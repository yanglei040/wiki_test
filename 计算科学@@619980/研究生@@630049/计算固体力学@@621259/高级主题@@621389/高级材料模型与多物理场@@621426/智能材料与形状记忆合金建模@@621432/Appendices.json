{"hands_on_practices": [{"introduction": "要真正掌握形状记忆合金 (SMA) 的计算建模，最好的方法莫过于从基本原理出发，亲手构建一个模型。本实践将指导您基于能量变分原理，为一维 SMA 杆开发一个有限元 (FE) 程序 [@problem_id:3600550]。通过这个练习，您将学习如何将亥姆霍兹自由能和耗散等热力学概念离散化，并利用交替最小化算法求解力学场与相变场之间的耦合问题，为理解更复杂的本构模型打下坚实的基础。", "problem": "考虑一根由形状记忆合金（SMA）制成的一维杆。该杆的长度为 $L$，具有恒定的横截面积 $A$，并在小应变运动学下进行建模。设轴向位移场为 $u(x)$，其中 $x \\in [0,L]$，小应变为 $\\varepsilon(x) = \\dfrac{du}{dx}$。该材料在奥氏体相中具有线性弹性响应，杨氏模量为 $E$，并经历大小为 $\\varepsilon_{\\mathrm{L}}$ 的单轴相变应变，该应变由马氏体体积分数 $\\xi(x) \\in [0,1]$ 调制，因此相变应变为 $\\varepsilon_{\\mathrm{tr}}(x) = \\varepsilon_{\\mathrm{L}} \\, \\xi(x)$。包含一个模量为 $H \\ge 0$ 的各向同性硬化贡献。$\\xi$ 的演化是率无关的，具有一个由类应力参数 $Y > 0$ 表征的恒定相变阻力。\n\n您的任务是基于能量变分法，为单个准静态载荷增量推导、离散化并实现一个有限元解。请使用以下基于原理的构建模块作为起点（问题陈述中不允许使用其他本构捷径）：\n- 小应变运动学 $\\varepsilon(x) = \\dfrac{du}{dx}$。\n- 率无关系统的准静态增量势能最小原理：在给定载荷步和先前内状态 $\\xi_{\\mathrm{prev}}(x)$ 的情况下，对 $(u,\\xi)$ 最小化由亥姆霍兹自由能加率无关耗散减去外力功组成的增量泛函。\n- 亥姆霍兹自由能密度由与弹性应变 $\\varepsilon - \\varepsilon_{\\mathrm{tr}}$ 相关的弹性应变能和依赖于 $\\xi$ 的各向同性硬化能组成。\n- 在增量上累积的率无关耗散是与绝对值变化 $|\\xi - \\xi_{\\mathrm{prev}}|$ 成正比的局部耗散密度的积分。\n\n施加本质（狄利克雷）边界条件 $u(0) = 0$ 和 $u(L) = U$，无外加面力，无体力。使用线性两节点有限元对杆进行离散化，每个单元使用一个常数内变量 $\\xi$，并对每个增量步采用交替最小化算法：对于固定的内变量场 $\\xi$，对 $u$ 进行最小化；对于更新后的位移 $u$，在箱式约束 $\\xi \\in [0,1]$ 的条件下，对每个单元常数 $\\xi$ 进行局部独立的最小化。您的实现必须：\n- 组装由关于 $u$ 的平稳性产生的全局线性系统，并施加狄利克雷边界条件。\n- 计算单元平均应变作为每个单元中的常应变。\n- 仅使用上述原理和一般凸分析思想（特别是，通过次梯度一致地处理绝对值耗散），对每个单元的 $\\xi$ 局部最小化增量泛函，并施加边界 $\\xi \\in [0,1]$。\n- 迭代这两个步骤，直到 $u$ 和 $\\xi$ 都收敛到严格的容差。\n\n所有情况均采用以下数据和单位：$E$ 单位为帕斯卡（$\\mathrm{Pa}$），$H$ 单位为帕斯卡（$\\mathrm{Pa}$），$Y$ 单位为帕斯卡（$\\mathrm{Pa}$），$L$ 单位为米（$\\mathrm{m}$），$U$ 单位为米（$\\mathrm{m}$），$\\varepsilon_{\\mathrm{L}}$ 无量纲，$A = 1$ 单位为平方米（$\\mathrm{m}^2$）。所有计算和答案都必须使用国际单位制（SI）。右端反力应以牛顿（$\\mathrm{N}$）为单位报告。本问题不涉及角度。马氏体分数是无量纲的。\n\n测试套件（请完全按照给定的数据使用）：\n- 案例 A（理想情况，部分相变）：$E = 4.0 \\times 10^{10}$，$H = 5.0 \\times 10^{8}$，$Y = 5.0 \\times 10^{7}$，$\\varepsilon_{\\mathrm{L}} = 6.0 \\times 10^{-2}$，$L = 1.0$，$N = 20$，$U = 3.0 \\times 10^{-2}$，$A = 1.0$。\n- 案例 B（亚阈值，无相变）：$E = 4.0 \\times 10^{10}$，$H = 5.0 \\times 10^{8}$，$Y = 5.0 \\times 10^{7}$，$\\varepsilon_{\\mathrm{L}} = 6.0 \\times 10^{-2}$，$L = 1.0$，$N = 20$，$U = 1.0 \\times 10^{-2}$，$A = 1.0$。\n- 案例 C（边界阈值）：$E = 4.0 \\times 10^{10}$，$H = 5.0 \\times 10^{8}$，$Y = 5.0 \\times 10^{7}$，$\\varepsilon_{\\mathrm{L}} = 6.0 \\times 10^{-2}$，$L = 1.0$，$N = 20$，$U = \\dfrac{Y}{E \\, \\varepsilon_{\\mathrm{L}}}$，$A = 1.0$。\n\n您的程序必须为每个案例计算收敛后杆上的马氏体分数空间平均值 $\\bar{\\xi}$（无量纲）和右端反力 $R$（单位为 $\\mathrm{N}$）。最终输出必须是单行，包含一个逗号分隔的列表，结果按 $[\\bar{\\xi}^{\\mathrm{A}}, R^{\\mathrm{A}}, \\bar{\\xi}^{\\mathrm{B}}, R^{\\mathrm{B}}, \\bar{\\xi}^{\\mathrm{C}}, R^{\\mathrm{C}}]$ 的顺序排列。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$）。所有值均报告为浮点数。对于 $R$，单位是 $\\mathrm{N}$；对于 $\\bar{\\xi}$，它是无量纲的。", "solution": "该问题要求对一维形状记忆合金（SMA）杆在准静态指定位移作用下，推导并实现一个有限元解。该公式基于率无关系统的增量势能最小原理。\n\n### **1. 理论公式**\n\n系统的状态由轴向位移场 $u(x)$ 和马氏体体积分数场 $\\xi(x)$ 描述。对于从初始状态（$u_{\\mathrm{prev}} = 0$，$\\xi_{\\mathrm{prev}} = 0$）开始的单个准静态载荷增量，我们寻求找到使总增量势能泛函 $\\Pi[u, \\xi]$ 最小化的对 $(u, \\xi)$。该泛函是亥姆霍兹自由能和在杆体积上积分的耗散能之和。\n\n小应变由运动学关系给出：\n$$ \\varepsilon(x) = \\frac{du}{dx} $$\n\n总应变 $\\varepsilon$ 可加法分解为弹性部分 $\\varepsilon_e$ 和相变部分 $\\varepsilon_{tr}$：\n$$ \\varepsilon = \\varepsilon_e + \\varepsilon_{tr} $$\n相变应变与马氏体分数 $\\xi$ 成正比：\n$$ \\varepsilon_{tr}(x) = \\varepsilon_{\\mathrm{L}} \\xi(x) $$\n其中 $\\varepsilon_{\\mathrm{L}}$ 是最大相变应变。\n\n亥姆霍兹自由能密度 $\\psi$ 包括一个弹性应变能项和一个各向同性硬化项：\n$$ \\psi(\\varepsilon, \\xi) = \\frac{1}{2} E (\\varepsilon - \\varepsilon_{tr})^2 + \\frac{1}{2} H \\xi^2 = \\frac{1}{2} E (\\varepsilon - \\varepsilon_{\\mathrm{L}} \\xi)^2 + \\frac{1}{2} H \\xi^2 $$\n其中 $E$ 是杨氏模量，$H$ 是硬化模量。\n\n对于第一个载荷增量，率无关耗散密度由 $\\mathcal{D}(\\xi, \\xi_{\\mathrm{prev}=0}) = Y |\\xi - 0|$ 给出。由于根据定义马氏体分数 $\\xi$ 是非负的（$\\xi \\in [0,1]$），这可以简化为：\n$$ \\mathcal{D}(\\xi) = Y \\xi $$\n其中 $Y$ 是恒定相变阻力。\n\n需要最小化的总增量势能泛函是：\n$$ \\Pi[u, \\xi] = \\int_0^L \\left[ \\psi(\\varepsilon(x), \\xi(x)) + \\mathcal{D}(\\xi(x)) \\right] A \\, dx $$\n$$ \\Pi[u, \\xi] = \\int_0^L \\left[ \\frac{1}{2} E \\left( \\frac{du}{dx} - \\varepsilon_{\\mathrm{L}} \\xi \\right)^2 + \\frac{1}{2} H \\xi^2 + Y \\xi \\right] A \\, dx $$\n约束条件为边界条件 $u(0) = 0$、$u(L) = U$ 和约束 $0 \\le \\xi(x) \\le 1$。\n\n### **2. 有限元离散化与算法方案**\n\n我们将长度为 $L$ 的杆离散化为 $N$ 个线性两节点有限元，每个单元的长度为 $h=L/N$。位移场 $u(x)$ 用分段线性函数近似，马氏体分数 $\\xi(x)$ 被视为分段常数，每个单元 $e$ 对应一个值 $\\xi_e$。\n\n离散化的泛函是所有单元的总和：\n$$ \\Pi^h(\\mathbf{u}, \\boldsymbol{\\xi}) = \\sum_{e=1}^N \\left[ \\frac{1}{2} E (\\varepsilon_e - \\varepsilon_{\\mathrm{L}} \\xi_e)^2 + \\frac{1}{2} H \\xi_e^2 + Y \\xi_e \\right] A h $$\n其中 $\\mathbf{u}$ 是节点位移向量，$\\boldsymbol{\\xi}$ 是单元马氏体分数的向量，$\\varepsilon_e = (u_i - u_{i-1})/h$ 是单元 $e$（连接节点 $i-1$ 和 $i$）中的常应变。\n\n我们采用交替最小化（或交错）算法来解决这个耦合的最小化问题。从一个初始猜测（例如 $\\boldsymbol{\\xi}^{(0)} = \\mathbf{0}$）开始，我们迭代两个步骤直到收敛：\n\n#### **步骤 1：位移更新 (u-步)**\n对于固定的马氏体场 $\\boldsymbol{\\xi} = \\boldsymbol{\\xi}^{(k)}$，我们找到使 $\\Pi^h(\\mathbf{u}, \\boldsymbol{\\xi}^{(k)})$ 最小化的位移场 $\\mathbf{u}^{(k+1)}$。这是一个标准的线性弹性问题，带有一个由相变应变产生的附加力项。最小化导出一个线性方程组 $\\mathbf{K}\\mathbf{u} = \\mathbf{f}_{tr}$，其中 $\\mathbf{K}$ 是全局刚度矩阵，$\\mathbf{f}_{tr}$ 是由相变应变引起的节点力向量。\n\n对于自由内部节点 $i=1, \\dots, N-1$，平衡方程为：\n$$ \\frac{EA}{h} (-u_{i-1} + 2u_i - u_{i+1}) = EA\\varepsilon_{\\mathrm{L}}(\\xi_{i-1} - \\xi_i) $$\n这里我们采用约定，单元 $i$ 连接节点 $i$ 和 $i+1$，其马氏体分数为 $\\xi_i$。在施加边界条件 $u_0=0$ 和 $u_N=U$ 后，我们求解得到的线性系统，以获得未知的内部节点位移 $u_1, \\dots, u_{N-1}$。\n\n#### **步骤 2：内变量更新 ($\\xi$-步)**\n对于固定的位移场 $\\mathbf{u} = \\mathbf{u}^{(k+1)}$，总泛函解耦为 $N$ 个独立的最小化问题，每个问题对应一个单元的 $\\xi_e$。我们找到使局部能量最小化的 $\\xi_e^{(k+1)}$：\n$$ \\pi_e(\\xi_e) = \\left[ \\frac{1}{2} E (\\varepsilon_e - \\varepsilon_{\\mathrm{L}} \\xi_e)^2 + \\frac{1}{2} H \\xi_e^2 + Y \\xi_e \\right] A h $$\n约束条件为 $0 \\le \\xi_e \\le 1$。现在每个单元中的应变 $\\varepsilon_e$ 是一个已知量，根据更新后的位移场 $\\mathbf{u}^{(k+1)}$ 计算得出。\n\n函数 $\\pi_e(\\xi_e)$ 是关于 $\\xi_e$ 的凸二次函数。通过将其导数设为零来找到其无约束最小值：\n$$ \\frac{d\\pi_e}{d\\xi_e} = \\left[ E(\\varepsilon_e - \\varepsilon_L \\xi_e)(-\\varepsilon_L) + H\\xi_e + Y \\right] A h = 0 $$\n$$ (E \\varepsilon_{\\mathrm{L}}^2 + H)\\xi_e - (E \\varepsilon_e \\varepsilon_{\\mathrm{L}} - Y) = 0 $$\n无约束最小化子为：\n$$ \\xi_e^* = \\frac{E \\varepsilon_e \\varepsilon_{\\mathrm{L}} - Y}{E \\varepsilon_{\\mathrm{L}}^2 + H} $$\n在约束 $\\xi_e \\in [0,1]$ 下的解是通过将 $\\xi_e^*$ 投影到该区间上得到的：\n$$ \\xi_e^{(k+1)} = \\max(0, \\min(1, \\xi_e^*)) $$\n\n迭代这两个步骤，直到 $\\mathbf{u}$ 和 $\\boldsymbol{\\xi}$ 的变化都低于选定的容差。\n\n### **3. 后处理**\n\n收敛后，我们计算所需的输出：\n- **平均马氏体分数 ($\\bar{\\xi}$)**：由于单元长度相等，这是单元值的算术平均值：\n$$ \\bar{\\xi} = \\frac{1}{N} \\sum_{e=1}^N \\xi_e $$\n- **右端反力 ($R$)**：这是在支座 $x=L$ 处的力，等于最后一个单元（$e=N$）中的轴向应力 $\\sigma_N$ 乘以面积 $A$。该应力由本构律给出：\n$$ R = A \\sigma_N = A E (\\varepsilon_N - \\varepsilon_{\\mathrm{L}} \\xi_N) $$\n其中 $\\varepsilon_N = (u_N - u_{N-1})/h$ 是最后一个单元中的应变。\n\n该方法为解决指定问题提供了一个鲁棒且物理上一致的框架。在没有体力的情况下，内部应力变得均匀，从而导致均匀的应变和马氏体分数场，这显著简化了交错格式的收敛行为。", "answer": "```python\nimport numpy as np\n\ndef run_simulation(E, H, Y, eps_L, L, N, U, A):\n    \"\"\"\n    Solves the 1D SMA bar problem using an alternate minimization scheme.\n\n    Args:\n        E (float): Young's modulus [Pa]\n        H (float): Hardening modulus [Pa]\n        Y (float): Transformation resistance [Pa]\n        eps_L (float): Transformation strain magnitude [-]\n        L (float): Bar length [m]\n        N (int): Number of elements\n        U (float): Prescribed displacement at right end [m]\n        A (float): Cross-sectional area [m^2]\n\n    Returns:\n        tuple: A tuple containing:\n            - xi_avg (float): Spatially averaged martensite fraction.\n            - R (float): Reaction force at the right end [N].\n    \"\"\"\n    # Discretization parameter\n    h = L / N\n\n    # Initialize fields\n    # u: displacement vector of size N+1 for nodes 0 to N\n    u = np.linspace(0.0, U, N + 1)\n    # xi: martensite fraction vector of size N for elements 0 to N-1\n    xi = np.zeros(N)\n\n    # Alternate-Minimization (Staggered) Loop\n    max_iter = 100\n    tolerance = 1e-10\n    \n    for k in range(max_iter):\n        u_old = u.copy()\n        xi_old = xi.copy()\n\n        # Step 1: Minimize w.r.t. displacement u (for fixed xi)\n        # We solve a linear system K_free * u_free = f_eff for the free\n        # internal nodes u[1],...,u[N-1].\n        \n        num_free_dofs = N - 1\n        if num_free_dofs > 0:\n            # Stiffness matrix for free nodes (N-1 x N-1)\n            K_free = (E * A / h) * (np.diag(np.full(num_free_dofs, 2.0)) - \n                                   np.diag(np.ones(num_free_dofs - 1), 1) - \n                                   np.diag(np.ones(num_free_dofs - 1), -1))\n            \n            # Effective force vector for free nodes\n            f_eff = np.zeros(num_free_dofs)\n            const_f = E * A * eps_L\n\n            # Element indices are 0 to N-1. Node indices are 0 to N.\n            # Element e is between node e and e+1.\n            # Internal node i is between element i-1 and i.\n            # Loop for nodes 1 to N-2\n            for i in range(1, N - 1):\n                f_eff[i-1] = const_f * (xi[i-1] - xi[i])\n            \n            # Last free node (N-1) gets force from xi and BC at u[N]\n            f_eff[N-2] = const_f * (xi[N-2] - xi[N-1]) + (E * A / h) * U\n\n            # Solve for internal displacements\n            u_free = np.linalg.solve(K_free, f_eff)\n            u[1:N] = u_free\n\n        # Step 2: Minimize w.r.t. internal variable xi (for fixed u)\n        # This is a local update for each element, indexed 0 to N-1.\n        \n        xi_denom = E * eps_L**2 + H\n        if xi_denom == 0: xi_denom = 1.0 # Avoid division by zero, though unlikely with H>=0, E>0\n\n        for e in range(N):\n            strain_e = (u[e+1] - u[e]) / h\n            xi_num = E * strain_e * eps_L - Y\n            xi_star = xi_num / xi_denom\n            xi[e] = np.clip(xi_star, 0.0, 1.0)\n\n        # Step 3: Check for convergence\n        u_err = np.linalg.norm(u - u_old)\n        xi_err = np.linalg.norm(xi - xi_old)\n        \n        u_norm = np.linalg.norm(u)\n        xi_norm = np.linalg.norm(xi)\n        \n        u_rel_err = u_err / u_norm if u_norm > tolerance else u_err\n        xi_rel_err = xi_err / xi_norm if xi_norm > tolerance else xi_err\n\n        if u_rel_err  tolerance and xi_rel_err  tolerance:\n            break\n            \n    # Post-processing after convergence\n    xi_avg = np.mean(xi)\n    \n    # Reaction force R = A * sigma_N = A * E * (epsilon_N - eps_L * xi_N)\n    strain_last_elem = (u[N] - u[N-1]) / h\n    # The last element is indexed N-1\n    xi_last_elem = xi[N-1]\n    R = A * E * (strain_last_elem - eps_L * xi_last_elem)\n    \n    return xi_avg, R\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results.\n    \"\"\"\n    params_A = {'E': 4.0e10, 'H': 5.0e8, 'Y': 5.0e7, 'eps_L': 6.0e-2, \n                'L': 1.0, 'N': 20, 'U': 3.0e-2, 'A': 1.0}\n    params_B = {'E': 4.0e10, 'H': 5.0e8, 'Y': 5.0e7, 'eps_L': 6.0e-2, \n                'L': 1.0, 'N': 20, 'U': 1.0e-2, 'A': 1.0}\n    \n    # For Case C, U is defined by a formula\n    E_C, Y_C, eps_L_C = 4.0e10, 5.0e7, 6.0e-2\n    U_C = Y_C / (E_C * eps_L_C)\n    params_C = {'E': E_C, 'H': 5.0e8, 'Y': Y_C, 'eps_L': eps_L_C, \n                'L': 1.0, 'N': 20, 'U': U_C, 'A': 1.0}\n    \n    test_cases = [params_A, params_B, params_C]\n    \n    results = []\n    for params in test_cases:\n        xi_avg, R = run_simulation(**params)\n        results.extend([xi_avg, R])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3600550"}, {"introduction": "在隐式有限元分析中，计算效率和收敛性至关重要，而这在很大程度上取决于本构模型的一致切线模量。本练习聚焦于从热力学势函数出发，推导并实现伪弹性 SMA 模型在相变过程中的一致算法切线模量 $\\mathbb{C}_{\\mathrm{alg}}$ [@problem_id:3600551]。这项实践不仅能加深您对材料在相变过程中刚度变化的理解，还能让您掌握提升非线性有限元求解器鲁棒性和二次收敛速度的关键技术。", "problem": "你的任务是在计算固体力学框架内，从热力学一致性原理出发，推导并实现伪弹性形状记忆合金（SMA）的一维一致性算法切线。一致性算法切线定义为应力对应变的导数，该导数由精确的增量应力更新算法计算得出，此时内变量（马氏体体积分数）在相变一致性条件下演化。你的推导和实现必须在科学上是合理的，并遵循基本的热力学和力学原理。实现必须为指定的测试套件生成数值上可测试的结果。\n\n考虑一根由伪弹性 SMA 制成的一维杆，承受施加的微小应变增量。设亥姆霍兹自由能密度定义为\n$$\n\\psi(\\varepsilon,\\xi,T) = \\tfrac{1}{2} E \\left(\\varepsilon - \\Lambda \\xi\\right)^2 + \\tfrac{1}{2} H \\xi^2 - s_0 \\left(T - T_0\\right)\\xi,\n$$\n其中 $E$ 是杨氏模量，$\\varepsilon$ 是总应变，$\\Lambda$ 是最大相变应变幅值，$\\xi \\in [0,1]$ 是马氏体体积分数， $H$ 是相变硬化模量， $s_0$ 是热耦合系数， $T$ 是绝对温度， $T_0$ 是参考温度。柯西应力由标准热力学关系得到\n$$\n\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = E \\left(\\varepsilon - \\Lambda \\xi\\right).\n$$\n正向相变的热力学驱动力定义为\n$$\nr = -\\frac{\\partial \\psi}{\\partial \\xi} = E \\Lambda \\left(\\varepsilon - \\Lambda \\xi\\right) - H \\xi + s_0 \\left(T - T_0\\right),\n$$\n并且当通过 Kuhn-Tucker 条件强制执行正向相变函数的一致性条件时，正向相变被激活：正向相变函数 $f = r - R_{\\mathrm{fwd}}$ 满足 $f \\le 0$，正向相变速率 $\\dot{\\xi} \\ge 0$，以及互补条件 $f \\, \\dot{\\xi} = 0$。当 $\\dot{\\xi} > 0$ 时，一致性要求 $f = 0$。\n\n你的任务是：\n- 从给定的自由能出发，推导在激活的正向相变一致性条件下，应力更新和 $\\xi$ 的演化，确保容许性 $\\xi \\in [0,1]$ 和正向相变增量的单调性。明确推导一致性算法切线，定义为 $\\mathbb{C}_{\\mathrm{alg}} = \\dfrac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon}$，包括弹性区域（无相变）和激活的正向相变区域（非饱和）。\n- 实现一个鲁棒的一维更新算法，对于给定的应变 $\\varepsilon$、温度 $T$ 和上一步的马氏体分数 $\\xi^{\\mathrm{prev}}$，返回更新后的应力 $\\sigma$、更新后的分数 $\\xi$ 以及适用于有限元法（FEM）中牛顿-拉夫逊迭代的一致性算法切线 $\\mathbb{C}_{\\mathrm{alg}}$。\n- 更新必须遵循以下步骤：\n  - 使用 $\\xi^{\\mathrm{prev}}$ 计算试探驱动力 $r$。\n  - 如果 $r \\le R_{\\mathrm{fwd}}$ 或 $\\xi^{\\mathrm{prev}} \\ge 1$，则该步为弹性步，此时 $\\xi = \\xi^{\\mathrm{prev}}$，$\\sigma = E (\\varepsilon - \\Lambda \\xi)$，且 $\\mathbb{C}_{\\mathrm{alg}} = E$。\n  - 如果 $r > R_{\\mathrm{fwd}}$ 且 $\\xi^{\\mathrm{prev}}  1$，则强制一致性条件 $r = R_{\\mathrm{fwd}}$ 以获得更新后的 $\\xi$；将其限制在容许区间内，并强制正向单调性 $\\xi \\ge \\xi^{\\mathrm{prev}}$。如果更新值被限制在 $\\xi=1$，则设置 $\\mathbb{C}_{\\mathrm{alg}} = E$，否则使用推导出的激活区域的 $\\mathbb{C}_{\\mathrm{alg}}$。\n\n使用的物理和数值参数如下：\n- $E = 70 \\times 10^{9}$ $\\,\\mathrm{Pa}$，\n- $\\Lambda = 0.06$，\n- $H = 0.5 \\times 10^{9}$ $\\,\\mathrm{Pa}$，\n- $s_0 = 5 \\times 10^{6}$ $\\,\\mathrm{Pa/K}$，\n- $R_{\\mathrm{fwd}} = 150 \\times 10^{6}$ $\\,\\mathrm{Pa}$，\n- $T_0 = 293$ $\\,\\mathrm{K}$。\n\n设绝对温度单位为开尔文，应变为无量纲。应力和算法切线必须以帕斯卡（$\\,\\mathrm{Pa}$）表示。马氏体分数 $\\xi$ 是无量纲的。\n\n测试套件：\n- 情况 1（弹性区域）：$\\varepsilon = 0.005$, $T = 293$, $\\xi^{\\mathrm{prev}} = 0.0$。\n- 情况 2（激活的非饱和相变）：$\\varepsilon = 0.02$, $T = 323$, $\\xi^{\\mathrm{prev}} = 0.0$。\n- 情况 3（具有非零初始分数的激活相变）：$\\varepsilon = 0.03$, $T = 373$, $\\xi^{\\mathrm{prev}} = 0.3$。\n- 情况 4（饱和相变）：$\\varepsilon = 0.04$, $T = 493$, $\\xi^{\\mathrm{prev}} = 0.8$。\n\n你的程序必须为每种情况计算三元组 $[\\sigma, \\mathbb{C}_{\\mathrm{alg}}, \\xi]$，其中 $\\sigma$ 和 $\\mathbb{C}_{\\mathrm{alg}}$ 四舍五入到最接近的整数（单位为 $\\,\\mathrm{Pa}$），$\\xi$ 四舍五入到六位小数。你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是对应于一个测试用例的列表。例如：$[\\,[\\sigma_1, \\mathbb{C}_1, \\xi_1], [\\sigma_2, \\mathbb{C}_2, \\xi_2], [\\sigma_3, \\mathbb{C}_3, \\xi_3], [\\sigma_4, \\mathbb{C}_4, \\xi_4]\\,]$。", "solution": "该问题陈述经评估有效。它在科学上基于连续介质热力学原理，特别是用于伪弹性形状记忆合金（SMA）的建模，是计算固体力学中一个适定问题。算法所需的所有参数和逻辑步骤都已提供，并且没有内部矛盾或事实错误。\n\n解决方案首先推导必要的本构更新方程和一致性算法切线，然后总结数值算法。\n\n材料状态由总应变 $\\varepsilon$、马氏体体积分数 $\\xi$ 和绝对温度 $T$ 描述。亥姆霍兹自由能密度 $\\psi$ 由下式给出：\n$$\n\\psi(\\varepsilon,\\xi,T) = \\tfrac{1}{2} E \\left(\\varepsilon - \\Lambda \\xi\\right)^2 + \\tfrac{1}{2} H \\xi^2 - s_0 \\left(T - T_0\\right)\\xi\n$$\n其中 $E$ 是杨氏模量，$\\Lambda$ 是最大相变应变， $H$ 是相变硬化模量， $s_0$ 是热机耦合系数， $T_0$ 是参考温度。\n\n柯西应力 $\\sigma$ 和相变的热力学驱动力 $r$ 由标准热力学关系推导得出：\n$$\n\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = E \\left(\\varepsilon - \\Lambda \\xi\\right)\n$$\n$$\nr = -\\frac{\\partial \\psi}{\\partial \\xi} = E \\Lambda \\left(\\varepsilon - \\Lambda \\xi\\right) - H \\xi + s_0 \\left(T - T_0\\right)\n$$\n当驱动力 $r$ 达到临界阈值 $R_{\\mathrm{fwd}}$ 时，发生从奥氏体到马氏体的正向相变（$\\dot{\\xi} > 0$）。这由正向相变函数 $f = r - R_{\\mathrm{fwd}}$ 的 Kuhn-Tucker 条件控制：\n$$\nf \\le 0, \\quad \\dot{\\xi} \\ge 0, \\quad f \\dot{\\xi} = 0\n$$\n此外，马氏体分数在物理上被限制在区间 $\\xi \\in [0,1]$ 内。\n\n对于给定的应变增量，本构更新算法如下进行。给定一个步骤开始时的状态 $(\\xi^{\\mathrm{prev}})$ 以及新的总应变 $\\varepsilon$ 和温度 $T$，我们首先假设马氏体分数没有变化（即 $\\xi = \\xi^{\\mathrm{prev}}$），计算试探驱动力：\n$$\nr_{\\mathrm{trial}} = E \\Lambda (\\varepsilon - \\Lambda \\xi^{\\mathrm{prev}}) - H \\xi^{\\mathrm{prev}} + s_0(T - T_0)\n$$\n\n如果 $r_{\\mathrm{trial}} \\le R_{\\mathrm{fwd}}$ 或者材料已经完全马氏体化（$\\xi^{\\mathrm{prev}} \\ge 1$），则该步为弹性步（没有进一步的相变发生）。在这种情况下，马氏体分数保持不变，即 $\\xi = \\xi^{\\mathrm{prev}}$。\n\n如果 $r_{\\mathrm{trial}} > R_{\\mathrm{fwd}}$ 且 $\\xi^{\\mathrm{prev}}  1$，则发生正向相变。$\\xi$ 的演化由一致性条件控制，该条件规定在激活相变期间，驱动力必须保持在阈值，即 $r = R_{\\mathrm{fwd}}$。我们求解满足此条件的 $\\xi$ 值：\n$$\nE \\Lambda \\left(\\varepsilon - \\Lambda \\xi\\right) - H \\xi + s_0 \\left(T - T_0\\right) = R_{\\mathrm{fwd}}\n$$\n这是一个关于 $\\xi$ 的线性方程。重新整理各项以求解 $\\xi$：\n$$\nE \\Lambda \\varepsilon + s_0(T-T_0) - R_{\\mathrm{fwd}} = (E \\Lambda^2 + H) \\xi\n$$\n$$\n\\xi_{\\mathrm{consistency}} = \\frac{E \\Lambda \\varepsilon + s_0(T-T_0) - R_{\\mathrm{fwd}}}{E \\Lambda^2 + H}\n$$\n最终更新的马氏体分数 $\\xi$ 必须遵守物理边界，因此如果达到完全相变，我们将值限制在 $\\xi=1$。单调性条件 $\\xi \\ge \\xi^{\\mathrm{prev}}$ 通过仅在 $r_{\\mathrm{trial}} > R_{\\mathrm{fwd}}$ 时激活相变来隐式满足。因此，更新后的分数为：\n$$\n\\xi = \\min\\left(1, \\xi_{\\mathrm{consistency}}\\right)\n$$\n\n一致性算法切线 $\\mathbb{C}_{\\mathrm{alg}} = \\frac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon}$ 是隐式有限元求解器所必需的。它是增量步结束时的应力相对于增量步结束时总应变的导数。\n\n**1. 弹性与饱和区域**\n在弹性区域，$\\xi$ 相对于 $\\varepsilon$ 的变化是恒定的（即 $\\xi = \\xi^{\\mathrm{prev}}$）。在饱和区域也是如此，此时 $\\xi$ 被限制在 $1$。在这两种情况下，$\\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} = 0$。\n应力的导数则很简单：\n$$\n\\mathbb{C}_{\\mathrm{alg}} = \\frac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon} = \\frac{\\mathrm{d}}{\\mathrm{d}\\varepsilon} \\left[ E \\left(\\varepsilon - \\Lambda \\xi\\right) \\right] = E \\left(1 - \\Lambda \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon}\\right) = E(1 - 0)\n$$\n$$\n\\mathbb{C}_{\\mathrm{alg}} = E\n$$\n\n**2. 激活的非饱和相变区域**\n在此区域，$\\xi$ 作为 $\\varepsilon$ 的函数演化，以维持一致性条件 $r = R_{\\mathrm{fwd}}$。为了求得 $\\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon}$，我们对一致性条件关于 $\\varepsilon$ 求导，在求导过程中将 $T$ 视为固定参数：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}\\varepsilon} \\left[ E \\Lambda \\left(\\varepsilon - \\Lambda \\xi(\\varepsilon)\\right) - H \\xi(\\varepsilon) + s_0 \\left(T - T_0\\right) - R_{\\mathrm{fwd}} \\right] = 0\n$$\n$$\nE \\Lambda - E \\Lambda^2 \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} - H \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} = 0\n$$\n求解 $\\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon}$：\n$$\nE \\Lambda = \\left( E \\Lambda^2 + H \\right) \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} \\implies \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} = \\frac{E \\Lambda}{E \\Lambda^2 + H}\n$$\n将此代入应力导数方程：\n$$\n\\mathbb{C}_{\\mathrm{alg}} = E \\left(1 - \\Lambda \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon}\\right) = E \\left(1 - \\Lambda \\left(\\frac{E \\Lambda}{E \\Lambda^2 + H}\\right)\\right)\n$$\n$$\n\\mathbb{C}_{\\mathrm{alg}} = E \\left( \\frac{E \\Lambda^2 + H - E \\Lambda^2}{E \\Lambda^2 + H} \\right) = \\frac{E H}{E \\Lambda^2 + H}\n$$\n这是激活的、非饱和相变区域的一致性算法切线。它代表了材料在相变过程中的折减刚度。\n\n总而言之，待实现的算法是：\n1.  使用 $\\varepsilon$、 $T$ 和 $\\xi^{\\mathrm{prev}}$ 计算 $r_{\\mathrm{trial}}$。\n2.  如果 $r_{\\mathrm{trial}} \\le R_{\\mathrm{fwd}}$ 或 $\\xi^{\\mathrm{prev}} \\ge 1$：\n    - $\\xi = \\xi^{\\mathrm{prev}}$\n    - $\\mathbb{C}_{\\mathrm{alg}} = E$\n3.  否则（激活相变）：\n    - 根据推导的公式计算 $\\xi_{\\mathrm{consistency}}$。\n    - 设置 $\\xi = \\min(1, \\xi_{\\mathrm{consistency}})$。\n    - 如果 $\\xi = 1$ （饱和），$\\mathbb{C}_{\\mathrm{alg}} = E$。\n    - 如果 $\\xi  1$ （非饱和），$\\mathbb{C}_{\\mathrm{alg}} = \\frac{EH}{E \\Lambda^2 + H}$。\n4.  在所有情况下，最终应力计算为 $\\sigma = E(\\varepsilon - \\Lambda \\xi)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef update_sma_state(epsilon, T, xi_prev, params):\n    \"\"\"\n    Computes the updated stress, algorithmic tangent, and martensitic fraction for a 1D SMA.\n\n    Args:\n        epsilon (float): Total strain.\n        T (float): Absolute temperature in Kelvin.\n        xi_prev (float): Martensitic fraction from the previous step.\n        params (dict): Dictionary of material parameters.\n\n    Returns:\n        tuple: A tuple containing the updated stress (sigma, Pa), consistent\n               algorithmic tangent (C_alg, Pa), and martensitic fraction (xi).\n    \"\"\"\n    E = params['E']\n    Lambda = params['Lambda']\n    H = params['H']\n    s0 = params['s0']\n    R_fwd = params['R_fwd']\n    T0 = params['T0']\n\n    # Step 1: Compute trial driving force\n    r_trial = E * Lambda * (epsilon - Lambda * xi_prev) - H * xi_prev + s0 * (T - T0)\n    \n    # Step 2: Check for elastic response\n    if r_trial = R_fwd or xi_prev >= 1.0:\n        xi = xi_prev\n        C_alg = E\n        sigma = E * (epsilon - Lambda * xi)\n        return sigma, C_alg, xi\n    \n    # Step 3: Active transformation\n    else:\n        # Denominator for xi_consistency and C_alg calculation\n        denom = E * Lambda**2 + H\n        \n        # Calculate xi from the consistency condition\n        xi_consistency = (E * Lambda * epsilon + s0 * (T - T0) - R_fwd) / denom\n        \n        # Clamp xi to be at most 1.0. Monotonicity (xi >= xi_prev) is guaranteed\n        # by the r_trial > R_fwd condition.\n        xi = min(1.0, xi_consistency)\n        \n        # Calculate the consistent algorithmic tangent\n        if xi >= 1.0:\n            # Saturated transformation, tangent reverts to elastic modulus\n            C_alg = E\n        else:\n            # Active, unsaturated transformation\n            C_alg = (E * H) / denom\n        \n        # Calculate the final stress\n        sigma = E * (epsilon - Lambda * xi)\n        \n        return sigma, C_alg, xi\n\ndef solve():\n    \"\"\"\n    Main function to run the SMA model for the specified test suite.\n    \"\"\"\n    # Define physical and numerical parameters\n    params = {\n        'E': 70e9,       # Pa\n        'Lambda': 0.06,  # dimensionless\n        'H': 0.5e9,      # Pa\n        's0': 5e6,       # Pa/K\n        'R_fwd': 150e6,  # Pa\n        'T0': 293.0      # K\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.005, 293, 0.0), # Case 1 (elastic regime)\n        (0.02,  323, 0.0), # Case 2 (active unsaturated transformation)\n        (0.03,  373, 0.3), # Case 3 (active with nonzero previous fraction)\n        (0.04,  493, 0.8)  # Case 4 (saturated transformation)\n    ]\n\n    results = []\n    for case in test_cases:\n        epsilon_input, T_input, xi_prev_input = case\n        \n        # Get the updated state variables\n        sigma, C_alg, xi = update_sma_state(epsilon_input, T_input, xi_prev_input, params)\n        \n        # Round results to the specified precision\n        sigma_rounded = int(round(sigma))\n        C_alg_rounded = int(round(C_alg))\n        xi_rounded = round(xi, 6)\n        \n        results.append([sigma_rounded, C_alg_rounded, xi_rounded])\n\n    # Final print statement in the exact required format.\n    # The default str representation of a list includes spaces. We build the string manually.\n    results_str = ','.join([f\"[{s},{c},{x}]\" for s, c, x in results])\n    print(f\"[{results_str}]\")\n\nsolve()\n```", "id": "3600551"}, {"introduction": "许多工程应用涉及大变形，因此将 SMA 模型从微应变框架推广到有限应变框架是至关重要的一步。本实践将带您进入三维有限应变领域，探索如何通过变形梯度的乘法分解来处理几何非线性 [@problem_id:3600572]。您将使用可压缩 Neo-Hookean 弹性能模型，并结合一个依赖于速率的相变动力学法则，来构建一个更为真实的 SMA 本构更新程序。这个练习将显著拓宽您的建模视野，使您能够处理更具挑战性的真实世界问题。", "problem": "考虑一个正在经历有限应变变形的三维形状记忆合金 (SMA)。令变形梯度表示为 $\\mathbf{F} \\in \\mathbb{R}^{3 \\times 3}$，且 $\\det(\\mathbf{F}) > 0$。假设马氏体相变只有一个与第一主方向对齐的晶体学变体，并采用变形梯度的乘法分解，将其分解为弹性和相变两部分：\n$$\n\\mathbf{F} = \\mathbf{F}_{\\mathrm{e}} \\, \\mathbf{F}_{\\mathrm{tr}},\n$$\n其中 $\\mathbf{F}_{\\mathrm{tr}}$ 是相变拉伸，$\\mathbf{F}_{\\mathrm{e}}$ 是弹性部分。内变量是马氏体体积分数 $\\xi \\in [0,1]$。相变拉伸被规定为等容的，并与第一基方向对齐：\n$$\n\\mathbf{F}_{\\mathrm{tr}}(\\xi) = \\mathrm{diag}\\left(1 + \\beta \\, \\xi, \\frac{1}{\\sqrt{1 + \\beta \\, \\xi}}, \\frac{1}{\\sqrt{1 + \\beta \\, \\xi}}\\right),\n$$\n参数 $\\beta > 0$，因此对于所有 $\\xi \\in [0,1]$，$\\det\\left(\\mathbf{F}_{\\mathrm{tr}}(\\xi)\\right) = 1$。弹性响应由一个可压缩 Neo-Hookean 自由能密度（单位参考体积）建模，以弹性部分 $\\mathbf{F}_{\\mathrm{e}}$ 表示：\n$$\n\\psi_{\\mathrm{e}}(\\mathbf{F}_{\\mathrm{e}}) = \\frac{\\mu}{2}\\left(\\mathrm{tr}\\left(\\mathbf{b}_{\\mathrm{e}}\\right) - 3\\right) - \\mu \\ln J_{\\mathrm{e}} + \\frac{\\kappa}{2}\\left(\\ln J_{\\mathrm{e}}\\right)^2,\n$$\n其中 $\\mathbf{b}_{\\mathrm{e}} = \\mathbf{F}_{\\mathrm{e}} \\mathbf{F}_{\\mathrm{e}}^{\\mathsf{T}}$，$J_{\\mathrm{e}} = \\det(\\mathbf{F}_{\\mathrm{e}})$，$\\mu$ 是剪切模量，$\\kappa$ 是体积模量。假设相变硬化对自由能的贡献取决于温度 $T$：\n$$\n\\psi_{\\mathrm{tr}}(\\xi, T) = A \\, \\xi + \\frac{H}{2} \\, \\xi^2 + \\Theta \\, (T - T_0) \\, \\xi,\n$$\n其中 $A$ 是一个常数偏移量，$H > 0$ 是一个硬化模量，$\\Theta > 0$ 衡量热影响的尺度，$T_0$ 是一个参考温度。总亥姆霍兹自由能为\n$$\n\\psi(\\mathbf{F}, \\xi, T) = \\psi_{\\mathrm{e}}\\!\\left(\\mathbf{F}_{\\mathrm{e}}(\\mathbf{F}, \\xi)\\right) + \\psi_{\\mathrm{tr}}(\\xi, T),\n$$\n其中 $\\mathbf{F}_{\\mathrm{e}}(\\mathbf{F}, \\xi) = \\mathbf{F}\\,\\mathbf{F}_{\\mathrm{tr}}(\\xi)^{-1}$。克劳修斯-杜亥姆不等式和 Coleman–Noll 程序得出 Kirchhoff 应力\n$$\n\\boldsymbol{\\tau} = \\mu\\left(\\mathbf{b}_{\\mathrm{e}} - \\mathbf{I}\\right) + \\kappa \\, \\ln J_{\\mathrm{e}} \\, \\mathbf{I},\n$$\n以及与 $\\xi$ 共轭的热力学驱动力，定义为\n$$\np = -\\frac{\\partial \\psi}{\\partial \\xi}.\n$$\n假设一个率相关的相变动力学，具有正向和反向阈值：\n- 正向（奥氏体 $\\rightarrow$ 马氏体）：如果 $p > R_{\\mathrm{f}}$，则 $\\dot{\\xi} = L_{\\mathrm{f}} \\left(p - R_{\\mathrm{f}}\\right)$，\n- 反向（马氏体 $\\rightarrow$ 奥氏体）：如果 $p  -R_{\\mathrm{r}}$，则 $\\dot{\\xi} = L_{\\mathrm{r}} \\left(p + R_{\\mathrm{r}}\\right)$，\n否则 $\\dot{\\xi} = 0$，其中 $R_{\\mathrm{f}} > 0$，$R_{\\mathrm{r}} > 0$，$L_{\\mathrm{f}} > 0$，$L_{\\mathrm{r}} > 0$。在一个大小为 $\\Delta t$ 的离散时间步长内，更新方式为\n$$\n\\xi_{\\mathrm{new}} = \\mathrm{clip}\\left(\\xi_{\\mathrm{old}} + \\dot{\\xi} \\, \\Delta t, \\, 0, \\, 1\\right).\n$$\n更新后，通过 $\\boldsymbol{\\tau}$ 计算 Cauchy 应力 $\\boldsymbol{\\sigma}$：\n$$\n\\boldsymbol{\\sigma} = \\frac{1}{J_{\\mathrm{e}}} \\, \\boldsymbol{\\tau},\n$$\n并报告 von Mises 等效应力\n$$\n\\sigma_{\\mathrm{vM}} = \\sqrt{\\frac{3}{2} \\, \\boldsymbol{s}:\\boldsymbol{s}}, \\quad \\boldsymbol{s} = \\boldsymbol{\\sigma} - \\frac{1}{3} \\, \\mathrm{tr}(\\boldsymbol{\\sigma}) \\, \\mathbf{I}.\n$$\n您的程序必须在单个增量中实现上述本构更新，如下所示：\n- 计算 $\\psi(\\mathbf{F}, \\xi, T)$。\n- 使用关于 $\\xi$ 的一个小的增量，通过二阶中心有限差分数值近似 $p = -\\partial \\psi/\\partial \\xi$：\n  $$\n  p \\approx -\\frac{\\psi(\\xi + \\varepsilon) - \\psi(\\xi - \\varepsilon)}{2 \\varepsilon},\n  $$\n  在边界 $\\xi = 0$ 和 $\\xi = 1$ 附近使用适当的单边差分。\n- 使用动力学定律更新 $\\xi$ 并将其裁剪到 $[0,1]$ 区间内。\n- 使用更新后的 $\\xi$ 计算 $\\boldsymbol{\\sigma}$ 和 $\\sigma_{\\mathrm{vM}}$。\n采用以下材料和动力学参数（使用所述物理单位）：\n- 剪切模量：$\\mu = 26000 \\ \\mathrm{MPa}$，\n- 体积模量：$\\kappa = 130000 \\ \\mathrm{MPa}$，\n- 相变幅度：$\\beta = 0.06$（无量纲），\n- 硬化模量：$H = 75 \\ \\mathrm{MPa}$，\n- 偏移量：$A = 0 \\ \\mathrm{MPa}$，\n- 热系数：$\\Theta = 0.8 \\ \\mathrm{MPa/K}$，\n- 参考温度：$T_0 = 298 \\ \\mathrm{K}$，\n- 正向阈值：$R_{\\mathrm{f}} = 5 \\ \\mathrm{MPa}$，\n- 反向阈值：$R_{\\mathrm{r}} = 5 \\ \\mathrm{MPa}$，\n- 正向速率：$L_{\\mathrm{f}} = 0.15 \\ \\mathrm{(MPa \\cdot s)^{-1}}$，\n- 反向速率：$L_{\\mathrm{r}} = 0.15 \\ \\mathrm{(MPa \\cdot s)^{-1}}$，\n- 时间步长：$\\Delta t = 1.0 \\ \\mathrm{s}$，\n- 数值微分增量：$\\varepsilon = 10^{-6}$（无量纲）。\n测试套件。对于每种情况，给定变形梯度 $\\mathbf{F}$（无量纲）、温度 $T$（单位 K）和初始马氏体分数 $\\xi_0$（无量纲）：\n- 情况 1（理想路径，可能发生正向相变）：\n  $$\n  \\mathbf{F} = \\begin{bmatrix} 1.06  0.01  0 \\\\ 0  0.971  0 \\\\ 0  0  0.971 \\end{bmatrix}, \\quad T = 300, \\quad \\xi_0 = 0.\n  $$\n- 情况 2（边界情况，高温无载荷下不发生相变）：\n  $$\n  \\mathbf{F} = \\mathbf{I}, \\quad T = 340, \\quad \\xi_0 = 0.\n  $$\n- 情况 3（边缘情况，低温下有强烈的正向相变趋势）：\n  $$\n  \\mathbf{F} = \\begin{bmatrix} 1.08  0  0 \\\\ 0  0.962  0 \\\\ 0  0  0.962 \\end{bmatrix}, \\quad T = 280, \\quad \\xi_0 = 0.3.\n  $$\n- 情况 4（高温、近无载荷构型下，从完全相变状态发生反向相变）：\n  $$\n  \\mathbf{F} = \\begin{bmatrix} 0.995  0  0 \\\\ 0  1.005  0 \\\\ 0  0  1.0 \\end{bmatrix}, \\quad T = 360, \\quad \\xi_0 = 1.0.\n  $$\n要求输出。对于每个测试用例，输出一对 $[\\xi_{\\mathrm{new}}, \\sigma_{\\mathrm{vM}}]$，其中 $\\xi_{\\mathrm{new}}$ 是无量纲的，$\\sigma_{\\mathrm{vM}}$ 的单位是 $\\mathrm{MPa}$。$\\sigma_{\\mathrm{vM}}$ 以 $\\mathrm{MPa}$ 表示，并将 $\\xi_{\\mathrm{new}}$ 和 $\\sigma_{\\mathrm{vM}}$ 均四舍五入到三位小数。您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，例如 $[\\,[\\xi_1,\\sigma_{\\mathrm{vM},1}],\\,[\\xi_2,\\sigma_{\\mathrm{vM},2}],\\,\\ldots\\,]$。", "solution": "用户提供了一个科学基础扎实、问题提出得当且客观的问题陈述。它基于成熟的连续介质力学原理，概述了一个用于描述形状记忆合金 (SMA) 有限应变的综合本构模型。该模型包含变形梯度的乘法分解、一个可压缩的 Neo-Hookean 弹性能以及一个用于描述相变硬化和动力学的唯象模型。单步时间增量所需的所有方程、材料参数和边界条件都得到了明确的规定。所提供的测试用例在物理上是合理的，用于验证实现在不同材料行为区间（正向相变、反向相变和无相变）的正确性。因此，该问题被认为是有效的，并将提供解决方案。\n\n该解决方案框架以单步显式本构更新的方式实现。该过程从初始状态 $(\\mathbf{F}, \\xi_0, T)$ 开始，计算在时间增量 $\\Delta t$ 后的最终状态 $(\\xi_{\\mathrm{new}}, \\boldsymbol{\\sigma}_{\\mathrm{new}})$。\n\n总亥姆霍兹自由能密度 $\\psi$ 是弹性部分 $\\psi_{\\mathrm{e}}$ 和相变部分 $\\psi_{\\mathrm{tr}}$ 的总和：\n$$\n\\psi(\\mathbf{F}, \\xi, T) = \\psi_{\\mathrm{e}}\\!\\left(\\mathbf{F}_{\\mathrm{e}}(\\mathbf{F}, \\xi)\\right) + \\psi_{\\mathrm{tr}}(\\xi, T)\n$$\n弹性部分取决于弹性变形梯度 $\\mathbf{F}_{\\mathrm{e}} = \\mathbf{F}\\,\\mathbf{F}_{\\mathrm{tr}}(\\xi)^{-1}$，其中 $\\mathbf{F}_{\\mathrm{tr}}$ 是相变拉伸。\n$$\n\\psi_{\\mathrm{e}}(\\mathbf{F}_{\\mathrm{e}}) = \\frac{\\mu}{2}\\left(\\mathrm{tr}\\left(\\mathbf{b}_{\\mathrm{e}}\\right) - 3\\right) - \\mu \\ln J_{\\mathrm{e}} + \\frac{\\kappa}{2}\\left(\\ln J_{\\mathrm{e}}\\right)^2\n$$\n其中 $\\mathbf{b}_{\\mathrm{e}} = \\mathbf{F}_{\\mathrm{e}} \\mathbf{F}_{\\mathrm{e}}^{\\mathsf{T}}$ 且 $J_{\\mathrm{e}} = \\det(\\mathbf{F}_{\\mathrm{e}})$。相变部分由以下公式给出：\n$$\n\\psi_{\\mathrm{tr}}(\\xi, T) = A \\, \\xi + \\frac{H}{2} \\, \\xi^2 + \\Theta \\, (T - T_0) \\, \\xi\n$$\n\n更新程序的核心在于确定马氏体体积分数 $\\xi$ 的演化。这由与 $\\xi$ 共轭的热力学驱动力 $p$ 控制，定义为：\n$$\np = -\\frac{\\partial \\psi}{\\partial \\xi}\n$$\n该实现将遵循规定的数值算法来求解更新后的状态。\n\n**步骤 1：计算热力学驱动力 $p$**\n在当前状态 $(\\mathbf{F}, \\xi_0, T)$ 下的驱动力 $p$ 是通过数值方法计算的。问题指定了偏导数的有限差分近似。对于内部点，使用二阶中心差分；在边界 $\\xi=0$ 和 $\\xi=1$ 处，使用适当的单边差分，以维持 $\\xi$ 的物理域。令 $\\xi_{\\mathrm{old}} = \\xi_0$。\n\n- 如果 $0  \\xi_{\\mathrm{old}}  1$：\n$$\np(\\xi_{\\mathrm{old}}) \\approx -\\frac{\\psi(\\xi_{\\mathrm{old}} + \\varepsilon) - \\psi(\\xi_{\\mathrm{old}} - \\varepsilon)}{2 \\varepsilon}\n$$\n- 如果 $\\xi_{\\mathrm{old}} = 0$：使用一阶前向差分。\n$$\np(0) \\approx -\\frac{\\psi(\\varepsilon) - \\psi(0)}{\\varepsilon}\n$$\n- 如果 $\\xi_{\\mathrm{old}} = 1$：使用一阶后向差分。\n$$\np(1) \\approx -\\frac{\\psi(1) - \\psi(1 - \\varepsilon)}{\\varepsilon}\n$$\n这里，$\\psi(\\xi)$ 意味着对于给定的 $\\mathbf{F}$ 和 $T$ 计算总自由能 $\\psi(\\mathbf{F}, \\xi, T)$。\n\n**步骤 2：应用动力学定律**\n马氏体体积分数的变化率 $\\dot{\\xi}$ 由一个具有指定正向 ($R_{\\mathrm{f}}$) 和反向 ($R_{\\mathrm{r}}$) 阈值的率相关动力学定律决定。\n- 正向相变（奥氏体到马氏体）：如果 $p > R_{\\mathrm{f}}$，则 $\\dot{\\xi} = L_{\\mathrm{f}} (p - R_{\\mathrm{f}})$。\n- 反向相变（马氏体到奥氏体）：如果 $p  -R_{\\mathrm{r}}$，则 $\\dot{\\xi} = L_{\\mathrm{r}} (p + R_{\\mathrm{r}})$。\n- 否则（在弹性域内）：$\\dot{\\xi} = 0$。\n\n**步骤 3：更新马氏体体积分数 $\\xi$**\n使用前向欧拉格式在时间步长 $\\Delta t$ 上更新 $\\xi$。结果被裁剪到物理上有意义的范围 $[0, 1]$ 内。\n$$\n\\xi_{\\mathrm{new}} = \\mathrm{clip}\\left(\\xi_{\\mathrm{old}} + \\dot{\\xi} \\, \\Delta t, \\, 0, \\, 1\\right)\n$$\n\n**步骤 4：计算应力状态**\n利用更新后的马氏体分数 $\\xi_{\\mathrm{new}}$，计算最终的应力状态。\n首先，找到新的弹性变形梯度 $\\mathbf{F}_{\\mathrm{e,new}}$：\n$$\n\\mathbf{F}_{\\mathrm{tr,new}} = \\mathrm{diag}\\left(1 + \\beta \\, \\xi_{\\mathrm{new}}, \\frac{1}{\\sqrt{1 + \\beta \\, \\xi_{\\mathrm{new}}}}, \\frac{1}{\\sqrt{1 + \\beta \\, \\xi_{\\mathrm{new}}}}\\right)\n$$\n$$\n\\mathbf{F}_{\\mathrm{e,new}} = \\mathbf{F}\\,\\mathbf{F}_{\\mathrm{tr,new}}^{-1}\n$$\n由此，计算弹性左 Cauchy-Green 张量 $\\mathbf{b}_{\\mathrm{e,new}} = \\mathbf{F}_{\\mathrm{e,new}} \\mathbf{F}_{\\mathrm{e,new}}^{\\mathsf{T}}$ 和弹性体积变化 $J_{\\mathrm{e,new}} = \\det(\\mathbf{F}_{\\mathrm{e,new}})$。\n\n然后使用提供的公式计算 Kirchhoff 应力张量 $\\boldsymbol{\\tau}$：\n$$\n\\boldsymbol{\\tau} = \\mu\\left(\\mathbf{b}_{\\mathrm{e,new}} - \\mathbf{I}\\right) + \\kappa \\, \\ln J_{\\mathrm{e,new}} \\, \\mathbf{I}\n$$\nCauchy 应力 $\\boldsymbol{\\sigma}$ 通过将 $\\boldsymbol{\\tau}$ 按弹性变形梯度的行列式进行缩放得到。由于相变是等容的（$\\det(\\mathbf{F}_{\\mathrm{tr}}) = 1$），我们有 $J = \\det(\\mathbf{F}) = \\det(\\mathbf{F}_{\\mathrm{e}}\\mathbf{F}_{\\mathrm{tr}}) = \\det(\\mathbf{F}_{\\mathrm{e}})\\det(\\mathbf{F}_{\\mathrm{tr}}) = J_{\\mathrm{e}}$。因此，关系式为：\n$$\n\\boldsymbol{\\sigma} = \\frac{1}{J_{\\mathrm{e,new}}} \\boldsymbol{\\tau}\n$$\n最后，从 Cauchy 应力的偏量部分 $\\boldsymbol{s}$ 计算 von Mises 等效应力 $\\sigma_{\\mathrm{vM}}$：\n$$\n\\boldsymbol{s} = \\boldsymbol{\\sigma} - \\frac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma}) \\mathbf{I}\n$$\n$$\n\\sigma_{\\mathrm{vM}} = \\sqrt{\\frac{3}{2} \\, \\boldsymbol{s}:\\boldsymbol{s}}\n$$\n其中 $\\boldsymbol{s}:\\boldsymbol{s}$ 是 Frobenius 内积，等价于 $\\boldsymbol{s}$ 各元素平方的总和。\n\n整个过程被封装在一个 Python 脚本中，该脚本遍历指定的测试用例，为每个用例计算 $[\\xi_{\\mathrm{new}}, \\sigma_{\\mathrm{vM}}]$，并按要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SMA constitutive update problem for the given test cases.\n    \"\"\"\n\n    # Material and kinetic parameters\n    params = {\n        'mu': 26000.0,       # Shear modulus [MPa]\n        'kappa': 130000.0,    # Bulk modulus [MPa]\n        'beta': 0.06,        # Transformation magnitude\n        'H': 75.0,           # Hardening modulus [MPa]\n        'A': 0.0,            # Offset [MPa]\n        'Theta': 0.8,        # Thermal coefficient [MPa/K]\n        'T0': 298.0,         # Reference temperature [K]\n        'R_f': 5.0,          # Forward threshold [MPa]\n        'R_r': 5.0,          # Reverse threshold [MPa]\n        'L_f': 0.15,         # Forward rate [(MPa*s)^-1]\n        'L_r': 0.15,         # Reverse rate [(MPa*s)^-1]\n        'dt': 1.0,           # Time step [s]\n        'eps': 1e-6,         # Numerical derivative increment\n    }\n\n    # Test suite\n    test_cases = [\n        # Case 1\n        (np.array([[1.06, 0.01, 0.0], [0.0, 0.971, 0.0], [0.0, 0.0, 0.971]]), 300.0, 0.0),\n        # Case 2\n        (np.identity(3), 340.0, 0.0),\n        # Case 3\n        (np.array([[1.08, 0.0, 0.0], [0.0, 0.962, 0.0], [0.0, 0.0, 0.962]]), 280.0, 0.3),\n        # Case 4\n        (np.array([[0.995, 0.0, 0.0], [0.0, 1.005, 0.0], [0.0, 0.0, 1.0]]), 360.0, 1.0),\n    ]\n\n    # --- Helper Functions ---\n\n    def get_F_tr_inv(xi, beta):\n        \"\"\"Computes the inverse of the transformation stretch tensor F_tr.\"\"\"\n        # Ensure xi is within [0, 1] to avoid math errors for sqrt\n        xi = np.clip(xi, 0, 1)\n        # Check for division by zero, although 1 + beta*xi > 0 for xi in [0,1] and beta > 0\n        term1 = 1.0 / (1.0 + beta * xi)\n        term2 = np.sqrt(1.0 + beta * xi)\n        return np.diag([term1, term2, term2])\n\n    def psi_e(F_e, mu, kappa):\n        \"\"\"Computes elastic free energy density.\"\"\"\n        J_e = np.linalg.det(F_e)\n        if J_e = 0: return np.inf # Physically inadmissible\n        b_e = F_e @ F_e.T\n        tr_be = np.trace(b_e)\n        log_Je = np.log(J_e)\n        return mu / 2.0 * (tr_be - 3.0) - mu * log_Je + kappa / 2.0 * log_Je**2\n\n    def psi_tr(xi, T, A, H, Theta, T0):\n        \"\"\"Computes transformation hardening free energy density.\"\"\"\n        return A * xi + H / 2.0 * xi**2 + Theta * (T - T0) * xi\n\n    def psi_total(xi, F, T, p):\n        \"\"\"Computes total Helmholtz free energy density.\"\"\"\n        F_tr_inv = get_F_tr_inv(xi, p['beta'])\n        F_e = F @ F_tr_inv\n        pe = psi_e(F_e, p['mu'], p['kappa'])\n        pt = psi_tr(xi, T, p['A'], p['H'], p['Theta'], p['T0'])\n        return pe + pt\n\n    def compute_update(F, T, xi_old, p):\n        \"\"\"Performs a single constitutive update.\"\"\"\n        # Step 1: Compute driving force p\n        eps = p['eps']\n        if xi_old == 0.0:\n            # Forward difference at lower bound\n            psi_eps = psi_total(xi_old + eps, F, T, p)\n            psi_0 = psi_total(xi_old, F, T, p)\n            p_force = -(psi_eps - psi_0) / eps\n        elif xi_old == 1.0:\n            # Backward difference at upper bound\n            psi_1_minus_eps = psi_total(xi_old - eps, F, T, p)\n            psi_1 = psi_total(xi_old, F, T, p)\n            p_force = -(psi_1 - psi_1_minus_eps) / eps\n        else:\n            # Central difference for interior points\n            psi_plus = psi_total(xi_old + eps, F, T, p)\n            psi_minus = psi_total(xi_old - eps, F, T, p)\n            p_force = -(psi_plus - psi_minus) / (2.0 * eps)\n\n        # Step 2: Apply kinetic law\n        xi_dot = 0.0\n        if p_force > p['R_f']:\n            xi_dot = p['L_f'] * (p_force - p['R_f'])\n        elif p_force  -p['R_r']:\n            xi_dot = p['L_r'] * (p_force + p['R_r'])\n        \n        # Step 3: Update xi\n        xi_new = xi_old + xi_dot * p['dt']\n        xi_new = np.clip(xi_new, 0.0, 1.0)\n\n        # Step 4: Compute stresses\n        F_tr_inv_new = get_F_tr_inv(xi_new, p['beta'])\n        F_e_new = F @ F_tr_inv_new\n        J_e_new = np.linalg.det(F_e_new)\n        b_e_new = F_e_new @ F_e_new.T\n        \n        tau = p['mu'] * (b_e_new - np.identity(3)) + p['kappa'] * np.log(J_e_new) * np.identity(3)\n        sigma = tau / J_e_new\n        \n        s = sigma - (np.trace(sigma) / 3.0) * np.identity(3)\n        s_colon_s = np.sum(s * s)\n        sigma_vM = np.sqrt(3.0 / 2.0 * s_colon_s)\n\n        return round(xi_new, 3), round(sigma_vM, 3)\n\n    # --- Main loop ---\n    results_str = []\n    for F_case, T_case, xi0_case in test_cases:\n        xi_new, sigma_vM = compute_update(F_case, T_case, xi0_case, params)\n        results_str.append(str([xi_new, sigma_vM]))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3600572"}]}