{"hands_on_practices": [{"introduction": "要将连续介质损伤力学的理论付诸实践，第一步是掌握其数值实现。本练习将指导您为一个简单的率无关各向同性损伤模型构建一个隐式时间积分算法。通过推导和实现一个“返回映射”算法，您将学习如何强制执行一致性条件，这是计算非弹性力学中的一项核心技能[@problem_id:3554745]。", "problem": "您的任务是为一个一维各向同性率无关连续介质损伤模型制定并实现一个隐式时间积分算法，然后将其应用于一组给定的应变历史。该算法必须在每个时间步强制执行一致性条件，并为一套参数集的测试套件生成定量输出。\n\n假设基底材料为线性弹性体，其特征为模量 $E$ 和一个标量各向同性损伤变量 $d \\in [0,1)$，该变量均匀地降低刚度。本构应力-应变关系为 $ \\sigma = (1 - d) E \\varepsilon $。单位体积的亥姆霍兹自由能被假定为\n$$\n\\psi(\\varepsilon, d) = (1 - d)\\,\\frac{1}{2} E \\varepsilon^2 + \\frac{1}{2} H d^2,\n$$\n其中 $H$ 是一个正标量模量，它正则化损伤演化并提供一个良定的驱动力。与损伤变量共轭的热力学力是损伤能量释放率\n$$\nY(\\varepsilon, d) = - \\frac{\\partial \\psi}{\\partial d} = \\frac{1}{2} E \\varepsilon^2 - H d.\n$$\n率无关的损伤激活由一个阈值 $Y_0 > 0$ 通过屈服函数控制\n$$\nf(\\varepsilon, d) = Y(\\varepsilon, d) - Y_0,\n$$\n并由 Karush-Kuhn-Tucker (KKT) 条件强制执行\n$$\n\\dot{d} \\ge 0,\\quad f(\\varepsilon, d) \\le 0,\\quad \\dot{d}\\, f(\\varepsilon, d) = 0.\n$$\n在每个离散时间步 $t_{n+1}$，给定前一步的损伤 $d_n$ 和给定的应变 $\\varepsilon_{n+1}$，为 $d_{n+1}$ 构建一个隐式更新，当损伤机制被激活时，该更新强制执行一致性条件。从这些基本定义和定律出发，推导出算法，该算法根据 $f(\\varepsilon_{n+1}, d_n)$ 来决定损伤是增长还是保持不变，并且在激活时，在 $t_{n+1}$ 时刻强制执行一致性条件，以使更新后的状态满足相应的约束。使用本构应力关系 $ \\sigma_{n+1} = (1 - d_{n+1}) E \\varepsilon_{n+1} $ 来计算应力响应。\n\n数值实现要求：\n- 在 KKT 条件的不等式检查中，使用一个小的非负容差 $\\tau$（例如，$\\tau = 10^{-12}$ 帕斯卡），以考虑浮点舍入误差。\n- 施加一个上限 $d_{\\max} = 0.999$，以避免数值更新中的奇异刚度，并强制 $d_{n+1} \\in [0, d_{\\max}]$。\n- 强制执行不可逆约束 $d_{n+1} \\ge d_n$。\n- 无论加载或卸载，算法必须是隐式的，即所有更新量都在 $t_{n+1}$ 时刻计算。\n\n物理单位和输出规格：\n- 所有模量 $E$、$H$、阈值 $Y_0$ 和应力 $\\sigma$ 必须以帕斯卡为单位处理和报告。\n- 应变 $\\varepsilon$ 是无量纲的。\n- 程序必须为每个测试用例报告一个包含三个值的列表：最终损伤 $d_{\\text{end}}$（无量纲），最终应力 $\\sigma_{\\text{end}}$（单位：帕斯卡），以及一致性条件被激活（即在强制约束下更新损伤）的时间步数的整数计数。\n- 您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表的结果（例如，$[ \\text{result}_1, \\text{result}_2, \\text{result}_3 ]$），其中每个 $\\text{result}_i$ 本身是对应测试用例的列表 $[ d_{\\text{end}}, \\sigma_{\\text{end}}, \\text{active\\_count} ]$。\n\n测试套件：\n- 用例 1（应变递增，发生激活）：\n  - $E = 200 \\times 10^{9}\\ \\text{Pa}$，$H = 10^{4}\\ \\text{Pa}$，$Y_0 = 800\\ \\text{Pa}$，$d_0 = 0.0$，应变序列 $\\{ \\varepsilon_k \\} = [\\, 0.0,\\ 8 \\times 10^{-5},\\ 1 \\times 10^{-4},\\ 1.2 \\times 10^{-4},\\ 2 \\times 10^{-4} \\,]$。\n- 用例 2（边界阈值和轻微卸载）：\n  - $E = 70 \\times 10^{9}\\ \\text{Pa}$，$H = 2 \\times 10^{4}\\ \\text{Pa}$，$Y_0 = 350\\ \\text{Pa}$，$d_0 = 0.0$，应变序列 $\\{ \\varepsilon_k \\} = [\\, 5 \\times 10^{-5},\\ 1 \\times 10^{-4},\\ 9 \\times 10^{-5} \\,]$。\n- 用例 3（由于 H 值小导致的快速饱和）：\n  - $E = 30 \\times 10^{9}\\ \\text{Pa}$，$H = 500\\ \\text{Pa}$，$Y_0 = 100\\ \\text{Pa}$，$d_0 = 0.0$，应变序列 $\\{ \\varepsilon_k \\} = [\\, 2 \\times 10^{-4},\\ 3 \\times 10^{-4},\\ 5 \\times 10^{-4} \\,]$。\n- 用例 4（加载后卸载）：\n  - $E = 100 \\times 10^{9}\\ \\text{Pa}$，$H = 10^{4}\\ \\text{Pa}$，$Y_0 = 1000\\ \\text{Pa}$，$d_0 = 0.0$，应变序列 $\\{ \\varepsilon_k \\} = [\\, 1.5 \\times 10^{-4},\\ 2 \\times 10^{-4},\\ 1 \\times 10^{-4} \\,]$。\n\n您的程序必须实现从基本定义推导出的隐式算法，并按照上面指定的精确格式，在单行上输出这四个用例的 $[ d_{\\text{end}}, \\sigma_{\\text{end}}, \\text{active\\_count} ]$ 的聚合列表，其中应力单位为帕斯卡，损伤为无量纲。", "solution": "该问题陈述被评估为有效。它在科学上基于连续介质损伤力学的原理，内部一致，并提供了所有必要的数据和约束来构建一个唯一且有意义的解。该问题是计算固体力学中的一个标准练习，要求为率无关材料模型推导并实现一个回映算法。\n\n问题的核心是设计一个标量损伤变量 $d$ 在时间步 $t_{n+1}$ 的离散时间更新规则，给定前一步 $t_n$ 的状态和给定的应变 $\\varepsilon_{n+1}$。该更新必须与 Karush-Kuhn-Tucker (KKT) 条件所指定的率无关不可逆热力学原理一致。\n\n系统的状态由应变 $\\varepsilon$ 和内部损伤变量 $d$ 描述。该模型由以下方程定义：\n亥姆霍兹自由能密度：\n$$\n\\psi(\\varepsilon, d) = (1 - d)\\,\\frac{1}{2} E \\varepsilon^2 + \\frac{1}{2} H d^2\n$$\n应力的本构律：\n$$\n\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = (1 - d) E \\varepsilon\n$$\n与损伤共轭的热力学力，称为损伤能量释放率：\n$$\nY = - \\frac{\\partial \\psi}{\\partial d} = \\frac{1}{2} E \\varepsilon^2 - H d\n$$\n损伤演化由屈服函数 $f$ 和一组 KKT 条件控制：\n$$\nf(Y) = Y - Y_0 \\le 0\n$$\n$$\n\\dot{d} \\ge 0 \\quad (\\text{不可逆性})\n$$\n$$\n\\dot{d} f(Y) = 0 \\quad (\\text{一致性})\n$$\n这些条件定义了一个弹性域，其中 $f \\le 0$ 且 $\\dot{d}=0$；以及一个加载条件，其中 $f=0$ 且 $\\dot{d} \\ge 0$。\n\n对于数值实现，我们在时间上进行离散化。给定时间 $t_n$ 的状态 $d_n$ 和时间 $t_{n+1}$ 的给定应变 $\\varepsilon_{n+1}$，我们寻求找到 $d_{n+1}$ 和 $\\sigma_{n+1}$。算法结构遵循标准的弹性预测/损伤修正方案，该方案是隐式的，因为它在时间步的末端 $t_{n+1}$ 强制执行条件。\n\n**步骤 1：弹性预测**\n首先，我们做一个试探性假设，即该步是纯弹性的，意味着没有损伤演化。\n$$\nd_{n+1}^{\\text{trial}} = d_n\n$$\n\n**步骤 2：检查损伤激活**\n我们使用已知的应变 $\\varepsilon_{n+1}$ 和试探损伤 $d_{n+1}^{\\text{trial}}$ 来评估试探状态下的屈服函数。我们将试探损伤能量释放率定义为：\n$$\nY^{\\text{trial}} = Y(\\varepsilon_{n+1}, d_{n+1}^{\\text{trial}}) = \\frac{1}{2} E \\varepsilon_{n+1}^2 - H d_n\n$$\n然后，试探屈服函数为：\n$$\nf^{\\text{trial}} = Y^{\\text{trial}} - Y_0 = \\frac{1}{2} E \\varepsilon_{n+1}^2 - H d_n - Y_0\n$$\n现在，我们对照弹性域要求检查这个值，同时考虑一个小的数值容差 $\\tau > 0$：\n- 如果 $f^{\\text{trial}} \\le \\tau$，则试探状态是可接受的。弹性假设成立，没有损伤演化发生。KKT 条件以 $\\dot{d}=0$（或更准确地说，$\\Delta d = d_{n+1} - d_n = 0$）得到满足。因此，我们接受试探状态：\n  $$\n  d_{n+1} = d_n\n  $$\n- 如果 $f^{\\text{trial}} > \\tau$，则试探状态是不可接受的，因为它位于弹性域之外。这表明在该步中必须发生损伤。KKT 条件要求系统状态返回到屈服面。这是**一致性条件**，必须在时间步 $t_{n+1}$ 的末端强制执行：\n  $$\n  f(\\varepsilon_{n+1}, d_{n+1}) = 0\n  $$\n\n**步骤 3：损伤修正**\n当一致性条件激活时，我们求解更新后的损伤值 $d_{n+1}$。\n$$\nf(\\varepsilon_{n+1}, d_{n+1}) = Y(\\varepsilon_{n+1}, d_{n+1}) - Y_0 = 0\n$$\n代入 $Y$ 的定义：\n$$\n\\frac{1}{2} E \\varepsilon_{n+1}^2 - H d_{n+1} - Y_0 = 0\n$$\n解这个关于 $d_{n+1}$ 的线性方程，得到更新后的损伤：\n$$\nd_{n+1} = \\frac{1}{H} \\left( \\frac{1}{2} E \\varepsilon_{n+1}^2 - Y_0 \\right)\n$$\n这是算法的“回映”部分，因为它将不可接受的试探状态映射回屈服面。\n\n**步骤 4：约束的强制执行**\n问题指定了对损伤变量的两个额外约束：不可逆性和一个最大值。\n- **不可逆性**：损伤只能增加或保持不变，所以 $d_{n+1} \\ge d_n$。\n- **饱和**：损伤不能达到 $1$，因此施加了一个数值上限：$d_{n+1} \\le d_{\\max}$。\n\n当应用损伤修正器时，计算出的 $d_{n+1}$ 值必须遵守这些约束。我们可以将更新合并成一个表达式。设 $d_{\\text{candidate}}$ 为来自一致性条件的值：\n$$\nd_{\\text{candidate}} = \\frac{1}{H} \\left( \\frac{1}{2} E \\varepsilon_{n+1}^2 - Y_0 \\right)\n$$\n然后，通过确保 $d_{n+1}$ 不小于前一个值 $d_n$ 且不大于上限 $d_{\\max}$ 来获得最终值。注意，如果修正步被激活（$f^{\\text{trial}} > 0$），那么 $d_{\\text{candidate}} - d_n = \\frac{1}{H}(\\frac{1}{2} E \\varepsilon_{n+1}^2 - Y_0 - H d_n) = \\frac{1}{H}f^{\\text{trial}} > 0$，所以 $d_{\\text{candidate}} > d_n$ 会自动满足。因此，不可逆性约束 $d_{n+1} \\ge d_n$ 由回映算法的逻辑内在满足。在这种情况下，唯一需要明确强制执行的约束是上限。\n\n$d_{n+1}$ 的完整算法更新如下：\n1.  计算 $f^{\\text{trial}} = \\frac{1}{2} E \\varepsilon_{n+1}^2 - H d_n - Y_0$。\n2.  如果 $f^{\\text{trial}} \\le \\tau$：\n    $d_{n+1} = d_n$。\n3.  否则（如果 $f^{\\text{trial}} > \\tau$）：\n    $d_{\\text{candidate}} = \\frac{1}{H} \\left( \\frac{1}{2} E \\varepsilon_{n+1}^2 - Y_0 \\right)$。\n    $d_{n+1} = \\min(d_{\\text{candidate}}, d_{\\max})$。\n\n该算法隐式地维持了不可逆性约束。$f^{\\text{trial}} > \\tau$ 的情况对应于一个激活的一致性条件，因此我们为此类步骤增加一个计数器。\n\n**步骤 5：应力更新**\n一旦确定了该步的最终损伤值 $d_{n+1}$，就使用本构律计算时间 $t_{n+1}$ 的应力：\n$$\n\\sigma_{n+1} = (1 - d_{n+1}) E \\varepsilon_{n+1}\n$$\n\n对给定的应变历史中的每一步重复此过程，以找到最终损伤 $d_{\\text{end}}$、最终应力 $\\sigma_{\\text{end}}$ 和损伤激活步骤的总数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the continuum damage mechanics problem for a suite of test cases.\n    \"\"\"\n\n    # Numerical parameters specified in the problem statement.\n    tolerance = 1e-12  # Small tolerance for inequality checks.\n    d_max = 0.999      # Maximum allowable damage value.\n\n    # Test suite defined in the problem statement.\n    test_cases = [\n        # Case 1 (increasing strain, activation occurs)\n        {\n            \"E\": 200e9, \"H\": 1e4, \"Y0\": 800, \"d0\": 0.0,\n            \"strains\": [0.0, 8e-5, 1e-4, 1.2e-4, 2e-4]\n        },\n        # Case 2 (boundary threshold and slight unloading)\n        {\n            \"E\": 70e9, \"H\": 2e4, \"Y0\": 350, \"d0\": 0.0,\n            \"strains\": [5e-5, 1e-4, 9e-5]\n        },\n        # Case 3 (rapid saturation due to small H)\n        {\n            \"E\": 30e9, \"H\": 500, \"Y0\": 100, \"d0\": 0.0,\n            \"strains\": [2e-4, 3e-4, 5e-4]\n        },\n        # Case 4 (loading then unloading)\n        {\n            \"E\": 100e9, \"H\": 1e4, \"Y0\": 1000, \"d0\": 0.0,\n            \"strains\": [1.5e-4, 2e-4, 1e-4]\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        E = case[\"E\"]\n        H = case[\"H\"]\n        Y0 = case[\"Y0\"]\n        \n        d_n = case[\"d0\"]\n        strains = case[\"strains\"]\n        \n        active_count = 0\n\n        # Iterate through the prescribed strain history.\n        for eps_np1 in strains:\n            # Calculate the trial yield function value.\n            # f_trial = Y_trial - Y0 = (0.5 * E * eps_np1^2 - H * d_n) - Y0\n            f_trial = 0.5 * E * eps_np1**2 - H * d_n - Y0\n\n            # Elastic predictor/damage corrector logic\n            if f_trial = tolerance:\n                # Elastic step: damage does not evolve.\n                d_np1 = d_n\n            else:\n                # Damage step: enforce consistency condition f(eps_{n+1}, d_{n+1}) = 0.\n                active_count += 1\n                \n                # Solve for d_{n+1} from the consistency condition:\n                # 0.5 * E * eps_{n+1}^2 - H * d_{n+1} - Y0 = 0\n                d_candidate = (0.5 * E * eps_np1**2 - Y0) / H\n                \n                # Enforce the maximum damage constraint. The irreversibility\n                # d_{n+1} = d_n is naturally satisfied since f_trial  0 implies\n                # d_candidate  d_n.\n                d_np1 = min(d_candidate, d_max)\n\n            # Update the damage variable for the next step.\n            d_n = d_np1\n            \n        # After the loop, d_n holds the final damage value.\n        d_end = d_n\n        \n        # Calculate the final stress using the final strain and final damage.\n        eps_end = strains[-1] if strains else 0.0\n        sigma_end = (1 - d_end) * E * eps_end\n        \n        results.append([d_end, sigma_end, active_count])\n\n    # Format the output as a single-line string representation of a list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3554745"}, {"introduction": "在数值模拟中，一个理论上完美的算法在面对有限精度浮点运算时可能会失效。本练习聚焦于算子分裂法中历史变量更新的数值鲁棒性问题[@problem_id:3554716]。通过比较一个“朴素”的更新规则和一个基于容差的“鲁棒”规则，您将探索在临界点（如峰值强度）附近，数值舍入误差如何影响模拟结果的准确性和稳定性。", "problem": "考虑一个通过算子分裂进行时间积分的标量、一维、各向同性损伤模型。其运动学由小应变变量 $\\,\\varepsilon\\,$、必须单调非递减的标量内部历史变量 $\\,\\kappa\\,$ 以及标量损伤变量 $\\,d\\in[0,1)\\,$ 来表征。自由能密度假定为\n$$\n\\psi(\\varepsilon,d) = \\tfrac{1}{2}\\,(1-d)\\,E\\,\\varepsilon^2,\n$$\n其中 $\\,E\\,$ 是杨氏模量。与 $\\,d\\,$ 共轭的热力学力是能量释放率\n$$\nY(\\varepsilon) = -\\frac{\\partial \\psi}{\\partial d} = \\tfrac{1}{2}\\,E\\,\\varepsilon^2 \\ge 0.\n$$\n损伤由一个单调非递减的历史变量 $\\,\\kappa\\,$ 通过本构映射 $\\,d=g(\\kappa)\\,$ 驱动。令\n$$\nd(\\kappa) = 1 - \\exp\\!\\Big(-\\big(\\tfrac{\\kappa}{\\kappa_0}\\big)^{m}\\Big),\n$$\n其中参数 $\\,\\kappa_00\\,$ 且 $\\,m\\ge 1\\,$。一维柯西应力为\n$$\n\\sigma(\\varepsilon,\\kappa) = (1 - d(\\kappa))\\,E\\,\\varepsilon.\n$$\n历史更新被表达为单边约束\n$$\n\\kappa_{n+1} = \\max\\big(\\kappa_{n},\\,\\tilde{\\kappa}(\\varepsilon_{n+1})\\big), \\quad \\text{with} \\quad \\tilde{\\kappa}(\\varepsilon) = |\\varepsilon|.\n$$\n这实现了损伤萌生和演化的互补性（Kuhn–Tucker (KT)）条件的离散形式：$\\,\\tilde{\\kappa}(\\varepsilon_{n+1}) - \\kappa_{n+1} \\le 0\\,$，$\\,\\kappa_{n+1} - \\kappa_{n} \\ge 0\\,$，以及 $\\,(\\kappa_{n+1}-\\kappa_{n})\\big(\\tilde{\\kappa}(\\varepsilon_{n+1}) - \\kappa_{n+1}\\big)=0\\,$。在接近峰值强度时，浮点舍入误差会使 $\\,\\tilde{\\kappa}(\\varepsilon_{n+1})\\,$ 在数值上与 $\\,\\kappa_n\\,$ 无法区分，这可能导致不一致的分支决策，除非使用稳健的平局打破规则。\n\n仅从这些原理和定义出发（不得假定任何其他公式），为单个增量 $\\,n\\to n+1\\,$ 实现两种离散时间步更新：\n\n- 使用精确最大值的朴素更新，\n$$\n\\kappa_{n+1}^{\\text{naive}} = \\max\\big(\\kappa_n,\\,\\tilde{\\kappa}(\\varepsilon_{n+1})\\big).\n$$\n\n- 一种稳健更新，用一个考虑容差的平局打破规则替代精确比较：对于用户指定的 $\\,a_{\\mathrm{tol}}\\ge 0\\,$ 和 $\\,r_{\\mathrm{tol}}\\ge 0\\,$，定义\n$$\n\\mathrm{tol}(\\kappa_n,\\tilde{\\kappa}) = a_{\\mathrm{tol}} + r_{\\mathrm{tol}}\\,\\max\\big(|\\kappa_n|,\\,|\\tilde{\\kappa}|\\big).\n$$\n然后设置\n$$\n\\kappa_{n+1}^{\\text{rob}} =\n\\begin{cases}\n\\tilde{\\kappa}(\\varepsilon_{n+1}),  \\text{if } \\tilde{\\kappa}(\\varepsilon_{n+1}) \\ge \\kappa_n + \\mathrm{tol} \\\\\n\\kappa_n,  \\text{otherwise (tie region)}\n\\end{cases}\n$$\n这种平局打破机制在模糊带内倾向于保持不变以避免抖动。强制施加单调性约束 $\\,\\kappa_{n+1}^{\\text{rob}} \\leftarrow \\max(\\kappa_n,\\kappa_{n+1}^{\\text{rob}})\\,$ 以保证 $\\,\\kappa\\,$ 不会减小。\n\n对于每种更新规则，在步骤 $\\,n+1\\,$ 计算应力 $\\,\\sigma_{n+1}\\,$ 和离散损伤耗散增量\n$$\n\\Delta \\mathcal{D} \\approx Y_{n+\\theta}\\,\\Delta d, \\quad \\Delta d = d(\\kappa_{n+1})-d(\\kappa_n), \\quad Y_{n+\\theta} = \\tfrac{1}{2}\\,E\\,\\varepsilon_{n+1}^2,\n$$\n其中 $\\,\\theta=1\\,$（此处不需要中点；取在 $\\,n+1\\,$ 处计算的 $\\,Y\\,$ 进行保守的非负性检查，因为 $\\,Y\\ge 0\\,$ 和 $\\,\\Delta d\\ge 0\\,$ 应意味着 $\\,\\Delta \\mathcal{D}\\ge 0\\,$）。通过检查 $\\,\\Delta d \\ge -t_{\\mathrm{diss}}\\,$，在损伤容差 $\\,t_{\\mathrm{diss}}\\,$ 内数值上验证 $\\,\\Delta d \\ge 0\\,$。\n\n峰值强度敏感性。对于给定的 $\\,d(\\kappa)\\,$ 和在单调拉伸下的 $\\,\\kappa=\\tilde{\\kappa}(\\varepsilon)=|\\varepsilon|\\,$，应力-应变关系为\n$$\n\\sigma(\\varepsilon) = E\\,\\varepsilon\\,\\exp\\!\\Big(-\\big(\\tfrac{\\varepsilon}{\\kappa_0}\\big)^m\\Big),\n$$\n其峰值出现在\n$$\n\\varepsilon_{\\mathrm{p}} = \\kappa_0\\,m^{-1/m}.\n$$\n提供一个数值研究，包含 $\\,\\varepsilon_{n+1}\\,$ 非常接近 $\\,\\varepsilon_{\\mathrm{p}}\\,$ 的情况，以便浮点舍入误差可能翻转比较结果。通过报告两种更新规则的离散应力增量 $\\,\\Delta \\sigma = \\sigma_{n+1}-\\sigma_{n}\\,$ 来量化该效应。\n\n实现要求。\n\n- 使用算子分裂算法：给定 $\\,(\\varepsilon_n,\\kappa_n)\\,$，计算 $\\,\\tilde{\\kappa}(\\varepsilon_{n+1})\\,$，用每种规则更新 $\\,\\kappa_{n+1}\\,$，然后计算 $\\,d_{n+1}=d(\\kappa_{n+1})\\,$ 和 $\\,\\sigma_{n+1}\\,$。\n- 使用材料参数 $\\,E=\\,$$\\,2.10\\times 10^{5}\\,$ 帕斯卡，$\\,\\kappa_0=\\,$$\\,2.0\\times 10^{-2}\\,$，以及 $\\,m=\\,$$\\,2.0\\,$。\n- 使用稳健容差 $\\,a_{\\mathrm{tol}}=\\,$$\\,1.0\\times 10^{-12}\\,$，$\\,r_{\\mathrm{tol}}=\\,$$\\,1.0\\times 10^{-8}\\,$，以及损伤正性容差 $\\,t_{\\mathrm{diss}}=\\,$$\\,1.0\\times 10^{-14}\\,$。\n- 将应变视为无量纲，所有应力以帕斯卡表示；报告 $\\,\\Delta \\sigma\\,$ 时以帕斯卡为单位，输出中不含任何单位。\n\n测试套件。对于每个案例 $\\,i\\,$，输入为 $\\,(\\varepsilon_n^{(i)},\\kappa_n^{(i)},\\varepsilon_{n+1}^{(i)})\\,$ 且要产生的输出是\n$$\n\\big[\\kappa_{n+1}^{\\text{naive}},\\ \\kappa_{n+1}^{\\text{rob}},\\ \\Delta \\sigma^{\\text{naive}},\\ \\Delta \\sigma^{\\text{rob}},\\ \\mathrm{mon}^{\\text{naive}},\\ \\mathrm{mon}^{\\text{rob}},\\ \\mathrm{diss}^{\\text{naive}},\\ \\mathrm{diss}^{\\text{rob}}\\big],\n$$\n其中 $\\,\\mathrm{mon}\\,$ 和 $\\,\\mathrm{diss}\\,$ 是用于单调性（$\\,\\kappa_{n+1}\\ge \\kappa_n\\,$）和离散损伤正性（$\\,\\Delta d \\ge -t_{\\mathrm{diss}}\\,$）的布尔标志。使用以下案例：\n\n- 案例 $\\,1\\,$ (理想路径，明显增加): $\\ \\varepsilon_n=\\,$$\\,1.0\\times 10^{-2}\\,$, $\\ \\kappa_n=\\,$$\\,1.0\\times 10^{-2}\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,1.2\\times 10^{-2}\\,$.\n- 案例 $\\,2\\,$ (接近峰值，微小向上差异低于容差): 令 $\\,\\varepsilon_{\\mathrm{p}}=\\kappa_0\\,m^{-1/m}\\,$. 使用 $\\ \\varepsilon_n=\\,$$\\,1.414213561\\times 10^{-2}\\,$, $\\ \\kappa_n=\\varepsilon_n\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,1.414213563\\times 10^{-2}\\,$.\n- 案例 $\\,3\\,$ (接近峰值，微小向下差异): $\\ \\varepsilon_n=\\,$$\\,1.414213563\\times 10^{-2}\\,$, $\\ \\kappa_n=\\varepsilon_n\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,1.414213561\\times 10^{-2}\\,$.\n- 案例 $\\,4\\,$ (边缘情况，接近零): $\\ \\varepsilon_n=\\,$$\\,0.0\\,$, $\\ \\kappa_n=\\,$$\\,0.0\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,1.0\\times 10^{-16}\\,$.\n- 案例 $\\,5\\,$ (大数值，相对容差占主导): $\\ \\varepsilon_n=\\,$$\\,1.0\\,$, $\\ \\kappa_n=\\,$$\\,1.0\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,1.000000005\\,$.\n- 案例 $\\,6\\,$ (大幅增加): $\\ \\varepsilon_n=\\,$$\\,5.0\\times 10^{-1}\\,$, $\\ \\kappa_n=\\,$$\\,5.0\\times 10^{-1}\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,6.0\\times 10^{-1}\\,$.\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试案例，并且本身是按上述顺序排列的八个条目的列表。例如，输出应如下所示\n$$\n[\\,[\\cdots 8\\ \\text{entries}\\cdots],[\\cdots],[\\cdots],[\\cdots],[\\cdots],[\\cdots]\\,].\n$$\n所有应力必须以帕斯卡表示，所有布尔值必须以编程语言的布尔字面量形式出现。", "solution": "该问题是良态的且有科学依据。它提出了一个计算损伤力学中的标准问题，提供了执行关于历史变量更新稳健性的数值研究所需的所有本构方程、参数和算法。所有提供的信息都是自洽且一致的。\n\n任务是在一个一维各向同性损伤模型中，为标量历史变量 $\\kappa$ 实现并比较两种不同的更新方案。该模型在连续介质力学框架内定义，使用算子分裂方法对内部变量进行时间积分。\n\n材料在时间步 $n$ 的状态由应变 $\\varepsilon_n$ 和历史变量 $\\kappa_n$ 描述。历史变量 $\\kappa$ 是材料所经历的最大应变幅值的度量，并且本构上要求其单调非递减，即 $\\kappa_{n+1} \\ge \\kappa_n$。\n\n核心本构关系如下：\n亥姆霍兹自由能密度 $\\psi$ 由下式给出：\n$$\n\\psi(\\varepsilon, d) = \\tfrac{1}{2}\\,(1-d)\\,E\\,\\varepsilon^2\n$$\n其中 $E$ 是杨氏模量，$d$ 是标量损伤变量，$d \\in [0, 1)$。\n\n损伤变量 $d$ 是历史变量 $\\kappa$ 的函数：\n$$\nd(\\kappa) = 1 - \\exp\\!\\Big(-\\big(\\tfrac{\\kappa}{\\kappa_0}\\big)^{m}\\Big)\n$$\n其中材料参数 $\\kappa_0  0$ 且 $m \\ge 1$。\n\n柯西应力 $\\sigma$ 从自由能导出，$\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon}$：\n$$\n\\sigma(\\varepsilon, \\kappa) = (1 - d(\\kappa))\\,E\\,\\varepsilon = E\\,\\varepsilon\\,\\exp\\!\\Big(-\\big(\\tfrac{\\kappa}{\\kappa_0}\\big)^{m}\\Big)\n$$\n\n损伤的演化由 $\\kappa$ 的更新控制。在步骤 $n+1$ 的历史变量的试探值是基于新应变 $\\varepsilon_{n+1}$ 定义的：\n$$\n\\tilde{\\kappa}(\\varepsilon_{n+1}) = |\\varepsilon_{n+1}|\n$$\n然后，使用该试探值从上一步的值 $\\kappa_n$ 更新 $\\kappa$。演化必须满足 Kuhn-Tucker 条件，其离散形式意味着 $\\kappa_{n+1} = \\max(\\kappa_n, \\tilde{\\kappa}(\\varepsilon_{n+1}))$。问题要求将此更新的朴素实现与一个基于容差的稳健版本进行比较。\n\n从 $n$ 到 $n+1$ 的单个时间增量的算法流程如下：\n1.  给定状态 $(\\varepsilon_n, \\kappa_n)$ 和新应变 $\\varepsilon_{n+1}$。\n2.  计算增量开始时的应力：$\\sigma_n = \\sigma(\\varepsilon_n, \\kappa_n)$。\n3.  计算试探历史变量：$\\tilde{\\kappa}_{n+1} = |\\varepsilon_{n+1}|$。\n4.  使用两种不同的规则将历史变量更新为 $\\kappa_{n+1}$：\n\n    a.  **朴素更新规则**：此规则直接实现 `max` 函数，当 $\\tilde{\\kappa}_{n+1}$ 非常接近 $\\kappa_n$ 时，它容易受到浮点误差的影响。\n        $$\n        \\kappa_{n+1}^{\\text{naive}} = \\max(\\kappa_n, \\tilde{\\kappa}_{n+1})\n        $$\n\n    b.  **稳健更新规则**：此规则在 $\\kappa_n$ 周围引入一个容差带，以处理 $\\tilde{\\kappa}_{n+1} \\approx \\kappa_n$ 的模糊情况。如果试探值没有比当前历史值大得足够多，它会阻止损伤演化。容差定义为：\n        $$\n        \\mathrm{tol} = a_{\\mathrm{tol}} + r_{\\mathrm{tol}}\\,\\max(|\\kappa_n|, |\\tilde{\\kappa}_{n+1}|)\n        $$\n        其中 $a_{\\text{tol}}$ 是绝对容差，$r_{\\text{tol}}$ 是相对容差。更新逻辑指定为：\n        $$\n        \\kappa'_{n+1} =\n        \\begin{cases}\n        \\tilde{\\kappa}_{n+1},  \\text{if } \\tilde{\\kappa}_{n+1} \\ge \\kappa_n + \\mathrm{tol} \\\\\n        \\kappa_n,  \\text{otherwise}\n        \\end{cases}\n        $$\n        按照要求应用最终的单调性约束：\n        $$\n        \\kappa_{n+1}^{\\text{rob}} = \\max(\\kappa_n, \\kappa'_{n+1})\n        $$\n\n5.  对于每个产生的历史变量（$\\kappa_{n+1}^{\\text{naive}}$ 和 $\\kappa_{n+1}^{\\text{rob}}$），计算在步骤 $n+1$ 的相应量：\n    -   损伤：$d_{n+1} = d(\\kappa_{n+1})$。\n    -   应力：$\\sigma_{n+1} = \\sigma(\\varepsilon_{n+1}, \\kappa_{n+1})$。\n    -   应力增量：$\\Delta\\sigma = \\sigma_{n+1} - \\sigma_n$。\n\n6.  最后，为每个更新规则执行验证检查：\n    -   **$\\kappa$ 的单调性**：检查是否 $\\kappa_{n+1} \\ge \\kappa_n$。根据构造，预计这两种规则都成立。\n    -   **耗散的正性**：损伤增量 $\\Delta d = d_{n+1} - d_n$ 必须为非负。为了考虑浮点不精确性，使用容差 $t_{\\text{diss}}$进行检查：$\\Delta d \\ge -t_{\\text{diss}}$。这也应成立，因为 $d(\\kappa)$ 是单调递增函数且 $\\kappa_{n+1} \\ge \\kappa_n$。\n\n该实现将对提供的每个测试案例应用此程序，使用指定的材料参数（$E = 2.1 \\times 10^5$, $\\kappa_0 = 2.0 \\times 10^{-2}$, $m = 2.0$）和容差（$a_{\\text{tol}} = 1.0 \\times 10^{-12}$, $r_{\\text{tol}} = 1.0 \\times 10^{-8}$, $t_{\\text{diss}} = 1.0 \\times 10^{-14}$）。将为每个案例计算八个指定的输出值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the continuum damage mechanics problem by implementing and\n    comparing naive and robust update rules for the history variable.\n    \"\"\"\n    # Material and tolerance parameters from the problem statement\n    E = 2.10e5\n    kappa_0 = 2.0e-2\n    m = 2.0\n    a_tol = 1.0e-12\n    r_tol = 1.0e-8\n    t_diss = 1.0e-14\n\n    # --- Constitutive Functions ---\n    def damage_func(kappa):\n        if kappa  0: # kappa must be non-negative\n            return 0.0\n        return 1.0 - np.exp(-((kappa / kappa_0)**m))\n\n    def stress_func(epsilon, kappa):\n        d = damage_func(kappa)\n        return (1.0 - d) * E * epsilon\n    \n    # Test cases from the problem statement\n    test_cases = [\n        # (epsilon_n, kappa_n, epsilon_n+1)\n        (1.0e-2, 1.0e-2, 1.2e-2),\n        (1.414213561e-2, 1.414213561e-2, 1.414213563e-2),\n        (1.414213563e-2, 1.414213563e-2, 1.414213561e-2),\n        (0.0, 0.0, 1.0e-16),\n        (1.0, 1.0, 1.000000005),\n        (5.0e-1, 5.0e-1, 6.0e-1),\n    ]\n\n    results = []\n    \n    for eps_n, kappa_n, eps_n1 in test_cases:\n        \n        # --- Common calculations for the step ---\n        sigma_n = stress_func(eps_n, kappa_n)\n        d_n = damage_func(kappa_n)\n        tilde_kappa_n1 = abs(eps_n1)\n\n        # --- Naive Update ---\n        kappa_n1_naive = max(kappa_n, tilde_kappa_n1)\n        sigma_n1_naive = stress_func(eps_n1, kappa_n1_naive)\n        d_n1_naive = damage_func(kappa_n1_naive)\n        \n        delta_sigma_naive = sigma_n1_naive - sigma_n\n        mon_naive = kappa_n1_naive >= kappa_n\n        delta_d_naive = d_n1_naive - d_n\n        diss_naive = delta_d_naive >= -t_diss\n\n        # --- Robust Update ---\n        tol = a_tol + r_tol * max(abs(kappa_n), abs(tilde_kappa_n1))\n        \n        if tilde_kappa_n1 >= kappa_n + tol:\n            kappa_n1_rob_intermediate = tilde_kappa_n1\n        else:\n            kappa_n1_rob_intermediate = kappa_n\n\n        # Apply monotonicity clamp as requested\n        kappa_n1_rob = max(kappa_n, kappa_n1_rob_intermediate)\n        \n        sigma_n1_rob = stress_func(eps_n1, kappa_n1_rob)\n        d_n1_rob = damage_func(kappa_n1_rob)\n        \n        delta_sigma_rob = sigma_n1_rob - sigma_n\n        mon_rob = kappa_n1_rob >= kappa_n\n        delta_d_rob = d_n1_rob - d_n\n        diss_rob = delta_d_rob >= -t_diss\n\n        # --- Assemble results for the current case ---\n        case_result = [\n            kappa_n1_naive,\n            kappa_n1_rob,\n            delta_sigma_naive,\n            delta_sigma_rob,\n            mon_naive,\n            mon_rob,\n            diss_naive,\n            diss_rob\n        ]\n        results.append(case_result)\n\n    # --- Final Output Formatting ---\n    # Create the string representation manually to match the required format\n    # `repr()` is used to get a standard string for floats and booleans.\n    outer_parts = []\n    for res_list in results:\n        inner_parts = [repr(x) for x in res_list]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    final_string = f\"[{','.join(outer_parts)}]\"\n\n    print(final_string)\n\nsolve()\n```", "id": "3554716"}, {"introduction": "损伤力学问题本质上是力学场与损伤场之间的耦合问题。解决这类耦合系统时，数值求解策略的选择至关重要。本练习将引导您从实现者转变为分析者，通过推导和分析雅可比矩阵，比较“交错”法和“整体”法这两种牛顿求解器的局部收敛性[@problem_id:3554721]。这项高级实践将揭示不同数值方案的效率和可靠性，并展示如何通过谱半径分析来预测其收敛行为。", "problem": "考虑一个具有单位移自由度和各向同性标量损伤变量的一维小应变杆。令 $u \\in \\mathbb{R}$ 为位移未知量，$d \\in [0,1]$ 为内部损伤变量。假设单位参考体积的无量纲亥姆霍兹自由能形式为\n$$\n\\psi(\\varepsilon,d,\\nabla d) = \\tfrac{1}{2} \\left(1-d\\right)^{2} E \\, \\varepsilon^{2} + \\tfrac{1}{2} k_d \\, d^{2},\n$$\n其中 $E0$ 是一个（无量纲化的）弹性模量，$k_d  0$ 是一个等效的（无量纲化的）损伤正则化刚度，它源于梯度正则化的空间离散化。考虑一个单单元离散化，其中轴向应变与位移成正比，因此增量势能为\n$$\n\\Pi(u,d) = \\tfrac{1}{2} \\left(1-d\\right)^{2} E \\, u^{2} - f u + \\tfrac{1}{2} k_d \\, d^{2},\n$$\n其中 $f \\ge 0$ 表示一个恒定的外部广义载荷。平稳性条件给出了残差\n$$\nR_u(u,d) = \\frac{\\partial \\Pi}{\\partial u} = \\left(1-d\\right)^{2} E\\, u - f, \\quad\nR_d(u,d) = \\frac{\\partial \\Pi}{\\partial d} = -\\left(1-d\\right) E\\, u^{2} + k_d \\, d.\n$$\n将耦合系统 $\\{u,d\\}$ 的整体（monolithic）雅可比矩阵定义为\n$$\nJ(u,d) = \n\\begin{bmatrix}\nA  B \\\\\nC  D\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\frac{\\partial R_u}{\\partial u}  \\frac{\\partial R_u}{\\partial d} \\\\\n\\frac{\\partial R_d}{\\partial u}  \\frac{\\partial R_d}{\\partial d}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\left(1-d\\right)^{2} E  -2\\left(1-d\\right) E\\, u \\\\\n-2\\left(1-d\\right) E\\, u  E\\, u^{2} + k_d\n\\end{bmatrix}.\n$$\n交错（块高斯-赛德尔）牛顿迭代在每次全局迭代中依次求解子问题：先固定 $d$ 求解 $u$，然后固定 $u$ 求解 $d$。在解 $\\{u^\\star,d^\\star\\}$ 处进行线性化，雅可比块 $A,B,C,D$ 在 $\\{u^\\star,d^\\star\\}$ 处取值，则交错迭代的线性化误差传播由迭代矩阵控制\n$$\nG = -\\left[\\begin{array}{cc} A  0\\\\ C  D\\end{array}\\right]^{-1}\\left[\\begin{array}{cc} 0  B\\\\ 0  0\\end{array}\\right]\n=\n\\begin{bmatrix}\n0  -A^{-1} B \\\\\n0  D^{-1} C A^{-1} B\n\\end{bmatrix}.\n$$\n谱半径 $\\rho(G)$ 控制了交错格式的局部线性收敛性；具体来说，如果 $\\rho(G)  1$，则交错迭代在 $\\{u^\\star,d^\\star\\}$ 的一个邻域内是局部线性收敛的。在具有一致雅可比矩阵和二次连续可微残差的整体牛顿法中，如果 $J(u^\\star,d^\\star)$ 是非奇异的且初始迭代点足够接近解，则局部二次收敛成立。\n\n您的任务是：\n1. 从增量势能 $\\Pi(u,d)$ 和平稳性条件出发，仅使用残差 $R_u$ 和 $R_d$ 的定义，推导在一般状态 $\\{u,d\\}$ 下的雅可比块 $A, B, C, D$。\n2. 对于交错（块高斯-赛德尔）线性化，用雅可比块 $A, B, C, D$ 推导迭代矩阵 $G$，并针对当前的标量块情况简化谱半径 $\\rho(G)$。将简化的 $\\rho(G)$ 仅用 $E, k_d, u^\\star, d^\\star$ 表示。\n3. 证明耦合平衡满足代数系统 $R_u(u^\\star,d^\\star) = 0$ 和 $R_d(u^\\star,d^\\star) = 0$。通过消去 $u^\\star$ 来用 $d^\\star$ 表示，将平衡条件简化为关于 $x := 1 - d^\\star \\in (0,1]$ 的单一标量方程，形式为\n$$\nF(x;E,k_d,f) = k_d\\left(x^4 - x^3\\right) + \\frac{f^2}{E} = 0,\n$$\n并用此方程计算 $u^\\star$ 和 $d^\\star$。\n4. 利用上述结果，在 $\\{u^\\star,d^\\star\\}$ 处计算谱半径 $\\rho(G)$，并通过检查 $\\rho(G)  1$ 是否成立来判断交错法是否局部收敛。此外，通过检查完整雅可比矩阵 $J(u^\\star,d^\\star)$ 是否非奇异来判断整体牛顿法是否局部二次收敛。\n5. 实现一个程序，对于一组测试用例，求解 $\\{u^\\star,d^\\star\\}$，计算 $\\rho(G)$，并为每个测试用例返回两个布尔值：一个基于 $\\rho(G)  1$ 指示交错局部收敛性，另一个基于 $\\det J(u^\\star,d^\\star) \\ne 0$ 指示整体局部二次收敛性。该问题是完全无量纲的；报告所有量时均不带物理单位。为保证数值鲁棒性，在与零或一比较时，可使用 $\\varepsilon = 10^{-12}$ 的容差。\n\n测试套件：\n- 情况 1：$(E,k_d,f) = (1000, 10, 1)$。\n- 情况 2：$(E,k_d,f) = (1000, 1, 10)$。\n- 情况 3：$(E,k_d,f) = (1000, 1000, 10)$。\n- 情况 4：$(E,k_d,f) = (1000, 10, 0)$。\n\n您的程序必须：\n- 求解简化的标量方程 $F(x;E,k_d,f) = 0$ 以得到 $x \\in (0,1]$，从而获得 $d^\\star = 1 - x$ 和 $u^\\star = f/\\left(E x^{2}\\right)$，并遵循约定：如果 $f=0$，则 $x=1$。\n- 在 $\\{u^\\star,d^\\star\\}$ 处计算 $A,B,C,D$，然后通过您推导的简化公式计算谱半径。\n- 对于每个测试用例，输出一个三元组 $[\\rho, \\text{staggered\\_convergent}, \\text{monolithic\\_quadratic}]$，其中 $\\rho$ 是一个四舍五入到8位小数的浮点数，两个布尔值表示为 True 或 False。\n- 将所有测试用例的结果汇总到一行打印到标准输出，格式化为 Python 风格的列表的列表，例如 $[[r_1,b_1,c_1],[r_2,b_2,c_2],\\ldots]$。\n- 您的最终程序必须是自包含的，不需要用户输入，并严格遵循指定的输出格式。", "solution": "此问题要求对一个一维、单自由度的连续介质损伤力学模型的整体解法和交错解法的收敛特性进行详细分析。分析涉及几个步骤：推导系统雅可比矩阵，构建交错迭代矩阵及其谱半径，将平衡方程简化为单个标量方程，以及在平衡状态下评估收敛准则。\n\n**任务1：推导雅可比块**\n\n雅可比矩阵 $J$ 由残差 $R_u(u,d)$ 和 $R_d(u,d)$ 对变量 $u$ 和 $d$ 的偏导数定义。残差由下式给出：\n$$\nR_u(u,d) = \\left(1-d\\right)^{2} E\\, u - f\n$$\n$$\nR_d(u,d) = -\\left(1-d\\right) E\\, u^{2} + k_d \\, d\n$$\n雅可比块 $A$, $B$, $C$, 和 $D$ 的计算如下：\n$A = \\frac{\\partial R_u}{\\partial u} = \\frac{\\partial}{\\partial u} \\left[ \\left(1-d\\right)^{2} E\\, u - f \\right] = \\left(1-d\\right)^{2} E$\n\n$B = \\frac{\\partial R_u}{\\partial d} = \\frac{\\partial}{\\partial d} \\left[ \\left(1-d\\right)^{2} E\\, u - f \\right] = 2\\left(1-d\\right)(-1) E\\, u = -2\\left(1-d\\right) E\\, u$\n\n$C = \\frac{\\partial R_d}{\\partial u} = \\frac{\\partial}{\\partial u} \\left[ -\\left(1-d\\right) E\\, u^{2} + k_d \\, d \\right] = -\\left(1-d\\right) E\\, (2u) = -2\\left(1-d\\right) E\\, u$\n\n$D = \\frac{\\partial R_d}{\\partial d} = \\frac{\\partial}{\\partial d} \\left[ -\\left(1-d\\right) E\\, u^{2} + k_d \\, d \\right] = -(-1) E\\, u^{2} + k_d = E\\, u^{2} + k_d$\n\n这些推导出的表达式与问题陈述中提供的雅可比矩阵相匹配。\n\n**任务2：推导交错迭代矩阵及其谱半径**\n\n交错（块高斯-赛德尔）迭代矩阵 $G$ 由下式给出：\n$$\nG = -\\left[\\begin{array}{cc} A  0\\\\ C  D\\end{array}\\right]^{-1}\\left[\\begin{array}{cc} 0  B\\\\ 0  0\\end{array}\\right]\n$$\n第一个矩阵是块下三角矩阵。其逆矩阵通过对角块求逆得到：\n$$\n\\left[\\begin{array}{cc} A  0\\\\ C  D\\end{array}\\right]^{-1} = \\begin{bmatrix} A^{-1}  0 \\\\ -D^{-1} C A^{-1}  D^{-1} \\end{bmatrix}\n$$\n将此代入 $G$ 的表达式中：\n$$\nG = - \\begin{bmatrix} A^{-1}  0 \\\\ -D^{-1} C A^{-1}  D^{-1} \\end{bmatrix} \\begin{bmatrix} 0  B \\\\ 0  0 \\end{bmatrix} = - \\begin{bmatrix} A^{-1}(0) + 0(0)  A^{-1}B + 0(0) \\\\ -D^{-1}CA^{-1}(0) + D^{-1}(0)  -D^{-1}CA^{-1}B + D^{-1}(0) \\end{bmatrix} = \\begin{bmatrix} 0  -A^{-1}B \\\\ 0  D^{-1}CA^{-1}B \\end{bmatrix}\n$$\n由于 $G$ 是一个块上三角矩阵，其特征值即为其对角块的特征值。在这种标量块的情况下，对角块是标量 $0$ 和 $D^{-1}CA^{-1}B$。因此，$G$ 的特征值为 $\\lambda_1 = 0$ 和 $\\lambda_2 = D^{-1}CA^{-1}B = \\frac{BC}{AD}$。\n\n谱半径 $\\rho(G)$ 是特征值绝对值的最大值：\n$$\n\\rho(G) = \\max\\left( \\left|\\lambda_1\\right|, \\left|\\lambda_2\\right| \\right) = \\left| \\frac{BC}{AD} \\right|\n$$\n现在，我们代入在平衡状态 $\\{u^\\star, d^\\star\\}$ 下计算的 $A$, $B$, $C$, 和 $D$ 的表达式：\n$A = \\left(1-d^\\star\\right)^{2} E$\n$B = -2\\left(1-d^\\star\\right) E\\, u^\\star$\n$C = -2\\left(1-d^\\star\\right) E\\, u^\\star$\n$D = E\\, (u^\\star)^{2} + k_d$\n\n$$\n\\rho(G) = \\left| \\frac{\\left(-2\\left(1-d^\\star\\right) E\\, u^\\star\\right) \\left(-2\\left(1-d^\\star\\right) E\\, u^\\star\\right)}{\\left(\\left(1-d^\\star\\right)^{2} E\\right) \\left(E\\, (u^\\star)^{2} + k_d\\right)} \\right| = \\frac{4\\left(1-d^\\star\\right)^{2} E^2 (u^\\star)^2}{\\left(1-d^\\star\\right)^{2} E \\left(E\\, (u^\\star)^{2} + k_d\\right)} = \\frac{4 E (u^\\star)^2}{E (u^\\star)^2 + k_d}\n$$\n这是用 $E$, $k_d$, $u^\\star$, 和 $d^\\star$ 表示的谱半径表达式。\n\n**任务3：推导标量平衡方程**\n\n平衡状态 $\\{u^\\star, d^\\star\\}$ 满足平稳性条件 $R_u(u^\\star, d^\\star)=0$ 和 $R_d(u^\\star, d^\\star)=0$：\n1. $R_u = 0 \\implies \\left(1-d^\\star\\right)^{2} E\\, u^\\star - f = 0$\n2. $R_d = 0 \\implies -\\left(1-d^\\star\\right) E\\, (u^\\star)^{2} + k_d \\, d^\\star = 0$\n\n由方程(1)可知，如果 $f  0$，则 $d^\\star \\neq 1$，我们可以解出 $u^\\star$：\n$$\nu^\\star = \\frac{f}{\\left(1-d^\\star\\right)^{2} E}\n$$\n将这个 $u^\\star$ 的表达式代入方程(2)：\n$$\n-\\left(1-d^\\star\\right) E \\left( \\frac{f}{\\left(1-d^\\star\\right)^{2} E} \\right)^2 + k_d d^\\star = 0\n$$\n$$\n-\\left(1-d^\\star\\right) E \\frac{f^2}{\\left(1-d^\\star\\right)^{4} E^2} + k_d d^\\star = 0\n$$\n$$\n-\\frac{f^2}{\\left(1-d^\\star\\right)^{3} E} + k_d d^\\star = 0\n$$\n我们定义 $x := 1 - d^\\star$，这意味着 $d^\\star = 1 - x$。将其代入方程：\n$$\n-\\frac{f^2}{x^3 E} + k_d (1-x) = 0\n$$\n重新整理各项以匹配所需形式：\n$$\nk_d (1-x) = \\frac{f^2}{x^3 E}\n$$\n$$\nk_d E x^3 (1-x) = f^2\n$$\n$$\nk_d (x^3 - x^4) = \\frac{f^2}{E}\n$$\n$$\nk_d (x^4 - x^3) + \\frac{f^2}{E} = 0\n$$\n这就是所求的标量方程 $F(x;E,k_d,f) = 0$。一旦求得 $x$，我们就有 $d^\\star = 1-x$ 和 $u^\\star = f / (E x^2)$。\n对于 $f=0$ 的情况，方程变为 $k_d(x^4-x^3)=0$，其解为 $x^3(x-1)=0$。解是 $x=0$ 和 $x=1$。由于 $d \\in [0,1]$，我们有 $x \\in [0,1]$。问题陈述中约定，对于 $f=0$，我们取 $x=1$，对应于无损状态 $d^\\star=0$ 和 $u^\\star=0$。\n\n**任务4：评估收敛准则**\n\n我们现在用单一变量 $x := 1 - d^\\star$ 来表示收敛准则。\n\n**交错格式：**\n由平衡条件 $R_d=0$ 可得 $k_d d^\\star = (1-d^\\star) E (u^\\star)^2$。这给出了 $E(u^\\star)^2 = \\frac{k_d d^\\star}{1-d^\\star}$。\n将此代入 $\\rho(G)$ 的表达式：\n$$\n\\rho(G) = \\frac{4 E (u^\\star)^2}{E (u^\\star)^2 + k_d} = \\frac{4 \\frac{k_d d^\\star}{1-d^\\star}}{\\frac{k_d d^\\star}{1-d^\\star} + k_d} = \\frac{4 \\frac{d^\\star}{1-d^\\star}}{\\frac{d^\\star}{1-d^\\star} + 1} = \\frac{4 \\frac{d^\\star}{1-d^\\star}}{\\frac{d^\\star + (1-d^\\star)}{1-d^\\star}} = \\frac{4 \\frac{d^\\star}{1-d^\\star}}{\\frac{1}{1-d^\\star}} = 4d^\\star\n$$\n局部线性收敛条件是 $\\rho(G)  1$，这可以简化为 $4d^\\star  1$，即 $d^\\star  1/4$。\n\n**整体格式：**\n局部二次收敛性取决于雅可比矩阵 $J(u^\\star, d^\\star)$ 的非奇异性，即 $\\det(J) \\neq 0$。\n$$\n\\det(J) = AD - BC = \\left((1-d^\\star)^2 E\\right) (E(u^\\star)^2+k_d) - \\left(-2(1-d^\\star)Eu^\\star\\right)^2\n$$\n$$\n\\det(J) = (1-d^\\star)^2 E (E(u^\\star)^2+k_d) - 4(1-d^\\star)^2 E^2 (u^\\star)^2\n$$\n$$\n\\det(J) = (1-d^\\star)^2 E k_d - 3(1-d^\\star)^2 E^2 (u^\\star)^2 = (1-d^\\star)^2 E (k_d - 3E(u^\\star)^2)\n$$\n代入 $E(u^\\star)^2 = \\frac{k_d d^\\star}{1-d^\\star}$：\n$$\n\\det(J) = (1-d^\\star)^2 E \\left(k_d - 3\\frac{k_d d^\\star}{1-d^\\star}\\right) = (1-d^\\star)^2 E k_d \\left(1 - \\frac{3d^\\star}{1-d^\\star}\\right)\n$$\n$$\n\\det(J) = (1-d^\\star)^2 E k_d \\left(\\frac{1-d^\\star-3d^\\star}{1-d^\\star}\\right) = (1-d^\\star) E k_d (1 - 4d^\\star)\n$$\n由于 $E0$, $k_d0$，且对于 $f0$，$d^\\star \\in (0,1)$ 所以 $1-d^\\star \\neq 0$，条件 $\\det(J) \\neq 0$ 等价于 $1 - 4d^\\star \\neq 0$，即 $d^\\star \\neq 1/4$。\n\n两种收敛性分析都凸显了在 $d^\\star = 1/4$ 处的一个临界损伤状态。在这一点上，交错格式的谱半径达到1，表明失去收敛保证；而整体雅可比矩阵变为奇异，表明出现分岔点或极限点，并失去二次收敛性。\n\n**实现摘要：**\n对于每个测试用例 $(E, k_d, f)$：\n1. 如果 $f=0$，则设置 $x=1$。否则，计算 $C = f^2/(E k_d)$ 并数值求解 $x^3(1-x) - C = 0$ 以在区间 $[0.75, 1]$ 内找到 $x^\\star$。选择此区间是因为物理平衡路径从 $x=1$（无损伤）开始，并随着载荷 $f$ 的增加朝向较小的 $x$ 值（损伤增加）发展。$x^3(1-x)$ 的最大值出现在 $x=3/4$ 处，这标志着极限点。\n2. 计算 $d^\\star = 1 - x^\\star$。\n3. 计算 $\\rho(G) = 4d^\\star$。\n4. 检查交错收敛性：$\\rho(G)  1$。\n5. 检查整体收敛性：$d^\\star \\neq 1/4$。\n然后按要求格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for the equilibrium state of a 1D damage model and analyzes the\n    local convergence properties of monolithic and staggered numerical schemes.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (E, k_d, f)\n        (1000, 10, 1),\n        (1000, 1, 10),\n        (1000, 1000, 10),\n        (1000, 10, 0),\n    ]\n\n    results = []\n    # Numerical tolerance for comparisons\n    epsilon = 1e-12\n\n    for E, k_d, f in test_cases:\n        # Task 3: Solve for equilibrium state {u*, d*}\n        # by finding x* = 1-d* from F(x;E,k_d,f) = 0.\n\n        if abs(f)  epsilon:\n            # Per problem convention, if f=0, then x=1 (no damage state).\n            x_star = 1.0\n        else:\n            # For f  0, solve k_d(x^4-x^3) + f^2/E = 0.\n            # This is equivalent to solving x^3(1-x) = C, where C = f^2/(E*k_d).\n            # The physically stable equilibrium branch corresponds to roots x in [0.75, 1.0].\n            # The function h(x) = x^3(1-x) has a maximum at x=0.75.\n            C = f**2 / (E * k_d)\n            \n            # Use a robust root-finding algorithm (Brent's method) on the stable interval.\n            # The function whose root we seek is g(x) = x^3(1-x) - C.\n            # g(0.75) = (3/4)^3 * (1/4) - C = 27/256 - C >= 0 for a solution to exist.\n            # g(1) = 0 - C  0.\n            # The interval [0.75, 1.0] brackets the root if C is in the valid range.\n            try:\n                # Handle the boundary case where C = 27/256 exactly\n                if abs(C - 27.0/256.0)  epsilon:\n                    x_star = 0.75\n                else:\n                    x_star = brentq(lambda x: x**3 * (1 - x) - C, 0.75, 1.0)\n            except ValueError:\n                # This would occur if C > 27/256, for which no real solution for x in [0,1] exists.\n                # The problem's test cases avoid this scenario.\n                # For robustness, we could assign a NaN or error state.\n                # For this specific problem, it is safe to assume a solution exists.\n                rho, staggered_convergent, monolithic_quadratic = (np.nan, False, False)\n                results.append([rho, staggered_convergent, monolithic_quadratic])\n                continue\n\n        # From x_star, compute d_star\n        d_star = 1.0 - x_star\n\n        # Task 4: Evaluate convergence criteria.\n        \n        # Staggered scheme convergence: rho(G) = 4*d_star  1\n        rho = 4.0 * d_star\n        staggered_convergent = rho  1.0 - epsilon\n        \n        # Monolithic scheme quadratic convergence: det(J) != 0, which is equivalent to d_star != 1/4\n        # We can check this by |d_star - 0.25| > epsilon.\n        # Note that d_star = 1 - x_star, so d_star = 1/4 is equivalent to x_star = 3/4.\n        monolithic_quadratic = abs(d_star - 0.25) > epsilon\n\n        # Format the results as per problem specification.\n        results.append([round(rho, 8), staggered_convergent, monolithic_quadratic])\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list of lists is the required format.\n    print(str(results))\n\nsolve()\n```", "id": "3554721"}]}