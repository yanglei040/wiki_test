{"hands_on_practices": [{"introduction": "本次实践为砂浆法奠定了理论基础。我们将通过为一个简单的一维接触界面显式构建一组对偶基函数，来探索“双正交性”这一概念。这项练习对于理解为何某些拉格朗日乘子空间的选择可以产生对角化的（因而计算效率极高）系统矩阵至关重要[@problem_id:3553737]。", "problem": "考虑两个可变形体之间的一维空间无摩擦双边接触界面 $\\Gamma \\subset \\mathbb{R}$，该界面由坐标 $x \\in [0,L]$ 参数化，其中 $L = h_{1} + h_{2} > 0$ 是总界面长度。该界面被一个从网格和一个主网格离散化。从网格由两个线性有限元 $S_{1} = [0,h_{1}]$ 和 $S_{2} = [h_{1},L]$ 组成，主网格由两个线性有限元 $M_{1} = [0,H_{1}]$ 和 $M_{2} = [H_{1},L]$ 组成，其中 $H_{1} + H_{2} = L$。从场使用与位于 $x_{1} = 0$、$x_{2} = h_{1}$ 和 $x_{3} = L$ 的从节点相关联的标准节点线性（帽状）形函数 $\\{N_{j}\\}_{j=1}^{3}$ 进行近似。\n\n在用于接触问题的砂浆有限元法（Mortar Finite Element Method, MFEM）中，无穿透约束的弱形式施加是通过一个拉格朗日乘子场 $\\lambda$ 实现的。该乘子场存在于一个由在从网格上构造的对偶基 $\\{\\Psi_{i}\\}_{i=1}^{3}$ 所张成的乘子空间中。双正交对偶基的特征由以下要求决定：\n$$\n\\int_{\\Gamma} \\Psi_{i}(x)\\,N_{j}(x)\\,\\mathrm{d}x \\;=\\; m_{j}\\,\\delta_{ij}, \\quad i,j \\in \\{1,2,3\\},\n$$\n其中 $\\delta_{ij}$ 是克罗内克δ，$m_{j}$ 是必须从第一性原理确定的正常数缩放因子。这导出了砂浆格拉姆矩阵 $M$，其元素为\n$$\nM_{ij} \\;=\\; \\int_{\\Gamma} \\Psi_{i}(x)\\,N_{j}(x)\\,\\mathrm{d}x.\n$$\n\n从接触约束的加权残差陈述和每个单元上标准线性从形函数的定义出发，完成以下任务：\n\n1. 推导每个单元上从形函数的显式表达式。在 $S_{1}$ 上使用局部坐标 $\\xi \\in [0,1]$（其中 $x = h_{1}\\,\\xi$），在 $S_{2}$ 上使用局部坐标 $\\eta \\in [0,1]$（其中 $x = h_{1} + h_{2}\\,\\eta$）。用这些局部坐标表示 $S_{1}$ 上的 $N_{1}$ 和 $N_{2}$，以及 $S_{2}$ 上的 $N_{2}$ 和 $N_{3}$。\n\n2. 仅根据定义 $m_{j} = \\int_{\\Gamma} N_{j}(x)\\,\\mathrm{d}x$ 和每个 $N_{j}$ 的支集来确定缩放因子 $m_{j}$。\n\n3. 通过在每个从单元上寻求分段线性形式，在从网格上构造一个双正交对偶基 $\\{\\Psi_{i}\\}_{i=1}^{3}$，其支集为满足双正交条件所需的最小范围。具体而言，对每个 $\\Psi_{i}$ 强制执行：\n   - $\\int_{\\Gamma} \\Psi_{i}(x)\\,N_{i}(x)\\,\\mathrm{d}x = m_{i}$，\n   - $\\int_{\\Gamma} \\Psi_{i}(x)\\,N_{j}(x)\\,\\mathrm{d}x = 0$ 对所有 $j \\neq i$ 成立。\n   将 $\\Psi_{1}$ 写成在 $S_{1}$ 上线性且在 $S_{2}$ 上为零的形式；将 $\\Psi_{3}$ 写成在 $S_{2}$ 上线性且在 $S_{1}$ 上为零的形式；对于 $\\Psi_{2}$，选择一个具有足以满足三个双正交约束的支集的表示。\n\n4. 使用你构造的 $\\{\\Psi_{i}\\}$，用 $h_{1}$ 和 $h_{2}$ 显式计算元素 $M_{ij} = \\int_{\\Gamma} \\Psi_{i}(x)\\,N_{j}(x)\\,\\mathrm{d}x$，并报告完整的 $3\\times 3$ 矩阵 $M$。\n\n你最终报告的答案必须是用 $h_{1}$ 和 $h_{2}$ 写出的矩阵 $M$ 的解析表达式。无需进行数值计算或四舍五入。", "solution": "用户请求解答一个计算固体力学中的问题，该问题具体涉及在一维情况下为砂浆有限元法（MFEM）构造对偶基。\n\n### 问题验证\n\n首先，需要对问题陈述进行严格的验证。\n\n**步骤1：提取已知条件**\n- 接触界面：$\\Gamma \\subset \\mathbb{R}$，由 $x \\in [0,L]$ 参数化，其中 $L=h_{1}+h_{2}$。\n- 从网格：两个线性单元，$S_{1} = [0,h_{1}]$ 和 $S_{2} = [h_{1},L]$。\n- 从节点：$x_{1}=0$，$x_{2}=h_{1}$，$x_{3}=L$。\n- 从形函数：标准线性帽状函数 $\\{N_{j}\\}_{j=1}^{3}$。\n- 局部坐标：$S_{1}$ 上的 $\\xi = x/h_{1}$ 和 $S_{2}$ 上的 $\\eta = (x-h_{1})/h_{2}$。\n- 拉格朗日乘子基：一个对偶基 $\\{\\Psi_{i}\\}_{i=1}^{3}$。\n- 双正交条件：$\\int_{\\Gamma} \\Psi_{i}(x)\\,N_{j}(x)\\,\\mathrm{d}x = m_{j}\\,\\delta_{ij}$。\n- 砂浆格拉姆矩阵：$M_{ij} = \\int_{\\Gamma} \\Psi_{i}(x)\\,N_{j}(x)\\,\\mathrm{d}x$。\n- 缩放因子定义：$m_{j} = \\int_{\\Gamma} N_{j}(x)\\,\\mathrm{d}x$。\n- $\\Psi_{i}$ 的构造约束：\n    - 在从单元上分段线性。\n    - $\\Psi_1$ 的支集在 $S_1$上，$\\Psi_3$ 的支集在 $S_2$ 上。\n    - $\\int_{\\Gamma} \\Psi_{i}(x)\\,N_{i}(x)\\,\\mathrm{d}x = m_{i}$ 且 $\\int_{\\Gamma} \\Psi_{i}(x)\\,N_{j}(x)\\,\\mathrm{d}x = 0$ 对 $j \\neq i$ 成立。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题在计算接触力学领域具有坚实的科学基础。所有术语都是标准的且定义明确。一个潜在的混淆点源于对双正交积分给出的两个定义：\n1.  $\\int_{\\Gamma} \\Psi_{i}(x)\\,N_{j}(x)\\,\\mathrm{d}x = m_{j}\\,\\delta_{ij}$\n2.  构造规则：$\\int_{\\Gamma} \\Psi_{i}(x)\\,N_{j}(x)\\,\\mathrm{d}x = m_{i}\\,\\delta_{ij}$\n\n由于缩放因子 $m$ 的下标不同，这两个陈述看起来相互矛盾。然而，对于 $i=j$ 的非零情况，两个陈述都简化为 $\\int_{\\Gamma} \\Psi_{i}(x)\\,N_{i}(x)\\,\\mathrm{d}x = m_{i}$。对于 $i \\neq j$ 的情况，两个陈述都要求积分为零。因此，这两个定义在功能上是等价的，不存在矛盾。该问题是适定的且内部一致的。\n\n**步骤3：结论与行动**\n该问题是**有效的**。将遵循问题陈述中指定的四个任务，提供一个完整的、附带推理过程的解。\n\n### 解题推导\n\n目标是计算砂浆格拉姆矩阵 $M$，其元素为 $M_{ij} = \\int_{\\Gamma} \\Psi_{i}(x)\\,N_{j}(x)\\,\\mathrm{d}x$。对偶基 $\\{\\Psi_i\\}$ 的构造使其与原基 $\\{N_j\\}$ 双正交。\n\n**任务1：从形函数**\n\n从形函数 $\\{N_j\\}_{j=1}^3$ 是定义在由单元 $S_1 = [0, h_1]$ 和 $S_2 = [h_1, h_1+h_2]$ 组成的网格上的标准线性“帽状”函数。它们在节点 $x_1=0$、$x_2=h_1$、$x_3=h_1+h_2$ 处满足性质 $N_j(x_k) = \\delta_{jk}$。\n\n- $N_1(x)$ 仅在 $S_1$ 上非零。它是线性的，且 $N_1(0)=1$，$N_1(h_1)=0$。用全局坐标 $x$ 表示，$N_1(x) = 1 - x/h_1$（当 $x \\in S_1$）。在 $S_1$ 上使用局部坐标 $\\xi = x/h_1$，我们有 $N_1(\\xi) = 1-\\xi$。\n\n- $N_2(x)$ 在 $S_1$ 和 $S_2$ 上都非零。\n  - 在 $S_1$ 上：$N_2(0)=0$，$N_2(h_1)=1 \\implies N_2(x) = x/h_1$。用局部坐标表示，$N_2(\\xi) = \\xi$。\n  - 在 $S_2$ 上：$N_2(h_1)=1$，$N_2(h_1+h_2)=0 \\implies N_2(x) = \\frac{(h_1+h_2)-x}{h_2}$。用局部坐标 $\\eta = (x-h_1)/h_2$ 表示，我们有 $x = h_1+h_2\\eta$，因此 $N_2(\\eta) = \\frac{(h_1+h_2)-(h_1+h_2\\eta)}{h_2} = 1-\\eta$。\n\n- $N_3(x)$ 仅在 $S_2$ 上非零。它是线性的，且 $N_3(h_1)=0$，$N_3(h_1+h_2)=1$。这得到 $N_3(x) = (x-h_1)/h_2$（当 $x \\in S_2$）。用局部坐标表示，$N_3(\\eta) = \\eta$。\n\n**任务2：缩放因子 $m_j$**\n\n缩放因子定义为 $m_j = \\int_{\\Gamma} N_j(x)\\,\\mathrm{d}x$。该积分表示每个形函数下方的面积。\n\n- $m_1 = \\int_{0}^{h_1} N_1(x)\\,\\mathrm{d}x = \\int_{0}^{h_1} (1 - \\frac{x}{h_1})\\,\\mathrm{d}x = [x - \\frac{x^2}{2h_1}]_{0}^{h_1} = h_1 - \\frac{h_1}{2} = \\frac{h_1}{2}$。\n  这是一个底为 $h_1$ 高为 $1$ 的三角形面积。\n\n- $m_2 = \\int_{0}^{h_1+h_2} N_2(x)\\,\\mathrm{d}x = \\int_{0}^{h_1} \\frac{x}{h_1}\\,\\mathrm{d}x + \\int_{h_1}^{h_1+h_2} \\frac{(h_1+h_2)-x}{h_2}\\,\\mathrm{d}x$。\n  这是两个三角形的面积之和：一个底为 $h_1$ 高为 $1$，另一个底为 $h_2$ 高为 $1$。\n  $m_2 = \\frac{1}{2}h_1(1) + \\frac{1}{2}h_2(1) = \\frac{h_1+h_2}{2}$。\n\n- $m_3 = \\int_{h_1}^{h_1+h_2} N_3(x)\\,\\mathrm{d}x = \\int_{h_1}^{h_1+h_2} \\frac{x-h_1}{h_2}\\,\\mathrm{d}x = \\frac{h_2}{2}$。\n  这是一个底为 $h_2$ 高为 $1$ 的三角形面积。\n\n**任务3：双正交对偶基 $\\Psi_i$**\n\n我们构造 $\\{\\Psi_i\\}$ 以满足 $\\int_{\\Gamma} \\Psi_i(x)N_j(x)\\,\\mathrm{d}x = m_i\\delta_{ij}$。\n\n- 对于 $\\Psi_1(x)$：支集在 $S_1$ 上，线性。设 $\\Psi_1(x) = A\\xi+B$，其中 $\\xi=x/h_1$。$\\mathrm{d}x = h_1\\mathrm{d}\\xi$。\n  条件为：\n  1. $\\int_0^1 (A\\xi+B)(1-\\xi) h_1 \\mathrm{d}\\xi = m_1 = h_1/2 \\implies \\int_0^1(B + (A-B)\\xi - A\\xi^2)\\mathrm{d}\\xi = 1/2 \\implies B + (A-B)/2 - A/3 = 1/2 \\implies A/6 + B/2 = 1/2 \\implies A+3B=3$。\n  2. $\\int_0^1 (A\\xi+B)\\xi h_1 \\mathrm{d}\\xi = 0 \\implies \\int_0^1(A\\xi^2+B\\xi)\\mathrm{d}\\xi = 0 \\implies A/3+B/2=0 \\implies 2A+3B=0$。\n  求解 $\\{A+3B=3, 2A+3B=0\\}$ 得到 $A=-3$ 和 $B=2$。\n  因此，在 $S_1$ 上 $\\Psi_1(\\xi) = 2-3\\xi$。用全局坐标表示，$\\Psi_1(x) = 2-3x/h_1$（当 $x \\in S_1$）。\n\n- 对于 $\\Psi_3(x)$：支集在 $S_2$ 上，线性。设 $\\Psi_3(x) = C\\eta+D$，其中 $\\eta=(x-h_1)/h_2$。$\\mathrm{d}x = h_2\\mathrm{d}\\eta$。\n  条件与 $\\Psi_1$ 对称：\n  1. $\\int_0^1 (C\\eta+D)\\eta h_2 \\mathrm{d}\\eta = m_3 = h_2/2 \\implies C/3+D/2 = 1/2 \\implies 2C+3D=3$。\n  2. $\\int_0^1 (C\\eta+D)(1-\\eta) h_2 \\mathrm{d}\\eta = 0 \\implies C/6+D/2=0 \\implies C+3D=0$。\n  求解得到 $C=3$ 和 $D=-1$。\n  因此，在 $S_2$ 上 $\\Psi_3(\\eta) = 3\\eta-1$。用全局坐标表示，$\\Psi_3(x) = 3\\frac{x-h_1}{h_2}-1$（当 $x \\in S_2$）。\n\n- 对于 $\\Psi_2(x)$：支集在 $S_1 \\cup S_2$ 上。一个连续分段线性函数可以写成基函数的线性组合：$\\Psi_2(x) = c_1 N_1(x) + c_2 N_2(x) + c_3 N_3(x)$。双正交条件变成了关于系数 $c_j$ 的一个线性系统：\n  $\\sum_{k=1}^3 c_k \\int_\\Gamma N_k N_j \\mathrm{d}x = m_2 \\delta_{2j}$。设 $K_{jk} = \\int_\\Gamma N_j N_k \\mathrm{d}x$。该系统是 $K\\mathbf{c} = [0, m_2, 0]^T$。质量矩阵 $K$ 对于线性单元是标准的：\n  $$\n  K =\n  \\begin{pmatrix}\n  \\frac{h_1}{3} & \\frac{h_1}{6} & 0 \\\\\n  \\frac{h_1}{6} & \\frac{h_1+h_2}{3} & \\frac{h_2}{6} \\\\\n  0 & \\frac{h_2}{6} & \\frac{h_2}{3}\n  \\end{pmatrix}\n  $$\n  方程组为：\n  1. $\\frac{h_1}{3} c_1 + \\frac{h_1}{6} c_2 = 0 \\implies 2c_1+c_2=0$。\n  2. $\\frac{h_1}{6} c_1 + \\frac{h_1+h_2}{3} c_2 + \\frac{h_2}{6} c_3 = m_2 = \\frac{h_1+h_2}{2}$。\n  3. $\\frac{h_2}{6} c_2 + \\frac{h_2}{3} c_3 = 0 \\implies c_2+2c_3=0$。\n  从 (1) 和 (3) 得，$c_2 = -2c_1$ 且 $c_2 = -2c_3$，这意味着 $c_1=c_3$。代入 (2)：\n  $c_1(\\frac{h_1}{6}) + (-2c_1)(\\frac{h_1+h_2}{3}) + c_1(\\frac{h_2}{6}) = \\frac{h_1+h_2}{2}$\n  $c_1 \\left( \\frac{h_1 - 4(h_1+h_2) + h_2}{6} \\right) = \\frac{h_1+h_2}{2}$\n  $c_1 \\left( \\frac{-3h_1 - 3h_2}{6} \\right) = \\frac{h_1+h_2}{2}$\n  $c_1 \\left( -\\frac{h_1+h_2}{2} \\right) = \\frac{h_1+h_2}{2} \\implies c_1 = -1$。\n  因此，$c_1=-1$，$c_3=-1$，$c_2=2$。\n  所以，$\\Psi_2(x) = -N_1(x) + 2N_2(x) - N_3(x)$。\n\n**任务4：计算砂浆格拉姆矩阵 $M$**\n\n矩阵 $M$ 的元素由 $M_{ij} = \\int_{\\Gamma} \\Psi_i(x)N_j(x)\\,\\mathrm{d}x$ 给出。根据构造，对偶基 $\\{\\Psi_i\\}$ 满足双正交条件 $\\int_{\\Gamma} \\Psi_i N_j \\mathrm{d}x = m_i \\delta_{ij}$。这意味着矩阵 $M$ 必须是对角矩阵，其对角线元素为任务2中计算出的缩放因子 $m_i$。\n$$\nM_{ij} = m_i \\delta_{ij}\n$$\n因此，矩阵 $M$ 为：\n$M_{11} = m_1 = \\frac{h_1}{2}$\n$M_{22} = m_2 = \\frac{h_1+h_2}{2}$\n$M_{33} = m_3 = \\frac{h_2}{2}$\n所有非对角线元素 $M_{ij}$（当 $i \\neq j$）均为零。\n最终的矩阵是：\n$$\nM =\n\\begin{pmatrix}\n\\frac{h_1}{2} & 0 & 0 \\\\\n0 & \\frac{h_1+h_2}{2} & 0 \\\\\n0 & 0 & \\frac{h_2}{2}\n\\end{pmatrix}\n$$\n这个结果是双正交基的定义和特定缩放选择 $m_j=\\int N_j \\mathrm{d}x$ 的直接推论。任务3中对函数 $\\Psi_i$ 的显式构造证明了它们的存在性，并与此结果一致。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{h_{1}}{2} & 0 & 0 \\\\\n0 & \\frac{h_{1}+h_{2}}{2} & 0 \\\\\n0 & 0 & \\frac{h_{2}}{2}\n\\end{pmatrix}\n}\n$$", "id": "3553737"}, {"introduction": "从一维理论走向二维应用，本练习旨在解决一个核心的实践挑战：计算重叠单元间的耦合项。你将需要为两个三角形单元计算砂浆积分，这涉及处理坐标映射以及在相交区域上对形函数的乘积进行积分[@problem_id:3553674]。掌握这项计算对于实现模拟真实曲面接触的砂浆法至关重要。", "problem": "考虑在有限元法（FEM）中通过 Mortar 方法对单边接触约束进行弱施加。在用于二维表面接触的 Mortar 框架中，主面单元和从面单元之间的耦合是通过它们形函数在其支集几何交集上的重叠积分来实现的。设从面单元为一个二维线性三角形表面单元，其全局顶点坐标为 $S_{1}=(0,0)$、$S_{2}=(2,0)$ 和 $S_{3}=(0,2)$，并设主面单元为一个二维线性三角形表面单元，其全局顶点坐标为 $M_{1}=(\\tfrac{1}{2},\\tfrac{1}{2})$、$M_{2}=(\\tfrac{3}{2},\\tfrac{1}{2})$ 和 $M_{3}=(\\tfrac{1}{2},\\tfrac{3}{2})$。假设两个单元都使用同阶的 Lagrange 形函数。将坐标视为无量纲。\n\n定义参考三角形 $\\widehat{\\Delta}=\\{(\\xi,\\eta)\\,|\\,\\xi\\ge 0,\\ \\eta\\ge 0,\\ \\xi+\\eta\\le 1\\}$ 以及 $\\widehat{\\Delta}$ 上的标准线性形函数为 $N_{1}(\\xi,\\eta)=1-\\xi-\\eta$、$N_{2}(\\xi,\\eta)=\\xi$、$N_{3}(\\xi,\\eta)=\\eta$。设从面三角形映射是从 $\\widehat{\\Delta}$ 到从面单元的仿射映射：$(x,y)=\\boldsymbol{F}_{s}(\\xi,\\eta)$，主面三角形映射也类似：$(x,y)=\\boldsymbol{F}_{m}(\\xi,\\eta)$。使用这些映射，重叠区域 $\\Gamma_{\\text{overlap}}$ 是两个单元的几何交集。\n\n从 Mortar 耦合项是主、从形函数的重叠积分这一原理出发，显式推导局部到全局的映射 $\\boldsymbol{F}_{s}$ 和 $\\boldsymbol{F}_{m}$，并确定所得到的重叠区域 $\\Gamma_{\\text{overlap}}$。给出重叠区域面积的显式公式。然后计算九个重叠积分\n$$\nI_{ij}\\;=\\;\\int_{\\Gamma_{\\text{overlap}}}N_{i}^{(m)}(x,y)\\,N_{j}^{(s)}(x,y)\\,\\mathrm{d}\\Gamma,\\qquad i,j\\in\\{1,2,3\\},\n$$\n其中 $N_{i}^{(m)}$ 和 $N_{j}^{(s)}$ 分别是通过 $\\boldsymbol{F}_{m}$ 和 $\\boldsymbol{F}_{s}$ 拉回到全局坐标的主、从形函数。将这九个积分项按行主序以单行矩阵的形式报告 $\\big(I_{11},I_{12},I_{13},I_{21},I_{22},I_{23},I_{31},I_{32},I_{33}\\big)$。\n\n将最终的积分项表示为精确的有理数。无需四舍五入。由于所有坐标都是无量纲的，因此不需要单位。", "solution": "首先验证问题，以确保其科学基础可靠、适定且客观。\n\n### 步骤 1：提取已知条件\n-   **从面单元顶点**：$S_{1}=(0,0)$、$S_{2}=(2,0)$、$S_{3}=(0,2)$。\n-   **主面单元顶点**：$M_{1}=(\\tfrac{1}{2},\\tfrac{1}{2})$、$M_{2}=(\\tfrac{3}{2},\\tfrac{1}{2})$、$M_{3}=(\\tfrac{1}{2},\\tfrac{3}{2})$。\n-   **参考三角形**：$\\widehat{\\Delta}=\\{(\\xi,\\eta)\\,|\\,\\xi\\ge 0,\\ \\eta\\ge 0,\\ \\xi+\\eta\\le 1\\}$。\n-   **参考形函数**：$N_{1}(\\xi,\\eta)=1-\\xi-\\eta$、$N_{2}(\\xi,\\eta)=\\xi$、$N_{3}(\\xi,\\eta)=\\eta$。\n-   **映射**：从面映射 $\\boldsymbol{F}_{s}(\\xi,\\eta)$ 和主面映射 $\\boldsymbol{F}_{m}(\\xi,\\eta)$ 都是从 $\\widehat{\\Delta}$ 出发的仿射映射。\n-   **重叠区域**：$\\Gamma_{\\text{overlap}}$ 是从面单元和主面单元的几何交集。\n-   **待计算的积分**：$I_{ij}\\;=\\;\\int_{\\Gamma_{\\text{overlap}}}N_{i}^{(m)}(x,y)\\,N_{j}^{(s)}(x,y)\\,\\mathrm{d}\\Gamma$，对于 $i,j\\in\\{1,2,3\\}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学性**：问题陈述描述了 Mortar 有限元法在接触问题背景下的一个标准计算。所有概念——形函数、仿射映射、重叠积分——都是计算力学的基础。该问题在科学上是合理的。\n-   **适定性**：两个单元的几何数据都已明确给出，形函数也是标准的。任务是计算一个明确定义的域上的定积分。存在唯一且有意义的解。\n-   **客观性**：问题使用精确的数学语言陈述，没有主观或模糊的术语。\n-   **完备性与一致性**：所提供的数据足以定义所有必要的量。初步检查显示，主面单元的顶点 $M_1, M_2, M_3$ 都位于由 $x \\ge 0$, $y \\ge 0$ 和 $x+y \\le 2$ 定义的从面单元边界内部。这意味着存在非空的重叠区域，且设置是一致的。\n\n### 步骤 3：结论与行动\n问题有效。下面是一个完整的、有理据的解答。\n\n***\n\n### 解答\n\n解答过程分四个阶段进行：(1) 推导仿射映射，(2) 确定重叠区域及其面积，(3) 在一个共同的坐标系中表示形函数，以及 (4) 计算重叠积分。\n\n#### 1. 仿射映射 $\\boldsymbol{F}_{s}$ 和 $\\boldsymbol{F}_{m}$\n从参考三角形 $\\widehat{\\Delta}$ 到顶点为 $\\boldsymbol{X}_1, \\boldsymbol{X}_2, \\boldsymbol{X}_3$ 的目标三角形的仿射映射 $\\boldsymbol{F}$ 由下式给出：$\\boldsymbol{x}(\\xi,\\eta) = \\boldsymbol{X}_1 N_1(\\xi,\\eta) + \\boldsymbol{X}_2 N_2(\\xi,\\eta) + \\boldsymbol{X}_3 N_3(\\xi,\\eta)$。\n\n对于从面单元，其顶点为 $S_{1}=(0,0)$、$S_{2}=(2,0)$ 和 $S_{3}=(0,2)$：\n$$\n\\boldsymbol{F}_{s}(\\xi,\\eta) = (0,0)(1-\\xi-\\eta) + (2,0)\\xi + (0,2)\\eta = (2\\xi, 2\\eta)\n$$\n因此，对于从面映射，我们有全局坐标 $(x,y)$ 作为局部坐标 $(\\xi,\\eta)$ 的函数：$x=2\\xi$ 和 $y=2\\eta$。\n\n对于主面单元，其顶点为 $M_{1}=(\\tfrac{1}{2},\\tfrac{1}{2})$、$M_{2}=(\\tfrac{3}{2},\\tfrac{1}{2})$ 和 $M_{3}=(\\tfrac{1}{2},\\tfrac{3}{2})$：\n$$\n\\boldsymbol{F}_{m}(\\xi,\\eta) = (\\tfrac{1}{2},\\tfrac{1}{2})(1-\\xi-\\eta) + (\\tfrac{3}{2},\\tfrac{1}{2})\\xi + (\\tfrac{1}{2},\\tfrac{3}{2})\\eta\n$$\n其分量为：\n$$\nx(\\xi,\\eta) = \\frac{1}{2}(1-\\xi-\\eta) + \\frac{3}{2}\\xi + \\frac{1}{2}\\eta = \\frac{1}{2} - \\frac{1}{2}\\xi - \\frac{1}{2}\\eta + \\frac{3}{2}\\xi + \\frac{1}{2}\\eta = \\frac{1}{2} + \\xi\n$$\n$$\ny(\\xi,\\eta) = \\frac{1}{2}(1-\\xi-\\eta) + \\frac{1}{2}\\xi + \\frac{3}{2}\\eta = \\frac{1}{2} - \\frac{1}{2}\\xi - \\frac{1}{2}\\eta + \\frac{1}{2}\\xi + \\frac{3}{2}\\eta = \\frac{1}{2} + \\eta\n$$\n因此，主面映射为 $\\boldsymbol{F}_{m}(\\xi,\\eta) = (\\tfrac{1}{2}+\\xi, \\tfrac{1}{2}+\\eta)$。\n\n#### 2. 重叠区域 $\\Gamma_{\\text{overlap}}$ 及其面积\n从面单元 $T_s$ 是顶点为 $(0,0), (2,0), (0,2)$ 的三角形。它由不等式 $x \\ge 0$、$y \\ge 0$ 和 $x+y \\le 2$ 描述。\n主面单元 $T_m$ 是顶点为 $(\\tfrac{1}{2},\\tfrac{1}{2}), (\\tfrac{3}{2},\\tfrac{1}{2}), (\\tfrac{1}{2},\\tfrac{3}{2})$ 的三角形。\n我们检查 $T_m$ 的顶点是否位于 $T_s$ 内部：\n- 对于 $M_1=(\\tfrac{1}{2},\\tfrac{1}{2})$：$\\tfrac{1}{2} \\ge 0$，$\\tfrac{1}{2} \\ge 0$，且 $\\tfrac{1}{2}+\\tfrac{1}{2} = 1 \\le 2$。它在内部。\n- 对于 $M_2=(\\tfrac{3}{2},\\tfrac{1}{2})$：$\\tfrac{3}{2} \\ge 0$，$\\tfrac{1}{2} \\ge 0$，且 $\\tfrac{3}{2}+\\tfrac{1}{2} = 2 \\le 2$。它在内部。\n- 对于 $M_3=(\\tfrac{1}{2},\\tfrac{3}{2})$：$\\tfrac{1}{2} \\ge 0$，$\\tfrac{3}{2} \\ge 0$，且 $\\tfrac{1}{2}+\\tfrac{3}{2} = 2 \\le 2$。它在内部。\n由于两个单元都是凸三角形，并且 $T_m$ 的所有顶点都在 $T_s$ 的内部或边界上，所以主面单元完全包含在从面单元中。因此，重叠区域就是主面单元本身：$\\Gamma_{\\text{overlap}} = T_m$。\n\n$\\Gamma_{\\text{overlap}}$ 的面积就是 $T_m$ 的面积。顶点为 $\\boldsymbol{M}_1, \\boldsymbol{M}_2, \\boldsymbol{M}_3$ 的三角形面积的显式公式为 $A = \\frac{1}{2}|\\det(\\boldsymbol{M}_2-\\boldsymbol{M}_1, \\boldsymbol{M}_3-\\boldsymbol{M}_1)|$。\n这里, $\\boldsymbol{M}_2-\\boldsymbol{M}_1 = (1,0)$ 且 $\\boldsymbol{M}_3-\\boldsymbol{M}_1 = (0,1)$。\n$$\nA = \\frac{1}{2} \\left| \\det \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} \\right| = \\frac{1}{2}\n$$\n另外，$T_m$ 是一个直角三角形，其直角边长度为 $|\\tfrac{3}{2}-\\tfrac{1}{2}|=1$ 和 $|\\tfrac{3}{2}-\\tfrac{1}{2}|=1$。面积是 $\\frac{1}{2} \\times 1 \\times 1 = \\frac{1}{2}$。\n\n#### 3. 用于积分的形函数\n积分 $I_{ij}$ 定义在 $\\Gamma_{\\text{overlap}} = T_m$ 上。最方便的计算方法是使用 $\\boldsymbol{F}_{m}$ 的逆映射将积分域映射回主单元的参考单元 $\\widehat{\\Delta}$。\n面积微元变换为 $\\mathrm{d}\\Gamma = |\\det(J_m)| \\mathrm{d}\\xi \\mathrm{d}\\eta$，其中 $J_m$ 是 $\\boldsymbol{F}_{m}$ 的雅可比矩阵。\n$$\nJ_m = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}\n$$\n行列式为 $|\\det(J_m)| = 1$。积分变为：\n$$\nI_{ij} = \\int_{\\widehat{\\Delta}} (N_i^{(m)} \\circ \\boldsymbol{F}_m)(\\xi,\\eta) \\cdot (N_j^{(s)} \\circ \\boldsymbol{F}_m)(\\xi,\\eta) \\, \\mathrm{d}\\xi \\mathrm{d}\\eta\n$$\n- 主形函数与其自身的映射复合后，变回简单的参考形函数：$(N_i^{(m)} \\circ \\boldsymbol{F}_m)(\\xi,\\eta) = N_i(\\xi, \\eta)$。\n所以，$N_1^{(m)} \\rightarrow 1-\\xi-\\eta$，$N_2^{(m)} \\rightarrow \\xi$，$N_3^{(m)} \\rightarrow \\eta$。\n- 从形函数必须用主单元的局部坐标 $(\\xi, \\eta)$ 来表示。首先，我们通过对 $\\boldsymbol{F}_s$ 求逆来找到从形函数 $N_j^{(s)}$ 在全局坐标 $(x,y)$ 下的表达式：$(\\xi_s, \\eta_s) = (\\frac{x}{2}, \\frac{y}{2})$。\n$N_1^{(s)}(x,y) = 1-\\xi_s-\\eta_s = 1 - \\frac{x}{2} - \\frac{y}{2}$\n$N_2^{(s)}(x,y) = \\xi_s = \\frac{x}{2}$\n$N_3^{(s)}(x,y) = \\eta_s = \\frac{y}{2}$\n现在，我们将它们与 $\\boldsymbol{F}_m(x(\\xi,\\eta), y(\\xi,\\eta))=(\\tfrac{1}{2}+\\xi, \\tfrac{1}{2}+\\eta)$ 复合：\n$N_1^{(s)} \\circ \\boldsymbol{F}_m = 1 - \\frac{1}{2}(\\tfrac{1}{2}+\\xi) - \\frac{1}{2}(\\tfrac{1}{2}+\\eta) = 1 - \\tfrac{1}{4} - \\tfrac{\\xi}{2} - \\tfrac{1}{4} - \\tfrac{\\eta}{2} = \\frac{1}{2} - \\frac{\\xi}{2} - \\frac{\\eta}{2} = \\frac{1}{2}(1-\\xi-\\eta)$\n$N_2^{(s)} \\circ \\boldsymbol{F}_m = \\frac{1}{2}(\\tfrac{1}{2}+\\xi) = \\frac{1}{4} + \\frac{\\xi}{2}$\n$N_3^{(s)} \\circ \\boldsymbol{F}_m = \\frac{1}{2}(\\tfrac{1}{2}+\\eta) = \\frac{1}{4} + \\frac{\\eta}{2}$\n\n#### 4. 积分计算\n我们使用在 $\\widehat{\\Delta}$ 上对单项式积分的标准公式：\n$$\n\\int_{\\widehat{\\Delta}} \\xi^a \\eta^b \\mathrm{d}\\xi \\mathrm{d}\\eta = \\frac{a! b!}{(a+b+2)!}\n$$\n我们将其记为 $\\mathcal{I}(a,b)$。一些关键值为：$\\mathcal{I}(0,0)=\\frac{1}{2}$，$\\mathcal{I}(1,0)=\\mathcal{I}(0,1)=\\frac{1}{6}$，$\\mathcal{I}(2,0)=\\mathcal{I}(0,2)=\\frac{1}{12}$，$\\mathcal{I}(1,1)=\\frac{1}{24}$。\n\n积分计算如下：\n\n$I_{11} = \\int_{\\widehat{\\Delta}} (1-\\xi-\\eta) \\frac{1}{2}(1-\\xi-\\eta) \\mathrm{d}\\Gamma = \\frac{1}{2}\\int_{\\widehat{\\Delta}} (1-\\xi-\\eta)^2 \\mathrm{d}\\Gamma = \\frac{1}{2}\\int_{\\widehat{\\Delta}}(1-2\\xi-2\\eta+\\xi^2+2\\xi\\eta+\\eta^2)\\mathrm{d}\\Gamma$\n$I_{11} = \\frac{1}{2}[\\mathcal{I}(0,0) - 2\\mathcal{I}(1,0) - 2\\mathcal{I}(0,1) + \\mathcal{I}(2,0) + 2\\mathcal{I}(1,1) + \\mathcal{I}(0,2)] = \\frac{1}{2}[\\frac{1}{2} - \\frac{2}{6} - \\frac{2}{6} + \\frac{1}{12} + \\frac{2}{24} + \\frac{1}{12}] = \\frac{1}{2}[\\frac{6-4-4+1+1+1}{12}]=\\frac{1}{24}$。\n\n$I_{12} = \\int_{\\widehat{\\Delta}} (1-\\xi-\\eta)(\\frac{1}{4}+\\frac{\\xi}{2}) \\mathrm{d}\\Gamma = \\int_{\\widehat{\\Delta}} (\\frac{1}{4}+\\frac{\\xi}{4}-\\frac{\\eta}{4}-\\frac{\\xi^2}{2}-\\frac{\\xi\\eta}{2}) \\mathrm{d}\\Gamma$\n$I_{12} = \\frac{1}{4}\\mathcal{I}(0,0)+\\frac{1}{4}\\mathcal{I}(1,0)-\\frac{1}{4}\\mathcal{I}(0,1)-\\frac{1}{2}\\mathcal{I}(2,0)-\\frac{1}{2}\\mathcal{I}(1,1) = \\frac{1}{4}(\\frac{1}{2})+\\frac{1}{4}(\\frac{1}{6})-\\frac{1}{4}(\\frac{1}{6})-\\frac{1}{2}(\\frac{1}{12})-\\frac{1}{2}(\\frac{1}{24}) = \\frac{1}{8}-\\frac{1}{24}-\\frac{1}{48} = \\frac{6-2-1}{48}=\\frac{3}{48}=\\frac{1}{16}$。\n\n$I_{13} = \\int_{\\widehat{\\Delta}} (1-\\xi-\\eta)(\\frac{1}{4}+\\frac{\\eta}{2}) \\mathrm{d}\\Gamma$。根据与 $I_{12}$ 的对称性（交换 $\\xi$ 和 $\\eta$），$I_{13}=\\frac{1}{16}$。\n\n$I_{21} = \\int_{\\widehat{\\Delta}} \\xi \\frac{1}{2}(1-\\xi-\\eta) \\mathrm{d}\\Gamma = \\frac{1}{2}\\int_{\\widehat{\\Delta}} (\\xi-\\xi^2-\\xi\\eta) \\mathrm{d}\\Gamma$\n$I_{21} = \\frac{1}{2}[\\mathcal{I}(1,0)-\\mathcal{I}(2,0)-\\mathcal{I}(1,1)] = \\frac{1}{2}[\\frac{1}{6}-\\frac{1}{12}-\\frac{1}{24}] = \\frac{1}{2}[\\frac{4-2-1}{24}]=\\frac{1}{48}$。\n\n$I_{22} = \\int_{\\widehat{\\Delta}} \\xi(\\frac{1}{4}+\\frac{\\xi}{2}) \\mathrm{d}\\Gamma = \\frac{1}{4}\\int_{\\widehat{\\Delta}}\\xi\\mathrm{d}\\Gamma + \\frac{1}{2}\\int_{\\widehat{\\Delta}}\\xi^2\\mathrm{d}\\Gamma$\n$I_{22} = \\frac{1}{4}\\mathcal{I}(1,0) + \\frac{1}{2}\\mathcal{I}(2,0) = \\frac{1}{4}(\\frac{1}{6}) + \\frac{1}{2}(\\frac{1}{12}) = \\frac{1}{24}+\\frac{1}{24}=\\frac{2}{24}=\\frac{1}{12}$。\n\n$I_{23} = \\int_{\\widehat{\\Delta}} \\xi(\\frac{1}{4}+\\frac{\\eta}{2}) \\mathrm{d}\\Gamma = \\frac{1}{4}\\int_{\\widehat{\\Delta}}\\xi\\mathrm{d}\\Gamma + \\frac{1}{2}\\int_{\\widehat{\\Delta}}\\xi\\eta\\mathrm{d}\\Gamma$\n$I_{23} = \\frac{1}{4}\\mathcal{I}(1,0) + \\frac{1}{2}\\mathcal{I}(1,1) = \\frac{1}{4}(\\frac{1}{6}) + \\frac{1}{2}(\\frac{1}{24}) = \\frac{1}{24}+\\frac{1}{48}=\\frac{2+1}{48}=\\frac{3}{48}=\\frac{1}{16}$。\n\n$I_{31} = \\int_{\\widehat{\\Delta}} \\eta \\frac{1}{2}(1-\\xi-\\eta) \\mathrm{d}\\Gamma$。根据与 $I_{21}$ 的对称性，$I_{31}=\\frac{1}{48}$。\n\n$I_{32} = \\int_{\\widehat{\\Delta}} \\eta(\\frac{1}{4}+\\frac{\\xi}{2}) \\mathrm{d}\\Gamma$。根据与 $I_{23}$ 的对称性，$I_{32}=\\frac{1}{16}$。\n\n$I_{33} = \\int_{\\widehat{\\Delta}} \\eta(\\frac{1}{4}+\\frac{\\eta}{2}) \\mathrm{d}\\Gamma$。根据与 $I_{22}$ 的对称性，$I_{33}=\\frac{1}{12}$。\n\n九个重叠积分按行主序 $(I_{11},I_{12},I_{13},I_{21},I_{22},I_{23},I_{31},I_{32},I_{33})$ 排列为：\n$(\\frac{1}{24}, \\frac{1}{16}, \\frac{1}{16}, \\frac{1}{48}, \\frac{1}{12}, \\frac{1}{16}, \\frac{1}{48}, \\frac{1}{16}, \\frac{1}{12})$。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{24} & \\frac{1}{16} & \\frac{1}{16} & \\frac{1}{48} & \\frac{1}{12} & \\frac{1}{16} & \\frac{1}{48} & \\frac{1}{16} & \\frac{1}{12} \\end{pmatrix}}\n$$", "id": "3553674"}, {"introduction": "尽管功能强大，但基本的“从面到主面”(slave-to-master)砂浆公式存在固有偏差，这会影响接触力计算的准确性，尤其是在网格不匹配的情况下。这个编程练习将引导你从第一性原理出发，构建一个简单的一维模型来展示并量化这种偏差[@problem_id:3553682]。通过比较传递的压力与主面上的“最佳拟合”近似，你将对这一重要的概念局限性获得切实的理解。", "problem": "在计算固体力学中，考虑两个可变形体之间的一维无摩擦接触界面 $\\Gamma = [0,1]$，其中接触约束通过采用完全传递的从-主格式的砂浆法来施加。该界面在两侧（从面和主面）使用有限元法（FEM）独立进行离散化，采用均匀网格上的一阶拉格朗日基函数。设从面有 $n_s$ 个单元，主面有 $n_m$ 个单元。将从面基函数表示为 $\\{N_i^s(x)\\}_{i=0}^{n_s}$，主面基函数表示为 $\\{N_j^m(x)\\}_{j=0}^{n_m}$，每组基函数均构成单位分解。一个给定的接触压力分布 $p(x)$ 作用在 $\\Gamma$ 上。\n\n在完全传递的从-主砂浆格式中，接触压力通过在从面上进行 $L^2$ 投影到从空间来进行近似，得到离散近似值 $p_h(x) = \\sum_{i=0}^{n_s} \\lambda_i N_i^s(x)$，其系数 $\\{\\lambda_i\\}$ 从 $L^2$ 正交条件获得。然后，由从面近似引起的主面面力矢量通过弱传递 $f_j^m = \\int_{\\Gamma} N_j^m(x)\\, p_h(x)\\, \\mathrm{d}x$ 计算得出。\n\n当两种离散化不兼容时（例如在粗-细网格耦合中），会产生偏差，因为完全传递的格式优先考虑了从空间。为了构造一个反例并量化此偏差，请从第一性原理出发：\n\n- 从虚功原理和使用拉格朗日乘子弱形式施加接触约束开始，确保接触壓力場仅通过从面上的检验函数进行弱形式表示。\n- 使用 $L^2$ 投影的定义，从条件 $\\int_{\\Gamma} N_i^s(x)\\, p_h(x)\\, \\mathrm{d}x = \\int_{\\Gamma} N_i^s(x)\\, p(x)\\, \\mathrm{d}x$（对于所有从基函数索引 $i$）获得从面系数 $\\{\\lambda_i\\}$，不要调用任何快捷公式。\n- 定义主面最佳 $L^2$ 面力数据 $b_j^m = \\int_{\\Gamma} N_j^m(x)\\, p(x)\\, \\mathrm{d}x$，它代表了精确压力 $p(x)$ 在主面上的 $L^2$ 投影矩。\n- 根据 $p_h(x)$ 定义传递的主面力矢量 $f^m$，并将其与 $b^m$进行比较，以计算主空间中的面力平衡误差。设 $t_h^m(x)$ 是与 $f^m$ 关联的主空间函数，$p_m(x)$ 是 $p(x)$ 在主空间上的 $L^2$ 投影。界面面力平衡误差通过主空间中的相对 $L^2$ 误差来量化\n$$\nr = \\frac{\\| t_h^m - p_m \\|_{L^2(\\Gamma)}}{\\| p_m \\|_{L^2(\\Gamma)}} \\, ,\n$$\n表示为一个无量纲浮点数。三角函数的参数仅使用弧度。\n\n算法构造要求：\n\n- 使用定义 $M_{ij} = \\int_{\\Gamma} N_i(x) N_j(x)\\, \\mathrm{d}x$ 从第一性原理为每一侧组装从面和主面质量矩阵。对于均匀网格上的一阶拉格朗日单元，使用精确的单元级积分。\n- 使用从面质量矩阵和右侧项 $b_i^s = \\int_{\\Gamma} N_i^s(x)\\, p(x)\\, \\mathrm{d}x$，从 $L^2$ 投影条件求解从面系数 $\\{\\lambda_i\\}$。\n- 通过将从面近似弱耦合到主面基函数，构造传递的主面力矩 $f_j^m = \\int_{\\Gamma} N_j^m(x)\\, p_h(x)\\, \\mathrm{d}x$。\n- 构造主面 $L^2$ 投影矩 $b_j^m = \\int_{\\Gamma} N_j^m(x)\\, p(x)\\, \\mathrm{d}x$，并在形成函数的 $L^2$ 范数时，通过主面质量矩阵将力矩矢量转换为主空间系数。\n- 计算上面定义的相对误差 $r$。\n\n测试套件：\n\n计算以下四种情况的相对误差 $r$，这些情况旨在揭示偏差、对称性和表示的边界情况：\n\n1. 从面细，主面粗，非平凡振荡压力：$n_s = 8$，$n_m = 2$，$p(x) = \\sin(2\\pi x)$，其中 $\\sin$ 使用弧度。\n2. 从面粗，主面细，非平凡振荡压力：$n_s = 2$，$n_m = 8$，$p(x) = \\sin(2\\pi x)$，其中 $\\sin$ 使用弧度。\n3. 从面与主面相同，网格匹配，非平凡振荡压力：$n_s = 4$，$n_m = 4$，$p(x) = \\sin(2\\pi x)$，其中 $\\sin$ 使用弧度。\n4. 从面粗，主面细，全局线性压力可在线性有限元空间中精确表示：$n_s = 2$，$n_m = 8$，$p(x) = 0.5 + 0.3 x$。\n\n最终输出格式：\n\n您的程序应生成一行输出，其中包含按测试套件顺序排列的四个相对误差，格式为逗号分隔的列表，并用方括号括起来，例如 $\\texttt{[r_1,r_2,r_3,r_4]}$，其中每个 $r_k$ 是一个浮点数。所有输出必须是无量纲的。", "solution": "该问题要求量化一维从-主砂浆接触方法中的面力平衡误差。此误差源于该公式的非对称性，即“完全传递”特性，其中接触压力首先投影到从离散空间，然后传递到主面。我们将从有限元法（FEM）的第一性原理出发构建一个解决方案。\n\n### 1. 离散化与基函数\n接触界面 $\\Gamma = [0,1]$ 在每一侧（从面和主面）都被离散化为包含 $n$ 个单元的均匀网格。单元尺寸为 $h = 1/n$，节点位于 $x_k = k \\cdot h$，其中 $k \\in \\{0, 1, ..., n\\}$。我们使用一阶拉格朗日基函数，也称为“帽函数”。与节点 $x_k$ 相关联的基函数 $N_k(x)$ 是一个分段线性函数，仅在区间 $[x_{k-1}, x_{k+1}]$ 上非零（对于边界节点 $k=0$ 和 $k=n$ 有适当的修改）。它在 $x_k$ 处取值为 $1$，在所有其他节点处取值为 $0$。该有限元空间中的任何函数 $u_h(x)$ 都可以写成这些基函数的线性组合：$u_h(x) = \\sum_{k=0}^{n} c_k N_k(x)$，其中 $c_k$ 是系数（通常是节点值）。\n\n### 2. $L^2$ 投影与系统构建\n砂浆法的核心涉及将场从一个空间投影到另一个空间。一个函数 $f(x)$ 到由基函数 $\\{N_i(x)\\}$ 张成的有限元空间上的 $L^2$ 投影产生一个近似 $f_h(x) = \\sum_i c_i N_i(x)$。系数 $c_i$ 是通过强制误差 $f - f_h$ 与基函数正交来确定的，即对所有 $j$ 满足 $\\int_{\\Gamma} (f - f_h) N_j(x) dx = 0$。这导出一个线性方程组：\n$$\n\\sum_{i} c_i \\left( \\int_{\\Gamma} N_j(x) N_i(x) dx \\right) = \\int_{\\Gamma} f(x) N_j(x) dx\n$$\n这是一个线性系统 $M c = b$，其中 $M$ 是质量矩阵，其元素为 $M_{ji} = \\int_{\\Gamma} N_j(x) N_i(x) dx$，$b$ 是载荷矢量，其元素为 $b_j = \\int_{\\Gamma} f(x) N_j(x) dx$。\n\n### 3. 质量矩阵和载荷矢量构建\n对于单元尺寸为 $h$ 的均匀网格，一个 $(n+1)$ 节点系统的质量矩阵 $M$ 是一个对称三对角矩阵：\n$$\nM = \\frac{h}{6}\n\\begin{pmatrix}\n2 & 1 & 0 & \\dots \\\\\n1 & 4 & 1 & \\\\\n0 & \\ddots & \\ddots & \\ddots \\\\\n& 1 & 4 & 1 \\\\\n\\dots & 0 & 1 & 2\n\\end{pmatrix}\n$$\n载荷矢量的元素 $b_k = \\int_{\\Gamma} N_k(x) p(x) dx$ 和耦合矩阵（见下文）的元素需要对基函数与压力函数 $p(x)$ 的乘积进行积分。由于基函数是分段线性的，且给定的压力函数为 $p(x)=\\sin(2\\pi x)$ 和 $p(x)=0.5+0.3x$，这些积分可以解析计算。对于一个单元上的通用积分 $\\int (Ax+B)g(x)dx$，我们使用精确的反导数。\n\n### 4. 砂浆法步骤与耦合\n从-主格式按以下步骤进行：\n1.  **将压力投影到从空间**：用 $p_h(x) = \\sum_i \\lambda_i N_i^s(x)$ 来近似真实压力 $p(x)$。系数 $\\lambda$ 通过求解从面系统 $M^s \\lambda = b^s$ 得到，其中 $M^s$ 和 $b^s$ 是从面网格的质量矩阵和载荷矢量。\n2.  **传递到主空间**：主面上的离散面力（力）矢量 $f^m$ 是通过用主面基函数 $N_j^m(x)$ 测试从面近似 $p_h(x)$ 获得的：\n    $$\n    f_j^m = \\int_{\\Gamma} N_j^m(x) p_h(x) dx = \\int_{\\Gamma} N_j^m(x) \\left( \\sum_i \\lambda_i N_i^s(x) \\right) dx = \\sum_i \\left( \\int_{\\Gamma} N_j^m(x) N_i^s(x) dx \\right) \\lambda_i\n    $$\n    这定义了一个线性变换 $f^m = D \\lambda$，其中 $D$ 是一个 $(n_m+1) \\times (n_s+1)$ 的耦合矩阵，其元素为 $D_{ji} = \\int_{\\Gamma} N_j^m(x) N_i^s(x) dx$。该矩阵耦合了不匹配的从-主网格。其元素通过对两个分段线性基函数的乘积（这是一个分段二次函数）进行积分来计算。积分是在由两个网格的所有节点联合定义的初等区间上进行的。\n\n### 5. 误差量化\n为了量化偏差，我们在主空间中比较两个函数：\n-   $p_m(x)$：主空间中真实压力 $p(x)$ 的“最佳”近似。这是 $p(x)$ 到主空间的直接 $L^2$ 投影，由 $p_m(x) = \\sum_j \\nu_j N_j^m(x)$ 给出，其中 $M^m \\nu = b^m$。\n-   $t_h^m(x)$：主空间中对应于传递的面力 $f^m$ 的函数。它由 $t_h^m(x) = \\sum_j \\mu_j N_j^m(x)$ 给出，其中 $M^m \\mu = f^m$。\n\n误差是这两个函数之差，用 $L^2$ 范数衡量。函数 $g_h(x) = \\sum_k c_k N_k(x)$ 的 $L^2$ 范数平方由 $\\|g_h\\|^2_{L^2} = c^T M c$ 给出。\n相对误差 $r$ 为：\n$$\nr = \\frac{\\| t_h^m - p_m \\|_{L^2}}{\\| p_m \\|_{L^2}} = \\sqrt{\\frac{(\\mu - \\nu)^T M^m (\\mu - \\nu)}{\\nu^T M^m \\nu}}\n$$\n对每个测试案例计算此表达式。对于精确压力场 $p(x)$ 同时位于主面和从面的有限元空间内的情况（案例3和4），传递是精确的，导致 $f^m = b^m$，$\\mu=\\nu$，因此理论误差为 $r=0$。任何非零结果都是由数值浮点不精确性引起的。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the mortar method contact bias problem for the given test suite.\n    \"\"\"\n\n    class MortarAnalyzer:\n        \"\"\"\n        A class to encapsulate the computations for the mortar method analysis.\n        \"\"\"\n\n        def _get_mass_matrix(self, n: int) -> np.ndarray:\n            \"\"\"\n            Assembles the 1D consistent mass matrix for linear Lagrange elements on a uniform mesh.\n            \"\"\"\n            if n == 0:\n                return np.array([[0.0]])\n            h = 1.0 / n\n            size = n + 1\n            M = np.zeros((size, size))\n            \n            # Diagonal entries\n            M.flat[::size + 1] = 4.0\n            M[0, 0] = 2.0\n            M[n, n] = 2.0\n            \n            # Off-diagonal entries\n            if n > 0:\n                M.flat[1::size + 1] = 1.0\n                M.flat[size::size + 1] = 1.0\n            \n            return M * (h / 6.0)\n\n        def _antideriv_linear_p(self, A: float, B: float, C1: float, C2: float, x: float) -> float:\n            \"\"\"Antiderivative of (Ax+B)(C1+C2x).\"\"\"\n            c_x3 = A * C2 / 3.0\n            c_x2 = (A * C1 + B * C2) / 2.0\n            c_x1 = B * C1\n            return c_x3 * x**3 + c_x2 * x**2 + c_x1 * x\n        \n        def _antideriv_sin_p(self, A: float, B: float, k: float, x: float) -> float:\n            \"\"\"Antiderivative of (Ax+B)sin(kx).\"\"\"\n            term1 = -(A * x + B) * np.cos(k * x) / k\n            term2 = A * np.sin(k * x) / (k**2)\n            return term1 + term2\n\n        def _get_load_vector(self, n: int, p_type: str, p_params: dict) -> np.ndarray:\n            \"\"\"\n            Assembles the 1D load vector by analytically integrating p(x) against basis functions.\n            \"\"\"\n            if n == 0:\n                return np.array([0.0]])\n            h = 1.0 / n\n            nodes = np.linspace(0, 1, n + 1)\n            b = np.zeros(n + 1)\n\n            for i in range(n):\n                x1, x2 = nodes[i], nodes[i+1]\n                \n                # Contribution from basis function N_i (right slope)\n                # N_i(x) = (x_{i+1} - x) / h = -x/h + x_{i+1}/h for x in [x_i, x_{i+1}]\n                A_i, B_i = -1.0/h, x2/h\n                \n                # Contribution from basis function N_{i+1} (left slope)\n                # N_{i+1}(x) = (x - x_i) / h = x/h - x_i/h for x in [x_i, x_{i+1}]\n                A_ip1, B_ip1 = 1.0/h, -x1/h\n                \n                if p_type == 'sin':\n                    k = p_params['k']\n                    integral_i = self._antideriv_sin_p(A_i, B_i, k, x2) - self._antideriv_sin_p(A_i, B_i, k, x1)\n                    integral_ip1 = self._antideriv_sin_p(A_ip1, B_ip1, k, x2) - self._antideriv_sin_p(A_ip1, B_ip1, k, x1)\n                elif p_type == 'linear':\n                    C1, C2 = p_params['C1'], p_params['C2']\n                    integral_i = self._antideriv_linear_p(A_i, B_i, C1, C2, x2) - self._antideriv_linear_p(A_i, B_i, C1, C2, x1)\n                    integral_ip1 = self._antideriv_linear_p(A_ip1, B_ip1, C1, C2, x2) - self._antideriv_linear_p(A_ip1, B_ip1, C1, C2, x1)\n                else: \n                    raise ValueError(\"Unknown pressure function type.\")\n\n                b[i] += integral_i\n                b[i+1] += integral_ip1\n                \n            return b\n\n        def _get_basis_fun_params(self, node_coords: np.ndarray, node_idx: int, x1: float, x2: float) -> tuple[float, float]:\n            \"\"\"\n            Gets the coefficients (A, B) of the linear basis function N_node_idx on interval [x1, x2].\n            Assumes [x1, x2] does not span a node.\n            \"\"\"\n            h = node_coords[1] - node_coords[0] if len(node_coords) > 1 else 1.0\n            n = len(node_coords) - 1\n            node_x = node_coords[node_idx]\n\n            # Interval is outside the support of the basis function\n            if x1 >= node_x + h or x2 = node_x - h: return 0., 0.\n\n            # Left slope of hat function\n            if node_idx > 0 and x2 = node_x and x1 >= node_coords[node_idx - 1]:\n                 return 1./h, -node_coords[node_idx - 1]/h\n            # Right slope of hat function\n            if node_idx  n and x1 >= node_x and x2 = node_coords[node_idx + 1]:\n                 return -1./h, node_coords[node_idx + 1]/h\n            return 0., 0.\n\n        def _integrate_product_of_linears(self, A1, B1, A2, B2, x1, x2):\n            \"\"\"Antiderivative of (A1*x+B1)*(A2*x+B2).\"\"\"\n            C3 = A1 * A2 / 3.0\n            C2 = (A1 * B2 + B1 * A2) / 2.0\n            C1 = B1 * B2\n            val_x2 = C3 * x2**3 + C2 * x2**2 + C1 * x2\n            val_x1 = C3 * x1**3 + C2 * x1**2 + C1 * x1\n            return val_x2 - val_x1\n\n        def _get_coupling_matrix(self, n_s: int, n_m: int) -> np.ndarray:\n            \"\"\"\n            Computes the coupling matrix D by integrating products of slave and master basis functions.\n            \"\"\"\n            nodes_s = np.linspace(0, 1, n_s + 1)\n            nodes_m = np.linspace(0, 1, n_m + 1)\n            \n            all_nodes = np.unique(np.concatenate([nodes_s, nodes_m]))\n            \n            D = np.zeros((n_m + 1, n_s + 1))\n            \n            for j in range(n_m + 1):\n                for i in range(n_s + 1):\n                    integral = 0.0\n                    for k in range(len(all_nodes) - 1):\n                        z1, z2 = all_nodes[k], all_nodes[k+1]\n                        # Add a small epsilon to avoid floating point issues at interval boundaries\n                        if z1 >= z2: continue\n\n                        As, Bs = self._get_basis_fun_params(nodes_s, i, z1, z2)\n                        Am, Bm = self._get_basis_fun_params(nodes_m, j, z1, z2)\n                        \n                        integral += self._integrate_product_of_linears(As, Bs, Am, Bm, z1, z2)\n                    D[j, i] = integral\n            return D\n\n        def calculate_error(self, n_s: int, n_m: int, p_type: str, p_params: dict) -> float:\n            \"\"\"\n            Main driver for calculating the relative L2 error for one test case.\n            \"\"\"\n            # Slave-side computations\n            M_s = self._get_mass_matrix(n_s)\n            b_s = self._get_load_vector(n_s, p_type, p_params)\n            lambda_coeffs = np.linalg.solve(M_s, b_s)\n\n            # Master-side computations\n            M_m = self._get_mass_matrix(n_m)\n            b_m = self._get_load_vector(n_m, p_type, p_params)\n\n            # Check for zero pressure projection on master.\n            # ||p_m||^2 = nu^T M_m nu = b_m^T (M_m^-1)^T M_m M_m^-1 b_m = b_m^T M_m^-1 b_m\n            # Since M_m is SPD, ||p_m||=0 iff b_m=0.\n            if np.linalg.norm(b_m)  1e-15:\n                # If target projection is zero, the nature of the error changes.\n                # Here we assume it won't happen for the given test cases.\n                pass\n\n            # Coupling\n            D = self._get_coupling_matrix(n_s, n_m)\n            f_m = D @ lambda_coeffs\n            \n            # For exact cases, numerical noise might make f_m and b_m slightly different.\n            if np.allclose(f_m, b_m):\n                return 0.0\n\n            # Solve for master-space coefficients\n            nu_coeffs = np.linalg.solve(M_m, b_m)  # for p_m(x)\n            mu_coeffs = np.linalg.solve(M_m, f_m)  # for t_h^m(x)\n            \n            delta_coeffs = mu_coeffs - nu_coeffs\n            \n            # Compute squared L2 norms\n            # norm_err_sq = delta_coeffs.T @ M_m @ delta_coeffs\n            # norm_pm_sq = nu_coeffs.T @ M_m @ nu_coeffs\n            #\n            # Using the more efficient formulation:\n            norm_err_sq = delta_coeffs @ (f_m - b_m)\n            norm_pm_sq = nu_coeffs @ b_m\n\n            if norm_pm_sq  1e-30:\n                return 0.0 if norm_err_sq  1e-30 else np.inf\n\n            return np.sqrt(norm_err_sq / norm_pm_sq)\n\n\n    test_cases = [\n        # (n_s, n_m, p_type, p_params)\n        (8, 2, 'sin', {'k': 2 * np.pi}),\n        (2, 8, 'sin', {'k': 2 * np.pi}),\n        (4, 4, 'sin', {'k': 2 * np.pi}),\n        (2, 8, 'linear', {'C1': 0.5, 'C2': 0.3}),\n    ]\n\n    analyzer = MortarAnalyzer()\n    results = []\n    for n_s, n_m, p_type, p_params in test_cases:\n        r = analyzer.calculate_error(n_s, n_m, p_type, p_params)\n        results.append(r)\n\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "3553682"}]}