{"hands_on_practices": [{"introduction": "本练习将抽象的接触力学理论植根于一个直接的计算任务中。我们从最基本的步骤开始：给定一组已计算出的、变形体上节点的间隙值 $g_i$，我们如何确定哪些节点处于接触状态，以及它们产生多大的接触力？通过实现一个带有激活容差 $\\varepsilon$ 的罚函数接触模型，你将构建起施加单边约束的基本逻辑，这是任何接触仿真的基石。[@problem_id:3553936]", "problem": "考虑一个离散为节点的一维弹性杆，该杆可以接近一个完全刚性的障碍物。设外法线沿杆轴指向障碍物方向定义。对于每个索引为 $i$ 的节点，有符号法向间隙 $g_i$ 代表杆与障碍物之间的法向距离。按照约定，$g_i \\ge 0$ 表示没有接触（分离），而 $g_i < 0$ 表示必须通过接触反力来纠正的相互穿透。单边接触条件是互补条件 $g_i \\ge 0$, $\\lambda_i \\ge 0$, 和 $g_i \\lambda_i = 0$，其中 $\\lambda_i$ 是节点 $i$ 处的法向接触反力（力）。在计算实践中，罚函数正则化引入一个线性罚刚度 $k_p > 0$，使得接触反力与相互穿透成比例地产生，并服从于一个激活集决策。为避免数值振荡，采用一个激活容差 $\\varepsilon \\ge 0$，使得一个节点当且仅当 $g_i \\le -\\varepsilon$ 时处于激活集中。假设接触是无摩擦的，且罚响应是纯法向的。程序的输入数据是节点间隙值 $g_i$（单位为 $\\,\\mathrm{m}\\,$）、罚刚度 $k_p$（单位为 $\\,\\mathrm{N/m}\\,$）和激活容差 $\\varepsilon$（单位为 $\\,\\mathrm{m}\\,$）。要求的输出是：表示每个节点 $i$ 是否激活的离散激活集（作为布尔值列表），以及相应的法向接触力列表（单位为 $\\,\\mathrm{N}\\,$），四舍五入到六位小数。使用符号约定，即正的法向接触力作用于抵抗对障碍物的穿透。\n\n从第一性原理出发，以互补条件和线性罚函数正则化为起点，推导一种方法来计算：\n- 离散激活集 $A = \\{ i \\mid g_i \\le -\\varepsilon \\}$，以及\n- 基于罚模型和激活集决策的每个节点 $i$ 处的法向接触力 $\\lambda_i$。\n\n将此方法实现为一个完整的、可运行的程序，处理以下测试套件。每个测试用例由一个元组 $(\\mathbf{g}, k_p, \\varepsilon)$ 指定，其中 $\\mathbf{g}$ 是节点间隙的列表。所有用例的单位都是一致的：\n- 用例 $1$（正常路径，混合间隙和非零容差）：$\\mathbf{g} = [0.005, -0.002, -0.0005, 0.0]$（单位 $\\,\\mathrm{m}\\,$），$k_p = 10^6$（单位 $\\,\\mathrm{N/m}\\,$），$\\varepsilon = 0.001$（单位 $\\,\\mathrm{m}\\,$）。\n- 用例 $2$（激活阈值处的边界条件）：$\\mathbf{g} = [-0.001, 0.01]$（单位 $\\,\\mathrm{m}\\,$），$k_p = 5 \\times 10^5$（单位 $\\,\\mathrm{N/m}\\,$），$\\varepsilon = 0.001$（单位 $\\,\\mathrm{m}\\,$）。\n- 用例 $3$（零罚刚度的边界情况）：$\\mathbf{g} = [-0.003, -0.2]$（单位 $\\,\\mathrm{m}\\,$），$k_p = 0$（单位 $\\,\\mathrm{N/m}\\,$），$\\varepsilon = 10^{-6}$（单位 $\\,\\mathrm{m}\\,$）。\n- 用例 $4$（具有有限容差的小负间隙和小正间隙）：$\\mathbf{g} = [-10^{-9}, -10^{-4}, 10^{-8}]$（单位 $\\,\\mathrm{m}\\,$），$k_p = 10^3$（单位 $\\,\\mathrm{N/m}\\,$），$\\varepsilon = 10^{-6}$（单位 $\\,\\mathrm{m}\\,$）。\n\n你的程序应该产生单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果。这个外部列表的每个元素对应一个测试用例，并且必须是一个双列表结构 $[\\text{active}, \\text{forces}]$，其中 $\\text{active}$ 是离散激活集的布尔值列表，$\\text{forces}$ 是相应的法向接触力列表（单位为 $\\,\\mathrm{N}\\,$），四舍五入到六位小数。例如，总输出必须具有 $[[\\text{active}_1,\\text{forces}_1],[\\text{active}_2,\\text{forces}_2],\\dots]$ 的形式。", "solution": "所提出的问题是计算接触力学中一个定义明确的练习，提供了一套清晰且一致的定义和数据。它在科学上基于用于施加单边约束的罚函数法原理。因此，该问题被认为是有效的，并按如下方式推导出解决方案。\n\n离散系统的无摩擦单边接触力学的基础是针对每个潜在接触节点 $i$ 的 Karush-Kuhn-Tucker (KKT) 条件集。这些条件在问题中已给出，它们是：\n$1$. 运动学容许性（无穿透）：$g_i \\ge 0$\n$2$. 静力学容许性（无拉力）：$\\lambda_i \\ge 0$\n$3$. 互补性（仅当闭合时才存在力）：$g_i \\lambda_i = 0$\n\n这里，$g_i$ 是节点 $i$ 与刚性障碍物之间的有符号法向间隙，其中 $g_i > 0$ 表示分离。$\\lambda_i$ 是节点 $i$ 处的法向接触力（拉格朗日乘子）。符号约定指定，当 $\\lambda_i$ 作用于抵抗穿透时为正。\n\n精确地执行这些条件在计算上可能要求很高。罚函数法通过放宽严格的无穿透约束 $g_i \\ge 0$ 来提供一种近似。它允许一个小的、非物理的穿透 $g_i < 0$，并引入一个恢复力 $\\lambda_i$，该力的大小与此穿透的量成正比。\n\n问题指定了线性罚函数正则化。在此模型中，接触力 $\\lambda_i$ 通过罚刚度参数 $k_p > 0$ 与间隙 $g_i$ 相关联。对于分离（$g_i > 0$）和在接触点（$g_i = 0$），力必须为零。对于穿透（$g_i < 0$），必须产生一个正的恢复力。穿透的量由 $-g_i$ 给出。因此，建立了一个线性力定律：\n$$\n\\lambda_i = \n\\begin{cases} \n-k_p g_i  &\\text{if } g_i < 0 \\\\\n0  &\\text{if } g_i \\ge 0 \n\\end{cases}\n$$\n此关系确保了 $\\lambda_i \\ge 0$ 的要求，因为 $k_p > 0$，并且在产生力的情况下，$g_i < 0$，使得 $-k_p g_i > 0$。\n\n为了数值稳定性和防止振荡（边界附近节点接触状态的快速切换），问题引入了一个激活容差 $\\varepsilon \\ge 0$。这修改了产生接触力的条件。一个节点 $i$ 被认为在接触节点的“激活集” $A$ 中，当且仅当其穿透超过此容差。激活集的形式化定义为：\n$$\nA = \\{ i \\mid g_i \\le -\\varepsilon \\}\n$$\n一个节点 $i \\in A$ 被认为是主动接触，并将产生一个反作用力。一个节点 $i \\notin A$（即 $g_i > -\\varepsilon$）被认为是非激活的，不产生力。这种非激活条件既包括真实的分离（$g_i \\ge 0$），也包括少量可容忍的穿透（$-\\varepsilon < g_i < 0$）。\n\n将线性罚函数定律与激活集决策相结合，我们推导出每个节点 $i$ 处接触力 $\\lambda_i$ 的最终计算模型：\n\n$1$. **激活集确定**：对于每个节点 $i$，评估条件 $g_i \\le -\\varepsilon$。结果确定该节点是否属于激活集 $A$。此步骤的输出是每个节点的布尔值。\n\n$2$. **接触力计算**：接触力 $\\lambda_i$ 基于激活集状态进行计算：\n$$\n\\lambda_i = \n\\begin{cases} \n-k_p g_i  &\\text{if } i \\in A \\quad (g_i \\le -\\varepsilon) \\\\\n0  &\\text{if } i \\notin A \\quad (g_i > -\\varepsilon)\n\\end{cases}\n$$\n这个公式遵循了问题中列出的所有条件。力的符号是正的，抵抗穿透，因为如果施加了力，$g_i$ 是负的。如果罚刚度 $k_p$ 为零，则无论间隙如何，产生的力 $\\lambda_i$ 也将为零，这在物理上是一致的。\n\n此分步过程应用于每个节点，以获得离散激活集和相应的节点接触力向量。单位是一致的：如果 $k_p$ 的单位是 $\\mathrm{N/m}$，$g_i$ 的单位是 $\\mathrm{m}$，那么 $\\lambda_i$ 会被正确地计算出来，单位是 $\\mathrm{N}$。该过程是确定性的且可直接实现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the active contact set and normal contact forces for a 1D bar\n    approaching a rigid obstacle, based on a penalty method with an activation\n    tolerance.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (list of gaps g, penalty stiffness kp, activation tolerance eps)\n    test_cases = [\n        # Case 1\n        (np.array([0.005, -0.002, -0.0005, 0.0]), 1e6, 0.001),\n        # Case 2\n        (np.array([-0.001, 0.01]), 5e5, 0.001),\n        # Case 3\n        (np.array([-0.003, -0.2]), 0.0, 1e-6),\n        # Case 4\n        (np.array([-1e-9, -1e-4, 1e-8]), 1e3, 1e-6),\n    ]\n\n    results = []\n    for g_vec, kp, eps in test_cases:\n        # Step 1: Determine the discrete active set A.\n        # A node i is active if and only if g_i <= -eps.\n        # This vectorized operation returns a boolean numpy array.\n        active_set = g_vec <= -eps\n\n        # Step 2: Compute the normal contact force lambda_i for each node.\n        # The force is lambda_i = -kp * g_i if the node is active, and 0 otherwise.\n        # np.where is an efficient way to perform this conditional logic on arrays.\n        forces = np.where(active_set, -kp * g_vec, 0.0)\n\n        # Round the forces to six decimal places as required.\n        rounded_forces = np.round(forces, 6)\n\n        # Append the results for the current test case to the main list.\n        # Convert numpy arrays to Python lists for the final output format.\n        results.append([active_set.tolist(), rounded_forces.tolist()])\n\n    # Final print statement must produce a single line in the exact required format.\n    # The str() representation of a list of lists matches the desired output structure.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3553936"}, {"introduction": "在练习了如何使用间隙值之后，我们现在转向计算它们本身的几何挑战。本练习聚焦于接触运动学的核心问题：寻找从动点 $\\mathbf{x}_s$ 到由参数 $(\\xi, \\eta)$ 定义的光滑主面的“最近点投影”。以环面作为一个非平凡的例子，你将实现牛顿-拉弗森迭代来求解基本的正交性条件，从而亲身体验支撑现代接触算法的微分几何原理。[@problem_id:3553921]", "problem": "考虑三维欧几里得空间中的一个光滑双参数曲面，该曲面由一个主半径为 $R$、次半径为 $r$ 的环面定义，使用参数化 $x(\\xi,\\eta)$，其中角度以弧度为单位。该参数化由下式给出\n$$\nx(\\xi,\\eta) = \n\\begin{bmatrix}\n\\left(R + r \\cos \\eta\\right)\\cos \\xi \\\\\n\\left(R + r \\cos \\eta\\right)\\sin \\xi \\\\\nr \\sin \\eta\n\\end{bmatrix},\n$$\n其中 $R$ 和 $r$ 的单位为米，$x(\\xi,\\eta)$ 的单位也为米。设空间中一个固定的“从”点表示为 $x_s \\in \\mathbb{R}^3$，单位也为米。光滑曲面上的最近点投影满足正交性条件，即向量 $x(\\xi,\\eta) - x_s$ 与曲面切线方向 $x_{,\\xi}(\\xi,\\eta)$ 和 $x_{,\\eta}(\\xi,\\eta)$ 正交，其中 $x_{,\\xi}$ 和 $x_{,\\eta}$ 分别表示对 $\\xi$ 和 $\\eta$ 的偏导数。\n\n定义正交残差向量 $f(\\xi,\\eta)$，其分量为\n$$\nf_\\xi(\\xi,\\eta) = \\left(x(\\xi,\\eta)-x_s\\right)\\cdot x_{,\\xi}(\\xi,\\eta), \\quad\nf_\\eta(\\xi,\\eta) = \\left(x(\\xi,\\eta)-x_s\\right)\\cdot x_{,\\eta}(\\xi,\\eta),\n$$\n其中 $\\cdot$ 表示欧几里得内积。从当前迭代点 $(\\xi,\\eta)$ 出发，求解 $f(\\xi,\\eta) = 0$ 的单次牛顿迭代步通过构建 $f$ 的雅可比矩阵 $J(\\xi,\\eta)$ 并求解线性系统得到\n$$\nJ(\\xi,\\eta)\\,\\Delta =\n- f(\\xi,\\eta),\n$$\n以将参数更新为 $(\\xi_{\\text{new}},\\eta_{\\text{new}}) = (\\xi+\\Delta_\\xi,\\eta+\\Delta_\\eta)$。在执行完该单次牛顿迭代步后，计算：\n- 接触法向量 $n(\\xi_{\\text{new}},\\eta_{\\text{new}})$，作为沿 $x_{,\\xi}(\\xi_{\\text{new}},\\eta_{\\text{new}}) \\times x_{,\\eta}(\\xi_{\\text{new}},\\eta_{\\text{new}})$ 方向的单位向量，其中 $\\times$ 表示叉积，\n- 法向间隙函数 $g_n = n(\\xi_{\\text{new}},\\eta_{\\text{new}})\\cdot\\left(x_s - x(\\xi_{\\text{new}},\\eta_{\\text{new}})\\right)$，单位为米，\n- 更新后的正交残差 $f_\\xi(\\xi_{\\text{new}},\\eta_{\\text{new}})$ 和 $f_\\eta(\\xi_{\\text{new}},\\eta_{\\text{new}})$。\n\n您的程序必须使用接触运动学的第一性原理来实现上述过程：最近点投影的正交性条件，使用由 $x(\\xi,\\eta)$ 关于 $\\xi$ 和 $\\eta$ 的一阶和二阶偏导数构成的精确雅可比矩阵的牛顿线性化，以及作为分离向量 $x_s - x$ 在单位法向量上投影的间隙函数。使用以下参数值测试集，其中所有 $R$ 和 $r$ 的单位为米，$x_s$ 的单位为米，角度单位为弧度：\n\n- 测试用例 1：$R = 2.0$，$r = 0.5$，$\\xi_0 = 0.0$，$\\eta_0 = 0.0$，$x_s = \\begin{bmatrix} 2.6 \\\\ 0.05 \\\\ 0.0 \\end{bmatrix}$。\n- 测试用例 2：$R = 2.0$，$r = 0.5$，$\\xi_0 = 0.0$，$\\eta_0 = \\pi$，$x_s = \\begin{bmatrix} 1.8 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}$。\n- 测试用例 3：$R = 2.0$，$r = 0.5$，$\\xi_0 = 0.3$，$\\eta_0 = 1.1$，$x_s = \\begin{bmatrix} 2.0 \\\\ 0.0 \\\\ 0.5 \\end{bmatrix}$。\n\n对于每个测试用例，从 $(\\xi_0,\\eta_0)$ 开始执行恰好一次牛顿迭代，然后计算并返回包含五个值的元组 $[\\xi_{\\text{new}},\\eta_{\\text{new}},g_n,f_\\xi(\\xi_{\\text{new}},\\eta_{\\text{new}}),f_\\eta(\\xi_{\\text{new}},\\eta_{\\text{new}})]$。将角度 $\\xi_{\\text{new}}$ 和 $\\eta_{\\text{new}}$ 以弧度表示为十进制数，间隙 $g_n$ 以米表示为十进制数，残差表示为十进制数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个包含五个值的逗号分隔列表，没有空格，每个数字四舍五入到 $8$ 位小数。例如，总的输出格式为\n$$\n[\\,[\\xi_1,\\eta_1,g_{n,1},f_{\\xi,1},f_{\\eta,1}],\\,[\\xi_2,\\eta_2,g_{n,2},f_{\\xi,2},f_{\\eta,2}],\\,[\\xi_3,\\eta_3,g_{n,3},f_{\\xi,3},f_{\\eta,3}]\\,],\n$$\n其中的确切数值由您的计算确定。\n\n注意：使用通过对正交性条件求导得出的 $f(\\xi,\\eta)$ 的精确雅可比矩阵，这需要环面参数化的二阶偏导数 $x_{,\\xi\\xi}(\\xi,\\eta)$、$x_{,\\xi\\eta}(\\xi,\\eta)$ 和 $x_{,\\eta\\eta}(\\xi,\\eta)$。确保所有运算都统一以弧度和米为单位进行，并以米为单位报告 $g_n$。如果某个测试用例的雅可比矩阵 $J(\\xi,\\eta)$ 是奇异的，则使用伪逆在线性最小二乘意义下求解牛顿系统，以获得一个良定义的更新。", "solution": "该问题定义明确，有科学依据，并包含了进行求解所需的所有信息。这是数值方法在计算接触力学问题中的一个标准应用。\n\n问题的核心是在环面上找到离空间中给定点 $x_s$ 最近的点。曲面上的最近点 $x(\\xi, \\eta)$ 的特征是正交性条件：连接从点和曲面上点的向量 $d = x(\\xi, \\eta) - x_s$ 必须与该点处曲面的切向量正交。这些切向量是参数化相对于曲面参数 $x_{,\\xi}$ 和 $x_{,\\eta}$ 的偏导数。\n\n问题在于求解关于参数 $(\\xi, \\eta)$ 的非线性方程组：\n$$\nf(\\xi, \\eta) = \\begin{bmatrix} f_\\xi(\\xi,\\eta) \\\\ f_\\eta(\\xi,\\eta) \\end{bmatrix} = \\begin{bmatrix} (x(\\xi,\\eta)-x_s)\\cdot x_{,\\xi}(\\xi,\\eta) \\\\ (x(\\xi,\\eta)-x_s)\\cdot x_{,\\eta}(\\xi,\\eta) \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\n$$\n我们被要求执行一步牛顿-拉夫逊法来更新初始猜测 $(\\xi_0, \\eta_0)$。更新步骤通过求解以下线性系统给出：\n$$\nJ(\\xi_k, \\eta_k) \\Delta_k = -f(\\xi_k, \\eta_k)\n$$\n其中 $\\Delta_k = [\\Delta_\\xi, \\Delta_\\eta]^T$ 是更新向量，$J$ 是 $f$ 的雅可比矩阵。然后参数更新为 $(\\xi_{k+1}, \\eta_{k+1}) = (\\xi_k, \\eta_k) + (\\Delta_\\xi, \\Delta_\\eta)$。\n\n首先，我们推导必要的解析表达式。\n环面参数化为：\n$$\nx(\\xi,\\eta) = \n\\begin{bmatrix}\n(R + r \\cos \\eta)\\cos \\xi \\\\\n(R + r \\cos \\eta)\\sin \\xi \\\\\nr \\sin \\eta\n\\end{bmatrix}\n$$\n一阶偏导数（切向量）为：\n$$\nx_{,\\xi}(\\xi,\\eta) = \\frac{\\partial x}{\\partial \\xi} = \\begin{bmatrix} -(R + r \\cos \\eta)\\sin \\xi \\\\ (R + r \\cos \\eta)\\cos \\xi \\\\ 0 \\end{bmatrix}\n$$\n$$\nx_{,\\eta}(\\xi,\\eta) = \\frac{\\partial x}{\\partial \\eta} = \\begin{bmatrix} -r \\sin \\eta \\cos \\xi \\\\ -r \\sin \\eta \\sin \\xi \\\\ r \\cos \\eta \\end{bmatrix}\n$$\n对于残差 $f$ 的雅可比矩阵，我们需要 $x$ 的二阶偏导数：\n$$\nx_{,\\xi\\xi} = \\frac{\\partial^2 x}{\\partial \\xi^2} = \\begin{bmatrix} -(R + r \\cos \\eta)\\cos \\xi \\\\ -(R + r \\cos \\eta)\\sin \\xi \\\\ 0 \\end{bmatrix}\n$$\n$$\nx_{,\\eta\\eta} = \\frac{\\partial^2 x}{\\partial \\eta^2} = \\begin{bmatrix} -r \\cos \\eta \\cos \\xi \\\\ -r \\cos \\eta \\sin \\xi \\\\ -r \\sin \\eta \\end{bmatrix}\n$$\n$$\nx_{,\\xi\\eta} = \\frac{\\partial^2 x}{\\partial \\xi \\partial \\eta} = \\begin{bmatrix} r \\sin \\eta \\sin \\xi \\\\ -r \\sin \\eta \\cos \\xi \\\\ 0 \\end{bmatrix}\n$$\n雅可比矩阵的分量 $J_{ij} = \\partial f_i / \\partial_j$ 使用点积的求导乘法法则推导得出：\n$$\nJ_{\\xi\\xi} = \\frac{\\partial f_\\xi}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left( (x-x_s) \\cdot x_{,\\xi} \\right) = x_{,\\xi} \\cdot x_{,\\xi} + (x-x_s) \\cdot x_{,\\xi\\xi} = \\|x_{,\\xi}\\|^2 + (x-x_s) \\cdot x_{,\\xi\\xi}\n$$\n$$\nJ_{\\xi\\eta} = \\frac{\\partial f_\\xi}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left( (x-x_s) \\cdot x_{,\\xi} \\right) = x_{,\\eta} \\cdot x_{,\\xi} + (x-x_s) \\cdot x_{,\\xi\\eta}\n$$\n$$\nJ_{\\eta\\xi} = \\frac{\\partial f_\\eta}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left( (x-x_s) \\cdot x_{,\\eta} \\right) = x_{,\\xi} \\cdot x_{,\\eta} + (x-x_s) \\cdot x_{,\\eta\\xi}\n$$\n$$\nJ_{\\eta\\eta} = \\frac{\\partial f_\\eta}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left( (x-x_s) \\cdot x_{,\\eta} \\right) = x_{,\\eta} \\cdot x_{,\\eta} + (x-x_s) \\cdot x_{,\\eta\\eta} = \\|x_{,\\eta}\\|^2 + (x-x_s) \\cdot x_{,\\eta\\eta}\n$$\n对于给定的环面正交参数化，有 $x_{,\\xi} \\cdot x_{,\\eta} = 0$。由于 $x_{,\\xi\\eta}=x_{,\\eta\\xi}$，雅可比矩阵是对称的，因此 $J_{\\xi\\eta} = J_{\\eta\\xi}$。范数的平方为 $\\|x_{,\\xi}\\|^2 = (R+r\\cos\\eta)^2$ 和 $\\|x_{,\\eta}\\|^2 = r^2$。\n\n在执行一步牛顿法找到 $(\\xi_{\\text{new}},\\eta_{\\text{new}})$ 后，我们计算以下量：\n1. 曲面法向量 $n$。这是通过将切向量的叉积归一化得到的：\n$$\nn(\\xi,\\eta) = \\frac{x_{,\\xi} \\times x_{,\\eta}}{\\|x_{,\\xi} \\times x_{,\\eta}\\|}\n$$\n叉积为 $x_{,\\xi} \\times x_{,\\eta} = r(R+r\\cos\\eta)[\\cos\\xi\\cos\\eta, \\sin\\xi\\cos\\eta, \\sin\\eta]^T$。\n其范数为 $\\|x_{,\\xi} \\times x_{,\\eta}\\| = \\|x_{,\\xi}\\| \\|x_{,\\eta}\\| = r(R+r\\cos\\eta)$。\n因此，单位法向量为 $n(\\xi,\\eta) = [\\cos\\xi\\cos\\eta, \\sin\\xi\\cos\\eta, \\sin\\eta]^T$。\n2. 法向间隙函数 $g_n$，定义为从曲面点到从点的向量在法向量上的投影：\n$$\ng_n = n(\\xi_{\\text{new}},\\eta_{\\text{new}}) \\cdot (x_s - x(\\xi_{\\text{new}},\\eta_{\\text{new}}))\n$$\n3. 更新后的正交残差 $f_\\xi(\\xi_{\\text{new}},\\eta_{\\text{new}})$ 和 $f_\\eta(\\xi_{\\text{new}},\\eta_{\\text{new}})$，它们在新的参数值处进行评估。\n\n每个测试用例的算法如下：\n1. 给定 $R, r, \\xi_0, \\eta_0, x_s$。令 $(\\xi_k, \\eta_k) = (\\xi_0, \\eta_0)$。\n2. 在 $(\\xi_k, \\eta_k)$ 处计算 $x$, $x_{,\\xi}$, $x_{,\\eta}$, $x_{,\\xi\\xi}$, $x_{,\\xi\\eta}$, $x_{,\\eta\\eta}$。\n3. 计算残差向量 $f = [f_\\xi, f_\\eta]^T$。\n4. 计算雅可比矩阵 $J$。\n5. 使用伪逆求解线性系统 $J\\Delta = -f$ 以得到 $\\Delta = [\\Delta_\\xi, \\Delta_\\eta]^T$，以处理潜在的奇异性。\n6. 更新参数：$(\\xi_{\\text{new}}, \\eta_{\\text{new}}) = (\\xi_k, \\eta_k) + (\\Delta_\\xi, \\Delta_\\eta)$。\n7. 在 $(\\xi_{\\text{new}}, \\eta_{\\text{new}})$ 处计算 $x, x_{,\\xi}, x_{,\\eta}$ 和 $n$。\n8. 计算最终量：$g_n$, $f_{\\xi,\\text{new}}$ 和 $f_{\\eta,\\text{new}}$。\n9. 收集并格式化结果 $[\\xi_{\\text{new}},\\eta_{\\text{new}},g_n,f_{\\xi,\\text{new}},f_{\\eta,\\text{new}}]$。\n此过程在提供的 Python 代码中实现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        {'R': 2.0, 'r': 0.5, 'xi0': 0.0, 'eta0': 0.0, 'xs': np.array([2.6, 0.05, 0.0])},\n        {'R': 2.0, 'r': 0.5, 'xi0': 0.0, 'eta0': np.pi, 'xs': np.array([1.8, 0.0, 0.0])},\n        {'R': 2.0, 'r': 0.5, 'xi0': 0.3, 'eta0': 1.1, 'xs': np.array([2.0, 0.0, 0.5])},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = process_case(case['R'], case['r'], case['xi0'], case['eta0'], case['xs'])\n        all_results.append(result)\n    \n    # Format the output string as per the problem specification.\n    list_of_strings = []\n    for result_tuple in all_results:\n        # Round each value to 8 decimal places and format.\n        formatted_vals = [f\"{val:.8f}\" for val in result_tuple]\n        s = f\"[{','.join(formatted_vals)}]\"\n        list_of_strings.append(s)\n    \n    final_output = f\"[{','.join(list_of_strings)}]\"\n    print(final_output)\n\ndef process_case(R, r, xi_k, eta_k, xs):\n    \"\"\"\n    Performs one Newton step and calculates the required output values for a single test case.\n    \"\"\"\n    \n    # --- Step 1: Evaluate geometric quantities at the current iterate (xi_k, eta_k) ---\n    \n    # Helper trigonometric values\n    cos_xi = np.cos(xi_k)\n    sin_xi = np.sin(xi_k)\n    cos_eta = np.cos(eta_k)\n    sin_eta = np.sin(eta_k)\n    \n    # Parametrization x(xi, eta)\n    x = np.array([\n        (R + r * cos_eta) * cos_xi,\n        (R + r * cos_eta) * sin_xi,\n        r * sin_eta\n    ])\n    \n    # First partial derivatives\n    x_xi = np.array([\n        -(R + r * cos_eta) * sin_xi,\n        (R + r * cos_eta) * cos_xi,\n        0.0\n    ])\n    \n    x_eta = np.array([\n        -r * sin_eta * cos_xi,\n        -r * sin_eta * sin_xi,\n        r * cos_eta\n    ])\n    \n    # Second partial derivatives\n    x_xixi = np.array([\n        -(R + r * cos_eta) * cos_xi,\n        -(R + r * cos_eta) * sin_xi,\n        0.0\n    ])\n    \n    x_etaeta = np.array([\n        -r * cos_eta * cos_xi,\n        -r * cos_eta * sin_xi,\n        -r * sin_eta\n    ])\n    \n    x_xieta = np.array([\n        r * sin_eta * sin_xi,\n        -r * sin_eta * cos_xi,\n        0.0\n    ])\n\n    # --- Step 2: Form the residual vector f and the Jacobian matrix J ---\n    \n    # Residual vector f(xi, eta)\n    x_minus_xs = x - xs\n    f_xi = np.dot(x_minus_xs, x_xi)\n    f_eta = np.dot(x_minus_xs, x_eta)\n    f = np.array([f_xi, f_eta])\n    \n    # Jacobian matrix J(xi, eta)\n    J_xixi = np.dot(x_xi, x_xi) + np.dot(x_minus_xs, x_xixi)\n    J_xieta = np.dot(x_xi, x_eta) + np.dot(x_minus_xs, x_xieta)\n    J_etaeta = np.dot(x_eta, x_eta) + np.dot(x_minus_xs, x_etaeta)\n    \n    J = np.array([\n        [J_xixi, J_xieta],\n        [J_xieta, J_etaeta] # J is symmetric\n    ])\n    \n    # --- Step 3: Solve for the update delta and find new parameters ---\n    \n    # Solve J * delta = -f using pseudoinverse for robustness\n    delta = np.linalg.pinv(J) @ -f\n    \n    xi_new = xi_k + delta[0]\n    eta_new = eta_k + delta[1]\n    \n    # --- Step 4: Calculate final results at the new point (xi_new, eta_new) ---\n    \n    # Helper trigonometric values at the new point\n    cos_xi_new = np.cos(xi_new)\n    sin_xi_new = np.sin(xi_new)\n    cos_eta_new = np.cos(eta_new)\n    sin_eta_new = np.sin(eta_new)\n    \n    # Parametrization x at new point\n    x_new = np.array([\n        (R + r * cos_eta_new) * cos_xi_new,\n        (R + r * cos_eta_new) * sin_xi_new,\n        r * sin_eta_new\n    ])\n    \n    # First partial derivatives at new point\n    x_xi_new = np.array([\n        -(R + r * cos_eta_new) * sin_xi_new,\n        (R + r * cos_eta_new) * cos_xi_new,\n        0.0\n    ])\n    \n    x_eta_new = np.array([\n        -r * sin_eta_new * cos_xi_new,\n        -r * sin_eta_new * sin_xi_new,\n        r * cos_eta_new\n    ])\n    \n    # Contact normal vector n\n    normal_unscaled = np.cross(x_xi_new, x_eta_new)\n    norm_val = np.linalg.norm(normal_unscaled)\n    if norm_val > 1e-12: # Avoid division by zero\n        n_new = normal_unscaled / norm_val\n    else: # Should not happen for a regular torus\n        n_new = np.array([0.0, 0.0, 0.0])\n\n    # Normal gap gn\n    gn = np.dot(n_new, xs - x_new)\n    \n    # Updated residuals f_new\n    x_minus_xs_new = x_new - xs\n    f_xi_new = np.dot(x_minus_xs_new, x_xi_new)\n    f_eta_new = np.dot(x_minus_xs_new, x_eta_new)\n    \n    return xi_new, eta_new, gn, f_xi_new, f_eta_new\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3553921"}, {"introduction": "真实的接触仿真通常涉及大的相对运动，其中一个点可能会滑过多个表面单元。这个高级实践旨在填补从单表面投影到在分段双线性网格上实现稳健大滑移算法之间的鸿沟。你将设计并实现追踪最近点投影的逻辑，包括检测其何时穿过单元的自然坐标域 $[-1,1] \\times [-1,1]$，将其坐标 $(\\xi,\\eta)$ 重新参数化到相邻单元上，以及处理边界约束，这些都是开发工业级有限元代码的关键技能。[@problem_id:3553969]", "problem": "给定一个嵌入在三维欧几里得空间中的分片双线性四边形曲面。该曲面由有限个单元集合描述，每个单元都通过自然坐标 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ 进行参数化，并使用双线性等参映射将 $(\\xi,\\eta)$ 映射到物理坐标 $\\mathbf{X}(\\xi,\\eta)\\in\\mathbb{R}^3$。对于每个单元，四个节点按照标准的双线性四边形约定排序：分别为 $(\\xi,\\eta)=(-1,-1)$, $(-1,1)$, $(1,1)$, $(1,-1)$。单元映射由双线性形函数定义\n$$\nN_1(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1+\\eta),\\quad\nN_3(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1-\\eta),\n$$\n因此\n$$\n\\mathbf{X}(\\xi,\\eta)=\\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,\\mathbf{X}_i,\n$$\n其中 $\\mathbf{X}_i\\in\\mathbb{R}^3$ 是单元的节点坐标，单位为米。单元切向量为\n$$\n\\mathbf{a}_\\xi(\\xi,\\eta)=\\frac{\\partial \\mathbf{X}}{\\partial \\xi},\\qquad\n\\mathbf{a}_\\eta(\\xi,\\eta)=\\frac{\\partial \\mathbf{X}}{\\partial \\eta}.\n$$\n\n从第一性原理出发，从点 $\\mathbf{x}_s\\in\\mathbb{R}^3$ 到曲面上的最近点投影最小化了平方距离\n$$\n\\phi(\\xi,\\eta)=\\tfrac{1}{2}\\,\\|\\mathbf{X}(\\xi,\\eta)-\\mathbf{x}_s\\|_2^2,\n$$\n对于一个无约束的内部解，该解必须满足正交条件\n$$\n\\mathbf{a}_\\xi(\\xi,\\eta)\\cdot\\left(\\mathbf{X}(\\xi,\\eta)-\\mathbf{x}_s\\right)=0,\\qquad\n\\mathbf{a}_\\eta(\\xi,\\eta)\\cdot\\left(\\mathbf{X}(\\xi,\\eta)-\\mathbf{x}_s\\right)=0.\n$$\n当最小化点位于单元边界上时，问题简化为在相应边上的约束搜索；如果最小化点位于顶点上，则简化为角点之间的离散比较。\n\n您的任务是设计并实现一个鲁棒的算法，该算法能够：\n- 通过一种基于最小化 $\\phi(\\xi,\\eta)$ 的、有原则的迭代方法求解无约束问题，仅使用切线信息 $(\\mathbf{a}_\\xi,\\mathbf{a}_\\eta)$ 作为符合上下文的基本基底。\n- 检测迭代点何时超出单元域 $[-1,1]\\times[-1,1]$，并且如果穿过的边存在相邻单元，则根据共享边的方向一致性将 $(\\xi,\\eta)$ 重新参数化到相邻单元的自然坐标上，然后在相邻单元上继续迭代过程。这实现了跨单元边界的大滑移。\n- 如果穿过的边没有相邻单元，则在当前单元的边界边上（必要时包括角点）执行约束最近点投影，在这些约束候选点中选择平方距离的全局最小化子。\n- 计算法向间隙函数\n$$\ng_n=\\mathbf{n}(\\xi,\\eta)\\cdot\\left(\\mathbf{x}_s-\\mathbf{X}(\\xi,\\eta)\\right),\n$$\n其中单位法向量为\n$$\n\\mathbf{n}(\\xi,\\eta)=\\frac{\\mathbf{a}_\\xi(\\xi,\\eta)\\times \\mathbf{a}_\\eta(\\xi,\\eta)}{\\left\\|\\mathbf{a}_\\xi(\\xi,\\eta)\\times \\mathbf{a}_\\eta(\\xi,\\eta)\\right\\|_2},\n$$\n单位为米，四舍五入到$6$位小数。\n\n您必须实现该算法以鲁棒地处理边和角点情况。边的重新参数化必须遵循方向。边索引定义如下：边$0$为$\\xi=-1$，$\\eta$从$-1$增加到$1$；边$1$为$\\eta=1$，$\\xi$从$-1$增加到$1$；边$2$为$\\xi=1$，$\\eta$从$-1$增加到$1$；边$3$为$\\eta=-1$，$\\xi$从$-1$增加到$1$。在共享边上，相邻单元提供一个在其对应边上满足$\\xi'=\\pm 1$或$\\eta'=\\pm 1$的映射$(\\xi',\\eta')$，并且沿该边的切向参数必须用一个符号$s\\in\\{-1,1\\}$进行重新参数化，该符号编码了方向的一致性。\n\n使用以下包含三个双线性四边形单元的网格（单位为米），包括邻接关系和边方向，来构建您的测试套件。对于每个单元，节点均按标准顺序$(-1,-1)$, $(-1,1)$, $(1,1)$, $(1,-1)$给出：\n- 单元 $0$ 节点：\n$$\n\\mathbf{X}_1=(0,0,0),\\quad\n\\mathbf{X}_2=(0,1,0),\\quad\n\\mathbf{X}_3=(1,1,0.1),\\quad\n\\mathbf{X}_4=(1,0,0.1).\n$$\n邻接关系：边 $2$ 与单元 $1$ 的边 $0$ 相邻，方向 $s=+1$。所有其他边没有相邻单元。\n- 单元 $1$ 节点：\n$$\n\\mathbf{X}_1=(1,0,0.1),\\quad\n\\mathbf{X}_2=(1,1,0.1),\\quad\n\\mathbf{X}_3=(2,1,0.2),\\quad\n\\mathbf{X}_4=(2,0,0.2).\n$$\n邻接关系：边 $0$ 与单元 $0$ 的边 $2$ 相邻，方向 $s=+1$；边 $2$ 与单元 $2$ 的边 $0$ 相邻，方向 $s=+1$。所有其他边没有相邻单元。\n- 单元 $2$ 节点：\n$$\n\\mathbf{X}_1=(2,0,0.2),\\quad\n\\mathbf{X}_2=(2,1,0.2),\\quad\n\\mathbf{X}_3=(3,1,0.2),\\quad\n\\mathbf{X}_4=(3,0,0.2).\n$$\n邻接关系：边 $0$ 与单元 $1$ 的边 $2$ 相邻，方向 $s=+1$。所有其他边没有相邻单元。\n\n实现您的程序以评估以下五个测试用例的法向间隙函数 $g_n$，每个测试用例以从点 $\\mathbf{x}_s$（单位为米）和初始单元索引的形式给出：\n- 测试 $1$：$\\mathbf{x}_s=(0.3,0.4,0.05)$，起始单元 $0$。\n- 测试 $2$：$\\mathbf{x}_s=(1.4,0.5,0.05)$，起始单元 $0$。\n- 测试 $3$：$\\mathbf{x}_s=(0.6,1.2,0.05)$，起始单元 $0$。\n- 测试 $4$：$\\mathbf{x}_s=(3.7,-0.6,1.0)$，起始单元 $1$。\n- 测试 $5$：$\\mathbf{x}_s=(2.6,0.2,0.3)$，起始单元 $0$。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个条目是法向间隙 $g_n$（单位为米），按上述测试顺序四舍五入到$6$位小数，例如 $[g_1,g_2,g_3,g_4,g_5]$。", "solution": "用户提供了一个计算接触力学中的问题，涉及将一个点投影到分片双线性曲面上的最近点。解决方案需要一个鲁棒的迭代算法，处理单元间的滑移（大滑移），以及到单元边界和角点的约束投影。\n\n### 步骤1：问题验证\n\n#### 提取已知条件\n- **曲面表示**：$\\mathbb{R}^3$中的分片双线性四边形曲面。\n- **单元参数化**：每个单元从自然坐标 $(\\xi,\\eta) \\in [-1,1]\\times[-1,1]$ 映射到物理坐标 $\\mathbf{X}(\\xi,\\eta) \\in \\mathbb{R}^3$。\n- **形函数**：\n  $$ N_1(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad N_2(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1+\\eta) $$\n  $$ N_3(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad N_4(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1-\\eta) $$\n- **等参映射**：$\\mathbf{X}(\\xi,\\eta)=\\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,\\mathbf{X}_i$，其中 $\\mathbf{X}_i$ 是节点坐标。\n- **节点顺序**：对于每个单元，节点 $i=1,2,3,4$ 分别对应 $(\\xi,\\eta) = (-1,-1), (-1,1), (1,1), (1,-1)$。\n- **切向量**：$\\mathbf{a}_\\xi(\\xi,\\eta)=\\frac{\\partial \\mathbf{X}}{\\partial \\xi}$ 和 $\\mathbf{a}_\\eta(\\xi,\\eta)=\\frac{\\partial \\mathbf{X}}{\\partial \\eta}$。\n- **目标函数**：对于给定的从点 $\\mathbf{x}_s$，最小化平方距离 $\\phi(\\xi,\\eta)=\\tfrac{1}{2}\\,\\|\\mathbf{X}(\\xi,\\eta)-\\mathbf{x}_s\\|_2^2$。\n- **正交条件**：对于无约束的内部最小值，$\\phi$ 的梯度必须为零：\n  $$ \\frac{\\partial\\phi}{\\partial\\xi} = \\mathbf{a}_\\xi\\cdot\\left(\\mathbf{X}-\\mathbf{x}_s\\right)=0 $$\n  $$ \\frac{\\partial\\phi}{\\partial\\eta} = \\mathbf{a}_\\eta\\cdot\\left(\\mathbf{X}-\\mathbf{x}_s\\right)=0 $$\n- **输出量**：法向间隙函数 $g_n=\\mathbf{n}(\\xi,\\eta)\\cdot\\left(\\mathbf{x}_s-\\mathbf{X}(\\xi,\\eta)\\right)$，其中 $\\mathbf{n}$ 是单位法向量：\n  $$ \\mathbf{n}(\\xi,\\eta)=\\frac{\\mathbf{a}_\\xi(\\xi,\\eta)\\times \\mathbf{a}_\\eta(\\xi,\\eta)}{\\left\\|\\mathbf{a}_\\xi(\\xi,\\eta)\\times \\mathbf{a}_\\eta(\\xi,\\eta)\\right\\|_2} $$\n- **边索引和参数化**：\n  - 边 $0$：$\\xi=-1$，$\\eta$ 从 $-1$ 增加到 $1$。\n  - 边 $1$：$\\eta=1$，$\\xi$ 从 $-1$ 增加到 $1$。\n  - 边 $2$：$\\xi=1$，$\\eta$ 从 $-1$ 增加到 $1$。\n  - 边 $3$：$\\eta=-1$，$\\xi$ 从 $-1$ 增加到 $1$。\n- **网格数据（单位为米）**：\n  - 单元 0 节点：$\\mathbf{X}_1=(0,0,0), \\mathbf{X}_2=(0,1,0), \\mathbf{X}_3=(1,1,0.1), \\mathbf{X}_4=(1,0,0.1)$。\n    邻接关系：边 2 与单元 1 的边 0 相邻 ($s=+1$)。\n  - 单元 1 节点：$\\mathbf{X}_1=(1,0,0.1), \\mathbf{X}_2=(1,1,0.1), \\mathbf{X}_3=(2,1,0.2), \\mathbf{X}_4=(2,0,0.2)$。\n    邻接关系：边 0 与单元 0 的边 2 相邻 ($s=+1$)。边 2 与单元 2 的边 0 相邻 ($s=+1$)。\n  - 单元 2 节点：$\\mathbf{X}_1=(2,0,0.2), \\mathbf{X}_2=(2,1,0.2), \\mathbf{X}_3=(3,1,0.2), \\mathbf{X}_4=(3,0,0.2)$。\n    邻接关系：边 0 与单元 1 的边 2 相邻 ($s=+1$)。\n- **测试用例**：\n  1. $\\mathbf{x}_s=(0.3,0.4,0.05)$，起始单元 $0$。\n  2. $\\mathbf{x}_s=(1.4,0.5,0.05)$，起始单元 $0$。\n  3. $\\mathbf{x}_s=(0.6,1.2,0.05)$，起始单元 $0$。\n  4. $\\mathbf{x}_s=(3.7,-0.6,1.0)$，起始单元 $1$。\n  5. $\\mathbf{x}_s=(2.6,0.2,0.3)$，起始单元 $0$。\n\n#### 使用已知条件进行验证\n根据验证标准评估该问题。\n\n- **科学基础**：该问题是计算接触力学中的一个经典基础任务。使用等参单元、形函数、切向量以及最小化距离函数的公式是有限元法 (FEM) 领域的标准实践。使用类牛顿-拉夫逊方法求解得到的非线性方程组也是一种标准的、鲁棒的技术。\n- **适定性**：该问题是适定的。它寻求一个连续函数在一个紧凑域（单元域的集合）上的最小值。解保证存在。无约束内部搜索、跨单元滑移机制和约束边界搜索的组合提供了一个找到该最小值的全面策略。\n- **客观性**：所有定义和数据都以精确、明确的数学和数值术语给出。\n- **缺陷清单**：\n  1.  **科学/事实不准确**：无。原理是正确的。\n  2.  **无法形式化/不相关**：无。该问题是计算固体力学的核心。\n  3.  **设置不完整/矛盾**：问题是自洽的。虽然指定的边 2 和边 3 的参数化偏离了标准的逆时针节点遍历，但它被明确定义，并构成了问题规范的一个有效（尽管不常规）部分。这不是矛盾，而是需要遵循的特定指令。\n  4.  **不切实际/不可行**：数据和所需计算在物理上和计算上都是现实的。\n  5.  **病态的/结构不良**：无。问题结构引导向一个唯一且有意义的解。\n  6.  **伪深刻/琐碎**：无。实现需要仔细处理数值方法、几何学和逻辑分支，代表了一个非凡的算法挑战。\n  7.  **无法进行科学验证**：无。结果是确定性的，可以独立验证。\n\n#### 结论\n问题是**有效的**。\n\n### 解法推导\n问题的核心是在某个曲面单元上找到自然坐标 $(\\xi, \\eta)$，以最小化到从点 $\\mathbf{x}_s$ 的平方距离。这是通过求解非线性正交方程组 $\\mathbf{r}(\\xi, \\eta) = \\mathbf{0}$ 来实现的，其中 $\\mathbf{r}$ 是残差向量：\n$$ \\mathbf{r}(\\xi, \\eta) = \\begin{pmatrix} r_\\xi \\\\ r_\\eta \\end{pmatrix} = \\begin{pmatrix} \\mathbf{a}_\\xi(\\xi, \\eta) \\cdot (\\mathbf{X}(\\xi, \\eta) - \\mathbf{x}_s) \\\\ \\mathbf{a}_\\eta(\\xi, \\eta) \\cdot (\\mathbf{X}(\\xi, \\eta) - \\mathbf{x}_s) \\end{pmatrix} $$\n\n采用迭代的牛顿-拉夫逊法来求解这个系统。更新步骤由下式给出：\n$$ \\mathbf{H}(\\xi_k, \\eta_k) \\begin{pmatrix} \\Delta\\xi \\\\ \\Delta\\eta \\end{pmatrix} = -\\mathbf{r}(\\xi_k, \\eta_k) $$\n$$ \\xi_{k+1} = \\xi_k + \\Delta\\xi, \\quad \\eta_{k+1} = \\eta_k + \\Delta\\eta $$\n其中 $\\mathbf{H}$ 是 $\\mathbf{r}$ 的雅可比矩阵，也是目标函数 $\\phi$ 的海森矩阵。海森矩阵的分量是 $H_{ij} = \\frac{\\partial^2\\phi}{\\partial s_i \\partial s_j}$，对于 $\\mathbf{s}=(\\xi, \\eta)$。\n\n映射 $\\mathbf{X}(\\xi, \\eta)$ 的双线性性质可以表示为：\n$$ \\mathbf{X}(\\xi,\\eta) = \\mathbf{c}_0 + \\mathbf{c}_\\xi \\xi + \\mathbf{c}_\\eta \\eta + \\mathbf{c}_{\\xi\\eta} \\xi \\eta $$\n其中常数向量 $\\mathbf{c}_0, \\mathbf{c}_\\xi, \\mathbf{c}_\\eta, \\mathbf{c}_{\\xi\\eta}$ 是节点坐标 $\\mathbf{X}_i$ 的线性组合。具体来说，$\\mathbf{c}_{\\xi\\eta} = \\frac{1}{4}(\\mathbf{X}_1 - \\mathbf{X}_2 + \\mathbf{X}_3 - \\mathbf{X}_4)$。\n切向量是：\n$$ \\mathbf{a}_\\xi = \\frac{\\partial\\mathbf{X}}{\\partial\\xi} = \\mathbf{c}_\\xi + \\mathbf{c}_{\\xi\\eta} \\eta $$\n$$ \\mathbf{a}_\\eta = \\frac{\\partial\\mathbf{X}}{\\partial\\eta} = \\mathbf{c}_\\eta + \\mathbf{c}_{\\xi\\eta} \\xi $$\n海森矩阵是：\n$$ \\mathbf{H} = \\begin{pmatrix} \\mathbf{a}_\\xi \\cdot \\mathbf{a}_\\xi + (\\mathbf{X} - \\mathbf{x}_s) \\cdot \\frac{\\partial^2\\mathbf{X}}{\\partial\\xi^2} & \\mathbf{a}_\\xi \\cdot \\mathbf{a}_\\eta + (\\mathbf{X} - \\mathbf{x}_s) \\cdot \\frac{\\partial^2\\mathbf{X}}{\\partial\\xi\\partial\\eta} \\\\ \\mathbf{a}_\\eta \\cdot \\mathbf{a}_\\xi + (\\mathbf{X} - \\mathbf{x}_s) \\cdot \\frac{\\partial^2\\mathbf{X}}{\\partial\\eta\\partial\\xi} & \\mathbf{a}_\\eta \\cdot \\mathbf{a}_\\eta + (\\mathbf{X} - \\mathbf{x}_s) \\cdot \\frac{\\partial^2\\mathbf{X}}{\\partial\\eta^2} \\end{pmatrix} $$\n对于双线性单元，$\\frac{\\partial^2\\mathbf{X}}{\\partial\\xi^2} = \\mathbf{0}$ 且 $\\frac{\\partial^2\\mathbf{X}}{\\partial\\eta^2} = \\mathbf{0}$。混合偏导数 $\\frac{\\partial^2\\mathbf{X}}{\\partial\\xi\\partial\\eta} = \\mathbf{c}_{\\xi\\eta}$ 是常数。海森矩阵简化为：\n$$ \\mathbf{H} = \\begin{pmatrix} \\mathbf{a}_\\xi \\cdot \\mathbf{a}_\\xi & \\mathbf{a}_\\xi \\cdot \\mathbf{a}_\\eta \\\\ \\mathbf{a}_\\eta \\cdot \\mathbf{a}_\\xi & \\mathbf{a}_\\eta \\cdot \\mathbf{a}_\\eta \\end{pmatrix} + \\begin{pmatrix} 0 & (\\mathbf{X} - \\mathbf{x}_s) \\cdot \\mathbf{c}_{\\xi\\eta} \\\\ (\\mathbf{X} - \\mathbf{x}_s) \\cdot \\mathbf{c}_{\\xi\\eta} & 0 \\end{pmatrix} $$\n对于问题中给定的特定单元，所有三个单元的 $\\mathbf{c}_{\\xi\\eta}$ 项都为零，这意味着它们是平面的。这使得海森矩阵简化为高斯-牛顿近似，对每个单元而言是常数。然而，算法是为一般的非平面情况实现的。\n\n整体算法流程如下：\n1.  **初始化**：从给定的初始单元和自然坐标的初始猜测开始，通常是 $(\\xi, \\eta) = (0, 0)$。\n2.  **无约束迭代**：执行牛顿-拉夫逊迭代，以找到当前单元内 $\\phi(\\xi, \\eta)$ 的最小值。\n3.  **域检查**：每次迭代后，检查新的坐标 $(\\xi_{k+1}, \\eta_{k+1})$ 是否在域 $[-1, 1] \\times [-1, 1]$ 内。\n    a. 如果过程收敛且解在域内，则已找到曲面上的最近点。\n    b. 如果迭代点超出域，则终止在当前单元上的无约束搜索。\n4.  **滑移与重新参数化**：如果迭代点超出域，则识别出射边。检查该单元的邻接数据，看是否存在跨越此边的相邻单元。\n    a. 如果存在相邻单元，则将出射点的切向坐标重新参数化到相邻单元的自然坐标系中，并遵循方向符号 $s$。将当前单元更新为相邻单元，并从这个新的起始点继续迭代搜索。\n    b. 如果没有相邻单元，则终止搜索，算法转到边界搜索。\n5.  **约束边界搜索**：如果搜索在没有相邻单元的边上终止，则最近点必须位于最后活动单元的边界上。这需要找到 $\\mathbf{x}_s$ 在该单元的四个边和四个角上的最近点。\n    - 到每个边（$\\mathbb{R}^3$中的线段）的投影被求解为一个一维最小化问题。计算包含该线段的直线上最近点的参数，然后将其限制在对应于线段端点的 $[0, 1]$ 范围内。\n    - 比较所有候选点（四个角点和最多四个边内投影点），并选择与 $\\mathbf{x}_s$ 距离最小的点作为最终解。\n6.  **最终计算**：一旦确定了最终的单元索引和坐标 $(\\xi, \\eta)$，就计算物理点 $\\mathbf{X}(\\xi, \\eta)$ 和单位法向量 $\\mathbf{n}(\\xi, \\eta)$。然后计算法向间隙为 $g_n = \\mathbf{n} \\cdot (\\mathbf{x}_s - \\mathbf{X})$。\n\n这种结构化方法通过有原则地处理内部解、单元间滑移和约束边界条件来确保鲁棒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# language: Python\n# version: 3.12\n# libraries:\n#   name: numpy, version: 1.23.5\n\nclass BilinearElement:\n    \"\"\"\n    Represents a bilinear quadrilateral element.\n    \"\"\"\n    def __init__(self, elem_id, nodes, adjacency):\n        self.elem_id = elem_id\n        self.nodes = np.array(nodes)\n        self.adjacency = adjacency  # {edge_idx: (neighbor_id, neighbor_edge, s)}\n\n        # Pre-compute coefficients for the mapping X(xi, eta)\n        X1, X2, X3, X4 = self.nodes\n        self.c0 = 0.25 * (X1 + X2 + X3 + X4)\n        self.c_xi = 0.25 * (-X1 - X2 + X3 + X4)\n        self.c_eta = 0.25 * (-X1 + X2 + X3 - X4)\n        self.c_xi_eta = 0.25 * (X1 - X2 + X3 - X4)\n\n    def get_geometry(self, xi, eta):\n        \"\"\"\n        Computes physical coordinates and tangent vectors.\n        \"\"\"\n        X = self.c0 + self.c_xi * xi + self.c_eta * eta + self.c_xi_eta * xi * eta\n        a_xi = self.c_xi + self.c_xi_eta * eta\n        a_eta = self.c_eta + self.c_xi_eta * xi\n        return X, a_xi, a_eta\n\n    def project_onto_boundary(self, xs):\n        \"\"\"\n        Finds the closest point to xs on the element's boundary (edges and corners).\n        \"\"\"\n        candidates = []\n        # Add corners\n        node_coords = [(-1, -1), (-1, 1), (1, 1), (1, -1)]\n        for i in range(4):\n            X_node = self.nodes[i]\n            dist_sq = np.sum((X_node - xs)**2)\n            candidates.append((dist_sq, node_coords[i][0], node_coords[i][1]))\n\n        # Edge definitions based on node ordering 1-2-3-4\n        edge_nodes = [(0, 1), (1, 2), (2, 3), (3, 0)]\n        \n        for i in range(4):\n            p_a = self.nodes[edge_nodes[i][0]]\n            p_b = self.nodes[edge_nodes[i][1]]\n            \n            v = p_b - p_a\n            v_norm_sq = np.dot(v, v)\n            if v_norm_sq < 1e-14:\n                continue\n\n            t = np.dot(xs - p_a, v) / v_norm_sq\n            \n            if 0 < t < 1:\n                proj_point = p_a + t * v\n                dist_sq = np.sum((proj_point - xs)**2)\n                \n                # Convert t back to (xi, eta)\n                xi_a, eta_a = node_coords[edge_nodes[i][0]]\n                xi_b, eta_b = node_coords[edge_nodes[i][1]]\n                xi_proj = (1 - t) * xi_a + t * xi_b\n                eta_proj = (1 - t) * eta_a + t * eta_b\n                candidates.append((dist_sq, xi_proj, eta_proj))\n\n        # Find the best candidate (minimum distance)\n        best_dist_sq, best_xi, best_eta = min(candidates, key=lambda item: item[0])\n        return best_xi, best_eta\n\n\ndef find_closest_point(xs, start_elem_idx, elements):\n    \"\"\"\n    Main algorithm to find the closest point on the piecewise surface.\n    \"\"\"\n    current_elem_idx = start_elem_idx\n    xi, eta = 0.0, 0.0  # Initial guess\n    \n    max_slides = 10 # Prevent infinite sliding loops\n    for _ in range(max_slides):\n        elem = elements[current_elem_idx]\n        \n        # Newton-Raphson iterations on the current element\n        max_iter = 20\n        tolerance = 1e-12\n        \n        solution_found_inside = False\n        for k in range(max_iter):\n            X, a_xi, a_eta = elem.get_geometry(xi, eta)\n            \n            # Residual vector\n            res = X - xs\n            r_xi = np.dot(a_xi, res)\n            r_eta = np.dot(a_eta, res)\n            \n            # Check for convergence\n            if np.sqrt(r_xi**2 + r_eta**2) < tolerance:\n                if abs(xi) <= 1.0 and abs(eta) <= 1.0:\n                    solution_found_inside = True\n                    break\n                else: # Converged outside, handled below\n                    break\n            \n            # Hessian matrix (Full Newton)\n            H_xixi = np.dot(a_xi, a_xi)\n            H_etaeta = np.dot(a_eta, a_eta)\n            H_xieta = np.dot(a_xi, a_eta) + np.dot(elem.c_xi_eta, res)\n            \n            H = np.array([[H_xixi, H_xieta], [H_xieta, H_etaeta]])\n            \n            # Solve for update\n            try:\n                # Use scipy.linalg.solve for robustness if it were allowed\n                update = np.linalg.solve(H, -np.array([r_xi, r_eta]))\n            except np.linalg.LinAlgError:\n                # Fallback to boundary search if Hessian is singular\n                xi, eta = elem.project_onto_boundary(xs)\n                return current_elem_idx, xi, eta\n\n            xi_new, eta_new = xi + update[0], eta + update[1]\n            \n            # Check if iterate exits the domain\n            if abs(xi_new) > 1.0 or abs(eta_new) > 1.0:\n                xi, eta = xi_new, eta_new # Update before exiting loop\n                break\n                \n            xi, eta = xi_new, eta_new\n            # Last iteration and still inside\n            if k == max_iter - 1:\n                solution_found_inside = True\n\n\n        if solution_found_inside:\n            return current_elem_idx, xi, eta\n\n        #---------- Sliding/Boundary Logic ----------\n        # Clip the out-of-bounds point back to the boundary\n        xi_exit = np.clip(xi, -1.0, 1.0)\n        eta_exit = np.clip(eta, -1.0, 1.0)\n\n        # Determine exit edge\n        exit_edge = -1\n        if abs(xi - xi_exit) > abs(eta - eta_exit): # Exited through a xi=const edge\n            exit_edge = 2 if xi > 1.0 else 0\n            tangential_param = eta_exit\n        else: # Exited through an eta=const edge\n            exit_edge = 1 if eta > 1.0 else 3\n            tangential_param = xi_exit\n        \n        neighbor_info = elem.adjacency.get(exit_edge)\n\n        if neighbor_info:\n            neighbor_id, neighbor_edge, s = neighbor_info\n            \n            # Reparameterize onto neighbor\n            new_tangential_param = s * tangential_param\n            \n            if neighbor_edge == 0: # xi' = -1\n                xi_new, eta_new = -1.0, new_tangential_param\n            elif neighbor_edge == 1: # eta' = 1\n                xi_new, eta_new = new_tangential_param, 1.0\n            elif neighbor_edge == 2: # xi' = 1\n                xi_new, eta_new = 1.0, new_tangential_param\n            else: # neighbor_edge == 3, eta' = -1\n                xi_new, eta_new = new_tangential_param, -1.0\n            \n            current_elem_idx = neighbor_id\n            # Step slightly inside the new element for the next iteration\n            xi = np.clip(xi_new, -1.0 + 1e-9, 1.0 - 1e-9)\n            eta = np.clip(eta_new, -1.0 + 1e-9, 1.0 - 1e-9)\n\n        else: # No neighbor, perform boundary search\n            final_xi, final_eta = elem.project_onto_boundary(xs)\n            return current_elem_idx, final_xi, final_eta\n    \n    # Fallback if max_slides is reached\n    final_xi, final_eta = elements[current_elem_idx].project_onto_boundary(xs)\n    return current_elem_idx, final_xi, final_eta\n\n\ndef solve():\n    nodes_all = [\n        [(0,0,0), (0,1,0), (1,1,0.1), (1,0,0.1)],\n        [(1,0,0.1), (1,1,0.1), (2,1,0.2), (2,0,0.2)],\n        [(2,0,0.2), (2,1,0.2), (3,1,0.2), (3,0,0.2)],\n    ]\n\n    # Edge indices: 0: xi=-1, 1: eta=1, 2: xi=1, 3: eta=-1\n    adj_all = [\n        {2: (1, 0, 1)},\n        {0: (0, 2, 1), 2: (2, 0, 1)},\n        {0: (1, 2, 1)},\n    ]\n    \n    elements = [BilinearElement(i, nodes_all[i], adj_all[i]) for i in range(3)]\n    \n    test_cases = [\n        {'xs': (0.3, 0.4, 0.05), 'start': 0},\n        {'xs': (1.4, 0.5, 0.05), 'start': 0},\n        {'xs': (0.6, 1.2, 0.05), 'start': 0},\n        {'xs': (3.7, -0.6, 1.0), 'start': 1},\n        {'xs': (2.6, 0.2, 0.3), 'start': 0},\n    ]\n\n    results = []\n    for case in test_cases:\n        xs = np.array(case['xs'])\n        start_idx = case['start']\n        \n        final_idx, final_xi, final_eta = find_closest_point(xs, start_idx, elements)\n\n        final_elem = elements[final_idx]\n        X, a_xi, a_eta = final_elem.get_geometry(final_xi, final_eta)\n        \n        normal_vec = np.cross(a_xi, a_eta)\n        norm_val = np.linalg.norm(normal_vec)\n        if norm_val < 1e-12:\n            # Handle degenerate normal (e.g., at a seam)\n            # Use normal from element center as an approximation\n            _, a_xi_c, a_eta_c = final_elem.get_geometry(0, 0)\n            normal_vec = np.cross(a_xi_c, a_eta_c)\n            norm_val = np.linalg.norm(normal_vec)\n\n        n = normal_vec / norm_val\n        \n        gap = np.dot(n, xs - X)\n        results.append(f\"{gap:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3553969"}]}