{"hands_on_practices": [{"introduction": "任何本构模型，无论是基于物理推导还是数据驱动，都必须遵守热力学基本定律。本练习的核心是应用离散形式的克劳修斯-杜恩不等式（Clausius-Duhem inequality），这是热力学第二定律在连续介质力学中的体现。通过计算给定变形历史下每个增量步的耗散，你将能够亲手检验一个候选的亥姆霍兹自由能函数（Helmholtz free energy）是否满足非负耗散这一热力学一致性要求，这是评估任何新本构模型有效性的关键“健全性检查”[@problem_id:3557155]。", "problem": "给定离散的、按时间排序的小应变张量和柯西应力张量的测量值，表示为集合对 $\\{(\\boldsymbol{\\varepsilon}_k,\\boldsymbol{\\sigma}_k)\\}_{k=0}^N$，其中每个 $\\boldsymbol{\\varepsilon}_k$ 和 $\\boldsymbol{\\sigma}_k$ 都是对称的 $3\\times 3$ 张量。在小应变假设和等温条件下，连续介质力学层面的克劳修斯-杜亥姆不等式（Clausius-Duhem inequality, CDI）指出，单位体积的耗散率满足 $\\boldsymbol{\\sigma}:\\dot{\\boldsymbol{\\varepsilon}} - \\dot{\\psi} \\ge 0$，其中 $\\psi$ 是亥姆霍兹自由能密度。在采用后向差分的离散时间设置中，这产生分段离散耗散\n$$\n\\mathcal{D}_k = \\boldsymbol{\\sigma}_k : \\left( \\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1} \\right) - \\left[ \\psi(\\boldsymbol{\\varepsilon}_k) - \\psi(\\boldsymbol{\\varepsilon}_{k-1}) \\right],\n$$\n以及历史过程中的累积耗散\n$$\n\\mathcal{D}_{\\mathrm{tot}} = \\sum_{k=1}^N \\mathcal{D}_k.\n$$\n二阶张量的双点积 $:$ 定义为 $\\mathbf{A}:\\mathbf{B} = \\sum_{i=1}^3\\sum_{j=1}^3 A_{ij}B_{ij}$，弗罗贝尼乌斯范数满足 $\\|\\mathbf{A}\\|_F^2 = \\mathbf{A}:\\mathbf{A}$。\n\n您的任务是实现一个程序，对于给定的候选能量密度 $\\psi(\\boldsymbol{\\varepsilon})$，计算几个测试历史的分段离散耗散 $\\mathcal{D}_k$ 和累积耗散 $\\mathcal{D}_{\\mathrm{tot}}$，并验证所有分段 $k=1,\\dots,N$ 的非负性条件 $\\mathcal{D}_k \\ge 0$。离散耗散是单位体积的能量，必须以帕斯卡（Pa）为单位表示。您必须使用 $10^{-12}\\,\\mathrm{Pa}$ 的数值容差来检查非负性，即，如果 $\\mathcal{D}_k \\ge -10^{-12}\\,\\mathrm{Pa}$，则视该分段为非负。\n\n实现以下候选能量密度：\n- 具有拉梅参数 $\\lambda>0$ 和 $\\mu>0$ 的各向同性线弹性势能，\n$$\n\\psi_{\\mathrm{lin}}(\\boldsymbol{\\varepsilon};\\lambda,\\mu) = \\tfrac{1}{2}\\lambda \\left(\\mathrm{tr}\\,\\boldsymbol{\\varepsilon}\\right)^2 + \\mu\\, \\boldsymbol{\\varepsilon}:\\boldsymbol{\\varepsilon}.\n$$\n- 具有系数 $\\alpha \\ge 0$ 和 $\\beta > 0$ 的四次凸能量，\n$$\n\\psi_{\\mathrm{quartic}}(\\boldsymbol{\\varepsilon};\\alpha,\\beta) = \\alpha\\, \\|\\boldsymbol{\\varepsilon}\\|_F^2 + \\beta\\, \\|\\boldsymbol{\\varepsilon}\\|_F^4.\n$$\n- 具有系数 $\\alpha>0$ 的凹二次能量（热力学上不可接受），\n$$\n\\psi_{\\mathrm{concave}}(\\boldsymbol{\\varepsilon};\\alpha) = -\\alpha\\, \\|\\boldsymbol{\\varepsilon}\\|_F^2.\n$$\n在测量应力与所选 $\\psi$ 一致的测试用例中，使用 $\\boldsymbol{\\sigma}_k = \\partial \\psi/\\partial \\boldsymbol{\\varepsilon}\\,\\big|_{\\boldsymbol{\\varepsilon}_k}$，梯度如下：\n- 对于 $\\psi_{\\mathrm{lin}}$: $\\boldsymbol{\\sigma} = \\lambda\\,\\mathrm{tr}(\\boldsymbol{\\varepsilon})\\,\\mathbf{I} + 2\\mu\\,\\boldsymbol{\\varepsilon}$，其中 $\\mathbf{I}$ 是单位张量。\n- 对于 $\\psi_{\\mathrm{quartic}}$: $\\boldsymbol{\\sigma} = 2\\alpha\\,\\boldsymbol{\\varepsilon} + 4\\beta\\,\\|\\boldsymbol{\\varepsilon}\\|_F^2\\,\\boldsymbol{\\varepsilon}$。\n- 对于 $\\psi_{\\mathrm{concave}}$: $\\boldsymbol{\\sigma} = -2\\alpha\\,\\boldsymbol{\\varepsilon}$。\n\n此外，包括一个测试用例，其测量应力取自理想单轴理想弹塑性响应，屈服应力为 $\\sigma_y>0$。在这种情况下，仅限于单轴应变路径，其中 $\\varepsilon_{11}\\neq 0$ 且所有其他应变分量均为零，并按以下方式定义测量应力\n$$\n\\sigma_{11,k} = \\mathrm{sign}(\\varepsilon_{11,k}) \\,\\min\\!\\left( E_{\\mathrm{eff}}\\, \\varepsilon_{11,k},\\, \\sigma_y \\right), \\quad \\sigma_{ij,k}=0 \\;\\text{for}\\; (i,j)\\neq(1,1),\n$$\n其中 $E_{\\mathrm{eff}} = \\lambda + 2\\mu$ 是与该测试中使用的各向同性线弹性 $\\psi_{\\mathrm{lin}}$ 相关联的有效单轴模量，$\\mathrm{sign}(\\cdot)$ 表示符号函数。\n\n测试套件。为保证科学覆盖性，请使用以下四个历史和参数：\n\n1. 具有一致应力的凸二次能量（理想路径）。使用 $\\psi_{\\mathrm{lin}}$，参数为 $\\lambda = 6.0\\times 10^{10}\\,\\mathrm{Pa}$ 和 $\\mu = 4.0\\times 10^{10}\\,\\mathrm{Pa}$。设 $N=4$ 且\n$$\n\\boldsymbol{\\varepsilon}_0 = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix},\\;\n\\boldsymbol{\\varepsilon}_1 = \\begin{bmatrix} 1.0\\times 10^{-3}  1.5\\times 10^{-4}  0 \\\\ 1.5\\times 10^{-4}  -2.0\\times 10^{-4}  5.0\\times 10^{-5} \\\\ 0  5.0\\times 10^{-5}  3.0\\times 10^{-4} \\end{bmatrix},\n$$\n$$\n\\boldsymbol{\\varepsilon}_2 = \\begin{bmatrix} 2.0\\times 10^{-3}  1.0\\times 10^{-4}  -1.0\\times 10^{-4} \\\\ 1.0\\times 10^{-4}  4.0\\times 10^{-4}  2.0\\times 10^{-5} \\\\ -1.0\\times 10^{-4}  2.0\\times 10^{-5}  1.0\\times 10^{-3} \\end{bmatrix},\n\\quad\n\\boldsymbol{\\varepsilon}_3 = \\begin{bmatrix} 1.5\\times 10^{-3}  0  0 \\\\ 0  1.0\\times 10^{-3}  0 \\\\ 0  0  5.0\\times 10^{-4} \\end{bmatrix},\n$$\n$$\n\\boldsymbol{\\varepsilon}_4 = \\begin{bmatrix} 1.5\\times 10^{-3}  2.0\\times 10^{-5}  -1.0\\times 10^{-5} \\\\ 2.0\\times 10^{-5}  1.2\\times 10^{-3}  0 \\\\ -1.0\\times 10^{-5}  0  4.0\\times 10^{-4} \\end{bmatrix}.\n$$\n使用 $\\boldsymbol{\\sigma}_k = \\partial \\psi_{\\mathrm{lin}}/\\partial \\boldsymbol{\\varepsilon}\\,\\big|_{\\boldsymbol{\\varepsilon}_k}$。\n\n2. 具有一致应力的凹二次能量（显示违规的边缘情况）。使用 $\\psi_{\\mathrm{concave}}$，参数为 $\\alpha = 1.0\\times 10^{9}\\,\\mathrm{Pa}$。设 $N=3$ 且\n$$\n\\boldsymbol{\\varepsilon}_0 = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix},\\;\n\\boldsymbol{\\varepsilon}_1 = \\begin{bmatrix} 3.0\\times 10^{-3}  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix},\n$$\n$$\n\\boldsymbol{\\varepsilon}_2 = \\begin{bmatrix} 6.0\\times 10^{-3}  0  0 \\\\ 0  -2.0\\times 10^{-3}  0 \\\\ 0  0  1.0\\times 10^{-3} \\end{bmatrix},\\quad\n\\boldsymbol{\\varepsilon}_3 = \\begin{bmatrix} 2.0\\times 10^{-3}  0  0 \\\\ 0  2.0\\times 10^{-3}  0 \\\\ 0  0  -1.0\\times 10^{-3} \\end{bmatrix}.\n$$\n使用 $\\boldsymbol{\\sigma}_k = \\partial \\psi_{\\mathrm{concave}}/\\partial \\boldsymbol{\\varepsilon}\\,\\big|_{\\boldsymbol{\\varepsilon}_k}$。\n\n3. 具有重复状态的四次凸能量（零增量的边界情况）。使用 $\\psi_{\\mathrm{quartic}}$，参数为 $\\alpha = 2.5\\times 10^{8}\\,\\mathrm{Pa}$ 和 $\\beta = 5.0\\times 10^{11}\\,\\mathrm{Pa}$。设 $N=4$ 且\n$$\n\\boldsymbol{\\varepsilon}_0 = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix},\\;\n\\boldsymbol{\\varepsilon}_1 = \\begin{bmatrix} -1.0\\times 10^{-3}  2.0\\times 10^{-4}  0 \\\\ 2.0\\times 10^{-4}  -1.0\\times 10^{-3}  0 \\\\ 0  0  -1.0\\times 10^{-3} \\end{bmatrix},\n$$\n$$\n\\boldsymbol{\\varepsilon}_2 = \\boldsymbol{\\varepsilon}_1,\\quad\n\\boldsymbol{\\varepsilon}_3 = \\begin{bmatrix} -2.0\\times 10^{-3}  3.0\\times 10^{-4}  0 \\\\ 3.0\\times 10^{-4}  -5.0\\times 10^{-4}  1.0\\times 10^{-4} \\\\ 0  1.0\\times 10^{-4}  -2.0\\times 10^{-4} \\end{bmatrix},\n$$\n$$\n\\boldsymbol{\\varepsilon}_4 = \\begin{bmatrix} -2.5\\times 10^{-3}  0  0 \\\\ 0  -1.0\\times 10^{-3}  0 \\\\ 0  0  0 \\end{bmatrix}.\n$$\n使用 $\\boldsymbol{\\sigma}_k = \\partial \\psi_{\\mathrm{quartic}}/\\partial \\boldsymbol{\\varepsilon}\\,\\big|_{\\boldsymbol{\\varepsilon}_k}$。\n\n4. 弹性势能与测量的理想弹塑性应力一起使用（显示潜在违规的边缘情况）。使用 $\\psi_{\\mathrm{lin}}$，参数为 $\\lambda = 6.0\\times 10^{10}\\,\\mathrm{Pa}$ 和 $\\mu = 4.0\\times 10^{10}\\,\\mathrm{Pa}$，屈服应力为 $\\sigma_y = 1.0\\times 10^{8}\\,\\mathrm{Pa}$。设 $N=3$ 并考虑单轴应变路径\n$$\n\\boldsymbol{\\varepsilon}_0 = \\mathbf{0},\\quad\n\\boldsymbol{\\varepsilon}_1 = \\begin{bmatrix} 5.0\\times 10^{-4}  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix},\\quad\n\\boldsymbol{\\varepsilon}_2 = \\begin{bmatrix} 1.0\\times 10^{-3}  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix},\\quad\n\\boldsymbol{\\varepsilon}_3 = \\begin{bmatrix} 2.0\\times 10^{-3}  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix},\n$$\n测量应力由上述理想弹塑性规则给出，其中 $E_{\\mathrm{eff}}=\\lambda+2\\mu$。\n\n程序要求。您的程序必须：\n- 实现上述的 $\\psi$ 函数，并在指定情况下实现相应的应力函数。\n- 对于每个测试用例，计算所有分段耗散值 $\\mathcal{D}_k$ 和累积耗散 $\\mathcal{D}_{\\mathrm{tot}}$，单位为帕斯卡。\n- 使用 $10^{-12}\\,\\mathrm{Pa}$ 的容差验证每个分段的非负性条件，并报告该测试用例中的所有分段是否均为非负。\n- 生成一行输出，包含一个逗号分隔的列表，用方括号括起来，格式为 $[\\mathcal{D}_{\\mathrm{tot}}^{(1)},\\mathrm{all\\_nonneg}^{(1)},\\mathcal{D}_{\\mathrm{tot}}^{(2)},\\mathrm{all\\_nonneg}^{(2)},\\mathcal{D}_{\\mathrm{tot}}^{(3)},\\mathrm{all\\_nonneg}^{(3)},\\mathcal{D}_{\\mathrm{tot}}^{(4)},\\mathrm{all\\_nonneg}^{(4)}]$，其中 $\\mathcal{D}_{\\mathrm{tot}}^{(i)}$ 是一个以帕斯卡为单位的浮点数，$\\mathrm{all\\_nonneg}^{(i)}$ 是一个布尔值，指示测试用例 $i$ 中的所有分段是否满足 $\\mathcal{D}_k \\ge -10^{-12}\\,\\mathrm{Pa}$。", "solution": "该问题陈述被评估为有效。它在科学上基于连续介质力学的原理，特别是克劳修斯-杜亥姆不等式对材料行为施加的热力学约束。该问题是适定的，为直接计算求解提供了所有必要的数据、参数和函数形式。定义和测试用例清晰、客观且自洽。\n\n问题的核心是针对几种材料模型和加载历史，验证克劳修斯-杜亥姆不等式（CDI）的离散形式。在等温力学过程中，CDI 指出耗散率必须为非负。其对于从时间步 $k-1$ 到 $k$ 的时间段的离散对应形式为\n$$\n\\mathcal{D}_k = \\boldsymbol{\\sigma}_k : (\\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1}) - \\left[ \\psi(\\boldsymbol{\\varepsilon}_k) - \\psi(\\boldsymbol{\\varepsilon}_{k-1}) \\right] \\ge 0\n$$\n其中 $\\boldsymbol{\\varepsilon}_k$ 是小应变张量，$\\boldsymbol{\\sigma}_k$ 是柯西应力张量，$\\psi$ 是亥姆霍兹自由能密度。上述条件必须对每个分段 $k=1, \\dots, N$ 都成立。历史过程中的总耗散是总和 $\\mathcal{D}_{\\mathrm{tot}} = \\sum_{k=1}^N \\mathcal{D}_k$。\n\n计算过程涉及实现给定的亥姆霍兹自由能密度 $\\psi$ 的候选函数以及相应的应力张量 $\\boldsymbol{\\sigma}$。对于每个测试用例，程序将遍历所提供的时间有序应变历史 $\\{\\boldsymbol{\\varepsilon}_k\\}$。在每个分段中，它计算增量功 $\\boldsymbol{\\sigma}_k : (\\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1})$ 和储能变化 $\\psi(\\boldsymbol{\\varepsilon}_k) - \\psi(\\boldsymbol{\\varepsilon}_{k-1})$，然后计算耗散 $\\mathcal{D}_k$。\n\n实现将严重依赖于数值张量代数，`numpy` 库非常适合此目的。张量 $\\boldsymbol{\\varepsilon}$ 和 $\\boldsymbol{\\sigma}$ 表示为 $3\\times3$ 的 `numpy` 数组。所需的基本张量运算是：\n- 迹，$\\mathrm{tr}\\,\\boldsymbol{\\varepsilon} = \\sum_{i=1}^3 \\varepsilon_{ii}$。\n- 双点积，$\\mathbf{A}:\\mathbf{B} = \\sum_{i,j} A_{ij}B_{ij}$，这相当于逐元素乘积后求和。\n- 弗罗贝尼乌斯范数的平方，$\\|\\mathbf{A}\\|_F^2 = \\mathbf{A}:\\mathbf{A}$。\n\n让我们分析每个测试用例的理论预期：\n\n1.  **各向同性线弹性势能 ($\\psi_{\\mathrm{lin}}$)**：能量函数 $\\psi_{\\mathrm{lin}}(\\boldsymbol{\\varepsilon}) = \\frac{1}{2}\\lambda (\\mathrm{tr}\\,\\boldsymbol{\\varepsilon})^2 + \\mu\\, \\boldsymbol{\\varepsilon}:\\boldsymbol{\\varepsilon}$ 是一个二次型。当拉梅参数 $\\lambda > 0$ 和 $\\mu > 0$ 时，此函数是严格凸的。应力由 $\\boldsymbol{\\sigma} = \\partial\\psi_{\\mathrm{lin}}/\\partial\\boldsymbol{\\varepsilon}$ 给出。在这种所谓的*超弹性*情况下，离散耗散 $\\mathcal{D}_k$ 等效于与凸函数 $\\psi$ 相关联的 Bregman 散度。\n    $$\n    \\mathcal{D}_k = \\frac{\\partial\\psi}{\\partial\\boldsymbol{\\varepsilon}}\\bigg|_{\\boldsymbol{\\varepsilon}_k} : (\\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1}) - (\\psi(\\boldsymbol{\\varepsilon}_k) - \\psi(\\boldsymbol{\\varepsilon}_{k-1}))\n    $$\n    由于 $\\psi$ 的凸性，该量保证为非负。实际上，对于像 $\\psi_{\\mathrm{lin}}$ 这样的二次函数，此表达式简化为 $\\mathcal{D}_k = \\psi_{\\mathrm{lin}}(\\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1})$。由于对于非零应变，$\\psi_{\\mathrm{lin}}$ 是正定的，我们期望 $\\mathcal{D}_k \\ge 0$，且仅当 $\\boldsymbol{\\varepsilon}_k = \\boldsymbol{\\varepsilon}_{k-1}$ 时等号成立。因此，预计所有分段都满足CDI。\n\n2.  **凹二次能量 ($\\psi_{\\mathrm{concave}}$)**：能量 $\\psi_{\\mathrm{concave}}(\\boldsymbol{\\varepsilon}) = -\\alpha\\, \\|\\boldsymbol{\\varepsilon}\\|_F^2$（其中 $\\alpha>0$）是严格凹的。对于稳定材料而言，这样的能量函数在热力学上是不可接受的。当 $\\boldsymbol{\\sigma} = \\partial\\psi_{\\mathrm{concave}}/\\partial\\boldsymbol{\\varepsilon}$ 时，直接计算可得：\n    $$\n    \\mathcal{D}_k = -\\alpha \\|\\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1}\\|_F^2\n    $$\n    由于 $\\alpha>0$ 且 $\\|\\cdot\\|_F^2$ 是非负的，$\\mathcal{D}_k$ 将是非正的。对于任何应变发生变化的分段（$\\boldsymbol{\\varepsilon}_k \\neq \\boldsymbol{\\varepsilon}_{k-1}$），我们预计会严格违反 CDI，即 $\\mathcal{D}_k  0$。\n\n3.  **四次凸能量 ($\\psi_{\\mathrm{quartic}}$)**：函数 $\\psi_{\\mathrm{quartic}}(\\boldsymbol{\\varepsilon}) = \\alpha\\, \\|\\boldsymbol{\\varepsilon}\\|_F^2 + \\beta\\, \\|\\boldsymbol{\\varepsilon}\\|_F^4$（其中 $\\alpha \\ge 0, \\beta  0$）是严格凸的。与第一种情况一样，材料是超弹性的，$\\psi$ 的凸性确保了耗散 $\\mathcal{D}_k$ 是非负的。此测试用例中的一个分段由 $\\boldsymbol{\\varepsilon}_2 = \\boldsymbol{\\varepsilon}_1$ 定义，这意味着 $\\boldsymbol{\\varepsilon}_2 - \\boldsymbol{\\varepsilon}_1 = \\mathbf{0}$。对于此分段，耗散 $\\mathcal{D}_2$ 必须恰好为零，我们的实现必须正确处理这一点。预计所有分段都满足CDI。\n\n4.  **弹性势能与塑性应力**：在这里，所选的能量函数 $\\psi_{\\mathrm{lin}}$ 仅表示能量存储的可恢复弹性部分。然而，应力取自一个理想弹塑性模型，该模型包括不可恢复（耗散）的变形。应力不能从所选的 $\\psi$ 导出，即 $\\boldsymbol{\\sigma}_k \\neq \\partial\\psi_{\\mathrm{lin}}/\\partial\\boldsymbol{\\varepsilon}\\big|_{\\boldsymbol{\\varepsilon}_k}$。因此，计算出的量 $\\mathcal{D}_k$ 并不代表真实的物理耗散。该框架要求 $\\psi$ 是总亥姆霍兹自由能。通过使用一个不完整的 $\\psi$，计算出的非负性可能会被违反，并且在这种情况下，这是预料之中的。具体来说，当材料屈服时，应力上限为 $\\sigma_y$，而（通过 $\\psi_{\\mathrm{lin}}$ 和总应变 $\\boldsymbol{\\varepsilon}_k$ 计算的）储存的弹性势能继续呈二次方增长。这种不匹配可能导致计算出的 $\\mathcal{D}_k  0$。\n\n程序将构建为处理以上每一种情况。它将为每个 $\\psi$ 和 $\\boldsymbol{\\sigma}$ 定义函数。一个主循环将遍历四个测试套件，计算应力历史、分段耗散 $\\mathcal{D}_k$、累积耗散 $\\mathcal{D}_{\\mathrm{tot}}$，并根据给定的 $10^{-12}\\,\\mathrm{Pa}$ 容差验证非负性条件。最终结果将被汇总并按指定格式输出。", "answer": "```python\nimport numpy as np\n\n# A meticulous and exacting professor in the STEM fields.\n\ndef solve():\n    \"\"\"\n    Computes and verifies discrete dissipation for several constitutive models.\n    \"\"\"\n    TOL = 1e-12\n\n    # Utility functions for tensor algebra\n    def double_dot(A, B):\n        \"\"\"Computes the double dot product of two 3x3 tensors.\"\"\"\n        return np.sum(A * B)\n\n    def frobenius_norm_sq(A):\n        \"\"\"Computes the squared Frobenius norm of a 3x3 tensor.\"\"\"\n        return double_dot(A, A)\n\n    # Candidate energy and stress functions\n    def psi_lin(eps, lam, mu):\n        \"\"\"Isotropic linear elastic energy density.\"\"\"\n        return 0.5 * lam * np.trace(eps)**2 + mu * double_dot(eps, eps)\n\n    def sigma_lin(eps, lam, mu):\n        \"\"\"Stress from isotropic linear elastic energy.\"\"\"\n        return lam * np.trace(eps) * np.eye(3) + 2 * mu * eps\n\n    def psi_quartic(eps, alpha, beta):\n        \"\"\"Quartic convex energy density.\"\"\"\n        norm_sq = frobenius_norm_sq(eps)\n        return alpha * norm_sq + beta * norm_sq**2\n\n    def sigma_quartic(eps, alpha, beta):\n        \"\"\"Stress from quartic convex energy.\"\"\"\n        norm_sq = frobenius_norm_sq(eps)\n        return 2 * alpha * eps + 4 * beta * norm_sq * eps\n\n    def psi_concave(eps, alpha):\n        \"\"\"Concave quadratic energy density.\"\"\"\n        return -alpha * frobenius_norm_sq(eps)\n\n    def sigma_concave(eps, alpha):\n        \"\"\"Stress from concave quadratic energy.\"\"\"\n        return -2 * alpha * eps\n\n    # --- Test Suite Setup ---\n\n    # Case 1: Convex quadratic energy with consistent stress\n    case1_params = {'lam': 6.0e10, 'mu': 4.0e10}\n    case1_eps_hist = [\n        np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[1.0e-3, 1.5e-4, 0.0], [1.5e-4, -2.0e-4, 5.0e-5], [0.0, 5.0e-5, 3.0e-4]]),\n        np.array([[2.0e-3, 1.0e-4, -1.0e-4], [1.0e-4, 4.0e-4, 2.0e-5], [-1.0e-4, 2.0e-5, 1.0e-3]]),\n        np.array([[1.5e-3, 0.0, 0.0], [0.0, 1.0e-3, 0.0], [0.0, 0.0, 5.0e-4]]),\n        np.array([[1.5e-3, 2.0e-5, -1.0e-5], [2.0e-5, 1.2e-3, 0.0], [-1.0e-5, 0.0, 4.0e-4]])\n    ]\n\n    # Case 2: Concave quadratic energy with consistent stress\n    case2_params = {'alpha': 1.0e9}\n    case2_eps_hist = [\n        np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[3.0e-3, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[6.0e-3, 0.0, 0.0], [0.0, -2.0e-3, 0.0], [0.0, 0.0, 1.0e-3]]),\n        np.array([[2.0e-3, 0.0, 0.0], [0.0, 2.0e-3, 0.0], [0.0, 0.0, -1.0e-3]])\n    ]\n\n    # Case 3: Quartic convex energy with a repeated state\n    case3_params = {'alpha': 2.5e8, 'beta': 5.0e11}\n    _eps1_case3 = np.array([[-1.0e-3, 2.0e-4, 0.0], [2.0e-4, -1.0e-3, 0.0], [0.0, 0.0, -1.0e-3]])\n    case3_eps_hist = [\n        np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        _eps1_case3,\n        _eps1_case3.copy(),\n        np.array([[-2.0e-3, 3.0e-4, 0.0], [3.0e-4, -5.0e-4, 1.0e-4], [0.0, 1.0e-4, -2.0e-4]]),\n        np.array([[-2.5e-3, 0.0, 0.0], [0.0, -1.0e-3, 0.0], [0.0, 0.0, 0.0]])\n    ]\n\n    # Case 4: Elastic energy with measured elastic-perfectly plastic stress\n    case4_params = {'lam': 6.0e10, 'mu': 4.0e10, 'sigma_y': 1.0e8}\n    case4_eps_hist = [\n        np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[5.0e-4, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[1.0e-3, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[2.0e-3, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    ]\n    \n    test_suite = [\n        {'psi_func': psi_lin, 'sigma_type': 'consistent', 'sigma_func': sigma_lin, 'params': case1_params, 'eps_hist': case1_eps_hist},\n        {'psi_func': psi_concave, 'sigma_type': 'consistent', 'sigma_func': sigma_concave, 'params': case2_params, 'eps_hist': case2_eps_hist},\n        {'psi_func': psi_quartic, 'sigma_type': 'consistent', 'sigma_func': sigma_quartic, 'params': case3_params, 'eps_hist': case3_eps_hist},\n        {'psi_func': psi_lin, 'sigma_type': 'plastic', 'params': case4_params, 'eps_hist': case4_eps_hist}\n    ]\n\n    results = []\n\n    for case in test_suite:\n        eps_hist = case['eps_hist']\n        params = case['params']\n        psi_func = case['psi_func']\n        N = len(eps_hist) - 1\n        \n        # Generate stress history\n        sigma_hist = [np.zeros((3, 3))] * (N + 1)\n        if case['sigma_type'] == 'consistent':\n            sigma_func = case['sigma_func']\n            sigma_hist = [sigma_func(eps, **params) for eps in eps_hist]\n        elif case['sigma_type'] == 'plastic':\n            lam, mu, sigma_y = params['lam'], params['mu'], params['sigma_y']\n            E_eff = lam + 2 * mu\n            temp_sigma_hist = []\n            for k in range(N + 1):\n                eps_k = eps_hist[k]\n                stress_k = np.zeros((3, 3))\n                if k > 0: # sigma_0 is not used in dissipation calculation\n                    eps11_k = eps_k[0, 0]\n                    sigma11_elastic = E_eff * eps11_k\n                    sigma11_k = np.sign(eps11_k) * min(abs(sigma11_elastic), sigma_y)\n                    stress_k[0, 0] = sigma11_k\n                temp_sigma_hist.append(stress_k)\n            sigma_hist = temp_sigma_hist\n\n        # Calculate dissipation\n        d_total = 0.0\n        all_nonneg = True\n        \n        for k in range(1, N + 1):\n            eps_k = eps_hist[k]\n            eps_km1 = eps_hist[k-1]\n            sigma_k = sigma_hist[k]\n\n            work_inc = double_dot(sigma_k, eps_k - eps_km1)\n            psi_k = psi_func(eps_k, **{p: v for p, v in params.items() if p not in ['sigma_y']})\n            psi_km1 = psi_func(eps_km1, **{p: v for p, v in params.items() if p not in ['sigma_y']})\n            \n            d_k = work_inc - (psi_k - psi_km1)\n            d_total += d_k\n            \n            if d_k  -TOL:\n                all_nonneg = False\n        \n        results.extend([d_total, str(all_nonneg).lower()])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3557155"}, {"introduction": "掌握了基本物理约束后，我们转向数据驱动求解器的核心算法。数据驱动计算力学（Data-Driven Computational Mechanics, DDCM）框架旨在绕过传统的封闭形式本构关系，直接从材料数据中求解力学问题。本练习将指导你为一个简单的桁架结构实现DDCM求解器的一次完整迭代，它包含两个基本步骤：将力学状态投影到最近的材料数据点（D-projection），以及在力学平衡和运动协调约束下寻找最优状态（E-projection）。通过这个练习，你将深入理解作为许多数据驱动求解器基础的“交替投影”（alternating projections）算法[@problem_id:3557165]。", "problem": "考虑一个沿$x$轴的一维双单元桁架，其包含节点$1$、$2$和$3$，其中节点$1$被固定，位移为$u_1 = 0$，节点$3$承受一个指定的轴向载荷$P$，单位为牛顿$(\\mathrm{N})$。节点由长度为$L_e$（单位：米$(\\mathrm{m})$）和横截面积为$A_e$（单位：平方米$(\\mathrm{m}^2)$）的单元$e = 1, 2$连接。每个单元的轴向应变由协调条件定义为$\\varepsilon_1 = (u_2 - u_1)/L_1$和$\\varepsilon_2 = (u_3 - u_2)/L_2$，其中$u_2$和$u_3$是节点位移，单位为米$(\\mathrm{m})$。每个单元的轴向应力用$\\sigma_e$表示，单位为帕斯卡$(\\mathrm{Pa})$。全局平衡要求在节点$2$处，内力达到平衡，$A_1 \\sigma_1 - A_2 \\sigma_2 = 0$，在节点$3$处，内力等于施加的载荷，$A_2 \\sigma_2 = P$。这些条件意味着$\\sigma_2 = P/A_2$和$\\sigma_1 = P/A_1$，单位为帕斯卡$(\\mathrm{Pa})$。\n\n在数据驱动计算力学（DDCM）框架中，材料行为由每个单元的有限数据集$D_e = \\{(\\varepsilon_{e,j}, \\sigma_{e,j})\\}_{j=1}^{N_e}$描述，而不是一个封闭形式的本构定律。给定单元模量$E_e$（单位：帕斯卡$(\\mathrm{Pa})$），定义柔度$S_e = 1/E_e$（单位：帕斯卡的倒数$(\\mathrm{Pa}^{-1})$）。一个单元状态$(\\varepsilon_e, \\sigma_e)$相对于一个数据点$(\\varepsilon_{e,j}, \\sigma_{e,j})$的数据驱动度量为\n$$\nd_{e,j}^2 = E_e \\left(\\varepsilon_e - \\varepsilon_{e,j}\\right)^2 + \\frac{1}{E_e} \\left(\\sigma_e - \\sigma_{e,j}\\right)^2,\n$$\n单位为帕斯卡$(\\mathrm{Pa})$。在材料数据集上的逐单元投影（D-投影）将$(\\varepsilon_e, \\sigma_e)$映射到使其$d_{e,j}^2$最小化的最近数据点$(\\hat{\\varepsilon}_e, \\hat{\\sigma}_e)$。定义一个状态$\\{(\\varepsilon_e, \\sigma_e)\\}_{e=1}^2$及其D-投影$\\{(\\hat{\\varepsilon}_e, \\hat{\\sigma}_e)\\}_{e=1}^2$的全局度量残差范数为\n$$\nr = \\left( \\sum_{e=1}^2 \\left[ E_e \\left(\\varepsilon_e - \\hat{\\varepsilon}_e\\right)^2 + \\frac{1}{E_e} \\left(\\sigma_e - \\hat{\\sigma}_e\\right)^2 \\right] \\right)^{1/2},\n$$\n其单位为$\\sqrt{\\mathrm{Pa}}$。一次DDCM迭代包括：\n1. D-投影：对每个单元，将$(\\varepsilon_e^0, \\sigma_e^0)$投影到其最近的数据点$(\\hat{\\varepsilon}_e^0, \\hat{\\sigma}_e^0)$。\n2. E-投影：在满足全局协调和平衡的条件下，找到$(\\varepsilon_e^1, \\sigma_e^1)$，使其与投影数据的度量距离之和最小，即：\n$$\n\\min_{u_2,u_3,\\sigma_1,\\sigma_2} \\sum_{e=1}^2 \\left[ E_e \\left(\\varepsilon_e(u_2,u_3) - \\hat{\\varepsilon}_e^0\\right)^2 + \\frac{1}{E_e} \\left(\\sigma_e - \\hat{\\sigma}_e^0\\right)^2 \\right],\n$$\n约束条件为$\\varepsilon_1=(u_2-u_1)/L_1$，$\\varepsilon_2=(u_3-u_2)/L_2$，$A_1 \\sigma_1 - A_2 \\sigma_2 = 0$以及$A_2 \\sigma_2 = P$。\n\n从一个指定的初始猜测$\\{(\\varepsilon_e^0, \\sigma_e^0)\\}_{e=1}^2$开始，定义$r_0$为该状态相对于其D-投影$\\{(\\hat{\\varepsilon}_e^0, \\hat{\\sigma}_e^0)\\}_{e=1}^2$的度量残差范数，定义$r_1$为E-投影后的状态$\\{(\\varepsilon_e^1,\\sigma_e^1)\\}_{e=1}^2$相对于其自身D-投影的度量残差范数。我们关注的量是度量残差范数的减小量，\n$$\n\\Delta r = r_0 - r_1,\n$$\n单位为$\\sqrt{\\mathrm{Pa}}$。\n\n实现一个程序，对下方的每个测试用例，执行恰好一次如上所述的DDCM迭代，并输出$\\Delta r$。\n\n所有物理量必须按其规定单位处理。将每个最终的$\\Delta r$以$\\sqrt{\\mathrm{Pa}}$为单位，表示为一个浮点数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\Delta r_1,\\Delta r_2,\\Delta r_3]$），不含任何额外文本。\n\n使用以下测试套件，其中包括一个一般情况、一个零载荷边界情况以及一个残差可能增加的情况：\n\n- 测试用例1（一般情况）：\n    - 几何形状：$L_1 = 1.0$ $\\mathrm{m}$，$L_2 = 1.5$ $\\mathrm{m}$。\n    - 面积：$A_1 = 1.0$ $\\mathrm{m}^2$，$A_2 = 0.8$ $\\mathrm{m}^2$。\n    - 模量：$E_1 = 2.10 \\times 10^{11}$ $\\mathrm{Pa}$，$E_2 = 7.0 \\times 10^{10}$ $\\mathrm{Pa}$。\n    - 材料数据集：\n        $D_1 = \\{(-10^{-3},-2.10\\times 10^8),(-5\\times10^{-4},-1.05\\times10^8),(0,0),(5\\times10^{-4},1.05\\times10^8),(10^{-3},2.10\\times10^8)\\}$，\n        $D_2 = \\{(-1.2\\times10^{-3},-8.4\\times10^7),(-6\\times10^{-4},-4.2\\times10^7),(0,0),(6\\times10^{-4},4.2\\times10^7),(1.2\\times10^{-3},8.4\\times10^7)\\}$。\n    - 载荷：$P = 5.0 \\times 10^6$ $\\mathrm{N}$。\n    - 初始猜测：$(\\varepsilon_1^0,\\sigma_1^0) = (-8\\times10^{-4}, P/A_1)$，$(\\varepsilon_2^0,\\sigma_2^0) = (9\\times10^{-4}, P/A_2)$。\n\n- 测试用例2（零载荷边界情况）：\n    - 几何形状：$L_1 = 2.0$ $\\mathrm{m}$，$L_2 = 2.0$ $\\mathrm{m}$。\n    - 面积：$A_1 = 1.0$ $\\mathrm{m}^2$，$A_2 = 1.0$ $\\mathrm{m}^2$。\n    - 模量：$E_1 = 1.0 \\times 10^{11}$ $\\mathrm{Pa}$，$E_2 = 1.0 \\times 10^{11}$ $\\mathrm{Pa}$。\n    - 材料数据集：\n        $D_1 = D_2 = \\{(-8\\times10^{-4},-8\\times10^7),(-4\\times10^{-4},-4\\times10^7),(0,0),(4\\times10^{-4},4\\times10^7),(8\\times10^{-4},8\\times10^7)\\}$。\n    - 载荷：$P = 0$ $\\mathrm{N}$。\n    - 初始猜测：$(\\varepsilon_1^0,\\sigma_1^0) = (1\\times10^{-5}, 0)$，$(\\varepsilon_2^0,\\sigma_2^0) = (-1\\times10^{-5}, 0)$。\n\n- 测试用例3（残差可能增加的边缘情况）：\n    - 几何形状：$L_1 = 1.0$ $\\mathrm{m}$，$L_2 = 1.0$ $\\mathrm{m}$。\n    - 面积：$A_1 = 1.0$ $\\mathrm{m}^2$，$A_2 = 2.0$ $\\mathrm{m}^2$。\n    - 模量：$E_1 = 1.5 \\times 10^{11}$ $\\mathrm{Pa}$，$E_2 = 5.0 \\times 10^{10}$ $\\mathrm{Pa}$。\n    - 材料数据集：\n        $D_1 = D_2 = \\{(-10^{-3},-1.5\\times10^8),(-5\\times10^{-4},-7.5\\times10^7),(0,0),(5\\times10^{-4},7.5\\times10^7),(10^{-3},1.5\\times10^8)\\}$。\n    - 载荷：$P = 1.0 \\times 10^6$ $\\mathrm{N}$。\n    - 初始猜测：$(\\varepsilon_1^0,\\sigma_1^0) = (0, 0)$，$(\\varepsilon_2^0,\\sigma_2^0) = (0, 0)$。", "solution": "用户要求针对一维双单元桁架结构，实现数据驱动计算力学（DDCM）算法的单次迭代，并计算由此产生的度量残差范数减小量 $\\Delta r$。\n\n首先，对问题陈述进行验证。该问题设定在计算固体力学（工程学的一个子领域）的背景下。对于一维桁架模型，静力平衡和运动协调的物理原理陈述正确。数据驱动方法的数学框架，包括能量范数度量、D-投影（最近邻搜索）和E-投影（约束最小化），定义明确。所有测试用例的参数、数据集和初始条件都已提供，且单位在物理上是一致的（国际单位制）。该问题是自包含的，有科学依据且适定的。任务是实现指定的算法，该算法具有唯一且有意義的解。因此，该问题被视为有效。\n\n解决方案首先分析DDCM迭代的两个主要步骤：D-投影和E-投影。\n\n**1. D-投影（材料投影）**\n\nD-投影步骤要求在材料数据集 $D_e$ 中找到距离给定状态 $(\\varepsilon_e, \\sigma_e)$ 最近的数据点 $(\\hat{\\varepsilon}_e, \\hat{\\sigma}_e)$。距离由度量 $d_e^2 = E_e (\\varepsilon_e - \\varepsilon_{e,j})^2 + \\frac{1}{E_e} (\\sigma_e - \\sigma_{e,j})^2$ 衡量。由于每个数据集 $D_e$ 是一个有限的点集，这个投影是通过计算 $(\\varepsilon_e, \\sigma_e)$ 到 $D_e$ 中每个点 $(\\varepsilon_{e,j}, \\sigma_{e,j})$ 的距离，并选择产生最小距离的那个点来找到的。对于单元 `$e$`，这个最小距离的平方值记为 $d_{e, \\min}^2$。\n\n**2. E-投影（平衡/协调投影）**\n\nE-投影步骤在满足协调和平衡约束的条件下，找到一个新状态 $\\{(\\varepsilon_e^1, \\sigma_e^1)\\}_{e=1}^2$，该状态使得到上一步D-投影数据的平方距离之和最小。最小化问题是：\n$$\n\\min_{u_2,u_3,\\sigma_1,\\sigma_2} \\sum_{e=1}^2 \\left[ E_e \\left(\\varepsilon_e(u_2,u_3) - \\hat{\\varepsilon}_e^0\\right)^2 + \\frac{1}{E_e} \\left(\\sigma_e - \\hat{\\sigma}_e^0\\right)^2 \\right]\n$$\n约束条件为：\n1. 协调性：$\\varepsilon_1 = u_2/L_1$（因为 $u_1=0$），$\\varepsilon_2 = (u_3-u_2)/L_2$。\n2. 平衡性：$\\sigma_2 = P/A_2$，$\\sigma_1 = P/A_1$。\n\n平衡约束完全确定了新状态下的应力 $\\sigma_1^1 = P/A_1$ 和 $\\sigma_2^1 = P/A_2$，而与其他变量无关。将这些代入目标函数，与应力相关的项 $\\sum_{e=1}^2 \\frac{1}{E_e} (\\sigma_e^1 - \\hat{\\sigma}_e^0)^2$ 相对于最小化变量 $u_2$ 和 $u_3$ 成为常数。因此，问题简化为最小化与应变相关的项：\n$$\n\\min_{u_2,u_3} F(u_2, u_3) = E_1 \\left(\\frac{u_2}{L_1} - \\hat{\\varepsilon}_1^0\\right)^2 + E_2 \\left(\\frac{u_3 - u_2}{L_2} - \\hat{\\varepsilon}_2^0\\right)^2\n$$\n这是一个关于 $u_2$ 和 $u_3$ 的二次函数的无约束最小化问题。通过将关于 $u_2$ 和 $u_3$ 的偏导数设为零来找到最小值。\n$$\n\\frac{\\partial F}{\\partial u_3} = 2 E_2 \\left(\\frac{u_3 - u_2}{L_2} - \\hat{\\varepsilon}_2^0\\right) \\frac{1}{L_2} = 0\n$$\n$$\n\\frac{\\partial F}{\\partial u_2} = 2 E_1 \\left(\\frac{u_2}{L_1} - \\hat{\\varepsilon}_1^0\\right) \\frac{1}{L_1} + 2 E_2 \\left(\\frac{u_3 - u_2}{L_2} - \\hat{\\varepsilon}_2^0\\right) \\left(-\\frac{1}{L_2}\\right) = 0\n$$\n从第一个方程，我们得到 $\\frac{u_3 - u_2}{L_2} = \\hat{\\varepsilon}_2^0$。由于 $\\varepsilon_2^1 = (u_3 - u_2)/L_2$，这直接得出 $\\varepsilon_2^1 = \\hat{\\varepsilon}_2^0$。将此结果代入第二个方程，使第二项为零，得到：\n$$\n2 E_1 \\left(\\frac{u_2}{L_1} - \\hat{\\varepsilon}_1^0\\right) \\frac{1}{L_1} = 0 \\implies \\frac{u_2}{L_1} = \\hat{\\varepsilon}_1^0\n$$\n由于 $\\varepsilon_1^1 = u_2/L_1$，这得出 $\\varepsilon_1^1 = \\hat{\\varepsilon}_1^0$。\n因此，E-投影产生的状态 $(\\varepsilon_e^1, \\sigma_e^1)$ 中，应变等于上一步的投影应变，而应力由全局平衡确定：\n$$\n\\varepsilon_1^1 = \\hat{\\varepsilon}_1^0, \\quad \\sigma_1^1 = \\frac{P}{A_1}\n$$\n$$\n\\varepsilon_2^1 = \\hat{\\varepsilon}_2^0, \\quad \\sigma_2^1 = \\frac{P}{A_2}\n$$\n\n**3. 算法实现**\n\n基于以上分析，实现一个分步算法来计算 $\\Delta r = r_0 - r_1$。\n\n- **步骤A：计算 $r_0$**\n    1. 对每个单元 $e=1, 2$，取初始猜测状态 $(\\varepsilon_e^0, \\sigma_e^0)$。请注意，所提供的应力初始猜测可能是符号形式（$P/A_e$），必须首先计算其值。\n    2. 执行D-投影：在材料数据集 $D_e$ 中找到使距离度量 $d_{e,j}^2$ 最小化的点 $(\\hat{\\varepsilon}_e^0, \\hat{\\sigma}_e^0)$。存储此点及相应的最小平方距离 $d_{e,\\min}^2 = E_e(\\varepsilon_e^0 - \\hat{\\varepsilon}_e^0)^2 + \\frac{1}{E_e}(\\sigma_e^0 - \\hat{\\sigma}_e^0)^2$。\n    3. 计算初始全局残差范数：$r_0 = \\sqrt{d_{1,\\min}^2 + d_{2,\\min}^2}$。\n\n- **步骤B：计算 $r_1$**\n    1. 使用最小化的结果确定E-投影后的状态 $\\{(\\varepsilon_e^1, \\sigma_e^1)\\}_{e=1}^2$：\n        - $\\varepsilon_1^1 = \\hat{\\varepsilon}_1^0$，$\\sigma_1^1 = P/A_1$。\n        - $\\varepsilon_2^1 = \\hat{\\varepsilon}_2^0$，$\\sigma_2^1 = P/A_2$。\n    2. 对这个状态执行新的D-投影：对每个单元 $e=1, 2$，在 $D_e$ 中找到最接近 $(\\varepsilon_e^1, \\sigma_e^1)$ 的点 $(\\hat{\\varepsilon}_e^1, \\hat{\\sigma}_e^1)$。存储新的最小平方距离 $d_{e,\\min'}^2 = E_e(\\varepsilon_e^1 - \\hat{\\varepsilon}_e^1)^2 + \\frac{1}{E_e}(\\sigma_e^1 - \\hat{\\sigma}_e^1)^2$。\n    3. 计算新的全局残差范数：$r_1 = \\sqrt{d_{1,\\min'}^2 + d_{2,\\min'}^2}$。\n\n- **步骤C：最终计算**\n    1. 计算度量残差范数的减小量：$\\Delta r = r_0 - r_1$。\n\n此过程应用于所提供的三个测试用例中的每一个。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the DDCM problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1 (general case)\n        {\n            \"L_e\": (1.0, 1.5), \"A_e\": (1.0, 0.8), \"E_e\": (2.10e11, 7.0e10),\n            \"D_e\": (\n                [(-1e-3, -2.10e8), (-5e-4, -1.05e8), (0, 0), (5e-4, 1.05e8), (1e-3, 2.10e8)],\n                [(-1.2e-3, -8.4e7), (-6e-4, -4.2e7), (0, 0), (6e-4, 4.2e7), (1.2e-3, 8.4e7)]\n            ),\n            \"P\": 5.0e6,\n            \"initial_guess_eps\": (-8e-4, 9e-4),\n            \"initial_guess_sig\": (\"P/A1\", \"P/A2\")\n        },\n        # Test Case 2 (zero-load boundary case)\n        {\n            \"L_e\": (2.0, 2.0), \"A_e\": (1.0, 1.0), \"E_e\": (1.0e11, 1.0e11),\n            \"D_e\": (\n                [(-8e-4, -8e7), (-4e-4, -4e7), (0, 0), (4e-4, 4e7), (8e-4, 8e7)],\n                [(-8e-4, -8e7), (-4e-4, -4e7), (0, 0), (4e-4, 4e7), (8e-4, 8e7)]\n            ),\n            \"P\": 0.0,\n            \"initial_guess_eps\": (1e-5, -1e-5),\n            \"initial_guess_sig\": (0.0, 0.0)\n        },\n        # Test Case 3 (edge case with possible residual increase)\n        {\n            \"L_e\": (1.0, 1.0), \"A_e\": (1.0, 2.0), \"E_e\": (1.5e11, 5.0e10),\n            \"D_e\": (\n                [(-1e-3, -1.5e8), (-5e-4, -7.5e7), (0, 0), (5e-4, 7.5e7), (1e-3, 1.5e8)],\n                [(-1e-3, -1.5e8), (-5e-4, -7.5e7), (0, 0), (5e-4, 7.5e7), (1e-3, 1.5e8)]\n            ),\n            \"P\": 1.0e6,\n            \"initial_guess_eps\": (0.0, 0.0),\n            \"initial_guess_sig\": (0.0, 0.0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_r = perform_ddcm_iteration(case)\n        results.append(f\"{delta_r:.10f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef find_closest_data_point(eps, sig, data_set, E):\n    \"\"\"\n    Finds the closest point in a data set to a given (strain, stress) state.\n    \n    Args:\n        eps (float): Current strain.\n        sig (float): Current stress.\n        data_set (list of tuples): The material data set [(eps_j, sig_j), ...].\n        E (float): The Young's modulus for the metric.\n        \n    Returns:\n        tuple: (closest_strain, closest_stress), min_squared_distance\n    \"\"\"\n    min_dist_sq = float('inf')\n    closest_point = None\n    \n    inv_E = 1.0 / E\n    \n    for eps_j, sig_j in data_set:\n        dist_sq = E * (eps - eps_j)**2 + inv_E * (sig - sig_j)**2\n        if dist_sq  min_dist_sq:\n            min_dist_sq = dist_sq\n            closest_point = (eps_j, sig_j)\n            \n    return closest_point, min_dist_sq\n\ndef perform_ddcm_iteration(params):\n    \"\"\"\n    Performs one DDCM iteration and computes the reduction in residual norm.\n    \n    Args:\n        params (dict): A dictionary containing all parameters for the test case.\n        \n    Returns:\n        float: The reduction in the metric residual norm, Delta_r = r_0 - r_1.\n    \"\"\"\n    # Unpack parameters\n    L1, L2 = params[\"L_e\"]\n    A1, A2 = params[\"A_e\"]\n    E1, E2 = params[\"E_e\"]\n    D1, D2 = params[\"D_e\"]\n    P = params[\"P\"]\n    eps1_0, eps2_0 = params[\"initial_guess_eps\"]\n    sig1_0_expr, sig2_0_expr = params[\"initial_guess_sig\"]\n\n    # --- Step A: Calculate r_0 ---\n\n    # 1. Determine initial guess state\n    sig1_0 = P / A1 if sig1_0_expr == \"P/A1\" else float(sig1_0_expr)\n    sig2_0 = P / A2 if sig2_0_expr == \"P/A2\" else float(sig2_0_expr)\n\n    # 2. D-projection of initial guess\n    (eps_hat1_0, sig_hat1_0), d1_sq_0 = find_closest_data_point(eps1_0, sig1_0, D1, E1)\n    (eps_hat2_0, sig_hat2_0), d2_sq_0 = find_closest_data_point(eps2_0, sig2_0, D2, E2)\n    \n    # 3. Calculate initial residual norm r_0\n    r_0 = np.sqrt(d1_sq_0 + d2_sq_0)\n\n    # --- Step B: Calculate r_1 ---\n\n    # 1. E-projection to find the new state (eps^1, sig^1)\n    eps1_1 = eps_hat1_0\n    sig1_1 = P / A1\n    \n    eps2_1 = eps_hat2_0\n    sig2_1 = P / A2\n    \n    # 2. D-projection of the new state\n    (eps_hat1_1, sig_hat1_1), d1_sq_1 = find_closest_data_point(eps1_1, sig1_1, D1, E1)\n    (eps_hat2_1, sig_hat2_1), d2_sq_1 = find_closest_data_point(eps2_1, sig2_1, D2, E2)\n    \n    # 3. Calculate new residual norm r_1\n    r_1 = np.sqrt(d1_sq_1 + d2_sq_1)\n\n    # --- Step C: Final Calculation ---\n    delta_r = r_0 - r_1\n    return delta_r\n\nsolve()\n```", "id": "3557165"}, {"introduction": "在实际的三维分析中，任何本构模型都必须满足一个至关重要的对称性要求：客观性或称物质坐标系无关性（material frame indifference）。该原则确保材料的响应独立于观察者的刚体转动。本练习将展示一种简洁而强大的方法，通过“构造”来保证模型的客观性：在主拉伸（principal stretches）这一不变量空间中学习本构关系，然后利用谱分解（spectral decomposition）重构完整的应力张量。此外，你还将学习如何设计“对抗性旋转”（adversarial rotations）来从数值上验证客观性约束的稳健性[@problem_id:3557115]。", "problem": "要求您实现并验证一个数据驱动的本构模型。该模型通过在主伸长变量中进行训练，并通过谱映射重构应力，从而强制实现材料框架无关性（客观性）。目标是 (i) 使用一个仅依赖于客观量的共享函数形式，学习一个从主伸长到主应力的映射，(ii) 对于任意变形，使用谱分解重构完整的柯西应力张量，以及 (iii) 设计并评估对抗性旋转，以量化所学模型中任何不变性的泄漏。\n\n从以下基本基础开始：\n- 材料框架无关性要求，对于所有正常正交旋转 $Q \\in \\mathbb{R}^{3 \\times 3}$ 且 $\\det(Q) = 1$，柯西应力映射 $\\sigma$ 满足 $\\sigma(QF) = Q \\, \\sigma(F) \\, Q^{\\mathsf{T}}$，其中 $F \\in \\mathbb{R}^{3 \\times 3}$ 为任意变形梯度且 $\\det(F)  0$。\n- 极分解表明 $F = R U$，其中 $R \\in \\mathbb{R}^{3 \\times 3}$ 是一个正常旋转，$U \\in \\mathbb{R}^{3 \\times 3}$ 是右伸长张量，对称正定。\n- 左柯西-格林张量为 $B = F F^{\\mathsf{T}}$，其特征值为 $\\beta_i$，对应的标准正交特征向量定义了主方向。主伸长为 $\\lambda_i = \\sqrt{\\beta_i}$，雅可比行列式为 $J = \\lambda_1 \\lambda_2 \\lambda_3$。\n- 定义基尔霍夫应力 $\\tau = J \\, \\sigma$。对于各向同性弹性材料，$\\tau$ 和 $B$ 可交换并共享特征向量。主基尔霍夫应力 $\\tau_i$ 可以通过各向同性本构关系表示为主伸长 $\\lambda_i$ 和 $J$ 的函数。\n\n使用以下经过充分检验的本构律（在一致的无量纲单位下）来生成监督训练信号和基准真值比较：\n- 对于剪切模量为 $\\mu$、体积模量为 $\\kappa$ 的可压缩 Neo-Hookean 材料，其柯西应力为\n$$\n\\sigma(F) = \\frac{\\mu}{J}\\left(B - I\\right) + \\kappa \\left(J - 1\\right) I,\n$$\n其中 $I$ 是单位张量。因此，主基尔霍夫应力满足\n$$\n\\tau_i = \\mu\\left(\\lambda_i^2 - 1\\right) + \\kappa \\, J \\left(J - 1\\right).\n$$\n\n您的任务：\n1. 设计一个小型数据驱动的本构模型，该模型将主伸长映射到主基尔霍夫应力，同时通过构造强制实现客观性：\n   - 使用输入 $x_i = \\ln(\\lambda_i)$ 和体积耦合变量 $s = \\sum_{j=1}^3 x_j = \\ln(J)$。\n   - 对每个主分量采用一个共享线性模型，其参数在 $i \\in \\{1,2,3\\}$ 之间完全相同，形式如下\n   $$\n   \\widehat{\\tau}_i = w_1 \\, \\exp(2 x_i) + w_2 \\cdot 1 + w_3 \\, \\exp(2 s) + w_4 \\, \\exp(s),\n   $$\n   这确保了对主方向的置换等变处理，并通过 $s$ 耦合了偏量和体积响应。使用从给定本构律中采样的合成训练数据，通过最小二乘法拟合参数矢量 $w \\in \\mathbb{R}^4$。\n2. 对于给定的变形 $F$，按以下步骤重构完整的预测柯西应力张量：\n   - 计算 $B = F F^{\\mathsf{T}}$ 并对其进行谱分解，以恢复主方向和主伸长 $\\lambda_i = \\sqrt{\\beta_i}$，其中 $J = \\lambda_1 \\lambda_2 \\lambda_3$。\n   - 基于主伸长评估学习模型 $\\widehat{\\tau}_i$，并组装预测的基尔霍夫应力张量 $\\widehat{\\tau} = \\sum_{i=1}^3 \\widehat{\\tau}_i \\, v_i \\otimes v_i$，其中 $v_i$ 是 $B$ 的特征向量。\n   - 返回预测的柯西应力 $\\widehat{\\sigma} = \\widehat{\\tau} / J$。\n3. 提出对抗性旋转以评估所学模型的不变性泄漏：\n   - 对于一个固定的伸长张量 $U = \\mathrm{diag}(\\lambda_1,\\lambda_2,\\lambda_3)$ 和一个选定的参考旋转 $R_{\\text{ref}}$，构造 $F_1 = R_{\\text{ref}} U$。\n   - 对于多个随机采样的旋转 $Q_k$（角度以弧度为单位），定义 $F_{2,k} = Q_k F_1$，并计算学习到的应力 $\\widehat{\\sigma}(F_1)$ 和 $\\widehat{\\sigma}(F_{2,k})$。\n   - 将每个 $k$ 的不变性泄漏度量定义为\n   $$\n   \\mathcal{L}_k = \\frac{\\left\\| \\widehat{\\sigma}(F_{2,k}) - Q_k \\, \\widehat{\\sigma}(F_1) \\, Q_k^{\\mathsf{T}} \\right\\|_F}{\\left\\| \\widehat{\\sigma}(F_1) \\right\\|_F + \\epsilon},\n   $$\n   其中 $\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数，$\\epsilon$ 是一个小的正数以避免除以零。报告每个测试用例在对抗性集合上的最大泄漏 $\\max_k \\mathcal{L}_k$。\n\n训练数据协议：\n- 通过从均值为 $0$、标准差为 $0.4$ 的正态分布中抽取 $x_i = \\ln(\\lambda_i)$ 来采样 $N_{\\text{train}} = 256$ 组独立的主伸长三元组，然后设置 $\\lambda_i = \\exp(x_i)$，$J = \\prod_i \\lambda_i$。使用上述 $\\mu = 2.0$ 和 $\\kappa = 10.0$ 的 Neo-Hookean 律计算精确的目标值 $\\tau_i$，并通过对所有主分量进行池化后的最小二乘法来拟合 $w$。\n- 使用固定的随机种子，以确保采样和训练过程的确定性。\n\n对抗性旋转的生成：\n- 通过在单位球面上均匀选择一个随机轴和在 $[0, \\pi)$ 弧度范围内均匀选择一个随机角度，然后通过罗德里格斯公式构造 $Q_k$，以此来采样 $K = 25$ 个随机旋转 $Q_k$。使用确定性种子以使结果可复现。\n\n测试套件：\n- 使用三个具有给定主伸长以及固定的参考旋转轴和角度的测试用例。在所有情况下，参考旋转轴与 $(1,1,1)$ 成比例并被归一化，参考旋转角度为 $\\alpha = 1.234$ 弧度。\n  1. 用例 A（中等程度近乎等体积）：$\\lambda = (1.10, 0.95, 0.96)$。\n  2. 用例 B（大变形各向异性）：$\\lambda = (1.60, 0.70, 1.30)$。\n  3. 用例 C（近简并方向）：$\\lambda = (1.00, 1.00, 1.05)$。\n- 对于每个用例：\n  - 构造 $U = \\mathrm{diag}(\\lambda)$ 和 $F_1 = R_{\\text{ref}} U$。\n  - 使用给定的本构律计算真实柯西应力，并使用学习的模型计算预测柯西应力。报告相对弗罗贝尼乌斯误差\n  $$\n  e = \\frac{\\left\\|\\widehat{\\sigma}(F_1) - \\sigma(F_1)\\right\\|_F}{\\left\\|\\sigma(F_1)\\right\\|_F}.\n  $$\n  - 计算在上述 $K$ 个对抗性旋转下的最大不变性泄漏 $\\max_k \\mathcal{L}_k$。\n\n角度单位说明：\n- 所有角度都必须以弧度为单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个长度为 $6$ 的、用方括号括起来的逗号分隔列表，其结果按以下顺序排列\n  $$\n  [e_A, \\max \\mathcal{L}_A, e_B, \\max \\mathcal{L}_B, e_C, \\max \\mathcal{L}_C],\n  $$\n  其中 $e_{\\cdot}$ 是基础变形 $F_1$ 的相对弗罗贝尼乌斯误差，$\\max \\mathcal{L}_{\\cdot}$ 是每个用例在对抗性旋转下的最大不变性泄漏。输出条目是实数（浮点数），无单位，并且必须以小数形式表示。", "solution": "此问题是有效的。它在科学上基于连续介质力学的原理，问题设定良好，具有清晰和确定性的程序以获得唯一解，并使用客观、正式的语言进行描述。这些任务与数据驱动计算力学领域相关，并涉及模型训练、预测和验证的非平凡实现。\n\n解决方案按规定分为三个主要部分：(1) 训练一个数据驱动的本构模型，(2) 实现一个基于谱分解的应力重构算法，以及 (3) 使用对抗性旋转评估模型的材料框架无关性。\n\n### 第 1 部分：本构模型训练\n\n目标是学习一个从主伸长 $\\lambda_i$ 到主基尔霍夫应力 $\\tau_i$ 的映射。基准真值的关系由剪切模量 $\\mu = 2.0$ 和体积模量 $\\kappa = 10.0$ 的可压缩 Neo-Hookean 模型给出：\n$$\n\\tau_i = \\mu\\left(\\lambda_i^2 - 1\\right) + \\kappa \\, J \\left(J - 1\\right)\n$$\n其中 $J = \\lambda_1 \\lambda_2 \\lambda_3$ 是雅可比行列式。\n\n所提出的数据驱动模型是主基尔霍夫应力 $\\widehat{\\tau}_i$ 的一个线性模型：\n$$\n\\widehat{\\tau}_i = w_1 \\, \\exp(2 x_i) + w_2 \\cdot 1 + w_3 \\, \\exp(2 s) + w_4 \\, \\exp(s)\n$$\n其中 $x_i = \\ln(\\lambda_i)$ 且 $s = \\sum_j x_j = \\ln(J)$。代入这些定义，模型形式变为：\n$$\n\\widehat{\\tau}_i = w_1 \\lambda_i^2 + w_2 + w_3 J^2 + w_4 J\n$$\n这种形式是一个恰当的选择，因为它是真实定律 $\\tau_i = \\mu \\lambda_i^2 - \\mu + \\kappa J^2 - \\kappa J$ 中各项的线性组合。我们期望学习到的权重近似于 $w_1 \\approx \\mu$，$w_2 \\approx -\\mu$，$w_3 \\approx \\kappa$ 和 $w_4 \\approx -\\kappa$。\n\n训练使用一个合成数据集进行。通过首先从正态分布 $\\mathcal{N}(0, 0.4^2)$ 中抽取对数伸长 $x_i$ 来生成 $N_{\\text{train}} = 256$ 个主伸长样本。然后，主伸长为 $\\lambda_i = \\exp(x_i)$。对于每一组 $(\\lambda_1, \\lambda_2, \\lambda_3)$，使用 Neo-Hookean 公式计算目标主应力 $(\\tau_1, \\tau_2, \\tau_3)$。\n\n参数矢量 $w = [w_1, w_2, w_3, w_4]^{\\mathsf{T}}$ 通过求解一个形式为 $A w = b$ 的线性最小二乘问题来确定。来自所有 $N_{\\text{train}}$ 个样本的所有 $3$ 个主方向的数据被汇集在一起，得到 $3 \\times N_{\\text{train}} = 768$ 个数据点。设计矩阵 $A$ 的大小为 $(768, 4)$，目标向量 $b$ 的大小为 $(768, 1)$。对于每个对应于样本 $j$ 和主方向 $i$ 的数据点 $k$，$A$ 和 $b$ 的行结构如下：\n$$\nA_k = [\\lambda_{j,i}^2, \\quad 1, \\quad J_j^2, \\quad J_j], \\quad b_k = \\tau_{j,i}\n$$\n使用 `numpy.linalg.lstsq` 求解该系统以得到 $w$。固定的随机种子确保了训练数据的可复现性，从而也保证了学习到的权重 $w$ 的可复现性。\n\n### 第 2 部分：应力张量重构\n\n学习到的模型作用于主伸长，它们是标量不变量。为了预测任意变形梯度 $F$ 的完整柯西应力张量 $\\widehat{\\sigma}$，我们使用谱重构方法。这个过程内在地强制实现了材料框架无关性。\n\n给定一个变形梯度 $F$ 且 $\\det(F)  0$：\n1.  计算左柯西-格林张量 $B = F F^{\\mathsf{T}}$。$B$ 是对称正定的。\n2.  对 $B$ 进行谱分解，以找到其特征值 $\\beta_i$ 和相应的标准正交特征向量 $v_i$。即 $B = \\sum_{i=1}^3 \\beta_i v_i \\otimes v_i$。\n3.  主伸长是 $B$ 的特征值的平方根：$\\lambda_i = \\sqrt{\\beta_i}$。特征向量 $v_i$ 定义了空间构型中的主伸长方向。特征值被排序以保持一致的顺序，例如 $\\lambda_1 \\le \\lambda_2 \\le \\lambda_3$。\n4.  雅可比行列式计算为 $J = \\lambda_1 \\lambda_2 \\lambda_3$。\n5.  使用学习到的模型 $\\widehat{\\tau}_i(w, \\lambda_1, \\lambda_2, \\lambda_3)$ 来预测主基尔霍夫应力 $\\widehat{\\tau}_i$。\n6.  在 $B$ 的特征向量基中重构完整的基尔霍夫应力张量 $\\widehat{\\tau}$：\n    $$\n    \\widehat{\\tau} = \\sum_{i=1}^3 \\widehat{\\tau}_i \\, v_i \\otimes v_i\n    $$\n    此操作将主应力与主伸长方向正确对齐。\n7.  最后，通过缩放基尔霍夫应力获得预测的柯西应力张量：$\\widehat{\\sigma} = \\widehat{\\tau} / J$。\n\n### 第 3 部分：框架无关性的对抗性验证\n\n材料框架无关性要求本构律独立于观察者的刚体旋转。在数学上，对于任何正常正交张量 $Q$，应力响应必须满足 $\\sigma(QF) = Q \\sigma(F) Q^{\\mathsf{T}}$。\n\n谱重构方法的设计旨在通过构造满足此属性。为了在数值上验证这一点并量化由于浮点不精确性造成的任何“泄漏”，我们采用对抗性测试。\n1.  由纯拉伸 $U = \\mathrm{diag}(\\lambda_1, \\lambda_2, \\lambda_3)$ 和参考旋转 $R_{\\text{ref}}$ 创建一个基础变形 $F_1 = R_{\\text{ref}} U$。\n2.  生成一组 $K=25$ 个随机的“对抗性”旋转 $Q_k$。\n3.  对于每个 $Q_k$，形成一个新的变形 $F_{2,k} = Q_k F_1$。这代表了从一个旋转的框架观察到的相同物理变形 $F_1$。\n4.  模型预测两种变形的应力：$\\widehat{\\sigma}(F_1)$ 和 $\\widehat{\\sigma}(F_{2,k})$。\n5.  如果模型是完全客观的，它必须满足 $\\widehat{\\sigma}(F_{2,k}) = Q_k \\widehat{\\sigma}(F_1) Q_k^{\\mathsf{T}}$。\n6.  不变性泄漏使用以下度量进行量化：\n    $$\n    \\mathcal{L}_k = \\frac{\\left\\| \\widehat{\\sigma}(F_{2,k}) - Q_k \\, \\widehat{\\sigma}(F_1) \\, Q_k^{\\mathsf{T}} \\right\\|_F}{\\left\\| \\widehat{\\sigma}(F_1) \\right\\|_F + \\epsilon}\n    $$\n    其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数，$\\epsilon$ 是一个小的正则化常数。对于我们的模型，$\\mathcal{L}_k$ 的任何非零值都归因于一系列矩阵运算（特别是 `eigh`）中的数值浮点误差。测试报告了在对抗性旋转集合上的最大泄漏 $\\max_k \\mathcal{L}_k$。\n\n该实现对所有随机数生成使用固定的种子，以确保训练、对抗性旋转生成和最终结果的完全可复现性。对于测试用例，还计算了模型预测 $\\widehat{\\sigma}(F_1)$ 与基准真值 $\\sigma(F_1)$ 之间的相对误差，以评估所学线性模型的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rodrigues_rotation(axis, angle):\n    \"\"\"\n    Computes the rotation matrix for a given axis and angle using Rodrigues' formula.\n    \"\"\"\n    axis = np.asarray(axis, dtype=float)\n    axis /= np.linalg.norm(axis)\n    \n    K = np.array([[0, -axis[2], axis[1]],\n                  [axis[2], 0, -axis[0]],\n                  [-axis[1], axis[0], 0]])\n    \n    R = np.identity(3) + np.sin(angle) * K + (1 - np.cos(angle)) * (K @ K)\n    return R\n\ndef solve():\n    \"\"\"\n    Main function to perform model training, evaluation, and reporting.\n    \"\"\"\n    # --- Constants and Hyperparameters ---\n    MU = 2.0\n    KAPPA = 10.0\n    N_TRAIN = 256\n    K_ADV = 25\n    EPSILON = 1e-15\n    TRAIN_SEED = 42\n    ADV_SEED = 123\n\n    # --- 1. Training Phase ---\n    rng_train = np.random.default_rng(TRAIN_SEED)\n    # Generate logarithmic stretches x_i = ln(lambda_i)\n    x_train = rng_train.normal(loc=0.0, scale=0.4, size=(N_TRAIN, 3))\n    lambdas_train = np.exp(x_train)\n    J_train = np.prod(lambdas_train, axis=1)\n\n    # Compute ground-truth Kirchhoff stresses (targets)\n    # tau_i = mu*(lambda_i^2 - 1) + kappa*J*(J-1)\n    tau_train = MU * (lambdas_train**2 - 1) + KAPPA * J_train[:, np.newaxis] * (J_train[:, np.newaxis] - 1)\n    \n    # Assemble design matrix A and target vector b for least squares Aw=b\n    # Model: tau_hat_i = w1*lambda_i^2 + w2*1 + w3*J^2 + w4*J\n    # All 3*N_TRAIN components are pooled together\n    b = tau_train.flatten()\n    A = np.zeros((3 * N_TRAIN, 4))\n    A[:, 0] = (lambdas_train**2).flatten()\n    A[:, 1] = 1.0\n    A[:, 2] = (np.repeat(J_train, 3)**2)\n    A[:, 3] = np.repeat(J_train, 3)\n\n    # Solve for the weight vector w\n    w, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n\n    # --- Define Prediction and Ground Truth Functions ---\n    def predict_sigma_hat(F, w_fit):\n        \"\"\"Predicts Cauchy stress using the learned spectral model.\"\"\"\n        if np.linalg.det(F) = 0:\n            return np.full((3, 3), np.nan) # Invalid deformation\n        B = F @ F.T\n        # eigh returns sorted eigenvalues and corresponding eigenvectors\n        betas, V = np.linalg.eigh(B)\n        \n        # Clamp small negative numerical noise before sqrt\n        betas[betas  0] = 0\n        lambdas = np.sqrt(betas)\n        J = np.prod(lambdas)\n        if J  EPSILON: J = EPSILON # Avoid division by zero\n        \n        # Evaluate learned model for principal Kirchhoff stresses\n        tau_hat_i = w_fit[0] * lambdas**2 + w_fit[1] + w_fit[2] * J**2 + w_fit[3] * J\n        \n        # Reconstruct Kirchhoff stress tensor\n        tau_hat = V @ np.diag(tau_hat_i) @ V.T\n        \n        # Return Cauchy stress\n        return tau_hat / J\n\n    def true_sigma(F, mu, kappa):\n        \"\"\"Computes Cauchy stress using the true Neo-Hookean law.\"\"\"\n        J = np.linalg.det(F)\n        if J = 0:\n            return np.full((3, 3), np.nan)\n        B = F @ F.T\n        I = np.identity(3)\n        return (mu/J) * (B - I) + kappa * (J - 1) * I\n\n    # --- 2. Test Suite Execution ---\n    results = []\n    test_cases = [\n        np.array([1.10, 0.95, 0.96]),\n        np.array([1.60, 0.70, 1.30]),\n        np.array([1.00, 1.00, 1.05])\n    ]\n\n    # Reference rotation for base deformation\n    axis_ref = np.array([1.0, 1.0, 1.0])\n    angle_ref = 1.234\n    R_ref = rodrigues_rotation(axis_ref, angle_ref)\n    \n    rng_adv = np.random.default_rng(ADV_SEED)\n\n    for lambdas_test in test_cases:\n        # --- Base Deformation Analysis ---\n        U = np.diag(lambdas_test)\n        F1 = R_ref @ U\n        \n        sigma_hat_1 = predict_sigma_hat(F1, w)\n        sigma_true_1 = true_sigma(F1, MU, KAPPA)\n\n        # Compute relative Frobenius error\n        error_num = np.linalg.norm(sigma_hat_1 - sigma_true_1, 'fro')\n        error_den = np.linalg.norm(sigma_true_1, 'fro')\n        relative_error = error_num / error_den if error_den > EPSILON else 0.0\n        results.append(relative_error)\n\n        # --- Adversarial Analysis for Invariance Leakage ---\n        max_leakage = 0.0\n        den_L = np.linalg.norm(sigma_hat_1, 'fro') + EPSILON\n\n        for _ in range(K_ADV):\n            # Generate random rotation as per problem specification\n            axis_adv = rng_adv.normal(size=3)\n            norm_axis = np.linalg.norm(axis_adv)\n            if norm_axis  EPSILON:\n                axis_adv = np.array([1.0, 0.0, 0.0]) # fallback for zero vector\n            else:\n                axis_adv /= norm_axis\n\n            angle_adv = rng_adv.uniform(0, np.pi)\n            Qk = rodrigues_rotation(axis_adv, angle_adv)\n            \n            F2k = Qk @ F1\n            sigma_hat_2k = predict_sigma_hat(F2k, w)\n            sigma_transformed = Qk @ sigma_hat_1 @ Qk.T\n            \n            num_L = np.linalg.norm(sigma_hat_2k - sigma_transformed, 'fro')\n            Lk = num_L / den_L\n            \n            if Lk > max_leakage:\n                max_leakage = Lk\n        \n        results.append(max_leakage)\n\n    # --- 3. Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3557115"}]}