{"hands_on_practices": [{"introduction": "本练习将为您提供最常用的预条件迭代方法之一的基础实践经验。您将亲手实现预条件共轭梯度（PCG）算法的核心组件，包括为一个源于有限差分法的矩阵构建不完全 Cholesky（IC(0)）预条件子。这项实践对于揭开 PCG 内部工作的神秘面纱，以及理解预条件子在每次迭代中如何被构建和应用，具有不可估量的价值。[@problem_id:3576531]", "problem": "考虑一个线性系统，该系统源于计算固体力学，由二维网格上的离散泊松算子与齐次狄利克雷边界条件产生。该离散问题是对称正定的，因为它是在有限维子空间上最小化二次势能的结果。设 $n$ 表示每个坐标方向上的内部点数，$N = n^2$ 表示总自由度数。使用 $n = 4$，因此 $N = 16$。采用字典序（行主序）排序：对于网格索引 $(i,j)$（其中 $i \\in \\{0,1,2,3\\}$ 且 $j \\in \\{0,1,2,3\\}$），映射到向量索引 $k = j \\cdot n + i$。组装与负拉普拉斯算子的 $5$-点模板对应的 $N \\times N$ 刚度矩阵 $A$，不进行网格尺寸缩放。也就是说，对于每个内部节点，离散算子为该节点值的 $4$ 倍减去其在 $\\pm x$ 和 $\\pm y$ 方向上直接相邻节点的值（若这些相邻节点存在）。具体而言，对所有 $k$，设置 $A_{k,k} = 4$；对网格图中的每一对相邻节点，将对应的非对角线元素设置为 $-1$；所有其他元素均为 $0$。该矩阵 $A$ 是对称正定的。\n\n定义零填充不完全 Cholesky 预条件子，记作 $\\mathrm{IC}(0)$，按自然排序计算，如下所示。寻求一个下三角矩阵 $L$，使得 $L L^\\top \\approx A$，并满足约束条件：对于每个 $i > j$，元素 $L_{i,j}$ 非零当且仅当 $A_{i,j} \\neq 0$，且对所有 $i$ 都有 $L_{i,i} > 0$。$L$ 因子通过精确 Cholesky 分解得到的递推公式计算，同时丢弃所有不在 $A$ 的下三角稀疏模式中出现的填充元素：\n- 对于 $i = 0,1,\\dots,N-1$ 和每个 $j < i$ 且 $A_{i,j} \\neq 0$，\n$$\nL_{i,j} = \\frac{1}{L_{j,j}} \\left(A_{i,j} - \\sum_{k=0}^{j-1} \\mathbf{1}_{A_{i,k} \\neq 0} \\, \\mathbf{1}_{A_{j,k} \\neq 0} \\, L_{i,k} L_{j,k}\\right),\n$$\n对角线元素为\n$$\nL_{i,i} = \\sqrt{A_{i,i} - \\sum_{k=0}^{i-1} \\mathbf{1}_{A_{i,k} \\neq 0} \\, L_{i,k}^2}.\n$$\n此处 $\\mathbf{1}_{\\cdot}$ 表示指示函数。\n\n考虑将预条件共轭梯度（PCG）法应用于 $A \\mathbf{x} = \\mathbf{b}$，其中预条件子为 $M = L L^\\top$，初始猜测值为 $\\mathbf{x}_0 = \\mathbf{0}$。一步PCG的定义如下：\n- 残差：$\\mathbf{r}_0 = \\mathbf{b} - A \\mathbf{x}_0 = \\mathbf{b}$。\n- 预条件残差：求解 $M \\mathbf{z}_0 = \\mathbf{r}_0$ 得到 $\\mathbf{z}_0$，使用 $L$ 进行前向代入，然后使用 $L^\\top$ 进行后向代入。\n- 搜索方向：$\\mathbf{p}_0 = \\mathbf{z}_0$。\n- 步长：\n$$\n\\alpha_0 = \\frac{\\mathbf{r}_0^\\top \\mathbf{z}_0}{\\mathbf{p}_0^\\top A \\mathbf{p}_0}.\n$$\n- 更新后的迭代值：$\\mathbf{x}_1 = \\mathbf{x}_0 + \\alpha_0 \\mathbf{p}_0$。\n- 更新后的残差：$\\mathbf{r}_1 = \\mathbf{r}_0 - \\alpha_0 A \\mathbf{p}_0$。\n- 更新后的预条件残差：求解 $M \\mathbf{z}_1 = \\mathbf{r}_1$ 得到 $\\mathbf{z}_1$。\n\n您的任务是，对于以下测试套件中的每个右端向量 $\\mathbf{b}$，计算一次PCG迭代后预条件残差范数的比值，即 $||\\mathbf{z}_1||_2 / ||\\mathbf{z}_0||_2$。在所有情况下，均使用上述的 $A$ 和 $\\mathrm{IC}(0)$ 以及初始猜测值 $\\mathbf{x}_0 = \\mathbf{0}$。无需物理单位。三角函数定义中出现的所有角度均以弧度为单位。\n\n测试套件（其中 $n=4, N=16$，索引映射为 $k = j \\cdot n + i$）：\n- 案例 A（一般行为）：$\\mathbf{b}^{(A)}$ 是 $\\mathbb{R}^{16}$ 中的全1向量，即对于所有 $k \\in \\{0,1,\\dots,15\\}$，$b^{(A)}_k = 1$。\n- 案例 B（局部载荷）：$\\mathbf{b}^{(B)}$ 是对应于 $(i,j) = (1,1)$ 的索引处的单位向量，即当 $k = 5$ 时 $b^{(B)}_k = 1$，否则 $b^{(B)}_k = 0$。\n- 案例 C（谐波载荷）：$\\mathbf{b}^{(C)}$ 按点定义为\n$$\nb^{(C)}_{j \\cdot n + i} = \\sin\\!\\left(\\pi \\frac{i+1}{n+1}\\right)\\, \\sin\\!\\left(2\\pi \\frac{j+1}{n+1}\\right),\n$$\n对于 $i,j \\in \\{0,1,2,3\\}$。\n- 案例 D（确定性振荡序列）：$\\mathbf{b}^{(D)}$ 的元素为\n$$\nb^{(D)}_{k} = \\sin\\!\\left(\\frac{k+1}{3}\\right) + \\frac{1}{2}\\cos\\!\\left(\\frac{k+1}{5}\\right),\n$$\n对于 $k \\in \\{0,1,2,\\dots,15\\}$。\n\n您的程序必须：\n- 完全按照规定构造 $A$（对角线元素为 $4$，最近邻非对角线元素为 $-1$，无 $1/h^2$ 缩放）。\n- 使用给定的公式，按自然排序计算 $\\mathrm{IC}(0)$ 预条件子 $L$。\n- 对于每个案例，从 $\\mathbf{x}_0 = \\mathbf{0}$ 开始执行恰好一次 PCG 迭代，并计算比值 $||\\mathbf{z}_1||_2 / ||\\mathbf{z}_0||_2$。\n- 将每个比值四舍五入到 $12$ 位小数。\n\n最终输出格式：\n- 生成单行输出，其中包含案例 A、B、C 和 D 的四个四舍五入后的比值，按此顺序排列，形式为方括号括起来的逗号分隔列表，例如 $\\texttt{[r\\_A,r\\_B,r\\_C,r\\_D]}$，其中每个 $r_{\\cdot}$ 是小数点后恰有 $12$ 位的十进制数。", "solution": "用户提供了一个在数值线性代数领域中定义明确的计算问题，具体涉及求解由偏微分方程离散化产生的方程组的迭代求解器。在给出解决方案之前，需要对问题的正确性和可解性进行验证。\n\n### 问题验证\n\n**步骤1：提取的已知条件**\n\n-   **问题领域**：计算固体力学，二维网格上的离散泊松算子与齐次狄利克雷边界条件。得到的线性系统是对称正定的（SPD）。\n-   **网格与系统规模**：每个方向 $n=4$ 个内部点，总计 $N = n^2 = 16$ 个自由度。\n-   **节点索引**：字典序（行主序）排序：对于网格索引 $i, j \\in \\{0, 1, 2, 3\\}$，$k = j \\cdot n + i$。\n-   **刚度矩阵 $A$ ($16 \\times 16$)**：\n    -   对所有 $k$，$A_{k,k} = 4$。\n    -   若节点 $k$ 和 $m$ 在网格中是直接相邻的，则 $A_{k,m} = -1$。\n    -   所有其他元素均为 $0$。\n-   **预条件子**：零填充不完全 Cholesky 分解，$\\mathrm{IC}(0)$，由 $M = LL^\\top$ 给出。下三角因子 $L$ 必须满足：\n    -   稀疏模式：对于 $i > j$，$L_{i,j} \\neq 0$ 当且仅当 $A_{i,j} \\neq 0$。\n    -   非对角线计算 ($i > j, A_{i,j} \\neq 0$)：$L_{i,j} = \\frac{1}{L_{j,j}} \\left(A_{i,j} - \\sum_{k=0}^{j-1} \\mathbf{1}_{A_{i,k} \\neq 0} \\, \\mathbf{1}_{A_{j,k} \\neq 0} \\, L_{i,k} L_{j,k}\\right)$。\n    -   对角线计算：$L_{i,i} = \\sqrt{A_{i,i} - \\sum_{k=0}^{i-1} \\mathbf{1}_{A_{i,k} \\neq 0} \\, L_{i,k}^2}$。\n-   **求解器**：对 $A \\mathbf{x} = \\mathbf{b}$ 进行一次预条件共轭梯度（PCG）法迭代，从 $\\mathbf{x}_0 = \\mathbf{0}$ 开始。\n-   **PCG分步定义**：\n    1.  $\\mathbf{r}_0 = \\mathbf{b} - A \\mathbf{x}_0 = \\mathbf{b}$。\n    2.  求解 $M \\mathbf{z}_0 = \\mathbf{r}_0$ 得到 $\\mathbf{z}_0$（通过对 $L, L^\\top$ 进行前向和后向代入）。\n    3.  $\\mathbf{p}_0 = \\mathbf{z}_0$。\n    4.  $\\alpha_0 = (\\mathbf{r}_0^\\top \\mathbf{z}_0) / (\\mathbf{p}_0^\\top A \\mathbf{p}_0)$。\n    5.  $\\mathbf{x}_1 = \\mathbf{x}_0 + \\alpha_0 \\mathbf{p}_0$。\n    6.  $\\mathbf{r}_1 = \\mathbf{r}_0 - \\alpha_0 A \\mathbf{p}_0$。\n    7.  求解 $M \\mathbf{z}_1 = \\mathbf{r}_1$ 得到 $\\mathbf{z}_1$。\n-   **目标**：计算预条件残差范数的比值 $||\\mathbf{z}_1||_2 / ||\\mathbf{z}_0||_2$。\n-   **右端向量 $\\mathbf{b}$ 的测试套件**：\n    -   **案例 A**：对所有 $k$，$b^{(A)}_k = 1$。\n    -   **案例 B**：$b^{(B)}_k = \\delta_{k,5}$，其中 $k=5$ 对应网格点 $(i,j)=(1,1)$。\n    -   **案例 C**：$b^{(C)}_{j \\cdot 4 + i} = \\sin(\\pi \\frac{i+1}{5}) \\sin(2\\pi \\frac{j+1}{5})$。\n    -   **案例 D**：$b^{(D)}_k = \\sin((k+1)/3) + 0.5 \\cos((k+1)/5)$。\n-   **输出要求**：单行输出，包含四个比率（对应案例 A, B, C, D）的列表，每个比率四舍五入到12位小数。\n\n**步骤2：对提取的已知条件进行验证**\n\n-   **科学基础**：该问题在根本上是合理的。它涉及使用标准的、成熟的方法（有限差分、PCG、IC(0)预处理）对离散化的椭圆偏微分方程进行数值求解。这些技术是计算科学与工程的基石。\n-   **适定性**：该问题是适定的。对应于具有狄利克雷条件的规则网格上的5点离散拉普拉斯算子的矩阵 $A$ 是一个对称的、弱链对角占优的M-矩阵。对于此类矩阵，一个已知结果是 $\\mathrm{IC}(0)$ 分解存在，并产生一个正定的预条件子 $M$。PCG 算法是确定性的，所有输入都明确定义，确保了唯一的可计算结果。\n-   **客观性**：该问题使用精确、形式化的数学语言陈述。它不含主观论断或解释。\n\n该问题没有任何无效性缺陷。它在科学上是合理的、完全指定的、自洽的并且计算上是可行的。\n\n**步骤3：结论与行动**\n\n该问题是**有效的**。将提供一个解决方案。\n\n### 基于原理的解决方案设计\n\n该解决方案是对问题陈述中提供的算法和定义的直接、系统的实现。该过程分为四个主要阶段：\n\n1.  **刚度矩阵 $A$ 的组装**：\n    根据5点模板规则和字典序索引，构造 $N=16$ 的 $N \\times N$ 矩阵 $A$。对于每个对应网格点 $(i,j)$ 的节点 $k$，对角线元素 $A_{k,k}$ 设置为 $4$。如果节点 $m$ 对应于有效的网格邻居 $(i \\pm 1, j)$ 或 $(i, j \\pm 1)$ 之一，则非对角线元素 $A_{k,m}$ 设置为 $-1$。所有其他元素均为零。这将产生一个稀疏、对称、块三对角矩阵。\n\n2.  **IC(0) 预条件子因子 $L$ 的计算**：\n    下三角矩阵 $L$ 从 $i=0$ 到 $N-1$ 逐行计算。一个关键的洞见简化了非对角元素 $L_{i,j}$ 的计算。公式为：\n    $$L_{i,j} = \\frac{1}{L_{j,j}} \\left(A_{i,j} - \\sum_{k=0}^{j-1} \\mathbf{1}_{A_{i,k} \\neq 0} \\, \\mathbf{1}_{A_{j,k} \\neq 0} \\, L_{i,k} L_{j,k}\\right)$$\n    只有当节点 $i$ 和 $j$ 共享一个公共邻居 $k$ 时（其中“邻居”关系由 $A$ 的非零模式定义），求和项才非零。对于矩形网格上的5点模板，其对应的图是二分的，不包含奇数长度的环，特别是没有长度为3的环（三角形）。如果 $A_{i,j} \\neq 0$，则节点 $i$ 和 $j$ 是邻居，不能有共同的邻居。因此，求和项始终为零。这极大地简化了非对角元素的公式：\n    $$L_{i,j} = \\frac{A_{i,j}}{L_{j,j}} \\quad (\\text{对于 } i>j, A_{i,j} \\neq 0)$$\n    对角线元素使用提供的公式计算，其中求和是对当前行中已经计算出的 $L$ 的非零元素进行的：\n    $$L_{i,i} = \\sqrt{A_{i,i} - \\sum_{k=0}^{i-1, A_{i,k} \\neq 0} L_{i,k}^2}$$\n    计算过程通过迭代行 $i=0, \\dots, N-1$ 进行，并且对于每一行，首先计算非零的非对角线元素 $L_{i,j}$ ($j<i$），然后计算对角线元素 $L_{i,i}$。\n\n3.  **PCG 迭代的执行**：\n    对于每个给定的向量 $\\mathbf{b}$，执行问题中定义的一步 PCG。这涉及：\n    -   初始化残差 $\\mathbf{r}_0 = \\mathbf{b}$。\n    -   通过求解 $L\\mathbf{y}=\\mathbf{r}_0$（前向代入）和 $L^\\top\\mathbf{z}_0=\\mathbf{y}$（后向代入）来应用预条件子。\n    -   计算步长 $\\alpha_0$。这需要一次矩阵-向量乘积 $\\mathbf{p}_0^\\top A \\mathbf{p}_0$ 和两次点积。\n    -   更新解和残差。\n    -   再次应用预条件子以获得 $\\mathbf{z}_1$。\n\n4.  **比值的计算与格式化**：\n    计算 $||\\mathbf{z}_1||_2$ 和 $||\\mathbf{z}_0||_2$ 的欧几里得范数，求其比值，并将结果四舍五入到12位小数。为所有四个案例收集这些比值，并按要求格式化为单个字符串。\n一个健壮的实现将使用数值库（如 NumPy）进行向量和矩阵操作。所有计算都应使用双精度浮点数以确保准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef create_A_matrix(n, N):\n    \"\"\"\n    Assembles the stiffness matrix A for the 2D Poisson problem.\n    \"\"\"\n    A = np.zeros((N, N), dtype=float)\n    for k in range(N):\n        A[k, k] = 4.0\n        i, j = k % n, k // n\n        # Neighbor to the left\n        if i > 0:\n            A[k, k - 1] = -1.0\n        # Neighbor to the right\n        if i  n - 1:\n            A[k, k + 1] = -1.0\n        # Neighbor above\n        if j > 0:\n            A[k, k - n] = -1.0\n        # Neighbor below\n        if j  n - 1:\n            A[k, k + n] = -1.0\n    return A\n\ndef compute_ic0_factor(A, N):\n    \"\"\"\n    Computes the Incomplete Cholesky factorization with zero fill-in (IC(0)).\n    \"\"\"\n    L = np.zeros((N, N), dtype=float)\n    for i in range(N):\n        # Calculate off-diagonal values in row i first\n        for j in range(i):\n            if A[i, j] != 0:\n                # The summation term in the problem's formula for L_ij is zero\n                # for a 5-point stencil grid graph, as adjacent nodes (where A_ij != 0)\n                # do not share a common neighbor.\n                sum_term = 0.0\n                L[i, j] = (A[i, j] - sum_term) / L[j, j]\n        \n        # Calculate diagonal value for row i\n        sum_diag_sq = 0.0\n        for k in range(i):\n            if A[i, k] != 0:\n                sum_diag_sq += L[i,k]**2\n        \n        val_under_sqrt = A[i, i] - sum_diag_sq\n        L[i, i] = np.sqrt(val_under_sqrt)\n    return L\n\ndef solve_forward_sub(L, b):\n    \"\"\"\n    Solves the lower triangular system Lx = b using forward substitution.\n    \"\"\"\n    n = L.shape[0]\n    x = np.zeros(n)\n    for i in range(n):\n        s = np.dot(L[i, :i], x[:i])\n        x[i] = (b[i] - s) / L[i, i]\n    return x\n\ndef solve_backward_sub(Lt, b):\n    \"\"\"\n    Solves the upper triangular system L^T x = b using backward substitution.\n    \"\"\"\n    n = Lt.shape[0]\n    x = np.zeros(n)\n    for i in range(n - 1, -1, -1):\n        s = np.dot(Lt[i, i + 1:], x[i + 1:])\n        x[i] = (b[i] - s) / Lt[i, i]\n    return x\n\ndef solve_preconditioner(L, r):\n    \"\"\"\n    Solves the preconditioner system Mz = r, where M = LL^T.\n    \"\"\"\n    # Step 1: Solve Ly = r for y (forward substitution)\n    y = solve_forward_sub(L, r)\n    # Step 2: Solve L^T z = y for z (backward substitution)\n    z = solve_backward_sub(L.T, y)\n    return z\n\ndef run_pcg_one_step_and_get_ratio(A, L, b):\n    \"\"\"\n    Performs one PCG iteration and computes the ratio of preconditioned residual norms.\n    \"\"\"\n    N = A.shape[0]\n    \n    # Initial guess x_0 = 0\n    x0 = np.zeros(N)\n    \n    # r_0 = b - A x_0 = b\n    r0 = b\n    \n    # Solve M z_0 = r_0\n    z0 = solve_preconditioner(L, r0)\n    \n    # p_0 = z_0\n    p0 = z0\n    \n    # alpha_0 = (r_0^T z_0) / (p_0^T A p_0)\n    Ap0 = A @ p0\n    alpha0 = np.dot(r0, z0) / np.dot(p0, Ap0)\n    \n    # r_1 = r_0 - alpha_0 A p_0\n    r1 = r0 - alpha0 * Ap0\n    \n    # Solve M z_1 = r_1\n    z1 = solve_preconditioner(L, r1)\n    \n    # Compute the ratio ||z_1||_2 / ||z_0||_2\n    norm_z0 = np.linalg.norm(z0)\n    norm_z1 = np.linalg.norm(z1)\n    \n    if norm_z0 == 0:\n        return 0.0\n\n    return norm_z1 / norm_z0\n\ndef solve():\n    # Define problem parameters\n    n = 4\n    N = n**2\n\n    # Assemble the stiffness matrix A\n    A = create_A_matrix(n, N)\n    \n    # Compute the IC(0) preconditioner factor L\n    L = compute_ic0_factor(A, N)\n\n    # Define the test cases (right-hand side vectors b)\n    # Case A: All-ones vector\n    b_A = np.ones(N)\n    \n    # Case B: Localized load at (i=1, j=1) -> k = 1*4+1 = 5\n    b_B = np.zeros(N)\n    b_B[n * 1 + 1] = 1.0\n    \n    # Case C: Harmonic load\n    b_C = np.zeros(N)\n    for j in range(n):\n        for i in range(n):\n            k = j * n + i\n            b_C[k] = np.sin(np.pi * (i + 1) / (n + 1)) * \\\n                     np.sin(2 * np.pi * (j + 1) / (n + 1))\n                     \n    # Case D: Deterministic oscillatory sequence\n    k_vals = np.arange(N)\n    b_D = np.sin((k_vals + 1) / 3.0) + 0.5 * np.cos((k_vals + 1) / 5.0)\n    \n    test_cases = [b_A, b_B, b_C, b_D]\n\n    # Calculate the ratio for each test case\n    results = []\n    for b in test_cases:\n        ratio = run_pcg_one_step_and_get_ratio(A, L, b)\n        results.append(ratio)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "3576531"}, {"introduction": "诸如共轭梯度（CG）法等迭代求解器的效率，在很大程度上取决于系统矩阵的谱特性，特别是其条件数。本实践通过一个线性弹性的具体例子来探讨这一基本关系，您将研究添加质量正则化项如何影响 CG 方法的收敛速度。通过数值实验观察迭代次数的减少，您将直观地理解如何通过修改矩阵以改善其条件数，并将其作为一种加速求解的强大策略。[@problem_id:3576538]", "problem": "使用带有线性形函数的有限元法（FEM）为杆构建一个准静态一维线性弹性模型。设杆具有无量纲参数：杨氏模量 $E=1$、横截面积 $A=1$、质量密度 $\\rho=1$ 和长度 $L=1$。将杆离散为 $n_e$ 个大小为 $h=L/n_e$ 的等长线性单元，节点索引从 $0$ 到 $n_e$。在节点 $0$ 施加狄利克雷边界条件，使得位移 $u(0)=0$。通过组装其一致节点荷载贡献，沿杆施加一个均匀的无量纲体力 $q=1$。\n\n其基本依据是小应变下的一维准静态线性动量平衡，其强形式由以下平衡方程给出：\n$$\n\\frac{d}{dx}\\left( E A \\frac{du}{dx} \\right) + q = 0.\n$$\n在采用线性形函数的标准伽辽金有限元离散化中，单元刚度矩阵和单元一致质量矩阵为：\n$$\n\\mathbf{k}_e = \\frac{E A}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}, \\quad\n\\mathbf{m}_e = \\frac{\\rho A h}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix},\n$$\n在均匀体力 $q$ 作用下，单元一致节点荷载向量为：\n$$\n\\mathbf{f}_e = \\frac{q A h}{2} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}.\n$$\n在组装并施加节点 $0$ 的狄利克雷边界条件后，对于自由度，全局刚度矩阵 $\\mathbf{K}$ 和全局质量矩阵 $\\mathbf{M}$ 是对称正定（SPD）的。考虑用一个无量纲质量正则化项 $\\alpha \\mathbf{M}$ 来增强准静态算子，并定义：\n$$\n\\mathbf{K}_\\alpha = \\mathbf{K} + \\alpha \\mathbf{M},\n$$\n其中 $\\alpha \\ge 0$ 是一个标量参数。你必须证明在所述条件下，对于所有 $\\alpha \\ge 0$，$\\mathbf{K}_\\alpha \\succ 0$（即 $\\mathbf{K}_\\alpha$ 是对称正定的）。\n\n然后，对于线性系统：\n$$\n\\mathbf{K}_\\alpha \\mathbf{u} = \\mathbf{b},\n$$\n通过测量在改变 $\\alpha$ 时达到预定相对残差容差所需的迭代次数，比较共轭梯度（CG）法的收敛行为。使用相对残差的标准定义：\n$$\n\\frac{\\|\\mathbf{b} - \\mathbf{K}_\\alpha \\mathbf{u}_k\\|_2}{\\|\\mathbf{b}\\|_2},\n$$\n其中 $\\mathbf{u}_k$ 是第 $k$ 次迭代时的 CG 迭代解。\n\n在一个完整的、可运行的程序中实现以下内容：\n1. 使用上述无量纲参数为所描述的杆组装全局矩阵 $\\mathbf{K}$、$\\mathbf{M}$ 和全局荷载向量 $\\mathbf{b}$。\n2. 通过从 $\\mathbf{K}$ 和 $\\mathbf{M}$ 中移除相应的行和列，并从 $\\mathbf{b}$ 中移除相应的条目，来施加节点 $0$ 处的狄利克雷边界条件。\n3. 对于每个指定的 $\\alpha$，构建 $\\mathbf{K}_\\alpha$，计算其最小特征值以数值方式确认其 SPD 性质，并使用从头实现的共轭梯度法求解 $\\mathbf{K}_\\alpha \\mathbf{u}=\\mathbf{b}$。记录从零初始猜测开始达到 $10^{-10}$ 相对残差容差所需的迭代次数。\n4. 使用 $n_e=64$ 个单元。\n\n测试套件：\n- 使用 $\\alpha$ 值 $\\{0.0, 10^{-6}, 10^{-3}, 10^{-1}, 1.0, 10.0\\}$ 以涵盖基线、小幅增强、中度增强和大幅增强机制。\n\n答案规范：\n- 对于列表中按顺序列出的每个 $\\alpha$，产生两个输出：整数形式的 CG 迭代次数和浮点数形式的 $\\mathbf{K}_\\alpha$ 最小特征值。由于模型是无量纲化的，这些输出是无单位的数值。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按确切顺序包含与 $\\alpha$ 值 $\\{0.0, 10^{-6}, 10^{-3}, 10^{-1}, 1.0, 10.0\\}$ 对应的数值：$\\left[\\text{iters}_{\\alpha_1}, \\lambda_{\\min}(\\mathbf{K}_{\\alpha_1}), \\text{iters}_{\\alpha_2}, \\lambda_{\\min}(\\mathbf{K}_{\\alpha_2}), \\ldots \\right]$。", "solution": "该问题要求使用有限元法（FEM）构建和分析杆的准静态一维线性弹性模型。该模型通过一个质量正则化项进行增强，并且需要研究共轭梯度（CG）迭代求解器作为正则化参数 $\\alpha$ 的函数的收敛行为。\n\n第一步是对问题的核心前提进行理论验证：即在给定的边界条件下，对于所有 $\\alpha \\ge 0$，矩阵 $\\mathbf{K}_\\alpha = \\mathbf{K} + \\alpha \\mathbf{M}$ 都是对称正定（SPD）的。\n\n如果一个矩阵 $\\mathbf{A}$ 是对称的（$\\mathbf{A} = \\mathbf{A}^T$），并且对于任何非零向量 $\\mathbf{x}$，其二次型 $\\mathbf{x}^T \\mathbf{A} \\mathbf{x}  0$，则该矩阵是 SPD 的。全局刚度矩阵 $\\mathbf{K}$ 和质量矩阵 $\\mathbf{M}$ 是由其对称的单元级对应矩阵（$\\mathbf{k}_e$, $\\mathbf{m}_e$）组装而成的，因此它们也是对称的。所以，$\\mathbf{K}_\\alpha$ 是对称的。\n\n为了确定正定性，我们考虑二次型的物理解释。\n项 $\\frac{1}{2}\\mathbf{u}^T \\mathbf{K} \\mathbf{u}$ 表示对于给定的节点位移向量 $\\mathbf{u}$，存储在离散化杆中的弹性应变能。为使系统稳定，对于任何可能的变形，该能量必须为正。在没有任何边界条件的情况下，杆的刚体平移（对于常数 $c \\ne 0$，$\\mathbf{u} = c[1, 1, \\dots, 1]^T$）导致零应变和零应变能，这意味着 $\\mathbf{K}$ 只是半正定的。问题指定了狄利克雷边界条件 $u(0)=0$，该条件通过移除全局矩阵的第一行和第一列来施加。这个约束消除了刚体模式。对于剩余自由度上的任何非零位移向量 $\\mathbf{u}$，必然存在非零应变，因此应变能 $\\frac{1}{2}\\mathbf{u}^T \\mathbf{K} \\mathbf{u}  0$。因此，缩减后的刚度矩阵 $\\mathbf{K}$ 是 SPD 的。\n\n项 $\\frac{1}{2}\\mathbf{u}^T \\mathbf{M} \\mathbf{u}$ 对应于系统的动能（如果 $\\mathbf{u}$ 是一个速度向量）。单元质量矩阵 $\\mathbf{m}_e$ 是 SPD 的，组装后的全局质量矩阵 $\\mathbf{M}$（无论是在施加边界条件之前还是之后）也是 SPD 的，因为质量是一个内在的正量。对于任何非零位移（或速度）场，动能必须为正。因此，对于自由度上的任何非零向量 $\\mathbf{u}$，$\\mathbf{u}^T \\mathbf{M} \\mathbf{u}  0$。\n\n现在，考虑对于任何适当维度的非零向量 $\\mathbf{u}$ 的 $\\mathbf{K}_\\alpha$ 的二次型：\n$$\n\\mathbf{u}^T \\mathbf{K}_\\alpha \\mathbf{u} = \\mathbf{u}^T (\\mathbf{K} + \\alpha \\mathbf{M}) \\mathbf{u} = \\mathbf{u}^T \\mathbf{K} \\mathbf{u} + \\alpha (\\mathbf{u}^T \\mathbf{M} \\mathbf{u})\n$$\n由于 $\\mathbf{K}$ 和 $\\mathbf{M}$ 是 SPD 的，我们有 $\\mathbf{u}^T \\mathbf{K} \\mathbf{u}  0$ 和 $\\mathbf{u}^T \\mathbf{M} \\mathbf{u}  0$。对于 $\\alpha \\ge 0$，项 $\\alpha (\\mathbf{u}^T \\mathbf{M} \\mathbf{u})$ 是非负的。一个严格正数与一个非负数之和是严格正的。因此，对于所有 $\\alpha \\ge 0$，$\\mathbf{u}^T \\mathbf{K}_\\alpha \\mathbf{u}  0$，这证实了 $\\mathbf{K}_\\alpha$ 是 SPD 的。这是成功应用共轭梯度法的关键先决条件。\n\n数值实现过程如下。\n首先，我们定义无量纲化的物理和离散化参数：$E=1$、$A=1$、$\\rho=1$、$L=1$、$q=1$ 和 $n_e=64$。这得出的单元长度为 $h = L/n_e = 1/64$。\n计算单元刚度矩阵 $\\mathbf{k}_e$、质量矩阵 $\\mathbf{m}_e$ 和力向量 $\\mathbf{f}_e$：\n$$\n\\mathbf{k}_e = \\frac{1 \\cdot 1}{1/64} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} = 64 \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n$$\n\\mathbf{m}_e = \\frac{1 \\cdot 1 \\cdot (1/64)}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix} = \\frac{1}{384} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}\n$$\n$$\n\\mathbf{f}_e = \\frac{1 \\cdot 1 \\cdot (1/64)}{2} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} = \\frac{1}{128} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\n$$\n将全局矩阵 $\\mathbf{K}$、$\\mathbf{M}$（大小为 $(n_e+1) \\times (n_e+1)$）和向量 $\\mathbf{b}$（大小为 $n_e+1$）初始化为零。然后我们遍历 $n_e$ 个单元中的每一个。对于单元 $i$（连接节点 $i$ 和 $i+1$），将 $\\mathbf{k}_e$、$\\mathbf{m}_e$ 和 $\\mathbf{f}_e$ 的条目加到全局系统中的相应位置。这个标准的组装过程会产生带状的全局矩阵。\n\n通过从 $\\mathbf{K}$ 和 $\\mathbf{M}$ 中移除对应于节点 $0$ 的行和列，以及从 $\\mathbf{b}$ 中移除对应于节点 $0$ 的条目来强制执行狄利克雷边界条件 $u(0)=0$。这将系统大小从 $(n_e+1) \\times (n_e+1)$ 减小到 $n_e \\times n_e$。将缩减后的系统表示为 $\\mathbf{K}_{red}$、$\\mathbf{M}_{red}$ 和 $\\mathbf{b}_{red}$。\n\n对于测试套件中的每个 $\\alpha$ 值，构建增强矩阵 $\\mathbf{K}_\\alpha = \\mathbf{K}_{red} + \\alpha \\mathbf{M}_{red}$。计算其最小特征值 $\\lambda_{\\min}(\\mathbf{K}_\\alpha)$，以数值方式验证 SPD 性质（对于对称矩阵，一个正的最小特征值即可证实）。\n\n然后使用从头实现的共轭梯度算法求解线性系统 $\\mathbf{K}_\\alpha \\mathbf{u} = \\mathbf{b}_{red}$。该算法以零向量猜测 $\\mathbf{u}_0 = \\mathbf{0}$ 进行初始化。迭代过程如下：\n1.  初始化：$\\mathbf{u}_0 = \\mathbf{0}$，残差 $\\mathbf{r}_0 = \\mathbf{b}_{red}$，搜索方向 $\\mathbf{p}_0 = \\mathbf{r}_0$。\n2.  对于 $k=0, 1, 2, \\dots$：\n    a. 计算步长：$\\gamma_k = (\\mathbf{r}_k^T \\mathbf{r}_k) / (\\mathbf{p}_k^T \\mathbf{K}_\\alpha \\mathbf{p}_k)$。\n    b. 更新解：$\\mathbf{u}_{k+1} = \\mathbf{u}_k + \\gamma_k \\mathbf{p}_k$。\n    c. 更新残差：$\\mathbf{r}_{k+1} = \\mathbf{r}_k - \\gamma_k \\mathbf{K}_\\alpha \\mathbf{p}_k$。\n    d. 检查收敛性：如果 $\\|\\mathbf{r}_{k+1}\\|_2 / \\|\\mathbf{b}_{red}\\|_2 \\le 10^{-10}$，则停止。迭代次数为 $k+1$。\n    e. 更新搜索方向：$\\beta_k = (\\mathbf{r}_{k+1}^T \\mathbf{r}_{k+1}) / (\\mathbf{r}_k^T \\mathbf{r}_k)$，然后 $\\mathbf{p}_{k+1} = \\mathbf{r}_{k+1} + \\beta_k \\mathbf{p}_k$。\n\nCG 方法的性能与系统矩阵的条件数 $\\kappa(\\mathbf{K}_\\alpha) = \\lambda_{\\max}(\\mathbf{K}_\\alpha) / \\lambda_{\\min}(\\mathbf{K}_\\alpha)$ 内在相关。对于 $\\alpha=0$，已知刚度矩阵 $\\mathbf{K}_{red}$ 在细网格下是病态的，其条件数 $\\kappa(\\mathbf{K}_{red}) \\propto n_e^2$。添加质量矩阵项（$\\alpha  0$）会增加所有特征值，但它对较小特征值的影响相对更显著，因此通常会减小条件数。预计随着 $\\alpha$ 从零开始增加，达到收敛所需的 CG 迭代次数会减少。对于大的 $\\alpha$，$\\mathbf{K}_\\alpha \\approx \\alpha \\mathbf{M}_{red}$，条件数将接近质量矩阵的条件数 $\\kappa(\\mathbf{M}_{red})$，这是一个与 $n_e$ 无关的小常数。因此，对于大的 $\\alpha$，迭代次数应该会稳定下来。以下程序实现了这个过程，并为指定的 $\\alpha$ 值集合测量了迭代次数和最小特征值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and solves a 1D linear elasticity problem using FEM,\n    analyzing the convergence of the Conjugate Gradient method with\n    mass regularization.\n    \"\"\"\n\n    # 1. Define problem parameters and test suite\n    E = 1.0\n    A = 1.0\n    rho = 1.0\n    L = 1.0\n    q = 1.0\n    n_e = 64\n    h = L / n_e\n    \n    alpha_values = [0.0, 1e-6, 1e-3, 1e-1, 1.0, 10.0]\n    tolerance = 1e-10\n\n    # 2. Assemble global matrices and vector\n    n_nodes = n_e + 1\n    K_global = np.zeros((n_nodes, n_nodes))\n    M_global = np.zeros((n_nodes, n_nodes))\n    b_global = np.zeros(n_nodes)\n\n    # Element matrices and vector\n    k_e = (E * A / h) * np.array([[1, -1], [-1, 1]])\n    m_e = (rho * A * h / 6) * np.array([[2, 1], [1, 2]])\n    f_e = (q * A * h / 2) * np.array([1, 1])\n\n    # Assembly loop\n    for i in range(n_e):\n        # Global DOFs for element i are i and i+1\n        dofs = np.array([i, i + 1])\n        ix_ = np.ix_(dofs, dofs)\n        K_global[ix_] += k_e\n        M_global[ix_] += m_e\n        b_global[dofs] += f_e\n\n    # 3. Apply Dirichlet boundary condition (u(0) = 0)\n    # This involves removing the first row and column (DOF 0)\n    free_dofs = np.arange(1, n_nodes)\n    K_reduced = K_global[np.ix_(free_dofs, free_dofs)]\n    M_reduced = M_global[np.ix_(free_dofs, free_dofs)]\n    b_reduced = b_global[free_dofs]\n\n    def conjugate_gradient(A_mat, b_vec, tol):\n        \"\"\"\n        Solves Ax=b using the Conjugate Gradient method from first principles.\n        \"\"\"\n        n = len(b_vec)\n        x = np.zeros(n)\n        r = b_vec - A_mat @ x\n        p = r.copy()\n        rs_old = r @ r\n        \n        b_norm = np.linalg.norm(b_vec)\n        if b_norm == 0:\n            return 0 # Trivial solution\n\n        # The problem asks for a maximum number of iterations, but for a \n        # well-posed problem, setting it to the system size is sufficient\n        # as CG is guaranteed to converge in at most n steps (in exact arithmetic).\n        for i in range(n):\n            Ap = A_mat @ p\n            alpha_cg = rs_old / (p @ Ap)\n            \n            x += alpha_cg * p\n            r -= alpha_cg * Ap\n            \n            # Check for convergence\n            residual_norm = np.linalg.norm(r)\n            if residual_norm / b_norm  tol:\n                return i + 1\n            \n            rs_new = r @ r\n            p = r + (rs_new / rs_old) * p\n            rs_old = rs_new\n            \n        return n # Return max iterations if tolerance not met\n\n    results = []\n    for alpha in alpha_values:\n        # 4. Form augmented matrix and solve\n        K_alpha = K_reduced + alpha * M_reduced\n\n        # 5. Compute smallest eigenvalue to confirm SPD\n        # eigvalsh is efficient for symmetric matrices and returns sorted eigenvalues\n        min_eigenvalue = np.linalg.eigvalsh(K_alpha)[0]\n\n        # 6. Solve system with CG and record iteration count\n        iterations = conjugate_gradient(K_alpha, b_reduced, tolerance)\n\n        results.extend([iterations, min_eigenvalue])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3576538"}, {"introduction": "虽然算法效率（如迭代次数）至关重要，但求解器在现代超级计算机上的真实性能是计算、通信和内存访问之间复杂相互作用的结果。本练习将从纯粹的算法分析转向性能建模的实践领域，这是大规模计算力学中的一项关键技能。您将使用一个基于原理的模型来估计和比较使用和不使用两级预条件子的 CG 方法的壁钟时间，从而突显通信成本（特别是全局归约操作）对整体可扩展性的关键影响。[@problem_id:3576532]", "problem": "考虑一个由计算固体力学中的有限元离散化产生的对称正定（SPD）线性系统。您将估计在分布式内存集群上使用共轭梯度（CG）方法（带和不带两层预处理器）求解时每次求解的墙钟时间。您的估计必须遵循一个将计算和通信分开的有原则的性能模型，并重点关注全局归约的贡献。\n\n基本和建模假设：\n- 用于SPD系统的共轭梯度（CG）方法每次迭代执行一次稀疏矩阵向量乘积、少量向量更新和内积。经典的预处理共轭梯度（PCG）方法每次迭代需要$2$次全局点积（每次都通过全局归约实现）。\n- 通信模型使用延迟-带宽模型（也称为Hockney模型）。一个大小为$m$字节的点对点消息所需时间为$T_{\\text{ptp}} = \\alpha + m/\\beta$，其中$\\alpha$是每条消息的网络延迟，$\\beta$是每链路的带宽（单位：字节/秒）。在$p$个节点上进行的全局归约使用一个具有$\\lceil \\log_{2}(p) \\rceil$个阶段的树，因此一次大小为$m$字节的消息归约所需的时间为\n$$\nT_{\\text{red}}(p,m) = \\lceil \\log_{2}(p) \\rceil \\left( \\alpha + \\frac{m}{\\beta} \\right).\n$$\n- 计算时间被建模为浮点运算次数除以持续浮点速率。设有$N$个未知数，每行平均有$z$个非零元，以及$p$个相同的节点，每个节点每秒可维持$R_{\\text{node}}$次浮点运算，则总持续速率为$R_{\\text{tot}} = p \\, R_{\\text{node}}$。一次稀疏矩阵向量乘积（SpMV）大约需要$2 z N$次浮点运算，每次迭代的向量更新需要$6 N$次浮点运算，两次点积的局部部分需要$2 N$次浮点运算。因此，每次迭代的局部计算工作量（不包括任何预处理器工作）为\n$$\nW_{\\text{iter,local}} = 2 z N + 6 N + 2 N = 2 z N + 8 N,\n$$\n其时间为 $T_{\\text{iter,comp}} = W_{\\text{iter,local}} / R_{\\text{tot}}$。\n- 无预处理的CG迭代次数建模为$K_{0} = \\lceil c_{k} \\, N^{1/3} \\rceil$，其中$c_{k}$是一个无量纲常数。两层预处理器产生的迭代次数为$K_{\\text{pc}} = \\lceil K_{0} / \\rho \\rceil$，其中$\\rho  1$是迭代减少因子。\n- 两层预处理器有一个大小为$N_{c} = \\alpha_{c} \\, p$的粗空间，其中$\\alpha_{c}$是一个无量纲常数，表示每个子域的粗略未知数。粗略校正的每次迭代额外成本包括：\n    - 一个密集粗略求解时间，建模为\n    $$\n    T_{\\text{coarse,comp}} = \\frac{c_{\\text{chol}} \\, N_{c}^{3}}{R_{\\text{node}}},\n    $$\n    其中$c_{\\text{chol}} = 1/3$模拟了密集Cholesky分解的复杂度，在一个节点上有效执行。\n    - 对大小为$8 N_{c}$字节的粗略向量进行一次额外的全局归约（每次预处理迭代增加一次归约），因此每次迭代的额外归约时间为$T_{\\text{red}}(p, 8 N_{c})$。\n- 预处理器设置包括$s_{\\text{setup}} N / R_{\\text{tot}}$秒的局部设置成本，其中$s_{\\text{setup}}$是每个未知数的局部设置浮点运算次数，以及对大小为$8 N_{c}$字节的粗略向量进行一次全局归约。在无预处理的情况下，没有预处理器开销。\n- 用于点积的归约使用$8$字节的消息大小（一个浮点标量）。\n- 无预处理的总墙钟时间为\n$$\nT_{\\text{noPC}} = K_{0} \\left( T_{\\text{iter,comp}} + 2 \\, T_{\\text{red}}(p, 8) \\right),\n$$\n使用两层预处理器的总墙钟时间为\n$$\nT_{\\text{PC}} = \\underbrace{\\frac{s_{\\text{setup}} N}{R_{\\text{tot}}} + T_{\\text{red}}(p, 8 N_{c})}_{T_{\\text{setup,PC}}} + K_{\\text{pc}} \\left( T_{\\text{iter,comp}} + T_{\\text{coarse,comp}} + 2 \\, T_{\\text{red}}(p, 8) + T_{\\text{red}}(p, 8 N_{c}) \\right).\n$$\n- 为突出全局归约的影响，还需报告仅由全局归约产生的时间。对于无预处理的情况，\n$$\nT_{\\text{red,noPC}} = K_{0} \\cdot 2 \\, T_{\\text{red}}(p, 8),\n$$\n对于有预处理的情况，\n$$\nT_{\\text{red,PC}} = \\underbrace{T_{\\text{red}}(p, 8 N_{c})}_{\\text{setup}} + K_{\\text{pc}} \\left( 2 \\, T_{\\text{red}}(p, 8) + T_{\\text{red}}(p, 8 N_{c}) \\right).\n$$\n\n您的任务：\n- 实现一个程序，为下面的测试套件计算$T_{\\text{noPC}}$、$K_{0}$、$T_{\\text{red,noPC}}$、$T_{\\text{PC}}$、$K_{\\text{pc}}$和$T_{\\text{red,PC}}$。所有时间必须以秒为单位，并四舍五入到6位小数。迭代次数为整数。\n- 使用常数$c_{k} = 0.5$、$c_{\\text{chol}} = 1/3$和$s_{\\text{setup}} = 200$（每个未知数的浮点运算次数）。\n- 假设$R_{\\text{tot}} = p \\, R_{\\text{node}}$，并在$p = 1$时使用$\\lceil \\log_{2}(p) \\rceil = 0$。\n\n测试套件（每个案例是一个参数元组$(p, \\alpha, \\beta, N, z, R_{\\text{node}}, \\rho, \\alpha_{c})$）：\n- 案例 A（理想路径）：$(16, 1.0 \\times 10^{-6}, 12.0 \\times 10^{9}, 1.0 \\times 10^{7}, 27, 1.0 \\times 10^{11}, 4, 8)$。\n- 案例 B（高延迟，多节点）：$(64, 5.0 \\times 10^{-5}, 1.0 \\times 10^{9}, 2.0 \\times 10^{7}, 27, 8.0 \\times 10^{10}, 6, 16)$。\n- 案例 C（小问题，中等节点数）：$(32, 2.0 \\times 10^{-6}, 25.0 \\times 10^{9}, 1.0 \\times 10^{6}, 15, 1.2 \\times 10^{11}, 3, 4)$。\n- 案例 D（单节点边界情况）：$(1, 1.0 \\times 10^{-6}, 12.0 \\times 10^{9}, 5.0 \\times 10^{6}, 27, 1.0 \\times 10^{11}, 2, 8)$。\n\n最终输出规范：\n- 对于每个测试案例，生成一个列表$[T_{\\text{noPC}}, K_{0}, T_{\\text{red,noPC}}, T_{\\text{PC}}, K_{\\text{pc}}, T_{\\text{red,PC}}]$，其中时间以秒为单位，四舍五入到6位小数，迭代次数为整数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素是对应测试案例的列表，顺序与提供的一致（例如，$[[ \\cdot ],[ \\cdot ],[ \\cdot ],[ \\cdot ]]$）。", "solution": "该问题提供了一个详细的性能模型，用于估算在使用共轭梯度（CG）方法（带和不带两层预处理器）求解对称正定（SPD）线性系统时的墙钟时间。任务是实现此模型，并为一组给定的测试案例计算特定的性能指标。解决方案通过系统地实现所提供的公式来展开。\n\n对于由参数集$(p, \\alpha, \\beta, N, z, R_{\\text{node}}, \\rho, \\alpha_{c})$定义的每个测试案例，其过程如下：\n\n首先，我们定义所提供的常数：\n- 迭代次数常数，$c_{k} = 0.5$。\n- Cholesky复杂度常数，$c_{\\text{chol}} = 1/3$。\n- 预处理器局部设置工作，$s_{\\text{setup}} = 200$ 每个未知数的浮点运算次数。\n- 点积归约的消息大小，$m_{\\text{dot}} = 8$ 字节。\n\n接下来，我们计算从输入参数派生的几个中间量：\n- 所有节点的总持续浮点速率：$R_{\\text{tot}} = p \\cdot R_{\\text{node}}$。\n- 预处理器的粗空间大小：$N_{c} = \\alpha_{c} \\cdot p$。\n- 粗向量归约的消息大小：$m_{\\text{coarse}} = 8 \\cdot N_{c}$ 字节。\n- 归约模型的项$\\lceil \\log_{2}(p) \\rceil$，根据规定，当$p=1$时取0。对于$p  1$，其计算为$\\lceil \\log_{2}(p) \\rceil$，对于$p=1$则为0。\n\n使用这些量，我们计算模型的基本时间分量。\n单次大小为$m$的全局归约消息的时间由Hockney风格模型给出：\n$$ T_{\\text{red}}(p,m) = \\lceil \\log_{2}(p) \\rceil \\left( \\alpha + \\frac{m}{\\beta} \\right) $$\n我们应用此公式来计算点积归约的时间$T_{\\text{red,dot}} = T_{\\text{red}}(p, m_{\\text{dot}})$和粗向量归约的时间$T_{\\text{red,coarse}} = T_{\\text{red}}(p, m_{\\text{coarse}})$。\n\n每次迭代的计算时间（不包括预处理器特定工作）基于一次SpMV（$2zN$）、向量更新（$6N$）和局部点积（$2N$）的浮点运算次数：\n$$ W_{\\text{iter,local}} = 2 z N + 8 N $$\n$$ T_{\\text{iter,comp}} = \\frac{W_{\\text{iter,local}}}{R_{\\text{tot}}} $$\n\n接下来估算迭代次数。对于无预处理的情况：\n$$ K_{0} = \\lceil c_{k} \\, N^{1/3} \\rceil $$\n对于有预处理的情况，此值减少一个因子$\\rho$：\n$$ K_{\\text{pc}} = \\lceil K_{0} / \\rho \\rceil $$\n这些值必须是整数。\n\n有了这些分量，我们可以组装无预处理情况下的总时间和归约时间。每次迭代的总时间是计算时间和两次点积归约时间之和。\n$$ T_{\\text{noPC}} = K_{0} \\left( T_{\\text{iter,comp}} + 2 \\, T_{\\text{red,dot}} \\right) $$\n仅归因于全局归约的时间是：\n$$ T_{\\text{red,noPC}} = K_{0} \\cdot 2 \\, T_{\\text{red,dot}} $$\n\n对于有预处理的情况，必须包括预处理器设置和应用的额外成本。\n设置包括局部计算和一次粗向量的全局归约：\n$$ T_{\\text{setup,PC}} = \\frac{s_{\\text{setup}} N}{R_{\\text{tot}}} + T_{\\text{red}}(p, 8 N_{c}) $$\n现在的每次迭代成本包括标准的CG工作、粗略求解和三次全局归约（两次用于点积，一次用于预处理器）：\n$$ T_{\\text{iter-total,PC}} = T_{\\text{iter,comp}} + T_{\\text{coarse,comp}} + 2 \\, T_{\\text{red}}(p, 8) + T_{\\text{red}}(p, 8 N_{c}) $$\n其中粗略求解时间被建模为在单个节点上进行密集Cholesky分解：\n$$ T_{\\text{coarse,comp}} = \\frac{c_{\\text{chol}} \\, N_{c}^{3}}{R_{\\text{node}}} $$\n预处理求解的总时间是设置时间和所有迭代总时间之和：\n$$ T_{\\text{PC}} = T_{\\text{setup,PC}} + K_{\\text{pc}} \\cdot T_{\\text{iter-total,PC}} $$\n最后，在有预处理的情况下，归因于归约的总时间包括设置归约和每次$K_{\\text{pc}}$迭代内的归约：\n$$ T_{\\text{red,PC}} = T_{\\text{red}}(p, 8 N_{c}) + K_{\\text{pc}} \\left( 2 \\, T_{\\text{red}}(p, 8) + T_{\\text{red}}(p, 8 N_{c}) \\right) $$\n\n通过为每个测试案例实现这些公式，我们可以计算所需的六个值：$T_{\\text{noPC}}$、$K_{0}$、$T_{\\text{red,noPC}}$、$T_{\\text{PC}}$、$K_{\\text{pc}}$和$T_{\\text{red,PC}}$。所有时间值都四舍五入到6位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the performance model to estimate wall-clock time for CG and PCG methods.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (p, alpha, beta, N, z, R_node, rho, alpha_c)\n    test_cases = [\n        (16, 1.0e-6, 12.0e9, 1.0e7, 27, 1.0e11, 4, 8),   # Case A\n        (64, 5.0e-5, 1.0e9, 2.0e7, 27, 8.0e10, 6, 16),   # Case B\n        (32, 2.0e-6, 25.0e9, 1.0e6, 15, 1.2e11, 3, 4),   # Case C\n        (1, 1.0e-6, 12.0e9, 5.0e6, 27, 1.0e11, 2, 8),    # Case D\n    ]\n\n    # Constants from the problem statement\n    c_k = 0.5\n    c_chol = 1.0 / 3.0\n    s_setup = 200.0\n    m_dot = 8.0 # bytes\n\n    results = []\n    \n    for case in test_cases:\n        p, alpha, beta, N, z, R_node, rho, alpha_c = case\n\n        # Calculate intermediate quantities\n        R_tot = p * R_node\n        N_c = alpha_c * p\n        m_coarse = 8.0 * N_c\n        \n        # Per the spec, log2p_ceil is 0 for p=1. np.log2(1)=0, np.ceil(0)=0.\n        # This handles all p >= 1 correctly.\n        log2p_ceil = np.ceil(np.log2(p)) if p > 1 else 0.0\n\n        # Define T_red function based on the model\n        def T_red(p_val, m_val, alpha_val, beta_val, log2p_val):\n            if p_val == 1:\n                return 0.0\n            return log2p_val * (alpha_val + m_val / beta_val)\n\n        # Calculate fundamental time components\n        T_red_dot = T_red(p, m_dot, alpha, beta, log2p_ceil)\n        T_red_coarse = T_red(p, m_coarse, alpha, beta, log2p_ceil)\n        \n        W_iter_local = 2.0 * z * N + 8.0 * N\n        T_iter_comp = W_iter_local / R_tot\n\n        # Calculate iteration counts\n        K0 = int(np.ceil(c_k * (N**(1.0/3.0))))\n        K_pc = int(np.ceil(float(K0) / rho))\n\n        # --- Unpreconditioned case ---\n        T_noPC = K0 * (T_iter_comp + 2.0 * T_red_dot)\n        T_red_noPC = K0 * 2.0 * T_red_dot\n\n        # --- Preconditioned case ---\n        # Setup time\n        T_setup_comp = (s_setup * N) / R_tot\n        T_setup_PC = T_setup_comp + T_red_coarse\n\n        # Per-iteration costs\n        T_coarse_comp = (c_chol * (N_c**3)) / R_node\n        T_iter_total_PC = T_iter_comp + T_coarse_comp + 2.0 * T_red_dot + T_red_coarse\n\n        # Total time\n        T_PC = T_setup_PC + K_pc * T_iter_total_PC\n        \n        # Total reduction time\n        T_red_PC = T_red_coarse + K_pc * (2.0 * T_red_dot + T_red_coarse)\n\n        # Store results, rounded as specified\n        case_results = [\n            round(T_noPC, 6),\n            K0,\n            round(T_red_noPC, 6),\n            round(T_PC, 6),\n            K_pc,\n            round(T_red_PC, 6)\n        ]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3576532"}]}