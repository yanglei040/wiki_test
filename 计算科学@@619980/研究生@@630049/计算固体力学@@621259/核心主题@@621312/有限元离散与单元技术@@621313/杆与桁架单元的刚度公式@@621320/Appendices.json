{"hands_on_practices": [{"introduction": "理论联系实践的第一步是确保我们最基本的构建单元——单个单元刚度矩阵——是正确的。本练习将指导你从第一性原理出发，推导并实现二维杆单元的全局刚度矩阵，并设计一系列关键的数值测试来验证其旋转不变性、对称性和半正定性等基本属性。通过这个实践[@problem_id:3602979]，你将为后续更复杂的有限元分析打下坚实的基础。", "problem": "您需要从第一性原理出发，实现一个程序，构建一个二维杆（双节点桁架）单元的全局刚度矩阵，并设计数值检验来验证其在刚性旋转下的不变性，以及检测常见的符号约定错误。推导过程必须从一维小应变运动学、线性弹性本构关系和虚功原理开始，然后进而求得单元在自身轴向坐标系下的局部单元刚度。接着，使用由方向余弦构建的正交变换，将局部刚度映射到每个节点具有两个自由度（DOF）的全局（实验室）坐标系。该程序必须在一个测试套件上检验此公式，该套件用于探查旋转不变性、对称性和半正定性、一个刻意设置的“病态”方向以及一个退化几何的边界情况。\n\n您应使用的基本原理：\n- 轴向变形杆的小应变运动学：轴向应变 $\\varepsilon = du/dx$。\n- 杆的线性弹性本构关系：轴向应力 $\\sigma = E\\varepsilon$，其中 $E$ 是杨氏模量。\n- 用于保守线性系统的虚功原理，它使得可以从内虚功平衡推导出对称的单元刚度算子。\n- 使用方向余弦进行正交基变换，以在单元局部坐标和全局坐标之间进行映射。\n\n使用以下建模和数值约定：\n- 二维杆单元，节点位于全局坐标 $(x_1,y_1)$ 和 $(x_2,y_2)$，杨氏模量为 $E$（单位：帕斯卡），横截面积为 $A$（单位：平方米）。\n- 单元长度为 $\\ell = \\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}$（单位：米），其单位方向余弦为 $c = (x_2-x_1)/\\ell$ 和 $s = (y_2-y_1)/\\ell$。\n- 局部单元位移向量是二维的，每个节点沿单元轴线有一个平移自由度；而全局位移向量是四维的，每个节点有两个平移自由度。从全局到局部的映射必须通过方向余弦构建的正交变换来构造。\n- 将单元视为线性弹性并忽略体力。\n\n您的程序必须：\n- 从第一性原理出发，通过构建单元轴向坐标系下的 $2\\times 2$ 局部刚度，然后通过基于方向余弦 $c$ 和 $s$ 构建的正交变换将其映射到全局坐标系，从而构造出 $4\\times 4$ 的全局单元刚度矩阵 $K_e$。\n- 计算 $K_e$ 的谱并提取唯一的非零特征值。对于一个二维空间中的自由双节点杆单元，$K_e$ 必须是对称半正定的，并且有且仅有一个严格为正的特征值。报告所有特征值时应带有数值保护措施；如果一个特征值的绝对值低于一个按 $k = EA/\\ell$ 缩放的容差，则视其为“零”。\n- 通过一个将单元翻转 $180^\\circ$ 的“病态”方向来验证旋转不变性，这将同时改变 $c$ 和 $s$ 的符号。如果变换实现正确，全局 $K_e$ 在此翻转下必须保持不变。通过差的弗罗贝尼乌斯范数来衡量不变性，并与一个相对容差进行比较。\n- 通过将正确的刚度与一个使用故意引入符号错误的变换计算出的刚度进行比较，来检测一个常见的符号约定错误。对于非轴对齐的单元，这个错误必须导致一个可检测的差异。报告该差异是否超过指定的容差。\n- 通过标记长度满足 $\\ell  10^{-9}$ 米的单元来检测退化几何，在这种情况下不应构建刚度矩阵。\n\n物理单位：\n- 对 $E$ 使用 $\\mathrm{Pa}$，对 $A$ 使用 $\\mathrm{m}^2$，对所有坐标使用 $\\mathrm{m}$。刚度矩阵的元素和特征值的单位是 $\\mathrm{N}/\\mathrm{m}$。将所有报告的特征值以浮点数形式表示，单位为 $\\mathrm{N}/\\mathrm{m}$。\n\n角度单位：\n- 任何对角度的引用都由坐标隐含；不需要显式的角度输入。\n\n容差：\n- 使用特征值零点容差 $10^{-9}k$，其中 $k = EA/\\ell$ 的单位是 $\\mathrm{N}/\\mathrm{m}$。\n- 在通过弗罗贝尼乌斯范数检查 $180^\\circ$ 翻转下的相等性时，使用相对矩阵不变性容差 $10^{-12}$。\n- 使用退化长度阈值 $10^{-9}$ 米。\n\n测试套件：\n- 对于所有非退化单元，使用 $E = 210\\times 10^{9}$ Pa 和 $A = 10^{-2}$ $\\mathrm{m}^2$。\n- 情况 A（轴对齐，水平）：节点 $1$ 位于 $(0,0)$ 米，节点 $2$ 位于 $(5,0)$ 米。以浮点数形式报告 $K_e$ 的唯一非零特征值，单位为 $\\mathrm{N}/\\mathrm{m}$。\n- 情况 B（轴对齐，垂直）：节点 $1$ 位于 $(0,0)$ 米，节点 $2$ 位于 $(0,5)$ 米。以浮点数形式报告 $K_e$ 的唯一非零特征值，单位为 $\\mathrm{N}/\\mathrm{m}$。\n- 情况 C（非轴对齐的 $3$–$4$–$5$ 三角形几何）：节点 $1$ 位于 $(0,0)$ 米，节点 $2$ 位于 $(3,4)$ 米。以浮点数形式报告 $K_e$ 的唯一非零特征值，单位为 $\\mathrm{N}/\\mathrm{m}$。\n- 病态旋转不变性：比较 $(0,0)\\rightarrow(3,4)$ 和 $(0,0)\\rightarrow(-3,-4)$ 两种情况下 $K_e$ 的值。如果差的相对弗罗贝尼乌斯范数低于 $10^{-12}$，则报告一个布尔值 true。\n- 对情况 C 进行对称性和半正定性检查：如果 $K_e$ 在机器精度范围内是对称的，并且有且仅有一个严格为正的特征值，而所有其他特征值都在上述定义的零点容差范围内，则报告一个布尔值 true。\n- 对一个非轴对齐单元进行符号约定错误检测：使用节点 $(0,0)$ 和 $(1,1)$。在一个方向余弦项中故意构造一个带错误符号的变换，并将得到的刚度与正确的刚度进行比较。如果差的弗罗贝尼乌斯范数超过了特征值零点容差的尺度，则报告一个布尔值 true。\n- 退化几何：节点为 $(0,0)$ 和 $(10^{-12},0)$。如果几何形状因 $\\ell  10^{-9}$ 米而被正确标记为无效，则报告一个布尔值 true。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  - 情况 A、B 和 C 中唯一非零特征值的三个浮点数（单位 $\\mathrm{N}/\\mathrm{m}$），\n  - 分别用于 $180^\\circ$ 不变性检查、对称性和半正定性检查、符号约定错误检测以及退化几何检测的四个布尔值。\n- 所需输出结构的示例：$[\\text{float},\\text{float},\\text{float},\\text{bool},\\text{bool},\\text{bool},\\text{bool}]$。", "solution": "该问题要求对二维杆（桁架）单元的全局刚度矩阵进行公式化和程序化实现，并包含一系列数值验证检查。推导和实现将按规定从第一性原理出发。\n\n### 单元刚度矩阵的推导\n\n有限元的节点力与节点位移之间的关系通过其刚度矩阵来表达。我们使用虚功原理（$\\delta W$）来推导该矩阵，该原理指出，对于处于平衡状态的物体，对于任何运动学上容许的虚位移，由应力所做的内虚功等于由外力所做的外虚功。为了推导刚度矩阵，我们只考虑内虚功 $\\delta W_{int}$。\n\n$\\delta W_{int} = \\int_V \\delta\\varepsilon^T \\sigma \\, dV$\n\n**1. 局部刚度矩阵 ($k_e$)**\n\n首先，我们在与单元轴线（$x'$）对齐的局部坐标系中建立刚度公式。该单元有两个节点，1 和 2，其属性为杨氏模量 $E$、横截面积 $A$ 和长度 $\\ell$。自由度是每个节点的轴向位移 $d'_{1}$ 和 $d'_{2}$。\n\n沿单元的位移场 $u'(x')$ 是使用线性形函数 $N_1(x') = 1 - x'/\\ell$ 和 $N_2(x') = x'/\\ell$ 从节点位移插值得到的：\n$$ u'(x') = N_1(x') d'_{1} + N_2(x') d'_{2} = \\begin{bmatrix} N_1(x')  N_2(x') \\end{bmatrix} \\begin{Bmatrix} d'_{1} \\\\ d'_{2} \\end{Bmatrix} = \\mathbf{N} \\mathbf{d}_{local} $$\n\n轴向应变 $\\varepsilon$ 是位移场的空间导数。对于线性形函数，应变沿单元是恒定的：\n$$ \\varepsilon = \\frac{du'}{dx'} = \\frac{d\\mathbf{N}}{dx'} \\mathbf{d}_{local} = \\begin{bmatrix} -\\frac{1}{\\ell}  \\frac{1}{\\ell} \\end{bmatrix} \\mathbf{d}_{local} = \\mathbf{B} \\mathbf{d}_{local} $$\n这里，$\\mathbf{B}$ 是应变-位移矩阵。虚应变为 $\\delta\\varepsilon = \\mathbf{B} \\delta\\mathbf{d}_{local}$。\n\n线性弹性本构关系（胡克定律）关联了应力 $\\sigma$ 和应变 $\\varepsilon$：\n$$ \\sigma = E \\varepsilon = E \\mathbf{B} \\mathbf{d}_{local} $$\n\n将这些代入内虚功表达式，并注意到对于横截面积为常数 $A$ 的杆，有 $dV = A \\, dx'$：\n$$ \\delta W_{int} = \\int_0^\\ell (\\delta\\varepsilon)^T \\sigma A \\, dx' = \\int_0^\\ell (\\mathbf{B} \\delta\\mathbf{d}_{local})^T (E \\mathbf{B} \\mathbf{d}_{local}) A \\, dx' $$\n由于 $\\mathbf{d}_{local}$ 及其变分 $\\delta\\mathbf{d}_{local}$ 独立于 $x'$，且 $\\mathbf{B}$、$E$ 和 $A$ 是常数，我们可以写出：\n$$ \\delta W_{int} = (\\delta\\mathbf{d}_{local})^T \\left( A E \\int_0^\\ell \\mathbf{B}^T \\mathbf{B} \\, dx' \\right) \\mathbf{d}_{local} $$\n括号中的表达式即为 $2 \\times 2$ 的局部刚度矩阵 $k_e$：\n$$ k_e = A E \\ell \\mathbf{B}^T \\mathbf{B} = A E \\ell \\begin{Bmatrix} -1/\\ell \\\\ 1/\\ell \\end{Bmatrix} \\begin{bmatrix} -1/\\ell  1/\\ell \\end{bmatrix} = \\frac{AE}{\\ell^2} \\ell \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} $$\n$$ k_e = \\frac{EA}{\\ell} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} $$\n\n**2. 全局刚度矩阵 ($K_e$)**\n\n接下来，我们将局部刚度矩阵转换到全局 $x$-$y$ 坐标系。现在每个节点有两个平移自由度：节点 1 为 $(u_1, v_1)$，节点 2 为 $(u_2, v_2)$。全局位移向量为 $\\mathbf{d}_{global} = [u_1, v_1, u_2, v_2]^T$。\n\n一个节点的局部轴向位移 $d'_i$ 是其全局位移向量 $(u_i, v_i)$ 在单元轴线上的投影。该轴线的方向由一个单位向量给出，其分量为 $(c, s)$，其中 $c$ 和 $s$ 是方向余弦：\n$$ c = \\frac{x_2 - x_1}{\\ell}, \\quad s = \\frac{y_2 - y_1}{\\ell} $$\n局部和全局位移之间的关系是：\n$$ d'_{1} = c u_1 + s v_1 $$\n$$ d'_{2} = c u_2 + s v_2 $$\n这可以写成矩阵形式 $\\mathbf{d}_{local} = \\mathbf{T} \\mathbf{d}_{global}$：\n$$ \\begin{Bmatrix} d'_{1} \\\\ d'_{2} \\end{Bmatrix} = \\begin{bmatrix} c  s  0  0 \\\\ 0  0  c  s \\end{bmatrix} \\begin{Bmatrix} u_1 \\\\ v_1 \\\\ u_2 \\\\ v_2 \\end{Bmatrix} $$\n其中 $\\mathbf{T}$ 是 $2 \\times 4$ 的转换矩阵。\n\n根据功等效原理，内功必须与坐标系的选择无关。\n$$ \\delta W_{int} = (\\delta\\mathbf{d}_{local})^T k_e \\mathbf{d}_{local} = (\\delta\\mathbf{d}_{global})^T K_e \\mathbf{d}_{global} $$\n代入 $\\mathbf{d}_{local} = \\mathbf{T} \\mathbf{d}_{global}$ 和 $\\delta\\mathbf{d}_{local} = \\mathbf{T} \\delta\\mathbf{d}_{global}$：\n$$ (\\mathbf{T} \\delta\\mathbf{d}_{global})^T k_e (\\mathbf{T} \\mathbf{d}_{global}) = (\\delta\\mathbf{d}_{global})^T (\\mathbf{T}^T k_e \\mathbf{T}) \\mathbf{d}_{global} $$\n由此，我们确定 $4 \\times 4$ 的全局刚度矩阵 $K_e$：\n$$ K_e = \\mathbf{T}^T k_e \\mathbf{T} $$\n执行矩阵乘法：\n$$ K_e = \\begin{bmatrix} c  0 \\\\ s  0 \\\\ 0  c \\\\ 0  s \\end{bmatrix} \\left( \\frac{EA}{\\ell} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} \\right) \\begin{bmatrix} c  s  0  0 \\\\ 0  0  c  s \\end{bmatrix} $$\n$$ K_e = \\frac{EA}{\\ell} \\begin{bmatrix} c  -c \\\\ s  -s \\\\ -c  c \\\\ -s  s \\end{bmatrix} \\begin{bmatrix} c  s  0  0 \\\\ 0  0  c  s \\end{bmatrix} $$\n这得到了全局刚度矩阵的最终表达式：\n$$ K_e = \\frac{EA}{\\ell} \\begin{bmatrix} c^2  cs  -c^2  -cs \\\\ cs  s^2  -cs  -s^2 \\\\ -c^2  -cs  c^2  cs \\\\ -cs  -s^2  cs  s^2 \\end{bmatrix} $$\n该矩阵可以紧凑地写为 $K_e = \\frac{EA}{\\ell} \\begin{bmatrix} \\mathbf{M}  -\\mathbf{M} \\\\ -\\mathbf{M}  \\mathbf{M} \\end{bmatrix}$，其中 $\\mathbf{M} = \\begin{bmatrix} c^2  cs \\\\ cs  s^2 \\end{bmatrix}$。\n\n### 属性和验证检查\n\n**1. $K_e$ 的谱**：矩阵 $K_e$ 的大小为 $4 \\times 4$。对于一个自由单元，存在三种刚体模态（二维平面内的两种平移和一种旋转），对应三个零特征值。因此，该矩阵的秩为 1。一个秩为 1 的矩阵只有一个非零特征值，该值等于其迹。\n$$ \\lambda_{nonzero} = \\text{Tr}(K_e) = \\frac{EA}{\\ell} (c^2 + s^2 + c^2 + s^2) = \\frac{EA}{\\ell} (2(c^2_i+s^2_i)) = 2 \\frac{EA}{\\ell} $$\n这个特征值代表了单元的轴向刚度，并且与单元在空间中的方向无关。\n\n**2. 旋转不变性**：$K_e$ 的结构取决于 $c^2$、$s^2$ 和 $cs$。如果一个单元旋转 $180^\\circ$，其方向余弦会变号：$(c, s) \\to (-c, -s)$。然而，乘积 $c^2 \\to (-c)^2 = c^2$、$s^2 \\to (-s)^2 = s^2$ 和 $cs \\to (-c)(-s) = cs$ 保持不变。因此，全局刚度矩阵 $K_e$ 在这种旋转下必须是不变的。\n\n**3. 对称性和半正定性**：矩阵 $K_e$ 是从表达式 $\\mathbf{T}^T k_e \\mathbf{T}$ 推导出来的。由于局部刚度矩阵 $k_e$ 是对称的，所以 $K_e$ 也是对称的。作为一个稳定物理系统的刚度矩阵，它必须是半正定的，意味着其所有特征值都必须是非负的（$\\lambda_i \\ge 0$）。\n\n**4. 符号约定错误**：一个常见的错误是对方向余弦使用不一致的符号，例如，使用 $s = (y_1-y_2)/\\ell$ 而不是 $s = (y_2-y_1)/\\ell$。这个缺陷会翻转 $s$ 的符号，进而翻转矩阵 $\\mathbf{M}$ 中 $cs$ 项的符号，导致任何非轴对齐单元的刚度矩阵不正确。\n\n**5. 退化几何**：如果一个单元的两个节点重合或在数值上非常接近，其长度 $\\ell$ 会趋近于零。这会导致刚度计算中出现除以零的情况，表明存在奇异性。这类单元必须被标记并从分析中排除。\n\n以下程序实现了这些原理，并在指定的测试套件上执行所需的验证检查。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef get_stiffness_matrix(coords, E, A, sign_error_s=False):\n    \"\"\"\n    Constructs the global stiffness matrix for a 2D bar element.\n\n    Args:\n        coords (tuple): A tuple of (x1, y1, x2, y2) nodal coordinates.\n        E (float): Young's modulus in Pascals.\n        A (float): Cross-sectional area in square meters.\n        sign_error_s (bool): If True, introduces a sign error in the 's' direction cosine.\n\n    Returns:\n        tuple: A tuple containing (K_e, l, k_base) where K_e is the 4x4 stiffness\n               matrix (np.ndarray), l is the element length (float), and k_base\n               is the axial stiffness EA/l (float). Returns (None, l, None) if\n               the element is degenerate.\n    \"\"\"\n    x1, y1, x2, y2 = coords\n    dx = x2 - x1\n    dy = y2 - y1\n    \n    l = np.sqrt(dx**2 + dy**2)\n    \n    # Degenerate geometry check\n    degenerate_length_threshold = 1e-9\n    if l  degenerate_length_threshold:\n        return None, l, None\n\n    c = dx / l\n    s = dy / l\n    \n    # Introduce intentional sign error for the specific test case\n    if sign_error_s:\n        s = -s\n\n    k_base = E * A / l\n    \n    c2 = c * c\n    s2 = s * s\n    cs = c * s\n    \n    # Sub-matrix M\n    M = np.array([\n        [c2, cs],\n        [cs, s2]\n    ])\n    \n    # Assemble the 4x4 global stiffness matrix K_e\n    K_e = k_base * np.block([\n        [ M, -M],\n        [-M,  M]\n    ])\n    \n    return K_e, l, k_base\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and generate the final output.\n    \"\"\"\n    results = []\n    \n    # --- Shared parameters ---\n    E_modulus = 210.0e9  # Pa\n    Area = 1.0e-2       # m^2\n    \n    # --- Test Cases A, B, C: Unique Nonzero Eigenvalue ---\n    cases_abc = [\n        (0.0, 0.0, 5.0, 0.0),  # Case A: Horizontal\n        (0.0, 0.0, 0.0, 5.0),  # Case B: Vertical\n        (0.0, 0.0, 3.0, 4.0),  # Case C: 3-4-5 Triangle\n    ]\n    \n    for coords in cases_abc:\n        K_e, l, k_base = get_stiffness_matrix(coords, E_modulus, Area)\n        \n        # Eigenvalue zero tolerance\n        eigenvalue_zero_tol = 1e-9 * k_base\n        \n        # Use eigh for symmetric matrices; it's faster and more stable\n        eigenvalues = eigh(K_e, eigvals_only=True)\n        \n        # Find the single eigenvalue that is strictly positive\n        # based on the defined tolerance.\n        nonzero_eig = eigenvalues[eigenvalues > eigenvalue_zero_tol]\n        \n        # There should be exactly one such eigenvalue\n        if len(nonzero_eig) == 1:\n            results.append(nonzero_eig[0])\n        else:\n            # Append a sentinel value if the check fails, though it shouldn't\n            results.append(-1.0)\n            \n    # --- Pathological Rotation Invariance Check ---\n    coords1 = (0.0, 0.0, 3.0, 4.0)\n    coords2 = (0.0, 0.0, -3.0, -4.0) # 180-degree rotation\n    \n    K_e1, _, _ = get_stiffness_matrix(coords1, E_modulus, Area)\n    K_e2, _, _ = get_stiffness_matrix(coords2, E_modulus, Area)\n    \n    norm_k1 = np.linalg.norm(K_e1, 'fro')\n    diff_norm = np.linalg.norm(K_e1 - K_e2, 'fro')\n    \n    # Avoid division by zero for a null matrix, though not expected here\n    relative_diff = diff_norm / norm_k1 if norm_k1 > 0 else 0\n    \n    relative_invariance_tol = 1e-12\n    invariance_check = relative_diff  relative_invariance_tol\n    results.append(invariance_check)\n\n    # --- Symmetry and Positive Semidefiniteness (PSD) Check on Case C ---\n    K_e_C, l_C, k_base_C = get_stiffness_matrix(cases_abc[2], E_modulus, Area)\n    \n    # 1. Symmetry Check\n    is_symmetric = np.allclose(K_e_C, K_e_C.T)\n    \n    # 2. PSD Check: 1 strictly positive eigenvalue, others are 'zero'\n    eigenvalues_C = eigh(K_e_C, eigvals_only=True)\n    eigenvalue_zero_tol_C = 1e-9 * k_base_C\n    \n    # All eigenvalues must be non-negative (within tolerance)\n    are_non_negative = np.all(eigenvalues_C >= -eigenvalue_zero_tol_C)\n    \n    # Exactly one eigenvalue must be strictly positive\n    num_positive_eigs = np.sum(eigenvalues_C > eigenvalue_zero_tol_C)\n    has_one_positive_eig = (num_positive_eigs == 1)\n\n    symmetry_psd_check = is_symmetric and are_non_negative and has_one_positive_eig\n    results.append(symmetry_psd_check)\n    \n    # --- Sign-Convention Mistake Detection ---\n    coords_sign_test = (0.0, 0.0, 1.0, 1.0)\n    \n    K_correct, l_sign, k_base_sign = get_stiffness_matrix(coords_sign_test, E_modulus, Area, sign_error_s=False)\n    K_flawed, _, _ = get_stiffness_matrix(coords_sign_test, E_modulus, Area, sign_error_s=True)\n    \n    # The scale for comparison is k = EA/l\n    zero_tolerance_scale = k_base_sign\n    \n    mistake_diff_norm = np.linalg.norm(K_correct - K_flawed, 'fro')\n    \n    sign_mistake_detected = mistake_diff_norm > zero_tolerance_scale\n    results.append(sign_mistake_detected)\n\n    # --- Degenerate Geometry Detection ---\n    coords_degenerate = (0.0, 0.0, 1e-12, 0.0)\n    \n    _, l_degenerate, _ = get_stiffness_matrix(coords_degenerate, E_modulus, Area)\n    \n    degenerate_length_threshold = 1e-9\n    is_degenerate = l_degenerate  degenerate_length_threshold\n    results.append(is_degenerate)\n    \n    # --- Final Output Formatting ---\n    # Convert booleans to lowercase 'true'/'false' for output\n    formatted_results = []\n    for r in results:\n        if isinstance(r, bool):\n            formatted_results.append(str(r).lower())\n        else:\n            formatted_results.append(f\"{r:.1f}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3602979"}, {"introduction": "在验证了单个单元的正确性之后，下一步是考察它们如何组合成一个结构体系。一个有效的有限元列式必须遵守基本的物理原理，其中之一便是刚体运动不变性，即未变形的结构在平移或旋转时不应产生内力。本练习[@problem_id:3602998]将引导你设计一个最小的桁架结构，专门用于测试刚体运动，并揭示一个微小的编程错误如何导致非物理的“伪刚度”。", "problem": "二维桁架单元是连接两个节点的直杆，每个节点在全局坐标方向上具有两个自由度（DOF）。有限元法（FEM）中此类单元的刚度公式必须保持刚体运动的物理不变性，这意味着整个结构的任何均匀平移或均匀旋转都应产生零内力。从以下基本依据出发：(i) 小应变线性弹性，其中 $ \\sigma = E\\varepsilon $；(ii) 小位移梯度下的杆轴向应变 $ \\varepsilon = \\frac{du}{dx} $；以及 (iii) 在平衡状态下，线性系统的内功与外功相等的虚功原理。基于这些，推导单元在局部轴向坐标系下的刚度，然后通过一个将全局位移投影到单元轴上的正交变换，严格地获得全局刚度。该变换依赖于方向余弦 $ c = \\Delta x / L $ 和 $ s = \\Delta y / L $，其中 $ \\Delta x $ 和 $ \\Delta y $ 是节点坐标的差值，$ L $ 是单元长度。\n\n设计一个最小的双单元桁架，在纯刚体运动下应表现出零内力。使用三个节点：节点 $ 0 $ 位于 $(0,0)$，节点 $ 1 $ 位于 $(1,1)$，节点 $ 2 $ 位于 $(1,-1)$，单元为 $(0,1)$ 和 $(0,2)$。考虑两种刚体运动：对每个节点施加的均匀平移 $(t_x,t_y)$，以及绕原点的均匀无穷小旋转，角度为 $ \\varphi $，其中每个位于 $(x_i,y_i)$ 的节点移动 $(u_{x,i},u_{y,i}) = \\varphi(-y_i, x_i)$。对于从全局位移到局部位移的正确变换，在组装全局刚度矩阵并乘以全局位移向量后，这些运动必须产生零内力。\n\n为探究对变换符号错误的敏感性，定义一个“有缺陷”的变换，该变换错误地翻转了第二个节点投影的正弦项符号。具体来说，这个错误的变换在映射第二个节点的全局位移时，在其正弦贡献中使用 $ s \\mapsto -s $，同时保持余弦贡献不变。证明这个单一的符号错误会引入伪刚度，即在纯刚体运动下会产生非零内力。\n\n您必须实现一个完整的程序，该程序：\n- 从第一性原理构建二维桁架结构的全局刚度矩阵，通过将全局自由度投影到局部轴向自由度上，然后再映射回全局坐标来计算并组装单元刚度。同时使用上述的正确变换和有缺陷的变换。\n- 对于指定的刚体运动，计算内力向量 $ \\mathbf{r} = \\mathbf{K}\\mathbf{u} $ 的欧几里得范数，其中 $ \\mathbf{K} $ 是组装好的全局刚度矩阵，$ \\mathbf{u} $ 是全局位移向量。\n- 对所有单元使用以下物理参数：杨氏模量 $ E = 7.0\\times 10^{10}\\,\\mathrm{Pa} $，横截面积 $ A = 1.0\\times 10^{-4}\\,\\mathrm{m}^2 $。\n- 使用平移 $(t_x,t_y) = (0.123\\,\\mathrm{m},-0.456\\,\\mathrm{m})$ 和旋转 $ \\varphi = 0.2\\,\\mathrm{rad} $。\n- 产生以牛顿 ($ \\mathrm{N} $) 为单位的结果，角度以弧度表示。\n\n此外，设计另外两个桁架变体作为回归测试：\n1. 轴对齐变体：节点为 $(0,0)$、$(1,0)$、$(-1,0)$，单元为 $(0,1)$ 和 $(0,2)$。此变体应不受正弦符号缺陷的影响，因为所有单元的 $ s = 0 $。\n2. 近轴对齐变体：节点为 $(0,0)$、$(1,\\varepsilon)$、$(-1,\\varepsilon)$，其中 $ \\varepsilon = 10^{-6}\\,\\mathrm{m} $，单元为 $(0,1)$ 和 $(0,2)$。在有缺陷的变换下，此变体应表现出非常小但非零的伪刚度。\n\n对于每个桁架变体，计算内力向量的欧几里得范数 $ \\|\\mathbf{K}\\mathbf{u}\\|_2 $，针对以下情况：\n- 正确变换下的均匀平移和均匀旋转。\n- 有缺陷变换下的均匀平移和均匀旋转。\n\n按以下方式组织测试：\n- 变体 $ V_1 $ (旋转桁架)：节点 $(0,0)$, $(1,1)$, $(1,-1)$；单元 $(0,1)$ 和 $(0,2)$；平移和旋转如指定。\n- 变体 $ V_2 $ (轴对齐桁架)：节点 $(0,0)$, $(1,0)$, $(-1,0)$；单元 $(0,1)$ 和 $(0,2)$；平移和旋转如指定。\n- 变体 $ V_3 $ (近轴桁架)：节点 $(0,0)$, $(1,\\varepsilon)$, $(-1,\\varepsilon)$，其中 $ \\varepsilon = 10^{-6}\\,\\mathrm{m} $；单元 $(0,1)$ 和 $(0,2)$；平移和旋转如指定。\n\n您的程序必须生成单行输出，其中包含八个用方括号括起来的逗号分隔浮点数，顺序完全如下：\n$ [R_{V_1}^{\\text{corr,trans}}, R_{V_1}^{\\text{corr,rot}}, R_{V_1}^{\\text{bug,trans}}, R_{V_1}^{\\text{bug,rot}}, R_{V_2}^{\\text{bug,trans}}, R_{V_2}^{\\text{bug,rot}}, R_{V_3}^{\\text{bug,trans}}, R_{V_3}^{\\text{bug,rot}}] $，\n其中每个 $ R $ 是欧几里得范数 $ \\|\\mathbf{K}\\mathbf{u}\\|_2 $，单位为 $ \\mathrm{N} $。在有缺陷的变换下，轴对齐变体 $ V_2 $ 对于两种运动理想上都应产生精确的零，从而揭示出缺陷检测的一个盲点，而 $ V_3 $ 则应产生与 $ \\varepsilon $ 成比例的微小非零值。此输出可作为一个自动化的回归测试套件，用于标记此类变换符号缺陷。\n\n您的实现必须是自包含的，仅使用指定的运行时环境，并且不需要任何输入。最终答案必须是一个完整的可运行程序，它构建三个桁架变体，使用正确和有缺陷的变换组装刚度矩阵，应用指定的刚体运动，计算范数（单位为 $ \\mathrm{N} $），并按要求的最终输出格式在单行中打印它们。", "solution": "该问题的核心主题是在有限元法（FEM）框架内，为二维桁架单元建立单元刚度矩阵。任何有效力学公式的基石是其遵守物理不变性原理，特别是刚体运动——未变形体的均匀平移或旋转——绝不能产生内部应力或应变。该问题要求严格推导正确的刚度矩阵，证明其不变性属性，并分析一个特定的、细微的底层几何变换错误如何违反此原则，从而导致伪假的、非物理的内力。\n\n### 1. 局部坐标系中的单元刚度\n\n我们从单个桁架单元开始，它是一根一维杆件。在其由单元轴 $x'$ 定义的局部坐标系中，该单元连接两个节点，1 和 2。每个节点只有一个轴向自由度，$u'_1$ 和 $u'_2$。\n\n在小位移假设下，轴向位移场 $u'(x')$ 可以通过节点位移进行线性插值：\n$$ u'(x') = (1 - \\frac{x'}{L})u'_1 + (\\frac{x'}{L})u'_2 $$\n其中 $L$ 是单元长度。\n\n轴向应变 $\\varepsilon$ 是位移场的空间导数。对于这种线性插值，应变沿单元是恒定的：\n$$ \\varepsilon = \\frac{du'}{dx'} = \\frac{1}{L}(u'_2 - u'_1) $$\n这可以写成矩阵形式 $\\varepsilon = \\mathbf{B}\\mathbf{u'}$，其中 $\\mathbf{u'} = [u'_1, u'_2]^T$ 是局部坐标位移向量，$\\mathbf{B} = \\frac{1}{L}[-1, 1]$ 是应变-位移矩阵。\n\n根据线性弹性理论（一维杆的胡克定律），轴向应力 $\\sigma$ 与应变成正比：$\\sigma = E\\varepsilon$，其中 $E$ 是杨氏模量。\n\n节点力 $\\mathbf{f'} = [f'_1, f'_2]^T$ 与节点位移 $\\mathbf{u'}$ 之间的关系由局部单元刚度矩阵 $\\mathbf{k'}$ 给出，即 $\\mathbf{f'} = \\mathbf{k'}\\mathbf{u'}$。利用虚功原理或应变能方法，$\\mathbf{k'}$ 推导如下：\n$$ \\mathbf{k'} = \\int_V \\mathbf{B}^T E \\mathbf{B} \\,dV = A \\int_0^L \\mathbf{B}^T E \\mathbf{B} \\,dx' $$\n其中 $A$ 是横截面积。代入 $\\mathbf{B}$ 得：\n$$ \\mathbf{k'} = A \\int_0^L \\frac{1}{L^2} \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} E \\begin{pmatrix} -1  1 \\end{pmatrix} dx' = \\frac{AE}{L^2} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} \\int_0^L dx' = \\frac{AE}{L} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} $$\n这是杆单元在其局部坐标系中的标准 $2 \\times 2$ 刚度矩阵。\n\n### 2. 到全局坐标系的变换\n\n在二维分析中，每个节点 $i$ 有两个全局自由度 $(u_{ix}, u_{iy})$。单元的方向由其与全局 x 轴的夹角 $\\theta$ 定义，或等效地由其方向余弦定义：\n$$ c = \\cos\\theta = \\frac{x_j - x_i}{L} \\quad \\text{和} \\quad s = \\sin\\theta = \\frac{y_j - y_i}{L} $$\n其中节点 $i$ 和 $j$ 是单元的端点。\n\n节点的轴向位移是其全局位移向量在单元轴上的投影。因此，局部轴向位移 $u'_i$ 和 $u'_j$ 通过一个变换矩阵 $\\mathbf{T}$ 与全局位移 $\\mathbf{u}_e = [u_{ix}, u_{iy}, u_{jx}, u_{jy}]^T$ 相关联：\n$$ \\mathbf{u'} = \\begin{pmatrix} u'_i \\\\ u'_j \\end{pmatrix} = \\begin{pmatrix} c  s  0  0 \\\\ 0  0  c  s \\end{pmatrix} \\begin{pmatrix} u_{ix} \\\\ u_{iy} \\\\ u_{jx} \\\\ u_{jy} \\end{pmatrix} = \\mathbf{T}\\mathbf{u}_e $$\n功等效原理指出，全局力所做的功必须等于局部力所做的功，即 $\\mathbf{u'}^T\\mathbf{f'} = \\mathbf{u}_e^T\\mathbf{f}_e$。由此可得力的变换关系：$\\mathbf{f}_e = \\mathbf{T}^T\\mathbf{f'}$。\n\n代入这些关系，我们得到 $\\mathbf{f}_e = \\mathbf{T}^T(\\mathbf{k'}\\mathbf{u'}) = \\mathbf{T}^T\\mathbf{k'}(\\mathbf{T}\\mathbf{u}_e)$。因此，全局坐标系中的单元刚度矩阵 $\\mathbf{k}_e$ 是：\n$$ \\mathbf{k}_e = \\mathbf{T}^T\\mathbf{k'}\\mathbf{T} $$\n执行该矩阵乘法：\n$$ \\mathbf{k}_e = \\frac{AE}{L} \\begin{pmatrix} c  0 \\\\ s  0 \\\\ 0  c \\\\ 0  s \\end{pmatrix} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} \\begin{pmatrix} c  s  0  0 \\\\ 0  0  c  s \\end{pmatrix} = \\frac{AE}{L} \\begin{pmatrix}\nc^2  cs  -c^2  -cs \\\\\ncs  s^2  -cs  -s^2 \\\\\n-c^2  -cs  c^2  cs \\\\\n-cs  -s^2  cs  s^2\n\\end{pmatrix} $$\n该矩阵是对称的，并正确地关联了单元的四个全局自由度。$\\mathbf{k}_e$ 的一个关键特性是，任何行或列的元素之和均为零。这确保了均匀平移（所有节点具有相同的位移 $(t_x, t_y)$）导致净力为零，因为 $\\mathbf{k}_e [t_x, t_y, t_x, t_y]^T = \\mathbf{0}$。该公式对于无穷小旋转也正确地产生零力，因为单元长度的净变化在一阶上为零。\n\n### 3. “有缺陷”的变换和伪刚度\n\n该问题引入了一个错误的变换矩阵 $\\mathbf{T}_{bug}$，其中第二个节点（节点 $j$）投影的正弦项符号被翻转：\n$$ \\mathbf{T}_{bug} = \\begin{pmatrix} c  s  0  0 \\\\ 0  0  c  -s \\end{pmatrix} $$\n这个看似微小的符号错误对应于一个不一致的几何假设。由此产生的“有缺陷”的单元刚度矩阵 $\\mathbf{k}_{e,bug}$ 的推导方式类似：\n$$ \\mathbf{k}_{e,bug} = \\mathbf{T}_{bug}^T \\mathbf{k'} \\mathbf{T}_{bug} $$\n让我们定义一个向量 $\\mathbf{v}_{bug} = (\\begin{pmatrix}1  -1\\end{pmatrix} \\mathbf{T}_{bug})^T = [c, s, -c, s]^T$。那么，有缺陷的刚度矩阵是外积 $\\mathbf{k}_{e,bug} = \\frac{AE}{L} \\mathbf{v}_{bug}\\mathbf{v}_{bug}^T$，其结果是：\n$$ \\mathbf{k}_{e,bug} = \\frac{AE}{L} \\begin{pmatrix}\nc^2  cs  -c^2  cs \\\\\ncs  s^2  -cs  s^2 \\\\\n-c^2  -cs  c^2  -cs \\\\\ncs  s^2  -cs  s^2\n\\end{pmatrix} $$\n虽然这个矩阵仍然是对称的，但它不再具有行和为零的特性。任何一行的和都与 $2s$ 成正比。具体来说，第 $i$ 行的和与 $(\\mathbf{v}_{bug})_i \\sum_j (\\mathbf{v}_{bug})_j = (\\mathbf{v}_{bug})_i (c+s-c+s) = 2s(\\mathbf{v}_{bug})_i$ 成正比。如果 $s \\neq 0$，这个和就非零。因此，当施加均匀平移时，$\\mathbf{k}_{e,bug} [t_x, t_y, t_x, t_y]^T \\neq \\mathbf{0}$，产生伪假的、非物理的内力。这违反了平移不变性原理。类似的分析也显示其违反了旋转不变性。\n\n### 4. 系统组装与分析\n\n整个结构的全局刚度矩阵 $\\mathbf{K}$ 是通过根据所有单元刚度矩阵 $\\mathbf{k}_e$ 的节点连接性进行求和组装而成的。在给定的全局位移向量 $\\mathbf{u}$ 下，结构的总内力向量为 $\\mathbf{r} = \\mathbf{K}\\mathbf{u}$。\n\n该问题要求使用正确和有缺陷的刚度公式，计算三个桁架变体在平移和旋转两种情况下的内力向量的欧几里得范数 $\\|\\mathbf{r}\\|_2$。\n\n- **V1（旋转桁架）**：单元具有非零的 $s$ 值，因此该缺陷将在平移和旋转中都显现出来。\n- **V2（轴对齐桁架）**：单元与 x 轴对齐，因此所有单元的 $s = 0$。有缺陷的变换变得与正确的变换相同（$c \\pm s = c \\pm 0$），使得在这种配置下无法检测到该缺陷。$\\|\\mathbf{r}\\|_2$ 应为零。\n- **V3（近轴桁架）**：单元具有非常小但非零的 $s = \\varepsilon/L$。有缺陷的公式将产生微小但非零的伪力，展示了该错误对方向的敏感性。\n\n对于正确的公式，任何刚体运动（RBM）都必须满足 $\\|\\mathbf{K}_{corr}\\mathbf{u}_{RBM}\\|_2$ 为零（在浮点精度范围内）。对于有缺陷的公式，如果任何单元的 $s \\neq 0$，则 $\\|\\mathbf{K}_{bug}\\mathbf{u}_{RBM}\\|_2$ 将为非零，从而暴露其缺陷。以下程序实现了这个验证过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_element_stiffness(p1, p2, E, A, buggy):\n    \"\"\"\n    Computes the 4x4 element stiffness matrix in global coordinates.\n\n    Args:\n        p1 (tuple): Coordinates of the first node (x1, y1).\n        p2 (tuple): Coordinates of the second node (x2, y2).\n        E (float): Young's modulus.\n        A (float): Cross-sectional area.\n        buggy (bool): If True, use the buggy transformation matrix.\n\n    Returns:\n        numpy.ndarray: The 4x4 element stiffness matrix.\n    \"\"\"\n    dx = p2[0] - p1[0]\n    dy = p2[1] - p1[1]\n    L = np.sqrt(dx**2 + dy**2)\n\n    if np.isclose(L, 0):\n        return np.zeros((4, 4))\n\n    c = dx / L\n    s = dy / L\n\n    # Local 2x2 stiffness matrix\n    k_prime_factor = E * A / L\n    k_prime = k_prime_factor * np.array([[1, -1], [-1, 1]])\n\n    # Transformation matrix from global to local displacements\n    if buggy:\n        # Buggy transformation: flips the sign of 's' for the second node\n        T = np.array([[c, s, 0, 0], [0, 0, c, -s]])\n    else:\n        # Correct transformation\n        T = np.array([[c, s, 0, 0], [0, 0, c, s]])\n        \n    # Element stiffness matrix in global coordinates: k_e = T.T @ k_prime @ T\n    k_e = T.T @ k_prime @ T\n    \n    return k_e\n\ndef assemble_global_stiffness(nodes, elements, E, A, buggy):\n    \"\"\"\n    Assembles the global stiffness matrix for the truss structure.\n\n    Args:\n        nodes (list of tuples): List of nodal coordinates.\n        elements (list of tuples): List of elements defined by node indices.\n        E (float): Young's modulus.\n        A (float): Cross-sectional area.\n        buggy (bool): If True, use the buggy element stiffness formulation.\n\n    Returns:\n        numpy.ndarray: The global stiffness matrix.\n    \"\"\"\n    num_nodes = len(nodes)\n    num_dofs = 2 * num_nodes\n    K = np.zeros((num_dofs, num_dofs))\n\n    for n1, n2 in elements:\n        p1 = nodes[n1]\n        p2 = nodes[n2]\n        k_e = get_element_stiffness(p1, p2, E, A, buggy)\n\n        # Map local DOFs to global DOFs\n        dof_map = [2 * n1, 2 * n1 + 1, 2 * n2, 2 * n2 + 1]\n        \n        # Add element stiffness to global matrix\n        for i_local in range(4):\n            for j_local in range(4):\n                i_global = dof_map[i_local]\n                j_global = dof_map[j_local]\n                K[i_global, j_global] += k_e[i_local, j_local]\n    \n    return K\n\ndef get_displacement_vectors(nodes, t_vec, phi):\n    \"\"\"\n    Generates global displacement vectors for rigid-body motions.\n\n    Args:\n        nodes (list of tuples): List of nodal coordinates.\n        t_vec (tuple): Translation vector (tx, ty).\n        phi (float): Infinitesimal rotation angle in radians.\n\n    Returns:\n        tuple: (u_translation, u_rotation) as numpy arrays.\n    \"\"\"\n    num_nodes = len(nodes)\n    num_dofs = 2 * num_nodes\n    u_trans = np.zeros(num_dofs)\n    u_rot = np.zeros(num_dofs)\n\n    tx, ty = t_vec\n    for i, (x, y) in enumerate(nodes):\n        # Uniform translation\n        u_trans[2 * i] = tx\n        u_trans[2 * i + 1] = ty\n        \n        # Infinitesimal rotation about the origin\n        u_rot[2 * i] = -phi * y\n        u_rot[2 * i + 1] = phi * x\n        \n    return u_trans, u_rot\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem's requirements.\n    \"\"\"\n    # Physical and motion parameters\n    E = 7.0e10  # Pa\n    A = 1.0e-4  # m^2\n    translation_vec = (0.123, -0.456)  # m\n    rotation_angle = 0.2  # rad\n    epsilon = 1.0e-6 # m\n\n    # Define truss variants\n    variants = {\n        \"V1\": {\n            \"nodes\": [(0.0, 0.0), (1.0, 1.0), (1.0, -1.0)],\n            \"elements\": [(0, 1), (0, 2)],\n        },\n        \"V2\": {\n            \"nodes\": [(0.0, 0.0), (1.0, 0.0), (-1.0, 0.0)],\n            \"elements\": [(0, 1), (0, 2)],\n        },\n        \"V3\": {\n            \"nodes\": [(0.0, 0.0), (1.0, epsilon), (-1.0, epsilon)],\n            \"elements\": [(0, 1), (0, 2)],\n        },\n    }\n\n    results = []\n\n    # --- Variant V1: Rotated Truss ---\n    v1_spec = variants[\"V1\"]\n    v1_nodes = v1_spec[\"nodes\"]\n    v1_elements = v1_spec[\"elements\"]\n    u_trans_v1, u_rot_v1 = get_displacement_vectors(v1_nodes, translation_vec, rotation_angle)\n\n    # Correct transformation\n    K_corr_v1 = assemble_global_stiffness(v1_nodes, v1_elements, E, A, buggy=False)\n    r_corr_trans_v1 = K_corr_v1 @ u_trans_v1\n    r_corr_rot_v1 = K_corr_v1 @ u_rot_v1\n    results.append(np.linalg.norm(r_corr_trans_v1))\n    results.append(np.linalg.norm(r_corr_rot_v1))\n\n    # Buggy transformation\n    K_bug_v1 = assemble_global_stiffness(v1_nodes, v1_elements, E, A, buggy=True)\n    r_bug_trans_v1 = K_bug_v1 @ u_trans_v1\n    r_bug_rot_v1 = K_bug_v1 @ u_rot_v1\n    results.append(np.linalg.norm(r_bug_trans_v1))\n    results.append(np.linalg.norm(r_bug_rot_v1))\n    \n    # --- Variant V2: Axis-Aligned Truss ---\n    v2_spec = variants[\"V2\"]\n    v2_nodes = v2_spec[\"nodes\"]\n    v2_elements = v2_spec[\"elements\"]\n    u_trans_v2, u_rot_v2 = get_displacement_vectors(v2_nodes, translation_vec, rotation_angle)\n\n    # Buggy transformation (Correct is guaranteed to be 0)\n    K_bug_v2 = assemble_global_stiffness(v2_nodes, v2_elements, E, A, buggy=True)\n    r_bug_trans_v2 = K_bug_v2 @ u_trans_v2\n    r_bug_rot_v2 = K_bug_v2 @ u_rot_v2\n    results.append(np.linalg.norm(r_bug_trans_v2))\n    results.append(np.linalg.norm(r_bug_rot_v2))\n\n    # --- Variant V3: Near-Axis-Aligned Truss ---\n    v3_spec = variants[\"V3\"]\n    v3_nodes = v3_spec[\"nodes\"]\n    v3_elements = v3_spec[\"elements\"]\n    u_trans_v3, u_rot_v3 = get_displacement_vectors(v3_nodes, translation_vec, rotation_angle)\n\n    # Buggy transformation\n    K_bug_v3 = assemble_global_stiffness(v3_nodes, v3_elements, E, A, buggy=True)\n    r_bug_trans_v3 = K_bug_v3 @ u_trans_v3\n    r_bug_rot_v3 = K_bug_v3 @ u_rot_v3\n    results.append(np.linalg.norm(r_bug_trans_v3))\n    results.append(np.linalg.norm(r_bug_rot_v3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "3602998"}, {"introduction": "掌握了如何构建并验证正确的刚度矩阵后，我们可以运用这些工具来探究更复杂的结构行为，例如不稳定性。当一个结构存在机构（mechanism）时，其全局刚度矩阵会变得奇异。本练习[@problem_id:3602983]将教你如何通过系统地减弱单元刚度来模拟机构模式的出现，并使用奇异值分解（SVD）和$\\text{LDL}^{\\mathsf{T}}$分解等高级数值方法来诊断和追踪这些模式，从而深入理解刚度矩阵的数学性质与其所代表的物理意义之间的深刻联系。", "problem": "要求您设计并实现一个完整的计算程序，该程序为一个小平面桁架构建、分解和分析其缩减后的全局刚度矩阵，其中选定的轴向刚度被驱动趋近于零，以揭示机构模态。您的推导和算法必须从线弹性力学和能量法的基本原理出发，而不是直接引用现成的有限元公式。物理背景是一个具有三个节点和两个杆单元的二维桁架。桁架的几何形状和支座是固定的，而杆的轴向刚度在一系列测试中会发生变化，以引发近奇异行为。\n\n物理模型和几何数据：\n- 节点坐标：节点 $1$ 位于 $(x_1,y_1)=(0,0)$，节点 $2$ 位于 $(x_2,y_2)=(L,0)$，节点 $3$ 位于 $(x_3,y_3)=\\left(\\frac{L}{2},H\\right)$，其中 $L0$ 且 $H0$。\n- 单元：杆 $(1,3)$ 和杆 $(2,3)$。\n- 支座：节点 $1$ 在 $x$ 和 $y$ 方向上均被完全约束；节点 $2$ 仅在 $y$ 方向上被约束；节点 $2$ 在 $x$ 方向上自由；节点 $3$ 在两个方向上均自由。\n- 材料-几何参数化：给定一个基础轴向刚度 $E A_0$，并定义单元 $(1,3)$ 的轴向刚度为 $E A_{13}=\\alpha E A_0$，单元 $(2,3)$ 的轴向刚度为 $E A_{23}=\\beta E A_0$，其中 $\\alpha0$ 且 $\\beta0$。这些比例因子将在测试套件中变化，以模拟将选定的 $E A \\to 0$ 的过程。\n\n您必须使用的基本原理：\n- 一维线弹性力学：轴向应力 $\\sigma=E\\varepsilon$，轴向应变 $\\varepsilon=\\frac{du}{dx}$，轴向力 $N=E A\\varepsilon$，以及准静态条件下的线性动量守恒。\n- 虚功原理：在没有体力的情况下，对于任何运动学上容许的虚位移场，内虚功等于外虚功，这代表了平衡状态。\n- 小位移体系下铰接杆的运动学：节点位移在杆件轴线上的投影产生轴向伸长，结合线弹性力学，可以得到杆的轴向力以及相应的协调节点力。\n\n任务要求：\n1) 从虚功原理和上述定义出发，推导二维铰接杆的单元刚度算子。展示杆件方向余弦如何引入，以及算子如何在不直接引用任何最终公式的情况下在局部坐标和全局坐标之间进行转换。然后，说明如何通过叠加和消除给定支座条件下的约束自由度来组装缩减后的全局刚度矩阵 $K_r(\\alpha,\\beta;L,H,E A_0)$。\n2) 解释 $K_r$ 的零空间如何表征机构模态，以及将选定的 $E A \\to 0$ 如何引入额外的机构方向。提出一个使用秩揭示分解来跟踪演变中的零空间的数值程序。您必须：\n   - 使用奇异值分解 (SVD) 来确定数值秩 $r$ 和一个相应的零空间标准正交基。\n   - 根据最大奇异值定义一个显式容差 $\\tau$，使得小于或等于 $\\tau$ 的奇异值被视为空值。使用 $\\tau = n\\,\\epsilon_0\\,\\sigma_{\\max}$，其中 $n$ 是 $K_r$ 的缩减维度，$\\epsilon_0=10^{-10}$，$\\sigma_{\\max}$ 是 $K_r$ 的最大奇异值。\n   - 通过比率 $\\rho=\\frac{\\sigma_{\\min}}{\\sigma_{\\max}}$ 来量化条件数，如果 $\\sigma_{\\max}=0$，则取 $\\rho=0$。\n3) 应用一种带有稳健主元选择的对称不定分解，并讨论其在接近奇异点时的作用。具体来说：\n   - 使用带有对称主元选择的下三角-对角-下三角转置（$\\text{LDL}^{\\mathsf{T}}$）分解来揭示小主元。解释为什么车步 (rook) 或 Bunch–Kaufman 主元选择策略在这种情况下是稳健的。\n   - 从块对角因子 $D$ 中，计算一个标量主元诊断值：其 $1\\times 1$ 和 $2\\times 2$ 块的最小绝对特征值。这个量具有刚度的单位，并指示与奇异性的接近程度。\n4) 通过计算连续零空间之间的最大主交角，来跟踪测试套件中机构子空间的演化。最大主交角以度为单位报告。如果任一零空间是平凡的（维度为 $0$），则按惯例将角度定义为 $0$。使用由欧几里得内积导出的子空间之间主交角的标准定义。\n\n数值测试套件和单位：\n- 使用 $E A_0 = 10^7$ 牛顿作为基础轴向刚度。长度单位必须是米。\n- 将测试套件定义为以下四个参数集 $(L,H,\\alpha,\\beta)$：\n  - 情况 A：$(2,1,1,1)$。\n  - 情况 B：$(2,1,1,10^{-12})$。\n  - 情况 C：$(2,1,10^{-12},10^{-12})$。\n  - 情况 D：$(2,10^{-3},1,1)$。\n- 对每种情况，组装 $K_r$ 并计算：\n  - 基于 SVD 的数值秩 $r$，\n  - 零度 $n-r$，其中 $n$ 是 $K_r$ 的大小，\n  - 比率 $\\rho=\\sigma_{\\min}/\\sigma_{\\max}$，\n  - 从 $\\text{LDL}^{\\mathsf{T}}$ 分解的 $D$ 块中提取的最小绝对主元大小。\n- 单位：任何从刚度派生出的量（例如，来自 $\\text{LDL}^{\\mathsf{T}}$ 分解的主元）必须以牛顿/米表示，即 $\\mathrm{N/m}$。比率是无量纲的。角度必须以度为单位报告。\n\n输出规格：\n- 您的程序必须生成单行文本，其中包含按 $A,B,C,D$ 顺序排列的四个测试用例的结果列表。每个用例的结果必须是 $[r,\\text{nullity},\\rho,\\text{pivot\\_min},\\theta_{\\max}]$ 形式的列表，其中 $r$ 和 $\\text{nullity}$ 是整数，$\\rho$ 是浮点数，$\\text{pivot\\_min}$ 是以 $\\mathrm{N/m}$ 为单位的浮点数，$\\theta_{\\max}$ 是如上定义的以度为单位的浮点数。将各用例的结果聚合到一个列表中，并将总体结果打印为没有空格的单行，例如：\n  - $[[r_A,\\text{nullity}_A,\\rho_A,\\text{pivot\\_min}_A,\\theta_{\\max,A}],[r_B,\\text{nullity}_B,\\rho_B,\\text{pivot\\_min}_B,\\theta_{\\max,B}],\\ldots]$。", "solution": "该问题要求推导并实现一个计算程序，用于分析一个平面桁架系统。分析的重点是缩减后的全局刚度矩阵 $K_r$，及其在单元轴向刚度变化时的奇异性、零空间、条件数和主元特性。\n\n### 第1部分：单元刚度矩阵与系统组装\n\n单个二维杆（桁架）单元的刚度矩阵可以从虚功原理（PVW）推导得出。该原理指出，对于处于平衡状态的物体，对于任何运动学上容许的虚位移场，内虚功（$\\delta W_{int}$）等于外虚功（$\\delta W_{ext}$）。\n\n考虑一个长度为 $L_e$、横截面积为 $A$、杨氏模量为 $E$ 的杆单元。该单元连接节点 $i$ 和 $j$。全局坐标系中的节点位移向量为 $\\mathbf{d}_e = [u_i, v_i, u_j, v_j]^T$。在小位移情况下，杆的轴向伸长量 $\\Delta L$ 是节点位移在杆轴线上的投影。设杆与全局 $x$ 轴的夹角为 $\\theta$。方向余弦为 $c = \\cos\\theta$ 和 $s = \\sin\\theta$。伸长量为：\n$$ \\Delta L = (u_j - u_i)c + (v_j - v_i)s $$\n这可以写成矩阵形式 $\\Delta L = \\mathbf{a}^T \\mathbf{d}_e$，其中运动学向量 $\\mathbf{a}$ 为 $\\mathbf{a} = [-c, -s, c, s]^T$。\n\n外虚功由节点力 $\\mathbf{f}_e = [f_{ix}, f_{iy}, f_{jx}, f_{jy}]^T$ 在虚位移 $\\delta \\mathbf{d}_e$ 下完成：\n$$ \\delta W_{ext} = \\mathbf{f}_e^T \\delta \\mathbf{d}_e $$\n内虚功由轴向力 $N$ 在虚伸长量 $\\delta(\\Delta L)$ 下完成：\n$$ \\delta W_{int} = N \\, \\delta(\\Delta L) $$\n根据运动学，虚伸长量为 $\\delta(\\Delta L) = \\mathbf{a}^T \\delta \\mathbf{d}_e$。\n通过虚功原理使内、外虚功相等：\n$$ N \\, \\mathbf{a}^T \\delta \\mathbf{d}_e = \\mathbf{f}_e^T \\delta \\mathbf{d}_e $$\n由于此式对任意虚位移 $\\delta \\mathbf{d}_e$ 均成立，我们得到轴向力与节点力之间的关系：\n$$ \\mathbf{f}_e = N \\mathbf{a} $$\n根据一维线弹性力学，轴向力 $N$ 与伸长量 $\\Delta L$ 通过本构关系 $N = EA\\varepsilon = EA \\frac{\\Delta L}{L_e}$ 相关联。代入运动学关系 $\\Delta L = \\mathbf{a}^T \\mathbf{d}_e$：\n$$ N = \\frac{EA}{L_e} (\\mathbf{a}^T \\mathbf{d}_e) $$\n将此 $N$ 的表达式代回节点力方程，得到刚度关系 $\\mathbf{f}_e = \\mathbf{k}_e \\mathbf{d}_e$：\n$$ \\mathbf{f}_e = \\left( \\frac{EA}{L_e} \\mathbf{a}^T \\mathbf{d}_e \\right) \\mathbf{a} = \\left( \\frac{EA}{L_e} \\mathbf{a} \\mathbf{a}^T \\right) \\mathbf{d}_e $$\n因此，全局坐标系下的单元刚度矩阵 $\\mathbf{k}_e$ 为：\n$$ \\mathbf{k}_e = \\frac{EA}{L_e} \\mathbf{a} \\mathbf{a}^T = \\frac{EA}{L_e} \\begin{bmatrix} c^2  cs  -c^2  -cs \\\\ cs  s^2  -cs  -s^2 \\\\ -c^2  -cs  c^2  cs \\\\ -cs  -s^2  cs  s^2 \\end{bmatrix} $$\n该系统由三个节点和两个单元组成。全局位移向量有 6 个自由度（DOFs）：$\\mathbf{U} = [u_1, v_1, u_2, v_2, u_3, v_3]^T$。边界条件为 $u_1=0$、$v_1=0$ 和 $v_2=0$。这留下了三个自由自由度：$u_2$、$u_3$ 和 $v_3$。缩减后的位移向量为 $\\mathbf{U}_r = [u_2, u_3, v_3]^T$。\n\n缩减后的全局刚度矩阵 $K_r$ 是通过将每个单元矩阵的贡献求和到全局矩阵 $K$ 中，然后提取与自由自由度对应的子矩阵来组装的。\n- 单元 (1,3)：连接节点 $1$（自由度 $1,2$）和节点 $3$（自由度 $5,6$）。轴向刚度 $EA_{13} = \\alpha E A_0$。\n- 单元 (2,3)：连接节点 $2$（自由度 $3,4$）和节点 $3$（自由度 $5,6$）。轴向刚度 $EA_{23} = \\beta E A_0$。\n\n几何由节点 $1(0,0)$、$2(L,0)$ 和 $3(L/2,H)$ 定义。\n- 对于单元 (1,3)：长度 $L_{13} = \\sqrt{(L/2)^2 + H^2}$。方向余弦 $c_{13} = (L/2)/L_{13}$，$s_{13} = H/L_{13}$。\n- 对于单元 (2,3)：长度 $L_{23} = \\sqrt{(-L/2)^2 + H^2} = L_{13}$。方向余弦 $c_{23} = (-L/2)/L_{23} = -c_{13}$，$s_{23} = H/L_{23}=s_{13}$。\n\n令 $L_e = L_{13}$，$c = c_{13}$ 和 $s = s_{13}$。关联自由度 $(u_2, u_3, v_3)$ 的力和位移的 $3 \\times 3$ 缩减矩阵 $K_r(\\alpha,\\beta;L,H,E A_0)$ 构建如下：\n$$ K_r = \\frac{E A_0}{L_e} \\begin{bmatrix} \\beta c^2  -\\beta c^2  \\beta cs \\\\ -\\beta c^2  (\\alpha + \\beta) c^2  (\\alpha - \\beta) cs \\\\ \\beta cs  (\\alpha - \\beta) cs  (\\alpha + \\beta) s^2 \\end{bmatrix} $$\n分析表明，对于所有参数值，此矩阵的行列式恒为零，这表明该结构具有一个固有的机构模态。其零度至少为 $1$。\n\n### 第2部分：通过 SVD 进行零空间分析\n\n$K_r$ 的零空间由位移向量 $\\mathbf{U}_r$ 组成，对于这些位移，恢复力 $K_r \\mathbf{U}_r$ 为零。这些向量代表结构的刚体运动或机构模态，它们不产生任何应变能。将轴向刚度 $EA$ 驱动至零（例如，通过 $\\alpha \\to 0$ 或 $\\beta \\to 0$）等同于移除一根杆，这会引入新的机构，并增加零空间的维度。\n\n奇异值分解 (SVD)，$K_r = U S V^H$，是分析矩阵秩的稳健数值工具。对于实对称矩阵 $K_r$，$K_r = U S U^T$，其中 $U$ 是由特征向量构成的正交矩阵，$S$ 是由奇异值（$\\sigma_i$）构成的对角矩阵，这些奇异值是特征值的绝对值。\n数值程序如下：\n1.  计算 $K_r$ 的 SVD，得到奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_n \\ge 0$。\n2.  定义一个容差 $\\tau = n \\epsilon_0 \\sigma_{\\max}$，其中 $n=3$，$\\epsilon_0=10^{-10}$，$\\sigma_{\\max} = \\sigma_1$。\n3.  数值秩 $r$ 是大于 $\\tau$ 的奇异值 $\\sigma_i$ 的数量。零度为 $n-r$。\n4.  与奇异值 $\\sigma_i \\le \\tau$ 对应的 $U$ 的列构成了数值零空间的标准正交基。\n5.  条件数通过比率 $\\rho = \\sigma_{\\min}/\\sigma_{\\max}$ 来衡量，其中 $\\sigma_{\\min}=\\sigma_n$。\n\n### 第3部分：对称不定分解 (LDL$^\\mathsf{T}$)\n\n$\\text{LDL}^{\\mathsf{T}}$ 分解将一个对称矩阵 $A$ 分解为 $P A P^T = L D L^T$，其中 $P$ 是一个置换矩阵，$L$ 是单位下三角矩阵，$D$ 是由 $1 \\times 1$ 和 $2 \\times 2$ 块组成的块对角矩阵。这是对称高斯消元法的一种形式。\n在接近奇异时，标准的 Cholesky ($LL^T$) 分解对非正定矩阵会失败，而标准的 LU 分解在没有主元选择的情况下可能不稳定。像 Bunch-Kaufman（在 `scipy.linalg.ldl` 中使用）这样的稳健主元选择策略通过对称地交换行和列来保持稳定性，选择一个大的 $1 \\times 1$ 主元或一个稳定的 $2 \\times 2$ 主元。\n这种分解能揭示奇异性：一个秩亏矩阵在消元过程中会在 $D$ 中产生一个零的 $1 \\times 1$ 块或一个奇异的 $2 \\times 2$ 块。$D$ 中主元的大小是刚度和与奇异性接近程度的直接度量。一个小主元表示结构中存在一个“软”方向。\n一个标量主元诊断值被计算为因子 $D$ 的所有 $1 \\times 1$ 和 $2 \\times 2$ 块的最小绝对特征值。该值具有刚度单位（$\\mathrm{N/m}$），并提供了一个稳健的奇异性指标。\n\n### 第4部分：机构子空间的演化\n\n测试用例之间机构模态的变化通过它们各自刚度矩阵的零空间之间的最大主交角来量化。设 $Q_{k-1}$ 和 $Q_k$ 是列向量构成两个连续用例零空间标准正交基的矩阵。这些子空间之间主交角的余弦是矩阵 $M = Q_{k-1}^T Q_k$ 的奇异值。最大主交角 $\\theta_{\\max}$ 由 $\\theta_{\\max} = \\arccos(\\sigma_{\\min}(M))$ 给出，其中 $\\sigma_{\\min}(M)$ 是 $M$ 的最小奇异值。按照惯例，如果任一零空间是平凡的（维度为 $0$），则角度定义为 $0$ 度。这个角度衡量了新的零空间相对于前一个“旋转”了多少。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import ldl, svd\n\ndef solve():\n    \"\"\"\n    Solves the truss analysis problem for a series of test cases.\n    It computes the reduced stiffness matrix, performs SVD and LDLT analysis,\n    and tracks the evolution of the null-space (mechanisms).\n    \"\"\"\n\n    # Define physical constants and test cases\n    EA0 = 1.0e7  # N\n    epsilon0 = 1.0e-10\n\n    test_cases = {\n        'A': {'L': 2.0, 'H': 1.0, 'alpha': 1.0, 'beta': 1.0},\n        'B': {'L': 2.0, 'H': 1.0, 'alpha': 1.0, 'beta': 1.0e-12},\n        'C': {'L': 2.0, 'H': 1.0, 'alpha': 1.0e-12, 'beta': 1.0e-12},\n        'D': {'L': 2.0, 'H': 1.0e-3, 'alpha': 1.0, 'beta': 1.0},\n    }\n    \n    case_order = ['A', 'B', 'C', 'D']\n    results = []\n    \n    # Initialize the null-space from the previous step. Starts as a trivial (0-dim) space.\n    null_space_basis_prev = np.zeros((3, 0))\n\n    for case_name in case_order:\n        params = test_cases[case_name]\n        L, H, alpha, beta = params['L'], params['H'], params['alpha'], params['beta']\n\n        # 1. Assemble the reduced stiffness matrix Kr\n        if (L / 2)**2 + H**2 == 0:\n            # Avoid division by zero if L=0 and H=0\n            Kr = np.zeros((3, 3))\n        else:\n            Le = np.sqrt((L / 2)**2 + H**2)\n            c = (L / 2) / Le\n            s = H / Le\n            k_factor = EA0 / Le\n            Kr = k_factor * np.array([\n                [beta * c**2, -beta * c**2, beta * c * s],\n                [-beta * c**2, (alpha + beta) * c**2, (alpha - beta) * c * s],\n                [beta * c * s, (alpha - beta) * c * s, (alpha + beta) * s**2]\n            ])\n        \n        n = Kr.shape[0]\n\n        # 2. SVD analysis for rank, nullity, and conditioning\n        try:\n            U, s_vals, _ = svd(Kr)\n            sigma_max = s_vals[0] if s_vals.size > 0 else 0.0\n            sigma_min = s_vals[-1] if s_vals.size > 0 else 0.0\n        except np.linalg.LinAlgError:\n            s_vals = np.zeros(n)\n            sigma_max, sigma_min = 0.0, 0.0\n            U = np.eye(n)\n\n        rho = sigma_min / sigma_max if sigma_max > 0.0 else 0.0\n        tau = n * epsilon0 * sigma_max\n\n        numerical_rank = np.sum(s_vals > tau)\n        nullity = n - numerical_rank\n        \n        null_space_basis_curr = U[:, numerical_rank:]\n\n        # 3. LDL^T factorization for pivot diagnostic\n        pivot_min = 0.0\n        if not np.all(Kr == 0):\n            try:\n                # Use upper triangular part for factorization, so P A P' = L D L'\n                # scipy returns P' A P'T = L D LT for lower=False\n                _, D_fact, _ = ldl(Kr, lower=False)\n                \n                d_abs_eigs = []\n                i = 0\n                while i  n:\n                    # Check for 2x2 block indicated by off-diagonal element\n                    if i + 1  n and D_fact[i, i + 1] != 0:\n                        block = D_fact[i:i+2, i:i+2]\n                        # For a symmetric matrix, eigvalsh is efficient and stable\n                        eigs = np.linalg.eigvalsh(block)\n                        d_abs_eigs.extend(np.abs(eigs))\n                        i += 2\n                    else:\n                        # 1x1 block\n                        d_abs_eigs.append(np.abs(D_fact[i, i]))\n                        i += 1\n                \n                pivot_min = min(d_abs_eigs) if d_abs_eigs else 0.0\n            except (np.linalg.LinAlgError, ValueError):\n                pivot_min = 0.0\n\n        # 4. Principal angle calculation\n        theta_max = 0.0\n        dim_prev = null_space_basis_prev.shape[1]\n        dim_curr = null_space_basis_curr.shape[1]\n\n        if dim_prev > 0 and dim_curr > 0:\n            M = null_space_basis_prev.T @ null_space_basis_curr\n            cos_angles = svd(M, compute_uv=False)\n            \n            if cos_angles.size > 0:\n                min_cos_angle = np.min(cos_angles)\n                # Clip to handle potential floating point inaccuracies > 1.0\n                clipped_cos = np.clip(min_cos_angle, -1.0, 1.0)\n                theta_max = np.rad2deg(np.arccos(clipped_cos))\n\n        # Store results and update for next iteration\n        results.append([int(numerical_rank), int(nullity), rho, pivot_min, theta_max])\n        null_space_basis_prev = null_space_basis_curr\n    \n    # Format output as required: [[rA,n_A,...],[rB,n_B,...],...]\n    output_str = \"[\" + \",\".join([str(res) for res in results]) + \"]\"\n    output_str = output_str.replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3602983"}]}