{"hands_on_practices": [{"introduction": "在求解有限元问题之前，我们必须能够准确地将外部载荷施加到离散模型上。本练习将引导你基于虚功原理，把作用在单元边界上的连续分布力转化为一组等效的、在能量上与单元形函数协调一致的离散节点力[@problem_id:3583980]。这是建立任何结构分析问题的基本步骤，同时也能加深对数值积分精确性的理解。", "problem": "考虑一个用于计算固体力学的有限元法 (FEM) 中的二维等参九节点拉格朗日四边形单元（通常表示为 Q9 单元）。设自然坐标为 $\\xi$ 和 $\\eta$，通常的方形参考域为 $[-1,1] \\times [-1,1]$。假设该单元在物理空间中被映射为一个直边矩形，其右边对应于 $\\xi=1$ 且物理长度为 $L$，三个边节点位于 $\\eta=-1$, $\\eta=0$ 和 $\\eta=1$。该单元具有常数厚度 $b$。\n\n沿右边 $\\xi=1$ 施加一个面力，该力仅作用于 $x$ 方向，并由自然边坐标 $\\eta$ 的二次函数给出\n$$\nt_{x}(\\eta) = \\alpha + \\beta \\,\\eta + \\gamma \\,\\eta^{2},\n$$\n其中 $\\alpha$、$\\beta$ 和 $\\gamma$ 为常数。使用虚功原理中的基本边界项，推导该边上三个节点在 $x$ 方向上的一致性边节点力，并仅用 $\\alpha$、$\\beta$、$\\gamma$、$b$ 和 $L$ 表示。从第一性原理出发，直接根据与点 $\\eta=-1$、$\\eta=0$ 和 $\\eta=1$ 相关的一维二次 Lagrange 形函数的定义，构造沿该边的必要插值；不要引用任何预先给出的有限元公式。\n\n然后，验证这些积分可由具有精确性所需最少点数的一维 Gauss-Legendre 求积法则精确计算。您必须根据被积函数在该边上的多项式阶数以及 Gauss-Legendre 法则的精确性性质，来证明所选点数的合理性。\n\n将最终答案表示为对应于 $\\eta=-1$、$\\eta=0$ 和 $\\eta=1$ 的三个 $x$ 方向节点力的行向量，形式为闭式解析表达式。不需要进行数值代入，答案框中的最终表达式不应包含单位。", "solution": "该问题被认为是有效的，因为它具有科学依据、提法明确、客观，并包含获得唯一解所需的所有信息。\n\n一致性节点力的推导始于虚功原理。由面力矢量 $\\mathbf{t}$ 在表面 $S_t$ 上所做的外虚功 $\\delta W_{\\text{ext}}$，由该力与虚位移矢量 $\\delta\\mathbf{u}$ 的点积的积分给出：\n$$\n\\delta W_{\\text{ext}} = \\int_{S_t} \\delta\\mathbf{u}^T \\mathbf{t} \\, dS\n$$\n在这个二维问题中，力作用在 $\\xi=1$ 的边上，且仅作用于 $x$ 方向，即 $t_x(\\eta) = \\alpha + \\beta\\eta + \\gamma\\eta^2$。$x$ 方向的虚位移为 $\\delta u_x$。面元为 $dS = b \\, ds$，其中 $b$ 是常数厚度，$ds$ 是沿该边的弧长微分。虚功表达式简化为：\n$$\n\\delta W_{\\text{ext}} = \\int_{S_{\\text{edge}}} \\delta u_x(\\eta) t_x(\\eta) b \\, ds\n$$\n在有限元框架内，沿该边的位移场是通过使用形函数对节点位移进行插值得到的。所讨论的边有三个节点，对应于 $\\eta = -1$、$\\eta = 0$ 和 $\\eta = 1$。设它们的 $x$ 方向节点位移分别为 $d_{x1}$、$d_{x2}$ 和 $d_{x3}$，相应的一维形函数为 $N_1(\\eta)$、$N_2(\\eta)$ 和 $N_3(\\eta)$。沿该边的位移 $u_x$ 和虚位移 $\\delta u_x$ 为：\n$$\nu_x(\\eta) = N_1(\\eta)d_{x1} + N_2(\\eta)d_{x2} + N_3(\\eta)d_{x3} = \\sum_{i=1}^3 N_i(\\eta) d_{xi}\n$$\n$$\n\\delta u_x(\\eta) = N_1(\\eta)\\delta d_{x1} + N_2(\\eta)\\delta d_{x2} + N_3(\\eta)\\delta d_{x3} = \\sum_{i=1}^3 N_i(\\eta) \\delta d_{xi}\n$$\n将 $\\delta u_x$ 代入虚功表达式：\n$$\n\\delta W_{\\text{ext}} = \\int_{S_{\\text{edge}}} \\left( \\sum_{i=1}^3 N_i(\\eta) \\delta d_{xi} \\right) t_x(\\eta) b \\, ds\n$$\n由于虚节点位移 $\\delta d_{xi}$ 是任意的，并且相对于积分是常数，我们可以写出：\n$$\n\\delta W_{\\text\next}} = \\sum_{i=1}^3 \\delta d_{xi} \\left( \\int_{S_{\\text{edge}}} N_i(\\eta) t_x(\\eta) b \\, ds \\right)\n$$\n外虚功也定义为一致性节点力 $F_{xi}$ 与相应虚节点位移 $\\delta d_{xi}$ 的乘积之和：\n$$\n\\delta W_{\\text{ext}} = \\sum_{i=1}^3 F_{xi} \\delta d_{xi}\n$$\n通过比较 $\\delta W_{\\text{ext}}$ 的两个表达式，节点 $i$ 的一致性节点力为：\n$$\nF_{xi} = \\int_{S_{\\text{edge}}} N_i(\\eta) t_x(\\eta) b \\, ds\n$$\n问题陈述物理边是一条长度为 $L$ 的直线，对应于自然坐标 $\\eta$ 从 $-1$ 变化到 $1$。物理微分长度 $ds$ 和自然坐标微分 $d\\eta$ 之间的关系通过一维映射的雅可比行列式 $J_s = ds/d\\eta$ 找到。对于从 $[-1, 1]$ 到 $[0, L]$ 的线性映射，我们有 $s(\\eta) = \\frac{L}{2}(\\eta+1)$，因此 $J_s = ds/d\\eta = L/2$。积分为：\n$$\nF_{xi} = \\int_{-1}^{1} N_i(\\eta) t_x(\\eta) b \\left( \\frac{L}{2} \\right) d\\eta = \\frac{bL}{2} \\int_{-1}^{1} N_i(\\eta) t_x(\\eta) \\, d\\eta\n$$\n接下来，我们为位于 $\\eta_1=-1$、$\\eta_2=0$ 和 $\\eta_3=1$ 的节点构造一维二次 Lagrange 形函数。\n对于 $N_1(\\eta)$（位于 $\\eta=-1$ 的节点），它在 $\\eta=0$ 和 $\\eta=1$ 处必须为零。因此，$N_1(\\eta) = C_1(\\eta-0)(\\eta-1)$。应用条件 $N_1(-1)=1$ 可得 $C_1(-1)(-2)=1 \\implies C_1=1/2$。\n$$ N_1(\\eta) = \\frac{1}{2}\\eta(\\eta-1) = \\frac{1}{2}(\\eta^2-\\eta) $$\n对于 $N_2(\\eta)$（位于 $\\eta=0$ 的节点），它在 $\\eta=-1$ 和 $\\eta=1$ 处必须为零。因此，$N_2(\\eta) = C_2(\\eta+1)(\\eta-1)$。应用条件 $N_2(0)=1$ 可得 $C_2(1)(-1)=1 \\implies C_2=-1$。\n$$ N_2(\\eta) = -(\\eta^2-1) = 1-\\eta^2 $$\n对于 $N_3(\\eta)$（位于 $\\eta=1$ 的节点），它在 $\\eta=-1$ 和 $\\eta=0$ 处必须为零。因此，$N_3(\\eta) = C_3(\\eta+1)(\\eta-0)$。应用条件 $N_3(1)=1$ 可得 $C_3(2)(1)=1 \\implies C_3=1/2$。\n$$ N_3(\\eta) = \\frac{1}{2}\\eta(\\eta+1) = \\frac{1}{2}(\\eta^2+\\eta) $$\n现在我们计算每个节点力的积分。\n对于 $F_{x1}$：\n$$ F_{x1} = \\frac{bL}{2} \\int_{-1}^{1} \\frac{1}{2}(\\eta^2-\\eta)(\\alpha + \\beta\\eta + \\gamma\\eta^2) \\, d\\eta = \\frac{bL}{4} \\int_{-1}^{1} (\\gamma\\eta^4 + (\\beta-\\gamma)\\eta^3 + (\\alpha-\\beta)\\eta^2 - \\alpha\\eta) \\, d\\eta $$\n在对称区间 $[-1, 1]$ 上，奇次幂项（$\\eta^3$, $\\eta$）的积分为零。\n$$ F_{x1} = \\frac{bL}{4} \\int_{-1}^{1} (\\gamma\\eta^4 + (\\alpha-\\beta)\\eta^2) \\, d\\eta = \\frac{bL}{4} \\left[ \\gamma\\frac{\\eta^5}{5} + (\\alpha-\\beta)\\frac{\\eta^3}{3} \\right]_{-1}^{1} = \\frac{bL}{4} \\left( 2\\frac{\\gamma}{5} + 2\\frac{\\alpha-\\beta}{3} \\right) = \\frac{bL}{2} \\left( \\frac{3\\gamma + 5\\alpha - 5\\beta}{15} \\right) = \\frac{bL}{30}(5\\alpha - 5\\beta + 3\\gamma) $$\n对于 $F_{x2}$：\n$$ F_{x2} = \\frac{bL}{2} \\int_{-1}^{1} (1-\\eta^2)(\\alpha + \\beta\\eta + \\gamma\\eta^2) \\, d\\eta = \\frac{bL}{2} \\int_{-1}^{1} (-\\gamma\\eta^4 - \\beta\\eta^3 + (\\gamma-\\alpha)\\eta^2 + \\beta\\eta + \\alpha) \\, d\\eta $$\n同样，奇次幂项的积分为零。\n$$ F_{x2} = \\frac{bL}{2} \\int_{-1}^{1} (-\\gamma\\eta^4 + (\\gamma-\\alpha)\\eta^2 + \\alpha) \\, d\\eta = \\frac{bL}{2} \\left[ -\\gamma\\frac{\\eta^5}{5} + (\\gamma-\\alpha)\\frac{\\eta^3}{3} + \\alpha\\eta \\right]_{-1}^{1} = \\frac{bL}{2} \\left( -2\\frac{\\gamma}{5} + 2\\frac{\\gamma-\\alpha}{3} + 2\\alpha \\right) = bL \\left( -\\frac{\\gamma}{5} + \\frac{\\gamma-\\alpha}{3} + \\alpha \\right) $$\n$$ F_{x2} = bL \\left( \\frac{-3\\gamma + 5\\gamma - 5\\alpha + 15\\alpha}{15} \\right) = bL \\left( \\frac{10\\alpha + 2\\gamma}{15} \\right) = \\frac{bL}{30}(20\\alpha + 4\\gamma) $$\n对于 $F_{x3}$：\n$$ F_{x3} = \\frac{bL}{2} \\int_{-1}^{1} \\frac{1}{2}(\\eta^2+\\eta)(\\alpha + \\beta\\eta + \\gamma\\eta^2) \\, d\\eta = \\frac{bL}{4} \\int_{-1}^{1} (\\gamma\\eta^4 + (\\beta+\\gamma)\\eta^3 + (\\alpha+\\beta)\\eta^2 + \\alpha\\eta) \\, d\\eta $$\n奇次幂项的积分为零。\n$$ F_{x3} = \\frac{bL}{4} \\int_{-1}^{1} (\\gamma\\eta^4 + (\\alpha+\\beta)\\eta^2) \\, d\\eta = \\frac{bL}{4} \\left[ \\gamma\\frac{\\eta^5}{5} + (\\alpha+\\beta)\\frac{\\eta^3}{3} \\right]_{-1}^{1} = \\frac{bL}{4} \\left( 2\\frac{\\gamma}{5} + 2\\frac{\\alpha+\\beta}{3} \\right) = \\frac{bL}{2} \\left( \\frac{3\\gamma + 5\\alpha + 5\\beta}{15} \\right) = \\frac{bL}{30}(5\\alpha + 5\\beta + 3\\gamma) $$\n三个节点力为：\n$F_{x1} = \\frac{bL}{30}(5\\alpha - 5\\beta + 3\\gamma)$\n$F_{x2} = \\frac{bL}{30}(20\\alpha + 4\\gamma)$\n$F_{x3} = \\frac{bL}{30}(5\\alpha + 5\\beta + 3\\gamma)$\n\n现在我们必须验证这些积分能被具有最少点数的 Gauss-Legendre 求积法则精确计算。积分的一般形式为 $\\int_{-1}^1 f(\\eta) d\\eta$，其中被积函数为 $f(\\eta) = N_i(\\eta)t_x(\\eta)$。\n形函数 $N_i(\\eta)$ 是二次多项式。力函数 $t_x(\\eta)$ 也是二次多项式。因此，这两者的乘积 $f(\\eta) = N_i(\\eta)t_x(\\eta)$ 是一个阶数为 $p=2+2=4$ 的多项式。\n一个具有 $n$ 个点的 Gauss-Legendre 求积法则可以精确积分最高为 $2n-1$ 阶的多项式。为确保我们的四阶多项式能够被精确积分，必须满足以下条件：\n$2n - 1 \\ge 4$\n$2n \\ge 5$\n$n \\ge 2.5$\n由于求积点数 $n$ 必须是整数，因此确保精确性所需的最少点数为 $n=3$。因此，三点 Gauss-Legendre 求积法则是能够精确计算一致性节点力积分的最少点数法则。验证到此完成。\n\n最终答案是这三个节点力的行向量。我们可以提取公因式 $\\frac{bL}{30}$。\n这三个力是 $\\frac{bL}{30}(5\\alpha - 5\\beta + 3\\gamma)$、$\\frac{bL}{30}(20\\alpha + 4\\gamma)$ 和 $\\frac{bL}{30}(5\\alpha + 5\\beta + 3\\gamma)$。", "answer": "$$\n\\boxed{\\frac{bL}{30} \\begin{pmatrix} 5\\alpha - 5\\beta + 3\\gamma & 20\\alpha + 4\\gamma & 5\\alpha + 5\\beta + 3\\gamma \\end{pmatrix}}\n$$", "id": "3583980"}, {"introduction": "一个合格的有限元单元必须能够准确地描述最基本的变形状态，即刚体位移和恒定应变场。本练习将指导你实现“膜片检验”（Patch Test）这一关键的质量验证方法，以检验Q9单元是否满足这个基本要求[@problem_id:3583985]。你还将通过一系列测试案例，探索单元几何扭曲如何导致雅可比行列式 $\\det \\mathbf{J} \\le 0$，从而使得等参映射失效并破坏单元的准确性，这对于理解网格质量的重要性至关重要。", "problem": "考虑定义在参考方域 $[-1,1] \\times [-1,1]$ 上的二维九节点等参拉格朗日四边形单元，其局部坐标为 $(\\xi,\\eta)$。九个节点位于 $(\\xi,\\eta) \\in \\{(-1,-1),(0,-1),(1,-1),(-1,0),(0,0),(1,0),(-1,1),(0,1),(1,1)\\}$，并按以下顺序索引：$k=0 \\rightarrow (-1,-1)$，$k=1 \\rightarrow (0,-1)$，$k=2 \\rightarrow (1,-1)$，$k=3 \\rightarrow (-1,0)$，$k=4 \\rightarrow (0,0)$，$k=5 \\rightarrow (1,0)$，$k=6 \\rightarrow (-1,1)$，$k=7 \\rightarrow (0,1)$，$k=8 \\rightarrow (1,1)$。设节点 $k$ 的物理坐标为 $(X_k,Y_k)$。\n\n您必须构造一维二次拉格朗日多项式 $L_i(\\xi)$ 和 $L_j(\\eta)$（其中 $i,j \\in \\{-1,0,1\\}$），然后形成九节点拉格朗日形函数\n$$\nN_{ij}(\\xi,\\eta) = L_i(\\xi)\\,L_j(\\eta), \\quad i,j \\in \\{-1,0,1\\}。\n$$\n使用这些形函数来实现标准的等参映射\n$$\nx(\\xi,\\eta) = \\sum_{a=0}^{8} N_a(\\xi,\\eta)\\,X_a, \\quad y(\\xi,\\eta) = \\sum_{a=0}^{8} N_a(\\xi,\\eta)\\,Y_a,\n$$\n其中 $N_a(\\xi,\\eta)$ 表示在所述编号顺序下与节点 $a$ 相关联的形函数。计算雅可比矩阵\n$$\n\\mathbf{J}(\\xi,\\eta) = \n\\begin{bmatrix}\n\\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\\n\\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta}\n\\end{bmatrix},\n$$\n及其在每个坐标方向上横坐标为 $\\{-\\sqrt{3/5},\\,0,\\,\\sqrt{3/5}\\}$ 的 $3 \\times 3$ Gauss–Legendre 求积点上的行列式 $\\det \\mathbf{J}(\\xi,\\eta)$。\n\n对于分片检验 (patch test)，考虑一个标量位移场（这足以验证有限元法 (FEM) 中的常应变再现能力）\n$$\nu(x,y) = a + b\\,x + c\\,y,\n$$\n其中 $a$、$b$ 和 $c$ 为给定常数。定义节点值为 $u_a = u(X_a,Y_a)$。使用构造的形函数和链式法则，计算在 $3 \\times 3$ Gauss 点处的梯度 $\\nabla u$，并与精确的常数梯度 $\\nabla u_{\\text{exact}} = [\\,b,\\,c\\,]^T$ 进行比较。当且仅当两个条件同时满足时，检验通过：\n- 在所有 Gauss 点处 $\\det \\mathbf{J}(\\xi,\\eta) > 0$，并且\n- 在所有 Gauss 点上，计算出的梯度与精确梯度之间的最大分量绝对误差小于 $10^{-10}$ 的容差。\n\n您还必须识别出当任何 Gauss 点处的 $\\det \\mathbf{J}(\\xi,\\eta) \\le 0$ 时的失效条件，这种情况会使等参映射无效并导致分片检验失败。\n\n实现一个完整、可运行的程序，该程序：\n- 从拉格朗日插值的基本原理构造 $L_i(\\xi)$ 和 $L_j(\\eta)$（其中 $i,j \\in \\{-1,0,1\\}$），\n- 构建 $N_{ij}(\\xi,\\eta)$ 及其关于 $\\xi$ 和 $\\eta$ 的导数，\n- 通过 $\\mathbf{J}$ 的逆矩阵计算 $\\mathbf{J}(\\xi,\\eta)$、其行列式以及梯度 $\\nabla u$，\n- 按照所述评估分片检验的通过/失败情况。\n\n此问题不涉及物理单位或角度单位。\n\n测试套件：\n使用以下四个测试用例，所有用例均针对单个九节点单元定义。在每个用例中，节点顺序 $k=0,\\dots,8$ 对应于本问题开头列出的 $(\\xi,\\eta)$ 位置。\n\n- 测试用例 1 (随机轻度扭曲)：从单位正方形开始，其角点 $(0,0)$、$(1,0)$、$(0,1)$、$(1,1)$ 分别分配给 $k \\in \\{0,2,6,8\\}$，边中点节点位于边的中点，中心点位于 $(0.5,0.5)$。使用种子为 $42$ 的伪随机数生成器，在 $x$ 和 $y$ 方向上对边中点和中心点添加 $[-0.1,0.1]$ 区间内的独立均匀扰动，仅扰动这些点。角点保持固定。\n- 测试用例 2 (蝶形自相交)：分配角点以产生一个自相交的四边形：$k=0 \\rightarrow (0,0)$，$k=2 \\rightarrow (1,0)$，$k=6 \\rightarrow (1,1)$，$k=8 \\rightarrow (0,1)$。将边中点节点设置在相应（可能交叉）边的中点上：$k=1 \\rightarrow (0.5,0)$，$k=3 \\rightarrow (0.5,0.5)$，$k=5 \\rightarrow (0.5,0.5)$，$k=7 \\rightarrow (0.5,1)$，中心点为 $k=4 \\rightarrow (0.5,0.5)$。\n- 测试用例 3 (随机强扭曲但尝试非反转)：与测试用例 1 的基础单位正方形相同，但使用种子为 7，对边中点和中心点施加 $[-0.45,0.45]$ 区间内的均匀扰动。角点保持固定。\n- 测试用例 4 (塌缩的底边)：设置 $k=0 \\rightarrow (0,0)$，$k=2 \\rightarrow (0,0)$，底边中点 $k=1 \\rightarrow (0,0)$，左边中点 $k=3 \\rightarrow (0,0.5)$，右边中点 $k=5 \\rightarrow (0.5,0.5)$，顶边中点 $k=7 \\rightarrow (0.5,1)$，左上角点 $k=6 \\rightarrow (0,1)$，右上角点 $k=8 \\rightarrow (1,1)$，中心点 $k=4 \\rightarrow (0.25,0.5)$。\n\n所有测试用例均使用位移参数 $a=0.3$，$b=-1.2$，$c=2.5$。\n\n答案规格：\n对每个测试用例，计算：\n- 一个布尔值，指示分片检验是否在所述标准下通过，以及\n- 在 $3 \\times 3$ Gauss 点上 $\\det \\mathbf{J}(\\xi,\\eta)$ 的最小值。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个测试用例结果都是一个包含两个元素的列表 $[\\text{pass}, \\min\\det]$，顺序与测试套件相同，例如 $\\big[\\, [\\text{True},\\,0.123],\\,[\\text{False},\\,-0.001],\\,[\\text{True},\\,0.05],\\,[\\text{False},\\,-0.02] \\,\\big]$。", "solution": "用户提供了一个关于使用分片检验 (patch test) 来验证九节点拉格朗日四边形单元的计算固体力学问题。\n\n### 第 1 步：提取给定信息\n- **单元类型**：二维九节点等参拉格朗日四边形单元。\n- **参考域**：一个由局部坐标 $(\\xi, \\eta)$ 定义的方形区域，其中 $\\xi, \\eta \\in [-1, 1]$。\n- **节点位置（参考坐标系）**：九个节点位于 $\\xi, \\eta \\in \\{-1, 0, 1\\}$ 的所有组合处。\n- **节点顺序**：从索引 $k=0, \\dots, 8$ 到参考坐标 $(\\xi_k, \\eta_k)$ 的特定映射：$k=0 \\rightarrow (-1,-1)$，$k=1 \\rightarrow (0,-1)$，$k=2 \\rightarrow (1,-1)$，$k=3 \\rightarrow (-1,0)$，$k=4 \\rightarrow (0,0)$，$k=5 \\rightarrow (1,0)$，$k=6 \\rightarrow (-1,1)$，$k=7 \\rightarrow (0,1)$，$k=8 \\rightarrow (1,1)$。\n- **形函数**：由一维二次拉格朗日多项式的张量积定义：$N_{ij}(\\xi,\\eta) = L_i(\\xi)L_j(\\eta)$，其中 $i,j \\in \\{-1,0,1\\}$。\n- **等参映射**：物理坐标 $(x,y)$ 是通过形函数 $N_a$ 和节点物理坐标 $(X_a, Y_a)$ 从参考坐标 $(\\xi,\\eta)$ 映射而来：$x(\\xi,\\eta) = \\sum_{a=0}^{8} N_a(\\xi,\\eta)X_a$ 和 $y(\\xi,\\eta) = \\sum_{a=0}^{8} N_a(\\xi,\\eta)Y_a$。\n- **雅可比矩阵**：$\\mathbf{J}(\\xi,\\eta) = \\begin{bmatrix} \\partial x/\\partial \\xi & \\partial x/\\partial \\eta \\\\ \\partial y/\\partial \\xi & \\partial y/\\partial \\eta \\end{bmatrix}$。需要计算的一个量是其行列式 $\\det \\mathbf{J}$。\n- **求积点**：$3 \\times 3$ 的 Gauss-Legendre 求积点，在每个坐标方向 $(\\xi, \\eta)$ 上的横坐标为 $\\{-\\sqrt{3/5}, 0, \\sqrt{3/5}\\}$。\n- **分片检验场**：一个标量位移场 $u(x,y) = a + b x + c y$，其中 $a, b, c$ 为给定常数。\n- **节点值**：$u_a = u(X_a, Y_a)$。\n- **梯度计算**：需要在 Gauss 点上使用形函数和链式法则计算梯度 $\\nabla u = [\\partial u/\\partial x, \\partial u/\\partial y]^T$。\n- **分片检验标准**：当且仅当两个条件都满足时，检验通过：\n    1.  在所有 9 个 Gauss 点上 $\\det \\mathbf{J}(\\xi,\\eta) > 0$。\n    2.  在所有 Gauss 点上，计算出的梯度 $\\nabla u$ 与精确梯度 $[\\,b,\\,c\\,]^T$ 之间的最大分量绝对误差小于 $10^{-10}$ 的容差。\n- **位移参数**：对所有测试用例，$a=0.3, b=-1.2, c=2.5$。\n- **测试用例**：通过节点物理坐标 $(X_k, Y_k)$ 定义了四个测试用例，其中 $k=0, \\dots, 8$：\n    1.  **随机轻度扭曲**：单位正方形，角点固定，边中点和中心点通过在 $[-0.1, 0.1]$ 区间内的均匀随机值进行扰动（种子为 $42$）。\n    2.  **蝶形自相交**：角点为 $k=0 \\to (0,0)$, $k=2 \\to (1,0)$, $k=6 \\to (1,1)$, $k=8 \\to (0,1)$。相应地放置边中点和中心点，导致一些节点重合。\n    3.  **随机强扭曲**：与用例 1 相同，但扰动在 $[-0.45, 0.45]$ 区间内（种子为 $7$）。\n    4.  **塌缩的底边**：节点 $k=0, 1, 2$ 都映射到物理点 $(0,0)$。\n- **要求输出**：对每个测试用例，输出一个用于表示分片检验是否通过的布尔值，以及在所有 Gauss 点上 $\\det \\mathbf{J}$ 的最小值。最终输出必须是包含这些结果列表的单行文本。\n\n### 第 2 步：使用提取的给定信息进行验证\n该问题根据指定的标准进行验证。\n- **科学依据**：该问题是有限元法 (FEM) 中的一个标准验证程序。等参映射、拉格朗日形函数、变换的雅可比矩阵、Gauss 求积和分片检验等概念都是计算固体力学中基本且成熟的原理。\n- **适定性**：该问题是算法上明确的。每个用例的输入（节点坐标、位移场参数）都有清晰的定义。计算过程是确定性的，并为每个测试用例产生唯一的解。\n- **客观性**：该问题以精确、定量和无偏见的数学语言陈述。所有标准都是客观的（例如，$\\det \\mathbf{J} > 0$，误差 $< 10^{-10}$）。\n- **完整性与一致性**：提供了所有必要的数据和定义。节点顺序、形函数构造、物理坐标和评估标准都得到了明确规定，没有歧义或矛盾。\n- **可行性与现实性**：所描述的计算是 FEM 软件中的标准操作，在物理上和数学上都是可行的。这些测试用例，包括扭曲和退化的几何形状，旨在测试单元公式的鲁棒性，这是一种常见的做法。\n- **其他缺陷**：该问题并非微不足道，因为它需要对 FEM 概念进行相当程度的实现。它不是同义反复、隐喻性的，也不超出科学可验证性的范畴。\n\n### 第 3 步：结论与行动\n问题陈述是**有效的**。它自成体系、科学合理且适定。将提供一个完整的解决方案。\n\n### 基于原理的解决方案设计\n该解决方案通过系统地实现等参有限元公式的原理来开发。\n\n**1. 一维拉格朗日多项式**\n九节点单元形函数的基础是在区间 $[-1, 1]$ 上定义的一维二次拉格朗日多项式，节点位于 $\\zeta \\in \\{-1, 0, 1\\}$。对于索引 $i \\in \\{-1, 0, 1\\}$，多项式 $L_i(\\zeta)$ 具有 $L_i(\\zeta_j) = \\delta_{ij}$（克罗内克 δ）的性质，其中 $\\zeta_j \\in \\{-1, 0, 1\\}$。\n其通用形式为 $L_i(\\zeta) = \\prod_{j \\in \\{-1,0,1\\}, j \\neq i} \\frac{\\zeta - \\zeta_j}{\\zeta_i - \\zeta_j}$。由此可得：\n- $L_{-1}(\\zeta) = \\frac{(\\zeta-0)(\\zeta-1)}{(-1-0)(-1-1)} = \\frac{1}{2}\\zeta(\\zeta-1)$\n- $L_{0}(\\zeta) = \\frac{(\\zeta-(-1))(\\zeta-1)}{(0-(-1))(0-1)} = -(\\zeta+1)(\\zeta-1) = 1-\\zeta^2$\n- $L_{1}(\\zeta) = \\frac{(\\zeta-(-1))(\\zeta-0)}{(1-(-1))(1-0)} = \\frac{1}{2}\\zeta(\\zeta+1)$\n\n它们关于 $\\zeta$ 的导数也需要计算：\n- $\\frac{dL_{-1}}{d\\zeta} = \\zeta - \\frac{1}{2}$\n- $\\frac{dL_{0}}{d\\zeta} = -2\\zeta$\n- $\\frac{dL_{1}}{d\\zeta} = \\zeta + \\frac{1}{2}$\n\n**2. 二维形函数**\n节点 $k$ 的二维形函数 $N_k(\\xi, \\eta)$ 是由一维多项式的张量积构成的。根据指定的节点顺序 $k = 0, \\dots, 8$，我们可以建立从标量索引 $k$ 到一维节点索引对 $(i, j) \\in \\{-1, 0, 1\\} \\times \\{-1, 0, 1\\}$ 的映射。该映射为 $i = (k \\pmod 3) - 1$ 和 $j = \\lfloor k/3 \\rfloor - 1$。\n与索引对 $(i,j)$ 对应的节点 $k$ 的形函数为：\n$$N_k(\\xi, \\eta) = L_i(\\xi) L_j(\\eta)$$\n其偏导数是计算雅可比矩阵所必需的，可使用乘法法则求得：\n$$\\frac{\\partial N_k}{\\partial \\xi} = \\frac{dL_i(\\xi)}{d\\xi} L_j(\\eta)$$\n$$\\frac{\\partial N_k}{\\partial \\eta} = L_i(\\xi) \\frac{dL_j(\\eta)}{d\\eta}$$\n\n**3. 等参映射和雅可比矩阵**\n等参公式使用相同的形函数来插值几何和解场。从参考单元 $(\\xi, \\eta)$ 到物理单元 $(x, y)$ 的映射为：\n$$x(\\xi, \\eta) = \\sum_{k=0}^{8} N_k(\\xi, \\eta) X_k, \\quad y(\\xi, \\eta) = \\sum_{k=0}^{8} N_k(\\xi, \\eta) Y_k$$\n雅可比矩阵 $\\mathbf{J}$ 关联了两个坐标系中的微分元，$d\\mathbf{x} = \\mathbf{J} d\\boldsymbol{\\xi}$。其分量为：\n$$J_{11} = \\frac{\\partial x}{\\partial \\xi} = \\sum_{k=0}^{8} \\frac{\\partial N_k}{\\partial \\xi} X_k, \\quad J_{12} = \\frac{\\partial x}{\\partial \\eta} = \\sum_{k=0}^{8} \\frac{\\partial N_k}{\\partial \\eta} X_k$$\n$$J_{21} = \\frac{\\partial y}{\\partial \\xi} = \\sum_{k=0}^{8} \\frac{\\partial N_k}{\\partial \\xi} Y_k, \\quad J_{22} = \\frac{\\partial y}{\\partial \\eta} = \\sum_{k=0}^{8} \\frac{\\partial N_k}{\\partial \\eta} Y_k$$\n行列式 $\\det \\mathbf{J}$ 是微分面积之间的缩放因子：$dA_{phys} = \\det \\mathbf{J} \\, dA_{ref}$。一个有效的映射要求在单元内任何地方都有 $\\det \\mathbf{J} > 0$。如果 $\\det \\mathbf{J} \\le 0$，则映射是奇异的或局部反转的（“网格缠结”），这是不符合物理规律的。\n\n**4. 分片检验 (Patch Test)**\n分片检验验证单元精确再现常应变状态的能力。对于位移场 $u(x, y) = a + bx + cy$，应变分量（位移的导数）是恒定的：$\\frac{\\partial u}{\\partial x} = b$ 和 $\\frac{\\partial u}{\\partial y} = c$。精确梯度为 $\\nabla u_{\\text{exact}} = [b, c]^T$。\n节点位移被设置为精确值：$u_k = u(X_k, Y_k) = a + b X_k + c Y_k$。\n单元内的插值位移场为 $u^h(\\xi, \\eta) = \\sum_{k=0}^{8} N_k(\\xi, \\eta) u_k$。由于等参映射的特性，特别是 $\\sum N_k = 1$（单位分解性）和 $\\sum N_k X_k = x$，可以证明 $u^h(\\xi, \\eta) = a + b x(\\xi, \\eta) + c y(\\xi, \\eta)$。这意味着插值场与精确场是相同的。\n物理坐标系中的计算梯度通过链式法则获得：\n$$\\begin{pmatrix} \\partial u^h/\\partial \\xi \\\\ \\partial u^h/\\partial \\eta \\end{pmatrix} = \\mathbf{J} \\begin{pmatrix} \\partial u^h/\\partial x \\\\ \\partial u^h/\\partial y \\end{pmatrix} \\implies \\nabla u^h = \\begin{pmatrix} \\partial u^h/\\partial x \\\\ \\partial u^h/\\partial y \\end{pmatrix} = \\mathbf{J}^{-1} \\begin{pmatrix} \\partial u^h/\\partial \\xi \\\\ \\partial u^h/\\partial \\eta \\end{pmatrix}$$\n其中 $\\partial u^h/\\partial \\xi = \\sum_k (\\partial N_k/\\partial \\xi) u_k$ 且 $\\partial u^h/\\partial \\eta = \\sum_k (\\partial N_k/\\partial \\eta) u_k$。\n理论上，如果 $\\det \\mathbf{J} > 0$，计算出的梯度 $\\nabla u^h$ 必须在机器精度范围内等于精确梯度 $[b, c]^T$。如果在所有指定的 Gauss 点上此条件成立且雅可比行列式为正，则检验通过。\n\n**5. 实现**\n该解决方案以 Python 程序实现。该程序定义了用于一维拉格朗日多项式及其导数的函数。一个核心函数计算给定点 $(\\xi, \\eta)$ 处的二维形函数及其导数。一个主测试函数针对一组给定的节点坐标来组织整个过程：它遍历 $3 \\times 3$ 的 Gauss 点，计算 $\\mathbf{J}$ 和 $\\det \\mathbf{J}$，如果映射有效，则继续计算位移梯度及其误差。然后汇总结果以确定总体的通过/失败状态和最小雅可比行列式。对问题中定义的四个测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef _l_1d(zeta, i):\n    \"\"\"Computes the 1D quadratic Lagrange polynomial L_i(zeta) for i in {-1, 0, 1}.\"\"\"\n    if i == -1:\n        return 0.5 * zeta * (zeta - 1.0)\n    elif i == 0:\n        return 1.0 - zeta**2\n    elif i == 1:\n        return 0.5 * zeta * (zeta + 1.0)\n    else:\n        raise ValueError(\"Invalid index for 1D Lagrange polynomial.\")\n\ndef _dl_1d(zeta, i):\n    \"\"\"Computes the derivative of the 1D Lagrange polynomial dL_i/dzeta.\"\"\"\n    if i == -1:\n        return zeta - 0.5\n    elif i == 0:\n        return -2.0 * zeta\n    elif i == 1:\n        return zeta + 0.5\n    else:\n        raise ValueError(\"Invalid index for 1D Lagrange polynomial derivative.\")\n\ndef get_shape_functions_and_derivs(xi, eta):\n    \"\"\"\n    Computes the 9-node quad shape functions and their derivatives at (xi, eta).\n    Node ordering k=0..8 corresponds to (i,j) pairs from (-1,-1) to (1,1).\n    \"\"\"\n    N = np.zeros(9)\n    dN_dxi_deta = np.zeros((9, 2))\n    \n    for k in range(9):\n        i = (k % 3) - 1\n        j = (k // 3) - 1\n\n        L_i_xi = _l_1d(xi, i)\n        L_j_eta = _l_1d(eta, j)\n        dL_i_xi = _dl_1d(xi, i)\n        dL_j_eta = _dl_1d(eta, j)\n\n        N[k] = L_i_xi * L_j_eta\n        dN_dxi_deta[k, 0] = dL_i_xi * L_j_eta  # dN_k/dxi\n        dN_dxi_deta[k, 1] = L_i_xi * dL_j_eta  # dN_k/deta\n        \n    return N, dN_dxi_deta\n\ndef run_patch_test_q9(coords, a, b, c, tol):\n    \"\"\"\n    Performs the patch test for a single 9-node element.\n    \"\"\"\n    gauss_abscissae = [-np.sqrt(3.0 / 5.0), 0.0, np.sqrt(3.0 / 5.0)]\n    gauss_points = [(xi, eta) for eta in gauss_abscissae for xi in gauss_abscissae]\n    \n    min_det_J = float('inf')\n    max_grad_error = 0.0\n    \n    all_dets_positive = True\n\n    # Nodal displacements from the exact field u(x,y)\n    nodal_u = a + b * coords[:, 0] + c * coords[:, 1]\n    grad_u_exact = np.array([b, c])\n\n    for xi, eta in gauss_points:\n        # Get shape functions and their derivatives at the current Gauss point\n        N, dN_dxi_deta = get_shape_functions_and_derivs(xi, eta)\n        \n        # Compute Jacobian matrix\n        # J = [dx/dxi, dx/deta]\n        #     [dy/dxi, dy/deta]\n        J = np.dot(dN_dxi_deta.T, coords)\n\n        # Compute determinant of Jacobian\n        det_J = np.linalg.det(J)\n        min_det_J = min(min_det_J, det_J)\n        \n        if det_J = 0:\n            all_dets_positive = False\n\n        # Compute gradient if mapping is valid\n        if det_J > 0:\n            # Gradient of u in reference coordinates\n            grad_u_ref = np.dot(dN_dxi_deta.T, nodal_u)\n\n            # Gradient of u in physical coordinates: grad_u_phys = J^-1 * grad_u_ref\n            try:\n                grad_u_phys = np.linalg.solve(J, grad_u_ref)\n                error = np.max(np.abs(grad_u_phys - grad_u_exact))\n                max_grad_error = max(max_grad_error, error)\n            except np.linalg.LinAlgError:\n                # This should not happen if det_J > 0, but as a safeguard\n                all_dets_positive = False\n    \n    passes = all_dets_positive and (max_grad_error  tol)\n    return [passes, min_det_J]\n\n\ndef solve():\n    # Define test parameters\n    a, b, c = 0.3, -1.2, 2.5\n    tolerance = 1e-10\n    \n    # --- Test Case Generation ---\n    test_cases_coords = []\n\n    # Case 1: Random Mild Distortion\n    rng1 = np.random.default_rng(42)\n    coords1 = np.array([\n        [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],\n        [0.0, 0.5], [0.5, 0.5], [1.0, 0.5],\n        [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]\n    ])\n    perturbed_indices = [1, 3, 4, 5, 7]\n    perturbations1 = rng1.uniform(-0.1, 0.1, size=(len(perturbed_indices), 2))\n    coords1[perturbed_indices] += perturbations1\n    test_cases_coords.append(coords1)\n\n    # Case 2: Bow-tie self-intersection\n    coords2 = np.array([\n        [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],  # k=0,1,2\n        [0.5, 0.5], [0.5, 0.5], [0.5, 0.5],  # k=3,4,5\n        [1.0, 1.0], [0.5, 1.0], [0.0, 1.0]   # k=6,7,8\n    ])\n    test_cases_coords.append(coords2)\n\n    # Case 3: Random Strong Distortion\n    rng3 = np.random.default_rng(7)\n    coords3 = np.array([\n        [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],\n        [0.0, 0.5], [0.5, 0.5], [1.0, 0.5],\n        [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]\n    ])\n    perturbations3 = rng3.uniform(-0.45, 0.45, size=(len(perturbed_indices), 2))\n    coords3[perturbed_indices] += perturbations3\n    test_cases_coords.append(coords3)\n    \n    # Case 4: Collapsed bottom edge\n    coords4 = np.array([\n        [0.0, 0.0], [0.0, 0.0], [0.0, 0.0],      # k=0,1,2\n        [0.0, 0.5], [0.25, 0.5], [0.5, 0.5],    # k=3,4,5\n        [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]     # k=6,7,8\n    ])\n    test_cases_coords.append(coords4)\n\n    # Run tests and collect results\n    results = []\n    for coords in test_cases_coords:\n        result = run_patch_test_q9(coords, a, b, c, tolerance)\n        results.append(result)\n        \n    # Format and print the final output as a single string\n    # E.g., [[True, 0.123], [False, -0.001]]\n    output_str = f\"[{', '.join(str(r) for r in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3583985"}, {"introduction": "一个通过了基本检验的单元，其性能优劣还需通过收敛性来量化评估。当网格加密时，其数值解应以一个可预测的速率逼近真实解。本练习将采用“制造解法”（Method of Manufactured Solutions），让你能够在一个已知精确解的问题上，通过编程实践来验证Q9单元在能量范数（$H^1$-seminorm）和$L^2$范数下的理论收敛阶[@problem_id:3583965]。这一过程将有限元方法的抽象理论（如Céa引理和Aubin-Nitsche对偶技巧）与具体的代码验证联系起来，是确保数值方法可靠性的重要环节。", "problem": "考虑由单位正方形域 $[0,1] \\times [0,1]$ 上的泊松方程控制的标量反平面剪切模型。令 $u:[0,1] \\times [0,1] \\to \\mathbb{R}$ 为标量位移场。其强形式为\n$$\n-\\nabla \\cdot (\\nabla u) = f \\text{ in } \\Omega = [0,1]^2, \\quad u = g \\text{ on } \\partial \\Omega.\n$$\n您将使用一个制造解 $u_{\\text{ex}}(x,y)$，因此 $f$ 和 $g$ 由 $u_{\\text{ex}}$ 通过强形式导出。使用以下制造解：\n$$\nu_{\\text{ex}}(x,y) = \\sin(\\pi x)\\sin(\\pi y).\n$$\n使用强形式，从 $u_{\\text{ex}}(x,y)$ 一致地定义 $f(x,y)$ 和 $g(x,y)$。\n\n您的任务是：\n- 从在索博列夫空间 $H^1_0(\\Omega)$ 中建立的弱形式和伽辽金方法出发，当试验空间为协调九节点拉格朗日四边形单元空间（常称为张量积二次族）时，推导在 $H^1$-半范数（能量范数）和 $L^2$-范数下的理论预期收敛阶。推导必须仅从变分形式和张量积二次插值的一般逼近性质开始，不得使用任何预先引用的目标阶数。清晰地陈述得出收敛阶结论所依赖的解的正则性和网格的正则性假设。\n- 在单位正方形 $\\Omega$ 的一系列均匀网格上，使用九节点拉格朗日四边形单元实现一个协调有限元求解器，其中每个坐标方向上的单元数为 $N \\in \\{2,4,8\\}$。对于每边有 $N$ 个单元的均匀张量网格，单元尺寸为 $h = 1/N$。\n- 通过与节点 $\\xi \\in \\{-1,0,1\\}$ 和 $\\eta \\in \\{-1,0,1\\}$ 相关的一维二次拉格朗日多项式的张量积，在双单位参考正方形 $[-1,1]^2$ 上构建九节点形函数。对从参考正方形到每个物理矩形单元的映射使用等参仿射变换（这在均匀矩形网格上是有效的）。使用足够高阶的高斯-勒让德求积法组装全局刚度矩阵和载荷向量，以对所选的制造数据达到组装精度。\n- 通过在所有边界节点上指定 $u_{\\text{ex}}$ 的精确值来强加狄利克雷边界条件，并求解内部节点的值。\n- 在每个单元上使用足够高阶的高斯-勒让德求积法，计算 $H^1$-半范数误差\n$$\n\\lvert u_{\\text{ex}} - u_h \\rvert_{H^1(\\Omega)} = \\left( \\int_{\\Omega} \\|\\nabla u_{\\text{ex}} - \\nabla u_h\\|^2 \\, d\\Omega \\right)^{1/2}\n$$\n和 $L^2$-范数误差\n$$\n\\|u_{\\text{ex}} - u_h\\|_{L^2(\\Omega)} = \\left( \\int_{\\Omega} (u_{\\text{ex}} - u_h)^2 \\, d\\Omega \\right)^{1/2}\n$$\n。\n- 对于 $N \\in \\{2,4,8\\}$ 的网格序列，计算每个范数在连续网格细化之间的观测收敛阶。如果 $e(h)$ 表示网格尺寸为 $h$ 时的误差，则将 $h$ 和 $h/2$ 之间的观测收敛阶定义为\n$$\n\\text{rate} = \\frac{\\log(e(h)/e(h/2))}{\\log(2)}.\n$$\n\n您可以使用的基础材料：\n- 在 $H^1_0(\\Omega)$ 上建立的变分形式和标准的伽辽金框架。\n- 具有齐次狄利克雷边界条件的泊松算子变分问题的适定性。\n- 将伽辽金误差与试验空间中最佳逼近误差联系起来的 Céa 引理。\n- 到张量积二次空间中的有界插值算子的存在性，以及在形状规则、拟一致网格上对足够光滑函数的一般插值误差估计。\n- 在适当的椭圆正则性下，用于从能量范数估计改进 $L^2$-范数估计的 Aubin–Nitsche 对偶论证。\n\n需要实现的数值细节：\n- 使用精确的制造解 $u_{\\text{ex}}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$、其梯度 $\\nabla u_{\\text{ex}}(x,y)$ 以及由强形式导出的相应右端项 $f(x,y)$。\n- 对于刚度/载荷组装，每个方向使用至少4阶的高斯-勒让德求积；对于误差评估，每个方向使用至少6阶的高斯-勒让德求积。\n- 处理参考单元 $[-1,1]^2$ 时，使用源于与节点 $\\{-1,0,1\\}$ 相关的一维多项式的张量积二次基。二维基通过张量积获得，导数通过乘法法则获得。\n\n测试套件：\n- 使用三种网格，每边分别有 $N \\in \\{2,4,8\\}$ 个单元。\n- 对于每个 $N$，计算误差对 $(\\lvert \\cdot \\rvert_{H^1}, \\|\\cdot\\|_{L^2})$。\n- 对两种范数，计算在 $N=2$ 和 $N=4$ 之间以及在 $N=4$ 和 $N=8$ 之间的观测收敛阶。此外，报告四个布尔检查，验证 $H^1$-半范数的观测收敛阶在两个细化步骤中是否都超过 1.9，以及 $L^2$-范数的观测收敛阶在两个细化步骤中是否都超过 2.8。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须严格按此顺序包含：\n    - $N=2$ 时的 $H^1$-半范数误差，\n    - $N=2$ 时的 $L^2$-范数误差，\n    - $N=4$ 时的 $H^1$-半范数误差，\n    - $N=4$ 时的 $L^2$-范数误差，\n    - $N=8$ 时的 $H^1$-半范数误差，\n    - $N=8$ 时的 $L^2$-范数误差，\n    - 从 $N=2$ 到 $N=4$ 的观测 $H^1$-半范数收敛阶，\n    - 从 $N=4$ 到 $N=8$ 的观测 $H^1$-半范数收敛阶，\n    - 从 $N=2$ 到 $N=4$ 的观测 $L^2$-范数收敛阶，\n    - 从 $N=4$ 到 $N=8$ 的观测 $L^2$-范数收敛阶，\n    - 一个布尔值，指示两次细化的 $H^1$ 收敛阶是否都超过 $1.9$，\n    - 一个布尔值，指示两次细化的 $L^2$ 收敛阶是否都超过 $2.8$，\n    - 一个布尔值，指示从 $N=2$ 到 $N=4$ 的 $H^1$ 收敛阶是否超过 $1.9$，\n    - 一个布尔值，指示从 $N=2$ 到 $N=4$ 的 $L^2$ 收敛阶是否超过 $2.8$。\n- 所有浮点数必须以定点格式打印，小数点后恰好有 $8$ 位数字。\n- 输出必须看起来像\n$$\n[\\text{eH1\\_N2},\\text{eL2\\_N2},\\text{eH1\\_N4},\\text{eL2\\_N4},\\text{eH1\\_N8},\\text{eL2\\_N8},\\text{rateH1\\_24},\\text{rateH1\\_48},\\text{rateL2\\_24},\\text{rateL2\\_48},\\text{boolH1All},\\text{boolL2All},\\text{boolH1\\_24},\\text{boolL2\\_24}]\n$$\n其中逗号分隔的值遵循上述顺序，布尔值打印为 True 或 False。本问题不涉及单位，也没有出现角度。", "solution": "该问题要求推导泊松方程的九节点拉格朗日四边形有限元离散化的理论收敛阶，然后使用一个制造解对这些收敛阶进行数值验证。\n\n### 第一部分：问题表述与理论分析\n\n**1.1. 强形式与弱形式**\n\n问题由单位正方形域 $\\Omega = [0,1]^2$ 上的泊松方程控制：\n$$\n-\\nabla^2 u = f \\quad \\text{in } \\Omega,\n$$\n边界条件为 $u=g$ on $\\partial\\Omega$ 的狄利克雷边界条件。\n\n制造解由 $u_{\\text{ex}}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$ 给出。我们从 $u_{\\text{ex}}$ 推导源项 $f$ 和边界数据 $g$。\n梯度为 $\\nabla u_{\\text{ex}} = (\\pi \\cos(\\pi x)\\sin(\\pi y), \\pi \\sin(\\pi x)\\cos(\\pi y))$。\n拉普拉斯算子为 $\\nabla^2 u_{\\text{ex}} = \\frac{\\partial^2 u_{\\text{ex}}}{\\partial x^2} + \\frac{\\partial^2 u_{\\text{ex}}}{\\partial y^2} = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y) - \\pi^2 \\sin(\\pi x)\\sin(\\pi y) = -2\\pi^2 u_{\\text{ex}}$。\n因此，源项为 $f(x,y) = -\\nabla^2 u_{\\text{ex}} = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$。\n\n对于边界数据 $g$，我们在 $\\partial\\Omega$ 上计算 $u_{\\text{ex}}$。由于 $\\sin(0) = 0$ 和 $\\sin(\\pi) = 0$，所以 $u_{\\text{ex}}(x,y)$ 在单位正方形的所有四条边上都为零。因此，在 $\\partial\\Omega$ 上 $g(x,y) = 0$。该问题是齐次的。\n\n相应的弱（变分）形式是，在索博列夫空间 $H^1_0(\\Omega) = \\{ v \\in H^1(\\Omega) : v|_{\\partial\\Omega} = 0 \\}$ 中找到一个解 $u$，使得：\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\Omega} f v \\, d\\Omega \\quad \\forall v \\in H^1_0(\\Omega).\n$$\n这可以写成抽象形式：找到 $u \\in H^1_0(\\Omega)$，使得对所有 $v \\in H^1_0(\\Omega)$ 都有 $a(u,v) = L(v)$，其中双线性形式 $a(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega$ 在 $H^1_0(\\Omega)$ 上定义了一个内积，并导出了能量范数 $|v|_{H^1(\\Omega)} = \\sqrt{a(v,v)}$。线性泛函是 $L(v) = \\int_{\\Omega} f v \\, d\\Omega$。\n\n**1.2. 伽辽金方法与收敛阶**\n\n有限元法是一种伽辽金方法，我们在一个有限维子空间 $V_h \\subset H^1_0(\\Omega)$ 中寻找近似解 $u_h$。空间 $V_h$ 由定义在四边形单元网格上的连续分片双二次多项式组成，这些多项式在 $\\partial\\Omega$ 上为零。伽辽金问题是找到 $u_h \\in V_h$，使得：\n$$\na(u_h, v_h) = L(v_h) \\quad \\forall v_h \\in V_h.\n$$\n\n**$H^1$-半范数收敛性：**\n分析从 Céa 引理开始，对于本问题，该引理指出伽辽金解的误差由子空间 $V_h$ 中的最佳逼近误差界定：\n$$\n|u - u_h|_{H^1(\\Omega)} \\leq \\inf_{v_h \\in V_h} |u - v_h|_{H^1(\\Omega)}.\n$$\n最佳逼近误差可以由 $V_h$ 中特定插值函数的误差来界定。令 $\\mathcal{I}_h u$ 为 $u$ 在 $V_h$ 中的标准双二次拉格朗日插值。标准插值理论提供了一个插值误差的估计，假设解 $u$ 具有足够的正则性且网格是拟一致的。对于多项式次数为 $p$ 的有限元，估计为：\n$$\n|u - \\mathcal{I}_h u|_{H^1(\\Omega)} \\leq C h^p |u|_{H^{p+1}(\\Omega)},\n$$\n其中 $h$ 是特征网格尺寸，C 是一个与 $h$ 无关的常数。\n九节点拉格朗日单元是张量积二次单元，所以其多项式次数为 $p=2$。该估计要求解属于索博列夫空间 $H^{p+1}(\\Omega) = H^3(\\Omega)$。我们的制造解 $u_{\\text{ex}}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$ 是无限可微的 ($C^\\infty$)，所以它属于任何 $k$ 阶的 $H^k(\\Omega)$，包括 $H^3(\\Omega)$。\n综合这些结果，$H^1$-半范数误差的理论收敛阶为：\n$$\n|u_{\\text{ex}} - u_h|_{H^1(\\Omega)} = O(h^p) = O(h^2).\n$$\n预期的收敛阶为 2。\n\n**$L^2$-范数收敛性：**\n为了获得 $L^2$-范数更高的收敛阶，我们使用 Aubin-Nitsche 对偶论证。该论证要求泊松问题具有 $H^2$ 椭圆正则性，对于像单位正方形这样的凸域，这一条件是成立的。这意味着对于辅助问题 $-\\nabla^2 \\phi = \\psi$ in $\\Omega$ 且 $\\phi=0$ on $\\partial\\Omega$，解满足 $\\|\\phi\\|_{H^2(\\Omega)} \\leq C_{\\text{reg}} \\|\\psi\\|_{L^2(\\Omega)}$，对于任何 $\\psi \\in L^2(\\Omega)$。\nAubin-Nitsche 论证得出以下估计：\n$$\n\\|u - u_h\\|_{L^2(\\Omega)} \\leq C h |u - u_h|_{H^1(\\Omega)}.\n$$\n代入先前导出的 $H^1$-半范数误差的收敛阶：\n$$\n\\|u_{\\text{ex}} - u_h\\|_{L^2(\\Omega)} \\leq C h \\cdot O(h^p) = O(h^{p+1}).\n$$\n对于我们的双二次单元，$p=2$，所以 $L^2$-范数误差的理论收敛阶为：\n$$\n\\|u_{\\text{ex}} - u_h\\|_{L^2(\\Omega)} = O(h^{p+1}) = O(h^3).\n$$\n预期的收敛阶为 3。\n\n### 第二部分：有限元实现细节\n\n**2.1. 离散化与形函数**\n区域 $\\Omega=[0,1]^2$ 被离散化为 $N \\times N$ 个边长为 $h=1/N$ 的均匀正方形单元网格。使用九节点（双二次）拉格朗日单元。参考单元 $[-1,1]^2$ 上的形函数 $N_i(\\xi, \\eta)$ 是由与节点 $s \\in \\{-1,0,1\\}$ 相关的一维二次拉格朗日多项式 $L_k(s)$ 的张量积构建的：\n$L_0(s) = \\frac{1}{2}s(s-1)$, $L_1(s) = 1-s^2$, $L_2(s) = \\frac{1}{2}s(s+1)$。\n对于 $k=0, \\dots, 8$ 的九个二维形函数 $N_k(\\xi, \\eta)$ 是 $N_{ij}(\\xi, \\eta) = L_i(\\xi)L_j(\\eta)$，其中 $i,j \\in \\{0,1,2\\}$。\n\n**2.2. 等参映射与数值求积**\n一个仿射等参映射 $x(\\xi, \\eta)$ 将参考单元变换到每个物理单元 $K_e$。对于中心为 $(x_c, y_c)$ 且边长为 $h$ 的正方形单元，该映射为 $x = x_c + \\frac{h}{2}\\xi$, $y = y_c + \\frac{h}{2}\\eta$。雅可比行列式是常数：$\\det(J) = h^2/4$。\n\n单元刚度矩阵 $k^e$ 和载荷向量 $f^e$ 通过将积分变换到参考单元并使用高斯-勒让德求积法进行数值计算。\n$$\nk^e_{ij} = \\int_{-1}^1 \\int_{-1}^1 \\left(\\nabla N_i(\\xi, \\eta)\\right)^T (J^{-T} J^{-1}) \\left(\\nabla N_j(\\xi, \\eta)\\right) \\det(J) \\,d\\xi d\\eta\n$$\n$$\nf^e_i = \\int_{-1}^1 \\int_{-1}^1 f(x(\\xi,\\eta), y(\\xi,\\eta)) N_i(\\xi, \\eta) \\det(J) \\,d\\xi d\\eta\n$$\n$k^e$ 的被积函数是一个多项式。对于双二次单元和仿射映射，其在每个变量中的次数最多为 4。一个3点高斯法则将是精确的，但问题指定每个方向至少4个点；我们使用 $4 \\times 4$ 法则。$f^e$ 的被积函数是非多项式的，因此高阶法则可以提高精度。\n单元贡献被组装成一个全局刚度矩阵 $K$ 和载荷向量 $F$。\n\n**2.3. 边界条件与求解**\n齐次狄利克雷边界条件 ($u=0$) 被强加。这是通过将全局方程组划分为内部未知数和边界未知数来实现的。求解系统 $K_{II}U_I = F_I - K_{IB}U_B$ 以获得内部节点值 $U_I$。由于边界值 $U_B$ 全为零，这简化为求解 $K_{II} U_I = F_I$。\n\n**2.4. 误差计算**\n误差 $e = u_{\\text{ex}} - u_h$ 的 $H^1$-半范数和 $L^2$-范数通过对每个单元的贡献求和来计算，并使用高阶（$6 \\times 6$）高斯-勒让德求积法以确保精度。\n$$\n|e|_{H^1(\\Omega)}^2 = \\sum_{e} \\int_{K_e} \\|\\nabla u_{\\text{ex}} - \\nabla u_h\\|^2 \\,d\\Omega \\quad \\text{和} \\quad \\|e\\|_{L^2(\\Omega)}^2 = \\sum_{e} \\int_{K_e} (u_{\\text{ex}} - u_h)^2 \\,d\\Omega.\n$$\n\n**2.5. 收敛阶计算**\n对于每个范数，尺寸为 $h_1$ 和 $h_2=h_1/2$ 的网格之间的观测收敛阶计算为 $\\text{rate} = \\log(e_1/e_2) / \\log(2)$。这对从 $N=2$ 到 $N=4$ 以及从 $N=4$ 到 $N=8$ 的细化进行计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 9-node quadrilateral FEM solver for the Poisson equation\n    and performs a convergence study.\n    \"\"\"\n\n    def get_gauss_points(order):\n        return np.polynomial.legendre.leggauss(order)\n\n    # 1D quadratic shape functions and their derivatives\n    L = [\n        lambda s: 0.5 * s * (s - 1),\n        lambda s: 1 - s**2,\n        lambda s: 0.5 * s * (s + 1),\n    ]\n    dL = [\n        lambda s: s - 0.5,\n        lambda s: -2 * s,\n        lambda s: s + 0.5,\n    ]\n\n    def shape_functions(xi, eta):\n        N = np.zeros(9)\n        for j in range(3):\n            for i in range(3):\n                N[j * 3 + i] = L[i](xi) * L[j](eta)\n        return N\n\n    def shape_function_derivatives(xi, eta):\n        dN = np.zeros((9, 2))\n        for j in range(3):\n            for i in range(3):\n                dN[j * 3 + i, 0] = dL[i](xi) * L[j](eta)  # d/d(xi)\n                dN[j * 3 + i, 1] = L[i](xi) * dL[j](eta)  # d/d(eta)\n        return dN\n\n    # Manufactured solution and its derivatives\n    u_ex = lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y)\n    grad_u_ex = lambda x, y: np.array([\n        np.pi * np.cos(np.pi * x) * np.sin(np.pi * y),\n        np.pi * np.sin(np.pi * x) * np.cos(np.pi * y)\n    ])\n    f_source = lambda x, y: 2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n    \n    mesh_sizes = [2, 4, 8]\n    errors = []\n\n    GQ_ORDER_ASSEMBLY = 4\n    GQ_ORDER_ERROR = 6\n    gp_assembly, gw_assembly = get_gauss_points(GQ_ORDER_ASSEMBLY)\n    gp_error, gw_error = get_gauss_points(GQ_ORDER_ERROR)\n\n    for N in mesh_sizes:\n        h = 1.0 / N\n        num_nodes_1d = 2 * N + 1\n        num_nodes = num_nodes_1d**2\n        \n        nodes = np.zeros((num_nodes, 2))\n        for j in range(num_nodes_1d):\n            for i in range(num_nodes_1d):\n                nodes[j * num_nodes_1d + i] = [i * h / 2.0, j * h / 2.0]\n\n        elements = []\n        for j in range(N):\n            for i in range(N):\n                el_nodes = np.zeros(9, dtype=int)\n                for row in range(3):\n                    for col in range(3):\n                        node_x_idx = 2 * i + col\n                        node_y_idx = 2 * j + row\n                        el_nodes[row * 3 + col] = node_y_idx * num_nodes_1d + node_x_idx\n                elements.append(el_nodes)\n        \n        K_global = np.zeros((num_nodes, num_nodes))\n        F_global = np.zeros(num_nodes)\n        \n        for el_nodes in elements:\n            k_elem = np.zeros((9, 9))\n            f_elem = np.zeros(9)\n            \n            x_nodes = nodes[el_nodes]\n            x_c = np.mean(x_nodes, axis=0) # Center of the element\n            \n            # Jacobian for affine map from [-1,1]^2 to [x-h/2,x+h/2]x[y-h/2,y+h/2]\n            det_J = (h / 2.0)**2\n            inv_J_T = np.array([[2.0 / h, 0], [0, 2.0 / h]])\n\n            for i in range(GQ_ORDER_ASSEMBLY):\n                for j in range(GQ_ORDER_ASSEMBLY):\n                    xi, eta = gp_assembly[i], gp_assembly[j]\n                    weight = gw_assembly[i] * gw_assembly[j]\n                    \n                    x_phys = x_c[0] + xi * h / 2.0\n                    y_phys = x_c[1] + eta * h / 2.0\n                    \n                    N_vals = shape_functions(xi, eta)\n                    dN_dxi_eta = shape_function_derivatives(xi, eta)\n                    \n                    dN_dx_dy = dN_dxi_eta @ inv_J_T\n                    \n                    B = dN_dx_dy.T\n                    k_elem += (B.T @ B) * weight * det_J\n                    \n                    f_val = f_source(x_phys, y_phys)\n                    f_elem += f_val * N_vals * weight * det_J\n            \n            for i in range(9):\n                for j in range(9):\n                    K_global[el_nodes[i], el_nodes[j]] += k_elem[i, j]\n                F_global[el_nodes[i]] += f_elem[i]\n\n        boundary_nodes = [i for i in range(num_nodes) if (nodes[i,0]==0 or nodes[i,0]==1 or nodes[i,1]==0 or nodes[i,1]==1)]\n        interior_nodes = list(set(range(num_nodes)) - set(boundary_nodes))\n\n        K_interior = K_global[np.ix_(interior_nodes, interior_nodes)]\n        F_interior = F_global[interior_nodes]\n        \n        U_interior = np.linalg.solve(K_interior, F_interior)\n        \n        U_global = np.zeros(num_nodes)\n        U_global[interior_nodes] = U_interior\n        \n        err_H1_sq = 0.0\n        err_L2_sq = 0.0\n\n        for el_nodes in elements:\n            x_nodes = nodes[el_nodes]\n            u_elem = U_global[el_nodes]\n            x_c = np.mean(x_nodes, axis=0)\n            det_J = (h / 2.0)**2\n            inv_J_T = np.array([[2.0 / h, 0], [0, 2.0 / h]])\n            \n            for i in range(GQ_ORDER_ERROR):\n                for j in range(GQ_ORDER_ERROR):\n                    xi, eta = gp_error[i], gp_error[j]\n                    weight = gw_error[i] * gw_error[j]\n                    \n                    x_phys = x_c[0] + xi * h / 2.0\n                    y_phys = x_c[1] + eta * h / 2.0\n                    \n                    N_vals = shape_functions(xi, eta)\n                    dN_dxi_eta = shape_function_derivatives(xi, eta)\n                    dN_dx_dy = dN_dxi_eta @ inv_J_T\n                    \n                    u_h = np.dot(N_vals, u_elem)\n                    grad_u_h = u_elem @ dN_dx_dy\n                    \n                    u_exact_val = u_ex(x_phys, y_phys)\n                    grad_u_exact_val = grad_u_ex(x_phys, y_phys)\n                    \n                    err_L2_sq += (u_exact_val - u_h)**2 * weight * det_J\n                    err_H1_sq += np.sum((grad_u_exact_val - grad_u_h)**2) * weight * det_J\n\n        errors.append((np.sqrt(err_H1_sq), np.sqrt(err_L2_sq)))\n\n    eH1_N2, eL2_N2 = errors[0]\n    eH1_N4, eL2_N4 = errors[1]\n    eH1_N8, eL2_N8 = errors[2]\n\n    rateH1_24 = np.log(eH1_N2 / eH1_N4) / np.log(2)\n    rateH1_48 = np.log(eH1_N4 / eH1_N8) / np.log(2)\n    rateL2_24 = np.log(eL2_N2 / eL2_N4) / np.log(2)\n    rateL2_48 = np.log(eL2_N4 / eL2_N8) / np.log(2)\n\n    boolH1_24 = rateH1_24 > 1.9\n    boolL2_24 = rateL2_24 > 2.8\n    boolH1All = (rateH1_24 > 1.9) and (rateH1_48 > 1.9)\n    boolL2All = (rateL2_24 > 2.8) and (rateL2_48 > 2.8)\n\n    output = [\n        f\"{eH1_N2:.8f}\", f\"{eL2_N2:.8f}\",\n        f\"{eH1_N4:.8f}\", f\"{eL2_N4:.8f}\",\n        f\"{eH1_N8:.8f}\", f\"{eL2_N8:.8f}\",\n        f\"{rateH1_24:.8f}\", f\"{rateH1_48:.8f}\",\n        f\"{rateL2_24:.8f}\", f\"{rateL2_48:.8f}\",\n        str(boolH1All), str(boolL2All),\n        str(boolH1_24), str(boolL2_24)\n    ]\n    \n    print(f\"[{','.join(output)}]\")\n\nsolve()\n\n```", "id": "3583965"}]}