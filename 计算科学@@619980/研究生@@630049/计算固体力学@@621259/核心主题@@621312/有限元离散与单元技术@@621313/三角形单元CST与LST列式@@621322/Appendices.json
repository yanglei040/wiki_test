{"hands_on_practices": [{"introduction": "“补丁测试” (Patch Test) 是验证有限元列式正确性的一个基本基准。本实践将指导您通过编程实现数值验证，以确认常应变三角形（Constant Strain Triangle, CST）单元能够精确表示其设计所针对的常应变状态，这是保证单元收敛性的一个必要条件 [@problem_id:3607774]。成功完成此测试，将使您对单元的基本实现建立信心。", "problem": "考虑二维空间中无体力作用下的小应变、线性弹性、平面应力问题。令位移场为 $\\mathbf{u}(x,y) = \\begin{bmatrix} u(x,y) \\\\ v(x,y) \\end{bmatrix}$，无穷小应变张量为 $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} \\varepsilon_{xx} \\\\ \\varepsilon_{yy} \\\\ \\gamma_{xy} \\end{bmatrix} = \\begin{bmatrix} \\dfrac{\\partial u}{\\partial x} \\\\ \\dfrac{\\partial v}{\\partial y} \\\\ \\dfrac{\\partial u}{\\partial y} + \\dfrac{\\partial v}{\\partial x} \\end{bmatrix}$。对于平面应力状态下的各向同性材料，令 $\\mathbf{D}$ 为弹性本构矩阵，使得 $\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}$，其中 $\\boldsymbol{\\sigma} = \\begin{bmatrix} \\sigma_{xx} \\\\ \\sigma_{yy} \\\\ \\sigma_{xy} \\end{bmatrix}$ 是柯西应力向量。对于杨氏模量 $E$ 和泊松比 $\\nu$，平面应力矩阵为 $\\mathbf{D} = \\dfrac{E}{1-\\nu^2}\\begin{bmatrix} 1  \\nu  0 \\\\ \\nu  1  0 \\\\ 0  0  \\dfrac{1-\\nu}{2} \\end{bmatrix}$。\n\n在常应变三角形 (CST) 有限元中，位移在每个三角形上通过线性形函数进行插值。以 $t$ 表示单元厚度（面外方向，为正常数）。在无体力且边界 $\\Gamma$ 上作用有一致边界牵引力 $\\mathbf{t} = \\boldsymbol{\\sigma}\\,\\mathbf{n}$ 的情况下，虚功原理导出组装后的平衡（残差）向量 $\\mathbf{r} = \\mathbf{f}_{\\mathrm{int}} - \\mathbf{f}_{\\mathrm{trac}}$，其中 $\\mathbf{f}_{\\mathrm{int}}$ 是组装后的内部节点力向量，每个单元的贡献为 $\\int_{\\Omega_e} \\mathbf{B}^\\top \\boldsymbol{\\sigma}\\, \\mathrm{d}\\Omega$；$\\mathbf{f}_{\\mathrm{trac}}$ 是组装后的一致节点牵引力向量，每个边界边的贡献为 $\\int_{\\Gamma_e} \\mathbf{N}^\\top \\mathbf{t}\\, \\mathrm{d}\\Gamma$；$\\mathbf{B}$ 是由线性形函数导数构建的标准 CST 应变-位移矩阵；$\\mathbf{N}$ 是汇集了两个位移分量形函数的矩阵。\n\n您的任务是设计并分析三个由 CST 单元组成的三角形网格片，并从第一性原理出发，通过数值和算法验证以下两个性质：\n- 如果精确位移是 $x$ 和 $y$ 的线性函数，那么当节点值取自同一线性场时，CST 插值能够在每个单元上逐点地再现该位移场。\n- 在无体力、且边界牵引力设置为与同线性场对应的精确值 $\\mathbf{t} = \\boldsymbol{\\sigma}\\,\\mathbf{n}$ 的条件下，组装后的残差 $\\mathbf{r}$ 为零，即全局内力与边界牵引力精确平衡，因此残差范数为零。\n\n实现一个完整的程序，针对每个指定的网格片和线性位移场，计算以下内容：\n- 位移再现的最大绝对误差 $\\max\\limits_{\\text{samples},\\ \\alpha \\in \\{u,v\\}} \\left| \\alpha_{\\mathrm{FE}} - \\alpha_{\\mathrm{exact}} \\right|$，以米（SI单位）表示。\n- 组装后残差向量的欧几里得范数 $\\|\\mathbf{r}\\|_2 = \\|\\mathbf{f}_{\\mathrm{int}} - \\mathbf{f}_{\\mathrm{trac}}\\|_2$，以牛顿（SI单位）表示，其中一致边界牵引力 $\\mathbf{t} = \\boldsymbol{\\sigma}\\,\\mathbf{n}$ 以逆时针顺序施加在边界边上。\n\n使用以下三个测试算例（所有坐标单位为米，模量单位为帕斯卡，厚度单位为米）。对于每个算例，线性位移场以 $u(x,y) = a_0 + a_1 x + a_2 y$ 和 $v(x,y) = b_0 + b_1 x + b_2 y$ 的形式给出。所有角度（如果出现）必须以弧度为单位。\n\n测试算例 $\\mathbf{1}$（由两个三角形组成一个正方形的基准网格片）：\n- 节点 $\\mathbf{x}_i$：$\\left[(0,0),(1,0),(1,1),(0,1)\\right]$。\n- 单元（节点索引的三元组，从零开始）：$\\left[(0,1,2),(0,2,3)\\right]$。\n- 边界边（按逆时针顺序排列的节点索引对）：$\\left[(0,1),(1,2),(2,3),(3,0)\\right]$。\n- 材料：$E = 210\\times 10^9$，$\\nu = 0.3$，$t = 0.01$。\n- 线性场系数：$a_0 = 1$， $a_1 = 2$， $a_2 = -3$， $b_0 = -0.5$， $b_1 = 4$， $b_2 = 1$。\n\n测试算例 $\\mathbf{2}$（带内部节点的网格片：四个三角形在中心交汇）：\n- 节点 $\\mathbf{x}_i$：$\\left[(0,0),(2,0),(2,1),(0,1),(1,0.5)\\right]$。\n- 单元：$\\left[(0,1,4),(1,2,4),(2,3,4),(3,0,4)\\right]$。\n- 边界边（逆时针）：$\\left[(0,1),(1,2),(2,3),(3,0)\\right]$。\n- 材料：$E = 70\\times 10^9$，$\\nu = 0.25$，$t = 0.02$。\n- 线性场系数：$a_0 = -0.1$， $a_1 = 0.3$， $a_2 = 0.2$， $b_0 = 0.7$， $b_1 = -0.6$， $b_2 = 0.4$。\n\n测试算例 $\\mathbf{3}$（边缘情况：单个细长三角形）：\n- 节点 $\\mathbf{x}_i$：$\\left[(0,0),(0.001,0),(1,0.1)\\right]$。\n- 单元：$\\left[(0,1,2)\\right]$。\n- 边界边（逆时针）：$\\left[(0,1),(1,2),(2,0)\\right]$。\n- 材料：$E = 110\\times 10^9$，$\\nu = 0.29$，$t = 0.005$。\n- 线性场系数（刚体运动：零应变）：$a_0 = 0.02$， $a_1 = 0$， $a_2 = 0.001$， $b_0 = -0.03$， $b_1 = -0.001$， $b_2 = 0$。\n\n算法要求：\n- 使用标准的 CST 构建方法。对于每个具有节点 $(x_i,y_i)$ 的三角形，定义线性形函数 $N_i(x,y)$（$i\\in\\{1,2,3\\}$）及其在单元内的常数导数。相应地构建单元 $\\mathbf{B}$ 矩阵。\n- 根据给定的线性场计算精确的常应变 $\\varepsilon_{xx} = a_1$， $\\varepsilon_{yy} = b_2$ 和 $\\gamma_{xy} = a_2 + b_1$，然后计算 $\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}$。\n- 将内力向量组装为所有单元 $\\int_{\\Omega_e} \\mathbf{B}^\\top \\boldsymbol{\\sigma}\\, \\mathrm{d}\\Omega = \\mathbf{B}^\\top \\boldsymbol{\\sigma}\\,A_e\\,t$ 的总和，其中 $A_e$ 是单元面积。\n- 通过对边界边求和 $\\int_{\\Gamma_e} \\mathbf{N}^\\top \\mathbf{t}\\, \\mathrm{d}\\Gamma$ 来组装一致边界牵引力向量，其中 $\\mathbf{t} = \\boldsymbol{\\sigma}\\,\\mathbf{n}$，$\\mathbf{n}$ 是根据逆时针边排序得到的单位外法向量。由于对于线性位移场，$\\mathbf{t}$ 沿直线边是常数，因此可将其分配到该边的两个节点上，每个节点分配 $\\dfrac{L_e\\,t}{2}\\mathbf{t}$，其中 $L_e$ 是边长。\n- 对于再现误差，将节点位移设置为在节点处求值的精确线性场，然后使用 CST 形函数在每个三角形的质心和各边中点组成的采样点集上评估有限元位移，并计算所有样本和两个位移分量与精确场之间的最大绝对差。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个 Python 风格的列表，其中有 6 个浮点数，顺序如下：$\\left[\\text{err}_1,\\ \\|\\mathbf{r}_1\\|_2,\\ \\text{err}_2,\\ \\|\\mathbf{r}_2\\|_2,\\ \\text{err}_3,\\ \\|\\mathbf{r}_3\\|_2\\right]$，其中 $\\text{err}_k$ 是测试算例 $k$ 的最大绝对位移再现误差（单位：米），$\\|\\mathbf{r}_k\\|_2$ 是测试算例 $k$ 的组装后残差向量的欧几里得范数（单位：牛顿）。不要打印单位；确保数值符合指定的 SI 单位。\n\n程序必须是自包含的，不需要任何输入。它必须实现执行所述计算所需的所有细节。", "solution": "该问题要求在平面应力条件下，对常应变三角形 (CST) 有限元的两个基本性质进行数值验证。这两个性质是：它能够精确再现线性位移场的能力，以及通过网格片检验（patch test）的能力。对于无体力的情况，后者表现为当施加与恒定应变状态相对应的一致边界牵引力时，残差力向量为零。我们将分析三个不同的测试算例，每个算例都有指定的几何形状、材料属性和线性位移场。\n\n分析基于线弹性力学和有限元方法。位移场 $\\mathbf{u}(x,y)$ 由 $\\mathbf{u} = [u(x,y), v(x,y)]^\\top$ 给出。无穷小应变的应变-位移关系以向量形式表示为 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\top$，其中\n$$ \\boldsymbol{\\varepsilon} = \\begin{bmatrix} \\dfrac{\\partial u}{\\partial x} \\\\ \\dfrac{\\partial v}{\\partial y} \\\\ \\dfrac{\\partial u}{\\partial y} + \\dfrac{\\partial v}{\\partial x} \\end{bmatrix} $$\n对于线性、各向同性、均质材料，在平面应力下，应力向量 $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}]^\\top$ 通过本构矩阵 $\\mathbf{D}$ 与应变向量相关联：\n$$ \\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon} \\quad \\text{其中} \\quad \\mathbf{D} = \\dfrac{E}{1-\\nu^2}\\begin{bmatrix} 1  \\nu  0 \\\\ \\nu  1  0 \\\\ 0  0  \\dfrac{1-\\nu}{2} \\end{bmatrix} $$\n这里，$E$ 代表杨氏模量，$\\nu$ 是泊松比。\n\nCST 单元使用线性形函数 $N_i(x,y)$ 在三角形域 $\\Omega_e$ 内近似位移场，其中 $i \\in \\{1,2,3\\}$ 对应于单元的三个节点。插值后的位移场 $(u^h, v^h)$ 为：\n$$ u^h(x,y) = \\sum_{i=1}^{3} N_i(x,y) u_i \\quad \\text{和} \\quad v^h(x,y) = \\sum_{i=1}^{3} N_i(x,y) v_i $$\n其中 $(u_i, v_i)$ 是节点 $i$ 处的位移。形函数 $N_i$ 是 $x$ 和 $y$ 的线性函数，具有 $N_i(x_j, y_j) = \\delta_{ij}$ 的性质，其中 $\\delta_{ij}$ 是克罗内克（Kronecker）符号。\n\n这些线性形函数的导数在单元上是常数。这导致单元内有一个恒定的应变场，这也是它被称为常应变三角形的原因。应变通过应变-位移矩阵 $\\mathbf{B}$ 与节点位移向量 $\\mathbf{d}_e = [u_1, v_1, u_2, v_2, u_3, v_3]^\\top$ 相关联：\n$$ \\boldsymbol{\\varepsilon}_e = \\mathbf{B} \\mathbf{d}_e $$\n对于节点 $(x_1, y_1)$、$(x_2, y_2)$ 和 $(x_3, y_3)$ 按逆时针顺序排列的单元，$\\mathbf{B}$ 矩阵由下式给出：\n$$ \\mathbf{B} = \\frac{1}{2A_e} \\begin{bmatrix}\ny_2-y_3  0  y_3-y_1  0  y_1-y_2  0 \\\\\n0  x_3-x_2  0  x_1-x_3  0  x_2-x_1 \\\\\nx_3-x_2  y_2-y_3  x_1-x_3  y_3-y_1  x_2-x_1  y_1-y_2\n\\end{bmatrix} $$\n其中 $A_e$ 是单元的面积，计算公式为 $A_e = \\frac{1}{2} \\det \\begin{bmatrix} 1  x_1  y_1 \\\\ 1  x_2  y_2 \\\\ 1  x_3  y_3 \\end{bmatrix}$。\n\n**位移再现的验证**\n\n要验证的第一个性质是 CST 单元能够精确再现线性位移场。给定的精确场是：\n$$ u(x,y) = a_0 + a_1 x + a_2 y \\quad \\text{和} \\quad v(x,y) = b_0 + b_1 x + b_2 y $$\n由于 CST 形函数 $N_i(x,y)$ 本身是线性的，并且它们构成了三角形上线性多项式的一组基（因为 $\\sum N_i = 1$），因此取自线性场的节点值的任何线性组合都必须再现该线性场。也就是说，如果我们设置节点位移 $u_i = u(x_i, y_i)$ 和 $v_i = v(x_i, y_i)$，那么对于单元中所有的 $(x,y)$，插值位移 $u^h(x,y) = \\sum N_i(x,y) u(x_i,y_i)$ 必须与 $u(x,y)$ 相同。一个线性函数由其在三个不共线点（即顶点）的值唯一确定。由于 $u(x,y)$ 和 $u^h(x,y)$ 都是线性的且在顶点处值相同，它们必须处处相同。\n\n为了进行数值验证，我们在每个单元内的一组采样点（质心和边中点）上计算有限元近似 $u^h, v^h$，并将其与精确值 $u, v$ 进行比较。对于 $\\alpha \\in \\{u,v\\}$，最大绝对差 $\\max |\\alpha_{\\mathrm{FE}} - \\alpha_{\\mathrm{exact}}|$ 预计在浮点精度范围内为零。\n\n**网格片检验的验证（零残差）**\n\n第二个性质是满足网格片检验。对于处于恒定应变状态下的一片单元，若无体力，则节点平衡方程必须得到满足。这意味着组装后的内部节点力 $\\mathbf{f}_{\\mathrm{int}}$ 必须与由边界牵引力产生的组装后外部节点力 $\\mathbf{f}_{\\mathrm{trac}}$ 完全平衡。残差向量 $\\mathbf{r} = \\mathbf{f}_{\\mathrm{int}} - \\mathbf{f}_{\\mathrm{trac}}$ 必须为零向量。\n\n所提供的线性位移场在整个域上引起一个恒定的应变状态：\n$$ \\boldsymbol{\\varepsilon} = \\begin{bmatrix} a_1 \\\\ b_2 \\\\ a_2 + b_1 \\end{bmatrix} $$\n这导致一个恒定的应力场 $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$。\n\n一个单元的内力向量通过对内应力的虚功进行积分来计算：\n$$ \\mathbf{f}_{e, \\mathrm{int}} = \\int_{\\Omega_e} \\mathbf{B}^\\top \\boldsymbol{\\sigma} \\, \\mathrm{d}\\Omega $$\n由于 $\\mathbf{B}$ 和 $\\boldsymbol{\\sigma}$ 在 CST 单元内是常数，这可以简化为：\n$$ \\mathbf{f}_{e, \\mathrm{int}} = \\mathbf{B}^\\top \\boldsymbol{\\sigma} A_e t $$\n其中 $t$ 是恒定的单元厚度。这些单元向量被组装成全局内力向量 $\\mathbf{f}_{\\mathrm{int}}$。\n\n由边界牵引力产生的一致节点力是为网格片外边界上的每条边计算的。对于一条具有牵引力向量 $\\mathbf{t}$ 的边 $\\Gamma_e$，力向量为：\n$$ \\mathbf{f}_{e, \\mathrm{trac}} = \\int_{\\Gamma_e} \\mathbf{N}^\\top \\mathbf{t} \\, \\mathrm{d}\\Gamma $$\n在具有单位外法向量 $\\mathbf{n}$ 的边上，牵引力 $\\mathbf{t}$ 由 $\\mathbf{t} = \\hat{\\boldsymbol{\\sigma}}\\mathbf{n}$ 给出，其中 $\\hat{\\boldsymbol{\\sigma}}$ 是柯西应力张量。对于我们的恒定应力场，$\\mathbf{t}$ 在每条直边界边上是恒定的。对于具有节点 $i$ 和 $j$ 的线性边单元，该积分将总边力 $L_e t \\mathbf{t}$ 平均分配给两个节点：\n$$ \\mathbf{f}_{i, \\mathrm{trac}} = \\mathbf{f}_{j, \\mathrm{trac}} = \\frac{L_e t}{2} \\mathbf{t} $$\n其中 $L_e$ 是边长。这些节点力被组装成全局牵引力向量 $\\mathbf{f}_{\\mathrm{trac}}$。\n\n然后计算所得残差向量的范数 $\\|\\mathbf{r}\\|_2 = \\|\\mathbf{f}_{\\mathrm{int}} - \\mathbf{f}_{\\mathrm{trac}}\\|_2$。理论预测此范数将为零（在浮点容差范围内），从而证实 CST 公式通过了网格片检验。\n\n每个测试算例的计算流程如下：\n1.  解析算例数据：节点坐标、单元连接关系、边界边、材料属性和线性场系数。\n2.  **再现误差**：\n    a. 对于每个单元，确定采样点（质心、边中点）。\n    b. 通过在单元节点处评估给定的线性场来计算精确的节点位移。\n    c. 在每个采样点，使用节点值和形函数计算插值的有限元位移。\n    d. 计算采样点处的精确位移。\n    e. 计算有限元位移和精确位移之间 $u$ 和 $v$ 分量的绝对误差。\n    f. 所有单元和采样点中这些误差的最大值即为该测试算例的结果。\n3.  **残差范数**：\n    a. 将全局力向量 $\\mathbf{f}_{\\mathrm{int}}$ 和 $\\mathbf{f}_{\\mathrm{trac}}$ 初始化为零。\n    b. 从线性场系数和材料属性计算常数应变向量 $\\boldsymbol{\\varepsilon}$ 和应力向量 $\\boldsymbol{\\sigma}$。\n    c. 遍历所有单元：计算单元内力向量 $\\mathbf{f}_{e, \\mathrm{int}}$ 并将其组装到 $\\mathbf{f}_{\\mathrm{int}}$ 中。\n    d. 遍历所有边界边：计算牵引力向量 $\\mathbf{t}$、节点力，并将其组装到 $\\mathbf{f}_{\\mathrm{trac}}$ 中。\n    e. 计算残差 $\\mathbf{r} = \\mathbf{f}_{\\mathrm{int}} - \\mathbf{f}_{\\mathrm{trac}}$ 及其欧几里得范数。\n\n此流程在实施后，将从数值上证明 CST 公式对于常应变状态的正确性，这是有限元理论的基石。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the verification tests for CST elements.\n    \"\"\"\n    test_cases = [\n        {\n            \"nodes\": np.array([[0, 0], [1, 0], [1, 1], [0, 1]]),\n            \"elements\": np.array([[0, 1, 2], [0, 2, 3]]),\n            \"boundary_edges\": np.array([[0, 1], [1, 2], [2, 3], [3, 0]]),\n            \"material\": {\"E\": 210e9, \"nu\": 0.3, \"t\": 0.01},\n            \"field\": {\"a\": [1, 2, -3], \"b\": [-0.5, 4, 1]},\n        },\n        {\n            \"nodes\": np.array([[0, 0], [2, 0], [2, 1], [0, 1], [1, 0.5]]),\n            \"elements\": np.array([[0, 1, 4], [1, 2, 4], [2, 3, 4], [3, 0, 4]]),\n            \"boundary_edges\": np.array([[0, 1], [1, 2], [2, 3], [3, 0]]),\n            \"material\": {\"E\": 70e9, \"nu\": 0.25, \"t\": 0.02},\n            \"field\": {\"a\": [-0.1, 0.3, 0.2], \"b\": [0.7, -0.6, 0.4]},\n        },\n        {\n            \"nodes\": np.array([[0, 0], [0.001, 0], [1, 0.1]]),\n            \"elements\": np.array([[0, 1, 2]]),\n            \"boundary_edges\": np.array([[0, 1], [1, 2], [2, 0]]),\n            \"material\": {\"E\": 110e9, \"nu\": 0.29, \"t\": 0.005},\n            \"field\": {\"a\": [0.02, 0, 0.001], \"b\": [-0.03, -0.001, 0]},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        err = calculate_reproduction_error(case)\n        residual_norm = calculate_residual_norm(case)\n        results.extend([err, residual_norm])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_cst_b_matrix_and_area(node_coords):\n    \"\"\"\n    Computes the B-matrix and area for a CST element.\n    node_coords is a 3x2 numpy array of [[x1, y1], [x2, y2], [x3, y3]].\n    \"\"\"\n    mat = np.hstack([np.ones((3, 1)), node_coords])\n    area = 0.5 * np.linalg.det(mat)\n    \n    # Ensure area is positive (assumes CCW ordering)\n    if area  0:\n        # This case is not expected with problem data but good practice\n        node_coords = node_coords[[0, 2, 1], :]\n        area = -area\n\n    (x1, y1), (x2, y2), (x3, y3) = node_coords\n    \n    b_mat = (1 / (2 * area)) * np.array([\n        [y2 - y3, 0, y3 - y1, 0, y1 - y2, 0],\n        [0, x3 - x2, 0, x1 - x3, 0, x2 - x1],\n        [x3 - x2, y2 - y3, x1 - x3, y3 - y1, x2 - x1, y1 - y2]\n    ])\n    \n    return b_mat, area\n\ndef calculate_reproduction_error(case):\n    \"\"\"\n    Calculates the maximum absolute displacement reproduction error.\n    \"\"\"\n    nodes = case[\"nodes\"]\n    elements = case[\"elements\"]\n    a_coeffs, b_coeffs = case[\"field\"][\"a\"], case[\"field\"][\"b\"]\n\n    max_error = 0.0\n\n    # Define exact displacement field functions\n    def u_exact(x, y):\n        return a_coeffs[0] + a_coeffs[1] * x + a_coeffs[2] * y\n\n    def v_exact(x, y):\n        return b_coeffs[0] + b_coeffs[1] * x + b_coeffs[2] * y\n\n    for el_nodes_idx in elements:\n        node_coords = nodes[el_nodes_idx]\n        \n        # Get exact nodal displacements\n        nodal_u = u_exact(node_coords[:, 0], node_coords[:, 1])\n        nodal_v = v_exact(node_coords[:, 0], node_coords[:, 1])\n\n        # Define sample points: centroid and edge midpoints\n        p1, p2, p3 = node_coords[0], node_coords[1], node_coords[2]\n        sample_points = [\n            (p1 + p2 + p3) / 3.0,  # Centroid\n            (p1 + p2) / 2.0,       # Midpoint of edge 1-2\n            (p2 + p3) / 2.0,       # Midpoint of edge 2-3\n            (p3 + p1) / 2.0,       # Midpoint of edge 3-1\n        ]\n        \n        for sp in sample_points:\n            x_sp, y_sp = sp\n\n            # Calculate shape function values (using area coordinates)\n            mat = np.hstack([np.ones((3, 1)), node_coords])\n            total_area = 0.5 * np.linalg.det(mat)\n            \n            # Area coordinates L1, L2, L3 are the shape function values N1, N2, N3\n            N = np.zeros(3)\n            # N1 = Area(P, P2, P3) / TotalArea\n            N[0] = 0.5 * np.linalg.det(np.array([[1, x_sp, y_sp], [1, p2[0], p2[1]], [1, p3[0], p3[1]]])) / total_area\n            # N2 = Area(P, P3, P1) / TotalArea\n            N[1] = 0.5 * np.linalg.det(np.array([[1, x_sp, y_sp], [1, p3[0], p3[1]], [1, p1[0], p1[1]]])) / total_area\n            # N3 = 1 - N1 - N2\n            N[2] = 1.0 - N[0] - N[1]\n\n            # FE interpolated displacement\n            u_fe = np.dot(N, nodal_u)\n            v_fe = np.dot(N, nodal_v)\n\n            # Exact displacement\n            u_ex = u_exact(x_sp, y_sp)\n            v_ex = v_exact(x_sp, y_sp)\n\n            # Update max error\n            max_error = max(max_error, abs(u_fe - u_ex), abs(v_fe - v_ex))\n            \n    return max_error\n\ndef calculate_residual_norm(case):\n    \"\"\"\n    Calculates the Euclidean norm of the assembled residual vector.\n    \"\"\"\n    nodes = case[\"nodes\"]\n    elements = case[\"elements\"]\n    boundary_edges = case[\"boundary_edges\"]\n    E, nu, t = case[\"material\"][\"E\"], case[\"material\"][\"nu\"], case[\"material\"][\"t\"]\n    a_coeffs, b_coeffs = case[\"field\"][\"a\"], case[\"field\"][\"b\"]\n\n    num_nodes = len(nodes)\n    f_int = np.zeros(2 * num_nodes)\n    f_trac = np.zeros(2 * num_nodes)\n\n    # 1. Calculate constant strain and stress from the linear field\n    strain = np.array([\n        a_coeffs[1],                # eps_xx = a1\n        b_coeffs[2],                # eps_yy = b2\n        a_coeffs[2] + b_coeffs[1]   # gamma_xy = a2 + b1\n    ])\n    \n    # Plane stress constitutive matrix D\n    D_mat = (E / (1 - nu**2)) * np.array([\n        [1, nu, 0],\n        [nu, 1, 0],\n        [0, 0, (1 - nu) / 2]\n    ])\n    \n    stress = D_mat @ strain\n\n    # 2. Assemble internal force vector f_int\n    for el_nodes_idx in elements:\n        node_coords = nodes[el_nodes_idx]\n        b_mat, area = get_cst_b_matrix_and_area(node_coords)\n        \n        f_e_int = b_mat.T @ stress * area * t\n        \n        # Assembly map\n        dof_indices = np.array([2*i for i in el_nodes_idx] + [2*i+1 for i in el_nodes_idx]).reshape(2,3).T.flatten()\n        f_int[dof_indices] += f_e_int\n\n    # 3. Assemble traction force vector f_trac\n    # Stress tensor in 2x2 matrix form for traction calculation\n    stress_tensor = np.array([\n        [stress[0], stress[2]],  # [sigma_xx, sigma_xy]\n        [stress[2], stress[1]]   # [sigma_xy, sigma_yy]\n    ])\n    \n    for edge_nodes_idx in boundary_edges:\n        n1_idx, n2_idx = edge_nodes_idx\n        p1, p2 = nodes[n1_idx], nodes[n2_idx]\n        \n        dx, dy = p2[0] - p1[0], p2[1] - p1[1]\n        length = np.sqrt(dx**2 + dy**2)\n        \n        # Outward normal vector (assuming CCW boundary edge ordering)\n        normal = np.array([dy, -dx]) / length\n        \n        # Traction vector t = sigma * n\n        traction_vec = stress_tensor @ normal\n        \n        # Distribute force to nodes\n        node_force = (length * t / 2) * traction_vec\n        \n        # Assembly\n        f_trac[2*n1_idx: 2*n1_idx+2] += node_force\n        f_trac[2*n2_idx: 2*n2_idx+2] += node_force\n\n    # 4. Calculate residual and its norm\n    residual = f_int - f_trac\n    return np.linalg.norm(residual)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3607774"}, {"introduction": "虽然 CST 单元对于线性位移场是精确的，但在更复杂的场景中其性能会下降。本练习将直接比较 CST 单元与更高阶的线性应变三角形（Linear Strain Triangle, LST）单元在面对二次位移场时的逼近能力 [@problem_id:3607784]。通过量化两者的应变逼近误差，您将对单元阶次与精度之间的权衡有一个实践性的理解。", "problem": "一个二维小应变连续体被用三角形有限元进行离散化。考虑常应变三角形（CST）和线性应变三角形（LST）。CST在一个三节点三角形上采用线性形函数，从而在单元内部产生一个常应变场。LST在一个六节点三角形（三个顶点和三个边中点节点）上采用二次形函数，可以精确地插值单元内的任何二次位移场。\n\n从二维无穷小应变的定义出发，假设位移场是位置的二次函数：\n$$\nu(x,y) = a\\,x^2 + b\\,x\\,y + c\\,y^2 + d\\,x + e\\,y + f,\\qquad\nv(x,y) = p\\,x^2 + q\\,x\\,y + r\\,y^2 + s\\,x + t\\,y + w,\n$$\n其中 $u$ 和 $v$ 是位移分量，$a,b,c,d,e,f,p,q,r,s,t,w$ 是实系数。小应变张量分量定义为\n$$\n\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x},\\quad\n\\varepsilon_{yy} = \\frac{\\partial v}{\\partial y},\\quad\n\\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}.\n$$\n对于一个给定顶点为 $(x_1,y_1)$、$(x_2,y_2)$、$(x_3,y_3)$ 的三角形，将其重心（面积）坐标记为 $(L_1,L_2,L_3)$，满足 $L_1+L_2+L_3=1$ 且 $L_i\\ge 0$。CST 使用线性形函数 $N_1=L_1$，$N_2=L_2$，$N_3=L_3$。LST 使用二次形函数 $N_1=L_1(2L_1-1)$，$N_2=L_2(2L_2-1)$，$N_3=L_3(2L_3-1)$，$N_4=4L_1L_2$，$N_5=4L_2L_3$，$N_6=4L_3L_1$。重心坐标是单元上 $(x,y)$ 的线性函数，并且它们的梯度是常数。\n\n你的任务是实现一个程序，该程序：\n- 使用指定的系数构造精确的二次位移场。\n- 通过在节点处评估精确位移场，计算 CST 的顶点节点位移和 LST 的 $6$ 个节点（顶点和边中点节点）位移。\n- 构建 CST 和 LST 的单元位移近似，并使用小应变定义计算相应的应变分量。\n- 从二次场中评估精确的应变分量。\n- 通过在一组由重心坐标指定的内部采样点上计算均方根（RMS）范数，来量化单元内部的残余应变误差。\n\n使用以下三个测试用例，每个用例都由三角形顶点坐标和位移系数定义：\n- 案例 $1$（具有混合二次和线性项的普通不等边三角形）：\n  - 三角形顶点：$(0,0)$, $(2,0)$, $(0.5,1.5)$。\n  - $u$ 的系数：$a=0.3$, $b=-0.2$, $c=0.4$, $d=1.0$, $e=-0.5$, $f=0.0$。\n  - $v$ 的系数：$p=-0.1$, $q=0.25$, $r=0.2$, $s=-0.7$, $t=0.3$, $w=0.2$。\n- 案例 $2$（具有纯二次场的等边三角形）：\n  - 三角形顶点：$(0,0)$, $(1,0)$, $\\left(0.5,\\frac{\\sqrt{3}}{2}\\right)$。\n  - $u$ 的系数：$a=0.5$, $b=0.1$, $c=0.3$, $d=0.0$, $e=0.0$, $f=0.0$。\n  - $v$ 的系数：$p=-0.4$, $q=0.2$, $r=0.1$, $s=0.0$, $t=0.0$, $w=0.0$。\n- 案例 $3$（用于探究几何条件数的窄长三角形）：\n  - 三角形顶点：$(0,0)$, $(10^{-3},0)$, $(0,1.0)$。\n  - $u$ 的系数：$a=0.8$, $b=-0.6$, $c=0.5$, $d=0.0$, $e=1.0$, $f=-0.3$。\n  - $v$ 的系数：$p=0.2$, $q=0.3$, $r=-0.4$, $s=0.0$, $t=-0.2$, $w=0.5$。\n\n使用以下由重心坐标定义的 $7$ 个采样点来评估 RMS 误差：\n$$\n(1/3,1/3,1/3),\\ (0.6,0.2,0.2),\\ (0.2,0.6,0.2),\\ (0.2,0.2,0.6),\\ (0.05,0.05,0.90),\\ (0.05,0.90,0.05),\\ (0.90,0.05,0.05).\n$$\n在每个采样点，计算 CST 和 LST 的近似应变以及二次场的精确应变，得到每种方法的误差向量 $(\\varepsilon_{xx}^{h}-\\varepsilon_{xx}^{\\text{exact}},\\varepsilon_{yy}^{h}-\\varepsilon_{yy}^{\\text{exact}},\\gamma_{xy}^{h}-\\gamma_{xy}^{\\text{exact}})$，累加误差范数的平方和，除以采样点数，然后取平方根以获得 RMS 误差。应变是无量纲的；以无量纲浮点数报告 RMS 残差。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表包含 $6$ 个结果，顺序为 $[\\text{案例 }1\\ \\text{CST RMS},\\ \\text{案例 }1\\ \\text{LST RMS},\\ \\text{案例 }2\\ \\text{CST RMS},\\ \\text{案例 }2\\ \\text{LST RMS},\\ \\text{案例 }3\\ \\text{CST RMS},\\ \\text{案例 }3\\ \\text{LST RMS}]$。例如，输出格式为 $[r_1^{\\text{CST}},r_1^{\\text{LST}},r_2^{\\text{CST}},r_2^{\\text{LST}},r_3^{\\text{CST}},r_3^{\\text{LST}}]$。", "solution": "该问题已经过验证，被认为是合理的。这是一个基于计算固体力学和有限元方法原理的适定数值分析问题。所有需要的数据和定义都已提供，没有内部矛盾或科学上的不准确之处。\n\n解决方案通过实施一项计算分析来进行，目的是量化常应变三角形（CST）和线性应变三角形（LST）单元在承受精确二次位移场时的应变近似误差。误差通过应变张量分量的均方根（RMS）范数来衡量，该范数是在单元内一组预定的采样点上评估的。\n\n首先，我们定义精确的位移场和应变场。问题提供了一个二维 $(x, y)$ 中的通用二次位移场：\n$$u(x,y) = a\\,x^2 + b\\,x\\,y + c\\,y^2 + d\\,x + e\\,y + f$$\n$$v(x,y) = p\\,x^2 + q\\,x\\,y + r\\,y^2 + s\\,x + t\\,y + w$$\n其中 $u$ 和 $v$ 分别是沿 $x$ 和 $y$ 轴的位移分量。系数 $a,b,c,d,e,f,p,q,r,s,t,w$ 已为每个测试案例给出。\n\n精确的无穷小应变张量分量 $(\\varepsilon_{xx}^{\\text{exact}}, \\varepsilon_{yy}^{\\text{exact}}, \\gamma_{xy}^{\\text{exact}})$ 是通过根据小应变定义对位移场进行微分得出的：\n$$\\varepsilon_{xx}^{\\text{exact}} = \\frac{\\partial u}{\\partial x} = 2ax + by + d$$\n$$\\varepsilon_{yy}^{\\text{exact}} = \\frac{\\partial v}{\\partial y} = qx + 2ry + t$$\n$$\\gamma_{xy}^{\\text{exact}} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x} = (bx + 2cy + e) + (2px + qy + s) = (b+2p)x + (2c+q)y + (e+s)$$\n注意，对于二次位移场，产生的应变场是关于位置 $(x, y)$ 的线性函数。\n\n接下来，我们构建有限元近似。此公式的一个关键组成部分是使用重心坐标 $(L_1, L_2, L_3)$，用于一个顶点为 $(x_1, y_1)$、$(x_2, y_2)$ 和 $(x_3, y_3)$ 的三角形。三角形内的任何点 $(x,y)$ 都可以表示为顶点的凸组合：$x = L_1x_1 + L_2x_2 + L_3x_3$ 和 $y = L_1y_1 + L_2y_2 + L_3y_3$，其中 $L_1+L_2+L_3=1$。近似位移场 $u^h(x,y)$ 是通过使用形函数 $N_i$ 插值节点位移 $u_i$ 来构建的：$u^h = \\sum_i N_i u_i$。为了计算应变，我们需要形函数的空间梯度。由于形函数是根据重心坐标定义的，我们使用链式法则：$\\frac{\\partial N_i}{\\partial x} = \\sum_{j=1}^3 \\frac{\\partial N_i}{\\partial L_j} \\frac{\\partial L_j}{\\partial x}$。重心坐标的梯度在整个单元内是恒定的，并由以下公式给出：\n$$ \\frac{\\partial L_1}{\\partial x} = \\frac{y_2 - y_3}{2A}, \\quad \\frac{\\partial L_1}{\\partial y} = \\frac{x_3 - x_2}{2A} $$\n$$ \\frac{\\partial L_2}{\\partial x} = \\frac{y_3 - y_1}{2A}, \\quad \\frac{\\partial L_2}{\\partial y} = \\frac{x_1 - x_3}{2A} $$\n$$ \\frac{\\partial L_3}{\\partial x} = \\frac{y_1 - y_2}{2A}, \\quad \\frac{\\partial L_3}{\\partial y} = \\frac{x_2 - x_1}{2A} $$\n其中 $A$ 是三角形的面积，计算公式为 $2A = x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2)$。\n\n对于常应变三角形（CST），我们在顶点处有 $3$ 个节点。形函数是线性的：$N_1=L_1, N_2=L_2, N_3=L_3$。因此，位移近似 $u^h$ 是线性的，其导数，即应变 $\\varepsilon^h$，是常数。节点位移 $(u_i,v_i)$（$i=1,2,3$）是通过在顶点坐标处评估精确的二次位移场得到的。那么，常数近似应变分量为：\n$$ \\varepsilon_{xx}^h = \\sum_{i=1}^3 \\frac{\\partial N_i}{\\partial x} u_i = \\sum_{i=1}^3 \\frac{\\partial L_i}{\\partial x} u_i $$\n$$ \\varepsilon_{yy}^h = \\sum_{i=1}^3 \\frac{\\partial N_i}{\\partial y} v_i = \\sum_{i=1}^3 \\frac{\\partial L_i}{\\partial y} v_i $$\n$$ \\gamma_{xy}^h = \\sum_{i=1}^3 \\frac{\\partial N_i}{\\partial y} u_i + \\sum_{i=1}^3 \\frac{\\partial N_i}{\\partial x} v_i $$\n由于精确应变场是线性的，而 CST 近似是常数，因此预计会存在误差。\n\n对于线性应变三角形（LST），我们有 $6$ 个节点：$3$ 个在顶点，$3$ 个在边的中点。形函数 $N_i$ 是重心坐标的二次多项式。LST 单元的关键特性是它能够精确表示任何二次多项式。二维二次多项式空间 $P_2(x,y)$ 具有 $6$ 个自由度（对应于 $1, x, y, x^2, xy, y^2$ 的系数）。一个 LST 单元有 $6$ 个节点。一个二次多项式由其在 $6$ 个非退化点上的值唯一确定。由于精确位移场 $(u, v)$ 是二次的，并且 LST 节点位移 $(u_i, v_i)$ 是从这个精确场评估得到的，LST 插值 $u^h = \\sum_{i=1}^6 N_i u_i$ 将在单元内的任何地方都与精确场 $u(x,y)$ 完全相同。这是有限元完备性的一个基本属性。因此，从 LST 近似中导出的应变 $\\varepsilon^h$ 将与精确应变 $\\varepsilon^{\\text{exact}}$ 完全相同。因此，LST 单元的应变误差恒为零，最终的 RMS 误差为 $0.0$。\n\n残余误差由 RMS 范数量化。对于 $N_{sp}=7$ 个采样点中的每一个，我们计算应变误差向量 $\\mathbf{e} = (\\varepsilon_{xx}^{h}-\\varepsilon_{xx}^{\\text{exact}},\\varepsilon_{yy}^{h}-\\varepsilon_{yy}^{\\text{exact}},\\gamma_{xy}^{h}-\\gamma_{xy}^{\\text{exact}})$。RMS 误差则为：\n$$ \\text{RMS error} = \\sqrt{\\frac{1}{N_{sp}} \\sum_{k=1}^{N_{sp}} \\|\\mathbf{e}_k\\|^2_2} = \\sqrt{\\frac{1}{N_{sp}} \\sum_{k=1}^{N_{sp}} \\left( (\\varepsilon_{xx,k}^{h}-\\varepsilon_{xx,k}^{\\text{exact}})^2 + (\\varepsilon_{yy,k}^{h}-\\varepsilon_{yy,k}^{\\text{exact}})^2 + (\\gamma_{xy,k}^{h}-\\gamma_{xy,k}^{\\text{exact}})^2 \\right)} $$\n对于 CST 单元，此值通过数值计算得出。对于 LST 单元，此值在理论上和数值上均为 $0.0$。\n\n所实现的算法对每个测试案例执行以下步骤：\n1.  根据给定的系数定义精确的位移和应变函数。\n2.  计算单元的几何属性（面积和重心坐标梯度）。\n3.  对于 CST 分析：\n    a. 在 $3$ 个顶点节点处评估精确位移。\n    b. 计算 CST 单元的常应变分量。\n    c. 将误差平方和初始化为 $0$。\n    d. 对于 $7$ 个采样点中的每一个（以重心坐标给出）：\n        i. 将重心坐标转换为笛卡尔坐标 $(x_{sp}, y_{sp})$。\n        ii. 在 $(x_{sp}, y_{sp})$ 处评估精确应变。\n        iii. 计算该点处恒定 CST 应变与精确应变之间误差向量的平方范数。\n        iv. 将此值加到误差平方和中。\n    e. 通过取误差平方和的均值的平方根来计算 CST 的最终 RMS 误差。\n4.  对于 LST 分析，根据上述理论论证，RMS 误差设置为 $0.0$。\n5.  收集所有案例的结果，并按指定格式呈现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the finite element analysis problem for CST and LST elements.\n    \"\"\"\n\n    def calculate_rms_errors(vertices, u_coeffs, v_coeffs):\n        \"\"\"\n        Calculates RMS strain errors for CST and LST for a single test case.\n\n        Args:\n            vertices (tuple): A tuple of 3 vertex coordinates ((x1, y1), ...).\n            u_coeffs (tuple): Coefficients a, b, c, d, e, f for the u-displacement.\n            v_coeffs (tuple): Coefficients p, q, r, s, t, w for the v-displacement.\n\n        Returns:\n            tuple: A tuple containing (rms_err_cst, rms_err_lst).\n        \"\"\"\n        # Unpack vertices\n        (x1, y1), (x2, y2), (x3, y3) = vertices\n        \n        # Unpack coefficients\n        a, b, c, d, e, f = u_coeffs\n        p, q, r, s, t, w = v_coeffs\n\n        # --- Exact field and strain definitions ---\n        def u_exact(x, y):\n            return a*x**2 + b*x*y + c*y**2 + d*x + e*y + f\n\n        def v_exact(x, y):\n            return p*x**2 + q*x*y + r*y**2 + s*x + t*y + w\n\n        def eps_xx_exact(x, y):\n            return 2*a*x + b*y + d\n\n        def eps_yy_exact(x, y):\n            return q*x + 2*r*y + t\n\n        def gamma_xy_exact(x, y):\n            return (b + 2*p)*x + (2*c + q)*y + (e + s)\n\n        # --- CST (Constant Strain Triangle) Calculation ---\n        \n        # Triangle Area and Barycentric coordinate gradients\n        two_A = x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)\n        if abs(two_A)  1e-20:  # Avoid division by zero for collinear points\n            return np.nan, np.nan\n\n        L1x = (y2 - y3) / two_A\n        L1y = (x3 - x2) / two_A\n        L2x = (y3 - y1) / two_A\n        L2y = (x1 - x3) / two_A\n        L3x = (y1 - y2) / two_A\n        L3y = (x2 - x1) / two_A\n\n        # Nodal displacements for CST (3 vertices)\n        u1, v1 = u_exact(x1, y1), v_exact(x1, y1)\n        u2, v2 = u_exact(x2, y2), v_exact(x2, y2)\n        u3, v3 = u_exact(x3, y3), v_exact(x3, y3)\n        \n        # Constant strain components for CST\n        eps_xx_cst = L1x*u1 + L2x*u2 + L3x*u3\n        eps_yy_cst = L1y*v1 + L2y*v2 + L3y*v3\n        gamma_xy_cst = (L1y*u1 + L2y*u2 + L3y*u3) + (L1x*v1 + L2x*v2 + L3x*v3)\n\n        # --- Error calculation over specified sampling points ---\n        sampling_points_bary = [\n            (1/3, 1/3, 1/3),\n            (0.6, 0.2, 0.2), (0.2, 0.6, 0.2), (0.2, 0.2, 0.6),\n            (0.05, 0.05, 0.90), (0.05, 0.90, 0.05), (0.90, 0.05, 0.05),\n        ]\n        \n        sum_sq_err_cst = 0.0\n        for L1s, L2s, L3s in sampling_points_bary:\n            # Cartesian coordinates of the sampling point\n            xs = L1s*x1 + L2s*x2 + L3s*x3\n            ys = L1s*y1 + L2s*y2 + L3s*y3\n\n            # Exact strain at the sampling point\n            exx_e = eps_xx_exact(xs, ys)\n            eyy_e = eps_yy_exact(xs, ys)\n            gxy_e = gamma_xy_exact(xs, ys)\n\n            # Error for CST\n            err_xx = eps_xx_cst - exx_e\n            err_yy = eps_yy_cst - eyy_e\n            err_gxy = gamma_xy_cst - gxy_e\n            sum_sq_err_cst += err_xx**2 + err_yy**2 + err_gxy**2\n\n        num_sampling_points = len(sampling_points_bary)\n        rms_err_cst = np.sqrt(sum_sq_err_cst / num_sampling_points)\n\n        # --- LST (Linear Strain Triangle) Calculation ---\n        # The LST element with quadratic shape functions can exactly represent the\n        # quadratic displacement field. Therefore, the approximated strains are\n        # identical to the exact strains, and the error is zero.\n        rms_err_lst = 0.0\n\n        return rms_err_cst, rms_err_lst\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"vertices\": ((0.0, 0.0), (2.0, 0.0), (0.5, 1.5)),\n            \"u_coeffs\": (0.3, -0.2, 0.4, 1.0, -0.5, 0.0),\n            \"v_coeffs\": (-0.1, 0.25, 0.2, -0.7, 0.3, 0.2),\n        },\n        {\n            \"vertices\": ((0.0, 0.0), (1.0, 0.0), (0.5, np.sqrt(3)/2)),\n            \"u_coeffs\": (0.5, 0.1, 0.3, 0.0, 0.0, 0.0),\n            \"v_coeffs\": (-0.4, 0.2, 0.1, 0.0, 0.0, 0.0),\n        },\n        {\n            \"vertices\": ((0.0, 0.0), (1e-3, 0.0), (0.0, 1.0)),\n            \"u_coeffs\": (0.8, -0.6, 0.5, 0.0, 1.0, -0.3),\n            \"v_coeffs\": (0.2, 0.3, -0.4, 0.0, -0.2, 0.5),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        rms_cst, rms_lst = calculate_rms_errors(\n            case[\"vertices\"], \n            case[\"u_coeffs\"], \n            case[\"v_coeffs\"]\n        )\n        results.append(rms_cst)\n        results.append(rms_lst)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3607784"}, {"introduction": "一种严格验证有限元实现的方法是使用“制造解法”（Manufactured Solution）进行网格加密研究。本最终实践将之前的概念综合成一个严谨的网格细化分析 [@problem_id:3607799]。通过使用一个已知的二次函数解，我们将数值化地计算 CST 单元应变误差的收敛速度，并验证 LST 列式的精确性，从而为理论误差估计提供具体的证据。", "problem": "要求您构建一个网格精度基准，以在小应变运动学的背景下，评估三角形有限元对一个制造位移解的行为。请从第一性原理出发，直至编写出一个能够计算收敛性指标的完整、可运行的程序。制造位移场被定义为一个二维向量场，其分量为 $u_x(x,y)=x^2+y^2$ 和 $u_y(x,y)=0$。目标是计算精确的小应变场，然后评估常应变三角形（CST）和线性应变三角形（LST）的有限元插值误差，最后验证 LST 的精确性以及 CST 误差随网格尺寸 $h$ 变化的缩放规律。\n\n请从以下基本依据和核心定义开始：\n- 对于小变形，应变分量定义为 $\\varepsilon_{xx} = \\partial u_x / \\partial x$、$\\varepsilon_{yy} = \\partial u_y / \\partial y$ 和 $\\gamma_{xy} = \\partial u_x / \\partial y + \\partial u_y / \\partial x$。\n- 三角形上的有限元插值使用以面积（重心）坐标 $(L_1,L_2,L_3)$ 表示的等参朗格朗日形函数，其中 $L_1+L_2+L_3=1$，$L_i \\ge 0$。对于 CST，形函数是关于 $(L_1,L_2,L_3)$ 的线性多项式；对于 LST，它们是关于 $(L_1,L_2,L_3)$ 的二次多项式。\n- 对于顶点为 $(x_i,y_i)$ 的三角形，面积（重心）坐标满足仿射关系 $\\begin{bmatrix}L_1\\\\L_2\\\\L_3\\end{bmatrix} = \\mathbf{M}^{-1}\\begin{bmatrix}x\\\\y\\\\1\\end{bmatrix}$，其中 $\\mathbf{M}=\\begin{bmatrix}x_1  x_2  x_3\\\\ y_1  y_2  y_3\\\\ 1  1  1\\end{bmatrix}$。它们的空间导数 $\\partial L_i/\\partial x$ 和 $\\partial L_i/\\partial y$ 在每个直边三角形内是常数。\n\n问题任务：\n1. 推导由制造位移场 $u_x(x,y)=x^2+y^2$ 和 $u_y(x,y)=0$ 隐含的精确小应变场 $\\boldsymbol{\\varepsilon}^{\\mathrm{exact}}(x,y)$。明确列出分量 $\\varepsilon_{xx}(x,y)$、$\\varepsilon_{yy}(x,y)$ 和 $\\gamma_{xy}(x,y)$。\n2. 对于顶点为 $(x_i,y_i)$ 的单个三角形单元，推导以面积坐标表示的线性（CST）和二次（LST）朗格朗日形函数及其关于 $x$ 的空间导数。展示如何通过链式法则，从节点位移值和形函数的导数计算应变分量 $\\varepsilon_{xx}^{\\mathrm{FE}}(x,y)$ 的有限元近似。\n3. 对于单位正方形域 $\\Omega=[0,1]\\times[0,1]$ 的给定三角剖分，将网格尺寸 $h$ 定义为 $h=1/N$，其中 $N$ 是每个坐标方向上的区间数，并通过将每个正方形单元以一致的逆时针方向分割成两个三角形来生成一个均匀的直角三角形网格。对每个三角形，计算其对 $\\varepsilon_{xx}$ 分量的 $L^2$ 误差平方的单元贡献：\n   $$E_K^2=\\int_K \\left(\\varepsilon_{xx}^{\\mathrm{exact}}(x,y)-\\varepsilon_{xx}^{\\mathrm{FE}}(x,y)\\right)^2 \\, \\mathrm{d}A,$$\n   以及全局 $L^2$ 误差平方 $E^2=\\sum_K E_K^2$。对于 CST，使用一个对至少2次多项式精确的数值积分法则；对于 LST，使用一个对至少5次多项式精确的数值积分法则。该积分必须在重心坐标中定义，并且最终的物理空间积分必须按三角形面积进行缩放。\n4. 通过计算数值证据验证两个理论性质：\n   - LST（二次三角形位移插值）应能在直边三角形上精确地再现二次制造位移，这意味着在精确算术下，应变场的误差恰好为零。在数值上，这应表现为 $L^2$ 误差极度接近零（在舍入误差范围内）。\n   - CST（线性三角形位移插值）不能精确地再现二次位移；对于光滑的二次函数 $u_x$，在网格细化下，应变误差的 $L^2$ 范数预计将按 $\\mathcal{O}(h)$ 的阶数收敛。在数值上，比值 $E(h)/E(h/2)$ 应趋近于 $2$。\n\n测试套件和要求输出：\n- 使用以下三角剖分和单元类型作为测试套件：\n  - CST，其中 $N\\in\\{2,4,8\\}$，即 $h\\in\\{1/2,1/4,1/8\\}$。\n  - LST，其中 $N\\in\\{4,8\\}$，即 $h\\in\\{1/4,1/8\\}$。\n- 对于每个 CST 情况，计算 $\\varepsilon_{xx}$ 的全局 $L^2$ 误差，记为 $E_{\\mathrm{CST}}(N)$。\n- 对于 CST，还需计算细化比 $R_{2\\to 4}=E_{\\mathrm{CST}}(2)/E_{\\mathrm{CST}}(4)$ 和 $R_{4\\to 8}=E_{\\mathrm{CST}}(4)/E_{\\mathrm{CST}}(8)$。\n- 对于每个 LST 情况，计算 $\\varepsilon_{xx}$ 的全局 $L^2$ 误差，记为 $E_{\\mathrm{LST}}(N)$，并报告一个布尔标志：如果 $E_{\\mathrm{LST}}(N)  10^{-12}$ 则为 $\\mathrm{true}$，否则为 $\\mathrm{false}$。\n- 您的程序必须生成单行输出，其中包含一个方括号内的逗号分隔列表，结果顺序如下：\n  $$\\left[ E_{\\mathrm{CST}}(2), E_{\\mathrm{CST}}(4), E_{\\mathrm{CST}}(8), R_{2\\to 4}, R_{4\\to 8}, E_{\\mathrm{LST}}(4), E_{\\mathrm{LST}}(8), \\mathbf{1}\\{E_{\\mathrm{LST}}(4)  10^{-12}\\}, \\mathbf{1}\\{E_{\\mathrm{LST}}(8)  10^{-12}\\} \\right].$$\n除最后两个布尔条目外，所有输出都应为无量纲实数。不涉及角度。程序必须是自包含的，且不要求任何输入。", "solution": "问题陈述构成了一个有效且适定的计算力学任务，特别适用于有限元公式的验证。其科学基础在于连续介质力学和有限元法的原理，提供了完整且一致的数据和定义集，并概述了一个可行的计算流程。所有术语在该领域内都是标准且无歧义的。因此，我们可以进行完整求解。\n\n解答将遵循问题陈述中列出的四个任务进行。\n\n### 1. 精确小应变场\n\n制造位移场以向量场 $\\mathbf{u}(x,y)$ 形式给出，其分量为 $u_x(x,y) = x^2+y^2$ 和 $u_y(x,y) = 0$。小应变分量由其定义计算得出：\n$$\n\\varepsilon_{xx} = \\frac{\\partial u_x}{\\partial x}, \\quad \\varepsilon_{yy} = \\frac{\\partial u_y}{\\partial y}, \\quad \\gamma_{xy} = \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x}\n$$\n为求精确应变场 $\\boldsymbol{\\varepsilon}^{\\mathrm{exact}}(x,y)$，我们计算给定到位移分量的偏导数：\n- 因此，精确应变场的显式分量为：\n$$\n\\varepsilon_{xx}^{\\mathrm{exact}}(x,y) = 2x\n$$\n$$\n\\varepsilon_{yy}^{\\mathrm{exact}}(x,y) = 0\n$$\n$$\n\\gamma_{xy}^{\\mathrm{exact}}(x,y) = 2y\n$$\n\n### 2. 有限元应变近似\n\n在单个单元 $K$ 上，位移分量（例如 $u_x(x,y)$）的有限元近似由插值给出：\n$$\nu_x^{\\mathrm{FE}}(x,y) = \\sum_{i=1}^{n_{\\text{nodes}}} N_i(x,y) u_{x,i}\n$$\n其中 $n_{\\text{nodes}}$ 是单元的节点数，$u_{x,i}$ 是位移分量的节点值，$N_i(x,y)$ 是等参形函数。节点位移通过在节点坐标 $(x_i, y_i)$ 处计算精确位移场得到：$u_{x,i} = u_x(x_i, y_i) = x_i^2 + y_i^2$。\n\n相应的应变分量 $\\varepsilon_{xx}^{\\mathrm{FE}}$ 通过微分得到：\n$$\n\\varepsilon_{xx}^{\\mathrm{FE}}(x,y) = \\frac{\\partial u_x^{\\mathrm{FE}}}{\\partial x} = \\sum_{i=1}^{n_{\\text{nodes}}} \\frac{\\partial N_i(x,y)}{\\partial x} u_{x,i}\n$$\n形函数的空间导数 $\\frac{\\partial N_i}{\\partial x}$ 使用链式法则计算。由于形函数自然地用重心坐标 $(L_1, L_2, L_3)$ 定义，我们有：\n$$\n\\frac{\\partial N_i}{\\partial x} = \\frac{\\partial N_i}{\\partial L_1}\\frac{\\partial L_1}{\\partial x} + \\frac{\\partial N_i}{\\partial L_2}\\frac{\\partial L_2}{\\partial x} + \\frac{\\partial N_i}{\\partial L_3}\\frac{\\partial L_3}{\\partial x}\n$$\n在顶点为 $(x_1,y_1), (x_2,y_2), (x_3,y_3)$、面积为 $A$ 的直边三角形内，重心坐标相对于笛卡尔坐标的导数是常数。它们由下式给出：\n$$\n\\frac{\\partial L_1}{\\partial x} = \\frac{y_2-y_3}{2A}, \\quad \\frac{\\partial L_2}{\\partial x} = \\frac{y_3-y_1}{2A}, \\quad \\frac{\\partial L_3}{\\partial x} = \\frac{y_1-y_2}{2A}\n$$\n其中 $2A = x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)$，对于逆时针排序的顶点。\n\n**常应变三角形 (CST)：**\nCST 是一个3节点单元，节点即为顶点。\n- 形函数：$N_i = L_i$ for $i=1,2,3$。\n- 形函数相对于重心坐标的导数：$\\frac{\\partial N_i}{\\partial L_j} = \\delta_{ij}$ (克罗内克 δ)。\n- 空间导数：$\\frac{\\partial N_i}{\\partial x} = \\frac{\\partial L_i}{\\partial x}$。这些是常数。\n- 因此，应变近似在单元上是常数：\n$$\n\\varepsilon_{xx}^{\\mathrm{CST}} = \\sum_{i=1}^{3} \\frac{\\partial L_i}{\\partial x} u_{x,i} = \\frac{1}{2A} \\left( (y_2-y_3)u_{x,1} + (y_3-y_1)u_{x,2} + (y_1-y_2)u_{x,3} \\right)\n$$\n\n**线性应变三角形 (LST)：**\nLST 是一个6节点单元，有3个顶点节点和3个中点节点。设顶点为节点1,2,3，中点节点为4（在边1-2上）、5（在边2-3上）和6（在边3-1上）。\n- 形函数（$L_i$ 的二次函数）：\n  - 顶点节点 ($i=1,2,3$): $N_i = L_i(2L_i - 1)$\n  - 中点节点: $N_4 = 4L_1L_2$, $N_5=4L_2L_3$, $N_6=4L_3L_1$\n- 形函数相对于重心坐标的导数，例如：\n  - $\\frac{\\partial N_1}{\\partial L_1} = 4L_1-1$, $\\frac{\\partial N_1}{\\partial L_2} = 0$, $\\frac{\\partial N_1}{\\partial L_3} = 0$。\n  - $\\frac{\\partial N_4}{\\partial L_1} = 4L_2$, $\\frac{\\partial N_4}{\\partial L_2} = 4L_1$, $\\frac{\\partial N_4}{\\partial L_3} = 0$。\n- 空间导数是位置（通过 $L_i$）的线性函数，例如：\n  - $\\frac{\\partial N_1}{\\partial x} = (4L_1-1)\\frac{\\partial L_1}{\\partial x}$\n  - $\\frac{\\partial N_4}{\\partial x} = 4\\left(L_2 \\frac{\\partial L_1}{\\partial x} + L_1 \\frac{\\partial L_2}{\\partial x}\\right)$\n- 应变近似 $\\varepsilon_{xx}^{\\mathrm{LST}}(x,y) = \\sum_{i=1}^{6} \\frac{\\partial N_i}{\\partial x} u_{x,i}$ 在单元内是位置的线性函数。\n\n### 3. 误差计算与数值积分\n\n在单个单元 $K$ 上，$\\varepsilon_{xx}$ 分量的 $L^2$ 误差平方为 $E_K^2=\\int_K \\left(\\varepsilon_{xx}^{\\mathrm{exact}}-\\varepsilon_{xx}^{\\mathrm{FE}}\\right)^2 \\, \\mathrm{d}A$。全局误差是单元贡献的总和，$E = \\sqrt{\\sum_K E_K^2}$。\n\n该积分使用三角形上的数值积分计算。一个积分法则是具有重心坐标 $\\mathbf{L}_q = (L_{1,q}, L_{2,q}, L_{3,q})$ 和权重 $w_q$ 的一组点 $q$。积分近似为：\n$$\n\\int_K f(x,y) \\, \\mathrm{d}A \\approx A \\sum_{q} w_q f(\\mathbf{x}(\\mathbf{L}_q))\n$$\n其中 $\\mathbf{x}(\\mathbf{L}_q) = \\sum_{i=1}^3 \\mathbf{L}_{i,q} \\mathbf{x}_i$ 将积分点从重心坐标映射到物理坐标。\n\n被积函数是 $(\\varepsilon_{xx}^{\\mathrm{exact}}(x,y)-\\varepsilon_{xx}^{\\mathrm{FE}}(x,y))^2$。\n- 对于CST，$\\varepsilon_{xx}^{\\mathrm{exact}}=2x$ 是线性的，而 $\\varepsilon_{xx}^{\\mathrm{CST}}$ 是常数。被积函数是一个二次多项式。需要一个对2次多项式精确的积分法则，例如在参考三角形边中点的3点法则。\n- 对于LST，$\\varepsilon_{xx}^{\\mathrm{exact}}=2x$ 是线性的，而 $\\varepsilon_{xx}^{\\mathrm{LST}}$ 也是线性的。被积函数是一个二次多项式。问题指定了一个对至少5次多项式精确的积分法则。虽然这对本特定问题而言是过度指定，但我们将遵循它，使用一个5次的对称7点法则。\n\n网格在单位正方形 $\\Omega=[0,1]\\times[0,1]$ 上生成，首先创建一个边长为 $h=1/N$ 的 $N\\times N$ 正方形网格。每个左下角在 $(i h, j h)$ 的正方形单元被划分为两个具有逆时针顶点排序的直角三角形：\n- 三角形1的顶点：$(ih, jh), ((i+1)h, jh), ((i+1)h, (j+1)h)$\n- 三角形2的顶点：$(ih, jh), ((i+1)h, (j+1)h), (ih, (j+1)h)$\n\n### 4. 理论性质的验证\n\n**LST 精确性：** 制造位移 $u_x(x,y)=x^2+y^2$ 是一个二次多项式。6节点 LST 单元使用二次形函数。对于任何三角形，有限元插值 $u_x^{\\mathrm{FE}}(x,y) = \\sum_{i=1}^{6} N_i(x,y) u_{x,i}$ 是一个二次多项式，根据其构造，它在所有6个节点上都与精确解 $u_x(x_i,y_i)$ 匹配。由于一个二维二次多项式由其在6个一般位置点上的值唯一确定，因此插值场必须与精确场完全相同：$u_x^{\\mathrm{FE}}(x,y) \\equiv u_x(x,y)$。因此，它们的导数也完全相同：$\\varepsilon_{xx}^{\\mathrm{LST}}(x,y) \\equiv \\varepsilon_{xx}^{\\mathrm{exact}}(x,y)$。误差被积函数恒为零，计算出的 $L^2$ 误差应在机器浮点精度范围内为零。\n\n**CST 收敛性：** CST 单元使用线性形函数（$k=1$）来近似一个二次位移场。标准有限元插值理论预测，导数（应变）的误差以网格尺寸的阶数收敛，即 $\\|\\boldsymbol{\\varepsilon}^{\\mathrm{exact}} - \\boldsymbol{\\varepsilon}^{\\mathrm{CST}}\\|_{L^2} = \\mathcal{O}(h^k) = \\mathcal{O}(h)$。因此，当通过将单元尺寸 $h$ 减半来细化网格时，误差 $E(h)$ 也应减半。误差比 $E(h)/E(h/2)$ 预计将趋近于 $2^1=2$。数值实验将验证此收敛率。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes a mesh-precision benchmark for CST and LST finite elements.\n    \"\"\"\n\n    # Manufactured solution and its exact strain derivative\n    def u_exact(x, y):\n        return x**2 + y**2\n\n    def eps_xx_exact(x, y):\n        return 2 * x\n\n    # --- Quadrature Rules ---\n    # 3-point rule, exact for degree 2 polynomials\n    QUAD_CST = {\n        'points': np.array([\n            [0.5, 0.0, 0.5],\n            [0.5, 0.5, 0.0],\n            [0.0, 0.5, 0.5]\n        ]),\n        'weights': np.array([1/3, 1/3, 1/3])\n    }\n\n    # 7-point rule, exact for degree 5 polynomials (Dunavant)\n    alpha = (6 + np.sqrt(21)) / 21\n    beta = (1 - alpha) / 2\n    gamma = (6 - np.sqrt(21)) / 21\n    delta = (1 - gamma) / 2\n    \n    w1 = (155 - np.sqrt(21)) / 1200\n    w2 = (155 + np.sqrt(21)) / 1200\n    wc = 9/40\n\n    QUAD_LST = {\n        'points': np.array([\n            [1/3, 1/3, 1/3],\n            [alpha, beta,  beta],\n            [beta,  alpha, beta],\n            [beta,  beta,  alpha],\n            [gamma, delta, delta],\n            [delta, gamma, delta],\n            [delta, delta, gamma],\n        ]),\n        'weights': np.array([wc, w1, w1, w1, w2, w2, w2])\n    }\n\n    def get_mesh_triangles(N):\n        \"\"\"Generates a list of triangles for a given grid division N.\"\"\"\n        h = 1.0 / N\n        triangles = []\n        for i in range(N):\n            for j in range(N):\n                # Coordinates of the square cell corners\n                p1 = np.array([i * h, j * h])\n                p2 = np.array([(i + 1) * h, j * h])\n                p3 = np.array([(i + 1) * h, (j + 1) * h])\n                p4 = np.array([i * h, (j + 1) * h])\n                \n                # Split square into two triangles with CCW orientation\n                # Triangle 1: (p1, p2, p3)\n                triangles.append(np.array([p1, p2, p3]))\n                # Triangle 2: (p1, p3, p4) for CCW\n                triangles.append(np.array([p1, p3, p4])) # This gives h^2, so it's CCW\n        return triangles\n\n    def get_l_derivs(verts):\n        \"\"\"Computes derivatives of barycentric coords w.r.t. x and y.\"\"\"\n        p1, p2, p3 = verts[0], verts[1], verts[2]\n        # 2 * Area\n        area2 = p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])\n        if area2 == 0:\n            raise ValueError(\"Triangle with zero area.\")\n        \n        # Derivatives w.r.t x\n        dL1_dx = (p2[1] - p3[1]) / area2\n        dL2_dx = (p3[1] - p1[1]) / area2\n        dL3_dx = (p1[1] - p2[1]) / area2\n        return np.array([dL1_dx, dL2_dx, dL3_dx]), area2 / 2.0\n\n    def compute_cst_error(N):\n        triangles = get_mesh_triangles(N)\n        total_squared_error = 0.0\n\n        for verts in triangles:\n            # 1. Nodal values\n            u_nodes = u_exact(verts[:, 0], verts[:, 1])\n\n            # 2. Constant strain over the element\n            dL_dx, area = get_l_derivs(verts)\n            eps_xx_fe = np.dot(dL_dx, u_nodes)\n            \n            # 3. Integrate error over element\n            elem_squared_error = 0.0\n            for i, l_coords in enumerate(QUAD_CST['points']):\n                # Map barycentric to physical coords\n                xy_q = l_coords @ verts\n                \n                # Evaluate exact strain at quad point\n                eps_xx_q_exact = eps_xx_exact(xy_q[0], xy_q[1])\n\n                # Error at quad point\n                error_at_q = eps_xx_q_exact - eps_xx_fe\n                elem_squared_error += QUAD_CST['weights'][i] * (error_at_q**2)\n            \n            total_squared_error += elem_squared_error * area\n            \n        return np.sqrt(total_squared_error)\n\n    def compute_lst_error(N):\n        triangles = get_mesh_triangles(N)\n        total_squared_error = 0.0\n        \n        # LST shape function derivatives w.r.t. barycentric coords\n        def dN_dL(L):\n            L1, L2, L3 = L[0], L[1], L[2]\n            return np.array([\n                [4*L1 - 1, 0, 0],\n                [0, 4*L2 - 1, 0],\n                [0, 0, 4*L3 - 1],\n                [4*L2, 4*L1, 0],\n                [0, 4*L3, 4*L2],\n                [4*L3, 0, 4*L1]\n            ])\n\n        for verts in triangles:\n            # 1. Define 6 nodes for LST element\n            p1, p2, p3 = verts[0], verts[1], verts[2]\n            p4 = (p1 + p2) / 2\n            p5 = (p2 + p3) / 2\n            p6 = (p3 + p1) / 2\n            nodes = np.array([p1, p2, p3, p4, p5, p6])\n            \n            # 2. Nodal values\n            u_nodes = u_exact(nodes[:, 0], nodes[:, 1])\n            \n            # 3. Derivatives of area coords\n            dL_dx, area = get_l_derivs(verts)\n\n            # 4. Integrate error over element\n            elem_squared_error = 0.0\n            for i, l_coords in enumerate(QUAD_LST['points']):\n                # Derivatives of shape functions w.r.t. x at quad point\n                dN_dL_q = dN_dL(l_coords)\n                dN_dx_q = dN_dL_q @ dL_dx\n                \n                # FE strain at quad point\n                eps_xx_fe = np.dot(dN_dx_q, u_nodes)\n                \n                # Map barycentric to physical coords\n                xy_q = l_coords @ verts\n                \n                # Exact strain at quad point\n                eps_xx_q_exact = eps_xx_exact(xy_q[0], xy_q[1])\n                \n                error_at_q = eps_xx_q_exact - eps_xx_fe\n                elem_squared_error += QUAD_LST['weights'][i] * (error_at_q**2)\n\n            total_squared_error += elem_squared_error * area\n\n        return np.sqrt(total_squared_error)\n\n    # --- Calculations for CST ---\n    E_cst_2 = compute_cst_error(N=2)\n    E_cst_4 = compute_cst_error(N=4)\n    E_cst_8 = compute_cst_error(N=8)\n    \n    R_2_4 = E_cst_2 / E_cst_4 if E_cst_4 != 0 else 0\n    R_4_8 = E_cst_4 / E_cst_8 if E_cst_8 != 0 else 0\n\n    # --- Calculations for LST ---\n    E_lst_4 = compute_lst_error(N=4)\n    E_lst_8 = compute_lst_error(N=8)\n    \n    flag_lst_4 = E_lst_4  1e-12\n    flag_lst_8 = E_lst_8  1e-12\n\n    # --- Final Output Formatting ---\n    results = [\n        E_cst_2,\n        E_cst_4,\n        E_cst_8,\n        R_2_4,\n        R_4_8,\n        E_lst_4,\n        E_lst_8,\n        str(flag_lst_4).lower(),\n        str(flag_lst_8).lower()\n    ]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3607799"}]}