{"hands_on_practices": [{"introduction": "在有限元分析中，除了刚度矩阵，一致质量矩阵在求解动力学问题（如振动和波传播分析）时也扮演着至关重要的角色。本练习将引导你通过第一性原理推导T4和T10单元的一致质量矩阵，这是一个巩固理论基础的绝佳实践。通过这个过程，你将熟练运用重心坐标和狄利克雷积分这一强大组合来处理四面体上的积分，并深刻理解单元形函数的插值多项式阶次如何直接决定数值积分所需的精度要求 [@problem_id:3605661]。", "problem": "考虑从有限元法（FEM）中标量场的线性动量守恒弱形式得到的半离散形式，其中单元级一致质量矩阵定义为\n$$\nM_{e} \\;=\\; \\int_{\\Omega_{e}} \\rho\\, N^{\\top} N \\, d\\Omega,\n$$\n其中 $N$ 是形函数的列向量，$\\rho$ 是质量密度，$\\Omega_{e}$ 是物理四面体单元域。假设 $\\rho$ 在 $\\Omega_{e}$ 上是常数，并且当等参映射为线性时，单元是直边的。使用四面体上的重心坐标 $\\{\\lambda_{i}\\}_{i=1}^{4}$，以及重心坐标中单项式的狄利克雷积分恒等式，推导四节点线性四面体（T4）和十节点二次四面体（T10）的一致质量矩阵表达式。将 $N$ 视为相应单元的标量拉格朗日形函数列向量，并陈述您所引用的任何几何映射假设。\n\n从基本定义和经过验证的公式出发，完成以下内容：\n\n1. 通过使用重心坐标单项式的狄利克雷积分计算 $\\int_{\\Omega_{e}} \\lambda_{i}\\lambda_{j}\\, d\\Omega$，推导 T4 单元的 $M_{e}$ 的闭式表达式（用单元体积 $V_{e}$ 和 $\\rho$ 表示）。\n\n2. 对于 T10 单元，用重心坐标写出四个顶点和六个边中点处的二次拉格朗日形函数，并确定被积函数 $\\rho\\,N^{\\top}N$ 在参考四面体上的多项式次数。然后，在等参二次几何下，确定雅可比行列式 $\\det J$ 的次数以及参考域上完整被积函数 $\\rho\\,N^{\\top}N\\,\\det J$ 的最终多项式次数。\n\n3. 根据您的发现，陈述一个四面体求积法则为 T4（线性几何）和 T10（二次几何）精确积分一致质量矩阵被积函数所需的最小多项式精确度。将您的最终答案以包含这两个精确度的行矩阵 $\\big(k_{\\mathrm{T4}} \\;\\; k_{\\mathrm{T10}}\\big)$ 的形式报告。最终答案无需四舍五入，也不应包含任何单位。", "solution": "该问题是适定的，具有科学依据，并提供了推导所求量所需的所有信息。这是计算固体力学领域的一个标准问题，特别是在有限元法（FEM）的背景下。我们开始解答。\n\n根据问题陈述的要求，分析分为三个部分。\n\n### 第 1 部分：T4 单元的一致质量矩阵\n\n四节点线性四面体（T4）单元在其四个顶点处有节点。在等参格式中，几何形状和未知场使用同一组形函数表示。对于线性单元，形函数是线性的。对于四面体，表示这些函数最便捷的方法是使用重心坐标 $\\{\\lambda_i\\}_{i=1}^{4}$。对于 T4 单元，节点 $i$ 的形函数（记为 $N_i$）就是第 $i$ 个重心坐标，即 $N_i = \\lambda_i$。\n\n单元级一致质量矩阵 $M_e$ 由下式给出\n$$\nM_{e} \\;=\\; \\int_{\\Omega_{e}} \\rho\\, N^{\\top} N \\, d\\Omega\n$$\n其中 $\\rho$ 是质量密度，假设在单元域 $\\Omega_e$ 上为常数，$N$ 是形函数的列向量，$N = \\begin{pmatrix} \\lambda_1  \\lambda_2  \\lambda_3  \\lambda_4 \\end{pmatrix}^{\\top}$。这个 $4 \\times 4$ 质量矩阵的项 $M_{ij}$ 由下式给出：\n$$\nM_{ij} \\;=\\; \\rho \\int_{\\Omega_{e}} N_i N_j \\, d\\Omega \\;=\\; \\rho \\int_{\\Omega_{e}} \\lambda_i \\lambda_j \\, d\\Omega\n$$\n为计算该积分，我们使用重心坐标单项式在三维四面体域 $\\Omega_e$ 上的狄利克雷积分恒等式：\n$$\n\\int_{\\Omega_{e}} \\lambda_1^{a_1} \\lambda_2^{a_2} \\lambda_3^{a_3} \\lambda_4^{a_4} \\, d\\Omega \\;=\\; V_e \\frac{3! \\, a_1! \\, a_2! \\, a_3! \\, a_4!}{(3 + a_1 + a_2 + a_3 + a_4)!}\n$$\n其中 $V_e$ 是四面体的体积。\n\n我们区分质量矩阵的对角线项（$i=j$）和非对角线项（$i \\neq j$）。\n\n**对角线项（$i=j$）：**\n被积函数为 $\\lambda_i \\lambda_j = \\lambda_i^2$。在狄利克雷积分公式中，指数为 $a_i=2$ 且对于 $k \\neq i$ 有 $a_k=0$。\n$$\n\\int_{\\Omega_{e}} \\lambda_i^2 \\, d\\Omega \\;=\\; V_e \\frac{3! \\, 2! \\, 0! \\, 0! \\, 0!}{(3 + 2)!} \\;=\\; V_e \\frac{6 \\cdot 2}{5!} \\;=\\; V_e \\frac{12}{120} \\;=\\; \\frac{1}{10} V_e\n$$\n因此，对角线项为 $M_{ii} = \\rho \\frac{V_e}{10}$。\n\n**非对角线项（$i \\neq j$）：**\n被积函数为 $\\lambda_i \\lambda_j$。指数为 $a_i=1$，$a_j=1$，且对于 $k \\notin \\{i, j\\}$ 有 $a_k=0$。\n$$\n\\int_{\\Omega_{e}} \\lambda_i \\lambda_j \\, d\\Omega \\;=\\; V_e \\frac{3! \\, 1! \\, 1! \\, 0! \\, 0!}{(3 + 1 + 1)!} \\;=\\; V_e \\frac{6 \\cdot 1 \\cdot 1}{5!} \\;=\\; V_e \\frac{6}{120} \\;=\\; \\frac{1}{20} V_e\n$$\n因此，对于 $i \\neq j$，非对角线项为 $M_{ij} = \\rho \\frac{V_e}{20}$。\n\nT4 单元的完整一致质量矩阵为：\n$$\nM_e \\;=\\; \\frac{\\rho V_e}{20}\n\\begin{pmatrix}\n2  1  1  1 \\\\\n1  2  1  1 \\\\\n1  1  2  1 \\\\\n1  1  1  2\n\\end{pmatrix}\n$$\n\n### 第 2 部分：T10 单元的多项式次数\n\n十节点二次四面体（T10）单元在四个顶点处有四个节点，在六条边的中点处有六个节点。其形函数是重心坐标的二次多项式。设顶点为节点 $1, 2, 3, 4$，边中点为节点 $5, ..., 10$。形函数 $N_i$ 为：\n- 对于顶点节点 $i \\in \\{1,2,3,4\\}$：$N_i = \\lambda_i (2\\lambda_i - 1)$。\n- 对于连接顶点 $i$ 和 $j$ 的边上的中点节点 $k$：$N_k = 4\\lambda_i \\lambda_j$。\n\n物理域上质量矩阵的被积函数为 $\\rho N^{\\top}N$。其各项形式为 $\\rho N_i N_j$。由于 $\\rho$ 是常数，我们考虑乘积 $N_i N_j$ 的多项式次数。形函数 $N_i$ 是重心坐标 $\\lambda_k$ 的二次多项式（次数为 2）。因此，乘积 $N_i N_j$ 是重心坐标的 $2+2=4$ 次多项式。\n\n问题要求在等参二次几何映射下，参考域上完整被积函数的多项式次数。从物理域 $\\Omega_e$ 到参考域 $\\hat{\\Omega}$ 的积分变换为：\n$$\n\\int_{\\Omega_e} f(x) \\,d\\Omega = \\int_{\\hat{\\Omega}} f(x(\\xi)) \\det(J) \\,d\\hat{\\Omega}\n$$\n其中 $\\xi$ 是参考单元上的坐标，$J$ 是几何映射 $x(\\xi)$ 的雅可比矩阵。\n\n对于具有二次等参映射的 T10 单元，物理坐标 $x$ 使用二次形函数进行插值：\n$$\nx(\\xi) = \\sum_{k=1}^{10} N_k(\\xi) x_k\n$$\n其中 $x_k$ 是节点坐标。形函数 $N_k(\\xi)$ 是参考坐标 $\\xi = (\\xi_1, \\xi_2, \\xi_3)$ 的二次多项式。\n\n雅可比矩阵的项为 $J_{ab} = \\frac{\\partial x_a}{\\partial \\xi_b}$。\n$$\nJ_{ab} = \\frac{\\partial}{\\partial \\xi_b} \\left( \\sum_{k=1}^{10} N_k(\\xi) (x_k)_a \\right) = \\sum_{k=1}^{10} \\frac{\\partial N_k(\\xi)}{\\partial \\xi_b} (x_k)_a\n$$\n由于每个 $N_k(\\xi)$ 是 $\\xi$ 的二次多项式，其偏导数 $\\frac{\\partial N_k(\\xi)}{\\partial \\xi_b}$ 是 $\\xi$ 的线性多项式。因此，雅可比矩阵的每个项 $J_{ab}$ 都是参考坐标 $\\xi$ 的线性多项式。\n\n这个 $3 \\times 3$ 雅可比矩阵的行列式 $\\det(J)$ 是根据其线性多项式项计算的。行列式是三项乘积之和，因此其多项式次数通常为 $1+1+1=3$。对于一般的曲边 T10 单元，这个三次项不为零。因此，$\\det(J)$ 的次数为 3。\n\n参考域上的完整被积函数为 $\\rho N_i(\\xi) N_j(\\xi) \\det(J(\\xi))$。\n- $N_i(\\xi) N_j(\\xi)$ 的多项式次数为 4。\n- $\\det(J(\\xi))$ 的多项式次数为 3。\n\n完整被积函数的多项式次数是这些次数之和：$4 + 3 = 7$。\n\n### 第 3 部分：最小求积精确度\n\n如果一个数值求积法则能够精确积分次数最高为 $k$（含 $k$）的任意多项式，则称其多项式精确度为 $k$。为了无误差地计算一致质量矩阵，求积法则对于被积函数中遇到的最高多项式次数必须是精确的。\n\n**对于具有线性几何的 T4 单元：**\n问题指定了一个直边单元，这对应于线性等参映射。坐标变换为 $x(\\xi) = \\sum_{i=1}^{4} N_i(\\xi) x_i$，其中 $N_i$ 是线性形函数。雅可比矩阵 $J$ 是常数，因此其行列式 $\\det(J)$ 也是一个常数（0 次多项式）。参考域上的被积函数为 $N_i(\\xi) N_j(\\xi) \\det(J)$。\n- 形函数 $N_i$ 是线性的（次数为 1）。\n- 乘积 $N_i N_j$ 是二次的（次数为 2）。\n- 行列式 $\\det(J)$ 是常数（次数为 0）。\n被积函数的总次数为 $2+0=2$。\n因此，T4 单元所需的最小多项式精确度为 $k_{\\mathrm{T4}} = 2$。\n\n**对于具有二次几何的 T10 单元：**\n如第 2 部分所推导，参考域上的被积函数为 $N_i(\\xi) N_j(\\xi) \\det(J(\\xi))$。\n- 形函数的乘积 $N_i N_j$ 是一个 4 次多项式。\n- 雅可比行列式 $\\det(J)$ 是一个 3 次多项式。\n被积函数的总次数为 $4+3=7$。\n因此，T10 单元所需的最小多项式精确度为 $k_{\\mathrm{T10}} = 7$。\n\n最终答案是一个包含这两个次数的行矩阵。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2  7\n\\end{pmatrix}\n}\n$$", "id": "3605661"}, {"introduction": "准确计算形函数梯度是有限元方法的核心，它是构建单元刚度矩阵、质量矩阵以及进行应力恢复等后处理步骤的基础。本练习旨在搭建理论与实践之间的桥梁，要求你编写一个程序来计算T10单元在任意积分点处的物理梯度。这个过程不仅能加深你对等参映射、雅可比矩阵和链式法则在计算中应用的理解，还通过与仿射几何下的解析解进行对比，强调了在科学计算中进行代码验证的关键性 [@problem_id:3605665]。", "problem": "设计并实现一个完整的程序，该程序针对一个十节点二次四面体单元（通常表示为 T10），使用等参公式计算指定积分点处形函数的物理空间梯度。计算必须遵循从等参映射和链式法则出发的第一性原理路径。程序还必须针对仿射几何的特殊情况，使用基于重心坐标微积分推导的解析值来验证梯度的准确性。\n\n您必须从以下基本基础出发：\n- 单元的等参映射通过单元形函数将参考坐标映射到物理坐标。如果 $\\{\\boldsymbol{X}_a\\}_{a=1}^{10}$ 是物理节点位置，$\\{N_a\\}_{a=1}^{10}$ 是形函数，则映射由下式给出\n$$\n\\boldsymbol{x}(\\boldsymbol{\\xi}) \\;=\\; \\sum_{a=1}^{10} N_a(\\boldsymbol{\\xi})\\,\\boldsymbol{X}_a,\n$$\n其中 $\\boldsymbol{\\xi} = (r,s,t)$ 是单位四面体上的参考坐标，满足 $r \\ge 0$、 $s \\ge 0$、 $t \\ge 0$ 和 $r+s+t \\le 1$。\n- 雅可比矩阵定义为\n$$\n\\boldsymbol{J}(\\boldsymbol{\\xi}) \\;=\\; \\frac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{\\xi}} \\;=\\; \\sum_{a=1}^{10} \\boldsymbol{X}_a \\otimes \\nabla_{\\boldsymbol{\\xi}} N_a(\\boldsymbol{\\xi}),\n$$\n且链式法则给出形函数的物理空间梯度为\n$$\n\\nabla_{\\boldsymbol{x}} N_a(\\boldsymbol{\\xi}) \\;=\\; \\boldsymbol{J}(\\boldsymbol{\\xi})^{-\\mathsf{T}} \\, \\nabla_{\\boldsymbol{\\xi}} N_a(\\boldsymbol{\\xi}).\n$$\n- 对于参考四面体上的 T10，形函数可以使用重心坐标 $\\{L_i\\}_{i=1}^4$ 来表示，其定义为 $L_1=r$、 $L_2=s$、 $L_3=t$、 $L_4 = 1 - r - s - t$，且 $L_1+L_2+L_3+L_4=1$。十个二次形函数是\n$$\n\\begin{aligned}\nN_1 = L_1\\,(2L_1-1),\\;\\; N_2 = L_2\\,(2L_2-1),\\;\\; N_3 = L_3\\,(2L_3-1),\\;\\; N_4 = L_4\\,(2L_4-1),\\\\\nN_5 = 4\\,L_1 L_2,\\;\\; N_6 = 4\\,L_2 L_3,\\;\\; N_7 = 4\\,L_1 L_3,\\;\\; N_8 = 4\\,L_1 L_4,\\;\\; N_9 = 4\\,L_2 L_4,\\;\\; N_{10} = 4\\,L_3 L_4.\n\\end{aligned}\n$$\n- 导数 $\\nabla_{\\boldsymbol{\\xi}} N_a$ 由乘法法则和线性关系 $\\partial L_1/\\partial r = 1$、 $\\partial L_2/\\partial s = 1$、 $\\partial L_3/\\partial t = 1$、 $\\partial L_4/\\partial r = \\partial L_4/\\partial s = \\partial L_4/\\partial t = -1$ 得出，而 $L_i$ 的所有其他偏导数都等于 $0$。\n\n针对仿射几何的解析验证基础：\n- 如果几何是仿射的，即边中节点的位置位于四个顶点节点之间直线的几何中点，则物理映射简化为仿射映射。在这种情况下，物理重心坐标在 $\\boldsymbol{x}$ 中是线性的，并满足\n$$\n\\boldsymbol{x} \\;=\\; \\sum_{i=1}^{4} L_i(\\boldsymbol{x})\\,\\boldsymbol{X}_i,\\;\\;\\; \\sum_{i=1}^{4} L_i(\\boldsymbol{x}) = 1,\n$$\n且梯度 $\\{\\nabla_{\\boldsymbol{x}} L_i\\}_{i=1}^{4}$ 是由顶点位置决定的恒定向量。定义 $3\\times 3$ 矩阵\n$$\n\\boldsymbol{B} \\;=\\; \\begin{bmatrix} \\boldsymbol{X}_1 - \\boldsymbol{X}_4  \\boldsymbol{X}_2 - \\boldsymbol{X}_4  \\boldsymbol{X}_3 - \\boldsymbol{X}_4 \\end{bmatrix},\n$$\n则\n$$\n\\nabla_{\\boldsymbol{x}} L_1 \\;=\\; \\boldsymbol{B}^{-\\mathsf{T}} \\boldsymbol{e}_1,\\;\\;\n\\nabla_{\\boldsymbol{x}} L_2 \\;=\\; \\boldsymbol{B}^{-\\mathsf{T}} \\boldsymbol{e}_2,\\;\\;\n\\nabla_{\\boldsymbol{x}} L_3 \\;=\\; \\boldsymbol{B}^{-\\mathsf{T}} \\boldsymbol{e}_3,\\;\\;\n\\nabla_{\\boldsymbol{x}} L_4 \\;=\\; -\\sum_{i=1}^{3} \\nabla_{\\boldsymbol{x}} L_i,\n$$\n其中 $\\{\\boldsymbol{e}_i\\}$ 是笛卡尔基向量。对于任何具有重心坐标 $\\{L_i\\}$ 的点，T10 形函数的解析梯度则为\n$$\n\\begin{aligned}\n\\nabla_{\\boldsymbol{x}} N_1 = (4L_1-1)\\,\\nabla_{\\boldsymbol{x}} L_1,\\;\\;\n\\nabla_{\\boldsymbol{x}} N_2 = (4L_2-1)\\,\\nabla_{\\boldsymbol{x}} L_2,\\;\\;\n\\nabla_{\\boldsymbol{x}} N_3 = (4L_3-1)\\,\\nabla_{\\boldsymbol{x}} L_3,\\;\\;\n\\nabla_{\\boldsymbol{x}} N_4 = (4L_4-1)\\,\\nabla_{\\boldsymbol{x}} L_4,\\\\\n\\nabla_{\\boldsymbol{x}} N_5 = 4\\,(L_1\\,\\nabla_{\\boldsymbol{x}} L_2 + L_2\\,\\nabla_{\\boldsymbol{x}} L_1),\\;\\;\n\\nabla_{\\boldsymbol{x}} N_6 = 4\\,(L_2\\,\\nabla_{\\boldsymbol{x}} L_3 + L_3\\,\\nabla_{\\boldsymbol{x}} L_2),\\\\\n\\nabla_{\\boldsymbol{x}} N_7 = 4\\,(L_1\\,\\nabla_{\\boldsymbol{x}} L_3 + L_3\\,\\nabla_{\\boldsymbol{x}} L_1),\\;\\;\n\\nabla_{\\boldsymbol{x}} N_8 = 4\\,(L_1\\,\\nabla_{\\boldsymbol{x}} L_4 + L_4\\,\\nabla_{\\boldsymbol{x}} L_1),\\\\\n\\nabla_{\\boldsymbol{x}} N_9 = 4\\,(L_2\\,\\nabla_{\\boldsymbol{x}} L_4 + L_4\\,\\nabla_{\\boldsymbol{x}} L_2),\\;\\;\n\\nabla_{\\boldsymbol{x}} N_{10} = 4\\,(L_3\\,\\nabla_{\\boldsymbol{x}} L_4 + L_4\\,\\nabla_{\\boldsymbol{x}} L_3).\n\\end{aligned}\n$$\n\n您的程序必须：\n- 实现一个鲁棒的算法，对于每个积分点，计算 $\\nabla_{\\boldsymbol{\\xi}} N_a$，组装 $\\boldsymbol{J}$，通过线性求解计算 $\\boldsymbol{J}^{-\\mathsf{T}}$，并返回 $\\nabla_{\\boldsymbol{x}} N_a$。\n- 在参考四面体上使用以下对称四点积分法则，以重心坐标给出。令 $a = 0.1381966011250105$，并定义四个积分点，其重心坐标为\n$$\n(L_1,L_2,L_3,L_4) \\in \\{(a,a,a,1-3a),\\;(1-3a,a,a,a),\\;(a,1-3a,a,a),\\;(a,a,1-3a,a)\\},\n$$\n每个点都具有相同的权重（权重对于此任务不是必需的，但必须使用这些点）。通过 $(r,s,t) = (L_1,L_2,L_3)$ 将这些重心坐标转换为参考坐标。\n\n测试套件：\n- 对于以下三个仿射 T10 单元中的每一个，通过将 4 个顶点节点放置在给定坐标处，并将 6 个边中节点中的每一个放置在其对应直边的中点，来构造 10 个节点位置。对于每个单元，在四个积分点处计算梯度，并计算算法计算的梯度与解析梯度之差在所有形函数和积分点上的最大欧几里得范数。每个单元报告一个最大误差值。\n    1. 正常情况单元，直角单位四面体：\n       - 顶点节点： $\\boldsymbol{X}_1=(0,0,0)$, $\\boldsymbol{X}_2=(1,0,0)$, $\\boldsymbol{X}_3=(0,1,0)$, $\\boldsymbol{X}_4=(0,0,1)$。\n    2. 扭曲但形状良好的单元：\n       - 顶点节点： $\\boldsymbol{X}_1=(0,0,0)$, $\\boldsymbol{X}_2=(3,0.1,0)$, $\\boldsymbol{X}_3=(0.2,2.5,0.1)$, $\\boldsymbol{X}_4=(0.1,0.2,2.0)$。\n    3. 近奇异单元（边缘情况）：\n       - 顶点节点： $\\boldsymbol{X}_1=(0,0,0)$, $\\boldsymbol{X}_2=(10^{-4},0,0)$, $\\boldsymbol{X}_3=(0,10^{-4},0)$, $\\boldsymbol{X}_4=(0,0,1)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为包含在方括号中的逗号分隔列表，例如 $[e_1,e_2,e_3]$，其中 $e_i$ 是单元 $i$ 的最大误差，以浮点数表示。不应打印任何额外文本。", "solution": "该问题要求设计并实现一个程序，用于计算十节点二次四面体单元（T10）形函数在物理空间中的梯度。计算必须基于等参公式和链式法则。此外，对于仿射单元几何的特殊情况，必须根据从重心坐标微积分推导出的解析解来验证结果。\n\n解决方案包括四个主要阶段：1) 在参考坐标系中推导形函数梯度，2) 建立等参映射和雅可比矩阵的公式，以将这些梯度转换到物理坐标系，3) 建立仿射几何的解析解公式，以及 4) 用于计算和比较指定测试用例结果的算法流程。\n\n设单位四面体上的参考坐标为 $\\boldsymbol{\\xi} = (r, s, t)^{\\mathsf{T}}$，其中 $r \\ge 0$, $s \\ge 0$, $t \\ge 0$, 且 $r+s+t \\le 1$。物理坐标表示为 $\\boldsymbol{x}=(x,y,z)^{\\mathsf{T}}$。\n\n首先，我们定义重心坐标，这是定义形函数的基础。对于参考四面体中的任何点 $\\boldsymbol{\\xi}$，其重心坐标 $\\{L_i\\}_{i=1}^4$ 由下式给出：\n$$\nL_1(\\boldsymbol{\\xi}) = r, \\quad L_2(\\boldsymbol{\\xi}) = s, \\quad L_3(\\boldsymbol{\\xi}) = t, \\quad L_4(\\boldsymbol{\\xi}) = 1 - r - s - t\n$$\n这些坐标满足属性 $\\sum_{i=1}^4 L_i = 1$。T10 单元的十个形函数可以优雅地用这些重心坐标表示。节点1到4是四面体的顶点，节点5到10是六条边的中点。形函数如下：\n$$\n\\begin{aligned}\nN_1 = L_1(2L_1-1)  \\text{(顶点 1)} \\\\\nN_2 = L_2(2L_2-1)  \\text{(顶点 2)} \\\\\nN_3 = L_3(2L_3-1)  \\text{(顶点 3)} \\\\\nN_4 = L_4(2L_4-1)  \\text{(顶点 4)} \\\\\nN_5 = 4L_1 L_2  \\text{(边 1-2 的中点)} \\\\\nN_6 = 4L_2 L_3  \\text{(边 2-3 的中点)} \\\\\nN_7 = 4L_1 L_3  \\text{(边 1-3 的中点)} \\\\\nN_8 = 4L_1 L_4  \\text{(边 1-4 的中点)} \\\\\nN_9 = 4L_2 L_4  \\text{(边 2-4 的中点)} \\\\\nN_{10} = 4L_3 L_4  \\text{(边 3-4 的中点)}\n\\end{aligned}\n$$\n\n为了计算物理空间梯度 $\\nabla_{\\boldsymbol{x}} N_a$，我们首先需要参考空间梯度 $\\nabla_{\\boldsymbol{\\xi}} N_a$。这些梯度可以通过对形函数定义应用链式法则来找到。任何形函数 $N_a$ 关于某个参考坐标（例如 $r$）的梯度是 $\\frac{\\partial N_a}{\\partial r} = \\sum_{i=1}^4 \\frac{\\partial N_a}{\\partial L_i} \\frac{\\partial L_i}{\\partial r}$。重心坐标相对于参考坐标的导数是常数：\n$$\n\\nabla_{\\boldsymbol{\\xi}} L_1 = (1, 0, 0)^{\\mathsf{T}}, \\quad \\nabla_{\\boldsymbol{\\xi}} L_2 = (0, 1, 0)^{\\mathsf{T}}, \\quad \\nabla_{\\boldsymbol{\\xi}} L_3 = (0, 0, 1)^{\\mathsf{T}}, \\quad \\nabla_{\\boldsymbol{\\xi}} L_4 = (-1, -1, -1)^{\\mathsf{T}}\n$$\n这导出了 $\\nabla_{\\boldsymbol{\\xi}} N_a$ 分量的以下表达式：\n$$\n\\frac{\\partial N_a}{\\partial r} = \\frac{\\partial N_a}{\\partial L_1} - \\frac{\\partial N_a}{\\partial L_4}, \\quad\n\\frac{\\partial N_a}{\\partial s} = \\frac{\\partial N_a}{\\partial L_2} - \\frac{\\partial N_a}{\\partial L_4}, \\quad\n\\frac{\\partial N_a}{\\partial t} = \\frac{\\partial N_a}{\\partial L_3} - \\frac{\\partial N_a}{\\partial L_4}\n$$\n导数 $\\frac{\\partial N_a}{\\partial L_i}$ 是通过对 $N_a$ 的多项式表达式求导得到的。例如，对于 $N_1 = 2L_1^2 - L_1$，$\\frac{\\partial N_1}{\\partial L_1} = 4L_1-1$，而对于 $N_5=4L_1L_2$，$\\frac{\\partial N_5}{\\partial L_1} = 4L_2$ 且 $\\frac{\\partial N_5}{\\partial L_2} = 4L_1$。所有其他导数均为零。这些导数在由其重心坐标定义的特定点处进行求值。\n\n等参公式使用相同的形函数将参考单元映射到物理单元：\n$$\n\\boldsymbol{x}(\\boldsymbol{\\xi}) \\;=\\; \\sum_{a=1}^{10} N_a(\\boldsymbol{\\xi})\\,\\boldsymbol{X}_a\n$$\n其中 $\\boldsymbol{X}_a$ 是单元十个节点的物理坐标。该映射的梯度定义了雅可比矩阵 $\\boldsymbol{J}$：\n$$\n\\boldsymbol{J}(\\boldsymbol{\\xi}) = \\frac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{\\xi}} = \\sum_{a=1}^{10} \\boldsymbol{X}_a \\otimes \\nabla_{\\boldsymbol{\\xi}} N_a(\\boldsymbol{\\xi})\n$$\n以分量形式表示，$J_{ij} = \\frac{\\partial x_i}{\\partial \\xi_j} = \\sum_{a=1}^{10} X_{ai} \\frac{\\partial N_a}{\\partial \\xi_j}$。这里，$i \\in \\{1,2,3\\}$ 指物理维度 $(x,y,z)$，$j \\in \\{1,2,3\\}$ 指参考维度 $(r,s,t)$。\n\n链式法则连接了物理梯度和参考梯度：$\\nabla_{\\boldsymbol{\\xi}} N_a = \\boldsymbol{J}^{\\mathsf{T}} \\nabla_{\\boldsymbol{x}} N_a$。为了找到所需的物理梯度，我们重新整理这个关系：\n$$\n\\nabla_{\\boldsymbol{x}} N_a(\\boldsymbol{\\xi}) \\;=\\; \\boldsymbol{J}(\\boldsymbol{\\xi})^{-\\mathsf{T}} \\, \\nabla_{\\boldsymbol{\\xi}} N_a(\\boldsymbol{\\xi})\n$$\n在计算上，对每个形函数 $a$ 求解线性系统 $\\boldsymbol{J}^{\\mathsf{T}} (\\nabla_{\\boldsymbol{x}} N_a) = \\nabla_{\\boldsymbol{\\xi}} N_a$ 比显式计算 $\\boldsymbol{J}^{\\mathsf{T}}$ 的逆矩阵更稳定、更高效。\n\n为了验证，我们使用一个对仿射单元有效的解析解，其中所有边中节点 $\\boldsymbol{X}_{5-10}$ 都精确位于连接相应顶点节点 $\\boldsymbol{X}_{1-4}$ 的边的几何中点。在这种情况下，从物理坐标到重心坐标的映射是仿射的。重心坐标相对于物理坐标的梯度 $\\nabla_{\\boldsymbol{x}} L_i$ 是恒定向量。它们可以通过首先定义矩阵 $\\boldsymbol{B}$ 来计算，该矩阵的列由从顶点4到顶点1、2和3的向量构成：\n$$\n\\boldsymbol{B} \\;=\\; \\begin{bmatrix} \\boldsymbol{X}_1 - \\boldsymbol{X}_4  \\boldsymbol{X}_2 - \\boldsymbol{X}_4  \\boldsymbol{X}_3 - \\boldsymbol{X}_4 \\end{bmatrix}\n$$\n梯度则由下式给出：\n$$\n\\nabla_{\\boldsymbol{x}} L_1 = \\boldsymbol{B}^{-\\mathsf{T}} \\boldsymbol{e}_1, \\;\\;\n\\nabla_{\\boldsymbol{x}} L_2 = \\boldsymbol{B}^{-\\mathsf{T}} \\boldsymbol{e}_2, \\;\\;\n\\nabla_{\\boldsymbol{x}} L_3 = \\boldsymbol{B}^{-\\mathsf{T}} \\boldsymbol{e}_3, \\;\\;\n\\nabla_{\\boldsymbol{x}} L_4 = -\\sum_{i=1}^{3} \\nabla_{\\boldsymbol{x}} L_i\n$$\n其中 $\\{\\boldsymbol{e}_i\\}$ 是标准笛卡尔基向量。利用这些恒定梯度，任何形函数 $N_a$ 的解析物理梯度都可以通过对其以 $L_i$ 表示的定义应用乘法法则来找到。例如，对于 $N_1=L_1(2L_1-1)$，梯度是 $\\nabla_{\\boldsymbol{x}} N_1 = (4L_1-1)\\nabla_{\\boldsymbol{x}} L_1$。对于 $N_5=4L_1L_2$，它是 $\\nabla_{\\boldsymbol{x}} N_5 = 4(L_1 \\nabla_{\\boldsymbol{x}} L_2 + L_2 \\nabla_{\\boldsymbol{x}} L_1)$。\n\n针对给定单元的总体算法如下：\n1. 定义4个顶点节点坐标 $\\boldsymbol{X}_{1..4}$。构造6个边中节点坐标 $\\boldsymbol{X}_{5..10}$（例如，$\\boldsymbol{X}_5 = 0.5(\\boldsymbol{X}_1 + \\boldsymbol{X}_2)$）。这就构成了所有10个节点坐标的矩阵。\n2. 对于四个指定的积分点中的每一个，以重心坐标 $(L_1, L_2, L_3, L_4)$ 给出：\n    a. 转换为参考坐标 $(r, s, t) = (L_1, L_2, L_3)$。\n    b. **算法梯度计算**：\n        i. 计算参考梯度的 $10 \\times 3$ 矩阵 $\\boldsymbol{D}$，其中 $D_{aj} = (\\nabla_{\\boldsymbol{\\xi}} N_a)_j$。\n        ii. 组装 $3 \\times 3$ 的雅可比矩阵 $\\boldsymbol{J}$。\n        iii. 同时对所有10个形函数求解线性系统 $\\boldsymbol{J}^{\\mathsf{T}} \\boldsymbol{G}^{\\mathsf{T}} = \\boldsymbol{D}^{\\mathsf{T}}$，以找到物理梯度的 $10 \\times 3$ 矩阵 $\\boldsymbol{G}$，其中 $G_{aj} = (\\nabla_{\\boldsymbol{x}} N_a)_j$。\n    c. **解析梯度计算**：\n        i. 计算重心坐标的恒定物理梯度 $\\nabla_{\\boldsymbol{x}} L_i$。\n        ii. 使用这些梯度和积分点的重心坐标来计算所有10个形函数的解析物理梯度。\n    d. 对每个形函数，计算算法梯度和解析梯度之间向量差的欧几里得范数。\n3. 单元的最终误差是这10个形函数和4个积分点上所有这些范数的最大值。\n对所提供的三个测试单元中的每一个重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve, inv\n\ndef solve_problem():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It computes the maximum error between algorithmic and analytical T10 gradients\n    for three different affine tetrahedral elements.\n    \"\"\"\n\n    # Test suite: vertex coordinates for three affine T10 elements.\n    test_cases = [\n        # 1. Happy path element: right-angled unit tetrahedron\n        np.array([\n            [0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]\n        ]),\n        # 2. Skewed, well-shaped element\n        np.array([\n            [0.0, 0.0, 0.0], [3.0, 0.1, 0.0], [0.2, 2.5, 0.1], [0.1, 0.2, 2.0]\n        ]),\n        # 3. Nearly singular element (edge case)\n        np.array([\n            [0.0, 0.0, 0.0], [1e-4, 0.0, 0.0], [0.0, 1e-4, 0.0], [0.0, 0.0, 1.0]\n        ]),\n    ]\n\n    # Quadrature points for a symmetric 4-point rule on the tetrahedron.\n    a = 0.1381966011250105\n    b = 1.0 - 3.0 * a\n    # Quadrature points are given in barycentric coordinates (L1, L2, L3, L4).\n    quad_points_bary = np.array([\n        [a, a, a, b],\n        [b, a, a, a],\n        [a, b, a, a],\n        [a, a, b, a],\n    ])\n\n    results = []\n    for vertices in test_cases:\n        # Construct the full 10-node coordinate matrix for the affine element.\n        # Nodes 1-4 are vertices.\n        # Nodes 5-10 are mid-edge nodes in the order: 1-2, 2-3, 1-3, 1-4, 2-4, 3-4.\n        all_nodes = np.zeros((10, 3))\n        all_nodes[0:4, :] = vertices\n        all_nodes[4, :] = 0.5 * (vertices[0] + vertices[1])  # Edge 1-2\n        all_nodes[5, :] = 0.5 * (vertices[1] + vertices[2])  # Edge 2-3\n        all_nodes[6, :] = 0.5 * (vertices[0] + vertices[2])  # Edge 1-3\n        all_nodes[7, :] = 0.5 * (vertices[0] + vertices[3])  # Edge 1-4\n        all_nodes[8, :] = 0.5 * (vertices[1] + vertices[3])  # Edge 2-4\n        all_nodes[9, :] = 0.5 * (vertices[2] + vertices[3])  # Edge 3-4\n        \n        max_error = compute_max_error(all_nodes, quad_points_bary)\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.15e}' for err in results)}]\")\n\ndef get_ref_grads(bary_coords):\n    \"\"\"\n    Computes the gradients of the 10 T10 shape functions with respect to the\n    reference coordinates (r, s, t) at a point defined by its barycentric\n    coordinates.\n\n    Args:\n        bary_coords (np.ndarray): A (4,) array of barycentric coordinates [L1, L2, L3, L4].\n\n    Returns:\n        np.ndarray: A (10, 3) matrix of reference gradients, where row 'a' is\n                    the gradient of shape function N_a.\n    \"\"\"\n    L = bary_coords\n    \n    # partial derivatives of shape functions w.r.t. barycentric coordinates (dNa/dLi)\n    dNa_dLi = np.zeros((10, 4))\n    \n    # Vertex nodes (N1 to N4)\n    dNa_dLi[0, 0] = 4 * L[0] - 1\n    dNa_dLi[1, 1] = 4 * L[1] - 1\n    dNa_dLi[2, 2] = 4 * L[2] - 1\n    dNa_dLi[3, 3] = 4 * L[3] - 1\n    \n    # Mid-edge nodes (N5 to N10)\n    dNa_dLi[4, 0], dNa_dLi[4, 1] = 4 * L[1], 4 * L[0]  # N5 = 4*L1*L2\n    dNa_dLi[5, 1], dNa_dLi[5, 2] = 4 * L[2], 4 * L[1]  # N6 = 4*L2*L3\n    dNa_dLi[6, 0], dNa_dLi[6, 2] = 4 * L[2], 4 * L[0]  # N7 = 4*L1*L3\n    dNa_dLi[7, 0], dNa_dLi[7, 3] = 4 * L[3], 4 * L[0]  # N8 = 4*L1*L4\n    dNa_dLi[8, 1], dNa_dLi[8, 3] = 4 * L[3], 4 * L[1]  # N9 = 4*L2*L4\n    dNa_dLi[9, 2], dNa_dLi[9, 3] = 4 * L[3], 4 * L[2]  # N10 = 4*L3*L4\n    \n    # Chain rule: dNa/dr = dNa/dL1 - dNa/dL4, etc.\n    dNa_dxi = np.zeros((10, 3))\n    dNa_dxi[:, 0] = dNa_dLi[:, 0] - dNa_dLi[:, 3]  # d/dr\n    dNa_dxi[:, 1] = dNa_dLi[:, 1] - dNa_dLi[:, 3]  # d/ds\n    dNa_dxi[:, 2] = dNa_dLi[:, 2] - dNa_dLi[:, 3]  # d/dt\n    \n    return dNa_dxi\n\ndef compute_gradients_isoparametric(nodes, bary_coords):\n    \"\"\"\n    Computes physical gradients using the standard isoparametric formulation.\n    \"\"\"\n    ref_grads = get_ref_grads(bary_coords)\n    # Jacobian J_ij = sum_a X_ai * dNa/dxi_j\n    # In matrix form: J = X.T @ (dNa/dxi)\n    J = nodes.T @ ref_grads\n    \n    # Physical grads G = (dNa/dxi) @ inv(J)\n    # Solved more robustly as J.T @ G.T = (dNa/dxi).T\n    phys_grads = solve(J.T, ref_grads.T).T\n    return phys_grads\n\ndef compute_gradients_analytical(nodes, bary_coords):\n    \"\"\"\n    Computes physical gradients using the analytical formulas for affine elements.\n    \"\"\"\n    vertices = nodes[0:4]\n    L = bary_coords\n\n    # Matrix B for computing barycentric coordinate gradients\n    B = np.zeros((3, 3))\n    B[:, 0] = vertices[0] - vertices[3]\n    B[:, 1] = vertices[1] - vertices[3]\n    B[:, 2] = vertices[2] - vertices[3]\n    \n    B_inv_T = inv(B).T\n    \n    # Gradients of barycentric coordinates w.r.t. physical coords (dLi/dx)\n    dL_dx = np.zeros((4, 3))\n    dL_dx[0, :] = B_inv_T[:, 0]\n    dL_dx[1, :] = B_inv_T[:, 1]\n    dL_dx[2, :] = B_inv_T[:, 2]\n    dL_dx[3, :] = -np.sum(dL_dx[0:3, :], axis=0)\n    \n    # Analytical physical gradients of shape functions\n    grad_N_an = np.zeros((10, 3))\n    grad_N_an[0, :] = (4 * L[0] - 1) * dL_dx[0]\n    grad_N_an[1, :] = (4 * L[1] - 1) * dL_dx[1]\n    grad_N_an[2, :] = (4 * L[2] - 1) * dL_dx[2]\n    grad_N_an[3, :] = (4 * L[3] - 1) * dL_dx[3]\n    \n    grad_N_an[4, :] = 4 * (L[1] * dL_dx[0] + L[0] * dL_dx[1])\n    grad_N_an[5, :] = 4 * (L[2] * dL_dx[1] + L[1] * dL_dx[2])\n    grad_N_an[6, :] = 4 * (L[2] * dL_dx[0] + L[0] * dL_dx[2])\n    grad_N_an[7, :] = 4 * (L[3] * dL_dx[0] + L[0] * dL_dx[3])\n    grad_N_an[8, :] = 4 * (L[3] * dL_dx[1] + L[1] * dL_dx[3])\n    grad_N_an[9, :] = 4 * (L[3] * dL_dx[2] + L[2] * dL_dx[3])\n\n    return grad_N_an\n\ndef compute_max_error(nodes, quad_points_bary):\n    \"\"\"\n    Computes the maximum error between algorithmic and analytical gradients\n    over all shape functions and quadrature points for a single element.\n    \"\"\"\n    max_err = 0.0\n    for qp_bary in quad_points_bary:\n        \n        # Algorithmic (isoparametric) computation\n        grad_iso = compute_gradients_isoparametric(nodes, qp_bary)\n        \n        # Analytical computation for affine case\n        grad_an = compute_gradients_analytical(nodes, qp_bary)\n        \n        # Compute error for this quadrature point\n        diff = grad_iso - grad_an\n        errors_at_qp = np.linalg.norm(diff, axis=1) # Norms for each shape function\n        \n        # Update overall maximum error\n        max_err = max(max_err, np.max(errors_at_qp))\n        \n    return max_err\n\nif __name__ == '__main__':\n    solve_problem()\n```", "id": "3605665"}, {"introduction": "在选择有限元单元时，除了理论精度，计算效率也是一个决定性的考量因素。本练习提供了一个量化分析的视角，通过估算和比较组装T4和T10单元刚度矩阵所需的浮点运算（FLOPs）数量，来揭示不同单元之间的性能差异。通过深入剖析矩阵组装算法的每一个步骤，你将能够洞察到单元复杂性与计算成本之间的权衡关系，从而对有限元软件的性能有更深刻的认识 [@problem_id:3605651]。", "problem": "考虑用等参四面体单元离散的三维小应变线性弹性问题。单元刚度矩阵由积分定义\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e^{\\text{ref}}} \\mathbf{B}(\\boldsymbol{\\xi})^{\\mathsf{T}} \\, \\mathbf{D} \\, \\mathbf{B}(\\boldsymbol{\\xi}) \\, \\det\\mathbf{J}(\\boldsymbol{\\xi}) \\, \\mathrm{d}\\Omega_{\\boldsymbol{\\xi}},\n$$\n其中 $\\mathbf{D}$ 是常数 $6\\times 6$ 各向同性本构矩阵，$\\mathbf{J}(\\boldsymbol{\\xi})$ 是从参考四面体到物理单元的等参映射的 $3\\times 3$ 雅可比矩阵，$\\mathbf{B}(\\boldsymbol{\\xi})$ 是一个具有 $n$ 个节点且每个节点有 $3$ 个位移自由度的单元的 $6\\times (3n)$ 应变-位移矩阵。假设为直边（仿射）几何形状，因此物理单元的面是平面的；$10$ 节点四面体的边中点节点位于边的中点，确保了仿射映射。然而，实现中使用通用的等参公式（对所有单元节点求和）在每个求积点上计算 $\\mathbf{J}(\\boldsymbol{\\xi})$。\n\n你需要通过显式计算评估 $\\mathbf{J}$、$\\det\\mathbf{J}$、$\\mathbf{J}^{-1}$、形函数的物理梯度以及 $\\mathbf{B}^{\\mathsf{T}}\\mathbf{D}\\mathbf{B}$ 的求积累加所需的算术运算，来估算将 $\\mathbf{K}_e$ 组装到单元存储中的每个单元的浮点运算次数。使用以下规则和假设：\n\n- 将每次浮点加法、乘法和除法计为成本 $1$；忽略所有内存加载/存储和分支成本。\n- 在每个求积点通过\n$$\nJ_{ij} = \\sum_{a=1}^{n} x_{a,i} \\, \\frac{\\partial N_a}{\\partial \\xi_j},\n$$\n计算 $\\mathbf{J}$，每个条目 $J_{ij}$ 的成本为 $n$ 次乘法和 $n-1$ 次加法。共有 $9$ 个条目。\n- 在每个求积点通过伴随矩阵（代数余子式）法计算 $\\det\\mathbf{J}$ 和 $\\mathbf{J}^{-1}$：形成所有 $9$ 个代数余子式，通过第一行与相应代数余子式的点积计算 $\\det\\mathbf{J}$，然后将伴随矩阵乘以 $1/\\det\\mathbf{J}$ 进行缩放。每个求积点的成本为 $30$ 次乘法、$11$ 次加法和 $1$ 次除法。\n- 在每个求积点通过 $\\nabla_{\\mathbf{x}} N_a = \\mathbf{J}^{-\\mathsf{T}} \\nabla_{\\boldsymbol{\\xi}} N_a$ 将参考梯度映射到物理梯度，每个节点进行一次 $3\\times 3$ 矩阵-向量乘积，成本为每个节点 $9$ 次乘法和 $6$ 次加法。\n- 通过以下步骤在每个求积点组装被积函数：\n  1. 形成 $6\\times (3n)$ 矩阵 $\\mathbf{M} = \\mathbf{D}\\mathbf{B}$，成本为 $(6\\cdot 3n)$ 次长度为 $6$ 的点积。\n  2. 将对称乘积 $\\mathbf{B}^{\\mathsf{T}}\\mathbf{M}$ 累加到单元刚度中，仅使用上三角部分，即 $(3n)(3n+1)/2$ 次长度为 $6$ 的点积，然后对每个唯一的上三角条目，乘以标量求积权重与 $\\det\\mathbf{J}$ 的乘积进行缩放和相加。\n- 对于 $4$ 节点四面体（$\\mathrm{T}4$），使用对线性场精确的 $1$ 点求积法。对于 $10$ 节点四面体（$\\mathrm{T}10$），使用对二次被积函数精确的 $4$ 点求积法则。\n- 本构矩阵 $\\mathbf{D}$ 是常数且可重用；形成 $\\mathbf{D}$ 的成本不计。映射是仿射的，但如上所述在每个求积点进行计算。\n\n任务：\n\n- 根据上述规则，从第一性原理推导 $\\mathrm{T}4$ 和 $\\mathrm{T}10$ 单元每个单元的总运算次数。清晰地说明计算 $\\mathbf{J}$、$\\det\\mathbf{J}$、$\\mathbf{J}^{-1}$、变换梯度、形成 $\\mathbf{M}$、执行对称乘积以及用求积权重和行列式进行缩放的成本。\n- 计算比率\n$$\nR \\equiv \\frac{\\text{total flop count per element for } \\mathrm{T}10}{\\text{total flop count per element for } \\mathrm{T}4}.\n$$\n- 单独说明每种单元类型的唯一上三角单元刚度条目数 $(3n)(3n+1)/2$，并定性讨论这在组装后如何影响全局稀疏内存占用和矩阵带宽。\n\n仅提供 $R$ 的最终数值。将答案四舍五入到 $4$ 位有效数字。最终答案必须是无单位的纯数字。不要在最终答案中包含任何额外文本。", "solution": "用户提供的问题是计算固体力学中一个适定且有科学依据的练习。它要求推导T4和T10四面体单元刚度矩阵组装的浮点运算（FLOP）次数，计算这些次数的比率，并定性讨论矩阵存储的影响。该问题是自洽的，提供了所有必要的公式、假设和计数规则。没有科学或逻辑上的矛盾。因此，该问题被认为是有效的，并将提供解答。\n\n每个单元的总 FLOP 计数 $C_{\\text{total}}$ 是求积点数 $N_q$ 与每个求积点的 FLOP 计数 $C_{\\text{quad}}$ 的乘积。\n$$\nC_{\\text{total}} = N_q \\times C_{\\text{quad}}\n$$\n每个求积点的成本 $C_{\\text{quad}}$ 是几个连续步骤成本的总和，这些成本取决于节点数 $n$。我们将推导一个通用表达式 $C_{\\text{quad}}(n)$。\n\n1.  **计算雅可比矩阵 $\\mathbf{J}$ 的成本**：\n    雅可比矩阵 $\\mathbf{J}$ 是一个 $3 \\times 3$ 的矩阵。其 $9$ 个条目中的每一个 $J_{ij}$ 都是通过一个包含 $n$ 个项的和来计算的。每个条目的成本被指定为 $n$ 次乘法和 $n-1$ 次加法，总计 $2n-1$ FLOPs。\n    $\\mathbf{J}$ 的总成本是：\n    $$\n    C_J(n) = 9 \\times (2n - 1) = 18n - 9 \\text{ FLOPs}.\n    $$\n\n2.  **计算 $\\det\\mathbf{J}$ 和 $\\mathbf{J}^{-1}$ 的成本**：\n    这个成本在问题陈述中已直接给出。它是 $30$ 次乘法、$11$ 次加法和 $1$ 次除法。\n    $$\n    C_{\\text{invJ}} = 30 + 11 + 1 = 42 \\text{ FLOPs}.\n    $$\n\n3.  **将参考梯度映射到物理梯度的成本**：\n    对于 $n$ 个节点中的每一个，物理梯度 $\\nabla_{\\mathbf{x}} N_a$ 是通过一个 $3 \\times 3$ 的矩阵-向量乘积 $\\mathbf{J}^{-\\mathsf{T}} \\nabla_{\\boldsymbol{\\xi}} N_a$ 找到的。这被指定为每个节点花费 $9$ 次乘法和 $6$ 次加法。\n    所有 $n$ 个节点的总成本是：\n    $$\n    C_{\\text{grad}}(n) = n \\times (9 + 6) = 15n \\text{ FLOPs}.\n    $$\n\n4.  **组装被积函数 $\\mathbf{B}^{\\mathsf{T}}\\mathbf{D}\\mathbf{B}$ 并累加的成本**：\n    根据问题的规则，此过程分为几个子步骤。\n\n    a. **形成 $\\mathbf{M} = \\mathbf{D}\\mathbf{B}$**：\n    规则规定这需要 $(6 \\cdot 3n)$ 次长度为 $6$ 的点积。长度为 $k$ 的点积需要 $k$ 次乘法和 $k-1$ 次加法，总计 $2k-1$ FLOPs。对于 $k=6$，成本是 $6+5=11$ FLOPs。\n    此步骤的总成本是：\n    $$\n    C_M(n) = (6 \\cdot 3n) \\times 11 = 18n \\times 11 = 198n \\text{ FLOPs}.\n    $$\n\n    b. **形成并累加 $\\mathbf{B}^{\\mathsf{T}}\\mathbf{M}$**：\n    在一个求积点上的刚度矩阵贡献 $\\mathbf{K}_{qp} = \\mathbf{B}^{\\mathsf{T}}\\mathbf{M}$ 是一个对称的 $(3n) \\times (3n)$ 矩阵。我们只计算上三角条目。唯一条目的数量是 $\\frac{3n(3n+1)}{2}$。\n    每个条目都是通过长度为 $6$ 的点积计算的，成本为 $11$ FLOPs。\n    然后，这些条目中的每一个都被缩放并加到单元刚度矩阵中。缩放因子是 $s = w_q \\det\\mathbf{J}$，这需要 $1$ 次乘法（其中 $w_q$ 是求积权重）。累加 $(\\mathbf{K}_e)_{ij} \\leftarrow (\\mathbf{K}_e)_{ij} + s \\cdot (\\mathbf{K}_{qp})_{ij}$ 需要 $1$ 次乘法和 $1$ 次加法，总计 $2$ FLOPs。\n    每个条目的总成本是 $11 (\\text{点积}) + 2 (\\text{缩放-相加}) = 13$ FLOPs。\n    此累加步骤的总成本，包括找到 $s$ 的单次乘法，是：\n    $$\n    C_{\\text{accum}}(n) = 1 + \\left( \\frac{3n(3n+1)}{2} \\right) \\times 13 = 1 + \\frac{13}{2}(9n^2 + 3n) = 1 + 58.5n^2 + 19.5n \\text{ FLOPs}.\n    $$\n\n5.  **每个求积点的总成本，$C_{\\text{quad}}(n)$**：\n    总结所有步骤的成本：\n    $$\n    C_{\\text{quad}}(n) = C_J(n) + C_{\\text{invJ}} + C_{\\text{grad}}(n) + C_M(n) + C_{\\text{accum}}(n)\n    $$\n    $$\n    C_{\\text{quad}}(n) = (18n - 9) + 42 + 15n + 198n + (1 + 58.5n^2 + 19.5n)\n    $$\n    按 $n$ 的幂次收集项：\n    $$\n    C_{\\text{quad}}(n) = 58.5n^2 + (18 + 15 + 198 + 19.5)n + (-9 + 42 + 1)\n    $$\n    $$\n    C_{\\text{quad}}(n) = 58.5n^2 + 250.5n + 34\n    $$\n\n现在，我们将这个通用公式应用于 T4 和 T10 单元。\n\n**T4 单元的总 FLOP 计数**\n对于 $4$ 节点四面体 (T4)，$n=4$ 且 $N_q=1$（$1$ 点求积）。\n$$\nC_{\\text{total}}(\\text{T4}) = 1 \\times C_{\\text{quad}}(4)\n$$\n$$\nC_{\\text{total}}(\\text{T4}) = 58.5(4^2) + 250.5(4) + 34\n$$\n$$\nC_{\\text{total}}(\\text{T4}) = 58.5(16) + 1002 + 34\n$$\n$$\nC_{\\text{total}}(\\text{T4}) = 936 + 1002 + 34 = 1972 \\text{ FLOPs}.\n$$\n\n**T10 单元的总 FLOP 计数**\n对于 $10$ 节点四面体 (T10)，$n=10$ 且 $N_q=4$（$4$ 点求积）。\n$$\nC_{\\text{total}}(\\text{T10}) = 4 \\times C_{\\text{quad}}(10)\n$$\n$$\nC_{\\text{quad}}(10) = 58.5(10^2) + 250.5(10) + 34\n$$\n$$\nC_{\\text{quad}}(10) = 58.5(100) + 2505 + 34\n$$\n$$\nC_{\\text{quad}}(10) = 5850 + 2505 + 34 = 8389 \\text{ FLOPs}.\n$$\n总成本是：\n$$\nC_{\\text{total}}(\\text{T10}) = 4 \\times 8389 = 33556 \\text{ FLOPs}.\n$$\n\n**比率 $R$**\n总 FLOP 计数的比率是：\n$$\nR = \\frac{C_{\\text{total}}(\\text{T10})}{C_{\\text{total}}(\\text{T4})} = \\frac{33556}{1972} \\approx 17.016227...\n$$\n四舍五入到 $4$ 位有效数字，我们得到：\n$$\nR \\approx 17.02\n$$\n\n**关于全局矩阵存储的定性讨论**\n单元刚度矩阵中唯一的上三角条目数由 $\\frac{3n(3n+1)}{2}$ 给出。\n-   对于 T4 单元（$n=4$），自由度（DOF）的数量是 $3 \\times 4 = 12$。唯一条目的数量是 $\\frac{12(13)}{2} = 78$。\n-   对于 T10 单元（$n=10$），自由度（DOF）的数量是 $3 \\times 10 = 30$。唯一条目的数量是 $\\frac{30(31)}{2} = 465$。\n\n这对全局稀疏矩阵的组装有重要影响：\n-   **内存占用**：与 T4 单元相比，T10 单元为全局刚度矩阵贡献的非零条目*每个单元*多出 $465/78 \\approx 5.96$ 倍。虽然对于给定区域的网格，要达到相当的几何近似水平，所需的 T10 单元会比 T4 单元少，但每个单元非零项的增加通常会导致基于 T10 的离散化中全局矩阵的总体内存占用更大。\n-   **矩阵带宽**：全局刚度矩阵的带宽由单个单元内耦合的任意两个自由度（DOF）的全局索引之间的最大差异决定。由于 T10 单元连接 $10$ 个节点（和 $30$ 个自由度），而 T4 单元连接 $4$ 个节点（和 $12$ 个自由度），它天生会在可能更宽的全局节点索引范围内创建连接。在相似的节点编号方案下，这会导致 T10 网格的矩阵带宽显著增大。增加的带宽会对直接求解器（例如，Cholesky 分解）的计算成本和内存需求产生负面影响，并可能影响与迭代求解器一起使用的各种预条件器的性能。", "answer": "$$\n\\boxed{17.02}\n$$", "id": "3605651"}]}