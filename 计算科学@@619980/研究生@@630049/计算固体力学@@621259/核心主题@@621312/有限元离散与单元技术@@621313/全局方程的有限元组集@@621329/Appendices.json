{"hands_on_practices": [{"introduction": "在非线性有限元分析中，一致切线算子 (consistent tangent operator) 的正确实现对于保证牛顿-拉弗森法 (Newton-Raphson method) 的二次收敛性至关重要。本实践旨在指导你通过一种被称为“有限差分检验”的经典方法，来验证你所实现的弹塑性本构模型及其在全局方程组装中的切线矩阵。通过比较组装后的切线矩阵所预测的全局残差变化与数值有限差分计算出的变化，你可以有效地调试和验证代码的正确性 ([@problem_id:3560905])。", "problem": "使用有限元法 (FEM) 为一维小应变杆中的算法弹塑性一致切线算子设计并实现一个验证工作流。目标是通过将全局残差的方向有限差分与从组装的切线得到的线性预测进行比较，来验证全局切线矩阵的组装。所有量均为无量纲。\n\n考虑一个长度为 $L$、均匀横截面积为 $A$ 的一维杆，它由 $n_{e}$ 个线性双节点单元组成，节点坐标 $x \\in [0,L]$。令 $u$ 表示全局节点位移向量。在左端施加狄利克雷边界条件 $u(0)=0$，并在右端施加指定的牵引力 $T$，使得最后一个节点上的总节点力为 $F = T A$。对于每个单元 $e$，其内力贡献为\n$$\nf^{\\text{int}}_{e}(u) \\;=\\; \\int_{\\Omega_e} B^{\\mathsf{T}}(x)\\, \\sigma(\\varepsilon(x))\\, A \\, \\mathrm{d}x,\n$$\n单元切线矩阵为\n$$\nK^{\\text{tan}}_{e}(u) \\;=\\; \\int_{\\Omega_e} B^{\\mathsf{T}}(x)\\, \\mathbb{C}^{\\text{alg}}(\\varepsilon(x))\\, B(x)\\, A \\, \\mathrm{d}x,\n$$\n其中 $B$ 是线性杆的应变-位移矩阵，$\\varepsilon(x)$ 是轴向应变，$\\sigma$ 是小应变下的柯西应力，$\\mathbb{C}^{\\text{alg}}$ 是由本构更新提供的一维算法一致切线模量。对于长度为 $L_e$ 的线性双节点单元，$B$ 是常数 $B=[-1/L_{e}, \\, 1/L_{e}]$，因此上述积分可简化为使用单个积分点的单元级闭合形式：\n$$\nf^{\\text{int}}_{e}(u) \\;=\\; B^{\\mathsf{T}} \\, \\sigma(\\varepsilon_e) \\, A \\, L_e, \n\\qquad\nK^{\\text{tan}}_{e}(u) \\;=\\; B^{\\mathsf{T}} \\, \\mathbb{C}^{\\text{alg}}(\\varepsilon_e) \\, B \\, A \\, L_e,\n$$\n其中 $\\varepsilon_e = B u_e$，$u_e$ 为单元节点向量。\n\n使用具有线性各向同性硬化的单轴弹塑性材料。令 $E$ 为杨氏模量，$H$ 为塑性模量，$\\sigma_{y0}$ 为初始屈服应力，$\\varepsilon^{p}$ 为塑性应变，$\\alpha$ 为累积塑性应变。屈服函数为\n$$\n\\phi(\\sigma,\\alpha) \\;=\\; |\\sigma| - \\big(\\sigma_{y0} + H \\alpha\\big) \\;\\le\\; 0.\n$$\n在一维情况下，流动法则是相关的，塑性应变率为 $\\dot{\\varepsilon}^{p} = \\dot{\\gamma}\\, \\mathrm{sign}(\\sigma)$，各向同性硬化为 $\\dot{\\alpha} = \\dot{\\gamma}$，其中 $\\dot{\\gamma}\\ge 0$ 是塑性乘子率。使用小应变运动学和加法应变分解 $\\varepsilon = \\varepsilon^{e} + \\varepsilon^{p}$，其中 $\\sigma = E \\varepsilon^{e}$。假设从零状态 $\\varepsilon^{p}_n=0, \\alpha_n=0$ 到当前状态只有一个载荷增量。实现一个回归映射更新，对于给定的应变 $\\varepsilon$，返回更新后的应力 $\\sigma$ 和算法一致切线模量 $\\mathbb{C}^{\\text{alg}} = \\partial \\sigma / \\partial \\varepsilon$。\n\n将全局残差定义为\n$$\nR(u) \\;=\\; f^{\\text{int}}(u) - f^{\\text{ext}},\n$$\n其中 $f^{\\text{ext}}$ 仅包含施加在右端的节点力 $F$，其余项为零。令 $K(u)$ 为组装后的全局切线矩阵。为验证 $K(u)$，计算残差在自由度的给定方向 $p$ 上的方向变化的中心有限差分近似：\n$$\n\\Delta R_{\\text{FD}} \\;=\\; R\\big(u + \\epsilon\\, p\\big) - R\\big(u - \\epsilon\\, p\\big),\n$$\n并与线性预测\n$$\n\\Delta R_{\\text{lin}} \\;=\\; K(u)\\, (2 \\epsilon\\, p),\n$$\n进行比较，其中 $\\epsilon$ 是一个小的扰动幅度。使用相对误差\n$$\ne \\;=\\; \\frac{\\left\\|\\Delta R_{\\text{FD}} - \\Delta R_{\\text{lin}}\\right\\|_{2}}{\\max\\!\\big(\\left\\|\\Delta R_{\\text{lin}}\\right\\|_{2}, \\tau\\big)},\n$$\n其中 $\\tau$ 是一个微小的正则化项，以避免除以零。\n\n对于下述每个测试用例，构建一个平衡位移场 $u$，该位移场能产生均匀的轴向应力 $\\sigma = F/A$，同时满足 $u(0)=0$。对于均质杆，这对应于均匀应变；对于具有单元不同 $\\sigma_{y0}$ 的非均质杆，单元应变可能不同，但均匀应力得以保持。在所有情况下，每个单元使用单个高斯点进行积分。使用以下测试套件，所有用例中 $n_{e} = 2$, $A = 1$, $L = 1$，当为非均质时，单元的 $\\sigma_{y0}$ 以列表形式指定：\n\n- 用例 1（均质弹性）：$E = 2\\times 10^{5}$, $H = 10^{3}$, $\\sigma_{y0} = 250$, $F = 100$。\n- 用例 2（均质塑性）：$E = 2\\times 10^{5}$, $H = 10^{3}$, $\\sigma_{y0} = 250$, $F = 500$。\n- 用例 3（弱塑性，接近屈服）：$E = 2\\times 10^{5}$, $H = 10^{3}$, $\\sigma_{y0} = 250$, $F = 255$。\n- 用例 4（非均质混合响应）：$E = 2\\times 10^{5}$, $H = 10^{3}$, $\\sigma_{y0} = [250,\\, 1000]$, $F = 500$。\n\n实现要求：\n\n- 从上述基本定义开始。为本构模型实现一个一维回归映射更新，对于给定的 $\\varepsilon$ 返回 $\\sigma$ 和 $\\mathbb{C}^{\\text{alg}}$。\n- 通过消除 $x=0$ 处的固定位移，为自由度组装 $R(u)$ 和 $K(u)$。\n- 对于每个用例，构建一个具有均匀应力 $\\sigma = F/A$ 的平衡位移场 $u$。对于均质杆，使用 $u(x) = \\varepsilon\\, x$，其中 $\\varepsilon$ 由本构关系确定。对于非均质杆，在所有单元上强制施加均匀应力 $\\sigma$；对于单元 $e$，通过本构关系计算与均匀应力一致的单元应变 $\\varepsilon_e$，并对这些应变进行积分，以从左到右构建满足 $u(0)=0$ 的连续节点位移。\n- 每个用例在自由度空间中使用固定的扰动幅度 $\\epsilon = 10^{-8}$ 和一个确定性的随机方向 $p$，每个用例使用固定的种子以使结果可复现。使用 $\\tau = 10^{-14}$。\n- 角度单位不适用。没有物理单位；所有量均为无量纲。\n\n您的程序应产生单行输出，其中包含按用例顺序排列的四个相对误差的逗号分隔列表，并用方括号括起来，例如 $[e_1,e_2,e_3,e_4]$，其中每个 $e_i$ 是一个浮点数。", "solution": "用户要求在一维有限元法 (FEM) 框架内，设计并实现一个弹塑性算法一致切线算子的验证过程。该验证基于将全局残差向量变化的有限差分近似与从组装的切线刚度矩阵得到的预测进行比较。\n\n解决方案将按以下结构组织：\n1.  **本构模型实现**：实现一个用于具有线性各向同性硬化的弹塑性的一维回归映射算法。该函数在给定总应变 $\\varepsilon$ 的情况下，返回更新后的应力 $\\sigma$ 和算法一致切线模量 $\\mathbb{C}^{\\text{alg}} = \\partial\\sigma/\\partial\\varepsilon$。\n2.  **平衡状态构建**：为每个测试用例构建一个平衡节点位移场 $u$。该场旨在在整个杆中产生均匀的轴向应力 $\\sigma = F/A$，并满足狄利克雷边界条件 $u(0)=0$。\n3.  **有限元组装**：创建函数来计算对全局内力向量和切线刚度矩阵的单元级贡献，并将它们组装成全局系统量。通过消除 $x=0$ 处的固定自由度来处理自由度系统。\n4.  **验证工作流**：实现核心验证逻辑。这包括扰动平衡位移场，计算残差的有限差分，并将其与一致切线矩阵的线性预测进行比较。\n\n### 步骤 1：本构模型（一维回归映射）\n材料模型为具有线性各向同性硬化的单轴弹塑性。我们从无应力状态（$\\varepsilon^{p}_n=0, \\alpha_n=0$）开始。对于第 $n+1$ 步给定的总应变 $\\varepsilon$：\n\n1.  **试探状态**：假设一个弹性试探步。试探应力为 $\\sigma^{\\text{trial}} = E \\varepsilon$。使用上一步的屈服应力来评估屈服面，由于 $\\alpha_n=0$，该屈服应力就是初始屈服应力 $\\sigma_{y0}$。试探屈服函数为 $\\phi^{\\text{trial}} = |\\sigma^{\\text{trial}}| - \\sigma_{y0}$。\n\n2.  **屈服检查**：\n    - 如果 $\\phi^{\\text{trial}} \\le 0$，则该步为弹性步。应力为 $\\sigma = \\sigma^{\\text{trial}}$，切线模量为弹性模量 $\\mathbb{C}^{\\text{alg}} = E$。\n    - 如果 $\\phi^{\\text{trial}} > 0$，则发生塑性流动。需要进行回归映射，将应力状态拉回到更新后的屈服面上。\n\n3.  **塑性修正**：对于此一维模型，塑性乘子增量 $\\Delta\\gamma$ 可由一致性条件 $\\phi_{n+1}=0$ 求得。这给出：\n    $$\n    \\Delta\\gamma = \\frac{\\phi^{\\text{trial}}}{E+H} = \\frac{|\\sigma^{\\text{trial}}| - \\sigma_{y0}}{E+H}\n    $$\n    然后，更新后的应力计算如下：\n    $$\n    \\sigma = \\sigma^{\\text{trial}} - E\\,\\Delta\\gamma\\,\\mathrm{sign}(\\sigma^{\\text{trial}})\n    $$\n    算法一致切线模量是更新后的应力相对于总应变的精确导数，其表达式为：\n    $$\n    \\mathbb{C}^{\\text{alg}} = \\frac{\\partial\\sigma}{\\partial\\varepsilon} = \\frac{EH}{E+H}\n    $$\n该函数构成了模拟的本构核心。\n\n### 步骤 2：平衡位移场的构建\n为了进行验证，我们在一个已知的平衡状态 $u$ 周围分析系统。构建此状态以在所有单元上产生均匀应力 $\\sigma = F/A$。产生此应力所需的每个单元的应变 $\\varepsilon_e$ 从逆本构关系计算得出：\n- 如果 $|\\sigma| \\le \\sigma_{y0,e}$ (弹性)：$\\varepsilon_e = \\sigma/E$。\n- 如果 $|\\sigma| > \\sigma_{y0,e}$ (塑性)：总应变是弹性和塑性部分之和，$\\varepsilon_e = \\varepsilon^e + \\varepsilon^p$。弹性应变为 $\\varepsilon^e = \\sigma/E$。塑性应变的大小由硬化定律导出，即 $|\\varepsilon^p| = \\alpha = (|\\sigma| - \\sigma_{y0,e})/H$。将这些结合起来可得：\n  $$\n  \\varepsilon_e = \\mathrm{sign}(\\sigma) \\left( \\frac{|\\sigma|}{E} + \\frac{|\\sigma| - \\sigma_{y0,e}}{H} \\right)\n  $$\n在确定单元应变 $\\{\\varepsilon_e\\}$ 后，通过从固定端 $u(0)=0$ 开始对这些应变进行积分来找到节点位移：\n$$\nu_0 = 0, \\quad u_{i+1} = u_i + \\varepsilon_i L_i\n$$\n其中 $L_i$ 是单元 $i$ 的长度。\n\n### 步骤 3：有限元组装和系统简化\n分析是在一个离散化的杆上进行的，该杆有 $n_e=2$ 个线性双节点单元。总节点数为 $n_n = 3$。\n\n- **单元级矩阵**：对于每个长度为 $L_e$、面积为 $A$ 的单元 $e$，其应变-位移矩阵为 $B = [-1/L_e, 1/L_e]$。使用应变 $\\varepsilon_e = B u_e$，在单个积分点计算单元内力向量和切线刚度矩阵：\n  $$\n  f^{\\text{int}}_{e} = B^{\\mathsf{T}} \\sigma(\\varepsilon_e) A L_e, \\qquad K^{\\text{tan}}_{e} = B^{\\mathsf{T}} \\mathbb{C}^{\\text{alg}}(\\varepsilon_e) B A L_e = \\frac{\\mathbb{C}^{\\text{alg}}_e A}{L_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n  $$\n- **全局组装**：将单元贡献组装成大小分别为 $3$ 和 $3 \\times 3$ 的全局矩阵 $f^{\\text{int}}(u)$ 和 $K(u)$。\n- **系统定义**：全局残差为 $R(u) = f^{\\text{int}}(u) - f^{\\text{ext}}$，其中 $f^{\\text{ext}} = [0, 0, F]^{\\mathsf{T}}$。通过从全局系统中消除第一行和第一列来施加狄利克雷边界条件 $u(0)=0$，从而得到一个针对自由度（节点1和2）的简化系统。令其为 $R_{\\text{free}}(u)$ 和 $K_{\\text{free}}(u)$。\n\n### 步骤 4：验证过程\n该验证确认 $K_{\\text{free}}(u)$ 是 $R_{\\text{free}}(u)$ 的正确切线。使用中心有限差分来近似 $R_{\\text{free}}$ 在自由度空间中沿随机方向 $p$ 的方向导数。\n\n1.  **线性预测**：使用组装的切线矩阵来预测残差的变化：\n    $$\n    \\Delta R_{\\text{lin}} = K_{\\text{free}}(u) \\, (2 \\epsilon p)\n    $$\n2.  **有限差分近似**：在扰动后的位移状态 $u^+ = u + \\epsilon p$ 和 $u^- = u - \\epsilon p$ 下评估残差。将自由度的扰动向量 $p$ 嵌入到全局位移向量中（固定自由度对应的值为零）。\n    $$\n    \\Delta R_{\\text{FD}} = R_{\\text{free}}(u^+) - R_{\\text{free}}(u^-)\n    $$\n3.  **相对误差**：切线的准确性通过预测和近似之间的相对误差来量化：\n    $$\n    e = \\frac{\\left\\|\\Delta R_{\\text{FD}} - \\Delta R_{\\text{lin}}\\right\\|_{2}}{\\max(\\left\\|\\Delta R_{\\text{lin}}\\right\\|_{2}, \\tau)}\n    $$\n一个小的误差 $e$（接近机器精度）验证了所实现的切线模量 $\\mathbb{C}^{\\text{alg}}$ 确实与数值应力更新法则一致，并且全局组装是正确的。测试用例涵盖了弹性、塑性、近屈服和混合弹塑性响应，以确保鲁棒性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that designs, implements, and runs the verification \n    workflow for the elasto-plastic consistent tangent operator.\n    \"\"\"\n    \n    # Global constants from the problem statement\n    L_TOTAL = 1.0\n    A_CROSS_SECTION = 1.0\n    N_ELEMENTS = 2\n    EPSILON = 1e-8\n    TAU = 1e-14\n\n    def update_material(strain, E, H, sigma_y0):\n        \"\"\"\n        Implements the 1D return mapping algorithm for linear isotropic hardening.\n\n        Args:\n            strain (float): Current total strain.\n            E (float): Young's modulus.\n            H (float): Plastic modulus.\n            sigma_y0 (float): Initial yield stress.\n\n        Returns:\n            tuple: (stress, algorithmic_tangent_modulus).\n        \"\"\"\n        if np.abs(strain) < 1e-16: # Handle zero strain case to avoid division by zero\n            return 0.0, E\n\n        sigma_trial = E * strain\n        \n        # Previous state has alpha_n = 0, so current yield stress is sigma_y0\n        phi_trial = np.abs(sigma_trial) - sigma_y0\n\n        if phi_trial <= 0:\n            # Elastic step\n            return sigma_trial, E\n        else:\n            # Plastic step\n            delta_gamma = phi_trial / (E + H)\n            stress = sigma_trial - E * delta_gamma * np.sign(sigma_trial)\n            C_alg = (E * H) / (E + H)\n            return stress, C_alg\n\n    def get_equilibrium_displacement(F, E, H, sigma_y0_list, L, A, n_e):\n        \"\"\"\n        Constructs the nodal displacement vector 'u' that corresponds to a\n        state of uniform axial stress sigma = F/A.\n        \"\"\"\n        sigma_target = F / A\n        element_strains = []\n\n        for e in range(n_e):\n            sigma_y0_e = sigma_y0_list[e]\n            \n            if np.abs(sigma_target) <= sigma_y0_e:\n                strain_e = sigma_target / E\n            else:\n                strain_e = np.sign(sigma_target) * (\n                    np.abs(sigma_target) / E + (np.abs(sigma_target) - sigma_y0_e) / H\n                )\n            element_strains.append(strain_e)\n\n        n_nodes = n_e + 1\n        u_global = np.zeros(n_nodes)\n        node_coords = np.linspace(0, L, n_nodes)\n        \n        for e in range(n_e):\n            L_e = node_coords[e + 1] - node_coords[e]\n            u_global[e + 1] = u_global[e] + element_strains[e] * L_e\n            \n        return u_global\n\n    def compute_residual_and_tangent(u_global, E, H, sigma_y0_list, L, A, n_e, F):\n        \"\"\"\n        Assembles the global internal force and tangent matrix and returns the\n        components corresponding to the free degrees of freedom.\n        \"\"\"\n        n_nodes = n_e + 1\n        node_coords = np.linspace(0, L, n_nodes)\n\n        f_int_global = np.zeros(n_nodes)\n        K_tan_global = np.zeros((n_nodes, n_nodes))\n\n        for e in range(n_e):\n            i, j = e, e + 1\n            L_e = node_coords[j] - node_coords[i]\n            B = np.array([-1.0 / L_e, 1.0 / L_e])\n            u_e = u_global[[i, j]]\n            strain_e = B @ u_e\n            \n            sigma_e, C_alg_e = update_material(strain_e, E, H, sigma_y0_list[e])\n            \n            f_int_elem = B.T * sigma_e * A * L_e\n            K_tan_elem = C_alg_e * A / L_e * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n            f_int_global[i:j+1] += f_int_elem\n            K_tan_global[np.ix_([i, j], [i, j])] += K_tan_elem\n\n        f_ext_global = np.zeros(n_nodes)\n        f_ext_global[-1] = F\n        R_global = f_int_global - f_ext_global\n\n        free_dofs = slice(1, None)\n        R_free = R_global[free_dofs]\n        K_free = K_tan_global[free_dofs, free_dofs]\n        \n        return R_free, K_free\n\n    def run_verification(case_params):\n        \"\"\"\n        Runs the verification procedure for a single test case.\n        \"\"\"\n        E, H, sigma_y0_val, F, seed = case_params\n        \n        if isinstance(sigma_y0_val, list):\n            sigma_y0_list = sigma_y0_val\n        else:\n            sigma_y0_list = [sigma_y0_val] * N_ELEMENTS\n\n        u_eq = get_equilibrium_displacement(F, E, H, sigma_y0_list, L_TOTAL, A_CROSS_SECTION, N_ELEMENTS)\n        \n        n_free_dofs = N_ELEMENTS\n        rng = np.random.default_rng(seed)\n        p_free = rng.random(size=n_free_dofs)\n\n        _, K_free_eq = compute_residual_and_tangent(\n            u_eq, E, H, sigma_y0_list, L_TOTAL, A_CROSS_SECTION, N_ELEMENTS, F\n        )\n        delta_R_lin = K_free_eq @ (2 * EPSILON * p_free)\n\n        p_global = np.zeros(N_ELEMENTS + 1)\n        p_global[1:] = p_free\n        \n        u_plus = u_eq + EPSILON * p_global\n        u_minus = u_eq - EPSILON * p_global\n        \n        R_free_plus, _ = compute_residual_and_tangent(\n            u_plus, E, H, sigma_y0_list, L_TOTAL, A_CROSS_SECTION, N_ELEMENTS, F\n        )\n        R_free_minus, _ = compute_residual_and_tangent(\n            u_minus, E, H, sigma_y0_list, L_TOTAL, A_CROSS_SECTION, N_ELEMENTS, F\n        )\n        \n        delta_R_fd = R_free_plus - R_free_minus\n\n        norm_diff = np.linalg.norm(delta_R_fd - delta_R_lin)\n        norm_lin = np.linalg.norm(delta_R_lin)\n        \n        error = norm_diff / max(norm_lin, TAU)\n        \n        return error\n\n    test_cases = [\n        # (E, H, sigma_y0, F, seed)\n        (2e5, 1e3, 250.0, 100.0, 1), # Case 1: Homogeneous elastic\n        (2e5, 1e3, 250.0, 500.0, 2), # Case 2: Homogeneous plastic\n        (2e5, 1e3, 250.0, 255.0, 3), # Case 3: Weakly plastic, near yield\n        (2e5, 1e3, [250.0, 1000.0], 500.0, 4), # Case 4: Heterogeneous mixed\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_verification(case)\n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "3560905"}, {"introduction": "在工程实践中，复杂的模型常常包含具有不同网格密度的部件，或是在界面处存在非协调的网格。多点约束 (Multipoint Constraints, MPCs) 是连接这些不匹配网格的有效技术。本实践将引导你探索两种主流的 MPC 施加方法：通过变量替换直接销去从属自由度，以及使用拉格朗日乘子法 (Lagrange multipliers) 建立增广系统来施加约束 ([@problem_id:3565247])。通过这个练习，你将获得修改全局方程以适应复杂运动学关联的实践经验，并能深入比较这两种方法在系统矩阵对称性、条件数等性质上的优劣。", "problem": "您的任务是为一根带有一维不匹配网格界面的线性弹性杆，实现其全局方程组的组装，并使用多点约束（MPCs）在界面处施加连续性。您必须实现两种方法：通过线性变量替换的约束消除法，以及通过拉格朗日乘子法的约束实施。您将比较所得系统矩阵的条件数和对称性，并验证约束的满足情况。最终输出必须由一个完整、可运行的程序生成。\n\n物理设置为一根占据区间 $[0,L]$ 的一维杆，其中 $L$ 的单位为米。该杆是均匀的，具有杨氏模量 $E$ 和横截面积 $A$（两者均为常数，$E$ 的单位为帕斯卡，$A$ 的单位为 $\\mathrm{m}^2$）。不存在体力。在 $x=L$ 处施加一个末端牵引力 $T$（单位为牛顿）。左端 $x=0$ 处被固定，其本质边界条件为 $u(0)=0$，其中 $u(x)$ 表示轴向位移，单位为米。\n\n您将在重叠的子域上构建两个独立的有限元网格，这两个子域在一个界面位置 $x=\\xi$ 处相遇，但在该界面处不共享节点。左侧子网格跨越 $[0,\\xi]$，其节点为 $x_{0}^{L}, x_{1}^{L}, \\dots, x_{n_{L}-1}^{L}$，满足 $x_{0}^{L}=0$ 且 $x_{n_{L}-1}^{L}\\xi$。右侧子网格跨越 $[\\xi,L]$，其节点为 $x_{0}^{R}, x_{1}^{R}, \\dots, x_{n_{R}-1}^{R}$，满足 $x_{0}^{R}=\\xi$ 且 $x_{n_{R}-1}^{R}=L$。左右网格使用线性两节点单元独立组装成子域刚度矩阵和子域载荷向量。在没有约束的情况下，全局系统是块对角矩阵。界面连续性约束通过将右侧界面自由度（“从自由度”）与包围 $x=\\xi$ 的两个相邻左侧自由度（“主自由度”）的插值绑定来施加，具体规定如下。这是一个多点约束，因为从自由度的位移等于多个主自由度的线性组合。\n\n您必须从第一性原理出发，推导并实现这两种方法：\n\n1. 基本原理：一维线性弹性的总势能为\n$$\n\\Pi(u) = \\int_{0}^{L} \\frac{E A}{2} \\left(\\frac{du}{dx}\\right)^{2} \\, dx - T \\, u(L),\n$$\n其本质边界条件为 $u(0)=0$。弱形式源于最小势能原理：在满足本质边界条件的所有容许位移中，寻找使 $\\Pi(u)$ 最小化的 $u$。对于有限元法（FEM），在每个单元上使用线性形函数，并通过对单元贡献求和来组装全局刚度矩阵。长度为 $h$ 的区间的单元刚度为\n$$\nk^{e} = \\frac{E A}{h}\n\\begin{bmatrix}\n1  -1 \\\\\n-1  1\n\\end{bmatrix},\n$$\n唯一的外部载荷是在 $x=L$ 处施加的末端牵引力 $T$，它贡献于右侧子网格最右侧的自由度。\n\n2. 多点约束定义：假设 $x=\\xi$ 严格位于某个左侧网格单元内部（其节点为 $x_{i}^{L}$ 和 $x_{i+1}^{L}$），或与某个左侧网格节点 $x_{i}^{L}$ 重合，其中 $i$ 为某个索引。右侧界面节点为 $x_{0}^{R}=\\xi$，其未知位移为 $u_{0}^{R}$。定义来自左侧主自由度的插值权重，使得\n$$\nu_{0}^{R} = w_{1}\\, u_{i}^{L} + w_{2}\\, u_{i+1}^{L},\n$$\n其中，对于严格位于内部的情况，\n$$\nw_{1} = \\frac{x_{i+1}^{L}-\\xi}{x_{i+1}^{L}-x_{i}^{L}}, \\quad\nw_{2} = \\frac{\\xi - x_{i}^{L}}{x_{i+1}^{L}-x_{i}^{L}},\n$$\n而对于重合情况 $\\xi = x_{i}^{L}$，取 $w_{1}=1$ 和 $w_{2}=0$。该约束可写为\n$$\n\\mathbf{C}\\, \\mathbf{x} = 0,\n$$\n其中 $\\mathbf{x}$ 是通过消除法施加 $u(0)=0$ 后，将左右自由度堆叠而成的向量，而 $\\mathbf{C}$ 具有相应的系数。\n\n3. 通过变量替换的约束消除法：引入一个线性变换 $\\mathbf{x} = \\mathbf{T} \\mathbf{y}$，该变换消除了从属变量，代之以主变量，其中 $\\mathbf{y}$ 是简化的独立变量集。推导并组装修正后的简化系统\n$$\n\\mathbf{K}_{\\mathrm{elim}} = \\mathbf{T}^{\\top} \\mathbf{K} \\mathbf{T}, \\quad\n\\mathbf{f}_{\\mathrm{elim}} = \\mathbf{T}^{\\top} \\mathbf{f},\n$$\n然后求解 $\\mathbf{y}$ 并恢复 $\\mathbf{x}$。通过计算残差 $r_{\\mathrm{elim}} = \\lVert \\mathbf{C}\\, \\mathbf{x} \\rVert_{\\infty}$（单位为米）来验证 MPC 是否被满足。\n\n4. 拉格朗日乘子法：使用拉格朗日乘子（LM）组装鞍点系统，\n$$\n\\begin{bmatrix}\n\\mathbf{K}  \\mathbf{C}^{\\top} \\\\\n\\mathbf{C}  \\mathbf{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{x} \\\\\n\\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f} \\\\\n0\n\\end{bmatrix},\n$$\n并求解 $\\mathbf{x}$ 和 $\\lambda$。通过计算 MPC 残差 $r_{\\mathrm{LM}} = \\lVert \\mathbf{C}\\, \\mathbf{x} \\rVert_{\\infty}$（单位为米）来验证。\n\n对于每种方法，您必须计算：\n- 矩阵的 2-范数条件数，量化为\n$$\n\\kappa_{2}(\\mathbf{A}) = \\frac{\\sigma_{\\max}(\\mathbf{A})}{\\sigma_{\\min}(\\mathbf{A})},\n$$\n其中 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 分别是 $\\mathbf{A}$ 的最大和最小奇异值。\n- 一个布尔值，通过检查 $\\mathbf{A}-\\mathbf{A}^{\\top}$ 的最大绝对值项是否小于一个容差（使用数值容差 $10^{-12}$），来指示每个矩阵是否对称。\n\n单位：\n- 位移 $u$ 和残差 $r_{\\mathrm{elim}}$ 及 $r_{\\mathrm{LM}}$ 的单位必须是米。\n- 材料参数 $E$ 的单位为帕斯卡，$A$ 的单位为 $\\mathrm{m}^{2}$，牵引力 $T$ 的单位为牛顿，长度单位为米。\n- 条件数是无量纲的。\n\n请为以下测试套件实现上述内容，每个测试由 $(E,A,T,L,\\xi,\\text{左侧节点},\\text{右侧节点})$ 定义：\n- 测试用例1（正常路径，不匹配网格，内部插值）：\n  - $E = 2.10 \\times 10^{11}$，$A = 1.0 \\times 10^{-4}$，$T = 1.0 \\times 10^{3}$，$L = 1.0$，$\\xi = 0.45$，\n  - 左侧节点：$[0.0, 0.3, 0.6]$，\n  - 右侧节点：$[0.45, 0.75, 1.0]$。\n- 测试用例2（边界插值，$\\xi$ 与一个左侧节点重合）：\n  - $E = 1.90 \\times 10^{11}$，$A = 1.2 \\times 10^{-4}$，$T = 5.0 \\times 10^{2}$，$L = 1.0$，$\\xi = 0.5$，\n  - 左侧节点：$[0.0, 0.5, 0.8]$，\n  - 右侧节点：$[0.5, 0.9, 1.0]$。\n- 测试用例3（通过界面附近一个非常小的左侧单元导致的病态条件）：\n  - $E = 2.00 \\times 10^{11}$，$A = 0.8 \\times 10^{-4}$，$T = 8.0 \\times 10^{2}$，$L = 1.0$，$\\xi = 0.55$，\n  - 左侧节点：$[0.0, 0.49, 0.49001, 0.7]$，\n  - 右侧节点：$[0.55, 0.8, 1.0]$。\n\n算法要求：\n- 使用线性的两节点单元刚度公式和标准的有限元组装方法（源自弱形式）来组装子域刚度矩阵，不得使用除上述单元形式之外的快捷公式。\n- 在施加 MPCs 之前，在全局组装层面通过消除法施加 $u(0)=0$。\n- 对于约束消除法，构建显式的变换矩阵 $\\mathbf{T}$，以实现关系 $u_{0}^{R} = w_{1}\\, u_{i}^{L} + w_{2}\\, u_{i+1}^{L}$，并进行自由度到简化变量的适当映射。\n- 对于拉格朗日乘子法，按照规定组装增广鞍点系统。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，输出一个包含六个条目的列表：$[\\kappa_{2}(\\mathbf{K}_{\\mathrm{elim}}), \\kappa_{2}(\\mathbf{K}_{\\mathrm{aug}}), \\text{is\\_sym\\_elim}, \\text{is\\_sym\\_aug}, r_{\\mathrm{elim}}, r_{\\mathrm{LM}}]$，其中 $\\text{is\\_sym\\_elim}$ 和 $\\text{is\\_sym\\_aug}$ 是布尔值。条件数使用浮点数并四舍五入到六位小数，残差四舍五入到十二位小数。因此，最终输出是一个包含三个列表的列表，每个测试用例一个，例如 $[[\\dots],[\\dots],[\\dots]]$。", "solution": "当前任务是实现并分析两种在一维有限元网格的非协调界面上施加连续性的方法：约束消除法和拉格朗日乘子法。分析内容包括为每种方法组装系统矩阵，求解所得的线性系统，并评估矩阵属性（条件数、对称性）和约束满足情况。\n\n物理系统是一根一维线性弹性杆，其长度为 $L$，杨氏模量为 $E$，横截面积为 $A$。它在 $x=0$ 处固定（$u(0)=0$），并在 $x=L$ 处承受点牵引力 $T$。总势能泛函由下式给出\n$$\n\\Pi(u) = \\int_{0}^{L} \\frac{E A}{2} \\left(\\frac{du}{dx}\\right)^{2} \\, dx - T \\, u(L)\n$$\n有限元法（FEM）将此问题离散化。我们使用两节点线性单元。长度为 $h$ 的单元的刚度矩阵为\n$$\nk^{e} = \\frac{E A}{h}\n\\begin{bmatrix}\n1  -1 \\\\\n-1  1\n\\end{bmatrix}\n$$\n域被离散为两个子网格，它们在一个界面 $x=\\xi$ 处相遇但不共享节点。一个左侧网格覆盖从 $x=0$ 到并超过 $\\xi$ 的区域，一个右侧网格从 $x=\\xi$ 开始延伸到 $x=L$。在通过移除相应的自由度（DOF）来施加本质边界条件 $u(0)=0$ 后，这将产生一个块对角形式的无约束方程组 $\\mathbf{K}\\mathbf{x} = \\mathbf{f}$，其中 $\\mathbf{K} = \\text{diag}(\\mathbf{K}^L, \\mathbf{K}^R)$。\n\n界面 $x=\\xi$ 处的连续性通过多点约束（MPC）施加。右侧网格第一个节点（位于 $x_0^R = \\xi$）的位移 $u_0^R$ 被约束为包围 $\\xi$ 的左侧网格两个节点 $u_i^L$ 和 $u_{i+1}^L$ 位移的插值。约束方程为\n$$\nu_0^R = w_1 u_i^L + w_2 u_{i+1}^L\n$$\n其中 $w_1 = \\frac{x_{i+1}^{L}-\\xi}{x_{i+1}^{L}-x_{i}^{L}}$ 和 $w_2 = \\frac{\\xi - x_{i}^{L}}{x_{i+1}^{L}-x_{i}^{L}}$ 是线性插值权重。在 $\\xi$ 与左侧网格节点 $x_i^L$ 重合的情况下，权重为 $w_1=1$ 和 $w_2=0$，这实际上是将从属自由度绑定到单个主自由度上。这个 MPC 可以用矩阵形式表示为 $\\mathbf{C}\\mathbf{x} = \\mathbf{0}$，其中 $\\mathbf{C}$ 是一个单行矩阵，$\\mathbf{x}$ 是所有活动自由度的向量。\n\n我们现在将详细介绍整合此约束的两种方法。\n\n**1. 通过变量替换的约束消除法**\n\n此方法从方程组中消除因变量（从属自由度），从而得到一个仅用自变量（独立自由度）表示的、规模更小但可能更稠密的系统。我们定义一个线性变换 $\\mathbf{x} = \\mathbf{T}\\mathbf{y}$，其中 $\\mathbf{y}$ 是简化的独立自由度向量，$\\mathbf{T}$ 是一个变换矩阵。$\\mathbf{y}$ 的维数比 $\\mathbf{x}$ 的维数小一。\n\n向量 $\\mathbf{y}$ 可以选择为从向量 $\\mathbf{x}$ 中移除从属自由度后得到的向量。设从属自由度为 $x_s = u_0^R$，主自由度为 $x_{m1} = u_i^L$ 和 $x_{m2} = u_{i+1}^L$。约束为 $x_s = w_1 x_{m1} + w_2 x_{m2}$。尺寸为 $N \\times (N-1)$（其中 $N$ 是 $\\mathbf{x}$ 的大小）的变换矩阵 $\\mathbf{T}$ 的构造如下：\n- $\\mathbf{T}$ 的列将 $\\mathbf{y}$ 中的独立自由度映射回 $\\mathbf{x}$ 中的完整自由度集。\n- 对于一个与原始自由度 $x_k$（其中 $k$ 不是从属自由度的索引）对应的独立自由度 $y_j$，$\\mathbf{T}$ 的第 $j$ 列将是一个在位置 $k$ 处为 1 的单位向量。\n- $\\mathbf{T}$ 中对应于从属自由度 $x_s$ 的行是根据约束方程构造的。由于主自由度 $x_{m1}$ 和 $x_{m2}$ 本身也是 $\\mathbf{y}$ 中存在的独立自由度（位于某个位置 $j_{m1}$ 和 $j_{m2}$），$\\mathbf{T}$ 的从属行将在列 $j_{m1}$ 和 $j_{m2}$ 上分别包含条目 $w_1$ 和 $w_2$。\n\n将 $\\mathbf{x} = \\mathbf{T}\\mathbf{y}$ 代入势能泛函 $\\Pi(\\mathbf{x}) = \\frac{1}{2}\\mathbf{x}^\\top\\mathbf{K}\\mathbf{x} - \\mathbf{x}^\\top\\mathbf{f}$ 得到 $\\Pi(\\mathbf{y}) = \\frac{1}{2}(\\mathbf{T}\\mathbf{y})^\\top\\mathbf{K}(\\mathbf{T}\\mathbf{y}) - (\\mathbf{T}\\mathbf{y})^\\top\\mathbf{f}$。对 $\\mathbf{y}$ 求最小值，得到简化系统：\n$$\n\\mathbf{K}_{\\mathrm{elim}}\\mathbf{y} = \\mathbf{f}_{\\mathrm{elim}}, \\quad \\text{其中} \\quad \\mathbf{K}_{\\mathrm{elim}} = \\mathbf{T}^\\top\\mathbf{K}\\mathbf{T} \\quad \\text{和} \\quad \\mathbf{f}_{\\mathrm{elim}} = \\mathbf{T}^\\top\\mathbf{f}\n$$\n原始刚度矩阵 $\\mathbf{K}$ 是对称且正定的（因为刚体模式已被移除）。变换后的矩阵 $\\mathbf{K}_{\\mathrm{elim}}$ 也将是对称且正定的。在求解出 $\\mathbf{y}$ 之后，通过 $\\mathbf{x} = \\mathbf{T}\\mathbf{y}$ 恢复完整的位移向量。\n\n**2. 拉格朗日乘子法**\n\n此方法通过引入一个新变量，即拉格朗日乘子 $\\lambda$，来增广方程组。该乘子代表了施加 MPC 所需的约束力。寻求增广拉格朗日泛函 $\\mathcal{L}(\\mathbf{x}, \\lambda) = \\Pi(\\mathbf{x}) + \\lambda^\\top(\\mathbf{C}\\mathbf{x})$ 的驻点。将关于 $\\mathbf{x}$ 和 $\\lambda$ 的变分设为零，得到鞍点系统：\n$$\n\\begin{bmatrix}\n\\mathbf{K}  \\mathbf{C}^{\\top} \\\\\n\\mathbf{C}  \\mathbf{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{x} \\\\\n\\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f} \\\\\n0\n\\end{bmatrix}\n$$\n这个增广系统比原始的无约束系统更大。增广矩阵 $\\mathbf{K}_{\\mathrm{aug}}$ 在构造上是对称的。然而，由于对角线上的零块，它不是正定的，这可能导致与原始定矩阵 $\\mathbf{K}$ 或简化矩阵 $\\mathbf{K}_{\\mathrm{elim}}$ 相比具有更高的条件数。这种方法的优点是不需要显式构造变换矩阵 $\\mathbf{T}$，并且它能直接计算出约束力（即拉格朗日乘子 $\\lambda$）。\n\n**实现步骤**\n对于每个测试用例，执行以下程序：\n1.  **子域组装**：对于左右网格，组装单元刚度矩阵 $k^e$ 并将其贡献累加到子域矩阵 $\\mathbf{K}^L_{\\text{full}}$ 和 $\\mathbf{K}^R_{\\text{full}}$ 中。\n2.  **全局组装**：形成块对角的无约束全局刚度矩阵 $\\mathbf{K}$ 和力向量 $\\mathbf{f}$。通过移除 $\\mathbf{K}^L_{\\text{full}}$ 的第一行和第一列来施加本质边界条件 $u(0)=0$。将牵引载荷 $T$ 施加到全局力向量 $\\mathbf{f}$ 的最后一个条目上。\n3.  **MPC 定义**：在左侧网格上识别主自由度，在右侧网格上识别从属自由度。计算插值权重 $w_1, w_2$ 并构造约束矩阵 $\\mathbf{C}$。\n4.  **求解（消除法）**：构造变换矩阵 $\\mathbf{T}$。形成并求解简化系统 $\\mathbf{K}_{\\mathrm{elim}}\\mathbf{y} = \\mathbf{f}_{\\mathrm{elim}}$。恢复完整解 $\\mathbf{x}_{\\mathrm{elim}}$。\n5.  **求解（拉格朗日乘子法）**：形成并求解增广系统，得到包含 $\\mathbf{x}_{\\mathrm{LM}}$ 和 $\\lambda$ 的解向量。\n6.  **分析**：对于两种方法，使用其奇异值计算系统矩阵的 2-范数条件数 $\\kappa_2$（$\\kappa_2(\\mathbf{A}) = \\sigma_{\\max}/\\sigma_{\\min}$），检查对称性，并计算约束满足残差 $r = \\lVert \\mathbf{C}\\mathbf{x} \\rVert_{\\infty}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_subsystem(nodes, E, A):\n    \"\"\"\n    Assembles the stiffness matrix for a 1D submesh using linear elements.\n    \"\"\"\n    n_nodes = len(nodes)\n    K_sub = np.zeros((n_nodes, n_nodes))\n    \n    for i in range(n_nodes - 1):\n        h = nodes[i+1] - nodes[i]\n        if h <= 0:\n            raise ValueError(\"Element length must be positive.\")\n        k_e_val = E * A / h\n        k_e = k_e_val * np.array([[1, -1], [-1, 1]])\n        \n        # Assembly (scatter-add)\n        K_sub[i:i+2, i:i+2] += k_e\n        \n    return K_sub\n\ndef solve_one_case(E, A, T, L, xi, left_nodes, right_nodes):\n    \"\"\"\n    Solves a single test case for the 1D bar problem with non-matching meshes.\n    \"\"\"\n    left_nodes = np.array(left_nodes, dtype=float)\n    right_nodes = np.array(right_nodes, dtype=float)\n\n    # 1. Assemble subdomain systems\n    K_L_full = assemble_subsystem(left_nodes, E, A)\n    K_R_full = assemble_subsystem(right_nodes, E, A)\n\n    # 2. Apply u(0)=0 and assemble global unconstrained system\n    # Eliminate the first DOF of the left mesh\n    K_L = K_L_full[1:, 1:]\n    n_L_active = K_L.shape[0]\n    n_R_active = K_R_full.shape[0]\n    N = n_L_active + n_R_active\n\n    K = np.zeros((N, N))\n    f = np.zeros(N)\n\n    K[:n_L_active, :n_L_active] = K_L\n    K[n_L_active:, n_L_active:] = K_R_full\n    \n    # Apply traction T at x=L (last DOF of the right mesh)\n    f[-1] = T\n\n    # 3. Define the Multipoint Constraint (MPC)\n    # Find master nodes bracketing xi on the left mesh\n    master_idx_i = -1\n    for i in range(len(left_nodes) - 1):\n        if left_nodes[i] <= xi <= left_nodes[i+1]:\n            master_idx_i = i\n            break\n    if master_idx_i == -1:\n        raise ValueError(\"xi is not within any left mesh element.\")\n\n    # Calculate interpolation weights\n    if np.isclose(xi, left_nodes[master_idx_i]):\n        w1, w2 = 1.0, 0.0\n    else:\n        h_master = left_nodes[master_idx_i+1] - left_nodes[master_idx_i]\n        w1 = (left_nodes[master_idx_i+1] - xi) / h_master\n        w2 = (xi - left_nodes[master_idx_i]) / h_master\n\n    # Identify global indices of slave and master DOFs\n    # Slave: u_0^R, which is the first DOF of the right system\n    idx_slave = n_L_active\n    \n    # Masters: u_i^L and u_{i+1}^L\n    # Remember u(0)=0 is eliminated, so global index for u_k^L is k-1\n    idx_m1 = master_idx_i - 1 if master_idx_i > 0 else -1\n    idx_m2 = master_idx_i # Corresponds to u_{i+1}^L\n\n    # Constraint matrix C for C*x = 0\n    C = np.zeros((1, N))\n    C[0, idx_slave] = 1.0\n    if idx_m1 != -1: # Master u_i^L is an active DOF\n        C[0, idx_m1] -= w1\n    # Master u_{i+1}^L is always an active DOF in our setup\n    C[0, idx_m2] -= w2\n\n    # 4. Method 1: Constraint Elimination\n    T_mat = np.zeros((N, N - 1))\n    \n    # Identity mapping for DOFs before slave\n    T_mat[:idx_slave, :idx_slave] = np.eye(idx_slave)\n    # Identity mapping for DOFs after slave\n    T_mat[idx_slave + 1:, idx_slave:] = np.eye(N - 1 - idx_slave)\n    \n    # Slave row of T\n    # y_j maps to x_j for j  idx_slave\n    # So we can use master indices directly for y\n    if idx_m1 != -1:\n        T_mat[idx_slave, idx_m1] = w1\n    T_mat[idx_slave, idx_m2] = w2\n    \n    K_elim = T_mat.T @ K @ T_mat\n    f_elim = T_mat.T @ f\n    \n    y = np.linalg.solve(K_elim, f_elim)\n    x_elim = T_mat @ y\n    \n    svd_elim = np.linalg.svd(K_elim, compute_uv=False)\n    # Handle potential singularity for ill-conditioned cases\n    kappa_elim = svd_elim[0] / svd_elim[-1] if svd_elim[-1]  1e-15 else np.inf\n    \n    is_sym_elim = np.max(np.abs(K_elim - K_elim.T))  1e-12\n    r_elim = np.linalg.norm(C @ x_elim, ord=np.inf)\n\n    # 5. Method 2: Lagrange Multipliers\n    K_aug = np.zeros((N + 1, N + 1))\n    K_aug[:N, :N] = K\n    K_aug[:N, N] = C.T.flatten()\n    K_aug[N, :N] = C.flatten()\n\n    f_aug = np.zeros(N + 1)\n    f_aug[:N] = f\n    \n    sol_aug = np.linalg.solve(K_aug, f_aug)\n    x_lm = sol_aug[:N]\n\n    svd_aug = np.linalg.svd(K_aug, compute_uv=False)\n    kappa_aug = svd_aug[0] / svd_aug[-1] if svd_aug[-1]  1e-15 else np.inf\n\n    is_sym_aug = np.max(np.abs(K_aug - K_aug.T))  1e-12\n    r_lm = np.linalg.norm(C @ x_lm, ord=np.inf)\n\n    return [kappa_elim, kappa_aug, is_sym_elim, is_sym_aug, r_elim, r_lm]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2.10e11, 1.0e-4, 1.0e3, 1.0, 0.45, [0.0, 0.3, 0.6], [0.45, 0.75, 1.0]),\n        (1.90e11, 1.2e-4, 5.0e2, 1.0, 0.5, [0.0, 0.5, 0.8], [0.5, 0.9, 1.0]),\n        (2.00e11, 0.8e-4, 8.0e2, 1.0, 0.55, [0.0, 0.49, 0.49001, 0.7], [0.55, 0.8, 1.0])\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_one_case(*case)\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_cases = []\n    for case_res in all_results:\n        k_elim, k_aug, s_elim, s_aug, r_elim, r_lm = case_res\n        formatted_case_str = (\n            f\"[{k_elim:.6f},\"\n            f\"{k_aug:.6f},\"\n            f\"{str(s_elim).lower()},\"\n            f\"{str(s_aug).lower()},\"\n            f\"{r_elim:.12f},\"\n            f\"{r_lm:.12f}]\"\n        )\n        formatted_cases.append(formatted_case_str)\n    \n    print(f\"[{','.join(formatted_cases)}]\")\n\nsolve()\n```", "id": "3565247"}, {"introduction": "全局方程的组装不仅限于静力学问题，同样是求解动力学问题的核心。在动力学分析中，除了刚度矩阵 $K$ 外，我们还需要组装一致质量矩阵 $M$，并且时间积分格式的选择对仿真的长期稳定性和物理保真度有着深远影响。本实践将一个标准的纽马克 (Newmark) 平均加速度法与一个从哈密顿体系 (Hamiltonian system) 推导出的能量-动量守恒中点格式进行对比 ([@problem_id:3565225])。你将通过这个练习掌握动力学系统的组装方法，并深入理解离散守恒律这一关键概念，同时发现对于线性系统，这两种看似不同的方法在代数上是等价的。", "problem": "考虑一根无外力作用下进行自由振动的一维线性弹性杆。该杆具有均匀的长度 $L$、横截面积 $A$、密度 $\\rho$ 和杨氏模量 $E$。该杆使用有限元法进行离散化，包含 $n_{\\mathrm{el}}$ 个双节点线性单元和 $n_{\\mathrm{n}} = n_{\\mathrm{el}} + 1$ 个节点。设全局节点位移向量为 $u \\in \\mathbb{R}^{n_{\\mathrm{n}}}$，全局节点速度向量为 $v \\in \\mathbb{R}^{n_{\\mathrm{n}}}$，全局节点动量向量为 $p = M v \\in \\mathbb{R}^{n_{\\mathrm{n}}}$，其中 $M \\in \\mathbb{R}^{n_{\\mathrm{n}} \\times n_{\\mathrm{n}}}$ 是由单元贡献组装的一致质量矩阵，$K \\in \\mathbb{R}^{n_{\\mathrm{n}} \\times n_{\\mathrm{n}}}$ 是由单元贡献组装的刚度矩阵。内力由一个二次应变能势导出，从而得到半离散运动方程\n$$\nM \\, \\dot{v}(t) + K \\, u(t) = 0, \\quad \\dot{u}(t) = v(t),\n$$\n这些方程可由 Hamilton 原理和拉格朗日量 $L = T - V$ 导出，其中 $T = \\tfrac{1}{2} v^{\\top} M v$ 和 $V = \\tfrac{1}{2} u^{\\top} K u$。该杆两端自由，因此平移不变性成立，刚度矩阵满足 $K \\, \\mathbf{1} = 0$，其中 $\\mathbf{1}$ 是全一向量，这反映了刚体模态。\n\n从这些基本原理（Hamilton 原理和线性弹性杆的有限元组装）出发，设计两种隐式时间积分方法，在一个大小为 $\\Delta t$ 的时间步长内，将系统从 $(u_n, v_n)$推进到 $(u_{n+1}, v_{n+1})$：\n\n1. 一种能量-动量守恒方法，通过对一阶 Hamilton 系统 $(\\dot{u}, \\dot{p})$ 应用隐式中点法则得到，其中 $p = M v$，Hamilton 量为二次能量 $H(u, v) = \\tfrac{1}{2} v^{\\top} M v + \\tfrac{1}{2} u^{\\top} K u$。该方法必须在离散意义上保持与 Noether 定理相关的不变量，即时间平移对应的不变量（总能量）和空间平移对应的不变量（总线性动量 $P = \\mathbf{1}^{\\top} p$）。在全局层面上组装相应的算法切线矩阵，用于在每个时间步中求解 $u_{n+1}$。\n\n2. 标准的 Newmark 族方法，采用平均加速度参数 $\\beta = \\tfrac{1}{4}$ 和 $\\gamma = \\tfrac{1}{2}$，零阻尼，并应用于二阶形式 $M a + K u = 0$，其中 $a = \\dot{v}$。组装相应的全局算法切线矩阵，用于在每个时间步中求解 $u_{n+1}$。\n\n您必须：\n- 从第一性原理出发，推导两种方法的离散更新方程，以及在离散方程的 Newton 解法中出现的全局算法切线矩阵。第 1 项中的离散方法必须体现离散 Noether 属性：精确守恒线性 Hamilton 系统的二次不变量。\n- 使用单元长度为 $h = L / n_{\\mathrm{el}}$ 的双节点线性单元，实现 $M$ 和 $K$ 的有限元组装，其中一致单元质量为 $M_e = \\rho A h \\, \\tfrac{1}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}$，单元刚度为 $K_e = \\dfrac{E A}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$，并通过标准连接关系组装成全局矩阵。\n- 对于每种方法，从指定的初始条件 $(u_0, v_0)$ 开始，对系统进行给定时间步数的积分，并在每一步计算总能量 $H(u, v)$（单位：焦耳）和总线性动量 $P = \\mathbf{1}^{\\top} M v$（单位：千克-米/秒）。报告在整个模拟过程中能量和动量相对于其初始值的最大绝对漂移。\n\n定义以下参数集测试套件，所有单位均采用国际单位制 (SI)。对于每种情况，使用均匀时间步长 $\\Delta t$ 模拟系统 $N$ 步，并计算所需的量：\n\n- 情况 1（一般自由振动，理想路径）：\n  - $L = 1.0$ 米, $A = 0.01$ 平方米, $\\rho = 7800.0$ 千克/立方米, $E = 210 \\times 10^{9}$ 帕斯卡, $n_{\\mathrm{el}} = 6$, $\\Delta t = 7.5 \\times 10^{-6}$ 秒, $N = 1000$。\n  - 初始条件：$u_0 = 0$，在节点位置 $x_i$ 处定义 $v_0$ 为 $v_0(x_i) = 0.01 \\, \\sin\\!\\left(\\pi x_i / L\\right)$ 米/秒。\n\n- 情况 2（刚体运动，用于探测动量守恒）：\n  - $L = 2.0$ 米, $A = 0.015$ 平方米, $\\rho = 8050.0$ 千克/立方米, $E = 200 \\times 10^{9}$ 帕斯卡, $n_{\\mathrm{el}} = 8$, $\\Delta t = 1.0 \\times 10^{-4}$ 秒, $N = 500$。\n  - 初始条件：$u_0 = 0$，在所有节点上 $v_0(x_i) = 0.05$ 米/秒 均匀分布。\n\n- 情况 3（边界情况，采用粗时间步长以检验能量行为）：\n  - $L = 0.5$ 米, $A = 0.008$ 平方米, $\\rho = 8800.0$ 千克/立方米, $E = 190 \\times 10^{9}$ 帕斯卡, $n_{\\mathrm{el}} = 2$, $\\Delta t = 1.0 \\times 10^{-3}$ 秒, $N = 200$。\n  - 初始条件：$u_0(x_i) = 1.0 \\times 10^{-4} \\, \\sin\\!\\left(2 \\pi x_i / L\\right)$ 米，$v_0 = 0$。\n\n对于每种情况，您必须计算并返回两种方法的以下值：\n- 能量-动量中点方法在 $N$ 步内的最大绝对能量漂移（单位：焦耳）。\n- Newmark 平均加速度方法在 $N$ 步内的最大绝对能量漂移（单位：焦耳）。\n- 能量-动量中点方法在 $N$ 步内的最大绝对动量漂移（单位：千克-米/秒）。\n- Newmark 平均加速度方法在 $N$ 步内的最大绝对动量漂移（单位：千克-米/秒）。\n- 一个布尔值，断言能量-动量中点方法的算法切线矩阵是否为对称正定。\n- 一个布尔值，断言 Newmark 平均加速度方法的算法切线矩阵是否为对称正定。\n\n所有浮点数必须按规定以国际单位制表示，并四舍五入到六位小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目对应一个测试用例，并且本身也是一个列表，顺序完全如下\n$$\n[\\mathrm{energy\\_drift\\_EM}, \\mathrm{energy\\_drift\\_NM}, \\mathrm{momentum\\_drift\\_EM}, \\mathrm{momentum\\_drift\\_NM}, \\mathrm{SPD\\_EM}, \\mathrm{SPD\\_NM}],\n$$\n整体输出为\n$$\n\\big[\\,[\\cdot], [\\cdot], [\\cdot]\\,\\big].\n$$\n例如，如果有三个测试用例，输出格式必须为\n$$\n[[a_1,b_1,c_1,d_1,e_1,f_1],[a_2,b_2,c_2,d_2,e_2,f_2],[a_3,b_3,c_3,d_3,e_3,f_3]].\n$$", "solution": "## 问题验证\n\n所提供的问题陈述已经过仔细验证，并被确定为 **有效的**。它在计算弹性动力学的既定框架内具有科学依据，是适定的，所有必要的数据和条件都已明确指定，且语言客观。该任务要求针对一维线性弹性系统，推导、实现和比较两种标准的隐式时间积分方案——能量-动量守恒中点法则和 Newmark 平均加速度法。从第一性原理出发的推导以及随后发现这两种方法对于此特定线性问题在代数上是等价的，这构成了该任务的一个关键教学见解，而非缺陷。该问题并非微不足道，它对理论理解和实现技能都提供了严格的考验。\n\n## 理论推导与实现策略\n\n该问题要求为一维线性弹性杆的半离散运动方程设计和分析两种隐式时间积分方案：\n$$\nM \\ddot{u}(t) + K u(t) = 0\n$$\n其中 $M$ 和 $K$ 分别是全局一致质量矩阵和刚度矩阵，$u(t)$ 是节点位移向量。\n\n### 有限元组装\n\n全局矩阵 $M$ 和 $K$ 由单元级贡献组装而成。对于具有 $n_{\\mathrm{el}}$ 个长度为 $h = L/n_{\\mathrm{el}}$ 的单元的均匀离散化，每个单元 $e$ 连接两个节点。单元质量矩阵 $M_e$ 和单元刚度矩阵 $K_e$ 由下式给出：\n$$\nM_e = \\frac{\\rho A h}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}, \\quad K_e = \\frac{E A}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n这些单元矩阵根据单元连接关系被系统地加到全局矩阵 $M \\in \\mathbb{R}^{n_{\\mathrm{n}} \\times n_{\\mathrm{n}}}$ 和 $K \\in \\mathbb{R}^{n_{\\mathrm{n}} \\times n_{\\mathrm{n}}}$ 中。最终的全局质量矩阵 $M$ 是对称正定 (SPD) 的。由于自由-自由边界条件引入了刚体平移模态，全局刚度矩阵 $K$ 是对称半正定 (SPSD) 的。该模态对应于 $K$ 的零空间，由全一向量 $\\mathbf{1}$ 张成，满足 $K\\mathbf{1}=0$。\n\n### 方法 1：能量-动量 (EM) 守恒中点法则\n\n该方法通过将隐式中点法则应用于运动方程的一阶 Hamilton 形式来推导。状态变量是广义坐标 $u$ 及其共轭动量 $p = Mv$。代表总能量的 Hamilton 量 $H(u,p)$ 是：\n$$\nH(u,p) = \\frac{1}{2} p^{\\top} M^{-1} p + \\frac{1}{2} u^{\\top} K u\n$$\n一阶运动方程是 Hamilton 方程：\n$$\n\\dot{u} = \\frac{\\partial H}{\\partial p} = M^{-1}p = v, \\quad \\dot{p} = -\\frac{\\partial H}{\\partial u} = -Ku\n$$\n在从 $t_n$ 到 $t_{n+1}$ 的时间步长 $\\Delta t$ 上应用隐式中点法则：\n$$\nu_{n+1} - u_n = \\Delta t \\, \\dot{u}_{n+1/2} = \\Delta t \\, v_{n+1/2}\n$$\n$$\np_{n+1} - p_n = \\Delta t \\, \\dot{p}_{n+1/2} = -\\Delta t \\, K u_{n+1/2}\n$$\n其中中点值定义为平均值：$u_{n+1/2} = \\frac{u_n+u_{n+1}}{2}$ 和 $v_{n+1/2} = \\frac{v_n+v_{n+1}}{2}$。代入这些平均值和关系式 $p=Mv$ 可得：\n$$\nu_{n+1} - u_n = \\frac{\\Delta t}{2} (v_n + v_{n+1}) \\quad (1)\n$$\n$$\nMv_{n+1} - Mv_n = -\\frac{\\Delta t}{2} K (u_n + u_{n+1}) \\quad (2)\n$$\n从 (1) 式，我们可以用未知位移 $u_{n+1}$ 来表示未知速度 $v_{n+1}$：\n$$\nv_{n+1} = \\frac{2}{\\Delta t}(u_{n+1} - u_n) - v_n\n$$\n将此式代入 (2) 式并重新整理各项以分离出 $u_{n+1}$，得到最终的线性系统：\n$$\n\\left(M + \\frac{\\Delta t^2}{4} K\\right) u_{n+1} = \\left(M - \\frac{\\Delta t^2}{4} K\\right) u_n + \\Delta t M v_n\n$$\n矩阵 $A_{\\mathrm{EM}} = M + \\frac{\\Delta t^2}{4} K$ 是 **算法切线矩阵**。由于 $M$ 是对称正定 (SPD)，$K$ 是对称半正定 (SPSD)，它们的正加权和 $A_{\\mathrm{EM}}$ 是对称正定的。该方法作为一个应用于二次 Hamilton 量的辛积分器，能够精确保持系统的任何二次不变量。对于这个线性问题，总能量 $H(u,v) = \\frac{1}{2}v^{\\top}Mv + \\frac{1}{2}u^{\\top}Ku$ 是二次的，因此是守恒的。总线性动量 $P = \\mathbf{1}^{\\top}p = \\mathbf{1}^{\\top}Mv$ 也是守恒的。这是因为其时间导数为 $\\dot{P} = \\mathbf{1}^{\\top}\\dot{p} = -\\mathbf{1}^{\\top}Ku$，并且对于自由-自由杆，$\\mathbf{1}^{\\top}K = (K\\mathbf{1})^{\\top} = 0^{\\top} = 0$。动量的离散更新法则 $P_{n+1} - P_n = -\\Delta t \\mathbf{1}^{\\top} K u_{n+1/2} = 0$ 证实了精确的离散动量守恒。\n\n### 方法 2：Newmark 平均加速度法\n\n该方法应用于二阶方程 $M\\ddot{u} + Ku = 0$。对于平均加速度法，Newmark 参数为 $\\gamma = 1/2$ 和 $\\beta=1/4$。位移和速度的更新法则为：\n$$\nu_{n+1} = u_n + \\Delta t \\, v_n + \\frac{\\Delta t^2}{4} (a_n + a_{n+1}) \\quad (3)\n$$\n$$\nv_{n+1} = v_n + \\frac{\\Delta t}{2}(a_n + a_{n+1}) \\quad (4)\n$$\n其中 $a_n$ 和 $a_{n+1}$ 分别是 $t_n$ 和 $t_{n+1}$ 时刻的加速度。运动方程在 $t_{n+1}$ 时刻必须成立：\n$$\nM a_{n+1} + K u_{n+1} = 0\n$$\n从 (3) 式，我们用未知位移 $u_{n+1}$ 表示未知加速度 $a_{n+1}$：\n$$\na_{n+1} = \\frac{4}{\\Delta t^2}\\left(u_{n+1} - u_n - \\Delta t \\, v_n\\right) - a_n\n$$\n将此式代入 $t_{n+1}$ 时刻的运动方程并重新整理，得到关于 $u_{n+1}$ 的系统：\n$$\n\\left(\\frac{4}{\\Delta t^2}M + K\\right)u_{n+1} = M\\left(\\frac{4}{\\Delta t^2}u_n + \\frac{4}{\\Delta t}v_n + a_n\\right)\n$$\n矩阵 $A_{\\mathrm{NM}} = \\frac{4}{\\Delta t^2}M + K$ 是 **算法切线矩阵**。与 $A_{\\mathrm{EM}}$ 一样，该矩阵也是对称正定的。\n\n### 线性系统下两种方法的等价性\n\n直接比较表明，对于这个线性问题，推导出的两种方法在代数上是等价的。将 $Ma_n = -Ku_n$ 代入 Newmark 系统的右侧，得到：\n$$\n\\left(\\frac{4}{\\Delta t^2}M + K\\right)u_{n+1} = \\frac{4}{\\Delta t^2}M u_n + \\frac{4}{\\Delta t}M v_n - K u_n\n$$\n将整个方程乘以 $\\frac{\\Delta t^2}{4}$，可以恢复出与能量-动量方法完全相同的系统：\n$$\n\\left(M + \\frac{\\Delta t^2}{4}K\\right)u_{n+1} = M u_n + \\Delta t M v_n - \\frac{\\Delta t^2}{4} K u_n = \\left(M - \\frac{\\Delta t^2}{4}K\\right) u_n + \\Delta t M v_n\n$$\n速度更新法则也可以被证明是相同的。因此，对于这个线性系统，两种方法会为 $(u, v)$ 生成相同的数值轨迹，并表现出相同（理论上为零）的能量和动量漂移，任何观察到的非零漂移都完全归因于浮点运算。\n\n### 实现与分析\n\n对每个测试用例，实现过程遵循以下步骤：\n1. **组装**：从单元矩阵组装全局矩阵 $M$ 和 $K$。\n2. **初始化**：设置初始条件 $u_0$ 和 $v_0$。计算初始能量 $H_0$ 和动量 $P_0$。\n3. **时间步进**：一个循环将系统推进 $N$ 步。在每一步中，构建算法切线矩阵和右端向量，求解关于 $u_{n+1}$ 的线性系统，并更新速度 $v_{n+1}$。计算并存储能量 $H_{n+1}$ 和动量 $P_{n+1}$。\n4. **分析**：最大绝对能量漂移为 $\\max_{n=1..N} |H_n - H_0|$，最大绝对动量漂移为 $\\max_{n=1..N} |P_n - P_0|$。算法切线矩阵的对称正定 (SPD) 属性通过数值方式进行验证。对称性通过 `np.allclose(A, A.T)` 检查，正定性通过确保所有特征值（通过 `np.linalg.eigvalsh` 计算）均为正来确认。由于两个切线矩阵互为正标量倍数，它们的 SPD 属性是相同的。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve\n\ndef assemble_matrices(L, A, rho, E, n_el):\n    \"\"\"\n    Assembles the global consistent mass and stiffness matrices for a 1D bar.\n    \"\"\"\n    n_n = n_el + 1\n    h = L / n_el\n    M = np.zeros((n_n, n_n))\n    K = np.zeros((n_n, n_n))\n\n    m_e_factor = rho * A * h / 6.0\n    M_e = m_e_factor * np.array([[2, 1], [1, 2]])\n\n    k_e_factor = E * A / h\n    K_e = k_e_factor * np.array([[1, -1], [-1, 1]])\n\n    for i in range(n_el):\n        nodes = [i, i + 1]\n        M[np.ix_(nodes, nodes)] += M_e\n        K[np.ix_(nodes, nodes)] += K_e\n\n    return M, K\n\ndef is_spd(matrix):\n    \"\"\"\n    Checks if a matrix is symmetric positive definite (SPD).\n    \"\"\"\n    if not np.allclose(matrix, matrix.T):\n        return False\n    try:\n        eigenvalues = np.linalg.eigvalsh(matrix)\n        # Check if all eigenvalues are strictly positive, using a small tolerance for robustness.\n        return np.all(eigenvalues  1e-12)\n    except np.linalg.LinAlgError:\n        return False\n\ndef run_simulation(u0, v0, M, K, dt, N, method_name):\n    \"\"\"\n    Runs the time integration for a given method and returns simulation results.\n    The two methods requested are algebraically identical for this linear problem.\n    This function implements their common update rule.\n    \"\"\"\n    n_n = M.shape[0]\n    u, v = np.copy(u0), np.copy(v0)\n    \n    # Algorithmic tangent for the Energy-Momentum (EM) method\n    tangent_em = M + (dt**2 / 4) * K\n    tangent_is_spd_em = is_spd(tangent_em)\n\n    # Algorithmic tangent for the Newmark method\n    tangent_nm = (4 / dt**2) * M + K\n    tangent_is_spd_nm = is_spd(tangent_nm)\n    \n    # We use the EM tangent formulation for the linear solve. As shown in the\n    # derivation, this is equivalent to using the Newmark tangent formulation.\n    A_solve = tangent_em\n\n    energy_history = np.zeros(N + 1)\n    momentum_history = np.zeros(N + 1)\n    ones = np.ones(n_n)\n\n    # Calculate initial state\n    energy_history[0] = 0.5 * v.T @ M @ v + 0.5 * u.T @ K @ u\n    momentum_history[0] = ones.T @ M @ v\n\n    for i in range(N):\n        # Form RHS vector based on the EM formulation\n        rhs = (M - (dt**2 / 4) * K) @ u + dt * M @ v\n        \n        # Solve for the new displacement u_{n+1}\n        # 'assume_a=pos' indicates that A_solve is positive definite, enabling a faster solver.\n        u_new = solve(A_solve, rhs, assume_a='pos')\n\n        # Update velocity using the common update rule\n        v_new = (2 / dt) * (u_new - u) - v\n        \n        u, v = u_new, v_new\n\n        # Calculate and store energy and momentum for the new state\n        energy_history[i + 1] = 0.5 * v.T @ M @ v + 0.5 * u.T @ K @ u\n        momentum_history[i + 1] = ones.T @ M @ v\n    \n    max_energy_drift = np.max(np.abs(energy_history - energy_history[0]))\n    max_momentum_drift = np.max(np.abs(momentum_history - momentum_history[0]))\n    \n    if method_name == 'EM':\n      return max_energy_drift, max_momentum_drift, tangent_is_spd_em\n    else: # Newmark\n      return max_energy_drift, max_momentum_drift, tangent_is_spd_nm\n\ndef solve_all_cases():\n    \"\"\"\n    Defines test cases, runs simulations for each, and formats the output.\n    \"\"\"\n    test_cases = [\n        {\n            \"L\": 1.0, \"A\": 0.01, \"rho\": 7800.0, \"E\": 210e9, \n            \"n_el\": 6, \"dt\": 7.5e-6, \"N\": 1000,\n            \"u0_func\": lambda x, L: 0.0,\n            \"v0_func\": lambda x, L: 0.01 * np.sin(np.pi * x / L)\n        },\n        {\n            \"L\": 2.0, \"A\": 0.015, \"rho\": 8050.0, \"E\": 200e9, \n            \"n_el\": 8, \"dt\": 1.0e-4, \"N\": 500,\n            \"u0_func\": lambda x, L: 0.0,\n            \"v0_func\": lambda x, L: 0.05\n        },\n        {\n            \"L\": 0.5, \"A\": 0.008, \"rho\": 8800.0, \"E\": 190e9, \n            \"n_el\": 2, \"dt\": 1.0e-3, \"N\": 200,\n            \"u0_func\": lambda x, L: 1.0e-4 * np.sin(2 * np.pi * x / L),\n            \"v0_func\": lambda x, L: 0.0\n        }\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        L, A, rho, E = case[\"L\"], case[\"A\"], case[\"rho\"], case[\"E\"]\n        n_el, dt, N = case[\"n_el\"], case[\"dt\"], case[\"N\"]\n        n_n = n_el + 1\n        \n        M, K = assemble_matrices(L, A, rho, E, n_el)\n        \n        x_nodes = np.linspace(0, L, n_n)\n        u0 = np.array([case[\"u0_func\"](x, L) for x in x_nodes])\n        v0 = np.array([case[\"v0_func\"](x, L) if callable(case[\"v0_func\"]) else case[\"v0_func\"] for x in x_nodes])\n\n        # Since the methods are algebraically identical for this linear problem,\n        # their numerical results for drift will be identical.\n        # We run the simulation once and report the results for both.\n        \n        # Energy-Momentum Method anaylsis\n        energy_drift_em, momentum_drift_em, spd_em = run_simulation(u0, v0, M, K, dt, N, 'EM')\n        \n        # Newmark Method analysis\n        energy_drift_nm, momentum_drift_nm, spd_nm = run_simulation(u0, v0, M, K, dt, N, 'Newmark')\n\n        case_results = [\n            f\"{energy_drift_em:.6f}\",\n            f\"{energy_drift_nm:.6f}\",\n            f\"{momentum_drift_em:.6f}\",\n            f\"{momentum_drift_nm:.6f}\",\n            str(spd_em).lower(),\n            str(spd_nm).lower()\n        ]\n        all_results_str.append(f\"[{','.join(case_results)}]\")\n\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve_all_cases()\n```", "id": "3565225"}]}