{"hands_on_practices": [{"introduction": "这项首个实践是一项基础理论练习。它着重于推导环向应变 $\\varepsilon_{\\theta\\theta}$ 的表达式，这是轴对称分析中的一个关键运动学量。在进行数值实现之前，理解该应变分量如何与径向位移相关，以及如何在对称轴（$r=0$）上正确评估它，是至关重要的第一步。[@problem_id:3545424]", "problem": "考虑一个在柱坐标系中的等参数轴对称四边形有限元，其径向坐标为 $r$，轴向坐标为 $z$。位移场是轴对称的（不依赖于环向角），并假设小应变张量有效。单元内部的离散运动学插值是\n$$\nu_r(r,z) = \\sum_{i=1}^{n} N_i(r,z)\\,u_{ri},\\qquad\nu_z(r,z) = \\sum_{i=1}^{n} N_i(r,z)\\,u_{zi},\n$$\n其中 $N_i$ 是形函数，$u_{ri}$ 和 $u_{zi}$ 是节点的径向和轴向位移自由度，$n$ 是节点数。设 $(r_g,z_g)$ 表示物理单元中的一个高斯点，其半径 $r_g \\ge 0$。\n\n从柱坐标系中小应变张量的定义和轴对称运动学假设出发，推导在高斯点 $(r_g,z_g)$ 处的环向（周向）应变分量 $\\varepsilon_{\\theta\\theta}$，并用 $N_i$、$u_{ri}$ 和 $r_g$ 表示。使用柱坐标系中的基本连续介质运动学和所给的位移插值仔细论证每一步。然后，讨论当 $r_g \\to 0$ 时，如何处理 $\\varepsilon_{\\theta\\theta}$ 中的表观 $1/r$ 奇点，以在坐标轴上获得一个有限且定义明确的极限，并推导相应的极限表达式，用 $N_i$ 及其关于 $r$ 的导数表示。\n\n将你的最终答案以单个符号表达式的形式给出，用于表示在 $r_g>0$ 的一般高斯点处的 $\\varepsilon_{\\theta\\theta}$。由于最终答案是符号形式，不需要四舍五入。应变是无量纲的；不要在最终答案中包含单位。", "solution": "**问题验证**\n\n**步骤 1：提取已知条件**\n- 坐标系：柱坐标系，径向坐标为 $r$，轴向坐标为 $z$。\n- 单元类型：等参数轴对称四边形有限元。\n- 运动学假设：位移场是轴对称的，不依赖于环向角。\n- 应变假设：小应变张量有效。\n- 离散运动学插值：\n  $$u_r(r,z) = \\sum_{i=1}^{n} N_i(r,z)\\,u_{ri}$$\n  $$u_z(r,z) = \\sum_{i=1}^{n} N_i(r,z)\\,u_{zi}$$\n- 定义：$N_i$ 是形函数，$u_{ri}$ 和 $u_{zi}$ 是节点的径向和轴向位移自由度，$n$ 是节点数。\n- 求值点：物理单元中的一个高斯点 $(r_g, z_g)$，其半径 $r_g \\ge 0$。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据既定准则对问题陈述进行评估。\n- **科学依据**：该问题牢固地植根于连续介质力学和有限元方法的经典理论，特别是针对轴对称分析。柱坐标系中的应变-位移关系和等参数插值的概念在计算固体力学中是标准的、被严格定义的。\n- **适定性**：该问题是适定的。它要求基于一套完整的给定定义和假设，推导一个特定量（环向应变）。问题的第二部分，关于对称轴上的奇点，是轴对称公式中一个标准且被充分理解的课题，存在一个唯一且有意义的极限值。\n- **客观性**：问题以精确、客观和定量的术语陈述。所有术语在该领域内都是标准的，没有歧义或主观解释。\n\n该问题没有表现出任何导致其无效的缺陷。它在科学上是合理的，结构上是形式化的，内容是完整的，并在其指定领域内提出了一个有意义的问题。\n\n**步骤 3：结论与行动**\n该问题有效。将提供一个完整的、有理有据的解答。\n\n**解答推导**\n\n目标是推导在高斯点 $(r_g, z_g)$ 处的环向（周向）应变分量 $\\varepsilon_{\\theta\\theta}$ 的表达式，并分析当径向坐标趋近于零时其行为。\n\n首先，我们回顾柱坐标系 $(r, \\theta, z)$ 中的小应变张量分量。位移向量为 $\\mathbf{u} = u_r(r,z) \\mathbf{e}_r + u_z(r,z) \\mathbf{e}_z$，其中轴对称假设意味着位移不依赖于环向坐标 $\\theta$，且环向位移分量 $u_\\theta$ 为零。应变-位移关系由下式给出：\n$$ \\varepsilon_{rr} = \\frac{\\partial u_r}{\\partial r} $$\n$$ \\varepsilon_{zz} = \\frac{\\partial u_z}{\\partial z} $$\n$$ \\varepsilon_{\\theta\\theta} = \\frac{1}{r}\\frac{\\partial u_\\theta}{\\partial \\theta} + \\frac{u_r}{r} $$\n$$ \\varepsilon_{rz} = \\gamma_{rz} = \\frac{1}{2}\\left( \\frac{\\partial u_r}{\\partial z} + \\frac{\\partial u_z}{\\partial r} \\right) $$\n由于轴对称假设（$u_\\theta=0$ 和 $\\partial/\\partial\\theta=0$），其他剪切应变分量 $\\varepsilon_{r\\theta}$ 和 $\\varepsilon_{z\\theta}$ 为零。\n\n我们关心的是环向应变 $\\varepsilon_{\\theta\\theta}$。其通用表达式为 $\\varepsilon_{\\theta\\theta} = \\frac{1}{r}\\frac{\\partial u_\\theta}{\\partial \\theta} + \\frac{u_r}{r}$。应用轴对称假设，环向位移 $u_\\theta$ 为零。因此，其关于 $\\theta$ 的导数也为零。这将环向应变的表达式简化为：\n$$ \\varepsilon_{\\theta\\theta} = \\frac{u_r}{r} $$\n该方程表达了轴对称问题中的一个基本运动学关系：某一点的环向应变等于该点的径向位移除以其径向坐标。\n\n接下来，我们引入径向位移 $u_r$ 的有限元离散化。如问题陈述中所给，单元内的位移是通过形函数 $N_i$ 从节点位移插值得到的：\n$$ u_r(r,z) = \\sum_{i=1}^{n} N_i(r,z)\\,u_{ri} $$\n其中 $n$ 是单元中的节点数，$u_{ri}$ 是径向位移的节点值，$N_i(r,z)$ 是形函数。\n\n为了求出指定高斯点 $(r_g, z_g)$ 处的环向应变，我们将插值位移场代入 $\\varepsilon_{\\theta\\theta}$ 的运动学关系式，并在此点求值。假设 $r_g > 0$，我们有：\n$$ \\varepsilon_{\\theta\\theta}(r_g, z_g) = \\frac{u_r(r_g, z_g)}{r_g} $$\n代入 $u_r(r_g, z_g)$ 的表达式：\n$$ \\varepsilon_{\\theta\\theta}(r_g, z_g) = \\frac{1}{r_g} \\left( \\sum_{i=1}^{n} N_i(r_g, z_g)\\,u_{ri} \\right) $$\n这就是在半径不为零的一般点 $(r_g, z_g)$ 处环向应变的表达式。\n\n现在，我们处理问题的第二部分：当 $r_g \\to 0$ 时的行为。表达式 $\\varepsilon_{\\theta\\theta} = u_r/r$ 在 $r=0$ 处有一个表观奇点。然而，物理连续性要求旋转轴上（$r=0$）的点不能有非零的径向位移，因为这会产生空洞或材料自穿透。因此，存在一个物理约束：\n$$ u_r(0, z) = 0 \\quad \\text{对于所有 } z $$\n在有限元模型的背景下，这意味着对于任何在对称轴上有节点的单元，这些特定节点 $i$ 的径向位移自由度 $u_{ri}$ 必须被约束为零。有了这个约束，插值径向位移 $u_r(r,z)$ 在 $r \\to 0$ 时趋近于零。\n\n因此，当 $r \\to 0$ 时，$\\varepsilon_{\\theta\\theta}$ 的极限变成 $0/0$ 型的不定式：\n$$ \\lim_{r \\to 0} \\varepsilon_{\\theta\\theta}(r, z) = \\lim_{r \\to 0} \\frac{u_r(r, z)}{r} $$\n我们可以使用洛必达法则来计算这个极限，即对分子和分母分别关于 $r$ 求导：\n$$ \\lim_{r \\to 0} \\frac{u_r(r, z)}{r} = \\lim_{r \\to 0} \\frac{\\frac{\\partial u_r}{\\partial r}(r,z)}{\\frac{\\partial r}{\\partial r}} = \\lim_{r \\to 0} \\frac{\\partial u_r}{\\partial r}(r,z) = \\frac{\\partial u_r}{\\partial r}\\bigg|_{r=0} $$\n从应变-位移关系中，我们认识到 $\\frac{\\partial u_r}{\\partial r}$ 是径向应变分量 $\\varepsilon_{rr}$。因此，在对称轴上，环向应变等于径向应变：\n$$ \\varepsilon_{\\theta\\theta}(0, z) = \\varepsilon_{rr}(0, z) $$\n这是对称轴上应变协调性的一个必要条件。\n\n为了找到用有限元量表示的极限表达式，我们首先计算插值位移场关于 $r$ 的导数：\n$$ \\frac{\\partial u_r}{\\partial r}(r,z) = \\frac{\\partial}{\\partial r} \\left( \\sum_{i=1}^{n} N_i(r,z)\\,u_{ri} \\right) = \\sum_{i=1}^{n} \\frac{\\partial N_i}{\\partial r}(r,z)\\,u_{ri} $$\n在对称轴上的一点 $(0, z_g)$ 处计算该表达式，得到环向应变的极限值：\n$$ \\lim_{r_g \\to 0} \\varepsilon_{\\theta\\theta}(r_g, z_g) = \\left( \\sum_{i=1}^{n} \\frac{\\partial N_i}{\\partial r}(r,z)\\,u_{ri} \\right)\\bigg|_{(r=0, z=z_g)} = \\sum_{i=1}^{n} \\frac{\\partial N_i}{\\partial r}(0, z_g)\\,u_{ri} $$\n这个表达式是有限且定义明确的，解决了表观奇点问题。对于正好位于轴上的高斯点的实际计算，使用后一个公式。对于任何 $r_g > 0$ 的高斯点，使用前一个表达式。\n\n问题要求的是在 $r_g > 0$ 的一般高斯点处 $\\varepsilon_{\\theta\\theta}$ 的单个符号表达式。这对应于我们推导的第一部分。", "answer": "$$\n\\boxed{\\frac{1}{r_g} \\sum_{i=1}^{n} N_i(r_g, z_g)\\,u_{ri}}\n$$", "id": "3545424"}, {"introduction": "在理论基础之上，本实践转向了实现与验证。你将设计并实现一个“补丁测试”(patch test)，这是有限元分析中的一个标准程序，用以确保单元能够准确表示基本的变形状态。此练习将要求你从第一性原理出发编写一个轴对称单元，并验证其再现恒定静水应力状态的能力，该测试至关重要地涉及到环向应变的正确构建。[@problem_id:3502235]", "problem": "您的任务是在有限元法（FEM）框架内，从头开始依据小应变运动学和各向同性线弹性的基本原理，设计并实现一个针对轴对称双线性四边形单元的环形贴片检验程序。其目标是施加一个恒定的静水压应力状态，其中径向、环向和轴向正应力相等，而剪应力为零。具体而言，目标应力场是一个满足 $\\sigma_{rr}=\\sigma_{\\theta\\theta}=\\sigma_{zz}=c$ 和 $\\sigma_{rz}=0$ 的恒定应力场，并验证在线性位移场 $u_r(r)$ 和 $u_z(z)$ 下，轴对称公式能正确再现非零的环向应变 $\\epsilon_{\\theta\\theta}=u_r/r$。\n\n请使用小应变轴对称框架，从应变和平衡的定义出发进行推导，不可使用简化公式。位移场必须选择为在径向和轴向坐标上呈线性，即 $u_r(r)=\\alpha\\,r$ 和 $u_z(z)=\\alpha\\,z$。其中，常数 $\\alpha$ 需要被推导出来，以使得产生的应力状态为指定的恒定值 $c$（单位为帕斯卡）。请从各向同性线弹性（Hooke定律）关系式中，通过体积模量和体积应变来表达静水压应力状态，从而明确推导出 $\\alpha$，确保 $\\sigma_{rr}=\\sigma_{\\theta\\theta}=\\sigma_{zz}=c$ 和 $\\sigma_{rz}=0$。\n\n请为一个内径为 $a$、外径为 $b$，轴向坐标范围从 $z=0$ 到 $z=H$ 的单个双线性四边形环单元实现轴对称应变-位移映射。该单元的四个节点按顺序为 $(a,0)$、$(b,0)$、$(b,H)$、$(a,H)$。在自然坐标域 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ 上使用标准的等参双线性形函数，并采用 $2\\times 2$ 高斯积分（高斯点位于 $\\xi,\\eta=\\pm 1/\\sqrt{3}$）计算高斯点处的应变分量。\n\n从基本原理出发：\n- 使用小应变轴对称定义，通过应变-位移矩阵（该矩阵包含用于计算环向应变 $\\epsilon_{\\theta\\theta}=u_r/r$ 的 $1/r$ 项）从节点位移计算应变 $\\epsilon_{rr}$、$\\epsilon_{zz}$、$\\epsilon_{\\theta\\theta}$ 和 $\\gamma_{rz}$。\n- 使用各向同性线弹性本构律，从应变分量计算相应的应力 $\\sigma_{rr}$、$\\sigma_{zz}$、$\\sigma_{\\theta\\theta}$ 和 $\\sigma_{rz}$。该本构律需使用由Hooke定律推导出的Lamé参数或等效的弹性模量和泊松比来表示，不得直接套用已知的单元公式。\n\n每个高斯点的验证标准必须包括：\n- $\\sigma_{rr}$、$\\sigma_{\\theta\\theta}$ 和 $\\sigma_{zz}$ 在数值容差范围内均等于 $c$。\n- $\\sigma_{rz}$ 在数值容差范围内等于 $0$。\n- $\\epsilon_{\\theta\\theta}$ 在数值容差范围内等于标量 $\\alpha$。\n- $\\gamma_{rz}$ 在数值容差范围内等于 $0$。\n\n请使用以下参数集测试套件来评估您的实现。半径和高度的单位必须为米，模量的单位为帕斯卡，目标应力 $c$ 的单位为帕斯卡。在每种情况下，推导出 $\\alpha$，将位移场应用于单元节点，然后计算所有四个高斯点处的应变和应力：\n1. $E=100{,}000{,}000$ Pa, $\\nu=0.25$, $a=0.5$ m, $b=1.0$ m, $H=1.0$ m, $c=1{,}200{,}000$ Pa.\n2. $E=10{,}000{,}000$ Pa, $\\nu=0.499$, $a=0.5$ m, $b=1.0$ m, $H=1.0$ m, $c=50{,}000$ Pa.\n3. $E=200{,}000{,}000$ Pa, $\\nu=0.30$, $a=0.9$ m, $b=1.0$ m, $H=0.2$ m, $c=200{,}000$ Pa.\n4. $E=50{,}000{,}000$ Pa, $\\nu=0.33$, $a=0.01$ m, $b=0.21$ m, $H=0.3$ m, $c=100{,}000$ Pa.\n5. $E=150{,}000{,}000$ Pa, $\\nu=0.27$, $a=0.4$ m, $b=0.8$ m, $H=0.5$ m, $c=-100{,}000$ Pa.\n\n您的程序必须：\n- 计算每个高斯点处的应变和应力分量。\n- 对每个测试用例，在所有高斯点上验证上述条件，容差定义如下：\n  - 对于应力，绝对容差为 $\\tau_\\sigma = 10^{-9}\\cdot\\max(1,|c|)$。\n  - 对于应变，绝对容差为 $\\tau_\\epsilon = 10^{-9}\\cdot\\max(1,|\\alpha|)$。\n- 生成单行输出，其中包含五个测试用例的通过/失败结果，格式为一个由方括号包围的、逗号分隔的布尔值列表，例如 $[\\mathrm{True},\\mathrm{False},\\dots]$。\n\n所有物理量必须使用指定的单位处理，本问题不涉及角度。最终输出为布尔值，因此无单位。推导和实现必须从头开始，基于小应变轴对称运动学和各向同性线弹性的基本定义，并且必须在单元运动学中包含环向应变贡献 $\\epsilon_{\\theta\\theta}=u_r/r$。", "solution": "该问题陈述是计算固体力学领域内一个有效且适定的验证任务。它要求实现一个针对4节点双线性轴对称单元的贴片检验，以确认其能够再现一个恒定的静水压应力状态。所有必需的物理和几何参数以及验证标准均已提供。该问题在科学上是合理的，并且在算法上是可形式化的。\n\n求解过程分为三个主要阶段：\n1.  推导实现目标静水压应力状态所需的运动学常数 $\\alpha$。\n2.  从基本原理出发，列式构建轴对称双线性四边形单元，包括应变-位移关系和本构关系。\n3.  算法实现贴片检验，在各高斯积分点上评估应变和应力，并将其与理论值进行比较。\n\n**1. 运动学常数 $\\alpha$ 的推导**\n\n问题规定了一个线性位移场，$u_r(r) = \\alpha r$ 和 $u_z(z) = \\alpha z$。必须确定常数 $\\alpha$，使得该位移场能够产生目标静水压应力状态：$\\sigma_{rr} = \\sigma_{\\theta\\theta} = \\sigma_{zz} = c$ 和 $\\sigma_{rz} = 0$。\n\n首先，我们使用小应变轴对称运动学关系，根据给定的位移场计算应变分量：\n应变分量定义为：\n$\\epsilon_{rr} = \\frac{\\partial u_r}{\\partial r}$\n$\\epsilon_{zz} = \\frac{\\partial u_z}{\\partial z}$\n$\\epsilon_{\\theta\\theta} = \\frac{u_r}{r}$\n$\\gamma_{rz} = \\frac{\\partial u_r}{\\partial z} + \\frac{\\partial u_z}{\\partial r}$\n\n代入规定的位移场：\n$\\epsilon_{rr} = \\frac{\\partial (\\alpha r)}{\\partial r} = \\alpha$\n$\\epsilon_{zz} = \\frac{\\partial (\\alpha z)}{\\partial z} = \\alpha$\n$\\epsilon_{\\theta\\theta} = \\frac{\\alpha r}{r} = \\alpha$\n$\\gamma_{rz} = \\frac{\\partial (\\alpha r)}{\\partial z} + \\frac{\\partial (\\alpha z)}{\\partial r} = 0 + 0 = 0$\n\n因此，该位移场对应一个恒定的应变状态，其中三个正应变均等于 $\\alpha$，剪应变为零。体积应变 $\\epsilon_v$ 是正应变之和：\n$\\epsilon_v = \\epsilon_{rr} + \\epsilon_{zz} + \\epsilon_{\\theta\\theta} = \\alpha + \\alpha + \\alpha = 3\\alpha$\n\n应力状态是静水压状态，其平均应力为 $p$：\n$p = \\frac{\\sigma_{rr} + \\sigma_{zz} + \\sigma_{\\theta\\theta}}{3} = \\frac{c + c + c}{3} = c$\n\n对于各向同性线弹性材料，平均应力通过体积模量 $K$ 与体积应变相关联：\n$p = K \\epsilon_v$\n\n体积模量 $K$ 与杨氏模量 $E$ 和泊松比 $\\nu$ 的关系为：\n$K = \\frac{E}{3(1 - 2\\nu)}$\n\n代入 $p$、$\\epsilon_v$ 和 $K$ 的表达式：\n$c = \\left(\\frac{E}{3(1 - 2\\nu)}\\right) (3\\alpha)$\n$c = \\frac{E\\alpha}{1 - 2\\nu}$\n\n求解未知常数 $\\alpha$ 得到所需的关系式：\n$\\alpha = c \\frac{1 - 2\\nu}{E}$\n\n该推导证实了所规定的位移场确实是在各向同性线弹性材料中产生目标静水压应力状态的正确位移场。\n\n**2. 轴对称有限元列式**\n\n贴片检验在单个4节点双线性等参单元上执行。\n单元节点按逆时针顺序排列：$1: (a, 0)$，$2: (b, 0)$，$3: (b, H)$，$4: (a, H)$。\n\n单元内的位移场 $\\{u_r(r, z), u_z(r, z)\\}$ 是通过在自然坐标系 $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$ 中使用双线性形函数 $N_i(\\xi, \\eta)$ 从节点位移 $\\mathbf{d} = [u_{r1}, u_{z1}, u_{r2}, u_{z2}, u_{r3}, u_{z3}, u_{r4}, u_{z4}]^T$ 插值得到的：\n$u_r(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_{ri}$\n$u_z(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_{zi}$\n其中 $N_1 = \\frac{1}{4}(1-\\xi)(1-\\eta)$，$N_2 = \\frac{1}{4}(1+\\xi)(1-\\eta)$，$N_3 = \\frac{1}{4}(1+\\xi)(1+\\eta)$，$N_4 = \\frac{1}{4}(1-\\xi)(1+\\eta)$。\n\n节点位移通过在节点处评估理论位移场来确定：\n$u_{r1} = \\alpha a, u_{z1} = 0$；$u_{r2} = \\alpha b, u_{z2} = 0$；$u_{r3} = \\alpha b, u_{z3} = \\alpha H$；$u_{r4} = \\alpha a, u_{z4} = \\alpha H$。\n\n为了计算应变，我们需要位移相对于全局坐标 $(r, z)$ 的导数，这通过链式法则获得：\n$$\n\\begin{Bmatrix} \\frac{\\partial f}{\\partial r} \\\\ \\frac{\\partial f}{\\partial z} \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\frac{\\partial f}{\\partial \\xi} \\\\ \\frac{\\partial f}{\\partial \\eta} \\end{Bmatrix}\n$$\n其中 $\\mathbf{J}$ 是坐标映射 $r(\\xi, \\eta) = \\sum N_i r_i$ 和 $z(\\xi, \\eta) = \\sum N_i z_i$ 的雅可比矩阵：\n$$\n\\mathbf{J} = \\begin{bmatrix} \\frac{\\partial r}{\\partial \\xi}  \\frac{\\partial z}{\\partial \\xi} \\\\ \\frac{\\partial r}{\\partial \\eta}  \\frac{\\partial z}{\\partial \\eta} \\end{bmatrix} = \\begin{bmatrix} \\sum \\frac{\\partial N_i}{\\partial \\xi} r_i  \\sum \\frac{\\partial N_i}{\\partial \\xi} z_i \\\\ \\sum \\frac{\\partial N_i}{\\partial \\eta} r_i  \\sum \\frac{\\partial N_i}{\\partial \\eta} z_i \\end{bmatrix}\n$$\n轴对称应变向量 $\\boldsymbol{\\epsilon} = [\\epsilon_{rr}, \\epsilon_{zz}, \\epsilon_{\\theta\\theta}, \\gamma_{rz}]^T$ 通过应变-位移矩阵 $\\mathbf{B}$ 与节点位移相关联：$\\boldsymbol{\\epsilon} = \\mathbf{B}\\mathbf{d}$。矩阵 $\\mathbf{B}$ 由形函数的导数和径向位置 $r$ 构成：\n$$\n\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4], \\quad \\text{其中} \\quad \\mathbf{B}_i = \\begin{bmatrix}\n\\frac{\\partial N_i}{\\partial r}  0 \\\\\n0  \\frac{\\partial N_i}{\\partial z} \\\\\n\\frac{N_i}{r}  0 \\\\\n\\frac{\\partial N_i}{\\partial z}  \\frac{\\partial N_i}{\\partial r}\n\\end{bmatrix}\n$$\n请注意第三行中的 $N_i/r$ 项，这是轴对称公式所特有的，源于环向应变 $\\epsilon_{\\theta\\theta} = u_r/r$。该项使得 $\\mathbf{B}$ 矩阵明确地依赖于径向坐标 $r$。\n\n应力 $\\boldsymbol{\\sigma} = [\\sigma_{rr}, \\sigma_{zz}, \\sigma_{\\theta\\theta}, \\sigma_{rz}]^T$ 是使用各向同性线弹性本构矩阵 $\\mathbf{D}$ 从应变计算得出的。根据广义Hooke定律 $\\sigma_{ij} = 2G\\epsilon_{ij} + \\lambda \\epsilon_{kk}\\delta_{ij}$（其中 $\\lambda$ 和 $G$ 是Lamé参数），我们可以推导出轴对称情况下的本构矩阵：\n$$\n\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\epsilon}\n$$\n$$\n\\mathbf{D} = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{bmatrix}\n1-\\nu  \\nu  \\nu  0 \\\\\n\\nu  1-\\nu  \\nu  0 \\\\\n\\nu  \\nu  1-\\nu  0 \\\\\n0  0  0  \\frac{1-2\\nu}{2}\n\\end{bmatrix}\n$$\n\n**3. 算法验证流程**\n\n贴片检验旨在确认数值列式能否正确地再现理论解。该过程涉及在单元内的 $2 \\times 2$ 高斯积分点上评估应变和应力，并与预期的恒定值进行核对。\n\n对于由 $\\{E, \\nu, a, b, H, c\\}$ 定义的每个测试用例：\n1.  计算理论运动学常数 $\\alpha = c(1-2\\nu)/E$。\n2.  确定角点为 $(a,0), (b,0), (b,H), (a,H)$ 的单元的节点位移 $\\mathbf{d}$。\n3.  定义高斯积分点 $(\\xi_g, \\eta_g)$，其坐标为 $\\xi_g, \\eta_g = \\pm 1/\\sqrt{3}$。\n4.  对每个高斯点：\n    a. 评估形函数 $N_i$ 及其相对于自然坐标的导数 $\\partial N_i/\\partial \\xi$ 和 $\\partial N_i/\\partial \\eta$。\n    b. 在该高斯点计算雅可比矩阵 $\\mathbf{J}$ 及其逆矩阵 $\\mathbf{J}^{-1}$。\n    c. 使用 $\\mathbf{J}^{-1}$ 求得形函数相对于全局坐标的导数 $\\partial N_i/\\partial r$ 和 $\\partial N_i/\\partial z$。\n    d. 确定高斯点的全局径向坐标 $r_g$。\n    e. 使用在 $(r_g, z_g)$ 处的值组装应变-位移矩阵 $\\mathbf{B}$。\n    f. 计算高斯点处的应变向量：$\\boldsymbol{\\epsilon}_g = \\mathbf{B}(r_g, z_g) \\mathbf{d}$。\n    g. 计算高斯点处的应力向量：$\\boldsymbol{\\sigma}_g = \\mathbf{D} \\boldsymbol{\\epsilon}_g$。\n5.  将计算值与理论解进行验证：\n    - $\\sigma_{rr,g}, \\sigma_{zz,g}, \\sigma_{\\theta\\theta,g}$ 必须在容差 $\\tau_\\sigma = 10^{-9} \\cdot \\max(1, |c|)$ 内等于 $c$。\n    - $\\sigma_{rz,g}$ 必须在容差 $\\tau_\\sigma$ 内等于 $0$。\n    - $\\epsilon_{\\theta\\theta,g}$ 必须在容差 $\\tau_\\epsilon = 10^{-9} \\cdot \\max(1, |\\alpha|)$ 内等于 $\\alpha$。\n    - $\\gamma_{rz,g}$ 必须在容差 $\\tau_\\epsilon$ 内等于 $0$。\n6.  如果所有四个高斯点的所有检查都通过，则该测试用例的贴片检验成功。\n\n由于规定的位移场在 $r$ 和 $z$ 上是线性的，并且双线性单元在矩形域上可以完美表示任何形式为 $f(r,z) = c_1 + c_2 r + c_3 z + c_4 rz$ 的函数，因此单元内的插值位移场将与理论场完全匹配。因此，数值计算出的应变和应力应在机器精度范围内与理论恒定值相匹配。所以，预计所有给定的测试用例都将通过测试。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_patch_test(E, nu, a, b, H, c):\n    \"\"\"\n    Performs a ring patch test for a single axisymmetric bilinear element.\n\n    Args:\n        E (float): Young's modulus in Pascals.\n        nu (float): Poisson's ratio.\n        a (float): Inner radius in meters.\n        b (float): Outer radius in meters.\n        H (float): Element height in meters.\n        c (float): Target hydrostatic stress in Pascals.\n\n    Returns:\n        bool: True if the test passes, False otherwise.\n    \"\"\"\n\n    # 1. Derive theoretical kinematic constant alpha\n    # For a hydrostatic stress state, c = E*alpha / (1 - 2*nu)\n    if abs(1 - 2 * nu)  1e-15:\n        # For nu=0.5, a finite stress c requires infinite volumetric strain, unless c=0.\n        # This parameter set is not expected. But handle gracefully.\n        alpha = 0.0 if c == 0.0 else float('inf')\n    else:\n        alpha = c * (1 - 2 * nu) / E\n\n    # 2. Define element geometry and nodal displacements\n    # Nodal coordinates: Node 1 to 4, counter-clockwise\n    node_coords = np.array([\n        [a, 0.],  # Node 1\n        [b, 0.],  # Node 2\n        [b, H],   # Node 3\n        [a, H]    # Node 4\n    ])\n\n    # Nodal displacements from u_r = alpha*r, u_z = alpha*z\n    # DOF vector: [u_r1, u_z1, u_r2, u_z2, u_r3, u_z3, u_r4, u_z4]\n    dof_vals = np.array([\n        alpha * a, 0.,          # Node 1\n        alpha * b, 0.,          # Node 2\n        alpha * b, alpha * H,   # Node 3\n        alpha * a, alpha * H    # Node 4\n    ])\n\n    # 3. Define constitutive matrix D for axisymmetric case\n    factor = E / ((1 + nu) * (1 - 2 * nu))\n    D_matrix = factor * np.array([\n        [1 - nu, nu,     nu,     0],\n        [nu,     1 - nu, nu,     0],\n        [nu,     nu,     1 - nu, 0],\n        [0,      0,      0,      (1 - 2 * nu) / 2]\n    ])\n\n    # 4. Gauss quadrature points for 2x2 scheme\n    gp_val = 1 / np.sqrt(3)\n    gauss_points = [\n        (-gp_val, -gp_val), (gp_val, -gp_val),\n        (gp_val, gp_val),   (-gp_val, gp_val)\n    ]\n\n    # Verification tolerances\n    tol_stress = 1e-9 * max(1, abs(c))\n    tol_strain = 1e-9 * max(1, abs(alpha))\n\n    # 5. Loop over Gauss points to compute strains and stresses\n    for xi, eta in gauss_points:\n        # Shape functions N at (xi, eta)\n        N_vec = 0.25 * np.array([\n            (1 - xi) * (1 - eta),\n            (1 + xi) * (1 - eta),\n            (1 + xi) * (1 + eta),\n            (1 - xi) * (1 + eta)\n        ])\n\n        # Derivatives of shape functions w.r.t. natural coordinates (xi, eta)\n        grad_N_nat = 0.25 * np.array([\n            [-(1 - eta),  (1 - eta),  (1 + eta), -(1 + eta)],  # dN/dxi\n            [-(1 - xi),  -(1 + xi),   (1 + xi),   (1 - xi)]   # dN/deta\n        ])\n\n        # Jacobian matrix J = d(r,z)/d(xi,eta)\n        J_matrix = grad_N_nat @ node_coords\n        \n        if abs(np.linalg.det(J_matrix))  1e-15:\n            return False  # Degenerate element\n\n        J_inv = np.linalg.inv(J_matrix)\n\n        # Derivatives of shape functions w.r.t. global coordinates (r, z)\n        grad_N_glob = J_inv @ grad_N_nat\n\n        # Coordinates (r, z) of the Gauss point\n        r_gp, z_gp = N_vec @ node_coords\n\n        # Construct strain-displacement matrix B for axisymmetric element\n        B_matrix = np.zeros((4, 8))\n        for i in range(4):\n            dNi_dr = grad_N_glob[0, i]\n            dNi_dz = grad_N_glob[1, i]\n            Ni = N_vec[i]\n            \n            # Strain components [eps_rr, eps_zz, eps_thetatheta, gamma_rz]\n            B_matrix[0, 2 * i] = dNi_dr\n            B_matrix[1, 2 * i + 1] = dNi_dz\n            B_matrix[2, 2 * i] = Ni / r_gp\n            B_matrix[3, 2 * i] = dNi_dz\n            B_matrix[3, 2 * i + 1] = dNi_dr\n\n        # Calculate strain and stress vectors at the Gauss point\n        epsilon = B_matrix @ dof_vals\n        sigma = D_matrix @ epsilon\n\n        # 6. Verification checks\n        # Stresses: sig_rr, sig_zz, sig_thetatheta should be c; sig_rz should be 0.\n        if not np.allclose(sigma[:3], c, atol=tol_stress, rtol=0):\n            return False\n        if not np.allclose(sigma[3], 0, atol=tol_stress, rtol=0):\n            return False\n        \n        # Strains: eps_thetatheta should be alpha; gamma_rz should be 0.\n        if not np.allclose(epsilon[2], alpha, atol=tol_strain, rtol=0):\n            return False\n        if not np.allclose(epsilon[3], 0, atol=tol_strain, rtol=0):\n            return False\n\n    return True\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (E, nu, a, b, H, c)\n        (100_000_000, 0.25, 0.5, 1.0, 1.0, 1_200_000),\n        (10_000_000, 0.499, 0.5, 1.0, 1.0, 50_000),\n        (200_000_000, 0.30, 0.9, 1.0, 0.2, 200_000),\n        (50_000_000, 0.33, 0.01, 0.21, 0.3, 100_000),\n        (150_000_000, 0.27, 0.4, 0.8, 0.5, -100_000),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_patch_test(*case)\n        results.append(str(result))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3502235"}, {"introduction": "这最后一项实践深入探讨了一个直接源于第一项实践所探讨理论的进阶数值挑战。当单元非常靠近对称轴时，应变公式中的 $\\frac{1}{r}$ 项可能导致刚度矩阵的数值病态。本练习要求你通过比较不同的网格划分策略来研究此现象，并量化矩阵的条件数，从而深入了解构建稳健的轴对称有限元模型的实际问题。[@problem_id:3545417]", "problem": "在此题目中，您需要在一个计算固体力学问题中，实现并比较邻近对称轴的两种轴对称子午面网格拓扑，并量化当最小半径趋近于轴时，组装后的刚度矩阵的数值条件。推导必须从第一性原理出发，并对四节点双线性等参四边形单元使用一致的轴对称公式。比较应考虑楔形网格（节点位于轴上）和矩形网格（以一个严格为正的最小半径偏移）。您还必须实现一种映射策略，以避免在半径非常小时环向应变项中出现塌陷。\n\n必须使用的基本理论基础包括以下内容，不提供任何简化公式：\n- 适用于连续介质的牛顿运动定律，以及关联内部虚功与外部虚功的虚功原理。\n- 轴对称情况下的微应变运动学，其中位移是子午面坐标的函数，且与周向坐标无关，环向应变根据轴对称性进行一致性定义。\n- 三维各向同性线弹性（胡克定律）在轴对称条件下的特化，从杨氏模量和泊松比引入拉梅参数。\n- 四边形单元的等参映射、母坐标与物理坐标之间的雅可比变换，以及用于数值积分的高斯求积。\n\n您的程序必须：\n1. 在 $r$-$z$ 平面上构建具有相同轴向范围的两种双单元子午面网格。每个单元都是一个四节点双线性四边形。一个网格是邻近轴的楔形网格，其左侧节点列的 $r=0$。另一个是矩形网格，并从轴上偏移，使其左侧节点列的 $r=r_{\\min}>0$。\n2. 使用一致的双线性等参单元公式组装全局轴对称刚度矩阵。应变-位移矩阵必须包括径向、轴向、环向和剪切分量；本构关系必须是轴对称条件下的各向同性三维线弹性关系；积分权重必须按轴对称要求包含半径。积分必须在母坐标下使用 $2\\times 2$ 高斯求积。\n3. 施加本质边界条件以消除刚体模态并强制实现轴上正则性。对于楔形网格，在每个 $r=0$ 的节点处强制 $u_r=0$，并固定一个轴向位移以锚定解。对于矩形网格，固定一个角节点的两个位移分量以消除刚体平移。\n4. 对每个测试案例，使用 $2$-范数定义计算简化刚度矩阵（通过消除受约束的自由度来施加边界条件后）的条件数，并以无单位浮点数的形式返回结果。\n5. 实现两种映射策略来评估环向应变和轴对称积分权重中的半径：一种是标准的等参半径计算，另一种是受保护的半径下限映射，其中在这些项中使用的有效半径为 $r_{\\text{eff}}=\\max(r,r_{\\text{floor}})$，并指定一个 $r_{\\text{floor}}>0$。\n\n材料和几何数据（使用以下值）：\n- 杨氏模量 $E$（单位：帕斯卡）为 $E=210\\times 10^{9}$。\n- 泊松比 $\\nu$ 为 $\\nu=0.3$。\n- 径向单元宽度 $h_r$（单位：米）为 $h_r=1.0$。\n- 轴向单元高度 $h_z$（单位：米）为 $h_z=1.0$。\n这些量用于构建有限元模型，但最终报告的条件数是无单位的。确保任何中间量都得到一致处理，并注意条件数与 $E$ 的整体缩放无关。\n\n按如下方式为两种拓扑定义子午面网格：\n- 网格有两个沿轴向堆叠的单元，共享中间一排节点。节点形成一个 $2$ 列 $3$ 行的网格。对于楔形网格，左列半径为 $r=0$，右列半径为 $r=h_r$。对于矩形网格，左列半径为 $r=r_{\\min}$，右列半径为 $r=r_{\\min}+h_r$。各行节点的轴向坐标为 $z=0$、 $z=h_z$、 $z=2h_z$。\n- 单元由节点索引按逆时针顺序定义：左下、右下、右上、左上。\n\n边界条件：\n- 楔形网格：在每个 $r=0$ 的节点处强制 $u_r=0$，并在左下角节点处固定 $u_z=0$。\n- 矩形网格：在左下角节点处固定 $u_r=0$ 和 $u_z=0$。\n这些条件足以消除在此比较中获得适定刚度矩阵所需的刚体模态，并在楔形情况下强制实现轴上正则性。\n\n测试套件：\n- 案例 1：矩形网格， $r_{\\min}=10^{-6}\\ \\text{m}$，标准映射， $r_{\\text{floor}}=0$。\n- 案例 2：矩形网格， $r_{\\min}=10^{-3}\\ \\text{m}$，标准映射， $r_{\\text{floor}}=0$。\n- 案例 3：矩形网格， $r_{\\min}=10^{-1}\\ \\text{m}$，标准映射， $r_{\\text{floor}}=0$。\n- 案例 4：楔形网格，几何 $r_{\\min}=0\\ \\text{m}$，标准映射， $r_{\\text{floor}}=0$。\n- 案例 5：矩形网格， $r_{\\min}=10^{-6}\\ \\text{m}$，下限映射， $r_{\\text{floor}}=10^{-3}\\ \\text{m}$。\n- 案例 6：楔形网格，几何 $r_{\\min}=0\\ \\text{m}$，下限映射， $r_{\\text{floor}}=10^{-3}\\ \\text{m}$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来（例如，$[result_1,result_2,result_3]$）。每个 $result_i$ 必须是对应测试案例的简化刚度矩阵的浮点条件数。不应打印任何其他文本。这些值为无单位的浮点数。\n\n该问题要求科学真实性并从第一性原理进行推导。您必须确保您的实现与轴对称公式一致，并能处理邻近轴时的数值行为。除了为测试套件计算条件数之外，您的解决方案还应提出映射策略以避免塌陷，并根据上述基本定律和定义来论证其物理和数值意义。", "solution": "该问题经验证具有科学依据、适定性且客观。它代表了计算固体力学中关于轴对称有限元分析数值条件的一项标准研究。所有必要的数据和条件都已提供，没有矛盾或歧义。\n\n该解源于虚功原理，该原理指出，对于处于平衡状态的物体，对于任何运动学上容许的虚位移，内应力所做的虚功等于外力所做的虚功。对于连续介质，这表示为：\n$$\n\\delta W_{\\text{int}} = \\int_V \\delta\\boldsymbol{\\epsilon}^T \\boldsymbol{\\sigma} \\, dV = \\delta W_{\\text{ext}}\n$$\n在轴对称设置中，体积元为 $dV = 2\\pi r \\, dA$，其中 $A$ 是 $r$-$z$ 子午面内的面积。位移场纯粹是子午面坐标 $(r, z)$ 的函数，即 $\\mathbf{u}(r, z) = [u_r(r, z), u_z(r, z)]^T$。\n\n在小应变假设下，应变分量由向量 $\\boldsymbol{\\epsilon} = [\\epsilon_r, \\epsilon_z, \\epsilon_\\theta, \\gamma_{rz}]^T$ 给出，其中：\n$$\n\\epsilon_r = \\frac{\\partial u_r}{\\partial r}, \\quad \\epsilon_z = \\frac{\\partial u_z}{\\partial z}, \\quad \\epsilon_\\theta = \\frac{u_r}{r}, \\quad \\gamma_{rz} = \\frac{\\partial u_r}{\\partial z} + \\frac{\\partial u_z}{\\partial r}\n$$\n环向应变 $\\epsilon_\\theta$ 是轴对称的一个独特特征，并且当半径 $r$ 趋近于零时，会成为数值困难的来源。\n\n假设材料是各向同性线弹性的，遵循胡克定律 $\\boldsymbol{\\sigma} = \\mathbf{C} \\boldsymbol{\\epsilon}$，其中 $\\boldsymbol{\\sigma} = [\\sigma_r, \\sigma_z, \\sigma_\\theta, \\tau_{rz}]^T$ 是应力向量。轴对称条件下各向同性材料的本构矩阵 $\\mathbf{C}$ 为：\n$$\n\\mathbf{C} = \\frac{E}{(1+\\nu)(1-2\\nu)}\n\\begin{pmatrix}\n1-\\nu  \\nu  \\nu  0 \\\\\n\\nu  1-\\nu  \\nu  0 \\\\\n\\nu  \\nu  1-\\nu  0 \\\\\n0  0  0  \\frac{1-2\\nu}{2}\n\\end{pmatrix}\n$$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。\n\n我们采用四节点双线性等参四边形单元。单元内的几何和位移场使用母坐标系 $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$ 中的形函数 $N_i(\\xi, \\eta)$ 从节点值进行插值：\n$$\nr(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) r_i, \\quad z(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) z_i\n$$\n$$\nu_r(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_{ri}, \\quad u_z(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_{zi}\n$$\n令 $\\mathbf{d}^e$ 为单元的 8 个节点位移向量，我们可以将位移场写为 $\\mathbf{u} = \\mathbf{N}\\mathbf{d}^e$，应变场写为 $\\boldsymbol{\\epsilon} = \\mathbf{B}\\mathbf{d}^e$。应变-位移矩阵 $\\mathbf{B}$ 由应变定义和等参插值推导得出。对于节点 $i$，其对 $\\mathbf{B}$ 的贡献是一个 $4 \\times 2$ 的子矩阵 $\\mathbf{B}_i$：\n$$\n\\mathbf{B}_i(\\xi, \\eta) = \\begin{pmatrix}\n\\frac{\\partial N_i}{\\partial r}  0 \\\\\n0  \\frac{\\partial N_i}{\\partial z} \\\\\n\\frac{N_i}{r}  0 \\\\\n\\frac{\\partial N_i}{\\partial z}  \\frac{\\partial N_i}{\\partial r}\n\\end{pmatrix}\n$$\n形函数的空间导数通过坐标变换的雅可比矩阵 $\\mathbf{J}$ 求得，其中 $\\left[\\frac{\\partial N_i}{\\partial r}, \\frac{\\partial N_i}{\\partial z}\\right]^T = \\mathbf{J}^{-T} \\left[\\frac{\\partial N_i}{\\partial \\xi}, \\frac{\\partial N_i}{\\partial \\eta}\\right]^T$。\n\n将有限元近似代入虚功原理，得到离散系统 $\\mathbf{K}\\mathbf{d} = \\mathbf{F}_{\\text{ext}}$，其中全局刚度矩阵 $\\mathbf{K}$ 由单元刚度矩阵 $\\mathbf{k}^e$ 组装而成：\n$$\n\\mathbf{k}^e = \\int_{A_e} \\mathbf{B}^T \\mathbf{C} \\mathbf{B} \\, (2\\pi r) \\, dA = \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{B}^T(\\xi, \\eta) \\mathbf{C} \\mathbf{B}(\\xi, \\eta) \\, (2\\pi r(\\xi, \\eta)) \\, \\det(\\mathbf{J}) \\, d\\xi \\, d\\eta\n$$\n该积分使用 $2 \\times 2$ 高斯求积进行数值计算。\n\n数值挑战源于 $\\mathbf{B}$ 矩阵中环向应变分量的 $1/r$ 项。当单元接近对称轴（$r \\to 0$）时，此项可能变得非常大。在 $\\mathbf{k}^e$ 的积分中，这个大项与变得非常小的积分权重因子 $r$ 相乘。一个非常大的项和一个非常小的项的乘积 $\\mathbf{B}^T \\mathbf{C} \\mathbf{B} \\cdot r$ 可能导致刚度矩阵的系数范围非常宽。这会导致高条件数，表明存在数值敏感性，并可能在求解中产生较大误差。\n\n为研究此问题，实现了两种评估高斯点处半径 $r$ 的策略：\n1.  **标准等参映射**：直接使用在高斯点处评估的半径 $r_g = r(\\xi_g, \\eta_g)$。对于靠近轴的情况，$r_g$ 可能非常小，导致上述的病态条件。这等效于设置一个半径下限 $r_{\\text{floor}} = 0$。\n2.  **受保护的下限映射**：引入一个最小有效半径 $r_{\\text{floor}} > 0$。在环向应变项（$1/r$）和积分权重（$2\\pi r$）中使用的有效半径为 $r_{\\text{eff}} = \\max(r_g, r_{\\text{floor}})$。该策略防止 $1/r$ 项变为奇异，并确保单元对刚度矩阵贡献一个最小的“体积”，从而对矩阵进行正则化并改善其条件数。从物理上看，它模拟的是一个薄壁管状单元而非零半径线，这可能是一种更稳定的理想化模型。\n\n全局刚度矩阵由两个单元组装而成。然后通过消除与约束自由度相对应的行和列来施加本质边界条件。对于楔形网格，轴对称条件要求轴上（$r=0$）所有节点的 $u_r = 0$。对于模拟具有小内径的厚壁圆筒的矩形网格，通过固定单个节点来消除刚体运动。然后使用 2-范数计算所得简化刚度矩阵的条件数。对每个测试案例重复此过程，以量化网格拓扑和半径映射对数值稳定性的影响。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_constitutive_matrix(E, nu):\n    \"\"\"\n    Computes the axisymmetric constitutive matrix for an isotropic material.\n    \"\"\"\n    C = np.zeros((4, 4))\n    factor = E / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    \n    C[0, 0] = factor * (1.0 - nu)\n    C[0, 1] = factor * nu\n    C[0, 2] = factor * nu\n    \n    C[1, 0] = factor * nu\n    C[1, 1] = factor * (1.0 - nu)\n    C[1, 2] = factor * nu\n    \n    C[2, 0] = factor * nu\n    C[2, 1] = factor * nu\n    C[2, 2] = factor * (1.0 - nu)\n    \n    C[3, 3] = factor * (1.0 - 2.0 * nu) / 2.0\n    \n    return C\n\ndef get_shape_functions(xi, eta):\n    \"\"\"\n    Computes shape functions and their derivatives for a 4-node quad element.\n    \"\"\"\n    N = 0.25 * np.array([\n        (1.0 - xi) * (1.0 - eta),\n        (1.0 + xi) * (1.0 - eta),\n        (1.0 + xi) * (1.0 + eta),\n        (1.0 - xi) * (1.0 + eta)\n    ])\n    \n    dN_dxi = 0.25 * np.array([\n        -(1.0 - eta),\n        (1.0 - eta),\n        (1.0 + eta),\n        -(1.0 + eta)\n    ])\n    \n    dN_deta = 0.25 * np.array([\n        -(1.0 - xi),\n        -(1.0 + xi),\n        (1.0 + xi),\n        (1.0 - xi)\n    ])\n    \n    return N, dN_dxi, dN_deta\n\ndef get_element_stiffness(node_coords, C, r_floor):\n    \"\"\"\n    Computes the stiffness matrix for a single 4-node axisymmetric element.\n    \"\"\"\n    k_e = np.zeros((8, 8))\n    gauss_points = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    gauss_weights = [1.0, 1.0]\n\n    for i, xi in enumerate(gauss_points):\n        for j, eta in enumerate(gauss_points):\n            N, dN_dxi, dN_deta = get_shape_functions(xi, eta)\n            \n            # Jacobian matrix\n            J = np.zeros((2, 2))\n            J[0, 0] = np.dot(dN_dxi, node_coords[:, 0])  # dr/dxi\n            J[0, 1] = np.dot(dN_dxi, node_coords[:, 1])  # dz/dxi\n            J[1, 0] = np.dot(dN_deta, node_coords[:, 0]) # dr/deta\n            J[1, 1] = np.dot(dN_deta, node_coords[:, 1]) # dz/deta\n            \n            det_J = np.linalg.det(J)\n            inv_J = np.linalg.inv(J)\n            \n            # Derivatives of shape functions w.r.t. physical coordinates (r, z)\n            dN_d_phys = inv_J @ np.array([dN_dxi, dN_deta])\n            dN_dr = dN_d_phys[0, :]\n            dN_dz = dN_d_phys[1, :]\n            \n            # Radius at the Gauss point\n            r_gp = np.dot(N, node_coords[:, 0])\n            \n            # Apply safeguarded radius floor mapping\n            r_eff = max(r_gp, r_floor)\n            \n            # Strain-displacement matrix B\n            B = np.zeros((4, 8))\n            for k in range(4):\n                B[0, 2*k]     = dN_dr[k]\n                B[1, 2*k+1]   = dN_dz[k]\n                if r_eff > 1e-15:  # Avoid division by zero\n                    B[2, 2*k] = N[k] / r_eff\n                B[3, 2*k]     = dN_dz[k]\n                B[3, 2*k+1]   = dN_dr[k]\n            \n            # Integrate to get stiffness matrix contribution\n            weight = gauss_weights[i] * gauss_weights[j]\n            k_e += (B.T @ C @ B) * (2.0 * np.pi * r_eff) * det_J * weight\n            \n    return k_e\n\ndef run_analysis(mesh_type, r_min, r_floor):\n    \"\"\"\n    Performs the full analysis for one test case.\n    \"\"\"\n    # 1. Define material and geometric properties\n    E = 210e9\n    nu = 0.3\n    h_r = 1.0\n    h_z = 1.0\n    C = get_constitutive_matrix(E, nu)\n\n    # 2. Define node coordinates based on mesh type\n    r_geom = 0.0 if mesh_type == 'wedge' else r_min\n    \n    nodes = np.array([\n        [r_geom, 0.0],\n        [r_geom + h_r, 0.0],\n        [r_geom, h_z],\n        [r_geom + h_r, h_z],\n        [r_geom, 2.0 * h_z],\n        [r_geom + h_r, 2.0 * h_z]\n    ])\n    num_nodes = 6\n    num_dofs = 2 * num_nodes\n\n    # 3. Define elements and DOF maps for assembly\n    # Connectivity [bottom-left, bottom-right, top-right, top-left]\n    elements = [[0, 1, 3, 2], [2, 3, 5, 4]]\n    # Maps local element DOFs to global DOFs\n    dof_maps = [\n        np.array([0, 1, 2, 3, 6, 7, 4, 5]),\n        np.array([4, 5, 6, 7, 10, 11, 8, 9])\n    ]\n\n    # 4. Assemble global stiffness matrix K\n    K = np.zeros((num_dofs, num_dofs))\n    for i, elem_node_indices in enumerate(elements):\n        elem_coords = nodes[elem_node_indices]\n        k_e = get_element_stiffness(elem_coords, C, r_floor)\n        \n        ix_map = dof_maps[i]\n        K[np.ix_(ix_map, ix_map)] += k_e\n\n    # 5. Apply Boundary Conditions by elimination\n    if mesh_type == 'wedge':\n        # ur=0 at r=0 (nodes 0, 2, 4 -> DOFs 0, 4, 8)\n        # uz=0 at node 0 (DOF 1) to remove rigid body motion\n        constrained_dofs = [0, 1, 4, 8]\n    else: # rectangular\n        # ur=0, uz=0 at node 0 (DOFs 0, 1) to remove rigid body motion\n        constrained_dofs = [0, 1]\n    \n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, constrained_dofs)\n    K_reduced = K[np.ix_(free_dofs, free_dofs)]\n    \n    # 6. Compute and return the 2-norm condition number\n    condition_number = np.linalg.cond(K_reduced, p=2)\n    return condition_number\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'type': 'rectangular', 'r_min': 1e-6, 'r_floor': 0.0},\n        {'type': 'rectangular', 'r_min': 1e-3, 'r_floor': 0.0},\n        {'type': 'rectangular', 'r_min': 1e-1, 'r_floor': 0.0},\n        {'type': 'wedge', 'r_min': 0.0, 'r_floor': 0.0},\n        {'type': 'rectangular', 'r_min': 1e-6, 'r_floor': 1e-3},\n        {'type': 'wedge', 'r_min': 0.0, 'r_floor': 1e-3},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_analysis(\n            mesh_type=case['type'],\n            r_min=case['r_min'],\n            r_floor=case['r_floor']\n        )\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.7e}' for r in results)}]\")\n\nsolve()\n```", "id": "3545417"}]}