{"hands_on_practices": [{"introduction": "要掌握复杂的概念，最好的方法往往是从最简单的模型入手。本次实践将引导你从第一性原理出发，为一个基本的杆单元推导其几何刚度矩阵。通过这个练习，你将清晰地看到，一个结构单元的刚度是如何因其内部存在的轴向力而发生变化的，这是理解应力刚化和屈曲现象的理论基石 [@problem_id:3574666]。", "problem": "一个长度为 $L$、参考横截面积为常数 $A$ 的直棱柱双节点桁架单元，经历了大的刚体转动但轴向应变很小。该单元在共旋坐标系下建模，因此在共旋局部坐标系中，唯一非零的运动学自由度是沿单元轴线的标量轴向节点位移 $u_{1}$ 和 $u_{2}$。设轴向合力为 $N$，它代表单元当前承受的内部轴向力，并假定沿单元长度是均匀的。使用虚功原理（PVW），在全拉格朗日框架下，结合格林-拉格朗日应变和第二皮奥拉-基尔霍夫应力，以及轴向位移场的线性形函数插值，推导局部轴向子空间中的初始应力（几何）刚度贡献。具体来说，从第一性原理出发，在共旋坐标系中对当前构型下的内虚功进行线性化，以获得与局部轴向节点自由度 $u_{1}$ 和 $u_{2}$ 相关的 $2 \\times 2$ 几何刚度子矩阵。\n\n您的推导必须清楚地指明初始应力贡献在线性化过程中的来源，并说明最终表达式成立的假设条件。将您的最终结果表示为一个由 $N$ 和 $L$ 构成的封闭形式的解析 $2 \\times 2$ 矩阵。不需要数值舍入。最终表达式中不要包含物理单位。", "solution": "合适的出发点是针对一维桁架在全拉格朗日框架下的虚功原理（PVW），用格林-拉格朗日应变和第二皮奥拉-基尔霍夫应力表示。对于参考横截面积为 $A$、参考坐标为 $X \\in [0,L]$ 的棱柱桁架，其内虚功为\n$$\n\\delta W_{\\text{int}} \\;=\\; \\int_{0}^{L} A\\, S\\, \\delta E \\, \\mathrm{d}X,\n$$\n其中 $S$ 是第二皮奥拉-基尔霍夫应力，$E$ 是格林-拉格朗日应变。在共旋局部坐标系中，轴向位移场通过线性形函数进行插值：\n$$\nu(X) \\;=\\; N_{1}(X)\\,u_{1} \\;+\\; N_{2}(X)\\,u_{2}, \\quad N_{1}(X) \\;=\\; 1 - \\frac{X}{L}, \\quad N_{2}(X) \\;=\\; \\frac{X}{L}.\n$$\n定义恒定的轴向位移梯度\n$$\n\\alpha \\;=\\; \\frac{\\mathrm{d}u}{\\mathrm{d}X} \\;=\\; \\frac{u_{2} - u_{1}}{L}.\n$$\n对于一维轴向变形，变形梯度为 $F = 1 + \\alpha$，格林-拉格朗日应变为\n$$\nE \\;=\\; \\frac{1}{2}\\big(F^{2} - 1\\big) \\;=\\; \\alpha \\;+\\; \\frac{1}{2}\\,\\alpha^{2}.\n$$\n其变分为\n$$\n\\delta E \\;=\\; \\frac{\\partial E}{\\partial \\alpha}\\,\\delta \\alpha \\;=\\; (1+\\alpha)\\,\\delta \\alpha, \\quad \\delta \\alpha \\;=\\; \\frac{\\mathrm{d}}{\\mathrm{d}X}(\\delta u) \\;=\\; \\frac{-\\,\\delta u_{1} + \\delta u_{2}}{L}.\n$$\n将其代入内虚功表达式，并利用对于线性插值 $\\delta \\alpha$ 在 $[0,L]$ 上为常数的性质，\n$$\n\\delta W_{\\text{int}} \\;=\\; \\int_{0}^{L} A\\,S\\,(1+\\alpha)\\,\\delta \\alpha \\,\\mathrm{d}X \\;=\\; A\\,S\\,(1+\\alpha)\\,L\\,\\delta \\alpha \\;=\\; A\\,S\\,(1+\\alpha)\\,\\big(-\\,\\delta u_{1} + \\delta u_{2}\\big).\n$$\n通过 $\\delta W_{\\text{int}} = \\delta u_{1}\\,f_{\\text{int},1} + \\delta u_{2}\\,f_{\\text{int},2}$ 识别内节点力向量 $f_{\\text{int}}$ 可得\n$$\nf_{\\text{int}} \\;=\\; A\\,S\\,(1+\\alpha)\\,\\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}.\n$$\n为了获得一致切线刚度，我们将 $f_{\\text{int}}$ 对节点位移 $(u_{1},u_{2})$ 进行线性化。线性化过程自然地分为材料部分（通过本构关系中的 $\\partial S/\\partial u_{i}$）和几何或初始应力部分（通过乘以形函数梯度的运动学因子 $(1+\\alpha)$）。初始应力刚度是通过固定当前应力 $S$（即，在方向导数中忽略 $\\partial S/\\partial u_{i}$）并仅对运动学因子 $(1+\\alpha)$ 求导得到的：\n$$\nK_{\\sigma} \\;=\\; \\frac{\\partial}{\\partial \\mathbf{u}}\\Big(A\\,S\\,(1+\\alpha)\\,\\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}\\Big)\\Big|_{S=\\text{const}} \\;=\\; A\\,S\\,\\frac{\\partial (1+\\alpha)}{\\partial \\mathbf{u}}\\,\\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}.\n$$\n当 $\\alpha = (u_{2}-u_{1})/L$ 时，$(1+\\alpha)$ 的导数为\n$$\n\\frac{\\partial (1+\\alpha)}{\\partial u_{1}} \\;=\\; -\\,\\frac{1}{L}, \\quad \\frac{\\partial (1+\\alpha)}{\\partial u_{2}} \\;=\\; \\frac{1}{L}.\n$$\n因此，\n$$\nK_{\\sigma} \\;=\\; A\\,S\\,\\frac{1}{L}\\,\\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}.\n$$\n为了用轴向合力 $N$ 来表示该式，我们注意到内节点力向量具有 $f_{\\text{int}} = \\begin{bmatrix} -N \\\\ N \\end{bmatrix}$ 的结构。与 $f_{\\text{int}} = A\\,S\\,(1+\\alpha)\\,\\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}$ 比较可知\n$$\nN \\;=\\; A\\,S\\,(1+\\alpha).\n$$\n在共旋坐标系下的小轴向应变假设下，有 $(1+\\alpha) \\approx 1$，因此 $N \\approx A\\,S$，几何刚度可以紧凑地写为\n$$\nK_{\\sigma} \\;=\\; \\frac{N}{L}\\,\\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}.\n$$\n这个 $2 \\times 2$ 子矩阵作用于局部轴向节点自由度 $(u_{1},u_{2})$。\n\n此表达式成立的条件如下：\n- 共旋坐标系消除了刚体转动，因此轴向运动学由沿单元轴线的标量位移 $u_{1}$ 和 $u_{2}$ 描述，同时允许任意大的转动但轴向应变很小，即 $|\\alpha| \\ll 1$，从而 $(1+\\alpha) \\approx 1$。\n- 轴力 $N$ 沿单元是均匀的，并被解释为当前的内部轴向合力；在小轴向应变下，$N \\approx A\\,S$。\n- 单元是直的、棱柱形的，具有恒定的参考面积 $A$，并使用线性形函数，因此轴向位移梯度是恒定的。\n- 在局部轴向子空间中没有随动荷载效应；此处不包括与外部随动荷载相关的荷载刚度。推导出的矩阵是由内部预应力 $N$ 引起的初始应力（几何）刚度。\n- 结果是局部的轴向 $2 \\times 2$ 分块矩阵；当在全局坐标系下用横向自由度组装完整的单元切线刚度时，标准的旋转变换可以恢复出在所有平动分量上分布的、人们所熟悉的几何刚度。", "answer": "$$\\boxed{\\frac{N}{L}\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}}$$", "id": "3574666"}, {"introduction": "在分别推导了初始应力刚度 $K_{\\sigma}$ 和载荷刚度 $K_L$ 之后，理解它们在非线性分析中的实际影响至关重要。最后一个练习将通过一个简化的数值模型进行一场“思想实验”。通过在求解器中有选择地包含或排除这些刚度项，我们可以直观地观察到它们在保证解的稳定性和收敛性方面所扮演的独特角色 [@problem_id:3574659]。", "problem": "实现一个小型、自包含的数值实验，以在一个降阶、无量纲的结构模型中，隔离和比较材料刚度、初始应力（几何）刚度和载荷刚度在非线性求解过程中的作用。在无量纲变量下工作，这样就不需要进行物理单位转换。你的程序必须是一个完整的、可运行的程序，它使用牛顿法组装并求解增量载荷步，并带有用户可控的开关，用于在求解器使用的切线矩阵中包含或排除初始应力刚度和载荷刚度（同时保持“真实”残差固定）。目标是凭经验分离切线矩阵三个部分对收敛性和稳定性的作用。\n\n从以下基于原理的对象开始，这些对象在问题中未经推导直接给出，但需要在你的解答中证明其合理性：\n\n- 该模型有一个降阶状态向量 $u \\in \\mathbb{R}^2$。\n- 在参考构型邻域内的内力线性化可加性地分解为材料刚度、由轴向预应力参数 $N \\ge 0$ 缩放的初始应力（几何）刚度，以及由随动载荷参数 $P \\ge 0$ 缩放的载荷刚度之和。因此，对于每个载荷步，“真实”切线矩阵为\n$$\nK_{\\mathrm{true}}(N,P) \\;=\\; K_M \\;+\\; N\\,K_G \\;+\\; P\\,K_L.\n$$\n- 在给定步骤中对应的残差是\n$$\nR(u;N,P) \\;=\\; K_{\\mathrm{true}}(N,P)\\,u \\;-\\; P\\,f_0,\n$$\n其中 $f_0 \\in \\mathbb{R}^2$ 是一个固定的无量纲载荷方向向量，代表随动载荷的固定部分。\n- 材料刚度 $K_M$ 是对称正定的；初始应力刚度 $K_G$ 是对称的，在受压时为负定的（因此增加 $N$ 可能导致失去正定性）；载荷刚度 $K_L$ 是反对称的（因此它会引起非保守效应）。使用以下以无量纲形式表示的具体矩阵和向量：\n$$\nK_M \\;=\\; \\begin{bmatrix} 4.0  0.5 \\\\ 0.5  1.5 \\end{bmatrix},\\quad\nK_G \\;=\\; -\\,\\begin{bmatrix} 1.6  0.2 \\\\ 0.2  0.9 \\end{bmatrix},\\quad\nK_L \\;=\\; \\begin{bmatrix} 0.0  1.0 \\\\ -1.0  0.0 \\end{bmatrix},\\quad\nf_0 \\;=\\; \\begin{bmatrix} 1.0 \\\\ 0.2 \\end{bmatrix}.\n$$\n- 在每个载荷步，牛顿法用一个近似切线矩阵求解 $R(u;N,P)=0$\n$$\nA(N,P;\\,\\sigma_G,\\sigma_L) \\;=\\; K_M \\;+\\; \\sigma_G\\,N\\,K_G \\;+\\; \\sigma_L\\,P\\,K_L,\n$$\n其中开关 $\\sigma_G \\in \\{0,1\\}$ 控制是否在求解器切线矩阵中包含几何刚度，开关 $\\sigma_L \\in \\{0,1\\}$ 控制是否在求解器切线矩阵中包含载荷刚度。注意，$R$ 始终使用 $K_{\\mathrm{true}}(N,P)$（从不切换），而求解器的切线矩阵 $A$ 可以通过开关而有所不同。在迭代 $k$ 次时的牛顿迭代更新为\n$$\nu^{k+1} \\;=\\; u^k \\;-\\; A(N,P;\\,\\sigma_G,\\sigma_L)^{-1}\\,R(u^k;N,P).\n$$\n\n数值步骤：\n\n- 在每个算例的第一步，将 $u$ 初始化为 $\\mathbf{0}$，然后使用收敛解作为同一算例内下一步的初始猜测值。\n- 每步最多进行 $200$ 次牛顿迭代，收敛准则为\n$$\n\\frac{\\lVert R(u;N,P)\\rVert_2}{\\lVert P\\,f_0\\rVert_2 + 10^{-16}} \\;\\le\\; 10^{-8}.\n$$\n- 如果使用 $A$ 的线性求解失败（出现数值奇异或条件数超过 $10^{12}$），或迭代未在最大迭代次数内满足收敛准则，则声明当前载荷步不收敛，并停止当前算例的后续步骤。\n\n你的任务：\n\n- 实现上述带有开关 $\\sigma_G$ 和 $\\sigma_L$ 的牛顿法程序。\n- 对于每个指定的算例（见下面的测试套件），计算有多少个载荷步收敛，并返回该计数。\n\n测试套件：\n\n为以下四个算例提供结果，这些算例旨在分别探究 $K_M$、$K_G$ 和 $K_L$ 的作用：\n\n- 算例 $1$（不含载荷相关切线的基准拟牛顿法）：$\\sigma_G = 0$，$\\sigma_L = 0$，载荷序列包含三个步骤\n  - 步骤 $1$：$(N,P)=(0.0,\\,0.05)$\n  - 步骤 $2$：$(N,P)=(0.3,\\,0.05)$\n  - 步骤 $3$：$(N,P)=(0.6,\\,0.05)$\n- 算例 $2$（仅在切线矩阵中包含几何刚度）：$\\sigma_G = 1$，$\\sigma_L = 0$，载荷序列包含四个步骤\n  - 步骤 $1$：$(N,P)=(0.0,\\,0.20)$\n  - 步骤 $2$：$(N,P)=(0.8,\\,0.40)$\n  - 步骤 $3$：$(N,P)=(0.8,\\,0.80)$\n  - 步骤 $4$：$(N,P)=(0.8,\\,1.60)$\n- 算例 $3$（仅在切线矩阵中包含载荷刚度）：$\\sigma_G = 0$，$\\sigma_L = 1$，载荷序列包含四个步骤\n  - 步骤 $1$：$(N,P)=(0.0,\\,0.0)$\n  - 步骤 $2$：$(N,P)=(0.6,\\,0.0)$\n  - 步骤 $3$：$(N,P)=(0.9,\\,0.0)$\n  - 步骤 $4$：$(N,P)=(1.2,\\,0.0)$\n- 算例 $4$（包含两种载荷相关切线的精确牛顿法）：$\\sigma_G = 1$，$\\sigma_L = 1$，载荷序列包含四个步骤\n  - 步骤 $1$：$(N,P)=(0.0,\\,0.0)$\n  - 步骤 $2$：$(N,P)=(0.8,\\,0.2)$\n  - 步骤 $3$：$(N,P)=(1.0,\\,0.2)$\n  - 步骤 $4$：$(N,P)=(1.2,\\,0.2)$\n\n最终输出规范：\n\n- 你的程序应生成单行输出，其中包含一个含四个整数的列表，第 $i$ 个整数是算例 $i$ 中收敛的步数，格式严格如下\n$$\n[\\text{r1},\\text{r2},\\text{r3},\\text{r4}],\n$$\n列表中无空格，且无附加文本。例如，一个有效的输出是 $[3,2,4,4]$（实际数字取决于你的实现以及指定的矩阵和载荷序列）。", "solution": "用户要求实现一个数值实验，以研究在一个简化的结构力学模型中，材料刚度、初始应力刚度和载荷刚度的作用。验证和求解过程如下。\n\n### **问题验证**\n\n**步骤 1：提取已知条件**\n\n-   **状态向量**：$u \\in \\mathbb{R}^2$。\n-   **真实切线刚度**：$K_{\\mathrm{true}}(N,P) = K_M + N\\,K_G + P\\,K_L$，其中 $N \\ge 0$ 是预应力参数，$P \\ge 0$ 是随动载荷参数。\n-   **残差向量**：$R(u;N,P) = K_{\\mathrm{true}}(N,P)\\,u - P\\,f_0$。\n-   **分量矩阵和向量**：\n    $$\n    K_M = \\begin{bmatrix} 4.0  0.5 \\\\ 0.5  1.5 \\end{bmatrix} \\quad (\\text{对称正定})\n    $$\n    $$\n    K_G = -\\begin{bmatrix} 1.6  0.2 \\\\ 0.2  0.9 \\end{bmatrix} \\quad (\\text{对称负定})\n    $$\n    $$\n    K_L = \\begin{bmatrix} 0.0  1.0 \\\\ -1.0  0.0 \\end{bmatrix} \\quad (\\text{反对称})\n    $$\n    $$\n    f_0 = \\begin{bmatrix} 1.0 \\\\ 0.2 \\end{bmatrix}\n    $$\n-   **近似求解器切线矩阵**：$A(N,P;\\,\\sigma_G,\\sigma_L) = K_M + \\sigma_G\\,N\\,K_G + \\sigma_L\\,P\\,K_L$，其中开关 $\\sigma_G, \\sigma_L \\in \\{0,1\\}$。\n-   **牛顿迭代更新**：$u^{k+1} = u^k - A^{-1}\\,R(u^k)$。\n-   **数值步骤**：\n    -   在一个算例的第一步将 $u$ 初始化为 $\\mathbf{0}$；后续步骤使用前一步的收敛解。\n    -   每步最大迭代次数：$200$。\n    -   收敛准则：$\\frac{\\lVert R(u;N,P)\\rVert_2}{\\lVert P\\,f_0\\rVert_2 + 10^{-16}} \\le 10^{-8}$。\n    -   失败条件：使用 $A$ 的线性求解失败（奇异或条件数  $10^{12}$）或在最大迭代次数内不收敛。\n-   **任务**：对四个指定的算例，计算成功收敛的载荷步数。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n1.  **科学上成立**：该问题是对非线性结构分析问题的合理抽象，在有限元法中很常见。将切线刚度分解为材料（$K_M$）、几何（$K_G$）和载荷相关（$K_L$）部分是规范做法。给定矩阵的性质与其物理解释一致：$K_M$ 是对称正定的（特征值约等于 $4.15, 1.35$），$K_G$ 是对称负定的（其正部的特征值约等于 $1.7, 0.8$，因此 $K_G$ 的特征值为负），$K_L$ 是反对称的（$K_L = -K_L^T$）。使用近似切线矩阵 $A$ 求解由真实刚度 $K_{\\mathrm{true}}$ 控制的系统，这种拟牛顿法的设置是标准技术，也是数值实验的有效基础。\n2.  **良态**：所有必要的数据、矩阵、参数和算法都已明确提供。目标——计算收敛步数——清晰明确，能产生唯一的、确定性的结果。\n3.  **客观性**：问题以精确的数学语言陈述，没有主观性。\n4.  **不完整或矛盾的设置**：问题是自包含且无矛盾的。虽然对固定的 $N$ 和 $P$ 来说，系统 $K_{\\mathrm{true}}u = Pf_0$ 是线性的，但在此系统上使用牛顿法是一种有效的实验设计，用以探究当求解器的雅可比矩阵（$A$）与系统的真实雅可比矩阵（$K_{\\mathrm{true}}$）不匹配时拟牛顿法的收敛性。\n5.  **不切实际或不可行**：问题是无量纲的，所要求的计算是标准的线性代数运算，都是可行的。\n6.  **病态或平凡**：该问题不是病态的。虽然某些测试算例（例如算例 3）可能看起来平凡，但它们的行为是问题物理性质的直接且富有信息的反映（$P=0$ 意味着没有外力，导致平凡解）。这探究了一个有效的边界情况。整个实验并非平凡，它阐明了计算力学中的重要概念。\n\n**步骤 3：结论和行动**\n\n该问题被判定为**有效**。它是一个健全、自包含且良态的数值问题，其基础是计算固体力学的原理。将提供一个解。\n\n### **基于原理的求解设计**\n\n任务的核心是实现一个拟牛顿迭代求解器。牛顿法的基本原理是通过在当前迭代点用函数的切线来近似函数，从而迭代地找到函数（这里是残差 $R(u)$）的根。\n\n1.  **控制方程和残差**：物理系统由方程 $K_{\\mathrm{true}}(N,P)\\,u = P\\,f_0$ 建模。求解器的目标是找到满足此方程的位移向量 $u$。残差 $R(u) = K_{\\mathrm{true}}(N,P)\\,u - P\\,f_0$ 量化了给定 $u$ 的误差。当 $R(u) = \\mathbf{0}$ 时，找到解。\n\n2.  **拟牛顿迭代**：标准的 Newton-Raphson 方法在每一步都对残差进行线性化。更新量 $\\Delta u$ 通过求解 $J \\Delta u = -R(u^k)$ 找到，其中 $J = \\frac{\\partial R}{\\partial u}$ 是雅可比矩阵。对于我们的线性残差，精确的雅可比矩阵是 $J = K_{\\mathrm{true}}$。本问题通过用一个近似值 $A(N,P;\\,\\sigma_G,\\sigma_L)$ 替换精确的雅可比矩阵 $J$ 来引入一个拟牛顿方案。因此，迭代更新为：\n    $$\n    u^{k+1} = u^k + \\Delta u^k \\quad \\text{其中} \\quad A \\Delta u^k = -R(u^k)\n    $$\n    $A$ 的选择决定了求解器的行为：\n    -   当 $A=K_{\\mathrm{true}}$（算例 4）时，我们得到精确牛顿法，对于这个线性残差，它在一次迭代中收敛。\n    -   当 $A \\neq K_{\\mathrm{true}}$（算例 1、2、3）时，我们得到一个拟牛顿法。其收敛性取决于 $A$ 对 $K_{\\mathrm{true}}$ 的近似程度。一个糟糕的近似可能导致收敛缓慢或发散。\n\n3.  **刚度分量的物理解释**：\n    -   $K_M$：材料的固有刚度。它是切线矩阵的基准，是对称正定的部分。\n    -   $N K_G$：初始应力或几何刚度。一个压缩性预应力（$N0$）通常会降低整体刚度。如果 $N$ 足够大，$K_M + N K_G$ 可能变为奇异，对应于弹性屈曲。\n    -   $P K_L$：载荷刚度，源于非保守的“随动”力。其反对称性可导致非对称的切线矩阵，可能引起颤振失稳。\n\n4.  **算法实现**：解决方案的构建是通过编写一个程序，该程序遍历四个指定的测试算例。对于每个算例，它按顺序处理一系列载荷步。在每个步骤中，它执行拟牛顿循环，检查收敛或失败。\n    -   **状态初始化**：在每个算例开始时，位移 $u$ 被重置为 $\\mathbf{0}$，并且在一个算例内，从一个收敛的步骤传递到下一个步骤。这模拟了一个增量加载历史。\n    -   **矩阵组装**：对于每个步骤，根据当前的载荷参数 $(N, P)$ 和算例的开关 $(\\sigma_G, \\sigma_L)$ 组装 $K_{\\mathrm{true}}$ 和 $A$。\n    -   **失效处理**：在迭代之前，检查求解器矩阵 $A$ 的条件数是否超过阈值（$10^{12}$），以预先检测病态条件。在迭代期间，监视线性求解 $A \\Delta u = -R$ 是否出现数值失败。如果达到最大迭代次数（$200$）而残差未满足容差（$\\lVert R \\rVert_2 / (\\lVert P f_0 \\rVert_2 + \\epsilon) \\le 10^{-8}$），则该步骤被标记为不收敛。\n    -   **计数和报告**：每个算例的计数器跟踪成功步骤的数量。在第一个失败的步骤处，该算例的流程停止。报告所有四个算例的最终计数。\n\n这种系统化的方法正确地模拟了指定的数值实验，允许直接比较在求解器的切线矩阵中包含或排除几何刚度和载荷刚度项如何影响其稳定性和收敛性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a quasi-Newton solver to test the effects of stiffness matrix components.\n    \"\"\"\n    # Define the nondimensional matrices and load vector from the problem statement.\n    K_M = np.array([[4.0, 0.5],\n                    [0.5, 1.5]])\n\n    K_G = -np.array([[1.6, 0.2],\n                     [0.2, 0.9]])\n\n    K_L = np.array([[0.0, 1.0],\n                    [-1.0, 0.0]])\n\n    f_0 = np.array([1.0, 0.2])\n\n    # Define numerical procedure parameters.\n    MAX_ITER = 200\n    TOL = 1e-8\n    COND_LIMIT = 1e12\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (sigma_G, sigma_L, list_of_load_steps)\n    test_cases = [\n        # Case 1: Baseline quasi-Newton without load-dependent tangents\n        (0, 0, [(0.0, 0.05), (0.3, 0.05), (0.6, 0.05)]),\n        # Case 2: Include geometric stiffness only\n        (1, 0, [(0.0, 0.20), (0.8, 0.40), (0.8, 0.80), (0.8, 1.60)]),\n        # Case 3: Include load stiffness only\n        (0, 1, [(0.0, 0.0), (0.6, 0.0), (0.9, 0.0), (1.2, 0.0)]),\n        # Case 4: Exact Newton with both load-dependent tangents\n        (1, 1, [(0.0, 0.0), (0.8, 0.2), (1.0, 0.2), (1.2, 0.2)])\n    ]\n\n    results = []\n    \n    # Iterate through each test case.\n    for case in test_cases:\n        sigma_G, sigma_L, load_steps = case\n        \n        # Initialize displacement vector and converged step counter for the case.\n        u = np.zeros(2)\n        converged_steps_count = 0\n        \n        # Iterate through the load steps for the current case.\n        for N, P in load_steps:\n            # The initial guess for this step is the converged solution from the previous step.\n            u_k = np.copy(u)\n            \n            # Assemble the \"true\" and \"approximate\" tangent matrices.\n            K_true = K_M + N * K_G + P * K_L\n            A = K_M + sigma_G * N * K_G + sigma_L * P * K_L\n            \n            step_converged = False\n\n            # Pre-check for ill-conditioning of the solver's tangent matrix.\n            try:\n                if np.linalg.cond(A) > COND_LIMIT:\n                    break # Step fails, so break from the load_steps loop for this case.\n            except np.linalg.LinAlgError:\n                break # Matrix is singular.\n\n            # Calculate the external force vector and the denominator for the convergence criterion.\n            F_ext = P * f_0\n            conv_denom = np.linalg.norm(F_ext) + 1e-16\n\n            # Perform Newton-Raphson iteration.\n            for _ in range(MAX_ITER):\n                # Calculate the residual vector.\n                R_k = K_true @ u_k - F_ext\n                \n                # Check for convergence.\n                if np.linalg.norm(R_k) / conv_denom = TOL:\n                    step_converged = True\n                    u = u_k  # Store the converged solution for the next step.\n                    break\n\n                # Solve for the displacement update: A * delta_u = -R_k.\n                try:\n                    delta_u = np.linalg.solve(A, -R_k)\n                except np.linalg.LinAlgError:\n                    # Linear solve failed, iteration cannot continue.\n                    step_converged = False\n                    break \n                \n                # Update the displacement vector.\n                u_k += delta_u\n            \n            # If the step converged, increment the counter.\n            if step_converged:\n                converged_steps_count += 1\n            else:\n                # If a step fails, stop processing this case.\n                break\n\n        results.append(converged_steps_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3574659"}]}