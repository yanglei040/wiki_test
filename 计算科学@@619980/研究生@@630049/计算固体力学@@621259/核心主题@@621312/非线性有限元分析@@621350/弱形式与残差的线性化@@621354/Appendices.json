{"hands_on_practices": [{"introduction": "在非线性固体力学中，求解控制方程通常依赖于牛顿法，而该方法的核心在于对弱形式残差进行一致性线性化。对于有限应变问题，这要求我们精确推导应力张量相对于变形梯度的变分。本练习 [@problem_id:3578792] 旨在通过从第一性原理出发，推导第一皮奥拉-基尔霍夫应力（First Piola–Kirchhoff stress）的变分，从而为学习者提供处理有限应变超弹性材料本构模型线性化的基础技能。", "problem": "考虑一个三维超弹性体，其占据一个具有物质坐标的参考构型。令变形梯度为 $F$，右柯西-格林张量为 $C=F^{\\top}F$，格林-拉格朗日应变为 $E=\\tfrac{1}{2}(C-I)$，第二皮奥拉-基尔霍夫应力为 $S$，第一皮奥拉-基尔霍夫应力为 $P$，柯西应力为 $\\sigma$。假设材料为超弹性，其单位参考体积的亥姆霍兹自由能 $\\Psi$ 是 $C$（或等效地，是 $E$）的函数，因此本构关系可由标准能量共轭导出。在参考构型中的虚功原理 (PVW) 指出，对于所有容许虚位移，内虚功等于外虚功。\n\n从以下基本依据出发：\n- 标架无关的运动学关系 $C=F^{\\top}F$ 和 $E=\\tfrac{1}{2}(C-I)$，\n- 超弹性关系 $S=2\\,\\partial \\Psi/\\partial C$ 和 $P=F\\,S$，\n- 柯西应力的定义 $\\sigma=(1/J)\\,F\\,S\\,F^{\\top}$，其中 $J=\\det F$，\n- 以及内虚功的虚功原理表达式 $\\int_{\\Omega_{0}} P:\\nabla_{0} w\\,\\mathrm{d}V$，\n\n请执行以下步骤，不要引用任何预先线性化或“快捷”公式：\n\n1) 推导内虚功残量相对于变形的一致线性化，确定将增量 $\\delta F$ 映射到 $\\delta P$ 的切线算子。具体来说，推导 $\\delta P$ 关于 $\\delta F$、$S$ 和 $\\delta S$ 的表达式，并将 $\\delta S$ 表示为 $\\delta C$ 和 $\\Psi$ 对 $C$ 的二阶导数的函数。此外，推导相应的空间应力变分 $\\delta \\sigma$ 关于 $\\delta F$、$S$ 和 $\\delta S$ 的表达式。\n\n2) 将问题具体化到圣维南-基尔霍夫 (SVK) 材料，其自由能与 $E$ 的关系为 $\\Psi(E)=\\tfrac{\\lambda}{2}\\,(\\mathrm{tr}\\,E)^{2}+\\mu\\,\\mathrm{tr}(E^{2})$，其中 $\\lambda$ 和 $\\mu$ 是拉梅参数。使用第 1 部分得到的一般线性化结果，求出材料切线映射 $\\mathbb{A}$，其分量为 $A_{iJkL}=\\partial P_{iJ}/\\partial F_{kL}$。\n\n3) 在均匀拉伸状态下（$F=\\mathrm{diag}(a,b,c)$，其中 $a$、$b$ 和 $c$ 是正主拉伸）计算特定的切线分量 $A_{1111}$。请以 $a$、$b$、$c$、$\\lambda$ 和 $\\mu$ 的单个闭式解析表达式形式给出最终答案。不要代入数值。最终答案无需单位。", "solution": "用户提供了一个非线性连续介质力学领域的问题陈述，具体涉及超弹性材料本构关系的线性化。\n\n### 问题验证\n\n首先，我将对问题陈述进行严格的验证。\n\n**第1步：提取已知条件**\n\n*   **运动学**：\n    *   变形梯度：$F$\n    *   右柯西-格林张量：$C = F^{\\top}F$\n    *   格林-拉格朗日应变：$E = \\frac{1}{2}(C-I)$\n*   **动力学与本构律**：\n    *   单位参考体积的亥姆霍兹自由能：$\\Psi(C)$\n    *   第二皮奥拉-基尔霍夫应力：$S = 2\\,\\frac{\\partial \\Psi}{\\partial C}$\n    *   第一皮奥拉-基尔霍夫应力：$P = F S$\n    *   柯西应力：$\\sigma = \\frac{1}{J}\\,F\\,S\\,F^{\\top}$，其中 $J = \\det F$\n*   **虚功原理**：\n    *   内虚功：$\\int_{\\Omega_{0}} P:\\nabla_{0} w\\,\\mathrm{d}V$\n*   **特定材料模型 (圣维南-基尔霍夫, SVK)**：\n    *   自由能：$\\Psi(E) = \\frac{\\lambda}{2}\\,(\\mathrm{tr}\\,E)^{2} + \\mu\\,\\mathrm{tr}(E^{2})$，其中拉梅参数为 $\\lambda$ 和 $\\mu$。\n*   **用于评估的状态**：\n    *   均匀拉伸：$F = \\mathrm{diag}(a,b,c)$\n\n**第2步：使用提取的已知条件进行验证**\n\n*   **科学基础**：该问题完全基于非线性固体力学的既定原理和标准定义。所提供的运动学变量（$F, C, E$）、应力张量（$S, P, \\sigma$）和超弹性势（$\\Psi$）之间的关系是该领域的基础。SVK 模型是一个经典的、尽管简化的超弹性模型。所有方面在科学上都是合理的。\n*   **适定性**：该问题结构为一系列逻辑推导，然后对一个特定情况进行评估。每个步骤都定义明确，并且所提供的信息足以得出一个唯一的数学表达式来求解所需量。\n*   **客观性**：该问题使用精确、无歧义的数学和物理术语进行陈述。它不含主观主张或解释。\n*   **完整性**：所有必需的定义、方程和本构律的具体形式均已提供。必须进行最终评估的状态也已明确给出。\n*   **一致性**：所提供的定义或目标中没有内部矛盾。\n\n**第3步：结论与行动**\n\n该问题是有效的。这是计算力学中一个标准的、非平凡的练习，旨在测试对本构建模和线性化程序的基本理解。我现在将着手提供完整解答。\n\n### 解答\n\n解答按要求分为三部分呈现。\n\n**第1部分：应力张量的一般线性化**\n\n目标是求应力张量 $P$ 和 $\\sigma$ 相对于变形梯度无穷小变化（记为 $\\delta F$）的变分（Gateaux 导数）。\n\n1.  **第一皮奥拉-基尔霍夫应力 ($P$) 的变分**\n\n    第一皮奥拉-基尔霍夫应力 $P$ 通过 $P=FS$ 与第二皮奥拉-基尔霍夫应力 $S$ 相关。为求其变分 $\\delta P$，我们应用微分的乘法法则：\n    $$ \\delta P = (\\delta F) S + F (\\delta S) $$\n    此表达式按要求给出了 $\\delta P$ 关于 $\\delta F$、$S$ 和 $\\delta S$ 的关系。\n\n2.  **第二皮奥拉-基尔霍夫应力 ($S$) 的变分**\n\n    该材料为超弹性，其第二皮奥拉-基尔霍夫应力由亥姆霍兹自由能 $\\Psi(C)$ 导出，即 $S = 2 \\frac{\\partial \\Psi}{\\partial C}$。其变分 $\\delta S$ 可通过应用链式法则求得，该法则产生一个从右柯西-格林张量变分 $\\delta C$到 $\\delta S$ 的线性映射：\n    $$ \\delta S = 2 \\frac{\\partial}{\\partial C} \\left( \\frac{\\partial \\Psi}{\\partial C} \\right) : \\delta C = 2 \\frac{\\partial^2 \\Psi}{\\partial C \\partial C} : \\delta C $$\n    这就是 $\\delta S$ 关于 $\\delta C$ 和 $\\Psi$ 的二阶导数的表达式。变分 $\\delta C$ 通过定义 $C=F^{\\top}F$ 与 $\\delta F$ 相关：\n    $$ \\delta C = \\delta(F^{\\top}F) = (\\delta F)^{\\top}F + F^{\\top}(\\delta F) $$\n\n3.  **柯西应力 ($\\sigma$) 的变分**\n\n    柯西应力 $\\sigma$ 由 $\\sigma = J^{-1} F S F^{\\top}$ 给出。其变分可通过多次应用乘法法则求得：\n    $$ \\delta \\sigma = \\delta(J^{-1}) F S F^{\\top} + J^{-1} (\\delta F) S F^{\\top} + J^{-1} F (\\delta S) F^{\\top} + J^{-1} F S (\\delta F)^{\\top} $$\n    体积比的变分为 $\\delta J = J \\mathrm{tr}(F^{-1} \\delta F) = J (F^{-\\top} : \\delta F)$。因此，其逆的变分为 $\\delta(J^{-1}) = -J^{-2} \\delta J = -J^{-1}(F^{-\\top} : \\delta F)$。\n    将此代入 $\\delta \\sigma$ 的表达式，得到：\n    $$ \\delta \\sigma = -J^{-1} (F^{-\\top} : \\delta F) F S F^{\\top} + J^{-1} \\left( (\\delta F) S F^{\\top} + F (\\delta S) F^{\\top} + F S (\\delta F)^{\\top} \\right) $$\n    这就得到了柯西应力变分关于 $\\delta F$、$S$ 和 $\\delta S$ 的表达式。\n\n**第2部分：圣维南-基尔霍夫 (SVK) 材料的材料切线**\n\nSVK 模型由应变能函数 $\\Psi(E) = \\frac{\\lambda}{2}(\\mathrm{tr}\\,E)^{2} + \\mu\\,\\mathrm{tr}(E^{2})$ 定义。\n\n首先，我们推导第二皮奥拉-基尔霍夫应力 $S$ 的本构关系。问题陈述 $S = 2 \\frac{\\partial \\Psi}{\\partial C}$。由于 $E = \\frac{1}{2}(C-I)$，可得 $\\frac{\\partial E}{\\partial C} = \\frac{1}{2}I_s$，其中 $I_s$ 是四阶对称单位张量。这意味着一个更简单的关系 $S = \\frac{\\partial \\Psi}{\\partial E}$。将此应用于 SVK 能量函数，我们得到：\n$$ S = \\frac{\\partial}{\\partial E} \\left( \\frac{\\lambda}{2}(\\mathrm{tr}\\,E)^{2} + \\mu\\,\\mathrm{tr}(E^{2}) \\right) = \\lambda (\\mathrm{tr}\\,E) \\frac{\\partial(\\mathrm{tr}\\,E)}{\\partial E} + \\mu \\frac{\\partial(\\mathrm{tr}(E^2))}{\\partial E} $$\n使用恒等式 $\\frac{\\partial(\\mathrm{tr}\\,E)}{\\partial E} = I$ 和 $\\frac{\\partial(\\mathrm{tr}(E^2))}{\\partial E} = 2E$，我们得到 $S$ 的本构律：\n$$ S = \\lambda (\\mathrm{tr}\\,E) I + 2\\mu E $$\n接下来，我们推导由 $\\delta S = \\mathcal{C} : \\delta E$ 定义的四阶材料弹性张量 $\\mathcal{C}$。对 $S = \\lambda (\\mathrm{tr}\\,E) I + 2\\mu E$ 关于对称张量 $E$ 求导，可得到材料弹性张量 $\\mathcal{C}$，其分量为：\n$$ \\mathcal{C}_{ijkl} = \\lambda \\delta_{ij} \\delta_{kl} + \\mu (\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}) $$\n第一皮奥拉-基尔霍夫切线模量 $A_{iJkL}$ 由关系式 $\\delta P_{iJ} = A_{iJkL} \\delta F_{kL}$ 定义。我们从 $P_{iJ} = F_{iM} S_{MJ}$ 开始，计算其对 $F_{kL}$ 的导数：\n$$ A_{iJkL} = \\frac{\\partial P_{iJ}}{\\partial F_{kL}} = \\frac{\\partial(F_{iM} S_{MJ})}{\\partial F_{kL}} = \\frac{\\partial F_{iM}}{\\partial F_{kL}} S_{MJ} + F_{iM} \\frac{\\partial S_{MJ}}{\\partial F_{kL}} $$\n使用 $\\frac{\\partial F_{iM}}{\\partial F_{kL}} = \\delta_{ik}\\delta_{ML}$，第一项是 $\\delta_{ik}S_{LJ}$。对于第二项，我们使用链式法则：\n$$ \\frac{\\partial S_{MJ}}{\\partial F_{kL}} = \\frac{\\partial S_{MJ}}{\\partial E_{PQ}} \\frac{\\partial E_{PQ}}{\\partial F_{kL}} = \\mathcal{C}_{MJPQ} \\frac{\\partial E_{PQ}}{\\partial F_{kL}} $$\n格林-拉格朗日应变 $E_{PQ} = \\frac{1}{2}(F_{RP}F_{RQ} - \\delta_{PQ})$ 对 $F_{kL}$ 的导数是：\n$$ \\frac{\\partial E_{PQ}}{\\partial F_{kL}} = \\frac{1}{2} \\left( \\frac{\\partial F_{RP}}{\\partial F_{kL}} F_{RQ} + F_{RP} \\frac{\\partial F_{RQ}}{\\partial F_{kL}} \\right) = \\frac{1}{2} (\\delta_{Rk}\\delta_{PL} F_{RQ} + F_{RP} \\delta_{Rk}\\delta_{QL}) = \\frac{1}{2} (F_{kQ}\\delta_{PL} + F_{kP}\\delta_{QL}) $$\n将其代回，我们得到：\n$$ F_{iM} \\frac{\\partial S_{MJ}}{\\partial F_{kL}} = F_{iM} \\mathcal{C}_{MJPQ} \\frac{1}{2} (F_{kQ}\\delta_{PL} + F_{kP}\\delta_{QL}) = \\frac{1}{2} F_{iM} (\\mathcal{C}_{MJLQ} F_{kQ} + \\mathcal{C}_{MJPL} F_{kP}) $$\n重命名哑求和指标并利用次对称性 $\\mathcal{C}_{MJLQ} = \\mathcal{C}_{MJQL}$，上式可简化为：\n$$ \\frac{1}{2} F_{iM} (\\mathcal{C}_{MJLN} F_{kN} + \\mathcal{C}_{MJNL} F_{kN}) = F_{iM} F_{kN} \\mathcal{C}_{MJLN} $$\n因此，材料切线模量的完整表达式为：\n$$ A_{iJkL} = \\delta_{ik} S_{LJ} + F_{iM} F_{kN} \\mathcal{C}_{MJLN} $$\n\n**第3部分：$A_{1111}$ 的计算**\n\n我们在均匀拉伸状态 $F = \\mathrm{diag}(a,b,c)$ 下计算 $A_{1111}$。\n用分量形式表示，$F_{iJ} = \\lambda_i \\delta_{iJ}$ (对 $i$ 不求和)，其中 $\\lambda_1 = a$, $\\lambda_2 = b$, $\\lambda_3 = c$。\n我们需要计算 $A_{1111}$，因此我们令 $i=1, J=1, k=1, L=1$：\n$$ A_{1111} = \\delta_{11} S_{11} + F_{1M} F_{1N} \\mathcal{C}_{M11N} $$\n由于 $F$ 是对角阵，$F_{1M} = a \\delta_{1M}$ 且 $F_{1N} = a \\delta_{1N}$。表达式变为：\n$$ A_{1111} = S_{11} + (a \\delta_{1M}) (a \\delta_{1N}) \\mathcal{C}_{M11N} = S_{11} + a^2 \\mathcal{C}_{1111} $$\n现在，我们计算分量 $S_{11}$ 和 $\\mathcal{C}_{1111}$。\n右柯西-格林张量为 $C = F^{\\top}F = \\mathrm{diag}(a^2, b^2, c^2)$，格林-拉格朗日应变为 $E = \\frac{1}{2}(C-I) = \\frac{1}{2}\\mathrm{diag}(a^2-1, b^2-1, c^2-1)$。\n应变的迹为 $\\mathrm{tr}\\,E = \\frac{1}{2}(a^2+b^2+c^2-3)$。\n分量 $S_{11}$ 为：\n$$ S_{11} = \\lambda (\\mathrm{tr}\\,E) + 2\\mu E_{11} = \\frac{\\lambda}{2}(a^2+b^2+c^2-3) + 2\\mu \\left(\\frac{1}{2}(a^2-1)\\right) = \\frac{\\lambda}{2}(a^2+b^2+c^2-3) + \\mu(a^2-1) $$\n分量 $\\mathcal{C}_{1111}$ 为：\n$$ \\mathcal{C}_{1111} = \\lambda \\delta_{11}\\delta_{11} + \\mu(\\delta_{11}\\delta_{11} + \\delta_{11}\\delta_{11}) = \\lambda(1)(1) + \\mu(1 \\cdot 1 + 1 \\cdot 1) = \\lambda + 2\\mu $$\n将这些代入 $A_{1111}$ 的表达式：\n$$ A_{1111} = \\left[ \\frac{\\lambda}{2}(a^2+b^2+c^2-3) + \\mu(a^2-1) \\right] + a^2(\\lambda+2\\mu) $$\n展开并合并同类项：\n$$ A_{1111} = \\frac{\\lambda}{2}a^2 + \\frac{\\lambda}{2}b^2 + \\frac{\\lambda}{2}c^2 - \\frac{3\\lambda}{2} + \\mu a^2 - \\mu + \\lambda a^2 + 2\\mu a^2 $$\n$$ A_{1111} = a^2 \\left(\\frac{\\lambda}{2} + \\mu + \\lambda + 2\\mu \\right) + \\frac{\\lambda}{2}b^2 + \\frac{\\lambda}{2}c^2 - \\frac{3\\lambda}{2} - \\mu $$\n$$ A_{1111} = a^2 \\left(\\frac{3\\lambda}{2} + 3\\mu \\right) + \\frac{\\lambda}{2}(b^2 + c^2) - \\frac{3\\lambda}{2} - \\mu $$\n这就是分量 $A_{1111}$ 的最终闭式解析表达式。", "answer": "$$\n\\boxed{ a^{2} \\left(\\frac{3\\lambda}{2} + 3\\mu \\right) + \\frac{\\lambda}{2}(b^{2} + c^{2}) - \\frac{3\\lambda}{2} - \\mu }\n$$", "id": "3578792"}, {"introduction": "理论推导的正确性最终需要在计算程序中得到验证，尤其是对于复杂的非线性问题，手动推导的切线算子很容易引入错误。泰勒余项检验（Taylor remainder test）是验证非线性有限元程序正确性的黄金标准，它通过数值方法检验所实现的切线算子是否确实是残差的精确导数。通过本练习 [@problem_id:3578726]，您将学习如何为一个非线性杆单元系统地构建并实施这一关键的验证程序，从而确保数值求解的收敛性与准确性。", "problem": "考虑一根一维准静态杆，其参考长度为 $L$，横截面积为常数 $A$，通过有限元法 (FEM) 离散为 $n_{\\text{el}}$ 个线性双节点单元和 $n_{\\text{n}}$ 个节点。设节点位移向量为 $u \\in \\mathbb{R}^{n_{\\text{n}}}$，并令 $\\Delta u \\in \\mathbb{R}^{n_{\\text{n}}}$ 表示一个任意的扰动方向。假设小应变运动学，工程应变为 $\\varepsilon(x) = \\dfrac{du}{dx}$，并采用光滑的非线性本构关系 $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^{3}$，其中 $E \\gt 0$ 是杨氏模量，$\\alpha \\ge 0$ 是一个非线性参数。在无外部载荷的情况下，平衡的弱形式简化为内虚功陈述，相关的全局残差映射 $R(u)$（节点残差力向量）通过组合单元贡献 $\\int_{\\Omega_e} A\\,B^{\\top}\\,\\sigma(B\\,u_e)\\,dx$ 来定义，其中 $\\Omega_e$ 是单元域，$u_e$ 是单元 $e$ 的节点位移，$B$ 是单元应变-位移算子。对于长度为 $L_e$ 的线性双节点单元，$B = \\left[-\\dfrac{1}{L_e},\\,\\dfrac{1}{L_e}\\right]$，因此单元应变为常数，$\\varepsilon_e = B\\,u_e$。\n\n残差的 Gateaux 导数（方向导数）$DR(u)\\cdot \\Delta u$ 是切线算子在 $u$ 处对 $\\Delta u$ 的作用，对于给定的本构关系，它通过对 $\\sigma(\\varepsilon)$ 关于 $\\varepsilon$ 求导得到，即 $C(u) = \\dfrac{d\\sigma}{d\\varepsilon}\\big\\rvert_{\\varepsilon = B\\,u_e} = E + 3\\,\\alpha\\,(B\\,u_e)^2$。单元级的线性化随后产生切线贡献 $\\int_{\\Omega_e} A\\,B^{\\top}\\,C(u)\\,B\\,\\Delta u_e\\,dx$，它被组装到全局向量 $DR(u)\\cdot \\Delta u$ 中。\n\n您的任务是为残差映射构建并数值验证泰勒余项测试，使用一个有限元模型，该模型包含位于 $x = 0$、$x = \\dfrac{L}{2}$ 和 $x = L$ 位置的 $n_{\\text{n}} = 3$ 个节点，以及将杆均分为两段的 $n_{\\text{el}} = 2$ 个单元。具体来说，验证泰勒余项满足\n$$\n\\left\\| R(u + \\epsilon\\,\\Delta u) - R(u) - \\epsilon\\,DR(u)\\cdot \\Delta u \\right\\| = o(\\epsilon) \\quad \\text{as} \\quad \\epsilon \\to 0,\n$$\n通过计算比率\n$$\n\\rho(\\epsilon) = \\dfrac{\\left\\| R(u + \\epsilon\\,\\Delta u) - R(u) - \\epsilon\\,DR(u)\\cdot \\Delta u \\right\\|}{\\epsilon}\n$$\n对于一个递减的 $\\epsilon$ 值序列，并检查 $\\rho(\\epsilon)$ 以与可微性一致的方式趋于零。向量使用欧几里得范数。本问题中的所有量都是无量纲的；不需要物理单位。\n\n需要遵循的实现细节：\n- 网格由 $L = 1$、$A = 1$、节点位置 $x_1 = 0$、$x_2 = \\dfrac{1}{2}$、$x_3 = 1$ 定义，单元为 $e_1 = (x_1, x_2)$ 和 $e_2 = (x_2, x_3)$。\n- 对于每个单元 $e$，计算常数单元应变 $\\varepsilon_e = B\\,u_e$、应力 $\\sigma_e = E\\,\\varepsilon_e + \\alpha\\,\\varepsilon_e^{3}$，并将单元残差 $r_e = \\int_{\\Omega_e} A\\,B^{\\top}\\,\\sigma_e\\,dx = A\\,\\sigma_e\\,B^{\\top}\\,L_e$ 组装到 $R(u)$ 中。\n- 对于 Gateaux 导数，计算切线模量 $C_e(u) = E + 3\\,\\alpha\\,\\varepsilon_e^{2}$，并通过 $k_e(u)\\,\\Delta u_e$ 组装其作用 $DR(u)\\cdot \\Delta u$，其中 $k_e(u) = \\int_{\\Omega_e} A\\,B^{\\top}\\,C_e(u)\\,B\\,dx = A\\,C_e(u)\\,(B^{\\top}B)\\,L_e$。\n- 通过为序列 $\\epsilon \\in \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}\\}$ 计算 $\\rho(\\epsilon)$ 来验证泰勒余项条件，并检查它是否为非递增，且其最小值在绝对值上或相对于最大值足够小，与 $\\rho(\\epsilon) \\sim \\mathcal{O}(\\epsilon)$ 一致。\n\n测试套件：\n- 情况 1：$E = 1000$，$\\alpha = 10$，$u = [0,\\, 10^{-3},\\, 2\\times 10^{-3}]$，$\\Delta u = [0,\\, -5\\times 10^{-4},\\, 3\\times 10^{-4}]$。\n- 情况 2：$E = 500$，$\\alpha = 0$，$u = [0,\\, 10^{-2},\\, 2\\times 10^{-2}]$，$\\Delta u = [2\\times 10^{-4},\\, 10^{-4},\\, -10^{-4}]$。\n- 情况 3：$E = 1000$，$\\alpha = 50$，$u = [0,\\, 2\\times 10^{-3},\\, 3\\times 10^{-3}]$，$\\Delta u = [0,\\, 0,\\, 0]$。\n- 情况 4：$E = 1000$，$\\alpha = 1000$，$u = [0,\\, 10^{-1},\\, 2\\times 10^{-1}]$，$\\Delta u = [0,\\, 5\\times 10^{-2},\\, -2\\times 10^{-2}]$。\n\n您的程序应为每种情况计算序列 $\\rho(\\epsilon)$，验证其为非递增且最小值表明收敛性与 $o(\\epsilon)$ 一致，并为每种情况返回一个布尔结果，指示泰勒余项测试是否通过。使用固定的序列 $\\epsilon \\in \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}\\}$。最终输出必须是一行，包含一个用方括号括起来的逗号分隔列表，例如 $[{\\text{result}_1},{\\text{result}_2},{\\text{result}_3},{\\text{result}_4}]$，其中每个 ${\\text{result}_i}$ 是 ${\\text{True}}$ 或 ${\\text{False}}$。", "solution": "该问题要求在非线性有限元背景下，对残差映射进行泰勒余项测试的数值验证。此过程对于验证切线算子（即残差的 Gateaux 导数）的实现至关重要。该测试确认了残差的线性化是正确的，这是使用 Newton-Raphson 及相关方法求解非线性方程组的先决条件。\n\n验证基于泰勒定理。对于一个可微映射 $R(u)$，对于位移状态 $u$ 和扰动方向 $\\Delta u$，以下公式成立：\n$$\nR(u + \\epsilon\\,\\Delta u) = R(u) + \\epsilon\\,DR(u)\\cdot \\Delta u + o(\\epsilon)\n$$\n其中 $DR(u)\\cdot \\Delta u$ 是 $R$ 在 $u$ 处沿方向 $\\Delta u$ 的 Gateaux 导数，而 $o(\\epsilon)$ 表示当 $\\epsilon \\to 0$ 时比 $\\epsilon$ 更快消失的高阶项。该测试通过计算以下比率来数值验证此属性：\n$$\n\\rho(\\epsilon) = \\dfrac{\\left\\| R(u + \\epsilon\\,\\Delta u) - R(u) - \\epsilon\\,DR(u)\\cdot \\Delta u \\right\\|_2}{\\epsilon}\n$$\n对于正确实现的 Gateaux 导数，当 $\\epsilon \\to 0$ 时，$\\rho(\\epsilon)$ 必须收敛到 $0$。通过进一步分析泰勒展开，余项为 $\\mathcal{O}(\\epsilon^2)$，这意味着 $\\rho(\\epsilon)$ 的行为应为 $\\mathcal{O}(\\epsilon)$。这通过为一个递减的 $\\epsilon$ 值序列计算 $\\rho(\\epsilon)$ 并确认所得序列为非递增来进行检查。\n\n具体模型是一根长度为 $L=1$、面积为 $A=1$ 的一维杆，被离散为 $n_{\\text{el}} = 2$ 个线性单元和位于 $x_1=0$、$x_2=0.5$ 和 $x_3=1$ 的 $n_{\\text{n}} = 3$ 个节点。单元长度为 $L_{e1} = L_{e2} = 0.5$。\n\n**1. 残差向量 $R(u)$ 的构建**\n\n全局残差向量 $R(u) \\in \\mathbb{R}^3$ 是由两个单元的贡献组装而成的。对于具有节点位移 $u_e$ 的通用单元 $e$，常数应变由 $\\varepsilon_e = B u_e$ 给出。对于长度为 $L_e$ 的线性单元，应变-位移算子为 $B = \\left[-\\dfrac{1}{L_e}, \\dfrac{1}{L_e}\\right]$。当 $L_e = 0.5$ 时，我们有 $B = [-2, 2]$。\n\n对于单元 1（节点 1, 2），其位移为 $u_{e1} = [u_1, u_2]^T$：\n$$\n\\varepsilon_1 = [-2, 2] \\begin{bmatrix} u_1 \\\\ u_2 \\end{bmatrix} = 2(u_2 - u_1)\n$$\n对于单元 2（节点 2, 3），其位移为 $u_{e2} = [u_2, u_3]^T$：\n$$\n\\varepsilon_2 = [-2, 2] \\begin{bmatrix} u_2 \\\\ u_3 \\end{bmatrix} = 2(u_3 - u_2)\n$$\n\n每个单元中的应力根据非线性本构关系 $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^{3}$ 计算：\n$$\n\\sigma_1 = E\\,\\varepsilon_1 + \\alpha\\,\\varepsilon_1^{3} \\quad , \\quad \\sigma_2 = E\\,\\varepsilon_2 + \\alpha\\,\\varepsilon_2^{3}\n$$\n\n单元残差向量（内力向量）$r_e$ 源自虚功原理：\n$$\nr_e = \\int_{\\Omega_e} A\\,B^{\\top}\\,\\sigma_e\\,dx = A\\,L_e\\,B^{\\top}\\,\\sigma_e = (1)(0.5)\\begin{bmatrix} -2 \\\\ 2 \\end{bmatrix}\\sigma_e = \\begin{bmatrix} -\\sigma_e \\\\ \\sigma_e \\end{bmatrix}\n$$\n将单元 1（作用于节点 1,2）和单元 2（作用于节点 2,3）的贡献组装起来，得到全局残差向量 $R(u) = [R_1, R_2, R_3]^T$：\n$$\nR_1 = -\\sigma_1 \\\\\nR_2 = \\sigma_1 - \\sigma_2 \\\\\nR_3 = \\sigma_2\n$$\n\n**2. 切线算子作用 $DR(u) \\cdot \\Delta u$ 的构建**\n\n切线算子的作用是通过组装单元级贡献来构建的。每个单元的材料切线模量 $C_e$ 是应力对应变的导数：\n$$\nC_e(u) = \\frac{d\\sigma}{d\\varepsilon}\\bigg\\rvert_{\\varepsilon = \\varepsilon_e} = E + 3\\,\\alpha\\,\\varepsilon_e^2\n$$\n因此，对于我们的单元：\n$$\nC_1 = E + 3\\,\\alpha\\,\\varepsilon_1^2 \\quad , \\quad C_2 = E + 3\\,\\alpha\\,\\varepsilon_2^2\n$$\n单元切线刚度矩阵 $k_e$ 对单元位移扰动 $\\Delta u_e$ 的作用由 $\\int_{\\Omega_e} A\\,B^{\\top}\\,C_e\\,B\\,\\Delta u_e\\,dx$ 给出。这可以计算为 $A\\,L_e\\,B^{\\top}\\,C_e\\,\\Delta\\varepsilon_e$，其中 $\\Delta\\varepsilon_e = B\\,\\Delta u_e$。\n\n对于单元 1，应变扰动为 $\\Delta\\varepsilon_1 = 2(\\Delta u_2 - \\Delta u_1)$。其作用为：\n$$\n(1)(0.5)\\begin{bmatrix} -2 \\\\ 2 \\end{bmatrix}C_1\\,\\Delta\\varepsilon_1 = \\begin{bmatrix} -C_1\\,\\Delta\\varepsilon_1 \\\\ C_1\\,\\Delta\\varepsilon_1 \\end{bmatrix}\n$$\n对于单元 2，应变扰动为 $\\Delta\\varepsilon_2 = 2(\\Delta u_3 - \\Delta u_2)$。其作用为：\n$$\n(1)(0.5)\\begin{bmatrix} -2 \\\\ 2 \\end{bmatrix}C_2\\,\\Delta\\varepsilon_2 = \\begin{bmatrix} -C_2\\,\\Delta\\varepsilon_2 \\\\ C_2\\,\\Delta\\varepsilon_2 \\end{bmatrix}\n$$\n组装这些作用，得到全局切线算子的作用 $DR(u) \\cdot \\Delta u$：\n$$\n(DR(u)\\cdot\\Delta u)_1 = -C_1\\,\\Delta\\varepsilon_1 \\\\\n(DR(u)\\cdot\\Delta u)_2 = C_1\\,\\Delta\\varepsilon_1 - C_2\\,\\Delta\\varepsilon_2 \\\\\n(DR(u)\\cdot\\Delta u)_3 = C_2\\,\\Delta\\varepsilon_2\n$$\n\n**3. 算法步骤**\n\n对于由参数 $(E, \\alpha, u, \\Delta u)$ 定义的每种测试情况：\n1.  实现一个函数 `calculate_R_and_DRdu`，使用上述推导的公式计算 $R(u)$ 和 $DR(u)\\cdot\\Delta u$。\n2.  主测试函数遍历序列 $\\epsilon \\in \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}\\}$。\n3.  在每次迭代中，它计算扰动后的位移状态 $u_{\\epsilon} = u + \\epsilon\\,\\Delta u$。\n4.  它通过调用 `calculate_R_and_DRdu` 来计算扰动后状态的残差 $R(u_{\\epsilon})$。\n5.  它计算泰勒余项向量：$Res = R(u_{\\epsilon}) - R(u) - \\epsilon\\,(DR(u)\\cdot\\Delta u)$。\n6.  它计算测试比率 $\\rho(\\epsilon) = \\|Res\\|_2 / \\epsilon$。\n7.  计算出 $\\rho$ 值序列后，它验证该序列是否为非递增，即对于递减的 $\\epsilon$ 值序列，$\\rho(\\epsilon_i) \\le \\rho(\\epsilon_{i-1})$。这作为通过/失败的标准。\n\n特殊情况得到妥善处理：\n- 如果 $\\Delta u = 0$，余项显然为零，测试通过。\n- 如果 $\\alpha = 0$，问题是线性的。应力为 $\\sigma = E\\varepsilon$，残差 $R(u)$ 是 $u$ 的线性函数。泰勒余项解析上为零，导致 $\\rho$ 值序列为零（或数值上接近零），这是非递增的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_R_and_DRdu(u, delta_u, E, alpha):\n    \"\"\"\n    Computes the residual vector R(u) and the tangent action DR(u).du\n    for the 2-element, 3-node bar problem.\n\n    Args:\n        u (np.ndarray): The global nodal displacement vector of size 3.\n        delta_u (np.ndarray): The global nodal perturbation vector of size 3.\n        E (float): The Young's modulus.\n        alpha (float): The nonlinearity parameter.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the residual vector R(u)\n        and the tangent action vector DR(u).du.\n    \"\"\"\n    # Extract nodal displacements and perturbations\n    # Node indices are 0, 1, 2, corresponding to positions x=0, x=L/2, x=L.\n    u0, u1, u2 = u[0], u[1], u[2]\n    du0, du1, du2 = delta_u[0], delta_u[1], delta_u[2]\n\n    # Element properties are constant: L_e = 0.5, A = 1.\n    # The B-operator term B=[-1/L_e, 1/L_e] leads to a factor of 2.0.\n    B_factor = 2.0\n\n    # --- Element 1 (connects nodes 0 and 1) ---\n    eps1 = B_factor * (u1 - u0)\n    sigma1 = E * eps1 + alpha * eps1**3\n    C1 = E + 3.0 * alpha * eps1**2\n    delta_eps1 = B_factor * (du1 - du0)\n\n    # --- Element 2 (connects nodes 1 and 2) ---\n    eps2 = B_factor * (u2 - u1)\n    sigma2 = E * eps2 + alpha * eps2**3\n    C2 = E + 3.0 * alpha * eps2**2\n    delta_eps2 = B_factor * (du2 - du1)\n    \n    # Assemble Global Residual R(u)\n    # Element residual r_e = A*L_e*B^T*sigma_e = (1)*(0.5)*[-2, 2]^T*sigma_e = [-sigma_e, sigma_e]^T\n    R = np.array([\n        -sigma1,\n        sigma1 - sigma2,\n        sigma2\n    ])\n    \n    # Assemble Global Tangent Action DR(u).du\n    # Element action = A*L_e*B^T*C_e*delta_eps_e = [-C_e*delta_eps_e, C_e*delta_eps_e]^T\n    action1 = C1 * delta_eps1\n    action2 = C2 * delta_eps2\n    DRdu = np.array([\n        -action1,\n        action1 - action2,\n        action2\n    ])\n    \n    return R, DRdu\n\n\ndef run_taylor_test(params):\n    \"\"\"\n    Performs the Taylor remainder test for a given set of parameters.\n\n    Args:\n        params (tuple): A tuple containing (E, alpha, u, delta_u).\n\n    Returns:\n        bool: True if the test passes (rho sequence is nonincreasing), False otherwise.\n    \"\"\"\n    E, alpha, u_list, delta_u_list = params\n    u = np.array(u_list, dtype=np.float64)\n    delta_u = np.array(delta_u_list, dtype=np.float64)\n    \n    # Per the problem description, use this fixed sequence of epsilon values.\n    epsilons = [1e-1, 1e-2, 1e-3, 1e-4]\n    \n    # If the perturbation direction is the zero vector, the remainder is trivially zero.\n    if not np.any(delta_u):\n        return True\n\n    # Calculate the base residual R(u) and tangent action DR(u).du.\n    R_u, DR_du = calculate_R_and_DRdu(u, delta_u, E, alpha)\n\n    rho_vals = []\n    for eps in epsilons:\n        # Calculate the perturbed displacement state u_eps = u + eps * delta_u.\n        u_eps = u + eps * delta_u\n        \n        # Calculate the residual at the perturbed state, R(u_eps).\n        # We don't need the tangent action at u_eps, so the second return value is ignored.\n        R_u_eps, _ = calculate_R_and_DRdu(u_eps, delta_u, E, alpha)\n        \n        # Calculate the Taylor remainder vector.\n        remainder_vec = R_u_eps - R_u - eps * DR_du\n        \n        # Calculate its Euclidean norm.\n        remainder_norm = np.linalg.norm(remainder_vec)\n        \n        # Calculate the test ratio rho(epsilon).\n        # Division by eps is safe as it is always > 0.\n        rho = remainder_norm / eps\n        rho_vals.append(rho)\n\n    # Verify that the sequence of rho values is nonincreasing. This is the criterion for passing the test.\n    for i in range(1, len(rho_vals)):\n        # A small tolerance is added to account for floating-point noise,\n        # especially for cases where rho should be close to zero.\n        if rho_vals[i] > rho_vals[i-1] + 1e-9:\n            return False\n\n    return True\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Standard nonlinear case\n        (1000.0, 10.0, [0.0, 1e-3, 2e-3], [0.0, -5e-4, 3e-4]),\n        # Case 2: Linear case (alpha = 0)\n        (500.0, 0.0, [0.0, 1e-2, 2e-2], [2e-4, 1e-4, -1e-4]),\n        # Case 3: Trivial perturbation (delta_u = 0)\n        (1000.0, 50.0, [0.0, 2e-3, 3e-3], [0.0, 0.0, 0.0]),\n        # Case 4: Strong nonlinearity and larger displacements\n        (1000.0, 1000.0, [0.0, 1e-1, 2e-1], [0.0, 5e-2, -2e-2])\n    ]\n\n    results = []\n    for case in test_cases:\n        # Run the Taylor remainder test for each case.\n        result = run_taylor_test(case)\n        results.append(str(result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3578726"}, {"introduction": "手动推导和验证切线算子虽然是理解基本原理的必要步骤，但在现代计算实践中，我们还可以借助自动化工具来提高效率和可靠性。自动微分（Automatic Differentiation, AD）技术能够精确计算由代码定义的复杂函数的导数，从而避免了繁琐且易错的手动推导。本练习 [@problem_id:3578776] 将引导您同时使用手动推导和基于对偶数（dual numbers）的自动微分两种方法来计算非线性本构的切线刚度矩阵，并通过比对二者的结果来加深对切线算子本质的理解。", "problem": "您需要使用手动推导的表达式和通过对偶数实现的自动微分 (AD) 方法，在计算固体力学领域中实现并验证一维非线性杆单元的弱形式和残差的线性化。考虑一个用于轴向加载杆的单个双节点线性有限元，该杆具有恒定的横截面积和长度。未知量为节点轴向位移 $u_1$ 和 $u_2$，并集合成向量 $u = [u_1, u_2]^T$。本问题中的所有量均视为无量纲。\n\n从一维杆的平衡弱形式出发：通过代入有限元近似并使用轴向应变的定义，可以得到节点 $i$ 的离散残差。请使用以下具有坚实物理和数学基础的要素。\n\n- 离散残差向量 $R(u)$ 的分量 $R_i(u)$ 由内部虚功减去外部节点力定义，具体为 $R_i(u) = \\int_{0}^{L} A \\,\\sigma(\\varepsilon(u))\\,N_i'(x)\\,\\mathrm{d}x - F_i^{\\text{ext}}$，其中 $A$ 是恒定的横截面积，$L$ 是单元长度，$N_i'(x)$ 是节点 $i$ 处线性形函数的空间导数，$F_i^{\\text{ext}}$ 是施加在节点 $i$ 上的外部节点力。\n- 轴向应变定义为 $\\varepsilon(u) = \\dfrac{\\mathrm{d}u}{\\mathrm{d}x}$。对于双节点线性单元，这特化为 $\\varepsilon(u) = B\\,u$，其中 $B = \\left[-\\dfrac{1}{L}, \\dfrac{1}{L}\\right]$ 在整个单元上是常数。\n- 本构法则是非线性的、可微的、各向同性的材料模型，由 $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^3$ 给出，其中 $E$ 是弹性模量，$\\alpha$ 是一个控制三次非线性的实数材料参数。\n\n任务目标：\n\n1. 基于以上内容，手动推导一致切线矩阵 $K_{\\text{manual}}(u) = \\dfrac{\\partial R}{\\partial u}$，并用 $A$、$L$、$B$ 以及应力对应变的导数来表示。\n2. 使用通过对偶数实现的自动微分 (AD) 来实现 $K_{\\text{AD}}(u) = \\dfrac{\\partial R}{\\partial u}$。为 $u_1$ 和 $u_2$ 构造对偶变量，将它们通过残差计算进行传播，并提取雅可比矩阵。\n3. 对提供的每个测试用例，验证 $K_{\\text{AD}}$ 和 $K_{\\text{manual}}$ 的条目在严格的绝对容差内匹配，并且 $K_{\\text{AD}}$ 和 $K_{\\text{manual}}$ 都是对称的。用于逐项比较和对称性检查的容差必须为 $10^{-12}$。\n\n需遵守的实现细节：\n\n- 使用上面定义的离散残差，其中线性形函数使得 $B = \\left[-\\dfrac{1}{L}, \\dfrac{1}{L}\\right]$ 为常数。内力向量为 $f_{\\text{int}}(u) = \\int_{0}^{L} A\\,\\sigma(\\varepsilon(u))\\,B^T\\,\\mathrm{d}x$，残差为 $R(u) = f_{\\text{int}}(u) - f_{\\text{ext}}$，其中 $f_{\\text{ext}}$ 集合了外部节点力。为本问题之目的，使用单个右端节点力，以使 $f_{\\text{ext}} = [0, t]^T$，其中 $t$ 在测试用例中给出。\n- AD 实现必须使用导数向量长度为 2 的对偶数，以同时携带关于 $u_1$ 和 $u_2$ 的敏感度。为对偶数实现加法、减法、乘法、除法和整数次幂；不需要超越函数。\n\n测试套件：\n\n为以下参数集提供结果。对于每个案例，$E$、$\\alpha$、$L$、$A$、$u_1$、$u_2$ 和 $t$ 均已指定。\n\n- 案例 1：$E = 1000.0$, $\\alpha = 200.0$, $L = 2.0$, $A = 3.0$, $u_1 = 0.1$, $u_2 = 0.5$, $t = 50.0$。\n- 案例 2：$E = 1000.0$, $\\alpha = 0.0$, $L = 1.5$, $A = 1.2$, $u_1 = 0.3$, $u_2 = -0.1$, $t = -10.0$。\n- 案例 3：$E = 800.0$, $\\alpha = 50.0$, $L = 1.0$, $A = 0.8$, $u_1 = 0.0$, $u_2 = 0.0$, $t = 0.0$。\n- 案例 4：$E = 10.0$, $\\alpha = 1.0$, $L = 10^{-6}$, $A = 1.0$, $u_1 = 0.0$, $u_2 = 10^{-6}$, $t = 0.0$。\n- 案例 5：$E = 500.0$, $\\alpha = 30.0$, $L = 5.0$, $A = 2.5$, $u_1 = 1.0$, $u_2 = -2.0$, $t = 20.0$。\n\n答案规格：\n\n- 对于每个测试用例，计算 $K_{\\text{AD}}$ 和 $K_{\\text{manual}}$，评估最大的逐项绝对差值，检查每个矩阵的对称性，并生成一个包含四个条目的结果列表：$\\text{match}$（一个布尔值，表示最大绝对差值是否小于或等于 $10^{-12}$）、$\\text{sym\\_AD}$（一个布尔值，表示 $K_{\\text{AD}}$ 是否在 $10^{-12}$ 容差内对称）、$\\text{sym\\_manual}$（一个布尔值，表示 $K_{\\text{manual}}$ 是否在 $10^{-12}$ 容差内对称）和 $\\text{max\\_abs\\_diff}$（一个浮点数，给出最大逐项绝对差值）。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素本身是对应测试用例的四条目列表，顺序与上面列出的完全相同（例如，$[\\,[\\text{match}_1,\\text{sym\\_AD}_1,\\text{sym\\_manual}_1,\\text{max\\_abs\\_diff}_1],\\ldots\\,]$）。", "solution": "该问题被评估为有效。这是一个来自计算固体力学领域的适定的、科学合理且内部一致的问题。它提供了所有必要的定义、参数和明确的目标。其前提基于有限元法 (FEA) 和连续介质力学的既定原则。\n\n任务是使用两种方法——手动解析推导和自动微分 (AD)——计算非线性一维杆单元的一致切线刚度矩阵，并验证它们等价。\n\n### 1. 切线矩阵的解析推导 ($K_{\\text{manual}}$)\n\n该问题定义了具有节点位移 $u = [u_1, u_2]^T$ 的双节点单元的残差向量 $R(u) \\in \\mathbb{R}^2$ 为 $R(u) = f_{\\text{int}}(u) - f_{\\text{ext}}$。\n\n外力向量给定为 $f_{\\text{ext}} = [0, t]^T$。\n内力向量由 $f_{\\text{int}}(u) = \\int_{0}^{L} A\\,\\sigma(\\varepsilon(u))\\,B^T\\,\\mathrm{d}x$ 给出。\n\n对于长度为 $L$ 的双节点线性单元，轴向应变 $\\varepsilon$ 是恒定的，并由B矩阵公式给出：\n$$\n\\varepsilon = B u = \\begin{bmatrix} -\\frac{1}{L}  \\frac{1}{L} \\end{bmatrix} \\begin{bmatrix} u_1 \\\\ u_2 \\end{bmatrix} = \\frac{u_2 - u_1}{L}\n$$\n本构法则是 $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^3$，其中 $E$ 和 $\\alpha$ 是材料常数。\n\n由于 $A$、$\\sigma$ 和 $B$ 相对于空间坐标 $x$ 是常数，内力向量的积分简化为：\n$$\nf_{\\text{int}}(u) = A\\,\\sigma(\\varepsilon)\\,B^T \\int_{0}^{L} \\mathrm{d}x = A\\,L\\,\\sigma(\\varepsilon)\\,B^T\n$$\n代入 $B^T = \\begin{bmatrix} -1/L \\\\ 1/L \\end{bmatrix}$：\n$$\nf_{\\text{int}}(u) = A\\,L\\,\\sigma(\\varepsilon) \\begin{bmatrix} -1/L \\\\ 1/L \\end{bmatrix} = A\\,\\sigma(\\varepsilon) \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}\n$$\n因此，残差向量为：\n$$\nR(u) = \\begin{bmatrix} -A\\,\\sigma(\\varepsilon) \\\\ A\\,\\sigma(\\varepsilon) \\end{bmatrix} - \\begin{bmatrix} 0 \\\\ t \\end{bmatrix} = \\begin{bmatrix} -A\\,\\sigma(\\varepsilon) \\\\ A\\,\\sigma(\\varepsilon) - t \\end{bmatrix}\n$$\n\n一致切线矩阵 $K$ 是残差向量相对于位移向量 $u$ 的雅可比矩阵：\n$$\nK(u) = \\frac{\\partial R}{\\partial u} = \\begin{bmatrix} \\frac{\\partial R_1}{\\partial u_1}  \\frac{\\partial R_1}{\\partial u_2} \\\\ \\frac{\\partial R_2}{\\partial u_1}  \\frac{\\partial R_2}{\\partial u_2} \\end{bmatrix}\n$$\n由于 $f_{\\text{ext}}$ 相对于 $u$ 是常数，$\\frac{\\partial f_{\\text{ext}}}{\\partial u} = 0$。因此，$K(u) = \\frac{\\partial f_{\\text{int}}}{\\partial u}$。\n我们应用链式法则：\n$$\n\\frac{\\partial f_{\\text{int}}}{\\partial u} = \\frac{\\partial}{\\partial u} \\left( A\\,L\\,\\sigma(\\varepsilon(u))\\,B^T \\right) = A\\,L\\,B^T \\otimes \\frac{\\partial \\sigma}{\\partial u} = A\\,L\\,B^T \\otimes \\left( \\frac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon} \\frac{\\partial \\varepsilon}{\\partial u} \\right)\n$$\n其中 $\\otimes$ 表示外积。\n应力对应变的导数是材料切线模量 $E_t$：\n$$\nE_t(\\varepsilon) = \\frac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon} = \\frac{\\mathrm{d}}{\\mathrm{d}\\varepsilon}(E\\,\\varepsilon + \\alpha\\,\\varepsilon^3) = E + 3\\alpha\\varepsilon^2\n$$\n应变对位移向量的导数是B矩阵：\n$$\n\\frac{\\partial \\varepsilon}{\\partial u} = B = \\begin{bmatrix} -\\frac{1}{L}  \\frac{1}{L} \\end{bmatrix}\n$$\n将这些代入 $K(u)$ 的表达式中：\n$$\nK(u) = A\\,L\\,\\left( \\frac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon} \\right) B^T B = A\\,L\\,E_t(\\varepsilon)\\,B^T B\n$$\n矩阵乘积 $B^T B$ 是：\n$$\nB^T B = \\begin{bmatrix} -1/L \\\\ 1/L \\end{bmatrix} \\begin{bmatrix} -1/L  1/L \\end{bmatrix} = \\begin{bmatrix} 1/L^2  -1/L^2 \\\\ -1/L^2  1/L^2 \\end{bmatrix} = \\frac{1}{L^2} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n最后，手动推导的切线矩阵 $K_{\\text{manual}}$ 的表达式是：\n$$\nK_{\\text{manual}}(u) = A\\,L\\,(E + 3\\alpha\\varepsilon^2) \\frac{1}{L^2} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} = \\frac{A}{L}(E + 3\\alpha\\varepsilon^2) \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n其中 $\\varepsilon = (u_2 - u_1)/L$。该矩阵显然是对称的。\n\n### 2. 通过对偶数实现自动微分 (AD)\n\n自动微分是一种数值计算由计算机程序指定的函数导数的技术。我们使用基于对偶数的前向模式AD。对偶数是形如 $z = v + \\dot{v}\\epsilon$ 的对象，其中 $v$ 是值，$\\dot{v}$ 是导数，$\\epsilon$ 是一个无穷小量，使得 $\\epsilon^2 = 0$。对于多变量函数 $f(x_1, ..., x_n)$，导数部分可以是一个表示梯度的向量：$z = v + (\\nabla v)\\epsilon$。\n\n我们定义一个 `Dual` 数类来存储一个值及其导数向量。两个对偶数 $z_1 = (v_1, \\nabla v_1)$ 和 $z_2 = (v_2, \\nabla v_2)$ 的算术运算通过应用标准微积分法则来定义：\n- 加/减法：$z_1 \\pm z_2 = (v_1 \\pm v_2, \\nabla v_1 \\pm \\nabla v_2)$\n- 乘法：$z_1 \\cdot z_2 = (v_1 v_2, v_1 \\nabla v_2 + v_2 \\nabla v_1)$\n- 幂运算：$z_1^n = (v_1^n, n v_1^{n-1} \\nabla v_1)$\n\n要计算雅可比矩阵 $K_{\\text{AD}} = \\frac{\\partial R}{\\partial u}$，我们遵循以下步骤：\n1.  将输入位移 $u_1$ 和 $u_2$ 初始化为 `Dual` 数。导数“种子”是 $\\mathbb{R}^2$ 中的标准基向量：\n    -   $u_{1,\\text{dual}} = \\text{Dual}(u_1, [1.0, 0.0])$\n    -   $u_{2,\\text{dual}} = \\text{Dual}(u_2, [0.0, 1.0])$\n2.  通过计算残差向量 $R(u) = [R_1(u), R_2(u)]^T$ 的一系列操作来传播这些对偶数。这是通过编写一个使用 `Dual` 类的重载算术运算符的 $R(u)$ 函数来完成的。\n3.  计算得到残差分量为对偶数：\n    -   $R_{1,\\text{dual}} = (R_1(u), \\nabla_u R_1)$\n    -   $R_{2,\\text{dual}} = (R_2(u), \\nabla_u R_2)$\n4.  $R_{1,\\text{dual}}$ 的导数部分是雅可比矩阵的第一行，即 $[\\frac{\\partial R_1}{\\partial u_1}, \\frac{\\partial R_1}{\\partial u_2}]$。$R_{2,\\text{dual}}$ 的导数部分是第二行，即 $[\\frac{\\partial R_2}{\\partial u_1}, \\frac{\\partial R_2}{\\partial u_2}]$。将这些行组合起来得到完整的切线矩阵 $K_{\\text{AD}}$。\n\n### 3. 验证流程\n\n对于每个测试用例，我们计算 $K_{\\text{manual}}$ 和 $K_{\\text{AD}}$。验证包括两个检查：\n1.  **匹配性**：两个矩阵之间逐项绝对差的最大值与 $10^{-12}$ 的容差进行比较：\n    $$\n    \\text{max\\_abs\\_diff} = \\max_{i,j} |(K_{\\text{AD}})_{ij} - (K_{\\text{manual}})_{ij}| \\le 10^{-12}\n    $$\n2.  **对称性**：通过将每个矩阵与其转置进行比较来检查其对称性。最大绝对差值与相同的容差进行比较：\n    $$\n    \\max_ {i,j} |K_{ij} - K_{ji}| \\le 10^{-12}\n    $$\n每个案例的结果是一个包含三个布尔值和一个浮点数的列表：$[\\text{match}, \\text{sym\\_AD}, \\text{sym\\_manual}, \\text{max\\_abs\\_diff}]$。", "answer": "```python\nimport numpy as np\n\nclass Dual:\n    \"\"\"\n    A class to represent dual numbers for forward mode automatic differentiation.\n    The derivative component is a vector for multivariate functions.\n    \"\"\"\n    def __init__(self, value, deriv):\n        self.value = float(value)\n        self.deriv = np.asarray(deriv, dtype=float)\n\n    def __repr__(self):\n        return f\"Dual(value={self.value}, deriv={self.deriv})\"\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value + other.value, self.deriv + other.deriv)\n        return Dual(self.value + other, self.deriv)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value - other.value, self.deriv - other.deriv)\n        return Dual(self.value - other, self.deriv)\n\n    def __rsub__(self, other):\n        return Dual(other - self.value, -self.deriv)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value * other.value, self.value * other.deriv + other.value * self.deriv)\n        return Dual(self.value * other, self.deriv * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __truediv__(self, other):\n        if isinstance(other, Dual):\n            if other.value == 0:\n                raise ValueError(\"Division by a dual number with zero value.\")\n            val = self.value / other.value\n            der = (self.deriv * other.value - self.value * other.deriv) / (other.value**2)\n            return Dual(val, der)\n        if other == 0:\n            raise ValueError(\"Division by zero.\")\n        return Dual(self.value / other, self.deriv / other)\n\n    def __rtruediv__(self, other):\n        if self.value == 0:\n            raise ValueError(\"Division by a dual number with zero value.\")\n        val = other / self.value\n        der = (-other * self.deriv) / (self.value**2)\n        return Dual(val, der)\n\n    def __pow__(self, power):\n        if not isinstance(power, (int, float)):\n            raise TypeError(\"Power must be a number.\")\n        val = self.value ** power\n        der = power * (self.value ** (power - 1)) * self.deriv\n        return Dual(val, der)\n    \n    def __neg__(self):\n        return Dual(-self.value, -self.deriv)\n\ndef compute_k_manual(params):\n    \"\"\"\n    Computes the tangent stiffness matrix using the analytically derived formula.\n    \"\"\"\n    E, alpha, L, A, u1, u2, _ = params\n    \n    if L == 0:\n        raise ValueError(\"Length L cannot be zero.\")\n    \n    eps = (u2 - u1) / L\n    E_t = E + 3 * alpha * eps**2\n    factor = (A / L) * E_t\n    \n    K_manual = factor * np.array([[1.0, -1.0], [-1.0, 1.0]])\n    return K_manual\n\ndef compute_k_ad(params):\n    \"\"\"\n    Computes the tangent stiffness matrix using Automatic Differentiation with dual numbers.\n    \"\"\"\n    E, alpha, L, A, u1, u2, t = params\n    \n    if L == 0:\n        raise ValueError(\"Length L cannot be zero.\")\n\n    # Initialize input displacements as dual numbers\n    # The derivative \"seeds\" are the standard basis vectors in R^2\n    u1_d = Dual(u1, [1.0, 0.0])\n    u2_d = Dual(u2, [0.0, 1.0])\n\n    # Propagate dual numbers through residual calculation\n    # Strain\n    eps_d = (u2_d - u1_d) / L\n    \n    # Stress\n    sigma_d = E * eps_d + alpha * eps_d**3\n    \n    # Residual components R = f_int - f_ext\n    # R_1 = -A*sigma - 0\n    # R_2 = A*sigma - t\n    R1_d = -A * sigma_d\n    R2_d = A * sigma_d - t \n    \n    # The Jacobian is formed by the derivative parts of the final dual numbers\n    K_ad = np.vstack([R1_d.deriv, R2_d.deriv])\n    return K_ad\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (E,         alpha,   L,       A,     u1,   u2,        t)\n        (1000.0,    200.0,   2.0,     3.0,   0.1,  0.5,       50.0),\n        (1000.0,    0.0,     1.5,     1.2,   0.3,  -0.1,      -10.0),\n        (800.0,     50.0,    1.0,     0.8,   0.0,  0.0,       0.0),\n        (10.0,      1.0,     1.0e-6,  1.0,   0.0,  1.0e-6,    0.0),\n        (500.0,     30.0,    5.0,     2.5,   1.0,  -2.0,      20.0),\n    ]\n\n    results = []\n    TOL = 1.0e-12\n\n    for case in test_cases:\n        K_manual = compute_k_manual(case)\n        K_ad = compute_k_ad(case)\n\n        # 1. Compare K_ad and K_manual\n        max_abs_diff = np.max(np.abs(K_ad - K_manual))\n        match = max_abs_diff = TOL\n\n        # 2. Check symmetry of K_ad\n        sym_ad_diff = np.max(np.abs(K_ad - K_ad.T))\n        sym_ad = sym_ad_diff = TOL\n\n        # 3. Check symmetry of K_manual\n        sym_manual_diff = np.max(np.abs(K_manual - K_manual.T))\n        sym_manual = sym_manual_diff = TOL\n        \n        results.append([match, sym_ad, sym_manual, max_abs_diff])\n    \n    # Format the output string to be a list of lists with no spaces\n    inner_strs = [f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]\n    final_output = f\"[{','.join(inner_strs)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3578776"}]}