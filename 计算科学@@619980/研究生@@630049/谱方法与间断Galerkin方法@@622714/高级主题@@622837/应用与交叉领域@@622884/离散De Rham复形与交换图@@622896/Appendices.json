{"hands_on_practices": [{"introduction": "结构保持方法的基础是交换图性质，它是基本微积分定理的离散对应。本练习通过在简单的几何元素上实现离散余链和导数，将德拉姆复形的抽象代数与熟悉的斯托克斯定理和散度定理联系起来，从而对这一性质进行直接的动手验证。[@problem_id:3380459]", "problem": "考虑在一个简单的定向网格上，通过离散 de Rham 复形构建的麦克斯韦方程组的间断伽辽金 (DG) 离散化。设外微分 ($\\mathrm{d}$) 在不同次数的离散上链之间进行映射，交换投影 ($\\Pi_k$) 定义为将连续场积分到 $k$-上链上（$k=1$ 为边，$k=2$ 为面，$k=3$ 为体）。当 $\\Pi_k$ 由精确的线/面/体积分定义，且关联 ($\\mathrm{d}$) 通过定向边界和实现时，对于足够光滑的场，交换图性质表明 $\\mathrm{d}\\circ\\Pi_k = \\Pi_{k+1}\\circ \\mathrm{d}$。您将以斯托克斯定理和散度定理为基本依据，在一组人造场上对这些性质进行数值验证，同时在上链层面检查法拉第定律和高斯定律的积分恒等式。\n\n几何与定向：\n- 设一个定向三角形（一个 $2$-单纯形）由顶点 $v_0=(0,0,0)$、$v_1=(1,0,0)$、$v_2=(0,1,0)$ 定义，其正定向法向量 $\\boldsymbol{n}$ 指向 $+z$ 方向。其定向边界为逆时针方向的边循环 $(v_0\\rightarrow v_1)$、$(v_1\\rightarrow v_2)$、$(v_2\\rightarrow v_0)$。\n- 设一个定向四面体（一个 $3$-单纯形）由顶点 $v_0=(0,0,0)$、$v_1=(1,0,0)$、$v_2=(0,1,0)$、$v_3=(0,0,1)$ 定义，其定向由有序列表 $[v_0,v_1,v_2,v_3]$ 给出。其定向边界由顶点排序为 $(v_1,v_2,v_3)$、$(v_0,v_3,v_2)$、$(v_0,v_1,v_3)$、$(v_0,v_2,v_1)$ 的面组成，根据右手定则计算时，这些面对应于向外的法向量。对于一个顶点有序为 $(a,b,c)$ 的三角形，令其定向面积向量为 $\\boldsymbol{A} = \\tfrac{1}{2}(b-a)\\times(c-a)$，因此 $\\int_{\\text{face}} \\boldsymbol{n}\\, \\mathrm{d}S = \\boldsymbol{A}$。对于该四面体，其体积为 $V=\\tfrac{1}{6}\\left|\\det\\left([v_1-v_0, v_2-v_0, v_3-v_0]\\right)\\right|$。\n\n上链投影与离散外微分：\n- 对于光滑矢量场 $\\boldsymbol{E}(\\boldsymbol{x},t)$，通过在定向边上的线积分定义 $1$-上链投影：$\\Pi_1 \\boldsymbol{E}(e) = \\int_e \\boldsymbol{E}\\cdot \\mathrm{d}\\boldsymbol{l}$。\n- 对于光滑矢量场 $\\boldsymbol{B}(\\boldsymbol{x},t)$，通过在定向面上的曲面积分（通量）定义 $2$-上链投影：$\\Pi_2 \\boldsymbol{B}(f) = \\int_f \\boldsymbol{B}\\cdot \\boldsymbol{n}\\,\\mathrm{d}S$。\n- 对于光滑标量场 $q(\\boldsymbol{x},t)$，通过在定向胞腔上的体积分定义 $3$-上链投影：$\\Pi_3 q(c) = \\int_c q\\,\\mathrm{d}V$。\n- 离散外微分 $\\mathrm{d}$ 通过定向边界和作用：对于一个边界为边集 $\\partial f$ 的面 $f$，$(\\mathrm{d}\\Pi_1 \\boldsymbol{E})(f) = \\sum_{e\\in \\partial f} \\Pi_1 \\boldsymbol{E}(e)$；对于一个边界为面集 $\\partial c$ 的胞腔 $c$，$(\\mathrm{d}\\Pi_2 \\boldsymbol{B})(c) = \\sum_{f\\in \\partial c} \\Pi_2 \\boldsymbol{B}(f)$。\n\n需要验证的基本恒等式：\n- 斯托克斯定理：$\\int_f (\\nabla\\times \\boldsymbol{E})\\cdot \\boldsymbol{n}\\,\\mathrm{d}S = \\oint_{\\partial f} \\boldsymbol{E}\\cdot \\mathrm{d}\\boldsymbol{l}$，它在面上意味着交换性质 $\\mathrm{d}\\circ\\Pi_1 \\boldsymbol{E} = \\Pi_2 (\\nabla\\times\\boldsymbol{E})$。\n- 散度定理：$\\int_c (\\nabla\\cdot \\boldsymbol{B})\\,\\mathrm{d}V = \\int_{\\partial c} \\boldsymbol{B}\\cdot \\boldsymbol{n}\\,\\mathrm{d}S$，它在胞腔上意味着交换性质 $\\mathrm{d}\\circ\\Pi_2 \\boldsymbol{B} = \\Pi_3 (\\nabla\\cdot\\boldsymbol{B})$。\n- 积分形式的法拉第定律：$\\oint_{\\partial f} \\boldsymbol{E}\\cdot \\mathrm{d}\\boldsymbol{l} + \\dfrac{\\partial}{\\partial t}\\int_f \\boldsymbol{B}\\cdot \\boldsymbol{n}\\,\\mathrm{d}S = 0$。\n- 磁高斯定律：$\\int_c (\\nabla\\cdot \\boldsymbol{B})\\,\\mathrm{d}V = 0$。\n\n数值实现：\n- 对线段上的线积分使用中点法则，这对于线性场是精确的：对于从 $a$ 到 $b$ 的定向边，$\\int_e \\boldsymbol{E}\\cdot \\mathrm{d}\\boldsymbol{l} = \\boldsymbol{E}\\!\\left(\\tfrac{a+b}{2},t\\right)\\cdot (b-a)$。\n- 对三角形上的积分使用形心法则，这对于空间线性场是精确的：对于面 $(a,b,c)$，当 $\\boldsymbol{F}$ 在空间上是线性时，$\\int_f \\boldsymbol{F}\\cdot \\boldsymbol{n}\\,\\mathrm{d}S = \\boldsymbol{F}\\!\\left(\\tfrac{a+b+c}{3},t\\right)\\cdot \\boldsymbol{A}$。\n- 对四面体上的积分使用形心法则，这对于空间线性标量是精确的：对于胞腔 $c$，当 $q$ 在空间上是线性时，$\\int_c q\\,\\mathrm{d}V = q\\!\\left(\\tfrac{v_0+v_1+v_2+v_3}{4},t\\right)\\, V$。\n\n测试套件：\n对于每个测试用例，定义 $\\boldsymbol{E}$、其旋度 $\\nabla\\times\\boldsymbol{E}$、$\\boldsymbol{B}$、其散度 $\\nabla\\cdot\\boldsymbol{B}$、时间导数 $\\dfrac{\\partial \\boldsymbol{B}}{\\partial t}$ 和评估时间 $t$。所有场都是无量纲的（已作无量纲化处理），因此输出中不需要物理单位。\n\n- 情况 A (非平凡的麦克斯韦一致环流和零散度):\n  - $\\boldsymbol{E}(\\boldsymbol{x},t) = \\left(-\\dfrac{y}{2}, \\dfrac{x}{2}, 0\\right)$。\n  - $\\nabla\\times\\boldsymbol{E} = (0,0,1)$。\n  - $\\boldsymbol{B}(\\boldsymbol{x},t) = (0,0,-t)$。\n  - $\\nabla\\cdot\\boldsymbol{B} = 0$。\n  - $\\dfrac{\\partial \\boldsymbol{B}}{\\partial t} = (0,0,-1)$。\n  - $t=0.3$。\n- 情况 B (交换性质成立；麦克斯韦定律被违反):\n  - $\\boldsymbol{E}(\\boldsymbol{x},t) = (x,0,0)$。\n  - $\\nabla\\times\\boldsymbol{E} = (0,0,0)$。\n  - $\\boldsymbol{B}(\\boldsymbol{x},t) = \\left(x, \\dfrac{y}{2}, -\\dfrac{z}{4} + \\sin t\\right)$。\n  - $\\nabla\\cdot\\boldsymbol{B} = \\dfrac{\\partial}{\\partial x}x + \\dfrac{\\partial}{\\partial y}\\left(\\dfrac{y}{2}\\right) + \\dfrac{\\partial}{\\partial z}\\left(-\\dfrac{z}{4} + \\sin t\\right) = 1 + \\dfrac{1}{2} - \\dfrac{1}{4} = \\dfrac{5}{4}$。\n  - $\\dfrac{\\partial \\boldsymbol{B}}{\\partial t} = (0,0,\\cos t)$。\n  - $t=0.7$。\n- 情况 C (零场):\n  - $\\boldsymbol{E}(\\boldsymbol{x},t) = (0,0,0)$。\n  - $\\nabla\\times\\boldsymbol{E} = (0,0,0)$。\n  - $\\boldsymbol{B}(\\boldsymbol{x},t) = (0,0,0)$。\n  - $\\nabla\\cdot\\boldsymbol{B} = 0$。\n  - $\\dfrac{\\partial \\boldsymbol{B}}{\\partial t} = (0,0,0)$。\n  - $t=0$。\n\n程序要求：\n- 使用上述规则，在给定的定向三角形和四面体上实现上链投影和离散外微分。\n- 对每种情况，使用公差 $\\varepsilon=10^{-12}$ 计算四个布尔值检查：\n  1. 旋度的交换性：$\\left|(\\mathrm{d}\\circ \\Pi_1 \\boldsymbol{E})(\\text{face}) - \\Pi_2 (\\nabla\\times\\boldsymbol{E})(\\text{face})\\right| \\le \\varepsilon$。\n  2. 法拉第积分恒等式：$\\left|(\\mathrm{d}\\circ \\Pi_1 \\boldsymbol{E})(\\text{face}) + \\dfrac{\\partial}{\\partial t}\\Pi_2 \\boldsymbol{B}(\\text{face})\\right| \\le \\varepsilon$。\n  3. 散度的交换性：$\\left|(\\mathrm{d}\\circ \\Pi_2 \\boldsymbol{B})(\\text{cell}) - \\Pi_3 (\\nabla\\cdot\\boldsymbol{B})(\\text{cell})\\right| \\le \\varepsilon$。\n  4. 高斯定律：$\\left|\\Pi_3 (\\nabla\\cdot\\boldsymbol{B})(\\text{cell})\\right| \\le \\varepsilon$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_{12}]$），列表中的条目是情况 A、B 和 C 的十二个布尔值，顺序按照每个情况的四个检查顺序排列。\n\n解决方案应仅依赖于基本定理（斯托克斯定理和散度定理）、作为定向边界和的离散外微分定义，以及由线/面/体积分定义的精确投影算子。不允许外部输入。使用确定性算术和规定的公差进行比较。", "solution": "用户提供的问题陈述已经过分析并被认定为**有效**。它具有科学依据，问题定义明确，并且为获得唯一解提供了所有必要的数据和定义。该问题要求在单个三角形面和单个四面体胞腔上，对与离散 de Rham 复形相关的交换图性质和物理定律进行数值验证。所提供的场在空间变量上是线性的，对于这类场，指定的求积法则（中点法则和形心法则）是精确的。这确保了数值投影不是近似值，而是连续积分的精确计算，从而可以对代数结构进行精确测试。\n\n解决方案按以下步骤进行：\n1.  **定义几何实体**：将参考三角形和四面体的顶点定义为 `numpy` 数组。根据这些顶点，并遵循问题陈述中指定的定向，构造三角形的定向边和四面体的定向面。\n2.  **实现辅助几何函数**：实现用于计算三角形定向面积向量 $\\boldsymbol{A} = \\frac{1}{2}(b-a)\\times(c-a)$ 和四面体体积 $V=\\frac{1}{6}|\\det([v_1-v_0, v_2-v_0, v_3-v_0])|$ 的函数。这些对于投影算子至关重要。\n3.  **实现投影算子 ($\\Pi_k$)**：根据提供的数值积分法则，实现将连续场映射到离散上链的投影算子：\n    *   $\\Pi_1$：使用中点法则计算矢量场 $\\boldsymbol{E}$ 在边 $e=(a,b)$ 上的线积分：$\\Pi_1 \\boldsymbol{E}(e) = \\boldsymbol{E}(\\frac{a+b}{2}, t) \\cdot (b-a)$。\n    *   $\\Pi_2$：使用形心法则计算矢量场 $\\boldsymbol{F}$ 在三角形面 $f=(a,b,c)$ 上的曲面积分（通量）：$\\Pi_2 \\boldsymbol{F}(f) = \\boldsymbol{F}(\\frac{a+b+c}{3}, t) \\cdot \\boldsymbol{A}_f$。\n    *   $\\Pi_3$：使用形心法则计算标量场 $q$ 在四面体胞腔 $c=(v_0,v_1,v_2,v_3)$ 上的体积分：$\\Pi_3 q(c) = q(\\frac{v_0+v_1+v_2+v_3}{4}, t) \\cdot V_c$。\n4.  **实现离散外微分 ($\\mathrm{d}$)**：将离散外微分实现为边界元素上的定向和：\n    *   对于一个 $1$-上链（定义在边上的值），其在面 $f$ 上的微分为 $(\\mathrm{d}\\Pi_1 \\boldsymbol{E})(f) = \\sum_{e \\in \\partial f} \\Pi_1 \\boldsymbol{E}(e)$。该和是对面边界上的所有定向边求和。\n    *   对于一个 $2$-上链（定义在面上的值），其在胞腔 $c$ 上的微分为 $(\\mathrm{d}\\Pi_2 \\boldsymbol{B})(c) = \\sum_{f \\in \\partial c} \\Pi_2 \\boldsymbol{B}(f)$。该和是对胞腔边界上的所有定向面求和。\n5.  **定义场函数**：对于三个测试用例（A, B, C）中的每一个，将矢量场 $\\boldsymbol{E}(\\boldsymbol{x},t)$、$\\boldsymbol{B}(\\boldsymbol{x},t)$、它们的导数（$\\nabla\\times\\boldsymbol{E}$、$\\nabla\\cdot\\boldsymbol{B}$、$\\frac{\\partial\\boldsymbol{B}}{\\partial t}$）以及评估时间 $t$ 定义为 Python 函数。\n6.  **执行数值验证**：对每个测试用例，使用 $\\varepsilon = 10^{-12}$ 的公差执行四个指定的检查。\n    *   **检查 1（旋度的交换性）**：在三角形上验证 $\\mathrm{d}\\circ\\Pi_1 \\boldsymbol{E} = \\Pi_2(\\nabla\\times\\boldsymbol{E})$。这是斯托克斯定理的离散形式。由于基本定理成立且投影对于给定的线性场是精确的，因此预计此检查在所有情况下都会通过。\n    *   **检查 2（法拉第定律）**：验证 $(\\mathrm{d}\\circ \\Pi_1 \\boldsymbol{E})(f) + \\Pi_2 (\\frac{\\partial \\boldsymbol{B}}{\\partial t})(f) = 0$。这是法拉第感应定律的离散积分形式。仅当所提供的场 $\\boldsymbol{E}$ 和 $\\boldsymbol{B}$ 满足连续定律 $\\nabla\\times\\boldsymbol{E} = -\\frac{\\partial\\boldsymbol{B}}{\\partial t}$ 时，此式才成立。\n    *   **检查 3（散度的交换性）**：在四面体上验证 $\\mathrm{d}\\circ\\Pi_2 \\boldsymbol{B} = \\Pi_3(\\nabla\\cdot\\boldsymbol{B})$。这是散度定理的离散形式。与第一个检查类似，这是一个代数恒等式，在投影精确的情况下，应对所有情况都成立。\n    *   **检查 4（磁高斯定律）**：验证 $\\Pi_3(\\nabla\\cdot\\boldsymbol{B}) = 0$，这是连续定律 $\\nabla\\cdot\\boldsymbol{B}=0$ 的直接推论。此检查取决于给定的 $\\boldsymbol{B}$ 场是否无散。\n7.  **格式化输出**：将十二个布尔检查的结果（三个案例各四个）收集起来，并按要求格式化为单个字符串。\n\n计算按计划执行。对于情况 A，构造的场满足麦克斯韦方程组，因此所有四个检查都通过。对于情况 B，选择的场违反了法拉第定律和磁高斯定律，但交换图性质（纯粹是几何/代数性质）仍然成立。对于情况 C，所有场均为零，因此所有条件都平凡地满足。最终输出将反映这些理论预期。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the discrete de Rham complex verification problem.\n    \"\"\"\n    TOL = 1e-12\n\n    # --- 1. Define Geometric Entities ---\n    v0 = np.array([0.0, 0.0, 0.0])\n    v1 = np.array([1.0, 0.0, 0.0])\n    v2 = np.array([0.0, 1.0, 0.0])\n    v3 = np.array([0.0, 0.0, 1.0])\n\n    # Oriented triangle face and its boundary edges\n    triangle_face_geom = (v0, v1, v2)\n    triangle_edges_geom = [(v0, v1), (v1, v2), (v2, v0)]\n\n    # Oriented tetrahedron cell and its boundary faces\n    tetra_cell_geom = (v0, v1, v2, v3)\n    tetra_faces_geom = [(v1, v2, v3), (v0, v3, v2), (v0, v1, v3), (v0, v2, v1)]\n\n    # --- 2. Implement Auxiliary Geometric Functions ---\n    def area_vector(v_a, v_b, v_c):\n        return 0.5 * np.cross(v_b - v_a, v_c - v_a)\n\n    def volume(v0, v1, v2, v3):\n        mat = np.array([v1 - v0, v2 - v0, v3 - v0])\n        return np.abs(np.linalg.det(mat)) / 6.0\n\n    # --- 3. Implement Projection Operators ---\n    def pi_1(E_func, edge, t):\n        a, b = edge\n        midpoint = 0.5 * (a + b)\n        dl = b - a\n        E_val = E_func(midpoint, t)\n        return np.dot(E_val, dl)\n\n    def pi_2(F_func, face, t):\n        a, b, c = face\n        centroid = (a + b + c) / 3.0\n        A = area_vector(a, b, c)\n        F_val = F_func(centroid, t)\n        return np.dot(F_val, A)\n\n    def pi_3(q_func, cell, t):\n        v0, v1, v2, v3 = cell\n        centroid = (v0 + v1 + v2 + v3) / 4.0\n        V = volume(v0, v1, v2, v3)\n        q_val = q_func(centroid, t)\n        return q_val * V\n\n    # --- 4. Implement Discrete Exterior Derivative ---\n    def d_pi_1(E_func, edges, t):\n        total = 0.0\n        for edge in edges:\n            total += pi_1(E_func, edge, t)\n        return total\n\n    def d_pi_2(B_func, faces, t):\n        total = 0.0\n        for face in faces:\n            total += pi_2(B_func, face, t)\n        return total\n\n    # --- 5. Define Field Functions ---\n    test_cases = [\n        # Case A\n        {\n            \"E\": lambda x, t: np.array([-x[1]/2.0, x[0]/2.0, 0.0]),\n            \"curl_E\": lambda x, t: np.array([0.0, 0.0, 1.0]),\n            \"B\": lambda x, t: np.array([0.0, 0.0, -t]),\n            \"div_B\": lambda x, t: 0.0,\n            \"dB_dt\": lambda x, t: np.array([0.0, 0.0, -1.0]),\n            \"t\": 0.3\n        },\n        # Case B\n        {\n            \"E\": lambda x, t: np.array([x[0], 0.0, 0.0]),\n            \"curl_E\": lambda x, t: np.array([0.0, 0.0, 0.0]),\n            \"B\": lambda x, t: np.array([x[0], x[1]/2.0, -x[2]/4.0 + np.sin(t)]),\n            \"div_B\": lambda x, t: 1.25,\n            \"dB_dt\": lambda x, t: np.array([0.0, 0.0, np.cos(t)]),\n            \"t\": 0.7\n        },\n        # Case C\n        {\n            \"E\": lambda x, t: np.array([0.0, 0.0, 0.0]),\n            \"curl_E\": lambda x, t: np.array([0.0, 0.0, 0.0]),\n            \"B\": lambda x, t: np.array([0.0, 0.0, 0.0]),\n            \"div_B\": lambda x, t: 0.0,\n            \"dB_dt\": lambda x, t: np.array([0.0, 0.0, 0.0]),\n            \"t\": 0.0\n        }\n    ]\n\n    results = []\n    # --- 6. Perform Numerical Verification ---\n    for case in test_cases:\n        E_func = case[\"E\"]\n        curl_E_func = case[\"curl_E\"]\n        B_func = case[\"B\"]\n        div_B_func = case[\"div_B\"]\n        dB_dt_func = case[\"dB_dt\"]\n        t = case[\"t\"]\n\n        # Check 1: Commuting for curl on the triangle face\n        # | (d o Pi_1 E)(face) - Pi_2(curl E)(face) | = tol\n        d_pi_1_E_val = d_pi_1(E_func, triangle_edges_geom, t)\n        pi_2_curl_E_val = pi_2(curl_E_func, triangle_face_geom, t)\n        check1 = np.abs(d_pi_1_E_val - pi_2_curl_E_val) = TOL\n        results.append(check1)\n\n        # Check 2: Faraday integral identity on the triangle face\n        # | (d o Pi_1 E)(face) + d/dt(Pi_2 B)(face) | = tol\n        # d/dt(Pi_2 B) is implemented as Pi_2(dB/dt)\n        pi_2_dB_dt_val = pi_2(dB_dt_func, triangle_face_geom, t)\n        check2 = np.abs(d_pi_1_E_val + pi_2_dB_dt_val) = TOL\n        results.append(check2)\n\n        # Check 3: Commuting for divergence on the tetrahedron cell\n        # | (d o Pi_2 B)(cell) - Pi_3(div B)(cell) | = tol\n        d_pi_2_B_val = d_pi_2(B_func, tetra_faces_geom, t)\n        pi_3_div_B_val = pi_3(div_B_func, tetra_cell_geom, t)\n        check3 = np.abs(d_pi_2_B_val - pi_3_div_B_val) = TOL\n        results.append(check3)\n\n        # Check 4: Gauss's law for magnetism on the tetrahedron cell\n        # | Pi_3(div B)(cell) | = tol\n        check4 = np.abs(pi_3_div_B_val) = TOL\n        results.append(check4)\n\n    # --- 7. Format Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3380459"}, {"introduction": "虽然交换图在理论上是精确成立的，但实际的数值实现通常涉及近似，例如截断谱级数，这可能会引入误差。本练习让您能够量化这种谱稀疏化所产生的“交换亏格”和“拓扑误差”，从而具体理解近似误差如何影响底层数学结构的保持。[@problem_id:3380480]", "problem": "考虑区间 $[-1,1]$ 上的一维离散 de Rham 复形，其中 $0$-形式为标量函数 $u(x)$，$1$-形式为 $v(x)\\,\\mathrm{d}x$ 形式。外微分 $\\mathrm{d}$ 将一个 $0$-形式 $u$ 映射到一个 $1$-形式 $\\mathrm{d}u = u'(x)\\,\\mathrm{d}x$。在基于 Legendre 多项式的谱模态设置中，令 $\\{P_n(x)\\}_{n=0}^{\\infty}$ 表示 $[-1,1]$ 上的 Legendre 多项式序列，其关于单位权重的 $L^2([-1,1])$ 内积正交。对于一个截断阶数 $K \\in \\mathbb{N}$，定义到多项式空间 $V_K := \\mathrm{span}\\{P_0,\\dots,P_K\\}$ 上的模态截断（正交 $L^2$ 投影）算子 $\\Pi_K$ 为\n$$\n\\Pi_K u = \\sum_{n=0}^{K} a_n P_n(x), \\quad a_n = \\frac{2n+1}{2} \\int_{-1}^{1} u(x) P_n(x)\\,\\mathrm{d}x.\n$$\n类似地，对于 $1$-形式，定义到 $W_{K-1} := \\mathrm{span}\\{P_0,\\dots,P_{K-1}\\}$ 上的算子 $\\Pi_{K-1}$（在计算系数时忽略 $\\mathrm{d}x$ 因子）。谱模态稀疏化是通过截断到阶数 $K$ 来舍弃高频模态的操作，即令 $n  K$ 的系数 $a_n$ 为零。\n\n连续复形的交换图性质要求 $\\mathrm{d}\\,\\Pi_K u = \\Pi_{K-1}\\,\\mathrm{d}u$。当应用模态稀疏化时，对于非多项式函数 $u$，此性质通常不成立。我们希望量化由稀疏化引起的两个缺陷：\n\n1. 交换缺陷\n$$\n\\Delta_K(u) := \\left\\| \\mathrm{d}\\big(\\Pi_K u\\big) - \\Pi_{K-1}\\big(\\mathrm{d}u\\big) \\right\\|_{L^2([-1,1])},\n$$\n使用标准 $L^2$ 范数计算。\n\n2. 离散 Stokes 缺陷（一个拓扑误差的代理），\n$$\n\\Sigma_K(u) := \\left| \\int_{-1}^{1} \\Pi_{K-1}\\big(\\mathrm{d}u\\big)\\,\\mathrm{d}x - \\Big(\\big(\\Pi_K u\\big)(1) - \\big(\\Pi_K u\\big)(-1)\\Big) \\right|,\n$$\n它衡量了截断投影在保持微积分基本定理（Stokes 定理的一维实例）方面的失效程度。\n\n使用 Gauss-Legendre 求积来近似计算投影和范数所需的积分。假设所有三角函数中的角度均为弧度。所有模态展开和投影都必须使用 Legendre 多项式基。\n\n您的程序必须实现上述定义，并为下面的每个测试用例计算浮点数值对 $(\\Delta_K(u), \\Sigma_K(u))$。使用足够高的求积阶数，以使数值积分误差相对于报告值可以忽略不计。\n\n测试套件（每个用例指定 $u(x)$ 和 $K$）：\n\n- 用例 1：$u(x) = e^{x}$，$K=3$。\n- 用例 2：$u(x) = \\sin(7x)$，$K=5$。\n- 用例 3：$u(x) = x^{3} + e^{x}$，$K=7$。\n- 用例 4：$u(x) = 1$，$K=4$。\n- 用例 5：$u(x) = \\cos(50x)$，$K=8$。\n- 用例 6：$u(x) = x^{6} - 2x + 1$，$K=6$。\n\n对于每个用例，请完全按照定义计算 $\\Delta_K(u)$ 和 $\\Sigma_K(u)$。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序如下\n$$\n[\\Delta_{K_1}(u_1), \\Sigma_{K_1}(u_1), \\Delta_{K_2}(u_2), \\Sigma_{K_2}(u_2), \\dots, \\Delta_{K_6}(u_6), \\Sigma_{K_6}(u_6)]。\n$$\n没有物理单位。所有三角函数中的角度必须解释为弧度。最终输出必须是浮点数。", "solution": "用户提供了一个来自数值分析领域的问题，具体涉及谱方法和离散 de Rham 复形。任务是为给定的一组一维函数 $u(x)$ 和多项式截断阶数 $K$，计算交换缺陷 $\\Delta_K(u)$ 和离散 Stokes 缺陷 $\\Sigma_K(u)$ 这两个量。\n\n### **问题验证**\n\n1.  **提取已知条件**：\n    -   **定义域**：$x \\in [-1, 1]$。\n    -   **空间**：$0$-形式 $u(x)$，$1$-形式 $v(x)\\mathrm{d}x$。\n    -   **外微分**：$\\mathrm{d}u = u'(x)\\mathrm{d}x$。\n    -   **基**：Legendre 多项式 $P_n(x)$。\n    -   **多项式空间**：$V_K = \\mathrm{span}\\{P_0, \\dots, P_K\\}$ 和 $W_{K-1} = \\mathrm{span}\\{P_0, \\dots, P_{K-1}\\}$。\n    -   **投影算子 $\\Pi_K u$**：$\\sum_{n=0}^{K} a_n P_n(x)$，其中 $a_n = \\frac{2n+1}{2} \\int_{-1}^{1} u(x) P_n(x)\\,\\mathrm{d}x$。\n    -   **交换缺陷**：$\\Delta_K(u) := \\left\\| \\mathrm{d}\\big(\\Pi_K u\\big) - \\Pi_{K-1}\\big(\\mathrm{d}u\\big) \\right\\|_{L^2([-1,1])}$。\n    -   **离散 Stokes 缺陷**：$\\Sigma_K(u) := \\left| \\int_{-1}^{1} \\Pi_{K-1}\\big(\\mathrm{d}u\\big)\\,\\mathrm{d}x - \\Big(\\big(\\Pi_K u\\big)(1) - \\big(\\Pi_K u\\big)(-1)\\Big) \\right|$。\n    -   **数值方法**：对所有积分使用 Gauss-Legendre 求积。\n    -   **测试用例**：提供了六对 $(u(x), K)$。\n\n2.  **使用提取的已知条件进行验证**：\n    -   **科学依据**：该问题在谱方法和间断 Galerkin 方法的理论中有充分的依据。离散 de Rham 复形的概念以及离散算子交换性质的分析是现代数值偏微分方程中的标准课题。定义在数学上是严谨的。\n    -   **适定性**：对于每个测试用例，函数 $u(x)$ 都是光滑的，确保所有导数和积分都存在。缺陷的定义是明确的，对于给定的求积方案，可以得到唯一的数值结果。\n    -   **客观性**：问题以精确的数学公式和定义陈述，没有任何主观性。\n    -   该问题不违反任何无效性标准。使用“足够高的求积阶数”的指令是标准做法，表明实现应能稳健地应对数值积分误差。\n\n3.  **结论与行动**：\n    -   问题是**有效的**。将提供完整解决方案。\n\n### **解题推导**\n\n解决方案需要实现给定的定义。我们将首先根据 Legendre 展开系数推导这两个缺陷的解析表达式，而这些系数本身是通过数值计算得到的。\n\n令 $u(x)$ 为给定函数，$K$ 为截断阶数。$u$ 到 $V_K$ 上的投影的系数，记为 $\\Pi_K u = \\sum_{n=0}^{K} a_n P_n(x)$，由下式给出\n$$a_n = \\frac{2n+1}{2} \\int_{-1}^{1} u(x) P_n(x)\\,\\mathrm{d}x, \\quad n = 0, \\dots, K.$$\n类似地，导数 $u'(x)$ 到 $W_{K-1}$ 上的投影的系数，记为 $\\Pi_{K-1}(u') = \\sum_{m=0}^{K-1} b_m P_m(x)$，为\n$$b_m = \\frac{2m+1}{2} \\int_{-1}^{1} u'(x) P_m(x)\\,\\mathrm{d}x, \\quad m = 0, \\dots, K-1.$$\n这些积分使用 Gauss-Legendre 求积进行近似。令 $\\{x_i, w_i\\}_{i=1}^{N_q}$ 为足够高阶 $N_q$ 的求积点和权重。然后系数计算如下：\n$$a_n \\approx \\frac{2n+1}{2} \\sum_{i=1}^{N_q} w_i u(x_i) P_n(x_i)$$\n$$b_m \\approx \\frac{2m+1}{2} \\sum_{i=1}^{N_q} w_i u'(x_i) P_m(x_i)$$\n\n**1. 交换缺陷 $\\Delta_K(u)$**\n\n交换缺陷为 $\\Delta_K(u) = \\| (\\Pi_K u)' - \\Pi_{K-1}(u') \\|_{L^2}$。令 $D(x) = (\\Pi_K u)'(x) - \\Pi_{K-1}(u')(x)$。我们需要计算 $\\|D\\|_{L^2}$。\n\n第一项是 $(\\Pi_K u)'(x) = \\left(\\sum_{n=0}^{K} a_n P_n(x)\\right)' = \\sum_{n=1}^{K} a_n P'_n(x)$。\n我们使用 Legendre 多项式恒等式：$P'_n(x) = \\sum_{k=0, n-k \\text{ 为奇数}}^{n-1} (2k+1)P_k(x)$。\n代入此式可得：\n$$(\\Pi_K u)'(x) = \\sum_{n=1}^{K} a_n \\sum_{k=0, n-k \\text{ 为奇数}}^{n-1} (2k+1)P_k(x) = \\sum_{l=0}^{K-1} \\left( (2l+1) \\sum_{n=l+1, n-l \\text{ 为奇数}}^{K} a_n \\right) P_l(x)。$$\n我们将 $(\\Pi_K u)'$ 的 Legendre 系数记为 $c_l$，因此 $c_l = (2l+1) \\sum_{n=l+1, n-l \\text{ 为奇数}}^{K} a_n$。\n\n缺陷多项式为 $D(x) = \\sum_{l=0}^{K-1} c_l P_l(x) - \\sum_{l=0}^{K-1} b_l P_l(x) = \\sum_{l=0}^{K-1} (c_l - b_l) P_l(x)$。\n$L^2$ 范数使用 Legendre 多项式的正交性 $\\int_{-1}^1 P_l(x)P_j(x)\\,\\mathrm{d}x = \\frac{2}{2l+1}\\delta_{lj}$ 计算：\n$$\\Delta_K(u)^2 = \\|D\\|_{L^2}^2 = \\int_{-1}^1 \\left(\\sum_{l=0}^{K-1} (c_l - b_l) P_l(x)\\right)^2 \\mathrm{d}x = \\sum_{l=0}^{K-1} (c_l - b_l)^2 \\frac{2}{2l+1}。$$\n因此，交换缺陷为：\n$$\\Delta_K(u) = \\sqrt{\\sum_{l=0}^{K-1} \\frac{2}{2l+1} \\left( \\left( (2l+1) \\sum_{n=l+1, n-l \\text{ 为奇数}}^{K} a_n \\right) - b_l \\right)^2 }。$$\n\n**2. 离散 Stokes 缺陷 $\\Sigma_K(u)$**\n\nStokes 缺陷为 $\\Sigma_K(u) = \\left| \\int_{-1}^{1} \\Pi_{K-1}(u')\\,\\mathrm{d}x - \\Big((\\Pi_K u)(1) - (\\Pi_K u)(-1)\\Big) \\right|$。\n\n第一项是投影后导数的积分：\n$$\\int_{-1}^{1} \\Pi_{K-1}(u')\\,\\mathrm{d}x = \\int_{-1}^{1} \\sum_{m=0}^{K-1} b_m P_m(x)\\,\\mathrm{d}x = \\sum_{m=0}^{K-1} b_m \\int_{-1}^{1} P_m(x)\\,\\mathrm{d}x。$$\n由于性质 $\\int_{-1}^1 P_m(x)\\,\\mathrm{d}x = 2\\delta_{m0}$，该积分简化为 $2b_0$。\n\n第二项是投影函数在边界上的取值：\n$$(\\Pi_K u)(1) - (\\Pi_K u)(-1) = \\sum_{n=0}^{K} a_n P_n(1) - \\sum_{n=0}^{K} a_n P_n(-1) = \\sum_{n=0}^{K} a_n (P_n(1) - P_n(-1))。$$\n利用性质 $P_n(1)=1$ 和 $P_n(-1)=(-1)^n$，项 $(P_n(1) - P_n(-1))$ 为 $1 - (-1)^n$，当 $n$ 为奇数时等于 $2$，当 $n$ 为偶数时等于 $0$。\n因此，边界项简化为 $2 \\sum_{n=1, n \\text{ 为奇数}}^{K} a_n$。\n\n综合这些结果，Stokes 缺陷由下式给出：\n$$\\Sigma_K(u) = \\left| 2b_0 - 2\\sum_{n=1, n \\text{ 为奇数}}^{K} a_n \\right|。$$\n\n**数值策略**\n实现将遵循这些推导出的公式。将使用高阶 Gauss-Legendre 求积（例如，$N_q=200$ 个点）来计算系数 $a_n$ 和 $b_m$，以确保数值积分误差可以忽略不计。其余的计算是基于这些系数的解析计算。对于 $u(x)$ 是阶数 $N \\le K$ 的多项式的测试用例，两个缺陷在理论上都为零。这可以作为实现正确性的验证，因为任何非零结果都将归因于浮点精度限制。", "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import legval, legfit, Legendre, leggauss\nfrom typing import Callable, List, Tuple\n\ndef compute_defects(u_func: Callable[[np.ndarray], np.ndarray],\n                    u_prime_func: Callable[[np.ndarray], np.ndarray],\n                    K: int,\n                    N_q: int = 200) - Tuple[float, float]:\n    \"\"\"\n    Computes the commuting defect Delta_K and Stokes defect Sigma_K.\n\n    Args:\n        u_func: The function u(x).\n        u_prime_func: The derivative of the function, u'(x).\n        K: The truncation level for the polynomial space V_K.\n        N_q: The number of quadrature points for Gauss-Legendre integration.\n\n    Returns:\n        A tuple (Delta_K, Sigma_K).\n    \"\"\"\n\n    # 1. Setup Gauss-Legendre quadrature\n    x_q, w_q = leggauss(N_q)\n\n    # 2. Evaluate functions at quadrature points\n    u_vals = u_func(x_q)\n    u_prime_vals = u_prime_func(x_q)\n\n    # 3. Compute coefficients a_n for Pi_K(u)\n    a = np.zeros(K + 1)\n    for n in range(K + 1):\n        P_n_vals = legval(x_q, [0]*n + [1])\n        integral = np.sum(w_q * u_vals * P_n_vals)\n        a[n] = (2 * n + 1) / 2 * integral\n\n    # 4. Compute coefficients b_m for Pi_{K-1}(u')\n    b = np.zeros(K)\n    # The space is W_{K-1}, so projection is onto span{P_0, ..., P_{K-1}}\n    for m in range(K):\n        P_m_vals = legval(x_q, [0]*m + [1])\n        integral = np.sum(w_q * u_prime_vals * P_m_vals)\n        b[m] = (2 * m + 1) / 2 * integral\n\n    # 5. Compute the commuting defect Delta_K(u)\n    # Delta_K^2 = sum_{l=0}^{K-1} (2/(2l+1)) * (c_l - b_l)^2\n    # where c_l are the Legendre coeffs of (Pi_K u)'\n    \n    c = np.zeros(K)\n    for l in range(K):\n        sum_a = 0\n        # Sum over n from l+1 to K, where n-l is odd\n        for n in range(l + 1, K + 1):\n            if (n - l) % 2 == 1:\n                sum_a += a[n]\n        c[l] = (2 * l + 1) * sum_a\n\n    delta_sq = 0\n    for l in range(K):\n        delta_sq += (2 / (2 * l + 1)) * (c[l] - b[l])**2\n    delta = np.sqrt(delta_sq)\n\n    # 6. Compute the discrete Stokes defect Sigma_K(u)\n    # Sigma_K = | 2*b_0 - 2 * sum_{n odd, 1 to K} a_n |\n    \n    term1_sigma = 2 * b[0]\n\n    sum_a_odd = 0\n    for n in range(1, K + 1):\n        if n % 2 == 1:\n            sum_a_odd += a[n]\n    term2_sigma = 2 * sum_a_odd\n    \n    sigma = np.abs(term1_sigma - term2_sigma)\n\n    return delta, sigma\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite and prints the formatted output.\n    \"\"\"\n    test_cases = [\n        # Case 1: u(x) = e^x, K=3\n        {'u': lambda x: np.exp(x), 'u_prime': lambda x: np.exp(x), 'K': 3},\n        # Case 2: u(x) = sin(7x), K=5\n        {'u': lambda x: np.sin(7*x), 'u_prime': lambda x: 7*np.cos(7*x), 'K': 5},\n        # Case 3: u(x) = x^3 + e^x, K=7\n        {'u': lambda x: x**3 + np.exp(x), 'u_prime': lambda x: 3*x**2 + np.exp(x), 'K': 7},\n        # Case 4: u(x) = 1, K=4\n        {'u': lambda x: np.ones_like(x), 'u_prime': lambda x: np.zeros_like(x), 'K': 4},\n        # Case 5: u(x) = cos(50x), K=8\n        {'u': lambda x: np.cos(50*x), 'u_prime': lambda x: -50*np.sin(50*x), 'K': 8},\n        # Case 6: u(x) = x^6 - 2x + 1, K=6\n        {'u': lambda x: x**6 - 2*x + 1, 'u_prime': lambda x: 6*x**5 - 2, 'K': 6},\n    ]\n\n    results = []\n    # Use a high quadrature order to minimize integration error, especially for Case 5\n    quadrature_order = 400\n\n    for case in test_cases:\n        delta, sigma = compute_defects(case['u'], case['u_prime'], case['K'], N_q=quadrature_order)\n        results.extend([delta, sigma])\n\n    # Format the final output string\n    output_str = f\"[{','.join(f'{r:.10f}' for r in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3380480"}, {"introduction": "离散德拉姆框架的一个关键优势是它能够正确捕捉解的拓扑特征，这在电磁学和流体力学等领域至关重要。在这个高级练习中，您将在环面上实现一个谱方法来执行离散霍奇分解，从而数值验证该格式能够准确分离向量场的非平凡调和分量（上同调）。[@problem_id:3380435]", "problem": "您需要构建并验证一个关于二维平坦环面上离散 de Rham 复形的简单谱方法基准，其中使用一个包含非平凡调和分量的构造解。离散算子必须通过构造满足交换图性质，并且您的程序必须数值上验证交换关系以及通过 Hodge 分解恢复调和分量。\n\n工作在被视为平坦环面的周期性单位正方形域上，记为 $\\mathbb{T}^2 = [0,1)^2$，坐标为 $(x,y) \\in [0,1)^2$，并带有周期性边界条件。考虑以下二维空间中的连续 de Rham 序列：\n$$\n\\mathbb{R} \\xrightarrow{\\;\\subset\\;} H^1(\\mathbb{T}^2) \\xrightarrow{\\;\\nabla\\;} H(\\mathrm{curl};\\mathbb{T}^2) \\xrightarrow{\\;\\mathrm{curl}\\;} L^2(\\mathbb{T}^2) \\to 0,\n$$\n或者等价地，\n$$\n\\mathbb{R} \\xrightarrow{\\;\\subset\\;} H^1(\\mathbb{T}^2) \\xrightarrow{\\;\\nabla\\;} H(\\mathrm{div};\\mathbb{T}^2) \\xrightarrow{\\;\\mathrm{div}\\;} L^2(\\mathbb{T}^2) \\to 0,\n$$\n其中使用了标准的梯度算子 $\\nabla$、散度算子 $\\mathrm{div}$，以及二维中标量旋度算子，定义为 $\\mathrm{curl}\\,\\mathbf{v} = \\partial_x v_y - \\partial_y v_x$。$\\mathbb{T}^2$ 上的 Helmholtz–Hodge 分解指出，任何足够光滑的周期性向量场 $\\mathbf{u}$ 都可以唯一地分解为（在标量势中相差一个相加常数）：\n$$\n\\mathbf{u} = \\nabla \\phi + \\mathbf{J}\\,\\nabla \\psi + \\mathbf{h},\n$$\n其中 $\\phi,\\psi$ 是零均值标量势，$\\mathbf{J}$ 表示在平面上旋转 $+\\pi/2$，因此 $\\mathbf{J}\\,\\nabla \\psi = \\big(-\\partial_y \\psi,\\;\\partial_x \\psi\\big)$，而 $\\mathbf{h}$ 是一个常数向量场，张成代表第一 de Rham 上同调 $H^1(\\mathbb{T}^2) \\cong \\mathbb{R}^2$ 的调和子空间。\n\n您将通过一种全局模态谱方法来离散化此结构，该方法可以解释为 $\\mathbb{T}^2$ 上的单单元谱间断 Galerkin 空间，使用傅里叶基，并截断至由参数 $K \\in \\mathbb{N}$ 界定的整数频率。令 $\\mathcal{P}_K$ 表示到由 $\\exp\\!\\big(2\\pi i (k_x x + k_y y)\\big)$（其中整数指标满足 $\\max(|k_x|,|k_y|) \\le K$）张成的三角多项式上的 $L^2$-正交投影算子。通过傅里叶乘子定义离散算子：对于一个傅里葉变换为 $\\widehat{f}(k_x,k_y)$ 的标量场 $f$，离散梯度在傅里叶空间中通过乘以 $2\\pi i (k_x,k_y)$ 然后截断到 $\\mathcal{P}_K$ 的指标集给出；对于一个向量场 $\\mathbf{v}=(v_x,v_y)$，离散散度和标量旋度通过傅里叶乘子 $2\\pi i k_x$ 和 $2\\pi i k_y$ 类似地定义，然后截断到该指标集。$-\\Delta \\phi = g$ 的离散泊松求解器在傅里葉空間中通过在所有非零整数频率对 $(k_x,k_y)$ 上除以 $(2\\pi)^2(k_x^2 + k_y^2)$ 来定义，并将零模态设为零以强制零均值。\n\n从单个傅里叶模态和一个常数调和向量 $\\mathbf{h} \\in \\mathbb{R}^2$ 构造标量势 $\\phi$ 和 $\\psi$ 如下。对于给定的振幅 $A_\\phi, A_\\psi \\in \\mathbb{R}$ 和整数波数对 $(k_\\phi^x,k_\\phi^y)$ 及 $(k_\\psi^x,k_\\psi^y)$，定义\n- $\\phi(x,y) = A_\\phi \\cos\\!\\big(2\\pi k_\\phi^x x\\big)\\,\\sin\\!\\big(2\\pi k_\\phi^y y\\big)$,\n- $\\psi(x,y) = A_\\psi \\sin\\!\\big(2\\pi k_\\psi^x x\\big)\\,\\cos\\!\\big(2\\pi k_\\psi^y y\\big)$,\n- $\\mathbf{h} = (h_x,h_y)$ 是 $\\mathbb{R}^2$ 中的一个常数向量。\n\n然后定义精确的构造向量场\n$$\n\\mathbf{u}_{\\mathrm{exact}}(x,y) = \\nabla \\phi(x,y) + \\mathbf{J}\\,\\nabla \\psi(x,y) + \\mathbf{h},\n$$\n其中 $\\mathbf{J}\\,\\nabla \\psi = \\big(-\\partial_y \\psi,\\;\\partial_x \\psi\\big)$。在一个 $[0,1)^2$ 上的 $N \\times N$ 点均匀网格上工作，并以谱方法实现以下内容：\n- 用于标量和向量的投影算子 $\\mathcal{P}_K$，通过将截断指标集之外的傅里叶系数置零实现。\n- 离散梯度、散度和标量旋度，通过上述傅里叶乘子定义实现。\n- 用于零均值强迫项的离散泊松求解器，如上所述。\n\n验证任务：\n- 离散交换图检验。对于一个标量测试场 $f := \\phi + \\psi$，计算离散相对误差\n$$\n\\varepsilon_{\\nabla} = \\frac{\\left\\|\\mathcal{P}_K\\big(\\nabla f\\big) - \\nabla\\big(\\mathcal{P}_K f\\big)\\right\\|_{L^2}}{\\left\\|\\nabla\\big(\\mathcal{P}_K f\\big)\\right\\|_{L^2}},\n$$\n对于向量测试场 $\\mathbf{v} := \\mathbf{u}_{\\mathrm{exact}}$，计算\n$$\n\\varepsilon_{\\mathrm{div}} = \\frac{\\left\\|\\mathcal{P}_K\\big(\\mathrm{div}\\,\\mathbf{v}\\big) - \\mathrm{div}\\big(\\mathcal{P}_K \\mathbf{v}\\big)\\right\\|_{L^2}}{\\left\\|\\mathcal{P}_K\\big(\\mathrm{div}\\,\\mathbf{v}\\big)\\right\\|_{L^2}}.\n$$\n如果分母为零且分子也为零，则将相应的比值定义为 $0$。\n\n- 离散调和分量恢复检验。通过求解\n$$\n-\\Delta \\phi_h = \\mathrm{div}\\big(\\mathcal{P}_K \\mathbf{u}_{\\mathrm{exact}}\\big), \n\\qquad\n-\\Delta \\psi_h = \\mathrm{curl}\\big(\\mathcal{P}_K \\mathbf{u}_{\\mathrm{exact}}\\big),\n$$\n来计算 $\\mathcal{P}_K \\mathbf{u}_{\\mathrm{exact}}$ 的离散 Hodge 分解，其中 $\\phi_h, \\psi_h$ 为零均值，并将 $\\mathbf{h}_h$ 设为 $\\mathcal{P}_K \\mathbf{u}_{\\mathrm{exact}}$ 的空间平均值（零频模态）。定义相对调和误差\n$$\n\\varepsilon_{\\mathrm{harm}} = \n\\begin{cases}\n\\dfrac{\\|\\mathbf{h}_h - \\mathbf{h}\\|_{2}}{\\|\\mathbf{h}\\|_{2}},  \\text{if } \\|\\mathbf{h}\\|_2  0, \\\\\n\\|\\mathbf{h}_h\\|_{2},  \\text{if } \\|\\mathbf{h}\\|_2 = 0,\n\\end{cases}\n$$\n其中 $\\|\\cdot\\|_2$ 表示 $\\mathbb{R}^2$ 上的欧几里得范数。物理空间中的所有范数都应计算为与单位环面一致的 $L^2$ 范数，即幅值平方的空间平均值的平方根。\n\n您的程序必须实现这些构造，并在以下参数集测试套件上进行评估 $(N,K,A_\\phi,k_\\phi^x,k_\\phi^y,A_\\psi,k_\\psi^x,k_\\psi^y,h_x,h_y)$:\n- 案例 1 (一般混合内容): $(N,K) = (64,10)$, $A_\\phi = 0.7$, $(k_\\phi^x,k_\\phi^y)=(3,2)$, $A_\\psi = -0.4$, $(k_\\psi^x,k_\\psi^y)=(4,3)$, $\\mathbf{h}=(0.2,-0.1)$。\n- 案例 2 (纯调和场): $(N,K) = (64,10)$, $A_\\phi = 0$, $(k_\\phi^x,k_\\phi^y)=(1,1)$, $A_\\psi = 0$, $(k_\\psi^x,k_\\psi^y)=(1,1)$, $\\mathbf{h}=(0.05,0.3)$。\n- 案例 3 (分辨率边界): $(N,K) = (64,20)$, $A_\\phi = 1.0$, $(k_\\phi^x,k_\\phi^y)=(20,19)$, $A_\\psi = 0.5$, $(k_\\psi^x,k_\\psi^y)=(20,20)$, $\\mathbf{h}=(0,0)$。\n\n三角函数的角度参数以弧度为单位。本问题不涉及物理单位。\n\n您的程序应生成一行输出，包含一个逗号分隔的扁平列表形式的结果，并用方括号括起来，顺序如下\n$$\n\\big[\\max(\\varepsilon_{\\nabla},\\varepsilon_{\\mathrm{div}}),\\;\\varepsilon_{\\mathrm{harm}}\\big] \\text{ (案例 1)},\\; \\big[\\max(\\varepsilon_{\\nabla},\\varepsilon_{\\mathrm{div}}),\\;\\varepsilon_{\\mathrm{harm}}\\big] \\text{ (案例 2)},\\; \\big[\\max(\\varepsilon_{\\nabla},\\varepsilon_{\\mathrm{div}}),\\;\\varepsilon_{\\mathrm{harm}}\\big] \\text{ (案例 3)},\n$$\n扁平化为 $[c_1,h_1,c_2,h_2,c_3,h_3]$，其中 $c_j$ 表示案例 $j$ 的交换图误差，$h_j$ 表示案例 $j$ 的调和分量恢复误差。所有输出必须为浮点数。", "solution": "问题陈述已经过验证，并被认为是合理的。它为二维环面上的 de Rham 复形的傅里葉谱离散化提供了一个标准的验证练习。所有定义在数值分析中都是标准的，并且所提供的测试案例定义明确，适合用于验证实现。\n\n解答过程如下：\n首先，对于每个测试案例，我们建立计算网格和相应的整数波数网格。域是使用 $N \\times N$ 个点离散化的单位正方形 $[0,1)^2$。整数波数 $(k_x, k_y)$ 是使用 `numpy.fft.fftfreq` 获得的。\n\n其次，我们实现离散算子和投影算子 $\\mathcal{P}_K$。投影算子 $\\mathcal{P}_K$ 在傅里叶空间中通过创建一个掩码来作用，该掩码识别所有满足 $\\max(|k_x|, |k_y|)  K$ 的波数对 $(k_x, k_y)$，并将其对应的傅里葉系数设为零。离散微分算子（梯度 $\\nabla_K$、散度 $\\mathrm{div}_K$ 和标量旋度 $\\mathrm{curl}_K$）按规定实现：使用二维快速傅里叶变换 (FFT) 将场变换到傅里叶空间，乘以适当的傅里葉符号（例如，对于 $\\partial_x$ 是 $2\\pi i k_x$），通过将高频模态置零来使用 $\\mathcal{P}_K$进行投影，然后通过逆 FFT 变换回物理空间。\n\n第三，我们在网格上构造解析的构造解。计算标量势 $\\phi(x,y)$ 和 $\\psi(x,y)$。计算它们的解析导数以形成梯度部分 $\\nabla \\phi$ 和余梯度（旋转梯度）部分 $\\mathbf{J}\\,\\nabla \\psi$。将这些与常数调和向量 $\\mathbf{h}$ 结合，得到网格上的精确向量场 $\\mathbf{u}_{\\mathrm{exact}}$。\n\n第四，我们执行验证任务。\n\n对于交换图检验，我们计算两个误差 $\\varepsilon_{\\nabla}$ 和 $\\varepsilon_{\\mathrm{div}}$。\n对于 $\\varepsilon_{\\nabla}$，项 $\\mathcal{P}_K(\\nabla f)$ 是通过获取测试函数 $f = \\phi + \\psi$ 的解析梯度，在网格上求值，然后应用离散投影算子 $\\mathcal{P}_K$ 来计算的。项 $\\nabla(\\mathcal{P}_K f)$ 是通过首先将 $\\mathcal{P}_K$ 应用于网格函数 $f$，然后应用离散梯度算子 $\\nabla_K$ 来计算的。计算它们差的 $L^2$ 范数，并按规定进行归一化。对于 $\\varepsilon_{\\mathrm{div}}$ 也遵循类似的过程，使用测试向量场 $\\mathbf{v} = \\mathbf{u}_{\\mathrm{exact}}$ 及其解析散度 $\\mathrm{div}\\,\\mathbf{v} = \\Delta\\phi$。根据构造，由于测试案例中的所有构造解的傅里叶模态都在投影空间内（即，它们的波数 $(k_x, k_y)$ 满足 $\\max(|k_x|,|k_y|) \\le K$），这些交换误差预期在机器精度范围内为零。\n\n对于调和分量恢复检验，我们对投影场 $\\mathcal{P}_K \\mathbf{u}_{\\mathrm{exact}}$ 执行离散 Hodge 分解。调和分量 $\\mathbf{h}_h$ 是通过计算投影向量场的空间平均值（零频傅里叶模态）得到的。势分量通过求解两个离散泊松方程找到：$-\\Delta \\phi_h = \\mathrm{div}_K(\\mathcal{P}_K \\mathbf{u}_{\\mathrm{exact}})$ 和 $-\\Delta \\psi_h = \\mathrm{curl}_K(\\mathcal{P}_K \\mathbf{u}_{\\mathrm{exact}})$。泊松方程通过将右侧项的傅里叶变换除以负拉普拉斯算子的傅里叶符号（即 $(2\\pi)^2(k_x^2 + k_y^2)$）来以谱方法求解，并注意通过对势 $\\phi_h$ 和 $\\psi_h$ 施加零均值条件来正确处理零频模态。然后计算计算出的调和部分 $\\mathbf{h}_h$ 和精确部分 $\\mathbf{h}$ 之间的相对误差 $\\varepsilon_{\\mathrm{harm}}$。这个误差也预期接近于零。\n\n所有的 $L^2$ 范数都在物理空间中计算，作为网格函数值的均方根，这与单位环面上的积分是一致的。对三个测试案例中的每一个都执行了计算，并按要求收集和格式化了结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to construct and verify the spectral benchmark, evaluating\n    all test cases and printing the results in the specified format.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (general mixed content):\n        # (N, K, A_phi, k_phi_x, k_phi_y, A_psi, k_psi_x, k_psi_y, h_x, h_y)\n        (64, 10, 0.7, 3, 2, -0.4, 4, 3, 0.2, -0.1),\n        # Case 2 (purely harmonic field):\n        (64, 10, 0.0, 1, 1, 0.0, 1, 1, 0.05, 0.3),\n        # Case 3 (boundary of resolution):\n        (64, 20, 1.0, 20, 19, 0.5, 20, 20, 0.0, 0.0),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        comm_err, harm_err = solve_case(case_params)\n        results.extend([comm_err, harm_err])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_case(params):\n    \"\"\"\n    Implements the full construction and verification for a single test case.\n    \n    Args:\n        params (tuple): A tuple containing all parameters for the test case.\n    \n    Returns:\n        tuple: A tuple containing the commuting diagram error and the harmonic recovery error.\n    \"\"\"\n    N, K, A_phi, k_phi_x, k_phi_y, A_psi, k_psi_x, k_psi_y, h_x, h_y = params\n\n    # 1. Grid and Wavenumbers\n    x = np.linspace(0, 1, N, endpoint=False)\n    y = np.linspace(0, 1, N, endpoint=False)\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # Integer wavenumbers kx, ky from FFT frequencies\n    k_int_x = (np.fft.fftfreq(N) * N).astype(np.int32)\n    k_int_y = (np.fft.fftfreq(N) * N).astype(np.int32)\n    k_int_x_m, k_int_y_m = np.meshgrid(k_int_x, k_int_y, indexing='ij')\n\n    # 2. Discrete Operators and Projector\n    # Mask for projector P_K: max(|kx|, |ky|) = K\n    proj_mask = (np.abs(k_int_x_m) > K) | (np.abs(k_int_y_m) > K)\n\n    def project_fourier(f_hat):\n        f_hat_proj = f_hat.copy()\n        f_hat_proj[proj_mask] = 0\n        return f_hat_proj\n\n    def project_physical(f):\n        return np.fft.ifft2(project_fourier(np.fft.fft2(f)))\n\n    def grad_k(f):\n        f_hat = np.fft.fft2(f)\n        grad_x_hat = 1j * 2 * np.pi * k_int_x_m * f_hat\n        grad_y_hat = 1j * 2 * np.pi * k_int_y_m * f_hat\n        grad_x = np.fft.ifft2(project_fourier(grad_x_hat))\n        grad_y = np.fft.ifft2(project_fourier(grad_y_hat))\n        return grad_x, grad_y\n\n    def div_k(vx, vy):\n        vx_hat = np.fft.fft2(vx)\n        vy_hat = np.fft.fft2(vy)\n        div_hat = 1j * 2 * np.pi * k_int_x_m * vx_hat + 1j * 2 * np.pi * k_int_y_m * vy_hat\n        return np.fft.ifft2(project_fourier(div_hat))\n    \n    def curl_k(vx, vy):\n        vx_hat = np.fft.fft2(vx)\n        vy_hat = np.fft.fft2(vy)\n        curl_hat = 1j * 2 * np.pi * k_int_x_m * vy_hat - 1j * 2 * np.pi * k_int_y_m * vx_hat\n        return np.fft.ifft2(project_fourier(curl_hat))\n    \n    # L2 norms consistent with the unit torus (root-mean-square)\n    def l2_norm_scalar(f):\n        return np.sqrt(np.mean(np.abs(f)**2))\n\n    def l2_norm_vector(fx, fy):\n        return np.sqrt(np.mean(np.abs(fx)**2 + np.abs(fy)**2))\n\n    # 3. Manufactured Solution\n    phi = A_phi * np.cos(2*np.pi*k_phi_x*xx) * np.sin(2*np.pi*k_phi_y*yy)\n    psi = A_psi * np.sin(2*np.pi*k_psi_x*xx) * np.cos(2*np.pi*k_psi_y*yy)\n\n    grad_phi_x = -A_phi * (2*np.pi*k_phi_x) * np.sin(2*np.pi*k_phi_x*xx) * np.sin(2*np.pi*k_phi_y*yy)\n    grad_phi_y =  A_phi * (2*np.pi*k_phi_y) * np.cos(2*np.pi*k_phi_x*xx) * np.cos(2*np.pi*k_phi_y*yy)\n    J_grad_psi_x =  A_psi * (2*np.pi*k_psi_y) * np.sin(2*np.pi*k_psi_x*xx) * np.sin(2*np.pi*k_psi_y*yy)\n    J_grad_psi_y =  A_psi * (2*np.pi*k_psi_x) * np.cos(2*np.pi*k_psi_x*xx) * np.cos(2*np.pi*k_psi_y*yy)\n    \n    u_exact_x = grad_phi_x + J_grad_psi_x + h_x\n    u_exact_y = grad_phi_y + J_grad_psi_y + h_y\n\n    # 4. Verification Tasks\n    # 4.1. Commuting Diagram Errors\n    # Error for gradient: eps_nabla\n    f_test = phi + psi\n    grad_psi_x =  A_psi * (2*np.pi*k_psi_x) * np.cos(2*np.pi*k_psi_x*xx) * np.cos(2*np.pi*k_psi_y*yy)\n    grad_psi_y = -A_psi * (2*np.pi*k_psi_y) * np.sin(2*np.pi*k_psi_x*xx) * np.sin(2*np.pi*k_psi_y*yy)\n    \n    grad_f_exact_x = grad_phi_x + grad_psi_x\n    grad_f_exact_y = grad_phi_y + grad_psi_y\n\n    LHS_nabla_x = project_physical(grad_f_exact_x)\n    LHS_nabla_y = project_physical(grad_f_exact_y)\n    f_test_proj = project_physical(f_test)\n    RHS_nabla_x, RHS_nabla_y = grad_k(f_test_proj)\n    \n    num_nabla = l2_norm_vector(LHS_nabla_x - RHS_nabla_x, LHS_nabla_y - RHS_nabla_y)\n    den_nabla = l2_norm_vector(RHS_nabla_x, RHS_nabla_y)\n    eps_nabla = num_nabla / den_nabla if den_nabla > 1e-15 else 0.0\n\n    # Error for divergence: eps_div\n    div_v_exact = -A_phi * (2*np.pi)**2 * (k_phi_x**2 + k_phi_y**2) * np.cos(2*np.pi*k_phi_x*xx) * np.sin(2*np.pi*k_phi_y*yy)\n    LHS_div = project_physical(div_v_exact)\n    v_test_proj_x = project_physical(u_exact_x)\n    v_test_proj_y = project_physical(u_exact_y)\n    RHS_div = div_k(v_test_proj_x, v_test_proj_y)\n    \n    num_div = l2_norm_scalar(LHS_div - RHS_div)\n    den_div = l2_norm_scalar(LHS_div)\n    eps_div = num_div / den_div if den_div > 1e-15 else 0.0\n    \n    comm_err = max(eps_nabla, eps_div)\n\n    # 4.2. Harmonic Recovery\n    u_proj_x = project_physical(u_exact_x)\n    u_proj_y = project_physical(u_exact_y)\n    \n    g_poisson = div_k(u_proj_x, u_proj_y)\n    rho_poisson = curl_k(u_proj_x, u_proj_y)\n    \n    g_hat = np.fft.fft2(g_poisson)\n    rho_hat = np.fft.fft2(rho_poisson)\n\n    inv_lap_denom = (2*np.pi*k_int_x_m)**2 + (2*np.pi*k_int_y_m)**2\n    with np.errstate(divide='ignore', invalid='ignore'):\n        phi_h_hat = g_hat / inv_lap_denom\n        psi_h_hat = rho_hat / inv_lap_denom\n    phi_h_hat[0, 0] = 0.0\n    psi_h_hat[0, 0] = 0.0\n\n    h_h_x = np.mean(u_proj_x).real\n    h_h_y = np.mean(u_proj_y).real\n    h_h = np.array([h_h_x, h_h_y])\n    h_exact = np.array([h_x, h_y])\n    \n    h_norm = np.linalg.norm(h_exact)\n    if h_norm > 1e-15:\n        harm_err = np.linalg.norm(h_h - h_exact) / h_norm\n    else:\n        harm_err = np.linalg.norm(h_h)\n\n    return comm_err, harm_err\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3380435"}]}