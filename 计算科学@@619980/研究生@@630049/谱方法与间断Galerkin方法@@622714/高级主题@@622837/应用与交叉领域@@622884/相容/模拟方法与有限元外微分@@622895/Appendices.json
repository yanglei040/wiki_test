{"hands_on_practices": [{"introduction": "这项练习是基础的第一步。它要求您为一个简单的三角形单元手动构建有限元外微分（FEEC）的基本模块——关联矩阵和质量矩阵。通过计算离散余微分算子 $\\delta_h$ 的作用，您将具体体验到这个作为外导数伴随算子的关键工具是如何在计算中实现的。[@problem_id:3372195]", "problem": "考虑平面上的一个单一三角形网格，该网格由一个等边三角形构成，其顶点为 $v_{1}=(0,0)$、$v_{2}=(1,0)$ 和 $v_{3}=\\left(\\frac{1}{2},\\frac{\\sqrt{3}}{2}\\right)$。设定定向边为从 $v_{1}$ 到 $v_{2}$ 的 $e_{12}$、从 $v_{2}$ 到 $v_{3}$ 的 $e_{23}$ 以及从 $v_{3}$ 到 $v_{1}$ 的 $e_{31}$，并通过顶点排序 $(v_{1},v_{2},v_{3})$ 来定向该面。在 $\\mathbb{R}^{2}$ 上使用标准的欧几里得度量。\n\n使用有限元外微分（FEEC）的框架，令 $\\{\\lambda_{i}\\}_{i=1}^{3}$ 表示重心坐标函数（Whitney 0-形式），并定义与定向边相关联的 Whitney 1-形式为\n$$\nW_{ij}=\\lambda_{i}\\,\\mathrm{d}\\lambda_{j}-\\lambda_{j}\\,\\mathrm{d}\\lambda_{i}.\n$$\n定义离散余微分 $\\delta_{h}$ 为离散外微分关于由 Whitney 形式诱导的 $L^{2}$ 内积的伴随算子；也就是说，组装原始关联矩阵 $D_{0}$，并将 Whitney 0-形式和 1-形式上的离散霍奇星算子计算为相应的 $L^{2}$ 质量矩阵。然后，将 $\\delta_{h}$ 应用于 1-上链 $x\\in\\mathbb{R}^{3}$，其在定向边基 $\\{e_{12},e_{23},e_{31}\\}$ 上的系数为 $(1,0,0)$。\n\n计算向量 $\\delta_{h}x$ 中对应于顶点 $v_{2}$ 的分量。将最终答案表示为精确数，无需四舍五入。", "solution": "用户需要计算离散余微分算子 $\\delta_{h}$ 应用于一个给定的 1-上链后所得向量的特定分量。该问题设置在单个等边三角形上的有限元外微分（FEEC）背景下。\n\n### 步骤1：问题验证\n\n该问题是数值分析和计算数学领域内（特别是 FEEC）一个定义明确的数学练习。\n- **已知条件**：\n    - 单个二维网格单元：一个等边三角形 $T$。\n    - 顶点：$v_{1}=(0,0)$、$v_{2}=(1,0)$ 和 $v_{3}=(\\frac{1}{2},\\frac{\\sqrt{3}}{2})$。边长为 $s=1$。\n    - 定向边：$e_{12}$（从 $v_{1}$ 到 $v_{2}$）、$e_{23}$（从 $v_{2}$ 到 $v_{3}$）和 $e_{31}$（从 $v_{3}$ 到 $v_{1}$）。\n    - 0-形式的基（顶点上的函数）：Whitney 0-形式 $\\{\\lambda_i\\}_{i=1}^3$，即重心坐标。\n    - 1-形式的基（边上的函数）：与定向边对应的 Whitney 1-形式 $\\{W_{12}, W_{23}, W_{31}\\}$。$W_{ij} = \\lambda_i d\\lambda_j - \\lambda_j d\\lambda_i$。\n    - 离散余微分 $\\delta_h$ 定义为离散外微分 $d_h$ 关于 $L^2$ 内积的伴随算子。\n    - 输入为 1-上链 $x$，其在边基 $\\{e_{12}, e_{23}, e_{31}\\}$ 上的系数为 $(1,0,0)$。\n- **验证结论**：该问题具有科学依据、良定、客观且自洽。它依赖于 FEEC 的标准定义。计算是可行的。因此，该问题被视为**有效**。\n\n### 步骤2：离散余微分的公式化\n\n离散余微分 $\\delta_{h,1}: C^1 \\to C^0$ 将 1-上链（1-形式的系数向量）映射到 0-上链（0-形式的系数向量）。它被定义为离散外微分 $d_{h,0}: C^0 \\to C^1$ 关于 $L^2$ 内积的伴随算子。这些内积由质量矩阵表示。\n\n设 $u \\in C^0$ 为一个 0-上链，$v \\in C^1$ 为一个 1-上链。伴随关系为：\n$$\n\\langle d_{h,0} u, v \\rangle_1 = \\langle u, \\delta_{h,1} v \\rangle_0\n$$\n用矩阵表示，设 $D_0$ 是表示 $d_{h,0}$ 的关联矩阵。设 $M_0$ 和 $M_1$ 分别是 0-形式和 1-形式的质量矩阵。内积定义为 $\\langle a,b \\rangle_k = a^T M_k b$。伴随关系变为：\n$$\n(D_0 u)^T M_1 v = u^T M_0 (\\delta_{h,1} v)\n$$\n$$\nu^T D_0^T M_1 v = u^T M_0 (\\delta_{h,1} v)\n$$\n因为此式必须对所有 $u$ 成立，我们有：\n$$\nD_0^T M_1 v = M_0 (\\delta_{h,1} v)\n$$\n求解上链 $\\delta_{h,1} v$，我们得到其矩阵表示：\n$$\n\\delta_{h,1} v = M_0^{-1} D_0^T M_1 v\n$$\n我们的目标是计算 $y = \\delta_{h,1} x$，其中 $x = (1, 0, 0)^T$。\n\n### 步骤3：组装矩阵\n\n我们需要组装矩阵 $D_0$、$M_0$ 和 $M_1$。\n\n**A. 关联矩阵 $D_0$**\n$D_0$ 是一个 $3 \\times 3$ 的矩阵，将顶点映射到边。列对应于顶点 $(v_1, v_2, v_3)$，行对应于定向边 $(e_{12}, e_{23}, e_{31})$。\n- 对于边 $e_{12}$（从 $v_1$ 到 $v_2$）：行为 $(-1, 1, 0)$。\n- 对于边 $e_{23}$（从 $v_2$ 到 $v_3$）：行为 $(0, -1, 1)$。\n- 对于边 $e_{31}$（从 $v_3$ 到 $v_1$）：行为 $(1, 0, -1)$。\n$$\nD_0 = \\begin{pmatrix}\n-1  1  0 \\\\\n0  -1  1 \\\\\n1  0  -1\n\\end{pmatrix}\n$$\n其转置为：\n$$\nD_0^T = \\begin{pmatrix}\n-1  0  1 \\\\\n1  -1  0 \\\\\n0  1  -1\n\\end{pmatrix}\n$$\n\n**B. 0-形式的质量矩阵 $M_0$**\n矩阵项为 $(M_0)_{ij} = \\int_T \\lambda_i \\lambda_j \\, dA$。边长为 $s=1$ 的等边三角形的面积为 $A = \\frac{\\sqrt{3}}{4}s^2 = \\frac{\\sqrt{3}}{4}$。使用在面积为 $A$ 的三角形上关于重心坐标的标准积分公式：\n$$\n\\int_T \\lambda_i^p \\lambda_j^q \\lambda_k^r \\, dA = \\frac{p! q! r! 2!}{(p+q+r+2)!} A\n$$\n- 对角元素：$\\int_T \\lambda_i^2 \\, dA = \\frac{2!0!0!2!}{(2+2)!} A = \\frac{4}{24} A = \\frac{A}{6}$。\n- 非对角元素：$\\int_T \\lambda_i \\lambda_j \\, dA = \\frac{1!1!0!2!}{(1+1+2)!} A = \\frac{2}{24} A = \\frac{A}{12}$。\n所以质量矩阵是：\n$$\nM_0 = \\frac{A}{12} \\begin{pmatrix}\n2  1  1 \\\\\n1  2  1 \\\\\n1  1  2\n\\end{pmatrix} = \\frac{\\sqrt{3}}{48} \\begin{pmatrix}\n2  1  1 \\\\\n1  2  1 \\\\\n1  1  2\n\\end{pmatrix}\n$$\n\n**C. 1-形式的质量矩阵 $M_1$**\n矩阵项为 $(M_1)_{IJ} = \\int_T W_I \\cdot W_J \\, dA$，其中 $I, J$ 来自边基 $\\{e_{12}, e_{23}, e_{31}\\}$。点积由欧几里得度量诱导。对于一个等边三角形，$\\nabla\\lambda_i \\cdot \\nabla\\lambda_j = -2/3$ ($i \\ne j$) 且 $|\\nabla\\lambda_i|^2 = 4/3$。\n- 对角元素 $(M_1)_{11} = \\int_T W_{12} \\cdot W_{12} \\, dA$：\n$$\n\\int_T (\\lambda_1 \\nabla\\lambda_2 - \\lambda_2 \\nabla\\lambda_1) \\cdot (\\lambda_1 \\nabla\\lambda_2 - \\lambda_2 \\nabla\\lambda_1) \\, dA = \\int_T (\\lambda_1^2 |\\nabla\\lambda_2|^2 - 2\\lambda_1\\lambda_2(\\nabla\\lambda_1\\cdot\\nabla\\lambda_2) + \\lambda_2^2|\\nabla\\lambda_1|^2) \\, dA\n$$\n$$\n= \\frac{4}{3}\\int_T \\lambda_1^2 \\, dA + \\frac{4}{3}\\int_T \\lambda_1\\lambda_2 \\, dA + \\frac{4}{3}\\int_T\\lambda_2^2 \\, dA = \\frac{4}{3}\\left(\\frac{A}{6} + \\frac{A}{12} + \\frac{A}{6}\\right) = \\frac{4A}{3}\\frac{2+1+2}{12} = \\frac{5A}{9}\n$$\n根据对称性，所有对角元素均为 $\\frac{5A}{9}$。\n- 非对角元素 $(M_1)_{12} = \\int_T W_{12} \\cdot W_{23} \\, dA$：\n$$\n\\int_T (\\lambda_1 \\nabla\\lambda_2 - \\lambda_2 \\nabla\\lambda_1) \\cdot (\\lambda_2 \\nabla\\lambda_3 - \\lambda_3 \\nabla\\lambda_2) \\, dA\n$$\n$$\n= \\int_T (\\lambda_1 \\lambda_2(\\nabla\\lambda_2\\cdot\\nabla\\lambda_3) - \\lambda_1 \\lambda_3|\\nabla\\lambda_2|^2 - \\lambda_2^2(\\nabla\\lambda_1\\cdot\\nabla\\lambda_3) + \\lambda_2 \\lambda_3(\\nabla\\lambda_1\\cdot\\nabla\\lambda_2)) \\, dA\n$$\n$$\n= (-\\frac{2}{3}) \\int_T \\lambda_1\\lambda_2 \\, dA - \\frac{4}{3} \\int_T \\lambda_1\\lambda_3 \\, dA + \\frac{2}{3} \\int_T \\lambda_2^2 \\, dA - \\frac{2}{3} \\int_T \\lambda_2\\lambda_3 \\, dA\n$$\n$$\n= A \\left(-\\frac{2}{3}\\frac{1}{12} - \\frac{4}{3}\\frac{1}{12} + \\frac{2}{3}\\frac{1}{6} - \\frac{2}{3}\\frac{1}{12}\\right) = A\\left(\\frac{-2-4+4-2}{36}\\right) = -\\frac{4A}{36} = -\\frac{A}{9}\n$$\n根据对称性，所有非对角元素均为 $-\\frac{A}{9}$。\n$$\nM_1 = \\frac{A}{9} \\begin{pmatrix}\n5  -1  -1 \\\\\n-1  5  -1 \\\\\n-1  -1  5\n\\end{pmatrix} = \\frac{\\sqrt{3}}{36} \\begin{pmatrix}\n5  -1  -1 \\\\\n-1  5  -1 \\\\\n-1  -1  5\n\\end{pmatrix}\n$$\n\n### 步骤4：计算\n\n我们分步计算 $y = M_0^{-1} D_0^T M_1 x$。输入的上链为 $x = (1, 0, 0)^T$。\n\n**A. 计算 $M_1 x$**\n这等于 $M_1$ 的第一列：\n$$\nM_1 x = \\frac{A}{9} \\begin{pmatrix}\n5  -1  -1 \\\\\n-1  5  -1 \\\\\n-1  -1  5\n\\end{pmatrix}\n\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n= \\frac{A}{9} \\begin{pmatrix} 5 \\\\ -1 \\\\ -1 \\end{pmatrix}\n$$\n\n**B. 计算 $D_0^T (M_1 x)$**\n$$\nD_0^T (M_1 x) = \\begin{pmatrix}\n-1  0  1 \\\\\n1  -1  0 \\\\\n0  1  -1\n\\end{pmatrix}\n\\left( \\frac{A}{9} \\begin{pmatrix} 5 \\\\ -1 \\\\ -1 \\end{pmatrix} \\right)\n= \\frac{A}{9} \\begin{pmatrix}\n(-1)(5) + (0)(-1) + (1)(-1) \\\\\n(1)(5) + (-1)(-1) + (0)(-1) \\\\\n(0)(5) + (1)(-1) + (-1)(-1)\n\\end{pmatrix}\n= \\frac{A}{9} \\begin{pmatrix} -6 \\\\ 6 \\\\ 0 \\end{pmatrix}\n= \\frac{A}{3} \\begin{pmatrix} -2 \\\\ 2 \\\\ 0 \\end{pmatrix}\n$$\n\n**C. 计算 $M_0^{-1}$**\n设 $K = \\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix}$。我们有 $\\det(K) = 4$。\n其逆矩阵为 $K^{-1} = \\frac{1}{4} \\begin{pmatrix} 3  -1  -1 \\\\ -1  3  -1 \\\\ -1  -1  3 \\end{pmatrix}$。\n因为 $M_0 = \\frac{A}{12} K$，其逆矩阵是 $M_0^{-1} = \\frac{12}{A} K^{-1} = \\frac{12}{A} \\frac{1}{4} \\begin{pmatrix} 3  -1  -1 \\\\ -1  3  -1 \\\\ -1  -1  3 \\end{pmatrix} = \\frac{3}{A} \\begin{pmatrix} 3  -1  -1 \\\\ -1  3  -1 \\\\ -1  -1  3 \\end{pmatrix}$。\n\n**D. 计算 $y = M_0^{-1} (D_0^T M_1 x)$**\n$$\ny = \\left( \\frac{3}{A} \\begin{pmatrix} 3  -1  -1 \\\\ -1  3  -1 \\\\ -1  -1  3 \\end{pmatrix} \\right) \\left( \\frac{A}{3} \\begin{pmatrix} -2 \\\\ 2 \\\\ 0 \\end{pmatrix} \\right)\n$$\n标量因子 $\\frac{3}{A}$ 和 $\\frac{A}{3}$ 相互抵消。\n$$\ny = \\begin{pmatrix} 3  -1  -1 \\\\ -1  3  -1 \\\\ -1  -1  3 \\end{pmatrix}\n\\begin{pmatrix} -2 \\\\ 2 \\\\ 0 \\end{pmatrix}\n= \\begin{pmatrix}\n(3)(-2) + (-1)(2) + (-1)(0) \\\\\n(-1)(-2) + (3)(2) + (-1)(0) \\\\\n(-1)(-2) + (-1)(2) + (3)(0)\n\\end{pmatrix}\n= \\begin{pmatrix}\n-6 - 2 \\\\\n2 + 6 \\\\\n2 - 2\n\\end{pmatrix}\n= \\begin{pmatrix}\n-8 \\\\\n8 \\\\\n0\n\\end{pmatrix}\n$$\n所得向量 $y$ 表示 0-形式 $\\delta_h x$ 在顶点基 $\\{v_1, v_2, v_3\\}$ 中的系数。对应于顶点 $v_2$ 的分量是该向量的第二个元素。\n\n$\\delta_h x$ 中对应于 $v_2$ 的分量是 $8$。", "answer": "$$\n\\boxed{8}\n$$", "id": "3372195"}, {"introduction": "在离散算子的基础上，本练习将探索离散形式空间的结构。您将实现离散霍奇分解，它将任意一个离散 $k$-形式正交地分解为恰当、余恰当和调和三个部分。这个分解是FEEC的基石，为偏微分方程的稳定数值方法和计算拓扑学提供了理论基础。[@problem_id:3372181]", "problem": "考虑一个表示为二维正方形的有限胞腔复形上的离散霍奇分解，该正方形被细分为两个定向三角形。设顶点集为 $\\{v_0,v_1,v_2,v_3\\}$，其坐标分别为 $(0,0)$、$(1,0)$、$(1,1)$、$(0,1)$，边集为 $\\{e_0,e_1,e_2,e_3,e_4\\}$，其定向为 $e_0: v_0 \\to v_1$、$e_1: v_1 \\to v_2$、$e_2: v_2 \\to v_3$、$e_3: v_3 \\to v_0$ 以及 $e_4: v_0 \\to v_2$。面集由两个定向三角形 $f_0: (v_0,v_1,v_2)$ 和 $f_1: (v_0,v_2,v_3)$ 组成，每个都按逆时针方向定向。离散梯度（上边缘）算子由关联矩阵 $D_0 \\in \\mathbb{R}^{5 \\times 4}$（从顶点到边）和 $D_1 \\in \\mathbb{R}^{2 \\times 5}$（从边到面）给出，这些矩阵根据边和面的定向连接关系构造。设质量矩阵 $M_0 \\in \\mathbb{R}^{4 \\times 4}$、$M_1 \\in \\mathbb{R}^{5 \\times 5}$ 和 $M_2 \\in \\mathbb{R}^{2 \\times 2}$ 为对称正定矩阵，它们分别通过以下方式近似 $0$-形式、 $1$-形式和 $2$-形式上的 $L^2$ 内积：\n- $M_2$ 为对角矩阵，对角元为面的面积，\n- $M_1$ 为对角矩阵，对角元为边的长度，\n- $M_0$ 为对角矩阵，对角元为顶点的集中区域面积，其中每个顶点接收其相邻每个面面积的三分之一。\n\n有限元外微分 (FEEC) 通过 $D_k$ 定义离散微分 $d_k$，并将离散余微分 $\\delta_k$ 定义为 $d_k$ 关于 $M_k$ 内积的伴随算子。离散 $k$-形式 $u \\in V_k$ 的霍奇分解旨在寻求一个正交分解 $u = u_{\\mathrm{ex}} + u_{\\mathrm{coex}} + u_{\\mathrm{harm}}$，其中 $u_{\\mathrm{ex}}$ 是恰当的（$u_{\\mathrm{ex}} \\in \\mathrm{im}(d_{k-1})$），$u_{\\mathrm{coex}}$ 是余恰当的（$u_{\\mathrm{coex}} \\in \\mathrm{im}(\\delta_k)$），而 $u_{\\mathrm{harm}}$ 是调和的（在 $M_k$ 内积下与恰当分量和余恰当分量均正交）。您的任务是：\n1. 根据上述定向网格构造 $D_0$ 和 $D_1$，并根据几何度量构造 $M_0$、$M_1$、$M_2$。\n2. 仅使用内积空间中正交投影和伴随算子的基本定义，设计并实现一种方法，用于计算给定离散 $k$-形式 $u$ 在由 $M_k$ 诱导的内积下，到其恰当、余恰当和调和分量上的正交投影，其中 $k \\in \\{0,1,2\\}$。\n3. 对于以下测试套件，计算指定的量：\n   - 测试用例 1（理想情况，恰当形式）：$k=1$，取 $a \\in V_0$，其在 $(v_0,v_1,v_2,v_3)$ 上的分量为 $[0,1,2,1]$，并设 $u = d_0 a$。输出 $u_{\\mathrm{harm}}$ 的 $M_1$-范数。\n   - 测试用例 2（理想情况，余恰当形式）：$k=1$，取 $b \\in V_2$，其在 $(f_0,f_1)$ 上的分量为 $[1,-0.5]$，并设 $u = \\delta_1 b$。输出 $u_{\\mathrm{harm}}$ 的 $M_1$-范数。\n   - 测试用例 3（一般情况）：$k=1$，取 $u \\in V_1$，其在 $(e_0,e_1,e_2,e_3,e_4)$ 上的分量为 $[0.1,-0.3,0.2,0.5,-0.4]$。输出 $u_{\\mathrm{harm}}$ 的 $M_1$-范数。\n   - 测试用例 4（$k=0$ 的边界条件边缘情况）：$k=0$，取 $u \\in V_0$，其在 $(v_0,v_1,v_2,v_3)$ 上的分量为 $[0.3,-0.1,0.2,0.5]$。输出 $d_0 u_{\\mathrm{harm}}$ 的 $M_1$-范数。\n   - 测试用例 5（$k=2$ 的最高阶形式边缘情况）：$k=2$，取 $u \\in V_2$，其在 $(f_0,f_1)$ 上的分量为 $[0.7,-0.2]$。输出 $u_{\\mathrm{coex}}$ 的 $M_2$-范数。\n4. 离散 $k$-形式 $w \\in V_k$ 的 $M_k$-范数必须计算为 $\\|w\\|_{M_k} = \\sqrt{w^\\top M_k w}$。\n5. 您的程序应生成单行输出，其中包含以上五个测试用例的结果，结果为用逗号分隔并用方括号括起来的列表。所有输出均为实数（无单位的浮点数）。\n\n请通过从第一性原理（内积空间中的正交投影和伴随算子）推导算法，并使用提供的网格、定向和质量矩阵构造方法，来确保数学上的正确性。不需要外部输入，所有常数均按上述规定。最终输出为浮点数。", "solution": "我们从有限胞腔复形上的离散 de Rham 复形开始，其中离散 $k$-形式空间 $V_k$ 与 $k$-胞腔相关联，上边缘算子 $d_k: V_k \\to V_{k+1}$ 由关联矩阵 $D_k$ 表示。$V_k$ 上的内积由一个对称正定 (SPD) 质量矩阵 $M_k$ 定义，即对于 $u,v \\in V_k$，有 $\\langle u,v \\rangle_{M_k} := u^\\top M_k v$。离散余微分 $\\delta_k: V_{k+1} \\to V_k$ 是 $d_k$ 关于内积 $\\langle \\cdot,\\cdot \\rangle_{M_k}$ 的伴随算子，即它满足\n$$\n\\langle \\delta_k w, v \\rangle_{M_k} = \\langle w, d_k v \\rangle_{M_{k+1}} \\quad \\text{对于所有 } v \\in V_k, \\, w \\in V_{k+1}.\n$$\n在矩阵形式下，这意味着\n$$\n\\delta_k = M_k^{-1} D_k^\\top M_{k+1},\n$$\n因为\n$$\n(\\delta_k w)^\\top M_k v = w^\\top M_{k+1} D_k v = w^\\top (D_k^\\top M_{k+1}) v \\quad \\Rightarrow \\quad \\delta_k = M_k^{-1} D_k^\\top M_{k+1}.\n$$\n\n$u \\in V_k$ 的霍奇分解定义为\n$$\nu = u_{\\mathrm{ex}} + u_{\\mathrm{coex}} + u_{\\mathrm{harm}},\n$$\n其中 $u_{\\mathrm{ex}} \\in \\mathrm{im}(d_{k-1})$，$u_{\\mathrm{coex}} \\in \\mathrm{im}(\\delta_k)$，而 $u_{\\mathrm{harm}}$ 在 $\\langle \\cdot,\\cdot \\rangle_{M_k}$ 内积下与 $\\mathrm{im}(d_{k-1})$ 和 $\\mathrm{im}(\\delta_k)$ 都正交。希尔伯特空间中到闭子空间上的正交投影的特点是最小化残差范数。因此，为了计算 $u$ 到 $\\mathrm{im}(d_{k-1})$ 上的正交投影 $u_{\\mathrm{ex}}$，我们寻求 $a \\in V_{k-1}$ 来最小化\n$$\n\\|u - d_{k-1} a\\|_{M_k}^2 = (u - D_{k-1} a)^\\top M_k (u - D_{k-1} a).\n$$\n将关于 $a$ 的导数设为零，得到正规方程\n$$\nD_{k-1}^\\top M_k D_{k-1} \\, a = D_{k-1}^\\top M_k u.\n$$\n这个线性系统是对称半正定的；其解定义了正交投影算子。选择最小范数解（通过 Moore-Penrose 伪逆）得到 $a$，然后\n$$\nu_{\\mathrm{ex}} = D_{k-1} a.\n$$\n\n类似地，为了计算到 $\\mathrm{im}(\\delta_k)$ 上的正交投影 $u_{\\mathrm{coex}}$，我们寻求 $b \\in V_{k+1}$ 来最小化\n$$\n\\|u - \\delta_k b\\|_{M_k}^2 = (u - \\delta_k b)^\\top M_k (u - \\delta_k b).\n$$\n平稳性条件是\n$$\n\\delta_k^\\top M_k (u - \\delta_k b) = 0 \\quad \\Rightarrow \\quad \\delta_k^\\top M_k \\delta_k \\, b = \\delta_k^\\top M_k u.\n$$\n使用 $\\delta_k = M_k^{-1} D_k^\\top M_{k+1}$ 和 $\\delta_k^\\top M_k = M_{k+1} D_k$，我们得到\n$$\n(M_{k+1} D_k M_k^{-1} D_k^\\top M_{k+1}) \\, b = M_{k+1} D_k \\, u,\n$$\n这个方程同样是对称半正定的。选择最小范数解得到 $b$，然后\n$$\nu_{\\mathrm{coex}} = \\delta_k b = M_k^{-1} D_k^\\top M_{k+1} b.\n$$\n调和分量就是残差\n$$\nu_{\\mathrm{harm}} = u - u_{\\mathrm{ex}} - u_{\\mathrm{coex}}.\n$$\n根据构造，$u_{\\mathrm{harm}}$ 在 $\\langle \\cdot,\\cdot \\rangle_{M_k}$ 内积下与 $\\mathrm{im}(d_{k-1})$ 和 $\\mathrm{im}(\\delta_k)$ 都正交，因此它位于恰当子空间和余恰当子空间之和的正交补空间中。在没有施加边界条件的单连通网格上，调和子空间的维数等于胞腔复形的相应 Betti 数；具体到我们的网格，第一个 Betti 数为零，因此对于 $k=1$，我们预期对于任意 $u \\in V_1$，$u_{\\mathrm{harm}}$ 都（在数值上）为零。对于 $k=0$，常数构成了调和子空间，其特征为 $d_0 u_{\\mathrm{harm}} = 0$。对于二维中的 $k=2$，$\\delta_2$ 是平凡的，余恰当子空间为 $\\{0\\}$；恰当分量来自 $d_1$，调和分量是残差。\n\n我们现在具体说明网格代数：\n- 构造 $D_0$，对于每个定向边，其尾顶点对应的元为 $-1$，头顶点对应的元为 $+1$。\n- 构造 $D_1$，如果边的定向与诱导的面边界定向一致，则对应元为 $+1$，相反则为 $-1$。\n- 计算 $M_1$ 为边长的对角矩阵：对于端点为 $(x_i,y_i)$ 和 $(x_j,y_j)$ 的边，其长度为 $\\sqrt{(x_j-x_i)^2+(y_j-y_i)^2}$。\n- 计算 $M_2$ 为三角形面积的对角矩阵：对于定向三角形 $(p,q,r)$，其面积为 $\\frac{1}{2} |(q-p) \\times (r-p)|$。\n- 通过集中面积计算 $M_0$：对于每个三角形，将其面积的三分之一加到其每个顶点的对角元上。\n\n有了这些，我们通过 $\\delta_k = M_k^{-1} D_k^\\top M_{k+1}$ 计算 $\\delta_k$，并使用 Moore-Penrose 伪逆 $A^+$ 求解正规方程以处理半正定矩阵：\n- 对于恰当投影：\n$$\nA_{\\mathrm{ex}} = D_{k-1}^\\top M_k D_{k-1}, \\quad \\text{求解 } a = A_{\\mathrm{ex}}^+ D_{k-1}^\\top M_k u, \\quad u_{\\mathrm{ex}} = D_{k-1} a.\n$$\n- 对于余恰当投影：\n$$\nA_{\\mathrm{coex}} = D_k M_k^{-1} D_k^\\top M_{k+1}, \\quad \\text{求解 } b = A_{\\mathrm{coex}}^+ D_k u, \\quad u_{\\mathrm{coex}} = M_k^{-1} D_k^\\top M_{k+1} b.\n$$\n- 调和残差：\n$$\nu_{\\mathrm{harm}} = u - u_{\\mathrm{ex}} - u_{\\mathrm{coex}}.\n$$\n\n对于测试套件：\n1. 对于 $k=1$，$u = d_0 a$ 且 $a=[0,1,2,1]$，恰当性意味着 $u_{\\mathrm{harm}}$ 应接近于零；我们报告 $\\|u_{\\mathrm{harm}}\\|_{M_1}$。\n2. 对于 $k=1$，$u = \\delta_1 b$ 且 $b=[1,-0.5]$，余恰当性意味着 $u_{\\mathrm{harm}}$ 应接近于零；我们报告 $\\|u_{\\mathrm{harm}}\\|_{M_1}$。\n3. 对于 $k=1$，任意 $u=[0.1,-0.3,0.2,0.5,-0.4]$，单连通拓扑意味着 $u_{\\mathrm{harm}}$ 应接近于零；我们报告 $\\|u_{\\mathrm{harm}}\\|_{M_1}$。\n4. 对于 $k=0$，$u=[0.3,-0.1,0.2,0.5]$，调和分量应近似为常数；我们通过计算 $\\|d_0 u_{\\mathrm{harm}}\\|_{M_1}$ 来验证其闭性，该值应接近于零。\n5. 对于 $k=2$，$u=[0.7,-0.2]$，余恰当分量为零，因为在没有 3-胞腔的二维空间中 $\\delta_2$ 是平凡的；我们报告 $\\|u_{\\mathrm{coex}}\\|_{M_2}$，该值应精确为零。\n\n最后，程序计算这五个浮点数，并将它们以逗号分隔、用方括号括起来的列表形式单行打印输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_mesh():\n    # Vertex coordinates\n    V = np.array([\n        [0.0, 0.0],  # v0\n        [1.0, 0.0],  # v1\n        [1.0, 1.0],  # v2\n        [0.0, 1.0],  # v3\n    ])\n\n    # Oriented edges as (tail, head)\n    edges = [\n        (0, 1),  # e0\n        (1, 2),  # e1\n        (2, 3),  # e2\n        (3, 0),  # e3\n        (0, 2),  # e4 (diagonal)\n    ]\n\n    # Oriented faces: triangles with CCW orientation\n    faces = [\n        (0, 1, 2),  # f0\n        (0, 2, 3),  # f1\n    ]\n\n    # Incidence matrix D0: edges x vertices\n    nV = len(V)\n    nE = len(edges)\n    D0 = np.zeros((nE, nV))\n    for ei, (tail, head) in enumerate(edges):\n        D0[ei, tail] = -1.0\n        D0[ei, head] = +1.0\n\n    # Helper: map edge tuple to index for quick lookup\n    edge_to_index = {edges[i]: i for i in range(nE)}\n    # Also include reversed edges for sign handling\n    rev_edge_to_index = {(h, t): i for i, (t, h) in enumerate(edges)}\n\n    # Incidence matrix D1: faces x edges\n    nF = len(faces)\n    D1 = np.zeros((nF, nE))\n    # For each face, collect its boundary edges with orientation consistent with CCW face orientation\n    # Face boundary sequences:\n    # f0: v0->v1 (e0 +1), v1->v2 (e1 +1), v2->v0 (reverse of e4 => -1)\n    # f1: v0->v2 (e4 +1), v2->v3 (e2 +1), v3->v0 (e3 +1)\n    # We will compute programmatically to be robust.\n\n    def add_face_boundary(face_index, verts):\n        # verts is (a, b, c) oriented CCW.\n        # Boundary edges: a->b, b->c, c->a\n        boundary = [(verts[0], verts[1]), (verts[1], verts[2]), (verts[2], verts[0])]\n        for (t, h) in boundary:\n            sign = 0.0\n            if (t, h) in edge_to_index:\n                ei = edge_to_index[(t, h)]\n                sign = +1.0\n            elif (t, h) in rev_edge_to_index:\n                ei = rev_edge_to_index[(t, h)]\n                # Note: if edge stored as (h, t), then boundary orientation opposes edge orientation\n                sign = -1.0\n            else:\n                # Should not happen in this mesh\n                raise RuntimeError(\"Boundary edge not found in edge list\")\n            D1[face_index, ei] += sign\n\n    for fi, tri in enumerate(faces):\n        add_face_boundary(fi, tri)\n\n    # Mass matrices\n    # M1: diagonal of edge lengths\n    M1 = np.zeros((nE, nE))\n    for i, (tail, head) in enumerate(edges):\n        p = V[tail]\n        q = V[head]\n        length = np.linalg.norm(q - p)\n        M1[i, i] = length\n\n    # M2: diagonal of triangle areas\n    M2 = np.zeros((nF, nF))\n    # Function to compute area of triangle (p, q, r)\n    def tri_area(p, q, r):\n        # area = 0.5 * |(q-p) x (r-p)|\n        return 0.5 * abs((q[0]-p[0])*(r[1]-p[1]) - (q[1]-p[1])*(r[0]-p[0]))\n\n    areas = []\n    for fi, (a, b, c) in enumerate(faces):\n        area = tri_area(V[a], V[b], V[c])\n        areas.append(area)\n        M2[fi, fi] = area\n\n    # M0: lumped areas at vertices (each triangle contributes area/3 to its vertices)\n    M0 = np.zeros((nV, nV))\n    for fi, (a, b, c) in enumerate(faces):\n        area = areas[fi]\n        M0[a, a] += area / 3.0\n        M0[b, b] += area / 3.0\n        M0[c, c] += area / 3.0\n\n    return D0, D1, M0, M1, M2\n\ndef pinv_solve(A, b):\n    # Solve A x = b in the minimum-norm sense using Moore-Penrose pseudoinverse.\n    # Stable for symmetric positive semidefinite matrices.\n    return np.linalg.pinv(A) @ b\n\ndef delta_k(Dk, Mk, Mk1):\n    # Compute discrete codifferential: delta_k = Mk^{-1} Dk^T Mk1\n    # Mk and Mk1 are SPD; Mk^{-1} implemented via solve for generality (but diagonal here).\n    # Since Mk is diagonal, we can compute inverse efficiently.\n    Mk_inv = np.linalg.inv(Mk)\n    return Mk_inv @ Dk.T @ Mk1\n\ndef project_components(u, k, D_list, M_list):\n    # u in V_k; D_list = [D0, D1]; M_list = [M0, M1, M2]\n    Mk = M_list[k]\n    # Exact component\n    if k - 1 >= 0:\n        Dkm1 = D_list[k - 1]\n        A_ex = Dkm1.T @ Mk @ Dkm1\n        rhs_ex = Dkm1.T @ Mk @ u\n        a = pinv_solve(A_ex, rhs_ex)\n        u_ex = Dkm1 @ a\n    else:\n        u_ex = np.zeros_like(u)\n\n    # Coexact component\n    if k + 1 <= 2:\n        Dk = D_list[k]\n        Mk_inv = np.linalg.inv(Mk)\n        Mk1 = M_list[k + 1]\n        # A_coex = Dk Mk^{-1} Dk^T Mk1\n        A_coex = Dk @ Mk_inv @ Dk.T @ Mk1\n        rhs_coex = Dk @ u\n        b = pinv_solve(A_coex, rhs_coex)\n        # u_coex = Mk^{-1} Dk^T Mk1 b\n        u_coex = Mk_inv @ Dk.T @ Mk1 @ b\n    else:\n        u_coex = np.zeros_like(u)\n\n    # Harmonic residual\n    u_harm = u - u_ex - u_coex\n    return u_ex, u_coex, u_harm\n\ndef norm_M(u, M):\n    return float(np.sqrt(u.T @ M @ u))\n\ndef solve():\n    # Build mesh and operators\n    D0, D1, M0, M1, M2 = build_mesh()\n    D_list = [D0, D1]\n    M_list = [M0, M1, M2]\n\n    results = []\n\n    # Test case 1: k=1, u = d0 a with a=[0,1,2,1], output ||u_harm||_{M1}\n    a = np.array([0.0, 1.0, 2.0, 1.0])\n    u1_case1 = D0 @ a\n    u_ex, u_coex, u_harm = project_components(u1_case1, 1, D_list, M_list)\n    results.append(norm_M(u_harm, M1))\n\n    # Test case 2: k=1, u = delta1 b with b=[1,-0.5], output ||u_harm||_{M1}\n    b = np.array([1.0, -0.5])\n    delta1 = delta_k(D1, M1, M2)\n    u1_case2 = delta1 @ b\n    u_ex, u_coex, u_harm = project_components(u1_case2, 1, D_list, M_list)\n    results.append(norm_M(u_harm, M1))\n\n    # Test case 3: k=1, arbitrary u, output ||u_harm||_{M1}\n    u1_case3 = np.array([0.1, -0.3, 0.2, 0.5, -0.4])\n    u_ex, u_coex, u_harm = project_components(u1_case3, 1, D_list, M_list)\n    results.append(norm_M(u_harm, M1))\n\n    # Test case 4: k=0, arbitrary u, output ||d0 u_harm||_{M1}\n    u0_case4 = np.array([0.3, -0.1, 0.2, 0.5])\n    u_ex, u_coex, u_harm = project_components(u0_case4, 0, D_list, M_list)\n    d0_u_harm = D0 @ u_harm\n    results.append(norm_M(d0_u_harm, M1))\n\n    # Test case 5: k=2, arbitrary u, output ||u_coex||_{M2}\n    u2_case5 = np.array([0.7, -0.2])\n    u_ex, u_coex, u_harm = project_components(u2_case5, 2, D_list, M_list)\n    results.append(norm_M(u_coex, M2))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3372181"}, {"introduction": "这最后一个练习展示了模拟离散化框架在捕捉底层区域深刻拓扑性质方面的强大能力。您将通过数值方法研究离散庞加莱引理，该引理指出在可收缩空间上，任何闭形式都是恰当的。通过比较在一个简单正方形和一个有孔正方形上的结果，您将看到该性质的失效如何揭示区域的非平凡拓扑结构。[@problem_id:3372213]", "problem": "您的任务是，在谱方法和间断Galerkin (DG) 方法的背景下，利用相容和模拟方法以及有限元外微分 (FEEC) 的设定，对庞加莱引理的离散版本进行数值验证。您必须使用的基础是可收缩网格上的 de Rham 复形的上链模型，其中上边缘算子表示离散外导数，该模型源于组合拓扑学和斯托克斯定理 (Stokes’ theorem)。具体来说，将离散 $0$-形式表示为网格顶点（节点）上的值，将离散 $1$-形式表示为有向网格边上的值，将离散 $2$-形式表示为有向网格单元上的值。离散外导数被建模为关联矩阵：对于梯度，该矩阵将节点值映射到边上的差值；对于旋度，该矩阵将有向边的环流量映射到有向单元的环流量，并具有正合性，即连续关联算子的复合为零映射。\n\n您的程序必须：\n- 在单位正方形 $[0,1]^2$ 上构建一个均匀笛卡尔网格，其在 $x$ 方向有 $n_x$ 个区间，在 $y$ 方向有 $n_y$ 个区间，并定义以下内容：\n  - 节点集 $\\mathcal{N}=\\{(i,j): i\\in\\{0,\\dots,n_x\\}, j\\in\\{0,\\dots,n_y\\}\\}$，其坐标为 $(x_i,y_j)=(i/n_x,j/n_y)$。\n  - 有向边集 $\\mathcal{E}$，包含所有沿正 $x$ 方向的水平边 $((i,j)\\to(i+1,j))$ 和所有沿正 $y$ 方向的垂直边 $((i,j)\\to(i,j+1))$。\n  - 有向单元集 $\\mathcal{C}$，包含所有具有逆时针方向的单位正方形 $(i,j)$。可以选择性地移除单个单元 $(i_0,j_0)$，以生成一个带单个孔洞的单连通区域。\n- 构建两个关联矩阵：\n  - 节点到边的关联矩阵 $A\\in\\mathbb{R}^{m\\times n}$，表示离散梯度（上边缘算子）$d:\\Lambda^0_h\\to\\Lambda^1_h$，每行对应一条边，每列对应一个节点。对于每条边，其尾节点的对应项为 $-1$，头节点的对应项为 $+1$，其他项为零。\n  - 边到单元的关联矩阵 $B\\in\\mathbb{R}^{p\\times m}$，表示离散旋度 $d:\\Lambda^1_h\\to\\Lambda^2_h$，每行对应一个有向单元。对于每个单元，其边界边上有四个非零项：底边和右边为 $+1$（与逆时针边界方向一致），顶边和左边为 $-1$（与逆时针边界方向相反）。如果一个单元被移除（形成孔洞），则该单元在 $B$ 中不贡献行。\n- 从 FEEC 的角度出发，实现以下任务并给出合理解释：\n  1. 如果 $\\omega\\in\\Lambda^1_h$ 是一个满足 $d\\omega=0$（即 $B\\omega=0$）的离散 $1$-形式，那么在单连通网格（无孔洞）上，离散庞加莱引理预测存在一个离散势 $\\phi\\in\\Lambda^0_h$ 使得 $\\omega=d\\phi$（即 $\\omega=A\\phi$），该势在一个可加常数内是唯一的。通过求解以下约束最小二乘问题来数值化地展示 $\\phi$ 的重构：\n     $$\\min_{\\phi\\in\\mathbb{R}^n}\\|A\\phi-\\omega\\|_2\\quad\\text{subject to}\\quad \\phi_{k}=0,$$\n     其中 $\\phi_k$ 在一个参考节点处被固定为零，以确保可加常数的唯一性。验证当 $\\omega$ 在单连通区域上是闭形式时，残差 $\\|A\\phi-\\omega\\|_2$ 很小。\n  2. 对于有一个单元被移除（一个孔洞）的网格，通过求解以下最小范数问题来构造一个非平凡的闭离散 $1$-形式 $\\omega$，且该形式不是正合的：\n     $$\\min_{\\omega\\in\\mathbb{R}^m}\\frac{1}{2}\\|\\omega\\|_2^2\\quad\\text{subject to}\\quad B\\omega=0,\\quad C^\\top\\omega=1,$$\n     其中 $C\\in\\mathbb{R}^m$ 编码了围绕孔洞的一个不可收缩环路（逆时针方向）的有向指示函数。证明在该区域上，势重构问题的残差不为零，即 $\\min_{\\phi}\\|A\\phi-\\omega\\|_2>0$。\n  3. 通过使用中点法逼近光滑矢量场的线积分，在单连通网格上构造闭合与非闭合的离散 $1$-形式。使用与物理边长成比例的切向量来近似边积分。使用一个光滑势 $\\phi^\\star(x,y)$ 得到一个目标无旋场，并使用一个具有非零旋度的光滑场来生成一个非闭合的例子。\n\n您必须使用的基础定义：\n- de Rham 复形被离散化为上链复形 $(\\Lambda^0_h, d)\\xrightarrow{d}(\\Lambda^1_h,d)\\xrightarrow{d}(\\Lambda^2_h,0)$，其性质 $d\\circ d=0$ 由组合恒等式 $BA=0$ 编码。\n- 在可收缩域上的正合性表明 $\\ker(B)=\\operatorname{im}(A)$；第一上同调群是平凡的。\n- 间断Galerkin (DG) 的观点通过允许跨元素的不连续性，并用赋予了组合外导数和关联方向的上链来表示微分形式来实现；相容性来自于保持拓扑结构 $d\\circ d=0$。\n\n请使用以下具体的测试套件。对于每种情况，计算两个浮点数：\n- 闭合缺陷 $c=\\|B\\omega\\|_2$。\n- 势重构残差比 $r=\\|A\\phi-\\omega\\|_2/\\|\\omega\\|_2$，其中 $\\phi$ 是将一个参考节点（选择节点 $(0,0)$）设为零的最小二乘解。\n将所有情况的结果按指定顺序连接成一个列表进行报告。\n\n测试套件：\n- 情况 1（单连通，由节点势差精确构成的闭形式）：使用 $n_x=4$, $n_y=3$。令 $\\phi^\\star(x,y)=\\exp(x)\\sin(2\\pi y)$，通过 $\\phi_{i,j}=\\phi^\\star(i/n_x,j/n_y)$ 在节点上定义 $\\phi$，并设置 $\\omega=A\\phi$。\n- 情况 2（单连通，通过中点积分法近似构成的闭形式）：使用 $n_x=7$, $n_y=5$。令 $\\phi^\\star(x,y)=\\exp(x)\\sin(2\\pi y)$ 并定义矢量场 $\\mathbf{v}=\\nabla\\phi^\\star$。通过在每条边的中点处计算 $\\mathbf{v}$，并将其与按边长缩放的有向切向量作点积来近似 $\\omega$。\n- 情况 3（单连通，非闭形式）：使用 $n_x=7$, $n_y=5$。令 $\\mathbf{v}(x,y)=(-y,x)$，并如上所述使用中点法则近似计算每条边上的 $\\omega$。\n- 情况 4（带孔洞，闭合但非正合）：使用 $n_x=6$, $n_y=6$ 并移除单元 $(i_0,j_0)=(3,3)$（零基索引）。构造围绕缺失单元的逆时针方向的有向环路向量 $C$。通过求解以下最小范数约束问题来计算 $\\omega$：\n  $$\\min_{\\omega}\\frac{1}{2}\\|\\omega\\|_2^2\\ \\text{s.t.}\\ B\\omega=0,\\ C^\\top\\omega=1,$$\n  使用带拉格朗日乘子的一阶必要条件。\n\n不涉及角度单位。没有物理单位。您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，结果顺序为\n$$[c_1,r_1,c_2,r_2,c_3,r_3,c_4,r_4],$$\n其中 $c_k$ 和 $r_k$ 分别是情况 $k$ 的闭合缺陷和重构残差比。每个项目必须是浮点数。", "solution": "该问题陈述是计算代数拓扑领域一个有效且适定的练习，特别是在有限元外微分 (FEEC) 和模拟离散化方法的框架内。它具有科学依据、是客观的，并包含了继续进行所需的所有必要信息。\n\n### 理论基础\n\n该问题要求使用二维笛卡尔网格上的 de Rham 复形的上链模型，对离散庞加莱引理进行数值验证。这种方法是相容和模拟离散化的核心，旨在在离散层面保持矢量微积分和微分几何的基本结构。\n\n令计算域 $\\Omega = [0,1]^2$ 被离散化为一个由节点（0-胞腔）、边（1-胞腔）和矩形单元（2-胞腔）组成的胞腔复形。我们定义离散微分形式（上链）的空间：\n- $\\Lambda^0_h$：离散 $0$-形式空间，即分配给 $n$ 个节点的实数值。一个向量 $\\phi \\in \\mathbb{R}^n$ 表示一个离散 $0$-形式。\n- $\\Lambda^1_h$：离散 $1$-形式空间，即分配给 $m$ 条有向边的实数值。一个向量 $\\omega \\in \\mathbb{R}^m$ 表示一个离散 $1$-形式。\n- $\\Lambda^2_h$：离散 $2$-形式空间，即分配给 $p$ 个有向单元的实数值。一个向量 $\\tau \\in \\mathbb{R}^p$ 表示一个离散 $2$-形式。\n\n外导数 $d$ 通过上边缘算子进行离散化，这些算子由从网格拓扑导出的关联矩阵表示。\n1. 离散梯度 $d_0: \\Lambda^0_h \\to \\Lambda^1_h$，将一个 $0$-形式（节点上的势）映射到一个 $1$-形式（边上的势差）。它由节点到边的关联矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 表示。对于连接节点 $v_{tail}$ 到 $v_{head}$ 的边 $e$， $A$ 的对应行在 $v_{tail}$ 的列中为 $-1$，在 $v_{head}$ 的列中为 $+1$。如果 $\\omega = A\\phi$，则 $\\omega_e = \\phi_{head} - \\phi_{tail}$。\n\n2. 离散旋度 $d_1: \\Lambda^1_h \\to \\Lambda^2_h$，将一个 $1$-形式（边上的环流量）映射到一个 $2$-形式（单元上的涡度）。它由边到单元的关联矩阵 $B \\in \\mathbb{R}^{p \\times m}$ 表示。对于一个单元 $c$，$B$ 的对应行编码了其边界 $\\partial c$ 上 $1$-形式值的有向和。这是斯托克斯定理 (Stokes' theorem) 的离散版本。对于一个逆时针 (CCW) 方向的单元，其边界上的一条边，如果其方向与 CCW 遍历方向一致，则系数为 $+1$，如果相反，则为 $-1$。\n\nde Rham 复形的一个基本性质是两个连续外导数的复合为零：$d \\circ d = 0$。在我们的离散设置中，这转化为精确的组合恒等式 $B A = 0$。这确保了任何正合形式（即某个形式的导数，如 $\\omega = A\\phi$）也是闭形式（其导数为零，即 $B\\omega = B(A\\phi) = (BA)\\phi = 0$）。\n\n庞加莱引理指出，在可收缩域上，其逆命题也成立：每个闭形式都是正合的。对于一个单连通网格（无孔洞），该区域是可收缩的。该引理的离散模拟意味着第一上同调群是平凡的，即 $\\ker(B) = \\text{im}(A)$。也就是说，如果一个离散 $1$-形式 $\\omega$ 是闭的（$B\\omega=0$），那么必然存在一个离散 $0$-形式 $\\phi$ 使得 $\\omega = A\\phi$。\n\n### 实现策略\n\n实现过程首先构建网格实体（节点、边、单元）及其对应的关联矩阵 $A$ 和 $B$。然后，对于每个测试案例，根据问题规范构造离散 $1$-形式 $\\omega$。最后，我们计算所需的度量：闭合缺陷和势重构残差。\n\n**势重构：**\n为了为给定的 $1$-形式 $\\omega$ 找到势 $\\phi$，我们的目标是求解 $A\\phi = \\omega$。在连通域上，$A$ 的核是一维的，由常数 $0$-形式组成（即，如果 $\\phi$ 是常数，则 $A\\phi=0$）。为了获得唯一解，我们必须固定一个参考节点的势。我们选择位于 $(0,0)$ 的节点并将其势设为 $0$，即 $\\phi_0 = 0$。问题随后变成一个约束最小二乘问题：\n$$ \\min_{\\phi \\in \\mathbb{R}^n} \\|A\\phi - \\omega\\|_2 \\quad \\text{subject to} \\quad \\phi_0=0 $$\n这可以通过删除 $A$ 的第一列和 $\\phi$ 的第一个条目，求解得到的无约束最小二乘问题，然后为 $\\phi_0$ 重新插入零值来解决。残差范数 $\\|A\\phi - \\omega\\|_2$ 量化了 $\\omega$ 与位于 $A$ 的像空间中（即是正合的）的接近程度。比率 $r = \\|A\\phi - \\omega\\|_2 / \\|\\omega\\|_2$ 提供了对此非正合性的归一化度量。闭合缺陷 $c = \\|B\\omega\\|_2$ 衡量了 $\\omega$ 与位于 $B$ 的核空间中的距离。\n\n### 案例分析\n\n**情况 1：单连通，精确闭形式**\n- 给定 $n_x=4, n_y=3$。该域是单连通的。\n- 通过在网格节点上采样一个光滑函数 $\\phi^\\star(x,y)=\\exp(x)\\sin(2\\pi y)$ 来定义离散势 $\\phi$。\n- $1$-形式被构造为 $\\omega = A\\phi$。根据构造，$\\omega$ 位于 $A$ 的像空间中，因此它是正合的。\n- 由于 $BA=0$，它也必须是闭的，因此我们预期闭合缺陷 $c = \\|B\\omega\\|_2$ 为零（或机器精度）。\n- 由于 $\\omega$ 精确地在 $A$ 的像空间中，$\\phi$ 的重构应该是完美的（在一个常数范围内），重构残差比 $r$ 也应为零（或机器精度）。\n\n**情况 2：单连通，近似闭形式**\n- 给定 $n_x=7, n_y=5$。该域是单连通的。\n- $1$-形式 $\\omega$ 是通过在每条边上使用中点法则近似一个保守矢量场 $\\mathbf{v} = \\nabla\\phi^\\star$ 的线积分来构造的。边 $e$ 上的积分近似为 $\\omega_e \\approx \\mathbf{v}(\\mathbf{x}_{mid}) \\cdot \\mathbf{t}_e$，其中 $\\mathbf{x}_{mid}$ 是边的中点，$\\mathbf{t}_e$ 是有向切向量（其大小为边长）。\n- 由于连续矢量场是无旋的，$\\omega$ 的离散旋度应该很小，但由于求积误差而不为零。因此，我们预期有一个小的闭合缺陷 $c > 0$。\n- 因为 $\\omega$ 只是一个正合形式的近似，它不会完美地位于 $\\text{im}(A)$ 中。我们预期有一个小的但非零的重构残差比 $r > 0$。\n\n**情况 3：单连通，非闭形式**\n- 给定 $n_x=7, n_y=5$。该域是单连通的。\n- $1$-形式 $\\omega$ 的构造方式与情况 2 相同，但来自一个非保守矢量场 $\\mathbf{v}(x,y) = (-y, x)$，其具有恒定的旋度 $2$。\n- 离散旋度 $B\\omega$ 近似于连续旋度，因此它应该显著不为零。我们预期有一个大的闭合缺陷 $c > 0$。\n- 一个非闭形式不可能是正合的。因此，我们预期有一个大的重构残差比 $r > 0$。\n\n**情况 4：带孔洞的域，闭合但非正合形式**\n- 给定 $n_x=6, n_y=6$，并通过移除单元 $(3,3)$ 来创建一个孔洞。该域不再是可收缩的。其第一同调群非平凡，意味着存在非正合的闭 $1$-形式。\n- 我们通过求解一个约束优化问题来寻找这样的形式 $\\omega$：$\\min \\frac{1}{2}\\|\\omega\\|_2^2$ subject to $B\\omega=0$ 和 $C^\\top\\omega=1$。\n- 约束 $B\\omega=0$ 强制该形式是闭的。注意，该域的矩阵 $B$ 缺少与被移除单元相对应的那一行。\n- 约束 $C^\\top\\omega=1$ 强制 $\\omega$ 围绕一个不可收缩环路 $C$（孔洞的边界）的线积分为 $1$。这确保了 $\\omega$ 不可能是正合的，因为如果 $\\omega = A\\phi$，根据线积分的离散微积分基本定理，围绕任何闭环的积分必须为零。\n- 该问题使用拉格朗日乘子法求解，得到 KKT 系统：\n  $$ \\begin{pmatrix} I  B^\\top  C \\\\ B  0  0 \\\\ C^\\top  0  0 \\end{pmatrix} \\begin{pmatrix} \\omega \\\\ \\mu \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} $$\n  其中 $\\mu$ 和 $\\lambda$ 是拉格朗日乘子。求解该系统可得到所需的调和 $1$-形式 $\\omega$。\n- 根据构造，$B\\omega=0$，所以我们预期 $c \\approx 0$。\n- 因为 $C^\\top\\omega=1 \\neq 0$，$\\omega$ 不可能在 $\\text{im}(A)$ 中。因此，我们预期一个显著的非零重构残差 $r > 0$，这证明了庞加莱引理在非可收缩域上的失效。", "answer": "```python\nimport numpy as np\n\ndef build_matrices_and_indices(nx, ny, hole=None):\n    \"\"\"\n    Builds the node, edge, cell index mappings and the incidence matrices A and B.\n    \"\"\"\n    # Dimensions\n    num_nodes = (nx + 1) * (ny + 1)\n    num_h_edges = nx * (ny + 1)\n    num_v_edges = (nx + 1) * ny\n    num_edges = num_h_edges + num_v_edges\n    num_cells = nx * ny\n\n    # Indexing helper functions\n    def node_idx(i, j): return j * (nx + 1) + i\n    def h_edge_idx(i, j): return j * nx + i\n    def v_edge_idx(i, j): return num_h_edges + j * (nx + 1) + i\n    def cell_idx(i, j): return j * nx + i\n\n    # Matrix A: node-to-edge incidence (discrete gradient)\n    A = np.zeros((num_edges, num_nodes))\n    for j in range(ny + 1):\n        for i in range(nx):\n            idx = h_edge_idx(i, j)\n            A[idx, node_idx(i, j)] = -1\n            A[idx, node_idx(i + 1, j)] = 1\n    for j in range(ny):\n        for i in range(nx + 1):\n            idx = v_edge_idx(i, j)\n            A[idx, node_idx(i, j)] = -1\n            A[idx, node_idx(i, j + 1)] = 1\n\n    # Matrix B: edge-to-cell incidence (discrete curl)\n    rows_B, cols_B, data_B = [], [], []\n    num_cells_with_hole = num_cells\n    hole_cell_index = -1\n    if hole:\n        hole_cell_index = cell_idx(hole[0], hole[1])\n        num_cells_with_hole -= 1\n\n    cell_row_counter = 0\n    for j in range(ny):\n        for i in range(nx):\n            current_cell_index = cell_idx(i, j)\n            if current_cell_index == hole_cell_index:\n                continue\n            \n            # Bottom edge: (i,j) -> (i+1,j) -> sign +1\n            rows_B.append(cell_row_counter); cols_B.append(h_edge_idx(i, j)); data_B.append(1)\n            # Right edge: (i+1,j) -> (i+1,j+1) -> sign +1\n            rows_B.append(cell_row_counter); cols_B.append(v_edge_idx(i + 1, j)); data_B.append(1)\n            # Top edge: (i,j+1) -> (i+1,j+1) -> sign -1\n            rows_B.append(cell_row_counter); cols_B.append(h_edge_idx(i, j + 1)); data_B.append(-1)\n            # Left edge: (i,j) -> (i,j+1) -> sign -1\n            rows_B.append(cell_row_counter); cols_B.append(v_edge_idx(i, j)); data_B.append(-1)\n            cell_row_counter += 1\n            \n    # Using a COO-like format and then building the matrix\n    B = np.zeros((num_cells_with_hole, num_edges))\n    for r, c, d in zip(rows_B, cols_B, data_B):\n        B[r, c] = d\n        \n    indices = {\n        'node': node_idx, 'h_edge': h_edge_idx, 'v_edge': v_edge_idx, 'cell': cell_idx,\n        'num_nodes': num_nodes, 'num_edges': num_edges, 'num_h_edges': num_h_edges\n    }\n    return A, B, indices\n\ndef calculate_metrics(A, B, omega):\n    \"\"\"\n    Computes closedness defect and potential reconstruction residual ratio.\n    \"\"\"\n    # Closedness defect\n    c = np.linalg.norm(B @ omega) if B.shape[0] > 0 else 0.0\n\n    # Potential reconstruction\n    ref_node_idx = 0  # Node (0,0) as reference\n    \n    # Handle case where omega is zero vector\n    omega_norm = np.linalg.norm(omega)\n    if omega_norm < 1e-15:\n        return c, 0.0\n        \n    # Solve constrained least squares: min ||A*phi - omega||^2 s.t. phi[0]=0\n    A_constrained = np.delete(A, ref_node_idx, axis=1)\n    phi_constrained, _, _, _ = np.linalg.lstsq(A_constrained, omega, rcond=None)\n    \n    phi = np.insert(phi_constrained, ref_node_idx, 0)\n    \n    # Reconstruction residual ratio\n    residual_norm = np.linalg.norm(A @ phi - omega)\n    r = residual_norm / omega_norm\n\n    return c, r\n\ndef solve():\n    results = []\n\n    # Case 1: Simply connected, exactly closed from potential\n    nx, ny = 4, 3\n    A, B, idx = build_matrices_and_indices(nx, ny)\n    phi = np.zeros(idx['num_nodes'])\n    for j in range(ny + 1):\n        for i in range(nx + 1):\n            x, y = i / nx, j / ny\n            node_k = idx['node'](i, j)\n            phi[node_k] = np.exp(x) * np.sin(2 * np.pi * y)\n    omega1 = A @ phi\n    c1, r1 = calculate_metrics(A, B, omega1)\n    results.extend([c1, r1])\n\n    # Case 2: Simply connected, approximately closed from conservative field\n    nx, ny = 7, 5\n    A, B, idx = build_matrices_and_indices(nx, ny)\n    omega2 = np.zeros(idx['num_edges'])\n    dx, dy = 1/nx, 1/ny\n    def v_field_conservative(x, y):\n        ex = np.exp(x)\n        sin_2py, cos_2py = np.sin(2 * np.pi * y), np.cos(2 * np.pi * y)\n        return ex * sin_2py, 2 * np.pi * ex * cos_2py\n    # Horizontal edges\n    for j in range(ny + 1):\n        for i in range(nx):\n            mid_x, mid_y = (i + 0.5) / nx, j / ny\n            vx, _ = v_field_conservative(mid_x, mid_y)\n            omega2[idx['h_edge'](i, j)] = vx * dx\n    # Vertical edges\n    for j in range(ny):\n        for i in range(nx + 1):\n            mid_x, mid_y = i / nx, (j + 0.5) / ny\n            _, vy = v_field_conservative(mid_x, mid_y)\n            omega2[idx['v_edge'](i, j)] = vy * dy\n    c2, r2 = calculate_metrics(A, B, omega2)\n    results.extend([c2, r2])\n\n    # Case 3: Simply connected, non-closed field\n    nx, ny = 7, 5\n    A, B, idx = build_matrices_and_indices(nx, ny)\n    omega3 = np.zeros(idx['num_edges'])\n    dx, dy = 1/nx, 1/ny\n    def v_field_non_conservative(x, y): return -y, x\n    # Horizontal edges\n    for j in range(ny + 1):\n        for i in range(nx):\n            mid_x, mid_y = (i + 0.5) / nx, j / ny\n            vx, _ = v_field_non_conservative(mid_x, mid_y)\n            omega3[idx['h_edge'](i, j)] = vx * dx\n    # Vertical edges  \n    for j in range(ny):\n        for i in range(nx + 1):\n            mid_x, mid_y = i / nx, (j + 0.5) / ny\n            _, vy = v_field_non_conservative(mid_x, mid_y)\n            omega3[idx['v_edge'](i, j)] = vy * dy\n    c3, r3 = calculate_metrics(A, B, omega3)\n    results.extend([c3, r3])\n\n    # Case 4: Hole, closed but not exact form\n    nx, ny = 6, 6\n    hole_loc = (3, 3)\n    A, B, idx = build_matrices_and_indices(nx, ny, hole=hole_loc)\n    # Construct cycle vector C\n    C = np.zeros(idx['num_edges'])\n    i0, j0 = hole_loc\n    C[idx['h_edge'](i0, j0)] = 1      # Bottom\n    C[idx['v_edge'](i0 + 1, j0)] = 1  # Right\n    C[idx['h_edge'](i0, j0 + 1)] = -1 # Top\n    C[idx['v_edge'](i0, j0)] = -1    # Left\n    # Solve KKT system for mu, lambda\n    num_remaining_cells = B.shape[0]\n    KKT_size = num_remaining_cells + 1\n    KKT_mat = np.zeros((KKT_size, KKT_size))\n    \n    BBT = B @ B.T\n    BC = B @ C\n    CTC = C.T @ C\n    \n    KKT_mat[:num_remaining_cells, :num_remaining_cells] = BBT\n    KKT_mat[:num_remaining_cells, -1] = BC\n    KKT_mat[-1, :num_remaining_cells] = BC.T\n    KKT_mat[-1, -1] = CTC\n    \n    rhs = np.zeros(KKT_size)\n    rhs[-1] = 1.0\n    \n    sol = np.linalg.solve(KKT_mat, rhs)\n    mu = sol[:-1]\n    lambda_val = sol[-1]\n    \n    omega4 = B.T @ mu + C * lambda_val\n    c4, r4 = calculate_metrics(A, B, omega4)\n    results.extend([c4, r4])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3372213"}]}