{"hands_on_practices": [{"introduction": "本练习提供了一个具体的分步演练，展示了分层矩限制器如何在单个计算单元上操作。通过从最高阶到最低阶手动调整多项式的模态系数，您将直接观察到限制器如何强制施加单元边界上的物理界限，从而抑制非物理振荡。在进行自动化实现之前，这种手动计算是理解限制过程内部工作机制的基础。[@problem_id:3400905]", "problem": "考虑一个一维空间和一个不连续伽辽金 (DG) 离散的单个单元，该单元被映射到参考区间 $\\xi \\in [-1,1]$。设局部 DG 近似在标准勒让德多项式基 $\\{P_{0}(\\xi),P_{1}(\\xi),P_{2}(\\xi),P_{3}(\\xi)\\}$ 中展开：\n$$\nu_{i}(\\xi) \\;=\\; a_{0} P_{0}(\\xi) \\;+\\; a_{1} P_{1}(\\xi) \\;+\\; a_{2} P_{2}(\\xi) \\;+\\; a_{3} P_{3}(\\xi),\n$$\n其模态向量为 $(a_{0},a_{1},a_{2},a_{3})$。假设 $P_{0}(\\xi)=1$, $P_{1}(\\xi)=\\xi$, $P_{2}(\\xi)=\\frac{3\\xi^{2}-1}{2}$ 和 $P_{3}(\\xi)=\\frac{5\\xi^{3}-3\\xi}{2}$，因此对于所有 $k$ 都有 $P_{k}(1)=1$ 且 $P_{k}(-1)=(-1)^{k}$。单元平均值等于 $a_{0}$，因为对于 $k\\ge 1$ 有 $\\int_{-1}^{1} P_{k}(\\xi)\\,\\mathrm{d}\\xi=0$ 且 $\\int_{-1}^{1} P_{0}(\\xi)\\,\\mathrm{d}\\xi=2$。\n\n给定3阶模态向量\n$$\n(a_{0},a_{1},a_{2},a_{3}) \\;=\\; (0.9,\\,0.2,\\,0.1,\\,0.15),\n$$\n以及相邻单元的平均值\n$$\n\\bar{u}_{i-1} \\;=\\; 0.6, \\qquad \\bar{u}_{i+1} \\;=\\; 1.1.\n$$\n通过下式定义右侧界面（在 $\\xi=+1$ 处）的容许界\n$$\nL^{+} \\;=\\; \\min\\{\\bar{u}_{i},\\bar{u}_{i+1}\\} \\;=\\; \\min\\{a_{0},\\bar{u}_{i+1}\\}, \\qquad U^{+} \\;=\\; \\max\\{\\bar{u}_{i},\\bar{u}_{i+1}\\} \\;=\\; \\max\\{a_{0},\\bar{u}_{i+1}\\},\n$$\n以及左侧界面（在 $\\xi=-1$ 处）的容许界\n$$\nL^{-} \\;=\\; \\min\\{\\bar{u}_{i-1},\\bar{u}_{i}\\} \\;=\\; \\min\\{\\bar{u}_{i-1},a_{0}\\}, \\qquad U^{-} \\;=\\; \\max\\{\\bar{u}_{i-1},\\bar{u}_{i}\\} \\;=\\; \\max\\{\\bar{u}_{i-1},a_{0}\\}.\n$$\n\n借鉴 Krivodonova 方法的思想，应用一个分层矩限制器，该限制器在 $\\xi=\\pm 1$ 处强制施加界面界限，具体如下。对于 $k=3,2,1$，更新 $a_{k}$，同时保持所有其他系数的当前值不变。令 $S_{+}^{\\neq k}$ 表示除 $a_{k}$ 外所有模态对 $u_{i}(+1)$ 的贡献，令 $S_{-}^{\\neq k}$ 表示除 $a_{k}$ 外所有模态对 $u_{i}(-1)$ 的贡献，即：\n$$\nS_{+}^{\\neq k} \\;=\\; \\sum_{m\\neq k} a_{m} P_{m}(1), \\qquad S_{-}^{\\neq k} \\;=\\; \\sum_{m\\neq k} a_{m} P_{m}(-1).\n$$\n从右侧界面计算 $a_{k}$ 的容许区间，\n$$\nI_{k}^{+} \\;=\\; \\left[\\,L^{+} - S_{+}^{\\neq k},\\; U^{+} - S_{+}^{\\neq k}\\,\\right],\n$$\n并从左侧界面计算，使用 $P_{k}(-1)=(-1)^{k}$，\n$$\nI_{k}^{-} \\;=\\; \\left\\{ a_{k}\\in\\mathbb{R} \\;:\\; L^{-} \\le S_{-}^{\\neq k} + a_{k} P_{k}(-1) \\le U^{-} \\right\\}.\n$$\n等价地，\n$$\nI_{k}^{-} \\;=\\; \\begin{cases}\n\\left[\\,L^{-} - S_{-}^{\\neq k},\\; U^{-} - S_{-}^{\\neq k}\\,\\right],  \\text{若 } P_{k}(-1)=+1,\\\\[4pt]\n\\left[\\,S_{-}^{\\neq k} - U^{-},\\; S_{-}^{\\neq k} - L^{-}\\,\\right],  \\text{若 } P_{k}(-1)=-1.\n\\end{cases}\n$$\n设置受限系数\n$$\na_{k}^{\\text{lim}} \\;=\\; \\operatorname{clamp}\\!\\left( a_{k},\\; I_{k}^{+} \\cap I_{k}^{-} \\right),\n$$\n其中 $\\operatorname{clamp}(x,[\\ell,u])=\\min\\{\\max\\{x,\\ell\\},u\\}$，并且在此设定中假设交集 $I_{k}^{+}\\cap I_{k}^{-}$ 非空。从 $k=3$ 到 $k=1$ 分层进行，每一步都就地更新 $a_{k}$。不要改变 $a_{0}$。\n\n计算由此分层限制器产生的受限模态向量 $(a_{0}^{\\text{lim}},a_{1}^{\\text{lim}},a_{2}^{\\text{lim}},a_{3}^{\\text{lim}})$。以受限系数向量的形式提供您的最终答案。如果任何算术运算导致多个候选值，请选择指定交集中的唯一值。无需四舍五入。", "solution": "首先验证问题。问题陈述为不连续伽辽金方法中使用的分层矩限制器程序提供了清晰、自洽且有科学依据的描述。所有需要的数据、定义和约束都已提供。该程序在算法上是确定性的且适定的。没有矛盾、歧义或违反科学原理之处。因此，该问题被视为有效，并将提供解答。\n\n目标是通过对初始模态向量 $(a_{0}, a_{1}, a_{2}, a_{3}) = (0.9, 0.2, 0.1, 0.15)$ 应用分层矩限制器，来计算受限模态向量 $(a_{0}^{\\text{lim}}, a_{1}^{\\text{lim}}, a_{2}^{\\text{lim}}, a_{3}^{\\text{lim}})$。该限制器从最高阶模态 $k=3$ 开始，依次向下到 $k=1$，就地更新系数。代表单元平均值的零阶模态 $a_{0}$ 保持不变。\n\n首先，我们建立解在单元界面 $\\xi=+1$ 和 $\\xi=-1$ 处的容许界。给定的数据是：\n-   单元平均值： $\\bar{u}_{i} = a_{0} = 0.9$。\n-   左相邻单元平均值： $\\bar{u}_{i-1} = 0.6$。\n-   右相邻单元平均值： $\\bar{u}_{i+1} = 1.1$。\n\n右侧界面 ($\\xi=+1$) 的界限是：\n$$\nL^{+} = \\min\\{a_{0}, \\bar{u}_{i+1}\\} = \\min\\{0.9, 1.1\\} = 0.9\n$$\n$$\nU^{+} = \\max\\{a_{0}, \\bar{u}_{i+1}\\} = \\max\\{0.9, 1.1\\} = 1.1\n$$\n因此，$\\xi=+1$ 处的解必须位于区间 $[0.9, 1.1]$ 内。\n\n左侧界面 ($\\xi=-1$) 的界限是：\n$$\nL^{-} = \\min\\{\\bar{u}_{i-1}, a_{0}\\} = \\min\\{0.6, 0.9\\} = 0.6\n$$\n$$\nU^{-} = \\max\\{\\bar{u}_{i-1}, a_{0}\\} = \\max\\{0.6, 0.9\\} = 0.9\n$$\n因此，$\\xi=-1$ 处的解必须位于区间 $[0.6, 0.9]$ 内。\n\n勒让德多项式在界面处的取值为 $P_{k}(1) = 1$ 和 $P_{k}(-1) = (-1)^{k}$。分层限制过程从初始模态向量 $(a_{0}, a_{1}, a_{2}, a_{3}) = (0.9, 0.2, 0.1, 0.15)$ 开始。\n\n**第1步：限制 $a_{3}$ (对于 $k=3$)**\n\n当前模态向量为 $(0.9, 0.2, 0.1, 0.15)$。我们限制 $a_{3} = 0.15$。\n其他模态在界面处的贡献总和是：\n$$\nS_{+}^{\\neq 3} = \\sum_{m=0}^{2} a_{m} P_{m}(1) = a_{0} + a_{1} + a_{2} = 0.9 + 0.2 + 0.1 = 1.2\n$$\n$$\nS_{-}^{\\neq 3} = \\sum_{m=0}^{2} a_{m} P_{m}(-1) = a_{0} P_{0}(-1) + a_{1} P_{1}(-1) + a_{2} P_{2}(-1) = a_{0} - a_{1} + a_{2} = 0.9 - 0.2 + 0.1 = 0.8\n$$\n解在界面处的值为 $u_{i}(1) = S_{+}^{\\neq 3} + a_{3} P_{3}(1) = 1.2 + a_{3}$ 和 $u_{i}(-1) = S_{-}^{\\neq 3} + a_{3} P_{3}(-1) = 0.8 - a_{3}$。\n\n根据右侧界面约束 $L^{+} \\le u_{i}(1) \\le U^{+}$， $a_{3}$ 的容许区间为：\n$$\n0.9 \\le 1.2 + a_{3} \\le 1.1 \\implies -0.3 \\le a_{3} \\le -0.1\n$$\n因此，$I_{3}^{+} = [-0.3, -0.1]$。\n\n根据左侧界面约束 $L^{-} \\le u_{i}(-1) \\le U^{-}$， $a_{3}$ 的容许区间为：\n$$\n0.6 \\le 0.8 - a_{3} \\le 0.9 \\implies -0.2 \\le -a_{3} \\le 0.1 \\implies -0.1 \\le a_{3} \\le 0.2\n$$\n因此，$I_{3}^{-} = [-0.1, 0.2]$。\n\n这些区间的交集是 $I_{3} = I_{3}^{+} \\cap I_{3}^{-} = [-0.3, -0.1] \\cap [-0.1, 0.2] = \\{-0.1\\}$。\n受限系数 $a_{3}^{\\text{lim}}$ 是通过将原始值 $a_{3}=0.15$ 截断到此区间内得到的：\n$$\na_{3}^{\\text{lim}} = \\operatorname{clamp}(0.15, [-0.1, -0.1]) = -0.1\n$$\n模态向量更新为 $(0.9, 0.2, 0.1, -0.1)$。\n\n**第2步：限制 $a_{2}$ (对于 $k=2$)**\n\n当前模态向量为 $(0.9, 0.2, 0.1, -0.1)$。我们限制 $a_{2} = 0.1$。其他系数，包括新限制的 $a_{3}^{\\text{lim}}$，保持固定。\n其他模态的贡献总和是：\n$$\nS_{+}^{\\neq 2} = a_{0} + a_{1} + a_{3} = 0.9 + 0.2 + (-0.1) = 1.0\n$$\n$$\nS_{-}^{\\neq 2} = a_{0} - a_{1} - a_{3} = 0.9 - 0.2 - (-0.1) = 0.8\n$$\n由于 $P_{2}(-1) = 1$，解在界面处的值为 $u_{i}(1) = S_{+}^{\\neq 2} + a_{2}$ 和 $u_{i}(-1) = S_{-}^{\\neq 2} + a_{2}$。\n\n根据右侧界面，$a_{2}$ 的区间是：\n$$\n0.9 \\le 1.0 + a_{2} \\le 1.1 \\implies -0.1 \\le a_{2} \\le 0.1\n$$\n因此，$I_{2}^{+} = [-0.1, 0.1]$。\n\n根据左侧界面，$a_{2}$ 的区间是：\n$$\n0.6 \\le 0.8 + a_{2} \\le 0.9 \\implies -0.2 \\le a_{2} \\le 0.1\n$$\n因此，$I_{2}^{-} = [-0.2, 0.1]$。\n\n交集是 $I_{2} = I_{2}^{+} \\cap I_{2}^{-} = [-0.1, 0.1] \\cap [-0.2, 0.1] = [-0.1, 0.1]$。\n受限系数 $a_{2}^{\\text{lim}}$ 是：\n$$\na_{2}^{\\text{lim}} = \\operatorname{clamp}(0.1, [-0.1, 0.1]) = 0.1\n$$\n原始值 $a_{2}=0.1$ 已经处于容许区间内，因此保持不变。模态向量仍然是 $(0.9, 0.2, 0.1, -0.1)$。\n\n**第3步：限制 $a_{1}$ (对于 $k=1$)**\n\n当前模态向量为 $(0.9, 0.2, 0.1, -0.1)$。我们限制 $a_{1} = 0.2$。\n其他模态的贡献总和是：\n$$\nS_{+}^{\\neq 1} = a_{0} + a_{2} + a_{3} = 0.9 + 0.1 + (-0.1) = 0.9\n$$\n$$\nS_{-}^{\\neq 1} = a_{0} + a_{2} - a_{3} = 0.9 + 0.1 - (-0.1) = 1.1\n$$\n由于 $P_{1}(-1) = -1$，解在界面处的值为 $u_{i}(1) = S_{+}^{\\neq 1} + a_{1}$ 和 $u_{i}(-1) = S_{-}^{\\neq 1} - a_{1}$。\n\n根据右侧界面，$a_{1}$ 的区间是：\n$$\n0.9 \\le 0.9 + a_{1} \\le 1.1 \\implies 0 \\le a_{1} \\le 0.2\n$$\n因此，$I_{1}^{+} = [0, 0.2]$。\n\n根据左侧界面，$a_{1}$ 的区间是：\n$$\n0.6 \\le 1.1 - a_{1} \\le 0.9 \\implies -0.5 \\le -a_{1} \\le -0.2 \\implies 0.2 \\le a_{1} \\le 0.5\n$$\n因此，$I_{1}^{-} = [0.2, 0.5]$。\n\n交集是 $I_{1} = I_{1}^{+} \\cap I_{1}^{-} = [0, 0.2] \\cap [0.2, 0.5] = \\{0.2\\}$。\n受限系数 $a_{1}^{\\text{lim}}$ 是：\n$$\na_{1}^{\\text{lim}} = \\operatorname{clamp}(0.2, [0.2, 0.2]) = 0.2\n$$\n原始值 $a_{1}=0.2$ 已经处于容许区间的边界上，因此保持不变。模态向量仍然是 $(0.9, 0.2, 0.1, -0.1)$。\n\n根据定义，系数 $a_{0}$ 不变。因此，$a_{0}^{\\text{lim}}=0.9$。\n最终的受限模态向量为 $(a_{0}^{\\text{lim}}, a_{1}^{\\text{lim}}, a_{2}^{\\text{lim}}, a_{3}^{\\text{lim}})$。\n汇总结果：\n$a_{0}^{\\text{lim}} = 0.9$\n$a_{1}^{\\text{lim}} = 0.2$\n$a_{2}^{\\text{lim}} = 0.1$\n$a_{3}^{\\text{lim}} = -0.1$\n\n最终的受限向量为 $(0.9, 0.2, 0.1, -0.1)$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 0.9  0.2  0.1  -0.1 \\end{pmatrix}}\n$$", "id": "3400905"}, {"introduction": "前面的练习展示了限制器“做什么”，而本实践则关注于决定“何时”应用它。我们引入了影响深远的 Persson-Peraire 问题单元探测器，它通过分析解的模态系数能量谱来检测潜在的激波。您将为一个二维三角形单元实现该探测器，学习如何从已存储的系数中高效地计算它，并理解其对不同解剖面的敏感性，这是开发稳健高阶格式的一项关键技能。[@problem_id:3400893]", "problem": "给定一个参考三角形上的高阶间断 Galerkin (DG) 离散化，其使用一个 Dubiner 模态基，该基相对于参考单元上的标准 $L^{2}$ 内积是标准正交的。Dubiner 基是按总阶数组织的：对于多项式阶数 $p$，模态系数的集合是 $\\{ \\hat{u}_{i,j} \\}_{i,j \\ge 0,\\, i+j \\le p}$。假设系数存储在一个一维数组中，首先按总阶数 $n = i + j$ 从 $n = 0$ 到 $n = p$ 升序排列，然后在每个总阶数 $n$ 内，按 $i$ 从 $n$ 到 $0$ 的降序排列（其中 $j = n-i$）。模态总数为 $N_{p} = \\frac{(p+1)(p+2)}{2}$。\n\n一维 Legendre 多项式的 Persson–Peraire 矩衰减传感器通过比较最高总阶数模态携带的能量与总能量，推广到三角形上。设总模态能量为\n\n$$\nE_{\\mathrm{tot}} = \\sum_{i+j \\le p} \\hat{u}_{i,j}^{2},\n$$\n\n最高阶能量为\n\n$$\nE_{p} = \\sum_{i+j = p} \\hat{u}_{i,j}^{2}.\n$$\n\n定义传感器\n\n$$\nS = \\log_{10}\\!\\left( \\frac{E_{p}}{E_{\\mathrm{tot}} + \\varepsilon} \\right),\n$$\n\n其中 $\\varepsilon$ 是一个小的正则化项，以避免除以零。如果 $S  \\tau$，则一个单元被标记为问题单元，其中 $\\tau$ 是一个选定的阈值。假设 $\\varepsilon = 10^{-16}$ 且 $\\tau = -3$。\n\n仅从这些核心定义和 Dubiner 基的标准正交性出发，完成以下任务：\n\n1. 推导传感器 $S$ 关于存储的模态系数 $\\hat{u}_{i,j}$ 的表达式，并解释为什么标准正交性意味着在参考三角形上计算 $E_{\\mathrm{tot}}$ 和 $E_{p}$ 时不需要几何度量因子。\n\n2. 提出一种高效计算 $S$ 的算法，该算法仅使用存储的系数和已知的存储顺序，而无需在物理空间中重构解。您的算法时间复杂度必须是 $ \\mathcal{O}(N_{p}) $，并且必须避免显式的几何变换。展示如何在仅依赖于 $p$ 的预计算后，以常数时间计算对应于最高总阶数 $p$ 的索引范围。\n\n3. 解释为什么该传感器对单元内的斜激波敏感，即使激波未与坐标轴对齐，并将其与最高总阶数矩的分布情况联系起来。\n\n4. 实现一个程序，为以下每个测试用例计算问题单元标记。在每个案例中，根据指定的规则构建一维系数数组 $[\\hat{u}_{0,0}, \\hat{u}_{1,0}, \\hat{u}_{0,1}, \\hat{u}_{2,0}, \\hat{u}_{1,1}, \\hat{u}_{0,2}, \\dots]$。对于每个案例，计算 $S$ 并输出结果：如果单元是问题单元则输出 $1$，否则输出 $0$。使用 $\\tau = -3$ 和 $\\varepsilon = 10^{-16}$。\n\n   - 案例 A（光滑）：$p = 4$。对于每个满足 $i+j \\le p$ 的 $(i,j)$，设置 $\\hat{u}_{i,j} = \\alpha \\, \\rho^{\\, i + j}$，其中 $\\alpha = 7 \\times 10^{-1}$ 和 $\\rho = 2 \\times 10^{-1}$。\n\n   - 案例 B（类激波的代数衰减）：$p = 5$。对于每个 $(i,j)$，设置 $\\hat{u}_{i,j} = \\dfrac{1}{1 + i + j}$。\n\n   - 案例 C（零场）：$p = 3$。对于每个 $(i,j)$，设置 $\\hat{u}_{i,j} = 0$。\n\n   - 案例 D（斜激波各向异性替代）：$p = 5$。对于每个 $(i,j)$，设置 $\\hat{u}_{i,j} = \\dfrac{1}{1 + i + 3 j}$。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如，$[r_{A}, r_{B}, r_{C}, r_{D}]$），其中 $r_{\\bullet} \\in \\{0,1\\}$ 是对应测试用例的问题单元标记。\n\n本问题中所有量均为无量纲，无需物理单位。如果涉及角度，则不使用。每个测试用例的预期输出类型为整数。该测试套件旨在覆盖光滑情况、强类激波情况、退化的零能量情况，以及一个加载高阶交叉耦合矩的各向异性斜激波替代情况。", "solution": "此问题经评估是有效的。它在偏微分方程数值方法领域有科学依据，具体涉及高阶间断 Galerkin (DG) 方法。该问题是适定的，提供了所有必要的定义、常数和数据以得出唯一、可验证的解。其语言客观精确。\n\n### 1. 传感器表达式的推导及标准正交性的作用\n\n在参考三角形单元 $\\hat{K}$ 内的解 $u(\\mathbf{x})$ 可表示为在一个标准正交 Dubiner 模态基 $\\{\\phi_{i,j}(\\mathbf{x})\\}_{i+j \\le p}$ 上的有限展开：\n$$\nu(\\mathbf{x}) = \\sum_{i,j \\ge 0, i+j \\le p} \\hat{u}_{i,j} \\phi_{i,j}(\\mathbf{x})\n$$\n其中 $\\hat{u}_{i,j}$ 是模态系数，$p$ 是最大多项式阶数。题目指定该基相对于参考单元上的标准 $L^2$ 内积 $\\langle f, g \\rangle_{\\hat{K}} = \\int_{\\hat{K}} f(\\mathbf{x})g(\\mathbf{x}) d\\mathbf{x}$ 是标准正交的。此标准正交条件表示为：\n$$\n\\langle \\phi_{i,j}, \\phi_{k,l} \\rangle_{\\hat{K}} = \\delta_{ik}\\delta_{jl}\n$$\n其中 $\\delta$ 是克罗内克 δ (Kronecker delta)。\n\n参考单元上解的总能量是其 $L^2$-范数的平方，即 $\\|u\\|_{L^2(\\hat{K})}^2$。我们可以使用模态展开来表示它：\n$$\n\\|u\\|_{L^2(\\hat{K})}^2 = \\langle u, u \\rangle_{\\hat{K}} = \\left\\langle \\sum_{i+j \\le p} \\hat{u}_{i,j} \\phi_{i,j}, \\sum_{k+l \\le p} \\hat{u}_{k,l} \\phi_{k,l} \\right\\rangle_{\\hat{K}}\n$$\n根据内积的双线性性质，这变为：\n$$\n\\|u\\|_{L^2(\\hat{K})}^2 = \\sum_{i+j \\le p} \\sum_{k+l \\le p} \\hat{u}_{i,j} \\hat{u}_{k,l} \\langle \\phi_{i,j}, \\phi_{k,l} \\rangle_{\\hat{K}}\n$$\n代入标准正交条件 $\\langle \\phi_{i,j}, \\phi_{k,l} \\rangle_{\\hat{K}} = \\delta_{ik}\\delta_{jl}$：\n$$\n\\|u\\|_{L^2(\\hat{K})}^2 = \\sum_{i+j \\le p} \\sum_{k+l \\le p} \\hat{u}_{i,j} \\hat{u}_{k,l} \\delta_{ik}\\delta_{jl} = \\sum_{i+j \\le p} \\hat{u}_{i,j}^2\n$$\n这是帕塞瓦尔定理 (Parseval's theorem) 的一种表述。问题将总模态能量定义为 $E_{\\mathrm{tot}} = \\sum_{i+j \\le p} \\hat{u}_{i,j}^{2}$。因此，$E_{\\mathrm{tot}}$ 精确地等于解的 $L^2$-范数的平方，其计算只是系数平方的简单求和。由于基在参考单元 $\\hat{K}$ 上是标准正交的，并且所有计算都在此参考空间中执行，因此不需要几何度量因子（例如，来自映射的雅可比行列式）。\n\n由最高总阶数模态携带的能量 $E_p$，是总阶数恰好为 $p$ 的系数平方和：\n$$\nE_p = \\sum_{i+j = p} \\hat{u}_{i,j}^{2}\n$$\n这个量分离出了在所选多项式空间中最高频率基函数的能量贡献。\n\n然后，Persson–Peraire 传感器 $S$ 使用这些能量度量来定义：\n$$\nS = \\log_{10}\\!\\left( \\frac{E_{p}}{E_{\\mathrm{tot}} + \\varepsilon} \\right) = \\log_{10}\\!\\left( \\frac{\\sum_{i+j = p} \\hat{u}_{i,j}^{2}}{\\sum_{k+l \\le p} \\hat{u}_{k,l}^{2} + \\varepsilon} \\right)\n$$\n其中 $\\varepsilon$ 是一个小的正则化参数，用于防止当解恒为零时出现除以零的情况。此公式仅依赖于模态系数。\n\n### 2. 传感器计算的高效算法\n\n目标是设计一个时间复杂度为 $\\mathcal{O}(N_p)$ 的算法，从一维模态系数数组中计算 $S$，其中 $N_p = \\frac{(p+1)(p+2)}{2}$ 是模态总数。问题指定系数首先按总阶数 $n = i+j$ 升序排列（从 $n=0$ 到 $n=p$），并提供了一个存储模式示例 `[\\hat{u}_{0,0}, \\hat{u}_{1,0}, \\hat{u}_{0,1}, \\hat{u}_{2,0}, \\hat{u}_{1,1}, \\hat{u}_{0,2}, \\dots]`。此示例清晰地表明，对于给定的总阶数 $n$，模态是按索引 $i$ 降序排列的（从 $n$ 到 $0$）。\n\n要计算 $S$，我们需要计算两个和：$E_{\\mathrm{tot}}$（所有系数的平方和）和 $E_p$（对应于总阶数 $p$ 的系数平方和）。\n\n总阶数小于 $p$（即直到 $p-1$ 阶）的模态总数为 $N_{p-1} = \\frac{((p-1)+1)((p-1)+2)}{2} = \\frac{p(p+1)}{2}$。在一个零基索引的数组中，这些模态占据索引 $0, 1, \\dots, N_{p-1}-1$。因此，总阶数为 $p$ 的模态从索引 $N_{p-1}$ 开始。阶数为 $p$ 的模态有 $p+1$ 个。\n\n给定 $p$，最高阶模态的起始索引可以在常数时间内计算：\n$$\n\\text{start\\_index}_p = N_{p-1} = \\frac{p(p+1)}{2}\n$$\n\n算法流程如下：\n1.  给定多项式阶数 $p$ 和长度为 $N_p$ 的一维系数数组 `u_coeffs`。\n2.  计算最高阶模态的起始索引：`idx_start_p = p * (p + 1) // 2`。这是一个常数时间的预计算。\n3.  通过对最高阶模态的系数求平方和来计算 $E_p$。这对应于对数组从 `idx_start_p` 到末尾进行切片：\n    `E_p = sum(c*c for c in u_coeffs[idx_start_p:])`。\n4.  通过对数组中所有系数求平方和来计算 $E_{\\mathrm{tot}}$：\n    `E_tot = sum(c*c for c in u_coeffs)`。一个小的优化是计算 $0$ 到 $p-1$ 阶的和，然后加上 $E_p$。\n5.  使用给定公式计算传感器值：\n    `S = log10(E_p / (E_tot + epsilon))`。\n6.  将 $S$ 与阈值 $\\tau$ 比较，以确定单元是否为问题单元。\n\n该算法涉及对系数数组进行常数次迭代。主要成本是计算 $E_{\\mathrm{tot}}$ 的求和，该操作的复杂度与系数数量 $N_p$ 呈线性关系。因此，算法复杂度为 $\\mathcal{O}(N_p)$。不需要进行几何变换或在物理空间中重构解。\n\n### 3. 对斜激波的敏感性\n\n由于多项式逼近的光谱特性，Persson–Peraire 传感器能有效检测像激波这样尖锐且未被充分解析的特征。\n- **光谱衰减**：对于一个光滑函数（例如 $C^\\infty$），其在多项式基上的展开系数的衰减速度快于模态数的任何代数次幂（即光谱衰减）。在这种情况下，模态能量集中在低阶模态，而最高阶模态中的能量 $E_p$ 相对于总能量 $E_{\\mathrm{tot}}$ 极其微小。这导致 $E_p/E_{\\mathrm{tot}}$ 的比值非常小，$S$ 的值是一个很大的负数，通常远低于阈值 $\\tau$。\n- **间断性**：当函数存在间断时（如激波），其光谱系数的衰减要慢得多，通常是代数式的（例如 $|\\hat{u}_k| \\sim 1/k$）。这种缓慢衰减意味着需要将大量能量分配给高阶模态才能粗略地表示尖锐特征（这是吉布斯现象 (Gibbs phenomenon) 的一种表现）。因此，$E_p$ 将占 $E_{\\mathrm{tot}}$ 的一个不可忽略的部分。比值 $E_p/E_{\\mathrm{tot}}$ 会相对较大（例如 $10^{-3}$ 到 $10^{-1}$），导致 $S$ 的值大于阈值 $\\tau$。\n- **斜向**：斜激波是指未与参考单元的自然坐标轴对齐的激波。Dubiner 基函数由一维多项式的乘积构成，具有与这些轴相关的内在方向特性。一个与坐标方向对齐的特征可能会强烈激发特定的模态子集（例如那些 $j=0$ 或 $i=0$ 的模态）。然而，一个斜向特征无法被这样的子集有效表示，而是会投影到所有可用基函数的广泛组合上，包括 $i$ 和 $j$ 都不为零的交叉项。传感器的 $E_p = \\sum_{i+j=p} \\hat{u}_{i,j}^2$ 定义对*所有*最高阶模态的能量进行求和。因此，它在模态空间中是各向同性的；它对能量*如何*在 $p$ 阶的 $p+1$ 个模态中分布不敏感，只对该阶存在的总能量敏感。通过捕捉总的高频能量含量，该传感器能够稳健地检测未被充分解析的特征，而不管它们相对于单元坐标系的方向如何。\n\n### 4. 实现\n\n以下程序实现了所述算法，以对给定的测试用例进行分类。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the troubled-cell flag for several test cases of DG modal coefficients\n    using the Persson–Peraire moment-decay sensor.\n    \"\"\"\n    epsilon = 1e-16\n    tau = -3.0\n\n    test_cases = [\n        {\n            \"name\": \"Case A (smooth)\",\n            \"p\": 4,\n            \"rule\": lambda i, j: 7e-1 * (2e-1)**(i + j)\n        },\n        {\n            \"name\": \"Case B (shock-like algebraic decay)\",\n            \"p\": 5,\n            \"rule\": lambda i, j: 1.0 / (1.0 + i + j)\n        },\n        {\n            \"name\": \"Case C (zero field)\",\n            \"p\": 3,\n            \"rule\": lambda i, j: 0.0\n        },\n        {\n            \"name\": \"Case D (oblique-shock anisotropy surrogate)\",\n            \"p\": 5,\n            \"rule\": lambda i, j: 1.0 / (1.0 + i + 3.0 * j)\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        p = case[\"p\"]\n        rule = case[\"rule\"]\n\n        # 1. Generate coefficients based on the specified ordering.\n        # The ordering is by total degree n = i + j, and for each n, by descending i.\n        # This follows the problem's explicit example: [u_00, u_10, u_01, u_20, ...].\n        coeffs_list = []\n        for n in range(p + 1):\n            for i in range(n, -1, -1):\n                j = n - i\n                coeffs_list.append(rule(i, j))\n        \n        u_hat = np.array(coeffs_list, dtype=np.float64)\n\n        # 2. Compute the start index for the highest-degree (p) modes.\n        # Number of modes up to degree p-1 is N_{p-1} = p*(p+1)/2.\n        start_index_p = p * (p + 1) // 2\n\n        # 3. Calculate E_p and E_tot.\n        if u_hat.size  0:\n            u_hat_sq = u_hat**2\n            # Energy in highest-degree modes\n            E_p = np.sum(u_hat_sq[start_index_p:])\n            # Total energy\n            E_tot = np.sum(u_hat_sq)\n        else: # Handles p  0, though not in test cases\n            E_p = 0.0\n            E_tot = 0.0\n\n        # 4. Compute the sensor S.\n        # Use np.log10 for base-10 logarithm.\n        # The ratio is E_p / (E_tot + epsilon).\n        # np.log10(0) returns -inf, which is correctly handled.\n        ratio = E_p / (E_tot + epsilon)\n        # It's possible for E_p and E_tot to be extremely small, making the ratio\n        # effectively zero due to floating point precision before log10 is taken.\n        if ratio  1e-300: # np.log10(small_number) - -inf\n            S = -np.inf\n        else:\n            S = np.log10(ratio)\n\n        # 5. Determine if the cell is troubled.\n        is_troubled = 1 if S  tau else 0\n        results.append(is_troubled)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3400893"}, {"introduction": "理想的限制器应仅作用于真实的激波，但在实践中，它们可能会被陡峭但完全光滑的解特征错误地激活，从而不必要地降低了精度。本练习深入探讨了这一关键问题，要求您数值化地研究并量化一个矩衰减探测器的“误激活率”。通过将您的计算结果与所提供的渐近模型进行比较，您将对这些探测器的行为及其设计和校准中涉及的权衡有更深入的了解。[@problem_id:3400892]", "problem": "考虑在区间 $[-1,1]$ 上的一维不连续 Galerkin (DG) 方法，使用单元宽度为 $h$ 的均匀网格，其中 $N = 2/h$ 是一个整数。在每个单元上，使用参考域 $\\xi \\in [-1,1]$ 上的映射 Legendre 多项式基 $\\{L_k(\\xi)\\}_{k=0}^p$，其中仿射映射为 $x = x_c + \\frac{h}{2}\\xi$，$x_c$ 是单元中心。对于一个具有陡峭梯度的构造光滑函数 $u(x) = \\tanh(\\alpha x)$，将 $u$ 在次数为 $p$ 的局部多项式空间上的 $L^2$ 投影的模态（矩）系数 $a_k$ 定义为\n$$\na_k = \\frac{2k+1}{2}\\int_{-1}^1 u\\!\\left(x_c + \\frac{h}{2}\\xi\\right)L_k(\\xi)\\,d\\xi,\\quad k=0,1,\\dots,p.\n$$\n定义一个基于矩的衰减指示器，如果最高阶模态与其前一阶模态的比率超过一个阈值，则激活一个限制器：\n$$\n\\text{激活条件为}\\quad R_p = \\frac{|a_p|}{|a_{p-1}|}  \\Theta(p),\\quad \\Theta(p) = \\frac{\\eta}{p},\n$$\n其中 $\\eta  0$ 是一个给定的常数，且 $p \\ge 1$。对于光滑的构造解，任何激活根据定义都是伪激活。伪激活率定义为在 $[-1,1]$ 上指示器被激活的单元所占的比例。\n\n从 Legendre 多项式在 $[-1,1]$ 上构成正交基，以及对于足够光滑的 $u$，模态系数 $a_k$ 受 $u$ 的局部导数和依赖于 $h$ 的标度控制这些基本事实出发，推导一个关于局部导数比率和网格尺寸引起的尺度分离的易于处理的激活准则渐近模型。使用对于解析函数 $u$，分层模态比的主阶行为满足\n$$\nR_p(x_c) \\approx C_p\\,h\\,\\frac{|u^{(p)}(x_c)|}{|u^{(p-1)}(x_c)|},\n$$\n对于某个有界的 $C_p = \\mathcal{O}(1)$，它在 $p$ 固定时独立于 $h$ 和 $\\alpha$。对于 $u(x) = \\tanh(\\alpha x)$，利用 $|u'(x)| = \\alpha\\,\\operatorname{sech}^2(\\alpha x)$ 以及更高阶导数的比率被一个与 $\\alpha\\,\\operatorname{sech}^2(\\alpha x)$ 成比例的因子（在 $\\mathcal{O}(1)$ 乘法常数范围内）所界定的事实。利用此结构，证明激活的一个充分条件具有以下形式\n$$\n\\alpha h\\,p\\,\\operatorname{sech}^2(\\alpha x_c) \\gtrsim \\eta,\n$$\n并推导出伪激活概率（被激活单元的比例）作为 $t = \\alpha h p$ 的函数的渐近标度：\n$$\n\\Phi(t,\\alpha) \\approx \n\\begin{cases}\n0,  t \\le \\eta,\\\\[4pt]\n\\min\\!\\left(1,\\,\\dfrac{1}{\\alpha}\\,\\operatorname{arcosh}\\!\\sqrt{\\dfrac{t}{\\eta}}\\right),  t  \\eta,\n\\end{cases}\n$$\n其中 $\\operatorname{arcosh}$ 表示反双曲余弦函数，域长度为 $2$。该标度是通过测量满足指示器不等式的单元中心 $x_c$ 的集合得出的，其中 $\\operatorname{sech}^2(\\alpha x_c)$ 用于模拟局部陡峭度。\n\n你的任务是实现一个完整的程序，该程序：\n- 对每个测试用例 $(p,h,\\alpha)$，通过以下方式计算经验伪激活率：\n  - 在 $[-1,1]$ 上构建宽度为 $h$ 的单元的均匀网格。\n  - 通过对于给定的 $p$ 具有足够精度的 Gaussian 求积计算局部模态系数 $\\{a_k\\}_{k=0}^p$。\n  - 在每个单元上应用激活规则 $R_p  \\eta/p$ 来计数激活次数。\n  - 报告被激活单元的比例。\n- 对每个测试用例，使用上述公式和相同的 $\\eta$ 计算渐近预测值 $\\Phi(t,\\alpha)$。\n- 将所有测试用例的经验值和预测值聚合成对，并置于单行输出中。\n\n使用 $\\eta = 0.5$。每个单元使用至少 $2p+5$ 个点的 Gaussian 求积来近似积分。此问题不涉及角度。没有物理单位；所有量均为无量纲。所有浮点数答案请四舍五入到六位小数。\n\n测试套件：\n- 情况 A：$(p,h,\\alpha) = (2, 0.05, 1)$。\n- 情况 B：$(p,h,\\alpha) = (2, 0.5, 1)$。\n- 情况 C：$(p,h,\\alpha) = (4, 0.2, 5)$。\n- 情况 D：$(p,h,\\alpha) = (6, 0.5, 10)$。\n- 情况 E：$(p,h,\\alpha) = (8, 0.2, 3)$。\n\n你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果表示为一对 $[\\text{经验值},\\text{预测值}]$，例如 $[[e_1,p_1],[e_2,p_2],\\dots]$，其中每个 $e_i$ 和 $p_i$ 是一个四舍五入到六位小数的浮点数。", "solution": "此问题的目标是分析用于不连续 Galerkin (DG) 方法的基于矩的限制器，特别是其在光滑解上产生伪激活的倾向。我们将计算一个构造解的经验伪激活率，并将其与推导出的渐近预测进行比较。该过程涉及两个主要部分：基于 DG 表示的数值计算和理论公式的评估。\n\n首先，我们处理对于给定的多项式次数 $p$、单元宽度 $h$ 和解参数 $\\alpha$ 的经验伪激活率的计算。域是区间 $[-1, 1]$，它被离散化为 $N = 2/h$ 个单元的均匀网格。单元中心表示为 $x_c$。\n\n在每个单元上，我们分析光滑函数 $u(x) = \\tanh(\\alpha x)$ 的局部表示。该函数被投影到参考单元 $\\xi \\in [-1, 1]$ 上的 Legendre 多项式基 $\\{L_k(\\xi)\\}_{k=0}^p$ 上。物理坐标 $x$ 通过仿射映射 $x = x_c + \\frac{h}{2}\\xi$ 与参考坐标 $\\xi$ 相关联。此投影的模态系数 $a_k$ 由 $L^2$ 内积定义：\n$$\na_k = \\frac{\\int_{-1}^1 u\\!\\left(x_c + \\frac{h}{2}\\xi\\right)L_k(\\xi)\\,d\\xi}{\\int_{-1}^1 (L_k(\\xi))^2\\,d\\xi} = \\frac{2k+1}{2}\\int_{-1}^1 u\\!\\left(x_c + \\frac{h}{2}\\xi\\right)L_k(\\xi)\\,d\\xi.\n$$\n该积分通常无法解析处理，必须进行数值计算。我们采用 Gaussian-Legendre 求积，对于次数最高为 $2N_q - 1$ 的多项式，使用 $N_q$ 个求积点是精确的。问题指定使用 $N_q \\ge 2p+5$ 个点，确保被积函数（其涉及一个次数为 $p$ 的多项式和光滑函数 $u$）的高精度。对于一个通用函数 $f(\\xi)$，求积近似为 $\\int_{-1}^1 f(\\xi)\\,d\\xi \\approx \\sum_{j=1}^{N_q} w_j f(\\xi_j)$，其中 $\\xi_j$ 是求积点（$L_{N_q}(\\xi)$ 的根），$w_j$ 是对应的权重。因此，模态系数计算如下：\n$$\na_k \\approx \\frac{2k+1}{2} \\sum_{j=1}^{N_q} w_j \\tanh\\left(\\alpha \\left(x_c + \\frac{h}{2}\\xi_j\\right)\\right)L_k(\\xi_j).\n$$\n我们需要为 $p \\ge 1$ 计算系数 $a_{p-1}$ 和 $a_p$。如果模态系数的衰减率不够快，基于矩的限制器就会被激活。指示器由比率 $R_p = |a_p|/|a_{p-1}|$ 给出。如果此比率超过与次数相关的阈值 $\\Theta(p) = \\eta/p$（其中 $\\eta = 0.5$ 是一个常数），则发生激活。激活条件是：\n$$\nR_p = \\frac{|a_p|}{|a_{p-1}|}  \\frac{\\eta}{p}.\n$$\n对于网格中的每个单元，我们计算 $a_{p-1}$ 和 $a_p$，评估此条件，并统计满足该条件的单元数量。经验伪激活率是被激活单元的总数除以总单元数 $N$。\n\n其次，我们计算此激活率的渐近预测。问题提供了一个基于光滑函数模态系数渐近分析的理论模型。该模型的核心是模态系数比率与函数在单元中心的导数比率之间的关系：\n$$\nR_p(x_c) \\approx C_p\\,h\\,\\frac{|u^{(p)}(x_c)|}{|u^{(p-1)}(x_c)|},\n$$\n其中 $C_p = \\mathcal{O}(1)$ 是一个依赖于基的常数。对于 $u(x)=\\tanh(\\alpha x)$，其导数在空间上受到包含 $\\operatorname{sech}^2(\\alpha x)$ 的因子的调制。这导致了一个简化的激活条件：\n$$\n\\alpha h p \\operatorname{sech}^2(\\alpha x_c) \\gtrsim \\eta.\n$$\n令 $t = \\alpha h p$，该不等式变为 $\\operatorname{sech}^2(\\alpha x_c) \\gtrsim \\eta/t$。为了使这个关于 $x_c$ 的不等式有解，必须有 $\\eta/t  1$，即 $t  \\eta$。如果 $t \\le \\eta$，则预测不会发生激活。如果 $t  \\eta$，求解 $x_c$ 可得出激活区域：\n$$\n|x_c|  \\frac{1}{\\alpha}\\operatorname{arcosh}\\left(\\sqrt{\\frac{t}{\\eta}}\\right).\n$$\n预测的伪激活率 $\\Phi(t, \\alpha)$ 是该激活区域覆盖域 $[-1, 1]$ 的比例。激活区域的长度是 $2 \\cdot \\frac{1}{\\alpha}\\operatorname{arcosh}(\\sqrt{t/\\eta})$，总域长度是 $2$。预测率是这两个长度的比率，上限为 $1$，因为激活区域不能超出域的范围。这就得出了以下公式：\n$$\n\\Phi(t,\\alpha) = \n\\begin{cases}\n0,  t \\le \\eta, \\\\\n\\min\\!\\left(1,\\,\\dfrac{1}{\\alpha}\\,\\operatorname{arcosh}\\!\\sqrt{\\dfrac{t}{\\eta}}\\right),  t  \\eta.\n\\end{cases}\n$$\n我们的程序将为每个指定的测试用例 $(p, h, \\alpha)$ 实现经验计算和此预测公式，并报告这对结果。", "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre\n\ndef solve():\n    \"\"\"\n    Computes and prints the empirical and predicted false activation rates\n    for a moment-based limiter in a Discontinuous Galerkin method.\n    \"\"\"\n    \n    # Test suite from the problem statement\n    test_cases = [\n        # (p, h, alpha)\n        (2, 0.05, 1),\n        (2, 0.5, 1),\n        (4, 0.2, 5),\n        (6, 0.5, 10),\n        (8, 0.2, 3),\n    ]\n\n    # Constant from the problem statement\n    eta = 0.5\n\n    results = []\n\n    for p, h, alpha in test_cases:\n        # --- 1. Empirical False Activation Rate ---\n        \n        #\n        # Setup mesh\n        #\n        # Number of cells\n        N = int(2 / h)\n        # Cell centers\n        x_c = np.linspace(-1 + h / 2, 1 - h / 2, N)\n\n        #\n        # Setup for quadrature and basis functions\n        #\n        # Number of quadrature points\n        nq = 2 * p + 5\n        # Quadrature points (xi) and weights (w) on [-1, 1]\n        xi_q, w_q = np.polynomial.legendre.leggauss(nq)\n\n        # Evaluate Legendre polynomials at quadrature points\n        Lp_vals = eval_legendre(p, xi_q)\n        Lp_minus_1_vals = eval_legendre(p - 1, xi_q)\n        \n        activated_cells = 0\n        for i in range(N):\n            # Map quadrature points to the current cell\n            x_q = x_c[i] + (h / 2) * xi_q\n            \n            # Function values at quadrature points\n            u_vals = np.tanh(alpha * x_q)\n\n            # Compute integrands for a_p and a_{p-1}\n            integrand_p = u_vals * Lp_vals\n            integrand_p_minus_1 = u_vals * Lp_minus_1_vals\n\n            # Approximate integrals using quadrature\n            integral_p = np.sum(w_q * integrand_p)\n            integral_p_minus_1 = np.sum(w_q * integrand_p_minus_1)\n            \n            # Compute modal coefficients\n            a_p = (2 * p + 1) / 2 * integral_p\n            a_p_minus_1 = (2 * (p - 1) + 1) / 2 * integral_p_minus_1\n\n            # Check for activation\n            # Denominator safety check: if a_{p-1} is effectively zero,\n            # the ratio is considered infinite and the limiter activates.\n            if abs(a_p_minus_1)  1e-16:\n                 # Only activate if numerator is non-zero, otherwise 0/0 is indeterminate\n                 if abs(a_p)  1e-16:\n                     activated_cells += 1\n            else:\n                ratio = abs(a_p) / abs(a_p_minus_1)\n                threshold = eta / p\n                if ratio  threshold:\n                    activated_cells += 1\n        \n        empirical_rate = activated_cells / N\n\n        # --- 2. Asymptotic Prediction ---\n        \n        t = alpha * h * p\n        \n        if t = eta:\n            predicted_rate = 0.0\n        else:\n            # np.arccosh is the inverse hyperbolic cosine\n            value = (1 / alpha) * np.arccosh(np.sqrt(t / eta))\n            predicted_rate = min(1.0, value)\n\n        results.append([empirical_rate, predicted_rate])\n\n    # Format output as specified\n    output_str = \"[\" + \",\".join([f\"[{e:.6f},{p:.6f}]\" for e, p in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3400892"}]}