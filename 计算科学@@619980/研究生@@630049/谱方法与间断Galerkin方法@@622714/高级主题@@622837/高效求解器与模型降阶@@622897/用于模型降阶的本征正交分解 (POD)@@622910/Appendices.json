{"hands_on_practices": [{"introduction": "本征正交分解（POD）的核心在于从高维数据中提取最优的低维基。快照法（method of snapshots）是实现这一目标的高效计算工具，尤其适用于状态空间维度 $N$ 远大于快照数量 $m$ 的情况。本练习将指导您从第一性原理出发，推导并实现带有加权内积的快照法，这对于处理源自有限元或间断伽辽金等数值方法的离散系统至关重要，因为其中的能量范数通常由质量矩阵 $M$ 定义。", "problem": "给定一个快照矩阵 $X\\in\\mathbb{R}^{N\\times m}$（其中 $m\\ll N$）和一个对称正定矩阵 $M\\in\\mathbb{R}^{N\\times N}$，该矩阵导出加权内积 $\\langle u,v\\rangle_M = u^\\top M v$ 和范数 $\\|u\\|_M = \\sqrt{u^\\top M u}$。在本征正交分解 (Proper Orthogonal Decomposition, POD) 问题中，需要寻找一个 $M$-正交标准基，以最大化快照的均方投影，其中 $M$ 例如代表由谱方法或间断伽辽金离散化产生的质量矩阵。快照法通过快照空间中的一个特征值问题来构造 POD 模态。\n\n从 POD 子空间的定义出发，即其解是正交标准基向量所捕获的平均 $M$-能量的约束最大化问题，请基于基本线性代数原理，推导一个使用快照法计算 $M$-正交标准 POD 模态的显式算法。您的推导必须从 $M$-内积下的最优性变分刻画开始，并将问题简化为在 $m$ 维快照空间中提出的特征值问题。该算法必须能基于一个有原则的容差自动确定数值秩，并且在 $X$ 秩亏时必须是鲁棒的。\n\n然后将您的算法实现为一个程序，该程序：\n- 给定几个测试用例 $(M,X)$，计算 POD 模态并验证其 $M$-正交标准性。具体来说，如果 $\\Phi\\in\\mathbb{R}^{N\\times r}$ 表示计算出的 POD 基（其中 $r$ 等于确定的数值秩），请验证 $\\Phi^\\top M \\Phi$ 在一致的数值容差范围内是大小为 $r$ 的单位矩阵。\n- 对于每个测试用例，返回一个布尔值，该值指示 $M$-正交标准性检查是否通过，以及返回的模态数量是否等于从快照空间特征值问题中由您的容差确定的数值秩。\n\n此问题不涉及物理单位或角度。所有输出均为无量纲。您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 [True, False, ...]。\n\n使用以下测试套件。对于下述所有情况，$N$ 和 $m$ 从维度中可知。\n\n测试用例一（理想情况）：\n- $M_1 = I_6$，即大小为 6 的单位矩阵。\n- $X_1 = \\begin{bmatrix}\n1 & 2 & 3\\\\\n0 & 1 & 0\\\\\n1 & 0 & 1\\\\\n2 & 1 & 0\\\\\n0 & 1 & 2\\\\\n1 & 0 & 0\n\\end{bmatrix}$。\n\n测试用例二（非平凡对角阵 $M$）：\n- $M_2 = \\mathrm{diag}(2,\\,0.5,\\,3,\\,1.5,\\,4,\\,1)$。\n- $X_2 = \\begin{bmatrix}\n0.5 & 1.0 & -1.0\\\\\n2.0 & -1.0 & 0.0\\\\\n1.5 & 0.0 & 2.0\\\\\n0.0 & 1.0 & 1.0\\\\\n-1.0 & 0.5 & 0.0\\\\\n1.0 & -0.5 & 2.0\n\\end{bmatrix}$。\n\n测试用例三（秩亏快照，以及由给定 $A$ 构造的对称正定矩阵 $M$）：\n- 定义 $A_3 = \\begin{bmatrix}\n1 & 0 & 2 & 0 & 1 & 0\\\\\n0 & 1 & 0 & 2 & 0 & 1\\\\\n1 & 1 & 0 & 0 & 1 & 0\\\\\n0 & 0 & 1 & 1 & 0 & 1\\\\\n1 & 0 & 0 & 1 & 1 & 0\\\\\n0 & 1 & 1 & 0 & 0 & 1\n\\end{bmatrix}$ 并设置 $M_3 = A_3^\\top A_3 + 0.1\\,I_6$。\n- 令 $c_1 = \\begin{bmatrix}1\\\\0\\\\1\\\\0\\\\1\\\\0\\end{bmatrix}$ 和 $c_2 = \\begin{bmatrix}0\\\\1\\\\0\\\\1\\\\0\\\\1\\end{bmatrix}$，并构造 $X_3 = \\begin{bmatrix} c_1 & c_2 & (c_1+c_2) & (2\\,c_2)\\end{bmatrix}$。\n\n测试用例四（单个快照）：\n- $M_4 = \\mathrm{diag}(1,\\,2,\\,3,\\,4,\\,5)$。\n- $X_4 = \\begin{bmatrix}1\\\\-1\\\\2\\\\0\\\\3\\end{bmatrix}$。\n\n测试用例五（病态对角阵 $M$）：\n- $M_5 = \\mathrm{diag}(10^{-6},\\,10^{-3},\\,1,\\,10^{3},\\,10^{6},\\,2)$。\n- $X_5 = \\begin{bmatrix}\n1.0 & 0.0 & 0.5\\\\\n0.0 & 1.0 & -0.5\\\\\n0.5 & -0.5 & 1.0\\\\\n1.0 & 0.0 & -1.0\\\\\n0.0 & 1.0 & 0.0\\\\\n1.0 & -1.0 & 0.0\n\\end{bmatrix}$。\n\n算法和验证要求：\n- 在 $M$-内积下从第一性原理推导快照法，将构造过程简化为快照空间中的一个特征值问题，并通过回代形成模态。\n- 通过相对于快照空间相关矩阵的最大特征值和机器精度对特征值进行阈值处理，实现数值稳定的数值秩选择。如果高于阈值的特征值数量为 $r$，则精确返回 $r$ 个模态。\n- 通过检查 $\\Phi^\\top M \\Phi - I_r$ 的弗罗贝尼乌斯范数是否低于一个随问题规模和机器精度适当缩放的容差来验证 $M$-正交标准性。\n- 对于每个测试用例，当且仅当正交标准性验证通过且返回的模态数量等于确定的数值秩时，输出布尔值 ${\\rm True}$，否则输出 ${\\rm False}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 [True, False, True, True, True]。", "solution": "计算本征正交分解 (POD) 模态的问题本质上是一个优化问题。给定由矩阵 $X \\in \\mathbb{R}^{N \\times m}$ 的列表示的一组快照，以及一个定义了加权内积 $\\langle u, v \\rangle_M = u^\\top M v$ 的对称正定 (SPD) 矩阵 $M \\in \\mathbb{R}^{N \\times N}$，我们寻求一个 $M$-正交标准基 $\\{\\phi_k\\}_{k=1}^r$ 来最优地捕获快照的“能量”。当快照数量 $m$ 远小于状态维数 $N$ (即 $m \\ll N$) 时，“快照法”是解决此问题的一种高效算法。\n\n我们从其变分基础开始推导该算法。第一个 POD 模态 $\\phi_1$ 是在 $M$-范数下归一化的约束下，最大化快照均方投影的向量。这表示为以下优化问题：\n$$\n\\max_{\\phi \\in \\mathbb{R}^N} \\frac{1}{m} \\sum_{j=1}^{m} |\\langle x_j, \\phi \\rangle_M|^2 \\quad \\text{subject to} \\quad \\|\\phi\\|_M^2 = 1\n$$\n其中 $x_j$ 是快照矩阵 $X$ 的第 $j$ 列。\n\n目标函数可以用矩阵表示法重写。内积的平方为 $|\\langle x_j, \\phi \\rangle_M|^2 = (\\phi^\\top M x_j)(x_j^\\top M \\phi)$。对所有快照求和得到：\n$$\n\\frac{1}{m} \\sum_{j=1}^{m} \\phi^\\top M x_j x_j^\\top M \\phi = \\phi^\\top M \\left( \\frac{1}{m} \\sum_{j=1}^{m} x_j x_j^\\top \\right) M \\phi = \\phi^\\top M \\left( \\frac{1}{m} X X^\\top \\right) M \\phi\n$$\n令 $C_X = \\frac{1}{m} X X^\\top$ 为空间相关矩阵。约束条件为 $\\|\\phi\\|_M^2 = \\phi^\\top M \\phi = 1$。$\\phi_1$ 的优化问题是：\n$$\n\\max_{\\phi \\in \\mathbb{R}^N} \\phi^\\top M C_X M \\phi \\quad \\text{subject to} \\quad \\phi^\\top M \\phi = 1\n$$\n这是一个标准的瑞利商问题。使用拉格朗日乘子法，我们定义拉格朗日函数 $\\mathcal{L}(\\phi, \\sigma) = \\phi^\\top M C_X M \\phi - \\sigma (\\phi^\\top M \\phi - 1)$。对 $\\phi^\\top$ 求梯度并令其为零，得到广义特征值问题：\n$$\nM C_X M \\phi = \\sigma M \\phi\n$$\n由于 $M$ 是可逆的，这等价于 $C_X M \\phi = \\sigma \\phi$。这是一个 $N \\times N$ 的特征值问题，如果 $N$ 很大，直接求解在计算上是不可行的。\n\n快照法通过利用任何 POD 模态 $\\phi$ 都必须位于快照的张成空间内这一事实，提供了一种高效的替代方法。要理解这一点，请注意从特征值方程中，$\\phi = \\frac{1}{\\sigma} C_X M \\phi = \\frac{1}{\\sigma m} (XX^\\top) M \\phi$。这可以写成 $\\phi = \\sum_{j=1}^m \\alpha_j x_j$，其中系数为 $\\alpha_j = \\frac{1}{\\sigma m} x_j^\\top M \\phi$。这表明 $\\phi \\in \\text{span}\\{x_1, \\dots, x_m\\}$。\n\n因此，我们可以在快照的线性组合中寻找 POD 模态：\n$$\n\\phi = X a = \\sum_{j=1}^{m} a_j x_j\n$$\n对于某个系数向量 $a \\in \\mathbb{R}^m$。将此拟设代入原始变分问题，目标函数变为：\n$$\n\\phi^\\top M C_X M \\phi = (Xa)^\\top M \\left(\\frac{1}{m}XX^\\top\\right) M (Xa) = \\frac{1}{m} a^\\top (X^\\top M X) (X^\\top M X) a\n$$\n我们定义快照格拉姆矩阵 $K_m = X^\\top M X \\in \\mathbb{R}^{m \\times m}$。该矩阵是对称半正定的。目标函数简化为 $\\frac{1}{m} a^\\top K_m^2 a$。约束条件 $\\phi^\\top M \\phi = 1$ 变为：\n$$\n(Xa)^\\top M (Xa) = a^\\top (X^\\top M X) a = a^\\top K_m a = 1\n$$\n问题被简化为系数向量 $a$ 的一个 $m$ 维优化问题：\n$$\n\\max_{a \\in \\mathbb{R}^m} \\frac{1}{m} a^\\top K_m^2 a \\quad \\text{subject to} \\quad a^\\top K_m a = 1\n$$\n我们再次构造拉格朗日函数 $\\mathcal{L}(a, \\lambda) = \\frac{1}{m} a^\\top K_m^2 a - \\lambda(a^\\top K_m a - 1)$。平稳性条件是 $\\frac{1}{m} K_m^2 a - \\lambda K_m a = 0$。由于我们寻找的是非平凡模态，我们对 $K_m$ 的零空间（其中 $K_m a = 0$）不感兴趣。对于零空间之外的 $a$，我们可以简化为：\n$$\nK_m a = m \\lambda a\n$$\n这是一个标准的 $m \\times m$ 特征值问题。令 $(\\lambda_k, a_k)$（$k=1, \\dots, r$）为 $K_m$ 的特征对，其中 $r \\le m$ 是 $K_m$ 的秩。特征值 $\\lambda_k$ 是模态的 $M$-加权能量，特征向量 $a_k$ 提供了构造 POD 模态的系数。由于 $K_m$ 是对称的，其特征向量可以选择为正交标准的，即 $a_k^\\top a_j = \\delta_{kj}$。\n\nPOD 模态 $\\phi_k$ 由特征向量 $a_k$ 构造。首先，我们形成“预模态” $\\tilde{\\phi}_k = X a_k$。它们的 $M$-内积为：\n$$\n\\langle \\tilde{\\phi}_k, \\tilde{\\phi}_j \\rangle_M = (Xa_k)^\\top M (Xa_j) = a_k^\\top (X^\\top M X) a_j = a_k^\\top K_m a_j = a_k^\\top (\\lambda_j a_j) = \\lambda_j (a_k^\\top a_j) = \\lambda_j \\delta_{kj}\n$$\n这表明预模态是 $M$-正交的。一个预模态的 $M$-范数是 $\\|\\tilde{\\phi}_k\\|_M = \\sqrt{\\lambda_k}$。为了获得一个 $M$-正交标准基，我们对每个预模态进行归一化：\n$$\n\\phi_k = \\frac{\\tilde{\\phi}_k}{\\|\\tilde{\\phi}_k\\|_M} = \\frac{X a_k}{\\sqrt{\\lambda_k}}\n$$\n这对于所有严格为正的特征值 $\\lambda_k > 0$ 都是有效的。\n\n完整的算法如下：\n1.  **构造快照格拉姆矩阵**：计算 $K_m = X^\\top M X$，一个 $m \\times m$ 矩阵。\n2.  **求解特征问题**：求解对称特征值问题 $K_m a_k = \\lambda_k a_k$，得到特征值 $\\lambda_k$ 和正交标准特征向量 $a_k$。\n3.  **确定秩**：将特征值按降序排序：$\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_m \\ge 0$。数值秩 $r$ 是通过保留相对于最大特征值显著的特征值来确定的。一个有原则的容差是 $\\tau = \\lambda_1 \\cdot m \\cdot \\epsilon_{\\text{mach}}$，其中 $\\epsilon_{\\text{mach}}$ 是机器ε。秩 $r$ 是特征值 $\\lambda_k > \\tau$ 的数量。\n4.  **构造模态**：对于 $r$ 个选定的特征对 $(\\lambda_k, a_k)$，构造 POD 模态 $\\phi_k = \\frac{1}{\\sqrt{\\lambda_k}} X a_k$。最终的基是 $\\Phi = [\\phi_1, \\dots, \\phi_r] \\in \\mathbb{R}^{N \\times r}$。\n5.  **验证**：通过检查矩阵 $\\Phi^\\top M \\Phi$ 是否接近单位矩阵 $I_r$ 来确认计算出的基 $\\Phi$ 确实是 $M$-正交标准的。偏差由弗罗贝尼乌斯范数 $\\|\\Phi^\\top M \\Phi - I_r\\|_F$ 衡量，该值应低于一个验证容差。一个鲁棒的容差必须考虑问题的数值条件，这与被反演的有效矩阵的条件数有关，即 $\\kappa(K_m) = \\lambda_1 / \\lambda_r$。\n\n这个推导及由此产生的算法，为使用快照法计算 $M$-正交标准 POD 模态提供了一个完整、鲁棒的流程，包括有原则的秩确定和验证。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the POD algorithm on them.\n    \"\"\"\n\n    def compute_pod_modes(M: np.ndarray, X: np.ndarray) -> bool:\n        \"\"\"\n        Computes M-orthonormal POD modes using the method of snapshots and verifies the result.\n        \n        Args:\n            M: The symmetric positive definite mass matrix (N x N).\n            X: The snapshot matrix (N x m).\n        \n        Returns:\n            A boolean that is True if the M-orthonormality check passes and the\n            number of returned modes equals the determined numerical rank.\n        \"\"\"\n        N, m = X.shape\n\n        if m == 0:\n            # Vacuously true: numerical rank is 0, 0 modes are returned,\n            # and orthonormality of an empty set is trivial.\n            return True\n\n        # Step 1: Form the snapshot-space Gram matrix Km = X^T * M * X\n        Km = X.T @ M @ X\n\n        # Step 2: Solve the eigenvalue problem for the symmetric matrix Km\n        try:\n            # eigh returns eigenvalues in ascending order and orthonormal eigenvectors\n            eigenvalues, eigenvectors = eigh(Km)\n        except np.linalg.LinAlgError:\n            # This can occur if Km contains non-finite values, indicating an invalid setup.\n            return False\n\n        # Sort eigenvalues and corresponding eigenvectors in descending order\n        sorted_indices = np.argsort(eigenvalues)[::-1]\n        lambdas = eigenvalues[sorted_indices]\n        A = eigenvectors[:, sorted_indices]\n\n        # Step 3: Determine the numerical rank r based on a principled tolerance\n        lambda_max = lambdas[0] if m > 0 and len(lambdas) > 0 else 0.0\n        \n        if lambda_max == 0:\n            # This happens if all snapshots are in the null space of M or are zero vectors.\n            r = 0\n        else:\n            # Rank tolerance relative to the largest eigenvalue, machine precision, and problem size\n            rank_tol = lambda_max * m * np.finfo(float).eps\n            r = np.sum(lambdas > rank_tol)\n\n        if r == 0:\n            # No significant modes were found. The number of modes returned (0) matches rank (0).\n            return True\n\n        # Step 4: Select the top r eigenvalues and eigenvectors\n        top_lambdas = lambdas[:r]\n        top_A = A[:, :r]\n\n        # Step 5: Construct the POD modes\n        # phi_k = (1/sqrt(lambda_k)) * X @ a_k\n        # In matrix form: Phi = X @ A_r @ Lambda_r^(-1/2)\n        Phi = (X @ top_A) / np.sqrt(top_lambdas)\n\n        # Step 6: Verification\n        # 6a: The number of returned modes must match the determined rank.\n        num_modes_ok = (Phi.shape[1] == r)\n\n        # 6b: The computed basis Phi must be M-orthonormal.\n        # We check if Phi^T @ M @ Phi is close to the identity matrix.\n        check_matrix = Phi.T @ M @ Phi\n        Id_r = np.eye(r)\n        frob_norm_diff = np.linalg.norm(check_matrix - Id_r, 'fro')\n\n        # A principled verification tolerance that adapts to the problem's conditioning.\n        # The condition number of the snapshot Gram matrix subproblem.\n        lambda_min_r = top_lambdas[-1]\n        cond_Km_r = lambda_max / lambda_min_r if lambda_min_r > 0 else np.inf\n\n        # The tolerance scales with problem size, machine epsilon, and conditioning.\n        # We also set a minimum tolerance floor for well-conditioned problems.\n        verify_tol = max(1e-9, np.sqrt(r) * cond_Km_r * m * np.finfo(float).eps)\n        \n        orthonormality_ok = (frob_norm_diff < verify_tol)\n\n        return orthonormality_ok and num_modes_ok\n\n    # Define test cases\n    # Test case one\n    M1 = np.eye(6)\n    X1 = np.array([\n        [1, 2, 3], [0, 1, 0], [1, 0, 1],\n        [2, 1, 0], [0, 1, 2], [1, 0, 0]\n    ], dtype=float)\n\n    # Test case two\n    M2 = np.diag([2.0, 0.5, 3.0, 1.5, 4.0, 1.0])\n    X2 = np.array([\n        [0.5, 1.0, -1.0], [2.0, -1.0, 0.0], [1.5, 0.0, 2.0],\n        [0.0, 1.0, 1.0], [-1.0, 0.5, 0.0], [1.0, -0.5, 2.0]\n    ], dtype=float)\n\n    # Test case three\n    A3 = np.array([\n        [1, 0, 2, 0, 1, 0], [0, 1, 0, 2, 0, 1], [1, 1, 0, 0, 1, 0],\n        [0, 0, 1, 1, 0, 1], [1, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 1]\n    ], dtype=float)\n    M3 = A3.T @ A3 + 0.1 * np.eye(6)\n    c1 = np.array([1, 0, 1, 0, 1, 0], dtype=float)\n    c2 = np.array([0, 1, 0, 1, 0, 1], dtype=float)\n    X3 = np.array([c1, c2, c1 + c2, 2 * c2]).T\n\n    # Test case four\n    M4 = np.diag([1.0, 2.0, 3.0, 4.0, 5.0])\n    X4 = np.array([[1], [-1], [2], [0], [3]], dtype=float)\n\n    # Test case five\n    M5 = np.diag([1e-6, 1e-3, 1.0, 1e3, 1e6, 2.0])\n    X5 = np.array([\n        [1.0, 0.0, 0.5], [0.0, 1.0, -0.5], [0.5, -0.5, 1.0],\n        [1.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, -1.0, 0.0]\n    ], dtype=float)\n\n    test_cases = [\n        (M1, X1),\n        (M2, X2),\n        (M3, X3),\n        (M4, X4),\n        (M5, X5),\n    ]\n\n    results = []\n    for M, X in test_cases:\n        result = compute_pod_modes(M, X)\n        results.append(str(result))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3410811"}, {"introduction": "将POD应用于偏微分方程（PDE）的降阶时，一个常见的挑战是如何处理非齐次边界条件。由于POD基函数通常需要满足齐次边界条件，因此必须对原问题进行转化。本练习将介绍一种标准技术——“提升法”（lifting），通过将解分解为满足非齐次边界条件的提升函数和满足齐次边界条件的齐次分量，从而使POD能够被有效应用。您将推导修正后的控制方程，并为一个具体的传热问题计算降阶模型中的力向量。", "problem": "考虑单位区间上带非齐次狄利克雷边界条件的一维热方程，\n$$\nu_t(x,t) = u_{xx}(x,t) + f(x,t), \\quad x \\in (0,1), \\; t>0,\n$$\n满足\n$$\nu(0,t) = g_0(t), \\qquad u(1,t) = g_1(t),\n$$\n以及与边界数据一致的给定初始条件 $u(x,0) = u_0(x)$。在谱伽辽金或间断伽辽金 (DG) 离散化中，将使用本征正交分解 (POD) 进行模型降阶。为了处理非齐次边界条件，引入形式为 $u = \\ell + \\tilde{u}$ 的提升，其中提升 $\\ell$ 强制施加边界值，而齐次分量 $\\tilde{u}$ 满足齐次狄利克雷边界条件。\n\n1) 从强形式和作为边界提升的 $\\ell$ 的定义出发，推导控制 $\\tilde{u}$ 的偏微分方程及其适用于到齐次狄利克雷检验函数上进行伽辽金投影的弱形式。清晰地表述力项是如何被提升所修正的，并指出来自 $\\ell_t$ 和 $\\ell_{xx}$ 的贡献。\n\n2) 设 $\\{\\varphi_i(x)\\}_{i=1}^r$ 是在强制施加齐次狄利克雷边界条件的降阶空间中计算出的 POD 模态。设 $L^2(0,1)$ 内积为伽辽金内积。推导由展开式 $\\tilde{u}(x,t) = \\sum_{i=1}^r a_i(t)\\,\\varphi_i(x)$ 定义的模态系数 $a_i(t)$ 的降阶模型。您的推导必须从弱形式开始，并得出一个形式为如下的常微分方程组\n$$\n\\mathbf{M}\\,\\dot{\\mathbf{a}}(t) + \\mathbf{S}\\,\\mathbf{a}(t) = \\mathbf{F}(t),\n$$\n根据所选的内积和因提升而修正的力项，确定降阶质量矩阵 $\\mathbf{M}$、刚度矩阵 $\\mathbf{S}$ 和降阶力向量 $\\mathbf{F}(t)$。\n\n3) 从第一性原理出发，阐明如何从一个通过数值通量强制施加非齐次边界条件的 DG 模拟所产生的 $u$ 的全阶快照中，计算齐次分量 $\\tilde{u}$ 的快照。具体说明如何为 POD 构建快照集和相关算子，以使模态满足齐次狄利克雷边界条件，且内积与离散 DG 质量矩阵一致。\n\n4) 现在，使用以下给定的数据进行具体计算。取边界数据和源项\n$$\ng_0(t) = \\sin(t), \\qquad g_1(t) = 0, \\qquad f(x,t) = x,\n$$\n并选择线性提升\n$$\n\\ell(x,t) = g_0(t)\\,(1-x) + g_1(t)\\,x.\n$$\n设降阶基由前两个 $L^2(0,1)$ 标准正交的正弦函数组成，\n$$\n\\varphi_1(x) = \\sqrt{2}\\,\\sin(\\pi x), \\qquad \\varphi_2(x) = \\sqrt{2}\\,\\sin(2\\pi x).\n$$\n使用您的一般降阶模型，计算降阶力的第一个分量 $F_1(t)$，然后在 $t = \\ln(2)$ 处求值。将您的最终答案表示为用初等函数表示的闭式解析表达式。不要近似；不需要四舍五入。所要求的最终答案是 $F_1(\\ln 2)$ 的值，以单个无单位的闭式表达式给出。", "solution": "该问题是有效的，因为它在科学上基于偏微分方程和数值方法的理论，是适定的、客观的，并且包含了完整解答所需的所有信息。\n\n该问题要求一个分为四部分的解答，涉及使用本征正交分解（POD）对带非齐次边界条件的一维热方程进行模型降阶。\n\n**1) 齐次分量的偏微分方程及其弱形式的推导**\n\n给定的偏微分方程（PDE）是热方程：\n$$\nu_t(x,t) = u_{xx}(x,t) + f(x,t), \\quad x \\in (0,1), \\; t>0\n$$\n带有非齐次狄利克雷边界条件：\n$$\nu(0,t) = g_0(t), \\qquad u(1,t) = g_1(t)\n$$\n我们引入一个提升分解 $u(x,t) = \\ell(x,t) + \\tilde{u}(x,t)$。函数 $\\ell(x,t)$ 是提升，旨在满足非齐次边界条件，即 $\\ell(0,t) = g_0(t)$ 和 $\\ell(1,t) = g_1(t)$。因此，新的未知函数 $\\tilde{u}(x,t)$ 必须满足齐次狄利克雷边界条件：\n$$\n\\tilde{u}(0,t) = u(0,t) - \\ell(0,t) = g_0(t) - g_0(t) = 0\n$$\n$$\n\\tilde{u}(1,t) = u(1,t) - \\ell(1,t) = g_1(t) - g_1(t) = 0\n$$\n为求得控制 $\\tilde{u}$ 的偏微分方程，我们将分解 $u = \\ell + \\tilde{u}$ 代入原始热方程。我们计算 $u$ 的偏导数：\n$$\nu_t = \\frac{\\partial}{\\partial t}(\\ell + \\tilde{u}) = \\ell_t + \\tilde{u}_t\n$$\n$$\nu_{xx} = \\frac{\\partial^2}{\\partial x^2}(\\ell + \\tilde{u}) = \\ell_{xx} + \\tilde{u}_{xx}\n$$\n将这些代入偏微分方程得到：\n$$\n\\ell_t + \\tilde{u}_t = (\\ell_{xx} + \\tilde{u}_{xx}) + f(x,t)\n$$\n整理各项以分离出关于 $\\tilde{u}$ 的方程，我们得到：\n$$\n\\tilde{u}_t - \\tilde{u}_{xx} = f(x,t) - \\ell_t(x,t) + \\ell_{xx}(x,t)\n$$\n这就是齐次分量 $\\tilde{u}$ 的偏微分方程的强形式。右侧的项是修正后的力项，其中 $-\\ell_t$ 和 $\\ell_{xx}$ 是来自提升函数的贡献。\n\n为了推导弱形式，我们将此偏微分方程乘以一个检验函数 $v(x)$，该函数属于适用于齐次狄利克雷边界条件的函数空间，通常为 $v \\in H_0^1(0,1)$，这意味着 $v$ 是平方可积的，其导数也是平方可积的，并且 $v(0)=v(1)=0$。然后我们在空间域 $[0,1]$ 上积分：\n$$\n\\int_0^1 (\\tilde{u}_t - \\tilde{u}_{xx}) v \\, dx = \\int_0^1 (f - \\ell_t + \\ell_{xx}) v \\, dx\n$$\n利用积分的线性性质，我们分离左边的项：\n$$\n\\int_0^1 \\tilde{u}_t v \\, dx - \\int_0^1 \\tilde{u}_{xx} v \\, dx = \\int_0^1 (f - \\ell_t + \\ell_{xx}) v \\, dx\n$$\n我们对左边的第二项应用分部积分：\n$$\n- \\int_0^1 \\tilde{u}_{xx} v \\, dx = - \\left[ \\tilde{u}_x v \\right]_0^1 + \\int_0^1 \\tilde{u}_x v_x \\, dx\n$$\n由于检验函数 $v$ 满足齐次狄利克雷边界条件，即 $v(0)=v(1)=0$，边界项 $\\left[ \\tilde{u}_x v \\right]_0^1$ 为零。因此弱形式是：求 $\\tilde{u}(\\cdot, t) \\in H_0^1(0,1)$，使得对于所有 $v \\in H_0^1(0,1)$：\n$$\n\\int_0^1 \\tilde{u}_t v \\, dx + \\int_0^1 \\tilde{u}_x v_x \\, dx = \\int_0^1 (f - \\ell_t + \\ell_{xx}) v \\, dx\n$$\n\n**2) 降阶模型 (ROM) 的推导**\n\n降阶模型是通过将弱形式伽辽金投影到由 POD 模态 $\\{\\varphi_i(x)\\}_{i=1}^r$ 张成的低维子空间上得到的。这些模态满足齐次狄利克雷边界条件，因此它们构成了 $\\tilde{u}$ 所在空间的有效基。我们寻求如下形式的近似解：\n$$\n\\tilde{u}(x,t) \\approx \\sum_{j=1}^r a_j(t)\\,\\varphi_j(x)\n$$\n其中 $a_j(t)$ 是随时间变化的模态系数。我们将此展开式代入第一部分推导出的弱形式中。对于伽辽金方法，我们选择基函数本身作为检验函数，即对于 $i=1, \\dots, r$，$v(x) = \\varphi_i(x)$。\n\n将展开式和 $v=\\varphi_i$ 代入弱形式，对每个 $i \\in \\{1, \\dots, r\\}$ 得到：\n$$\n\\int_0^1 \\frac{\\partial}{\\partial t}\\left(\\sum_{j=1}^r a_j(t)\\varphi_j(x)\\right) \\varphi_i(x) \\, dx + \\int_0^1 \\frac{\\partial}{\\partial x}\\left(\\sum_{j=1}^r a_j(t)\\varphi_j(x)\\right) \\frac{d\\varphi_i}{dx}(x) \\, dx = \\int_0^1 (f - \\ell_t + \\ell_{xx}) \\varphi_i(x) \\, dx\n$$\n利用微分和积分的线性性质，我们得到：\n$$\n\\sum_{j=1}^r \\dot{a}_j(t) \\int_0^1 \\varphi_j(x) \\varphi_i(x) \\, dx + \\sum_{j=1}^r a_j(t) \\int_0^1 \\frac{d\\varphi_j}{dx}(x) \\frac{d\\varphi_i}{dx}(x) \\, dx = \\int_0^1 (f - \\ell_t + \\ell_{xx}) \\varphi_i(x) \\, dx\n$$\n我们定义 $L^2(0,1)$ 内积为 $(w,z) = \\int_0^1 w(x)z(x) \\, dx$。该方程组可以写为：\n$$\n\\sum_{j=1}^r (\\varphi_j, \\varphi_i) \\dot{a}_j(t) + \\sum_{j=1}^r (\\varphi_j', \\varphi_i') a_j(t) = (f - \\ell_t + \\ell_{xx}, \\varphi_i)\n$$\n这是一个关于系数 $\\mathbf{a}(t) = [a_1(t), \\dots, a_r(t)]^T$ 的 $r$ 个常微分方程组 (ODE)。我们可以将该系统写成矩阵形式 $\\mathbf{M}\\,\\dot{\\mathbf{a}}(t) + \\mathbf{S}\\,\\mathbf{a}(t) = \\mathbf{F}(t)$，其中矩阵和向量的项为：\n-   **降阶质量矩阵 $\\mathbf{M}$**：$M_{ij} = (\\varphi_j, \\varphi_i)$。注意，索引经常被交换，但由于内积是对称的，$M_{ij}=M_{ji}$。\n-   **降阶刚度矩阵 $\\mathbf{S}$**：$S_{ij} = (\\varphi_j', \\varphi_i')$。\n-   **降阶力向量 $\\mathbf{F}(t)$**：$F_i(t) = (f - \\ell_t + \\ell_{xx}, \\varphi_i)$。\n\n如果 POD 基 $\\{\\varphi_i\\}$ 被选择为关于 $L^2$ 内积是标准正交的，那么 $(\\varphi_i, \\varphi_j) = \\delta_{ij}$ (克罗内克 delta)。在这种情况下，质量矩阵 $\\mathbf{M}$ 成为单位矩阵 $\\mathbf{I}$，从而将系统简化为 $\\dot{\\mathbf{a}}(t) + \\mathbf{S}\\,\\mathbf{a}(t) = \\mathbf{F}(t)$。\n\n**3) 从 DG 模拟中计算快照**\n\n在间断伽辽金 (DG) 模拟中，全阶解 $u_h(x,t)$ 在一组离散时间点 $\\{t_k\\}_{k=1}^{N_s}$ 上计算，从而产生一组快照 $\\{u_h(x, t_k)\\}$。非齐次边界条件 $u(0,t_k)=g_0(t_k)$ 和 $u(1,t_k)=g_1(t_k)$ 通常通过在区域边界处的数值通量来弱施加。\n\n要生成齐次分量 $\\tilde{u}$ 的快照，我们执行以下步骤：\n1.  对每个快照时间 $t_k$，在用于 DG 模拟的相同离散网格上构造相应的提升函数 $\\ell(x, t_k)$。这是一个已知的解析函数 $\\ell(x,t)$ 的简单求值。\n2.  从全阶 DG 解快照中减去提升函数，以获得齐次分量的快照：$\\tilde{u}_h(x, t_k) = u_h(x, t_k) - \\ell(x, t_k)$。根据构造，$\\tilde{u}_h(x, t_k)$ 将以与 $u_h$ 满足非齐次边界条件相同的弱方式满足齐次边界条件。集合 $\\{\\tilde{u}_h(x, t_k)\\}_{k=1}^{N_s}$ 构成了快照集。\n3.  为了构造 POD 模态，我们使用快照法。目标是找到一个基，该基在快照捕获的能量（在适当的范数下度量）方面是最优的。问题指定了一个与离散 DG 质量矩阵 $\\mathbf{M}_{DG}$ 一致的内积。设 $\\tilde{\\mathbf{u}}_k$ 是表示快照 $\\tilde{u}_h(x, t_k)$ 的自由度向量。两个快照 $\\tilde{u}_h(\\cdot, t_k)$ 和 $\\tilde{u}_h(\\cdot, t_l)$ 之间的离散内积由 $\\tilde{\\mathbf{u}}_k^T \\mathbf{M}_{DG} \\tilde{\\mathbf{u}}_l$ 给出。\n4.  快照相关矩阵（或格拉姆矩阵）$\\mathbf{C}$ 是一个 $N_s \\times N_s$ 矩阵，其元素是快照的内积：$C_{kl} = (\\tilde{u}_h(\\cdot, t_k), \\tilde{u}_h(\\cdot, t_l))_{\\mathrm{DG}} = \\tilde{\\mathbf{u}}_k^T \\mathbf{M}_{DG} \\tilde{\\mathbf{u}}_l$。\n5.  求解相关矩阵的特征值问题：$\\mathbf{C} \\mathbf{v}_i = \\lambda_i \\mathbf{v}_i$，其中 $\\lambda_i$ 是特征值，$\\mathbf{v}_i$ 是对应的特征向量。\n6.  第 $i$ 个 POD 模态 $\\varphi_i(x)$ 被构造为快照的线性组合，其系数由特征向量 $\\mathbf{v}_i$ 的分量给出：\n$$\n\\varphi_i(x) = \\frac{1}{\\sqrt{\\lambda_i}} \\sum_{k=1}^{N_s} (\\mathbf{v}_i)_k \\, \\tilde{u}_h(x, t_k)\n$$\n由于每个快照 $\\tilde{u}_h$ 都满足齐次边界条件，它们的任何线性组合，包括 POD 模态 $\\varphi_i$，也将满足这些条件。此外，此过程保证了所得到的模态 $\\{\\varphi_i\\}$ 在 DG 诱导的内积下是标准正交的：$(\\varphi_i, \\varphi_j)_{\\mathrm{DG}} = \\delta_{ij}$。\n\n**4) 降阶力分量的具体计算**\n\n我们被给予了具体的数据：\n-   边界数据：$g_0(t) = \\sin(t)$, $g_1(t) = 0$。\n-   源项：$f(x,t) = x$。\n-   提升函数：$\\ell(x,t) = g_0(t)\\,(1-x) + g_1(t)\\,x = \\sin(t)(1-x)$。\n-   降阶基函数：$\\varphi_1(x) = \\sqrt{2}\\,\\sin(\\pi x)$, $\\varphi_2(x) = \\sqrt{2}\\,\\sin(2\\pi x)$。\n\n我们需要计算降阶力向量的第一个分量 $F_1(t)$，并在 $t = \\ln(2)$ 处对其求值。\n根据第二部分，公式为 $F_1(t) = (f - \\ell_t + \\ell_{xx}, \\varphi_1)$。\n\n首先，我们计算提升函数 $\\ell(x,t)$ 的导数：\n$$\n\\ell_t(x,t) = \\frac{\\partial}{\\partial t} [\\sin(t)(1-x)] = (1-x)\\cos(t)\n$$\n$$\n\\ell_x(x,t) = \\frac{\\partial}{\\partial x} [\\sin(t)(1-x)] = -\\sin(t)\n$$\n$$\n\\ell_{xx}(x,t) = \\frac{\\partial}{\\partial x} [-\\sin(t)] = 0\n$$\n修正后的力项是：\n$$\nf(x,t) - \\ell_t(x,t) + \\ell_{xx}(x,t) = x - (1-x)\\cos(t)\n$$\n现在我们计算与 $\\varphi_1(x)$ 的内积：\n$$\nF_1(t) = \\int_0^1 \\left( x - (1-x)\\cos(t) \\right) \\sqrt{2}\\,\\sin(\\pi x) \\, dx\n$$\n我们可以将积分拆分：\n$$\nF_1(t) = \\sqrt{2} \\int_0^1 x \\sin(\\pi x) \\, dx - \\sqrt{2} \\cos(t) \\int_0^1 (1-x) \\sin(\\pi x) \\, dx\n$$\n让我们计算这两个定积分。对于第一个积分，我们使用分部积分法，设 $u=x$ 和 $dv=\\sin(\\pi x)dx$：\n$$\n\\int_0^1 x \\sin(\\pi x) \\, dx = \\left[ -x \\frac{\\cos(\\pi x)}{\\pi} \\right]_0^1 - \\int_0^1 \\left(-\\frac{\\cos(\\pi x)}{\\pi}\\right) dx = -\\frac{1}{\\pi}\\cos(\\pi) + \\frac{1}{\\pi} \\left[ \\frac{\\sin(\\pi x)}{\\pi} \\right]_0^1 = \\frac{1}{\\pi} + 0 = \\frac{1}{\\pi}\n$$\n对于第二个积分：\n$$\n\\int_0^1 (1-x) \\sin(\\pi x) \\, dx = \\int_0^1 \\sin(\\pi x) \\, dx - \\int_0^1 x \\sin(\\pi x) \\, dx\n$$\n第一部分是 $\\int_0^1 \\sin(\\pi x) dx = \\left[-\\frac{\\cos(\\pi x)}{\\pi}\\right]_0^1 = -\\frac{1}{\\pi}(\\cos(\\pi) - \\cos(0)) = -\\frac{1}{\\pi}(-1 - 1) = \\frac{2}{\\pi}$。\n我们已经求出第二部分是 $\\frac{1}{\\pi}$。所以，第二个积分是 $\\frac{2}{\\pi} - \\frac{1}{\\pi} = \\frac{1}{\\pi}$。\n\n将这些结果代回 $F_1(t)$ 的表达式中：\n$$\nF_1(t) = \\sqrt{2} \\left( \\frac{1}{\\pi} \\right) - \\sqrt{2} \\cos(t) \\left( \\frac{1}{\\pi} \\right) = \\frac{\\sqrt{2}}{\\pi} (1 - \\cos(t))\n$$\n最后，我们在 $t=\\ln(2)$ 处计算 $F_1(t)$：\n$$\nF_1(\\ln(2)) = \\frac{\\sqrt{2}}{\\pi} (1 - \\cos(\\ln(2)))\n$$\n这就是所要求的闭式解析表达式。", "answer": "$$\n\\boxed{\\frac{\\sqrt{2}}{\\pi} (1 - \\cos(\\ln(2)))}\n$$", "id": "3410807"}, {"introduction": "对于具有显著瞬态特征（如移动的激波）的高度非定常问题，单一的全局POD基的表达效率可能会很低，因为它难以同时精确捕捉激波前后的不同流动结构。本练习将探讨一种更先进的策略——“时窗POD”（time-windowed POD），通过在不同时间段内分别计算POD基，来更有效地捕捉系统演化的不同阶段。您将通过一个可压缩欧拉方程的数值模拟，量化分析激波等间断对POD模态能量分布的影响，从而深入理解POD在复杂流动问题中的适用性与局限性。", "problem": "考虑空间域 $x \\in [0,1]$ 和时间区间 $t \\in [0,T]$ 上，比热比 $\\gamma = 1.4$ 的量热完全气体的一维可压缩欧拉方程。守恒变量为 $U = (\\rho, \\rho u, E)^\\top$，其中 $\\rho$ 是密度，$u$ 是速度，$E$ 是总能量。控制方程为\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0,\n$$\n其中通量为\n$$\nF(U) = \n\\begin{pmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\nu (E + p)\n\\end{pmatrix},\n$$\n压力 $p$ 由状态方程 $p = (\\gamma - 1)\\left(E - \\frac{1}{2}\\rho u^2\\right)$ 给出。\n\n使用多项式阶数 $p=0$ 的间断伽辽金 (DG) 离散（即每个单元上采用分片常数基），这与守恒有限体积法一致。对单元间的数值通量，采用 Harten–Lax–van Leer–Einfeldt (HLLE) 近似黎曼求解器。令 $N$ 为计算单元的数量，单元宽度均匀，为 $\\Delta x = 1/N$。使用透射边界条件。\n\n使用中心位于 $x_0 = 0.5$、平滑宽度为 $w = 0.02$ 的平滑激波管剖面来初始化流场。令左状态为 $(\\rho_L, u_L, p_L) = (1.0, 0.0, 1.0)$，右状态为 $(\\rho_R, u_R, p_R) = (0.125, 0.0, 0.1)$。定义平滑混合函数\n$$\n\\phi(x) = \\frac{1}{2}\\left(1 - \\tanh\\left(\\frac{x - x_0}{w}\\right)\\right),\n$$\n并设置初始条件\n$$\n\\rho(x,0) = \\phi(x)\\rho_L + (1 - \\phi(x))\\rho_R,\\quad\nu(x,0) = 0,\\quad\np(x,0) = \\phi(x)p_L + (1 - \\phi(x))p_R.\n$$\n使用稳定的显式时间步进方法，在 Courant–Friedrichs–Lewy (CFL) 数为 $0.5$ 的条件下，将系统积分至最终时间 $T = 0.2$。其中时间步长 $\\Delta t$ 满足\n$$\n\\Delta t \\le \\mathrm{CFL}\\,\\frac{\\Delta x}{\\max_i \\left(|u_i| + c_i\\right)},\\quad c_i = \\sqrt{\\gamma \\frac{p_i}{\\rho_i}},\n$$\n并在 $t \\in [0,T]$ 范围内记录 $M=60$ 个等间距的密度场 $\\rho(x,t)$ 快照。构建快照矩阵 $X \\in \\mathbb{R}^{N \\times M}$，其列为每个快照时刻的节点密度值。\n\n定义两个时间窗：$W_{\\text{pre}} = \\{t \\in [0, t_{\\text{pre}}]\\}$ 和 $W_{\\text{post}} = \\{t \\in [t_{\\text{post}}, T]\\}$，其中 $0 < t_{\\text{pre}} < t_{\\text{post}} < T$。对每个窗口，通过选择快照时间位于相应窗口内的 $X$ 的列，来构成加窗快照矩阵 $X_{\\text{pre}}$ 和 $X_{\\text{post}}$。\n\n对每个加窗快照矩阵通过奇异值分解 (SVD) 执行本征正交分解 (POD)。本征正交分解 (POD) 旨在寻找一组标准正交空间模态 $\\{\\varphi_i\\}$，以在最小二乘意义下最优地表示快照集合。具体而言，计算 SVD 分解\n$$\nX_{\\text{win}} = U_{\\text{win}} \\Sigma_{\\text{win}} V_{\\text{win}}^\\top,\n$$\n其中 $U_{\\text{win}} \\in \\mathbb{R}^{N \\times r_{\\max}}$ 包含标准正交列（空间 POD 模态），$\\Sigma_{\\text{win}}$ 是对角线上为非负奇异值的对角矩阵，$V_{\\text{win}}$ 包含时间系数。令 $r$ 为选定的截断秩，并保留前 $r$ 个左奇异向量（记为 $\\varphi_i$，$i=1,\\dots,r$）及其对应的奇异值 $\\sigma_i$。\n\n为量化间断对 POD 模态造成的污染，根据梯度阈值定义一个激波区域掩码。对于给定窗口，计算每个快照中密度的离散梯度幅值\n$$\ng_j(t_k) = \\left|\\frac{\\rho_{j+1}(t_k) - \\rho_{j}(t_k)}{\\Delta x}\\right|,\\quad j=1,\\dots,N-1,\n$$\n并定义窗口内每个界面上随时间变化的最大梯度\n$$\nG_j = \\max_{t_k \\in W_{\\text{win}}} g_j(t_k).\n$$\n给定梯度阈值 $\\tau > 0$，将激波区域掩码 $\\mathcal{I}_\\tau$ 定义为相邻界面梯度超过该阈值的单元索引集合：\n$$\n\\mathcal{I}_\\tau = \\left\\{ i \\in \\{1,\\dots,N\\} \\,\\middle|\\, \\max\\left(G_{i-1}, G_i\\right) \\ge \\tau \\right\\},\n$$\n约定 $G_0 = G_N = 0$。\n\n对于一个归一化的 POD 模态 $\\varphi_i$（由 SVD 输出），定义其污染分数\n$$\nC_i = \\frac{\\sum_{j \\in \\mathcal{I}_\\tau} \\varphi_i(j)^2}{\\sum_{j=1}^{N} \\varphi_i(j)^2}.\n$$\n定义前 $r$ 个模态的加权污染指数为\n$$\n\\mathrm{CI}(r,\\tau) = \\frac{\\sum_{i=1}^{r} \\sigma_i^2\\, C_i}{\\sum_{i=1}^{r} \\sigma_i^2},\n$$\n其中 $\\sigma_i$ 是与模态相关联的奇异值。计算两个窗口的 $\\mathrm{CI}_{\\text{pre}}(r,\\tau)$ 和 $\\mathrm{CI}_{\\text{post}}(r,\\tau)$，并报告其差值\n$$\n\\Delta(r,\\tau) = \\mathrm{CI}_{\\text{post}}(r,\\tau) - \\mathrm{CI}_{\\text{pre}}(r,\\tau).\n$$\n\n实现上述过程，并使用固定的离散化参数 $N=200$、$T=0.2$、$\\gamma=1.4$、$M=60$ 和 CFL$=0.5$ 来评估以下测试套件：\n\n- 测试用例 1 (正常路径): $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (5, 50.0, 0.05, 0.12)$。\n- 测试用例 2 (更高秩): $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (10, 50.0, 0.05, 0.12)$。\n- 测试用例 3 (更严格阈值): $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (5, 80.0, 0.05, 0.12)$。\n- 测试用例 4 (单一模态): $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (1, 50.0, 0.05, 0.12)$。\n- 测试用例 5 (宽松阈值和高秩): $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (20, 30.0, 0.05, 0.12)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表项按上述测试用例的顺序列出，每个条目是该用例的 $\\Delta(r,\\tau)$ 的浮点值（例如，[result1,result2,result3,result4,result5]）。输出中不需要单位。不出现角度。如果任一计算窗口包含的快照少于两个，或者 $r$ 超过该窗口中可用奇异值的数量，则将 $r$ 调整为该窗口中可用的最大值并继续。", "solution": "用户提供了一个流体动力学和模型降阶领域中定义明确的计算问题。我将继续对求解方法进行详细分解，然后给出完整的实现。\n\n### 第 1 步：问题验证\n\n**1.1. 提取已知条件**\n\n- **控制方程**：一维可压缩欧拉方程，$\\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0$。\n- **状态向量**：$U = (\\rho, \\rho u, E)^\\top$。\n- **通量向量**：$F(U) = (\\rho u, \\rho u^2 + p, u (E + p))^\\top$。\n- **状态方程**：对于量热完全气体，$p = (\\gamma - 1)(E - \\frac{1}{2}\\rho u^2)$。\n- **物理参数**：比热比 $\\gamma = 1.4$。\n- **域**：空间 $x \\in [0,1]$，时间 $t \\in [0,T]$，其中 $T=0.2$。\n- **离散化**：在 $N=200$ 个均匀单元上采用多项式阶数 $p=0$ 的间断伽辽金 (DG) 方法。单元宽度 $\\Delta x = 1/N$。这等价于一个有限体积法。\n- **数值通量**：Harten–Lax–van Leer–Einfeldt (HLLE) 近似黎曼求解器。\n- **边界条件**：透射边界。\n- **初始条件**：一个平滑的激波管剖面。\n    - 左状态 $(\\rho_L, u_L, p_L) = (1.0, 0.0, 1.0)$。\n    - 右状态 $(\\rho_R, u_R, p_R) = (0.125, 0.0, 0.1)$。\n    - 平滑函数：$\\phi(x) = \\frac{1}{2}(1 - \\tanh((x - x_0)/w))$，中心 $x_0 = 0.5$，宽度 $w = 0.02$。\n    - 初始剖面：$\\rho(x,0)$、$u(x,0)$、$p(x,0)$ 是使用 $\\phi(x)$ 对左右状态进行加权平均得到。\n- **时间积分**：显式方法，CFL 数为 $0.5$。时间步长 $\\Delta t \\le \\mathrm{CFL}\\,\\frac{\\Delta x}{\\max_i (|u_i| + c_i)}$，其中 $c_i = \\sqrt{\\gamma p_i/\\rho_i}$。\n- **快照收集**：在 $t \\in [0,T]$ 期间，采集 $M=60$ 个等间距的密度场 $\\rho(x,t)$ 快照。\n- **POD 分析**：\n    - 快照矩阵 $X \\in \\mathbb{R}^{N \\times M}$。\n    - 时间窗：$W_{\\text{pre}} = [0, t_{\\text{pre}}]$ 和 $W_{\\text{post}} = [t_{\\text{post}}, T]$。\n    - 对加窗矩阵进行 SVD：$X_{\\text{win}} = U_{\\text{win}} \\Sigma_{\\text{win}} V_{\\text{win}}^\\top$。\n- **污染量化**：\n    - 基于时间内的最大离散梯度幅值 $G_j$ 和阈值 $\\tau$ 的激波区域掩码 $\\mathcal{I}_\\tau$。\n    - 每个 POD 模态 $\\varphi_i$ 的污染分数 $C_i$。\n    - 加权污染指数 $\\mathrm{CI}(r,\\tau) = (\\sum_{i=1}^{r} \\sigma_i^2 C_i) / (\\sum_{i=1}^{r} \\sigma_i^2)$。\n- **最终输出**：差值 $\\Delta(r,\\tau) = \\mathrm{CI}_{\\text{post}}(r,\\tau) - \\mathrm{CI}_{\\text{pre}}(r,\\tau)$。\n- **测试用例**：\n    1. $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (5, 50.0, 0.05, 0.12)$\n    2. $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (10, 50.0, 0.05, 0.12)$\n    3. $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (5, 80.0, 0.05, 0.12)$\n    4. $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (1, 50.0, 0.05, 0.12)$\n    5. $(r, \\tau, t_{\\text{pre}}, t_{\\text{post}}) = (20, 30.0, 0.05, 0.12)$\n- **特殊规则**：如果 $r$ 超过窗口中可用奇异值的数量，则必须将 $r$ 调整为该窗口的最大可用值。\n\n**1.2. 验证与结论**\n\n该问题具有科学依据、适定且客观。它描述了计算流体动力学和降阶建模中的一个标准数值实验。\n- **科学合理性**：欧拉方程、状态方程以及使用带有 HLLE 求解器的守恒数值格式（DG p=0/FVM）都是为无粘性可压缩流建模的标准且物理上正确的方法。Sod 激波管是一个经典的基准问题。\n- **适定性**：该问题是适定的。初始条件已指定，边界条件已定义，数值方法是完整的。离散化、时间步进（CFL 条件）和分析的参数都已提供，从而可以得到一个唯一的、可计算的解。\n- **客观性与清晰度**：问题以精确的数学和算法术语陈述。所有量，包括自定义的“污染指数”，都通过无歧义的公式定义。\n\n该问题不违反任何无效标准。它是一个复杂、多步骤的计算任务，是可验证和可形式化的。\n\n**结论：问题有效。**\n\n### 第 2 步：解决方案设计\n\n解决方案将使用 Python 和 `numpy` 库来实现。整个过程分为三个主要部分：\n1.  **数值模拟**：开发一个一维欧拉方程的有限体积求解器。该求解器使用 HLLE 近似黎曼求解器计算数值通量，并采用由 CFL 条件稳定的显式前向欧拉时间积分格式。\n2.  **数据收集**：模拟从 $t=0$ 运行到 $t=T$，并在 $M$ 个等间距的时间间隔收集密度场的快照。\n3.  **POD 与污染分析**：对于每个测试用例，将快照数据划分到激波前和激波后窗口。对每个加窗数据集通过奇异值分解 (SVD) 执行本征正交分解 (POD)。基于梯度阈值计算激波区域掩码，并使用此掩码计算每个窗口的加权污染指数。最终结果是激波后和激波前污染指数之间的差值。\n\n**第 1 部分：有限体积求解器**\n\n系统的状态由一个形状为 `(3, N)` 的 `numpy` 数组 `U` 表示，其中 `N` 是单元数量，第一维对应于守恒变量 $(\\rho, \\rho u, E)$。\n\n- **初始条件**：在 $t=0$ 时，使用给定的平滑剖面在每个单元中心计算原始变量 $(\\rho, u, p)$。然后将这些变量转换为守恒状态向量 $U$。\n- **时间步进**：主循环将时间从 $t=0$ 推进到 $t=T$。在每个步骤中：\n    1.  计算所有单元上的最大波速 $\\lambda_{\\max} = \\max_i(|u_i| + c_i)$。\n    2.  使用 CFL 条件计算一个稳定的时间步长 $\\Delta t$。为确保精确捕获快照，如果下一个时间步会越过预定的快照时间，则对 $\\Delta t$ 进行调整。\n    3.  **边界条件**：通过在域的每一端创建两个虚拟单元来实现透射边界条件，这些虚拟单元的状态从相邻的内部单元复制而来。\n    4.  **数值通量**：在 $N+1$ 个单元界面中的每一个上计算 HLLE 通量 $F^*_{HLLE}$。界面左侧 ($U_L$) 和右侧 ($U_R$) 的状态取自相应的单元（或虚拟单元）。HLLE 通量计算如下：\n        $$ F_{HLLE}(U_L, U_R) = \\frac{ S_R F(U_L) - S_L F(U_R) + S_L S_R (U_R - U_L) }{ S_R - S_L } $$\n        如果 $S_L < 0 < S_R$。如果 $S_L \\ge 0$，则通量为 $F(U_L)$；如果 $S_R \\le 0$，则通量为 $F(U_R)$。信号速度 $S_L$ 和 $S_R$ 是基于左右状态的最小和最大波速估算的：$S_L = \\min(u_L - c_L, u_R - c_R)$ 和 $S_R = \\max(u_L + c_L, u_R + c_R)$。\n    5.  **状态更新**：使用有限体积公式更新每个单元 $i$ 中的守恒状态：\n        $$ U_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} (F^*_{i+1/2} - F^*_{i-1/2}) $$\n\n**第 2 部分：快照与分析**\n\n- **快照矩阵**：预先分配一个形状为 $(N, M)$ 的矩阵 $X$。在模拟过程中，每当当前时间 $t$ 与快照时间匹配时，就提取密度向量 $\\rho$（状态向量 $U$ 的第一个分量）并将其作为一列存储在 $X$ 中。\n- **加窗**：对于每个测试用例，提取 $X$ 中对应于激波前时间窗 $[0, t_{\\text{pre}}]$ 和激波后时间窗 $[t_{\\text{post}}, T]$ 的列，以形成矩阵 $X_{\\text{pre}}$ 和 $X_{\\text{post}}$。\n- **通过 SVD 进行 POD**：将 `numpy.linalg.svd` 函数应用于每个加窗矩阵，$X_{\\text{win}} = U_{\\text{win}} \\Sigma_{\\text{win}} V_{\\text{win}}^\\top$。$U_{\\text{win}}$ 的列是空间 POD 模态（$\\varphi_i$），$\\Sigma_{\\text{win}}$ 的对角线元素是奇异值（$\\sigma_i$）。根据问题要求，用于分析的秩 $r$ 被调整为不超过窗口中的快照数量：$r_{\\text{eff}} = \\min(r_{\\text{requested}}, \\text{num\\_snapshots})$。\n- **污染指数计算**：\n    1.  **梯度计算**：对每个窗口，计算所有快照的离散密度梯度。找出每个单元界面在所有时间上的最大梯度幅值，得到一个大小为 $N-1$ 的向量 $G$。\n    2.  **激波区域掩码**：对于给定的阈值 $\\tau$，创建一个布尔掩码。如果单元 $i$ 的任一相邻界面上的最大梯度 $G$ 超过 $\\tau$，则该单元被标记为激波区域的一部分。\n    3.  **污染分数**：对于前 $r_{\\text{eff}}$ 个 POD 模态 $\\varphi_i$ 中的每一个，其污染分数 $C_i$ 计算为该模态在激波区域内分量的平方和。由于 SVD 输出的模态是归一化的，因此这可简化为 $\\sum_{j \\in \\mathcal{I}_\\tau} \\varphi_i(j)^2$。\n    4.  **加权指数**：窗口的污染指数 $\\mathrm{CI}(r, \\tau)$ 是通过对分数 $C_i$ 进行加权平均计算得出的，权重为相应的奇异值的平方 $\\sigma_i^2$。\n- **最终结果**：计算每个测试用例的差值 $\\Delta = \\mathrm{CI}_{\\text{post}} - \\mathrm{CI}_{\\text{pre}}$ 并存储。最终输出是这些差值的列表。\n\n这种结构化的方法确保了问题的所有要求都得到满足，包括特定的数值方法、数据分析程序以及特殊情况的处理。", "answer": "```python\nimport numpy as np\n\ndef get_primitive_from_conservative(U, gamma):\n    \"\"\"Converts conservative variables to primitive variables.\"\"\"\n    rho = U[0, :]\n    rhou = U[1, :]\n    E = U[2, :]\n    u = rhou / rho\n    p = (gamma - 1.0) * (E - 0.5 * rhou**2 / rho)\n    return rho, u, p\n\ndef get_conservative_from_primitive(rho, u, p, gamma):\n    \"\"\"Converts primitive variables to conservative variables.\"\"\"\n    U = np.zeros((3, len(rho)))\n    U[0, :] = rho\n    U[1, :] = rho * u\n    U[2, :] = p / (gamma - 1.0) + 0.5 * rho * u**2\n    return U\n\ndef get_flux(U, gamma):\n    \"\"\"Computes the physical flux F(U).\"\"\"\n    rho, u, p = get_primitive_from_conservative(U, gamma)\n    flux = np.zeros_like(U)\n    flux[0, :] = rho * u\n    flux[1, :] = rho * u**2 + p\n    flux[2, :] = u * (U[2, :] + p)\n    return flux\n\ndef get_hlle_flux(UL, UR, gamma):\n    \"\"\"Computes the HLLE approximate Riemann solver flux.\"\"\"\n    rho_L, u_L, p_L = get_primitive_from_conservative(UL.reshape(3, 1), gamma)\n    rho_R, u_R, p_R = get_primitive_from_conservative(UR.reshape(3, 1), gamma)\n\n    c_L = np.sqrt(gamma * p_L / rho_L)\n    c_R = np.sqrt(gamma * p_R / rho_R)\n\n    s_L = min(u_L - c_L, u_R - c_R)[0]\n    s_R = max(u_L + c_L, u_R + c_R)[0]\n\n    flux_L = get_flux(UL.reshape(3, 1), gamma)\n    flux_R = get_flux(UR.reshape(3, 1), gamma)\n\n    if s_L >= 0.0:\n        return flux_L.flatten()\n    elif s_R <= 0.0:\n        return flux_R.flatten()\n    else:\n        num = s_R * flux_L - s_L * flux_R + s_L * s_R * (UR.reshape(3, 1) - UL.reshape(3, 1))\n        den = s_R - s_L\n        return (num / den).flatten()\n\ndef run_simulation(N, T, M, CFL, gamma):\n    \"\"\"Runs the 1D Euler simulation and collects density snapshots.\"\"\"\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    \n    # Initial conditions\n    rho_L, u_L, p_L = 1.0, 0.0, 1.0\n    rho_R, u_R, p_R = 0.125, 0.0, 0.1\n    x0, w = 0.5, 0.02\n    \n    phi = 0.5 * (1.0 - np.tanh((x - x0) / w))\n    rho0 = phi * rho_L + (1.0 - phi) * rho_R\n    u0 = phi * u_L + (1.0 - phi) * u_R\n    p0 = phi * p_L + (1.0 - phi) * p_R\n    \n    U = get_conservative_from_primitive(rho0, u0, p0, gamma)\n    \n    t_snapshots = np.linspace(0, T, M)\n    snapshots = np.zeros((N, M))\n    snapshots[:, 0] = U[0, :].copy()\n    \n    t = 0.0\n    snapshot_idx = 1\n    \n    while t < T:\n        rho, u, p = get_primitive_from_conservative(U, gamma)\n        c = np.sqrt(gamma * p / rho)\n        max_speed = np.max(np.abs(u) + c)\n        \n        dt = CFL * dx / max_speed\n        \n        if snapshot_idx < M and t + dt >= t_snapshots[snapshot_idx]:\n            dt = t_snapshots[snapshot_idx] - t\n        elif t + dt > T:\n            dt = T - t\n\n        U_ext = np.zeros((3, N + 2))\n        U_ext[:, 1:-1] = U\n        U_ext[:, 0] = U[:, 0] # Transmissive BC\n        U_ext[:, -1] = U[:, -1] # Transmissive BC\n        \n        fluxes = np.zeros((3, N + 1))\n        for i in range(N + 1):\n            fluxes[:, i] = get_hlle_flux(U_ext[:, i], U_ext[:, i+1], gamma)\n            \n        U_update = -(dt / dx) * (fluxes[:, 1:] - fluxes[:, :-1])\n        U += U_update\n        \n        t += dt\n\n        if snapshot_idx < M and np.isclose(t, t_snapshots[snapshot_idx]):\n            snapshots[:, snapshot_idx] = U[0, :].copy()\n            snapshot_idx += 1\n            \n    return snapshots, t_snapshots\n\ndef calculate_ci(X_win, r_req, tau, dx, N):\n    \"\"\"Calculates the weighted contamination index for a given window.\"\"\"\n    num_snapshots = X_win.shape[1]\n    if num_snapshots < 2:\n        return 0.0\n\n    r = min(r_req, num_snapshots)\n    \n    # SVD for POD modes\n    try:\n        U, s, Vt = np.linalg.svd(X_win, full_matrices=False)\n    except np.linalg.LinAlgError:\n        return 0.0\n\n    # Calculate max-in-time gradient\n    grads = np.abs((X_win[1:, :] - X_win[:-1, :]) / dx)\n    G = np.max(grads, axis=1) # Shape (N-1)\n    \n    # Create shock-region mask\n    mask = np.zeros(N, dtype=bool)\n    if N > 1:\n        mask[0] = G[0] >= tau\n        mask[-1] = G[-2] >= tau\n        if N > 2:\n            mask[1:-1] = (G[:-1] >= tau) | (G[1:] >= tau)\n    \n    mask_indices = np.where(mask)[0]\n\n    # Calculate contamination fractions\n    C_vec = np.zeros(r)\n    modes = U[:, :r]\n    if mask_indices.size > 0:\n        components_in_mask = modes[mask_indices, :]\n        C_vec = np.sum(components_in_mask**2, axis=0) # Denominator (norm^2) is 1.0\n\n    # Calculate weighted contamination index\n    sigmas_sq = s[:r]**2\n    numerator = np.sum(sigmas_sq * C_vec)\n    denominator = np.sum(sigmas_sq)\n\n    if denominator == 0.0:\n        return 0.0\n        \n    return numerator / denominator\n\ndef solve():\n    # Fixed parameters\n    N = 200\n    T = 0.2\n    gamma = 1.4\n    M = 60\n    CFL = 0.5\n    dx = 1.0 / N\n\n    # Run simulation once to generate all snapshots\n    X, t_snapshots = run_simulation(N, T, M, CFL, gamma)\n\n    test_cases = [\n        (5, 50.0, 0.05, 0.12),\n        (10, 50.0, 0.05, 0.12),\n        (5, 80.0, 0.05, 0.12),\n        (1, 50.0, 0.05, 0.12),\n        (20, 30.0, 0.05, 0.12),\n    ]\n\n    results = []\n    for r_req, tau, t_pre, t_post in test_cases:\n        # Pre-shock window\n        pre_indices = np.where(t_snapshots <= t_pre)[0]\n        X_pre = X[:, pre_indices]\n        ci_pre = calculate_ci(X_pre, r_req, tau, dx, N)\n        \n        # Post-shock window\n        post_indices = np.where(t_snapshots >= t_post)[0]\n        X_post = X[:, post_indices]\n        ci_post = calculate_ci(X_post, r_req, tau, dx, N)\n        \n        delta = ci_post - ci_pre\n        results.append(delta)\n\n    # Format output as specified\n    print(f\"[{','.join(f'{res:.10f}' for res in results)}]\")\n\nsolve()\n```", "id": "3410825"}]}