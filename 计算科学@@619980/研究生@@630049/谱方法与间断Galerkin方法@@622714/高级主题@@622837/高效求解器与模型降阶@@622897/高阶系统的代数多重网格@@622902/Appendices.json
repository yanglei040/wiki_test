{"hands_on_practices": [{"introduction": "掌握聚合策略是构建代数多重网格（AMG）求解器的第一步。本练习 [@problem_id:3363005] 提供了一个具体的手动任务，在一个简单的网格上应用一种特定的方法——单元面聚合，以帮助您直观地理解如何从细网格信息构建粗糙层。通过计算聚合的大小，您将直接体会到粗化过程如何影响粗糙空间自由度的数量和分布。", "problem": "考虑一个标量椭圆算子，它在一个二维四边形网格上通过多项式次数为 $p=4$ 的非连续伽辽金(DG)方法进行离散。在Gauss–Lobatto点上使用分层节点基，使得每个单元上的局部多项式空间分解为顶点、边和内部模式。特别地，对于一个四边形单元，次数为$p$的空间的维度是 $(p+1)^{2}$，它分解为 $4$ 个顶点模式，$4(p-1)$ 个边模式（每个面 $(p-1)$ 个），以及 $(p-1)^{2}$ 个内部模式。在一个采用单元-面聚合的代数多重网格(AMG)方案中，构造仅由与网格面相关联的边模式组成的聚合体：对于由两个单元共享的内部面，聚合体包含来自两个相邻单元并限制在该面上的所有边模式；对于边界面，聚合体包含来自单个相邻单元并限制在该面上的边模式。粗层图每个聚合体有一个节点，如果两个聚合体之间存在从细层算子继承的强代数耦合，则它们之间有边；对于具有一致内部和通量耦合的DG，一个充分条件是：如果两个聚合体的面属于一个共同的单元，则它们在粗层图中是相邻的。\n\n网格是一个覆盖矩形域的结构化 $2 \\times 2$ 四边形单元阵列，划分为单元 $E_{11}$（左上）、$E_{12}$（右上）、$E_{21}$（左下）和 $E_{22}$（右下）。将面聚合体（粗层节点）标记如下：\n- $F_{1}$：$E_{11}$ 的左边界，$F_{2}$：$E_{11}$ 的上边界，$F_{3}$：$E_{11}$ 和 $E_{12}$ 之间的内部垂直面，$F_{4}$：$E_{11}$ 和 $E_{21}$ 之间的内部水平面，\n- $F_{5}$：$E_{12}$ 的上边界，$F_{6}$：$E_{12}$ 的右边界，$F_{7}$：$E_{12}$ 和 $E_{22}$ 之间的内部水平面，\n- $F_{8}$：$E_{21}$ 的左边界，$F_{9}$：$E_{21}$ 的下边界，$F_{10}$：$E_{21}$ 和 $E_{22}$ 之间的内部垂直面，\n- $F_{11}$：$E_{22}$ 的下边界，$F_{12}$：$E_{22}$ 的右边界。\n\n使用上述单元-面聚合规则和DG耦合结构，计算 $F_{i}$ 之间的粗层图邻接关系，并确定对于 $p=4$ 时所有 $F_{i}$ 的最大和平均聚合体大小。将最终答案表示为包含两个数字的单行矩阵，其中第一个条目是最大聚合体大小，第二个条目是平均聚合体大小。无需四舍五入。", "solution": "用户要求我解决以下问题：\n考虑一个标量椭圆算子，它在一个二维四边形网格上通过多项式次数为 $p=4$ 的非连续伽辽金(DG)方法进行离散。在Gauss–Lobatto点上使用分层节点基，使得每个单元上的局部多项式空间分解为顶点、边和内部模式。特别地，对于一个四边形单元，次数为$p$的空间的维度是 $(p+1)^{2}$，它分解为 $4$ 个顶点模式，$4(p-1)$ 个边模式（每个面 $(p-1)$ 个），以及 $(p-1)^{2}$ 个内部模式。在一个采用单元-面聚合的代数多重网格(AMG)方案中，构造仅由与网格面相关联的边模式组成的聚合体：对于由两个单元共享的内部面，聚合体包含来自两个相邻单元并限制在该面上的所有边模式；对于边界面，聚合体包含来自单个相邻单元并限制在该面上的边模式。粗层图每个聚合体有一个节点，如果两个聚合体之间存在从细层算子继承的强代数耦合，则它们之间有边；对于具有一致内部和通量耦合的DG，一个充分条件是：如果两个聚合体的面属于一个共同的单元，则它们在粗层图中是相邻的。\n\n网格是一个覆盖矩形域的结构化 $2 \\times 2$ 四边形单元阵列，划分为单元 $E_{11}$（左上）、$E_{12}$（右上）、$E_{21}$（左下）和 $E_{22}$（右下）。将面聚合体（粗层节点）标记如下：\n- $F_{1}$：$E_{11}$ 的左边界，$F_{2}$：$E_{11}$ 的上边界，$F_{3}$：$E_{11}$ 和 $E_{12}$ 之间的内部垂直面，$F_{4}$：$E_{11}$ 和 $E_{21}$ 之间的内部水平面，\n- $F_{5}$：$E_{12}$ 的上边界，$F_{6}$：$E_{12}$ 的右边界，$F_{7}$：$E_{12}$ 和 $E_{22}$ 之间的内部水平面，\n- $F_{8}$：$E_{21}$ 的左边界，$F_{9}$：$E_{21}$ 的下边界，$F_{10}$：$E_{21}$ 和 $E_{22}$ 之间的内部垂直面，\n- $F_{11}$：$E_{22}$ 的下边界，$F_{12}$：$E_{22}$ 的右边界。\n\n使用上述单元-面聚合规则和DG耦合结构，计算 $F_{i}$ 之间的粗层图邻接关系，并确定对于 $p=4$ 时所有 $F_{i}$ 的最大和平均聚合体大小。将最终答案表示为包含两个数字的单行矩阵，其中第一个条目是最大聚合体大小，第二个条目是平均聚合体大小。无需四舍五入。\n\n首先，通过提取所有给定信息并评估其科学合理性、一致性和完整性来验证问题。\n\n第 1 步：提取已知信息\n- 离散化方法：非连续伽辽金(DG)。\n- 算子类型：标量椭圆。\n- 网格：二维四边形网格，结构化 $2 \\times 2$ 阵列。\n- 多项式次数：$p=4$。\n- 基：Gauss-Lobatto点上的分层节点基。\n- 局部多项式空间分解：$4$ 个顶点模式，$4(p-1)$ 个边模式（每个面 $(p-1)$ 个），以及 $(p-1)^2$ 个内部模式。\n- AMG聚合策略：单元-面聚合，仅使用边模式。\n- 内部面的聚合体定义：包含来自两个相邻单元并限制在该面上的所有边模式。\n- 边界面的聚合体定义：包含来自单个相邻单元并限制在该面上的边模式。\n- 粗层图连通性规则：如果两个聚合体的面属于一个共同的单元，则它们是相邻的。\n- 网格结构：$E_{11}$（左上）、$E_{12}$（右上）、$E_{21}$（左下）、$E_{22}$（右下）。\n- 面标记：$F_1, \\dots, F_{12}$，如问题描述中定义。\n- 任务：计算粗层图邻接关系，确定最大和平均聚合体大小。\n- 最终答案格式：一个包含两个条目的行矩阵：[最大聚合体大小, 平均聚合体大小]。\n\n第 2 步：使用提取的已知信息进行验证\n该问题具有科学依据，是适定的、客观的。\n- **科学依据**：该问题设置在偏微分方程数值方法这一成熟领域内，具体涉及非连续伽辽金方法和代数多重网格求解器。所有概念，如分层基、Gauss-Lobatto点、基于面的聚合以及粗层图的构建，都是该领域的标准概念。\n- **适定性**：问题提供了确定聚合体大小及其统计数据所需的所有必要信息。构建聚合体和粗层图的规则是明确且无歧义的。该设置能够导出一个唯一的、可计算的解。\n- **客观性**：语言精确、专业，没有主观性或歧义。定义是形式化的，不依赖于解释。\n\n第 3 步：结论和行动\n问题有效。将提供详细的解决方案。\n\n解决方案首先根据给定的多项式次数 $p$ 确定两种类型的聚合体（内部面和边界面）的大小。然后，将指定的 12 个面中的每一个都分类为内部或边界面，以找到其聚合体大小。最后，计算这些大小的最大值和平均值。\n\n问题指出，对于一个次数为 $p$ 的多项式，四边形单元的每个面都有 $(p-1)$ 个关联的边模式。给定的多项式次数为 $p=4$。因此，与单个单元面的一个边相关联的边模式数量为 $p-1 = 4-1 = 3$。\n\n聚合规则取决于一个面是位于域的边界上还是在内部。\n1.  对于边界面，聚合体由单个相邻单元的边模式组成。这种聚合体的大小为 $p-1$。对于 $p=4$，大小为 $3$。\n2.  对于内部面，它由两个相邻单元共享，聚合体由两个单元的边模式组成。在 DG 设置中，每个单元的自由度 (DoFs) 是不同的。因此，一个内部面有两组独立的边模式自由度，每个相邻单元一组。内部面的聚合体总大小为 $(p-1) + (p-1) = 2(p-1)$。对于 $p=4$，大小为 $2(4-1) = 6$。\n\n接下来，我们分析指定的 $2 \\times 2$ 网格，对 12 个面中的每一个进行分类，并确定它们对应的聚合体大小。网格由四个单元组成：\n$$\n\\begin{array}{c|c}\nE_{11}  E_{12} \\\\\n\\hline\nE_{21}  E_{22}\n\\end{array}\n$$\n我们对 $i=1, \\dots, 12$ 的每个面 $F_i$ 进行分类：\n- $F_1$：$E_{11}$ 的左边界。这是一个边界面。聚合体大小 = $3$。\n- $F_2$：$E_{11}$ 的上边界。这是一个边界面。聚合体大小 = $3$。\n- $F_3$：$E_{11}$ 和 $E_{12}$ 之间的内部垂直面。这是一个内部面。聚合体大小 = $6$。\n- $F_4$：$E_{11}$ 和 $E_{21}$ 之间的内部水平面。这是一个内部面。聚合体大小 = $6$。\n- $F_5$：$E_{12}$ 的上边界。这是一个边界面。聚合体大小 = $3$。\n- $F_6$：$E_{12}$ 的右边界。这是一个边界面。聚合体大小 = $3$。\n- $F_7$：$E_{12}$ 和 $E_{22}$ 之间的内部水平面。这是一个内部面。聚合体大小 = $6$。\n- $F_8$：$E_{21}$ 的左边界。这是一个边界面。聚合体大小 = $3$。\n- $F_9$：$E_{21}$ 的下边界。这是一个边界面。聚合体大小 = $3$。\n- $F_{10}$：$E_{21}$ 和 $E_{22}$ 之间的内部垂直面。这是一个内部面。聚合体大小 = $6$。\n- $F_{11}$：$E_{22}$ 的下边界。这是一个边界面。聚合体大小 = $3$。\n- $F_{12}$：$E_{22}$ 的右边界。这是一个边界面。聚合体大小 = $3$。\n\n从这个分类中，我们观察到有 4 个内部面（$F_3, F_4, F_7, F_{10}$）和 8 个边界面（$F_1, F_2, F_5, F_6, F_8, F_9, F_{11}, F_{12}$）。\n\n所有聚合体大小的集合是 $\\{3, 3, 6, 6, 3, 3, 6, 3, 3, 6, 3, 3\\}$。\n\n现在我们可以计算所需的统计数据。\n最大聚合体大小是此集合中的最大值：\n$$\n\\text{最大大小} = \\max(\\{3, 6\\}) = 6\n$$\n平均聚合体大小是所有聚合体大小的总和除以聚合体总数 12。\n大小的总和计算如下：\n$$\n\\text{大小总和} = (8 \\times \\text{边界面聚合体大小}) + (4 \\times \\text{内部面聚合体大小})\n$$\n$$\n\\text{大小总和} = (8 \\times 3) + (4 \\times 6) = 24 + 24 = 48\n$$\n平均聚合体大小为：\n$$\n\\text{平均大小} = \\frac{\\text{大小总和}}{\\text{聚合体数量}} = \\frac{48}{12} = 4\n$$\n\n问题还要求计算粗层图的邻接关系。规则是如果两个聚合体的面属于一个共同的单元，则它们是相邻的。这意味着对于每个单元，其四个面对应的聚合体形成一个完全子图（$K_4$）。\n- 单元 $E_{11}$ 连接面 $\\{F_1, F_2, F_3, F_4\\}$。\n- 单元 $E_{12}$ 连接面 $\\{F_3, F_5, F_6, F_7\\}$。\n- 单元 $E_{21}$ 连接面 $\\{F_4, F_8, F_9, F_{10}\\}$。\n- 单元 $E_{22}$ 连接面 $\\{F_7, F_{10}, F_{11}, F_{12}\\}$。\n这个邻接结构按要求确定，但它不是最终数值答案的一部分。最终答案只需要最大和平均聚合体大小。\n\n最终答案是一个包含最大聚合体大小和平均聚合体大小的行矩阵。\n最大大小 = $6$。\n平均大小 = $4$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n6  4\n\\end{pmatrix}\n}\n$$", "id": "3363005"}, {"introduction": "在学习了如何像练习 [@problem_id:3363005] 中那样形成聚合之后，分析其计算成本至关重要。本练习 [@problem_id:3363047] 将从具体示例转向通用分析模型，要求您推导算子复杂度。通过这个推导，您将了解算法选择（如聚合大小 $k$）和离散化参数（如多项式次数 $p$）如何相互作用，共同决定多重网格循环的整体效率。", "problem": "考虑一个定义在空间维度 $d \\in \\{2,3\\}$ 的有界域上的标量、二阶、一致椭圆扩散算子，该算子在一个包含 $N_{e}$ 个单元的拟一致网格上，使用次数为 $p \\geq 1$ 的张量积谱基，通过内部罚分不连续伽辽金方法进行离散化。令每个单元的局部自由度数量为张量积多项式空间的维度，即 $n_{p} = (p+1)^{d}$。由该离散化产生的细网格刚度矩阵 $A_{0}$ 是块稀疏的：假设在稀疏模式中，每个单元与其自身耦合，并平均与 $\\alpha$ 个相邻单元耦合（因此每个单元对应 $(\\alpha+1)$ 个稠密的 $n_{p} \\times n_{p}$ 块）。在一个使用基于聚合的粗化的代数多重网格（AMG）方法中，考虑通过将每个聚合体中的 $k \\geq 1$ 个连续单元分组来形成粗聚合体，并将每个聚合体上的粗空间定义为分片常数（每个聚合体一个粗未知量）。假设 $N_{e}$ 可被 $k$ 整除，并且聚合体层级的邻接关系反映了细网格层级的平均情况，即聚合图具有相同的平均邻居数 $\\alpha$。仅使用这些结构性假设和定义，完成以下任务：\n\n- 推导每个聚合体聚合 $k$ 个单元所产生的粗未知量数量 $N_{c}$。\n- 从算子复杂度 $C_{\\mathrm{op}} = \\dfrac{\\mathrm{nnz}(A_{0}) + \\mathrm{nnz}(A_{1})}{\\mathrm{nnz}(A_{0})}$ 的定义出发，用 $N_{e}$、$p$、$k$、$d$ 和 $\\alpha$ 来估计 $\\mathrm{nnz}(A_{0})$ 和 $\\mathrm{nnz}(A_{1})$，并将 $C_{\\mathrm{op}}$ 简化为一个闭式表达式，该表达式能明确显示 $k$ 和 $p$ 的选择如何影响算子复杂度。\n\n将你的最终答案表示为一个行矩阵 $\\left(N_{c},\\, C_{\\mathrm{op}}\\right)$，写成单一的解析表达式。无需进行数值计算。", "solution": "问题陈述已经过验证，并被确定为数值分析领域中一个适定且有科学依据的问题。它提供了一套清晰且一致的定义和假设，足以进行所要求的推导。\n\n任务是基于所提供的用于不连续伽辽金（DG）离散化的代数多重网格（AMG）聚合模型，推导粗未知量数量 $N_c$ 和算子复杂度 $C_{\\mathrm{op}}$ 的表达式。\n\n首先，我们推导粗未知量的数量 $N_c$。问题指明细网格有 $N_e$ 个单元。粗化是通过创建聚合体来执行的，每个聚合体包含 $k \\geq 1$ 个单元。粗空间在这些聚合体上被定义为分片常数，这意味着每个聚合体对应一个粗未知量。问题假设 $N_e$ 可被 $k$ 整除，确保单元可以完美地划分为聚合体。因此，聚合体的总数，即粗未知量的数量 $N_c$，由下式给出：\n$$\nN_c = \\frac{N_e}{k}\n$$\n\n接下来，我们估计细网格刚度矩阵 $A_0$ 中的非零元数量 $\\mathrm{nnz}(A_0)$。离散化在 $d$ 维域上使用多项式次数为 $p$ 的谱基，导致每个单元有 $n_p = (p+1)^d$ 个局部自由度（DOF）。刚度矩阵 $A_0$ 是块稀疏的。根据问题陈述，“每个单元与其自身耦合，并平均与 $\\alpha$ 个相邻单元耦合。” 这意味着在 $A_0$ 的块矩阵结构中， $N_e$ 个块行中的每一行平均包含 $(\\alpha+1)$ 个非零块：一个用于单元自耦合的块（对角块）和 $\\alpha$ 个用于与邻居耦合的块。问题进一步指出这些是“稠密的 $n_p \\times n_p$ 块”。一个稠密的 $n_p \\times n_p$ 块包含 $n_p^2$ 个非零元。因此，$A_0$ 中的非零元总数可以通过将单元数（对应于块行数）乘以每块行的平均非零块数和每块的非零元数来估计。\n$$\n\\mathrm{nnz}(A_0) \\approx N_e (\\alpha+1) n_p^2\n$$\n代入给定的定义 $n_p = (p+1)^d$，我们得到：\n$$\n\\mathrm{nnz}(A_0) \\approx N_e (\\alpha+1) \\left((p+1)^d\\right)^2 = N_e (\\alpha+1) (p+1)^{2d}\n$$\n\n然后，我们估计粗网格算子矩阵 $A_1$ 中的非零元数量 $\\mathrm{nnz}(A_1)$。粗算子 $A_1$ 的维度是 $N_c \\times N_c$。问题对其结构提供了一个关键的简化假设：“聚合体层级的邻接关系反映了细网格层级的平均情况，即聚合图具有相同的平均邻居数 $\\alpha$。” 这个假设意味着 $A_1$ 的稀疏模式类似于在聚合图上进行的低阶离散化的稀疏模式。$A_1$ 的每一行将有一个非零对角元（表示聚合体的自相互作用），并平均有 $\\alpha$ 个非零非对角元（表示与相邻聚合体的相互作用）。因此，$A_1$ 的每一行平均有 $(\\alpha+1)$ 个非零元。$A_1$ 中的非零元总数是行数（$N_c$）与每行平均非零元数的乘积。\n$$\n\\mathrm{nnz}(A_1) \\approx N_c (\\alpha+1)\n$$\n代入 $N_c$ 的表达式：\n$$\n\\mathrm{nnz}(A_1) \\approx \\frac{N_e}{k} (\\alpha+1)\n$$\n\n最后，我们推导算子复杂度 $C_{\\mathrm{op}}$。所提供的定义是：\n$$\nC_{\\mathrm{op}} = \\frac{\\mathrm{nnz}(A_0) + \\mathrm{nnz}(A_1)}{\\mathrm{nnz}(A_0)}\n$$\n我们可以将此表达式重写为：\n$$\nC_{\\mathrm{op}} = 1 + \\frac{\\mathrm{nnz}(A_1)}{\\mathrm{nnz}(A_0)}\n$$\n代入 $\\mathrm{nnz}(A_0)$ 和 $\\mathrm{nnz}(A_1)$ 的推导估计值：\n$$\nC_{\\mathrm{op}} \\approx 1 + \\frac{\\frac{N_e}{k} (\\alpha+1)}{N_e (\\alpha+1) (p+1)^{2d}}\n$$\n$N_e$ 和 $(\\alpha+1)$ 项相互抵消，得到一个仅依赖于聚合大小 $k$、多项式次数 $p$ 和空间维度 $d$ 的简化表达式。\n$$\nC_{\\mathrm{op}} = 1 + \\frac{1}{k(p+1)^{2d}}\n$$\n这个结果明确了在确定多重网格算子复杂度时，聚合大小的算法选择（$k$）与多项式次数的离散化选择（$p$）之间的关系。\n\n两个最终表达式是 $N_c = \\frac{N_e}{k}$ 和 $C_{\\mathrm{op}} = 1 + \\frac{1}{k(p+1)^{2d}}$。按照要求，它们以行矩阵的形式呈现。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{N_e}{k}  1 + \\frac{1}{k(p+1)^{2d}} \\end{pmatrix}}\n$$", "id": "3363047"}, {"introduction": "AMG求解器的效率在很大程度上取决于其延拓算子的设计，该算子定义了从粗糙空间到细空间的插值。本编程练习 [@problem_id:3362994] 要求您实现并比较两种方法：一种是纯代数的朴素方法，另一种是尊重谱元离散化中张量积结构的结构感知方法。通过比较它们的双网格收敛因子，您将量化地理解为什么保留底层问题结构是为高阶系统设计高效求解器的关键原则。", "problem": "考虑参考正方形上的Poisson问题，其带有齐次Dirichlet边界条件，其弱形式表述为：寻找一个标量场 $u$，使得对于所有在边界上 $v=0$ 的光滑测试函数 $v$，\n$$\n\\int_{-1}^{1}\\int_{-1}^{1} \\nabla u \\cdot \\nabla v \\, dx\\,dy = \\int_{-1}^{1}\\int_{-1}^{1} f \\, v \\, dx\\,dy,\n$$\n其中 $f$ 是给定的源项。在单一单元的谱元离散化中，近似空间是多项式次数为 $p$ 的Gauss-Lobatto-Legendre (GLL) 节点上的Lagrange多项式的张量积空间，并且双线性形式通过GLL求积进行离散化。在此设置下，施加齐次Dirichlet边界条件并限制在内部节点上的刚度算子 $A$ 可以通过一维微分矩阵和求积权重出发，并使用Kronecker积来表示。\n\n您的任务是为一个双网格方法实现并比较两种代数多重网格 (AMG) 延长策略，该方法将多项式次数从细网格次数 $p_{\\mathrm{f}}$ 粗化到粗网格次数 $p_{\\mathrm{c}} = \\max(2, \\lfloor p_{\\mathrm{f}}/2 \\rfloor)$。这两种延长策略的区别在于它们是否保持由单元自由度排序引起的张量积耦合：\n\n1. 保持张量积的延长：通过在细网格内部节点位置上评估粗网格Lagrange基多项式（定义在包括端点的全套粗网格GLL节点上），构建一个将粗网格内部GLL节点映射到细网格内部GLL节点的一维插值矩阵 $P_1$，然后将二维延长定义为 $P_{\\mathrm{tensor}} = P_1 \\otimes P_1$。\n\n2. 朴素逐点延长：独立于张量结构，对于每个细网格内部节点 $(x_i,y_j)$，在欧几里得度量下选择唯一的最近粗网格内部节点 $(\\hat{x}_\\alpha,\\hat{y}_\\beta)$，并以权重 $1$ 注入到该粗网格自由度中（所有其他权重为 $0$），从而生成一个每行只有一个非零元的稀疏插值矩阵 $P_{\\mathrm{naive}}$。\n\n使用一个具有一次前平滑和一次后平滑步骤的双网格方法，每个步骤都由加权Jacobi方法给出。设 $A$ 为细网格算子，设 $D$ 表示 $A$ 的对角线，并将加权Jacobi平滑子定义为 $S_\\omega = I - \\omega D^{-1} A$。通过最小化基于对称相似性 $D^{-1/2} A D^{-1/2}$ 的Jacobi迭代算子的谱半径来选择权重 $\\omega$，如下所示：\n$$\n\\omega^\\star = \\frac{2}{\\lambda_{\\min}(D^{-1/2} A D^{-1/2}) + \\lambda_{\\max}(D^{-1/2} A D^{-1/2})}.\n$$\n设限制是延长的转置，$R = P^\\top$，并设粗网格算子为Galerkin积 $A_{\\mathrm{c}} = R A P$。粗网格校正算子为 $I - P A_{\\mathrm{c}}^{-1} R A$。那么，双网格误差传播算子为\n$$\nE = S_\\omega \\left(I - P A_{\\mathrm{c}}^{-1} R A\\right) S_\\omega.\n$$\n双网格收敛因子是谱半径 $\\rho(E)$。\n\n您必须使用的基本依据：\n- 基于GLL求积和Lagrange基的参考区间上的谱元刚度矩阵满足一维形式 $M = \\mathrm{diag}(w)$ 和 $S = D^\\top \\mathrm{diag}(w) D$，其中 $w$ 是GLL求积权重，$D$ 是微分矩阵，其元素为 $D_{ij} = \\ell_j'(x_i)$，对应于GLL节点 $x_j$ 上的Lagrange基 $\\ell_j$。\n- 在二维情况下，通过消除边界节点来强制施加齐次Dirichlet边界条件，算子是Kronecker和 $A = S \\otimes M + M \\otimes S$。\n- 次数为 $p$ 的Gauss-Lobatto-Legendre节点是端点 $\\{-1,1\\}$ 以及次数为 $p$ 的Legendre多项式导数的根，GLL求积权重为 $w_i = \\frac{2}{p(p+1)} \\frac{1}{[P_p(x_i)]^2}$。\n- 重心Lagrange公式可以在任意节点上稳定地计算Lagrange多项式及其导数，微分矩阵的元素为 $D_{ij} = \\frac{\\alpha_j}{\\alpha_i} \\frac{1}{x_i - x_j}$（当 $i \\neq j$ 时）和 $D_{ii} = -\\sum_{m \\neq i} D_{im}$，其中 $\\alpha_j$ 是重心权重 $\\alpha_j = \\prod_{m \\neq j} (x_j - x_m)^{-1}$。\n\n在单个程序中实现以下步骤：\n- 对于指定测试套件中的每个多项式次数 $p_{\\mathrm{f}}$，为次数 $p_{\\mathrm{f}}$ 和次数 $p_{\\mathrm{c}}$ 构建一维GLL节点和权重，组装限制在内部节点上的细网格二维刚度矩阵 $A$，并构建上述定义的 $P_{\\mathrm{tensor}}$ 和 $P_{\\mathrm{naive}}$。\n- 对于每种延长策略，使用上面定义的最优选择的 $\\omega^\\star$，构建具有一次前加权Jacobi平滑和一次后加权Jacobi平滑步骤的双网格误差传播矩阵 $E$，并计算 $\\rho(E)$。\n- 通过报告每个 $p_{\\mathrm{f}}$ 的比率 $r = \\rho(E_{\\mathrm{naive}})/\\rho(E_{\\mathrm{tensor}})$，来量化保持张量积耦合的益处。\n\n测试套件：\n- 使用细网格多项式次数 $p_{\\mathrm{f}} \\in \\{4,6,8,12\\}$。对于每个次数，如前所述设置 $p_{\\mathrm{c}} = \\max(2, \\lfloor p_{\\mathrm{f}}/2 \\rfloor)$。\n\n答案规格：\n- 对于测试套件中的每个 $p_{\\mathrm{f}}$，计算比率 $r$ 作为四舍五入到 $6$ 位小数的浮点数。\n- 您的程序应生成单行输出，其中包含按测试套件顺序排列的比率，形式为用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4]$。\n- 不涉及物理单位。", "solution": "该问题要求为Poisson问题的谱元离散化实现并比较两种代数多重网格 (AMG) 延长策略。比较基于双网格方法的收敛因子。该分析将针对一组细网格多项式次数 $p_{\\mathrm{f}}$ 进行。\n\n首先，我们按照规定建立数学和计算框架。\n\n该问题考虑了在参考正方形 $\\Omega = [-1,1]^2$ 上带有齐次Dirichlet边界条件的Poisson方程。其弱形式为：寻找 $u \\in H_0^1(\\Omega)$ 使得\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\Omega} f v \\, d\\Omega \\quad \\forall v \\in H_0^1(\\Omega)\n$$\n该问题通过使用单一谱元进行离散化，其基函数由Gauss-Lobatto-Legendre (GLL) 节点上的Lagrange多项式构造而成。对于多项式次数 $p$，在 $[-1,1]$ 上有 $p+1$ 个GLL节点 $x_i$，它们是 $(1-x^2)P_p'(x)$ 的根，其中 $P_p(x)$ 是次数为 $p$ 的Legendre多项式。相应的GLL求积权重 $w_i$ 由以下公式给出\n$$\nw_i = \\frac{2}{p(p+1) [P_p(x_i)]^2}\n$$\n一维微分矩阵 $D$ 的元素为 $D_{ij} = \\ell_j'(x_i)$，其中 $\\ell_j(x)$ 是节点 $x_j$ 的Lagrange多项式。问题提供了一个基于重心权重 $\\alpha_j = (\\prod_{k \\neq j} (x_j - x_k))^{-1}$ 的公式：\n$$\nD_{ij} = \\frac{\\alpha_j}{\\alpha_i (x_i - x_j)} \\quad \\text{for } i \\neq j\n$$\n为了使常数函数的导数为零，微分矩阵的行和必须为零，即 $\\sum_j D_{ij} = 0$。这意味着对角线元素必须为 $D_{ii} = -\\sum_{j \\neq i} D_{ij}$。\n\n使用GLL求积，一维质量矩阵和刚度矩阵分别为 $M_{\\mathrm{1D}} = \\mathrm{diag}(w)$ 和 $S_{\\mathrm{1D}} = D^\\top M_{\\mathrm{1D}} D$，其中 $w$ 是GLL权重的向量。这些是大小为 $(p+1) \\times (p+1)$ 的矩阵。\n\n为了强制施加齐次Dirichlet边界条件，我们将问题限制在与内部节点相关的基函数上。这对应于取内部节点的子矩阵，其索引从 $1$ 到 $p-1$。设 $M$ 和 $S$ 是这些大小为 $(p-1) \\times (p-1)$ 的内部矩阵。那么，内部自由度的二维刚度算子 $A$ 由Kronecker和给出：\n$$\nA = S \\otimes M + M \\otimes S\n$$\n这个细网格算子 $A$ 是为细网格多项式次数 $p_{\\mathrm{f}}$ 构建的。\n\n双网格方法需要一个从粗网格映射到细网格的延长算子 $P$。在这里，粗网格对应于一个较低的多项式次数 $p_{\\mathrm{c}} = \\max(2, \\lfloor p_{\\mathrm{f}}/2 \\rfloor)$。该延长算子从 $(p_c-1)^2$ 个粗网格内部自由度的空间映射到 $(p_f-1)^2$ 个细网格内部自由度的空间。\n\n比较了两种延长策略：\n\n1.  **保持张量积的延长 ($P_{\\mathrm{tensor}}$)**：此算子由一维插值算子 $P_1$ 构建，并保持网格的张量积结构。$P_1$ 是一个大小为 $(p_{\\mathrm{f}}-1) \\times (p_{\\mathrm{c}}-1)$ 的矩阵，其元素通过在细网格内部节点位置上评估与粗网格内部节点相关联的粗网格Lagrange基函数来得到。然后，二维延长算子为 $P_{\\mathrm{tensor}} = P_1 \\otimes P_1$。\n\n2.  **朴素逐点延长 ($P_{\\mathrm{naive}}$)**：这是一种纯代数方法，忽略了网格的张量结构。对于每个细网格内部节点 $(x_i, y_j)$，我们在欧几里得度量下找到唯一的最近粗网格内部节点 $(\\hat{x}_\\alpha, \\hat{y}_\\beta)$。延长矩阵 $P_{\\mathrm{naive}}$ 中相应的行在对应于粗网格自由度 $(\\alpha, \\beta)$ 的列中包含一个值为 $1$ 的非零项。\n\n双网格方法有一次前平滑和一次后平滑步骤，使用加权Jacobi平滑子 $S_\\omega = I - \\omega D_A^{-1} A$，其中 $D_A$ 是 $A$ 的对角线。最优权重 $\\omega^\\star$ 的选择是为了最小化Jacobi迭代算子的谱半径：\n$$\n\\omega^\\star = \\frac{2}{\\lambda_{\\min}(D_A^{-1/2} A D_A^{-1/2}) + \\lambda_{\\max}(D_A^{-1/2} A D_A^{-1/2})}\n$$\n限制算子是延长算子的转置，$R = P^\\top$，粗网格算子通过Galerkin积 $A_{\\mathrm{c}} = R A P$ 形成。双网格误差传播算子由以下公式给出：\n$$\nE = S_{\\omega^\\star} \\left(I - P A_{\\mathrm{c}}^{-1} R A\\right) S_{\\omega^\\star}\n$$\n该方法的有效性由收敛因子来衡量，即此算子的谱半径 $\\rho(E)$。\n\n核心任务是，对于测试套件 $\\{4, 6, 8, 12\\}$ 中的每个 $p_{\\mathrm{f}}$，计算比率 $r = \\rho(E_{\\mathrm{naive}})/\\rho(E_{\\mathrm{tensor}})$，其中 $E_{\\mathrm{naive}}$ 和 $E_{\\mathrm{tensor}}$ 分别是使用 $P_{\\mathrm{naive}}$ 和 $P_{\\mathrm{tensor}}$ 构建的误差传播算子。该比率量化了使用保持离散化底层结构的延长算子所带来的性能增益。\n\n对于每个 $p_{\\mathrm{f}}$，计算过程如下：\n1.  确定 $p_{\\mathrm{c}} = \\max(2, \\lfloor p_{\\mathrm{f}}/2 \\rfloor)$。\n2.  计算次数为 $p_{\\mathrm{f}}$ 和 $p_{\\mathrm{c}}$ 的GLL节点和权重。\n3.  对于次数 $p_{\\mathrm{f}}$，组装一维内部矩阵 $M$ 和 $S$，然后构成二维细网格刚度矩阵 $A$。\n4.  构建两个延长矩阵，$P_{\\mathrm{tensor}}$ 和 $P_{\\mathrm{naive}}$。\n5.  根据缩放矩阵 $D_A^{-1/2} A D_A^{-1/2}$ 的特征值计算最优Jacobi权重 $\\omega^\\star$。\n6.  对于每个延长矩阵 $P$，组装相应的误差传播矩阵 $E$ 并计算其谱半径 $\\rho(E)$。\n7.  计算谱半径的比率 $r$。\n\n对所有指定的 $p_{\\mathrm{f}}$ 值系统地执行此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_jacobi, legendre\n\ndef get_gll_nodes_weights(p):\n    \"\"\"\n    Computes Gauss-Lobatto-Legendre (GLL) nodes and weights for a given polynomial degree p.\n    \"\"\"\n    if p == 0:\n        return np.array([0.0]), np.array([2.0])\n    if p == 1:\n        return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n    \n    # Interior nodes are roots of P_p'(x) which are roots of Jacobi poly P_{p-1}^{(1,1)}(x)\n    interior_nodes, _ = roots_jacobi(p - 1, 1, 1)\n    nodes = np.concatenate(([-1.0], np.sort(interior_nodes), [1.0]))\n    \n    # Weights using the formula w_i = 2 / (p(p+1) * [P_p(x_i)]^2)\n    poly = legendre(p)\n    weights = 2.0 / (p * (p + 1) * (poly(nodes))**2)\n    \n    return nodes, weights\n\ndef get_diff_matrix(nodes):\n    \"\"\"\n    Computes the 1D differentiation matrix for a given set of nodes.\n    \"\"\"\n    n = len(nodes)\n    D = np.zeros((n, n))\n    \n    # Using the formula D_ij = (alpha_j/alpha_i) / (x_i-x_j)\n    # This is equivalent to c_i / (c_j * (x_i-x_j)) where c_k = prod_{m!=k}(x_k-x_m).\n    # This avoids calculating alpha_k which can be very small or large.\n    c = np.ones(n)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                c[i] *= (nodes[i] - nodes[j])\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                D[i, j] = (c[i] / c[j]) / (nodes[i] - nodes[j])\n    \n    # Diagonal entries from row-sum-to-zero property (D * 1 = 0)\n    for i in range(n):\n        D[i, i] = -np.sum(D[i, :])\n        \n    return D\n\ndef barycentric_lagrange_eval(eval_points, basis_nodes):\n    \"\"\"\n    Evaluates Lagrange basis polynomials defined on `basis_nodes` at `eval_points`.\n    Returns matrix L where L[i, j] = l_j(eval_points[i]).\n    \"\"\"\n    n_eval = len(eval_points)\n    n_basis = len(basis_nodes)\n    L = np.zeros((n_eval, n_basis))\n\n    # Barycentric weights for basis_nodes, alpha_j = 1 / product(x_j - x_k)\n    bary_weights = np.ones(n_basis)\n    for j in range(n_basis):\n        for k in range(n_basis):\n            if j != k:\n                bary_weights[j] /= (basis_nodes[j] - basis_nodes[k])\n\n    for i, x in enumerate(eval_points):\n        # Check if x is one of the basis nodes\n        match_indices = np.where(np.isclose(x, basis_nodes))\n        if len(match_indices[0]) > 0:\n            L[i, match_indices[0][0]] = 1.0\n            continue\n        \n        # Barycentric formula: l_j(x) = (w_j / (x-x_j)) / sum_k(w_k / (x-x_k))\n        terms = bary_weights / (x - basis_nodes)\n        L[i, :] = terms / np.sum(terms)\n        \n    return L\n\ndef compute_convergence_ratio(p_f):\n    \"\"\"\n    Computes the ratio of convergence factors for naive vs. tensor-product prolongation.\n    \"\"\"\n    p_c = max(2, p_f // 2)\n\n    # 1. GLL data for fine and coarse grids\n    x_f, w_f = get_gll_nodes_weights(p_f)\n    x_c, _ = get_gll_nodes_weights(p_c)\n    \n    x_f_int, x_c_int = x_f[1:-1], x_c[1:-1]\n    n_f_int_1d, n_c_int_1d = len(x_f_int), len(x_c_int)\n\n    # 2. 1D fine-grid matrices (interior)\n    D_f_full = get_diff_matrix(x_f)\n    M_f_full = np.diag(w_f)\n    S_f_full = D_f_full.T @ M_f_full @ D_f_full\n    \n    M_f_int = M_f_full[1:-1, 1:-1]\n    S_f_int = S_f_full[1:-1, 1:-1]\n\n    # 3. 2D fine-grid stiffness matrix A\n    A = np.kron(S_f_int, M_f_int) + np.kron(M_f_int, S_f_int)\n    n_A = A.shape[0]\n\n    # 4a. Tensor-preserving prolongation P_tensor\n    # P1 maps from coarse interior basis to fine interior nodes\n    L_eval = barycentric_lagrange_eval(x_f_int, x_c)\n    P1 = L_eval[:, 1:-1]  # Select columns for interior coarse basis functions\n    P_tensor = np.kron(P1, P1)\n\n    # 4b. Naive pointwise prolongation P_naive\n    P_naive = np.zeros((n_f_int_1d**2, n_c_int_1d**2))\n    \n    fine_nodes_2d = np.array(np.meshgrid(x_f_int, x_f_int)).T.reshape(-1, 2)\n    coarse_nodes_2d = np.array(np.meshgrid(x_c_int, x_c_int)).T.reshape(-1, 2)\n    \n    for i, f_node in enumerate(fine_nodes_2d):\n        dists_sq = np.sum((coarse_nodes_2d - f_node)**2, axis=1)\n        j_min = np.argmin(dists_sq)\n        P_naive[i, j_min] = 1.0\n\n    # 5. Two-grid analysis\n    # Optimal Jacobi weight (same for both P)\n    A_diag = np.diag(A)\n    # The matrix A is SPD, so its diagonal is positive.\n    D_inv_sqrt = np.diag(1.0 / np.sqrt(A_diag))\n    A_scaled = D_inv_sqrt @ A @ D_inv_sqrt\n    eigvals_scaled = np.linalg.eigh(A_scaled)[0]\n    omega_opt = 2.0 / (np.min(eigvals_scaled) + np.max(eigvals_scaled))\n    \n    # Smoother matrix\n    S_omega = np.eye(n_A) - omega_opt * np.diag(1.0 / A_diag) @ A\n    \n    rhos = {}\n    for name, P in [(\"tensor\", P_tensor), (\"naive\", P_naive)]:\n        R = P.T\n        A_c = R @ A @ P\n        \n        # Check for singularity of coarse operator\n        if np.linalg.cond(A_c) > 1/np.finfo(A_c.dtype).eps:\n            # For P_naive, A_c can be singular if some coarse nodes are not targeted\n            # by any fine node, making columns of P zero. Use pseudoinverse.\n            A_c_inv = np.linalg.pinv(A_c)\n        else:\n            A_c_inv = np.linalg.inv(A_c)\n\n        # Two-grid error propagation operator\n        CGC = np.eye(n_A) - P @ A_c_inv @ R @ A\n        E = S_omega @ CGC @ S_omega\n        \n        # Spectral radius\n        rho = np.max(np.abs(np.linalg.eigvals(E)))\n        rhos[name] = rho\n        \n    return rhos[\"naive\"] / rhos[\"tensor\"]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [4, 6, 8, 12]\n\n    results = []\n    for p_f in test_cases:\n        ratio = compute_convergence_ratio(p_f)\n        results.append(round(ratio, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3362994"}]}