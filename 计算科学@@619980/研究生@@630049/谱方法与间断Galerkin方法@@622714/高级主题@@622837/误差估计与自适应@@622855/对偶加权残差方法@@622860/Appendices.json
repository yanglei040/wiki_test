{"hands_on_practices": [{"introduction": "我们从一个基础练习开始，旨在具体化对偶加权残差（DWR）方法的核心机制。这个练习的核心任务是，利用给定的单元残差和伴随解（或称对偶解）的采样值，计算每个单元对目标泛函误差的贡献。通过这个直接的计算和排序过程，您可以亲身体验DWR方法如何识别和量化局部误差，并据此确定自适应网格细化的优先顺序，这是目标导向自适应方法的基础。[@problem_id:3514494]", "problem": "考虑一个用于线性化多物理场耦合系统有限元方法 (FEM) 离散化的目标导向自适应网格加密 (AMR) 程序，其中我们关心一个标量输出泛函 $J(u)$。设 $u$ 为精确解，$u_{h}$ 为离散解。在对偶加权残差 (DWR) 框架中，$J(u)$ 误差的带符号单元贡献是通过伴随（对偶）解的样本对单元残差进行加权来确定的，该伴随解解析了 $J(u)$ 对 $u$ 中扰动的敏感性。假设采用协调离散和分段光滑系数，从而使得单元残差在测试空间上能被良好地定义为线性泛函，并且对偶解足够正则，可以按单元进行采样。\n\n给定三个对 $J(u)$ 有贡献的单元 $K=1,2,3$，其单元残差值为 $\\{R_K\\}=\\{1.2, -0.5, 0.8\\}$，对应的采样对偶权重为 $\\{z_{h,K}\\}=\\{0.4, 1.1, 0.2\\}$。在标准 DWR 局部性假设下，通过用每个单元 $K$ 的对偶样本对其残差进行加权来获得其带符号贡献，并通过按其带符号贡献的绝对值降序排序来确定单元的加密优先级。如果出现绝对值完全相等的情况，则优先选择单元索引较小的来打破平局。\n\n计算这三个带符号贡献，并按绝对贡献的降序给出这三个单元索引的排名。将您的最终答案表示为一个包含六个条目的单行矩阵：首先按 $K=1,2,3$ 的顺序列出三个带符号贡献，然后是按要求排名的三个单元索引。无需四舍五入；报告精确的小数值。这些量是无量纲的。", "solution": "用户提供了一个关于使用对偶加权残差 (DWR) 方法进行目标导向自适应网格加密 (AMR) 的问题。\n\n### 第 1 步：提取已知条件\n- **方法论**：使用对偶加权残差 (DWR) 框架对有限元方法 (FEM) 离散化进行目标导向 AMR。\n- **关注量**：一个标量输出泛函 $J(u)$。\n- **单元**：三个索引为 $K=1, 2, 3$ 的单元。\n- **单元残差**：单元残差值集合为 $\\{R_K\\} = \\{1.2, -0.5, 0.8\\}$，其中 $R_1=1.2$，$R_2=-0.5$，且 $R_3=0.8$。\n- **采样对偶权重**：对应的采样对偶权重集合为 $\\{z_{h,K}\\} = \\{0.4, 1.1, 0.2\\}$，其中 $z_{h,1}=0.4$，$z_{h,2}=1.1$，且 $z_{h,3}=0.2$。\n- **误差指示器计算**：每个单元 $K$ 对误差的带符号贡献是通过用其对偶样本对其残差进行加权得到的。将此贡献表示为 $\\eta_K$。因此，$\\eta_K = R_K \\cdot z_{h,K}$。这是基于 DWR 局部性假设。\n- **排序准则**：单元按其带符号贡献的绝对值 $|\\eta_K|$ 的降序进行排名。\n- **平局打破规则**：如果 $|\\eta_K|$ 出现平局，则优先考虑索引 $K$ 较小的单元。\n- **要求输出**：一个包含六个条目的单行矩阵：按顺序排列的三个带符号贡献 $\\eta_1, \\eta_2, \\eta_3$，后跟按加密优先级降序排列的三个单元索引 $K$。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题具有科学依据，因为 DWR 方法是计算工程和科学领域中用于后验误差估计和网格自适应的标准且成熟的技术。该问题是适定的，提供了所有必要的数据（$R_K$，$z_{h,K}$）以及一个清晰、明确的计算和排名程序。语言客观且专业。该问题不违反任何无效标准。它是偏微分方程数值分析中一个关键概念的直接且有效的应用。\n\n### 第 3 步：结论与行动\n问题有效。将提供完整解答。\n\n### 解答\n该问题要求基于 DWR 方法计算三个有限元的带符号误差贡献，并对其进行后续的网格加密排名。\n\n每个单元 $K$ 的带符号贡献（或误差指示器）$\\eta_K$ 由该单元的残差 $R_K$ 与从对偶（伴随）解中采样的相应值 $z_{h,K}$ 的乘积给出。公式为：\n$$\n\\eta_K = R_K \\cdot z_{h,K}\n$$\n\n我们被给予了单元 $K=1, 2, 3$ 的以下值：\n- 对于单元 $K=1$：$R_1 = 1.2$ 且 $z_{h,1} = 0.4$。\n- 对于单元 $K=2$：$R_2 = -0.5$ 且 $z_{h,2} = 1.1$。\n- 对于单元 $K=3$：$R_3 = 0.8$ 且 $z_{h,3} = 0.2$。\n\n首先，我们计算每个单元的带符号贡献 $\\eta_K$。\n\n对于单元 $K=1$：\n$$\n\\eta_1 = R_1 \\cdot z_{h,1} = (1.2) \\cdot (0.4) = 0.48\n$$\n\n对于单元 $K=2$：\n$$\n\\eta_2 = R_2 \\cdot z_{h,2} = (-0.5) \\cdot (1.1) = -0.55\n$$\n\n对于单元 $K=3$：\n$$\n\\eta_3 = R_3 \\cdot z_{h,3} = (0.8) \\cdot (0.2) = 0.16\n$$\n\n按单元索引顺序（$K=1, 2, 3$）的三个带符号贡献是 $\\{0.48, -0.55, 0.16\\}$。\n\n接下来，我们根据加密优先级对单元进行排名。该排名基于这些贡献的绝对值 $|\\eta_K|$，按降序排列。\n\n我们计算每个贡献的绝对值：\n- 对于 $K=1$：$|\\eta_1| = |0.48| = 0.48$。\n- 对于 $K=2$：$|\\eta_2| = |-0.55| = 0.55$。\n- 对于 $K=3$：$|\\eta_3| = |0.16| = 0.16$。\n\n现在，我们按降序对这些绝对值进行排序：\n$$\n0.55 > 0.48 > 0.16\n$$\n这些值对应于以下单元：\n- 最大值 $0.55$ 对应于单元 $K=2$。\n- 第二大值 $0.48$ 对应于单元 $K=1$。\n- 最小值 $0.16$ 对应于单元 $K=3$。\n\n绝对值没有相等的情况，因此不调用平局打破规则。\n\n因此，按加密优先级降序排列的单元索引排名是 $2, 1, 3$。\n\n最终答案要求一个包含六个条目的单行矩阵：三个带符号贡献（$\\eta_1, \\eta_2, \\eta_3$），后跟三个排好序的单元索引。这些条目是：$0.48, -0.55, 0.16, 2, 1, 3$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.48  -0.55  0.16  2  1  3\n\\end{pmatrix}\n}\n$$", "id": "3514494"}, {"introduction": "在理解了基本计算之后，我们通过一个更深入的练习来探索DWR方法的理论基石。在这个实践中，您将为一个一维泊松方程模型问题，手动推导有限元解和精确的伴随解。这个过程将揭示伽辽金正交性（Galerkin Orthogonality）的关键概念，并从根本上阐明为何在DWR方法中，伴随问题必须在一个比原始问题更“丰富”的函数空间中求解，从而得到一个有意义的、非零的误差估计。[@problem_id:3330525]", "problem": "考虑在定义域 $\\Omega=(0,1)$ 上具有齐次狄利克雷边界条件的一维泊松问题，其中，主变量 $u$ 满足强形式 $-u''=f$ 于 $\\Omega$ 内，且 $u(0)=u(1)=0$，源项 $f(x)=1$ 为常数。目标泛函为 $J(u)=\\int_{0}^{1} u\\,dx$。其对应的弱形式为：求 $u\\in H_{0}^{1}(\\Omega)$，使得对于所有 $v\\in H_{0}^{1}(\\Omega)$，有 $\\int_{0}^{1} u' v'\\,dx = \\int_{0}^{1} f v\\,dx$。对偶加权残差(DWR)方法旨在求解由 $J$ 的 Gateaux 导数所诱导的伴随问题，即：求 $z\\in H_{0}^{1}(\\Omega)$，使得对于所有 $v\\in H_{0}^{1}(\\Omega)$，有 $\\int_{0}^{1} v' z'\\,dx = \\int_{0}^{1} v\\,dx$。\n\n在一个包含两个单元 $K_{1}=(0,\\tfrac{1}{2})$ 和 $K_{2}=(\\tfrac{1}{2},1)$ 的均匀网格上，考虑连续有限元(FE)近似解 $u_{h}\\in V_{h}\\subset H_{0}^{1}(\\Omega)$，其中 $V_{h}$ 是在 $x=0$ 和 $x=1$ 处为零的连续分段线性函数空间。离散伴随解 $z_{h}\\in V_{h}$ 可类似地定义为：对于所有 $v_{h}\\in V_{h}$，有 $\\int_{0}^{1} v_{h}' z_{h}'\\,dx = \\int_{0}^{1} v_{h}\\,dx$。对于对偶加权残差，主问题近似解的弱残差为 $R(u_{h})(w):=\\int_{0}^{1} f w\\,dx - \\int_{0}^{1} u_{h}' w'\\,dx$（对任意 $w\\in H_{0}^{1}(\\Omega)$），而单元指示子（使用伴随权重）与分解式 $R(u_{h})(w)=\\sum_{K\\in\\{K_{1},K_{2}\\}} \\Big(\\int_{K} f w\\,dx - \\int_{K} u_{h}' w'\\,dx\\Big)$ 相关联。\n\n任务：\n- 在给定的双单元网格上计算连续有限元解 $u_{h}$。\n- 计算精确伴随解 $z$，并将其用作加密的伴随权重来定义单元指示子 $\\eta_{K}:=\\int_{K} f z\\,dx - \\int_{K} u_{h}' z'\\,dx$（对于 $K\\in\\{K_{1},K_{2}\\}$）。\n- 采用仅加密伴随空间的廉价估计子思想，取全局估计子为 $\\mathcal{E}_{\\text{cheap}}:=\\eta_{K_{1}}+\\eta_{K_{2}}=R(u_{h})(z)$，并计算其值。\n\n最后，从概念上解释当伴随解未被加密（即 $z_{h}\\in V_{h}$）时，$R(u_{h})(z_{h})$ 会发生什么，并将其与仅加密伴随空间的情况进行比较。在您的解释中，简要评论同样的想法如何扩展到非连续伽辽金(DG)方法中，此时单元内部残差 $f+\\nabla\\cdot(\\nabla u_{h})$ 和单元间通量跳跃项将进入指示子。将 $\\mathcal{E}_{\\text{cheap}}$ 的最终数值表示为精确分数，无需四舍五入。", "solution": "该问题陈述经核实具有科学依据，是适定且客观的。它提出了一个使用对偶加权残差(DWR)技术对有限元法进行后验误差分析的标准练习，这是计算科学中的一个核心课题。所有数据和定义均已提供且一致。因此，我们可以着手求解。\n\n求解过程包括三个主要的计算步骤，然后是一个概念性解释。\n\n首先，我们在指定的网格上计算连续分段线性有限元(FE)解 $u_h$。该网格由两个单元 $K_1 = (0, \\frac{1}{2})$ 和 $K_2 = (\\frac{1}{2}, 1)$ 组成。有限元空间 $V_h$ 由在每个单元上呈线性且在定义域边界 $x=0$ 和 $x=1$ 处为零的连续函数构成。这只留下一个自由度，即解在内部节点 $x=\\frac{1}{2}$ 处的值。设 $\\phi(x)$ 为与此节点关联的标准线性“帽子”基函数：\n$$\n\\phi(x) = \\begin{cases}\n2x  \\text{if } x \\in [0, \\frac{1}{2}] \\\\\n2(1-x)  \\text{if } x \\in [\\frac{1}{2}, 1]\n\\end{cases}\n$$\n有限元解 $u_h$ 可写作 $u_h(x) = U \\phi(x)$，其中 $U = u_h(\\frac{1}{2})$ 是待求的未知系数。其导数为 $u_h'(x) = U \\phi'(x)$，其中\n$$\n\\phi'(x) = \\begin{cases}\n2  \\text{if } x \\in (0, \\frac{1}{2}) \\\\\n-2  \\text{if } x \\in (\\frac{1}{2}, 1)\n\\end{cases}\n$$\n未知数 $U$ 通过求解离散弱形式得到，其中 $v_h = \\phi(x)$：\n$$\n\\int_{0}^{1} u_h'(x) \\phi'(x) \\,dx = \\int_{0}^{1} f(x) \\phi(x) \\,dx\n$$\n代入 $u_h'(x) = U \\phi'(x)$ 和 $f(x)=1$，我们得到：\n$$\nU \\int_{0}^{1} (\\phi'(x))^2 \\,dx = \\int_{0}^{1} \\phi(x) \\,dx\n$$\n我们计算积分：\n左侧积分为：\n$$\n\\int_{0}^{1} (\\phi'(x))^2 \\,dx = \\int_{0}^{1/2} (2)^2 \\,dx + \\int_{1/2}^{1} (-2)^2 \\,dx = 4 \\cdot \\frac{1}{2} + 4 \\cdot \\frac{1}{2} = 4\n$$\n右侧积分为：\n$$\n\\int_{0}^{1} \\phi(x) \\,dx = \\int_{0}^{1/2} 2x \\,dx + \\int_{1/2}^{1} 2(1-x) \\,dx = [x^2]_0^{1/2} + [2x - x^2]_{1/2}^1 = \\frac{1}{4} + \\left( (2-1) - (1 - \\frac{1}{4}) \\right) = \\frac{1}{4} + \\frac{1}{4} = \\frac{1}{2}\n$$\n关于 $U$ 的方程变为 $4U = \\frac{1}{2}$，解得 $U = \\frac{1}{8}$。\n因此，有限元解为：\n$$\nu_h(x) = \\frac{1}{8} \\phi(x) = \\begin{cases}\n\\frac{x}{4}  \\text{if } x \\in [0, \\frac{1}{2}] \\\\\n\\frac{1-x}{4}  \\text{if } x \\in [\\frac{1}{2}, 1]\n\\end{cases}\n$$\n其导数为：\n$$\nu_h'(x) = \\begin{cases}\n\\frac{1}{4}  \\text{if } x \\in (0, \\frac{1}{2}) \\\\\n-\\frac{1}{4}  \\text{if } x \\in (\\frac{1}{2}, 1)\n\\end{cases}\n$$\n\n其次，我们计算精确伴随解 $z$。$z$ 的弱形式为 $\\int_{0}^{1} v' z'\\,dx = \\int_{0}^{1} v\\,dx$（对所有 $v\\in H_{0}^{1}(\\Omega)$）。这对应于在 $\\Omega=(0,1)$ 内具有齐次狄利克雷边界条件 $z(0)=z(1)=0$ 的强形式 $-z'' = 1$。两次积分得到 $z(x) = -\\frac{x^2}{2} + C_1 x + C_2$。边界条件 $z(0)=0$ 和 $z(1)=0$ 给出 $C_2=0$ 和 $C_1=\\frac{1}{2}$。精确伴随解为：\n$$\nz(x) = \\frac{x}{2} - \\frac{x^2}{2} = \\frac{1}{2}x(1-x)\n$$\n其导数为 $z'(x) = \\frac{1}{2} - x$。\n\n第三，我们计算单元指示子 $\\eta_K$ 和全局估计子 $\\mathcal{E}_{\\text{cheap}}$。单元 $K$ 的指示子定义为 $\\eta_K = \\int_K f z \\,dx - \\int_K u_h' z' \\,dx$。\n\n对于单元 $K_1 = (0, \\frac{1}{2})$：\n$$\n\\eta_{K_1} = \\int_{0}^{1/2} (1) \\left(\\frac{x}{2} - \\frac{x^2}{2}\\right) \\,dx - \\int_{0}^{1/2} \\left(\\frac{1}{4}\\right) \\left(\\frac{1}{2} - x\\right) \\,dx\n$$\n第一个积分为 $\\frac{1}{2} [\\frac{x^2}{2} - \\frac{x^3}{3}]_0^{1/2} = \\frac{1}{2} \\left(\\frac{1}{8} - \\frac{1}{24}\\right) = \\frac{1}{2} \\left(\\frac{2}{24}\\right) = \\frac{1}{24}$。\n第二个积分为 $\\frac{1}{4} [\\frac{x}{2} - \\frac{x^2}{2}]_0^{1/2} = \\frac{1}{4} \\left(\\frac{1}{4} - \\frac{1}{8}\\right) = \\frac{1}{4} \\left(\\frac{1}{8}\\right) = \\frac{1}{32}$。\n所以，$\\eta_{K_1} = \\frac{1}{24} - \\frac{1}{32} = \\frac{4-3}{96} = \\frac{1}{96}$。\n\n对于单元 $K_2 = (\\frac{1}{2}, 1)$：\n$$\n\\eta_{K_2} = \\int_{1/2}^{1} (1) \\left(\\frac{x}{2} - \\frac{x^2}{2}\\right) \\,dx - \\int_{1/2}^{1} \\left(-\\frac{1}{4}\\right) \\left(\\frac{1}{2} - x\\right) \\,dx\n$$\n第一个积分为 $\\frac{1}{2} [\\frac{x^2}{2} - \\frac{x^3}{3}]_{1/2}^{1} = \\frac{1}{2} \\left[ \\left(\\frac{1}{2} - \\frac{1}{3}\\right) - \\left(\\frac{1}{8} - \\frac{1}{24}\\right) \\right] = \\frac{1}{2} \\left[ \\frac{1}{6} - \\frac{2}{24} \\right] = \\frac{1}{2} \\left[ \\frac{1}{6} - \\frac{1}{12} \\right] = \\frac{1}{24}$。\n第二个积分为 $\\frac{1}{4} \\int_{1/2}^{1} \\left(x - \\frac{1}{2}\\right) \\,dx = \\frac{1}{4} [\\frac{x^2}{2} - \\frac{x}{2}]_{1/2}^{1} = \\frac{1}{4} \\left[ \\left(\\frac{1}{2} - \\frac{1}{2}\\right) - \\left(\\frac{1}{8} - \\frac{1}{4}\\right) \\right] = \\frac{1}{4} \\left[ - \\left(-\\frac{1}{8}\\right) \\right] = \\frac{1}{32}$。\n所以，$\\eta_{K_2} = \\frac{1}{24} - \\frac{1}{32} = \\frac{4-3}{96} = \\frac{1}{96}$。\n\n全局估计子是单元指示子之和：\n$$\n\\mathcal{E}_{\\text{cheap}} = \\eta_{K_1} + \\eta_{K_2} = \\frac{1}{96} + \\frac{1}{96} = \\frac{2}{96} = \\frac{1}{48}\n$$\n\n最后，我们提供概念性解释。弱残差定义为 $R(u_{h})(w) = \\int_{0}^{1} f w\\,dx - \\int_{0}^{1} u_{h}' w'\\,dx$。有限元解 $u_h \\in V_h$ 的定义恰好是对于任何测试函数 $v_h \\in V_h$，该残差为零。此性质被称为伽辽金正交性。如果伴随近似解 $z_h$ 与主问题近似解 $u_h$ 在同一空间 $V_h$ 中求解（即，不进行加密），则 $z_h$ 是主问题的一个有效测试函数。因此，$R(u_h)(z_h) = 0$。基于 $R(u_h)(z_h)$ 的误差估计子将始终为零，无论实际误差大小，这使其对于自适应或误差量化毫无用处。\n\n这凸显了DWR方法的核心原则：为了获得一个非零且有意义的误差估计，伴随问题必须在一个比主问题有限元空间 $V_h$ 更“丰富”的空间中进行近似。通过“加密”伴随空间（例如，使用更高阶的多项式或更细的网格），我们得到一个不在 $V_h$ 中的近似伴随解 $z_{h, \\text{rich}}$。残差 $R(u_h)(z_{h, \\text{rich}})$ 此时非零，并提供了目标泛函误差 $J(u) - J(u_h)$ 的一个估计。在本问题中，我们使用精确解 $z$ 作为加密的最终形式。DWR理论的一个关键结果指出，泛函的精确误差恰好是用精确伴随误差加权的残差，即 $J(u)-J(u_h) = R(u_h)(z-z_h)$。由于 $R(u_h)(z_h)=0$，这可以简化为 $J(u)-J(u_h) = R(u_h)(z)$。因此，我们的计算结果 $\\mathcal{E}_{\\text{cheap}} = R(u_h)(z) = \\frac{1}{48}$ 不是一个估计值，而是目标泛函的精确误差。\n\n这个概念可以直接推广到非连续伽辽金(DG)方法。在DG设定中，解空间允许在单元交界面上存在不连续性。相应的弱形式不仅包括单元内部的积分，还包括单元交界面上的积分（通量项），用以惩罚跳跃。分部积分后，DG方法的单元DWR指示子 $\\eta_K$ 将包含来自单元内部残差（例如 $f + \\Delta_h u_h$）和单元间跳跃残差（例如 $u_h$ 的值或法向通量的跳跃）的贡献。与连续情况一样，伽辽金正交性确保了如果伴随测试函数选自与主问题解相同的DG空间，那么所有这些加权残差之和为零。因此，在DG背景下，加密伴随空间对于获得一个非平凡且有效的、用以驱动自适应网格加密的误差估计子同样至关重要。", "answer": "$$\n\\boxed{\\frac{1}{48}}\n$$", "id": "3330525"}, {"introduction": "最后一个练习是一个更高级的数值实验，挑战一个常见的误解：“大的局部残差必然导致大的目标误差”。通过构建一个特殊的场景，您将观察到即使在局部残差很大的情况下，如果残差的结构与伴随解的结构“失配”（例如，在频谱上正交），其对目标泛函的全局误差贡献也可能因抵消而变得微不足道。这个练习将极大地加深您对DWR方法精髓的理解——它不仅关注残差的大小，更关注残差与伴随解所代表的“敏感性”之间的相关性。[@problem_id:3381923]", "problem": "考虑区间 $[0,1]$ 上的齐次狄利克雷边界条件的一维稳态椭圆边值问题：求精确解 $u$，使得\n$$\n-\\frac{d^2 u}{dx^2} = f \\quad \\text{在 } (0,1) \\text{ 内}, \\qquad u(0)=u(1)=0,\n$$\n其中源项 $f$ 由预设的精确解 $u$ 通过算子 $L u = -u'' = f$ 导出。设目标量为线性泛函\n$$\nJ(u) = \\int_0^1 \\psi(x)\\,u(x)\\,dx,\n$$\n其中 $\\psi$ 是给定的权重函数。对偶加权残差 (Dual Weighted Residual, DWR) 方法通过求解权重 $z$ 的伴随 (对偶) 问题来评估 $J$ 中的误差，该问题定义为\n$$\n-\\frac{d^2 z}{dx^2} = \\psi(x) \\quad \\text{在 } (0,1) \\text{ 内}, \\qquad z(0)=z(1)=0.\n$$\n在间断伽辽金方法中，将域划分为单元 $\\{K\\}$，单元残差 $R_K$ 是原始残差 $R = L(u_h) - f$ 在 $K$ 上的限制，其中 $u_h$ 是 $u$ 的一个近似解。DWR 误差表示汇集了局部加权贡献 $\\langle R_K, z\\rangle = \\int_K R(x)\\,z(x)\\,dx$。您的任务是构建并量化一个场景，该场景表现出大的局部残差 $R_K$ 但伴随权重 $z$ 很小，导致在全局总和 $\\sum_K \\langle R_K, z\\rangle$ 中出现近乎抵消，然后解释 $J(u)$ 中误差可忽略不计的机制。\n\n您必须实现一个与上述模型一致的谱构造和单元汇集。请使用以下设置。\n\n1. 域和算子：\n   - 域为 $[0,1]$。\n   - 算子为 $L = -\\frac{d^2}{dx^2}$，带有齐次狄利克雷边界条件。\n\n2. 精确解 $u$：\n   - 通过满足边界条件的有限正弦级数定义 $u(x)$：\n     $$\n     u(x) = \\sum_{n\\in \\{1,2,10,15\\}} a_n \\sin(n\\pi x),\n     $$\n     系数为 $a_1=0.5$, $a_2=0.3$, $a_{10}=1.0$, $a_{15}=0.8$。\n   - 源项 $f$ 于是为 $f(x) = \\sum_{n\\in \\{1,2,10,15\\}} (n\\pi)^2 a_n \\sin(n\\pi x)$。\n\n3. 近似解 $u_h$ (欠分辨率谱离散)：\n   - 通过截断和扰动低频来定义 $u_h(x)$：\n     $$\n     u_h(x) = \\sum_{n\\in \\{1,2\\}} b_n \\sin(n\\pi x),\n     $$\n     系数为 $b_1=0.48$, $b_2=0.28$。\n\n4. 残差和伴随问题：\n   - 定义原始残差 $R(x) = L(u_h)(x) - f(x) = -u_h''(x) - f(x)$。\n   - 对每个测试案例，求解伴随问题 $-z'' = \\psi$，$z(0)=z(1)=0$。您将使用与所选 $\\psi$ 对应的 $z$ 的闭式解。\n\n5. 单元汇集：\n   - 将 $[0,1]$ 划分为 $N_{\\mathrm{el}}=20$ 个单元 $K_j = \\left[\\frac{j}{N_{\\mathrm{el}}}, \\frac{j+1}{N_{\\mathrm{el}}}\\right]$, $j=0,\\dots,19$。\n   - 对每个单元 $K$，使用每个单元 $Q=100$ 个点的高斯求积计算 $\\langle R_K, z\\rangle = \\int_K R(x)\\,z(x)\\,dx$。\n   - 计算全局加权残差总和 $E = \\sum_K \\langle R_K, z\\rangle$。\n   - 计算局部贡献的总量级 $S = \\sum_K \\left|\\langle R_K, z\\rangle\\right|$。\n   - 定义抵消比 $C = \\frac{|E|}{S}$，约定当 $S=0$ 时 $C=0$。\n\n6. 目标量误差：\n   - 通过在 $[0,1]$ 上使用足够精确的高斯求积（使用 $Q_{\\mathrm{global}}=2000$ 个点）计算 $J(u)-J(u_h)$。对于自伴算子和齐次边界条件，这为加权残差总和 $E$ 提供了一个独立的检验。\n\n7. 测试套件：\n   - 案例1 (低频权重加一个微小的高频扰动)：$\\psi_1(x) = \\sin(\\pi x) + \\alpha \\sin(10\\pi x)$，其中 $\\alpha = 0.01$。\n     预期的机制是 $R$ 的高频分量与 $z$ 弱对齐，因此局部贡献的符号会振荡并大部分抵消，而微小的低频不匹配则驱动一个小的净误差。\n   - 案例2 (与残差匹配的高频权重)：$\\psi_2(x) = \\sin(10\\pi x)$。\n     预期的机制是 $z$ 匹配 $u_h$ 中缺失的主要模式，因此局部贡献会相长地相加，导致一个大误差和最小的抵消。\n   - 案例3 (光滑非振荡权重)：$\\psi_3(x) = 1$ (常数函数)。\n     在这种情况下，$z(x)$ 是一个二次光滑函数。预期的机制是 $R$ 快速振荡，其与光滑的 $z$ 的乘积在局部被平均掉，产生强烈的抵消和一个可忽略的净误差。\n\n8. 输出要求：\n   - 对每个测试案例，计算两个浮点数：DWR 误差 $E$ 和抵消比 $C$。\n   - 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表中的六个结果，顺序为 $[E_1,C_1,E_2,C_2,E_3,C_3]$，其中 $E_i$ 和 $C_i$ 对应于测试案例 $i=1,2,3$。\n\n所有量都是无量纲的；不涉及物理单位。在适用的情况下，角度以弧度为单位。请确保使用指定的求积阶数和单元划分，以保证数值稳定性和准确性。该场景必须是科学上现实的，并从上面提供的基本设置中导出。实现程序时，应使其完全自包含，不需要任何输入，并遵守输出规范。", "solution": "该问题被评估为有效，因为它在科学上基于数值分析和后验误差估计的原理，问题本身是适定的，提供了所有必要信息，并且表述客观。所提供的设置是一个自洽且定义明确的数值实验，用于演示对偶加权残差 (DWR) 方法的机制。\n\n解决方案如下。首先，我们建立所有相关函数的解析形式：精确解 $u$、近似解 $u_h$、由此产生的残差 $R$，以及每个测试案例的对偶解 $z$。其次，我们描述了计算单元加权残差并将其汇集以求得总估计误差 $E$ 和抵消比 $C$ 的数值过程。最后，我们分析每个测试案例，将函数的数学结构与预期的数值结果联系起来。\n\n**1. 解析框架**\n\n问题围绕区间 $[0,1]$ 上的齐次狄利克雷边界条件的一维泊松方程展开：\n$$\nL u = -\\frac{d^2 u}{dx^2} = f(x) \\quad \\text{对于 } x \\in (0,1), \\quad u(0)=u(1)=0.\n$$\n目标量是一个线性泛函 $J(u) = \\int_0^1 \\psi(x) u(x) dx$。相关的对偶 (或伴随) 问题由下式给出：\n$$\nL^* z = -\\frac{d^2 z}{dx^2} = \\psi(x) \\quad \\text{对于 } x \\in (0,1), \\quad z(0)=z(1)=0.\n$$\n由于带有这些边界条件的算子 $L$ 是自伴的 ($L^*=L$)，目标量的误差 $J(u) - J(u_h)$ 可以与原始残差 $R(x)$ 和对偶解 $z(x)$ 相关联。令 $e(x) = u(x) - u_h(x)$ 为近似误差。\n$$\nJ(u) - J(u_h) = J(e) = \\int_0^1 \\psi(x) e(x) dx = \\int_0^1 (-z''(x)) e(x) dx.\n$$\n使用分部积分两次，并利用 $e$ 和 $z$ 的齐次边界条件，可得：\n$$\nJ(e) = \\int_0^1 z(x) (-e''(x)) dx = \\int_0^1 z(x) (-u''(x) + u_h''(x)) dx.\n$$\n使用 $-u''(x)=f(x)$，这变为：\n$$\nJ(e) = \\int_0^1 z(x) (f(x) + u_h''(x)) dx = - \\int_0^1 z(x) (-u_h''(x) - f(x)) dx.\n$$\n问题将原始残差定义为 $R(x) = L(u_h)(x) - f(x) = -u_h''(x) - f(x)$。因此，精确的误差表示为：\n$$\nJ(u) - J(u_h) = -\\int_0^1 R(x) z(x) dx.\n$$\n问题要求计算量 $E = \\sum_K \\langle R_K, z \\rangle = \\int_0^1 R(x) z(x) dx$。因此，$E$ 代表目标量误差的负值，即 $E = -(J(u)-J(u_h))$。在整个计算过程中都遵循此符号约定。\n\n**2. 函数定义**\n\n- **精确解 $u(x)$**：\n  $u(x) = \\sum_{n \\in \\{1,2,10,15\\}} a_n \\sin(n\\pi x)$，系数为 $a_1=0.5$, $a_2=0.3$, $a_{10}=1.0$, $a_{15}=0.8$。\n  $$u(x) = 0.5 \\sin(\\pi x) + 0.3 \\sin(2\\pi x) + 1.0 \\sin(10\\pi x) + 0.8 \\sin(15\\pi x)$$\n\n- **源项 $f(x)$**：\n  $f(x) = -u''(x) = \\sum_{n \\in \\{1,2,10,15\\}} (n\\pi)^2 a_n \\sin(n\\pi x)$。\n\n- **近似解 $u_h(x)$**：\n  $u_h(x) = \\sum_{n \\in \\{1,2\\}} b_n \\sin(n\\pi x)$，系数为 $b_1=0.48$, $b_2=0.28$。\n  $$u_h(x) = 0.48 \\sin(\\pi x) + 0.28 \\sin(2\\pi x)$$\n\n- **原始残差 $R(x)$**：\n  $R(x) = -u_h''(x) - f(x) = \\sum_{n \\in \\{1,2\\}} (n\\pi)^2 (b_n - a_n) \\sin(n\\pi x) - \\sum_{n \\in \\{10,15\\}} (n\\pi)^2 a_n \\sin(n\\pi x)$。\n  代入系数：\n  $$R(x) = -(0.02)\\pi^2\\sin(\\pi x) - (0.02)(2\\pi)^2\\sin(2\\pi x) - (1.0)(10\\pi)^2\\sin(10\\pi x) - (0.8)(15\\pi)^2\\sin(15\\pi x)$$\n  残差由小振幅、低频的模式（源于解的已解析分量的误差）和大振幅、高频的模式（源于未解析分量）组成。\n\n- **对偶解 $z(x)$**：我们对每个案例求解 $-z''=\\psi$ 且 $z(0)=z(1)=0$。对于右端项 $\\sin(k\\pi x)$，解为 $z(x) = \\frac{1}{(k\\pi)^2}\\sin(k\\pi x)$。对于 $\\psi=1$，解为 $z(x)=\\frac{x}{2}(1-x)$。\n  - **案例1**：$\\psi_1(x) = \\sin(\\pi x) + 0.01 \\sin(10\\pi x)$\n    $$z_1(x) = \\frac{1}{\\pi^2}\\sin(\\pi x) + \\frac{0.01}{(10\\pi)^2}\\sin(10\\pi x)$$\n  - **案例2**：$\\psi_2(x) = \\sin(10\\pi x)$\n    $$z_2(x) = \\frac{1}{(10\\pi)^2}\\sin(10\\pi x)$$\n  - **案例3**：$\\psi_3(x) = 1$\n    $$z_3(x) = \\frac{x}{2}(1-x)$$\n\n**3. 数值计算与分析**\n\n将域 $[0,1]$ 分为 $N_{\\mathrm{el}}=20$ 个单元 $K_j$。在每个单元上，我们使用具有 $Q=100$ 个点的高斯求积来计算局部加权残差 $\\langle R_K, z \\rangle_j = \\int_{K_j} R(x)z(x)dx$。这些局部值被汇集以形成：\n- 全局加权残差总和：$E = \\sum_{j=0}^{N_{\\mathrm{el}}-1} \\langle R_K, z \\rangle_j$。\n- 局部贡献的总量级：$S = \\sum_{j=0}^{N_{\\mathrm{el}}-1} |\\langle R_K, z \\rangle_j|$。\n- 抵消比：$C = \\frac{|E|}{S}$。\n\n比率 $C$ 衡量了局部加权残差之间的抵消程度。$C \\approx 1$ 的值表示所有局部贡献具有相同的符号并相长地叠加，意味着没有抵消。$C \\ll 1$ 的值表示局部贡献的符号振荡并大部分相互抵消，导致全局误差估计 $|E|$ 远小于局部指示子量级之和 $S$。\n\n- **案例1分析**：对偶解 $z_1(x)$ 由其低频分量主导。残差 $R(x)$ 具有大的高频分量。乘积 $R(x)z_1(x)$ 包含诸如 $\\sin(10\\pi x)\\sin(\\pi x)$ 之类的项，这些项快速振荡。在每个单元上积分时，这些项产生的值很小，并且倾向于在单元之间改变符号，导致在全局总和 $E_1$ 中发生显著抵消。净误差主要由 $R(x)$ 和 $z_1(x)$ 的微小低频部分的乘积决定。因此，我们预期误差 $E_1$ 和抵消比 $C_1$ 都会很小。\n\n- **案例2分析**：对偶解 $z_2(x)$ 是一个单一的高频模式，它直接对应于近似解 $u_h$ 中最大的未解析模式（$\\sin(10\\pi x)$ 项）。被积函数 $R(x)z_2(x)$ 有一个主导项 $-(\\sin(10\\pi x))^2 \\cdot (10\\pi)^2 / (10\\pi)^2 = -\\sin^2(10\\pi x)$。该项在任何地方都是非正的，因此局部积分 $\\langle R_K, z_2 \\rangle_j$ 均为负值。它们相长地叠加。这导致了大的全局误差 $E_2$ 和接近 1 的抵消比 $C_2$。\n\n- **案例3分析**：对偶解 $z_3(x)$ 是一个光滑、非振荡的二次函数。残差 $R(x)$ 是高度振荡的。乘积 $R(x)z_3(x)$ 是一个由 $z_3(x)$ 的光滑形状调制的快速振荡函数。在每个单元上，由于局部平均效应，该乘积的积分趋于很小。此外，由于 $R(x)$ 中模式的相位演进，这些微小局部积分的符号很可能在单元边界处翻转。这导致了强烈的全局抵消。我们预期误差 $E_3$ 很小，抵消比 $C_3$ 非常小。\n\n以下 Python 代码实现了此过程，以计算每个案例的 $E$ 和 $C$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes DWR error estimates and cancellation ratios for three test cases\n    of a 1D elliptic problem.\n    \"\"\"\n    # 1. Setup of problem parameters and analytical functions\n\n    # Coefficients for exact solution u(x)\n    a_coeffs = {1: 0.5, 2: 0.3, 10: 1.0, 15: 0.8}\n    # Coefficients for approximate solution u_h(x)\n    b_coeffs = {1: 0.48, 2: 0.28}\n\n    # Numerical parameters\n    N_el = 20  # Number of elements\n    Q = 100    # Quadrature points per element\n\n    # Define the residual function R(x) = -u_h''(x) - f(x)\n    # R(x) = sum_{n} (n*pi)^2 * (b_n - a_n) * sin(n*pi*x)\n    # Note: b_n is zero for n=10, 15\n    def R_func(x):\n        res = 0.0\n        pi = np.pi\n        \n        # Low frequency errors\n        res += (1 * pi)**2 * (b_coeffs[1] - a_coeffs[1]) * np.sin(1 * pi * x)\n        res += (2 * pi)**2 * (b_coeffs[2] - a_coeffs[2]) * np.sin(2 * pi * x)\n        \n        # High frequency (unresolved) errors\n        res += (10 * pi)**2 * (0 - a_coeffs[10]) * np.sin(10 * pi * x)\n        res += (15 * pi)**2 * (0 - a_coeffs[15]) * np.sin(15 * pi * x)\n        \n        return res\n\n    # Define the dual solutions z(x) for each case\n    pi = np.pi\n    alpha = 0.01\n\n    def z1_func(x):\n        # Corresponds to psi_1(x) = sin(pi*x) + alpha*sin(10*pi*x)\n        return (1 / pi**2) * np.sin(pi * x) + (alpha / (10 * pi)**2) * np.sin(10 * pi * x)\n\n    def z2_func(x):\n        # Corresponds to psi_2(x) = sin(10*pi*x)\n        return (1 / (10 * pi)**2) * np.sin(10 * pi * x)\n\n    def z3_func(x):\n        # Corresponds to psi_3(x) = 1\n        return 0.5 * x * (1 - x)\n\n    test_z_funcs = [z1_func, z2_func, z3_func]\n    \n    # 2. Gaussian Quadrature helper function\n    \n    # Pre-calculate Gauss-Legendre points and weights for [-1, 1]\n    gauss_points, gauss_weights = np.polynomial.legendre.leggauss(Q)\n\n    def gauss_quadrature(func, a, b):\n        \"\"\"\n        Integrates a function from a to b using pre-calculated Gauss points.\n        \"\"\"\n        # Map points from [-1, 1] to [a, b]\n        mapped_points = 0.5 * (b - a) * gauss_points + 0.5 * (a + b)\n        \n        # Evaluate the function at mapped points\n        func_vals = func(mapped_points)\n        \n        # Compute the integral\n        integral = 0.5 * (b - a) * np.sum(gauss_weights * func_vals)\n        return integral\n\n    # 3. Main computation loop for each test case\n    \n    results = []\n    \n    for z_func in test_z_funcs:\n        \n        E = 0.0  # Global weighted residual sum\n        S = 0.0  # Sum of absolute local contributions\n        \n        # Define the integrand for this case\n        integrand = lambda x: R_func(x) * z_func(x)\n        \n        # Loop over elements\n        for j in range(N_el):\n            x_left = j / N_el\n            x_right = (j + 1) / N_el\n            \n            # Compute local weighted residual\n            local_integral = gauss_quadrature(integrand, x_left, x_right)\n            \n            E += local_integral\n            S += np.abs(local_integral)\n            \n        # Compute cancellation ratio\n        # Use a small tolerance for floating point comparison to zero\n        C = np.abs(E) / S if S  1e-15 else 0.0\n        \n        results.extend([E, C])\n\n    # 4. Final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3381923"}]}