{"hands_on_practices": [{"introduction": "理论与实践的结合始于理解数值方法的各个组成部分如何相互作用。对于目标导向误差估计，其核心在于利用伴随解对原始问题的残差进行加权。然而，在实际计算中，为保证数值解的稳定性而引入的标准技术（如斜率限制器）可能会无意中“污染”这个残差，从而影响误差估计的准确性。本练习 [@problem_id:3362322] 提供了一个绝佳的动手实践机会，让您亲手实现一个简单的标量对流问题，并观察常用限制器对误差估计的影响。更重要的是，您将设计并测试一种改进的“伴随保持”限制器，它在抑制振荡的同时，又能保持误差估计值的准确性，从而揭示出在高保真数值模拟中进行精巧权衡的必要性。", "problem": "考虑一维域 $\\Omega = [0,1]$ 上的标量守恒律 $u_t + \\left(f(u)\\right)_x = 0$，其中平流速度为常数 $a > 0$，通量为 $f(u) = a\\,u$，并配备入流边界条件 $u(0,t) = u_{\\mathrm{in}}(t)$ 和在 $x=1$ 处的出流。设目标泛函为 $J\\left(u(T)\\right) = \\int_{0}^{1} u(x,T)\\,dx$。使用从时间 $t^n$ 到 $t^{n+1} = t^n + \\Delta t$ 的单步显式更新，在大小为 $\\Delta x = 1/N$ 的 $N$ 个单元组成的均匀网格上，采用一次多项式分片线性的间断Galerkin (DG) 方法，并在所有面上使用与 $a > 0$ 一致的迎风数值通量。\n\n您必须：\n\n1. 从守恒律出发，推导半离散格式的包含迎风通量的DG弱形式，然后推导与目标泛函 $J\\left(u(T)\\right)$ 相关的伴随方程。描述其终端条件和边界条件。解释在何种简化假设下（例如，周期性边界条件）伴随场 $\\phi(x,t)$ 会是常数。\n\n2. 使用对偶加权残差框架，对从 $t^n$ 到 $t^{n+1}$ 的单步更新进行面向目标的后验误差估计，展示内部项如何伸缩相消，并证明对于常数伴随权重，主阶估计子仅依赖于入流和出流面上的贡献。用出流边界处的左迹和入流边界值来表示该估计子。\n\n3. 分析只作用于单元内斜率同时保持单元平均值的斜率限制器的影响。定性和定量地解释这类限制器如何通过修改出流面迹来扰动基于伴随的估计子。然后，为目标泛函 $J\\left(u\\right) = \\int_{\\Omega} u\\,dx$ 提出一种在主阶上保持对偶残差的斜率限制器设计。您的设计必须：\n   - 精确保持单元平均值。\n   - 以一种相对于无限制重构，在主阶上保持出流面迹不变的方式修改单元内斜率。\n\n4. 实现一个程序，该程序在每个单元上构建分片线性表示 $u_h(x)$，其中：\n   - 单元平均值 $\\bar u_i$ 是通过对给定连续初始场 $u(x)$ 在每个单元上进行数值积分计算得出的。\n   - 无限制斜率 $s_i$ 是通过中心或单边差分从相邻单元平均值计算得出的。\n   - 应用于斜率的经典minmod限制器，以获得 $s_i^{\\mathrm{mm}}$。\n   - 您提出的伴随保持限制器，其产生的斜率 $s_i^{\\mathrm{adj}}$ 在保持 $\\bar u_i$ 不变的同时，在主阶上维持 $x=1$ 处的出流面迹。\n\n在内部面上，当 $a>0$ 时，使用迎风数值通量 $F_{i+1/2} = a\\,u^-_{i+1/2}$，其中 $u^-_{i+1/2}$ 是从单元 $i$ 重构的左迹。在入流边界 $x=0$ 处，设置 $F_{1-1/2} = a\\,u_{\\mathrm{in}}^n$，其中 $u_{\\mathrm{in}}^n$ 取自 $x=0$ 处的连续初始场。在出流边界 $x=1$ 处，使用从最后一个单元重构的 $F_{N+1/2} = a\\,u^-_{N+1/2}$。定义一个时间步长为 $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x/a$ 的更新，其中 $\\mathrm{CFL} = 0.3$。\n\n针对三种斜率选择：无限制斜率 $s_i$、minmod限制的斜率 $s_i^{\\mathrm{mm}}$ 和伴随保持的斜率 $s_i^{\\mathrm{adj}}$，计算在此单步更新上的基于伴随的面向目标的误差估计。该估计子必须从使用常数伴随权重的对偶加权残差中导出，并且必须用时间步长内的边界通量差来表示。\n\n您的程序必须对以下初始场和参数的测试套件评估该估计子：\n- 测试用例A（光滑，理想情况）：$a = 1.0$， $N = 50$， $u(x) = \\sin\\left(2\\pi x\\right)$， $u_{\\mathrm{in}}^n = u(0)$。\n- 测试用例B（间断，限制器激活）：$a = 1.0$， $N = 80$， $u(x) = \\begin{cases} 1, & x  0.7 \\\\ 0,  x \\ge 0.7 \\end{cases}$， $u_{\\mathrm{in}}^n = u(0)$。\n- 测试用例C（尖锐的局部特征）：$a = 2.0$， $N = 60$， $u(x) = \\exp\\left(-100\\,(x - 0.5)^2\\right)$， $u_{\\mathrm{in}}^n = u(0)$。\n\n在整个过程中采用无量纲单位，因为在此设定中涉及的量都是纯数。\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含九个结果，形式为用方括号括起来的逗号分隔列表，顺序如下：\n  $[\\text{A}_{\\mathrm{unlim}}, \\text{A}_{\\mathrm{mm}}, \\text{A}_{\\mathrm{adj}}, \\text{B}_{\\mathrm{unlim}}, \\text{B}_{\\mathrm{mm}}, \\text{B}_{\\mathrm{adj}}, \\text{C}_{\\mathrm{unlim}}, \\text{C}_{\\mathrm{mm}}, \\text{C}_{\\mathrm{adj}}]$，\n  其中每个条目是对应情况和斜率选择的基于伴随的估计子，表示为浮点数。", "solution": "该问题要求对应用于标量线性平流方程的间断Galerkin (DG) 方法，进行关于基于伴随的面向目标的误差估计的多部分理论推导和数值实现。\n\n### 第一部分：DG弱形式和伴随方程\n\n我们从域 $\\Omega = [0,1]$ 上的标量守恒律开始：\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial (a u)}{\\partial x} = 0\n$$\n我们用测试函数 $v_h$ 乘以该方程，并在时空域 $[0,T] \\times \\Omega$ 上积分。通过分部积分，误差 $e=u-u_h$ 与伴随解 $\\phi$ 之间的关系可以表示为：\n$$\nJ(u) - J(u_h) = \\int_0^T \\int_\\Omega R(u_h) \\phi \\,dx\\,dt - \\int_0^T [a e \\phi]_{x=0}^{x=1} \\,dt\n$$\n其中 $R(u_h)$ 是残差，伴随问题定义为：\n$$\n-\\frac{\\partial \\phi}{\\partial t} - a \\frac{\\partial \\phi}{\\partial x} = 0 \\quad \\text{in } \\Omega \\times [0, T)\n$$\n目标泛函 $J(u(T)) = \\int_\\Omega u(x,T) dx$ 确定了伴随问题的终端条件：$\\phi(x,T) = 1$。\n原始问题在 $x=0$ 处有指定的入流条件，而在 $x=1$ 处是出流。因此，误差 $e(1,t)$ 是未知的。为了消除边界积分项中这个未知量，我们必须施加伴随边界条件 $a \\phi(1,t) = 0 \\implies \\phi(1,t) = 0$。\n因此，伴随问题的解是一个沿着特征线 $x+at=\\text{const}$ 从终端和边界传播的波。由于 $\\phi(1,t)=0$，在区域 $x > 1-a(T-t)$ 内 $\\phi(x,t)=0$。在区域 $x  1-a(T-t)$ 内，解由终端条件决定，为 $\\phi(x,t)=1$。因此，对于给定的入流/出流问题，伴随解不是常数。\n\n然而，如果问题具有**周期性边界条件**，则边界项 $\\int_0^T [a e \\phi]_{x=0}^{x=1} \\,dt$ 会因为 $e(0)=e(1)$ 和 $\\phi(0)=\\phi(1)$ 而消失。在这种情况下，不需要施加伴随边界条件。只有终端条件 $\\phi(x,T)=1$。对于方程 $-\\phi_t - a\\phi_x = 0$，唯一的有界解是常数解 $\\phi(x,t)=1$。\n\n### 第二部分：后验误差估计\n\n我们基于常数伴随权重 $\\phi=1$ 推导误差估计子。对于一个守恒格式，总误差的变化率等于边界处真实通量和数值通量之间的不匹配。考虑单步更新中的总质量变化：\n$$\n\\int_\\Omega u_h^{n+1} dx - \\int_\\Omega u_h^n dx = \\sum_i \\Delta x (\\bar{u}_i^{n+1} - \\bar{u}_i^n)\n$$\n对于单步显式DG格式（等价于有限体积），我们有 $\\frac{\\bar{u}_i^{n+1} - \\bar{u}_i^n}{\\Delta t} = -\\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2})$。对所有单元求和：\n$$\n\\sum_i \\Delta x (\\bar{u}_i^{n+1} - \\bar{u}_i^n) = -\\Delta t \\sum_i (F_{i+1/2} - F_{i-1/2})\n$$\n这是一个伸缩相消（ telescoping）和，由于是周期性索引，它在内部面上相消。对于有界域问题，它简化为边界通量：\n$$\n\\sum_i \\Delta x (\\bar{u}_i^{n+1} - \\bar{u}_i^n) = -\\Delta t (F_{N+1/2} - F_{1/2}) = \\Delta t (F_{1/2} - F_{N+1/2})\n$$\n这里的 $F_{1/2}$ 和 $F_{N+1/2}$ 分别是流入和流出边界的数值通量。根据问题描述，$F_{1/2} = a u_{\\mathrm{in}}^n$，$F_{N+1/2} = a u_{N+1/2}^{-,n}$。因此，数值解的总质量在一个时间步内的变化量由流入和流出的净通量决定。\n这个量，即 $\\eta = \\Delta t (F_{1/2} - F_{N+1/2})$，可以被解释为（在常数伴随权重假设下）对目标泛函误差的单步贡献。它直接衡量了该时间步内数值解的非守恒性。\n代入通量表达式，我们得到估计子：\n$$\n\\eta = a \\Delta t (u_{\\mathrm{in}}^n - u_{N+1/2}^{-,n})\n$$\n其中 $u_{N+1/2}^{-,n}$ 是在时间 $t^n$ 时，从最后一个单元 $N$ 的内部重构到出流边界 $x=1$ 的解的值（左迹）。\n\n### 第三部分：斜率限制器的影响\n\n斜率限制器通过修改单元内的斜率 $s_i$ 来工作，同时保持单元平均值 $\\bar{u}_i$ 不变。对于分片线性重构 $u_h(x) = \\bar{u}_i + s_i(x-x_i)$，出流面迹 $u_{N+1/2}^- = u_N^-$ 由最后一个单元的重构决定：\n$$\nu_{N+1/2}^- = \\bar{u}_N + s_N \\frac{\\Delta x}{2}\n$$\n标准限制器（如minmod）会根据相邻单元的平均值来减小 $s_i$ 的大小，以抑制振荡。当它作用于最后一个单元时，它会改变 $s_N$，从而改变 $u_{N+1/2}^-$，并直接扰动误差估计子 $\\eta$。\n\n为了设计一个“伴随保持”的限制器，我们注意到对于常数伴随解，误差估计子仅依赖于边界通量。为了保持估计子不变，我们必须保持出流迹 $u_{N+1/2}^-$ 不变。这意味着我们不应该限制最后一个单元的斜率 $s_N$。\n因此，一个简单的伴随保持限制器设计如下：\n1.  对所有内部单元 $i = 1, \\dots, N-1$，照常应用标准斜率限制器（如minmod）。\n2.  对于出流边界旁的最后一个单元 $i=N$，不应用限制器，即使用无限制的斜率 $s_N^{\\mathrm{adj}} = s_N^{\\mathrm{unlim}}$。\n该设计保持了单元平均值，并且通过保持 $s_N$ 不变，确保了出流迹在主阶上不变，从而使误差估计子 $\\eta$ 与无限制情况下的值相同。\n\n### 第四部分：实现概述\n\n程序按照以下步骤为每个测试用例计算三个误差估计值：\n1.  **初始化**：设置网格（$N, \\Delta x, x_i$）和参数（$a, \\text{CFL}$）。根据初始条件函数 `u_func` 计算每个单元的平均值 $\\bar{u}_i$。\n2.  **计算斜率**：\n    a.  **无限制斜率 $s_i^{\\mathrm{unlim}}$**：使用中心差分计算内部单元的斜率，单边差分计算边界单元的斜率。\n    b.  **Minmod限制斜率 $s_i^{\\mathrm{mm}}$**：对内部斜率应用minmod限制器。\n    c.  **伴随保持斜率 $s_i^{\\mathrm{adj}}$**：将minmod限制应用于除最后一个单元外的所有单元；最后一个单元使用无限制斜率。\n3.  **计算估计子**：对于以上三种斜率 $\\{s_i\\}$：\n    a.  计算时间步长 $\\Delta t = \\text{CFL} \\cdot \\Delta x / a$。\n    b.  从初始条件获取入流值 $u_{\\mathrm{in}}^n = u(0)$。\n    c.  使用最后一个单元的平均值 $\\bar{u}_N$ 和斜率 $s_N$ 计算出流迹：$u_{\\mathrm{outflow\\_trace}} = \\bar{u}_N + s_N (\\Delta x/2)$。\n    d.  根据第二部分推导的公式计算误差估计子：$\\eta = a \\cdot \\Delta t \\cdot (u_{\\mathrm{in}}^n - u_{\\mathrm{outflow\\_trace}})$。\n4.  **输出**：收集所有九个计算出的估计子（3个测试用例 $\\times$ 3种斜率）并按指定格式打印。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to compute adjoint-based goal-oriented error estimates for three different\n    slope limiting strategies across three test cases for a 1D linear advection equation.\n    \"\"\"\n    CFL = 0.3\n\n    test_cases = [\n        # Test Case A (smooth)\n        {'a': 1.0, 'N': 50, 'u_func': lambda x: np.sin(2 * np.pi * x)},\n        # Test Case B (discontinuity)\n        {'a': 1.0, 'N': 80, 'u_func': lambda x: np.where(x  0.7, 1.0, 0.0)},\n        # Test Case C (sharp feature)\n        {'a': 2.0, 'N': 60, 'u_func': lambda x: np.exp(-100 * (x - 0.5)**2)},\n    ]\n\n    results = []\n\n    def minmod(a, b):\n        \"\"\"Standard minmod limiter function.\"\"\"\n        return 0.5 * (np.sign(a) + np.sign(b)) * np.minimum(np.abs(a), np.abs(b))\n\n    for case in test_cases:\n        a = case['a']\n        N = case['N']\n        u_initial = case['u_func']\n\n        # Setup mesh\n        dx = 1.0 / N\n        x_faces = np.linspace(0, 1, N + 1)\n        x_centers = x_faces[:-1] + dx / 2.0\n\n        # Compute cell averages by high-resolution numerical quadrature (100 points per cell)\n        u_bar = np.zeros(N)\n        for i in range(N):\n            quad_points = np.linspace(x_faces[i], x_faces[i+1], 100)\n            u_bar[i] = np.mean(u_initial(quad_points))\n\n        # 1. Compute unlimited slopes\n        s_unlim = np.zeros(N)\n        # One-sided differences at boundaries\n        s_unlim[0] = (u_bar[1] - u_bar[0]) / dx\n        s_unlim[-1] = (u_bar[-1] - u_bar[-2]) / dx\n        # Centered differences for interior\n        for i in range(1, N - 1):\n            s_unlim[i] = (u_bar[i+1] - u_bar[i-1]) / (2 * dx)\n\n        # 2. Compute minmod-limited slopes\n        s_mm = np.zeros(N)\n        # For simplicity, apply one-sided diffs at boundary cells, and minmod to interior\n        s_mm[0] = (u_bar[1] - u_bar[0]) / dx\n        s_mm[-1] = (u_bar[-1] - u_bar[-2]) / dx\n        # Apply minmod limiter to interior slopes\n        for i in range(1, N - 1):\n            delta_plus = (u_bar[i+1] - u_bar[i]) / dx\n            delta_minus = (u_bar[i] - u_bar[i-1]) / dx\n            s_mm[i] = minmod(delta_plus, delta_minus)\n        \n        # 3. Compute adjoint-preserving slopes\n        s_adj = np.copy(s_mm)\n        # Restore the unlimited slope in the last cell\n        s_adj[-1] = s_unlim[-1]\n        \n        # Calculate time step and estimator for each slope set\n        dt = CFL * dx / a\n        u_in = u_initial(0.0)\n\n        slope_sets = [s_unlim, s_mm, s_adj]\n        \n        for slopes in slope_sets:\n            # Reconstructed value at outflow boundary x=1 from cell N\n            u_outflow_trace = u_bar[-1] + slopes[-1] * (dx / 2.0)\n            \n            # Adjoint-based error estimator\n            estimator = a * dt * (u_in - u_outflow_trace)\n            results.append(estimator)\n\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\n\nsolve()\n```", "id": "3362322"}, {"introduction": "在前一个练习的基础上，我们深入探讨一个更为根本的性质：伴随一致性。一个可靠的误差估计量不仅要求数值格式的各个部分协同工作，更要求离散伴随问题在代数上是离散原始问题的真正“伴随”。若此性质不成立，误差估计的理论基础便会动摇。本练习 [@problem_id:3362346] 将我们带入计算流体动力学中一个更贴近实际的场景——线性化欧拉方程，并要求您为不同的数值通量计算“伴随一致性缺陷”。通过这个练习，您将量化地理解为何某些数值通量（如精确矩阵上风格式）在目标导向应用中本质上优于其他格式（如非一致的 Lax-Friedrichs 格式），并体会到理论分析在指导实践中的强大力量。", "problem": "考虑二维线性化欧拉方程，该方程以原始变量写出，用于描述均匀基态周围的小扰动。设扰动向量为 $q = [\\rho, u, v, p]^{\\top}$，其中 $\\rho$ 是密度，$u$ 是 $x$ 方向的速度分量，$v$ 是 $y$ 方向的速度分量，$p$ 是压力。基态为 $(\\rho_0, u_0, v_0, p_0)$，比熱容比 $\\gamma$ 为常数。对于小扰动和均匀基态，该线性化系统可写为\n$$\n\\partial_t q + A_x \\,\\partial_x q + A_y \\,\\partial_y q = 0,\n$$\n其中\n$$\nA_x = \\begin{bmatrix}\nu_0  \\rho_0  0  0 \\\\\n0  u_0  0  \\dfrac{1}{\\rho_0} \\\\\n0  0  u_0  0 \\\\\n0  \\gamma p_0  0  u_0\n\\end{bmatrix}, \\quad\nA_y = \\begin{bmatrix}\nv_0  0  \\rho_0  0 \\\\\n0  v_0  0  0 \\\\\n0  0  v_0  \\dfrac{1}{\\rho_0} \\\\\n0  0  \\gamma p_0  v_0\n\\end{bmatrix}.\n$$\n对于单位法向量为 $n = (n_x,n_y)$ 的一个面，定义\n$$\nA_n = n_x A_x + n_y A_y.\n$$\n你将要考虑用于此线性系统的间断 Galerkin (DG) 方法。DG 界面项需要一个数值通量 $\\widehat{F}(q^{-},q^{+},n)$，该通量是一致且守恒的，其中 $q^{-}$ 和 $q^{+}$ 分别是面上的内部和外部迹。对于线性系统，数值通量会导出一个双线性形式，该形式依赖于 $\\widehat{F}$ 关于其自变量的雅可比矩阵。将通量关于内部状态的雅可比矩阵记为\n$$\nM = \\frac{\\partial \\widehat{F}}{\\partial q^{-}}(q^{-},q^{+},n).\n$$\n\n在基于伴随的目标导向误差估计中，需要考虑与所选泛函相关联的伴随方程。这里，我们关注阻力泛函\n$$\nJ(q) = \\int_{\\Gamma} \\left(p\\,n_x - \\rho\\,u\\,v\\,n_y\\right)\\,ds,\n$$\n该泛函定义在边界部分 $\\Gamma$上，其中 $n$ 是向外的单位法向量。将 $J$ 在均匀基态 $(\\rho_0,u_0,v_0,p_0)$ 附近线性化，得到一阶变分\n$$\n\\delta J = \\int_{\\Gamma} g(n)^{\\top} \\,\\delta q \\, ds,\n$$\n其中边界敏感性向量 $g(n) \\in \\mathbb{R}^4$ 为\n$$\ng(n) = \\begin{bmatrix}\n-\\,u_0\\,v_0\\,n_y \\\\\n-\\,\\rho_0\\,v_0\\,n_y \\\\\n-\\,\\rho_0\\,u_0\\,n_y \\\\\nn_x\n\\end{bmatrix}.\n$$\n线性化系统的伴随方程为 $\\partial_t \\varphi + A_x^{\\top} \\partial_x \\varphi + A_y^{\\top} \\partial_y \\varphi = 0$，其伴随边界数据在 $\\Gamma$ 上与 $g(n)$ 一致。为了使 DG 离散化具有伴随一致性，用于原始问题的数值通量必须导出一个伴随数值通量，该通量关于内部伴随状态 $\\varphi^{-}$ 的雅可比矩阵满足\n$$\nM = \\left( M_{\\text{adj}} \\right)^{\\top}, \\quad \\text{其中} \\quad M_{\\text{adj}} = \\frac{\\partial \\widehat{F}_{\\text{adj}}}{\\partial \\varphi^{-}}(\\varphi^{-},\\varphi^{+},n),\n$$\n并且 $\\widehat{F}_{\\text{adj}}$ 是应用于伴随算子的数值通量，其矩阵为 $A_x^{\\top}$ 和 $A_y^{\\top}$。\n\n两种常见的线性数值通量选择是：\n\n1. 基于谱分解的精确矩阵迎风通量：\n$$\n\\widehat{F}(q^{-},q^{+},n) = A_n^{+} q^{-} + A_n^{-} q^{+}, \\quad A_n^{\\pm} = S \\Lambda^{\\pm} S^{-1}, \\quad \\Lambda^{\\pm} = \\operatorname{diag}\\big(\\max(\\lambda_i,0),\\min(\\lambda_i,0)\\big),\n$$\n其中 $A_n = S \\Lambda S^{-1}$ 是一个对角化，特征值为 $\\lambda_i$，特征向量为 $S$。\n\n2. 局部 Lax–Friedrichs (Rusanov) 通量：\n$$\n\\widehat{F}(q^{-},q^{+},n) = \\frac{1}{2}\\left(A_n (q^{-}+q^{+}) - \\alpha (q^{+}-q^{-})\\right),\n$$\n其中 $\\alpha \\ge \\rho(A_n)$ 是 $A_n$ 谱半径的任意上界。\n\n对于伴随算子，可以通过替换 $A_n^{\\top}$ 和可能的伴随参数 $\\alpha_{\\text{adj}}$ 来类似地定义伴随数值通量。如果 $M = (M_{\\text{adj}})^{\\top}$，则该格式是伴随一致的。对于精确矩阵迎风通量，如果分裂是使用真实的特征分解完成的，则此条件成立；对于局部 Lax–Friedrichs 通量，如果 $\\alpha_{\\text{adj}} = \\alpha$，则此条件成立。\n\n任务：\n\n1. 基于第一性原理，根据欧拉方程在均匀基态附近的线性化，推导上述矩阵 $A_x$ 和 $A_y$，以及泛函 $J$ 的边界敏感性向量 $g(n)$。\n\n2. 推导伴随一致性条件 $M = (M_{\\text{adj}})^{\\top}$ 并验证：\n   - 对于精确矩阵迎风通量，$M = A_n^{+}$ 且 $M_{\\text{adj}} = (A_n^{\\top})^{+}$，伴随一致性成立。\n   - 对于局部 Lax–Friedrichs 通量，$M = \\dfrac{1}{2}\\left(A_n + \\alpha I\\right)$ 且 $M_{\\text{adj}} = \\dfrac{1}{2}\\left(A_n^{\\top} + \\alpha_{\\text{adj}} I\\right)$，因此伴随一致性要求 $\\alpha_{\\text{adj}} = \\alpha$。\n\n3. 实现一个程序，对于给定的基态参数，构造 $A_x$、$A_y$，并评估伴随一致性缺陷\n$$\n\\Delta(n,\\text{flux},\\alpha,\\alpha_{\\text{adj}}) = \\left\\| M - (M_{\\text{adj}})^{\\top} \\right\\|_F,\n$$\n其中 $\\|\\cdot\\|_F$ 表示 Frobenius 范数。同时计算一个泛函加权的敏感性量级\n$$\nS(n,\\text{flux},\\alpha,\\alpha_{\\text{adj}}) = \\left\\| \\left( M - (M_{\\text{adj}})^{\\top} \\right)^{\\top} g(n) \\right\\|_2,\n$$\n它衡量了不一致性如何影响阻力泛函的线性化；这里 $\\|\\cdot\\|_2$ 是欧几里得范数。\n\n在国际单位制（SI单位）下，使用以下物理上合理的基态常数：\n$$\n\\gamma = 1.4, \\quad \\rho_0 = 1.0 \\ \\text{kg/m}^3, \\quad p_0 = 10^5 \\ \\text{Pa}, \\quad u_0 = 300 \\ \\text{m/s}, \\quad v_0 = 50 \\ \\text{m/s}.\n$$\n仅在需要解释时才定义声速 $a = \\sqrt{\\gamma p_0 / \\rho_0}$；下面的数值任务直接使用 $A_x$ 和 $A_y$。\n\n测试套件：\n\n针对以下四个测试案例评估 $(\\Delta,S)$，这些案例探测了不同的法向量和通量选择：\n\n- 案例1（理想路径）：$n = \\left(\\dfrac{1}{\\sqrt{2}}, \\dfrac{1}{\\sqrt{2}}\\right)$，精确矩阵迎风通量；这应得到接近于零的伴随一致性缺陷。\n- 案例2（基线一致性）：$n = (1,0)$，局部 Lax–Friedrichs 通量，其中 $\\alpha$ 等于 $A_n$ 的谱半径且 $\\alpha_{\\text{adj}} = \\alpha$；这应得到接近于零的缺陷。\n- 案例3（不一致性，轻微）：$n = (0,1)$，局部 Lax–Friedrichs 通量，其中 $\\alpha$ 等于 $A_n$ 的谱半径且 $\\alpha_{\\text{adj}} = 0.5\\,\\alpha$；这应表现出非零的缺陷。\n- 案例4（不一致性，强烈）：$n = \\left(\\dfrac{1}{\\sqrt{2}}, \\dfrac{1}{\\sqrt{2}}\\right)$，局部 Lax–Friedrichs 通量，其中 $\\alpha$ 等于谱半径且 $\\alpha_{\\text{adj}} = 2\\,\\alpha$；这应表现出更大的缺陷。\n\n最终输出格式：\n\n你的程序应生成单行输出，其中包含所有四个测试案例的八个浮点数结果，按顺序聚合，每个案例贡献两个数字 $(\\Delta,S)$，平展成一个列表。要求的格式是一个用方括号括起来的、逗号分隔的列表，例如\n$$\n[\\Delta_1,S_1,\\Delta_2,S_2,\\Delta_3,S_3,\\Delta_4,S_4].\n$$\n输出中不使用角度；报告的值是无量纲的范数。程序必须是完全自包含的，且不需要用户输入。", "solution": "本回应分为两部分。首先，给出了系统矩阵、边界敏感性向量和伴随一致性条件的所需推导。其次，概述了数值实现的逻辑，并最终给出程序。\n\n### 第一部分：系统矩阵和边界敏感性的推导\n\n首要任务是推导用于线性化欧拉方程的系统矩阵 $A_x$ 和 $A_y$（以原始变量表示），以及指定阻力泛函的边界敏感性向量 $g(n)$。\n\n**系统矩阵 $A_x$ 和 $A_y$ 的推导**\n\n可压缩无粘性流体的欧拉方程（以原始变量 $q = [\\rho, u, v, p]^\\top$ 表示）为：\n连续性方程：$\\partial_t \\rho + \\mathbf{u} \\cdot \\nabla\\rho + \\rho \\nabla \\cdot \\mathbf{u} = 0$\n动量方程：$\\partial_t \\mathbf{u} + (\\mathbf{u} \\cdot \\nabla)\\mathbf{u} + \\frac{1}{\\rho}\\nabla p = 0$\n能量方程（等熵形式）：$\\partial_t p + \\mathbf{u} \\cdot \\nabla p + \\gamma p \\nabla \\cdot \\mathbf{u} = 0$\n\n我们围绕均匀基态 $(\\rho_0, u_0, v_0, p_0)$ 对这些方程进行线性化，其中所有基态量均为常数。设状态向量为 $q = q_0 + q'$，其中 $q_0 = [\\rho_0, u_0, v_0, p_0]^\\top$，$q' = [\\rho', u', v', p']^\\top$ 是小扰动向量。为清晰起见，我们将省略扰动变量上的撇号。算子变为 $\\partial_t \\to \\partial_t$，$\\partial_x \\to \\partial_x$，$\\partial_y \\to \\partial_y$。方程中的变量被替换为其基态加上扰动，例如 $\\rho \\to \\rho_0 + \\rho$，我们只保留扰动的一阶项。\n\n1.  **连续性方程**：\n    $\\partial_t (\\rho_0+\\rho) + (u_0+u)\\partial_x(\\rho_0+\\rho) + (v_0+v)\\partial_y(\\rho_0+\\rho) + (\\rho_0+\\rho)(\\partial_x(u_0+u) + \\partial_y(v_0+v)) = 0$\n    线性化（注意到常数的导数为零，扰动的乘积可以忽略不计）：\n    $\\partial_t \\rho + u_0 \\partial_x \\rho + v_0 \\partial_y \\rho + \\rho_0(\\partial_x u + \\partial_y v) = 0$\n    这可以写成：\n    $\\partial_t \\rho + (u_0 \\partial_x \\rho + \\rho_0 \\partial_x u) + (v_0 \\partial_y \\rho + \\rho_0 \\partial_y v) = 0$\n\n2.  **x-动量方程**：\n    $\\partial_t (u_0+u) + (u_0+u)\\partial_x(u_0+u) + (v_0+v)\\partial_y(u_0+u) + \\frac{1}{\\rho_0+\\rho}\\partial_x(p_0+p) = 0$\n    使用 $\\frac{1}{\\rho_0+\\rho} \\approx \\frac{1}{\\rho_0}(1-\\frac{\\rho}{\\rho_0}) \\approx \\frac{1}{\\rho_0}$，当乘以扰动项如 $\\partial_x p$ 时，此为一阶近似。\n    线性化：\n    $\\partial_t u + u_0 \\partial_x u + v_0 \\partial_y u + \\frac{1}{\\rho_0} \\partial_x p = 0$\n\n3.  **y-动量方程**：\n    $\\partial_t (v_0+v) + (u_0+u)\\partial_x(u_0+v) + (v_0+v)\\partial_y(u_0+v) + \\frac{1}{\\rho_0+\\rho}\\partial_y(p_0+p) = 0$\n    线性化：\n    $\\partial_t v + u_0 \\partial_x v + v_0 \\partial_y v + \\frac{1}{\\rho_0} \\partial_y p = 0$\n\n4.  **压力（能量）方程**：\n    $\\partial_t (p_0+p) + (u_0+u)\\partial_x(p_0+p) + (v_0+v)\\partial_y(p_0+p) + \\gamma(p_0+p)(\\partial_x(u_0+u) + \\partial_y(v_0+v)) = 0$\n    线性化：\n    $\\partial_t p + u_0 \\partial_x p + v_0 \\partial_y p + \\gamma p_0 (\\partial_x u + \\partial_y v) = 0$\n\n我们将这四个线性化方程组合成矩阵形式 $\\partial_t q + A_x \\partial_x q + A_y \\partial_y q = 0$：\n$$\n\\partial_t \\begin{pmatrix} \\rho \\\\ u \\\\ v \\\\ p \\end{pmatrix} +\n\\begin{pmatrix}\nu_0  \\rho_0  0  0 \\\\\n0  u_0  0  1/\\rho_0 \\\\\n0  0  u_0  0 \\\\\n0  \\gamma p_0  0  u_0\n\\end{pmatrix}\n\\partial_x \\begin{pmatrix} \\rho \\\\ u \\\\ v \\\\ p \\end{pmatrix} +\n\\begin{pmatrix}\nv_0  0  \\rho_0  0 \\\\\n0  v_0  0  0 \\\\\n0  0  v_0  1/\\rho_0 \\\\\n0  0  \\gamma p_0  v_0\n\\end{pmatrix}\n\\partial_y \\begin{pmatrix} \\rho \\\\ u \\\\ v \\\\ p \\end{pmatrix} = 0\n$$\n推导出的矩阵 $A_x$ 和 $A_y$与问题陈述中提供的矩阵相匹配。\n\n**边界敏感性向量 $g(n)$ 的推导**\n\n阻力泛函给出为 $J(q_{total}) = \\int_{\\Gamma} \\left(p_{total}\\,n_x - \\rho_{total}\\,u_{total}\\,v_{total}\\,n_y\\right)\\,ds$。我们通过代入 $p_{total} = p_0 + p$，$\\rho_{total} = \\rho_0 + \\rho$，$u_{total} = u_0 + u$ 和 $v_{total} = v_0 + v$，并仅保留扰动 $\\rho, u, v, p$ 的一阶项，将此泛函在基态 $q_0$ 附近线性化。\n\n被积函数为 $I = (p_0+p)n_x - (\\rho_0+\\rho)(u_0+u)(v_0+v)n_y$。\n第一项是 $p_0 n_x + p n_x$。\n第二项展开为：\n$(\\rho_0+\\rho)(u_0+u)(v_0+v) = (\\rho_0 u_0 + \\rho_0 u + \\rho u_0)(v_0+v) + \\mathcal{O}(\\text{pert}^2)$\n$= \\rho_0 u_0 v_0 + \\rho_0 u v_0 + \\rho u_0 v_0 + \\rho_0 u_0 v + \\mathcal{O}(\\text{pert}^2)$\n代回到被积函数中：\n$I = p_0 n_x + p n_x - (\\rho_0 u_0 v_0 + \\rho u_0 v_0 + \\rho_0 u v_0 + \\rho_0 u_0 v)n_y + \\mathcal{O}(\\text{pert}^2)$\n$J(q_0+q) = \\int_{\\Gamma} I \\, ds = \\underbrace{\\int_{\\Gamma} (p_0 n_x - \\rho_0 u_0 v_0 n_y) ds}_{J(q_0)} + \\underbrace{\\int_{\\Gamma} (p n_x - \\rho u_0 v_0 n_y - \\rho_0 u v_0 n_y - \\rho_0 v u_0 n_y) ds}_{\\delta J} + \\mathcal{O}(\\text{pert}^2)$\n一阶变分 $\\delta J$ 是扰动向量 $q=[\\rho, u, v, p]^\\top$ 的线性泛函的积分。我们可以将被积函数写成点积 $g(n)^\\top q$：\n$g(n)^\\top q = (-\\,u_0\\,v_0\\,n_y)\\rho + (-\\,\\rho_0\\,v_0\\,n_y)u + (-\\,\\rho_0\\,u_0\\,n_y)v + (n_x)p$\n由此，我们确定边界敏感性向量 $g(n)$ 为：\n$$\ng(n) = \\begin{bmatrix}\n-\\,u_0\\,v_0\\,n_y \\\\\n-\\,\\rho_0\\,v_0\\,n_y \\\\\n-\\,\\rho_0\\,u_0\\,n_y \\\\\nn_x\n\\end{bmatrix}\n$$\n此推导证实了问题陈述中给出的 $g(n)$ 表达式。\n\n### 第二部分：伴随一致性条件\n\n间断 Galerkin (DG) 格式的伴随一致性是目标导向误差估计的一个关键性质，它确保离散伴随问题是连续伴随问题的一致离散化。对于使用数值通量 $\\widehat{F}(q^-, q^+)$ 离散化的线性双曲系统，格式的行为由通量的雅可比矩阵决定。关系式 $M = (M_{\\text{adj}})^\\top$（其中 $M = \\partial \\widehat{F}/\\partial q^-$ 且 $M_{\\text{adj}} = \\partial \\widehat{F}_{\\text{adj}}/\\partial \\varphi^-$）源于要求与DG空间离散化相关的双线性形式在特定意义下是自伴的。一个完整的推导涉及分析原始问题和伴随问题的弱形式中的边界积分，并确保它们互为伴随。在这里，我们视此条件为已知，并为两种指定的通量验证它。\n\n**1. 精确矩阵迎风通量**\n原始数值通量为 $\\widehat{F}(q^{-},q^{+},n) = A_n^{+} q^{-} + A_n^{-} q^{+}$，其中 $A_n^{\\pm}$ 是矩阵 $A_n = n_x A_x + n_y A_y$ 通过其谱分解 $A_n = S \\Lambda S^{-1}$ 得到的正部和负部。\n$\\widehat{F}$ 关于内部状态 $q^-$ 的雅可比矩阵为：\n$M = \\dfrac{\\partial \\widehat{F}}{\\partial q^{-}} = A_n^{+}$\n伴随数值通量是通过将相同的分裂过程应用于伴随系统矩阵 $A_n^\\top$ 来定义的：\n$\\widehat{F}_{\\text{adj}}(\\varphi^{-},\\varphi^{+},n) = (A_n^{\\top})^{+} \\varphi^{-} + (A_n^{\\top})^{-} \\varphi^{+}$\n$\\widehat{F}_{\\text{adj}}$ 关于内部伴随状态 $\\varphi^-$ 的雅可比矩阵为：\n$M_{\\text{adj}} = \\dfrac{\\partial \\widehat{F}_{\\text{adj}}}{\\partial \\varphi^{-}} = (A_n^{\\top})^{+}$\n伴随一致性条件是 $M = (M_{\\text{adj}})^\\top$。代入 $M$ 和 $M_{\\text{adj}}$ 的表达式：\n$A_n^{+} = \\left( (A_n^{\\top})^{+} \\right)^{\\top}$\n为验证这一点，我们回顾定义。对于矩阵 $A = S \\Lambda S^{-1}$，$A^+ = S \\Lambda^+ S^{-1}$，其中 $\\Lambda^+=\\text{diag}(\\max(0,\\lambda_i))$。$A^\\top$ 的特征值与 $A$ 相同。$A^\\top$ 的特征向量由 $(S^{-1})^\\top$ 的列给出。因此，$A^\\top = (S^{-1})^\\top \\Lambda S^\\top$。\n由此，$(A_n^\\top)^+ = ((S_n^{-1})^\\top) \\Lambda_n^+ S_n^\\top$。\n对此表达式取转置：\n$\\left( (A_n^\\top)^+ \\right)^\\top = (S_n^\\top)^\\top (\\Lambda_n^+)^\\top ((S_n^{-1})^\\top)^\\top = S_n \\Lambda_n^+ S_n^{-1} = A_n^+$\n最后一步利用了 $\\Lambda_n^+$ 是对角矩阵的事实，所以 $(\\Lambda_n^+)^\\top = \\Lambda_n^+$。因此，条件成立，精确矩阵迎风通量是伴随一致的。\n\n**2. 局部 Lax–Friedrichs (LLF) 通量**\n原始 LLF 通量为 $\\widehat{F}(q^{-},q^{+},n) = \\frac{1}{2}\\left(A_n (q^{-}+q^{+}) - \\alpha (q^{+}-q^{-})\\right)$。\n我们可以将其重写为 $\\widehat{F}(q^{-},q^{+},n) = \\frac{1}{2}(A_n + \\alpha I)q^{-} + \\frac{1}{2}(A_n - \\alpha I)q^{+}$。\n关于内部状态 $q^-$ 的雅可比矩阵为：\n$M = \\dfrac{\\partial \\widehat{F}}{\\partial q^{-}} = \\dfrac{1}{2}(A_n + \\alpha I)$\n伴随 LLF 通量是使用 $A_n^\\top$ 和一个独立的稳定化参数 $\\alpha_{\\text{adj}}$ 来定义的：\n$\\widehat{F}_{\\text{adj}}(\\varphi^{-},\\varphi^{+},n) = \\frac{1}{2}\\left(A_n^\\top (\\varphi^{-}+\\varphi^{+}) - \\alpha_{\\text{adj}} (\\varphi^{+}-\\varphi^{-})\\right)$\n关于内部伴随状态 $\\varphi^-$ 的雅可比矩阵为：\n$M_{\\text{adj}} = \\dfrac{\\partial \\widehat{F}_{\\text{adj}}}{\\partial \\varphi^{-}} = \\dfrac{1}{2}(A_n^\\top + \\alpha_{\\text{adj}} I)$\n伴随一致性条件 $M = (M_{\\text{adj}})^\\top$ 要求：\n$\\dfrac{1}{2}(A_n + \\alpha I) = \\left( \\dfrac{1}{2}(A_n^\\top + \\alpha_{\\text{adj}} I) \\right)^{\\top}$\n$\\dfrac{1}{2}(A_n + \\alpha I) = \\dfrac{1}{2}((A_n^\\top)^\\top + (\\alpha_{\\text{adj}} I)^\\top)$\n$\\dfrac{1}{2}(A_n + \\alpha I) = \\dfrac{1}{2}(A_n + \\alpha_{\\text{adj}} I)$\n此等式成立当且仅当 $\\alpha I = \\alpha_{\\text{adj}} I$，这意味着 $\\alpha = \\alpha_{\\text{adj}}$。因此，LLF 通量仅当原始问题和伴随问题使用相同的稳定化参数时才是伴随一致的。\n\n分析证实了问题描述中陈述的理论性质。任务的数值部分涉及计算与这些理想条件的偏差。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating adjoint-consistency defects for the\n    linearized Euler equations under different numerical flux choices.\n    \"\"\"\n    # Base state parameters (SI units)\n    gamma = 1.4\n    rho_0 = 1.0\n    p_0 = 1e5\n    u_0 = 300.0\n    v_0 = 50.0\n\n    # Construct system matrices Ax and Ay\n    A_x = np.array([\n        [u_0, rho_0, 0, 0],\n        [0, u_0, 0, 1.0/rho_0],\n        [0, 0, u_0, 0],\n        [0, gamma*p_0, 0, u_0]\n    ])\n    A_y = np.array([\n        [v_0, 0, rho_0, 0],\n        [0, v_0, 0, 0],\n        [0, 0, v_0, 1.0/rho_0],\n        [0, 0, gamma*p_0, v_0]\n    ])\n\n    test_cases = [\n        # Case 1: Exact upwind, n=(1/sqrt(2), 1/sqrt(2))\n        (np.array([1.0/np.sqrt(2), 1.0/np.sqrt(2)]), 'upwind', None),\n        # Case 2: LLF, n=(1,0), alpha_adj = alpha\n        (np.array([1.0, 0.0]), 'llf', 1.0),\n        # Case 3: LLF, n=(0,1), alpha_adj = 0.5*alpha\n        (np.array([0.0, 1.0]), 'llf', 0.5),\n        # Case 4: LLF, n=(1/sqrt(2), 1/sqrt(2)), alpha_adj = 2.0*alpha\n        (np.array([1.0/np.sqrt(2), 1.0/np.sqrt(2)]), 'llf', 2.0),\n    ]\n\n    results = []\n\n    for n, flux_type, alpha_adj_factor in test_cases:\n        n_x, n_y = n\n        \n        # Form the flux Jacobian An\n        A_n = n_x * A_x + n_y * A_y\n        \n        # Form the boundary sensitivity vector g(n)\n        g_n = np.array([\n            -u_0 * v_0 * n_y,\n            -rho_0 * v_0 * n_y,\n            -rho_0 * u_0 * n_y,\n            n_x\n        ])\n\n        if flux_type == 'upwind':\n            \n            def get_positive_part(A):\n                \"\"\"Computes the positive part of a matrix via spectral decomposition.\"\"\"\n                eigvals, S = np.linalg.eig(A)\n                S_inv = np.linalg.inv(S)\n                # For hyperbolic systems, eigenvalues are real. Use .real to handle potential small imaginary parts from numerics.\n                Lambda_plus = np.diag(np.maximum(eigvals.real, 0))\n                return S @ Lambda_plus @ S_inv\n\n            # Primal flux Jacobian M\n            M = get_positive_part(A_n)\n            \n            # Adjoint flux Jacobian Madj\n            M_adj = get_positive_part(A_n.T)\n            \n            # Defect matrix D\n            D = M - M_adj.T\n            \n        elif flux_type == 'llf':\n            # Speed of sound squared\n            a0_sq = gamma * p_0 / rho_0\n            a0 = np.sqrt(a0_sq)\n            \n            # Convective velocity in normal direction\n            V_n = u_0 * n_x + v_0 * n_y\n            \n            # Eigenvalues of An are V_n, V_n, V_n-a0, V_n+a0\n            eigvals_An = np.array([V_n, V_n, V_n - a0, V_n + a0])\n            \n            # Primal stabilization parameter alpha\n            alpha = np.max(np.abs(eigvals_An))\n            \n            # Adjoint stabilization parameter alpha_adj\n            alpha_adj = alpha * alpha_adj_factor\n            \n            I = np.identity(4)\n            \n            # Primal flux Jacobian M\n            M = 0.5 * (A_n + alpha * I)\n            \n            # Transpose of adjoint flux Jacobian (M_adj)^T\n            M_adj_T = 0.5 * (A_n + alpha_adj * I)\n            \n            # Defect matrix D\n            D = M - M_adj_T\n        \n        # Calculate consistency defect Delta (Frobenius norm)\n        delta = np.linalg.norm(D, 'fro')\n        \n        # Calculate functional-weighted sensitivity S (Euclidean norm)\n        s_val = np.linalg.norm(D.T @ g_n)\n        \n        results.extend([delta, s_val])\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "3362346"}, {"introduction": "在复杂的科学计算中，我们时常面临一个棘手的权衡：保证正演模拟的数值稳定性与追求目标泛函误差估计的准确性。为了实现鲁棒性，我们可能需要在原始问题中加入较多的数值耗散，但这往往会“抹平”解的精细结构，从而降低误差估计的精度。本练习 [@problem_id:3362323] 探索了一种高级的设计理念——混合原始-伴随定常化。其思想是为原始问题和伴随问题选择不同的数值格式（在此例中是不同的定常化参数 $a_{\\mathrm{p}}$ 和 $a_{\\mathrm{a}}$），以期同时达到稳定性和准确性的最优平衡。您将通过一个完整的仿真项目，亲手实现原始解和伴随解的演化，并计算误差估计的有效性指数与原始解的稳定性裕度，从而第一手地分析这种设计权衡，体验面向特定应用需求进行算法设计的精髓。", "problem": "考虑高马赫数区中的一维无粘性可压缩流，在均匀状态附近进行线性化，对于熵平流，该问题可简化为周期性域 $x \\in [0,1]$（周期为1）上的标量线性输运方程 $u_t + a u_x = 0$，其中 $a  0$ 表示恒定的平流速度。在使用分片常数基函数的间断 Galerkin (DG) 方法（这与有限体积格式一致）中，半离散原始公式可以写成在 $N$ 个大小为 $\\Delta x = 1/N$ 的均匀网格上的网格平均值 $\\{u_i(t)\\}_{i=0}^{N-1}$ 的形式，并采用周期性边界条件。对原始问题使用带有稳定化参数 $\\alpha_{\\mathrm{p}} \\ge 0$ 的 Lax–Friedrichs (也称为 Rusanov) 数值通量，半离散算子 $\\mathbf{A}_{\\mathrm{p}} \\in \\mathbb{R}^{N \\times N}$ 满足\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{A}_{\\mathrm{p}}\\mathbf{u}, \\quad \\mathbf{u}(0) = \\mathbf{u}_0,\n$$\n其项由界面通量\n$$\nF_{i+1/2} = \\tfrac{1}{2} a (u_i + u_{i+1}) - \\tfrac{1}{2} \\alpha_{\\mathrm{p}} (u_{i+1} - u_i),\n$$\n推导得出，对每个网格 $i$（使用周期性索引）给出\n$$\n\\left(\\frac{d\\mathbf{u}}{dt}\\right)_i = -\\frac{1}{\\Delta x}\\left(F_{i+1/2} - F_{i-1/2}\\right) = -\\frac{1}{\\Delta x}\\left(\\alpha_{\\mathrm{p}} u_i + \\tfrac{1}{2}(a - \\alpha_{\\mathrm{p}})u_{i+1} - \\tfrac{1}{2}(a + \\alpha_{\\mathrm{p}})u_{i-1}\\right).\n$$\n在最终时间 $T  0$ 的目标泛函为\n$$\nJ(u) = \\int_{0}^{1} w(x)\\, u(x,T)\\, dx,\n$$\n其中 $w(x)$ 是一个给定的权重函数，其紧支集在 $(0,1)$ 内部，且 $\\int_0^1 w(x)\\,dx$ 是有限的。我们考虑一种混合原始-伴随稳定化设计，其中伴随方程使用一个可能不同的 Lax–Friedrichs 参数 $\\alpha_{\\mathrm{a}} \\ge 0$ 和一个相应的半离散算子 $\\mathbf{A}_{\\mathrm{a}}$，该算子以类似于 $\\mathbf{A}_{\\mathrm{p}}$ 的方式构造，但用 $\\alpha_{\\mathrm{a}}$ 替换 $\\alpha_{\\mathrm{p}}$。\n\n通过将带有时间步长 $\\Delta t$ 的强稳定保持三阶 Runge–Kutta (SSP RK3) 方法应用于原始常微分方程，来定义时间上离散的前向解。对于从 $\\mathbf{u}^n$ 演化到 $\\mathbf{u}^{n+1}$ 的单个时间步，该方法具有单步稳定性多项式\n$$\n\\mathbf{K}(\\mathbf{A}, \\Delta t) = \\mathbf{I} + \\Delta t\\, \\mathbf{A} + \\tfrac{1}{2}\\Delta t^2\\, \\mathbf{A}^2 + \\tfrac{1}{6}\\Delta t^3\\, \\mathbf{A}^3,\n$$\n以至于 $\\mathbf{u}^{n+1} = \\mathbf{K}(\\mathbf{A}_{\\mathrm{p}}, \\Delta t)\\, \\mathbf{u}^{n}$。离散伴随变量 $\\mathbf{z}$ 使用混合伴随算子和转置映射 $\\mathbf{z}^{n} = \\mathbf{K}(\\mathbf{A}_{\\mathrm{a}}, \\Delta t)^{\\top}\\, \\mathbf{z}^{n+1}$ 向后传播，并满足终端条件\n$$\n\\mathbf{z}^N = \\mathbf{z}(T) = \\mathbf{M}\\mathbf{w},\n$$\n其中 $\\mathbf{M}$ 是分片常数 DG 空间的质量矩阵，在此设置下它等于 $\\Delta x$ 乘以单位矩阵，$\\mathbf{w}$ 是在网格中心 $x_i$ 处计算的权重 $w(x_i)$ 的向量。\n\n面向目标的误差估计子是通过将半离散原始方程的离散残差与每个时间步上的伴随权重进行度量来构造的：\n$$\n\\mathcal{R}_n = \\left(\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^{n}}{\\Delta t}\\right) - \\mathbf{A}_{\\mathrm{p}}\\left(\\tfrac{\\mathbf{u}^{n+1} + \\mathbf{u}^{n}}{2}\\right),\n$$\n估计值为\n$$\n\\eta = \\sum_{n=0}^{N_t-1} \\left(\\mathbf{z}^{n+1}\\right)^{\\top} \\mathbf{M}\\, \\mathcal{R}_n\\, \\Delta t.\n$$\n该估计子通过 $(\\alpha_{\\mathrm{p}}, \\alpha_{\\mathrm{a}})$ 编码了一种混合原始-伴随稳定化，并允许量化目标泛函中稳定性与准确性之间的权衡。\n\n您的任务是在一个单一、完整、可运行的程序中为一组测试用例实现以下步骤：\n1. 为给定的 $(a, \\alpha_{\\mathrm{p}}, \\alpha_{\\mathrm{a}}, N)$ 在周期性网格上构造原始算子 $\\mathbf{A}_{\\mathrm{p}}$ 和伴随算子 $\\mathbf{A}_{\\mathrm{a}}$。\n2. 通过 Courant–Friedrichs–Lewy (CFL) 约束\n$$\n\\Delta t = \\frac{\\mathrm{CFL}\\, \\Delta x}{|a| + \\alpha_{\\mathrm{p}}},\n$$\n选择时间步长 $\\Delta t$，并设置步数 $N_t = \\lceil T/\\Delta t \\rceil$，且精确地使 $\\Delta t = T/N_t$。\n3. 使用 SSP RK3 将原始解 $\\mathbf{u}$ 从初始数据 $u_0(x)$ 演化到时间 $T$。初始数据必须是\n$$\nu_0(x) = \\sin(2\\pi x) + \\tfrac{1}{2} \\exp\\left(-\\frac{(x-0.25)^2}{2\\sigma_0^2}\\right), \\quad \\sigma_0 = 0.02.\n$$\n4. 将 $w(x)$ 定义为\n$$\nw(x) = \\exp\\left(-\\frac{(x-x_0)^2}{2\\sigma_w^2}\\right), \\quad x_0 = 0.7, \\quad \\sigma_w = 0.05.\n$$\n在网格中心计算 $\\mathbf{w}$ 并设置 $\\mathbf{M} = \\Delta x\\, \\mathbf{I}$。\n5. 从 $\\mathbf{z}^N = \\mathbf{M}\\mathbf{w}$ 开始，使用带有 $\\mathbf{A}_{\\mathrm{a}}$ 的转置混合伴随映射和 SSP RK3 单步多项式 $\\mathbf{K}(\\mathbf{A}_{\\mathrm{a}}, \\Delta t)^{\\top}$ 向后传播伴随变量，并使用残差 $\\mathcal{R}_n$ 累积估计子 $\\eta$。\n6. 计算离散目标 $J_h = \\sum_{i} w(x_i)\\, u_i(T)\\, \\Delta x$。\n7. 使用至少 $10^4$ 个均匀点的高分辨率数值积分计算精确目标 $J_{\\mathrm{exact}} = \\int_0^1 w(x)\\, u_0(x - aT \\bmod 1)\\, dx$。\n8. 报告有效性指数 $E = |\\eta|/|J_{\\mathrm{exact}} - J_h|$ 和一个由\n$$\n\\delta = 1 - \\rho\\left(\\mathbf{K}(\\mathbf{A}_{\\mathrm{p}}, \\Delta t)\\right),\n$$\n定义的稳定性-阻尼裕度，其中 $\\rho(\\cdot)$ 表示单步映射矩阵的谱半径（特征值的最大模）；$\\delta  0$ 表示阻尼，$\\delta  0$ 表示放大。\n\n测试套件：\n- 案例 1 (中等马赫数，对偶一致): $a = 3.0$, $\\alpha_{\\mathrm{p}} = 1.0\\,|a|$, $\\alpha_{\\mathrm{a}} = 1.0\\,|a|$, $N = 80$, $\\mathrm{CFL} = 0.5$, $T = 0.1$。\n- 案例 2 (高马赫数，原始欠耗散，伴随为目标调整): $a = 10.0$, $\\alpha_{\\mathrm{p}} = 0.5\\,|a|$, $\\alpha_{\\mathrm{a}} = 1.0\\,|a|$, $N = 120$, $\\mathrm{CFL} = 0.4$, $T = 0.1$。\n- 案例 3 (极高马赫数，原始过耗散，伴随欠耗散): $a = 20.0$, $\\alpha_{\\mathrm{p}} = 2.0\\,|a|$, $\\alpha_{\\mathrm{a}} = 0.5\\,|a|$, $N = 60$, $\\mathrm{CFL} = 0.3$, $T = 0.1$。\n\n您的程序应生成单行输出，其中包含三个案例的六个浮点结果 $[E_1,\\delta_1,E_2,\\delta_2,E_3,\\delta_3]$，按顺序排列，以逗号分隔并用方括号括起来（例如，\"[0.95,0.12,1.04,0.08,0.75,-0.02]\"）。不应产生其他任何输出。\n\n所有数值均为无量纲。不涉及角度。不得使用百分比。将所有最终标量结果表示为浮点小数。", "solution": "该问题为分析一维线性平流方程的面向目标的误差估计子提供了一个完整且适定的指令。所有必要的数学定义、物理参数和计算过程均已提供且科学上是合理的。该问题是有效的，可以按照指定的方法构建解决方案。\n\n问题的核心是在周期性域 $x \\in [0,1]$ 上离散化线性平流方程 $u_t + a u_x = 0$，然后使用基于伴随的对偶加权残差法来估计特定关注量——目标泛函 $J(u)$ 的误差。\n\n**1. 空间离散化：半离散算子**\n\n空间域 $[0,1]$ 被划分为 $N$ 个均匀网格，每个网格的宽度为 $\\Delta x = 1/N$。解 $u(x,t)$ 被分片常数函数所近似，其中在网格 $i$ 中的值为网格平均值 $u_i(t)$。使用带有分片常数基函数的间断 Galerkin (DG) 方法和数值通量对平流方程进行半离散化，会得到一个常微分方程 (ODE) 组。\n\n网格 $i$ 和网格 $i+1$ 之间的界面 $x_{i+1/2}$ 处的通量由 Lax–Friedrichs (Rusanov) 通量近似：\n$$\nF_{i+1/2} = \\frac{1}{2} a (u_i + u_{i+1}) - \\frac{1}{2} \\alpha (u_{i+1} - u_i)\n$$\n其中 $a  0$ 是平流速度，$\\alpha \\ge 0$ 是一个稳定化参数。网格平均值 $u_i$ 的变化率由通量的散度给出：\n$$\n\\frac{du_i}{dt} = -\\frac{1}{\\Delta x}(F_{i+1/2} - F_{i-1/2})\n$$\n代入通量定义并应用周期性索引（例如，$u_{-1} = u_{N-1}$ 和 $u_N = u_0$），得到时间导数的显式表达式：\n$$\n\\frac{du_i}{dt} = -\\frac{1}{\\Delta x}\\left(\\alpha u_i + \\frac{1}{2}(a - \\alpha)u_{i+1} - \\frac{1}{2}(a + \\alpha)u_{i-1}\\right)\n$$\n对于网格平均值向量 $\\mathbf{u}(t) = [u_0(t), u_1(t), \\dots, u_{N-1}(t)]^{\\top}$，这个常微分方程组可以写成矩阵形式：\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{A}\\mathbf{u}\n$$\n矩阵 $\\mathbf{A} \\in \\mathbb{R}^{N \\times N}$ 是一个循环矩阵，其任意行 $i$ 的元素由 $u_{i-1}$、$u_i$ 和 $u_{i+1}$ 的系数确定：\n$$\nA_{i,j} = \\begin{cases}\n-\\frac{\\alpha}{\\Delta x}  \\text{if } j = i \\\\\n-\\frac{a-\\alpha}{2\\Delta x}  \\text{if } j = (i+1) \\pmod N \\\\\n\\frac{a+\\alpha}{2\\Delta x}  \\text{if } j = (i-1) \\pmod N \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n问题指定了两个这样的算子：一个是用参数 $\\alpha_{\\mathrm{p}}$ 构建的原始算子 $\\mathbf{A}_{\\mathrm{p}}$，另一个是用 $\\alpha_{\\mathrm{a}}$ 构建的伴随算子 $\\mathbf{A}_{\\mathrm{a}}$。\n\n**2. 时间离散化与稳定性分析**\n\n线性常微分方程组使用强稳定保持三阶 Runge-Kutta (SSP-RK3) 方法进行时间演化。对于一个线性系统，从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的一个完整 SSP-RK3 时间步的作用可以表示为一个矩阵向量乘积：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{K}(\\mathbf{A}, \\Delta t)\\mathbf{u}^{n}\n$$\n其中 $\\mathbf{K}(\\mathbf{A}, \\Delta t)$ 是单步稳定性多项式矩阵，给定为：\n$$\n\\mathbf{K}(\\mathbf{A}, \\Delta t) = \\mathbf{I} + \\Delta t\\, \\mathbf{A} + \\frac{1}{2}\\Delta t^2\\, \\mathbf{A}^2 + \\frac{1}{6}\\Delta t^3\\, \\mathbf{A}^3\n$$\n时间步长 $\\Delta t$ 基于 Courant–Friedrichs–Lewy (CFL) 条件来选择，以确保数值稳定性。初始的 $\\Delta t$ 计算为 $\\Delta t_{\\text{prov}} = \\frac{\\mathrm{CFL}\\, \\Delta x}{|a| + \\alpha_{\\mathrm{p}}}$。然后将时间步数设为 $N_t = \\lceil T/\\Delta t_{\\text{prov}} \\rceil$，并调整最终的时间步长为 $\\Delta t = T/N_t$ 以精确到达最终时间 $T$。\n\n时间步进格式的稳定性由稳定性-阻尼裕度 $\\delta$ 来量化。这由单步原始算子 $\\mathbf{K}_{\\mathrm{p}} = \\mathbf{K}(\\mathbf{A}_{\\mathrm{p}}, \\Delta t)$ 的谱半径 $\\rho(\\cdot)$ 定义：\n$$\n\\delta = 1 - \\rho(\\mathbf{K}_{\\mathrm{p}}) = 1 - \\max_{j} |\\lambda_j(\\mathbf{K}_{\\mathrm{p}})|\n$$\n其中 $\\lambda_j$ 是 $\\mathbf{K}_{\\mathrm{p}}$ 的特征值。$\\delta  0$ 的值表示所有模式都被阻尼，确保了稳定性，而 $\\delta  0$ 则意味着至少有一个模式被放大，导致不稳定性。\n\n**3. 面向目标的基于伴随的误差估计**\n\n目标是准确计算目标泛函 $J(u) = \\int_{0}^{1} w(x)\\, u(x,T)\\, dx$，其中 $w(x)$ 是一个权重函数。该目标的数值近似是离散和 $J_h = \\sum_{i=0}^{N-1} w(x_i)\\, u_i(T)\\, \\Delta x$。目标的精确值 $J_{\\mathrm{exact}}$ 可以通过利用平流方程的精确解 $u(x,t) = u_0(x - a t \\pmod 1)$ 来计算：\n$$\nJ_{\\mathrm{exact}} = \\int_0^1 w(x)\\, u_0(x - aT \\pmod 1)\\, dx\n$$\n目标中的误差 $J_{\\mathrm{exact}} - J_h$ 是通过后验误差估计子 $\\eta$ 来估计的。这需要向后求解一个伴随问题。离散伴随向量 $\\mathbf{z}$ 根据以下方式演化：\n$$\n\\mathbf{z}^{n} = \\mathbf{K}(\\mathbf{A}_{\\mathrm{a}}, \\Delta t)^{\\top}\\, \\mathbf{z}^{n+1}\n$$\n此演化从时间 $T$ 处的终端条件开始，该条件由目标泛函的权重函数导出：$\\mathbf{z}^N = \\mathbf{M}\\mathbf{w}$，其中 $\\mathbf{M} = \\Delta x \\, \\mathbf{I}$ 是质量矩阵，$\\mathbf{w}$ 是在网格中心计算的权重 $w(x_i)$ 的向量。注意在伴随算子 $\\mathbf{A}_{\\mathrm{a}}$ 中使用了混合稳定化参数 $\\alpha_{\\mathrm{a}}$。\n\n误差估计子 $\\eta$ 是通过将原始残差与伴随解在所有时间步上的内积求和来构造的。时间步 $[t_n, t_{n+1}]$ 的残差定义为：\n$$\n\\mathcal{R}_n = \\left(\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^{n}}{\\Delta t}\\right) - \\mathbf{A}_{\\mathrm{p}}\\left(\\frac{\\mathbf{u}^{n+1} + \\mathbf{u}^{n}}{2}\\right)\n$$\n该残差衡量了在使用梯形法则对时间步进行平均时，数值解满足半离散方程的程度有多差。总的估计误差为：\n$$\n\\eta = \\sum_{n=0}^{N_t-1} (\\mathbf{z}^{n+1})^{\\top} \\mathbf{M}\\, \\mathcal{R}_n\\, \\Delta t\n$$\n该估计子的质量由有效性指数 $E$ 来衡量，即估计误差与真实误差的比值：\n$$\nE = \\frac{|\\eta|}{|J_{\\mathrm{exact}} - J_h|}\n$$\n接近 1 的有效性指数表明误差估计子非常准确。\n\n**4. 算法实现**\n\n对于每个测试用例，计算过程如下：\n1.  **设置**：定义网格参数 ($N, \\Delta x$) 和物理参数 ($a, T, \\mathrm{CFL}, \\alpha_{\\mathrm{p}}, \\alpha_{\\mathrm{a}}$)。\n2.  **算子**：构造原始矩阵 $\\mathbf{A}_{\\mathrm{p}}$ 和伴随矩阵 $\\mathbf{A}_{\\mathrm{a}}$。\n3.  **时间积分**：确定 $\\Delta t$ 和 $N_t$。\n4.  **原始求解**：计算 SSP-RK3 算子 $\\mathbf{K}_{\\mathrm{p}}$。根据 $u_0(x)$ 在网格中心初始化 $\\mathbf{u}^0$。将 $\\mathbf{u}$ 演化 $N_t$ 步以找到 $\\mathbf{u}(T)$，并存储完整的历史记录 $\\{\\mathbf{u}^n\\}_{n=0}^{N_t}$。\n5.  **伴随求解与估计**：\n    *   根据 $w(x)$ 初始化 $\\mathbf{w}$。设置终端伴随状态 $\\mathbf{z}^N = \\Delta x \\, \\mathbf{w}$。\n    *   计算转置的 SSP-RK3 伴随算子 $\\mathbf{K}(\\mathbf{A}_{\\mathrm{a}}, \\Delta t)^{\\top}$。\n    *   初始化 $\\eta = 0$。\n    *   从 $n=N_t-1$ 到 $0$ 进行时间上的反向迭代。在每一步中，计算 $\\mathcal{R}_n$，更新 $\\eta$，并将伴随状态传播到 $\\mathbf{z}^n$。\n6.  **分析**：\n    *   通过高分辨率数值积分计算离散目标 $J_h$、精确目标 $J_{\\mathrm{exact}}$ 和有效性指数 $E$。\n    *   计算 $\\mathbf{K}_{\\mathrm{p}}$ 的特征值，找到其谱半径 $\\rho(\\mathbf{K}_{\\mathrm{p}})$，并计算稳定性裕度 $\\delta$。\n7.  **输出**：报告每个案例计算出的 $E$ 和 $\\delta$ 值。", "answer": "```python\nimport numpy as np\nimport math\n\n# Per the execution environment, scipy is available, but we can implement this\n# problem using only numpy and the standard library.\n# from scipy.linalg import circulant # Not strictly needed\n\ndef solve():\n    \"\"\"\n    Main driver function that iterates through test cases and prints the final result.\n    \"\"\"\n    \n    test_cases = [\n        # (a, alpha_p_factor, alpha_a_factor, N, CFL, T)\n        (3.0, 1.0, 1.0, 80, 0.5, 0.1),\n        (10.0, 0.5, 1.0, 120, 0.4, 0.1),\n        (20.0, 2.0, 0.5, 60, 0.3, 0.1),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, alpha_p_factor, alpha_a_factor, N, CFL, T = case\n        alpha_p = alpha_p_factor * abs(a)\n        alpha_a = alpha_a_factor * abs(a)\n        \n        E, delta = run_case(a, alpha_p, alpha_a, N, CFL, T)\n        results.extend([E, delta])\n\n    # Final output must be a single line of comma-separated floats\n    print(f\"[{','.join(f'{x:.12f}' for x in results)}]\")\n\ndef construct_operator(N, dx, a, alpha):\n    \"\"\"\n    Constructs the semi-discrete operator matrix A for the 1D advection equation\n    on a periodic domain.\n    \"\"\"\n    diag_val = -alpha / dx\n    sup_diag_val = -(a - alpha) / (2 * dx)\n    sub_diag_val = (a + alpha) / (2 * dx)\n\n    A = np.zeros((N, N))\n    \n    # Main diagonals\n    np.fill_diagonal(A, diag_val)\n    # Sub-diagonal (i, i-1)\n    np.fill_diagonal(A[1:, :-1], sub_diag_val)\n    # Super-diagonal (i, i+1)\n    np.fill_diagonal(A[:-1, 1:], sup_diag_val)\n    \n    # Periodic boundary conditions\n    A[0, N - 1] = sub_diag_val\n    A[N - 1, 0] = sup_diag_val\n    \n    return A\n\ndef u0_func(x):\n    \"\"\"Initial condition function u_0(x).\"\"\"\n    sigma0 = 0.02\n    return np.sin(2 * np.pi * x) + 0.5 * np.exp(-((x - 0.25)**2) / (2 * sigma0**2))\n\ndef w_func(x):\n    \"\"\"Weight function w(x) for the goal functional.\"\"\"\n    x0 = 0.7\n    sigma_w = 0.05\n    return np.exp(-((x - x0)**2) / (2 * sigma_w**2))\n\ndef run_case(a, alpha_p, alpha_a, N, CFL, T):\n    \"\"\"\n    Executes the full simulation and analysis for a single test case.\n    \"\"\"\n    # 1. Setup grid and operators\n    dx = 1.0 / N\n    x = np.linspace(0.5 * dx, 1.0 - 0.5 * dx, N)  # Cell centers\n\n    A_p = construct_operator(N, dx, a, alpha_p)\n    A_a = construct_operator(N, dx, a, alpha_a)\n\n    # 2. Determine time step\n    dt_provisional = (CFL * dx) / (abs(a) + alpha_p)\n    Nt = math.ceil(T / dt_provisional)\n    dt = T / Nt\n\n    # 3. Evolve primal solution\n    I = np.identity(N)\n    K_p = I + dt * A_p + 0.5 * dt**2 * (A_p @ A_p) + (1/6) * dt**3 * (A_p @ A_p @ A_p)\n\n    u = u0_func(x)\n    u_history = [u]\n    for _ in range(Nt):\n        u = K_p @ u\n        u_history.append(u)\n    \n    u_final = u_history[-1]\n\n    # 4. Define goal functional weights\n    w = w_func(x)\n    M = dx * I\n    M_w = M @ w\n\n    # 5. Propagate adjoint and accumulate error estimator\n    K_a = I + dt * A_a + 0.5 * dt**2 * (A_a @ A_a) + (1/6) * dt**3 * (A_a @ A_a @ A_a)\n    K_a_T = K_a.T\n    \n    z = M_w  # z^N = M*w\n    eta = 0.0\n    \n    for n in range(Nt - 1, -1, -1):\n        z_np1 = z\n        u_n = u_history[n]\n        u_np1 = u_history[n+1]\n\n        # Calculate residual for step n\n        R_n = ((u_np1 - u_n) / dt) - A_p @ (0.5 * (u_np1 + u_n))\n        \n        # Accumulate estimator: (z^{n+1})^T * M * R_n * dt\n        eta += np.dot(z_np1, M @ R_n) * dt\n        \n        # Propagate adjoint backward\n        z = K_a_T @ z_np1\n\n    # 6. Compute discrete and exact goals\n    J_h = np.sum(w * u_final) * dx\n\n    N_quad = 20000\n    x_quad = np.linspace(0.0, 1.0, N_quad, endpoint=False)\n    dx_quad = 1.0/N_quad\n    \n    x_advected = (x_quad - a * T) % 1.0\n    \n    integrand = w_func(x_quad) * u0_func(x_advected)\n    J_exact = np.sum(integrand) * dx_quad\n\n    # 7. Compute effectivity index E\n    true_error = J_exact - J_h\n    if abs(true_error)  1e-15:\n        E = 1.0 if abs(eta)  1e-15 else float('inf')\n    else:\n        E = abs(eta) / abs(true_error)\n\n    # 8. Compute stability-damping margin delta\n    eigvals = np.linalg.eigvals(K_p)\n    spectral_radius = np.max(np.abs(eigvals))\n    delta = 1.0 - spectral_radius\n    \n    return E, delta\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3362323"}]}