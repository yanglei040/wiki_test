{"hands_on_practices": [{"introduction": "我们从一个基础的分析练习开始，以验证混合可杂交间断伽辽金（HDG）方法后处理的核心特性。通过在一个单元上构造一个已知的精确解，并假设我们得到了一个理想的HDG通量近似，这个练习将引导你分析性地证明后处理解 $u_h^\\star$ 能够精确地恢复一个 $k+1$ 次的多项式解。这项实践旨在揭示后处理技术能够提升解的精度的根本原因，即其超收敛性质。[@problem_id:3410138]", "problem": "考虑在单个凸多边形单元 $K = [0,1] \\times [0,1]$ 上的稳态扩散模型问题，其扩散系数为常数，由偏微分方程 $-\\Delta u = f$ 和狄利克雷边界条件 $u|_{\\partial K} = g$ 控制。设精确（人造）解为 $u(x,y) = x^2 + y^2$ 在 $K$ 上。那么在 $\\partial K$ 上有 $f(x,y) = -\\Delta u(x,y)$ 和 $g(x,y) = u(x,y)$。\n\n令 $\\mathcal{P}_{k}(K)$ 表示 $K$ 上总次数至多为 $k$ 的多项式空间，并设可杂交间断伽辽金 (HDG) 方法的局部空间为 $\\boldsymbol{q}_{h} \\in [\\mathcal{P}_{k}(K)]^{2}$，$u_{h} \\in \\mathcal{P}_{k}(K)$，以及在 $\\partial K$ 上的数值迹 $\\widehat{u}_{h}$（单单元设置）。假设 $k=1$，并且计算出的 HDG 通量 $\\boldsymbol{q}_{h}$ 等于精确通量 $\\nabla u$ 在 $[\\mathcal{P}_{1}(K)]^{2}$ 上的 $L^{2}(K)$-投影。由于 $\\nabla u(x,y) = (2x,2y)$ 已经属于 $[\\mathcal{P}_{1}(K)]^{2}$，这个假设意味着在 $K$ 上有 $\\boldsymbol{q}_{h} = \\nabla u$。\n\n将标准 HDG 后处理 $u_{h}^{\\star} \\in \\mathcal{P}_{k+1}(K)$ 定义为对所有 $w \\in \\mathcal{P}_{k+1}(K)$ 满足下式的唯一多项式：\n$$(\\nabla u_{h}^{\\star}, \\nabla w)_{K} = (\\boldsymbol{q}_{h}, \\nabla w)_{K},$$\n以及平均值约束 \n$$\\int_{K} u_{h}^{\\star} \\,\\mathrm{d}\\boldsymbol{x} = \\int_{K} u \\,\\mathrm{d}\\boldsymbol{x}。$$\n此处，$(\\cdot,\\cdot)_{K}$ 表示 $L^{2}(K)$ 内积，$\\mathrm{d}\\boldsymbol{x}$ 是 $K$ 上的面积测度。\n\n从上述定义和人造数据出发，显式地推导 $u_{h}^{\\star}(x,y)$，并验证此单单元问题中后处理所蕴含的阶数和精确性。您的最终答案必须是关于 $x$ 和 $y$ 的 $u_{h}^{\\star}(x,y)$ 的单一闭式解析表达式。不需要进行数值取整。", "solution": "该问题是有效的，因为它是数学上适定的，在数值分析领域有科学依据，并提供了一套完整且一致的定义和数据。\n\n任务是推导在单个方形单元 $K = [0,1] \\times [0,1]$ 上的后处理可杂交间断伽辽金 (HDG) 解 $u_h^\\star(x,y)$ 的显式形式。局部 HDG 空间的多项式次数为 $k=1$。\n\n后处理解 $u_h^\\star \\in \\mathcal{P}_{k+1}(K) = \\mathcal{P}_{2}(K)$ 的定义性质由两个条件给出：\n1.  一个变分方程：\n    $$(\\nabla u_{h}^{\\star}, \\nabla w)_{K} = (\\boldsymbol{q}_{h}, \\nabla w)_{K}, \\quad \\forall w \\in \\mathcal{P}_{2}(K)$$\n2.  一个平均值约束：\n    $$\\int_{K} u_{h}^{\\star} \\,\\mathrm{d}\\boldsymbol{x} = \\int_{K} u \\,\\mathrm{d}\\boldsymbol{x}$$\n此处，$(\\cdot, \\cdot)_{K}$ 表示在区域 $K$ 上的标准 $L^2$ 内积。\n\n首先，我们必须确定 HDG 通量近似 $\\boldsymbol{q}_h$。问题陈述 $\\boldsymbol{q}_h$ 是精确通量 $\\nabla u$ 在多项式空间 $[\\mathcal{P}_{k}(K)]^2$ 上的 $L^2(K)$-投影，当 $k=1$ 时，该空间为 $[\\mathcal{P}_{1}(K)]^2$。\n\n精确解为 $u(x,y) = x^2 + y^2$。\n精确通量是 $u$ 的梯度：\n$$\\nabla u(x,y) = \\left( \\frac{\\partial u}{\\partial x}, \\frac{\\partial u}{\\partial y} \\right) = (2x, 2y)$$\n向量场 $\\nabla u$ 的每个分量都是一个一次多项式。因此，精确通量 $\\nabla u$ 已经存在于投影的目标空间 $[\\mathcal{P}_{1}(K)]^2$ 中。\n一个元素到包含其自身的空间上的 $L^2$-投影就是该元素本身。\n因此，我们有 $\\boldsymbol{q}_h = \\nabla u = (2x, 2y)$。\n\n现在，我们将 $\\boldsymbol{q}_h$ 的这个结果代入定义 $u_h^\\star$ 的变分方程中：\n$$(\\nabla u_{h}^{\\star}, \\nabla w)_{K} = (\\nabla u, \\nabla w)_{K}, \\quad \\forall w \\in \\mathcal{P}_{2}(K)$$\n根据内积的线性性，该方程可以重写为：\n$$(\\nabla u_{h}^{\\star} - \\nabla u, \\nabla w)_{K} = 0$$\n这可以简化为：\n$$(\\nabla (u_{h}^{\\star} - u), \\nabla w)_{K} = 0, \\quad \\forall w \\in \\mathcal{P}_{2}(K)$$\n让我们将后处理解的误差定义为 $e_u^\\star = u_h^\\star - u$。方程变为：\n$$(\\nabla e_u^\\star, \\nabla w)_{K} = 0, \\quad \\forall w \\in \\mathcal{P}_{2}(K)$$\n我们知道精确解 $u(x,y) = x^2+y^2$ 是一个二次多项式，所以 $u \\in \\mathcal{P}_{2}(K)$。后处理解 $u_h^\\star$ 也在空间 $\\mathcal{P}_{2}(K)$ 中寻找。因此，它们的差，即误差 $e_u^\\star$，也必须是 $\\mathcal{P}_{2}(K)$ 中的一个多项式。\n\n由于 $e_u^\\star \\in \\mathcal{P}_{2}(K)$，我们可以自由选择测试函数 $w$ 为 $e_u^\\star$ 本身。进行此代换，我们得到：\n$$(\\nabla e_u^\\star, \\nabla e_u^\\star)_{K} = 0$$\n这个内积是 $e_u^\\star$ 梯度 $L^2$-范数的平方的定义：\n$$\\int_{K} |\\nabla e_u^\\star|^2 \\,\\mathrm{d}\\boldsymbol{x} = 0$$\n被积函数 $|\\nabla e_u^\\star|^2$ 是一个非负连续函数。要使其在具有正测度（面积 Area$(K)=1$）的区域 $K$ 上的积分为零，被积函数必须在整个 $K$ 上恒等于零。\n$$|\\nabla e_u^\\star(\\boldsymbol{x})|^2 = 0 \\quad \\forall \\boldsymbol{x} \\in K$$\n这意味着梯度本身必须在 $K$ 的任何地方都是零向量：\n$$\\nabla e_u^\\star(\\boldsymbol{x}) = \\boldsymbol{0} \\quad \\forall \\boldsymbol{x} \\in K$$\n在一个连通区域上梯度处处为零的函数在该区域上必为常数。因此，对于某个实常数 $C$，有 $e_u^\\star(\\boldsymbol{x}) = C$。\n回顾 $e_u^\\star$ 的定义，我们有 $u_h^\\star(\\boldsymbol{x}) - u(\\boldsymbol{x}) = C$，或者 $u_h^\\star(\\boldsymbol{x}) = u(\\boldsymbol{x}) + C$。\n\n为了确定常数 $C$ 的值，我们现在应用第二个条件，即平均值约束：\n$$\\int_{K} u_{h}^{\\star} \\,\\mathrm{d}\\boldsymbol{x} = \\int_{K} u \\,\\mathrm{d}\\boldsymbol{x}$$\n将 $u_h^\\star = u+C$ 代入此方程得到：\n$$\\int_{K} (u(\\boldsymbol{x}) + C) \\,\\mathrm{d}\\boldsymbol{x} = \\int_{K} u(\\boldsymbol{x}) \\,\\mathrm{d}\\boldsymbol{x}$$\n左边的积分可以拆分为：\n$$\\int_{K} u(\\boldsymbol{x}) \\,\\mathrm{d}\\boldsymbol{x} + \\int_{K} C \\,\\mathrm{d}\\boldsymbol{x} = \\int_{K} u(\\boldsymbol{x}) \\,\\mathrm{d}\\boldsymbol{x}$$\n从两边减去 $\\int_K u(\\boldsymbol{x}) d\\boldsymbol{x}$，剩下：\n$$\\int_{K} C \\,\\mathrm{d}\\boldsymbol{x} = 0$$\n$$C \\int_{K} \\,\\mathrm{d}\\boldsymbol{x} = 0$$\n积分 $\\int_K d\\boldsymbol{x}$ 代表区域 $K = [0,1] \\times [0,1]$ 的面积，即 $1$。\n$$C \\cdot 1 = 0 \\implies C=0$$\n由于常数 $C$ 为零，误差 $e_u^\\star$ 恒等于零。因此，后处理解与精确解相同：\n$$u_h^\\star(\\boldsymbol{x}) = u(\\boldsymbol{x})$$\n代入给定的 $u(x,y)$ 表达式：\n$$u_h^\\star(x,y) = x^2 + y^2$$\n\n最后，我们验证此结果的性质。推导出的解 $u_h^\\star(x,y) = x^2 + y^2$ 是一个总次数为 2 的多项式，这与 $u_h^\\star \\in \\mathcal{P}_{k+1}(K) = \\mathcal{P}_{2}(K)$ 的要求一致。结果 $u_h^\\star=u$ 展示了 HDG 后处理在这种特定情况下的精确性。这是一个已知的理论结果：对于单个单元，如果精确解 $u$ 是一个次数至多为 $k+1$ 的多项式（此处，$u \\in \\mathcal{P}_2$ 且 $k=1$），那么后处理解 $u_h^\\star$ 是精确的。我们的推导证实了这种超收敛性质。", "answer": "$$\n\\boxed{x^2 + y^2}\n$$", "id": "3410138"}, {"introduction": "在掌握了标准后处理的基础上，本练习旨在探索如何针对更复杂的物理问题调整该技术。我们将研究一个带有强对流的各向异性扩散问题，并推导一个使用加权投影的修正后处理算子。这个练习将帮助你理解如何通过改变投影的范数来定制数值方法，从而更有效地处理特定的物理挑战，并深入了解误差各向异性的控制。[@problem_id:3410083]", "problem": "考虑在单个单元 $K \\subset \\mathbb{R}^{2}$ 上的标量对流扩散模型问题，其中对流场 $\\boldsymbol{\\beta} \\in \\mathbb{R}^{2}$ 为常数，扩散系数 $\\epsilon > 0$。令可杂交间断伽辽金 (HDG) 方法在单元 $K$ 上产生一个梯度（记为 $\\boldsymbol{q}_{h}$）的单元局部近似，其多项式次数为 $k$。经典的超收敛后处理通过将 $u^{\\star} \\in \\mathcal{P}_{k+1}(K)$ 定义为唯一的零均值多项式，使其针对 $\\mathcal{P}_{k+1}(K)$ 中所有零均值的测试函数满足一个梯度匹配变分条件，从而将解的次数提升到 $k+1$。\n\n在各向异性对流扩散问题中，考虑一个由与 $\\boldsymbol{\\beta}$ 对齐的加权投影定义的修正后处理算子。引入对称正定权重矩阵\n$$\n\\mathbf{M} \\;=\\; \\mathbf{I} \\;+\\; \\gamma \\,\\frac{\\boldsymbol{\\beta}\\,\\boldsymbol{\\beta}^{\\top}}{|\\boldsymbol{\\beta}|^{2}},\n$$\n其中 $\\gamma \\ge 0$，并定义零均值的 $u^{\\star} \\in \\mathcal{P}_{k+1}(K)$ 对任意零均值的 $v \\in \\mathcal{P}_{k+1}(K)$ 满足\n$$\n\\int_{K} \\big( \\mathbf{M}\\,\\nabla u^{\\star} \\big)\\cdot \\nabla v \\, \\mathrm{d}\\boldsymbol{x} \\;=\\; \\int_{K} \\big( \\mathbf{M}\\,\\boldsymbol{q}_{h} \\big)\\cdot \\nabla v \\, \\mathrm{d}\\boldsymbol{x}.\n$$\n从 $\\mathcal{P}_{k+1}(K)$、正交性和加权 $L^2$ 投影的定义出发，推导上述算子，并将其具体化到参考单元 $K = [0,1]^{2}$ 上，其中常数 $\\boldsymbol{\\beta} = (1,0)^{\\top}$，从而得到\n$$\n\\mathbf{M} \\;=\\; \\begin{pmatrix} 1+\\gamma  0 \\\\ 0  1 \\end{pmatrix}.\n$$\n令 $k=1$，使得 $u^{\\star} \\in \\mathcal{P}_{2}(K)$，并假设 HDG 梯度近似为如下线性场\n$$\n\\boldsymbol{q}_{h}(x,y) \\;=\\; \\begin{pmatrix} \\mu\\,x + \\nu\\,y \\\\ \\rho\\,x + \\sigma\\,y \\end{pmatrix},\n$$\n其中 $\\mu, \\nu, \\rho, \\sigma$ 为给定的实系数。将 $u^{\\star}$ 参数化为\n$$\nu^{\\star}(x,y) \\;=\\; \\tfrac{1}{2}\\,a\\,x^{2} \\;+\\; b\\,x\\,y \\;+\\; \\tfrac{1}{2}\\,c\\,y^{2} \\;+\\; d\\,x \\;+\\; e\\,y \\;+\\; g,\n$$\n并施加零均值约束 $\\int_{K} u^{\\star}\\,\\mathrm{d}\\boldsymbol{x} = 0$ 来确定 $g$。仅利用多项式空间、加权投影和混合偏导数对称性的基本性质，通过最小化加权残差泛函来推导系数 $a,b,c,d,e$ 的法方程\n$$\nJ(a,b,c,d,e) \\;=\\; \\int_{K} \\Big( \\nabla u^{\\star}(x,y) \\;-\\; \\boldsymbol{q}_{h}(x,y) \\Big)^{\\top} \\mathbf{M} \\Big( \\nabla u^{\\star}(x,y) \\;-\\; \\boldsymbol{q}_{h}(x,y) \\Big)\\,\\mathrm{d}\\boldsymbol{x}.\n$$\n显式求解这些方程，并给出交叉项系数 $b$ 关于 $\\gamma$、$\\nu$ 和 $\\rho$ 的闭式解析表达式。最后，根据你的推导，提出一个假设，说明增加 $\\gamma$ 如何影响后处理误差沿 $\\boldsymbol{\\beta}$ 方向和垂直于 $\\boldsymbol{\\beta}$ 方向的各向异性。您的最终答案必须是所要求的 $b$ 作为 $\\gamma$、$\\nu$ 和 $\\rho$ 的函数的表达式。", "solution": "用户提供了一个数值分析领域的问题，具体涉及可杂交间断伽辽金 (HDG) 方法的后处理技术。我将首先验证问题陈述，然后进行完整推导。\n\n### 第一步：提取已知条件\n- **模型问题**：在单元 $K \\subset \\mathbb{R}^{2}$ 上的标量对流扩散问题。\n- **参数**：恒定对流场 $\\boldsymbol{\\beta} \\in \\mathbb{R}^{2}$，扩散系数 $\\epsilon > 0$。\n- **HDG 近似**：单元局部梯度近似 $\\boldsymbol{q}_{h}$，在 $K$ 上为 $k$ 次多项式。\n- **后处理解**：$u^{\\star} \\in \\mathcal{P}_{k+1}(K)$，具有零均值，$\\int_K u^{\\star} \\, \\mathrm{d}\\boldsymbol{x} = 0$。\n- **权重矩阵**：$\\mathbf{M} = \\mathbf{I} + \\gamma \\frac{\\boldsymbol{\\beta}\\,\\boldsymbol{\\beta}^{\\top}}{|\\boldsymbol{\\beta}|^{2}}$，其中 $\\gamma \\geq 0$。\n- **变分形式**：对任意零均值的 $v \\in \\mathcal{P}_{k+1}(K)$，\n$$ \\int_{K} \\big( \\mathbf{M}\\,\\nabla u^{\\star} \\big)\\cdot \\nabla v \\, \\mathrm{d}\\boldsymbol{x} = \\int_{K} \\big( \\mathbf{M}\\,\\boldsymbol{q}_{h} \\big)\\cdot \\nabla v \\, \\mathrm{d}\\boldsymbol{x}. $$\n- **最小化泛函**：$J(a,b,c,d,e) = \\int_{K} \\Big( \\nabla u^{\\star}(x,y) - \\boldsymbol{q}_{h}(x,y) \\Big)^{\\top} \\mathbf{M} \\Big( \\nabla u^{\\star}(x,y) - \\boldsymbol{q}_{h}(x,y) \\Big)\\,\\mathrm{d}\\boldsymbol{x}$。\n- **具体化**：\n    - 参考单元：$K = [0,1]^{2}$。\n    - 对流场：$\\boldsymbol{\\beta} = (1,0)^{\\top}$。\n    - 得到的权重矩阵：$\\mathbf{M} = \\begin{pmatrix} 1+\\gamma  0 \\\\ 0  1 \\end{pmatrix}$。\n    - 多项式次数：$k=1$，因此 $u^{\\star} \\in \\mathcal{P}_{2}(K)$。\n- **参数化**：\n    - HDG 梯度：$\\boldsymbol{q}_{h}(x,y) = \\begin{pmatrix} \\mu\\,x + \\nu\\,y \\\\ \\rho\\,x + \\sigma\\,y \\end{pmatrix}$。\n    - 后处理解：$u^{\\star}(x,y) = \\frac{1}{2}\\,a\\,x^{2} + b\\,x\\,y + \\frac{1}{2}\\,c\\,y^{2} + d\\,x + e\\,y + g$。\n\n### 第二步：使用提取的已知条件进行验证\n该问题具有科学依据，位于有限元方法和逼近理论等成熟的数学框架之内。HDG 方法、多项式空间、加权投影和变分原理等概念在计算数学中是标准的。这是一个适定的问题；它要求通过最小化一个二次泛函来推导系数，这个过程会导出一个适定的线性方程组。其语言客观、正式且精确。没有矛盾、信息缺失或伪科学主张。该问题是应用数学中一个有效且非平凡的练习。\n\n### 第三步：结论与行动\n问题有效。我将开始推导。\n\n### 推导\n该问题要求通过最小化泛函 $J$ 来推导后处理解 $u^{\\star}$ 的系数的法方程，然后求解系数 $b$。所提供的变分形式是与二次泛函 $J$ 最小化问题相关联的欧拉-拉格朗日方程。对 $J$ 关于其参数 $(a,b,c,d,e)$ 进行最小化，等价于寻找其驻点，即 $J$ 对每个参数的偏导数都为零的点。\n\n首先，我们表示 $u^{\\star}$ 的梯度：\n$$ \\nabla u^{\\star}(x,y) = \\begin{pmatrix} \\partial_x u^{\\star} \\\\ \\partial_y u^{\\star} \\end{pmatrix} = \\begin{pmatrix} a\\,x + b\\,y + d \\\\ b\\,x + c\\,y + e \\end{pmatrix} $$\n误差向量 $\\boldsymbol{\\delta} = \\nabla u^{\\star} - \\boldsymbol{q}_h$ 为：\n$$ \\boldsymbol{\\delta}(x,y) = \\begin{pmatrix} (a-\\mu)x + (b-\\nu)y + d \\\\ (b-\\rho)x + (c-\\sigma)y + e \\end{pmatrix} $$\n待最小化的泛函 $J$ 是该误差的加权平方范数在定义域 $K = [0,1]^2$ 上的积分：\n$$ J = \\int_0^1 \\int_0^1 \\boldsymbol{\\delta}^{\\top} \\mathbf{M} \\boldsymbol{\\delta} \\,\\mathrm{d}x\\,\\mathrm{d}y $$\n代入 $\\boldsymbol{\\delta}$ 和 $\\mathbf{M}$ 的表达式：\n$$ J = \\int_K \\left[ (1+\\gamma)\\big((a-\\mu)x + (b-\\nu)y + d\\big)^2 + \\big((b-\\rho)x + (c-\\sigma)y + e\\big)^2 \\right] \\mathrm{d}\\boldsymbol{x} $$\n通过将 $J$ 对五个系数 $a, b, c, d, e$ 中每一个的偏导数设为零，即可得到法方程。我们利用恒等式 $\\int_0^1 \\int_0^1 x^i y^j \\,\\mathrm{d}x\\,\\mathrm{d}y = \\frac{1}{(i+1)(j+1)}$。\n\n1.  $\\frac{\\partial J}{\\partial a} = 0$:\n    $$ \\int_K 2(1+\\gamma)\\big((a-\\mu)x + (b-\\nu)y + d\\big)x \\, \\mathrm{d}\\boldsymbol{x} = 0 $$\n    $$ \\int_K \\big(ax^2 + bxy + dx\\big) \\, \\mathrm{d}\\boldsymbol{x} = \\int_K \\big(\\mu x^2 + \\nu xy\\big) \\, \\mathrm{d}\\boldsymbol{x} $$\n    $$ a\\frac{1}{3} + b\\frac{1}{4} + d\\frac{1}{2} = \\mu\\frac{1}{3} + \\nu\\frac{1}{4} \\quad (1) $$\n\n2.  $\\frac{\\partial J}{\\partial c} = 0$:\n    $$ \\int_K 2\\big((b-\\rho)x + (c-\\sigma)y + e\\big)y \\, \\mathrm{d}\\boldsymbol{x} = 0 $$\n    $$ \\int_K \\big(bxy + cy^2 + ey\\big) \\, \\mathrm{d}\\boldsymbol{x} = \\int_K \\big(\\rho xy + \\sigma y^2\\big) \\, \\mathrm{d}\\boldsymbol{x} $$\n    $$ b\\frac{1}{4} + c\\frac{1}{3} + e\\frac{1}{2} = \\rho\\frac{1}{4} + \\sigma\\frac{1}{3} \\quad (2) $$\n\n3.  $\\frac{\\partial J}{\\partial d} = 0$:\n    $$ \\int_K 2(1+\\gamma)\\big((a-\\mu)x + (b-\\nu)y + d\\big) \\, \\mathrm{d}\\boldsymbol{x} = 0 $$\n    $$ \\int_K \\big(ax + by + d\\big) \\, \\mathrm{d}\\boldsymbol{x} = \\int_K \\big(\\mu x + \\nu y\\big) \\, \\mathrm{d}\\boldsymbol{x} $$\n    $$ a\\frac{1}{2} + b\\frac{1}{2} + d = \\mu\\frac{1}{2} + \\nu\\frac{1}{2} \\quad (3) $$\n\n4.  $\\frac{\\partial J}{\\partial e} = 0$:\n    $$ \\int_K 2\\big((b-\\rho)x + (c-\\sigma)y + e\\big) \\, \\mathrm{d}\\boldsymbol{x} = 0 $$\n    $$ \\int_K \\big(bx + cy + e\\big) \\, \\mathrm{d}\\boldsymbol{x} = \\int_K \\big(\\rho x + \\sigma y\\big) \\, \\mathrm{d}\\boldsymbol{x} $$\n    $$ b\\frac{1}{2} + c\\frac{1}{2} + e = \\rho\\frac{1}{2} + \\sigma\\frac{1}{2} \\quad (4) $$\n我们可以简化这个方程组。从 (3) 中，我们解出 $d$：$d = \\frac{1}{2}(\\mu+\\nu-a-b)$。将其代入 (1) 中：\n$$ \\frac{a}{3} + \\frac{b}{4} + \\frac{1}{4}(\\mu+\\nu-a-b) = \\frac{\\mu}{3} + \\frac{\\nu}{4} $$\n$$ \\left(\\frac{1}{3}-\\frac{1}{4}\\right)a + \\left(\\frac{1}{4}-\\frac{1}{4}\\right)b = \\left(\\frac{1}{3}-\\frac{1}{4}\\right)\\mu + \\left(\\frac{1}{4}-\\frac{1}{4}\\right)\\nu $$\n$$ \\frac{a}{12} = \\frac{\\mu}{12} \\implies a = \\mu $$\n类似地，从 (4) 中，我们解出 $e$：$e = \\frac{1}{2}(\\rho+\\sigma-b-c)$。将其代入 (2) 中：\n$$ \\frac{b}{4} + \\frac{c}{3} + \\frac{1}{4}(\\rho+\\sigma-b-c) = \\frac{\\rho}{4} + \\frac{\\sigma}{3} $$\n$$ \\left(\\frac{1}{4}-\\frac{1}{4}\\right)b + \\left(\\frac{1}{3}-\\frac{1}{4}\\right)c = \\left(\\frac{1}{4}-\\frac{1}{4}\\right)\\rho + \\left(\\frac{1}{3}-\\frac{1}{4}\\right)\\sigma $$\n$$ \\frac{c}{12} = \\frac{\\sigma}{12} \\implies c = \\sigma $$\n$a=\\mu$ 和 $c=\\sigma$ 这两个结果非常简洁。它们表明，后处理从 HDG 梯度近似的相应项中精确地恢复了二阶纯导数项的系数。\n\n现在我们通过计算 $\\frac{\\partial J}{\\partial b} = 0$ 来推导关于 $b$ 的方程：\n$$ \\frac{\\partial J}{\\partial b} = \\int_K \\left[ 2(1+\\gamma)\\big((a-\\mu)x + (b-\\nu)y + d\\big)y + 2\\big((b-\\rho)x + (c-\\sigma)y + e\\big)x \\right] \\mathrm{d}\\boldsymbol{x} = 0 $$\n代入 $a=\\mu$ 和 $c=\\sigma$，方程简化为：\n$$ \\int_K \\left[ (1+\\gamma)\\big((b-\\nu)y + d\\big)y + \\big((b-\\rho)x + e\\big)x \\right] \\mathrm{d}\\boldsymbol{x} = 0 $$\n$$ (1+\\gamma)\\int_K \\big((b-\\nu)y^2 + dy\\big)\\mathrm{d}\\boldsymbol{x} + \\int_K \\big((b-\\rho)x^2 + ex\\big)\\mathrm{d}\\boldsymbol{x} = 0 $$\n$$ (1+\\gamma)\\left( (b-\\nu)\\frac{1}{3} + d\\frac{1}{2} \\right) + \\left( (b-\\rho)\\frac{1}{3} + e\\frac{1}{2} \\right) = 0 \\quad (5) $$\n我们有 $d$ 和 $e$ 关于 $b$ 的显式形式。当 $a=\\mu$ 时，方程 (3) 给出 $d = \\frac{1}{2}(\\nu-b)$。当 $c=\\sigma$ 时，方程 (4) 给出 $e = \\frac{1}{2}(\\rho-b)$。将这些代入 (5) 中：\n$$ (1+\\gamma)\\left( (b-\\nu)\\frac{1}{3} + \\frac{1}{2}\\frac{\\nu-b}{2} \\right) + \\left( (b-\\rho)\\frac{1}{3} + \\frac{1}{2}\\frac{\\rho-b}{2} \\right) = 0 $$\n$$ (1+\\gamma)\\left( \\frac{b}{3} - \\frac{\\nu}{3} + \\frac{\\nu}{4} - \\frac{b}{4} \\right) + \\left( \\frac{b}{3} - \\frac{\\rho}{3} + \\frac{\\rho}{4} - \\frac{b}{4} \\right) = 0 $$\n合并括号内的项：\n$$ (1+\\gamma)\\left( \\frac{b}{12} - \\frac{\\nu}{12} \\right) + \\left( \\frac{b}{12} - \\frac{\\rho}{12} \\right) = 0 $$\n乘以 12：\n$$ (1+\\gamma)(b-\\nu) + (b-\\rho) = 0 $$\n$$ b + \\gamma b - \\nu - \\gamma\\nu + b - \\rho = 0 $$\n$$ b(2+\\gamma) = \\nu(1+\\gamma) + \\rho $$\n解出 $b$：\n$$ b = \\frac{(1+\\gamma)\\nu + \\rho}{2+\\gamma} $$\n\n最后，我们以所要求的假设作结。系数 $b$ 代表混合偏导数 $\\partial_{xy}^2 u^{\\star}$。项 $\\nu = \\partial_y q_x$ 和 $\\rho = \\partial_x q_y$ 是来自 HDG 梯度 $\\boldsymbol{q}_h$ 的相应（且通常不相等）的混合导数。$b$ 的表达式可以写成加权平均的形式：\n$$ b = \\left(\\frac{1+\\gamma}{2+\\gamma}\\right)\\nu + \\left(\\frac{1}{2+\\gamma}\\right)\\rho $$\n当 $\\gamma=0$ 时，$\\mathbf{M}=\\mathbf{I}$（各向同性加权），$b = \\frac{\\nu+\\rho}{2}$，即算术平均值。当 $\\gamma \\to \\infty$ 时，$\\nu$ 的权重趋近于 1，而 $\\rho$ 的权重趋近于 0，因此 $b \\to \\nu$。\n参数 $\\gamma$ 控制投影的各向异性。项 $(1+\\gamma)$ 对平行于 $\\boldsymbol{\\beta}=(1,0)^\\top$ 的梯度分量的误差（即 $\\partial_x u^\\star - q_x$）进行加权。增加 $\\gamma$ 会严重惩罚该误差分量，迫使 $\\nabla u^\\star$ 相比于 HDG 梯度的 $y$ 分量 $q_y$ 更信任其 $x$ 分量 $q_x$。因此，$\\partial_x u^{\\star}$ 的性质（例如它关于 $y$ 的导数，即 $b$）被驱动去匹配 $q_x$ 的性质（其关于 $y$ 的导数为 $\\nu$）。\n假设：增加 $\\gamma$ 会通过优先减少沿对流方向 $\\boldsymbol{\\beta}$ 的误差分量，而不是横向的误差分量，从而在后处理中引入各向异性。这迫使后处理解的梯度更紧密地匹配与 $\\boldsymbol{\\beta}$ 对齐的 HDG 梯度分量，其代价可能是与 HDG 梯度的横向分量产生更大的差异。这使得后处理误差本身具有各向异性，其量级可能沿 $\\boldsymbol{\\beta}$ 方向较小，而在垂直于 $\\boldsymbol{\\beta}$ 的方向上较大。", "answer": "$$\\boxed{\\frac{(1+\\gamma)\\nu + \\rho}{2+\\gamma}}$$", "id": "3410083"}, {"introduction": "见证了单次后处理步骤的威力后，一个自然的问题是：我们能否通过重复这个过程来获得更高的精度？本计算实践将指导你实现一个多层级的后处理方案。你将通过数值实验来研究，与单次后处理相比，这种迭代增强方法是否能带来收敛阶的进一步提升，或者其效益是否在第一步之后就已饱和。[@problem_id:3410140]", "problem": "考虑区间 $\\Omega = [0,1]$ 上的标量泊松模型问题，其边界条件为齐次狄利克雷边界条件，精确解为光滑函数 $u(x) = \\sin(2\\pi x)$。控制方程为 $-\\Delta u = f$，其中 $f(x) = (2\\pi)^2\\sin(2\\pi x)$，精确通量为 $q(x) = -\\nabla u(x) = -2\\pi\\cos(2\\pi x)$。在一维空间中，$\\nabla$ 和 $\\Delta$ 分别简化为 $\\mathrm{d}/\\mathrm{d}x$ 和 $\\mathrm{d}^2/\\mathrm{d}x^2$。\n\n您将从第一性原理出发，研究可杂交间断伽辽金（HDG）方法中为达到超收敛的后处理。此构造必须遵循以下基本基底和定义：通过分部积分推导出的弱形式、局部多项式逼近空间以及到多项式空间上的 $L^2$ 投影。除了这些基本原理外，不允许使用任何快捷公式或外部恒等式。\n\n设区域被划分为一个包含 $N$ 个单元 $K = [x_i,x_{i+1}]$ 的均匀网格，其中 $x_i = i/N$，对于 $i=0,\\dots,N$。对于给定的多项式次数 $k \\in \\mathbb{N}_0$，按如下方式定义单元上的离散场。\n\n1. 在每个单元 $K$ 上，分别定义次数至多为 $k$ 和 $k+1$ 的多项式的局部逼近空间 $\\mathcal{P}^k(K)$ 和 $\\mathcal{P}^{k+1}(K)$。在参考区间上使用勒让德多项式基，并通过标准仿射映射到每个 $K$ 上进行计算。\n\n2. 构造一个单元上的逼近 $u_h \\in \\mathcal{P}^k(K)$，作为精确解的 $L^2$ 投影，即对于每个 $K$ 和所有 $v \\in \\mathcal{P}^k(K)$，\n$(u_h,v)_K = (u,v)_K,$\n其中 $(\\cdot,\\cdot)_K$ 表示 $L^2(K)$ 内积。同样地，构造一个单元上的通量逼近 $q_h \\in \\mathcal{P}^k(K)$，作为精确通量 $q$ 的 $L^2$ 投影，即对于所有 $w \\in \\mathcal{P}^k(K)$，\n$(q_h,w)_K = (q,w)_K.$\n\n3. 通过在每个单元 $K$ 上求解弱形式的诺伊曼问题来定义标准的 HDG 局部后处理 $u^\\star \\in \\mathcal{P}^{k+1}(K)$。该弱形式通过分部积分推导，并使用投影通量 $q_h$ 作为数值边界通量。具体来说，寻找 $u^\\star \\in \\mathcal{P}^{k+1}(K)$，使得对于所有在 $K$ 上零均值的 $v \\in \\mathcal{P}^{k+1}(K)$，\n$$(\\nabla u^\\star,\\nabla v)_K = -(f,v)_K + \\langle q_h \\cdot n, v \\rangle_{\\partial K},$$\n并强制执行均值约束\n$$\\frac{1}{|K|}\\int_K u^\\star \\,\\mathrm{d}x = \\frac{1}{|K|}\\int_K u_h \\,\\mathrm{d}x.$$\n此处，$n$ 是 $\\partial K$ 上的外单位法向量，$\\langle \\cdot,\\cdot \\rangle_{\\partial K}$ 表示单元边界上的 $L^2$ 对偶配对。\n\n4. 设计一个多级后处理：计算一个二级后处理解 $u^{\\star\\star} \\in \\mathcal{P}^{k+1}(K)$，方法是重新应用局部后处理，但这次使用从一级后处理解的梯度中获得的更新后的数值边界通量，即 $q^\\star := -\\nabla u^\\star$。也就是说，寻找 $u^{\\star\\star} \\in \\mathcal{P}^{k+1}(K)$，使得对于所有在 $K$ 上零均值的 $v \\in \\mathcal{P}^{k+1}(K)$，\n$$(\\nabla u^{\\star\\star},\\nabla v)_K = -(f,v)_K + \\langle q^\\star \\cdot n, v \\rangle_{\\partial K},$$\n并强制执行均值约束\n$$\\frac{1}{|K|}\\int_K u^{\\star\\star} \\,\\mathrm{d}x = \\frac{1}{|K|}\\int_K u^\\star \\,\\mathrm{d}x.$$\n\n这种构造在每个 $K$ 上是纯局部的，并且仅依赖于 $L^2$ 投影和分部积分，不使用全局杂交迹。\n\n您的任务是实现这整个流程，并通过数值分析来检验通过二级后处理的迭代增强是否相比一级后处理能带来任何进一步的阶数增益，或者它是否会饱和。您必须计算 $u_h$、$u^\\star$ 和 $u^{\\star\\star}$ 相对于精确解的 $L^2(\\Omega)$ 误差，并通过网格加密来估计观测到的收敛阶。\n\n实现与测试协议：\n\n- 使用包含 $N \\in \\{8,16,32,64\\}$ 个单元的网格。使用多项式次数 $k \\in \\{0,1,2\\}$。\n- 对于数值积分，使用足够高阶的高斯求积法，以避免由求积引起的误差。所有积分必须根据上述定义进行数值计算并保持一致。\n- 对于每个固定的 $k$，计算在 $N \\in \\{8,16,32,64\\}$ 时 $u_h$、$u^\\star$ 和 $u^{\\star\\star}$ 的 $L^2$ 误差。然后，对于每个连续的加密对 $(N,2N)$，计算成对的观测阶数\n$$p = \\log_2\\left(\\frac{e_N}{e_{2N}}\\right),$$\n并报告 $u_h$、$u^\\star$ 和 $u^{\\star\\star}$ 各自的这些成对阶数的平均值。\n- 对于每个 $k$，还要计算一个布尔标志，当且仅当 $u^{\\star\\star}$ 的观测阶数超过 $u^\\star$ 的观测阶数 0.2 以上时，该标志为真，否则为假。\n\n您的程序必须输出单行内容，其中包含一个用方括号括起来的逗号分隔列表，按 $k \\in \\{0,1,2\\}$ 三个次数的顺序排列：\n- $u_h$ 的平均观测阶数（四舍五入到三位小数），\n- $u^\\star$ 的平均观测阶数（四舍五入到三位小数），\n- $u^{\\star\\star}$ 的平均观测阶数（四舍五入到三位小数），\n- 上述的布尔标志。\n\n因此，最终输出必须是一个包含 12 个条目的扁平列表，按 $k$ 的递增顺序排列，即 $[o_{h}^{(k=0)},o_{\\star}^{(k=0)},o_{\\star\\star}^{(k=0)},\\mathrm{flag}_{k=0},o_{h}^{(k=1)},o_{\\star}^{(k=1)},o_{\\star\\star}^{(k=1)},\\mathrm{flag}_{k=1},o_{h}^{(k=2)},o_{\\star}^{(k=2)},o_{\\star\\star}^{(k=2)},\\mathrm{flag}_{k=2}]$，其中每个 $o$ 是一个如上指定的小数，每个 flag 是一个布尔值。您的程序应生成单行输出，包含以方括号括起来的逗号分隔列表形式的结果（例如，$[1.234,2.345,3.456,\\mathrm{True},\\dots]$）。不允许用户输入；所有参数均如上固定。", "solution": "该问题要求对应用于一维泊松模型问题的可杂交间断伽辽金（HDG）方法的多级后处理技术进行数值研究。我们必须首先验证问题陈述。该问题提供了一个明确定义的数学背景：在指定区域 $\\Omega = [0,1]$ 上的标量泊松方程，一个光滑的精确解 $u(x) = \\sin(2\\pi x)$ 及其对应的源项 $f(x)$ 和通量 $q(x)$，以及齐次狄利克雷边界条件。数值流程也已详细说明，定义了局部多项式逼近空间 $\\mathcal{P}^k(K)$，通过 $L^2$ 投影构造初始逼近 $u_h$ 和 $q_h$，以及两个连续的局部后处理步骤来计算 $u^\\star$ 和 $u^{\\star\\star}$。网格加密、误差计算和收敛阶估计的协议是明确且无歧义的。该问题在偏微分方程数值方法的理论中有科学依据，是适定的、客观的且内部一致的。未发现任何缺陷。因此，我们可以着手解决问题。\n\n任务的核心是在区域 $\\Omega$ 的均匀网格的每个单元 $K$ 上实现指定的局部过程。\n\n### 1. 准备工作：参考单元和基底\n所有计算都在参考区间 $\\hat{K} = [-1, 1]$ 上进行，并通过仿射变换 $x(\\xi) = x_i + \\frac{h}{2}(\\xi+1)$ 映射到宽度为 $h = 1/N$ 的物理单元 $K = [x_i, x_{i+1}]$ 上。该映射的雅可比行列式为 $\\frac{\\mathrm{d}x}{\\mathrm{d}\\xi} = \\frac{h}{2}$。空间导数变换为 $\\frac{\\mathrm{d}}{\\mathrm{d}x} = \\frac{2}{h}\\frac{\\mathrm{d}}{\\mathrm{d}\\xi}$。\n我们使用勒让德多项式 $\\{P_j(\\xi)\\}_{j \\ge 0}$ 作为多项式空间的基底。函数 $p \\in \\mathcal{P}^m(K)$ 表示为截断级数 $p(x(\\xi)) = \\sum_{j=0}^{m} c_j P_j(\\xi)$，其中 $\\mathbf{c} \\in \\mathbb{R}^{m+1}$ 是其系数向量。\n在 $K$ 上的积分通过变换到 $\\hat{K}$ 并使用具有点 $\\{\\xi_q\\}_{q=1}^{N_{qp}}$ 和权重 $\\{w_q\\}_{q=1}^{N_{qp}}$ 的 $N_{qp}$ 点高斯-勒让德求积法则来计算：\n$$ \\int_K g(x) \\,\\mathrm{d}x = \\int_{-1}^1 g(x(\\xi)) \\frac{h}{2} \\,\\mathrm{d}\\xi \\approx \\frac{h}{2} \\sum_{q=1}^{N_{qp}} w_q g(x(\\xi_q)). $$\n选择足够多的求积点以确保求积误差与离散化误差相比可以忽略不计。\n\n### 2. 精确解的 $L^2$ 投影\n逼近 $u_h \\in \\mathcal{P}^k(K)$ 和 $q_h \\in \\mathcal{P}^k(K)$ 分别定义为精确解 $u$ 和通量 $q$ 的 $L^2$ 投影。$u_h = \\sum_{j=0}^k c_{u_h,j} P_j(\\xi)$ 的系数 $c_{u_h,j}$ 由勒让德基的正交性确定。对于每个 $j \\in \\{0, \\dots, k\\}$，定义关系 $(u_h, P_j)_K = (u, P_j)_K$ 由于对角质量矩阵而简化，其中 $(P_j, P_l)_K = \\frac{h}{2j+1}\\delta_{jl}$。这给出了系数的显式公式：\n$$ c_{u_h,j} = \\frac{(u, P_j)_K}{(P_j, P_j)_K} = \\frac{\\int_K u(x) P_j(\\xi(x)) \\,\\mathrm{d}x}{\\int_K P_j(\\xi(x))^2 \\,\\mathrm{d}x} = \\frac{\\frac{h}{2}\\int_{-1}^1 u(x(\\xi)) P_j(\\xi) \\,\\mathrm{d}\\xi}{\\frac{h}{2j+1}} = \\frac{2j+1}{2} \\int_{-1}^1 u(x(\\xi)) P_j(\\xi) \\,\\mathrm{d}\\xi. $$\n通量逼近 $q_h$ 的系数 $c_{q_h,j}$ 的计算方式类似，只需将 $u$ 替换为 $q$。积分使用数值求积进行评估。\n\n### 3. 获得 $u^\\star$ 的一级后处理\n后处理解 $u^\\star \\in \\mathcal{P}^{k+1}(K)$ 是通过求解一个局部诺伊曼问题得到的。我们将 $u^\\star$ 分解为其均值和零均值部分：\n$$ u^\\star(x(\\xi)) = c_{u^\\star,0} P_0(\\xi) + \\sum_{j=1}^{k+1} c_{u^\\star,j} P_j(\\xi). $$\n均值约束 $\\frac{1}{|K|}\\int_K u^\\star \\,\\mathrm{d}x = \\frac{1}{|K|}\\int_K u_h \\,\\mathrm{d}x$ 直接确定了第零个系数，因为对于 $j \\ge 1$，$\\int_K P_0 \\,\\mathrm{d}x = h$ 且 $\\int_K P_j \\,\\mathrm{d}x = 0$。这得出 $c_{u^\\star,0} = c_{u_h,0}$。\n剩余的系数 $\\{c_{u^\\star,j}\\}_{j=1}^{k+1}$ 从弱形式方程中求得。我们使用基 $\\{P_m\\}_{m=1}^{k+1}$ 作为零均值测试函数空间 $v \\in \\mathcal{P}^{k+1}(K)$ 的基底。对于每个 $m \\in \\{1, \\dots, k+1\\}$，我们求解：\n$$ (\\nabla u^\\star, \\nabla P_m)_K = -(f, P_m)_K + \\langle q_h \\cdot n, P_m \\rangle_{\\partial K}. $$\n展开各项，左手边 (LHS) 变为：\n$$ \\text{LHS} = \\sum_{j=1}^{k+1} c_{u^\\star,j} (\\nabla P_j, \\nabla P_m)_K = \\sum_{j=1}^{k+1} c_{u^\\star,j} \\left( \\frac{2}{h} \\int_{-1}^1 P'_j(\\xi) P'_m(\\xi) \\,\\mathrm{d}\\xi \\right). $$\n右手边 (RHS) 为：\n$$ \\text{RHS} = -\\int_K f(x) P_m(\\xi(x)) \\,\\mathrm{d}x + \\left[ q_h(x) P_m(\\xi(x)) \\right]_{x=x_i}^{x=x_{i+1}} = -(f,P_m)_K + q_h(x_{i+1})P_m(1) - q_h(x_i)P_m(-1). $$\n这构成了一个关于高阶系数 $\\mathbf{c}_{high} = [c_{u^\\star,1}, \\dots, c_{u^\\star,k+1}]^T$ 的 $(k+1) \\times (k+1)$ 线性系统 $\\mathbf{S} \\mathbf{c}_{high} = \\mathbf{F}$，该系统在每个单元上求解。\n\n### 4. 获得 $u^{\\star\\star}$ 的二级后处理\n这一步是前一步的迭代。我们计算一个更新的通量 $q^\\star = -\\nabla u^\\star$，并将其用作新的局部诺伊曼问题的边界数据。解为 $u^{\\star\\star} \\in \\mathcal{P}^{k+1}(K)$。\n$u^\\star$ 的导数给出了参考单元上的新通量：\n$$ q^\\star(\\xi) = -\\frac{\\mathrm{d}u^\\star}{\\mathrm{d}x} = -\\frac{2}{h}\\sum_{j=1}^{k+1} c_{u^\\star,j} P'_j(\\xi). $$\n这是一个在 $\\mathcal{P}^k(\\hat{K})$ 中的多项式，其勒让德系数 $\\{c_{q^\\star,l}\\}_{l=0}^k$ 通过 $L^2$ 投影求得：\n$$ c_{q^\\star,l} = \\frac{2l+1}{2} \\int_{-1}^1 q^\\star(\\xi) P_l(\\xi) \\,\\mathrm{d}\\xi = -\\frac{2l+1}{h} \\sum_{j=1}^{k+1} c_{u^\\star,j} \\int_{-1}^1 P'_j(\\xi) P_l(\\xi) \\,\\mathrm{d}\\xi. $$\n确定了 $q^\\star$ 的系数后，我们就可以在单元边界上对其进行求值。求 $u^{\\star\\star}$ 的过程随后与求 $u^\\star$ 的过程相同，均值约束为 $c_{u^{\\star\\star},0} = c_{u^\\star,0}$，而 RHS 向量 $\\mathbf{F}$ 中的边界项现在使用 $q^\\star$ 而不是 $q_h$。\n\n### 5. 误差分析与收敛阶\n全局 $L^2(\\Omega)$ 误差通过对单元误差的平方求和来计算：\n$$ E^2 = \\|u - u_{approx}\\|_{L^2(\\Omega)}^2 = \\sum_{i=0}^{N-1} \\int_{K_i} (u(x) - u_{approx}(x))^2 \\,\\mathrm{d}x. $$\n单元积分使用高阶求积法计算。对于每种逼近（$u_h, u^\\star, u^{\\star\\star}$），我们在一系列连续加密的网格（$N \\in \\{8, 16, 32, 64\\}$）上计算误差。观测到的收敛阶 $p$ 根据连续网格上的误差 $e_N$ 和 $e_{2N}$ 估计为 $p = \\log_2(e_N/e_{2N})$。最终报告的阶数是这些逐对计算的阶数的平均值。分析的重点是 $u^{\\star\\star}$ 的阶数是否比 $u^\\star$ 的阶数有显著提升，或者该过程是否饱和，这将由 $p_{\\star\\star} \\approx p_{\\star}$ 来表明。标准的 HDG 理论预测 $p_h \\approx k+1$，而后处理解具有超收敛性，即 $p_\\star \\approx k+2$。理论上不期望迭代应用会进一步提高收敛阶。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import lpn, eval_legendre\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Implements the HDG post-processing pipeline and analyzes convergence orders.\n    \"\"\"\n\n    # --- Problem Definition ---\n    exact_u = lambda x: np.sin(2 * np.pi * x)\n    exact_q = lambda x: -2 * np.pi * np.cos(2 * np.pi * x)\n    f_source = lambda x: (2 * np.pi)**2 * np.sin(2 * np.pi * x)\n\n    # --- Numerical Parameters ---\n    k_vals = [0, 1, 2]\n    N_vals = [8, 16, 32, 64]\n    \n    final_results = []\n\n    for k in k_vals:\n        errors_h_list = []\n        errors_star_list = []\n        errors_starstar_list = []\n\n        num_qp = 2 * (k + 1) + 5\n        qp, w_qp = leggauss(num_qp)\n\n        # Pre-compute Legendre polynomial values at quadrature points\n        P_vals_at_qp, P_derivs_at_qp = lpn(k + 1, qp)\n        \n        # Pre-compute reference matrices\n        # S_{ij} = integral(P_{i+1}' * P_{j+1}') for i,j=0..k\n        stiff_mat_ref = np.zeros((k + 1, k + 1))\n        if k + 1 > 0:\n            P_deriv_high = P_derivs_at_qp[1:, :]\n            stiff_mat_ref = P_deriv_high @ np.diag(w_qp) @ P_deriv_high.T\n        \n        # C_{li} = integral(P_{i+1}' * P_l) for l=0..k, i=0..k\n        proj_mat_q_star = np.zeros((k + 1, k + 1))\n        if k + 1 > 0:\n            P_deriv_high = P_derivs_at_qp[1:, :]\n            P_low = P_vals_at_qp[:k+1, :]\n            proj_mat_q_star = P_low @ np.diag(w_qp) @ P_deriv_high.T\n\n\n        for N in N_vals:\n            h = 1.0 / N\n            total_err_h_sq = 0.0\n            total_err_star_sq = 0.0\n            total_err_starstar_sq = 0.0\n\n            for i_elem in range(N):\n                x_left = i_elem * h\n                x_qp = x_left + h/2 * (qp + 1)\n\n                # --- 1. Compute u_h and q_h (L2 projections) ---\n                # Coeffs c for u_h in P^k\n                uh_integrand = exact_u(x_qp)\n                numerators_uh = h/2 * (P_vals_at_qp[:k+1, :] @ (w_qp * uh_integrand))\n                denominators_k = h / (2 * np.arange(k + 1) + 1)\n                c_uh = numerators_uh / denominators_k\n\n                # Coeffs d for q_h in P^k\n                qh_integrand = exact_q(x_qp)\n                numerators_qh = h/2 * (P_vals_at_qp[:k+1, :] @ (w_qp * qh_integrand))\n                c_qh = numerators_qh / denominators_k\n\n                # --- 2. Compute u_star in P^{k+1} ---\n                c_ustar = np.zeros(k + 2)\n                c_ustar[0] = c_uh[0] # Mean value constraint\n\n                if k + 1 > 0:\n                    stiff_mat = (2.0 / h) * stiff_mat_ref\n                    rhs = np.zeros(k + 1)\n\n                    q_h_right = np.sum(c_qh)\n                    q_h_left = np.sum(c_qh * (-1)**np.arange(k+1))\n                    \n                    p_at_1 = np.ones(k + 1)\n                    p_at_minus_1 = (-1)**np.arange(1, k + 2)\n                    \n                    f_proj_integrals = -h/2 * (P_vals_at_qp[1:, :] @ (w_qp * f_source(x_qp)))\n                    bnd_term = q_h_right * p_at_1 - q_h_left * p_at_minus_1\n                    rhs = f_proj_integrals + bnd_term\n                    \n                    c_ustar_high = np.linalg.solve(stiff_mat, rhs)\n                    c_ustar[1:] = c_ustar_high\n\n                # --- 3. Compute u_starstar in P^{k+1} ---\n                c_ustarstar = np.zeros(k + 2)\n                c_ustarstar[0] = c_ustar[0] # Mean value constraint\n\n                if k + 1 > 0:\n                    # First, find q_star = -grad(u_star) in P^k\n                    integral_vals = proj_mat_q_star @ c_ustar[1:]\n                    l_indices = np.arange(k + 1)\n                    c_qstar = -(2 * l_indices + 1) / h * integral_vals\n                    \n                    q_star_right = np.sum(c_qstar)\n                    q_star_left = np.sum(c_qstar * (-1)**np.arange(k+1))\n                    \n                    bnd_term_star = q_star_right * p_at_1 - q_star_left * p_at_minus_1\n                    rhs_starstar = f_proj_integrals + bnd_term_star\n                    \n                    c_ustarstar_high = np.linalg.solve(stiff_mat, rhs_starstar)\n                    c_ustarstar[1:] = c_ustarstar_high\n\n                # --- 4. Compute L2 error contributions ---\n                u_h_vals = P_vals_at_qp[:k+1, :].T @ c_uh\n                u_star_vals = P_vals_at_qp.T @ c_ustar\n                u_starstar_vals = P_vals_at_qp.T @ c_ustarstar\n                u_exact_vals = exact_u(x_qp)\n\n                total_err_h_sq += h/2 * np.sum(w_qp * (u_exact_vals - u_h_vals)**2)\n                total_err_star_sq += h/2 * np.sum(w_qp * (u_exact_vals - u_star_vals)**2)\n                total_err_starstar_sq += h/2 * np.sum(w_qp * (u_exact_vals - u_starstar_vals)**2)\n\n            errors_h_list.append(np.sqrt(total_err_h_sq))\n            errors_star_list.append(np.sqrt(total_err_star_sq))\n            errors_starstar_list.append(np.sqrt(total_err_starstar_sq))\n        \n        # --- 5. Compute average convergence orders ---\n        def compute_avg_order(errors):\n            orders = [np.log2(errors[i] / errors[i+1]) for i in range(len(errors)-1)]\n            return np.mean(orders)\n\n        avg_order_h = compute_avg_order(errors_h_list)\n        avg_order_star = compute_avg_order(errors_star_list)\n        avg_order_starstar = compute_avg_order(errors_starstar_list)\n\n        flag = (avg_order_starstar - avg_order_star) > 0.2\n\n        final_results.extend([\n            round(avg_order_h, 3),\n            round(avg_order_star, 3),\n            round(avg_order_starstar, 3),\n            flag\n        ])\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3410140"}]}