{"hands_on_practices": [{"introduction": "要真正掌握混合不连续伽辽金（HDG）方法，最有效的方式莫过于亲手推导其核心机制。本练习将引导您从第一性原理出发，为一个简单的一维扩散问题推导并求解其代数系统。通过这个具体实例 [@problem_id:3390545]，您将清晰地看到如何利用定义在单元边界上的迹变量，将单元内部的未知量进行静态凝聚（static condensation），从而将一个大规模的耦合问题转化为一个只涉及迹变量的、规模小得多的全局系统。", "problem": "考虑区间 $[0,1]$ 上的稳态一维扩散方程，其扩散系数 $\\kappa > 0$ 为常数，体积源项为零。写成混合一阶形式：求解 $u:(0,1)\\to\\mathbb{R}$ 和 $q:(0,1)\\to\\mathbb{R}$，使得\n$$\nq \\;=\\; -\\,\\kappa\\,\\frac{du}{dx}, \n\\qquad \n\\frac{dq}{dx} \\;=\\; 0 \\quad \\text{in } (0,1),\n$$\n满足混合狄利克雷–诺伊曼（Dirichlet–Neumann）边界条件\n$$\nu(0) \\;=\\; U_{D}, \n\\qquad \nq(1) \\;=\\; g_{N},\n$$\n其中 $U_{D}\\in\\mathbb{R}$ 和 $g_{N}\\in\\mathbb{R}$ 是给定数据，且在 $x=1$ 处的外法线方向为 $+1$。\n\n将区域划分为两个单元 $K_{1}=[0,h_{1}]$ 和 $K_{2}=[h_{1},1]$，其中 $0  h_1  1$。\n在每个单元上，解 $u_h$ 和通量 $q_h$ 由常数（$\\mathbb{P}_{0}$ 多项式）逼近。混合迹变量 $\\widehat{u}_h$ 定义在节点 $x \\in \\{0, h_1, 1\\}$ 上。稳定化参数 $\\tau$ 是一个正常数。\n任务是，通过执行以下步骤，推导内部迹节点 $x=h_1$ 处混合迹未知数 $\\widehat{u}_h(h_1)$ 的显式闭式表达式：\n1.  写出每个单元 $K_1$ 和 $K_2$ 的局部HDG方程。\n2.  通过将单元内部未知量 $u_1, q_1, u_2, q_2$ 表示为迹未知量 $\\widehat{u}_h(0), \\widehat{u}_h(h_1), \\widehat{u}_h(1)$ 的函数，来执行静态凝聚。\n3.  建立一个只涉及迹未知数的全局系统，该系统通过在内部面 $x=h_1$ 处强制执行数值通量守恒，并在 $x=1$ 处施加诺伊曼条件来获得。\n4.  求解得到的系统，以获得 $\\widehat{u}_h(h_1)$ 的表达式。", "solution": "用户提供的问题经确认为自洽、有科学依据、适定且客观。这是将可杂交间断伽辽金（Hybridizable Discontinuous Galerkin, HDG）方法应用于一维边值问题的标准练习。我们开始进行求解。\n\n该问题要求推导在内部面 $x=h_1$ 处杂交迹未知数 $\\widehat{u}_{h}$ 的值。我们将此值记为 $\\widehat{u}_{h,1} \\equiv \\widehat{u}_{h}(h_{1})$。区域 $\\Omega = [0,1]$ 被划分为两个单元，$K_1 = [0, h_1]$ 和 $K_2 = [h_1, 1]$。解 $u_h$ 和通量 $q_h$ 的近似空间在每个单元上是分片常数，即 $u_h|_{K_i} = u_i \\in \\mathbb{R}$ 和 $q_h|_{K_i} = q_i \\in \\mathbb{R}$（对于 $i=1,2$）。杂交迹 $\\widehat{u}_h$ 在每个面上是常数，其值为 $\\widehat{u}_h(0)$、$\\widehat{u}_h(h_1)$ 和 $\\widehat{u}_h(1)$。\n\n局部 HDG 方程是从每个单元 $K$ 上控制方程的弱形式推导出来的。对于测试函数 $v \\in \\mathbb{P}_0(K)$ 和测试通量 $w \\in \\mathbb{P}_0(K)$，方程为：\n$$\n\\int_K w q_h \\,dx = -\\kappa \\int_{\\partial K} w n \\widehat{u}_h \\,ds\n$$\n$$\n\\int_{\\partial K} v n \\widehat{q}_h \\,ds = 0\n$$\n由于测试函数是常数（$v=1, w=1$），这些方程简化为：\n$$\n|K|q_h = -\\kappa \\sum_{F \\in \\partial K} n_F \\widehat{u}_h|_F\n$$\n$$\n\\sum_{F \\in \\partial K} n_F \\widehat{q}_h|_F = 0\n$$\n其中 $|K|$ 是单元 $K$ 的长度，$n_F$ 是面 $F$ 处的外法线。\n\n关于数值通量的问题陈述可解释如下：定义 $\\widehat{q}_{h}\\,n \\;=\\; q_{h}\\,n + \\tau\\,(u_{h}-\\widehat{u}_{h})$ 在所有面上成立，并且诺伊曼（Neumann）条件作为全局方程 $\\widehat{q}_h \\cdot n = g_N$ 在边界上弱施加。这种解释对于得到一个适定系统是必要的。\n\n**步骤1：局部方程和静态凝聚**\n\n在单元 $K_1=[0, h_1]$ 上：\n未知数是常数 $u_1, q_1$。长度为 $|K_1|=h_1$。面位于 $x=0$（法线 $n=-1$）和 $x=h_1$（法线 $n=+1$）。迹值为 $\\widehat{u}_h(0) = U_D$（给定的狄利克雷数据）和 $\\widehat{u}_h(h_1) = \\widehat{u}_{h,1}$。\n第一个局部方程给出：\n$h_1 q_1 = -\\kappa [ (+1)\\widehat{u}_{h,1} + (-1)U_D ] \\implies q_1 = -\\frac{\\kappa}{h_1}(\\widehat{u}_{h,1} - U_D) = \\frac{\\kappa}{h_1}(U_D - \\widehat{u}_{h,1})$。\n对于第二个局部方程，面上的数值通量为：\n在 $x=h_1$ 处： $n_1 \\widehat{q}_{h,1} = (+1)q_1 + \\tau(u_1 - \\widehat{u}_{h,1})$。\n在 $x=0$ 处： $n_1 \\widehat{q}_{h,1} = (-1)q_1 + \\tau(u_1 - U_D)$。\n将它们相加得到：$[q_1 + \\tau(u_1 - \\widehat{u}_{h,1})] + [-q_1 + \\tau(u_1 - U_D)] = 0 \\implies 2\\tau u_1 - \\tau(\\widehat{u}_{h,1} + U_D) = 0$。\n这得到 $u_1 = \\frac{1}{2}(U_D + \\widehat{u}_{h,1})$。\n\n在单元 $K_2=[h_1, 1]$ 上：\n未知数是常数 $u_2, q_2$。长度为 $|K_2|=1-h_1$。面位于 $x=h_1$（法线 $n=-1$）和 $x=1$（法线 $n=+1$）。我们将 $x=1$ 处的未知迹值记为 $\\widehat{u}_{h,2} \\equiv \\widehat{u}_h(1)$。\n第一个局部方程给出：\n$(1-h_1) q_2 = -\\kappa [ (+1)\\widehat{u}_{h,2} + (-1)\\widehat{u}_{h,1} ] \\implies q_2 = -\\frac{\\kappa}{1-h_1}(\\widehat{u}_{h,2} - \\widehat{u}_{h,1})$。\n对于第二个局部方程，面上的数值通量为：\n在 $x=1$ 处： $n_2 \\widehat{q}_{h,2} = (+1)q_2 + \\tau(u_2 - \\widehat{u}_{h,2})$。\n在 $x=h_1$ 处： $n_2 \\widehat{q}_{h,2} = (-1)q_2 + \\tau(u_2 - \\widehat{u}_{h,1})$。\n将它们相加得到：$[q_2 + \\tau(u_2 - \\widehat{u}_{h,2})] + [-q_2 + \\tau(u_2 - \\widehat{u}_{h,1})] = 0 \\implies 2\\tau u_2 - \\tau(\\widehat{u}_{h,1} + \\widehat{u}_{h,2}) = 0$。\n这得到 $u_2 = \\frac{1}{2}(\\widehat{u}_{h,1} + \\widehat{u}_{h,2})$。\n\n**步骤2：杂交迹的全局系统**\n\n全局系统由未知迹值 $\\widehat{u}_{h,1}$ 和 $\\widehat{u}_{h,2}$ 的方程组成。\n在内部面 $x=h_1$ 处，我们施加数值通量的连续性。$K_1$ 的外法线为 $n=+1$，$K_2$ 的外法线为 $n=-1$。\n$(\\widehat{q}_h \\cdot n)|_{K_1, x=h_1} + (\\widehat{q}_h \\cdot n)|_{K_2, x=h_1} = 0$。\n$[q_1 + \\tau(u_1 - \\widehat{u}_{h,1})] + [-q_2 + \\tau(u_2-\\widehat{u}_{h,1})] = 0 \\implies q_1 - q_2 + \\tau(u_1+u_2-2\\widehat{u}_{h,1}) = 0$。\n\n在诺伊曼（Neumann）边界面 $x=1$ 处，我们施加条件 $\\widehat{q}_h \\cdot n = g_N$。从 $K_2$ 出发的外法线为 $n=+1$。\n$(\\widehat{q}_h \\cdot n)|_{K_2, x=1} = g_N \\implies q_2 + \\tau(u_2 - \\widehat{u}_{h,2}) = g_N$。\n\n**步骤3：简化为单个方程并求解**\n\n我们现在有一个关于 $\\widehat{u}_{h,1}$ 和 $\\widehat{u}_{h,2}$ 的 $2 \\times 2$ 系统。首先，我们使用诺伊曼（Neumann）方程来消去 $\\widehat{u}_{h,2}$。\n将 $q_2$ 和 $u_2$ 的凝聚形式代入诺伊曼（Neumann）方程：\n$-\\frac{\\kappa}{1-h_1}(\\widehat{u}_{h,2} - \\widehat{u}_{h,1}) + \\tau\\left(\\frac{1}{2}(\\widehat{u}_{h,1} + \\widehat{u}_{h,2}) - \\widehat{u}_{h,2}\\right) = g_N$\n$\\frac{\\kappa}{1-h_1}(\\widehat{u}_{h,1} - \\widehat{u}_{h,2}) + \\frac{\\tau}{2}(\\widehat{u}_{h,1} - \\widehat{u}_{h,2}) = g_N$\n$\\left(\\frac{\\kappa}{1-h_1} + \\frac{\\tau}{2}\\right) (\\widehat{u}_{h,1} - \\widehat{u}_{h,2}) = g_N$。\n这使得 $(\\widehat{u}_{h,1} - \\widehat{u}_{h,2})$ 可以被表示，从而 $\\widehat{u}_{h,2}$ 也可以用 $\\widehat{u}_{h,1}$ 表示：\n$\\widehat{u}_{h,2} = \\widehat{u}_{h,1} - g_N \\left(\\frac{\\kappa}{1-h_1} + \\frac{\\tau}{2}\\right)^{-1}$。\n\n接下来，将所有凝聚形式代入内部面方程：\n$q_1 - q_2 + \\tau(u_1+u_2-2\\widehat{u}_{h,1}) = 0$\n$\\frac{\\kappa}{h_1}(U_D - \\widehat{u}_{h,1}) - \\left[-\\frac{\\kappa}{1-h_1}(\\widehat{u}_{h,2} - \\widehat{u}_{h,1})\\right] + \\tau\\left(\\frac{1}{2}(U_D + \\widehat{u}_{h,1}) + \\frac{1}{2}(\\widehat{u}_{h,1} + \\widehat{u}_{h,2}) - 2\\widehat{u}_{h,1}\\right) = 0$\n$\\frac{\\kappa}{h_1}(U_D - \\widehat{u}_{h,1}) + \\frac{\\kappa}{1-h_1}(\\widehat{u}_{h,2} - \\widehat{u}_{h,1}) + \\frac{\\tau}{2}(U_D - 2\\widehat{u}_{h,1} + \\widehat{u}_{h,2}) = 0$\n合并各项：\n$(U_D - \\widehat{u}_{h,1})\\left(\\frac{\\kappa}{h_1} + \\frac{\\tau}{2}\\right) + (\\widehat{u}_{h,2} - \\widehat{u}_{h,1})\\left(\\frac{\\kappa}{1-h_1} + \\frac{\\tau}{2}\\right) = 0$\n令 $A = \\frac{\\kappa}{1-h_1} + \\frac{\\tau}{2}$。从诺伊曼（Neumann）方程，我们已经知道 $(\\widehat{u}_{h,1}-\\widehat{u}_{h,2})A = g_N$，所以 $(\\widehat{u}_{h,2}-\\widehat{u}_{h,1})A = -g_N$。\n将此代入方程：\n$(U_D - \\widehat{u}_{h,1})\\left(\\frac{\\kappa}{h_1} + \\frac{\\tau}{2}\\right) - g_N = 0$\n$(U_D - \\widehat{u}_{h,1})\\left(\\frac{2\\kappa + \\tau h_1}{2h_1}\\right) = g_N$\n$U_D - \\widehat{u}_{h,1} = \\frac{2h_1 g_N}{2\\kappa + \\tau h_1}$\n$\\widehat{u}_{h,1} = U_D - \\frac{2h_1 g_N}{2\\kappa + \\tau h_1}$\n为了将其表示为单个分数：\n$\\widehat{u}_{h,1} = \\frac{U_D(2\\kappa + \\tau h_1) - 2h_1 g_N}{2\\kappa + \\tau h_1}$。\n这就是 $\\widehat{u}_h(h_1)$ 的显式闭式表达式。", "answer": "$$\\boxed{\\frac{U_{D}(2\\kappa + \\tau h_{1}) - 2h_{1}g_{N}}{2\\kappa + \\tau h_{1}}}$$", "id": "3390545"}, {"introduction": "在理解了静态凝聚的“如何做”之后，下一个关键问题是“为什么这么做”。本练习 [@problem_id:3390584] 旨在量化分析静态凝聚带来的计算优势。我们将对比标准的不连续伽辽金（DG）方法与经过静态凝聚的HDG方法，在一个具体的二维网格上估算两者的计算复杂度和内存消耗。通过这个练习，您将深刻体会到HDG方法在求解大规模问题时，为何能在保证精度的同时，大幅提升计算效率。", "problem": "考虑一个标量泊松方程，该方程通过对称内部罚分连续伽辽金(DG)方法和可杂交间断伽辽金(HDG)方法进行离散化。HDG方法采用静态凝聚，消除了单元内部的未知量，从而在全局上仅保留面上的迹未知量。请使用以下数据和建模假设来比较计算复杂度和内存存储。\n\n您可以使用的基本定义和事实：\n- 对于三角形上次数为 $p$ 的多项式，标量单元内部基函数的数量为 $n_{\\mathrm{el}} = \\frac{(p+1)(p+2)}{2}$。\n- 对于边上次数为 $p$ 的多项式，标量迹基函数的数量为 $m_{\\mathrm{ed}} = p+1$。\n- 在块稀疏全局矩阵上，Krylov方法每次迭代的主要成本与存储的非零标量条目数量成正比。在压缩稀疏行(CSR)存储格式中，内存也与存储的非零标量条目数量成正比。\n- 在一个在单纯形网格上组装的DG矩阵中，每个单元贡献一个 $n_{\\mathrm{el}}\\times n_{\\mathrm{el}}$ 的自耦合块，每个内部边贡献两个相邻单元之间的非对角耦合。计算两个对称的非对角块后，非零元总数可模型化为 $\\mathrm{nnz}_{\\mathrm{DG}} = E\\,n_{\\mathrm{el}}^{2} + 2\\,E_{\\mathrm{int}}\\,n_{\\mathrm{el}}^{2}$，其中 $E$ 是单元数量，$E_{\\mathrm{int}}$ 是内部边数量。\n- 在三角形上的HDG凝聚全局矩阵中，每个单元在其三条边的迹之间贡献一个稠密的 $(3\\,m_{\\mathrm{ed}})\\times(3\\,m_{\\mathrm{ed}})$ 块。在对边进行全局组装时，对角边块由两个相邻单元共享，因此应只计算一次；而非对角的边-边耦合（同一单元的两条不同边之间）是该单元所独有的。一个一致的存储非零元计数是 $\\mathrm{nnz}_{\\mathrm{HDG}} = E\\,(3\\,m_{\\mathrm{ed}})^{2} - E_{\\mathrm{int}}\\,m_{\\mathrm{ed}}^{2}$。\n\n几何与网格：\n- 区域是一个被划分为 $N_{x}\\times N_{y}$ 个矩形的矩形区域，其中 $N_{x} = 20$，$N_{y} = 10$。每个矩形由同一条对角线分割成两个三角形。网格具有齐次Dirichlet边界条件，因此只有内部边携带全局HDG迹未知量。\n- 对于这种结构化三角剖分，网格实体的数量为：\n  - 单元：$E = 2\\,N_{x}\\,N_{y}$。\n  - 总边数：$E_{\\mathrm{tot}} = 3\\,N_{x}\\,N_{y} + N_{x} + N_{y}$。\n  - 边界边数：$E_{\\partial} = 2\\,N_{x} + 2\\,N_{y}$。\n  - 内部边数：$E_{\\mathrm{int}} = E_{\\mathrm{tot}} - E_{\\partial} = 3\\,N_{x}\\,N_{y} - N_{x} - N_{y}$。\n\n多项式次数：\n- 在单元和边上使用 $p = 3$。\n\n任务：\n1. 使用以上信息，计算静态凝聚后的HDG系统相对于全局DG系统的每次矩阵向量乘积的算术复杂度之比，\n$$\\mathcal{C} = \\frac{\\mathrm{nnz}_{\\mathrm{HDG}}}{\\mathrm{nnz}_{\\mathrm{DG}}}.$$\n2. 计算内存节省的分数\n$$\\mathcal{S} = 1 - \\frac{\\mathrm{nnz}_{\\mathrm{HDG}}}{\\mathrm{nnz}_{\\mathrm{DG}}}.$$\n\n将最终答案以双元素行向量 $\\begin{pmatrix}\\mathcal{C}  \\mathcal{S}\\end{pmatrix}$ 的形式报告，四舍五入到四位有效数字。不需要单位。", "solution": "我们首先确定网格的组合量。当 $N_{x} = 20$ 且 $N_{y} = 10$ 时，三角形单元的数量为\n$$\nE = 2\\,N_{x}\\,N_{y} = 2\\cdot 20 \\cdot 10 = 400.\n$$\n内部边的数量为\n$$\nE_{\\mathrm{int}} = 3\\,N_{x}\\,N_{y} - N_{x} - N_{y} = 3\\cdot 20 \\cdot 10 - 20 - 10 = 600 - 30 = 570.\n$$\n\n接下来，我们计算多项式次数 $p=3$ 时的局部自由度数量。在三角形上，\n$$\nn_{\\mathrm{el}} = \\frac{(p+1)(p+2)}{2} = \\frac{(3+1)(3+2)}{2} = \\frac{4\\cdot 5}{2} = 10,\n$$\n在边上，\n$$\nm_{\\mathrm{ed}} = p+1 = 3+1 = 4.\n$$\n\n我们现在对全局矩阵中存储的非零元数量进行建模。\n\n对于间断伽辽金(DG)矩阵，我们使用块模式计数，该计数包括单元自耦合和跨每个内部边的成对耦合，并计算两个对称的非对角块。这给出\n$$\n\\mathrm{nnz}_{\\mathrm{DG}} = E\\,n_{\\mathrm{el}}^{2} + 2\\,E_{\\mathrm{int}}\\,n_{\\mathrm{el}}^{2}.\n$$\n代入 $E=400$，$E_{\\mathrm{int}}=570$ 和 $n_{\\mathrm{el}}=10$ 得\n$$\n\\mathrm{nnz}_{\\mathrm{DG}} = 400\\cdot 10^{2} + 2\\cdot 570 \\cdot 10^{2} = 400\\cdot 100 + 1140\\cdot 100 = 40{,}000 + 114{,}000 = 154{,}000.\n$$\n\n对于可杂交间断伽辽金(HDG)凝聚矩阵，每个三角形在其三条边之间贡献一个稠密的 $(3\\,m_{\\mathrm{ed}})\\times(3\\,m_{\\mathrm{ed}})$ 局部舒尔(Schur)块。全局组装后，对角边块由两个三角形共享，因此必须只计算一次，而两条不同边之间的非对角耦合是包含这两条边的三角形所独有的。一个一致的全局计数是\n$$\n\\mathrm{nnz}_{\\mathrm{HDG}} = E\\,(3\\,m_{\\mathrm{ed}})^{2} - E_{\\mathrm{int}}\\,m_{\\mathrm{ed}}^{2}.\n$$\n当 $E=400$，$E_{\\mathrm{int}}=570$ 且 $m_{\\mathrm{ed}}=4$ 时，\n$$\n(3\\,m_{\\mathrm{ed}})^{2} = (3\\cdot 4)^{2} = 12^{2} = 144, \\quad m_{\\mathrm{ed}}^{2}=4^{2}=16,\n$$\n所以\n$$\n\\mathrm{nnz}_{\\mathrm{HDG}} = 400\\cdot 144 - 570\\cdot 16 = 57{,}600 - 9{,}120 = 48{,}480.\n$$\n\n每次矩阵向量乘法的算术复杂度之比模型化为非零元的比率：\n$$\n\\mathcal{C} = \\frac{\\mathrm{nnz}_{\\mathrm{HDG}}}{\\mathrm{nnz}_{\\mathrm{DG}}} = \\frac{48{,}480}{154{,}000}.\n$$\n计算该分数：\n$$\n\\mathcal{C} = \\frac{48{,}480}{154{,}000} \\approx 0.3148051948\\ldots\n$$\n\n内存节省的分数为\n$$\n\\mathcal{S} = 1 - \\mathcal{C} \\approx 1 - 0.3148051948\\ldots \\approx 0.6851948052\\ldots\n$$\n\n将两者都四舍五入到四位有效数字，得到\n$$\n\\mathcal{C} \\approx 0.3148, \\qquad \\mathcal{S} \\approx 0.6852.\n$$\n\n我们将结果报告为包含这两个条目的行向量。", "answer": "$$\\boxed{\\begin{pmatrix}0.3148  0.6852\\end{pmatrix}}$$", "id": "3390584"}, {"introduction": "在完成了理论推导与计算效益分析之后，我们进入最终的实践环节：代码实现与验证。分片测试（Patch Test）是验证有限元代码正确性的基石，它确保您的数值方法能够精确地复现多项式解。本练习 [@problem_id:3390607] 将指导您为一个二维泊松问题实现一个单单元的HDG求解器，并验证其是否能通过分片测试。这不仅能巩固您对HDG离散格式的理解，更是将理论知识转化为可靠计算工具的关键一步。", "problem": "考虑在单个三角形单元上带有狄利克雷边界数据的二阶标量椭圆模型问题。设控制方程为混合形式的泊松问题：求标量场 $u$ 和通量（矢量场）$\\boldsymbol{q}$，使得\n$$\n\\boldsymbol{q} + \\nabla u = \\boldsymbol{0}, \\qquad \\nabla \\cdot \\boldsymbol{q} = f \\quad \\text{在单元内},\n$$\n在单元边界上具有狄利克雷边界数据 $u = g$。可杂交间断伽辽金（HDG）方法在单元内部及其边上各自的多项式空间中求解 $(\\boldsymbol{q}_h, u_h, \\widehat{u}_h)$，使其满足HDG局部方程：对于所选多项式空间中的所有测试函数 $\\boldsymbol{r}$ 和 $v$，\n$$\n(\\boldsymbol{q}_h, \\boldsymbol{r})_T - (u_h, \\nabla \\cdot \\boldsymbol{r})_T + \\langle \\widehat{u}_h, \\boldsymbol{r} \\cdot \\boldsymbol{n} \\rangle_{\\partial T} = 0,\n$$\n$$\n-(\\boldsymbol{q}_h, \\nabla v)_T + \\langle \\boldsymbol{q}_h \\cdot \\boldsymbol{n} + \\tau (u_h - \\widehat{u}_h), v \\rangle_{\\partial T} = (f, v)_T,\n$$\n其中 $T$ 是三角形单元，$\\partial T$ 是其边界，$\\boldsymbol{n}$ 是 $\\partial T$ 上的单位外法向量，$\\tau$ 是一个正常数稳定化参数。在狄利克雷边界上，混合迹变量被设置为边界数据，即 $\\widehat{u}_h = g$。\n\n面片检验（patch test）检查线性多项式的精确再现能力。假设一个精确的线性解 $u_{\\text{exact}}(x,y) = \\alpha x + \\beta y + \\gamma$，其梯度为常数，因此 $f = 0$。当所有逼近空间的多项式次数均为 $p=1$ 时（即在每条边 $e \\subset \\partial T$ 上有 $u_h \\in \\mathbb{P}_1(T)$，$\\boldsymbol{q}_h \\in [\\mathbb{P}_1(T)]^2$，以及 $\\widehat{u}_h \\in \\mathbb{P}_1(e)$），HDG面片检验要求计算每条边上的混合迹未知数，从而使局部求解器产生的 $u_h$ 等于线性多项式 $u_{\\text{exact}}$。\n\n从基本定义出发：\n- 泊松方程的混合形式及其弱形式。\n- 带有数值通量 $\\widehat{\\boldsymbol{q}}_h \\cdot \\boldsymbol{n} = \\boldsymbol{q}_h \\cdot \\boldsymbol{n} + \\tau (u_h - \\widehat{u}_h)$ 的HDG局部方程。\n- 三角形单元及其边上的多项式逼近空间及其基函数。\n\n推导、实现并验证一个带有狄利克雷边界数据的单单元HDG面片检验，重点是计算能够保证单元内部线性解被精确再现的边迹未知数值。\n\n你的程序必须：\n- 在单个三角形单元上，使用次数 $p=1$ 的空间和常数稳定化参数 $\\tau$ 来组装并求解局部HDG系统。\n- 在体积分中使用精确的质量和梯度积分，并在边上使用精确的两点高斯求积来计算边界积分。\n- 将每条边上的混合迹未知数 $\\widehat{u}_h$ 设置为限制在该边上的狄利克雷数据 $g$，由次数为1的边自由度（即每条边两个端点处的值）表示。\n- 计算得到的 $u_h$，并通过在一小组内部点上评估最大绝对逐点误差，来验证其在数值容差范围内等于 $u_{\\text{exact}}$。\n\n测试套件：\n对于每个测试用例，三角形由其顶点坐标 $(x_i, y_i)$（$i \\in \\{0,1,2\\}$，按 $(0,1,2)$ 顺序给出）、线性多项式系数 $(\\alpha, \\beta, \\gamma)$ 和稳定化参数 $\\tau$ 给出。使用以下三个测试用例：\n- 用例1：顶点 $(0,0)$, $(1,0)$, $(0,1)$；系数 $(\\alpha, \\beta, \\gamma) = (2, -1, 1)$；稳定化参数 $\\tau = 1$。\n- 用例2：顶点 $(0,0)$, $(10^{-3}, 1)$, $(0,1)$；系数 $(\\alpha, \\beta, \\gamma) = (-\\tfrac{1}{2}, 1.7, 0.3)$；稳定化参数 $\\tau = 3.3$。\n- 用例3：顶点 $(0,0)$, $(2,0)$, $(0,1)$；系数 $(\\alpha, \\beta, \\gamma) = (1, 3, -2)$；稳定化参数 $\\tau = 5$。\n\n边迹自由度与输出顺序：\n- 按 $[(0,1), (1,2), (2,0)]$ 的顺序枚举边。\n- 对于每条边 $(i,j)$，两个迹自由度分别是 $\\widehat{u}_h$ 在端点 $i$ 和 $j$ 处的值。\n- 迹值由端点处的狄利克雷数据 $g = u_{\\text{exact}}$ 计算得出。\n\n最终输出格式：\n- 对于每个测试用例，输出一个形式为 $[\\text{trace\\_values}, \\text{max\\_error}]$ 的列表，其中 $\\text{trace\\_values}$ 是一个包含6个浮点数的列表，按 $[ \\widehat{u}_{(0,1),0}, \\widehat{u}_{(0,1),1}, \\widehat{u}_{(1,2),1}, \\widehat{u}_{(1,2),2}, \\widehat{u}_{(2,0),2}, \\widehat{u}_{(2,0),0} ]$ 的顺序排列，而 $\\text{max\\_error}$ 是在固定的一组内部点上评估的 $u_h$ 和 $u_{\\text{exact}}$ 之间的最大绝对逐点误差。\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，结果为逗号分隔的列表，用方括号括起，不含空格，并按给定顺序排列。例如，输出必须类似于 $[[\\ldots,\\ldots],[\\ldots,\\ldots],[\\ldots,\\ldots]]$。\n- 如果出现任何三角函数，所有角度均以弧度为单位；然而，本任务不涉及角度。\n- 不涉及物理单位。", "solution": "用户要求在单个三角形单元上实现并验证一个用于标量椭圆问题的可杂交间断伽辽金（HDG）面片检验。面片检验是有限元方法的一种基本验证程序，用以确保该方法能够精确地再现特定次数的多项式解。对于此问题，我们必须证明，对于一个已知的线性精确解，使用次数 $p=1$ 多项式空间的HDG方法能够产生一个与精确解在机器精度范围内相同的数值解。\n\n控制方程是混合形式的泊松问题：\n$$\n\\boldsymbol{q} + \\nabla u = \\boldsymbol{0}, \\qquad \\nabla \\cdot \\boldsymbol{q} = f\n$$\nHDG格式在多项式空间 $\\boldsymbol{q}_h \\in [\\mathbb{P}_1(T)]^2$、$u_h \\in \\mathbb{P}_1(T)$ 以及三角形 $T$ 的每条边 $e$ 上的 $\\widehat{u}_h \\in \\mathbb{P}_1(e)$ 中求解 $(\\boldsymbol{q}_h, u_h, \\widehat{u}_h)$。局部弱形式为：\n$$\n(\\boldsymbol{q}_h, \\boldsymbol{r})_T - (u_h, \\nabla \\cdot \\boldsymbol{r})_T + \\langle \\widehat{u}_h, \\boldsymbol{r} \\cdot \\boldsymbol{n} \\rangle_{\\partial T} = 0\n$$\n$$\n-(\\boldsymbol{q}_h, \\nabla v)_T + \\langle \\boldsymbol{q}_h \\cdot \\boldsymbol{n} + \\tau (u_h - \\widehat{u}_h), v \\rangle_{\\partial T} = (f, v)_T\n$$\n其中 $(\\cdot, \\cdot)_T$ 表示单元 $T$ 上的 $L^2$ 内积，而 $\\langle \\cdot, \\cdot \\rangle_{\\partial T}$ 是其边界 $\\partial T$ 上的内积。测试函数 $\\boldsymbol{r}$ 和 $v$ 分别与 $\\boldsymbol{q}_h$ 和 $u_h$ 来自相同的多项式空间。\n\n对于面片检验，精确解是一个线性多项式 $u_{\\text{exact}}(x,y) = \\alpha x + \\beta y + \\gamma$。这意味着源项 $f = \\nabla \\cdot (-\\nabla u_{\\text{exact}}) = 0$。狄利克雷边界条件为 $\\partial T$ 上的 $u = g = u_{\\text{exact}}$。在HDG框架中，这是通过将迹变量 $\\widehat{u}_h$ 设置为 $g$ 在迹空间上的投影来强制执行的。由于 $\\widehat{u}_h \\in \\mathbb{P}_1(e)$ 且 $g$ 是线性的，这个投影是精确的：$\\widehat{u}_h$ 仅仅是 $g$ 在每条边上的限制。$\\widehat{u}_h$ 的自由度是其在三角形顶点处的值，计算方式为 $\\widehat{U}_i = g(\\boldsymbol{v}_i) = \\alpha x_i + \\beta y_i + \\gamma$。\n\n求解过程包括以下步骤：\n1.  **定义基函数**：我们在顶点为 $(0,0), (1,0), (0,1)$ 的参考三角形 $\\widehat{T}$ 上使用 $\\mathbb{P}_1$ 的单项式基 $\\{1, \\widehat{x}, \\widehat{y}\\}$。一个仿射映射 $F(\\widehat{\\boldsymbol{x}}) = B\\widehat{\\boldsymbol{x}} + \\boldsymbol{v}_0$ 将参考单元连接到物理单元 $T$。矢量空间 $[\\mathbb{P}_1(T)]^2$ 的基函数是分量式构造的，导致 $u_h$ 共有3个自由度，$\\boldsymbol{q}_h$ 共有6个自由度。\n2.  **构建线性系统**：将 $u_h$ 和 $\\boldsymbol{q}_h$ 的基函数展开式代入弱形式，得到一个关于未知系数的 $9 \\times 9$ 线性方程组。设 $u_h$ 的系数向量为 $\\boldsymbol{U}$，$\\boldsymbol{q}_h$ 的系数向量为 $\\boldsymbol{Q}$。该系统具有以下形式：\n    $$\n    \\begin{pmatrix} \\mathbf{A}_{\\boldsymbol{qq}}  \\mathbf{A}_{\\boldsymbol{q}u} \\\\ \\mathbf{A}_{u\\boldsymbol{q}}  \\mathbf{A}_{uu} \\end{pmatrix} \\begin{pmatrix} \\boldsymbol{Q} \\\\ \\boldsymbol{U} \\end{pmatrix} = \\begin{pmatrix} \\boldsymbol{F}_{\\boldsymbol{q}} \\\\ \\boldsymbol{F}_{u} \\end{pmatrix}\n    $$\n3.  **组装矩阵和向量**：系统矩阵 $\\mathbf{A}$ 和右端向量 $\\boldsymbol{F}$ 的项由弱形式计算得出。\n    -   $\\mathbf{A}_{\\boldsymbol{qq}}$ 是 $\\boldsymbol{q}_h$ 的质量矩阵。\n    -   $\\mathbf{A}_{\\boldsymbol{q}u}$ 和 $\\mathbf{A}_{u\\boldsymbol{q}}$ 是耦合变量的类刚度矩阵。\n    -   $\\mathbf{A}_{uu}$ 是一个由稳定化参数 $\\tau$ 缩放的边界质量矩阵。\n    -   $\\boldsymbol{F}_{\\boldsymbol{q}}$ 和 $\\boldsymbol{F}_{u}$ 是由迹变量 $\\widehat{u}_h$ 产生的载荷向量。\n    所有积分都在参考单元 $\\widehat{T}$ 上计算，然后变换到物理单元。多项式的体积分使用已知公式精确计算。边上的边界积分使用2点高斯求积法则计算，这对于遇到的多项式被积函数（最高3次）是精确的。\n4.  **求解与验证**：求解线性系统以获得系数 $\\boldsymbol{U}$ 和 $\\boldsymbol{Q}$。然后，将得到的数值解 $u_h$ 与在一组内部点上的已知精确解 $u_{\\text{exact}}$ 进行比较。计算最大绝对逐点误差，以验证面片检验是否通过（即误差在机器精度范围内）。顶点处的迹值也作为输出的一部分进行报告。\n\n该实现针对所提供的每个测试用例遵循这些步骤，系统地组装和求解局部HDG系统，然后评估结果的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef format_output(results):\n    \"\"\"Formats the results into the required single-line string format.\"\"\"\n    case_strings = []\n    for res in results:\n        trace_vals, max_err = res\n        # Format trace values with high precision scientific notation\n        trace_str = f\"[{','.join(f'{v:.15e}' for v in trace_vals)}]\"\n        # Format max error with high precision scientific notation\n        error_str = f\"{max_err:.15e}\"\n        case_strings.append(f\"[{trace_str},{error_str}]\")\n    return f\"[{','.join(case_strings)}]\"\n\ndef run_patch_test(vertices, coeffs, tau):\n    \"\"\"\n    Performs the HDG patch test for a single triangular element.\n\n    Args:\n        vertices (list of tuples): Coordinates of the triangle vertices.\n        coeffs (tuple): Coefficients (alpha, beta, gamma) for the linear exact solution.\n        tau (float): The stabilization parameter.\n\n    Returns:\n        tuple: A tuple containing the list of trace values and the maximum pointwise error.\n    \"\"\"\n    v = np.array(vertices, dtype=np.float64)\n    alpha, beta, gamma = coeffs\n\n    # 1. Geometric setup for the affine map from reference to physical element\n    v0, v1, v2 = v[0], v[1], v[2]\n    # Affine map: x = B * x_hat + v0\n    B = np.array([v1 - v0, v2 - v0]).T\n    J_det = np.linalg.det(B)\n    B_inv = np.linalg.inv(B)\n    C = B_inv.T  # Transformation matrix for gradients\n\n    # 2. Exact solution and trace setup\n    u_exact_func = lambda x, y: alpha * x + beta * y + gamma\n    Uhat_vals = np.array([u_exact_func(p[0], p[1]) for p in v])\n    trace_values_output = [\n        Uhat_vals[0], Uhat_vals[1], Uhat_vals[1], Uhat_vals[2], Uhat_vals[2], Uhat_vals[0]\n    ]\n\n    # 3. Basis functions and quadrature\n    # Basis on reference triangle (0,0)-(1,0)-(0,1): {1, x_hat, y_hat}\n    # Pre-computed integrals of basis product pairs (phi_i * phi_j) over the reference triangle.\n    M_hat_phiphi = np.array([\n        [1/2, 1/6, 1/6],\n        [1/6, 1/12, 1/24],\n        [1/6, 1/24, 1/12]\n    ])\n    # Pre-computed integrals of basis functions (phi_i) over the reference triangle.\n    int_phi_hat = np.array([1/2, 1/6, 1/6])\n\n    # 2-point Gaussian quadrature for the interval [0, 1]\n    q_points = 0.5 * (1.0 + np.array([-1.0, 1.0]) / np.sqrt(3.0))\n    q_weights = np.array([0.5, 0.5])\n\n    # 4. Assemble local system A*X = F\n    # X = [Qx0, Qx1, Qx2, Qy0, Qy1, Qy2, U0, U1, U2]^T (9 unknowns)\n    A = np.zeros((9, 9))\n    F = np.zeros(9)\n\n    # Volume integral contributions\n    # Block A_qq (mass matrix for q_h)\n    M_phiphi = J_det * M_hat_phiphi\n    A[:3, :3] = M_phiphi\n    A[3:6, 3:6] = M_phiphi\n\n    # Block A_qu\n    div_psi_consts = [0, C[0,0], C[0,1], 0, C[1,0], C[1,1]]\n    for i in range(6):\n        if abs(div_psi_consts[i]) > 1e-15:\n            for l_idx in range(3):\n                int_phi_l = J_det * int_phi_hat[l_idx]\n                A[i, 6 + l_idx] = -int_phi_l * div_psi_consts[i]\n\n    # Block A_uq (volume part)\n    grad_phi_k_consts = [np.zeros(2), C[:,0], C[:,1]]\n    int_psi_j = np.zeros((6, 2))\n    for j_idx in range(3):\n        int_phi_j = J_det * int_phi_hat[j_idx]\n        int_psi_j[j_idx, 0] = int_phi_j\n        int_psi_j[3 + j_idx, 1] = int_phi_j\n    for k_idx in range(3):\n        grad_phi_k = grad_phi_k_consts[k_idx]\n        for j_idx in range(6):\n            A[6 + k_idx, j_idx] = -np.dot(int_psi_j[j_idx], grad_phi_k)\n\n    # Boundary integral contributions\n    edges = [(0, 1), (1, 2), (2, 0)]\n    for i_start, i_end in edges:\n        v_start, v_end = v[i_start], v[i_end]\n        edge_vec = v_end - v_start\n        edge_len = np.linalg.norm(edge_vec)\n        normal = np.array([edge_vec[1], -edge_vec[0]]) / edge_len\n\n        for t_q, w_q in zip(q_points, q_weights):\n            if (i_start, i_end) == (0, 1): x_hat_q = np.array([t_q, 0.0])\n            elif (i_start, i_end) == (1, 2): x_hat_q = np.array([1.0 - t_q, t_q])\n            else: x_hat_q = np.array([0.0, 1.0 - t_q])\n            \n            phi_vals = np.array([1.0, x_hat_q[0], x_hat_q[1]])\n            psi_vals = np.zeros((6,2)); psi_vals[:3, 0] = phi_vals; psi_vals[3:, 1] = phi_vals\n            \n            u_hat_q = Uhat_vals[i_start] * (1 - t_q) + Uhat_vals[i_end] * t_q\n            factor = edge_len * w_q\n\n            # Update matrices and vectors from boundary terms\n            for k in range(3):\n                for j in range(6): A[6 + k, j] += factor * np.dot(psi_vals[j], normal) * phi_vals[k]\n                for l in range(3): A[6 + k, 6 + l] += factor * tau * phi_vals[l] * phi_vals[k]\n                F[6 + k] += factor * tau * u_hat_q * phi_vals[k]\n            for i in range(6): F[i] -= factor * u_hat_q * np.dot(psi_vals[i], normal)\n\n    # 5. Solve the system and extract solution coefficients for u_h\n    X = np.linalg.solve(A, F)\n    U_coeffs = X[6:]\n\n    # 6. Verification: Compare numerical and exact solutions\n    test_points_ref = [(1/3, 1/3), (0.1, 0.1), (0.8, 0.1), (0.1, 0.8)]\n    max_error = 0.0\n    for p_ref in test_points_ref:\n        p_ref_np = np.array(p_ref)\n        p_phy = B @ p_ref_np + v0\n        \n        u_h_val = U_coeffs[0] + U_coeffs[1]*p_ref[0] + U_coeffs[2]*p_ref[1]\n        u_exact_val = u_exact_func(p_phy[0], p_phy[1])\n        \n        error = abs(u_h_val - u_exact_val)\n        if error > max_error: max_error = error\n    \n    return trace_values_output, max_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for all cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"vertices\": [(0, 0), (1, 0), (0, 1)],\n            \"coeffs\": (2, -1, 1),\n            \"tau\": 1.0\n        },\n        {\n            \"vertices\": [(0, 0), (1e-3, 1), (0, 1)],\n            \"coeffs\": (-0.5, 1.7, 0.3),\n            \"tau\": 3.3\n        },\n        {\n            \"vertices\": [(0, 0), (2, 0), (0, 1)],\n            \"coeffs\": (1, 3, -2),\n            \"tau\": 5.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        res = run_patch_test(case[\"vertices\"], case[\"coeffs\"], case[\"tau\"])\n        results.append(res)\n    \n    print(format_output(results))\n\nsolve()\n\n```", "id": "3390607"}]}