{"hands_on_practices": [{"introduction": "在谱元和不连续伽辽金方法中，高斯-洛巴托-勒让德 (GLL) 求积法则因其节点包含区间端点而备受青睐，这使其特别适用于构建节点基函数。本练习将引导你从第一性原理出发，推导一个四阶 GLL 求积法则。通过这个过程，你将深入理解这些求积法则的构造与勒让德多项式的性质之间的深刻联系，并验证其精度阶。[@problem_id:3405872]", "problem": "在谱方法和间断 Galerkin 方法中，区间 $[-1,1]$ 上的高斯-洛巴托-勒让德 (GLL) 求积被广泛用于确保与多项式基和节点插值的强相容性。考虑 $[-1,1]$ 上的 $4$ 点 GLL 法则，它被定义为一个使用区间端点和对称内部节点的求积法则。设该法则写为\n$$\nQ_{4}[f] \\equiv \\sum_{i=1}^{4} w_{i}\\, f(x_{i}),\n$$\n其中 $x_{1},x_{2},x_{3},x_{4} \\in [-1,1]$ 是节点，$w_{1},w_{2},w_{3},w_{4} > 0$ 是权重。一个求积法则的精度阶定义为最大的整数 $m$，使得对于次数至多为 $m$ 的每个多项式 $p(x)$，都有 $Q_{4}[p] = \\int_{-1}^{1} p(x)\\,dx$。\n\n从第一性原理出发：\n- 使用 $[-1,1]$ 上的经典勒让德多项式 $P_{n}(x)$ 作为基本基底，其特点是当 $m \\neq n$ 时具有正交性 $\\int_{-1}^{1} P_{m}(x) P_{n}(x)\\,dx = 0$ 和归一化条件 $P_{n}(1)=1$。\n- 使用 GLL 节点的定义，即端点 $x=\\pm 1$ 以及由 $P_{3}(x)$ 的驻点确定的内部节点。\n- 使用单项式的矩精确性条件，通过要求对适当的 $k$ 值满足 $Q_{4}[x^{k}] = \\int_{-1}^{1} x^{k}\\,dx$ 来确定权重。\n\n以精确形式显式推导节点 $x_{i}$ 和权重 $w_{i}$，然后对所有整数 $k \\leq 5$ 测试该法则在 $x^{k}$ 上的精确性，并通过计算精确求积误差来证明当 $k=6$ 时法则失效\n$$\nE \\equiv Q_{4}[x^{6}] - \\int_{-1}^{1} x^{6}\\,dx。\n$$\n将您的最终结果表示为有序元组\n$$\n(x_{1},\\,x_{2},\\,x_{3},\\,x_{4},\\,w_{1},\\,w_{2},\\,w_{3},\\,w_{4},\\,E)，\n$$\n其中节点按升序排列。精确表示根式和有理数；不要四舍五入。", "solution": "首先对用户提供的问题进行验证检查。\n\n### 步骤 1：提取已知条件\n- **问题类型**：在区间 $[-1,1]$ 上推导 $4$ 点高斯-洛巴托-勒让德 (GLL) 求积法则。\n- **求积法则**：$Q_{4}[f] \\equiv \\sum_{i=1}^{4} w_{i}\\, f(x_{i})$，其中节点 $x_{i} \\in [-1,1]$，权重 $w_{i} > 0$。\n- **精度阶**：最大的整数 $m$，使得对于次数至多为 $m$ 的每个多项式 $p(x)$，都有 $Q_{4}[p] = \\int_{-1}^{1} p(x)\\,dx$。\n- **基多项式**：$[-1,1]$ 上的经典勒让德多项式 $P_{n}(x)$，当 $m \\neq n$ 时具有正交性 $\\int_{-1}^{1} P_{m}(x) P_{n}(x)\\,dx = 0$ 和归一化条件 $P_{n}(1)=1$。\n- **节点定义**：GLL 节点是端点 $x=\\pm 1$ 和由 $P_{3}(x)$ 的驻点（即 $P'_{3}(x)$ 的根）确定的内部节点。\n- **权重确定**：使用矩精确性条件 $Q_{4}[x^{k}] = \\int_{-1}^{1} x^{k}\\,dx$。\n- **任务 1**：推导节点 $x_{i}$ 和权重 $w_{i}$。\n- **任务 2**：对 $k \\leq 5$ 的单项式 $x^{k}$ 测试该法则的精确性。\n- **任务 3**：通过计算求积误差 $E \\equiv Q_{4}[x^{6}] - \\int_{-1}^{1} x^{6}\\,dx$ 来证明当 $k=6$ 时法则失效。\n- **输出格式**：一个有序元组 $(x_{1},\\,x_{2},\\,x_{3},\\,x_{4},\\,w_{1},\\,w_{2},\\,w_{3},\\,w_{4},\\,E)$，其中节点按升序排列。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题是数值分析中一个标准的、基础的练习，特别是在构造求积法则方面。勒让德多项式、高斯-洛巴托求积和精度阶的定义都是正确且公认的。\n- **适定性**：问题陈述清晰，并提供了足够的约束条件来唯一确定未知数（四个节点和四个权重）。推导说明是明确的，并遵循标准程序。\n- **客观性**：语言精确、数学化，并且没有任何主观或模糊的术语。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**，因为它是科学合理的、适定的和客观的。将构建详细的解决方案。\n\n求解过程首先确定求积节点，然后是权重，最后计算所需的误差项。\n\n**1. 求积节点的确定**\n在 $[-1,1]$ 上的 $4$ 点 GLL 节点由端点 $x = -1$ 和 $x = 1$，以及勒让德多项式 $P_{4-1}(x) = P_3(x)$ 的导数的根组成。我们首先使用 Bonnet 递归关系 $(n+1)P_{n+1}(x) = (2n+1)xP_n(x) - nP_{n-1}(x)$ 以及初始多项式 $P_0(x)=1$ 和 $P_1(x)=x$ 来求 $P_3(x)$。\n对于 $n=1$，我们求 $P_2(x)$：\n$$2P_2(x) = (2(1)+1)xP_1(x) - 1P_0(x) = 3x(x) - 1 = 3x^2 - 1 \\implies P_2(x) = \\frac{1}{2}(3x^2 - 1)$$\n对于 $n=2$，我们求 $P_3(x)$：\n$$3P_3(x) = (2(2)+1)xP_2(x) - 2P_1(x) = 5x \\left(\\frac{1}{2}(3x^2 - 1)\\right) - 2x$$\n$$3P_3(x) = \\frac{15}{2}x^3 - \\frac{5}{2}x - 2x = \\frac{15}{2}x^3 - \\frac{9}{2}x$$\n$$P_3(x) = \\frac{1}{3}\\left(\\frac{15}{2}x^3 - \\frac{9}{2}x\\right) = \\frac{1}{2}(5x^3 - 3x)$$\n归一化条件 $P_3(1) = \\frac{1}{2}(5-3) = 1$ 得到满足。\n\n内部节点是 $P'_3(x)=0$ 的根：\n$$P'_3(x) = \\frac{d}{dx} \\left( \\frac{1}{2}(5x^3 - 3x) \\right) = \\frac{1}{2}(15x^2 - 3) = \\frac{3}{2}(5x^2-1)$$\n令 $P'_3(x)=0$ 得到 $5x^2 - 1 = 0$，这给出了内部节点 $x=\\pm\\frac{1}{\\sqrt{5}} = \\pm\\frac{\\sqrt{5}}{5}$。\n四个 GLL 节点按升序排列为：\n$$x_1 = -1, \\quad x_2 = -\\frac{\\sqrt{5}}{5}, \\quad x_3 = \\frac{\\sqrt{5}}{5}, \\quad x_4 = 1$$\n\n**2. 求积权重的确定**\n权重 $w_i$ 是通过要求该法则对尽可能高次数的多项式精确来确定的。对于 $N$ 个点，GLL 求积的精度阶为 $2N-3$。对于 $N=4$，精度阶为 $2(4)-3=5$。我们对 $k=0,1,2,3$ 的单项式 $x^k$ 强制精确性。\n由于节点关于 $x=0$ 对称，权重也必须是对称的：$w_1 = w_4$ 且 $w_2 = w_3$。这自动确保了对所有奇次单项式的精确性。对于 $p(x)=x^{2k+1}$，\n$$Q_4[x^{2k+1}] = w_1(-1)^{2k+1} + w_2\\left(-\\frac{\\sqrt{5}}{5}\\right)^{2k+1} + w_2\\left(\\frac{\\sqrt{5}}{5}\\right)^{2k+1} + w_1(1)^{2k+1} = -w_1 - w_2\\left(\\frac{\\sqrt{5}}{5}\\right)^{2k+1} + w_2\\left(\\frac{\\sqrt{5}}{5}\\right)^{2k+1} + w_1 = 0$$\n这与精确积分 $\\int_{-1}^{1} x^{2k+1}\\,dx = 0$ 相匹配。\n我们需要对偶次单项式 $p(x)=x^k$（$k=0,2$）强制精确性。\n对于 $k=0$:\n$$\\int_{-1}^{1} x^0 \\,dx = 2$$\n$$Q_4[x^0] = w_1(1) + w_2(1) + w_3(1) + w_4(1) = 2w_1 + 2w_2$$\n令两者相等，得到我们的第一个方程：$2w_1 + 2w_2 = 2 \\implies w_1 + w_2 = 1$。\n\n对于 $k=2$:\n$$\\int_{-1}^{1} x^2 \\,dx = \\left[\\frac{x^3}{3}\\right]_{-1}^{1} = \\frac{1}{3} - \\left(-\\frac{1}{3}\\right) = \\frac{2}{3}$$\n$$Q_4[x^2] = w_1(-1)^2 + w_2\\left(-\\frac{\\sqrt{5}}{5}\\right)^2 + w_3\\left(\\frac{\\sqrt{5}}{5}\\right)^2 + w_4(1)^2 = w_1 + w_2\\left(\\frac{5}{25}\\right) + w_3\\left(\\frac{5}{25}\\right) + w_4 = 2w_1 + 2w_2\\left(\\frac{1}{5}\\right)$$\n令两者相等，得到我们的第二个方程：$2w_1 + \\frac{2}{5}w_2 = \\frac{2}{3} \\implies w_1 + \\frac{1}{5}w_2 = \\frac{1}{3}$。\n\n我们现在求解这个线性方程组：\n1) $w_1 + w_2 = 1$\n2) $w_1 + \\frac{1}{5}w_2 = \\frac{1}{3}$\n方程 (1) 减去方程 (2)：\n$(w_1 + w_2) - (w_1 + \\frac{1}{5}w_2) = 1 - \\frac{1}{3} \\implies \\frac{4}{5}w_2 = \\frac{2}{3} \\implies w_2 = \\frac{2}{3} \\cdot \\frac{5}{4} = \\frac{10}{12} = \\frac{5}{6}$。\n将 $w_2$ 代入方程 (1)：\n$w_1 + \\frac{5}{6} = 1 \\implies w_1 = 1 - \\frac{5}{6} = \\frac{1}{6}$。\n四个 GLL 权重为：\n$$w_1 = \\frac{1}{6}, \\quad w_2 = \\frac{5}{6}, \\quad w_3 = \\frac{5}{6}, \\quad w_4 = \\frac{1}{6}$$\n\n**3. 精度验证与误差计算**\n该法则是为 $k=0,1,2,3$ 精确而构造的。我们对 $k=4$ 进行测试：\n$$\\int_{-1}^{1} x^4 \\,dx = \\left[\\frac{x^5}{5}\\right]_{-1}^{1} = \\frac{2}{5}$$\n$$Q_4[x^4] = 2w_1(1)^4 + 2w_2\\left(\\frac{\\sqrt{5}}{5}\\right)^4 = 2\\left(\\frac{1}{6}\\right) + 2\\left(\\frac{5}{6}\\right)\\left(\\frac{1}{5}\\right)^2 = \\frac{1}{3} + \\frac{5}{3}\\left(\\frac{1}{25}\\right) = \\frac{1}{3} + \\frac{1}{15} = \\frac{5+1}{15} = \\frac{6}{15} = \\frac{2}{5}$$\n该法则对 $k=4$ 是精确的。对于 $k=5$，根据对称性也是精确的。因此，精度阶为 $5$，符合预期。\n\n现在我们通过计算误差 $E = Q_{4}[x^{6}] - \\int_{-1}^{1} x^{6}\\,dx$ 来证明当 $k=6$ 时法则失效。\n首先，积分值为：\n$$\\int_{-1}^{1} x^6 \\,dx = \\left[\\frac{x^7}{7}\\right]_{-1}^{1} = \\frac{1}{7} - \\left(-\\frac{1}{7}\\right) = \\frac{2}{7}$$\n其次，求积和为：\n$$Q_4[x^6] = 2w_1(1)^6 + 2w_2\\left(\\frac{\\sqrt{5}}{5}\\right)^6 = 2\\left(\\frac{1}{6}\\right) + 2\\left(\\frac{5}{6}\\right)\\left(\\frac{1}{5}\\right)^3 = \\frac{1}{3} + \\frac{5}{3}\\left(\\frac{1}{125}\\right) = \\frac{1}{3} + \\frac{1}{3 \\cdot 25} = \\frac{1}{3} + \\frac{1}{75}$$\n$$Q_4[x^6] = \\frac{25}{75} + \\frac{1}{75} = \\frac{26}{75}$$\n误差 $E$ 为：\n$$E = Q_4[x^6] - \\int_{-1}^{1} x^6 \\,dx = \\frac{26}{75} - \\frac{2}{7} = \\frac{26 \\cdot 7 - 2 \\cdot 75}{75 \\cdot 7} = \\frac{182 - 150}{525} = \\frac{32}{525}$$\n\n**4. 最终组装结果**\n所需的有序元组为 $(x_{1},\\,x_{2},\\,x_{3},\\,x_{4},\\,w_{1},\\,w_{2},\\,w_{3},\\,w_{4},\\,E)$。\n$$x_1 = -1, \\quad x_2 = -\\frac{\\sqrt{5}}{5}, \\quad x_3 = \\frac{\\sqrt{5}}{5}, \\quad x_4 = 1$$\n$$w_1 = \\frac{1}{6}, \\quad w_2 = \\frac{5}{6}, \\quad w_3 = \\frac{5}{6}, \\quad w_4 = \\frac{1}{6}$$\n$$E = \\frac{32}{525}$$\n这给出了最终的元组。", "answer": "$$\n\\boxed{\n\\begin{pmatrix} -1,  -\\frac{\\sqrt{5}}{5},  \\frac{\\sqrt{5}}{5},  1,  \\frac{1}{6},  \\frac{5}{6},  \\frac{5}{6},  \\frac{1}{6},  \\frac{32}{525} \\end{pmatrix}\n}\n$$", "id": "3405872"}, {"introduction": "构建了标准的高斯求积法则后，我们来探讨求积点和权重的选择对数值格式稳定性的关键影响。本练习通过分析一个给定了节点的插值型求积法则，揭示了一个重要属性：正的求积权重。我们将看到，非正权重如何在不连续伽辽金 (DG) 方法的质量矩阵集中化过程中导致奇异性，从而对显式时间积分格式的稳定性产生灾难性影响。[@problem_id:3405819]", "problem": "考虑在区间 $[-1,1]$ 上的一个插值型求积法则，它有四个不同的节点 $x_{1}=-1$，$x_{2}=-\\frac{1}{2}$，$x_{3}=0$ 和 $x_{4}=1$。根据定义，如果一个有 $n$ 个节点的插值型求积法则的权重 $w_{1},\\dots,w_{n}$ 的选择能使其对所有次数最高为 $n-1$ 的多项式都是精确的，那么该法则的精度阶至少为 $n-1$。这通过匹配单项式的矩来实现：对于整数 $k=0,1,\\dots,n-1$，权重必须满足 $\\sum_{i=1}^{n} w_{i} x_{i}^{k} = \\int_{-1}^{1} x^{k}\\,\\mathrm{d}x$。仅使用这些基本定义和事实，计算出唯一的权重 $w_{1},w_{2},w_{3},w_{4}$，使得该求积法则对区间 $[-1,1]$ 上所有次数至多为 $3$ 的多项式都是精确的，并确定所有权重是否为正。然后，基于第一性原理，推断当使用质量集中求积法对质量矩阵进行对角化时，这些权重的符号模式对间断 Galerkin (DG) 方法中显式时间步进的影响。作为您的最终数值答案，报告 $w_{1},w_{2},w_{3},w_{4}$ 中的最小权重值 $w_{\\min}$。", "solution": "问题要求计算在区间 $[-1, 1]$ 上的一个特定四节点插值型求积法则的权重，并分析其性质，特别是在间断 Galerkin (DG) 方法的背景下。\n\n该求积法则定义在区间 $[-1, 1]$ 上，有 $n=4$ 个不同的节点：$x_{1}=-1$，$x_{2}=-\\frac{1}{2}$，$x_{3}=0$ 和 $x_{4}=1$。\n该法则被指定为插值型求积法则，它对所有次数最高为 $n-1 = 3$ 的多项式都是精确的。这个条件是通过要求该求积法则能精确积分单项式 $x^k$ (其中 $k=0, 1, 2, 3$) 来强制执行的。这为未知权重 $w_1, w_2, w_3, w_4$ 导出了一个线性方程组：\n$$ \\sum_{i=1}^{4} w_{i} x_{i}^{k} = \\int_{-1}^{1} x^{k}\\,\\mathrm{d}x \\quad \\text{for } k=0, 1, 2, 3 $$\n\n首先，我们计算这些方程的右边，即单项式在 $[-1, 1]$ 上的矩。\n对于 $k=0$:\n$$ \\int_{-1}^{1} x^{0}\\,\\mathrm{d}x = \\int_{-1}^{1} 1\\,\\mathrm{d}x = [x]_{-1}^{1} = 1 - (-1) = 2 $$\n对于 $k=1$:\n$$ \\int_{-1}^{1} x^{1}\\,\\mathrm{d}x = \\left[\\frac{x^{2}}{2}\\right]_{-1}^{1} = \\frac{1^{2}}{2} - \\frac{(-1)^{2}}{2} = 0 $$\n对于 $k=2$:\n$$ \\int_{-1}^{1} x^{2}\\,\\mathrm{d}x = \\left[\\frac{x^{3}}{3}\\right]_{-1}^{1} = \\frac{1^{3}}{3} - \\frac{(-1)^{3}}{3} = \\frac{1}{3} - \\left(-\\frac{1}{3}\\right) = \\frac{2}{3} $$\n对于 $k=3$:\n$$ \\int_{-1}^{1} x^{3}\\,\\mathrm{d}x = \\left[\\frac{x^{4}}{4}\\right]_{-1}^{1} = \\frac{1^{4}}{4} - \\frac{(-1)^{4}}{4} = 0 $$\n\n现在，我们通过代入节点值 $x_1=-1, x_2=-1/2, x_3=0, x_4=1$ 和计算出的积分来构建线性系统。\n对于 $k=0$：$w_1(x_1)^0 + w_2(x_2)^0 + w_3(x_3)^0 + w_4(x_4)^0 = w_1 + w_2 + w_3 + w_4 = 2$\n对于 $k=1$：$w_1(x_1)^1 + w_2(x_2)^1 + w_3(x_3)^1 + w_4(x_4)^1 = -w_1 - \\frac{1}{2}w_2 + 0 \\cdot w_3 + w_4 = 0$\n对于 $k=2$：$w_1(x_1)^2 + w_2(x_2)^2 + w_3(x_3)^2 + w_4(x_4)^2 = w_1 + \\frac{1}{4}w_2 + 0 \\cdot w_3 + w_4 = \\frac{2}{3}$\n对于 $k=3$：$w_1(x_1)^3 + w_2(x_2)^3 + w_3(x_3)^3 + w_4(x_4)^3 = -w_1 - \\frac{1}{8}w_2 + 0 \\cdot w_3 + w_4 = 0$\n\n该方程组为：\n1. $w_1 + w_2 + w_3 + w_4 = 2$\n2. $-w_1 - \\frac{1}{2}w_2 + w_4 = 0$\n3. $w_1 + \\frac{1}{4}w_2 + w_4 = \\frac{2}{3}$\n4. $-w_1 - \\frac{1}{8}w_2 + w_4 = 0$\n\n从方程 (2) 和 (4) 可得：\n$$ -w_1 - \\frac{1}{2}w_2 + w_4 = -w_1 - \\frac{1}{8}w_2 + w_4 $$\n$$ -\\frac{1}{2}w_2 = -\\frac{1}{8}w_2 $$\n$$ \\left(\\frac{1}{8} - \\frac{1}{2}\\right)w_2 = 0 \\implies -\\frac{3}{8}w_2 = 0 \\implies w_2 = 0 $$\n\n将 $w_2=0$ 代入方程组，可将其简化为：\n1. $w_1 + w_3 + w_4 = 2$\n2. $-w_1 + w_4 = 0 \\implies w_1 = w_4$\n3. $w_1 + w_4 = \\frac{2}{3}$\n\n从 (2) 和 (3) 出发，我们将 $w_4=w_1$ 代入 (3)：\n$$ w_1 + w_1 = \\frac{2}{3} \\implies 2w_1 = \\frac{2}{3} \\implies w_1 = \\frac{1}{3} $$\n因为 $w_1=w_4$，我们也有 $w_4 = \\frac{1}{3}$。\n\n最后，我们使用方程 (1) 来求 $w_3$：\n$$ \\frac{1}{3} + w_3 + \\frac{1}{3} = 2 $$\n$$ w_3 + \\frac{2}{3} = 2 \\implies w_3 = 2 - \\frac{2}{3} = \\frac{6-2}{3} = \\frac{4}{3} $$\n\n唯一的权重是 $w_1 = \\frac{1}{3}$，$w_2 = 0$，$w_3 = \\frac{4}{3}$ 和 $w_4 = \\frac{1}{3}$。\n\n问题的第二部分询问所有权重是否为正。权重集合为 $\\{\\frac{1}{3}, 0, \\frac{4}{3}, \\frac{1}{3}\\}$。由于 $w_2 = 0$，并非所有权重都是严格正数。它们都是非负的。\n\n问题的第三部分涉及对 DG 方法的影响。在 DG 方法中，对每个单元，会组装一个质量矩阵 $M$，其元素为 $M_{ij} = \\int_K \\phi_i \\phi_j \\,\\mathrm{d}x$，其中 $\\phi_i$ 是单元 $K$ 上的基函数。对于显式时间步进格式，每一步都需要计算项 $M^{-1}u$，这使得 $M$ 的求逆成为一个计算瓶颈。\n\n质量集中是一种用对角矩阵 $\\tilde{M}$ 来近似 $M$ 的技术，对角矩阵的求逆是平凡的。这通常通过选择基函数 $\\phi_i$ 为与一组求积节点 $x_k$ 相关联的拉格朗日多项式（即 $\\phi_i(x_k) = \\delta_{ik}$），然后使用相同的求积法则来近似积分来实现：\n$$ \\tilde{M}_{ij} = \\sum_{k=1}^n w_k \\phi_i(x_k) \\phi_j(x_k) = \\sum_{k=1}^n w_k \\delta_{ik} \\delta_{jk} $$\n（这里，权重 $w_k$ 乘以从参考单元到物理单元映射的雅可比行列式，这是一个正常数）。这会得到一个对角矩阵，其对角元素为 $\\tilde{M}_{ii} = w_i$。\n\n对于一个半离散系统 $\\frac{du}{dt} = M^{-1}F(u)$，经过质量集中后，显式时间步进格式变为 $\\frac{du}{dt} = \\tilde{M}^{-1}F(u)$。这意味着第 $i$ 个自由度的更新与 $(\\tilde{M}^{-1})_{ii} = 1/w_i$ 成正比。\n\n权重的符号模式具有关键影响：\n- 如果所有 $w_i > 0$，则集中质量矩阵 $\\tilde{M}$ 是对角且正定的。这通常是理想的，因为它经常能保持原始连续问题的稳定性。\n- 如果有任何权重 $w_i  0$，$\\tilde{M}$ 不是正定的，这会引入不稳定性并导致非物理行为，可能使时间步进格式无条件不稳定。\n- 如果有任何权重 $w_i = 0$，就像本例中的 $w_2=0$ 一样，$\\tilde{M}$ 对应的对角元素为零。这使得矩阵 $\\tilde{M}$ 是奇异的，其逆矩阵不存在。相应自由度的更新是未定义的，因为它会涉及除以零。因此，这种求积法则不适用于需要为显式时间步进而求逆质量矩阵的 DG 方法中的质量集中。数值格式将会失败。\n\n最终的数值答案是最小的权重值 $w_{\\min}$。\n$$ w_{\\min} = \\min\\left\\{\\frac{1}{3}, 0, \\frac{4}{3}, \\frac{1}{3}\\right\\} = 0 $$", "answer": "$$\n\\boxed{0}\n$$", "id": "3405819"}, {"introduction": "本章的最后一个练习将解决一个高阶方法应用于非线性问题时的核心挑战：混叠误差 (aliasing error)。我们将从理论和计算两方面探讨非线性项如何产生超出解的多项式基表示能力的高频分量，以及不充分的求积精度如何导致这些误差。这个练习将阐明“过积分”（over-integration）或“去混叠”（de-aliasing）的概念，这是一种在求解非线性偏微分方程时确保计算准确性的实用策略。[@problem_id:3405861]", "problem": "考虑一个在参考区间 $\\left[-1,1\\right]$ 上的一维谱方法或间断 Galerkin 元，并设近似解 $u(x)$ 是在单项式基下次数至多为 $p$ 的多项式。重点关注非线性通量函数 $f(u)$ 在该元上的体积分，这是谱方法和间断 Galerkin 方法中体积项的常见操作。\n\n使用以下基本依据：\n- 一个精度阶为 $m$ 的数值积分法则对于次数至多为 $m$ 的任意多项式的积分是精确的。\n- 一个次数至多为 $p$ 的多项式 $u(x)$ 与一个多项式非线性 $f(u)=u^q$ 的复合，会产生一个次数至多为 $q\\,p$ 的多项式 $f(u(x))$。\n- 对于在 $\\left[-1,1\\right]$ 上有 $N$ 个节点的 Gauss-Legendre 积分，其精度阶为 $m=2N-1$。\n\n任务：\n1. 从上述核心定义出发，证明如果 $u \\in \\mathbb{P}_p$（次数至多为 $p$ 的多项式空间）且 $f(u)=u^q$，那么体积分 $\\int_{-1}^{1} f(u(x))\\,dx$ 可以被任何精度阶 $m \\ge q\\,p$ 的积分法则精确计算。解释为什么这意味着对于二次非线性 $f(u)=\\tfrac{1}{2}u^2$，精度阶达到 $m=2p$ 是足够的，但当 $p \\ge 1$ 时，对于三次非线性 $f(u)=u^3$ 则是不足够的，并解释为什么 $m=3p$ 可以消除三次非线性情况下的混叠。\n\n2. 基于以上分析，设计一个计算测试：\n   - 构造一个特定的多项式 $u(x)=x^p$，其次数恰好为 $p$，对于整数 $q \\ge 1$，可产生次数恰好为 $q\\,p$ 的 $f(u)$。\n   - 通过在单项式基中展开 $f(u)$ 并逐项积分，以解析方式计算精确积分 $I_{q}=\\int_{-1}^{1} f(u(x))\\,dx$（由于定义域对称，只有偶数次幂有贡献）。\n   - 使用 Gauss-Legendre 积分来近似 $I_{q}$，其中节点数 $N$ 的选择应满足目标精度阶 $m$（通过 $m=2N-1$）。\n   - 通过比较积分近似值与解析值来报告是否存在混叠。使用 $\\varepsilon=10^{-12}$ 的相对容差来判断是否相等。\n\n3. 实现下面的测试套件，并按末尾指定的方式汇总布尔结果：\n   - 测试 1 (二次非线性的理想情况)：$p=4$, $q=2$, 目标 $m=2p$。如果未检测到混叠，即积分值在容差范围内与解析积分一致，则声明测试通过。\n   - 测试 2 (三次非线性的不足情况)：$p=4$, $q=3$, 目标 $m=2p$。如果检测到混叠，即积分值在容差范围内不一致，则声明测试通过。\n   - 测试 3 (三次非线性的超积分情况)：$p=4$, $q=3$, 目标 $m=3p$。如果未检测到混叠，则声明测试通过。\n   - 测试 4 (边界度数检查)：$p=2$, $q=3$, 目标 $m=2p$。如果检测到混叠，则声明测试通过。\n   - 测试 5 (小度数二次非线性)：$p=2$, $q=2$, 目标 $m=2p$。如果未检测到混叠，则声明测试通过。\n\n实现要求：\n- 必须通过操作多项式系数来精确计算解析积分：给定 $u(x)=x^p$，使用重复多项式乘法在单项式基中构造 $f(u)$ 作为单项式多项式，并利用 $\\int_{-1}^{1} x^k\\,dx = 0$（对于奇数 $k$）和 $\\int_{-1}^{1} x^k\\,dx = \\dfrac{2}{k+1}$（对于偶数 $k$）进行逐项积分。\n- 必须通过选择满足 $2N-1 \\ge m$ 的最小整数 $N$ 来实现目标精度阶 $m$，然后使用 $N$ 点 Gauss-Legendre 积分来计算 $f(u)$ 的数值积分。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3,result4,result5]\"）。\n- 每个结果都应为一个布尔值：\"True\" 表示测试根据上述标准通过，否则为 \"False\"。\n- 此问题不涉及物理单位或角度；所有计算都是无量纲的。", "solution": "问题陈述经评估有效。它在科学上基于数值分析的原理，特别是数值积分和多项式逼近理论。该问题是适定的、客观的，并包含推导解决方案和实现所需计算测试的所有必要信息。\n\n### 1. 积分精确性的理论分析\n\n该问题要求分析在何种条件下，数值积分法则能够精确地计算谱方法或间断 Galerkin 方法中的体积项 $\\int_{-1}^{1} f(u(x))\\,dx$。\n\n已知条件如下：\n- 积分域是参考区间 $I = [-1, 1]$。\n- 近似解 $u(x)$ 是一个次数至多为 $p$ 的多项式，记为 $u \\in \\mathbb{P}_p$。\n- 非线性通量函数是 $f(u) = u^q$ 形式的多项式，其中 $q \\ge 1$ 为整数。\n- 一个精度阶为 $m$ 的数值积分法则能精确地对次数至多为 $m$ 的任何多项式进行积分。\n- 对于具有 $N$ 个节点的 Gauss-Legendre 积分，其精度阶为 $m = 2N-1$。\n\n首先，我们确定被积函数 $f(u(x))$ 的性质。由于 $u(x)$ 是一个次数至多为 $p$ 的多项式，它可以写成 $u(x) = \\sum_{k=0}^{p} c_k x^k$。复合函数 $f(u(x))$ 则是 $(u(x))^q = (\\sum_{k=0}^{p} c_k x^k)^q$。此表达式中 $x$ 的最高次幂来自 $u(x)$ 中 $x$ 的最高次幂，即 $x^p$。因此，$f(u(x))$ 展开式中的最高次项是 $(c_p x^p)^q = c_p^q x^{pq}$。这意味着 $f(u(x))$ 是一个次数至多为 $p \\cdot q$ 的多项式。\n\n根据精度阶的定义，如果 $g(x)$ 是一个多项式且其次数 $\\text{deg}(g)$ 满足 $\\text{deg}(g) \\le m$，那么积分法则可以精确计算积分 $\\int_{-1}^{1} g(x)\\,dx$。在我们的例子中，被积函数是 $g(x) = f(u(x))$，它是一个次数至多为 $pq$ 的多项式。因此，为了精确积分，我们必须选择一个精度阶为 $m$ 的积分法则，使得 $m \\ge pq$。\n\n现在，我们将这个一般性结果应用于提到的具体情况：\n\n- **二次非线性 ($q=2$):** 通量为 $f(u) = u^2$（或 $\\frac{1}{2}u^2$，常数因子不影响多项式次数）。被积函数 $f(u(x))$ 是一个次数至多为 $2p$ 的多项式。如果我们使用目标精度阶为 $m=2p$ 的积分法则，精确性条件 $m \\ge 2p$ 得到满足。这意味着精度阶为 $m=2p$ 的积分法则足以精确计算该积分，不会发生混叠误差。\n\n- **三次非线性 ($q=3$):** 通量为 $f(u) = u^3$。被积函数 $f(u(x))$ 是一个次数至多为 $3p$ 的多项式。如果我们使用目标精度阶为 $m=2p$ 的积分法则，对于任何 $p \\ge 1$，精确性条件 $m \\ge 3p$ *不*被满足，因为 $2p  3p$。该积分法则的精度不足以精确积分由三次非线性产生的高次多项式。无法解析多项式中的最高次项导致了混叠误差，即这些高次项的贡献被错误地映射到结果中，导致数值积分不准确。\n\n- **消除三次情况下的混叠:** 为了消除三次非线性带来的混叠误差，必须使用满足精确性条件 $m \\ge 3p$ 的积分法则。通过选择一个精度阶为 $m=3p$ 的法则，我们确保了积分被精确计算。这种技术通常被称为超积分或去混叠。\n\n### 2. 计算测试的设计\n\n该计算测试旨在验证上述理论结论。\n\n**a. 多项式构造和解析积分：**\n我们选择特定的多项式 $u(x) = x^p$，其次数恰好为 $p$。通量函数 $f(u) = u^q$ 于是变为 $f(u(x)) = (x^p)^q = x^{pq}$。这是一个次数恰好为 $pq$ 的单项式。问题要求通过展开 $f(u)$ 并逐项积分来计算解析积分。在这个简化的情况下，只有一项 $x^{pq}$。\n\n精确积分 $I_{q,p} = \\int_{-1}^{1} x^{pq}\\,dx$ 使用在对称区间上对 $x$ 的幂进行积分的标准公式计算：\n$$\nI_{q,p} = \\int_{-1}^{1} x^{k}\\,dx = \\begin{cases} 0  \\text{如果 } k \\text{ 是奇数} \\\\ \\frac{2}{k+1}  \\text{如果 } k \\text{ 是偶数} \\end{cases}\n$$\n这里，$k=pq$。所以，如果 $pq$ 是偶数，精确的解析积分是 $I_{q,p} = \\frac{2}{pq+1}$；如果 $pq$ 是奇数，则 $I_{q,p} = 0$。对于所有指定的测试用例，$p$ 和 $q$ 的选择使得 $pq$ 为偶数，因此积分将非零。\n\n**b. 数值积分：**\n数值积分使用 Gauss-Legendre 积分法计算。给定一个目标精度阶 $m$，我们需要找到达到此精度的最小积分节点数 $N$。关系式为 $2N-1 \\ge m$。解出 $N$ 得 $N \\ge \\frac{m+1}{2}$。由于 $N$ 必须是整数，我们选择 $N = \\lceil \\frac{m+1}{2} \\rceil$。在整数算术中，这可以计算为 $N = (m+2)//2$。\n\n确定 $N$ 后，我们获得 $N$ 个 Gauss-Legendre 节点 $\\{x_i\\}_{i=1}^N$ 和权重 $\\{w_i\\}_{i=1}^N$。积分的数值近似值为：\n$$\n\\tilde{I}_{q,p} = \\sum_{i=1}^{N} w_i f(u(x_i)) = \\sum_{i=1}^{N} w_i (x_i)^{pq}\n$$\n\n**c. 混叠检测：**\n如果数值积分 $\\tilde{I}_{q,p}$ 与解析积分 $I_{q,p}$ 不匹配，则存在混叠。我们使用相对容差 $\\varepsilon = 10^{-12}$ 来比较这些值。如果满足以下条件，则检测到混叠：\n$$\n\\frac{|I_{q,p} - \\tilde{I}_{q,p}|}{|I_{q,p}|} \\ge \\varepsilon\n$$\n这等效于检查 $I_{q,p}$ 和 $\\tilde{I}_{q,p}$ 是否在给定的相对容差内不“接近”。\n\n### 3. 测试用例实现\n\n实现将遵循上述逻辑对五个测试用例中的每一个进行操作。一个辅助函数将为给定的参数集 $(p, q, m_{\\text{target}})$ 执行计算，并返回一个布尔值，指示测试的特定条件（例如，“检测到混叠”）是否被满足。\n\n- **测试 1 ($p=4, q=2, m=2p=8$):** 被积函数次数为 $pq=8$。目标精度为 $m=8$。法则应是精确的 ($m \\ge pq$)。如果未检测到混叠，则测试通过。\n- **测试 2 ($p=4, q=3, m=2p=8$):** 被积函数次数为 $pq=12$。目标精度为 $m=8$。法则精度不足 ($m  pq$)。如果检测到混叠，则测试通过。\n- **测试 3 ($p=4, q=3, m=3p=12$):** 被积函数次数为 $pq=12$。目标精度为 $m=12$。法则应是精确的 ($m \\ge pq$)。如果未检测到混叠，则测试通过。\n- **测试 4 ($p=2, q=3, m=2p=4$):** 被积函数次数为 $pq=6$。目标精度为 $m=4$。法则精度不足 ($m  pq$)。如果检测到混叠，则测试通过。\n- **测试 5 ($p=2, q=2, m=2p=4$):** 被积函数次数为 $pq=4$。目标精度为 $m=4$。法则应是精确的 ($m \\ge pq$)。如果未检测到混叠，则测试通过。\n\n最终程序将执行这些测试，并将布尔形式的通过/失败结果格式化为逗号分隔的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for quadrature aliasing and print results.\n    \"\"\"\n    \n    # Test cases defined as (p, q, m_name, m_func, expected_aliasing) tuples.\n    # m_name is for clarity, m_func calculates target m from p.\n    # expected_aliasing: True if the test passes when aliasing is detected.\n    test_cases = [\n        # Test 1: p=4, q=2, m=2p. Should be exact. Pass if no aliasing.\n        {'p': 4, 'q': 2, 'm_target': 2 * 4, 'pass_if_aliasing_detected': False},\n        # Test 2: p=4, q=3, m=2p. Insufficient. Pass if aliasing.\n        {'p': 4, 'q': 3, 'm_target': 2 * 4, 'pass_if_aliasing_detected': True},\n        # Test 3: p=4, q=3, m=3p. Sufficient. Pass if no aliasing.\n        {'p': 4, 'q': 3, 'm_target': 3 * 4, 'pass_if_aliasing_detected': False},\n        # Test 4: p=2, q=3, m=2p. Insufficient. Pass if aliasing.\n        {'p': 2, 'q': 3, 'm_target': 2 * 2, 'pass_if_aliasing_detected': True},\n        # Test 5: p=2, q=2, m=2p. Sufficient. Pass if no aliasing.\n        {'p': 2, 'q': 2, 'm_target': 2 * 2, 'pass_if_aliasing_detected': False},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        p = case['p']\n        q = case['q']\n        m_target = case['m_target']\n        pass_if_aliasing_detected = case['pass_if_aliasing_detected']\n\n        # 1. ANALYTIC INTEGRAL\n        # The integrand is f(u(x)) = (x^p)^q = x^(p*q).\n        integrand_degree = p * q\n        \n        # Analytic integral I = integral from -1 to 1 of x^k dx.\n        # I = 2/(k+1) if k is even, I = 0 if k is odd.\n        # For all test cases, p*q is even.\n        if integrand_degree % 2 != 0:\n            analytic_integral = 0.0\n        else:\n            analytic_integral = 2.0 / (integrand_degree + 1)\n            \n        # 2. NUMERICAL INTEGRAL\n        # Determine number of quadrature points N for target precision m.\n        # The degree of precision for N-point Gauss-Legendre is 2N-1.\n        # We need 2N-1 = m_target = N = (m_target + 1)/2.\n        # As N must be an integer, N = ceil((m_target + 1)/2).\n        num_points_N = int(np.ceil((m_target + 1) / 2.0))\n\n        # Get Gauss-Legendre nodes and weights.\n        nodes, weights = roots_legendre(num_points_N)\n        \n        # Evaluate the integrand at the nodes.\n        integrand_values = nodes ** integrand_degree\n        \n        # Compute the numerical integral by summing weighted values.\n        numeric_integral = np.sum(weights * integrand_values)\n\n        # 3. ALIASING DETECTION AND TEST VERDICT\n        # Aliasing is detected if the numerical result is not close to the analytic one.\n        # Using a relative tolerance of 1e-12 as specified.\n        # atol is a failsafe for cases where the analytic integral is zero.\n        is_exact = np.isclose(analytic_integral, numeric_integral, rtol=1e-12, atol=1e-15)\n        aliasing_detected = not is_exact\n        \n        # The test passes if the aliasing detection matches the expectation.\n        test_passes = (aliasing_detected == pass_if_aliasing_detected)\n        results.append(test_passes)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3405861"}]}