{"hands_on_practices": [{"introduction": "尽管我们通常使用预先计算好的求积法则，但理解其构建过程是领会其数值特性的关键。本练习将深入“幕后”，实现一个用于高斯-勒让德求积的稳定算法，揭示正交多项式、递推关系和求根方法之间的相互作用 [@problem_id:3388881]。这对保证高阶数值方法的稳定性至关重要。", "problem": "你需要设计、推导并实现一个数值稳定的算法，用于计算区间 $[-1,1]$ 上的高斯-勒让德求积（Gauss–Legendre quadrature）的节点和权重，该算法需适用于谱元法（Spectral Element Methods）和间断伽辽金（Discontinuous Galerkin, DG）方法。目标是通过将勒让德多项式在其根处的导数 $P_n'(x)$ 表示为可通过递推稳定计算的量，来避免在求值过程中出现灾难性抵消。你的推导必须从勒让德多项式的基本性质、其三项递推关系以及关于高斯求积精确性的基本事实出发。你必须假定无法访问任何预打包的特殊函数节点或权重生成器。仅根据这些基本原理构建算法。\n\n所需推导和算法步骤：\n1.  从 $[-1,1]$ 上勒让德多项式 $P_n(x)$ 的三项递推关系及其正交性开始，推导出一个用 $P_n(x)$ 和 $P_{n-1}(x)$ 表示 $P_n'(x)$ 的关系式，该关系式在高斯-勒让德节点 $\\{\\xi_i\\}_{i=1}^n$ 处或其附近不会出现灾难性抵消。\n2.  推导一个牛顿迭代更新公式，用于精化 $P_n(x)=0$ 的根 $\\xi_i$ 的初始近似值，该公式仅用 $P_n(\\xi)$、$P_{n-1}(\\xi)$ 和 $P_n'(\\xi)$ 表示。\n3.  利用高斯求积的精确性和勒让德多项式的范数性质，推导出用 $P_n'(\\xi_i)$ 和 $\\xi_i$ 表示的高斯-勒让德权重表达式 $w_i$。\n4.  解释为什么该算法能够避免灾难性抵消，并且对于大的 $n$ 值在双精度下是数值稳定的。\n\n实现要求：\n- 实现一个程序，给定一个正整数 $n$，使用以下方法计算 $[-1,1]$ 上的高斯-勒让德节点 $\\{\\xi_i\\}_{i=1}^n$ 和权重 $\\{w_i\\}_{i=1}^n$：\n  - 通过三项递推关系稳定地计算 $P_n(x)$ 和 $P_{n-1}(x)$。\n  - 使用你推导出的稳定导数恒等式计算节点处的 $P_n'(x)$。\n  - 从渐近初始猜测开始，使用牛顿迭代精化节点。\n- 不得使用任何库中内置的高斯-勒让德节点/权重例程。\n- 你的程序必须为下面的测试套件中的每个 $n$ 计算并报告诊断指标。\n\n测试套件：\n- 考虑以下 $n$ 值：$n \\in \\{1,2,10,64\\}$。\n- 对每个 $n$，计算以下三个诊断指标：\n  1.  $E_{\\mathrm{sum}}(n)$：权重和的绝对误差，定义为 $E_{\\mathrm{sum}}(n) = \\left|\\sum_{i=1}^n w_i - 2\\right|$。\n  2.  $E_{\\mathrm{poly}}(n)$：对 $2n-2$ 次偶次多项式的绝对求积误差，定义为 $E_{\\mathrm{poly}}(n) = \\left|\\sum_{i=1}^n w_i \\, \\xi_i^{2n-2} - \\int_{-1}^1 x^{2n-2} \\, dx\\right|$，其中 $\\int_{-1}^1 x^{2n-2} \\, dx = \\frac{2}{2n-1}$。\n  3.  $\\mathrm{PosOk}(n)$：一个布尔值，当且仅当所有权重都严格为正且所有节点都满足 $-1  \\xi_i  1$ 时为真。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个包含在方括号中的逗号分隔列表。\n- 列表必须按以下顺序包含测试用例的诊断指标：对于 $n=1$，输出 $E_{\\mathrm{sum}}(1)$, $E_{\\mathrm{poly}}(1)$, $\\mathrm{PosOk}(1)$；对于 $n=2$，输出 $E_{\\mathrm{sum}}(2)$, $E_{\\mathrm{poly}}(2)$, $\\mathrm{PosOk}(2)$；对于 $n=10$ 和 $n=64$ 同样如此。\n- 例如，你的输出必须看起来像 `[E_{\\mathrm{sum}}(1),E_{\\mathrm{poly}}(1),\\mathrm{PosOk}(1),E_{\\mathrm{sum}}(2),E_{\\mathrm{poly}}(2),\\mathrm{PosOk}(2),E_{\\mathrm{sum}}(10),E_{\\mathrm{poly}}(10),\\mathrm{PosOk}(10),E_{\\mathrm{sum}}(64),E_{\\mathrm{poly}}(64),\\mathrm{PosOk}(64)]`。\n- 数字必须以十进制形式打印。布尔值必须打印为 $True$ 或 $False$。\n\n注意：\n- 实现和推导的重点是高斯-勒让德求积。你可以简要讨论在谱元法和间断伽辽金方法中使用的高斯-洛巴托（Gauss–Lobatto）和高斯-拉道（Gauss–Radau）规则中如何出现类似的稳定性考虑，但在此任务中你不需要在代码中实现这些变体。", "solution": "该问题要求推导并实现一个数值稳定的算法来计算高斯-勒让德求积的节点和权重。这是数值分析中的一个基本任务，尤其对于高阶谱方法和间断伽辽金方法，这些方法需要高阶（大 $n$）的求积法则，并且稳定性至关重要。\n\n该过程将基于勒让德多项式 $P_n(x)$ 的基本性质。我们将推导出求积节点处导数 $P_n'(x)$ 的稳定公式、牛顿-拉夫森求根迭代以及求积权重 $\\{w_i\\}$。算法将从第一性原理构建，避免使用预打包的库函数来生成这些量。\n\n### 1. 勒让德多项式的基本性质\n\n对于 $n \\in \\{0, 1, 2, \\dots\\}$，勒让德多项式 $P_n(x)$ 是在区间 $[-1, 1]$ 上关于权重函数 $w(x) = 1$ 的一个正交多项式序列。\n\n**正交性：**\n其正交性由下式给出：\n$$\n\\int_{-1}^{1} P_m(x) P_n(x) dx = \\frac{2}{2n+1}\\delta_{mn}\n$$\n其中 $\\delta_{mn}$ 是克罗内克δ。\n\n**三项递推关系（博内递推公式）：**\n勒让德多项式可以使用一个稳定的三项递推关系生成：\n$$\n(n+1)P_{n+1}(x) = (2n+1)xP_n(x) - nP_{n-1}(x)\n$$\n起始多项式为 $P_0(x) = 1$ 和 $P_1(x) = x$。此关系是稳定评估多项式的算法基石。\n\n### 2. 数值稳定算法的推导\n\n高斯-勒让德求积节点 $\\{\\xi_i\\}_{i=1}^n$ 是勒让德多项式 $P_n(x)$ 的根。我们将使用牛顿法来高精度地找到这些根。这需要计算 $P_n(x)$ 及其导数 $P_n'(x)$。\n\n#### 2.1. 节点处 $P_n'(x)$ 的稳定公式\n\n一个标准的勒让德多项式恒等式将 $P_n(x)$、$P_{n-1}(x)$ 和 $P_n'(x)$ 联系起来：\n$$\n(1-x^2)P_n'(x) = n(P_{n-1}(x) - xP_n(x))\n$$\n设 $\\xi_i$ 是一个高斯-勒让德节点，即 $P_n(x)$ 的一个根。根据定义，$P_n(\\xi_i)=0$。将此代入恒等式，得到：\n$$\n(1-\\xi_i^2)P_n'(\\xi_i) = n(P_{n-1}(\\xi_i) - \\xi_i \\cdot 0) = n P_{n-1}(\\xi_i)\n$$\n这为我们提供了一个直接且稳定的公式，用于计算 $P_n(x)$ 在其根处的导数：\n$$\nP_n'(\\xi_i) = \\frac{n P_{n-1}(\\xi_i)}{1-\\xi_i^2}\n$$\n这个公式是数值稳定的，因为已知 $P_n(x)$ 的根 $\\xi_i$ 严格位于区间 $(-1, 1)$ 内，所以分母 $(1-\\xi_i^2)$ 永远不为零。$P_{n-1}(\\xi_i)$ 项可以使用三项递推关系稳健地计算。这避免了在其他导数公式中可能发生的灾难性抵消。\n\n#### 2.2. 用于求根的牛顿法\n\n牛顿法提供了一个迭代格式来寻找函数 $f(x)$ 的根：\n$$\nx_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)}\n$$\n为了找到 $P_n(x)$ 的根，我们设 $f(x) = P_n(x)$。迭代更新为：\n$$\n\\xi^{(k+1)} = \\xi^{(k)} - \\frac{P_n(\\xi^{(k)})}{P_n'(\\xi^{(k)})}\n$$\n为了在迭代过程中计算任意点 $x$（不一定是根）处的导数 $P_n'(x)$，我们对上一节的恒等式进行轻微重排：\n$$\nP_n'(x) = \\frac{n(xP_n(x) - P_{n-1}(x))}{x^2-1}\n$$\n牛顿更新步长 $\\Delta\\xi^{(k)} = \\xi^{(k+1)} - \\xi^{(k)}$ 可以写为：\n$$\n\\Delta\\xi^{(k)} = - \\frac{P_n(\\xi^{(k)})}{P_n'(\\xi^{(k)})} = - \\frac{P_n(\\xi^{(k)}) ((\\xi^{(k)})^2-1)}{n(\\xi^{(k)}P_n(\\xi^{(k)}) - P_{n-1}(\\xi^{(k)}))}\n$$\n此表达式用于求根算法的每一步。值 $P_n(\\xi^{(k)})$ 和 $P_{n-1}(\\xi^{(k)})$ 通过博内递推关系高效且稳定地计算。\n\n#### 2.3. 求积权重的推导\n\n高斯-勒让德求积的权重 $w_i$ 可以用节点 $\\xi_i$ 和导数 $P_n'(\\xi_i)$ 来表示：\n$$\nw_i = \\frac{2}{(1-\\xi_i^2)[P_n'(\\xi_i)]^2}\n$$\n将第2.1节中推导出的 $P_n'(\\xi_i)$ 的稳定表达式代入此公式，我们得到：\n$$\nw_i = \\frac{2}{(1-\\xi_i^2)\\left[ \\frac{n P_{n-1}(\\xi_i)}{1-\\xi_i^2} \\right]^2} = \\frac{2 (1-\\xi_i^2)^2}{(1-\\xi_i^2) n^2 [P_{n-1}(\\xi_i)]^2}\n$$\n这简化为最终的、数值稳定的权重公式：\n$$\nw_i = \\frac{2(1-\\xi_i^2)}{n^2 [P_{n-1}(\\xi_i)]^2}\n$$\n这个公式异常稳定。它只涉及行为良好的量的平方和乘积。根 $\\xi_i$ 位于 $(-1, 1)$ 内，确保 $1-\\xi_i^2 > 0$。$P_{n-1}(x)$ 的根与 $P_n(x)$ 的根交错，因此 $P_{n-1}(\\xi_i) \\neq 0$。\n\n### 3. 算法总结与稳定性分析\n\n完整的算法流程如下：\n1.  **初始猜测：** 对于给定的阶数 $n$，我们需要 $P_n(x)$ 根的初始猜测。根关于 $x=0$ 对称。我们只需要计算非负根。对于第 $k$ 个根（按从大到小排序）的一个极佳初始猜测由渐近公式给出：\n    $$ \\xi_k^{(0)} = \\cos\\left(\\pi \\frac{4k-1}{4n+2}\\right), \\quad k=1, 2, \\dots, \\lceil n/2 \\rceil $$\n2.  **根的精化：** 每个初始猜测都使用第2.2节中描述的牛顿-拉夫森迭代进行精化，直到收敛到机器精度。\n3.  **权重计算：** 一旦找到根 $\\xi_i$，就使用第2.3节中的稳定公式计算相应的权重 $w_i$。\n4.  **对称性：** 通过利用对称性构建完整的节点和权重集：如果 $\\xi_i$ 是一个权重为 $w_i$ 的节点，那么 $-\\xi_i$ 也是一个权重相同的节点。如果 $n$ 是奇数，则 $\\xi=0$ 是一个节点。\n\n该算法对于大的 $n$ 值是数值稳定的，原因有几点：\n- **求值：** 使用三项递推关系来评估 $P_k(x)$ 在 $x \\in [-1, 1]$ 上是数值稳定的，因为多项式的幅值以1为界。\n- **求根：** 牛顿迭代基于 $P_n(x)$ 和 $P_{n-1}(x)$ 的比值，这两个值是稳定计算的。在根附近，行为是稳健的。\n- **权重计算：** 最终的权重公式只涉及正量（$1-\\xi_i^2$, $n^2$, $[P_{n-1}(\\xi_i)]^2$），并避免了几乎相等的数相减，从而防止了灾难性抵消。\n\n这些利用递推关系实现稳定计算的原则不仅限于高斯-勒让德求积。它们对于计算其他求积法则（如高斯-洛巴托和高斯-拉道）的节点和权重也至关重要，这些在谱元法和间断伽辽金方法中对于构建对角质量矩阵和确保稳健的数值方案是关键的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_gauss_legendre(n):\n    \"\"\"\n    Computes Gauss-Legendre nodes and weights on [-1, 1] using a stable\n    Newton-Raphson method based on the three-term recurrence relation.\n\n    Args:\n        n (int): The order of the quadrature rule. Must be a positive integer.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the sorted nodes\n        and corresponding weights.\n    \"\"\"\n    if not isinstance(n, int) or n  1:\n        raise ValueError(\"n must be a positive integer.\")\n\n    if n == 1:\n        return np.array([0.0]), np.array([2.0])\n\n    nodes = np.zeros(n, dtype=float)\n    weights = np.zeros(n, dtype=float)\n    \n    # We find the non-negative roots using symmetry.\n    # The number of roots to find is ceil(n/2).\n    n_roots_to_find = (n + 1) // 2\n    \n    for i in range(n_roots_to_find):\n        # Initial guess for the k-th root, where roots are ordered from largest to smallest.\n        # k is 1-indexed, loop i is 0-indexed.\n        k = i + 1\n        x = np.cos(np.pi * (k - 0.25) / (n + 0.5))\n\n        # Newton-Raphson iteration to refine the root.\n        # A tolerance based on machine epsilon is appropriate for high precision.\n        tol = np.finfo(float).eps\n        \n        for _ in range(20):  # A max iteration count prevents infinite loops.\n            # Evaluate P_n(x) and P_{n-1}(x) using Bonnet's three-term recurrence.\n            p_n_minus_1 = 1.0  # P_0(x)\n            p_n = x            # P_1(x)\n            \n            for j in range(1, n):\n                # (j+1)P_{j+1} = (2j+1)xP_j - jP_{j-1}\n                p_n_plus_1 = ((2 * j + 1) * x * p_n - j * p_n_minus_1) / (j + 1)\n                p_n_minus_1 = p_n\n                p_n = p_n_plus_1\n            # After the loop, p_n is P_n(x) and p_n_minus_1 is P_{n-1}(x).\n            \n            # Derivative P_n'(x) for the Newton step.\n            # (x^2 - 1) * P_n'(x) = n * (x*P_n(x) - P_{n-1}(x))\n            p_n_prime = n * (x * p_n - p_n_minus_1) / (x**2 - 1.0)\n            \n            # Newton update step.\n            dx = p_n / p_n_prime\n            x = x - dx\n            \n            # Check for convergence.\n            if np.abs(dx) = tol * (1.0 + np.abs(x)):\n                break\n        \n        # Store the converged root and its symmetric counterpart.\n        # This scheme finds positive roots in descending order.\n        nodes[i] = x\n        nodes[n - 1 - i] = -x\n        \n        # Re-evaluate P_{n-1}(x) at the converged root for the weight calculation.\n        p_prev = 1.0 # P_0(x)\n        p_curr = x   # P_1(x)\n        if n > 1:\n            for j in range(1, n - 1): # Recurrence up to P_{n-1}\n                p_next = ((2 * j + 1) * x * p_curr - j * p_prev) / (j + 1)\n                p_prev = p_curr\n                p_curr = p_next\n        p_n_minus_1_at_root = p_curr\n        \n        # Calculate the weight using the stable formula:\n        # w_k = 2(1-x_k^2) / (n^2 * [P_{n-1}(x_k)]^2)\n        w = 2.0 * (1 - x**2) / ((n * p_n_minus_1_at_root)**2)\n        weights[i] = w\n        weights[n - 1 - i] = w\n        \n    # The nodes are constructed symmetrically, but for convention let's sort them.\n    # The construction order already results in a sorted descending array, so\n    # an explicit sort is for formal correctness according to convention.\n    sort_indices = np.argsort(nodes)\n    nodes = nodes[sort_indices]\n    weights = weights[sort_indices]\n\n    return nodes, weights\n\ndef solve():\n    test_cases = [1, 2, 10, 64]\n    results = []\n    \n    for n in test_cases:\n        nodes, weights = compute_gauss_legendre(n)\n\n        # Diagnostic 1: Absolute error in the sum of weights. Should be 2.\n        e_sum = np.abs(np.sum(weights) - 2.0)\n\n        # Diagnostic 2: Absolute quadrature error for f(x) = x^(2n-2).\n        # Integral of x^(2n-2) from -1 to 1 is 2/(2n-1).\n        exact_integral = 2.0 / (2 * n - 1)\n        # The term x^(2n-2) requires special handling for n=1, where x=0 and exponent is 0.\n        # np.power(0.0, 0.0) correctly evaluates to 1.0.\n        quad_sum = np.sum(weights * np.power(nodes, 2 * n - 2))\n        e_poly = np.abs(quad_sum - exact_integral)\n\n        # Diagnostic 3: Check if all weights are positive and nodes are in (-1, 1).\n        # The roots of Legendre polynomials are guaranteed to be in (-1, 1).\n        pos_ok = np.all(weights > 0) and np.all(np.abs(nodes)  1.0)\n        \n        results.extend([e_sum, e_poly, pos_ok])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3388881"}, {"introduction": "在标准的“参考”区间 $[-1,1]$ 上创建了求积法则后，下一个实际步骤是将其应用于现实世界问题中的任意区间。本练习涉及有限元和谱元方法中的一个核心推导：仿射映射 [@problem_id:3388861]。我们将看到节点和权重如何变换，以及最重要的一点，为什么多项式精确度得以保持。", "problem": "在为谱方法和间断 Galerkin (DG) 方法构建高阶数值通量和刚度/质量矩阵时，物理区间单元 $E=[a,b]$ 上的单元积分是通过映射到参考区间 $[-1,1]$ 来计算的。考虑一个仿射映射 $\\phi:[-1,1]\\to [a,b]$，由 $\\phi(\\xi)=\\alpha+\\beta\\,\\xi$ 给出，其雅可比 $J=\\phi'(\\xi)=\\beta0$ 为常数。参考区间 $[-1,1]$ 上的一个高斯型求积法则，其节点为 $\\{\\xi_i\\}_{i=1}^{n}$，权重为 $\\{w_i\\}_{i=1}^{n}$，将 $\\int_{-1}^{1} g(\\xi)\\,d\\xi$ 近似为 $\\sum_{i=1}^{n} w_i\\,g(\\xi_i)$，并且对于不超过某一阶数的多项式是精确的，该阶数取决于所选的法则（Gauss–Legendre、Gauss–Lobatto 或 Gauss–Radau）。\n\n从积分的换元公式和参考求积的定义性质出发，推导通过 $\\phi$ 将高斯型参考法则传递后得到的物理单元 $E=[a,b]$ 上的求积法则。你的推导必须：\n- 用 $a$、$b$、$\\{\\xi_i\\}$ 和 $\\{w_i\\}$ 表示映射后的节点和映射后的权重。\n- 对于 Gauss–Legendre、Gauss–Lobatto 和 Gauss–Radau 法则，论证在此仿射映射下，多项式精确度的阶数得以保持。\n\n将你的最终结果表示为 $\\int_{a}^{b} f(x)\\,dx$ 的映射求积近似的单一闭式解析表达式，用 $a$、$b$、$\\{\\xi_i\\}$ 和 $\\{w_i\\}$ 表示，其中 $f$ 是一个足够光滑的函数。最终答案中不要包含任何推导或解释。最终答案必须是单一的解析表达式，且不得包含单位。", "solution": "该问题要求通过仿射映射，将参考区间 $[-1,1]$ 上的一个高斯型参考求积法则传递到物理单元 $E=[a,b]$ 上，从而推导出其上的求积法则。我们还必须论证多项式精确度的阶数得以保持。\n\n首先，我们确定仿射映射 $\\phi(\\xi) = \\alpha + \\beta\\xi$ 的参数，该映射将参考区间 $[-1,1]$ 映射到物理区间 $[a,b]$。端点必须相互映射，因此我们要求 $\\phi(-1) = a$ 和 $\\phi(1) = b$。这给出了一个关于 $\\alpha$ 和 $\\beta$ 的二元线性方程组：\n$$\n\\begin{cases}\n\\alpha - \\beta = a \\\\\n\\alpha + \\beta = b\n\\end{cases}\n$$\n两式相加可得 $2\\alpha = a+b$，所以 $\\alpha = \\frac{a+b}{2}$。第二个方程减去第一个方程可得 $2\\beta = b-a$，所以 $\\beta = \\frac{b-a}{2}$。条件 $\\beta  0$ 意味着 $ba$，这与区间 $[a,b]$ 的标准定义是一致的。\n因此，该映射为：\n$$\nx = \\phi(\\xi) = \\frac{a+b}{2} + \\frac{b-a}{2}\\xi\n$$\n该变换的雅可比 $J$ 是 $\\phi$ 对 $\\xi$ 的导数：\n$$\nJ = \\frac{d\\phi}{d\\xi} = \\beta = \\frac{b-a}{2}\n$$\n由于 $a$ 和 $b$ 是常数，雅可比 $J$ 也是一个常数。\n\n接下来，我们对函数 $f(x)$ 在物理单元 $[a,b]$ 上的积分应用换元公式：\n$$\n\\int_{a}^{b} f(x)\\,dx = \\int_{\\phi^{-1}(a)}^{\\phi^{-1}(b)} f(\\phi(\\xi)) \\frac{d\\phi}{d\\xi}\\,d\\xi = \\int_{-1}^{1} f(\\phi(\\xi)) J\\,d\\xi\n$$\n代入 $\\phi(\\xi)$ 和 $J$ 的表达式，我们得到：\n$$\n\\int_{a}^{b} f(x)\\,dx = \\int_{-1}^{1} f\\left( \\frac{a+b}{2} + \\frac{b-a}{2}\\xi \\right) \\left( \\frac{b-a}{2} \\right) d\\xi\n$$\n由于雅可比 $J$ 是常数，我们可以将其移到积分号外：\n$$\n\\int_{a}^{b} f(x)\\,dx = \\frac{b-a}{2} \\int_{-1}^{1} f\\left( \\frac{a+b}{2} + \\frac{b-a}{2}\\xi \\right) d\\xi\n$$\n现在，我们使用给定的高斯型求积法则来近似参考区间 $[-1,1]$ 上的积分。令 $g(\\xi) = f(\\phi(\\xi)) = f\\left( \\frac{a+b}{2} + \\frac{b-a}{2}\\xi \\right)$。参考求积法则表明：\n$$\n\\int_{-1}^{1} g(\\xi)\\,d\\xi \\approx \\sum_{i=1}^{n} w_i g(\\xi_i)\n$$\n其中 $\\{\\xi_i\\}_{i=1}^{n}$ 是参考节点，$\\{w_i\\}_{i=1}^{n}$ 是参考权重。\n将此近似代入我们变换后的积分中，得到：\n$$\n\\int_{a}^{b} f(x)\\,dx \\approx \\frac{b-a}{2} \\sum_{i=1}^{n} w_i g(\\xi_i) = \\frac{b-a}{2} \\sum_{i=1}^{n} w_i f\\left( \\frac{a+b}{2} + \\frac{b-a}{2}\\xi_i \\right)\n$$\n此表达式即为物理单元 $[a,b]$ 上的求积法则。我们可以确定映射后的求积节点 $x_i$ 和映射后的求积权重 $W_i$。在 $[a,b]$ 上的求积法则形式为 $\\sum_{i=1}^{n} W_i f(x_i)$。通过比较形式，我们推断出：\n映射后的节点为 $x_i = \\phi(\\xi_i) = \\frac{a+b}{2} + \\frac{b-a}{2}\\xi_i$。\n映射后的权重为 $W_i = J \\cdot w_i = \\frac{b-a}{2}w_i$。\n\n最后，我们必须论证多项式精确度的阶数得以保持。设参考求积法则对所有次数不超过 $k$ 的关于 $\\xi$ 的多项式都是精确的。$k$ 的具体值取决于求积类型（例如，对于 $n$ 点 Gauss-Legendre 法则，$k=2n-1$）。这意味着对于任意次数至多为 $k$ 的多项式 $p(\\xi)$，求积都是精确的：\n$$\n\\int_{-1}^{1} p(\\xi)\\,d\\xi = \\sum_{i=1}^{n} w_i p(\\xi_i)\n$$\n现在，考虑物理区间 $[a,b]$ 上任意一个次数至多为 $k$ 的多项式 $P(x)$。我们要证明映射后的求积法则对 $P(x)$ 是精确的。\n$P(x)$ 的积分为：\n$$\n\\int_{a}^{b} P(x)\\,dx = \\frac{b-a}{2} \\int_{-1}^{1} P\\left(\\phi(\\xi)\\right) d\\xi\n$$\n此积分的求积近似为：\n$$\n\\sum_{i=1}^{n} W_i P(x_i) = \\sum_{i=1}^{n} \\left(\\frac{b-a}{2}w_i\\right) P(\\phi(\\xi_i)) = \\frac{b-a}{2} \\sum_{i=1}^{n} w_i P(\\phi(\\xi_i))\n$$\n我们来分析复合函数 $p(\\xi) = P(\\phi(\\xi))$。由于 $P(x)$ 是一个次数至多为 $k$ 的多项式，而 $\\phi(\\xi) = \\alpha + \\beta\\xi$ 是一个关于 $\\xi$ 的一次多项式（其中 $\\beta \\neq 0$），所以复合函数 $P(\\phi(\\xi))$ 也是一个关于 $\\xi$ 的多项式，其次数与 $P(x)$ 相同，即至多为 $k$。\n由于 $p(\\xi) = P(\\phi(\\xi))$ 是一个次数至多为 $k$ 的多项式，参考求积法则对其是精确的：\n$$\n\\int_{-1}^{1} P(\\phi(\\xi))\\,d\\xi = \\sum_{i=1}^{n} w_i P(\\phi(\\xi_i))\n$$\n两边同乘以常数雅可比 $J = \\frac{b-a}{2}$，我们得到：\n$$\n\\frac{b-a}{2} \\int_{-1}^{1} P(\\phi(\\xi))\\,d\\xi = \\frac{b-a}{2} \\sum_{i=1}^{n} w_i P(\\phi(\\xi_i))\n$$\n上式左边是 $\\int_{a}^{b} P(x)\\,dx$ 的精确值，而右边是由映射后的求积法则计算出的值。因为它们相等，所以映射后的法则对任意次数不超过 $k$ 的多项式 $P(x)$ 都是精确的。因此，多项式精确度的阶数在仿射映射下得以保持。这对 Gauss–Legendre、Gauss–Lobatto 和 Gauss–Radau 法则都成立，因为该论证仅依赖于仿射映射的性质和求积精确度的定义，而不依赖于具体的节点和权重。\n\n$\\int_{a}^{b} f(x)\\,dx$ 的映射求积近似的最终表达式为：\n$$\n\\int_{a}^{b} f(x)\\,dx \\approx \\frac{b-a}{2} \\sum_{i=1}^{n} w_i f\\left( \\frac{a+b}{2} + \\frac{b-a}{2}\\xi_i \\right)\n$$", "answer": "$$\n\\boxed{\n\\frac{b-a}{2} \\sum_{i=1}^{n} w_i f\\left( \\frac{a+b}{2} + \\frac{b-a}{2}\\xi_i \\right)\n}\n$$", "id": "3388861"}, {"introduction": "求积法则的选择不仅仅关乎精度，它对数值方法的效率和行为有着深远的影响。本练习通过比较高斯-勒让德和高斯-洛巴托求积，探讨了谱方法中的一个经典权衡 [@problem_id:3388916]。我们将实现一个谱方法，并数值研究使用高斯-洛巴托点来实现对角“集中”质量矩阵如何影响波传播的精度，这一现象被称为数值色散。", "problem": "考虑参考区间 $[-1,1]$ 和一个次数为 $N \\ge 1$ 的多项式空间。令 $\\{x_i\\}_{i=0}^N$ 为节点，$\\{w_i\\}_{i=0}^N$ 为定义在 $[-1,1]$ 上的求积法则的非负权重。通过 $\\ell_j(x_i)=\\delta_{ij}$ 定义拉格朗日 (Lagrange) 节点基 $\\{\\ell_j(x)\\}_{j=0}^N$，其中 $\\delta_{ij}$ 是克罗内克 (Kronecker) delta。节点谱元法 (SEM) 使用这些基函数来近似函数及其导数。本问题关注两种求积和节点的选择：高斯-勒让德 (Gauss–Legendre, GL) 和高斯-洛巴托-勒让德 (Gauss-Lobatto-Legendre, GLL)，并量化在谱方法和间断伽辽金 (Discontinuous Galerkin, DG) 方法的背景下，对角质量矩阵与色散误差之间的权衡。\n\n您必须从以下基本事实和定义出发：\n\n- $N+1$ 点高斯-勒让德 (Gauss–Legendre) 求积在 $[-1,1]$ 上能精确积分所有次数最高为 $2N+1$ 的多项式。其节点是勒让德 (Legendre) 多项式 $P_{N+1}(x)$ 的零点，权重为严格正值。\n- $(N+1)$ 点高斯-洛巴托-勒让德 (Gauss-Lobatto-Legendre) 求积包含端点 $\\pm 1$，其内部节点是 $P_N'(x)$ 的零点。其精确度为 $2N-1$。权重是严格正值，并且可以根据在节点处计算的 $P_N(x)$ 值写出。\n- 对于在求积节点 $\\{x_i\\}$ 上的节点拉格朗日基函数 $\\ell_j(x)$，基于求积的质量矩阵 $M_{\\text{quad}}$ 是对角的，其元素为 $M_{ii}^{\\text{quad}} = w_i$。对于具有 $N+1$ 个节点的高斯-勒让德求积，基于求积的质量矩阵也是精确的一致质量矩阵。对于具有 $N+1$ 个节点的高斯-洛巴托-勒让德求积，基于求积的质量矩阵与精确的一致质量矩阵不同，这种效应通常被称为质量集中 (mass-lumping)。\n\n您的任务是：\n\n- 仅使用上述事实和拉格朗日插值的定义，从第一性原理出发，推导出一个数值稳定的程序来构建微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，其元素为 $D_{ij} = \\ell_j'(x_i)$。您必须在不依赖问题陈述中任何预先推导的封闭形式微分公式的情况下完成此任务，并且必须根据条件数来证明其稳定性。\n- 对于实数波数 $\\kappa$ 的复值平面波 $u(x) = \\exp(\\mathrm{i}\\,\\kappa x)$，定义质量加权的最小二乘残差 $r(\\kappa) = \\| D\\,u - \\mathrm{i}\\,\\kappa\\,u \\|_{M}$，其中 $u \\in \\mathbb{C}^{N+1}$ 是节点采样向量 $u_i = u(x_i)$，$\\|v\\|_M^2 = v^* M v$，$M$ 是基于求积的质量矩阵，${}^*$ 表示共轭转置。推导使 $r(\\kappa)$ 在 $\\kappa \\in \\mathbb{R}$ 上最小化的离散波数 $\\kappa_d$ 的表达式，并仅用 $D$、$M$ 和 $u$ 表示。\n- 对于每种方案（GL 和 GLL），计算指定 $(N,\\kappa)$ 的相对色散误差 $E(N,\\kappa) = |\\kappa_d - \\kappa|/|\\kappa|$。\n- 量化对角质量集中矩阵与精确一致质量矩阵之间的偏差。令 $M_{\\text{true}}$ 表示精确的一致质量矩阵，其元素为 $M_{ij}^{\\text{true}} = \\int_{-1}^1 \\ell_i(x)\\,\\ell_j(x)\\,\\mathrm{d}x$。使用具有 $Q$ 个点的足够高阶的高斯-勒让德求积来近似 $M_{\\text{true}}$，并计算归一化的非对角弗罗贝尼乌斯 (Frobenius) 范数\n$$\n\\rho(N) = \\frac{\\| M_{\\text{true}} - \\operatorname{diag}(\\operatorname{diag}(M_{\\text{true}})) \\|_F}{\\| M_{\\text{true}} \\|_F}.\n$$\n报告 GL 和 GLL 节点的 $\\rho(N)$，以对比精确对角化（GL）和质量集中（GLL）。\n\n您必须遵循的实现和数值细节：\n\n- 构建具有 $N+1$ 个点的 GL 节点和权重。\n- 构建具有 $N+1$ 个点的 GLL 节点和权重。内部节点必须是 $P_N'(x)$ 的零点，权重必须使用标准的正 GLL 公式，以在节点处计算的 $P_N(x)$ 值表示。端点包含在 $x=\\pm 1$ 处。\n- 通过重心坐标数据构建拉格朗日基，并通过对插值多项式求导来组装微分矩阵 $D$。使用重心坐标表示法来控制数值条件数。\n- 使用具有 $Q=200$ 个点的高斯-勒让德求积来近似 $M_{\\text{true}}$，并通过重心坐标公式在求积横坐标上稳健地计算 $\\ell_j(x)$ 的值。您必须遵守所有实体的纯数学定义；不涉及任何物理单位。\n\n测试套件：\n\n计算并汇总以下输入的结果：\n\n- 色散误差测试：\n  - 案例 $\\#1$：$(N,\\kappa) = (2, 1.0)$。\n  - 案例 $\\#2$：$(N,\\kappa) = (4, 2.5)$。\n  - 案例 $\\#3$：$(N,\\kappa) = (8, 7.0)$。\n  - 案例 $\\#4$：$(N,\\kappa) = (6, 10^{-6})$。\n  对于每个案例，输出两个浮点数：$E_{\\text{GL}}$ 和 $E_{\\text{GLL}}$。\n- 质量矩阵对角性测试：\n  - 案例 $\\#5$：$N=6$。输出两个浮点数：$\\rho_{\\text{GL}}$ 和 $\\rho_{\\text{GLL}}$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$$\n[E_{\\text{GL}}^{(1)}, E_{\\text{GLL}}^{(1)}, E_{\\text{GL}}^{(2)}, E_{\\text{GLL}}^{(2)}, E_{\\text{GL}}^{(3)}, E_{\\text{GLL}}^{(3)}, E_{\\text{GL}}^{(4)}, E_{\\text{GLL}}^{(4)}, \\rho_{\\text{GL}}, \\rho_{\\text{GLL}}].\n$$\n所有浮点输出必须是纯十进制数。不应打印任何其他文本。本问题不涉及角度和物理单位。", "solution": "用户提供的问题经评估有效。它在科学上基于数值分析和谱方法的原理，问题提法恰当，并以客观的数学语言表达。它自成体系，没有矛盾或含糊之处。这些任务需要基于既定理论进行实质性的、非平凡的推导和计算。因此，我们可以着手解决。\n\n解决方案分为四个部分：微分矩阵的推导，离散波数的推导，计算色散误差的步骤，以及量化质量矩阵对角性的步骤。\n\n### 1. 微分矩阵 $D$ 的构建\n\n令 $\\{x_i\\}_{i=0}^N$ 为区间 $[-1, 1]$ 上的 $N+1$ 个不同节点。次数最多为 $N$ 且通过点 $(x_j, u_j)$ 的拉格朗日插值多项式 $p(x)$ 由 $p(x) = \\sum_{j=0}^N u_j \\ell_j(x)$ 给出，其中 $\\{\\ell_j(x)\\}_{j=0}^N$ 是满足 $\\ell_j(x_i) = \\delta_{ij}$ 的拉格朗日多项式基。\n\n插值多项式的导数为 $p'(x) = \\sum_{j=0}^N u_j \\ell_j'(x)$。在节点 $x_i$ 处计算该导数，可得到导数值向量 $p'(x_i) = \\sum_{j=0}^N u_j \\ell_j'(x_i)$。这可以表示为矩阵-向量乘积 $\\mathbf{u}' = D \\mathbf{u}$，其中 $\\mathbf{u} = [u_0, \\dots, u_N]^T$，$\\mathbf{u}' = [p'(x_0), \\dots, p'(x_N)]^T$，而 $D$ 是 $(N+1) \\times (N+1)$ 的微分矩阵，其元素为 $D_{ij} = \\ell_j'(x_i)$。\n\n计算 $D_{ij}$ 的一个数值稳定方法源于拉格朗日多项式的重心坐标形式，它避免了直接计算可能病态的 $\\ell_j(x)$ 及其导数。\n\n拉格朗日基多项式 $\\ell_j(x)$ 定义为：\n$$\n\\ell_j(x) = \\prod_{k=0, k \\neq j}^{N} \\frac{x-x_k}{x_j-x_k}\n$$\n对于 $i \\neq j$ 的非对角元素 $D_{ij}$，我们对 $\\ell_j(x)$ 求导并在 $x=x_i$ 处求值：\n$$\n\\ell_j'(x_i) = \\left. \\frac{d}{dx} \\left( \\prod_{k=0, k \\neq j}^{N} \\frac{x-x_k}{x_j-x_k} \\right) \\right|_{x=x_i}\n$$\n使用乘法法则，在 $x=x_i$ 处求值时，和式中唯一的非零项是因子 $(x-x_i)$ 被微分的那一项。这得出：\n$$\n\\ell_j'(x_i) = \\frac{1}{\\prod_{k \\neq j}(x_j-x_k)} \\prod_{k \\neq j, k \\neq i} (x_i-x_k)\n$$\n我们引入重心权重 $\\beta_j = 1 / \\prod_{k \\neq j} (x_j - x_k)$。$\\ell_j'(x_i)$ 的表达式可以用这些权重重写为：\n$$\nD_{ij} = \\ell_j'(x_i) = \\frac{\\beta_j}{\\beta_i} \\frac{1}{x_i - x_j} \\quad \\text{for } i \\neq j\n$$\n对于合理的节点分布，此公式已知是数值稳定的。\n\n对于对角元素 $D_{ii}$，我们利用常数函数的导数为零的性质。令 $u(x)=1$，则对所有 $j$ 都有 $u_j=1$。其多项式插值恰好是 $p(x)=1$，其导数为 $p'(x)=0$。在任何节点 $x_i$ 处，我们必须有：\n$$\np'(x_i) = \\sum_{j=0}^{N} D_{ij} u_j = \\sum_{j=0}^{N} D_{ij} (1) = 0\n$$\n这意味着微分矩阵的每行之和为零。因此，我们可以如下计算对角元素：\n$$\nD_{ii} = - \\sum_{j=0, j \\neq i}^{N} D_{ij}\n$$\n这个过程避免了直接对 $\\ell_i(x)$ 的公式求导时可能发生的灾难性抵消，并为构建 $D$ 提供了一个稳定的算法。\n\n### 2. 离散波数 $\\kappa_d$ 的推导\n\n我们的任务是找到一个实数波数 $\\kappa_d$，它对于给定的、对应于平面波 $u(x) = \\exp(\\mathrm{i}\\kappa x)$ 的节点向量 $\\mathbf{u} \\in \\mathbb{C}^{N+1}$，能够最小化质量加权的最小二乘残差 $r(\\kappa) = \\| D\\mathbf{u} - \\mathrm{i}\\kappa\\mathbf{u} \\|_M$。范数定义为 $\\|\\mathbf{v}\\|_M^2 = \\mathbf{v}^* M \\mathbf{v}$，其中 $M$ 是对角质量矩阵，其元素为 $M_{ii}=w_i  0$，$\\mathbf{v}^*$ 是 $\\mathbf{v}$ 的共轭转置。\n\n最小化 $r(\\kappa)$ 等价于最小化其平方 $r(\\kappa)^2$：\n$$\nr(\\kappa)^2 = \\| D\\mathbf{u} - \\mathrm{i}\\kappa\\mathbf{u} \\|_M^2 = (D\\mathbf{u} - \\mathrm{i}\\kappa\\mathbf{u})^* M (D\\mathbf{u} - \\mathrm{i}\\kappa\\mathbf{u})\n$$\n展开此表达式，并利用 $\\kappa$ 是实数的事实：\n$$\nr(\\kappa)^2 = ((D\\mathbf{u})^* + \\mathrm{i}\\kappa\\mathbf{u}^*) M (D\\mathbf{u} - \\mathrm{i}\\kappa\\mathbf{u})\n$$\n$$\nr(\\kappa)^2 = (D\\mathbf{u})^*M(D\\mathbf{u}) - \\mathrm{i}\\kappa(D\\mathbf{u})^*M\\mathbf{u} + \\mathrm{i}\\kappa\\mathbf{u}^*M(D\\mathbf{u}) + \\kappa^2\\mathbf{u}^*M\\mathbf{u}\n$$\n这是一个关于 $\\kappa$ 的二次函数，形式为 $f(\\kappa) = a\\kappa^2 + b\\kappa + c$，其中：\n$a = \\mathbf{u}^*M\\mathbf{u}$\n$b = \\mathrm{i}(\\mathbf{u}^*M(D\\mathbf{u}) - (D\\mathbf{u})^*M\\mathbf{u})$\n$c = (D\\mathbf{u})^*M(D\\mathbf{u})$\n\n令 $z = \\mathbf{u}^*M(D\\mathbf{u})$。那么 $(D\\mathbf{u})^*M\\mathbf{u} = ((D\\mathbf{u})^*M\\mathbf{u})^* = \\mathbf{u}^*M^*(D\\mathbf{u})^{**} = \\mathbf{u}^*M(D\\mathbf{u}) = z^*$，因为 $M$ 是实对角矩阵，因而是埃尔米特 (Hermitian) 矩阵 ($M^*=M$）。\n系数 $b$ 变为 $b = \\mathrm{i}(z - z^*) = \\mathrm{i}(2\\mathrm{i}\\operatorname{Im}(z)) = -2\\operatorname{Im}(z)$。\n该二次函数为 $r(\\kappa)^2 = (\\mathbf{u}^*M\\mathbf{u})\\kappa^2 - 2\\operatorname{Im}(\\mathbf{u}^*M(D\\mathbf{u}))\\kappa + (D\\mathbf{u})^*M(D\\mathbf{u})$。\n为了找到最小值，我们对 $\\kappa$ 求导并令其为零：\n$$\n\\frac{d}{d\\kappa} r(\\kappa)^2 = 2(\\mathbf{u}^*M\\mathbf{u})\\kappa - 2\\operatorname{Im}(\\mathbf{u}^*M(D\\mathbf{u})) = 0\n$$\n由于质量矩阵 $M$ 是正定的，对于任何非零向量 $\\mathbf{u}$，都有 $\\mathbf{u}^*M\\mathbf{u}  0$。解出 $\\kappa$，我们得到离散波数 $\\kappa_d$：\n$$\n\\kappa_d = \\frac{\\operatorname{Im}(\\mathbf{u}^* M D \\mathbf{u})}{\\mathbf{u}^* M \\mathbf{u}}\n$$\n此表达式仅用微分矩阵 $D$、质量矩阵 $M$ 和节点向量 $\\mathbf{u}$ 来表示 $\\kappa_d$。\n\n### 3. 相对色散误差 $E(N,\\kappa)$ 的计算\n\n对于每种方案（高斯-勒让德，GL，和高斯-洛巴托-勒让德，GLL）以及每个给定的对 $(N, \\kappa)$，相对色散误差 $E = |\\kappa_d - \\kappa|/|\\kappa|$ 的计算步骤如下：\n1.  对于指定的次数 $N$，确定所选方案（GL 或 GLL）的 $N+1$ 个求积节点 $\\{x_i\\}_{i=0}^N$ 和权重 $\\{w_i\\}_{i=0}^N$。\n2.  使用第 1 部分中描述的稳定重心坐标程序构建 $(N+1) \\times (N+1)$ 的微分矩阵 $D$。\n3.  构建对角质量矩阵 $M$，其元素为 $M_{ii} = w_i$。\n4.  在节点处对平面波 $u(x) = \\exp(\\mathrm{i}\\kappa x)$ 进行采样，以形成向量 $\\mathbf{u}$，其元素为 $u_i = \\exp(\\mathrm{i}\\kappa x_i)$。\n5.  使用第 2 部分中推导的公式计算离散波数 $\\kappa_d$。\n6.  计算相对色散误差 $E(N,\\kappa) = |\\kappa_d - \\kappa| / |\\kappa|$。\n\n### 4. 质量矩阵对角性 $\\rho(N)$ 的计算\n\n此任务量化了精确一致质量矩阵 $M_{\\text{true}}$ 与纯对角形式的偏差。$M_{\\text{true}}$ 的元素为 $M_{ij}^{\\text{true}} = \\int_{-1}^1 \\ell_i(x)\\ell_j(x)\\,\\mathrm{d}x$。\n\n对于具有 $N+1$ 个节点的高斯-勒让德 (GL) 方案，求积法则对于次数最高为 $2(N+1)-1=2N+1$ 的多项式是精确的。由于 $\\ell_i(x)\\ell_j(x)$ 是一个次数为 $2N$ 的多项式，且对于 $N \\ge 0$ 有 $2N \\le 2N+1$，因此该积分可由求积法则本身精确计算：\n$$\nM_{ij}^{\\text{true}} = \\int_{-1}^1 \\ell_i(x)\\ell_j(x)\\,\\mathrm{d}x = \\sum_{k=0}^N w_k \\ell_i(x_k)\\ell_j(x_k) = \\sum_{k=0}^N w_k \\delta_{ik}\\delta_{jk} = w_i\\delta_{ij}\n$$\n因此，对于 GL 方案，真实质量矩阵 $M_{\\text{true}}$ 与基于求积的对角质量矩阵 $M_{\\text{quad}}$ 相同。因此，$M_{\\text{true}} - \\operatorname{diag}(\\operatorname{diag}(M_{\\text{true}}))$ 是一个零矩阵，归一化的非对角弗罗贝尼乌斯范数 $\\rho_{\\text{GL}}(N)$ 理论上为零。任何非零结果都将归因于有限精度算术。\n\n对于具有 $N+1$ 个节点的高斯-洛巴托-勒让德 (GLL) 方案，其精确度为 $2N-1$。由于对于 $N \\ge 1$ 有 $2N  2N-1$，GLL 求积不能精确积分 $\\ell_i(x)\\ell_j(x)$，因此 $M_{\\text{true}}$ 不是对角的。这种效应被称为质量集中 (mass lumping)。\n\n为了计算给定 $N$ 的 $\\rho(N)$，我们对 GL 和 GLL 节点集执行以下步骤：\n1.  确定方案的 $N+1$ 个节点 $\\{x_j\\}$。\n2.  使用具有 $Q=200$ 个点的高阶高斯-勒让德求积来近似 $M_{ij}^{\\text{true}}$ 的积分，记为 $\\{y_q, w'_q\\}_{q=0}^{Q-1}$。\n$$\nM_{ij}^{\\text{true}} \\approx \\sum_{q=0}^{Q-1} w'_q \\ell_i(y_q) \\ell_j(y_q)\n$$\n3.  使用第二重心坐标公式稳健地计算 $\\ell_j(y_q)$ 的值。令 $\\beta_j$ 为节点 $\\{x_j\\}$ 的重心权重。则：\n$$\n\\ell_j(y_q) = \\frac{ \\frac{\\beta_j}{y_q - x_j} }{ \\sum_{k=0}^N \\frac{\\beta_k}{y_q - x_k} }\n$$\n这样就可以在求积点 $\\{y_q\\}$ 上计算基函数的值。\n4.  使用高阶求积和来组装矩阵 $M_{\\text{true}}$。在矩阵表示法中，如果 $V$ 是 $Q \\times (N+1)$ 矩阵，其元素为 $V_{qj} = \\ell_j(y_q)$，$W'$ 是权重 $w'_q$ 构成的对角 $Q \\times Q$ 矩阵，则 $M_{\\text{true}} \\approx V^T W' V$。\n5.  计算归一化的非对角弗罗贝尼乌斯范数：\n$$\n\\rho(N) = \\frac{\\| M_{\\text{true}} - \\operatorname{diag}(\\operatorname{diag}(M_{\\text{true}})) \\|_F}{\\| M_{\\text{true}} \\|_F}\n$$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre, legendre, eval_legendre\n\ndef solve():\n    \"\"\"\n    Main solver function that computes and prints the results for the given test cases.\n    \"\"\"\n\n    def get_gl_nodes_weights(n_points):\n        \"\"\"\n        Computes n-point Gauss-Legendre nodes and weights.\n        \"\"\"\n        nodes, weights = roots_legendre(n_points)\n        return nodes, weights\n\n    def get_gll_nodes_weights(n_points):\n        \"\"\"\n        Computes n-point Gauss-Lobatto-Legendre nodes and weights.\n        n_points = N + 1, where N is the polynomial degree.\n        \"\"\"\n        if n_points  2:\n            raise ValueError(\"GLL quadrature requires at least 2 points.\")\n        \n        N = n_points - 1\n        \n        if N > 0:\n            p_n_prime_roots = legendre(N).deriv(1).roots\n        else:\n            p_n_prime_roots = np.array([])\n            \n        nodes = np.concatenate(([-1.0], np.real(p_n_prime_roots), [1.0]))\n        nodes.sort()\n        \n        weights = 2 / (N * (N + 1) * eval_legendre(N, nodes)**2)\n        \n        return nodes, weights\n\n    def barycentric_weights(nodes):\n        \"\"\"\n        Computes barycentric weights for a given set of nodes.\n        \"\"\"\n        n = len(nodes)\n        weights = np.ones(n, dtype=np.float64)\n        for j in range(n):\n            prod = 1.0\n            for k in range(n):\n                if k != j:\n                    prod *= (nodes[j] - nodes[k])\n            weights[j] = 1.0 / prod\n        return weights\n\n    def differentiation_matrix(nodes):\n        \"\"\"\n        Constructs the differentiation matrix using the barycentric formula.\n        \"\"\"\n        n = len(nodes)\n        b_weights = barycentric_weights(nodes)\n        D = np.zeros((n, n), dtype=np.float64)\n        \n        for i in range(n):\n            row_sum = 0.0\n            for j in range(n):\n                if i == j:\n                    continue\n                term = (b_weights[j] / b_weights[i]) / (nodes[i] - nodes[j])\n                D[i, j] = term\n                row_sum += term\n            D[i, i] = -row_sum\n        return D\n\n    def compute_dispersion_error(N, kappa, scheme):\n        \"\"\"\n        Computes the relative dispersion error E(N, kappa).\n        \"\"\"\n        n_points = N + 1\n        \n        if scheme == 'GL':\n            nodes, weights = get_gl_nodes_weights(n_points)\n        elif scheme == 'GLL':\n            nodes, weights = get_gll_nodes_weights(n_points)\n        else:\n            raise ValueError(\"Unknown scheme\")\n\n        D = differentiation_matrix(nodes)\n        M = np.diag(weights)\n        u = np.exp(1j * kappa * nodes)\n        \n        u_H = u.conj().T\n        \n        numerator = np.imag(u_H @ M @ D @ u)\n        denominator = u_H @ M @ u\n        \n        kappa_d = numerator / denominator.real\n        \n        if np.abs(kappa) == 0:\n            return np.abs(kappa_d)\n            \n        return np.abs(kappa_d - kappa) / np.abs(kappa)\n\n    def compute_mass_matrix_diagonality(N, scheme, Q=200):\n        \"\"\"\n        Computes the normalized off-diagonal Frobenius norm rho(N).\n        \"\"\"\n        n_points = N + 1\n        \n        if scheme == 'GL':\n            x_nodes, _ = get_gl_nodes_weights(n_points)\n        elif scheme == 'GLL':\n            x_nodes, _ = get_gll_nodes_weights(n_points)\n        else:\n            raise ValueError(\"Unknown scheme\")\n\n        b_weights = barycentric_weights(x_nodes)\n        y_q, w_q = get_gl_nodes_weights(Q)\n        \n        V_mat = np.zeros((Q, n_points), dtype=np.float64)\n        \n        # Denominator for second barycentric formula\n        bary_denom = np.zeros(Q, dtype=np.float64)\n        for k in range(n_points):\n            # To avoid division by zero when a quadrature point y_q matches a node x_k\n            # we handle these terms carefully.\n            diff = y_q - x_nodes[k]\n            # Use a small tolerance to check for equality\n            safe_diff = np.where(np.isclose(diff, 0), np.inf, diff)\n            bary_denom += b_weights[k] / safe_diff\n\n        for j in range(n_points):\n            # Numerator for second barycentric formula\n            diff = y_q - x_nodes[j]\n            safe_diff = np.where(np.isclose(diff, 0), np.inf, diff)\n            bary_num = b_weights[j] / safe_diff\n            \n            # The value of the Lagrange polynomial is 1 at its own node and 0 at others.\n            V_mat[:, j] = bary_num / bary_denom\n            exact_indices = np.where(np.isclose(y_q, x_nodes[j]))[0]\n            if len(exact_indices) > 0:\n                V_mat[exact_indices, :] = 0.0\n                V_mat[exact_indices, j] = 1.0\n\n        M_true = V_mat.T @ np.diag(w_q) @ V_mat\n        \n        M_diag_only = np.diag(np.diag(M_true))\n        \n        num_norm = np.linalg.norm(M_true - M_diag_only, 'fro')\n        den_norm = np.linalg.norm(M_true, 'fro')\n        \n        if den_norm == 0:\n            return 0.0\n            \n        return num_norm / den_norm\n\n    # Test suite from the problem statement\n    dispersion_tests = [\n        (2, 1.0),\n        (4, 2.5),\n        (8, 7.0),\n        (6, 1e-6)\n    ]\n    mass_matrix_test_N = 6\n\n    results = []\n\n    # Run dispersion error tests\n    for N, kappa in dispersion_tests:\n        E_GL = compute_dispersion_error(N, kappa, 'GL')\n        E_GLL = compute_dispersion_error(N, kappa, 'GLL')\n        results.extend([E_GL, E_GLL])\n\n    # Run mass matrix diagonality test\n    # For GL, rho is theoretically 0. Numerical result should be close to machine epsilon.\n    # The provided solution code might have issues if y_q is exactly a node x_k.\n    # A robust implementation is needed.\n    rho_GL = compute_mass_matrix_diagonality(mass_matrix_test_N, 'GL')\n    rho_GLL = compute_mass_matrix_diagonality(mass_matrix_test_N, 'GLL')\n    results.extend([rho_GL, rho_GLL])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```", "id": "3388916"}]}