{"hands_on_practices": [{"introduction": "虽然更高阶的数值积分法则似乎能提供更高的精度，但在实践中，这种精度通常伴随着稳定性的牺牲。本练习将通过计算揭示高阶牛顿-科茨法则的一个根本缺陷。通过直接计算不同阶数的积分权重，并将其与精确参考解进行比较，我们将量化由于等距节点上的高阶多项式插值所带来的病态问题，从而直观地理解数值敏感性、舍入误差和抵消误差等重要概念 [@problem_id:3401957]。", "problem": "考虑单位区间上的闭合牛顿-科特斯求积，其中，对于一个足够光滑的函数 $f(x)$，其在 $[0,1]$ 上的积分近似为\n$$\n\\int_{0}^{1} f(x)\\,dx \\approx \\sum_{i=0}^{n} w_i f(x_i),\n$$\n其中 $x_i = \\frac{i}{n}$（对于 $i = 0,1,\\dots,n$）是 $[0,1]$ 上的 $n+1$ 个等距节点，而 $w_i$ 是求积权重。在谱方法和间断伽辽金方法（Spectral/DG）的背景下，该系列公式是在等距网格上进行求積的典型示例，已知当 $n$ 较大时，由于等距点上高次多项式插值带来的病态问题，该方法会出现数值不稳定性。\n\n根据对多项式的精确性要求，该求积必须对 $j=0,\\dots,n$ 的每个单项式 $p_j(x)=x^j$ 进行精确积分。这为权重导出了一个线性系统，\n$$\n\\sum_{i=0}^{n} w_i x_i^j \\;=\\; \\int_{0}^{1} x^j\\,dx \\;=\\; \\frac{1}{j+1}, \\quad j=0,1,\\dots,n,\n$$\n可以写成矩阵形式 $A\\,\\mathbf{w}=\\mathbf{m}$，其中 $A_{j,i}=x_i^j$ 且 $\\mathbf{m}_j=\\frac{1}{j+1}$。对于较大的 $n$，在标准双精度下求解此系统可能存在数值敏感性。\n\n任务。编写一个完整的、可运行的程序，该程序：\n1) 对于每个给定的 $n$，通过两种方式求解 $A\\,\\mathbf{w}=\\mathbf{m}$ 来构建闭合牛顿-科特斯权重向量 $\\mathbf{w}\\in\\mathbb{R}^{n+1}$：\n- 使用稠密线性代数在标准双精度下求解。\n- 在精确有理数算术中（将所有条目表示为有理数）求解，以获得高质量的参考解。\n2) 将精确有理数参考解转换为高精度实数值，并报告双精度解的数值敏感性的定量度量：\n- 相对 $\\ell_\\infty$-范数误差\n$$\n\\mathrm{rinf} \\;=\\; \\frac{\\max_{0\\le i\\le n} \\left| w_i^{(\\mathrm{double})} - w_i^{(\\mathrm{ref})}\\right|}{\\max_{0\\le i\\le n} \\left| w_i^{(\\mathrm{ref})}\\right|}.\n$$\n- 双精度权重之和与 1 的绝对偏差，\n$$\n\\mathrm{sdev} \\;=\\; \\left| \\sum_{i=0}^{n} w_i^{(\\mathrm{double})} - 1 \\right|.\n$$\n- 两个布尔标志，分别指示是否存在严格为负的参考权重和是否存在严格为负的双精度权重。\n3) 使用以上结果，凭经验评估随着 $n$ 增大而产生的舍入和抵消效应。\n\n使用以下阶数（子区间数量）的测试套件来检验不同数值敏感性范围：\n- $n=1$（边界情况：两个节点）。\n- $n=2$（经典辛普森型范围）。\n- $n=8$（中等高阶）。\n- $n=12$（敏感性开始增加的高阶）。\n- $n=16$（对于等距牛顿-科特斯方法而言的极高阶，通常不稳定）。\n\n您的程序必须：\n- 对于测试套件中的每个 $n$，按顺序输出一个包含五个条目的列表\n$$\n\\left[n,\\; \\mathrm{rinf},\\; \\mathrm{sdev},\\; \\mathrm{neg\\_ref},\\; \\mathrm{neg\\_double}\\right],\n$$\n其中 $n$ 是整数，$\\mathrm{rinf}$ 和 $\\mathrm{sdev}$ 是浮点数，$\\mathrm{neg\\_ref}$ 和 $\\mathrm{neg\\_double}$ 是布尔值。\n- 将每个 $n$ 的列表聚合到一个单独的列表中，并打印一行包含此聚合列表的内容，采用标准 Python 列表语法，例如，\n$$\n\\big[ [\\cdots], [\\cdots], \\dots \\big].\n$$\n\n需使用的科学和算法基础：\n- 闭合牛顿-科特斯权重的基本定义：使得求积对 $[0,1]$ 上最高为 $n$ 次的所有多项式都精确。\n- 从单项式精确性构建线性系统 $A\\,\\mathbf{w}=\\mathbf{m}$。\n- 通过对 $x_i=\\frac{i}{n}$ 和 $\\int_0^1 x^j dx=\\frac{1}{j+1}$ 使用有理数算术进行精确参考计算。\n- 使用相对误差和绝对和偏差作为数值敏感性度量。\n\n角度单位、物理单位和百分比不适用。所有输出均为无单位的实数或布尔值。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[[n,rinf,sdev,neg_ref,neg_double], ...]”）。", "solution": "用户提供了一个有效的问题。\n\n### 步骤 1：提取已知信息\n- **求积法则**：函数 $f(x)$ 在 $[0,1]$ 上的积分由闭合牛顿-科特斯公式近似：\n$$ \\int_{0}^{1} f(x)\\,dx \\approx \\sum_{i=0}^{n} w_i f(x_i) $$\n- **节点**：$[0,1]$ 上的 $n+1$ 个等距节点，由 $x_i = \\frac{i}{n}$ 给出，其中 $i = 0,1,\\dots,n$。\n- **权重计算**：通过要求求积对所有单项式 $p_j(x)=x^j$（其中 $j=0,\\dots,n$）都精确来确定权重 $w_i$。这会产生以下线性系统：\n$$ \\sum_{i=0}^{n} w_i x_i^j = \\frac{1}{j+1}, \\quad j=0,1,\\dots,n $$\n- **矩阵形式**：线性系统为 $A\\,\\mathbf{w}=\\mathbf{m}$，其中 $A_{j,i}=x_i^j$（一个范德蒙矩阵），$\\mathbf{w}$ 是权重向量，$\\mathbf{m}_j=\\frac{1}{j+1}$。\n- **计算方法**：\n    1.  **双精度**：使用标准浮点算术求解系统。令解为 $\\mathbf{w}^{(\\mathrm{double})}$。\n    2.  **精确参考**：使用精确有理数算术求解系统。将结果转换为高精度浮点数以进行比较，记为 $\\mathbf{w}^{(\\mathrm{ref})}$。\n- **数值敏感性度量**：\n    1.  **相对 $\\ell_\\infty$-范数误差**：$\\mathrm{rinf} = \\frac{\\max_{i} \\left| w_i^{(\\mathrm{double})} - w_i^{(\\mathrm{ref})}\\right|}{\\max_{i} \\left| w_i^{(\\mathrm{ref})}\\right|}$。\n    2.  **和偏差**：$\\mathrm{sdev} = \\left| \\sum_{i=0}^{n} w_i^{(\\mathrm{double})} - 1 \\right|$。\n    3.  **负权重标志**：$\\mathrm{neg\\_ref}$（布尔值，用于参考权重）和 $\\mathrm{neg\\_double}$（布尔值，用于双精度权重）。\n- **测试套件**：将对 $n \\in \\{1, 2, 8, 12, 16\\}$ 进行分析。\n- **输出格式**：一个列表的列表，其中每个内部列表的格式为 $[n, \\mathrm{rinf}, \\mathrm{sdev}, \\mathrm{neg\\_ref}, \\mathrm{neg\\_double}]$。\n\n### 步骤 2：使用提取的已知信息进行验证\n- **科学依据**：该问题是数值分析中的一个经典研究。通过范德蒙系统构建牛顿-科特斯权重以及该系统在等距点上的著名病态问题都是基本概念。所提议的实验在科学上是合理的，并直接证明了这些原理。\n- **适定性**：对于任何给定的 $n \\ge 1$，节点 $x_i$ 都是不同的。因此，相应的范德蒙矩阵 $A$ 是非奇异的，保证了权重 $\\mathbf{w}$ 有唯一解。该问题定义明确，并具有唯一的、有意义的解。\n- **客观性**：所有术语、公式和度量都以数学精度定义。该问题没有任何主观或模棱两可的语言。\n- **其他缺陷**：该问题是自包含的、一致的、可行的且非平凡的。它没有违反任何其他无效性标准。\n\n### 步骤 3：结论与行动\n该问题是有效的。将制定一个合理的解决方案。\n\n### 基于原则的设计\n该解决方案通过按规定实施数值实验来进行。对于测试套件中的每个 $n$ 值，我们将执行以下步骤：\n\n1.  **系统构建（双精度）**：我们将系统大小定义为 $N = n+1$。节点 $x_i = i/n$ 被创建为一个双精度浮点数的 `numpy` 数组。使用 `numpy.vander` 构建范德蒙矩阵 $A$，右侧向量 $\\mathbf{m}$ 也由浮点数构成。然后使用 `numpy.linalg.solve` 求解系统 $A \\mathbf{w} = \\mathbf{m}$，得到 $\\mathbf{w}^{(\\mathrm{double})}$。此函数实现了一种标准的、鲁棒的算法（通常基于 LU 分解）来求解稠密线性系统。\n\n2.  **系统构建（精确有理数算术）**：为获得高质量的参考解，我们避免浮点表示误差。我们使用 Python 的 `fractions.Fraction` 类，该类可以精确地对有理数进行算术运算。节点 $x_i = i/n$ 和单项式积分 $1/(j+1)$ 表示为 `Fraction` 对象。矩阵 $A$ 和向量 $\\mathbf{m}$ 由这些精确的有理数条目构建。\n\n3.  **精确系统求解**：由于 `numpy` 和 `scipy` 没有内置针对有理数类型的线性代数求解器，因此必须实现一个自定义求解器。我们将使用高斯-若尔当消元法。该算法将增广矩阵 $[A|\\mathbf{m}]$ 转换为 $[I|\\mathbf{w}]$，其中 $I$ 是单位矩阵，$\\mathbf{w}$ 是解向量。算法内的所有算术运算（加、减、乘、除）都使用 `Fraction` 的方法执行，确保结果 $\\mathbf{w}^{(\\mathrm{ref\\_rational})}$ 是精确的。\n\n4.  **度量计算**：\n    - 精确的有理数权重 $\\mathbf{w}^{(\\mathrm{ref\\_rational})}$ 被转换为标准的双精度浮点数，得到 $\\mathbf{w}^{(\\mathrm{ref})}$。\n    - 相对 $\\ell_\\infty$ 误差 `rinf` 的计算方法是：找到 `w_double` 和 `w_ref` 之间的最大绝对差，并用 `w_ref` 的最大绝对值进行归一化。这量化了计算出的权重中的最坏情况相对误差。\n    - 和偏差 `sdev` 是双精度权重之和与 $1$ 之间的绝对差。由于条件 $\\sum w_i = 1$（对于 $j=0$）是线性系统中的一个方程，该度量衡量了数值解满足这一基本约束的程度。\n    - 布尔标志 `neg_ref` 和 `neg_double` 是通过检查相应向量中是否有任何权重严格为负来确定的。对参考解的检查是在转换为浮点数之前对精确有理数值进行的，以避免由浮点不精确性引起的任何歧义。\n\n对每个 $n$ 重复此过程，并将结果聚合为指定的列表的列表格式作为最终输出。该实验旨在揭示随着 $n$ 的增加，数值精度的下降情况，这是等距点范德蒙矩阵条件数呈指数增长的直接后果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom fractions import Fraction\nimport sys\n\n# Increase recursion limit for potentially deep calls in Fraction arithmetic for large n.\n# Although not strictly necessary for n=16, it is good practice for larger systems.\nsys.setrecursionlimit(2000)\n\ndef solve_rational_system(A_rational, m_rational):\n    \"\"\"\n    Solves a linear system Ax=b where A and b contain Fraction objects.\n    Uses Gauss-Jordan elimination.\n\n    Args:\n        A_rational (list of lists of Fraction): The N x N coefficient matrix.\n        m_rational (list of Fraction): The N-element right-hand side vector.\n\n    Returns:\n        list of Fraction: The solution vector x.\n    \"\"\"\n    N = len(m_rational)\n    # Create the augmented matrix [A|m]\n    Ab = [A_rational[i] + [m_rational[i]] for i in range(N)]\n\n    for i in range(N):\n        # Find a non-zero pivot in column i, at or below the current row\n        pivot_row = i\n        while pivot_row  N and Ab[pivot_row][i] == 0:\n            pivot_row += 1\n\n        if pivot_row == N:\n            # This should not happen for the non-singular matrices in this problem\n            raise ValueError(\"Matrix is singular or near-singular.\")\n\n        # Swap the current row with the pivot row\n        Ab[i], Ab[pivot_row] = Ab[pivot_row], Ab[i]\n\n        # Get the pivot element\n        pivot_val = Ab[i][i]\n\n        # Normalize the pivot row by dividing all its elements by the pivot value\n        for j in range(i, N + 1):\n            Ab[i][j] /= pivot_val\n\n        # Eliminate the entry in the current pivot column for all other rows\n        for k in range(N):\n            if k != i:\n                factor = Ab[k][i]\n                # Subtract factor * (pivot row) from row k\n                for j in range(i, N + 1):\n                    Ab[k][j] -= factor * Ab[i][j]\n\n    # After Gauss-Jordan, the last column of the augmented matrix is the solution\n    w_rational = [Ab[row][N] for row in range(N)]\n    return w_rational\n\n\ndef compute_metrics_for_n(n):\n    \"\"\"\n    Constructs and solves the Newton-Cotes system for a given degree n,\n    and computes the specified numerical sensitivity metrics.\n    \"\"\"\n    N = n + 1  # Number of nodes and dimension of the system\n\n    # --- 1. Double precision solution ---\n    nodes_double = np.linspace(0.0, 1.0, N, dtype=np.float64)\n    # The matrix A has entries A_ji = x_i^j.\n    # np.vander(x, N, increasing=True) produces columns [x^0, x^1, ...].\n    # Transposing gives rows [x_0^j, x_1^j, ...], which is what we need.\n    A_double = np.vander(nodes_double, N, increasing=True).T\n    m_double = 1.0 / (np.arange(N, dtype=np.float64) + 1.0)\n    \n    w_double = np.linalg.solve(A_double, m_double)\n\n    # --- 2. Exact rational reference solution ---\n    # Handle the case n=0 if it were to be used, although test cases start at n=1\n    if n == 0:\n        nodes_rational = [Fraction(0, 1)] # A single node at 0\n    else:\n        nodes_rational = [Fraction(i, n) for i in range(N)]\n\n    A_rational = [[node ** j for node in nodes_rational] for j in range(N)]\n    m_rational = [Fraction(1, j + 1) for j in range(N)]\n\n    w_ref_rational = solve_rational_system(A_rational, m_rational)\n    \n    # Convert rational reference solution to float for comparison\n    w_ref = np.array([float(f) for f in w_ref_rational], dtype=np.float64)\n\n    # --- 3. Compute metrics ---\n    # Relative infinity-norm error\n    abs_error = np.abs(w_double - w_ref)\n    max_abs_error = np.max(abs_error)\n    max_abs_ref = np.max(np.abs(w_ref))\n    \n    if max_abs_ref == 0.0:\n        rinf = np.inf if max_abs_error > 0.0 else 0.0\n    else:\n        rinf = max_abs_error / max_abs_ref\n\n    # Absolute deviation of sum from unity\n    sdev = np.abs(np.sum(w_double) - 1.0)\n\n    # Check for negative weights\n    neg_ref = any(w  Fraction(0) for w in w_ref_rational)\n    neg_double = bool(np.any(w_double  0))\n\n    return [n, rinf, sdev, neg_ref, neg_double]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 8, 12, 16]\n\n    results = []\n    for n in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        result = compute_metrics_for_n(n)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format \"[[...],[...]]\" is standard Python list representation.\n    # The template 'f\"[{\",\".join(map(str, results))}]\"' correctly produces this.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3401957"}, {"introduction": "一个成功的数值积分不仅取决于积分法则本身，还取决于被积函数的性质。即使是低阶的稳定法则，在处理非光滑函数时也可能表现不佳。本练习将用一个带有端点奇异性的积分来挑战一个标准的开区间牛顿-科茨法则，旨在揭示其局限性，并启发我们思考更先进的解决方案，如变量替换（正则化）或加权高斯积分 [@problem_id:3401936]。", "problem": "在高阶间断 Galerkin (DG) 和谱元离散化的背景下，边界邻近积分可能表现出代数端点奇点，这对标准的闭式 Newton-Cotes 求积公式构成了挑战。考虑积分\n$$\n\\int_{0}^{1} x^{-1/2}\\,dx,\n$$\n该积分是可积的，但在左端点有一个平方根奇点。为了模拟在 DG 通量积分中排除端点的常见做法，请从第一性原理出发，推导在区间 $[0,1]$ 上具有等距内部节点的开三点 Newton-Cotes 求积法则，并用它得出一个近似上述积分的单一精确解析表达式。\n\n你的推导必须从基本定义开始：在三个等距内节点上构造二次 Lagrange 插值多项式，并将其在 $[0,1]$ 上精确积分以获得求积权重。然后，将得到的求积公式应用于函数 $f(x)=x^{-1/2}$，在指定节点上求值，以获得所要求的精确解析表达式。\n\n最后，在不引用任何预制求积公式的情况下，解释为什么通过变量替换来正则化端点奇点，或者使用与奇异权重对齐的加权正交多项式求积，可以显著提高谱方法和间断 Galerkin (DG) 方法的精度。你可以引用高斯-雅可比求积（首次使用时全称为 Gauss-Jacobi Quadrature (GJQ)）来从概念上说明加权方法，但不要计算任何其他数值近似值。\n\n不要四舍五入；将开式 Newton-Cotes 近似值表示为单一的封闭形式解析表达式。", "solution": "问题陈述经评估有效。它在数值分析领域有科学依据，问题设定良好，目标明确，没有矛盾或含糊之处。\n\n任务是推导并应用开三点 Newton-Cotes 求积法则来近似积分 `$\\int_{0}^{1} x^{-1/2}\\,dx$`，然后从概念上解释替代方法对此类奇异积分的优越性。\n\n首先，我们推导在区间 `$[0, 1]$` 上的开三点 Newton-Cotes 求积法则。该法则使用三个等距的内节点。对于区间 `$[a, b]$` 和 `$n=3$` 个内节点，步长 `$h$` 由 `$h = (b-a)/(n+1)$` 给出。当 `$a=0$` 和 `$b=1$` 时，我们有 `$h = (1-0)/(3+1) = 1/4$`。节点 `$x_j$`（其中 `$j=1, 2, 3$`）位于 `$x_j = a + j h$`。\n求积节点为：\n$$\nx_1 = 0 + 1 \\cdot \\frac{1}{4} = \\frac{1}{4} \\\\\nx_2 = 0 + 2 \\cdot \\frac{1}{4} = \\frac{1}{2} \\\\\nx_3 = 0 + 3 \\cdot \\frac{1}{4} = \\frac{3}{4}\n$$\n该求积法则通过对穿过这些节点的二次 Lagrange 插值多项式 `$P_2(x)$` 进行积分来近似函数 `$f(x)$` 的积分。该多项式由 `$P_2(x) = \\sum_{j=1}^{3} f(x_j) L_j(x)$` 给出，其中 `$L_j(x)$` 是 Lagrange 基多项式。\n求积近似值为 `$\\int_0^1 f(x) dx \\approx \\int_0^1 P_2(x) dx = \\sum_{j=1}^{3} f(x_j) \\left(\\int_0^1 L_j(x) dx\\right) = \\sum_{j=1}^{3} w_j f(x_j)$`。权重 `$w_j$` 是基多项式 `$L_j(x)$` 在 `$[0, 1]$` 上的积分。\n\n对于节点 `$x_1=1/4$`、`$x_2=1/2$` 和 `$x_3=3/4$`，Lagrange 基多项式为：\n$$\nL_1(x) = \\frac{(x-x_2)(x-x_3)}{(x_1-x_2)(x_1-x_3)} = \\frac{(x-1/2)(x-3/4)}{(1/4-1/2)(1/4-3/4)} = \\frac{x^2 - \\frac{5}{4}x + \\frac{3}{8}}{(-\\frac{1}{4})(-\\frac{2}{4})} = \\frac{x^2 - \\frac{5}{4}x + \\frac{3}{8}}{1/8} = 8x^2 - 10x + 3\n$$\n$$\nL_2(x) = \\frac{(x-x_1)(x-x_3)}{(x_2-x_1)(x_2-x_3)} = \\frac{(x-1/4)(x-3/4)}{(1/2-1/4)(1/2-3/4)} = \\frac{x^2 - x + \\frac{3}{16}}{(\\frac{1}{4})(-\\frac{1}{4})} = \\frac{x^2 - x + \\frac{3}{16}}{-1/16} = -16x^2 + 16x - 3\n$$\n$$\nL_3(x) = \\frac{(x-x_1)(x-x_2)}{(x_3-x_1)(x_3-x_2)} = \\frac{(x-1/4)(x-1/2)}{(3/4-1/4)(3/4-1/2)} = \\frac{x^2 - \\frac{3}{4}x + \\frac{1}{8}}{(\\frac{2}{4})(\\frac{1}{4})} = \\frac{x^2 - \\frac{3}{4}x + \\frac{1}{8}}{1/8} = 8x^2 - 6x + 1\n$$\n接下来，我们通过将这些多项式从 `$0$` 积分到 `$1$` 来计算权重 `$w_j$`：\n$$\nw_1 = \\int_{0}^{1} (8x^2 - 10x + 3) dx = \\left[ \\frac{8}{3}x^3 - 5x^2 + 3x \\right]_{0}^{1} = \\frac{8}{3} - 5 + 3 = \\frac{2}{3}\n$$\n$$\nw_2 = \\int_{0}^{1} (-16x^2 + 16x - 3) dx = \\left[ -\\frac{16}{3}x^3 + 8x^2 - 3x \\right]_{0}^{1} = -\\frac{16}{3} + 8 - 3 = -\\frac{1}{3}\n$$\n$$\nw_3 = \\int_{0}^{1} (8x^2 - 6x + 1) dx = \\left[ \\frac{8}{3}x^3 - 3x^2 + x \\right]_{0}^{1} = \\frac{8}{3} - 3 + 1 = \\frac{2}{3}\n$$\n因此，在 `$[0, 1]$` 上的开三点 Newton-Cotes 法则为：\n$$\n\\int_0^1 f(x) dx \\approx \\frac{2}{3}f\\left(\\frac{1}{4}\\right) - \\frac{1}{3}f\\left(\\frac{1}{2}\\right) + \\frac{2}{3}f\\left(\\frac{3}{4}\\right)\n$$\n现在，我们将此法则应用于函数 `$f(x) = x^{-1/2}$`。该求积法则的开放性至关重要，因为它避免了在奇点 `$x=0$` 处对函数求值。\n我们在节点处计算 `$f(x)$` 的值：\n$$\nf(x_1) = f\\left(\\frac{1}{4}\\right) = \\left(\\frac{1}{4}\\right)^{-1/2} = 4^{1/2} = 2\n$$\n$$\nf(x_2) = f\\left(\\frac{1}{2}\\right) = \\left(\\frac{1}{2}\\right)^{-1/2} = 2^{1/2} = \\sqrt{2}\n$$\n$$\nf(x_3) = f\\left(\\frac{3}{4}\\right) = \\left(\\frac{3}{4}\\right)^{-1/2} = \\left(\\frac{4}{3}\\right)^{1/2} = \\frac{2}{\\sqrt{3}} = \\frac{2\\sqrt{3}}{3}\n$$\n将这些值代入求积公式，得到积分的近似值：\n$$\n\\int_{0}^{1} x^{-1/2}\\,dx \\approx \\frac{2}{3}(2) - \\frac{1}{3}(\\sqrt{2}) + \\frac{2}{3}\\left(\\frac{2\\sqrt{3}}{3}\\right) = \\frac{4}{3} - \\frac{\\sqrt{2}}{3} + \\frac{4\\sqrt{3}}{9}\n$$\n为了将其表示为单个分数，我们找到公分母 `$9$`：\n$$\n\\frac{4 \\cdot 3}{9} - \\frac{\\sqrt{2} \\cdot 3}{9} + \\frac{4\\sqrt{3}}{9} = \\frac{12 - 3\\sqrt{2} + 4\\sqrt{3}}{9}\n$$\n\n最后，我们解释为什么替代方法对此类问题更优越。核心问题在于，Newton-Cotes 法则用一个单一的、全局光滑的多项式来近似被积函数 `$f(x)$`。函数 `$f(x) = x^{-1/2}$` 在 `$x=0$` 处有一个垂直渐近线，其导数在该点也是奇异的。没有一个单一的低次多项式能够准确地捕捉在整个区间 `$[0, 1]$` 上的这种行为。光滑多项式近似与奇异函数之间的这种不匹配导致了巨大的误差和缓慢的收敛，这在高阶方法（如 DG 和谱元法）中是一个严重问题，因为这些方法在处理光滑问题时期望实现快速（指数级）收敛。\n\n两种更优越的策略是：\n1.  **变量替换（正则化）**：此技术将积分转换为具有正则（光滑）被积函数的积分。对于 `$\\int_0^1 x^{-1/2} dx$`，通过替换 `$x = u^2$` 和 `$dx = 2u\\,du$`，积分转换为 `$\\int_0^1 (u^2)^{-1/2} (2u\\,du) = \\int_0^1 u^{-1} (2u\\,du) = \\int_0^1 2\\,du$`。新的被积函数是一个常数 `$g(u)=2$`，它是无限光滑的。现在，任何标准的求積法则都可以以非常高（通常是精确）的精度对其进行积分。这消除了奇点，恢复了高阶方法的快速收敛性。\n\n2.  **加权正交多项式求积**：此方法修改求积法则，使其对特定类别的奇异函数达到最优。该积分被视为 `$\\int_0^1 w(x)g(x)dx$`，其中 `$w(x)=x^{-1/2}$` 是一个权函数，而 `$g(x)=1$`。高斯求积法则针对特定的权函数，在给定点数下提供最优精度。对于区间 ` $[-1, 1] $` 上形式为 `$(1-z)^\\alpha (1+z)^\\beta$` 的权函数，相应的最优法则是高斯-雅可比求积 (Gauss-Jacobi Quadrature, GJQ)。在 `$[0, 1]$` 上的奇点 `$x^{-1/2}$` 可以映射到 ` $[-1, 1] $` 上的一个雅可比类型的权重。GJQ 法则的节点和权重是经过专门选择的，可以精确地积分权函数与最高达到某个高度的多项式的乘积。通过将奇异行为“内置”到求积法则本身，GJQ 即使使用很少的点也能达到非常高的精度，因为它只需要近似被积函数的非奇异部分（在本例中为 `$g(x)=1$`），这非常简单。在谱方法和 DG 方法中，这对应于使用相对于奇异权重正交的基函数（例如，雅可比多项式），这同样可以恢复指数收敛性。\n\n相比之下，为无权积分（即 `$w(x)=1$`）设计的 Newton-Cotes 公式从根本上不适合这项任务，其精度无法仅通过增加点数来显著提高。", "answer": "$$\n\\boxed{\\frac{12 - 3\\sqrt{2} + 4\\sqrt{3}}{9}}\n$$", "id": "3401936"}, {"introduction": "现在，我们将把之前练习中揭示的抽象数值概念联系起来，探究它们的实际后果。我们已经看到，高阶牛顿-科茨法则可能会产生负权重；在本练习中，我们将研究当使用这种含有负权重的积分法则来离散化一个物理算子（如扩散算子）时会发生什么。通过计算离散算子矩阵的特征值，您将亲眼见证一个不合适的积分选择如何破坏算子一个关键的数学性质——对称正定性，这在间断伽辽金（DG）方法的稳定性分析中至关重要 [@problem_id:3401958]。", "problem": "考虑间断 Galerkin (DG) 形式的一维扩散算子，该算子被限制在映射到参考区间 $\\left[-1,1\\right]$ 的单个单元上。扩散的双线性形式的单元体积贡献定义为\n$$\na(u,v) \\;=\\; \\int_{-1}^{1} \\partial_x u(x)\\,\\partial_x v(x)\\,\\mathrm{d}x,\n$$\n其中 $u$ 和 $v$ 属于参考单元上的一个多项式空间。在谱 DG 实践中，一个常见的选择是在 $\\left[-1,1\\right]$ 上使用勒让德多项式 $\\{P_n(x)\\}_{n\\ge 0}$ 来表示函数。为避免扩散能中的零模，我们考虑由 $\\{P_n(x)\\}_{n=1}^{p}$ 张成的子空间，即我们排除了常数模 $P_0$。\n\n数值积分通过 Newton–Cotes 求积公式执行。设一个闭合 Newton–Cotes 法则在 $\\left[-1,1\\right]$ 上由 $N$ 个包括端点的等距节点定义：\n$$\nx_k \\;=\\; -1 + \\frac{2k}{N-1}, \\quad k=0,1,\\dots,N-1,\n$$\n及其关联权重 $\\{w_k\\}_{k=0}^{N-1}$。该求积通过加权和 $\\sum_{k=0}^{N-1} w_k\\,g(x_k)$ 来近似形式为 $\\int_{-1}^{1} g(x)\\,\\mathrm{d}x$ 的积分。闭合 Newton–Cotes 权重由其对最高 $N-1$ 次的代数单项式的精确性定义：\n$$\n\\sum_{k=0}^{N-1} w_k\\,x_k^m \\;=\\; \\int_{-1}^{1} x^m\\,\\mathrm{d}x, \\quad m=0,1,\\dots,N-1.\n$$\n众所周知，对于足够大的 $N$，一些闭合 Newton–Cotes 权重会变为负数。欠积分指的是使用的求积的精确度低于在所选多项式空间上精确积分双线性形式所需的阶数。\n\n离散单元算子（双线性形式的 Gram 矩阵）按如下方式构造。设 $D(x)$ 表示勒让德基函数导数的列向量，\n$$\nD(x) \\;=\\; \\begin{bmatrix} P_1'(x) \\\\ P_2'(x) \\\\ \\vdots \\\\ P_p'(x) \\end{bmatrix},\n$$\n并定义离散 Gram 矩阵 $G\\in\\mathbb{R}^{p\\times p}$ 为\n$$\nG \\;=\\; \\sum_{k=0}^{N-1} w_k\\, D(x_k)\\,D(x_k)^\\top.\n$$\n该构造对应于对所有基索引 $i,j$，将被积函数 $\\partial_x P_i(x)\\,\\partial_x P_j(x)$ 应用闭合 Newton–Cotes 求积。如果 $G$ 的最小特征值为非正数，则双线性形式的对称正定性会丧失，这可能是由秩亏（例如，欠积分导致零特征值）或不定性（例如，负权重导致负特征值）引起的。\n\n您的任务是实现一个程序，对于一组给定的多项式阶数 $p$ 和求积点数 $N$，通过上述过程构造 $G$，计算其谱，并确定对称正定性是否丧失。使用以下测试套件：\n- 情况 1：$p=3$, $N=5$。\n- 情况 2：$p=5$, $N=4$（欠积分，求积点数少于基维度）。\n- 情况 3：$p=9$, $N=11$（已知存在负权重的高阶闭合 Newton–Cotes 法则）。\n- 情况 4：$p=1$, $N=2$（基准梯形法则）。\n- 情况 5：$p=8$, $N=9$（存在负权重的闭合 Newton–Cotes 法则）。\n\n对于每种情况：\n1. 通过在 $\\left[-1,1\\right]$ 上的等距节点上强制执行高达 $N-1$ 次的多项式精确性，来构造闭合 Newton–Cotes 权重 $\\{w_k\\}_{k=0}^{N-1}$。\n2. 在所有求积节点 $x_k$ 处，计算 $n=1,\\dots,p$ 的 $P_n'(x_k)$。\n3. 如上所述组装 $G$，并通过取 $\\frac{1}{2}\\left(G+G^\\top\\right)$ 对其进行对称化。\n4. 计算 $G$ 的排序后的特征值（升序）。\n5. 通过检查最小特征值是否小于或等于容差 $\\varepsilon=10^{-10}$ 来确定对称正定性是否丧失。\n\n您的程序必须输出单行，其中包含一个列表，其长度等于测试用例的数量。此列表中的每个条目本身都必须是一个列表，由排序后的特征值（浮点数）和一个指示对称正定性是否丧失的布尔值组成（如果最小特征值 $\\le \\varepsilon$，则使用 $True$，否则使用 $False$）。例如，输出格式必须如下所示\n$$\n\\big[ \\,[\\lambda_1,\\lambda_2,\\dots,\\lambda_p,\\text{flag}],\\; \\dots \\,\\big],\n$$\n打印的字符串中没有空格。\n\n不涉及物理单位或角度单位。所有数值必须表示为浮点数，所有逻辑决策必须表示为布尔值。您的程序产生的最后一行应是如上所述的列表，打印为单行，条目以逗号分隔并用方括号括起。", "solution": "该问题要求分析一个离散一维扩散算子的对称正定性，该算子是在间断 Galerkin (DG) 框架内，使用勒让德多项式的谱基构造的。积分是使用闭合 Newton-Cotes 求积法则进行数值计算的。对于指定的多项式阶数 $p$ 和求积点数 $N$，我们需要构造离散 Gram 矩阵 $G$，计算其特征值，并确定是否丧失了正定性。正定性的丧失定义为最小特征值小于或等于容差 $\\varepsilon = 10^{-10}$。\n\n该过程涉及几个不同的数学和计算步骤，详述如下。\n\n首先，我们定义计算环境。分析在参考单元，即区间 $\\left[-1, 1\\right]$ 上进行。DG 空间的多项式基选择为 $\\{P_n(x)\\}_{n=1}^p$，其中 $P_n(x)$ 是 $n$ 次勒让德多项式。排除常数模 $P_0(x)$ 以消除扩散算子的平凡零模。\n\n问题的核心在于构造和分析离散 Gram 矩阵 $G$，其元素由双线性形式 $a(u,v) = \\int_{-1}^{1} (\\partial_x u)(\\partial_x v) \\mathrm{d}x$（其中 $u=P_i(x)$ 和 $v=P_j(x)$）的数值求积给出。离散矩阵 $G \\in \\mathbb{R}^{p\\times p}$ 定义为：\n$$\nG_{ij} = \\sum_{k=0}^{N-1} w_k P_i'(x_k) P_j'(x_k).\n$$\n\n对于每个测试用例 $(p, N)$，总体算法如下：\n\n1.  **构造闭合 Newton-Cotes 求积法则**\n\n    在区间 $\\left[-1, 1\\right]$ 上具有 $N$ 个点的闭合 Newton-Cotes 求积法则由一组 $N$ 个等距节点 $\\{x_k\\}_{k=0}^{N-1}$ 和相应的权重 $\\{w_k\\}_{k=0}^{N-1}$ 定义。\n\n    节点由以下公式给出：\n    $$\n    x_k = -1 + \\frac{2k}{N-1}, \\quad \\text{for } k=0, 1, \\dots, N-1.\n    $$\n    权重是通过强制要求积法则能精确积分最高 $N-1$ 次的多项式来确定的。这会导出一个关于 $N$ 个权重的 $N$ 个线性方程组：\n    $$\n    \\sum_{k=0}^{N-1} w_k x_k^m = \\int_{-1}^{1} x^m \\mathrm{d}x, \\quad \\text{for } m=0, 1, \\dots, N-1.\n    $$\n    右侧的积分计算结果为：\n    $$\n    \\int_{-1}^{1} x^m \\mathrm{d}x = \\frac{1 - (-1)^{m+1}}{m+1} = \\begin{cases} \\frac{2}{m+1}  \\text{if } m \\text{ is even} \\\\ 0  \\text{if } m \\text{ is odd} \\end{cases}.\n    $$\n    该线性系统可以写成矩阵形式 $V \\mathbf{w} = \\mathbf{b}$，其中 $V$ 是一个范德蒙德矩阵，其元素为 $V_{mk} = x_k^m$，$\\mathbf{w}$ 是权重列向量 $[w_0, \\dots, w_{N-1}]^\\top$，而 $\\mathbf{b}$ 是单项式积分的列向量。求解该系统可得到所需的权重。当 $N \\ge 9$（以及其他一些值，如 $N=8$），其中一些权重会变为负数，这可能损害所得到的离散算子的正定性。\n\n2.  **计算勒让德多项式的导数**\n\n    基函数是勒让德多项式 $\\{P_n(x)\\}_{n=1}^p$。我们需要它们的一阶导数 $\\{P_n'(x)\\}_{n=1}^p$。这些导数本身也是多项式。对于每个基函数 $P_n'(x)$，我们必须在所有求积节点 $\\{x_k\\}$ 处对其进行求值。这将得到一组值 $P_n'(x_k)$，其中 $n \\in \\{1, \\dots, p\\}$ 和 $k \\in \\{0, \\dots, N-1\\}$。这些求值可以组织成一个矩阵 $D_{\\text{eval}} \\in \\mathbb{R}^{p \\times N}$，其中 $(D_{\\text{eval}})_{nk} = P_{n+1}'(x_k)$（行使用从 0 开始的索引）。\n\n3.  **组装离散 Gram 矩阵 $G$**\n\n    Gram 矩阵 $G$ 由以下和定义：\n    $$\n    G = \\sum_{k=0}^{N-1} w_k D(x_k) D(x_k)^\\top,\n    $$\n    其中 $D(x_k)$ 是在节点 $x_k$ 处求值的基函数导数列向量：\n    $$\n    D(x_k) = \\begin{bmatrix} P_1'(x_k) \\\\ P_2'(x_k) \\\\ \\vdots \\\\ P_p'(x_k) \\end{bmatrix}.\n    $$\n    使用上一步的求值矩阵 $D_{\\text{eval}}$ 和一个对角矩阵 $W = \\text{diag}(w_0, \\dots, w_{N-1})$，可以高效地计算矩阵 $G$：\n    $$\n    G = D_{\\text{eval}} W D_{\\text{eval}}^\\top.\n    $$\n    从这个构造中，我们可以推断出秩亏的潜在来源。$G$ 的秩至多为 $W$ 的秩（如果所有权重都非零，则为 $N$），且至多为 $D_{\\text{eval}}$ 的秩（至多为 $\\min(p, N)$）。如果 $N  p$，$G$ 的秩至多为 $N$，这意味着 $G$ 将是一个秩小于 $p$ 的 $p \\times p$ 矩阵。因此，它将至少有 $p-N$ 个零特征值，导致正定性的丧失。这种情况被称为欠积分。\n\n4.  **分析对称正定性**\n\n    理论上，这样构造的矩阵 $G$ 是对称的。然而，由于浮点运算，可能会出现微小的不对称性。为确保对称矩阵的有效特征值分解，我们首先显式地对 $G$ 进行对称化：\n    $$\n    G_{\\text{sym}} = \\frac{1}{2} (G + G^\\top).\n    $$\n    接下来，我们计算 $G_{\\text{sym}}$ 的特征值。由于 $G_{\\text{sym}}$ 是一个实对称矩阵，其所有特征值都是实数。我们将这些特征值按升序排序：$\\lambda_1 \\le \\lambda_2 \\le \\dots \\le \\lambda_p$。\n\n    一个矩阵是对称正定的，当且仅当其所有特征值都严格为正。该问题将对称正定性的丧失定义为最小特征值 $\\lambda_1$ 为非正数的条件。我们使用给定的容差 $\\varepsilon = 10^{-10}$ 检查此条件：\n    $$\n    \\text{Loss of SPD} \\iff \\lambda_1 \\le \\varepsilon.\n    $$\n    根据此结果设置一个布尔标志（$True$ 表示丧失，$False$ 表示保持）。每种情况的最终结果包括排序后的特征值列表和这个布尔标志。\n\n将此过程应用于每个指定的测试用例，并将结果汇总成最终的输出格式。所选的测试用例旨在突出不同的数值现象：稳定积分 ($p=3, N=5$)、由欠积分引起的秩亏 ($p=5, N=4$)，以及由负求积权重引起的不定性 ($p=9, N=11$ 和 $p=8, N=9$)。情况 $p=1, N=2$ 作为对应于梯形法则的简单、稳定的基准。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases, analyzing the symmetric positive\n    definiteness of a DG diffusion operator matrix.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3, 5),   # Case 1\n        (5, 4),   # Case 2\n        (9, 11),  # Case 3\n        (1, 2),   # Case 4\n        (8, 9),   # Case 5\n    ]\n    \n    epsilon = 1e-10\n    all_results = []\n\n    for p, N in test_cases:\n        # Step 1: Construct the Closed Newton-Cotes Quadrature Rule\n        # Generate N equispaced nodes on [-1, 1]\n        nodes = np.linspace(-1.0, 1.0, N)\n\n        # Determine weights by solving the linear system for polynomial exactness\n        # The system is V @ w = b, where V_ij = x_j^i\n        V = np.vander(nodes, N, increasing=True).T\n        \n        # Right-hand side: integrals of x^m from -1 to 1\n        b = np.zeros(N)\n        for m in range(N):\n            if (m + 1) % 2 != 0:\n                b[m] = 2.0 / (m + 1)\n        \n        weights = np.linalg.solve(V, b)\n\n        # Step 2: Evaluate Derivatives of Legendre Polynomials\n        # D_eval is a p x N matrix where D_eval[i, j] = P_{i+1}'(nodes[j])\n        D_eval = np.zeros((p, N))\n        for n_poly in range(1, p + 1):\n            P_n = legendre(n_poly)\n            P_n_prime = P_n.deriv()\n            D_eval[n_poly - 1, :] = P_n_prime(nodes)\n\n        # Step 3: Assemble the Discrete Gram Matrix G\n        # G = D_eval @ diag(weights) @ D_eval.T\n        G = D_eval @ np.diag(weights) @ D_eval.T\n        \n        # Step 4: Analyze Symmetric Positive Definiteness\n        # Symmetrize the matrix to correct for potential floating point inaccuracies\n        G_sym = 0.5 * (G + G.T)\n        \n        # Compute eigenvalues. eigvalsh returns them sorted in ascending order.\n        eigenvalues = np.linalg.eigvalsh(G_sym)\n        \n        # Check if the smallest eigenvalue is non-positive within the tolerance\n        is_lost = eigenvalues[0] = epsilon\n        \n        # Format the result for this test case\n        result_case = eigenvalues.tolist() + [is_lost]\n        all_results.append(result_case)\n\n    # Final print statement in the exact required format.\n    results_str_list = []\n    for res in all_results:\n        # The last element is a boolean, the rest are floats.\n        # str() on a boolean gives 'True' or 'False' with a capital letter, as required.\n        str_vals = [f\"{v}\" for v in res]\n        results_str_list.append(f\"[{','.join(str_vals)}]\")\n    \n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```", "id": "3401958"}]}