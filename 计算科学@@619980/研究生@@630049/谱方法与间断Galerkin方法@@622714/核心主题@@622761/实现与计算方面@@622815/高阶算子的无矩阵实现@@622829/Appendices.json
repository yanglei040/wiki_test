{"hands_on_practices": [{"introduction": "开发高效数值软件的第一步是确保其正确性。本练习[@problem_id:3398909]将概念上简单但内存密集的全稀疏矩阵方法与计算上高效但更抽象的无矩阵方法进行对比。通过验证两种方法产生相同的结果，学生可以建立对无矩阵实现的信心，并对底层的间断Galerkin（DG）算子有更深入的理解。", "problem": "考虑在周期性域上具有恒定速度的一维线性平流方程。设物理域为区间 $[0,1]$，被划分为 $E$ 个等长 $h = 1/E$ 的仿射单元。每个单元 $e$ 通过一个雅可比行列式为 $J_e = h/2$ 的仿射映射从参考区间 $[-1,1]$ 映射而来。在每个单元上，使用勒让德-高斯-洛巴托（LGL）节点 $\\{\\xi_j\\}_{j=0}^N$ 及其相关的 LGL 求积权重 $\\{w_j\\}_{j=0}^N$ 的节点表示，将解近似为 $N$ 次多项式。将拉格朗日插值基函数表示为 $\\{\\phi_j(\\xi)\\}_{j=0}^N$，使得 $\\phi_j(\\xi_k) = \\delta_{jk}$，并通过恒等式 $d u/d \\xi \\big|_{\\xi = \\xi_j} = \\sum_{k=0}^N D_{jk} u(\\xi_k)$ 在参考区间上定义微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，此恒等式适用于任何次数至多为 $N$ 的多项式。\n\n对于恒定的平流速度 $a > 0$，单元 $e$ 上采用迎风数值通量的半离散间断伽辽金弱形式规定，对于每个检验函数索引 $j \\in \\{0,\\dots,N\\}$，\n$$\n\\int_{x_{e-1/2}}^{x_{e+1/2}} \\phi_j(x) \\frac{\\partial u}{\\partial t}(x,t) \\, dx\n= -a \\int_{x_{e-1/2}}^{x_{e+1/2}} \\phi_j'(x) u(x,t) \\, dx\n+ a \\, \\phi_j(x_{e+1/2}) \\, \\hat{u}_{e+1/2} - a \\, \\phi_j(x_{e-1/2}) \\, \\hat{u}_{e-1/2},\n$$\n其中 $x_{e\\pm 1/2}$ 是物理单元边界，撇号表示对 $x$ 的导数，$\\hat{u}_{e\\pm 1/2}$ 是 $u$ 在右/左单元界面处的迎风数值迹。在周期性网格上且对于 $a>0$，迎风数值迹在每个界面处取左状态，即 $\\hat{u}_{e+1/2} = u_{N}^e$ 和 $\\hat{u}_{e-1/2} = u_{N}^{e-1}$，其中 $u_j^e$ 表示单元 $e$ 上节点索引 $j$ 处的值，$e-1$ 是 $e$ 的左邻居（带周期性环绕）。\n\n使用以下经过充分检验的基本事实：\n- LGL 节点是端点 $\\xi_0 = -1$, $\\xi_N = 1$ 以及 $N$ 次勒让德多项式 $P_N(\\xi)$ 的导数在 $(-1,1)$ 内的 $N-1$ 个根。\n- LGL求积权重满足 $w_j = \\dfrac{2}{N(N+1)} \\dfrac{1}{[P_N(\\xi_j)]^2}$，对于 $j = 0,\\dots,N$。\n- 由于与 LGL 求积的配置，节点 LGL 基中单元 $e$ 上的质量矩阵是对角的，其对角项为 $M_{jj}^e = J_e w_j$。\n- 对于不同节点 $\\xi_j \\neq \\xi_k$ 的拉格朗日基的微分矩阵项由重心微分恒等式给出 $D_{jk} = \\dfrac{\\omega_k}{\\omega_j}\\dfrac{1}{\\xi_j - \\xi_k}$，对角项为 $D_{jj} = -\\sum_{k\\ne j} D_{jk}$，其中 $\\omega_j$ 是重心权重 $\\omega_j = \\left(\\prod_{k\\ne j}(\\xi_j - \\xi_k)\\right)^{-1}$。\n\n任务：从这些基本定义和事实出发，设计并实现一个程序，用于在指定的 $(E,N,a)$下，比较无矩阵间断伽辽金算子的作用与全局组装稀疏矩阵算子的作用。这两个算子都表示从节点自由度到由弱形式导出的右端向量的相同半离散映射。您的比较应通过计算随机测试向量的差异范数来执行。\n\n您的程序必须：\n1. 为给定的多项式次数 $N$ 构造 LGL 节点和权重。\n2. 使用 LGL 节点上的重心权重构造微分矩阵 $D$。\n3. 定义一个无矩阵算子应用，它不组装全局矩阵，仅使用单元局部操作、质量矩阵对角线、微分矩阵和带周期性边界条件的迎风数值通量，来计算每个节点自由度处的半离散右端项。\n4. 组装全局稀疏矩阵，该矩阵表示整个周期性网格上（包含 $E$ 个单元）的相同半离散算子映射，其顺序是通过连接每个单元的 $(N+1)$ 个节点来确定的。\n5. 对于指定数量的随机测试向量（使用固定的种子以保证可复现性），计算每个向量的无矩阵结果与组装稀疏矩阵-向量乘积结果之间差异的相对 $2$-范数。对于每个测试用例，返回这些相对范数中的最大值。\n\n使用以下测试套件（每个元组列出 $(E,N,a,\\text{seed},R)$，其中 $R$ 是测试的随机向量数量）：\n- $(1,1,1.0,42,3)$：单个单元，最低阶情况，三个随机向量。\n- $(4,3,1.0,7,5)$：中等数量的单元和阶数，五个随机向量。\n- $(8,7,0.5,123,4)$：较高多项式阶数，四个随机向量。\n- $(10,2,0.0,9,2)$：零平流速度边界情况，两个随机向量。\n- $(3,5,2.0,100,4)$：较少单元但较高速度，四个随机向量。\n\n角度单位不适用，因为没有使用角度。无需报告物理单位，因为输出纯粹是数学的。对于每个测试用例，计算一个浮点数，该数等于其 $R$ 个随机向量中差异的相对 $2$-范数最大值。\n\n最终输出格式：您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5]”），每个结果按上述顺序对应于列出的测试用例。", "solution": "该问题要求设计、实现并验证两种计算方法，以应用一维线性平流方程的间断伽辽金（DG）离散化的空间算子。这两种方法分别是无矩阵方法和基于组装的全局稀疏矩阵的方法。验证过程包括比较它们在随机向量上的输出，并计算最大相对差异。\n\n### 数学公式\n该问题考虑线性平流方程 $\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0$，定义在周期性域 $[0,1]$ 上，平流速度为 $a > 0$。该域被划分为 $E$ 个单元，在每个单元上，解被近似为一个 $N$ 次多项式。对于检验函数 $\\phi_j$，单元 $e$ 上的半离散弱形式由下式给出：\n$$\n\\int_{x_e} \\phi_j \\frac{\\partial u}{\\partial t} \\, dx = -a \\int_{x_e} \\phi_j' u \\, dx + a \\, \\phi_j(x_{e+1/2}) \\, \\hat{u}_{e+1/2} - a \\, \\phi_j(x_{e-1/2}) \\, \\hat{u}_{e-1/2}\n$$\n左侧对应于作用在解系数时间导数上的质量矩阵。任务是计算所有自由度（DOF）的右端项（RHS）向量。设 $u^e = [u_0^e, \\dots, u_N^e]^T$ 为单元 $e$ 上的节点自由度向量。全局自由度向量 $U$ 是所有 $u^e$ 的串联。要实现的算子将 $U$ 映射到全局 RHS 向量 $F(U)$。让我们分析单个单元 $e$ 上对 RHS 的贡献。\n\n#### 体积分项\n第一项是体积分，我们将其表示为 $F_{\\text{vol}, j}^e$：\n$$\nF_{\\text{vol}, j}^e = -a \\int_{x_e} \\phi_j'(x) u(x) \\, dx\n$$\n在单元 $e$ 上，解为 $u(x) = \\sum_{k=0}^N u_k^e \\phi_k(x)$。将其代入积分得：\n$$\nF_{\\text{vol}, j}^e = -a \\sum_{k=0}^N u_k^e \\int_{x_e} \\phi_j'(x) \\phi_k(x) \\, dx\n$$\n积分 $\\int_{x_e} \\phi_j'(x) \\phi_k(x) \\, dx$ 定义了单元刚度矩阵的项。使用雅可比行列式为 $J_e = h/2$（其中 $h=1/E$）的仿射映射 $x(\\xi)$ 变换到参考单元 $[-1,1]$：$\\phi_j'(x) = \\frac{d\\phi_j}{d\\xi}\\frac{d\\xi}{dx} = \\frac{1}{J_e}\\frac{d\\phi_j}{d\\xi}$ 且 $dx = J_e d\\xi$。积分变为：\n$$\nS^{\\text{ref}}_{jk} = \\int_{-1}^1 \\left(\\frac{1}{J_e}\\frac{d\\phi_j}{d\\xi}\\right) \\phi_k(\\xi) J_e d\\xi = \\int_{-1}^1 \\frac{d\\phi_j}{d\\xi}(\\xi) \\phi_k(\\xi) d\\xi\n$$\n这个参考刚度矩阵与单元无关。我们使用 $N+1$ 点 LGL 求积法则来近似这个积分，该法则对于最高为 $2N-1$ 次的多项式是精确的。被积函数的次数最高为 $2N-1$，因此求积通常不是精确的，但这是标准的 DG 方法。\n利用性质 $\\frac{d\\phi_j}{d\\xi}(\\xi) = \\sum_{l=0}^N \\frac{d\\phi_j}{d\\xi}(\\xi_l) \\phi_l(\\xi) = \\sum_{l=0}^N D_{lj} \\phi_l(\\xi)$：\n$$\nS^{\\text{ref}}_{jk} \\approx \\sum_{m=0}^N w_m \\left(\\sum_{l=0}^N D_{lj} \\phi_l(\\xi_m)\\right) \\phi_k(\\xi_m) = \\sum_{m=0}^N w_m \\left(\\sum_{l=0}^N D_{lj} \\delta_{lm}\\right) \\delta_{mk} = w_k D_{kj}\n$$\n在矩阵表示法中，$S^{\\text{ref}} = D^T \\text{diag}(w)$。单元 $e$ 上对 RHS 向量的体积分贡献为 $F_{\\text{vol}}^e = -a S^{\\text{ref}} u^e$。\n\n#### 面积（通量）积分项\nRHS 的第二部分涉及单元边界 $x_{e \\pm 1/2}$ 处的数值通量：\n$$\nF_{\\text{flux}, j}^e = a \\, \\phi_j(x_{e+1/2}) \\, \\hat{u}_{e+1/2} - a \\, \\phi_j(x_{e-1/2}) \\, \\hat{u}_{e-1/2}\n$$\n拉格朗日基函数 $\\phi_j$ 定义在 LGL 节点 $\\{\\xi_k\\}_{k=0}^N$ 上，其中 $\\xi_0=-1$ 和 $\\xi_N=1$。它们分别映射到单元边界 $x_{e-1/2}$ 和 $x_{e+1/2}$。由于性质 $\\phi_j(\\xi_k)=\\delta_{jk}$，我们有 $\\phi_j(x_{e-1/2})=\\delta_{j0}$ 和 $\\phi_j(x_{e+1/2})=\\delta_{jN}$。这意味着通量项仅在单元的第一个和最后一个节点（$j=0$ 和 $j=N$）处非零。\n对于 $a>0$，迎风通量在界面处取“左”状态的值。\n- 在右边界 $x_{e+1/2}$：$\\hat{u}_{e+1/2} = u(x_{e+1/2}^-)$，即当前单元 $e$ 上节点 $N$ 的值，因此 $\\hat{u}_{e+1/2} = u_N^e$。\n- 在左边界 $x_{e-1/2}$：$\\hat{u}_{e-1/2} = u(x_{e-1/2}^-)$，即左侧相邻单元 $e-1$ 上节点 $N$ 的值。由于周期性，如果 $e=0$，则 $e-1$ 对应于单元 $E-1$。因此，$\\hat{u}_{e-1/2} = u_N^{e-1}$。\n通量贡献为：\n- 对于节点 $j=0$：$-a \\cdot 1 \\cdot \\hat{u}_{e-1/2} = -a u_N^{e-1}$。\n- 对于节点 $j=N$：$a \\cdot 1 \\cdot \\hat{u}_{e+1/2} = a u_N^e$。\n\n### 算法实现策略\n\n#### 基本构件\n实现始于为给定的多项式次数 $N$ 构建必要的基本构件：\n1.  **LGL 节点和权重**：节点 $\\{\\xi_j\\}$ 是 $\\{-1, 1\\}$ 与勒让德多项式 $P_N(\\xi)$ 导数的根的并集，这等价于雅可比多项式 $P_{N-1}^{(1,1)}(\\xi)$ 的根。权重 $\\{w_j\\}$ 通过提供的公式计算。\n2.  **微分矩阵**：参考微分矩阵 $D$ 使用给定的重心公式 $D_{jk} = \\frac{\\omega_k}{\\omega_j}\\frac{1}{\\xi_j - \\xi_k}$ 和 $D_{jj} = -\\sum_{k\\ne j} D_{jk}$ 构建。重心权重 $\\omega_j = (\\prod_{k\\ne j}(\\xi_j - \\xi_k))^{-1}$ 使用对数进行仔细计算以保持数值稳定性。\n\n#### 无矩阵算子\n此算子直接计算作用 $F(U)$ 而不形成全局矩阵。它遍历 $E$ 个单元中的每一个：\n1.  对于每个单元 $e$，从全局向量 $U$ 中提取局部自由度向量 $u^e$。\n2.  计算体积分项：$F_{\\text{vol}}^e = -a (D^T \\text{diag}(w)) u^e$。\n3.  识别迎风邻居的自由度，$u_N^{e-1}$。\n4.  添加通量贡献：从 $F_{\\text{vol}}^e$ 的第一个分量中减去 $a u_N^{e-1}$，并向最后一个分量中加上 $a u_N^e$。\n5.  得到的向量是单元 $e$ 对 RHS 的贡献，存储在全局 RHS 向量 $F(U)$ 的相应段中。\n\n#### 组装矩阵算子\n该方法显式构建全局 $E(N+1) \\times E(N+1)$ 稀疏矩阵 $L$，使得 $F(U) = L U$。\n1.  初始化一个稀疏矩阵（例如，使用 LIL 格式以便高效构建）。\n2.  遍历每个单元 $e$：\n    a.  **体积分部分**：局部算子 $-a S^{\\text{ref}} = -a D^T \\text{diag}(w)$ 是一个稠密的 $(N+1) \\times (N+1)$ 块。此块被加到 $L$ 中对应于单元 $e$ 的对角块上。\n    b.  **通量部分**：通量项在相邻单元之间创建耦合。对于每个单元 $e$：\n        i.  项 $a u_N^e$ 加到 $L$ 中对应于单元 $e$ 上节点 $N$ 的全局索引的行和列的元素上。\n        ii. 项 $-a u_N^{e-1}$ 加到 $L$ 中对应于单元 $e$ 上节点 $0$ 的行和单元 $e-1$ 上节点 $N$ 的列的元素上。\n3.  将矩阵转换为高效进行矩阵-向量乘法的格式（例如，CSR）。\n\n#### 验证\n对于每个测试用例，生成 $R$ 个随机向量 $U_i$。使用两种方法计算算子作用，得到 $y_{\\text{free},i}$ 和 $y_{\\text{mat},i} = L U_i$。计算差异的相对 2-范数 $\\frac{\\|y_{\\text{free},i} - y_{\\text{mat},i}\\|_2}{\\|y_{\\text{mat},i}\\|_2}$。报告这 $R$ 个向量中这些范数的最大值。对于 $a=0$ 的特殊情况，两种方法都产生零向量，因此差异为零，相对误差取为 $0$。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi, eval_legendre\nfrom scipy.sparse import lil_matrix\n\ndef get_lgl_nodes_weights(N):\n    \"\"\"\n    Computes the Legendre-Gauss-Lobatto (LGL) nodes and weights for a given\n    polynomial degree N.\n    \"\"\"\n    if N == 0:\n        return np.array([-1.0]), np.array([2.0])\n    if N == 1:\n        nodes = np.array([-1.0, 1.0])\n        weights = np.array([1.0, 1.0])\n        return nodes, weights\n\n    # Interior nodes are roots of P_N'(x), which are roots of Jacobi P_{N-1}^{(1,1)}(x)\n    interior_nodes, _ = roots_jacobi(N - 1, 1, 1)\n    nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n\n    # Weights from the formula w_j = 2 / (N(N+1) [P_N(xi_j)]^2)\n    poly_vals = eval_legendre(N, nodes)\n    weights = 2.0 / (N * (N + 1) * poly_vals**2)\n    \n    return nodes, weights\n\ndef get_derivative_matrix(N, nodes):\n    \"\"\"\n    Computes the nodal derivative matrix D on the reference element using\n    the provided barycentric weight formula.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.0]])\n    \n    D = np.zeros((N + 1, N + 1))\n    omega = np.zeros(N + 1)\n\n    # Compute barycentric weights omega_j = (product_{k!=j} (xi_j - xi_k))^{-1}\n    # This is done using logarithms to avoid numerical overflow/underflow.\n    for j in range(N + 1):\n        log_abs_prod = np.sum(np.log(np.abs(nodes[j] - np.delete(nodes, j))))\n        # The sign of the product is (-1)^(N-j) for ordered nodes.\n        # The sign of omega_j is the same.\n        sign = (-1.0)**(N - j)\n        omega[j] = sign / np.exp(log_abs_prod)\n\n    # Off-diagonal entries: D_jk = (omega_k/omega_j) / (xi_j - xi_k)\n    for j in range(N + 1):\n        for k in range(N + 1):\n            if j != k:\n                D[j, k] = (omega[k] / omega[j]) / (nodes[j] - nodes[k])\n\n    # Diagonal entries: D_jj = -sum_{k!=j} D_jk\n    for j in range(N + 1):\n        D[j, j] = -np.sum(D[j, :])\n        \n    return D\n\ndef matrix_free_operator(U, E, N, a, D, w):\n    \"\"\"\n    Computes the action of the DG operator in a matrix-free fashion.\n    \"\"\"\n    dofs = E * (N + 1)\n    rhs = np.zeros(dofs)\n    \n    if np.isclose(a, 0.0):\n        return rhs\n\n    U_mat = U.reshape((E, N + 1))\n    \n    # Reference stiffness matrix S_ref = D^T @ diag(w)\n    # This is efficiently computed by scaling columns of D^T by w.\n    S_ref = D.T * w\n\n    for e in range(E):\n        u_e = U_mat[e, :]\n        \n        # Volume term contribution\n        vol_term = -a * (S_ref @ u_e)\n        \n        # Flux term contribution (upwind for a > 0)\n        e_prev = (e - 1 + E) % E\n        u_left_neighbor_val = U_mat[e_prev, N]  # u_N from element e-1\n        u_self_right_val = u_e[N]               # u_N from element e\n        \n        flux_term_at_0 = -a * u_left_neighbor_val\n        flux_term_at_N = a * u_self_right_val\n        \n        # Combine local contributions\n        rhs_e = vol_term\n        rhs_e[0] += flux_term_at_0\n        rhs_e[N] += flux_term_at_N\n        \n        # Place into global RHS vector\n        rhs[e * (N + 1):(e + 1) * (N + 1)] = rhs_e\n        \n    return rhs\n\ndef assemble_global_matrix(E, N, a, D, w):\n    \"\"\"\n    Assembles the global sparse matrix for the DG operator.\n    \"\"\"\n    dofs = E * (N + 1)\n    L_global = lil_matrix((dofs, dofs))\n\n    if np.isclose(a, 0.0):\n        return L_global.tocsr()\n\n    S_ref = D.T * w\n    local_op_block = -a * S_ref\n\n    for e in range(E):\n        start_idx = e * (N + 1)\n        end_idx = (e + 1) * (N + 1)\n        \n        # Add volume term (block diagonal part)\n        L_global[start_idx:end_idx, start_idx:end_idx] = local_op_block\n        \n        # Add flux terms (off-diagonal and diagonal-modifying part)\n        e_prev = (e - 1 + E) % E\n        \n        # Contribution from left neighbor to node j=0\n        row_idx_0 = start_idx\n        col_idx_neighbor = e_prev * (N + 1) + N\n        L_global[row_idx_0, col_idx_neighbor] += -a\n        \n        # Contribution from self to node j=N\n        row_idx_N = start_idx + N\n        col_idx_self = start_idx + N\n        L_global[row_idx_N, col_idx_self] += a\n        \n    return L_global.tocsr()\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compare operator implementations.\n    \"\"\"\n    test_cases = [\n        (1, 1, 1.0, 42, 3),\n        (4, 3, 1.0, 7, 5),\n        (8, 7, 0.5, 123, 4),\n        (10, 2, 0.0, 9, 2),\n        (3, 5, 2.0, 100, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        E, N, a, seed, R = case\n        \n        rel_diffs = []\n        \n        # Pre-compute DG basis components for the given degree N\n        nodes, weights = get_lgl_nodes_weights(N)\n        D = get_derivative_matrix(N, nodes)\n        \n        # Assemble the global sparse matrix for this test case\n        L_global = assemble_global_matrix(E, N, a, D, weights)\n        \n        # Use a reproducible random number generator for this case\n        rng = np.random.default_rng(seed)\n        \n        for _ in range(R):\n            U_rand = rng.random(E * (N + 1))\n            \n            y_free = matrix_free_operator(U_rand, E, N, a, D, weights)\n            y_mat = L_global @ U_rand\n            \n            diff_norm = np.linalg.norm(y_free - y_mat)\n            y_mat_norm = np.linalg.norm(y_mat)\n            \n            if y_mat_norm > 1e-15:\n                rel_diff = diff_norm / y_mat_norm\n            else:\n                # If true result is zero vector, relative error is 0 if difference is also zero.\n                rel_diff = 0.0 if diff_norm < 1e-15 else np.inf\n\n            rel_diffs.append(rel_diff)\n\n        results.append(max(rel_diffs))\n        \n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```", "id": "3398909"}, {"introduction": "拥有一个正确的算子后，我们可以将其应用于更具挑战性的问题，例如在移动网格上的模拟。本练习[@problem_id:3398913]探讨了自由流保持（free-stream preservation）这一关键概念，它确保数值格式不会因为网格运动而产生人为的力。学生将看到相同的离散算子结构如何能够优雅地应用于物理守恒律和几何守恒律（GCL），这突出了抽象化在数值方法中的力量。", "problem": "考虑在 Arbitrary Lagrangian-Eulerian (ALE) 框架下，带有网格运动的周期性域上的一维线性平流方程。其物理守恒律由 $\\,\\partial_t u + a\\,\\partial_x u = 0\\,$ 给出，其中平流速度 $\\,a \\in \\mathbb{R}\\,$ 为常数。在从参考坐标 $\\,\\xi \\in [-1,1]\\,$ 到物理坐标 $\\,x(\\xi,t)\\,$ 的随时间变化的映射下，其雅可比（Jacobian）为 $\\,J(\\xi,t) = \\partial x / \\partial \\xi\\,$，网格速度为 $\\,w(\\xi,t) = \\partial_t x(\\xi,t)\\,$，则参考空间中的ALE形式为如下守恒型方程\n$$\n\\partial_t \\big(J(\\xi,t)\\,u(\\xi,t)\\big) + \\partial_\\xi \\big( F(u,w) \\big) = 0,\n$$\n其中ALE通量为 $\\,F(u,w) = u\\,(a - w)\\,$。自由流保持（Free-stream preservation）要求，如果离散化和几何处理是一致的，那么一个精确的常数解 $\\,u(\\xi,t) \\equiv c\\,$ 必须在所有时间内保持为常数。特别地，几何守恒律（Geometric Conservation Law, GCL）指出\n$$\n\\partial_t J(\\xi,t) - \\partial_\\xi w(\\xi,t) = 0,\n$$\n为了实现自由流保持，该定律必须在离散意义上成立。\n\n您需要通过在一个无矩阵高阶 Discontinuous Galerkin Spectral Element Method (DGSEM) 中追踪一个精确常数解在算子流水线中的演化，来验证其自由流保持性质。使用具有 Summation-By-Parts (SBP) 性质的 Gauss-Lobatto-Legendre (GLL) 节点进行插值和求积，并在每个单元上采用强形式的DGSEM离散化。不要组装任何全局矩阵；实现必须直接应用单元算子（即在全局意义上是无矩阵的）。所有三角函数中的角度必须以弧度为单位。\n\n从守恒形式、参考映射和GCL等基本概念出发：\n- 守恒律：$\\,\\partial_t u + \\partial_x f(u) = 0\\,$，其中 $\\,f(u) = a u\\,$。\n- ALE守恒形式：$\\,\\partial_t(J u) + \\partial_\\xi \\big( u (a - w) \\big) = 0\\,$。\n- 几何守恒律：$\\,\\partial_t J - \\partial_\\xi w = 0\\,$。\n- GLL节点上的离散SBP性质和配置法。\n\n将参考域离散为 $\\,E \\in \\mathbb{N}\\,$ 个单元，每个单元都通过 $\\,s = e + (\\xi+1)/2\\,$（单元索引 $\\,e \\in \\{0,1,\\dots,E-1\\}\\,$）从 $\\,\\xi \\in [-1,1]\\,$ 等参映射到一个全局周期性参数坐标 $\\,s \\in [0,E]\\,$。通过全局映射 $\\,x(s,t) = s + \\gamma \\sin\\!\\big(2\\pi s / E\\big)\\,\\sin(\\Omega t)\\,$ 定义一个光滑的周期性网格运动，其振幅为 $\\,\\gamma \\in \\mathbb{R}\\,$，频率为 $\\,\\Omega \\in \\mathbb{R}\\,$。网格速度为 $\\,w(s,t) = \\partial_t x(s,t) = \\gamma\\,\\Omega \\cos(\\Omega t)\\,\\sin\\!\\big(2\\pi s / E\\big)\\,$。关于 $\\,\\xi\\,$ 的雅可比为 $\\,J(\\xi,t) = \\big(\\partial x / \\partial s\\big) \\big(\\partial s / \\partial \\xi\\big) = \\frac{1}{2}\\Big(1 + \\frac{2\\pi \\gamma}{E}\\cos\\!\\big(2\\pi s / E\\big)\\,\\sin(\\Omega t)\\Big)\\,$；通过为每个测试用例选择足够小的 $\\,\\gamma\\,$ 来确保 $\\,J(\\xi,t) > 0\\,$。\n\n实现以下内容：\n- 每个单元使用 $\\,N+1\\,$ 个GLL节点，多项式阶数为 $\\,N \\in \\mathbb{N}\\,$。设GLL节点为 $\\,\\{\\xi_j\\}_{j=0}^N\\,$，求积权重为 $\\,\\{w_j\\}_{j=0}^N\\,$，微分矩阵为 $\\,D \\in \\mathbb{R}^{(N+1)\\times(N+1)}\\,$，且满足GLL求积下的SBP性质。\n- 在每个单元上，为任意节点通量向量 $\\,\\boldsymbol{F} \\in \\mathbb{R}^{N+1}\\,$ 定义强形式DGSEM算子\n$$\n\\mathcal{L}(\\boldsymbol{F})_j = -\\sum_{k=0}^{N} D_{jk}\\,F_k \\;+\\; \\frac{1}{w_j}\\,\\Big( \\delta_{j,N}\\,\\big(F^\\ast_{R} - F_{N}^- \\big)\\;-\\;\\delta_{j,0}\\,\\big(F^\\ast_{L} - F_{0}^- \\big) \\Big),\n$$\n其中 $\\,F^\\ast_{L}\\,$ 和 $\\,F^\\ast_{R}\\,$ 分别是左右界面的数值通量，而 $\\,F_0^-\\,$ 和 $\\,F_N^-\\,$ 分别是左右节点的内部界面值。对于本次验证，对任意界面量 $\\,q\\,$ 使用一致的中心数值通量 $\\,q^\\ast = \\tfrac{1}{2}(q^- + q^+)\\,$，并采用相邻单元间的周期性耦合。对于ALE通量，使用 $\\,F = u\\,(a - w)\\,$；对于GCL通量，使用 $\\,G = -w\\,$，使得 $\\,\\partial_t J = \\mathcal{L}(\\boldsymbol{G})\\,$。\n- 对于常数状态 $\\,u \\equiv c\\,$，计算离散自由流残差向量\n$$\n\\boldsymbol{R} = c\\,\\partial_t \\boldsymbol{J} \\;-\\; \\mathcal{L}\\big(\\boldsymbol{F}(c,a,w)\\big),\n$$\n其中 $\\,\\partial_t \\boldsymbol{J}\\,$ 通过将相同的DGSEM算子应用于 $\\,\\boldsymbol{G} = -\\boldsymbol{w}\\,$ 来近似，而 $\\,\\boldsymbol{F}(c,a,w)\\,$ 使用 $\\,w\\,$ 的节点值。如果 $\\,\\|\\boldsymbol{R}\\|_\\infty\\,$ 小到舍入误差级别，则自由流在离散意义上是保持的。\n\n您的任务是编写一个完整、可运行的程序，该程序能够：\n- 为给定的 $\\,N\\,$ 构建GLL节点、权重和微分矩阵。\n- 在每个单元上实现带有周期性耦合的无矩阵DGSEM强形式算子。\n- 计算所有节点和单元界面上的全局网格速度 $\\,w(s,t)\\,$，角度以弧度为单位。\n- 对于下面测试套件中列出的每组参数，计算在所有单元和节点上 $\\,\\boldsymbol{R}\\,$ 的最大绝对值。\n\n测试套件与答案规格：\n- 在所有测试用例中使用频率 $\\,\\Omega = 1\\,$。\n- 参数元组为 $\\,\\big(E,N,a,\\gamma,t,c\\big)\\,$。使用以下五个用例：\n    - 用例 $\\,1$: $\\,E=3\\,$, $\\,N=5\\,$, $\\,a=1.0\\,$, $\\, \\gamma=0.15\\,$, $\\,t=0.37\\,$, $\\,c=2.0\\,$。\n    - 用例 $\\,2$: $\\,E=4\\,$, $\\,N=10\\,$, $\\,a=0.7\\,$, $\\,\\gamma=0.05\\,$, $\\,t=2.1\\,$, $\\,c=-1.0\\,$。\n    - 用例 $\\,3$: $\\,E=2\\,$, $\\,N=7\\,$, $\\,a=-0.5\\,$, $\\,\\gamma=0.0\\,$, $\\,t=1.23\\,$, $\\,c=1.0\\,$。\n    - 用例 $\\,4$: $\\,E=5\\,$, $\\,N=3\\,$, $\\,a=0.0\\,$, $\\,\\gamma=0.1\\,$, $\\,t=1.7\\,$, $\\,c=3.3\\,$。\n    - 用例 $\\,5$: $\\,E=1\\,$, $\\,N=1\\,$, $\\,a=1.0\\,$, $\\,\\gamma=0.02\\,$, $\\,t=3.14\\,$, $\\,c=1.0\\,$。\n- 对于每个用例，计算标量 $\\,r = \\|\\boldsymbol{R}\\|_\\infty\\,$，其结果为一个浮点数。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$）。\n\n通过保持 $\\,\\gamma\\,$ 足够小以确保在所有情况下 $\\,J(\\xi,t) > 0\\,$ 来保证科学真实性。输出中不需要物理单位。所有三角函数角度必须以弧度为单位。输出必须是确定性的，不依赖于任何用户输入。", "solution": "该问题要求在一个 Arbitrary Lagrangian-Eulerian (ALE) 框架下，对使用无矩阵高阶 Discontinuous Galerkin Spectral Element Method (DGSEM) 离散化的一维线性平流方程进行自由流保持性质的验证。自由流保持是数值格式的一项基本性质，它确保一个恒定的初始状态即使在移动或变形的网格上也能随时间保持恒定。未能保持自由流会引入虚假的源或汇，从而违反均匀流的基本物理原理。\n\n验证是通过为一个常数解 $u(\\xi,t) = c$ 计算离散残差来执行的。如果格式是一致的，该残差应在浮点精度范围内为零。该性质的核心在于，由物理守恒律和几何守恒律（GCL）产生的项能够在离散层面精确抵消。\n\n我们从平流的物理守恒律 $\\partial_t u + a\\,\\partial_x u = 0$ 开始。在随时间变化的映射 $x(\\xi,t)$ 下，将其转换到参考坐标系 $\\xi$ 中，得到守恒的ALE形式：\n$$\n\\partial_t \\big(J u\\big) + \\partial_\\xi \\big( u (a - w) \\big) = 0\n$$\n其中 $J = \\partial x / \\partial \\xi$ 是雅可比， $w = \\partial_t x$ 是网格速度。该方程可使用乘法法则展开：\n$$\nu\\,\\partial_t J + J\\,\\partial_t u + \\partial_\\xi \\big( u (a - w) \\big) = 0\n$$\n对于常数解 $u \\equiv c$，$J\\,\\partial_t u$ 项为零。方程简化为：\n$$\nc\\,\\partial_t J + \\partial_\\xi \\big( c (a - w) \\big) = 0\n$$\n自由流保持取决于几何守恒律（GCL），该定律源于偏导数的可交换性，即 $\\partial_t (\\partial_\\xi x) = \\partial_\\xi (\\partial_t x)$，从而得到：\n$$\n\\partial_t J - \\partial_\\xi w = 0 \\quad \\text{或} \\quad \\partial_t J = \\partial_\\xi w\n$$\n将 $\\partial_t J = \\partial_\\xi w$ 代入常数状态下的简化ALE方程，得到：\n$$\nc\\,(\\partial_\\xi w) + \\partial_\\xi \\big( c (a - w) \\big) = c\\,\\partial_\\xi w + c\\,\\partial_\\xi a - c\\,\\partial_\\xi w = 0\n$$\n这表明连续方程是一致的。问题的关键在于验证所选的DGSEM离散化方法是否能保持这种抵消特性。\n\nDGSEM离散化在 $E$ 个单元上执行，每个单元都从参考域 $\\xi \\in [-1,1]$ 映射而来。在每个单元内部，解和几何形状由 $N+1$ 个 Gauss-Lobatto-Legendre (GLL) 节点上的 $N$ 阶多项式表示。空间导数算子由强形式DGSEM算子 $\\mathcal{L}$ 近似，该算子结合了内部导数（使用一个 Summation-By-Parts 微分矩阵 $\\boldsymbol{D}$）和单元界面上的数值通量。对于节点通量向量 $\\boldsymbol{F}$，该算子为：\n$$\n\\mathcal{L}(\\boldsymbol{F})_j = -\\sum_{k=0}^{N} D_{jk}\\,F_k \\;+\\; \\frac{1}{w_j}\\,\\Big( \\delta_{j,N}\\,\\big(F^\\ast_{R} - F_{N}^- \\big)\\;-\\;\\delta_{j,0}\\,\\big(F^\\ast_{L} - F_{0}^- \\big) \\Big)\n$$\n该算子近似于 $-\\partial_\\xi \\boldsymbol{F}$。基于GLL的微分矩阵 $\\boldsymbol{D}$ 的一个关键性质是它能零化常数向量，即 $\\boldsymbol{D}\\boldsymbol{1} = \\boldsymbol{0}$。此外，对于全局常数通量，数值通量 $F^\\ast$ 等于内部通量 $F^-$，导致边界项消失。因此，$\\mathcal{L}(\\text{常数}) = \\boldsymbol{0}$。\n\n问题定义了一个一致的离散GCL。连续GCL $\\partial_t J = \\partial_\\xi w$ 被离散为：\n$$\n\\partial_t \\boldsymbol{J} = \\mathcal{L}(\\boldsymbol{G}) \\quad \\text{其中GCL通量为 } \\boldsymbol{G} = -\\boldsymbol{w}\n$$\n这是一致的，因为 $\\mathcal{L}(\\boldsymbol{G}) = \\mathcal{L}(-\\boldsymbol{w})$ 近似于 $-\\partial_\\xi(-\\boldsymbol{w}) = \\partial_\\xi \\boldsymbol{w}$。\n\n离散自由流残差向量 $\\boldsymbol{R}$ 被定义为 $c\\,\\partial_t J + \\partial_\\xi (c(a-w)) = 0$ 的离散版本。由于 $\\mathcal{L}$ 近似于 $-\\partial_\\xi$，相应的离散表达式为：\n$$\n\\boldsymbol{R} = c\\,\\partial_t \\boldsymbol{J} - \\mathcal{L}\\big(\\boldsymbol{F}(c,a,w)\\big)\n$$\n其中 $\\boldsymbol{F}(c,a,w)$ 是ALE通量 $u(a-w)$ 在 $u=c$ 时的节点向量。现在，我们将离散GCL和ALE通量代入残差表达式：\n$$\n\\boldsymbol{R} = c\\,\\mathcal{L}(-\\boldsymbol{w}) - \\mathcal{L}\\big(c(a - \\boldsymbol{w})\\big)\n$$\n算子 $\\mathcal{L}$ 对其通量参数是线性的。因此：\n$$\n\\mathcal{L}\\big(c(a - \\boldsymbol{w})\\big) = \\mathcal{L}(ca - c\\boldsymbol{w}) = \\mathcal{L}(ca) - \\mathcal{L}(c\\boldsymbol{w})\n$$\n由于 $ca$ 是一个常数，$\\mathcal{L}(ca) = \\boldsymbol{0}$。因此，$\\mathcal{L}\\big(c(a - \\boldsymbol{w})\\big) = -\\mathcal{L}(c\\boldsymbol{w})$。\n残差变为：\n$$\n\\boldsymbol{R} = c\\,\\mathcal{L}(-\\boldsymbol{w}) - \\big( -\\mathcal{L}(c\\boldsymbol{w}) \\big) = -c\\,\\mathcal{L}(\\boldsymbol{w}) + c\\,\\mathcal{L}(\\boldsymbol{w}) = \\boldsymbol{0}\n$$\n对于离散算子，这种代数抵消是精确成立的。因此，数值实现应产生一个量级为机器浮点精度的残差范数 $\\|\\boldsymbol{R}\\|_\\infty$。\n\n实现计划如下：\n1.  对于给定的多项式阶数 $N$，生成 $N+1$ 个GLL节点 $\\xi_j$、求积权重 $w_j$ 和 $(N+1) \\times (N+1)$ 的SBP微分矩阵 $\\boldsymbol{D}$。这些节点是 Legendre 多项式 $P_N(x)$ 在 $[-1,1]$ 上的极值点，权重和微分矩阵通过标准公式计算。\n2.  对于每个测试用例，定义包含 $E$ 个单元的网格。计算每个单元 $e$ 上每个节点 $j$ 的全局参数坐标 $s_{ej} = e + (\\xi_j+1)/2$。\n3.  使用给定公式 $w(s,t) = \\gamma\\,\\Omega \\cos(\\Omega t)\\,\\sin(2\\pi s / E)$，计算所有单元的节点网格速度向量 $\\boldsymbol{w}$。\n4.  实现无矩阵算子 $\\mathcal{L}$。该函数接收一个全局通量向量（一个 $E \\times (N+1)$ 的数组）并返回算子作用的结果。它通过在每个单元上进行矩阵-向量乘积来计算体积项，并使用中心通量和周期性边界条件添加表面修正项。\n5.  计算雅可比的离散时间导数，$\\partial_t \\boldsymbol{J} = \\mathcal{L}(-\\boldsymbol{w})$。\n6.  计算ALE通量的离散散度，$\\mathcal{L}(\\boldsymbol{F}) = \\mathcal{L}(c(a - \\boldsymbol{w}))$。\n7.  将这些组合起来形成残差向量 $\\boldsymbol{R} = c\\,\\partial_t \\boldsymbol{J} - \\mathcal{L}(\\boldsymbol{F})$。\n8.  最后，为每个测试用例计算全局残差向量的无穷范数 $\\|\\boldsymbol{R}\\|_\\infty$。", "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre, roots_jacobi\n\ndef get_gll_data(N):\n    \"\"\"\n    Computes Gauss-Lobatto-Legendre (GLL) nodes, weights, and derivative matrix.\n\n    Args:\n        N (int): Polynomial degree.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray, np.ndarray]:\n            - xi: GLL nodes of size (N+1).\n            - w: GLL quadrature weights of size (N+1).\n            - D: GLL derivative matrix of size (N+1, N+1).\n    \"\"\"\n    if not isinstance(N, int) or N < 1:\n        raise ValueError(\"Polynomial degree N must be an integer >= 1.\")\n\n    if N == 1:\n        xi = np.array([-1.0, 1.0])\n        w = np.array([1.0, 1.0])\n        D = np.array([[-0.5, 0.5], [-0.5, 0.5]])\n        return xi, w, D\n\n    # GLL nodes are roots of (1-x^2) * P_N'(x).\n    # The inner nodes are roots of P_N'(x), which are roots of the\n    # Jacobi polynomial P_{N-1}^{(1,1)}(x).\n    inner_nodes, _ = roots_jacobi(N - 1, 1, 1)\n    xi = np.concatenate(([-1.0], inner_nodes, [1.0]))\n\n    # Quadrature weights: w_j = 2 / (N(N+1) * P_N(xi_j)^2)\n    p_N_at_xi = eval_legendre(N, xi)\n    w = 2.0 / (N * (N + 1) * p_N_at_xi**2)\n\n    # Derivative matrix D\n    D = np.zeros((N + 1, N + 1))\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = (p_N_at_xi[i] / p_N_at_xi[j]) / (xi[i] - xi[j])\n            elif i == 0:\n                D[i, i] = -N * (N + 1) / 4.0\n            elif i == N:\n                D[i, i] = N * (N + 1) / 4.0\n            else:  # diagonal, 0 < i < N\n                D[i, i] = 0.0\n    return xi, w, D\n\ndef apply_L_operator(flux_global, E, N, D, w_gll):\n    \"\"\"\n    Applies the strong-form DGSEM operator L to a global flux vector.\n\n    Args:\n        flux_global (np.ndarray): Nodal flux values, shape (E, N+1).\n        E (int): Number of elements.\n        N (int): Polynomial degree.\n        D (np.ndarray): Derivative matrix, shape (N+1, N+1).\n        w_gll (np.ndarray): GLL weights, shape (N+1).\n\n    Returns:\n        np.ndarray: Result of operator application, shape (E, N+1).\n    \"\"\"\n    result_global = np.zeros_like(flux_global)\n\n    # Volume integral term: -D * F_e for each element e\n    # This is equivalent to `result_global = -flux_global @ D.T`\n    result_global = -np.einsum('ij,kj->ki', D, flux_global)\n\n    # Surface integral term (boundary corrections)\n    if N > 0:\n        inv_w0 = 1.0 / w_gll[0]\n        inv_wN = 1.0 / w_gll[N]\n\n        for e in range(E):\n            # Left face (at node 0)\n            e_left = (e - 1 + E) % E\n            F_minus_L = flux_global[e, 0]\n            F_plus_L = flux_global[e_left, N]  # from right face of left neighbor\n            F_star_L = 0.5 * (F_minus_L + F_plus_L)\n            result_global[e, 0] += -inv_w0 * (F_star_L - F_minus_L)\n\n            # Right face (at node N)\n            e_right = (e + 1) % E\n            F_minus_R = flux_global[e, N]\n            F_plus_R = flux_global[e_right, 0] # from left face of right neighbor\n            F_star_R = 0.5 * (F_minus_R + F_plus_R)\n            result_global[e, N] += inv_wN * (F_star_R - F_minus_R)\n\n    return result_global\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute free-stream residuals.\n    \"\"\"\n    # Test cases: (E, N, a, gamma, t, c)\n    test_cases = [\n        (3, 5, 1.0, 0.15, 0.37, 2.0),\n        (4, 10, 0.7, 0.05, 2.1, -1.0),\n        (2, 7, -0.5, 0.0, 1.23, 1.0),\n        (5, 3, 0.0, 0.1, 1.7, 3.3),\n        (1, 1, 1.0, 0.02, 3.14, 1.0),\n    ]\n\n    results = []\n    Omega = 1.0\n\n    for case in test_cases:\n        E, N, a, gamma, t, c = case\n\n        # 1. Get GLL data (nodes, weights, derivative matrix)\n        xi_nodes, w_gll, D = get_gll_data(N)\n\n        # 2. Set up geometry and compute mesh velocity\n        s_global = np.zeros((E, N + 1))\n        for e in range(E):\n            s_global[e, :] = e + (xi_nodes + 1.0) / 2.0\n        \n        # Check Jacobian positivity\n        # J_min = 0.5 * (1 - 2*pi*|gamma|/E). Must be > 0.\n        # This is equivalent to |gamma| < E / (2*pi).\n        if np.abs(gamma) * 2.0 * np.pi >= E:\n            # This check is for robustness; problem statement confirms validity.\n            raise ValueError(f\"Jacobian may not be positive for case {case}\")\n\n        w_mesh_global = gamma * Omega * np.cos(Omega * t) * np.sin(2.0 * np.pi * s_global / E)\n\n        # 3. Compute discrete GCL term: dt_J = L(-w)\n        G_global = -w_mesh_global\n        dt_J_global = apply_L_operator(G_global, E, N, D, w_gll)\n\n        # 4. Compute discrete ALE flux term: L(F) = L(c*(a-w))\n        F_global = c * (a - w_mesh_global)\n        L_F_global = apply_L_operator(F_global, E, N, D, w_gll)\n        \n        # 5. Compute the residual vector: R = c*dt_J - L(F)\n        # As derived, this should be close to zero.\n        R_global = c * dt_J_global - L_F_global\n        \n        # 6. Compute the infinity norm of the residual\n        r = np.max(np.abs(R_global))\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.16e}' for res in results)}]\")\n\nsolve()\n```", "id": "3398913"}, {"introduction": "使用无矩阵方法背后的动机是追求卓越的性能。这最后一个练习[@problem_id:3399013]将焦点从数值分析转向计算科学，分析无矩阵算子的可扩展性和效率。通过建立并应用基于算术强度和屋顶线（roofline）模型的性能模型，学生将学会分析算法设计如何与硬件架构相互作用，这是开发高性能科学计算模拟的一项关键技能。", "problem": "设计并实现一个完整的、可运行的程序，该程序使用带有对称内部罚项的张量积不连续伽辽金 (DG) 算子，模拟并分析三维标量泊松问题的无矩阵、高阶算子的可扩展性。您的分析必须纯粹基于算法和数学，依据第一性原理和经过充分检验的公式，并且不得依赖外部测量。该程序必须生成在 $h$ (网格尺寸) 细化和多项式次数 $p$ 增加的情况下，迭代次数、算术强度和吞吐量的合成测量数据，然后将一个简单的性能模型拟合到这些测量数据上。\n\n使用以下基本基础和定义：\n\n- 考虑一个单位立方体域，其上有一个 $M \\times M \\times M$ 个单元的结构化笛卡尔网格，其中 $M = 2^L$，L 为细化水平，$L \\in \\mathbb{N}_0$。单元尺寸为 $h = 1/M = 2^{-L}$。\n- 每个坐标方向使用 $p$ 阶节点张量积基，每个方向有 $n = p + 1$ 个节点，每个单元有 $n^3$ 个节点。\n- 对 DG 算子采用标准的和因子分解无矩阵实现。每个单元的浮点运算次数模型为\n$$\nF_{\\text{elem}}(p) = 90\\,n^4 + 60\\,n^3 \\quad \\text{flops}, \\quad n = p+1,\n$$\n该公式考虑了在对称内部罚离散化中，沿每个坐标进行张量收缩的体积项和面项。这捕捉了众所周知的 $d=3$ 维中体积项的 $\\mathcal{O}(n^{d+1})$ 开销和面项的 $\\mathcal{O}(n^d)$ 开销。\n- 每个单元的主内存流量模型为\n$$\nB_{\\text{elem}}(p) = 72\\,n^3 \\quad \\text{bytes},\n$$\n该模型考虑了读取一次输入向量（$8\\,n^3$ 字节）、写入一次输出向量（$8\\,n^3$ 字节）以及在求积点读取几何因子（模型化为 $56\\,n^3$ 字节），所有操作均使用双精度。假设基和求积元数据被有效缓存，不主导内存流量。\n- 每个单元的算术强度为\n$$\nI(p) = \\frac{F_{\\text{elem}}(p)}{B_{\\text{elem}}(p)} \\quad \\text{flops/byte}.\n$$\n- 每个单元使用一个简单的 roofline 执行时间模型：\n$$\nt_{\\text{elem}}(p; P, \\mathrm{BW}) = \\max\\!\\left(\\frac{F_{\\text{elem}}(p)}{P}, \\frac{B_{\\text{elem}}(p)}{\\mathrm{BW}} \\right),\n$$\n其中 $P$ 是峰值浮点速率（单位为 flops/秒），$\\mathrm{BW}$ 是持续内存带宽（单位为 字节/秒）。对于 $p$ 和 $h$ 的每种组合，实现的吞吐量（浮点速率）为\n$$\n\\Theta(p; P, \\mathrm{BW}) = \\frac{F_{\\text{elem}}(p)}{t_{\\text{elem}}(p; P, \\mathrm{BW})} = \\min\\!\\left(P,\\, I(p)\\,\\mathrm{BW}\\right),\n$$\n该值与 $h$ 无关。\n- 使用标准界限来模拟带对角（Jacobi）预处理的共轭梯度 (CG) 方法的迭代次数\n$$\nk(h,p;\\varepsilon) \\approx \\left\\lceil \\tfrac{1}{2}\\sqrt{\\kappa(h,p)} \\,\\ln\\!\\left(\\tfrac{2}{\\varepsilon}\\right)\\right\\rceil,\n$$\n其中条件数按以下方式缩放\n$$\n\\kappa(h,p) = C\\,\\frac{p^4}{h^2},\n$$\n这是高阶有限元和谱元离散化椭圆算子时一个被广泛接受的缩放规律。设置 $C = 1$，相对残差容差为 $\\varepsilon = 10^{-8}$。\n\n对于下面的每个测试用例，您的程序必须：\n1. 从提供的细化水平和多项式次数列表中，生成所有的 $(L, p)$ 对。\n2. 对于每个 $p$，使用上述公式计算 $F_{\\text{elem}}(p)$、$B_{\\text{elem}}(p)$、$I(p)$、$t_{\\text{elem}}(p; P, \\mathrm{BW})$ 和 $\\Theta(p; P, \\mathrm{BW})$。\n3. 对于每个 $(L,p)$ 对，计算 $h = 2^{-L}$ 和迭代次数 $k(h,p;\\varepsilon)$。\n4. 对每个测试用例，汇总以下指标：\n   - 在所有考虑的 $p$ 值上的平均算术强度，\n     $$\n     \\overline{I} = \\frac{1}{N_p}\\sum_{p} I(p),\n     $$\n     其中 $N_p$ 是测试用例中不同 $p$ 值的数量。\n   - 在所有 $(L,p)$ 对上的平均实现吞吐量，\n     $$\n     \\overline{\\Theta} = \\frac{1}{N_L N_p}\\sum_{L}\\sum_{p} \\Theta(p; P, \\mathrm{BW}),\n     $$\n     其中 $N_L$ 是测试用例中细化水平的数量。\n   - 在所有 $(L,p)$ 对上的平均 CG 迭代次数，\n     $$\n     \\overline{k} = \\frac{1}{N_L N_p}\\sum_{L}\\sum_{p} k(h,p;\\varepsilon).\n     $$\n5. 通过计算满足所有观测到的 $p$ 的 roofline 不等式的最紧可行峰值参数 $(\\widehat{P}, \\widehat{\\mathrm{BW}})$，从合成的单元时间 $t_{\\text{elem}}(p; P, \\mathrm{BW})$ 拟合一个 roofline 性能模型：\n   $$\n   \\widehat{P} = \\max_{p} \\frac{F_{\\text{elem}}(p)}{t_{\\text{elem}}(p; P, \\mathrm{BW})}, \\qquad\n   \\widehat{\\mathrm{BW}} = \\max_{p} \\frac{B_{\\text{elem}}(p)}{t_{\\text{elem}}(p; P, \\mathrm{BW})}.\n   $$\n   这是最小的 $(\\widehat{P}, \\widehat{\\mathrm{BW}})$ 对，使得对所有 $p$ 都有 $t_{\\text{elem}}(p; \\widehat{P}, \\widehat{\\mathrm{BW}}) \\le t_{\\text{elem}}(p; P, \\mathrm{BW})$，并且当数据集中同时出现带宽受限和计算受限两种情况时，它等于真实的 $(P,\\mathrm{BW})$。当只出现一种情况时，$\\widehat{P}$ 或 $\\widehat{\\mathrm{BW}}$ 成为真实峰值的下界。\n\n测试套件：\n- 测试用例 A（平衡到带宽受限的过渡）：\n  - 峰值浮点速率：$P = 400 \\times 10^9$ flops/s。\n  - 内存带宽：$\\mathrm{BW} = 100 \\times 10^9$ 字节/s。\n  - 细化水平：$L \\in \\{0,1,2,3\\}$。\n  - 多项式次数：$p \\in \\{1,3,7,15\\}$。\n- 测试用例 B（整个集合均为带宽受限）：\n  - 峰值浮点速率：$P = 1500 \\times 10^9$ flops/s。\n  - 内存带宽：$\\mathrm{BW} = 40 \\times 10^9$ 字节/s。\n  - 细化水平：$L \\in \\{0,1,2,3\\}$。\n  - 多项式次数：$p \\in \\{1,2,3,4,7\\}$。\n- 测试用例 C（平衡到计算受限的过渡）：\n  - 峰值浮点速率：$P = 800 \\times 10^9$ flops/s。\n  - 内存带宽：$\\mathrm{BW} = 200 \\times 10^9$ 字节/s。\n  - 细化水平：$L \\in \\{1,2,3\\}$。\n  - 多项式次数：$p \\in \\{1,5,9,13\\}$。\n\n单位和输出要求：\n- 吞吐量以千兆浮点运算每秒（GF/s）表示，即将 flops/秒 除以 $10^9$。\n- 内存带宽以千兆字节每秒（GB/s）表示，即将 字节/秒 除以 $10^9$。\n- 最终输出必须是单行，包含一个由三个结果组成的列表（每个测试用例一个），其中每个结果是一个包含五个数字的列表：\n  $$\n  [\\,\\overline{k},\\,\\overline{I},\\,\\overline{\\Theta}\\,(\\text{GF/s}),\\,\\widehat{\\mathrm{BW}}\\,(\\text{GB/s}),\\,\\widehat{P}\\,(\\text{GF/s})\\,].\n  $$\n- 将所有浮点输出四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，包含以逗号分隔并用方括号括起来的结果（例如，\"[[...],[...],[...]]\"）。不应打印任何其他文本。\n\n您的实现必须确定性地遵循这些步骤，不得使用任何随机性。程序必须能够按原样运行，无需任何用户输入、外部文件或网络访问。确保所有计算仅根据此处提供的定义即可复现。", "solution": "该问题是有效的，因为它在科学上基于数值分析和高性能计算的原理，定义和约束完整，问题是适定的，并且其表述是客观的。所有提供的模型和公式都是计算科学领域用于分析数值方法性能的标准方法。我现在将进行详细的解答。\n\n该解决方案通过系统地实现为无矩阵不连续伽辽金 (DG) 算子性能分析所提供的数学模型来设计。分析分为三个主要部分：计算核心的性能、迭代求解器的收敛性以及将性能模型拟合到合成数据。\n\n**1. 单元性能模型（计算核心）**\n\n模拟的核心是在单个网格单元上应用 DG 算子的性能模型。算子应用是共轭梯度 (CG) 等迭代求解器中最耗时的部分。\n\n每个单元的浮点运算 (flop) 次数 $F_{\\text{elem}}(p)$ 由下式给出：\n$$\nF_{\\text{elem}}(p) = 90\\,n^4 + 60\\,n^3 \\quad \\text{flops}, \\quad \\text{where } n = p+1\n$$\n这里，$p$ 是基函数的多项式次数。该公式模拟了三维 ($d=3$) 中和因子分解实现的成本。主导项 $90\\,n^4$ 反映了与体积积分的张量收缩相关的 $\\mathcal{O}(n^{d+1})$ 复杂度。$60\\,n^3$ 项反映了 DG 方法固有的面积分的 $\\mathcal{O}(n^d)$ 复杂度。\n\n每个单元的主内存流量（移动的字节数） $B_{\\text{elem}}(p)$ 为：\n$$\nB_{\\text{elem}}(p) = 72\\,n^3 \\quad \\text{bytes}, \\quad \\text{where } n = p+1\n$$\n该模型假设使用双精度浮点数（$8$ 字节）。它考虑了读取输入向量（$8n^3$ 字节）、写入结果输出向量（$8n^3$ 字节）以及读取单元的预计算几何因子（$56n^3$ 字节），这些因子对于从参考单元到物理单元的转换是必需的。\n\n这两个量的比率定义了算术强度 $I(p)$：\n$$\nI(p) = \\frac{F_{\\text{elem}}(p)}{B_{\\text{elem}}(p)} = \\frac{90n^4 + 60n^3}{72n^3} = \\frac{90(p+1) + 60}{72} \\quad \\text{flops/byte}\n$$\n算术强度是一个关键的、与硬件无关的度量，它表征了算法的数据局部性。更高的强度意味着每从主内存移动一个字节的数据，就执行更多的计算。\n\n每个单元的执行时间 $t_{\\text{elem}}$ 使用 roofline 模型确定，该模型假定性能受限于机器的峰值浮点速率 $P$ 或其内存带宽 $\\mathrm{BW}$：\n$$\nt_{\\text{elem}}(p; P, \\mathrm{BW}) = \\max\\left(\\frac{F_{\\text{elem}}(p)}{P}, \\frac{B_{\\text{elem}}(p)}{\\mathrm{BW}} \\right)\n$$\n实现的浮点吞吐量 $\\Theta(p; P, \\mathrm{BW})$ 是执行的浮点运算次数除以该时间，可以表示为：\n$$\n\\Theta(p; P, \\mathrm{BW}) = \\frac{F_{\\text{elem}}(p)}{t_{\\text{elem}}(p; P, \\mathrm{BW})} = \\min(P, I(p) \\cdot \\mathrm{BW})\n$$\n这个简洁的形式表明，如果核心是计算受限的（$I(p) > P/\\mathrm{BW}$），吞吐量受限于峰值计算速率 $P$；如果核心是内存受限的（$I(p) < P/\\mathrm{BW}$），则受限于内存系统提供数据的速率（$I(p) \\cdot \\mathrm{BW}$）。\n\n**2. 迭代求解器性能模型（收敛性）**\n\n求解线性系统的总时间取决于每次迭代的时间（主要由算子应用主导）和达到收敛所需的迭代次数。共轭梯度法的迭代次数 $k$ 是基于其标准收敛理论建模的。对于相对残差容差 $\\varepsilon$，迭代次数近似为：\n$$\nk(h,p;\\varepsilon) \\approx \\left\\lceil \\tfrac{1}{2}\\sqrt{\\kappa(h,p)} \\,\\ln\\left(\\tfrac{2}{\\varepsilon}\\right)\\right\\rceil\n$$\n其中 $\\kappa(h,p)$ 是预处理系统矩阵的条件数。对于带 Jacobi 预处理的泊松问题的对称内部罚 (SIP) DG 离散化，条件数随网格尺寸 $h$ 和多项式次数 $p$ 的缩放关系为：\n$$\n\\kappa(h,p) = C\\,\\frac{p^4}{h^2}\n$$\n这个缩放关系是高阶方法分析中一个公认的结果，源于迹不等式和逆不等式。给定常数 $C=1$ 和 $\\varepsilon=10^{-8}$，以及网格尺寸关系 $h=2^{-L}$（$L$ 为细化水平），迭代次数公式变为：\n$$\nk(L,p) = \\left\\lceil \\tfrac{1}{2}\\sqrt{\\frac{p^4}{(2^{-L})^2}} \\,\\ln\\left(\\frac{2}{10^{-8}}\\right)\\right\\rceil = \\left\\lceil p^2 \\cdot 2^{L-1} \\ln(2\\cdot 10^8)\\right\\rceil\n$$\n\n**3. 聚合与性能模型拟合**\n\n对于每个测试用例，程序会为所有指定的 $(L, p)$ 对计算上述量。然后计算三个平均指标：\n- 平均算术强度 $\\overline{I}$：$I(p)$ 在所有 $p$ 上的平均值。\n- 平均实现吞吐量 $\\overline{\\Theta}$：$\\Theta(p)$ 在所有 $(L,p)$ 对上的平均值。由于 $\\Theta$ 与 $L$ 无关，这等同于在 $p$ 上的平均值。\n- 平均 CG 迭代次数 $\\overline{k}$：$k(L,p)$ 在所有 $(L,p)$ 对上的平均值。\n\n最后，程序从合成的时间数据中反向工程出一个 roofline 模型。它计算与观察到的单元时间 $t_{\\text{elem}}(p; P, \\mathrm{BW})$ 一致的最紧可行峰值参数 $(\\widehat{P}, \\widehat{\\mathrm{BW}})$。计算公式如下：\n$$\n\\widehat{P} = \\max_{p} \\frac{F_{\\text{elem}}(p)}{t_{\\text{elem}}(p; P, \\mathrm{BW})} = \\max_p \\Theta(p; P, \\mathrm{BW})\n$$\n$$\n\\widehat{\\mathrm{BW}} = \\max_{p} \\frac{B_{\\text{elem}}(p)}{t_{\\text{elem}}(p; P, \\mathrm{BW})} = \\max_p \\min(P/I(p), \\mathrm{BW})\n$$\n如果所选的多项式次数 $p$ 集合包含既处于内存受限区域又处于计算受限区域的值，这些拟合参数将与真实的硬件参数 $(P, \\mathrm{BW})$ 相匹配。如果所有点都处于一个区域，那么对于未受约束的资源的拟合值（在内存受限情况下是 $\\widehat{P}$，在计算受限情况下是 $\\widehat{\\mathrm{BW}}$）表示其真实峰值的下界。\n\n实现部分为每个提供的测试用例自动执行这些计算，将结果格式化为指定的单位（GF/s 和 GB/s），进行四舍五入，并以所需的列表的列表格式打印出来。", "answer": "```python\nimport numpy as np\n\ndef process_case(P, BW, L_values, p_values):\n    \"\"\"\n    Processes a single test case to compute performance metrics.\n\n    Args:\n        P (float): Peak floating-point rate in flops/s.\n        BW (float): Memory bandwidth in bytes/s.\n        L_values (list): List of refinement levels L.\n        p_values (list): List of polynomial degrees p.\n\n    Returns:\n        list: A list of 5 floating-point numbers representing the results for the case:\n              [avg_k, avg_I, avg_Theta_gfs, fit_BW_gbs, fit_P_gfs].\n    \"\"\"\n    \n    C = 1.0\n    epsilon = 1e-8\n    k_log_term = np.log(2.0 / epsilon)\n    \n    intensities = []\n    throughputs = []\n    iter_counts = []\n    \n    # For roofline fitting\n    p_fit_P_values = []\n    p_fit_BW_values = []\n\n    # Loop over polynomial degrees p\n    for p in p_values:\n        n = float(p + 1)\n        \n        # Flops and Bytes per element\n        f_elem = 90.0 * n**4 + 60.0 * n**3\n        b_elem = 72.0 * n**3\n        \n        # Arithmetic intensity\n        intensity = f_elem / b_elem\n        intensities.append(intensity)\n        \n        # Roofline time and throughput\n        t_compute = f_elem / P\n        t_memory = b_elem / BW\n        t_elem = max(t_compute, t_memory)\n        \n        throughput = f_elem / t_elem\n        throughputs.append(throughput)\n        \n        # Values for fitting\n        p_fit_P_values.append(f_elem / t_elem)\n        p_fit_BW_values.append(b_elem / t_elem)\n\n        # Loop over refinement levels L\n        for L in L_values:\n            h = 2.0**(-L)\n            \n            # Condition number\n            kappa = C * (p**4) / (h**2)\n            \n            # Iteration count\n            k = np.ceil(0.5 * np.sqrt(kappa) * k_log_term)\n            iter_counts.append(k)\n            \n    # Calculate aggregate metrics\n    avg_I = np.mean(intensities)\n    \n    # Throughput is independent of L, averaging over L and p is same as over p\n    avg_Theta = np.mean(throughputs)\n    \n    avg_k = np.mean(iter_counts)\n    \n    # Fit the roofline model\n    fit_P = max(p_fit_P_values)\n    fit_BW = max(p_fit_BW_values)\n\n    # Convert to required units\n    avg_Theta_gfs = avg_Theta / 1e9\n    fit_P_gfs = fit_P / 1e9\n    fit_BW_gbs = fit_BW / 1e9\n    \n    # Return rounded results\n    return [\n        avg_k,\n        avg_I,\n        avg_Theta_gfs,\n        fit_BW_gbs,\n        fit_P_gfs\n    ]\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test Case A\n        (400e9, 100e9, [0, 1, 2, 3], [1, 3, 7, 15]),\n        # Test Case B\n        (1500e9, 40e9, [0, 1, 2, 3], [1, 2, 3, 4, 7]),\n        # Test Case C\n        (800e9, 200e9, [1, 2, 3], [1, 5, 9, 13])\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = process_case(*case)\n        all_results.append(result)\n\n    # Format the final output string as a list of lists of numbers\n    formatted_inner_lists = []\n    for res_list in all_results:\n        # Format each number to 6 decimal places\n        formatted_nums = [f'{val:.6f}' for val in res_list]\n        formatted_inner_lists.append(f\"[{','.join(formatted_nums)}]\")\n    \n    final_output = f\"[{','.join(formatted_inner_lists)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3399013"}]}