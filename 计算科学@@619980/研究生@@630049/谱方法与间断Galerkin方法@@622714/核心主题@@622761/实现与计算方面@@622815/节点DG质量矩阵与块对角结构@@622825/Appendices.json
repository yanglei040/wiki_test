{"hands_on_practices": [{"introduction": "DG 方法的计算效率在很大程度上取决于质量矩阵的结构。此练习探讨了张量积单元的理想情况，其中单元质量矩阵块可以优雅地表示为一维矩阵的克罗内克积。理解这种结构是推导快速“和因子分解”算法以应用矩阵或其逆矩阵的关键，这对于高性能计算至关重要 ([@problem_id:3402879])。", "problem": "考虑在单个 $d$ 维矩形单元 $K = \\prod_{k=1}^{d} [a_k,b_k]$ 上对一个标量守恒律进行的间断伽辽金 (DG) 离散化。设 $n \\geq 2$ 为每个空间方向上的节点数，并设 $\\{ \\ell_{i}^{(k)}(\\xi_k) \\}_{i=1}^{n}$ 表示在参考区间 $[-1,1]$ 上与每个方向 $k \\in \\{1,\\dots,d\\}$ 的这些节点相关联的一维拉格朗日基。在参考超立方体 $[-1,1]^d$ 上定义张量积节点基为\n$$\n\\phi_{\\boldsymbol{i}}(\\boldsymbol{\\xi}) \\;=\\; \\prod_{k=1}^{d} \\ell_{i_k}^{(k)}(\\xi_k), \\quad \\boldsymbol{i} = (i_1,\\dots,i_d), \\quad i_k \\in \\{1,\\dots,n\\},\n$$\n并通过仿射映射 $x_k = \\frac{b_k-a_k}{2}\\,\\xi_k + \\frac{a_k+b_k}{2}$（其中 $k=1,\\dots,d$）映射到物理单元。局部 DG 质量矩阵块 $M \\in \\mathbb{R}^{N \\times N}$（其中 $N = n^d$）由精确积分定义，\n$$\nM_{\\boldsymbol{i},\\boldsymbol{j}} \\;=\\; \\int_{K} \\phi_{\\boldsymbol{i}}(\\boldsymbol{x})\\,\\phi_{\\boldsymbol{j}}(\\boldsymbol{x})\\,\\mathrm{d}\\boldsymbol{x}.\n$$\n您可以假设，由于基函数在单元界面上是不连续的，网格上的全局质量矩阵是块对角的，每个单元对应一个这样的块。\n\n1. 从 $M_{\\boldsymbol{i},\\boldsymbol{j}}$ 的定义和张量积基的可分离性出发，证明局部质量矩阵可以写成一维质量矩阵的克罗内克积，\n$$\nM \\;=\\; M^{(1)} \\otimes M^{(2)} \\otimes \\cdots \\otimes M^{(d)},\n$$\n其中每个 $M^{(k)} \\in \\mathbb{R}^{n \\times n}$ 是方向 $k$ 上的一维质量矩阵，且包含了相应的仿射缩放。\n\n2. 设 $v \\in \\mathbb{R}^{N}$ 是单元上的一个任意自由度向量，它被重塑为一个大小为 $n \\times \\cdots \\times n$ 的 $d$ 阶张量。使用求和分解法，通过沿每个张量模态的一系列 $d$ 次一维运算来将 $M$ 应用于 $v$。类似地，通过在每个张量线上进行 $d$ 次独立的一维求解来应用 $M^{-1}$（假设已预先计算好一维矩阵分解，因此在应用时只计算前向和后向代入的开销）。计算浮点运算次数时，将一次乘法视为一次运算，一次加法视为一次运算，因此一个乘加对计为两次运算。忽略所有低阶项和任何预计算成本。\n\n请提供一个关于 $d$ 和 $n$ 的单一闭式解析表达式作为您的最终答案，该表达式表示使用求和分解法在单个单元上将 $M$ 或 $M^{-1}$ 应用于一个向量所需浮点运算的主阶数。答案必须是单一表达式，不带任何附加评论或条件。", "solution": "所述问题具有科学依据、是适定的、客观且自洽的。这是高阶数值方法（特别是谱方法和间断伽辽金 (DG) 方法）分析中的一个标准问题。该问题是有效的，并将提供解答。\n\n问题包含两部分。首先，我们必须证明在一个 $d$ 维矩形单元上的局部 DG 质量矩阵可以表示为一维质量矩阵的克罗内克积。其次，我们必须确定使用求和分解法将该质量矩阵或其逆矩阵应用于一个向量的主阶计算成本。\n\n**第一部分：质量矩阵的克罗内克积结构**\n\n局部质量矩阵 $M$ 的元素 $(\\boldsymbol{i}, \\boldsymbol{j})$ 定义为两个张量积基函数在物理单元 $K = \\prod_{k=1}^{d} [a_k, b_k]$ 上的乘积的积分。指标 $\\boldsymbol{i}$ 和 $\\boldsymbol{j}$ 是形式为 $\\boldsymbol{i} = (i_1, \\dots, i_d)$ 和 $\\boldsymbol{j} = (j_1, \\dots, j_d)$ 的多重指标，其中对于所有 $k \\in \\{1, \\dots, d\\}$，都有 $i_k, j_k \\in \\{1, \\dots, n\\}$。\n\n其定义为：\n$$\nM_{\\boldsymbol{i},\\boldsymbol{j}} = \\int_{K} \\phi_{\\boldsymbol{i}}(\\boldsymbol{x})\\,\\phi_{\\boldsymbol{j}}(\\boldsymbol{x})\\,\\mathrm{d}\\boldsymbol{x}\n$$\n基函数在参考超立方体 $[-1, 1]^d$ 上定义为 $\\phi_{\\boldsymbol{i}}(\\boldsymbol{\\xi}) = \\prod_{k=1}^{d} \\ell_{i_k}^{(k)}(\\xi_k)$。我们必须将积分变量从物理坐标 $\\boldsymbol{x}$ 更改为参考坐标 $\\boldsymbol{\\xi}$。仿射映射由 $x_k = \\frac{b_k-a_k}{2}\\,\\xi_k + \\frac{a_k+b_k}{2}$ 给出。此变换的雅可比矩阵是对角的，其元素为：\n$$\n\\frac{\\partial x_k}{\\partial \\xi_j} = \\delta_{kj} \\frac{b_k-a_k}{2}\n$$\n其中 $\\delta_{kj}$ 是克罗内克 delta。雅可比行列式 $J$ 是对角元素的乘积：\n$$\nJ = \\det\\left(\\frac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{\\xi}}\\right) = \\prod_{k=1}^{d} \\frac{b_k-a_k}{2}\n$$\n微分体积元变换为 $\\mathrm{d}\\boldsymbol{x} = J\\,\\mathrm{d}\\boldsymbol{\\xi}$。将此式及基函数的定义代入 $M_{\\boldsymbol{i},\\boldsymbol{j}}$ 的积分中，得到：\n$$\nM_{\\boldsymbol{i},\\boldsymbol{j}} = \\int_{[-1,1]^d} \\left(\\prod_{k=1}^{d} \\ell_{i_k}^{(k)}(\\xi_k)\\right) \\left(\\prod_{k=1}^{d} \\ell_{j_k}^{(k)}(\\xi_k)\\right) \\left(\\prod_{k=1}^{d} \\frac{b_k-a_k}{2}\\right) \\mathrm{d}\\boldsymbol{\\xi}\n$$\n我们可以对积分内的各项重新组合：\n$$\nM_{\\boldsymbol{i},\\boldsymbol{j}} = \\int_{[-1,1]^d} \\prod_{k=1}^{d} \\left( \\ell_{i_k}^{(k)}(\\xi_k) \\, \\ell_{j_k}^{(k)}(\\xi_k) \\, \\frac{b_k-a_k}{2} \\right) \\mathrm{d}\\xi_1 \\dots \\mathrm{d}\\xi_d\n$$\n由于被积函数是可分离的，我们可以应用 Fubini 定理将多维积分分离为一维积分的乘积：\n$$\nM_{\\boldsymbol{i},\\boldsymbol{j}} = \\prod_{k=1}^{d} \\left( \\int_{-1}^{1} \\ell_{i_k}^{(k)}(\\xi_k)\\,\\ell_{j_k}^{(k)}(\\xi_k) \\left(\\frac{b_k-a_k}{2}\\right) \\mathrm{d}\\xi_k \\right)\n$$\n让我们为每个方向 $k$ 定义一维质量矩阵 $M^{(k)} \\in \\mathbb{R}^{n \\times n}$ 如下：\n$$\nM^{(k)}_{i_k, j_k} = \\frac{b_k-a_k}{2} \\int_{-1}^{1} \\ell_{i_k}^{(k)}(\\xi_k) \\, \\ell_{j_k}^{(k)}(\\xi_k) \\, \\mathrm{d}\\xi_k\n$$\n根据这个定义，完整的 $d$ 维质量矩阵的元素变为：\n$$\nM_{\\boldsymbol{i},\\boldsymbol{j}} = M^{(1)}_{i_1, j_1} M^{(2)}_{i_2, j_2} \\cdots M^{(d)}_{i_d, j_d}\n$$\n这恰好是矩阵 $M^{(1)}, \\dots, M^{(d)}$ 的克罗内克积的第 $(\\boldsymbol{i}, \\boldsymbol{j})$ 个元素的定义，其中多重指标 $\\boldsymbol{i}$ 和 $\\boldsymbol{j}$ 被映射到单个行和列索引（例如，按字典序）。因此，我们证明了：\n$$\nM = M^{(1)} \\otimes M^{(2)} \\otimes \\cdots \\otimes M^{(d)}\n$$\n\n**第二部分：浮点运算计数**\n\n我们需要找出计算矩阵-向量积 $u = Mv$ 或求解系统 $Mu=v$（即计算 $u = M^{-1}v$）的主阶浮点运算 (FLOPS) 次数，其中向量 $v \\in \\mathbb{R}^N$ 且 $N=n^d$。求和分解法将向量 $v$ 重塑为一个大小为 $n \\times \\cdots \\times n$ 的 $d$ 阶张量 $V$。然后，乘积 $u$ 被计算为相同大小的张量 $U$。\n\n**情况1：应用 $M$**\n\n乘积 $u=Mv$（其中 $M = M^{(1)} \\otimes \\cdots \\otimes M^{(d)}$）是通过一系列 $d$ 次运算来执行的，每个运算对应张量 $V$ 的一个维度。设初始张量为 $V^{(0)} = V$。该序列为：对于 $k = 1, \\dots, d$：通过沿 $V^{(k-1)}$ 的第 $k$ 个模态应用 $M^{(k)}$ 来计算 $V^{(k)}$。\n让我们分析这样一个步骤的成本，例如，沿第一个模态应用 $M^{(1)}$。计算过程为：\n$$\n(V^{(1)})_{i_1, i_2, \\dots, i_d} = \\sum_{j_1=1}^{n} M^{(1)}_{i_1, j_1} (V^{(0)})_{j_1, i_2, \\dots, i_d}\n$$\n对于每一组固定的索引 $(i_2, \\dots, i_d)$，该运算是一个 $n \\times n$ 矩阵 $M^{(1)}$ 与一个长度为 $n$ 的向量的矩阵-向量积。共有 $n^{d-1}$ 组这样的固定索引，对应于张量沿第一个模态的 $n^{d-1}$ 个“纤维”。\n\n单个 $n \\times n$ 稠密矩阵-向量积的成本计算如下：对于输出向量的 $n$ 行中的每一行，我们执行两个长度为 $n$ 的向量的点积。这涉及 $n$ 次乘法和 $n-1$ 次加法，总共 $n + (n-1) = 2n-1$ 次浮点运算。对于所有 $n$ 行，总成本为 $n(2n-1) = 2n^2 - n$ 次浮点运算。主阶成本为 $2n^2$ 次浮点运算。\n\n求和分解法中一个步骤（例如，沿第一个模态应用 $M^{(1)}$）的成本是纤维数量乘以每个纤维的成本：\n$$\n\\text{每步成本} = n^{d-1} \\times (2n^2 - n) = 2n^{d+1} - n^d\n$$\n一个步骤的主阶成本是 $2n^{d+1}$。由于有 $d$ 个这样的步骤（每个维度一个），应用 $M$ 的总主阶成本是：\n$$\n\\text{应用 } Mv \\text{ 的总成本} = d \\times (2n^{d+1}) = 2dn^{d+1}\n$$\n\n**情况2：应用 $M^{-1}$**\n\n克罗内克积的逆是逆的克罗内克积：\n$$\nM^{-1} = (M^{(1)} \\otimes \\cdots \\otimes M^{(d)})^{-1} = (M^{(1)})^{-1} \\otimes \\cdots \\otimes (M^{(d)})^{-1}\n$$\n$M^{-1}$ 的应用遵循相同的求和分解过程，但每个步骤都涉及应用一维质量矩阵的逆 $(M^{(k)})^{-1}$。这等同于求解一个线性方程组。问题指定我们假设对每个 $M^{(k)}$ 进行了预计算分解（例如 LU 分解）。\n将 $(M^{(k)})^{-1}$ 应用于向量 $x$ 意味着求解 $M^{(k)}y=x$ 以得到 $y$。利用预计算的 LU 分解 $M^{(k)}=L^{(k)}U^{(k)}$，这分两个阶段完成：\n1.  使用前向代入求解 $L^{(k)}z=x$。\n2.  使用后向代入求解 $U^{(k)}y=z$。\n\n对于一个稠密的 $n \\times n$ 下三角矩阵，前向代入需要 $\\sum_{i=1}^{n} (2(i-1)) = n(n-1) = n^2-n$ 次浮点运算。对于一个稠密的上三角矩阵，后向代入需要 $n^2$ 次浮点运算。求解一个 $n \\times n$ 系统的总成本为 $(n^2-n) + n^2 = 2n^2-n$ 次浮点运算。主阶成本为 $2n^2$ 次浮点运算。\n\n这个主阶成本与稠密矩阵-向量乘法的成本相同。因此，将 $(M^{(k)})^{-1}$ 应用于一个向量的成本，在主阶上是 $2n^2$ 次浮点运算。\n应用 $M^{-1}$ 的总成本是 $d$ 个步骤的成本之和，每个步骤涉及 $n^{d-1}$ 次一维求解：\n$$\n\\text{应用 } M^{-1}v \\text{ 的总成本} = d \\times (n^{d-1} \\times 2n^2) = 2dn^{d+1}\n$$\n应用 $M$ 或 $M^{-1}$ 的主阶运算计数是相同的。\n\n浮点运算主阶数的最终表达式是 $2dn^{d+1}$。", "answer": "$$\n\\boxed{2dn^{d+1}}\n$$", "id": "3402879"}, {"introduction": "在理想情况之外，我们常常需要处理更实际的弯曲单元场景。当几何映射不是简单的仿射变换时，雅可比行列式不再是常数，这为质量矩阵的积分带来了复杂性。本练习通过一个动手计算，量化了当我们使用节点求积（质量集中）得到的对角矩阵来近似精确质量矩阵时所产生的“混叠误差”，这是一种简化计算的常用技术 ([@problem_id:3402889])。", "problem": "考虑一维参考单元 $\\xi \\in [-1,1]$，它通过多项式映射 $x(\\xi)$ 映射到一个弯曲的物理单元，其雅可比为 $J(\\xi) = 1 + \\alpha \\xi + \\beta \\xi^{2}$，其中 $\\alpha$ 和 $\\beta$ 是实参数。在节点间断伽辽金 (DG) 方法中，该单元上的质量矩阵由矩阵元 $M_{ij} = \\int_{-1}^{1} \\ell_{i}(\\xi)\\,\\ell_{j}(\\xi)\\,J(\\xi)\\,\\mathrm{d}\\xi$ 定义，其中 $\\{\\ell_{i}\\}$ 是拉格朗日节点基多项式。当插值节点与 Gauss-Lobatto-Legendre (GLL) 求积节点配置时，通过计算以下公式形成一个近似的对角质量\n$$\n\\tilde{M}_{ii} = \\sum_{q=1}^{N} w_{q}\\,\\ell_{i}(\\xi_{q})\\,\\ell_{i}(\\xi_{q})\\,J(\\xi_{q}),\n$$\n其中 $\\{\\xi_{q}\\}$ 和 $\\{w_{q}\\}$ 分别是 GLL 节点和权重。取 $N=3$，则 GLL 节点为 $\\xi_{1}=-1$，$\\xi_{2}=0$，$\\xi_{3}=1$，相应的权重为 $w_{1}=\\frac{1}{3}$，$w_{2}=\\frac{4}{3}$，$w_{3}=\\frac{1}{3}$。设节点基为通过这些节点的 2 次拉格朗日多项式。关注与中间节点 $i=2$（位于 $\\xi=0$）相关的对角元。\n\n从上述定义出发，除了所述的映射和节点外，不作任何特殊结构假设，计算：\n- 配置 GLL 近似 $\\tilde{M}_{22}$。\n- 精确积分 $M_{22} = \\int_{-1}^{1} \\ell_{2}(\\xi)^{2}\\,J(\\xi)\\,\\mathrm{d}\\xi$。\n\n将在配置求积下由雅可比引起的混叠误差定义为\n$$\n\\Delta(\\alpha,\\beta) = M_{22} - \\tilde{M}_{22}.\n$$\n\n请提供 $\\Delta(\\alpha,\\beta)$ 的一个仅用 $\\beta$ 简化的闭合形式解析表达式。您的最终答案必须是单个解析表达式，无需四舍五入。", "solution": "用户要求我解决一个问题。\n\n我的计划如下：\n1.  我将首先验证用户的问题陈述。\n2.  如果问题有效，我将构造对应于节点 $\\xi=0$ 的拉格朗日基多项式 $\\ell_{2}(\\xi)$。\n3.  接下来，我将使用提供的求积法则计算配置 GLL 近似 $\\tilde{M}_{22}$。\n4.  然后，我将计算质量矩阵项 $M_{22}$ 的精确积分。\n5.  最后，我将计算它们的差值 $\\Delta(\\alpha,\\beta) = M_{22} - \\tilde{M}_{22}$ 并简化表达式。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n-   一维参考单元：$\\xi \\in [-1,1]$。\n-   映射的雅可比：$J(\\xi) = 1 + \\alpha \\xi + \\beta \\xi^{2}$，其中 $\\alpha, \\beta \\in \\mathbb{R}$。\n-   精确质量矩阵项定义：$M_{ij} = \\int_{-1}^{1} \\ell_{i}(\\xi)\\,\\ell_{j}(\\xi)\\,J(\\xi)\\,\\mathrm{d}\\xi$。\n-   近似对角质量项定义：$\\tilde{M}_{ii} = \\sum_{q=1}^{N} w_{q}\\,\\ell_{i}(\\xi_{q})\\,\\ell_{i}(\\xi_{q})\\,J(\\xi_{q})$。\n-   GLL 点数：$N=3$。\n-   GLL 节点：$\\xi_{1}=-1$，$\\xi_{2}=0$，$\\xi_{3}=1$。\n-   GLL 权重：$w_{1}=\\frac{1}{3}$，$w_{2}=\\frac{4}{3}$，$w_{3}=\\frac{1}{3}$。\n-   节点基：通过 GLL 节点的 2 次拉格朗日多项式 $\\{\\ell_{i}(\\xi)\\}$。\n-   目标项：中间节点 $i=2$（位于 $\\xi=0$）的对角元。\n-   混叠误差定义：$\\Delta(\\alpha,\\beta) = M_{22} - \\tilde{M}_{22}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学依据**：该问题设置在数值分析这一成熟领域内，特别是间断伽辽金方法。所有概念，如拉格朗日基、质量矩阵、GLL 求积和雅可比，都是标准的且定义正确。\n-   **适定性**：该问题要求计算两个明确定义的量及其差值。所有必要信息（节点、权重、函数）均已提供，确保存在唯一解。\n-   **客观性**：该问题以精确的数学语言陈述，没有歧义或主观因素。\n-   **完整性**：该问题是自洽的。$M_{22}$、$\\tilde{M}_{22}$、$J(\\xi)$、基函数和求积法则的定义都已明确给出。\n-   **一致性**：所提供的数据或定义中没有内部矛盾。\n\n**步骤 3：结论与行动**\n该问题有效。这是一个计算数学中的标准、适定问题。我现在将开始求解。\n\n**求解推导**\n\n**1. 确定拉格朗日基多项式 $\\ell_{2}(\\xi)$**\n节点基由通过节点 $\\xi_{1}=-1$、$\\xi_{2}=0$ 和 $\\xi_{3}=1$ 的 2 次拉格朗日多项式组成。基多项式 $\\ell_{2}(\\xi)$ 由性质 $\\ell_{2}(\\xi_{j}) = \\delta_{2j}$ 定义，其中 $\\delta_{2j}$ 是克罗内克 δ。这意味着 $\\ell_{2}(\\xi)$ 在 $\\xi_{1}=-1$ 和 $\\xi_{3}=1$ 处必须为零，在 $\\xi_{2}=0$ 处必须为一。\n\n$\\ell_{2}(\\xi)$ 的形式必为 $C(\\xi - \\xi_{1})(\\xi - \\xi_{3})$，其中 $C$ 是某个常数。\n$$\n\\ell_{2}(\\xi) = C(\\xi - (-1))(\\xi - 1) = C(\\xi+1)(\\xi-1) = C(\\xi^{2} - 1)\n$$\n为求出 $C$，我们使用条件 $\\ell_{2}(0) = 1$：\n$$\n1 = C(0^{2} - 1) = -C \\implies C = -1\n$$\n因此，所求的拉格朗日多项式为：\n$$\n\\ell_{2}(\\xi) = -( \\xi^{2} - 1) = 1 - \\xi^{2}\n$$\n\n**2. 计算配置 GLL 近似 $\\tilde{M}_{22}$**\n问题将近似质量矩阵项定义为：\n$$\n\\tilde{M}_{22} = \\sum_{q=1}^{3} w_{q}\\,\\ell_{2}(\\xi_{q})\\,\\ell_{2}(\\xi_{q})\\,J(\\xi_{q})\n$$\n由于插值节点与求积节点是配置的，我们有 $\\ell_{2}(\\xi_{q}) = \\delta_{2q}$。我们可以对每个求积点进行计算：\n-   对于 $q=1$：$\\ell_{2}(\\xi_{1}) = \\ell_{2}(-1) = 1 - (-1)^{2} = 0$。\n-   对于 $q=2$：$\\ell_{2}(\\xi_{2}) = \\ell_{2}(0) = 1 - (0)^{2} = 1$。\n-   对于 $q=3$：$\\ell_{2}(\\xi_{3}) = \\ell_{2}(1) = 1 - (1)^{2} = 0$。\n\n求和得以简化，因为只有 $q=2$ 的项非零：\n$$\n\\tilde{M}_{22} = w_{1}(0)^{2}J(\\xi_{1}) + w_{2}(1)^{2}J(\\xi_{2}) + w_{3}(0)^{2}J(\\xi_{3}) = w_{2}J(\\xi_{2})\n$$\n已知 $w_{2} = \\frac{4}{3}$ 且 $\\xi_{2}=0$。雅可比为 $J(\\xi) = 1 + \\alpha \\xi + \\beta \\xi^{2}$。在 $\\xi_{2}=0$ 处：\n$$\nJ(0) = 1 + \\alpha(0) + \\beta(0)^{2} = 1\n$$\n代入这些值：\n$$\n\\tilde{M}_{22} = \\frac{4}{3} \\cdot 1 = \\frac{4}{3}\n$$\n\n**3. 计算精确积分 $M_{22}$**\n精确质量矩阵项由以下积分给出：\n$$\nM_{22} = \\int_{-1}^{1} \\ell_{2}(\\xi)^{2}\\,J(\\xi)\\,\\mathrm{d}\\xi\n$$\n代入 $\\ell_{2}(\\xi)$ 和 $J(\\xi)$ 的表达式：\n$$\nM_{22} = \\int_{-1}^{1} (1 - \\xi^{2})^{2}\\,(1 + \\alpha \\xi + \\beta \\xi^{2})\\,\\mathrm{d}\\xi\n$$\n首先，展开被积函数：\n$$\n(1 - 2\\xi^{2} + \\xi^{4})(1 + \\alpha \\xi + \\beta \\xi^{2}) = (1 - 2\\xi^{2} + \\xi^{4}) + (\\alpha\\xi - 2\\alpha\\xi^{3} + \\alpha\\xi^{5}) + (\\beta\\xi^{2} - 2\\beta\\xi^{4} + \\beta\\xi^{6})\n$$\n按 $\\xi$ 的幂次对各项进行分组：\n$$\n1 + \\alpha\\xi + (\\beta - 2)\\xi^{2} - 2\\alpha\\xi^{3} + (1 - 2\\beta)\\xi^{4} + \\alpha\\xi^{5} + \\beta\\xi^{6}\n$$\n我们在对称区间 $[-1, 1]$ 上对该多项式进行积分。所有含 $\\xi$ 奇次幂的项的积分都将为零。因此，涉及 $\\alpha$ 的项会消失。\n$$\nM_{22} = \\int_{-1}^{1} (1 + (\\beta - 2)\\xi^{2} + (1 - 2\\beta)\\xi^{4} + \\beta\\xi^{6})\\,\\mathrm{d}\\xi\n$$\n我们使用通用公式 $\\int_{-1}^{1} \\xi^{2n}\\,\\mathrm{d}\\xi = \\frac{2}{2n+1}$：\n$$\nM_{22} = \\left[ \\xi \\right]_{-1}^{1} + (\\beta - 2) \\left[ \\frac{\\xi^{3}}{3} \\right]_{-1}^{1} + (1 - 2\\beta) \\left[ \\frac{\\xi^{5}}{5} \\right]_{-1}^{1} + \\beta \\left[ \\frac{\\xi^{7}}{7} \\right]_{-1}^{1}\n$$\n$$\nM_{22} = 2 + (\\beta - 2)\\frac{2}{3} + (1 - 2\\beta)\\frac{2}{5} + \\beta\\frac{2}{7}\n$$\n现在，我们简化此表达式：\n$$\nM_{22} = 2 + \\frac{2\\beta}{3} - \\frac{4}{3} + \\frac{2}{5} - \\frac{4\\beta}{5} + \\frac{2\\beta}{7}\n$$\n将常数项和含 $\\beta$ 的项分组：\n$$\n\\text{常数项} = 2 - \\frac{4}{3} + \\frac{2}{5} = \\frac{30 - 20 + 6}{15} = \\frac{16}{15}\n$$\n$$\n\\text{含 } \\beta \\text{ 的项} = \\beta\\left(\\frac{2}{3} - \\frac{4}{5} + \\frac{2}{7}\\right) = \\beta\\left(\\frac{2 \\cdot 35 - 4 \\cdot 21 + 2 \\cdot 15}{105}\\right) = \\beta\\left(\\frac{70 - 84 + 30}{105}\\right) = \\frac{16\\beta}{105}\n$$\n所以，精确积分为：\n$$\nM_{22} = \\frac{16}{15} + \\frac{16}{105}\\beta\n$$\n\n**4. 计算混叠误差 $\\Delta(\\alpha,\\beta)$**\n混叠误差是精确值与近似值之差：\n$$\n\\Delta(\\alpha,\\beta) = M_{22} - \\tilde{M}_{22}\n$$\n代入我们找到的表达式：\n$$\n\\Delta(\\alpha,\\beta) = \\left(\\frac{16}{15} + \\frac{16}{105}\\beta\\right) - \\frac{4}{3}\n$$\n为简化，为常数项找到一个公分母：\n$$\n\\Delta(\\alpha,\\beta) = \\frac{16}{15} - \\frac{4 \\cdot 5}{3 \\cdot 5} + \\frac{16}{105}\\beta = \\frac{16 - 20}{15} + \\frac{16}{105}\\beta\n$$\n$$\n\\Delta(\\alpha,\\beta) = -\\frac{4}{15} + \\frac{16}{105}\\beta\n$$\n这就是混叠误差的最终表达式，它按要求仅依赖于 $\\beta$。", "answer": "$$\\boxed{-\\frac{4}{15} + \\frac{16}{105}\\beta}$$", "id": "3402889"}, {"introduction": "这项计算练习将理论与实践联系起来，要求您实现并比较两种不同的 $L^2$ 投影方法：一种使用一致（完全积分）质量矩阵，另一种使用对角的“集中”质量矩阵。通过构建这些单元局部投影算子并量化它们各自的误差，您将对 DG 系统的块对角特性以及与质量集中相关的精度和计算成本之间的权衡获得实践性的理解 ([@problem_id:3402900])。", "problem": "考虑一个一维分区定义域和一个使用 Legendre–Gauss–Lobatto (GLL) 节点的节点间断 Galerkin (DG) 方法。您需要设计并实现一个程序，该程序利用质量矩阵的块对角结构来构建单元局部的 $L^2$ 投影，比较对角（集中）质量近似与一致（精确积分）质量矩阵，并定量分析混叠误差。该程序必须为指定的测试套件生成单行数值输出。\n\n使用的基本原理包括以下定义和事实：\n- 对于一个给定的单元 $e$，其局部参考坐标为 $\\xi \\in [-1,1]$，到物理坐标的映射为 $x(\\xi) = \\frac{x_R - x_L}{2}\\,\\xi + \\frac{x_R + x_L}{2}$，其雅可比行列式为 $J_e = \\frac{x_R - x_L}{2}$。\n- 将函数 $u$ 到最高为 $k$ 次的多项式空间 $V_k$ 上的单元局部 $L^2$ 投影，旨在寻找一个 $u_k \\in V_k$，使得对于所有单元局部基函数 $\\{\\phi_i\\}_{i=0}^k$，都有 $(\\phi_i, u_k)_{L^2(e)} = (\\phi_i, u)_{L^2(e)}$ 成立。这会在每个单元上导出一个以单元局部质量矩阵为左侧项的线性系统。\n- 在 GLL 节点 $\\{\\xi_j\\}_{j=0}^k$ 上的节点 DG 设置中，拉格朗日基定义为 $\\phi_j(\\xi_i) = \\delta_{ij}$。质量矩阵可以通过对基函数的乘积进行积分来组装。使用精确积分会得到一个完整（一致）的质量矩阵。而使用与节点集相关联的 GLL 求积法则会得到一个对角（集中）近似，该近似通常不严格等于一致质量矩阵。\n- 混叠是指因欠积分或用低阶离散表示来表达高阶内容而产生的误差。\n\n设计要求：\n- 在一维定义域 $[a,b] = [-1,1]$ 上进行操作。将其划分为 $E$ 个等长单元。在每个单元上，设 $V_N$ 为 GLL 节点上最高为 $N$ 次的节点多项式空间，设 $V_k$ 为最高为 $k$ 次的节点多项式空间，除非另有说明，否则 $k  N$。\n- 每个单元上的输入场是在该单元的 $N$ 次 GLL 节点上对给定目标函数 $u(x)$ 进行采样，并形成单元局部拉格朗日插值所得到的节点 $N$ 次插值 $u_N^h \\in V_N$。这个 $u_N^h$ 是要投影到 $V_k$ 上的场。\n- 实现两种到 $V_k$ 上的单元局部投影算子：\n  1. 一种使用对角（集中）质量的投影，该质量是用 $k$ 次 GLL 求积和 $k$ 次 GLL 基计算的。该质量矩阵因其构造方式而为对角矩阵，并能实现快速的单元求解。\n  2. 一种使用一致（积分至数值精度）质量矩阵的投影，该矩阵通过足够精确的 Gauss–Legendre 求积组装，以确保最高至少为 $N+k$ 次的多项式积分能被积分到机器精度。\n- 对于每个单元，使用两种方法计算投影场在 $k$ 次 GLL 节点上的节点系数。\n- 为 $L^2$ 投影定义一个基准参考如下：使用对于所涉及的被积函数足够精确的高阶 Gauss–Legendre 求积来组装 $k$ 次质量矩阵和右端项，使得 $u_N^h$ 的投影能计算到接近机器精度。将此用作 $u_N^h$ 到 $V_k$ 上的参考“精确”单元局部 $L^2$ 投影。\n- 为了在整个定义域上进行定量比较，将函数 $w$ 的定义域 $L^2$ 范数定义为 $\\|w\\|_{L^2([-1,1])} = \\left(\\sum_{e=1}^E \\int_{x_L^e}^{x_R^e} w(x)^2\\,dx\\right)^{1/2}$。所有范数评估所需的积分都必须通过足够高阶的 Gauss–Legendre 求积来计算，以确保其精度接近机器精度。\n\n您的程序必须：\n- 为任意非负整数 $m$ 构建 $m$ 次的 GLL 节点和权重，并根据需要组装拉格朗日插值/求值算子。\n- 在每个单元上实现两种投影方法。仅通过构建和求解每个单元的系统来利用块对角结构。确保对角质量版本专用于计算成本更低的逐单元过程。\n- 对于下面套件中的每个测试用例，计算三个浮点数：\n  1. $e_{\\mathrm{diff}}$：对角质量投影与一致质量投影之差的定义域 $L^2$ 范数，即 $\\|u_k^{\\mathrm{diag}} - u_k^{\\mathrm{cons}}\\|_{L^2([-1,1])}$。\n  2. $e_{\\mathrm{cons}}$：一致质量投影与基准参考投影之差的定义域 $L^2$ 范数，即 $\\|u_k^{\\mathrm{cons}} - u_k^{\\mathrm{ref}}\\|_{L^2([-1,1])}$。\n  3. $e_{\\mathrm{diag}}$：对角质量投影与基准参考投影之差的定义域 $L^2$ 范数，即 $\\|u_k^{\\mathrm{diag}} - u_k^{\\mathrm{ref}}\\|_{L^2([-1,1])}$。\n\n角度单位：当出现三角函数时，自变量以弧度为单位。\n\n测试套件：\n- 情况 A：$E = 3$，$N = 6$，$k = 3$，$u(x) = x^6 - 3 x^2 + 1$。\n- 情况 B：$E = 4$，$N = 7$，$k = 4$，$u(x) = \\sin(7 x)$，其中 $x$ 以弧度为单位。\n- 情况 C：$E = 2$，$N = 5$，$k = 5$，$u(x) = e^{x}$。\n- 情况 D：$E = 1$，$N = 8$，$k = 3$，$u(x) = P_{4}(x)$，其中 $P_{4}$ 是 $[-1,1]$ 上的 4 次勒让德多项式。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，按 A、B、C、D 的顺序输出三元组 $[e_{\\mathrm{diff}}, e_{\\mathrm{cons}}, e_{\\mathrm{diag}}]$，并将它们展平为单个列表。每个浮点数用科学记数法表示，并保留 $10$ 位有效数字。例如，单个三元组应类似于 $[1.234567890e-03,2.345678901e-04,3.456789012e-05]$，所有四个情况的总输出应是一个包含 $12$ 个数字的单个括号列表：$[a_1,a_2,a_3,b_1,b_2,b_3,c_1,c_2,c_3,d_1,d_2,d_3]$。\n\n约束和期望：\n- 所有单元局部计算必须是独立的，因此全局质量矩阵在构造上是块对角的。对角质量方法不得组装非对角质量项。\n- 用于组装一致质量矩阵和右端项的 Gauss–Legendre 求积阶数必须选择得能保证对最高至少为 $N+k$ 次的多项式被积函数是精确的；基准参考的求积阶数必须显著更高，以消除范数中的求积误差。\n- 所有数学符号、变量和数字都使用 LaTeX 内联数学表示，例如 $N$、$k$、$E$ 和 $10$。\n\n您的实现必须是一个完整的、可运行的程序，如最终答案部分所述，并且不需要任何用户输入。输出必须严格按照要求的格式只有一行。", "solution": "在尝试任何解决方案之前，需要对所提出的问题进行验证。\n\n### 第 1 步：提取已知条件\n- **方法**：在一维分区定义域 $[-1,1]$ 上，使用 Legendre–Gauss–Lobatto (GLL) 节点的节点间断 Galerkin (DG) 方法。\n- **定义域和离散化**：定义域为 $[a,b] = [-1,1]$，划分为 $E$ 个等长单元。参考单元为 $\\xi \\in [-1,1]$。雅可比行列式 $J_e = \\frac{x_R - x_L}{2}$。\n- **函数空间**：$V_N$ 是在 $N$ 次 GLL 节点上最高为 $N$ 次的节点多项式空间。$V_k$ 是在 $k$ 次 GLL 节点上最高为 $k$ 次的节点多项式空间，除非另有说明，否则 $k  N$。\n- **输入数据**：对于每个单元，输入是在 $N$ 次 GLL 节点上对给定函数 $u(x)$ 进行采样得到的节点 $N$ 次插值 $u_N^h \\in V_N$。\n- **任务**：实现并比较三种从 $V_N$ 到 $V_k$ 的单元局部 $L^2$ 投影算子。\n- **投影 1 (对角质量)**：质量矩阵和右端项使用 $k$ 次 GLL 求积计算。得到的质量矩阵是对角的。\n- **投影 2 (一致质量)**：质量矩阵和右端项使用 Gauss-Legendre 求积计算，其精度足以处理最高至少为 $N+k$ 次的被积函数。\n- **投影 3 (参考)**：与一致质量方法相同，但使用显著更高阶的 Gauss-Legendre 求积，以作为基准参考，精度接近机器精度。\n- **误差度量**：对于每个测试用例，计算得到的投影场 $u_k^{\\mathrm{diag}}$、$u_k^{\\mathrm{cons}}$ 和 $u_k^{\\mathrm{ref}}$ 之间差异的全域 $L^2$ 范数：\n  1. $e_{\\mathrm{diff}} = \\|u_k^{\\mathrm{diag}} - u_k^{\\mathrm{cons}}\\|_{L^2([-1,1])}$\n  2. $e_{\\mathrm{cons}} = \\|u_k^{\\mathrm{cons}} - u_k^{\\mathrm{ref}}\\|_{L^2([-1,1])}$\n  3. $e_{\\mathrm{diag}} = \\|u_k^{\\mathrm{diag}} - u_k^{\\mathrm{ref}}\\|_{L^2([-1,1])}$\n- **范数计算**：定义域 $L^2$ 范数 $\\|w\\|_{L^2([-1,1])}^2 = \\sum_{e=1}^E \\int_{x_L^e}^{x_R^e} w(x)^2\\,dx$，要求使用足够高阶的 Gauss-Legendre 求积来计算积分。\n- **测试套件**：\n    - A: $E = 3$, $N = 6$, $k = 3$, $u(x) = x^6 - 3 x^2 + 1$。\n    - B: $E = 4$, $N = 7$, $k = 4$, $u(x) = \\sin(7 x)$。\n    - C: $E = 2$, $N = 5$, $k = 5$, $u(x) = e^{x}$。\n    - D: $E = 1$, $N = 8$, $k = 3$, $u(x) = P_{4}(x)$。\n- **输出**：一个包含 $12$ 个浮点数的单行列表（每个测试用例三个），每个数都用科学记数法表示，并保留 $10$ 位有效数字。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题在数值分析领域有坚实的科学基础，特别是谱方法和间断 Galerkin 方法的研究。所使用的所有概念——$L^2$ 投影、GLL 节点、拉格朗日基、质量矩阵（一致与集中）以及混叠误差——都是标准的且定义明确。该问题可以形式化为一个精确的数值算法。所提供的信息是自洽的，并且足以构建一个解决方案；虽然“显著更高”的求积阶数没有严格定义，但在建立基准解决方案的背景下其意图是明确的，可以选择一个合理的高阶法则来满足此要求。该问题是适定的，因为到有限维空间上的 $L^2$ 投影涉及到一个对称正定质量矩阵的求逆，这保证了唯一解的存在。指定的测试用例在计算上是可行的，并包括一些非平凡的场景（例如，情况 C 中 $k=N$ 和情况 D 中使用正交多项式），这些场景可用于验证实现的正确性。该问题是计算科学领域的一个实质性练习，而非一个琐碎或同义反复的任务。\n\n### 第 3 步：结论与行动\n问题是**有效的**。将构建一个解决方案。\n\n### 解决方案\n目标是分析在节点间断 Galerkin (DG) 框架中，不同数值积分方案在计算 $L^2$ 投影时引入的误差。全局 DG 解是逐个单元构建的，从而形成一个块对角系统。我们关注单个单元内的计算。\n\n对于一个单元 $e$，函数 $f$ 到多项式空间 $V_k$ 上的 $L^2$ 投影，旨在寻找一个函数 $f_k \\in V_k$，使得对于所有测试函数 $v \\in V_k$，正交性条件 $(f - f_k, v)_{L^2(e)} = 0$ 都成立。在 $V_k$ 的节点基中展开 $f_k$，$f_k(\\xi) = \\sum_{j=0}^k \\hat{f}_j \\phi_j^{(k)}(\\xi)$，并选择测试函数为基函数本身，$v = \\phi_i^{(k)}$，可得到关于节点系数 $\\hat{\\mathbf{f}} = \\{\\hat{f}_j\\}_{j=0}^k$ 的线性方程组：\n$$\n\\sum_{j=0}^k \\left( \\int_e \\phi_i^{(k)} \\phi_j^{(k)} \\,dx \\right) \\hat{f}_j = \\int_e f \\, \\phi_i^{(k)} \\,dx, \\quad \\text{for } i=0, \\ldots, k.\n$$\n这是一个矩阵系统 $\\mathbf{M}_e \\hat{\\mathbf{f}} = \\mathbf{b}_e$，其中 $\\mathbf{M}_e$ 是单元质量矩阵，其元素为 $M_{ij} = (\\phi_i^{(k)}, \\phi_j^{(k)})_{L^2(e)}$，$\\mathbf{b}_e$ 是右端项向量，其元素为 $b_i = (f, \\phi_i^{(k)})_{L^2(e)}$。在此问题中，被投影的函数是 $f = u_N^h$，即 $u(x)$ 的 $N$ 次插值。\n\n所有积分都转换到参考单元 $\\xi \\in [-1, 1]$ 上，引入雅可比行列式 $J_e = (x_R^e - x_L^e)/2$。\n$$\nM_{ij} = J_e \\int_{-1}^1 \\phi_i^{(k)}(\\xi) \\phi_j^{(k)}(\\xi) \\,d\\xi, \\quad b_i = J_e \\int_{-1}^1 u_N^h(x(\\xi)) \\phi_i^{(k)}(\\xi) \\,d\\xi.\n$$\n函数 $u_N^h(x(\\xi))$ 本身是 $\\xi$ 的一个 $N$ 次多项式，表示为对 $N$ 次基函数的求和：$u_N^h(x(\\xi)) = \\sum_{m=0}^N u_m^{(N)} \\phi_m^{(N)}(\\xi)$，其中 $u_m^{(N)}$ 是 $u(x)$ 在 $N$ 次 GLL 节点上的节点值。\n\n三种投影方法的不同之处在于它们如何近似这些积分。\n\n**1. 对角质量投影 ($u_k^{\\mathrm{diag}}$)**\n此方法采用 $k$ 次 GLL 求积法则，该法则使用 $k+1$ 个 GLL 节点 $\\{\\xi_j^{(k)}\\}_{j=0}^k$ 作为求积点。对应的权重为 $\\{w_j^{(k)}\\}_{j=0}^k$。\n质量矩阵的元素近似为：\n$$\nM_{ij}^{\\mathrm{diag}} = J_e \\sum_{l=0}^k w_l^{(k)} \\phi_i^{(k)}(\\xi_l^{(k)}) \\phi_j^{(k)}(\\xi_l^{(k)}) = J_e \\sum_{l=0}^k w_l^{(k)} \\delta_{il} \\delta_{jl} = J_e w_i^{(k)} \\delta_{ij}.\n$$\n得到的质量矩阵是对角的。右端项为：\n$$\nb_i^{\\mathrm{diag}} = J_e \\sum_{l=0}^k w_l^{(k)} u_N^h(x(\\xi_l^{(k)})) \\phi_i^{(k)}(\\xi_l^{(k)}) = J_e w_i^{(k)} u_N^h(x(\\xi_i^{(k)})).\n$$\n系统 $\\mathbf{M}^{\\mathrm{diag}} \\hat{\\mathbf{u}}^{\\mathrm{diag}} = \\mathbf{b}^{\\mathrm{diag}}$ 的解是平凡的：\n$$\n\\hat{u}_i^{\\mathrm{diag}} = \\frac{b_i^{\\mathrm{diag}}}{M_{ii}^{\\mathrm{diag}}} = u_N^h(x(\\xi_i^{(k)})).\n$$\n这表明对角质量投影等同于简单地在目标空间的节点上对输入场 $u_N^h$ 进行求值（插值）。具有 $k+1$ 个点的 GLL 求积法则对于最高为 $2k-1$ 次的多项式是精确的。被积函数 $\\phi_i^{(k)}\\phi_j^{(k)}$ 的次数是 $2k$，因此该求积是不精确的，这是“集中”或“混叠”误差的来源。\n\n**2. 一致质量投影 ($u_k^{\\mathrm{cons}}$)**\n此方法使用一个高阶 Gauss-Legendre 求积法则，其点为 $\\{\\xi_q^{\\mathrm{cons}}\\}$，权重为 $\\{w_q^{\\mathrm{cons}}\\}$，选择该法则以确保对最高至少为 $N+k$ 次的多项式是精确的。质量矩阵的被积函数次数为 $2k$，右端项的被积函数次数为 $N+k$。求积点数 $n_{\\mathrm{cons}}$ 必须满足 $2n_{\\mathrm{cons}} - 1 \\ge N+k$，因此我们选择 $n_{\\mathrm{cons}} = \\lceil(N+k+2)/2\\rceil$。\n矩阵元素计算如下：\n$$\nM_{ij}^{\\mathrm{cons}} = J_e \\sum_q w_q^{\\mathrm{cons}} \\phi_i^{(k)}(\\xi_q^{\\mathrm{cons}}) \\phi_j^{(k)}(\\xi_q^{\\mathrm{cons}})\n$$\n$$\nb_i^{\\mathrm{cons}} = J_e \\sum_q w_q^{\\mathrm{cons}} \\left(\\sum_{m=0}^N u_m^{(N)} \\phi_m^{(N)}(\\xi_q^{\\mathrm{cons}})\\right) \\phi_i^{(k)}(\\xi_q^{\\mathrm{cons}})\n$$\n这会产生一个稠密的、对称正定的质量矩阵 $\\mathbf{M}^{\\mathrm{cons}}$，需要求解线性系统 $\\mathbf{M}^{\\mathrm{cons}} \\hat{\\mathbf{u}}^{\\mathrm{cons}} = \\mathbf{b}^{\\mathrm{cons}}$。\n\n**3. 参考投影 ($u_k^{\\mathrm{ref}}$)**\n此方法遵循与一致质量投影相同的过程，但采用一个阶数显著更高（$n_{\\mathrm{ref}}$ 个点）的求积法则，以确保积分计算达到近似精确解析结果的精度。这作为衡量其他方法的基准。\n\n**误差范数计算**\n两个投影场（例如 $u_k^A$ 和 $u_k^B$）之间的全域平方 $L^2$ 误差是单元平方误差的总和：\n$$\n\\|u_k^A - u_k^B\\|_{L^2([-1,1])}^2 = \\sum_{e=1}^E \\int_e (u_k^A - u_k^B)^2 dx.\n$$\n设 $\\Delta \\hat{\\mathbf{u}}_e = \\hat{\\mathbf{u}}_e^A - \\hat{\\mathbf{u}}_e^B$ 为单元 $e$ 上节点系数的差异。差异函数为 $\\Delta u_k(\\xi) = \\sum_j \\Delta \\hat{u}_{e,j} \\phi_j^{(k)}(\\xi)$。单元上的积分为：\n$$\n\\int_e (\\Delta u_k)^2 dx = J_e \\int_{-1}^1 \\left(\\sum_i \\Delta \\hat{u}_{e,i} \\phi_i^{(k)}(\\xi)\\right) \\left(\\sum_j \\Delta \\hat{u}_{e,j} \\phi_j^{(k)}(\\xi)\\right) d\\xi = (\\Delta \\hat{\\mathbf{u}}_e)^T \\mathbf{M}_e^{\\mathrm{ref}} (\\Delta \\hat{\\mathbf{u}}_e).\n$$\n我们使用高精度的参考质量矩阵 $\\mathbf{M}_e^{\\mathrm{ref}}$ 来进行此范数计算，如题目规定。总误差是这些单元二次型之和的平方根。\n计算过程首先准备必要的基函数和求积法则。然后，对于每个测试用例，程序遍历每个单元，计算输入函数 $u_N^h$ 的节点值，求解三个投影解 $\\hat{\\mathbf{u}}^{\\mathrm{diag}}$、$\\hat{\\mathbf{u}}^{\\mathrm{cons}}$ 和 $\\hat{\\mathbf{u}}^{\\mathrm{ref}}$，计算该单元对总平方误差的贡献，并将其累加。最后，对总和取平方根，得到所需的误差范数 $e_{\\mathrm{diff}}$、$e_{\\mathrm{cons}}$ 和 $e_{\\mathrm{diag}}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre, eval_legendre\n\ndef get_gll_nodes_weights(p):\n    \"\"\"\n    Computes the p+1 Legendre-Gauss-Lobatto nodes and weights on [-1, 1].\n    \"\"\"\n    if p == 0:\n        return np.array([0.0]), np.array([2.0])\n    if p == 1:\n        return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n    \n    # Interior nodes are roots of P_p'(x)\n    p_poly = legendre(p)\n    p_prime_poly = p_poly.deriv()\n    interior_nodes = np.sort(p_prime_poly.roots)\n    \n    nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n    \n    # Weights\n    weights = 2.0 / (p * (p + 1.0) * eval_legendre(p, nodes)**2)\n    weights[0] = weights[-1] = 2.0 / (p * (p + 1.0))\n    \n    return nodes, weights\n\ndef get_gauss_legendre_nodes_weights(n_pts):\n    \"\"\"\n    Computes n_pts Gauss-Legendre nodes and weights on [-1, 1].\n    \"\"\"\n    if n_pts == 0:\n        return np.array([]), np.array([])\n    return np.polynomial.legendre.leggauss(n_pts)\n\ndef get_lagrange_basis_matrix(eval_points, nodes):\n    \"\"\"\n    Computes the Lagrange basis matrix L_ij = phi_j(eval_points_i).\n    \"\"\"\n    n_eval = len(eval_points)\n    n_nodes = len(nodes)\n    L = np.zeros((n_eval, n_nodes))\n    for j in range(n_nodes):\n        node_j = nodes[j]\n        den = 1.0\n        for m in range(n_nodes):\n            if m != j:\n                den *= (node_j - nodes[m])\n        \n        # Avoid division by zero if eval_points are nodes themselves\n        for i in range(n_eval):\n            pt_i = eval_points[i]\n            if np.isclose(pt_i, node_j):\n                L[i,j] = 1.0\n                continue\n\n            num = 1.0\n            for m in range(n_nodes):\n                if m != j:\n                    num *= (pt_i - nodes[m])\n            L[i, j] = num / den\n    return L\n    \ndef get_legendre_poly(deg):\n    \"\"\"Returns a function for the Legendre polynomial of degree deg.\"\"\"\n    if deg == 4: # Hardcode for P4 as per test case\n      return lambda x: (35 * x**4 - 30 * x**2 + 3) / 8.0\n    # A generic implementation would be needed for other degrees\n    # This is sufficient for the provided test suite.\n    return None\n\ndef compute_projection_errors(E, N, k, u_func):\n    \"\"\"\n    Computes the L2 error norms for the three projection methods.\n    \"\"\"\n    # 1. Domain and element geometry\n    domain = [-1.0, 1.0]\n    elem_width = (domain[1] - domain[0]) / E\n    jacobian = elem_width / 2.0\n\n    # 2. Nodes, weights, and basis functions for V_N and V_k\n    nodes_N, _ = get_gll_nodes_weights(N)\n    nodes_k, _ = get_gll_nodes_weights(k)\n\n    # 3. Quadrature rules\n    # Consistent quadrature (for mass and rhs assembly)\n    n_cons = int(np.ceil((N + k + 2) / 2.0))\n    xi_cons, w_cons = get_gauss_legendre_nodes_weights(n_cons)\n\n    # Reference quadrature (for ground truth and norm calculation)\n    # This must be very high order to serve as 'exact' integration.\n    n_ref = 50 \n    xi_ref, w_ref = get_gauss_legendre_nodes_weights(n_ref)\n\n    # 4. Vandermonde-like interpolation/evaluation matrices\n    L_N_at_k = get_lagrange_basis_matrix(nodes_k, nodes_N)\n    L_k_at_cons = get_lagrange_basis_matrix(xi_cons, nodes_k)\n    L_N_at_cons = get_lagrange_basis_matrix(xi_cons, nodes_N)\n    L_k_at_ref = get_lagrange_basis_matrix(xi_ref, nodes_k)\n    L_N_at_ref = get_lagrange_basis_matrix(xi_ref, nodes_N)\n    \n    # Pre-compute matrices on reference element [-1, 1]\n    # M_cons_ref_elem = (\\phi_i, \\phi_j), integrated with cons quad\n    M_cons_ref_elem = L_k_at_cons.T @ np.diag(w_cons) @ L_k_at_cons\n    \n    # M_ref_elem = (\\phi_i, \\phi_j), integrated with ref quad\n    M_ref_elem = L_k_at_ref.T @ np.diag(w_ref) @ L_k_at_ref\n    \n    M_ref = jacobian * M_ref_elem # This is constant for all elements\n\n    total_err_diff_sq = 0.0\n    total_err_cons_sq = 0.0\n    total_err_diag_sq = 0.0\n\n    for e in range(E):\n        # a. Element-specific data\n        x_L = domain[0] + e * elem_width\n        x_R = x_L + elem_width\n        \n        # Map reference nodes to physical element\n        x_nodes_N = x_L + (nodes_N + 1.0) * jacobian\n        \n        # b. Get input field u_N^h nodal coefficients\n        u_coeffs_N = u_func(x_nodes_N)\n        \n        # c. Diagonal mass projection (interpolation)\n        u_coeffs_diag = L_N_at_k @ u_coeffs_N\n        \n        # d. Consistent mass projection\n        M_cons = jacobian * M_cons_ref_elem\n        # Interpolate u_N^h to consistent quadrature points\n        u_vals_at_cons = L_N_at_cons @ u_coeffs_N\n        f_cons = jacobian * L_k_at_cons.T @ (w_cons * u_vals_at_cons)\n        u_coeffs_cons = np.linalg.solve(M_cons, f_cons)\n\n        # e. Reference projection\n        # M_ref is already computed\n        u_vals_at_ref = L_N_at_ref @ u_coeffs_N\n        f_ref = jacobian * L_k_at_ref.T @ (w_ref * u_vals_at_ref)\n        u_coeffs_ref = np.linalg.solve(M_ref, f_ref)\n\n        # f. Compute and accumulate squared errors\n        diff_diag_cons = u_coeffs_diag - u_coeffs_cons\n        diff_cons_ref = u_coeffs_cons - u_coeffs_ref\n        diff_diag_ref = u_coeffs_diag - u_coeffs_ref\n\n        total_err_diff_sq += diff_diag_cons.T @ M_ref @ diff_diag_cons\n        total_err_cons_sq += diff_cons_ref.T @ M_ref @ diff_cons_ref\n        total_err_diag_sq += diff_diag_ref.T @ M_ref @ diff_diag_ref\n        \n    e_diff = np.sqrt(total_err_diff_sq)\n    e_cons = np.sqrt(total_err_cons_sq)\n    e_diag = np.sqrt(total_err_diag_sq)\n    \n    return e_diff, e_cons, e_diag\n\ndef solve():\n    test_cases = [\n        # E, N, k, u(x)\n        (3, 6, 3, lambda x: x**6 - 3 * x**2 + 1),\n        (4, 7, 4, lambda x: np.sin(7 * x)),\n        (2, 5, 5, lambda x: np.exp(x)),\n        (1, 8, 3, get_legendre_poly(4)),\n    ]\n\n    results = []\n    for E, N, k, u_func in test_cases:\n        e_diff, e_cons, e_diag = compute_projection_errors(E, N, k, u_func)\n        results.extend([e_diff, e_cons, e_diag])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.9e}' for r in results)}]\")\n\nsolve()\n```", "id": "3402900"}]}