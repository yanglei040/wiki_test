{"hands_on_practices": [{"introduction": "在谱方法中，选择一组性质优良的基函数至关重要。本练习从正交的勒让德多项式出发，通过缩放构建一组标准正交基，这是简化计算（例如，使质量矩阵成为单位阵）的第一步。通过这个练习，你将巩固对函数空间内积、范数以及张量积构造高维基底核心概念的理解。[@problem_id:3422988]", "problem": "考虑用于四边形和六面体单元的高阶谱方法和间断Galerkin (DG) 方法中的参考一维区间 $[-1,1]$。令 $\\{P_{n}(x)\\}_{n=0}^{\\infty}$ 表示勒让德多项式序列，它们在 $[-1,1]$ 上关于标准勒贝格测度是正交的。$L^{2}([-1,1])$ 内积定义为 $\\langle f, g \\rangle = \\int_{-1}^{1} f(x) g(x) \\, dx$。参考六面体 $[-1,1]^{3}$ 上的张量积 $L^{2}$ 内积定义为 $\\langle f, g \\rangle = \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} f(x,y,z) g(x,y,z) \\, dx \\, dy \\, dz$。勒让德多项式满足 $\\int_{-1}^{1} P_{n}(x) P_{m}(x) \\, dx = \\frac{2}{2n+1} \\delta_{nm}$ 是一个经过充分验证的事实，其中 $\\delta_{nm}$ 是克罗内克δ。\n\n从这些基础的内积定义和勒让德多项式的正交性出发，推导一个缩放关系，从 $\\{P_{n}(x)\\}_{n=0}^{\\infty}$ 生成一个 $L^{2}([-1,1])$ 标准正交基 $\\{\\phi_{n}(x)\\}_{n=0}^{\\infty}$，然后将此缩放关系扩展到参考六面体 $[-1,1]^{3}$ 上的张量积标准正交基，其形式为 $\\{\\Phi_{i j k}(x,y,z)\\}_{i,j,k \\ge 0}$，其中 $\\Phi_{i j k}(x,y,z)$ 与 $P_{i}(x) P_{j}(y) P_{k}(z)$ 成正比。分别计算将 $P_{n}(x)$ 和 $P_{i}(x) P_{j}(y) P_{k}(z)$ 缩放至单位 $L^{2}$ 范数的归一化常数 $c_{n}$ 和 $c_{i j k}$。将最终答案表示为 $c_{n}$ 和 $c_{i j k}$ 的闭式解析表达式。无需四舍五入。", "solution": "该问题经验证具有科学依据，定义明确，客观且内部一致。这是为谱方法构造标准正交基的一个标准练习，是数值分析和应用数学中的一个基本课题。因此，我们可以着手求解。\n\n目标是确定归一化常数 $c_{n}$ 和 $c_{i j k}$，这些常数将勒让德多项式 $P_{n}(x)$ 及其张量积 $P_{i}(x) P_{j}(y) P_{k}(z)$ 进行缩放，以分别在定义域 $[-1,1]$ 和 $[-1,1]^3$ 上形成标准正交基。标准正交基是指其中任意两个不同基函数的内积为零（正交性），且任意基函数与自身的内积（即其范数的平方）为一（归一性）。\n\n首先，我们考虑一维区间 $[-1,1]$ 上的情况。$L^{2}([-1,1])$ 内积由 $\\langle f, g \\rangle = \\int_{-1}^{1} f(x) g(x) \\, dx$ 给出。我们旨在从勒让德多项式序列 $\\{P_{n}(x)\\}_{n=0}^{\\infty}$ 构造一个标准正交基 $\\{\\phi_{n}(x)\\}_{n=0}^{\\infty}$。设标准正交基函数定义为 $\\phi_{n}(x) = c_{n} P_{n}(x)$，其中 $c_{n}$ 是我们需要找到的实值归一化常数。\n\n标准正交性的条件是 $\\langle \\phi_{n}, \\phi_{m} \\rangle = \\delta_{nm}$，其中 $\\delta_{nm}$ 是克罗内克δ。我们来计算这个内积：\n$$\n\\langle \\phi_{n}, \\phi_{m} \\rangle = \\langle c_{n} P_{n}, c_{m} P_{m} \\rangle = \\int_{-1}^{1} (c_{n} P_{n}(x)) (c_{m} P_{m}(x)) \\, dx = c_{n} c_{m} \\int_{-1}^{1} P_{n}(x) P_{m}(x) \\, dx\n$$\n问题给出了勒让德多项式的正交关系：$\\int_{-1}^{1} P_{n}(x) P_{m}(x) \\, dx = \\frac{2}{2n+1} \\delta_{nm}$。将此代入我们的表达式中得到：\n$$\n\\langle \\phi_{n}, \\phi_{m} \\rangle = c_{n} c_{m} \\frac{2}{2n+1} \\delta_{nm}\n$$\n为使此表达式等于 $\\delta_{nm}$，我们必须考虑 $n=m$ 的情况。当 $n \\neq m$ 时，$\\delta_{nm}=0$，正交性条件 $\\langle \\phi_{n}, \\phi_{m} \\rangle = 0$ 已经满足。对于归一化，我们要求 $\\phi_{n}(x)$ 的 $L^{2}$-范数的平方为1。平方范数为 $\\|\\phi_{n}\\|^2 = \\langle \\phi_{n}, \\phi_{n} \\rangle$。令 $m=n$，我们有：\n$$\n\\langle \\phi_{n}, \\phi_{n} \\rangle = (c_{n})^2 \\frac{2}{2n+1} \\delta_{nn} = (c_{n})^2 \\frac{2}{2n+1}\n$$\n为了归一化，我们将其设为 $1$：\n$$\n(c_{n})^2 \\frac{2}{2n+1} = 1\n$$\n求解 $c_{n}$，我们得到 $(c_{n})^2 = \\frac{2n+1}{2}$。按照惯例，我们选择正根作为归一化常数：\n$$\nc_{n} = \\sqrt{\\frac{2n+1}{2}}\n$$\n\n接下来，我们将此扩展到参考六面体 $[-1,1]^3$ 上的三维情况。张量积 $L^{2}$ 内积由 $\\langle f, g \\rangle = \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} f(x,y,z) g(x,y,z) \\, dx \\, dy \\, dz$ 给出。我们寻求一个张量积标准正交基 $\\{\\Phi_{i j k}(x,y,z)\\}_{i,j,k \\ge 0}$，其中 $\\Phi_{i j k}(x,y,z) = c_{i j k} P_{i}(x) P_{j}(y) P_{k}(z)$。常数 $c_{i j k}$ 是归一化常数。\n\n在这种多重索引设置下，标准正交性的条件是 $\\langle \\Phi_{i j k}, \\Phi_{l m n} \\rangle = \\delta_{il} \\delta_{jm} \\delta_{kn}$。和之前一样，我们通过计算基函数的平方范数来关注归一化条件，这对应于设置 $(l,m,n) = (i,j,k)$：\n$$\n\\| \\Phi_{i j k} \\|^2 = \\langle \\Phi_{i j k}, \\Phi_{i j k} \\rangle = \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} [c_{i j k} P_{i}(x) P_{j}(y) P_{k}(z)]^2 \\, dx \\, dy \\, dz\n$$\n$$\n\\| \\Phi_{i j k} \\|^2 = (c_{i j k})^2 \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} P_{i}(x)^2 P_{j}(y)^2 P_{k}(z)^2 \\, dx \\, dy \\, dz\n$$\n由于函数和定义域的张量积性质，三重积分可以分离为三个一维积分的乘积：\n$$\n\\| \\Phi_{i j k} \\|^2 = (c_{i j k})^2 \\left( \\int_{-1}^{1} P_{i}(x)^2 \\, dx \\right) \\left( \\int_{-1}^{1} P_{j}(y)^2 \\, dy \\right) \\left( \\int_{-1}^{1} P_{k}(z)^2 \\, dz \\right)\n$$\n我们可以使用勒让德多项式平方范数的一维结果 $\\int_{-1}^{1} P_{n}(x)^2 \\, dx = \\frac{2}{2n+1}$。将其应用于每个积分：\n$$\n\\| \\Phi_{i j k} \\|^2 = (c_{i j k})^2 \\left( \\frac{2}{2i+1} \\right) \\left( \\frac{2}{2j+1} \\right) \\left( \\frac{2}{2k+1} \\right) = (c_{i j k})^2 \\frac{8}{(2i+1)(2j+1)(2k+1)}\n$$\n为了归一化，我们将此平方范数设为 $1$：\n$$\n(c_{i j k})^2 \\frac{8}{(2i+1)(2j+1)(2k+1)} = 1\n$$\n求解 $c_{i j k}$，我们得到 $(c_{i j k})^2 = \\frac{(2i+1)(2j+1)(2k+1)}{8}$。同样取正根：\n$$\nc_{i j k} = \\sqrt{\\frac{(2i+1)(2j+1)(2k+1)}{8}}\n$$\n我们观察到 $c_{i j k} = \\sqrt{\\frac{2i+1}{2}} \\sqrt{\\frac{2j+1}{2}} \\sqrt{\\frac{2k+1}{2}} = c_i c_j c_k$。这证实了标准正交张量积基是由一维标准正交基函数的乘积构成的，即 $\\Phi_{i j k}(x,y,z) = \\phi_{i}(x) \\phi_{j}(y) \\phi_{k}(z)$。\n\n因此，所需的归一化常数已确定。", "answer": "$$\n\\boxed{c_n = \\sqrt{\\frac{2n+1}{2}}, \\quad c_{ijk} = \\sqrt{\\frac{(2i+1)(2j+1)(2k+1)}{8}}}\n$$", "id": "3422988"}, {"introduction": "构建基底后，下一步是在实际计算中使用它们，这通常涉及积分运算，例如计算质量矩阵和刚度矩阵。本练习将理论与实践相结合，探讨了如何使用高斯数值求积来精确计算基函数的相关积分。通过推导保证积分精度的条件，你将深入理解谱方法中数值积分的准确性对于保证算法整体精度的重要性。[@problem_id:3423027]", "problem": "考虑在参考四边形单元 $[-1,1]^{2}$ 上的谱方法设置，其张量积模态基由一维 Legendre 多项式构造。设 $\\{P_{n}(x)\\}_{n=0}^{\\infty}$ 表示 $[-1,1]$ 上的标准 Legendre 多项式，并为非负整数 $i$ 和 $j$ 定义可分离的二维基函数为 $\\phi_{i}(\\xi) = P_{i}(\\xi)$ 和 $\\phi_{j}(\\eta) = P_{j}(\\eta)$。\n\n1. 计算积分\n$$\nI_{ij} \\equiv \\int_{-1}^{1}\\int_{-1}^{1} \\phi_{i}(\\xi)\\,\\phi_{j}(\\eta)\\,d\\xi\\,d\\eta\n= \\int_{-1}^{1} P_{i}(\\xi)\\,d\\xi \\;\\int_{-1}^{1} P_{j}(\\eta)\\,d\\eta,\n$$\n并将您的最终结果表示为关于 $i$ 和 $j$ 的闭式解析表达式。\n\n2. 考虑使用在每个坐标方向上具有 $p$ 个点的张量积 Gauss-Legendre 求积法来计算 $I_{ij}$。从一维 Gauss-Legendre 求积的精确性出发，推导出保证二维张量求积法能精确计算 $I_{ij}$ 的关于 $p$ 的最小条件（用 $i$ 和 $j$ 表示），并验证在此条件下，该求积法能够再现您的解析结果。\n\n无需四舍五入。将第 1 部分的最终答案报告为精确的符号表达式。", "solution": "该问题由两部分组成。首先，我们必须计算积分 $I_{ij}$ 的精确值。其次，我们必须确定张量积 Gauss-Legendre 求积法能精确计算此积分的条件。\n\n第 1 部分：$I_{ij}$ 的解析计算\n\n需要计算的积分如下：\n$$\nI_{ij} = \\int_{-1}^{1}\\int_{-1}^{1} \\phi_{i}(\\xi)\\,\\phi_{j}(\\eta)\\,d\\xi\\,d\\eta\n$$\n其中 $\\phi_{i}(\\xi) = P_{i}(\\xi)$ 且 $\\phi_{j}(\\eta) = P_{j}(\\eta)$，$P_k(x)$ 是在区间 $[-1, 1]$ 上的 $k$ 次标准 Legendre 多项式。索引 $i$ 和 $j$ 是非负整数。\n由于被积函数的可分离性和矩形积分域，该积分可以写成两个一维积分的乘积：\n$$\nI_{ij} = \\left( \\int_{-1}^{1} P_{i}(\\xi)\\,d\\xi \\right) \\left( \\int_{-1}^{1} P_{j}(\\eta)\\,d\\eta \\right)\n$$\n为了计算 $I_{ij}$，我们首先需要计算对于非负整数 $k$ 的一般积分 $\\int_{-1}^{1} P_k(x)\\,dx$。我们可以利用 Legendre 多项式的正交性来做到这一点。标准的正交关系是\n$$\n\\int_{-1}^{1} P_m(x) P_n(x) \\,dx = \\frac{2}{2n+1} \\delta_{mn}\n$$\n其中 $\\delta_{mn}$ 是 Kronecker delta，如果 $m=n$ 则为 $1$，否则为 $0$。\n\n我们可以将常数函数 $1$ 表示为零次 Legendre 多项式，$P_0(x) = 1$。因此，我们希望计算的积分可以写成：\n$$\n\\int_{-1}^{1} P_k(x)\\,dx = \\int_{-1}^{1} P_k(x) P_0(x) \\,dx\n$$\n应用 $m=k$ 和 $n=0$ 的正交关系，我们得到：\n$$\n\\int_{-1}^{1} P_k(x) P_0(x) \\,dx = \\frac{2}{2(0)+1} \\delta_{k0} = 2 \\delta_{k0}\n$$\n这个结果表明，如果 $k=0$，积分等于 $2$；如果 $k \\neq 0$，积分等于 $0$。由于 $k$ 是一个非负整数，这意味着对于所有 $k \\ge 1$，积分为 $0$。\n\n现在我们可以将这个结果代回到 $I_{ij}$ 的表达式中。这两个一维积分是：\n$$\n\\int_{-1}^{1} P_{i}(\\xi)\\,d\\xi = 2 \\delta_{i0}\n$$\n$$\n\\int_{-1}^{1} P_{j}(\\eta)\\,d\\eta = 2 \\delta_{j0}\n$$\n将这两个结果相乘得到 $I_{ij}$ 的值：\n$$\nI_{ij} = (2 \\delta_{i0}) (2 \\delta_{j0}) = 4 \\delta_{i0} \\delta_{j0}\n$$\n两个 Kronecker delta 的乘积 $\\delta_{i0} \\delta_{j0}$ 仅在 $i=0$ 且 $j=0$ 时等于 $1$。如果 $i \\neq 0$ 或 $j \\neq 0$，乘积为 $0$。因此，我们可以将结果表示为：\n$$\nI_{ij} = \\begin{cases} 4  \\text{若 } i=0 \\text{ 且 } j=0 \\\\ 0  \\text{其他情况} \\end{cases}\n$$\n这是 $I_{ij}$ 的闭式解析表达式。\n\n第 2 部分：精确求积的条件\n\n现在我们考虑使用在每个坐标方向上具有 $p$ 个点的张量积 Gauss-Legendre 求积法来计算 $I_{ij}$。一维 $p$ 点 Gauss-Legendre 求积法则将 $[-1, 1]$ 上的积分近似为加权和：\n$$\n\\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{k=1}^{p} w_k f(x_k)\n$$\n其中 $x_k$ 是 $P_p(x)$ 的根，$w_k$ 是相应的求积权重。该法则的一个基本性质是，它对于次数最高为 $2p-1$ 的任何多项式 $f(x)$ 都是精确的。也就是说，如果 $\\deg(f) \\le 2p-1$，则该近似是等式。\n\n$I_{ij}$ 的二维张量积求积法则由下式给出：\n$$\nI_{ij}^{quad} = \\sum_{k=1}^{p} \\sum_{l=1}^{p} w_k w_l P_i(\\xi_k) P_j(\\eta_l) = \\left(\\sum_{k=1}^{p} w_k P_i(\\xi_k)\\right) \\left(\\sum_{l=1}^{p} w_l P_j(\\eta_l)\\right)\n$$\n为使这个二维求积法精确，即 $I_{ij}^{quad} = I_{ij}$，两个一维求积和都必须是其对应积分的精确表示。\n1. 第一个和必须精确：\n$$\n\\sum_{k=1}^{p} w_k P_i(\\xi_k) = \\int_{-1}^{1} P_i(\\xi)\\,d\\xi\n$$\n如果被积函数 $P_i(\\xi)$ 的次数小于或等于 $2p-1$，这是成立的。$P_i(\\xi)$ 的次数是 $i$。因此，我们要求 $i \\le 2p-1$。\n\n2. 第二个和必须精确：\n$$\n\\sum_{l=1}^{p} w_l P_j(\\eta_l) = \\int_{-1}^{1} P_j(\\eta)\\,d\\eta\n$$\n类似地，被积函数 $P_j(\\eta)$ 的次数是 $j$。如果 $j \\le 2p-1$，此等式成立。\n\n为使张量积求积法对 $I_{ij}$ 精确，两个条件必须同时成立：\n$$\ni \\le 2p-1 \\quad \\text{且} \\quad j \\le 2p-1\n$$\n这等价于要求两个次数的最大值满足该条件：\n$$\n\\max(i, j) \\le 2p-1\n$$\n为了找到关于 $p$ 的最小条件，我们对 $p$ 解这个不等式：\n$$\n2p \\ge \\max(i, j) + 1 \\implies p \\ge \\frac{\\max(i, j) + 1}{2}\n$$\n由于 $p$ 必须是整数，所需的最小求积点数是大于或等于右侧的最小整数。这可以用上取整函数表示：\n$$\np_{min} = \\left\\lceil \\frac{\\max(i, j) + 1}{2} \\right\\rceil\n$$\n这是保证精确性的关于 $p$ 的最小条件。\n\n最后，我们必须验证在此条件下，求积法能够再现第 1 部分的解析结果。\n如果条件 $p \\ge (\\max(i, j) + 1)/2$ 满足，那么根据 Gauss-Legendre 求积法的精确性定义，我们有：\n$$\nI_{ij}^{quad} = \\left(\\sum_{k=1}^{p} w_k P_i(\\xi_k)\\right) \\left(\\sum_{l=1}^{p} w_l P_j(\\eta_l)\\right) = \\left( \\int_{-1}^{1} P_i(\\xi)\\,d\\xi \\right) \\left( \\int_{-1}^{1} P_j(\\eta)\\,d\\eta \\right)\n$$\n右侧恰好是 $I_{ij}$ 的定义。正如我们在第 1 部分计算的，这个值是 $4 \\delta_{i0} \\delta_{j0}$。因此，在推导出的关于 $p$ 的最小条件下，求积法保证是精确的，并能再现解析结果。验证完成。", "answer": "$$\n\\boxed{4\\delta_{i0}\\delta_{j0}}\n$$", "id": "3423027"}, {"introduction": "理论概念最终要应用于模拟真实物理问题的复杂几何构型上，这需要从参考单元映射到物理单元。本练习是一个综合性的编程实践，旨在揭示张量积结构在坐标变换下的行为。你将通过编程验证，对于简单的仿射映射，微分算子可以完美地分解为一系列高效的一维运算，但对于弯曲单元，这种优雅的分解性被破坏，必须处理更复杂的度量张量。[@problem_id:3422992]", "problem": "考虑在四边形和六面体单元上，用于张量积谱方法和间断 Galerkin 方法的强形式离散拉普拉斯残差。设参考单元为超立方体 $[-1,1]^d$，其维度 $d \\in \\{2,3\\}$。沿每个参考坐标使用多项式阶数为 $N$ 的 Legendre–Gauss–Lobatto (LGL) 节点，以及在这些节点上插值的张量积拉格朗日基。在物理坐标中定义一个构造的可分离解 $u(x,y,z)=f(x)g(y)h(z)$，其中 $f(x)=\\sin(\\pi x)$，$g(y)=\\cos(2\\pi y)$ 和 $h(z)=\\exp(z)$，所有角度均以弧度为单位。\n\n给定一个从参考坐标 $(r,s,t)$ 到物理坐标 $(x,y,z)$ 的等参数映射 $\\boldsymbol{x}(r,s,t)$。将雅可比矩阵记为 $J=\\partial\\boldsymbol{x}/\\partial(r,s,t)$，其行列式记为 $|J|$，逆变度量张量记为 $G=J^{-1}J^{-T}$。节点上的变换后强形式拉普拉斯残差为\n$$\nR = \\frac{1}{|J|}\\sum_{a=1}^d \\frac{\\partial}{\\partial \\xi_a}\\left(|J|\\sum_{b=1}^d G^{ab}\\frac{\\partial u}{\\partial \\xi_b}\\right),\n$$\n其中 $(\\xi_1,\\xi_2,\\xi_3)=(r,s,t)$ 且 $(G^{ab})$ 是 $G$ 的分量。导数 $\\partial/\\partial \\xi_a$ 通过与 LGL 节点相关联的一维微分矩阵 $D$ 进行离散化；在多维情况下，沿每个轴使用 $D$ 的张量积。沿一个轴的二阶导数通过在该轴上施加两次 $D$ 来实现。\n\n在仿射对角映射下（例如，$x=\\alpha_x r+\\beta_x$, $y=\\alpha_y s+\\beta_y$, $z=\\alpha_z t+\\beta_z$，其中 $\\alpha_x,\\alpha_y,\\alpha_z$ 为常数，且无交叉依赖），雅可比矩阵和度量张量是常数对角阵，离散残差可张量化：如果 $F(r)=f(x(r))$, $G(s)=g(y(s))$, $H(t)=h(z(t))$，则\n$$\nR_{\\text{split}} = \\left(\\frac{\\partial^2 F}{\\partial r^2}\\frac{1}{\\alpha_x^2}\\right)G(s)H(t) + F(r)\\left(\\frac{\\partial^2 G}{\\partial s^2}\\frac{1}{\\alpha_y^2}\\right)H(t) + F(r)G(s)\\left(\\frac{\\partial^2 H}{\\partial t^2}\\frac{1}{\\alpha_z^2}\\right),\n$$\n其中二阶导数通过沿相应轴的 $D^2$ 进行离散化。这种构造仅涉及一维运算，并且是跨轴分离的。\n\n在弯曲映射（非仿射，带有如 $x=x(r,s,t)$ 这类依赖于多个参考坐标的交叉项）上，$J$、$|J|$ 和 $G$ 逐点变化，并可能含有非对角分量。在这种情况下，离散残差通常不等于上述由一维二阶导数乘以局部对角链式法则因子（例如 $1/x_r^2$, $1/y_s^2$, $1/z_t^2$）所构建的 $R_{\\text{split}}$，因为来自非对角度量项和映射导数的额外贡献会进入 $R$。\n\n您的任务是编写一个程序，该程序：\n- 为指定的阶数构建 LGL 节点和一维微分矩阵 $D$。\n- 对每个映射，在张量积节点上计算构造解 $u(x,y,z)$ 的值。\n- 使用变换后的强形式以及逐点变化的 $|J|$ 和 $G$ 来计算完整离散残差 $R$。\n- 仅使用沿相应因子的每个轴的一维二阶导数，并按链式法则对角因子进行缩放，来计算分离残差 $R_{\\text{split}}$；对于二维情况，省略与 z 相关的项。\n\n使用以下映射和参数的测试套件。在所有情况下，三角函数的角度必须以弧度为单位：\n1. 二维仿射对角映射：$x=1.1\\,r+0.3$, $y=0.9\\,s-0.2$，多项式阶数为 $N=10$。检查 $\\|R-R_{\\text{split}}\\|_2/\\|R\\|_2 \\leq 10^{-9}$。\n2. 三维仿射对角映射：$x=0.7\\,r-0.1$, $y=1.2\\,s+0.05$, $z=0.8\\,t+0.02$，多项式阶数为 $N=8$。检查 $\\|R-R_{\\text{split}}\\|_2/\\|R\\|_2 \\leq 10^{-8}$。\n3. 二维弯曲映射：$x=1.0\\,r+0.4+0.3\\,r\\,s$, $y=0.8\\,s-0.1+0.2\\,r^2$，多项式阶数为 $N=10$。检查 $\\|R-R_{\\text{split}}\\|_2/\\|R\\|_2 \\geq 5\\times 10^{-4}$。\n4. 三维弯曲映射：$x=0.9\\,r+0.1+0.2\\,r\\,s$, $y=1.0\\,s-0.2+0.2\\,s\\,t$, $z=0.95\\,t+0.05+0.2\\,r\\,t$，多项式阶数为 $N=7$。检查 $\\|R-R_{\\text{split}}\\|_2/\\|R\\|_2 \\geq 5\\times 10^{-4}$。\n\n对于每种情况，通过评估指定的不等式来产生一个布尔结果。您的程序应产生单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，“[true,false,true,false]”）。输出必须是小写字母，并且必须是布尔类型（而非字符串）。\n\n除了对三角函数的弧度规定外，不需要其他物理单位。所有计算都纯粹是数值计算，在参考单元及其到物理空间的映射上进行。\n\n最终输出格式必须是与测试套件案例顺序对应的、包含四个布尔结果列表的单行。", "solution": "用户提供的问题经评估有效。该问题科学上基于偏微分方程数值分析的原理，特别是谱方法和间断 Galerkin 方法。问题是适定的、客观的，并包含进行计算求解所需的所有必要信息。未检测到不一致、歧义或事实错误。\n\n在此，提供一个全面的解决方案，详细说明解决该问题所需的理论背景和计算步骤。\n\n### 1. 理论框架\n\n该问题涉及在物理空间中的一般四边形或六面体单元上对拉普拉斯算子 $\\nabla^2 u$ 进行离散化。这是通过将一个简单的参考单元，即超立方体 $\\mathcal{E}_{\\text{ref}} = [-1,1]^d$（其中 $d \\in \\{2,3\\}$），使用等参数映射 $\\boldsymbol{x}(\\boldsymbol{\\xi})$ 映射到物理单元来实现的，其中 $\\boldsymbol{x}=(x,y,z)$ 是物理坐标，$\\boldsymbol{\\xi}=(r,s,t)$ 是参考坐标。\n\n#### 1.1. 参考单元上的谱离散化\n\n我们使用基于一维 Legendre-Gauss-Lobatto (LGL) 点的张量积的节点谱方法。对于给定的多项式阶数 $N$，这 $N+1$ 个 LGL 节点 $\\{\\xi_j\\}_{j=0}^N$ 是 $(1-\\xi^2)P'_N(\\xi)$ 的零点，其中 $P_N$ 是 $N$ 阶 Legendre 多项式。这些节点包括端点 $\\xi_0 = -1$ 和 $\\xi_N = 1$。\n\n$[-1,1]$ 上的函数 $f(\\xi)$ 由其在这些节点处的值 $f_j = f(\\xi_j)$ 表示。其导数可以通过使用一个微分矩阵 $D$ 进行代数计算。函数在节点处的导数由矩阵向量乘积给出：\n$$\n\\left. \\frac{df}{d\\xi} \\right|_{\\xi_j} \\approx \\sum_{k=0}^N D_{jk} f_k\n$$\n$(N+1) \\times (N+1)$ 微分矩阵 $D$ 的项由以下公式给出：\n$$\nD_{jk} = \n\\begin{cases}\n\\frac{P_N(\\xi_j)}{P_N(\\xi_k)(\\xi_j - \\xi_k)}  j \\neq k \\\\\n-\\frac{N(N+1)}{4}  j=k=0 \\\\\n\\frac{N(N+1)}{4}  j=k=N \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n二阶导数通过施加两次矩阵来近似，即使用 $D^2 = D \\cdot D$。在多维情况下（$d>1$），节点形成张量积网格，导数通过沿相应轴应用一维微分矩阵来计算。对于二维网格上的函数 $F(r,s)$，偏导数计算为 $(D \\cdot F^T)^T$（对于 $\\partial/\\partial r$）和 $F \\cdot D^T$（对于 $\\partial/\\partial s$），或更普遍地使用张量缩并。\n\n#### 1.2. 变换后的拉普拉斯算子（完整残差 $R$）\n\n物理坐标 $(x,y,z)$ 中的拉普拉斯算子根据以下公式变换到参考坐标 $(r,s,t)$：\n$$\n\\nabla^2 u = \\frac{1}{|J|} \\sum_{a=1}^d \\frac{\\partial}{\\partial \\xi_a} \\left( |J| \\sum_{b=1}^d G^{ab} \\frac{\\partial u}{\\partial \\xi_b} \\right)\n$$\n这里，$\\boldsymbol{\\xi} = (\\xi_1, \\xi_2, \\xi_3) = (r,s,t)$，$J = \\frac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{\\xi}}$ 是映射的雅可比矩阵，$|J|$ 是其行列式，$G = J^{-1}J^{-T}$ 是逆变度量张量。右手边的表达式是要计算的量 $R$。\n\n在张量积 LGL 节点上计算 $R$ 的过程如下：\n1.  在参考网格 $\\boldsymbol{\\xi}_{ijk}$ 的所有节点上计算物理坐标 $\\boldsymbol{x}$。\n2.  通过使用谱微分矩阵 $D$ 对映射函数进行微分（例如，$x_r = \\partial x/\\partial r$, $x_s = \\partial x/\\partial s$ 等），计算每个节点处的雅可比矩阵 $J$ 的分量。由于映射可以是非线性的，$J$（以及 $|J|$ 和 $G$）将逐点变化。\n3.  在每个节点处，通过对 $J$求逆来计算行列式 $|J|$ 和度量张量 $G$。\n4.  在每个节点的物理坐标处计算构造解 $u(x,y,z)$。\n5.  使用矩阵 $D$ 计算解在参考坐标中的导数 $\\partial u/\\partial \\xi_b$。\n6.  在每个节点处形成通量分量 $F_a = |J| \\sum_{b=1}^d G^{ab} (\\partial u / \\partial \\xi_b)$。\n7.  再次使用矩阵 $D$ 计算通量的散度 $\\sum_{a=1}^d \\partial F_a/\\partial \\xi_a$。\n8.  最后，通过将第7步的结果除以每个节点处的 $|J|$ 来获得离散残差 $R$。\n\n#### 1.3. 分离近似（分离残差 $R_{\\text{split}}$）\n\n$R_{\\text{split}}$ 是拉普拉斯算子的简化近似，它忽略了由弯曲、非正交映射产生的几何复杂性。\n\n对于**仿射对角映射**，例如 $x=\\alpha_x r+\\beta_x$ 和 $y=\\alpha_y s+\\beta_y$，雅可比矩阵和度量张量是常数对角阵。具体来说，$J = \\text{diag}(\\alpha_x, \\alpha_y, \\alpha_z)$，$|J| = \\alpha_x\\alpha_y\\alpha_z$，$G = \\text{diag}(\\alpha_x^{-2}, \\alpha_y^{-2}, \\alpha_z^{-2})$。在这种特殊情况下，变换后的拉普拉斯算子简化为沿每个轴的缩放二阶导数之和：\n$$\n\\nabla^2 u = \\frac{1}{\\alpha_x^2} \\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{\\alpha_y^2} \\frac{\\partial^2 u}{\\partial s^2} + \\frac{1}{\\alpha_z^2} \\frac{\\partial^2 u}{\\partial t^2}\n$$\n对于给定的可分离解 $u(x,y,z) = f(x)g(y)h(z)$，在此映射下变为 $u(x(r), y(s), z(t)) = F(r)G(s)H(t)$，残差可以完美地张量化。项 $\\partial^2 u / \\partial r^2$ 变为 $(\\partial^2 F/\\partial r^2) G(s) H(t)$。这导致了问题描述中给出的 $R_{\\text{split}}$ 公式，该公式对于此映射类型是精确的。\n\n对于**一般弯曲映射**，问题将 $R_{\\text{split}}$ 定义为扩展了仿射情况逻辑的近似。它通过忽略所有非对角度量项（$a \\neq b$ 时的 $G^{ab}$）和所有几何因子（$|J|$ 和 $G^{ab}$）的导数来构造。它仅保留了链式法则中的对角缩放，$1/(\\partial x/\\partial r)^2$, $1/(\\partial y/\\partial s)^2$ 等，这些现在是位置相关的。“沿相应因子的每个轴的一维二阶导数”意味着对于 $u=f(x)g(y)h(z)$ 采用以下构造：\n$$\nR_{\\text{split}} = \\frac{g(y)h(z)}{(\\partial x/\\partial r)^2} \\frac{\\partial^2 f(x(r,s,t))}{\\partial r^2} + \\frac{f(x)h(z)}{(\\partial y/\\partial s)^2} \\frac{\\partial^2 g(y(r,s,t))}{\\partial s^2} + \\frac{f(x)g(y)}{(\\partial z/\\partial t)^2} \\frac{\\partial^2 h(z(r,s,t))}{\\partial t^2}\n$$\n其中所有导数都使用 $D$ 和 $D^2$ 进行谱计算。这种形式是一种近似，因为它省略了交叉导数项（例如 $\\partial^2 u / \\partial r \\partial s$）和由几何非均匀性产生的项（例如 $\\partial G^{ab}/\\partial \\xi_c$）。\n\n### 2. 计算方法\n\n该解决方案以 Python 脚本的形式实现，对每个测试用例执行以下步骤：\n\n1.  **设置**：定义一个函数 `lgl_diff_matrix(N)` 来计算给定阶数 $N$ 的 LGL 节点和一维微分矩阵 $D$。创建一个辅助函数 `spec_deriv(field, axis, D)`，用于沿指定轴将微分矩阵应用于多维数组。构建参考坐标网格 $\\boldsymbol{\\xi}$。\n2.  **映射和求解**：根据当前测试用例的映射，在网格上计算物理坐标 $\\boldsymbol{x}(\\boldsymbol{\\xi})$。然后在这些物理坐标处计算构造解 $u(\\boldsymbol{x})$。\n3.  **计算 $R$**：按照第 1.2 节中的程序计算完整残差 $R$。这涉及尽可能使用矢量化操作：\n    *   使用 `spec_deriv` 计算映射导数（例如 $x_r, x_s, ...$）。\n    *   将每个网格点处的雅可比矩阵 $J$ 组装成一个多维数组（例如，对于2D，形状为 `(N+1, N+1, 2, 2)`）。\n    *   使用 `numpy.linalg.det` 和 `numpy.linalg.inv` 在整个网格上计算 $|J|$ 和 $G$。\n    *   使用 `spec_deriv` 计算解的导数（$\\partial u/\\partial r$ 等）和通量导数。\n    *   根据 $R$ 的公式组合所有项。\n4.  **计算 $R_{\\text{split}}$**：计算分离残差 $R_{\\text{split}}$。\n    *   对于仿射情况，创建一维函数 `F(r)`, `G(s)`, `H(t)`，使用 $D^2$ 计算它们的二阶导数，进行缩放，并通过张量积（例如 `numpy.outer` 或广播）进行组合。\n    *   对于弯曲情况，使用第 1.3 节中的构造。在整个网格上定义因子 $f(x)$、$g(y)$ 和 $h(z)$。使用 `spec_deriv` 计算它们各自的二阶导数（例如 $\\partial^2 f/\\partial r^2$）和所需的映射导数（例如 $\\partial x/\\partial r$），然后进行组合。\n5.  **比较与验证**：计算差值的相对 L2-范数 $\\|R-R_{\\text{split}}\\|_2/\\|R\\|_2$。将结果与测试用例中指定的不等式进行比较，得出一个布尔值。\n6.  **输出**：收集所有四个测试用例的布尔结果，并以指定的列表格式打印。\n\n此过程正确地区分了算子的精确数学变换和常见的简化方法，验证了该简化仅对几何简单（仿射对角）的映射有效。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi, eval_legendre\n\ndef lgl_diff_matrix(N):\n    \"\"\"\n    Computes the (N+1)x(N+1) LGL differentiation matrix and nodes.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0]), np.array([[0.0]])\n    \n    # Use roots of Jacobi polynomial P_{N-1}^{(1,1)} for internal nodes\n    jacobi_roots, _ = roots_jacobi(N - 1, 1, 1)\n    nodes = np.concatenate(([-1.0], jacobi_roots, [1.0]))\n\n    # Legendre polynomials at nodes\n    PN_vals = eval_legendre(N, nodes)\n\n    # Differentiation matrix\n    D = np.zeros((N + 1, N + 1))\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = PN_vals[i] / (PN_vals[j] * (nodes[i] - nodes[j]))\n            elif i == 0:\n                D[i, i] = -N * (N + 1) / 4.0\n            elif i == N:\n                D[i, i] = N * (N + 1) / 4.0\n            else:\n                D[i, i] = 0.0\n    return nodes, D\n\ndef spec_deriv(F, axis, D):\n    \"\"\"\n    Computes the spectral derivative of a d-dimensional array F along a given axis.\n    \"\"\"\n    d = F.ndim\n    if axis  0 or axis >= d:\n        raise ValueError(\"Invalid axis\")\n    \n    # Permute the interested axis to the front\n    F_perm = np.moveaxis(F, axis, 0)\n    original_shape = F_perm.shape\n    \n    # Reshape for matrix multiplication\n    F_reshaped = F_perm.reshape(original_shape[0], -1)\n    \n    # Apply differentiation matrix\n    DF_reshaped = D @ F_reshaped\n    \n    # Reshape back to permuted shape\n    DF_perm = DF_reshaped.reshape(original_shape)\n    \n    # Permute axis back to original position\n    result = np.moveaxis(DF_perm, 0, axis)\n    \n    return result\n\ndef solve():\n    test_cases = [\n        {\n            'd': 2, 'N': 10,\n            'map': lambda r, s, t: (1.1 * r + 0.3, 0.9 * s - 0.2, None),\n            'map_params': {'ax': 1.1, 'ay': 0.9, 'az':None, 'beta_x': 0.3, 'beta_y': -0.2, 'beta_z':None},\n            'check': lambda err: err = 1e-9,\n            'is_affine_diag': True\n        },\n        {\n            'd': 3, 'N': 8,\n            'map': lambda r, s, t: (0.7 * r - 0.1, 1.2 * s + 0.05, 0.8 * t + 0.02),\n            'map_params': {'ax': 0.7, 'ay': 1.2, 'az': 0.8, 'beta_x': -0.1, 'beta_y': 0.05, 'beta_z': 0.02},\n            'check': lambda err: err = 1e-8,\n            'is_affine_diag': True\n        },\n        {\n            'd': 2, 'N': 10,\n            'map': lambda r, s, t: (1.0 * r + 0.4 + 0.3 * r * s, 0.8 * s - 0.1 + 0.2 * r**2, None),\n            'map_params': None,\n            'check': lambda err: err >= 5e-4,\n            'is_affine_diag': False\n        },\n        {\n            'd': 3, 'N': 7,\n            'map': lambda r, s, t: (0.9 * r + 0.1 + 0.2 * r * s, 1.0 * s - 0.2 + 0.2 * s * t, 0.95 * t + 0.05 + 0.2 * r * t),\n            'map_params': None,\n            'check': lambda err: err >= 5e-4,\n            'is_affine_diag': False\n        }\n    ]\n\n    results = []\n    \n    # Manufactured solution functions\n    f_sol = lambda x: np.sin(np.pi * x)\n    g_sol = lambda y: np.cos(2 * np.pi * y)\n    h_sol = lambda z: np.exp(z)\n\n    for case in test_cases:\n        N, d = case['N'], case['d']\n        nodes, D = lgl_diff_matrix(N)\n        D2 = D @ D\n        \n        # Create grid\n        if d == 2:\n            r, s = np.meshgrid(nodes, nodes, indexing='ij')\n            t = None\n        else: # d == 3\n            r, s, t = np.meshgrid(nodes, nodes, nodes, indexing='ij')\n\n        # Physical coordinates and solution\n        x, y, z = case['map'](r, s, t)\n        \n        if d == 2:\n            u = f_sol(x) * g_sol(y)\n        else:\n            u = f_sol(x) * g_sol(y) * h_sol(z)\n            \n        # --- Compute Full Residual R ---\n        coords = (x, y, z) if d == 3 else (x, y)\n        J = np.zeros(list(r.shape) + [d, d])\n        \n        for i in range(d): # physical coord index\n            for j in range(d): # reference coord index\n                J[..., i, j] = spec_deriv(coords[i], j, D)\n        \n        detJ = np.linalg.det(J)\n        invJ = np.linalg.inv(J)\n        G = np.einsum('...ij,...kj->...ik', invJ, invJ)\n        \n        u_derivs = [spec_deriv(u, i, D) for i in range(d)]\n        \n        flux = np.zeros(list(r.shape) + [d])\n        for i in range(d):\n            for j in range(d):\n                flux[..., i] += G[..., i, j] * u_derivs[j]\n        flux *= detJ[..., np.newaxis]\n        \n        div_flux = np.zeros_like(r)\n        for i in range(d):\n            div_flux += spec_deriv(flux[..., i], i, D)\n            \n        R = div_flux / detJ\n\n        # --- Compute Split Residual R_split ---\n        if case['is_affine_diag']:\n            ax = case['map_params']['ax']\n            ay = case['map_params']['ay']\n            beta_x = case['map_params']['beta_x']\n            beta_y = case['map_params']['beta_y']\n            \n            F_1d = f_sol(ax * nodes + beta_x)\n            G_1d = g_sol(ay * nodes + beta_y)\n            \n            F_rr_1d = D2 @ F_1d\n            G_ss_1d = D2 @ G_1d\n            \n            if d == 2:\n                term1 = np.outer(F_rr_1d / (ax**2), G_1d)\n                term2 = np.outer(F_1d, G_ss_1d / (ay**2))\n                R_split = term1 + term2\n            else: # d == 3\n                az = case['map_params']['az']\n                beta_z = case['map_params']['beta_z']\n                H_1d = h_sol(az * nodes + beta_z)\n                H_tt_1d = D2 @ H_1d\n                \n                term1 = (F_rr_1d/ax**2)[:,None,None] * G_1d[None,:,None] * H_1d[None,None,:]\n                term2 = F_1d[:,None,None] * (G_ss_1d/ay**2)[None,:,None] * H_1d[None,None,:]\n                term3 = F_1d[:,None,None] * G_1d[None,:,None] * (H_tt_1d/az**2)[None,None,:]\n                R_split = term1 + term2 + term3\n        else: # Curved map\n            f_factor = f_sol(x)\n            g_factor = g_sol(y)\n\n            xr = spec_deriv(x, 0, D)\n            ys = spec_deriv(y, 1, D)\n            if d==3: zt = spec_deriv(z, 2, D)\n            \n            f_rr = spec_deriv(spec_deriv(f_factor, 0, D), 0, D)\n            g_ss = spec_deriv(spec_deriv(g_factor, 1, D), 1, D)\n\n            if d == 2:\n                term1 = f_rr * g_factor / (xr**2)\n                term2 = f_factor * g_ss / (ys**2)\n                R_split = term1 + term2\n            else: # d == 3\n                h_factor = h_sol(z)\n                h_tt = spec_deriv(spec_deriv(h_factor, 2, D), 2, D)\n                term1 = f_rr * g_factor * h_factor / (xr**2)\n                term2 = f_factor * g_ss * h_factor / (ys**2)\n                term3 = f_factor * g_factor * h_tt / (zt**2)\n                R_split = term1 + term2 + term3\n        \n        # --- Comparison ---\n        norm_R = np.linalg.norm(R)\n        if norm_R  1e-15:\n            norm_diff = np.linalg.norm(R - R_split)\n            relative_error = norm_diff if norm_diff > 1e-15 else 0.0\n        else:\n            relative_error = np.linalg.norm(R - R_split) / norm_R\n        \n        results.append(case['check'](relative_error))\n\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```", "id": "3422992"}]}