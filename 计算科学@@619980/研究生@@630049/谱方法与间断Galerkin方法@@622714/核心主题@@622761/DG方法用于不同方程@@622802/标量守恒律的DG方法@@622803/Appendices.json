{"hands_on_practices": [{"introduction": "稳定性是偏微分方程数值方法的基石。对于间断Galerkin (DG) 方法，单元交界面上数值通量的选择对确保稳定性至关重要。本练习将指导您推导半离散 $L^2$ 能量演化方程 [@problem_id:3377133]。通过对中心通量、迎风通量和Lax-Friedrichs通量等不同通量进行推导，您将从根本上理解数值耗散是如何被引入的，以及为何它对于双曲问题的稳定计算至关重要。", "problem": "考虑在周期性区域 $\\Omega = [0,1]$ 上的常系数标量守恒律 $u_{t} + a \\, u_{x} = 0$。该区域被均匀剖分为 $N$ 个闭区间 $\\{K_{j}\\}_{j=1}^{N}$，每个区间都通过仿射映射到参考区间 $[-1,1]$。设 $p \\ge 1$ 为一个固定的多项式阶数，并设 $u_{h}$ 为在分片多项式空间 $\\mathbb{P}^{p}(K_{1}) \\oplus \\cdots \\oplus \\mathbb{P}^{p}(K_{N})$ 中的半离散间断 Galerkin (DG) 近似。比较两种 DG 格式：\n- 使用 Gauss–Lobatto 点和求积的节点格式，以及\n- 使用 Legendre 多项式基和精确积分的模态格式。\n\n对每种格式，使用通过在每个单元上进行分部积分并将单元交界面处的物理通量替换为数值通量而得到的 DG 弱形式。假设多项式项的求积是精确的，以便为所选离散化成立的任何离散分部求和 (SBP) 恒等式在离散层面上都能实现。考虑以下交界面数值通量：\n- 中心通量 $\\widehat{f}_{\\mathrm{c}}(u^{-},u^{+}) = a \\,\\{\\!\\{u\\}\\!\\}$，\n- 当 $a>0$ 时为迎风通量 $\\widehat{f}_{\\mathrm{u}}(u^{-},u^{+}) = a \\, u^{-}$，当 $a<0$ 时为 $\\widehat{f}_{\\mathrm{u}}(u^{-},u^{+}) = a \\, u^{+}$，\n- Lax–Friedrichs 通量 $\\widehat{f}_{\\mathrm{LF}}(u^{-},u^{+}) = a \\,\\{\\!\\{u\\}\\!\\} - \\tfrac{\\alpha}{2}\\,[u]$，其中参数 $\\alpha \\ge |a|$。\n\n此处，跳跃项和平均值由 $[u] = u^{+} - u^{-}$ 和 $\\{\\!\\{u\\}\\!\\} = \\tfrac{1}{2}(u^{-}+u^{+})$ 给出。设 $\\|\\cdot\\|_{L^{2}(\\Omega)}$ 表示周期性区域上的 $L^{2}$ 范数。\n\n从 DG 弱形式和上述定义出发，为每种数值通量以及 nodal Gauss–Lobatto 和 modal Legendre 两种格式，推导半离散 $L^{2}$ 能量演化公式 $\\tfrac{d}{dt}\\|u_{h}\\|_{L^{2}(\\Omega)}^{2}$。仅使用诸如分部积分和离散情况下的 SBP 性质等基本恒等式，不要假设任何预先推导的 DG 能量恒等式。确定对于 $p \\ge 1$，中心通量在何种条件下是稳定的（能量不增或守恒）或不稳定的，并明确说明得出结论所必需的关于边界条件、求积精确性和网格均匀性的任何假设。\n\n最后，在所述的周期性设置下，报告使用中心通量时半离散 $L^{2}$ 能量时间导数 $\\tfrac{d}{dt}\\|u_{h}\\|_{L^{2}(\\Omega)}^{2}$ 的唯一解析值。不需要四舍五入。", "solution": "该问题要求分析用于标量对流方程 $u_{t} + a \\, u_{x} = 0$ 的间断 Galerkin (DG) 方法的半离散 $L^2$ 能量演化。我们将推导能量演化公式，并针对三种不同的数值通量进行分析。该分析将适用于给定假设下的 nodal Gauss-Lobatto 格式和 modal Legendre 格式。\n\n设区域 $\\Omega = [0,1]$ 被剖分为 $N$ 个大小为 $h_j = x_{j+1/2} - x_{j-1/2}$ 的单元 $K_j = [x_{j-1/2}, x_{j+1/2}]$。DG 近似 $u_h$ 属于分片多项式空间 $V_h = \\{ v \\in L^2(\\Omega) : v|_{K_j} \\in \\mathbb{P}^p(K_j) \\text{ for } j=1, \\dots, N \\}$。守恒律的半离散 DG 格式是通过乘以一个测试函数 $v_h \\in V_h$，在单元 $K_j$ 上积分，并对空间通量项应用分部积分得到的：\n$$\n\\int_{K_j} \\frac{\\partial u_h}{\\partial t} v_h \\, dx - \\int_{K_j} a u_h \\frac{\\partial v_h}{\\partial x} \\, dx + \\left[ a u_h v_h \\right]_{\\partial K_j} = 0\n$$\n边界项 $\\left[ a u_h v_h \\right]_{\\partial K_j}$ 计算为 $a u_h(x_{j+1/2}^-)v_h(x_{j+1/2}^-) - a u_h(x_{j-1/2}^+)v_h(x_{j-1/2}^+)$。为了耦合单元，交界面处的物理通量 $a u_h$ 被一个单值数值通量 $\\widehat{f}(u^-, u^+)$ 替代，其中 $u^-$ 和 $u^+$ 分别是交界面左右两侧的状态。标准的 DG 弱形式变为：\n$$\n\\int_{K_j} \\frac{\\partial u_h}{\\partial t} v_h \\, dx - \\int_{K_j} a u_h \\frac{\\partial v_h}{\\partial x} \\, dx + \\widehat{f}_{j+1/2} v_h(x_{j+1/2}^-) - \\widehat{f}_{j-1/2} v_h(x_{j-1/2}^+) = 0\n$$\n其中 $\\widehat{f}_{j \\pm 1/2} = \\widehat{f}(u_h(x_{j \\pm 1/2}^-), u_h(x_{j \\pm 1/2}^+))$。这对所有 $v_h \\in \\mathbb{P}^p(K_j)$ 和所有单元 $K_j$ ($j=1, \\dots, N$) 都必须成立。\n\n为了推导 $L^2$ 能量演化，我们设置测试函数 $v_h = u_h$。平方 $L^2$ 范数的时间导数由下式给出：\n$$\n\\frac{d}{dt} \\|u_h\\|_{L^2(\\Omega)}^2 = \\frac{d}{dt} \\sum_{j=1}^{N} \\int_{K_j} u_h^2 \\, dx = \\sum_{j=1}^{N} \\int_{K_j} 2 u_h \\frac{\\partial u_h}{\\partial t} \\, dx\n$$\n从 $v_h = u_h$ 的弱形式，我们有：\n$$\n\\int_{K_j} u_h \\frac{\\partial u_h}{\\partial t} \\, dx = \\int_{K_j} a u_h \\frac{\\partial u_h}{\\partial x} \\, dx - \\widehat{f}_{j+1/2} u_h(x_{j+1/2}^-) + \\widehat{f}_{j-1/2} u_h(x_{j-1/2}^+)\n$$\n右侧的第一项可以被精确积分：$\\int_{K_j} a u_h \\frac{\\partial u_h}{\\partial x} \\, dx = \\int_{K_j} \\frac{a}{2} \\frac{\\partial}{\\partial x}(u_h^2) \\, dx = \\frac{a}{2} \\left[ u_h^2 \\right]_{x_{j-1/2}^+}^{x_{j+1/2}^-} = \\frac{a}{2} \\left( (u_h(x_{j+1/2}^-))^2 - (u_h(x_{j-1/2}^+))^2 \\right)$。这一步是关键的。对于使用 Legendre 基和精确积分的模态格式，此恒等式成立。对于使用 Gauss-Lobatto 求积的节点格式，被积函数 $u_h \\frac{\\partial u_h}{\\partial x}$ 是一个阶数至多为 $p + (p-1) = 2p-1$ 的多项式。一个 $(p+1)$ 点的 Gauss-Lobatto 求积法则对于阶数高达 $2p-1$ 的多项式是精确的。此外，这种节点离散化具有分部求和 (SBP) 性质，确保了分部积分的离散模拟是精确成立的。问题陈述保证了这两种格式都满足此条件。\n\n代入此结果并乘以 2，我们得到单个单元上的能量演化：\n$$\n\\frac{d}{dt} \\int_{K_j} u_h^2 \\, dx = a \\left( (u_h(x_{j+1/2}^-))^2 - (u_h(x_{j-1/2}^+))^2 \\right) - 2 \\widehat{f}_{j+1/2} u_h(x_{j+1/2}^-) + 2 \\widehat{f}_{j-1/2} u_h(x_{j-1/2}^+)\n$$\n现在，我们对所有单元 $j=1, \\dots, N$ 求和。右侧的项是耦合相邻单元的边界项。我们可以将对单元的求和重排为对交界面的求和。对于单元 $K_k$ 和 $K_{k+1}$ 之间位于 $x_{k+1/2}$ 的一个一般交界面，其总贡献来自于单元 $K_k$ 在 $x_{k+1/2}$ 处的项和单元 $K_{k+1}$ 在 $x_{(k+1)-1/2}=x_{k+1/2}$ 处的项：\n\\begin{itemize}\n    \\item 来自 $K_k$：$a (u_h(x_{k+1/2}^-))^2 - 2 \\widehat{f}_{k+1/2} u_h(x_{k+1/2}^-)$。\n    \\item 来自 $K_{k+1}$：$-a (u_h(x_{k+1/2}^+))^2 + 2 \\widehat{f}_{k+1/2} u_h(x_{k+1/2}^+)$。\n\\end{itemize}\n将这些相加，得到来自 $x_{k+1/2}$ 处交界面的总贡献：\n$$\na \\left( (u_h^-)^2 - (u_h^+)^2 \\right) - 2 \\widehat{f} (u_h^- - u_h^+)\n$$\n其中为简洁起见，我们记 $u_h^\\pm = u_h(x_{k+1/2}^\\pm)$ 和 $\\widehat{f} = \\widehat{f}_{k+1/2}$。使用跳跃项 $[u_h] = u_h^+ - u_h^-$ 和平均值 $\\{\\!\\{u_h\\}\\!\\} = \\frac{1}{2}(u_h^- + u_h^+)$，我们可以将其重写为：\n$$\na(u_h^- - u_h^+)(u_h^- + u_h^+) + 2\\widehat{f}(u_h^+ - u_h^-) = a(-[u_h])(2\\{\\!\\{u_h\\}\\!\\}) + 2\\widehat{f}[u_h] = 2(\\widehat{f} - a\\{\\!\\{u_h\\}\\!\\})[u_h]\n$$\n周期性边界条件确保每个交界面都是内部交界面，因此我们将此贡献对所有 $N$ 个交界面求和：\n$$\n\\frac{d}{dt} \\|u_h\\|_{L^2(\\Omega)}^2 = \\sum_{\\text{interfaces}} 2(\\widehat{f} - a\\{\\!\\{u_h\\}\\!\\})[u_h]\n$$\n这就是一般的半离散 $L^2$ 能量演化公式。现在我们为每种数值通量分析它。\n\n1.  **中心通量**: $\\widehat{f}_{\\mathrm{c}}(u^{-},u^{+}) = a \\,\\{\\!\\{u\\}\\!\\} = \\frac{a}{2}(u^{-} + u^{+})$。\n    代入能量演化公式：\n    $$ \\frac{d}{dt} \\|u_h\\|_{L^2(\\Omega)}^2 = \\sum_{\\text{interfaces}} 2(a\\{\\!\\{u_h\\}\\!\\} - a\\{\\!\\{u_h\\}\\!\\})[u_h] = \\sum_{\\text{interfaces}} 0 = 0 $$\n    在半离散层面上，能量是精确守恒的。\n\n2.  **迎风通量**: $\\widehat{f}_{\\mathrm{u}} = a \\, u^{-}$ for $a>0$ and $\\widehat{f}_{\\mathrm{u}} = a \\, u^{+}$ for $a<0$。这可以紧凑地写为 $\\widehat{f}_{\\mathrm{u}} = a\\{\\!\\{u\\}\\!\\} - \\frac{|a|}{2}[u]$。\n    我们来分析 $(\\widehat{f}_{\\mathrm{u}} - a\\{\\!\\{u_h\\}\\!\\})$ 这一项：\n    $$ \\widehat{f}_{\\mathrm{u}} - a\\{\\!\\{u_h\\}\\!\\} = \\left(a\\{\\!\\{u_h\\}\\!\\} - \\frac{|a|}{2}[u_h]\\right) - a\\{\\!\\{u_h\\}\\!\\} = -\\frac{|a|}{2}[u_h] $$\n    因此，能量演化为：\n    $$ \\frac{d}{dt} \\|u_h\\|_{L^2(\\Omega)}^2 = \\sum_{\\text{interfaces}} 2\\left(-\\frac{|a|}{2}[u_h]\\right)[u_h] = -\\sum_{\\text{interfaces}} |a|[u_h]^2 $$\n    由于 $|a| \\ge 0$ 且 $[u_h]^2 \\ge 0$，能量是不增的。该格式是耗散的。\n\n3.  **Lax–Friedrichs 通量**: $\\widehat{f}_{\\mathrm{LF}} = a \\,\\{\\!\\{u\\}\\!\\} - \\tfrac{\\alpha}{2}\\,[u]$ with $\\alpha \\ge |a|$。\n    $(\\widehat{f}_{\\mathrm{LF}} - a\\{\\!\\{u_h\\}\\!\\})$ 这一项是：\n    $$ \\widehat{f}_{\\mathrm{LF}} - a\\{\\!\\{u_h\\}\\!\\} = \\left( a\\{\\!\\{u_h\\}\\!\\} - \\frac{\\alpha}{2}[u_h] \\right) - a\\{\\!\\{u_h\\}\\!\\} = -\\frac{\\alpha}{2}[u_h] $$\n    能量演化为：\n    $$ \\frac{d}{dt} \\|u_h\\|_{L^2(\\Omega)}^2 = \\sum_{\\text{interfaces}} 2\\left(-\\frac{\\alpha}{2}[u_h]\\right)[u_h] = -\\sum_{\\text{interfaces}} \\alpha[u_h]^2 $$\n    鉴于 $\\alpha \\ge |a| \\ge 0$，能量是不增的，且该格式是耗散的。\n\n关于中心通量，分析表明 $\\frac{d}{dt} \\|u_h\\|_{L^2(\\Omega)}^2 = 0$。这意味着对于所有时间 $t$，$\\|u_h(t)\\|_{L^2(\\Omega)} = \\|u_h(0)\\|_{L^2(\\Omega)}$。这是 $L^2$ 范数下的稳定性定义（具体来说，是中性稳定或能量守恒）。因此该格式是稳定的。这个结论对任何多项式阶数 $p \\ge 1$ 都成立。得出此结果的关键条件是：\n\\begin{itemize}\n    \\item 问题是线性对流方程。\n    \\item 边界条件是周期性的。\n    \\item 离散体积积分项满足性质 $\\sum_j \\int_{K_j} a u_h (\\partial_x u_h) \\, dx = \\sum_{\\text{interfaces}} \\frac{a}{2}((u_h^-)^2 - (u_h^+)^2)$，这由问题中关于指定节点和模态格式的精确/SBP 求积的假设所保证。\n\\end{itemize}\n在这些标准的 DG 分析条件下，中心通量在 $L^2$ 能量增长的意义上绝不会不稳定。虽然在实践中，缺乏耗散可能导致混叠误差或其他未被此能量分析捕捉到的非物理振荡的增长，但半离散化本身被证明是能量守恒的。\n\n最后，问题要求给出使用中心通量时半离散 $L^2$ 能量时间导数的唯一解析值。如上所推导，这个值为零。", "answer": "$$\\boxed{0}$$", "id": "3377133"}, {"introduction": "虽然DG方法在求解光滑解时精度很高，但在处理激波等间断时可能会遇到困难，常表现为振荡和不正确的传播速度。本实践探讨了一种基于局部子单元平均的修正技术，以改善对激波速度的估计 [@problem_id:3377131]。通过实现并测试该方法，您将学习一种减轻Gibbs现象并提高DG模拟中激波捕捉物理精度的实用方法，从而将理论上的Rankine-Hugoniot条件与具体的数值算法联系起来。", "problem": "考虑一维标量守恒律 $u_t + (f(u))_x = 0$ 及其包含一个激波的弱解，该激波分隔了两个恒定的平台态 $u_L^\\star$（左侧）和 $u_R^\\star$（右侧）。Rankine–Hugoniot 条件给出了激波速度 $s^\\star = \\dfrac{f(u_R^\\star) - f(u_L^\\star)}{u_R^\\star - u_L^\\star}$。在间断 Galerkin (DG) 方法 (Discontinuous Galerkin (DG)) 中，每个单元内的数值解由参考区间 $\\xi \\in [-1,1]$ 上的一个 $p$ 次 Legendre 模态形式的多项式表示，$u_h(\\xi) = \\sum_{k=0}^p a_k P_k(\\xi)$，其中 $P_k$ 是第 $k$ 个 Legendre 多项式，$a_k$ 是模态系数。在单元交界面处，DG 解提供了单侧多项式迹，可用于通过将这些迹代入 Rankine–Hugoniot 公式来形成激波速度的数值估计。\n\n您的任务是推导、实现并测试一种针对欠解析激波的修正方法，该方法通过在交界面附近使用子单元平均值局部重构平台态来改进激波速度的估计。请从守恒的积分形式和 Rankine–Hugoniot 的定义开始，然后推导出一个算法，该算法用邻近交界面两侧小区间上的局部子单元平均值替换逐点的 DG 界面迹。请使用以下原则和要求。\n\n- 从跨越移动间断的积分守恒陈述和 Rankine–Hugoniot 条件开始。交界面处的数值 DG 状态由单侧多项式迹 $u_h(\\pm 1)$ 给出。使用这些迹在 Rankine–Hugoniot 公式中定义一个基准 DG 激波速度估计 $s_{\\mathrm{DG}}$。\n- 定义一个局部子单元重构，如下所示。对于给定的整数 $M \\ge 1$，设参考坐标系中的子单元宽度为 $\\Delta \\xi = \\dfrac{2}{M}$。在左侧单元上，将左侧重构态定义为右交界面附近的子单元平均值，\n  $$ \\bar{u}_L^{\\mathrm{sub}} = \\frac{1}{\\Delta \\xi} \\int_{1 - \\Delta \\xi}^{1} u_h^{(L)}(\\xi)\\, d\\xi, $$\n  在右侧单元上，将右侧重构态定义为左交界面附近的子单元平均值，\n  $$ \\bar{u}_R^{\\mathrm{sub}} = \\frac{1}{\\Delta \\xi} \\int_{-1}^{-1 + \\Delta \\xi} u_h^{(R)}(\\xi)\\, d\\xi. $$\n  使用这些重构的子单元平均值 $\\bar{u}_L^{\\mathrm{sub}}$ 和 $\\bar{u}_R^{\\mathrm{sub}}$ 作为修正的平台态估计，代入修正的 Rankine–Hugoniot 激波速度公式 $s_{\\mathrm{corr}} = \\dfrac{f(\\bar{u}_R^{\\mathrm{sub}}) - f(\\bar{u}_L^{\\mathrm{sub}})}{\\bar{u}_R^{\\mathrm{sub}} - \\bar{u}_L^{\\mathrm{sub}}}$。\n- 您的程序必须实现上述基准和修正的激波速度估计。Legendre 多项式必须采用标准多项式 $P_0(\\xi) = 1$、$P_1(\\xi) = \\xi$、$P_2(\\xi) = \\dfrac{1}{2}(3\\xi^2 - 1)$ 等。界面迹在 $\\xi = 1$（左侧单元的右侧）和 $\\xi = -1$（右侧单元的左侧）处求值。子单元平均值必须通过数值积分计算，该积分对至少为 $p$ 次的多项式是精确的；使用映射到子区间的 Gaussian–Legendre 求积法来计算定义 $\\bar{u}_L^{\\mathrm{sub}}$ 和 $\\bar{u}_R^{\\mathrm{sub}}$ 的积分。\n- 对于每个测试用例，根据给定的平台态 $u_L^\\star$ 和 $u_R^\\star$ 计算精确激波速度 $s^\\star = \\dfrac{f(u_R^\\star) - f(u_L^\\star)}{u_R^\\star - u_L^\\star}$。然后计算绝对基准误差 $E_{\\mathrm{DG}} = |s_{\\mathrm{DG}} - s^\\star|$ 和绝对修正误差 $E_{\\mathrm{corr}} = |s_{\\mathrm{corr}} - s^\\star|$。为每个测试报告改进量 $I = E_{\\mathrm{DG}} - E_{\\mathrm{corr}}$，以单个浮点数形式表示，其中正值表示修正改进了估计。\n\n使用以下测试套件。在所有情况下，使用多项式次数 $p = 2$ 和子单元数量 $M = 4$。\n\n- 测试 $1$（凸二次通量，欠解析跳跃）：\n  - 通量：$f(u) = \\dfrac{1}{2} u^2$。\n  - 真实平台态：$u_L^\\star = 2.0$，$u_R^\\star = 0.0$。\n  - 左侧单元系数：$\\boldsymbol{a}^{(L)} = [1.95,\\,-0.08,\\,0.03]$。\n  - 右侧单元系数：$\\boldsymbol{a}^{(R)} = [0.10,\\,0.12,\\,0.03]$。\n- 测试 $2$（线性通量边缘情况，恒定信号速度）：\n  - 通量：$f(u) = a\\, u$，其中 $a = 1.3$。\n  - 真实平台态：$u_L^\\star = 1.0$，$u_R^\\star = 0.0$。\n  - 左侧单元系数：$\\boldsymbol{a}^{(L)} = [0.90,\\,0.20,\\,-0.05]$。\n  - 右侧单元系数：$\\boldsymbol{a}^{(R)} = [0.10,\\,0.00,\\,0.00]$。\n- 测试 $3$（凸三次通量，非对称偏差）：\n  - 通量：$f(u) = \\dfrac{1}{3} u^3$。\n  - 真实平台态：$u_L^\\star = 1.5$，$u_R^\\star = -0.5$。\n  - 左侧单元系数：$\\boldsymbol{a}^{(L)} = [1.55,\\,-0.08,\\,0.00]$。\n  - 右侧单元系数：$\\boldsymbol{a}^{(R)} = [-0.48,\\,0.03,\\,0.00]$。\n\n实现细节和输出规格：\n\n- 将每个单元多项式表示为 $u_h(\\xi) = \\sum_{k=0}^{2} a_k P_k(\\xi)$，其中给定的模态系数是在 $[-1,1]$ 上的标准 Legendre 基中。\n- 使用在 $\\xi = 1$（对于左侧单元）和 $\\xi = -1$（对于右侧单元）处的求值来计算单侧 DG 界面迹。\n- 使用映射到子区间 $[1 - \\Delta \\xi, 1]$ 和 $[-1, -1 + \\Delta \\xi]$（其中 $\\Delta \\xi = \\dfrac{2}{M}$）的足够阶数的 Gaussian–Legendre 求积法计算子单元平均值。\n- 对于每个测试用例，输出改进量 $I = E_{\\mathrm{DG}} - E_{\\mathrm{corr}}$，四舍五入到六位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，“[$0.012345$, $0.000000$, $0.004200$]”），按测试 $1$–$3$ 的顺序排列。\n\n本问题中的所有答案均为纯数值；不需要物理单位或角度。请确保本问题陈述中的每个数学实体都使用 $...$ 分隔符以 LaTeX 格式书写。", "solution": "该问题要求推导并实现一种修正的激波速度估计方法，用于将间断 Galerkin (DG) 数值方法应用于一维标量守恒律 $u_t + (f(u))_x = 0$。该修正基于局部子单元平均，以更好地近似激波间断两侧的平台态。\n\n分析始于在一个包含以速度 $s$ 传播的激波的时空矩形 $[x_L, x_R] \\times [t_1, t_2]$ 上的守恒律积分形式。这导出了精确激波速度 $s^\\star$ 的 Rankine–Hugoniot 条件：\n$$\ns^\\star = \\frac{f(u_R^\\star) - f(u_L^\\star)}{u_R^\\star - u_L^\\star} = \\frac{[f(u)]}{[u]}\n$$\n其中 $u_L^\\star$ 和 $u_R^\\star$ 分别是激波左侧和右侧的恒定状态，$[ \\cdot ]$ 表示量跨越间断的跳跃。\n\n在 DG 框架中，每个计算单元内的数值解由一个多项式表示。对于本问题，该多项式是在参考区间 $\\xi \\in [-1, 1]$ 上的一个 $p$ 次多项式，以 Legendre 模态基表示：\n$$\nu_h(\\xi) = \\sum_{k=0}^p a_k P_k(\\xi)\n$$\n其中 $P_k(\\xi)$ 是第 $k$ 个 Legendre 多项式，$a_k$ 是模态系数。给定的次数为 $p=2$，因此相关的多项式为：\n$$\nP_0(\\xi) = 1, \\quad P_1(\\xi) = \\xi, \\quad P_2(\\xi) = \\frac{1}{2}(3\\xi^2 - 1)\n$$\n因此，给定单元中的解是显式的：$u_h(\\xi) = a_0 + a_1 \\xi + a_2 \\frac{1}{2}(3\\xi^2 - 1)$。\n\n激波速度的基准数值估计 $s_{\\mathrm{DG}}$ 可以通过将 DG 解在单元交界面处的单侧迹直接代入 Rankine–Hugoniot 公式来形成。设交界面位于“左”单元和“右”单元之间。左单元的右边界对应于 $\\xi=1$，右单元的左边界对应于 $\\xi=-1$。单侧迹为：\n$$\nu_L = u_h^{(L)}(\\xi=1) = a_0^{(L)} P_0(1) + a_1^{(L)} P_1(1) + a_2^{(L)} P_2(1) = a_0^{(L)} + a_1^{(L)} + a_2^{(L)}\n$$\n$$\nu_R = u_h^{(R)}(\\xi=-1) = a_0^{(R)} P_0(-1) + a_1^{(R)} P_1(-1) + a_2^{(R)} P_2(-1) = a_0^{(R)} - a_1^{(R)} + a_2^{(R)}\n$$\n则基准激波速度估计为：\n$$\ns_{\\mathrm{DG}} = \\frac{f(u_R) - f(u_L)}{u_R - u_L}\n$$\n\n对于欠解析的激波，间断附近的多项式振荡（Gibbs 现象）可能使逐点迹 $u_L$ 和 $u_R$ 成为真实平台态 $u_L^\\star$ 和 $u_R^\\star$ 的较差近似。所提出的修正旨在通过使用局部平均值作为更鲁棒的平台态估计来缓解此问题。\n\n子单元重构通过对邻近交界面的小 子区间上的 DG 多项式进行平均来定义修正的状态 $\\bar{u}_L^{\\mathrm{sub}}$ 和 $\\bar{u}_R^{\\mathrm{sub}}$。给定子单元数 $M$，参考坐标系中子区间的宽度为 $\\Delta\\xi = 2/M$。修正的状态定义为：\n$$\n\\bar{u}_L^{\\mathrm{sub}} = \\frac{1}{\\Delta \\xi} \\int_{1 - \\Delta \\xi}^{1} u_h^{(L)}(\\xi)\\, d\\xi\n$$\n$$\n\\bar{u}_R^{\\mathrm{sub}} = \\frac{1}{\\Delta \\xi} \\int_{-1}^{-1 + \\Delta \\xi} u_h^{(R)}(\\xi)\\, d\\xi\n$$\n使用这些平均状态，可以构建一个修正的激波速度估计 $s_{\\mathrm{corr}}$：\n$$\ns_{\\mathrm{corr}} = \\frac{f(\\bar{u}_R^{\\mathrm{sub}}) - f(\\bar{u}_L^{\\mathrm{sub}})}{\\bar{u}_R^{\\mathrm{sub}} - \\bar{u}_L^{\\mathrm{sub}}}\n$$\n\n为了计算 $\\bar{u}_L^{\\mathrm{sub}}$ 和 $\\bar{u}_R^{\\mathrm{sub}}$ 的积分，我们采用 Gaussian-Legendre 求积法，该方法要求对至少为 $p=2$ 次的多项式是精确的。一个 $N$ 点 Gaussian-Legendre 求积法则对最高为 $2N-1$ 次的多项式是精确的。对于我们的 $p=2$ 次的被积函数，我们需要 $2N-1 \\ge 2$，这意味着 $N \\ge 1.5$。因此，一个 $2$ 点求积法则（$N=2$，对最高 $3$ 次多项式精确）是足够的。\n\n要使用 $N$ 点 Gaussian-Legendre 法则计算积分 $\\int_a^b g(\\xi) d\\xi$，我们将区间 $[a, b]$ 映射到参考求积区间 $[-1, 1]$，使用变换 $\\xi(\\eta) = \\frac{b-a}{2}\\eta + \\frac{a+b}{2}$。积分然后近似为：\n$$\n\\int_a^b g(\\xi) d\\xi = \\frac{b-a}{2} \\int_{-1}^1 g(\\xi(\\eta)) d\\eta \\approx \\frac{b-a}{2} \\sum_{i=1}^N w_i g(\\xi(\\eta_i))\n$$\n其中 $(\\eta_i, w_i)$ 是 $[-1, 1]$ 上的标准 Gaussian-Legendre 节点和权重。\n\n对于给定的参数 $p=2$ 和 $M=4$，我们有 $\\Delta\\xi = 2/4 = 0.5$。\n$\\bar{u}_L^{\\mathrm{sub}}$ 的积分区间是 $[1 - 0.5, 1] = [0.5, 1]$。\n$\\bar{u}_R^{\\mathrm{sub}}$ 的积分区间是 $[-1, -1 + 0.5] = [-1, -0.5]$。\n\n最终任务是为每个测试用例计算改进量 $I = E_{\\mathrm{DG}} - E_{\\mathrm{corr}}$，其中误差定义为 $E_{\\mathrm{DG}} = |s_{\\mathrm{DG}} - s^\\star|$ 和 $E_{\\mathrm{corr}} = |s_{\\mathrm{corr}} - s^\\star|$。$I$ 的正值表示子单元修正改进了激波速度的估计。\n\n每个测试用例的算法如下：\n1.  根据给定的真实平台态 $u_L^\\star$ 和 $u_R^\\star$ 以及通量函数 $f(u)$，计算精确的激波速度 $s^\\star$。\n2.  根据给定的模态系数 $\\boldsymbol{a}^{(L)}$ 和 $\\boldsymbol{a}^{(R)}$，计算界面迹 $u_L = u_h^{(L)}(1)$ 和 $u_R = u_h^{(R)}(-1)$。\n3.  计算基准激波速度 $s_{\\mathrm{DG}} = (f(u_R) - f(u_L))/(u_R - u_L)$。\n4.  为子区间 $[0.5, 1]$ 和 $[-1, -0.5]$ 建立 $2$ 点 Gaussian-Legendre 求积法。\n5.  使用求积法则计算平均值 $\\bar{u}_L^{\\mathrm{sub}}$ 和 $\\bar{u}_R^{\\mathrm{sub}}$。\n6.  计算修正的激波速度 $s_{\\mathrm{corr}} = (f(\\bar{u}_R^{\\mathrm{sub}}) - f(\\bar{u}_L^{\\mathrm{sub}}))/(\\bar{u}_R^{\\mathrm{sub}} - \\bar{u}_L^{\\mathrm{sub}})$。\n7.  计算绝对误差 $E_{\\mathrm{DG}}$ 和 $E_{\\mathrm{corr}}$。\n8.  计算改进量 $I = E_{\\mathrm{DG}} - E_{\\mathrm{corr}}$。\n此流程应用于所有指定的测试用例。对于线性通量情况 $f(u) = au$，只要激波两侧的状态不相等，Rankine-Hugoniot 速度总是 $s=a$。这可作为对实现的一个有用的解析性检验。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing baseline and corrected DG shock speed estimates.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"flux\": lambda u: 0.5 * u**2,\n            \"u_star\": (2.0, 0.0),\n            \"coeffs_L\": np.array([1.95, -0.08, 0.03]),\n            \"coeffs_R\": np.array([0.10, 0.12, 0.03]),\n        },\n        {\n            \"flux\": lambda u: 1.3 * u,\n            \"u_star\": (1.0, 0.0),\n            \"coeffs_L\": np.array([0.90, 0.20, -0.05]),\n            \"coeffs_R\": np.array([0.10, 0.00, 0.00]),\n        },\n        {\n            \"flux\": lambda u: (1/3) * u**3,\n            \"u_star\": (1.5, -0.5),\n            \"coeffs_L\": np.array([1.55, -0.08, 0.00]),\n            \"coeffs_R\": np.array([-0.48, 0.03, 0.00]),\n        }\n    ]\n\n    p = 2  # Polynomial degree\n    M = 4  # Subcell count\n\n    results = []\n    for case in test_cases:\n        improvement = calculate_improvement(case, p, M)\n        results.append(improvement)\n\n    # Format the final output string as specified\n    output_str = \"[\" + \",\".join(f\"{res:.6f}\" for res in results) + \"]\"\n    print(output_str)\n\ndef eval_poly(coeffs, xi):\n    \"\"\"\n    Evaluates the DG polynomial at reference coordinate(s) xi.\n    Coeffs are [a0, a1, a2].\n    xi can be a scalar or a numpy array.\n    \"\"\"\n    if not isinstance(xi, np.ndarray):\n        xi = np.array([xi])\n        \n    P0 = np.ones_like(xi)\n    P1 = xi\n    P2 = 0.5 * (3 * xi**2 - 1)\n    \n    val = coeffs[0] * P0 + coeffs[1] * P1 + coeffs[2] * P2\n    \n    return val[0] if len(val) == 1 else val\n\ndef integrate_gauss_legendre(func, interval, nodes, weights):\n    \"\"\"\n    Performs Gauss-Legendre quadrature of a function over a given interval.\n    \"\"\"\n    a, b = interval\n    # Map nodes from [-1, 1] to [a, b]\n    mapped_nodes = 0.5 * (b - a) * nodes + 0.5 * (a + b)\n    # The integral is the scaled sum of weighted function evaluations\n    integral = 0.5 * (b - a) * np.sum(weights * func(mapped_nodes))\n    return integral\n\ndef calculate_improvement(case_data, p, M):\n    \"\"\"\n    Calculates the improvement I = E_DG - E_corr for a single test case.\n    \"\"\"\n    f = case_data[\"flux\"]\n    u_L_star, u_R_star = case_data[\"u_star\"]\n    coeffs_L = case_data[\"coeffs_L\"]\n    coeffs_R = case_data[\"coeffs_R\"]\n    \n    # 1. Calculate exact shock speed s_star\n    # Handle the linear flux case where the formula simplifies, but the general one is fine.\n    if u_R_star == u_L_star:\n        # This case is not in the test suite but is handled for completeness.\n        # It corresponds to a characteristic wave, speed is f'(u).\n        # For this problem, we assume a shock so u_L != u_R.\n        # However, for a general implementation this might be important.\n        # Assuming f'(u) is known or can be computed symbolically/numerically.\n        # For this problem, this branch is not taken.\n        s_star = 0 \n    else:\n        s_star = (f(u_R_star) - f(u_L_star)) / (u_R_star - u_L_star)\n\n    # 2. Calculate baseline DG shock speed s_dg\n    u_L_trace = eval_poly(coeffs_L, 1.0)\n    u_R_trace = eval_poly(coeffs_R, -1.0)\n    \n    if u_R_trace == u_L_trace:\n        # Degenerate case, should not happen in these tests\n        s_dg = s_star \n    else:\n        s_dg = (f(u_R_trace) - f(u_L_trace)) / (u_R_trace - u_L_trace)\n\n    # 3. Calculate corrected shock speed s_corr\n    delta_xi = 2.0 / M\n    \n    # Quadrature setup: N=2 points is sufficient for integrating a degree p=2 polynomial\n    # as 2*N-1 = 3 >= 2.\n    n_quad_points = p \n    nodes, weights = roots_legendre(n_quad_points)\n\n    # Define polynomial functions for quadrature\n    u_h_L = lambda xi: eval_poly(coeffs_L, xi)\n    u_h_R = lambda xi: eval_poly(coeffs_R, xi)\n\n    # Left subcell average\n    interval_L = [1.0 - delta_xi, 1.0]\n    integral_L = integrate_gauss_legendre(u_h_L, interval_L, nodes, weights)\n    u_L_sub = integral_L / delta_xi\n\n    # Right subcell average\n    interval_R = [-1.0, -1.0 + delta_xi]\n    integral_R = integrate_gauss_legendre(u_h_R, interval_R, nodes, weights)\n    u_R_sub = integral_R / delta_xi\n\n    if u_R_sub == u_L_sub:\n        # Degenerate case\n        s_corr = s_star\n    else:\n        s_corr = (f(u_R_sub) - f(u_L_sub)) / (u_R_sub - u_L_sub)\n\n    # 4. Calculate errors and improvement\n    e_dg = abs(s_dg - s_star)\n    e_corr = abs(s_corr - s_star)\n    improvement = e_dg - e_corr\n    \n    return improvement\n\nsolve()\n```", "id": "3377131"}, {"introduction": "传统上，数值通量的设计由数学分析指导。本练习将介绍一种现代的、面向研究的方法，即利用高保真数据来优化通量参数 [@problem_id:3377101]。您将实现一个简单的学习算法，以精确的Godunov通量为“基准真相”，来寻找对标准Rusanov通量的修正。这项实践提供了科学机器学习新兴领域的动手经验，展示了如何在严格执行一致性和熵稳定性等基本物理约束的同时，创建数据驱动的数值闭合模型。", "problem": "考虑标量守恒律 $u_t + f(u)_x = 0$，其通量为 $f(u) = \\tfrac{1}{2} u^2$（无粘伯格斯方程）。在间断伽辽金（DG）方法中，单元间的耦合由每个界面上的两点数值通量 $\\hat{f}(u_L,u_R)$ 控制，其中 $u_L$ 和 $u_R$ 表示近似解的左右迹值。数值通量必须满足相容性条件 $\\hat{f}(u,u) = f(u)$（对于任意 $u$）。此外，对于一个凸熵对 $(\\eta(u), q(u))$，为了确保熵耗散，期望在界面上满足形式为 $(v_R - v_L)\\,\\hat{f}(u_L,u_R) \\le q(u_R) - q(u_L)$ 的离散熵不等式，其中 $v = \\eta'(u)$ 是熵变量。\n\n您的任务是设计一种数据驱动的数值通量封闭模型。这通过学习一个标量修正参数 $c$ 来实现，该参数乘以局部Lax-Friedrichs（Rusanov）通量的扩散系数，同时强制满足相容性约束和熵不等式。具体来说，使用Rusanov通量族\n$$\n\\hat{f}_c(u_L,u_R) = \\frac{f(u_L)+f(u_R)}{2} - \\frac{1}{2}\\, c \\,\\alpha(u_L,u_R)\\,(u_R - u_L),\n$$\n其中，对于伯格斯方程，$\\alpha(u_L,u_R) = \\max\\{|f'(u_L)|, |f'(u_R)|\\} = \\max\\{|u_L|, |u_R|\\}$。基准选择 $c = 1$ 得到经典的Rusanov通量。您必须通过最小化 $\\hat{f}_c(u_L,u_R)$ 与高保真目标界面通量之间的均方差，从数据中学习 $c$，然后强制执行 $c \\ge 1$ 以保证凸熵的单调性和离散熵不等式。\n\n对于训练数据，使用由伯格斯方程在界面上的精确黎曼解定义的高保真目标，即精确的Godunov通量：\n- 如果 $u_L \\le u_R$（稀疏波），则\n  - 如果 $u_L \\ge 0$，界面状态为 $u_L$，通量为 $f(u_L)$。\n  - 如果 $u_R \\le 0$，界面状态为 $u_R$，通量为 $f(u_R)$。\n  - 否则，界面状态为 $0$，通量为 $f(0) = 0$。\n- 如果 $u_L > u_R$（激波），激波速度为 $s = \\dfrac{f(u_L) - f(u_R)}{u_L - u_R} = \\dfrac{u_L + u_R}{2}$，且\n  - 如果 $s \\ge 0$，通量为 $f(u_L)$。\n  - 如果 $s  0$，通量为 $f(u_R)$。\n\n通过在固定的界面状态训练集 $\\{(u_L^{(i)},u_R^{(i)})\\}_{i=1}^N$ 上使用最小二乘法学习 $c$，然后对学习到的参数进行投影以满足 $c \\ge 1$。学习到 $c$ 之后，在未见过的黎曼问题上测试其泛化能力，并使用熵对 $\\eta(u) = \\tfrac{1}{2}u^2$ 和 $q(u) = \\tfrac{1}{3}u^3$ 验证所学通量的相容性和离散熵不等式。\n\n使用以下固定的训练和测试集：\n- 训练对 $(u_L,u_R)$:\n  $(-1.0, 0.5)$、$(0.0, 1.0)$、$(-0.5, -1.0)$、$(0.75, -0.25)$、$(-1.0, -0.2)$、$(0.2, 0.8)$、$(-0.9, 0.0)$、$(0.0, -0.7)$。\n- 测试对 $(u_L,u_R)$（训练中未见过）：\n  $(-2.0, -1.5)$、$(-1.75, 0.25)$、$(1.25, -0.75)$、$(0.0, 2.0)$、$(-2.0, 1.0)$、$(0.5, 0.5)$。\n\n实现一个程序，该程序：\n1. 对所有训练对计算Godunov通量 $f_G(u_L,u_R)$。\n2. 学习标量参数 $c$，使其在训练对上最小化 $\\hat{f}_c(u_L,u_R)$ 和 $f_G(u_L,u_R)$ 之间的均方误差。利用 $\\hat{f}_c$ 线性依赖于 $c$ 这一事实，推导出最小二乘的闭式解，然后通过投影强制 $c \\ge 1$。\n3. 报告基准Rusanov通量（$c = 1$）和所学通量的训练均方误差。\n4. 在测试对上，计算基准通量和所学通量相对于Godunov通量的平均绝对误差。\n5. 通过计算 $\\max_{u \\in \\{-2.0, -1.0, -0.5, 0.0, 0.5, 1.0, 2.0\\}} |\\hat{f}_c(u,u) - f(u)|$ 并返回一个布尔值来验证相容性，该布尔值指示此最大值是否小于或等于 $10^{-12}$。\n6. 通过检查所有测试对是否满足 $(v_R - v_L)\\,\\hat{f}_c(u_L,u_R) \\le q(u_R) - q(u_L)$（在 $10^{-12}$ 的容差内，且 $v = u$）来验证离散熵不等式，并返回一个布尔值，表示该不等式是否对所有测试对都成立。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[$training\\_MSE\\_baseline$, $training\\_MSE\\_learned$, $test\\_MAE\\_baseline$, $test\\_MAE\\_learned$, $consistency\\_ok$, $entropy\\_ok$$]$。\n所有数值都应作为原始浮点数或布尔值输出，不涉及单位，也没有附加文本。角度单位不适用。如果需要，在代码输出中将任何比率或分数表示为小数。从标量守恒律、数值通量相容性和熵对的定义出发，从第一性原理设计您的解决方案，并确保所学的封闭模型通过构造尊重相容性和熵耗散。上面定义的训练/测试集是唯一要使用的数据；不要读取任何外部数据。", "solution": "问题要求我们为标量守恒律 $u_t + f(u)_x = 0$ 的间断伽辽金（DG）方法设计一个数据驱动的数值通量封闭模型。我们考虑的具体情况是无粘伯格斯方程，其通量函数为 $f(u) = \\frac{1}{2} u^2$。我们的目标是在局部Lax-Friedrichs（或Rusanov）数值通量族中学习一个参数，并受相容性和熵稳定性约束。\n\n首先，我们建立数学框架。Rusanov通量族由以下公式给出：\n$$\n\\hat{f}_c(u_L,u_R) = \\frac{f(u_L)+f(u_R)}{2} - \\frac{1}{2}\\, c \\,\\alpha(u_L,u_R)\\,(u_R - u_L)\n$$\n这里，$u_L$ 和 $u_R$ 分别是界面左右两侧的状态。参数 $c$ 是我们旨在学习的标量。项 $\\alpha(u_L,u_R)$ 是局部传播速度，定义为 $\\alpha(u_L,u_R) = \\max\\{|f'(u_L)|, |f'(u_R)|\\}$。对于伯格斯方程，$f'(u) = u$，这简化为 $\\alpha(u_L,u_R) = \\max\\{|u_L|, |u_R|\\}$。选择 $c=1$ 可恢复为标准的Rusanov通量，它作为我们的基准。\n\n学习过程是监督式的。我们给定一组训练数据点 $\\{(u_L^{(i)}, u_R^{(i)})\\}_{i=1}^N$。每对数据的目标值是由黎曼问题的精确解给出的通量，即Godunov通量 $f_G(u_L, u_R)$。对于伯格斯方程，Godunov通量为：\n\\begin{itemize}\n    \\item 如果 $u_L \\le u_R$ (稀疏波): $f_G = \\begin{cases} f(u_L)  \\text{if } u_L \\ge 0 \\\\ f(u_R)  \\text{if } u_R \\le 0 \\\\ f(0) = 0  \\text{if } u_L  0  u_R \\end{cases}$\n    \\item 如果 $u_L  u_R$ (激波): 激波速度为 $s = \\frac{f(u_L)-f(u_R)}{u_L-u_R} = \\frac{u_L+u_R}{2}$。通量为 $f_G = \\begin{cases} f(u_L)  \\text{if } s \\ge 0 \\\\ f(u_R)  \\text{if } s  0 \\end{cases}$\n\\end{itemize}\n\n我们的目标是找到标量参数 $c$，以最小化参数化通量 $\\hat{f}_c$ 和Godunov通量 $f_G$ 在训练集上的均方误差（MSE）。令 $y^{(i)} = f_G(u_L^{(i)}, u_R^{(i)})$ 为第 $i$ 个训练对的目标通量。要最小化的损失函数是：\n$$\nL(c) = \\sum_{i=1}^N \\left( \\hat{f}_c(u_L^{(i)}, u_R^{(i)}) - y^{(i)} \\right)^2\n$$\n为了简化优化，我们可以重写通量 $\\hat{f}_c$ 以分离出对 $c$ 的线性依赖关系。令 $A_i = \\frac{f(u_L^{(i)})+f(u_R^{(i)})}{2}$ 为平均通量部分，令 $B_i = \\frac{1}{2}\\alpha(u_L^{(i)},u_R^{(i)})(u_R^{(i)} - u_L^{(i)})$ 为扩散部分的系数。那么，$\\hat{f}_c^{(i)} = A_i - c B_i$。损失函数变为：\n$$\nL(c) = \\sum_{i=1}^N (A_i - c B_i - y^{(i)})^2\n$$\n这是一个标准的线性最小二乘问题。我们通过将 $L(c)$ 对 $c$ 的导数设为零来找到最优的 $c$：\n$$\n\\frac{dL}{dc} = \\sum_{i=1}^N 2 (A_i - c B_i - y^{(i)}) (-B_i) = 0\n$$\n求解 $c$，我们得到闭式解：\n$$\nc_{LS} = \\frac{\\sum_{i=1}^N (A_i - y^{(i)}) B_i}{\\sum_{i=1}^N B_i^2}\n$$\n问题陈述，在找到 $c_{LS}$ 后，我们必须强制执行约束 $c \\ge 1$。这通过投影实现：\n$$\nc_{learned} = \\max\\{c_{LS}, 1.0\\}\n$$\n这个约束至关重要，因为 $c \\ge 1$ 是一个已知的充分条件，可使Rusanov通量对任何凸熵满足离散熵不等式，从而确保数值格式是耗散和稳定的。\n\n在确定 $c_{learned}$ 后，我们评估其性能。我们计算基准（$c=1$）和学习到的（$c=c_{learned}$）通量的训练MSE。我们还在一个独立的、未见过的测试集上计算平均绝对误差（MAE），以评估其泛化能力。\n\n最后，我们必须验证学习到的数值通量 $\\hat{f}_{c_{learned}}$ 的两个基本属性：\n1.  **相容性**：数值通量必须与物理通量相容，即对任何状态 $u$ 都有 $\\hat{f}_c(u,u) = f(u)$。对于我们的通量族：\n    $$\n    \\hat{f}_c(u,u) = \\frac{f(u)+f(u)}{2} - \\frac{1}{2} c \\alpha(u,u)(u-u) = f(u) - 0 = f(u)\n    $$\n    对于任何 $c$ 值，该属性在解析上都成立。数值检验是验证实现是否在机器精度范围内正确。\n2.  **离散熵不等式**：对于凸熵对 $(\\eta(u), q(u))$，其中 $\\eta(u) = \\frac{1}{2}u^2$ 和 $q(u) = \\frac{1}{3}u^3$，相应的熵变量是 $v = \\eta'(u) = u$。界面处熵稳定性的一个充分条件是满足不等式：\n    $$\n    (v_R - v_L)\\hat{f}_c(u_L, u_R) \\le q(u_R) - q(u_L)\n    $$\n    代入 $v$ 和 $q$ 的具体形式，我们检查是否：\n    $$\n    (u_R - u_L)\\hat{f}_{c_{learned}}(u_L, u_R) \\le \\frac{1}{3}u_R^3 - \\frac{1}{3}u_L^3\n    $$\n    对测试集中的所有数据对执行此检查。由于我们强制执行了 $c_{learned} \\ge 1$，我们期望此不等式成立。\n\n整个过程如下：\n1. 实现Godunov通量 $f_G$ 和Rusanov通量族 $\\hat{f}_c$ 的分量。\n2. 使用训练数据，计算向量 $A_i$、$B_i$ 和 $y_i$。\n3. 使用推导出的公式计算 $c_{LS}$，并对其进行投影以得到 $c_{learned}$。\n4. 计算 $c=1$ 和 $c=c_{learned}$ 的训练MSE。\n5. 计算 $c=1$ 和 $c=c_{learned}$ 相对于Godunov通量的测试MAE。\n6. 对 $\\hat{f}_{c_{learned}}$ 执行相容性和熵不等式检查。\n7. 编译并以指定格式报告结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of learning a data-driven numerical flux for Burgers' equation.\n    \"\"\"\n    # Define the training and test suites as specified in the problem statement.\n    train_pairs = [\n        (-1.0, 0.5), (0.0, 1.0), (-0.5, -1.0), (0.75, -0.25),\n        (-1.0, -0.2), (0.2, 0.8), (-0.9, 0.0), (0.0, -0.7)\n    ]\n    test_pairs = [\n        (-2.0, -1.5), (-1.75, 0.25), (1.25, -0.75),\n        (0.0, 2.0), (-2.0, 1.0), (0.5, 0.5)\n    ]\n\n    # ----------------------------------------------------------------------\n    # 1. Define Flux Functions and their Components\n    # ----------------------------------------------------------------------\n\n    def physical_flux(u):\n        \"\"\"Computes the physical flux f(u) = 0.5*u^2.\"\"\"\n        return 0.5 * u**2\n\n    def godunov_flux(u_l, u_r):\n        \"\"\"Computes the Godunov flux for the Burgers' equation.\"\"\"\n        if u_l = u_r:  # Rarefaction\n            if u_l >= 0.0:\n                return physical_flux(u_l)\n            elif u_r = 0.0:\n                return physical_flux(u_r)\n            else:  # u_l  0  u_r\n                return 0.0\n        else:  # Shock\n            s = 0.5 * (u_l + u_r) # Shock speed\n            if s >= 0.0:\n                return physical_flux(u_l)\n            else:\n                return physical_flux(u_r)\n    \n    def rusanov_components(u_l, u_r):\n        \"\"\"Computes components A and B of the Rusanov flux family.\"\"\"\n        A = 0.5 * (physical_flux(u_l) + physical_flux(u_r))\n        alpha = max(abs(u_l), abs(u_r))\n        B = 0.5 * alpha * (u_r - u_l)\n        return A, B\n\n    def rusanov_flux(u_l, u_r, c):\n        \"\"\"Computes the Rusanov flux for a given parameter c.\"\"\"\n        A, B = rusanov_components(u_l, u_r)\n        return A - c * B\n\n    # ----------------------------------------------------------------------\n    # 2. Learn the parameter c from training data\n    # ----------------------------------------------------------------------\n\n    # Prepare data for least-squares\n    A_train = []\n    B_train = []\n    y_target_train = []\n    for u_l, u_r in train_pairs:\n        A, B = rusanov_components(u_l, u_r)\n        A_train.append(A)\n        B_train.append(B)\n        y_target_train.append(godunov_flux(u_l, u_r))\n\n    A_train_np = np.array(A_train)\n    B_train_np = np.array(B_train)\n    y_target_train_np = np.array(y_target_train)\n\n    # Solve the least-squares problem for c\n    # We want to minimize || (A - c*B) - y ||^2\n    # which is equivalent to minimizing || (A - y) - c*B ||^2\n    # The solution is c_ls = dot(A - y, B) / dot(B, B)\n    numerator = np.dot(A_train_np - y_target_train_np, B_train_np)\n    denominator = np.dot(B_train_np, B_train_np)\n\n    if abs(denominator)  1e-15:\n        # Handle case where all B_i are zero (unlikely with this data)\n        c_ls = 1.0 \n    else:\n        c_ls = numerator / denominator\n    \n    # Project c to satisfy c >= 1\n    c_learned = max(c_ls, 1.0)\n\n    # ----------------------------------------------------------------------\n    # 3. Compute Training MSE\n    # ----------------------------------------------------------------------\n\n    flux_pred_baseline_train = np.array([rusanov_flux(u_l, u_r, 1.0) for u_l, u_r in train_pairs])\n    flux_pred_learned_train = np.array([rusanov_flux(u_l, u_r, c_learned) for u_l, u_r in train_pairs])\n\n    training_mse_baseline = np.mean((flux_pred_baseline_train - y_target_train_np)**2)\n    training_mse_learned = np.mean((flux_pred_learned_train - y_target_train_np)**2)\n\n    # ----------------------------------------------------------------------\n    # 4. Compute Test MAE\n    # ----------------------------------------------------------------------\n    \n    y_target_test = np.array([godunov_flux(u_l, u_r) for u_l, u_r in test_pairs])\n    flux_pred_baseline_test = np.array([rusanov_flux(u_l, u_r, 1.0) for u_l, u_r in test_pairs])\n    flux_pred_learned_test = np.array([rusanov_flux(u_l, u_r, c_learned) for u_l, u_r in test_pairs])\n\n    test_mae_baseline = np.mean(np.abs(flux_pred_baseline_test - y_target_test))\n    test_mae_learned = np.mean(np.abs(flux_pred_learned_test - y_target_test))\n\n    # ----------------------------------------------------------------------\n    # 5. Verify Consistency\n    # ----------------------------------------------------------------------\n\n    u_vals_consistency = [-2.0, -1.0, -0.5, 0.0, 0.5, 1.0, 2.0]\n    errors = [abs(rusanov_flux(u, u, c_learned) - physical_flux(u)) for u in u_vals_consistency]\n    consistency_ok = max(errors) = 1e-12\n\n    # ----------------------------------------------------------------------\n    # 6. Verify Discrete Entropy Inequality\n    # ----------------------------------------------------------------------\n    \n    def entropy_flux(u):\n        \"\"\"Computes the entropy flux q(u) = 1/3 * u^3.\"\"\"\n        return (1/3) * u**3\n\n    entropy_inequality_holds = True\n    for u_l, u_r in test_pairs:\n        # For eta(u) = 0.5*u^2, entropy variable v = eta'(u) = u\n        v_l, v_r = u_l, u_r\n        \n        flux = rusanov_flux(u_l, u_r, c_learned)\n        \n        lhs = (v_r - v_l) * flux\n        rhs = entropy_flux(v_r) - entropy_flux(v_l)\n        \n        # Check if lhs = rhs within a small tolerance for floating point arithmetic\n        if lhs > rhs + 1e-12:\n            entropy_inequality_holds = False\n            break\n    \n    entropy_ok = entropy_inequality_holds\n\n    # ----------------------------------------------------------------------\n    # Final Output\n    # ----------------------------------------------------------------------\n    \n    results = [\n        training_mse_baseline,\n        training_mse_learned,\n        test_mae_baseline,\n        test_mae_learned,\n        consistency_ok,\n        entropy_ok\n    ]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3377101"}]}