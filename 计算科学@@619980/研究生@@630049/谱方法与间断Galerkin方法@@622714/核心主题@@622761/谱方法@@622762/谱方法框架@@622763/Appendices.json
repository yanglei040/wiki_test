{"hands_on_practices": [{"introduction": "谱方法的基础在于使用一组精心选择的有限基函数来逼近复杂函数。本练习将深入探讨这一核心概念，要求你在 $L^2$ 范数意义下，找到函数 $\\exp(x)$ 的“最佳”多项式逼近。通过将该函数投影到由勒让德多项式 (Legendre polynomials) 构成的基底上，你将亲身体验正交投影原理，并实践计算谱系数的过程，这是所有伽辽金 (Galerkin) 类型谱方法的基石。[@problem_id:3419277]", "problem": "设 $L^{2}([-1,1])$ 是 $[-1,1]$ 上的平方可积函数所构成的希尔伯特空间，其标准内积为 $\\langle f,g\\rangle=\\int_{-1}^{1} f(x)\\,g(x)\\,dx$。考虑勒让德多项式 $\\{P_{n}(x)\\}_{n\\geq 0}$，它们构成了 $L^{2}([-1,1])$ 中关于权重 $1$ 的一个正交基，满足 $\\int_{-1}^{1} P_{n}(x)\\,P_{m}(x)\\,dx=\\frac{2}{2n+1}\\,\\delta_{nm}$，其具体形式为 $P_{0}(x)=1$，$P_{1}(x)=x$，$P_{2}(x)=\\frac{1}{2}(3x^{2}-1)$，$P_{3}(x)=\\frac{1}{2}(5x^{3}-3x)$。令 $u(x)=\\exp(x)$。\n\n从希尔伯特空间中正交投影的定义以及勒让德基的正交性出发，确定在 $L^{2}([-1,1])$ 中逼近 $u(x)$ 的次数至多为 $N=3$ 的最佳多项式。将该多项式 $p_{3}(x)$ 表示为单个封闭形式的解析表达式。不要四舍五入；请给出精确表达式。", "solution": "该问题陈述经证实是科学上合理的、适定的和客观的。这是数值分析和谱方法领域中逼近理论的一个标准问题。所有必要的数据和定义均已提供，不存在矛盾或歧义。\n\n该问题要求在 $L^2([-1,1])$ 范数下，求函数 $u(x) = \\exp(x)$ 在区间 $[-1,1]$ 上的次数至多为 $N=3$ 的最佳多项式逼近。在希尔伯特空间中，最佳逼近由函数到指定子空间的正交投影给出。在本例中，该子空间是 $\\mathcal{P}_3$，即所有次数至多为 $3$ 的多项式空间。\n\n勒让德多项式 $\\{P_n(x)\\}_{n=0}^{\\infty}$ 构成了 $L^2([-1,1])$ 的一个完备正交基。子空间 $\\mathcal{P}_3$ 由前四个勒让德多项式 $\\{P_0(x), P_1(x), P_2(x), P_3(x)\\}$ 张成。$u(x)$ 到 $\\mathcal{P}_3$ 上的正交投影（记作 $p_3(x)$）由 $u(x)$ 的截断勒让德级数展开给出：\n$$\np_3(x) = \\sum_{n=0}^{3} \\hat{u}_n P_n(x)\n$$\n其中系数 $\\hat{u}_n$ 是 $u(x)$ 关于勒让德基的广义傅里叶系数。这些系数通过内积 $\\langle f,g\\rangle = \\int_{-1}^{1} f(x)g(x)dx$ 计算。\n\n给定正交关系 $\\langle P_n, P_m \\rangle = \\int_{-1}^{1} P_n(x)P_m(x)dx = \\frac{2}{2n+1}\\delta_{nm}$，系数 $\\hat{u}_n$ 通过计算 $u(x)$ 与 $P_n(x)$ 的内积得到：\n$$\n\\langle u, P_n \\rangle = \\left\\langle \\sum_{k=0}^{\\infty} \\hat{u}_k P_k, P_n \\right\\rangle = \\sum_{k=0}^{\\infty} \\hat{u}_k \\langle P_k, P_n \\rangle = \\hat{u}_n \\langle P_n, P_n \\rangle = \\hat{u}_n \\frac{2}{2n+1}\n$$\n这给出了系数的计算公式：\n$$\n\\hat{u}_n = \\frac{\\langle u, P_n \\rangle}{\\langle P_n, P_n \\rangle} = \\frac{2n+1}{2} \\int_{-1}^{1} u(x)P_n(x)dx\n$$\n对于本问题，$u(x) = \\exp(x)$。我们需要计算系数 $\\hat{u}_0, \\hat{u}_1, \\hat{u}_2, \\hat{u}_3$。这需要计算 $n=0, 1, 2, 3$ 时的积分 $\\int_{-1}^{1} \\exp(x) P_n(x) dx$。我们已知：\n$P_0(x) = 1$\n$P_1(x) = x$\n$P_2(x) = \\frac{1}{2}(3x^2 - 1)$\n$P_3(x) = \\frac{1}{2}(5x^3 - 3x)$\n\n为了计算必要的积分，我们首先计算 $\\exp(x)$ 在 $[-1,1]$ 上的矩，即形如 $\\int_{-1}^{1} x^k \\exp(x) dx$ 的积分。这些积分可以通过分部积分法求解。\n令 $I_k = \\int_{-1}^{1} x^k \\exp(x) dx$。\n当 $k=0$ 时：\n$I_0 = \\int_{-1}^{1} \\exp(x) dx = [\\exp(x)]_{-1}^{1} = \\exp(1) - \\exp(-1)$。\n当 $k=1$ 时：\n$I_1 = \\int_{-1}^{1} x \\exp(x) dx = [x\\exp(x) - \\exp(x)]_{-1}^{1} = (1\\exp(1) - \\exp(1)) - (-1\\exp(-1) - \\exp(-1)) = 0 - (-2\\exp(-1)) = 2\\exp(-1)$。\n当 $k=2$ 时：\n$I_2 = \\int_{-1}^{1} x^2 \\exp(x) dx = [(x^2-2x+2)\\exp(x)]_{-1}^{1} = ((1)^2-2(1)+2)\\exp(1) - ((-1)^2-2(-1)+2)\\exp(-1) = (1-2+2)\\exp(1) - (1+2+2)\\exp(-1) = \\exp(1) - 5\\exp(-1)$。\n当 $k=3$ 时：\n$I_3 = \\int_{-1}^{1} x^3 \\exp(x) dx = [(x^3-3x^2+6x-6)\\exp(x)]_{-1}^{1} = ((1)^3-3(1)^2+6(1)-6)\\exp(1) - ((-1)^3-3(-1)^2+6(-1)-6)\\exp(-1) = (1-3+6-6)\\exp(1) - (-1-3-6-6)\\exp(-1) = -2\\exp(1) + 16\\exp(-1)$。\n\n现在我们计算内积 $\\langle \\exp(x), P_n(x) \\rangle$：\n当 $n=0$ 时：$\\langle u, P_0 \\rangle = \\int_{-1}^{1} \\exp(x) \\cdot 1 dx = I_0 = \\exp(1) - \\exp(-1)$。\n当 $n=1$ 时：$\\langle u, P_1 \\rangle = \\int_{-1}^{1} \\exp(x) \\cdot x dx = I_1 = 2\\exp(-1)$。\n当 $n=2$ 时：$\\langle u, P_2 \\rangle = \\int_{-1}^{1} \\exp(x) \\frac{1}{2}(3x^2-1) dx = \\frac{3}{2}I_2 - \\frac{1}{2}I_0 = \\frac{3}{2}(\\exp(1) - 5\\exp(-1)) - \\frac{1}{2}(\\exp(1) - \\exp(-1)) = (\\frac{3}{2}-\\frac{1}{2})\\exp(1) + (-\\frac{15}{2}+\\frac{1}{2})\\exp(-1) = \\exp(1) - 7\\exp(-1)$。\n当 $n=3$ 时：$\\langle u, P_3 \\rangle = \\int_{-1}^{1} \\exp(x) \\frac{1}{2}(5x^3-3x) dx = \\frac{5}{2}I_3 - \\frac{3}{2}I_1 = \\frac{5}{2}(-2\\exp(1) + 16\\exp(-1)) - \\frac{3}{2}(2\\exp(-1)) = -5\\exp(1) + 40\\exp(-1) - 3\\exp(-1) = -5\\exp(1) + 37\\exp(-1)$。\n\n接下来，我们计算系数 $\\hat{u}_n$：\n$\\hat{u}_0 = \\frac{1}{2} \\langle u, P_0 \\rangle = \\frac{1}{2}(\\exp(1) - \\exp(-1))$。\n$\\hat{u}_1 = \\frac{3}{2} \\langle u, P_1 \\rangle = \\frac{3}{2}(2\\exp(-1)) = 3\\exp(-1)$。\n$\\hat{u}_2 = \\frac{5}{2} \\langle u, P_2 \\rangle = \\frac{5}{2}(\\exp(1) - 7\\exp(-1))$。\n$\\hat{u}_3 = \\frac{7}{2} \\langle u, P_3 \\rangle = \\frac{7}{2}(-5\\exp(1) + 37\\exp(-1))$。\n\n最后，我们将这些系数和勒让德多项式的具体形式代入求和式中，然后根据 $x$ 的幂次合并同类项，从而构造出多项式 $p_3(x)$。\n$$\np_3(x) = \\hat{u}_0 P_0(x) + \\hat{u}_1 P_1(x) + \\hat{u}_2 P_2(x) + \\hat{u}_3 P_3(x)\n$$\n$$\np_3(x) = \\hat{u}_0(1) + \\hat{u}_1(x) + \\hat{u}_2\\left(\\frac{3}{2}x^2 - \\frac{1}{2}\\right) + \\hat{u}_3\\left(\\frac{5}{2}x^3 - \\frac{3}{2}x\\right)\n$$\n该多项式为 $p_3(x) = c_3x^3 + c_2x^2 + c_1x + c_0$，其中系数为：\n$c_3 = \\frac{5}{2}\\hat{u}_3 = \\frac{5}{2} \\cdot \\frac{7}{2}(-5\\exp(1) + 37\\exp(-1)) = \\frac{35}{4}(-5\\exp(1) + 37\\exp(-1)) = \\frac{-175\\exp(1) + 1295\\exp(-1)}{4}$。\n$c_2 = \\frac{3}{2}\\hat{u}_2 = \\frac{3}{2} \\cdot \\frac{5}{2}(\\exp(1) - 7\\exp(-1)) = \\frac{15}{4}(\\exp(1) - 7\\exp(-1)) = \\frac{15\\exp(1) - 105\\exp(-1)}{4}$。\n$c_1 = \\hat{u}_1 - \\frac{3}{2}\\hat{u}_3 = 3\\exp(-1) - \\frac{3}{2} \\cdot \\frac{7}{2}(-5\\exp(1) + 37\\exp(-1)) = 3\\exp(-1) - \\frac{21}{4}(-5\\exp(1) + 37\\exp(-1)) = \\frac{12\\exp(-1) + 105\\exp(1) - 777\\exp(-1)}{4} = \\frac{105\\exp(1) - 765\\exp(-1)}{4}$。\n$c_0 = \\hat{u}_0 - \\frac{1}{2}\\hat{u}_2 = \\frac{1}{2}(\\exp(1) - \\exp(-1)) - \\frac{1}{2} \\cdot \\frac{5}{2}(\\exp(1) - 7\\exp(-1)) = \\frac{1}{2}(\\exp(1) - \\exp(-1)) - \\frac{5}{4}(\\exp(1) - 7\\exp(-1)) = \\frac{2(\\exp(1) - \\exp(-1)) - 5(\\exp(1) - 7\\exp(-1))}{4} = \\frac{2\\exp(1) - 2\\exp(-1) - 5\\exp(1) + 35\\exp(-1)}{4} = \\frac{-3\\exp(1) + 33\\exp(-1)}{4}$。\n\n因此，次数至多为 $3$ 的最佳 $L^2$ 多项式逼近为：\n$$\np_3(x) = \\left(\\frac{-175\\exp(1) + 1295\\exp(-1)}{4}\\right)x^3 + \\left(\\frac{15\\exp(1) - 105\\exp(-1)}{4}\\right)x^2 + \\left(\\frac{105\\exp(1) - 765\\exp(-1)}{4}\\right)x + \\left(\\frac{-3\\exp(1) + 33\\exp(-1)}{4}\\right)\n$$", "answer": "$$\n\\boxed{\\left(\\frac{-175\\exp(1) + 1295\\exp(-1)}{4}\\right)x^3 + \\left(\\frac{15\\exp(1) - 105\\exp(-1)}{4}\\right)x^2 + \\left(\\frac{105\\exp(1) - 765\\exp(-1)}{4}\\right)x + \\left(\\frac{-3\\exp(1) + 33\\exp(-1)}{4}\\right)}\n$$", "id": "3419277"}, {"introduction": "为了有效求解微分方程，我们不仅需要逼近函数本身，还需要高精度地逼近其导数。本练习将从函数逼近过渡到微分计算这一关键任务，介绍强大的谱配置法 (spectral collocation method)。你将在切比雪夫点 (Chebyshev points) 上构建一个微分矩阵，并用它来计算一个已知函数的导数，从而亲眼见证这些方法标志性的“谱精度”，并验证其对多项式的微分是精确的。[@problem_id:3419278]", "problem": "您需要在谱方法框架内，使用 Chebyshev–Gauss–Lobatto 点实现一个多项式配置方案。重点是通过对拉格朗日插值多项式进行微分，构建一个将节点值映射到导数节点值的微分矩阵。此设定纯属数学性质，不涉及物理单位，但所有三角函数求值都必须使用弧度。\n\n从区间 $[-1,1]$ 上节点处的多项式插值定义出发，并基于插值多项式在节点处的导数可以表示为作用于节点值的线性算子这一原理，推导并实现以下内容：\n\n1. 在 $[-1,1]$ 上生成 Chebyshev–Gauss–Lobatto 节点 $\\{x_j\\}_{j=0}^N$。\n2. 从拉格朗日插值及其重心形式的基本定义出发，推导并构建微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，使得对于一个光滑函数 $u$，向量 $D\\,\\mathbf{u}$ 能够逼近 $u'(x)$ 的节点值，其中 $\\mathbf{u} = \\big(u(x_0),\\ldots,u(x_N)\\big)^\\top$。\n3. 考虑常微分方程 $u'(x) = \\sin(x)$，并设 $u(x) = -\\cos(x)$ 以使得 $u'(x) = \\sin(x)$ 精确成立。使用所构建的微分矩阵 $D$，计算无穷范数误差 $E_N = \\|D\\,\\mathbf{u} - \\boldsymbol{\\sin}\\|_\\infty$，其中 $\\boldsymbol{\\sin} = \\big(\\sin(x_0),\\ldots,\\sin(x_N)\\big)^\\top$，范数为最大绝对值项。所有三角函数求值均使用弧度。\n4. 计算谱半径 $\\rho(D)$，其定义为矩阵 $D$ 特征值的最大绝对值。\n5. 通过测试 $u(x) = x^3$ 来验证微分矩阵对于次数至多为 $N$ 的多项式的精确性，并检查是否满足 $\\|D\\,\\mathbf{u} - \\mathbf{v}\\|_\\infty  10^{-12}$，其中 $\\mathbf{v} = \\big(3 x_0^2,\\ldots,3 x_N^2\\big)^\\top$。如果此条件成立，则返回布尔值 true，否则返回 false。\n\n使用以下测试套件，该套件探索一个一般情况、一个边界情况和一个精度趋势情况：\n- 情况1：$N=8$（一般情况）。计算 $u(x)=-\\cos(x)$ 时的 $E_8$、$\\rho(D)$，以及对 $u(x)=x^3$ 在容差 $10^{-12}$ 下的布尔精确性检查。\n- 情况2：$N=1$（含两个节点的边界情况）。计算 $u(x)=-\\cos(x)$ 时的 $E_1$。\n- 情况3：$N=32$（更高分辨率情况）。计算 $u(x)=-\\cos(x)$ 时的 $E_{32}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：$[E_8,\\rho(D_8),\\text{poly\\_exact\\_N8},E_1,E_{32}]$，其中 $E_8$、$\\rho(D_8)$、$E_1$ 和 $E_{32}$ 为浮点数，而 $\\text{poly\\_exact\\_N8}$ 为布尔值。", "solution": "多项式配置微分的基本原理是函数在指定节点上的拉格朗日插值，以及由此产生的将节点值映射到插值多项式在节点处导数的线性算子。选择 Chebyshev–Gauss–Lobatto 节点是因为它们在 $[-1,1]$ 区间上的多项式逼近中具有最优性质。我们从第一性原理出发，步骤如下。\n\n1. Chebyshev–Gauss–Lobatto 节点。对于给定的整数 $N \\geq 1$，节点定义为\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N}\\right), \\quad j=0,1,\\ldots,N,\n$$\n这些节点位于 $[-1,1]$ 区间内，并包括端点 $x_0=1$ 和 $x_N=-1$。这些节点是 $(1-x^2)T'_N(x)$ 的根，其中 $T_N(x)$ 是 $N$ 次第一类切比雪夫多项式，这确保了节点分布有利于谱插值。\n\n2. 拉格朗日插值和重心权重。对于节点 $\\{x_j\\}_{j=0}^N$ 上的节点值 $\\{u_j\\}_{j=0}^N$，次数至多为 $N$ 的拉格朗日插值多项式 $p(x)$ 为\n$$\np(x) = \\sum_{j=0}^N u_j \\ell_j(x),\n$$\n其中 $\\ell_j(x)$ 是拉格朗日基多项式，满足 $\\ell_j(x_k) = \\delta_{jk}$，$\\delta_{jk}$ 为克罗内克 δ 符号。在重心形式中，仅根据节点定义重心权重 $\\{\\lambda_j\\}_{j=0}^N$，插值多项式便可以稳定地表示和求值。对于 Chebyshev–Gauss–Lobatto 节点，从拉格朗日基的乘积形式推导出的重心权重可选择为\n$$\n\\lambda_j = (-1)^j \\alpha_j, \\quad \\alpha_j = \\begin{cases}\n\\frac{1}{2},  j=0 \\text{ 或 } j=N,\\\\\n1,  \\text{其他情况}.\n\\end{cases}\n$$\n此选择源于 $(1-x^2)T'_N(x)$ 的导数以及节点间距与定义 $\\ell_j(x)$ 的乘积之间的关系。\n\n3. 从重心权重构建微分矩阵。对 $p(x)$ 进行微分并在节点处求值，可得到一个从节点向量 $\\mathbf{u} = (u_0,\\ldots,u_N)^\\top$ 到节点导数向量 $(p'(x_0),\\ldots,p'(x_N))^\\top$ 的线性映射。该映射由一个矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 表示，定义为\n$$\np'(x_j) = \\sum_{k=0}^N D_{jk} u_k.\n$$\n根据重心表示法和 $\\ell_j'(x)$ 在节点处的基本恒等式，对于 $j \\neq k$：\n$$\nD_{jk} = \\frac{\\lambda_k}{\\lambda_j} \\cdot \\frac{1}{x_j - x_k},\n$$\n对角线元素则由常数微分精确性所带来的行和为零的约束条件得出：\n$$\nD_{jj} = -\\sum_{k=0, k\\neq j}^N D_{jk}.\n$$\n此构造是通过对拉格朗日重心形式进行微分，并利用恒等式 $\\sum_{k=0}^N \\ell_k(x) \\equiv 1$ 及其导数 $\\sum_{k=0}^N \\ell_k'(x) \\equiv 0$ 推导得出的，这意味着 $D \\mathbf{1} = \\mathbf{0}$，因此每行之和为零。\n\n尽管 Chebyshev–Gauss–Lobatto 节点存在闭式对角线元素（例如，$D_{00} = \\frac{2N^2+1}{6}$，$D_{NN} = -\\frac{2N^2+1}{6}$，以及对于 $1 \\le j \\le N-1$ 有 $D_{jj} = -\\frac{x_j}{2(1-x_j^2)}$），但上述基于重心权重的构造方法在数值上是鲁棒的，并且避免了显式的端点奇异公式。\n\n4. 针对 $u'(x) = \\sin(x)$ 的配置。选择 $u(x) = -\\cos(x)$ 以使得 $u'(x) = \\sin(x)$ 精确成立。在节点 $\\{x_j\\}$ 处，定义节点值 $\\mathbf{u} = \\big(u(x_0),\\ldots,u(x_N)\\big)^\\top = \\big(-\\cos(x_0),\\ldots,-\\cos(x_N)\\big)^\\top$。精确的导数节点向量为 $\\boldsymbol{\\sin} = \\big(\\sin(x_0),\\ldots,\\sin(x_N)\\big)^\\top$。微分矩阵作用于 $\\mathbf{u}$ 得到插值多项式在节点处的导数；与精确导数的偏差即为插值-微分误差：\n$$\nE_N = \\|D\\,\\mathbf{u} - \\boldsymbol{\\sin}\\|_\\infty = \\max_{0 \\le j \\le N} \\left| \\sum_{k=0}^N D_{jk} u_k - \\sin(x_j) \\right|.\n$$\n所有三角函数求值均以弧度为单位。\n\n5. 谱半径。谱半径 $\\rho(D)$ 定义为\n$$\n\\rho(D) = \\max_{1 \\le i \\le N+1} |\\lambda_i(D)|,\n$$\n其中 $\\{\\lambda_i(D)\\}$ 是 $D$ 的特征值。此量表征了微分算子的大小，并与稳定性分析相关。\n\n6. 多项式精确性验证。对于 $u(x) = x^3$，当 $N \\ge 3$ 时，插值多项式与 $u(x)$ 完全匹配。其导数 $u'(x) = 3x^2$ 也是一个次数至多为 $N$ 的多项式（对于任何 $N \\ge 3$）。因此，对于这样的 $u$，配置微分必须能得到精确的节点导数值。我们计算\n$$\nE_N^{(3)} = \\|D\\,\\mathbf{u} - \\mathbf{v}\\|_\\infty, \\quad \\mathbf{u} = (x_0^3,\\ldots,x_N^3)^\\top, \\quad \\mathbf{v} = (3x_0^2,\\ldots,3x_N^2)^\\top,\n$$\n并验证 $E_N^{(3)}  10^{-12}$ 是否成立，返回一个布尔结果。\n\n7. 测试套件和输出。我们实现上述构造并报告：\n- 对于 $N=8$：计算 $u(x)=-\\cos(x)$ 时的 $E_8$、$\\rho(D_8)$，以及对 $u(x)=x^3$ 在容差 $10^{-12}$ 下的布尔精确性检查。\n- 对于 $N=1$：计算 $u(x)=-\\cos(x)$ 时的 $E_1$。\n- 对于 $N=32$：计算 $u(x)=-\\cos(x)$ 时的 $E_{32}$。\n\n最终程序以精确格式输出单行结果\n$$\n[E_8,\\rho(D_8),\\text{poly\\_exact\\_N8},E_1,E_{32}],\n$$\n其中 $E_8$、$\\rho(D_8)$、$E_1$ 和 $E_{32}$ 为浮点数，而 $\\text{poly\\_exact\\_N8}$ 为布尔值。\n\n算法步骤：\n- 通过 $x_j = \\cos(\\pi j/N)$ 计算 $\\{x_j\\}_{j=0}^N$。\n- 计算重心权重 $\\lambda_j = (-1)^j \\alpha_j$，其中 $\\alpha_0=\\alpha_N=\\frac{1}{2}$，对于 $1 \\le j \\le N-1$ 有 $\\alpha_j=1$。\n- 构造矩阵 $D$，其非对角线元素为 $D_{jk} = \\frac{\\lambda_k}{\\lambda_j}\\frac{1}{x_j-x_k}$（$j \\ne k$），对角线元素为 $D_{jj} = -\\sum_{k \\ne j} D_{jk}$。\n- 对于 $u(x)=-\\cos(x)$，以弧度为单位计算 $\\mathbf{u}$ 和 $\\boldsymbol{\\sin}$，通过无穷范数计算 $E_N$。\n- 计算 $\\rho(D)$ 为 $D$ 特征值的最大绝对值。\n- 计算 $u(x)=x^3$ 的情况，计算 $E_N^{(3)}$，并与 $10^{-12}$ 比较以获得布尔精确性结果。\n\n此方法遵循谱方法框架，并利用关于切比雪夫多项式和重心插值的成熟理论来构造一个鲁棒的微分算子，而无需依赖任何未经推导的捷径公式。", "answer": "```python\nimport numpy as np\n\ndef chebyshev_gauss_lobatto_nodes(N: int) - np.ndarray:\n    # x_j = cos(pi*j/N), j=0..N\n    j = np.arange(N + 1)\n    return np.cos(np.pi * j / N)\n\ndef barycentric_weights_cgl(N: int) - np.ndarray:\n    # lambda_j = (-1)^j * alpha_j, alpha_0 = alpha_N = 1/2, else 1\n    j = np.arange(N + 1)\n    w = np.ones(N + 1)\n    if N == 0:\n        # Degenerate case, not used in our tests\n        return w\n    w[0] = 0.5\n    w[-1] = 0.5\n    w *= (-1.0) ** j\n    return w\n\ndef differentiation_matrix_from_weights(x: np.ndarray, w: np.ndarray) - np.ndarray:\n    # Construct D with off-diagonal entries via barycentric weights and diagonal by row-sum zero\n    Np1 = x.size\n    Xdiff = x[:, None] - x[None, :]\n    # Avoid division by zero on diagonal by setting placeholder\n    np.fill_diagonal(Xdiff, 1.0)\n    wratio = (w[None, :]) / (w[:, None])\n    D = wratio / Xdiff\n    # Zero out diagonal temporarily\n    np.fill_diagonal(D, 0.0)\n    # Set diagonal as negative row sum\n    D[np.arange(Np1), np.arange(Np1)] = -np.sum(D, axis=1)\n    return D\n\ndef max_abs_error(D: np.ndarray, u_nodes: np.ndarray, exact_nodes: np.ndarray) - float:\n    approx = D @ u_nodes\n    return float(np.max(np.abs(approx - exact_nodes)))\n\ndef spectral_radius(D: np.ndarray) - float:\n    eigvals = np.linalg.eigvals(D)\n    return float(np.max(np.abs(eigvals)))\n\ndef test_case_errors(N: int):\n    x = chebyshev_gauss_lobatto_nodes(N)\n    w = barycentric_weights_cgl(N)\n    D = differentiation_matrix_from_weights(x, w)\n    # Test function u(x) = -cos(x), u'(x) = sin(x), angles in radians\n    u_nodes = -np.cos(x)\n    exact_nodes = np.sin(x)\n    E = max_abs_error(D, u_nodes, exact_nodes)\n    return D, E\n\ndef polynomial_exactness_boolean(D: np.ndarray, x: np.ndarray, tol: float = 1e-12) - bool:\n    # u(x) = x^3, u'(x) = 3x^2\n    u_nodes = x**3\n    exact_nodes = 3.0 * x**2\n    err = np.max(np.abs(D @ u_nodes - exact_nodes))\n    return bool(err  tol)\n\ndef solve():\n    results = []\n\n    # Case 1: N = 8\n    N1 = 8\n    x8 = chebyshev_gauss_lobatto_nodes(N1)\n    D8, E8 = test_case_errors(N1)\n    rho8 = spectral_radius(D8)\n    poly_exact_N8 = polynomial_exactness_boolean(D8, x8, tol=1e-12)\n    results.append(E8)\n    results.append(rho8)\n    results.append(poly_exact_N8)\n\n    # Case 2: N = 1 (boundary case)\n    N2 = 1\n    D1, E1 = test_case_errors(N2)\n    results.append(E1)\n\n    # Case 3: N = 32 (higher resolution case)\n    N3 = 32\n    D32, E32 = test_case_errors(N3)\n    results.append(E32)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3419278"}, {"introduction": "经典的谱方法在简单区域上表现出色，但实际应用要求具备处理复杂几何形状的能力。这个高级练习将探索等参映射 (isoparametric mapping) 技术，这是谱元法 (spectral element method) 的基石，它能将简单的参考单元变形为所需的物理形状。通过分析几何变形如何影响格拉姆矩阵 (Gram matrix)，你将对在非平凡区域上应用谱方法所面临的挑战与权衡获得关键的洞察。[@problem_id:3419299]", "problem": "要求您为参考正方形内的单个四边形单元设计和分析一个等参谱元映射，并量化映射雅可比行列式的变化如何影响模态基的正交性和条件数。分析必须完全以数学术语进行，最终的数值结果必须由一个完整的、可运行的程序产生。\n\n从以下基本设定开始：\n- 参考单元是边长为 $[-1,1] \\times [-1,1]$ 的正方形，坐标为 $(\\xi, \\eta)$。\n- 等参映射 $F : [-1,1]^2 \\to \\mathbb{R}^2$ 由与解空间相同的多项式基表示（等参特性）。具体来说，使用与一维节点 $\\{-1,0,1\\}$ 相关联的次数为 $2$ 的张量积 Lagrange 基。\n- 对于任何映射 $F$，线元变换遵循积分的变量替换法则，因此对于拉回到参考单元上的任何函数 $u(\\xi,\\eta)$ 和 $v(\\xi,\\eta)$，它们在物理单元上的内积由下式给出\n$$\n\\langle u, v \\rangle_F = \\int_{-1}^1 \\int_{-1}^1 u(\\xi, \\eta)\\, v(\\xi, \\eta)\\, J(\\xi, \\eta)\\, d\\xi\\, d\\eta,\n$$\n其中 $J(\\xi,\\eta)$ 表示映射 $F$ 在 $(\\xi,\\eta)$ 处的雅可比行列式。\n- 一维模态基是在 $[-1,1]$ 上的一组归一化 Legendre 多项式 $\\{\\phi_n(x)\\}_{n=0}^{N-1}$，其中\n$$\n\\phi_n(x) = \\sqrt{\\frac{2n+1}{2}}\\, P_n(x),\n$$\n其中 $P_n(x)$ 是第 $n$ 阶 Legendre 多项式。这组基在参考区间上的标准 $L^2$ 内积下是标准正交的。参考正方形上的二维模态基是张量积\n$$\n\\psi_{i,j}(\\xi,\\eta) = \\phi_i(\\xi)\\, \\phi_j(\\eta), \\quad i,j \\in \\{0,1,\\dots,N-1\\}.\n$$\n- 在映射内积下的正交性由 Gram 矩阵 $G$ 表征，其元素为\n$$\nG_{(i,j),(p,q)} = \\int_{-1}^1 \\int_{-1}^1 \\psi_{i,j}(\\xi,\\eta)\\, \\psi_{p,q}(\\xi,\\eta)\\, J(\\xi,\\eta)\\, d\\xi\\, d\\eta,\n$$\n如果 $J(\\xi,\\eta)$ 是常数，该矩阵将简化为一个缩放的单位矩阵。$J$ 与常数的偏差会引入非对角耦合，并改变 $G$ 的条件数。\n\n设计要求和任务：\n1. 构建一个多项式次数为 $2$ 的等参映射，使用每个坐标上节点为 $\\{-1,0,1\\}$ 的张量积 Lagrange 基。定义物理节点 $\\mathbf{P}_{ij}$，$i,j \\in \\{0,1,2\\}$，使得角点形成一个由失真参数 $\\,\\alpha \\in \\mathbb{R}\\,$ 决定的梯形，并引入一个内部失真控制参数 $\\,\\beta \\in \\mathbb{R}\\,$，该参数仅移动中心节点，同时保持所有边是直的：\n   - 角节点为\n     $$\n     \\mathbf{P}_{00}=(0,0),\\quad \\mathbf{P}_{20}=(1,0),\\quad \\mathbf{P}_{22}=(1,1),\\quad \\mathbf{P}_{02}=(0,1+\\alpha).\n     $$\n   - 边中点是其各自角端点的共线中点：\n     $$\n     \\mathbf{P}_{10}=(0.5,0),\\quad \\mathbf{P}_{21}=(1,0.5),\\quad \\mathbf{P}_{12}=(0.5,1+\\alpha/2),\\quad \\mathbf{P}_{01}=(0,0.5+\\alpha/2).\n     $$\n   - 中心节点为\n     $$\n     \\mathbf{P}_{11}=(0.5,0.5+\\alpha/2+\\beta/4).\n     $$\n   映射 $F(\\xi,\\eta)$ 则为\n   $$\n   F(\\xi,\\eta) = \\sum_{i=0}^2 \\sum_{j=0}^2 L_i(\\xi)\\, L_j(\\eta)\\, \\mathbf{P}_{ij},\n   $$\n   其中 $L_0(x)=\\frac{x(x-1)}{2}$、$L_1(x)=1-x^2$ 和 $L_2(x)=\\frac{x(x+1)}{2}$ 是与节点 $-1,0,1$ 相关联的次数为 $2$ 的 Lagrange 基多项式。\n\n2. 使用以下公式计算雅可比行列式 $J(\\xi,\\eta)$：\n   $$\n   J(\\xi,\\eta) = \\det\\left( \\begin{bmatrix} \\dfrac{\\partial x}{\\partial \\xi}  \\dfrac{\\partial x}{\\partial \\eta} \\\\ \\dfrac{\\partial y}{\\partial \\xi}  \\dfrac{\\partial y}{\\partial \\eta} \\end{bmatrix} \\right),\n   $$\n   其中 $(x(\\xi,\\eta),y(\\xi,\\eta)) = F(\\xi,\\eta)$。对于每个测试用例，用数值方法确认在参考正方形上 $J(\\xi,\\eta) > 0$。\n\n3. 将模态基的大小固定为 $N=3$，即每个方向三个模态，得到一个大小为 $9$ 的二维基。使用在 $[-1,1]$ 上足够高阶的张量积 Gaussian 求积法构建映射内积的 Gram 矩阵 $G$，并量化：\n   - 通过归一化 Frobenius 非对角范数度量正交性退化\n     $$\n     E = \\frac{\\left\\| G - \\mathrm{diag}(\\mathrm{diag}(G)) \\right\\|_F}{\\left\\| \\mathrm{diag}(\\mathrm{diag}(G)) \\right\\|_F}.\n     $$\n   - 通过谱条件数度量条件数\n     $$\n     \\kappa_2(G) = \\frac{\\sigma_{\\max}(G)}{\\sigma_{\\min}(G)},\n     $$\n     其中 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 是 $G$ 在欧几里得范数下的最大和最小奇异值。\n\n4. 在单个独立的程序中实现上述所有内容。对 $L_i(x)$ 及其导数使用精确的多项式表达式。对模态基使用归一化的 Legendre 多项式。当 $N=3$ 且几何映射次数为 $2$ 时，使用足够高阶的张量积 Gaussian 求积法来解析积分。\n\n5. 使用以下失真参数 $(\\alpha,\\beta)$ 测试套件：\n   - 测试用例 1：$(\\alpha,\\beta)=(0.0,0.0)$。\n   - 测试用例 2：$(\\alpha,\\beta)=(0.3,0.0)$。\n   - 测试用例 3：$(\\alpha,\\beta)=(0.0,0.4)$。\n   - 测试用例 4：$(\\alpha,\\beta)=(0.3,0.4)$。\n   - 测试用例 5：$(\\alpha,\\beta)=(0.4,-0.3)$。\n\n6. 对于每个测试用例，计算 $E$ 和 $\\kappa_2(G)$ 作为实数。您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序为 $[E_1,\\kappa_2(G)_1,E_2,\\kappa_2(G)_2,\\dots,E_5,\\kappa_2(G)_5]$。此问题不涉及任何物理单位；所有量均为无量纲实数。\n\n您的最终程序必须用 Python 编写，并遵守后面描述的执行环境。不允许用户输入或外部文件。", "solution": "用户提供了一个计算数学领域中明确定义的问题，具体涉及等参谱元法。任务是分析几何失真对模态基性质的影响。问题陈述的验证如下：\n\n### 第 1 步：提取已知条件\n- **参考单元**：边长为 $[-1,1] \\times [-1,1]$ 的正方形，坐标为 $(\\xi, \\eta)$。\n- **等参映射**：$F : [-1,1]^2 \\to \\mathbb{R}^2$，由次数为 $2$ 的张量积 Lagrange 基定义。\n- **Lagrange 基多项式** (对于节点 $\\{-1,0,1\\}$)：\n    - $L_0(x)=\\frac{x(x-1)}{2}$\n    - $L_1(x)=1-x^2$\n    - $L_2(x)=\\frac{x(x+1)}{2}$\n- **物理节点** $\\mathbf{P}_{ij}$，其中 $i,j \\in \\{0,1,2\\}$：\n    - 角点：$\\mathbf{P}_{00}=(0,0)$, $\\mathbf{P}_{20}=(1,0)$, $\\mathbf{P}_{22}=(1,1)$, $\\mathbf{P}_{02}=(0,1+\\alpha)$。\n    - 边中点：$\\mathbf{P}_{10}=(0.5,0)$, $\\mathbf{P}_{21}=(1,0.5)$, $\\mathbf{P}_{12}=(0.5,1+\\alpha/2)$, $\\mathbf{P}_{01}=(0,0.5+\\alpha/2)$。\n    - 中心点：$\\mathbf{P}_{11}=(0.5,0.5+\\alpha/2+\\beta/4)$。\n- **映射公式**：$F(\\xi,\\eta) = \\sum_{i=0}^2 \\sum_{j=0}^2 L_i(\\xi)\\, L_j(\\eta)\\, \\mathbf{P}_{ij}$。\n- **内积**：$\\langle u, v \\rangle_F = \\int_{-1}^1 \\int_{-1}^1 u(\\xi, \\eta)\\, v(\\xi, \\eta)\\, J(\\xi, \\eta)\\, d\\xi\\, d\\eta$。\n- **雅可比行列式**：$J(\\xi,\\eta) = \\det\\left( \\begin{bmatrix} \\partial x/\\partial \\xi  \\partial x/\\partial \\eta \\\\ \\partial y/\\partial \\xi  \\partial y/\\partial \\eta \\end{bmatrix} \\right)$。\n- **模态基**：\n    - 一维基：归一化 Legendre 多项式 $\\phi_n(x) = \\sqrt{\\frac{2n+1}{2}}\\, P_n(x)$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。\n    - 二维基：张量积 $\\psi_{i,j}(\\xi,\\eta) = \\phi_i(\\xi)\\, \\phi_j(\\eta)$，其中 $i,j \\in \\{0,1,\\dots,N-1\\}$，且 $N=3$。\n- **Gram 矩阵**：$G_{(i,j),(p,q)} = \\langle \\psi_{i,j}, \\psi_{p,q} \\rangle_F$。\n- **量化指标**：\n    - 正交性退化：$E = \\frac{\\left\\| G - \\mathrm{diag}(\\mathrm{diag}(G)) \\right\\|_F}{\\left\\| \\mathrm{diag}(\\mathrm{diag}(G)) \\right\\|_F}$。\n    - 条件数：$\\kappa_2(G) = \\sigma_{\\max}(G) / \\sigma_{\\min}(G)$。\n- **计算方法**：使用足够高阶的张量积 Gaussian 求积法。\n- **测试用例** $(\\alpha, \\beta)$：$(0.0,0.0)$, $(0.3,0.0)$, $(0.0,0.4)$, $(0.3,0.4)$, $(0.4,-0.3)$。\n- **输出格式**：单行 `[E_1,k_1,E_2,k_2,...,E_5,k_5]`。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题具有科学依据、是适定且客观的。它描述了谱元法分析中的一个标准过程。\n- **科学合理性**：所使用的概念（等参映射、Lagrange 基、Legendre 多项式、雅可比行列式、Gram 矩阵、Gaussian 求积）都是数值分析和逼近理论中的标准和正确元素。\n- **完整性和一致性**：提供了所有必要的公式、参数和定义。节点、映射和基的定义明确无误。任务陈述清晰。没有矛盾之处。\n- **适定性**：任务涉及从一组给定的参数计算明确定义的数学量（$E$ 和 $\\kappa_2(G)$）。每个测试用例都存在唯一的解。\n- **求积阶数**：Gram 矩阵的被积函数为 $\\psi_{i,j} \\psi_{p,q} J$。基函数 $\\psi$ 是次数最高为 $N-1=2$ 的多项式。映射由次数为 2 的 Lagrange 多项式构建。映射的偏导数，例如 $\\partial x / \\partial \\xi$，是关于 $\\xi$ 的 1 次多项式和关于 $\\eta$ 的 2 次多项式。因此，雅可比行列式 $J$ 是关于 $\\xi$ 和 $\\eta$ 次数最高都为 $(1+2)=3$ 的多项式。基函数之积 $\\psi_{i,j}\\psi_{p,q}$ 在每个变量上的次数最高为 $(2+2)=4$。因此，总被积函数在每个变量上的多项式次数最高为 $(4+3)=7$。具有 $Q$ 个点的 Gaussian 求积法则对于次数最高为 $2Q-1$ 的多项式是精确的。为了对次数为 7 的多项式精确，我们需要 $2Q-1 \\geq 7$，这意味着 $Q \\geq 4$。对于张量积求积，在每个方向上选择 $Q=5$ 个点是足够的。\n\n### 第 3 步：结论和行动\n该问题是**有效的**。这是一个计算数学中的标准、适定的问题。我将继续提供一个完整的解决方案。\n\n### 解决方案设计\n解决方案的实现遵循问题陈述中概述的任务。实现的核心是遍历由失真参数 $(\\alpha, \\beta)$ 定义的五个测试用例。对于每个用例，执行以下步骤：\n\n1.  **定义几何形状**：根据给定的 $\\alpha$ 和 $\\beta$ 值，构建物理节点坐标的 $3 \\times 3$ 网格 $\\mathbf{P}_{ij} = (x_{ij}, y_{ij})$。\n\n2.  **设置求积**：我们使用张量积 Gauss-Legendre 求积法则。根据上述分析，选择在每个方向上有 $Q=5$ 个点（一个 $5 \\times 5$ 的网格）的法则，以确保 Gram 矩阵的积分计算具有足够的精度。求积点和权重通过 `scipy.special.roots_legendre` 获得。\n\n3.  **计算雅可比行列式**：等参映射由 $F(\\xi,\\eta) = (x(\\xi,\\eta), y(\\xi,\\eta))$ 给出。偏导数，例如 $\\frac{\\partial x}{\\partial \\xi} = \\sum_{i,j} L'_i(\\xi) L_j(\\eta) x_{ij}$，在每个 $Q \\times Q$ 求积点上进行计算。这可以通过使用 NumPy 的 `einsum` 函数高效完成，该函数执行广义张量缩并。然后，在每个求积点上计算雅可比行列式 $J(\\xi,\\eta)$。检查确认对于所有测试用例，在单元上 $J  0$，确保映射是有效的（非退化的）。\n\n4.  **组装 Gram 矩阵**：模态基由 $N^2 = 3^2 = 9$ 个函数组成，即 $\\psi_{i,j}(\\xi,\\eta) = \\phi_i(\\xi)\\phi_j(\\eta)$，其中 $i,j \\in \\{0,1,2\\}$。归一化的 Legendre 多项式 $\\phi_n$ 在一维求积点上进行求值。大小为 $9 \\times 9$ 的 Gram 矩阵 $G$ 的元素为 $G_{m,n} = \\int_{-1}^1\\int_{-1}^1 \\psi_m \\psi_n J \\, d\\xi d\\eta$，其中 $m, n$ 是基函数的线性索引。该矩阵通过对每个求积点的贡献进行求和来组装，贡献值由求积权重和雅可比行列式的乘积进行加权。这个求和过程也得到了高效的实现。例如，通过预先计算所有基函数在所有求积点的值，然后使用 `einsum` 或向量化的矩阵运算来计算最终的和。从二维基索引 $(i,j)$ 到一维索引 $m$ 的线性映射是 $m = 3i+j$。\n\n5.  **计算指标**：\n    - 正交性退化 $E$ 是通过首先将 Gram 矩阵分解为其对角部分和非对角部分 $G = D + G_{\\text{off}}$ 来计算的。$D$ 和 $G_{\\text{off}}$ 的 Frobenius 范数使用 `numpy.linalg.norm` 计算，它们的比值即为 $E$。\n    - 谱条件数 $\\kappa_2(G)$ 使用 `numpy.linalg.cond`（参数为 `p=2`）计算，该函数计算 $G$ 的最大奇异值与最小奇异值之比。\n\n6.  **存储和格式化输出**：为每个测试用例计算的 $E$ 和 $\\kappa_2(G)$ 的值被收集起来，并在执行结束时以指定的逗号分隔格式打印。对于参考用例 $(\\alpha, \\beta)=(0,0)$，映射是仿射的，雅可比行列式是常数，Gram 矩阵是对角矩阵。这导致 $E=0$ 和 $\\kappa_2(G)=1$，这可以作为基准和实现验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre, roots_legendre\n\ndef solve():\n    \"\"\"\n    Solves the isoparametric spectral element mapping problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 0.0),\n        (0.3, 0.0),\n        (0.0, 0.4),\n        (0.3, 0.4),\n        (0.4, -0.3),\n    ]\n\n    results = []\n\n    # Constants for the problem\n    N_modes_1D = 3  # N=3, so modes are for n=0, 1, 2\n    N_basis = N_modes_1D * N_modes_1D\n\n    # Determine required quadrature order.\n    # Integrand involves product of four basis polynomials (max deg 2+2=4 in each variable)\n    # and the Jacobian (max deg 3 in each variable).\n    # Total integrand degree is at most 7.\n    # Gaussian quadrature with Q points is exact up to degree 2Q-1.\n    # 2Q-1 = 7  =  Q = 4. We choose Q=5 for safety.\n    Q = 5\n    q_pts, q_w = roots_legendre(Q)\n\n    # Define Lagrange basis polynomials and their derivatives for nodes {-1, 0, 1}\n    # L0 is for node -1, L1 for 0, L2 for 1\n    def L0(x): return x * (x - 1) / 2\n    def L1(x): return 1 - x**2\n    def L2(x): return x * (x + 1) / 2\n    \n    def L0_p(x): return x - 0.5\n    def L1_p(x): return -2 * x\n    def L2_p(x): return x + 0.5\n\n    # Pre-evaluate Lagrange polynomials and their derivatives at 1D quadrature points\n    L_vals = np.array([L0(q_pts), L1(q_pts), L2(q_pts)])  # Shape (3, Q)\n    L_deriv_vals = np.array([L0_p(q_pts), L1_p(q_pts), L2_p(q_pts)])  # Shape (3, Q)\n\n    # Pre-evaluate normalized Legendre polynomials at 1D quadrature points\n    phi_vals = np.zeros((N_modes_1D, Q))\n    for n in range(N_modes_1D):\n        Pn = legendre(n)\n        phi_vals[n, :] = np.sqrt((2 * n + 1) / 2) * Pn(q_pts)\n    \n    # Pre-evaluate 2D basis functions at all quadrature points\n    # psi_full[m, k, l] is value of basis function m at qp (q_pts[k], q_pts[l])\n    psi_full = np.zeros((N_basis, Q, Q))\n    for i in range(N_modes_1D):\n        for j in range(N_modes_1D):\n            m = i * N_modes_1D + j  # Row-major linear index\n            psi_full[m, :, :] = np.outer(phi_vals[i, :], phi_vals[j, :])\n\n    # 2D Quadrature weights\n    q_w_2d = np.outer(q_w, q_w)\n\n    for alpha, beta in test_cases:\n        # Step 1: Define physical node coordinates for the current case\n        P = np.zeros((3, 3, 2))\n        # Corners (indices [0,2] map to reference coords [-1,1])\n        P[0, 0] = [0, 0]\n        P[2, 0] = [1, 0]\n        P[2, 2] = [1, 1]\n        P[0, 2] = [0, 1 + alpha]\n        # Edge midpoints (index 1 maps to reference coord 0)\n        P[1, 0] = [0.5, 0]\n        P[2, 1] = [1, 0.5]\n        P[1, 2] = [0.5, 1 + alpha / 2]\n        P[0, 1] = [0, 0.5 + alpha / 2]\n        # Center\n        P[1, 1] = [0.5, 0.5 + alpha / 2 + beta / 4]\n\n        x_coords = P[:, :, 0]\n        y_coords = P[:, :, 1]\n\n        # Step 2: Compute Jacobian determinant at all quadrature points\n        # efficiently using Einstein summation convention\n        x_xi = np.einsum('ik,jl,ij-kl', L_deriv_vals, L_vals, x_coords)\n        y_xi = np.einsum('ik,jl,ij-kl', L_deriv_vals, L_vals, y_coords)\n        x_eta = np.einsum('ik,jl,ij-kl', L_vals, L_deriv_vals, x_coords)\n        y_eta = np.einsum('ik,jl,ij-kl', L_vals, L_deriv_vals, y_coords)\n\n        J_vals = x_xi * y_eta - x_eta * y_xi  # Shape (Q, Q)\n\n        # Confirm Jacobian is positive, as required by the problem\n        assert np.all(J_vals  0), f\"Jacobian is not positive for (a,b)={alpha,beta}\"\n\n        # Step 3: Assemble the Gram matrix G\n        # G_mn = integral(psi_m * psi_n * J) d(xi,eta)\n        # We use quadrature: sum_{k,l} w_k*w_l * J(k,l) * psi_m(k,l) * psi_n(k,l)\n        \n        # Factor for integration: J(xi,eta) * d(xi) * d(eta)\n        integrand_factor = J_vals * q_w_2d # Shape (Q, Q)\n        \n        # Flatten the spatial dimensions for efficient matrix computation\n        psi_flat = psi_full.reshape(N_basis, Q*Q)\n        integrand_factor_flat = integrand_factor.flatten()\n\n        # G[m,n] = sum_p (psi_flat[m,p] * integrand_factor_flat[p] * psi_flat[n,p])\n        # This is equivalent to psi_flat @ diag(integrand_factor_flat) @ psi_flat.T\n        G = np.einsum('mp,p,np-mn', psi_flat, integrand_factor_flat, psi_flat)\n\n        # Step 4: Compute the metrics E and kappa_2(G)\n        \n        # Orthogonality degradation E\n        D = np.diag(np.diag(G))\n        G_off = G - D\n        \n        norm_D_fro = np.linalg.norm(D, 'fro')\n        # Avoid division by zero if G is a zero matrix (not possible here)\n        E = np.linalg.norm(G_off, 'fro') / norm_D_fro if norm_D_fro  1e-15 else 0.0\n        \n        # Condition number kappa_2(G)\n        kappa = np.linalg.cond(G, 2)\n        \n        results.extend([E, kappa])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.7g}' for x in results)}]\")\n\nsolve()\n```", "id": "3419299"}]}