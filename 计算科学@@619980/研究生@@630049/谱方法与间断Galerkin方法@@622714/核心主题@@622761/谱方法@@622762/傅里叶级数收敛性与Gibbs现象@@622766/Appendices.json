{"hands_on_practices": [{"introduction": "在科学与工程应用中，我们处理的信号常常同时包含由物理不连续性产生的跳变和有意义的平滑振荡。一个核心挑战在于，如何在抑制由跳变引起的伪吉布斯振荡的同时，不扭曲信号中真实的平滑特征。本练习 [@problem_id:3373741] 将引导你通过实验，探索不同谱滤波器（例如指数滤波器和 Lanczos 滤波器）在实现这一目标时的效果，并量化在抑制吉布斯现象与保持平滑区域精度之间的权衡。", "problem": "考虑一个在区间 $[0,2\\pi)$ 上的 $2\\pi$ 周期函数 $f(x)$（角度以弧度为单位），它由一个跳跃和-一个光滑振荡部分组成。令 $a_L=-1$ 和 $a_R=1$，并定义分段常数函数 $h(x)$ 为：当 $x\\in[0,\\pi)$ 时 $h(x)=a_L$，当 $x\\in[\\pi,2\\pi)$ 时 $h(x)=a_R$。令光滑振荡分量为 $g(x)=b_1\\sin(\\kappa_1 x)+b_2\\cos(\\kappa_2 x)$，其中 $b_1=0.15$，$b_2=0.10$，$\\kappa_1=7$ 和 $\\kappa_2=13$。目标函数为 $f(x)=h(x)+g(x)$。跳跃点集是单点集 $\\{x=\\pi\\}$，跳跃高度为 $J=a_R-a_L=2$。\n\n您将使用离散傅里叶变换，在一个包含 $M$ 个等距点 $x_j=\\frac{2\\pi j}{M}$（$j=0,1,\\dots,M-1$，$M=4096$）的均匀网格上，通过截断傅里叶级数来近似 $f(x)$。令 $\\widehat{f}_k$ 为通过标准快速傅里叶变换 (FFT) 约定得到的离散傅里叶系数，其中正变换是离散求和，逆变换包含因子 $1/M$。通过保留 $|k|\\le N$ 的傅里叶模态并将其余 $|k|>N$ 的模态置零，构建一个截断频率为 $N$ 的截断谱近似。为了研究未滤波和滤波后的重构，引入作用于保留模态 $|k|\\le N$ 上的谱乘子（滤波器）$\\sigma(|k|)$：\n- 无滤波器：当 $|k|\\le N$ 时，$\\sigma(|k|)=1$；当 $|k|>N$ 时，$\\sigma(|k|)=0$。\n- 指数滤波器：对于参数 $\\alpha=36$ 和 $p=8$，定义当 $|k|\\le N$ 时，$\\sigma(|k|)=\\exp\\!\\big(-\\alpha \\, (|k|/N)^p\\big)$；当 $|k|>N$ 时，$\\sigma(|k|)=0$。\n- Lanczos 滤波器：定义 $\\sigma(0)=1$，当 $1\\le |k|\\le N$ 时，设置 $\\sigma(|k|)=\\dfrac{\\sin\\!\\big(\\pi |k|/(N+1)\\big)}{\\pi |k|/(N+1)}$；当 $|k|>N$ 时，$\\sigma(|k|)=0$。\n\n从基本原理的角度，您必须使用以下基础和定义：\n- $2\\pi$ 周期函数 $f(x)$ 的傅里叶级数具有复系数 $a_k$，定义为 $a_k=\\frac{1}{2\\pi}\\int_{0}^{2\\pi} f(x)\\,e^{-ikx}\\,dx$，其第 $N$ 部分和为 $S_N f(x)=\\sum_{k=-N}^{N} a_k e^{ikx}$。\n- 对于足够光滑的函数 $f(x)$，在均匀网格上使用梯形法则计算的离散傅里叶变换能一致地逼近连续傅里叶系数；而对于分段光滑的函数 $f(x)$，截断重构在跳跃点附近表现出吉布斯现象 (Gibbs phenomenon)。\n- 吉布斯现象是指在 $S_N f(x)$ 中，不连续点附近的过冲和振荡，其幅度不会随着 $N\\to\\infty$ 而减小，尽管它们会变得更加局部化。\n- 谱滤波器是应用于傅里叶系数的光滑乘子 $\\sigma(|k|)$，用于衰减高频模态和减少伪振荡，同时力求保留远离跳跃点的光滑特征。这种范式与高阶谱方法和间断伽辽金 (Discontinuous Galerkin, DG) 方法中使用的稳定化技术有共通之处。\n\n您的任务是实现一个诊断程序，通过根据滤波后系数进行逆变换得到的重构 $u_{N,\\sigma}(x)$ 计算出的两个量化指标，来区分吉布斯振荡（伪振荡）和真实的光滑振荡（物理振荡）：\n- 跳跃点附近的归一化吉布斯过冲：在跳跃位置 $x=\\pi$ 周围选择一个半宽为 $w=0.2$ 的对称窗口。令 $U_\\text{win}$ 为 $x\\in[\\pi-w,\\pi+w]$ 范围内重构值 $u_{N,\\sigma}(x)$ 的集合。将正过冲定义为 $\\max\\{0,\\max U_\\text{win}-\\max(a_L,a_R)\\}$，负下冲定义为 $\\max\\{0,\\min(a_L,a_R)-\\min U_\\text{win}\\}$。吉布斯指标为 $\\mathcal{G}=\\max\\{\\text{overshoot},\\text{undershoot}\\}/J$，是一个在 $[0,\\infty)$ 范围内的无量纲浮点数。\n- 光滑区域均方根误差：在不包含跳跃点的区间 $I=[0.1\\pi,0.9\\pi]$ 上，使用位于 $I$ 内的均匀网格点，计算重构值 $u_{N,\\sigma}(x)$ 与精确值 $f(x)$ 之间的离散均方根误差。将此指标记为 $\\mathcal{E}$，是一个在 $[0,\\infty)$ 范围内的浮点数。\n\n基于上述定义的解释指南：如果 $\\mathcal{G}$ 仍然显著而 $\\mathcal{E}$ 很小，则 $x=\\pi$ 附近的振荡主要由吉布斯效应引起。如果一个合适的滤波器在不显著增加 $\\mathcal{E}$ 的情况下减小了 $\\mathcal{G}$，则该滤波器有效地抑制了伪振荡，同时保留了真实的光滑振荡。\n\n您的程序必须使用上述精确的滤波器，通过 FFT 实现谱截断和滤波，为每个测试用例计算这两个指标，并输出它们的值。\n\n测试套件。使用以下七个测试用例，每个用例由截断数 $N$ 和滤波器类型指定：\n- 用例 1：$N=16$，滤波器类型 = 无。\n- 用例 2：$N=16$，滤波器类型 = 指数。\n- 用例 3：$N=64$，滤波器类型 = 无。\n- 用例 4：$N=64$，滤波器类型 = 指数。\n- 用例 5：$N=64$，滤波器类型 = Lanczos。\n- 用例 6：$N=256$，滤波器类型 = 无。\n- 用例 7：$N=256$，滤波器类型 = 指数。\n\n角度单位是弧度。没有物理单位。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含每个测试用例的浮点数对 $(\\mathcal{G},\\mathcal{E})$，格式化为六位小数，并按给定顺序连接所有用例的结果。例如，一个包含三个用例的输出将如下所示：$[\\mathcal{G}_1,\\mathcal{E}_1,\\mathcal{G}_2,\\mathcal{E}_2,\\mathcal{G}_3,\\mathcal{E}_3]$。因此，对于这个问题中的七个用例，输出必须在单行上总共包含 14 个浮点数，且无附加文本。", "solution": "该问题是有效的。这是一个适定、有科学依据的数值分析练习，具体涉及通过截断和滤波的傅里叶级数来近似不连续函数。所有参数、函数和指标都得到了明确的定义，从而可以得到唯一且可验证的数值解。该问题正确地将任务置于谱方法和吉布斯现象缓解的背景之下。\n\n求解方法如下：\n\n首先，我们建立计算域和待近似的函数。在区间 $[0, 2\\pi)$ 上定义一个包含 $M=4096$ 个点的均匀网格 $x_j = \\frac{2\\pi j}{M}$（$j=0, 1, \\dots, M-1$）。在此网格上，我们对目标函数 $f(x) = h(x) + g(x)$ 进行采样。函数 $h(x)$ 是一个分段常数阶跃函数，定义为\n$$\nh(x) = \\begin{cases} a_L = -1  \\text{if } x \\in [0, \\pi) \\\\ a_R = 1  \\text{if } x \\in [\\pi, 2\\pi) \\end{cases}\n$$\n光滑分量 $g(x)$ 由下式给出\n$$\ng(x) = b_1\\sin(\\kappa_1 x) + b_2\\cos(\\kappa_2 x)\n$$\n其中常数 $b_1=0.15$, $b_2=0.10$, $\\kappa_1=7$ 和 $\\kappa_2=13$。然后在每个网格点 $x_j$ 上计算复合函数 $f(x)$ 的值。\n\n接下来，我们计算采样函数 $f(x_j)$ 的离散傅里叶变换 (DFT)。离散傅里叶系数 $\\widehat{f}_k$ 是使用快速傅里叶变换 (FFT) 算法获得的。设 $\\{f_j\\}_{j=0}^{M-1}$ 为采样函数值的集合。正变换为 $\\widehat{f}_k = \\sum_{j=0}^{M-1} f_j e^{-i 2\\pi jk/M}$。用于重构信号的逆变换为 $f_j = \\frac{1}{M} \\sum_{k=0}^{M-1} \\widehat{f}_k e^{i 2\\pi jk/M}$。此约定与 NumPy 等标准数值库一致。FFT 输出的整数索引 $k$ 对应于波数；对于 $[0, 2\\pi)$ 上的信号，波数是整数。我们可以将 FFT 索引 $k \\in \\{0, \\dots, M-1\\}$ 映射到物理波数，后者大约为 $[0, \\dots, M/2-1, -M/2, \\dots, -1]$。\n\n对于每个由截断数 $N$ 和滤波器类型指定的测试用例，我们构造一个谱乘子（滤波器）数组 $\\sigma_k$。该数组逐元素地应用于计算出的傅里叶系数 $\\widehat{f}_k$。滤波器根据波数 $|k|$ 和截断频率 $N$ 定义。\n1.  **无滤波器（仅截断）**：这等效于在傅里叶空间中应用一个锐谱滤波器，或一个矩形窗。\n    $$\n    \\sigma_k = \\begin{cases} 1  \\text{if } |k| \\le N \\\\ 0  \\text{if } |k| > N \\end{cases}\n    $$\n2.  **指数滤波器**：这是一个对于高波数会快速衰减的光滑滤波器。对于参数 $\\alpha=36$ 和 $p=8$，其定义为：\n    $$\n    \\sigma_k = \\begin{cases} \\exp\\left(-\\alpha \\left(\\frac{|k|}{N}\\right)^p\\right)  \\text{if } |k| \\le N \\\\ 0  \\text{if } |k| > N \\end{cases}\n    $$\n    该滤波器保留低频模态，并将高频模态平滑地衰减至零，从而减少吉布斯现象。\n3.  **Lanczos 滤波器**：该滤波器源于 sinc 函数。\n    $$\n    \\sigma_k = \\begin{cases} \\dfrac{\\sin(\\pi |k|/(N+1))}{\\pi |k|/(N+1)}  \\text{if } 1 \\le |k| \\le N \\\\ 1  \\text{if } k=0 \\\\ 0  \\text{if } |k| > N \\end{cases}\n    $$\n    注意 $\\lim_{z\\to 0} \\frac{\\sin(\\pi z)}{\\pi z} = 1$，因此该公式在 $k=0$ 处是良定义的。\n\n滤波后的系数计算为 $\\widehat{u}_k = \\widehat{f}_k \\cdot \\sigma_k$。然后，通过对滤波后的系数 $\\widehat{u}_k$ 应用逆 FFT，得到网格上的重构函数 $u_{N,\\sigma}(x_j)$。由于原始函数 $f(x)$ 是实值的，重构函数 $u_{N,\\sigma}(x)$ 也应为实数，因此我们取逆 FFT 输出的实部，舍弃由数值浮点不精确性产生的任何微小虚部。\n\n最后，我们为每个重构计算两个诊断指标。\n-   **吉布斯指标 $\\mathcal{G}$**：该指标量化了不连续点 $x=\\pi$ 附近的过冲/下冲。我们找出窗口 $[\\pi - w, \\pi + w]$ 内的所有网格点 $x_j$，其中 $w=0.2$。令 $U_\\text{win}$ 为在这些点上重构值 $u_{N,\\sigma}(x_j)$ 的集合。过冲为 $\\max\\{0, \\max(U_\\text{win}) - a_R\\}$，下冲为 $\\max\\{0, a_L - \\min(U_\\text{win})\\}$，因为 $a_R = \\max(a_L, a_R) = 1$ 且 $a_L = \\min(a_L, a_R) = -1$。该指标是这两个值的最大值的归一化结果：$\\mathcal{G} = \\frac{\\max\\{\\text{overshoot}, \\text{undershoot}\\}}{J}$，其中跳跃高度为 $J=a_R-a_L=2$。\n\n-   **光滑区域误差 $\\mathcal{E}$**：该指标衡量在远离不连续点区域的重构精度。我们选择不包含跳跃点的区间 $I=[0.1\\pi, 0.9\\pi]$。我们找出位于该区间内的所有网格点 $x_j$。指标 $\\mathcal{E}$ 是在这些点上重构值 $u_{N,\\sigma}(x_j)$ 和精确值 $f(x_j)$ 之间的离散均方根误差 (RMSE)：\n$$\n\\mathcal{E} = \\sqrt{\\frac{1}{N_I} \\sum_{x_j \\in I} (u_{N,\\sigma}(x_j) - f(x_j))^2}\n$$\n其中 $N_I$ 是区间 $I$ 内的网格点数。\n\n对七个测试用例中的每一个重复此完整过程，并收集所得的指标对 $(\\mathcal{G}, \\mathcal{E})$，按指定格式进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of evaluating Fourier-based reconstructions of a\n    piecewise smooth function using Gibbs and smooth-region error metrics.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    # Discretization\n    M = 4096\n    \n    # Function h(x) parameters\n    a_L = -1.0\n    a_R = 1.0\n    J = a_R - a_L\n\n    # Function g(x) parameters\n    b1 = 0.15\n    b2 = 0.10\n    kappa1 = 7.0\n    kappa2 = 13.0\n\n    # Exponential filter parameters\n    alpha = 36.0\n    p = 8.0\n\n    # Metric parameters\n    gibbs_window_half_width = 0.2\n    smooth_interval_start = 0.1 * np.pi\n    smooth_interval_end = 0.9 * np.pi\n    \n    # Test cases: (N, filter_type)\n    test_cases = [\n        (16, 'none'),\n        (16, 'exponential'),\n        (64, 'none'),\n        (64, 'exponential'),\n        (64, 'lanczos'),\n        (256, 'none'),\n        (256, 'exponential'),\n    ]\n\n    # --- Setup Grid and Exact Function ---\n    x = (2 * np.pi / M) * np.arange(M)\n\n    # h(x): piecewise constant\n    h = np.ones(M) * a_R\n    h[x  np.pi] = a_L\n\n    # g(x): smooth oscillatory part\n    g = b1 * np.sin(kappa1 * x) + b2 * np.cos(kappa2 * x)\n\n    # f(x): composite function\n    f = h + g\n\n    # --- FFT of the exact function ---\n    f_hat = np.fft.fft(f)\n    # Wavenumbers corresponding to FFT output\n    k = np.fft.fftfreq(M) * M\n\n    results = []\n\n    for N, filter_type in test_cases:\n        # --- 1. Construct the filter ---\n        sigma = np.zeros(M, dtype=float)\n        truncation_mask = np.abs(k) = N\n        \n        if filter_type == 'none':\n            sigma[truncation_mask] = 1.0\n        \n        elif filter_type == 'exponential':\n            k_abs_in_mask = np.abs(k[truncation_mask])\n            if N > 0:\n                vals = np.exp(-alpha * (k_abs_in_mask / N)**p)\n            else: # Handle N=0 case although not in test suite\n                vals = np.array([1.0]) if 0 in k_abs_in_mask else np.array([])\n            sigma[truncation_mask] = vals\n\n        elif filter_type == 'lanczos':\n            k_abs_in_mask = np.abs(k[truncation_mask])\n            # np.sinc(x) is sin(pi*x)/(pi*x). Problem def is sin(pi*|k|/(N+1))/(pi*|k|/(N+1))\n            # so x = |k|/(N+1)\n            vals = np.sinc(k_abs_in_mask / (N + 1))\n            sigma[truncation_mask] = vals\n\n        # --- 2. Filter and Reconstruct ---\n        f_hat_filtered = f_hat * sigma\n        u = np.fft.ifft(f_hat_filtered).real\n\n        # --- 3. Compute Metrics ---\n\n        # Metric G: Gibbs Overshoot\n        window_mask = (x >= np.pi - gibbs_window_half_width)  \\\n                      (x = np.pi + gibbs_window_half_width)\n        u_win = u[window_mask]\n        \n        max_val = np.max(u_win)\n        min_val = np.min(u_win)\n        \n        overshoot = max(0.0, max_val - a_R)\n        undershoot = max(0.0, a_L - min_val)\n        \n        G = max(overshoot, undershoot) / J\n\n        # Metric E: Smooth-region RMSE\n        smooth_mask = (x >= smooth_interval_start)  (x = smooth_interval_end)\n        u_smooth = u[smooth_mask]\n        f_smooth = f[smooth_mask]\n        \n        E = np.sqrt(np.mean((u_smooth - f_smooth)**2))\n\n        # Store results formatted to six decimal places\n        results.append(f\"{G:.6f}\")\n        results.append(f\"{E:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3373741"}, {"introduction": "吉布斯现象源于傅里叶系数的缓慢衰减，而这种缓慢衰减正是函数不连续性的直接后果。然而，这种渐近行为虽然给重构带来了麻烦，却也蕴含了关于跳变位置和大小的精确信息。本练习 [@problem_id:3373806] 采用一种类似 Prony 方法的技巧，从带噪声的谱数据中提取这些信息。这个分析性练习将向你展示如何将“问题”（源于跳变的高频成分）转化为“信息”（奇异点检测），并分析噪声如何影响检测的精度，从而加深你对傅里叶级数结构的理解。", "problem": "考虑一个实值、$2\\pi$-周期函数 $f(x)$，该函数分段光滑，在位置 $\\xi \\in (-\\pi,\\pi]$ 处有一个幅度为 $J \\neq 0$ 的单个跳跃间断点，在其他地方是 $C^{2}$ 类的。令 $\\{c_{k}\\}_{k \\in \\mathbb{Z}}$ 表示其傅里叶系数，定义为 $c_{k} = \\frac{1}{2\\pi}\\int_{-\\pi}^{\\pi} f(x)\\,\\exp(-i k x)\\,dx$。一个经过充分检验的事实是，对于这类函数，高频傅里叶系数的渐近行为由跳跃主导，\n$$\nc_{k} \\;=\\; \\frac{J}{2\\pi i\\,k}\\,\\exp(-i k \\xi) \\;+\\; \\mathcal{O}\\!\\left(\\frac{1}{k^{2}}\\right)\n\\quad \\text{当 } |k|\\to\\infty \\text{ 时}.\n$$\n定义重标度序列 $y_{k} := k\\,c_{k}$。假设我们只能获取傅里叶系数 $\\{c_{k}^{m}\\}$（对于 $k \\in \\mathbb{Z}$）的含噪声测量值，其中\n$$\nc_{k}^{m} \\;=\\; c_{k} \\;+\\; \\frac{\\eta_{k}}{k},\n$$\n$\\{\\eta_{k}\\}$ 是独立同分布的圆对称复高斯随机变量，均值为零，方差为 $\\mathbb{E}[|\\eta_{k}|^{2}] = \\sigma^{2}$，且 $k \\neq 0$。因此，测得的重标度序列满足\n$$\ny_{k}^{m} \\;=\\; k\\,c_{k}^{m} \\;=\\; \\frac{J}{2\\pi i}\\,\\exp(-i k \\xi) \\;+\\; \\eta_{k} \\;+\\; \\mathcal{O}\\!\\left(\\frac{1}{k}\\right).\n$$\n考虑以下用于间断点位置的 Prony 型双样本估计量（一种零化滤波器比值估计量）：\n$$\n\\widehat{z} \\;:=\\; \\frac{y_{K+1}^{m}}{y_{K}^{m}}, \n\\qquad \\widehat{\\xi} \\;:=\\; -\\arg(\\widehat{z}),\n$$\n其中 $K \\geq 1$ 是一个固定的大的整数模态指数。在 $K \\to \\infty$ 的渐近区域中进行分析，以便模型误差 $\\mathcal{O}(1/K)$ 在主阶上可以被忽略。\n\n从 $c_{k}$ 的定义和上述关于跳跃主导的高频傅里叶系数的渐近事实出发，将噪声视为对 $\\sigma$ 的一阶微扰进行处理，推导均方误差 $\\mathbb{E}\\big[(\\widehat{\\xi}-\\xi)^{2}\\big]$ 在极限 $K \\to \\infty$ 和 $\\sigma \\to 0$ 下的主阶渐近表达式，该表达式仅用跳跃幅度 $J$、噪声水平 $\\sigma$ 和普适常数表示。\n\n回顾傅里叶部分和在跳跃点处的经典过冲是由 Wilbraham–Gibbs 常数决定的跳跃大小的一个固定比例，简要解释该鲁棒性估计如何与吉布斯现象联系起来，并在主阶标度的层面上解释，精确的边缘移除将如何消除过冲，而估计量误差又如何重新引入一个残余效应。你最终报告的答案必须是 $\\mathbb{E}\\big[(\\widehat{\\xi}-\\xi)^{2}\\big]$ 的闭式表达式；不需要数值近似，也不应报告其他任何量。", "solution": "问题要求在给定周期函数傅里叶系数的含噪声测量值的情况下，为一个跳跃间断点位置的估计量推导其均方误差 (MSE) 的主阶渐近表达式。\n\n首先，我们在模态指数 $K \\to \\infty$ 的渐近区域中将所涉及的量形式化。根据问题陈述，测得的重标度序列模型中的 $\\mathcal{O}(1/K)$ 项被忽略。\n真实的（无噪声的）重标度傅里叶系数由主阶渐近行为给出：\n$$\ny_{k} = k\\,c_{k} \\approx \\frac{J}{2\\pi i}\\,\\exp(-i k \\xi)\n$$\n我们定义复常数 $A = \\frac{J}{2\\pi i}$。因此，$y_{k} \\approx A\\,\\exp(-i k \\xi)$。\n测得的重标度系数由下式给出：\n$$\ny_{k}^{m} = y_{k} + \\eta_{k} = A\\,\\exp(-i k \\xi) + \\eta_{k}\n$$\n其中 $\\{\\eta_{k}\\}$ 是独立的、同分布的圆对称复高斯随机变量，均值 $\\mathbb{E}[\\eta_{k}] = 0$，方差 $\\mathbb{E}[|\\eta_{k}|^{2}] = \\sigma^{2}$。圆对称复随机变量的一个关键性质是，对于 $k \\neq j$，有 $\\mathbb{E}[\\eta_{k}\\eta_{j}] = \\mathbb{E}[\\eta_{k}]\\mathbb{E}[\\eta_{j}] = 0$，$\\mathbb{E}[\\eta_{k}\\eta_{j}^{*}] = \\mathbb{E}[\\eta_{k}]\\mathbb{E}[\\eta_{j}^{*}] = 0$，以及 $\\mathbb{E}[\\eta_{k}^{2}]=0$。\n\n跳跃位置 $\\xi$ 的估计量由两个连续的测量系数 $y_{K}^{m}$ 和 $y_{K+1}^{m}$ 的比值构造而成：\n$$\n\\widehat{z} = \\frac{y_{K+1}^{m}}{y_{K}^{m}} = \\frac{A\\,\\exp(-i (K+1) \\xi) + \\eta_{K+1}}{A\\,\\exp(-i K \\xi) + \\eta_{K}}\n$$\n在没有噪声的情况下（$\\eta_k = 0$），这个比值将是 $\\frac{A\\,\\exp(-i (K+1) \\xi)}{A\\,\\exp(-i K \\xi)} = \\exp(-i\\xi)$。我们用 $z_{0} = \\exp(-i\\xi)$ 表示这个真值。\n\n我们被要求对噪声进行微扰处理，这对于小的 $\\sigma$ 是有效的。这对应于假设噪声项 $\\eta_k$ 的幅度相对于信号项的幅度 $|A| = |J/(2\\pi i)| = |J|/(2\\pi)$ 很小。我们进行一阶泰勒展开。\n$$\n\\widehat{z} = \\frac{A\\,\\exp(-i (K+1) \\xi)\\left(1 + \\frac{\\eta_{K+1}}{A\\,\\exp(-i (K+1) \\xi)}\\right)}{A\\,\\exp(-i K \\xi)\\left(1 + \\frac{\\eta_{K}}{A\\,\\exp(-i K \\xi)}\\right)} = \\exp(-i\\xi) \\frac{1 + \\frac{\\eta_{K+1}}{A}\\exp(i(K+1)\\xi)}{1 + \\frac{\\eta_{K}}{A}\\exp(i K\\xi)}\n$$\n对于小的 $x$，使用一阶近似 $(1+x)^{-1} \\approx 1-x$：\n$$\n\\widehat{z} \\approx z_{0} \\left(1 + \\frac{\\eta_{K+1}}{A}\\exp(i(K+1)\\xi)\\right) \\left(1 - \\frac{\\eta_{K}}{A}\\exp(i K\\xi)\\right)\n$$\n展开并保留 $\\eta$ 的一阶项：\n$$\n\\widehat{z} \\approx z_{0} \\left(1 + \\frac{\\eta_{K+1}}{A}\\exp(i(K+1)\\xi) - \\frac{\\eta_{K}}{A}\\exp(i K\\xi)\\right)\n$$\n我们定义复随机微扰 $\\delta$，使得 $\\widehat{z} \\approx z_{0}(1+\\delta)$：\n$$\n\\delta = \\frac{1}{A} \\left( \\eta_{K+1}\\exp(i(K+1)\\xi) - \\eta_{K}\\exp(i K\\xi) \\right)\n$$\n由于 $\\mathbb{E}[\\eta_k]=0$，微扰的期望值为 $\\mathbb{E}[\\delta]=0$。\n\n位置的估计量是 $\\widehat{\\xi} = -\\arg(\\widehat{z})$，真实位置是 $\\xi = -\\arg(z_{0})$。估计量的误差是：\n$$\n\\widehat{\\xi} - \\xi = -\\arg(\\widehat{z}) - (-\\arg(z_{0})) = -(\\arg(\\widehat{z}) - \\arg(z_{0})) = -\\arg\\left(\\frac{\\widehat{z}}{z_{0}}\\right)\n$$\n使用我们的近似，$\\frac{\\widehat{z}}{z_{0}} \\approx 1+\\delta$。对于一个小的复数 $\\delta$，其辐角可以很好地用其虚部来近似：$\\arg(1+\\delta) \\approx \\text{Im}(\\delta)$。\n因此，主阶误差是：\n$$\n\\widehat{\\xi} - \\xi \\approx -\\text{Im}(\\delta)\n$$\n我们需要计算均方误差 (MSE)，$\\mathbb{E}[(\\widehat{\\xi}-\\xi)^{2}]$。\n$$\n\\mathbb{E}[(\\widehat{\\xi}-\\xi)^{2}] \\approx \\mathbb{E}[(-\\text{Im}(\\delta))^{2}] = \\mathbb{E}[(\\text{Im}(\\delta))^{2}]\n$$\n我们来分析 $\\text{Im}(\\delta)$。代入 $A = J/(2\\pi i)$：\n$$\n\\delta = \\frac{2\\pi i}{J} \\left( \\eta_{K+1}\\exp(i(K+1)\\xi) - \\eta_{K}\\exp(i K\\xi) \\right)\n$$\n令 $u = \\eta_{K+1}\\exp(i(K+1)\\xi) - \\eta_{K}\\exp(i K\\xi)$。则 $\\delta = i\\frac{2\\pi}{J}u$。\n$\\delta$ 的虚部是：\n$$\n\\text{Im}(\\delta) = \\text{Im}\\left(i\\frac{2\\pi}{J}u\\right) = \\frac{2\\pi}{J}\\text{Re}(u)\n$$\n现在，我们计算这一项的平方的期望：\n$$\n\\mathbb{E}[(\\text{Im}(\\delta))^{2}] = \\left(\\frac{2\\pi}{J}\\right)^{2} \\mathbb{E}[(\\text{Re}(u))^{2}]\n$$\n复随机变量 $u$ 是两个独立的、零均值的、圆对称复高斯变量的线性组合。因此，$u$ 本身也是一个零均值的、圆对称复高斯变量。对于任何这样的变量 $u = X+iY$，其实部和虚部是独立的、零均值的高斯变量，且方差相等：$\\mathbb{E}[X^{2}] = \\mathbb{E}[Y^{2}] = \\frac{1}{2}\\mathbb{E}[|u|^{2}]$。\n我们首先计算 $u$ 的方差 $\\mathbb{E}[|u|^{2}]$：\n$$\n\\mathbb{E}[|u|^{2}] = \\mathbb{E}[u u^{*}] = \\mathbb{E}\\left[ \\left( \\eta_{K+1}e^{i(K+1)\\xi} - \\eta_{K}e^{iK\\xi} \\right) \\left( \\eta_{K+1}^{*}e^{-i(K+1)\\xi} - \\eta_{K}^{*}e^{-iK\\xi} \\right) \\right]\n$$\n展开乘积得到四项：\n$$\n\\mathbb{E}[|u|^{2}] = \\mathbb{E}[|\\eta_{K+1}|^{2}] - \\mathbb{E}[\\eta_{K+1}\\eta_{K}^{*}]e^{i\\xi} - \\mathbb{E}[\\eta_{K}\\eta_{K+1}^{*}]e^{-i\\xi} + \\mathbb{E}[|\\eta_{K}|^{2}]\n$$\n由于 $\\eta_K$ 和 $\\eta_{K+1}$ 是独立的且均值为零，交叉项为零：$\\mathbb{E}[\\eta_{K+1}\\eta_{K}^{*}] = \\mathbb{E}[\\eta_{K+1}]\\mathbb{E}[\\eta_{K}^{*}] = 0$。\n我们剩下：\n$$\n\\mathbb{E}[|u|^{2}] = \\mathbb{E}[|\\eta_{K+1}|^{2}] + \\mathbb{E}[|\\eta_{K}|^{2}] = \\sigma^{2} + \\sigma^{2} = 2\\sigma^{2}\n$$\n现在我们可以求出 $\\mathbb{E}[(\\text{Re}(u))^{2}]$：\n$$\n\\mathbb{E}[(\\text{Re}(u))^{2}] = \\frac{1}{2}\\mathbb{E}[|u|^{2}] = \\frac{1}{2}(2\\sigma^{2}) = \\sigma^{2}\n$$\n将此代回 MSE 的表达式中：\n$$\n\\mathbb{E}[(\\widehat{\\xi}-\\xi)^{2}] \\approx \\left(\\frac{2\\pi}{J}\\right)^{2} \\sigma^{2} = \\frac{4\\pi^{2}\\sigma^{2}}{J^{2}}\n$$\n这是均方误差的主阶渐近表达式。\n\n简要解释：\n吉布斯现象描述了傅里叶部分和在跳跃间断点附近的持续过冲。这个过冲的幅度是跳跃大小 $J$ 的一个固定比例（约 $9\\%$），它的存在是傅里叶系数 $c_k$ 缓慢的 $k^{-1}$ 衰减的直接结果，而这种衰减又是由跳跃引起的。\n如果跳跃位置 $\\xi$ 和幅度 $J$ 被精确地知道，人们可以构造一个具有相同跳跃的参考函数（例如，锯齿波），并将其从 $f(x)$ 中减去。得到的函数会更光滑，其傅里叶系数会衰减得更快（例如，以 $k^{-2}$ 或更快的速度），并且其傅里叶级数会收敛而没有吉布斯过冲。这被称为奇点减除或边缘移除。\n在这个问题中，我们用估计量 $\\widehat{\\xi}$ 来估计位置 $\\xi$。推导出的 MSE，$\\mathbb{E}[(\\widehat{\\xi}-\\xi)^{2}] = 4\\pi^2\\sigma^2/J^2$，量化了由噪声引起的该位置估计的不确定性。位置的均方根误差是 $\\sqrt{\\mathbb{E}[(\\widehat{\\xi}-\\xi)^{2}]} = 2\\pi\\sigma/|J|$。当我们使用估计的位置 $\\widehat{\\xi}$ 进行奇点减除时，由于误差 $\\widehat{\\xi}-\\xi$ 的存在，奇点的消除是不完美的。这种不完美的减除留下一个残余的、更小尺度的间断，这反过来又导致了残余的吉布斯现象。这个残余过冲的幅度将与“失配”跳跃的幅度成正比，而后者与位置误差成比例。因此，残余过冲的尺度为 $\\sigma/|J|$。这表明，更大的跳跃可以被更精确地定位（MSE 更小），并且对噪声更鲁棒，而更高的噪声水平会降低位置估计的准确性，并在不完美校正后导致更大的残余吉布斯效应。", "answer": "$$\n\\boxed{\\frac{4\\pi^{2}\\sigma^{2}}{J^{2}}}\n$$", "id": "3373806"}, {"introduction": "在学习了如何滤波吉布斯振荡甚至检测底层的跳变之后，我们现在将探索一种更强大、更具针对性的缓解策略。这种被称为“跳变提升”或奇异点减法的方法，其核心思想是在进行傅里叶近似*之前*，通过解析方式从函数中移除不连续性。由此产生的剩余函数是连续的，可以用傅里叶级数以高得多的精度来表示。通过实现这一技术 [@problem_id:3373762]，你将观察到与标准傅里叶级数和简单滤波方法相比，近似质量得到了显著改善，这也展示了类似于间断伽辽金（DG）方法中端点修正的关键思想。", "problem": "考虑单位环面上的 $2\\pi$-周期傅里叶级数，其在本文中表示为区间 $[0,1)$ 上的 $1$-周期函数。设 $f \\in L^{2}([0,1))$ 为一分段光滑函数，在位置 $\\{x_{j}\\}_{j=1}^{J} \\subset [0,1)$ 处有有限个跳跃间断点，其跳跃幅度为 $J_{j} = f(x_{j}^{+}) - f(x_{j}^{-})$，其中 $f(x_{j}^{\\pm})$ 表示单侧极限。\n\n使用的基本基底和定义如下：\n- 函数 $f$ 的复傅里叶系数 $c_k$ 由 $c_{k} = \\int_{0}^{1} f(x) e^{-2\\pi i k x} \\, dx$ (对所有整数 $k$) 给出，$f(x)$ 具有傅里叶级数 $f(x) \\sim \\sum_{k\\in\\mathbb{Z}} c_{k} e^{2\\pi i k x}$。\n- $N$ 阶截断傅里叶部分和为 $S_{N}[f](x) = \\sum_{k=-N}^{N} c_{k} e^{2\\pi i k x}$。\n- 狄利克雷核 $D_{N}(x) = \\sum_{k=-N}^{N} e^{2\\pi i k x}$ 控制着逐点收敛 $S_{N}[f] = D_{N} * f$，其中 $*$ 是卷积。对于分段光滑的 $f$，$S_{N}[f](x)$ 在远离跳跃点处逐点收敛，但在跳跃点附近表现出吉布斯现象。\n- 定义周期锯齿波函数 $s(x)$，其均值为零，在 $x=0$ 处有单位负跳跃，定义为 $s(x) = x - \\tfrac{1}{2}$ (对于 $x \\in [0,1)$)，并周期性延拓到 $\\mathbb{R}$。那么 $s$ 在 $x \\equiv 0 \\mod 1$ 处有 $-1$ 的跳跃，并且是 $1$-周期的。平移后的函数 $s(x-x_{0})$ 在 $x=x_{0}$ 处有单位负跳跃。\n- 对于给定的跳跃 $\\{(x_{j}, J_{j})\\}_{j=1}^{J}$，定义提升函数 $L(x)$ 为\n$$\nL(x) = - \\sum_{j=1}^{J} J_{j} \\, s(x - x_{j}),\n$$\n使得 $L$ 在每个 $x_{j}$ 处与 $f$ 有相同的跳跃。然后，跳跃提升后的残差 $f_{c}(x) := f(x) - L(x)$ 在 $\\{x_{j}\\}$ 处是连续的。\n- 间断伽辽金方法 (DG) 中的端点修正在概念上是类似的：提升算子将界面跳跃映射到内部修正。在这里，$L$ 扮演着一个全局提升的角色，它在进行谱投影之前移除了端点和内部的跳跃。\n\n任务：\n对下面的每个测试用例，从第一性原理出发，实现以下计算实验：\n\n1) 在 $[0,1)$ 上显式地构造 $f$，并列出其跳跃点 $\\{(x_{j}, J_{j})\\}$。使用上述定义构建 $L$ 和连续残差 $f_{c} = f - L$。\n\n2) 对于给定的整数截断阶数 $N$，在一个具有 $M$ 个点的均匀网格上计算截断傅里叶部分和 $S_{N}[f]$ 和 $S_{N}[f_{c}]$，其中 $M$ 足够大。然后，形成提升后的重构\n$$\nR_{N}(x) := S_{N}[f_{c}](x) + L(x).\n$$\n\n3) 通过计算以下指标来量化吉布斯现象及其缓解效果：\n- 跳跃点附近的最大过冲幅度。对于每个跳跃位置 $x_{j}$，设窗口半宽为 $w = \\alpha/N$，其中 $\\alpha = 4$。定义到 $x_{j}$ 的带符号周期距离 $d(x;x_{j})$ 为在 $(-\\tfrac{1}{2},\\tfrac{1}{2}]$ 中与 $x-x_{j} \\mod 1$ 同余的唯一值。在左侧，取点满足 $d(x;x_{j}) \\in [-w,0)$ 并与左极限值 $f(x_{j}^{-})$ 进行比较；在右侧，取点满足 $d(x;x_{j}) \\in (0,w]$ 并与右极限值 $f(x_{j}^{+})$ 进行比较。对于一个重构 $u$，其过冲幅度是在这些窗口内，对所有跳跃点和两侧计算的绝对偏差 $|u(x) - f(x_{j}^{\\pm})|$ 的最大值。为 $u = S_{N}[f]$ 和 $u = R_{N}$ 计算此值。\n- 远离跳跃点的均方根 (RMS) 误差。设排除半径为 $r = 3/N$。排除所有到任一 $x_{j}$ 的周期距离小于 $r$ 的网格点，并对剩余的网格点计算 $u - f$ 的 RMS 误差。为 $u = S_{N}[f]$ 和 $u = R_{N}$ 计算此值。\n\n4) 对每个测试用例，报告两个浮点数：\n- 过冲幅度的比率：$\\mathrm{ratio}_{\\mathrm{over}} = \\dfrac{R_{N} \\text{ 的过冲}}{S_{N}[f] \\text{ 的过冲}}$。\n- 远离跳跃点的 RMS 误差的比率：$\\mathrm{ratio}_{\\mathrm{rms}} = \\dfrac{\\|R_{N} - f\\|_{\\mathrm{RMS,away}}}{\\|S_{N}[f] - f\\|_{\\mathrm{RMS,away}}}$。\n\n数值要求：\n- 在 $[0,1)$ 上使用包含 $M = 65536$ 个点的均匀网格，并精确处理周期性。\n- 当需要时，角度和相位以弧度为单位。\n- 所有构造都必须遵循 $[0,1)$ 上的周期性。\n\n测试套件：\n- 情况 A (内部和端点跳跃，双平台)：令 $a = 0.3$。定义 $f(x) = 1$ (对于 $x \\in [0,a)$) 和 $f(x) = -1$ (对于 $x \\in [a,1)$)。则在 $x_{1} = 0$ 处 $J_{1} = 2$，在 $x_{2} = a$ 处 $J_{2} = -2$。使用 $N = 64$。\n- 情况 B (仅端点跳跃，斜坡)：定义 $f(x) = x - \\tfrac{1}{2}$ (对于 $x \\in [0,1)$)，因此仅在 $x_{1} = 0$ 处有端点跳跃 $J_{1} = -1$。使用 $N = 64$。\n- 情况 C (多个内部和端点跳跃，三平台)：令 $a = 0.25$，$b = 0.7$ 并定义 $f(x) = v_{0}$ (对于 $x \\in [0,a)$)，$f(x) = v_{1}$ (对于 $x \\in [a,b)$)，以及 $f(x) = v_{2}$ (对于 $x \\in [b,1)$)，其中 $v_{0} = 1$，$v_{1} = -0.5$，$v_{2} = 0.3$。跳跃点为：在 $x_{1} = 0$ 处 $J_{1} = v_{0} - v_{2}$，在 $x_{2} = a$ 处 $J_{2} = v_{1} - v_{0}$，以及在 $x_{3} = b$ 处 $J_{3} = v_{2} - v_{1}$。使用 $N = 32$。\n\n最终输出格式：\n你的程序应生成单行输出，包含六个浮点数 $[\\mathrm{ratio}_{\\mathrm{over}}^{A},\\mathrm{ratio}_{\\mathrm{rms}}^{A},\\mathrm{ratio}_{\\mathrm{over}}^{B},\\mathrm{ratio}_{\\mathrm{rms}}^{B},\\mathrm{ratio}_{\\mathrm{over}}^{C},\\mathrm{ratio}_{\\mathrm{rms}}^{C}]$，形式为用方括号括起来的逗号分隔列表（例如，$[0.12,0.03,0.00001,0.00001,0.2,0.1]$）。不应打印任何其他文本。", "solution": "用户提供的问题是数值分析领域一个良构的计算任务，具体涉及不连续函数的傅里叶级数的收敛特性。该问题具有科学依据，不需要外部信息，其指令清晰明确。可以通过直接实现指定的程序来构建解决方案。该问题被声明为 **有效**。\n\n这个问题的核心在于理解和缓解吉布斯现象。吉布斯现象是一种持续存在的振荡伪影，当使用截断傅里叶级数 $S_{N}[f](x)$ 来近似分段光滑函数 $f(x)$ 在其跳跃间断点附近时会出现。对于在点 $x_j$ 处有幅度为 $J$ 的跳跃的函数，其部分和 $S_N[f]$ 将在 $x_j$ 附近表现出过冲和下冲。随着模态数 $N$ 的增加，这种振荡会局限在离跳跃点更近的位置，但其幅度不会减小。最大过冲收敛到跳跃幅度的一个固定比例，大约为 $9\\%$，具体为 $\\frac{J}{\\pi} \\int_{0}^{\\pi} \\frac{\\sin(t)}{t} dt - \\frac{J}{2} \\approx 0.08949 J$。这种缓慢的、非一致的收敛显著降低了傅里叶近似的质量。\n\n提出的缓解策略基于“通过提升进行正则化”的原理。其关键的洞见在于，吉布斯现象是用全局光滑函数基（复指数函数）来近似不连续点的直接后果。如果能在近似*之前*从目标函数中移除不连续性，那么剩余的连续部分就可以用截断傅里叶级数更精确地表示。\n\n这个过程展开如下：\n\n1.  **跳跃识别与提升**：对于 $[0,1)$ 上的给定分段光滑函数 $f(x)$，我们首先识别其跳跃间断点。位置 $x_j$ 处的跳跃由其幅度 $J_j = f(x_j^+) - f(x_j^-)$ 来表征，其中 $f(x_j^\\pm)$ 是单侧极限。我们构造一个特殊的“提升”函数 $L(x)$，使其具有与 $f(x)$ 完全相同的跳跃结构。问题提供了基于周期锯齿波函数 $s(x) = x - \\frac{1}{2}$ (对于 $x \\in [0,1)$) 的 $L(x)$ 的形式：\n    $$\n    L(x) = - \\sum_{j=1}^{J} J_{j} \\, s(x - x_{j})\n    $$\n    项 $-J_j s(x-x_j)$ 在 $x=x_j$ 处的跳跃是 $-J_j \\times (s(x) \\text{ 在 } 0 \\text{ 处的跳跃}) = -J_j \\times (-1) = J_j$。由于其他项在 $x_j$ 处是连续的，所以 $L(x)$ 在 $x_j$ 处的总跳跃是 $J_j$，与 $f(x)$ 的跳跃相匹配。\n\n2.  **构造连续残差**：通过从原始函数中减去提升函数，我们创建了一个“跳跃提升后的残差” $f_c(x)$：\n    $$\n    f_c(x) := f(x) - L(x)\n    $$\n    根据构造， $f_c(x)$ 在每个 $x_j$ 处的跳跃是 $\\text{jump}(f) - \\text{jump}(L) = J_j - J_j = 0$。因此，$f_c(x)$ 处处连续，并且如果 $f(x)$ 是分段光滑的，$f_c(x)$ 将至少是连续且分段光滑的，甚至可能更光滑。\n\n3.  **谱近似**：我们现在可以计算这个连续残差的截断傅里叶级数 $S_N[f_c](x)$。因为 $f_c(x)$ 是连续的，其傅里叶系数比原始不连续函数 $f(x)$ 的系数衰减得快得多，并且其部分和 $S_N[f_c](x)$ 收敛得更快、更一致，没有吉布斯现象。\n\n4.  **提升后的重构**：$f(x)$ 的最终改进近似，记为 $R_N(x)$，是通过将提升函数加回到残差的近似上形成的：\n    $$\n    R_{N}(x) := S_{N}[f_{c}](x) + L(x)\n    $$\n    其基本原理是，由于 $S_N[f_c](x)$ 是 $f_c(x)$ 的一个非常好的近似，那么 $R_N(x) \\approx f_c(x) + L(x) = (f(x) - L(x)) + L(x) = f(x)$。这种重构方法巧妙地将所有不连续性局部化在解析已知的函数 $L(x)$ 中，该函数是在谱投影步骤*之后*加回的，从而规避了吉布斯现象的来源。\n\n所要求的计算实验涉及实现此过程并量化其有效性。对于每个测试用例，我们在 $[0,1)$ 上的一个包含 $M$ 个点的精细均匀网格上执行以下步骤：\n\n1.  构造 $f(x)$、其跳跃点 $\\{(x_j, J_j, f(x_j^-), f(x_j^+))\\}$ 以及相应的提升函数 $L(x)$ 的离散表示。形成连续残差 $f_c(x) = f(x) - L(x)$。\n\n2.  计算标准傅里叶部分和 $S_N[f]$ 和残差部分和 $S_N[f_c]$。这可以通过使用快速傅里叶变换 (FFT) 来高效完成。截断到模 $|k| \\le N$ 的傅里叶级数计算方法如下：\n    a. 使用 `fft` 计算函数样本的离散傅里叶变换 (DFT)。\n    b. 将所有对应于模 $|k| > N$ 的频率分量设置为零。\n    c. 使用 `ifft` 计算滤波后系数的离散傅里叶逆变换 (IDFT)。\n    然后，提升后的重构为 $R_N(x) = S_N[f_c](x) + L(x)$。\n\n3.  对标准重构 $S_N[f]$ 和提升后的重构 $R_N$ 进行误差量化。使用两个度量标准：\n    - **最大过冲幅度**：这测量了在每个跳跃点周围半宽为 $w = 4/N$ 的小窗口内，与真实极限值 $f(x_j^\\pm)$ 的峰值偏差。这直接量化了吉布斯现象。\n    - **远离跳跃点的均方根 (RMS) 误差**：这测量了定义域中不与跳跃点紧邻部分的平均近似误差，特别是在每个不连续点周围排除半径为 $r = 3/N$ 的区域之外。这量化了“光滑”区域的整体收敛质量。\n\n4.  最后，计算这些误差度量的比率 $\\mathrm{ratio}_{\\mathrm{over}}$ 和 $\\mathrm{ratio}_{\\mathrm{rms}}$，以提供通过提升技术获得的改进的归一化度量。远小于 $1$ 的比率表示显著的改进。\n\n此过程被系统地应用于提供的三个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the computational experiment for all test cases.\n    \"\"\"\n    \n    # Global numerical parameters\n    M = 65536  # Number of grid points\n    \n    # Test cases definition\n    test_cases = [\n        # Case A: Two-plateau function\n        {\n            \"name\": \"Case A\",\n            \"N\": 64,\n            \"f_def\": lambda x, a=0.3: np.where(x  a, 1.0, -1.0),\n            \"jumps\": [\n                # (xj, Jj, f(xj-), f(xj+))\n                (0.0, 2.0, -1.0, 1.0),\n                (0.3, -2.0, 1.0, -1.0)\n            ],\n        },\n        # Case B: Sawtooth function (ramp)\n        {\n            \"name\": \"Case B\",\n            \"N\": 64,\n            \"f_def\": lambda x: x - 0.5,\n            \"jumps\": [\n                (0.0, -1.0, 0.5, -0.5)\n            ],\n        },\n        # Case C: Three-plateau function\n        {\n            \"name\": \"Case C\",\n            \"N\": 32,\n            \"f_def\": lambda x, a=0.25, b=0.7, v0=1.0, v1=-0.5, v2=0.3: \\\n                np.select([x  a, (x >= a)  (x  b), x >= b], [v0, v1, v2]),\n            \"jumps\": [\n                (0.0, 0.7, 0.3, 1.0),       # J1 = v0 - v2\n                (0.25, -1.5, 1.0, -0.5),   # J2 = v1 - v0\n                (0.7, 0.8, -0.5, 0.3)        # J3 = v2 - v1\n            ],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        ratios = process_case(M, case['N'], case['f_def'], case['jumps'])\n        results.extend([f\"{r:.6f}\" for r in ratios])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef process_case(M, N, f_def, jumps):\n    \"\"\"\n    Processes a single test case and returns the error ratios.\n    \"\"\"\n\n    # 1. Grid and function setup\n    x = np.arange(M) / M\n    f_vals = f_def(x)\n\n    # 2. Construct the lifting function L(x)\n    L_vals = np.zeros(M)\n    for xj, Jj, _, _ in jumps:\n        # Periodic sawtooth: s(y) = y - 0.5 for y in [0,1)\n        # s(x - xj) evaluated on the grid\n        shifted_x_mod1 = (x - xj + 1.0) % 1.0\n        sawtooth_vals = shifted_x_mod1 - 0.5\n        L_vals -= Jj * sawtooth_vals\n\n    # 3. Form the continuous residual f_c = f - L\n    fc_vals = f_vals - L_vals\n\n    # 4. Compute Fourier partial sums using FFT\n    k_modes = np.fft.fftfreq(M, d=1.0/M)\n    mask_N = np.abs(k_modes) = N\n    \n    # S_N[f]\n    F_f = np.fft.fft(f_vals)\n    F_f_trunc = F_f * mask_N\n    SN_f = np.real(np.fft.ifft(F_f_trunc))\n    \n    # S_N[f_c]\n    F_fc = np.fft.fft(fc_vals)\n    F_fc_trunc = F_fc * mask_N\n    SN_fc = np.real(np.fft.ifft(F_fc_trunc))\n    \n    # 5. Form the lifted reconstruction R_N\n    R_N = SN_fc + L_vals\n\n    # 6. Quantify errors\n    overshoot_SN, rms_SN = calculate_errors(SN_f, f_vals, jumps, N, x, M)\n    overshoot_RN, rms_RN = calculate_errors(R_N, f_vals, jumps, N, x, M)\n\n    # 7. Compute ratios\n    # Handle the case where the denominator is zero (perfect reconstruction)\n    ratio_over = 0.0 if overshoot_SN == 0 else overshoot_RN / overshoot_SN\n    ratio_rms = 0.0 if rms_SN == 0 else rms_RN / rms_SN\n\n    return ratio_over, ratio_rms\n\ndef periodic_dist(x, x0):\n    \"\"\"\n    Computes the signed periodic distance from points x to x0 on the torus [0,1).\n    The result lies in [-0.5, 0.5).\n    \"\"\"\n    d = x - x0\n    return (d + 0.5) % 1.0 - 0.5\n\ndef calculate_errors(u, f, jumps, N, x, M):\n    \"\"\"\n    Calculates overshoot and RMS error for a given reconstruction u.\n    \"\"\"\n    # ----- Overshoot calculation -----\n    w = 4.0 / N\n    max_overshoot = 0.0\n    \n    for xj, _, f_minus, f_plus in jumps:\n        dist_from_jump = periodic_dist(x, xj)\n        \n        # Left side window: [-w, 0)\n        left_mask = (dist_from_jump >= -w)  (dist_from_jump  0)\n        if np.any(left_mask):\n            dev_left = np.max(np.abs(u[left_mask] - f_minus))\n            max_overshoot = max(max_overshoot, dev_left)\n            \n        # Right side window: (0, w]\n        right_mask = (dist_from_jump > 0)  (dist_from_jump = w)\n        if np.any(right_mask):\n            dev_right = np.max(np.abs(u[right_mask] - f_plus))\n            max_overshoot = max(max_overshoot, dev_right)\n\n    # ----- RMS error away from jumps -----\n    r = 3.0 / N\n    away_mask = np.ones(M, dtype=bool)\n    \n    for xj, _, _, _ in jumps:\n        dist_from_jump_abs = np.abs(periodic_dist(x, xj))\n        away_mask[dist_from_jump_abs  r] = False\n    \n    error_vals = u - f\n    \n    # Ensure there are points in the 'away' region to avoid division by zero\n    if np.sum(away_mask) > 0:\n        rms_error = np.sqrt(np.mean(error_vals[away_mask]**2))\n    else:\n        # This case is unlikely but handled for robustness\n        rms_error = 0.0\n        \n    return max_overshoot, rms_error\n\n# Run the main solver function\nsolve()\n```", "id": "3373762"}]}