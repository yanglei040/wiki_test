{"hands_on_practices": [{"introduction": "在许多科学和工程应用中，我们处理的信号或数据都是实数。其实值序列的离散傅里叶变换（DFT）具有一种称为厄米共轭对称性（Hermitian symmetry）的特殊结构，即 $X_{N-k} = \\overline{X_k}$。这意味着频谱中近一半的复数系数是冗余的。这项实践练习 [@problem_id:3381085] 旨在通过设计和实现一种高效的存储方案，利用这一基本属性来减少内存使用，这对于内存受限的系统或大规模数值模拟至关重要。", "problem": "给定一个长度为 $N$ 的实值序列及其离散傅里叶变换 (DFT)，其正变换定义为\n$$\nX_k = \\sum_{n=0}^{N-1} x_n\\,e^{-2\\pi i kn/N},\\quad k=0,1,\\dots,N-1,\n$$\n逆变换定义为\n$$\nx_n = \\frac{1}{N}\\sum_{k=0}^{N-1} X_k\\,e^{2\\pi i kn/N},\\quad n=0,1,\\dots,N-1.\n$$\n角度应以弧度为单位。对于实数输入 $x_n\\in\\mathbb{R}$，其 DFT 满足厄米对称性：\n$$\nX_{N-k} = \\overline{X_k},\\quad k=1,2,\\dots,N-1,\n$$\n当 $N$ 为偶数时，奈奎斯特频率点满足 $X_{N/2}\\in\\mathbb{R}$，而对于所有 $N$，$X_0\\in\\mathbb{R}$。\n\n任务：设计一个存储布局，将实值序列 DFT 中的非冗余信息打包到一个长度为 $N$ 的实数数组中（即恰好 $N$ 个实数）。该布局必须编码由厄米对称性产生的所有自由度。推导逆向解包算法，该算法能从这个打包的实数数组中重构出完整的复数谱 $\\{X_k\\}_{k=0}^{N-1}$，需分别考虑 $N$ 为偶数和奇数的情况，并基于上述定义和性质从第一性原理出发论证其正确性。\n\n您的程序必须实现以下内容：\n- 一个函数，输入为实数序列的完整复数谱 $\\{X_k\\}_{k=0}^{N-1}$，根据您设计的布局返回长度为 $N$ 的打包实数数组。\n- 一个函数，输入为这样一个打包数组和 $N$，使用您的逆向解包算法重构完整的复数谱 $\\{X_k\\}_{k=0}^{N-1}$，并强制执行厄米对称性以及 $X_0$ 和（如果 $N$ 为偶数）$X_{N/2}$ 为实数的特殊情况。\n- 一个验证程序，对每个测试用例，计算给定实数序列的正向 DFT，将其打包，解包为完整频谱，应用逆向 DFT，并将重构的实值序列与原始序列进行比较。比较必须使用最大绝对重构误差，并且当且仅当此误差小于或等于 $10^{-10}$ 时，才声明测试通过。\n\n测试套件：\n使用以下四个测试用例，它们检验了问题的不同方面，包括边界情况。\n1. $N=1$，其中 $x_0=3.5$。\n2. $N=2$，其中 $x_0=1.0$，$x_1=-2.0$。\n3. $N=7$，其中 $x_n = 0.3 + \\cos\\!\\big(2\\pi\\cdot 1\\cdot n/7\\big) + 0.5\\,\\sin\\!\\big(2\\pi\\cdot 2\\cdot n/7\\big)$，对于 $n=0,1,\\dots,6$。\n4. $N=8$，其中 $x_n = 0.1 + 1.25\\,\\cos\\!\\big(2\\pi\\cdot 3\\cdot n/8\\big) + 2.0\\,\\cos\\!\\big(\\pi\\cdot n\\big) + 0.75\\,\\sin\\!\\big(2\\pi\\cdot 1\\cdot n/8\\big)$，对于 $n=0,1,\\dots,7$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个条目是一个布尔值，指示相应的测试用例是否通过（例如，`[True,False,True,True]`）。在整个过程中，角度必须以弧度为单位，不涉及物理单位。最终输出仅为布尔值。", "solution": "该问题要求设计一种存储布局以及相应的打包/解包算法，用恰好 $N$ 个实数来表示长度为 $N$ 的实值序列的离散傅里叶变换 (DFT)。算法的正确性必须从第一性原理出发进行论证。\n\n实值序列 $\\{x_n\\}_{n=0}^{N-1}$ (其中 $x_n \\in \\mathbb{R}$) 的 DFT $\\{X_k\\}_{k=0}^{N-1}$ 具有厄米对称性。此性质是紧凑存储方案的基础。该对称性表示为：\n$$\nX_{N-k} = \\overline{X_k}, \\quad k=1, 2, \\dots, N-1\n$$\n其中 $\\overline{X_k}$ 表示 $X_k$ 的复共轭。此外，两个特定的频率分量具有特殊性质：\n1.  直流分量 $X_0 = \\sum_{n=0}^{N-1} x_n$ 总是实数，因为所有 $x_n$ 都是实数。\n2.  对于偶数长度 $N$，奈奎斯特分量 $X_{N/2} = \\sum_{n=0}^{N-1} x_n e^{-i\\pi n} = \\sum_{n=0}^{N-1} x_n (-1)^n$ 也总是实数。\n\n这些性质意味着 $N$ 个复数 $X_k$（代表 $2N$ 个实数值）并不都是独立的。独立的实数值（自由度）的总数恰好是 $N$，我们现在来证明这一点。\n\n**自由度分析**\n\n让我们计算定义频谱 $\\{X_k\\}$ 所需的独立实数值的数量。我们考虑长度 $N$ 的两种情况。\n\n情况 1：$N$ 为偶数。设 $N=2M$，其中 $M \\ge 1$ 为整数。\n-   $X_0$ 是实数，贡献 1 个自由度。\n-   $X_M = X_{N/2}$ 是实数，贡献 1 个自由度。\n-   其余系数通过对称关系配对。这些对是 $(X_k, X_{N-k})$，其中 $k=1, 2, \\dots, M-1$。共有 $M-1$ 个这样的对。对于每一对，$X_{N-k}$ 完全由 $X_k$ 决定。因此，我们只需要存储 $X_k = \\mathrm{Re}(X_k) + i\\,\\mathrm{Im}(X_k)$，它有 2 个自由度（其实部和虚部）。\n-   自由度总数为 $1 \\text{ (对于 } X_0) + 1 \\text{ (对于 } X_M) + 2(M-1) \\text{ (对于这些对)} = 2 + 2M - 2 = 2M = N$。\n\n情况 2：$N$ 为奇数。设 $N=2M+1$，其中 $M \\ge 0$ 为整数。\n-   $X_0$ 是实数，贡献 1 个自由度。\n-   没有保证为实数的奈奎斯特分量。\n-   系数通过对称关系配对为 $(X_k, X_{N-k})$，其中 $k=1, 2, \\dots, M$。共有 $M$ 个这样的对。对于每一对，我们只需要存储一个复系数，例如 $X_k$，贡献 2 个自由度。\n-   自由度总数为 $1 \\text{ (对于 } X_0) + 2M \\text{ (对于这些对)} = 1 + 2M = N$。\n\n在 $N$ 为偶数和奇数的情况下，长度为 $N$ 的实序列的 DFT 都由恰好 $N$ 个实数唯一确定。我们的任务是设计一个从这些自由度到长度为 $N$ 的实值数组的映射。\n\n**存储布局和打包算法**\n\n我们为长度为 $N$ 的实值打包数组 $P$ 提出以下布局。这种布局是高效的，因为它为低频分量的实部和虚部使用连续的内存块。\n\n设 $P$ 为一个长度为 $N$ 的实数数组。打包算法如下：\n1.  直流分量 $X_0$ 是实数。将其存储在 $P$ 的第一个元素中：\n    $P[0] = \\mathrm{Re}(X_0)$。\n2.  对于直至奈奎斯特频率（或略低于它）的正频率分量，存储其实部和虚部。这样的复数分量数量为 $\\lfloor (N-1)/2 \\rfloor$。对于 $k = 1, 2, \\dots, \\lfloor (N-1)/2 \\rfloor$：\n    -   存储实部：$P[k] = \\mathrm{Re}(X_k)$。\n    -   存储虚部：$P[N-k] = \\mathrm{Im}(X_k)$。\n3.  如果 $N$ 是偶数，则剩下一个自由度 $\\mathrm{Re}(X_{N/2})$ 和数组中的一个未使用位置 $P[N/2]$。将实数奈奎斯特分量存储在那里：\n    $P[N/2] = \\mathrm{Re}(X_{N/2})$。\n\n这个方案完全填充了长度为 $N$ 的数组 $P$ 而没有任何重叠。例如，对于奇数 $N=2M+1$，索引 $N-k$ 的范围从 $N-1$ 到 $N-M = M+1$，而 $k$ 的范围从 $1$ 到 $M$。使用的索引是 $0, \\{1,\\dots,M\\}, \\{M+1,\\dots,N-1\\}$，这覆盖了从 $0$ 到 $N-1$ 的所有索引。对于偶数 $N=2M$，配对的 $k$ 从 $1$ 到 $M-1$。这些对使用的索引是 $\\{1,\\dots,M-1\\}$ 和 $\\{N-1, \\dots, N-(M-1)\\}=\\{M+1,\\dots,2M-1\\}$。加上索引 $0$ 和索引 $M=N/2$，就覆盖了所有索引。\n\n**逆向解包算法**\n\n为了从打包数组 $P$ 重构完整的复数谱 $\\{X_k\\}_{k=0}^{N-1}$，我们反转打包过程。设重构的频谱为 $X'$。\n\n1.  将 $X'$ 初始化为长度为 $N$ 的复值数组。\n2.  重构直流分量：\n    $X'[0] = P[0] + 0i$。\n3.  重构复共轭对。对于 $k=1, 2, \\dots, \\lfloor (N-1)/2 \\rfloor$：\n    -   组合存储的实部和虚部以形成 $X'_k$：\n        $X'[k] = P[k] + i P[N-k]$。\n    -   使用厄米对称性找到其共轭对 $X'_{N-k}$：\n        $X'[N-k] = \\overline{X'[k]} = P[k] - i P[N-k]$。\n4.  如果 $N$ 是偶数，重构实值奈奎斯特分量：\n    $X'[N/2] = P[N/2] + 0i$。\n\n**正确性论证**\n\n此设计的正确性基于以下事实：它在有效实信号 DFT 谱集与长度为 $N$ 的打包实数数组之间建立了一种无损的一一对应（双射）。\n-   **信息保持**：打包算法存储了定义频谱的所有 $N$ 个独立实数值。没有信息丢失。\n-   **对称性强制**：解包算法通过构造重构出一个频谱 $X'$，该频谱严格遵守其逆变换为实值的必要条件：\n    -   $X'[0]$ 是实数。\n    -   如果 $N$ 是偶数，$X'[N/2]$ 是实数。\n    -   对于所有 $k=1, \\dots, N-1$，强制执行属性 $X'[N-k] = \\overline{X'[k]}$。\n-   **可逆性**：先应用打包算法再应用解包算法是一个恒等操作。如果我们从一个有效的频谱 $X$ 开始，我们将得到 $X' = X$。因此，对重构的频谱 $X'$ 应用逆 DFT 将产生原始的实值序列 $x_n$，直至浮点精度的限制。整个过程是一个有效且可逆的变换。这证实了所提出的存储布局及其相关算法的正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef pack_dft(X: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Packs the DFT of a real sequence into a real array of length N.\n    \n    The layout is:\n    - P[0] = Re(X[0])\n    - P[k] = Re(X[k]) for k=1..floor((N-1)/2)\n    - P[N-k] = Im(X[k]) for k=1..floor((N-1)/2)\n    - P[N/2] = Re(X[N/2]) if N is even\n    \n    Args:\n        X (np.ndarray): The full complex DFT spectrum of length N.\n\n    Returns:\n        np.ndarray: The packed real array of length N.\n    \"\"\"\n    N = len(X)\n    P = np.zeros(N, dtype=np.float64)\n\n    # Store the DC component (always real)\n    P[0] = X[0].real\n\n    # Store real and imaginary parts for k=1...floor((N-1)/2)\n    # This range handles both even and odd N correctly for the paired components.\n    num_pairs = (N - 1) // 2\n    for k in range(1, num_pairs + 1):\n        P[k] = X[k].real\n        P[N - k] = X[k].imag\n\n    # If N is even, store the Nyquist component (always real)\n    if N % 2 == 0:\n        if N > 0: # Guard for N=0 case, though not in test suite\n            P[N // 2] = X[N // 2].real\n            \n    return P\n\ndef unpack_dft(P: np.ndarray, N: int) -> np.ndarray:\n    \"\"\"\n    Unpacks a real array into the full complex DFT spectrum, enforcing Hermitian symmetry.\n\n    Args:\n        P (np.ndarray): The packed real array of length N.\n        N (int): The length of the spectrum to reconstruct.\n\n    Returns:\n        np.ndarray: The reconstructed full complex spectrum of length N.\n    \"\"\"\n    X_re = np.zeros(N, dtype=np.complex128)\n\n    # Reconstruct the DC component\n    X_re[0] = P[0]\n\n    # Reconstruct complex conjugate pairs\n    num_pairs = (N - 1) // 2\n    for k in range(1, num_pairs + 1):\n        real_part = P[k]\n        imag_part = P[N - k]\n        X_re[k] = real_part + 1j * imag_part\n        # Enforce Hermitian symmetry\n        X_re[N - k] = real_part - 1j * imag_part\n\n    # If N is even, reconstruct the real Nyquist component\n    if N % 2 == 0:\n        if N > 0:\n            X_re[N // 2] = P[N // 2]\n            \n    return X_re\n\ndef solve():\n    \"\"\"\n    Main function to run the verification for all test cases.\n    \"\"\"\n    test_cases = [\n        # (N, function to generate sequence x_n)\n        (1, lambda n: np.array([3.5])),\n        (2, lambda n: np.array([1.0, -2.0])),\n        (7, lambda n: 0.3 + np.cos(2 * np.pi * 1 * n / 7) + 0.5 * np.sin(2 * np.pi * 2 * n / 7)),\n        (8, lambda n: 0.1 + 1.25 * np.cos(2 * np.pi * 3 * n / 8) + 2.0 * np.cos(np.pi * n) + 0.75 * np.sin(2 * np.pi * 1 * n / 8))\n    ]\n\n    results = []\n    error_threshold = 1e-10\n\n    for N, x_func in test_cases:\n        # Step 1: Generate the original real sequence\n        if N > 1:\n            n_vals = np.arange(N)\n            x_original = x_func(n_vals)\n        else: # Handle N=1 case where arange is not needed\n            x_original = x_func(0)\n\n        # Step 2: Compute the forward DFT\n        X_full = np.fft.fft(x_original)\n\n        # Step 3: Pack the DFT spectrum\n        P_packed = pack_dft(X_full)\n\n        # Step 4: Unpack to reconstruct the spectrum\n        X_reconstructed = unpack_dft(P_packed, N)\n\n        # Step 5: Apply the inverse DFT\n        x_reconstructed = np.fft.ifft(X_reconstructed)\n        \n        # Result of IFFT on a Hermitian-symmetric spectrum is real.\n        # Take .real to discard negligible imaginary parts from floating-point errors.\n        x_reconstructed_real = x_reconstructed.real\n\n        # Step 6: Compare reconstructed sequence to original\n        max_abs_error = np.max(np.abs(x_original - x_reconstructed_real))\n\n        # Step 7: Check if the test passes and record result\n        passed = max_abs_error = error_threshold\n        results.append(passed)\n\n    # Final print statement in the exact required format.\n    # The map(str,...) converts boolean True/False to \"True\"/\"False\" strings.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3381085"}, {"introduction": "快速傅里叶变换（FFT）是求解偏微分方程的谱方法的核心计算引擎。谱方法的一个强大之处在于，物理空间中的微分运算在傅里叶空间中可以简化为简单的乘法运算。然而，当处理非线性项（例如 $u(x)^2$）时，在物理空间中直接计算会导致一种称为“混叠”（aliasing）的误差，这会严重影响计算的准确性和稳定性。这项实践 [@problem_id:3381044] 将让你亲身体验谱微分的威力以及处理混叠误差的关键挑战，你将实现并比较几种经典的去混叠策略，如“$3/2$规则”，这对于开发稳健的伪谱方法代码至关重要。", "problem": "考虑一个实值、$2\\pi$-周期函数 $u(x)$，在 $N$ 个等距配置点 $x_j = 2\\pi j/N$（其中 $j = 0,1,\\dots,N-1$）上进行采样。设离散傅里叶变换 (DFT) 对定义如下：\n$$\n\\widehat{u}_k = \\sum_{j=0}^{N-1} u(x_j)\\, e^{-2\\pi i\\, j k/N}, \\quad\nu(x_j) = \\frac{1}{N} \\sum_{k=0}^{N-1} \\widehat{u}_k\\, e^{2\\pi i\\, j k/N}.\n$$\n与第 $k$ 个 DFT 频率箱相关的波数对应于在 $2\\pi$ 周期域上解释的整数 $k$。也就是说，角波数是离散傅里叶变换索引在上述约定下标准映射所返回频率的 $2\\pi$ 倍。对于偶数 $N$，整数波数为 $k \\in \\{0,1,\\dots,N/2-1,-N/2,\\dots,-1\\}$。\n\n谱方法微分的定义是：变换到傅里叶空间，乘以 $i k$，然后变换回来：\n$$\n\\mathcal{D}_x[u](x) \\approx \\mathcal{F}^{-1}\\left\\{ i\\,k\\,\\widehat{u}_k \\right\\}(x).\n$$\n对于非线性乘积，伪谱法在物理空间中计算乘积，然后变换回傅里叶空间。当傅里叶模态的卷积超出网格的可分辨范围时，这会引入混叠。两种经典的去混叠策略是：\n- “$3/2$ 法则”补零：临时将谱分辨率提高 $3/2$ 倍，在更高的分辨率下计算乘积，然后截断回 $N$ 个模态。\n- “$2/3$ 法则”截断：在原始网格上计算二次乘积之前，将所有 $|k|  \\lfloor N/3 \\rfloor$ 的模态置零。\n\n从上述 DFT 对和 $2\\pi$ 周期傅里叶级数解释出发，实现以下内容：\n1. 通过 DFT 实现谱方法微分，并与解析导数对比以验证其准确性。\n2. 对 $u(x)^2$ 进行伪谱评估，并在傅里叶系数层面展示混叠与使用 $3/2$ 法则去混叠的对比。\n3. 对于二次乘积，当初始谱包含在 $2/3$ 带宽内时，$3/2$ 法则和 $2/3$ 法则在已解析的低阶模态上的等价性。\n4. 对非线性通量导数 $\\partial_x\\left(\\tfrac{1}{2}u(x)^2\\right) = u(x)\\,u_x(x)$ 进行伪谱评估，使用精确结果的解析表达式，比较混叠计算与正确去混叠的计算。\n\n您的程序必须实现以下测试套件并生成所要求的输出。角度以弧度为单位，不涉及物理单位。\n\n测试套件：\n- 测试 A (谱方法微分准确性):\n  - 定义域 $[0,2\\pi)$，$N \\in \\{16, 32, 64\\}$。\n  - 函数 $u(x) = \\sin(3x) + 0.5 \\cos(5x)$。\n  - 在配置点上计算谱方法导数 $\\mathcal{D}_x[u](x)$ 和解析导数 $u_x(x)$。\n  - 对每个 $N$ 值，输出最大绝对误差 $\\max_j | \\mathcal{D}_x[u](x_j) - u_x(x_j) |$，作为三个独立的浮点数。\n\n- 测试 B ($u^2$ 中的混叠与在傅里叶系数层面的 $3/2$ 法则去混叠):\n  - 定义域 $[0,2\\pi)$，$N = 16$。\n  - 函数 $u(x) = \\cos(6x) + \\cos(7x)$。\n  - 通过以下方式计算 $u^2$ 的傅里叶系数：\n    - 混叠伪谱法：在 $N$ 点网格上计算 $u(x_j)^2$，然后应用 DFT 得到 $\\widehat{(u^2)}^{\\mathrm{alias}}_k$。\n    - 使用 $3/2$ 法则去混叠：通过 $3/2$ 的因子构造一个补零谱，在填充后的网格上计算 $u^2$，变换回来，并截断到 $N$ 个模态以获得 $\\widehat{(u^2)}^{3/2}_k$。补零和截断必须保持与给定 DFT 对一致的傅里叶级数归一化。\n  - 输出 $N$ 长度系数向量之差的欧几里得范数，即 $\\left\\| \\widehat{(u^2)}^{\\mathrm{alias}} - \\widehat{(u^2)}^{3/2} \\right\\|_2$，作为一个单独的浮点数。\n\n- 测试 C (对于二次乘积，$3/2$ 法则与 $2/3$ 法则在低阶模态上的等价性):\n  - 定义域 $[0,2\\pi)$，$N = 24$。\n  - 函数 $u(x) = \\cos(7x) + 0.5 \\sin(6x)$。\n  - 令 $K_c = \\lfloor N/3 \\rfloor$。\n  - 使用以下方法计算 $u^2$ 的傅里叶系数：\n    - $3/2$ 法则补零法，截断回 $N$ 个模态。\n    - $2/3$ 法则：在原始网格上，将 $\\widehat{u}_k$ 中 $|k|  K_c$ 的模态置零，逆变换到物理空间，平方，然后变换回来；接着在结果中将 $|k|  K_c$ 的模态置零。\n  - 只比较 $|k| \\le K_c$ 的低阶模态。输出这些模态上的最大绝对差，作为一个单独的浮点数。\n\n- 测试 D (混叠与去混叠的非线性通量导数):\n  - 定义域 $[0,2\\pi)$，$N = 32$。\n  - 函数 $u(x) = \\sin(9x) + 0.4 \\cos(8x)$。\n  - 精确通量导数：$u(x)\\,u_x(x)$，其中 $u_x(x)$ 是解析导数。\n  - 混叠计算：在 $N$-网格上用谱方法计算 $u_x$，在物理空间中形成 $u\\,u_x$，并与配置点上的精确值进行比较。输出均方根误差 $\\sqrt{\\frac{1}{N}\\sum_{j=0}^{N-1} \\left( u(x_j)u_x(x_j) - [u\\,u_x]^{\\mathrm{alias}}(x_j)\\right)^2}$，作为一个单独的浮点数。\n  - 使用 $3/2$ 法则的去混叠计算：对 $u\\,u_x$ 进行 $3/2$ 法则的去混叠乘积，方法是填充到 $3N/2$，在填充后的网格上用谱方法求导，在填充后的网格上形成乘积，变换回来，截断到 $N$ 个模态，然后逆变换到 $N$-网格。与精确值比较并输出均方根误差，作为一个单独的浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  - 测试 A 中 $N=16$ 的误差\n  - 测试 A 中 $N=32$ 的误差\n  - 测试 A 中 $N=64$ 的误差\n  - 测试 B 的系数向量差异范数\n  - 测试 C 的最大低阶模态差异\n  - 测试 D 的混叠均方根误差\n  - 测试 D 的去混叠均方根误差\n- 每个数字必须以具有十二位有效数字的科学记数法打印，列表前后不得有任何额外文本。", "solution": "该问题是有效的。它就谱方法求解偏微分方程这一主题，提出了一套清晰、适定且科学上合理的数值练习。所有必要的定义、参数和评估标准都已提供。这些任务涉及该领域标准和基础技术的实现与验证，如谱方法微分、用于非线性项的伪谱法，以及常见的去混叠策略，如 $3/2$ 和 $2/3$ 法则。\n\n问题的核心在于离散傅里叶变换 (DFT) 在用于近似周期函数的导数和非线性乘积时的性质。在一个 $2\\pi$ 周期域上，由 $N$ 个等距点 $x_j = 2\\pi j/N$ 组成的网格上，函数 $u(x)$ 由其值 $u(x_j)$ 表示。所提供的 DFT 对为：\n$$ \\widehat{u}_k = \\sum_{j=0}^{N-1} u(x_j)\\, e^{-2\\pi i\\, j k/N} $$\n$$ u(x_j) = \\frac{1}{N} \\sum_{k=0}^{N-1} \\widehat{u}_k\\, e^{2\\pi i\\, j k/N} $$\n这些定义分别直接对应 `numpy.fft.fft` 和 `numpy.fft.ifft` 函数，从而简化了实现。\n\n整数波数 $k$ 从 DFT 索引映射而来。对于偶数点数 $N$，波数为 $k \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$。这个集合代表了网格可以解析的频率。最高量级的波数是奈奎斯特频率，即 $|k| = N/2$。\n\n**1. 谱方法微分**\n傅里叶级数项 $e^{ikx}$ 的导数是 $ik e^{ikx}$。此性质可推广到 DFT。谱方法导数 $\\mathcal{D}_x[u]$ 的计算方法是：将 $u$ 变换到傅里叶空间得到系数 $\\widehat{u}_k$，将每个系数乘以其对应的有效波数 $ik$，然后变换回物理空间：\n$$ (\\mathcal{D}_x[u])_j = \\mathcal{F}^{-1}\\left\\{ i k \\widehat{u}_k \\right\\}_j $$\n对于一个函数，如果其傅里叶级数只包含满足 $|k|  N/2$ 的波数 $k$，那么谱方法求导在机器精度内是精确的。这是因为所有分量波都能被网格很好地解析。\n\n**2. 伪谱法与混叠**\n非线性项，如 $u(x)^2$，在傅里叶空间中处理起来很有挑战性。两个函数的乘积对应于其傅里叶系数的卷积：\n$$ \\widehat{(uv)}_k = (\\widehat{u} * \\widehat{v})_k = \\sum_{m=-\\infty}^{\\infty} \\widehat{u}_m \\widehat{v}_{k-m} $$\n直接计算此卷积的计算成本很高 ($O(N^2)$)。伪谱法提供了一种高效的替代方案：\n1. 将 $\\widehat{u}_k$ 和 $\\widehat{v}_k$ 变换到物理空间，得到 $u(x_j)$ 和 $v(x_j)$ ($O(N\\log N)$)。\n2. 在物理空间中逐点计算乘积：$w(x_j) = u(x_j) v(x_j)$ ($O(N)$)。\n3. 将 $w(x_j)$ 变换回傅里叶空间，得到 $\\widehat{w}_k$ ($O(N\\log N)$)。\n\n然而，该方法会引入混叠误差。如果 $u(x)$ 的模态最高达到波数 $K_{max}$，则乘积 $u(x)^2$ 将包含最高达到 $2K_{max}$ 的模态。如果 $2K_{max}$ 超过网格的奈奎斯特极限 ($N/2$)，高频分量将被“折叠”回低频波数上，从而污染计算出的谱。具体来说，一个真实波数为 $k_{true}$ 的模态会被混叠到 $k_{alias} = k_{true} \\pmod N$。\n\n**3. 去混叠策略**\n为防止混叠，网格必须足够精细，以解析非线性乘积中的最高波数。\n- **$3/2$ 法则（补零）：** 这是一种通用的去混叠方法。如果原始函数 $u$ 是带限的，其谱 $\\widehat{u}_k$ 在 $|k|  K$ 时为零，则乘积 $u^2$ 的谱仅在 $|k| \\le 2K$ 时非零。为了无混叠地计算此乘积，我们需要一个奈奎斯特频率大于 $2K$ 的网格，即 $N_{padded}/2  2K$。$3/2$ 法则涉及将网格大小临时增加到 $N' = \\lfloor 3N/2 \\rfloor$。原始谱 $\\widehat{u}_k$ 通过补零来创建一个高分辨率谱 $\\widehat{u}^{\\mathrm{pad}}_k$。然后在此填充后的网格上计算乘积。最后，将得到的谱截断回原始的 $N$ 个模态。如果原始信号的能量包含在 $|k|  N/3$ 内，此方法是有效的，因为这样乘积的能量就在 $|k|  2N/3$ 内，这在填充后的网格上是可解析的，因为 $N'/2 \\approx 3N/4  2N/3$。将系数从一个 N 点变换填充到一个 N' 点变换时，必须将其乘以 N'/N 来保持底层连续函数的振幅。截断回来时，则乘以 N/N'。\n\n- **$2/3$ 法则（截断）：** 此法则专门适用于二次或三次非线性项。对于二次乘积 $u^2$，如果首先通过将所有 $|k|  N/3$ 的模态置零来截断输入谱 $\\widehat{u}_k$，则在原始 N 点网格上计算的伪谱乘积对于所有 $|k| \\le N/3$ 的模态将具有正确、无混叠的系数。混叠误差被限制在谱的较高、被截断的部分。对于已经带限于 $|k| \\le N/3$ 的初始谱，该方法对于保留的低频模态与 $3/2$ 法则等价。\n\n该问题要求在四个测试案例中实现这些概念。\n\n**测试 A：谱方法微分准确性**\n对于 $u(x) = \\sin(3x) + 0.5 \\cos(5x)$，最高波数为 $k=5$。对于网格大小 $N=16, 32, 64$，奈奎斯特频率分别为 $N/2=8, 16, 32$。在所有情况下，$5  N/2$。因此，函数被很好地解析，谱方法导数 $\\mathcal{D}_x[u]$ 应与解析导数 $u_x(x) = 3\\cos(3x) - 2.5\\sin(5x)$ 在机器精度内匹配。最大绝对误差预计将非常小，约为 $10^{-14}$ 或更低。\n\n**测试 B：$u^2$ 中的混叠**\n对于 $N=16$ 时的 $u(x) = \\cos(6x) + \\cos(7x)$，输入波数为 $k=6,7$。奈奎斯特频率为 $N/2=8$。二次乘积 $u^2(x)$ 将通过三角恒等式（$\\cos(A)\\cos(B) = \\frac{1}{2}(\\cos(A-B)+\\cos(A+B))$）生成波数为 $k=0, 1, 12, 13, 14$ 的模态。模态 $k=12, 13, 14$ 都大于 $8$ 的奈奎斯特频率。它们将分别混叠到 $k=12-16=-4$，$k=13-16=-3$ 和 $k=14-16=-2$。因此，混叠伪谱计算将在这些负波数处具有非零系数，而在精确结果中这些系数应为零。在大小为 $N' = 3/2 \\cdot 16 = 24$ 的填充网格上进行的 $3/2$ 法则去混叠将计算出准确的谱，因为乘积的最高波数 $14$ 超过了填充网格的奈奎斯特极限 $12$，所以仍会有一些混叠（$k=14$ 混叠到 $14-24=-10$）。然而，混叠模式不同，结果比在 $N=16$ 网格上的计算更准确。问题的措辞是正确的，即比较两种方法。两种方法得到的系数向量之差的范数将非零，从而量化了混叠的影响。\n\n**测试 C：$3/2$ 法则与 $2/3$ 法则的等价性**\n对于 $N=24$，$2/3$ 法则的截断波数为 $K_c = \\lfloor 24/3 \\rfloor = 8$。函数为 $u(x) = \\cos(7x) + 0.5 \\sin(6x)$。其所有波数（$k=6,7$）都在 $|k| \\le K_c$ 的环带内。根据理论，对于这样的带限输入，$3/2$ 法则和 $2/3$ 法则都应该在 $|k| \\le K_c$ 范围内为乘积 $u^2$ 得出精确的傅里叶系数。因此，两种方法计算出的在该范围内的系数之间的最大绝对差应接近机器精度。\n\n**测试 D：混叠与去混叠的非线性通量导数**\n非线性通量为 $\\frac{1}{2}u(x)^2$，其导数为 $u(x)u_x(x)$。对于 $N=32$ 时的 $u(x) = \\sin(9x) + 0.4 \\cos(8x)$，奈奎斯特频率为 $16$。$u$ 及其导数 $u_x$ 中的波数均为 $8, 9$。乘积 $u u_x$ 将包含最高达 $9+9=18$ 的波数。由于 $18  16$，混叠伪谱计算（在 $N=32$ 网格上乘以 $u$ 及其谱方法导数）将由于 $k=18$ 模态混叠到 $k=18-32=-14$ 而不正确。与解析结果相比，均方根误差将很显著。相比之下，使用 $3/2$ 法则在大小为 $N' = 3/2 \\cdot 32 = 48$ 的网格上进行的去混叠计算将是准确的。填充后网格的奈奎斯特频率为 $24$，大于乘积的最大波数 $18$。因此，在填充网格上计算的乘积是精确的，最终在 $N=32$ 网格上的去混叠结果的均方根误差将接近机器精度。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the specified test suite for spectral methods and dealiasing.\n    \"\"\"\n    \n    results = []\n\n    # --- Test A: Spectral differentiation accuracy ---\n    def run_test_A(N):\n        x = 2 * np.pi * np.arange(N) / N\n        u = np.sin(3 * x) + 0.5 * np.cos(5 * x)\n        u_x_analytic = 3 * np.cos(3 * x) - 2.5 * np.sin(5 * x)\n        \n        # Spectral derivative\n        u_hat = np.fft.fft(u)\n        # Wavenumbers k = [0, 1, ..., N/2-1, -N/2, ..., -1]\n        k = np.fft.fftfreq(N, d=1.0/N)\n        du_dx_hat = 1j * k * u_hat\n        u_x_spectral = np.fft.ifft(du_dx_hat)\n        \n        # Error calculation\n        error = np.max(np.abs(np.real(u_x_spectral) - u_x_analytic))\n        return error\n\n    results.append(run_test_A(16))\n    results.append(run_test_A(32))\n    results.append(run_test_A(64))\n\n    # --- Test B: Aliasing in u^2 and 3/2-rule dealiasing ---\n    def run_test_B(N):\n        x = 2 * np.pi * np.arange(N) / N\n        u = np.cos(6 * x) + np.cos(7 * x)\n\n        # Aliased computation\n        u_sq_alias_phys = u**2\n        u_sq_alias_hat = np.fft.fft(u_sq_alias_phys)\n\n        # Dealiased 3/2-rule computation\n        N_pad = int(N * 3 / 2)\n        u_hat = np.fft.fft(u)\n        \n        # Pad spectrum, scaling by N'/N\n        u_hat_padded = np.zeros(N_pad, dtype=complex)\n        scaling_factor_pad = N_pad / N\n        # For even N, fftfreq gives k=[0, 1, ..., N/2-1, -N/2, ..., -1]\n        # Positive freqs (and zero) go to the first part of the array\n        u_hat_padded[0 : N//2 + 1] = scaling_factor_pad * u_hat[0 : N//2 + 1]\n        # Negative freqs go to the end of the array\n        u_hat_padded[N_pad - (N - (N//2 + 1)) :] = scaling_factor_pad * u_hat[N//2 + 1:]\n        \n        u_padded = np.fft.ifft(u_hat_padded)\n        u_sq_padded_phys = np.real(u_padded)**2\n        u_sq_padded_hat = np.fft.fft(u_sq_padded_phys)\n        \n        # Truncate spectrum, scaling by N/N'\n        u_sq_dealias_hat = np.zeros(N, dtype=complex)\n        scaling_factor_trunc = N / N_pad\n        u_sq_dealias_hat[0 : N//2 + 1] = scaling_factor_trunc * u_sq_padded_hat[0 : N//2 + 1]\n        u_sq_dealias_hat[N//2 + 1:] = scaling_factor_trunc * u_sq_padded_hat[N_pad - (N - (N//2 + 1)) :]\n        \n        diff_norm = np.linalg.norm(u_sq_alias_hat - u_sq_dealias_hat)\n        return diff_norm\n\n    results.append(run_test_B(16))\n\n    # --- Test C: 3/2-rule versus 2/3-rule equivalence ---\n    def run_test_C(N):\n        Kc = N // 3\n        x = 2 * np.pi * np.arange(N) / N\n        u = np.cos(7 * x) + 0.5 * np.sin(6 * x)\n        k = np.fft.fftfreq(N, d=1.0/N)\n\n        # 3/2-rule\n        N_pad = int(N * 3 / 2)\n        u_hat = np.fft.fft(u)\n\n        u_hat_padded = np.zeros(N_pad, dtype=complex)\n        scaling_factor_pad = N_pad / N\n        u_hat_padded[0 : N//2 + 1] = scaling_factor_pad * u_hat[0 : N//2 + 1]\n        u_hat_padded[N_pad - (N - (N//2+1)) :] = scaling_factor_pad * u_hat[N//2+1:]\n\n        u_padded = np.fft.ifft(u_hat_padded)\n        u_sq_padded_phys = np.real(u_padded)**2\n        u_sq_padded_hat = np.fft.fft(u_sq_padded_phys)\n\n        u_sq_32_hat = np.zeros(N, dtype=complex)\n        scaling_factor_trunc = N / N_pad\n        u_sq_32_hat[0 : N//2 + 1] = scaling_factor_trunc * u_sq_padded_hat[0 : N//2 + 1]\n        u_sq_32_hat[N//2+1:] = scaling_factor_trunc * u_sq_padded_hat[N_pad - (N - (N//2+1)) :]\n\n        # 2/3-rule\n        u_hat_trunc = u_hat.copy()\n        u_hat_trunc[np.abs(k)  Kc] = 0\n        u_trunc = np.fft.ifft(u_hat_trunc)\n        u_sq_trunc_phys = np.real(u_trunc)**2\n        u_sq_23_hat = np.fft.fft(u_sq_trunc_phys)\n        u_sq_23_hat[np.abs(k)  Kc] = 0\n\n        # Comparison\n        low_modes_mask = np.abs(k) = Kc\n        max_diff = np.max(np.abs(u_sq_32_hat[low_modes_mask] - u_sq_23_hat[low_modes_mask]))\n        return max_diff\n        \n    results.append(run_test_C(24))\n\n    # --- Test D: Aliased vs. dealiased nonlinear flux derivative ---\n    def run_test_D(N):\n        x = 2 * np.pi * np.arange(N) / N\n        u = np.sin(9 * x) + 0.4 * np.cos(8 * x)\n        \n        # Exact flux derivative\n        ux_analytic = 9 * np.cos(9 * x) - 3.2 * np.sin(8 * x)\n        flux_deriv_exact = u * ux_analytic\n        \n        # Aliased computation\n        u_hat = np.fft.fft(u)\n        k = np.fft.fftfreq(N, d=1.0/N)\n        ux_hat = 1j * k * u_hat\n        ux_spectral = np.fft.ifft(ux_hat)\n        flux_deriv_alias = u * np.real(ux_spectral)\n        err_alias = np.sqrt(np.mean((flux_deriv_alias - flux_deriv_exact)**2))\n        \n        # Dealiased 3/2-rule computation\n        N_pad = int(N * 3 / 2)\n        k_pad = np.fft.fftfreq(N_pad, d=1.0/N_pad)\n\n        u_hat_padded = np.zeros(N_pad, dtype=complex)\n        scaling_factor_pad = N_pad / N\n        u_hat_padded[0 : N//2 + 1] = scaling_factor_pad * u_hat[0 : N//2 + 1]\n        u_hat_padded[N_pad - (N - (N//2+1)) :] = scaling_factor_pad * u_hat[N//2+1:]\n        \n        ux_hat_padded = 1j * k_pad * u_hat_padded\n        \n        u_padded = np.fft.ifft(u_hat_padded)\n        ux_padded = np.fft.ifft(ux_hat_padded)\n        \n        flux_deriv_padded_phys = np.real(u_padded) * np.real(ux_padded)\n        flux_deriv_padded_hat = np.fft.fft(flux_deriv_padded_phys)\n        \n        flux_deriv_dealias_hat = np.zeros(N, dtype=complex)\n        scaling_factor_trunc = N / N_pad\n        flux_deriv_dealias_hat[0 : N//2 + 1] = scaling_factor_trunc * flux_deriv_padded_hat[0 : N//2 + 1]\n        flux_deriv_dealias_hat[N//2+1:] = scaling_factor_trunc * flux_deriv_padded_hat[N_pad - (N - (N//2+1)):]\n        \n        flux_deriv_dealias = np.fft.ifft(flux_deriv_dealias_hat)\n        err_dealias = np.sqrt(np.mean((np.real(flux_deriv_dealias) - flux_deriv_exact)**2))\n        \n        return err_alias, err_dealias\n\n    err_D_alias, err_D_dealias = run_test_D(32)\n    results.append(err_D_alias)\n    results.append(err_D_dealias)\n    \n    # Format and print the final output\n    formatted_results = [f\"{r:.12e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3381044"}, {"introduction": "科学计算经常涉及二维或三维等多维数据集。虽然多维DFT在数学上是可分离的，但在按行优先顺序存储的内存布局上直接实现会导致严重的性能问题，其原因在于沿列进行变换时会产生巨大的内存访问步长，从而导致缓存效率低下。这项实践练习 [@problem_id:3381024] 深入探讨了高性能计算的一个核心主题：通过重构算法来适应硬件架构。你将通过实现一种基于矩阵转置的缓存友好型二维FFT算法，来解决内存访问瓶颈问题，这是一种在现代硬件上优化数值算法的基础技术。", "problem": "考虑在谱方法和间断伽辽金 (DG) 方法中出现的张量积网格上的二维离散傅里叶变换 (DFT)。设 $X \\in \\mathbb{C}^{n_y \\times n_x}$ 是一个以行主序布局存储的复数数组，这意味着对于 $0 \\le j  n_y$，$0 \\le i  n_x$，位于 $(j,i)$ 处的条目的线性内存索引为 $p = j\\,n_x + i$。$X$ 的二维 DFT 是数组 $Y \\in \\mathbb{C}^{n_y \\times n_x}$，定义为\n$$\nY_{k,\\ell} = \\sum_{j=0}^{n_y-1} \\sum_{i=0}^{n_x-1} X_{j,i} \\, e^{-2\\pi \\mathrm{i} \\frac{k j}{n_y}} \\, e^{-2\\pi \\mathrm{i} \\frac{\\ell i}{n_x}}, \\quad 0 \\le k  n_y, \\; 0 \\le \\ell  n_x,\n$$\n其中 $\\mathrm{i}$ 是虚数单位。该变换是可分离的，可以使用一维 DFT 矩阵 $F_{n_y} \\in \\mathbb{C}^{n_y \\times n_y}$ 和 $F_{n_x} \\in \\mathbb{C}^{n_x \\times n_x}$ 以矩阵形式表示为\n$$\nY = F_{n_y} \\, X \\, F_{n_x}^{\\top}.\n$$\n等价地，使用克罗内克积，向量化映射满足\n$$\n\\operatorname{vec}(Y) = \\left(F_{n_x} \\otimes F_{n_y}\\right) \\operatorname{vec}(X),\n$$\n其中 $\\operatorname{vec}(\\cdot)$ 堆叠列，$\\otimes$ 表示克罗内克积。快速傅里叶变换 (FFT) 通过利用递归的基数分解，在 $O(n \\log n)$ 次运算内计算一维 DFT。\n\n在行主序内存中，一个朴素的两遍调度方案首先沿行应用长度为 $n_x$ 的一维 FFT（单位步长访问），然后沿列应用长度为 $n_y$ 的一维 FFT（步长为 $n_x$ 的访问），这种方案在列处理遍中会因缓存局部性不佳而性能受损，因为列的连续元素在线性内存中相隔 $n_x$ 个位置。通过交错进行转置操作，可以改善缓存局部性，使得两次一维 FFT 过程都以单位步长遍历内存。您的任务是设计一个遍处理和转置的序列，以计算具有良好缓存局部性的原地二维 FFT，并从二维 DFT 的可分离性和行主序内存映射的第一性原理出发，论证您的选择。该设计应最小化 FFT 过程中的非单位步长内存访问，并应使用分块转置来最大化空间局部性。\n\n程序要求：\n- 实现以下序列来计算 $Y = F_{n_y} \\, X \\, F_{n_x}^{\\top}$：\n  1) 沿 $X$ 的行应用长度为 $n_x$ 的一维 FFT，生成 $X^{(1)}$。\n  2) 应用分块大小为 $(b_y, b_x)$ 的分块转置，得到形状为 $n_x \\times n_y$ 的 $T = \\left(X^{(1)}\\right)^{\\top}$。\n  3) 沿 $T$ 的行应用长度为 $n_y$ 的一维 FFT，生成 $T^{(1)}$ (这对应于对 $X$ 的列进行 FFT)。\n  4) 应用分块转置，将其转回原始方向 $Y = \\left(T^{(1)}\\right)^{\\top}$。\n- 通过与直接在 $X$ 的两个轴上应用内置一维 FFT 计算出的二维 FFT 进行比较，来验证数值正确性。\n- 对于每个测试用例，报告：\n  1) 设计序列的结果与直接二维 FFT 结果之间的最大绝对误差，以浮点数表示，以及\n  2) 一个缓存局部性改进度量，定义为在朴素的两遍调度（先行后列，无转置）中遇到的最大步长与在基于转置的调度中遇到的最大步长之比。在行主序布局中，朴素方案的最大步长为 $n_x$，改进后方案的最大步长为 $1$，因此该度量等于 $n_x$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且本身是一个双元素列表 $[\\,\\text{误差},\\,\\text{改进度量}\\,]$。\n\n测试套件：\n使用以下测试用例 $(n_x, n_y, b_x, b_y, s)$，其中 $s$ 是用于可复现性的随机种子：\n- 案例 1：$(64, 32, 8, 8, 0)$。\n- 案例 2：$(1, 128, 16, 16, 1)$。\n- 案例 3：$(30, 45, 10, 9, 2)$。\n- 案例 4：$(17, 31, 8, 8, 3)$。\n\n三角因子中的所有角度均以弧度为单位。不涉及物理单位。最终输出必须是浮点数。您的程序必须是自包含的，并且不得从用户或外部文件读取输入。遍处理和转置的序列应在您的解决方案的推导部分进行论证。", "solution": "该问题要求设计并实现一种缓存高效的算法，用于计算存储在行主序内存布局中的复值矩阵 $X \\in \\mathbb{C}^{n_y \\times n_x}$ 的二维离散傅里叶变换 (DFT)。设计的核心是论证并实现一个操作序列，该序列将计算成本高昂的非单位步长内存访问模式转化为一系列单位步长操作。\n\n$X$ 的二维 DFT 定义为矩阵 $Y \\in \\mathbb{C}^{n_y \\times n_x}$，其条目为：\n$$\nY_{k,\\ell} = \\sum_{j=0}^{n_y-1} \\sum_{i=0}^{n_x-1} X_{j,i} \\, e^{-2\\pi \\mathrm{i} \\frac{k j}{n_y}} \\, e^{-2\\pi \\mathrm{i} \\frac{\\ell i}{n_x}}, \\quad \\text{for } 0 \\le k  n_y, \\; 0 \\le \\ell  n_x\n$$\n其中 $\\mathrm{i}$ 是虚数单位。指数核是可分离的，这使得双重求和可以分解为两个连续的步骤。我们可以先对每一行 $j$ 的索引 $i$ 进行求和，然后再对每一列 $\\ell$ 的索引 $j$ 进行求和。\n\n我们通过对 $X$ 的每一行执行长度为 $n_x$ 的一维 DFT 来定义一个中间矩阵 $X^{(1)} \\in \\mathbb{C}^{n_y \\times n_x}$：\n$$\nX^{(1)}_{j,\\ell} = \\sum_{i=0}^{n_x-1} X_{j,i} \\, e^{-2\\pi \\mathrm{i} \\frac{\\ell i}{n_x}}\n$$\n此操作对应于矩阵乘积 $X^{(1)} = X F_{n_x}^{\\top}$，其中 $F_{n_x}$ 是大小为 $n_x \\times n_x$ 的一维 DFT 矩阵，其 $(\\ell, i)$ 项为 $e^{-2\\pi \\mathrm{i} \\frac{\\ell i}{n_x}}$。\n\n然后通过对中间矩阵 $X^{(1)}$ 的每一列执行长度为 $n_y$ 的一维 DFT 来获得最终结果 $Y$：\n$$\nY_{k,\\ell} = \\sum_{j=0}^{n_y-1} X^{(1)}_{j,\\ell} \\, e^{-2\\pi \\mathrm{i} \\frac{k j}{n_y}}\n$$\n这对应于矩阵乘积 $Y = F_{n_y} X^{(1)}$。将这两个步骤结合起来，证实了问题陈述中给出的表达式：$Y = F_{n_y} X F_{n_x}^{\\top}$。\n\n这种可分离性导致了一种朴素的两遍算法：\n1.  对 $X$ 的 $n_y$ 行中的每一行应用长度为 $n_x$ 的一维快速傅里叶变换 (FFT)。\n2.  对所得矩阵 $X^{(1)}$ 的 $n_x$ 列中的每一列应用长度为 $n_y$ 的一维 FFT。\n\n现在，我们分析以行主序存储的矩阵的内存访问模式。在这种布局中，元素 $X_{j,i}$ 的线性内存索引是 $p = j \\cdot n_x + i$。\n- 在第一遍（行向 FFT）中，第 $j$ 行的元素 $(X_{j,0}, X_{j,1}, \\dots, X_{j,n_x-1})$ 位于连续的内存地址。访问这些元素涉及的内存步长为 $1$，这对于现代 CPU 缓存是理想的（表现出高度的空间局部性）。\n- 在第二遍（列向 FFT）中，第 $\\ell$ 列的元素 $(X^{(1)}_{0,\\ell}, X^{(1)}_{1,\\ell}, \\dots, X^{(1)}_{n_y-1,\\ell})$ 位于以 $n_x$ 为步长分隔的内存地址。$X^{(1)}_{j,\\ell}$ 的地址是 $j \\cdot n_x + \\ell$，而该列中下一个元素 $X^{(1)}_{j+1,\\ell}$ 的地址是 $(j+1) \\cdot n_x + \\ell$。如果 $n_x$ 很大，这种非单位步长的访问模式会导致缓存性能不佳，因为每次内存访问都可能获取一个新的缓存行，而其中只有一个元素被使用，从而导致高缓存未命中率。\n\n为了缓解这一性能瓶颈，我们可以交错进行矩阵转置操作，以确保两次 FFT 过程都以单位步长操作数据。所提出的改进算法如下：\n1.  **行向 FFT**：通过沿 $X$ 的行应用长度为 $n_x$ 的 FFT 来计算 $X^{(1)} = X F_{n_x}^{\\top}$。此步骤具有单位步长内存访问，对缓存友好。\n2.  **转置**：计算中间矩阵的转置，$T = (X^{(1)})^{\\top}$。现在，$X^{(1)}$ 的列已成为 $T$ 的行。矩阵 $T$ 的维度为 $n_x \\times n_y$。\n3.  **对转置矩阵进行行向 FFT**：沿 $T$ 的行应用长度为 $n_y$ 的 FFT 以获得 $T^{(1)} = T F_{n_y}^{\\top}$。由于我们再次沿行（$T$ 的行）操作，此步骤也具有单位步长内存访问。此步骤在数学上等同于对 $X^{(1}$ 的列执行 FFT。\n4.  **转置回来**：将结果转置回原始方向，$Y = (T^{(1)})^{\\top}$，以获得最终的 $n_y \\times n_x$ 结果矩阵。\n\n让我们验证这个序列的数学正确性。\n$$\nY = (T^{(1)})^{\\top} = (T F_{n_y}^{\\top})^{\\top}\n$$\n使用属性 $(AB)^{\\top} = B^{\\top}A^{\\top}$，我们有：\n$$\nY = (F_{n_y}^{\\top})^{\\top} T^{\\top} = F_{n_y} T^{\\top}\n$$\n代入 $T = (X^{(1)})^{\\top}$：\n$$\nY = F_{n_y} ((X^{(1)})^{\\top})^{\\top} = F_{n_y} X^{(1)}\n$$\n最后，代入 $X^{(1)} = X F_{n_x}^{\\top}$：\n$$\nY = F_{n_y} (X F_{n_x}^{\\top}) = F_{n_y} X F_{n_x}^{\\top}\n$$\n这证实了基于转置的序列正确地计算了二维 DFT。\n\n如果朴素地实现，转置操作本身也可能遭受缓存局部性不佳的困扰。将矩阵 $A$ 朴素地转置为 $B$ 涉及读取 $A_{j,i}$ 并写入 $B_{i,j}$。如果我们在内层循环中遍历 $i$，从 $A$ 的读取是单位步长的，但对 $B$ 的写入是非单位步长的。为了优化这一点，使用了**分块转置**。矩阵被划分为大小为 $b_y \\times b_x$ 的较小矩形块。理想情况下，每个块都足够小，可以放入 CPU 缓存中。源矩阵的一个块被加载到缓存中，在本地进行转置（此时所有需要的数据都已准备好访问），然后写入其目标位置。与朴素的全矩阵转置相比，该技术最大化了缓存内的数据重用，并显著减少了缓存未命中。\n\n缓存局部性改进度量被定义为朴素调度中的最大步长与基于转置的调度中的最大步长之比。\n- 在朴素调度中，最大步长出现在列向 FFT 过程中，等于 $n_x$。\n- 在基于转置的调度中，两个 FFT 过程都沿行操作，因此 FFT 计算的步长始终为 $1$。问题陈述仅基于 FFT 过程定义了此调度的步长。\n- 因此，改进度量为 $\\frac{\\text{最大步长 (朴素)}}{\\text{最大步长 (改进)}} = \\frac{n_x}{1} = n_x$。该度量通过将 FFT 计算本身重构为完全缓存友好的方式来量化性能增益。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, fft2\n\ndef blocked_transpose(arr: np.ndarray, block_h: int, block_w: int) - np.ndarray:\n    \"\"\"\n    Performs a blocked (tiled) transpose of a 2D numpy array.\n\n    Args:\n        arr (np.ndarray): The input 2D array to transpose.\n        block_h (int): The height of the blocks.\n        block_w (int): The width of the blocks.\n\n    Returns:\n        np.ndarray: The transposed array.\n    \"\"\"\n    h, w = arr.shape\n    transposed_arr = np.empty((w, h), dtype=arr.dtype)\n\n    for j in range(0, h, block_h):\n        for i in range(0, w, block_w):\n            # Define the slice for the source block, handling boundary cases\n            j_end = min(j + block_h, h)\n            i_end = min(i + block_w, w)\n            block = arr[j:j_end, i:i_end]\n\n            # Transpose the block and place it in the destination array\n            transposed_arr[i:i_end, j:j_end] = block.T\n            \n    return transposed_arr\n\ndef solve():\n    \"\"\"\n    Solves the 2D FFT problem for the given test cases.\n    It implements a cache-efficient 2D FFT using transposes and compares it\n    to a direct 2D FFT to verify correctness and calculate a performance metric.\n    \"\"\"\n    # Test cases: (nx, ny, bx, by, seed)\n    test_cases = [\n        (64, 32, 8, 8, 0),\n        (1, 128, 16, 16, 1),\n        (30, 45, 10, 9, 2),\n        (17, 31, 8, 8, 3),\n    ]\n\n    results = []\n    for nx, ny, bx, by, seed in test_cases:\n        # Generate a reproducible random complex array\n        rng = np.random.default_rng(seed)\n        X = rng.random((ny, nx)) + 1j * rng.random((ny, nx))\n\n        # --- Reference solution: Direct 2D FFT ---\n        # scipy.fft.fft2 computes the DFT as defined in the problem\n        Y_direct = fft2(X)\n\n        # --- Transpose-based 2D FFT implementation ---\n        # 1. Apply length-nx 1D FFTs along rows of X\n        # axis=1 for row-wise operations in a (ny, nx) matrix\n        X1 = fft(X, axis=1)\n\n        # 2. Apply a blocked transpose with tile sizes (by, bx)\n        T = blocked_transpose(X1, by, bx)\n\n        # 3. Apply length-ny 1D FFTs along rows of T\n        # T has shape (nx, ny), so axis=1 is the correct dimension\n        T1 = fft(T, axis=1)\n\n        # 4. Apply a blocked transpose back. The matrix T1 has shape (nx, ny),\n        # so the blocks on it are of size (bx, by).\n        Y_computed = blocked_transpose(T1, bx, by)\n\n        # --- Calculate required metrics ---\n        # 1. Maximum absolute error between the two results\n        max_abs_error = np.max(np.abs(Y_computed - Y_direct))\n\n        # 2. Cache-locality improvement metric\n        # Naive max stride = nx (column FFTs on row-major data)\n        # Improved max stride = 1 (all FFTs are row-wise)\n        # Ratio = nx / 1 = nx\n        improvement_metric = float(nx)\n        \n        results.append([max_abs_error, improvement_metric])\n\n    # Final print statement in the exact required format.\n    # str() on a list produces the required \"[item1, item2]\" format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3381024"}]}