{"hands_on_practices": [{"introduction": "第一个练习是卷积定理的一个基本示例。我们将探讨如何将一个更复杂的函数（三角脉冲）视为一个更简单函数（矩形脉冲）的自卷积，以及这个视角如何极大地简化其傅里叶变换的求解过程。这个练习旨在巩固核心概念：时域中的卷积等价于频域中的乘积。[@problem_id:27693]", "problem": "一个三角脉冲函数 $f_a(t)$ 可以通过一个更简单的函数的自卷积生成。考虑一个矩形脉冲函数 $p_a(t)$，定义如下：\n$$\np_a(t) = \n\\begin{cases} \n1  \\text{如果 } |t| \\le \\frac{a}{2} \\\\\n0  \\text{如果 } |t| > \\frac{a}{2} \n\\end{cases}\n$$\n其中 $a$ 是一个正常数，表示脉冲的宽度。\n\n三角脉冲 $f_a(t)$ 由该矩形脉冲与自身的卷积给出：\n$$\nf_a(t) = (p_a * p_a)(t) = \\int_{-\\infty}^{\\infty} p_a(\\tau) p_a(t - \\tau) d\\tau\n$$\n得到的这个三角脉冲以 $t=0$ 为中心，基底宽度为 $2a$，峰高为 $a$。\n\n你的任务是推导该三角脉冲的傅里叶变换 $\\hat{f_a}(k)$。你必须使用卷积定理。\n\n**定义与定理：**\n\n1.  **傅里叶变换：** 函数 $g(t)$ 的傅里叶变换记为 $\\hat{g}(k)$ 或 $\\mathcal{F}\\{g(t)\\}$，定义为：\n    $$\n    \\hat{g}(k) = \\int_{-\\infty}^{\\infty} g(t) e^{-ikt} dt\n    $$\n2.  **卷积定理：** 两个函数 $g(t)$ 和 $h(t)$ 卷积的傅里叶变换是它们各自傅里叶变换的乘积：\n    $$\n    \\mathcal{F}\\{ (g * h)(t) \\} = \\hat{g}(k) \\hat{h}(k)\n    $$\n\n使用这些定义，推导 $\\hat{f_a}(k)$ 的表达式。", "solution": "根据卷积定理，\n$$\\mathcal{F}\\{f_a(t)\\}=\\mathcal{F}\\{p_a * p_a\\}\n=\\bigl(\\mathcal{F}\\{p_a(t)\\}\\bigr)^2.$$\n首先计算\n$$\\hat p_a(k)=\\int_{-\\infty}^{\\infty}p_a(t)\\,e^{-ikt}dt\n=\\int_{-a/2}^{a/2}e^{-ikt}dt\n=\\left[\\frac{e^{-ikt}}{-ik}\\right]_{-a/2}^{a/2}\n=\\frac{e^{-ik(a/2)}-e^{ik(a/2)}}{-ik}\n=\\frac{2\\sin\\!\\bigl(\\tfrac{ka}{2}\\bigr)}{k}.$$\n因此\n$$\\hat f_a(k)=\\bigl(\\hat p_a(k)\\bigr)^2\n=\\left(\\frac{2\\sin\\!\\bigl(\\tfrac{ka}{2}\\bigr)}{k}\\right)^2\n=\\frac{4\\sin^2\\!\\bigl(\\tfrac{ka}{2}\\bigr)}{k^2}\\,. $$", "answer": "$$\\boxed{\\frac{4\\sin^2\\!\\bigl(\\frac{ka}{2}\\bigr)}{k^2}}$$", "id": "27693"}, {"introduction": "在理解了基本原理之后，这个练习将深入探讨卷积定理在伪谱方法中的一个关键应用：处理混叠误差。当我们在物理空间中通过逐点相乘来计算像 $u(x)v(x)w(x)$ 这样的非线性项时，卷积定理告诉我们其结果的频谱会扩张。本练习将指导你确定计算三次非线性项所需的最小网格分辨率（即填充），以避免混叠，这是编写精确谱方法代码的一项关键技能。[@problem_id:3423295]", "problem": "考虑一个周期性域，以及在谱方法和间断 Galerkin (DG) 方法的背景下，对一个三次非线性项的伪谱评估。设 $u(x)$、$v(x)$ 和 $w(x)$ 为三个场，其复傅里叶级数的支撑集仅限于满足 $|k|\\le K$ 的整数波数 $k$，其中 $K$ 为某个固定的正整数。您希望以一种在保留频带 $|k|\\le K$ 上没有混叠的方式计算乘积 $q(x)=u(x)\\,v(x)\\,w(x)$。\n\n采用以下步骤：使用离散傅里叶变换 (DFT) 将每个场变换到由 $M$ 个等距点组成的均匀网格上的物理空间，在该网格上进行逐点相乘以获得 $q(x)$，然后使用快速傅里叶变换 (FFT) 将其反变换回谱空间，并截断以仅保留 $|k|\\le K$ 的模式。假设 $M$ 是一个偶数，并且 DFT 的波数索引是通常的主值集 $k\\in\\{-M/2,\\dots,M/2-1\\}$。\n\n仅从傅里叶级数的卷积定理以及傅里叶空间中的离散卷积由 DFT 按模 $M$ 计算这一事实出发，推导保证在形成三次乘积时，没有混叠误差污染保留模式 $|k|\\le K$ 的最小填充大小 $M$（作为 $K$ 的函数）。然后，将相应的填充因子 $p:=\\dfrac{M}{2K}$ 表示为一个精确的数值。最后，根据您的推导，解释为什么通常用于二次非线性项的 3/2 法则（即填充因子 $p=\\dfrac{3}{2}$）对于三次相互作用来说是不够的。\n\n您的最终答案必须是 $p$ 的单个值（无单位）。无需进行数值四舍五入。", "solution": "设场 $u(x)$、$v(x)$ 和 $w(x)$ 由其复傅里叶级数表示。已知它们的谱的支撑集为满足 $|k| \\le K$ 的整数波数 $k$，其级数表示为：\n$$u(x) = \\sum_{k=-K}^{K} \\hat{u}_k e^{ikx}$$\n$$v(x) = \\sum_{l=-K}^{K} \\hat{v}_l e^{ilx}$$\n$$w(x) = \\sum_{m=-K}^{K} \\hat{w}_m e^{imx}$$\n其中 $\\hat{u}_k$、$\\hat{v}_l$ 和 $\\hat{w}_m$ 是复傅里叶系数。\n\n精确乘积为 $q(x) = u(x)v(x)w(x)$。为确定 $q(x)$ 的谱内容，我们应用卷积定理。首先，我们求中间乘积 $p(x) = u(x)v(x)$ 的谱。$p(x)$ 的傅里叶系数（记为 $\\hat{p}_j$）由 $u(x)$ 和 $v(x)$ 系数的卷积给出：\n$$\\hat{p}_j = (\\hat{u} * \\hat{v})_j = \\sum_{k=-\\infty}^{\\infty} \\hat{u}_k \\hat{v}_{j-k}$$\n由于 $\\hat{u}_k$ 仅在 $|k| \\le K$ 时非零，$\\hat{v}_{j-k}$ 仅在 $|j-k| \\le K$ 时非零，因此系数 $\\hat{p}_j$ 只有在存在满足这两个条件的 $k$ 时才可能非零。对波数应用三角不等式可得 $|j| = |k + (j-k)| \\le |k| + |j-k| \\le K + K = 2K$。因此，场 $p(x)$ 的谱的支撑集为波数 $|j| \\le 2K$。\n\n接下来，我们求最终乘积 $q(x) = p(x)w(x)$ 的谱。其傅里叶系数 $\\hat{q}_n$ 是 $p(x)$ 和 $w(x)$ 系数的卷积：\n$$\\hat{q}_n = (\\hat{p} * \\hat{w})_n = \\sum_{j=-\\infty}^{\\infty} \\hat{p}_j \\hat{w}_{n-j}$$\n在这里，$\\hat{p}_j$ 仅在 $|j| \\le 2K$ 时非零，而 $\\hat{w}_{n-j}$ 仅在 $|n-j| \\le K$ 时非零。再次应用三角不等式，我们求出 $\\hat{q}_n$ 的支撑集：\n$$|n| = |j + (n-j)| \\le |j| + |n-j| \\le 2K + K = 3K$$\n因此，精确的三次乘积 $q(x)$ 是一个带限函数，其傅里叶谱的支撑集为波数 $|n| \\le 3K$。\n\n伪谱法在 $M$ 个点的离散网格上计算乘积。逐点乘积 $q_j = u_j v_j w_j$ 的离散傅里叶变换 (DFT) 产生数值系数 $\\tilde{q}_n$。由于有限采样，这些数值系数通过混叠公式与精确的傅里叶系数 $\\hat{q}_n$ 相关联：\n$$\\tilde{q}_n = \\sum_{s=-\\infty}^{\\infty} \\hat{q}_{n+sM}$$\n我们的目标是确保计算出的系数对于保留的模式（即 $|n| \\le K$ 的模式）没有混叠误差。这意味着我们要求对于所有 $|n| \\le K$ 都有 $\\tilde{q}_n = \\hat{q}_n$。为此，混叠项的和必须为零：\n$$\\sum_{s \\in \\mathbb{Z}, s \\neq 0} \\hat{q}_{n+sM} = 0 \\quad \\text{for all } n \\text{ s.t. } |n| \\le K$$\n由于我们知道 $\\hat{q}_{k'}$ 仅在 $|k'| \\le 3K$ 时非零，因此保留模式上无混叠的条件是：对于范围 $|n| \\le K$ 内的任何整数 $n$ 和任何非零整数 $s$，混叠波数 $n+sM$ 必须落在精确乘积的谱支撑集之外。即：\n$$|n+sM| > 3K \\quad \\text{for all } n \\in [-K, K] \\text{ and } s \\in \\mathbb{Z} \\setminus \\{0\\}$$\n我们只需要检查最严格的情况，即对应于 $s = 1$ 和 $s = -1$ 的情况。对于 $|s| \\ge 2$，如果该不等式对于 $|s|=1$ 成立，那么它也将成立，前提是网格大小是合理的 $M>K$。\n\n情况 1：$s=1$。我们必须有 $|n+M| > 3K$。由于 $M$ 必须足够大以表示初始场（即 $M \\ge 2K+1$），$M$ 是正数且大于 $K$。因此，对于所有 $|n|\\le K$，$n+M$ 都是正数。条件变为 $n+M > 3K$。这必须对所有 $n \\in [-K, K]$ 成立。最坏的情况（即左侧的最小值）发生在 $n=-K$ 时：\n$$-K + M > 3K \\implies M > 4K$$\n\n情况 2：$s=-1$。我们必须有 $|n-M| > 3K$。由于 $M > K$，对于所有 $|n|\\le K$，$n-M$ 都是负数。条件变为 $-(n-M) > 3K$，即 $M-n > 3K$。这必须对所有 $n \\in [-K, K]$ 成立。最坏的情况（即左侧的最小值）发生在 $n=K$ 时：\n$$M - K > 3K \\implies M > 4K$$\n两种情况都得出了相同的严格不等式：$M > 4K$。这是保证三次乘积对所有保留模式 $|k|\\le K$ 都被去混叠的最小网格大小 $M$ 的条件。\n\n问题将填充因子定义为 $p := \\dfrac{M}{2K}$。代入推导出的 $M$ 的条件：\n$$p \\cdot (2K) > 4K$$\n由于 $K$ 是一个正整数，$2K > 0$，我们可以用它来除不等式两边而不改变不等号的方向：\n$$p > 2$$\n问题要求将填充因子表示为“一个”精确的数值。这对应于所需条件的边界。任何大于 2 的填充因子都将成功地对三次非线性项进行去混叠。因此，该法则是基于这个边界值。所需的最小填充因子从上方趋近于此值，因此该法则用数字 2 表示。\n\n最后，我们解释为什么 3/2 法则（$p=\\dfrac{3}{2}$）是不够的。$p=\\dfrac{3}{2}$ 的填充因子意味着网格大小为 $M = p \\cdot (2K) = \\dfrac{3}{2} \\cdot (2K) = 3K$。对于任何正整数 $K$，这个 $M$ 的选择都违反了推导出的必要条件 $M > 4K$。\n为了明确地看到这个失败，考虑 $M=3K$。对于模式 $n=K$ 的混叠公式是 $\\tilde{q}_K = \\sum_s \\hat{q}_{K+s(3K)}$。当 $s=-1$ 时，其中一个混叠项是 $\\hat{q}_{K-3K} = \\hat{q}_{-2K}$。波数 $-2K$ 位于精确乘积 $q(x)$ 的谱支撑集之内（因为对于 $K\\ge 0$，有 $|-2K| \\le 3K$）。通常情况下，$\\hat{q}_{-2K}$ 是非零的。因此，$\\tilde{q}_K$ 的计算被 $\\hat{q}_{-2K}$ 污染，结果是混叠的：$\\tilde{q}_K = \\hat{q}_K + \\hat{q}_{-2K} + \\dots \\neq \\hat{q}_K$。因此，对于二次非线性项（要求 $M>3K$）来说足够的 3/2 法则，对于三次非线性项来说是不够的，因为后者会产生更高的波数，从而需要更大的网格来进行去混叠。", "answer": "$$\n\\boxed{2}\n$$", "id": "3423295"}, {"introduction": "最后一个高级实践展示了傅里叶表示在定义和计算复杂非局部算子（如分数阶拉普拉斯算子）方面的强大威力。我们可以将物理空间中难以处理的奇异积分，转化为傅里叶空间中的简单乘法来实现该算子。这个动手编程问题将比较谱方法和物理空间卷积方法，突显傅里叶方法的高效性，并探索其在间断Galerkin（DG）框架下的应用。[@problem_id:3374108]", "problem": "要求您利用傅里叶表示的卷积定理，实现并验证一维域上分数阶拉普拉斯算子的数值实现。阶数为 $\\alpha \\in (0,2)$ 的分数阶拉普拉斯算子，记作 $(-\\Delta)^{\\alpha/2}$，在无限域上作为平移不变算子作用于函数 $u(x)$，并通过傅里叶变换在周期域上具有谱乘子表示。在非周期单元上的间断 Galerkin (DG) 公式中，内部奇异积分必须辅以边界校正，以解释单元外部的相互作用。您的任务将整合以下基础理论：\n\n- 傅里叶变换定义：对于长度为 $L$ 的周期域上足够光滑的函数 $u(x)$，其傅里叶系数 $\\hat{u}(\\xi)$ 是 $u$ 的谱表示。平移不变线性算子在傅里叶空间中作为乘子作用；对于符号为 $m(\\xi)$ 的算子，其在物理空间中的作用对应于将 $\\hat{u}(\\xi)$ 乘以 $m(\\xi)$。\n- 卷积定理：卷积的傅里叶变换是傅里叶变换的乘积，这使得通过谱乘子表示带有奇异核的积分算子成为可能。\n- 实轴上分数阶拉普拉斯算子的主值奇异积分表示：对于在无穷远处衰减足够快的函数 $u$，算子 $(-\\Delta)^{\\alpha/2}u(x)$ 可以用一个主值积分表示，该积分涉及一个仅依赖于 $|x-y|$ 和阶数 $\\alpha$ 的奇异核；其归一化常数是关于 $\\alpha$ 的已知函数。\n\n您将实现并比较两种互补的数值方法：\n\n1. 在具有周期性边界条件的周期域 $[0,2\\pi)$ 上，通过将傅里叶系数乘以 $|\\xi|^{\\alpha}$ 并变换回物理空间，使用傅里叶空间乘子法近似 $(-\\Delta)^{\\alpha/2}u(x)$。同时，通过对实轴奇异核进行周期求和，并在奇异点处取柯西主值，构造一个物理空间的奇异卷积来近似同一算子。通过计算离散 $L^2$ 范数下的相对误差来比较这两种近似。\n2. 在具有零外部延拓的单个非周期 DG 单元 $[0,1]$ 上，通过仅在 $[0,1]$ 上离散化主值积分来近似内部算子，然后添加代表在补集 $\\mathbb{R}\\setminus[0,1]$ 上的尾部积分的边界校正。相对于在 $[0,1]$ 上使用零外部延拓的加密网格上计算的高分辨率参考解，通过仅内部近似的最大绝对误差与内部加校正近似的最大绝对误差之比，来量化边界校正带来的改进。\n\n在数值实现中，请使用以下经过充分检验的事实和定义：\n\n- $(-\\Delta)^{\\alpha/2}$ 的傅里叶空间乘子是 $|\\xi|^{\\alpha}$，其中 $\\xi$ 表示角频率。\n- 在实轴上，分数阶拉普拉斯算子具有奇异积分表示\n$$\n(-\\Delta)^{\\alpha/2}u(x) = C_{\\alpha}\\,\\mathrm{PV}\\int_{\\mathbb{R}} \\frac{u(x)-u(y)}{|x-y|^{1+\\alpha}}\\,\\mathrm{d}y,\n$$\n其中 $C_{\\alpha} = \\dfrac{\\alpha\\,2^{\\alpha-1}\\,\\Gamma\\!\\left(\\dfrac{1+\\alpha}{2}\\right)}{\\sqrt{\\pi}\\,\\Gamma\\!\\left(1-\\dfrac{\\alpha}{2}\\right)}$ 且 $\\Gamma(\\cdot)$ 是伽马函数。对于周期域，通过对实轴核进行整数平移求和来使其周期化。对于具有零外部延拓的单个单元 $[0,1]$，对应于尾部积分的边界校正为\n$$\nB_{\\alpha}(x) = C_{\\alpha}\\,u(x)\\,\\frac{1}{\\alpha}\\left(x^{-\\alpha} + (1-x)^{-\\alpha}\\right),\n$$\n且完整算子等于在 $[0,1]$ 上的内部主值积分加上 $B_{\\alpha}(x)$。\n\n您的程序必须实现以下测试套件，并按下文指定的精确最终输出格式生成结果。\n\n测试套件：\n\n- 在 $[0,2\\pi)$ 上的周期性测试：\n  - 函数：$u(x) = \\sin(3x)$，在 $N_{\\mathrm{p}} = 256$ 个均匀间隔点上采样。\n  - 傅里叶乘子必须使用角频率。\n  - 物理空间周期性奇异卷积：通过对 $m=-M,\\ldots,M$（其中 $M=8$）的镜像求和来近似周期化核。\n  - 阶数：$\\alpha = 0.6$ 和 $\\alpha = 1.4$。\n  - 对每个 $\\alpha$，计算相对离散 $L^2$ 误差：\n    $$\n    \\varepsilon_{\\mathrm{per}}(\\alpha)=\\frac{\\|(-\\Delta)^{\\alpha/2}u_{\\mathrm{FFT}}-(-\\Delta)^{\\alpha/2}u_{\\mathrm{phys}}\\|_{2}}{\\|(-\\Delta)^{\\alpha/2}u_{\\mathrm{FFT}}\\|_{2}},\n    $$\n    其中离散 $L^2$ 范数通过 $\\left(\\sum_{j}|v_j|^2\\Delta x\\right)^{1/2}$ 近似，$\\Delta x$ 是网格间距。\n- 在 $[0,1]$ 上的 DG 单元测试：\n  - 函数：$u(x) = x(1-x)$。\n  - 粗网格：$N=64$ 个内部节点，位于 $x_i = i/N$, $i=1,\\ldots,N-1$。\n  - 精细网格参考：$N_{\\mathrm{ref}}=1024$ 个内部节点，位于 $x_k = k/N_{\\mathrm{ref}}$, $k=1,\\ldots,N_{\\mathrm{ref}}-1$。使用相同的内部主值积分离散化并添加边界校正以形成精细参考解。仅通过选择索引 $k=i\\cdot(N_{\\mathrm{ref}}/N)$ 在粗网格点上评估参考解。\n  - 阶数：$\\alpha = 0.6$ 和 $\\alpha = 1.4$。\n  - 对每个 $\\alpha$，计算改进比\n    $$\n    \\rho(\\alpha)=\\frac{\\|(-\\Delta)^{\\alpha/2}u_{\\mathrm{int}}-(-\\Delta)^{\\alpha/2}u_{\\mathrm{ref}}\\|_{\\infty}}{\\|(-\\Delta)^{\\alpha/2}u_{\\mathrm{int+bc}}-(-\\Delta)^{\\alpha/2}u_{\\mathrm{ref}}\\|_{\\infty}},\n    $$\n    其中 $\\|\\cdot\\|_{\\infty}$ 是粗网格上的 sup 范数，$(-\\Delta)^{\\alpha/2}u_{\\mathrm{int}}$ 是粗网格上仅内部的近似，$(-\\Delta)^{\\alpha/2}u_{\\mathrm{int+bc}}$ 是粗网格上内部加边界校正的近似，而 $(-\\Delta)^{\\alpha/2}u_{\\mathrm{ref}}$ 是限制在粗网格点上的精细网格参考解。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含四个结果，以逗号分隔列表形式并用方括号括起：$[\\varepsilon_{\\mathrm{per}}(0.6),\\varepsilon_{\\mathrm{per}}(1.4),\\rho(0.6),\\rho(1.4)]$。\n- 所有输出都必须是浮点数。不涉及物理单位。\n\n无需用户输入；您的程序必须能按原样运行。确保所选离散化方法的数值稳定性和合理精度。实现不得依赖任何外部文件或网络访问。", "solution": "我们从傅里叶变换和卷积定理出发，设计分数阶拉普拉斯算子的谱方法和物理空间两种实现，然后为非周期性间断 Galerkin 单元引入边界校正。\n\n基本原理与推导：\n\n1. 傅里叶变换和乘子表示。对于定义在 $[0,L)$ 上的足够光滑的周期函数 $u(x)$，其傅里叶级数表示为 $u(x) = \\sum_{\\xi \\in \\frac{2\\pi}{L}\\mathbb{Z}} \\hat{u}(\\xi)\\,e^{i\\xi x}$，其中 $\\xi$ 表示角频率。对于平移不变线性算子，其在傅里叶空间中的作用是乘法性的：如果算子 $\\mathcal{L}$ 的符号为 $m(\\xi)$，则 $\\widehat{\\mathcal{L}u}(\\xi) = m(\\xi)\\,\\hat{u}(\\xi)$。分数阶拉普拉斯算子通过其谱符号定义为 $m(\\xi) = |\\xi|^{\\alpha}$，这与标准拉普拉斯算子（其符号为 $-\\xi^2$）一致。因此，在周期域上，通过傅里叶空间乘法实现 $(-\\Delta)^{\\alpha/2}u$ 的方法是计算 $\\hat{u}(\\xi)$，应用 $\\widehat{(-\\Delta)^{\\alpha/2}u}(\\xi) = |\\xi|^{\\alpha}\\hat{u}(\\xi)$，然后进行逆变换。\n\n2. 卷积定理和奇异核表示。在实轴上，分数阶拉普拉斯算子具有公认的奇异积分形式\n$$\n(-\\Delta)^{\\alpha/2}u(x) = C_{\\alpha}\\,\\mathrm{PV}\\int_{\\mathbb{R}} \\frac{u(x)-u(y)}{|x-y|^{1+\\alpha}}\\,\\mathrm{d}y,\n$$\n其中 $C_{\\alpha} = \\dfrac{\\alpha\\,2^{\\alpha-1}\\,\\Gamma\\!\\left(\\dfrac{1+\\alpha}{2}\\right)}{\\sqrt{\\pi}\\,\\Gamma\\!\\left(1-\\dfrac{\\alpha}{2}\\right)}$ 确保该积分算子与傅里叶乘子 $|\\xi|^{\\alpha}$ 一致。卷积定理连接了积分核和谱乘子：核的傅里叶变换是乘子，反之亦然。在长度为 $L$ 的周期域上，适当的奇异核是通过对实轴核进行所有整数平移求和得到的周期化形式，这对应于将 $u$ 与周期化的奇异核进行卷积，并产生相同的谱乘子 $|\\xi|^{\\alpha}$。\n\n3. 非周期 DG 单元的边界校正。考虑单个 DG 单元 $[0,1]$，其外部延拓为零，即当 $x \\in [0,1]$ 时 $\\tilde{u}(x) = u(x)$，当 $x \\notin [0,1]$ 时 $\\tilde{u}(x)=0$。实轴上的算子\n$$\n(-\\Delta)^{\\alpha/2}\\tilde{u}(x) = C_{\\alpha}\\,\\mathrm{PV}\\int_{0}^{1}\\frac{u(x)-u(y)}{|x-y|^{1+\\alpha}}\\,\\mathrm{d}y + C_{\\alpha}\\,\\int_{\\mathbb{R}\\setminus[0,1]}\\frac{u(x)-0}{|x-y|^{1+\\alpha}}\\,\\mathrm{d}y\n$$\n可以分解为单元内部的主值积分和单元外部的尾部贡献。尾部积分具有闭合形式\n$$\n\\int_{\\mathbb{R}\\setminus[0,1]}\\frac{1}{|x-y|^{1+\\alpha}}\\,\\mathrm{d}y = \\int_{1}^{\\infty}\\frac{1}{(y-x)^{1+\\alpha}}\\,\\mathrm{d}y + \\int_{-\\infty}^{0}\\frac{1}{(x-y)^{1+\\alpha}}\\,\\mathrm{d}y = \\frac{1}{\\alpha}\\left(\\frac{1}{(1-x)^{\\alpha}}+\\frac{1}{x^{\\alpha}}\\right),\n$$\n因此边界校正项为\n$$\nB_{\\alpha}(x) = C_{\\alpha}\\,u(x)\\,\\frac{1}{\\alpha}\\left(x^{-\\alpha} + (1-x)^{-\\alpha}\\right).\n$$\n因此，对于零外部延拓，完整算子恰好等于在 $[0,1]$ 上的内部主值积分加上 $B_{\\alpha}(x)$。\n\n算法设计：\n\nA. 周期域 $[0,2\\pi)$。\n\n- 网格与函数。在 $N_{\\mathrm{p}}=256$ 个均匀间隔的点上采样 $u(x)=\\sin(3x)$，间距为 $\\Delta x = L/N_{\\mathrm{p}}$，且 $L=2\\pi$。\n- 谱方法。使用标准的快速傅里叶变换 (FFT) 计算离散傅里叶变换。角频率通过 $\\xi_k = 2\\pi f_k$ 计算，其中 $f_k$ 是来自 $\\mathrm{fftfreq}$ 的离散频率；对于 $L=2\\pi$ 和均匀间距，$\\xi_k$ 与整数对齐。将每个傅里叶系数 $\\hat{u}(\\xi_k)$ 乘以 $|\\xi_k|^{\\alpha}$ 并进行逆变换，以获得物理空间中的谱近似。\n- 物理空间周期性奇异卷积。通过对 $m=-M,\\ldots,M$（其中 $M=8$）的实轴奇异核求和来构造周期化核。对于每个网格点 $x_i$，使用均匀 $\\Delta x$ 的梯形法则，通过对所有网格点 $x_j$（对于 $m=0$ 项，不包括 $j=i$）的离散求和来近似主值积分：\n$$\n\\left[(-\\Delta)^{\\alpha/2}u\\right](x_i) \\approx C_{\\alpha}\\sum_{j=0}^{N_{\\mathrm{p}}-1}\\left(u(x_i)-u(x_j)\\right)\\left(\\sum_{m=-M}^{M}\\frac{1}{|x_i-x_j+mL|^{1+\\alpha}}\\right)\\Delta x,\\quad \\text{其中通过省略 } j=i, m=0 \\text{ 来处理主值}。\n$$\n- 误差度量。计算相对离散 $L^2$ 误差，使用 $\\|v\\|_2 = \\left(\\sum_j |v_j|^2 \\Delta x\\right)^{1/2}$。\n\nB. 具有零外部延拓的单个 DG 单元 $[0,1]$。\n\n- 网格与函数。在粗网格上，对于 $i=1,\\ldots,N-1$，使用内部节点 $x_i = i/N$，其中 $N=64$，函数为 $u(x)=x(1-x)$。在精细网格上，使用 $N_{\\mathrm{ref}}=1024$ 个内部节点和相同的函数。粗网格节点包含在精细网格的索引 $k = i(N_{\\mathrm{ref}}/N)$ 处。\n- 内部算子。使用梯形法则近似在 $[0,1]$ 上的主值积分：\n$$\n\\left[(-\\Delta)^{\\alpha/2}u\\right]_{\\mathrm{int}}(x_i) \\approx C_{\\alpha}\\sum_{\\substack{j=1 \\\\ j\\neq i}}^{N-1}\\frac{u(x_i)-u(x_j)}{|x_i-x_j|^{1+\\alpha}}\\Delta x,\n$$\n其中 $\\Delta x = 1/N$。在精细网格上使用 $\\Delta x_{\\mathrm{ref}} = 1/N_{\\mathrm{ref}}$ 进行相同的近似，以获得高分辨率的内部算子。\n- 边界校正。在两个网格上都添加 $B_{\\alpha}(x_i) = C_{\\alpha}\\,u(x_i)\\,\\dfrac{1}{\\alpha}\\left(x_i^{-\\alpha} + (1-x_i)^{-\\alpha}\\right)$ 以形成校正后的算子。这在精细网格上产生了精细参考解 $(-\\Delta)^{\\alpha/2}u_{\\mathrm{ref}}$。\n- 误差与改进比。将精细参考解限制到粗网格节点，并计算 sup 范数误差：\n$$\nE_{\\mathrm{int}}(\\alpha) = \\max_i \\left| \\left[(-\\Delta)^{\\alpha/2}u\\right]_{\\mathrm{int}}(x_i) - \\left[(-\\Delta)^{\\alpha/2}u\\right]_{\\mathrm{ref}}(x_i) \\right|,\n$$\n$$\nE_{\\mathrm{corr}}(\\alpha) = \\max_i \\left| \\left[(-\\Delta)^{\\alpha/2}u\\right]_{\\mathrm{int+bc}}(x_i) - \\left[(-\\Delta)^{\\alpha/2}u\\right]_{\\mathrm{ref}}(x_i) \\right|,\n$$\n并报告比值 $\\rho(\\alpha) = E_{\\mathrm{int}}(\\alpha)/E_{\\mathrm{corr}}(\\alpha)$。\n\n数值考量：\n\n- 常数 $C_{\\alpha}$ 使用所提供公式通过伽马函数实现，以确保积分定义和谱定义之间的一致性。\n- 通过在离散求和中省略自相互作用来强制处理主值。\n- 周期化核使用有限数量的镜像 ($M=8$) 来近似无穷级数，由于 $|mL|^{-(1+\\alpha)}$ 的快速衰减，这对所选的阶数 $\\alpha$ 来说是足够的。\n- 精细网格参考解采用显著加密的离散化，作为在 DG 单元上评估误差的基准。\n\n程序按指定顺序输出 $\\alpha=0.6$ 和 $\\alpha=1.4$ 的周期性相对误差，然后是相同 $\\alpha$ 值的 DG 改进比，作为单行浮点数列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma\n\ndef c_alpha(alpha: float) -> float:\n    # Normalization constant for 1D fractional Laplacian\n    return alpha * (2 ** (alpha - 1)) * gamma((1 + alpha) / 2) / (np.sqrt(np.pi) * gamma(1 - alpha / 2))\n\ndef fractional_laplacian_fft(u: np.ndarray, L: float, alpha: float) -> np.ndarray:\n    # Compute spectral fractional Laplacian via FFT multiplier |xi|^alpha\n    N = u.size\n    dx = L / N\n    # Angular frequencies corresponding to FFT bins\n    xi = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n    u_hat = np.fft.fft(u)\n    # Multiply by |xi|^alpha\n    u_hat_mul = (np.abs(xi) ** alpha) * u_hat\n    # Inverse FFT to physical space\n    u_frac = np.fft.ifft(u_hat_mul).real\n    return u_frac\n\ndef fractional_laplacian_periodic_physical(u: np.ndarray, L: float, alpha: float, M: int) -> np.ndarray:\n    # Physical-space singular convolution with periodized kernel summed over images m=-M..M\n    N = u.size\n    dx = L / N\n    x = np.linspace(0.0, L - dx, N)\n    # Pairwise differences\n    delta = x[:, None] - x[None, :]\n    # Build periodized kernel by summing images\n    kernel = np.zeros_like(delta)\n    for m in range(-M, M + 1):\n        shifted = delta + m * L\n        # Add contribution; principal value will be handled by zeroing diagonal later\n        kernel += 1.0 / (np.abs(shifted) ** (1.0 + alpha))\n    # Principal value: remove singular self-interaction (m=0, j=i)\n    np.fill_diagonal(kernel, 0.0)\n    ca = c_alpha(alpha)\n    # Discrete convolution integral\n    diff = u[:, None] - u[None, :]\n    op = ca * (diff * kernel).sum(axis=1) * dx\n    return op\n\ndef dg_interior_operator(u: np.ndarray, x: np.ndarray, alpha: float) -> np.ndarray:\n    # Interior principal value integral over [0,1] using trapezoidal rule on uniform interior nodes\n    N = x.size + 1  # since x has interior nodes 1..N-1\n    dx = 1.0 / N\n    # Pairwise differences on interior nodes\n    delta = x[:, None] - x[None, :]\n    kernel = 1.0 / (np.abs(delta) ** (1.0 + alpha))\n    # Principal value: zero out diagonal\n    np.fill_diagonal(kernel, 0.0)\n    ca = c_alpha(alpha)\n    diff = u[:, None] - u[None, :]\n    op_int = ca * (diff * kernel).sum(axis=1) * dx\n    return op_int\n\ndef dg_boundary_correction(u: np.ndarray, x: np.ndarray, alpha: float) -> np.ndarray:\n    # Boundary correction for zero exterior extension tails\n    ca = c_alpha(alpha)\n    bc = ca * u * (1.0 / alpha) * (np.power(x, -alpha) + np.power(1.0 - x, -alpha))\n    return bc\n\ndef periodic_tests():\n    L = 2.0 * np.pi\n    Np = 256\n    dx = L / Np\n    x = np.linspace(0.0, L - dx, Np)\n    u = np.sin(3.0 * x)\n    alphas = [0.6, 1.4]\n    M = 8\n    errors = []\n    for alpha in alphas:\n        op_fft = fractional_laplacian_fft(u, L, alpha)\n        op_phys = fractional_laplacian_periodic_physical(u, L, alpha, M)\n        # Discrete L2 norms with measure dx\n        diff = op_fft - op_phys\n        num = np.sqrt(np.sum(np.abs(diff) ** 2) * dx)\n        den = np.sqrt(np.sum(np.abs(op_fft) ** 2) * dx)\n        err = num / den if den != 0 else 0.0\n        errors.append(err)\n    return errors\n\ndef dg_tests():\n    # Coarse grid\n    N = 64\n    x_coarse = np.arange(1, N) / N  # interior nodes\n    u_coarse = x_coarse * (1.0 - x_coarse)\n    # Fine grid for reference\n    Nref = 1024\n    x_ref = np.arange(1, Nref) / Nref\n    u_ref = x_ref * (1.0 - x_ref)\n    m = Nref // N  # must be integer\n    # Map coarse indices to fine grid indices\n    coarse_to_ref_idx = (np.arange(1, N) * m) - 1  # zero-based indexing for fine grid\n    alphas = [0.6, 1.4]\n    ratios = []\n    for alpha in alphas:\n        op_int_coarse = dg_interior_operator(u_coarse, x_coarse, alpha)\n        op_corr_coarse = op_int_coarse + dg_boundary_correction(u_coarse, x_coarse, alpha)\n        # Fine reference\n        op_int_ref_full = dg_interior_operator(u_ref, x_ref, alpha)\n        op_ref_full = op_int_ref_full + dg_boundary_correction(u_ref, x_ref, alpha)\n        # Restrict fine reference to coarse nodes\n        op_ref_at_coarse = op_ref_full[coarse_to_ref_idx]\n        # Compute sup norm errors\n        e_int = np.max(np.abs(op_int_coarse - op_ref_at_coarse))\n        e_corr = np.max(np.abs(op_corr_coarse - op_ref_at_coarse))\n        # Avoid division by zero\n        ratio = (e_int / e_corr) if e_corr != 0 else np.inf\n        ratios.append(ratio)\n    return ratios\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Periodic errors for alpha=0.6 and alpha=1.4, then DG improvement ratios for the same alphas.\n    periodic_errors = periodic_tests()\n    dg_ratios = dg_tests()\n    results = periodic_errors + dg_ratios\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3374108"}]}