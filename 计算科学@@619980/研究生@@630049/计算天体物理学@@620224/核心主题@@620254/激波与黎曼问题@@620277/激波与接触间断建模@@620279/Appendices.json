{"hands_on_practices": [{"introduction": "现代激波捕获格式的核心在于其能够在光滑区域实现高阶精度，同时在间断处抑制非物理振荡。这通常通过高阶重构（如MUSCL格式）与斜率限制器的组合来实现。本练习将指导您亲手实现这一核心组件，通过对一个接触间断的数值模拟，直观且定量地评估不同斜率限制器（如minmod、MC、van Leer等）的作用。通过计算过冲、数值耗散和界面宽度等指标，您将为开发和使用流体动力学程序建立起关于不同限制器之间权衡利弊的实践直觉 [@problem_id:3521267]。", "problem": "考虑在一维标量守恒律 $\\partial_t q + \\partial_x f(q) = 0$ 中，一个长度为 $L$ 的周期性区域上存在包含单个接触间断的分段常数初始条件。在可压缩流的接触间断中，像密度或质量分数这样的被动平流标量会被底层速度场输运，其形状保持不变。使用线性平流通量 $f(q) = a q$ 来模拟此输运过程，其中 $a$ 为恒定平流速度，因此守恒律变为 $\\partial_t q + a \\partial_x q = 0$。使用有限体积法，其中网格单元均匀，$q_i^n$ 表示在时间层 $n$ 时网格单元索引 $i$ 处的单元平均值，均匀网格间距为 $\\Delta x = L/N$，时间步长 $\\Delta t$ 由指定的库朗数 $C$ 通过 $\\Delta t = C \\Delta x / |a|$ 设定。单个时间步的更新公式为 $q_i^{n+1} = q_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right)$，其中 $F_{i+1/2}^n$ 是网格单元 $i$ 和 $i+1$ 之间界面上的数值通量，并施加周期性边界条件。\n\n通过对 $q_i^n$ 进行分段线性重构来构造二阶精度守恒律的单调上游中心格式 (MUSCL) 的界面状态 $q_{i+1/2}^{L}$ 和 $q_{i+1/2}^{R}$，斜率限制器从以下集合中选择：minmod、单调中心 (MC)、van Leer 或 superbee。斜率限制器必须强制执行与总变差减小 (TVD) 要求一致的单调性，在存在局部极值时降为一阶迎风格式，并在可能的情况下锐化接触间断而不产生伪振荡。对线性平流使用迎风 Godunov 通量：对于 $a \\ge 0$，选择 $F_{i+1/2}^n = a \\, q_{i+1/2}^{L}$；对于 $a  0$，选择 $F_{i+1/2}^n = a \\, q_{i+1/2}^{R}$。\n\n使用上述格式从初始数据推进一个时间步后，使用以下指标评估振荡控制和接触间断锐度：\n- 最大过冲幅值：令 $q_{\\min}^0 = \\min_i q_i^0$ 和 $q_{\\max}^0 = \\max_i q_i^0$，定义 $\\mathrm{overshoot\\_max} = \\max_i \\max\\left(0, q_i^{1} - q_{\\max}^0, q_{\\min}^0 - q_i^{1}\\right)$，表示为浮点数。\n- 总变差增量：令 $\\mathrm{TV}(q) = \\sum_i \\left|q_{i+1} - q_i\\right|$（使用周期性索引），并定义 $\\Delta \\mathrm{TV} = \\mathrm{TV}(q^{1}) - \\mathrm{TV}(q^{0})$，表示为浮点数。\n- 接触过渡宽度：给定已知的平台值 $q_L$（左状态）和 $q_R$（右状态），定义 $\\mathrm{width} = \\#\\{i \\, | \\, \\min(q_L,q_R)  q_i^{1}  \\max(q_L,q_R)\\}$，表示为更新后其值严格位于两个平台之间的网格单元的整数计数。\n\n您的程序必须实现单时间步的重构和更新，并为下面的每个测试用例计算这些指标。使用周期性区域。所有数学运算必须一致且科学上合理。不允许外部输入。\n\n测试套件：\n- 用例 1：$N = 100$，$L = 1$，$a = 1$，$C = 0.8$，限制器 = minmod，接触位置位于区域的 $x_c = 0.4$ 比例处，平台值 $q_L = 1.0$，$q_R = 0.1$，附加局部噪声幅值 $\\epsilon = 0$。\n- 用例 2：$N = 100$，$L = 1$，$a = 1$，$C = 0.95$，限制器 = MC，接触位置位于区域的 $x_c = 0.4$ 比例处，平台值 $q_L = 1.0$，$q_R = 0.1$，附加局部噪声幅值 $\\epsilon = 0.01$，通过 $q_i \\mapsto q_i + \\epsilon \\sin\\left(2\\pi i / N\\right)$ 精确应用于以接触点为中心的 5 个网格单元。\n- 用例 3：$N = 20$，$L = 1$，$a = 1$，$C = 0.5$，限制器 = vanleer，接触位置位于区域的 $x_c = 0.5$ 比例处，平台值 $q_L = 2.0$，$q_R = 1.5$，$\\epsilon = 0$。\n- 用例 4：$N = 80$，$L = 1$，$a = -1$，$C = 0.9$，限制器 = superbee，接触位置位于区域的 $x_c = 0.5$ 比例处，平台值 $q_L = 1.0$，$q_R = 0.0$，附加局部噪声幅值 $\\epsilon = 0.005$，通过 $q_i \\mapsto q_i + \\epsilon \\sin\\left(2\\pi i / N\\right)$ 精确应用于以接触点为中心的 3 个网格单元。\n- 用例 5（边界条件和退化检查）：$N = 50$，$L = 1$，$a = 1$，$C = 0.7$，限制器 = MC，接触位置位于区域的 $x_c = 0.3$ 比例处，平台值 $q_L = 0.5$，$q_R = 0.5$，$\\epsilon = 0$。\n\n初始化：对于每个用例，在均匀网格点 $x_i = (i+1/2)\\Delta x$ 上初始化 $q_i^0$，设置 $q_i^0 = q_L$（对于 $x_i  x_c L$）和 $q_i^0 = q_R$（对于 $x_i \\ge x_c L$），然后以接触点索引 $i_c = \\lfloor x_c N \\rfloor$ 为中心，在指定数量的网格单元上添加指定的局部噪声。\n\n最终输出格式：您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，其本身是一个包含三个值的列表 $[\\mathrm{overshoot\\_max}, \\mathrm{width}, \\Delta \\mathrm{TV}]$。将浮点值 $\\mathrm{overshoot\\_max}$ 和 $\\Delta \\mathrm{TV}$ 四舍五入到 6 位小数，并将 $\\mathrm{width}$ 作为整数输出。例如，包含两个用例的输出应如下所示：$[[0.000123,4,0.001234],[0.0,0,-0.000456]]$。", "solution": "用户提供的问题已经过验证，被确定为是合理的、适定的和客观的。它代表了计算流体动力学和天体物理学领域中一项标准任务。以下解决方案详细解释了方法论及其实施。\n\n该问题要求实现一个二阶精度守恒律的单调上游中心格式 (MUSCL) 有限体积法，以求解一维线性平流方程，\n$$\n\\partial_t q + a \\partial_x q = 0\n$$\n在长度为 $L$ 的周期性区域上。此处，$q(x,t)$ 是一个标量，而 $a$ 是一个恒定的平流速度。这个方程是守恒律 $\\partial_t q + \\partial_x f(q) = 0$ 的一个特例，其通量函数为线性函数 $f(q) = aq$。\n\n数值解在由 $N$ 个单元组成的均匀网格上计算，其中单元 $i$ 覆盖区间 $[x_{i-1/2}, x_{i+1/2}]$。单元中心位于 $x_i = (i+1/2)\\Delta x$，其中 $i=0, 1, \\dots, N-1$，网格间距为 $\\Delta x = L/N$。在时间层 $n$ 时，单元 $i$ 中 $q$ 的单元平均值表示为 $q_i^n$。\n\n有限体积法通过以下守恒公式将单元平均值从一个时间层 $n$ 更新到下一个时间层 $n+1$：\n$$\nq_i^{n+1} = q_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right)\n$$\n其中 $\\Delta t$ 是时间步长，$F_{i+1/2}^n$ 是单元 $i$ 和 $i+1$ 之间界面上的数值通量。时间步长由 Courant-Friedrichs-Lewy (CFL) 条件确定，即 $\\Delta t = C \\Delta x / |a|$，其中 $C$ 是指定的库朗数，为保证稳定性，其值必须小于或等于 $1$。应用周期性边界条件，意味着索引按模 $N$ 处理。\n\nMUSCL 格式的核心是在单元界面上对状态进行二阶精度的空间重构。在每个单元 $i$ 内部，数据由一个分段线性函数表示。这导致在每个界面上产生两个不同的值：$q_{i+1/2}^L$，从左侧（单元 $i$）重构的状态，和 $q_{i+1/2}^R$，从右侧（单元 $i+1$）重构的状态。它们由以下公式给出：\n$$\nq_{i+1/2}^L = q_i^n + \\frac{1}{2} \\sigma_i\n$$\n$$\nq_{i+1/2}^R = q_{i+1}^n - \\frac{1}{2} \\sigma_{i+1}\n$$\n此处，$\\sigma_i$ 是跨单元 $i$ 的 $q$ 变化的斜率限制表示。为防止伪振荡并确保格式是总变差减小 (TVD) 的，斜率 $\\sigma_i$ 通过将斜率限制器函数应用于相对于单元 $i$ 的后向和前向差分来计算：$\\Delta q_{i-1/2} = q_i^n - q_{i-1}^n$ 和 $\\Delta q_{i+1/2} = q_{i+1}^n - q_i^n$。\n$$\n\\sigma_i = \\text{limiter}(\\Delta q_{i-1/2}, \\Delta q_{i+1/2})\n$$\n限制器函数定义如下，对于两个参数 $u$ 和 $v$：\n1.  **minmod**:\n    $$\n    \\text{minmod}(u, v) =\n    \\begin{cases}\n    \\text{sgn}(u) \\min(|u|, |v|)  \\text{if } uv  0 \\\\\n    0  \\text{if } uv \\le 0\n    \\end{cases}\n    $$\n2.  **单调中心 (MC)**:\n    $$\n    \\text{MC}(u, v) =\n    \\begin{cases}\n    \\text{sgn}(u) \\min\\left(2|u|, 2|v|, \\frac{|u+v|}{2}\\right)  \\text{if } uv  0 \\\\\n    0  \\text{if } uv \\le 0\n    \\end{cases}\n    $$\n3.  **van Leer**:\n    $$\n    \\text{vanLeer}(u, v) =\n    \\begin{cases}\n    \\frac{2uv}{u+v}  \\text{if } uv  0 \\\\\n    0  \\text{if } uv \\le 0\n    \\end{cases}\n    $$\n4.  **superbee**:\n    $$\n    \\text{superbee}(u, v) =\n    \\begin{cases}\n    \\text{sgn}(u) \\max\\left(\\min(2|u|,|v|), \\min(|u|,2|v|)\\right)  \\text{if } uv  0 \\\\\n    0  \\text{if } uv \\le 0\n    \\end{cases}\n    $$\n\n数值通量 $F_{i+1/2}^n$ 是一个迎风 Godunov 通量，它根据信息流动的方向选择界面状态，该方向由平流速度 $a$ 的符号决定：\n$$\nF_{i+1/2}^n =\n\\begin{cases}\na \\, q_{i+1/2}^{L}  \\text{if } a \\ge 0 \\\\\na \\, q_{i+1/2}^{R}  \\text{if } a  0\n\\end{cases}\n$$\n\n在为所有单元 $i$ 计算更新后的状态 $q_i^1$ 之后，评估以下指标以评定格式的性能：\n-   **最大过冲幅值**: 这衡量了对初始数据全局最小值和最大值的最大违反程度。令 $q_{\\min}^0 = \\min_j q_j^0$ 和 $q_{\\max}^0 = \\max_j q_j^0$。过冲为：\n    $$\n    \\mathrm{overshoot\\_max} = \\max_i \\max\\left(0, q_i^{1} - q_{\\max}^0, q_{\\min}^0 - q_i^{1}\\right)\n    $$\n    值为 $0$ 表示结果无振荡且遵守初始边界。\n-   **总变差增量**: 总变差 $\\mathrm{TV}(q) = \\sum_i \\left|q_{i+1} - q_i\\right|$（使用周期性索引）是衡量数据中总振荡的指标。对于 TVD 格式，总变差不应随时间增加。该指标是单步之后总变差的变化量：\n    $$\n    \\Delta \\mathrm{TV} = \\mathrm{TV}(q^{1}) - \\mathrm{TV}(q^{0})\n    $$\n-   **接触过渡宽度**: 这衡量了接触间断的数值耗散。它定义为值严格位于初始左右平台值 $q_L$ 和 $q_R$ 之间的单元数量：\n    $$\n    \\mathrm{width} = \\#\\{i \\, | \\, \\min(q_L,q_R)  q_i^{1}  \\max(q_L,q_R)\\}\n    $$\n    较小的宽度表示捕捉到的间断更锐利。\n\n算法的流程是：根据给定的分段常数剖面和任何指定的噪声初始化单元平均值 $q_i^0$，计算斜率和界面状态，计算迎风通量，将解推进一个时间步，最后计算所需的指标。对于常数初始数据（$q_L = q_R$）的情况，该格式应能精确保持此状态，导致所有指标均为零。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a MUSCL finite volume scheme for the 1D linear advection equation\n    and computes performance metrics for several test cases.\n    \"\"\"\n    \n    test_cases = [\n        {'N': 100, 'L': 1.0, 'a': 1.0, 'C': 0.8, 'limiter': 'minmod', 'xc': 0.4, 'qL': 1.0, 'qR': 0.1, 'epsilon': 0.0, 'noise_cells': 0},\n        {'N': 100, 'L': 1.0, 'a': 1.0, 'C': 0.95, 'limiter': 'mc', 'xc': 0.4, 'qL': 1.0, 'qR': 0.1, 'epsilon': 0.01, 'noise_cells': 5},\n        {'N': 20, 'L': 1.0, 'a': 1.0, 'C': 0.5, 'limiter': 'vanleer', 'xc': 0.5, 'qL': 2.0, 'qR': 1.5, 'epsilon': 0.0, 'noise_cells': 0},\n        {'N': 80, 'L': 1.0, 'a': -1.0, 'C': 0.9, 'limiter': 'superbee', 'xc': 0.5, 'qL': 1.0, 'qR': 0.0, 'epsilon': 0.005, 'noise_cells': 3},\n        {'N': 50, 'L': 1.0, 'a': 1.0, 'C': 0.7, 'limiter': 'mc', 'xc': 0.3, 'qL': 0.5, 'qR': 0.5, 'epsilon': 0.0, 'noise_cells': 0},\n    ]\n\n    # --- Slope Limiter Functions ---\n    def minmod(a, b):\n        return np.where(a * b > 0, np.sign(a) * np.minimum(np.abs(a), np.abs(b)), 0)\n\n    def mc(a, b):\n        s = (a + b) / 2.0\n        # Use np.sign(s) instead of np.sign(a) to handle s=0 case if a,b are opposite signs\n        return np.where(a * b > 0, np.sign(s) * np.minimum(np.abs(s), np.minimum(2 * np.abs(a), 2 * np.abs(b))), 0)\n\n    def vanleer(a, b):\n        # Handle division by zero when a+b is close to zero\n        # This happens if a = -b or a=b=0. If a*b > 0, then a+b=0 only if a=b=0.\n        denom = a + b\n        # Epsilon can be larger since we're dealing with differences, not just machine precision\n        return np.where( (a * b > 0)  (np.abs(denom) > 1e-12), 2 * a * b / denom, 0)\n        \n    def superbee(a, b):\n        t1 = np.minimum(2 * np.abs(a), np.abs(b))\n        t2 = np.minimum(np.abs(a), 2 * np.abs(b))\n        return np.where(a * b > 0, np.sign(a) * np.maximum(t1, t2), 0)\n\n    limiters = {\n        'minmod': minmod,\n        'mc': mc,\n        'vanleer': vanleer,\n        'superbee': superbee\n    }\n\n    def total_variation(q):\n        \"\"\"Computes the total variation of a periodic array.\"\"\"\n        return np.sum(np.abs(np.roll(q, -1) - q))\n\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        L = case['L']\n        a = case['a']\n        C = case['C']\n        qL = case['qL']\n        qR = case['qR']\n        xc = case['xc']\n        epsilon = case['epsilon']\n        noise_cells = case['noise_cells']\n        limiter_func = limiters[case['limiter']]\n\n        # --- Grid and Time Step Setup ---\n        dx = L / N\n        dt = C * dx / abs(a)\n        \n        # --- Initialization ---\n        i = np.arange(N)\n        x = (i + 0.5) * dx\n        q0 = np.where(x  xc * L, qL, qR)\n\n        if epsilon > 0 and noise_cells > 0:\n            ic = int(np.floor(xc * N))\n            m = noise_cells // 2\n            noise_indices = np.arange(ic - m, ic + m + 1)\n            noise_indices = noise_indices % N  # Handle periodic wrap-around\n            q0[noise_indices] += epsilon * np.sin(2 * np.pi * noise_indices / N)\n\n        # --- Initial Metrics ---\n        q0_min = np.min(q0)\n        q0_max = np.max(q0)\n        tv0 = total_variation(q0)\n        \n        # --- MUSCL Finite Volume Step ---\n        # Get neighboring cell values with periodic boundaries\n        q_im1 = np.roll(q0, 1)\n        q_ip1 = np.roll(q0, -1)\n\n        # Compute differences for slope calculation\n        delta_fwd = q_ip1 - q0  # Corresponds to q_{i+1} - q_i\n        delta_bwd = q0 - q_im1  # Corresponds to q_i - q_{i-1}\n\n        # Compute limited slopes for each cell\n        # The limiter function arguments are (q_i - q_{i-1}, q_{i+1} - q_i)\n        sigma = limiter_func(delta_bwd, delta_fwd)\n\n        # Reconstruct interface states\n        q_L = q0 + 0.5 * sigma\n        q_R = q_ip1 - 0.5 * np.roll(sigma, -1)\n\n        # Compute upwind Godunov flux at interfaces i+1/2\n        if a >= 0:\n            F = a * q_L\n        else:\n            F = a * q_R\n        \n        # Get fluxes at interfaces i-1/2 by rolling\n        F_im1_2 = np.roll(F, 1)\n\n        # Update solution by one time step\n        q1 = q0 - (dt / dx) * (F - F_im1_2)\n\n        # --- Final Metrics Calculation ---\n        # 1. Maximum overshoot\n        overshoot = np.maximum(0, q1 - q0_max)\n        undershoot = np.maximum(0, q0_min - q1)\n        overshoot_max = np.max(np.maximum(overshoot, undershoot))\n\n        # 2. Total variation increase\n        tv1 = total_variation(q1)\n        delta_tv = tv1 - tv0\n\n        # 3. Contact transition width\n        plateau_min = min(qL, qR)\n        plateau_max = max(qL, qR)\n        \n        # Prevent counting plateaus if min == max\n        if plateau_min == plateau_max:\n             width = 0\n        else:\n             width = np.sum((q1 > plateau_min)  (q1  plateau_max))\n\n        results.append([round(overshoot_max, 6), int(width), round(delta_tv, 6)])\n\n    # --- Format final output correctly ---\n    formatted_results = []\n    for r in results:\n        # Use standard float formatting; round() handles cases like 0.0 correctly\n        # f-strings with precision (e.g. .6f) would write 0.0 as 0.000000\n        formatted_results.append(f\"[{r[0]},{r[1]},{r[2]}]\")\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3521267"}, {"introduction": "编写代码只是工作的一半，验证其正确性同等重要。对于包含移动间断的解，标准的误差范数（如对解本身计算$L^1$范数）可能会产生误导。正确的做法是衡量程序是否能收敛到间断的正确物理属性，例如其传播速度、强度和宽度。本练习 [@problem_id:3521202] 介绍了专为激波和接触间断问题设计的网格加密研究的基本方法。通过实现简单的数值格式并追踪激波位置和接触间断宽度的收敛情况，您将学到一种强大且必要的技术，从而对自己的数值结果建立信心。", "problem": "您需要实现并分析包含传播激波和传播接触间断的一维守恒律模型。目标是为间断定义合适的界面感知误差范数，并设计一个网格加密研究，以测量激波位置和接触宽度相对于精确解的收敛性。所有数学实体必须用 LaTeX 书写，所有物理输出在适用时必须以米表示。\n\n基本理论基础是双曲守恒律、Rankine–Hugoniot 跳跃条件和 Courant–Friedrichs–Lewy (CFL) 稳定性条件。使用以下两个模型：\n\n1. 激波模型：无粘 Burgers 守恒律，\n$$\nu_t + \\left(\\frac{1}{2} u^2\\right)_x = 0,\n$$\n在位置 $x_0$ 处具有黎曼初始数据，\n$$\nu(x,0) = \\begin{cases}\nu_L,  x  x_0,\\\\\nu_R,  x > x_0,\n\\end{cases}\n$$\n且 $u_L > u_R$。根据 Rankine–Hugoniot 跳跃条件，精确的激波速度为\n$$\ns = \\frac{f(u_L) - f(u_R)}{u_L - u_R}, \\quad \\text{其中} \\quad f(u) = \\frac{1}{2}u^2,\n$$\n其简化为\n$$\ns = \\frac{u_L + u_R}{2}.\n$$\n精确的激波位置则为\n$$\nx_s(t) = x_0 + s t.\n$$\n\n2. 接触间断模型：被动标量密度的线性平流，\n$$\n\\rho_t + a \\,\\rho_x = 0,\n$$\n在位置 $x_0$ 处具有黎曼初始数据，\n$$\n\\rho(x,0) = \\begin{cases}\n\\rho_L,  x  x_0,\\\\\n\\rho_R,  x > x_0,\n\\end{cases}\n$$\n其中 $a$ 是一个恒定的平流速度。精确的接触间断以速度 $a$ 传播而无扩散，精确的接触宽度在任何时候都保持为零。精确的接触位置是\n$$\nx_c(t) = x_0 + a t \\quad \\text{对于周期性边界，模上域长度}。\n$$\n\n定义适用于间断的误差范数。对于由一个界面（激波或接触）表示的间断，我们如下定义指示函数、阈值和几何误差度量：\n\n- 激波指示函数：令 $H(x; x_*)$ 为以 $x_*$ 为中心的 Heaviside 函数，\n$$\nH(x; x_*) = \\begin{cases}\n1,  x  x_*,\\\\\n0,  x > x_*.\n\\end{cases}\n$$\n对于 $u_L > u_R$ 的 Burgers 激波，精确指示函数为 $\\chi_{\\mathrm{exact}}(x,t) = H(x; x_s(t))$，而数值指示函数为 $\\chi_{\\mathrm{num}}(x,t) = \\mathbf{1}_{\\{u(x,t) > u_m\\}}$，其中中间值阈值为 $u_m = \\frac{u_L + u_R}{2}$。指示函数误差场为 $e_\\chi(x,t) = \\chi_{\\mathrm{num}}(x,t) - \\chi_{\\mathrm{exact}}(x,t)$。$e_\\chi$ 在空间域 $[0,L]$ 上的 $L_1$、$L_2$ 和 $L_\\infty$ 范数为\n$$\n\\|e_\\chi\\|_{1} = \\int_0^L |e_\\chi(x,t)| \\, dx, \\quad\n\\|e_\\chi\\|_{2} = \\left(\\int_0^L |e_\\chi(x,t)|^2 \\, dx\\right)^{1/2}, \\quad\n\\|e_\\chi\\|_{\\infty} = \\sup_{x \\in [0,L]} |e_\\chi(x,t)|.\n$$\n对于完全陡峭的阶跃，$\\|e_\\chi\\|_{1}$ 等于激波错位 $|x_s^{\\mathrm{num}}(t) - x_s(t)|$ 且 $\\|e_\\chi\\|_{2} = \\sqrt{|x_s^{\\mathrm{num}}(t) - x_s(t)|}$，而 $\\|e_\\chi\\|_{\\infty}$ 为 $0$ 或 $1$。在实践中，由于存在数值弥散，$\\|e_\\chi\\|_{1}$ 同时包含错位和弥散的贡献。为了分离出几何激波位置误差，定义标量位置误差\n$$\ne_s(t) = x_s^{\\mathrm{num}}(t) - x_s(t),\n$$\n并使用其标量范数，\n$$\n\\|e_s\\|_{1} = |e_s|, \\quad \\|e_s\\|_{2} = \\sqrt{e_s^2}, \\quad \\|e_s\\|_{\\infty} = |e_s|.\n$$\n\n- 接触宽度指示器：通过跳跃幅度对密度进行归一化，\n$$\n\\eta(x,t) = \\frac{\\rho(x,t) - \\rho_R}{\\rho_L - \\rho_R}.\n$$\n在 $\\eta_{10} = 0.1$ 和 $\\eta_{90} = 0.9$ 水平上定义阈值穿越。令 $x_{10}(t)$ 和 $x_{90}(t)$ 分别为在时间 $t$ 时 $\\eta$ 穿越 $0.1$ 和 $0.9$ 的位置，使用网格点之间的线性插值。数值接触宽度为\n$$\n\\hat{w}(t) = x_{90}(t) - x_{10}(t).\n$$\n精确宽度为 $w(t) = 0$，所以标量宽度误差为\n$$\ne_w(t) = \\hat{w}(t) - w(t) = \\hat{w}(t).\n$$\n为 $e_w$ 定义标量范数\n$$\n\\|e_w\\|_{1} = \\hat{w}, \\quad \\|e_w\\|_{2} = \\sqrt{\\hat{w}^2}, \\quad \\|e_w\\|_{\\infty} = \\hat{w}.\n$$\n\n要使用的数值格式：\n\n- 对于 Burgers 激波，使用基于 Lax–Friedrichs 数值通量的一阶守恒有限体积法，在均匀网格上实现。在界面 $i+\\frac{1}{2}$ 处的 Lax–Friedrichs 通量为\n$$\nF_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(f(u_i) + f(u_{i+1})\\right) - \\frac{1}{2}\\alpha_{i+\\frac{1}{2}}(u_{i+1} - u_i),\n$$\n其中 $f(u) = \\frac{1}{2}u^2$ 且 $\\alpha_{i+\\frac{1}{2}} = \\max\\{|u_i|,|u_{i+1}|\\}$。更新\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\n并通过对虚拟单元进行常数外插来强制执行出流（透射）边界条件。根据 Courant–Friedrichs–Lewy (CFL) 条件选择时间步长，\n$$\n\\Delta t = \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max_i |u_i|},\n$$\n其中 $\\mathrm{CFL} = 0.45$。\n\n- 对于接触间断，在均匀周期性网格上使用适合 $a$ 符号的一阶迎风有限差分格式。如果 $a \\ge 0$，\n$$\n\\rho_i^{n+1} = \\rho_i^n - \\nu\\left(\\rho_i^n - \\rho_{i-1}^n\\right), \\quad \\nu = \\frac{a \\Delta t}{\\Delta x},\n$$\n对 $i-1$ 使用周期性回绕。如果 $a  0$，\n$$\n\\rho_i^{n+1} = \\rho_i^n - \\nu\\left(\\rho_{i+1}^n - \\rho_i^n\\right), \\quad \\nu = \\frac{a \\Delta t}{\\Delta x},\n$$\n对 $i+1$ 使用周期性回绕。根据 Courant–Friedrichs–Lewy (CFL) 条件选择 $\\Delta t$\n$$\n\\Delta t = \\mathrm{CFL} \\cdot \\frac{\\Delta x}{|a|},\n$$\n其中 $\\mathrm{CFL} = 0.9$。\n\n几何检测程序：\n\n- 激波位置检测：在最终时间 $t$，定义中间状态 $u_m = \\frac{u_L + u_R}{2}$，并通过在跨越 $u_m$ 的两个相邻网格点之间进行线性插值，来定位 $u(x,t)$ 中 $u_m$ 水平的唯一穿越点。如果由于数值异常而未找到穿越点，则回退到将界面定位为具有最大梯度幅值 $|u_{i+1} - u_i|$ 的单元面的中点。\n\n- 接触宽度检测：在最终时间 $t$，计算归一化场 $\\eta$。通过线性插值定位 $\\eta$ 穿越 $0.1$ 和 $0.9$ 水平的位置 $x_{10}$ 和 $x_{90}$。使用最接近（在索引空间中）最大梯度位置的一对穿越点，以避免由于周期性引起的伪穿越。宽度则为 $\\hat{w} = x_{90} - x_{10}$。\n\n网格加密研究和要求的输出：\n\n- 域长度为 $L = 1$ 米。初始间断位置对于激波是 $x_0 = 0.5$ 米，对于接触间断是 $x_0 = 0.25$ 米。最终时间和参数如下：\n\n  - 激波情况：$u_L = 2$ 米/秒，$u_R = 0$ 米/秒，最终时间 $t_{\\mathrm{shock}} = 0.2$ 秒。\n  - 接触间断情况：$\\rho_L = 1$ 千克/立方米，$\\rho_R = 0.1$ 千克/立方米，平流速度 $a = 0.5$ 米/秒，最终时间 $t_{\\mathrm{contact}} = 0.4$ 秒。\n\n- 使用单元数 $N \\in \\{100, 200, 400, 800\\}$ 的均匀网格。对于每个 $N$，计算激波位置误差的 $L_1$ 范数 $\\|e_s\\|_1$（单位为米）和接触宽度误差的 $L_1$ 范数 $\\|e_w\\|_1$（单位为米）。然后通过连续加密的成对比率计算每个量的经验收敛率，\n$$\nR = \\frac{1}{M}\\sum_{j=1}^{M} \\frac{\\log\\left(E_{N_j} / E_{N_{j+1}}\\right)}{\\log\\left(\\Delta x_{N_j} / \\Delta x_{N_{j+1}}\\right)} = \\frac{1}{M}\\sum_{j=1}^{M} \\frac{\\log\\left(E_{N_j} / E_{N_{j+1}}\\right)}{\\log(2)},\n$$\n其中 $E_{N}$ 是分辨率为 $N$ 时的误差，$\\Delta x_N = L/N$，对于序列 $\\{100,200,400,800\\}$，$M = 3$。\n\n- 物理单位：所有位置和宽度必须以米表示。报告所有误差和收敛率时，除了所有误差值表示以米为单位的长度外，都应为无单位浮点数。\n\n- 测试套件：对上述两种情景使用网格尺寸 $N \\in \\{100, 200, 400, 800\\}$。\n\n- 最终输出格式：您的程序应生成单行输出，其中包含结果，格式为方括号内以逗号分隔的列表，顺序完全如下\n$$\n[\\|e_s\\|_1(N{=}100), \\|e_s\\|_1(N{=}200), \\|e_s\\|_1(N{=}400), \\|e_s\\|_1(N{=}800), R_{\\mathrm{shock}}, \\|e_w\\|_1(N{=}100), \\|e_w\\|_1(N{=}200), \\|e_w\\|_1(N{=}400), \\|e_w\\|_1(N{=}800), R_{\\mathrm{contact}}],\n$$\n其中每个 $\\|e_s\\|_1$ 和 $\\|e_w\\|_1$ 以米为单位，每个收敛率 $R$ 无单位。列表必须严格按照规定打印，不含任何额外文本。", "solution": "该问题要求对两个基本的一维双曲守恒律进行数值解的实现与分析：用于模拟激波形成的无粘 Burgers 方程，以及用于模拟接触间断传播的线性平流方程。分析涉及一项网格加密研究，以测量适用于间断解的特定误差度量的收敛性。\n\n解决方案结构如下：首先，我们使用一阶有限体积法和 Lax-Friedrichs 通量为 Burgers 方程开发数值求解器。其次，我们使用一阶迎风格式为线性平流方程开发求解器。对于这两种情况，我们都实现了用于检测特征（激波位置或接触宽度）并计算与精确解之间误差的指定程序。最后，我们对两个模型进行网格加密研究，计算网格尺寸为 $N \\in \\{100, 200, 400, 800\\}$ 时的误差，并计算经验收敛率。\n\n### 1. 激波模型：无粘 Burgers 方程\n\n**控制方程与精确解**\n无粘 Burgers 方程由下式给出\n$$u_t + \\left(\\frac{1}{2} u^2\\right)_x = 0.$$\n对于黎曼初始数据 $u(x,0) = u_L$（当 $x  x_0$）和 $u(x,0) = u_R$（当 $x > x_0$），其中 $u_L > u_R$，会形成一个激波并以由 Rankine-Hugoniot 条件决定的恒定速度 $s$ 传播：\n$$s = \\frac{f(u_L) - f(u_R)}{u_L - u_R} = \\frac{\\frac{1}{2}u_L^2 - \\frac{1}{2}u_R^2}{u_L - u_R} = \\frac{u_L + u_R}{2}.$$\n在时间 $t$ 的精确激波位置为 $x_s(t) = x_0 + st$。\n\n**数值实现**\n我们在单元尺寸为 $\\Delta x = L/N$ 的均匀网格上实现一个守恒有限体积格式。状态变量 $u_i^n$ 表示在时间 $t^n$ 时单元 $i$ 中解的单元平均值。更新公式为\n$$u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),$$\n其中 $F_{i+\\frac{1}{2}}$ 是单元 $i$ 和单元 $i+1$ 之间界面的数值通量。我们使用 Lax-Friedrichs 通量：\n$$F_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(f(u_i) + f(u_{i+1})\\right) - \\frac{1}{2}\\alpha_{i+\\frac{1}{2}}(u_{i+1} - u_i),$$\n其中通量函数为 $f(u) = \\frac{1}{2}u^2$，局部耗散系数为 $\\alpha_{i+\\frac{1}{2}} = \\max\\{|u_i|, |u_{i+1}|\\}$。该格式为一阶精度。时间步长 $\\Delta t$ 由 CFL 条件控制，常数 $\\mathrm{CFL}=0.45$：\n$$\\Delta t = \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max_i |u_i^n|}.$$\n出流边界条件通过将域两端的单个虚拟单元中的值设置为其相邻内部单元中心的值（零梯度外插）来处理。\n\n**误差分析：激波位置**\n主要的误差度量是激波位置误差，$e_s(t) = x_s^{\\mathrm{num}}(t) - x_s(t)$。为找到数值激波位置 $x_s^{\\mathrm{num}}(t)$，我们定位数值解 $u(x,t)$ 穿过中间状态值 $u_m = (u_L+u_R)/2$ 的位置。这通过找到跨越 $u_m$ 的两个相邻网格单元 $(i, i+1)$ 并使用线性插值来找到子网格穿越点来实现。为保证鲁棒性，实现了一个基于定位最大梯度单元界面的备用程序，尽管单调的 Lax-Friedrichs 格式预计不会触发它。这个标量误差的 $L_1$ 范数就是它的绝对值，$\\|e_s\\|_1 = |e_s(t)|$。\n\n### 2. 接触间断模型：线性平流\n\n**控制方程与精确解**\n被动标量密度 $\\rho$ 的线性平流由下式控制\n$$\\rho_t + a \\,\\rho_x = 0,$$\n其中 $a$ 是一个恒定速度。对于黎曼初始数据，间断仅以速度 $a$ 平移，形状不发生改变。接触间断的精确宽度保持为零。对于长度为 $L$ 的周期域，其位置为 $x_c(t) = (x_0 + at) \\pmod{L}$。\n\n**数值实现**\n在均匀的周期性网格上使用一阶迎风有限差分格式。对于给定的参数 $a=0.5 \\text{ m/s} > 0$，更新公式为\n$$\\rho_i^{n+1} = \\rho_i^n - \\nu\\left(\\rho_i^n - \\rho_{i-1}^n\\right),$$\n其中 $\\nu = a\\Delta t / \\Delta x$ 是库朗数。通过对 $\\rho_{i-1}$ 项使用循环移位来强制周期性。时间步长由 CFL 条件确定，其中 $\\mathrm{CFL}=0.9$：\n$$\\Delta t = \\mathrm{CFL} \\cdot \\frac{\\Delta x}{|a|}.$$\n\n**误差分析：接触宽度**\n一阶格式会引入数值扩散，这会人为地加宽接触间断。这种加宽是需要测量的主要误差。数值接触宽度 $\\hat{w}(t)$ 从归一化密度 $\\eta(x,t) = (\\rho(x,t) - \\rho_R)/(\\rho_L - \\rho_R)$ 的剖面计算得出。我们识别 $\\eta$ 穿过阈值 $0.1$ 和 $0.9$ 的位置 $x_{10}(t)$ 和 $x_{90}(t)$。这些位置使用线性插值找到，搜索范围局限在 $\\eta$ 的最大梯度点周围，以确保识别到正确的过渡区。数值宽度随后计算为 $\\hat{w}(t) = |x_{10}(t) - x_{90}(t)|$。由于精确宽度 $w(t)$ 为零，宽度误差为 $e_w(t) = \\hat{w}(t)$，其 $L_1$ 范数为 $\\|e_w\\|_1 = \\hat{w}(t)$。\n\n### 3. 网格加密研究与收敛率\n\n对两种模型使用四个网格分辨率序列 $N = 100, 200, 400, 800$ 进行收敛性研究。对于每个分辨率，记录相应的误差，即激波的 $\\|e_s\\|_1$ 或接触间断的 $\\|e_w\\|_1$。然后，经验收敛率 $R$ 作为从连续加密中确定的成对率的平均值来计算：\n$$R = \\frac{1}{3} \\sum_{j=1}^{3} \\frac{\\log\\left(E_{N_j} / E_{N_{j+1}}\\right)}{\\log(2)},$$\n其中 $E_{N_j}$ 是序列 $\\{100, 200, 400, 800\\}$ 中分辨率为 $N_j$ 的误差。对于一阶格式，激波位置误差预计以 $R \\approx 1$ 的速率收敛，而由与 $\\Delta x$ 成正比的数值扩散主导的接触宽度，也预计以 $R \\approx 1$ 的速率收敛。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_shock_sim(N):\n    \"\"\"\n    Solves the 1D inviscid Burgers' equation for a shock tube problem\n    using a first-order Lax-Friedrichs finite-volume scheme.\n    \"\"\"\n    # Parameters from problem statement\n    L = 1.0  # meters\n    x0 = 0.5  # meters\n    u_L = 2.0  # m/s\n    u_R = 0.0  # m/s\n    t_final = 0.2  # seconds\n    CFL_val = 0.45\n\n    # Grid setup\n    dx = L / N\n    # Array with one ghost cell on each side\n    u = np.zeros(N + 2)\n    # Cell centers for the physical domain\n    domain_x = np.linspace(0.5 * dx, L - 0.5 * dx, N)\n\n    # Initial condition\n    u[1:-1] = np.where(domain_x  x0, u_L, u_R)\n    \n    t = 0.0\n    while t  t_final:\n        # Boundary conditions: outflow (zero-gradient)\n        u[0] = u[1]\n        u[-1] = u[-2]\n\n        # Time step from CFL condition\n        max_speed = np.max(np.abs(u))\n        if max_speed  1e-9: # Avoid division by zero\n            dt = t_final - t\n        else:\n            dt = CFL_val * dx / max_speed\n        \n        dt = min(dt, t_final - t)\n\n        # Lax-Friedrichs flux calculation\n        f_u = 0.5 * u**2\n        u_left = u[:-1]\n        u_right = u[1:]\n        \n        alpha = np.maximum(np.abs(u_left), np.abs(u_right))\n        flux = 0.5 * (f_u[:-1] + f_u[1:]) - 0.5 * alpha * (u_right - u_left)\n        \n        # Update solution in the physical domain\n        u[1:-1] -= (dt / dx) * (flux[1:] - flux[:-1])\n        \n        t += dt\n\n    # Post-processing to find error\n    s = (u_L + u_R) / 2.0\n    x_s_exact = x0 + s * t_final\n    \n    u_m = (u_L + u_R) / 2.0\n    u_domain = u[1:-1]\n    \n    x_s_num = None\n    # Find shock position via linear interpolation\n    for i in range(N - 1):\n        if u_domain[i] > u_m and u_domain[i+1] = u_m:\n            y1, y2 = u_domain[i], u_domain[i+1]\n            x1 = domain_x[i]\n            # (x2-x1) is dx\n            x_s_num = x1 + dx * (u_m - y1) / (y2 - y1)\n            break\n            \n    # Fallback if no crossing is found\n    if x_s_num is None:\n        grad_u = np.abs(u_domain[1:] - u_domain[:-1])\n        max_grad_idx = np.argmax(grad_u)\n        # Midpoint of the cell face with maximal gradient\n        x_s_num = domain_x[max_grad_idx] + 0.5 * dx\n\n    return np.abs(x_s_num - x_s_exact)\n\n\ndef run_contact_sim(N):\n    \"\"\"\n    Solves the 1D linear advection equation for a contact discontinuity\n    using a first-order upwind finite-difference scheme.\n    \"\"\"\n    # Parameters from problem statement\n    L = 1.0  # meters\n    x0 = 0.25  # meters\n    rho_L = 1.0  # kg/m^3\n    rho_R = 0.1  # kg/m^3\n    a = 0.5  # m/s\n    t_final = 0.4  # seconds\n    CFL_val = 0.9\n\n    # Grid setup\n    dx = L / N\n    x = np.linspace(0.5 * dx, L - 0.5 * dx, N)\n    rho = np.where(x  x0, rho_L, rho_R)\n    \n    t = 0.0\n    # Fixed timestep and Courant number for linear advection\n    dt_cfl = CFL_val * dx / np.abs(a)\n\n    while t  t_final:\n        dt = min(dt_cfl, t_final - t)\n        nu = a * dt / dx\n        \n        # Update with first-order upwind scheme (a > 0)\n        # Periodic BCs handled by np.roll\n        rho_prev = np.roll(rho, 1)\n        rho = rho - nu * (rho - rho_prev)\n        \n        t += dt\n\n    # Post-processing to find contact width\n    eta = (rho - rho_R) / (rho_L - rho_R)\n    \n    def find_crossing_pos(vals, x_coords, threshold):\n        # Locate the region of steepest descent first\n        grad_eta = np.abs(np.roll(vals, -1) - vals)\n        max_grad_idx = np.argmax(grad_eta)\n        \n        # Search for crossing around the steepest gradient\n        # Search window of +/- N/4 should be sufficient\n        search_range = np.arange(max_grad_idx - N // 4, max_grad_idx + N // 4)\n        search_range = search_range % N # periodic wrap\n\n        for i in search_range:\n            i_p1 = (i + 1) % N\n            y1, y2 = vals[i], vals[i_p1]\n            # Condition for crossing a threshold in a decreasing profile\n            if (y1 >= threshold and y2  threshold):\n                x1 = x_coords[i]\n                return x1 + dx * (threshold - y1) / (y2 - y1)\n        return None\n\n    x_90 = find_crossing_pos(eta, x, 0.9)\n    x_10 = find_crossing_pos(eta, x, 0.1)\n\n    if x_90 is None or x_10 is None:\n        return np.nan # Should not happen in this problem\n\n    # Since profile is decreasing, x_10 should be > x_90\n    width = x_10 - x_90\n    if width  0: # Handle periodic wrap-around case\n        width += L\n    \n    return width\n\n\ndef calculate_rate(errors):\n    \"\"\"Calculates the average convergence rate.\"\"\"\n    rates = []\n    for i in range(len(errors) - 1):\n        # Avoid log(0) or division by zero\n        if errors[i] = 0 or errors[i+1] = 0:\n            continue\n        ratio_err = errors[i] / errors[i+1]\n        rate = np.log2(ratio_err) # Equivalent to log(ratio)/log(2)\n        rates.append(rate)\n    return np.mean(rates) if rates else np.nan\n\n\ndef solve():\n    \"\"\"\n    Main driver function to run simulations, calculate errors and rates,\n    and print the final result in the specified format.\n    \"\"\"\n    N_vals = [100, 200, 400, 800]\n    \n    shock_errors = [run_shock_sim(N) for N in N_vals]\n    R_shock = calculate_rate(shock_errors)\n\n    contact_errors = [run_contact_sim(N) for N in N_vals]\n    R_contact = calculate_rate(contact_errors)\n    \n    results = shock_errors + [R_shock] + contact_errors + [R_contact]\n    \n    # Format and print the final output line\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n\n```", "id": "3521202"}, {"introduction": "为了严格测试一个数值格式的形式精度，特别是像限制器这类组件所带来的影响，我们需要一个已知的精确解作为基准。人造解方法（Method of Manufactured Solutions, MMS）为此提供了一个强大的框架。该方法通过设计一个解析解，并将其代入控制方程以获得一个相应的源项来工作；对于线性平流问题，这个过程可以简化为平移一个已知的初始剖面。在本练习 [@problem_id:3521220] 中，您将使用一个人造解，其特点是包含一个光滑的阶跃，来精确测量MUSCL格式的收敛阶。通过在阶跃变得越来越陡峭时比较有无限制器情况下的性能，您将直接量化振荡控制与形式精度之间的权衡，这是高级代码开发中一项至关重要的分析技能。", "problem": "考虑一个周期性域上的一维线性平流守恒律，\n$$\n\\frac{\\partial u}{\\partial t} + a\\,\\frac{\\partial u}{\\partial x} = 0,\n$$\n对于标量场 $u(x,t)$，其中平流速度 $a0$ 为常数，且 $x\\in[0,1]$ 采用周期性边界条件。目标是构造一个带光滑间断的制造解，实现一个带斜率限制器和不带斜率限制器的激波捕捉有限体积格式，并使用此制造解来验证其形式精度阶数，同时分离出由限制器引起的误差。\n\n从守恒律在单元平均上的积分形式和线性平流方程的迎风数值通量的定义出发。在空间上使用守恒律单调上游中心格式 (Monotone Upstream-centered Schemes for Conservation Laws, MUSCL) 重构以达到二阶精度，在时间上使用二阶强保稳 (Strong Stability Preserving) Runge-Kutta (SSP-RK2) 方法。实现该格式的两种变体：\n- 使用 minmod 斜率限制器的受限变体，\n- 使用中心斜率且不受限的无限制变体。\n\n通过选择一个结合了光滑背景和光滑间断的初始剖面 $g(x)$ 来定义制造解，\n$$\ng(x) = \\sin(2\\pi x) + s\\,\\tanh\\!\\left(\\frac{x-x_0}{\\delta}\\right),\n$$\n其中 $s$ 是一个固定振幅，$x_0$ 设置光滑间断的中心，$\\delta0$ 控制光滑宽度。在周期性边界条件下，时间 $t$ 的精确解由平流后的剖面给出\n$$\nu_{\\text{exact}}(x,t) = g\\big((x - a t) \\bmod 1\\big).\n$$\n使用制造解计算数值解在固定最终时间 $T$ 的误差，并在连续的网格加密下估计观测到的精度阶数。\n\n在一个包含 $N$ 个单元的均匀网格上实现一维有限体积法，单元宽度为 $\\Delta x = 1/N$，单元中心位于 $x_i = (i+1/2)\\Delta x$，其中整数 $i \\in \\{0,1,\\dots,N-1\\}$。对所有的重构和通量计算使用周期性边界条件。对于 $a0$ 的情况，迎风数值通量使用界面处的左状态。对于 MUSCL 重构，使用单元中心值和重构的斜率计算左右界面状态。对于受限变体，在每个单元中使用应用于单边差分的 minmod 限制器；对于无限制变体，使用无限制的中心斜率。使用 SSP-RK2 格式将解在时间上推进到 $T$，其中 Courant–Friedrichs–Lewy (CFL) 数设为 $C$，时间步长 $\\Delta t$ 的选择满足 $\\Delta t \\le C\\,\\Delta x/a$。对所有模板操作使用周期性索引。\n\n计算时间 $T$ 时的 $L^1$ 误差，\n$$\nE_{L^1} = \\sum_{i=0}^{N-1} \\left| u_i(T) - u_{\\text{exact}}(x_i,T) \\right| \\,\\Delta x,\n$$\n其中 $u_i(T)$ 是单元 $i$ 在时间 $T$ 的数值近似解，$u_{\\text{exact}}(x_i,T)$ 是在单元中心 $x_i$ 处计算的精确解。对于每个加密对 $(N,2N)$，将观测阶数 $p$ 定义为\n$$\np = \\frac{\\log\\left( E_{L^1}(N) / E_{L^1}(2N) \\right)}{\\log(2)}.\n$$\n\n您必须实现程序以完成以下任务：\n- 为受限和无限制的 MUSCL 变体构造数值解并将其演化至时间 $T$，\n- 计算相对于精确制造解的 $L^1$ 误差，\n- 使用最后一对加密网格为每个变体估计观测阶数 $p$，\n- 通过报告最细网格上受限与无限制 $L^1$ 误差的比率来量化限制器引起的误差。\n\n使用以下固定参数：\n- 平流速度 $a = 1$，\n- 最终时间 $T = 0.5$,\n- 限制振幅 $s = 0.8$，\n- 间断中心 $x_0 = 0.25$，\n- Courant–Friedrichs–Lewy (CFL) 数 $C = 0.45$，\n- 网格分辨率 $N \\in \\{50, 100, 200, 400\\}$，\n- 光滑宽度 $\\delta \\in \\{0.1, 0.02, 0.005\\}$。\n\n对于每个选定的 $\\delta$，计算：\n- 使用网格对 $(N,2N) = (200,400)$ 计算受限格式的观测阶数 $p_{\\text{lim}}$，\n- 使用相同网格对计算无限制格式的观测阶数 $p_{\\text{unlim}}$，\n- 误差比率 $R = E_{L^1,\\text{lim}}(400) / E_{L^1,\\text{unlim}}(400)$。\n\n测试套件和答案规范：\n- 测试套件包含三个 $\\delta$ 值：$\\delta_1 = 0.1$, $\\delta_2 = 0.02$ 和 $\\delta_3 = 0.005$，每个值都与四种网格尺寸 $N = 50$、$N = 100$、$N = 200$ 和 $N = 400$ 结合。\n- 对于每个 $\\delta$，按顺序报告三个浮点数 $p_{\\text{lim}}$、$p_{\\text{unlim}}$ 和 $R$。\n- 将所有结果按 $\\delta_1$、$\\delta_2$、$\\delta_3$ 的顺序汇总到一个列表中。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，即\n$$\n[ p_{\\text{lim}}(\\delta_1), p_{\\text{unlim}}(\\delta_1), R(\\delta_1), p_{\\text{lim}}(\\delta_2), p_{\\text{unlim}}(\\delta_2), R(\\delta_2), p_{\\text{lim}}(\\delta_3), p_{\\text{unlim}}(\\delta_3), R(\\delta_3) ].\n$$\n所有输出都必须是无单位的浮点数。", "solution": "所提出的问题是计算物理学中的一个有效练习，特别是在双曲守恒律的数值解法方面。它要求使用制造解方法实现并验证用于一维线性平流方程的有限体积格式。该问题的所有组成部分在科学上都是合理的、定义明确的，并且与偏微分方程数值方法领域的标准实践相一致。\n\n问题的核心在于求解线性平流方程，\n$$\n\\frac{\\partial u}{\\partial t} + a\\,\\frac{\\partial u}{\\partial x} = 0\n$$\n在周期性域 $x \\in [0,1]$ 上，平流速度 $a  0$ 为常数。我们将采用有限体积法，该方法从守恒律在宽度为 $\\Delta x = x_{i+1/2} - x_{i-1/2}$ 的计算单元 $C_i = [x_{i-1/2}, x_{i+1/2}]$ 上的积分形式开始。将该方程在 $C_i$ 上积分可得：\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial u}{\\partial t} dx + \\int_{x_{i-1/2}}^{x_{i+1/2}} a\\,\\frac{\\partial u}{\\partial x} dx = 0\n$$\n定义单元平均值 $\\bar{u}_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$ 和通量 $F(u) = au$，我们得到单元平均值的精确演化方程：\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x} \\left( F(u(x_{i+1/2}, t)) - F(u(x_{i-1/2}, t)) \\right)\n$$\n在数值格式中，单元界面处的精确点态通量被一个数值通量函数 $F^*$ 所取代，该函数依赖于界面处解的重构状态。这就得到了半离散有限体积格式：\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x} \\left( F^*_{i+1/2} - F^*_{i-1/2} \\right) \\equiv \\mathcal{L}(\\bar{\\mathbf{u}})_i\n$$\n其中 $\\bar{\\mathbf{u}}$ 是所有单元平均值的向量。由于平流速度 $a$ 为正，信息从左向右传播。因此，迎风格式使用从界面左侧重构的状态来计算通量。界面 $x_{i+1/2}$ 处的数值通量为 $F^*_{i+1/2} = a u^L_{i+1/2}$，其中 $u^L_{i+1/2}$ 是在界面 $x_{i+1/2}$ 左侧重构的解值。\n\n为了在空间上达到二阶精度，我们使用守恒律单调上游中心格式 (Monotone Upstream-centered Schemes for Conservation Laws, MUSCL) 方法。这涉及到在每个单元 $i$ 内对解进行分段线性重构：\n$$\nu(x) = \\bar{u}_i + \\sigma_i (x - x_i) \\quad \\text{for } x \\in C_i\n$$\n其中 $x_i$ 是单元中心，$\\sigma_i$ 是单元 $i$ 中重构的斜率。界面 $x_{i+1/2}$ 左侧的值由单元 $i$ 中的重构确定：\n$$\nu^L_{i+1/2} = \\bar{u}_i + \\sigma_i (x_{i+1/2} - x_i) = \\bar{u}_i + \\sigma_i \\frac{\\Delta x}{2}\n$$\n此界面处的数值通量为 $F^*_{i+1/2} = a( \\bar{u}_i + \\sigma_i \\frac{\\Delta x}{2} )$。前一个界面 $x_{i-1/2}$ 处的通量取决于单元 $i-1$ 中的重构：$F^*_{i-1/2} = a( \\bar{u}_{i-1} + \\sigma_{i-1} \\frac{\\Delta x}{2} )$。单元 $i$ 的半离散更新公式则为：\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{a}{\\Delta x} \\left[ \\left(\\bar{u}_i + \\sigma_i \\frac{\\Delta x}{2}\\right) - \\left(\\bar{u}_{i-1} + \\sigma_{i-1} \\frac{\\Delta x}{2}\\right) \\right]\n$$\n格式由斜率 $\\sigma_i$ 的选择来定义。我们实现两种变体：\n1.  **无限制格式**：对于光滑解，使用二阶精度的中心差分斜率：\n    $$\n    \\sigma_i^{\\text{unlim}} = \\frac{\\bar{u}_{i+1} - \\bar{u}_{i-1}}{2\\Delta x}\n    $$\n    该格式不保证单调性，并且可能在陡峭梯度附近产生伪振荡。\n2.  **受限格式**：为防止振荡，应用了斜率限制器。`minmod` 限制器是一个常见的选择。它比较后向和前向差分斜率，如果符号相同，则选择绝对值较小者，否则返回零。\n    $$\n    \\sigma_i^{\\text{lim}} = \\text{minmod}\\left( \\frac{\\bar{u}_i - \\bar{u}_{i-1}}{\\Delta x}, \\frac{\\bar{u}_{i+1} - \\bar{u}_i}{\\Delta x} \\right)\n    $$\n    其中 $\\text{minmod}(a, b) = \\frac{1}{2}(\\text{sgn}(a) + \\text{sgn}(b)) \\min(|a|, |b|)$。这确保了格式在特定条件下是全变差递减 (Total Variation Diminishing, TVD) 的，但在极值点和陡峭梯度附近会将局部精度降低到一阶。\n\n对于时间积分，采用二阶强保稳 (Strong Stability-Preserving) Runge-Kutta (SSP-RK2) 方法。给定半离散算子 $\\mathcal{L}(\\bar{\\mathbf{u}})$，解从时间 $t^n$ 推进到 $t^{n+1}=t^n+\\Delta t$ 分为两个阶段：\n$$\n\\bar{\\mathbf{u}}^{(1)} = \\bar{\\mathbf{u}}^n + \\Delta t \\mathcal{L}(\\bar{\\mathbf{u}}^n)\n$$\n$$\n\\bar{\\mathbf{u}}^{n+1} = \\frac{1}{2}\\bar{\\mathbf{u}}^n + \\frac{1}{2}\\left(\\bar{\\mathbf{u}}^{(1)} + \\Delta t \\mathcal{L}(\\bar{\\mathbf{u}}^{(1)})\\right)\n$$\n时间步长 $\\Delta t$ 必须满足 Courant–Friedrichs–Lewy (CFL) 条件，即 $\\Delta t \\le C \\frac{\\Delta x}{a}$，其中给定的 CFL 数 $C=0.45$。\n\n验证基于制造解。初始剖面为 $g(x) = \\sin(2\\pi x) + s\\,\\tanh((x-x_0)/\\delta)$。带有周期性边界条件的平流方程的精确解是该剖面的平移：$u_{\\text{exact}}(x,t) = g((x - a t) \\bmod 1)$。我们计算数值解 $\\bar{u}_i$ 在最终时间 $T$ 的 $L^1$ 误差：\n$$\nE_{L^1} = \\sum_{i=0}^{N-1} \\left| \\bar{u}_i(T) - u_{\\text{exact}}(x_i,T) \\right| \\,\\Delta x\n$$\n观测精度阶数 $p$ 是根据在具有 $N$ 和 $2N$ 个单元的两个连续加密网格上的误差估计的：$p = \\log_2(E_{L^1}(N) / E_{L^1}(2N))$。\n通过改变光滑参数 $\\delta$，我们可以研究该格式在从非常光滑 ($\\delta=0.1$) 到具有陡峭梯度 ($\\delta=0.005$) 的问题上的行为。分析包括比较收敛阶数 ($p_{\\text{lim}}$、$p_{\\text{unlim}}$) 和最终误差比率 $R = E_{L^1,\\text{lim}} / E_{L^1,\\text{unlim}}$，以量化斜率限制器的影响。对于光滑解（大 $\\delta$），两种格式都应接近二阶收敛 ($p \\approx 2$)。对于尖锐特征（小 $\\delta$），受限格式中的限制器将被激活，将收敛率降低至接近一阶 ($p_{\\text{lim}} \\approx 1$)，而无限制格式尽管存在振荡，仍可能在 $L^1$ 范数下保持更高的形式精度阶数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the one-dimensional linear advection problem\n    using a finite-volume method with MUSCL reconstruction, comparing limited\n    (minmod) and unlimited (centered slope) schemes.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    A = 1.0  # advection speed\n    T_FINAL = 0.5  # final time\n    S = 0.8  # amplitude of the smoothed discontinuity\n    X0 = 0.25  # center of the smoothed discontinuity\n    CFL = 0.45  # Courant-Friedrichs-Lewy number\n    N_VALS = [50, 100, 200, 400]  # grid resolutions\n    DELTA_VALS = [0.1, 0.02, 0.005]  # smoothing widths for tanh\n\n    def initial_condition(x, s_param, x0_param, delta_param):\n        \"\"\"Defines the initial profile g(x).\"\"\"\n        return np.sin(2 * np.pi * x) + s_param * np.tanh((x - x0_param) / delta_param)\n\n    def exact_solution(x, t, a_param, s_param, x0_param, delta_param):\n        \"\"\"Provides the exact solution by advecting the initial profile.\"\"\"\n        # np.mod handles the periodic boundary condition correctly.\n        return initial_condition(np.mod(x - a_param * t, 1.0), s_param, x0_param, delta_param)\n\n    def rhs(u, dx, a_param, limiter_type):\n        \"\"\"\n        Computes the right-hand side of the semi-discrete finite-volume scheme,\n        which represents the spatial operator L(u).\n        \"\"\"\n        # Get neighboring cell values using periodic boundaries via np.roll\n        u_im1 = np.roll(u, 1)\n        u_ip1 = np.roll(u, -1)\n\n        if limiter_type == 'unlimited':\n            # Unlimited scheme: second-order centered difference slope\n            sigma = (u_ip1 - u_im1) / (2.0 * dx)\n        elif limiter_type == 'limited':\n            # Limited scheme: minmod limiter on one-sided slopes\n            # Epsilon to avoid issues with np.sign(0)\n            epsilon = 1e-12 \n            sigma_fwd = (u_ip1 - u) / dx\n            sigma_bwd = (u - u_im1) / dx\n            \n            # Vectorized minmod implementation\n            # It returns the argument with smaller magnitude if signs match, else 0.\n            signs_match = (np.sign(sigma_fwd + epsilon) * np.sign(sigma_bwd + epsilon)) > 0\n            sigma = np.where(signs_match,\n                             np.sign(sigma_fwd) * np.minimum(np.abs(sigma_fwd), np.abs(sigma_bwd)),\n                             0.0)\n        else:\n            raise ValueError(\"Unknown limiter_type.\")\n\n        # Reconstruct values at the left of the i+1/2 interface\n        # This is for flux F*_{i+1/2} which depends on cell i\n        term = u + sigma * dx / 2.0\n        \n        # Flux at the i-1/2 interface depends on cell i-1\n        term_im1 = np.roll(term, 1)\n        \n        # Semi-discrete form: d(u_i)/dt = -1/dx * (F*_{i+1/2} - F*_{i-1/2})\n        # F*_{i+1/2} = a * (u_i + sigma_i * dx/2)\n        # F*_{i-1/2} = a * (u_{i-1} + sigma_{i-1} * dx/2)\n        dudt = -a_param / dx * (term - term_im1)\n        return dudt\n\n    def run_simulation(N, delta, limiter_type):\n        \"\"\"\n        Runs a single simulation for a given grid size, delta, and limiter type.\n        Returns the L1 error at the final time.\n        \"\"\"\n        # Grid setup\n        dx = 1.0 / N\n        x = (np.arange(N) + 0.5) * dx\n\n        # Time step setup\n        dt_cfl = CFL * dx / A\n        # To land exactly on T_FINAL, adjust dt slightly\n        num_steps = int(np.ceil(T_FINAL / dt_cfl))\n        dt = T_FINAL / num_steps\n\n        # Set initial condition from point values at cell centers\n        u = initial_condition(x, S, X0, delta)\n\n        # Time-marching loop using SSP-RK2\n        for _ in range(num_steps):\n            # Stage 1\n            L_u = rhs(u, dx, A, limiter_type)\n            u1 = u + dt * L_u\n            \n            # Stage 2\n            L_u1 = rhs(u1, dx, A, limiter_type)\n            u = 0.5 * u + 0.5 * (u1 + dt * L_u1)\n\n        # Compute L1 error at the final time\n        u_ex = exact_solution(x, T_FINAL, A, S, X0, delta)\n        l1_error = np.sum(np.abs(u - u_ex)) * dx\n        return l1_error\n\n    # List to store the final results\n    all_results = []\n    \n    # Main loop over the test suite\n    for delta in DELTA_VALS:\n        errors_lim = []\n        errors_unlim = []\n        \n        # Run simulations for all grid resolutions\n        for n in N_VALS:\n            errors_lim.append(run_simulation(n, delta, 'limited'))\n            errors_unlim.append(run_simulation(n, delta, 'unlimited'))\n        \n        # Compute observed order of accuracy p using the last refinement pair (N=200, 2N=400)\n        # N=200 corresponds to index -2, N=400 to index -1\n        p_lim = np.log2(errors_lim[-2] / errors_lim[-1])\n        p_unlim = np.log2(errors_unlim[-2] / errors_unlim[-1])\n        \n        # Compute the error ratio R at the finest grid resolution (N=400)\n        R = errors_lim[-1] / errors_unlim[-1]\n        \n        all_results.extend([p_lim, p_unlim, R])\n        \n    # Print the final aggregated results in the specified format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3521220"}]}