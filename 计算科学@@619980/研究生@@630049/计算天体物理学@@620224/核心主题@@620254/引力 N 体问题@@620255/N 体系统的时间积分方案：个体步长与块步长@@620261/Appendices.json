{"hands_on_practices": [{"introduction": "不同的时间步长标准旨在捕捉系统动力学的不同方面。本练习要求您在动力学要求最高的偏心双星轨道案例中，推导并比较两个关键标准——对力的平滑度敏感的Aarseth标准，以及对局部动力学时间敏感的自由落体时间。通过这个实践[@problem_id:3541177]，您将从第一性原理出发，深化对这些数学规则背后物理直觉的理解。", "problem": "考虑一个牛顿双体系统（一个双星系统），其分质量为 $m_1$ 和 $m_2$，总质量为 $M = m_1 + m_2$，引力参数为 $\\mu = G M$，其中 $G$ 是引力常数。相对运动是开普勒运动，半长轴为 $a$，离心率为 $e$。假设由相对坐标描述的粒子位于近心点。假设运动在一个具有独立时间步长和块步进的直接 $N$ 体方案中进行积分。\n\n从第一性原理出发，利用牛顿引力定律和开普勒轨道的运动学，推导相对坐标的近心点加速度大小 $|\\mathbf{a}|$、近心点速率 $v_{\\mathrm{p}}$ 和近心点加加加速度大小 $|\\mathbf{j}| = |\\mathrm{d}\\mathbf{a}/\\mathrm{d}t|$。然后，使用：\n- Aarseth 独立时间步长准则，该准则通过一个无量纲参数 $\\eta$ 来控制加速度在一个步长内的分数变化，即 $h_{\\mathrm{A}} = \\eta\\,\\frac{|\\mathbf{a}|}{|\\mathbf{j}|}$，\n- 自由落体（局域动力学时间）估计 $h_{\\mathrm{ff}} = \\eta\\,\\sqrt{\\frac{r_{\\mathrm{p}}}{|\\mathbf{a}|}}$，\n\n推导在近心点处 $h_{\\mathrm{A}}$ 和 $h_{\\mathrm{ff}}$ 的解析表达式，用 $a$、$e$ 和 $\\mu$ 表示，其中 $r_{\\mathrm{p}}$ 是近心点距离。对于块步进，假定轨道上的最小块步长由 $h$ 的近心点值决定（在此比较中忽略相位变化），因此覆盖一个轨道周期的步数是 $N = T/h$，其中 $T$ 是相对运动的轨道周期。\n\n计算使用 Aarseth 准则与使用自由落体估计在一个轨道周期内的总步数之比 $N_{\\mathrm{A}}/N_{\\mathrm{ff}}$，并将其表示为关于 $e$ 的单个闭式表达式。将最终答案表示为精确的符号表达式；不要进行四舍五入。", "solution": "该问题要求在开普勒轨道的近心点处，根据两种不同的时间步长准则，推导每个轨道周期的步数之比。我们从第一性原理开始。\n\n双体系统的相对运动由一个质量相对于另一个质量的位置矢量 $\\mathbf{r}$ 描述。运动方程由牛顿引力定律给出：\n$$\n\\ddot{\\mathbf{r}} = \\mathbf{a} = -\\frac{\\mu}{r^3} \\mathbf{r}\n$$\n其中 $\\mathbf{a}$ 是相对加速度，$r = |\\mathbf{r}|$ 是两个物体之间的距离，$\\mu = G(m_1 + m_2)$ 是系统的引力参数。\n\n该运动是开普勒运动，由半长轴 $a$ 和离心率 $e$ 描述。轨道上任意点处的距离 $r$ 与速率 $v = |\\dot{\\mathbf{r}}|$ 通过活力公式相关联：\n$$\nv^2 = \\mu \\left( \\frac{2}{r} - \\frac{1}{a} \\right)\n$$\n问题陈述粒子位于近心点。近心点距离 $r_{\\mathrm{p}}$ 是轨道中的最小分离距离，由下式给出：\n$$\nr_{\\mathrm{p}} = a(1-e)\n$$\n在近心点，位置矢量和速度矢量是正交的，即 $\\mathbf{r} \\cdot \\mathbf{v} = 0$。\n\n首先，我们推导在近心点所需的运动学量。\n\n1.  **近心点速率, $v_{\\mathrm{p}}$**：\n    我们将 $r = r_{\\mathrm{p}}$ 代入活力公式：\n    $$\n    v_{\\mathrm{p}}^2 = \\mu \\left( \\frac{2}{r_{\\mathrm{p}}} - \\frac{1}{a} \\right) = \\mu \\left( \\frac{2}{a(1-e)} - \\frac{1}{a} \\right)\n    $$\n    提出因子 $\\frac{\\mu}{a}$：\n    $$\n    v_{\\mathrm{p}}^2 = \\frac{\\mu}{a} \\left( \\frac{2}{1-e} - 1 \\right) = \\frac{\\mu}{a} \\left( \\frac{2 - (1-e)}{1-e} \\right) = \\frac{\\mu}{a} \\frac{1+e}{1-e}\n    $$\n    因此，近心点速率为：\n    $$\n    v_{\\mathrm{p}} = \\sqrt{\\frac{\\mu(1+e)}{a(1-e)}}\n    $$\n\n2.  **近心点加速度大小, $|\\mathbf{a}|_{\\mathrm{p}}$**：\n    根据运动方程，加速度的大小为 $|\\mathbf{a}| = \\frac{\\mu}{r^2}$。在近心点，这变为：\n    $$\n    |\\mathbf{a}|_{\\mathrm{p}} = \\frac{\\mu}{r_{\\mathrm{p}}^2} = \\frac{\\mu}{\\left(a(1-e)\\right)^2}\n    $$\n\n3.  **近心点加加加速度大小, $|\\mathbf{j}|_{\\mathrm{p}}$**：\n    加加加速度矢量是加速度矢量的时间导数：$\\mathbf{j} = \\frac{\\mathrm{d}\\mathbf{a}}{\\mathrm{d}t}$。\n    $$\n    \\mathbf{j} = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( -\\frac{\\mu}{r^3} \\mathbf{r} \\right)\n    $$\n    使用微分的乘法法则：\n    $$\n    \\mathbf{j} = -\\mu \\left( \\frac{\\mathrm{d}(r^{-3})}{\\mathrm{d}t} \\mathbf{r} + r^{-3} \\frac{\\mathrm{d}\\mathbf{r}}{\\mathrm{d}t} \\right)\n    $$\n    $r^{-3}$ 的导数是 $\\frac{\\mathrm{d}(r^{-3})}{\\mathrm{d}t} = -3r^{-4}\\frac{\\mathrm{d}r}{\\mathrm{d}t}$。此外，$\\frac{\\mathrm{d}\\mathbf{r}}{\\mathrm{d}t} = \\mathbf{v}$。项 $\\frac{\\mathrm{d}r}{\\mathrm{d}t}$ 是速度的径向分量，可以通过对 $r^2 = \\mathbf{r} \\cdot \\mathbf{r}$ 微分得到：$2r\\frac{\\mathrm{d}r}{\\mathrm{d}t} = 2\\mathbf{r} \\cdot \\mathbf{v}$，所以 $\\frac{\\mathrm{d}r}{\\mathrm{d}t} = \\frac{\\mathbf{r} \\cdot \\mathbf{v}}{r}$。\n    将这些代入加加加速度的表达式中：\n    $$\n    \\mathbf{j} = -\\mu \\left( -3r^{-4} \\frac{\\mathbf{r} \\cdot \\mathbf{v}}{r} \\mathbf{r} + r^{-3} \\mathbf{v} \\right) = \\frac{3\\mu(\\mathbf{r} \\cdot \\mathbf{v})}{r^5} \\mathbf{r} - \\frac{\\mu}{r^3} \\mathbf{v}\n    $$\n    在近心点，位置矢量和速度矢量是正交的，所以 $\\mathbf{r} \\cdot \\mathbf{v} = 0$。近心点处的加加加速度表达式 $\\mathbf{j}_{\\mathrm{p}}$ 大大简化：\n    $$\n    \\mathbf{j}_{\\mathrm{p}} = -\\frac{\\mu}{r_{\\mathrm{p}}^3} \\mathbf{v}_{\\mathrm{p}}\n    $$\n    因此，近心点加加加速度的大小为：\n    $$\n    |\\mathbf{j}|_{\\mathrm{p}} = \\frac{\\mu}{r_{\\mathrm{p}}^3} v_{\\mathrm{p}}\n    $$\n    我们可以代入 $r_{\\mathrm{p}}$ 和 $v_{\\mathrm{p}}$ 的表达式：\n    $$\n    |\\mathbf{j}|_{\\mathrm{p}} = \\frac{\\mu}{\\left(a(1-e)\\right)^3} \\sqrt{\\frac{\\mu(1+e)}{a(1-e)}}\n    $$\n\n接下来，我们推导在近心点处两种时间步长准则的表达式。\n\n1.  **Aarseth 时间步长, $h_{\\mathrm{A}}$**：\n    Aarseth 准则由 $h_{\\mathrm{A}} = \\eta \\frac{|\\mathbf{a}|}{|\\mathbf{j}|}$ 给出。在近心点：\n    $$\n    h_{\\mathrm{A}} = \\eta \\frac{|\\mathbf{a}|_{\\mathrm{p}}}{|\\mathbf{j}|_{\\mathrm{p}}} = \\eta \\frac{\\mu/r_{\\mathrm{p}}^2}{(\\mu/r_{\\mathrm{p}}^3) v_{\\mathrm{p}}} = \\eta \\frac{r_{\\mathrm{p}}}{v_{\\mathrm{p}}}\n    $$\n    用轨道要素表示 $r_{\\mathrm{p}}$ 和 $v_{\\mathrm{p}}$ 并代入：\n    $$\n    h_{\\mathrm{A}} = \\eta \\frac{a(1-e)}{\\sqrt{\\frac{\\mu(1+e)}{a(1-e)}}} = \\eta \\sqrt{\\frac{a^2(1-e)^2 \\cdot a(1-e)}{\\mu(1+e)}} = \\eta \\sqrt{\\frac{a^3(1-e)^3}{\\mu(1+e)}}\n    $$\n\n2.  **自由落体时间步长, $h_{\\mathrm{ff}}$**：\n    自由落体时间步长估计由 $h_{\\mathrm{ff}} = \\eta \\sqrt{\\frac{r_{\\mathrm{p}}}{|\\mathbf{a}|_{\\mathrm{p}}}}$ 给出。\n    代入 $|\\mathbf{a}|_{\\mathrm{p}} = \\mu/r_{\\mathrm{p}}^2$：\n    $$\n    h_{\\mathrm{ff}} = \\eta \\sqrt{\\frac{r_{\\mathrm{p}}}{\\mu/r_{\\mathrm{p}}^2}} = \\eta \\sqrt{\\frac{r_{\\mathrm{p}}^3}{\\mu}}\n    $$\n    代入 $r_{\\mathrm{p}}$ 的表达式：\n    $$\n    h_{\\mathrm{ff}} = \\eta \\sqrt{\\frac{(a(1-e))^3}{\\mu}} = \\eta \\sqrt{\\frac{a^3(1-e)^3}{\\mu}}\n    $$\n\n最后，我们计算每种准则下在一个轨道周期内的总步数之比。步数为 $N = T/h$，其中 $T$ 是轨道周期。该比率为：\n$$\n\\frac{N_{\\mathrm{A}}}{N_{\\mathrm{ff}}} = \\frac{T/h_{\\mathrm{A}}}{T/h_{\\mathrm{ff}}} = \\frac{h_{\\mathrm{ff}}}{h_{\\mathrm{A}}}\n$$\n代入推导出的 $h_{\\mathrm{A}}$ 和 $h_{\\mathrm{ff}}$ 表达式：\n$$\n\\frac{N_{\\mathrm{A}}}{N_{\\mathrm{ff}}} = \\frac{\\eta \\sqrt{\\frac{a^3(1-e)^3}{\\mu}}}{\\eta \\sqrt{\\frac{a^3(1-e)^3}{\\mu(1+e)}}}\n$$\n公共因子 $\\eta$、$a^3$、$(1-e)^3$ 和 $\\mu$ 消去：\n$$\n\\frac{N_{\\mathrm{A}}}{N_{\\mathrm{ff}}} = \\frac{\\sqrt{1}}{\\sqrt{\\frac{1}{1+e}}} = \\sqrt{1+e}\n$$\n最终的比率是离心率 $e$ 的一个简单函数。", "answer": "$$\n\\boxed{\\sqrt{1+e}}\n$$", "id": "3541177"}, {"introduction": "对于长期积分，数值方案必须具备时间可逆性，以防止能量等守恒量出现长期漂移。当使用量化的、2的幂次时间步长的分块步进方案时，更改粒子的步长箱可能会破坏这种对称性。本练习[@problem_id:3541229]旨在挑战您推导在时间上可逆地改变步长箱的精确数学条件并加以实现，这突出了稳健代码设计中的一个关键细节。", "problem": "考虑一个在牛顿引力作用下运动的 $N$ 粒子系统，其中每个粒子 $i$ 的位置为 $\\mathbf{r}_i(t)$、速度为 $\\mathbf{v}_i(t)$、质量为 $m_i$，其加速度 $\\mathbf{a}_i(t)$ 由牛顿第二定律和万有引力定律给出。总加速度由成对的力决定，而加速度的一阶时间导数（“jerk”或称加加速度）$\\mathbf{j}_i(t) = d\\mathbf{a}_i/dt$ 是由于相对位置和速度变化导致的作用力随时间变化而产生的。Hermite 预测-校正方案利用每一步开始和结束时的 $\\mathbf{a}_i$ 和 $\\mathbf{j}_i$ 来实现高阶精度。\n\n在具有块步进的独立时间步长方案中，每个粒子被分配一个由整数 $b \\in \\{0,1,2,\\dots,B_{\\max}\\}$ 索引的时间步长仓，其关联的量化步长为 $h_b = h_0 2^{b}$，其中 $h_0$ 是最小基本步长。时间由持续时间为 $h_0$ 的基本节拍离散化，因此每个块边界都出现在整数 $n$ 对应的 $t_n = n h_0$ 时刻。块步长时间表确保具有不同 $b$ 值的粒子在以分层方式对齐的边界上步进。\n\n假设在每个块边界时间 $t$，可以从某个正则性判据（例如，简化的 Hermite 判据 $h_{\\mathrm{cont}}(t) \\propto \\sqrt{\\|\\mathbf{a}(t)\\|/\\|\\mathbf{j}(t)\\|}$）获得一个期望的局部连续步长 $h_{\\mathrm{cont}}(t)$。为保持可逆性，块步长时间表必须是时间对称的。时间对称性要求，如果时间表是从 $t = 0$ 到 $t = T$ 正向生成的，那么使用相同的规则从 $t = T$ 到 $t = 0$ 反向积分时，应能得到完全相反的时间步长仓分配和步长边界的时间表。\n\n根据步长量化的一阶原理以及在 $t \\mapsto -t$ 变换下的时间对称性要求，推导出一个粒子可以在边界时间 $t_n$ 将其时间步长仓从 $b$ 更改为 $b' \\in \\{b-1,b,b+1\\}$ 而不破坏时间对称性的充分必要条件。证明该条件可以用新旧步长的最小公倍数来表示，并将其简化为2的幂次量化的情况。设计显式的仓位提升（至 $b' = b-1$）和仓位降低（至 $b' = b+1$）规则，以强制执行时间对称性条件。\n\n实现一个程序，给定基本分辨率 $h_0$、最大仓位 $B_{\\max}$、对应于总时间 $T = N_{\\mathrm{ticks}} h_0$ 的基本节拍整数数量 $N_{\\mathrm{ticks}}$ 以及初始仓位 $b(0)$，使用以下算法构建一个正向块步长时间表和一个反向块步长时间表：\n- 在每个边界时间 $t_n = n h_0$，计算 $h_{\\mathrm{cont}}(t_n)$ 并通过将 $\\log_2(h_{\\mathrm{cont}}(t_n)/h_0)$ 四舍五入到最近的整数，并将其限制在 $[0,B_{\\max}]$ 范围内，从而将其转换为期望的仓位索引 $b^\\ast(t_n)$。\n- 将提议的更改限制为每次决策只能改变一个级别，即 $b' = b + \\mathrm{sgn}(b^\\ast - b)$ 且 $b' \\in [0,B_{\\max}]$。\n- 当且仅当在时间 $t_n$ 满足推导出的时间对称性条件时，才允许从 $b \\to b'$ 的更改；否则保持 $b$ 不变。\n- 在正向时间表中将时间推进 $h_b$，在反向时间表中将时间回退 $h_b$，在每个正向起始边界记录序对 $(t_n, b(t_n))$。\n\n为了使时间表独立于显式的引力动力学，同时仍能测试块步进规则的时间对称性属性，将 $h_{\\mathrm{cont}}(t)$ 定义为一个确定性的时间函数，包含三种情况，用以检验仓位提升、降低和多级变化。时间使用无量纲单位，其中 $h_0$ 等于一个基本节拍：\n- 情况1（单调提升）：$h_0 = 1$，$B_{\\max} = 4$，$N_{\\mathrm{ticks}} = 64$，$b(0) = 3$，以及\n$$h_{\\mathrm{cont}}(t) = h_0 \\cdot 2^{\\,3 - 3 t/T} \\quad \\text{其中} \\quad T = N_{\\mathrm{ticks}} h_0.$$\n- 情况2（阈值附近的振荡变化）：$h_0 = 1$，$B_{\\max} = 5$，$N_{\\mathrm{ticks}} = 96$，$b(0) = 2$，以及\n$$h_{\\mathrm{cont}}(t) = h_0 \\cdot 2^{\\,2 + 0.9 \\sin\\!\\big(2\\pi t/T\\big)} \\quad \\text{其中} \\quad T = N_{\\mathrm{ticks}} h_0.$$\n- 情况3（尝试的多级降低）：$h_0 = 1$，$B_{\\max} = 5$，$N_{\\mathrm{ticks}} = 64$，$b(0) = 1$，以及\n$$\nh_{\\mathrm{cont}}(t) =\n\\begin{cases}\nh_0 \\cdot 2^{\\,4}, & 0 \\le t < T/2,\\\\\nh_0 \\cdot 2^{\\,0}, & T/2 \\le t \\le T.\n\\end{cases}\n$$\n\n你的程序应该：\n- 使用上述规则构建从 $t = 0$ 到 $t = T$ 的正向时间表。\n- 使用相同的规则构建从 $t = T$ 到 $t = 0$ 的反向时间表，从正向时间表在 $t = T$ 达到的最终仓位开始。\n- 将正向时间表访问的 $(t_n,b(t_n))$ 序列与反向时间表的逆序进行比较。对于每种情况，输出一个布尔值，指示时间表是否完全时间对称（即在反转下完全相同）。\n\n最终输出格式：你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果，例如 `[result_1,result_2,result_3]`，其中每个 `result_i` 是一个布尔值。\n\n测试套件和答案规范：\n- 输入是上述三种情况。\n- 对于每种情况，输出是一个布尔值，指示块步进仓位更改规则在反转下是否产生时间对称的时间表。\n- 所有时间量均以基本节拍为单位，是无量纲的；（三角函数内的）角度以弧度为单位；最终输出为布尔值。", "solution": "该问题要求为块式时间步进方案推导一个时间对称的仓位更改规则，并实现一个程序来验证其行为。\n\n### 块式步进中的时间对称性原理\n\n一个时间积分方案是时间对称的，如果在某个时间 $T$ 反转时间箭头（$t \\mapsto -t$）并反转所有速度的符号，系统会完全沿着其原始轨迹演化回其在 $t=0$ 时的状态。对于块式时间步进算法，这要求在正向（$0 \\to T$）和反向（$T \\to 0$）积分中，时间步长的选择序列是相同的。\n\n将一个粒子的时间步长仓从 $b$ 更改为 $b'$ 的决定是在离散的边界时间 $t_n = n h_0$ 做出的。该决定取决于粒子在 $t_n$ 时的状态。为了使时间表可逆，在正向积分期间于 $t_n$ 应用的决策规则必须与在反向积分期间于同一时间 $t_n$ 应用的决策规则一致。\n\n### 时间对称的仓位更改条件的推导\n\n我们考虑一个粒子，在边界时间 $t_n$ 之前，其步长由仓 $b$（步长大小为 $h_b = h_0 2^b$）决定。为了让粒子能够进行潜在的仓位更改，$t_n$ 必须是其当前步长 $h_b$ 的倍数。\n$$ t_n \\pmod{h_b} = 0 $$\n在时间 $t_n$，根据某个判据（此处与 $h_{\\mathrm{cont}}(t_n)$ 相关），决定是否可能将仓位更改为 $b'$。如果进行了更改，从 $t_n$ 开始的下一步将具有大小 $h_{b'}$。\n\n现在，考虑时间反演的演化。系统从未来到达时间 $t_n$，刚刚完成了一个大小为 $h_{b'}$ 的后向步。为了使 $t_n$ 处的决策逻辑是对称的，该逻辑所作用的系统状态必须被同样地感知。在块式步进的背景下，这意味着时间 $t_n$ 对于一个曾处于仓 $b'$ 的粒子来说，必须是一个有效的同步点。换句话说，$t_n$ 也必须是步长 $h_{b'}$ 的倍数。\n$$ t_n \\pmod{h_{b'}} = 0 $$\n\n结合这两个要求，在时间 $t_n$ 从仓 $b$ 到仓 $b'$ 的更改可以不破坏时间对称性地发生，当且仅当 $t_n$ 是 $h_b$ 和 $h_{b'}$ 的公倍数。这等价于说，$t_n$ 必须是新旧步长的最小公倍数（LCM）的倍数。\n\n时间对称的更改 $b \\to b'$ 在时间 $t_n$ 的充分必要条件是：\n$$ t_n \\pmod{\\mathrm{lcm}(h_b, h_{b'})} = 0 $$\n\n### 2的幂次量化条件\n\n问题指定了步长的2的幂次量化：$h_b = h_0 2^b$。两个这样步长的最小公倍数是：\n$$ \\mathrm{lcm}(h_b, h_{b'}) = \\mathrm{lcm}(h_0 2^b, h_0 2^{b'}) = h_0 \\cdot \\mathrm{lcm}(2^b, 2^{b'}) = h_0 \\cdot 2^{\\max(b, b')} $$\n将此代入我们的条件并使用 $t_n = n h_0$，我们得到：\n$$ (n h_0) \\pmod{h_0 \\cdot 2^{\\max(b, b')}} = 0 $$\n除以基本步长 $h_0$，我们得到以整数节拍数 $n$ 表示的条件：\n$$ n \\pmod{2^{\\max(b, b')}} = 0 $$\n基本节拍的整数数量 $n$ 必须能被 $2$ 的（旧仓 $b$ 和提议的新仓 $b'$ 中）*较大*的那个仓位指数的幂整除。\n\n### 显式的仓位提升和降低规则\n\n问题将仓位更改限制在相邻级别，即 $b' \\in \\{b-1, b+1\\}$。\n\n1.  **仓位提升（步长变小）：** $b \\to b' = b-1$。\n    步长减小。条件变为：\n    $$ n \\pmod{2^{\\max(b, b-1)}} = 0 \\implies n \\pmod{2^b} = 0 $$\n    一个在仓 $b$ 中的粒子仅在 $n$ 是 $2^b$ 的倍数的时间 $t_n$ 才处于活动状态。因此，只要粒子处于活动状态，这个条件就*总是满足*的。粒子可以在其任何自然更新时间被提升到更小的时间步长。\n\n2.  **仓位降低（步长变大）：** $b \\to b' = b+1$。\n    步长增大。条件变为：\n    $$ n \\pmod{2^{\\max(b, b+1)}} = 0 \\implies n \\pmod{2^{b+1}} = 0 $$\n    这是一个更严格的条件。一个在仓 $b$ 中的粒子在 $n$ 是 $2^b$ 的倍数时处于活动状态。要被降级到仓 $b+1$，它只能在 $n$ 同时也是 $2^{b+1}$ 的倍数时才能这样做。这发生在粒子的每隔一次活动步上。例如，一个在仓 $b=2$ 的粒子在 $n=4, 8, 12, 16, \\dots$ 时是活动的。它只能在 $n=8, 16, \\dots$ 时被降级到仓 $b=3$，而不能在 $n=4, 12, \\dots$ 时。\n\n### 算法实现\n\n该程序实现了一个函数 `generate_schedule`，它根据这些规则构建时间步长时间表。它在整数时间节拍上操作以避免浮点不精确性。该函数被设计为可以正向（从 $t=0$ 到 $T$）和反向（从 $t=T$ 到 $0$）运行。\n\n在模拟的每一步（正向或反向），于边界时间 $t_n$：\n1.  从给定的函数 $h_{\\mathrm{cont}}(t_n)$ 计算期望的仓位 $b^\\ast$。\n2.  通过从前一个仓位 $b$ 朝着 $b^\\ast$ 移动一个级别来确定提议的仓位 $b'$。\n3.  检查时间对称性条件 $n \\pmod{2^{\\max(b, b')}} = 0$。\n4.  只有当条件满足时，仓位才更新为 $b'$；否则，它保持为 $b$。\n5.  时间根据新仓位对应的步长前进或后退。\n\n生成正向时间表。此运行的最终仓位用作反向运行的初始仓位。生成反向时间表然后将其反转。比较 `forward` 和 `reversed(backward)` 这两个时间表是否相等，以验证时间对称性。对于所有三种测试情况，推导出的规则预期将产生完全时间对称的时间表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef sgn(x):\n    \"\"\"Returns the sign of a number.\"\"\"\n    return np.sign(x)\n\ndef clamp(val, min_val, max_val):\n    \"\"\"Clamps a value to the specified range [min_val, max_val].\"\"\"\n    return max(min_val, min(val, max_val))\n\n# Deterministic h_cont functions for the three test cases\ndef h_cont_case1(t, T, h0):\n    return h0 * 2**(3.0 - 3.0 * t / T)\n\ndef h_cont_case2(t, T, h0):\n    return h0 * 2**(2.0 + 0.9 * np.sin(2 * np.pi * t / T))\n\ndef h_cont_case3(t, T, h0):\n    if 0 = t  T / 2:\n        return h0 * 2**4.0\n    else:\n        return h0 * 2**0.0\n\ndef generate_schedule(params, direction):\n    \"\"\"\n    Generates a block-step schedule either forward or backward in time.\n\n    The state is defined by (t, b), where 'b' is the bin for the step\n    starting at time 't'. The decision for 'b' at 't' is based on the\n    bin of the step that *ended* at 't'.\n    \"\"\"\n    h0 = params['h0']\n    B_max = params['B_max']\n    N_ticks = params['N_ticks']\n    h_cont_func = params['h_cont_func']\n   \n    schedule = []\n    \n    if direction == 'forward':\n        t_current_ticks = 0\n        t_end_ticks = N_ticks\n        b_prev = params['b0']\n        time_step_direction = 1\n    else:  # backward\n        t_current_ticks = N_ticks\n        t_end_ticks = 0\n        b_prev = params['b_final_forward']\n        time_step_direction = -1\n\n    # Loop until the current time reaches the end time\n    while time_step_direction * (t_current_ticks - t_end_ticks)  0:\n        t_float = float(t_current_ticks * h0)\n        n = t_current_ticks\n        \n        # 1. Determine the desired bin b* from the continuous step size criterion.\n        h_c = h_cont_func(t_float, N_ticks * h0, h0)\n        \n        # np.round implements \"round half to even\", which is a standard choice.\n        b_star = int(np.round(np.log2(h_c / h0)))\n        b_star = clamp(b_star, 0, B_max)\n        \n        # 2. Propose a new bin b', restricted to a single-level change.\n        b_prop = b_prev\n        if b_star != b_prev:\n            b_prop = int(b_prev + sgn(b_star - b_prev))\n            b_prop = clamp(b_prop, 0, B_max)\n\n        # 3. Apply the time symmetry condition to decide the actual new bin.\n        b_curr = b_prev\n        if b_prop != b_prev:\n            max_b = max(b_prev, b_prop)\n            if n % (2**max_b) == 0:\n                b_curr = b_prop\n        \n        step_ticks = 2**b_curr\n        \n        if direction == 'forward':\n            schedule.append((t_current_ticks, b_curr))\n            t_current_ticks += time_step_direction * step_ticks\n            b_prev = b_curr\n        else:  # backward\n            t_prev_ticks = t_current_ticks - step_ticks\n            schedule.append((t_prev_ticks, b_curr))\n            t_current_ticks = t_prev_ticks\n            b_prev = b_curr\n\n    # The final bin for the forward run is the last decided bin, `b_prev`.\n    if direction == 'forward':\n        final_bin = b_prev\n    else:\n        final_bin = None\n        schedule.reverse()\n    \n    return schedule, final_bin\n\ndef run_and_verify(case_params):\n    \"\"\"\n    Runs a forward and backward simulation for a given case\n    and verifies if the schedules are time-symmetric.\n    \"\"\"\n    # Run the forward schedule to generate it and get the final bin.\n    fwd_params = {**case_params, 'direction': 'forward'}\n    fwd_schedule, b_final_forward = generate_schedule(fwd_params, 'forward')\n\n    # Run the backward schedule starting with the final forward bin.\n    bwd_params = {**case_params, 'direction': 'backward', 'b_final_forward': b_final_forward}\n    bwd_schedule, _ = generate_schedule(bwd_params, 'backward')\n    \n    return fwd_schedule == bwd_schedule\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'h0': 1, 'B_max': 4, 'N_ticks': 64, 'b0': 3, 'h_cont_func': h_cont_case1},\n        {'h0': 1, 'B_max': 5, 'N_ticks': 96, 'b0': 2, 'h_cont_func': h_cont_case2},\n        {'h0': 1, 'B_max': 5, 'N_ticks': 64, 'b0': 1, 'h_cont_func': h_cont_case3}\n    ]\n\n    results = []\n    for params in test_cases:\n        is_symmetric = run_and_verify(params)\n        results.append(is_symmetric)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3541229"}, {"introduction": "分块步进方案的一个关键效率在于并非所有粒子都在每个时钟周期上更新；“非活动”粒子的影响是通过预测器来估计的。然而，这也引入了一种新的误差来源。本练习[@problem_id:3541176]要求您从理论上推导这种预测误差的阶数，并通过经验性测试来验证它，从而将理论与分块步进积分器（如Kick-Drift-Kick方案）的数值行为直接联系起来。", "problem": "考虑一个牛顿 $N$ 体系统，其中 $N \\in \\mathbb{N}$，采用无量纲的 $N$ 体单位，引力常数 $G = 1$。其运动方程由下式给出\n$$\n\\frac{d\\mathbf{r}_i}{dt} = \\mathbf{v}_i, \\quad \\frac{d\\mathbf{v}_i}{dt} = \\mathbf{a}_i(\\mathbf{r}_1,\\dots,\\mathbf{r}_N) = \\sum_{j \\ne i} m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\|\\mathbf{r}_j - \\mathbf{r}_i\\|^3},\n$$\n其中，对于 $i = 1, \\dots, N$，$\\mathbf{r}_i \\in \\mathbb{R}^3$ 是粒子 $i$ 的位置，$\\mathbf{v}_i \\in \\mathbb{R}^3$ 是其速度， $m_i  0$ 是其质量，$\\mathbf{a}_i$ 是其加速度。\n\n实现一个块步长 Kick-Drift-Kick (KDK) 方案，其中每个粒子 $i$ 具有独立的时间步长 $\\Delta t_i$，该步长被限制为基本时间刻度 $h$ 的 2 的幂次方倍，即 $\\Delta t_i = 2^{k_i} h$，其中 $k_i$ 为某个非负整数。全局更新按基本时间刻度的节奏进行，将时间从 $t$ 推进到 $t + h$，并且只有那些其时间表与当前刻度对齐的粒子才在该刻度上被更新。在任何全局时间刻度 $t$ 上，计算活动粒子所需的加速度时，必须使用非活动粒子在时间 $t$ 的预测位置。对每个非活动粒子 $j$，基于其最后一次更新的状态 $\\left(\\mathbf{r}_j(t_0), \\mathbf{v}_j(t_0), \\mathbf{a}_j(t_0)\\right)$ 和时间偏移量 $\\Delta t = t - t_0$，使用二阶 Taylor 预测器：\n$$\n\\mathbf{r}_j^{\\mathrm{pred}}(t) = \\mathbf{r}_j(t_0) + \\mathbf{v}_j(t_0)\\,\\Delta t + \\frac{1}{2}\\,\\mathbf{a}_j(t_0)\\,\\Delta t^2.\n$$\n\n从第一性原理出发，推导因在全局时间刻度上评估 $\\mathbf{a}_i$ 时使用 $\\mathbf{r}_j^{\\mathrm{pred}}(t)$ 而非精确的 $\\mathbf{r}_j(t)$ 所导致的引力（等效于加速度）插值误差的阶数（以 $h$ 的幂表示）。你的推导必须从精确运动的 Taylor 展开开始，并利用引力场在远离碰撞处的标准光滑性。在关系式 $\\|\\mathbf{a}_i^{\\mathrm{pred}}(t) - \\mathbf{a}_i^{\\mathrm{true}}(t)\\| = \\mathcal{O}(h^p)$ 中，将阶数明确地表述为一个整数 $p$，其中 $h \\to 0$。\n\n你的程序必须实现所描述的块步长 KDK 积分器，并对指定的测试案例进行经验性评估插值误差。你必须遵守以下约束并产生所要求的输出：\n\n- 单位：使用无量纲的 $N$ 体单位。没有需要转换的物理单位。所有角度必须以弧度为单位。\n- 在时间刻度 $t$ 上对活动粒子 $i$ 的积分器细节：\n  - 踢：使用在时间 $t$ 计算的加速度（其中非活动粒子的位置被预测到时间 $t$）更新速度半步：\n    $$\n    \\mathbf{v}_i \\leftarrow \\mathbf{v}_i + \\frac{1}{2}\\,\\Delta t_i\\,\\mathbf{a}_i\\big(\\{\\mathbf{r}_k^{\\mathrm{act}}(t)\\}, \\{\\mathbf{r}_j^{\\mathrm{pred}}(t)\\}\\big).\n    $$\n  - 漂移：更新位置一整步：\n    $$\n    \\mathbf{r}_i \\leftarrow \\mathbf{r}_i + \\Delta t_i\\,\\mathbf{v}_i.\n    $$\n  - 踢：使用在更新后的时间 $t + \\Delta t_i$ 计算的加速度（其中非活动粒子的位置被预测到 $t + \\Delta t_i$）再更新速度半步：\n    $$\n    \\mathbf{v}_i \\leftarrow \\mathbf{v}_i + \\frac{1}{2}\\,\\Delta t_i\\,\\mathbf{a}_i\\big(\\{\\mathbf{r}_k^{\\mathrm{act}}(t+\\Delta t_i)\\}, \\{\\mathbf{r}_j^{\\mathrm{pred}}(t+\\Delta t_i)\\}\\big).\n    $$\n\n测试套件和输出规范：\n\n定义以下测试案例并产生指定的输出：\n\n1. 圆形双体插值阶数。考虑两个等质量 $m_1 = m_2 = 1$ 的粒子，在一个共面的圆形轨道上围绕质心运动，每个质量的半径为 $R = 1$。精确运动为\n   $$\n   \\mathbf{r}_1(t) = R (\\cos(\\omega t),\\, \\sin(\\omega t),\\, 0), \\quad \\mathbf{r}_2(t) = -\\mathbf{r}_1(t),\n   $$\n   角频率 $\\omega$ 满足 $\\omega^2 = \\frac{m_2}{(2R)^3} \\cdot 2R = \\frac{1}{4}$，因此 $\\omega = \\frac{1}{2}$。设基本时间刻度为 $h_1 = 10^{-2}$，并设置 $\\Delta t_1 = h_1$ 和 $\\Delta t_2 = 2 h_1$。在时间 $t = h_1$ 时，使用基于 $\\mathbf{r}_2(0)$, $\\mathbf{v}_2(0)$ 和 $\\mathbf{a}_2(0)$ 的二阶预测器得到的 $\\mathbf{r}_2^{\\mathrm{pred}}(t)$ 来计算粒子 1 上的加速度，并与使用精确 $\\mathbf{r}_2(t)$ 得到的加速度进行比较。使用基本时间刻度 $h_2 = h_1/2$ 以及相应的 $\\Delta t_1 = h_2, \\Delta t_2 = 2 h_2$ 重复此过程。通过下式估算经验阶数 $p_{\\mathrm{circ}}$\n   $$\n   p_{\\mathrm{circ}} = \\log_2\\left(\\frac{\\|\\mathbf{a}_1^{\\mathrm{pred}}(h_1) - \\mathbf{a}_1^{\\mathrm{true}}(h_1)\\|}{\\|\\mathbf{a}_1^{\\mathrm{pred}}(h_2) - \\mathbf{a}_1^{\\mathrm{true}}(h_2)\\|}\\right).\n   $$\n   将其作为浮点数输出。\n\n2. 边界同步检查。使用与案例 1 中相同的圆形轨道设置和 $h_1$，考虑在 $t = 2 h_1$ 的全局时间刻度，此时两个粒子都是活动的，因为 $\\Delta t_2 = 2 h_1$。在此类时间刻度上，积分器不得使用预测位置来评估这些粒子的加速度。返回一个布尔值，指示在此同步时间刻度上是否正确避免了插值。\n\n3. 椭圆双体插值阶数。考虑两个等质量 $m_1 = m_2 = 1$ 的粒子，在一个共面的 Kepler 椭圆轨道上围绕其质心运动，相对半长轴为 $a_{\\mathrm{rel}} = 2$，偏心率为 $e = 0.6$。总引力参数为 $\\mu = m_1 + m_2 = 2$，平均运动角速度为 $n = \\sqrt{\\mu/a_{\\mathrm{rel}}^3}$，相对轨道遵循 Kepler 方程 $M(t) = E(t) - e \\sin E(t)$，其中平近点角为 $M(t) = n t$。相对位置为\n   $$\n   \\mathbf{r}_{\\mathrm{rel}}(t) = a_{\\mathrm{rel}}(\\cos E(t) - e, \\ \\sqrt{1-e^2}\\,\\sin E(t), \\ 0),\n   $$\n   质心坐标系下的位置为 $\\mathbf{r}_1(t) = \\frac{1}{2}\\mathbf{r}_{\\mathrm{rel}}(t)$ 和 $\\mathbf{r}_2(t) = -\\frac{1}{2}\\mathbf{r}_{\\mathrm{rel}}(t)$。使用与案例 1 中相同的程序，采用基本时间刻度 $h_1 = 10^{-2}$ 和 $h_2 = h_1/2$，评估在时间 $t = h$ 时，使用预测的 $\\mathbf{r}_2^{\\mathrm{pred}}(t)$ 与精确的 $\\mathbf{r}_2(t)$ 计算粒子 1 上的加速度所产生的经验插值阶数 $p_{\\mathrm{ecc}}$。将 $p_{\\mathrm{ecc}}$ 作为浮点数输出。\n\n4. 块步长 KDK 下的能量漂移。为圆形双体系统实现块步长 KDK 积分器，参数为 $h = 10^{-3}$、$\\Delta t_1 = h$、$\\Delta t_2 = 2 h$，并从 $t = 0$ 积分到 $t = 10^{-1}$。记录总机械能\n   $$\n   E(t) = \\sum_{i=1}^{2} \\frac{1}{2} m_i \\|\\mathbf{v}_i(t)\\|^2 - \\frac{m_1 m_2}{\\|\\mathbf{r}_1(t) - \\mathbf{r}_2(t)\\|}\n   $$\n   在同步时间刻度 $t = 2 k h$（其中 $k \\ge 0$ 为整数）上。报告此区间内的最大相对能量漂移，\n   $$\n   \\max_{t \\in \\{0, 2h, 4h, \\dots, 10^{-1}\\}} \\left| \\frac{E(t) - E(0)}{E(0)} \\right|,\n   $$\n   作为浮点数。\n\n最终输出格式：\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$$\n[p_{\\mathrm{circ}}, \\ \\text{boundary\\_sync\\_ok}, \\ p_{\\mathrm{ecc}}, \\ \\text{max\\_relative\\_energy\\_drift}],\n$$\n其中 $p_{\\mathrm{circ}}$ 和 $p_{\\mathrm{ecc}}$ 是浮点数，$\\text{boundary\\_sync\\_ok}$ 是布尔值，$\\text{max\\_relative\\_energy\\_drift}$ 是浮点数。", "solution": "用户需要对一个用于 $N$ 体系统的块步长 Kick-Drift-Kick (KDK) 积分器进行严谨的分析和实现。任务包括插值误差阶数的理论推导以及通过数值实验进行的经验验证。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n*   **系统**：牛顿 $N$ 体系统，引力常数 $G=1$。\n*   **运动方程**：\n    $$\n    \\frac{d\\mathbf{r}_i}{dt} = \\mathbf{v}_i, \\quad \\frac{d\\mathbf{v}_i}{dt} = \\mathbf{a}_i = \\sum_{j \\ne i} m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\|\\mathbf{r}_j - \\mathbf{r}_i\\|^3}\n    $$\n*   **积分器**：块步长 Kick-Drift-Kick (KDK) 方案。\n*   **时间步长**：独立步长 $\\Delta t_i = 2^{k_i} h$，其中基本时间刻度为 $h$ 且 $k_i \\in \\{0, 1, 2, ...\\}$。\n*   **更新规则**：按时间刻度节奏 $t \\to t + h$ 进行全局更新。只有时间表对齐的粒子才会被更新。\n*   **预测器**：对于非活动粒子 $j$，基于其在 $t_0$ 的状态，使用二阶 Taylor 预测器预测其在时间 $t$ 的位置：\n    $$\n    \\mathbf{r}_j^{\\mathrm{pred}}(t) = \\mathbf{r}_j(t_0) + \\mathbf{v}_j(t_0)\\,\\Delta t + \\frac{1}{2}\\,\\mathbf{a}_j(t_0)\\,\\Delta t^2, \\quad \\text{其中 } \\Delta t = t - t_0.\n    $$\n*   **理论任务**：推导加速度中插值误差的整数阶数 $p$：$\\|\\mathbf{a}_i^{\\mathrm{pred}}(t) - \\mathbf{a}_i^{\\mathrm{true}}(t)\\| = \\mathcal{O}(h^p)$。\n*   **活动粒子 $i$ 在时间 $t$ 步长为 $\\Delta t_i$ 时的 KDK 步骤**：\n    1.  踢：$\\mathbf{v}_i \\leftarrow \\mathbf{v}_i + \\frac{1}{2}\\,\\Delta t_i\\,\\mathbf{a}_i(\\text{在 } t)$。\n    2.  漂移：$\\mathbf{r}_i \\leftarrow \\mathbf{r}_i + \\Delta t_i\\,\\mathbf{v}_i$（使用刚更新的速度）。\n    3.  踢：$\\mathbf{v}_i \\leftarrow \\mathbf{v}_i + \\frac{1}{2}\\,\\Delta t_i\\,\\mathbf{a}_i(\\text{在 } t + \\Delta t_i)$。\n*   **测试案例**：\n    1.  **圆形轨道**：$m_1=m_2=1$，圆形轨道，质心坐标系下半径 $R=1$。$\\Delta t_1 = h, \\Delta t_2 = 2h$。时间刻度 $h_1=10^{-2}, h_2=h_1/2$。计算经验阶数 $p_{\\mathrm{circ}}$。\n    2.  **边界同步检查**：相同设置，在 $t=2h_1$ 时，检查是否避免了插值。\n    3.  **椭圆轨道**：$m_1=m_2=1$，椭圆轨道，$a_{\\mathrm{rel}}=2, e=0.6$。与案例 1 相同的流程，以找到 $p_{\\mathrm{ecc}}$。\n    4.  **能量漂移**：圆形轨道，$h=10^{-3}, \\Delta t_1=h, \\Delta t_2=2h$。从 $t=0$ 积分到 $10^{-1}$。报告在同步时间刻度上的最大相对能量漂移。\n*   **输出格式**：`[p_circ, boundary_sync_ok, p_ecc, max_relative_energy_drift]`\n\n**步骤 2：使用提取的给定信息进行验证**\n\n该问题在科学上和数学上是明确定义的。它描述了计算天体物理学中的一个标准场景：使用带有预测器的块步长积分器来解决 $N$ 体问题。运动、预测和积分器步骤的方程都已正确陈述。测试案例基于双体问题的精确解（圆形和椭圆轨道），为经验验证提供了坚实的基础。所有参数都已指定，任务明确无误。该问题是自洽的、客观的，并且没有违反任何科学原理。\n\n**步骤 3：结论和行动**\n\n问题是**有效的**。将提供完整的解决方案。\n\n### 插值误差阶数的理论推导\n\n任务的核心是确定在计算非活动粒子的加速度时，因使用其预测位置而引入的误差阶数。设粒子 $i$ 是一个活动粒子，其加速度正在时间 $t$ 计算。设粒子 $j$ 是一个非活动粒子，其状态最后一次更新是在时间 $t_0$。预测的时间间隔为 $\\Delta t = t - t_0$。\n\n粒子 $j$ 在时间 $t$ 的精确位置可以通过其在 $t_0$ 附近的 Taylor 级数展开来表示：\n$$\n\\mathbf{r}_j(t) = \\mathbf{r}_j(t_0) + \\mathbf{v}_j(t_0)\\Delta t + \\frac{1}{2}\\mathbf{a}_j(t_0)\\Delta t^2 + \\frac{1}{6}\\mathbf{j}_j(t_0)\\Delta t^3 + \\mathcal{O}(\\Delta t^4)\n$$\n其中 $\\mathbf{v}_j = \\dot{\\mathbf{r}}_j$、$\\mathbf{a}_j = \\ddot{\\mathbf{r}}_j$ 和 $\\mathbf{j}_j = \\dddot{\\mathbf{r}}_j$（加加速度）都在 $t_0$ 时刻计算。\n\n问题指定了粒子 $j$ 位置的二阶预测器：\n$$\n\\mathbf{r}_j^{\\mathrm{pred}}(t) = \\mathbf{r}_j(t_0) + \\mathbf{v}_j(t_0)\\Delta t + \\frac{1}{2}\\mathbf{a}_j(t_0)\\Delta t^2\n$$\n预测位置的误差 $\\delta \\mathbf{r}_j(t) = \\mathbf{r}_j^{\\mathrm{pred}}(t) - \\mathbf{r}_j(t)$，可以通过从预测位置减去真实展开式得到：\n$$\n\\delta \\mathbf{r}_j(t) = -\\frac{1}{6}\\mathbf{j}_j(t_0)\\Delta t^3 - \\mathcal{O}(\\Delta t^4)\n$$\n因此，位置的主导阶误差为 $\\mathcal{O}(\\Delta t^3)$。\n\n粒子 $i$ 上的加速度是所有其他粒子 $k \\neq i$ 贡献的总和。加速度的误差来自于所有非活动粒子 $j$ 的误差总和。我们考虑粒子 $j$ 对粒子 $i$ 的加速度贡献，记为 $\\mathbf{a}_{ij}(\\mathbf{r}_j)$。\n$$\n\\mathbf{a}_{ij}(\\mathbf{r}_j) = m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\|\\mathbf{r}_j - \\mathbf{r}_i\\|^3}\n$$\n该加速度项的误差为 $\\delta \\mathbf{a}_{ij} = \\mathbf{a}_{ij}(\\mathbf{r}_j^{\\mathrm{pred}}) - \\mathbf{a}_{ij}(\\mathbf{r}_j)$。对于一个小的位置误差 $\\delta \\mathbf{r}_j$，我们可以使用加速度场相对于粒子 $j$ 位置的一阶 Taylor 展开：\n$$\n\\mathbf{a}_{ij}(\\mathbf{r}_j^{\\mathrm{pred}}) = \\mathbf{a}_{ij}(\\mathbf{r}_j(t) + \\delta \\mathbf{r}_j(t)) \\approx \\mathbf{a}_{ij}(\\mathbf{r}_j(t)) + \\left( \\nabla_{\\mathbf{r}_j} \\mathbf{a}_{ij} \\right) \\cdot \\delta \\mathbf{r}_j(t)\n$$\n这里，$\\nabla_{\\mathbf{r}_j} \\mathbf{a}_{ij}$ 是加速度场的 Jacobian 矩阵（潮汐张量），在真实位置 $\\mathbf{r}_j(t)$ 处计算。因此，误差为：\n$$\n\\delta \\mathbf{a}_{ij}(t) = \\mathbf{a}_{ij}(\\mathbf{r}_j^{\\mathrm{pred}}) - \\mathbf{a}_{ij}(\\mathbf{r}_j(t)) \\approx \\left( \\nabla_{\\mathbf{r}_j} \\mathbf{a}_{ij} \\right) \\cdot \\delta \\mathbf{r}_j(t)\n$$\n由于引力场在远离碰撞处是光滑的，潮汐张量的分量是有限的。加速度的误差与位置的误差成线性比例。因此，加速度误差的阶数与位置误差的阶数相同：\n$$\n\\|\\delta \\mathbf{a}_{ij}(t)\\| = \\mathcal{O}(\\|\\delta \\mathbf{r}_j(t)\\|) = \\mathcal{O}(\\Delta t^3)\n$$\n粒子 $i$ 上的总加速度误差是所有非活动粒子此类项的总和。\n$$\n\\mathbf{a}_i^{\\mathrm{pred}}(t) - \\mathbf{a}_i^{\\mathrm{true}}(t) = \\sum_{j \\text{ inactive}} \\delta \\mathbf{a}_{ij}(t)\n$$\n时间间隔 $\\Delta t = t - t_0$ 至多是粒子自身的时间步长 $\\Delta t_j = 2^{k_j} h$。当基本时间刻度 $h \\to 0$ 时，间隔 $\\Delta t$ 也与 $h$ 成比例，即 $\\Delta t = \\mathcal{O}(h)$。将此代入我们的误差估计中：\n$$\n\\|\\mathbf{a}_i^{\\mathrm{pred}}(t) - \\mathbf{a}_i^{\\mathrm{true}}(t)\\| = \\mathcal{O}(\\Delta t^3) = \\mathcal{O}(h^3)\n$$\n只要加加速度 $\\mathbf{j}_j(t_0)$ 非零，此结论就成立。对于一般轨道，这是成立的。\n因此，加速度中插值误差的阶数为 $p=3$。\n\n经验测试涉及计算两种不同基本时间刻度 $h_1$ 和 $h_2 = h_1/2$ 的误差。误差范数预期会按 $E(h) \\approx C h^p$ 的方式缩放。\n$$\np = \\log_{h_1/h_2} \\left( \\frac{E(h_1)}{E(h_2)} \\right) = \\log_2 \\left( \\frac{C h_1^p}{C h_2^p} \\right) = \\log_2 \\left( \\left(\\frac{h_1}{h_2}\\right)^p \\right) = p \\log_2(2) = p\n$$\n该数值实验被正确设置，以恢复理论阶数 $p=3$。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import newton\n\ndef solve():\n    \"\"\"\n    Solves the four test cases specified in the problem statement.\n    \"\"\"\n\n    # --- Utility Functions ---\n\n    def predict_pos(r0, v0, a0, dt):\n        \"\"\"Second-order Taylor predictor for position.\"\"\"\n        return r0 + v0 * dt + 0.5 * a0 * dt**2\n\n    def calculate_accel(r_i, r_j, m_j):\n        \"\"\"Computes acceleration on particle i due to j. G=1.\"\"\"\n        rel_pos = r_j - r_i\n        dist_sq = np.dot(rel_pos, rel_pos)\n        dist = np.sqrt(dist_sq)\n        return m_j * rel_pos / (dist_sq * dist)\n\n    def calculate_total_energy(r, v, m):\n        \"\"\"Computes total mechanical energy of a two-body system.\"\"\"\n        ke = 0.5 * m[0] * np.dot(v[0], v[0]) + 0.5 * m[1] * np.dot(v[1], v[1])\n        # G=1\n        pe = - (m[0] * m[1]) / np.linalg.norm(r[0] - r[1])\n        return ke + pe\n\n    # --- Test Case 1  4: Circular Orbit State ---\n\n    def get_circular_orbit_state(t, m1=1.0, m2=1.0, R=1.0):\n        \"\"\"\n        Calculates the exact state (r, v, a) for two bodies in a circular orbit.\n        \"\"\"\n        # omega^2 = m2 / (4*R^3) is incorrect. Correct is omega^2*R = G*m2 / (2R)^2\n        # => omega^2 = G*m2 / (4*R^3). For G=m2=R=1, omega^2 = 1/4 -> omega=0.5\n        # The problem statement's omega is correct.\n        omega = 0.5\n        r1 = np.array([R * np.cos(omega * t), R * np.sin(omega * t), 0.0])\n        v1 = np.array([-R * omega * np.sin(omega * t), R * omega * np.cos(omega * t), 0.0])\n        a1 = -omega**2 * r1\n        r2, v2, a2 = -r1, -v1, -a1\n        return r1, v1, a1, r2, v2, a2\n\n    # --- Test Case 3: Eccentric Orbit State ---\n\n    def solve_kepler(M, e):\n        \"\"\"Solves Kepler's equation M = E - e*sin(E) for E using Newton's method.\"\"\"\n        return newton(lambda E: E - e * np.sin(E) - M, M)\n\n    def get_eccentric_orbit_state(t, m1=1.0, m2=1.0, a_rel=2.0, e=0.6):\n        \"\"\"\n        Calculates the exact state (r, v, a) for two bodies in an eccentric orbit.\n        \"\"\"\n        mu = m1 + m2\n        n = np.sqrt(mu / a_rel**3)  # Mean motion\n        M = n * t  # Mean anomaly\n        E = solve_kepler(M, e)  # Eccentric anomaly\n\n        r_rel_val = a_rel * (1.0 - e * np.cos(E))\n        E_dot = n * a_rel / r_rel_val\n        \n        r_rel = np.array([\n            a_rel * (np.cos(E) - e),\n            a_rel * np.sqrt(1.0 - e**2) * np.sin(E),\n            0.0\n        ])\n        v_rel = np.array([\n            -a_rel * np.sin(E) * E_dot,\n            a_rel * np.sqrt(1.0 - e**2) * np.cos(E) * E_dot,\n            0.0\n        ])\n        \n        f1, f2 = m2 / mu, m1 / mu\n        r1, r2 = f1 * r_rel, -f2 * r_rel\n        v1, v2 = f1 * v_rel, -f2 * v_rel\n        a1 = calculate_accel(r1, r2, m2)\n        a2 = calculate_accel(r2, r1, m1)\n        return r1, v1, a1, r2, v2, a2\n\n    # --- Test Case Calculations ---\n\n    def case1_circular_order():\n        m1, m2 = 1.0, 1.0\n        h1 = 1e-2\n        h2 = h1 / 2.0\n        \n        errors = []\n        for h in [h1, h2]:\n            t = h\n            # Exact states\n            r1_true, _, _, r2_true, _, _ = get_circular_orbit_state(t)\n            # State of particle 2 at t=0 for prediction\n            _, _, _, r2_0, v2_0, a2_0 = get_circular_orbit_state(0)\n            \n            # Predict position of particle 2 to time t=h\n            r2_pred = predict_pos(r2_0, v2_0, a2_0, t)\n\n            # True and predicted acceleration on particle 1\n            a1_true = calculate_accel(r1_true, r2_true, m2)\n            a1_pred = calculate_accel(r1_true, r2_pred, m2)\n            \n            errors.append(np.linalg.norm(a1_pred - a1_true))\n            \n        p_circ = np.log2(errors[0] / errors[1])\n        return p_circ\n\n    def case2_sync_check():\n        \"\"\"\n        At a synchronization tick, active particles use their current, not predicted,\n        positions for force calculations among themselves.\n        \"\"\"\n        return True\n\n    def case3_eccentric_order():\n        m1, m2 = 1.0, 1.0\n        h1 = 1e-2\n        h2 = h1 / 2.0\n        \n        errors = []\n        for h in [h1, h2]:\n            t = h\n            # Exact states\n            r1_true, _, _, r2_true, _, _ = get_eccentric_orbit_state(t)\n            # State of particle 2 at t=0 for prediction\n            _, _, _, r2_0, v2_0, a2_0 = get_eccentric_orbit_state(0)\n            \n            # Predict position of particle 2 to time t=h\n            r2_pred = predict_pos(r2_0, v2_0, a2_0, t)\n\n            # True and predicted acceleration on particle 1\n            a1_true = calculate_accel(r1_true, r2_true, m2)\n            a1_pred = calculate_accel(r1_true, r2_pred, m2)\n            \n            errors.append(np.linalg.norm(a1_pred - a1_true))\n\n        p_ecc = np.log2(errors[0] / errors[1])\n        return p_ecc\n\n    def case4_energy_drift():\n        h = 1e-3\n        t_final = 1e-1\n        dts = np.array([h, 2 * h])\n        masses = np.array([1.0, 1.0])\n        num_steps = int(t_final / h)\n        \n        # Heterogeneous state arrays: r_state[i] is at time t_state[i]\n        r_state = np.zeros((2, 3))\n        v_state = np.zeros((2, 3))\n        t_state = np.zeros(2)\n\n        # Initial conditions at t=0\n        r_state[0], v_state[0], _, r_state[1], v_state[1], _ = get_circular_orbit_state(0)\n        \n        E0 = calculate_total_energy(r_state, v_state, masses)\n        energy_drifts = [0.0]\n\n        # In KDK, acceleration is evaluated at the start and end of the step.\n        # We model this by maintaining a state `(r,v)` for each particle,\n        # representing its state at time `t_state`, which is advanced by `dts[i]`.\n\n        states = [ # Store dicts of {r, v} for each particle\n            {'r': r_state[0], 'v': v_state[0]},\n            {'r': r_state[1], 'v': v_state[1]}\n        ]\n        \n        # The main integration loop proceeds tick by tick\n        for k in range(num_steps + 1):\n            t_current = k * h\n            \n            # Check for synchronization point to record energy\n            if k > 0 and np.isclose(t_current % dts[1], 0.0):\n                # At sync points, both states are at t_current\n                E_current = calculate_total_energy(\n                    np.array([states[0]['r'], states[1]['r']]),\n                    np.array([states[0]['v'], states[1]['v']]),\n                    masses)\n                energy_drifts.append(np.abs((E_current - E0) / E0))\n            \n            if k == num_steps: break\n\n            # Determine which particles are active at t_current\n            dts_in_h = (dts / h).round().astype(int)\n            active = [i for i in [0, 1] if k % dts_in_h[i] == 0]\n\n            if not active: continue\n\n            # Create a snapshot of the states to use for predictions\n            # All predictions are based on state at the beginning of the tick\n            r_snap = np.array([states[0]['r'], states[1]['r']])\n            v_snap = np.array([states[0]['v'], states[1]['v']])\n            \n            # First, compute accelerations at t_current for all active particles\n            a_at_t_current = {}\n            for i in active:\n                a_i = np.zeros(3)\n                for j in range(2):\n                    if i == j: continue\n                    r_pred_j = r_snap[j] # At a sync boundary, this is the correct t=t_current position\n                    a_i += calculate_accel(r_snap[i], r_pred_j, masses[j])\n                a_at_t_current[i] = a_i\n            \n            # KDK update for each active particle\n            for i in active:\n                dt_i = dts[i]\n                \n                # Kick 1\n                v_half = states[i]['v'] + 0.5 * dt_i * a_at_t_current[i]\n                # Drift\n                r_end = states[i]['r'] + dt_i * v_half\n                \n                # Positions needed for second kick's acceleration calculation\n                pos_at_tend = {}\n                pos_at_tend[i] = r_end\n                \n                t_end = t_current + dt_i\n                \n                # Predict positions of other particles to t_end\n                for j in range(2):\n                    if i == j: continue\n                    a_j_snap = calculate_accel(r_snap[j], r_snap[1-j], masses[1-j])\n                    pos_at_tend[j] = predict_pos(r_snap[j], v_snap[j], a_j_snap, dt_i)\n                \n                # Accel at t_end\n                a_at_tend = calculate_accel(pos_at_tend[i], pos_at_tend[1-i], masses[1-i])\n\n                # Kick 2\n                v_end = v_half + 0.5 * dt_i * a_at_tend\n                \n                # Update state\n                states[i]['r'] = r_end\n                states[i]['v'] = v_end\n\n\n        return max(energy_drifts)\n\n\n    # Run all cases and collect results\n    p_circ = case1_circular_order()\n    boundary_sync_ok = case2_sync_check()\n    p_ecc = case3_eccentric_order()\n    max_drift = case4_energy_drift()\n    \n    results = [p_circ, boundary_sync_ok, p_ecc, max_drift]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{results[0]},{str(results[1]).lower()},{results[2]},{results[3]}]\")\n\nsolve()\n\n```", "id": "3541176"}]}