{"hands_on_practices": [{"introduction": "蛙跳积分格式（Kick-Drift-Kick, KDK）的强大之处在于其位置和动量在时间上交错更新的结构。然而，这也带来一个关键的实现问题：如果我们获得了在同一时刻 $t=0$ 的初始条件 $(q_0, p_0)$，我们该如何正确地开始积分？这个基础练习 [@problem_id:3538304] 将引导你通过理论推导，确定启动积分所需的正确“半步踢”，以确保该方法从第一步起就同时具有二阶精度和时间可逆性。", "problem": "考虑一个可分离的哈密顿系统，该系统代表了一个无碰撞引力$N$体模型，其哈密顿量为 $H(q,p)=T(p)+V(q)$，其中 $q \\in \\mathbb{R}^{d}$ 是位置，$p \\in \\mathbb{R}^{d}$ 是正则动量，$T$ 是仅依赖于 $p$ 的动能，$V$ 是仅依赖于 $q$ 的势能。设运动方程由哈密顿方程给出：$\\dot{q}=\\nabla_{p}T(p)$ 和 $\\dot{p}=-\\nabla_{q}V(q)$，并假设所有函数都足够光滑以使泰勒展开有效。\n\n您希望使用时间步长为 $\\Delta t > 0$ 的时间对称辛蛙跳格式（kick-drift-kick, KDK形式）来积分该系统。KDK 格式从 $t=0$ 时的 $(q_{0},p_{0})$ 开始演进，首先执行一个半步动量更新（踢），然后是一个整步位置更新（漂移），最后再执行一个半步动量更新（踢）。由于蛙跳格式使用交错动量，您必须仅使用 $(q_{0},p_{0})$ 和 $\\Delta t$ 来初始化一个半步动量 $p_{1/2}$，以满足以下条件：\n- 第一个漂移步产生的 $q_{1}$ 与精确解 $q(\\Delta t)$ 匹配，直到并包括 $\\Delta t^{2}$ 阶项（局部截断误差为 $\\mathcal{O}(\\Delta t^{3})$），并且\n- 整个方法在变换 $(q,p,\\Delta t)\\mapsto(q,-p,-\\Delta t)$ 下是时间可逆的。\n\n假设 $T$ 关于 $p$ 是二阶连续可微且严格凸的，因此 $\\nabla_{p}T$ 可逆，且其关于 $p$ 的雅可比矩阵等于海森矩阵 $D^{2}_{pp}T(p)$。设第一个漂移步通过 $q_{1}=q_{0}+\\Delta t\\,\\nabla_{p}T(p_{1/2})$ 使用初始化的 $p_{1/2}$。将该初始化参数化为 $p_{1/2}=p_{0}-c\\,\\Delta t\\,\\nabla_{q}V(q_{0})+\\mathcal{O}(\\Delta t^{2})$，其中 $c \\in \\mathbb{R}$ 是一个未知常数。\n\n从哈密顿方程和关于 $t=0$ 的泰勒展开式中，推导满足上述两个条件所需的常数 $c$ 的值，从而得到关于 $q_{0}$、$p_{0}$、$\\Delta t$ 和 $\\nabla_{q}V(q_{0})$ 的 $p_{1/2}$ 的唯一初始化公式，该公式确保了KDK方法从第一步起就具有二阶精度和时间可逆性。请将您的最终答案表示为 $p_{1/2}$ 的单个闭式解析表达式。无需进行数值计算。", "solution": "首先验证问题陈述，以确保其具有科学依据、问题定义良好且客观。\n\n### 步骤1：提取已知条件\n- **系统**：一个由 $H(q,p)=T(p)+V(q)$ 描述的可分离哈密顿系统。\n- **变量**：$q \\in \\mathbb{R}^{d}$ (位置)，$p \\in \\mathbb{R}^{d}$ (正则动量)。\n- **能量项**：$T(p)$ 是动能，$V(q)$ 是势能。假设所有函数都足够光滑。\n- **运动方程**：哈密顿方程为 $\\dot{q}=\\nabla_{p}T(p)$ 和 $\\dot{p}=-\\nabla_{q}V(q)$。\n- **积分格式**：时间步长为 $\\Delta t > 0$ 的时间对称辛蛙跳法，形式为踢-漂移-踢（KDK）。\n- **初始条件**：系统在 $t=0$ 时处于状态 $(q_{0},p_{0})$。\n- **任务**：仅使用 $(q_{0},p_{0})$ 和 $\\Delta t$ 确定半步动量 $p_{1/2}$ 的初始化公式。\n- **条件1 (精度)**：由 $q_{1}=q_{0}+\\Delta t\\,\\nabla_{p}T(p_{1/2})$ 给出的第一个漂移步必须产生一个位置 $q_{1}$，该位置与精确解 $q(\\Delta t)$ 匹配，局部截断误差为 $\\mathcal{O}(\\Delta t^{3})$。即 $q_{1} - q(\\Delta t) = \\mathcal{O}(\\Delta t^{3})$。\n- **条件2 (时间可逆性)**：整个积分方法在变换 $(q,p,\\Delta t)\\mapsto(q,-p,-\\Delta t)$ 下必须是时间可逆的。\n- **关于 $T(p)$ 的假设**：动能 $T$ 关于 $p$ 是二阶连续可微且严格凸的，这确保其海森矩阵 $D^{2}_{pp}T(p)$ 是一个定义良好且可逆的矩阵。\n- **参数化**：$p_{1/2}$ 的初始化被参数化为 $p_{1/2}=p_{0}-c\\,\\Delta t\\,\\nabla_{q}V(q_{0})+\\mathcal{O}(\\Delta t^{2})$，其中 $c \\in \\mathbb{R}$ 是一个待定常数。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题植根于经典力学（哈密顿形式）和数值分析（辛积分），这些是计算物理学和天体物理学中的标准和基础课题。\n- **问题定义良好**：问题陈述清晰，包含了所有必要信息。它要求一个特定的常数 $c$ 和一个满足明确定义的数学条件（精度和时间可逆性）的相应公式。\n- **客观性**：问题以精确的数学语言表述，没有任何主观性或歧义。\n\n该问题不违反任何无效标准。它是几何数值积分领域一个标准的、非平凡的推导。\n\n### 步骤3：结论与行动\n问题有效。下面是完整的、有理有据的解答。\n\n### 解题推导\n\n主要任务是找到满足给定精度要求的常数 $c$ 的值。这个值将定义 $p_{1/2}$ 的初始化公式。\n\n首先，我们确定精确位置 $q(\\Delta t)$ 在 $t=0$ 附近直到 $(\\Delta t)^2$ 阶项的泰勒级数展开。精确解根据哈密顿方程从初始状态 $(q_0, p_0)$ 演化。\n\n泰勒展开式为：\n$$q(\\Delta t) = q(0) + \\Delta t \\, \\dot{q}(0) + \\frac{(\\Delta t)^2}{2} \\ddot{q}(0) + \\mathcal{O}(\\Delta t^3)$$\n在 $t=0$ 时，我们有 $q(0) = q_0$ 和 $p(0) = p_0$。位置的一阶导数由哈密顿方程给出：\n$$\\dot{q}(t) = \\nabla_p T(p(t))$$\n在 $t=0$ 处求值：\n$$\\dot{q}(0) = \\nabla_p T(p_0)$$\n为了求二阶导数 $\\ddot{q}(0)$，我们对 $\\dot{q}(t)$ 关于时间求导，使用链式法则：\n$$\\ddot{q}(t) = \\frac{d}{dt} \\left( \\nabla_p T(p(t)) \\right) = D^2_{pp}T(p(t)) \\, \\dot{p}(t)$$\n其中 $D^2_{pp}T(p(t))$ 是 $T$ 关于 $p$ 的海森矩阵。动量的导数 $\\dot{p}(t)$ 也由哈密顿方程给出：\n$$\\dot{p}(t) = -\\nabla_q V(q(t))$$\n在 $t=0$ 处求值：\n$$\\dot{p}(0) = -\\nabla_q V(q_0)$$\n将此代入 $\\ddot{q}(0)$ 的表达式中：\n$$\\ddot{q}(0) = D^2_{pp}T(p_0) (-\\nabla_q V(q_0)) = -D^2_{pp}T(p_0) \\nabla_q V(q_0)$$\n现在，我们将这些导数代回 $q(\\Delta t)$ 的泰勒展开式中：\n$$q(\\Delta t) = q_0 + \\Delta t \\, \\nabla_p T(p_0) - \\frac{(\\Delta t)^2}{2} D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^3)$$\n\n接下来，我们分析数值格式第一步得到的位置 $q_1$。该格式使用基于初始化动量 $p_{1/2}$ 的漂移步：\n$$q_1 = q_0 + \\Delta t \\, \\nabla_p T(p_{1/2})$$\n动量 $p_{1/2}$ 由参数化公式给出：\n$$p_{1/2} = p_0 - c \\, \\Delta t \\, \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^2)$$\n为了找到一个与 $q(\\Delta t)$ 的展开式可比的 $q_1$ 表达式，我们将 $\\nabla_p T(p_{1/2})$ 在 $p_0$ 附近进行泰勒级数展开。令 $\\delta p = p_{1/2} - p_0 = -c \\, \\Delta t \\, \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^2)$。注意 $\\delta p$ 是 $\\mathcal{O}(\\Delta t)$ 阶的。\n$$\\nabla_p T(p_{1/2}) = \\nabla_p T(p_0 + \\delta p) = \\nabla_p T(p_0) + D^2_{pp}T(p_0) \\, \\delta p + \\mathcal{O}(||\\delta p||^2)$$\n代入 $\\delta p$ 的表达式：\n$$\\nabla_p T(p_{1/2}) = \\nabla_p T(p_0) + D^2_{pp}T(p_0) \\left( -c \\, \\Delta t \\, \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^2) \\right) + \\mathcal{O}(\\Delta t^2)$$\n$$\\nabla_p T(p_{1/2}) = \\nabla_p T(p_0) - c \\, \\Delta t \\, D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^2)$$\n现在，将此展开式代回 $q_1$ 的表达式中：\n$$q_1 = q_0 + \\Delta t \\left( \\nabla_p T(p_0) - c \\, \\Delta t \\, D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^2) \\right)$$\n$$q_1 = q_0 + \\Delta t \\, \\nabla_p T(p_0) - c \\, (\\Delta t)^2 \\, D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^3)$$\n\n精度条件要求 $q_1 = q(\\Delta t) + \\mathcal{O}(\\Delta t^3)$。我们比较两个推导出的展开式：\n精确解：$q(\\Delta t) = q_0 + \\Delta t \\, \\nabla_p T(p_0) - \\frac{1}{2} (\\Delta t)^2 D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^3)$\n数值解：$q_1 = q_0 + \\Delta t \\, \\nabla_p T(p_0) - c \\, (\\Delta t)^2 \\, D^2_{pp}T(p_0) \\nabla_q V(q_0) + \\mathcal{O}(\\Delta t^3)$\n$\\mathcal{O}(1)$ 和 $\\mathcal{O}(\\Delta t)$ 阶的项已经匹配。为了使展开式在 $(\\Delta t)^2$ 阶上一致，$(\\Delta t)^2$ 项的系数必须相等：\n$$-c \\, D^2_{pp}T(p_0) \\nabla_q V(q_0) = -\\frac{1}{2} D^2_{pp}T(p_0) \\nabla_q V(q_0)$$\n由于 $T(p)$ 是严格凸的，其海森矩阵 $D^2_{pp}T(p_0)$ 可逆。假设势能非平凡，即 $\\nabla_q V(q_0) \\neq 0$，我们可以得出结论：\n$$c = \\frac{1}{2}$$\n\n这个 $c$ 值满足精度条件。现在我们考虑时间可逆性条件。标准的 KDK 积分器是对应于势能 $V$（踢）和动能 $T$（漂移）下的流的算子的对称复合：$\\Phi_{\\Delta t} = \\phi_V^{\\Delta t/2} \\circ \\phi_T^{\\Delta t} \\circ \\phi_V^{\\Delta t/2}$。这种对称结构确保了该方法是时间可逆的，即对于变换 $S(q,p)=(q,-p)$，有 $\\Phi_{\\Delta t}^{-1} = S \\circ \\Phi_{\\Delta t} \\circ S$，前提是动能 $T(p)$ 是 $p$ 的偶函数。初始化步骤 $p_{1/2} = p_0 - c \\Delta t \\nabla_q V(q_0)$ 对应于第一个算子——半步踢 $\\phi_V^{c \\Delta t}$ 的作用。为了使整个格式成为对称的 KDK 积分器，这第一次踢必须是一个半步踢，即 $\\phi_V^{\\Delta t/2}$。这意味着 $c \\Delta t = \\Delta t / 2$，从而得到 $c = 1/2$。因此，精度和时间可逆性两个条件独立地导出了相同的 $c$ 值。\n\n当 $c=1/2$ 时，参数化公式 $p_{1/2}=p_{0}-c\\,\\Delta t\\,\\nabla_{q}V(q_{0})+\\mathcal{O}(\\Delta t^{2})$ 成为初始半步动量更新的确定公式。对于标准的 KDK 格式，高阶项为零，因此在算法定义的范围内，该唯一公式是精确的。\n\n$p_{1/2}$ 的唯一初始化公式为：\n$$p_{1/2} = p_0 - \\frac{1}{2} \\Delta t \\nabla_q V(q_0)$$", "answer": "$$\\boxed{p_{1/2} = p_{0} - \\frac{1}{2} \\Delta t \\nabla_{q} V(q_{0})}$$", "id": "3538304"}, {"introduction": "一个理论上正确的算法，只有当其代码实现也正确时才有价值。考虑到辛方法的精妙之处，我们如何验证编写的代码是否真正地保持了我们期望的辛结构？这个动手实践 [@problem_id:3538342] 将挑战你构建一个数值诊断工具，用于检验辛条件 $J^{\\top}\\Omega J = \\Omega$。通过这个过程，你将学会区分正确的KDK实现与一个有细微缺陷的非辛版本，这是计算物理中一项至关重要的技能。", "problem": "要求您设计并实现一种数值诊断方法，用于在随机相空间点上估计蛙跳（踢-漂移-踢）映射的量 $J^{\\top}\\Omega J - \\Omega$，并指定用于检测因实现错误导致的辛性丧失的容差。其背景是一个可分离的哈密顿系统，具有正则坐标 $(q,p)$ 和哈密顿量 $H(q,p) = T(p) + V(q)$，其中 $T(p)$ 仅依赖于 $p$，$V(q)$ 仅依赖于 $q$。正则辛形式是常数 $2\\times 2$ 矩阵\n$$\n\\Omega \\equiv \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}.\n$$\n蛙跳（踢-漂移-踢）格式通过三个顺序子步骤将 $(q,p)$ 推进一个时间步长 $h$：一个半步动量更新（“踢”），一个全步位置更新（“漂移”），以及另一个半步动量更新（“踢”）。该诊断方法必须：\n- 在随机选择的相空间点上，使用有限差分数值近似单步映射 $(q,p)\\mapsto (q',p')$ 的雅可比矩阵 $J$。\n- 通过 $S \\equiv J^{\\top}\\Omega J - \\Omega$ 评估辛性偏差，并汇总一个误差度量（例如，$S$ 的最大绝对值元素）。\n- 基于一组随机相空间样本的汇总误差度量，判断该映射是否在指定容差内是辛的。\n\n设计约束和基础：\n- 使用 Hamilton 方程 $dq/dt = \\partial H/\\partial p$ 和 $dp/dt = -\\partial H/\\partial q$ 以及 $H$ 的可分离性来证明蛙跳（踢-漂移-踢）子步骤的合理性。\n- 为了进行具体且可复现的测试，请使用简谐振子，其无量纲参数为 $m=1$ 和 $k=1$，即 $T(p)=\\tfrac{1}{2}p^2$ 和 $V(q)=\\tfrac{1}{2}q^2$。所有量都是无量纲的，不需要物理单位。\n- 在点 $(q,p)$ 处，使用中心有限差分来近似雅可比矩阵 $J$，其中每个坐标的微扰大小 $\\delta$ 由用户指定。对第 $i$ 个坐标，使用中心差分公式 $J_{:,i} \\approx \\big(F(x+\\delta e_i)-F(x-\\delta e_i)\\big)/(2\\delta)$，其中 $F$ 是单步映射，$e_i$ 是第 $i$ 个标准基向量。\n- 将一个点的辛性误差定义为 $\\|S\\|_{\\infty}$，其中 $\\|\\cdot\\|_{\\infty}$ 表示最大绝对值元素范数。\n- 通过取所有样本中的最大误差来对多个随机样本进行汇总。\n\n容差指定：\n- 有限差分雅可比矩阵估计引入了两个主要误差来源：截断误差 $O(\\delta^2)$ 和浮点舍入误差放大 $O(\\epsilon_{\\text{mach}}/\\delta)$，其中 $\\epsilon_{\\text{mach}}$ 是机器精度。对于此诊断，一个在典型双精度场景下稳健的实用检测阈值是 $\\tau(\\delta) \\equiv 10\\,\\delta^2 + 10^{-8}$。\n- 如果样本集上的汇总误差 $\\max\\|S\\|_{\\infty}$ 小于或等于 $\\tau(\\delta)$，则该诊断应将实现分类为辛的。\n\n随机抽样：\n- 为了保证可复现性，使用固定的随机种子从区间 $[-1,1]$ 中独立且均匀地抽取 $(q,p)$。\n\n待检测的实现错误：\n- 至少包含一个有缺陷的蛙跳变体，该变体在漂移子步骤中使用踢前的动量 $p$ 而不是半步踢后的动量 $p_{1/2}$；这种不一致性破坏了辛性，应能被该诊断方法检测到。\n\n测试套件：\n- 实现四个测试用例，每个用例由一个元组 $(\\text{scheme}, h, \\delta, N)$ 指定：\n    1. $(\\text{KDK}, 0.1, 10^{-6}, 256)$: 正确的踢-漂移-踢格式，适中的时间步长和有限差分尺度。\n    2. $(\\text{KDK}, 1.0, 10^{-6}, 128)$: 正确的踢-漂移-踢格式，使用较大的时间步长。\n    3. $(\\text{BUG1}, 0.1, 10^{-6}, 256)$: 有缺陷的格式，其中漂移步骤使用 $p$ 而不是 $p_{1/2}$。\n    4. $(\\text{KDK}, 0.1, 10^{-12}, 64)$: 正确的格式，但使用非常小的有限差分尺度，以说明由于舍入误差放大导致的失效。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含每个测试用例的诊断决策，格式为方括号内的逗号分隔列表，每个条目是一个布尔值，如果汇总误差 $\\le \\tau(\\delta)$ 则为 $\\text{True}$，否则为 $\\text{False}$。例如：$[\\text{True},\\text{True},\\text{False},\\text{False}]$。", "solution": "任务是设计一种数值诊断方法，以验证一个可分离哈密顿系统的数值积分器的辛性。一个推进相空间坐标 $x = (q,p)$ 的映射 $\\Phi$ 被定义为辛映射，如果其雅可比矩阵 $J = \\partial \\Phi / \\partial x$ 保持正则辛形式 $\\Omega$ 不变。这由关系式 $J^{\\top}\\Omega J = \\Omega$ 表达。我们的诊断方法将数值估计偏差矩阵 $S \\equiv J^{\\top}\\Omega J - \\Omega$，并检查其大小是否在与数值精度和近似误差相符的容差范围内。\n\n所考虑的物理系统是简谐振子，由可分离的哈密顿量 $H(q,p) = T(p) + V(q)$ 描述，其中动能为 $T(p) = \\frac{1}{2}p^2$，势能为 $V(q) = \\frac{1}{2}q^2$。对于这个问题，我们使用无量纲参数，使得质量 $m=1$，弹簧常数 $k=1$。系统的动力学由 Hamilton 方程决定：\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p} = p\n$$\n$$\n\\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q} = -q\n$$\n\n待测试的积分器是二阶蛙跳格式，采用其踢-漂移-踢（KDK）形式。该方法是几何积分器的一个例子，旨在保持底层物理系统的几何特性，包括辛性。$H$ 的可分离性允许进行算子分裂，其中一个时间步长 $h$ 内的完全演化可以通过一个仅涉及 $T(p)$ 或 $V(q)$ 的对称操作序列来近似。从 $(q_n, p_n)$ 到 $(q_{n+1}, p_{n+1})$ 的单步映射由三个子步骤给出：\n\n1.  **踢（动量更新，半步 $\\Delta t = h/2$）：** 系统在势能 $V(q)$ 下演化。动量使用力 $F(q) = -\\partial V/\\partial q = -q$ 进行更新。\n    $$p_{n+1/2} = p_n + \\frac{h}{2} F(q_n) = p_n - \\frac{h}{2} q_n$$\n2.  **漂移（位置更新，全步 $\\Delta t = h$）：** 系统在动能 $T(p)$ 下演化。位置使用速度 $v(p) = \\partial T/\\partial p = p$ 进行更新。此步骤必须使用经过半步更新的动量 $p_{n+1/2}$。\n    $$q_{n+1} = q_n + h \\cdot v(p_{n+1/2}) = q_n + h \\cdot p_{n+1/2}$$\n3.  **踢（动量更新，半步 $\\Delta t = h/2$）：** 执行第二次动量更新，使用在新位置 $q_{n+1}$ 处计算的力。\n    $$p_{n+1} = p_{n+1/2} + \\frac{h}{2} F(q_{n+1}) = p_{n+1/2} - \\frac{h}{2} q_{n+1}$$\n\n这种对称结构确保了最终的映射是精确辛的。我们还考虑一个有缺陷的变体（BUG1），其中漂移步骤错误地使用了初始动量 $p_n$ 而不是 $p_{n+1/2}$：$q_{n+1} = q_n + h \\cdot p_n$。这个看似微小的错误破坏了积分器的对称性，并导致一个非辛映射。\n\n我们诊断方法的核心是单步映射（记为 $F(x)$）的雅可比矩阵 $J$ 的数值近似。由于对于复杂系统，$J$ 的解析表达式通常是不可用的，我们采用二阶中心有限差分公式。对于雅可比矩阵的第 $i$ 列，对应于相空间向量 $x=(q,p)$ 的第 $i$ 个坐标的微扰，我们有：\n$$\nJ_{:,i} \\approx \\frac{F(x + \\delta e_i) - F(x - \\delta e_i)}{2\\delta}\n$$\n其中 $e_i$ 是第 $i$ 个标准基向量，$\\delta$ 是一个小的微扰。这种近似引入了量级为 $O(\\delta^2)$ 的截断误差。\n\n利用数值估计的雅可比矩阵 $\\tilde{J}$，我们计算偏差矩阵 $\\tilde{S} = \\tilde{J}^{\\top}\\Omega \\tilde{J} - \\Omega$。对于正确的 KDK 格式，真实映射是辛的，因此 $\\tilde{S}$ 中唯一的误差来源应该是雅可比矩阵近似的截断误差，即 $\\|\\tilde{S}\\|_{\\infty} = O(\\delta^2)$。然而，对于有缺陷的 BUG1 格式，映射本身不是辛的，导致 $S$ 中存在一个内在误差，该误差在 $\\delta \\to 0$ 时不会消失。我们会发现这个内在误差的量级为 $O(h^2)$。第二个数值误差来源是浮点舍入，当 $\\delta$ 非常小时，它会变得显著。在有限差分分子中，两个几乎相等的数相减，再除以一个非常小的 $\\delta$，会放大舍入误差，贡献一个量级为 $O(\\epsilon_{\\text{mach}}/\\delta)$ 的项，其中 $\\epsilon_{\\text{mach}}$ 是机器精度（对于双精度，约为 $10^{-16}$）。\n\n该诊断方法将这些考虑因素结合成一个单一的决策规则。我们在相空间中的一组 $N$ 个随机点上计算偏差矩阵的最大绝对值元素 $\\|S\\|_{\\infty}$，并取其最大值。如果这个汇总误差小于或等于指定的容差 $\\tau(\\delta) = 10\\delta^2 + 10^{-8}$，则该实现被分类为正确的辛实现。这个公式为预期的截断误差提供了一个上限（$10\\delta^2$），并为容纳舍入误差提供了一个下限（$10^{-8}$），特别是对于 $\\delta$ 值在 $10^{-8}$ 附近时，这两个误差源是相当的。\n\n测试套件将检查四种情况：\n1.  **正确的 KDK，小 $h$**：诊断应该通过，因为测得的误差 $O(\\delta^2) = O((10^{-6})^2) = O(10^{-12})$ 将远低于容差 $\\tau \\approx 10^{-8}$。\n2.  **正确的 KDK，大 $h$**：结果应该相同。无论步长 $h$ 如何，该映射都是精确辛的，因此诊断误差仅取决于 $\\delta$。\n3.  **有缺陷的 BUG1**：诊断应该失败。其内在的非辛性引入了一个大小为 $h^2/2 = (0.1)^2/2 = 0.005$ 的误差，这远大于容差 $\\tau \\approx 10^{-8}$。\n4.  **正确的 KDK，非常小的 $\\delta$**：诊断应该失败。舍入误差放大，$O(\\epsilon_{\\text{mach}}/\\delta) \\approx 10^{-16}/10^{-12} = 10^{-4}$，将占主导地位并超过容差 $\\tau \\approx 10^{-8}$。这表明当 $\\delta$ 选择不当时，数值诊断方法本身存在局限性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the symplecticity diagnostic on a set of test cases.\n    \"\"\"\n    # Define the canonical symplectic form matrix Omega\n    OMEGA = np.array([[0, 1], [-1, 0]], dtype=np.float64)\n\n    # --- Integrator Maps ---\n\n    def kdk_step(x: np.ndarray, h: float) -> np.ndarray:\n        \"\"\"\n        Performs one step of the Kick-Drift-Kick (KDK) Leapfrog integrator\n        for the simple harmonic oscillator H = 0.5*p^2 + 0.5*q^2.\n\n        Args:\n            x: Phase-space vector [q, p].\n            h: Time step.\n\n        Returns:\n            New phase-space vector [q_new, p_new].\n        \"\"\"\n        q, p = x\n        # Force F(q) = -dV/dq = -q\n        \n        # Kick 1 (half step)\n        p_half = p - (h / 2.0) * q\n        \n        # Drift (full step) using updated momentum\n        q_new = q + h * p_half\n        \n        # Kick 2 (half step) using new position\n        p_new = p_half - (h / 2.0) * q_new\n        \n        return np.array([q_new, p_new], dtype=np.float64)\n\n    def buggy_step(x: np.ndarray, h: float) -> np.ndarray:\n        \"\"\"\n        Performs one step of a flawed Leapfrog integrator where the drift\n        step incorrectly uses the initial momentum.\n\n        Args:\n            x: Phase-space vector [q, p].\n            h: Time step.\n\n        Returns:\n            New phase-space vector [q_new, p_new].\n        \"\"\"\n        q, p = x\n        \n        # Kick 1 (half step)\n        p_half = p - (h / 2.0) * q\n        \n        # Drift (full step) - THE BUG: uses initial momentum p instead of p_half\n        q_new = q + h * p\n        \n        # Kick 2 (half step)\n        p_new = p_half - (h / 2.0) * q_new\n        \n        return np.array([q_new, p_new], dtype=np.float64)\n\n    # --- Diagnostic Tools ---\n\n    def compute_jacobian(map_func, x: np.ndarray, h: float, delta: float) -> np.ndarray:\n        \"\"\"\n        Computes the Jacobian of a map function using central finite differences.\n\n        Args:\n            map_func: The one-step map function, e.g., kdk_step.\n            x: The phase-space point [q, p] at which to evaluate the Jacobian.\n            h: The time step for the map function.\n            delta: The perturbation size for the finite difference.\n\n        Returns:\n            The 2x2 Jacobian matrix.\n        \"\"\"\n        dim = len(x)\n        J = np.zeros((dim, dim), dtype=np.float64)\n        \n        for i in range(dim):\n            # Create perturbation vector e_i * delta\n            perturbation = np.zeros(dim, dtype=np.float64)\n            perturbation[i] = delta\n            \n            x_plus = x + perturbation\n            x_minus = x - perturbation\n            \n            f_plus = map_func(x_plus, h)\n            f_minus = map_func(x_minus, h)\n            \n            # Central difference formula for the i-th column of the Jacobian\n            J[:, i] = (f_plus - f_minus) / (2.0 * delta)\n            \n        return J\n\n    def check_symplecticity(scheme_name: str, h: float, delta: float, N: int) -> bool:\n        \"\"\"\n        Runs the full diagnostic for a given scheme and parameters.\n\n        Args:\n            scheme_name: Identifier for the scheme ('KDK' or 'BUG1').\n            h: Time step for the integrator.\n            delta: Perturbation for finite-difference Jacobian.\n            N: Number of random samples to test.\n\n        Returns:\n            True if the scheme is classified as symplectic, False otherwise.\n        \"\"\"\n        if scheme_name == 'KDK':\n            map_func = kdk_step\n        elif scheme_name == 'BUG1':\n            map_func = buggy_step\n        else:\n            raise ValueError(f\"Unknown scheme: {scheme_name}\")\n\n        # Fixed seed for reproducibility\n        rng = np.random.default_rng(42)\n        \n        # Generate N random phase-space points (q, p) in [-1, 1] x [-1, 1]\n        samples = rng.uniform(low=-1.0, high=1.0, size=(N, 2))\n        \n        max_S_norm = 0.0\n        \n        for x_point in samples:\n            # 1. Compute numerical Jacobian J\n            J = compute_jacobian(map_func, x_point, h, delta)\n            \n            # 2. Compute the deviation matrix S = J^T Omega J - Omega\n            S = J.T @ OMEGA @ J - OMEGA\n            \n            # 3. Compute the point-wise error ||S||_inf (max absolute entry)\n            s_norm_inf = np.max(np.abs(S))\n            \n            # 4. Aggregate by taking the maximum error found so far\n            if s_norm_inf > max_S_norm:\n                max_S_norm = s_norm_inf\n        \n        # 5. Calculate the tolerance tau(delta)\n        tolerance = 10.0 * delta**2 + 1e-8\n        \n        # 6. Classify based on the tolerance\n        return max_S_norm = tolerance\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('KDK', 0.1, 1e-6, 256),\n        ('KDK', 1.0, 1e-6, 128),\n        ('BUG1', 0.1, 1e-6, 256),\n        ('KDK', 0.1, 1e-12, 64)\n    ]\n\n    results = []\n    for case in test_cases:\n        scheme, h, delta, N = case\n        is_symplectic = check_symplecticity(scheme, h, delta, N)\n        results.append(str(is_symplectic))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3538342"}, {"introduction": "在精确算术下，辛积分器是完美时间可逆的，这一性质与其出色的长期稳定性密切相关。然而，在真实的计算机上，有限精度的浮点运算会引入微小的舍入误差，从而打破这种完美的对称性。这最后一个实践 [@problem_id:3538292] 将通过一个数值实验，来精确量化这种可逆性的损失，并揭示舍入误差是如何随着积分步数的变化而累积的。", "problem": "实现一个程序，用以量化由辛蛙跳格式积分的一维汉密尔顿系统中，因浮点舍入导致的时间可逆性损失。该物理系统是一个简谐振子，其无量纲哈密顿量由 $H(x,v)=\\tfrac{1}{2}v^{2}+\\tfrac{1}{2}x^{2}$ 给出，其中 $x$ 是位置，$v$ 是速度。运动方程为 $dx/dt=v$ 和 $dv/dt=a(x)$，其中 $a(x)=-x$。将要使用的积分器是“踢-漂移-踢”（kick-drift-kick）组合的蛙跳格式：其过程为，首先根据当前位置 $x$ 的加速度对速度 $v$ 进行半步更新，接着利用更新后的速度对位置 $x$ 进行整步更新，最后根据新位置 $x$ 的加速度对速度 $v$ 完成另半步更新。在精确算术中，此映射是时间可逆的，即以步长 $\\Delta t$ 前进 $N$ 步，再以步长 $-\\Delta t$ 后退 $N$ 步，将精确地返回初始状态。在浮点算术中，舍入误差会破坏完美的可逆性，并产生非零的往返状态误差。\n\n从该汉密尔顿系统的基本运动定律和蛙跳组合的定义出发，用双精度算术实现以下过程。设初始状态为 $x_{0}=1.234567890123456$ 和 $v_{0}=-0.987654321098765$，并设机器ε为 $\\epsilon_{\\mathrm{mach}}$，其定义为在浮点格式中 $1$ 与下一个可表示的更大数之间的距离（对于双精度，这由标准库中64位二进制浮点数的机器ε常量给出）。将步长为 $\\Delta t$ 的 $N$ 次蛙跳步骤后的前向-后向往返误差定义为\n$$\nE(N,\\Delta t)=\\sqrt{\\left(x_{\\mathrm{fb}}-x_{0}\\right)^{2}+\\left(v_{\\mathrm{fb}}-v_{0}\\right)^{2}},\n$$\n其中 $\\left(x_{\\mathrm{fb}},v_{\\mathrm{fb}}\\right)$ 是通过执行 $N$ 次步长为 $\\Delta t$ 的前向“踢-漂移-踢”步骤，并紧接着执行 $N$ 次步长为 $-\\Delta t$ 的后向“踢-漂移-踢”步骤得到的。\n\n您的程序必须通过在对数坐标轴上使用自然对数拟合标度指数来计算以下诊断量：\n\n- 对于固定的 $\\Delta t=\\;10^{-1}$ 和一组步数 $N\\in\\{10,30,100,300,1000,3000,10000\\}$，通过对 $\\ln E$ 与 $\\ln N$ 进行最小二乘线性拟合，估计标度关系 $E(N,\\Delta t)\\propto N^{\\alpha_{N}}$ 中的指数 $\\alpha_{N}$。此外，计算无量纲前置因子 $C_{N}$，其定义为在同一组 $N$ 上，归一化量 $E(N,\\Delta t)/\\left(\\epsilon_{\\mathrm{mach}}\\,N^{\\alpha_{N}}\\right)$ 的中位数。\n\n- 对于固定的 $N=50000$ 和一组步长 $\\Delta t\\in\\{10^{-4},3\\times 10^{-4},10^{-3},3\\times 10^{-3},10^{-2}\\}$，通过对 $\\ln E$ 与 $\\ln \\Delta t$ 进行最小二乘线性拟合，估计标度关系 $E(N,\\Delta t)\\propto \\Delta t^{\\beta_{\\Delta t}}$ 中的指数 $\\beta_{\\Delta t}$。\n\n- 作为边界条件检查，验证当 $\\Delta t=10^{-1}$ 时 $E(0,\\Delta t)=0$，并将此结果报告为布尔值。\n\n- 作为小步长合理性检查，验证当 $\\Delta t=10^{-12}$ 和 $N=1000$ 时，往返误差满足 $E(N,\\Delta t)\\leq 1000\\,\\epsilon_{\\mathrm{mach}}$，并将此结果报告为布尔值。\n\n所有计算均在无量纲单位下进行。不使用角度。最终输出格式必须是单行，包含一个逗号分隔的Python风格列表，按顺序包含以下五个条目：$[\\alpha_{N},\\beta_{\\Delta t},C_{N},\\text{boundary\\_check},\\text{small\\_step\\_check}]$，其中 $\\alpha_{N}$、$\\beta_{\\Delta t}$ 和 $C_{N}$ 是实数，两个检查是布尔值。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[0.5,0.0,1.2,\\mathrm{True},\\mathrm{True}]$）。此单行是唯一的输出，并且必须在不读取任何输入的情况下生成。\n\n程序要使用的测试套件：\n- 对于 $N$-标度拟合：$\\Delta t=10^{-1}$ 和 $N\\in\\{10,30,100,300,1000,3000,10000\\}$。\n- 对于 $\\Delta t$-标度拟合：$N=50000$ 和 $\\Delta t\\in\\{10^{-4},3\\times 10^{-4},10^{-3},3\\times 10^{-3},10^{-2}\\}$。\n- 边界条件检查：$N=0$ 和 $\\Delta t=10^{-1}$。\n- 小步长合理性检查：$N=1000$ 和 $\\Delta t=10^{-12}$。\n\n预期的输出类型是一个包含三个浮点数和两个布尔值的列表。不允许有其他输出。", "solution": "问题陈述已经过严格验证，并被确定为是合理的。它在科学上基于汉密尔顿力学和数值分析的原理，问题定义明确，指令清晰完整，并且计算上是可行的。其目标是实现一个数值实验，以量化辛积分器中因浮点运算导致的时间可逆性损失。\n\n解决方案的步骤是：首先定义物理系统和数值积分方案，然后实现前向-后向误差测量协议，最后执行指定的标度分析和检查。\n\n**1. 物理系统：简谐振子**\n\n所考虑的系统是一个一维简谐振子，这是物理学中的一个基本模型。其状态由位置 $x$ 和速度 $v$ 描述。系统的总能量由哈密顿量 $H(x, v)$ 给出，它是动能和势能的总和：\n$$\nH(x,v) = \\frac{1}{2}v^{2} + \\frac{1}{2}x^{2}\n$$\n在这种无量纲形式中，质量和弹簧常数均为1（$m=1$, $k=1$）。系统的演化由哈密顿运动方程决定：\n$$\n\\frac{dx}{dt} = \\frac{\\partial H}{\\partial v} = v\n$$\n$$\n\\frac{dv}{dt} = -\\frac{\\partial H}{\\partial x} = -x\n$$\n第二个方程给出了加速度 $a(x) = -x$。系统的初始状态指定为 $(x_0, v_0)$，其中 $x_{0}=1.234567890123456$ 且 $v_{0}=-0.987654321098765$。\n\n**2. 数值积分器：“踢-漂移-踢”（KDK）蛙跳格式**\n\n辛积分器是一类用于哈密尔顿系统的数值方法，其设计旨在保持相空间体积元，这一特性使其具有出色的长期能量守恒性。蛙跳法是一种广泛使用的二阶辛积分器。本问题指定使用其“踢-漂移-踢”（KDK）变体。\n\n单个积分步骤通过三个连续操作，将状态从时间 $t_n$ 的 $(x_n, v_n)$推进到时间 $t_{n+1} = t_n + \\Delta t$ 的 $(x_{n+1}, v_{n+1})$：\n\n1.  **踢（半步）**：使用当前位置 $x_n$ 处的加速度，对速度进行半步更新。\n    $$\n    v_{n+1/2} = v_n + a(x_n) \\frac{\\Delta t}{2}\n    $$\n2.  **漂移（全步）**：使用新的半步速度 $v_{n+1/2}$，对位置进行全步更新。\n    $$\n    x_{n+1} = x_n + v_{n+1/2} \\Delta t\n    $$\n3.  **踢（半步）**：使用新位置 $x_{n+1}$ 处的加速度，对速度进行剩余的半步更新。\n    $$\n    v_{n+1} = v_{n+1/2} + a(x_{n+1}) \\frac{\\Delta t}{2}\n    $$\n代入 $a(x)=-x$，此问题的具体更新规则为：\n$$\nv_{n+1/2} = v_n - x_n \\frac{\\Delta t}{2}\n$$\n$$\nx_{n+1} = x_n + v_{n+1/2} \\Delta t\n$$\n$$\nv_{n+1} = v_{n+1/2} - x_{n+1} \\frac{\\Delta t}{2}\n$$\n\n**3. 量化时间可逆性误差**\n\n该积分器的一个关键特性是，在精确算术中从 $(x_n, v_n)$ 到 $(x_{n+1}, v_{n+1})$ 的映射是时间可逆的。这意味着以步长 $\\Delta t$ 前进 $N$ 步，然后以步长 $-\\Delta t$ 后退 $N$ 步，将完美地恢复初始状态。然而，在有限精度的浮点算术中，每次运算都会累积微小的舍入误差，从而打破这种完美的可逆性。\n\n程序通过计算往返误差来量化这种被破坏的可逆性。从 $(x_0, v_0)$ 开始：\n1.  以步长 $\\Delta t$ 执行 $N$ 次前向步骤。\n2.  从所得状态开始，使用步长 $-\\Delta t$ 执行 $N$ 次后向步骤。\n3.  最终状态记为 $(x_{\\mathrm{fb}}, v_{\\mathrm{fb}})$。\n\n往返误差 $E(N, \\Delta t)$ 是相空间中初始状态与最终状态之间的欧几里得距离：\n$$\nE(N,\\Delta t)=\\sqrt{\\left(x_{\\mathrm{fb}}-x_{0}\\right)^{2}+\\left(v_{\\mathrm{fb}}-v_{0}\\right)^{2}}\n$$\n计算使用标准的双精度（64位）浮点数进行。舍入误差的特征尺度由机器ε $\\epsilon_{\\mathrm{mach}}$ 给出，它是满足 $1.0 + \\epsilon_{\\mathrm{mach}} \\neq 1.0$ 的最小数字。\n\n**4. 误差标度分析与检查**\n\n程序实现了所要求的四项具体分析：\n\n- **$N$-标度分析**：对于固定的步长 $\\Delta t = 10^{-1}$ 和一系列步数 $N \\in \\{10, 30, 100, 300, 1000, 3000, 10000\\}$，我们将误差建模为 $E(N, \\Delta t) \\propto N^{\\alpha_N}$。取自然对数得到 $\\ln E = \\alpha_N \\ln N + \\text{常数}$。通过对 $(\\ln N, \\ln E)$ 数据点进行最小二乘线性拟合求得斜率，从而确定指数 $\\alpha_N$。然后，无量纲前置因子 $C_N$ 计算为在 $N$ 的集合上 $E(N, \\Delta t) / (\\epsilon_{\\mathrm{mach}} N^{\\alpha_N})$ 值的中位数。这种归一化将观测到的误差与算术的基本精度和步数联系起来。\n\n- **$\\Delta t$-标度分析**：对于固定的步数 $N = 50000$ 和一系列步长 $\\Delta t \\in \\{10^{-4}, 3 \\times 10^{-4}, 10^{-3}, 3 \\times 10^{-3}, 10^{-2}\\}$，我们将误差建模为 $E(N, \\Delta t) \\propto \\Delta t^{\\beta_{\\Delta t}}$。类似地，$\\beta_{\\Delta t}$ 通过对 $(\\ln \\Delta t, \\ln E)$ 数据进行最小二乘线性拟合的斜率求得。这旨在研究步长本身如何影响舍入误差的累积。\n\n- **边界条件检查**：对 $\\Delta t = 10^{-1}$ 检查 $N=0$ 步的情况。零步数意味着状态不应改变，因此 $(x_{\\mathrm{fb}}, v_{\\mathrm{fb}})$ 必须与 $(x_0, v_0)$ 完全相同，且误差 $E(0, \\Delta t)$ 必须精确为 $0$。一个布尔值将报告条件 $E(0, 10^{-1}) = 0$ 是否成立。\n\n- **小步长合理性检查**：对于一个非常小的步长 $\\Delta t=10^{-12}$ 和 $N=1000$ 步，将舍入误差与一个合理的上界进行比较。在这种情况下，截断误差可以忽略不计，预计舍入误差将占主导地位。该检查验证计算出的误差 $E(1000, 10^{-12})$ 是否小于或等于 $1000 \\, \\epsilon_{\\mathrm{mach}}$。\n\n该实现封装了这一逻辑，执行数值模拟和后续的数据分析，以生成所需的五个诊断值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\ndef solve():\n    \"\"\"\n    Computes diagnostics for the time-reversibility error of a leapfrog integrator\n    applied to a simple harmonic oscillator.\n    \"\"\"\n\n    # --- Problem Setup ---\n    \n    # Initial conditions as specified\n    x0 = 1.234567890123456\n    v0 = -0.987654321098765\n    \n    # Machine epsilon for double precision (64-bit) float\n    eps_mach = sys.float_info.epsilon\n\n    # Acceleration function for H = 0.5*v^2 + 0.5*x^2, so a = -dH/dx = -x\n    def acceleration(x):\n        return -x\n\n    # Kick-Drift-Kick (KDK) leapfrog integrator step\n    def kdk_step(x, v, dt):\n        \"\"\"Advances the state (x, v) by a single KDK step of size dt.\"\"\"\n        v_half = v + acceleration(x) * (dt / 2.0)\n        x_new = x + v_half * dt\n        v_new = v_half + acceleration(x_new) * (dt / 2.0)\n        return x_new, v_new\n\n    # Function to compute the forward-backward round-trip error E(N, dt)\n    def compute_error(N, dt):\n        \"\"\"\n        Calculates the round-trip error after N forward steps and N backward steps.\n        \"\"\"\n        # The boundary case of N=0 means no steps are taken.\n        if N == 0:\n            return 0.0\n\n        # Start from the initial state\n        x, v = x0, v0\n\n        # Forward integration: N steps with dt\n        for _ in range(N):\n            x, v = kdk_step(x, v, dt)\n\n        # Backward integration: N steps with -dt from the final forward state\n        for _ in range(N):\n            x, v = kdk_step(x, v, -dt)\n        \n        # The final state after the round trip is (x_fb, v_fb)\n        x_fb, v_fb = x, v\n        \n        # Calculate the Euclidean error in phase space\n        error = np.sqrt((x_fb - x0)**2 + (v_fb - v0)**2)\n        return error\n\n    # --- Task 1: N-scaling analysis ---\n    dt_for_N_scaling = 1e-1\n    N_values = np.array([10, 30, 100, 300, 1000, 3000, 10000], dtype=float)\n    \n    errors_for_N = np.array([compute_error(int(n), dt_for_N_scaling) for n in N_values])\n    \n    # Perform a linear least-squares fit of log(E) vs log(N) to find the slope alpha_N\n    log_N = np.log(N_values)\n    log_E_N = np.log(errors_for_N)\n    alpha_N, _ = np.polyfit(log_N, log_E_N, 1)\n\n    # Compute the dimensionless prefactor C_N\n    prefactors = errors_for_N / (eps_mach * (N_values ** alpha_N))\n    C_N = np.median(prefactors)\n\n    # --- Task 2: dt-scaling analysis ---\n    N_for_dt_scaling = 50000\n    dt_values = np.array([1e-4, 3e-4, 1e-3, 3e-3, 1e-2], dtype=float)\n\n    errors_for_dt = np.array([compute_error(N_for_dt_scaling, dt) for dt in dt_values])\n\n    # Perform a linear least-squares fit of log(E) vs log(dt) to find the slope beta_dt\n    log_dt = np.log(dt_values)\n    log_E_dt = np.log(errors_for_dt)\n    beta_dt, _ = np.polyfit(log_dt, log_E_dt, 1)\n    \n    # --- Task 3: Boundary condition check ---\n    boundary_check = (compute_error(0, 1e-1) == 0.0)\n\n    # --- Task 4: Small-step sanity check ---\n    error_small_step = compute_error(1000, 1e-12)\n    small_step_check = (error_small_step = 1000 * eps_mach)\n\n    # --- Final Output Generation ---\n    results = [alpha_N, beta_dt, C_N, boundary_check, small_step_check]\n    \n    # Format the output as a single-line string representation of a list\n    # e.g., \"[0.501,0.012,1.234,True,True]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3538292"}]}