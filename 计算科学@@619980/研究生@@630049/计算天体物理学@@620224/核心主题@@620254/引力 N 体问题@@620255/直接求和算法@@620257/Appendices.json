{"hands_on_practices": [{"introduction": "在构建任何$N$体模拟器时，首要任务是验证其核心力计算的正确性。一个基本且强大的方法是检验系统总动量的守恒性，这直接源于牛顿第三定律。本实践将指导您设计一个数值实验，通过将模拟的质心运动与其理论上的惯性轨迹进行比较，来定量地验证力求和算法的正确性，这是一种至关重要的“健全性检查”和调试技术。[@problem_id:3508414]", "problem": "您的任务是设计并实现一个直接求和引力 $N$ 体积分器，用于定量检验系统质心运动的守恒性，以此作为力求和算法正确性的健全性检查。从 Newton 运动定律和质心的定义出发，并仅考虑内部引力相互作用。以此为基本依据，推导出仅受内力作用的封闭系统其质心进行惯性运动的结论，并利用该理论结果为数值模拟定义一个可测量的偏差。您的程序必须直接实现两两之间的力计算（不使用树形码或多极展开）、一个时间积分器，以及一个将模拟的质心轨迹与预期惯性轨迹进行比较的诊断工具。\n\n物理模型为带有 Plummer 软化的牛顿引力，其中作用于粒子 $i$ 的总引力加速度由粒子 $j$ 基于软化的牛顿两两作用定律构建，并对所有 $j\\neq i$ 的粒子求和。使用国际单位制（SI）中的引力常数 $G$，所有距离以米表示，质量以千克表示，时间以秒表示。\n\n您的算法必须实现两种力累积模式：\n- 一种正确的对称两两累积模式，该模式对每个相互作用对强制执行大小相等、方向相反的贡献，与 Newton 第三定律保持一致。\n- 一种微扰模式，通过一个微小的无量纲参数 $\\eta$ 故意违反作用-反作用对称性，以模拟存在错误的力求和过程。在此模式下，对于每一个无序对 $\\{i,j\\}$，该粒子对粒子 $i$ 加速度的贡献乘以 $(1+\\eta)$，对粒子 $j$ 加速度的贡献乘以 $(1-\\eta)$。\n\n时间积分必须使用辛蛙跳格式。从时间 $t=0$ 时的给定位置和速度开始初始化，并以均匀的时间步长 $\\Delta t$ 推进 $n_{\\mathrm{steps}}$ 步。在每一步，计算系统的质心位置 $\\mathbf{R}_{\\mathrm{cm}}(t)$，并将其与根据初始质心位置 $\\mathbf{R}_{\\mathrm{cm}}(0)$ 和初始质心速度 $\\mathbf{V}_{\\mathrm{cm}}(0)$ 预测的惯性参考轨迹进行比较。将时间 $t$ 的偏差定义为模拟质心位置与惯性参考质心位置之间向量差的欧几里得范数。对于每个测试用例，您的程序必须报告整个模拟时间内的最大偏差。\n\n所有输出必须以 SI 单位报告。最大偏差必须以米表示。对于任何向量运算，隐式使用弧度；不直接需要角度。您的程序必须将每个报告值格式化为具有 6 位有效数字的科学记数法十进制浮点数。\n\n测试套件。实现以下四个测试用例；对于每个用例，计算系统质心与其预期惯性轨迹的最大偏差。所有用例均使用引力常数 $G=6.67430\\times 10^{-11}\\ \\mathrm{m^{3}\\ kg^{-1}\\ s^{-2}}$ 和每个用例提供的 Plummer 软化长度 $\\epsilon$。\n\n- 用例 1（正常路径，正确对称性）：\n  - $N=3$\n  - 质量 $\\mathbf{m}=[5\\times 10^{24},\\ 6\\times 10^{24},\\ 7\\times 10^{24}]\\ \\mathrm{kg}$\n  - 初始位置 $\\mathbf{r}(0)$（单位：米）：\n    - $\\mathbf{r}_1=[0,\\ 0,\\ 0]$\n    - $\\mathbf{r}_2=[2\\times 10^{9},\\ 0,\\ 0]$\n    - $\\mathbf{r}_3=[-1\\times 10^{9},\\ 1.5\\times 10^{9},\\ 0]$\n  - 初始速度 $\\mathbf{v}(0)$（单位：米/秒）：\n    - $\\mathbf{v}_1=[0,\\ 300,\\ 0]$\n    - $\\mathbf{v}_2=[0,\\ -100,\\ 0]$\n    - $\\mathbf{v}_3=[50,\\ 0,\\ 0]$\n  - 时间步长 $\\Delta t=2000\\ \\mathrm{s}$，步数 $n_{\\mathrm{steps}}=1000$\n  - 软化长度 $\\epsilon=10^{6}\\ \\mathrm{m}$\n  - 对称性微扰参数 $\\eta=0$\n\n- 用例 2（违反作用-反作用，检测漂移）：\n  - 与用例 1 相同，除了使用 $\\eta=1\\times 10^{-5}$\n\n- 用例 3（边界条件 $N=1$）：\n  - $N=1$\n  - 质量 $\\mathbf{m}=[1\\times 10^{26}]\\ \\mathrm{kg}$\n  - 初始位置 $\\mathbf{r}(0)$（单位：米）：\n    - $\\mathbf{r}_1=[1\\times 10^{8},\\ -2\\times 10^{8},\\ 0]$\n  - 初始速度 $\\mathbf{v}(0)$（单位：米/秒）：\n    - $\\mathbf{v}_1=[1200,\\ -500,\\ 0]$\n  - 时间步长 $\\Delta t=1000\\ \\mathrm{s}$，步数 $n_{\\mathrm{steps}}=2000$\n  - 软化长度 $\\epsilon=10^{6}\\ \\mathrm{m}$\n  - 对称性微扰参数 $\\eta=0$\n\n- 用例 4（总动量为零，预期质心静止）：\n  - $N=4$\n  - 质量 $\\mathbf{m}=[2\\times 10^{25},\\ 3\\times 10^{25},\\ 4\\times 10^{25},\\ 5\\times 10^{25}]\\ \\mathrm{kg}$\n  - 初始位置 $\\mathbf{r}(0)$（单位：米）：\n    - $\\mathbf{r}_1=[1\\times 10^{9},\\ 0,\\ 0]$\n    - $\\mathbf{r}_2=[-1\\times 10^{9},\\ 1\\times 10^{9},\\ 0]$\n    - $\\mathbf{r}_3=[0,\\ -1\\times 10^{9},\\ 0]$\n    - $\\mathbf{r}_4=[2\\times 10^{9},\\ 2\\times 10^{9},\\ 0]$\n  - 初始速度 $\\mathbf{v}(0)$（单位：米/秒）：\n    - $\\mathbf{v}_1=[200,\\ 0,\\ 0]$\n    - $\\mathbf{v}_2=[-100,\\ 100,\\ 0]$\n    - $\\mathbf{v}_3=[0,\\ -50,\\ 0]$\n    - $\\mathbf{v}_4=[-20,\\ -20,\\ 0]$\n  - 时间步长 $\\Delta t=1500\\ \\mathrm{s}$，步数 $n_{\\mathrm{steps}}=1200$\n  - 软化长度 $\\epsilon=5\\times 10^{5}\\ \\mathrm{m}$\n  - 对称性微扰参数 $\\eta=0$\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含四个最大偏差值（以米为单位），每个值都格式化为具有 6 位有效数字的科学记数法，并作为逗号分隔的列表用方括号括起来。例如，输出必须采用“[x,y,z,w]”的形式，其中 x、y、z 和 w 均为用科学记数法书写且具有 6 位有效数字的浮点数，不带单位。不应打印任何其他文本。", "solution": "该问题是良置的，有科学依据，并包含了获得唯一解所需的所有信息。它要求设计并实现一个 $N$ 体积分器，以检验质心运动的守恒性——这是 Newton 第三定律的直接推论，从而为力求和算法提供一个基本的健全性检查。我们将进行完整的求解。\n\n### 理论基础：封闭系统中的质心运动\n\n这个问题的基础在于牛顿力学。我们首先定义一个由 $N$ 个粒子组成的系统的质心（CM），其中粒子 $i$ 的质量为 $m_i$，位置向量为 $\\mathbf{r}_i$。\n\n系统的总质量为 $M_{\\mathrm{tot}} = \\sum_{i=1}^{N} m_i$。\n质心位置 $\\mathbf{R}_{\\mathrm{cm}}$ 是粒子位置的质量加权平均值：\n$$\n\\mathbf{R}_{\\mathrm{cm}}(t) = \\frac{1}{M_{\\mathrm{tot}}} \\sum_{i=1}^{N} m_i \\mathbf{r}_i(t)\n$$\n\n对时间 $t$ 求导，得到质心速度 $\\mathbf{V}_{\\mathrm{cm}}$：\n$$\n\\mathbf{V}_{\\mathrm{cm}}(t) = \\frac{d\\mathbf{R}_{\\mathrm{cm}}}{dt} = \\frac{1}{M_{\\mathrm{tot}}} \\sum_{i=1}^{N} m_i \\frac{d\\mathbf{r}_i}{dt} = \\frac{1}{M_{\\mathrm{tot}}} \\sum_{i=1}^{N} m_i \\mathbf{v}_i(t)\n$$\n量 $\\sum m_i \\mathbf{v}_i$ 是系统的总动量 $\\mathbf{P}_{\\mathrm{tot}}$，因此 $\\mathbf{P}_{\\mathrm{tot}} = M_{\\mathrm{tot}} \\mathbf{V}_{\\mathrm{cm}}$。\n\n第二次求导得到质心加速度 $\\mathbf{A}_{\\mathrm{cm}}$：\n$$\n\\mathbf{A}_{\\mathrm{cm}}(t) = \\frac{d\\mathbf{V}_{\\mathrm{cm}}}{dt} = \\frac{1}{M_{\\mathrm{tot}}} \\sum_{i=1}^{N} m_i \\frac{d\\mathbf{v}_i}{dt} = \\frac{1}{M_{\\mathrm{tot}}} \\sum_{i=1}^{N} m_i \\mathbf{a}_i(t)\n$$\n\n根据 Newton 第二定律，项 $m_i \\mathbf{a}_i$ 等于作用在粒子 $i$ 上的总力 $\\mathbf{F}_i^{\\mathrm{tot}}$。对于一个只有内力的封闭系统，这个力是来自系统中所有其他粒子 $j$ 的力的矢量和：\n$$\nm_i \\mathbf{a}_i = \\mathbf{F}_i^{\\mathrm{tot}} = \\sum_{j=1, j\\neq i}^{N} \\mathbf{F}_{ij}\n$$\n其中 $\\mathbf{F}_{ij}$ 是粒子 $j$ 施加于粒子 $i$ 的力。将此代入 $\\mathbf{A}_{\\mathrm{cm}}$ 的方程中可得：\n$$\nM_{\\mathrm{tot}} \\mathbf{A}_{\\mathrm{cm}} = \\sum_{i=1}^{N} \\mathbf{F}_i^{\\mathrm{tot}} = \\sum_{i=1}^{N} \\sum_{j=1, j\\neq i}^{N} \\mathbf{F}_{ij}\n$$\n\n关键步骤是应用 Newton 第三定律（作用与反作用定律），该定律指出任何两个粒子之间的力大小相等，方向相反：$\\mathbf{F}_{ij} = -\\mathbf{F}_{ji}$。右侧的双重求和可以看作是对所有相互作用对 $\\{i,j\\}$ 的求和。对于每一对，求和中既包含 $\\mathbf{F}_{ij}$ 也包含 $\\mathbf{F}_{ji}$。\n$$\n\\sum_{i=1}^{N} \\sum_{j=1, j\\neq i}^{N} \\mathbf{F}_{ij} = \\sum_{i  j} (\\mathbf{F}_{ij} + \\mathbf{F}_{ji})\n$$\n根据 Newton 第三定律，每一项 $(\\mathbf{F}_{ij} + \\mathbf{F}_{ji})$ 都恒等于零。因此，作用在系统上的总内力为零：\n$$\n\\sum_{i=1}^{N} \\mathbf{F}_i^{\\mathrm{tot}} = \\mathbf{0}\n$$\n这意味着 $M_{\\mathrm{tot}} \\mathbf{A}_{\\mathrm{cm}} = \\mathbf{0}$，因此 $\\mathbf{A}_{\\mathrm{cm}} = \\mathbf{0}$。质心的加速度为零。这就是动量守恒定律。\n\n如果 $\\mathbf{A}_{\\mathrm{cm}} = \\mathbf{0}$，那么速度 $\\mathbf{V}_{\\mathrm{cm}}$ 是恒定的，等于其初始值 $\\mathbf{V}_{\\mathrm{cm}}(0)$。再次积分，我们发现质心必须遵循一条惯性轨迹（以恒定速度沿直线运动）：\n$$\n\\mathbf{R}_{\\mathrm{cm}}(t) = \\mathbf{R}_{\\mathrm{cm}}(0) + \\mathbf{V}_{\\mathrm{cm}}(0) t\n$$\n该方程定义了用于检验数值模拟的参考轨迹。\n\n### 算法设计与数值实现\n\n现在的任务是将这一物理原理转化为数值算法。\n\n#### 1. 使用 Plummer 软化的力计算\n\n粒子 $j$ 对粒子 $i$ 的引力由牛顿万有引力定律给出，并使用 Plummer 软化进行修正，以避免粒子间距离非常近时出现数值奇异点。力向量为：\n$$\n\\mathbf{F}_{ij} = G m_i m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\left( \\|\\mathbf{r}_j - \\mathbf{r}_i\\|^2 + \\epsilon^2 \\right)^{3/2}}\n$$\n其中 $G$ 是引力常数，$\\epsilon$ 是软化长度。粒子 $i$ 的加速度为 $\\mathbf{a}_i = \\frac{1}{m_i} \\sum_{j \\neq i} \\mathbf{F}_{ij}$。\n\n#### 2. 作用-反作用对称性破坏\n\n诊断测试的核心涉及两种力累积模式：\n- **对称模式 ($\\eta = 0$)：** 在一个对唯一粒子对 $(i, j)$（其中 $i  j$）进行直接求和的循环中，我们计算 $\\mathbf{F}_{ij}$ 并将其加到粒子 $i$ 的总力上，同时将 $\\mathbf{F}_{ji} = -\\mathbf{F}_{ij}$ 加到粒子 $j$ 的总力上。这正确地实现了 Newton 第三定律。在数值误差范围内，系统总动量是守恒的。\n- **微扰模式 ($\\eta \\neq 0$)：** 问题指定了对对称性的故意破坏。对于每一对 $\\{i,j\\}$（我们使用 $i", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to execute all test cases and print the final result.\n    \"\"\"\n    G = 6.67430e-11  # SI units: m^3 kg^-1 s^-2\n\n    test_cases = [\n        # Case 1 (happy path, correct symmetry)\n        {\n            \"N\": 3,\n            \"masses\": np.array([5e24, 6e24, 7e24]),\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0],\n                [2e9, 0.0, 0.0],\n                [-1e9, 1.5e9, 0.0]\n            ]),\n            \"velocities\": np.array([\n                [0.0, 300.0, 0.0],\n                [0.0, -100.0, 0.0],\n                [50.0, 0.0, 0.0]\n            ]),\n            \"dt\": 2000.0,\n            \"n_steps\": 1000,\n            \"epsilon\": 1e6,\n            \"eta\": 0.0,\n        },\n        # Case 2 (action–reaction violation, detect drift)\n        {\n            \"N\": 3,\n            \"masses\": np.array([5e24, 6e24, 7e24]),\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0],\n                [2e9, 0.0, 0.0],\n                [-1e9, 1.5e9, 0.0]\n            ]),\n            \"velocities\": np.array([\n                [0.0, 300.0, 0.0],\n                [0.0, -100.0, 0.0],\n                [50.0, 0.0, 0.0]\n            ]),\n            \"dt\": 2000.0,\n            \"n_steps\": 1000,\n            \"epsilon\": 1e6,\n            \"eta\": 1e-5,\n        },\n        # Case 3 (boundary condition N=1)\n        {\n            \"N\": 1,\n            \"masses\": np.array([1e26]),\n            \"positions\": np.array([\n                [1e8, -2e8, 0.0]\n            ]),\n            \"velocities\": np.array([\n                [1200.0, -500.0, 0.0]\n            ]),\n            \"dt\": 1000.0,\n            \"n_steps\": 2000,\n            \"epsilon\": 1e6,\n            \"eta\": 0.0,\n        },\n        # Case 4 (zero total momentum)\n        {\n            \"N\": 4,\n            \"masses\": np.array([2e25, 3e25, 4e25, 5e25]),\n            \"positions\": np.array([\n                [1e9, 0.0, 0.0],\n                [-1e9, 1e9, 0.0],\n                [0.0, -1e9, 0.0],\n                [2e9, 2e9, 0.0]\n            ]),\n            \"velocities\": np.array([\n                [200.0, 0.0, 0.0],\n                [-100.0, 100.0, 0.0],\n                [0.0, -50.0, 0.0],\n                [-20.0, -20.0, 0.0]\n            ]),\n            \"dt\": 1500.0,\n            \"n_steps\": 1200,\n            \"epsilon\": 5e5,\n            \"eta\": 0.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        max_deviation = run_simulation(\n            masses=case[\"masses\"],\n            positions=case[\"positions\"],\n            velocities=case[\"velocities\"],\n            G=G,\n            dt=case[\"dt\"],\n            n_steps=case[\"n_steps\"],\n            epsilon=case[\"epsilon\"],\n            eta=case[\"eta\"]\n        )\n        results.append(f\"{max_deviation:.6e}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_accelerations(positions, masses, G, epsilon, eta):\n    \"\"\"\n    Calculates gravitational accelerations using direct summation.\n    \n    This function implements both symmetric force accumulation (eta=0) and a\n    perturbed mode that violates Newton's third law (eta != 0).\n    \"\"\"\n    n_particles = positions.shape[0]\n    accelerations = np.zeros((n_particles, 3))\n    \n    # Iterate over unique pairs of particles (i, j) where i  j\n    for i in range(n_particles):\n        for j in range(i + 1, n_particles):\n            # Vector from particle i to particle j\n            r_ij = positions[j] - positions[i]\n            \n            # Squared distance with softening\n            dist_sq = np.sum(r_ij**2)\n            \n            # Softened inverse cube law factor\n            inv_dist_cubed = (dist_sq + epsilon**2)**(-1.5)\n            \n            # Calculate acceleration contribution for each particle due to the other\n            acc_i_due_to_j = G * masses[j] * inv_dist_cubed * r_ij\n            acc_j_due_to_i = G * masses[i] * inv_dist_cubed * (-r_ij)\n            \n            # Apply symmetric or asymmetric force accumulation\n            # For a pair {i,j}, the contribution to i's acceleration is scaled by (1+eta)\n            # and to j's acceleration by (1-eta).\n            accelerations[i] += (1.0 + eta) * acc_i_due_to_j\n            accelerations[j] += (1.0 - eta) * acc_j_due_to_i\n            \n    return accelerations\n\ndef run_simulation(masses, positions, velocities, G, dt, n_steps, epsilon, eta):\n    \"\"\"\n    Runs a single N-body simulation and returns the max CM deviation.\n    \"\"\"\n    # Defensive copies to avoid modifying the original test case data\n    pos = np.copy(positions)\n    vel = np.copy(velocities)\n    masses_reshaped = masses.reshape(-1, 1)\n    \n    total_mass = np.sum(masses)\n    \n    # Calculate initial center-of-mass position and velocity\n    if total_mass > 0:\n        R_cm_0 = np.sum(masses_reshaped * pos, axis=0) / total_mass\n        V_cm_0 = np.sum(masses_reshaped * vel, axis=0) / total_mass\n    else: # Handle case of zero total mass if needed, though not in tests\n        R_cm_0 = np.zeros(3)\n        V_cm_0 = np.zeros(3)\n\n    max_deviation = 0.0\n\n    # Leapfrog Integrator (KDK - Kick-Drift-Kick)\n    \n    # Initial Kick (half-step)\n    acc = calculate_accelerations(pos, masses, G, epsilon, eta)\n    vel += acc * (dt / 2.0)\n    \n    for step in range(n_steps):\n        # Drift (full step)\n        pos += vel * dt\n        \n        # Kick (full step)\n        acc = calculate_accelerations(pos, masses, G, epsilon, eta)\n        vel += acc * dt\n        \n        # --- Diagnostic Calculation ---\n        current_time = (step + 1) * dt\n        \n        # Calculate simulated center-of-mass position\n        R_cm_sim = np.sum(masses_reshaped * pos, axis=0) / total_mass\n        \n        # Calculate theoretical inertial reference position\n        R_cm_ref = R_cm_0 + V_cm_0 * current_time\n        \n        # Calculate deviation and update maximum\n        deviation = np.linalg.norm(R_cm_sim - R_cm_ref)\n        if deviation > max_deviation:\n            max_deviation = deviation\n            \n    return max_deviation\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3508414"}, {"introduction": "在验证了力计算的准确性之后，下一个关键环节是时间积分器的选择与评估。不同的积分方案具有截然不同的误差特性，深刻影响着模拟的长期保真度。本实践通过一个前向-后向积分实验，让您亲手对比时间可逆的辛积分器（如速度Verlet算法）和非可逆的高阶积分器（如RK4），从而揭示截断误差与舍入误差的来源及其对模拟结果的影响。[@problem_id:3508413]", "problem": "考虑一个在牛顿引力作用下演化的小型 $N$ 体系统。计算任务是设计并执行一个前向-后向积分实验，该实验使用直接求和算法计算引力加速度，并量化由截断误差和舍入误差引起的可逆性误差。实验必须在无量纲单位下进行，引力常数 $G=1$。该问题的基本定律和定义是牛顿第二定律和牛顿万有引力定律：质量为 $m_i$ 的粒子 $i$ 的加速度由下式给出\n$$\n\\frac{d^2 \\boldsymbol{r}_i}{dt^2} = \\boldsymbol{a}_i(\\boldsymbol{r}) = \\sum_{j \\ne i} G m_j \\frac{\\boldsymbol{r}_j - \\boldsymbol{r}_i}{\\left(\\lVert \\boldsymbol{r}_j - \\boldsymbol{r}_i \\rVert^2 + \\epsilon^2 \\right)^{3/2}},\n$$\n其中 $\\boldsymbol{r}_i \\in \\mathbb{R}^3$ 是粒子 $i$ 的位置，$\\boldsymbol{a}_i(\\boldsymbol{r})$ 是由所有其他粒子引起的加速度，$G$ 是引力常数，$\\epsilon$ 是用于正则化近距离接触的 Plummer 软化长度。\n\n您的程序必须：\n- 实现一个直接求和例程，使用上述公式（$G=1$）计算所有粒子的加速度 $\\boldsymbol{a}_i(\\boldsymbol{r})$。\n- 实现两种时间积分方案：\n  - 速度 Verlet (VV) 积分器，这是一种时间对称的二阶方法。将该方案定义为在每个大小为 $\\Delta t$ 的步长中，使用半步踢、全步漂移和半步踢的序列。\n  - 经典的四阶 Runge–Kutta (RK4) 方法。将状态 $(\\boldsymbol{r},\\boldsymbol{v})$ 的常微分方程组定义为 $d\\boldsymbol{r}/dt=\\boldsymbol{v}$ 和 $d\\boldsymbol{v}/dt=\\boldsymbol{a}(\\boldsymbol{r})$，然后应用 RK4 更新，步长为 $\\Delta t$。\n\n- 执行前向-后向实验：给定初始状态 $(\\boldsymbol{r}(0),\\boldsymbol{v}(0))$，使用步长 $\\Delta t$ 进行 $n=\\lfloor T/\\Delta t \\rfloor$ 步的前向积分，总时间为 $T$；然后使用步长 $-\\Delta t$ 进行相同步数的后向积分，使用相同的积分器和相同的操作序列。设后向积分后的最终状态为 $(\\boldsymbol{r}_{\\mathrm{fb}},\\boldsymbol{v}_{\\mathrm{fb}})$。\n- 通过完整状态向量差值的欧几里得范数来量化可逆性误差：\n$$\nE = \\left\\lVert \\mathrm{vec}(\\boldsymbol{r}_{\\mathrm{fb}},\\boldsymbol{v}_{\\mathrm{fb}}) - \\mathrm{vec}(\\boldsymbol{r}(0),\\boldsymbol{v}(0)) \\right\\rVert_2,\n$$\n其中 $\\mathrm{vec}(\\boldsymbol{r},\\boldsymbol{v})$ 表示将所有粒子的所有位置和速度分量连接成 $\\mathbb{R}^{6N}$ 中单个向量所形成的向量。\n\n- 通过执行受控数值实验来归因截断误差和舍入误差的贡献：\n  - 为强调舍入误差，重复实验，在每次更新后将所有状态变量和中间更新量化为单精度（即使用 32 位浮点数），并与双精度（即使用 64 位浮点数）进行比较。\n  - 为强调截断误差，在使用非时间可逆的 RK4 方法时，保持双精度并改变步长 $\\Delta t$，比较两种不同 $\\Delta t$ 值的可逆性误差。\n\n所有量均为无量纲。不使用物理单位。不明确要求角度。最终输出必须是浮点数。\n\n测试套件：\n- 使用以下系统和参数。在所有情况下，引力常数 $G=1$，总积分时间为每个测试指定的 $T$。软化长度 $\\epsilon$ 由每个测试指定。\n\n- 为 $N=3$ 的测试定义初始三体系统：\n  - 质量：$[1.0,1.0,1.0]$。\n  - 位置：$\\boldsymbol{r}(0) = \\left[(-1.0,0.0,0.0),(1.0,0.0,0.0),(0.0,0.0,0.5)\\right]$。\n  - 速度：$\\boldsymbol{v}(0) = \\left[(0.0,0.5,0.0),(0.0,-0.5,0.0),(0.0,0.0,-0.5)\\right]$。\n\n- 为 $N=2$ 的测试定义初始双体圆形轨道：\n  - 质量：$[1.0,1.0]$。\n  - 位置：$\\boldsymbol{r}(0) = \\left[(-0.5,0.0,0.0),(0.5,0.0,0.0)\\right]$。\n  - 速度：在 $y$ 方向选择圆形轨道速度，大小为 $v=\\sqrt{0.5}$，即 $\\boldsymbol{v}(0) = \\left[(0.0,\\sqrt{0.5},0.0),(0.0,-\\sqrt{0.5},0.0)\\right]$。\n\n- 定义平凡的 $N=1$ 系统（边界条件）：\n  - 质量：$[1.0]$。\n  - 位置：$\\boldsymbol{r}(0) = \\left[(0.0,0.0,0.0)\\right]$。\n  - 速度：$\\boldsymbol{v}(0) = \\left[(1.0,0.0,0.0)\\right]$。\n\n需要运行和报告的实验：\n- 测试 $1$（舍入误差主导的可逆方法）：$N=3$，积分器 VV，$\\Delta t=0.01$，$T=1.0$，$\\epsilon=10^{-3}$，双精度（$64$ 位），每次更新后量化为 $64$ 位。\n- 测试 $2$（增强的舍入误差）：与测试 $1$ 相同，但每次更新后进行单精度（$32$ 位）量化。\n- 测试 $3$（存在非可逆截断）：$N=3$，积分器 RK4，$\\Delta t=0.01$，$T=1.0$，$\\epsilon=10^{-3}$，双精度，每次更新后进行量化。\n- 测试 $4$（截断误差缩放）：与测试 $3$ 相同，但 $\\Delta t=0.005$。\n- 测试 $5$（使用可逆方法的双体系统）：$N=2$，积分器 VV，$\\Delta t=0.05$，$T=1.0$，$\\epsilon=0.0$，双精度，每次更新后进行量化。\n- 测试 $6$（边界情况 $N=1$，零加速度）：$N=1$，积分器 RK4，$\\Delta t=0.02$，$T=1.0$，$\\epsilon=0.0$，双精度，每次更新后进行量化。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔的浮点数列表，顺序为 $[E_1,E_2,E_3,E_4,E_5,E_6]$，其中 $E_k$ 是测试 $k$ 的可逆性误差。例如，程序必须精确打印一行，如 $[e_1,e_2,e_3,e_4,e_5,e_6]$。", "solution": "用户提供的问题是有效且适定的。它基于应用于计算天体物理学的经典力学和数值分析的基本原理。该问题要求设计并实现一个数值实验，以研究引力 $N$ 体问题中两种标准积分方案——速度 Verlet (VV) 和四阶 Runge-Kutta (RK4)——的可逆性属性和误差特征。所有提供的参数、初始条件和评估指标在科学上都是合理的、完整的且无歧义的。\n\n解决方案首先建立数学和物理框架，然后详细说明所需数值算法的实现，最后解释前向-后向实验的设计及其结果的解释。\n\n### 1. 运动控制方程\n\n该系统由 $N$ 个通过牛顿引力相互作用的质点组成。每个质量为 $m_i$、位置为 $\\boldsymbol{r}_i \\in \\mathbb{R}^3$ 的粒子 $i$ 的运动由牛顿第二定律 $\\boldsymbol{F}_i = m_i \\boldsymbol{a}_i$ 控制，其中 $\\boldsymbol{a}_i = d^2\\boldsymbol{r}_i/dt^2$ 是加速度。粒子 $i$ 上的力 $\\boldsymbol{F}_i$ 是来自所有其他粒子 $j \\neq i$ 的引力的矢量和。根据牛顿万有引力定律，并按规定取引力常数 $G=1$，粒子 $i$ 的加速度为：\n$$\n\\boldsymbol{a}_i(\\boldsymbol{r}) = \\sum_{j \\ne i} m_j \\frac{\\boldsymbol{r}_j - \\boldsymbol{r}_i}{\\lVert \\boldsymbol{r}_j - \\boldsymbol{r}_i \\rVert^3}\n$$\n为防止当两个粒子彼此靠近时（即 $\\lVert \\boldsymbol{r}_j - \\boldsymbol{r}_i \\rVert \\to 0$）出现数值发散，引入了一个 Plummer 软化长度 $\\epsilon$。修正后的正则化加速度为：\n$$\n\\boldsymbol{a}_i(\\boldsymbol{r}) = \\sum_{j \\ne i} m_j \\frac{\\boldsymbol{r}_j - \\boldsymbol{r}_i}{\\left(\\lVert \\boldsymbol{r}_j - \\boldsymbol{r}_i \\rVert^2 + \\epsilon^2 \\right)^{3/2}}\n$$\n这组 $N$ 个耦合二阶常微分方程 (ODEs) 可以通过定义一个 $6N$ 维状态向量 $Y(t) = (\\boldsymbol{r}_1, \\dots, \\boldsymbol{r}_N, \\boldsymbol{v}_1, \\dots, \\boldsymbol{v}_N)$ 转换为一个 $2N$ 个一阶常微分方程组，其中 $\\boldsymbol{v}_i = d\\boldsymbol{r}_i/dt$ 是速度。系统的时间演化由下式给出：\n$$\n\\frac{dY}{dt} = f(Y) = \\left( \\boldsymbol{v}_1, \\dots, \\boldsymbol{v}_N, \\boldsymbol{a}_1(\\boldsymbol{r}), \\dots, \\boldsymbol{a}_N(\\boldsymbol{r}) \\right)\n$$\n这个一阶系统适合用标准的数值积分器求解。\n\n### 2. 加速度的直接求和算法\n\n直接求和算法通过遍历所有其他粒子并将其贡献相加来计算每个粒子上的加速度。对于一个 $N$ 粒子系统，这涉及计算 $N(N-1)$ 次成对相互作用，导致计算复杂度为 $O(N^2)$。对于本问题中的小 $N$ 值，这种方法是完全足够的。实现以矢量化方式计算这些成对力以提高效率。\n\n### 3. 数值积分方案\n\n该问题要求实现两种不同的积分器来随时间演化系统。\n\n**速度 Verlet (VV) 积分器：**\n速度 Verlet 算法是一种二阶、辛的、时间可逆的积分器。其时间可逆性使其成为长期模拟哈密顿系统（如 $N$ 体问题）的绝佳选择，因为它能在长时间内保持能量守恒（有界振荡）。从时间 $t$ 到 $t+\\Delta t$ 的单步积分通过“踢-漂移-踢”序列完成：\n1.  **半步踢：** 用半步更新速度：$\\boldsymbol{v}(t + \\Delta t/2) = \\boldsymbol{v}(t) + \\frac{1}{2}\\Delta t \\cdot \\boldsymbol{a}(\\boldsymbol{r}(t))$。\n2.  **全步漂移：** 使用新的半步速度更新位置：$\\boldsymbol{r}(t + \\Delta t) = \\boldsymbol{r}(t) + \\Delta t \\cdot \\boldsymbol{v}(t + \\Delta t/2)$。\n3.  **计算新加速度：** 在新位置计算 $\\boldsymbol{a}(\\boldsymbol{r}(t + \\Delta t))$。\n4.  **半步踢：** 完成速度更新：$\\boldsymbol{v}(t + \\Delta t) = \\boldsymbol{v}(t + \\Delta t/2) + \\frac{1}{2}\\Delta t \\cdot \\boldsymbol{a}(\\boldsymbol{r}(t + \\Delta t))$。\n至关重要的是，这些操作通过将 $\\Delta t$ 取反是完全可逆的。在没有舍入误差的情况下，向前积分然后再向后积分相同的时间将完美地恢复初始状态。\n\n**四阶 Runge-Kutta (RK4) 积分器：**\n经典的 RK4 方法是一种广泛使用的通用积分器，以其高精度而闻名。它是一种四阶方法，意味着其全局误差以 $O((\\Delta t)^4)$ 的阶数缩放。对于一个系统 $dY/dt = f(Y)$，更新规则为：\n$$\nY_{n+1} = Y_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\n其中中间斜率为：\n-   $k_1 = f(Y_n)$\n-   $k_2 = f(Y_n + \\frac{\\Delta t}{2} k_1)$\n-   $k_3 = f(Y_n + \\frac{\\Delta t}{2} k_2)$\n-   $k_4 = f(Y_n + \\Delta t k_3)$\n在我们的问题中，$Y_n = (\\boldsymbol{r}_n, \\boldsymbol{v}_n)$，而 $f(Y_n)$ 涉及计算加速度。虽然对于给定的 $\\Delta t$ 精度很高，但 RK4 既不是辛的，也不是时间可逆的。这意味着误差，特别是截断误差，在时间反转时不会抵消。\n\n### 4. 前向-后向可逆性实验\n\n该实验旨在通过测试积分器反转计算轨迹的能力来量化数值误差。\n1.  系统从初始状态 $(\\boldsymbol{r}(0), \\boldsymbol{v}(0))$ 开始向前积分，总时间为 $T$。\n2.  从最终状态 $(\\boldsymbol{r}(T), \\boldsymbol{v}(T))$ 开始，系统向后积分相同的时间 $T$（使用步长 $-\\Delta t$）。\n3.  将此后向积分的最终状态 $(\\boldsymbol{r}_{\\mathrm{fb}}, \\boldsymbol{v}_{\\mathrm{fb}})$ 与原始初始状态进行比较。\n可逆性误差 $E = \\left\\lVert \\mathrm{vec}(\\boldsymbol{r}_{\\mathrm{fb}},\\boldsymbol{v}_{\\mathrm{fb}}) - \\mathrm{vec}(\\boldsymbol{r}(0),\\boldsymbol{v}(0)) \\right\\rVert_2$ 衡量了总偏差。此误差主要来自两个来源：\n-   **截断误差：** 用离散步长算法近似连续微分方程所产生的内在误差。对于像 VV 这样的时间可逆积分器，截断误差以一种结构化的方式累积，在反转时大部分会抵消。对于像 RK4 这样的非可逆积分器，它们不会抵消，导致显著的可逆性误差。此误差随步长 $\\Delta t$ 缩放。\n-   **舍入误差：** 由于计算机中数字的有限精度表示而产生的误差。这些误差以伪随机的方式累积。通过在单精度（$32$ 位）和双精度（$64$ 位）下进行实验，我们可以分离出舍入误差的贡献。舍入误差的影响通过在每个完整的积分步骤后将状态向量 $(\\boldsymbol{r}, \\boldsymbol{v})$ 量化到目标精度来模拟。\n\n### 5. 测试用例分析\n提供的测试用例旨在系统地探测这些误差源：\n-   **测试 1  2 (VV, $N=3$)：** 比较时间可逆的 VV 积分器在双精度和单精度下的表现，可以分离出舍入误差的影响。测试 1（$64$ 位）中的误差应该极小，而测试 2（$32$ 位）中的误差将大得多，这表明了降低精度的代价。\n-   **测试 3 (RK4, $N=3$)：** 使用非可逆的 RK4 方法，误差将由不可抵消的截断误差主导，预计会比测试 1 中 VV 的舍入误差主导的误差大得多，尽管 RK4 是一个更高阶的方法。\n-   **测试 4 (RK4, $N=3$, 更小的 $\\Delta t$)：** 与测试 3 相比，将 $\\Delta t$ 减半将测试 RK4 截断误差的 $O((\\Delta t)^4)$ 缩放特性。误差 $E_4$ 应该显著小于 $E_3$，理想情况下接近因子 $(0.01/0.005)^4 = 16$。\n-   **测试 5 (VV, $N=2$)：** 此测试将鲁棒的 VV 方法应用于一个稳定的双体开普勒轨道。使用 `double` 精度和 $\\epsilon=0$，误差应该非常小，主要由理想物理系统中的舍入误差引起。\n-   **测试 6 (RK4, $N=1$)：** 一个不受任何力作用的粒子沿直线运动。精确解是平凡的。任何计算出的误差 $E_6$ 都完全是由于位置和速度更新中浮点舍入误差的累积，为这种计算环境下的机器精度限制提供了基线。", "answer": "```python\nimport numpy as np\n\ndef calculate_accelerations(pos, masses, eps, dtype):\n    \"\"\"\n    Calculates gravitational accelerations using a vectorized direct summation.\n    G is assumed to be 1.\n    \"\"\"\n    n_particles = pos.shape[0]\n    if n_particles == 1:\n        return np.zeros_like(pos, dtype=dtype)\n\n    # Vectorized calculation of pairwise differences and distances\n    # pos_i shape: (n, 1, 3); pos_j shape: (1, n, 3)\n    # This allows broadcasting to get all pairs of vectors.\n    pos_i = pos[:, np.newaxis, :]\n    pos_j = pos[np.newaxis, :, :]\n    \n    # r_ij is vector from i to j, has shape (n, n, 3)\n    r_ij = pos_j - pos_i \n    \n    # dist_sq has shape (n, n)\n    dist_sq = np.sum(r_ij**2, axis=-1)\n    \n    # Softened inverse cube distance\n    inv_r3 = (dist_sq + eps**2)**(-1.5)\n    \n    # Set diagonal elements to 0 to avoid self-interaction\n    np.fill_diagonal(inv_r3, 0.0)\n    \n    # masses_j shape: (1, n, 1) to broadcast correctly with r_ij\n    masses_j = masses[np.newaxis, :, np.newaxis]\n    \n    # Sum over j axis; inv_r3 needs an extra dimension for broadcasting\n    # accel shape: (n, 3)\n    accel = np.sum(masses_j * r_ij * inv_r3[..., np.newaxis], axis=1)\n    \n    return accel.astype(dtype)\n\ndef step_vv(pos, vel, masses, dt, eps, dtype):\n    \"\"\"A single step of the Velocity Verlet integrator.\"\"\"\n    a_t = calculate_accelerations(pos, masses, eps, dtype)\n    v_half = vel + 0.5 * dt * a_t\n    pos_new = pos + dt * v_half\n    a_t_plus_dt = calculate_accelerations(pos_new, masses, eps, dtype)\n    vel_new = v_half + 0.5 * dt * a_t_plus_dt\n    return pos_new, vel_new\n\ndef step_rk4(pos, vel, masses, dt, eps, dtype):\n    \"\"\"A single step of the classic 4th-order Runge-Kutta integrator.\"\"\"\n    # k1\n    k1_r = dt * vel\n    k1_v = dt * calculate_accelerations(pos, masses, eps, dtype)\n    \n    # k2\n    k2_r = dt * (vel + 0.5 * k1_v)\n    k2_v = dt * calculate_accelerations(pos + 0.5 * k1_r, masses, eps, dtype)\n    \n    # k3\n    k3_r = dt * (vel + 0.5 * k2_v)\n    k3_v = dt * calculate_accelerations(pos + 0.5 * k2_r, masses, eps, dtype)\n    \n    # k4\n    k4_r = dt * (vel + k3_v)\n    k4_v = dt * calculate_accelerations(pos + k3_r, masses, eps, dtype)\n    \n    # Update state\n    pos_new = pos + (k1_r + 2*k2_r + 2*k3_r + k4_r) / 6.0\n    vel_new = vel + (k1_v + 2*k2_v + 2*k3_v + k4_v) / 6.0\n    \n    return pos_new, vel_new\n\ndef run_experiment(initial_r, initial_v, masses, integrator_name, dt, T, eps, precision_str):\n    \"\"\"\n    Performs a forward-backward integration experiment and returns the reversibility error.\n    \"\"\"\n    dtype = np.float64 if precision_str == 'double' else np.float32\n\n    # Set initial state and precision\n    r0 = initial_r.copy().astype(dtype)\n    v0 = initial_v.copy().astype(dtype)\n    m = masses.copy().astype(dtype)\n    \n    r, v = r0.copy(), v0.copy()\n\n    stepper = step_vv if integrator_name == 'VV' else step_rk4\n    n_steps = int(round(T / abs(dt)))\n\n    # Forward integration\n    for _ in range(n_steps):\n        r_new, v_new = stepper(r, v, m, dt, eps, dtype)\n        r = r_new.astype(dtype)\n        v = v_new.astype(dtype)\n        \n    # Backward integration\n    for _ in range(n_steps):\n        r_new, v_new = stepper(r, v, m, -dt, eps, dtype)\n        r = r_new.astype(dtype)\n        v = v_new.astype(dtype)\n        \n    r_fb, v_fb = r, v\n    \n    # Calculate final error\n    initial_state_vec = np.concatenate((r0.flatten(), v0.flatten()))\n    final_state_vec = np.concatenate((r_fb.flatten(), v_fb.flatten()))\n    \n    error = np.linalg.norm(final_state_vec - initial_state_vec)\n    return float(error)\n\ndef solve():\n    # Initial conditions\n    ic_n3 = {\n        'masses': np.array([1.0, 1.0, 1.0]),\n        'pos': np.array([[-1.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 0.5]]),\n        'vel': np.array([[0.0, 0.5, 0.0], [0.0, -0.5, 0.0], [0.0, 0.0, -0.5]])\n    }\n    \n    v_circ = np.sqrt(0.5)\n    ic_n2 = {\n        'masses': np.array([1.0, 1.0]),\n        'pos': np.array([[-0.5, 0.0, 0.0], [0.5, 0.0, 0.0]]),\n        'vel': np.array([[0.0, v_circ, 0.0], [0.0, -v_circ, 0.0]])\n    }\n    \n    ic_n1 = {\n        'masses': np.array([1.0]),\n        'pos': np.array([[0.0, 0.0, 0.0]]),\n        'vel': np.array([[1.0, 0.0, 0.0]])\n    }\n\n    test_cases = [\n        # Test 1: VV, double, N=3\n        {'ic': ic_n3, 'integrator': 'VV', 'dt': 0.01, 'T': 1.0, 'eps': 1e-3, 'precision': 'double'},\n        # Test 2: VV, single, N=3\n        {'ic': ic_n3, 'integrator': 'VV', 'dt': 0.01, 'T': 1.0, 'eps': 1e-3, 'precision': 'single'},\n        # Test 3: RK4, double, dt=0.01, N=3\n        {'ic': ic_n3, 'integrator': 'RK4', 'dt': 0.01, 'T': 1.0, 'eps': 1e-3, 'precision': 'double'},\n        # Test 4: RK4, double, dt=0.005, N=3\n        {'ic': ic_n3, 'integrator': 'RK4', 'dt': 0.005, 'T': 1.0, 'eps': 1e-3, 'precision': 'double'},\n        # Test 5: VV, double, N=2\n        {'ic': ic_n2, 'integrator': 'VV', 'dt': 0.05, 'T': 1.0, 'eps': 0.0, 'precision': 'double'},\n        # Test 6: RK4, double, N=1\n        {'ic': ic_n1, 'integrator': 'RK4', 'dt': 0.02, 'T': 1.0, 'eps': 0.0, 'precision': 'double'},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_experiment(\n            initial_r=case['ic']['pos'],\n            initial_v=case['ic']['vel'],\n            masses=case['ic']['masses'],\n            integrator_name=case['integrator'],\n            dt=case['dt'],\n            T=case['T'],\n            eps=case['eps'],\n            precision_str=case['precision']\n        )\n        results.append(error)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3508413"}, {"introduction": "在追求计算效率与数值精度之间的平衡时，理解浮点运算的影响至关重要，尤其是在利用现代硬件（如GPU）时。直接求和算法中计算成本最高的部分是力的累加。本实践旨在量化在这一关键步骤中使用单精度累加器与双精度累加器所引入的数值误差，帮助您深入理解在不同物理情境下，精度与性能之间的权衡。[@problem_id:3508472]", "problem": "考虑一个在牛顿引力作用下的自引力$N$体系统，该系统在无量纲$N$体单位下建模，其中$G = 1$。设位置$\\mathbf{x}_i \\in \\mathbb{R}^3$和速度$\\mathbf{v}_i \\in \\mathbb{R}^3$以双精度（binary $64$）存储。粒子$i$上由所有其他粒子产生的引力加速度定义为\n$$\n\\mathbf{a}_i = \\sum_{j \\ne i} m_j \\frac{\\mathbf{x}_j - \\mathbf{x}_i}{\\left(\\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert^2 + \\epsilon^2\\right)^{3/2}},\n$$\n其中$m_j$是粒子$j$的质量，$\\epsilon  0$是一个普拉默（Plummer）软化长度，用于防止在零间距时出现奇异力。在直接求和算法中，对$j$累加$\\mathbf{a}_i$的部分和可以用单精度（binary $32$）或双精度（binary $64$）进行计算。在这两种情况下，位置$\\mathbf{x}_i$和速度$\\mathbf{v}_i$都保持以双精度存储。\n\n您的任务是量化使用单精度与双精度累加加速度矢量所引入的数值误差，而所有输入（位置、速度、质量、软化长度）均以双精度表示。对于下述每个测试用例，计算以下误差度量：\n$$\nE_{\\max} = \\max_{i \\in \\{1,\\dots,N\\}} \\left( \\frac{\\lVert \\mathbf{a}_i^{(\\text{single})} - \\mathbf{a}_i^{(\\text{double})} \\rVert_2}{\\lVert \\mathbf{a}_i^{(\\text{double})} \\rVert_2} \\right),\n$$\n并遵循以下针对接近零的分母的约定：如果$\\lVert \\mathbf{a}_i^{(\\text{double})} \\rVert_2 \\le \\tau$，则用绝对误差$\\lVert \\mathbf{a}_i^{(\\text{single})} - \\mathbf{a}_i^{(\\text{double})} \\rVert_2$代替该比率。使用阈值$\\tau = 10^{-300}$。加速度$\\mathbf{a}_i^{(\\text{single})}$和$\\mathbf{a}_i^{(\\text{double})}$都必须使用上述相同的贡献项公式，唯一的区别在于，前者对$j$的求和累加使用单精度累加器，而后者使用双精度累加器。在双精度下计算贡献项，并且对于单精度累加，在相加前将每个贡献项转换为单精度。\n\n使用以下测试套件。所有随机值必须使用提供的种子确定性地生成，并且所有量在$N$体单位下都是无量纲的：\n\n- 测试用例$1$（一般配置，中等$N$）：$N = 32$。位置$\\mathbf{x}_i$使用种子$12345$从$[-1,1]^3$上的均匀分布中独立抽取。质量$m_i$使用相同的种子从$[0.5,1.5]$上的均匀分布中独立抽取。速度$\\mathbf{v}_i$使用相同的种子从$[-0.1,0.1]^3$上的均匀分布中独立抽取。使用软化长度$\\epsilon = 10^{-3}$。\n\n- 测试用例$2$（成对对称与抵消）：$N = 20$。使用种子$777$从$[-0.5,0.5]^3$上均匀生成$10$个基矢量$\\mathbf{b}_k$，并对$k = 1,\\dots,10$配对形成位置$\\mathbf{x}_{2k-1} = \\mathbf{b}_k$和$\\mathbf{x}_{2k} = -\\mathbf{b}_k$。将所有质量设置为$m_i = 1$。速度$\\mathbf{v}_i$使用相同的种子从$[-0.1,0.1]^3$上的均匀分布中独立抽取。使用软化长度$\\epsilon = 10^{-3}$。\n\n- 测试用例$3$（更大的$N$以强调累加过程）：$N = 256$。位置$\\mathbf{x}_i$使用种子$2021$从$[-2,2]^3$上的均匀分布中独立抽取。将所有质量设置为$m_i = 1$。速度$\\mathbf{v}_i$使用相同的种子从$[-0.01,0.01]^3$上的均匀分布中独立抽取。使用软化长度$\\epsilon = 10^{-4}$。\n\n- 测试用例$4$（贡献项的动态范围）：$N = 64$。在原点放置一个质量为$m_1 = 10^6$的粒子。其余$63$个位置使用种子$42$从$[0.1,1]^3$上的均匀分布中独立抽取。对于$i \\ge 2$，其余质量$m_i$使用相同的种子从$[0.5,1.5]$上的均匀分布中独立抽取。速度$\\mathbf{v}_i$使用相同的种子从$[-0.01,0.01]^3$上的均匀分布中独立抽取。使用软化长度$\\epsilon = 10^{-2}$。\n\n您的程序必须实现两种累加精度的加速度直接求和，并为每个测试用例计算$E_{\\max}$。您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表，结果采用科学记数法，小数点后恰好有六位数字（例如，$[1.234567\\text{e-}08,9.876543\\text{e-}07,\\dots]$）。输出是在$N$体单位下的无量纲数。不允许外部输入；所有数据必须按规定在程序内生成。", "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上基于牛顿力学和数值分析的原理，问题定义良好，所有必要的参数和条件都已明确，并且其表述是客观的。任务是量化在一个$N$体系统中，与双精度基准相比，使用单精度浮点算术累加引力加速度所引入的数值误差。\n\n问题的核心在于对粒子$i$上的引力加速度$\\mathbf{a}_i$进行直接求和计算：\n$$\n\\mathbf{a}_i = \\sum_{j \\ne i} m_j \\frac{\\mathbf{x}_j - \\mathbf{x}_i}{\\left(\\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert^2 + \\epsilon^2\\right)^{3/2}}\n$$\n其中$\\mathbf{x}_i$是位置，$m_j$是质量，$\\epsilon$是普拉默软化长度。问题要求比较两种计算变体：$\\mathbf{a}_i^{(\\text{double})}$，其中求和以双精度（binary64）累加；以及$\\mathbf{a}_i^{(\\text{single})}$，其中求和以单精度（binary32）累加。所有输入量（$\\mathbf{x}_i, m_j, \\epsilon$）都以双精度提供。\n\n所研究的基本原理是浮点求和中的舍入误差累积。在对一串数字求和时，表示的有限精度可能导致精度损失。当将一个小数字加到一个大数字上（吸收效应）或对许多符号交替的项求和时（灾难性抵消），这种情况尤为明显。单精度算术的尾数（通常为$23$位）比双精度（$52$位）小，因此更容易受到这些效应的影响。\n\n解决此问题的算法步骤如下：\n\n1.  **系统初始化**：对于每个测试用例，使用指定的参数和随机种子确定性地生成粒子位置$\\mathbf{x}_i$和质量$m_i$。这确保了可复现性。使用NumPy的`default_rng`提供了一个现代化且可靠的伪随机数源。\n\n2.  **力的贡献项的矢量化计算**：直接求和算法的计算复杂度为$O(N^2)$，因为它涉及计算所有唯一粒子对之间的相互作用。为了高效地实现这一点，采用了矢量化的方法。\n    -   首先，使用NumPy的广播功能，为所有粒子对$(i, j)$计算一个$N \\times N \\times 3$的位移矢量数组$\\Delta\\mathbf{x}_{ij} = \\mathbf{x}_j - \\mathbf{x}_i$。\n    -   由此，计算出一个$N \\times N$的距离平方矩阵$\\lVert \\Delta\\mathbf{x}_{ij} \\rVert^2$。\n    -   然后，对所有粒子对逐元素计算软化的逆立方定律项$(\\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert^2 + \\epsilon^2)^{-3/2}$，得到一个$N \\times N$矩阵。将对应于$i=j$的对角线元素设置为零，以强制执行$j \\ne i$的条件。\n    -   最后，所有单个的成对加速度贡献项$\\mathbf{f}_{ij} = m_j \\frac{\\mathbf{x}_j - \\mathbf{x}_i}{(\\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert^2 + \\epsilon^2)^{3/2}}$都在双精度（`float64`）下计算，并存储在一个$N \\times N \\times 3$的数组中。该数组代表了对每个粒子$i$要求和的所有项。\n\n3.  **特定精度的加速度累加**：\n    -   **双精度加速度$\\mathbf{a}_i^{(\\text{double})}$**：通过沿适当的轴（$j$）对预先计算的`float64`贡献项求和，来计算所有粒子的加速度矢量。`numpy.sum`函数应用于`float64`数组时，默认使用`float64`累加器，从而正确地模拟了双精度求和。\n    -   **单精度加速度$\\mathbf{a}_i^{(\\text{single})}$**：为了按规定模拟单精度累加，每个双精度贡献项必须在添加到累加器*之前*转换为单精度（`float32`）。这通过首先创建整个$N \\times N \\times 3$贡献项数组的`float32`副本实现。然后，对这个`float32`数组使用`numpy.sum`。求和过程自然地使用`float32`累加器进行，忠实地复制了指定的数值过程。\n\n4.  **误差度量计算**：分析的核心是计算最大相对误差$E_{\\max}$。\n    $$\n    E_{\\max} = \\max_{i \\in \\{1,\\dots,N\\}} \\left( \\frac{\\lVert \\mathbf{a}_i^{(\\text{single})} - \\mathbf{a}_i^{(\\text{double})} \\rVert_2}{\\lVert \\mathbf{a}_i^{(\\text{double})} \\rVert_2} \\right)\n    $$\n    -   对每个粒子计算差分矢量$\\mathbf{a}_i^{(\\text{single})} - \\mathbf{a}_i^{(\\text{double})}$。请注意，`float32`的结果$\\mathbf{a}_i^{(\\text{single})}$必须转换回`float64`进行此减法运算，以保留误差信息。\n    -   对所有粒子计算差分矢量和双精度加速度矢量的L2范数（欧几里得范数）。\n    -   为处理$\\lVert \\mathbf{a}_i^{(\\text{double})} \\rVert_2$接近于零的情况（例如，由于对称性，如测试用例2中所示），使用阈值$\\tau = 10^{-300}$。如果$\\lVert \\mathbf{a}_i^{(\\text{double})} \\rVert_2 \\le \\tau$，则使用绝对误差$\\lVert \\mathbf{a}_i^{(\\text{single})} - \\mathbf{a}_i^{(\\text{double})} \\rVert_2$代替该比率。这可以防止除以零，并正确处理相对误差可能会产生误导性的大值或无穷大的情况。\n    -   最终误差$E_{\\max}$是在所有粒子的个体误差度量中找到的最大值。\n\n此方法应用于四个指定的测试用例中的每一个，并将所得的$E_{\\max}$值收集起来并按要求格式化。", "answer": "```python\nimport numpy as np\n\ndef generate_test_case_data(case_num):\n    \"\"\"\n    Generates initial conditions for a specified test case.\n    \"\"\"\n    if case_num == 1:\n        N = 32\n        epsilon = 1e-3\n        seed = 12345\n        rng = np.random.default_rng(seed)\n        positions = rng.uniform(-1.0, 1.0, size=(N, 3))\n        masses = rng.uniform(0.5, 1.5, size=N)\n        # Velocities are not needed for acceleration calculation\n    elif case_num == 2:\n        N = 20\n        epsilon = 1e-3\n        seed = 777\n        rng = np.random.default_rng(seed)\n        base_vectors = rng.uniform(-0.5, 0.5, size=(N // 2, 3))\n        positions = np.zeros((N, 3), dtype=np.float64)\n        positions[0::2] = base_vectors\n        positions[1::2] = -base_vectors\n        masses = np.ones(N, dtype=np.float64)\n    elif case_num == 3:\n        N = 256\n        epsilon = 1e-4\n        seed = 2021\n        rng = np.random.default_rng(seed)\n        positions = rng.uniform(-2.0, 2.0, size=(N, 3))\n        masses = np.ones(N, dtype=np.float64)\n    elif case_num == 4:\n        N = 64\n        epsilon = 1e-2\n        seed = 42\n        rng = np.random.default_rng(seed)\n        positions = np.zeros((N, 3), dtype=np.float64)\n        masses = np.zeros(N, dtype=np.float64)\n        \n        # Central massive particle\n        positions[0] = [0.0, 0.0, 0.0]\n        masses[0] = 1e6\n        \n        # Other particles\n        positions[1:] = rng.uniform(0.1, 1.0, size=(N - 1, 3))\n        masses[1:] = rng.uniform(0.5, 1.5, size=N - 1)\n    else:\n        raise ValueError(\"Invalid case number\")\n        \n    return N, positions, masses, epsilon\n\ndef compute_E_max(N, positions, masses, epsilon):\n    \"\"\"\n    Computes accelerations with single and double precision accumulators\n    and returns the maximum relative error E_max.\n    \"\"\"\n    tau = 1e-300\n    \n    # Use broadcasting to compute all pairwise displacement vectors\n    # dx[i, j, :] = positions[j] - positions[i]\n    dx = positions[None, :, :] - positions[:, None, :]\n    \n    # Compute squared distances\n    r_sq = np.sum(dx**2, axis=2)\n    \n    # Compute the softened inverse cube law term\n    # Add a small value to r_sq to avoid division by zero if epsilon is 0, though not required here.\n    inv_r3_soft = (r_sq + epsilon**2)**(-1.5)\n    \n    # Set diagonal elements to 0 to exclude self-interaction (j != i)\n    # This is an efficient way to handle the j != i condition.\n    np.fill_diagonal(inv_r3_soft, 0.0)\n    \n    # Compute all pairwise acceleration contributions in double precision\n    # terms[i, j, :] is the acceleration on particle i due to particle j\n    # Broadcasting masses (1, N) * inv_r3_soft (N, N) -> (N, N)\n    # Then expand dims to (N, N, 1) and multiply by dx (N, N, 3)\n    terms = (masses[None, :] * inv_r3_soft)[:, :, None] * dx\n\n    # 1. Double-precision accumulation\n    # np.sum on a float64 array uses a float64 accumulator\n    a_double = np.sum(terms, axis=1, dtype=np.float64)\n\n    # 2. Single-precision accumulation\n    # Per the problem, cast each term to float32 BEFORE summing.\n    # This is achieved by creating a float32 copy of the terms array.\n    # np.sum on a float32 array will use a float32 accumulator.\n    terms_single = terms.astype(np.float32)\n    a_single = np.sum(terms_single, axis=1)\n\n    # Calculate the error metric E_max\n    # Cast a_single back to float64 for a high-precision difference\n    diff_a = a_single.astype(np.float64) - a_double\n    \n    norm_diff_a = np.linalg.norm(diff_a, axis=1)\n    norm_a_double = np.linalg.norm(a_double, axis=1)\n    \n    # Apply the threshold condition to avoid division by zero/small numbers\n    # Use absolute error where norm_a_double is small\n    errors = np.where(\n        norm_a_double > tau,\n        norm_diff_a / norm_a_double,\n        norm_diff_a\n    )\n    \n    E_max = np.max(errors)\n    \n    return E_max\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [1, 2, 3, 4]\n    results = []\n\n    for case_num in test_cases:\n        N, positions, masses, epsilon = generate_test_case_data(case_num)\n        E_max = compute_E_max(N, positions, masses, epsilon)\n        results.append(E_max)\n\n    # Format output as a list of strings in scientific notation\n    formatted_results = [f\"{res:.6e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3508472"}]}