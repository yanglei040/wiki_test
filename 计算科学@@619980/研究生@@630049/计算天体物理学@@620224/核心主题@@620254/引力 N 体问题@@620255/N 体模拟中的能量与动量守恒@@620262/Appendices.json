{"hands_on_practices": [{"introduction": "在任何 N 体模拟开始之前，建立一个一致的参考系至关重要。本实践聚焦于一个基础任务：将系统的质心置于原点并使其总动量为零。此练习将引导你应对有限精度算术带来的数值挑战，并掌握实现高精度初始化的稳健方法 ([@problem_id:3509637])。", "problem": "考虑一个引力 $N$ 体问题的初始化，该初始化在双精度浮点运算中进行，并且在时间积分之前必须强制执行两个不变量：总动量为零以及质心位于原点。设质量为 $\\{m_i\\}_{i=1}^N$，$m_i \\in \\mathbb{R}^+$；位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$，$\\mathbf{r}_i \\in \\mathbb{R}^3$，单位为米；速度为 $\\{\\mathbf{v}_i\\}_{i=1}^N$，$\\mathbf{v}_i \\in \\mathbb{R}^3$，单位为米每秒。需要施加的不变量为 $\\sum_{i=1}^N m_i \\mathbf{v}_i = \\mathbf{0}$ 和 $\\sum_{i=1}^N m_i \\mathbf{r}_i = \\mathbf{0}$。\n\n从第一性原理出发，结合线性动量和质心的定义以及牛顿力学，设计一个数值稳健的过程。该过程计算所需的聚合量，并对 $\\mathbf{r}_i$ 和 $\\mathbf{v}_i$ 应用变换，以在浮点运算中将不变量强制约束到机器精度。该过程必须对由 $\\{m_i\\}$、$\\{\\mathbf{r}_i\\}$ 和 $\\{\\mathbf{v}_i\\}$ 中的大动态范围引起的病态和具有稳健性。您的设计必须明确采用一种求和策略，以稳定 $\\sum_{i=1}^N m_i$、$\\sum_{i=1}^N m_i \\mathbf{r}_i$ 和 $\\sum_{i=1}^N m_i \\mathbf{v}_i$ 的累加，防止舍入误差的影响（例如，补偿求和或成对求和），并且必须包含一个校正步骤，以消除浮点极限内对不变量的任何残余违反。您必须在全局平移下保持天体的相对构型，并在均匀加性向量下保持速度不变，并且您的过程必须能稳健地处理 $N=1$ 的边界情况。\n\n将此初始化过程实现为一个完整的、可运行的程序。应用您的过程后，通过检查来验证不变量。该检查将残差范数 $\\left\\|\\sum_{i=1}^N m_i \\mathbf{r}_i\\right\\|_2$ 和 $\\left\\|\\sum_{i=1}^N m_i \\mathbf{v}_i\\right\\|_2$ 与一个容差进行比较，该容差与机器 ε 成正比，并按一个具有物理意义的范数进行缩放。位置单位使用米，速度单位使用米每秒。此问题不涉及角度。每个测试用例的验证必须返回一个布尔值，指示在您的容差标准下，两个不变量是否都满足到机器精度。\n\n测试套件：\n- 案例 A（一般情况）：$N=5$，质量 $\\left[m_1,m_2,m_3,m_4,m_5\\right] = \\left[1.0, 2.0, 3.5, 0.8, 4.2\\right]$，位置（米）\n$\\mathbf{r}_1 = \\left[1.0\\times 10^7, -2.0\\times 10^7, 3.0\\times 10^7\\right]$, \n$\\mathbf{r}_2 = \\left[-4.0\\times 10^7, 5.0\\times 10^7, -6.0\\times 10^7\\right]$, \n$\\mathbf{r}_3 = \\left[7.0\\times 10^7, -8.0\\times 10^7, 9.0\\times 10^7\\right]$, \n$\\mathbf{r}_4 = \\left[-1.5\\times 10^7, 2.2\\times 10^7, -3.3\\times 10^7\\right]$, \n$\\mathbf{r}_5 = \\left[4.4\\times 10^7, -5.5\\times 10^7, 6.6\\times 10^7\\right]$；速度（米每秒）\n$\\mathbf{v}_1 = \\left[1200.0, -2300.0, 3100.0\\right]$, \n$\\mathbf{v}_2 = \\left[-4000.0, 5100.0, -6200.0\\right]$, \n$\\mathbf{v}_3 = \\left[7300.0, -8400.0, 9500.0\\right]$, \n$\\mathbf{v}_4 = \\left[-1600.0, 2200.0, -3300.0\\right]$, \n$\\mathbf{v}_5 = \\left[4400.0, -5500.0, 6600.0\\right]$。\n- 案例 B（边界情况 $N=1$）：$N=1$，质量 $\\left[m_1\\right] = \\left[1.0\\right]$，位置（米）$\\mathbf{r}_1 = \\left[1.0\\times 10^3, -2.0\\times 10^3, 3.0\\times 10^3\\right]$，速度（米每秒）$\\mathbf{v}_1 = \\left[-10.0, 20.0, -30.0\\right]$。\n- 案例 C（极端质量比）：$N=5$，质量 $\\left[m_1,\\dots,m_5\\right] = \\left[1.0\\times 10^{30}, 1.0, 1.0, 1.0, 1.0\\right]$，位置（米）\n$\\mathbf{r}_1 = \\left[0.0, 0.0, 0.0\\right]$, \n$\\mathbf{r}_2 = \\left[1.0\\times 10^{11}, -2.0\\times 10^{11}, 3.0\\times 10^{11}\\right]$, \n$\\mathbf{r}_3 = \\left[-4.0\\times 10^{11}, 5.0\\times 10^{11}, -6.0\\times 10^{11}\\right]$, \n$\\mathbf{r}_4 = \\left[7.0\\times 10^{11}, -8.0\\times 10^{11}, 9.0\\times 10^{11}\\right]$, \n$\\mathbf{r}_5 = \\left[-1.0\\times 10^{11}, 2.0\\times 10^{11}, -3.0\\times 10^{11}\\right]$；速度（米每秒）\n$\\mathbf{v}_1 = \\left[0.0, 0.0, 0.0\\right]$, \n$\\mathbf{v}_2 = \\left[1.0\\times 10^{4}, -2.0\\times 10^{4}, 3.0\\times 10^{4}\\right]$, \n$\\mathbf{v}_3 = \\left[-4.0\\times 10^{4}, 5.0\\times 10^{4}, -6.0\\times 10^{4}\\right]$, \n$\\mathbf{v}_4 = \\left[7.0\\times 10^{4}, -8.0\\times 10^{4}, 9.0\\times 10^{4}\\right]$, \n$\\mathbf{v}_5 = \\left[-1.0\\times 10^{4}, 2.0\\times 10^{4}, -3.0\\times 10^{4}\\right]$。\n- 案例 D（病态求和）：$N=6$，质量 $\\left[m_1,\\dots,m_6\\right] = \\left[1.0, 1.0\\times 10^{-16}, 3.0, 1.0\\times 10^{-12}, 5.0, 1.0\\times 10^{-20}\\right]$，位置（米）\n$\\mathbf{r}_1 = \\left[1.0\\times 10^{20}, -1.0\\times 10^{-10}, 1.0\\times 10^{5}\\right]$, \n$\\mathbf{r}_2 = \\left[-1.0\\times 10^{20}, 2.0\\times 10^{-10}, -1.0\\times 10^{5}\\right]$, \n$\\mathbf{r}_3 = \\left[3.0\\times 10^{15}, -3.0\\times 10^{-5}, 3.0\\times 10^{2}\\right]$, \n$\\mathbf{r}_4 = \\left[-4.0\\times 10^{15}, 4.0\\times 10^{-5}, -4.0\\times 10^{2}\\right]$, \n$\\mathbf{r}_5 = \\left[5.0\\times 10^{10}, -5.0\\times 10^{-5}, 5.0\\times 10^{2}\\right]$, \n$\\mathbf{r}_6 = \\left[6.0\\times 10^{5}, -6.0\\times 10^{-5}, 6.0\\times 10^{2}\\right]$；速度（米每秒）\n$\\mathbf{v}_1 = \\left[1.0\\times 10^{5}, -1.0\\times 10^{-10}, 2.0\\times 10^{5}\\right]$, \n$\\mathbf{v}_2 = \\left[-1.0\\times 10^{5}, 2.0\\times 10^{-10}, -2.0\\times 10^{5}\\right]$, \n$\\mathbf{v}_3 = \\left[3.0\\times 10^{4}, -3.0\\times 10^{-5}, 6.0\\times 10^{4}\\right]$, \n$\\mathbf{v}_4 = \\left[-4.0\\times 10^{4}, 4.0\\times 10^{-5}, -8.0\\times 10^{4}\\right]$, \n$\\mathbf{v}_5 = \\left[5.0\\times 10^{3}, -5.0\\times 10^{-5}, 1.0\\times 10^{4}\\right]$, \n$\\mathbf{v}_6 = \\left[6.0\\times 10^{2}, -6.0\\times 10^{-5}, 1.2\\times 10^{3}\\right]$。\n- 案例 E（已平衡）：$N=2$，质量 $\\left[m_1,m_2\\right]=\\left[2.0, 2.0\\right]$，位置（米）\n$\\mathbf{r}_1 = \\left[1.0\\times 10^{6}, 2.0\\times 10^{6}, -3.0\\times 10^{6}\\right]$, \n$\\mathbf{r}_2 = \\left[-1.0\\times 10^{6}, -2.0\\times 10^{6}, 3.0\\times 10^{6}\\right]$；速度（米每秒）\n$\\mathbf{v}_1 = \\left[4.0\\times 10^{3}, -5.0\\times 10^{3}, 6.0\\times 10^{3}\\right]$, \n$\\mathbf{v}_2 = \\left[-4.0\\times 10^{3}, 5.0\\times 10^{3}, -6.0\\times 10^{3}\\right]$。\n\n您的程序应将您的稳健初始化过程应用于每个案例，然后输出一行包含五个布尔值的结果，按 A、B、C、D、E 的顺序指示每个案例的两个不变量是否都得到满足。使用形式为 $\\tau = c \\, \\epsilon \\, s$ 的容差，其中 $\\epsilon$ 是双精度的机器 ε，$c$ 是一个适中的常数，$s$ 是根据数据计算出的一个尺度（例如，质量加权位置或速度的 $L^1$ 或 $L^2$ 范数）。您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$\\left[\\mathrm{result}_A,\\mathrm{result}_B,\\mathrm{result}_C,\\mathrm{result}_D,\\mathrm{result}_E\\right]$）。", "solution": "该问题要求设计并实现一个数值稳健的过程，用于初始化一个 $N$ 体系统，使其质心位于原点且总线性动量为零。这两个条件，$\\sum_{i=1}^N m_i \\mathbf{r}_i = \\mathbf{0}$ 和 $\\sum_{i=1}^N m_i \\mathbf{v}_i = \\mathbf{0}$，对许多计算天体物理学模拟至关重要，因为它们将系统置于一个正则参考系中。该过程必须对浮点舍入误差具有稳健性，尤其是在处理跨越大动态范围的数据时。\n\n**1. 第一性原理与数学公式**\n\n根据牛顿力学，对于一个由 $N$ 个粒子组成的封闭系统，其质量为 $\\{m_i\\}_{i=1}^N$，位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$，速度为 $\\{\\mathbf{v}_i\\}_{i=1}^N$，质心（COM）位置 $\\mathbf{R}_{CM}$ 和速度 $\\mathbf{V}_{CM}$ 定义如下：\n$$ \\mathbf{R}_{CM} = \\frac{\\sum_{i=1}^N m_i \\mathbf{r}_i}{\\sum_{i=1}^N m_i} $$\n$$ \\mathbf{V}_{CM} = \\frac{\\sum_{i=1}^N m_i \\mathbf{v}_i}{\\sum_{i=1}^N m_i} $$\n其中总质量为 $M_{tot} = \\sum_{i=1}^N m_i$。系统的总线性动量为 $\\mathbf{P}_{tot} = M_{tot} \\mathbf{V}_{CM}$。\n\n为了强制执行不变量 $\\sum m_i \\mathbf{r}'_i = \\mathbf{0}$，我们必须将坐标系的原点移动到质心。这通过对所有粒子的位置应用一个均匀平移 $-\\mathbf{R}_{CM}$ 来实现。新的位置 $\\mathbf{r}'_i$ 为：\n$$ \\mathbf{r}'_i = \\mathbf{r}_i - \\mathbf{R}_{CM} $$\n此变换保持了所有粒子间的相对位置，因为 $\\mathbf{r}'_i - \\mathbf{r}'_j = (\\mathbf{r}_i - \\mathbf{R}_{CM}) - (\\mathbf{r}_j - \\mathbf{R}_{CM}) = \\mathbf{r}_i - \\mathbf{r}_j$。\n\n为了强制执行不变量 $\\sum m_i \\mathbf{v}'_i = \\mathbf{0}$，我们必须变换到一个质心静止的参考系。这是一个伽利略变换，通过从所有粒子的速度中减去质心速度 $\\mathbf{V}_{CM}$ 来实现。新的速度 $\\mathbf{v}'_i$ 为：\n$$ \\mathbf{v}'_i = \\mathbf{v}_i - \\mathbf{V}_{CM} $$\n此变换保持了相对速度，$\\mathbf{v}'_i - \\mathbf{v}'_j = (\\mathbf{v}_i - \\mathbf{V}_{CM}) - (\\mathbf{v}_j - \\mathbf{V}_{CM}) = \\mathbf{v}_i - \\mathbf{v}_j$，从而保留了系统的内部动力学。\n\n**2. 数值稳定性与补偿求和**\n\n聚合量 $M_{tot}$、$\\sum m_i \\mathbf{r}_i$ 和 $\\sum m_i \\mathbf{v}_i$ 的计算涉及浮点数的求和。当相加的数值量级差异巨大时，标准求和方法容易导致严重的精度损失，这种情况在天体物理学中很常见（例如，一颗恒星和它的行星）。该问题明确要求采用一种稳健的求和策略。\n\n我们将采用 Kahan 求和算法。该算法通过维护一个运行补偿变量 $c$ 来减轻舍入误差，该变量累加每次加法产生的误差。对于一个和 $S = \\sum_{k=1}^N x_k$，算法如下：\n1. 初始化和 $s \\leftarrow 0.0$ 及补偿 $c \\leftarrow 0.0$。\n2. 对于 $k=1$ 到 $N$：\n   a. $y \\leftarrow x_k - c$\n   b. $t \\leftarrow s + y$\n   c. $c \\leftarrow (t - s) - y$\n   d. $s \\leftarrow t$\n3. 返回 $s$。\n\n变量 $c$ 捕获了加法 $s+y$ 中丢失的低位比特。在下一次迭代中，这个丢失的部分会从下一个项 $x_{k+1}$ 中减去，然后再加到运行总和 $s$ 中。此过程用于计算标量总质量 $M_{tot}$ 以及向量和 $\\sum m_i \\mathbf{r}_i$ 和 $\\sum m_i \\mathbf{v}_i$ 的每个分量。\n\n**3. 算法过程与精化**\n\n即使使用稳健的求和方法，减法 $\\mathbf{r}_i - \\mathbf{R}_{CM}$ 和 $\\mathbf{v}_i - \\mathbf{V}_{CM}$ 仍可能引入新的、更小的舍入误差。为确保不变量满足到机器精度，我们实现一个两遍校正过程：\n\n**步骤 A：初始校正**\n1. 使用 Kahan 求和计算总质量 $M_{tot} = \\sum_{i=1}^N m_i$。问题陈述保证了 $m_i \\in \\mathbb{R}^+$，因此 $M_{tot}  0$。\n2. 计算质量加权位置和 $\\mathbf{P}_{pos} = \\sum_{i=1}^N m_i \\mathbf{r}_i$ 和速度和 $\\mathbf{P}_{vel} = \\sum_{i=1}^N m_i \\mathbf{v}_i$。这些向量和的每个分量都使用 Kahan 求和计算。\n3. 确定初始的质心位置和速度：$\\mathbf{R}_{CM} = \\mathbf{P}_{pos} / M_{tot}$ 和 $\\mathbf{V}_{CM} = \\mathbf{P}_{vel} / M_{tot}$。\n4. 应用主变换以获得一次校正后的状态：$\\mathbf{r}'_i = \\mathbf{r}_i - \\mathbf{R}_{CM}$ 和 $\\mathbf{v}'_i = \\mathbf{v}_i - \\mathbf{V}_{CM}$。\n\n**步骤 B：校正精化**\n1. 使用校正后的状态 $\\{\\mathbf{r}'_i, \\mathbf{v}'_i\\}$，再次使用 Kahan 求和重新计算（现在非常小的）残余质量加权和 $\\delta\\mathbf{P}_{pos} = \\sum m_i \\mathbf{r}'_i$ 和 $\\delta\\mathbf{P}_{vel} = \\sum m_i \\mathbf{v}'_i$。\n2. 计算微小的残余偏移量：$\\delta\\mathbf{R}_{CM} = \\delta\\mathbf{P}_{pos} / M_{tot}$ 和 $\\delta\\mathbf{V}_{CM} = \\delta\\mathbf{P}_{vel} / M_{tot}$。\n3. 应用最终校正：$\\mathbf{r}''_i = \\mathbf{r}'_i - \\delta\\mathbf{R}_{CM}$ 和 $\\mathbf{v}''_i = \\mathbf{v}'_i - \\delta\\mathbf{V}_{CM}$。\n\n这种两遍法能有效地将残余误差消除到浮点极限之内。对于 $N=1$ 的边界情况，该过程正确地简化为将单个粒子的位置和速度设置为 $\\mathbf{0}$。\n\n**4. 验证标准**\n\n应用该过程后，我们验证不变量是否满足到机器精度。我们计算最终的残差范数 $res_r = \\left\\|\\sum m_i \\mathbf{r}''_i\\right\\|_2$ 和 $res_v = \\left\\|\\sum m_i \\mathbf{v}''_i\\right\\|_2$。\n\n将这些残差与一个容差 $\\tau$进行比较，该容差与机器 ε $\\epsilon$ 成正比，并按问题输入的特征量级进行缩放。一个合适的尺度 $s$ 是原始求和中各项大小的总和。\n对于位置不变量，尺度为 $s_r = \\sum_{i=1}^N \\|m_i \\mathbf{r}_{i, \\text{initial}}\\|_2 = \\sum_{i=1}^N m_i \\|\\mathbf{r}_{i, \\text{initial}}\\|_2$。\n对于速度不变量，尺度为 $s_v = \\sum_{i=1}^N m_i \\|\\mathbf{v}_{i, \\text{initial}}\\|_2$。\n\n因此，容差为 $\\tau = c \\cdot \\epsilon \\cdot s$，其中 $c$ 是一个小的常数（我们选择 $c=10$），用于解释多个操作中累积的舍入误差。如果每个不变量的残差范数小于或等于其各自的容差，则验证检查成功：\n$$ res_r \\le \\tau_r \\quad \\text{and} \\quad res_v \\le \\tau_v $$\n验证中涉及的所有求和（用于尺度和最终残差计算）也使用 Kahan 求和，以确保检查本身的准确性。一个测试用例当且仅当两个不变量都满足时才通过。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef kahan_sum(arr: np.ndarray) -> float:\n    \"\"\"\n    Computes the sum of a 1D array of floats using the Kahan summation algorithm\n    to minimize numerical error.\n    \"\"\"\n    s = 0.0\n    c = 0.0\n    for i in range(arr.shape[0]):\n        x = arr[i]\n        y = x - c\n        t = s + y\n        c = (t - s) - y\n        s = t\n    return s\n\ndef kahan_sum_vec(vec_arr: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the component-wise sum of an array of vectors (N, D) using Kahan summation.\n    \"\"\"\n    if vec_arr.shape[0] == 0:\n        return np.zeros(vec_arr.shape[1], dtype=np.float64)\n    \n    s = np.zeros(vec_arr.shape[1], dtype=np.float64)\n    c = np.zeros(vec_arr.shape[1], dtype=np.float64)\n    for i in range(vec_arr.shape[0]):\n        x = vec_arr[i, :]\n        y = x - c\n        t = s + y\n        c = (t - s) - y\n        s = t\n    return s\n\ndef robust_center_procedure(masses: np.ndarray, positions: np.ndarray, velocities: np.ndarray):\n    \"\"\"\n    Applies a numerically robust transformation to enforce zero total momentum\n    and center of mass at the origin.\n    \"\"\"\n    n_bodies = masses.shape[0]\n    \n    # Handle N=0 and N=1 cases robustly.\n    # For N=1, a single body system in its COM frame is at rest at the origin.\n    if n_bodies = 1:\n        return np.zeros_like(positions), np.zeros_like(velocities)\n\n    # Use copies to preserve original data for validation scaling\n    final_positions = np.copy(positions)\n    final_velocities = np.copy(velocities)\n    \n    # Reshape mass array for broadcasting\n    m_col = masses.reshape(-1, 1)\n\n    # --- Pass 1: Initial Correction ---\n    total_mass = kahan_sum(masses)\n\n    # Compute COM position and velocity using Kahan summation\n    com_pos_numerator = kahan_sum_vec(final_positions * m_col)\n    com_vel_numerator = kahan_sum_vec(final_velocities * m_col)\n    \n    r_cm = com_pos_numerator / total_mass\n    v_cm = com_vel_numerator / total_mass\n    \n    # Apply the first correction\n    final_positions -= r_cm\n    final_velocities -= v_cm\n    \n    # --- Pass 2: Corrective Refinement ---\n    # Re-compute residual COM position and velocity from the corrected state\n    residual_pos_numerator = kahan_sum_vec(final_positions * m_col)\n    residual_vel_numerator = kahan_sum_vec(final_velocities * m_col)\n    \n    # Calculate and apply the small residual correction\n    dr_cm = residual_pos_numerator / total_mass\n    dv_cm = residual_vel_numerator / total_mass\n    \n    final_positions -= dr_cm\n    final_velocities -= dv_cm\n    \n    return final_positions, final_velocities\n\ndef validate_invariants(masses: np.ndarray, final_positions: np.ndarray, final_velocities: np.ndarray,\n                     initial_positions: np.ndarray, initial_velocities: np.ndarray) -> bool:\n    \"\"\"\n    Validates if the invariants are satisfied to machine precision.\n    \"\"\"\n    n_bodies = masses.shape[0]\n    if n_bodies == 0:\n        return True\n\n    m_col = masses.reshape(-1, 1)\n    \n    # --- Compute Final Residuals ---\n    # Use Kahan sum to accurately compute the final residual sums\n    final_pos_sum = kahan_sum_vec(final_positions * m_col)\n    final_vel_sum = kahan_sum_vec(final_velocities * m_col)\n    \n    residual_pos_norm = np.linalg.norm(final_pos_sum)\n    residual_vel_norm = np.linalg.norm(final_vel_sum)\n\n    # --- Compute Tolerances ---\n    # Define constants for tolerance calculation\n    epsilon = np.finfo(np.float64).eps\n    const_c = 10.0\n    \n    # Calculate problem scales from initial data\n    # The scale is the sum of norms of the mass-weighted vectors\n    initial_mass_pos_norms = np.linalg.norm(initial_positions * m_col, axis=1)\n    initial_mass_vel_norms = np.linalg.norm(initial_velocities * m_col, axis=1)\n\n    # Use Kahan sum to accurately calculate the scales\n    scale_pos = kahan_sum(initial_mass_pos_norms)\n    scale_vel = kahan_sum(initial_mass_vel_norms)\n    \n    # Define tolerances\n    tolerance_pos = const_c * epsilon * scale_pos\n    tolerance_vel = const_c * epsilon * scale_vel\n    \n    # --- Perform Validation Check ---\n    pos_ok = residual_pos_norm = tolerance_pos\n    vel_ok = residual_vel_norm = tolerance_vel\n\n    return pos_ok and vel_ok\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    float_type = np.float64\n    \n    test_cases = [\n        # Case A: general\n        (\n            np.array([1.0, 2.0, 3.5, 0.8, 4.2], dtype=float_type),\n            np.array([\n                [1.0e7, -2.0e7, 3.0e7], [-4.0e7, 5.0e7, -6.0e7], [7.0e7, -8.0e7, 9.0e7],\n                [-1.5e7, 2.2e7, -3.3e7], [4.4e7, -5.5e7, 6.6e7]\n            ], dtype=float_type),\n            np.array([\n                [1200.0, -2300.0, 3100.0], [-4000.0, 5100.0, -6200.0], [7300.0, -8400.0, 9500.0],\n                [-1600.0, 2200.0, -3300.0], [4400.0, -5500.0, 6600.0]\n            ], dtype=float_type)\n        ),\n        # Case B: boundary N=1\n        (\n            np.array([1.0], dtype=float_type),\n            np.array([[1.0e3, -2.0e3, 3.0e3]], dtype=float_type),\n            np.array([[-10.0, 20.0, -30.0]], dtype=float_type)\n        ),\n        # Case C: extreme mass ratio\n        (\n            np.array([1.0e30, 1.0, 1.0, 1.0, 1.0], dtype=float_type),\n            np.array([\n                [0.0, 0.0, 0.0], [1.0e11, -2.0e11, 3.0e11], [-4.0e11, 5.0e11, -6.0e11],\n                [7.0e11, -8.0e11, 9.0e11], [-1.0e11, 2.0e11, -3.0e11]\n            ], dtype=float_type),\n            np.array([\n                [0.0, 0.0, 0.0], [1.0e4, -2.0e4, 3.0e4], [-4.0e4, 5.0e4, -6.0e4],\n                [7.0e4, -8.0e4, 9.0e4], [-1.0e4, 2.0e4, -3.0e4]\n            ], dtype=float_type)\n        ),\n        # Case D: ill-conditioned sums\n        (\n            np.array([1.0, 1.0e-16, 3.0, 1.0e-12, 5.0, 1.0e-20], dtype=float_type),\n            np.array([\n                [1.0e20, -1.0e-10, 1.0e5], [-1.0e20, 2.0e-10, -1.0e5], [3.0e15, -3.0e-5, 3.0e2],\n                [-4.0e15, 4.0e-5, -4.0e2], [5.0e10, -5.0e-5, 5.0e2], [6.0e5, -6.0e-5, 6.0e2]\n            ], dtype=float_type),\n            np.array([\n                [1.0e5, -1.0e-10, 2.0e5], [-1.0e5, 2.0e-10, -2.0e5], [3.0e4, -3.0e-5, 6.0e4],\n                [-4.0e4, 4.0e-5, -8.0e4], [5.0e3, -5.0e-5, 1.0e4], [6.0e2, -6.0e-5, 1.2e3]\n            ], dtype=float_type)\n        ),\n        # Case E: already balanced\n        (\n            np.array([2.0, 2.0], dtype=float_type),\n            np.array([[1.0e6, 2.0e6, -3.0e6], [-1.0e6, -2.0e6, 3.0e6]], dtype=float_type),\n            np.array([[4.0e3, -5.0e3, 6.0e3], [-4.0e3, 5.0e3, -6.0e3]], dtype=float_type)\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        masses, initial_positions, initial_velocities = case\n        \n        final_positions, final_velocities = robust_center_procedure(\n            masses, initial_positions, initial_velocities)\n        \n        is_valid = validate_invariants(\n            masses, final_positions, final_velocities,\n            initial_positions, initial_velocities\n        )\n        results.append(is_valid)\n\n    # Format the Python boolean True/False as lowercase for the final output string.\n    formatted_results = [str(r).lower() for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3509637"}, {"introduction": "在 N 体模拟中，积分器的选择对长期模拟的准确性有着深远的影响。本实践将通过一个具有挑战性的分层三体系统，直接比较辛积分器和非辛积分器的表现。你将学习并实践一种定量方法，用于诊断数值能量误差是保持有界振荡还是出现长期漂移 ([@problem_id:3509659])。", "problem": "您的任务是编写一个完整、可运行的程序，该程序实现并执行一个数值协议，用以诊断一个分层三体（$N=3$）引力系统中的能量误差是有界的（无净漂移的振荡）还是漂移的（能量误差随时间呈系统性趋势）。该协议必须从第一性原理定义，并纯粹以数学和算法术语表达。所有计算都必须在归一化单位下进行，其中引力常数 $G=1$，所有位置、速度和时间都必须用这些相同的归一化单位表示。如果需要，角度必须以弧度表示。\n\n该系统由三个遵循牛顿引力的质点组成。其控制常微分方程（ODE）源自牛顿定律：\n- 质量为 $i$ 的星体的加速度为 $\\mathbf{a}_i = \\sum_{j \\neq i} G m_j \\dfrac{\\mathbf{r}_j - \\mathbf{r}_i}{\\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert^3}$。\n- 速度满足 $\\dfrac{d\\mathbf{r}_i}{dt} = \\mathbf{v}_i$ 且 $\\dfrac{d\\mathbf{v}_i}{dt} = \\mathbf{a}_i$。\n\n使用两个特征尺度来定义共面圆形构型中的分层三体：\n- 质量为 $m_0$ 和 $m_1$ 的内双星，其半长轴为 $a_{\\mathrm{in}}$。\n- 内双星的质心与质量为 $m_2$ 的星体之间的外轨道，其半长轴为 $a_{\\mathrm{out}}$。\n\n对于圆形轨道，半长轴为 $a$、总质量为 $M$ 的二体周期 $T$ 遵循开普勒第三定律：\n$$T = 2\\pi \\sqrt{\\frac{a^3}{G M}}.$$\n使用此公式计算内周期 $T_{\\mathrm{in}}$（其中 $M_{\\mathrm{in}} = m_0 + m_1$）和外周期 $T_{\\mathrm{out}}$（其中 $M_{\\mathrm{out}} = M_{\\mathrm{in}} + m_2$）。\n\n协议规范：\n- 需计算和采样的可观测量：\n  1. 总能量 $E(t) = K(t) + U(t)$，其中 $K(t) = \\frac{1}{2}\\sum_i m_i \\lVert \\mathbf{v}_i(t) \\rVert^2$ 且 $U(t) = -\\sum_{0 \\le i  j \\le 2} \\frac{m_i m_j}{\\lVert \\mathbf{r}_i(t) - \\mathbf{r}_j(t) \\rVert}$。\n  2. 总动量 $\\mathbf{P}(t) = \\sum_{i=0}^{2} m_i \\mathbf{v}_i(t)$。\n\n- 模拟与采样：\n  - 模拟总时长为 $T_{\\mathrm{sim}} = 3 T_{\\mathrm{out}}$。\n  - 以 $\\Delta t_{\\mathrm{samp}} = T_{\\mathrm{in}} / 50$ 的时间间隔对总能量 $E(t)$ 进行采样。\n\n- 诊断度量：\n  - 计算分数能量误差 $e(t_k) = \\dfrac{E(t_k) - E(0)}{|E(0)|}$。\n  - 对时间序列 $e(t_k)$ 进行线性最小二乘拟合，得到斜率 $s$：$e(t_k) \\approx c + s t_k$。\n  - 计算拟合的均方根残差 $\\sigma_{\\mathrm{res}}$。\n  - 将能量误差分类为“漂移”（`true`）或“有界”（`false`）。如果由斜率引起的总变化大于随机散射的3倍，即 $|s| T_{\\mathrm{sim}} > 3 \\sigma_{\\mathrm{res}}$，则分类为漂移。\n\n- 测试套件：您必须为以下四个用例运行您的协议：\n  - 用例1：KDK速度Verlet积分器，时间步长 $\\Delta t = T_{\\mathrm{in}} / 200$。\n  - 用例2：KDK速度Verlet积分器，时间步长 $\\Delta t = T_{\\mathrm{in}} / 60$。\n  - 用例3：经典四阶龙格-库塔（RK4）积分器，时间步长 $\\Delta t = T_{\\mathrm{in}} / 30$。\n  - 用例4：经典四阶龙格-库塔（RK4）积分器，时间步长 $\\Delta t = T_{\\mathrm{in}} / 50$。\n\n您的程序必须生成一行输出，其中包含一个用方括号括起来的、由逗号分隔的布尔值列表（例如，`[false,false,true,true]`），按顺序对应于四个用例的漂移诊断结果。", "solution": "我们从 $N$ 体牛顿引力的控制物理学出发。对于 $N=3$ 的质点，引力常数 $G=1$，质量为 $i$ 的星体的加速度由下式给出\n$$\\mathbf{a}_i = \\sum_{j \\neq i} m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert^3},$$\n其状态演化由常微分方程（ODE）$\\dfrac{d\\mathbf{r}_i}{dt} = \\mathbf{v}_i$ 和 $\\dfrac{d\\mathbf{v}_i}{dt} = \\mathbf{a}_i$ 描述。总能量 $E(t)$ 结合了动能 $K(t)$ 和势能 $U(t)$：\n$$K(t) = \\frac{1}{2}\\sum_{i=0}^{2} m_i \\lVert \\mathbf{v}_i(t) \\rVert^2,\\quad U(t) = -\\sum_{0 \\le i  j \\le 2} \\frac{m_i m_j}{\\lVert \\mathbf{r}_i(t) - \\mathbf{r}_j(t) \\rVert}, \\quad E(t) = K(t) + U(t).$$\n总动量为 $\\mathbf{P}(t) = \\sum_{i=0}^{2} m_i \\mathbf{v}_i(t)$。对于精确的牛顿动力学，$E(t)$ 和 $\\mathbf{P}(t)$ 是运动常数；数值积分会引入偏差，我们的目标是将其分类为有界或漂移。\n\n我们考虑一个由两个圆形轨道构成的分层三体。对于半长轴为 $a_{\\mathrm{in}}$ 的内双星 $m_0$ 和 $m_1$，其内周期为\n$$T_{\\mathrm{in}} = 2\\pi \\sqrt{\\frac{a_{\\mathrm{in}}^3}{M_{\\mathrm{in}}}}, \\quad M_{\\mathrm{in}} = m_0 + m_1.$$\n对于半长轴为 $a_{\\mathrm{out}}$ 的内双星质心和 $m_2$ 的外轨道，其外周期为\n$$T_{\\mathrm{out}} = 2\\pi \\sqrt{\\frac{a_{\\mathrm{out}}^3}{M_{\\mathrm{out}}}}, \\quad M_{\\mathrm{out}} = M_{\\mathrm{in}} + m_2.$$\n为了构建初始条件，我们首先将内双星的质心置于原点。假设内轨道在x-y平面上，粒子可以放置在x轴上，速度沿y轴。然后将外层天体 $m_2$ 放置在相对于内双星质心的位置，并赋予内双星和 $m_2$ 适当的速度以实现外层圆形轨道。最终的初始速度是内轨道运动和外轨道运动的矢量和。\n\n我们实现两种数值积分器：\n- 踢-漂移-踢（KDK）速度 Verlet：给定当前位置 $\\mathbf{r}$、速度 $\\mathbf{v}$ 和加速度 $\\mathbf{a}(\\mathbf{r})$，在时间步长 $\\Delta t$ 内的更新为\n$$\\mathbf{v}^{n+\\frac{1}{2}} = \\mathbf{v}^n + \\frac{\\Delta t}{2}\\, \\mathbf{a}(\\mathbf{r}^n), \\quad \\mathbf{r}^{n+1} = \\mathbf{r}^n + \\Delta t\\, \\mathbf{v}^{n+\\frac{1}{2}}, \\quad \\mathbf{v}^{n+1} = \\mathbf{v}^{n+\\frac{1}{2}} + \\frac{\\Delta t}{2}\\, \\mathbf{a}(\\mathbf{r}^{n+1}).$$\n该方法是辛方法，对于解析良好的时间步长，通常会产生有界的能量误差振荡。\n- 经典四阶龙格-库塔（RK4）：对于状态 $\\mathbf{y} = (\\mathbf{r}, \\mathbf{v})$，其状态导数为 $\\dot{\\mathbf{y}} = \\mathbf{f}(\\mathbf{y})$，RK4 的增量为\n$$\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}^n), \\quad \\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{y}^n + \\frac{\\Delta t}{2} \\mathbf{k}_1\\right), \\quad \\mathbf{k}_3 = \\mathbf{f}\\left(\\mathbf{y}^n + \\frac{\\Delta t}{2} \\mathbf{k}_2\\right), \\quad \\mathbf{k}_4 = \\mathbf{f}\\left(\\mathbf{y}^n + \\Delta t \\mathbf{k}_3\\right),$$\n$$\\mathbf{y}^{n+1} = \\mathbf{y}^n + \\frac{\\Delta t}{6}\\left(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4\\right).$$\nRK4 是非辛方法，对于像引力这样的哈密顿问题，即使在中等时间步长下，它也常常产生缓慢漂移的能量误差。\n\n可观测量与采样：我们在整个模拟过程中计算 $E(t)$ 和 $\\mathbf{P}(t)$。我们以 $\\Delta t_{\\mathrm{samp}} = T_{\\mathrm{in}}/50$ 的间隔进行采样，以获得离散序列 $E(t_k)$。模拟持续时间为 $T_{\\mathrm{sim}} = 3 T_{\\mathrm{out}}$，以覆盖多个外轨道周期，确保能够检测到长期趋势。\n\n诊断度量：我们定义分数能量误差 $e(t_k) = \\dfrac{E(t_k) - E(0)}{|E(0)|}$，并进行线性最小二乘（LS）拟合 $e(t_k) \\approx c + s t_k$。我们计算残差 $r_k = e(t_k) - (c + s t_k)$ 及其均方根（RMS）$\\sigma_{\\mathrm{res}} = \\sqrt{ \\dfrac{1}{N} \\sum_k r_k^2 }$。如果模拟期间由斜率引起的净变化超过随机散射的 3 倍，即 $|s| T_{\\mathrm{sim}}  3 \\sigma_{\\mathrm{res}}$，我们则将能量误差分类为漂移。否则，我们将其分类为有界。\n\n测试套件和预期：\n- 用例 1 和用例 2（KDK 速度 Verlet）分别使用 $\\Delta t = T_{\\mathrm{in}}/200$ 和 $\\Delta t = T_{\\mathrm{in}}/60$ 的时间步长，由于其辛性和适当的时间分辨率，应表现出有界的能量误差。\n- 用例 3 和用例 4（RK4）分别使用 $\\Delta t = T_{\\mathrm{in}}/30$ 和 $\\Delta t = T_{\\mathrm{in}}/50$ 的时间步长，预计会显示可检测的漂移，因为在哈密顿系统中，非辛积分会在许多步长上相干地累积微小的能量变化。\n\n算法步骤：\n1. 根据 $a_{\\mathrm{in}}$、$a_{\\mathrm{out}}$、$M_{\\mathrm{in}}$ 和 $M_{\\mathrm{out}}$ 计算 $T_{\\mathrm{in}}$ 和 $T_{\\mathrm{out}}$。\n2. 按照描述构建初始位置和速度，将内轨道运动与外质心运动相结合。\n3. 对于每个测试用例，设置积分器和 $\\Delta t$，然后将 ODE 积分到 $T_{\\mathrm{sim}}$，同时以 $\\Delta t_{\\mathrm{samp}}$ 的频率对 $E(t)$ 进行采样。\n4. 计算 $e(t_k)$，拟合最小二乘直线以获得 $s$ 和 $c$，计算 $\\sigma_{\\mathrm{res}}$，并应用漂移规则 $|s| T_{\\mathrm{sim}}  3 \\sigma_{\\mathrm{res}}$。\n5. 输出一行包含与四个用例相对应的布尔值列表。\n\n该协议将 $N$ 体模拟中能量的数值行为与守恒定律的物理学直接联系起来。作为辛方法的 Kick-Drift-Kick 方法保留了哈密顿量误差的定性有界性，而非辛的 RK4 方法则倾向于产生长期漂移。相对于 $T_{\\mathrm{in}}$ 的采样频率确保了内轨道动力学的解析度，而相对于 $T_{\\mathrm{out}}$ 的持续时间则确保了能够捕捉到外轨道的长期趋势。最小二乘斜率测试提供了一种可量化、可重现的诊断方法，对振荡有界波动具有鲁棒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nG = 1.0  # Normalized units\n\ndef gravitational_accelerations(r, m):\n    \"\"\"\n    Compute accelerations on each body due to Newtonian gravity.\n    r: (N,3) positions\n    m: (N,) masses\n    Returns a: (N,3) accelerations\n    \"\"\"\n    N = r.shape[0]\n    a = np.zeros_like(r)\n    for i in range(N):\n        # Vectorized contribution from all j != i\n        diff = r - r[i]\n        dist2 = np.sum(diff**2, axis=1)\n        mask = np.ones(N, dtype=bool)\n        mask[i] = False\n        inv_r3 = np.zeros(N)\n        # Avoid division by zero\n        inv_r3[mask] = 1.0 / (dist2[mask] ** 1.5)\n        contrib = (diff.T * (m * inv_r3)).T\n        a[i] = G * np.sum(contrib[mask], axis=0)\n    return a\n\ndef total_energy(r, v, m):\n    \"\"\"\n    Compute total energy E = K + U.\n    \"\"\"\n    # Kinetic energy\n    K = 0.5 * np.sum(m * np.sum(v*v, axis=1))\n    # Potential energy\n    U = 0.0\n    N = r.shape[0]\n    for i in range(N):\n        for j in range(i+1, N):\n            rij = r[j] - r[i]\n            dist = np.linalg.norm(rij)\n            U -= G * m[i] * m[j] / dist\n    return K + U\n\ndef total_momentum(v, m):\n    return np.sum((v.T * m).T, axis=0)\n\ndef inner_outer_periods(masses, a_in, a_out):\n    m0, m1, m2 = masses\n    M_in = m0 + m1\n    M_out = M_in + m2\n    T_in = 2.0 * np.pi * np.sqrt((a_in**3) / (G * M_in))\n    T_out = 2.0 * np.pi * np.sqrt((a_out**3) / (G * M_out))\n    return T_in, T_out, M_in, M_out\n\ndef initial_conditions(masses, a_in=1.0, a_out=10.0):\n    \"\"\"\n    Construct hierarchical triple initial conditions:\n    Inner binary m0-m1 circular, outer orbit of inner COM with m2 circular.\n    Co-planar, COM of inner at origin, m2 at (a_out, 0, 0).\n    \"\"\"\n    m0, m1, m2 = masses\n    _, _, M_in, M_out = inner_outer_periods(masses, a_in, a_out)\n    # Inner positions (relative to inner COM)\n    r0 = np.array([+a_in * m1 / M_in, 0.0, 0.0])\n    r1 = np.array([-a_in * m0 / M_in, 0.0, 0.0])\n    # Inner velocities for circular motion\n    omega_in = np.sqrt(G * M_in / (a_in**3))\n    v0_inner = np.array([0.0, +omega_in * np.linalg.norm(r0), 0.0])\n    v1_inner = np.array([0.0, -omega_in * np.linalg.norm(r1), 0.0])\n\n    # Outer placement of m2 at +x relative to total COM\n    # To place total COM at origin, inner COM and m2 must be placed relative to it.\n    r_com_inner_from_total = np.array([-a_out * m2 / M_out, 0.0, 0.0])\n    r2_from_total = np.array([+a_out * M_in / M_out, 0.0, 0.0])\n\n    r0 += r_com_inner_from_total\n    r1 += r_com_inner_from_total\n    r2 = r2_from_total\n\n    # Outer relative motion velocities\n    v_rel_out = np.sqrt(G * M_out / a_out)\n    v_com_inner_from_total = np.array([0.0, - (m2 / M_out) * v_rel_out, 0.0])\n    v2_from_total = np.array([0.0, + (M_in / M_out) * v_rel_out, 0.0])\n\n    # Inner bodies get COM velocity added\n    v0 = v0_inner + v_com_inner_from_total\n    v1 = v1_inner + v_com_inner_from_total\n    v2 = v2_from_total\n\n    r = np.vstack([r0, r1, r2])\n    v = np.vstack([v0, v1, v2])\n\n    return r, v, *inner_outer_periods(masses, a_in, a_out)[:2]\n\ndef step_leapfrog(r, v, m, dt):\n    \"\"\"\n    Kick-Drift-Kick (velocity Verlet) one step.\n    \"\"\"\n    a = gravitational_accelerations(r, m)\n    v_half = v + 0.5 * dt * a\n    r_new = r + dt * v_half\n    a_new = gravitational_accelerations(r_new, m)\n    v_new = v_half + 0.5 * dt * a_new\n    return r_new, v_new\n\ndef step_rk4(r, v, m, dt):\n    \"\"\"\n    Classical RK4 one step for Newtonian gravity.\n    State y = [r, v].\n    \"\"\"\n    def f(r_state, v_state):\n        a_state = gravitational_accelerations(r_state, m)\n        return a_state\n\n    # k1\n    a1 = gravitational_accelerations(r, m)\n    kr1 = v\n    kv1 = a1\n\n    # k2\n    r2 = r + 0.5 * dt * kr1\n    v2 = v + 0.5 * dt * kv1\n    a2 = gravitational_accelerations(r2, m)\n    kr2 = v2\n    kv2 = a2\n\n    # k3\n    r3 = r + 0.5 * dt * kr2\n    v3 = v + 0.5 * dt * kv2\n    a3 = gravitational_accelerations(r3, m)\n    kr3 = v3\n    kv3 = a3\n\n    # k4\n    r4 = r + dt * kr3\n    v4 = v + dt * kv3\n    a4 = gravitational_accelerations(r4, m)\n    kr4 = v4\n    kv4 = a4\n\n    r_new = r + (dt / 6.0) * (kr1 + 2.0 * kr2 + 2.0 * kr3 + kr4)\n    v_new = v + (dt / 6.0) * (kv1 + 2.0 * kv2 + 2.0 * kv3 + kv4)\n    return r_new, v_new\n\ndef integrate_case(integrator, dt, T_sim, T_samp, masses, r0, v0):\n    \"\"\"\n    Integrate one case and sample energy at cadence T_samp.\n    Returns times samples and energy time series.\n    \"\"\"\n    r = r0.copy()\n    v = v0.copy()\n    m = np.array(masses, dtype=float)\n    t = 0.0\n    next_sample = 0.0\n\n    energies = []\n    times = []\n\n    E0 = total_energy(r, v, m)\n\n    # Choose step function\n    if integrator == 'leapfrog':\n        step_fn = step_leapfrog\n    elif integrator == 'rk4':\n        step_fn = step_rk4\n    else:\n        raise ValueError(\"Unknown integrator\")\n\n    # Ensure we sample at t=0\n    energies.append(E0)\n    times.append(0.0)\n    next_sample += T_samp\n\n    # Main loop\n    while t  T_sim - 1e-12:\n        r, v = step_fn(r, v, m, dt)\n        t += dt\n        # Sample when crossing next_sample\n        if t + 1e-12 >= next_sample:\n            E = total_energy(r, v, m)\n            energies.append(E)\n            times.append(next_sample)  # use scheduled sample time\n            next_sample += T_samp\n\n    return np.array(times), np.array(energies)\n\ndef diagnose_drift(times, energies):\n    \"\"\"\n    Apply LS slope test to fractional energy error e(t) = (E(t)-E0)/|E0|.\n    Drifting if |s| * T_sim > 3 * sigma_res.\n    \"\"\"\n    E0 = energies[0]\n    if abs(E0) == 0: return False # Avoid division by zero\n    e = (energies - E0) / abs(E0)\n    t = times\n    # Linear fit: degree 1 polynomial\n    # polyfit returns [slope, intercept]\n    s, c = np.polyfit(t, e, 1)\n    residuals = e - (s * t + c)\n    sigma_res = np.sqrt(np.mean(residuals**2))\n    T_sim = t[-1]\n    # Avoid division by zero if sigma_res is zero\n    if sigma_res == 0:\n        return abs(s) > 0\n    drifting = abs(s) * T_sim > 3.0 * sigma_res\n    return drifting\n\ndef solve():\n    # Define masses and initial configuration\n    masses = (1.0, 1.0, 0.5)\n    a_in = 1.0\n    a_out = 10.0\n    r0, v0, T_in, T_out = initial_conditions(masses, a_in, a_out)\n\n    # Sampling cadence and duration\n    T_samp = T_in / 50.0\n    T_sim = 3.0 * T_out\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('leapfrog', 200),  # Case 1\n        ('leapfrog', 60),   # Case 2\n        ('rk4', 30),        # Case 3\n        ('rk4', 50),        # Case 4\n    ]\n\n    results = []\n    for integrator, denom in test_cases:\n        dt = T_in / float(denom)\n        times, energies = integrate_case(integrator, dt, T_sim, T_samp, masses, r0, v0)\n        drift = diagnose_drift(times, energies)\n        results.append(drift)\n\n    # Final print statement in the exact required format.\n    formatted_results = [str(r).lower() for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3509659"}, {"introduction": "尽管总能量守恒是首要的诊断指标，但其他更微妙的误差也会累积，从而降低模拟的物理真实性。本练习深入探讨了如何量化这类误差，特别是开普勒轨道中的伪进动。通过利用拉普拉斯-龙格-楞次矢量等守恒量以及频率图分析等先进技术，你将能够精确评估积分器的保真度 ([@problem_id:3509626])。", "problem": "要求您设计并实现一个自包含的程序，用于量化近开普勒轨道中仅由轨道积分器的数值角动量不守恒引起的伪拱点进动。请从以下基本依据出发：牛顿第二定律、牛顿万有引力定律，以及轨道角动量和 Laplace–Runge–Lenz 矢量的定义。假设一个质量为 $m$ 的测试粒子围绕一个引力参数为 $\\mu = G M$ 的固定中心点质量运动，并限制在平面内。除了数值积分方案本身引入的扰动外，不存在其他外部扰动。\n\n程序必须完成以下所有任务。\n\n- 在无量纲的“代码单位”（其中 $\\mu = 1$）中实现平面二体运动，并根据给定的半长轴 $a$ 和偏心率 $e$ 在近心点初始化一个有界开普勒椭圆轨道。初始位置为 $\\mathbf{r}(0) = (a (1 - e), 0)$，初始速度为 $\\mathbf{v}(0) = \\left(0, \\sqrt{\\mu \\dfrac{1 + e}{a (1 - e)}}\\right)$。使用 $a = 1$。\n\n- 使用指定的数值方案，在均匀时间网格上积分运动方程 $\\dfrac{d \\mathbf{r}}{d t} = \\mathbf{v}$ 和 $\\dfrac{d \\mathbf{v}}{d t} = - \\mu \\dfrac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^{3}}$，总时长为 $T$，步长为 $\\Delta t$。\n\n- 通过计算 $z$ 分量 $L_{z}(t) = (\\mathbf{r} \\times \\mathbf{v})_{z}$ 来诊断角动量漂移，并以无量纲浮点数的形式报告整个运行过程中的最大相对偏差，即 $\\max_{t} \\left| \\dfrac{L_{z}(t) - L_{z}(0)}{L_{z}(0)} \\right|$。\n\n- 通过使用 Laplace–Runge–Lenz (LRL) 矢量 $\\mathbf{A}(t) = \\mathbf{v}(t) \\times \\mathbf{L}(t) - \\mu \\dfrac{\\mathbf{r}(t)}{\\lVert \\mathbf{r}(t) \\rVert}$（其中 $\\mathbf{L}(t) = \\mathbf{r}(t) \\times \\mathbf{v}(t)$）来诊断伪拱点进动。在精确的开普勒二体问题中，$\\mathbf{A}(t)$ 是一个常数，指向近拱点。数值上，角动量不守恒会引起 $\\mathbf{A}(t)$ 的缓慢旋转。通过以下方法量化平均伪拱点进动率：\n  - 将 $r(t) = \\lVert \\mathbf{r}(t) \\rVert$ 的局部最小值作为连续的近心点通过事件来检测。\n  - 在每个近心点记录 $\\mathbf{A}$ 的平面内夹角 $\\varpi_{k}$（使用 $\\mathrm{atan2}$ 计算平面内夹角）。\n  - 计算每个轨道的平均绝对变化量 $\\langle \\Delta \\varpi \\rangle = \\dfrac{1}{N_{\\mathrm{orb}} - 1} \\sum_{k=1}^{N_{\\mathrm{orb}} - 1} \\left| \\operatorname{unwrap}\\left(\\varpi_{k+1} - \\varpi_{k}\\right) \\right|$，以弧度/轨道为单位表示。\n\n- 执行频率图分析，估计时间序列的前半部分和后半部分中的基本径向角频率和方位角频率，并报告它们的扩散情况。具体操作如下：\n  - 通过 $r(t) - \\langle r \\rangle$ 的离散傅里叶变换中的主峰值计算基本径向角频率 $\\omega_{r}$，其中峰值取自正频率，并通过乘以 $2 \\pi$ 转换为角频率。\n  - 将基本方位角频率 $\\omega_{\\theta}$ 计算为展开的极角 $\\theta(t) = \\mathrm{atan2}(y(t), x(t))$ 对时间 $t$ 的最佳拟合斜率（通过最小二乘法）。\n  - 分别在积分区间的上半部分和下半部分评估这些频率，以获得 $(\\omega_{r}^{(1)}, \\omega_{\\theta}^{(1)})$ 和 $(\\omega_{r}^{(2)}, \\omega_{\\theta}^{(2)})$。\n  - 报告频率图扩散度量 $D_{\\mathrm{FMA}} = \\sqrt{\\left(\\omega_{r}^{(2)} - \\omega_{r}^{(1)}\\right)^{2} + \\left(\\omega_{\\theta}^{(2)} - \\omega_{\\theta}^{(1)}\\right)^{2}}$，单位为所选代码单位的逆时间单位。\n\n使用以下测试套件，其中包含指定的积分器、偏心率和步长。所有情况的总时长均为 $T = 50 \\times P$，其中 $P = 2 \\pi \\sqrt{\\dfrac{a^{3}}{\\mu}}$ 是所采用单位下的开普勒轨道周期。对于下述每种情况，$\\Delta t$ 被指定为 $P$ 的一个分数，使用前应转换为代码时间单位。所有角度必须以弧度表示。除扩散度量 $D_{\\mathrm{FMA}}$（单位为逆时间单位）外，所有报告值必须是无量纲的。\n\n- 案例1（理想情况，使用辛几何方案的近开普勒椭圆轨道）：\n  - 积分器：velocity-Verlet（也称为 leapfrog）。\n  - 偏心率：$e = 0.1$。\n  - 时间步长：$\\Delta t = P / 1000$。\n\n- 案例2（使用非辛几何方案和粗略步长以引发较大误差）：\n  - 积分器：forward Euler。\n  - 偏心率：$e = 0.1$。\n  - 时间步长：$\\Delta t = P / 200$。\n\n- 案例3（使用高阶非辛几何方案处理高偏心率的边缘情况）：\n  - 积分器：classical fourth-order Runge–Kutta。\n  - 偏心率：$e = 0.6$。\n  - 时间步长：$\\Delta t = P / 1000$。\n\n对于每种情况，您的程序必须输出一个包含三个浮点数的列表：\n- 最大相对角动量偏差 $\\max_{t} \\left| \\dfrac{L_{z}(t) - L_{z}(0)}{L_{z}(0)} \\right|$ (无量纲)。\n- 每个轨道的平均拱点进动 $\\langle \\Delta \\varpi \\rangle$ (以弧度/轨道为单位)。\n- 频率图扩散度量 $D_{\\mathrm{FMA}}$ (以逆时间单位为单位)。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个三元素列表，按上述顺序和单位排列，对应于按顺序列出的三个测试案例。例如，一个带有占位符的输出将如下所示：$[\\,[x_{1},y_{1},z_{1}],\\,[x_{2},y_{2},z_{2}],\\,[x_{3},y_{3},z_{3}]\\,]$。所有浮点数都应以标准十进制表示法呈现，不带单位。不得打印任何额外文本。", "solution": "该问题要求对数值积分器在模拟开普勒二体问题时的保真度进行定量分析。其核心在于理解，尽管能量守恒是重要的，但其他守恒量的破坏同样能揭示积分器的缺陷。本解答将遵循问题的要求，阐述其物理基础、诊断方法和算法实现。\n\n### 物理基础与守恒量\n对于一个围绕固定中心质量运动的测试粒子，如果受到的力严格遵守平方反比定律（即牛顿引力），其运动轨迹是解析可解的开普勒轨道。除了总能量 $E$ 之外，该系统还拥有两个额外的矢量守恒量：\n1.  **角动量矢量** $\\mathbf{L} = \\mathbf{r} \\times \\mathbf{v}$：该矢量的守恒意味着轨道被限制在一个固定的平面内。\n2.  **拉普拉斯-龙格-楞次 (LRL) 矢量** $\\mathbf{A} = \\mathbf{v} \\times \\mathbf{L} - \\mu \\frac{\\mathbf{r}}{r}$：该矢量从中心质量指向轨道的近心点（轨道上距离中心最近的点），其大小与偏心率 $e$ 成正比。$\\mathbf{A}$ 的守恒意味着轨道的方向在空间中是固定的，即轨道是闭合的，没有进动。\n\n当使用数值积分器时，由于离散化误差，计算出的力不再是完美的平方反比形式。这些微小的误差如同一种“数值扰动”，会破坏 $\\mathbf{L}$ 和 $\\mathbf{A}$ 的守恒性。\n\n### 诊断方法实现\n程序实现了三种诊断方法来量化这些数值误差的影响：\n\n1.  **角动量漂移**: 这是最直接的检验。对于平面运动，我们只需监测角动量垂直于平面的分量 $L_z$。通过计算其在整个模拟过程中的最大相对偏差 $\\max |(L_z(t) - L_z(0))/L_z(0)|$，我们可以衡量积分器保持轨道平面的能力。非辛积分器（如前向欧拉法）通常会导致 $L_z$ 的系统性漂移。\n\n2.  **伪拱点进动**: LRL矢量 $\\mathbf{A}$ 的方向固定性是开普勒问题的一个独有特性。当数值误差导致 $\\mathbf{A}$ 不再守恒时，它会在轨道平面内缓慢旋转。这种旋转的直接后果就是轨道自身的旋转，即“拱点进动”。为了量化这一点，程序首先通过寻找径向距离 $r(t)$ 的局部极小值来识别出一系列的近心点通过事件。然后，在每个近心点时刻，计算LRL矢量 $\\mathbf{A}$ 的方向角 $\\varpi_k$。相邻近心点之间的角度变化量 $\\Delta\\varpi$ 就代表了一次轨道周期内的进动量。通过对多次轨道的进动量求平均，我们得到了一个稳健的平均进动率（以弧度/轨道为单位）。\n\n3.  **频率图分析 (FMA)**: 这是一种更精细的诊断技术。对于理想的闭合开普勒轨道，粒子完成一次径向振荡（从近心点到远心点再返回）的时间与完成一次 $2\\pi$ 方位角扫描的时间是完全相同的。这意味着径向频率 $\\omega_r$ 和方位角频率 $\\omega_\\theta$ 是相等的（$\\omega_r = \\omega_\\theta$）。数值误差会打破这种简并性，导致频率发生微小的分离和漂移。FMA通过将整个时间序列分成两半来量化这种漂移。在每一半中，程序分别计算 $\\omega_r$（通过对 $r(t)$ 进行快速傅里叶变换(FFT)并找到主频率峰值得出）和 $\\omega_\\theta$（通过对展开的极角 $\\theta(t)$ 进行线性拟合得到斜率）。最后，计算两组频率 $(\\omega_{r}^{(1)}, \\omega_{\\theta}^{(1)})$ 和 $(\\omega_{r}^{(2)}, \\omega_{\\theta}^{(2)})$ 在频率平面上的距离 $D_{\\mathrm{FMA}}$，它为积分器长期稳定性提供了一个灵敏的度量。\n\n### 测试案例分析\n- **速度-Verlet法 (辛积分器)**：作为一种辛几何积分器，它能很好地保持系统的几何结构。预期其角动量误差和LRL矢量误差都将保持有界振荡，因此进动率和频率扩散会非常小。\n- **前向欧拉法 (非辛积分器)**：这是一个简单但性能差的积分器。预期它会产生巨大的能量和角动量漂移，导致轨道快速发散，进动率和频率扩散指标会非常大。\n- **经典四阶龙格-库塔法 (RK4)**：作为一种高阶非辛方法，它在短时间内非常精确。然而，对于长期哈密顿系统积分，微小的能量误差会逐渐累积，导致守恒量的缓慢漂移。在高偏心率下，轨道在近心点附近速度极快，对积分器的挑战更大。预期RK4的表现将远优于欧拉法，但其长期稳定性（尤其是在进动和频率漂移方面）将不如辛的Verlet法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and analysis for all test cases.\n    \"\"\"\n\n    def acceleration(r, mu=1.0):\n        \"\"\"Computes gravitational acceleration: a = -mu*r / |r|^3.\"\"\"\n        r_norm = np.linalg.norm(r)\n        if r_norm == 0:\n            return np.zeros_like(r)\n        return -mu * r / r_norm**3\n\n    def forward_euler_step(r, v, dt, mu=1.0):\n        \"\"\"Performs a single step of the Forward Euler integrator.\"\"\"\n        a = acceleration(r, mu)\n        r_new = r + v * dt\n        v_new = v + a * dt\n        return r_new, v_new\n\n    def velocity_verlet_step(r, v, dt, mu=1.0):\n        \"\"\"Performs a single step of the Velocity-Verlet integrator.\"\"\"\n        a = acceleration(r, mu)\n        r_new = r + v * dt + 0.5 * a * dt**2\n        a_new = acceleration(r_new, mu)\n        v_new = v + 0.5 * (a + a_new) * dt\n        return r_new, v_new\n\n    def rk4_step(r, v, dt, mu=1.0):\n        \"\"\"Performs a single step of the Classical RK4 integrator.\"\"\"\n        # k1\n        k1r = v\n        k1v = acceleration(r, mu)\n        \n        # k2\n        k2r = v + 0.5 * dt * k1v\n        k2v = acceleration(r + 0.5 * dt * k1r, mu)\n\n        # k3\n        k3r = v + 0.5 * dt * k2v\n        k3v = acceleration(r + 0.5 * dt * k2r, mu)\n\n        # k4\n        k4r = v + dt * k3v\n        k4v = acceleration(r + dt * k3r, mu)\n        \n        # Update\n        r_new = r + (dt / 6.0) * (k1r + 2.0 * k2r + 2.0 * k3r + k4r)\n        v_new = v + (dt / 6.0) * (k1v + 2.0 * k2v + 2.0 * k3v + k4v)\n        \n        return r_new, v_new\n\n    integrator_map = {\n        \"velocity-Verlet\": velocity_verlet_step,\n        \"forward Euler\": forward_euler_step,\n        \"classical fourth-order Runge–Kutta\": rk4_step,\n    }\n\n    def run_integration(integrator, r0, v0, T, dt, mu=1.0):\n        \"\"\"Integrates the orbit and returns the time series of phase space.\"\"\"\n        num_steps = int(T / dt)\n        times = np.linspace(0, T, num_steps + 1)\n        r, v = np.copy(r0), np.copy(v0)\n        \n        # Pre-allocate arrays\n        history_r = np.zeros((num_steps + 1, 2))\n        history_v = np.zeros((num_steps + 1, 2))\n        history_r[0], history_v[0] = r, v\n\n        for i in range(num_steps):\n            r, v = integrator(r, v, dt, mu)\n            history_r[i+1], history_v[i+1] = r, v\n        \n        return times, history_r, history_v\n\n    def analyze_trajectory(times, history_r, history_v, a, mu=1.0):\n        \"\"\"Performs all required diagnostic calculations on a trajectory.\"\"\"\n        \n        # 1. Angular Momentum Deviation\n        Lz = history_r[:, 0] * history_v[:, 1] - history_r[:, 1] * history_v[:, 0]\n        Lz0 = Lz[0]\n        if Lz0 == 0:\n            max_rel_L_dev = np.inf if np.any(Lz != 0) else 0.0\n        else:\n            max_rel_L_dev = np.max(np.abs((Lz - Lz0) / Lz0))\n\n        # 2. Apsidal Precession\n        r_norm = np.linalg.norm(history_r, axis=1)\n        \n        P = 2 * np.pi * np.sqrt(a**3 / mu)\n        dt = times[1] - times[0]\n        peak_dist = 0.8 * (P / dt)\n        \n        pericenter_indices, _ = find_peaks(-r_norm, distance=peak_dist)\n        \n        if len(pericenter_indices)  2:\n            mean_d_varpi = 0.0\n        else:\n            r_peri = history_r[pericenter_indices]\n            v_peri = history_v[pericenter_indices]\n            \n            L_vectors = np.cross(np.hstack([r_peri, np.zeros((len(r_peri), 1))]), \n                                 np.hstack([v_peri, np.zeros((len(v_peri), 1))]))\n            \n            v_peri_3d = np.hstack([v_peri, np.zeros((len(v_peri), 1))])\n            r_peri_3d = np.hstack([r_peri, np.zeros((len(r_peri), 1))])\n            r_peri_norm_3d = np.linalg.norm(r_peri_3d, axis=1)[:, np.newaxis]\n\n            A_vectors = np.cross(v_peri_3d, L_vectors) - mu * r_peri_3d / r_peri_norm_3d\n            \n            varpi_angles = np.arctan2(A_vectors[:, 1], A_vectors[:, 0])\n            unwrapped_varpi = np.unwrap(varpi_angles)\n            \n            mean_d_varpi = np.mean(np.abs(np.diff(unwrapped_varpi)))\n        \n        # 3. Frequency-Map Analysis (FMA)\n        def get_frequencies(t_series, r_series):\n            if len(t_series)  2:\n                return 0.0, 0.0\n            # Radial frequency from FFT\n            r_norm_series = np.linalg.norm(r_series, axis=1)\n            signal = r_norm_series - np.mean(r_norm_series)\n            fft_vals = np.fft.rfft(signal)\n            fft_freq = np.fft.rfftfreq(len(t_series), d=t_series[1] - t_series[0])\n            if len(fft_vals) > 1:\n                peak_idx = np.argmax(np.abs(fft_vals[1:])) + 1\n                omega_r = 2 * np.pi * fft_freq[peak_idx]\n            else:\n                omega_r = 0.0\n\n            # Azimuthal frequency from linear fit to unwrapped angle\n            theta = np.unwrap(np.arctan2(r_series[:, 1], r_series[:, 0]))\n            if len(t_series) > 1:\n                coeffs = np.polyfit(t_series, theta, 1)\n                omega_theta = coeffs[0]\n            else:\n                omega_theta = 0.0\n\n            return omega_r, omega_theta\n\n        n_pts = len(times)\n        mid_pt = n_pts // 2\n        \n        omega_r1, omega_theta1 = get_frequencies(times[:mid_pt], history_r[:mid_pt])\n        omega_r2, omega_theta2 = get_frequencies(times[mid_pt:], history_r[mid_pt:])\n\n        D_FMA = np.sqrt((omega_r2 - omega_r1)**2 + (omega_theta2 - omega_theta1)**2)\n\n        return max_rel_L_dev, mean_d_varpi, D_FMA\n\n    # Test suite parameters\n    test_cases = [\n        {\"name\": \"Case 1\", \"integrator\": \"velocity-Verlet\", \"e\": 0.1, \"dt_frac\": 1.0/1000.0},\n        {\"name\": \"Case 2\", \"integrator\": \"forward Euler\", \"e\": 0.1, \"dt_frac\": 1.0/200.0},\n        {\"name\": \"Case 3\", \"integrator\": \"classical fourth-order Runge–Kutta\", \"e\": 0.6, \"dt_frac\": 1.0/1000.0},\n    ]\n\n    results = []\n    mu = 1.0\n    a = 1.0\n    \n    for case in test_cases:\n        e = case[\"e\"]\n        \n        # Initial conditions at pericenter\n        r0 = np.array([a * (1 - e), 0.0])\n        v0_mag = np.sqrt(mu * (1 + e) / (a * (1 - e)))\n        v0 = np.array([0.0, v0_mag])\n        \n        # Time parameters\n        P = 2 * np.pi * np.sqrt(a**3 / mu)\n        T = 50 * P\n        dt = P * case[\"dt_frac\"]\n        \n        # Run simulation\n        integrator_func = integrator_map[case[\"integrator\"]]\n        times, history_r, history_v = run_integration(integrator_func, r0, v0, T, dt, mu)\n        \n        # Analyze and store results\n        res_tuple = analyze_trajectory(times, history_r, history_v, a, mu)\n        results.append(list(res_tuple))\n\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3509626"}]}