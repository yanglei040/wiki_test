{"hands_on_practices": [{"introduction": "构建模拟星表的第一步是定义其所代表的宇宙学体积。本练习将可观测的量——红移（$z$），通过Friedmann方程与物理量——共动距离（$\\chi$）联系起来。掌握这项基本计算是将理论上的数密度转换为特定巡天体积内预期星系数的关键步骤[@problem_id:3512721]。", "problem": "您正在为一个模拟测光巡天构建一个模拟星系表。为了将目标共动数密度转换为薄红移切片中每立体角的期望计数，您需要给定红移下该切片的共动径向厚度。考虑一个空间平坦的Lambda冷暗物质（ΛCDM）宇宙学模型，其物质密度参数为 $\\Omega_{m}=0.3$，暗能量密度参数为 $\\Omega_{\\Lambda}=0.7$，哈勃常数为 $H_{0}=70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$。假设在相关红移处辐射密度可忽略不计，且空间是平坦的，因此 $\\Omega_{m}+\\Omega_{\\Lambda}=1$。使用共动径向距离的定义和ΛCDM宇宙学模型中的弗里德曼方程，推导一个宽度为 $\\Delta z$、中心在 $z=1$ 处的红移切片的共动径向厚度 $\\Delta \\chi$ 的一阶表达式，并计算其在 $\\Delta z=0.1$ 时的数值。使用光速 $c=2.99792458\\times 10^{5}\\,\\mathrm{km\\,s^{-1}}$。将您的最终数值答案以百万秒差距（Mpc）为单位表示，并四舍五入到四位有效数字。", "solution": "在空间平坦的Friedmann–Lemaître–Robertson–Walker时空中，共动径向距离定义为\n$$\n\\chi(z)=c\\int_{0}^{z}\\frac{dz'}{H(z')}\\,,\n$$\n其中 $c$ 是光速，$H(z)$ 是依赖于红移的哈勃参数。对于一个中心在 $z$、宽度为 $\\Delta z$ 的薄红移切片，当 $\\Delta z$ 的高阶项可忽略时，其共动径向厚度的一阶近似由下式给出\n$$\n\\Delta \\chi \\approx \\left.\\frac{d\\chi}{dz}\\right|_{z}\\,\\Delta z = \\frac{c}{H(z)}\\,\\Delta z\\,.\n$$\n因此，任务简化为在给定的宇宙学模型中计算 $z=1$ 处的 $H(z)$。对于一个空间平坦的Lambda冷暗物质（ΛCDM）宇宙学模型，其物质密度参数为 $\\Omega_{m}$，暗能量密度参数为 $\\Omega_{\\Lambda}$（假设辐射可忽略不计），弗里德曼方程给出\n$$\nH(z)=H_{0}\\,\\sqrt{\\Omega_{m}(1+z)^{3}+\\Omega_{\\Lambda}}\\,.\n$$\n使用给定的参数在 $z=1$ 处进行计算，\n$$\nH(1)=H_{0}\\,\\sqrt{\\Omega_{m}(1+1)^{3}+\\Omega_{\\Lambda}}=H_{0}\\,\\sqrt{\\Omega_{m}\\cdot 8+\\Omega_{\\Lambda}}=70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}\\times \\sqrt{0.3\\times 8+0.7}\\,.\n$$\n计算平方根内的参数：\n$$\n0.3\\times 8+0.7=2.4+0.7=3.1\\,,\n$$\n所以\n$$\nH(1)=70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}\\times \\sqrt{3.1}\\,.\n$$\n因此，\n$$\n\\Delta \\chi \\approx \\frac{c}{H(1)}\\,\\Delta z=\\frac{2.99792458\\times 10^{5}\\,\\mathrm{km\\,s^{-1}}}{70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}\\,\\sqrt{3.1}}\\times 0.1\\,.\n$$\n消去单位 $\\mathrm{km\\,s^{-1}}$ 并简化前置因子，\n$$\n\\Delta \\chi = \\frac{2.99792458\\times 10^{5}}{70\\,\\sqrt{3.1}}\\,\\mathrm{Mpc}\\times 0.1\\,.\n$$\n现在分步进行数值计算，在最终计算前保留符号常量：\n- 符号计算然后数值计算 $\\sqrt{3.1}$：$\\sqrt{3.1}\\approx 1.7606816861659$。\n- 计算 $H(1)=70\\times \\sqrt{3.1}\\approx 70\\times 1.7606816861659\\approx 123.247718031613\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$。\n- 计算 $c/H(1)\\approx \\frac{2.99792458\\times 10^{5}}{123.247718031613}\\,\\mathrm{Mpc}\\approx 2432.438205\\,\\mathrm{Mpc}$。\n- 乘以 $\\Delta z=0.1$：\n$$\n\\Delta \\chi \\approx 243.2438205\\,\\mathrm{Mpc}\\,.\n$$\n根据要求四舍五入到四位有效数字，得到\n$$\n\\Delta \\chi \\approx 243.2\\,\\mathrm{Mpc}\\,.\n$$", "answer": "$$\\boxed{243.2}$$", "id": "3512721"}, {"introduction": "真实的巡天观测无法探测到所有星系；其观测能力受到仪器灵敏度的限制，而灵敏度在天空中可能并非处处相同。本实践通过结合一个内在的星系族群模型与一个仪器探测模型来计算巡天的完备性（completeness）。通过完成此练习，您将学会如何量化最重要的选择效应之一，从而能够创建出能真实模拟实际巡天偏差的模拟星表[@problem_id:3512735]。", "problem": "给定一个由 Hierarchical Equal Area isoLatitude Pixelization (HEALPix) 图描述的人造天空，对于每个由其角中心 $\\vec{\\theta}_i$ 索引的像素，该图存储了单个巡天波段中的局部 $5\\sigma$ 深度极限星等，记为 $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$。假设一个星系总体的真实视星等 $m$ 在有界区间 $[m_{\\min}, m_{\\max}]$ 上遵循微分数量计数模型 $p(m)$ 分布，并假设星等的仪器测量噪声是高斯分布的。具体来说，给定真实星等 $m$ 的条件下，测量星等 $m_{\\mathrm{meas}}$ 是一个均值为 $m$、标准差为 $\\sigma_m$ 的正态随机变量，并且当且仅当 $m_{\\mathrm{meas}} \\le m_{\\mathrm{lim}}(\\vec{\\theta})$ 时，一个源被探测到。将局域完备度 $C(\\vec{\\theta})$ 定义为在位置 $\\vec{\\theta}$ 处探测到的内禀星系总体的比例，该比例是在真实星等分布上，在区间 $[m_{\\min}, m_{\\max}]$ 内平均得到的。\n\n从概率论和上述指定的高斯模型出发，推导一个用关于 $m$ 的积分表示的 $C(\\vec{\\theta})$ 的表达式，并实现一个数值算法，该算法在给定 $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$ 的 HEALPix 图以及 $p(m)$ 和 $\\sigma_m$ 的参数的情况下，计算图中每个像素 $i$ 的 $C(\\vec{\\theta}_i)$。对于本问题，设星等分布为\n$$\np(m) \\propto 10^{\\beta m} \\quad \\text{for} \\quad m \\in [m_{\\min}, m_{\\max}],\n$$\n在该区间外 $p(m) = 0$。比例常数无需明确确定，因为 $C(\\vec{\\theta})$ 是一个积分之比，任何常数归一化因子都会被消去。\n\n您的程序必须为下面指定的每个测试用例计算 $C(\\vec{\\theta}_i)$，并将所有测试用例的结果输出到单行上，格式为一个逗号分隔的 Python 风格列表，其元素是浮点数列表，每个内部列表对应一个测试用例，并按与输入 $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$ 值相同的顺序包含每个像素的完备度值。将每个完备度值四舍五入到小数点后 $4$ 位。不需要进行物理单位转换，因为根据定义，天文星等是无量纲的；角度 $\\vec{\\theta}$ 不直接用于计算，但如果引用任何角度，应以弧度为单位。探测阈值规则是本问题中使用的唯一仪器模型。\n\n使用以下测试套件实现解决方案，其中每个测试用例提供了 HEALPix 像素的极限星等 $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$、$p(m)$ 的斜率参数 $\\beta$、星等边界 $m_{\\min}$ 和 $m_{\\max}$，以及测量噪声 $\\sigma_m$：\n\n- 测试用例 1 (一般情况，不同深度):\n  - $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$: $\\left[24.5, 24.0, 23.0, 25.5\\right]$\n  - $\\beta = 0.6$\n  - $m_{\\min} = 20.0$, $m_{\\max} = 26.0$\n  - $\\sigma_m = 0.1$\n\n- 测试用例 2 (亮端边界，预期完备度低):\n  - $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$: $\\left[21.0, 21.5\\right]$\n  - $\\beta = 0.6$\n  - $m_{\\min} = 20.0$, $m_{\\max} = 26.0$\n  - $\\sigma_m = 0.05$\n\n- 测试用例 3 (暗端情况，预期完备度高):\n  - $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$: $\\left[26.0, 26.5, 27.0\\right]$\n  - $\\beta = 0.4$\n  - $m_{\\min} = 20.0$, $m_{\\max} = 27.0$\n  - $\\sigma_m = 0.2$\n\n- 测试用例 4 (星等均匀分布, $\\beta = 0$):\n  - $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$: $\\left[24.0, 25.0, 26.0\\right]$\n  - $\\beta = 0.0$\n  - $m_{\\min} = 22.0$, $m_{\\max} = 26.0$\n  - $\\sigma_m = 0.2$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是对应于一个测试用例的列表。例如，输出应类似于 $\\left[[c_{1,1}, c_{1,2}, \\dots], [c_{2,1}, c_{2,2}, \\dots], \\dots\\right]$，其中每个 $c_{t,i}$ 是一个四舍五入到小数点后 $4$ 位的浮点数。", "solution": "用户提供的问题是有效的。它在科学上基于观测天文学和统计分析的原理，问题本身是适定的，所有必要的参数都有定义，并且以客观、正式的语言表述。它代表了天体物理学中为刻画巡天选择效应而执行的一种标准计算。\n\n该问题要求推导并实现一个局域完备度 $C(\\vec{\\theta})$ 的公式，该完备度定义为在特定天空位置 $\\vec{\\theta}$ 探测到的内禀星系总体的比例。探测受到极限星等 $m_{\\mathrm{lim}}(\\vec{\\theta})$ 和高斯测量噪声的影响。\n\n首先，我们将计算的各个组成部分形式化。星系真实视星等 $m$ 的内禀分布由一个数量计数模型 $p(m)$ 给出，该模型仅在区间 $[m_{\\min}, m_{\\max}]$ 上非零。问题指定在此区间上 $p(m) \\propto 10^{\\beta m}$。从该分布中抽取一个星系。然后测量其星等，得到一个值 $m_{\\mathrm{meas}}$。该测量值是一个随机变量，遵循均值为真实星等 $m$、标准差为 $\\sigma_m$ 的正态分布。我们可以将其写为 $P(m_{\\mathrm{meas}} | m) = \\mathcal{N}(m, \\sigma_m^2)$。当且仅当测量星等小于或等于局域极限星等时，即 $m_{\\mathrm{meas}} \\le m_{\\mathrm{lim}}(\\vec{\\theta})$，一个星系被探测到。\n\n在给定真实星等 $m$ 和局域极限星等 $m_{\\mathrm{lim}} \\equiv m_{\\mathrm{lim}}(\\vec{\\theta})$ 的条件下，探测到星系的概率是 $P(m_{\\mathrm{meas}} \\le m_{\\mathrm{lim}} | m)$。这由正态分布 $\\mathcal{N}(m, \\sigma_m^2)$ 的累积分布函数 (CDF) 在 $m_{\\mathrm{lim}}$ 处的值给出。\n$$ P(\\text{detection}|m, m_{\\mathrm{lim}}) = \\int_{-\\infty}^{m_{\\mathrm{lim}}} \\frac{1}{\\sqrt{2\\pi}\\sigma_m} \\exp\\left(-\\frac{(x-m)^2}{2\\sigma_m^2}\\right) dx $$\n通过变量替换 $z = (x-m)/\\sigma_m$，该积分变为标准正态分布的累积分布函数 $\\Phi(z)$ 在 $z = (m_{\\mathrm{lim}} - m)/\\sigma_m$ 处的值。\n$$ P(\\text{detection}|m, m_{\\mathrm{lim}}) = \\Phi\\left(\\frac{m_{\\mathrm{lim}} - m}{\\sigma_m}\\right) $$\n标准正态累积分布函数 $\\Phi(z)$ 与误差函数 $\\text{erf}(x)$ 通过恒等式 $\\Phi(z) = \\frac{1}{2}\\left(1 + \\text{erf}\\left(\\frac{z}{\\sqrt{2}}\\right)\\right)$ 相关联。将此代入我们的表达式中，得到探测概率：\n$$ P(\\text{detection}|m, m_{\\mathrm{lim}}) = \\frac{1}{2}\\left(1 + \\text{erf}\\left(\\frac{m_{\\mathrm{lim}} - m}{\\sqrt{2}\\sigma_m}\\right)\\right) $$\n\n完备度 $C(\\vec{\\theta})$ 是探测到的星系的总比例，即探测概率 $P(\\text{detection}|m, m_{\\mathrm{lim}})$ 由内禀星等分布 $p(m)$ 加权的平均值。它被计算为探测到的星系数量与星系总数之比。用概率密度表示，该比率为：\n$$ C(m_{\\mathrm{lim}}) = \\frac{\\int_{m_{\\min}}^{m_{\\max}} p(m) P(\\text{detection}|m, m_{\\mathrm{lim}}) \\,dm}{\\int_{m_{\\min}}^{m_{\\max}} p(m) \\,dm} $$\n请注意，对 $\\vec{\\theta}$ 的依赖完全通过 $m_{\\mathrm{lim}}(\\vec{\\theta})$ 体现，因此我们写作 $C(m_{\\mathrm{lim}})$。代入 $p(m)$ 和探测概率的表达式，我们得到：\n$$ C(m_{\\mathrm{lim}}) = \\frac{\\int_{m_{\\min}}^{m_{\\max}} 10^{\\beta m} \\cdot \\frac{1}{2}\\left(1 + \\text{erf}\\left(\\frac{m_{\\mathrm{lim}} - m}{\\sqrt{2}\\sigma_m}\\right)\\right) \\,dm}{\\int_{m_{\\min}}^{m_{\\max}} 10^{\\beta m} \\,dm} $$\n$p(m)$ 的比例常数在分子和分母中是相同的，因此它会消去，正如问题中所述。\n\n分母可以解析求解。积分为 $\\int 10^{\\beta m} dm = \\int e^{\\beta m \\ln(10)} dm$。\n对于 $\\beta \\neq 0$：\n$$ \\int_{m_{\\min}}^{m_{\\max}} 10^{\\beta m} \\,dm = \\left[ \\frac{10^{\\beta m}}{\\beta \\ln(10)} \\right]_{m_{\\min}}^{m_{\\max}} = \\frac{10^{\\beta m_{\\max}} - 10^{\\beta m_{\\min}}}{\\beta \\ln(10)} $$\n对于特殊情况 $\\beta = 0$，被积函数为 $10^0 = 1$，所以积分就是：\n$$ \\int_{m_{\\min}}^{m_{\\max}} 1 \\,dm = m_{\\max} - m_{\\min} $$\n\n分子，\n$$ I_{\\text{num}} = \\int_{m_{\\min}}^{m_{\\max}} 10^{\\beta m} \\cdot \\frac{1}{2}\\left(1 + \\text{erf}\\left(\\frac{m_{\\mathrm{lim}} - m}{\\sqrt{2}\\sigma_m}\\right)\\right) \\,dm $$\n没有一个简单的闭式解析解，必须使用数值积分来计算。\n\n解决该问题的算法如下：\n1. 对于每个测试用例，解析输入参数：极限星等列表 $\\{m_{\\mathrm{lim},i}\\}$、斜率 $\\beta$、边界 $m_{\\min}$ 和 $m_{\\max}$，以及噪声 $\\sigma_m$。\n2. 对于列表中的每个 $m_{\\mathrm{lim},i}$：\n    a. 将分子的被积函数定义为 $m$ 的函数, $f(m) = 10^{\\beta m} \\cdot \\frac{1}{2}\\left(1 + \\text{erf}\\left(\\frac{m_{\\mathrm{lim},i} - m}{\\sqrt{2}\\sigma_m}\\right)\\right)$。\n    b. 对 $f(m)$ 从 $m_{\\min}$到 $m_{\\max}$ 进行数值积分，得到分子 $I_{\\text{num}}$。\n    c. 使用给定 $\\beta$ 的适当公式解析计算分母 $I_{\\text{den}}$。\n    d. 计算完备度 $C_i = I_{\\text{num}} / I_{\\text{den}}$。\n    e. 将结果四舍五入到小数点后 $4$ 位。\n3. 将每个测试用例计算出的完备度值收集到一个列表中。\n4. 将所有测试用例的列表组合成一个最终的列表的列表。\n该过程将使用 Python 实现，其中 `scipy.integrate.quad` 函数用于数值积分，`scipy.special.erf` 用于误差函数。", "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the galaxy completeness problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1: general case, varied depths\n        {'m_lims': [24.5, 24.0, 23.0, 25.5], 'beta': 0.6, 'm_min': 20.0, 'm_max': 26.0, 'sigma_m': 0.1},\n        # Test Case 2: bright-limit boundary, expected low completeness\n        {'m_lims': [21.0, 21.5], 'beta': 0.6, 'm_min': 20.0, 'm_max': 26.0, 'sigma_m': 0.05},\n        # Test Case 3: faint-limit case, expected high completeness\n        {'m_lims': [26.0, 26.5, 27.0], 'beta': 0.4, 'm_min': 20.0, 'm_max': 27.0, 'sigma_m': 0.2},\n        # Test Case 4: uniform distribution across magnitudes, beta = 0\n        {'m_lims': [24.0, 25.0, 26.0], 'beta': 0.0, 'm_min': 22.0, 'm_max': 26.0, 'sigma_m': 0.2},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        m_lims = case['m_lims']\n        beta = case['beta']\n        m_min = case['m_min']\n        m_max = case['m_max']\n        sigma_m = case['sigma_m']\n        \n        case_results = []\n        \n        # Calculate the denominator integral once per test case\n        if beta == 0.0:\n            denominator = m_max - m_min\n        else:\n            log_10 = np.log(10)\n            denominator = (10**(beta * m_max) - 10**(beta * m_min)) / (beta * log_10)\n\n        if denominator == 0:\n            # This case should not be reached with the given inputs, but is a safeguard.\n            # If the denominator is 0, it means no galaxies in the range, so completeness is ill-defined.\n            # We can treat it as 0 detected galaxies out of 0 total, or just set completeness to 0.\n            case_results = [0.0] * len(m_lims)\n            all_results.append(case_results)\n            continue\n            \n        for m_lim in m_lims:\n            # Define the integrand for the numerator\n            def numerator_integrand(m):\n                # Unnormalized galaxy number counts p(m)\n                p_m = 10**(beta * m)\n                \n                # Detection probability P(detection|m)\n                arg_erf = (m_lim - m) / (np.sqrt(2) * sigma_m)\n                p_det = 0.5 * (1.0 + erf(arg_erf))\n                \n                return p_m * p_det\n\n            # Numerically integrate the numerator\n            # The second return value of quad is the error estimate, which we ignore.\n            numerator, _ = quad(numerator_integrand, m_min, m_max)\n            \n            # Calculate completeness\n            completeness = numerator / denominator\n            case_results.append(round(completeness, 4))\n            \n        all_results.append(case_results)\n\n    # Print the final result in the exact specified format.\n    # The default str() representation of a list of lists is \"[[], [], ...]\" which is a valid Python-style list format.\n    print(all_results)\n\nsolve()\n```", "id": "3512735"}, {"introduction": "在天空的稠密区域，来自多个星系的光可能会重叠，这种现象被称为“混合”（blending），它会干扰测量结果。这项高级练习将指导您建立一个正向模型，用以模拟混合现象，并量化其对弱引力透镜剪切和光度红移等关键宇宙学测量的影响。此实践展示了利用合成观测在诊断和校准影响精确宇宙学的复杂系统误差方面的强大能力[@problem_id:3512765]。", "problem": "您的任务是构建一个正向建模管道，为拥挤的双星系场生成合成观测数据，将光度混合效应传播到形状和光度红移估计中，并量化宇宙剪切和星系-星系引力透镜信号中的偏差。您将在一个简化但科学上一致且自洽的环境中工作，该环境使用一个源星系（“目标”）与一个邻近星系混合。目标和邻近星系具有二维高斯表面亮度剖面，通过高斯点扩展函数（PSF）进行观测。假设存在弱引力透镜剪切。程序必须从第一性原理出发，实现以下建模元素和计算。\n\n建模假设与基本依据：\n\n- 每个星系的表面亮度被建模为具有各向同性协方差的二维高斯分布。对于索引为 $i$ 的星系，在给定波段的总流量为 $F_i$，内禀各向同性尺寸参数为 $s_i$（以任意像素单位计），其（关于其自身形心的）未卷积二阶矩张量为 $$\\mathbf{S}_i = s_i^2 \\mathbf{I},$$ 其中 $\\mathbf{I}$ 是 $2 \\times 2$ 单位矩阵。PSF 是具有各向同性协方差的高斯函数 $$\\mathbf{P} = \\sigma_{\\mathrm{psf}}^2 \\mathbf{I}.$$\n- 两个高斯函数的卷积结果是一个新的高斯函数，其协方差等于原协方差之和。因此，星系 $i$ 卷积后的二阶矩张量为 $$\\mathbf{Q}_i = \\mathbf{S}_i + \\mathbf{P}.$$\n- 在弱引力透镜机制中，对于小的约化剪切 $(g_1, g_2)$ 和零会聚，通过一阶线性化来近似二阶矩的映射。设 $$\\mathbf{G} = \\begin{pmatrix} g_1  g_2 \\\\ g_2  -g_1 \\end{pmatrix}, \\quad \\mathbf{A} = \\mathbf{I} + \\mathbf{G}.$$ 剪切后的二阶矩张量为 $$\\mathbf{Q}_i' = \\mathbf{A}\\,\\mathbf{Q}_i\\,\\mathbf{A}^\\top.$$\n- 混合光分布是两个高斯分量的线性叠加。设目标星系的形心为 $\\mathbf{x}_t = (0, 0)$，邻近星系的形心为 $\\mathbf{x}_n = (d, 0)$，即邻近星系位于 $x$ 轴上，相距为 $d$。在给定波段 $B$ 中，流量分别为 $F_{t,B}$ 和 $F_{n,B}$，则流量加权的混合形心为 $$\\bar{\\mathbf{x}}_B = \\frac{F_{t,B}\\,\\mathbf{x}_t + F_{n,B}\\,\\mathbf{x}_n}{F_{t,B} + F_{n,B}}.$$ 关于 $\\bar{\\mathbf{x}}_B$ 的混合二阶矩张量是各分量二阶矩的流量加权和，再加上形心偏移的贡献，$$\\mathbf{M}_B = \\frac{F_{t,B}\\left(\\mathbf{Q}_t' + (\\mathbf{x}_t - \\bar{\\mathbf{x}}_B)(\\mathbf{x}_t - \\bar{\\mathbf{x}}_B)^\\top\\right) + F_{n,B}\\left(\\mathbf{Q}_n' + (\\mathbf{x}_n - \\bar{\\mathbf{x}}_B)(\\mathbf{x}_n - \\bar{\\mathbf{x}}_B)^\\top\\right)}{F_{t,B} + F_{n,B}}.$$\n- 使用标准的二阶矩椭率定义，从混合二阶矩（在形状测量波段）中定义椭率分量 $(e_1, e_2)$，分母中使用迹来归一化各向异性。对仅有目标星系的情况使用相同定义，以获得在剪切作用下、无混合时的基准“真实”椭率。\n- 光度红移是根据由 $r$ 和 $i$ 两个波段构建的单一色指数来估计的。设色指数为 $$C = -2.5\\,\\log_{10}\\left(\\frac{F_r}{F_i}\\right),$$ 使用这些波段中的总混合流量，并估计 $$\\hat{z} = a\\,C + b,$$ 其中 $a$ 和 $b$ 是固定的定标参数。\n- 对于星系-星系引力透镜，测得的超表面密度 $\\Delta\\Sigma$ 与真实切向剪切和临界表面密度 $\\Sigma_{\\mathrm{crit}}$ 的乘积成正比。在平坦、低红移近似下，使用与红移成正比的角直径距离，即 $$D(z) \\propto z,$$ 因此 $$\\Sigma_{\\mathrm{crit}}(z_l, z_s) \\propto \\frac{D(z_s)}{D(z_l)\\left[D(z_s) - D(z_l)\\right]} = \\frac{z_s}{z_l\\,(z_s - z_l)}.$$ 由剪切定标和光度红移误差引起的 $\\Delta\\Sigma$ 的分数偏差为 $$\\delta_{\\Delta\\Sigma} = (1 + m)\\,\\frac{\\Sigma_{\\mathrm{crit}}(z_l, \\hat{z})}{\\Sigma_{\\mathrm{crit}}(z_l, z_t)} - 1,$$ 其中 $m$ 是下面定义的乘性剪切偏差，$z_l$ 是透镜红移，$z_t$ 是目标的真实源红移，$\\hat{z}$ 是从混合色指数估计的光度红移。\n\n每个测试案例需要计算的量：\n\n1. 计算仅有目标星系在形状波段 $i$ 中的二阶矩张量、其在剪切作用下的椭率 $(e_{1,\\mathrm{true}}, e_{2,\\mathrm{true}})$，以及使用波段 $i$ 中的流量计算的混合二阶矩张量和椭率 $(e_{1,\\mathrm{obs}}, e_{2,\\mathrm{obs}})$。\n2. 通过关系 $$\\mathbf{e}_{\\mathrm{obs}} = (1 + m)\\,\\mathbf{e}_{\\mathrm{true}} + \\mathbf{c},$$ 定义乘性剪切偏差 $m$ 和加性剪切偏差矢量 $\\mathbf{c} = (c_1, c_2)$，并计算它们。将 $m$ 视为沿 $\\mathbf{e}_{\\mathrm{true}}$ 方向最小化残差平方的标量（即 $$m = \\frac{\\mathbf{e}_{\\mathrm{obs}} \\cdot \\mathbf{e}_{\\mathrm{true}}}{\\mathbf{e}_{\\mathrm{true}} \\cdot \\mathbf{e}_{\\mathrm{true}}} - 1$$），且 $$\\mathbf{c} = \\mathbf{e}_{\\mathrm{obs}} - (1 + m)\\,\\mathbf{e}_{\\mathrm{true}}.$$\n3. 计算光度红移偏差 $$\\delta z = \\hat{z} - z_t,$$ 其中 $z_t$ 是目标的真实源红移，$\\hat{z}$ 是根据上述色指数定义从混合光中得到的估计值。\n4. 在低红移近似下，使用简化的临界表面密度标度关系计算星系-星系引力透镜中的分数偏差 $$\\delta_{\\Delta\\Sigma}$$。\n\n测试套件：\n\n使用以下四个测试案例，每个案例均以参数元组的形式给出，顺序为 $(s_t, s_n, F_{t,i}, F_{t,r}, F_{n,i}, F_{n,r}, d, \\sigma_{\\mathrm{psf}}, g_1, g_2, z_t, z_l, a, b)$:\n\n- 案例 A（一般拥挤场混合）：(1.0, 0.8, 1.0, 0.6, 0.3, 0.9, 0.5, 0.5, 0.02, -0.01, 0.7, 0.3, -1.2, 0.8)。\n- 案例 B（近乎完全重叠）：(0.9, 0.9, 1.2, 0.7, 1.0, 1.5, 0.0, 0.7, 0.03, 0.0, 0.6, 0.3, -1.2, 0.8)。\n- 案例 C（邻近星系遥远，混合极小）：(1.0, 1.0, 1.0, 0.8, 0.5, 0.5, 5.0, 0.6, 0.01, 0.01, 0.5, 0.2, -1.2, 0.8)。\n- 案例 D（仅光度污染，在 $i$ 波段无形状混合）：(1.1, 0.7, 1.0, 0.9, 0.0, 1.0, 2.0, 0.5, 0.02, 0.02, 0.65, 0.25, -1.2, 0.8)。\n\n您的程序必须：\n\n- 使用双精度浮点算术，以数值稳定的方式实现上述建模和计算。\n- 对于每个测试案例，输出列表 $[m, c_1, c_2, \\delta z, \\delta_{\\Delta\\Sigma}]$。\n- 将所有四个测试案例的结果汇总到一行：一个用方括号括起来的逗号分隔列表，其中每个元素是上述的单个案例列表。例如，一个有效的输出格式为 `[[x_1, x_2, x_3, x_4, x_5], [y_1, y_2, y_3, y_4, y_5], [z_1, z_2, z_3, z_4, z_5], [w_1, w_2, w_3, w_4, w_5]]`。\n\n所有输出均为无量纲浮点数。最终答案中不需要物理单位或角度单位。您的实现必须是自洽的，且无需外部输入。使用的缩写词为点扩展函数（PSF）、星系-星系引力透镜（GGL）。", "solution": "该问题经评估有效。它以成熟的星系形状、透镜效应和混合模型为科学基础，尽管经过了简化。该问题是良置的、自洽的，并为计算唯一解提供了所有必要的数据和定义。测试案例旨在探测参数空间中不同的、具有物理意义的区域。\n\n解决方案通过系统地实现问题陈述中描述的正向模型链来展开。对于每个由参数元组 $(s_t, s_n, F_{t,i}, F_{t,r}, F_{n,i}, F_{n,r}, d, \\sigma_{\\mathrm{psf}}, g_1, g_2, z_t, z_l, a, b)$ 指定的测试案例，我们计算五个所需的量：乘性剪切偏差 $m$、加性剪切偏差分量 $(c_1, c_2)$、光度红移偏差 $\\delta z$ 以及分数形式的星系-星系引力透镜偏差 $\\delta_{\\Delta\\Sigma}$。\n\n**1. 初步定义**\n我们定义基本的矩阵和向量。$2 \\times 2$ 单位矩阵为 $\\mathbf{I}$。弱引力透镜剪切由矩阵 $\\mathbf{G}$ 描述，相应的线性变换矩阵为 $\\mathbf{A}$：\n$$\n\\mathbf{G} = \\begin{pmatrix} g_1  g_2 \\\\ g_2  -g_1 \\end{pmatrix}, \\quad \\mathbf{A} = \\mathbf{I} + \\mathbf{G}\n$$\n目标星系和邻近星系的形心分别为 $\\mathbf{x}_t = (0, 0)^\\top$ 和 $\\mathbf{x}_n = (d, 0)^\\top$。\n\n**2. 内禀和剪切后的星系属性**\n目标星系（$t$）和邻近星系（$n$）的未卷积二阶矩张量为 $\\mathbf{S}_t = s_t^2 \\mathbf{I}$ 和 $\\mathbf{S}_n = s_n^2 \\mathbf{I}$。点扩展函数（PSF）由其二阶矩张量 $\\mathbf{P} = \\sigma_{\\mathrm{psf}}^2 \\mathbf{I}$ 建模。\n卷积后（孤立观测时）的二阶矩张量是内禀协方差与 PSF 协方差之和：\n$$\n\\mathbf{Q}_t = \\mathbf{S}_t + \\mathbf{P} = (s_t^2 + \\sigma_{\\mathrm{psf}}^2) \\mathbf{I} \\\\\n\\mathbf{Q}_n = \\mathbf{S}_n + \\mathbf{P} = (s_n^2 + \\sigma_{\\mathrm{psf}}^2) \\mathbf{I}\n$$\n然后，这些矩受到弱引力透镜剪切的变换。假设两个星系位于同一源平面，并受到相同的剪切影响，它们剪切后的二阶矩张量为：\n$$\n\\mathbf{Q}_t' = \\mathbf{A}\\,\\mathbf{Q}_t\\,\\mathbf{A}^\\top \\quad \\text{和} \\quad \\mathbf{Q}_n' = \\mathbf{A}\\,\\mathbf{Q}_n\\,\\mathbf{A}^\\top\n$$\n\n**3. 无混合时的“真实”椭率**\n基准或“真实”椭率 $\\mathbf{e}_{\\mathrm{true}} = (e_{1,\\mathrm{true}}, e_{2,\\mathrm{true}})$ 对应于单独为目标星系测量的、经过剪切和卷积后的形状。它使用标准的二阶矩椭率定义从 $\\mathbf{Q}_t'$ 计算得出：\n$$\ne_{1,\\mathrm{true}} = \\frac{Q'_{t,11} - Q'_{t,22}}{\\mathrm{Tr}(\\mathbf{Q}_t')}, \\quad e_{2,\\mathrm{true}} = \\frac{2 Q'_{t,12}}{\\mathrm{Tr}(\\mathbf{Q}_t')}\n$$\n其中 $\\mathrm{Tr}(\\mathbf{Q}_t') = Q'_{t,11} + Q'_{t,22}$。\n\n**4. 混合属性和“观测”椭率**\n当两个星系混合时，总的光分布是一个叠加。形状测量在 $i$ 波段进行。该波段的总流量为 $F_{\\mathrm{tot},i} = F_{t,i} + F_{n,i}$。混合天体的流量加权形心为：\n$$\n\\bar{\\mathbf{x}}_i = \\frac{F_{t,i}\\,\\mathbf{x}_t + F_{n,i}\\,\\mathbf{x}_n}{F_{\\mathrm{tot},i}} = \\left(\\frac{F_{n,i} d}{F_{t,i} + F_{n,i}}, 0\\right)^\\top\n$$\n混合二阶矩张量 $\\mathbf{M}_i$ 是关于这个新形心计算的，使用了适用于混合成分的平行轴定理：\n$$\n\\mathbf{M}_i = \\frac{F_{t,i}\\left(\\mathbf{Q}_t' + (\\mathbf{x}_t - \\bar{\\mathbf{x}}_i)(\\mathbf{x}_t - \\bar{\\mathbf{x}}_i)^\\top\\right) + F_{n,i}\\left(\\mathbf{Q}_n' + (\\mathbf{x}_n - \\bar{\\mathbf{x}}_i)(\\mathbf{x}_n - \\bar{\\mathbf{x}}_i)^\\top\\right)}{F_{t,i} + F_{n,i}}\n$$\n混合天体的“观测”椭率 $\\mathbf{e}_{\\mathrm{obs}} = (e_{1,\\mathrm{obs}}, e_{2,\\mathrm{obs}})$ 是从 $\\mathbf{M}_i$ 计算得出的：\n$$\ne_{1,\\mathrm{obs}} = \\frac{M_{i,11} - M_{i,22}}{\\mathrm{Tr}(\\mathbf{M}_i)}, \\quad e_{2,\\mathrm{obs}} = \\frac{2 M_{i,12}}{\\mathrm{Tr}(\\mathbf{M}_i)}\n$$\n\n**5. 剪切定标偏差（$m$ 和 $c$）**\n乘性偏差 $m$ 和加性偏差 $\\mathbf{c}=(c_1, c_2)$ 通过将观测椭率建模为真实椭率的线性变换来定义：$\\mathbf{e}_{\\mathrm{obs}} = (1 + m)\\,\\mathbf{e}_{\\mathrm{true}} + \\mathbf{c}$。使用所提供的定义，我们计算：\n$$\nm = \\frac{\\mathbf{e}_{\\mathrm{obs}} \\cdot \\mathbf{e}_{\\mathrm{true}}}{\\mathbf{e}_{\\mathrm{true}} \\cdot \\mathbf{e}_{\\mathrm{true}}} - 1\n$$\n$$\n\\mathbf{c} = \\mathbf{e}_{\\mathrm{obs}} - (1 + m)\\,\\mathbf{e}_{\\mathrm{true}}\n$$\n\n**6. 光度红移偏差（$\\delta z$）**\n光度红移估计 $\\hat{z}$ 基于 $r$ 和 $i$ 波段总混合流量的色指数：$F_{\\mathrm{tot},r} = F_{t,r} + F_{n,r}$ 和 $F_{\\mathrm{tot},i} = F_{t,i} + F_{n,i}$。色指数 $C$ 和估计的红移 $\\hat{z}$ 为：\n$$\nC = -2.5\\,\\log_{10}\\left(\\frac{F_{\\mathrm{tot},r}}{F_{\\mathrm{tot},i}}\\right)\n$$\n$$\n\\hat{z} = a\\,C + b\n$$\n光度红移偏差是估计红移与目标星系真实红移之差：\n$$\n\\delta z = \\hat{z} - z_t\n$$\n\n**7. 星系-星系引力透镜偏差（$\\delta_{\\Delta\\Sigma}$）**\n星系-星系引力透镜信号的分数偏差 $\\delta_{\\Delta\\Sigma}$ 结合了剪切定标偏差（$m$）和光度红移偏差的影响。该偏差取决于在真实源红移 $z_t$ 和估计红移 $\\hat{z}$ 处计算的临界表面密度 $\\Sigma_{\\mathrm{crit}}$ 的比率。使用给定的低红移近似 $\\Sigma_{\\mathrm{crit}}(z_l, z_s) \\propto \\frac{z_s}{z_l\\,(z_s - z_l)}$，该比率为：\n$$\n\\frac{\\Sigma_{\\mathrm{crit}}(z_l, \\hat{z})}{\\Sigma_{\\mathrm{crit}}(z_l, z_t)} = \\frac{\\hat{z}}{z_l(\\hat{z} - z_l)} \\cdot \\frac{z_l(z_t - z_l)}{z_t} = \\frac{\\hat{z}(z_t - z_l)}{z_t(\\hat{z} - z_l)}\n$$\n最终的分数偏差为：\n$$\n\\delta_{\\Delta\\Sigma} = (1 + m)\\,\\frac{\\Sigma_{\\mathrm{crit}}(z_l, \\hat{z})}{\\Sigma_{\\mathrm{crit}}(z_l, z_t)} - 1 = (1 + m)\\,\\frac{\\hat{z}(z_t - z_l)}{z_t(\\hat{z} - z_l)} - 1\n$$\n对每个测试案例评估此公式，以获得最终所需的量。计算对所有测试案例都是可行的，因为对于所有提供的输入，都有 $\\hat{z} > z_l$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and print results for all test cases.\n    \"\"\"\n    # Test cases parameters are provided in the following order:\n    # (s_t, s_n, F_ti, F_tr, F_ni, F_nr, d, sigma_psf, g1, g2, z_t, z_l, a, b)\n    test_cases = [\n        # Case A (general crowded-field blending)\n        (1.0, 0.8, 1.0, 0.6, 0.3, 0.9, 0.5, 0.5, 0.02, -0.01, 0.7, 0.3, -1.2, 0.8),\n        # Case B (near-complete overlap)\n        (0.9, 0.9, 1.2, 0.7, 1.0, 1.5, 0.0, 0.7, 0.03, 0.0, 0.6, 0.3, -1.2, 0.8),\n        # Case C (neighbor far away, minimal blending)\n        (1.0, 1.0, 1.0, 0.8, 0.5, 0.5, 5.0, 0.6, 0.01, 0.01, 0.5, 0.2, -1.2, 0.8),\n        # Case D (photometric contamination only, no shape blending in i)\n        (1.1, 0.7, 1.0, 0.9, 0.0, 1.0, 2.0, 0.5, 0.02, 0.02, 0.65, 0.25, -1.2, 0.8)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_biases_for_case(case)\n        # Format each number in the list to a consistent representation if needed,\n        # but Python's default float representation is fine.\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists in Python matches the required format.\n    # Using the suggested template's join method for robustness.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_biases_for_case(params):\n    \"\"\"\n    Computes all specified biases for a single test case.\n    \"\"\"\n    s_t, s_n, f_ti, f_tr, f_ni, f_nr, d, sigma_psf, g1, g2, z_t, z_l, a, b = params\n\n    # Use double-precision floating-point arithmetic (numpy default)\n    I = np.identity(2)\n    xt = np.array([0.0, 0.0])\n    xn = np.array([d, 0.0])\n\n    G = np.array([[g1, g2], [g2, -g1]])\n    A = I + G\n\n    # 1. Compute target-only properties and true ellipticity\n    Q_t = (s_t**2 + sigma_psf**2) * I\n    Q_t_prime = A @ Q_t @ A.T\n    \n    trace_qt = np.trace(Q_t_prime)\n    e1_true = (Q_t_prime[0, 0] - Q_t_prime[1, 1]) / trace_qt\n    e2_true = 2 * Q_t_prime[0, 1] / trace_qt\n    e_true = np.array([e1_true, e2_true])\n    \n    # 2. Compute blended properties and observed ellipticity\n    # Convolved, sheared second moments for neighbor\n    Q_n = (s_n**2 + sigma_psf**2) * I\n    Q_n_prime = A @ Q_n @ A.T\n\n    # Total flux in i-band for shape measurement\n    f_tot_i = f_ti + f_ni\n\n    if f_tot_i == 0.0:\n        # Avoid division by zero, though not expected for these test cases.\n        # If total flux is zero, the object is unobservable.\n        # Biases would be ill-defined. Return NaNs or handle as error.\n        # For this problem, we can assume f_tot_i > 0.\n        pass\n\n    # Blended centroid in i-band\n    x_bar_i = (f_ti * xt + f_ni * xn) / f_tot_i\n\n    # Parallel axis theorem terms (outer products)\n    xt_offset = xt - x_bar_i\n    xn_offset = xn - x_bar_i\n    v_t = np.outer(xt_offset, xt_offset)\n    v_n = np.outer(xn_offset, xn_offset)\n\n    # Blended second-moment tensor in i-band\n    M_i = (f_ti * (Q_t_prime + v_t) + f_ni * (Q_n_prime + v_n)) / f_tot_i\n\n    # Observed ellipticity from blended moments\n    trace_mi = np.trace(M_i)\n    e1_obs = (M_i[0, 0] - M_i[1, 1]) / trace_mi\n    e2_obs = 2 * M_i[0, 1] / trace_mi\n    e_obs = np.array([e1_obs, e2_obs])\n    \n    # 3. Compute shear calibration biases (m, c)\n    e_true_sq_norm = np.dot(e_true, e_true)\n    if e_true_sq_norm == 0.0:\n       # if g1=g2=0, e_true is zero, m is ill-defined.\n       # Problem constraints ensure g1,g2 are not both zero.\n       m = 0.0\n    else:\n       m = np.dot(e_obs, e_true) / e_true_sq_norm - 1.0\n\n    c = e_obs - (1 + m) * e_true\n    c1, c2 = c[0], c[1]\n\n    # 4. Compute photometric redshift bias (delta_z)\n    f_tot_r = f_tr + f_nr\n    if f_tot_i = 0 or f_tot_r = 0: # Physical fluxes must be positive\n        # Handle log of non-positive number. Not expected in test cases.\n        delta_z = np.nan\n    else:\n        color = -2.5 * np.log10(f_tot_r / f_tot_i)\n        z_hat = a * color + b\n        delta_z = z_hat - z_t\n\n    # 5. Compute GGL bias (delta_DeltaSigma)\n    if z_hat = z_l or z_t = z_l:\n        # Unphysical configuration or division by zero. Not in test cases.\n        delta_DeltaSigma = np.nan\n    else:\n        # Ratio of critical surface density scaling factors\n        sigma_crit_ratio = (z_hat * (z_t - z_l)) / (z_t * (z_hat - z_l))\n        delta_DeltaSigma = (1 + m) * sigma_crit_ratio - 1.0\n        \n    return [m, c1, c2, delta_z, delta_DeltaSigma]\n\nsolve()\n```", "id": "3512765"}]}