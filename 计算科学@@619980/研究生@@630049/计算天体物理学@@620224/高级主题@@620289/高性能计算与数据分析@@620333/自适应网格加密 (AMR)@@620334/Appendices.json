{"hands_on_practices": [{"introduction": "自适应网格加密（AMR）的核心思想是将计算资源集中在最需要的区域。但我们如何识别这些区域呢？本练习介绍了一种基本技术：通过比较不同分辨率网格上的解来估计局部截断误差。通过推导基于Richardson外推的误差估计器，您将理解驱动现代模拟代码中自适应加密的理论引擎。[@problem_id:3503443]", "problem": "考虑一维空间中的标量双曲守恒律，其写为在控制体上的积分形式，并使用形式精度阶为 $p \\geq 1$ 的有限体积格式进行离散。在自适应网格加密（AMR）中，其中自适应网格加密（AMR）表示使用整数加密比的动态、分层网格加密，一种常见的做法是通过比较嵌套网格上的解来估计局部截断误差，以驱动加密决策。\n\n设均匀粗网格的网格间距为 $h$，嵌套在其中的细网格的网格间距为 $h/r$，其中整数加密比 $r > 1$。用 $u$ 表示在给定单元覆盖区域上的精确单元平均解，用 $u_h$ 表示在粗网格上计算并限制在公共覆盖区域上的数值单元平均解，用 $u_{h/r}$ 表示在细网格上计算并同样进行限制的数值单元平均解。假设存在渐近误差展开\n$$\nu_h = u + C h^{p} + \\mathcal{O}\\!\\left(h^{p+1}\\right), \\qquad\nu_{h/r} = u + C \\left(\\frac{h}{r}\\right)^{p} + \\mathcal{O}\\!\\left(h^{p+1}\\right),\n$$\n其中 $C$ 是一个不依赖于 $h$ 或 $r$ 但可能依赖于位置、时间和解的正则性的光滑系数。\n\n仅使用这些渐近展开和形式精度阶的定义，为给定位置的细网格解 $u_{h/r}$ 定义一个基于理查森外推的截断误差估计器，该估计器仅用 $u_h$、$u_{h/r}$、$r$ 和 $p$ 表示。推导在 $h \\to 0$ 且 $r$ 固定的渐近区域中，该估计器如何随加密比 $r$ 和形式精度阶 $p$ 缩放。您的最终答案必须是该估计器的单个闭式解析表达式。无需进行数值计算。", "solution": "对光滑解的有限体积离散允许存在一个体现形式精度阶的渐近误差展开。形式精度阶 $p$ 的定义是主导离散误差按 $h^{p}$ 缩放，因此网格尺寸为 $h$ 上的数值解满足\n$$\nu_h = u + C h^{p} + \\mathcal{O}\\!\\left(h^{p+1}\\right),\n$$\n其中某个系数 $C$ 与 $h$ 无关，并且在加密比 $r$ 固定的情况下，也与 $r$ 无关。在间距为 $h/r$ 的加密网格上，类似的展开式为\n$$\nu_{h/r} = u + C \\left(\\frac{h}{r}\\right)^{p} + \\mathcal{O}\\!\\left(h^{p+1}\\right).\n$$\n将这两个展开式相减，可以消去未知的精确解 $u$，并分离出对 $h$、$r$ 和 $p$ 的主导阶依赖关系：\n$$\nu_h - u_{h/r} = \\left[u + C h^{p} + \\mathcal{O}\\!\\left(h^{p+1}\\right)\\right] - \\left[u + C \\left(\\frac{h}{r}\\right)^{p} + \\mathcal{O}\\!\\left(h^{p+1}\\right)\\right].\n$$\n因此，\n$$\nu_h - u_{h/r} = C h^{p} - C h^{p} r^{-p} + \\mathcal{O}\\!\\left(h^{p+1}\\right) = C h^{p} \\left(1 - r^{-p}\\right) + \\mathcal{O}\\!\\left(h^{p+1}\\right).\n$$\n我们所关心的细网格解的截断误差是细网格上的主导阶离散误差，\n$$\ne_{h/r} \\equiv u - u_{h/r} = -\\,C \\left(\\frac{h}{r}\\right)^{p} + \\mathcal{O}\\!\\left(h^{p+1}\\right).\n$$\n我们可以通过这两个关系式消去未知的 $C h^{p}$。由差值式，\n$$\nC h^{p} = \\frac{u_h - u_{h/r}}{1 - r^{-p}} + \\mathcal{O}\\!\\left(h\\right),\n$$\n代入细网格误差得到\n$$\ne_{h/r} = -\\,\\left(\\frac{h}{r}\\right)^{p} \\frac{u_h - u_{h/r}}{h^{p}\\left(1 - r^{-p}\\right)} + \\mathcal{O}\\!\\left(h^{p+1}\\right)\n= -\\,\\frac{r^{-p}}{1 - r^{-p}}\\left(u_h - u_{h/r}\\right) + \\mathcal{O}\\!\\left(h^{p+1}\\right).\n$$\n注意到以下关系，可以将乘法因子写得更清晰\n$$\n\\frac{r^{-p}}{1 - r^{-p}} = \\frac{1}{r^{p} - 1}.\n$$\n因此，细网格解的主导阶截断误差为\n$$\ne_{h/r} = \\frac{u_h - u_{h/r}}{r^{p} - 1} + \\mathcal{O}\\!\\left(h^{p+1}\\right).\n$$\n这导出了一个基于理查森外推的截断误差估计器，它使用粗细网格解之差，\n$$\n\\widehat{e}_{h/r} \\equiv \\frac{u_h - u_{h/r}}{r^{p} - 1}.\n$$\n它随加密比 $r$ 和阶数 $p$ 的缩放关系可直接得出：原始的粗细网格解之差 $u_h - u_{h/r}$ 的缩放行为类似于 $h^{p}\\left(1 - r^{-p}\\right)$，而估计器除以 $r^{p} - 1$，得到主导依赖关系 $\\widehat{e}_{h/r} \\sim C h^{p} r^{-p}$，即相对于粗网格误差，细网格截断误差与 $r^{-p}$ 成比例衰减，这与 $p$ 阶精度一致。在 $h \\to 0$ 且 $r$ 固定的渐近区域中，高阶项 $\\mathcal{O}\\!\\left(h^{p+1}\\right)$ 消失，估计器收敛到真实的主导阶截断误差：\n$$\n\\widehat{e}_{h/r} \\to e_{h/r} \\quad \\text{as} \\quad h \\to 0.\n$$\n因此，所求的仅用 $u_h$、$u_{h/r}$、$r$ 和 $p$ 表示的闭式估计器是\n$$\n\\widehat{e}_{h/r} = \\frac{u_h - u_{h/r}}{r^{p} - 1}.\n$$", "answer": "$$\\boxed{\\frac{u_h - u_{h/r}}{r^{p} - 1}}$$", "id": "3503443"}, {"introduction": "一旦某个区域被标记为需要加密，我们必须从现有的粗网格数据为新的细网格生成初始数据，这一过程称为延拓（prolongation）。为了保持物理准确性和数值稳定性，尤其是在激波等尖锐特征附近，这个过程必须是守恒的，并避免产生虚假的振荡。本实践将指导您使用斜率限制器实现一个先进的延拓方案，这是高分辨率激波捕捉方法的基石。[@problem_id:3503480]", "problem": "考虑在计算天体物理学背景下，具有接触间断的可压缩流密度的一维有限体积表示。自适应网格加密 (AMR) 的目标是从粗糙层级的单元平均值构造精细层级的初始数据，同时保持守恒性并避免伪极值。其基本基础是单元平均值的有限体积定义和带有斜率限制器的总变差递减 (TVD) 重构。\n\n设粗糙层级的网格是均匀的，单元中心位于 $x_i$，宽度为 $\\Delta x$。粗糙层级的单元平均密度为 $\\bar{\\rho}_i = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} \\rho(x)\\,dx$。对于延长操作，每个粗糙单元 $i$ 被细分为 $r$ 个精细子单元，索引为 $j \\in \\{0,1,\\dots,r-1\\}$，每个子单元的宽度为 $\\Delta x / r$。在每个粗糙单元 $i$ 内使用分段线性重构，\n$$\n\\rho_i(x) = \\bar{\\rho}_i + s_i \\frac{x - x_i}{\\Delta x},\n$$\n其中 $s_i$ 是一个根据相邻粗糙单元平均值计算的受限斜率，以强制满足 TVD 属性。定义后向和前向差分\n$$\n\\Delta_- = \\bar{\\rho}_i - \\bar{\\rho}_{i-1}, \\quad \\Delta_+ = \\bar{\\rho}_{i+1} - \\bar{\\rho}_i,\n$$\n及以下斜率限制器：\n- Minmod 限制器：$$s_i = \\mathrm{mm}(a,b) = \\begin{cases}\\mathrm{sign}(a)\\min(|a|,|b|) & \\text{if } ab > 0, \\\\ 0 & \\text{otherwise.}\\end{cases}$$，其中 $s_i = \\mathrm{mm}(\\Delta_-,\\Delta_+)$。\n- Monotonized Central (MC) 限制器：$$s_i = \\mathrm{mm}_3\\left(\\frac{\\Delta_- + \\Delta_+}{2}, 2\\Delta_-, 2\\Delta_+\\right)$$，其中如果 $ab>0$ 且 $ac>0$，则 $\\mathrm{mm}_3(a,b,c)$ 返回 $\\mathrm{sign}(a)\\min(|a|,|b|,|c|)$，否则返回 $0$。\n- Van Leer 限制器：$$s_i = \\begin{cases}\\frac{2\\Delta_- \\Delta_+}{\\Delta_- + \\Delta_+} & \\text{if } \\Delta_- \\Delta_+ > 0, \\\\ 0 & \\text{otherwise.}\\end{cases}$$。\n\n在域边界处，当邻居单元不可用时，设置 $s_i = 0$ 以保持守恒。粗糙单元 $i$ 内部子单元 $j$ 的子单元平均密度为\n$$\n\\bar{\\rho}_{i,j} = \\frac{r}{\\Delta x}\\int_{x_{i-1/2} + \\frac{j}{r}\\Delta x}^{x_{i-1/2} + \\frac{j+1}{r}\\Delta x} \\rho_i(x)\\,dx.\n$$\n对于上述的分段线性 $\\rho_i(x)$，子单元平均值等于子单元中点处的值，得到\n$$\n\\bar{\\rho}_{i,j} = \\bar{\\rho}_i + s_i\\,c_j,\\quad c_j = \\left(\\frac{j+\\frac{1}{2}}{r} - \\frac{1}{2}\\right).\n$$\n为避免在接触间断处产生伪极值，对每个粗糙单元 $i$ 实施保界裁剪，其局部边界为\n$$\n\\rho_{\\min,i} = \\min\\{\\bar{\\rho}_{i-1},\\bar{\\rho}_i,\\bar{\\rho}_{i+1}\\},\\quad \\rho_{\\max,i} = \\max\\{\\bar{\\rho}_{i-1},\\bar{\\rho}_i,\\bar{\\rho}_{i+1}\\},\n$$\n在边界处仅使用可用的邻居单元。强制执行\n$$\n\\bar{\\rho}_{i,j} \\leftarrow \\min\\left(\\rho_{\\max,i}, \\max\\left(\\rho_{\\min,i}, \\bar{\\rho}_{i,j}\\right)\\right).\n$$\n\n实现一个程序，该程序：\n1. 根据指定的限制器计算受限斜率 $s_i$。\n2. 使用上述公式，为给定的加密比 $r$ 计算精细层级的子单元平均值 $\\bar{\\rho}_{i,j}$。\n3. 对每个粗糙单元应用保界裁剪。\n4. 为每个测试用例输出加密后的子单元平均值，作为浮点数列表。\n\n所有密度均采用无量纲代码单位；无需进行物理单位转换。不涉及角度。程序必须生成单行输出，其中包含结果，格式为一个逗号分隔的列表，并用方括号括起来，其中每个元素本身是对应测试用例的加密单元平均密度的方括号括起的逗号分隔列表，不含空格。例如：`[[a_1,a_2,...],[b_1,b_2,...]]`。\n\n使用以下测试套件，其设计旨在覆盖平滑行为、尖锐接触间断、振荡模式和边界效应：\n- 测试 $1$（平滑单调增加，Minmod，$r=2$）：粗糙平均值 $\\left[\\,1.0,\\,1.1,\\,1.2,\\,1.3\\,\\right]$。\n- 测试 $2$（接触间断，MC，$r=2$）：粗糙平均值 $\\left[\\,1.0,\\,1.0,\\,5.0,\\,5.0\\,\\right]$。\n- 测试 $3$（振荡模式，Van Leer，$r=4$）：粗糙平均值 $\\left[\\,3.0,\\,1.0,\\,3.0,\\,1.0\\,\\right]$。\n- 测试 $4$（具有对称邻居的孤立跳跃，Minmod，$r=2$）：粗糙平均值 $\\left[\\,0.5,\\,0.5,\\,2.0,\\,0.5,\\,0.5\\,\\right]$。\n\n对于每个测试用例，输出应为展平的精细层级列表 [$\\bar{\\rho}_{0,0}, \\dots, \\bar{\\rho}_{0,r-1}, \\bar{\\rho}_{1,0}, \\dots, \\bar{\\rho}_{1,r-1}, \\dots$]，并遵循指定格式。最终输出必须是形如 $[ \\text{case1\\_list}, \\text{case2\\_list}, \\text{case3\\_list}, \\text{case4\\_list} ]$ 的单行文本，且任何位置都不能有空格。", "solution": "该问题陈述被评估为有效。它提出了一个定义明确的计算任务，该任务基于流体动力学数值方法的既定原则，特别是关于自适应网格加密 (AMR)。所提供的分段线性重构、斜率限制器和子单元平均的公式是标准且正确的。该问题是自包含的，指定了所有必要的数据和边界条件，从而能够为每个测试用例提供唯一的解。\n\n将粗糙层级单元平均密度 $\\bar{\\rho}_i$ 延长到加密比为 $r$ 的精细网格的过程涉及三个主要步骤：斜率计算、子单元平均值计算和保界裁剪。\n\n### 1. 受限斜率计算\n对于每个粗糙单元 $i$，计算一个斜率 $s_i$ 来定义一个分段线性重构，$$\n\\rho_i(x) = \\bar{\\rho}_i + s_i \\frac{x - x_i}{\\Delta x}\n$$，其中 $x_i$ 是单元 $i$ 的中心，$\\Delta x$ 是其宽度。为防止在尖锐特征附近引入伪振荡（这一特性被称为总变差递减或 TVD），斜率 $s_i$ 会根据局部数据进行限制。\n\n计算取决于单元的位置：\n- **边界单元**：对于域中的第一个（$i=0$）和最后一个（$i=N-1$）单元，无法获得完整的邻居集合。为保持守恒和简单的处理方式，斜率设为零，即 $s_0 = 0$ 和 $s_{N-1} = 0$。这对应于在边界处进行分段常数重构。\n- **内部单元**：对于任何内部单元 $i$，斜率由其直接邻居决定。我们首先计算后向和前向差分：\n    $$\n    \\Delta_- = \\bar{\\rho}_i - \\bar{\\rho}_{i-1} \\quad ; \\quad \\Delta_+ = \\bar{\\rho}_{i+1} - \\bar{\\rho}_i\n    $$\n    然后将这些差分传递给一个斜率限制器函数。问题指定了三种此类限制器：\n\n    1.  **Minmod 限制器**：这是耗散性最强的限制器，它能强烈抑制振荡。斜率由以下公式给出：\n        $$\n        s_i = \\mathrm{mm}(\\Delta_-, \\Delta_+) = \\begin{cases}\\mathrm{sign}(\\Delta_-)\\min(|\\Delta_-|,|\\Delta_+|),  & \\text{if } \\Delta_- \\Delta_+ > 0 \\\\ 0,  & \\text{otherwise}\\end{cases}\n        $$\n        仅当数据在局部是单调的（即 $\\Delta_-$ 和 $\\Delta_+$ 符号相同）时，斜率才非零。在局部极值点，斜率为零。\n\n    2.  **Monotonized Central (MC) 限制器**：该限制器旨在平滑区域比 Minmod 更精确。它使用一个三参数的 minmod 函数定义：\n        $$\n        s_i = \\mathrm{mm}_3\\left(\\frac{\\Delta_- + \\Delta_+}{2}, 2\\Delta_-, 2\\Delta_+\\right)\n        $$\n        其中，如果 $a, b, c$ 符号全部相同，$\\mathrm{mm}_3(a,b,c)$ 返回 $\\mathrm{sign}(a)\\min(|a|,|b|,|c|)$，否则返回 $0$。此限制器考虑中心差分斜率 $(\\Delta_- + \\Delta_+)/2$，并用两倍的单边差分来限制它。\n\n    3.  **Van Leer 限制器**：该限制器在单边差分之间提供平滑过渡，并以能为接触间断提供良好的解析度而闻名。它是两个差分的调和平均数：\n        $$\n        s_i = \\begin{cases}\\frac{2\\Delta_- \\Delta_+}{\\Delta_- + \\Delta_+},  & \\text{if } \\Delta_- \\Delta_+ > 0 \\\\ 0,  & \\text{otherwise}\\end{cases}\n        $$\n\n### 2. 子单元平均值延长\n一旦每个粗糙单元 $i$ 的斜率 $s_i$ 已知，我们就可以确定其中 $r$ 个子单元中每个子单元的平均密度 $\\bar{\\rho}_{i,j}$。子单元的索引为 $j \\in \\{0, 1, \\dots, r-1\\}$。一个线性函数在一个区间上的平均值等于该函数在该区间中点处的值。这将积分定义简化为代数定义。粗糙单元 $i$ 中子单元 $j$ 的中点与粗糙单元中心 $x_i$ 的偏移由一个距离因子决定。这导出了以下公式：\n$$\n\\bar{\\rho}_{i,j} = \\bar{\\rho}_i + s_i\\,c_j\n$$\n其中系数 $c_j$ 仅取决于子单元索引 $j$ 和加密比 $r$：\n$$\nc_j = \\left(\\frac{j+\\frac{1}{2}}{r} - \\frac{1}{2}\\right)\n$$\n这些系数表示每个子单元中心与父单元中心的归一化距离。例如，对于 $r=2$，我们有 $c_0 = -0.25$ 和 $c_1 = 0.25$。\n\n### 3. 保界裁剪\nTVD 斜率限制器旨在防止在单元界面上重构的点值产生新的极值。然而，为了严格强制新的“单元平均值”也不产生新的局部极值，会应用一个额外的裁剪步骤。对于每个粗糙单元 $i$，我们根据该单元平均值本身及其可用邻居定义局部边界：\n$$\n\\rho_{\\min,i} = \\min\\{\\bar{\\rho}_{k} \\mid k \\in \\{i-1, i, i+1\\} \\cap [0, N-1]\\}\n$$\n$$\n\\rho_{\\max,i} = \\max\\{\\bar{\\rho}_{k} \\mid k \\in \\{i-1, i, i+1\\} \\cap [0, N-1]\\}\n$$\n对于边界单元 $i=0$，邻域为 $\\{0, 1\\}$。对于内部单元，邻域为 $\\{i-1, i, i+1\\}$。\n\n然后，每个计算出的子单元平均值 $\\bar{\\rho}_{i,j}$ 被强制限制在这些边界内：\n$$\n\\bar{\\rho}_{i,j} \\leftarrow \\min\\left(\\rho_{\\max,i}, \\max\\left(\\rho_{\\min,i}, \\bar{\\rho}_{i,j}\\right)\\right)\n$$\n这确保了加密后的数据场在局部上仍受原始粗糙数据的限制，这对于稳定性和物理真实性至关重要，尤其是在接触间断处。\n\n### 示例演练：测试用例 1\n- **输入**：粗糙平均值 $\\bar{\\rho} = [1.0, 1.1, 1.2, 1.3]$，限制器：Minmod，$r=2$。\n- **斜率**：\n    - $s_0 = 0$（边界）。\n    - $i=1$：$\\Delta_- = 1.1-1.0=0.1$，$\\Delta_+ = 1.2-1.1=0.1$。$\\mathrm{mm}(0.1, 0.1) = 0.1$。所以，$s_1=0.1$。\n    - $i=2$：$\\Delta_- = 1.2-1.1=0.1$，$\\Delta_+ = 1.3-1.2=0.1$。$\\mathrm{mm}(0.1, 0.1) = 0.1$。所以，$s_2=0.1$。\n    - $s_3 = 0$（边界）。\n    - 斜率向量为 $s = [0, 0.1, 0.1, 0]$。\n- **子单元平均值（$r=2 \\implies c_0=-0.25, c_1=0.25$）**：\n    - $i=0$：$\\bar{\\rho}_{0,0} = 1.0 + 0 \\cdot (-0.25) = 1.0$；$\\bar{\\rho}_{0,1} = 1.0 + 0 \\cdot (0.25) = 1.0$。\n    - $i=1$：$\\bar{\\rho}_{1,0} = 1.1 + 0.1 \\cdot (-0.25) = 1.075$；$\\bar{\\rho}_{1,1} = 1.1 + 0.1 \\cdot (0.25) = 1.125$。\n    - $i=2$：$\\bar{\\rho}_{2,0} = 1.2 + 0.1 \\cdot (-0.25) = 1.175$；$\\bar{\\rho}_{2,1} = 1.2 + 0.1 \\cdot (0.25) = 1.225$。\n    - $i=3$：$\\bar{\\rho}_{3,0} = 1.3 + 0 \\cdot (-0.25) = 1.3$；$\\bar{\\rho}_{3,1} = 1.3 + 0 \\cdot (0.25) = 1.3$。\n- **裁剪**：\n    - $i=0$：边界为 $[\\min(1.0, 1.1), \\max(1.0, 1.1)] = [1.0, 1.1]$。值 $[1.0, 1.0]$ 在边界内。\n    - $i=1$：边界为 $[\\min(1.0, 1.1, 1.2), \\max(1.0, 1.1, 1.2)] = [1.0, 1.2]$。值 $[1.075, 1.125]$ 在边界内。\n    - $i=2$：边界为 $[\\min(1.1, 1.2, 1.3), \\max(1.1, 1.2, 1.3)] = [1.1, 1.3]$。值 $[1.175, 1.225]$ 在边界内。\n    - $i=3$：边界为 $[\\min(1.2, 1.3), \\max(1.2, 1.3)] = [1.2, 1.3]$。值 $[1.3, 1.3]$ 在边界内。\n    - 在这种情况下，裁剪步骤不会改变任何值，因为 Minmod 限制器已经确保了重构是非振荡的。\n- **最终结果**：展平的精细单元平均值列表为 $[1.0, 1.0, 1.075, 1.125, 1.175, 1.225, 1.3, 1.3]$。", "answer": "```python\nimport numpy as np\n\ndef minmod_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Minmod limited slope.\"\"\"\n    if delta_minus * delta_plus > 0:\n        return np.sign(delta_minus) * min(abs(delta_minus), abs(delta_plus))\n    return 0.0\n\ndef mm3(a, b, c):\n    \"\"\"Generalized minmod function for three arguments.\"\"\"\n    sa, sb, sc = np.sign(a), np.sign(b), np.sign(c)\n    if sa == sb and sa == sc:\n        return sa * min(abs(a), abs(b), abs(c))\n    return 0.0\n\ndef mc_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Monotonized Central (MC) limited slope.\"\"\"\n    return mm3((delta_minus + delta_plus) / 2.0, 2.0 * delta_minus, 2.0 * delta_plus)\n\ndef van_leer_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Van Leer limited slope.\"\"\"\n    if delta_minus * delta_plus > 0:\n        # The check for d- * d+ > 0 prevents division by zero,\n        # as d- + d+ could only be zero if both were zero.\n        return (2.0 * delta_minus * delta_plus) / (delta_minus + delta_plus)\n    return 0.0\n\ndef process_case(coarse_rho, limiter_name, r):\n    \"\"\"\n    Performs AMR prolongation for a given set of coarse cell averages.\n\n    Args:\n        coarse_rho (list[float]): The coarse-level cell averages.\n        limiter_name (str): The name of the slope limiter to use ('Minmod', 'MC', 'Van Leer').\n        r (int): The refinement ratio.\n\n    Returns:\n        list[float]: The flattened list of fine-level cell averages after clipping.\n    \"\"\"\n    limiter_funcs = {\n        'Minmod': minmod_limiter,\n        'MC': mc_limiter,\n        'Van Leer': van_leer_limiter\n    }\n    \n    n_coarse = len(coarse_rho)\n    slopes = np.zeros(n_coarse)\n    limiter_func = limiter_funcs[limiter_name]\n\n    # 1. Compute limited slopes for interior cells\n    for i in range(1, n_coarse - 1):\n        delta_minus = coarse_rho[i] - coarse_rho[i-1]\n        delta_plus = coarse_rho[i+1] - coarse_rho[i]\n        slopes[i] = limiter_func(delta_minus, delta_plus)\n    # Slopes at boundaries (i=0, i=n_coarse-1) remain 0\n\n    # 2. Compute fine-level subcell averages with bound-preserving clipping\n    c_j_coeffs = (np.arange(r, dtype=float) + 0.5) / r - 0.5\n    fine_rho = []\n    \n    for i in range(n_coarse):\n        # Determine local bounds from available neighbors\n        neighbors = [coarse_rho[i]]\n        if i > 0:\n            neighbors.append(coarse_rho[i-1])\n        if i  n_coarse - 1:\n            neighbors.append(coarse_rho[i+1])\n        \n        rho_min_i = min(neighbors)\n        rho_max_i = max(neighbors)\n\n        # Compute, clip, and store subcell values\n        for j in range(r):\n            # Calculate value from piecewise linear reconstruction\n            val = coarse_rho[i] + slopes[i] * c_j_coeffs[j]\n            # Apply bound-preserving clipping\n            clipped_val = min(rho_max_i, max(rho_min_i, val))\n            fine_rho.append(clipped_val)\n            \n    return fine_rho\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the formatted results.\n    \"\"\"\n    test_cases = [\n        {'coarse_rho': [1.0, 1.1, 1.2, 1.3], 'limiter': 'Minmod', 'r': 2},\n        {'coarse_rho': [1.0, 1.0, 5.0, 5.0], 'limiter': 'MC', 'r': 2},\n        {'coarse_rho': [3.0, 1.0, 3.0, 1.0], 'limiter': 'Van Leer', 'r': 4},\n        {'coarse_rho': [0.5, 0.5, 2.0, 0.5, 0.5], 'limiter': 'Minmod', 'r': 2},\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        result = process_case(case['coarse_rho'], case['limiter'], case['r'])\n        # Format the list of floats into a string \"[f1,f2,...]\"\n        result_str = '[' + ','.join(map(str, result)) + ']'\n        all_results_str.append(result_str)\n\n    # Combine all case strings into the final output format \"[[...],[...],...]\"\n    # with no spaces.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "3503480"}, {"introduction": "自适应网格创建了具有不同分辨率的网格层次结构，这也带来了一个重大挑战：由于Courant–Friedrichs–Lewy (CFL) 条件，每个层级都有不同的最大稳定时间步长。本练习解决了通过子循环（subcycling）管理这些不同时间尺度的实际问题，即在每个粗网格步长内，细网格会执行多个更小的时间步。您将计算合适的时间步长和同步计划，这是开发高效、稳定AMR模拟的一项关键技能。[@problem_id:3503472]", "problem": "考虑一个在计算天体物理学模拟中采用自适应网格加密（AMR）技术的一维显式有限体积法求解器，用于求解双曲守恒律。网格层级结构包含三个级别：一个粗网格层级 $\\ell = 0$，一个相对于层级 $\\ell=0$ 加密因子为 $r_1 = 3$ 的较细层级 $\\ell = 1$，以及一个相对于层级 $\\ell=1$ 加密因子为 $r_2 = 2$ 的最细层级 $\\ell = 2$。粗网格层级的空间步长为 $\\Delta x_0 = 9.6 \\times 10^9$ 米，因此 $\\Delta x_1 = \\Delta x_0/r_1$ 且 $\\Delta x_2 = \\Delta x_1/r_2$。在每个层级上解析的最大特征速度（通量雅可比矩阵特征值的最大绝对值）分别为：层级 $\\ell = 0$ 上为 $a_0 = 2.0 \\times 10^7$ 米/秒，层级 $\\ell = 1$ 上为 $a_1 = 3.3 \\times 10^7$ 米/秒，层级 $\\ell = 2$ 上为 $a_2 = 4.0 \\times 10^7$ 米/秒。Courant–Friedrichs–Lewy (CFL) 数为 $C_{\\mathrm{CFL}} = 0.45$。\n\n使用适用于双曲系统显式有限体积离散化的 Courant–Friedrichs–Lewy 稳定性要求，首先计算每个 AMR 层级上允许的时间步长，记为 $\\Delta t_{\\ell}^{\\max}$，其中 $\\ell \\in \\{0,1,2\\}$。然后，假设粗网格层级前进一个时间步长，其长度为 $\\Delta t_0 = \\Delta t_0^{\\max}$。通过选择整数 $n_1$ 和 $n_2$，在较细的层级上实现层级同步的子循环（subcycling），使得在一个粗网格层级步长内，层级 $\\ell = 1$ 执行 $n_1$ 个子步，层级 $\\ell = 2$ 执行 $n_2$ 个子步，且满足 $\\Delta t_1 = \\Delta t_0/n_1 \\le \\Delta t_1^{\\max}$ 和 $\\Delta t_2 = \\Delta t_0/n_2 \\le \\Delta t_2^{\\max}$，同时 $n_2$ 是 $n_1$ 的正整数倍以确保嵌套同步。在所有允许的选择中，选取满足这些约束的最小 $n_1$ 和最小倍数 $n_2$。\n\n将区间 $[0, \\Delta t_0]$ 内的同步时间定义为所有更细层级同时完成整数个子步长的时刻集合，此时它们可以与其父层级进行通量修正；在上述 $n_2$ 是 $n_1$ 的倍数的约束下，这些同步时间即为层级 $\\ell = 1$ 的子步边界。列出这些时间，包括粗网格层级步长的开始和结束时刻。所有时间量均以秒为单位表示。\n\n在最终答案中，按顺序将三元组 $(\\Delta t_0^{\\max}, \\Delta t_1^{\\max}, \\Delta t_2^{\\max})$、实际的子循环时间步长 $(\\Delta t_0, \\Delta t_1, \\Delta t_2)$ 以及一个粗网格层级步长内的有序同步时间 $(t_0, t_1, t_2, t_3, t_4, t_5)$ 作为单行提供。无需四舍五入。", "solution": "用户提供了一个计算天体物理学中的问题，涉及自适应网格加密（AMR）模拟中的时间步进。该问题要求基于 Courant-Friedrichs-Lewy (CFL) 稳定性条件计算时间步长，并确定子循环参数和同步时间。\n\n首先根据所需标准对问题进行验证。\n\n### 问题验证\n\n**步骤1：提取给定条件**\n- AMR 层级：$\\ell \\in \\{0, 1, 2\\}$。\n- 从层级 $\\ell=0$ 到 $\\ell=1$ 的加密因子：$r_1 = 3$。\n- 从层级 $\\ell=1$ 到 $\\ell=2$ 的加密因子：$r_2 = 2$。\n- 粗网格层级空间步长：$\\Delta x_0 = 9.6 \\times 10^9$ 米。\n- 空间步长关系：$\\Delta x_1 = \\Delta x_0/r_1$ 和 $\\Delta x_2 = \\Delta x_1/r_2$。\n- 每个层级上的最大特征速度：$a_0 = 2.0 \\times 10^7$ 米/秒， $a_1 = 3.3 \\times 10^7$ 米/秒， $a_2 = 4.0 \\times 10^7$ 米/秒。\n- Courant-Friedrichs-Lewy (CFL) 数：$C_{\\mathrm{CFL}} = 0.45$。\n- 推进的粗网格层级时间步长：$\\Delta t_0 = \\Delta t_0^{\\max}$。\n- 子循环约束：\n  - 层级 $\\ell=1$ 执行 $n_1$ 个子步，$\\Delta t_1 = \\Delta t_0/n_1 \\le \\Delta t_1^{\\max}$。\n  - 层级 $\\ell=2$ 执行 $n_2$ 个子步，$\\Delta t_2 = \\Delta t_0/n_2 \\le \\Delta t_2^{\\max}$。\n- 同步约束：$n_2$ 是 $n_1$ 的正整数倍。\n- 最小性约束：$n_1$ 是满足其约束的最小整数，而 $n_2$ 是满足其约束的 $n_1$ 的最小倍数。\n- 同步时间：在粗网格层级步长区间 $[0, \\Delta t_0]$ 内，层级 $\\ell=1$ 子步的边界。\n\n**步骤2：使用提取的给定条件进行验证**\n- **科学依据**：该问题基于 CFL 条件，这是双曲方程显式数值方法稳定性的基本原理。带子循环的 AMR 是计算流体动力学和天体物理学中一种标准的、科学上有效的技术。该问题牢固地植根于已建立的数值分析。\n- **适定性**：所有必要参数（$\\Delta x_0$, $r_1$, $r_2$, $a_\\ell$, $C_{\\mathrm{CFL}}$）均已提供。对子循环整数（$n_1, n_2$）的约束定义清晰，并能导出一个唯一的、最小的解。该问题是自洽的，在数学上是适定的。\n- **客观性**：该问题使用精确、无歧义的数学术语和物理量进行表述。它不含主观性语言。\n\n**步骤3：结论与行动**\n该问题是有效的，因为它科学上合理、适定且客观。将提供一个完整的解。\n\n### 解答\n\n解答过程分几个步骤：\n1.  计算每个层级 $\\ell$ 的空间步长 $\\Delta x_{\\ell}$。\n2.  使用 CFL 条件计算每个层级的最大允许时间步长 $\\Delta t_{\\ell}^{\\max}$。\n3.  确定满足给定约束的整数子循环数 $n_1$ 和 $n_2$。\n4.  计算用于子循环推进的实际时间步长 $\\Delta t_{\\ell}$。\n5.  列出一个粗网格层级步长内的同步时间。\n\n**1. 空间步长**\n较细层级的空间步长由给定的加密因子确定。\n- 层级 $\\ell=0$: $\\Delta x_0 = 9.6 \\times 10^9 \\, \\text{m}$。\n- 层级 $\\ell=1$: $\\Delta x_1 = \\frac{\\Delta x_0}{r_1} = \\frac{9.6 \\times 10^9}{3} = 3.2 \\times 10^9 \\, \\text{m}$。\n- 层级 $\\ell=2$: $\\Delta x_2 = \\frac{\\Delta x_1}{r_2} = \\frac{3.2 \\times 10^9}{2} = 1.6 \\times 10^9 \\, \\text{m}$。\n\n**2. 最大允许时间步长**\n一维显式有限体积格式的 CFL 条件规定，为保证稳定性，时间步长 $\\Delta t$ 必须满足 $\\Delta t \\le C_{\\mathrm{CFL}} \\frac{\\Delta x}{a}$，其中 $a$ 是最大特征速度。因此，层级 $\\ell$ 上的最大允许时间步长为 $\\Delta t_{\\ell}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{\\ell}}{a_{\\ell}}$。\n\n- 层级 $\\ell=0$:\n$$ \\Delta t_{0}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{0}}{a_{0}} = 0.45 \\times \\frac{9.6 \\times 10^{9} \\, \\text{m}}{2.0 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times (4.8 \\times 10^{2} \\, \\text{s}) = 216 \\, \\text{s} $$\n- 层级 $\\ell=1$:\n$$ \\Delta t_{1}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{1}}{a_{1}} = 0.45 \\times \\frac{3.2 \\times 10^{9} \\, \\text{m}}{3.3 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times \\frac{3.2}{3.3} \\times 10^{2} \\, \\text{s} = \\frac{1.44}{3.3} \\times 10^{2} \\, \\text{s} = \\frac{144}{3.3} \\, \\text{s} = \\frac{1440}{33} \\, \\text{s} = \\frac{480}{11} \\, \\text{s} $$\n- 层级 $\\ell=2$:\n$$ \\Delta t_{2}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{2}}{a_{2}} = 0.45 \\times \\frac{1.6 \\times 10^{9} \\, \\text{m}}{4.0 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times (0.4 \\times 10^{2} \\, \\text{s}) = 18 \\, \\text{s} $$\n第一组要求的值是 $(\\Delta t_0^{\\max}, \\Delta t_1^{\\max}, \\Delta t_2^{\\max}) = (216, \\frac{480}{11}, 18)$。\n\n**3. 子循环整数**\n粗网格层级前进一个步长，大小为 $\\Delta t_0 = \\Delta t_0^{\\max} = 216 \\, \\text{s}$。\n对于层级 $\\ell=1$，子步数 $n_1$ 必须满足 $\\Delta t_1 = \\frac{\\Delta t_0}{n_1} \\le \\Delta t_1^{\\max}$。这意味着：\n$$ n_1 \\ge \\frac{\\Delta t_0}{\\Delta t_1^{\\max}} = \\frac{216}{\\frac{480}{11}} = \\frac{216 \\times 11}{480} = \\frac{9 \\times 24 \\times 11}{20 \\times 24} = \\frac{99}{20} = 4.95 $$\n由于 $n_1$ 必须是整数，所以 $n_1$ 的最小值为 $\\lceil 4.95 \\rceil = 5$。\n\n对于层级 $\\ell=2$，子步数 $n_2$ 必须满足 $\\Delta t_2 = \\frac{\\Delta t_0}{n_2} \\le \\Delta t_2^{\\max}$。这意味着：\n$$ n_2 \\ge \\frac{\\Delta t_0}{\\Delta t_2^{\\max}} = \\frac{216}{18} = 12 $$\n此外，$n_2$ 必须是 $n_1=5$ 的正整数倍。我们必须找到大于或等于 $12$ 的 $5$ 的最小倍数。$5$ 的相关倍数是 $5, 10, 15, \\dots$。最小的此类倍数是 $15$。\n因此，选定的子循环整数为 $n_1 = 5$ 和 $n_2 = 15$。\n\n**4. 实际子循环时间步长**\n每个层级的实际时间步长是根据子循环整数计算的。\n- 层级 $\\ell=0$: $\\Delta t_0 = 216 \\, \\text{s}$。\n- 层级 $\\ell=1$: $\\Delta t_1 = \\frac{\\Delta t_0}{n_1} = \\frac{216}{5} = 43.2 \\, \\text{s}$。\n- 层级 $\\ell=2$: $\\Delta t_2 = \\frac{\\Delta t_0}{n_2} = \\frac{216}{15} = \\frac{72}{5} = 14.4 \\, \\text{s}$。\n第二组要求的值是 $(\\Delta t_0, \\Delta t_1, \\Delta t_2) = (216, 43.2, 14.4)$。\n\n**5. 同步时间**\n同步时间是层级 $\\ell=1$ 子步的边界。由于层级 $\\ell=1$ 执行 $n_1=5$ 个子步，每个子步持续时间为 $\\Delta t_1 = 43.2 \\, \\text{s}$，因此同步时间 $t_j$ 由 $t_j = j \\cdot \\Delta t_1$ 给出，其中 $j=0, 1, \\dots, 5$。\n- $t_0 = 0 \\times 43.2 = 0 \\, \\text{s}$\n- $t_1 = 1 \\times 43.2 = 43.2 \\, \\text{s}$\n- $t_2 = 2 \\times 43.2 = 86.4 \\, \\text{s}$\n- $t_3 = 3 \\times 43.2 = 129.6 \\, \\text{s}$\n- $t_4 = 4 \\times 43.2 = 172.8 \\, \\text{s}$\n- $t_5 = 5 \\times 43.2 = 216.0 \\, \\text{s}$\n第三组要求的值是 $(0, 43.2, 86.4, 129.6, 172.8, 216.0)$。\n\n这三组结果合并成一个单行矩阵作为最终答案。\n- $(\\Delta t_0^{\\max}, \\Delta t_1^{\\max}, \\Delta t_2^{\\max}) = (216, \\frac{480}{11}, 18)$\n- $(\\Delta t_0, \\Delta t_1, \\Delta t_2) = (216, 43.2, 14.4)$\n- $(t_0, \\dots, t_5) = (0, 43.2, 86.4, 129.6, 172.8, 216)$", "answer": "$$\n\\boxed{\\begin{pmatrix} 216  \\frac{480}{11}  18  216  43.2  14.4  0  43.2  86.4  129.6  172.8  216 \\end{pmatrix}}\n$$", "id": "3503472"}]}