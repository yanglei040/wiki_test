{"hands_on_practices": [{"introduction": "这项实践为并行计算的性能分析提供了一个基础练习。我们将分析有限体积或有限差分代码中最常见的通信模式：基于模板的计算所需的“光环”交换。通过计算标准三维笛卡尔域分解的通信量，你将具体理解通信成本如何随问题规模和处理器数量扩展，并直接应用制约许多并行算法效率的“表面积-体积比”原则[@problem_id:3509238]。", "problem": "一个显式有限体积法的天体物理流体动力学求解器在一个大小为 $N^{3}$ 的均匀立方网格上推进一个标量场。使用笛卡尔域分解将全局域分解为 $4 \\times 4 \\times 4$ 个进程（rank），各子域大小相等。假设 $N$ 可被 $4$ 整除，这样每个进程正好持有 $(N/4) \\times (N/4) \\times (N/4)$ 个内部单元。更新采用 $7$ 点最近邻模板，并仅在每个面上进行 halo 交换，halo 宽度为 $w=1$ 个单元（不进行边或角的交换）。每个 halo 值用双精度（每个值 $8$ 字节）表示。在每个时间步中，所有进程与其现有的最近邻进程交换其面 halo（外部物理边界没有相邻进程，因此不涉及进程间通信）。\n\n从笛卡尔域分解和 $7$ 点模板要求的定义出发，计算：\n- 每个进程在每个基本方向（即 $\\pm x$、$\\pm y$ 和 $\\pm z$ 方向）上的 halo 消息大小（以字节为单位），表示为 $N$ 的函数。\n- 用于面交换通信的、所有进程在每个时间步发送的总字节数。\n\n将最终总数表示为关于 $N$ 的单个闭式表达式。使用字节作为最终数量的单位。无需四舍五入。将所有进程在每个时间步发送的总字节数作为最终答案报告。", "solution": "问题陈述已经过验证，被认为是有效的。这是一个在计算科学领域内提法得当、有科学依据的问题，特别是关于并行算法的性能分析。所有必要的参数都已提供，没有内部矛盾或含糊之处。\n\n问题要求计算在一个并行流体动力学求解器中用于 halo 交换的总通信量。给定以下参数：\n- 全局网格大小：$N \\times N \\times N$ 个单元。\n- 进程（rank）网格：$P_x \\times P_y \\times P_z = 4 \\times 4 \\times 4$。进程总数为 $P = 4^3 = 64$。\n- 假设：$N$ 可被 $4$ 整除。\n- 每个进程的内部单元：每个进程管理一个 $(N/4) \\times (N/4) \\times (N/4)$ 单元的子域。设 $N_s = N/4$ 为子域的边长。子域的体积为 $N_s^3$。\n- 模板：$7$ 点最近邻模板，这意味着仅需要与六个面相邻的邻居进行通信。\n- Halo 宽度：每个面上 $w=1$ 个单元。\n- 数据精度：每个标量值是一个双精度浮点数，占用 $8$ 字节。设 $S_{val} = 8$ 字节。\n\n首先，我们计算从一个进程发送到相邻进程的单个消息的大小。该消息包含一个面的 halo 数据。子域的一个面是一个维度为 $N_s \\times N_s$ 的二维单元平面。待交换的 halo 区域厚度为 $w=1$。\n\n单个面 halo 区域中的数据值（单元）数量为：\n$$V_{face\\_halo} = w \\times N_s \\times N_s = 1 \\times \\left(\\frac{N}{4}\\right) \\times \\left(\\frac{N}{4}\\right) = \\frac{N^2}{16}$$\n\n一个面的消息大小（以字节为单位）是值的数量乘以每个值的大小：\n$$M_{face} = V_{face\\_halo} \\times S_{val} = \\frac{N^2}{16} \\times 8 = \\frac{N^2}{2} \\text{ bytes}$$\n这是每个进程在六个基本方向（$\\pm x$、$\\pm y$、$\\pm z$）中任意一个方向上的 halo 消息大小。\n\n接下来，我们必须确定每个时间步在整个模拟域中发送的此类消息的总数。问题要求的是“所有进程在每个时间步发送的总字节数”。这意味着我们必须计算从任何进程到相邻进程的每一次“发送”操作。通信仅发生在相邻进程之间的内部边界上。\n\n进程网格是一个 $4 \\times 4 \\times 4$ 的立方体。我们可以计算进程之间的内部边界（接口）数量。\n- 沿 $x$ 方向，有 $P_x - 1 = 4 - 1 = 3$ 个接口平面。每个平面由 $P_y \\times P_z = 4 \\times 4 = 16$ 个接口组成。因此，垂直于 $x$ 轴的接口数量为 $N_{int,x} = (P_x - 1) P_y P_z = 3 \\times 4 \\times 4 = 48$。\n- 根据对称性，垂直于 $y$ 轴的接口数量为 $N_{int,y} = P_x (P_y - 1) P_z = 4 \\times 3 \\times 4 = 48$。\n- 同样地，垂直于 $z$ 轴的接口数量为 $N_{int,z} = P_x P_y (P_z - 1) = 4 \\times 4 \\times 3 = 48$。\n\n整个域中的内部接口总数为：\n$$N_{int} = N_{int,x} + N_{int,y} + N_{int,z} = 48 + 48 + 48 = 144$$\n\n对于两个进程（例如进程 A 和进程 B）之间的每个内部接口，每个时间步会发生两次通信事件：进程 A 将其 halo 发送给进程 B，进程 B 将其 halo 发送给进程 A。问题要求计算*发送*的总字节数。因此，对于 $N_{int}$ 个接口中的每一个，我们都必须计算两次“发送”操作。\n\n每个时间步的“发送”操作总数为：\n$$N_{send} = 2 \\times N_{int} = 2 \\times 144 = 288$$\n\n最后，每个时间步发送的总通信量 $B_{total}$（以字节为单位），是发送操作总数与每条消息大小的乘积。\n$$B_{total} = N_{send} \\times M_{face}$$\n代入我们导出的表达式：\n$$B_{total} = 288 \\times \\frac{N^2}{2}$$\n$$B_{total} = 144 N^2$$\n\n所有进程在每个时间步发送的总字节数的最终表达式为 $144 N^2$。", "answer": "$$\\boxed{144 N^{2}}$$", "id": "3509238"}, {"introduction": "除了局部的邻居间数据交换，天体物理模拟还经常需要全局通信，例如通过寻找全局最小值来确定一个稳定的时间步。本练习对比了完成此任务的两种不同算法：一种是简单但不可扩展的环形集合通信，另一种是高效的、拓扑感知的树形集合通信。通过量化两者在大规模模拟中的巨大性能差异，你将认识到为何通信算法的选择与硬件一样，对实现可扩展性至关重要[@problem_id:3509190]。", "problem": "一个用于自引力湍流的三维可压缩磁流体动力学（MHD）求解器，在 $P$ 个子域上通过均匀笛卡尔域分解实现，每个子域由一个消息传递接口（MPI）秩推进。该求解器在每个显式时间步通过计算所有秩的局部稳定时间步长 $ \\Delta t_i $ 的全局最小值来强制执行全局 Courant–Friedrichs–Lewy (CFL) 条件。这个全局最小值是通过一个 MPI 集体操作获得的，该操作对每个秩的一个数值对 $ \\{ \\Delta t, \\mathrm{rank\\_id} \\} $ 进行归约以打破平局，总共占用 $m$ 字节。\n\n考虑在每个时间步实现全局归约的两种替代方案：\n- 一种确定性的基于环的集体操作，它忽略机器拓扑结构，并将 $P$ 个秩逻辑上排列成一个环。该集体操作分两个阶段执行：一个类似归约的阶段，将消息在环中传递一圈；然后是一个类似分发的阶段，将结果在环中传递一圈。\n- 一种拓扑感知的基于树的集体操作，它在 $P$ 个秩上构建一个二项树，并分两个阶段执行：一个向上归约阶段，然后是一个向下广播阶段。\n\n假设如下：\n- 每条消息的通信时间由标准延迟-带宽模型 $ T_{\\mathrm{msg}} = \\alpha + \\frac{m}{\\beta} $ 建模，其中启动延迟为 $ \\alpha $，带宽为 $ \\beta $。\n- 消息很小，没有注入或链路竞争，因此 $ \\alpha $ 和 $ \\beta $ 是常数且与 $P$ 无关。\n- 消息大小为 $ m = 16 $ 字节（一个作为 8 字节浮点数的 $ \\Delta t $ 和一个 8 字节的秩标识符）。\n- 机器参数为 $ \\alpha = 1.2 \\times 10^{-6} $ 秒 和 $ \\beta = 1.2 \\times 10^{10} $ 字节/秒。\n- 作业使用 $ P = 32768 $ 个 MPI 秩。\n\n从所述的通信模式和延迟-带宽成本模型出发，推导与拓扑感知的基于树的集体操作相比，确定性的基于环的集体操作在每个时间步所产生的额外挂钟时间 $ \\Delta T $。请以秒为单位表示你的答案，并四舍五入到四位有效数字。", "solution": "问题要求推导与拓扑感知的基于树的集体通信模式相比，确定性的基于环的集体通信模式在每个时间步所产生的额外挂钟时间 $\\Delta T$。时间差由 $\\Delta T = T_{\\text{ring}} - T_{\\text{tree}}$ 给出，其中 $T_{\\text{ring}}$ 和 $T_{\\text{tree}}$ 分别是环形算法和树形算法的总时间。\n\n大小为 $m$ 的单条消息的通信时间由延迟-带宽公式建模：\n$$T_{\\mathrm{msg}} = \\alpha + \\frac{m}{\\beta}$$\n其中 $\\alpha$ 是启动延迟，$\\beta$ 是通信带宽。\n\n首先，我们分析基于环的集体操作。$P$ 个 MPI 秩被排列在一个逻辑环中。该过程包括两个阶段：\n1.  一个类似归约的阶段，通过在环中传递消息来找到最小值。这构成了一个包含 $P-1$ 个相互依赖的通信步骤的序列。例如，秩 $i$ 将其当前的最小值发送给秩 $(i+1) \\pmod P$，后者计算出新的最小值并将其转发。此阶段的时间为 $(P-1)T_{\\mathrm{msg}}$。\n2.  一个类似分发的阶段，最终结果再次在环中传递，以便所有秩都接收到它。这类似于在环上的广播，也需要 $P-1$ 个顺序通信步骤。此阶段的时间为 $(P-1)T_{\\mathrm{msg}}$。\n\n基于环的集体操作的总时间是这两个阶段时间的总和：\n$$T_{\\text{ring}} = (P-1)T_{\\mathrm{msg}} + (P-1)T_{\\mathrm{msg}} = 2(P-1)T_{\\mathrm{msg}}$$\n\n接下来，我们分析拓扑感知的基于树的集体操作。该算法使用二项树结构。对于 $P$ 个秩，其中 $P$ 是 2 的幂，归约和广播的顺序通信步骤数都等于树的高度，即 $\\log_2(P)$。该过程也包括两个阶段：\n1.  一个向上归约阶段，数据从树的叶节点收集到根节点。这需要 $\\log_2(P)$ 个顺序通信步骤。此阶段的时间为 $\\log_2(P)T_{\\mathrm{msg}}$。\n2.  一个向下广播阶段，最终结果从根节点分发到树中的所有其他节点。这也需要 $\\log_2(P)$ 个顺序通信步骤。此阶段的时间为 $\\log_2(P)T_{\\mathrm{msg}}$。\n\n基于树的集体操作的总时间是这两个阶段时间的总和：\n$$T_{\\text{tree}} = \\log_2(P)T_{\\mathrm{msg}} + \\log_2(P)T_{\\mathrm{msg}} = 2\\log_2(P)T_{\\mathrm{msg}}$$\n\n每个时间步额外增加的挂钟时间 $\\Delta T$ 是 $T_{\\text{ring}}$ 和 $T_{\\text{tree}}$ 之间的差值：\n$$\\Delta T = T_{\\text{ring}} - T_{\\text{tree}} = 2(P-1)T_{\\mathrm{msg}} - 2\\log_2(P)T_{\\mathrm{msg}}$$\n$$\\Delta T = 2(P - 1 - \\log_2(P))T_{\\mathrm{msg}}$$\n代入 $T_{\\mathrm{msg}}$ 的表达式：\n$$\\Delta T = 2(P - 1 - \\log_2(P))\\left(\\alpha + \\frac{m}{\\beta}\\right)$$\n\n给定以下值：\n- MPI 秩的数量：$P = 32768$\n- 消息大小：$m = 16$ 字节\n- 延迟：$\\alpha = 1.2 \\times 10^{-6}$ 秒\n- 带宽：$\\beta = 1.2 \\times 10^{10}$ 字节/秒\n\n首先，我们计算涉及 $P$ 的项：\n因为 $P = 32768 = 2^{15}$，所以我们有：\n$$\\log_2(P) = \\log_2(2^{15}) = 15$$\n$\\Delta T$ 表达式中的因子是：\n$$2(P - 1 - \\log_2(P)) = 2(32768 - 1 - 15) = 2(32752) = 65504$$\n\n接下来，我们计算每条消息的时间 $T_{\\mathrm{msg}}$：\n$$T_{\\mathrm{msg}} = 1.2 \\times 10^{-6} \\, \\text{s} + \\frac{16 \\, \\text{bytes}}{1.2 \\times 10^{10} \\, \\text{bytes/s}}$$\n带宽项是：\n$$\\frac{16}{1.2 \\times 10^{10}} = \\frac{16}{12 \\times 10^9} = \\frac{4}{3} \\times 10^{-9} \\approx 1.333... \\times 10^{-9} \\, \\text{s}$$\n所以，每条消息的时间是：\n$$T_{\\mathrm{msg}} = \\left(1.2 \\times 10^{-6} + \\frac{4}{3} \\times 10^{-9}\\right) \\, \\text{s}$$\n$$T_{\\mathrm{msg}} = (1.200 \\times 10^{-6} + 0.001333... \\times 10^{-6}) \\, \\text{s} = 1.201333... \\times 10^{-6} \\, \\text{s}$$\n\n现在我们可以计算 $\\Delta T$：\n$$\\Delta T = 65504 \\times T_{\\mathrm{msg}}$$\n$$\\Delta T = 65504 \\times \\left(1.2 \\times 10^{-6} + \\frac{4}{3} \\times 10^{-9}\\right) \\, \\text{s}$$\n$$\\Delta T = (65504 \\times 1.2 \\times 10^{-6}) + \\left(65504 \\times \\frac{4}{3} \\times 10^{-9}\\right) \\, \\text{s}$$\n第一项是：\n$$65504 \\times 1.2 \\times 10^{-6} = 78604.8 \\times 10^{-6} = 0.0786048 \\, \\text{s}$$\n第二项是：\n$$65504 \\times \\frac{4}{3} \\times 10^{-9} = \\frac{262016}{3} \\times 10^{-9} \\approx 87338.67 \\times 10^{-9} = 0.00008733867 \\, \\text{s}$$\n将两项相加：\n$$\\Delta T = 0.0786048 \\, \\text{s} + 0.00008733867... \\, \\text{s} = 0.07869213867... \\, \\text{s}$$\n\n问题要求答案四舍五入到四位有效数字。\n$$\\Delta T \\approx 0.07869 \\, \\text{s}$$", "answer": "$$\\boxed{0.07869}$$", "id": "3509190"}, {"introduction": "真实世界的天体物理问题通常涉及高度非均匀的自适应网格，而非简单的规则网格。这项高级的动手实践将指导你使用希尔伯特空间填充曲线，为这类复杂网格实现一种现代的域分解策略。你将学习如何基于这种排序来划分单元，以同时实现良好的负载均衡和最小化进程间通信——这是任何有效并行化策略的两个基本目标[@problem_id:3509227]。", "problem": "你的任务是为一个自适应二维网格实现一个确定性的、连续的、基于一维排序的区域分解。该网格代表了计算天体物理学中的自adaptive Mesh Refinement (AMR)策略。该分解必须使用单元中心的 Hilbert 空间填充曲线排序，将网格剖分给指定数量的处理单元。然后，你将计算两个定量指标：一个负载均衡指标和网格对偶图中的切割边数量。\n\n请使用以下定义和规则。\n\n1.  区域与单元。计算域为正方形 $[0,1]\\times[0,1]$。网格是一组轴对齐的矩形单元，每个单元由其闭合坐标范围 $[x_{\\min},x_{\\max}]\\times[y_{\\min},y_{\\max}]$ 表示，其中 $0 \\le x_{\\min}  x_{\\max} \\le 1$ 且 $0 \\le y_{\\min}  y_{\\max} \\le 1$。每个单元 $i$ 有一个中心 $(x_i,y_i)$，由 $x_i = (x_{\\min,i}+x_{\\max,i})/2$ 和 $y_i=(y_{\\min,i}+y_{\\max,i})/2$ 给出。每个单元 $i$ 还有一个正的计算权重 $w_i$。\n\n2.  Hilbert 空间填充曲线排序。使用每个坐标 $b=16$ 位将每个单元中心 $(x_i,y_i)$ 映射到一个整数网格，即令 $n=2^{b}$ 并定义整数坐标：\n$$\ni_x = \\min\\left(\\left\\lfloor x_i \\cdot n \\right\\rfloor, n-1\\right),\\quad\ni_y = \\min\\left(\\left\\lfloor y_i \\cdot n \\right\\rfloor, n-1\\right).\n$$\n使用标准的 b 阶 Hilbert 曲线映射，将 $(i_x,i_y)\\in\\{0,1,\\dots,n-1\\}^2$ 映射到 $h\\in\\{0,1,\\dots,n^2-1\\}$，从而计算 Hilbert 索引 $h(i_x,i_y)$。按 $h$ 升序对单元进行排序；如果出现平局，则按 $i_x$ 升序，然后按 $i_y$ 升序打破平局。这个排序后的序列就是一维排序。\n\n3.  通过加权中点区间分配进行连续剖分。给定排序后的序列，根据以下规则将每个单元 $i$ 分配给 $P$ 个剖分之一。设 $W_{\\mathrm{tot}}=\\sum_i w_i$ 为总权重，设 $c_i$ 为排序中严格排在单元 $i$ 之前的所有单元的权重累积和。则单元 $i$ 的剖分索引为：\n$$\np_i = \\min\\left(\\left\\lfloor P \\cdot \\frac{c_i + \\tfrac{1}{2}w_i}{W_{\\mathrm{tot}}} \\right\\rfloor,\\, P-1\\right).\n$$\n这将沿 Hilbert 排序产生 $P$ 个连续段。\n\n4.  负载均衡指标。对于 $p\\in\\{0,1,\\dots,P-1\\}$，设 $W_p=\\sum_{i:\\,p_i=p} w_i$ 为剖分 $p$ 上的权重，设 $\\bar{W}=W_{\\mathrm{tot}}/P$ 为平均权重。负载均衡指标为：\n$$\nL = \\frac{\\max_p W_p}{\\bar{W}}.\n$$\n你必须报告四舍五入到 6 位小数的 $L$。\n\n5.  对偶图中的切割边。定义一个无向对偶图，其顶点为单元。两个不同的单元 $i$ 和 $j$ 相邻，当且仅当它们的矩形共享一条非零长度的边界边。更准确地说，如果满足以下任一条件，则它们相邻：\n- $x_{\\max,i} = x_{\\min,j}$ 或 $x_{\\max,j} = x_{\\min,i}$，且沿 $y$ 轴的重叠长度严格为正，即：\n$$\n\\min(y_{\\max,i},y_{\\max,j}) - \\max(y_{\\min,i},y_{\\min,j}) > 0,\n$$\n或\n- $y_{\\max,i} = y_{\\min,j}$ 或 $y_{\\max,j} = y_{\\min,i}$，且沿 $x$ 轴的重叠长度严格为正，即：\n$$\n\\min(x_{\\max,i},x_{\\max,j}) - \\max(x_{\\min,i},x_{\\min,j}) > 0.\n$$\n每个无序相邻对只计数一次。切割边数 $E$ 是满足 $p_i \\ne p_j$ 的相邻对 $\\{i,j\\}$ 的数量。\n\n6.  测试套件。为以下四个测试用例实现上述方法。在所有情况下，计算域均为 $[0,1]\\times[0,1]$，且 Hilbert 映射使用 $b=16$。\n\n-   测试用例 A（均匀网格，均匀权重）：一个 $n_x=4$ 和 $n_y=4$ 的均匀网格，形成 16 个大小为 $1/4\\times 1/4$ 的相同单元，即由 $(a,b)$ 索引的单元，其中 $a\\in\\{0,1,2,3\\}$，$b\\in\\{0,1,2,3\\}$，坐标为：\n$$\n[x_{\\min},x_{\\max}] = \\left[\\frac{a}{4}, \\frac{a+1}{4}\\right],\\quad\n[y_{\\min},y_{\\max}] = \\left[\\frac{b}{4}, \\frac{b+1}{4}\\right].\n$$\n所有权重均为 $w_i=1$。使用 $P=4$。\n\n-   测试用例 B（四叉树加密，均匀权重）：从一个由大小为 $1/2\\times 1/2$ 的单元组成的 $2\\times 2$ 粗网格开始，索引为 $(a,b)$，$a,b\\in\\{0,1\\}$：\n$$\n[x_{\\min},x_{\\max}] = \\left[\\frac{a}{2}, \\frac{a+1}{2}\\right],\\quad\n[y_{\\min},y_{\\max}] = \\left[\\frac{b}{2}, \\frac{b+1}{2}\\right].\n$$\n将右上角的粗单元 $(a,b)=(1,1)$ 加密为四个大小为 $1/4\\times 1/4$ 的子单元，它们对齐于明显可见的子象限。然后，将这四个子单元中位于右上角的那个加密为四个大小为 $1/8\\times 1/8$ 的孙单元。因此，最终的网格包含 3 个粗单元，3 个四分之一单元（被加密的粗单元的子单元，除了那个被进一步加密的），以及 4 个八分之一单元，总共 10 个单元。所有权重均为 $w_i=1$。使用 $P=3$。\n\n-   测试用例 C（非整合界面，依赖于层级的权重）：左半部分 $[0,1/2]\\times[0,1]$ 为一个粗单元，右半部分 $[1/2,1]\\times[0,1]$ 细分为一个由四个大小为 $1/4\\times 1/2$ 的相同单元组成的 $2\\times 2$ 网格。根据加密层级分配权重：粗单元的权重 $w=1$，四个细单元的权重各为 $w=2$。使用 $P=2$。\n\n-   测试用例 D（剖分数多于单元数）：两个大小相等的单元垂直分割，即 $[0,1/2]\\times[0,1]$ 和 $[1/2,1]\\times[0,1]$，两者权重均为 $w=1$。使用 $P=3$。\n\n7.  输出规范。你的程序应产生单行输出，包含一个用方括号括起来的、以逗号分隔的列表形式的结果，其中每个测试用例贡献一个包含负载均衡指标 $L$（四舍五入到 6 位小数）和整数切割边数 $E$ 的双元素列表。例如，所需的格式为：\n$$\n\\big[ [L_A,E_A], [L_B,E_B], [L_C,E_C], [L_D,E_D] \\big],\n$$\n打印在单行上，无任何附加文本。\n\n所有计算纯粹是几何和组合性质的；不涉及物理单位。不涉及角度。本问题中使用的所有数字和符号必须按上文给出的标准数学符号进行解释。", "solution": "我们从并行计算的区域分解的基本原理出发，这在计算天体物理学的自适应网格加密（AMR）中很常见。其目的是将由带权重的网格单元表示的计算工作分配给 $P$ 个处理单元，以实现两个期望目标：负载均衡和局部性。一种被广泛接受的方法是使用空间填充曲线施加一维排序，然后将此排序剖分为连续的段。我们将此方法具体化为使用 Hilbert 空间填充曲线。\n\n我们使用的基本依据是：保持空间局部性的空间填充曲线排序的定义，根据工作权重定义的负载均衡，以及由共享边界边定义的对偶图中的邻接关系。\n\n首先，考虑一组覆盖 $[0,1]\\times[0,1]$ 子集的轴对齐矩形单元。每个单元 $i$ 由 $[x_{\\min,i},x_{\\max,i}]\\times[y_{\\min,i},y_{\\max,i}]$ 给出，其中 $0\\le x_{\\min,i}  x_{\\max,i} \\le 1$ 且 $0\\le y_{\\min,i}  y_{\\max,i} \\le 1$。其中心为 $(x_i,y_i)$，其中\n$$\nx_i = \\frac{x_{\\min,i}+x_{\\max,i}}{2},\\qquad y_i=\\frac{y_{\\min,i}+y_{\\max,i}}{2}.\n$$\n我们为每个单元分配一个计算权重 $w_i0$，它反映了计算该单元更新的成本。在计算天体物理学中，权重可以与每步更新的状态数量成正比，在多级 AMR 设置中，由于时间上的子循环，更精细的层级可能会产生更高的有效成本；例如，如果精细层级采取的子步长是原来的两倍，那么对于层级 $\\ell$，一个简单的模型 $w\\propto 2^\\ell$ 是合理的。\n\n为了在剖分中实现良好的空间局部性，我们将 $(x_i,y_i)$ 映射到 b 阶 Hilbert 曲线索引。令 $b=16$ 和 $n=2^{b}$。整数坐标为\n$$\ni_x = \\min\\left(\\left\\lfloor x_i \\cdot n \\right\\rfloor, n-1\\right),\\quad\ni_y = \\min\\left(\\left\\lfloor y_i \\cdot n \\right\\rfloor, n-1\\right).\n$$\n存在一个经过充分测试的双射映射 $h:\\{0,1,\\dots,n-1\\}^2\\to\\{0,1,\\dots,n^2-1\\}$，称为 Hilbert 索引，它可以通过在位尺度减半时递归地旋转和反射象限来算法化地计算。操作上，一种标准方法遍历位尺度 $s\\in\\{n/2, n/4, \\dots, 1\\}$，提取相应的位\n$$\nr_x = \\left\\lfloor \\frac{i_x \\bmod 2s}{s} \\right\\rfloor,\\qquad r_y = \\left\\lfloor \\frac{i_y \\bmod 2s}{s} \\right\\rfloor,\n$$\n将 $s^2\\cdot\\big( (3r_x)\\oplus r_y\\big)$ 的贡献累积到 $h$ 中，并应用一个旋转 $\\mathrm{rot}(s,i_x,i_y,r_x,r_y)$，当 $r_y=0$ 且 $r_x=1$ 时反转并交换坐标，否则当 $r_y=0$ 时交换坐标。该映射有广泛的文献记载，并保持局部性：平面中的邻近点在一维排序中也倾向于接近。\n\n我们按 $h(i_x,i_y)$ 升序对所有单元进行排序。在不太可能发生的 Hilbert 索引相等的情况下，我们通过按 $i_x$ 升序然后按 $i_y$ 升序来打破平局，以确保一个确定性的全序。这将产生一个一维序列。\n\n给定此序列，我们需要一个将其分解为 $P$ 个连续部分的方案，使得每个部分的权重近似相等。设 $W_{\\mathrm{tot}}=\\sum_i w_i$ 为总权重，$\\bar{W}=W_{\\mathrm{tot}}/P$ 为每个剖分的目标权重。对于序列中的每个单元 $i$，设 $c_i$ 为所有前面单元的权重累积和。基本原则是根据权重区间 $[c_i, c_i+w_i)$ 的中点相对于 $[0,W_{\\mathrm{tot}})$ 的 $P$ 个相等子区间的位置来分配剖分索引。因此我们分配\n$$\np_i = \\min\\left(\\left\\lfloor P \\cdot \\frac{c_i + \\tfrac{1}{2}w_i}{W_{\\mathrm{tot}}} \\right\\rfloor,\\, P-1\\right).\n$$\n这是一种有原则的中点分配方法，它将权重区间的包含性中点放入 $P$ 个仓之一，从而将序列剖分为连续的段。使用中点是一种经过充分测试的方法，可以在离散化连续剖分时最小化舍入误差。\n\n负载均衡指标源于负载不均衡的定义：如果 $W_p$ 是分配给剖分 $p$ 的总权重，那么理想的平衡是当所有 $p$ 的 $W_p=\\bar{W}$ 时。一个标准的标量度量是\n$$\nL = \\frac{\\max_p W_p}{\\bar{W}},\n$$\n其值至少为 1，当所有部分的权重都恰好等于目标权重时，其值等于 1。这是一个无量纲的量，与单位无关。\n\n切割边的数量是在对偶图上计算的，其中如果两个单元共享一条非零长度的边界边，则它们相邻。对于两个矩形 $[x_{\\min,i},x_{\\max,i}]\\times[y_{\\min,i},y_{\\max,i}]$ 和 $[x_{\\min,j},x_{\\max,j}]\\times[y_{\\min,j},y_{\\max,j}]$，如果 $x_{\\max,i}=x_{\\min,j}$ 或 $x_{\\max,j}=x_{\\min,i}$ 且沿 $y$ 轴的重叠长度，\n$$\n\\delta_y = \\min(y_{\\max,i},y_{\\max,j}) - \\max(y_{\\min,i},y_{\\min,j}),\n$$\n严格为正，则它们沿垂直界面相邻。如果 $y_{\\max,i}=y_{\\min,j}$ 或 $y_{\\max,j}=y_{\\min,i}$ 且沿 $x$ 轴的重叠长度，\n$$\n\\delta_x = \\min(x_{\\max,i},x_{\\max,j}) - \\max(x_{\\min,i},x_{\\min,j}),\n$$\n严格为正，则它们沿水平界面相邻。为了在使用二进制有理数坐标时具有数值鲁棒性，我们使用一个小的容差来实现相等性检查，但概念上意图是精确相等。每个无序相邻对 $\\{i,j\\}$ 只计数一次，如果 $p_i\\ne p_j$，它就对切割计数 $E$ 有贡献。\n\n我们现在实例化这四个测试用例：\n\n-   测试用例 A 是一个均匀的 $4\\times 4$ 网格。16 个单元每个的权重都是 $w_i=1$，且 $P=4$。因为 Hilbert 排序保持了局部性且权重均匀，中点分配将产生四个总权重相等或几乎相等的连续块，在这种情况下，如果排序能够均匀划分，则每个剖分恰好有 4 个单元。负载均衡指标 $L$ 是用 $\\bar{W}=16/4=4$ 和测量的 $W_p$ 来计算的。切割边数 $E$ 取决于剖分切割落在网格邻接关系中的位置。\n\n-   测试用例 B 是一个分层的四叉树加密：三个大小为 $1/2\\times 1/2$ 的粗单元，三个大小为 $1/4\\times 1/4$ 的四分之一单元（替换一个粗单元，除了那个被进一步加密的），以及四个大小为 $1/8\\times 1/8$ 的八分之一单元（替换被加密的四分之一单元）。所有权重均为 $w_i=1$ 且 $P=3$，因此 $\\bar{W}=10/3$。中点分配产生三个总权重接近 $10/3$ 的连续段。然后我们计算跨非整合网格的切割边数。邻接规则正确处理了大单元到小单元的界面，即一个单元可以与多个较小的邻居共享一条边。\n\n-   测试用例 C 在 $x=1/2$ 处设置了一个非整合界面，左侧是一个粗单元，右侧是四个 $2\\times 2$ 网格中的单元。权重取决于加密级别以模拟子循环：0 级（粗单元）的权重为 $w=1$，1 级（四个更细的单元）的权重为 $w=2$，所以 $W_{\\mathrm{tot}}=1+4\\cdot 2=9$，$P=2$，$\\bar{W}=9/2=4.5$。中点分配将 Hilbert 序列分为总权重几乎相等的两个部分，切割边数取决于左右邻接关系是否跨越剖分索引。\n\n-   测试用例 D 只有两个垂直分割的单元，权重 $w_i=1$，且 $P=3$。这里 $W_{\\mathrm{tot}}=2$ 且 $\\bar{W}=2/3$。由于单元数少于剖分数，至少有一个剖分的权重为零。负载均衡指标是 $L = \\max_p W_p / \\bar{W}$，在这种情况下，如果一个剖分得到一个单元且最大值为 1，则等于 $1 / (2/3)=1.5$，或者如果两个单元最终都在同一个剖分上，则等于 $2 / (2/3)=3$；然而，Hilbert 排序上的中点规则会产生确定性的分配，我们据此计算精确的 $L$。两个单元之间的单一邻接关系是否为切割边，当且仅当它们最终被分到不同的剖分中。\n\n实现的算法步骤：\n\n1.  为每个测试用例按规定生成矩形和权重的列表，使用精确有理数坐标。\n\n2.  对每个测试用例，为每个单元计算 $(x_i,y_i)$，用 $b=16$ 映射到整数 $(i_x,i_y)$，通过标准的迭代旋转算法计算 Hilbert 索引 $h(i_x,i_y)$，并按 $(h,i_x,i_y)$ 排序。\n\n3.  遍历排序后的单元，保持一个累积和 $c_i$，并使用中点规则分配剖分索引 $p_i$：\n$$\np_i = \\min\\left(\\left\\lfloor P \\cdot \\frac{c_i + \\tfrac{1}{2}w_i}{W_{\\mathrm{tot}}} \\right\\rfloor,\\, P-1\\right).\n$$\n\n4.  计算 $W_p=\\sum_{i:\\,p_i=p} w_i$，$\\bar{W}=W_{\\mathrm{tot}}/P$ 和 $L = \\max_p W_p / \\bar{W}$，并将 $L$ 四舍五入到 6 位小数以供输出。\n\n5.  使用具有正长度重叠的共享边准则计算邻接集，并计算 $p_i\\ne p_j$ 的对数，得到 $E$。\n\n6.  在单行上输出列表 $\\big[ [L_A,E_A], [L_B,E_B], [L_C,E_C], [L_D,E_D] \\big]$。\n\n这个设计整合了核心原则：通过 Hilbert 曲线保持空间局部性以减少部分间的通信，确定性的连续剖分以实现可复现性，以及使用 $\\max_p W_p / \\bar{W}$ 的有原则的负载均衡测量。通过共享边定义邻接关系在天体物理模拟中常见的有限体积和有限差分离散化方法中是标准的，确保了跨非整合界面的真实通信边计数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rot(n, x, y, rx, ry):\n    # Rotate/flip a quadrant appropriately\n    if ry == 0:\n        if rx == 1:\n            x = n - 1 - x\n            y = n - 1 - y\n        # Swap x and y\n        x, y = y, x\n    return x, y\n\ndef xy2d(n, x, y):\n    # Convert (x,y) integer coordinates in [0,n-1] to Hilbert d in [0,n*n-1]\n    d = 0\n    s = n // 2\n    xi = x\n    yi = y\n    while s > 0:\n        rx = 1 if (xi  s) else 0\n        ry = 1 if (yi  s) else 0\n        d += s * s * ((3 * rx) ^ ry)\n        xi, yi = rot(s, xi, yi, rx, ry)\n        s //= 2\n    return d\n\ndef hilbert_indices(centers, b=16):\n    n = 1  b\n    idxs = []\n    for (cx, cy) in centers:\n        ix = int(np.floor(cx * n))\n        iy = int(np.floor(cy * n))\n        if ix >= n:\n            ix = n - 1\n        if iy >= n:\n            iy = n - 1\n        h = xy2d(n, ix, iy)\n        idxs.append((h, ix, iy))\n    return idxs\n\ndef assign_partitions_by_midpoint(weights, order, P):\n    Wtot = float(np.sum(weights))\n    parts = [0] * len(weights)\n    c = 0.0\n    for k in range(len(order)):\n        i = order[k]\n        w = float(weights[i])\n        # midpoint assignment\n        p = int(np.floor(P * ((c + 0.5 * w) / Wtot)))\n        if p >= P:\n            p = P - 1\n        parts[i] = p\n        c += w\n    return parts\n\ndef compute_load_metric(weights, parts, P):\n    Wtot = float(np.sum(weights))\n    avg = Wtot / float(P)\n    Wp = np.zeros(P, dtype=float)\n    for w, p in zip(weights, parts):\n        Wp[p] += float(w)\n    L = float(np.max(Wp)) / avg if avg > 0 else 0.0\n    return L\n\ndef overlap_len(a0, a1, b0, b1):\n    return max(0.0, min(a1, b1) - max(a0, b0))\n\ndef count_cut_edges(rects, parts, tol=1e-12):\n    n = len(rects)\n    cut = 0\n    # Build adjacency by pairwise check; small meshes so O(n^2) is fine\n    for i in range(n):\n        xi0, yi0, xi1, yi1 = rects[i]\n        for j in range(i + 1, n):\n            xj0, yj0, xj1, yj1 = rects[j]\n            # vertical adjacency\n            vert = (abs(xi1 - xj0)  tol or abs(xj1 - xi0)  tol) and (overlap_len(yi0, yi1, yj0, yj1) > tol)\n            # horizontal adjacency\n            horiz = (abs(yi1 - yj0)  tol or abs(yj1 - yi0)  tol) and (overlap_len(xi0, xi1, xj0, xj1) > tol)\n            if vert or horiz:\n                if parts[i] != parts[j]:\n                    cut += 1\n    return cut\n\ndef centers_of_rects(rects):\n    centers = []\n    for (x0, y0, x1, y1) in rects:\n        centers.append(((x0 + x1) * 0.5, (y0 + y1) * 0.5))\n    return centers\n\ndef test_case_A():\n    # Uniform 4x4 grid on [0,1]^2\n    rects = []\n    for a in range(4):\n        for b in range(4):\n            x0 = a / 4.0\n            x1 = (a + 1) / 4.0\n            y0 = b / 4.0\n            y1 = (b + 1) / 4.0\n            rects.append((x0, y0, x1, y1))\n    weights = [1.0] * len(rects)\n    P = 4\n    return rects, weights, P\n\ndef test_case_B():\n    # Quadtree: 2x2 coarse; refine top-right into 4; refine its top-right into 4\n    rects = []\n    # coarse cells\n    coarse = []\n    for a in range(2):\n        for b in range(2):\n            x0 = a / 2.0\n            x1 = (a + 1) / 2.0\n            y0 = b / 2.0\n            y1 = (b + 1) / 2.0\n            coarse.append((a, b, (x0, y0, x1, y1)))\n    # Keep all coarse except (1,1)\n    for (a, b, r) in coarse:\n        if not (a == 1 and b == 1):\n            rects.append(r)\n    # children of (1,1)\n    quarter = []\n    base = (1/2.0, 1/2.0, 1.0, 1.0)\n    # four children in that quadrant\n    for da in range(2):\n        for db in range(2):\n            x0 = 0.5 + da * 0.25\n            x1 = 0.5 + (da + 1) * 0.25\n            y0 = 0.5 + db * 0.25\n            y1 = 0.5 + (db + 1) * 0.25\n            quarter.append((da, db, (x0, y0, x1, y1)))\n    # refine the top-right child (da=1, db=1) into four eighth-cells\n    for (da, db, r) in quarter:\n        if not (da == 1 and db == 1):\n            rects.append(r)\n    # grandchildren within [0.75,1]x[0.75,1]\n    for ea in range(2):\n        for eb in range(2):\n            x0 = 0.75 + ea * 0.125\n            x1 = 0.75 + (ea + 1) * 0.125\n            y0 = 0.75 + eb * 0.125\n            y1 = 0.75 + (eb + 1) * 0.125\n            rects.append((x0, y0, x1, y1))\n    weights = [1.0] * len(rects)  # uniform weights\n    P = 3\n    return rects, weights, P\n\ndef test_case_C():\n    # Left coarse [0,0.5]x[0,1], right half subdivided into 2x2\n    rects = []\n    # coarse left\n    rects.append((0.0, 0.0, 0.5, 1.0))\n    # right 2x2\n    for a in range(2):\n        for b in range(2):\n            x0 = 0.5 + a * 0.25\n            x1 = 0.5 + (a + 1) * 0.25\n            y0 = b * 0.5\n            y1 = (b + 1) * 0.5\n            rects.append((x0, y0, x1, y1))\n    # weights: level 0 for left -> 1, level 1 for right -> 2\n    weights = [1.0] + [2.0] * 4\n    P = 2\n    return rects, weights, P\n\ndef test_case_D():\n    # Two vertical halves, P=3\n    rects = [(0.0, 0.0, 0.5, 1.0), (0.5, 0.0, 1.0, 1.0)]\n    weights = [1.0, 1.0]\n    P = 3\n    return rects, weights, P\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        test_case_A(),\n        test_case_B(),\n        test_case_C(),\n        test_case_D(),\n    ]\n\n    results_str = []\n    for rects, weights, P in test_cases:\n        centers = centers_of_rects(rects)\n        h_idxs = hilbert_indices(centers, b=16)\n        # Sort by (hilbert, ix, iy)\n        order = sorted(range(len(rects)), key=lambda i: (h_idxs[i][0], h_idxs[i][1], h_idxs[i][2]))\n        parts = assign_partitions_by_midpoint(weights, order, P)\n        L = compute_load_metric(weights, parts, P)\n        E = count_cut_edges(rects, parts)\n        # Format load metric to 6 decimals\n        L_str = f\"{L:.6f}\"\n        results_str.append(f\"[{L_str},{E}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3509227"}]}