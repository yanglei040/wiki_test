{"hands_on_practices": [{"introduction": "任何超新星模拟都始于一个前身星模型，这些模型通常来自一维恒星演化代码，提供密度、温度等连续的物理量剖面。为了在我们的模拟中使用这些模型，我们必须将它们离散化到计算网格上，这一过程必须遵守基本的守恒定律，例如质量守恒。这个练习 [@problem_id:3533781] 提供了在这一基本初始化步骤中的实践经验，通过实现一个稳健的映射算法并验证其守恒特性，你将为整个模拟的准确性奠定基础。", "problem": "给定球对称的前身星剖面，由质量密度 $\\rho(r)$（单位为 $\\mathrm{g\\,cm^{-3}}$）、热力学温度 $T(r)$（单位为 $\\mathrm{K}$）和电子分数 $Y_e(r)$（无量纲）的连续函数描述。您的目标是将这些函数映射到一个由同心球壳构成的有限体积球坐标网格上，并以一种既能强制实施重子质量守恒又能保持强度标量的质量加权积分的方式计算单元平均量。您必须从第一性原理推导出一个算法，该算法能够构建映射后的球壳平均场并验证积分的保持性。\n\n从以下基本原理开始：\n- 球坐标体积元 $dV = 4\\pi r^2 dr$。\n- 球壳体积 $V_i = \\int_{r_{i-1/2}}^{r_{i+1/2}} 4\\pi r^2\\,dr$。\n- 总重子质量 $M = \\int_0^{R_{\\max}} \\rho(r)\\,dV$（单位为 $\\mathrm{g}$）。\n- 强度标量 $\\phi(r)$（例如电子分数或温度）的质量加权积分为 $I_\\phi = \\int_0^{R_{\\max}} \\rho(r)\\,\\phi(r)\\,dV$。\n\n定义必须从连续场计算的有限体积球壳平均量：\n- 球壳平均密度 $\\bar{\\rho}_i$ 必须满足 $\\bar{\\rho}_i V_i = \\int_{r_{i-1/2}}^{r_{i+1/2}} \\rho(r)\\,dV$，以确保每个球壳中的重子质量守恒。\n- 对于任何强度标量 $\\phi(r)$，球壳平均质量加权值 $\\bar{\\phi}_i$ 必须满足 $\\bar{\\phi}_i \\left(\\bar{\\rho}_i V_i\\right) = \\int_{r_{i-1/2}}^{r_{i+1/2}} \\rho(r)\\,\\phi(r)\\,dV$，以保持球壳积分的质量加权量。\n\n您的程序必须：\n- 在 $[0,R_{\\max}]$ 上构建一个具有 $N$ 个球壳的球坐标网格，使用比率 $q \\ge 1$ 的几何间距。令 $\\Delta r_i = \\Delta r_0\\,q^i$ 对于 $i=0,\\dots,N-1$，其中 $\\sum_{i=0}^{N-1}\\Delta r_i = R_{\\max}$。这定义了球壳边界 $r_{i+1/2}$，其中 $r_{1/2}=0$ 且 $r_{N+1/2}=R_{\\max}$。\n- 对每个球壳，通过计算所需的体积和质量加权积分来计算 $V_i$、$\\bar{\\rho}_i$、$\\overline{Y_e}_i$ 和 $\\bar{T}_i$。对所需的积分使用数值稳定且精确的求积方法。如果某个剖面是分段定义的，在已知半径 $r = r_\\star$ 处存在间断点，则应在 $r_\\star$ 处分割任何积分以确保稳健性。\n- 通过为每个测试案例计算以下相对误差来验证积分保持性：\n  - 总质量的相对误差 $\\epsilon_M = \\left|\\sum_i \\bar{\\rho}_i V_i - \\int_0^{R_{\\max}} \\rho(r)\\,dV\\right| \\big/ \\left(\\int_0^{R_{\\max}} \\rho(r)\\,dV\\right)$。\n  - 质量加权电子分数积分的相对误差 $\\epsilon_{Y} = \\left|\\sum_i \\bar{\\rho}_i \\overline{Y_e}_i V_i - \\int_0^{R_{\\max}} \\rho(r) Y_e(r)\\,dV\\right| \\big/ \\left(\\int_0^{R_{\\max}} \\rho(r) Y_e(r)\\,dV\\right)$。\n  - 质量加权温度积分的相对误差 $\\epsilon_{T} = \\left|\\sum_i \\bar{\\rho}_i \\bar{T}_i V_i - \\int_0^{R_{\\max}} \\rho(r) T(r)\\,dV\\right| \\big/ \\left(\\int_0^{R_{\\max}} \\rho(r) T(r)\\,dV\\right)$。\n这三个误差都是无量纲的，必须以十进制浮点数的形式报告。\n\n使用以下测试套件，所有半径单位为 $\\mathrm{cm}$，密度单位为 $\\mathrm{g\\,cm^{-3}}$，温度单位为 $\\mathrm{K}$，电子分数为无量纲：\n\n测试案例 1（光滑的类多方球核）：\n- 域半径 $R_{\\max} = 3\\times 10^8$。\n- 网格参数 $N=128$, $q=1.03$。\n- 剖面：\n  - $\\rho(r) = \\dfrac{\\rho_c}{\\left(1 + \\left(\\dfrac{r}{r_c}\\right)^2\\right)^n}$，其中 $\\rho_c = 10^{10}$，$r_c = 10^7$，$n = 1.5$。\n  - $T(r) = \\dfrac{T_c}{1 + \\left(\\dfrac{r}{2\\times 10^7}\\right)^{1.3}}$，其中 $T_c = 7\\times 10^9$。\n  - $Y_e(r) = 0.5 - 0.1\\,\\dfrac{r}{R_{\\max}}$。\n\n测试案例 2（不连续的核-包层过渡）：\n- 域半径 $R_{\\max} = 3\\times 10^8$。\n- 网格参数 $N=96$, $q=1.05$。\n- 过渡半径 $r_{\\mathrm{core}} = 1.5\\times 10^8$。\n- 剖面：\n  - $\\rho(r) = \\begin{cases}\n    6\\times 10^9,   r \\le r_{\\mathrm{core}},\\\\\n    6\\times 10^9 \\left(\\dfrac{r}{r_{\\mathrm{core}}}\\right)^{-3},  r  r_{\\mathrm{core}}.\n    \\end{cases}$\n  - $T(r) = 8\\times 10^9 \\exp\\!\\left(-\\dfrac{r}{1.2\\times 10^8}\\right)$。\n  - $Y_e(r) = \\begin{cases}\n    0.44,   r \\le r_{\\mathrm{core}},\\\\\n    0.50,  r  r_{\\mathrm{core}}.\n    \\end{cases}$\n对于此案例，在积分时必须显式处理 $r=r_{\\mathrm{core}}$ 处的间断点。\n\n测试案例 3（中心陡峭、快速变化的核）：\n- 域半径 $R_{\\max} = 2.5\\times 10^8$。\n- 网格参数 $N=200$, $q=1.02$。\n- 剖面：\n  - $\\rho(r) = 2\\times 10^{10}\\,\\exp\\!\\left(-\\left(\\dfrac{r}{2\\times 10^7}\\right)^{1/2}\\right)$。\n  - $T(r) = \\dfrac{10^{10}}{1 + \\left(\\dfrac{r}{5\\times 10^7}\\right)^{1.5}}$。\n  - $Y_e(r) = 0.48 - 0.05\\,\\tanh\\!\\left(\\dfrac{r}{10^8}\\right)$。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含三个测试案例的所有九个相对误差，按顺序串联为 $\\left[\\epsilon_M^{(1)},\\epsilon_{Y}^{(1)},\\epsilon_{T}^{(1)},\\epsilon_M^{(2)},\\epsilon_{Y}^{(2)},\\epsilon_{T}^{(2)},\\epsilon_M^{(3)},\\epsilon_{Y}^{(3)},\\epsilon_{T}^{(3)}\\right]$，形式为一个用方括号括起来的逗号分隔列表（例如，$\\left[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0\\right]$）。这些值必须是十进制浮点数。不涉及角度。所有报告的值都是无单位的相对误差。", "solution": "该问题要求开发并实现一个算法，将连续的、球对称的前身星剖面映射到一个离散的有限体积网格上。该映射必须严格遵守重子质量守恒，并保持强度热力学量的总质量加权积分。所实现算法的有效性将通过计算离散化总和与“精确”连续积分之间的相对误差来验证。\n\n理论推导从第一性原理出发，过程如下。\n\n**1. 球坐标网格构建**\n一维径向域 $[0, R_{\\max}]$ 被离散化为 $N$ 个连续、不重叠的同心球壳。设球壳索引为 $i = 0, 1, \\dots, N-1$。球壳 $i$ 是半径为 $r_i$ 和 $r_{i+1}$ 的球面所包围的体积。这定义了位于半径 $r_0, r_1, \\dots, r_N$ 处的 $N+1$ 个界面，其中 $r_0 = 0$ 且 $r_N = R_{\\max}$。\n\n网格间距是几何的，意味着每个球壳的宽度 $\\Delta r_i = r_{i+1} - r_i$ 遵循关系 $\\Delta r_i = \\Delta r_0 \\, q^i$，其中比率 $q \\ge 1$ 为常数。第一个球壳的宽度 $\\Delta r_0$ 由所有球壳宽度之和必须等于总域大小的约束条件确定：\n$$ R_{\\max} = \\sum_{i=0}^{N-1} \\Delta r_i = \\sum_{i=0}^{N-1} \\Delta r_0 \\, q^i = \\Delta r_0 \\sum_{i=0}^{N-1} q^i $$\n对于 $q  1$，几何级数之和为 $\\frac{q^N-1}{q-1}$，这给出 $\\Delta r_0 = R_{\\max} \\frac{q-1}{q^N-1}$。对于均匀间距，即 $q=1$ 的情况，和为 $N$，给出 $\\Delta r_0 = R_{\\max}/N$。\n\n界面半径由此完全确定。从 $r_0=0$ 开始，每个后续半径计算如下：\n$$ r_{j} = \\sum_{k=0}^{j-1} \\Delta r_k = \\sum_{k=0}^{j-1} \\Delta r_0 \\, q^k = \\Delta r_0 \\frac{q^j - 1}{q-1} \\quad (\\text{对于 } j=1, \\dots, N \\text{ 且 } q  1) $$\n对于 $q=1$，这简化为 $r_j = j \\cdot \\Delta r_0$。\n\n**2. 物理量的离散化**\n目标是定义满足守恒律的球壳平均量（$\\bar{\\rho}_i$, $\\overline{Y_e}_i$, $\\bar{T}_i$）。\n\n**球壳体积**\n球壳 $i$ 的体积 $V_i$ 是球坐标体积元 $dV = 4\\pi r^2 dr$ 在其边界半径 $r_i$ 和 $r_{i+1}$ 之间的积分：\n$$ V_i = \\int_{r_i}^{r_{i+1}} 4\\pi r^2 dr = 4\\pi \\left[\\frac{r^3}{3}\\right]_{r_i}^{r_{i+1}} = \\frac{4\\pi}{3} (r_{i+1}^3 - r_i^3) $$\n这是一个精确的解析公式。\n\n**质量守恒和球壳平均密度**\n包含在球壳 $i$ 内的重子质量，记为 $M_i$，是连续密度函数 $\\rho(r)$ 在该球壳体积上的积分：\n$$ M_i = \\int_{V_i} \\rho(r) \\, dV = \\int_{r_i}^{r_{i+1}} \\rho(r) (4\\pi r^2) dr $$\n质量守恒原理要求分配给离散单元的质量（由 $\\bar{\\rho}_i V_i$ 给出）必须与连续质量 $M_i$ 完全相等。这定义了球壳平均密度 $\\bar{\\rho}_i$：\n$$ \\bar{\\rho}_i V_i = M_i \\implies \\bar{\\rho}_i = \\frac{M_i}{V_i} = \\frac{\\int_{r_i}^{r_{i+1}} 4\\pi \\rho(r) r^2 dr}{\\frac{4\\pi}{3} (r_{i+1}^3 - r_i^3)} = \\frac{3}{r_{i+1}^3 - r_i^3} \\int_{r_i}^{r_{i+1}} \\rho(r) r^2 dr $$\n\n**质量加权标量积分的保持**\n对于任何强度标量 $\\phi(r)$（例如，温度 $T(r)$ 或电子分数 $Y_e(r)$），我们必须保持其质量加权积分。球壳 $i$ 中量 $\\rho \\phi$ 的总量为 $\\int_{V_i} \\rho(r) \\phi(r) dV$。在离散化方案中，这表示为 $\\bar{\\phi}_i M_i$。将两者等同，定义了质量加权的球壳平均值 $\\bar{\\phi}_i$：\n$$ \\bar{\\phi}_i M_i = \\int_{V_i} \\rho(r) \\phi(r) dV = \\int_{r_i}^{r_{i+1}} \\rho(r) \\phi(r) (4\\pi r^2) dr $$\n$$ \\implies \\bar{\\phi}_i = \\frac{1}{M_i} \\int_{r_i}^{r_{i+1}} \\rho(r) \\phi(r) (4\\pi r^2) dr $$\n这种表述确保了所有球壳上离散量的总和能够正确地再现连续量在全局上的积分。\n\n**3. 数值计算与验证**\n对于任意的剖面 $\\rho(r)$ 和 $\\phi(r)$，$M_i$ 和 $\\bar{\\phi}_i M_i$ 的积分通常无法解析求解。它们必须使用数值求积法来计算。高质量的自适应求积例程，例如 Python 中的 `scipy.integrate.quad`，适合此任务。这些例程可以达到接近机器精度的准确性。\n\n对于具有已知间断点的剖面，例如测试案例 2 中在 $r=r_{\\mathrm{core}}$ 处的间断点，将这些点告知求积算法至关重要。如果一个球壳 $[r_i, r_{i+1}]$ 包含 $r_{\\mathrm{core}}$，则必须将积分分割，或者将该点传递给积分器，以避免数值误差并确保结果准确。\n\n验证过程确认了映射的完整性。根据构造，离散球壳上某个量的总和必须等于连续域上的总积分，其精度仅受数值积分和浮点运算的限制。\n来自网格的总质量为 $M_{\\mathrm{grid}} = \\sum_{i=0}^{N-1} \\bar{\\rho}_i V_i = \\sum_{i=0}^{N-1} M_i$。\n“精确”的总质量为 $M_{\\mathrm{tot}} = \\int_0^{R_{\\max}} \\rho(r) dV$。\n质量的相对误差为：\n$$ \\epsilon_M = \\frac{\\left| M_{\\mathrm{grid}} - M_{\\mathrm{tot}} \\right|}{M_{\\mathrm{tot}}} $$\n类似地，对于一个标量 $\\phi$，来自网格的总质量加权量为 $I_{\\phi, \\mathrm{grid}} = \\sum_{i=0}^{N-1} \\bar{\\phi}_i M_i$。\n“精确”的总量为 $I_{\\phi, \\mathrm{tot}} = \\int_0^{R_{\\max}} \\rho(r) \\phi(r) dV$。\n相对误差为：\n$$ \\epsilon_\\phi = \\frac{\\left| I_{\\phi, \\mathrm{grid}} - I_{\\phi, \\mathrm{tot}} \\right|}{I_{\\phi, \\mathrm{tot}}} $$\n这些误差量化了数值方法的自洽性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    # Test Case 1: Smooth, polytrope-like core\n    case1 = {\n        \"R_max\": 3e8,\n        \"N\": 128,\n        \"q\": 1.03,\n        \"discontinuity_points\": None,\n        \"rho_func\": lambda r: 1e10 / (1 + (r / 1e7)**2)**1.5,\n        \"T_func\": lambda r: 7e9 / (1 + (r / 2e7)**1.3),\n        \"Ye_func\": lambda r: 0.5 - 0.1 * r / 3e8,\n    }\n\n    # Test Case 2: Discontinuous core-envelope transition\n    r_core_case2 = 1.5e8\n    \n    def rho_case2(r):\n        return np.where(r = r_core_case2, 6e9, 6e9 * (r / r_core_case2)**(-3))\n\n    def T_case2(r):\n        return 8e9 * np.exp(-r / 1.2e8)\n\n    def Ye_case2(r):\n        return np.where(r = r_core_case2, 0.44, 0.50)\n\n    case2 = {\n        \"R_max\": 3e8,\n        \"N\": 96,\n        \"q\": 1.05,\n        \"discontinuity_points\": [r_core_case2],\n        \"rho_func\": rho_case2,\n        \"T_func\": T_case2,\n        \"Ye_func\": Ye_case2,\n    }\n\n    # Test Case 3: Centrally peaked, rapidly varying core\n    case3 = {\n        \"R_max\": 2.5e8,\n        \"N\": 200,\n        \"q\": 1.02,\n        \"discontinuity_points\": None,\n        \"rho_func\": lambda r: 2e10 * np.exp(-(r / 2e7)**0.5),\n        \"T_func\": lambda r: 1e10 / (1 + (r / 5e7)**1.5),\n        \"Ye_func\": lambda r: 0.48 - 0.05 * np.tanh(r / 1e8),\n    }\n\n    test_cases = [case1, case2, case3]\n    all_results = []\n\n    for case in test_cases:\n        errors = process_case(case)\n        all_results.extend(errors)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef process_case(case_params):\n    \"\"\"\n    Processes a single test case: builds the grid, computes averaged quantities,\n    and returns the relative errors.\n    \"\"\"\n    R_max = case_params[\"R_max\"]\n    N = case_params[\"N\"]\n    q = case_params[\"q\"]\n    rho_func = case_params[\"rho_func\"]\n    T_func = case_params[\"T_func\"]\n    Ye_func = case_params[\"Ye_func\"]\n    points = case_params[\"discontinuity_points\"]\n\n    # 1. Grid Construction\n    interfaces = np.zeros(N + 1)\n    if q == 1.0:\n        interfaces = np.linspace(0, R_max, N + 1)\n    else:\n        # dr_0 = R_max * (q - 1) / (q^N - 1)\n        dr0 = R_max * (q - 1) / (q**N - 1)\n        # r_j = dr_0 * (q^j - 1) / (q - 1)\n        # Using a loop to avoid potential floating point issues with large powers\n        # A closed form is also good: r_j = dr0 * (q**j - 1) / (q - 1)\n        for j in range(1, N + 1):\n             interfaces[j] = dr0 * (q**j - 1) / (q - 1)\n    \n    # 2. Define Integrands\n    # Integrand for mass: rho(r) * 4 * pi * r^2\n    mass_integrand = lambda r: rho_func(r) * 4.0 * np.pi * r**2\n    # Integrand for mass-weighted Ye: Ye(r) * rho(r) * 4 * pi * r^2\n    Ye_integrand = lambda r: Ye_func(r) * rho_func(r) * 4.0 * np.pi * r**2\n    # Integrand for mass-weighted T: T(r) * rho(r) * 4 * pi * r^2\n    T_integrand = lambda r: T_func(r) * rho_func(r) * 4.0 * np.pi * r**2\n\n    # 3. Calculate \"Exact\" Total Integrals\n    M_total = quad(mass_integrand, 0, R_max, points=points)[0]\n    IY_total = quad(Ye_integrand, 0, R_max, points=points)[0]\n    IT_total = quad(T_integrand, 0, R_max, points=points)[0]\n    \n    # 4. Compute Shell Quantities and Sums\n    shell_masses = np.zeros(N)\n    shell_I_Ye = np.zeros(N)\n    shell_I_T = np.zeros(N)\n\n    for i in range(N):\n        r_a, r_b = interfaces[i], interfaces[i+1]\n        \n        # Integrate over the shell\n        # M_i = integral of mass_integrand from r_a to r_b\n        shell_masses[i] = quad(mass_integrand, r_a, r_b, points=points)[0]\n        # I_{Y,i} = integral of Ye_integrand from r_a to r_b\n        shell_I_Ye[i] = quad(Ye_integrand, r_a, r_b, points=points)[0]\n        # I_{T,i} = integral of T_integrand from r_a to r_b\n        shell_I_T[i] = quad(T_integrand, r_a, r_b, points=points)[0]\n\n    # Sum up the discrete shell quantities\n    # By construction, M_grid = Sum(M_i)\n    M_grid = np.sum(shell_masses)\n    \n    # By construction, IY_grid = Sum(Ye_bar_i * M_i) = Sum(I_{Y,i}/M_i * M_i) = Sum(I_{Y,i})\n    IY_grid = np.sum(shell_I_Ye)\n    IT_grid = np.sum(shell_I_T)\n\n    # 5. Calculate Relative Errors\n    eps_M = np.abs(M_grid - M_total) / M_total if M_total != 0 else 0.0\n    eps_Y = np.abs(IY_grid - IY_total) / IY_total if IY_total != 0 else 0.0\n    eps_T = np.abs(IT_grid - IT_total) / IT_total if IT_total != 0 else 0.0\n    \n    return [eps_M, eps_Y, eps_T]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3533781"}, {"introduction": "当恒星坍缩时，其中的物理过程发生在迥异的时间尺度上。虽然流体的整体运动（流体动力学）可能在毫秒量级上变化，但像电子俘获这样的弱相互作用过程的时间尺度可能短至微秒，尤其是在高密度下，这种“刚性”问题对数值积分构成了重大挑战。在这个实践中 [@problem_id:3533784]，你将为一个模型化的电子俘获源项实现一个简单的隐式-显式（IMEX）方案，并分析其稳定性和准确性，从而对现代模拟代码如何处理超新星物理的多尺度特性获得关键的洞察。", "problem": "考虑核塌缩超新星内陷阶段的单个拉格朗日流体元。忽略在所关心时间步长上的平流和中微子输运反馈，电子分数由于原子核和自由质子上的电子俘获而演化，其演化遵循以下常微分方程（ODE）：\n$$\n\\frac{dY_e}{dt}=-\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e,\n$$\n其中 $Y_e$ 是电子分数，$\\lambda_{\\mathrm{ec}}(\\rho)$ 是电子俘获率，此处将其建模为仅依赖于密度的幂律形式：\n$$\n\\lambda_{\\mathrm{ec}}(\\rho)=\\lambda_0\\left(\\frac{\\rho}{\\rho_0}\\right)^{\\alpha}.\n$$\n假设常数为：\n$$\n\\lambda_0=5\\,\\mathrm{s^{-1}},\\quad \\rho_0=10^9\\,\\mathrm{g\\,cm^{-3}},\\quad \\alpha=0.6.\n$$\n使用线性源项的 $\\theta$ 方法分裂，为刚性源项实现一个单参数的隐式-显式 (IMEX) 更新，该更新在大小为 $\\Delta t$ 的单个时间步长上进行：\n$$\nY_e^{n+1}=Y_e^n+\\Delta t\\left[-(1-\\theta)\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^n-\\theta\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^{n+1}\\right],\n$$\n使用一个固定的隐式参数：\n$$\n\\theta=0.3.\n$$\n对于这个线性测试问题，更新是一个线性放大映射 $Y_e^{n+1}=G\\,Y_e^n$，其放大因子为 $G(\\Delta t,\\rho,\\theta)$。使用这个放大因子，您必须根据以下两个属性对每个 $(\\Delta t,\\rho)$ 对进行分类：\n\n- 具有物理单调性的数值稳定性：当且仅当 $0\\le G(\\Delta t,\\rho,\\theta)\\le 1$ 时，将该步长声明为“稳定”(stable)，这保证了 $Y_e$ 的符号不变且不增加。\n- 局部精度：如果单步相对误差（相对于精确解）低于容差 $\\varepsilon$，则将该步长声明为“精确”(accurate)，\n$$\n\\frac{\\left|G(\\Delta t,\\rho,\\theta)-e^{-\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t}\\right|}{e^{-\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t}}\\le \\varepsilon,\\quad \\varepsilon=10^{-3}.\n$$\n\n您必须推导出 $G(\\Delta t,\\rho,\\theta)$ 并将其应用于以下密度和时间步长的测试套件：\n\n- 密度 (单位为 $\\mathrm{g\\,cm^{-3}}$)：$\\rho\\in\\{10^8,10^{10},10^{12}\\}$。\n- 时间步长 (单位为 $\\mathrm{s}$)：$\\Delta t\\in\\{10^{-6},10^{-4},10^{-3},5\\times 10^{-3},2\\times 10^{-2}\\}$。\n\n对于每个有序对 $(\\rho,\\Delta t)$，分配一个分类代码 $c$，定义如下：\n- 如果步长是稳定且精确的，则 $c=2$。\n- 如果步长是稳定但不精确的，则 $c=1$。\n- 如果步长是不稳定的（即，在单调稳定区域之外），则 $c=0$。\n\n您的程序必须计算上述集合的笛卡尔积的所有分类，排序方式为 $\\rho$ 作为外层循环（升序），$\\Delta t$ 作为内层循环（升序）。输出必须是单行，包含按此顺序排列的 15 个整数代码，形式为逗号分隔的列表，并用方括号括起来，例如 $[c_1,c_2,\\dots,c_{15}]$。所有计算都应使用上面为 $\\rho$ 和 $\\Delta t$ 提供的单位，输出代码是无量纲的整数。不应打印任何其他文本。\n\n您的实现必须是一个完整的、可运行的程序，通过推导和使用 $G(\\Delta t,\\rho,\\theta)$ 来执行上述分类；不要硬编码答案。", "solution": "我们从拉格朗日流体元的电子分数演化方程开始，\n$$\n\\frac{dY_e}{dt}=-\\lambda_{\\mathrm{ec}}(\\rho)Y_e,\n$$\n其中电子俘获率建模为\n$$\n\\lambda_{\\mathrm{ec}}(\\rho)=\\lambda_0\\left(\\frac{\\rho}{\\rho_0}\\right)^{\\alpha},\\quad \\lambda_0=5\\,\\mathrm{s^{-1}},\\ \\rho_0=10^9\\,\\mathrm{g\\,cm^{-3}},\\ \\alpha=0.6.\n$$\n对于单个时间步长内固定的 $\\rho$，该常微分方程是常系数线性的，其在大小为 $\\Delta t$ 的步长上的精确解是\n$$\nY_e(t+\\Delta t)=Y_e(t)\\,e^{-\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t}.\n$$\n为了设计一个数值上鲁棒的更新方案，该方案能隐式处理刚性问题，同时保留隐式-显式 (IMEX) 分裂的概念，我们考虑对源项进行 $\\theta$ 方法划分。设 $Y_e^n$ 是时刻 $t^n$ 的状态，$Y_e^{n+1}$ 是时刻 $t^{n+1}=t^n+\\Delta t$ 的状态。我们将其离散化为\n$$\nY_e^{n+1}=Y_e^n+\\Delta t\\left[-(1-\\theta)\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^n-\\theta\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^{n+1}\\right],\n$$\n其中 $\\theta$ 是一个固定的隐式参数。这是一种有效的 IMEX 处理方法，因为它将部分刚性项进行隐式处理，而将其余部分进行显式处理；当只有刚性源项存在时，它简化为一个单参数的线性隐式更新族。重新整理该离散方程可得\n$$\nY_e^{n+1}+\\Delta t\\,\\theta\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^{n+1}=Y_e^n-\\Delta t\\,(1-\\theta)\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,Y_e^n,\n$$\n于是\n$$\nY_e^{n+1}=\\frac{1-(1-\\theta)\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t}{1+\\theta\\,\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t}\\,Y_e^n.\n$$\n定义无量纲刚性参数 $z=\\lambda_{\\mathrm{ec}}(\\rho)\\,\\Delta t$。则放大因子为\n$$\nG(z,\\theta)=\\frac{1-(1-\\theta)\\,z}{1+\\theta\\,z}.\n$$\n对于这个物理衰减问题，我们施加的稳定性要求是具有物理单调性的数值稳定性，即 $0\\le G\\le 1$。因为对于 $z\\ge 0$ 和 $\\theta\\ge 0$，分母 $1+\\theta z$ 严格为正，所以条件 $0\\le G\\le 1$ 可简化为\n$$\n0\\le 1-(1-\\theta)\\,z\\le 1+\\theta\\,z.\n$$\n右侧不等式 $1-(1-\\theta)z\\le 1+\\theta z$ 对于 $z\\ge 0$ 总是成立。左侧不等式 $1-(1-\\theta)z\\ge 0$ 给出了单调稳定区域\n$$\n0\\le z\\le \\frac{1}{1-\\theta}.\n$$\n对于给定的选择 $\\theta=0.3$，此界限为\n$$\n0\\le z\\le \\frac{1}{1-0.3}=\\frac{1}{0.7}\\approx 1.428571\\ldots\n$$\n因此，任何满足 $z=\\lambda_{\\mathrm{ec}}(\\rho)\\Delta t\\le 1/(1-\\theta)$ 的 $(\\rho,\\Delta t)$ 对都是单调稳定的，否则该方法将得到 $G0$ 并违反物理单调衰减，我们将其分类为不稳定。\n\n在精度方面，我们将数值单步更新与精确单步解进行比较。精确放大因子是 $e^{-z}$，数值放大因子是 $G(z,\\theta)$。单步相对误差为\n$$\n\\mathrm{err}(z,\\theta)=\\frac{\\left|G(z,\\theta)-e^{-z}\\right|}{e^{-z}}.\n$$\n如果 $\\mathrm{err}(z,\\theta)\\le \\varepsilon$（其中 $\\varepsilon=10^{-3}$），我们声明该步长是精确的。对于小的 $z$，泰勒展开证实了其一阶精度：$G(z,\\theta)=1-z+\\theta(1-\\theta)z^2+\\mathcal{O}(z^3)$ 而 $e^{-z}=1-z+\\tfrac{1}{2}z^2+\\mathcal{O}(z^3)$，这给出了一个在主导阶上与 $|(\\theta(1-\\theta)-\\tfrac{1}{2})z^2|$ 成正比的局部误差。随着 $z$ 的增加，误差增大，并在一个依赖于问题的阈值处超过容差。\n\n为了评估测试套件，我们为每个指定的密度 $\\rho\\in\\{10^8,10^{10},10^{12}\\}\\,\\mathrm{g\\,cm^{-3}}$ 计算\n$$\n\\lambda_{\\mathrm{ec}}(\\rho)=5\\left(\\frac{\\rho}{10^9\\,\\mathrm{g\\,cm^{-3}}}\\right)^{0.6}\\,\\mathrm{s^{-1}}\n$$\n然后对于每个 $\\Delta t\\in\\{10^{-6},10^{-4},10^{-3},5\\times 10^{-3},2\\times 10^{-2}\\}\\,\\mathrm{s}$ 计算 $z=\\lambda_{\\mathrm{ec}}(\\rho)\\Delta t$。对于每个对，我们计算 $G(z,0.3)$，通过 $0\\le G\\le 1$ 来测试稳定性，并计算误差 $\\mathrm{err}(z,0.3)$ 与 $\\varepsilon=10^{-3}$ 进行比较。如果稳定且精确，则分配分类代码 $c=2$；如果稳定但不精确，则为 $c=1$；如果不稳定，则为 $c=0$。\n\n在算法上，这可以简化为：\n- 按升序遍历 $\\rho$ 和 $\\Delta t$。\n- 计算 $\\lambda_{\\mathrm{ec}}(\\rho)$ 和 $z$。\n- 计算 $G$ 并检查 $0\\le G\\le 1$ 以判断稳定性。\n- 计算 $\\mathrm{err}$ 并与 $\\varepsilon$ 比较以判断精度。\n- 将相应的整数代码附加到结果列表中。\n\n最后，以 $[c_1,c_2,\\dots,c_{15}]$ 的精确格式将结果打印为单行。此过程确保了在 $(\\Delta t,\\rho)$ 平面上，针对指定的 IMEX 更新和速率模型，使用基于刚性源项指数衰减动力学的、具有物理意义的标准来映射稳定性和精度区域。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lambda_ec(rho, lambda0=5.0, rho0=1e9, alpha=0.6):\n    \"\"\"\n    Electron-capture rate model: lambda_ec = lambda0 * (rho / rho0)^alpha\n    rho in g/cm^3, lambda in 1/s\n    \"\"\"\n    return lambda0 * (rho / rho0) ** alpha\n\ndef amplification_factor(z, theta):\n    \"\"\"\n    Amplification factor G for the theta-IMEX update on y' = -lambda y with z=lambda*dt.\n    G = (1 - (1-theta)*z) / (1 + theta*z)\n    \"\"\"\n    return (1.0 - (1.0 - theta) * z) / (1.0 + theta * z)\n\ndef classify_case(rho, dt, theta=0.3, eps=1e-3):\n    \"\"\"\n    Classify one (rho, dt) pair.\n    Returns:\n        2 if stable and accurate,\n        1 if stable but not accurate,\n        0 if unstable (violates monotone stability 0 = G = 1).\n    \"\"\"\n    lam = lambda_ec(rho)\n    z = lam * dt\n    G = amplification_factor(z, theta)\n    # Monotone stability: non-negative and no growth.\n    stable = (G >= 0.0) and (G = 1.0)\n    if not stable:\n        return 0\n    # Relative one-step error vs exact exponential decay.\n    exact = np.exp(-z)\n    rel_err = abs(G - exact) / exact if exact != 0.0 else np.inf\n    if rel_err = eps:\n        return 2\n    else:\n        return 1\n\ndef solve():\n    # Define the test cases from the problem statement.\n    densities = [1e8, 1e10, 1e12]  # g/cm^3\n    timesteps = [1e-6, 1e-4, 1e-3, 5e-3, 2e-2]  # s\n    theta = 0.3\n    eps = 1e-3\n\n    results = []\n    for rho in densities:\n        for dt in timesteps:\n            c = classify_case(rho, dt, theta=theta, eps=eps)\n            results.append(c)\n\n    # Final print statement in the exact required format: no spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3533784"}, {"introduction": "核心坍缩理论的中心问题是：什么使停滞的激波复苏并驱动恒星爆炸？主流的延迟中微子驱动机制理论认为，这取决于一场竞赛：来自原中子星的中微子能否比吸积流将物质席卷走（即平流）更快地将能量沉积在激波后的物质中？这场竞赛可以被描述为两个特征时间尺度的比较：加热时间尺度（$\\tau_{\\mathrm{heat}}$）和平流时间尺度（$\\tau_{\\mathrm{adv}}$）。这个练习 [@problem_id:3533769] 将指导你建立一个简化但物理上富有洞察力的模型来描述这个临界条件，通过推导和实现这些时间尺度的公式，你将直接检验吸积率和激波位置等因素如何影响超新星成功爆炸的可能性。", "problem": "您的任务是推导、实现并测试一个用于核塌缩超新星增益区（gain region）的球对称、光学薄（optically thin）加热模型。您的目标是计算中微子加热效率，并基于特征时间尺度的比值来评估激波复苏（shock revival）条件。结果必须是一个完整的、可运行的程序，能够为指定的测试组输出所要求的值。\n\n从以下基本依据和核心定义出发：\n- 牛顿引力和引力势能：在中心质量 $M_{\\mathrm{NS}}$ 的势场中，位于半径 $r$ 处的质量元具有比引力势 $-\\dfrac{G M_{\\mathrm{NS}}}{r}$，其中 $G$ 是引力常数。\n- 稳流中的质量守恒：控制体积内质量的平流驻留时间等于该体积内的总质量除以通过它的质量通量。\n- 纯吸收的光学薄辐射转移：沿径向轨迹穿过质量柱密度为 $\\Sigma$ 的薄层时，入射能量通量的吸收分数为 $1-e^{-\\tau}$，其中光学深度 $\\tau=\\kappa\\,\\Sigma$，$\\kappa$ 是质量吸收不透明度。\n- 带电流电子味中微子吸收截面与中微子能量平方的定标关系：$\\sigma_{\\mathrm{abs}}(\\varepsilon)\\approx \\sigma_0\\left(\\dfrac{\\varepsilon}{\\mathrm{MeV}}\\right)^2$，其中 $\\sigma_0$ 是一个常数。\n\n假设一个从半径 $R_g$（增益半径）到 $R_s$（激波半径）的球对称增益区，其密度分布为幂律形式\n$$\n\\rho(r)=\\rho_g\\left(\\dfrac{r}{R_g}\\right)^{-n},\n$$\n并且为了分析上的易处理性，取 $n=2$。给定中微子光度 $L_\\nu$ 和有效平均中微子能量 $\\langle \\varepsilon_\\nu \\rangle$。\n\n推导并实现以下内容，仅使用上述基本依据（不要引用任何其他专门的超新星定标关系）：\n\n1) 加热效率。使用光学薄吸收模型将加热效率表示为增益层吸收的中微子光度分数，\n$$\n\\eta \\equiv \\dfrac{\\dot{Q}_{\\mathrm{heat}}}{L_\\nu} = 1 - e^{-\\tau_{\\mathrm{gain}}}, \\quad \\tau_{\\mathrm{gain}} = \\int_{R_g}^{R_s} \\kappa\\,\\rho(r)\\,dr,\n$$\n其中质量吸收不透明度为\n$$\n\\kappa = \\dfrac{\\sigma_{\\mathrm{abs}}}{m_b} = \\dfrac{\\sigma_0}{m_b}\\left(\\dfrac{\\langle \\varepsilon_\\nu \\rangle}{\\mathrm{MeV}}\\right)^2,\n$$\n其中 $m_b$ 是重子质量。对于 $n=2$，计算增益区的柱密度\n$$\n\\Sigma \\equiv \\int_{R_g}^{R_s} \\rho(r)\\,dr = \\rho_g R_g \\left(1 - \\dfrac{R_g}{R_s}\\right),\n$$\n因此 $\\tau_{\\mathrm{gain}}=\\kappa\\,\\Sigma$。\n\n2) 平流时间尺度。使用质量守恒，计算平流驻留时间\n$$\n\\tau_{\\mathrm{adv}} = \\dfrac{M_{\\mathrm{gain}}}{\\dot{M}},\n$$\n其中对于 $n=2$ 的增益质量为\n$$\nM_{\\mathrm{gain}} = 4\\pi \\int_{R_g}^{R_s} \\rho(r)\\,r^2\\,dr = 4\\pi \\rho_g R_g^2 \\left(R_s - R_g\\right).\n$$\n\n3) 加热时间尺度。计算增益区引力束缚能的大小为\n$$\nE_{\\mathrm{bind}} = 4\\pi G M_{\\mathrm{NS}} \\int_{R_g}^{R_s} \\rho(r)\\,r\\,dr = 4\\pi G M_{\\mathrm{NS}} \\rho_g R_g^2 \\ln\\!\\left(\\dfrac{R_s}{R_g}\\right),\n$$\n以及净中微子加热率为 $\\dot{Q}_{\\mathrm{heat}}=\\eta L_\\nu$。然后定义\n$$\n\\tau_{\\mathrm{heat}} = \\dfrac{E_{\\mathrm{bind}}}{\\dot{Q}_{\\mathrm{heat}}}.\n$$\n\n4) 激波复苏条件。将激波复苏诊断量定义为\n$$\n\\mathcal{R} \\equiv \\dfrac{\\tau_{\\mathrm{adv}}}{\\tau_{\\mathrm{heat}}},\n$$\n如果 $\\mathcal{R}  1$，则宣布复苏。\n\n使用的常数和单位：\n- 所有计算必须使用厘米-克-秒（cgs）单位制。\n- 引力常数 $G = 6.674\\times 10^{-8}\\,\\mathrm{cm^3\\,g^{-1}\\,s^{-2}}$。\n- 太阳质量 $M_\\odot = 1.98847\\times 10^{33}\\,\\mathrm{g}$。\n- 中子星质量 $M_{\\mathrm{NS}} = 1.4\\,M_\\odot$。\n- 增益半径 $R_g = 100\\,\\mathrm{km} = 1.0\\times 10^{7}\\,\\mathrm{cm}$。\n- 增益半径处的密度归一化值 $\\rho_g = 1.0\\times 10^{9}\\,\\mathrm{g\\,cm^{-3}}$。\n- 密度幂律指数 $n=2$（如上所述）。\n- 中微子光度 $L_\\nu = 3.0\\times 10^{52}\\,\\mathrm{erg\\,s^{-1}}$。\n- 有效平均中微子能量 $\\langle \\varepsilon_\\nu \\rangle = 12\\,\\mathrm{MeV}$。\n- 重子质量 $m_b = 1.674\\times 10^{-24}\\,\\mathrm{g}$。\n- 带电流吸收截面系数 $\\sigma_0 = 9.0\\times 10^{-44}\\,\\mathrm{cm^2}$。\n\n测试组。对于每种情况，给定吸积率 $\\dot{M}$（单位为 $M_\\odot\\,\\mathrm{s^{-1}}$）和激波半径 $R_s$（单位为 $\\mathrm{km}$）：\n- 情况 A：$\\dot{M} = 0.3$, $R_s=150$。\n- 情况 B：$\\dot{M} = 0.05$, $R_s=150$。\n- 情况 C：$\\dot{M} = 1.0$, $R_s=150$。\n- 情况 D：$\\dot{M} = 0.3$, $R_s=250$。\n- 情况 E（极低吸积率的边缘情况）：$\\dot{M} = 0.01$, $R_s=150$。\n\n对于每种情况，计算：\n- 加热效率 $\\eta$（无量纲）。\n- 比值 $\\mathcal{R}=\\tau_{\\mathrm{adv}}/\\tau_{\\mathrm{heat}}$（无量纲）。\n- 布尔标志 $\\mathrm{revive}$，如果 $\\mathcal{R}1$ 则定义为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含五个测试用例的结果列表，顺序为 [情况 A, 情况 B, 情况 C, 情况 D, 情况 E]。\n- 每个测试用例的结果必须是一个形式为 $[\\mathrm{revive}, \\eta, \\mathcal{R}]$ 的嵌套列表，其中 $\\mathrm{revive}$ 是一个布尔值，$\\eta$ 和 $\\mathcal{R}$ 是四舍五入到六位小数的浮点数。\n- 最终输出必须是包含整个列表的单行文本，不含任何额外文字，例如：$[[\\mathrm{False},0.012345,0.678901],[\\mathrm{True},0.023456,1.234567],\\dots]$。\n\n角度单位不适用。无需其他输入。所有常数和参数均已在上方提供。所有结果均为无量纲，且必须按规定打印为四舍五入到六位小数的浮点数。", "solution": "该问题要求推导并实现一个用于核塌缩超新星增益区的中微子加热的简化球对称模型。目标是计算中微子加热效率 $\\eta$、特征时间尺度的比值 $\\mathcal{R} = \\tau_{\\mathrm{adv}}/\\tau_{\\mathrm{heat}}$，并根据此比值为一组给定的参数确定激波复苏条件。所有计算将在厘米-克-秒（cgs）单位制下进行。\n\n该模型基于一套基本原理和定义。增益区从增益半径 $R_g$ 延伸至激波半径 $R_s$。该区域内的密度分布遵循幂律 $\\rho(r)=\\rho_g(r/R_g)^{-n}$，指数指定为 $n=2$。\n\n推导过程分为三个主要步骤，随后是计算实现的描述。\n\n1.  **加热效率 $\\eta$**\n\n加热效率 $\\eta$ 定义为增益区物质吸收的总中微子光度 $L_\\nu$ 的分数。因此，净加热率为 $\\dot{Q}_{\\mathrm{heat}} = \\eta L_\\nu$。\n\n使用所提供的纯吸收光学薄辐射转移模型，效率由下式给出：\n$$\n\\eta = 1 - e^{-\\tau_{\\mathrm{gain}}}\n$$\n其中 $\\tau_{\\mathrm{gain}}$ 是增益区对中微子的总光学深度。光学深度通过沿径向路径从 $R_g$ 到 $R_s$ 积分质量吸收不透明度 $\\kappa$ 和质量密度 $\\rho(r)$ 的乘积来计算：\n$$\n\\tau_{\\mathrm{gain}} = \\int_{R_g}^{R_s} \\kappa\\,\\rho(r)\\,dr\n$$\n不透明度 $\\kappa$ 在整个增益区内被假定为常数。它由每个重子的中微子吸收截面 $\\sigma_{\\mathrm{abs}}$ 和重子质量 $m_b$ 导出。鉴于截面与中微子能量 $\\varepsilon$ 的平方相关，$\\sigma_{\\mathrm{abs}}(\\varepsilon) \\approx \\sigma_0 (\\varepsilon/\\mathrm{MeV})^2$，对于有效平均能量为 $\\langle \\varepsilon_\\nu \\rangle$ 的中微子，其不透明度为：\n$$\n\\kappa = \\dfrac{\\sigma_{\\mathrm{abs}}}{m_b} = \\dfrac{\\sigma_0}{m_b}\\left(\\dfrac{\\langle \\varepsilon_\\nu \\rangle}{\\mathrm{MeV}}\\right)^2\n$$\n光学深度的积分简化为 $\\tau_{\\mathrm{gain}} = \\kappa \\Sigma$，其中 $\\Sigma$ 是增益区的总质量柱密度。对于 $n=2$ 的特定情况，问题给出了积分结果：\n$$\n\\Sigma = \\int_{R_g}^{R_s} \\rho(r)\\,dr = \\int_{R_g}^{R_s} \\rho_g \\left(\\dfrac{r}{R_g}\\right)^{-2} dr = \\rho_g R_g \\left(1 - \\dfrac{R_g}{R_s}\\right)\n$$\n通过由给定常数计算 $\\kappa$ 以及为每个测试用例的 $R_s$ 计算 $\\Sigma$，我们可以确定 $\\tau_{\\mathrm{gain}}$，进而确定加热效率 $\\eta$。\n\n2.  **特征时间尺度：$\\tau_{\\mathrm{adv}}$ 和 $\\tau_{\\mathrm{heat}}$**\n\n超新星激波的复苏由两个过程的竞争所主导：物质通过增益区的平流和中微子对该物质的加热。这些过程由平流时间尺度 $\\tau_{\\mathrm{adv}}$ 和加热时间尺度 $\\tau_{\\mathrm{heat}}$ 来表征。\n\n**平流时间尺度** $\\tau_{\\mathrm{adv}}$ 是物质在增益区内的驻留时间。基于稳流中的质量守恒，它是增益区内总质量 $M_{\\mathrm{gain}}$ 与质量吸积率 $\\dot{M}$ 的比值：\n$$\n\\tau_{\\mathrm{adv}} = \\dfrac{M_{\\mathrm{gain}}}{\\dot{M}}\n$$\n增益区中的质量 $M_{\\mathrm{gain}}$ 通过在从 $R_g$到$R_s$的球壳体积上对密度进行积分得到。对于给定的 $n=2$ 密度分布，该积分已提供：\n$$\nM_{\\mathrm{gain}} = 4\\pi \\int_{R_g}^{R_s} \\rho(r)\\,r^2\\,dr = 4\\pi \\int_{R_g}^{R_s} \\rho_g \\left(\\dfrac{r}{R_g}\\right)^{-2} r^2\\,dr = 4\\pi \\rho_g R_g^2 (R_s - R_g)\n$$\n**加热时间尺度** $\\tau_{\\mathrm{heat}}$ 表示吸收的中微子能量克服增益区物质的引力束缚所需的时间。它被定义为增益质量的引力束缚能大小 $E_{\\mathrm{bind}}$ 与净加热率 $\\dot{Q}_{\\mathrm{heat}}$ 的比值：\n$$\n\\tau_{\\mathrm{heat}} = \\dfrac{E_{\\mathrm{bind}}}{\\dot{Q}_{\\mathrm{heat}}}\n$$\n束缚能 $E_{\\mathrm{bind}}$ 通过对增益区内所有质量元的比引力势能进行积分来计算。中心天体是一颗质量为 $M_{\\mathrm{NS}}$ 的中子星。对于 $n=2$ 的密度分布，此积分已提供：\n$$\nE_{\\mathrm{bind}} = 4\\pi G M_{\\mathrm{NS}} \\int_{R_g}^{R_s} \\rho(r)\\,r\\,dr = 4\\pi G M_{\\mathrm{NS}} \\int_{R_g}^{R_s} \\rho_g \\left(\\dfrac{r}{R_g}\\right)^{-2} r\\,dr = 4\\pi G M_{\\mathrm{NS}} \\rho_g R_g^2 \\ln\\left(\\dfrac{R_s}{R_g}\\right)\n$$\n分母 $\\dot{Q}_{\\mathrm{heat}}$ 使用先前确定的加热效率 $\\eta$ 和给定的中微子光度 $L_\\nu$ 来计算。\n\n3.  **激波复苏条件**\n\n平流与加热之间的竞争由无量纲比值 $\\mathcal{R}$ 量化：\n$$\n\\mathcal{R} \\equiv \\dfrac{\\tau_{\\mathrm{adv}}}{\\tau_{\\mathrm{heat}}}\n$$\n$\\mathcal{R}  1$ 的值表示加热时间尺度短于平流时间尺度。这意味着物质在被平流吸积到中子星上之前，已被充分加热至非束缚状态。因此，在该模型中，激波成功复苏的条件是 $\\mathcal{R}  1$。\n\n计算流程如下：\n首先，在 cgs 单位制中定义所有物理常数（$G$，$M_\\odot$ 等）。计算中子星质量 $M_{\\mathrm{NS}}$。质量吸收不透明度 $\\kappa$ 对所有测试用例都是一个常数，只需计算一次。\n\n对于每个由吸积率 $\\dot{M}$（单位 $M_\\odot\\,\\mathrm{s^{-1}}$）和激波半径 $R_s$（单位 km）指定的测试用例：\n1.  将 $\\dot{M}$ 转换为 $\\mathrm{g\\,s^{-1}}$，将 $R_s$ 转换为 $\\mathrm{cm}$。\n2.  使用给定的 $R_s$ 计算柱密度 $\\Sigma$。\n3.  计算光学深度 $\\tau_{\\mathrm{gain}} = \\kappa\\Sigma$ 和加热效率 $\\eta = 1 - e^{-\\tau_{\\mathrm{gain}}}$。\n4.  计算增益区质量 $M_{\\mathrm{gain}}$。\n5.  计算平流时间尺度 $\\tau_{\\mathrm{adv}} = M_{\\mathrm{gain}}/\\dot{M}$。\n6.  计算增益区的束缚能 $E_{\\mathrm{bind}}$。\n7.  计算总加热率 $\\dot{Q}_{\\mathrm{heat}} = \\eta L_\\nu$。\n8.  计算加热时间尺度 $\\tau_{\\mathrm{heat}} = E_{\\mathrm{bind}}/\\dot{Q}_{\\mathrm{heat}}$。\n9.  计算诊断比值 $\\mathcal{R} = \\tau_{\\mathrm{adv}}/\\tau_{\\mathrm{heat}}$。\n10. 确定复苏标志：如果 $\\mathcal{R}  1$ 则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n11. 按照要求的精度存储和格式化结果（$\\mathrm{revive}$，$\\eta$，$\\mathcal{R}$）。\n\n这种对推导公式的系统性应用，使得能够为每个指定的场景评估激波复苏条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the neutrino heating efficiency and shock revival condition for\n    a simplified core-collapse supernova model.\n    \"\"\"\n    \n    # Constants and units (all in cgs)\n    G = 6.674e-8        # Gravitational constant [cm^3 g^-1 s^-2]\n    M_SOLAR = 1.98847e33 # Solar mass [g]\n    M_NS = 1.4 * M_SOLAR # Neutron star mass [g]\n    R_g = 1.0e7          # Gain radius [cm] (100 km)\n    rho_g = 1.0e9        # Density at gain radius [g cm^-3]\n    L_nu = 3.0e52        # Neutrino luminosity [erg s^-1]\n    eps_nu_mean = 12.0   # Effective mean neutrino energy [MeV]\n    m_b = 1.674e-24      # Baryon mass [g]\n    sigma_0 = 9.0e-44    # Cross-section coefficient [cm^2]\n\n    # Pre-calculate constant mass absorption opacity kappa [cm^2 g^-1]\n    kappa = (sigma_0 / m_b) * (eps_nu_mean**2)\n\n    # Test suite: (M_dot [M_solar/s], R_s [km])\n    test_cases = [\n        (0.3, 150.0),   # Case A\n        (0.05, 150.0),  # Case B\n        (1.0, 150.0),   # Case C\n        (0.3, 250.0),   # Case D\n        (0.01, 150.0),  # Case E\n    ]\n\n    results = []\n    for m_dot_msun_s, r_s_km in test_cases:\n        # Convert inputs to cgs units\n        m_dot = m_dot_msun_s * M_SOLAR  # Mass accretion rate [g s^-1]\n        r_s = r_s_km * 1.0e5          # Shock radius [cm]\n\n        # 1) Heating efficiency eta\n        # Column density Sigma [g cm^-2]\n        Sigma = rho_g * R_g * (1.0 - R_g / r_s)\n        \n        # Optical depth tau_gain (dimensionless)\n        tau_gain = kappa * Sigma\n        \n        # Heating efficiency eta (dimensionless)\n        eta = 1.0 - np.exp(-tau_gain)\n\n        # 2) Advective timescale tau_adv\n        # Mass in the gain region M_gain [g]\n        M_gain = 4.0 * np.pi * rho_g * R_g**2 * (r_s - R_g)\n        \n        # Advective timescale tau_adv [s]\n        tau_adv = M_gain / m_dot\n\n        # 3) Heating timescale tau_heat\n        # Gravitational binding energy of the gain region E_bind [erg]\n        E_bind = 4.0 * np.pi * G * M_NS * rho_g * R_g**2 * np.log(r_s / R_g)\n        \n        # Net heating rate Q_heat_dot [erg s^-1]\n        Q_heat_dot = eta * L_nu\n        \n        # Heating timescale tau_heat [s]\n        tau_heat = E_bind / Q_heat_dot\n\n        # 4) Shock revival condition\n        # Diagnostic ratio R (dimensionless)\n        R_ratio = tau_adv / tau_heat\n        \n        # Revival flag (boolean)\n        revive = R_ratio > 1.0\n        \n        results.append([revive, eta, R_ratio])\n\n    # Final print statement in the exact required format.\n    # Format: [[bool,float,float],[bool,float,float],...]\n    output_strings = []\n    for res in results:\n        bool_str = str(res[0])\n        eta_str = f\"{res[1]:.6f}\"\n        R_str = f\"{res[2]:.6f}\"\n        output_strings.append(f\"[{bool_str},{eta_str},{R_str}]\")\n    \n    print(f\"[{','.join(output_strings)}]\")\n\nsolve()\n```", "id": "3533769"}]}