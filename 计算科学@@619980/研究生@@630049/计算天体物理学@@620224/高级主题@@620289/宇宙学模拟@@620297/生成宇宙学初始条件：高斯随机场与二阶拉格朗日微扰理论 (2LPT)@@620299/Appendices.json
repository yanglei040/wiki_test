{"hands_on_practices": [{"introduction": "在计算宇宙学中，几乎所有基于周期性边界条件的操作都依赖于快速傅里叶变换（FFT）。因此，动手实践的第一步是精确掌握计算网格（数组索引）与物理傅里叶空间（波矢 $\\boldsymbol{k}$）之间的映射关系。本练习将指导你如何正确处理不同的FFT约定，并强制施加实数场所需的厄米对称性，这是避免在初始条件中引入非物理伪影的关键。[@problem_id:3512441]", "problem": "您正在为三维周期性立方体区域上的高斯随机场生成宇宙学初始条件，该区域的边长为 $L_x$、$L_y$ 和 $L_z$，并在一个大小为 $N_x$、$N_y$ 和 $N_z$、间距为 $\\Delta_x = L_x/N_x$、$\\Delta_y = L_y/N_y$ 和 $\\Delta_z = L_z/N_z$ 的规则网格上进行了离散化。您将通过在傅里叶空间中求解类泊松方程来计算一阶和二阶拉格朗日微扰理论 (2LPT) 位移，因此您必须准确地将快速傅里叶变换 (FFT) 数组索引映射到物理波矢分量，并确保实空间场的实数性质。\n\n从在网格上采样的实标量场 $\\delta(\\mathbf{x})$ 的离散傅里叶变换的定义开始，该定义与整数 $m_a \\in \\mathbb{Z}$（其中 $a \\in \\{x,y,z\\}$）上的三维周期性傅里叶级数表示一致：\n$$\n\\delta(\\mathbf{x}_{\\mathbf{n}}) = \\sum_{\\mathbf{m}} \\tilde{\\delta}(\\mathbf{k}_{\\mathbf{m}}) \\exp\\!\\left(i \\mathbf{k}_{\\mathbf{m}} \\cdot \\mathbf{x}_{\\mathbf{n}}\\right), \\quad \\mathbf{x}_{\\mathbf{n}} = \\left(n_x \\Delta_x, n_y \\Delta_y, n_z \\Delta_z\\right), \\quad \\mathbf{k}_{\\mathbf{m}} = \\left(\\tfrac{2\\pi m_x}{L_x}, \\tfrac{2\\pi m_y}{L_y}, \\tfrac{2\\pi m_z}{L_z}\\right),\n$$\n其中 $n_a \\in \\{0,1,\\dots,N_a-1\\}$。对于实数场 $\\delta(\\mathbf{x})$，其傅里叶系数遵循厄米共轭对称性 $\\tilde{\\delta}(-\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^\\ast$。\n\n在实践中，FFT 库以不同的索引顺序呈现离散谱。两种常见的约定是：\n- 每个轴 $a$ 的原始、“未移位”的 FFT 输出顺序，其索引为 $i_a \\in \\{0,1,\\dots,N_a-1\\}$。\n- 重新索引的“移位”顺序（例如，通过一个将零频率移动到中心的函数），其索引 $s_a \\in \\{0,1,\\dots,N_a-1\\}$ 对应于从负到正升序排列的有符号频率。\n\n为确保生成的高斯随机场以及所有导出的一阶和二阶拉格朗日微扰理论位移场在实空间中严格为实数，必须在每种约定下使用从 FFT 数组索引到物理 $\\mathbf{k}$ 值的正确整数频率映射，并对自共轭的零频模式和奈奎斯特模式进行正确处理。\n\n哪个选项正确地指定了：\n(i) 在三维情况下（包括偶数和奇数 $N_a$），对于未移位和移位两种约定，从 FFT 数组索引到整数三元组 $(m_x, m_y, m_z)$ 进而到物理 $\\mathbf{k}$ 的映射，以及\n(ii) 为满足 $\\tilde{\\delta}(-\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^\\ast$ 以确保 $\\delta(\\mathbf{x})$ 为实数所需的对零频和奈奎斯特模式的正确处理？\n\n选择最佳选项。\n\nA. 未移位映射：对于每个大小为 $N_a$ 且原始索引为 $i_a \\in \\{0,\\dots,N_a-1\\}$ 的轴 $a$，定义整数频率：\n对于偶数 $N_a$：\n$$\nm_a(i_a) = \\begin{cases}\ni_a,  0 \\le i_a \\le N_a/2 \\\\\ni_a - N_a,  N_a/2  i_a \\le N_a-1\n\\end{cases}\n$$\n对于奇数 $N_a$：\n$$\nm_a(i_a) = \\begin{cases}\ni_a,  0 \\le i_a \\le (N_a-1)/2 \\\\\ni_a - N_a,  (N_a-1)/2  i_a \\le N_a-1\n\\end{cases}\n$$\n移位映射：对于每个移位索引为 $s_a \\in \\{0,\\dots,N_a - 1\\}$ 的轴 $a$，定义\n$$\nm_a(s_a) = s_a - \\left\\lfloor \\tfrac{N_a}{2} \\right\\rfloor,\n$$\n使得有符号整数从 $- \\left\\lfloor \\tfrac{N_a}{2} \\right\\rfloor$ 升序排列至 $+\\left\\lceil \\tfrac{N_a}{2} \\right\\rceil - 1$。物理波矢为\n$$\nk_a = \\frac{2\\pi m_a}{L_a}, \\quad \\mathbf{k} = (k_x, k_y, k_z).\n$$\n零频和奈奎斯特模式处理：通过配对不同的模式来强制实现 $\\tilde{\\delta}(-\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^\\ast$；对于在离散对称性 $2 m_a \\equiv 0 \\pmod{N_a}$（对所有 $a$ 成立）下是其自身负值的任何模式（即，当 $N_a$ 为偶数时，每个分量 $m_a \\in \\{0, N_a/2\\}$），将 $\\tilde{\\delta}(\\mathbf{k})$ 设置为纯实数。特别地，零频模式 $(m_x,m_y,m_z)=(0,0,0)$ 以及所有 $m_a \\in \\{0, N_a/2\\}$（如适用）的“角落”奈奎斯特组合都是实数。所有其他模式都通过厄米共轭配对处理。\n\nB. 未移位映射：对于 $i_a \\in \\{0,\\dots,N_a-1\\}$，$k_a = \\dfrac{2\\pi i_a}{L_a}$，无环绕；移位映射：$k_a = \\dfrac{2\\pi s_a}{L_a}$。零频和奈奎斯特模式处理：只有零频模式必须为实数；奈奎斯特模式可以是具有独立实部和虚部的复数，因为它们的负值在其他地方表示。\n\nC. 未移位映射：当 $i_a  N_a/2$ 时 $m_a(i_a) = i_a$，当 $i_a \\ge N_a/2$ 时 $m_a(i_a) = N_a/2 - i_a$；移位映射：对于所有 $s_a$，$m_a(s_a) = s_a$。物理波数值为 $k_a = \\dfrac{m_a}{\\Delta_a}$，不含因子 $2\\pi$。零频和奈奎斯特模式处理：仅当恰好一个轴处于奈奎斯特值时才将虚部设置为零；零频模式无需约束，因为厄米共轭对称性将在逆 FFT 后强制实现实数性。\n\nD. 未移位映射：对于所有 $i_a$，$m_a(i_a) = i_a - N_a$；移位映射：$m_a(s_a) = s_a - N_a$，使得负索引占据前半部分，但零频率位于索引 $s_a = N_a$ 处。物理波数值为 $k_a = \\dfrac{\\pi m_a}{L_a}$，限制在范围 $\\lvert k_a \\rvert \\le \\dfrac{\\pi}{\\Delta_a}$ 内。零频和奈奎斯特模式处理：将包括零频和奈奎斯特在内的所有模式都视为独立的复数自由度，并依赖数值舍入来抵消实空间中的虚部。", "solution": "我们从有限三维域上的周期性傅里叶级数开始。对于每个轴 $a \\in \\{x,y,z\\}$，在长度为 $L_a$ 的周期域上的场的连续表示允许具有物理波数的离散傅里叶模式\n$$\nk_a = \\frac{2\\pi m_a}{L_a}, \\quad m_a \\in \\mathbb{Z}.\n$$\n在均匀网格 $\\{n_a \\in \\{0,\\dots,N_a-1\\}\\}$ 上采样会选择这些整数 $m_a$ 的一个有限集合，它们具有相关的离散傅里叶变换系数 $\\tilde{\\delta}(\\mathbf{k}_{\\mathbf{m}})$，逆变换通过以下方式重建场：\n$$\n\\delta(\\mathbf{x}_{\\mathbf{n}}) = \\sum_{m_x} \\sum_{m_y} \\sum_{m_z} \\tilde{\\delta}(\\mathbf{k}_{\\mathbf{m}}) \\exp\\!\\left(i \\left(\\frac{2\\pi m_x}{L_x} n_x \\Delta_x + \\frac{2\\pi m_y}{L_y} n_y \\Delta_y + \\frac{2\\pi m_z}{L_z} n_z \\Delta_z\\right)\\right),\n$$\n其中 $\\Delta_a = L_a/N_a$ 且 $\\mathbf{x}_{\\mathbf{n}} = (n_x \\Delta_x, n_y \\Delta_y, n_z \\Delta_z)$。离散傅里叶变换以由 FFT 约定决定的特定索引顺序来实现这些求和。\n\n关键是从 FFT 数组索引到整数频率 $\\mathbf{m} = (m_x, m_y, m_z)$ 的映射，后者再通过 $k_a = 2\\pi m_a / L_a$ 映射到物理 $\\mathbf{k}$。两种常见的约定是原始的“未移位”排序和“fftshifted”排序。\n\n未移位排序。对于每个轴 $a$，FFT 输出数组的索引为 $i_a \\in \\{0,1,\\dots,N_a-1\\}$。频率的排序方式是先出现非负整数，然后是负整数。对于偶数 $N_a$，标准的未移位整数序列是\n$$\n0,\\;1,\\;2,\\;\\dots,\\;\\frac{N_a}{2},\\;-\\frac{N_a}{2}+1,\\;-\\frac{N_a}{2}+2,\\;\\dots,\\;-1,\n$$\n这对应于映射\n$$\nm_a(i_a) = \\begin{cases}\ni_a,  0 \\le i_a \\le N_a/2 \\\\\ni_a - N_a,  N_a/2  i_a \\le N_a - 1\n\\end{cases}\n$$\n对于奇数 $N_a$，没有奈奎斯特整数；序列是\n$$\n0,\\;1,\\;2,\\;\\dots,\\;\\frac{N_a-1}{2},\\;-\\frac{N_a-1}{2},\\;-\\frac{N_a-1}{2}+1,\\;\\dots,\\;-1,\n$$\n映射变为\n$$\nm_a(i_a) = \\begin{cases}\ni_a,  0 \\le i_a \\le \\frac{N_a - 1}{2} \\\\\ni_a - N_a,  \\frac{N_a - 1}{2}  i_a \\le N_a - 1\n\\end{cases}\n$$\n这些表达式编码了负频率环绕（模 $N_a$）到索引范围上半部分的方式。\n\n移位排序。通过将零频率移动到数组中间的“移位”（例如“fftshift”）进行重新索引后，每个轴 $a$ 的整数序列是从负到正升序排列。对于偶数 $N_a$，它是\n$$\n-\\frac{N_a}{2},\\;-\\frac{N_a}{2}+1,\\;\\dots,\\;-1,\\;0,\\;1,\\;\\dots,\\;\\frac{N_a}{2}-1,\n$$\n对于奇数 $N_a$，它是\n$$\n-\\frac{N_a - 1}{2},\\;-\\frac{N_a - 1}{2}+1,\\;\\dots,\\;-1,\\;0,\\;1,\\;\\dots,\\;\\frac{N_a - 1}{2}.\n$$\n一个涵盖两种情况的紧凑映射是\n$$\nm_a(s_a) = s_a - \\left\\lfloor \\frac{N_a}{2} \\right\\rfloor, \\quad s_a \\in \\{0,\\dots,N_a - 1\\},\n$$\n这会产生所需的有序整数序列。在所有情况下，物理波矢分量都遵循 $k_a = 2\\pi m_a/L_a$。\n\n实数性和厄米共轭对称性。对于实数场 $\\delta(\\mathbf{x})$，其离散傅里叶系数必须满足厄米共轭对称性，\n$$\n\\tilde{\\delta}(-\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^\\ast,\n$$\n从而使逆变换为实数。对于 $-\\mathbf{k}$ 与 $\\mathbf{k}$ 处于不同数组索引的模式，通过在 $\\mathbf{k}$ 处生成一个复系数，并将其在 $-\\mathbf{k}$ 处的系数设置为其复共轭来强制实现这一点。然而，每当一个模式在离散对称性下是其自身的负值时，厄米条件就简化为 $\\tilde{\\delta}(\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^\\ast$，这意味着系数是纯实数。在离散情况下，一个模式是自共轭的，当且仅当对于每个轴 $a$，整数 $m_a$ 满足\n$$\n2 m_a \\equiv 0 \\pmod{N_a},\n$$\n这意味着当 $N_a$ 为偶数时，$m_a \\in \\{0, N_a/2\\}$；当 $N_a$ 为奇数时，$m_a = 0$。因此：\n- 零频模式 $(m_x,m_y,m_z) = (0,0,0)$ 总是纯实数。\n- 对于偶数 $N_a$，任何每个分量 $m_a \\in \\{0, N_a/2\\}$ 的“角落”组合都是自共轭的，并且必须是纯实数。在 $d$ 维空间中，最多有 $2^d$ 个这样的点（对于 $d=3$，最多 8 个点），具体取决于哪些轴具有偶数大小。\n- 所有其他模式都以 $\\pm \\mathbf{k}$ 对的形式出现，并且必须设置为复共轭对。\n\n这在宇宙学初始条件生成中至关重要：对零频和奈奎斯特模式的不当处理会违反 $\\tilde{\\delta}(-\\mathbf{k}) = \\tilde{\\delta}(\\mathbf{k})^\\ast$ 并导致实空间场中出现复数污染，从而破坏一阶位移（Zel’dovich 近似）和二阶拉格朗日微扰理论修正。\n\n我们现在评估各个选项。\n\n选项 A。此选项为偶数和奇数 $N_a$ 提供了正确的未移位映射，恰当地捕捉了负整数到索引范围上半部分的环绕。它提供了紧凑的移位映射 $m_a = s_a - \\lfloor N_a/2 \\rfloor$。物理 $k_a$ 正确地由 $k_a = 2\\pi m_a/L_a$ 给出。对于实数性处理，它正确地陈述了不同 $\\pm \\mathbf{k}$ 的厄米共轭配对，以及任何自身为负的模式（所有分量满足 $2 m_a \\equiv 0 \\pmod{N_a}$）必须是纯实数，并明确包括零频模式和所有奈奎斯特角落组合。这是一个正确且完整的规范。\n\n结论：正确。\n\n选项 B。此选项将 $k_a$ 线性映射到原始索引 $i_a$ 而没有环绕。它没有考虑负频率，因此无法恢复有符号整数谱；它还错误地将移位索引 $s_a$ 直接映射到正 $k_a$ 值。在处理零频和奈奎斯特模式时，它错误地声称奈奎斯特模式可以是具有独立实部和虚部的复数。这违反了 $m_a = N_a/2$（当 $N_a$ 为偶数时）模式的自共轭条件，使得逆变换非实数。\n\n结论：错误。\n\n选项 C。此选项提出当 $i_a  N_a/2$ 时 $m_a(i_a) = i_a$，否则 $m_a(i_a) = N_a/2 - i_a$，这不是标准的未移位映射，并产生不正确的负频率索引（例如，它以不匹配模 $N_a$ 算术的方式翻转符号和大小）。移位映射 $m_a(s_a) = s_a$ 也是错误的，因为它未能将零居中并包含负整数。物理波数值 $k_a = m_a/\\Delta_a$ 忽略了必需的因子 $2\\pi$ 并使用了错误的缩放。零频和奈奎斯特模式的处理不正确：自共轭性取决于所有轴，而不仅仅是恰好一个轴处于奈奎斯特值，并且零频模式必须明确约束为实数。\n\n结论：错误。\n\n选项 D。此选项对所有 $i_a$ 设置 $m_a(i_a) = i_a - N_a$，这错误地移动了整个频谱，并将零频率置于一个负整数处，不匹配任何常见的 FFT 排序。移位映射 $m_a(s_a) = s_a - N_a$ 同样将零错误地放在索引 $N_a$ 处，这超出了有效范围。物理波数值 $k_a = \\pi m_a/L_a$ 缺少因子 $2$，而所述限制 $\\lvert k_a \\rvert \\le \\pi/\\Delta_a$ 是抽样理论的陈述，而不是映射规则；此外，映射本身就是错误的。将零频和奈奎斯特模式作为独立的复数自由度处理是错误的，并且不能确保逆变换场为实数。\n\n结论：错误。\n\n因此，唯一一个既正确提供了常见 FFT 约定的索引到 $\\mathbf{k}$ 的映射，又提供了保持实数场一致性所必需的零频/奈奎斯特模式处理方法的选项是 A。", "answer": "$$\\boxed{A}$$", "id": "3512441"}, {"introduction": "在将复杂的数值代码应用于实际科学问题之前，验证其核心物理引擎的正确性至关重要。本练习采用一种称为“人造解法”（method of manufactured solutions）的经典验证技术，通过为一个简化的初始势能注入一个已知的解析解，来精确测试你的二阶拉格朗日微扰理论（2LPT）代码。通过将数值计算的二阶位移场与精确的解析结果进行比较，你可以独立地验证代码中非线性源项计算的准确性。[@problem_id:3512423]", "problem": "设计并实现一个独立的程序，构建一个周期性的三维拉格朗日微扰理论测试工具，用以验证由初始势中已知的潮汐四极矩引起的二阶拉格朗日微扰理论 (2LPT) 各向异性位移。在边长为 $L$ 的周期性立方体上完全使用无量纲量进行计算，并使用离散傅里叶变换求解泊松型方程。程序必须生成单行输出，包含一个浮点数值列表，每个值对应于特定测试用例下，2LPT 位移的数值均方根 (RMS) 分量与解析均方根 (RMS) 分量之间的最大相对误差。\n\n从以下基础出发：\n- 拉格朗日位移展开为 $\\boldsymbol{\\Psi} = \\sum_{n \\ge 1} \\boldsymbol{\\Psi}^{(n)}$，其中 $\\boldsymbol{\\Psi}^{(n)} = -\\boldsymbol{\\nabla} \\phi^{(n)}$，$ \\phi^{(n)}$ 是 $n$ 阶标量势。\n- 二阶拉格朗日微扰理论 (2LPT) 中标量势的二阶控制方程为\n$$\n\\nabla^2 \\phi^{(2)}(\\boldsymbol{x}) \\;=\\; \\sum_{ij} \\left( \\phi^{(1)}_{,ii}(\\boldsymbol{x}) \\, \\phi^{(1)}_{,jj}(\\boldsymbol{x}) \\;-\\; \\left[\\phi^{(1)}_{,ij}(\\boldsymbol{x})\\right]^2 \\right),\n$$\n其中 $\\phi^{(1)}_{,ij} \\equiv \\partial_i \\partial_j \\phi^{(1)}$。\n\n通过规定以下形式，将一个已知的、空间周期性的潮汐四极矩注入初始（一阶）势中：\n$$\n\\phi^{(1)}(\\boldsymbol{x}) \\;=\\; A \\sum_{i \\in \\{x,y,z\\}} a_i \\cos\\!\\left( K \\, x_i \\right),\n$$\n其中 $A$ 是一个无量纲振幅，$\\boldsymbol{a} = (a_x,a_y,a_z)$ 是一个编码四极各向异性的无量纲系数三元组，$K = 2\\pi m / L$ 是基本波数，其中整数模式指数 $m$。使用 $m=1$。在一个包含 $N^3$ 个点的规则网格上进行计算，该网格位于周期性立方体 $[0,L)^3$ 上。\n\n需要实现的任务：\n1. 仅使用一阶势的二阶导数构建 2LPT 标量势的实空间源项，\n$$\nS(\\boldsymbol{x}) \\;\\equiv\\; \\sum_{ij} \\left( \\phi^{(1)}_{,ii} \\phi^{(1)}_{,jj} - \\left[\\phi^{(1)}_{,ij}\\right]^2 \\right).\n$$\n对于上述可分离的余弦拟设，当 $i \\neq j$ 时 $\\phi^{(1)}_{,ij} = 0$，且 $\\phi^{(1)}_{,ii} = -A \\, a_i \\, K^2 \\cos(K x_i)$，因此\n$$\nS(\\boldsymbol{x}) \\;=\\; A^2 K^4 \\left( a_x a_y \\cos(K x) \\cos(K y) \\;+\\; a_x a_z \\cos(K x) \\cos(K z) \\;+\\; a_y a_z \\cos(K y) \\cos(K z) \\right).\n$$\n2. 使用谱方法在周期性立方体上求解泊松方程，\n$$\n\\nabla^2 \\phi^{(2)}(\\boldsymbol{x}) \\;=\\; S(\\boldsymbol{x}),\n$$\n其边界条件为周期性，且 $\\phi^{(2)}$ 的均值为零。在傅里叶空间中，对于每个非零波矢 $\\boldsymbol{k} = (k_x,k_y,k_z)$ 且 $k^2 = k_x^2 + k_y^2 + k_z^2$，解满足\n$$\n\\tilde{\\phi}^{(2)}(\\boldsymbol{k}) \\;=\\; - \\frac{\\tilde{S}(\\boldsymbol{k})}{k^2}, \\quad \\text{且} \\quad \\tilde{\\phi}^{(2)}(\\boldsymbol{0}) \\;=\\; 0,\n$$\n其中波浪号表示离散傅里叶变换。\n3. 通过谱方法微分计算二阶位移场，\n$$\n\\tilde{\\Psi}^{(2)}_i(\\boldsymbol{k}) \\;=\\; i k_i \\, \\tilde{\\phi}^{(2)}(\\boldsymbol{k}), \\quad \\text{并进行逆变换得到 } \\Psi^{(2)}_i(\\boldsymbol{x})。\n$$\n4. 在整个网格上计算每个分量的数值 RMS，\n$$\n\\mathrm{RMS}^{\\mathrm{num}}_i \\;=\\; \\sqrt{\\langle \\left(\\Psi^{(2)}_i(\\boldsymbol{x})\\right)^2 \\rangle_{\\boldsymbol{x}} }。\n$$\n5. 推导并计算所选可分离余弦拟设的解析 RMS。利用均匀网格上各坐标因子之间的独立性以及 $\\langle \\sin^2(K x_i) \\rangle = 1/2$、$\\langle \\cos^2(K x_i) \\rangle = 1/2$，第 $i$ 个分量的 RMS 为\n$$\n\\mathrm{RMS}^{\\mathrm{ana}}_i \\;=\\; \\frac{A^2 K^3}{4} \\, \\sqrt{ a_i^2 \\left( \\sum_{j \\neq i} a_j^2 \\right) }。\n$$\n6. 对于每个指定的测试用例，报告各分量中的最大相对误差，\n$$\n\\epsilon_{\\max} \\;=\\; \\max_{i \\in \\{x,y,z\\}} \\begin{cases}\n\\left| \\dfrac{\\mathrm{RMS}^{\\mathrm{num}}_i - \\mathrm{RMS}^{\\mathrm{ana}}_i}{\\mathrm{RMS}^{\\mathrm{ana}}_i} \\right|,  \\mathrm{若}\\ \\mathrm{RMS}^{\\mathrm{ana}}_i \\neq 0, \\\\\n\\left| \\mathrm{RMS}^{\\mathrm{num}}_i \\right|,  \\mathrm{若}\\ \\mathrm{RMS}^{\\mathrm{ana}}_i = 0.\n\\end{cases}\n$$\n\n数值实现要求：\n- 所有测试均使用边长 $L = 1$、网格大小 $N = 64$ 的周期性立方体。\n- 使用 $m = 1$，因此 $K = 2\\pi$。\n- 使用波数为 $k_i = 2\\pi \\, n_i / L$ 的离散傅里叶变换，其中 $n_i$ 是对应于 $N$ 尺寸网格上离散傅里叶变换的标准整数频率。\n- 全程使用无量纲单位。\n\n测试套件：\n- Case 1: $(A, a_x, a_y, a_z) = (0.05, 1, -1, 0)$。\n- Case 2: $(A, a_x, a_y, a_z) = (0.1, 1, 1, -2)$。\n- Case 3: $(A, a_x, a_y, a_z) = (0.2, 0, 0, 0)$。\n\n要求输出：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，按测试用例的顺序列出结果，例如 $[\\epsilon_1,\\epsilon_2,\\epsilon_3]$。每个 $\\epsilon_i$ 必须是一个浮点数。\n\n不出现物理单位；所有量均为严格无量纲。当角度出现在三角函数内部时，根据离散傅里叶表示的构造，其单位为弧度。", "solution": "用户提供的问题经评估有效。该问题科学合理、提法明确、客观，并包含得出唯一解所需的全部必要信息。核心任务是针对一个给定的解析解，实现对二阶拉格朗日微扰理论 (2LPT) 的数值检验，这是计算宇宙学中一种标准的验证程序。该方法依赖于在周期域上使用傅里叶分析求解微分方程的既定原则。\n\n以下是所实现解决方案的原则性、分步描述。\n\n程序的目标是计算数值计算出的二阶拉格朗日位移场 $\\boldsymbol{\\Psi}^{(2)}$ 与其在特定初始条件下的已知解析对应物之间的最大相对误差。整个过程在一个三维周期性网格上进行。\n\n**1. 网格与常数初始化**\n模拟域是一个边长为 $L=1$ 的周期性立方体，在一个包含 $N^3$ 个点的规则网格上离散化，其中 $N=64$。初始势的基本波数为 $K = 2\\pi m / L$，其中模式指数 $m=1$。由于 $L=1$，这简化为 $K=2\\pi$。我们构建三维坐标数组 $x, y, z$ 来表示网格点 $(x_i, y_j, z_k)$，其中 $i,j,k \\in \\{0, 1, \\dots, N-1\\}$。\n\n**2. 构建 2LPT 源项**\n问题始于一个给定的一阶势 $\\phi^{(1)}$，它是一个可分离的余弦拟设：\n$$\n\\phi^{(1)}(\\boldsymbol{x}) \\;=\\; A \\sum_{i \\in \\{x,y,z\\}} a_i \\cos\\!\\left( K \\, x_i \\right)\n$$\n二阶势 $\\phi^{(2)}$ 的源项 $S(\\boldsymbol{x})$ 由 $\\phi^{(1)}$ 的导数定义：\n$$\nS(\\boldsymbol{x}) \\;\\equiv\\; \\sum_{ij} \\left( \\phi^{(1)}_{,ii} \\phi^{(1)}_{,jj} - \\left[\\phi^{(1)}_{,ij}\\right]^2 \\right)\n$$\n对于给定的 $\\phi^{(1)}$ 的可分离形式，当 $i \\neq j$ 时，交叉导数 $\\phi^{(1)}_{,ij}$ 为零。二阶导数为 $\\phi^{(1)}_{,ii} = -A \\, a_i \\, K^2 \\cos(K x_i)$。将这些代入 $S(\\boldsymbol{x})$ 的定义，得到代码中使用的解析表达式：\n$$\nS(\\boldsymbol{x}) \\;=\\; A^2 K^4 \\left( a_x a_y \\cos(K x) \\cos(K y) \\;+\\; a_x a_z \\cos(K x) \\cos(K z) \\;+\\; a_y a_z \\cos(K y) \\cos(K z) \\right)\n$$\n对于每个测试用例给定的参数 $A$ 和 $\\boldsymbol{a}=(a_x, a_y, a_z)$，此源项在实空间网格上进行计算。\n\n**3. 二阶势的谱方法求解**\n二阶势 $\\phi^{(2)}$ 受泊松方程 $\\nabla^2 \\phi^{(2)}(\\boldsymbol{x}) = S(\\boldsymbol{x})$ 控制。在周期域上，使用谱方法求解此方程最为高效。\n首先，使用三维快速傅里叶变换 (FFT) 将源项变换到傅里叶空间，即 $\\tilde{S}(\\boldsymbol{k}) = \\mathcal{F}[S(\\boldsymbol{x})]$，这是通过 `scipy.fft.fftn` 实现的。\n在傅里叶空间中，拉普拉斯算子 $\\nabla^2$ 变为乘以 $-k^2$，其中 $k^2 = k_x^2 + k_y^2 + k_z^2$ 是波矢 $\\boldsymbol{k}$ 大小的平方。与网格对应的离散波矢 $k_i$ 是使用 `scipy.fft.fftfreq` 生成的。\n因此，泊松方程变换为关于势的傅里叶模式的代数方程：\n$$\n-k^2 \\tilde{\\phi}^{(2)}(\\boldsymbol{k}) = \\tilde{S}(\\boldsymbol{k}) \\quad \\implies \\quad \\tilde{\\phi}^{(2)}(\\boldsymbol{k}) = - \\frac{\\tilde{S}(\\boldsymbol{k})}{k^2}\n$$\n此解对所有 $\\boldsymbol{k} \\neq \\boldsymbol{0}$ 均有效。对于零频模式 ($\\boldsymbol{k}=\\boldsymbol{0}$)，除以 $k^2=0$ 是未定义的。势的均值为零的物理约束 $\\langle \\phi^{(2)} \\rangle=0$ 将傅里叶空间中的直流 (DC) 分量设为零，即 $\\tilde{\\phi}^{(2)}(\\boldsymbol{0})=0$。这在代码中得到了明确处理。\n\n**4. 2LPT 位移场的计算**\n2LPT 位移场是势的负梯度，$\\boldsymbol{\\Psi}^{(2)} = -\\boldsymbol{\\nabla}\\phi^{(2)}$。与拉普拉斯算子类似，梯度算子在傅里叶空间中具有简单的表示：$\\mathcal{F}[\\boldsymbol{\\nabla} f(\\boldsymbol{x})] = i\\boldsymbol{k}\\tilde{f}(\\boldsymbol{k})$。\n因此，位移场分量的傅里叶模式通过以下方式计算：\n$$\n\\tilde{\\Psi}^{(2)}_i(\\boldsymbol{k}) = -i k_i \\tilde{\\phi}^{(2)}(\\boldsymbol{k})\n$$\n一旦计算出傅里叶空间中的位移分量 $\\tilde{\\Psi}^{(2)}_i(\\boldsymbol{k})$，就使用逆快速傅里叶变换 (`scipy.fft.ifftn`) 将它们变换回实空间。由于原始场是实数，所得的位移分量 $\\Psi^{(2)}_i(\\boldsymbol{x})$也必须是实数。我们明确取逆 FFT 输出的实部，以丢弃任何由浮点不精确性引起的微小的虚部。\n\n**5. 验证与误差计算**\n过程的最后一部分是验证数值结果。\n每个位移分量的数值均方根 (RMS) 通过取整个网格上场值的平方的均值的平方根来计算：\n$$\n\\mathrm{RMS}^{\\mathrm{num}}_i \\;=\\; \\sqrt{\\frac{1}{N^3} \\sum_{\\boldsymbol{x}} \\left(\\Psi^{(2)}_i(\\boldsymbol{x})\\right)^2 }\n$$\n这是使用 `numpy.sqrt` 和 `numpy.mean` 实现的。\n这些数值结果与问题陈述中提供的解析推导的 RMS 值进行比较：\n$$\n\\mathrm{RMS}^{\\mathrm{ana}}_i \\;=\\; \\frac{A^2 K^3}{4} \\, \\sqrt{ a_i^2 \\left( \\sum_{j \\neq i} a_j^2 \\right) }\n$$\n对于每个分量 $i \\in \\{x,y,z\\}$，计算相对误差。需要进行条件检查以处理解析 RMS 为零的情况。如果 $\\mathrm{RMS}^{\\mathrm{ana}}_i = 0$，则误差定义为数值 RMS 的绝对值 $|\\mathrm{RMS}^{\\mathrm{num}}_i|$。否则，它是标准的相对误差 $|\\mathrm{RMS}^{\\mathrm{num}}_i - \\mathrm{RMS}^{\\mathrm{ana}}_i| / |\\mathrm{RMS}^{\\mathrm{ana}}_i|$。\n每个测试用例的最终输出是这三个分量误差中的最大值 $\\epsilon_{\\max}$。对所有指定的测试用例重复此整个过程。", "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef compute_2lpt_error(params):\n    \"\"\"\n    Computes the maximum relative error for 2LPT displacement for one test case.\n\n    This function implements the full chain:\n    1. Set up the grid and initial potential parameters.\n    2. Compute the real-space source term S(x).\n    3. Solve the Poisson equation for phi^(2) in Fourier space.\n    4. Compute the displacement field Psi^(2) via spectral differentiation.\n    5. Calculate numerical and analytical RMS values.\n    6. Return the maximum relative error across components.\n    \"\"\"\n    # Unpack test case parameters\n    A, ax, ay, az = params\n\n    # Numerical and physical constants\n    L = 1.0\n    N = 64\n    m = 1\n    K = 2.0 * np.pi * m / L\n\n    # 1. Construct the real-space grid\n    grid_1d = np.arange(N, dtype=float) * L / N\n    # Use 'ij' indexing for coordinate arrays to match the typical (x,y,z) loop order\n    x, y, z = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n\n    # 2. Construct the real-space source term for the 2LPT scalar potential\n    S = A**2 * K**4 * (\n        ax * ay * np.cos(K * x) * np.cos(K * y) +\n        ax * az * np.cos(K * x) * np.cos(K * z) +\n        ay * az * np.cos(K * y) * np.cos(K * z)\n    )\n\n    # 3. Solve the Poisson equation using spectral methods\n    # Fourier transform the source term\n    S_k = fft.fftn(S)\n\n    # Create the k-space grid of wavevectors\n    k_freq = fft.fftfreq(N, d=L / N) * 2.0 * np.pi\n    kx, ky, kz = np.meshgrid(k_freq, k_freq, k_freq, indexing='ij')\n    \n    # Calculate k-squared, handling the k=0 mode to avoid division by zero\n    k_squared = kx**2 + ky**2 + kz**2\n    # The [0,0,0] element is the DC mode (k=0).\n    # Temporarily set k_squared[0,0,0] to a non-zero value to avoid a warning.\n    k_squared[0, 0, 0] = 1.0\n\n    # Solve for phi_2_k = -S_k / k^2\n    phi2_k = -S_k / k_squared\n    # Enforce zero mean for phi^(2) by setting the k=0 mode to zero.\n    phi2_k[0, 0, 0] = 0.0\n\n    # 4. Compute the second-order displacement field by spectral differentiation\n    # Psi_i = -grad_i phi  =  Psi_i_k = -i * k_i * phi_k\n    Psi2x_k = -1j * kx * phi2_k\n    Psi2y_k = -1j * ky * phi2_k\n    Psi2z_k = -1j * kz * phi2_k\n\n    # Inverse transform to get real-space displacement fields\n    Psi2x = fft.ifftn(Psi2x_k).real\n    Psi2y = fft.ifftn(Psi2y_k).real\n    Psi2z = fft.ifftn(Psi2z_k).real\n\n    # 5. Compute the numerical RMS of each displacement component\n    rms_num_x = np.sqrt(np.mean(Psi2x**2))\n    rms_num_y = np.sqrt(np.mean(Psi2y**2))\n    rms_num_z = np.sqrt(np.mean(Psi2z**2))\n    rms_num = np.array([rms_num_x, rms_num_y, rms_num_z])\n\n    # 6. Derive and evaluate the analytic RMS\n    prefactor = (A**2 * K**3) / 4.0\n    a = np.array([ax, ay, az])\n    \n    rms_ana_x = prefactor * np.sqrt(a[0]**2 * (a[1]**2 + a[2]**2))\n    rms_ana_y = prefactor * np.sqrt(a[1]**2 * (a[0]**2 + a[2]**2))\n    rms_ana_z = prefactor * np.sqrt(a[2]**2 * (a[0]**2 + a[1]**2))\n    rms_ana = np.array([rms_ana_x, rms_ana_y, rms_ana_z])\n\n    # 7. Compute the maximum relative error across components\n    errors = np.zeros(3)\n    for i in range(3):\n        if rms_ana[i] != 0.0:\n            errors[i] = np.abs((rms_num[i] - rms_ana[i]) / rms_ana[i])\n        else:\n            errors[i] = np.abs(rms_num[i])\n            \n    return np.max(errors)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.05, 1.0, -1.0, 0.0),   # Case 1\n        (0.1, 1.0, 1.0, -2.0),    # Case 2\n        (0.2, 0.0, 0.0, 0.0),     # Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        max_error = compute_2lpt_error(case)\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3512423"}, {"introduction": "在验证了核心算法之后，我们现在可以将这些工具组合起来，解决一个更完整、更接近实际研究的课题。本练习将引导你为包含多种物质成分（例如冷暗物质和重子）的宇宙模型生成初始条件，这些成分在小尺度上具有不同的演化行为。这个综合性实践整合了高斯随机场的生成、传递函数的应用、一阶和二阶位移的计算，以及对最终场进行统计一致性检验的全过程。[@problem_id:3512400]", "problem": "您的任务是构建一个程序，使用高斯随机场和二阶拉格朗日微扰理论（2LPT），在周期性立方体区域内为两种无压强物质生成三维宇宙学初始条件。该程序必须计算特定于物质的傅里叶空间超密度场，使用一阶泽尔多维奇近似和由总物质场作为源的 2LPT 计算位移，并验证总物质功率谱等于基于物质组分比例和传递函数的理论预期加权和。\n\n使用边长为 $L$、包含 $N^3$ 个均匀分布单元的立方网格，并采用周期性边界条件。完全在无量纲系统中工作；不需要物理单位。如果傅里叶波数的定义中隐式出现任何角度量，请使用弧度。\n\n基本基础：\n- 区域是一个周期性立方体，傅里叶波数为 $k_x = \\frac{2\\pi}{L} n_x$，$k_y = \\frac{2\\pi}{L} n_y$，$k_z = \\frac{2\\pi}{L} n_z$，其中 $n_i \\in \\mathbb{Z}$ 是由快速傅里叶变换（FFT）定义的整数网格波指数。\n- 一个统计上均匀和各向同性的高斯随机场 $\\delta(\\mathbf{x})$ 在傅里叶空间中由 $\\delta(\\mathbf{k}) = \\sqrt{P(k)}\\,G(\\mathbf{k})$ 定义，其中 $P(k)$ 是各向同性功率谱，$G(\\mathbf{k})$ 是一个复高斯随机场，其均值为零，每个独立模式的方差为单位，并具有厄米对称性以确保 $\\delta(\\mathbf{x})$ 为实数。\n- 对于质量分数为 $f_1$ 和 $f_2$ 且满足 $f_1 + f_2 = 1$ 的两种物质，绝热构建使用单个高斯随机场 $G(\\mathbf{k})$ 和物质传递函数 $T_1(k)$ 和 $T_2(k)$，使得 $\\delta_1(\\mathbf{k}) = T_1(k)\\sqrt{P_0(k)}\\,G(\\mathbf{k})$ 和 $\\delta_2(\\mathbf{k}) = T_2(k)\\sqrt{P_0(k)}\\,G(\\mathbf{k})$。总物质超密度为 $\\delta_m(\\mathbf{k}) = f_1\\delta_1(\\mathbf{k}) + f_2\\delta_2(\\mathbf{k})$。\n- 一阶拉格朗日位移（泽尔多维奇）场满足 $\\boldsymbol{\\Psi}^{(1)}(\\mathbf{k}) = i\\,\\frac{\\mathbf{k}}{k^2}\\,\\delta_m(\\mathbf{k})$（对于 $\\mathbf{k} \\neq \\mathbf{0}$），零模式设置为零。\n- 通过泊松关系 $\\nabla^2 \\phi^{(1)}(\\mathbf{x}) = \\delta_m(\\mathbf{x})$ 定义一阶势 $\\phi^{(1)}$，即对于 $\\mathbf{k} \\neq \\mathbf{0}$ 时 $\\phi^{(1)}(\\mathbf{k}) = -\\delta_m(\\mathbf{k})/k^2$，在 $\\mathbf{k}=\\mathbf{0}$ 时为零。标准的 2LPT 源项在实空间中为\n$$\nS_2(\\mathbf{x}) = \\sum_{ij}\\Big(\\phi^{(1)}_{,ii}(\\mathbf{x})\\,\\phi^{(1)}_{,jj}(\\mathbf{x}) - \\left[\\phi^{(1)}_{,ij}(\\mathbf{x})\\right]^2\\Big),\n$$\n其中逗号表示空间导数。2LPT 势满足 $\\nabla^2 \\phi^{(2)}(\\mathbf{x}) = S_2(\\mathbf{x})$，因此对于 $\\mathbf{k} \\neq \\mathbf{0}$ 时 $\\phi^{(2)}(\\mathbf{k}) = -S_2(\\mathbf{k})/k^2$，二阶位移为 $\\boldsymbol{\\Psi}^{(2)}(\\mathbf{x}) = -\\nabla \\phi^{(2)}(\\mathbf{x})$。\n\n程序要求：\n1. 构建各向同性的基础功率谱\n$$\nP_0(k) = A\\,k^{n}\\,\\exp\\left[-\\left(\\frac{k}{k_c}\\right)^8\\right],\n$$\n其中常数 $A$、$n$ 和 $k_c$ 在每个测试用例中提供。设总物质传递函数 $T_m(k) \\equiv 1$。对于物质 1，使用形状\n$$\nT_1(k) = 1 + a\\,e^{-(k/k_0)^2} - \\tfrac{1}{2}a\\,e^{-(k/k_1)^2},\n$$\n其中参数 $a$、$k_0$ 和 $k_1$ 在每个测试用例中给出。通过定义\n$$\nT_2(k) = \\frac{T_m(k) - f_1 T_1(k)}{f_2},\n$$\n来强制绝热性（对于 $f_2 \\neq 0$）。在两种物质中使用相同的实现 $G(\\mathbf{k})$，使得\n对于 $s\\in\\{1,2\\}$，有 $\n\\delta_s(\\mathbf{k}) = T_s(k)\\sqrt{P_0(k)}\\,G(\\mathbf{k})\n$，以及\n$\n\\delta_m(\\mathbf{k}) = \\left[f_1 T_1(k) + f_2 T_2(k)\\right]\\sqrt{P_0(k)}\\,G(\\mathbf{k}).\n$\n通过对实空间白噪声场进行 FFT 来生成 $G(\\mathbf{k})$ 以确保厄米对称性，并在完整的三维网格上承载所有场。\n\n2. 从 $\\delta_m(\\mathbf{k})$ 计算一阶泽尔多维奇位移 $\\boldsymbol{\\Psi}^{(1)}(\\mathbf{k})$。通过在傅里叶空间中求解泊松方程来计算 $\\phi^{(1)}$，通过谱方法微分构建二阶导数 $\\phi^{(1)}_{,ij}(\\mathbf{x})$，组装 $S_2(\\mathbf{x})$，求解 $\\phi^{(2)}(\\mathbf{k})$，并计算二阶位移 $\\boldsymbol{\\Psi}^{(2)}(\\mathbf{x})$。\n\n3. 总物质场的验证：\n   - 通过将 $|\\delta_m(\\mathbf{k})|^2$ 在 $k$ 空间中分箱到宽度为 $\\Delta k = 2\\pi/L$ 的球壳中，来估计球平均总物质功率谱。排除零模式以及任何贡献模式数少于最小数量的球壳（选择一个确保数值稳定性的阈值）。\n   - 对于每个球壳，通过将\n   $$\n   \\left|G(\\mathbf{k})\\right|^2\\,\\left[f_1 T_1(k) + f_2 T_2(k)\\right]^2 P_0(k)\n   $$\n   分箱到该球壳中相同的模式上来计算预测功率。计算测量到的分箱功率与预测的分箱功率之比。报告在所有接受的球壳中最大的绝对分数偏差，波数限制在奈奎斯特波数的一个保守分数以下，以避免网格极限处的各向异性。\n   - 通过计算恒等式 $-\\nabla\\cdot\\boldsymbol{\\Psi}^{(1)}(\\mathbf{x}) = \\delta_m(\\mathbf{x})$ 的相对均方根误差，使用谱方法导数，独立地验证一阶运动学一致性。报告此相对误差。\n\n您的程序必须实现上述功能，并为每个测试用例生成一对浮点数：功率谱检查中的最大绝对分数偏差，以及一阶散度恒等式的相对均方根误差。将所有测试用例的结果聚合为单个输出行上的列表的列表。不要打印任何额外的文本。\n\n测试套件：\n为以下三个测试用例提供结果。所有符号如上定义，所有数字应解释为与所选单位一致的无量纲值：\n- 用例 A（一般情况）：$N=32$, $L=200$, $f_1=0.84$, $f_2=0.16$, $A=1$, $n=1$, $k_c=3$, $a=0.2$, $k_0=0.3$, $k_1=1.0$。\n- 用例 B（接近单物质极限）：$N=24$, $L=150$, $f_1=0.99$, $f_2=0.01$, $A=1$, $n=1$, $k_c=3$, $a=-0.3$, $k_0=0.4$, $k_1=1.2$。\n- 用例 C（等比例且具有更强尺度依赖性）：$N=28$, $L=220$, $f_1=0.5$, $f_2=0.5$, $A=1$, $n=1$, $k_c=3$, $a=0.5$, $k_0=0.25$, $k_1=0.9$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素本身是每个测试用例的两个浮点数的双元素列表。例如，格式必须完全是\n$\n[[x_1,y_1],[x_2,y_2],[x_3,y_3]]\n$\n，行中任何地方都不能有空格。", "solution": "用户的问题被评估为有效。它在科学上基于标准的宇宙学微扰理论框架，问题设定良好，对于给定的随机种子有清晰的算法路径可以得到唯一解，并且所有必要的参数和方程都已提供。该任务是计算宇宙学中一个标准但多步骤的过程。\n\n解决方案通过实现指定的算法来推进。核心步骤是：1) 在傅里叶空间中设置计算网格，2) 生成具有适当统计属性的高斯随机场，3) 构建物质密度和LPT位移场，以及 4) 执行所需的验证检查。\n\n**1. 网格和波数表示**\n模拟在一个大小为 $N \\times N \\times N$ 的立方网格上进行，该网格代表一个边长为 $L$ 的物理体积。我们在傅里叶空间中操作，这对于周期性区域是自然的。离散波矢量由 $\\mathbf{k} = (k_x, k_y, k_z)$ 给出，其中每个分量 $k_i$（对于 $i \\in \\{x, y, z\\}$）定义为 $k_i = \\frac{2\\pi}{L} n_i$。索引 $n_i$ 是整数，跨越适合快速傅里叶变换（FFT）的范围，通常是从 $-N/2$ 到 $N/2-1$。这些波矢分量可以很容易地使用 `numpy.fft.fftfreq` 和 `numpy.meshgrid` 生成，以形成三维数组 $k_x, k_y, k_z$。从这些数组中，计算每个波矢的模 $k = \\sqrt{k_x^2 + k_y^2 + k_z^2}$。必须小心处理 $\\mathbf{k}=\\mathbf{0}$ 的特殊情况（“直流模式”），以避免在后续步骤中出现除以零的错误。预先计算一个波数平方反比场 $1/k^2$，并将其在 $k=0$ 处的值显式设置为 $0$。\n\n**2. 高斯随机场的生成**\n一个统计上均匀和各向同性的高斯随机场在傅里叶空间中由其模式 $\\delta(\\mathbf{k})$ 表征。这些模式的相位是随机的，其振幅从瑞利分布中抽取，使得 $\\langle |\\delta(\\mathbf{k})|^2 \\rangle = P(k)$，其中 $P(k)$ 是功率谱。为了保证场在配置空间中是实数，傅里叶模式必须遵守厄米对称性条件 $\\delta(-\\mathbf{k}) = \\delta^*(\\mathbf{k})$。\n\n问题指定生成一个复高斯场 $G(\\mathbf{k})$，其均值为零，每个独立模式的方差为单位，并具有厄米对称性。满足这些属性的一个有效方法是首先生成一个实空间白噪声场 $w(\\mathbf{x})$，通过从标准正态分布中抽取 $N^3$ 个值。这个实数场的FFT，$G(\\mathbf{k}) = \\mathcal{F}[w(\\mathbf{x})]$，自动满足厄米属性。通过显式地将 $k=0$ 模式置零，$G(\\mathbf{k}=\\mathbf{0})=0$，来将场的均值设为零。\n\n**3. 物质场和位移场的构建**\n在建立了基础随机场 $G(\\mathbf{k})$ 之后，我们构建所有其他场。\n*   **功率谱和传递函数**：对网格上所有的 $k$ 值计算基础功率谱 $P_0(k) = A k^n \\exp[-(k/k_c)^8]$ 和物质1的传递函数 $T_1(k) = 1 + a e^{-(k/k_0)^2} - \\frac{1}{2}a e^{-(k/k_1)^2}$。\n*   **总物质超密度**：问题指定了一个绝热设置，其中总物质传递函数 $T_m(k) \\equiv 1$。物质2的传递函数定义为 $T_2(k) = (T_m(k) - f_1 T_1(k))/f_2$。这强制使得质量加权的总传递函数 $f_1 T_1(k) + f_2 T_2(k)$ 恒等于 $T_m(k) = 1$。因此，傅里叶空间中的总物质超密度场简化为 $\\delta_m(\\mathbf{k}) = [f_1 T_1(k) + f_2 T_2(k)] \\sqrt{P_0(k)} G(\\mathbf{k}) = \\sqrt{P_0(k)} G(\\mathbf{k})$。\n\n*   **一阶（泽尔多维奇）位移**：位移场 $\\boldsymbol{\\Psi}^{(1)}$ 与超密度通过 $\\nabla \\cdot \\boldsymbol{\\Psi}^{(1)}(\\mathbf{x}) = -\\delta_m(\\mathbf{x})$ 相关。在傅里叶空间中，这变为 $i\\mathbf{k} \\cdot \\boldsymbol{\\Psi}^{(1)}(\\mathbf{k}) = -\\delta_m(\\mathbf{k})$。这种初始位移的无旋性质允许我们将其写成一个势的梯度，$\\boldsymbol{\\Psi}^{(1)} = -\\nabla \\phi^{(1)}$，从而得到表达式 $\\boldsymbol{\\Psi}^{(1)}(\\mathbf{k}) = i \\frac{\\mathbf{k}}{k^2} \\delta_m(\\mathbf{k})$。这个矢量场在傅里叶空间中按分量计算。\n\n*   **二阶（2LPT）位移**：2LPT 计算涉及几个步骤：\n    1.  通过求解泊松方程 $\\nabla^2 \\phi^{(1)} = \\delta_m$ 来找到一阶势 $\\phi^{(1)}$。在傅里叶空间中，这是一个简单的代数关系：$\\phi^{(1)}(\\mathbf{k}) = -\\delta_m(\\mathbf{k})/k^2$。\n    2.  二阶源项 $S_2(\\mathbf{x}) = \\sum_{ij}(\\phi^{(1)}_{,ii}\\phi^{(1)}_{,jj} - [\\phi^{(1)}_{,ij}]^2)$ 在实空间中构建。这需要计算 $\\phi^{(1)}(\\mathbf{x})$ 的所有二阶空间导数。这些导数在傅里叶空间中可以高效计算，其中微分对应于乘以波矢量：$\\phi^{(1)}_{,ij}(\\mathbf{x}) = \\mathcal{F}^{-1}[-k_i k_j \\phi^{(1)}(\\mathbf{k})]$。\n    3.  计算了六个唯一的二阶导数（$\\phi^{(1)}_{,xx}$、$\\phi^{(1)}_{,yy}$、$\\phi^{(1)}_{,zz}$、$\\phi^{(1)}_{,xy}$、$\\phi^{(1)}_{,xz}$、$\\phi^{(1)}_{,yz}$）之后，在每个网格点上按照 $S_2(\\mathbf{x})$ 的公式将它们相乘。\n    4.  通过求解另一个泊松方程 $\\nabla^2 \\phi^{(2)} = S_2$ 来找到二阶势 $\\phi^{(2)}$。同样，这在傅里叶空间中完成：$\\phi^{(2)}(\\mathbf{k}) = -S_2(\\mathbf{k})/k^2$，其中 $S_2(\\mathbf{k}) = \\mathcal{F}[S_2(\\mathbf{x})]$。\n    5.  最后，二阶位移是该势的负梯度，$\\boldsymbol{\\Psi}^{(2)}(\\mathbf{x}) = -\\nabla \\phi^{(2)}(\\mathbf{x})$，在傅里叶空间中即为 $\\boldsymbol{\\Psi}^{(2)}(\\mathbf{k}) = -i\\mathbf{k}\\,\\phi^{(2)}(\\mathbf{k})$。\n\n**4. 验证程序**\n执行两个数值检查以验证实现的正确性。\n*   **功率谱验证**：此检查将数值上实现的功率谱与理论期望进行比较。“测量”到的每个模式的功率是 $|\\delta_m(\\mathbf{k})|^2$。“预测”的功率是 $|G(\\mathbf{k})|^2 |f_1 T_1(k) + f_2 T_2(k)|^2 P_0(k)$。这两个量对于每个模式在解析上是相同的。该检查将这两个量分箱到 $k$ 空间中宽度为 $\\Delta k = 2\\pi/L$ 的球壳中。计算每个箱中总测量功率与总预测功率的比值。测试指标是最大绝对分数偏差 $\\max(|P_{\\text{meas}}/P_{\\text{pred}} - 1|)$，该偏差在所有包含足够多模式（例如，超过10个）且位于奈奎斯特频率一半以下的箱中计算，以避免网格尺度上的各向异性。这个值应该在机器浮点精度的量级。\n\n*   **运动学一致性**：此检查验证一阶位移和物质超密度之间的基本关系 $-\\nabla \\cdot \\boldsymbol{\\Psi}^{(1)}(\\mathbf{x}) = \\delta_m(\\mathbf{x})$。这个恒等式在傅里叶空间中最容易测试，它变为 $-i\\mathbf{k} \\cdot \\boldsymbol{\\Psi}^{(1)}(\\mathbf{k}) = \\delta_m(\\mathbf{k})$（对于 $\\mathbf{k} \\neq \\mathbf{0}$）。左侧是从生成的 $\\boldsymbol{\\Psi}^{(1)}(\\mathbf{k})$ 计算的，右侧是生成的 $\\delta_m(\\mathbf{k})$。计算相对均方根误差 $\\sqrt{\\sum|\\text{LHS} - \\text{RHS}|^2 / \\sum|\\text{RHS}|^2}$，其中求和遍及所有傅里叶模式。这个值也应接近机器精度，从而证实傅里叶空间算符的正确实现。\n\n该实现将这些步骤封装在一个函数中，为每个测试用例调用该函数，产生两个指定的验证指标。", "answer": "```python\nimport numpy as np\n\ndef compute_initial_conditions(N, L, f1, f2, A, n_spec, k_c, a, k0, k1):\n    \"\"\"\n    Generates cosmological initial conditions and performs verification checks.\n    \"\"\"\n    # 1. Setup Grid\n    k_vec = np.fft.fftfreq(N, d=L / N) * 2 * np.pi\n    kx, ky, kz = np.meshgrid(k_vec, k_vec, k_vec, indexing='ij')\n    k_mag = np.sqrt(kx**2 + ky**2 + kz**2)\n    \n    k_is_zero = (k_mag == 0)\n    k_mag_safe = np.where(k_is_zero, 1.0, k_mag)\n    k_sq_inv = 1.0 / k_mag_safe**2\n    k_sq_inv[k_is_zero] = 0.0\n\n    # 2. Generate Initial Random Field\n    white_noise = np.random.randn(N, N, N)\n    G_k = np.fft.fftn(white_noise)\n    G_k[0, 0, 0] = 0.0  # Enforce zero mean for the field\n\n    # Power spectrum and transfer functions\n    P0_k = A * k_mag_safe**n_spec * np.exp(-(k_mag_safe / k_c)**8)\n    P0_k[k_is_zero] = 0.0\n\n    T1_k = 1.0 + a * np.exp(-(k_mag / k0)**2) - 0.5 * a * np.exp(-(k_mag / k1)**2)\n    \n    # Total matter overdensity field (since f1*T1 + f2*T2 = 1)\n    delta_m_k = np.sqrt(P0_k) * G_k\n\n    # 3. Compute LPT Displacements\n    # First-order (Zel'dovich)\n    Psi1_kx = 1j * kx * k_sq_inv * delta_m_k\n    Psi1_ky = 1j * ky * k_sq_inv * delta_m_k\n    Psi1_kz = 1j * kz * k_sq_inv * delta_m_k\n    \n    # Second-order (2LPT)\n    phi1_k = -delta_m_k * k_sq_inv\n    \n    d2phi1_dx2_k = -kx**2 * phi1_k\n    d2phi1_dy2_k = -ky**2 * phi1_k\n    d2phi1_dz2_k = -kz**2 * phi1_k\n    d2phi1_dxdy_k = -kx * ky * phi1_k\n    d2phi1_dxdz_k = -kx * kz * phi1_k\n    d2phi1_dydz_k = -ky * kz * phi1_k\n\n    d2phi1_xx = np.fft.ifftn(d2phi1_dx2_k).real\n    d2phi1_yy = np.fft.ifftn(d2phi1_dy2_k).real\n    d2phi1_zz = np.fft.ifftn(d2phi1_dz2_k).real\n    d2phi1_xy = np.fft.ifftn(d2phi1_dxdy_k).real\n    d2phi1_xz = np.fft.ifftn(d2phi1_dxdz_k).real\n    d2phi1_yz = np.fft.ifftn(d2phi1_dydz_k).real\n    \n    S2_x = (d2phi1_xx * d2phi1_yy - d2phi1_xy**2) + \\\n           (d2phi1_xx * d2phi1_zz - d2phi1_xz**2) + \\\n           (d2phi1_yy * d2phi1_zz - d2phi1_yz**2)\n    \n    S2_k = np.fft.fftn(S2_x)\n    phi2_k = -S2_k * k_sq_inv\n\n    _ = -1j * kx * phi2_k  # Psi2_kx, not needed for verification but computed as required\n    _ = -1j * ky * phi2_k  # Psi2_ky\n    _ = -1j * kz * phi2_k  # Psi2_kz\n\n    # 4. Verification\n    \n    # 4a. Power Spectrum Check\n    P_meas_k = np.abs(delta_m_k)**2\n    \n    T2_k = (1.0 - f1 * T1_k) / f2 if f2 != 0 else np.zeros_like(T1_k)\n    total_T_k_explicit = f1 * T1_k + f2 * T2_k\n    P_pred_k = np.abs(G_k)**2 * np.abs(total_T_k_explicit)**2 * P0_k\n\n    k_fundamental = 2 * np.pi / L\n    k_nyquist = np.pi * N / L\n    k_max_verify = k_nyquist / 2.0\n    \n    k_flat = k_mag.flatten()\n    valid_modes = ~k_is_zero.flatten()\n    k_flat_valid = k_flat[valid_modes]\n    \n    max_k_val = np.max(k_flat_valid) if k_flat_valid.size > 0 else 0\n    num_bins = int(np.ceil(max_k_val / k_fundamental)) + 1\n\n    bin_indices = np.floor(k_flat_valid / k_fundamental).astype(int)\n    \n    binned_P_meas = np.bincount(bin_indices, weights=P_meas_k.flatten()[valid_modes], minlength=num_bins)\n    binned_P_pred = np.bincount(bin_indices, weights=P_pred_k.flatten()[valid_modes], minlength=num_bins)\n    counts = np.bincount(bin_indices, minlength=num_bins)\n\n    ratios = []\n    min_modes_per_bin = 10\n    \n    for i in range(num_bins):\n        k_bin_center = (i + 0.5) * k_fundamental\n        if counts[i] >= min_modes_per_bin and binned_P_pred[i] > 1e-30 and k_bin_center  k_max_verify:\n             ratio = binned_P_meas[i] / binned_P_pred[i]\n             ratios.append(ratio)\n    \n    max_frac_dev = np.max(np.abs(np.array(ratios) - 1.0)) if ratios else 0.0\n\n    # 4b. Kinematic Consistency Check\n    LHS_k = -(1j * kx * Psi1_kx + 1j * ky * Psi1_ky + 1j * kz * Psi1_kz)\n    RHS_k = delta_m_k\n    err_k = LHS_k - RHS_k\n    \n    norm_err_sq = np.sum(np.abs(err_k)**2)\n    norm_rhs_sq = np.sum(np.abs(RHS_k)**2)\n    \n    rel_rms_err = np.sqrt(norm_err_sq / norm_rhs_sq) if norm_rhs_sq > 0 else 0.0\n\n    return [max_frac_dev, rel_rms_err]\n\ndef solve():\n    # Set a consistent seed for reproducibility of random numbers.\n    np.random.seed(42)\n\n    test_cases = [\n        # Case A\n        {'N': 32, 'L': 200, 'f1': 0.84, 'f2': 0.16, 'A': 1, 'n_spec': 1, 'k_c': 3, 'a': 0.2, 'k0': 0.3, 'k1': 1.0},\n        # Case B\n        {'N': 24, 'L': 150, 'f1': 0.99, 'f2': 0.01, 'A': 1, 'n_spec': 1, 'k_c': 3, 'a': -0.3, 'k0': 0.4, 'k1': 1.2},\n        # Case C\n        {'N': 28, 'L': 220, 'f1': 0.5, 'f2': 0.5, 'A': 1, 'n_spec': 1, 'k_c': 3, 'a': 0.5, 'k0': 0.25, 'k1': 0.9},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = compute_initial_conditions(**params)\n        results.append(result)\n\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3512400"}]}