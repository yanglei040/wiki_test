{"hands_on_practices": [{"introduction": "我们首先来研究宇宙膨胀对粒子运动最基本的影响：“哈勃拖拽”（Hubble Drag）。在没有其他特殊力的作用下，粒子的特殊动量（peculiar momentum）并不会守恒，而是随着宇宙的膨胀而衰减。这项练习 [@problem_id:3506150] 将引导你推导这一行为，并比较几种标准数值方法在积分此衰减过程中的表现，为构建任何宇宙学积分器提供一个重要的基准测试。", "problem": "实现一个完整、可运行的程序，用于在共形时间中演化的粒子在共动坐标系下的自由漂流奇异动量积分。从以下基本点开始：在一个膨胀的、空间平坦的 Friedmann–Robertson–Walker 背景中，自由漂流奇异动量满足一阶常微分方程 (ODE) $u'(\\tau) + \\mathcal{H}(\\tau)\\,u(\\tau) = 0$，其中 $\\tau$ 是共形时间，$u(\\tau)$ 是共动奇异动量，$\\mathcal{H}(\\tau) = a'(\\tau)/a(\\tau)$ 是共形哈勃参数，$a(\\tau)$ 是标度因子。您必须推导此 ODE 解析解所蕴含的精确离散时间积分器，并将其与直接对 ODE $u'(\\tau) + \\mathcal{H}(\\tau)\\,u(\\tau) = 0$ 进行时间步进的显式数值格式进行基准测试比较。\n\n您的程序必须：\n- 全程使用无量纲量；不要求也不允许使用物理单位。\n- 将以下宇宙学背景实现为共形时间 $\\tau$ 的函数：\n  - 辐射主导：$a(\\tau) = \\tau$，得到 $\\mathcal{H}(\\tau) = 1/\\tau$（对于 $\\tau > 0$）。\n  - 物质主导：$a(\\tau) = \\tau^2$，得到 $\\mathcal{H}(\\tau) = 2/\\tau$（对于 $\\tau > 0$）。\n  - 宇宙学常数主导（共形时间中的 de Sitter 时空）：$a(\\tau) = -1/\\tau$，得到 $\\mathcal{H}(\\tau) = -1/\\tau$（对于 $\\tau  0$）。\n- 实现四种积分格式，使用 $N$ 个大小为 $\\Delta \\tau = (\\tau_1 - \\tau_0)/N$ 的均匀步长，将 $u(\\tau)$ 从初始时间 $\\tau_0$ 推进到最终时间 $\\tau_1$：\n  - 由 ODE 解析解所蕴含的精确离散积分器，在每个区间上逐步应用。\n  - 应用于 ODE $u'(\\tau) + \\mathcal{H}(\\tau)\\,u(\\tau) = 0$ 的前向（显式）Euler 方法。\n  - 应用于相同 ODE 的隐式 Euler 方法。\n  - 应用于相同 ODE 的经典四阶 Runge–Kutta (RK4) 方法。\n- 为进行基准测试，计算每种格式在 $\\tau_1$ 时相对于 ODE 精确解析解的相对误差，定义为 $\\varepsilon = \\lvert u_{\\text{num}}(\\tau_1) - u_{\\text{exact}}(\\tau_1) \\rvert / \\max(\\lvert u_{\\text{exact}}(\\tau_1) \\rvert, 10^{-15})$。\n\n设计一个测试套件，用于测试不同的区间和边界情况：\n- 测试用例 $1$ (正常路径，辐射主导)：$\\tau_0 = 1$, $\\tau_1 = 4$, $u_0 = 1.23$, $N = 20$，其中 $a(\\tau) = \\tau$。\n- 测试用例 $2$ (正常路径，物质主导)：$\\tau_0 = 1$, $\\tau_1 = 2$, $u_0 = -2.5$, $N = 50$，其中 $a(\\tau) = \\tau^2$。\n- 测试用例 $3$ (边界情况：零动量，de Sitter)：$\\tau_0 = -1$, $\\tau_1 = -0.5$, $u_0 = 0$, $N = 30$，其中 $a(\\tau) = -1/\\tau$。\n- 测试用例 $4$ (边缘情况：极端粗略步长，辐射主导)：$\\tau_0 = 1$, $\\tau_1 = 4$, $u_0 = 3$, $N = 1$，其中 $a(\\tau) = \\tau$。\n\n对于每个测试用例，您的程序必须输出一个包含四个浮点数的列表，顺序固定为：$[\\varepsilon_{\\text{exact-step}}, \\varepsilon_{\\text{forward-Euler}}, \\varepsilon_{\\text{implicit-Euler}}, \\varepsilon_{\\text{RK4}}]$。将所有测试用例的结果汇总到单行中，该行包含一个由这些四元素列表构成的外部列表。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[[e_{1,1}, e_{1,2}, e_{1,3}, e_{1,4}], [e_{2,1}, e_{2,2}, e_{2,3}, e_{2,4}], [e_{3,1}, e_{3,2}, e_{3,3}, e_{3,4}], [e_{4,1}, e_{4,2}, e_{4,3}, e_{4,4}]]$。\n\n不允许用户输入；所有参数必须完全按照上述规定硬编码在程序中。最终打印的输出必须是指定格式的单行。通过将 $\\tau$ 值保持在 $a(\\tau)$ 和 $\\mathcal{H}(\\tau)$ 为有限且良定的定义域内来确保科学真实性（在 de Sitter 情况下不要跨越 $\\tau = 0$）。程序必须结构清晰、文档明确，以便开发人员能够验证其正确性并复现该基准测试。", "solution": "该问题要求实现并基准测试几种数值积分格式，用于描述膨胀宇宙中粒子共动奇异动量 $u$ 的演化。该演化由一个关于共形时间 $\\tau$ 的一阶常微分方程 (ODE) 描述。\n\n所给出的基本控制方程是：\n$$\n\\frac{du}{d\\tau} + \\mathcal{H}(\\tau)u(\\tau) = 0\n$$\n其中 $u'(\\tau) = du/d\\tau$，$\\mathcal{H}(\\tau) = a'(\\tau)/a(\\tau)$ 是共形哈勃参数，而 $a(\\tau)$ 是宇宙学标度因子。这个方程描述了奇异动量上的“哈勃阻尼”，随着宇宙膨胀，该动量会减小。\n\n首先，我们解析地求解这个 ODE，为基准测试建立基准真相 (ground truth)。该方程是一阶线性齐次常微分方程，可以通过分离变量法求解：\n$$\n\\frac{du}{u} = -\\mathcal{H}(\\tau)d\\tau\n$$\n从初始时间 $\\tau_0$ 积分到稍后的时间 $\\tau$ 可得：\n$$\n\\int_{u(\\tau_0)}^{u(\\tau)} \\frac{d\\tilde{u}}{\\tilde{u}} = -\\int_{\\tau_0}^{\\tau} \\mathcal{H}(\\tilde{\\tau})d\\tilde{\\tau}\n$$\n$$\n\\ln\\left(\\frac{u(\\tau)}{u(\\tau_0)}\\right) = -\\int_{\\tau_0}^{\\tau} \\frac{a'(\\tilde{\\tau})}{a(\\tilde{\\tau})}d\\tilde{\\tau} = -\\left[\\ln(a(\\tilde{\\tau}))\\right]_{\\tau_0}^{\\tau} = -(\\ln(a(\\tau)) - \\ln(a(\\tau_0))) = \\ln\\left(\\frac{a(\\tau_0)}{a(\\tau)}\\right)\n$$\n对两边取指数，即可得到精确的解析解：\n$$\nu(\\tau) = u(\\tau_0) \\frac{a(\\tau_0)}{a(\\tau)}\n$$\n这个结果表明，共动奇异动量会发生红移，其大小与标度因子成反比减小，即 $u \\propto 1/a$。\n\n程序将实现并比较四种积分格式，用大小为 $\\Delta\\tau = (\\tau_1 - \\tau_0)/N$ 的 $N$ 个均匀步长，求解从初始时间 $\\tau_0$ 到最终时间 $\\tau_1$ 的 ODE。设 $u_i = u(\\tau_i)$，其中 $\\tau_i = \\tau_0 + i\\Delta\\tau$。\n\n$1$. **精确步进积分器**：该格式在每个离散时间步 $\\tau_i$ 到 $\\tau_{i+1}$ 上应用精确解析解。更新法则直接从解析解推导而来：\n$$\nu_{i+1} = u_i \\frac{a(\\tau_i)}{a(\\tau_{i+1})}\n$$\n根据其构造，该方法将在 $\\tau_1$ 处得到精确结果（在浮点精度范围内），因此其相对误差应接近于零。\n\n$2$. **前向（显式）Euler 方法**：这是最简单的数值格式。它在区间开始处 $\\tau_i$ 近似导数。ODE 可写作 $u' = -\\mathcal{H}(\\tau)u(\\tau)$。更新法则是：\n$$\nu_{i+1} = u_i + \\Delta\\tau \\cdot u'(\\tau_i) = u_i - \\Delta\\tau \\mathcal{H}(\\tau_i) u_i = u_i (1 - \\Delta\\tau \\mathcal{H}(\\tau_i))\n$$\n\n$3$. **隐式 Euler 方法**：该格式在区间结束处 $\\tau_{i+1}$ 计算导数，这使其对于刚性问题更稳定。更新法则是：\n$$\nu_{i+1} = u_i + \\Delta\\tau \\cdot u'(\\tau_{i+1}) = u_i - \\Delta\\tau \\mathcal{H}(\\tau_{i+1}) u_{i+1}\n$$\n求解 $u_{i+1}$ 可得显式更新法则：\n$$\nu_{i+1}(1 + \\Delta\\tau \\mathcal{H}(\\tau_{i+1})) = u_i \\implies u_{i+1} = \\frac{u_i}{1 + \\Delta\\tau \\mathcal{H}(\\tau_{i+1})}\n$$\n\n$4$. **经典四阶 Runge-Kutta (RK4) 方法**：这是一种高阶方法，通过在步长内多个点上计算导数来提供更高的精度。对于 ODE $u' = f(\\tau, u)$，更新法则是：\n$$\nu_{i+1} = u_i + \\frac{\\Delta\\tau}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\n其中，对于我们的特定问题 $f(\\tau, u) = -\\mathcal{H}(\\tau)u(\\tau)$：\n- $k_1 = f(\\tau_i, u_i) = -\\mathcal{H}(\\tau_i)u_i$\n- $k_2 = f(\\tau_i + \\frac{\\Delta\\tau}{2}, u_i + \\frac{\\Delta\\tau}{2}k_1) = -\\mathcal{H}(\\tau_i + \\frac{\\Delta\\tau}{2})(u_i + \\frac{\\Delta\\tau}{2}k_1)$\n- $k_3 = f(\\tau_i + \\frac{\\Delta\\tau}{2}, u_i + \\frac{\\Delta\\tau}{2}k_2) = -\\mathcal{H}(\\tau_i + \\frac{\\Delta\\tau}{2})(u_i + \\frac{\\Delta\\tau}{2}k_2)$\n- $k_4 = f(\\tau_i + \\Delta\\tau, u_i + \\Delta\\tau k_3) = -\\mathcal{H}(\\tau_i + \\Delta\\tau)(u_i + \\Delta\\tau k_3)$\n\n指定的宇宙学模型是：\n- 辐射主导：$a(\\tau) = \\tau$, $\\mathcal{H}(\\tau) = 1/\\tau$，对于 $\\tau > 0$。\n- 物质主导：$a(\\tau) = \\tau^2$, $\\mathcal{H}(\\tau) = 2/\\tau$，对于 $\\tau > 0$。\n- de Sitter：$a(\\tau) = -1/\\tau$, $\\mathcal{H}(\\tau) = -1/\\tau$，对于 $\\tau  0$。\n对于所有这些模型，ODE 的形式均为 $u' = -c \\cdot u/\\tau$，其中 $c$ 为某个常数。这是一个已知的性质：对于这种形式的 ODE，RK4 方法能提供精确解。因此，我们预期所有测试用例中 RK4 的误差都将接近于零。\n\n基准测试过程如下：\n- 对于每个测试用例，定义参数 $(\\tau_0, \\tau_1, u_0, N)$ 和宇宙学模型。\n- 计算精确的最终动量 $u_{\\text{exact}}(\\tau_1) = u_0 a(\\tau_0)/a(\\tau_1)$。\n- 对于四种数值格式中的每一种，通过从 $\\tau_0$ 开始迭代 $N$ 次来计算最终动量 $u_{\\text{num}}(\\tau_1)$。\n- 使用提供的公式计算每种格式的相对误差 $\\varepsilon$：\n$$\n\\varepsilon = \\frac{\\lvert u_{\\text{num}}(\\tau_1) - u_{\\text{exact}}(\\tau_1) \\rvert}{\\max(\\lvert u_{\\text{exact}}(\\tau_1) \\rvert, 10^{-15})}\n$$\n程序整理每个测试用例的这些误差，并以指定的列表嵌套列表的格式呈现它们。", "answer": "```python\n#\n# Meticulous and Exacting STEM Professor\n# Solution for Comoving Momentum Integration\n#\n\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main entry point for the program. Defines test cases, runs benchmarks,\n    and prints the final results in the specified format.\n    \"\"\"\n\n    # Dictionary mapping cosmology names to their scale factor and Hubble parameter functions.\n    cosmology_models = {\n        'radiation': {\n            'a': lambda tau: tau,\n            'H': lambda tau: 1.0 / tau\n        },\n        'matter': {\n            'a': lambda tau: tau**2,\n            'H': lambda tau: 2.0 / tau\n        },\n        'de_sitter': {\n            'a': lambda tau: -1.0 / tau,\n            'H': lambda tau: -1.0 / tau\n        }\n    }\n\n    # Define the test suite as specified in the problem statement.\n    test_cases = [\n        {'cosmology': 'radiation', 'tau0': 1.0, 'tau1': 4.0, 'u0': 1.23, 'N': 20},\n        {'cosmology': 'matter',    'tau0': 1.0, 'tau1': 2.0, 'u0': -2.5, 'N': 50},\n        {'cosmology': 'de_sitter', 'tau0': -1.0, 'tau1': -0.5, 'u0': 0.0, 'N': 30},\n        {'cosmology': 'radiation', 'tau0': 1.0, 'tau1': 4.0, 'u0': 3.0, 'N': 1},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        errors = run_benchmark(case, cosmology_models)\n        all_results.append(errors)\n\n    # Format the final output string as a list of lists.\n    # The default string representation of floats is used as no specific format was required.\n    inner_lists_str = []\n    for res_list in all_results:\n        inner_lists_str.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    final_output = f\"[{','.join(inner_lists_str)}]\"\n    print(final_output)\n\n\ndef run_benchmark(case, cosmology_models):\n    \"\"\"\n    Runs all integration schemes for a single test case and returns their relative errors.\n\n    Args:\n        case (dict): A dictionary containing parameters for the test case\n                     (cosmology, tau0, tau1, u0, N).\n        cosmology_models (dict): A dictionary of cosmological model functions.\n\n    Returns:\n        list: A list of four floats representing the relative errors for each scheme.\n    \"\"\"\n    cosmology = case['cosmology']\n    tau0, tau1, u0, N = case['tau0'], case['tau1'], case['u0'], case['N']\n\n    a_func = cosmology_models[cosmology]['a']\n    H_func = cosmology_models[cosmology]['H']\n\n    # Generate time steps. np.linspace correctly handles N=1 (2 points).\n    tau_steps = np.linspace(tau0, tau1, N + 1)\n    delta_tau = (tau1 - tau0) / N\n\n    # Calculate the exact analytical solution at the final time for reference.\n    u_exact_final = u0 * a_func(tau0) / a_func(tau1)\n\n    # Run each of the four integration schemes.\n    u_exact_step_final = integrate_exact_step(u0, tau_steps, a_func)\n    u_forward_euler_final = integrate_forward_euler(u0, tau_steps, delta_tau, H_func)\n    u_implicit_euler_final = integrate_implicit_euler(u0, tau_steps, delta_tau, H_func)\n    u_rk4_final = integrate_rk4(u0, tau_steps, delta_tau, H_func)\n\n    # Collect the numerical results.\n    numerical_solutions = [\n        u_exact_step_final,\n        u_forward_euler_final,\n        u_implicit_euler_final,\n        u_rk4_final\n    ]\n    \n    # Calculate the relative error for each scheme.\n    errors = [calculate_relative_error(u_num, u_exact_final) for u_num in numerical_solutions]\n    \n    return errors\n\n\ndef calculate_relative_error(u_num, u_exact):\n    \"\"\"\n    Calculates the relative error according to the specified formula.\n    \"\"\"\n    numerator = np.abs(u_num - u_exact)\n    denominator = np.maximum(np.abs(u_exact), 1e-15)\n    return numerator / denominator\n\n\ndef integrate_exact_step(u0, tau_steps, a_func):\n    \"\"\"Integrator based on the exact solution applied stepwise.\"\"\"\n    u = u0\n    for i in range(len(tau_steps) - 1):\n        u = u * a_func(tau_steps[i]) / a_func(tau_steps[i+1])\n    return u\n\n\ndef integrate_forward_euler(u0, tau_steps, delta_tau, H_func):\n    \"\"\"Forward (explicit) Euler integrator.\"\"\"\n    u = u0\n    for i in range(len(tau_steps) - 1):\n        tau_i = tau_steps[i]\n        u = u * (1.0 - delta_tau * H_func(tau_i))\n    return u\n\n\ndef integrate_implicit_euler(u0, tau_steps, delta_tau, H_func):\n    \"\"\"Implicit Euler integrator.\"\"\"\n    u = u0\n    for i in range(len(tau_steps) - 1):\n        tau_i_plus_1 = tau_steps[i+1]\n        u = u / (1.0 + delta_tau * H_func(tau_i_plus_1))\n    return u\n\n\ndef integrate_rk4(u0, tau_steps, delta_tau, H_func):\n    \"\"\"Classical fourth-order Runge-Kutta (RK4) integrator.\"\"\"\n    # Define the function f(tau, u) = u' for the ODE u' = -H(tau) * u\n    f = lambda tau, u: -H_func(tau) * u\n    u = u0\n    for i in range(len(tau_steps) - 1):\n        tau_i = tau_steps[i]\n        \n        k1 = f(tau_i, u)\n        k2 = f(tau_i + 0.5 * delta_tau, u + 0.5 * delta_tau * k1)\n        k3 = f(tau_i + 0.5 * delta_tau, u + 0.5 * delta_tau * k2)\n        k4 = f(tau_i + delta_tau, u + delta_tau * k3)\n        \n        u = u + (delta_tau / 6.0) * (k1 + 2.0*k2 + 2.0*k3 + k4)\n    return u\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3506150"}, {"introduction": "任何宇宙学模拟代码都必须通过一项关键测试：它能否正确地演化那些初始在共动坐标系中静止的粒子。理论上，这些粒子应仅被哈勃流（Hubble flow）裹挟运动，其共动坐标保持不变。然而，数值误差会引入虚假的“漂移”（drift）。这项练习 [@problem_id:3506173] 要求你实现几种常见的积分器，并量化这种数值漂移，从而强调为长期宇宙学模拟选择合适且精确的积分方案的重要性。", "problem": "考虑一个在牛顿极限下建模的空间均匀、无压、物质主导的宇宙，其标度因子为 $a(t)$，哈勃参数为 $H(t)$。在一个平坦的 Einstein–de Sitter 宇宙中，Friedmann 方程意味着 $H^2(t) = \\frac{8 \\pi G}{3} \\rho_b(t)$ 且 $a(t) \\propto t^{2/3}$，其中 $t$ 是宇宙时，$G$ 是引力常数，$\\rho_b(t)$ 是均匀背景密度。在此背景下，一个自由测试粒子的物理位置 $r(t)$ 满足二阶常微分方程 (ODE) $ \\frac{d^2 r}{dt^2} = - \\frac{4 \\pi G}{3} \\rho_b(t) \\, r(t)$，这是均匀密度分布内的引力场。\n\n定义共动坐标 $x(t) = r(t)/a(t)$。对于一个初始与哈勃流共动的粒子（即 $r(t_0) = a(t_0) x_0$ 且 $\\frac{dr}{dt}(t_0) = H(t_0) r(t_0)$，其中 $x_0$ 为常数），我们期望对于所有的 $t$ 都精确地有 $x(t) = x_0$，因为该粒子在共动坐标系中保持静止。\n\n你的任务是编写一个完整、可运行的程序，该程序：\n- 使用无量纲代码单位，在指定的均匀背景中实现动力学系统，所选单位应使关系精确且数值上良态。\n- 针对多种积分器选项和时间步长，对粒子的运动进行数值积分。\n- 验证一个在共动坐标系中初始静止的粒子保持静止，并量化伪漂移 $|x(t) - x_0|$ 作为积分器选项和时间步长的函数。\n\n使用以下无量纲归一化：\n- 设置 $G = 1$ 并选择 $t_0 = 1$，从而精确得到 $a(t) = t^{2/3}$ 和 $H(t) = \\frac{2}{3 t}$。\n- 选择 $\\rho_0 = \\rho_b(t_0)$ 使得 $H_0^2 = \\frac{8 \\pi G}{3} \\rho_0$，其中 $H_0 = \\frac{2}{3}$，这意味着 $\\rho_0 = \\frac{1}{6 \\pi}$。\n- 通过此选择，常微分方程简化为 $\\frac{d^2 r}{dt^2} = - \\frac{2}{9} \\frac{r}{t^2}$。\n- 在 $t = t_0 = 1$ 进行初始化，设 $x_0 = 1$，$r(t_0) = a(t_0) x_0 = 1$，且 $\\frac{dr}{dt}(t_0) = \\frac{2}{3}$。\n\n你必须实现并比较以下应用于 $(r, v)$ 一阶系统的时间积分方案，其中 $v = \\frac{dr}{dt}$：\n- 显式欧拉法：使用在当前步计算的加速度 $a_r(t, r) = - \\frac{2}{9} \\frac{r}{t^2}$ 来更新 $v$ 和 $r$。\n- 速度 Verlet (Kick–Drift–Kick) 方法：一种时间中心格式，它执行 $v$ 的半步更新、$r$ 的全步更新，然后是 $v$ 的另一次半步更新，其中显式的时间依赖性在每一步的开始和结束时处理。\n- 经典四阶龙格-库塔 (RK4) 方法：对系统 $\\frac{dr}{dt} = v$，$\\frac{dv}{dt} = - \\frac{2}{9} \\frac{r}{t^2}$ 使用标准的四阶段过程计算更新，注意将适当的时间传递给每个阶段。\n\n对于每种积分器和时间步长，从 $t = t_0 = 1$ 积分到 $t_f = 10$。在每一步，计算共动坐标 $x(t) = \\frac{r(t)}{a(t)} = \\frac{r(t)}{t^{2/3}}$ 并跟踪整个积分区间内的最大绝对漂移 $\\max_t |x(t) - x_0|$。所有报告的漂移必须表示为无量纲浮点数。\n\n测试套件：\n- 情况 $1$：显式欧拉法，$\\Delta t = 0.5$。\n- 情况 $2$：显式欧拉法，$\\Delta t = 0.05$。\n- 情况 $3$：速度 Verlet 法，$\\Delta t = 0.1$。\n- 情况 $4$：经典龙格-库塔 $4$ 阶法，$\\Delta t = 0.5$。\n- 情况 $5$：经典龙格-库塔 $4$ 阶法，$\\Delta t = 0.01$。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[result_1,result_2,result_3,result_4,result_5]$），其中每个 $result_i$ 是相应测试用例的最大绝对漂移 $\\max_t |x(t) - x_0|$，以无量纲共动坐标单位的浮点数形式报告。", "solution": "用户提供的问题已经过评估并被确定为 **valid**。该问题在科学上基于标准宇宙学模型，在数学上作为一个常微分方程的初值问题是适定的，并且以客观、明确的语言和数据呈现。\n\n该问题要求在一个物质主导的膨胀宇宙的简化模型（一个 Einstein-de Sitter 模型）内，对一个测试粒子的运动方程进行数值积分。其目标是量化由不同积分方案引入的数值误差或“漂移”，对于一个解析上应保持在恒定共动位置的粒子而言。\n\n控制物理模型以无量纲形式指定。粒子的物理位置 $r(t)$ 根据二阶常微分方程 (ODE) 演化：\n$$\n\\frac{d^2 r}{dt^2} = - \\frac{2}{9} \\frac{r}{t^2}\n$$\n该方程描述了在此模型中，一个粒子在均匀、膨胀的介质内所经历的引力加速度。积分将在时间区间 $t \\in [1, 10]$ 上执行。\n\n初始条件设置在 $t_0 = 1$。粒子初始位于共动位置 $x_0 = 1$。因此，物理位置为 $r(t_0) = a(t_0) x_0$，其中标度因子 $a(t) = t^{2/3}$。这得出 $r(1) = 1^{2/3} \\cdot 1 = 1$。粒子初始也与哈勃流共动，意味着其初始物理速度与其所在位置的膨胀速度相匹配：$\\frac{dr}{dt}(t_0) = H(t_0) r(t_0)$。由于哈勃参数为 $H(t) = \\frac{2}{3t}$，初始速度为 $\\frac{dr}{dt}(1) = H(1) r(1) = (\\frac{2}{3 \\cdot 1}) \\cdot 1 = \\frac{2}{3}$。\n\n为了数值求解此问题，我们首先将二阶 ODE 转换为一个由两个耦合的一阶 ODE 组成的系统。设 $v(t) = \\frac{dr}{dt}$。该系统为：\n$$\n\\frac{dr}{dt} = v\n$$\n$$\n\\frac{dv}{dt} = a_r(t, r) = - \\frac{2}{9} \\frac{r}{t^2}\n$$\n初始条件为在 $t_0 = 1$ 时 $(r_0, v_0) = (1, 2/3)$。\n\n我们的任务是实现三种数值积分方案，以离散时间步长 $\\Delta t$ 从 $t_0=1$ 到 $t_f=10$ 求解该系统。在积分的每个时间点 $t_n$，我们计算共动坐标 $x(t_n) = \\frac{r(t_n)}{a(t_n)} = \\frac{r(t_n)}{t_n^{2/3}}$。评估的主要指标是与解析解的最大绝对漂移 $\\max_t |x(t) - x_0|$，其中初始共动位置为 $x_0=1$。\n\n三种积分方案的实现如下：\n\n1.  **显式欧拉法：** 这是一个一阶方法。给定在时间 $t_n$ 的状态 $(r_n, v_n)$，在 $t_{n+1} = t_n + \\Delta t$ 的状态是使用在区间开始时评估的导数来计算的：\n    $$\n    v_{n+1} = v_n + \\Delta t \\cdot a_r(t_n, r_n)\n    $$\n    $$\n    r_{n+1} = r_n + \\Delta t \\cdot v_n\n    $$\n    该方法简单，但众所周知其精度不高，并且对于振荡系统可能会不稳定。\n\n2.  **速度 Verlet (Kick–Drift–Kick) 方法：** 这是一种二阶、辛积分器，由于其在长时积分中具有良好的能量守恒特性，广泛用于分子动力学和 N 体模拟。对于一个依赖于位置和时间的力，步骤如下：\n    *   **踢 (Kick) (半步)：** 使用步长开始时的加速度更新速度。\n        $$v_{n+1/2} = v_n + \\frac{\\Delta t}{2} a_r(t_n, r_n)$$\n    *   **漂移 (Drift) (全步)：** 使用新的半步速度更新位置。\n        $$r_{n+1} = r_n + \\Delta t \\cdot v_{n+1/2}$$\n    *   **踢 (Kick) (半步)：** 计算步长结束时的新加速度 $a_r(t_{n+1}, r_{n+1})$，并更新速度至其最终值。\n        $$v_{n+1} = v_{n+1/2} + \\frac{\\Delta t}{2} a_r(t_{n+1}, r_{n+1})$$\n\n3.  **经典四阶龙格-库塔 (RK4) 方法：** 这是一种四阶方法，对于给定的步长，其精度远高于低阶方法。设状态向量为 $\\mathbf{y} = [r, v]^T$，导数函数为 $\\mathbf{f}(t, \\mathbf{y}) = [v, a_r(t,r)]^T$。更新规则为：\n    $$\n    \\mathbf{k}_1 = \\Delta t \\cdot \\mathbf{f}(t_n, \\mathbf{y}_n)\n    $$\n    $$\n    \\mathbf{k}_2 = \\Delta t \\cdot \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\mathbf{k}_1}{2})\n    $$\n    $$\n    \\mathbf{k}_3 = \\Delta t \\cdot \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\mathbf{k}_2}{2})\n    $$\n    $$\n    \\mathbf{k}_4 = \\Delta t \\cdot \\mathbf{f}(t_n + \\Delta t, \\mathbf{y}_n + \\mathbf{k}_3)\n    $$\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + 2\\mathbf{k}_4)\n    $$\n    这需要在每步中于 $(t, r, v)$ 相空间中的四个不同点评估加速度，以实现其高精度。\n\n程序在不同的函数中实现了这三种方法。一个主循环遍历指定的测试用例。对于每个用例，它将状态初始化为 $(t, r, v) = (1, 1, 2/3)$，计算总步数，并进入一个循环，每次将模拟推进一个步长。在此循环内，在每一步开始时计算共动坐标 $x(t)$，并跟踪与 $x_0=1$ 的最大漂移。在 $t=t_f=10$ 时进行最后一次检查。然后存储累积的最大漂移。最后，收集并打印所有测试用例的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef accel(t: float, r: float) -> float:\n    \"\"\"Calculates the acceleration of the particle.\"\"\"\n    # The time t=0 is avoided by the problem's integration range [1, 10].\n    return -2.0/9.0 * r / t**2\n\ndef euler_integrate(dt: float) -> float:\n    \"\"\"\n    Integrates the particle's motion using the Explicit Euler method.\n    Returns the maximum absolute comoving drift.\n    \"\"\"\n    t0, tf = 1.0, 10.0\n    r, v = 1.0, 2.0 / 3.0\n    x0 = 1.0\n\n    n_steps = int(round((tf - t0) / dt))\n    max_drift = 0.0\n\n    for i in range(n_steps):\n        t = t0 + i * dt\n        \n        # Calculate drift at the start of the step\n        current_x = r / t**(2.0/3.0)\n        max_drift = max(max_drift, abs(current_x - x0))\n\n        # Update step\n        a = accel(t, r)\n        r_new = r + v * dt\n        v_new = v + a * dt\n        r, v = r_new, v_new\n    \n    # Final drift check at t_f\n    final_x = r / tf**(2.0/3.0)\n    max_drift = max(max_drift, abs(final_x - x0))\n    \n    return max_drift\n\ndef verlet_integrate(dt: float) -> float:\n    \"\"\"\n    Integrates the particle's motion using the Velocity Verlet (KDK) method.\n    Returns the maximum absolute comoving drift.\n    \"\"\"\n    t0, tf = 1.0, 10.0\n    r, v = 1.0, 2.0 / 3.0\n    x0 = 1.0\n\n    n_steps = int(round((tf - t0) / dt))\n    max_drift = 0.0\n\n    for i in range(n_steps):\n        t = t0 + i * dt\n        \n        # Calculate drift at the start of the step\n        current_x = r / t**(2.0/3.0)\n        max_drift = max(max_drift, abs(current_x - x0))\n\n        # Kick-Drift-Kick update\n        a_current = accel(t, r)\n        v_half = v + 0.5 * dt * a_current\n        r_next = r + dt * v_half\n        t_next = t + dt\n        a_next = accel(t_next, r_next)\n        v_next = v_half + 0.5 * dt * a_next\n        r, v = r_next, v_next\n\n    # Final drift check at t_f\n    final_x = r / tf**(2.0/3.0)\n    max_drift = max(max_drift, abs(final_x - x0))\n    \n    return max_drift\n\ndef rk4_integrate(dt: float) -> float:\n    \"\"\"\n    Integrates the particle's motion using the Classical RK4 method.\n    Returns the maximum absolute comoving drift.\n    \"\"\"\n    t0, tf = 1.0, 10.0\n    r, v = 1.0, 2.0 / 3.0\n    x0 = 1.0\n\n    n_steps = int(round((tf - t0) / dt))\n    max_drift = 0.0\n\n    for i in range(n_steps):\n        t = t0 + i * dt\n        \n        # Calculate drift at the start of the step\n        current_x = r / t**(2.0/3.0)\n        max_drift = max(max_drift, abs(current_x - x0))\n\n        # RK4 stages\n        k1_r = dt * v\n        k1_v = dt * accel(t, r)\n\n        k2_r = dt * (v + k1_v / 2.0)\n        k2_v = dt * accel(t + dt / 2.0, r + k1_r / 2.0)\n\n        k3_r = dt * (v + k2_v / 2.0)\n        k3_v = dt * accel(t + dt / 2.0, r + k2_r / 2.0)\n\n        k4_r = dt * (v + k3_v)\n        k4_v = dt * accel(t + dt, r + k3_r)\n        \n        # Update step\n        r += (k1_r + 2.0 * k2_r + 2.0 * k3_r + k4_r) / 6.0\n        v += (k1_v + 2.0 * k2_v + 2.0 * k3_v + k4_v) / 6.0\n\n    # Final drift check at t_f\n    final_x = r / tf**(2.0/3.0)\n    max_drift = max(max_drift, abs(final_x - x0))\n    \n    return max_drift\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        ('Euler', 0.5),\n        ('Euler', 0.05),\n        ('Verlet', 0.1),\n        ('RK4', 0.5),\n        ('RK4', 0.01),\n    ]\n\n    integrators = {\n        'Euler': euler_integrate,\n        'Verlet': verlet_integrate,\n        'RK4': rk4_integrate\n    }\n\n    results = []\n    for integrator_name, dt in test_cases:\n        func = integrators[integrator_name]\n        drift = func(dt)\n        results.append(drift)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3506173"}, {"introduction": "在构建运动方程时，我们可以选择不同的“时间”作为积分变量，例如宇宙时（cosmic time）$t$、共形时间（conformal time）$\\eta$，甚至是尺度因子 $a$ 本身。这个选择并非无关紧要，它会极大地影响模拟的数值稳定性和准确性。在这个高级练习 [@problem_id:3506154] 中，你将通过积分一个共动谐振子系统来探索这一点，并衡量不同积分变量的选择对一个已知物理不变量的守恒效果。", "problem": "要求您实现并比较三种恒定步长控制策略，用于在空间平坦的弗里德曼-勒梅特-罗伯逊-沃尔克 (FLRW) 宇宙中对单个粒子的共动运动方程进行数值积分。这些策略基于三个不同的自变量：宇宙时 $t$、共形时 $\\eta$ 和标度因子 $a$。您的比较必须量化每种策略对一个共动能量不变量守恒的影响。\n\n基本依据和定义：\n- 令物理位置为 $\\mathbf{r}(t)=a(t)\\,\\mathbf{x}(t)$，其中 $a(t)$ 是标度因子，$\\mathbf{x}$ 是共动坐标。考虑一维空间，因此 $x$ 和 $r$ 是标量。通过 $H(a)=\\dot{a}/a$ 定义哈勃参数 $H(a)$，其中点号表示对 $t$ 的导数。\n- 令无量纲哈勃函数为 $h(a)=H(a)/H_0$，其中 $H_0$ 是一个常数参考值。假设一个平坦的 Lambda 冷暗物质模型，使得 $h(a)=\\sqrt{\\Omega_{\\mathrm{m}} a^{-3}+\\Omega_{\\Lambda}}$，其中常数 $\\Omega_{\\mathrm{m}}$ 和 $\\Omega_{\\Lambda}$ 满足 $\\Omega_{\\mathrm{m}}+\\Omega_{\\Lambda}=1$。\n- 通过 $d\\eta=dt/a$ 定义共形时 $\\eta$。标度因子 $a$ 与 $\\eta$ 和 $t$ 的关系如下\n$$\n\\frac{d\\eta}{da}=\\frac{1}{a^2 h(a)},\\qquad \\frac{dt}{da}=\\frac{1}{a h(a)}。\n$$\n- 考虑一个与 $\\eta$ 无关的共动谐振子势 $\\phi(x)=\\tfrac{1}{2}\\,\\omega_c^2\\,x^2$，其中常数 $\\omega_c0$。\n\n运动方程：\n- 在共形时下，共动运动方程为\n$$\n\\frac{dx}{d\\eta}=u,\\qquad \\frac{du}{d\\eta}=-\\omega_c^2\\,x,\n$$\n其中 $u$ 是与 $x$ 共轭的共动正则动量 (对于单位质量，等于 $dx/d\\eta$)。对于这个不依赖于时间的共动势，共动能量\n$$\nE_c(\\eta)=\\tfrac{1}{2}\\,u^2+\\tfrac{1}{2}\\,\\omega_c^2\\,x^2\n$$\n是一个不变量，因此在精确动力学下必须守恒。\n\n- 使用宇宙时 $t$ 重写相同的动力学，并且仅使用上述定义而不引入任何额外的宇宙学公式，可得\n$$\n\\frac{dx}{dt}=\\frac{u}{a},\\qquad \\frac{du}{dt}=-\\frac{\\omega_c^2}{a}\\,x,\\qquad \\frac{da}{dt}=a\\,h(a)。\n$$\n\n- 以标度因子 $a$ 作为自变量重写，可得\n$$\n\\frac{dx}{da}=\\frac{u}{a^2 h(a)},\\qquad \\frac{du}{da}=-\\frac{\\omega_c^2}{a^2 h(a)}\\,x。\n$$\n\n数值方法要求：\n- 对一个通用的一阶系统 $\\dfrac{d\\mathbf{y}}{ds}=\\mathbf{F}(s,\\mathbf{y})$，实现一个单步显式二阶龙格-库塔 (中点) 法，其中 $s$ 是所选的自变量 ($t$、$\\eta$ 或 $a$)。从 $s_n$ 到 $s_{n+1}=s_n+\\Delta s$ 的步进计算如下\n$$\n\\mathbf{k}_1=\\mathbf{F}(s_n,\\mathbf{y}_n),\\quad \\mathbf{k}_2=\\mathbf{F}\\left(s_n+\\tfrac{1}{2}\\Delta s,\\ \\mathbf{y}_n+\\tfrac{1}{2}\\Delta s\\,\\mathbf{k}_1\\right),\\quad \\mathbf{y}_{n+1}=\\mathbf{y}_n+\\Delta s\\,\\mathbf{k}_2。\n$$\n\n性能度量：\n- 对每种策略，计算共动能量的最大相对漂移\n$$\n\\delta_{\\max}=\\max_{n}\\left|\\frac{E_c(n)-E_c(0)}{E_c(0)}\\right|,\n$$\n其中 $E_c(n)$ 是在步数索引 $n$ 处的共动能量，$E_c(0)$ 是初始共动能量。所有量均为无量纲。\n\n实现细节：\n- 使用无量纲哈勃函数 $h(a)=\\sqrt{\\Omega_{\\mathrm{m}} a^{-3}+\\Omega_{\\Lambda}}$ 来计算 $d\\eta/da$ 和 $dt/da$，并在以 $t$ 为自变量进行积分时演化 $a(t)$。\n- 当以 $\\eta$ 为自变量进行积分时，通过对 $d\\eta/da$ 在 $a$ 上积分来获得区间 $[a_{\\mathrm{i}},a_{\\mathrm{f}}]$ 上的总 $\\Delta \\eta$；同样，当以 $t$ 为自变量进行积分时，通过对 $dt/da$ 在 $a$ 上积分来获得 $[a_{\\mathrm{i}},a_{\\mathrm{f}}]$ 上的总 $\\Delta t$。使用恒定步长 $\\Delta s$，其值由这些总时间除以步数 $N$ 确定。\n- 初始条件在 $a=a_{\\mathrm{i}}$ 处指定为 $x(0)=x_0$ 和 $u(0)=u_0$。\n\n测试套件：\n- 情况 1 (通用 Lambda 冷暗物质模型)：$\\Omega_{\\mathrm{m}}=0.3$，$\\Omega_{\\Lambda}=0.7$，$a_{\\mathrm{i}}=0.1$，$a_{\\mathrm{f}}=1.0$，$\\omega_c=0.5$，$x_0=1.0$，$u_0=0.0$，$N=1000$。\n- 情况 2 (爱因斯坦-德西特物质主导，早期宇宙)：$\\Omega_{\\mathrm{m}}=1.0$，$\\Omega_{\\Lambda}=0.0$，$a_{\\mathrm{i}}=0.01$，$a_{\\mathrm{f}}=0.1$，$\\omega_c=2.0$，$x_0=0.2$，$u_0=0.0$，$N=1500$。\n- 情况 3 (宇宙学常数主导，晚期宇宙)：$\\Omega_{\\mathrm{m}}=0.0$，$\\Omega_{\\Lambda}=1.0$，$a_{\\mathrm{i}}=0.5$，$a_{\\mathrm{f}}=2.0$，$\\omega_c=0.1$，$x_0=1.0$，$u_0=0.0$，$N=800$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个长度为 3 的列表，每个元素本身是一个长度为 3 的列表，其中包含三种策略的最大相对能量漂移，顺序为 $[t,\\eta,a]$，对应于三个测试用例的顺序 $[1,2,3]$。例如，输出必须看起来像\n$$\n\\big[[\\delta_{t,1},\\delta_{\\eta,1},\\delta_{a,1}],\\ [\\delta_{t,2},\\delta_{\\eta,2},\\delta_{a,2}],\\ [\\delta_{t,3},\\delta_{\\eta,3},\\delta_{a,3}]\\big],\n$$\n以单行形式打印，带有方括号和逗号，数据为无量纲浮点数。", "solution": "用户要求实现并比较三种用于求解共动谐振子势中粒子运动方程的数值积分策略。验证和解决方案如下所示。\n\n### **问题验证**\n\n**步骤 1：提取已知条件**\n-   **模型**：空间平坦的弗里德曼-勒梅特-罗伯逊-沃尔克 (FLRW) 宇宙。\n-   **坐标与关系**：物理位置 $r(t) = a(t)x(t)$，其中 $x$ 是共动坐标。哈勃参数 $H(a) = \\dot{a}/a$。无量纲哈勃函数 $h(a) = H(a)/H_0 = \\sqrt{\\Omega_{\\mathrm{m}} a^{-3} + \\Omega_{\\Lambda}}$，且 $\\Omega_{\\mathrm{m}} + \\Omega_{\\Lambda} = 1$。共形时由 $d\\eta = dt/a$ 定义。\n-   **关键微分关系**：$\\frac{d\\eta}{da} = \\frac{1}{a^2 h(a)}$，$\\frac{dt}{da} = \\frac{1}{a h(a)}$。\n-   **势和不变量**：共动谐振子势 $\\phi(x) = \\frac{1}{2}\\omega_c^2 x^2$。相关的共动能量 $E_c = \\frac{1}{2}u^2 + \\frac{1}{2}\\omega_c^2 x^2$ 是一个不变量，其中 $u$ 是共动正则动量。\n-   **运动方程 (EOM)**：\n    1.  自变量 $\\eta$：$\\frac{dx}{d\\eta}=u$, $\\frac{du}{d\\eta}=-\\omega_c^2 x$。\n    2.  自变量 $t$：$\\frac{dx}{dt}=\\frac{u}{a}$, $\\frac{du}{dt}=-\\frac{\\omega_c^2}{a}x$, $\\frac{da}{dt}=a h(a)$。\n    3.  自变量 $a$：$\\frac{dx}{da}=\\frac{u}{a^2 h(a)}$, $\\frac{du}{da}=-\\frac{\\omega_c^2}{a^2 h(a)}x$。\n-   **数值方法**：对于 $\\frac{d\\mathbf{y}}{ds}=\\mathbf{F}(s,\\mathbf{y})$ 的显式二阶龙格-库塔 (中点) 法：\n    $$\n    \\mathbf{k}_1=\\mathbf{F}(s_n,\\mathbf{y}_n),\\quad \\mathbf{k}_2=\\mathbf{F}\\left(s_n+\\tfrac{1}{2}\\Delta s,\\ \\mathbf{y}_n+\\tfrac{1}{2}\\Delta s\\,\\mathbf{k}_1\\right),\\quad \\mathbf{y}_{n+1}=\\mathbf{y}_n+\\Delta s\\,\\mathbf{k}_2.\n    $$\n-   **性能度量**：最大相对能量漂移 $\\delta_{\\max}=\\max_{n}\\left|\\frac{E_c(n)-E_c(0)}{E_c(0)}\\right|$。\n-   **积分流程**：对于给定的积分范围 $[a_{\\mathrm{i}}, a_{\\mathrm{f}}]$ 和 $N$ 步：\n    -   总积分时间 $\\Delta t_{\\text{total}} = \\int_{a_{\\mathrm{i}}}^{a_{\\mathrm{f}}} \\frac{da}{a h(a)}$ 和 $\\Delta \\eta_{\\text{total}} = \\int_{a_{\\mathrm{i}}}^{a_{\\mathrm{f}}} \\frac{da}{a^2 h(a)}$。\n    -   恒定步长为 $\\Delta t = \\Delta t_{\\text{total}}/N$，$\\Delta \\eta = \\Delta \\eta_{\\text{total}}/N$，以及 $\\Delta a = (a_{\\mathrm{f}}-a_{\\mathrm{i}})/N$。\n-   **初始条件**：在标度因子 $a=a_{\\mathrm{i}}$ 处，$x(0)=x_0, u(0)=u_0$。\n-   **测试用例**：\n    -   情况 1：$\\Omega_{\\mathrm{m}}=0.3, \\Omega_{\\Lambda}=0.7, a_{\\mathrm{i}}=0.1, a_{\\mathrm{f}}=1.0, \\omega_c=0.5, x_0=1.0, u_0=0.0, N=1000$。\n    -   情况 2：$\\Omega_{\\mathrm{m}}=1.0, \\Omega_{\\Lambda}=0.0, a_{\\mathrm{i}}=0.01, a_{\\mathrm{f}}=0.1, \\omega_c=2.0, x_0=0.2, u_0=0.0, N=1500$。\n    -   情况 3：$\\Omega_{\\mathrm{m}}=0.0, \\Omega_{\\Lambda}=1.0, a_{\\mathrm{i}}=0.5, a_{\\mathrm{f}}=2.0, \\omega_c=0.1, x_0=1.0, u_0=0.0, N=800$。\n-   **输出格式**：打印一个单行列表的列表：$[[\\delta_{t,1},\\delta_{\\eta,1},\\delta_{a,1}], [\\delta_{t,2},\\delta_{\\eta,2},\\delta_{a,2}], [\\delta_{t,3},\\delta_{\\eta,3},\\delta_{a,3}]]$。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学基础**：该问题基于标准的 ΛCDM 宇宙学模型和经典力学，这些都是已确立的科学原理。运动方程是在膨胀宇宙中粒子的标准推导。该设置在科学上是合理的。\n-   **适定性**：为每个测试用例都明确提供了所有必要的参数、初始条件和控制方程。数值方法已明确定义。任务是执行一个明确定义的数值实验。该问题是适定的。\n-   **客观性**：问题陈述使用精确、客观的数学语言编写，没有歧义或主观性陈述。\n-   **一致性检查**：通过链式法则和所提供的定义（例如，$\\frac{dx}{dt} = \\frac{dx}{d\\eta}\\frac{d\\eta}{dt} = u \\cdot \\frac{1}{a}$），各种形式的运动方程彼此一致。在像 $\\frac{da}{dt}=a h(a)$ 这样的运动方程中使用无量纲哈勃函数 $h(a)$，在所选的单位制中隐含地将哈勃常数 $H_0$ 设为 1，这是理论宇宙学中的标准做法。由于所有方程都是明确给出的，这构成了一个自洽且一致的系统。\n-   **可行性**：所选参数在物理上代表了不同的宇宙时期。数值积分是标准的，可以使用指定的库来执行。该问题是可行的。\n\n**步骤 3：结论与行动**\n问题有效。将提供完整的解决方案。\n\n### **基于原理的设计**\n\n问题的核心是比较同一物理动力学三种不同表述的数值稳定性。该系统是一个共动谐振子，其共动能量是一个守恒量。数值积分器的准确性可以通过它对该不变量的保持程度来衡量。这三种表述分别使用宇宙时 $t$、共形时 $\\eta$ 和标度因子 $a$ 作为独立的积分变量。\n\n**1. 通用数值方法：二阶龙格-库塔 (中点) 法**\n将按照问题中的定义，为 RK2 中点步进实现一个通用函数。该函数将接收右端 (RHS) 函数 $\\mathbf{F}$、当前自变量值 $s$、状态向量 $\\mathbf{y}$ 和步长 $\\Delta s$，并返回更新后的状态向量。\n\n**2. 积分策略**\n\n-   **策略 I：关于宇宙时 $t$ 的积分**\n    -   状态向量为 $\\mathbf{y} = [x, u, a]$。我们必须将标度因子 $a$ 的演化与粒子的坐标一起积分，因为 $x$ 和 $u$ 的运动方程明确地依赖于 $a$。\n    -   常微分方程组为 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{F}_t(\\mathbf{y}) = [u/a, -\\omega_c^2 x/a, a h(a)]$。这是一个自治系统（右端不显式依赖于 $t$）。\n    -   总积分时间 $\\Delta t_{\\text{total}}$ 通过对 $\\frac{dt}{da} = \\frac{1}{a h(a)}$ 从 $a_{\\mathrm{i}}$ 到 $a_{\\mathrm{f}}$ 进行数值积分来计算。步长为 $\\Delta t = \\Delta t_{\\text{total}} / N$。\n\n-   **策略 II：关于共形时 $\\eta$ 的积分**\n    -   共形时下的运动方程 $\\frac{dx}{d\\eta}=u$ 和 $\\frac{du}{d\\eta}=-\\omega_c^2 x$ 描述了一个简谐振子。其系数是恒定的。\n    -   状态向量为 $\\mathbf{y} = [x, u]$。常微分方程组为 $\\frac{d\\mathbf{y}}{d\\eta} = \\mathbf{F}_\\eta(\\mathbf{y}) = [u, -\\omega_c^2 x]$。这是一个线性、自治的系统，其精确解在相空间中位于一个椭圆上，使其成为测试积分器的理想选择。\n    -   总积分时间 $\\Delta \\eta_{\\text{total}}$ 通过对 $\\frac{d\\eta}{da} = \\frac{1}{a^2 h(a)}$ 从 $a_{\\mathrm{i}}$ 到 $a_{\\mathrm{f}}$ 进行数值积分来计算。步长为 $\\Delta \\eta = \\Delta \\eta_{\\text{total}} / N$。由于运动方程形式简单且不依赖于时间，预期选择此变量会产生最高的精度。\n\n-   **策略 III：关于标度因子 $a$ 的积分**\n    -   状态向量为 $\\mathbf{y} = [x, u]$。\n    -   运动方程为 $\\frac{d\\mathbf{y}}{da} = \\mathbf{F}_a(a, \\mathbf{y}) = [\\frac{u}{a^2 h(a)}, -\\frac{\\omega_c^2 x}{a^2 h(a)}]$。这是一个非自治系统，因为右端显式依赖于积分变量 $a$。系数的这种可变性对固定步长的积分器可能构成挑战。\n    -   步长就是 $\\Delta a = (a_{\\mathrm{f}} - a_{\\mathrm{i}}) / N$。积分以标度因子的均匀步长进行。\n\n**3. 实现结构**\n一个主函数将遍历所提供的三个测试用例。对于每个用例，它将调用三个独立的求解器函数，每个函数对应一种积分策略。每个求解器将：\n1.  根据用例参数定义特定的无量纲哈勃函数 $h(a)$。\n2.  如有必要，使用 `scipy.integrate.quad` 计算总积分区间（对于 $t$ 和 $\\eta$）。\n3.  确定恒定步长。\n4.  初始化状态向量，并计算初始共动能量 $E_c(0)$。\n5.  循环 $N$ 次，在每次迭代中应用 RK2 步进。在循环内部，计算当前的共动能量 $E_c(n)$ 并更新最大相对漂移 $\\delta_{\\max}$。\n6.  返回最终的 $\\delta_{\\max}$。\n\n每种情况下三种策略的结果将被收集并格式化为最终输出所需的嵌套列表。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the comoving equations of motion using three different integration strategies\n    and computes the maximum relative energy drift for each.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (LCDM)\n        {'Omega_m': 0.3, 'Omega_L': 0.7, 'a_i': 0.1, 'a_f': 1.0, \n         'omega_c': 0.5, 'x0': 1.0, 'u0': 0.0, 'N': 1000},\n        # Case 2 (EdS)\n        {'Omega_m': 1.0, 'Omega_L': 0.0, 'a_i': 0.01, 'a_f': 0.1, \n         'omega_c': 2.0, 'x0': 0.2, 'u0': 0.0, 'N': 1500},\n        # Case 3 (de Sitter)\n        {'Omega_m': 0.0, 'Omega_L': 1.0, 'a_i': 0.5, 'a_f': 2.0, \n         'omega_c': 0.1, 'x0': 1.0, 'u0': 0.0, 'N': 800}\n    ]\n\n    all_results = []\n\n    def rk2_midpoint_step(F, s, y, ds, params):\n        \"\"\"A single RK2 midpoint step.\"\"\"\n        k1 = F(s, y, params)\n        y_mid = y + 0.5 * ds * k1\n        s_mid = s + 0.5 * ds\n        k2 = F(s_mid, y_mid, params)\n        y_next = y + ds * k2\n        return y_next\n\n    # --- RHS functions for the ODEs ---\n    def F_t(t, y, params):\n        x, u, a = y\n        h_func = params['h_func']\n        omega_c = params['omega_c']\n        # Avoid division by zero if a becomes very small, although not expected here.\n        if a == 0:\n            return np.zeros(3)\n        return np.array([u / a, -omega_c**2 * x / a, a * h_func(a)])\n\n    def F_eta(eta, y, params):\n        x, u = y\n        omega_c = params['omega_c']\n        return np.array([u, -omega_c**2 * x])\n\n    def F_a(a, y, params):\n        x, u = y\n        h_func = params['h_func']\n        omega_c = params['omega_c']\n        # Avoid division by zero at a=0.\n        if a == 0:\n            return np.zeros(2)\n        common_factor = 1.0 / (a**2 * h_func(a))\n        return np.array([u * common_factor, -omega_c**2 * x * common_factor])\n\n    # --- Solver for each strategy ---\n    def solve_with_t(params):\n        N, a_i, a_f, x0, u0 = params['N'], params['a_i'], params['a_f'], params['x0'], params['u0']\n        h_func = params['h_func']\n        \n        total_t, _ = integrate.quad(lambda a: 1.0 / (a * h_func(a)), a_i, a_f)\n        dt = total_t / N\n        \n        y = np.array([x0, u0, a_i])\n        \n        E_c_0 = 0.5 * u0**2 + 0.5 * params['omega_c']**2 * x0**2\n        if E_c_0 == 0: return 0.0\n        \n        max_drift = 0.0\n        \n        s = 0.0\n        for _ in range(N):\n            y = rk2_midpoint_step(F_t, s, y, dt, params)\n            s += dt\n            x_n, u_n, _ = y\n            E_c_n = 0.5 * u_n**2 + 0.5 * params['omega_c']**2 * x_n**2\n            drift = abs((E_c_n - E_c_0) / E_c_0)\n            if drift > max_drift:\n                max_drift = drift\n        return max_drift\n\n    def solve_with_eta(params):\n        N, a_i, a_f, x0, u0 = params['N'], params['a_i'], params['a_f'], params['x0'], params['u0']\n        h_func = params['h_func']\n        \n        total_eta, _ = integrate.quad(lambda a: 1.0 / (a**2 * h_func(a)), a_i, a_f)\n        deta = total_eta / N\n        \n        y = np.array([x0, u0])\n        \n        E_c_0 = 0.5 * u0**2 + 0.5 * params['omega_c']**2 * x0**2\n        if E_c_0 == 0: return 0.0\n        \n        max_drift = 0.0\n        \n        s = 0.0\n        for _ in range(N):\n            y = rk2_midpoint_step(F_eta, s, y, deta, params)\n            s += deta\n            x_n, u_n = y\n            E_c_n = 0.5 * u_n**2 + 0.5 * params['omega_c']**2 * x_n**2\n            drift = abs((E_c_n - E_c_0) / E_c_0)\n            if drift > max_drift:\n                max_drift = drift\n        return max_drift\n\n    def solve_with_a(params):\n        N, a_i, a_f, x0, u0 = params['N'], params['a_i'], params['a_f'], params['x0'], params['u0']\n        \n        da = (a_f - a_i) / N\n        \n        y = np.array([x0, u0])\n        \n        E_c_0 = 0.5 * u0**2 + 0.5 * params['omega_c']**2 * x0**2\n        if E_c_0 == 0: return 0.0\n\n        max_drift = 0.0\n        \n        s = a_i\n        for _ in range(N):\n            y = rk2_midpoint_step(F_a, s, y, da, params)\n            s += da\n            x_n, u_n = y\n            E_c_n = 0.5 * u_n**2 + 0.5 * params['omega_c']**2 * x_n**2\n            drift = abs((E_c_n - E_c_0) / E_c_0)\n            if drift > max_drift:\n                max_drift = drift\n        return max_drift\n\n    for case_params in test_cases:\n        Omega_m = case_params['Omega_m']\n        Omega_L = case_params['Omega_L']\n        \n        # Define the dimensionless Hubble function for the current case\n        def h_func(a):\n            return np.sqrt(Omega_m * a**-3 + Omega_L)\n        \n        current_params = case_params.copy()\n        current_params['h_func'] = h_func\n\n        # Calculate drift for each strategy\n        drift_t = solve_with_t(current_params)\n        drift_eta = solve_with_eta(current_params)\n        drift_a = solve_with_a(current_params)\n        \n        all_results.append([drift_t, drift_eta, drift_a])\n    \n    # Format the output string as required\n    result_str = str(all_results).replace(\" \", \"\")\n    print(result_str)\n\nsolve()\n```", "id": "3506154"}]}