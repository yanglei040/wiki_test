{"hands_on_practices": [{"introduction": "本章节的第一个实践练习将聚焦于化学网络的核心：电离与复合之间的平衡。由于在稠密气体中，复合过程发生在极短的时间尺度上，这使得控制方程在数值上变得“刚性”，对简单的显式求解器构成了挑战。本练习将引导你推导一个稳定性条件，并实现一个显式方法与一个更稳健的隐式方法之间的比较，以建立你处理刚性方程的直觉。[@problem_id:3507618]", "problem": "考虑在宇宙再电离时期，一个代表星系际介质单元的单一、空间均匀的控制体积中，氢电离分数 $x(t) \\in [0,1]$ 的演化。假设氢数密度 $n_{\\mathrm{H}}$ 恒定，并且由于外部辐射场，每个氢原子的光致电离率 $\\Gamma$ 也恒定。忽略碰撞电离，并采用固定温度下系数为 $\\alpha_{\\mathrm{B}}$ 的B情况复合（Case B recombination）。控制常微分方程（ODE）为\n$$\n\\frac{dx}{dt} = (1 - x)\\,\\Gamma - \\alpha_{\\mathrm{B}}\\,n_{\\mathrm{H}}\\,x^2,\n$$\n该方程源于光致电离与辐射复合之间的平衡。定义复合时间尺度\n$$\nt_{\\mathrm{rec}} = \\frac{1}{\\alpha_{\\mathrm{B}}\\,n_{\\mathrm{H}}},\n$$\n并令 $k \\equiv \\alpha_{\\mathrm{B}}\\,n_{\\mathrm{H}}$。\n\n任务A（推导）：从该ODE出发，围绕稳定平衡点 $x_{\\infty}$（即 $k\\,x^2 + \\Gamma\\,x - \\Gamma = 0$ 的正根）对动力学进行线性化，并分析前向欧拉显式离散化。推导出一个充分的时间步长条件，该条件可用一个选定的无量纲参数 $0  \\epsilon  1$ 和复合时间尺度 $t_{\\mathrm{rec}}$ 来表示，以确保显式更新不会产生向 $x_{\\infty}$ 的振荡性趋近，从而防止电离分数的步间过冲。你的推导应仅使用在 $x_{\\infty}$ 处计算的右侧项的雅可比矩阵，以及针对具有负特征值的线性测试方程的前向欧拉稳定性行为。从复合所主导的刚度角度解释该判据的物理意义。\n\n任务B（算法比较）：为该ODE在有限时间域 $T$ 内（从 $x(0) = x_0$ 开始）实现两个时间积分器：\n- 一个显式前向欧拉方法，\n$$\nx^{n+1} = x^n + \\Delta t\\left[(1 - x^n)\\,\\Gamma - k\\,(x^n)^2\\right].\n$$\n- 一个隐式后向欧拉方法，\n$$\nx^{n+1} = x^n + \\Delta t\\left[(1 - x^{n+1})\\,\\Gamma - k\\,(x^{n+1})^2\\right],\n$$\n该方法在每一步都归结为一个关于 $x^{n+1}$ 的二次方程；选择 $[0,1]$ 范围内物理上允许的根。\n\n为获得参考精度，请使用具有常系数的Riccati方程的精确解。令 $x_1$ 和 $x_2$ 为 $k\\,x^2 + \\Gamma\\,x - \\Gamma = 0$ 的两个稳态根（其中 $x_1 > 0$ 且 $x_2  0$），并定义 $\\lambda = \\sqrt{\\Gamma^2 + 4\\,\\Gamma\\,k} = k\\,(x_1 - x_2)$。对于初始条件 $x(0) = x_0$，精确解为\n$$\nx(t) = \\frac{x_1 - C\\,e^{-\\lambda t}\\,x_2}{1 - C\\,e^{-\\lambda t}}, \\quad C = \\frac{x_0 - x_1}{x_0 - x_2}.\n$$\n\n成本模型：将显式方法的每步成本计为 $w_{\\mathrm{exp}} = 1$，隐式方法的每步成本计为 $w_{\\mathrm{imp}} = 4$，以反映额外的代数求解工作。总成本是步数乘以相应的权重。如果使用固定的 $\\Delta t$ 会导致最后一步超过 $T$，则仅缩短最后一步，使步长总和恰好等于 $T$。\n\n过冲度量：对于显式方法，记录在积分过程中遇到的超过物理边界 $x \\le 1$ 的最大过冲，\n$$\n\\mathrm{overshoot}_{\\max} = \\max_{n}\\,\\max\\left(0, x^n - 1\\right).\n$$\n\n精度度量：报告两种积分器在最终时刻的绝对误差，\n$$\nE_{\\mathrm{exp}} = \\left|x_{\\mathrm{exp}}(T) - x_{\\mathrm{exact}}(T)\\right|,\\quad\nE_{\\mathrm{imp}} = \\left|x_{\\mathrm{imp}}(T) - x_{\\mathrm{exact}}(T)\\right|.\n$$\n\n单位：$n_{\\mathrm{H}}$ 的单位为 $\\mathrm{cm}^{-3}$，$\\alpha_{\\mathrm{B}}$ 的单位为 $\\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$\\Gamma$ 的单位为 $\\mathrm{s}^{-1}$，所有时间（包括 $t_{\\mathrm{rec}}$、$T$ 和 $\\Delta t$）的单位均为 $\\mathrm{s}$。初始分数 $x_0$ 和过冲是无量纲的。\n\n测试套件：你的程序必须评估以下五个科学上合理的参数集，每个参数集由一个元组 $(\\alpha_{\\mathrm{B}}, n_{\\mathrm{H}}, \\Gamma, x_0, \\epsilon, T_{\\mathrm{factor}}, \\Delta t_{\\mathrm{factor}})$ 表示，其中 $T = T_{\\mathrm{factor}}\\,t_{\\mathrm{rec}}$ 且 $\\Delta t = \\Delta t_{\\mathrm{factor}}\\,\\epsilon\\,t_{\\mathrm{rec}}$：\n- 情况1：$(2.6\\times10^{-13}, 1.0\\times10^{-2}, 1.0\\times10^{-15}, 0.0, 0.2, 2.0, 0.25)$，一个远在判据内的“理想”显式时间步长。\n- 情况2：$(2.6\\times10^{-13}, 1.0\\times10^{-2}, 1.0\\times10^{-15}, 0.0, 0.2, 2.0, 0.95)$，一个接近边界、刚好在安全裕度内的显式时间步长。\n- 情况3：$(2.6\\times10^{-13}, 1.0\\times10^{-2}, 1.0\\times10^{-15}, 0.0, 0.2, 2.0, 1.2)$，一个旨在触发过冲或振荡行为的超临界显式时间步长。\n- 情况4：$(2.6\\times10^{-13}, 1.0\\times10^{-1}, 2.0\\times10^{-14}, 0.0, 0.1, 1.0, 0.5)$，一个密度更高、刚性更强的情况，显式时间步长被安全地约束。\n- 情况5：$(2.6\\times10^{-13}, 1.0\\times10^{-3}, 1.0\\times10^{-16}, 0.0, 0.3, 3.0, 1.1)$，一个低密度情况，其显式时间步长超过判据。\n\n对于每种情况，还需计算编码为整数的布尔判据检查，\n$$\n\\mathrm{pass} = \\begin{cases}\n1   \\text{若 }\\Delta t  \\epsilon\\,t_{\\mathrm{rec}},\\\\\n0   \\text{否则。}\n\\end{cases}\n$$\n\n最终输出格式：你的程序应生成一行输出，其中包含所有情况的结果，并聚合为一个列表的列表。对于每种情况，返回一个包含六个条目的列表\n$$\n[\\mathrm{pass},\\ \\mathrm{overshoot}_{\\max},\\ E_{\\mathrm{exp}},\\ E_{\\mathrm{imp}},\\ \\mathrm{cost}_{\\mathrm{exp}},\\ \\mathrm{cost}_{\\mathrm{imp}}],\n$$\n顺序如上。最后一行必须是\n$$\n[\\,[\\cdots],\\,[\\cdots],\\,[\\cdots],\\,[\\cdots],\\,[\\cdots]\\,].\n$$\n所有数值条目的类型必须是布尔型、整型、浮点型或它们的列表。布尔值必须编码为 $0$ 或 $1$（整数）。", "solution": "此问题经评估为有效。它在科学上基于已建立的光致电离与复合理论，提出了一个具有已知解析解的适定常微分方程，并定义了一套清晰、客观的计算任务和度量标准。所提供的参数据称对于宇宙再电离相关环境是科学上合理的。\n\n### 任务A：时间步长条件的推导\n\n电离分数 $x(t)$ 的演化由以下常微分方程（ODE）控制：\n$$\n\\frac{dx}{dt} = f(x) = (1 - x)\\Gamma - kx^2\n$$\n其中 $\\Gamma$ 是光致电离率， $k = \\alpha_{\\mathrm{B}}n_{\\mathrm{H}}$ 是经氢数密度缩放的复合率系数。\n\n当 $\\frac{dx}{dt} = 0$ 时，系统达到平衡态 $x_{\\infty}$，这需要求解二次方程：\n$$\nk x_{\\infty}^2 + \\Gamma x_{\\infty} - \\Gamma = 0\n$$\n问题指明我们关心的是稳定平衡，它对应于此方程的唯一正根，这可以通过分析系统动力学来验证。\n\n为分析数值方法在此平衡点附近的行为，我们在 $x = x_{\\infty}$ 周围对ODE进行线性化。令 $x(t) = x_{\\infty} + \\delta x(t)$，其中 $\\delta x$ 是一个小扰动。扰动的动力学近似为：\n$$\n\\frac{d(\\delta x)}{dt} \\approx J(x_{\\infty}) \\cdot \\delta x\n$$\n此处，$J(x)$ 是右侧项 $f(x)$ 的雅可比矩阵。\n$$\nJ(x) = \\frac{df}{dx} = \\frac{d}{dx} \\left( \\Gamma - \\Gamma x - kx^2 \\right) = -\\Gamma - 2kx\n$$\n在平衡点 $x_{\\infty}$ 处计算雅可比矩阵，给出线性化系统的特征值 $\\lambda_{\\text{sys}}$：\n$$\n\\lambda_{\\text{sys}} = J(x_{\\infty}) = -\\Gamma - 2kx_{\\infty}\n$$\n由于 $\\Gamma > 0$，$k > 0$ 且 $x_{\\infty} > 0$，该特征值总是负的，证实了 $x_{\\infty}$ 是一个稳定不动点。\n\n应用于线性测试方程 $\\frac{dy}{dt} = \\lambda_{\\text{sys}} y$ 的前向欧拉方法由下式给出：\n$$\ny^{n+1} = y^n + \\Delta t (\\lambda_{\\text{sys}} y^n) = (1 + \\Delta t \\lambda_{\\text{sys}}) y^n\n$$\n为使数值解收敛到平衡点而不发生振荡，放大因子 $(1 + \\Delta t \\lambda_{\\text{sys}})$ 必须为非负。即：\n$$\n1 + \\Delta t \\lambda_{\\text{sys}} \\ge 0\n$$\n代入 $\\lambda_{\\text{sys}}$ 的表达式并求解时间步长 $\\Delta t$：\n$$\n1 + \\Delta t (-\\Gamma - 2kx_{\\infty}) \\ge 0 \\implies 1 \\ge \\Delta t (\\Gamma + 2kx_{\\infty}) \\implies \\Delta t \\le \\frac{1}{\\Gamma + 2kx_{\\infty}}\n$$\n这是为防止在平衡点 $x_{\\infty}$ 附近出现数值振荡而对时间步长 $\\Delta t$ 施加的严格条件。量 $\\tau_{\\text{relax}} = (\\Gamma + 2kx_{\\infty})^{-1}$ 是系统弛豫到平衡的特征时间尺度。\n\n问题要求解释一个形式为 $\\Delta t  \\epsilon t_{\\mathrm{rec}}$ 的简化充分条件，其中 $t_{\\mathrm{rec}} = 1/k$。这种形式具有物理动机。$kx^2$ 项代表复合，该过程的特征时间尺度近似为 $x / (kx^2) = 1/(kx)$。对于高度电离的介质（$x \\approx 1$），此时间尺度即为 $1/k = t_{\\mathrm{rec}}$。在许多天体物理场景中，特别是在星系际介质的较稠密区域，复合可能是最快的过程，使得方程组变得“刚性”。对于像前向欧拉这样的显式时间积分格式，要使其在应用于刚性系统时保持稳定和准确，其时间步长必须受到当前存在的最短时间尺度的限制。因此，将时间步长约束为复合时间的一小部分是一种常见且鲁棒的做法：\n$$\n\\Delta t  C \\cdot t_{\\mathrm{rec}}\n$$\n其中 $C$ 是一个无量纲的安全因子，此处表示为 $\\epsilon$（$0  \\epsilon  1$）。尽管形式上推导出的条件依赖于具体状态 $x_{\\infty}$ 和 $\\Gamma$，但判据 $\\Delta t  \\epsilon t_{\\mathrm{rec}}$ 提供了一个实用且保守的上限，通过解析那个通常主导系统刚性的过程的时间尺度来确保数值稳定性。\n\n### 任务B：算法设计\n\n该实现将前向欧拉（显式）和后向欧拉（隐式）方法与几个测试用例的精确解析解进行比较。\n\n**1. 准备工作：**\n对于每个测试用例，我们首先从输入元组 $(\\alpha_{\\mathrm{B}}, n_{\\mathrm{H}}, \\Gamma, x_0, \\epsilon, T_{\\mathrm{factor}}, \\Delta t_{\\mathrm{factor}})$ 计算派生的物理参数。\n- 复合率常数：$k = \\alpha_{\\mathrm{B}} n_{\\mathrm{H}}$\n- 复合时间尺度：$t_{\\mathrm{rec}} = 1/k$\n- 总积分时间：$T = T_{\\mathrm{factor}} t_{\\mathrm{rec}}$\n- 两种方法的时间步长：$\\Delta t = \\Delta t_{\\mathrm{factor}} \\epsilon t_{\\mathrm{rec}}$\n- 时间步长判据检查被评估为：如果 $\\Delta t_{\\mathrm{factor}}  1$，则 $\\mathrm{pass} = 1$，否则为 $0$，因为这等价于 $\\Delta t  \\epsilon t_{\\mathrm{rec}}$。\n\n**2. 精确解：**\n计算最终时间 $T$ 的精确解以供参考。这需要 $k x^2 + \\Gamma x - \\Gamma = 0$ 的根：\n$$\nx_{1,2} = \\frac{-\\Gamma \\pm \\sqrt{\\Gamma^2 + 4\\Gamma k}}{2k}\n$$\n我们确定正根 $x_1 = x_{\\infty}$ 和负根 $x_2$。我们还计算 $\\lambda = \\sqrt{\\Gamma^2 + 4\\Gamma k}$（它等于 $k(x_1-x_2)$）和积分常数 $C = (x_0 - x_1) / (x_0 - x_2)$。那么在时间 $T$ 的精确解是：\n$$\nx_{\\text{exact}}(T) = \\frac{x_1 - C e^{-\\lambda T} x_2}{1 - C e^{-\\lambda T}}\n$$\n\n**3. 时间积分循环：**\n对于两种数值方法，总步数是 $N = \\lceil T / \\Delta t \\rceil$。积分以大小为 $\\Delta t$ 的步长进行 $N-1$ 步，然后进行一个大小为 $\\Delta t_{\\text{final}} = T - (N-1)\\Delta t$ 的较小最终步，以精确到达 $T$。\n\n**4. 前向欧拉方法：**\n从 $x_{\\mathrm{exp}}^0 = x_0$ 开始，我们迭代：\n$$\nx_{\\mathrm{exp}}^{n+1} = x_{\\mathrm{exp}}^n + \\Delta t_n \\left[ (1 - x_{\\mathrm{exp}}^n)\\Gamma - k(x_{\\mathrm{exp}}^n)^2 \\right]\n$$\n其中 $\\Delta t_n$ 是当前步长。在此过程中，我们跟踪超过物理上限 $x=1$ 的最大过冲：$\\mathrm{overshoot}_{\\max} = \\max_{n} \\max(0, x_{\\mathrm{exp}}^n - 1)$。最终误差是 $E_{\\mathrm{exp}} = |x_{\\mathrm{exp}}(T) - x_{\\text{exact}}(T)|$，成本是 $\\mathrm{cost}_{\\mathrm{exp}} = N \\cdot w_{\\mathrm{exp}} = N$。\n\n**5. 后向欧拉方法：**\n从 $x_{\\mathrm{imp}}^0 = x_0$ 开始，每一步都需要从隐式方程中求解 $x^{n+1}$：\n$$\nx^{n+1} = x^n + \\Delta t_n \\left[ (1 - x^{n+1})\\Gamma - k(x^{n+1})^2 \\right]\n$$\n这被重排为一个关于 $y = x^{n+1}$ 的标准二次型 $ay^2 + by + c = 0$：\n$$\n(\\Delta t_n k) y^2 + (1 + \\Delta t_n \\Gamma) y - (x^n + \\Delta t_n \\Gamma) = 0\n$$\n系数为 $a = \\Delta t_n k$，$b = 1 + \\Delta t_n \\Gamma$ 和 $c = -(x^n + \\Delta t_n \\Gamma)$。由于 $ac  0$（对于物理输入），该二次方程有一个正实根和一个负实根。我们选择物理上允许的正根：\n$$\nx_{\\mathrm{imp}}^{n+1} = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a}\n$$\n最终误差是 $E_{\\mathrm{imp}} = |x_{\\mathrm{imp}}(T) - x_{\\text{exact}}(T)|$，成本是 $\\mathrm{cost}_{\\mathrm{imp}} = N \\cdot w_{\\mathrm{imp}} = 4N$。\n\n**6. 输出聚合：**\n对于每个测试用例，六个所需指标 $[\\mathrm{pass}, \\mathrm{overshoot}_{\\max}, E_{\\mathrm{exp}}, E_{\\mathrm{imp}}, \\mathrm{cost}_{\\mathrm{exp}}, \\mathrm{cost}_{\\mathrm{imp}}]$ 被收集到一个列表中。最终输出是包含这五个结果列表的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ionization ODE problem for a suite of test cases, comparing\n    Forward Euler and Backward Euler methods against an exact solution.\n    \"\"\"\n    # Test suite: (alpha_B, n_H, Gamma, x0, epsilon, T_factor, dt_factor)\n    test_cases = [\n        # Case 1: \"happy path\" explicit timestep\n        (2.6e-13, 1.0e-2, 1.0e-15, 0.0, 0.2, 2.0, 0.25),\n        # Case 2: boundary-adjacent explicit timestep\n        (2.6e-13, 1.0e-2, 1.0e-15, 0.0, 0.2, 2.0, 0.95),\n        # Case 3: supercritical explicit timestep\n        (2.6e-13, 1.0e-2, 1.0e-15, 0.0, 0.2, 2.0, 1.2),\n        # Case 4: stiffer density, constrained timestep\n        (2.6e-13, 1.0e-1, 2.0e-14, 0.0, 0.1, 1.0, 0.5),\n        # Case 5: low density, supercritical timestep\n        (2.6e-13, 1.0e-3, 1.0e-16, 0.0, 0.3, 3.0, 1.1),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        alpha_B, n_H, Gamma, x0, epsilon, T_factor, dt_factor = case\n\n        # 1. Calculate derived parameters\n        k = alpha_B * n_H\n        t_rec = 1.0 / k\n        T = T_factor * t_rec\n        dt = dt_factor * epsilon * t_rec\n\n        # 2. Perform boolean criterion check\n        # The condition dt  epsilon * t_rec is equivalent to dt_factor  1\n        passes_criterion = 1 if dt_factor  1.0 else 0\n\n        # 3. Compute exact solution at time T\n        # Roots of k*x^2 + Gamma*x - Gamma = 0\n        sqrt_discriminant = np.sqrt(Gamma**2 + 4 * Gamma * k)\n        x1 = (-Gamma + sqrt_discriminant) / (2 * k)  # Positive root x_inf\n        x2 = (-Gamma - sqrt_discriminant) / (2 * k)  # Negative root\n\n        # Integration constant C\n        # Denominator x0 - x2 is never zero since x0 >= 0 and x2  0\n        if abs(x0 - x2)  1e-15: # handle case where x0 might be extremely close to x2, though unlikely\n            C = 0.0\n        else:\n            C = (x0 - x1) / (x0 - x2)\n        \n        # Exact solution x(T)\n        # The term lambda in the problem is sqrt_discriminant\n        if abs(1 - C * np.exp(-sqrt_discriminant * T))  1e-15:\n             x_exact_T = x1 # Reached equilibrium\n        else:\n            x_exact_T = (x1 - C * np.exp(-sqrt_discriminant * T) * x2) / \\\n                        (1 - C * np.exp(-sqrt_discriminant * T))\n\n        # 4. Perform numerical integrations\n        if T == 0:\n            N_steps = 0\n            timesteps = []\n        else:\n            N_steps = int(np.ceil(T / dt))\n            # The last step is adjusted to end exactly at T\n            timesteps = [dt] * (N_steps - 1)\n            last_step = T - (N_steps - 1) * dt\n            if last_step > 1e-12 * T: # Avoid negligible last step\n                timesteps.append(last_step)\n            else: # If last step is tiny, adjust previous step and reduce N\n                if N_steps > 1:\n                    timesteps[-1] += last_step\n                N_steps = len(timesteps)\n\n\n        # --- Forward Euler ---\n        x_exp = x0\n        max_overshoot = 0.0\n        if N_steps > 0:\n            for step_dt in timesteps:\n                dxdt = (1.0 - x_exp) * Gamma - k * x_exp**2\n                x_exp_new = x_exp + step_dt * dxdt\n                # Track maximum overshoot above physical bound x=1\n                current_overshoot = x_exp_new - 1.0\n                if current_overshoot > max_overshoot:\n                    max_overshoot = current_overshoot\n                x_exp = x_exp_new\n        \n        # Ensure overshoot is non-negative as per definition\n        max_overshoot = max(0.0, max_overshoot)\n        E_exp = abs(x_exp - x_exact_T)\n        cost_exp = N_steps * 1\n\n        # --- Backward Euler ---\n        x_imp = x0\n        if N_steps > 0:\n            for step_dt in timesteps:\n                # Solve quadratic equation for x_imp^{n+1}\n                # (dt*k) y^2 + (1+dt*Gamma) y - (x_imp^n + dt*Gamma) = 0\n                a = step_dt * k\n                b = 1.0 + step_dt * Gamma\n                c = -(x_imp + step_dt * Gamma)\n                # Choose the physically admissible (positive) root\n                x_imp = (-b + np.sqrt(b**2 - 4 * a * c)) / (2 * a)\n\n        E_imp = abs(x_imp - x_exact_T)\n        cost_imp = N_steps * 4\n\n        all_results.append([\n            passes_criterion, max_overshoot, E_exp, E_imp, cost_exp, cost_imp\n        ])\n\n    # Final print statement in the exact required format.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3507618"}, {"introduction": "在单物质例子的基础上，本实践将我们的化学网络扩展到同时包含氢和氦，这对于建立真实的再电离模型至关重要。隐式地求解这个耦合的非线性系统需要像牛顿-拉夫逊方法这样更高级的技术。在本练习中，你将推导该系统的雅可比矩阵，并实现一个利用该矩阵特殊结构的高效求解器，这项技术已被应用于最先进的模拟代码中。[@problem_id:3507586]", "problem": "考虑一个用于再电离的宇宙学辐射流体动力学计算中的均匀、非膨胀单元，其中包含氢和氦。令新时间层级的未知向量为 $\\mathbf{y}^{n+1} = [x_{\\mathrm{HII}}, x_{\\mathrm{HeII}}, x_{\\mathrm{HeIII}}]^\\top$，其中 $x_{\\mathrm{HII}}$ 是电离氢分数，$x_{\\mathrm{HeII}}$ 是单电离氦分数，$x_{\\mathrm{HeIII}}$ 是双电离氦分数。中性分数为 $x_{\\mathrm{HI}} = 1 - x_{\\mathrm{HII}}$ 和 $x_{\\mathrm{HeI}} = 1 - x_{\\mathrm{HeII}} - x_{\\mathrm{HeIII}}$。电子数密度为 $n_e = n_{\\mathrm{H}} x_{\\mathrm{HII}} + n_{\\mathrm{He}} x_{\\mathrm{HeII}} + 2 n_{\\mathrm{He}} x_{\\mathrm{HeIII}}$，其中 $n_{\\mathrm{H}}$ 和 $n_{\\mathrm{He}}$ 分别是氢和氦的数密度，单位为 $\\mathrm{cm}^{-3}$。\n\n电离网络的源项由经过充分检验的光致电离、碰撞电离和复合的反应率控制。将光致电离率表示为 $\\Gamma_{\\mathrm{HI}}$、$\\Gamma_{\\mathrm{HeI}}$ 和 $\\Gamma_{\\mathrm{HeII}}$，单位为 $\\mathrm{s}^{-1}$；将碰撞电离系数表示为 $C_{\\mathrm{HI}}$、$C_{\\mathrm{HeI}}$ 和 $C_{\\mathrm{HeII}}$，单位为 $\\mathrm{cm}^3\\,\\mathrm{s}^{-1}$；将复合系数表示为 $\\alpha_{\\mathrm{HII}}$、$\\alpha_{\\mathrm{HeII}}$ 和 $\\alpha_{\\mathrm{HeIII}}$，单位为 $\\mathrm{cm}^3\\,\\mathrm{s}^{-1}$。基于标准速率定律的反应网络为\n$$\n\\frac{d x_{\\mathrm{HII}}}{dt} = \\left(\\Gamma_{\\mathrm{HI}} + C_{\\mathrm{HI}} n_e\\right) x_{\\mathrm{HI}} - \\alpha_{\\mathrm{HII}} n_e x_{\\mathrm{HII}},\n$$\n$$\n\\frac{d x_{\\mathrm{HeII}}}{dt} = \\left(\\Gamma_{\\mathrm{HeI}} + C_{\\mathrm{HeI}} n_e\\right) x_{\\mathrm{HeI}} - \\left(\\Gamma_{\\mathrm{HeII}} + C_{\\mathrm{HeII}} n_e\\right) x_{\\mathrm{HeII}} - \\alpha_{\\mathrm{HeII}} n_e x_{\\mathrm{HeII}} + \\alpha_{\\mathrm{HeIII}} n_e x_{\\mathrm{HeIII}},\n$$\n$$\n\\frac{d x_{\\mathrm{HeIII}}}{dt} = \\left(\\Gamma_{\\mathrm{HeII}} + C_{\\mathrm{HeII}} n_e\\right) x_{\\mathrm{HeII}} - \\alpha_{\\mathrm{HeIII}} n_e x_{\\mathrm{HeIII}}.\n$$\n\n使用隐式后向欧拉更新，以时间步长 $\\Delta t$（秒）从 $\\mathbf{y}^n$推进到 $\\mathbf{y}^{n+1}$：\n$$\n\\mathbf{y}^{n+1} = \\mathbf{y}^{n} + \\Delta t\\, \\mathbf{R}(\\mathbf{y}^{n+1}),\n$$\n其中 $\\mathbf{R}(\\mathbf{y})$ 是将上述三个右手边速率堆叠而成的向量。定义非线性残差\n$$\n\\mathbf{F}(\\mathbf{y}^{n+1}) = \\mathbf{y}^{n+1} - \\mathbf{y}^{n} - \\Delta t\\, \\mathbf{R}(\\mathbf{y}^{n+1}).\n$$\n您必须推导出雅可比矩阵\n$$\n\\mathbf{J}(\\mathbf{y}^{n+1}) = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{y}^{n+1}} = \\mathbf{I} - \\Delta t\\, \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{y}^{n+1}},\n$$\n明确地用变量、参数和电子密度耦合来表示。展示如何将 $\\mathbf{J}$ 分解为一个基质 $\\mathbf{B}$（通过将 $n_e$ 视为常数计算）和一个源于 $n_e$ 对 $\\mathbf{y}^{n+1}$ 线性依赖的秩一外积更新之和，并解释这种结构如何通过 Sherman–Morrison 公式实现高效的牛顿-拉夫逊迭代。所有推导都必须从上述基本原理出发，避免使用简便公式。\n\n实现一个程序，该程序：\n- 构建 $\\mathbf{F}$ 和解析的 $\\mathbf{J}$，包括分解 $\\mathbf{J} = \\mathbf{B} + \\mathbf{u}\\mathbf{v}^\\top$，并明确定义 $\\mathbf{B}$、$\\mathbf{u}$ 和 $\\mathbf{v}$，然后使用牛顿-拉夫逊迭代求解 $\\mathbf{y}^{n+1}$。\n- 利用 Sherman-Morrison 公式利用其秩一结构，将 $\\mathbf{J}^{-1}$ 应用于一个向量，而无需显式构造 $\\mathbf{J}^{-1}$，并验证结构化步骤与稠密直接求解在数值容差范围内匹配。\n- 使用简单的步长阻尼将物种分数保持在区间 $[0,1]$ 内，必要时减小更新步长。\n\n在所有情况下，密度和速率使用 cgs 单位，时间使用秒。将最终程序输出表示为整数，代表每个测试用例达到残差无穷范数低于 $10^{-12}$ 容差所需的牛顿-拉夫逊迭代次数，以单个 Python 列表的形式在一行上打印。\n\n测试套件：\n提供四个情况的参数，以评估典型行为、刚性动力学和边缘条件。每个情况指定 $(n_{\\mathrm{H}}, n_{\\mathrm{He}}, \\Gamma_{\\mathrm{HI}}, \\Gamma_{\\mathrm{HeI}}, \\Gamma_{\\mathrm{HeII}}, C_{\\mathrm{HI}}, C_{\\mathrm{HeI}}, C_{\\mathrm{HeII}}, \\alpha_{\\mathrm{HII}}, \\alpha_{\\mathrm{HeII}}, \\alpha_{\\mathrm{HeIII}}, \\Delta t, \\mathbf{y}^n)$。\n\n- 情况1（典型的再电离单元）：\n  - $n_{\\mathrm{H}} = 2\\times 10^{-4}\\ \\mathrm{cm}^{-3}$，$n_{\\mathrm{He}} = 1.66\\times 10^{-5}\\ \\mathrm{cm}^{-3}$（氦数分数为氢的 $0.083$）。\n  - $\\Gamma_{\\mathrm{HI}} = 1\\times 10^{-12}\\ \\mathrm{s}^{-1}$，$\\Gamma_{\\mathrm{HeI}} = 1\\times 10^{-13}\\ \\mathrm{s}^{-1}$，$\\Gamma_{\\mathrm{HeII}} = 5\\times 10^{-14}\\ \\mathrm{s}^{-1}$。\n  - $C_{\\mathrm{HI}} = 5\\times 10^{-11}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$C_{\\mathrm{HeI}} = 1\\times 10^{-11}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$C_{\\mathrm{HeII}} = 8\\times 10^{-12}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$。\n  - $\\alpha_{\\mathrm{HII}} = 2.6\\times 10^{-13}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$\\alpha_{\\mathrm{HeII}} = 1.5\\times 10^{-12}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$\\alpha_{\\mathrm{HeIII}} = 3.0\\times 10^{-12}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$。\n  - $\\Delta t = 1\\times 10^{13}\\ \\mathrm{s}$。\n  - $\\mathbf{y}^{n} = [0.1, 0.05, 0.0]^\\top$。\n\n- 情况2（短步长，强源，较高密度）：\n  - $n_{\\mathrm{H}} = 1\\times 10^{-3}\\ \\mathrm{cm}^{-3}$，$n_{\\mathrm{He}} = 8.3\\times 10^{-5}\\ \\mathrm{cm}^{-3}$。\n  - $\\Gamma_{\\mathrm{HI}} = 5\\times 10^{-12}\\ \\mathrm{s}^{-1}$，$\\Gamma_{\\mathrm{HeI}} = 2\\times 10^{-12}\\ \\mathrm{s}^{-1}$，$\\Gamma_{\\mathrm{HeII}} = 1\\times 10^{-12}\\ \\mathrm{s}^{-1}$。\n  - $C_{\\mathrm{HI}} = 5\\times 10^{-11}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$C_{\\mathrm{HeI}} = 1\\times 10^{-11}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$C_{\\mathrm{HeII}} = 8\\times 10^{-12}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$。\n  - $\\alpha_{\\mathrm{HII}} = 2.6\\times 10^{-13}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$\\alpha_{\\mathrm{HeII}} = 1.5\\times 10^{-12}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$\\alpha_{\\mathrm{HeIII}} = 3.0\\times 10^{-12}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$。\n  - $\\Delta t = 1\\times 10^{10}\\ \\mathrm{s}$。\n  - $\\mathbf{y}^{n} = [0.0, 0.0, 0.0]^\\top$。\n\n- 情况3（非常刚性的步长，中等源）：\n  - $n_{\\mathrm{H}} = 1\\times 10^{-4}\\ \\mathrm{cm}^{-3}$，$n_{\\mathrm{He}} = 8.3\\times 10^{-6}\\ \\mathrm{cm}^{-3}$。\n  - $\\Gamma_{\\mathrm{HI}} = 1\\times 10^{-12}\\ \\mathrm{s}^{-1}$，$\\Gamma_{\\mathrm{HeI}} = 1\\times 10^{-13}\\ \\mathrm{s}^{-1}$，$\\Gamma_{\\mathrm{HeII}} = 5\\times 10^{-14}\\ \\mathrm{s}^{-1}$。\n  - $C_{\\mathrm{HI}} = 5\\times 10^{-11}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$C_{\\mathrm{HeI}} = 1\\times 10^{-11}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$C_{\\mathrm{HeII}} = 8\\times 10^{-12}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$。\n  - $\\alpha_{\\mathrm{HII}} = 2.6\\times 10^{-13}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$\\alpha_{\\mathrm{HeII}} = 1.5\\times 10^{-12}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$\\alpha_{\\mathrm{HeIII}} = 3.0\\times 10^{-12}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$。\n  - $\\Delta t = 1\\times 10^{15}\\ \\mathrm{s}$。\n  - $\\mathbf{y}^{n} = [0.0, 0.2, 0.1]^\\top$。\n\n- 情况4（极低密度，混合电离态）：\n  - $n_{\\mathrm{H}} = 1\\times 10^{-6}\\ \\mathrm{cm}^{-3}$，$n_{\\mathrm{He}} = 8.3\\times 10^{-8}\\ \\mathrm{cm}^{-3}$。\n  - $\\Gamma_{\\mathrm{HI}} = 5\\times 10^{-13}\\ \\mathrm{s}^{-1}$，$\\Gamma_{\\mathrm{HeI}} = 5\\times 10^{-14}\\ \\mathrm{s}^{-1}$，$\\Gamma_{\\mathrm{HeII}} = 1\\times 10^{-14}\\ \\mathrm{s}^{-1}$。\n  - $C_{\\mathrm{HI}} = 5\\times 10^{-11}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$C_{\\mathrm{HeI}} = 1\\times 10^{-11}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$C_{\\mathrm{HeII}} = 8\\times 10^{-12}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$。\n  - $\\alpha_{\\mathrm{HII}} = 2.6\\times 10^{-13}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$\\alpha_{\\mathrm{HeII}} = 1.5\\times 10^{-12}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$，$\\alpha_{\\mathrm{HeIII}} = 3.0\\times 10^{-12}\\ \\mathrm{cm}^3\\,\\mathrm{s}^{-1}$。\n  - $\\Delta t = 1\\times 10^{13}\\ \\mathrm{s}$。\n  - $\\mathbf{y}^{n} = [0.9, 0.5, 0.4]^\\top$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含情况1到4的牛顿-拉夫逊迭代次数，形式为逗号分隔的列表并用方括号括起来（例如，$\\texttt{[3,5,7,4]}$）。这些整数必须按照上述情况的指定顺序排列。所有中间计算必须使用$\\mathrm{cm}^{-3}$作为密度单位，$\\mathrm{s}^{-1}$作为速率单位，秒作为时间单位。收敛容差为$\\mathbf{F}(\\mathbf{y}^{n+1})$的无穷范数小于$10^{-12}$。", "solution": "该问题要求推导并实现一个牛顿-拉夫逊求解器，用于求解描述氢和氦电离状态的耦合常微分方程组。求解器必须使用隐式后向欧拉时间积分方案，并通过 Sherman-Morrison 公式利用系统雅可比矩阵的特定结构以提高计算效率。\n\n令电离分数的状态向量为 $\\mathbf{y} = [x_{\\mathrm{HII}}, x_{\\mathrm{HeII}}, x_{\\mathrm{HeIII}}]^\\top \\equiv [y_1, y_2, y_3]^\\top$。该向量的时间演化由 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{R}(\\mathbf{y})$ 给出，其中 $\\mathbf{R}(\\mathbf{y}) = [R_1(\\mathbf{y}), R_2(\\mathbf{y}), R_3(\\mathbf{y})]^\\top$ 是反应速率向量。\n\n应用后向欧拉方法，使用时间步长 $\\Delta t$ 从时间层级 $n$ 推进到 $n+1$，我们得到非线性方程组：\n$$\n\\mathbf{y}^{n+1} = \\mathbf{y}^{n} + \\Delta t\\, \\mathbf{R}(\\mathbf{y}^{n+1})\n$$\n为了求解 $\\mathbf{y}^{n+1}$，我们定义一个残差函数 $\\mathbf{F}(\\mathbf{y})$，并寻求其根。为简化起见，我们省略未知数 $\\mathbf{y}$ 的上标 $n+1$：\n$$\n\\mathbf{F}(\\mathbf{y}) = \\mathbf{y} - \\mathbf{y}^{n} - \\Delta t\\, \\mathbf{R}(\\mathbf{y}) = \\mathbf{0}\n$$\n该系统使用牛顿-拉夫逊方法求解。从初始猜测 $\\mathbf{y}_0 = \\mathbf{y}^n$ 开始，我们通过以下更新规则迭代地改进解：\n$$\n\\mathbf{y}_{k+1} = \\mathbf{y}_{k} + \\delta\\mathbf{y}_k\n$$\n其中更新步长 $\\delta\\mathbf{y}_k$ 是线性系统的解：\n$$\n\\mathbf{J}(\\mathbf{y}_k) \\delta\\mathbf{y}_k = -\\mathbf{F}(\\mathbf{y}_k)\n$$\n这里，$\\mathbf{J}(\\mathbf{y}_k)$ 是残差函数 $\\mathbf{F}$ 在当前迭代值 $\\mathbf{y}_k$ 处的雅可比矩阵。\n\n第一步是推导雅可比矩阵 $\\mathbf{J}(\\mathbf{y})$ 的解析形式。\n$$\n\\mathbf{J}(\\mathbf{y}) = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{y}} = \\frac{\\partial}{\\partial \\mathbf{y}} \\left( \\mathbf{y} - \\mathbf{y}^{n} - \\Delta t\\, \\mathbf{R}(\\mathbf{y}) \\right) = \\mathbf{I} - \\Delta t \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{y}}\n$$\n其中 $\\mathbf{I}$ 是 $3 \\times 3$ 的单位矩阵。核心任务是计算速率向量的雅可比矩阵 $\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{y}}$。\n\n速率 $R_i$ 既直接依赖于 $\\mathbf{y}$ 的分量，也通过电子数密度 $n_e = n_{\\mathrm{H}} y_1 + n_{\\mathrm{He}} y_2 + 2 n_{\\mathrm{He}} y_3$ 间接依赖于 $\\mathbf{y}$ 的分量。我们必须应用多元链式法则。速率 $R_i$ 对变量 $y_j$ 的全导数为：\n$$\n\\frac{\\partial R_i}{\\partial y_j} = \\left(\\frac{\\partial R_i}{\\partial y_j}\\right)_{n_e} + \\frac{\\partial R_i}{\\partial n_e} \\frac{\\partial n_e}{\\partial y_j}\n$$\n第一项是保持 $n_e$ 恒定时的偏导数，第二项解释了通过 $n_e$ 的耦合。在矩阵形式中，这可以写成一个外积：\n$$\n\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{y}} = \\mathbf{A} + \\mathbf{c} \\mathbf{d}^\\top\n$$\n其中矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{c}$、$\\mathbf{d}$ 定义如下：\n- $\\mathbf{A}_{ij} = \\left(\\frac{\\partial R_i}{\\partial y_j}\\right)_{n_e}$：将 $n_e$ 视为常数时 $\\mathbf{R}$ 的雅可比矩阵。\n- $\\mathbf{c} = \\frac{\\partial \\mathbf{R}}{\\partial n_e}$：速率对 $n_e$ 的导数向量。\n- $\\mathbf{d} = \\frac{\\partial n_e}{\\partial \\mathbf{y}}$：$n_e$ 对 $\\mathbf{y}$ 的导数向量。\n\n让我们明确地推导每个分量。\n中性分数为 $x_{\\mathrm{HI}} = 1 - y_1$ 和 $x_{\\mathrm{HeI}} = 1 - y_2 - y_3$。速率方程为：\n$R_1 = (\\Gamma_{\\mathrm{HI}} + C_{\\mathrm{HI}} n_e)(1-y_1) - \\alpha_{\\mathrm{HII}} n_e y_1$\n$R_2 = (\\Gamma_{\\mathrm{HeI}} + C_{\\mathrm{HeI}} n_e)(1-y_2-y_3) - (\\Gamma_{\\mathrm{HeII}} + C_{\\mathrm{HeII}} n_e)y_2 - \\alpha_{\\mathrm{HeII}} n_e y_2 + \\alpha_{\\mathrm{HeIII}} n_e y_3$\n$R_3 = (\\Gamma_{\\mathrm{HeII}} + C_{\\mathrm{HeII}} n_e)y_2 - \\alpha_{\\mathrm{HeIII}} n_e y_3$\n\n首先，向量 $\\mathbf{d}$：\n$$\n\\mathbf{d} = \\begin{bmatrix} \\partial n_e / \\partial y_1 \\\\ \\partial n_e / \\partial y_2 \\\\ \\partial n_e / \\partial y_3 \\end{bmatrix} = \\begin{bmatrix} n_{\\mathrm{H}} \\\\ n_{\\mathrm{He}} \\\\ 2 n_{\\mathrm{He}} \\end{bmatrix}\n$$\n其次，向量 $\\mathbf{c}$：\n$$\n\\mathbf{c} = \\begin{bmatrix} \\partial R_1 / \\partial n_e \\\\ \\partial R_2 / \\partial n_e \\\\ \\partial R_3 / \\partial n_e \\end{bmatrix} = \\begin{bmatrix} C_{\\mathrm{HI}}(1-y_1) - \\alpha_{\\mathrm{HII}} y_1 \\\\ C_{\\mathrm{HeI}}(1-y_2-y_3) - (C_{\\mathrm{HeII}} + \\alpha_{\\mathrm{HeII}})y_2 + \\alpha_{\\mathrm{HeIII}} y_3 \\\\ C_{\\mathrm{HeII}} y_2 - \\alpha_{\\mathrm{HeIII}} y_3 \\end{bmatrix}\n$$\n第三，矩阵 $\\mathbf{A}$：\n$A_{11} = \\frac{\\partial R_1}{\\partial y_1} = -(\\Gamma_{\\mathrm{HI}} + C_{\\mathrm{HI}} n_e) - \\alpha_{\\mathrm{HII}} n_e$\n$A_{12} = \\frac{\\partial R_1}{\\partial y_2} = 0$\n$A_{13} = \\frac{\\partial R_1}{\\partial y_3} = 0$\n\n$A_{21} = \\frac{\\partial R_2}{\\partial y_1} = 0$\n$A_{22} = \\frac{\\partial R_2}{\\partial y_2} = -(\\Gamma_{\\mathrm{HeI}} + C_{\\mathrm{HeI}} n_e) - (\\Gamma_{\\mathrm{HeII}} + C_{\\mathrm{HeII}} n_e) - \\alpha_{\\mathrm{HeII}} n_e$\n$A_{23} = \\frac{\\partial R_2}{\\partial y_3} = -(\\Gamma_{\\mathrm{HeI}} + C_{\\mathrm{HeI}} n_e) + \\alpha_{\\mathrm{HeIII}} n_e$\n\n$A_{31} = \\frac{\\partial R_3}{\\partial y_1} = 0$\n$A_{32} = \\frac{\\partial R_3}{\\partial y_2} = \\Gamma_{\\mathrm{HeII}} + C_{\\mathrm{HeII}} n_e$\n$A_{33} = \\frac{\\partial R_3}{\\partial y_3} = -\\alpha_{\\mathrm{HeIII}} n_e$\n矩阵 $\\mathbf{A}$ 是下三角矩阵。\n\n现在，我们组装完整的雅可比矩阵 $\\mathbf{J}$：\n$$\n\\mathbf{J} = \\mathbf{I} - \\Delta t \\left( \\mathbf{A} + \\mathbf{c} \\mathbf{d}^\\top \\right) = (\\mathbf{I} - \\Delta t \\mathbf{A}) - \\Delta t (\\mathbf{c} \\mathbf{d}^\\top)\n$$\n其形式为 $\\mathbf{J} = \\mathbf{B} + \\mathbf{u} \\mathbf{v}^\\top$，其中：\n- $\\mathbf{B} = \\mathbf{I} - \\Delta t \\mathbf{A}$\n- $\\mathbf{u} = -\\Delta t \\mathbf{c}$\n- $\\mathbf{v} = \\mathbf{d}$\n\n矩阵 $\\mathbf{B}$ 是单位矩阵与一个下三角矩阵 $\\mathbf{A}$ 的倍数之和，因此 $\\mathbf{B}$ 也是下三角矩阵。这种结构是实现高效求解的关键。牛顿步骤需要求解 $\\mathbf{J} \\delta\\mathbf{y} = -\\mathbf{F}$，这意味着我们需要计算 $\\mathbf{J}^{-1}(-\\mathbf{F})$。对稠密矩阵 $\\mathbf{J}$ 进行直接求逆或 LU 分解的成本为 $O(N^3)$ 操作，其中 $N=3$。\n\n通过使用 Sherman-Morrison 公式计算秩一更新矩阵的逆：\n$$\n(\\mathbf{B} + \\mathbf{u}\\mathbf{v}^\\top)^{-1} = \\mathbf{B}^{-1} - \\frac{\\mathbf{B}^{-1}\\mathbf{u}\\mathbf{v}^\\top\\mathbf{B}^{-1}}{1 + \\mathbf{v}^\\top\\mathbf{B}^{-1}\\mathbf{u}}\n$$\n我们可以更有效地求解该线性系统。计算 $\\delta\\mathbf{y} = (\\mathbf{B} + \\mathbf{u}\\mathbf{v}^\\top)^{-1}(-\\mathbf{F})$ 的步骤如下：\n1.  定义右手边向量 $\\mathbf{b} = -\\mathbf{F}$。\n2.  求解线性系统 $\\mathbf{B}\\mathbf{z} = \\mathbf{b}$ 以得到 $\\mathbf{z}$。由于 $\\mathbf{B}$ 是下三角矩阵，这是一个 $O(N^2)$ 的操作（前向替换）。这里，$\\mathbf{z} = \\mathbf{B}^{-1}\\mathbf{b}$。\n3.  求解线性系统 $\\mathbf{B}\\mathbf{w} = \\mathbf{u}$ 以得到 $\\mathbf{w}$。这也是一个 $O(N^2)$ 的操作。这里，$\\mathbf{w} = \\mathbf{B}^{-1}\\mathbf{u}$。\n4.  使用前几步的结果计算牛顿步长 $\\delta\\mathbf{y}$：\n$$\n\\delta\\mathbf{y} = \\mathbf{z} - \\left( \\frac{\\mathbf{v}^\\top \\mathbf{z}}{1 + \\mathbf{v}^\\top \\mathbf{w}} \\right) \\mathbf{w}\n$$\n整个过程涉及两次三角求解和向量运算，总成本为 $O(N^2)$，这比稠密矩阵求解的 $O(N^3)$ 成本更高效。\n\n最后，迭代过程必须确保更新后的物种分数保持物理有效性（即在区间 $[0,1]$ 内，并满足 $x_{\\mathrm{HeII}} + x_{\\mathrm{HeIII}} \\le 1$）。这通过在更新步骤中引入一个阻尼因子 $\\lambda \\in (0, 1]$ 来实现：$\\mathbf{y}_{k+1} = \\mathbf{y}_{k} + \\lambda \\delta\\mathbf{y}_k$。如果 $\\lambda=1$ 的更新违反了物理约束，则将 $\\lambda$ 连续减半，直到新状态 $\\mathbf{y}_{k+1}$ 有效。迭代将持续进行，直到残差的无穷范数 $||\\mathbf{F}(\\mathbf{y}_{k+1})||_\\infty$ 降至指定的容差 $10^{-12}$ 以下。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main driver function to run the test suite and print results.\n    \"\"\"\n    # Tolerance for Newton-Raphson convergence\n    TOL = 1e-12\n    # Maximum iterations to prevent infinite loops\n    MAX_ITER = 30\n\n    test_cases = [\n        # Case 1 (typical reionization cell)\n        {\n            'params': (2e-4, 1.66e-5, 1e-12, 1e-13, 5e-14, 5e-11, 1e-11, 8e-12, 2.6e-13, 1.5e-12, 3.0e-12, 1e13),\n            'y0': np.array([0.1, 0.05, 0.0])\n        },\n        # Case 2 (short step, strong source, higher density)\n        {\n            'params': (1e-3, 8.3e-5, 5e-12, 2e-12, 1e-12, 5e-11, 1e-11, 8e-12, 2.6e-13, 1.5e-12, 3.0e-12, 1e10),\n            'y0': np.array([0.0, 0.0, 0.0])\n        },\n        # Case 3 (very stiff step, moderate source)\n        {\n            'params': (1e-4, 8.3e-6, 1e-12, 1e-13, 5e-14, 5e-11, 1e-11, 8e-12, 2.6e-13, 1.5e-12, 3.0e-12, 1e15),\n            'y0': np.array([0.0, 0.2, 0.1])\n        },\n        # Case 4 (very low density, mixed ionization state)\n        {\n            'params': (1e-6, 8.3e-8, 5e-13, 5e-14, 1e-14, 5e-11, 1e-11, 8e-12, 2.6e-13, 1.5e-12, 3.0e-12, 1e13),\n            'y0': np.array([0.9, 0.5, 0.4])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        iter_count = solve_case(case['params'], case['y0'], TOL, MAX_ITER)\n        results.append(iter_count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_case(params, y_n, tol, max_iter):\n    \"\"\"\n    Solves the nonlinear system for one test case using Newton-Raphson.\n\n    Args:\n        params (tuple): Physical parameters of the system.\n        y_n (np.array): Initial state vector y^n.\n        tol (float): Convergence tolerance for the residual norm.\n        max_iter (int): Maximum number of iterations.\n\n    Returns:\n        int: The number of iterations required for convergence.\n    \"\"\"\n    n_H, n_He, G_HI, G_HeI, G_HeII, C_HI, C_HeI, C_HeII, a_HII, a_HeII, a_HeIII, dt = params\n    \n    # Current iterate for y^(n+1), initialized with y^n\n    y = y_n.copy()\n\n    for k in range(max_iter):\n        y1, y2, y3 = y[0], y[1], y[2]\n\n        # Ensure fractions are physically plausible for rate calculations\n        x_HII = np.clip(y1, 0.0, 1.0)\n        x_HeII = np.clip(y2, 0.0, 1.0)\n        x_HeIII = np.clip(y3, 0.0, 1.0)\n        \n        # Ensure sum of helium fractions doesn't exceed 1\n        if x_HeII + x_HeIII > 1.0:\n            scale = 1.0 / (x_HeII + x_HeIII)\n            x_HeII *= scale\n            x_HeIII *= scale\n\n        x_HI = 1.0 - x_HII\n        x_HeI = 1.0 - x_HeII - x_HeIII\n\n        # Electron density\n        n_e = n_H * x_HII + n_He * (x_HeII + 2.0 * x_HeIII)\n\n        # Rate vector R(y)\n        R = np.zeros(3)\n        R[0] = (G_HI + C_HI * n_e) * x_HI - a_HII * n_e * x_HII\n        R[1] = (G_HeI + C_HeI * n_e) * x_HeI \\\n             - (G_HeII + C_HeII * n_e) * x_HeII \\\n             - a_HeII * n_e * x_HeII \\\n             + a_HeIII * n_e * x_HeIII\n        R[2] = (G_HeII + C_HeII * n_e) * x_HeII - a_HeIII * n_e * x_HeIII\n\n        # Residual vector F(y)\n        F = y - y_n - dt * R\n        \n        # Check for convergence\n        if np.linalg.norm(F, np.inf)  tol:\n            return k\n\n        # --- Jacobian Construction ---\n        # Vector d = d(n_e)/dy\n        d = np.array([n_H, n_He, 2.0 * n_He])\n\n        # Vector c = dR/d(n_e)\n        c = np.zeros(3)\n        c[0] = C_HI * x_HI - a_HII * x_HII\n        c[1] = C_HeI * x_HeI - (C_HeII + a_HeII) * x_HeII + a_HeIII * x_HeIII\n        c[2] = C_HeII * x_HeII - a_HeIII * x_HeIII\n\n        # Matrix A = (dR/dy)_ne\n        A = np.zeros((3, 3))\n        A[0, 0] = -(G_HI + C_HI * n_e) - a_HII * n_e\n        A[1, 1] = -(G_HeI + C_HeI * n_e) - (G_HeII + C_HeII * n_e) - a_HeII * n_e\n        A[1, 2] = -(G_HeI + C_HeI * n_e) + a_HeIII * n_e\n        A[2, 1] = G_HeII + C_HeII * n_e\n        A[2, 2] = -a_HeIII * n_e\n\n        # --- Sherman-Morrison Components ---\n        # B = I - dt * A (lower triangular)\n        B = np.identity(3) - dt * A\n        # u = -dt * c\n        u = -dt * c\n        # v = d\n        v = d\n\n        # --- Newton Step Calculation ---\n        # Structured solve using Sherman-Morrison\n        b_rhs = -F\n        z = np.linalg.solve(B, b_rhs)\n        w = np.linalg.solve(B, u)\n        \n        scalar_num = np.dot(v, z)\n        scalar_den = 1.0 + np.dot(v, w)\n        \n        delta_y = z - (scalar_num / scalar_den) * w\n\n        # Verification against dense solve\n        J = B + np.outer(u, v)\n        delta_y_direct = np.linalg.solve(J, -F)\n        assert np.allclose(delta_y, delta_y_direct, rtol=1e-12, atol=1e-12)\n\n        # --- Step Damping ---\n        damping = 1.0\n        while True:\n            y_new = y + damping * delta_y\n            \n            # Physical constraints\n            is_physical = (\n                0.0 = y_new[0] = 1.0 and\n                y_new[1] >= 0.0 and\n                y_new[2] >= 0.0 and\n                y_new[1] + y_new[2] = 1.0\n            )\n\n            if is_physical:\n                y = y_new\n                break\n            \n            damping *= 0.5\n            if damping  1e-8: # Failsafe\n                # In case of stall, accept the clipped state and hope for recovery\n                y = np.clip(y_new, 0.0, 1.0)\n                if y[1] + y[2] > 1.0:\n                    y[1:] /= (y[1] + y[2])\n                break\n    \n    # Return max_iter if convergence is not reached\n    return max_iter\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3507586"}, {"introduction": "掌握了单个单元内的化学求解器后，我们现在转向辐射在空间中的传输问题。本实践探讨了辐射转移方程的不同近似方法如何处理复杂情况，例如由稠密气体团块投下的阴影。通过在一个受控测试中，将高精度的光线追踪方法与计算成本较低的矩方法（如 M1 和 OTVET）进行比较，你将对它们在各向异性辐射场中的优势和局限性获得实际的理解。[@problem_id:3507616]", "problem": "您的任务是，在一个与宇宙学再电离的辐射流体力学相关的简化各向异性双源遮蔽测试中，实现并比较三种近似辐射转移闭包。目标是仅使用第一性原理和经过充分检验的公式，计算角各向异性度量并量化不同方法之间的偏差。\n\n此任务的基本依据如下。\n\n- 考虑真空中的稳态、各向同性电离辐射点源。对于位于 $\\mathbf{x}_s$ 位置、热辐射光度为 $L$ 的单个点源，在没有吸收的情况下，根据球体上的能量守恒，半径 $r$ 处的能通量大小为 $L/(4\\pi r^2)$。在自由流（free streaming）条件下，辐射能量密度 $E$ 与通量 $\\mathbf{F}$ 的关系为 $\\mathbf{F} = c E \\hat{\\mathbf{n}}$，其中 $c$ 是光速，$\\hat{\\mathbf{n}}$ 是从源指向场点的单位向量。因此，对于一个位于 $\\mathbf{x}$、满足 $r = \\|\\mathbf{x}-\\mathbf{x}_s\\|$ 的场点，有\n$$\nE_s(\\mathbf{x}) = \\frac{L}{4\\pi c\\, r^2}, \\quad \\mathbf{F}_s(\\mathbf{x}) = c\\,E_s(\\mathbf{x})\\,\\frac{\\mathbf{x}-\\mathbf{x}_s}{\\|\\mathbf{x}-\\mathbf{x}_s\\|}.\n$$\n- 对于真空中的多个独立源，适用叠加原理：$E(\\mathbf{x}) = \\sum_s E_s(\\mathbf{x})$ 和 $\\mathbf{F}(\\mathbf{x}) = \\sum_s \\mathbf{F}_s(\\mathbf{x})$，前提是从每个源到 $\\mathbf{x}$ 的视线没有不透明障碍物。\n- 引入一个半径为 $R$、中心在 $\\mathbf{x}_c$ 的不透明圆形吸收体（一个致密的中性团块），它完全阻挡任何从源到场点的直线段与该圆盘相交的光线。在这种情况下，相应源在该视线方向上的贡献被设为零。\n\n将某一点的角各向异性度量（约化通量）定义为\n$$\nA(\\mathbf{x}) \\equiv \\frac{\\|\\mathbf{F}(\\mathbf{x})\\|}{c\\,E(\\mathbf{x})},\n$$\n根据构造，该度量必须满足 $0 \\le A \\le 1$。注意，$E_s$ 中的任何全局常数都会在该比率中被抵消。\n\n您必须比较三种估算 $A(\\mathbf{x})$ 的方法。\n\n1. 长特征线 (LC) 射线追踪：独立处理每个源，应用障碍物的精确直线遮挡，并进行叠加。这得到\n$$\nE_{\\mathrm{LC}}(\\mathbf{x}) = \\sum_{s \\in \\mathcal{V}(\\mathbf{x})} \\frac{L_s}{4\\pi c\\, r_s^2}, \\quad \\mathbf{F}_{\\mathrm{LC}}(\\mathbf{x}) = \\sum_{s \\in \\mathcal{V}(\\mathbf{x})} c\\,\\frac{L_s}{4\\pi c\\, r_s^2}\\,\\hat{\\mathbf{n}}_s,\n$$\n其中 $\\mathcal{V}(\\mathbf{x})$ 是到 $\\mathbf{x}$ 的视线未被阻挡的源的集合，$r_s = \\|\\mathbf{x}-\\mathbf{x}_s\\|$, $\\hat{\\mathbf{n}}_s = (\\mathbf{x}-\\mathbf{x}_s)/r_s$。然后\n$$\nA_{\\mathrm{LC}}(\\mathbf{x}) = \\frac{\\left\\|\\sum_{s \\in \\mathcal{V}(\\mathbf{x})} \\frac{L_s}{r_s^2}\\,\\hat{\\mathbf{n}}_s\\right\\|}{\\sum_{s \\in \\mathcal{V}(\\mathbf{x})} \\frac{L_s}{r_s^2}}.\n$$\n\n2. M1 矩闭包 (M1)：在稳态自由流区域，局部辐射矩满足 $\\mathbf{F}=cE\\,\\mathbf{f}$，其约化通量 $\\mathbf{f}$ 等于归一化通量矢量。对于无相互作用光束的局部混合，M1 约化通量是方向贡献的归一化叠加。在当前这个不求解演化方程的静态测试中，对于相同的遮挡集合，这给出了与 LC 相同的代数约化通量：\n$$\nA_{\\mathrm{M1}}(\\mathbf{x}) = \\frac{\\left\\|\\sum_{s \\in \\mathcal{V}(\\mathbf{x})} \\frac{L_s}{r_s^2}\\,\\hat{\\mathbf{n}}_s\\right\\|}{\\sum_{s \\in \\mathcal{V}(\\mathbf{x})} \\frac{L_s}{r_s^2}}.\n$$\n\n3. 光学薄可变爱丁顿张量 (OTVET)：爱丁顿张量以及由此产生的角结构是根据忽略吸收和遮挡的光学薄场构造的。在这个静态比较中，将 OTVET 预测的方向视为所有源方向的光学薄加权平均，权重与 $E_s^{\\mathrm{thin}} \\propto L_s/r_s^2$ 成正比（包含所有源）。如果真实的局部能量密度是 $E_{\\mathrm{LC}}(\\mathbf{x})$，一个与 OTVET 一致的各向异性估计是\n$$\nA_{\\mathrm{OTVET}}(\\mathbf{x}) = \\left\\|\\sum_{s} w_s(\\mathbf{x})\\,\\hat{\\mathbf{n}}_s\\right\\|,\\quad w_s(\\mathbf{x}) = \\frac{\\frac{L_s}{r_s^2}}{\\sum_{s'} \\frac{L_{s'}}{r_{s'}^2}},\n$$\n其中 $A_{\\mathrm{OTVET}}$ 中的求和遍历所有源，无论是否被遮挡。\n\n实现一个程序，对于固定的双源、单障碍物几何结构，在几个指定的场点上为每种方法评估 $A$，并报告与 LC 参考值的偏差。\n\n几何结构与参数：\n\n- 两个光度为 $L_1=L_2=1$ 的相同源，分别位于 $\\mathbf{x}_1 = (-2,0)$ 和 $\\mathbf{x}_2 = (2,0)$。\n- 一个不透明圆形障碍物，中心位于 $\\mathbf{x}_c=(0,0)$，半径为 $R=0.5$。\n- 四个场点：\n  - 测试用例 1：$\\mathbf{x}^{(1)} = (-1,\\,0.2)$。\n  - 测试用例 2：$\\mathbf{x}^{(2)} = (0,\\,1)$。\n  - 测试用例 3：$\\mathbf{x}^{(3)} = (0.6,\\,0)$。\n  - 测试用例 4：$\\mathbf{x}^{(4)} = (0,\\,0.6)$。\n\n对于每个测试用例 $i \\in \\{1,2,3,4\\}$，计算：\n- 使用精确的直线段与圆相交判断遮挡来计算 $A_{\\mathrm{LC}}(\\mathbf{x}^{(i)})$，\n- 使用与 LC 相同的可见源集合来计算 $A_{\\mathrm{M1}}(\\mathbf{x}^{(i)})$，\n- 使用所有源（不考虑遮挡）来计算 $A_{\\mathrm{OTVET}}(\\mathbf{x}^{(i)})$，\n以及绝对偏差\n$$\n\\Delta_{\\mathrm{M1}}^{(i)} = \\left|A_{\\mathrm{M1}}(\\mathbf{x}^{(i)}) - A_{\\mathrm{LC}}(\\mathbf{x}^{(i)})\\right|,\\quad\n\\Delta_{\\mathrm{OTVET}}^{(i)} = \\left|A_{\\mathrm{OTVET}}(\\mathbf{x}^{(i)}) - A_{\\mathrm{LC}}(\\mathbf{x}^{(i)})\\right|.\n$$\n\n所有结果都是无量纲的；输出中不需要物理单位。在内部需要进行矢量归一化时，角度应以弧度处理，但不要打印任何角度值。\n\n输出规范：\n\n- 您的程序必须生成单行输出，包含一个含四个子列表的列表，每个子列表对应一个测试用例 $i=1,2,3,4$。\n- 每个子列表必须按以下顺序包含五个保留小数点后六位的小数：$[A_{\\mathrm{LC}}, A_{\\mathrm{M1}}, A_{\\mathrm{OTVET}}, \\Delta_{\\mathrm{M1}}, \\Delta_{\\mathrm{OTVET}}]$。\n- 最终输出必须是严格符合\n$$\n\\left[\\,[a_{11},a_{12},a_{13},a_{14},a_{15}],\\,[a_{21},a_{22},a_{23},a_{24},a_{25}],\\,[a_{31},a_{32},a_{33},a_{34},a_{35}],\\,[a_{41},a_{42},a_{43},a_{44},a_{45}]\\,\\right]\n$$\n形式的单行文本，不得包含任何额外文字。\n\n测试套件覆盖范围：\n\n- 测试用例 1 是一个普通的离轴点，其中一个源被遮挡，另一个可见，用于探测强各向异性以及 OTVET 的偏差。\n- 测试用例 2 是一个理想情况下的点，两个源都可见且远在障碍物上方，用于探测部分抵消以及不同方法间的一致性。\n- 测试用例 3 是右侧的一个近轴点，其中左侧的源被遮挡，用于探测单向照明以及 OTVET 的偏差。\n- 测试用例 4 是一个近边界点，两个源都可见，但几何位置靠近障碍物，用于探测无遮挡情况下对各向异性的敏感度。\n\n您的实现必须是一个完整、可运行的程序，能够按照描述精确执行这些计算，并以指定的精确格式打印结果。不允许用户输入，也不应使用外部文件。", "solution": "该问题已经过验证，并被确定是健全的。它在科学上基于辐射转移原理，问题提法完善，提供了所有必要的参数和定义，并且可以形式化为一个直接的计算任务。在计算天体物理学中，比较长特征线 (LC)、M1 和光学薄可变爱丁顿张量 (OTVET) 方法是一个标准的、有意义的问题，用于评估辐射转移近似方法的性能。\n\n任务是使用三种不同的方法，为一个特定的二维配置计算角各向异性度量 $A(\\mathbf{x}) \\equiv \\frac{\\|\\mathbf{F}(\\mathbf{x})\\|}{c\\,E(\\mathbf{x})}$。该设置包括两个各向同性点源，一个不透明圆形障碍物和四个指定的场点。\n\n对每个场点 $\\mathbf{x}$，计算的核心包括两个主要步骤：首先，确定哪些源被障碍物遮挡；其次，根据源的可见性，为每种方法（$A_{\\mathrm{LC}}$, $A_{\\mathrm{M1}}$, $A_{\\mathrm{OTVET}}$）应用其独特的公式。\n\n几何和物理参数如下：\n- 源：光度 $L_1=1$ 位于 $\\mathbf{x}_1 = (-2, 0)$，光度 $L_2=1$ 位于 $\\mathbf{x}_2 = (2, 0)$。\n- 障碍物：中心在 $\\mathbf{x}_c=(0,0)$、半径为 $R=0.5$ 的圆。\n- 场点：$\\mathbf{x}^{(1)} = (-1, 0.2)$, $\\mathbf{x}^{(2)} = (0, 1)$, $\\mathbf{x}^{(3)} = (0.6, 0)$, $\\mathbf{x}^{(4)} = (0, 0.6)$。\n\n计算步骤如下：\n\n1.  **遮挡检测**：对于每个源 $\\mathbf{x}_s$ 和场点 $\\mathbf{x}_p$，我们必须确定连接它们的线段是否与由 $\\|\\mathbf{x}\\|^2 \\le R^2$ 定义的圆形障碍物相交。由于源和场点都不在障碍物内部，这等效于找到从圆心（$\\mathbf{x}_c = \\mathbf{0}$）到线段 $[\\mathbf{x}_s, \\mathbf{x}_p]$ 的最短距离，并检查该距离是否小于或等于 $R$。这个最短距离 $d_{\\mathrm{min}}$ 是通过将从线段端点（例如 $\\mathbf{x}_s$）到圆心的向量投影到线段方向向量 $\\mathbf{d} = \\mathbf{x}_p - \\mathbf{x}_s$ 上来找到的。投影参数为 $t = \\frac{(\\mathbf{x}_c - \\mathbf{x}_s) \\cdot \\mathbf{d}}{\\mathbf{d} \\cdot \\mathbf{d}}$。如果 $t \\in [0, 1]$，则最近点位于线段内部，$d_{\\mathrm{min}}$ 是垂直距离。否则，最近点是端点之一，$\\mathbf{x}_s$ 或 $\\mathbf{x}_p$。如果源 $s$ 的视线未被遮挡，则它从 $\\mathbf{x}_p$ 处是可见的。可见源的集合表示为 $\\mathcal{V}(\\mathbf{x}_p)$。\n\n2.  **各向异性度量计算**：对于每个场点 $\\mathbf{x}$，我们计算以下量。注意，由于光度 $L_s=1$ 是相同的，它们可以被约掉。令 $I_s(\\mathbf{x}) = 1/\\|\\mathbf{x}-\\mathbf{x}_s\\|^2 = 1/r_s^2$ 为未归一化的能量密度贡献，$\\hat{\\mathbf{n}}_s = (\\mathbf{x}-\\mathbf{x}_s)/r_s$ 为方向向量。\n\n    -   **长特征线 ($A_{\\mathrm{LC}}$)**：这是基准真相（ground truth）。计算仅涉及可见源。\n    $$\n    A_{\\mathrm{LC}}(\\mathbf{x}) = \\frac{\\left\\| \\sum_{s \\in \\mathcal{V}(\\mathbf{x})} I_s(\\mathbf{x}) \\hat{\\mathbf{n}}_s \\right\\|}{\\sum_{s \\in \\mathcal{V}(\\mathbf{x})} I_s(\\mathbf{x})}\n    $$\n    如果只有一个源可见，则求和中只包含一项，得到 $A_{\\mathrm{LC}} = \\|\\hat{\\mathbf{n}}_s\\| = 1$。如果没有源可见，$A_{\\mathrm{LC}}$ 未定义，但在这些测试用例中不会出现这种情况。\n\n    -   **M1 闭包 ($A_{\\mathrm{M1}}$)**：问题陈述指出，对于此静态测试，M1 方法使用与 LC 方法相同的可见源集合，并产生相同的结果。\n    $$\n    A_{\\mathrm{M1}}(\\mathbf{x}) = A_{\\mathrm{LC}}(\\mathbf{x})\n    $$\n\n    -   **光学薄可变爱丁顿张量 ($A_{\\mathrm{OTVET}}$)**：该方法基于光学薄辐射场构建其各向异性，这意味着它考虑所有源，无论是否被遮挡。\n    $$\n    A_{\\mathrm{OTVET}}(\\mathbf{x}) = \\left\\| \\sum_s w_s(\\mathbf{x}) \\hat{\\mathbf{n}}_s \\right\\|, \\quad \\text{where} \\quad w_s(\\mathbf{x}) = \\frac{I_s(\\mathbf{x})}{\\sum_{s'} I_{s'}(\\mathbf{x})}\n    $$\n    $w_s$ 和 $A_{\\mathrm{OTVET}}$ 的求和遍历所有源 $s$ 和 $s'$。\n\n3.  **偏差计算**：与 LC 参考值的绝对差计算如下：\n    $$\n    \\Delta_{\\mathrm{M1}} = |A_{\\mathrm{M1}} - A_{\\mathrm{LC}}| = 0 \\quad (\\text{根据此问题的定义})\n    $$\n    $$\n    \\Delta_{\\mathrm{OTVET}} = |A_{\\mathrm{OTVET}} - A_{\\mathrm{LC}}|\n    $$\n\n此过程应用于四个测试用例中的每一个。\n\n**情况 1：$\\mathbf{x} = (-1, 0.2)$**\n-   遮挡：源 $\\mathbf{x}_1=(-2,0)$ 可见。源 $\\mathbf{x}_2=(2,0)$ 被遮挡，因为视线穿过障碍物。\n-   $A_{\\mathrm{LC}}, A_{\\mathrm{M1}}$: 由于只有一个可见源，场是完全各向异性的。$A_{\\mathrm{LC}} = A_{\\mathrm{M1}} = 1$。\n-   $A_{\\mathrm{OTVET}}$: 使用两个源计算，由于对两个不同方向向量进行平均，得到的值小于 $1$。\n-   结果：$A_{\\mathrm{LC}} = 1.0$, $A_{\\mathrm{M1}} = 1.0$, $A_{\\mathrm{OTVET}} \\approx 0.797613$。偏差：$\\Delta_{\\mathrm{M1}} = 0.0$, $\\Delta_{\\mathrm{OTVET}} \\approx 0.202387$。\n\n**情况 2：$\\mathbf{x} = (0, 1)$**\n-   遮挡：根据对称性，该点距离障碍物足够远，两个源都可见。\n-   $A_{\\mathrm{LC}}, A_{\\mathrm{M1}}$: 使用两个源计算。\n-   $A_{\\mathrm{OTVET}}$: 由于所有源都可见，所使用的源集合与 LC 相同。在这种情况下，$A_{\\mathrm{LC}}$ 和 $A_{\\mathrm{OTVET}}$ 的公式在数学上是等效的。\n-   结果：$A_{\\mathrm{LC}} = A_{\\mathrm{M1}} = A_{\\mathrm{OTVET}} = 1/\\sqrt{5} \\approx 0.447214$。偏差：$\\Delta_{\\mathrm{M1}} = 0.0$, $\\Delta_{\\mathrm{OTVET}} = 0.0$。\n\n**情况 3：$\\mathbf{x} = (0.6, 0)$**\n-   遮挡：该点位于 x 轴上。到 $\\mathbf{x}_1=(-2,0)$ 的视线穿过原点，因此被遮挡。到 $\\mathbf{x}_2=(2,0)$ 的视线是清晰的。\n-   $A_{\\mathrm{LC}}, A_{\\mathrm{M1}}$: 由于只有一个可见源，场是完全各向异性的。$A_{\\mathrm{LC}} = A_{\\mathrm{M1}} = 1$。\n-   $A_{\\mathrm{OTVET}}$: 使用两个源计算。两个方向向量相反（$\\hat{\\mathbf{n}}_1=(1,0), \\hat{\\mathbf{n}}_2=(-1,0)$），导致显著抵消和一个低的各向异性值。\n-   结果：$A_{\\mathrm{LC}} = 1.0$, $A_{\\mathrm{M1}} = 1.0$, $A_{\\mathrm{OTVET}} \\approx 0.550570$。偏差：$\\Delta_{\\mathrm{M1}} = 0.0$, $\\Delta_{\\mathrm{OTVET}} \\approx 0.449430$。\n\n**情况 4：$\\mathbf{x} = (0, 0.6)$**\n-   遮挡：该点位于 y 轴上，刚好在障碍物外部（$0.6 > R=0.5$）。两条视线都靠近障碍物但未与之相交。两个源都可见。\n-   $A_{\\mathrm{LC}}, A_{\\mathrm{M1}}, A_{\\mathrm{OTVET}}$: 与情况 2 一样，所有源都可见，因此所有三种方法都产生相同的结果。\n-   结果：$A_{\\mathrm{LC}} = A_{\\mathrm{M1}} = A_{\\mathrm{OTVET}} = 0.6/\\sqrt{2^2+0.6^2} \\approx 0.287348$。偏差：$\\Delta_{\\mathrm{M1}} = 0.0$, $\\Delta_{\\mathrm{OTVET}} = 0.0$。\n\n最终的代码精确地实现了这些计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares three approximate radiative transfer closures\n    in a simplified anisotropic two-source shadowing test.\n    \"\"\"\n\n    # Define geometry and parameters\n    sources = [\n        {'pos': np.array([-2.0, 0.0]), 'L': 1.0},\n        {'pos': np.array([2.0, 0.0]), 'L': 1.0}\n    ]\n    obstacle = {'center': np.array([0.0, 0.0]), 'radius': 0.5}\n    \n    # Define test cases (field points)\n    test_cases = [\n        np.array([-1.0, 0.2]),\n        np.array([0.0, 1.0]),\n        np.array([0.6, 0.0]),\n        np.array([0.0, 0.6])\n    ]\n\n    def is_occluded(source_pos, point_pos, obs_center, obs_radius):\n        \"\"\"\n        Checks if the line segment from source_pos to point_pos is occluded\n        by a circular obstacle.\n        \n        This is done by finding the point on the line segment closest to the\n        obstacle's center and checking if its distance is within the radius.\n        \"\"\"\n        # Vector from source to point\n        vec_sp = point_pos - source_pos\n        d_sq = np.dot(vec_sp, vec_sp)\n        if d_sq == 0:  # Point is at the source\n            return False\n\n        # Vector from source to obstacle center\n        vec_s_obs = obs_center - source_pos\n\n        # Project vec_s_obs onto vec_sp to find the closest point on the infinite line\n        # t = (obs_center - source_pos) . (point_pos - source_pos) / |point_pos - source_pos|^2\n        t = np.dot(vec_s_obs, vec_sp) / d_sq\n        \n        # Clamp t to [0, 1] to find the closest point on the line segment\n        t_clamped = np.clip(t, 0.0, 1.0)\n\n        # Calculate the closest point on the segment to the obstacle center\n        closest_point_on_segment = source_pos + t_clamped * vec_sp\n        \n        # Calculate distance from this point to the obstacle center\n        dist_sq = np.sum((closest_point_on_segment - obs_center)**2)\n        \n        return dist_sq = obs_radius**2\n\n    results = []\n    \n    for x_p in test_cases:\n        # Determine the set of visible sources\n        visible_sources_indices = []\n        for i, s in enumerate(sources):\n            if not is_occluded(s['pos'], x_p, obstacle['center'], obstacle['radius']):\n                visible_sources_indices.append(i)\n\n        # --- Calculate A_LC and A_M1 ---\n        # (Based on visible sources)\n        A_lc = 0.0\n        if visible_sources_indices:\n            sum_flux_vec_lc = np.zeros(2)\n            sum_energy_den_lc = 0.0\n            for i in visible_sources_indices:\n                s = sources[i]\n                r_vec = x_p - s['pos']\n                r_mag = np.linalg.norm(r_vec)\n                n_hat = r_vec / r_mag\n                intensity = s['L'] / r_mag**2\n                \n                sum_flux_vec_lc += intensity * n_hat\n                sum_energy_den_lc += intensity\n            \n            if sum_energy_den_lc > 1e-12:\n                A_lc = np.linalg.norm(sum_flux_vec_lc) / sum_energy_den_lc\n        \n        A_m1 = A_lc  # As per problem statement\n        delta_m1 = abs(A_m1 - A_lc)\n\n        # --- Calculate A_OTVET ---\n        # (Based on ALL sources)\n        sum_weighted_n_hat_otvet = np.zeros(2)\n        total_intensity_otvet = 0.0\n        \n        intensities = []\n        unit_vectors = []\n        for s in sources:\n            r_vec = x_p - s['pos']\n            r_mag = np.linalg.norm(r_vec)\n            if r_mag > 1e-12:\n                n_hat = r_vec / r_mag\n                intensity = s['L'] / r_mag**2\n                intensities.append(intensity)\n                unit_vectors.append(n_hat)\n                total_intensity_otvet += intensity\n            else: # field point is at a source location\n                intensities.append(0)\n                unit_vectors.append(np.zeros(2))\n        \n        if total_intensity_otvet > 1e-12:\n            for i in range(len(sources)):\n                weight = intensities[i] / total_intensity_otvet\n                sum_weighted_n_hat_otvet += weight * unit_vectors[i]\n\n        A_otvet = np.linalg.norm(sum_weighted_n_hat_otvet)\n        delta_otvet = abs(A_otvet - A_lc)\n\n        # Store the results for this test case\n        results.append([A_lc, A_m1, A_otvet, delta_m1, delta_otvet])\n\n    # Format the final output string as specified\n    sublist_strs = []\n    for sublist in results:\n        sublist_strs.append(f\"[{','.join([f'{val:.6f}' for val in sublist])}]\")\n    \n    final_output_str = f\"[{','.join(sublist_strs)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "3507616"}]}