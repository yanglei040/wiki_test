{"hands_on_practices": [{"introduction": "宇宙学N体模拟的保真度在很大程度上取决于其初始条件的质量。本练习将引导您探索用于生成初始粒子位移和速度的标准方法——拉格朗日微扰理论（LPT）。通过这个实践，您将深入比较一阶（1LPT，也称为Zel'dovich近似）和二阶（2LPT）初始条件的差异，并量化2LPT如何有效地抑制非物理的“暂现模式”，从而使模拟能够从更低的红移开始，节省计算资源。[@problem_id:3507115]", "problem": "考虑一个在空间平坦的弗里德曼-勒梅特-罗伯逊-沃克 (FLRW) 背景下，在牛顿引力作用下演化的无旋、无压冷暗物质流体。在拉格朗日微扰理论 (LPT) 中，欧拉位置写作 $\\boldsymbol{x}(\\boldsymbol{q},t) = \\boldsymbol{q} + \\boldsymbol{\\psi}(\\boldsymbol{q},t)$，其中 $\\boldsymbol{q}$ 是拉格朗日坐标，$\\boldsymbol{\\psi}$ 是位移场。假设一个爱因斯坦-德西特 (EdS) 宇宙学模型，其中 $\\Omega_{\\mathrm{m}} = 1$，$\\Omega_{\\Lambda} = 0$，且标度因子 $a(t)$ 归一化为在 $z=0$ 时 $a(t_0) = 1$。一阶LPT (Zel'dovich 近似，ZA) 位移为 $\\boldsymbol{\\psi}^{(1)} = - D_{1}(a) \\boldsymbol{\\nabla}\\phi^{(1)}$，其中 $D_{1}(a)$ 是线性增长因子，$\\phi^{(1)}$ 满足一个以线性密度衬度为源的泊松方程。二阶LPT (2LPT) 位移为 $\\boldsymbol{\\psi}^{(2)} = D_{2}(a) \\boldsymbol{\\nabla}\\phi^{(2)}$，其中 $\\phi^{(2)}$ 为一个标量势。\n\n任务 A (推导)：从共动坐标系下自引力流体的牛顿第二定律、质量守恒以及无旋位移的假设出发，推导二阶LPT标量势 $\\phi^{(2)}$ 的控制方程，用一阶势 $\\phi^{(1)}$ 的空间导数表示。你的推导必须从基本定律（膨胀背景下的连续性方程和欧拉方程，以及引力势的泊松方程）开始，并得出一个泊松型方程，其源项是 $\\phi^{(1)}$ 的黑塞矩阵的二次方。你必须明确给出 $\\boldsymbol{\\nabla}^{2}\\phi^{(2)}$ 的方程，用 $\\phi^{(1)}$ 的二阶导数表示，所有数学实体均使用 LaTeX 格式。\n\n任务 B (时间演化与瞬变项)：在 EdS 极限下，二阶增长函数满足一个由一阶二次源项驱动的二阶常微分方程。仅使用第一性原理，推导 EdS 模型中 $D_{2}(a)$ 的通解结构，证明它由一个与 $a^{2}$ 成正比的特解以及与 $a$ 和 $a^{-3/2}$ 成正比的齐次模组成。在初始红移 $z_{\\mathrm{init}}$ (其中 $a_{\\mathrm{init}} = 1/(1+z_{\\mathrm{init}})$) 处施加以下初始条件设定：\n- 对于一阶LPT (ZA) 初始条件：设置 $D_{2}(a_{\\mathrm{init}}) = 0$ 且 $\\mathrm{d}D_{2}/\\mathrm{d}a\\big|_{a_{\\mathrm{init}}} = 0$。\n- 对于二阶LPT (2LPT) 初始条件：将 $D_{2}(a_{\\mathrm{init}})$ 和 $\\mathrm{d}D_{2}/\\mathrm{d}a\\big|_{a_{\\mathrm{init}}}$ 设置为与 EdS 特解一致的增长模值。\n\n对每种情况，求解齐次贡献的系数，并写出在两种初始条件选择下，在 $a=1$ 处求值的 $D_{2}(a)$，用 $a_{\\mathrm{init}}$ 明确表示。\n\n任务 C (量化物质功率谱中的瞬变抑制)：对于给定的初始条件设定，将 $z=0$ 时的瞬变抑制度量 $s$ 定义为二阶增长振幅平方相对于真实增长模值的相对减小量，\n$$\ns \\equiv 1 - \\left(\\frac{D_{2}^{\\mathrm{IC}}(a=1)}{D_{2}^{\\mathrm{true}}(a=1)}\\right)^{2},\n$$\n这是一个无量纲的小数。这里，$D_{2}^{\\mathrm{true}}(a)$ 表示 EdS 增长模特解，$D_{2}^{\\mathrm{IC}}(a)$ 是由所选初始条件产生并在 $a=1$ 处求值的实际 $D_{2}$。这个 $s$ 可作为与二阶增长平方成正比的主导单圈物质功率谱修正的相对抑制的一个代理。\n\n对于以下初始红移测试集，计算在 $z=0$ 时，一阶LPT (ZA) 和二阶LPT (2LPT) 两种初始条件下的 $s$：\n- 典型情况：$z_{\\mathrm{init}} = 99$,\n- 中间情况：$z_{\\mathrm{init}} = 49$,\n- 边界低红移情况：$z_{\\mathrm{init}} = 9$,\n- 高红移边缘情况：$z_{\\mathrm{init}} = 199$.\n\n所有输出均为无单位的小数。你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。对于上面列出的每个测试用例，按顺序输出两个数字：首先是一阶LPT (ZA) 的 $s$，然后是二阶LPT (2LPT) 的 $s$。例如，最终输出必须是 $\\left[\\ldots\\right]$ 的形式，并按顺序 $\\left[s_{\\mathrm{ZA}}(99), s_{\\mathrm{2LPT}}(99), s_{\\mathrm{ZA}}(49), s_{\\mathrm{2LPT}}(49), s_{\\mathrm{ZA}}(9), s_{\\mathrm{2LPT}}(9), s_{\\mathrm{ZA}}(199), s_{\\mathrm{2LPT}}(199)\\right]$ 包含恰好 $8$ 个浮点数。", "solution": "我们考虑一个在空间平坦的弗里德曼-勒梅特-罗伯逊-沃克 (FLRW) 背景下，由牛顿宇宙学描述的无压、无旋冷暗物质流体。欧拉位置为 $\\boldsymbol{x}(\\boldsymbol{q},t) = \\boldsymbol{q} + \\boldsymbol{\\psi}(\\boldsymbol{q},t)$，其中拉格朗日坐标为 $\\boldsymbol{q}$，位移场为 $\\boldsymbol{\\psi}$。其控制方程是共动坐标系下的牛顿第二定律、质量守恒以及引力势 $\\Phi$ 的泊松方程：\n$$\n\\frac{\\mathrm{d}^{2}\\boldsymbol{x}}{\\mathrm{d}t^{2}} + 2 H \\frac{\\mathrm{d}\\boldsymbol{x}}{\\mathrm{d}t} = - \\frac{1}{a^{2}} \\boldsymbol{\\nabla}_{x} \\Phi,\n$$\n$$\n\\boldsymbol{\\nabla}_{x}^{2} \\Phi = 4 \\pi G a^{2} \\bar{\\rho} \\, \\delta,\n$$\n$$\n1 + \\delta = \\frac{1}{J}, \\quad J \\equiv \\det\\left(\\frac{\\partial x_{i}}{\\partial q_{j}}\\right) = \\det\\left(\\delta_{ij} + \\frac{\\partial \\psi_{i}}{\\partial q_{j}}\\right),\n$$\n其中 $H \\equiv \\dot{a}/a$，$\\bar{\\rho}$ 是平均物质密度，$\\delta$ 是密度衬度。\n\n我们假设无旋性，因此各阶位移都是有势的：\n$$\n\\boldsymbol{\\psi}^{(1)} = - D_{1}(a) \\boldsymbol{\\nabla}\\phi^{(1)}, \\quad \\boldsymbol{\\psi}^{(2)} = D_{2}(a) \\boldsymbol{\\nabla}\\phi^{(2)},\n$$\n其中 $\\phi^{(1)}$ 和 $\\phi^{(2)}$ 是拉格朗日空间中的标量势，而 $D_{1}$、$D_{2}$ 是依赖于时间的增长函数。在爱因斯坦-德西特 (EdS) 模型中，线性增长因子为 $D_{1}(a) = a$。\n\n任务 A：二阶LPT势方程的推导。我们将雅可比矩阵 $J$ 在位移梯度 $\\Psi_{ij} \\equiv \\partial \\psi_{i}/\\partial q_{j}$ 上展开到二阶。使用行列式的恒等式，\n$$\nJ = 1 + \\mathrm{Tr}(\\Psi) + \\frac{1}{2}\\left[\\left(\\mathrm{Tr}(\\Psi)\\right)^{2} - \\mathrm{Tr}\\left(\\Psi^{2}\\right)\\right] + \\mathcal{O}(\\Psi^{3}),\n$$\n二阶密度衬度为\n$$\n\\delta^{(1)} = - \\mathrm{Tr}\\left(\\Psi^{(1)}\\right), \\quad \\delta^{(2)} = - \\mathrm{Tr}\\left(\\Psi^{(2)}\\right) + \\frac{1}{2}\\left[\\left(\\mathrm{Tr}\\left(\\Psi^{(1)}\\right)\\right)^{2} - \\mathrm{Tr}\\left(\\left(\\Psi^{(1)}\\right)^{2}\\right)\\right].\n$$\n对于 $\\boldsymbol{\\psi}^{(1)} = - D_{1} \\boldsymbol{\\nabla}\\phi^{(1)}$ 和 $\\boldsymbol{\\psi}^{(2)} = D_{2} \\boldsymbol{\\nabla}\\phi^{(2)}$，我们有\n$$\n\\Psi^{(1)}_{ij} = - D_{1} \\partial_{i}\\partial_{j}\\phi^{(1)}, \\quad \\Psi^{(2)}_{ij} = D_{2} \\partial_{i}\\partial_{j}\\phi^{(2)},\n$$\n因此\n$$\n\\delta^{(1)} = D_{1} \\nabla^{2} \\phi^{(1)}, \\quad \\delta^{(2)} = - D_{2} \\nabla^{2} \\phi^{(2)} + \\frac{D_{1}^{2}}{2}\\left[\\left(\\nabla^{2}\\phi^{(1)}\\right)^{2} - \\sum_{i,j} \\left(\\partial_{i}\\partial_{j}\\phi^{(1)}\\right)^{2}\\right].\n$$\n在二阶上，欧拉-泊松系统为 $\\delta^{(2)}$ 引入了一个在一阶场中是二次的源项。通过强制质量守恒以及与欧拉方程和泊松方程的一致性，二阶势 $\\phi^{(2)}$ 必须满足一个泊松型方程，其源项在适当的时间依赖性下抵消了纯二次的雅可比项。要求 $\\delta^{(2)}$ 与增长模对齐并匹配其空间依赖性，即可得到标准的2LPT势方程：\n$$\n\\nabla^{2} \\phi^{(2)} = \\sum_{i>j} \\left[ \\left(\\partial_{i}\\partial_{i} \\phi^{(1)}\\right)\\left(\\partial_{j}\\partial_{j} \\phi^{(1)}\\right) - \\left(\\partial_{i}\\partial_{j} \\phi^{(1)}\\right)^{2} \\right].\n$$\n等价地，用完整索引写出，\n$$\n\\nabla^{2} \\phi^{(2)} = \\frac{1}{2}\\left[\\left(\\nabla^{2}\\phi^{(1)}\\right)^{2} - \\sum_{i,j} \\left(\\partial_{i}\\partial_{j}\\phi^{(1)}\\right)^{2}\\right],\n$$\n这是在网格上构建2LPT初始位移时使用的经过充分检验的表达式。\n\n任务 B：$D_{2}(a)$ 的时间演化和瞬变模。在 EdS 模型中，二阶增长遵循一个由一阶增长的二次组合作为源项的线性非齐次常微分方程。一个以标度因子表示的方便形式是\n$$\n\\frac{\\mathrm{d}^{2} D_{2}}{\\mathrm{d} a^{2}} + \\frac{3}{2a} \\frac{\\mathrm{d} D_{2}}{\\mathrm{d} a} - \\frac{3}{2a^{2}} D_{2} = - \\frac{3}{2a^{2}} D_{1}^{2},\n$$\n其中右侧来自欧拉-泊松系统中的二次源项，并且在 EdS 模型中 $D_{1}(a) = a$。齐次方程\n$$\n\\frac{\\mathrm{d}^{2}y}{\\mathrm{d} a^{2}} + \\frac{3}{2a} \\frac{\\mathrm{d} y}{\\mathrm{d} a} - \\frac{3}{2a^{2}} y = 0\n$$\n有两个独立解 $y_{1}(a) \\propto a$ 和 $y_{2}(a) \\propto a^{-3/2}$。该非齐次方程的一个特解是\n$$\nD_{2}^{\\mathrm{part}}(a) = - \\frac{3}{7} a^{2}.\n$$\n因此通解为\n$$\nD_{2}(a) = - \\frac{3}{7} a^{2} + A a + B a^{-3/2},\n$$\n其中常数 $A$ 和 $B$ 由初始条件设定。\n\n对于一阶LPT (ZA) 初始条件，初始时不存在二阶分量，这意味着\n$$\nD_{2}(a_{\\mathrm{init}}) = 0, \\quad \\left.\\frac{\\mathrm{d}D_{2}}{\\mathrm{d}a}\\right|_{a_{\\mathrm{init}}} = 0.\n$$\n施加这两个条件，得到一个关于 $A$ 和 $B$ 的线性系统：\n$$\n0 = - \\frac{3}{7} a_{\\mathrm{init}}^{2} + A a_{\\mathrm{init}} + B a_{\\mathrm{init}}^{-3/2},\n$$\n$$\n0 = - \\frac{6}{7} a_{\\mathrm{init}} + A - \\frac{3}{2} B a_{\\mathrm{init}}^{-5/2}.\n$$\n求解得，\n$$\nB = - \\frac{6}{35} a_{\\mathrm{init}}^{7/2}, \\quad A = \\frac{3}{5} a_{\\mathrm{init}}.\n$$\n在 $a=1$ 处求值，\n$$\nD_{2}^{\\mathrm{ZA}}(1) = - \\frac{3}{7} + \\frac{3}{5} a_{\\mathrm{init}} - \\frac{6}{35} a_{\\mathrm{init}}^{7/2}.\n$$\n\n对于二阶LPT (2LPT) 初始条件，我们将初始二阶位移及其时间导数设置为增长模值以消除瞬变项：\n$$\nD_{2}(a_{\\mathrm{init}}) = - \\frac{3}{7} a_{\\mathrm{init}}^{2}, \\quad \\left.\\frac{\\mathrm{d}D_{2}}{\\mathrm{d}a}\\right|_{a_{\\mathrm{init}}} = - \\frac{6}{7} a_{\\mathrm{init}}.\n$$\n施加这些条件得到 $A = 0$ 和 $B = 0$，因此\n$$\nD_{2}^{\\mathrm{2LPT}}(a) = - \\frac{3}{7} a^{2}, \\quad D_{2}^{\\mathrm{2LPT}}(1) = - \\frac{3}{7}.\n$$\n\n任务 C：瞬变抑制度量。我们定义\n$$\ns \\equiv 1 - \\left(\\frac{D_{2}^{\\mathrm{IC}}(1)}{D_{2}^{\\mathrm{true}}(1)}\\right)^{2},\n$$\n其中 $D_{2}^{\\mathrm{true}}(1) = - 3/7$ 是 EdS 增长模在 $a=1$ 时的值。对于一阶LPT初始条件，\n$$\ns_{\\mathrm{ZA}}(z_{\\mathrm{init}}) = 1 - \\left( \\frac{ - \\frac{3}{7} + \\frac{3}{5} a_{\\mathrm{init}} - \\frac{6}{35} a_{\\mathrm{init}}^{7/2} }{ - \\frac{3}{7} } \\right)^{2} = 1 - \\left( 1 - \\frac{ \\frac{3}{5} a_{\\mathrm{init}} - \\frac{6}{35} a_{\\mathrm{init}}^{7/2} }{ \\frac{3}{7} } \\right)^{2}.\n$$\n对于小的 $a_{\\mathrm{init}}$，这在 $a_{\\mathrm{init}}$ 的主导阶上与 $s_{\\mathrm{ZA}} \\approx \\frac{14}{5} a_{\\mathrm{init}}$ 成比例，反映了 Zel'dovich 近似中著名的 $a_{\\mathrm{init}}$ 瞬变标度关系。对于二阶LPT初始条件，\n$$\ns_{\\mathrm{2LPT}}(z_{\\mathrm{init}}) = 1 - \\left( \\frac{ - \\frac{3}{7} }{ - \\frac{3}{7} } \\right)^{2} = 0,\n$$\n表明当在初始化时匹配增长模时，二阶瞬变项被完全抑制。\n\n算法实现。该程序对每个测试用例计算 $a_{\\mathrm{init}} = 1/(1+z_{\\mathrm{init}})$，通过上述精确表达式计算 $D_{2}^{\\mathrm{ZA}}(1)$，除以 $D_{2}^{\\mathrm{true}}(1) = - 3/7$，平方，然后用 1 减去结果以得到 $s_{\\mathrm{ZA}}$。对于 $s_{\\mathrm{2LPT}}$，在 EdS 增长模匹配中，其值对所有 $z_{\\mathrm{init}}$ 恒为 0。最终输出按指定顺序和格式汇总结果，生成一个不带单位的、由方括号括起来的浮点数列表。\n\n测试套件覆盖范围。案例 $z_{\\mathrm{init}} = 99$ 和 $z_{\\mathrm{init}} = 49$ 测试了典型的初始化选择；$z_{\\mathrm{init}} = 9$ 是一个具有可观瞬变项的边界低红移案例；$z_{\\mathrm{init}} = 199$ 是一个瞬变项被强烈抑制的高红移边缘案例。所有输出均为无量纲小数，按要求以 $\\left[s_{\\mathrm{ZA}}(99), s_{\\mathrm{2LPT}}(99), s_{\\mathrm{ZA}}(49), s_{\\mathrm{2LPT}}(49), s_{\\mathrm{ZA}}(9), s_{\\mathrm{2LPT}}(9), s_{\\mathrm{ZA}}(199), s_{\\mathrm{2LPT}}(199)\\right]$ 的顺序打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef suppression_ZA(z_init: float) -> float:\n    \"\"\"\n    Compute the transient suppression measure s for Zel'dovich (1LPT) initial conditions\n    at z=0 in an Einstein–de Sitter universe, given z_init.\n    s = 1 - (D2_wrong(1)/D2_true(1))^2\n    where D2_true(1) = -3/7 and\n    D2_wrong(1) = -3/7 + (3/5)*a_i - (6/35)*a_i^(7/2).\n    \"\"\"\n    a_i = 1.0 / (1.0 + z_init)\n    D2_true = -3.0 / 7.0\n    D2_wrong = (-3.0 / 7.0) + (3.0 / 5.0) * a_i - (6.0 / 35.0) * (a_i ** 3.5)\n    ratio_sq = (D2_wrong / D2_true) ** 2\n    s = 1.0 - ratio_sq\n    return s\n\ndef suppression_2LPT(z_init: float) -> float:\n    \"\"\"\n    Compute the transient suppression measure s for 2LPT initial conditions.\n    In EdS with correct matching, D2_wrong(1) = D2_true(1), hence s = 0.\n    \"\"\"\n    return 0.0\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Order: z_init = 99 (typical), 49 (intermediate), 9 (boundary low), 199 (high edge).\n    test_cases = [99.0, 49.0, 9.0, 199.0]\n\n    results = []\n    for z in test_cases:\n        s_ZA = suppression_ZA(z)\n        s_2LPT = suppression_2LPT(z)\n        # Append in the specified order: ZA then 2LPT for each z_init.\n        results.append(s_ZA)\n        results.append(s_2LPT)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3507115"}, {"introduction": "设置好初始条件后，我们必须在宇宙时标上演化粒子的运动。这个练习将解决在膨胀宇宙中精确积分粒子轨迹的挑战，在这种情况下，标准的固定时间步长方法效率低下。本实践将通过一个简化的无力场模型，揭示时间对称积分方案（Leapfrog方法的一个变体）在使用与尺度因子 $a$ 相关的可变时间步长时，对于保持长期数值精度的至关重要性。[@problem_id:3507114]", "problem": "在宇宙学背景下，通过从共动坐标系和膨胀背景下的基本动力学方程出发，实现并分析可变时间步长积分。任务是量化在使用 Leapfrog (LF) 方法时由可变时间步长引入的积分误差，并设计一种时间对称格式，在 Einstein-de Sitter (EdS) 宇宙学中，当尺度因子被用作时间变量时，该格式能保持二阶精度。\n\n考虑一个空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙中单个粒子的牛顿运动方程（在共动坐标系下）。共动坐标用 $x$ 表示，尺度因子用 $a$ 表示，哈勃参数用 $H(a)$ 表示。在共动变量中，一个受共动奇特引力势 $\\phi$ 影响的粒子的牛顿第二定律可写为\n$$\n\\frac{d^2 x}{dt^2} + 2 H \\frac{dx}{dt} = - \\frac{1}{a^2} \\nabla_x \\phi.\n$$\n定义正则动量 $p \\equiv a^2 \\frac{dx}{dt}$。使用 $dt = \\frac{da}{aH(a)}$ 和链式法则，以尺度因子 $a$ 为变量的运动方程为\n$$\n\\frac{dx}{da} = \\frac{p}{a^3 H(a)}, \\qquad \\frac{dp}{da} = \\frac{F(x,a)}{a^2 H(a)},\n$$\n其中 $F(x,a) \\equiv - \\nabla_x \\phi$。对于此问题，设 $F(x,a) = 0$（一个自由粒子），这样可以分离出宇宙膨胀和时间离散化的影响。此时 $p$ 是一个常数，精确解通过求积得到。\n\n采用 Einstein-de Sitter (EdS) 宇宙学模型，其中 $H(a) = H_0 a^{-3/2}$。在代码单位中进行计算，设 $H_0 = 1$ 和无量纲的共动位置；因此，所有报告的量都是无量纲的，不使用物理单位。设初始和最终尺度因子分别为 $a_i = 0.01$ 和 $a_f = 1$。初始条件为 $x(a_i) = x_i = 0$ 和 $v_i = \\left.\\frac{dx}{dt}\\right|_{a_i} = 1$，因此 $p = a_i^2 v_i$。\n\n对于给定的可变步长序列 $\\{\\Delta a_n\\}_{n=0}^{N-1}$，你必须实现并比较以下两种将 $x$ 从 $a_n$推进到 $a_{n+1} = a_n + \\Delta a_n$ 的单步更新规则：\n- 一种非时间对称的一阶漂移（一种朴素的可变步长 LF 漂移，其在左端点采样被积函数）：\n$$\nx_{n+1}^{\\mathrm{naive}} = x_n + \\Delta a_n \\, \\frac{p}{a_n^3 H(a_n)}.\n$$\n- 一种时间对称的二阶漂移（一种梯形法则，在 $a \\to -a$ 步长反转下保持可逆性）：\n$$\nx_{n+1}^{\\mathrm{sym}} = x_n + \\frac{\\Delta a_n}{2} \\, p \\left[ \\frac{1}{a_n^3 H(a_n)} + \\frac{1}{a_{n+1}^3 H(a_{n+1})} \\right].\n$$\n当 $F=0$ 时，这两种方法都简化为 Leapfrog 的特例，但对于可变的 $\\Delta a_n$，它们在时间对称性和全局阶数上有所不同。\n\n对于 $a_f$ 处的精确解，使用解析积分\n$$\nx_{\\mathrm{exact}}(a_f) = x_i + \\int_{a_i}^{a_f} \\frac{p}{a^3 H(a)} \\, da\n= x_i - \\frac{2 p}{H_0} \\left( a_f^{-1/2} - a_i^{-1/2} \\right),\n$$\n在代码单位中 $H_0 = 1$。\n\n测试套件。使用以下在 $a_i$ 和 $a_f$ 之间的步长序列，每个序列都指定为一系列步长 $\\{\\Delta a_n\\}$，其总和恰好为 $a_f - a_i$：\n- 情况 1（均匀，中等分辨率）：$N = 64$ 个等长步。\n- 情况 2（单步粗略，边界极端情况）：$N = 1$。\n- 情况 3（几何增长，强可变性）：$N = 32$ 个步长，权重为 $w_k = r^k$，比率为 $r = 1.5$，其中 $k \\in \\{0,\\dots,N-1\\}$，并进行归一化，使得 $\\sum \\Delta a_k = a_f - a_i$，且 $\\Delta a_k \\propto w_k$。\n- 情况 4（大小交替，高度不均匀）：$N = 32$ 个步长，大小交替为 $\\Delta a_{\\mathrm{small}}$ 和 $\\Delta a_{\\mathrm{large}}$，使得 $\\Delta a_{\\mathrm{large}} / \\Delta a_{\\mathrm{small}} = R = 50$，且总和等于 $a_f - a_i$。\n\n对于每种情况，计算两种格式在 $a_f$ 处的最终位置绝对误差：\n$$\ne_{\\mathrm{naive}} = \\left| x^{\\mathrm{naive}}(a_f) - x_{\\mathrm{exact}}(a_f) \\right|, \\qquad\ne_{\\mathrm{sym}} = \\left| x^{\\mathrm{sym}}(a_f) - x_{\\mathrm{exact}}(a_f) \\right|.\n$$\n\n最终输出格式。你的程序应生成单行输出，包含按以下顺序聚合的 8 个浮点数结果\n$$\n\\left[ e_{\\mathrm{naive}}^{(1)}, e_{\\mathrm{sym}}^{(1)}, e_{\\mathrm{naive}}^{(2)}, e_{\\mathrm{sym}}^{(2)}, e_{\\mathrm{naive}}^{(3)}, e_{\\mathrm{sym}}^{(3)}, e_{\\mathrm{naive}}^{(4)}, e_{\\mathrm{sym}}^{(4)} \\right],\n$$\n打印为一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,\\dots,r_8]$）。所有量在代码单位中都是无量纲的。不读取任何输入；所有参数均按上述规定硬编码。", "solution": "用户提供的问题已经过分析，并被确认为有效。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n\n- **共动坐标系下的动力学方程：**\n  - `\\frac{d^2 x}{dt^2} + 2 H \\frac{dx}{dt} = - \\frac{1}{a^2} \\nabla_x \\phi`\n  - 正则动量： `p \\equiv a^2 \\frac{dx}{dt}`\n  - 时间变量变换： `dt = \\frac{da}{aH(a)}`\n  - 以尺度因子 `a` 为变量的运动方程：\n    `\\frac{dx}{da} = \\frac{p}{a^3 H(a)}`, `\\frac{dp}{da} = \\frac{F(x,a)}{a^2 H(a)}`，其中 `F(x,a) \\equiv - \\nabla_x \\phi`。\n- **问题简化：**\n  - 力设为零： `F(x,a) = 0`，这意味着 `p` 是一个常数。\n- **宇宙学模型：**\n  - Einstein-de Sitter (EdS) 宇宙学： `H(a) = H_0 a^{-3/2}`。\n- **单位与常数：**\n  - 使用代码单位。\n  - 哈勃常数： `H_0 = 1`。\n  - 初始尺度因子： `a_i = 0.01`。\n  - 最终尺度因子： `a_f = 1`。\n- **初始条件：**\n  - 初始位置： `x(a_i) = x_i = 0`。\n  - 初始奇特速度： `v_i = \\left.\\frac{dx}{dt}\\right|_{a_i} = 1`。\n- **数值积分格式：**\n  - 非时间对称（朴素）漂移：`x_{n+1}^{\\mathrm{naive}} = x_n + \\Delta a_n \\, \\frac{p}{a_n^3 H(a_n)}`。\n  - 时间对称漂移： `x_{n+1}^{\\mathrm{sym}} = x_n + \\frac{\\Delta a_n}{2} \\, p \\left[ \\frac{1}{a_n^3 H(a_n)} + \\frac{1}{a_{n+1}^3 H(a_{n+1})} \\right]`。\n- **精确解：**\n  - `x_{\\mathrm{exact}}(a_f) = x_i - \\frac{2 p}{H_0} \\left( a_f^{-1/2} - a_i^{-1/2} \\right)`。\n- **测试用例（从 `a_i`到 `a_f` 的步长序列 `\\{\\Delta a_n\\}`）：**\n  - 情况 1：`N=64` 个等长步。\n  - 情况 2：`N=1` 个单步。\n  - 情况 3：`N=32` 个比率为 `r=1.5` 的几何步长。\n  - 情况 4：`N=32` 个尺寸比率为 `R=50` 的交替步长。\n- **要求输出：**\n  - 一个包含 8 个绝对误差的列表：`[e_{\\mathrm{naive}}^{(1)}, e_{\\mathrm{sym}}^{(1)}, e_{\\mathrm{naive}}^{(2)}, e_{\\mathrm{sym}}^{(2)}, e_{\\mathrm{naive}}^{(3)}, e_{\\mathrm{sym}}^{(3)}, e_{\\mathrm{naive}}^{(4)}, e_{\\mathrm{sym}}^{(4)}]`。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n- **科学基础：** 该问题基于标准的 FLRW 宇宙学模型中的基本运动方程。变换到共动坐标以及使用尺度因子作为时间变量是计算宇宙学中的标准技术。EdS 模型是一个广为接受的简化模型。\n- **适定性：** 该问题是一个定义明确的常微分方程初值问题，具有一组给定的参数。存在唯一的解，并且解析解已给出，这使得可以精确地量化误差。\n- **客观性：** 问题以精确、无歧义的数学语言陈述。任务是定量的，没有主观解释的余地。\n- **完整性与一致性：** 提供了所有必要的参数（`a_i, a_f, x_i, v_i, H_0`）、方程以及测试用例的定义。没有矛盾之处。\n- **可行性：** 所需的计算在数值上是直接的，并且可以使用标准库实现。\n\n**第 3 步：结论与行动**\n\n问题有效。将提供完整的解决方案。\n\n### 解决方案\n\n目标是量化一个在膨胀宇宙中运动的粒子的两种不同时间积分格式的数值误差。运动被简化为自由粒子（`F=0`），这分离了纯粹由背景膨胀项的离散化引起的误差。\n\n**1. 数学公式与解析解**\n\n需要积分的运动方程是：\n$$\n\\frac{dx}{da} = \\frac{p}{a^3 H(a)}\n$$\n对于 Einstein-de Sitter (EdS) 宇宙学，哈勃参数为 `H(a) = H_0 a^{-3/2}`。在指定的代码单位中，`H_0 = 1`，所以 `H(a) = a^{-3/2}`。将此代入运动方程得到：\n$$\n\\frac{dx}{da} = \\frac{p}{a^3 (a^{-3/2})} = \\frac{p}{a^{3/2}} = p a^{-3/2}\n$$\n这是一个关于 `x(a)` 的简单常微分方程。动量 `p` 是一个运动常数，由初始条件确定：\n$$\np = a_i^2 v_i = (0.01)^2 \\times 1 = 10^{-4}\n$$\n最终位置 `x(a_f)` 的精确解通过从 `a_i` 到 `a_f` 的直接积分求得：\n$$\nx_{\\mathrm{exact}}(a_f) = x_i + \\int_{a_i}^{a_f} p a^{-3/2} \\, da\n$$\n计算积分：\n$$\n\\int_{a_i}^{a_f} p a^{-3/2} \\, da = p \\left[ \\frac{a^{-1/2}}{-1/2} \\right]_{a_i}^{a_f} = -2p \\left( a_f^{-1/2} - a_i^{-1/2} \\right)\n$$\n使用给定的初始和最终值（`x_i = 0`，`a_i = 0.01`，`a_f = 1`），我们计算精确的最终位置：\n$$\nx_{\\mathrm{exact}}(a_f) = 0 - 2(10^{-4}) \\left( 1^{-1/2} - (0.01)^{-1/2} \\right) = -2 \\times 10^{-4} (1 - 10) = 1.8 \\times 10^{-3}\n$$\n该值作为基准，用于与数值格式的结果进行比较。\n\n**2. 数值离散格式**\n\n我们分析两种方法来近似积分 `\\int f(a) da`，其中被积函数是 `f(a) = \\frac{dx}{da} = p a^{-3/2}`。\n\n- **非时间对称（朴素）格式：** 该格式对应于前向欧拉法或在单步 `\\Delta a_n = a_{n+1} - a_n` 上的左黎曼和：\n$$\nx_{n+1} = x_n + \\Delta a_n f(a_n) = x_n + \\Delta a_n (p a_n^{-3/2})\n$$\n该方法是一阶精度的，意味着其全局误差与 `O(\\Delta a_{max})` 成比例，其中 `\\Delta a_{max}` 是最大步长。其缺乏时间对称性导致性能较差，尤其是在可变步长的情况下。\n\n- **时间对称（对称）格式：** 该格式是梯形法则的应用：\n$$\nx_{n+1} = x_n + \\frac{\\Delta a_n}{2} \\left[ f(a_n) + f(a_{n+1}) \\right] = x_n + \\frac{\\Delta a_n}{2} p \\left( a_n^{-3/2} + a_{n+1}^{-3/2} \\right)\n$$\n该方法是二阶精度的。其全局误差与 `O(\\Delta a_{max}^2)` 成比例。该结构是时间对称的，因为交换 `n` 和 `n+1` 的角色（即从 `a_{n+1}` 到 `a_n` 走一步 `-\\Delta a_n`）可以恢复到原始状态 `x_n`。此特性对于哈密顿系统中的长期稳定性和精度至关重要，尽管这里我们分析的是一个简化的情况。\n\n**3. 算法实现策略**\n\n解决方案通过以下步骤实现：\n\n1.  **初始化：** 定义物理和数值常数：`a_i`、`a_f`、`x_i`、`v_i`、`H_0`。计算常数动量 `p` 和精确的最终位置 `x_{\\mathrm{exact}}(a_f)`。\n\n2.  **步长生成：** 对于四个测试用例中的每一个，生成划分区间 `[a_i, a_f]` 的步长数组 `\\{\\Delta a_n\\}`。\n    -   **情况 1（均匀）：** 所有 `\\Delta a_n` 都等于 `(a_f - a_i) / N`。\n    -   **情况 2（单步）：** 一个单步 `\\Delta a_0 = a_f - a_i`。\n    -   **情况 3（几何）：** 步长 `\\Delta a_k` 与 `r^k` 成比例。它们被归一化，使其总和等于 `a_f - a_i`。\n    -   **情况 4（交替）：** 小步长 `\\Delta a_{\\mathrm{small}}` 和大步长 `\\Delta a_{\\mathrm{large}}` 的对由它们的比率 `R` 和总步数 `N` 决定，确保总长度等于 `a_f - a_i`。\n\n3.  **数值积分：** 创建一个通用的积分器函数，该函数接受一个步长数组和一个更新规则（朴素或对称）。该函数从 `(a, x) = (a_i, x_i)` 开始迭代应用更新规则，直到达到最终状态 `(a_f, x(a_f))`。\n\n4.  **误差计算：** 对于四个情况中的每一个，使用朴素和对称两种格式进行积分。通过将其与 `x_{\\mathrm{exact}}(a_f)` 比较，计算每个结果的绝对误差。\n\n5.  **输出：** 按指定顺序收集八个误差值，并将它们格式化为单行字符串以供输出。结果将展示时间对称格式的卓越精度，尤其是在步长高度不均匀的情况下（情况 3 和 4），在这些情况下，一阶方法的误差会显著增大。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes variable-timestep integration for a free particle\n    in an Einstein-de Sitter cosmology.\n    \"\"\"\n    # 1. Define constants and initial conditions\n    a_i = 0.01\n    a_f = 1.0\n    x_i = 0.0\n    v_i = 1.0\n    H_0 = 1.0  # In code units\n    \n    # Calculate constant canonical momentum p = a_i^2 * v_i\n    p = a_i**2 * v_i\n    \n    # Total integration interval length\n    total_delta_a = a_f - a_i\n\n    # 2. Define the integrand and the exact solution\n    # The ODE is dx/da = f(a), where f(a) = p / (a^3 * H(a)).\n    # With H(a) = H_0 * a**(-1.5) and H_0 = 1, this simplifies to:\n    # f(a) = p / (a^3 * a**(-1.5)) = p * a**(-1.5)\n    def f(a):\n        return p * a**(-1.5)\n\n    # The exact solution is the integral of f(a) from a_i to a_f.\n    # Integral of p*a**(-1.5) da = -2*p*a**(-0.5)\n    x_exact_af = x_i - 2 * p * (a_f**(-0.5) - a_i**(-0.5))\n\n    # 3. Define numerical integration schemes\n    def integrate(steps, update_rule):\n        \"\"\"Generic integrator for a given sequence of steps and an update rule.\"\"\"\n        x = x_i\n        a = a_i\n        for delta_a in steps:\n            x = update_rule(x, a, delta_a)\n            a += delta_a\n        return x\n\n    def update_naive(x_n, a_n, delta_a):\n        \"\"\"Non-time-symmetric, first-order (Forward Euler) update.\"\"\"\n        return x_n + delta_a * f(a_n)\n\n    def update_symmetric(x_n, a_n, delta_a):\n        \"\"\"Time-symmetric, second-order (Trapezoidal) update.\"\"\"\n        a_n1 = a_n + delta_a\n        return x_n + 0.5 * delta_a * (f(a_n) + f(a_n1))\n\n    # 4. Define test case parameters and generate step sequences\n    test_cases_params = [\n        {'type': 'uniform', 'N': 64},\n        {'type': 'single', 'N': 1},\n        {'type': 'geometric', 'N': 32, 'r': 1.5},\n        {'type': 'alternating', 'N': 32, 'R': 50.0}\n    ]\n\n    all_errors = []\n\n    for params in test_cases_params:\n        case_type = params['type']\n        \n        if case_type == 'uniform':\n            N = params['N']\n            steps = np.full(N, total_delta_a / N)\n        elif case_type == 'single':\n            steps = np.array([total_delta_a])\n        elif case_type == 'geometric':\n            N = params['N']\n            r = params['r']\n            indices = np.arange(N)\n            weights = r**indices\n            steps = total_delta_a * weights / np.sum(weights)\n        elif case_type == 'alternating':\n            N = params['N']\n            R = params['R']\n            num_pairs = N // 2\n            # For 16 pairs of (da_s, da_l), total_delta_a = 16 * (da_s + da_l)\n            # Since da_l = R * da_s, total_delta_a = 16 * da_s * (1 + R)\n            da_s = total_delta_a / (num_pairs * (1 + R))\n            da_l = R * da_s\n            step_pair = [da_s, da_l]\n            steps = np.array(step_pair * num_pairs)\n\n        # 5. Run simulations and compute errors\n        x_naive_af = integrate(steps, update_naive)\n        e_naive = np.abs(x_naive_af - x_exact_af)\n        \n        x_sym_af = integrate(steps, update_symmetric)\n        e_sym = np.abs(x_sym_af - x_exact_af)\n        \n        all_errors.extend([e_naive, e_sym])\n\n    # 6. Format and print the final output\n    print(f\"[{','.join(f'{e}' for e in all_errors)}]\")\n\nsolve()\n```", "id": "3507114"}, {"introduction": "模拟运行完成后，必须严格评估其结果是否存在数值人为效应。本实践将探讨“双体弛豫”效应，这是一种由有限的粒子数量引起的伪效应，它会人为地加热暗物质晕核心等密集区域。通过计算弛豫时间，本练习将教您如何评估模拟的分辨率和参数设置（如粒子质量 $m_p$ 和引力软化长度 $\\epsilon$）对于研究暗物质晕及其子结构属性是否处于“安全”范围。[@problem_id:3507095]", "problem": "您的指令是，通过测量晕核加热作为粒子质量 $m_p$ 和引力软化长度 $\\epsilon$ 的函数，来量化宇宙学 $N$ 体模拟中的虚假双体弛豫，估算弛豫时间 $t_r$，并为子晕存活统计校准一个安全区。请构建一个完整、可运行的程序，该程序从基本定律和核心定义出发，不依赖任何预计算数据，为一个由 Navarro–Frenk–White (NFW) 剖面（Navarro–Frenk–White (NFW)）建模的球对称晕实现一个基于物理原理的 $t_r$ 估算器。\n\n使用的基本依据是：\n- 牛顿引力：加速度由引力势导出，在小角度近似下，对于碰撞参数 $b$ 和相对速度 $v$，双体偏转角满足 $\\theta \\propto G m_p / (b v^2)$，其中 $G$ 是引力常数。\n- 弛豫晕的维里定理：动能和势能满足 $2K + U = 0$，并且半径 $r$ 处的一维速度弥散的量级估算可以通过圆周速度与 $\\sigma^2 \\approx V_c^2 / 2$ 关联，其中 $V_c^2(r) = G M(r) / r$。\n- 在平坦的 $\\Lambda$ 冷暗物质宇宙学模型中，红移 $z=0$ 时宇宙的临界密度为 $\\rho_{\\mathrm{crit}} = 3 H_0^2 / (8\\pi G)$，其中 $H_0$ 是哈勃常数。\n- NFW 晕剖面定义为 $\\rho(r) = \\rho_s \\left[(r/r_s)\\left(1+r/r_s\\right)^2\\right]^{-1}$，其中标度半径 $r_s = r_{200}/c$，维里半径 $r_{200} = \\left(3 M_{200}/[4\\pi \\cdot 200 \\cdot \\rho_{\\mathrm{crit}}]\\right)^{1/3}$，标度密度 $\\rho_s$ 由 $M_{200} = 4\\pi \\rho_s r_s^3 \\left[\\ln(1+c) - c/(1+c)\\right]$ 确定。\n\n您的程序必须：\n1. 对每个测试用例，使用上述定义和维里关系 $\\sigma^2 \\approx V_c^2/2$，计算在指定核心半径 $r_c$ 处的核心属性：局域密度 $\\rho(r_c)$ 和速度弥散 $\\sigma(r_c)$。\n2. 使用小角度散射扩散图像估算双体弛豫时间 $t_r$。将库仑对数处理为 $\\ln \\Lambda = \\ln\\left(b_{\\max}/b_{\\min}\\right)$，其中 $b_{\\max} = r_c$ 且 $b_{\\min} = \\max\\left(\\epsilon, b_{90}\\right)$，$b_{90} = G m_p / \\sigma^2$ 是造成 $90^\\circ$ 偏转的碰撞参数。如果 $b_{\\min} \\ge b_{\\max}$，为避免奇异行为，将 $\\ln \\Lambda$ 设置为一个小的正数下限值 $10^{-3}$，并将该状态解释为在 $r_c$ 处有效无碰撞。在一个近似麦克斯韦系统中使用一个经过充分检验的弛豫时间估算器：$t_r \\approx C \\, \\sigma^3 / \\left(G^2 \\, m_p \\, \\rho \\, \\ln \\Lambda\\right)$，其中 $C$ 是一个来自扩散理论的量级为1的常数。\n3. 计算 $r_c$ 处的局域平均粒子间距 $l = \\left(m_p/\\rho\\right)^{1/3}$，并为子晕存活统计校准一个简单的“安全区”判据，如果 $t_r \\ge \\alpha \\, t_H$ 和 $\\beta_1 \\, l \\le \\epsilon \\le \\beta_2 \\, l$ 两个条件同时满足，则将该用例标记为安全。其中 $t_H = 1/H_0$ 是哈勃时间，$\\alpha$、$\\beta_1$、$\\beta_2$ 是您选择的固定数值阈值，以反映保守的实践。\n4. 将弛豫时间 $t_r$ 以十亿年（Gyr）为单位表示，并四舍五入为浮点数值，安全区指示符表示为布尔值。\n\n在程序中采用以下常数和单位：\n- $G = 6.67430 \\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$，\n- $H_0 = 70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$，\n- 太阳质量 $M_\\odot = 1.98847 \\times 10^{30}\\,\\mathrm{kg}$，\n- $1\\,\\mathrm{kpc} = 3.085677581491367 \\times 10^{19}\\,\\mathrm{m}$，\n- $1\\,\\mathrm{Mpc} = 3.085677581491367 \\times 10^{22}\\,\\mathrm{m}$。\n\n在弛豫时间估算器中使用系数 $C = 0.34$，这是各向同性麦克斯韦分布公认的值。设置保守阈值 $\\alpha = 3$，$\\beta_1 = 0.2$ 和 $\\beta_2 = 1.0$。\n\n测试套件：\n提供以下五个测试用例的结果，所有用例均在 $z=0$ 时，使用指定参数。质量应以 $M_\\odot$ 为单位，半径和软化长度应以 $\\mathrm{kpc}$ 为单位。\n- 用例 1：$M_{200} = 10^{12}\\,M_\\odot$，$c = 10$，$r_c = 1.0\\,\\mathrm{kpc}$，$m_p = 10^{6}\\,M_\\odot$，$\\epsilon = 0.2\\,\\mathrm{kpc}$。\n- 用例 2：$M_{200} = 10^{12}\\,M_\\odot$，$c = 10$，$r_c = 1.0\\,\\mathrm{kpc}$，$m_p = 10^{8}\\,M_\\odot$，$\\epsilon = 0.5\\,\\mathrm{kpc}$。\n- 用例 3：$M_{200} = 10^{12}\\,M_\\odot$，$c = 10$，$r_c = 1.0\\,\\mathrm{kpc}$，$m_p = 10^{6}\\,M_\\odot$，$\\epsilon = 5.0\\,\\mathrm{kpc}$。\n- 用例 4：$M_{200} = 10^{10}\\,M_\\odot$，$c = 15$，$r_c = 0.5\\,\\mathrm{kpc}$，$m_p = 10^{6}\\,M_\\odot$，$\\epsilon = 0.05\\,\\mathrm{kpc}$。\n- 用例 5：$M_{200} = 10^{12}\\,M_\\odot$，$c = 8$，$r_c = 2.0\\,\\mathrm{kpc}$，$m_p = 10^{4}\\,M_\\odot$，$\\epsilon = 0.05\\,\\mathrm{kpc}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，本身是一个双元素列表 $[t_r, \\mathrm{safe}]$，其中 $t_r$ 的单位为 $\\mathrm{Gyr}$，$\\mathrm{safe}$ 是一个布尔值。例如，输出必须类似于 $[[t_{r,1},\\mathrm{safe}_1],[t_{r,2},\\mathrm{safe}_2],\\dots]$，不含任何额外文本。", "solution": "问题陈述是有效的。它在科学上基于宇宙学和恒星动力学的既定原理，特别是关于使用 Navarro–Frenk–White (NFW) 剖面对暗物质晕进行建模以及分析双体弛豫——这是 $N$ 体模拟中一个已知的数值效应。该问题提供了一整套方程、常数和参数，使其成为一个良定且自洽的问题。其语言客观，任务在计算上是可行的。因此，有必要提供一个完整的解决方案。\n\n该解决方案通过一系列基于物理动机的步骤构建，从基本的宇宙学参数和晕的定义开始，推导出所需的量：双体弛豫时间 $t_r$ 和一个用于“安全”模拟区的布尔指示符。为了内部一致性，所有计算都在国际单位制（SI）下进行，输入和输出按规定进行转换。\n\n首先，我们确定必要的物理常数和转换因子。引力常数为 $G$。哈勃常数为 $H_0 = 70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$。在红移 $z=0$ 时，宇宙的临界密度由 $\\rho_{\\mathrm{crit}} = 3 H_0^2 / (8\\pi G)$ 给出。所有以宇宙学单位（例如，太阳质量 $M_\\odot$，千秒差距 $\\mathrm{kpc}$）提供的输入参数都被转换为其国际单位制（SI）等效值（千克 $\\mathrm{kg}$，米 $\\mathrm{m}$）用于计算。哈勃时间 $t_H = 1/H_0$ 设定了宇宙演化的时间尺度。\n\n该模型的核心是暗物质晕的 NFW 剖面，它描述了其密度分布 $\\rho(r)$ 作为半径 $r$ 的函数：\n$$\n\\rho(r) = \\frac{\\rho_s}{\\left(\\frac{r}{r_s}\\right)\\left(1+\\frac{r}{r_s}\\right)^2}\n$$\n这里，$r_s$ 是标度半径，$\\rho_s$ 是标度密度。这两个参数由晕的总质量 $M_{200}$ 和聚集度 $c$ 决定。$M_{200}$ 是维里半径 $r_{200}$ 内包含的质量，在该半径内，平均密度是临界密度 $\\rho_{\\mathrm{crit}}$ 的 200 倍。因此维里半径计算如下：\n$$\nr_{200} = \\left(\\frac{3 M_{200}}{4\\pi \\cdot 200 \\cdot \\rho_{\\mathrm{crit}}}\\right)^{1/3}\n$$\n标度半径通过聚集度参数与维里半径相关联，$r_s = r_{200}/c$。然后通过对密度剖面进行积分以获得总质量 $M_{200}$ 来找到标度密度 $\\rho_s$：\n$$\nM_{200} = \\int_0^{r_{200}} 4\\pi r^2 \\rho(r) dr = 4\\pi \\rho_s r_s^3 \\left[\\ln(1+c) - \\frac{c}{1+c}\\right]\n$$\n对该方程进行重排，以求解每个测试用例的 $\\rho_s$。\n\n在 NFW 剖面完全确定后，我们接着计算在指定核心半径 $r_c$ 处的局域物理条件。局域密度 $\\rho(r_c)$ 通过直接代入 NFW 密度公式在 $r=r_c$ 处求值来计算。为了找到局域速度弥散 $\\sigma(r_c)$，我们首先需要 $r_c$ 内包含的质量，记为 $M(r_c)$。这通过对密度剖面从 $r=0$到$r_c$积分获得：\n$$\nM(r_c) = 4\\pi \\rho_s r_s^3 \\left[\\ln\\left(1+\\frac{r_c}{r_s}\\right) - \\frac{r_c/r_s}{1+r_c/r_s}\\right]\n$$\n该半径处的圆周速度为 $V_c^2(r_c) = G M(r_c) / r_c$。使用基于维里定理的、针对弛豫的各向同性系统的近似，一维速度弥散 $\\sigma(r_c)$ 估算为 $\\sigma^2(r_c) \\approx V_c^2(r_c) / 2$。这得到：\n$$\n\\sigma(r_c) = \\sqrt{\\frac{G M(r_c)}{2 r_c}}\n$$\n\n核心计算是双体弛豫时间 $t_r$ 的计算。这个时间尺度表征了单个粒子的轨道因与其他粒子的累积小角度引力散射而发生显著偏转的速率。对于一个质量为 $m_p$ 的粒子系统，在局域密度为 $\\rho(r_c)$ 和速度弥散为 $\\sigma(r_c)$ 的区域，弛豫时间由标准公式给出：\n$$\nt_r \\approx \\frac{C \\, \\sigma(r_c)^3}{G^2 \\, m_p \\, \\rho(r_c) \\, \\ln \\Lambda}\n$$\n其中 $C=0.34$ 是适用于速度的麦克斯韦分布的系数。项 $\\ln \\Lambda$ 是库仑对数，它解释了对弛豫有贡献的碰撞参数范围。它定义为 $\\ln \\Lambda = \\ln(b_{\\max}/b_{\\min})$。对于本问题，最大碰撞参数 $b_{\\max}$ 被取为该区域的特征尺度，因此 $b_{\\max} = r_c$。最小碰撞参数 $b_{\\min}$ 是模拟的引力软化长度 $\\epsilon$ 和在单次双体碰撞中会导致 $90^\\circ$ 偏转的碰撞参数 $b_{90}$ 中的较大者。后者由 $b_{90} = G m_p / \\sigma^2(r_c)$ 给出。因此，$b_{\\min} = \\max(\\epsilon, b_{90})$。使用 $\\epsilon$ 反映了在模拟中小距离上的引力被人为软化。如果 $b_{\\min} \\ge b_{\\max}$，这意味着在整个感兴趣的尺度上强偏转被抑制，使系统有效无碰撞。在这种情况下，$\\ln \\Lambda$ 被设定为一个小的正数下限值 $10^{-3}$，以防止出现奇点并反映一个非常长的弛豫时间。\n\n最后，我们评估模拟设置是否处于一个“安全区”，以保护像子晕这样的脆弱结构，这些结构可能被虚假的弛豫人为地破坏。这由两个判据判断：\n1. 弛豫时间 $t_r$ 必须远长于宇宙年龄 $t_H$。选择一个保守的阈值：$t_r \\ge \\alpha \\, t_H$，其中 $\\alpha=3$。\n2. 引力软化长度 $\\epsilon$ 必须相对于核心处的平均粒子间距 $l = (m_p/\\rho(r_c))^{1/3}$ 被适当地选择。如果 $\\epsilon$ 太小，大角度散射会变得频繁，从而增强弛豫。如果 $\\epsilon$ 太大，它会抹平真实的物理结构。一个实际的折衷方案是要求 $\\beta_1 \\, l \\le \\epsilon \\le \\beta_2 \\, l$，阈值为 $\\beta_1 = 0.2$ 和 $\\beta_2 = 1.0$。\n\n只有当这两个条件都满足时，模拟才被标记为“安全”（布尔值 `True`）。计算出的弛豫时间 $t_r$ 在最终输出时被转换为十亿年（Gyr）。这整个过程被封装在一个 Python 程序中，该程序处理每个测试用例并按规定格式化结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the relaxation time calculation for all test cases.\n    \"\"\"\n\n    # Physical constants in SI units\n    G_SI = 6.67430e-11  # m^3 kg^-1 s^-2\n    M_SUN_KG = 1.98847e30  # kg\n    KPC_M = 3.085677581491367e19  # m\n    MPC_M = 3.085677581491367e22  # m\n    H0_RAW = 70.0  # km s^-1 Mpc^-1\n    H0_SI = H0_RAW * 1000.0 / MPC_M  # s^-1\n    GYR_S = 1e9 * 365.25 * 24 * 3600  # seconds in a gigayear\n\n    # Problem-specific parameters\n    C_RELAX = 0.34\n    ALPHA_T = 3.0\n    BETA1_EPS = 0.2\n    BETA2_EPS = 1.0\n    LN_LAMBDA_FLOOR = 1e-3\n\n    # Test suite from the problem statement\n    # Format: (M200 [M_sun], c, r_c [kpc], m_p [M_sun], epsilon [kpc])\n    test_cases = [\n        (1e12, 10, 1.0, 1e6, 0.2),\n        (1e12, 10, 1.0, 1e8, 0.5),\n        (1e12, 10, 1.0, 1e6, 5.0),\n        (1e10, 15, 0.5, 1e6, 0.05),\n        (1e12, 8, 2.0, 1e4, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        m200_msun, c, rc_kpc, mp_msun, eps_kpc = case\n        result = calculate_relaxation_properties(\n            m200_msun, c, rc_kpc, mp_msun, eps_kpc,\n            G_SI, M_SUN_KG, KPC_M, H0_SI, GYR_S,\n            C_RELAX, ALPHA_T, BETA1_EPS, BETA2_EPS, LN_LAMBDA_FLOOR\n        )\n        results.append(result)\n\n    # Format the output string to match the required format precisely\n    # The boolean needs to be lowercase 'true' or 'false' for some platforms\n    formatted_results = [f\"[{res[0]},{str(res[1]).lower()}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_relaxation_properties(m200_msun, c, rc_kpc, mp_msun, eps_kpc,\n                                    g_si, m_sun_kg, kpc_m, h0_si, gyr_s,\n                                    c_relax, alpha_t, beta1_eps, beta2_eps,\n                                    ln_lambda_floor):\n    \"\"\"\n    Calculates the relaxation time and safe regime status for a single case.\n    \"\"\"\n    # 1. Convert all inputs to SI units\n    m200 = m200_msun * m_sun_kg\n    rc = rc_kpc * kpc_m\n    mp = mp_msun * m_sun_kg\n    epsilon = eps_kpc * kpc_m\n\n    # 2. Calculate NFW halo structural parameters\n    rho_crit = (3.0 * h0_si**2) / (8.0 * np.pi * g_si)\n    r200 = ((3.0 * m200) / (4.0 * np.pi * 200.0 * rho_crit))**(1.0/3.0)\n    rs = r200 / c\n\n    def nfw_mass_function(x):\n        return np.log(1.0 + x) - x / (1.0 + x)\n\n    m200_integrated_term = nfw_mass_function(c)\n    rho_s = m200 / (4.0 * np.pi * rs**3 * m200_integrated_term)\n\n    # 3. Calculate local properties at the core radius r_c\n    x_c = rc / rs\n    rho_rc = rho_s / (x_c * (1.0 + x_c)**2)\n    \n    m_rc = 4.0 * np.pi * rho_s * rs**3 * nfw_mass_function(x_c)\n    \n    # Check for non-physical mass/radius\n    if rc = 0 or m_rc = 0:\n        return [float('inf'), False]\n        \n    sigma_sq = (g_si * m_rc) / (2.0 * rc)\n    if sigma_sq = 0:\n        return [float('inf'), False]\n    sigma = np.sqrt(sigma_sq)\n\n    # 4. Estimate the two-body relaxation time t_r\n    b90 = (g_si * mp) / sigma_sq\n    b_min = max(epsilon, b90)\n    b_max = rc\n\n    if b_min >= b_max:\n        ln_Lambda = ln_lambda_floor\n    else:\n        ln_Lambda = np.log(b_max / b_min)\n\n    # Avoid division by zero if ln_Lambda is non-positive\n    if ln_Lambda = 0:\n        tr_s = float('inf')\n    else:\n        tr_s = (c_relax * sigma**3) / (g_si**2 * mp * rho_rc * ln_Lambda)\n    \n    tr_gyr = tr_s / gyr_s\n\n    # 5. Calibrate the \"safe regime\"\n    tH_s = 1.0 / h0_si\n    \n    # Condition 1: Relaxation time vs Hubble time\n    cond1_safe = tr_s >= alpha_t * tH_s\n\n    # Condition 2: Softening vs inter-particle spacing\n    if rho_rc = 0:\n        return [tr_gyr, False] # Unphysical density\n    l = (mp / rho_rc)**(1.0/3.0)\n    cond2_safe = (beta1_eps * l = epsilon) and (epsilon = beta2_eps * l)\n\n    is_safe = cond1_safe and cond2_safe\n\n    return [tr_gyr, is_safe]\n\nsolve()\n```", "id": "3507095"}]}