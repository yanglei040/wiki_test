{"hands_on_practices": [{"introduction": "在将复杂的物理模型托付给数值求解器之前，我们必须首先验证求解器本身是否已正确实现。制造解方法（Method of Manufactured Solutions, MMS）是一种强大的技术，它通过构建一个具有已知精确解的“人造”问题来达到此目的。这个练习将指导你应用MMS来验证恒星反应网络中常用时间积分方案的收敛阶，这是确保代码可靠性的基础步骤。[@problem_id:3525233]", "problem": "考虑一个无量纲的核反应网络，其中包含三种物质，状态向量是丰度向量 $\\mathbf{Y}(t) = \\big(Y_{\\mathrm{A}}(t), Y_{\\mathrm{B}}(t), Y_{\\mathrm{C}}(t)\\big)^{\\top}$。该网络包含两个具有恒定有效速率的反应：(i) $\\mathrm{A} \\to \\mathrm{B}$，速率参数为 $\\lambda$；(ii) $\\mathrm{B} \\to \\mathrm{C}$，速率参数为 $\\mu$。根据质量作用定律和化学计量关系，非受迫常微分方程（ODE）系统为\n$$\n\\frac{d\\mathbf{Y}}{dt} = \\mathbf{F}(\\mathbf{Y}) \\equiv \n\\begin{bmatrix}\n-\\lambda Y_{\\mathrm{A}} \\\\\n\\lambda Y_{\\mathrm{A}} - \\mu Y_{\\mathrm{B}} \\\\\n\\mu Y_{\\mathrm{B}}\n\\end{bmatrix}.\n$$\n我们将采用制造解方法（Method of Manufactured Solutions, MMS）来验证恒星反应网络求解器中使用的两种时间积分格式的精度阶。MMS 过程指定一个光滑的精确解 $\\mathbf{Y}_{\\mathrm{exact}}(t)$，并构造一个随时间变化的强迫项 $\\mathbf{Q}(t)$，使得受迫常微分方程\n$$\n\\frac{d\\mathbf{Y}}{dt} = \\mathbf{F}(\\mathbf{Y}) + \\mathbf{Q}(t)\n$$\n在积分区间内的所有时间 $t$ 上都具有精确解 $\\mathbf{Y}(t) \\equiv \\mathbf{Y}_{\\mathrm{exact}}(t)$。\n\n1. 制造解与强迫项。\n   - 令精确解为\n     $$\n     \\begin{aligned}\n     Y_{\\mathrm{A,exact}}(t) = 0.5 + 0.1\\cos(2\\pi t),\\\\\n     Y_{\\mathrm{B,exact}}(t) = 0.3 + 0.05\\sin(2\\pi t),\\\\\n     Y_{\\mathrm{C,exact}}(t) = 1 - Y_{\\mathrm{A,exact}}(t) - Y_{\\mathrm{B,exact}}(t).\n     \\end{aligned}\n     $$\n     该选择确保了对于所有 $t$ 均有 $Y_{\\mathrm{A,exact}}(t) > 0$、$Y_{\\mathrm{B,exact}}(t) > 0$、$Y_{\\mathrm{C,exact}}(t) > 0$ 且 $Y_{\\mathrm{A,exact}}(t) + Y_{\\mathrm{B,exact}}(t) + Y_{\\mathrm{C,exact}}(t) \\equiv 1$。\n   - 从基本定义 $\\mathbf{Q}(t) \\equiv \\frac{d\\mathbf{Y}_{\\mathrm{exact}}}{dt} - \\mathbf{F}(\\mathbf{Y}_{\\mathrm{exact}}(t))$ 出发，显式推导 $\\mathbf{Q}(t)$，并用它来定义用于数值时间积分的右端项 $\\mathbf{G}(t,\\mathbf{Y}) \\equiv \\mathbf{F}(\\mathbf{Y}) + \\mathbf{Q}(t)$。\n\n2. 待验证的时间积分方法。\n   - 实现 $p=1$ 阶的向前（显式）欧拉法：给定步长 $\\Delta t$，更新 $\\mathbf{Y}_{n+1} = \\mathbf{Y}_{n} + \\Delta t\\, \\mathbf{G}(t_n,\\mathbf{Y}_n)$。\n   - 实现 $p=4$ 阶的经典龙格-库塔法：以 $\\mathbf{G}(t,\\mathbf{Y})$ 为右端项，使用标准的 4 阶段格式，阶段时间为 $t_n$、$t_n+\\frac{\\Delta t}{2}$、$t_n+\\frac{\\Delta t}{2}$、$t_n+\\Delta t$。\n\n3. 网格加密下的误差测量与阶估计。\n   - 从 $t_0 = 0$ 积分到 $t_{\\mathrm{final}} = 1$，初始条件为 $\\mathbf{Y}(0) = \\mathbf{Y}_{\\mathrm{exact}}(0)$。\n   - 对于给定的基础时间步长 $\\Delta t_0$，使用三种加密步长：$\\Delta t_0$、$\\Delta t_0/2$ 和 $\\Delta t_0/4$，计算在 $t_{\\mathrm{final}}$ 处的数值解。对于每个 $\\Delta t$，计算误差\n     $$\n     E(\\Delta t) \\equiv \\left\\|\\mathbf{Y}_{\\mathrm{num}}(t_{\\mathrm{final}};\\Delta t) - \\mathbf{Y}_{\\mathrm{exact}}(t_{\\mathrm{final}})\\right\\|_{\\infty}.\n     $$\n   - 使用加密对 $(\\Delta t_0/2,\\ \\Delta t_0/4)$ 估计观测到的阶\n     $$\n     p_{\\mathrm{obs}} = \\log_2\\left(\\frac{E(\\Delta t_0/2)}{E(\\Delta t_0/4)}\\right).\n     $$\n     对于向前欧拉法，期望值为 $p_{\\mathrm{obs}} \\approx 1$；对于 4 阶经典龙格-库塔法，期望值为 $p_{\\mathrm{obs}} \\approx 4$。\n\n4. 测试套件。\n   - 使用以下四个测试案例，每个案例由 $(\\lambda,\\ \\mu,\\ \\Delta t_0,\\ \\text{method})$ 指定：\n     - 案例 A（中等速率，向前欧拉法）：$(2,\\ 1,\\ 0.05,\\ \\text{\"euler\"})$。\n     - 案例 B（中等速率，4 阶龙格-库塔法）：$(2,\\ 1,\\ 0.1,\\ \\text{\"rk4\"})$。\n     - 案例 C（较快速率，4 阶龙格-库塔法）：$(10,\\ 5,\\ 0.02,\\ \\text{\"rk4\"})$。\n     - 案例 D（较快速率，向前欧拉法）：$(10,\\ 5,\\ 0.01,\\ \\text{\"euler\"})$。\n   - 所有量均为无量纲；无需进行物理单位转换。\n\n5. 程序要求与最终输出格式。\n   - 程序必须实现从精确解和每个 $(\\lambda,\\ \\mu)$ 的网络 $\\mathbf{F}(\\mathbf{Y})$ 推导出的制造强迫项 $\\mathbf{Q}(t)$。\n   - 对于每个测试案例，按上述定义计算 $p_{\\mathrm{obs}}$ 并四舍五入到三位小数。\n   - 程序应生成单行输出，其中包含按 A、B、C、D 案例顺序排列的四个四舍五入后的 $p_{\\mathrm{obs}}$ 值，格式为方括号括起来的逗号分隔列表，例如：[x,y,z,w]。", "solution": "该问题要求验证两种数值时间积分格式——向前欧拉法和 4 阶经典龙格-库塔法——在应用于一个简单的核反应网络时的精度阶。验证将使用制造解方法（MMS）进行。该过程包括推导一个强迫项，使得控制微分方程具有一个选定的精确解，然后实现数值格式来求解这个受迫系统，并测量网格加密下数值误差的收敛率。\n\n系统的状态由物种丰度向量 $\\mathbf{Y}(t) = \\big(Y_{\\mathrm{A}}(t), Y_{\\mathrm{B}}(t), Y_{\\mathrm{C}}(t)\\big)^{\\top}$ 描述。非受迫演化由常微分方程系统 $\\frac{d\\mathbf{Y}}{dt} = \\mathbf{F}(\\mathbf{Y})$ 控制，其中反应网络 $\\mathrm{A} \\xrightarrow{\\lambda} \\mathrm{B} \\xrightarrow{\\mu} \\mathrm{C}$ 的反应项 $\\mathbf{F}(\\mathbf{Y})$ 由下式给出：\n$$\n\\mathbf{F}(\\mathbf{Y}) = \n\\begin{bmatrix}\n-\\lambda Y_{\\mathrm{A}} \\\\\n\\lambda Y_{\\mathrm{A}} - \\mu Y_{\\mathrm{B}} \\\\\n\\mu Y_{\\mathrm{B}}\n\\end{bmatrix}.\n$$\n\n首先，我们推导 MMS 所需的强迫项 $\\mathbf{Q}(t)$。受迫常微分方程系统为 $\\frac{d\\mathbf{Y}}{dt} = \\mathbf{F}(\\mathbf{Y}) + \\mathbf{Q}(t)$。根据设计，该系统必须具有精确解 $\\mathbf{Y}(t) \\equiv \\mathbf{Y}_{\\mathrm{exact}}(t)$。此条件将强迫项定义为：\n$$\n\\mathbf{Q}(t) \\equiv \\frac{d\\mathbf{Y}_{\\mathrm{exact}}}{dt} - \\mathbf{F}(\\mathbf{Y}_{\\mathrm{exact}}(t)).\n$$\n指定的制造解为：\n$$\n\\begin{aligned}\nY_{\\mathrm{A,exact}}(t) = 0.5 + 0.1\\cos(2\\pi t) \\\\\nY_{\\mathrm{B,exact}}(t) = 0.3 + 0.05\\sin(2\\pi t) \\\\\nY_{\\mathrm{C,exact}}(t) = 1 - Y_{\\mathrm{A,exact}}(t) - Y_{\\mathrm{B,exact}}(t) = 0.2 - 0.1\\cos(2\\pi t) - 0.05\\sin(2\\pi t)\n\\end{aligned}\n$$\n这些分量的时间导数为：\n$$\n\\frac{d\\mathbf{Y}_{\\mathrm{exact}}}{dt} = \n\\begin{bmatrix}\n-0.2\\pi \\sin(2\\pi t) \\\\\n0.1\\pi \\cos(2\\pi t) \\\\\n0.2\\pi \\sin(2\\pi t) - 0.1\\pi \\cos(2\\pi t)\n\\end{bmatrix}.\n$$\n接下来，我们在精确解处计算 $\\mathbf{F}$：\n$$\n\\mathbf{F}(\\mathbf{Y}_{\\mathrm{exact}}(t)) = \n\\begin{bmatrix}\n-\\lambda (0.5 + 0.1\\cos(2\\pi t)) \\\\\n\\lambda (0.5 + 0.1\\cos(2\\pi t)) - \\mu (0.3 + 0.05\\sin(2\\pi t)) \\\\\n\\mu (0.3 + 0.05\\sin(2\\pi t))\n\\end{bmatrix}.\n$$\n从 $\\frac{d\\mathbf{Y}_{\\mathrm{exact}}}{dt}$ 中减去 $\\mathbf{F}(\\mathbf{Y}_{\\mathrm{exact}}(t))$，得到 $\\mathbf{Q}(t) = \\big(Q_{\\mathrm{A}}(t), Q_{\\mathrm{B}}(t), Q_{\\mathrm{C}}(t)\\big)^{\\top}$ 的分量：\n$$\n\\begin{aligned}\nQ_{\\mathrm{A}}(t) = -0.2\\pi \\sin(2\\pi t) + \\lambda(0.5 + 0.1\\cos(2\\pi t)) \\\\\nQ_{\\mathrm{B}}(t) = 0.1\\pi \\cos(2\\pi t) - \\lambda(0.5 + 0.1\\cos(2\\pi t)) + \\mu(0.3 + 0.05\\sin(2\\pi t)) \\\\\nQ_{\\mathrm{C}}(t) = 0.2\\pi \\sin(2\\pi t) - 0.1\\pi \\cos(2\\pi t) - \\mu(0.3 + 0.05\\sin(2\\pi t))\n\\end{aligned}\n$$\n用于数值积分的右端项为 $\\mathbf{G}(t, \\mathbf{Y}) = \\mathbf{F}(\\mathbf{Y}) + \\mathbf{Q}(t)$。\n\n待验证的数值格式为：\n1.  **向前（显式）欧拉法（$p=1$ 阶）**：\n    $$\n    \\mathbf{Y}_{n+1} = \\mathbf{Y}_{n} + \\Delta t\\, \\mathbf{G}(t_n, \\mathbf{Y}_n)\n    $$\n2.  **经典龙格-库塔法（$p=4$ 阶）**：\n    $$\n    \\begin{aligned}\n    \\mathbf{k}_1 = \\mathbf{G}(t_n, \\mathbf{Y}_n) \\\\\n    \\mathbf{k}_2 = \\mathbf{G}(t_n + \\frac{\\Delta t}{2}, \\mathbf{Y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) \\\\\n    \\mathbf{k}_3 = \\mathbf{G}(t_n + \\frac{\\Delta t}{2}, \\mathbf{Y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) \\\\\n    \\mathbf{k}_4 = \\mathbf{G}(t_n + \\Delta t, \\mathbf{Y}_n + \\Delta t \\mathbf{k}_3) \\\\\n    \\mathbf{Y}_{n+1} = \\mathbf{Y}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n    \\end{aligned}\n    $$\n每个测试案例的数值实验通过将系统从 $t_0=0$ 积分到 $t_{\\mathrm{final}}=1$ 来进行，初始条件为 $\\mathbf{Y}(0) = \\mathbf{Y}_{\\mathrm{exact}}(0)$。此过程针对三种不同的时间步长完成：$\\Delta t_0$、$\\Delta t_1 = \\Delta t_0/2$ 和 $\\Delta t_2 = \\Delta t_0/4$。对于每个步长 $\\Delta t$，使用无穷范数计算最终时刻的误差：\n$$\nE(\\Delta t) = \\left\\|\\mathbf{Y}_{\\mathrm{num}}(t_{\\mathrm{final}}; \\Delta t) - \\mathbf{Y}_{\\mathrm{exact}}(t_{\\mathrm{final}})\\right\\|_{\\infty}.\n$$\n观测到的精度阶 $p_{\\mathrm{obs}}$ 是根据对应于两个最精细网格的误差 $E(\\Delta t_1)$ 和 $E(\\Delta t_2)$ 估算出来的。假设误差行为如 $E(\\Delta t) \\approx C(\\Delta t)^p$，我们有：\n$$\np_{\\mathrm{obs}} = \\frac{\\log(E(\\Delta t_1)/E(\\Delta t_2))}{\\log(\\Delta t_1/\\Delta t_2)} = \\frac{\\log(E(\\Delta t_0/2)/E(\\Delta t_0/4))}{\\log(2)} = \\log_2\\left(\\frac{E(\\Delta t_0/2)}{E(\\Delta t_0/4)}\\right).\n$$\n向前欧拉法的期望结果是 $p_{\\mathrm{obs}} \\approx 1$，RK$4$ 法的期望结果是 $p_{\\mathrm{obs}} \\approx 4$。算法实现将为 $\\mathbf{Y}_{\\mathrm{exact}}(t)$、$\\mathbf{G}(t,\\mathbf{Y})$ 和步进例程定义函数。一个主循环遍历所有测试案例，对三种步长进行积分，计算误差，并为每个案例计算 $p_{\\mathrm{obs}}$。最终结果是这些观测到的阶的列表，四舍五入到三位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    It computes the observed order of accuracy for four test cases\n    using the Method of Manufactured Solutions.\n    \"\"\"\n    \n    # --- Part 1: Manufactured Solution and Forcing Term Implementations ---\n\n    def get_Y_exact(t):\n        \"\"\"Computes the exact manufactured solution vector Y_exact(t).\"\"\"\n        cos_term = 0.1 * np.cos(2 * np.pi * t)\n        sin_term = 0.05 * np.sin(2 * np.pi * t)\n        Y_A = 0.5 + cos_term\n        Y_B = 0.3 + sin_term\n        Y_C = 1.0 - Y_A - Y_B\n        return np.array([Y_A, Y_B, Y_C])\n\n    def get_dY_exact_dt(t):\n        \"\"\"Computes the time derivative of the exact solution vector.\"\"\"\n        dY_A_dt = -0.1 * 2 * np.pi * np.sin(2 * np.pi * t)\n        dY_B_dt = 0.05 * 2 * np.pi * np.cos(2 * np.pi * t)\n        dY_C_dt = -dY_A_dt - dY_B_dt\n        return np.array([dY_A_dt, dY_B_dt, dY_C_dt])\n\n    def F(Y, lam, mu):\n        \"\"\"Computes the unforced reaction term F(Y).\"\"\"\n        Y_A, Y_B, _ = Y\n        return np.array([\n            -lam * Y_A,\n            lam * Y_A - mu * Y_B,\n            mu * Y_B\n        ])\n\n    def get_Q(t, lam, mu):\n        \"\"\"Computes the forcing term Q(t).\"\"\"\n        Y_exact_t = get_Y_exact(t)\n        dY_exact_dt_t = get_dY_exact_dt(t)\n        F_exact_t = F(Y_exact_t, lam, mu)\n        return dY_exact_dt_t - F_exact_t\n\n    def get_G(t, Y, lam, mu, Q_t):\n        \"\"\"Computes the full forced right-hand side G(t, Y).\"\"\"\n        return F(Y, lam, mu) + Q_t\n\n    # --- Part 2: Time Integration Method Implementations ---\n\n    def forward_euler_step(Y_n, t_n, dt, lam, mu):\n        \"\"\"Performs one step of the forward Euler method.\"\"\"\n        Q_n = get_Q(t_n, lam, mu)\n        G_n = get_G(t_n, Y_n, lam, mu, Q_n)\n        return Y_n + dt * G_n\n\n    def rk4_step(Y_n, t_n, dt, lam, mu):\n        \"\"\"Performs one step of the classical RK4 method.\"\"\"\n        Q_n = get_Q(t_n, lam, mu)\n        k1 = get_G(t_n, Y_n, lam, mu, Q_n)\n        \n        t_half = t_n + dt / 2.0\n        Q_half = get_Q(t_half, lam, mu)\n        k2 = get_G(t_half, Y_n + dt / 2.0 * k1, lam, mu, Q_half)\n        \n        k3 = get_G(t_half, Y_n + dt / 2.0 * k2, lam, mu, Q_half)\n\n        t_full = t_n + dt\n        Q_full = get_Q(t_full, lam, mu)\n        k4 = get_G(t_full, Y_n + dt * k3, lam, mu, Q_full)\n        \n        return Y_n + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    # --- Part 3: Error Measurement and Order Estimation ---\n\n    def run_one_case(lam, mu, dt0, method_str):\n        \"\"\"\n        Runs the numerical experiment for one test case and computes p_obs.\n        \"\"\"\n        t_final = 1.0\n        \n        # Select the numerical method\n        if method_str == \"euler\":\n            stepper = forward_euler_step\n        elif method_str == \"rk4\":\n            stepper = rk4_step\n        else:\n            raise ValueError(\"Unknown method\")\n\n        # Set up refinements\n        dts = [dt0 / 2.0, dt0 / 4.0]\n        errors = []\n\n        # Get the exact solution at the final time for error calculation\n        Y_final_exact = get_Y_exact(t_final)\n        \n        # Initial condition\n        Y0 = get_Y_exact(0.0)\n\n        # Loop over refinements\n        for dt in dts:\n            num_steps = int(round(t_final / dt))\n            Y = Y0.copy()\n            t = 0.0\n            \n            # Time integration loop\n            for _ in range(num_steps):\n                Y = stepper(Y, t, dt, lam, mu)\n                t += dt\n\n            # Compute and store error\n            error = np.linalg.norm(Y - Y_final_exact, ord=np.inf)\n            errors.append(error)\n        \n        # Calculate observed order of accuracy\n        # p_obs = log2(E(dt/2) / E(dt/4))\n        p_obs = np.log2(errors[0] / errors[1])\n        \n        return round(p_obs, 3)\n\n    # --- Part 4: Test Suite and Final Output ---\n\n    test_cases = [\n        (2, 1, 0.05, \"euler\"),   # Case A\n        (2, 1, 0.1, \"rk4\"),      # Case B\n        (10, 5, 0.02, \"rk4\"),    # Case C\n        (10, 5, 0.01, \"euler\"),  # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        lam, mu, dt0, method = case\n        p_obs = run_one_case(lam, mu, dt0, method)\n        results.append(p_obs)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3525233"}, {"introduction": "真实的恒星演化代码依赖于庞大的预计算核反应率数据表，这些反应率是温度和密度的复杂函数。准确地在这些离散数据点之间进行插值至关重要，因为插值误差会直接影响模拟的物理保真度。此练习将重点放在实现一种保形（shape-preserving）的插值方案，并量化其与精确物理模型相比的误差，这是处理输入物理并控制其不确定性的关键一环。[@problem_id:3525292]", "problem": "您正在实现一个模块，用于对恒星演化和爆炸模拟中使用的列表核反应率进行插值。这些表格以温度 $T$（以及可选的密度 $\\rho$）的函数形式给出，您必须使用能够保持物理单调性和正性的单调三次埃尔米特方案。您的任务是使用分段三次埃尔米特插值多项式（PCHIP）实现插值，量化相对于参考物理模型的插值误差，并报告无量纲的误差度量。本问题中的所有量在计算天体物理学的背景下都是自洽且合理的。\n\n从以下基本基础和定义开始。\n\n1. 设参考的一维单位粒子对反应率由一个解析的、非共振的带电粒子聚变形式建模\n$$\nr_0(T) \\;=\\; C \\; T_9^{-2/3} \\;\\exp\\!\\big(-b \\, T_9^{-1/3}\\big),\n$$\n其中 $T_9 \\equiv T / 10^9\\,\\mathrm{K}$，$C = 4.27\\times 10^{-15}$，且 $b = 3.38$。这个函数形式捕捉了在 $T \\in [10^7, 10^9]\\,\\mathrm{K}$ 范围内非共振反应的Gamow峰隧穿物理，并且在此区间上是严格为正且单调递增的。相应的对数敏感度为\n$$\n\\frac{d\\ln r_0}{d\\ln T} \\;=\\; -\\frac{2}{3} \\;+\\; \\frac{b}{3}\\,T_9^{-1/3}.\n$$\n\n2. 在一个可分离的二维模型中包含库仑屏蔽\n$$\nr(T,\\rho) \\;=\\; r_0(T)\\;\\times\\; f_{\\mathrm{screen}}(T,\\rho),\\qquad\nf_{\\mathrm{screen}}(T,\\rho) \\;=\\; \\exp\\!\\Big(A \\,\\rho_5^{1/2}\\, T_9^{-3/2}\\Big),\n$$\n其中 $\\rho_5 \\equiv \\rho / 10^5\\,\\mathrm{g\\,cm^{-3}}$ 且 $A = 0.05$。二维对数温度敏感度为\n$$\n\\frac{d\\ln r}{d\\ln T} \\;=\\; \\left(-\\frac{2}{3} \\;+\\; \\frac{b}{3}\\,T_9^{-1/3}\\right) \\;-\\; \\frac{3}{2}\\,A\\,\\rho_5^{1/2}\\,T_9^{-3/2}.\n$$\n\n3. 定义一个特征核燃烧时间尺度（不考虑成分因子）为\n$$\n\\tau(T,\\rho) \\;\\equiv\\; \\frac{1}{\\rho\\,r(T,\\rho)}.\n$$\n为了误差量化的特殊目的，您将报告在指定热力学状态下 $\\tau$ 的相对误差。\n\n您将获得从上述参考模型中采样的列表值，并且必须使用单调三次埃尔米特方案在列表节点之间进行插值。您不得使用任何可能引入过冲的非单调样条。您应该通过将插值结果与用于生成表格的精确解析模型进行比较来计算误差。\n\n插值要求。\n\n- 沿任何一维轴使用分段三次埃尔米特插值多项式（PCHIP）。对于在 $(T,\\rho)$ 的张量积网格上的二维插值，执行一维PCHIP操作的组合：首先在固定的 $\\rho$ 上沿 $T$ 轴进行插值，然后沿 $\\rho$ 轴组合这些结果。为了获得非网格点上关于 $T$ 的导数，从第一个PCHIP阶段携带 $T$ 导数，然后使用PCHIP沿 $\\rho$ 轴对该导数进行插值。\n\n- 对于在 $(T,\\rho)$ 处的任何评估，计算插值 $r_{\\mathrm{interp}}(T,\\rho)$ 和插值的对数温度敏感度\n$$\n\\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{interp}} \\;=\\; \\frac{T}{r_{\\mathrm{interp}}}\\,\\left(\\frac{\\partial r}{\\partial T}\\right)_{\\mathrm{interp}}.\n$$\n\n- 在任何已知精确参考值的点上量化两个误差度量：(i) 相对反应率误差\n$$\n\\varepsilon_r \\;=\\; \\left|\\frac{r_{\\mathrm{interp}} - r_{\\mathrm{exact}}}{r_{\\mathrm{exact}}}\\right|,\n$$\n和 (ii) 归一化对数斜率误差\n$$\n\\varepsilon_s \\;=\\; \\frac{\\left|\\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{interp}} - \\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{exact}}\\right|}{\\left|\\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{exact}}\\right| + 10^{-12}},\n$$\n其中，小的加法项 $10^{-12}$ 用于正则化接近零的分母，并且不影响在给定域上的准确性。\n\n表格、网格和测试套件。\n\n- 仅含 $T$ 的一维表格：\n  - 温度网格（单位：开尔文）: $T_{\\mathrm{grid}} = \\{\\,10^7,\\;2\\times 10^7,\\;5\\times 10^7,\\;10^8,\\;2\\times 10^8,\\;5\\times 10^8,\\;10^9\\,\\}$。\n  - 列表值：在 $T\\in T_{\\mathrm{grid}}$ 上精确计算的 $r_0(T)$。\n  - 查询集：从 $10^7$ 到 $10^9\\,\\mathrm{K}$（包括端点）之间对数均匀分布的 $50$ 个温度点。\n  - 报告此查询集上 $\\varepsilon_r$ 和 $\\varepsilon_s$ 的最大值。\n\n- $(T,\\rho)$ 的二维表格：\n  - 温度网格（单位：开尔文）：与上述 $T_{\\mathrm{grid}}$ 相同。\n  - 密度网格（单位：$\\mathrm{g\\,cm^{-3}}$）：$\\rho_{\\mathrm{grid}} = \\{\\,1,\\;10,\\;100,\\;10^3\\,\\}$。\n  - 列表值：在两个网格的张量积上精确计算的 $r(T,\\rho)$。\n  - 查询集：以下集合的笛卡尔积\n    - 温度（单位：开尔文）：$T_{\\mathrm{q}} = \\{\\,1.5\\times 10^7,\\;3\\times 10^7,\\;8\\times 10^7,\\;3\\times 10^8,\\;8\\times 10^8\\,\\}$，\n    - 密度（单位：$\\mathrm{g\\,cm^{-3}}$）：$\\rho_{\\mathrm{q}} = \\{\\,5,\\;50,\\;500\\,\\}$。\n  - 报告此二维查询集上 $\\varepsilon_r$ 和 $\\varepsilon_s$ 的最大值。\n\n- 在类日心状态下的核时间尺度误差：\n  - 单一状态：$T_\\star = 1.57\\times 10^7\\,\\mathrm{K}$，$\\rho_\\star = 150\\,\\mathrm{g\\,cm^{-3}}$。\n  - 使用二维插值函数，计算 $\\tau_{\\mathrm{interp}}(T_\\star,\\rho_\\star)$ 并与使用精确 $r(T,\\rho)$ 定义的 $\\tau_{\\mathrm{exact}}(T_\\star,\\rho_\\star)$ 进行比较。报告相对误差\n  $$\n  \\varepsilon_\\tau \\;=\\; \\left|\\frac{\\tau_{\\mathrm{interp}} - \\tau_{\\mathrm{exact}}}{\\tau_{\\mathrm{exact}}}\\right|.\n  $$\n\n实现和输出要求。\n\n- 使用 PCHIP 作为单调三次埃尔米特方法实现插值。对于二维插值，在每个 $\\rho$ 处沿 $T$ 轴应用 PCHIP 以获得插值和 $\\partial r/\\partial T$，然后沿 $\\rho$ 轴使用 PCHIP 以在目标 $\\rho$ 处获得 $r_{\\mathrm{interp}}$ 和 $(\\partial r/\\partial T)_{\\mathrm{interp}}$。\n\n- 您必须通过与上述指定的精确参考函数进行比较来计算误差。不要使用精确函数在列表节点之间进行插值。\n\n- 本问题不涉及角度。所有报告的误差度量都是无量纲的，并且必须以十进制数表示。\n\n- 您的程序应生成单行输出，包含一个逗号分隔的列表，其中包含以下五个浮点数结果，每个结果都四舍五入到六位有效数字并以科学记数法表示：$[\\max \\varepsilon_r \\text{ (一维)},\\;\\max \\varepsilon_s \\text{ (一维)},\\;\\max \\varepsilon_r \\text{ (二维)},\\;\\max \\varepsilon_s \\text{ (二维)},\\;\\text{在 } (T_\\star,\\rho_\\star) \\text{ 处的 } \\varepsilon_\\tau]$。例如，一个语法上有效的输出看起来像 $[1.234567\\mathrm{e}{-06},2.345678\\mathrm{e}{-05},\\dots]$。", "solution": "问题陈述已经过验证，被认为是科学上合理、定义明确且客观的。它提出了计算天体物理学中一个标准的、非平凡的任务：对列表核反应率进行插值并量化相关误差。所有提供的模型、常数和程序要求都是一致且物理上合理的。因此，我们可以着手解决。\n\n问题的核心是为温度 $T$ 和密度 $\\rho$ 的函数实现一个保形插值方案，并对照已知的解析形式评估其准确性。所选择的方法是分段三次埃尔米特插值多项式（PCHIP），它保证了如果基础数据是单调的，插值结果也将是单调的。对于像反应率这样的物理量，此属性至关重要，因为它们在相关热力学范围内通常表现出单调行为，从而防止引入可能困扰其他高阶插值方法（如标准三次样条）的非物理振荡。\n\n首先，我们定义将用于生成离散数据表并作为误差计算基准的精确参考模型。\n\n一维、非共振的单位粒子对反应率 $r_0(T)$ 由下式给出：\n$$\nr_0(T) = C \\, T_9^{-2/3} \\exp(-b \\, T_9^{-1/3})\n$$\n其中 $T_9 \\equiv T / (10^9\\,\\mathrm{K})$，$C = 4.27 \\times 10^{-15}$，且 $b = 3.38$。该反应率关于温度的对数敏感度为：\n$$\n\\left(\\frac{d\\ln r_0}{d\\ln T}\\right)_{\\mathrm{exact}} = -\\frac{2}{3} + \\frac{b}{3} T_9^{-1/3}\n$$\n\n二维模型 $r(T, \\rho)$ 包含了库仑屏蔽因子 $f_{\\mathrm{screen}}(T, \\rho)$：\n$$\nr(T,\\rho) = r_0(T) \\, f_{\\mathrm{screen}}(T,\\rho) \\quad \\text{where} \\quad f_{\\mathrm{screen}}(T,\\rho) = \\exp\\left(A \\,\\rho_5^{1/2}\\, T_9^{-3/2}\\right)\n$$\n此处，$\\rho_5 \\equiv \\rho / (10^5\\,\\mathrm{g\\,cm^{-3}})$ 且 $A = 0.05$。相应的二维对数温度敏感度为：\n$$\n\\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{exact}} = \\left(-\\frac{2}{3} + \\frac{b}{3}\\,T_9^{-1/3}\\right) - \\frac{3}{2}\\,A\\,\\rho_5^{1/2}\\,T_9^{-3/2}\n$$\n\n插值精度由两个误差度量来量化。相对反应率误差 $\\varepsilon_r$ 定义为：\n$$\n\\varepsilon_r = \\left|\\frac{r_{\\mathrm{interp}} - r_{\\mathrm{exact}}}{r_{\\mathrm{exact}}}\\right|\n$$\n归一化对数斜率误差 $\\varepsilon_s$ 定义为：\n$$\n\\varepsilon_s = \\frac{\\left|\\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{interp}} - \\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{exact}}\\right|}{\\left|\\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{exact}}\\right| + 10^{-12}}\n$$\n其中，插值的对数斜率由插值反应率 $r_{\\mathrm{interp}}$ 及其导数 $(\\partial r/\\partial T)_{\\mathrm{interp}}$ 计算得出：\n$$\n\\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{interp}} = \\frac{T}{r_{\\mathrm{interp}}} \\left(\\frac{\\partial r}{\\partial T}\\right)_{\\mathrm{interp}}\n$$\n此外，在一个单点 $(T_\\star, \\rho_\\star)$ 计算一个特定的时间尺度误差 $\\varepsilon_\\tau$。时间尺度 $\\tau$ 定义为 $\\tau(T,\\rho) = 1/(\\rho r(T,\\rho))$。误差为：\n$$\n\\varepsilon_\\tau = \\left|\\frac{\\tau_{\\mathrm{interp}} - \\tau_{\\mathrm{exact}}}{\\tau_{\\mathrm{exact}}}\\right| = \\left|\\frac{1/(\\rho_\\star r_{\\mathrm{interp}}) - 1/(\\rho_\\star r_{\\mathrm{exact}})}{1/(\\rho_\\star r_{\\mathrm{exact}})}\\right| = \\left|\\frac{r_{\\mathrm{exact}} - r_{\\mathrm{interp}}}{r_{\\mathrm{interp}}}\\right|\n$$\n值得注意的是，这是关于插值的反应率的相对误差，与 $\\varepsilon_r$ 的定义略有不同。\n\n解决方案分三个阶段进行：\n\n**第1部分：一维插值**\n通过在给定的温度网格 $T_{\\mathrm{grid}}$ 上评估精确函数 $r_0(T)$，创建一个离散数据点表 $(T_i, r_0(T_i))$。根据这些点构建一个PCHIP插值器。然后，在 $50$ 个查询温度点上分别评估此插值器及其导数。对于每个查询点，我们计算 $r_{\\mathrm{interp}}$、$(\\partial r/\\partial T)_{\\mathrm{interp}}$、$(\\frac{d\\ln r}{d\\ln T})_{\\mathrm{interp}}$，并将它们与精确值进行比较以计算 $\\varepsilon_r$ 和 $\\varepsilon_s$。记录整个查询集上这两个误差度量的最大值。\n\n**第2部分：二维插值**\n在 $T_{\\mathrm{grid}}$ 和 $\\rho_{\\mathrm{grid}}$ 的张量积上创建一个二维数据点表 $(T_i, \\rho_j, r(T_i, \\rho_j))$。为了找到查询点 $(T_q, \\rho_q)$ 处的插值和导数，我们遵循指定的两步程序：\n1.  **T轴插值**：对于网格 $\\rho_{\\mathrm{grid}}$ 中的每个密度 $\\rho_j$，我们沿温度网格 $T_{\\mathrm{grid}}$ 为作为温度函数的反应率 $r(T, \\rho_j)$ 构建一个一维PCHIP插值器。我们在查询温度 $T_q$ 处评估此插值器及其导数。对于每个网格密度 $\\rho_j$，这将产生一组中间值 $r_{\\mathrm{interp}}(T_q, \\rho_j)$ 和 $(\\partial r/\\partial T)_{\\mathrm{interp}}(T_q, \\rho_j)$。\n2.  **ρ轴插值**：我们构建两个新的一维PCHIP插值器。第一个沿 $\\rho_{\\mathrm{grid}}$ 对中间反应率 $r_{\\mathrm{interp}}(T_q, \\rho_j)$ 进行插值。第二个也沿 $\\rho_{\\mathrm{grid}}$ 对中间导数 $(\\partial r/\\partial T)_{\\mathrm{interp}}(T_q, \\rho_j)$ 进行插值。在查询密度 $\\rho_q$ 处评估这两个插值器，得到最终的 $r_{\\mathrm{interp}}(T_q, \\rho_q)$ 和 $(\\partial r/\\partial T)_{\\mathrm{interp}}(T_q, \\rho_q)$。\n对二维集中的每个查询点重复此过程。在每个点计算误差 $\\varepsilon_r$ 和 $\\varepsilon_s$，并记录它们的最大值。\n\n**第3部分：核时间尺度误差**\n再次对特定状态 $(T_\\star, \\rho_\\star) = (1.57\\times 10^7\\,\\mathrm{K}, 150\\,\\mathrm{g\\,cm^{-3}})$ 应用二维插值程序，以找到 $r_{\\mathrm{interp}}(T_\\star,\\rho_\\star)$。利用这个值，我们计算 $\\tau_{\\mathrm{interp}}(T_\\star, \\rho_\\star) = 1/(\\rho_\\star r_{\\mathrm{interp}})$。同时计算精确值 $\\tau_{\\mathrm{exact}}(T_\\star, \\rho_\\star)$。然后根据其定义确定相对误差 $\\varepsilon_\\tau$。\n\n最终输出将包含五个按要求格式化的计算误差度量。", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\nimport itertools\n\n# This script implements a PCHIP interpolation scheme for nuclear reaction rates\n# and quantifies the interpolation error against analytic reference models.\n\n# Role: Meticulous STEM Professor\n# Task: Validate and solve the problem of interpolating nuclear reaction rates.\n\ndef solve():\n    \"\"\"\n    Main function to perform interpolation, calculate errors, and print the results.\n    \"\"\"\n    # --------------------------------------------------------------------------\n    # 1. DEFINE CONSTANTS AND EXACT MODELS\n    # --------------------------------------------------------------------------\n    \n    # Physical and model constants\n    C = 4.27e-15  # Rate constant\n    b = 3.38      # Gamow peak exponent constant\n    A = 0.05      # Screening constant\n\n    def r0_exact(T):\n        \"\"\"Calculates the exact 1D non-resonant reaction rate.\"\"\"\n        T9 = T / 1e9\n        # Handling potential division by zero or invalid values for T=0\n        with np.errstate(divide='ignore'):\n            T9_m13 = T9**(-1/3)\n            T9_m23 = T9**(-2/3)\n        # For T=0, T9=0, exp(-inf) -> 0.\n        rate = C * T9_m23 * np.exp(-b * T9_m13)\n        rate = np.nan_to_num(rate)\n        return rate\n\n    def dlnr0_dlnT_exact(T):\n        \"\"\"Calculates the exact 1D logarithmic temperature sensitivity.\"\"\"\n        T9 = T / 1e9\n        with np.errstate(divide='ignore'):\n            T9_m13 = T9**(-1/3)\n        # The result diverges as T->0, but is well-behaved on the given grid.\n        return -2/3 + (b/3) * T9_m13\n\n    def r_exact(T, rho):\n        \"\"\"Calculates the exact 2D rate including Coulomb screening.\"\"\"\n        T9 = T / 1e9\n        rho5 = rho / 1e5\n        r0 = r0_exact(T)\n        with np.errstate(divide='ignore'):\n            f_screen = np.exp(A * rho5**(1/2) * T9**(-3/2))\n        f_screen = np.nan_to_num(f_screen, posinf=np.inf)\n        return r0 * f_screen\n\n    def dlnr_dlnT_exact(T, rho):\n        \"\"\"Calculates the exact 2D logarithmic temperature sensitivity.\"\"\"\n        T9 = T / 1e9\n        rho5 = rho / 1e5\n        dlnr0 = dlnr0_dlnT_exact(T)\n        with np.errstate(divide='ignore'):\n            screen_term = -(3/2) * A * rho5**(1/2) * T9**(-3/2)\n        return dlnr0 + screen_term\n\n    # --------------------------------------------------------------------------\n    # 2. DEFINE GRIDS AND QUERY POINTS\n    # --------------------------------------------------------------------------\n\n    # Grids for generating the interpolation tables\n    T_grid = np.array([1e7, 2e7, 5e7, 1e8, 2e8, 5e8, 1e9])\n    rho_grid = np.array([1.0, 10.0, 100.0, 1000.0])\n\n    # Query points for error analysis\n    T_q_1d = np.logspace(7, 9, 50)  # 1D query set\n\n    T_q_2d = np.array([1.5e7, 3e7, 8e7, 3e8, 8e8])\n    rho_q_2d = np.array([5.0, 50.0, 500.0])\n    query_points_2d = list(itertools.product(T_q_2d, rho_q_2d)) # 2D query set\n\n    T_star, rho_star = 1.57e7, 150.0  # Single state for timescale error\n\n    # --------------------------------------------------------------------------\n    # 3. PART 1: 1D INTERPOLATION AND ERROR ANALYSIS\n    # --------------------------------------------------------------------------\n    \n    # Generate the 1D table\n    r0_table = r0_exact(T_grid)\n\n    # Create 1D PCHIP interpolator for the rate and its derivative\n    pchip1d = PchipInterpolator(T_grid, r0_table)\n    pchip1d_deriv = pchip1d.derivative(nu=1)\n\n    errors_r_1d = []\n    errors_s_1d = []\n\n    for T_q in T_q_1d:\n        # Interpolated values\n        r_interp = pchip1d(T_q)\n        drdT_interp = pchip1d_deriv(T_q)\n        dlnr_dlnT_interp = (T_q / r_interp) * drdT_interp if r_interp > 0 else 0\n        \n        # Exact values\n        r_e = r0_exact(T_q)\n        dlnr_dlnT_e = dlnr0_dlnT_exact(T_q)\n        \n        # Calculate errors\n        err_r = np.abs((r_interp - r_e) / r_e) if r_e > 0 else 0\n        err_s = np.abs(dlnr_dlnT_interp - dlnr_dlnT_e) / (np.abs(dlnr_dlnT_e) + 1e-12)\n        \n        errors_r_1d.append(err_r)\n        errors_s_1d.append(err_s)\n\n    max_err_r_1d = np.max(errors_r_1d)\n    max_err_s_1d = np.max(errors_s_1d)\n\n    # --------------------------------------------------------------------------\n    # 4. PART 2: 2D INTERPOLATION AND ERROR ANALYSIS\n    # --------------------------------------------------------------------------\n\n    # Generate the 2D table\n    r_table_2d = r_exact(T_grid[:, np.newaxis], rho_grid[np.newaxis, :])\n\n    errors_r_2d = []\n    errors_s_2d = []\n\n    for T_q, rho_q in query_points_2d:\n        # Step A: Interpolate along T-axis for each grid density\n        r_interp_on_rhogrid = []\n        drdT_interp_on_rhogrid = []\n        for i in range(len(rho_grid)):\n            r_values_at_rho_i = r_table_2d[:, i]\n            pchip_T = PchipInterpolator(T_grid, r_values_at_rho_i)\n            r_interp_on_rhogrid.append(pchip_T(T_q))\n            drdT_interp_on_rhogrid.append(pchip_T.derivative(nu=1)(T_q))\n        \n        # Step B: Interpolate along rho-axis to get final values\n        pchip_rho_r = PchipInterpolator(rho_grid, r_interp_on_rhogrid)\n        r_interp = pchip_rho_r(rho_q)\n        \n        pchip_rho_drdT = PchipInterpolator(rho_grid, drdT_interp_on_rhogrid)\n        drdT_interp = pchip_rho_drdT(rho_q)\n        \n        dlnr_dlnT_interp = (T_q / r_interp) * drdT_interp if r_interp > 0 else 0\n        \n        # Exact values at (T_q, rho_q)\n        r_e = r_exact(T_q, rho_q)\n        dlnr_dlnT_e = dlnr_dlnT_exact(T_q, rho_q)\n\n        # Calculate errors\n        err_r = np.abs((r_interp - r_e) / r_e) if r_e > 0 else 0\n        err_s = np.abs(dlnr_dlnT_interp - dlnr_dlnT_e) / (np.abs(dlnr_dlnT_e) + 1e-12)\n\n        errors_r_2d.append(err_r)\n        errors_s_2d.append(err_s)\n\n    max_err_r_2d = np.max(errors_r_2d)\n    max_err_s_2d = np.max(errors_s_2d)\n\n    # --------------------------------------------------------------------------\n    # 5. PART 3: NUCLEAR TIMESCALE ERROR\n    # --------------------------------------------------------------------------\n\n    # Perform 2D interpolation for the specific state (T_star, rho_star)\n    r_interp_on_rhogrid_star = []\n    for i in range(len(rho_grid)):\n        r_values_at_rho_i = r_table_2d[:, i]\n        pchip_T = PchipInterpolator(T_grid, r_values_at_rho_i)\n        r_interp_on_rhogrid_star.append(pchip_T(T_star))\n\n    pchip_rho_r_star = PchipInterpolator(rho_grid, r_interp_on_rhogrid_star)\n    r_interp_star = pchip_rho_r_star(rho_star)\n\n    # Calculate timescales\n    tau_interp = 1 / (rho_star * r_interp_star) if r_interp_star > 0 else np.inf\n    \n    r_exact_star = r_exact(T_star, rho_star)\n    tau_exact = 1 / (rho_star * r_exact_star) if r_exact_star > 0 else np.inf\n    \n    # Calculate relative error in timescale as defined in the problem\n    err_tau = np.abs((tau_interp - tau_exact) / tau_exact) if tau_exact > 0 and np.isfinite(tau_exact) else 0\n\n    # --------------------------------------------------------------------------\n    # 6. FINAL OUTPUT\n    # --------------------------------------------------------------------------\n    \n    results = [\n        max_err_r_1d,\n        max_err_s_1d,\n        max_err_r_2d,\n        max_err_s_2d,\n        err_tau\n    ]\n    \n    # Format results to six significant digits in scientific notation\n    formatted_results = [\"{:.5e}\".format(res) for res in results]\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3525292"}, {"introduction": "在恒星演化的长时间尺度积分中，即使是高阶数值方法也会累积极微小的误差，导致像重子数和电荷数这样的守恒量发生漂移。为了保证模拟的长期稳定性和物理一致性，必须在每个时间步校正这种数值漂移。本练习将引导你推导并实现一种投影方法，它通过最小化对解的扰动来精确地恢复守恒律，这是构建鲁棒（robust）和可信的恒星演化代码的进阶技巧。[@problem_id:3525243]", "problem": "考虑一个恒星演化代码中的核反应网络，其中每种由 $i$ 索引的核素（物种）都有一个重子数 $A_i$、一个电荷数 $Z_i$ 和一个每重子丰度 $Y_i$。每重子丰度 $Y_i$ 的定义使得重子数守恒条件为 $C_1 = \\sum_i A_i Y_i - 1$。电子分数 $Y_e$ 由状态方程（EOS）从外部提供，电中性要求 $C_2 = \\sum_i Z_i Y_i - Y_e$。由于常微分方程（ODEs）的数值积分和有限精度运算，丰度向量 $\\mathbf{Y}$ 可能会发生漂移，导致 $C_1 \\neq 0$ 或 $C_2 \\neq 0$。您必须设计并实现一个投影步骤，通过最小化调整 $\\mathbf{Y}$ 来强制执行 $C_1 = 0$ 和 $C_2 = 0$。\n\n仅从上述基本定义和守恒要求出发，推导出一个数学上严格的更新规则，该规则基于在由 $C_1 = 0$ 和 $C_2 = 0$ 所隐含的线性约束条件下，最小化变化量 $\\Delta \\mathbf{Y}$ 的加权2-范数。令一个正对角权重矩阵 $\\mathbf{W} = \\mathrm{diag}(w_1, w_2, \\dots, w_n)$ 定义最小调整准则的度量。该投影必须：\n- 最小化二次型 $\\Delta \\mathbf{Y}^\\top \\mathbf{W} \\Delta \\mathbf{Y}$。\n- 当约束条件一致且具有足够自由度时，精确地强制执行两个线性约束 $C_1 = 0$ 和 $C_2 = 0$。\n- 对约束行之间的秩亏或近似线性相关具有鲁棒性，当精确执行不是由约束唯一确定时，选择一个最小范数解，以良态方式减少残差。\n\n您的程序必须实现此投影步骤，然后评估投影前后的守恒度量。对于每个测试用例，计算并返回：\n- 加权调整范数 $\\sqrt{\\Delta \\mathbf{Y}^\\top \\mathbf{W} \\Delta \\mathbf{Y}}$，作为一个浮点数。\n- 投影后的绝对值 $|C_1|$，作为一个浮点数。\n- 投影后的绝对值 $|C_2|$，作为一个浮点数。\n\n所有量都是无量纲的；不需要物理单位。不出现角度。不要将任何量表示为百分比；请使用小数表示法。\n\n测试套件：\n使用以下测试用例集，每个用例由 $(\\mathbf{A}, \\mathbf{Z}, \\mathbf{Y}, Y_e, \\mathbf{w})$ 指定，其中 $\\mathbf{A}$、$\\mathbf{Z}$ 和 $\\mathbf{w}$ 是列表，$\\mathbf{Y}$ 是初始丰度列表：\n- 测试用例 $1$（一般多物种情况）：\n  - $\\mathbf{A} = [1, 1, 4, 12]$\n  - $\\mathbf{Z} = [1, 0, 2, 6]$\n  - $\\mathbf{Y} = [0.6, 0.3, 0.02, 0.01]$\n  - $Y_e = 0.5$\n  - $\\mathbf{w} = [1, 1, 1, 1]$\n- 测试用例 $2$（边界情况，恰好两个物种和两个约束）：\n  - $\\mathbf{A} = [1, 1]$\n  - $\\mathbf{Z} = [1, 0]$\n  - $\\mathbf{Y} = [0.55, 0.55]$\n  - $Y_e = 0.45$\n  - $\\mathbf{w} = [1, 1]$\n- 测试用例 $3$（秩亏约束：所有物种具有相同的 $Z_i/A_i$ 比率）：\n  - $\\mathbf{A} = [4, 12, 16]$\n  - $\\mathbf{Z} = [2, 6, 8]$\n  - $\\mathbf{Y} = [0.1, 0.05, 0.01]$\n  - $Y_e = 0.5$\n  - $\\mathbf{w} = [1, 1, 1]$\n- 测试用例 $4$（非均匀权重，对某一物种的变化施加更强的惩罚）：\n  - $\\mathbf{A} = [1, 4]$\n  - $\\mathbf{Z} = [1, 2]$\n  - $\\mathbf{Y} = [0.99, 0.005]$\n  - $Y_e = 0.9$\n  - $\\mathbf{w} = [1, 5]$\n- 测试用例 $5$（已守恒的输入应产生零调整）：\n  - $\\mathbf{A} = [1, 1]$\n  - $\\mathbf{Z} = [1, 0]$\n  - $\\mathbf{Y} = [0.5, 0.5]$\n  - $Y_e = 0.5$\n  - $\\mathbf{w} = [1, 1]$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例的结果必须是按 $[\\sqrt{\\Delta \\mathbf{Y}^\\top \\mathbf{W} \\Delta \\mathbf{Y}}, |C_1|, |C_2|]$ 顺序排列的三个浮点数列表。例如，最终打印的行应类似于 $[[x_1,y_1,z_1],[x_2,y_2,z_2],\\dots]$，不含任何附加文本。", "solution": "该问题要求设计一个投影算法来校正核素丰度向量 $\\mathbf{Y}$，使其满足重子数和电荷守恒定律。这被表述为一个约束优化问题：找到一个调整向量 $\\Delta \\mathbf{Y}$，它在精确满足线性守恒约束的同时，最小化一个加权的二次范数。\n\n### 1. 数学公式\n\n设丰度向量为 $\\mathbf{Y} = (Y_1, Y_2, \\dots, Y_n)^\\top$，其中 $n$ 是核素物种的数量。系统的状态由重子数向量 $\\mathbf{A} = (A_1, A_2, \\dots, A_n)^\\top$ 和电荷数向量 $\\mathbf{Z} = (Z_1, Z_2, \\dots, Z_n)^\\top$ 描述。\n\n两个守恒定律是：\n1. 重子数守恒：$\\sum_{i=1}^n A_i Y_i = 1$。其违背量为 $C_1(\\mathbf{Y}) = \\mathbf{A}^\\top \\mathbf{Y} - 1$。\n2. 电中性：$\\sum_{i=1}^n Z_i Y_i = Y_e$。其违背量为 $C_2(\\mathbf{Y}) = \\mathbf{Z}^\\top \\mathbf{Y} - Y_e$。\n\n我们寻求一个满足这些约束的更新丰度向量 $\\mathbf{Y}' = \\mathbf{Y} + \\Delta \\mathbf{Y}$。这对调整向量 $\\Delta \\mathbf{Y}$ 施加了两个线性约束：\n1. $\\mathbf{A}^\\top (\\mathbf{Y} + \\Delta \\mathbf{Y}) = 1 \\implies \\mathbf{A}^\\top \\Delta \\mathbf{Y} = 1 - \\mathbf{A}^\\top \\mathbf{Y} = -C_1(\\mathbf{Y})$。\n2. $\\mathbf{Z}^\\top (\\mathbf{Y} + \\Delta \\mathbf{Y}) = Y_e \\implies \\mathbf{Z}^\\top \\Delta \\mathbf{Y} = Y_e - \\mathbf{Z}^\\top \\mathbf{Y} = -C_2(\\mathbf{Y})$。\n\n这些可以写成矩阵形式 $\\mathbf{C} \\Delta \\mathbf{Y} = \\mathbf{r}$，其中：\n$$\n\\mathbf{C} = \\begin{pmatrix} \\mathbf{A}^\\top \\\\ \\mathbf{Z}^\\top \\end{pmatrix}, \\quad\n\\mathbf{r} = \\begin{pmatrix} -C_1(\\mathbf{Y}) \\\\ -C_2(\\mathbf{Y}) \\end{pmatrix}\n$$\n矩阵 $\\mathbf{C}$ 的维度是 $2 \\times n$。目标是找到满足此系统且在特定意义上是“最小”的 $\\Delta \\mathbf{Y}$。最小化准则定义为最小化二次型 $\\Delta \\mathbf{Y}^\\top \\mathbf{W} \\Delta \\mathbf{Y}$，其中 $\\mathbf{W} = \\mathrm{diag}(w_1, w_2, \\dots, w_n)$ 是一个给定的正对角权重矩阵。\n\n因此，该问题是一个约束二次优化问题：\n$$\n\\text{minimize} \\quad f(\\Delta \\mathbf{Y}) = \\Delta \\mathbf{Y}^\\top \\mathbf{W} \\Delta \\mathbf{Y} \\\\\n\\text{subject to} \\quad \\mathbf{C} \\Delta \\mathbf{Y} = \\mathbf{r}\n$$\n\n### 2. 使用 Lagrange 乘子法求解\n\n该问题使用 Lagrange 乘子法求解。我们定义拉格朗日函数 $\\mathcal{L}$：\n$$\n\\mathcal{L}(\\Delta \\mathbf{Y}, \\boldsymbol{\\lambda}) = \\Delta \\mathbf{Y}^\\top \\mathbf{W} \\Delta \\mathbf{Y} - \\boldsymbol{\\lambda}^\\top (\\mathbf{C} \\Delta \\mathbf{Y} - \\mathbf{r})\n$$\n其中 $\\boldsymbol{\\lambda} = (\\lambda_1, \\lambda_2)^\\top$ 是 Lagrange 乘子向量。最优解必须满足 Karush-Kuhn-Tucker (KKT) 条件，对于此问题，这简化为将 $\\mathcal{L}$ 关于 $\\Delta \\mathbf{Y}$ 的梯度设为零：\n$$\n\\nabla_{\\Delta \\mathbf{Y}} \\mathcal{L} = 2 \\mathbf{W} \\Delta \\mathbf{Y} - \\mathbf{C}^\\top \\boldsymbol{\\lambda} = \\mathbf{0}\n$$\n由于 $\\mathbf{W}$ 是一个正对角矩阵，其逆矩阵 $\\mathbf{W}^{-1}$ 存在且易于计算。我们可以用 $\\boldsymbol{\\lambda}$ 来求解 $\\Delta \\mathbf{Y}$：\n$$\n\\Delta \\mathbf{Y} = \\frac{1}{2}\\mathbf{W}^{-1} \\mathbf{C}^\\top \\boldsymbol{\\lambda}\n$$\n因子 $\\frac{1}{2}$ 可以被吸收到 $\\boldsymbol{\\lambda}$ 的定义中，从而得到更简洁的表达式：\n$$\n\\Delta \\mathbf{Y} = \\mathbf{W}^{-1} \\mathbf{C}^\\top \\boldsymbol{\\lambda}\n$$\n为了找到 $\\boldsymbol{\\lambda}$，我们将此表达式代回约束方程 $\\mathbf{C} \\Delta \\mathbf{Y} = \\mathbf{r}$：\n$$\n\\mathbf{C} ( \\mathbf{W}^{-1} \\mathbf{C}^\\top \\boldsymbol{\\lambda} ) = \\mathbf{r}\n$$\n这给出了一个关于 Lagrange 乘子的 $2 \\times 2$ 线性系统：\n$$\n\\mathbf{M} \\boldsymbol{\\lambda} = \\mathbf{r}, \\quad \\text{where} \\quad \\mathbf{M} = \\mathbf{C} \\mathbf{W}^{-1} \\mathbf{C}^\\top\n$$\n\n### 3. 鲁棒性与秩亏\n\n$2 \\times 2$ 矩阵 $\\mathbf{M}$ 定义为：\n$$\n\\mathbf{M} = \\begin{pmatrix} \\mathbf{A}^\\top \\mathbf{W}^{-1} \\mathbf{A} & \\mathbf{A}^\\top \\mathbf{W}^{-1} \\mathbf{Z} \\\\ \\mathbf{Z}^\\top \\mathbf{W}^{-1} \\mathbf{A} & \\mathbf{Z}^\\top \\mathbf{W}^{-1} \\mathbf{Z} \\end{pmatrix} = \\begin{pmatrix} \\sum_i \\frac{A_i^2}{w_i} & \\sum_i \\frac{A_i Z_i}{w_i} \\\\ \\sum_i \\frac{Z_i A_i}{w_i} & \\sum_i \\frac{Z_i^2}{w_i} \\end{pmatrix}\n$$\n矩阵 $\\mathbf{M}$ 是奇异的当且仅当其行列式为零。根据 Cauchy-Schwarz 不等式，$\\det(\\mathbf{M}) = 0$ 当且仅当向量 $\\mathbf{A}$ 和 $\\mathbf{Z}$ 相对于由 $\\mathbf{W}^{-1}$ 定义的内积是线性相关的。这在物理上对应于所有核素具有相同荷质比的情况，即 $Z_i/A_i = \\text{常数}$（假设对所有物种 $w_i > 0$）。测试用例3就是这种情况的一个例子。\n\n为了确保一个能处理可逆和奇异情况的鲁棒解，我们使用 Moore-Penrose 伪逆 $\\mathbf{M}^+$ 来求解 $\\boldsymbol{\\lambda}$：\n$$\n\\boldsymbol{\\lambda} = \\mathbf{M}^+ \\mathbf{r}\n$$\n- 如果 $\\mathbf{M}$ 是可逆的，则 $\\mathbf{M}^+ = \\mathbf{M}^{-1}$，我们得到 $\\boldsymbol{\\lambda}$ 的唯一解。\n- 如果 $\\mathbf{M}$ 是奇异的，$\\boldsymbol{\\lambda} = \\mathbf{M}^+ \\mathbf{r}$ 给出最小化残差 $\\|\\mathbf{M}\\boldsymbol{\\lambda} - \\mathbf{r}\\|_2$ 的 $\\boldsymbol{\\lambda}$ 的最小欧几里得范数解。这产生了一个唯一的 $\\Delta \\mathbf{Y}$，它代表一个良态的、最小范数的校正。如果原始约束是一致的（即 $\\mathbf{r}$ 位于 $\\mathbf{M}$ 的列空间中），此过程将精确满足它们。如果它们不一致，它会找到一个最小二乘最佳拟合解。\n\n### 4. 算法实现\n\n要实现的完整算法如下：\n1. 对于一个给定的测试用例 $(\\mathbf{A}, \\mathbf{Z}, \\mathbf{Y}, Y_e, \\mathbf{w})$，构建相应的 `numpy` 向量。\n2. 计算初始约束值 $C_1(\\mathbf{Y})$ 和 $C_2(\\mathbf{Y})$，并构成残差向量 $\\mathbf{r} = (-C_1, -C_2)^\\top$。\n3. 构建约束矩阵 $\\mathbf{C}$ 和逆权重矩阵 $\\mathbf{W}^{-1} = \\mathrm{diag}(1/w_i)$。\n4. 构成 $2 \\times 2$ 矩阵 $\\mathbf{M} = \\mathbf{C} \\mathbf{W}^{-1} \\mathbf{C}^\\top$。\n5. 使用伪逆求解 Lagrange 乘子：$\\boldsymbol{\\lambda} = \\mathrm{pinv}(\\mathbf{M}) \\mathbf{r}$。\n6. 计算丰度调整向量：$\\Delta \\mathbf{Y} = \\mathbf{W}^{-1} \\mathbf{C}^\\top \\boldsymbol{\\lambda}$。\n7. 确定最终丰度向量 $\\mathbf{Y}' = \\mathbf{Y} + \\Delta \\mathbf{Y}$。\n8. 计算三个所需的输出量：\n    a. 加权调整范数：$\\sqrt{\\Delta \\mathbf{Y}^\\top \\mathbf{W} \\Delta \\mathbf{Y}}$。\n    b. 重子数守恒违背量的最终绝对值：$|C_1(\\mathbf{Y}')| = |\\mathbf{A}^\\top \\mathbf{Y}' - 1|$。\n    c. 电荷守恒违背量的最终绝对值：$|C_2(\\mathbf{Y}')| = |\\mathbf{Z}^\\top \\mathbf{Y}' - Y_e|$。\n为每个提供的测试用例实现此算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_projection(A_list, Z_list, Y_list, Ye, w_list):\n    \"\"\"\n    Performs the constrained minimization to project abundances onto the\n    manifold defined by baryon number and charge conservation.\n\n    Args:\n        A_list (list): List of baryon numbers for each species.\n        Z_list (list): List of charge numbers for each species.\n        Y_list (list): List of initial abundances for each species.\n        Ye (float): The target electron fraction.\n        w_list (list): List of weights for the minimization metric.\n\n    Returns:\n        list: A list containing three floats:\n              [adjustment_norm, final_C1_abs, final_C2_abs]\n    \"\"\"\n    A_vec = np.array(A_list, dtype=np.float64)\n    Z_vec = np.array(Z_list, dtype=np.float64)\n    Y_vec = np.array(Y_list, dtype=np.float64)\n    w_vec = np.array(w_list, dtype=np.float64)\n\n    # 1. Calculate initial constraint values (violations).\n    C1_initial = np.dot(A_vec, Y_vec) - 1.0\n    C2_initial = np.dot(Z_vec, Y_vec) - Ye\n\n    # 2. Define the RHS of the linear system for the adjustment vector delta_Y.\n    # The system is C @ delta_Y = r.\n    r_vec = np.array([-C1_initial, -C2_initial], dtype=np.float64)\n    \n    # If already conserved, no adjustment is needed.\n    if np.allclose(r_vec, 0.0):\n        return [0.0, 0.0, 0.0]\n\n    # 3. Construct matrices for the Lagrange multiplier system.\n    # The constraint matrix C has shape (2, n).\n    C_mat = np.array([A_vec, Z_vec])\n    # W_inv is a diagonal matrix with 1/w_i on the diagonal.\n    W_inv = np.diag(1.0 / w_vec)\n    \n    # 4. Form the 2x2 matrix M = C * W^-1 * C.T for the multiplier system.\n    M_mat = C_mat @ W_inv @ C_mat.T\n    \n    # 5. Solve for Lagrange multipliers lambda using the pseudoinverse for robustness.\n    # M * lambda = r  =>  lambda = M_pinv * r\n    M_pinv = np.linalg.pinv(M_mat)\n    lambda_vec = M_pinv @ r_vec\n    \n    # 6. Calculate the abundance adjustment vector delta_Y.\n    # delta_Y = W^-1 * C.T * lambda\n    delta_Y_vec = W_inv @ C_mat.T @ lambda_vec\n    \n    # 7. Calculate the final abundance vector.\n    Y_final_vec = Y_vec + delta_Y_vec\n    \n    # 8. Compute the required output metrics.\n    # a. Weighted adjustment norm: sqrt(delta_Y.T * W * delta_Y)\n    W_mat = np.diag(w_vec)\n    adj_norm_sq = delta_Y_vec.T @ W_mat @ delta_Y_vec\n    # Handle potential negative values due to floating point inaccuracies\n    adj_norm = np.sqrt(max(0, adj_norm_sq))\n\n    # b. Final constraint value C1\n    C1_final = np.dot(A_vec, Y_final_vec) - 1.0\n    \n    # c. Final constraint value C2\n    C2_final = np.dot(Z_vec, Y_final_vec) - Ye\n    \n    return [adj_norm, abs(C1_final), abs(C2_final)]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (general multi-species case):\n        {'A': [1, 1, 4, 12], 'Z': [1, 0, 2, 6], 'Y': [0.6, 0.3, 0.02, 0.01], 'Ye': 0.5, 'w': [1, 1, 1, 1]},\n        # Test case 2 (boundary with exactly two species and two constraints):\n        {'A': [1, 1], 'Z': [1, 0], 'Y': [0.55, 0.55], 'Ye': 0.45, 'w': [1, 1]},\n        # Test case 3 (rank-deficient constraints: identical Z_i/A_i ratio):\n        {'A': [4, 12, 16], 'Z': [2, 6, 8], 'Y': [0.1, 0.05, 0.01], 'Ye': 0.5, 'w': [1, 1, 1]},\n        # Test case 4 (non-uniform weights):\n        {'A': [1, 4], 'Z': [1, 2], 'Y': [0.99, 0.005], 'Ye': 0.9, 'w': [1, 5]},\n        # Test case 5 (already-conserved inputs):\n        {'A': [1, 1], 'Z': [1, 0], 'Y': [0.5, 0.5], 'Ye': 0.5, 'w': [1, 1]},\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = solve_projection(case['A'], case['Z'], case['Y'], case['Ye'], case['w'])\n        # Store string representation of list for final output formatting\n        results.append(str(result))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3525243"}]}