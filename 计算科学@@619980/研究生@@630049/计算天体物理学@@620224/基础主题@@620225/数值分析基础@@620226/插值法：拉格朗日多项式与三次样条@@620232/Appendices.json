{"hands_on_practices": [{"introduction": "这个实践将引导你解决一个数值分析中的经典挑战——龙格现象 (Runge's phenomenon)。通过对看似简单的龙格函数进行插值，你将直接观察到在等距节点上使用高次多项式所带来的陷阱。这个练习 [@problem_id:3515473] 突显了为什么审慎选择插值方法和节点布局对于获得准确且稳定的结果至关重要。", "problem": "在计算天体物理学中，从离散样本重建平滑的仪器响应函数或谱线轮廓需要稳健的插值方法。考虑闭区间 $[-1, 1]$ 上的解析测试函数 $f(x) = \\dfrac{1}{1 + 25 x^2}$。已知当在等距节点上使用高次全局多项式时，该函数会揭示插值不稳定性。你需要研究节点位置和插值方案如何影响最大误差。\n\n实现一个程序，使用 $N = n+1$ 个节点（其中 $n = 10$，因此插值多项式的次数为 $10$）执行以下任务：\n\n1. 使用两组节点，为 $[-1, 1]$ 上的 $f(x)$ 构建 $10$ 次拉格朗日多项式插值：\n   - 等距节点 $x_i = -1 + \\dfrac{2 i}{n}$，其中 $i = 0, 1, \\dots, n$。\n   - 第二类切比雪夫节点 $x_i = \\cos\\!\\left(\\dfrac{i \\pi}{n}\\right)$，其中 $i = 0, 1, \\dots, n$，角度 $\\pi$ 以弧度为单位。\n2. 使用相同的等距节点，构建一个自然三次样条插值（在端点处具有连续的一阶和二阶导数以及零二阶导数的分段三次多项式）。\n3. 对于每个插值，在一个由 $[-1, 1]$ 上均匀分布的 $M = 20001$ 个点组成的密集评估网格上，估计最大绝对插值误差。最大绝对插值误差定义为 $\\max_{x \\in \\mathcal{G}} \\left| f(x) - s(x) \\right|$，其中 $\\mathcal{G}$ 是评估网格，$s(x)$ 是插值函数。\n4. 此外，对于使用等距节点的 $10$ 次拉格朗日多项式，估计其在区间 $[-1, -0.9] \\cup [0.9, 1]$ 并集所给出的“边缘区域”内的最大绝对插值误差。对该边缘区域使用一个密集的评估网格，每个子区间包含 $5001$ 个点（在两个子区间内均均匀分布）。\n5. 不涉及物理单位。用于切比雪夫节点的余弦函数中的角度必须以弧度为单位。\n\n你的测试套件必须包括以下四种情况：\n- 情况 A：在 $[-1, 1]$ 上使用等距节点的 $10$ 次拉格朗日插值；以浮点数形式报告最大绝对误差。\n- 情况 B：在 $[-1, 1]$ 上使用第二类切比雪夫节点的 $10$ 次拉格朗日插值；以浮点数形式报告最大绝对误差。\n- 情况 C：在 $[-1, 1]$ 上使用等距节点的自然三次样条插值；以浮点数形式报告最大绝对误差。\n- 情况 D：使用等距节点的 $10$ 次拉格朗日插值，误差限制在 $[-1, -0.9] \\cup [0.9, 1]$ 区域；以浮点数形式报告最大绝对误差。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[resultA,resultB,resultC,resultD]”），每个条目都是十进制格式的浮点数。\n\n最后，在你的解题说明中，通过引用多项式插值误差的结构、节点放置对插值算子增长的影响，以及三次样条的平滑特性和局部性，来论证观察到的误差差异。", "solution": "该问题要求分析龙格函数 $f(x) = \\dfrac{1}{1 + 25 x^2}$ 在区间 $[-1, 1]$ 上使用不同插值方案和节点分布时的插值误差。我们将比较在等距节点和切比雪夫节点上的拉格朗日多项式插值，以及在等距节点上的自然三次样条插值。分析将基于最大绝对误差 $\\max |f(x) - s(x)|$，其中 $s(x)$ 是插值函数。\n\n多项式插值误差的理论基础由以下公式给出：\n$$E(x) = f(x) - P_n(x) = \\frac{f^{(n+1)}(\\xi_x)}{(n+1)!} \\prod_{i=0}^{n} (x - x_i)$$\n其中 $P_n(x)$ 是 $n$ 次插值多项式，$x_i$ 点是插值节点，而 $\\xi_x$ 是包含 $x$ 和所有节点 $x_i$ 的最小区间内的一个点。误差是两项的乘积：一项与函数导数有关，即 $\\frac{f^{(n+1)}(\\xi_x)}{(n+1)!}$；另一项与节点位置有关，即节点多项式 $\\omega_{n+1}(x) = \\prod_{i=0}^{n} (x - x_i)$。这两项的行为共同决定了插值的准确性。\n\n**情况 A：使用等距节点的拉格朗日插值**\n\n对于这种情况，我们使用一个次数为 $n=10$ 的单一多项式，它穿过 $N=11$ 个等距节点 $x_i = -1 + 2i/10$（其中 $i=0, \\dots, 10$）。龙格函数 $f(x)$ 在实数轴上是解析的，但其高阶导数增长非常迅速。例如，$f^{(12)}(0)$ 的数量级约为 $10^{11}$。这意味着 $\\frac{f^{(n+1)}(\\xi_x)}{(n+1)!}$ 这一项会变得非常大。\n\n同时，对于等距节点，节点多项式 $\\omega_{n+1}(x)$ 的量值在 $[-1, 1]$ 上并非均匀分布。它在区间中心的值相对较小，但在接近端点时呈指数级快速增长。在 $x = \\pm 1$ 附近，巨大的导数值与 $|\\omega_{n+1}(x)|$ 的大量值相结合，导致插值误差在区间边缘变得非常大。这导致插值函数出现剧烈振荡，这种现象被称为龙格现象。因此，我们预计在这种情况下会出现较大的最大绝对误差。\n\n**情况 D：等距拉格朗日插值的边缘区域误差**\n\n这种情况专门测量情况 A 的最大误差，但限制在“边缘区域” $[-1, -0.9] \\cup [0.9, 1]$ 内。如情况 A 所述，龙格现象表现为在插值区间端点附近出现大幅振荡且误差集中。因此，整个区间 $[-1, 1]$ 上的最大误差几乎肯定会出现在这个边缘区域内。我们预计情况 D 的结果将非常接近甚至等同于情况 A 的结果。\n\n**情况 B：使用切比雪夫节点的拉格朗日插值**\n\n这种情况使用相同的 $10$ 次拉格朗日多项式，但使用一组不同的节点：第二类切比雪夫节点，由 $x_i = \\cos(i\\pi/n)$ 给出（其中 $i=0, \\dots, n$）。这些节点是 $n$ 次切比雪夫多项式 $T_n(x)$ 的极值点。与等距节点不同，切比雪夫节点密集分布在区间 $[-1, 1]$ 的端点附近。\n\n这种特定的节点放置方式在某种意义上是最佳的，因为它最小化了节点多项式的最大绝对值，即 $\\|\\omega_{n+1}(x)\\|_{\\infty} = \\max_{x \\in [-1,1]} |\\prod_{i=0}^{n} (x-x_i)|$。通过最小化误差公式中的这个几何因子，使用切比雪夫节点的插值能有效抑制误差增长，即使对于具有较大高阶导数的函数也是如此。对于任何具有连续一阶导数的函数，该策略保证当 $n \\to \\infty$ 时，插值函数收敛于原函数。对于龙格函数，节点分布的这种改变极大地减少了端点附近的振荡，并与等距节点情况相比，产生了小得多的最大误差。\n\n**情况 C：自然三次样条插值**\n\n三次样条是另一种类型的插值函数。它不是在整个区间上使用单一的高次多项式，而是在每个子区间 $[x_i, x_{i+1}]$ 上使用一系列分段三次多项式。通过在内部节点处强制函数及其一阶和二阶导数的连续性，这些分段多项式被平滑地连接在一起。“自然”三次样条施加了额外的边界条件，即在端点（$x_0$ 和 $x_n$）处的二阶导数为零。\n\n样条插值的关键优势在于其*局部*性。在给定子区间 $[x_i, x_{i+1}]$ 内的插值主要由其紧邻的数据点决定。这个特性防止了困扰高次多项式插值的全局误差传播，使得样条插值能够避免龙格现象。三次样条的误差与 $h^4 \\max|f^{(4)}(x)|$ 成正比，其中 $h$ 是节点之间的最大间距。对于一个固定的函数和足够小的 $h$，这保证了良好的近似效果。考虑到我们使用的是与情况 A 中相同的等距节点，样条插值避免了大幅振荡，并有望产生一个较小的最大误差，其大小与该 $n$ 值下的切比雪夫多项式插值相当，甚至更优。样条插值为平滑数据的插值提供了一种稳定可靠的方法。", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator, CubicSpline\n\ndef solve():\n    \"\"\"\n    Computes interpolation errors for the Runge function using different methods.\n    \"\"\"\n    # Define the analytic test function\n    f = lambda x: 1.0 / (1.0 + 25.0 * x**2)\n\n    # --- Common Parameters ---\n    n = 10\n    N = n + 1  # Number of nodes\n    M = 20001  # Number of evaluation points for the full interval\n\n    # --- Evaluation Grids ---\n    # Dense grid for the full interval [-1, 1]\n    x_eval_full = np.linspace(-1.0, 1.0, M)\n    y_true_full = f(x_eval_full)\n\n    # Dense grid for the edge region [-1, -0.9] U [0.9, 1]\n    M_edge_per_interval = 5001\n    x_edge1 = np.linspace(-1.0, -0.9, M_edge_per_interval)\n    x_edge2 = np.linspace(0.9, 1.0, M_edge_per_interval)\n    x_eval_edge = np.concatenate((x_edge1, x_edge2))\n    y_true_edge = f(x_eval_edge)\n\n    # --- Node Sets ---\n    # Equispaced nodes\n    x_equi = np.linspace(-1.0, 1.0, N)\n    y_equi = f(x_equi)\n\n    # Chebyshev nodes of the second kind\n    i_cheby = np.arange(N)\n    x_cheby = np.cos(i_cheby * np.pi / n)\n    y_cheby = f(x_cheby)\n\n    results = []\n\n    # --- Case A: Lagrange with Equispaced Nodes on [-1, 1] ---\n    # This interpolant will also be used for Case D\n    poly_lagrange_equi = BarycentricInterpolator(x_equi, y_equi)\n    y_interp_A = poly_lagrange_equi(x_eval_full)\n    error_A = np.max(np.abs(y_true_full - y_interp_A))\n    results.append(error_A)\n\n    # --- Case B: Lagrange with Chebyshev Nodes on [-1, 1] ---\n    poly_lagrange_cheby = BarycentricInterpolator(x_cheby, y_cheby)\n    y_interp_B = poly_lagrange_cheby(x_eval_full)\n    error_B = np.max(np.abs(y_true_full - y_interp_B))\n    results.append(error_B)\n\n    # --- Case C: Natural Cubic Spline with Equispaced Nodes on [-1, 1] ---\n    spline_natural = CubicSpline(x_equi, y_equi, bc_type='natural')\n    y_interp_C = spline_natural(x_eval_full)\n    error_C = np.max(np.abs(y_true_full - y_interp_C))\n    results.append(error_C)\n\n    # --- Case D: Lagrange with Equispaced Nodes, Error on Edge Region ---\n    # Use the interpolant from Case A, evaluated on the edge grid\n    y_interp_D = poly_lagrange_equi(x_eval_edge)\n    error_D = np.max(np.abs(y_true_edge - y_interp_D))\n    results.append(error_D)\n\n    # Format and print the final output as a single line\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```", "id": "3515473"}, {"introduction": "在认识到三次样条是全局多项式的一个稳健替代方案后，本练习将深入探讨其实现的细微差别。你将使用表现良好的函数 $f(x) = e^x$ 来比较在“自然”与“钳制”边界条件下构建的样条。这个实践 [@problem_id:3515414] 将阐明如何利用函数在边界处的导数等额外信息来显著提高插值质量。", "problem": "考虑区间 $[0,1]$ 上的函数 $f(x)=e^{x}$。在计算天体物理学中，插值常用于从离散样本中重建平滑的剖面（例如，对数强度或光谱通量剖面）。两种广泛使用的插值方法是基于 Lagrange 多项式的多项式插值和基于三次样条的分段三次插值。插值函数的曲率具有物理意义，因为它衡量了局部弯曲并与平滑度相关；对于一个二阶可导函数 $y(x)$，其平面曲率 $\\kappa(x)$ 定义为\n$$\n\\kappa(x)=\\frac{\\lvert y''(x)\\rvert}{\\left(1+\\left(y'(x)\\right)^{2}\\right)^{3/2}}.\n$$\n三次样条被构造为分段三次多项式，在节点处满足 $y(x)$、$y'(x)$ 和 $y''(x)$ 的连续性，并在端点处强制施加边界条件。两种标准的端点条件是：自然边界条件，强制 $y''(0)=0$ 和 $y''(1)=0$；以及钳制边界条件，强制 $y'(0)=f'(0)$ 和 $y'(1)=f'(1)$，其中 $f'(x)=e^{x}$。\n\n您的任务是实现一个程序，对于 $[0,1]$ 上的几组节点集，在自然和钳制两种边界条件下构造 $f(x)=e^{x}$ 的三次样条插值，并比较：\n- 每种样条在 $[0,1]$ 上的最大曲率，以及\n- 最大内部插值误差，定义为 $\\max_{x\\in(0,1)}\\lvert S(x)-f(x)\\rvert$，其中 $S(x)$ 是样条插值函数。\n\n您必须在 $[0,1]$ 上使用一个包含 $M=10001$ 个点的均匀细网格来数值逼近最大值。内部误差的计算必须排除端点 $x=0$ 和 $x=1$。插值节点 $\\{x_{k}\\}_{k=0}^{n-1}$ 必须选择为以下两种之一：\n- 均匀节点，$x_{k}=\\frac{k}{n-1}$，或\n- 映射到 $[0,1]$ 的 Chebyshev 型节点，$x_{k}=\\frac{1}{2}\\left(1-\\cos\\left(\\frac{\\pi k}{n-1}\\right)\\right)$。\n\n对于下方的每个测试用例，执行以下操作：\n1. 使用给定的节点和样本 $y_{k}=f(x_{k})$ 构造自然三次样条和钳制三次样条。\n2. 在细网格上计算每种样条的最大曲率 $\\max_{x\\in[0,1]}\\kappa(x)$。\n3. 在同一细网格上计算每种样条的最大内部误差 $\\max_{x\\in(0,1)}\\lvert S(x)-f(x)\\rvert$，不包括端点。\n\n测试套件（每个测试用例是一个序对 $(n,\\text{distribution})$）：\n- $(5,\\text{uniform})$\n- $(8,\\text{uniform})$\n- $(8,\\text{chebyshev})$\n- $(17,\\text{uniform})$\n\n所有量都是无量纲的；不需要物理单位。三角函数中出现的角度，单位为弧度。您的程序必须生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个格式为 $[C_{\\mathrm{nat}},C_{\\mathrm{clamp}},E_{\\mathrm{nat}},E_{\\mathrm{clamp}}]$ 的列表，每个浮点数四舍五入到八位小数。例如，一个有效的整体输出格式是\n$$\n\\big[ [\\ldots,\\ldots,\\ldots,\\ldots], [\\ldots,\\ldots,\\ldots,\\ldots], [\\ldots,\\ldots,\\ldots,\\ldots], [\\ldots,\\ldots,\\ldots,\\ldots] \\big].\n$$", "solution": "本问题旨在比较函数 $f(x)=e^x$ 在区间 $[0,1]$ 上，使用两种不同边界条件（自然和钳制）的三次样条插值的性能。性能通过两个指标来衡量：插值函数的最大曲率和区间内部的最大插值误差。\n\n三次样条是分段三次多项式，通过在节点处要求函数值、一阶导数和二阶导数连续来保证其光滑性。为了唯一定义样条，必须在区间的两个端点施加边界条件。\n- **自然样条 ($S_{\\mathrm{nat}}$)** 施加 $S''_{\\mathrm{nat}}(0)=0$ 和 $S''_{\\mathrm{nat}}(1)=0$ 的条件。当函数在边界处的行为未知时，这是一种常用选择，因为它能最小化样条的总弯曲能。\n- **钳制样条 ($S_{\\mathrm{clamp}}$)** 利用了函数在边界处一阶导数的已知信息，强制 $S'_{\\mathrm{clamp}}(0) = f'(0)$ 和 $S'_{\\mathrm{clamp}}(1) = f'(1)$。对于 $f(x)=e^x$，这意味着我们精确地设定了边界斜率为 $f'(0)=1$ 和 $f'(1)=e$。\n\n由于钳制样条包含了关于被插值函数更多的精确信息，我们预期它会比自然样条提供更准确的近似。自然样条的边界条件与 $f(x)=e^x$ 的真实二阶导数 $f''(x)=e^x$（在 $x=0$ 和 $x=1$ 处分别为 $1$ 和 $e$）不符，这会在边界附近引入误差。\n\n求解过程对每个测试用例执行以下步骤：\n1.  根据指定的分布（均匀或切比雪夫）生成节点集 $\\{x_k\\}$。\n2.  在节点上采样函数值 $y_k = e^{x_k}$。\n3.  使用 `scipy.interpolate.CubicSpline` 分别构建自然样条 (`bc_type='natural'`) 和钳制样条 (`bc_type=((1, 1.0), (1, np.e))`)。\n4.  在一个密集的评估网格上，计算每个样条的一阶和二阶导数，从而得到最大曲率 $\\max \\kappa(x)$。\n5.  在同一网格的内部点上，计算最大插值误差 $\\max |S(x) - f(x)|$。\n6.  将四个计算出的指标 $(C_{\\mathrm{nat}}, C_{\\mathrm{clamp}}, E_{\\mathrm{nat}}, E_{\\mathrm{clamp}})$ 汇总并格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Constructs natural and clamped cubic splines for f(x)=e^x on [0,1]\n    and computes their maximum curvature and maximum interior error for\n    several node configurations.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (5, 'uniform'),\n        (8, 'uniform'),\n        (8, 'chebyshev'),\n        (17, 'uniform')\n    ]\n\n    all_results = []\n\n    # Setup for numerical approximation\n    M = 10001\n    # Fine grid for evaluating curvature and error\n    x_fine = np.linspace(0, 1, M)\n    # Interior part of the fine grid for error calculation\n    x_fine_interior = x_fine[1:-1]\n    \n    # Pre-calculate true function values on the grids\n    f_x_interior = np.exp(x_fine_interior)\n\n    for n, dist in test_cases:\n        # 1. Generate interpolation nodes\n        if dist == 'uniform':\n            nodes_x = np.linspace(0, 1, n)\n        elif dist == 'chebyshev':\n            k = np.arange(n)\n            nodes_x = 0.5 * (1 - np.cos(np.pi * k / (n - 1)))\n        \n        # 2. Sample the function at the nodes\n        nodes_y = np.exp(nodes_x)\n\n        # 3. Construct natural cubic spline and evaluate metrics\n        spline_nat = CubicSpline(nodes_x, nodes_y, bc_type='natural')\n        \n        # Derivatives for curvature\n        S1_nat_vals = spline_nat(x_fine, 1)\n        S2_nat_vals = spline_nat(x_fine, 2)\n        \n        # Maximum curvature for natural spline\n        kappa_nat_vals = np.abs(S2_nat_vals) / (1 + S1_nat_vals**2)**1.5\n        C_nat = np.max(kappa_nat_vals)\n        \n        # Maximum interior error for natural spline\n        error_nat_vals = np.abs(spline_nat(x_fine_interior) - f_x_interior)\n        E_nat = np.max(error_nat_vals)\n\n        # 4. Construct clamped cubic spline and evaluate metrics\n        f_prime_0 = 1.0\n        f_prime_1 = np.e\n        spline_clamp = CubicSpline(nodes_x, nodes_y, bc_type=((1, f_prime_0), (1, f_prime_1)))\n        \n        # Derivatives for curvature\n        S1_clamp_vals = spline_clamp(x_fine, 1)\n        S2_clamp_vals = spline_clamp(x_fine, 2)\n        \n        # Maximum curvature for clamped spline\n        kappa_clamp_vals = np.abs(S2_clamp_vals) / (1 + S1_clamp_vals**2)**1.5\n        C_clamp = np.max(kappa_clamp_vals)\n        \n        # Maximum interior error for clamped spline\n        error_clamp_vals = np.abs(spline_clamp(x_fine_interior) - f_x_interior)\n        E_clamp = np.max(error_clamp_vals)\n\n        # 5. Collect results for the current test case\n        case_results = [C_nat, C_clamp, E_nat, E_clamp]\n        all_results.append(case_results)\n\n    # 6. Format the final output string as specified\n    formatted_cases = []\n    for case_res in all_results:\n        formatted_cases.append(f\"[{','.join(f'{val:.8f}' for val in case_res)}]\")\n    \n    print(f\"[{','.join(formatted_cases)}]\")\n\nsolve()\n```", "id": "3515414"}, {"introduction": "最后一个实践将理论与应用联系起来，解决了一个源于天体物理学中常见任务——大气射线追踪的问题。挑战在于插值一个已知的单调行进时间函数，插值结果中的任何非单调行为都将代表非物理的“多路径”解。通过比较标准的拉格朗日多项式和保形三次样条 (PCHIP)，你将学习如何强制施加物理约束，并避免在数值模型中产生虚假的 artifacts [@problem_id:3515484]。", "problem": "考虑一个分层的平面平行大气，其折射率模型为 $n(z) = 1 + \\beta \\exp(-z/H)$，其中 $z$ 是以米为单位的高度，$\\beta$ 是一个小的无量纲参数，$H$ 是以米为单位的标高。假设电磁波射线以高出当地地平线的仰角 $\\theta$ 沿直线从 $z=0$ 传播到 $z=z_{\\max}$。设真空中的光速为 $c$。在直线假设下，沿路径的传播时间 $T(\\theta)$ 服从路径积分 $T(\\theta) = \\dfrac{1}{c \\sin \\theta} \\int_{0}^{z_{\\max}} n(z)\\,dz$，这在折射率小、弯曲可忽略不计的情况下是有效的。\n\n您的任务是实现 $T(\\theta)$（作为在有限数量节点上采样的 $\\theta$ 的函数）的 $C^1$ 三次样条插值，推导有原则的条件以防止插值函数产生在底层 $T(\\theta)$ 中不存在的虚假多路径极小值，并将其与在相同节点上构建的全局拉格朗日多项式插值的行为进行比较。在计算天体物理学中，此类插值出现在通过分层介质（例如，行星大气或恒星包层）进行射线追踪时，而虚假的极小值可能导致人为的多路径解，从而歪曲物理现实。\n\n使用的基本基准和参数：\n- 使用 $c = 3\\times 10^8\\,\\text{m/s}$。\n- 使用 $\\beta = 3\\times 10^{-4}$ 和 $H = 8\\times 10^3\\,\\text{m}$。\n- 使用 $z_{\\max} = 1\\times 10^5\\,\\text{m}$。\n- 计算步骤中的角度必须以弧度为单位；下面的输入节点规范以度为单位给出，在计算前必须转换为弧度。\n\n定义和要求：\n- 精确函数为 $T(\\theta) = \\dfrac{1}{c \\sin \\theta} \\int_{0}^{z_{\\max}} \\left(1 + \\beta e^{-z/H}\\right) dz$。您必须使用此精确的 $T(\\theta)$ 在采样节点上生成数据值；不要对路径进行数值射线追踪。\n- 通过分段三次埃尔米特插值多项式 (PCHIP) 实现一个 $C^1$ 保形三次样条，使用 Fritsch–Carlson 斜率限制，以在采样数据在 $\\theta$ 上单调时保持单调性。\n- 使用相同的采样节点，实现 $N$ 个节点的 $N-1$ 次全局拉格朗日多项式插值。\n- 从第一性原理出发，推导插值函数和采样的条件，以防止在定义域内插值的 $T(\\theta)$ 中出现虚假的多路径极小值。您的推导必须从单调函数的定义及其导数符号，以及单调数据的三次埃尔米特斜率限制规则开始。将这些与涉及 $T(\\theta)$ 的二阶导数和节点间距的界限联系起来，这有助于避免由离散化引起的割线斜率符号变化。这些条件必须以数学和逻辑方式表达；不要依赖于超出这些基本原理的任何捷径公式。\n- 通过在密集网格上对每个插值函数进行采样并检测内部局部极小值（不包括端点）来数值验证虚假极小值的存在与否。虚假极小值定义为这样一个内部点，在该点离散化的导数从负变为正，而精确的 $T(\\theta)$ 在定义域内没有内部极小值。\n\n测试套件：\n对于每个测试用例，在指定区间上使用以度为单位的等距节点，将它们转换为弧度进行计算，在这些节点上精确评估 $T(\\theta)$，然后构建两种插值函数。对于每种情况，在给定的评估角度（以度为单位）下评估两种插值函数，并计算相对于精确 $T(\\theta)$ 的绝对误差。同时报告布尔标志，指示当在 $2000$ 个点的密集网格上采样时，每个插值函数是否在区间内表现出至少一个虚假的内部极小值。\n- 情况 A（理想情况）：$\\theta \\in [10^\\circ, 80^\\circ]$，$N=9$ 个节点，评估角度 $\\theta^\\ast = 50^\\circ$。\n- 情况 B（稀疏采样边界）：$\\theta \\in [5^\\circ, 85^\\circ]$，$N=5$ 个节点，评估角度 $\\theta^\\ast = 30^\\circ$。\n- 情况 C（高次全局插值）：$\\theta \\in [5^\\circ, 85^\\circ]$，$N=13$ 个节点，评估角度 $\\theta^\\ast = 20^\\circ$。\n- 情况 D（靠近边缘且节点多）：$\\theta \\in [5^\\circ, 85^\\circ]$，$N=17$ 个节点，评估角度 $\\theta^\\ast = 15^\\circ$。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含所有四种情况的汇总结果，形式为方括号内的一个逗号分隔列表。对于每种情况，按顺序输出四个项目：PCHIP 插值在 $\\theta^\\ast$ 处的绝对误差（一个浮点数，单位为秒），拉格朗日插值在 $\\theta^\\ast$ 处的绝对误差（一个浮点数，单位为秒），一个指示 PCHIP 插值是否有任何虚假内部极小值的布尔值，以及一个指示拉格朗日插值是否有任何虚假内部极小值的布尔值。因此，最终输出应总共包含 $16$ 个项目，按情况 A、情况 B、情况 C 和情况 D 的项目顺序排列。角度必须在内部转换为弧度，所有时间量均以秒为单位。输出必须采用确切格式\n$[r_1,r_2,\\dots,r_{16}]$\n布尔值格式化为 $True$ 或 $False$，浮点数采用标准十进制表示法。", "solution": "该问题的核心是插值一个具有严格单调性的物理函数——射线传播时间 $T(\\theta)$，并验证不同插值方法保持这种物理约束的能力。任何违反单调性的行为（如产生虚假的局部极小值）都是非物理的。\n\n首先，我们推导 $T(\\theta)$ 的解析形式。通过对给定的折射率模型 $n(z) = 1 + \\beta e^{-z/H}$ 沿直线路径积分，我们得到传播时间为 $T(\\theta) = K / \\sin\\theta = K \\csc\\theta$，其中 $K = \\frac{z_{\\max} + \\beta H (1 - e^{-z_{\\max}/H})}{c}$ 是一个依赖于大气参数的常数。\n\n接下来，对 $T(\\theta)$ 的性质进行分析。\n- **一阶导数:** $T'(\\theta) = -K \\csc\\theta \\cot\\theta$。在物理相关的区间 $\\theta \\in (0, \\pi/2)$ 内，由于 $K, \\csc\\theta, \\cot\\theta$ 均为正，所以 $T'(\\theta)$ 恒为负。这证明了 $T(\\theta)$ 是一个**严格单调递减**的函数。\n- **二阶导数:** $T''(\\theta) = K \\csc\\theta (2\\csc^2\\theta - 1)$。在该区间内，此导数恒为正，表明该函数是**严格凸**的。\n因此，精确的物理模型中不存在任何内部局部极小值。插值的挑战在于，数值近似函数是否能尊重这种单调性。\n\n我们比较两种插值方法：\n1.  **分段三次埃尔米特插值多项式 (PCHIP):** 该方法被设计为一种**保形**插值。当应用于单调的数据集时（如此处的采样点），其内置的 Fritsch–Carlson 斜率限制算法能确保所构造的插值函数在整个区间内也保持单调性。因此，PCHIP 从根本上避免了产生非物理的虚假极小值。\n2.  **全局拉格朗日多项式:** 作为一个单一的高次多项式，它不具备内在的保形特性。尤其是在使用等距节点时，它很容易在节点之间产生振荡（龙格现象）。这些振荡可能导致其导数改变符号，从而产生非物理的局部极小值。当多项式次数较高，且插值区间包含函数高阶导数较大的区域（例如小角度 $\\theta$）时，这种风险尤其高。\n\n综上所述，我们预期PCHIP将准确地保持单调性，而拉格朗日插值可能会失败并产生虚假的极小值。数值实现部分通过在密集网格上检查插值函数是否存在任何增量（即 `y[i+1] > y[i]`）来验证这些预测，因为对于单调递减函数，任何增量都标志着一个虚假极小值的存在。", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator, lagrange\n\ndef solve():\n    \"\"\"\n    Solves the interpolation problem by comparing PCHIP and Lagrange methods.\n\n    The solution performs the following steps for each test case:\n    1. Defines physical constants and calculates the analytical form of the travel time T(theta).\n    2. Generates a set of N equally spaced nodes (theta_i, y_i) from the exact function.\n    3. Constructs a PCHIP (shape-preserving) cubic spline interpolant.\n    4. Constructs a global Lagrange polynomial interpolant.\n    5. For each interpolant, it calculates the absolute error at a specific evaluation angle theta*.\n    6. It checks for the presence of spurious interior minima by sampling the interpolant on a\n       dense grid and verifying if the function's monotonicity is violated.\n    7. Aggregates and prints the results in the specified format.\n    \"\"\"\n    # Define physical constants and model parameters\n    c = 3.0e8  # Speed of light in m/s\n    beta = 3.0e-4  # Dimensionless refractive index parameter\n    H = 8.0e3  # Atmospheric scale height in meters\n    z_max = 1.0e5  # Maximum integration altitude in meters\n\n    # Pre-calculate the constant factor K for T(theta) = K / sin(theta)\n    # The integral part is z_max + beta * H * (1 - exp(-z_max / H))\n    integral_val = z_max + beta * H * (1 - np.exp(-z_max / H))\n    K = integral_val / c\n\n    def T_exact(theta_deg):\n        \"\"\"Calculates the exact travel time T for a given angle in degrees.\"\"\"\n        # Ensure input is a float array for vectorized operations\n        theta_deg_arr = np.atleast_1d(theta_deg).astype(float)\n        # Avoid division by zero at 0 or 180 degrees\n        # Very small angles can still lead to large results, which is physically correct\n        theta_rad = np.deg2rad(theta_deg_arr)\n        \n        # Using a mask for invalid angles to avoid warnings and return inf\n        invalid_mask = np.isclose(np.sin(theta_rad), 0.0)\n        result = np.full_like(theta_rad, np.inf)\n        valid_mask = ~invalid_mask\n        result[valid_mask] = K / np.sin(theta_rad[valid_mask])\n        \n        return result[0] if result.size == 1 else result\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (theta_min_deg, theta_max_deg, N_nodes, theta_star_deg)\n        (10.0, 80.0, 9, 50.0),   # Case A\n        (5.0, 85.0, 5, 30.0),    # Case B\n        (5.0, 85.0, 13, 20.0),   # Case C\n        (5.0, 85.0, 17, 15.0),   # Case D\n    ]\n    \n    # Dense grid for checking for spurious minima\n    DENSE_GRID_POINTS = 2000\n\n    results = []\n\n    for case in test_cases:\n        theta_min_deg, theta_max_deg, N, theta_star_deg = case\n\n        # Generate N equally spaced nodes for interpolation\n        theta_nodes_deg = np.linspace(theta_min_deg, theta_max_deg, N)\n        theta_nodes_rad = np.deg2rad(theta_nodes_deg)\n        \n        # Evaluate T at the nodes to get the data values\n        y_nodes = T_exact(theta_nodes_deg)\n\n        # 1. PCHIP Interpolation\n        pchip_interpolator = PchipInterpolator(theta_nodes_rad, y_nodes)\n        \n        # Evaluate at the specified angle theta*\n        theta_star_rad = np.deg2rad(theta_star_deg)\n        pchip_val_at_star = pchip_interpolator(theta_star_rad)\n        \n        # Calculate absolute error\n        exact_val_at_star = T_exact(theta_star_deg)\n        pchip_abs_error = np.abs(pchip_val_at_star - exact_val_at_star)\n\n        # Check for spurious minima in PCHIP interpolant\n        theta_dense_rad = np.linspace(np.deg2rad(theta_min_deg), np.deg2rad(theta_max_deg), DENSE_GRID_POINTS)\n        pchip_dense_vals = pchip_interpolator(theta_dense_rad)\n        # A spurious minimum exists if the function increases at any point,\n        # as the true function is strictly decreasing.\n        pchip_has_spurious_minima = np.any(np.diff(pchip_dense_vals) > 0)\n        \n        # 2. Lagrange Interpolation\n        lagrange_poly = lagrange(theta_nodes_rad, y_nodes)\n\n        # Evaluate at theta*\n        lagrange_val_at_star = lagrange_poly(theta_star_rad)\n        \n        # Calculate absolute error\n        lagrange_abs_error = np.abs(lagrange_val_at_star - exact_val_at_star)\n\n        # Check for spurious minima in Lagrange interpolant\n        lagrange_dense_vals = lagrange_poly(theta_dense_rad)\n        lagrange_has_spurious_minima = np.any(np.diff(lagrange_dense_vals) > 0)\n\n        results.extend([\n            pchip_abs_error,\n            lagrange_abs_error,\n            bool(pchip_has_spurious_minima),\n            bool(lagrange_has_spurious_minima)\n        ])\n    \n    # Format the final output string as a list of comma-separated values\n    formatted_results = [f\"{val}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3515484"}]}