{"hands_on_practices": [{"introduction": "任何计算模型都构建在其所用机器的算术基础之上。要编写稳健的数值代码，首先必须理解并量化这一基础的局限性。本练习将指导你通过数值方法确定两个关键常数：机器精度 $\\varepsilon_{\\text{mach}}$ 和单位舍入误差 $u$。通过实现算法来寻找这些值并与理论值进行比较，你将对浮点数的间距和舍入行为有一个具体的理解，并将其应用于分析一个常见天体物理计算中的灾难性相消问题。[@problem_id:3510974]", "problem": "在计算天体物理学中，数值模拟依赖于浮点运算的行为。电气和电子工程师协会（IEEE）754标准定义了一个二进制浮点系统，其特征在于基数 $\\,\\beta\\,$、精度 $\\,p\\,$（尾数中的有效位数，包括规格化数的隐含前导位）和一个舍入规则。当采用“向最近舍入，偶数优先”的规则时，靠近 $\\,1\\,$ 的连续规格化浮点数之间的间距为 $\\,\\varepsilon_{\\mathrm{mach}} = \\beta^{1-p}\\,$，而单位舍入误差 $\\,u\\,$（出现在标准舍入模型 $\\,\\operatorname{fl}(x \\circ y) = (x \\circ y)(1 + \\delta)\\,$ 中的界限，其中对于基本运算 $\\,\\circ \\in \\{+, -, \\times, \\div\\}$，有 $\\,|\\delta| \\le u\\,$）为 $\\,u = \\frac{1}{2}\\beta^{1-p}\\,$。\n\n你需要实现一个鲁棒的数值算法，在执行平台上计算两种IEEE 754二进制格式的单位舍入误差 $\\,u\\,$ 和机器 epsilon $\\,\\varepsilon_{\\mathrm{mach}}\\,$：\n- Binary64（双精度），其中 $\\,\\beta = 2\\,$ 且 $\\,p = 53\\,$。\n- Binary32（单精度），其中 $\\,\\beta = 2\\,$ 且 $\\,p = 24\\,$。\n\n然后，将你计算出的值与根据 $\\,\\beta\\,$ 和 $\\,p\\,$ 推导出的理论值进行比较，并根据定义和舍入行为解释任何差异。最后，评估机器精度对一个涉及对消的数值敏感的天体物理计算的影响。\n\n使用的定义：\n- 机器 epsilon $\\,\\varepsilon_{\\mathrm{mach}}\\,$ 是间隙 $\\,\\operatorname{nextafter}(1, 2) - 1\\,$，其中 $\\,\\operatorname{nextafter}\\,$ 返回朝向 $\\,2\\,$ 方向的下一个可表示的浮点数。\n- 单位舍入误差 $\\,u\\,$ 是使得 $\\,1 + \\eta\\,$ 舍入后严格大于 $\\,1\\,$ 的最小正数 $\\,\\eta\\,$。在“向最近舍入，偶数优先”的规则下，此阈值等于 $\\,\\varepsilon_{\\mathrm{mach}}/2\\,$。\n\n算法要求：\n1. 实现一个鲁棒的循环来计算给定浮点类型的 $\\,u\\,$：从 $\\,\\eta = 1\\,$ 开始，并重复将 $\\,\\eta\\,$ 减半，直到 $\\,1 + \\eta = 1\\,$；等式成立前的上一个 $\\,\\eta\\,$ 值即为 $\\,u\\,$。此方法必须使用目标数据类型，而不是更高精度的中间值。\n2. 使用目标类型中在 $\\,1\\,$ 处的 $\\,\\operatorname{nextafter}\\,$ 来计算 $\\,\\varepsilon_{\\mathrm{mach}}\\,$，以避免依赖于减半的算术序列。\n3. 对于指定的 $\\,(\\beta, p)\\,$，使用 $\\,\\varepsilon_{\\mathrm{th}} = \\beta^{1-p}\\,$ 和 $\\,u_{\\mathrm{th}} = \\frac{1}{2}\\beta^{1-p} = \\beta^{-p}\\,$ 计算理论值。\n\n天体物理对消评估：\n考虑牛顿引力下圆形轨道的单位质量比轨道能，$\\,E(r) = -\\frac{G M}{2 r}\\,$。为了本次数值评估的目的，设 $\\,G M = 1\\,$，因此在这些归一化单位中，$\\,E(r) = -\\frac{1}{2 r}\\,$ 是无量纲的。半径 $\\,r_1\\,$ 和 $\\,r_2\\,$ 之间的比能量差为\n$$\n\\Delta E = E(r_2) - E(r_1) = -\\frac{1}{2}\\left(\\frac{1}{r_2} - \\frac{1}{r_1}\\right).\n$$\n当 $\\,r_1 \\approx r_2\\,$ 时，用浮点运算直接计算 $\\,\\Delta E\\,$ 会因对消而产生误差。在标准一阶舍入模型下，用两次除法和一次减法计算 $\\,\\Delta E\\,$ 的相对误差满足以下界限\n$$\n\\frac{\\left|\\Delta E_{\\mathrm{comp}} - \\Delta E_{\\mathrm{true}}\\right|}{\\left|\\Delta E_{\\mathrm{true}}\\right|} \\;\\lesssim\\; \\left(\\frac{\\left|\\frac{1}{r_1}\\right| + \\left|\\frac{1}{r_2}\\right|}{\\left|\\frac{1}{r_2} - \\frac{1}{r_1}\\right|} + 1\\right) u,\n$$\n忽略 $\\,u\\,$ 的二阶项。你必须对双精度（binary64）格式在数值上验证这个不等式，允许一个2倍的因子。\n\n测试套件：\n- 测试用例1（binary64）：计算绝对误差 $\\,|u_{\\mathrm{num}} - u_{\\mathrm{th}}|\\,$ 和 $\\,|\\varepsilon_{\\mathrm{num}} - \\varepsilon_{\\mathrm{th}}|\\,$。\n- 测试用例2（binary32）：计算绝对误差 $\\,|u_{\\mathrm{num}} - u_{\\mathrm{th}}|\\,$ 和 $\\,|\\varepsilon_{\\mathrm{num}} - \\varepsilon_{\\mathrm{th}}|\\,$。\n- 测试用例3（对消，中等程度）：$\\,r_1 = 10^8\\,$, $\\,r_2 = 10^8 + 1\\,$，使用binary64算术计算 $\\,\\Delta E_{\\mathrm{comp}}\\,$ 和高精度参考值计算 $\\,\\Delta E_{\\mathrm{true}}\\,$，判断测量的 $\\,\\Delta E\\,$ 相对误差是否小于或等于上述界限的 $\\,2\\,$ 倍。\n- 测试用例4（对消，极端情况）：$\\,r_1 = 1\\,$, $\\,r_2 = \\operatorname{nextafter}(1, 2)\\,$，执行与测试用例3中相同的界限检查。\n\n高精度参考值：\n使用编程语言标准库中的高精度算术来计算 $\\,\\Delta E_{\\mathrm{true}}\\,$，以确保其任何浮点舍入误差与正在评估的binary64误差相比都可以忽略不计。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n$$\n[\\;|u_{64,\\mathrm{num}} - u_{64,\\mathrm{th}}|,\\;|\\varepsilon_{64,\\mathrm{num}} - \\varepsilon_{64,\\mathrm{th}}|,\\;|u_{32,\\mathrm{num}} - u_{32,\\mathrm{th}}|,\\;|\\varepsilon_{32,\\mathrm{num}} - \\varepsilon_{32,\\mathrm{th}}|,\\;\\text{bound\\_ok\\_case3},\\;\\text{bound\\_ok\\_case4}\\;],\n$$\n其中前四项是浮点数，后两项是布尔值。由于归一化 $\\,G M = 1\\,$，不涉及物理单位；所有量都是无量纲的。程序必须是自包含的，并且不需要任何输入。", "solution": "该问题是有效的，因为它科学地基于IEEE 754浮点运算和牛顿力学的原理，提法恰当，提供了所有必要信息，并且其表述是客观的。问题的核心涉及实现和验证与机器精度相关的标准定义和误差界，这是计算科学中的一个基本课题。问题中为单位舍入误差 $u$ 提供的算法中表面上的差异，是一个刻意设计的特性，旨在测试对浮点行为中微妙但关键细节的理解，特别是“向最近舍入，偶数优先”的规则。\n\n解决方案主要分为两部分。首先，我们为binary64和binary32两种格式计算机器精度常数，即单位舍入误差 $u$ 和机器 epsilon $\\varepsilon_{\\mathrm{mach}}$，并将数值上获得的值与它们的理论对应值进行比较。其次，我们使用binary64算术评估灾难性对消对一个实际的天体物理计算的影响，并验证一个标准的一阶误差界。\n\n**第一部分：机器精度常数的计算**\n\n问题指定了两种格式：基数 $\\beta=2$、精度 $p=53$ 的binary64（双精度），以及基数 $\\beta=2$、精度 $p=24$ 的binary32（单精度）。\n\n机器 epsilon ($\\varepsilon_{\\mathrm{th}}$) 和单位舍入误差 ($u_{\\mathrm{th}}$) 的理论值由这些参数导出：\n- 机器 epsilon: $\\varepsilon_{\\mathrm{th}} = \\beta^{1-p}$。\n- 单位舍入误差: 对于 $\\beta=2$，$u_{\\mathrm{th}} = \\frac{1}{2}\\beta^{1-p} = \\beta^{-p}$。\n\n对于binary64，这给出：\n- $\\varepsilon_{64,\\mathrm{th}} = 2^{1-53} = 2^{-52} \\approx 2.22 \\times 10^{-16}$。\n- $u_{64,\\mathrm{th}} = 2^{-53} \\approx 1.11 \\times 10^{-16}$。\n\n对于binary32，这给出：\n- $\\varepsilon_{32,\\mathrm{th}} = 2^{1-24} = 2^{-23} \\approx 1.19 \\times 10^{-7}$。\n- $u_{32,\\mathrm{th}} = 2^{-24} \\approx 5.96 \\times 10^{-8}$。\n\n这些值的数值计算遵循两种不同且指定的算法。\n\n首先，数值机器 epsilon $\\varepsilon_{\\mathrm{num}}$，是使用函数 $\\operatorname{nextafter}(x, y)$ 计算的，该函数给出从 x 朝 y 方向的下一个可表示浮点数。根据定义，对于1附近的规格化数，$\\varepsilon_{\\mathrm{mach}}$ 是从1到下一个更大的可表示数之间的距离。因此，我们计算 $\\varepsilon_{\\mathrm{num}} = \\operatorname{nextafter}(1.0, 2.0) - 1.0$。这个计算针对 `numpy.float64` 和 `numpy.float32` 类型都执行。我们预期 $\\varepsilon_{\\mathrm{num}}$ 将精确等于 $\\varepsilon_{\\mathrm{th}}$，因为这是间隙的定义。\n\n其次，数值单位舍入误差 $u_{\\mathrm{num}}$，是通过一个指定的循环算法计算的：从 $\\eta = 1$ 开始，并重复将其减半，直到浮点加法 $1+\\eta$ 的计算结果为 $1$。在这个等式成立*之前*的迭代中 $\\eta$ 的值被取为 $u_{\\mathrm{num}}$。对该算法在IEEE 754“向最近舍入，偶数优先”规则下的关键性分析揭示了一个微妙但重要的细节。当 $\\eta$ 恰好是两个连续浮点数之间间隙的一半时，和 $1.0 + \\eta$ 会发生舍入平局。对于数字 $1.0$，下一个可表示的值是 $1.0 + \\varepsilon_{\\mathrm{mach}}$。中点是 $1.0 + \\varepsilon_{\\mathrm{mach}}/2 = 1.0 + u_{\\mathrm{th}}$。由于 $1.0$ 的尾数（即 $1.0...0 \\times 2^0$）是偶数，平局决胜规则规定 $1.0 + u_{\\mathrm{th}}$ 向下舍入到 $1.0$。因此，当 $\\eta$ 被减半到 $u_{\\mathrm{th}}$ 的值时，循环条件 $1.0 + \\eta > 1.0$ 将为假。条件为真的最后一个 $\\eta$ 值是 $2 \\cdot u_{\\mathrm{th}} = \\varepsilon_{\\mathrm{mach}}$。因此，如上所述的算法返回的是 $\\varepsilon_{\\mathrm{mach}}$。所以，我们预测数值计算出的值，记为 $u_{\\mathrm{num}}$，将等于 $\\varepsilon_{\\mathrm{mach}}$，而不是 $u_{\\mathrm{th}}$。绝对误差 $|u_{\\mathrm{num}} - u_{\\mathrm{th}}|$ 因此将是 $| \\varepsilon_{\\mathrm{mach}} - u_{\\mathrm{th}} | = | 2u_{\\mathrm{th}} - u_{\\mathrm{th}} | = u_{\\mathrm{th}} \\neq 0$。这个差异不是计算中的缺陷，而是对定义模糊性和浮点舍入精确行为的一个说明。\n\n**第二部分：天体物理对消评估**\n\n问题的第二部分研究了在计算比轨道能变化 $\\Delta E = E(r_2) - E(r_1)$ 时的灾难性对消，其中在归一化单位中 $E(r) = -1/(2r)$。朴素的计算公式是 $\\Delta E_{\\mathrm{comp}} = -0.5 \\times (1/r_2 - 1/r_1)$。当 $r_1 \\approx r_2$ 时，项 $1/r_1$ 和 $1/r_2$ 几乎相等，它们的减法导致相对精度的严重损失。\n\n问题提供了一个一阶相对误差界：\n$$ \\frac{|\\Delta E_{\\mathrm{comp}} - \\Delta E_{\\mathrm{true}}|}{|\\Delta E_{\\mathrm{true}}|} \\lesssim \\left(\\frac{|1/r_1| + |1/r_2|}{|1/r_2 - 1/r_1|} + 1\\right) u $$\n其中 $u$ 是单位舍入误差，对于binary64算术，我们取 $u_{64,\\mathrm{th}} = 2^{-53}$。乘以 $u$ 的项是减法的条件数。对于 $r_1, r_2 > 0$，这简化为 $C(r_1, r_2) = \\frac{r_1+r_2}{|r_2-r_1|} + 1$。该界限则近似为 $C(r_1, r_2) \\cdot u$。我们被要求在数值上验证这个界限，允许一个2倍的因子。\n\n为了进行此验证，我们需要三个量：\n1.  $\\Delta E_{\\mathrm{comp}}$：使用朴素公式和binary64（`numpy.float64`）算术计算。\n2.  $\\Delta E_{\\mathrm{true}}$：一个高精度参考值。这使用Python的 `decimal` 模块以100位数字的精度计算，以确保其自身的舍入误差可以忽略不计。\n3.  误差界：使用简化的条件数和 $u_{64,\\mathrm{th}}$ 计算。\n\n我们在binary64中对两个测试用例进行此检查：\n- 用例3（中等程度对消）：$r_1 = 10^8$, $r_2 = 10^8 + 1$。这里， $|r_2-r_1|=1$，所以条件数很大， $C \\approx 2 \\times 10^8$。\n- 用例4（极端对消）：$r_1 = 1$, $r_2 = \\operatorname{nextafter}(1, 2) = 1 + \\varepsilon_{64,\\mathrm{mach}}$。这里， $|r_2-r_1| = \\varepsilon_{64,\\mathrm{mach}}$，是最小可能的间隙。条件数达到最大，$C \\approx 2 / \\varepsilon_{64,\\mathrm{mach}} \\approx 0.9 \\times 10^{16}$。\n\n对于每个用例，我们计算测量的相对误差 $|\\Delta E_{\\mathrm{comp}} - \\Delta E_{\\mathrm{true}}|/|\\Delta E_{\\mathrm{true}}|$，并检查它是否小于或等于理论界限的2倍。\n\n最终输出将由第一部分的四个绝对误差值和第二部分的两个布尔结果组成，格式化为一个列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing machine precision constants and assessing\n    numerical cancellation in an astrophysical context.\n    \"\"\"\n\n    # Part 1: Computation of Machine Precision Constants\n\n    def get_constant_from_loop(dtype):\n        \"\"\"\n        Implements the loop-based algorithm described in the problem to find\n        the smallest power of 2, eta, such that 1.0 + eta > 1.0. As explained\n        in the solution, this algorithm computes machine epsilon, not unit roundoff.\n        \n        The problem asks for \"the previous eta value (just before equality holds)\".\n        \"\"\"\n        one = dtype(1.0)\n        two = dtype(2.0)\n        eta = dtype(1.0)\n        eta_prev = eta\n        \n        while True:\n            # Under round-to-nearest, ties-to-even, 1.0 + u rounds to 1.0.\n            # So, the loop terminates when eta becomes u or smaller.\n            if one + eta == one:\n                # The previous eta was the last value for which 1.0+eta > 1.0.\n                return eta_prev\n            eta_prev = eta\n            eta = eta / two\n\n    # Constants for binary64 (double precision)\n    p64 = 53\n    beta = 2\n    # Theoretical unit roundoff u = 1/2 * beta^(1-p) = beta^(-p) for beta=2\n    u_th_64 = np.float64(beta**(-p64))\n    # Theoretical machine epsilon eps = beta^(1-p)\n    eps_th_64 = np.float64(beta**(1 - p64))\n    \n    # Numerical computation for binary64\n    u_num_64 = get_constant_from_loop(np.float64) # This will be eps_mach\n    eps_num_64 = np.nextafter(np.float64(1), np.float64(2)) - np.float64(1)\n\n    abs_err_u64 = abs(u_num_64 - u_th_64)\n    abs_err_eps64 = abs(eps_num_64 - eps_th_64)\n\n    # Constants for binary32 (single precision)\n    p32 = 24\n    u_th_32 = np.float32(beta**(-p32))\n    eps_th_32 = np.float32(beta**(1 - p32))\n\n    # Numerical computation for binary32\n    u_num_32 = get_constant_from_loop(np.float32) # This will be eps_mach\n    eps_num_32 = np.nextafter(np.float32(1), np.float32(2)) - np.float32(1)\n    \n    abs_err_u32 = abs(u_num_32 - u_th_32)\n    abs_err_eps32 = abs(eps_num_32 - eps_th_32)\n\n    # Part 2: Astrophysical Cancellation Assessment\n\n    # Set precision for high-precision reference calculation\n    getcontext().prec = 100\n\n    def compute_delta_E_naive(r1, r2, dtype):\n        \"\"\"Computes Delta_E using the naive, cancellation-prone formula.\"\"\"\n        r1_f = dtype(r1)\n        r2_f = dtype(r2)\n        return -dtype(0.5) * (dtype(1.0) / r2_f - dtype(1.0) / r1_f)\n\n    def compute_delta_E_true(r1_str, r2_str):\n        \"\"\"Computes Delta_E using high-precision decimal arithmetic.\"\"\"\n        r1_d = Decimal(r1_str)\n        r2_d = Decimal(r2_str)\n        return -Decimal('0.5') * (Decimal('1') / r2_d - Decimal('1') / r1_d)\n\n    def check_error_bound(r1, r2):\n        \"\"\"\n        Verifies the relative error bound for a given test case.\n        Returns True if the measured error is within 2x the theoretical bound.\n        \"\"\"\n        unit_roundoff_64 = u_th_64\n\n        # 1. Compute Delta_E with standard float64 arithmetic\n        delta_E_comp = compute_delta_E_naive(r1, r2, np.float64)\n\n        # 2. Compute high-precision \"true\" Delta_E\n        # Use string representation to avoid float inaccuracies upon conversion\n        delta_E_true_decimal = compute_delta_E_true(str(r1), str(r2))\n        delta_E_true_float = float(delta_E_true_decimal)\n        \n        # 3. Calculate measured relative error\n        if delta_E_true_float == 0.0: return False # Avoid division by zero\n        measured_rel_error = abs(delta_E_comp - delta_E_true_float) / abs(delta_E_true_float)\n\n        # 4. Calculate theoretical error bound\n        r1_f = np.float64(r1)\n        r2_f = np.float64(r2)\n        # Simplified and stable form of the condition number term\n        condition_term = (r1_f + r2_f) / abs(r2_f - r1_f)\n        error_bound = (condition_term + 1.0) * unit_roundoff_64\n\n        # 5. Check if the measured error is within tolerance of the bound\n        return measured_rel_error = 2.0 * error_bound\n\n    # Test Case 3: Cancellation, moderate\n    r1_c3 = 1e8\n    r2_c3 = 1e8 + 1\n    bound_ok_case3 = check_error_bound(r1_c3, r2_c3)\n\n    # Test Case 4: Cancellation, extreme\n    r1_c4 = 1.0\n    # The next representable float64 after 1.0\n    r2_c4 = np.nextafter(np.float64(1.0), np.float64(2.0))\n    bound_ok_case4 = check_error_bound(r1_c4, r2_c4)\n    \n    # Collate results in the specified order\n    results = [\n        abs_err_u64,\n        abs_err_eps64,\n        abs_err_u32,\n        abs_err_eps32,\n        bound_ok_case3,\n        bound_ok_case4\n    ]\n    \n    # Print the final result in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3510974"}, {"introduction": "浮点运算中最违反直觉的方面之一是它不遵循我们习以为常的基本代数定律，例如结合律。这意味着运算顺序的改变可能会显著影响计算结果。本练习将使用跨越巨大数量级的数字来展示加法不满足结合律的情况，即 $(a+b)+c \\ne a+(b+c)$，这在天体物理模拟中是常见情景。你不仅将观察到这种代数定律的失效，还将学会通过计算“末位单位”（ULP）距离来精确量化其差异，这是一种在比特层面比较浮点值的强大技术。[@problem_id:3511001]", "problem": "您将实现并评估在电子电气工程师协会（IEEE）754 binary64 格式下的浮点数非结合性。本练习的基础是浮点数运算的有限精度模型：实数运算会被舍入到固定格式编码中最接近的可表示值，这意味着诸如结合律之类的代数属性不一定成立。您必须基于 binary64 表示法以及“向最接近的值舍入，偶数优先”的定义进行推导。\n\n任务说明：\n1. 设 $(a,b,c)$ 是用 IEEE 754 binary64 表示的实数。使用 binary64 算术计算两个带括号的和 $(a+b)+c$ 和 $a+(b+c)$，并确定它们是否不同。\n2. 将两个 binary64 结果 $x$ 和 $y$ 之间的精确“末位单位”距离定义为：在有限 binary64 值（包括非规格化数）的全序中，$x$ 和 $y$ 之间不同可表示的 binary64 数的整数个数；当 $x=y$ 时，距离为零。形式上，如果 $r(x)$ 表示 $x$ 在有限 binary64 数全序中的秩，则距离为 $\\Delta_{\\mathrm{ulp}}(x,y) = \\lvert r(x) - r(y) \\rvert$。您必须通过操作 $x$ 和 $y$ 的 $64$ 位编码以获得 $r(\\cdot)$ 来精确计算 $\\Delta_{\\mathrm{ulp}}(x,y)$。\n3. 所有算术运算都必须在 IEEE 754 binary64 中执行。不涉及物理单位；输出是无单位的整数。\n\n测试套件：\n- 情况 1（正常路径，大数抵消）：$(a,b,c) = (1, 10^{16}, -10^{16})$。\n- 情况 2（边界条件，非规格化数敏感性）：$(a,b,c) = (2^{-1074}, 1, -1)$，其中 $2^{-1074}$ 是最小的正非规格化 binary64 数。\n- 情况 3（极端数量级，无溢出）：$(a,b,c) = (10^{-308}, 10^{308}, -10^{308})$。\n\n对于每种情况，计算：\n- 使用 binary64 算术计算两个结果 $x_{\\mathrm{L}} = (a+b)+c$ 和 $x_{\\mathrm{R}} = a+(b+c)$。\n- 如上定义的精确整数 $\\Delta_{\\mathrm{ulp}}(x_{\\mathrm{L}}, x_{\\mathrm{R}})$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含上述情况的三个 $\\Delta_{\\mathrm{ulp}}$ 值，按顺序排列，格式为用方括号括起来的逗号分隔列表。例如，输出必须具有 $\\texttt{[d_1,d_2,d_3]}$ 的形式，其中每个 $d_i$ 都是一个整数。", "solution": "该问题要求分析在 IEEE 754 binary64 标准下浮点加法的非结合性。我们必须为三组特定的输入 $(a, b, c)$ 计算表达式 $(a+b)+c$ 和 $a+(b+c)$ 之间的差异。这种差异将通过精确的“末位单位”（ULP）距离来量化，该距离在形式上定义为两个浮点数结果在有限 binary64 数全序中的整数秩的绝对差。\n\n其基本原理是浮点数运算是实数运算的一种近似。由于对两个可表示数进行运算的结果本身可能无法精确表示，因此运算会产生舍入误差。在 binary64 中，一个数由一个符号位、一个 $11$ 位指数和一个 $52$ 位小数（尾数）表示，能提供大约 $15$ 到 $17$ 位的十进制精度。当数量级差异巨大的数字相加时，较小数的信息通常会丢失，这种现象被称为“吸收”或“淹没”(swamping)。这种信息丢失是非结合性的根源。\n\n为了量化两个 binary64 数 $x$ 和 $y$ 之间的差异，我们使用 ULP 距离 $\\Delta_{\\mathrm{ulp}}(x,y) = \\lvert r(x) - r(y) \\rvert$。这里，$r(f)$ 是一个函数，它将一个浮点数 $f$ 映射到一个唯一的整数秩，该秩相对于 IEEE 754 中定义的浮点数全序是单调的。在此排序中，数字从 $-\\infty$ 排列到 $+\\infty$，并且值得注意的是，$-0  +0$。\n\n为了实现秩函数 $r(f)$，我们操作浮点数 $f$ 的 $64$ 位整数表示，我们将其记为 $u$。在 Python 中，可以使用 `struct.pack` 和 `struct.unpack` 获得此表示。$64$ 位模式 $u$ 由一个符号位 $S$（第 $63$ 位）、一个指数 $E$（第 $62$-$52$ 位）和一个尾数 $M$（第 $51$-$0$ 位）组成。\n\n整数秩 $r(u)$ 的构造必须在整个有限浮点数范围内是单调的。对于符号位为 $0$ 的正数（包括 $+0$），其无符号整数表示 $u$ 已经正确排序。因此，对于浮点数 $f \\ge 0$，其 $64$ 位表示 $u$ 的 $S=0$，我们可以将其秩定义为：$r(u) = u$，其中 $u  2^{63}$。这样可以得到 $r(+0.0) = 0$，$r(\\text{最小正非规格化数}) = 1$，依此类推。\n\n对于符号位为 $1$ 的负数（包括 $-0$），标准整数表示的顺序与浮点值的顺序相反（例如，$-1.0$ 的位模式比 $-2.0$ 的大）。为了创建一个单一的单调序列，我们将负浮点数映射到负整数秩。浮点数 $-0.0$ 的秩必须紧挨在 $+0.0$ 之下，即为 $-1$。下一个浮点数，即绝对值最小的负数（值最大），其秩必须为 $-2$，依此类推。$-0.0$ 的位模式是 $u=2^{63}$。对于任何表示为 $u$ 的负浮点数，其秩可以定义为：$r(u) = -((u - 2^{63}) + 1)$，其中 $u \\ge 2^{63}$。对于 $u=2^{63}$ ($-0.0$)，这得到 $r = -((2^{63}-2^{63})+1) = -1$。对于 $u=2^{63}+1$（绝对值最小的负非规格化数），这得到 $r = -(((2^{63}+1)-2^{63})+1) = -2$。这个映射正确地建立了所需的全序。\n\n有了此秩函数，我们就可以分析这三个测试用例。\n\n情况 1：$(a,b,c) = (1, 10^{16}, -10^{16})$\n设 $a=1.0$, $b=10^{16}$, $c=-10^{16}$。\n$x_{\\mathrm{L}} = (a+b)+c$。第一个和是 $1.0 + 10^{16}$。$10^{16}$ 的数量级之大，使其 ULP 大于 $1.0$。具体来说，$\\text{ulp}(10^{16}) \\approx 10^{16} \\cdot 2^{-52} \\approx 2.22$。加法操作中，$1.0$ 的信息由于舍入而丢失。\n因此，$fl(a+b) = fl(1.0+10^{16}) = 10^{16}$。\n接着，$x_{\\mathrm{L}} = fl(10^{16} + (-10^{16})) = 0.0$。\n$x_{\\mathrm{R}} = a+(b+c)$。括号内的和是 $b+c = 10^{16} + (-10^{16}) = 0.0$。这个抵消是精确的。\n接着，$x_{\\mathrm{R}} = fl(1.0 + 0.0) = 1.0$。\nULP 距离为 $\\Delta_{\\mathrm{ulp}}(0.0, 1.0) = \\lvert r(0.0) - r(1.0) \\rvert$。\n$r(0.0) = 0$。$1.0$ 的 binary64 表示为 $u = \\text{0x3FF0000000000000}$。\n$r(1.0) = \\text{0x3FF0000000000000} = 4607182418800017408$。\n$\\Delta_{\\mathrm{ulp},1} = \\lvert 0 - 4607182418800017408 \\rvert = 4607182418800017408$。\n\n情况 2：$(a,b,c) = (2^{-1074}, 1, -1)$\n设 $a=2^{-1074}$, $b=1.0$, $c=-1.0$。值 $a$ 是最小的正非规格化数。\n$x_{\\mathrm{L}} = (a+b)+c$。第一个和是 $2^{-1074} + 1.0$。$a$ 的数量级远小于 $1.0$ 的 ULP ($\\text{ulp}(1.0) = 2^{-52}$)。$a$ 在加法中因舍入而丢失。\n因此，$fl(a+b) = fl(2^{-1074}+1.0) = 1.0$。\n接着，$x_{\\mathrm{L}} = fl(1.0 + (-1.0)) = 0.0$。\n$x_{\\mathrm{R}} = a+(b+c)$。括号内的和是 $b+c = 1.0 + (-1.0) = 0.0$。\n接着，$x_{\\mathrm{R}} = fl(2^{-1074} + 0.0) = 2^{-1074}$。\nULP 距离为 $\\Delta_{\\mathrm{ulp}}(0.0, 2^{-1074}) = \\lvert r(0.0) - r(2^{-1074}) \\rvert$。\n$r(0.0) = 0$。值 $2^{-1074}$ 是最小的正非规格化数，其表示为 $u=\\text{0x0000000000000001}$。\n$r(2^{-1074}) = 1$。\n$\\Delta_{\\mathrm{ulp},2} = \\lvert 0 - 1 \\rvert = 1$。这是预料之中的，因为它们在全序中是相邻的。\n\n情况 3：$(a,b,c) = (10^{-308}, 10^{308}, -10^{308})$\n设 $a=10^{-308}$, $b=10^{308}$, $c=-10^{308}$。\n$x_{\\mathrm{L}} = (a+b)+c$。第一个和是 $10^{-308} + 10^{308}$。与 $b$ 的 ULP 相比，$a$ 的值微不足道。该加法因吸收而丢失。\n因此，$fl(a+b) = fl(10^{-308} + 10^{308}) = 10^{308}$。\n接着，$x_{\\mathrm{L}} = fl(10^{308} + (-10^{308})) = 0.0$。\n$x_{\\mathrm{R}} = a+(b+c)$。括号内的和是 $b+c = 10^{308} + (-10^{308}) = 0.0$。\n接着，$x_{\\mathrm{R}} = fl(10^{-308} + 0.0) = 10^{-308}$。\nULP 距离是 $\\Delta_{\\mathrm{ulp}}(0.0, 10^{-308}) = \\lvert r(0.0) - r(10^{-308}) \\rvert$。\n$r(0.0) = 0$。值 $10^{-308}$ 是一个非规格化数，因为它小于最小的规格化数 ($2^{-1022} \\approx 2.225 \\times 10^{-308}$)。其值为 $k \\cdot 2^{-1074}$，其中 $k$ 为某个整数。这个整数 $k$ 就是它的位表示 $u$。\n$k$ 的值可以通过将 $10^{-308} / 2^{-1074}$ 舍入到最接近的整数来找到。\n$k = \\text{round}(10^{-308} / (4.94...\\times 10^{-324})) \\approx \\text{round}(2.0240225...\\times 10^{18}) = 2024022533832795894$。\n表示为 $u = 2024022533832795894$。由于该数为正，其秩为 $u$。\n$r(10^{-308}) = 2024022533832795894$。\n$\\Delta_{\\mathrm{ulp},3} = \\lvert 0 - 2024022533832795894 \\rvert = 2024022533832795894$。\n\n最终结果是通过实现此逻辑计算出的三种情况的 ULP 距离。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport struct\n\ndef get_rank(f: np.float64) - int:\n    \"\"\"\n    Computes a monotonic integer rank for a binary64 floating-point number.\n    This rank corresponds to the position of the number in the total ordering\n    of finite binary64 values, from -infinity to +infinity.\n    \"\"\"\n    if not isinstance(f, np.float64):\n        f = np.float64(f)\n    \n    # Pack the float into 8 bytes (64 bits) and then unpack it as an\n    # unsigned 64-bit integer. This gives the bit-level representation.\n    # 'd' is for double-precision float, 'Q' is for unsigned long long.\n    try:\n        u = struct.unpack('Q', struct.pack('d', f))[0]\n    except (struct.error, OverflowError):\n        # Handle cases where f might be Inf or NaN, though not in test cases\n        # This is for robustness; problem statement guarantees finite values.\n        if np.isinf(f):\n            return (1  63) - 1 if f > 0 else -((1  63) - 1)\n        # For NaN, rank is undefined, but for completeness:\n        return 0\n\n    # The most significant bit (bit 63) is the sign bit.\n    sign_bit_mask = 1  63\n    \n    if (u  sign_bit_mask) == 0:\n        # For positive numbers (including +0.0), the integer representation `u`\n        # is already ordered monotonically with the float value.\n        # r(+0.0) = 0, r(smallest_positive_subnormal) = 1, etc.\n        return int(u)\n    else:\n        # For negative numbers (including -0.0), the integer representation's\n        # order is inverse to the float value's order. To create a single\n        # monotonic sequence across all floats, we map them to negative integers.\n        # The rank of -0.0 (u = 0x800...0) should be -1, just below +0.0 (rank=0).\n        # The rank of -min_subnormal (u = 0x800...1) should be -2, and so on.\n        # This mapping is achieved by r(u) = -( (u - 2^63) + 1 ).\n        return -int((u - sign_bit_mask) + 1)\n\ndef compute_ulp_distance(x: np.float64, y: np.float64) - int:\n    \"\"\"\n    Computes the exact ULP distance between two binary64 floats.\n    The distance is defined as the absolute difference of their integer ranks.\n    \"\"\"\n    rank_x = get_rank(x)\n    rank_y = get_rank(y)\n    return abs(rank_x - rank_y)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Large cancellation\n        (1.0, 1.0e16, -1.0e16),\n        # Case 2: Subnormal sensitivity\n        (2.0**(-1074), 1.0, -1.0),\n        # Case 3: Extreme magnitudes\n        (1.0e-308, 1.0e308, -1.0e308),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Explicitly cast to numpy's float64 to ensure IEEE 754 binary64 arithmetic.\n        a, b, c = (np.float64(v) for v in case)\n        \n        # Compute x_L = (a+b)+c using binary64 arithmetic.\n        x_L = (a + b) + c\n        \n        # Compute x_R = a+(b+c) using binary64 arithmetic.\n        x_R = a + (b + c)\n        \n        # Compute the exact ULP distance between the two results.\n        delta = compute_ulp_distance(x_L, x_R)\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3511001"}, {"introduction": "一长串数值求和的最终结果可能对每一步所采用的舍入规则高度敏感。在涉及对大量元素求和的模拟中（例如引力或辐射通量），这可能导致系统性偏差，从而破坏物理结果的准确性。本练习要求你构建一个简化的浮点模拟器，以探索不同的 IEEE 754 舍入模式（例如，舍入到最近偶数、向零舍入）如何影响一个数列的求和结果。通过从第一性原理实现舍入逻辑，你将深刻理解舍入误差是如何累积的，以及舍入模式的选择如何引入可预测的偏差，这对于开发高精度数值方法至关重要。[@problem_id:3511012]", "problem": "考虑一个简化的二进制浮点模型，旨在捕捉计算天体物理学中使用的舍入和机器精度的基本特征。设浮点基数为 $b=2$，尾数精度为 $p$ 位。忽略指数范围限制和非规格化数。对于任何非零实数 $y$，通过分解 $y = m \\cdot 2^e$（其中 $0.5 \\le m  1$）来定义其二进制指数区间 (binade) 指数 $E$，因此 $E = e-1$ 且 $y \\in [2^E,2^{E+1})$。在一个二进制指数区间 $[2^E,2^{E+1})$ 中，可表示数是等差数列 $2^E + k \\cdot 2^{E-p}$，其中整数 $k \\in \\{0,1,\\dots,2^p\\}$，$k=2^p$ 对应上边界 $2^{E+1}$。设指数 $E$ 处的末位单位 (ULP) 为 $2^{E-p}$。\n\n您将实现一个有限二进有理数项列表的求和，每次加法后根据指定的舍入模式执行舍入。在二进制指数区间 $[2^E,2^{E+1})$ 中，$y$ 的舍入是通过根据小数位置 $k_f = (|y| - 2^E)/2^{E-p}$ 选择一个整数索引 $k$ 来定义的：\n- 向最近舍入，偶数优先：选择与 $k_f$ 最接近的整数，若平局则选择偶数。\n- 向最近舍入，远离零优先：选择与 $k_f$ 最接近的整数，若平局则选择使 $|y|$ 更大的整数（等价于当小数部分等于 $0.5$ 时选择 $\\lceil k_f \\rceil$）。\n- 向零舍入：选择 $\\lfloor k_f \\rfloor$。\n- 向正无穷舍入：如果 $y \\ge 0$，选择 $\\lceil k_f \\rceil$；如果 $y  0$，选择 $\\lfloor k_f \\rfloor$。\n- 向负无穷舍入：如果 $y \\ge 0$，选择 $\\lfloor k_f \\rfloor$；如果 $y  0$，选择 $\\lceil k_f \\rceil$。\n\n选择 $k$ 后，舍入值为 $y_{\\mathrm{round}} = \\operatorname{sign}(y)\\cdot\\left(2^E + k\\cdot 2^{E-p}\\right)$（对于 $k \\in \\{0,1,\\dots,2^p-1\\}$），以及 $y_{\\mathrm{round}} = \\operatorname{sign}(y)\\cdot 2^{E+1}$（对于 $k=2^p$）。对于 $y=0$，定义 $y_{\\mathrm{round}}=0$。\n\n精确参考和是将输入项作为二进有理数进行精确求和得到的有理数。计算任务是：\n1. 对于每个测试用例，通过按给定顺序添加项并在每种舍入模式下对每次加法后的中间结果进行舍入，来模拟累加和。\n2. 计算最终舍入和、相对于精确和的绝对误差，以及定义为 $\\operatorname{sign}(y_{\\mathrm{final}} - y_{\\mathrm{exact}})$ 的偏差符号，取值于 $\\{-1,0,+1\\}$。\n\n基本依据：使用以 $2$ 为基数的浮点二进制指数区间 (binade)、ULP 和 $p$ 位尾数精度的标准定义，以及由 Institute of Electrical and Electronics Engineers (IEEE) $754$ 标准定义的舍入模式。在计算天体物理学中，跨越多个数量级的贡献求和是常规操作（例如，在积分光度或聚合引力相互作用时），理解舍入行为对于量化数值误差和偏差至关重要。\n\n您的程序必须实现上述模型，并为以下测试套件执行计算。每个项以数对 $(n,e)$ 的形式给出，表示二进有理数 $n\\cdot 2^e$，其中 $n$ 是整数，$e$ 是整数指数。\n\n测试套件：\n- 测试用例 1：$p=24$；序列 $[(1,30),(1,-10),(1,-10),(1,-10),(-1,30)]$。精确和为 $3\\cdot 2^{-10}$。\n- 测试用例 2：$p=24$；序列 $[(1,20),(1,0),(-1,20)]$。精确和为 $1$。\n- 测试用例 3：$p=11$；序列 $[(1,15),(1,-20),(1,-20),(-1,15),(1,-20)]$。精确和为 $3\\cdot 2^{-20}$。\n\n按此顺序评估的舍入模式：\n1. 向最近舍入，偶数优先。\n2. 向零舍入。\n3. 向正无穷舍入。\n4. 向负无穷舍入。\n5. 向最近舍入，远离零优先。\n\n对于每个测试用例和每种舍入模式，计算：\n- 最终舍入和 $y_{\\mathrm{final}}$（作为浮点数）。\n- 绝对误差 $|y_{\\mathrm{final}} - y_{\\mathrm{exact}}|$（作为浮点数）。\n- 偏差符号 $\\operatorname{sign}(y_{\\mathrm{final}} - y_{\\mathrm{exact}})$，编码为 $-1$、$0$ 或 $+1$（作为整数）。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。该列表必须按以下固定顺序扁平化：对于测试用例 1 到测试用例 3，并按指定顺序对每种舍入模式，将三元组 $[y_{\\mathrm{final}}, |y_{\\mathrm{final}} - y_{\\mathrm{exact}}|, \\operatorname{sign}(y_{\\mathrm{final}} - y_{\\mathrm{exact}})]$ 附加到输出列表中，无需额外嵌套，从而产生一个包含 $45$ 个数字的单一列表。所有输出均为无量纲实数或整数；无需物理单位。", "solution": "该问题要求在多种舍入模式下模拟浮点求和，这是数值分析中的一项基本任务，在计算天体物理学等领域具有重要意义。关键在于忠实地实现指定的简化浮点模型，确保模拟本身不受宿主系统自身浮点运算的影响。为实现此目的，所有数值表示和计算均使用 Python 标准库中的 `decimal` 模块执行，该模块提供任意精度算术和对舍入的精细控制。所有计算均使用 $100$ 个十进制数字的精度，以确保中间结果实际上是精确的。\n\n总体方法是遍历每个测试用例，并对每个用例遍历五种指定的舍入模式。对于给定的用例和模式，将一个累加和初始化为零。输入序列中的项（形式为 $n \\cdot 2^e$ 的二进有理数）被逐一相加。每次加法后，在添加下一项之前，所得的中间和会根据模型的规则进行舍入。\n\n该解决方案的核心是一个函数，它接受一个精确数值 $y$、精度 $p$ 和一个舍入模式标识符。该函数执行以下步骤：\n$1$。首先处理 $y=0$ 的平凡情况，因为其舍入值始终为 $0$。\n$2$。对于非零数 $y$，我们首先确定其二进制指数区间 (binade) 指数 $E$。根据问题描述，$E$ 是一个整数，使得 $y$ 的绝对值落在区间 $[2^E, 2^{E+1})$ 内。这等价于找到 $E = \\lfloor \\log_2|y| \\rfloor$。为了使用任意精度数稳健地计算它，我们使用恒等式 $\\log_2(x) = \\log_{10}(x) / \\log_{10}(2)$，并使用高精度的 `Decimal` 对象进行计算。\n$3$。在已知二进制指数区间指数 $E$ 和精度 $p$ 的情况下，此二进制指数区间的末位单位 (ULP) 计算为 $\\text{ULP} = 2^{E-p}$。\n$4$。$|y|$ 在二进制指数区间内的位置由小数索引 $k_f$ 量化，定义为 $k_f = (|y| - 2^E) / \\text{ULP}$。该值表示 $|y|$ 距离该区间下界 $2^E$ 有多少个 ULP 步长。此计算的所有算术运算都使用 `Decimal` 以保持精确性。\n$5$。整数索引 $k$ 是通过根据指定的 `mode` 对 $k_f$ 进行舍入来确定的。问题陈述中提供的规则直接映射到 Python 的 `decimal` 模块中可用的舍入模式，这些模式应用于 $k_f$ 的 `Decimal` 值：\n- **向最近舍入，偶数优先 (RNE)：** 对应于 `ROUND_HALF_EVEN`。\n- **向零舍入 (RTZ)：** 对于非负的 $k_f$，这对应于 `ROUND_DOWN`。\n- **向正无穷舍入 (RPI)：** 如果 $y \\ge 0$ 则选择 $\\lceil k_f \\rceil$（在 $k_f$ 上使用 `ROUND_CEILING`），如果 $y  0$ 则选择 $\\lfloor k_f \\rfloor$（在 $k_f$ 上使用 `ROUND_FLOOR`）来实现。\n- **向负无穷舍入 (RMI)：** 如果 $y \\ge 0$ 则选择 $\\lfloor k_f \\rfloor$（在 $k_f$ 上使用 `ROUND_FLOOR`），如果 $y  0$ 则选择 $\\lceil k_f \\rceil$（在 $k_f$ 上使用 `ROUND_CEILING`）来实现。\n- **向最近舍入，远离零优先 (RNA)：** 对应于 `ROUND_HALF_UP`。\n$6$。舍入后结果的绝对值构造为 $2^E + k \\cdot \\text{ULP}$。最终的舍入值 $y_{\\mathrm{round}}$ 是通过使用 $y_{\\mathrm{round}} = \\operatorname{sign}(y) \\cdot (2^E + k \\cdot \\text{ULP})$ 应用 $y$ 的原始符号得到的。该公式正确处理了 $k=2^p$ 的情况，这对应于向上舍入到下一个二进制指数区间边界 $2^{E+1}$。\n\n在针对给定测试用例和舍入模式遍历序列中的所有项之后，获得最终的累加和 $y_{\\mathrm{final}}$。然后计算所需的输出：绝对误差 $|y_{\\mathrm{final}} - y_{\\mathrm{exact}}|$ 和偏差符号 $\\operatorname{sign}(y_{\\mathrm{final}} - y_{\\mathrm{exact}})$，后者通过直接比较确定。对于测试用例和舍入模式的每种组合，都会收集这三个值——最终和、绝对误差和偏差符号。最终输出是这些结果的单个扁平化列表，根据输出格式的要求转换为标准的 Python 浮点数和整数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, getcontext, ROUND_HALF_EVEN, ROUND_DOWN, ROUND_CEILING, ROUND_FLOOR, ROUND_HALF_UP\n\ndef solve():\n    \"\"\"\n    Simulates floating-point summation with specified rounding modes and precision.\n    \"\"\"\n    # Set precision for Decimal calculations to be high enough to avoid intermediate rounding\n    getcontext().prec = 100\n\n    test_cases = [\n        {\n            \"p\": 24,\n            \"sequence\": [(1, 30), (1, -10), (1, -10), (1, -10), (-1, 30)],\n            \"y_exact\": Decimal(3) * (Decimal(2)**-10),\n        },\n        {\n            \"p\": 24,\n            \"sequence\": [(1, 20), (1, 0), (-1, 20)],\n            \"y_exact\": Decimal(1),\n        },\n        {\n            \"p\": 11,\n            \"sequence\": [(1, 15), (1, -20), (1, -20), (-1, 15), (1, -20)],\n            \"y_exact\": Decimal(3) * (Decimal(2)**-20),\n        },\n    ]\n\n    # Order of rounding modes to be evaluated\n    rounding_modes = ['RNE', 'RTZ', 'RPI', 'RMI', 'RNA']\n    \n    # Store all results in a flattened list\n    results = []\n\n    def custom_round(y, p, mode):\n        \"\"\"\n        Implements the custom rounding logic as per the problem description.\n        All calculations use the Decimal type for exactness.\n        \"\"\"\n        if y == Decimal(0):\n            return Decimal(0)\n\n        sign_y = Decimal(1) if y >= 0 else Decimal(-1)\n        abs_y = abs(y)\n\n        # Determine the binade exponent E such that 2**E = abs_y  2**(E+1)\n        # This is equivalent to E = floor(log2(abs_y))\n        if abs_y == 0: return Decimal(0) # log(0) is undefined\n        log2_abs_y = abs_y.log10() / Decimal(2).log10()\n        E = int(log2_abs_y.to_integral_value(rounding=ROUND_FLOOR))\n\n        # Unit in the Last Place (ULP) for this binade\n        ulp = Decimal(2)**(E - p)\n        \n        # Calculate the fractional position k_f relative to the start of the binade\n        k_f = (abs_y - Decimal(2)**E) / ulp\n        \n        # Determine the integer index k based on the rounding mode\n        k = Decimal(0)\n        if mode == 'RNE':  # Round to nearest, ties to even\n            k = k_f.to_integral_value(rounding=ROUND_HALF_EVEN)\n        elif mode == 'RTZ':  # Round toward zero\n            k = k_f.to_integral_value(rounding=ROUND_DOWN)\n        elif mode == 'RPI':  # Round toward +infinity\n            if sign_y > 0:\n                k = k_f.to_integral_value(rounding=ROUND_CEILING)\n            else: # y  0, toward +inf is less negative -> round magnitude down\n                k = k_f.to_integral_value(rounding=ROUND_FLOOR)\n        elif mode == 'RMI':  # Round toward -infinity\n            if sign_y > 0: # y > 0, toward -inf is smaller -> round magnitude down\n                k = k_f.to_integral_value(rounding=ROUND_FLOOR)\n            else: # y  0, toward -inf is more negative -> round magnitude up\n                k = k_f.to_integral_value(rounding=ROUND_CEILING)\n        elif mode == 'RNA':  # Round to nearest, ties away from zero\n            k = k_f.to_integral_value(rounding=ROUND_HALF_UP)\n\n        # Calculate the rounded magnitude and apply the original sign\n        rounded_mag = Decimal(2)**E + k * ulp\n        return sign_y * rounded_mag\n\n    for case in test_cases:\n        p = case[\"p\"]\n        sequence = case[\"sequence\"]\n        y_exact = case[\"y_exact\"]\n\n        for mode in rounding_modes:\n            current_sum = Decimal(0)\n            for n, e in sequence:\n                term = Decimal(n) * (Decimal(2)**e)\n                unrounded_sum = current_sum + term\n                current_sum = custom_round(unrounded_sum, p, mode)\n\n            y_final = current_sum\n            abs_error = abs(y_final - y_exact)\n            \n            bias_sign = 0\n            if y_final > y_exact:\n                bias_sign = 1\n            elif y_final  y_exact:\n                bias_sign = -1\n\n            # Append the results as standard float/int types for the final output\n            results.extend([float(y_final), float(abs_error), int(bias_sign)])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3511012"}]}