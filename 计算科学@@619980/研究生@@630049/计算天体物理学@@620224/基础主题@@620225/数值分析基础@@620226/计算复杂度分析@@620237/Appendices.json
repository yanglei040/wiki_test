{"hands_on_practices": [{"introduction": "对最基础的N体模拟算法进行分析，是计算复杂度研究的起点。本练习的核心是通过计算基本浮点运算（FLOPs）来进行抽象的复杂度分析，旨在培养将代码结构转化为数学性能模型的基础技能。通过这个练习，您将清晰地看到诸如粒子数$N$和相互作用截断半径$r_c$等问题参数是如何直接影响算法的计算成本的 [@problem_id:3503805]。", "problem": "考虑 $N$ 个质点，其质量为 $\\{m_i\\}_{i=1}^{N}$，均匀且独立地分布在一个边长为 $L$ 的立方体盒子中（因此体积为 $V = L^{3}$）。相距为 $r_{ij}$ 的质点 $i$ 和 $j$ 之间的牛顿引力势能为 $-G m_i m_j / r_{ij}$，其中 $G$ 是引力常数。您实现了一个朴素的显式嵌套循环算法（无邻居列表，无空间索引）来计算总势能，并使用球形截断半径 $r_c$，使得只有满足 $r_{ij} \\le r_c$ 的质点对才对总势能有贡献。对于每个满足 $i  j$ 的不同质点对 $(i,j)$，该算法采用以下步骤：\n\n- 计算坐标差 $\\Delta x = x_j - x_i$、$\\Delta y = y_j - y_i$、$\\Delta z = z_j - z_i$。\n- 形成 $r_{ij}^{2} = \\Delta x^{2} + \\Delta y^{2} + \\Delta z^{2}$。\n- 如果 $r_{ij}^{2} \\le r_c^{2}$，则计算 $r_{ij} = \\sqrt{r_{ij}^{2}}$，计算 $1/r_{ij}$，并将贡献 $-G m_i m_j / r_{ij}$ 累加到能量的总和中。\n\n假设采用以下浮点运算（FLOPs）计数模型：每次减法、加法、乘法、除法和平方根计为一次 FLOP；比较、分支和内存访问不计数。在循环外预先计算 $r_c^{2}$ 不计数。假设 $r_c \\ll L$ 以便可以忽略边界效应，并假设所有位置都是独立且均匀分布的。\n\n设数密度为 $\\eta = N/V$，并假设当 $N$ 变化时 $\\eta$ 保持不变（即 $L = (N/\\eta)^{1/3}$）。\n\n从此循环结构和上述基本定义出发，推导总 FLOPs 期望值的闭式表达式，该表达式是关于 $N$、$r_c$ 和 $\\eta$ 的函数，然后在 $\\eta$ 固定的假设下，将其简化为关于 $N$ 和 $r_c$ 的主导阶渐近形式。请将您的最终答案表示为关于 $N$、$r_c$ 和 $\\eta$ 的单个解析表达式。不需要进行数值计算。", "solution": "问题要求计算使用一个带有截断半径 $r_c$ 的朴素嵌套循环算法，来计算一个 $N$ 质点系统的总引力势能所需的浮点运算（FLOPs）的总期望数。分析过程遵循一系列逻辑步骤。\n\n首先，我们确定算法的结构。它遍历所有满足 $i  j$ 的不同质点对 $(i,j)$，总共有 $\\binom{N}{2} = N(N-1)/2$ 对。对于每一对，算法执行一系列计算。我们可以将这些计算分为两部分：无条件执行的部分和仅在距离截断条件满足时才执行的部分。\n\n**1. 无条件 FLOPs**\n对于每一对 $(i,j)$，算法首先计算平方距离 $r_{ij}^2$。这包括：\n- 3 次减法 (计算 $\\Delta x, \\Delta y, \\Delta z$)\n- 3 次乘法 (计算 $\\Delta x^2, \\Delta y^2, \\Delta z^2$)\n- 2 次加法 (将平方差相加)\n这总计 $3 + 3 + 2 = 8$ 次 FLOPs。\n由于有 $N(N-1)/2$ 对，无条件执行的总 FLOPs 数为：\n$$ \\text{FLOPs}_{\\text{uncond}} = 8 \\times \\frac{N(N-1)}{2} = 4N(N-1) $$\n\n**2. 条件 FLOPs**\n如果满足条件 $r_{ij}^2 \\le r_c^2$，算法会执行额外的计算来更新总能量。这些计算包括：\n- 1 次平方根 (计算 $r_{ij}$)\n- 1 次除法 (计算 $1/r_{ij}$)\n- 3 次乘法 (计算 $-G \\cdot m_i \\cdot m_j \\cdot (1/r_{ij})$)\n- 1 次加法 (将贡献累加到总和中)\n这总计 $1 + 1 + 3 + 1 = 6$ 次 FLOPs。\n\n接下来，我们需要计算满足条件的质点对的期望数量。假设粒子在体积 $V$ 内均匀分布。对于任意一对粒子，它们之间的距离小于等于 $r_c$ 的概率 $P$ 是以一个粒子为中心的半径为 $r_c$ 的球体体积与盒子总体积之比（忽略边界效应）：\n$$ P(r_{ij} \\le r_c) = \\frac{\\frac{4}{3}\\pi r_c^3}{V} $$\n由于数密度 $\\eta = N/V$，我们可以写出 $V = N/\\eta$。因此，\n$$ P = \\frac{\\frac{4}{3}\\pi r_c^3}{N/\\eta} = \\frac{4\\pi\\eta r_c^3}{3N} $$\n满足条件的质点对的期望数量是总对数乘以这个概率：\n$$ E[\\text{pairs}_{\\text{cond}}] = \\frac{N(N-1)}{2} \\times P = \\frac{N(N-1)}{2} \\times \\frac{4\\pi\\eta r_c^3}{3N} = \\frac{2\\pi\\eta r_c^3(N-1)}{3} $$\n因此，条件 FLOPs 的期望总数为：\n$$ E[\\text{FLOPs}_{\\text{cond}}] = 6 \\times \\frac{2\\pi\\eta r_c^3(N-1)}{3} = 4\\pi\\eta r_c^3(N-1) $$\n\n**3. 总 FLOPs**\n总 FLOPs 的期望值是无条件部分和条件部分的和：\n$$ E[\\text{FLOPs}_{\\text{total}}] = 4N(N-1) + 4\\pi\\eta r_c^3(N-1) $$\n在 $N$ 很大的渐近极限下，我们可以忽略 $-1$ 项，得到主导阶行为：\n$$ E[\\text{FLOPs}_{\\text{total}}] \\approx 4N^2 + 4\\pi\\eta r_c^3 N $$\n这个表达式给出了关于 $N$、$r_c$ 和 $\\eta$ 的总 FLOPs 期望值。", "answer": "$$\\boxed{4N^{2} + 4\\pi\\eta r_{c}^{3}N}$$", "id": "3503805"}, {"introduction": "在求解物理场（如引力势或磁场）的偏微分方程时，有限差分模板更新是一种常用且关键的计算核心。本练习将引导您应用“屋顶线”（Roofline）模型，来深入理解算法的算术强度与硬件限制（如内存带宽和峰值计算性能）之间的相互作用。通过比较一个朴素实现和一个经过优化的缓存分块实现，本练习将有力地揭示为何优化数据移动，而不仅仅是减少浮点运算，往往是实现高性能计算的关键所在 [@problem_id:3503871]。", "problem": "一个大小为 $n^{3}$ 的三维均匀笛卡尔网格被用于在一个计算天体物理学代码中更新一个标量场 $\\phi$，该标量场代表引力势的替代物。该数值更新使用一种各向异性的七点有限差分模板，由于每个主方向上的非均匀有效耦合，其方向权重各不相同。对于每个内部网格点 $(i,j,k)$，更新是异地（out-of-place）计算的，公式如下\n$$\n\\phi_{\\text{new}}(i,j,k) = w_{0}\\,\\phi(i,j,k) + w_{x^{+}}\\,\\phi(i+1,j,k) + w_{x^{-}}\\,\\phi(i-1,j,k) + w_{y^{+}}\\,\\phi(i,j+1,k) + w_{y^{-}}\\,\\phi(i,j-1,k) + w_{z^{+}}\\,\\phi(i,j,k+1) + w_{z^{-}}\\,\\phi(i,j,k-1).\n$$\n所有权重 $w_{\\alpha}$ 在整个网格上是常数，但可以各不相同。算术运算以双精度进行。\n\n考虑单次扫描（对每个内部点进行一次更新）的两种实现方式：\n\n- 朴素实现：一个直接的三重嵌套循环，具有较差的空间和时间局部性。对于每次内部更新，假设代码从动态随机存取存储器（DRAM）中为七个输入值发出七次加载，并为输出值发出一次存储。存储操作使用写分配策略，因此在写入前，缓存行会从DRAM中分配，这会为目标地址产生一次双精度读取，然后是一次双精度写入。\n\n- 分块实现：一个缓存分块版本，它将网格平铺成大小为 $t^{3}$ 的立方体块，这些块可以装入末级缓存。在一个块内，输入值从缓存中重用，因此每个输入元素仅为其自身更新的贡献而从DRAM中获取一次。输出使用非临时（流式）存储写入，避免了写分配。通过假设 $n \\gg t$ 并关注每个块的内部点，忽略块之间的光环交换（halo exchanges）的贡献。\n\n假设在单个图形处理单元（GPU）上进行双精度计算的机器特性如下：峰值浮点性能 $P_{\\text{peak}} = 150 \\times 10^{9}$ 次浮点运算每秒，持续主存带宽 $B_{\\text{w}} = 250 \\times 10^{9}$ 字节每秒。\n\n从操作计数和内存流量的第一性原理出发，确定：\n\n1. 在朴素实现和分块实现中，单次内部更新的算术强度 $I_{\\text{naive}}$ 和 $I_{\\text{blocked}}$，单位为浮点运算次数/字节。\n\n2. 在Roofline模型推理下，每种情况的可达性能（以GFLOP/s为单位），以及通过比较算术强度与比率 $P_{\\text{peak}}/B_{\\text{w}}$ 所暗示的相应性能体系（内存约束型与计算约束型）。\n\n请按顺序提供 $I_{\\text{naive}}$、$I_{\\text{blocked}}$、朴素实现的可达性能以及分块实现的可达性能的最终数值。将您的答案四舍五入到四位有效数字。将可达性能值以GFLOP/s（吉咖浮点运算次数每秒）表示。", "solution": "题干已经过验证，被认为是科学上合理的、适定的和完整的。它描述了一个标准的计算科学场景，涉及有限差分法和使用Roofline模型进行性能分析，这些都是高性能计算中的既定概念。所有必要的参数和假设均已提供。我现在将进行正式的解答。\n\n这个问题的核心在于应用Roofline模型，该模型为计算内核的可达性能提供了一个上限。性能 $P$，以每秒浮点运算次数（FLOP/s）为单位，受到硬件的峰值浮点性能 $P_{\\text{peak}}$ 和持续主存带宽 $B_{\\text{w}}$ 的双重限制。其关系由下式给出：\n$$\nP_{\\text{attainable}} \\le \\min(P_{\\text{peak}}, I \\times B_{\\text{w}})\n$$\n其中 $I$ 是算法的算术强度，定义为执行的浮点运算次数与主存和处理器缓存之间移动的数据总字节数之比。\n$$\nI = \\frac{\\text{Floating-Point Operations (FLOPs)}}{\\text{Memory Traffic (Bytes)}}\n$$\n一个双精度类型的数据值占用 $8$ 字节。\n\n机器特性如下：\n- 峰值性能, $P_{\\text{peak}} = 150 \\times 10^{9}$ FLOP/s。\n- 内存带宽, $B_{\\text{w}} = 250 \\times 10^{9}$ 字节/秒。\n\n根据这些值，我们可以计算机器平衡点或临界强度 $I_{\\text{critical}}$，这是区分内存约束型和计算约束型体系的阈值：\n$$\nI_{\\text{critical}} = \\frac{P_{\\text{peak}}}{B_{\\text{w}}} = \\frac{150 \\times 10^{9} \\, \\text{FLOP/s}}{250 \\times 10^{9} \\, \\text{bytes/s}} = \\frac{150}{250} \\frac{\\text{FLOP}}{\\text{byte}} = 0.6 \\, \\text{FLOP/byte}\n$$\n如果一个算法的算术强度 $I  I_{\\text{critical}}$，其性能受内存带宽限制（$P = I \\times B_{\\text{w}}$）。如果 $I > I_{\\text{critical}}$，其性能受峰值计算速率限制（$P = P_{\\text{peak}}$）。\n\n我们现在将分析每种实现方式下单个内部点的更新。\n\n**1. 朴素实现的分析**\n\n首先，我们确定一次更新所需的浮点运算次数（FLOPs）。更新规则是：\n$$\n\\phi_{\\text{new}}(i,j,k) = w_{0}\\,\\phi(i,j,k) + w_{x^{+}}\\,\\phi(i+1,j,k) + w_{x^{-}}\\,\\phi(i-1,j,k) + w_{y^{+}}\\,\\phi(i,j+1,k) + w_{y^{-}}\\,\\phi(i,j-1,k) + w_{z^{+}}\\,\\phi(i,j,k+1) + w_{z^{-}}\\,\\phi(i,j,k-1)\n$$\n这个计算涉及 $7$ 次乘法和 $6$ 次加法。因此，每次更新的总FLOPs为 $7 + 6 = 13$ 次。\n\n接下来，我们确定内存流量。对于每次内部点更新：\n- 为输入值 $\\phi$ 从DRAM进行 $7$ 次加载。由于每个值都是双精度值，加载流量为 $7 \\times 8 = 56$ 字节。\n- 为输出值 $\\phi_{\\text{new}}$ 进行 $1$ 次存储。该存储使用写分配策略，这意味着目标地址的缓存行在被修改和写入之前首先从DRAM中读取。这会产生 $1$ 次双精度值的读取和 $1$ 次双精度值的写入。因此，存储流量为 $(1+1) \\times 8 = 16$ 字节。\n- 总内存流量 $M_{\\text{naive}}$ 是加载和存储流量的总和：$M_{\\text{naive}} = 56 + 16 = 72$ 字节。\n\n朴素实现的算术强度 $I_{\\text{naive}}$ 是：\n$$\nI_{\\text{naive}} = \\frac{13 \\, \\text{FLOPs}}{72 \\, \\text{bytes}} \\approx 0.180556 \\, \\text{FLOP/byte}\n$$\n将此与临界强度比较，我们发现 $I_{\\text{naive}} \\approx 0.1806  I_{\\text{critical}} = 0.6$。因此，朴素实现是**内存约束型**的。\n\n可达性能 $P_{\\text{naive}}$ 受内存带宽限制：\n$$\nP_{\\text{naive}} = I_{\\text{naive}} \\times B_{\\text{w}} = \\frac{13}{72} \\times (250 \\times 10^{9}) \\, \\text{FLOP/s} = \\frac{3250}{72} \\times 10^{9} \\, \\text{FLOP/s} \\approx 45.1389 \\times 10^{9} \\, \\text{FLOP/s}\n$$\n以GFLOP/s表示并四舍五入到四位有效数字，结果为 $45.14$ GFLOP/s。\n\n**2. 分块实现的分析**\n\n每次更新的FLOPs数量仍然是 $13$ 次。\n\n对于分块实现，我们在假设缓存驻留块内数据完全重用的前提下分析内存流量。这是对一个大块中各点的摊销分析，正如 $n \\gg t$ 所指定的。\n- 每个输入元素 $\\phi(i,j,k)$ 从DRAM中加载一次。这为其自身位置及其 $6$ 个邻居的更新做出贡献。在块内用于所有相关更新后，它就不再需要了。摊销到每次更新，这对应于从DRAM进行 $1$ 次读取。\n- 输出值 $\\phi_{\\text{new}}(i,j,k)$ 使用非临时（流式）存储一次性写入DRAM，这种方式绕过缓存，避免了写分配的写前读惩罚。摊销到每次更新，这对应于向DRAM进行 $1$ 次写入。\n- 总内存流量 $M_{\\text{blocked}}$ 是 $1$ 次摊销读取和 $1$ 次摊销写入的总和。每个都是双精度值。\n- 总内存流量：$M_{\\text{blocked}} = (1 \\times 8) + (1 \\times 8) = 16$ 字节。\n\n分块实现的算术强度 $I_{\\text{blocked}}$ 是：\n$$\nI_{\\text{blocked}} = \\frac{13 \\, \\text{FLOPs}}{16 \\, \\text{bytes}} = 0.8125 \\, \\text{FLOP/byte}\n$$\n将此与临界强度比较，我们发现 $I_{\\text{blocked}} = 0.8125 > I_{\\text{critical}} = 0.6$。因此，分块实现是**计算约束型**的。\n\n可达性能 $P_{\\text{blocked}}$ 受硬件的峰值浮点性能限制：\n$$\nP_{\\text{blocked}} = P_{\\text{peak}} = 150 \\times 10^{9} \\, \\text{FLOP/s} = 150 \\, \\text{GFLOP/s}\n$$\n\n**结果总结**\n\n- $I_{\\text{naive}} = \\frac{13}{72} \\approx 0.1806$ FLOP/字节。\n- $I_{\\text{blocked}} = \\frac{13}{16} = 0.8125$ FLOP/字节。\n- $P_{\\text{naive}} \\approx 45.14$ GFLOP/s (内存约束型)。\n- $P_{\\text{blocked}} = 150.0$ GFLOP/s (计算约束型，写入为四位有效数字)。\n\n最终数值答案被要求按以下顺序给出：$I_{\\text{naive}}$、$I_{\\text{blocked}}$、$P_{\\text{naive}}$（以GFLOP/s为单位）和 $P_{\\text{blocked}}$（以GFLOP/s为单位），数值四舍五入到四位有效数字。", "answer": "$$\n\\boxed{\\begin{pmatrix} 0.1806  0.8125  45.14  150.0 \\end{pmatrix}}\n$$", "id": "3503871"}, {"introduction": "在现代计算天体物理学中，利用并行计算来处理大规模N体模拟至关重要。本练习的核心是运用 Amdahl 定律和 Gustafson 定律这两个经典理论框架，来推导和对比并行计算的效率。这个过程将帮助您阐明“强扩展”（固定问题规模）和“弱扩展”（问题规模随处理器数量增长）之间的根本区别，为您准确预测并行程序的性能瓶颈并设定切合实际的加速比期望提供必要的理论工具 [@problem_id:3503847]。", "problem": "一个在均匀粒子分布上进行的 Barnes–Hut $N$体时间步的性能分析如下：可并行的树遍历占单节点总运行时间的分数 $f_{p} = 0.95$，而串行时间积分和开销占分数 $s = 0.05$。考虑一个拥有 $p = 64$ 个相同节点，并且在树遍历上实现理想负载均衡的并行系统。使用加速比和效率的核心定义，即 $S_{p} = T_{1}/T_{p}$ 和 $E_{p} = S_{p}/p$，不要引用任何预先给出的扩展公式。从这些定义和适用于各个模型的假设出发，在两种解释下推导模型预测的强扩展效率：\n- 固定总工作量（Amdahl 的固定规模观点）。\n- 在固定墙钟时间预算下扩展总工作量（Gustafson–Barsis 的扩展加速比观点）。\n计算当 $s = 0.05$ 和 $p = 64$ 时两种效率。将两个值都四舍五入到四位有效数字，并以小数形式表示。按 $(\\text{Amdahl}, \\text{Gustafson})$ 的顺序，将最终的数值对以行矩阵的形式报告。用一两句话解释，为什么在相同的 $s$ 和 $p$ 条件下，这两种预测会有所不同。", "solution": "该问题经验证是自洽的，科学上基于并行计算原理，且提法明确。所有必要的信息和定义均已提供。\n\n设 $T_{1}$ 为在单个处理器上执行 $N$ 体时间步的总执行时间。问题指出，该时间的一部分 $s$ 是纯串行的，另一部分 $f_{p}$ 是完全可并行的。给定 $s = 0.05$ 和 $f_{p} = 0.95$。注意 $s + f_{p} = 0.05 + 0.95 = 1$。串行部分花费的时间为 $s \\cdot T_{1}$，可并行部分花费的时间为 $f_{p} \\cdot T_{1}$。处理器数量为 $p=64$。加速比和效率的定义为 $S_{p} = T_{1}/T_{p}$ 和 $E_{p} = S_{p}/p$，其中 $T_{p}$ 是在 $p$ 个处理器上的执行时间。\n\n我们将在两种不同的模型下推导效率：Amdahl 的固定规模模型和 Gustafson-Barsis 的可扩展规模模型。\n\n**1. Amdahl 定律（固定总工作量）**\n\n该模型假设要完成的总工作量是固定的，与使用的处理器数量无关。工作的串行部分无法并行化，而可并行的部分在假设理想负载均衡的情况下，被平均分配给 $p$ 个处理器。\n\n在 $p$ 个处理器上执行程序的时间 $T_{p}$，是串行部分时间和并行化部分时间之和。\n$$ T_{p} = (\\text{串行时间}) + (\\text{在 } p \\text{ 个处理器上的并行时间}) $$\n$$ T_{p} = s \\cdot T_{1} + \\frac{f_{p} \\cdot T_{1}}{p} $$\n提取公因子 $T_{1}$，我们得到：\n$$ T_{p} = T_{1} \\left( s + \\frac{f_{p}}{p} \\right) $$\n现在，我们使用加速比的定义 $S_{p} = T_{1}/T_{p}$：\n$$ S_{p} = \\frac{T_{1}}{T_{1} \\left( s + \\frac{f_{p}}{p} \\right)} = \\frac{1}{s + \\frac{f_{p}}{p}} $$\n使用 $f_{p} = 1 - s$，这就是经典的 Amdahl 定律：\n$$ S_{p} = \\frac{1}{s + \\frac{1-s}{p}} $$\n效率 $E_{p}$ 定义为 $S_{p}/p$：\n$$ E_{p, \\text{Amdahl}} = \\frac{S_{p}}{p} = \\frac{1}{p \\left( s + \\frac{1-s}{p} \\right)} = \\frac{1}{p \\cdot s + (1-s)} $$\n代入给定值 $s = 0.05$ 和 $p = 64$：\n$$ E_{p, \\text{Amdahl}} = \\frac{1}{64 \\cdot 0.05 + (1-0.05)} = \\frac{1}{3.2 + 0.95} = \\frac{1}{4.15} $$\n$$ E_{p, \\text{Amdahl}} \\approx 0.240963855... $$\n四舍五入到四位有效数字，得到 $0.2410$。\n\n**2. Gustafson–Barsis 定律（可扩展的总工作量）**\n\n该模型假设要完成的总工作量随处理器数量扩展，从而使墙钟时间保持固定。具体来说，工作负载的可并行部分按因子 $p$ 进行扩展。\n\n设在一个具有 $p$ 个处理器的并行系统上的运行时间归一化为 $1$ 个单位时间。这个时间由串行部分 $s$ 和并行部分 $f_p$ 组成：\n$$ T_{p} = s + f_{p} = 1 $$\n在此模型中，总工作负载是可扩展的。串行工作量保持为 $s$，但并行工作量增加了 $p$ 倍。这个扩展后的问题，如果要在单个处理器上运行，其总工作量将花费时间 $T_{1}'$。\n$$ T_{1}' = (\\text{串行工作}) + (\\text{扩展后的并行工作}) = s + p \\cdot f_{p} $$\n根据 Gustafson-Barsis 的观点，扩展加速比是扩展后问题在单个处理器上的时间 $T_{1}'$ 与该问题在多个处理器上的时间 $T_{p}$ 之比。\n$$ S_{p, \\text{Gustafson}} = \\frac{T_{1}'}{T_{p}} = \\frac{s + p \\cdot f_{p}}{s + f_{p}} = \\frac{s + p \\cdot f_{p}}{1} = s + p \\cdot f_{p} $$\n使用 $f_{p} = 1 - s$，我们也可以将其写为 $s + p(1-s) = p - s(p-1)$。\n效率同样为 $E_{p} = S_{p}/p$：\n$$ E_{p, \\text{Gustafson}} = \\frac{S_{p, \\text{Gustafson}}}{p} = \\frac{s + p \\cdot f_{p}}{p} = \\frac{s}{p} + f_{p} $$\n代入给定值 $s = 0.05$，$f_{p} = 0.95$ 和 $p = 64$：\n$$ E_{p, \\text{Gustafson}} = \\frac{0.05}{64} + 0.95 $$\n$$ E_{p, \\text{Gustafson}} = 0.00078125 + 0.95 = 0.95078125 $$\n四舍五入到四位有效数字，得到 $0.9508$。\n\n**解释**\n\n这两种预测之所以不同，是因为 Amdahl 定律模拟了一个固定规模的问题，其中固定时间的串行部分随着处理器的增加而成为日益显著的瓶颈。相反，Gustafson 定律模拟了一个可扩展规模的问题，其中并行工作负载随之增长，从而减小了固定时间串行部分的相对影响，因此保持了高效率。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.2410  0.9508\n\\end{pmatrix}\n}\n$$", "id": "3503847"}]}