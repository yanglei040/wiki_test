{"hands_on_practices": [{"introduction": "本节的第一个练习将通过一个具体的解析性示例，展示截断误差和舍入误差之间的根本性冲突。我们将构建一个特定的函数，在该函数中，由于灾难性抵消（catastrophic cancellation）的存在，即使对于相对较大的步长，舍入误差也会成为不准确性的主要来源——这是一个违反直觉但至关重要的概念。这项实践旨在加深我们对浮点运算如何影响导数计算的理解[@problem_id:3273443]。", "problem": "在浮点运算的标准模型中，每个基本运算都表示为 $\\operatorname{fl}(z)=z(1+\\delta)$，其中 $|\\delta|\\leq u$，而 $u$ 是单位舍入。考虑函数 $f(x)$ 在点 $x$ 处导数的中心差分近似：\n$$\nD_{h}[f](x)=\\frac{f(x+h)-f(x-h)}{2h},\n$$\n该近似在 Institute of Electrical and Electronics Engineers (IEEE) 754 双精度下实现，其单位舍入为 $u=2^{-53}$。您将从第一性原理出发，比较截断误差和舍入误差，以设计一个函数，使其计算出的导数在一个典型的步长范围内由舍入误差主导。\n\n令 $x=0$，并考虑单参数函数族 $f_{A}(x)=A+\\sin(x)$，其中 $A>0$ 是一个待定常数。仅使用 $f$ 关于 $x$ 的泰勒级数展开和上述浮点模型（不使用任何现成的误差公式），比较当 $h$ 在 $[10^{-8},\\,10^{-2}]$ 范围内取值时，$D_{h}[f_{A}](0)$ 的主阶截断误差与计算量中舍入误差的主阶效应。\n\n确定最小的 $A>0$，使得对于区间 $[10^{-8},\\,10^{-2}]$ 中的每一个 $h$，$D_{h}[f_{A}](0)$ 的舍入误差贡献的量级至少与截断误差贡献的量级一样大。然后，将结果函数表示为关于 $x$ 的单个表达式。将常数 $A$ 四舍五入到三位有效数字，并将最终函数表示为不带等号的单个表达式。", "solution": "用户提供了一个问题，在尝试解决之前需要进行验证。\n\n### 第 1 步：提取已知条件\n- **浮点模型**：一个数 $z$ 的浮点表示为 $\\operatorname{fl}(z) = z(1+\\delta)$，其中 $|\\delta| \\leq u$。\n- **单位舍入**：对于 IEEE 754 双精度，$u = 2^{-53}$。\n- **数值方法**：函数 $f(x)$ 在点 $x$ 处导数的中心差分近似为 $D_{h}[f](x) = \\frac{f(x+h) - f(x-h)}{2h}$。\n- **函数族**：$f_{A}(x) = A + \\sin(x)$，其中 $A > 0$。\n- **求值点**：$x = 0$。\n- **步长范围**：$h \\in [10^{-8}, 10^{-2}]$。\n- **条件**：对于指定区间内的每一个 $h$，$D_{h}[f_{A}](0)$ 计算值的舍入误差贡献的量级必须至少与截断误差贡献的量级一样大。\n- **目标**：确定满足该条件的最小常数 $A > 0$。\n- **最终输出**：将确定的 $A$ 值四舍五入到三位有效数字后的函数 $f_A(x)$，表示为单个表达式。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题具有科学依据，是数值误差分析中一个结合了截断误差和舍入误差的标准练习。该问题是适定的，因为它要求一个受明确数学不等式约束的参数的最小值。所有术语都有定义，并且提供了必要的数据（$u$、$h$ 的区间、函数形式）。该问题是客观且可形式化的。它没有违反任何无效性标准。\n\n### 第 3 步：结论与行动\n问题有效。将提供完整解答。\n\n### 推导\n问题要求比较函数 $f_A(x) = A + \\sin(x)$ 在 $x=0$ 处导数的中心差分近似的截断误差和舍入误差。\n\n**1. 截断误差分析**\n\n$f_A(x)$ 的精确导数是 $f'_A(x) = \\cos(x)$。在 $x=0$ 处，精确导数为 $f'_A(0) = \\cos(0) = 1$。\n\n将中心差分公式应用于 $f_A(x)$ 在 $x=0$ 处可得：\n$$\nD_h[f_A](0) = \\frac{f_A(0+h) - f_A(0-h)}{2h} = \\frac{f_A(h) - f_A(-h)}{2h}\n$$\n代入 $f_A(x)$ 的定义：\n$$\nD_h[f_A](0) = \\frac{(A + \\sin(h)) - (A + \\sin(-h))}{2h} = \\frac{\\sin(h) - (-\\sin(h))}{2h} = \\frac{2\\sin(h)}{2h} = \\frac{\\sin(h)}{h}\n$$\n截断误差 $E_T$ 是此近似值与导数的精确值之差：\n$$\nE_T = D_h[f_A](0) - f'_A(0) = \\frac{\\sin(h)}{h} - 1\n$$\n为求主阶项，我们使用 $\\sin(h)$ 在 $h=0$ 附近的泰勒级数：\n$$\n\\sin(h) = h - \\frac{h^3}{3!} + \\frac{h^5}{5!} - \\dots = h - \\frac{h^3}{6} + O(h^5)\n$$\n将此代入 $E_T$ 的表达式中：\n$$\nE_T = \\frac{h - \\frac{h^3}{6} + O(h^5)}{h} - 1 = \\left(1 - \\frac{h^2}{6} + O(h^4)\\right) - 1 = -\\frac{h^2}{6} + O(h^4)\n$$\n主阶截断误差的量级为：\n$$\n|E_T| \\approx \\frac{h^2}{6}\n$$\n\n**2. 舍入误差分析**\n\n舍入误差源于浮点运算的有限精度。$D_h[f_A](0)$ 的计算涉及计算 $f_A(h)$ 和 $f_A(-h)$，将它们相减，然后除以 $2h$。\n\n令 $\\widehat{y}_+ = \\operatorname{fl}(f_A(h))$ 和 $\\widehat{y}_- = \\operatorname{fl}(f_A(-h))$ 为计算值。对于小的 $h$，$f_A(h) = A + \\sin(h) \\approx A$ 且 $f_A(-h) = A - \\sin(h) \\approx A$。函数求值的误差由单位舍入与函数值的乘积为界。因此，我们可以将计算值建模为：\n$$\n\\widehat{y}_+ = f_A(h) + e_+ = (A + \\sin(h)) + e_+ \\quad \\text{其中 } |e_+| \\lesssim u|f_A(h)| \\approx Au\n$$\n$$\n\\widehat{y}_- = f_A(-h) + e_- = (A - \\sin(h)) + e_- \\quad \\text{其中 } |e_-| \\lesssim u|f_A(-h)| \\approx Au\n$$\n此计算中舍入误差的主要来源是两个几乎相等的数 $\\widehat{y}_+ \\approx A$ 和 $\\widehat{y}_- \\approx A$ 相减。这种现象被称为灾难性抵消。\n\n差商的分子计算为 $\\operatorname{fl}(\\widehat{y}_+ - \\widehat{y}_-)$。分子中的误差由初始误差 $e_+$ 和 $e_-$ 主导。计算出的分子中的误差约为 $e_+ - e_-$。该误差的最坏情况量级为 $|e_+| + |e_-| \\approx 2Au$。\n\n最终结果中的舍入误差 $E_R$ 是分子中的误差通过除以 $2h$ 传播而来的。\n$$\n|E_R| \\approx \\frac{|e_+ - e_-|}{2h}\n$$\n主阶舍入贡献的量级由其最坏情况值界定：\n$$\n|E_R| \\approx \\frac{2Au}{2h} = \\frac{Au}{h}\n$$\n对于小的 $h$，此项占主导地位，因为 $1/h$ 的依赖性使其增长速度远快于截断误差的减小速度。\n\n**3. 确定常数 A**\n\n问题要求对于所有 $h \\in [10^{-8}, 10^{-2}]$，舍入误差至少与截断误差一样大：\n$$\n|E_R| \\ge |E_T|\n$$\n代入误差量级的表达式：\n$$\n\\frac{Au}{h} \\ge \\frac{h^2}{6}\n$$\n我们需要找到在整个区间上满足此不等式的最小 $A$。我们求解 $A$：\n$$\nA \\ge \\frac{h^3}{6u}\n$$\n令 $g(h) = \\frac{h^3}{6u}$。为确保不等式在给定范围内的所有 $h$ 上都成立，$A$ 必须大于或等于 $g(h)$ 在区间 $[10^{-8}, 10^{-2}]$ 上的最大值。\n对于 $h>0$，函数 $g(h)$ 是 $h$ 的单调递增函数。因此，它在区间上的最大值出现在右端点 $h_{max} = 10^{-2}$。\n\n$A$ 的最小可能值就是这个最大值：\n$$\nA_{min} = \\frac{(h_{max})^3}{6u} = \\frac{(10^{-2})^3}{6(2^{-53})} = \\frac{10^{-6}}{6 \\cdot 2^{-53}} = \\frac{2^{53} \\times 10^{-6}}{6}\n$$\n\n**4. 数值计算**\n\n我们现在计算 $A_{min}$ 的值：\n$$\nA_{min} = \\frac{9007199254740992 \\times 10^{-6}}{6} \\approx \\frac{9.0072 \\times 10^{15} \\times 10^{-6}}{6} = \\frac{9.0072 \\times 10^9}{6}\n$$\n$$\nA_{min} \\approx 1.5012 \\times 10^9\n$$\n按照要求将此值四舍五入到三位有效数字，我们得到：\n$$\nA = 1.50 \\times 10^9\n$$\n\n**5. 最终函数**\n\n结果函数为 $f_A(x) = A + \\sin(x)$，其中 $A$ 的值已经确定。问题要求将函数表示为单个表达式。\n$$\n1.50 \\times 10^9 + \\sin(x)\n$$", "answer": "$$\\boxed{1.50 \\times 10^{9} + \\sin(x)}$$", "id": "3273443"}, {"introduction": "基于对过小和过大步长均存在问题的理解，这项实践将探讨下一个逻辑问题：什么是*最佳*步长？我们将为数值微分建立一个通用的误差模型，并利用微积分推导出一个能最小化总误差的步长公式，从而平衡截断误差和舍入误差这两个相互竞争的影响[@problem_id:3536511]。这个练习为在实际模拟中做出明智选择提供了强有力的工具。", "problem": "考虑一个处于平衡状态的球对称、无碰撞的暗物质晕。令 $f(x)$ 表示沿穿过该暗物质晕的一维坐标 $x$ 采样的平滑标量场，代表质量密度、引力势或限制在视线方向上的分布函数。假设 $f(x)$ 在一个特征空间尺度 $L$ 上变化，并具有特征振幅 $F$，因此在一般位置，其导数满足量纲标度关系 $|f^{(n)}(x)| \\sim F L^{-n}$。您希望使用对称两点中心差分公式在某点 $x$ 处计算空间导数 $f'(x)$\n$$\nD_{\\Delta x} f(x) \\equiv \\frac{f(x+\\Delta x) - f(x-\\Delta x)}{2 \\Delta x}.\n$$\n假设浮点运算遵循标准模型，单位舍入为 $u$，意味着每次求值返回 $(1+\\delta) f(\\cdot)$，其中 $|\\delta| \\leq u$，并且算术运算会产生同阶的相对误差。在目标点 $x$ 处，通过将三阶导数写为 $|f^{(3)}(x)| = \\alpha F L^{-3}$ 来定义一个无量纲的局部形状参数 $\\alpha$，其中 $\\alpha$ 体现了对纯指数或幂律剖面的偏离，在天体物理应用中通常为单位量级。\n\n仅从关于 $f(x\\pm\\Delta x)$ 的泰勒定理和上述浮点模型出发，分析 $D_{\\Delta x} f(x)$ 中的主阶截断误差和舍入误差，建立一个总误差模型 $E(\\Delta x)$，该模型是这两个主导误差的量值之和，并确定使 $E(\\Delta x)$ 最小化的步长 $\\Delta x_{\\mathrm{opt}}$。\n\n请用 $u$、$L$ 和 $\\alpha$ 将 $\\Delta x_{\\mathrm{opt}}$ 的最终答案表示为单个闭式解析表达式。不需要数值，最终表达式中也不应包含物理单位。", "solution": "目标是确定对称两点中心差分公式的最优步长 $\\Delta x_{\\mathrm{opt}}$，以最小化总数值误差。总误差由两部分组成：截断误差，源于用有限差分近似导数；以及舍入误差，这是浮点运算固有的。我们将分别分析每个误差分量，将它们组合成一个总误差模型，然后针对步长 $\\Delta x$ 最小化该模型。\n\n首先，我们分析截断误差 $E_{\\text{trunc}}$。中心差分公式如下：\n$$\nD_{\\Delta x} f(x) = \\frac{f(x+\\Delta x) - f(x-\\Delta x)}{2 \\Delta x}\n$$\n我们使用泰勒定理在点 $x$ 附近展开 $f(x+\\Delta x)$ 和 $f(x-\\Delta x)$。假设 $f(x)$ 足够光滑（至少 $C^3$），我们可以写出：\n$$\nf(x+\\Delta x) = f(x) + \\Delta x f'(x) + \\frac{(\\Delta x)^2}{2} f''(x) + \\frac{(\\Delta x)^3}{6} f^{(3)}(x) + O((\\Delta x)^4)\n$$\n$$\nf(x-\\Delta x) = f(x) - \\Delta x f'(x) + \\frac{(\\Delta x)^2}{2} f''(x) - \\frac{(\\Delta x)^3}{6} f^{(3)}(x) + O((\\Delta x)^4)\n$$\n用第一个展开式减去第二个展开式可得：\n$$\nf(x+\\Delta x) - f(x-\\Delta x) = 2 \\Delta x f'(x) + \\frac{2 (\\Delta x)^3}{6} f^{(3)}(x) + O((\\Delta x)^5)\n$$\n注意，$\\Delta x$ 的偶次幂项被消去了。将此结果代入中心差分公式：\n$$\nD_{\\Delta x} f(x) = \\frac{2 \\Delta x f'(x) + \\frac{(\\Delta x)^3}{3} f^{(3)}(x) + O((\\Delta x)^5)}{2 \\Delta x} = f'(x) + \\frac{(\\Delta x)^2}{6} f^{(3)}(x) + O((\\Delta x)^4)\n$$\n截断误差是计算出的近似值与真实导数之间的差，即 $E_{\\text{trunc}}(\\Delta x) = D_{\\Delta x} f(x) - f'(x)$。该误差的主阶项为：\n$$\nE_{\\text{trunc}}(\\Delta x) \\approx \\frac{(\\Delta x)^2}{6} f^{(3)}(x)\n$$\n因此，截断误差的量值约为 $|E_{\\text{trunc}}(\\Delta x)| \\approx \\frac{(\\Delta x)^2}{6} |f^{(3)}(x)|$。根据问题中对点 $x$ 处三阶导数的定义 $|f^{(3)}(x)| = \\alpha F L^{-3}$，我们有：\n$$\n|E_{\\text{trunc}}(\\Delta x)| \\approx \\frac{\\alpha F}{6 L^3} (\\Delta x)^2\n$$\n当 $\\Delta x$ 减小时，该误差呈二次方减小。\n\n接下来，我们分析舍入误差 $E_{\\text{round}}$。根据浮点模型，对 $f(y)$ 的求值会得到一个计算值 $\\tilde{f}(y) = f(y)(1+\\delta)$，其中 $|\\delta| \\leq u$ 是单位舍入。令 $\\tilde{f}(x+\\Delta x)$ 和 $\\tilde{f}(x-\\Delta x)$ 为在采样点处函数的计算值。\n$$\n\\tilde{f}(x+\\Delta x) = f(x+\\Delta x)(1 + \\delta_{1})\n$$\n$$\n\\tilde{f}(x-\\Delta x) = f(x-\\Delta x)(1 + \\delta_{2})\n$$\n其中 $|\\delta_1| \\leq u$ 且 $|\\delta_2| \\leq u$。舍入误差源于这些函数求值和后续算术运算中的不精确性。该公式中舍入误差的主要来源是，当 $\\Delta x$ 很小时，由于两个值非常接近，在进行减法 $\\tilde{f}(x+\\Delta x) - \\tilde{f}(x-\\Delta x)$ 时可能发生的灾难性抵消。计算出的分子的绝对误差是：\n$$\ne_{\\text{num}} = \\tilde{f}(x+\\Delta x) - \\tilde{f}(x-\\Delta x) - (f(x+\\Delta x) - f(x-\\Delta x)) = f(x+\\Delta x)\\delta_{1} - f(x-\\Delta x)\\delta_{2}\n$$\n我们忽略减法运算本身产生的舍入误差，因为它通常小于传播误差。$e_{\\text{num}}$ 的量值有界：\n$$\n|e_{\\text{num}}| \\leq |f(x+\\Delta x)||\\delta_1| + |f(x-\\Delta x)||\\delta_2| \\leq u (|f(x+\\Delta x)| + |f(x-\\Delta x)|)\n$$\n问题陈述 $f(x)$ 具有特征振幅 $F$。对于小步长 $\\Delta x \\ll L$，函数值 $f(x\\pm\\Delta x)$ 将与该振幅同量级。因此，我们可以近似为 $|f(x\\pm\\Delta x)| \\approx F$。分子舍入误差的界变为 $|e_{\\text{num}}| \\lesssim u(F+F) = 2uF$。这个误差随后通过除以 $2\\Delta x$ 进行传播。因此，最终结果中舍入误差的量值为：\n$$\n|E_{\\text{round}}(\\Delta x)| \\approx \\frac{|e_{\\text{num}}|}{2\\Delta x} \\approx \\frac{2uF}{2\\Delta x} = \\frac{uF}{\\Delta x}\n$$\n当 $\\Delta x$ 减小时，该误差增大。\n\n总误差 $E(\\Delta x)$ 建模为主阶截断误差和舍入误差的量值之和：\n$$\nE(\\Delta x) = |E_{\\text{trunc}}(\\Delta x)| + |E_{\\text{round}}(\\Delta x)| \\approx \\frac{\\alpha F}{6 L^3} (\\Delta x)^2 + \\frac{uF}{\\Delta x}\n$$\n为了找到最小化此总误差的最优步长 $\\Delta x_{\\mathrm{opt}}$，我们对 $E(\\Delta x)$ 关于 $\\Delta x$ 求导，并令结果为零：\n$$\n\\frac{dE}{d(\\Delta x)} = \\frac{d}{d(\\Delta x)} \\left( \\frac{\\alpha F}{6 L^3} (\\Delta x)^2 + \\frac{uF}{\\Delta x} \\right) = 2 \\left( \\frac{\\alpha F}{6 L^3} \\right) \\Delta x - \\frac{uF}{(\\Delta x)^2} = 0\n$$\n$$\n\\frac{\\alpha F}{3 L^3} \\Delta x = \\frac{uF}{(\\Delta x)^2}\n$$\n特征振幅 $F$ 从等式两边消去：\n$$\n\\frac{\\alpha}{3 L^3} \\Delta x = \\frac{u}{(\\Delta x)^2}\n$$\n求解 $\\Delta x$：\n$$\n(\\Delta x)^3 = \\frac{3 u L^3}{\\alpha}\n$$\n对两边取立方根，得到最优步长：\n$$\n\\Delta x_{\\mathrm{opt}} = \\left( \\frac{3 u L^3}{\\alpha} \\right)^{1/3} = L \\left( \\frac{3u}{\\alpha} \\right)^{1/3}\n$$\n这个结果给出了平衡递减的截断误差和递增的舍入误差的步长，从而在给定模型下产生最精确的数值导数。", "answer": "$$\n\\boxed{L \\left( \\frac{3u}{\\alpha} \\right)^{1/3}}\n$$", "id": "3536511"}, {"introduction": "最后一个实践将理论误差分析与实际计算算法——自适应网格加密（Adaptive Mesh Refinement, AMR）——联系起来。我们将编写一段代码，使用误差指示器来决定在何处加密网格，然后分析该过程在何时会出错——即当舍入“噪声”被误认为是截断误差，导致浪费的“伪”加密时[@problem_id:3536557]。这个动手编码练习揭示了可实现精度的实际极限，以及在复杂模拟中设置切合实际的容差的重要性。", "problem": "考虑在区间 $x \\in [0,1]$ 上的一个一维无量纲标量场 $f(x)$，它代表一个平滑变化的天体物理量（例如，恒星包层模型中的密度或比内能）。自适应网格加密（AMR）被用于高效地解析空间尺度。基于由有限差分近似构建的局部截断误差指示器，定义自适应网格加密（AMR）的决策。您的目标是构建一个从截断误差指示器派生出的AMR加密准则，然后分析在该准则下，舍入噪声会触发错误加密的阈值。\n\n基本基础和假设：\n- 使用一维空间导数的速度定义，即 $g(x) = \\frac{df}{dx}$，并在一个大小为 $h$ 的均匀模板上，使用二阶中心有限差分来近似点 $x$ 处的 $g(x)$：$g_h(x) = \\frac{f(x+h) - f(x-h)}{2h}$。\n- 对 $f(x+h)$ 和 $f(x-h)$ 在 $x$ 点进行泰勒展开，并利用对于足够平滑的 $f(x)$，二阶中心差分的截断误差尺度为 $O(h^2)$ 这一经过充分检验的事实。\n- 采用 Richardson 风格的自洽性：在 $h$ 和 $h/2$ 处形成两种近似，并使用它们的差异来指示局部截断误差。您可以假设使用双精度浮点数运算，其机器舍入误差为 $\\epsilon_{\\mathrm{mach}}$，约等于 $2.220446049250313 \\times 10^{-16}$，但您不能在分析上依赖此精确值，应将其视为由浮点数实现控制的未知参数。\n- 任何三角函数的角度单位均为弧度。\n\n加密准则构建：\n- 对于一个中心在 $x$、局部网格间距为 $h$ 的单元，使用上述中心差分公式计算两个近似值 $g_h(x)$ 和 $g_{h/2}(x)$。\n- 使用 $g_{h/2}(x)$ 和 $g_h(x)$ 之间的差值作为截断误差指示器。如果该指示器超过用户指定的容差 $\\tau$（无量纲），则加密该单元。\n- 通过将被加密的单元分裂成两个相等的子单元（每个子单元的间距为 $h/2$）来迭代加密，直到指示器小于或等于 $\\tau$ 或达到最大层级 $L_{\\max}$ 为止。\n\n错误加密分析：\n- 如果一个加密决策被触发时，该层级的理论纯截断误差贡献本不会超过容差 $\\tau$，则将该决策定义为错误的。使用二阶中心差分的 $O(h^2)$ 截断定律，其首项基于三阶导数：对于平滑的 $f(x)$，在 $x$ 点和间距 $h$ 处的纯截断误差大小表现为 $\\left|\\frac{f^{(3)}(x)}{6}\\right| h^2$。\n- 假设 $f(x)$ 足够平滑，其三阶导数 $f^{(3)}(x)$ 在 $[0,1]$ 上存在且连续。\n\n您的程序必须：\n- 在覆盖 $[0,1]$ 的具有 $N_0$ 个单元的基础均匀网格上实现上述 AMR 决策过程，并根据需要递归地进行加密。\n- 对于给定的容差 $\\tau$，运行加密过程并计数：\n  - 加密决策的总数，以及\n  - 根据父单元的理论纯截断项 $\\left|\\frac{f^{(3)}(x)}{6}\\right| h^2$ 小于或等于 $\\tau$ 定义的错误决策数。\n- 对于每个测试用例，确定最小容差 $\\tau^\\star$，使得错误决策的比例（错误决策数除以总决策数）小于或等于指定的允许错误比例 $\\delta$（将 $\\delta$ 表示为小数，而非百分比）。\n\n测试套件：\n- 在所有情况下，定义域为 $x \\in [0,1]$，且三角函数使用弧度。\n- 用例 A（平滑，中等振幅）：$f(x) = A \\sin(k x)$，其中 $A = 1.0$, $k = 2\\pi$, $N_0 = 64$, $L_{\\max} = 8$, $\\delta = 0.05$。\n- 用例 B（易受舍入误差影响，微小振幅）：$f(x) = A \\sin(k x)$，其中 $A = 10^{-12}$, $k = 2\\pi$, $N_0 = 64$, $L_{\\max} = 8$, $\\delta = 0.05$。\n- 用例 C（高频内容）：$f(x) = A \\sin(k x)$，其中 $A = 1.0$, $k = 40\\pi$, $N_0 = 128$, $L_{\\max} = 8$, $\\delta = 0.05$。\n\n输出规格：\n- 您的程序必须在一个合理的对数范围内搜索容差 $\\tau$，并使用稳健的搜索方法（例如，在对数尺度上进行二分搜索）为每个用例确定 $\\tau^\\star$。\n- 您的程序应生成单行输出，其中包含用逗号分隔并用方括号括起来的结果列表，按测试用例的顺序排列，即 $[\\tau^\\star_{\\text{A}}, \\tau^\\star_{\\text{B}}, \\tau^\\star_{\\text{C}}]$。这些值是无量纲的，应以十进制数形式打印（科学记数法可接受）。", "solution": "用户提供了一个有效的问题陈述。该问题要求基于数值误差指示器，构建和分析一个自适应网格加密（AMR）准则，特别关注舍入误差开始占主导地位并导致虚假“错误”加密的阈值。\n\n解决方案将分为三个主要部分进行阐述：\n1.  数值误差指示器和理论截断误差的推导。\n2.  截断误差和舍入误差之间相互作用的分析，定义错误加密的机制。\n3.  模拟AMR过程并搜索临界容差阈值 $\\tau^\\star$ 的算法描述。\n\n### 1. 误差指示器和截断误差\n\n我们的任务是近似标量场 $f(x)$ 的导数 $g(x) = \\frac{df}{dx}$。问题指定在间距为 $h$ 的网格上使用二阶中心有限差分近似：\n$$\ng_h(x) = \\frac{f(x+h) - f(x-h)}{2h}\n$$\n为了理解这种近似的误差，我们在点 $x$ 周围对 $f(x+h)$ 和 $f(x-h)$ 进行泰勒级数展开，假设 $f(x)$ 足够平滑，其三阶导数 $f^{(3)}(x)$ 存在且连续。\n$$\nf(x+h) = f(x) + hf'(x) + \\frac{h^2}{2}f''(x) + \\frac{h^3}{6}f^{(3)}(x) + \\frac{h^4}{24}f^{(4)}(x) + O(h^5)\n$$\n$$\nf(x-h) = f(x) - hf'(x) + \\frac{h^2}{2}f''(x) - \\frac{h^3}{6}f^{(3)}(x) + \\frac{h^4}{24}f^{(4)}(x) - O(h^5)\n$$\n用第一个展开式减去第二个展开式可得：\n$$\nf(x+h) - f(x-h) = 2hf'(x) + \\frac{h^3}{3}f^{(3)}(x) + O(h^5)\n$$\n两边除以 $2h$ 并重新整理，得到数值近似 $g_h(x)$ 关于真实导数 $f'(x)$ 的表达式：\n$$\ng_h(x) = \\frac{f(x+h) - f(x-h)}{2h} = f'(x) + \\frac{h^2}{6}f^{(3)}(x) + O(h^4)\n$$\n截断误差 $E_T(h)$ 是近似值与真实值 $g(x) = f'(x)$ 之间的差值：\n$$\nE_T(h) = g_h(x) - g(x) = \\frac{h^2}{6}f^{(3)}(x) + O(h^4)\n$$\n因此，主阶截断误差为 $E_T(h) \\approx C(x)h^2$，其中 $C(x) = \\frac{f^{(3)}(x)}{6}$。这证实了 $O(h^2)$ 的缩放关系。\n\nAMR 加密准则基于 Richardson 风格的误差指示器，该指示器比较在两个不同网格间距 $h$ 和 $h/2$ 上的近似值。让我们写出两者的表达式：\n$$\ng_h(x) = g(x) + C(x)h^2 + O(h^4)\n$$\n$$\ng_{h/2}(x) = g(x) + C(x)\\left(\\frac{h}{2}\\right)^2 + O(h^4) = g(x) + \\frac{1}{4}C(x)h^2 + O(h^4)\n$$\n误差指示器 $\\eta(x, h)$ 定义为这两个近似值之间的差值：\n$$\n\\eta(x, h) = g_{h/2}(x) - g_h(x) = \\left(g(x) + \\frac{1}{4}C(x)h^2\\right) - \\left(g(x) + C(x)h^2\\right) + O(h^4) = -\\frac{3}{4}C(x)h^2 + O(h^4)\n$$\n该指示器的大小 $|\\eta(x, h)| = |g_{h/2}(x) - g_h(x)|$ 与父单元近似的主阶截断误差 $|E_T(h)| \\approx |C(x)|h^2$ 成正比。因此，$|\\eta(x, h)|$ 可作为局部截断误差的可计算代理，从而证明了其用作加密准则的合理性。\n\n### 2. 由舍入误差引起的错误加密\n\n上述分析仅考虑了截断误差。在使用浮点数运算的实际计算中，舍入误差也会产生影响。设 $\\tilde{g}_h(x)$ 为计算出的近似值。其总误差是截断误差和舍入误差之和：$E_{total}(h) = E_T(h) + E_R(h)$。\n\n中心差分公式中舍入误差的主要来源是 $f(x)$ 求值过程中表示误差的传播。设 $\\tilde{f}(y) = f(y)(1+\\epsilon_y)$，其中 $|\\epsilon_y| \\le \\epsilon_{\\mathrm{mach}}$ 是机器ε。计算出的差值为：\n$$\n\\tilde{g}_h(x) = \\frac{\\tilde{f}(x+h) - \\tilde{f}(x-h)}{2h} = \\frac{f(x+h)(1+\\epsilon_1) - f(x-h)(1+\\epsilon_2)}{2h}\n$$\n舍入误差分量为 $E_R(h) \\approx \\frac{f(x+h)\\epsilon_1 - f(x-h)\\epsilon_2}{2h}$。假设 $f$ 是平滑的，其大小的界限为：\n$$\n|E_R(h)| \\lesssim \\frac{(|f(x+h)| + |f(x-h)|)\\epsilon_{\\mathrm{mach}}}{2h} \\approx \\frac{|f(x)|\\epsilon_{\\mathrm{mach}}}{h}\n$$\n当 $h \\to 0$ 时，截断误差 $|E_T(h)| \\propto h^2$ 减小，而舍入误差 $|E_R(h)| \\propto h^{-1}$ 增大。总误差 $|E_{total}(h)|$ 在一个最优的 $h$ 处有一个特征最小值。\n\n当加密被触发，即 $|\\tilde{\\eta}(x,h)| > \\tau$，但理论截断误差已在容差范围内，即 $|C(x)|h^2 \\le \\tau$ 时，我们定义发生了“错误加密”。此处，$\\tilde{\\eta}$ 是数值计算的指示器。这种情况发生在 $\\tau$ 的设定值过低，以至于低于指示器的噪声基底时。计算出的指示器 $\\tilde{\\eta}$ 被舍入噪声主导，即 $|\\tilde{\\eta}(x,h)| \\approx |E_R(h/2) - E_R(h)|$，它不再反映真实的截断误差。如果这个噪声水平超过了 $\\tau$，即使从截断误差的角度来看网格已经足够精细，加密仍会被触发。这会导致计算资源的浪费。\n\n目标是找到最小的容差 $\\tau^\\star$，使得这些错误加密的比例不超过给定的阈值 $\\delta$。这个 $\\tau^\\star$ 代表了在舍入污染变得不可接受之前，可以向AMR方案要求的实际精度极限。\n\n### 3. 算法实现\n\n该问题通过实现一个两部分的算法来解决：一个AMR模拟函数和一个用于寻找 $\\tau^\\star$ 的搜索例程。\n\n**AMR 模拟：**\n一个函数 `run_amr_simulation` 接收物理参数（$A, k$）、网格参数（$N_0, L_{\\max}$）和一个容差 $\\tau$ 作为输入。\n1.  **初始化**：创建一个活动单元列表，代表覆盖域 $[0,1]$ 的 $N_0$ 个单元的基础网格。每个单元由其中心 $x_i = (i+0.5)h_0$、层级 $l=0$ 和间距 $h_0 = 1/N_0$ 定义。\n2.  **迭代**：算法遍历活动单元列表。对于每个单元 $(x, l, h)$：\n    a. 如果单元的层级 $l$ 达到了最大值 $L_{\\max}$，它不能再被加密。\n    b. 计算数值指示器 $|\\tilde{\\eta}| = |\\tilde{g}_{h/2}(x) - \\tilde{g}_h(x)|$。\n    c. 如果 $|\\tilde{\\eta}| > \\tau$，则做出加密决策。\n        i. 总加密计数器加一。\n        ii. 使用 $f(x)$ 的解析三阶导数计算理论截断误差大小 $|E_{T,theory}| = |\\frac{f^{(3)}(x)}{6}|h^2$。对于 $f(x) = A\\sin(kx)$，$f^{(3)}(x) = -Ak^3\\cos(kx)$。\n        iii. 如果 $|E_{T,theory}| \\le \\tau$，则该决策被归类为错误的，错误加密计数器加一。\n        iv. 父单元被替换为两个层级为 $l+1$、间距为 $h/2$、中心位于 $x \\pm h/4$ 的子单元。这些子单元被添加到待处理单元列表中。\n3.  **输出**：该函数返回总加密次数和错误加密次数。\n\n**搜索 $\\tau^\\star$：**\n对于每个测试用例，我们必须找到最小的容差 $\\tau^\\star$，使得错误加密比例小于或等于 $\\delta$。\n1.  **单调性**：错误加密比例是 $\\tau$ 的单调非增函数。较小的 $\\tau$ 会导致更多的总加密次数，并且其中更高比例可能是“错误的”（由噪声触发）。\n2.  **二分搜索**：这种单调性允许使用高效的二分搜索来找到阈值 $\\tau^\\star$。搜索在 $\\tau$ 的对数上进行，范围很广（例如，从 $10^{-20}$ 到 $10^{0}$）。\n3.  **过程**：\n    a. 初始化一个搜索范围 $[\\log \\tau_{\\min}, \\log \\tau_{\\max}]$。\n    b. 在每一步中，选择一个中点 $\\log \\tau_{\\text{mid}}$ 并计算相应的 $\\tau_{\\text{mid}} = 10^{\\log \\tau_{\\text{mid}}}$。\n    c. 使用 $\\tau_{\\text{mid}}$ 运行 AMR 模拟以获得错误比例。\n    d. 如果比例 $\\le \\delta$，则 $\\tau_{\\text{mid}}$ 是一个有效的容差。我们将其存储为潜在答案，并通过设置 $\\tau_{\\max} = \\tau_{\\text{mid}}$ 来尝试找到一个更小的有效容差。\n    e. 如果比例 $>\\delta$，则 $\\tau_{\\text{mid}}$ 太小。我们必须通过设置 $\\tau_{\\min} = \\tau_{\\text{mid}}$ 来增大它。\n4.  经过足够次数的迭代后，搜索将收敛到所需的 $\\tau^\\star$。对三个测试用例中的每一个重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef f(x, A, k):\n    \"\"\"The scalar field function f(x) = A * sin(k*x).\"\"\"\n    return A * np.sin(k * x)\n\ndef f_ddd(x, A, k):\n    \"\"\"The analytical third derivative of f(x).\"\"\"\n    return -A * k**3 * np.cos(k * x)\n\ndef run_amr_simulation(A, k, N0, Lmax, tau):\n    \"\"\"\n    Simulates the AMR process for a given tolerance tau.\n\n    Args:\n        A (float): Amplitude of the sine function.\n        k (float): Wavenumber of the sine function.\n        N0 (int): Number of cells in the base grid.\n        Lmax (int): Maximum refinement level.\n        tau (float): Refinement tolerance.\n\n    Returns:\n        tuple: (total_refinements, false_refinements)\n    \"\"\"\n    total_refinements = 0\n    false_refinements = 0\n\n    h0 = 1.0 / N0\n    # A list of cells to process, structured as (x_center, level, h).\n    # We use a list as a queue for breadth-first processing.\n    cells_to_process = [( (i + 0.5) * h0, 0, h0) for i in range(N0)]\n\n    head = 0\n    while head  len(cells_to_process):\n        x, level, h = cells_to_process[head]\n        head += 1\n\n        if level >= Lmax:\n            continue\n\n        # Compute numerical derivatives and the error indicator\n        h_half = h / 2.0\n        \n        g_h = (f(x + h, A, k) - f(x - h, A, k)) / (2.0 * h)\n        g_h_half = (f(x + h_half, A, k) - f(x - h_half, A, k)) / (2.0 * h_half)\n\n        indicator = np.abs(g_h_half - g_h)\n\n        # Check refinement criterion\n        if indicator > tau:\n            total_refinements += 1\n\n            # Check for false refinement\n            # The theoretical truncation error for the parent cell is |f'''(x)/6| * h^2\n            theoretical_trunc_err = np.abs(f_ddd(x, A, k) / 6.0) * h**2\n\n            if theoretical_trunc_err = tau:\n                false_refinements += 1\n\n            # Add two child cells to the processing list for further refinement\n            cells_to_process.append((x - h / 4.0, level + 1, h_half))\n            cells_to_process.append((x + h / 4.0, level + 1, h_half))\n\n    return total_refinements, false_refinements\n\ndef find_tau_star(params):\n    \"\"\"\n    Finds the smallest tolerance tau_star satisfying the false fraction condition.\n    \n    Args:\n        params (tuple): A tuple containing all parameters for a test case.\n\n    Returns:\n        float: The calculated smallest tolerance tau_star.\n    \"\"\"\n    A, k, N0, Lmax, delta = params\n\n    # Binary search for tau_star on a logarithmic scale.\n    # The range is chosen to be wide enough for all expected scales.\n    log_tau_min = -30.0\n    log_tau_max = 5.0\n    tau_star = 10**log_tau_max # Initialize with a safe upper bound.\n\n    # 100 iterations provide ample precision for a binary search.\n    for _ in range(100):\n        log_tau_mid = (log_tau_min + log_tau_max) / 2.0\n        tau_mid = 10**log_tau_mid\n\n        total_ref, false_ref = run_amr_simulation(A, k, N0, Lmax, tau_mid)\n\n        if total_ref == 0:\n            false_fraction = 0.0\n        else:\n            false_fraction = false_ref / total_ref\n\n        if false_fraction = delta:\n            # tau_mid is a valid tolerance. Store it and try for a smaller one.\n            tau_star = tau_mid\n            log_tau_max = log_tau_mid\n        else:\n            # tau_mid is too small. We need a larger tolerance.\n            log_tau_min = log_tau_mid\n\n    return tau_star\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (A, k, N0, Lmax, delta)\n    test_cases = [\n        # Case A: smooth, moderate amplitude\n        (1.0, 2.0 * np.pi, 64, 8, 0.05),\n        # Case B: round-off prone, tiny amplitude\n        (1.0e-12, 2.0 * np.pi, 64, 8, 0.05),\n        # Case C: high-frequency content\n        (1.0, 40.0 * np.pi, 128, 8, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        tau_star = find_tau_star(case)\n        results.append(f\"{tau_star:.6e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3536557"}]}