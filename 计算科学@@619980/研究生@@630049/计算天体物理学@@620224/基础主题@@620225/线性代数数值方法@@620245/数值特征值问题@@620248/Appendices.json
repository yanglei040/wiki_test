{"hands_on_practices": [{"introduction": "在深入研究复杂的数值方法之前，通过解析方法理解一个基础问题是至关重要的。本练习将探讨一维离散拉普拉斯算子——许多物理模拟（如热扩散和波动方程）的基石。通过推导其精确的本征对 [@problem_id:3526049]，您将深入了解离散化如何产生与连续傅里叶模式相对应的量化本征模，并理解边界条件在其中的决定性作用。", "problem": "一个厚度为 $L$ 的平行平面、光学厚的天体物理平板，在笛卡尔坐标 $x \\in [0,L]$ 方向上存在热扩散。由于与周围介质存在高效的辐射耦合，其边界温度保持固定。\n\n为了分析显式时间积分格式的数值稳定性和模态内容，我们考虑带齐次狄利克雷边界条件 $u(0)=0$ 和 $u(L)=0$ 的一维二阶导数 $d^2/dx^2$ 所对应的空间算子。\n\n使用 $N$ 个内部网格点将该区间离散化，网格点位置为 $x_{j} = j h$，其中 $j \\in \\{1,2,\\dots,N\\}$，$h = L/(N+1)$。使用基于导数作为差商极限的定义所构建的标准二阶中心有限差分来近似二阶导数。通过将常规的有限差分矩阵乘以 $h^{2}$ 来定义无量纲离散拉普拉斯矩阵 $\\tilde{\\mathcal{L}} \\in \\mathbb{R}^{N \\times N}$，其矩阵元素为\n$$\n\\tilde{\\mathcal{L}}_{j,j} = -2, \\quad \\tilde{\\mathcal{L}}_{j,j+1} = 1, \\quad \\tilde{\\mathcal{L}}_{j,j-1} = 1,\n$$\n所有其他元素均为 $0$，并带有隐式狄利克雷条件 $u_0=0$ 和 $u_{N+1}=0$。\n\n从这些定义和边界条件出发，推导 $\\tilde{\\mathcal{L}}$ 的特征对 $\\big(\\lambda_{k}, v^{(k)}\\big)$，并证明每个特征向量 $v^{(k)}$ 的分量是关于网格指数的正弦函数形式，且与狄利克雷边界一致。你的推导应从特征值方程所蕴含的有限差分递推关系开始，并说明满足边界条件的容许离散波数的合理性。\n\n最后，给出 $\\tilde{\\mathcal{L}}$ 的第 $k$ 个特征值 $\\lambda_{k}$ 作为整数 $N \\ge 2$ 和 $k \\in \\{1,2,\\dots,N\\}$ 的函数的解析表达式。请将最终答案表示为单个闭式符号表达式。无需四舍五入，无量纲矩阵 $\\tilde{\\mathcal{L}}$ 也无需物理单位。", "solution": "该问题陈述已经过验证，被认为是数值分析领域一个有效的、适定的问题，具体涉及带齐次狄利克雷边界条件的一维离散拉普拉斯算子的特征值问题。该问题是自洽的、有科学依据且客观的。这是计算数学中的一个标准练习。\n\n任务是求出无量纲离散拉普拉斯矩阵 $\\tilde{\\mathcal{L}} \\in \\mathbb{R}^{N \\times N}$ 的特征值和特征向量，其元素定义为 $\\tilde{\\mathcal{L}}_{j,j} = -2$，$\\tilde{\\mathcal{L}}_{j,j+1} = 1$ 和 $\\tilde{\\mathcal{L}}_{j,j-1} = 1$。特征值方程为\n$$\n\\tilde{\\mathcal{L}} v = \\lambda v\n$$\n其中 $\\lambda$ 是一个特征值，$v$ 是对应的特征向量，其分量为 $v_j$，$j \\in \\{1, 2, \\dots, N\\}$。\n\n将此矩阵方程写出其第 $j$ 个分量，我们得到一个线性递推关系：\n$$\n\\tilde{\\mathcal{L}}_{j,j-1} v_{j-1} + \\tilde{\\mathcal{L}}_{j,j} v_j + \\tilde{\\mathcal{L}}_{j,j+1} v_{j+1} = \\lambda v_j\n$$\n代入矩阵元素可得：\n$$\nv_{j-1} - 2v_j + v_{j+1} = \\lambda v_j\n$$\n此关系对 $j = 1, 2, \\dots, N$ 成立。问题指定了齐次狄利克雷边界条件，在此离散设置中即为 $v_0 = 0$ 和 $v_{N+1} = 0$。\n\n我们可以将递推关系重新整理为：\n$$\nv_{j+1} + v_{j-1} = (2 + \\lambda) v_j\n$$\n这是一个二阶常系数齐次线性差分方程。我们寻找形式为 $v_j = z^j$ 的解，其中 $z$ 是某个复数。将此设想解代入递推关系，得到特征方程：\n$$\nz^{j+1} + z^{j-1} = (2 + \\lambda) z^j\n$$\n两边除以 $z^{j-1}$（对于非平凡解，$z \\neq 0$ 必须成立），我们得到：\n$$\nz^2 + 1 = (2 + \\lambda) z\n$$\n$$\nz^2 - (2 + \\lambda)z + 1 = 0\n$$\n矩阵 $\\tilde{\\mathcal{L}}$ 是实对称的，因此其特征值 $\\lambda$ 是实数。此外，作为带狄利克雷条件的二阶导数的离散表示，其特征值是负的。具体来说，可以证明 $-4  \\lambda  0$。对于这个范围的 $\\lambda$，项 $2+\\lambda$ 位于区间 $(-2, 2)$ 内，二次方程的判别式 $\\Delta = (2+\\lambda)^2 - 4$ 为负。因此，$z$ 的根是一对共轭复数。\n\n我们定义一个角 $\\theta$ 使得 $2 + \\lambda = 2 \\cos(\\theta)$。特征方程变为：\n$$\nz^2 - 2\\cos(\\theta) z + 1 = 0\n$$\n根由求根公式给出：\n$$\nz = \\frac{2\\cos(\\theta) \\pm \\sqrt{4\\cos^2(\\theta) - 4}}{2} = \\frac{2\\cos(\\theta) \\pm 2i\\sin(\\theta)}{2} = \\cos(\\theta) \\pm i\\sin(\\theta) = e^{\\pm i\\theta}\n$$\n$v_j$ 的通解是与这些根对应的两个独立解的线性组合：\n$$\nv_j = A e^{ij\\theta} + B e^{-ij\\theta}\n$$\n使用欧拉公式，这可以表示为正弦函数的形式：\n$$\nv_j = C \\sin(j\\theta) + D \\cos(j\\theta)\n$$\n其中 $C$ 和 $D$ 为某些常数。\n\n现在我们应用边界条件。第一个条件是 $v_0 = 0$：\n$$\nv_0 = C \\sin(0 \\cdot \\theta) + D \\cos(0 \\cdot \\theta) = C \\cdot 0 + D \\cdot 1 = D = 0\n$$\n这使得系数 $D$ 必须为零，因此解必须具有 $v_j = C \\sin(j\\theta)$ 的形式。这证明了特征向量分量是关于网格指数 $j$ 的正弦函数，与要求一致。\n\n第二个边界条件是 $v_{N+1} = 0$：\n$$\nv_{N+1} = C \\sin((N+1)\\theta) = 0\n$$\n对于一个非平凡的特征向量，我们必须有 $C \\neq 0$。因此，正弦函数的自变量必须是 $\\pi$ 的整数倍：\n$$\n(N+1)\\theta = k\\pi, \\quad k \\in \\mathbb{Z}\n$$\n这将容许的 $\\theta$ 值量子化：\n$$\n\\theta_k = \\frac{k\\pi}{N+1}\n$$\n因此，第 $k$ 个特征向量的分量由下式给出：\n$$\nv_j^{(k)} = C \\sin\\left(\\frac{jk\\pi}{N+1}\\right)\n$$\n我们必须确定能产生一组完备的线性无关特征向量的整数模态指数 $k$ 的范围。\n- 如果 $k=0$，则 $\\theta_0=0$ 且对所有 $j$ 有 $v_j^{(0)} = C\\sin(0) = 0$。这是零向量，不是特征向量。\n- 指数 $j$ 的范围是从 $1$ 到 $N$。如果 $k = N+1$，则对所有整数 $j$ 有 $v_j^{(N+1)} = C\\sin(j\\pi) = 0$。这也是零向量。\n- 对于 $k \\in \\{1, 2, \\dots, N\\}$，我们得到 $N$ 个非平凡的线性无关向量。\n- 对于其他整数值 $k$，得到的向量不是新的。例如，对于 $k' = -k$，$v_j^{(-k)} = C \\sin(-jk\\pi/(N+1)) = -v_j^{(k)}$，这只是第 $k$ 个特征向量的一个缩放。类似地，由于 $\\sin(x+2\\pi) = \\sin(x)$，$k' = k+2(N+1)$ 会产生相同的特征向量。\n\n因此，通过取 $k \\in \\{1, 2, \\dots, N\\}$，可以获得一组包含 $N$ 个特征向量的完备且唯一的集合。\n\n最后，我们推导特征值 $\\lambda_k$ 的表达式。我们已经建立了关系 $2 + \\lambda = 2 \\cos(\\theta)$。代入量子化的值 $\\theta_k$ 可得：\n$$\n2 + \\lambda_k = 2\\cos\\left(\\frac{k\\pi}{N+1}\\right)\n$$\n$$\n\\lambda_k = 2\\cos\\left(\\frac{k\\pi}{N+1}\\right) - 2\n$$\n使用三角恒等式 $\\cos(2\\alpha) = 1 - 2\\sin^2(\\alpha)$，或等价地 $\\cos(x)-1 = -2\\sin^2(x/2)$，我们可以重写 $\\lambda_k$ 的表达式：\n$$\n\\lambda_k = -2 \\left(1 - \\cos\\left(\\frac{k\\pi}{N+1}\\right)\\right) = -2 \\left(2\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right)\\right)\n$$\n这就给出了特征值的最终闭式表达式：\n$$\n\\lambda_k = -4\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right)\n$$\n这就是所要求的 $\\tilde{\\mathcal{L}}$ 的第 $k$ 个特征值作为 $N$ 和 $k$ 的函数的解析表达式，其中 $k \\in \\{1, 2, \\dots, N\\}$。", "answer": "$$\\boxed{-4\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right)}$$", "id": "3526049"}, {"introduction": "接下来，我们将从一个理想化的算子转向一个更现实的天体物理模型：恒星振荡。这类物理系统通常通过Sturm–Liouville问题来描述，其离散化（例如使用有限元法）会产生一个广义本征值问题 $Kx = \\lambda Bx$。这个实践练习 [@problem_id:3526022] 将指导您使用有限元方法建立并求解这样一个广义问题，并通过验证解的 $B$-正交性来巩固对数值解性质的理解。", "problem": "考虑一个广义自伴 Sturm–Liouville 特征值问题，该问题模拟了一颗恒星在一维空间中的球对称振荡模式，定义在区间 $\\left[0,R\\right]$ 上，\n$$\n-\\frac{d}{dr}\\left(p(r)\\frac{d\\xi}{dr}\\right) + q(r)\\,\\xi(r) \\;=\\; \\lambda\\, w(r)\\,\\xi(r),\n$$\n其中 $r$ 是径向坐标，$\\xi(r)$ 是位移本征函数，$\\lambda$ 是特征值，$p(r)$ 是一个正的刚度分布，$q(r)$ 是一个非负的恢复分布，而 $w(r)$ 是一个与密度分布成正比的正权重。施加齐次 Dirichlet 边界条件 $\\xi(0)=0$ 和 $\\xi(R)=0$。假设有以下天体物理学上合理的分布：\n$$\np(r) = r^2,\\quad q(r) = \\alpha\\, r^2,\\quad w(r) = r^2\\,\\rho(r),\\quad \\rho(r) = \\rho_c\\left(1 - \\left(\\frac{r}{R}\\right)^2\\right),\n$$\n其中 $\\alpha > 0$ 且 $\\rho_c > 0$。在 $H_0^1(0,R)$ 上的弱形式是：寻找 $\\lambda \\in \\mathbb{R}$ 和 $\\xi \\neq 0$，使得对于所有测试函数 $\\eta$，\n$$\n\\int_0^R p(r)\\,\\frac{d\\xi}{dr}\\,\\frac{d\\eta}{dr}\\,dr \\;+\\; \\int_0^R q(r)\\,\\xi(r)\\,\\eta(r)\\,dr \\;=\\; \\lambda \\int_0^R w(r)\\,\\xi(r)\\,\\eta(r)\\,dr.\n$$\n使用有限元 (FE) 方法，在 $\\left[0,R\\right]$ 上一个包含 $N$ 个单元的均匀网格上，利用连续分段线性基函数来离散化此弱形式，通过消除在 $r=0$ 和 $r=R$ 处的边界自由度来强制执行 Dirichlet 边界条件。组装对称刚度矩阵 $K \\in \\mathbb{R}^{n \\times n}$ 和对称正定质量矩阵 $B \\in \\mathbb{R}^{n \\times n}$，其中 $n = N-1$ 是内部节点的数量。在每个单元上使用 3 点 Gauss–Legendre 求积法来计算所有需要的积分。求解广义对称特征值问题\n$$\nK\\,x = \\lambda\\,B\\,x,\n$$\n并将前 $m$ 个本征模收集到模态矩阵 $X \\in \\mathbb{R}^{n \\times m}$ 中，其列是对应于 $m$ 个最小特征值的特征向量。\n\n将计算出的本征模相对于 $B$ 进行归一化，使得 $X$ 的每一列 $x$ 都满足 $x^\\top B\\,x = 1$。然后通过计算\n$$\nM \\;=\\; X^\\top B\\,X,\n$$\n来数值验证 $B$-正交性，并用两种方式量化与精确正交归一性的偏差：\n- 最大绝对非对角元素幅值，$s = \\max_{i \\neq j} \\left|M_{ij}\\right|$。\n- 对角元素与 1 的最大绝对偏差，$t = \\max_{i} \\left|M_{ii} - 1\\right|$。\n\n您的程序必须实现此过程，并为以下每个由 $(N, R, \\rho_c, \\alpha, m)$ 指定的测试套件生成结果：\n- 情况 A: $(N, R, \\rho_c, \\alpha, m) = (32, 1, 1, 0.05, 6)$。\n- 情况 B: $(N, R, \\rho_c, \\alpha, m) = (64, 1, 1, 0.0001, 6)$。\n- 情况 C: $(N, R, \\rho_c, \\alpha, m) = (16, 1, 1000, 0.2, 4)$。\n\n对于每种情况，输出实数对 $[s, t]$。您的程序应生成单行输出，其中包含这些对的逗号分隔列表，并用方括号括起来。例如，要求的最终输出格式为\n$$\n\\left[ [s_A, t_A], [s_B, t_B], [s_C, t_C] \\right],\n$$\n其中 $[s_A, t_A]$ 对应情况 A，$[s_B, t_B]$ 对应情况 B，$[s_C, t_C]$ 对应情况 C。此问题中不需要物理单位，因为所有量都已无量纲化。", "solution": "计算恒星球对称振荡模式的问题表现为一个在区间 $\\left[0,R\\right]$ 上的广义自伴 Sturm–Liouville 特征值问题。解决方案需要使用有限元 (FE) 方法离散化此问题，然后数值求解所得的矩阵特征值问题。步骤如下。\n\n首先，我们从问题的弱（或变分）形式开始，该形式已给出。寻找一个特征值 $\\lambda \\in \\mathbb{R}$ 和一个非平凡的本征函数 $\\xi \\in H_0^1(0,R)$，使得对于所有测试函数 $\\eta \\in H_0^1(0,R)$：\n$$\na(\\xi, \\eta) = \\lambda\\, b(\\xi, \\eta)\n$$\n其中双线性形式 $a(\\cdot, \\cdot)$ 和 $b(\\cdot, \\cdot)$ 定义为：\n$$\na(\\xi, \\eta) = \\int_0^R p(r)\\,\\frac{d\\xi}{dr}\\,\\frac{d\\eta}{dr}\\,dr \\;+\\; \\int_0^R q(r)\\,\\xi(r)\\,\\eta(r)\\,dr\n$$\n$$\nb(\\xi, \\eta) = \\int_0^R w(r)\\,\\xi(r)\\,\\eta(r)\\,dr\n$$\n空间 $H_0^1(0,R)$ 是具有平方可积一阶导数且在边界 $r=0$ 和 $r=R$ 处为零的函数的 Sobolev 空间。系数给定为 $p(r) = r^2$，$q(r) = \\alpha r^2$，以及 $w(r) = r^2\\rho_c(1-(r/R)^2)$。由于当 $r \\in (0,R]$ 时 $p(r)>0$，$\\alpha>0$ 且 $\\rho_c>0$，双线性形式 $a(\\cdot,\\cdot)$ 是对称正定的，在 $H_0^1(0,R)$ 上定义了一个内积。类似地，由于当 $r \\in (0,R)$ 时 $w(r)>0$，$b(\\cdot,\\cdot)$ 也是对称正定的，在 $L^2(0,R)$ 上定义了一个内积。\n\n其次，我们应用有限元方法。区域 $[0,R]$ 被离散化为 $N$ 个单元的均匀网格，单元大小为 $h = R/N$。这会创建位于 $r_i = i h$（$i=0, 1, \\dots, N$）的 $N+1$ 个节点。解 $\\xi(r)$ 由函数 $\\xi_h(r)$ 近似，该函数是连续分段线性基函数（帽函数）$\\phi_j(r)$ 的线性组合：\n$$\n\\xi(r) \\approx \\xi_h(r) = \\sum_{j=1}^{N-1} x_j \\phi_j(r)\n$$\n求和遍及 $n = N-1$ 个内部节点（$j=1, \\dots, N-1$），因为齐次 Dirichlet 边界条件 $\\xi(0)=0$ 和 $\\xi(R)=0$ 通过排除与边界节点相关的基函数 $\\phi_0(r)$ 和 $\\phi_N(r)$ 来强制执行。系数 $x_j$ 是近似解在内部节点 $\\xi_h(r_j)$ 处的未知值。\n\n第三，我们采用 Galerkin 方法，其中测试函数 $\\eta$ 从与试探函数 $\\xi_h$ 相同的有限维空间中选取。我们为每个内部基函数设置 $\\eta = \\phi_i(r)$（$i = 1, \\dots, N-1$）。将近似解 $\\xi_h$ 和测试函数 $\\phi_i$ 代入弱形式，得到一个包含 $n$ 个线性方程的方程组：\n$$\n\\sum_{j=1}^{N-1} a(\\phi_j, \\phi_i) x_j = \\lambda \\sum_{j=1}^{N-1} b(\\phi_j, \\phi_i) x_j \\quad \\text{for } i=1, \\dots, N-1\n$$\n这是一个广义矩阵特征值问题 $Kx = \\lambda Bx$，其中 $x = [x_1, \\dots, x_{N-1}]^\\top$ 是未知系数向量，而 $K$ 和 $B$ 分别是全局刚度矩阵和质量矩阵。它们的元素由下式给出：\n$$\nK_{ij} = a(\\phi_j, \\phi_i) = \\int_0^R \\left( p(r) \\frac{d\\phi_j}{dr} \\frac{d\\phi_i}{dr} + q(r) \\phi_j(r) \\phi_i(r) \\right) dr\n$$\n$$\nB_{ij} = b(\\phi_j, \\phi_i) = \\int_0^R w(r) \\phi_j(r) \\phi_i(r) dr\n$$\n这些矩阵是对称的，并且由于双线性形式的性质，$K$ 是正定的，$B$ 也是正定的。\n\n第四，矩阵元素的积分在每个单元上使用 3 点 Gauss-Legendre 求积法进行数值计算。基函数 $\\phi_i$ 仅在最多两个相邻单元上非零，这使得矩阵 $K$ 和 $B$ 是稀疏的（具体来说是三对角的）。对于每个单元 $[r_e, r_{e+1}]$，我们通过计算 $2 \\times 2$ 的局部矩阵来计算对全局矩阵的贡献。单元上的积分被转换到参考区间 $[-1,1]$ 并近似为：\n$$\n\\int_{r_e}^{r_{e+1}} f(r) dr \\approx \\frac{h}{2} \\sum_{k=1}^{3} w_k^{\\text{Gauss}} f(r(z_k))\n$$\n其中 $z_k$ 和 $w_k^{\\text{Gauss}}$ 是求积点和权重，$r(z_k)$ 是物理单元中的对应点。\n\n第五，组装好 $n \\times n$ 矩阵 $K$ 和 $B$ 后，求解广义对称特征值问题 $Kx=\\lambda Bx$，以获得 $m$ 个最小的特征值和相应的特征向量。这可以通过使用专门的数值求解器（如 `scipy.linalg.eigh`）来完成，该求解器专为此类问题设计，并返回按升序排列的特征值以及相对于矩阵 $B$ 正交归一的特征向量。\n\n最后，计算出的特征向量（构成模态矩阵 $X \\in \\mathbb{R}^{n \\times m}$ 的列）已经被归一化，使得 $x^\\top B x = 1$。为验证 $B$-正交性的数值精度，我们计算矩阵 $M = X^\\top B X$。对于精确算术和完美的特征向量，$M$ 将是单位矩阵。与此理想情况的偏差由两个度量标准量化：最大绝对非对角元素幅值，$s = \\max_{i \\neq j} |M_{ij}|$，以及对角元素与 1 的最大绝对偏差，$t = \\max_i |M_{ii} - 1|$。这些值提供了对所计算本征模质量的度量。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef analyze_modes(N, R, rho_c, alpha, m):\n    \"\"\"\n    Solves the Sturm-Liouville problem using FEM and verifies mode orthogonality.\n\n    Args:\n        N (int): Number of elements.\n        R (float): Radius of the star (domain endpoint).\n        rho_c (float): Central density parameter.\n        alpha (float): Parameter for the q(r) profile.\n        m (int): Number of smallest eigenmodes to compute.\n\n    Returns:\n        tuple[float, float]: A pair [s, t] where s is the max absolute off-diagonal\n                             magnitude and t is the max absolute diagonal deviation.\n    \"\"\"\n    # Number of interior nodes\n    n = N - 1\n    # Element size\n    h = R / N\n\n    # 3-point Gauss-Legendre quadrature points and weights on [-1, 1]\n    z_gauss = np.array([-np.sqrt(3/5), 0, np.sqrt(3/5)])\n    w_gauss = np.array([5/9, 8/9, 5/9])\n\n    # Initialize global stiffness (K) and mass (B) matrices\n    K = np.zeros((n, n))\n    B = np.zeros((n, n))\n\n    # Define coefficient functions based on the problem statement\n    def p(r): return r**2\n    def q(r): return alpha * r**2\n    def w(r): return r**2 * rho_c * (1 - (r/R)**2) if R  0 else 0\n\n    # Assemble matrices element by element\n    for e in range(N):\n        r_e = e * h\n        \n        # Local 2x2 matrices for the current element\n        K_loc = np.zeros((2, 2))\n        B_loc = np.zeros((2, 2))\n        \n        # Integrate over the element using Gauss quadrature\n        for k in range(len(z_gauss)):\n            s_k = z_gauss[k]\n            weight_k = w_gauss[k]\n\n            # Map from reference element [-1, 1] to physical element [r_e, r_{e+1}]\n            r_k = r_e + (1 + s_k) * h / 2\n            jac = h / 2\n            \n            p_val = p(r_k)\n            q_val = q(r_k)\n            w_val = w(r_k)\n            \n            # Hat basis functions and their derivatives on the reference element\n            psi = np.array([(1 - s_k) / 2, (1 + s_k) / 2])\n            dpsi_dr = np.array([-1 / h, 1 / h])\n\n            for i in range(2):\n                for j in range(2):\n                    # Integral for stiffness matrix K\n                    integ_K = p_val * dpsi_dr[i] * dpsi_dr[j] + q_val * psi[i] * psi[j]\n                    K_loc[i, j] += weight_k * integ_K * jac\n                    \n                    # Integral for mass matrix B\n                    integ_B = w_val * psi[i] * psi[j]\n                    B_loc[i, j] += weight_k * integ_B * jac\n    \n        # Assemble local matrices into global matrices, considering only interior nodes\n        # Global matrix indices go from 0 to n-1, corresponding to nodes 1 to N-1\n        \n        # Left node of element 'e' is node 'e'. It is interior if e  0.\n        if e  0:\n            g_idx = e - 1\n            K[g_idx, g_idx] += K_loc[0, 0]\n            B[g_idx, g_idx] += B_loc[0, 0]\n\n        # Right node of element 'e' is node 'e+1'. It is interior if e+1  N.\n        if e  N - 1:\n            g_idx = e  # Corresponds to node e+1, so matrix index is (e+1)-1\n            K[g_idx, g_idx] += K_loc[1, 1]\n            B[g_idx, g_idx] += B_loc[1, 1]\n\n        # Off-diagonal terms if both nodes of the element are interior\n        if e  0 and e  N - 1:\n            g_idx_i = e - 1\n            g_idx_j = e\n            K[g_idx_i, g_idx_j] += K_loc[0, 1]\n            K[g_idx_j, g_idx_i] += K_loc[1, 0]\n            B[g_idx_i, g_idx_j] += B_loc[0, 1]\n            B[g_idx_j, g_idx_i] += B_loc[1, 0]\n\n    # Solve the generalized symmetric eigenvalue problem K*x = lambda*B*x\n    # eigh returns eigenvalues in ascending order and B-orthonormalized eigenvectors\n    eigvals, eigvecs = eigh(K, B)\n    \n    # Collect the first m eigenmodes (eigenvectors)\n    X = eigvecs[:, :m]\n    \n    # Numerically verify B-orthogonality by computing M = X^T * B * X\n    M = X.T @ B @ X\n    \n    # Quantify the deviation from orthonormality\n    # s: maximum absolute off-diagonal magnitude\n    M_off_diag = M.copy()\n    np.fill_diagonal(M_off_diag, 0)\n    s = np.max(np.abs(M_off_diag))\n    \n    # t: maximum absolute diagonal deviation from unity\n    t = np.max(np.abs(np.diag(M) - 1))\n    \n    return s, t\n\ndef solve():\n    # Define the test cases from the problem statement\n    test_cases = [\n        # (N, R, rho_c, alpha, m)\n        (32, 1, 1, 0.05, 6),      # Case A\n        (64, 1, 1, 0.0001, 6),    # Case B\n        (16, 1, 1000, 0.2, 4),    # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        s, t = analyze_modes(*case)\n        results.append([s, t])\n\n    # Format the final output string as specified\n    formatted_results = [f\"[{s},{t}]\" for s, t in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3526022"}, {"introduction": "本征值分析的强大之处不仅在于揭示物理系统的模式，还在于它可以用来分析和优化数值算法本身。本高级练习 [@problem_id:3525939] 关注一个辐射磁流体动力学（R-MHD）的隐式-显式（IMEX）时间步进格式的稳定性。通过计算其误差传播算子的谱半径（即最大本征值的模），我们可以量化格式的稳定性，并系统地优化其参数以获得最佳的鲁棒性和效率，这是计算科学家的一项核心技能。", "problem": "考虑一个无量纲的线性化辐射磁流体力学（R-MHD）模型，该模型通过对均匀背景态应用空间傅里叶变换而导出，因此空间导数对于波数 $k$ 映射为 $\\partial_x \\mapsto i k$。状态向量为 $y = [\\delta u, \\delta b, \\delta E_r]^\\top$，其中 $\\delta u$ 是速度扰动，$\\delta b$ 是磁场扰动，$\\delta E_r$ 是辐射能量扰动。令 $\\mathrm{Implicit\\mbox{-}Explicit}$ (IMEX) 表示隐式-显式时间步进，令 $\\mathrm{Magnetohydrodynamics}$ (MHD) 表示磁流体力学。\n\n我们将线性算子分裂为一个显式双曲部分和一个隐式刚性部分。显式部分模拟了非耗散的阿尔芬耦合：\n$$\nA_{\\mathrm{exp}}(k, v_A) =\n\\begin{bmatrix}\n0   i k v_A^2  0 \\\\\ni k  0  0 \\\\\n0  0  0\n\\end{bmatrix},\n$$\n其中 $v_A$ 是阿尔芬速度。隐式部分模拟了辐射扩散、辐射-物质耦合和磁扩散：\n$$\nA_{\\mathrm{imp}}(k, D, \\chi, \\nu, \\gamma, \\gamma_c, \\eta_b) =\n\\begin{bmatrix}\n-\\nu  0  -i k \\gamma \\\\\n0  -\\eta_b  0 \\\\\ni k \\gamma_c  0  -(D k^2 + \\chi)\n\\end{bmatrix},\n$$\n其中 $D$ 是辐射扩散系数，$\\chi$ 是辐射-物质弛豫率，$\\nu$ 是对气体的辐射拖拽，$\\gamma$ 和 $\\gamma_c$ 是气体与辐射之间的动量-能量交换系数，$\\eta_b$ 是磁扩散系数。所有量都是无量纲的。\n\n考虑一个单步 IMEX-$\\theta$ 方法，该方法由两个分裂系数 $0 \\le \\alpha \\le 1$ 和 $0 \\le \\beta \\le 1$ 参数化，这两个系数混合了对两个算子分裂的显式和隐式处理。该方法通过以下方式将 $y^n$推进到 $y^{n+1}$：\n$$\n\\left(\\mathbf{I} - \\Delta t \\left[ \\alpha A_{\\mathrm{exp}} + \\beta A_{\\mathrm{imp}} \\right] \\right) y^{n+1}\n=\n\\left(\\mathbf{I} + \\Delta t \\left[ (1 - \\alpha) A_{\\mathrm{exp}} + (1 - \\beta) A_{\\mathrm{imp}} \\right] \\right) y^{n},\n$$\n其中 $\\mathbf{I}$ 是单位矩阵，$\\Delta t$ 是时间步长。相关的线性误差传播（放大）算子是：\n$$\nG(\\Delta t, k, \\alpha, \\beta, \\text{params}) =\n\\left(\\mathbf{I} - \\Delta t \\left[ \\alpha A_{\\mathrm{exp}} + \\beta A_{\\mathrm{imp}} \\right] \\right)^{-1}\n\\left(\\mathbf{I} + \\Delta t \\left[ (1 - \\alpha) A_{\\mathrm{exp}} + (1 - \\beta) A_{\\mathrm{imp}} \\right] \\right).\n$$\n对于给定的参数集，$G$ 的特征值决定了该格式的线性稳定性；谱半径 $\\rho(G)$，定义为 $G$ 的特征值的最大模，量化了每时间步的误差放大。在 $[0,1] \\times [0,1]$ 上最小化 $\\rho(G)$ 关于 $(\\alpha, \\beta)$ 的值，可以提高 IMEX 分裂的稳定性和鲁棒性。\n\n任务：编写一个完整的、可运行的程序，对于下面的每个测试案例，构造 $A_{\\mathrm{exp}}$ 和 $A_{\\mathrm{imp}}$，计算 $G(\\Delta t, k, \\alpha, \\beta)$，并在 $(\\alpha, \\beta)$ 上搜索，以找到使谱半径 $\\rho(G)$ 最小化的对。在 $[0,1]$ 上对 $(\\alpha, \\beta)$ 使用粗略步长为 $0.02$ 的网格搜索，然后在最佳粗网格对周围的有界邻域内，使用步长为 $0.005$ 进行局部加密，结果限制在 $[0,1]$ 内。对于奇异矩阵，即 $\\left(\\mathbf{I} - \\Delta t [ \\alpha A_{\\mathrm{exp}} + \\beta A_{\\mathrm{imp}} ]\\right)$ 不可逆的情况，将该 $(\\alpha, \\beta)$ 对应的 $\\rho(G)$ 视为 $+\\infty$。\n\n所有量都是无量纲的，所有角度（如果有的话）都应以弧度解释；然而，此处不需要角度输入。最终的数值输出必须是浮点数。对于每个测试案例，报告最优的 $(\\alpha^\\star, \\beta^\\star)$ 和最小化的谱半径 $\\rho^\\star = \\min_{(\\alpha,\\beta)} \\rho(G)$。将报告的每个浮点数四舍五入到六位小数。\n\n测试套件（每个案例的无量纲参数）：\n- 案例1：$\\Delta t = 0.10$, $k = 1.00$, $v_A = 1.00$, $D = 0.30$, $\\chi = 1.20$, $\\nu = 0.05$, $\\gamma = 0.40$, $\\gamma_c = 0.40$, $\\eta_b = 0.02$。\n- 案例2：$\\Delta t = 0.01$, $k = 5.00$, $v_A = 0.60$, $D = 8.00$, $\\chi = 6.00$, $\\nu = 0.20$, $\\gamma = 0.50$, $\\gamma_c = 0.50$, $\\eta_b = 0.10$。\n- 案例3：$\\Delta t = 0.05$, $k = 2.00$, $v_A = 3.00$, $D = 0.10$, $\\chi = 0.40$, $\\nu = 0.02$, $\\gamma = 0.20$, $\\gamma_c = 0.20$, $\\eta_b = 0.00$。\n- 案例4：$\\Delta t = 0.30$, $k = 1.50$, $v_A = 0.70$, $D = 2.00$, $\\chi = 2.00$, $\\nu = 0.10$, $\\gamma = 0.00$, $\\gamma_c = 0.00$, $\\eta_b = 0.00$。\n\n程序要求：\n- 严格按照上述定义构造 $A_{\\mathrm{exp}}$ 和 $A_{\\mathrm{imp}}$。\n- 对于每个候选 $(\\alpha, \\beta)$，计算 $G$ 及其特征值，然后计算谱半径 $\\rho(G)$。\n- 对每个案例执行两阶段网格搜索，以找到 $(\\alpha^\\star, \\beta^\\star)$ 和 $\\rho^\\star$。\n- 将 $(\\alpha^\\star, \\beta^\\star, \\rho^\\star)$ 四舍五入到六位小数用于输出。\n- 最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，其中每个元素是一个包含三个浮点数 $[\\alpha^\\star, \\beta^\\star, \\rho^\\star]$ 的列表，对应于每个案例，顺序与测试套件相同（例如，$[[a_1,b_1,r_1],[a_2,b_2,r_2],\\dots]$）。", "solution": "该问题已经过验证，被认为具有科学依据、适定且客观。它提出了一个在计算天体物理学背景下的标准数值分析任务，具体来说是针对一个线性化辐射磁流体力学（R-MHD）模型的隐式-显式（IMEX）时间步进格式的优化。我们将提供一个完整的解答。\n\n目标是在单位正方形 $[0,1] \\times [0,1]$ 内找到分裂参数 $(\\alpha^\\star, \\beta^\\star)$，使得对于给定的物理参数集，放大算子 $G$ 的谱半径 $\\rho(G)$ 最小。放大算子 $G$ 决定了数值格式的误差从一个时间步到下一个时间步的传播。\n\n放大算子定义为：\n$$\nG(\\Delta t, k, \\alpha, \\beta, \\text{params}) =\n\\left(\\mathbf{I} - \\Delta t \\left[ \\alpha A_{\\mathrm{exp}} + \\beta A_{\\mathrm{imp}} \\right] \\right)^{-1}\n\\left(\\mathbf{I} + \\Delta t \\left[ (1 - \\alpha) A_{\\mathrm{exp}} + (1 - \\beta) A_{\\mathrm{imp}} \\right] \\right)\n$$\n其中 $\\mathbf{I}$ 是 $3 \\times 3$ 单位矩阵，$\\Delta t$ 是时间步长，$A_{\\mathrm{exp}}$ 和 $A_{\\mathrm{imp}}$ 是控制线性算子的显式和隐式部分。\n\n每个测试案例的求解过程包括以下步骤：\n\n1.  **构造系统矩阵**：根据所提供的物理参数构造显式和隐式矩阵 $A_{\\mathrm{exp}}$ 和 $A_{\\mathrm{imp}}$。两个矩阵都是 $3 \\times 3$ 且为复数值。\n\n    显式矩阵 $A_{\\mathrm{exp}}$ 取决于波数 $k$ 和阿尔芬速度 $v_A$：\n    $$\n    A_{\\mathrm{exp}}(k, v_A) =\n    \\begin{bmatrix}\n    0   i k v_A^2  0 \\\\\n    i k  0  0 \\\\\n    0  0  0\n    \\end{bmatrix}\n    $$\n    隐式矩阵 $A_{\\mathrm{imp}}$ 取决于 $k$ 和几个耗散与耦合系数（$D$、$\\chi$、$\\nu$、$\\gamma$、$\\gamma_c$、$\\eta_b$）：\n    $$\n    A_{\\mathrm{imp}}(k, D, \\chi, \\nu, \\gamma, \\gamma_c, \\eta_b) =\n    \\begin{bmatrix}\n    -\\nu  0  -i k \\gamma \\\\\n    0  -\\eta_b  0 \\\\\n    i k \\gamma_c  0  -(D k^2 + \\chi)\n    \\end{bmatrix}\n    $$\n    这里，$i$ 是虚数单位，$i^2 = -1$。所有涉及这些矩阵的数值计算都必须使用复数运算。\n\n2.  **定义目标函数**：我们定义一个函数，对于给定的 IMEX 参数对 $(\\alpha, \\beta)$，计算谱半径 $\\rho(G)$。这包括：\n    a.  构造复合矩阵 $L = \\mathbf{I} - \\Delta t (\\alpha A_{\\mathrm{exp}} + \\beta A_{\\mathrm{imp}})$ 和 $R = \\mathbf{I} + \\Delta t ((1-\\alpha)A_{\\mathrm{exp}} + (1-\\beta)A_{\\mathrm{imp}})$。\n    b.  尝试计算 $G = L^{-1} R$。如果 $L$ 是奇异的（不可逆的），其行列式为零，求逆会失败。根据问题陈述，在这种情况下，我们将谱半径 $\\rho(G)$ 视为 $+\\infty$。这有效地惩罚了导致奇异更新步骤的参数选择。\n    c.  如果 $L$ 是可逆的，我们计算所得矩阵 $G$ 的特征值 $\\lambda_j$。\n    d.  谱半径是这些特征值的最大模：$\\rho(G) = \\max_j|\\lambda_j|$。\n\n3.  **执行两阶段网格搜索**：为了找到最小化 $\\rho(G)$ 的最优 $(\\alpha^\\star, \\beta^\\star)$，我们采用在域 $[0,1] \\times [0,1]$ 上的两阶段网格搜索。\n\n    a.  **粗略搜索**：为 $\\alpha$ 和 $\\beta$ 创建一个从 $0$ 到 $1$、步长为 $0.02$ 的网格。在此网格的每个点 $(\\alpha, \\beta)$ 上评估目标函数 $\\rho(G)$。确定产生最小谱半径 $\\rho_c$ 的对 $(\\alpha_c, \\beta_c)$。\n\n    b.  **精细搜索**：在最佳粗网格点 $(\\alpha_c, \\beta_c)$ 周围的邻域内进行精细搜索。此阶段的搜索域定义为 $[\\max(0, \\alpha_c - 0.02), \\min(1, \\alpha_c + 0.02)] \\times [\\max(0, \\beta_c - 0.02), \\min(1, \\beta_c + 0.02)]$。使用步长为 $0.005$ 的更精细的网格。在这个新网格上评估目标函数，并更新搜索以找到最终的最优对 $(\\alpha^\\star, \\beta^\\star)$ 和相应的最小谱半径 $\\rho^\\star$。这种两阶段过程可以高效地定位最小值的良好近似，而无需在整个域上进行完整精细网格搜索的计算开销。\n\n对问题陈述中提供的四个测试案例中的每一个都重复此过程。收集每个案例的最终结果 $(\\alpha^\\star, \\beta^\\star, \\rho^\\star)$ 并按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'dt': 0.10, 'k': 1.00, 'vA': 1.00, 'D': 0.30, 'chi': 1.20, 'nu': 0.05, 'gamma': 0.40, 'gamma_c': 0.40, 'eta_b': 0.02},\n        # Case 2\n        {'dt': 0.01, 'k': 5.00, 'vA': 0.60, 'D': 8.00, 'chi': 6.00, 'nu': 0.20, 'gamma': 0.50, 'gamma_c': 0.50, 'eta_b': 0.10},\n        # Case 3\n        {'dt': 0.05, 'k': 2.00, 'vA': 3.00, 'D': 0.10, 'chi': 0.40, 'nu': 0.02, 'gamma': 0.20, 'gamma_c': 0.20, 'eta_b': 0.00},\n        # Case 4\n        {'dt': 0.30, 'k': 1.50, 'vA': 0.70, 'D': 2.00, 'chi': 2.00, 'nu': 0.10, 'gamma': 0.00, 'gamma_c': 0.00, 'eta_b': 0.00},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = find_optimal_imex_params(params)\n        # Round the final results to six decimal places\n        rounded_result = [round(x, 6) for x in result]\n        all_results.append(rounded_result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists is converted to the required format\n    # by removing spaces.\n    print(str(all_results).replace(\" \", \"\"))\n\ndef find_optimal_imex_params(params):\n    \"\"\"\n    Performs a two-stage grid search to find the optimal (alpha, beta) that\n    minimizes the spectral radius of the amplification operator G.\n    \"\"\"\n    dt = params['dt']\n    k = params['k']\n    vA = params['vA']\n    D = params['D']\n    chi = params['chi']\n    nu = params['nu']\n    gamma = params['gamma']\n    gamma_c = params['gamma_c']\n    eta_b = params['eta_b']\n    \n    # Pre-construct matrices A_exp and A_imp\n    A_exp = np.array([\n        [0, 1j * k * vA**2, 0],\n        [1j * k, 0, 0],\n        [0, 0, 0]\n    ], dtype=complex)\n\n    A_imp = np.array([\n        [-nu, 0, -1j * k * gamma],\n        [0, -eta_b, 0],\n        [1j * k * gamma_c, 0, -(D * k**2 + chi)]\n    ], dtype=complex)\n\n    I = np.identity(3, dtype=complex)\n\n    memo = {}\n    def get_spectral_radius(alpha, beta):\n        \"\"\"\n        Computes the spectral radius rho(G) for given alpha and beta.\n        Uses memoization to avoid re-computing for the same (alpha, beta).\n        \"\"\"\n        alpha = round(alpha, 12)\n        beta = round(beta, 12)\n        if (alpha, beta) in memo:\n            return memo[(alpha, beta)]\n\n        L_matrix = I - dt * (alpha * A_exp + beta * A_imp)\n        R_matrix = I + dt * ((1 - alpha) * A_exp + (1 - beta) * A_imp)\n\n        try:\n            # np.linalg.inv will raise LinAlgError for singular matrices\n            G = np.linalg.inv(L_matrix) @ R_matrix\n            eigenvalues = np.linalg.eigvals(G)\n            rho = np.max(np.abs(eigenvalues))\n        except np.linalg.LinAlgError:\n            rho = np.inf\n        \n        memo[(alpha, beta)] = rho\n        return rho\n\n    # Stage 1: Coarse Grid Search\n    coarse_step = 0.02\n    min_rho = np.inf\n    best_alpha_coarse, best_beta_coarse = -1, -1\n\n    alphas_coarse = np.arange(0, 1 + coarse_step / 2, coarse_step)\n    betas_coarse = np.arange(0, 1 + coarse_step / 2, coarse_step)\n\n    for alpha in alphas_coarse:\n        for beta in betas_coarse:\n            rho = get_spectral_radius(alpha, beta)\n            if rho  min_rho:\n                min_rho = rho\n                best_alpha_coarse = alpha\n                best_beta_coarse = beta\n    \n    # Stage 2: Fine Grid Search\n    fine_step = 0.005\n    best_alpha_fine = best_alpha_coarse\n    best_beta_fine = best_beta_coarse\n    \n    alpha_min_fine = np.clip(best_alpha_coarse - coarse_step, 0, 1)\n    alpha_max_fine = np.clip(best_alpha_coarse + coarse_step, 0, 1)\n    beta_min_fine = np.clip(best_beta_coarse - coarse_step, 0, 1)\n    beta_max_fine = np.clip(best_beta_coarse + coarse_step, 0, 1)\n\n    alphas_fine = np.arange(alpha_min_fine, alpha_max_fine + fine_step / 2, fine_step)\n    betas_fine = np.arange(beta_min_fine, beta_max_fine + fine_step / 2, fine_step)\n\n    for alpha in alphas_fine:\n        for beta in betas_fine:\n            # Ensure alpha, beta are within [0,1] due to potential floating point inaccuracies\n            alpha_clipped = np.clip(alpha, 0, 1)\n            beta_clipped = np.clip(beta, 0, 1)\n            rho = get_spectral_radius(alpha_clipped, beta_clipped)\n            if rho  min_rho:\n                min_rho = rho\n                best_alpha_fine = alpha_clipped\n                best_beta_fine = beta_clipped\n\n    return (best_alpha_fine, best_beta_fine, min_rho)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3525939"}]}