{"hands_on_practices": [{"introduction": "理论上的收敛阶 $p$ 是衡量数值积分器精度的核心指标，但在实际应用中，我们需要通过经验性测试来验证积分器是否达到了其理论性能。这个练习 [@problem_id:3534397] 将指导你使用步长加倍法，在一个具有解析解的简单物理模型（简谐振子）上，凭经验确定不同单步法的收敛阶。这不仅是验证代码正确性的基本步骤，也是深刻理解数值误差如何随步长变化的绝佳实践。", "problem": "您将设计并实现一个计算实验，通过步长减半法，为一个在计算天体物理学中已知的解析解，经验性地验证单步常微分方程（ODE）求解器的收敛阶。该物理模型是星系盘中径向小振荡的周转圆近似，可简化为受牛顿第二定律支配的一维简谐振子。其运动方程为\n$$\nm \\,\\frac{d^2 y}{dt^2} \\;=\\; -\\,k\\,y,\n$$\n其中 $m$ 是质量，$k$ 是等效劲度系数。通过 $k = m\\,\\omega^2$ 定义周转角频率 $\\omega$，该系统可以写成一阶形式，其状态向量为 $u(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$，即\n$$\n\\frac{d}{dt}\\begin{bmatrix} y \\\\ v \\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix} v \\\\ -\\,\\omega^2\\,y \\end{bmatrix}.\n$$\n对于初始条件 $y(0)=y_0$ 和 $v(0)=v_0$，其精确解为\n$$\ny(t) \\;=\\; y_0 \\cos(\\omega t) \\;+\\; \\frac{v_0}{\\omega}\\,\\sin(\\omega t),\\quad\nv(t) \\;=\\; -\\,y_0\\,\\omega\\,\\sin(\\omega t) \\;+\\; v_0 \\cos(\\omega t).\n$$\n\n您的任务是：\n- 针对上述系统，实现三种显式单步ODE求解器：前向欧拉法、显式中点法和经典四阶龙格-库塔法。\n- 对于每种方法，设计一个步长减半实验来估计观测到的全局收敛率 $p_{\\mathrm{obs}}$。设 $T$ 为最终时间，$N$ 为步长为 $h = T/N$ 时的步数，$2N$ 为步长为 $h/2$ 时的步数。如果 $E_h$ 表示用步长 $h$ 计算的在时间 $T$ 时的全局误差，$E_{h/2}$ 表示用步长 $h/2$ 计算的误差，则估计\n$$\np_{\\mathrm{obs}} \\;=\\; \\log_2\\!\\left(\\frac{E_h}{E_{h/2}}\\right).\n$$\n- 为避免位置和速度之间的单位不一致，将时间 $t$ 的误差定义为状态空间中的缩放欧几里得范数，\n$$\n\\|e(t)\\| \\;=\\; \\sqrt{\\;\\big(y_{\\mathrm{num}}(t) - y_{\\mathrm{exact}}(t)\\big)^2 \\;+\\; \\left(\\frac{v_{\\mathrm{num}}(t) - v_{\\mathrm{exact}}(t)}{\\omega}\\right)^2\\;}.\n$$\n使用此 $\\|e(T)\\|$ 作为 $E_h$ 和 $E_{h/2}$。\n\n角度单位必须是弧度，时间单位是秒，位置单位是米，速度单位是米/秒。观测到的收敛率 $p_{\\mathrm{obs}}$ 是无量纲的，应作为浮点数报告。\n\n实现您的程序以运行以下测试套件，并以指定的最终格式输出观测到的收敛率，每个案例一个。\n\n测试套件（每一项都是一个元组，指定了方法、角频率（弧度/秒）、最终时间（秒）、初始位置（米）、初始速度（米/秒）和粗略步数 $N$）：\n- 案例 1：$(\\text{Euler},\\, \\omega=1.0,\\, T=2\\pi,\\, y_0=1.0,\\, v_0=0.0,\\, N=200)$。\n- 案例 2：$(\\text{Midpoint},\\, \\omega=2.0,\\, T=\\pi,\\, y_0=1.0,\\, v_0=0.3,\\, N=240)$。\n- 案例 3：$(\\text{RK4},\\, \\omega=1.5,\\, T=\\tfrac{4\\pi}{1.5},\\, y_0=1.0,\\, v_0=0.0,\\, N=120)$。\n- 案例 4（用于前渐近行为的粗分辨率边界情况）：$(\\text{Euler},\\, \\omega=1.0,\\, T=2\\pi,\\, y_0=1.0,\\, v_0=0.0,\\, N=20)$。\n\n您的程序应：\n- 对于每个案例，使用 $N$ 步计算 $E_h$，使用 $2N$ 步计算 $E_{h/2}$，然后如上所述计算 $p_{\\mathrm{obs}}$。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[p_1, p_2, p_3, p_4]$。\n\n您的输出必须是四个浮点值 $[p_1, p_2, p_3, p_4]$ 的列表，按上述案例的顺序打印在单行上。不应打印任何附加文本。", "solution": "该问题要求对三种显式单步常微分方程（ODE）求解器——前向欧拉法、显式中点法和经典四阶龙格-库塔（RK4）法——的收敛阶进行经验性验证。测试模型是一个一维简谐振子，表示在周转圆近似下银盘中的径向小振荡。\n\n该物理系统由二阶ODE $m \\frac{d^2 y}{dt^2} = -k y$ 描述。通过定义角频率 $\\omega = \\sqrt{k/m}$，该方程可重写为 $\\frac{d^2 y}{dt^2} = -\\omega^2 y$。为了进行数值求解，我们将其转换为一个由两个一阶ODE组成的系统。设状态向量为 $u(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$，其中 $v(t) = \\frac{dy}{dt}$ 是速度。该系统则由下式给出：\n$$\n\\frac{du}{dt} = \\frac{d}{dt}\\begin{bmatrix} y \\\\ v \\end{bmatrix} = \\begin{bmatrix} v \\\\ -\\omega^2 y \\end{bmatrix} = f(u)\n$$\n这是一个形如 $\\frac{du}{dt} = f(u)$ 的自治系统，因为等式右侧不显式依赖于时间 $t$。我们将使用初始条件 $u(0) = u_0 = \\begin{bmatrix} y_0 \\\\ v_0 \\end{bmatrix}$ 来求解该系统。\n\n对于每种数值方法，我们生成一系列状态 $u_0, u_1, \\dots, u_N$，这些状态在离散时间点 $t_n = n h$ 逼近真实解，其中 $h = T/N$ 是步长，$N$ 是总步数，$T$ 是最终积分时间。\n\n三种求解器从 $u_n$ 到 $u_{n+1}$ 的单步实现如下：\n\n1.  **前向欧拉法：** 这是一种一阶方法（$p=1$）。其更新规则源自 $u(t_{n+1})$ 在 $t_n$ 附近的一阶泰勒展开：\n    $$\n    u_{n+1} = u_n + h f(u_n)\n    $$\n    对于我们特定的系统，这变为：\n    $$\n    \\begin{bmatrix} y_{n+1} \\\\ v_{n+1} \\end{bmatrix} = \\begin{bmatrix} y_n \\\\ v_n \\end{bmatrix} + h \\begin{bmatrix} v_n \\\\ -\\omega^2 y_n \\end{bmatrix} = \\begin{bmatrix} y_n + h v_n \\\\ v_n - h \\omega^2 y_n \\end{bmatrix}\n    $$\n\n2.  **显式中点法：** 这是一种二阶方法（$p=2$），一种两步龙格-库塔法。它首先使用步长为 $h/2$ 的前向欧拉步来估计区间中点 $t_n + h/2$ 处的状态，然后使用该中点处的斜率来完成从 $t_n$到 $t_{n+1}$ 的完整一步：\n    $$\n    k_1 = f(u_n)\n    $$\n    $$\n    k_2 = f(u_n + \\frac{h}{2} k_1)\n    $$\n    $$\n    u_{n+1} = u_n + h k_2\n    $$\n\n3.  **经典四阶龙格-库塔（RK4）法：** 这是一种四阶方法（$p=4$），也是一种广泛使用的四步显式龙格-库塔法。它使用区间 $[t_n, t_{n+1}]$ 内四个斜率估计的加权平均值：\n    $$\n    k_1 = f(u_n)\n    $$\n    $$\n    k_2 = f(u_n + \\frac{h}{2} k_1)\n    $$\n    $$\n    k_3 = f(u_n + \\frac{h}{2} k_2)\n    $$\n    $$\n    k_4 = f(u_n + h k_3)\n    $$\n    $$\n    u_{n+1} = u_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n    $$\n\n为了经验性地确定收敛阶 $p$，我们使用步长减半法。对于一个 $p$ 阶方法，在固定的最终时间 $T$ 处的全局误差 $E$ 预计与步长的 $p$ 次方成正比，即对于足够小的 $h$，$E \\approx C h^p$。我们计算数值解及其误差两次：一次使用粗步长 $h = T/N$ 得到误差 $E_h$，另一次使用细步长 $h/2 = T/(2N)$ 得到误差 $E_{h/2}$。这些误差的比值为：\n$$\n\\frac{E_h}{E_{h/2}} \\approx \\frac{C h^p}{C (h/2)^p} = 2^p\n$$\n解出 $p$，我们得到观测到的收敛阶：\n$$\np_{\\mathrm{obs}} = \\log_2\\left(\\frac{E_h}{E_{h/2}}\\right)\n$$\n最终时间 $T$ 的误差是通过将数值解 $u_{\\mathrm{num}}(T) = \\begin{bmatrix} y_{\\mathrm{num}}(T), v_{\\mathrm{num}}(T) \\end{bmatrix}^T$ 与精确解析解进行比较来计算的：\n$$\ny_{\\mathrm{exact}}(t) = y_0 \\cos(\\omega t) + \\frac{v_0}{\\omega}\\sin(\\omega t)\n$$\n$$\nv_{\\mathrm{exact}}(t) = -y_0\\,\\omega\\,\\sin(\\omega t) + v_0 \\cos(\\omega t)\n$$\n问题为误差向量 $e(T) = u_{\\mathrm{num}}(T) - u_{\\mathrm{exact}}(T)$ 指定了一个缩放的欧几里得范数：\n$$\nE = \\|e(T)\\| = \\sqrt{\\big(y_{\\mathrm{num}}(T) - y_{\\mathrm{exact}}(T)\\big)^2 + \\left(\\frac{v_{\\mathrm{num}}(T) - v_{\\mathrm{exact}}(T)}{\\omega}\\right)^2}\n$$\n这种缩放使得误差的两个分量（位置和速度）在量纲上保持一致，因为平方根内的两项都具有长度单位。\n\n每个测试案例的总体算法如下：\n1.  设置参数：方法、$\\omega$、$T$、$u_0$ 和粗略步数 $N$。\n2.  使用指定方法和 $N$ 步，从 $t=0$ 积分到 $t=T$，得到 $u_{\\mathrm{num}, h}(T)$。\n3.  使用相同方法和 $2N$ 步，从 $t=0$ 积分到 $t=T$，得到 $u_{\\mathrm{num}, h/2}(T)$。\n4.  计算精确解 $u_{\\mathrm{exact}}(T)$。\n5.  使用提供的误差范数计算误差 $E_h$ 和 $E_{h/2}$。\n6.  计算观测到的收敛率 $p_{\\mathrm{obs}} = \\log_2(E_h/E_{h/2})$。\n\n对问题描述中提供的所有四个测试案例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the observed convergence order for Euler, Midpoint, and RK4 methods\n    applied to the simple harmonic oscillator equation.\n    \"\"\"\n\n    # --- Define ODE system and its exact solution ---\n\n    def f_sho(t, u, omega_sq):\n        \"\"\"RHS of the simple harmonic oscillator ODE system: u' = f(t, u).\"\"\"\n        y, v = u\n        return np.array([v, -omega_sq * y])\n\n    def exact_solution(t, u0, omega):\n        \"\"\"Exact solution of the simple harmonic oscillator.\"\"\"\n        y0, v0 = u0\n        y_t = y0 * np.cos(omega * t) + (v0 / omega) * np.sin(omega * t)\n        v_t = -y0 * omega * np.sin(omega * t) + v0 * np.cos(omega * t)\n        return np.array([y_t, v_t])\n\n    # --- Define single-step ODE solvers ---\n\n    def euler_step(f, t, u, h, omega_sq):\n        \"\"\"Performs a single forward Euler step.\"\"\"\n        return u + h * f(t, u, omega_sq)\n\n    def midpoint_step(f, t, u, h, omega_sq):\n        \"\"\"Performs a single explicit midpoint method step.\"\"\"\n        k1 = f(t, u, omega_sq)\n        k2 = f(t + h / 2.0, u + (h / 2.0) * k1, omega_sq)\n        return u + h * k2\n\n    def rk4_step(f, t, u, h, omega_sq):\n        \"\"\"Performs a single classical 4th-order Runge-Kutta step.\"\"\"\n        k1 = f(t, u, omega_sq)\n        k2 = f(t + h / 2.0, u + (h / 2.0) * k1, omega_sq)\n        k3 = f(t + h / 2.0, u + (h / 2.0) * k2, omega_sq)\n        k4 = f(t + h, u + h * k3, omega_sq)\n        return u + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n    # --- Define the integration driver ---\n\n    def integrate(step_func, u0, omega, T, N):\n        \"\"\"Integrates the ODE from t=0 to T using N steps.\"\"\"\n        h = T / N\n        u = u0.copy()\n        omega_sq = omega**2\n        for i in range(N):\n            t = i * h\n            u = step_func(f_sho, t, u, h, omega_sq)\n        return u\n\n    # --- Define the error calculation function ---\n\n    def calculate_error(u_num, u_exact, omega):\n        \"\"\"Calculates the error using the specified scaled norm.\"\"\"\n        err_y = u_num[0] - u_exact[0]\n        err_v = u_num[1] - u_exact[1]\n        norm_sq = err_y**2 + (err_v / omega)**2\n        return np.sqrt(norm_sq)\n\n    # --- Test suite definition ---\n\n    test_cases = [\n        # (Method Name, omega, T, y0, v0, N_coarse)\n        ('Euler', 1.0, 2.0 * np.pi, 1.0, 0.0, 200),\n        ('Midpoint', 2.0, np.pi, 1.0, 0.3, 240),\n        ('RK4', 1.5, 4.0 * np.pi / 1.5, 1.0, 0.0, 120),\n        ('Euler', 1.0, 2.0 * np.pi, 1.0, 0.0, 20),\n    ]\n\n    solver_map = {\n        'Euler': euler_step,\n        'Midpoint': midpoint_step,\n        'RK4': rk4_step,\n    }\n\n    results = []\n    for case in test_cases:\n        method_name, omega, T, y0, v0, N_coarse = case\n\n        u0 = np.array([y0, v0])\n        step_func = solver_map[method_name]\n\n        # Integrate with coarse step size h = T / N_coarse\n        u_num_h = integrate(step_func, u0, omega, T, N_coarse)\n\n        # Integrate with fine step size h/2 = T / (2*N_coarse)\n        u_num_h2 = integrate(step_func, u0, omega, T, 2 * N_coarse)\n\n        # Calculate exact solution at T\n        u_exact_T = exact_solution(T, u0, omega)\n\n        # Calculate errors for both resolutions\n        E_h = calculate_error(u_num_h, u_exact_T, omega)\n        E_h2 = calculate_error(u_num_h2, u_exact_T, omega)\n\n        # Estimate the observed convergence order\n        # Handle the case where E_h2 is zero to avoid division by zero\n        if E_h2 == 0.0:\n            p_obs = np.inf if E_h > 0.0 else 0.0\n        else:\n            p_obs = np.log2(E_h / E_h2)\n        \n        results.append(p_obs)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3534397"}, {"introduction": "在天体物理学模拟中，仅仅追求数值精度是不够的；积分器还必须尊重系统的基本物理定律，特别是守恒量。这个练习 [@problem_id:3534434] 转向经典的开普勒问题，比较不同阶数的显式积分器（如欧拉法、中点法和RK4）在保持角动量守恒方面的表现。通过这个实践，你将直观地看到高阶方法如何以更高的计算成本换取更优的物理保真度，这是在选择积分器时必须做出的关键权衡。", "problem": "考虑一个单位点质量在牛顿引力作用下绕一个固定的中心质量运动的平面二体（开普勒）问题。使用无量纲单位，其中引力常数乘以中心质量为 $G M = 1$。状态是满足以下一阶常微分方程（ODE）组的对偶 $\\left(\\mathbf{r}(t), \\mathbf{v}(t)\\right) \\in \\mathbb{R}^2 \\times \\mathbb{R}^2$\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\qquad \\frac{d\\mathbf{v}}{dt} = - \\frac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^3}.\n$$\n关于平面外轴的比角动量（单位质量的角动量）为\n$$\n\\ell(t) = \\left(\\mathbf{r}(t) \\times \\mathbf{v}(t)\\right)_z = x(t)\\,v_y(t) - y(t)\\,v_x(t).\n$$\n根据牛顿第二定律和引力的中心力性质，力矩为零，因此在连续动力学中 $\\ell(t)$ 是精确守恒的。在有限精度计算和使用离散时间单步 ODE 积分器时，$\\ell(t)$ 可能会发生漂移。\n\n您的任务是构建一个数值实验，比较在使用三种单步方法以相同的固定步长 $h$ 对开普勒椭圆进行积分时 $\\ell(t)$ 的漂移情况。这三种方法分别是：显式欧拉法、显式中点法（二阶 Runge-Kutta 方法）和经典四阶 Runge-Kutta 方法（简写为 4 阶 Runge-Kutta，或 RK4）。该实验必须实现为一个完整、可运行的程序。\n\n使用以下设置作为初始条件。将半长轴固定为 $a = 1$，并将粒子置于 x 轴上的近心点，\n$$\n\\mathbf{r}(0) = \\big(a(1-e),\\, 0\\big),\n$$\n初始速度与轨道相切，指向 y 轴正方向，\n$$\n\\mathbf{v}(0) = \\left(0,\\, \\sqrt{\\frac{1+e}{a(1-e)}}\\right).\n$$\n在所选的无量纲单位中，$G M = 1$ 且 $a = 1$ 时，轨道周期为 $T = 2\\pi$。对于给定的轨道圈数 $K \\in \\mathbb{N}$ 和固定步长 $h > 0$，积分 $N = \\left\\lfloor \\frac{K T}{h} \\right\\rfloor$ 步（不要为了精确达到 $K T$ 而走部分步长；精确使用 $N$ 个大小为 $h$ 的步长）。对于每个积分器，记录积分过程中的最大相对角动量漂移，\n$$\n\\varepsilon_{\\max} \\equiv \\max_{0 \\leq n \\leq N} \\frac{\\left|\\ell_n - \\ell_0\\right|}{\\left|\\ell_0\\right|},\n$$\n其中 $\\ell_n$ 是经过 $n$ 步后从数值状态计算出的离散角动量，而 $\\ell_0$ 是从初始状态计算得出的。\n\n将这三种积分器实现为一阶系统 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$ 的单步方法，其中 $\\mathbf{y} = \\left(x, y, v_x, v_y\\right)$ 且 $\\mathbf{f}(\\mathbf{y}) = \\left(v_x, v_y, -x/r^3, -y/r^3\\right)$，其中 $r = \\sqrt{x^2 + y^2}$。在每个测试用例中，对所有三种积分器使用相同的固定步长 $h$。\n\n所有量均为无量纲；不需要物理单位。所有角度（如适用）均以弧度为单位。\n\n测试套件。对以下四个测试用例运行实验，每个用例由偏心率 $e$、步长 $h$ 和轨道圈数 $K$ 指定：\n\n- 情况 1：$e = 0$，$h = 0.01$，$K = 1$。\n- 情况 2：$e = 0.6$，$h = 0.01$，$K = 1$。\n- 情况 3：$e = 0.6$，$h = 0.03$，$K = 5$。\n- 情况 4：$e = 0.9$，$h = 0.005$，$K = 1$。\n\n对于每种情况，计算并返回一个包含三个浮点数的列表 $[\\varepsilon_{\\max}^{\\text{Euler}}, \\varepsilon_{\\max}^{\\text{Midpoint}}, \\varepsilon_{\\max}^{\\text{RK4}}]$。\n\n最终输出格式。您的程序应生成单行输出，其中包含所有四个用例的结果，形式为由四个用例列表组成的逗号分隔列表，并用方括号括起来，顺序与上述情况相同。也就是说，打印的字符串必须具有以下形式：\n$[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]]$\n其中每个 $a_j$、$b_j$、$c_j$ 都是一个浮点数。不应打印任何额外的文本或行。", "solution": "用户提供的问题已经过验证，被确定为一个适定、有科学依据且完整的任务。其目标是研究在使用三种不同的单步常微分方程（ODE）求解器对开普勒问题进行积分时，比角动量的数值守恒情况。\n\n该问题由一个点质量在二维中心引力场中的运动方程定义。在引力参数 $G M = 1$ 的无量纲单位中，系统的状态由位置矢量 $\\mathbf{r}(t) = (x(t), y(t))$ 和速度矢量 $\\mathbf{v}(t) = (v_x(t), v_y(t))$ 给出。其动力学由以下一阶 ODE 系统控制：\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\qquad \\frac{d\\mathbf{v}}{dt} = - \\frac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^3}\n$$\n为便于数值积分，我们将状态表示为 $\\mathbb{R}^4$ 中的单个向量，$\\mathbf{y}(t) = (x(t), y(t), v_x(t), v_y(t))^T$。该 ODE 系统可以写成紧凑形式 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$，其中函数 $\\mathbf{f}: \\mathbb{R}^4 \\to \\mathbb{R}^4$ 定义如下：\n$$\n\\mathbf{f}(\\mathbf{y}) = \\begin{pmatrix} v_x \\\\ v_y \\\\ -x / (\\sqrt{x^2+y^2})^3 \\\\ -y / (\\sqrt{x^2+y^2})^3 \\end{pmatrix}\n$$\n比角动量 $\\ell(t)$ 是一个标量，由位置和速度叉积的平面外分量定义：\n$$\n\\ell(t) = (\\mathbf{r}(t) \\times \\mathbf{v}(t))_z = x(t)\\,v_y(t) - y(t)\\,v_x(t)\n$$\n在精确解析解中，引力的中心力性质保证了力矩为零，因此 $\\ell(t)$ 是一个守恒量。然而，数值积分方法会引入离散化误差，可能导致该值随时间漂移。\n\n该数值实验针对半长轴 $a=1$ 的椭圆轨道进行设置。初始位置在 x 轴正半轴上的近心点，$\\mathbf{r}(0) = (1-e, 0)$，其中 $e$ 是偏心率。初始速度与位置矢量垂直，$\\mathbf{v}(0) = \\left(0, \\sqrt{\\frac{1+e}{1-e}}\\right)$。因此，初始比角动量 $\\ell_0$ 为：\n$$\n\\ell_0 = x(0) v_y(0) - y(0) v_x(0) = (1-e) \\sqrt{\\frac{1+e}{1-e}} - 0 = \\sqrt{(1-e)(1+e)} = \\sqrt{1-e^2}\n$$\n由于所提供的测试用例使用 $e  1$，$\\ell_0$ 是非零的。对于 $a=1$ 和 $GM=1$，轨道周期为 $T=2\\pi$。使用固定步长 $h$，在 $K$ 个轨道上进行积分，总步数为 $N = \\lfloor 2\\pi K / h \\rfloor$。\n\n我们将比较三种显式单步方法。设 $\\mathbf{y}_n$ 是在时间 $t_n = n h$ 时对 $\\mathbf{y}(t_n)$ 的数值近似。下一个状态 $\\mathbf{y}_{n+1}$ 计算如下：\n\n1.  **显式欧拉法（一阶）**：该方法通过在区间开始处沿切线方向迈出单步来近似求解。\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\mathbf{f}(\\mathbf{y}_n)\n    $$\n\n2.  **显式中点法（二阶 Runge-Kutta，RK2）**：该方法通过使用在区间中点处评估的斜率来提高精度。\n    $$\n    \\begin{aligned}\n    \\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) \\\\\n    \\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1\\right) \\\\\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\mathbf{k}_2\n    \\end{aligned}\n    $$\n\n3.  **经典 Runge-Kutta 方法（四阶，RK4）**：这是一种广泛使用的方法，通过使用区间内四个斜率估计的加权平均来获得更高的精度。\n    $$\n    \\begin{aligned}\n    \\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) \\\\\n    \\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1\\right) \\\\\n    \\mathbf{k}_3 = \\mathbf{f}\\left(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_2\\right) \\\\\n    \\mathbf{k}_4 = \\mathbf{f}\\left(\\mathbf{y}_n + h \\mathbf{k}_3\\right) \\\\\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n    \\end{aligned}\n    $$\n\n对于每个积分器和每个测试用例，积分都将执行 $N$ 步。在每一步 $n$，从状态 $\\mathbf{y}_n$ 计算数值角动量 $\\ell_n$。性能指标是整个积分过程中角动量的最大相对漂移：\n$$\n\\varepsilon_{\\max} = \\max_{0 \\leq n \\leq N} \\frac{\\left|\\ell_n - \\ell_0\\right|}{\\left|\\ell_0\\right|}\n$$\n最终输出将包括针对四个指定测试用例，每种积分器计算出的 $\\varepsilon_{\\max}$ 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Kepler problem for specified test cases, comparing the numerical drift\n    in angular momentum for Euler, Midpoint (RK2), and classical RK4 methods.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (eccentricity, step_size, num_orbits)\n    test_cases = [\n        (0.0, 0.01, 1),\n        (0.6, 0.01, 1),\n        (0.6, 0.03, 5),\n        (0.9, 0.005, 1),\n    ]\n\n    # Nondimensional gravitational parameter and semi-major axis.\n    GM = 1.0\n    a = 1.0\n\n    def f_ode(y):\n        \"\"\"\n        The derivative function dy/dt = f(y) for the Kepler problem.\n        y is the state vector [x, y_pos, v_x, v_y].\n        \"\"\"\n        x, y_pos, v_x, v_y = y\n        # The position vector magnitude r = ||r||.\n        r_norm = np.sqrt(x**2 + y_pos**2)\n        # Avoid division by zero, though not expected for these elliptical orbits.\n        if r_norm == 0:\n            return np.zeros(4)\n        \n        r_norm_cubed = r_norm**3\n        \n        # Acceleration components a = -GM * r / ||r||^3. With GM=1.\n        a_x = -x / r_norm_cubed\n        a_y = -y_pos / r_norm_cubed\n        \n        return np.array([v_x, v_y, a_x, a_y])\n\n    def euler_step(f, y, h):\n        \"\"\"Performs a single step using the explicit Euler method.\"\"\"\n        return y + h * f(y)\n\n    def midpoint_step(f, y, h):\n        \"\"\"Performs a single step using the explicit Midpoint (RK2) method.\"\"\"\n        k1 = f(y)\n        k2 = f(y + 0.5 * h * k1)\n        return y + h * k2\n\n    def rk4_step(f, y, h):\n        \"\"\"Performs a single step using the classical RK4 method.\"\"\"\n        k1 = f(y)\n        k2 = f(y + 0.5 * h * k1)\n        k3 = f(y + 0.5 * h * k2)\n        k4 = f(y + h * k3)\n        return y + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n    def get_angular_momentum(y):\n        \"\"\"Computes the specific angular momentum from the state vector.\"\"\"\n        x, y_pos, v_x, v_y = y\n        return x * v_y - y_pos * v_x\n\n    all_results = []\n\n    for e, h, K in test_cases:\n        # Orbital period for a=1, GM=1 is T = 2*pi.\n        T = 2.0 * np.pi\n        total_time = K * T\n        num_steps = int(np.floor(total_time / h))\n\n        # Initial conditions at pericenter.\n        r0 = np.array([a * (1.0 - e), 0.0])\n        v0 = np.array([0.0, np.sqrt(GM * (1.0 + e) / (a * (1.0 - e)))]) # Corrected to include GM\n        y0 = np.array([r0[0], r0[1], v0[0], v0[1]])\n\n        l0 = get_angular_momentum(y0)\n        \n        # Need to handle the case l0=0, though not expected here as e  1.\n        l0_abs = np.abs(l0)\n        if l0_abs == 0.0:\n            # For a radial trajectory, drift is ill-defined. This won't happen for test cases.\n            # We would skip or return NaN, but for this problem it's safe.\n            l0_abs = 1.0 # Placeholder to prevent division by zero in an edge case.\n\n        integrators = [\n            (\"Euler\", euler_step),\n            (\"Midpoint\", midpoint_step),\n            (\"RK4\", rk4_step),\n        ]\n        \n        case_results = []\n        for name, step_func in integrators:\n            y = np.copy(y0)\n            max_rel_drift = 0.0\n\n            for _ in range(num_steps):\n                y = step_func(f_ode, y, h)\n                l_n = get_angular_momentum(y)\n                rel_drift = np.abs(l_n - l0) / l0_abs\n                if rel_drift > max_rel_drift:\n                    max_rel_drift = rel_drift\n            \n            case_results.append(max_rel_drift)\n        \n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # [[a1,b1,c1],[a2,b2,c2],[a3,b3,c3],[a4,b4,c4]]\n    # This construction ensures there are no spaces within the sub-lists.\n    sublist_strs = [f\"[{','.join(map(str, sub))}]\" for sub in all_results]\n    print(f\"[{','.join(sublist_strs)}]\")\n\nsolve()\n```", "id": "3534434"}, {"introduction": "对于长期轨道动力学模拟，标准的显式积分器往往会引入能量的长期漂移（secular drift），这限制了它们的适用性。本练习 [@problem_id:3534425] 引导我们探索一种更高级的积分方案：通过组合前向和后向欧拉半步，构造一个时间对称的二阶方法。通过在开普勒问题中比较这种方法与显式方法的长期能量行为，我们将揭示积分器的结构特性（如时间对称性）如何成为实现长期稳定性和准确性的关键，为理解更高级的辛积分器打下基础。", "problem": "您将研究在使用三种单步常微分方程求解器对开普勒引力势下的平面二体问题进行积分时，数值轨道能量的长期行为。这三种求解器分别是：由半步前向欧拉和半步后向欧拉构成的时间对称组合方法、显式中点法，以及经典四阶龙格-库塔法。从第一性原理出发：牛顿第二定律和牛顿引力定律。具体来说，考虑一个点质量围绕一个固定的中心质量运动，其引力参数为 $\\mu$，动力学由以下方程组决定\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = -\\mu \\frac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^3},\n$$\n其中 $\\mathbf{r} = (x,y)$ 且 $\\mathbf{v} = (v_x,v_y)$。使用无量纲单位，令 $\\mu = 1$，从而所有量均为无量纲。总比轨道能量为\n$$\nE = \\frac{1}{2} \\left( v_x^2 + v_y^2 \\right) - \\frac{\\mu}{\\lVert \\mathbf{r} \\rVert}.\n$$\n\n您的任务：\n- 通过对称方式组合半步前向欧拉和半步后向欧拉，仅基于核心定义，推导出一个时间对称的二阶方法。将其实现为一个单步映射，将时间 $t_n$ 的状态映至时间 $t_{n+1} = t_n + h$。前向欧拉是基于在当前状态下评估方程右侧的显式更新，而后向欧拉是基于在新状态下评估方程右侧的隐式更新。组合方法应使用一个半步前向欧拉后跟一个半步后向欧拉，或反之，以实现时间对称性。任何隐式子步骤都必须求解到一致的数值容差。\n- 将显式中点法实现为一种单步二阶龙格-库塔方法。\n- 将经典四阶龙格-库塔方法实现为一种参考用的高阶显式方法。\n\n从牛顿定律和能量定义出发，推导常微分方程（ODE）系统的形式以及应用每种单步方法所需的表达式。对于任何隐式求解，使用牛顿迭代法，并采用对方程右侧关于状态的解析推导的雅可比矩阵。雅可比矩阵应从引力加速度对位置的依赖关系中推导得出；所有偏导数必须用 $\\mathbf{r}$、$\\lVert \\mathbf{r} \\rVert$ 和 $\\mu$ 表示。当更新量的无穷范数小于指定容差或达到最大迭代次数时，牛顿迭代应终止。使用 $10^{-12}$ 的容差和最多 $20$ 次迭代。使用双精度算术。\n\n初始条件对应于给定的半长轴 $a$ 和偏心率 $e$ 的束缚开普勒轨道，并在近拱点处初始化。在近拱点处使用活力公式设置速度：\n$$\nr_p = a (1 - e), \\quad v_p = \\sqrt{\\mu \\left(\\frac{2}{r_p} - \\frac{1}{a}\\right)} = \\sqrt{\\mu \\frac{1+e}{a(1-e)} }.\n$$\n将初始状态设置为 $\\mathbf{r}(0) = (r_p, 0)$ 和 $\\mathbf{v}(0) = (0, v_p)$。对于 $\\mu=1$，轨道周期为\n$$\nT = 2 \\pi a^{3/2}.\n$$\n\n对于下面的每个测试用例，使用固定步长 $\\Delta t = T/N_{\\text{per}}$ 对指定的轨道周期数进行积分，其中 $N_{\\text{per}}$ 是每个轨道周期的时间步数。对于每种方法，记录整个积分区间内的最大相对能量误差：\n$$\n\\max_{0 \\le n \\le N} \\frac{\\left| E_n - E_0 \\right|}{\\left|E_0\\right|},\n$$\n其中 $N$ 是总时间步数，$E_n$ 是在第 $n$ 步计算的能量。因为单位是无量纲的且 $\\mu=1$，所以无需报告物理单位。\n\n测试套件：\n- 用例 $1$（中等偏心率，中等分辨率，长持续时间）：$a=1$，$e=0.1$，积分 $200$ 个轨道周期，每个周期 $N_{\\text{per}} = 100$ 步。\n- 用例 $2$（高偏心率，较高分辨率，中等持续时间）：$a=1$，$e=0.6$，积分 $100$ 个轨道周期，每个周期 $N_{\\text{per}} = 200$ 步。\n- 用例 $3$（圆形轨道，粗糙分辨率，短持续时间）：$a=1$，$e=0.0$，积分 $50$ 个轨道周期，每个周期 $N_{\\text{per}} = 20$ 步。\n\n对于每个用例，计算三个浮点数，分别对应以下方法的最大相对能量误差：\n$1$) 时间对称欧拉组合方法，$2$) 显式中点法，以及 $3$) 经典龙格-库塔 $4$ 阶方法。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序固定为\n$$\n[\\text{case1\\_symEuler}, \\text{case1\\_midpoint}, \\text{case1\\_RK4}, \\text{case2\\_symEuler}, \\text{case2\\_midpoint}, \\text{case2\\_RK4}, \\text{case3\\_symEuler}, \\text{case3\\_midpoint}, \\text{case3\\_RK4}],\n$$\n其中每个条目都是一个浮点数。不应打印任何额外文本。答案要求无角度动力学和无量纲单位，因此不需要角度单位，输出也不需要附加物理单位。数值结果必须由您的代码直接计算；不要硬编码任何预期值。", "solution": "用户希望分析平面二体问题的数值积分。该问题在科学上和数学上都是合理的、适定的，并且为数值实验提供了所有必要的参数和条件。因此，我们可以着手解决。\n\n### 1. 系统构建\n该问题描述了一个点质量在牛顿引力作用下，围绕一个固定的中心质量在平面内运动。其动力学由一个二阶常微分方程（ODE）系统控制。为了应用单步ODE求解器，我们首先将该系统转换为一阶形式。\n\n设系统状态由一个四维向量 $\\mathbf{y}(t)$ 描述，该向量包含位置 $\\mathbf{r}=(x,y)$ 和速度 $\\mathbf{v}=(v_x,v_y)$：\n$$\n\\mathbf{y}(t) = \\begin{bmatrix} x(t) \\\\ y(t) \\\\ v_x(t) \\\\ v_y(t) \\end{bmatrix}\n$$\n给定的控制方程为：\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = -\\mu \\frac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^3}\n$$\n其中 $\\mu$ 是引力参数，设为 $\\mu=1$。该系统可以写成一个单一的一阶ODE，$\\frac{d\\mathbf{y}}{dt} = f(\\mathbf{y})$，其中函数 $f: \\mathbb{R}^4 \\to \\mathbb{R}^4$ 定义为：\n$$\nf(\\mathbf{y}) = f(x, y, v_x, v_y) = \\begin{bmatrix} v_x \\\\ v_y \\\\ -\\mu x / (x^2+y^2)^{3/2} \\\\ -\\mu y / (x^2+y^2)^{3/2} \\end{bmatrix}\n$$\n问题在于使用固定的时间步长 $h = \\Delta t$，从初始状态 $\\mathbf{y}_0$ 开始，在指定的时间段内对该系统进行数值积分。数值积分器是一个映射 $\\mathbf{y}_{n+1} = \\Phi_h(\\mathbf{y}_n)$，它近似于时间 $t_{n+1} = t_n + h$ 时的真实解。\n\n比轨道能量是该精确系统的一个守恒量，由下式给出：\n$$\nE(\\mathbf{y}) = \\frac{1}{2} (v_x^2 + v_y^2) - \\frac{\\mu}{\\sqrt{x^2+y^2}}\n$$\n我们将监控该量的误差，以评估数值积分器的质量。\n\n### 2. 数值积分器的推导\n\n我们将实现三种不同的单步方法。\n\n#### 2.1. 时间对称欧拉组合法\n该方法被指定为前向欧拉（EF）和后向欧拉（EB）方法的对称组合，每步都使用半步长 $h/2$。\n从 $\\mathbf{y}_A$ 到 $\\mathbf{y}_B$、步长为 $\\Delta t$ 的EF步长为 $\\mathbf{y}_B = \\mathbf{y}_A + \\Delta t f(\\mathbf{y}_A)$。\n从 $\\mathbf{y}_A$ 到 $\\mathbf{y}_B$、步长为 $\\Delta t$ 的EB步长为 $\\mathbf{y}_B = \\mathbf{y}_A + \\Delta t f(\\mathbf{y}_B)$。\n\n一个对称组合涉及先应用一个算子，然后再应用另一个算子。让我们考虑应用一个半步长的EF，然后应用一个半步长的EB。\n设 $\\mathbf{y}_n$ 是时间 $t_n$ 的状态。\n首先，使用步长为 $h/2$ 的EF计算中间状态 $\\mathbf{y}^*$：\n$$\n\\mathbf{y}^* = \\mathbf{y}_n + \\frac{h}{2} f(\\mathbf{y}_n)\n$$\n然后，从 $\\mathbf{y}^*$ 使用步长为 $h/2$ 的EB计算最终状态 $\\mathbf{y}_{n+1}$：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}^* + \\frac{h}{2} f(\\mathbf{y}_{n+1})\n$$\n将 $\\mathbf{y}^*$ 的表达式代入第二个方程，得到 $\\mathbf{y}_{n+1}$ 的单步映射：\n$$\n\\mathbf{y}_{n+1} = \\left(\\mathbf{y}_n + \\frac{h}{2} f(\\mathbf{y}_n)\\right) + \\frac{h}{2} f(\\mathbf{y}_{n+1})\n$$\n这可以重新排列为 $\\mathbf{y}_{n+1} - \\frac{h}{2} f(\\mathbf{y}_{n+1}) = \\mathbf{y}_n + \\frac{h}{2} f(\\mathbf{y}_n)$。该方法被认为是隐式梯形法则（或用于偏微分方程的Crank-Nicolson方法）。它是一个二阶、A稳定且时间对称（自伴）的方法。该方法是隐式的，因为 $\\mathbf{y}_{n+1}$ 出现在方程两边。要实现它，我们必须在每个时间步求解一个非线性方程组。\n\n#### 2.2. 显式中点法\n这是一种二阶、显式的龙格-库塔方法。它包括两个阶段：\n1. 使用大小为 $h/2$ 的欧拉步，计算区间中点的初步状态：\n   $$\n   \\mathbf{k}_1 = f(\\mathbf{y}_n) \\quad (\\text{起始点斜率})\n   $$\n   $$\n   \\mathbf{y}_{\\text{mid}} = \\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1\n   $$\n2. 使用该中点状态的斜率，从 $\\mathbf{y}_n$ 走一个完整的步长：\n   $$\n   \\mathbf{k}_2 = f(\\mathbf{y}_{\\text{mid}}) \\quad (\\text{中点斜率})\n   $$\n   $$\n   \\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\mathbf{k}_2\n   $$\n该方法是显式的，因为每个阶段都可以直接从前一个阶段的结果计算出来。\n\n#### 2.3. 经典四阶龙格-库塔（RK4）方法\n经典RK4方法是一种广泛使用的四阶显式方法。它通过使用时间步内四个斜率评估的加权平均来获得更高的精度：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = f(\\mathbf{y}_n) \\\\\n\\mathbf{k}_2 = f\\left(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1\\right) \\\\\n\\mathbf{k}_3 = f\\left(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_2\\right) \\\\\n\\mathbf{k}_4 = f\\left(\\mathbf{y}_n + h \\mathbf{k}_3\\right) \\\\\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{aligned}\n$$\n作为一种显式方法，它不需要求解方程。其卓越的局部精度通常在中等积分时间内表现出更好的性能。\n\n### 3. 用于隐式求解器的牛顿法\n为了实现时间对称欧拉方法，我们必须求解关于 $\\mathbf{y}_{n+1}$ 的隐式方程。令 $X = \\mathbf{y}_{n+1}$。要求解的方程是一个寻根问题：\n$$\nG(X) = X - \\mathbf{y}_n - \\frac{h}{2} f(\\mathbf{y}_n) - \\frac{h}{2} f(X) = 0\n$$\n我们使用牛顿法，它生成一个收敛于根的近似序列 $X_k$。从一个初始猜测 $X_0$ 开始，迭代过程为：\n$$\nX_{k+1} = X_k - [G'(X_k)]^{-1} G(X_k)\n$$\n其中 $G'(X_k)$ 是 $G$ 相对于 $X$ 的雅可比矩阵，在 $X_k$ 处求值。\n$G(X)$ 的雅可比矩阵为：\n$$\nG'(X) = \\frac{\\partial}{\\partial X} \\left( X - \\mathbf{y}_n - \\frac{h}{2} f(\\mathbf{y}_n) - \\frac{h}{2} f(X) \\right) = I - \\frac{h}{2} J_f(X)\n$$\n其中 $I$ 是 $4 \\times 4$ 的单位矩阵，$J_f(X) = f'(X)$ 是ODE右侧函数 $f$ 的雅可比矩阵。\n\n牛顿更新步骤涉及求解线性系统：\n$$\n\\left(I - \\frac{h}{2} J_f(X_k)\\right) \\Delta X_k = -G(X_k)\n$$\n以求得修正量 $\\Delta X_k = X_{k+1} - X_k$。迭代继续进行，直到 $\\|\\Delta X_k\\|_\\infty  10^{-12}$ 或达到最多 $20$ 次迭代。一个好的初始猜测 $X_0$ 是显式欧拉步骤的结果：$X_0 = \\mathbf{y}_n + hf(\\mathbf{y}_n)$。\n\n#### ODE函数 $f(\\mathbf{y})$ 的雅可比矩阵\n状态向量是 $\\mathbf{y} = [x, y, v_x, v_y]^T$。函数是 $f(\\mathbf{y}) = [v_x, v_y, a_x(\\mathbf{r}), a_y(\\mathbf{r})]^T$，其中 $\\mathbf{a} = -\\mu \\mathbf{r} / r^3$ 且 $r = \\sqrt{x^2+y^2}$。\n雅可比矩阵 $J_f = \\frac{\\partial f}{\\partial \\mathbf{y}}$ 具有块结构：\n$$\nJ_f = \\begin{pmatrix} \\mathbf{0}_{2\\times2}  I_{2\\times2} \\\\ J_{\\mathbf{a},\\mathbf{r}}  \\mathbf{0}_{2\\times2} \\end{pmatrix}\n$$\n这里，$\\mathbf{0}_{2\\times2}$ 和 $I_{2\\times2}$ 分别是 $2 \\times 2$ 的零矩阵和单位矩阵。非平凡块是 $J_{\\mathbf{a},\\mathbf{r}} = \\frac{\\partial \\mathbf{a}}{\\partial \\mathbf{r}}$。它的分量使用链式法则和乘积法则推导得出：\n偏导数的通用公式是 $\\frac{\\partial a_i}{\\partial r_j} = \\frac{\\mu}{r^5} (3 r_i r_j - \\delta_{ij} r^2)$，其中 $i,j \\in \\{x,y\\}$。\n这产生了如下块矩阵：\n$$\nJ_{\\mathbf{a},\\mathbf{r}} = \\frac{\\partial(a_x, a_y)}{\\partial(x, y)} = \\frac{\\mu}{r^5} \\begin{pmatrix} 3x^2 - r^2  3xy \\\\ 3xy  3y^2 - r^2 \\end{pmatrix} = \\frac{\\mu}{r^5} \\begin{pmatrix} 2x^2 - y^2  3xy \\\\ 3xy  2y^2 - x^2 \\end{pmatrix}\n$$\n这个 $4 \\times 4$ 的雅可比矩阵 $J_f$ 用于在每次牛顿迭代中构建线性系统。\n\n### 4. 数值实验设置\n对于每个测试用例，模拟设置如下：\n1.  **初始条件**：轨道在近拱点处初始化。给定半长轴 $a$ 和偏心率 $e$，近拱点距离为 $r_p = a(1-e)$，速度为 $v_p = \\sqrt{\\mu(2/r_p - 1/a)}$。初始状态向量为 $\\mathbf{y}_0 = [r_p, 0, 0, v_p]^T$。对于 $\\mu=1$，轨道周期为 $T = 2\\pi a^{3/2}$。\n2.  **积分参数**：积分为指定的轨道周期数。固定的时间步长为 $\\Delta t = h = T/N_{\\text{per}}$，其中 $N_{\\text{per}}$ 是每个周期的步数。\n3.  **误差度量**：计算初始能量 $E_0 = E(\\mathbf{y}_0)$。对于每一步 $n$，计算能量 $E_n = E(\\mathbf{y}_n)$，并求出相对误差。性能度量是整个积分过程中的最大相对能量误差：\n    $$\n    \\text{Error} = \\max_{n} \\frac{|E_n - E_0|}{|E_0|}\n    $$\n对三个积分器中的每一个和问题陈述中指定的三个测试用例中的每一个重复此过程。然后收集结果并按要求格式化。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-body problem using three different numerical integrators\n    and computes the maximum relative energy error for each.\n    \"\"\"\n    \n    # --- Problem Constants and Numerical Parameters ---\n    MU = 1.0\n    NEWTON_TOL = 1e-12\n    NEWTON_MAX_ITER = 20\n\n    # --- Core Physics and ODE Functions ---\n    \n    def compute_energy(y):\n        \"\"\"Computes the specific orbital energy.\"\"\"\n        x, y_pos, vx, vy = y\n        r_norm = np.sqrt(x**2 + y_pos**2)\n        v_norm_sq = vx**2 + vy**2\n        return 0.5 * v_norm_sq - MU / r_norm\n\n    def f_ode(y):\n        \"\"\"Computes the right-hand side of the ODE dy/dt = f(y).\"\"\"\n        x, y_pos, vx, vy = y\n        r_norm_cubed = (x**2 + y_pos**2)**1.5\n        ax = -MU * x / r_norm_cubed\n        ay = -MU * y_pos / r_norm_cubed\n        return np.array([vx, vy, ax, ay], dtype=np.float64)\n\n    def compute_jacobian(y):\n        \"\"\"Computes the Jacobian of f_ode(y).\"\"\"\n        x, y_pos, _, _ = y\n        r_sq = x**2 + y_pos**2\n        r_norm5 = r_sq**2.5\n        \n        # J_ar block: partial derivatives of acceleration w.r.t. position\n        dax_dx = MU * (2 * x**2 - y_pos**2) / r_norm5\n        dax_dy = MU * (3 * x * y_pos) / r_norm5\n        day_dx = dax_dy\n        day_dy = MU * (2 * y_pos**2 - x**2) / r_norm5\n        \n        J = np.array([\n            [0.0, 0.0, 1.0, 0.0],\n            [0.0, 0.0, 0.0, 1.0],\n            [dax_dx, dax_dy, 0.0, 0.0],\n            [day_dx, day_dy, 0.0, 0.0]\n        ], dtype=np.float64)\n        return J\n\n    # --- Numerical Integrators ---\n\n    def sym_euler_step(y_n, h):\n        \"\"\"Performs one step of the time-symmetrized Euler method.\"\"\"\n        \n        # Implicit equation: G(y_next) = y_next - y_n - 0.5*h*f(y_n) - 0.5*h*f(y_next) = 0\n        f_n = f_ode(y_n)\n        \n        # Initial guess using explicit Euler\n        y_next = y_n + h * f_n\n        \n        for _ in range(NEWTON_MAX_ITER):\n            # Evaluate G(y_next)\n            G = y_next - y_n - 0.5 * h * f_n - 0.5 * h * f_ode(y_next)\n            \n            # Evaluate Jacobian of G: I - 0.5*h*J_f(y_next)\n            J_g = np.identity(4) - 0.5 * h * compute_jacobian(y_next)\n            \n            # Solve linear system for the update: J_g * delta_y = -G\n            delta_y = np.linalg.solve(J_g, -G)\n            \n            # Update solution\n            y_next += delta_y\n            \n            # Check for convergence\n            if np.linalg.norm(delta_y, ord=np.inf)  NEWTON_TOL:\n                break\n        \n        return y_next\n\n    def midpoint_step(y_n, h):\n        \"\"\"Performs one step of the explicit midpoint method.\"\"\"\n        k1 = f_ode(y_n)\n        y_mid = y_n + 0.5 * h * k1\n        k2 = f_ode(y_mid)\n        return y_n + h * k2\n\n    def rk4_step(y_n, h):\n        \"\"\"Performs one step of the classical RK4 method.\"\"\"\n        k1 = f_ode(y_n)\n        k2 = f_ode(y_n + 0.5 * h * k1)\n        k3 = f_ode(y_n + 0.5 * h * k2)\n        k4 = f_ode(y_n + h * k3)\n        return y_n + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    # --- Test Case Execution ---\n\n    test_cases = [\n        # a, e, num_periods, N_per\n        (1.0, 0.1, 200, 100),\n        (1.0, 0.6, 100, 200),\n        (1.0, 0.0, 50, 20),\n    ]\n\n    integrators = {\n        'symEuler': sym_euler_step,\n        'midpoint': midpoint_step,\n        'RK4': rk4_step,\n    }\n    method_order = ['symEuler', 'midpoint', 'RK4']\n    \n    all_results = []\n\n    for a, e, num_periods, N_per in test_cases:\n        # Calculate initial conditions\n        if e == 1.0: # Parabolic case, r_p=a(1-e) is tricky\n            r_p = a * (1e-12) # Avoid singularity, not in test suite\n            v_p = np.sqrt(2*MU/r_p)\n        else:\n            r_p = a * (1 - e)\n            v_p = np.sqrt(MU * (2 / r_p - 1 / a))\n        \n        y0 = np.array([r_p, 0.0, 0.0, v_p], dtype=np.float64)\n        \n        # Calculate integration parameters\n        T = 2 * np.pi * a**1.5\n        dt = T / N_per\n        total_steps = num_periods * N_per\n\n        # Calculate initial energy\n        E0 = compute_energy(y0)\n\n        for method_name in method_order:\n            integrator = integrators[method_name]\n            y = y0.copy()\n            max_rel_error = 0.0\n            \n            for _ in range(total_steps):\n                y = integrator(y, dt)\n                En = compute_energy(y)\n                rel_error = np.abs(En - E0) / np.abs(E0)\n                if rel_error > max_rel_error:\n                    max_rel_error = rel_error\n            \n            all_results.append(max_rel_error)\n\n    # --- Format and Print Final Output ---\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3534425"}]}