{"hands_on_practices": [{"introduction": "在数值模拟中，施加像狄利克雷边界条件这样的约束是一项基本任务。本练习 [@problem_id:3525095] 提供了一个具体的编程实践，旨在比较经典的拉格朗日乘子法（它会导出一个鞍点系统）和近似的罚函数法。通过分析这两种基本方法的误差行为，我们将深入理解它们各自的优势与权衡。", "problem": "考虑区间 $[0,1]$ 上的一个一维标量泊松问题，该问题具有恒定的体力，其主场 $u(x)$ 满足强形式方程 $-u''(x)=1$（对于 $x\\in(0,1)$），同时在右端满足零诺伊曼边界条件 $u'(1)=0$，并在左端满足边界约束 $u(0)=0$。将 $u(0)=0$ 视为一个约束，可通过拉格朗日乘子（鞍点格式）或罚函数项来施加。从 $-u''=1$ 在 $x=1$ 处具有自然（诺伊曼）边界的标准变分陈述出发，利用虚功原理建立带有拉格朗日乘子的约束弱问题，并分别通过为约束添加二次罚函数项来建立罚函数弱问题。然后，使用在 $[0,1]$ 上的均匀线性有限元对两种格式进行离散化，其中包含 $N$ 个单元，网格尺寸为 $h=1/N$，并实现以下内容：\n\n- 对于乘子法，引入一个额外的标量未知数（乘子），以在弱意义下施加约束 $u(0)=0$，从而产生一个将有限元刚度与约束耦合的鞍点线性系统。\n- 对于罚函数法，添加一个与标量罚参数 $\\gamma$ 成正比的对称罚双线性形式，该形式弱施加 $u(0)\\approx 0$。\n\n使用与强形式和约束条件一致的精确解析解作为参考来量化数值误差，该解在相同的物理和数学框架内选取。对每种方法和每个测试用例，计算以下指标：\n- $L^2$ 误差范数 $\\left(\\int_{0}^{1}\\left(u_{\\text{exact}}(x)-u_h(x)\\right)^2\\,dx\\right)^{1/2}$。\n- 误差的 $H^1$ 半范数 $\\left(\\int_{0}^{1}\\left(u'_{\\text{exact}}(x)-u'_h(x)\\right)^2\\,dx\\right)^{1/2}$。\n- 边界上的约束残差 $\\left|u_h(0)\\right|$。\n\n您的实现必须使用足够阶数的高斯求积，以精确积分一维线性元在这些范数中出现的多项式。所有积分都必须在 $x\\in[0,1]$ 上执行。\n\n您的推导应基于：\n- 强形式 $-u''(x)=1$（对于 $x\\in(0,1)$），附带 $u'(1)=0$ 和等式约束 $u(0)=0$。\n- 相应的无约束弱形式 $\\int_{0}^{1}u'(x)v'(x)\\,dx=\\int_{0}^{1}1\\cdot v(x)\\,dx$（对于所有容许的 $v(x)$），此为添加约束之前的形式。\n\n精确定义离散格式然后实现它们。假设使用均匀网格和线性基函数。用于比较的精确解必须从指定的强形式和边界条件推导得出。测试套件由参数对 $(N,\\gamma)$ 的集合定义，其中 $N$ 是单元数量，$\\gamma$ 是罚参数：\n- $(N,\\gamma)=(4,10)$ 作为一般情况，\n- $(N,\\gamma)=(16,10)$ 用于在小 $\\gamma$ 下探究网格细化，\n- $(N,\\gamma)=(16,1000)$ 用于在固定 $h$ 下探究增加的 $\\gamma$，\n- $(N,\\gamma)=(64,1000)$ 作为中等 $\\gamma$ 下的细化网格，\n- $(N,\\gamma)=(64,10^6)$ 用于探究非常大的 $\\gamma$，\n- $(N,\\gamma)=(2,1000)$ 作为粗网格的边界情况。\n\n对于每个测试用例，计算罚函数法和乘子法的三个指标（乘子法不依赖于 $\\gamma$，但为了可比性，必须在相同的 $N$ 值下进行评估）。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，并且本身是一个包含六个浮点数的列表，顺序为 $[E_{L^2}^{\\text{pen}},E_{H^1}^{\\text{pen}},r^{\\text{pen}},E_{L^2}^{\\text{mult}},E_{H^1}^{\\text{mult}},r^{\\text{mult}}]$，其中 $E_{L^2}$ 是 $L^2$ 误差范数，$E_{H^1}$ 是误差的 $H^1$ 半范数，$r$ 是约束残差 $\\left|u_h(0)\\right|$。\n\n所有数学符号、变量、函数、算子和数字都必须用美元符号括起来以 LaTeX 格式书写，包括 $u$、$v$、$x$、$N$、$h$、$\\gamma$、$1$、$0$ 以及所有的积分和范数。本问题不涉及物理单位；不使用角度和百分比。输出必须符合上述格式，并且所有测试用例的答案都必须是浮点数。", "solution": "该问题要求解一维泊松方程 $-u''(x) = 1$（在区间 $x \\in (0,1)$ 上），边界条件为 $u'(1)=0$ 和 $u(0)=0$。条件 $u(0)=0$ 被视为一个约束，通过两种不同的方法施加：罚函数法和拉格朗日乘子法。解将使用线性基函数的有限元法获得。\n\n### 1. 解析解\n首先，我们建立精确解析解，以作为数值误差分析的基准。微分方程的强形式为：\n$$ -u''(x) = 1 $$\n对 $x$ 积分得到：\n$$ -u'(x) = x + C_1 $$\n应用诺伊曼边界条件 $u'(1)=0$ 来确定常数 $C_1$：\n$$ -u'(1) = 1 + C_1 = 0 \\implies C_1 = -1 $$\n因此，解的导数为：\n$$ u'(x) = 1 - x $$\n再次积分得到 $u(x)$ 的通解：\n$$ u(x) = x - \\frac{1}{2}x^2 + C_2 $$\n使用约束 $u(0)=0$ 来求解 $C_2$：\n$$ u(0) = 0 - 0 + C_2 = 0 \\implies C_2 = 0 $$\n因此，精确解为：\n$$ u_{\\text{exact}}(x) = x - \\frac{1}{2}x^2 $$\n其导数为 $u'_{\\text{exact}}(x) = 1 - x$。\n\n### 2. 变分格式\n我们从给定的无约束弱形式出发，它对应于双线性形式 $a(u,v) = \\int_{0}^{1} u'(x)v'(x) \\,dx$ 和线性泛函 $L(v) = \\int_{0}^{1} 1 \\cdot v(x) \\,dx$。问题是在一个适当的空间 $V$（此处为 $H^1(0,1)$）中找到一个函数 $u(x)$，使其满足变分方程和约束 $u(0)=0$。\n\n#### 2.1. 罚函数法格式\n在罚函数法中，通过向总势能泛函中添加一个罚函数项来弱施加约束 $u(0)=0$。需要最小化的修正泛函为：\n$$ J(u) = \\frac{1}{2} a(u,u) - L(u) + \\frac{1}{2}\\gamma (u(0))^2 $$\n其中 $\\gamma > 0$ 是一个大的罚参数。解 $u_\\gamma$ 通过要求 $J(u)$ 对任意试探函数 $v \\in V$ 的一阶变分为零来求得。这得到了罚函数弱格式：\n找到 $u_\\gamma \\in V$，使得对于所有 $v \\in V$：\n$$ a(u_\\gamma, v) + \\gamma u_\\gamma(0)v(0) = L(v) $$\n代入 $a(\\cdot,\\cdot)$ 和 $L(\\cdot)$ 的定义：\n$$ \\int_{0}^{1} u_\\gamma'(x)v'(x) \\,dx + \\gamma u_\\gamma(0)v(0) = \\int_{0}^{1} v(x) \\,dx $$\n\n#### 2.2. 拉格朗日乘子法格式\n该方法引入一个拉格朗日乘子 $\\lambda$ 来精确施加约束。我们求解一对 $(u, \\lambda) \\in V \\times \\mathbb{R}$。增广泛函（拉格朗日量）为：\n$$ \\mathcal{L}(u, \\lambda) = \\frac{1}{2} a(u,u) - L(u) + \\lambda u(0) $$\n解是 $\\mathcal{L}$ 的一个驻点。对 $u$（在 $v$ 方向）和 $\\lambda$（在 $\\mu$ 方向）取变分并令其为零，得到以下方程组：\n1.  $\\delta_u \\mathcal{L}(v) = a(u,v) - L(v) + \\lambda v(0) = 0$ 对所有 $v \\in V$。\n2.  $\\delta_\\lambda \\mathcal{L}(\\mu) = \\mu u(0) = 0$ 对所有 $\\mu \\in \\mathbb{R}$，这意味着 $u(0)=0$。\n\n这导出了鞍点弱格式：找到 $(u, \\lambda) \\in V \\times \\mathbb{R}$，使得：\n$$ \\int_{0}^{1} u'(x)v'(x) \\,dx + \\lambda v(0) = \\int_{0}^{1} v(x) \\,dx \\quad \\forall v \\in V $$\n$$ u(0) = 0 $$\n在物理上，乘子 $\\lambda$ 可以被视为施加约束所需的反作用通量。与分部积分产生的边界项比较，可知 $\\lambda = -u'(0)$。对于精确解，$\\lambda = -(1-0) = -1$。\n\n### 3. 有限元离散化\n我们将区间 $[0,1]$ 离散化为 $N$ 个长度为 $h=1/N$ 的均匀单元。节点位于 $x_i = i h$（$i=0, 1, \\dots, N$）。我们使用线性基函数（帽函数）$\\phi_i(x)$，其中 $\\phi_i(x_j) = \\delta_{ij}$。有限元解近似为 $u_h(x) = \\sum_{j=0}^{N} u_j \\phi_j(x)$，其中 $\\mathbf{u} = (u_0, u_1, \\dots, u_N)^T$ 是节点未知数值的向量。\n\n标准刚度矩阵 $K$ 和力向量 $F$ 由以下元素组装而成：\n$$ K_{ij} = a(\\phi_j, \\phi_i) = \\int_0^1 \\phi_j'(x) \\phi_i'(x) \\,dx $$\n$$ F_i = L(\\phi_i) = \\int_0^1 \\phi_i(x) \\,dx $$\n对于均匀网格和线性单元，这会得到一个 $(N+1) \\times (N+1)$ 的对称三对角刚度矩阵 $K$ 和载荷向量 $F$：\n$$ K = \\frac{1}{h} \\begin{pmatrix} 1  -1   \\\\ -1  2  -1  \\\\  \\ddots  \\ddots  \\ddots \\\\   -1  2  -1 \\\\    -1  1 \\end{pmatrix}, \\quad F = h \\begin{pmatrix} 1/2 \\\\ 1 \\\\ \\vdots \\\\ 1 \\\\ 1/2 \\end{pmatrix} $$\n\n#### 3.1. 离散罚函数系统\n通过令 $u_h = \\sum_j u_j \\phi_j$ 和 $v = \\phi_i$ 来离散化罚函数弱形式，得到：\n$$ \\sum_{j=0}^{N} u_j K_{ij} + \\gamma \\left(\\sum_{j=0}^{N} u_j \\phi_j(0)\\right) \\phi_i(0) = F_i \\quad \\text{for } i=0, \\dots, N $$\n由于 $\\phi_j(0) = \\delta_{j0}$ 且 $u_h(0) = u_0$，这可以被简化。罚函数项仅影响第一个方程（$i=0$），在方程左侧增加了 $\\gamma u_0$。这等价于将 $\\gamma$ 加到刚度矩阵的 $(0,0)$ 元素上。得到的线性系统是：\n$$ (K + K_p) \\mathbf{u} = F \\quad \\text{where} \\quad K_p = \\begin{pmatrix} \\gamma  0  \\dots \\\\ 0  0  \\dots \\\\ \\vdots  \\vdots  \\ddots \\end{pmatrix} $$\n\n#### 3.2. 离散拉格朗日乘子系统\n离散化鞍点格式会产生一个针对未知数 $(\\mathbf{u}, \\lambda)$ 的更大的块结构线性系统。方程变为：\n$$ \\sum_{j=0}^{N} u_j K_{ij} + \\lambda \\phi_i(0) = F_i \\quad \\text{for } i=0, \\dots, N $$\n$$ u_0 = 0 $$\n令 $B$ 为约束向量，使得 $B_i = \\phi_i(0) = \\delta_{i0}$。离散系统可以写成块矩阵形式：\n$$ \\begin{pmatrix} K  B \\\\ B^T  0 \\end{pmatrix} \\begin{pmatrix} \\mathbf{u} \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} F \\\\ 0 \\end{pmatrix} $$\n这是一个 $(N+2) \\times (N+2)$ 的对称不定系统。\n\n### 4. 误差指标\n使用三个指标将数值解与精确解进行比较：\n1.  **$L^2$ 误差范数：** $E_{L^2} = \\left(\\int_{0}^{1}\\left(u_{\\text{exact}}(x)-u_h(x)\\right)^2\\,dx\\right)^{1/2}$\n2.  **误差的 $H^1$ 半范数：** $E_{H^1} = \\left(\\int_{0}^{1}\\left(u'_{\\text{exact}}(x)-u'_h(x)\\right)^2\\,dx\\right)^{1/2}$\n3.  **约束残差：** $r = \\left|u_h(0)\\right| = |u_0|$\n\n误差范数的积分使用高斯求积进行数值计算。在每个单元上，$u_h(x)$ 是线性的，$u_h'(x)$ 是常数，而 $u_{\\text{exact}}(x)$ 是二次的，$u'_{\\text{exact}}(x)$ 是线性的。因此，$L^2$ 误差的被积函数是一个4次多项式，需要3点高斯法则才能精确积分。误差的 $H^1$ 半范数的被积函数是一个2次多项式，需要2点高斯法则。为简单和一致起见，3点法对两者都足够。在 $[0,1]$ 上的积分通过对每个单元的贡献求和来执行，即在参考单元上应用求积法则，然后映射到物理单元坐标。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Solves the 1D Poisson problem with two different constraint enforcement methods\n    and computes error metrics against the exact solution.\n    \"\"\"\n\n    test_cases = [\n        (4, 10.0),\n        (16, 10.0),\n        (16, 1000.0),\n        (64, 1000.0),\n        (64, 1.0e6),\n        (2, 1000.0),\n    ]\n\n    all_results = []\n\n    for N, gamma in test_cases:\n        h = 1.0 / N\n        num_nodes = N + 1\n\n        # Assemble stiffness matrix K and force vector F\n        K = np.zeros((num_nodes, num_nodes))\n        F = np.zeros(num_nodes)\n\n        # Diagonals\n        K.flat[::num_nodes+1] = 2.0 / h\n        K[0, 0] = 1.0 / h\n        K[N, N] = 1.0 / h\n        # Off-diagonals\n        off_diag = -1.0 / h\n        K.flat[1::num_nodes+1] = off_diag\n        K.flat[num_nodes::num_nodes+1] = off_diag\n\n        # Force vector\n        F[:] = h\n        F[0] = h / 2.0\n        F[N] = h / 2.0\n\n        # --- Penalty Method ---\n        K_pen = np.copy(K)\n        K_pen[0, 0] += gamma\n        u_pen = linalg.solve(K_pen, F)\n        \n        l2_pen, h1_pen = calculate_error_norms(u_pen, N)\n        r_pen = np.abs(u_pen[0])\n\n        # --- Lagrange Multiplier Method ---\n        # Form the saddle-point system matrix A_mult\n        A_mult = np.zeros((num_nodes + 1, num_nodes + 1))\n        A_mult[:num_nodes, :num_nodes] = K\n        B = np.zeros(num_nodes)\n        B[0] = 1.0\n        A_mult[:num_nodes, num_nodes] = B\n        A_mult[num_nodes, :num_nodes] = B.T\n\n        # Form the right-hand side vector\n        rhs_mult = np.zeros(num_nodes + 1)\n        rhs_mult[:num_nodes] = F\n\n        # Solve the system\n        sol_mult = linalg.solve(A_mult, rhs_mult)\n        u_mult = sol_mult[:num_nodes]\n        # _lambda = sol_mult[num_nodes] # The multiplier is not used further\n        \n        l2_mult, h1_mult = calculate_error_norms(u_mult, N)\n        r_mult = np.abs(u_mult[0])\n\n        case_results = [l2_pen, h1_pen, r_pen, l2_mult, h1_mult, r_mult]\n        all_results.append(case_results)\n\n    # Format output string\n    # Replace Python's default representation to remove spaces for cleaner output\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\n\ndef calculate_error_norms(u_h_coeffs, N):\n    \"\"\"\n    Computes L2 and H1 error norms using Gaussian quadrature.\n    \"\"\"\n    h = 1.0 / N\n    \n    # 3-point Gauss quadrature on [-1, 1]\n    z_pts = [-np.sqrt(3.0/5.0), 0.0, np.sqrt(3.0/5.0)]\n    w_pts = [5.0/9.0, 8.0/9.0, 5.0/9.0]\n    \n    l2_err_sq = 0.0\n    h1_err_sq = 0.0\n\n    # Exact solution and its derivative\n    u_exact_func = lambda x: x - 0.5 * x**2\n    u_exact_prime_func = lambda x: 1.0 - x\n\n    for e in range(N):\n        # Nodal coordinates and values for element e\n        x_e = e * h\n        u_e = u_h_coeffs[e]\n        u_e1 = u_h_coeffs[e+1]\n        \n        # Derivative of FE solution on element e (constant)\n        u_h_prime_val = (u_e1 - u_e) / h\n\n        # Loop over Gauss points\n        for z_k, w_k in zip(z_pts, w_pts):\n            # Map reference point to physical coordinate\n            x_q = x_e + h * (z_k + 1.0) / 2.0\n            \n            # Evaluate exact solution and its derivative\n            u_exact_val = u_exact_func(x_q)\n            u_exact_prime_val = u_exact_prime_func(x_q)\n            \n            # Evaluate FE solution at x_q\n            # Local coordinate xi is (z_k+1)/2\n            xi_q = (z_k + 1.0) / 2.0\n            u_h_val = u_e * (1.0 - xi_q) + u_e1 * xi_q\n            \n            # Accumulate squared errors\n            l2_err_sq += w_k * (u_exact_val - u_h_val)**2\n            h1_err_sq += w_k * (u_exact_prime_val - u_h_prime_val)**2\n    \n    # Apply Jacobian determinant and take square root\n    # The Jacobian factor is h/2\n    l2_err = np.sqrt(l2_err_sq * h / 2.0)\n    h1_err = np.sqrt(h1_err_sq * h / 2.0)\n    \n    return l2_err, h1_err\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3525095"}, {"introduction": "并非所有对鞍点问题的离散化都是有效的，其稳定性至关重要。本练习 [@problem_id:3525102] 通过展示当著名的inf-sup（或LBB）稳定条件失效时会发生什么，来探讨这一核心概念。通过为斯托克斯方程手动构造一个非物理的“棋盘”压力模式，您将理解为什么为不同物理场（如速度和压力）选择的有限元空间不能随意组合，以及这种选择对于获得有意义的解是多么关键。", "problem": "考虑单位正方形区域 $\\Omega = [0,1]^{2}$ 上的稳态不可压缩斯托克斯方程，速度满足齐次狄利克雷边界条件。设其弱形式由以下鞍点系统给出：求速度 $u \\in V$ 和压力 $p \\in Q$ 使得\n$$\na(u,v) + b(v,p) = f(v) \\quad \\text{对所有 } v \\in V, \\qquad b(u,q) = 0 \\quad \\text{对所有 } q \\in Q,\n$$\n其中 $V$ 是在 $\\partial \\Omega$ 上迹为零的平方可积向量场构成的索博列夫空间，其梯度也平方可积；$Q$ 是在 $\\Omega$ 上均值为零的平方可积函数空间；$a(u,v) = \\int_{\\Omega} 2\\mu \\, \\epsilon(u) : \\epsilon(v) \\, dx$，其中 $\\epsilon(u)$ 是对称梯度；以及 $b(v,p) = -\\int_{\\Omega} p \\, \\nabla \\cdot v \\, dx$。在有限元法 (FEM) 中，考虑等阶离散空间\n$$\nV_{h} = \\{ v_{h} \\in V : v_{h} \\text{ 在 } \\Omega \\text{ 的一个三角剖分上是连续的分片线性 ($P_{1}$) 函数} \\}^{2},\n$$\n$$\nQ_{h} = \\{ q_{h} \\in Q : q_{h} \\text{ 在相同的三角剖分上是连续的分片线性 ($P_{1}$) 函数} \\}.\n$$\n\n使用 $\\Omega$ 的如下协调三角剖分 $\\mathcal{T}_{h}$：顶点集由四个角点 $(0,0)$、$(1,0)$、$(1,1)$、$(0,1)$ 和内点 $C = (1/2,1/2)$ 组成。该网格由共享内顶点 $C$ 的四个三角形构成：\n- $T_{1}$ 的顶点为 $C$、$(0,0)$、$(1,0)$，\n- $T_{2}$ 的顶点为 $C$、$(1,0)$、$(1,1)$，\n- $T_{3}$ 的顶点为 $C$、$(1,1)$、$(0,1)$，\n- $T_{4}$ 的顶点为 $C$、$(0,1)$、$(0,0)$。\n\n假设离散速度空间 $V_{h}$ 强施加齐次狄利克雷边界条件，因此只有内节点 $C$ 具有速度自由度。令 $\\{N_{i}\\}$ 表示与节点 $i \\in \\{(0,0), (1,0), (1,1), (0,1), C\\}$ 相关联的标量 $P_{1}$ 节点形函数，并令速度基函数为 $\\phi_{C}^{x} = (N_{C}, 0)$ 和 $\\phi_{C}^{y} = (0, N_{C})$。离散耦合双线性形式为\n$$\nb(v_{h},q_{h}) = -\\int_{\\Omega} q_{h} \\, \\nabla \\cdot v_{h} \\, dx.\n$$\n\n从上述三角形上分片线性函数的基本定义和性质出发，构造一个显式的非零 $q_{h} \\in Q_{h}$，其节点值 $\\{p_{(0,0)}, p_{(1,0)}, p_{(1,1)}, p_{(0,1)}, p_{C}\\}$ 满足\n$$\nb(v_{h}, q_{h}) = 0 \\quad \\text{对所有 } v_{h} \\in V_{h}.\n$$\n\n你的任务：\n- 推导由 $\\mathcal{T}_{h}$ 的结构所决定的、使得对于所有 $v_{h} \\in V_{h}$ 都有 $b(v_{h}, q_{h})$ 为零的关于 $\\{p_{(0,0)}, p_{(1,0)}, p_{(1,1)}, p_{(0,1)}, p_{C}\\}$ 的充要条件。\n- 使用这些条件构造一个具体的、用其节点值表示的非零伪压力模式 $q_{h}$。\n- 以节点值的行向量\n$$\n\\left(p_{(0,0)} \\ \\ p_{(1,0)} \\ \\ p_{(1,1)} \\ \\ p_{(0,1)} \\ \\ p_{C}\\right),\n$$\n的精确形式给出最终答案。无需四舍五入，且不涉及物理单位。", "solution": "目标是找到一个非零的离散压力场 $q_{h} \\in Q_{h}$，使其与离散散度算子的像正交，即对于所有离散速度场 $v_{h} \\in V_{h}$，都有 $b(v_{h}, q_{h}) = 0$。具有此性质的压力场 $q_h$ 被称为伪压力模式，其存在表明所选的速度-压力有限元对（本例中为 $P_1-P_1$）是不稳定的。\n\n需要满足的条件是：\n$$b(v_{h}, q_{h}) = -\\int_{\\Omega} q_{h} \\, \\nabla \\cdot v_{h} \\, dx = 0 \\quad \\text{对所有 } v_{h} \\in V_{h}。$$\n由于该条件必须对任意 $v_{h} \\in V_{h}$ 成立，因此它必须对张成 $V_{h}$ 的基函数成立。根据问题描述，齐次狄利克雷边界条件是强施加的。唯一具有非零速度自由度的节点是内节点 $C = (1/2, 1/2)$。因此，离散速度空间 $V_{h}$ 是一个二维空间，由基函数 $\\phi_{C}^{x} = (N_{C}, 0)$ 和 $\\phi_{C}^{y} = (0, N_{C})$ 张成，其中 $N_{C}$ 是与节点 $C$ 相关联的连续分片线性节点基函数。\n\n压力场 $q_{h}$ 是 $Q_{h}$ 中的一个元素，可以表示为所有五个节点（角点 $V_{(0,0)}=(0,0)$、$V_{(1,0)}=(1,0)$、$V_{(1,1)}=(1,1)$、$V_{(0,1)}=(0,1)$ 和中心点 $C$）的节点基函数 $\\{N_i\\}$ 的线性组合。设 $q_{h}$ 的节点值为 $\\{p_{(0,0)}, p_{(1,0)}, p_{(1,1)}, p_{(0,1)}, p_{C}\\}$。那么，\n$$q_{h}(x,y) = p_{(0,0)}N_{(0,0)}(x,y) + p_{(1,0)}N_{(1,0)}(x,y) + p_{(1,1)}N_{(1,1)}(x,y) + p_{(0,1)}N_{(0,1)}(x,y) + p_{C}N_{C}(x,y)。$$\n\n条件 $b(v_{h}, q_{h}) = 0$ 对所有 $v_h \\in V_h$ 成立，可化简为两个标量方程：\n1. $b(\\phi_{C}^{x}, q_{h}) = -\\int_{\\Omega} q_{h} \\nabla \\cdot \\phi_{C}^{x} \\, dx = -\\int_{\\Omega} q_{h} \\frac{\\partial N_{C}}{\\partial x} \\, dx = 0$。\n2. $b(\\phi_{C}^{y}, q_{h}) = -\\int_{\\Omega} q_{h} \\nabla \\cdot \\phi_{C}^{y} \\, dx = -\\int_{\\Omega} q_{h} \\frac{\\partial N_{C}}{\\partial y} \\, dx = 0$。\n\n我们来分析基函数 $N_C$ 的梯度。在每个三角形 $T_k$ 上，$N_C$ 是一个线性函数，所以它的梯度是一个常向量。基函数 $N_C$ 在节点 $C$ 处的值为 1，在所有其他节点处的值为 0。在四个三角形上的梯度分别为：\n- 在 $T_{1}$ (顶点为 $C, (0,0), (1,0)$) 上：$\\nabla N_{C}|_{T_1} = (0, 2)$。\n- 在 $T_{2}$ (顶点为 $C, (1,0), (1,1)$) 上：$\\nabla N_{C}|_{T_2} = (-2, 0)$。\n- 在 $T_{3}$ (顶点为 $C, (1,1), (0,1)$) 上：$\\nabla N_{C}|_{T_3} = (0, -2)$。\n- 在 $T_{4}$ (顶点为 $C, (0,1), (0,0)$) 上：$\\nabla N_{C}|_{T_4} = (2, 0)$。\n\n因此，$\\frac{\\partial N_C}{\\partial x}$ 仅在 $T_2$ 和 $T_4$ 上非零，而 $\\frac{\\partial N_C}{\\partial y}$ 仅在 $T_1$ 和 $T_3$ 上非零。\n\n现在我们计算第一个方程：\n$$-\\int_{\\Omega} q_{h} \\frac{\\partial N_{C}}{\\partial x} \\, dx = -\\left( \\int_{T_2} q_{h} (-2) \\, dx + \\int_{T_4} q_{h} (2) \\, dx \\right) = 0。$$\n这可以简化为 $\\int_{T_2} q_{h} \\, dx = \\int_{T_4} q_{h} \\, dx$。\n线性函数在三角形上的积分等于其面积乘以其在顶点处节点值的平均值。每个三角形的面积为 $\\frac{1}{4}$。\n$T_2$ 的顶点是 $C, (1,0), (1,1)$。因此，$\\int_{T_2} q_{h} dx = \\frac{\\text{Area}(T_2)}{3}(p_C + p_{(1,0)} + p_{(1,1)}) = \\frac{1}{12}(p_C + p_{(1,0)} + p_{(1,1)})$。\n$T_4$ 的顶点是 $C, (0,1), (0,0)$。因此，$\\int_{T_4} q_{h} dx = \\frac{\\text{Area}(T_4)}{3}(p_C + p_{(0,1)} + p_{(0,0)}) = \\frac{1}{12}(p_C + p_{(0,1)} + p_{(0,0)})$。\n令二者相等可得 $p_C + p_{(1,0)} + p_{(1,1)} = p_C + p_{(0,1)} + p_{(0,0)}$，这就得出了我们关于节点压力的第一个条件：\n$$(1) \\quad p_{(0,0)} + p_{(0,1)} - p_{(1,0)} - p_{(1,1)} = 0。$$\n\n接下来，我们计算第二个方程：\n$$-\\int_{\\Omega} q_{h} \\frac{\\partial N_{C}}{\\partial y} \\, dx = -\\left( \\int_{T_1} q_{h} (2) \\, dx + \\int_{T_3} q_{h} (-2) \\, dx \\right) = 0。$$\n这可以简化为 $\\int_{T_1} q_{h} \\, dx = \\int_{T_3} q_{h} \\, dx$。\n$T_1$ 的顶点是 $C, (0,0), (1,0)$。因此，$\\int_{T_1} q_h dx = \\frac{1}{12}(p_C + p_{(0,0)} + p_{(1,0)})$。\n$T_3$ 的顶点是 $C, (1,1), (0,1)$。因此，$\\int_{T_3} q_h dx = \\frac{1}{12}(p_C + p_{(1,1)} + p_{(0,1)})$。\n令二者相等可得 $p_C + p_{(0,0)} + p_{(1,0)} = p_C + p_{(1,1)} + p_{(0,1)}$，这就得出了我们的第二个条件：\n$$(2) \\quad p_{(0,0)} + p_{(1,0)} - p_{(0,1)} - p_{(1,1)} = 0。$$\n\n最后，空间 $Q_h$ 是 $L^2_0(\\Omega)$ 的一个子空间，这意味着压力场在 $\\Omega$ 上的均值必须为零：\n$$\\int_{\\Omega} q_{h} \\, dx = \\sum_{k=1}^4 \\int_{T_k} q_h \\, dx = 0。$$\n将四个三角形上的积分相加：\n$$\\frac{1}{12} \\left[ (p_C+p_{(0,0)}+p_{(1,0)}) + (p_C+p_{(1,0)}+p_{(1,1)}) + (p_C+p_{(1,1)}+p_{(0,1)}) + (p_C+p_{(0,1)}+p_{(0,0)}) \\right] = 0。$$\n这可以简化为 $\\frac{1}{12} (4p_C + 2p_{(0,0)} + 2p_{(1,0)} + 2p_{(1,1)} + 2p_{(0,1)}) = 0$。\n所以，第三个条件是：\n$$(3) \\quad p_{(0,0)} + p_{(1,0)} + p_{(1,1)} + p_{(0,1)} + 2p_C = 0。$$\n\n我们得到了一个包含五个未知数的三个线性方程组。我们来找出它们之间的关系。\n将方程(1)和(2)相加：\n$(p_{(0,0)} + p_{(0,1)} - p_{(1,0)} - p_{(1,1)}) + (p_{(0,0)} + p_{(1,0)} - p_{(0,1)} - p_{(1,1)}) = 0 \\implies 2p_{(0,0)} - 2p_{(1,1)} = 0 \\implies p_{(1,1)} = p_{(0,0)}$。\n将方程(2)减去方程(1)：\n$(p_{(0,0)} + p_{(1,0)} - p_{(0,1)} - p_{(1,1)}) - (p_{(0,0)} + p_{(0,1)} - p_{(1,0)} - p_{(1,1)}) = 0 \\implies 2p_{(1,0)} - 2p_{(0,1)} = 0 \\implies p_{(0,1)} = p_{(1,0)}$。\n这些是必要条件：对角上相对的角点处的节点压力必须相等。\n\n将这些代入方程(3)：\n$p_{(0,0)} + p_{(1,0)} + p_{(0,0)} + p_{(1,0)} + 2p_C = 0 \\implies 2p_{(0,0)} + 2p_{(1,0)} + 2p_C = 0$。\n这给出了最终条件：$p_C = -p_{(0,0)} - p_{(1,0)}$。\n\n$q_h$ 成为一个伪压力模式的节点值的充要条件是：\n- $p_{(1,1)} = p_{(0,0)}$\n- $p_{(0,1)} = p_{(1,0)}$\n- $p_C = -(p_{(0,0)} + p_{(1,0)})$\n\n这定义了一个二维的伪压力模式空间。任意选择 $p_{(0,0)}$ 和 $p_{(1,0)}$（不全为零）都将生成一个有效的非零模式。用于说明此现象的一个典范选择是“棋盘”模式。我们设 $p_{(0,0)} = 1$ 和 $p_{(1,0)} = -1$。\n使用推导出的条件：\n- $p_{(1,1)} = p_{(0,0)} = 1$。\n- $p_{(0,1)} = p_{(1,0)} = -1$。\n- $p_C = -(1 + (-1)) = 0$。\n\n这给出了节点压力向量 $(p_{(0,0)}, p_{(1,0)}, p_{(1,1)}, p_{(0,1)}, p_C) = (1, -1, 1, -1, 0)$。这是一个具体的、非零的伪压力模式。\n最终答案是这些节点值按指定顺序组成的行向量。", "answer": "$$\\boxed{\\begin{pmatrix} 1  -1  1  -1  0 \\end{pmatrix}}$$", "id": "3525102"}, {"introduction": "现在我们将鞍点公式应用于一个更复杂的问题，这是多物理场仿真中的一个常见场景。本练习 [@problem_id:3525101] 将在三维网格上实现一个混合公式，用以施加磁场无散度 $\\nabla \\cdot B = 0$ 的物理约束。这是一个在标准基于势的公式中没有天然对应项的物理定律，因此本练习也展示了混合鞍点法在正确建模基本物理定律方面的强大能力。", "problem": "考虑非均匀介质中麦克斯韦方程组的静磁学子集，其中磁通量密度 $\\;B\\;$ 和磁场 $\\;H\\;$ 满足 $\\;B=\\mu H\\;$（$\\;\\mu>0\\;$），以及无散度约束 $\\;\\nabla\\cdot B=0\\;$（无磁单极子）。混合格式引入一个拉格朗日乘子来施加约束 $\\;\\nabla\\cdot(\\mu H)=0\\;$，从而得到一个鞍点系统。您的任务是在一个简单的四面体网格上构建一个离散有限体积鞍点系统，组装其矩阵，并求解一个小型示例，以说明如何通过乘子施加 $\\;\\nabla\\cdot(\\mu H)=0\\;$ 的约束。\n\n从以下基本基础开始：\n- 静磁学：$\\;\\nabla\\times H=J\\;$，$\\;B=\\mu H\\;$，$\\;\\nabla\\cdot B=0\\;$。\n- 无散度约束 $\\;\\nabla\\cdot B=0\\;$ 通过混合变分形式中的拉格朗日乘子 $\\;p\\;$ 来施加。\n- 能量原理：在约束条件 $\\;\\nabla\\cdot B=0\\;$ 下，最小化 $\\;\\int \\nu \\lvert B\\rvert^2/2\\;\\mathrm{d}V - \\int \\phi\\cdot B\\;\\mathrm{d}V\\;$，其中磁阻率 $\\;\\nu=1/\\mu\\;$，$\\;\\phi\\;$ 为通用源耦合项。这将导出一个鞍点线性系统。\n\n离散化设置：\n- 使用一个由2个共享一个面的四面体组成的四面体网格。顶点（以无量纲单位表示）为：\n  - $v_0=(0,0,0)$,\n  - $v_1=(1,0,0)$,\n  - $v_2=(0,1,0)$,\n  - $v_3=(0,0,1)$,\n  - $v_4=(1,1,1)$。\n- 两个四面体是：\n  - $T_0=(v_0,v_1,v_2,v_3)$,\n  - $T_1=(v_1,v_2,v_3,v_4)$。\n- 将唯一的三角形面构建为顶点索引的无序三元组集合；对于每个面，通过按顶点索引递增排序来固定一个全局方向，并计算其几何量：\n  - 面心 $\\;c_f\\;$ 为其3个顶点的算术平均值。\n  - 未归一化的面法向量 $\\;n_f\\;$ 来自与所选方向一致的两条边向量的叉积。\n  - 面面积 $\\;A_f=\\frac{1}{2}\\lVert n_f\\rVert\\;$。\n\n离散散度算子的组装：\n- 计算每个四面体 $\\;T\\;$ 的单元中心 $\\;c_{T}\\;$。\n- 确定面与单元的邻接关系：一个边界面属于一个四面体，一个内部面属于两个四面体。\n- 定义离散散度矩阵 $\\;D\\in\\mathbb{R}^{N_c\\times N_f}\\;$，其中 $\\;N_c=2\\;$ 是单元数量，$\\;N_f\\;$ 是面的数量。其元素由下式给出\n  $$\n  D_{T,f}=\\operatorname{sign}\\big(n_f\\cdot(c_f-c_T)\\big),\n  $$\n  即，如果所选的面法线向量指向单元 $\\;T\\;$ 的外部，则为 $+1$；如果指向内部，则为 $-1$。这种选择确保了对于由两个单元共享的面，符号相反，因此内部通量在单元散度求和中会相互抵消。\n\n未知数和矩阵：\n- 离散未知数 $\\;b\\in\\mathbb{R}^{N_f}\\;$ 表示穿过每个面的法向磁通量的面积分 $\\;B\\cdot n\\;$（即一个面通量余链）。无散度约束为 $\\;D\\,b=0\\;$。\n- 定义一个对角、对称正定矩阵 $\\;K\\in\\mathbb{R}^{N_f\\times N_f}\\;$，它使用面上的磁阻率对通量分量进行加权：\n  $$\n  K_{f,f}=\\nu_f\\,A_f,\\quad \\nu_f=\\frac{1}{\\mu_f},\n  $$\n  其中，面磁阻率 $\\;\\nu_f\\;$ 根据单元的 $\\;\\mu\\;$ 值构建如下：\n  - 如果面 $\\;f\\;$ 是与单个单元 $\\;T\\;$ 相邻的边界面，则设 $\\;\\mu_f=\\mu_T\\;$。\n  - 如果面 $\\;f\\;$ 是内部面，由单元 $\\;T_a\\;$ 和 $\\;T_b\\;$ 共享，则将 $\\;\\mu_f\\;$ 设为 $\\;\\mu_{T_a}\\;$ 和 $\\;\\mu_{T_b}\\;$ 的调和平均值，即\n    $$\n    \\mu_f=\\frac{2}{\\frac{1}{\\mu_{T_a}}+\\frac{1}{\\mu_{T_b}}},\\quad \\nu_f=\\frac{1}{\\mu_f}.\n    $$\n- 设 $\\;f\\in\\mathbb{R}^{N_f}\\;$ 为给定的面源向量（无量纲）。在没有约束的情况下，无约束最小化子为 $\\;b_0=K^{-1}f\\;$，其离散散度通常为非零，即 $\\;D\\,b_0\\neq 0\\;$。\n- 有约束的鞍点系统为\n  $$\n  \\begin{pmatrix}\n  K  D^\\top \\\\\n  D  0\n  \\end{pmatrix}\n  \\begin{pmatrix}\n  b \\\\\n  p\n  \\end{pmatrix}\n  =\n  \\begin{pmatrix}\n  f \\\\\n  0\n  \\end{pmatrix},\n  $$\n  其中 $\\;p\\in\\mathbb{R}^{N_c}\\;$ 是施加约束 $\\;D\\,b=0\\;$ 的拉格朗日乘子。\n\n算法要求：\n- 组装 $\\;D\\;$、$\\;K\\;$，并计算 $\\;b_0\\;$ 及其散度 $\\;D\\,b_0\\;$。\n- 使用舒尔补求解鞍点系统：\n  $$\n  S\\;p = D\\,K^{-1}\\,f,\\quad S=D\\,K^{-1}\\,D^\\top,\\quad b=K^{-1}\\big(f-D^\\top p\\big),\n  $$\n  其中 $K^{-1}$ 是 $K$ 的对角逆。验证 $\\;D\\,b\\;$（在数值舍入误差范围内）是零向量。\n\n测试套件：\n- 使用上述网格并定义三组参数集：\n  $1.$ 均匀情况：单元 $\\;T_0,T_1\\;$ 的 $\\;\\mu=[1,1]\\;$，源向量定义为边界面的 $\\;f_f=1\\;$，内部面的 $\\;f_f=0\\;$。\n  $2.$ 非均匀情况：$\\;\\mu=[1,4]\\;$，源向量规则相同，即边界面的 $\\;f_f=1\\;$，内部面的 $\\;f_f=0\\;$。\n  $3.$ 零源情况：$\\;\\mu=[1,1]\\;$，所有面的 $\\;f_f=0\\;$。\n- 对于每种情况，计算两个量：\n  - 两个单元上无约束离散散度的最大绝对值 $\\;\\max\\lvert D\\,b_0\\rvert\\;$。\n  - 两个单元上有约束离散散度的最大绝对值 $\\;\\max\\lvert D\\,b\\rvert\\;$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，各项按情况排序如下\n  $$\n  \\big[\\max\\lvert D\\,b_0\\rvert,\\;\\max\\lvert D\\,b\\rvert\\big]_{\\text{case }1},\\;\\big[\\max\\lvert D\\,b_0\\rvert,\\;\\max\\lvert D\\,b\\rvert\\big]_{\\text{case }2},\\;\\big[\\max\\lvert D\\,b_0\\rvert,\\;\\max\\lvert D\\,b\\rvert\\big]_{\\text{case }3}.\n  $$\n也就是说，最终输出应该是一个包含6个浮点数的列表：$\\;[\\text{before}_1,\\text{after}_1,\\text{before}_2,\\text{after}_2,\\text{before}_3,\\text{after}_3]\\;$。\n\n本问题中的所有量都是无量纲的，因此不需要进行物理单位转换。请通过使用所述的几何结构和组装方法来确保科学真实性，并且不要引入超出上述定义的任何人造或非物理系数。", "solution": "该问题要求在一个简单的四面体网格上，为静磁学问题构建并求解一个离散鞍点系统。该方法涉及有限体积离散化，其中磁通量与网格面相关联，而拉格朗日乘子与网格单元（四面体）相关联，用于施加对磁通量密度的无散度约束。解决方案将遵循问题陈述中概述的精确几何和代数步骤来实现。\n\n首先，我们定义网格几何结构。该网格由 $N_c=2$ 个四面体 $T_0$ 和 $T_1$ 组成，它们由 5 个顶点 $v_0$ 到 $v_4$ 构建。根据四面体的定义，$T_0=(v_0,v_1,v_2,v_3)$ 和 $T_1=(v_1,v_2,v_3,v_4)$，我们可以识别出唯一的三角形面集合。一个四面体有 4 个面。列出两个四面体的所有面后发现，它们共享一个公共面 $(v_1,v_2,v_3)$。因此，整个网格共有 $N_f=7$ 个唯一的面。我们通过按顶点索引递增的顺序存储每个面的顶点，为每个面建立一个规范表示。这得到面的集合：$f_0=(0,1,2)$、$f_1=(0,1,3)$、$f_2=(0,2,3)$、$f_3=(1,2,3)$、$f_4=(1,2,4)$、$f_5=(1,3,4)$ 和 $f_6=(2,3,4)$。面 $f_3$是内部面，而其他 6 个是边界面。\n\n接下来，我们计算每个面和单元所需的几何量。对于每个面 $f$，我们计算其中心 $c_f$ 作为其三个顶点的算术平均值。对于每个面，通过取其顶点（按索引排序）派生的两条边向量的叉积，计算出一个全局定向的、未归一化的法向量 $n_f$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and solves a magnetostatic saddle-point problem on a fixed\n    tetrahedral mesh for three different test cases.\n    \"\"\"\n\n    def setup_geometry():\n        \"\"\"\n        Defines the mesh vertices, tetrahedra, and faces.\n        Returns canonical lists and mappings for geometric entities.\n        \"\"\"\n        vertices = np.array([\n            [0, 0, 0],  # v0\n            [1, 0, 0],  # v1\n            [0, 1, 0],  # v2\n            [0, 0, 1],  # v3\n            [1, 1, 1],  # v4\n        ], dtype=float)\n\n        tets = np.array([[0, 1, 2, 3], [1, 2, 3, 4]], dtype=int)\n\n        tet_faces = [\n            [(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)],  # Faces of T0\n            [(1, 2, 4), (1, 3, 4), (2, 3, 4), (1, 2, 3)],  # Faces of T1\n        ]\n        \n        unique_faces_set = set()\n        for i_tet, tet in enumerate(tet_faces):\n            for face_verts in tet:\n                unique_faces_set.add(tuple(sorted(face_verts)))\n        \n        # Create a canonical ordering of faces\n        faces = sorted(list(unique_faces_set))\n        face_map = {face: i for i, face in enumerate(faces)}\n\n        face_to_cell_map = [[] for _ in range(len(faces))]\n        for i_tet, tet_face_list in enumerate(tet_faces):\n            for face_verts in tet_face_list:\n                face_id = face_map[tuple(sorted(face_verts))]\n                if i_tet not in face_to_cell_map[face_id]:\n                    face_to_cell_map[face_id].append(i_tet)\n\n        return vertices, tets, faces, face_to_cell_map\n\n    def compute_geometric_quantities(vertices, faces, tets):\n        \"\"\"\n        Computes face centroids, normals, areas, and cell centroids.\n        \"\"\"\n        num_faces = len(faces)\n        num_cells = len(tets)\n\n        face_centroids = np.zeros((num_faces, 3))\n        face_normals = np.zeros((num_faces, 3))\n        face_areas = np.zeros(num_faces)\n        for i, face_indices in enumerate(faces):\n            v = vertices[list(face_indices)]\n            face_centroids[i] = np.mean(v, axis=0)\n            \n            # Normal from cross product of edges based on sorted vertex indices\n            e1 = v[1] - v[0]\n            e2 = v[2] - v[0]\n            normal = np.cross(e1, e2)\n            face_normals[i] = normal\n            face_areas[i] = 0.5 * np.linalg.norm(normal)\n\n        cell_centroids = np.zeros((num_cells, 3))\n        for i, tet_indices in enumerate(tets):\n            cell_centroids[i] = np.mean(vertices[tet_indices], axis=0)\n\n        return face_centroids, face_normals, face_areas, cell_centroids\n\n    def assemble_divergence_matrix(num_cells, num_faces, faces, tets, face_to_cell_map, face_normals, face_centroids, cell_centroids):\n        \"\"\"\n        Assembles the discrete divergence matrix D.\n        \"\"\"\n        D = np.zeros((num_cells, num_faces))\n        for i_face in range(num_faces):\n            for i_cell in face_to_cell_map[i_face]:\n                # D_T,f = sign(n_f . (c_f - c_T))\n                vec_cf_ct = face_centroids[i_face] - cell_centroids[i_cell]\n                D[i_cell, i_face] = np.sign(np.dot(face_normals[i_face], vec_cf_ct))\n        return D\n\n    def run_simulation(case_params, D, face_areas, face_to_cell_map):\n        \"\"\"\n        Runs one simulation case: assembles K, f, solves, and returns results.\n        \"\"\"\n        num_faces = D.shape[1]\n        mu_cells = case_params['mu']\n        \n        # Assemble diagonal K matrix\n        K_diag = np.zeros(num_faces)\n        for i_face in range(num_faces):\n            adj_cells = face_to_cell_map[i_face]\n            if len(adj_cells) == 1: # Boundary face\n                mu_face = mu_cells[adj_cells[0]]\n            else: # Interior face\n                mu_face = 2.0 / (1.0/mu_cells[adj_cells[0]] + 1.0/mu_cells[adj_cells[1]])\n            \n            nu_face = 1.0 / mu_face\n            K_diag[i_face] = nu_face * face_areas[i_face]\n        \n        # Assemble source vector f\n        f_vec = np.zeros(num_faces)\n        if case_params['source'] == 'boundary':\n            for i_face in range(num_faces):\n                if len(face_to_cell_map[i_face]) == 1:\n                    f_vec[i_face] = 1.0\n        # For 'zero' source, f_vec remains zero.\n\n        # Unconstrained solution and its divergence\n        # Handle cases where K might have zero diagonals (if area is zero)\n        K_inv_diag = np.zeros_like(K_diag)\n        non_zero_mask = K_diag != 0\n        K_inv_diag[non_zero_mask] = 1.0 / K_diag[non_zero_mask]\n\n        b0 = K_inv_diag * f_vec\n        div_b0 = D @ b0\n        max_abs_div_b0 = np.max(np.abs(div_b0))\n\n        # Solve saddle-point system using Schur complement\n        # S p = D K^-1 f\n        # S = D K^-1 D^T\n        S = D @ np.diag(K_inv_diag) @ D.T\n        rhs_p = D @ b0\n\n        # Handle trivial case f=0\n        if np.all(rhs_p == 0):\n            p = np.zeros(D.shape[0])\n        else:\n            p = np.linalg.solve(S, rhs_p)\n\n        # Back-substitute for b\n        # b = K^-1 (f - D^T p)\n        b = K_inv_diag * (f_vec - D.T @ p)\n        div_b = D @ b\n        max_abs_div_b = np.max(np.abs(div_b))\n        \n        return max_abs_div_b0, max_abs_div_b\n\n    # --- Main execution logic ---\n    \n    # 1. Setup mesh and geometry\n    vertices, tets, faces, face_to_cell_map = setup_geometry()\n    face_centroids, face_normals, face_areas, cell_centroids = compute_geometric_quantities(vertices, faces, tets)\n    \n    num_cells = len(tets)\n    num_faces = len(faces)\n    \n    # 2. Assemble divergence matrix D\n    D = assemble_divergence_matrix(num_cells, num_faces, faces, tets, face_to_cell_map, face_normals, face_centroids, cell_centroids)\n\n    # 3. Define and run test cases\n    test_cases = [\n        {'mu': [1.0, 1.0], 'source': 'boundary'},  # Case 1\n        {'mu': [1.0, 4.0], 'source': 'boundary'},  # Case 2\n        {'mu': [1.0, 1.0], 'source': 'zero'},      # Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        b0_div, b_div = run_simulation(case, D, face_areas, face_to_cell_map)\n        results.extend([b0_div, b_div])\n\n    # 4. Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3525101"}]}