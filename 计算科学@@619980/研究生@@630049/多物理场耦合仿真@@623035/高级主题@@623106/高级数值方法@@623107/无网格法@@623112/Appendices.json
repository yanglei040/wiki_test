{"hands_on_practices": [{"introduction": "光滑核函数是光滑粒子流体动力学（SPH）方法的基石。为了确保最基本的数值精度，即零阶一致性，核函数必须满足归一化条件。本练习将指导您为一个广泛应用的光滑核函数推导其归一化常数，从而加深您对SPH连续积分形式与离散应用之间内在联系的理解。[@problem_id:3514916]", "problem": "在光滑粒子流体动力学 (SPH) 中，场近似能够精确重构一个常数场，当且仅当其光滑核函数满足从质量守恒和单位分解推导出的归一化条件，即核函数在整个定义域上的积分为 $1$。对于一个在 $3$ 维空间中进行的多物理场耦合模拟，需要一个紧支集、正值且二阶连续可微的核函数来控制噪声并确保耦合的稳定性，考虑由下式定义的各向同性核函数\n$$\nW(\\mathbf{r}, h) \\;=\\; C\\, h^{-3}\\, f\\!\\left(q\\right), \\quad q \\;=\\; \\frac{\\|\\mathbf{r}\\|}{h},\n$$\n其紧支集为 $q \\in [0,2]$，且\n$$\nf(q) \\;=\\; \\begin{cases}\n\\left(1 - \\dfrac{q}{2}\\right)^{4}\\,\\left(2 q + 1\\right),  0 \\le q \\le 2, \\\\\n0,  q > 2.\n\\end{cases}\n$$\n假设 $h>0$，且 $W(\\mathbf{r},h)$ 是径向对称的，并在 $\\mathbb{R}^{3}$ 中使用。仅从SPH近似能够精确重构常数场的要求（这意味着核函数需满足归一化条件 $\\int_{\\mathbb{R}^{3}} W(\\mathbf{r},h)\\, \\mathrm{d}V = 1$）出发，确定归一化常数 $C$ 的精确解析表达式，以使该条件在 $3$ 维空间中成立。请以闭式表达式给出最终答案，不要对结果进行四舍五入。", "solution": "根据规定标准对问题进行验证。\n\n### 第一步：提取已知条件\n- **方法**：光滑粒子流体动力学 (SPH)\n- **维度**：$3$ 维空间，$\\mathbb{R}^{3}$。\n- **核函数定义**：各向同性核函数由 $W(\\mathbf{r}, h) = C h^{-3} f(q)$ 给出，其中 $q = \\frac{\\|\\mathbf{r}\\|}{h}$ 且 $h  0$。\n- **核函数方程**：\n$$\nf(q) = \\begin{cases}\n\\left(1 - \\dfrac{q}{2}\\right)^{4}\\,\\left(2 q + 1\\right),  0 \\le q \\le 2 \\\\\n0,  q > 2\n\\end{cases}\n$$\n- **核函数性质**：紧支集、正值、二阶连续可微。\n- **基本条件**：为确保零阶一致性（精确重构常数场），核函数必须归一化为1。这由积分条件表示：$\\int_{\\mathbb{R}^{3}} W(\\mathbf{r},h)\\, \\mathrm{d}V = 1$。\n- **目标**：确定归一化常数 $C$ 的精确解析表达式。\n\n### 第二步：使用提取的已知条件进行验证\n1.  **科学依据**：该问题在SPH的基本理论中有充分的依据。归一化条件 $\\int W \\, \\mathrm{d}V = 1$ 是确保单位分解的标准要求，而单位分解是实现零阶精度的必要条件。给定的核函数是一个具有紧支集的多项式，这是SPH中为提高计算效率和稳定性而常用的选择。关于其二阶连续可微的论断是可验证且正确的，这确保了场变量及其导数的光滑近似。该问题在科学上是合理的。\n2.  **适定性**：该问题要求解一个由单一积分约束决定的未知常数 $C$。核函数 $f(q)$ 在 $q \\in [0, 2)$ 上严格为正，这保证了其积分为一个正的非零值。因此，存在一个唯一的、适定的 $C$ 的解。\n3.  **客观性**：问题陈述使用了精确的数学语言，没有任何歧义或主观内容。\n4.  **完备性与一致性**：所有必要信息——核函数的形式、其支集、空间维度以及归一化条件——均已提供。不存在矛盾之处。\n\n### 第三步：结论与行动\n该问题是 **有效的**。这是一个计算物理学中标准的、适定的问题。我现在将进行求解。\n\n求解始于 SPH 核函数在 $3$ 维空间中的基本归一化条件：\n$$\n\\int_{\\mathbb{R}^3} W(\\mathbf{r}, h) \\, \\mathrm{d}V = 1\n$$\n代入给定的核函数形式 $W(\\mathbf{r}, h) = C h^{-3} f\\left(\\frac{\\|\\mathbf{r}\\|}{h}\\right)$，我们得到：\n$$\n\\int_{\\mathbb{R}^3} C h^{-3} f\\left(\\frac{\\|\\mathbf{r}\\|}{h}\\right) \\, \\mathrm{d}V = 1\n$$\n常数项 $C h^{-3}$ 可以从积分中提出：\n$$\nC h^{-3} \\int_{\\mathbb{R}^3} f\\left(\\frac{\\|\\mathbf{r}\\|}{h}\\right) \\, \\mathrm{d}V = 1\n$$\n被积函数是径向对称的，因为它只依赖于模长 $\\|\\mathbf{r}\\|$。这提示我们转换到球坐标系。令 $r = \\|\\mathbf{r}\\|$。球坐标系中的体积元为 $\\mathrm{d}V = r^2 \\sin(\\theta) \\, \\mathrm{d}r \\, \\mathrm{d}\\theta \\, \\mathrm{d}\\phi$。积分变为：\n$$\nC h^{-3} \\int_0^{2\\pi} \\int_0^\\pi \\int_0^\\infty f\\left(\\frac{r}{h}\\right) r^2 \\sin(\\theta) \\, \\mathrm{d}r \\, \\mathrm{d}\\theta \\, \\mathrm{d}\\phi = 1\n$$\n对角度变量的积分可以独立进行：\n$$\n\\int_0^{2\\pi} \\int_0^\\pi \\sin(\\theta) \\, \\mathrm{d}\\theta \\, \\mathrm{d}\\phi = \\int_0^{2\\pi} [-\\cos(\\theta)]_0^\\pi \\, \\mathrm{d}\\phi = \\int_0^{2\\pi} (-(-1) - (-1)) \\, \\mathrm{d}\\phi = \\int_0^{2\\pi} 2 \\, \\mathrm{d}\\phi = 4\\pi\n$$\n代入此结果，归一化条件简化为：\n$$\n4\\pi C h^{-3} \\int_0^\\infty r^2 f\\left(\\frac{r}{h}\\right) \\, \\mathrm{d}r = 1\n$$\n函数 $f(q)$ 的紧支集为 $q \\in [0, 2]$。由于 $q = r/h$，被积函数仅在 $r/h \\le 2$ 时非零，即 $r \\le 2h$。因此，我们可以将积分上限从 $\\infty$ 改为 $2h$：\n$$\n4\\pi C h^{-3} \\int_0^{2h} r^2 f\\left(\\frac{r}{h}\\right) \\, \\mathrm{d}r = 1\n$$\n为了计算剩余的积分，我们进行变量替换，换为无量纲距离 $q = r/h$。这意味着 $r = qh$ 和 $\\mathrm{d}r = h \\, \\mathrm{d}q$。$q$ 的积分限为从 $0$ 到 $2$。\n$$\n4\\pi C h^{-3} \\int_0^2 (qh)^2 f(q) (h \\, \\mathrm{d}q) = 1\n$$\n$$\n4\\pi C h^{-3} \\int_0^2 q^2 h^2 f(q) h \\, \\mathrm{d}q = 1\n$$\n从积分中提出 $h$ 项：\n$$\n4\\pi C h^{-3} h^3 \\int_0^2 q^2 f(q) \\, \\mathrm{d}q = 1\n$$\n正如预期的那样，$h$ 因子相互抵消，表明归一化与光滑长度无关：\n$$\n4\\pi C \\int_0^2 q^2 f(q) \\, \\mathrm{d}q = 1\n$$\n现在，我们必须计算积分 $I = \\int_0^2 q^2 f(q) \\, \\mathrm{d}q$。代入 $f(q)$ 的表达式：\n$$\nI = \\int_0^2 q^2 \\left(1 - \\frac{q}{2}\\right)^4 (2q + 1) \\, \\mathrm{d}q\n$$\n为简化此积分，我们引入换元 $u = 1 - q/2$。由此可得 $q = 2(1 - u)$ 和 $\\mathrm{d}q = -2 \\, \\mathrm{d}u$。积分限变化如下：当 $q=0$ 时，$u=1$；当 $q=2$ 时，$u=0$。\n$$\nI = \\int_1^0 [2(1-u)]^2 (u)^4 [2(2(1-u)) + 1] (-2 \\, \\mathrm{d}u)\n$$\n反转积分限可以消掉来自 $-2 \\, \\mathrm{d}u$ 的负号：\n$$\nI = \\int_0^1 4(1-u)^2 u^4 (4 - 4u + 1) (2 \\, \\mathrm{d}u)\n$$\n$$\nI = 8 \\int_0^1 (1-2u+u^2) u^4 (5-4u) \\, \\mathrm{d}u\n$$\n展开积分内的多项式：\n$$\nI = 8 \\int_0^1 (u^4 - 2u^5 + u^6) (5 - 4u) \\, \\mathrm{d}u\n$$\n$$\nI = 8 \\int_0^1 (5u^4 - 10u^5 + 5u^6 - 4u^5 + 8u^6 - 4u^7) \\, \\mathrm{d}u\n$$\n合并同类项：\n$$\nI = 8 \\int_0^1 (5u^4 - 14u^5 + 13u^6 - 4u^7) \\, \\mathrm{d}u\n$$\n现在我们可以逐项对该多项式进行积分：\n$$\nI = 8 \\left[ \\frac{5u^5}{5} - \\frac{14u^6}{6} + \\frac{13u^7}{7} - \\frac{4u^8}{8} \\right]_0^1\n$$\n$$\nI = 8 \\left[ u^5 - \\frac{7}{3}u^6 + \\frac{13}{7}u^7 - \\frac{1}{2}u^8 \\right]_0^1\n$$\n在积分限 $u=1$ 和 $u=0$ 处计算表达式的值：\n$$\nI = 8 \\left( \\left(1 - \\frac{7}{3} + \\frac{13}{7} - \\frac{1}{2}\\right) - (0) \\right)\n$$\n为了对分数求和，我们找到公分母，即 $3 \\times 7 \\times 2 = 42$：\n$$\nI = 8 \\left( \\frac{42}{42} - \\frac{7 \\times 14}{42} + \\frac{13 \\times 6}{42} - \\frac{21}{42} \\right)\n$$\n$$\nI = 8 \\left( \\frac{42 - 98 + 78 - 21}{42} \\right) = 8 \\left( \\frac{120 - 119}{42} \\right) = 8 \\left( \\frac{1}{42} \\right) = \\frac{4}{21}\n$$\n找到了积分 $I$ 的值，我们现在可以求解归一化常数 $C$。归一化条件是 $4\\pi C I = 1$。\n$$\n4\\pi C \\left(\\frac{4}{21}\\right) = 1\n$$\n$$\n\\frac{16\\pi C}{21} = 1\n$$\n求解 $C$：\n$$\nC = \\frac{21}{16\\pi}\n$$\n这就是在 $3$ 维空间中归一化常数的精确解析表达式。", "answer": "$$\\boxed{\\frac{21}{16\\pi}}$$", "id": "3514916"}, {"introduction": "理论的生命力在于实践。本练习将引导您将抽象的SPH方程转化为一个可运行的程序，用于模拟多相流体系统。这是一个经典的SPH应用领域，无网格方法在追踪复杂自由表面和相界面方面表现出巨大优势，您将通过亲手实现密度计算、界面法向和曲率估计等核心算子，来模拟表面张力效应。[@problem_id:3514918]", "problem": "您的任务是实现一个二维简化的光滑粒子流体动力学（SPH）模型，重点关注多相相互作用和自由表面检测，该模型植根于守恒定律和无网格SPH近似。目标是为几种测试配置计算两个指标：被检测为自由表面粒子的比例和界面粒子上毛细加速度的平均大小。您的实现必须是一个完整的、可运行的程序，并遵循下面指定的最终输出格式。\n\n其基本原理包括标准的连续介质力学和SPH定义。从质量和动量守恒开始，然后采用SPH近似来离散化相关场。使用以下标准且经过充分测试的组件和事实：\n\n- 光滑粒子流体动力学（SPH）通过对粒子进行核函数加权求和来近似场 $f(\\mathbf{x})$。在密度求和形式中，粒子 $i$ 处的质量密度为\n$$\n\\rho_i = \\sum_{j} m_j \\, W\\!\\left(\\|\\mathbf{r}_i - \\mathbf{r}_j\\|, h\\right),\n$$\n其中 $\\rho_i$ 是质量密度， $m_j$ 是粒子 $j$ 的质量， $W$ 是光滑核函数， $h$ 是光滑长度， $\\mathbf{r}_i$ 表示位置。\n\n- 使用具有紧支集 $2h$ 的二维三次样条核函数：\n$$\nW(q,h) = \\alpha_{2D} \\times \\begin{cases}\n1 - \\frac{3}{2} q^2 + \\frac{3}{4} q^3,  0 \\le q  1, \\\\\n\\frac{1}{4}(2 - q)^3,  1 \\le q  2, \\\\\n0,  q \\ge 2,\n\\end{cases}\n$$\n其中 $q = \\frac{r}{h}$，$r = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$，且 $\\alpha_{2D} = \\frac{10}{7 \\pi h^2}$。\n\n- 核函数的梯度为\n$$\n\\nabla W(\\mathbf{r},h) = \\frac{d W}{d r}(r,h)\\, \\hat{\\mathbf{r}}, \\quad \\hat{\\mathbf{r}} = \\frac{\\mathbf{r}}{\\|\\mathbf{r}\\|},\n$$\n其中\n$$\n\\frac{dW}{dr}(r,h) = \\frac{1}{h} \\frac{dW}{dq}(q,h), \\quad \\frac{dW}{dq}(q,h) = \\alpha_{2D}\\times\n\\begin{cases}\n-3 q + \\frac{9}{4} q^2,  0 \\le q  1, \\\\\n-\\frac{3}{4}(2 - q)^2,  1 \\le q  2, \\\\\n0,  q \\ge 2.\n\\end{cases}\n$$\n\n- 自由表面检测基于核函数梯度和的梯度亏损判据。定义\n$$\n\\mathbf{S}_i = \\sum_j \\frac{m_j}{\\rho_j} \\, \\nabla W(\\mathbf{r}_i - \\mathbf{r}_j, h).\n$$\n如果 $ \\|\\mathbf{S}_i\\|  \\frac{\\lambda}{h} $，则粒子 $i$ 被标记为自由表面粒子，其中 $\\lambda$ 是下面提供的无量纲阈值。\n\n- 对于多相系统，设相指示函数（颜色函数）为 $c_i \\in \\{0,1\\}$，其中 $c_i = 1$ 表示A相，$c_i = 0$ 表示B相。通过以下方式估计颜色梯度\n$$\n\\nabla c_i = \\sum_j \\frac{m_j}{\\rho_j} \\left(c_j - c_i\\right) \\nabla W(\\mathbf{r}_i - \\mathbf{r}_j, h).\n$$\n使用一个小的正则化项 $\\epsilon$ 来定义单位法向量，以避免除以零：\n$$\n\\hat{\\mathbf{n}}_i = \\frac{\\nabla c_i}{\\|\\nabla c_i\\| + \\epsilon}.\n$$\n\n- 用于毛细作用的连续表面力模型得出粒子 $i$ 处的毛细加速度：\n$$\n\\mathbf{a}_i^{\\sigma} = \\frac{\\sigma}{\\rho_i} \\, \\kappa_i \\, \\hat{\\mathbf{n}}_i,\n$$\n其中 $\\sigma$ 是界面表面张力系数（单位：牛顿/米），$\\kappa_i$ 是由单位法向量的散度近似的曲率\n$$\n\\kappa_i = - \\nabla \\cdot \\hat{\\mathbf{n}}_i.\n$$\n对散度使用以下一致的SPH离散格式：\n$$\n\\nabla \\cdot \\hat{\\mathbf{n}}_i \\approx \\frac{1}{\\rho_i} \\sum_j m_j \\left(\\hat{\\mathbf{n}}_j - \\hat{\\mathbf{n}}_i\\right)\\cdot \\nabla W(\\mathbf{r}_i - \\mathbf{r}_j, h).\n$$\n因此\n$$\n\\kappa_i \\approx -\\frac{1}{\\rho_i} \\sum_j m_j \\left(\\hat{\\mathbf{n}}_j - \\hat{\\mathbf{n}}_i\\right)\\cdot \\nabla W(\\mathbf{r}_i - \\mathbf{r}_j, h),\n$$\n毛细加速度的大小为\n$$\n\\left\\|\\mathbf{a}_i^{\\sigma}\\right\\| = \\frac{\\sigma}{\\rho_i} \\left| \\kappa_i \\right|.\n$$\n\n实现要求：\n- 粒子 i 的质量必须使用 $m_i = \\rho_{0,i} \\Delta A$ 计算，其中 $\\rho_{0,i}$ 是该粒子相的静止密度，$\\Delta A = \\Delta x^2$ 是与二维粒子间距 $\\Delta x$ 相关的面积。\n- 使用二维位置和上述核函数定义。\n- 所有物理量必须采用国际单位制（SI）处理：位置单位为米（m），质量密度单位为千克/立方米（kg/m$^3$），光滑长度单位为米（m），表面张力单位为牛顿/米（N/m），加速度单位为米/秒^2（m/s$^2$）。\n- 自由表面粒子的比例必须是小数。平均毛细加速度必须以 m/s$^2$ 表示。\n\n测试套件：\n为以下三种情况中的每一种计算两个指标。在每种情况下，报告：\n- 自由表面粒子的比例（0到1之间的小数）。\n- 界面粒子（定义为 $\\|\\nabla c_i\\|  g_{\\text{thr}}$ 的粒子）中毛细加速度的平均大小。\n\n所有案例中使用的全局参数：\n- 光滑长度 $h = 0.075$ m。\n- 粒子间距 $\\Delta x = 0.05$ m，因此 $\\Delta A = (\\Delta x)^2$。\n- 自由表面阈值参数 $\\lambda = 0.6$。\n- 界面梯度阈值 $g_{\\text{thr}} = \\frac{0.1}{h}$。\n- 归一化正则化项 $\\epsilon = 10^{-12}$。\n\n案例 1（两相界面，中等密度比）：\n- A相静止密度 $\\rho_{0,A} = 1000$ kg/m$^3$，B相静止密度 $\\rho_{0,B} = 800$ kg/m$^3$。\n- 表面张力 $\\sigma = 0.072$ N/m。\n- 粒子位置（单位：米）和相：\n  - A相 ($c = 1$): $\\{(-0.05,-0.05), \\, (-0.05,0.0), \\, (-0.05,0.05)\\}$。\n  - B相 ($c = 0$): $\\{(0.05,-0.05), \\, (0.05,0.0), \\, (0.05,0.05)\\}$。\n\n案例 2（具有自由表面的单相簇，无表面张力）：\n- 单一A相静止密度 $\\rho_{0,A} = 1000$ kg/m$^3$，$\\sigma = 0.0$ N/m。\n- 粒子位置（单位：米），所有粒子 $c = 1$：\n  - $\\{(-0.05,-0.05), \\, (-0.05,0.05), \\, (0.05,-0.05), \\, (0.05,0.05)\\}$。\n\n案例 3（两相界面，极端密度比）：\n- A相静止密度 $\\rho_{0,A} = 1000$ kg/m$^3$，B相静止密度 $\\rho_{0,B} = 100$ kg/m$^3$。\n- 表面张力 $\\sigma = 0.02$ N/m。\n- 粒子位置（单位：米）和相：\n  - A相 ($c = 1$): $\\{(-0.05,-0.05), \\, (-0.05,0.0), \\, (-0.05,0.05)\\}$。\n  - B相 ($c = 0$): $\\{(0.05,-0.05), \\, (0.05,0.0), \\, (0.05,0.05)\\}$。\n\n答案规范：\n- 对于每个案例，计算自由表面粒子的比例和界面粒子上毛细加速度大小的平均值。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序如下：\n$$\n[\\text{fs\\_frac\\_case1}, \\text{avg\\_cap\\_acc\\_case1}, \\text{fs\\_frac\\_case2}, \\text{avg\\_cap\\_acc\\_case2}, \\text{fs\\_frac\\_case3}, \\text{avg\\_cap\\_acc\\_case3}]\n$$\n所有加速度单位必须为 m/s$^2$，所有比例必须为小数。", "solution": "用户提供了一个基于光滑粒子流体动力学（SPH）原理的计算物理问题。任务是为三种不同的粒子配置计算两个特定指标：自由表面粒子的比例和界面粒子上的平均毛细加速度。该问题是自洽的、科学上合理的、适定的，提供了所有必要的方程、常数和初始条件。\n\n解决方案将通过对每个测试案例遵循一个顺序的、多步骤的计算过程来实现，该过程由所提供的SPH公式中的依赖关系决定。\n\n首先，定义全局参数：光滑长度 $h$、粒子间距 $\\Delta x$、自由表面阈值参数 $\\lambda$、界面梯度阈值 $g_{\\text{thr}}$ 和一个小的正则化常数 $\\epsilon$。每个测试案例的粒子属性（位置、静止密度 $\\rho_0$ 和表面张力系数 $\\sigma$）也已定义。\n\n每个案例的计算工作流程如下：\n\n1.  **粒子质量初始化**：对于每个粒子 $i$，其质量 $m_i$ 根据其相特定的静止密度 $\\rho_{0,i}$ 和统一的粒子面积 $\\Delta A = (\\Delta x)^2$ 计算：\n    $$\n    m_i = \\rho_{0,i} \\Delta A\n    $$\n\n2.  **密度计算**：每个粒子 $i$ 的质量密度 $\\rho_i$ 通过对所有粒子 $j$（包括 $j=i$）的SPH求和计算：\n    $$\n    \\rho_i = \\sum_{j} m_j W(\\|\\mathbf{r}_i - \\mathbf{r}_j\\|, h)\n    $$\n    其中 $W$ 是指定的二维三次样条核函数，其归一化常数为 $\\alpha_{2D} = \\frac{10}{7 \\pi h^2}$。此步骤必须对所有粒子完成后才能继续，因为后续计算依赖于这些密度值。\n\n3.  **中间向量计算**：在此步骤中，为每个粒子 $i$ 计算两个关键向量。这些计算依赖于先前计算出的密度 $\\rho_j$。\n    \n    a. **自由表面向量**：计算用于自由表面检测的向量 $\\mathbf{S}_i$。其大小表示粒子分布的局部不对称性。\n    $$\n    \\mathbf{S}_i = \\sum_{j} \\frac{m_j}{\\rho_j} \\nabla W(\\mathbf{r}_i - \\mathbf{r}_j, h)\n    $$\n    \n    b. **颜色梯度**：计算相指示（颜色）函数的梯度 $\\nabla c_i$。该向量对于识别相间界面至关重要。\n    $$\n    \\nabla c_i = \\sum_{j} \\frac{m_j}{\\rho_j} (c_j - c_i) \\nabla W(\\mathbf{r}_i - \\mathbf{r}_j, h)\n    $$\n    核函数的梯度 $\\nabla W$ 指向从粒子 $j$ 到 $i$ 的方向，并使用提供的导数公式计算。求和是对所有邻居 $j$进行的，其中 $j=i$ 的项贡献为零。\n\n4.  **法向量计算**：使用颜色梯度，为每个粒子计算一个单位法向量 $\\hat{\\mathbf{n}}_i$。在分母中加入一个小的正则化项 $\\epsilon$，以防止对于远离任何界面且 $\\|\\nabla c_i\\|$ 可能为零的粒子出现除以零的情况。\n    $$\n    \\hat{\\mathbf{n}}_i = \\frac{\\nabla c_i}{\\|\\nabla c_i\\| + \\epsilon}\n    $$\n    在计算曲率之前，必须为所有粒子计算这些法向量。\n\n5.  **曲率计算**：使用法向量场的散度的SPH近似来估计界面曲率 $\\kappa_i$。\n    $$\n    \\kappa_i \\approx -\\frac{1}{\\rho_i} \\sum_j m_j (\\hat{\\mathbf{n}}_j - \\hat{\\mathbf{n}}_i) \\cdot \\nabla W(\\mathbf{r}_i - \\mathbf{r}_j, h)\n    $$\n    此计算需要邻近粒子的法向量 $\\hat{\\mathbf{n}}_j$，这说明了算法的顺序性。\n\n6.  **毛细加速度计算**：每个粒子的毛细加速度大小 $\\|\\mathbf{a}_i^{\\sigma}\\|$ 使用表面张力系数 $\\sigma$、粒子密度 $\\rho_i$ 和其曲率的绝对值 $|\\kappa_i|$ 来确定。\n    $$\n    \\|\\mathbf{a}_i^{\\sigma}\\| = \\frac{\\sigma}{\\rho_i} |\\kappa_i|\n    $$\n\n7.  **指标计算**：最后，为整个粒子系统计算所需的两个指标。\n    \n    a. **自由表面分数**：如果 $\\|\\mathbf{S}_i\\|  \\frac{\\lambda}{h}$，则每个粒子 $i$ 被分类为自由表面粒子。此类粒子的总数除以系统中的粒子总数得到该分数。\n    \n    b. **平均毛细加速度**：如果 $\\|\\nabla c_i\\|  g_{\\text{thr}}$，则每个粒子 $i$ 被分类为界面粒子。然后在所有已识别的界面粒子集合上计算 $\\|\\mathbf{a}_i^{\\sigma}\\|$ 的平均值。如果没有找到界面粒子（如在单相系统中），则平均值取为0。\n\n对问题中指定的三个测试案例中的每一个重复这整个过程，并收集六个结果值用于最终输出。该实现将使用 `numpy` 进行高效的向量和矩阵运算。鉴于粒子数量较少（$N \\le 6$），用于成对相互作用的嵌套循环在计算上开销不大，并能确保直接清晰地实现求和公式。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SPH problem for three test cases and prints the results.\n    \"\"\"\n    # Global parameters\n    h = 0.075  # Smoothing length in m\n    dx = 0.05  # Particle spacing in m\n    dA = dx**2  # Particle area in m^2\n    lambda_fs = 0.6  # Free-surface threshold parameter\n    g_thr = 0.1 / h  # Interface gradient threshold\n    epsilon = 1e-12  # Regularization for normal vector\n    alpha_2d = 10.0 / (7.0 * np.pi * h**2)\n\n    # Test cases\n    test_cases = [\n        {\n            \"name\": \"Case 1: Two-phase, moderate density ratio\",\n            \"particles\": [\n                # Phase A (c=1)\n                {\"pos\": [-0.05, -0.05], \"rho0\": 1000.0, \"c\": 1},\n                {\"pos\": [-0.05, 0.0], \"rho0\": 1000.0, \"c\": 1},\n                {\"pos\": [-0.05, 0.05], \"rho0\": 1000.0, \"c\": 1},\n                # Phase B (c=0)\n                {\"pos\": [0.05, -0.05], \"rho0\": 800.0, \"c\": 0},\n                {\"pos\": [0.05, 0.0], \"rho0\": 800.0, \"c\": 0},\n                {\"pos\": [0.05, 0.05], \"rho0\": 800.0, \"c\": 0},\n            ],\n            \"sigma\": 0.072,\n        },\n        {\n            \"name\": \"Case 2: Single-phase cluster\",\n            \"particles\": [\n                {\"pos\": [-0.05, -0.05], \"rho0\": 1000.0, \"c\": 1},\n                {\"pos\": [-0.05, 0.05], \"rho0\": 1000.0, \"c\": 1},\n                {\"pos\": [0.05, -0.05], \"rho0\": 1000.0, \"c\": 1},\n                {\"pos\": [0.05, 0.05], \"rho0\": 1000.0, \"c\": 1},\n            ],\n            \"sigma\": 0.0,\n        },\n        {\n            \"name\": \"Case 3: Two-phase, extreme density ratio\",\n            \"particles\": [\n                # Phase A (c=1)\n                {\"pos\": [-0.05, -0.05], \"rho0\": 1000.0, \"c\": 1},\n                {\"pos\": [-0.05, 0.0], \"rho0\": 1000.0, \"c\": 1},\n                {\"pos\": [-0.05, 0.05], \"rho0\": 1000.0, \"c\": 1},\n                # Phase B (c=0)\n                {\"pos\": [0.05, -0.05], \"rho0\": 100.0, \"c\": 0},\n                {\"pos\": [0.05, 0.0], \"rho0\": 100.0, \"c\": 0},\n                {\"pos\": [0.05, 0.05], \"rho0\": 100.0, \"c\": 0},\n            ],\n            \"sigma\": 0.02,\n        },\n    ]\n\n    def kernel_W(r, h_val):\n        q = r / h_val\n        if q >= 2.0:\n            return 0.0\n        elif q >= 1.0:\n            return alpha_2d * 0.25 * (2.0 - q)**3\n        else: # 0 = q  1\n            return alpha_2d * (1.0 - 1.5 * q**2 + 0.75 * q**3)\n\n    def grad_W_factor(r, h_val):\n        # This returns the magnitude of the gradient dW/dr.\n        # The full gradient vector is (dW/dr) * (r_vec / r)\n        q = r / h_val\n        if r  1e-12: # Avoid division by zero\n            return 0.0\n        \n        factor_dq = 0.0\n        if q >= 2.0:\n            factor_dq = 0.0\n        elif q >= 1.0:\n            factor_dq = alpha_2d * (-0.75 * (2.0 - q)**2)\n        else: # 0 = q  1\n            factor_dq = alpha_2d * (-3.0 * q + 2.25 * q**2)\n\n        return (1.0 / h_val) * factor_dq\n\n    def process_case(case_data):\n        n_particles = len(case_data[\"particles\"])\n        sigma = case_data[\"sigma\"]\n        \n        # Unpack particle data into numpy arrays\n        pos = np.array([p[\"pos\"] for p in case_data[\"particles\"]])\n        rho0 = np.array([p[\"rho0\"] for p in case_data[\"particles\"]])\n        c = np.array([p[\"c\"] for p in case_data[\"particles\"]])\n        \n        # 1. Particle Mass\n        m = rho0 * dA\n\n        # 2. Density Calculation\n        rho = np.zeros(n_particles, dtype=np.float64)\n        for i in range(n_particles):\n            for j in range(n_particles):\n                r_ij_vec = pos[i] - pos[j]\n                r_ij = np.linalg.norm(r_ij_vec)\n                rho[i] += m[j] * kernel_W(r_ij, h)\n\n        # 3. S-vector and Color Gradient\n        S_vec = np.zeros((n_particles, 2), dtype=np.float64)\n        grad_c = np.zeros((n_particles, 2), dtype=np.float64)\n\n        for i in range(n_particles):\n            for j in range(n_particles):\n                if i == j:\n                    continue\n                r_ij_vec = pos[i] - pos[j]\n                r_ij = np.linalg.norm(r_ij_vec)\n                \n                if r_ij > 1e-12 and r_ij  2.0 * h:\n                    grad_W_mag = grad_W_factor(r_ij, h)\n                    grad_W_ij = grad_W_mag * (r_ij_vec / r_ij)\n                    \n                    S_vec[i] += (m[j] / rho[j]) * grad_W_ij\n                    grad_c[i] += (m[j] / rho[j]) * (c[j] - c[i]) * grad_W_ij\n\n        # 4. Normal Vector\n        n_hat = np.zeros((n_particles, 2), dtype=np.float64)\n        grad_c_mag = np.linalg.norm(grad_c, axis=1)\n        \n        # Avoid division by zero where grad_c_mag is small\n        mask = grad_c_mag > 1e-12\n        n_hat[mask] = grad_c[mask] / (grad_c_mag[mask, np.newaxis] + epsilon)\n\n        # 5. Curvature\n        kappa = np.zeros(n_particles, dtype=np.float64)\n        for i in range(n_particles):\n            for j in range(n_particles):\n                if i == j:\n                    continue\n                r_ij_vec = pos[i] - pos[j]\n                r_ij = np.linalg.norm(r_ij_vec)\n                if r_ij > 1e-12 and r_ij  2.0 * h:\n                    grad_W_mag = grad_W_factor(r_ij, h)\n                    grad_W_ij = grad_W_mag * (r_ij_vec / r_ij)\n                    kappa[i] -= (m[j] / rho[i]) * np.dot(n_hat[j] - n_hat[i], grad_W_ij)\n\n        # 6. Capillary Acceleration\n        acc_mag_cap = (sigma / rho) * np.abs(kappa)\n\n        # 7. Metrics Computation\n        # Free-surface fraction\n        S_mag = np.linalg.norm(S_vec, axis=1)\n        is_free_surface = S_mag > (lambda_fs / h)\n        fs_frac = np.sum(is_free_surface) / n_particles\n        \n        # Average capillary acceleration\n        is_interfacial = grad_c_mag > g_thr\n        interfacial_particles_indices = np.where(is_interfacial)[0]\n        \n        if len(interfacial_particles_indices) > 0:\n            avg_cap_acc = np.mean(acc_mag_cap[interfacial_particles_indices])\n        else:\n            avg_cap_acc = 0.0\n\n        return fs_frac, avg_cap_acc\n\n    results = []\n    for case in test_cases:\n        fs_frac, avg_cap_acc = process_case(case)\n        results.extend([fs_frac, avg_cap_acc])\n\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "3514918"}, {"introduction": "除了基于显式力计算的弱可压模型外，精确模拟不可压缩流体需要更先进的算法。本练习将介绍一种关键的进阶技术：基于压力投影的不可压缩SPH（ISPH）方法。您将学习如何推导并实现压力泊松方程，通过求解一个线性系统来严格执行速度场的无散度约束，这是模拟水等不可压缩流体时不可或缺的核心步骤。[@problem_id:3514925]", "problem": "考虑光滑粒子流体动力学（SPH）的不可压缩极限，其中速度场通过施加无散约束的投影进行更新。从牛顿流体的基本守恒定律出发：质量守恒和线性动量守恒。在不可压缩极限下，质量守恒要求速度场是无散的。利用这些原理来论证压力投影方法，在该方法中，一个中间速度通过压力梯度进行修正，以使修正后的速度满足无散约束。使用以下具体、完全指定的设置来推导离散化并实现它。\n\n你将在长度为 $L = 1$ 的周期性一维空间域中工作（全文使用无量纲单位；无物理单位）。设 $N$ 个粒子均匀分布，其位置为 $x_i = \\left(i + \\frac{1}{2}\\right) \\Delta x$，其中 $i = 0, 1, \\dots, N-1$，且 $\\Delta x = 1/N$。假设密度恒为 $\\rho = 1$，粒子质量均匀为 $m = \\Delta x$。设光滑长度为 $h = \\kappa \\Delta x$，支持半径为 $2h$。对于粒子间距 $r = |x_i - x_j|$，使用支持半径为 $2h$ 的一维三次样条核函数，定义如下\n$$\nW(r, h) = \\alpha_1 f(q), \\quad q = \\frac{r}{h}, \\quad \\alpha_1 = \\frac{2}{3h}, \\\\\nf(q) = \\begin{cases}\n1 - \\frac{3}{2} q^2 + \\frac{3}{4} q^3,  0 \\le q  1, \\\\\n\\frac{1}{4}(2 - q)^3,  1 \\le q  2, \\\\\n0,  q \\ge 2,\n\\end{cases}\n$$\n并使用其关于粒子坐标 $x$ 的导数，\n$$\n\\frac{\\partial W}{\\partial x}(x_i - x_j; h) = \\alpha_1 f'(q) \\frac{1}{h} \\operatorname{sgn}(x_i - x_j), \\\\\nf'(q) = \\begin{cases}\n-3 q + \\frac{9}{4} q^2,  0 \\le q  1, \\\\\n-\\frac{3}{4} (2 - q)^2,  1 \\le q  2, \\\\\n0,  q \\ge 2,\n\\end{cases}\n$$\n约定不包括自相互作用，并且所有粒子间距都使用周期域上的最小镜像距离。所有量均为无量纲。\n\n设粒子索引 $i$ 处的中间速度为 $u_i^\\star$。压力投影法通过压力梯度对其进行修正，以获得 $u_i^{n+1} = u_i^\\star - \\Delta t \\, \\partial p / \\partial x \\big|_i$，其中 $\\Delta t$ 是时间步长，$p$ 是压力。对 $u^{n+1}$ 施加无散约束会得到一个压力泊松方程。在一维空间中，散度即空间导数。使用光滑粒子流体动力学（SPH）散度算子和对称的 Morris 型拉普拉斯算子推导离散的压力泊松方程，两者均由上述核函数和以下定义构建：\n- 将粒子 $i$ 处的 SPH 散度近似定义为\n$$\n(\\nabla \\cdot u)_i \\approx \\sum_{j \\ne i} m \\, (u_j - u_i) \\, \\frac{\\partial W}{\\partial x}(x_i - x_j; h).\n$$\n- 将粒子 $i$ 处的 SPH 标量拉普拉斯算子近似定义为\n$$\n(\\nabla^2 p)_i \\approx \\sum_{j \\ne i} 2 m \\, (p_j - p_i) \\, \\frac{(x_i - x_j)}{(x_i - x_j)^2 + \\varepsilon h^2} \\, \\frac{\\partial W}{\\partial x}(x_i - x_j; h),\n$$\n其中 $\\varepsilon$ 是一个小的正则化参数。两个算子使用相同的核函数导数。\n\n通过使用最小镜像距离 $x_i - x_j \\in [-\\frac{L}{2}, \\frac{L}{2})$ 来施加周期性。由于周期域上的离散拉普拉斯算子具有由常数构成的零空间，通过施加单个压力规范条件 $p_{N-1} = 0$ 来消除零空间模糊性。\n\n你的任务是：\n- 从质量和动量守恒以及不可压缩性约束 $\\nabla \\cdot u^{n+1} = 0$ 出发，证明压力投影步骤产生形式为 $\\nabla^2 p = \\frac{1}{\\Delta t} \\nabla \\cdot u^\\star$ 的压力泊松方程，然后通过用上述 SPH 算子替换连续散度和拉普拉斯算子来推导离散方程。\n- 实现一个程序，对每个测试用例，组装并求解粒子压力的线性系统，使用 SPH 压力梯度修正速度\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_i \\approx \\sum_{j \\ne i} m \\, (p_i - p_j) \\, \\frac{\\partial W}{\\partial x}(x_i - x_j; h),\n$$\n并计算修正后速度的离散散度的均方根（RMS）\n$$\n\\mathrm{RMS} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left[ (\\nabla \\cdot u^{n+1})_i \\right]^2 }.\n$$\n为每个测试用例报告一个浮点数形式的 RMS 值。\n\n使用以下测试用例集，所有用例均为无量纲，且独立运行：\n- 用例 A（一个波长的正弦波）：$N = 64$，$\\Delta t = 0.01$，$\\kappa = 2.5$，$\\varepsilon = 0.01$， $u_i^\\star = A \\sin(2 \\pi k x_i)$，其中 $A = 0.1$ 且 $k = 1$。\n- 用例 B（恒定速度）：$N = 32$，$\\Delta t = 0.02$，$\\kappa = 2.5$，$\\varepsilon = 0.01$， $u_i^\\star = A$，其中 $A = 0.2$。\n- 用例 C（两个波长的正弦波）：$N = 64$，$\\Delta t = 0.01$，$\\kappa = 2.5$，$\\varepsilon = 0.01$， $u_i^\\star = A \\sin(2 \\pi k x_i)$，其中 $A = 0.1$ 且 $k = 2$。\n\n实现要求和最终输出规范：\n- 所有计算都是无量纲的；不使用也不需要物理单位。\n- 对周期性距离使用最小镜像约定，在计算基于核函数的和时，仅包括满足 $|x_i - x_j|  2h$ 的邻居粒子。\n- 为简单起见，以稠密形式组装 $N \\times N$ 的类稀疏系统。通过将最后一个方程替换为 $p_{N-1} = 0$ 来施加 $p_{N-1} = 0$ 的条件。\n- 对于每个用例，计算并存储投影后的 RMS 散度，结果为浮点数。\n- 你的程序应生成单行输出，其中包含三个 RMS 值，格式为方括号括起来的逗号分隔列表，顺序为 [用例 A, 用例 B, 用例 C]，例如 `\"[r_A,r_B,r_C]\"`。\n\n你的最终答案必须是最终答案块中指定的完整、可运行的程序。该程序不得要求任何用户输入，并且必须仅使用如上所述的无量纲量。", "solution": "该问题是有效的，因为它科学地基于计算流体动力学的原理，特别是用于不可压缩流的光滑粒子流体动力学（SPH）方法。该问题是适定的、客观的，并提供了一套完整且一致的定义、参数和离散化方法，这些都是推导和实现解决方案所必需的。\n\n### 压力泊松方程的推导\n\n压力投影法是求解瞬态不可压缩纳维-斯托克斯方程的一种分步格式。该方法首先计算一个中间速度场 $u^\\star$，该速度场考虑了对流和粘性效应，但未考虑压力梯度。在这个问题中，中间速度 $u^\\star_i$ 是直接给出的。\n\n第二步，即投影步骤，用压力梯度修正这个中间速度，以施加不可压缩性约束。新时间步的速度 $u^{n+1}$ 的更新公式由下式给出\n$$\nu^{n+1} = u^\\star - \\frac{\\Delta t}{\\rho} \\nabla p\n$$\n其中 $p$ 是压力，$\\Delta t$ 是时间步长，$\\rho$ 是流体密度。问题指定所有量都是无量纲的，并提供恒定密度 $\\rho = 1$。该表达式简化为\n$$\nu^{n+1} = u^\\star - \\Delta t \\, \\nabla p\n$$\n在一维情况下，对每个粒子 $i$ 写为\n$$\nu_i^{n+1} = u_i^\\star - \\Delta t \\left(\\frac{\\partial p}{\\partial x}\\right)_i\n$$\n\n不可压缩性约束要求新时间步的速度场是无散的：\n$$\n\\nabla \\cdot u^{n+1} = 0\n$$\n为了找到压力 $p$ 的方程，我们对速度更新方程取散度：\n$$\n\\nabla \\cdot u^{n+1} = \\nabla \\cdot(u^\\star - \\Delta t \\, \\nabla p)\n= \\nabla \\cdot u^\\star - \\Delta t \\, \\nabla \\cdot (\\nabla p)\n= \\nabla \\cdot u^\\star - \\Delta t \\, \\nabla^2 p\n$$\n应用不可压缩性约束 $\\nabla \\cdot u^{n+1} = 0$ 可得：\n$$\n0 = \\nabla \\cdot u^\\star - \\Delta t \\, \\nabla^2 p\n$$\n重新整理此方程，得到关于 $p$ 的连续压力泊松方程：\n$$\n\\nabla^2 p = \\frac{1}{\\Delta t} \\nabla \\cdot u^\\star\n$$\n该方程表明，压力场的拉普拉斯算子与中间速度场的散度成正比。求解这个关于 $p$ 的方程，可以计算出将 $u^\\star$ 投影到无散空间所需的压力梯度，从而得到 $u^{n+1}$。在一维情况下，该方程为\n$$\n\\frac{\\partial^2 p}{\\partial x^2} = \\frac{1}{\\Delta t} \\frac{\\partial u^\\star}{\\partial x}\n$$\n\n### 使用 SPH 算子进行离散化\n\n为了对这组 $N$ 个粒子进行数值求解，我们用指定的 SPH 近似替换连续微分算子。我们设 $p_i$ 为粒子 $i$ 处的压力，$u_i^\\star$ 为其对应的中间速度。问题提供了以下 SPH 公式：\n-   **拉普拉斯算子**：$(\\nabla^2 p)_i \\approx \\sum_{j \\ne i} 2 m (p_j - p_i) \\frac{(x_i - x_j)}{(x_i - x_j)^2 + \\varepsilon h^2} \\frac{\\partial W}{\\partial x}(x_i - x_j; h)$\n-   **散度**：$(\\nabla \\cdot u^\\star)_i \\approx \\sum_{j \\ne i} m (u_j^\\star - u_i^\\star) \\frac{\\partial W}{\\partial x}(x_i - x_j; h)$\n\n其中 $m$ 是粒子质量，$x_i$ 是粒子 $i$ 的位置，$\\varepsilon$ 是一个正则化参数，$h$ 是光滑长度，$\\frac{\\partial W}{\\partial x}(x_i - x_j; h)$ 是 SPH 核函数关于坐标 $x_i$ 的导数。\n\n将这些离散算子代入压力泊松方程，我们得到一个关于未知粒子压力 $p_k$ 的线性方程组：\n$$\n\\sum_{j \\ne i} 2 m (p_j - p_i) \\frac{(x_i - x_j)}{(x_i - x_j)^2 + \\varepsilon h^2} \\frac{\\partial W_{ij}}{\\partial x} = \\frac{1}{\\Delta t} \\sum_{j \\ne i} m (u_j^\\star - u_i^\\star) \\frac{\\partial W_{ij}}{\\partial x}\n$$\n对每个粒子 $i = 0, 1, \\dots, N-1$ 成立，其中我们使用简写 $\\frac{\\partial W_{ij}}{\\partial x} = \\frac{\\partial W}{\\partial x}(x_i-x_j; h)$。\n\n该系统可以写成矩阵形式 $\\mathbf{A} \\mathbf{p} = \\mathbf{b}$，其中 $\\mathbf{p} = [p_0, p_1, \\dots, p_{N-1}]^T$ 是粒子压力向量。矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{b}$ 的分量确定如下。\n\n我们重写粒子 $i$ 的左侧（LHS）：\n$$\n\\text{LHS}_i = \\sum_{j \\ne i} \\left( 2 m \\frac{(x_i - x_j)}{(x_i - x_j)^2 + \\varepsilon h^2} \\frac{\\partial W_{ij}}{\\partial x} \\right) p_j - \\left( \\sum_{j \\ne i} 2 m \\frac{(x_i - x_j)}{(x_i - x_j)^2 + \\varepsilon h^2} \\frac{\\partial W_{ij}}{\\partial x} \\right) p_i\n$$\n由此，我们可以确定矩阵元素 $A_{ij}$：\n-   对于 $i \\ne j$：\n    $$\n    A_{ij} = 2 m \\frac{(x_i - x_j)}{(x_i - x_j)^2 + \\varepsilon h^2} \\frac{\\partial W_{ij}}{\\partial x}\n    $$\n-   对于对角元素（$i = j$）：\n    $$\n    A_{ii} = - \\sum_{k \\ne i} \\left( 2 m \\frac{(x_i - x_k)}{(x_i - x_k)^2 + \\varepsilon h^2} \\frac{\\partial W_{ik}}{\\partial x} \\right) = - \\sum_{k \\ne i} A_{ik}\n    $$\n右侧（RHS）向量 $\\mathbf{b}$ 的分量为 $b_i$：\n$$\nb_i = \\frac{1}{\\Delta t} \\sum_{j \\ne i} m (u_j^\\star - u_i^\\star) \\frac{\\partial W_{ij}}{\\partial x}\n$$\n\n### 求解线性系统\n\n周期域上的离散拉普拉斯算子具有对应于常数向量的零空间（即，如果 $p$ 是常数，则 $\\nabla^2 p = 0$）。这使得矩阵 $\\mathbf{A}$ 是奇异的。为了获得唯一解，我们必须施加一个压力规范条件。问题指定将最后一个粒子的压力设为零：$p_{N-1} = 0$。这通过修改线性系统来实现：矩阵 $\\mathbf{A}$ 的最后一行被替换为除了对角线上的 1 之外的全零（$A_{N-1, N-1} = 1$），并且向量 $\\mathbf{b}$ 的最后一个元素被设为零（$b_{N-1} = 0$）。修改后的系统是非奇异的，可以求解出 $\\mathbf{p}$。\n\n### 速度修正与最终散度计算\n\n一旦求出压力向量 $\\mathbf{p}$，就对速度进行修正。每个粒子 $i$ 处的压力梯度使用提供的 SPH 算子计算：\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_i \\approx \\sum_{j \\ne i} m (p_i - p_j) \\frac{\\partial W_{ij}}{\\partial x}\n$$\n然后，修正后的速度 $u^{n+1}_i$ 计算如下：\n$$\nu_i^{n+1} = u_i^\\star - \\Delta t \\left(\\frac{\\partial p}{\\partial x}\\right)_i\n$$\n最后，为了验证投影是否成功，我们计算新速度场的 SPH 散度 $(\\nabla \\cdot u^{n+1})_i$：\n$$\n(\\nabla \\cdot u^{n+1})_i = \\sum_{j \\ne i} m (u_j^{n+1} - u_i^{n+1}) \\frac{\\partial W_{ij}}{\\partial x}\n$$\n此散度在所有粒子上的均方根（RMS）作为最终的成功度量进行计算：\n$$\n\\mathrm{RMS} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left[ (\\nabla \\cdot u^{n+1})_i \\right]^2 }\n$$\n该值应接近于零，表明不可压缩性约束得到了很好的近似满足。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D incompressible SPH problem for three test cases.\n    \"\"\"\n\n    def get_kernel_derivatives(x, N, L, h):\n        \"\"\"\n        Computes the SPH kernel derivatives for all particle pairs.\n        \n        This function handles periodic boundary conditions and the cubic spline kernel.\n        \"\"\"\n        # Create a matrix of position differences\n        X_i = x.reshape(N, 1)\n        X_j = x.reshape(1, N)\n        dx_mat = X_i - X_j\n        \n        # Apply minimal image convention for periodic domain\n        dx_mat -= L * np.round(dx_mat / L)\n        \n        r_mat = np.abs(dx_mat)\n        q_mat = r_mat / h\n        \n        # Kernel constant\n        alpha1 = 2.0 / (3.0 * h)\n        \n        # Calculate f'(q) based on the piecewise definition\n        fp_q_mat = np.zeros_like(q_mat)\n        \n        # Condition for 0 = q  1\n        mask1 = (q_mat >= 0)  (q_mat  1)\n        q1 = q_mat[mask1]\n        fp_q_mat[mask1] = -3.0 * q1 + (9.0 / 4.0) * q1**2\n        \n        # Condition for 1 = q  2\n        mask2 = (q_mat >= 1)  (q_mat  2)\n        q2 = q_mat[mask2]\n        fp_q_mat[mask2] = - (3.0 / 4.0) * (2.0 - q2)**2\n        \n        # The derivative is zero for q >= 2\n        \n        # Compute the kernel derivative dW/dx\n        # Note: sign(0) is 0, correctly handling i=j case.\n        dWdx_mat = alpha1 * fp_q_mat * (1.0 / h) * np.sign(dx_mat)\n        \n        return dWdx_mat, dx_mat\n\n    def compute_rms_for_case(case_params):\n        \"\"\"\n        Computes the final RMS divergence for a single test case.\n        \"\"\"\n        N, delta_t, kappa, epsilon, u_star_func = case_params\n        \n        # 1. Setup simulation parameters\n        L = 1.0\n        rho = 1.0\n        dx = L / N\n        m = dx  # Particle mass given as delta x\n        h = kappa * dx\n        \n        # 2. Particle positions and intermediate velocities\n        x = (np.arange(N) + 0.5) * dx\n        u_star = u_star_func(x)\n        \n        # 3. Precompute kernel derivatives and distances\n        dWdx, dx_mat = get_kernel_derivatives(x, N, L, h)\n        \n        # 4. Assemble the linear system A*p = b\n        A = np.zeros((N, N))\n        b = np.zeros(N)\n        \n        # Vectorized assembly\n        # Off-diagonal elements of the Laplacian matrix part\n        # Zero out diagonal to handle i!=j condition\n        np.fill_diagonal(dx_mat, 0)\n        \n        # The coefficient for p_j in the equation for particle i\n        # Add a small number to denominator to prevent division by zero.\n        lap_coeff_mat = 2.0 * m * dx_mat / (dx_mat**2 + epsilon * h**2 + 1e-30) * dWdx\n\n        # Fill matrix A\n        # The sum is over k!=i, which is sum over columns for row i\n        A = lap_coeff_mat - np.diag(np.sum(lap_coeff_mat, axis=1))\n\n        # Assemble vector b\n        # u_star[j] - u_star[i] can be formed by broadcasting\n        u_diff_ji = u_star.reshape(1, N) - u_star.reshape(N, 1) # u_diff_ji[i, j] = u_star[j] - u_star[i]\n        div_u_star = np.sum(m * u_diff_ji * dWdx, axis=1)\n        b = div_u_star / delta_t\n        \n        # 5. Apply pressure gauge p_{N-1} = 0\n        A[N - 1, :] = 0.0\n        A[N - 1, N - 1] = 1.0\n        b[N - 1] = 0.0\n        \n        # 6. Solve for pressures\n        p = np.linalg.solve(A, b)\n        \n        # 7. Correct velocities\n        # p[i] - p[j]\n        p_diff_ij = p.reshape(N, 1) - p.reshape(1, N)\n        grad_p = np.sum(m * p_diff_ij * dWdx, axis=1)\n        u_new = u_star - delta_t * grad_p\n        \n        # 8. Compute final divergence and RMS\n        # u_new[j] - u_new[i]\n        u_new_diff_ji = u_new.reshape(1, N) - u_new.reshape(N, 1)\n        div_u_new = np.sum(m * u_new_diff_ji * dWdx, axis=1)\n        rms = np.sqrt(np.mean(div_u_new**2))\n        \n        return rms\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        (64, 0.01, 2.5, 0.01, lambda x: 0.1 * np.sin(2 * np.pi * 1 * x)),\n        # Case B\n        (32, 0.02, 2.5, 0.01, lambda x: 0.2 * np.ones_like(x)),\n        # Case C\n        (64, 0.01, 2.5, 0.01, lambda x: 0.1 * np.sin(2 * np.pi * 2 * x)),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_rms_for_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3514925"}]}