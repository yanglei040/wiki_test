{"hands_on_practices": [{"introduction": "要掌握一个算法，最好的方法就是亲手执行一遍。这个练习将引导你完成 Parareal 算法的第一次修正迭代，应用于一个简单的非线性常微分方程。通过这个具体的计算，你将清楚地理解粗略（coarse）和精细（fine）传播算子的角色，以及 Parareal 算法核心的预测-校正结构[@problem_id:2158974]。", "problem": "Parareal 算法是一种时间并行积分方法，旨在加速初值问题 (IVP) 的求解。该算法将总时间区间 $[T_0, T_{final}]$ 划分为 $N$ 个更小的子区间 $[T_n, T_{n+1}]$，其中 $T_n = T_0 + n \\Delta T$ 且 $\\Delta T = (T_{final}-T_0)/N$。然后，它使用两个数值求解器：一个计算成本低但不精确的粗略求解器 $\\mathcal{G}$，以及一个计算成本高但精确的精细求解器 $\\mathcal{F}$。\n\nParareal 方法的核心是一种迭代校正方案。从所有时间点 $T_n$ 处解的初始猜测（记为 $y_n^0$）开始，每次迭代 $k$ 将解的值从 $y_n^k$ 精化到 $y_n^{k+1}$。在第 n 个子区间末端解的更新值 $y_{n+1}^{k+1}$ 由以下公式给出：\n$$y_{n+1}^{k+1} = \\mathcal{G}(T_{n+1}, T_n, y_n^{k+1}) + \\left[ \\mathcal{F}(T_{n+1}, T_n, y_n^k) - \\mathcal{G}(T_{n+1}, T_n, y_n^k) \\right]$$\n此处，$\\mathcal{S}(T_b, T_a, y_{init})$ 表示在时间区间 $[T_a, T_b]$ 上，使用初始条件 $y(T_a) = y_{init}$ 应用求解器 $\\mathcal{S}$ 得到的结果。方括号中的项是校正项。注意，右侧的粗略求解器 $\\mathcal{G}$ 是从新计算出的值 $y_n^{k+1}$ 开始传播的。迭代 $k=0$ 时整个轨迹的初始猜测是通过顺序应用粗略求解器生成的：$y_{n+1}^0 = \\mathcal{G}(T_{n+1}, T_n, y_n^0)$，从真实的初始条件 $y_0^0 = y_0$ 开始。\n\n考虑由以下常微分方程给出的逻辑斯谛增长初值问题：\n$$y'(t) = \\rho y(t) \\left(1 - \\frac{y(t)}{K}\\right)$$\n参数为 $\\rho = 0.5$，$K = 100$，初始条件为 $y(0) = 10$。我们希望在时间区间 $[0, 2]$ 上求解该初值问题。\n\n时间区间被划分为 $N=2$ 个子区间：$[0, 1]$ 和 $[1, 2]$。因此，$T_0=0$，$T_1=1$，$T_2=2$，粗略时间步长为 $\\Delta T = 1$。\n\n粗略求解器 $\\mathcal{G}$ 是 Forward Euler 方法，它在每个子区间上使用大小为 $\\Delta T$ 的单步进行求解：\n$$\\mathcal{G}(T_{n+1}, T_n, y_n) = y_n + \\Delta T \\cdot f(T_n, y_n)$$\n其中 $f(t,y) = y'(t)$。\n\n精细求解器 $\\mathcal{F}$ 是经典的四阶 Runge-Kutta (RK4) 方法。为了跨越一个宽度为 $\\Delta T=1$ 的子区间，它需要走两步，步长为 $\\delta t = 0.5$。从时间 $t_i$ 到 $t_{i+1} = t_i + \\delta t$，值为 $y_i$ 的单个 RK4 步的更新由下式给出：\n$$y_{i+1} = y_i + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$\n其中\n$k_1 = \\delta t \\cdot f(t_i, y_i)$\n$k_2 = \\delta t \\cdot f(t_i + \\frac{\\delta t}{2}, y_i + \\frac{k_1}{2})$\n$k_3 = \\delta t \\cdot f(t_i + \\frac{\\delta t}{2}, y_i + \\frac{k_2}{2})$\n$k_4 = \\delta t \\cdot f(t_i + \\delta t, y_i + k_3)$\n\n你的任务是计算在第一次 parareal 校正之后，在 $t=T_2=2$ 处的数值解的值，即求出 $y_2^1$ 的值。将你的最终答案四舍五入到四位有效数字。", "solution": "我们求解初值问题 $y'(t)=\\rho y(t)\\left(1-\\frac{y(t)}{K}\\right)$，其中 $\\rho=0.5$，$K=100$，$y(0)=10$，时间区间为 $[0,2]$，划分为 $N=2$ 个子区间，$\\Delta T=1$。定义 $f(t,y)=\\rho y\\left(1-\\frac{y}{K}\\right)=0.5\\,y-0.005\\,y^{2}$。Parareal 更新公式为\n$$\ny_{n+1}^{k+1}=\\mathcal{G}(T_{n+1},T_{n},y_{n}^{k+1})+\\left[\\mathcal{F}(T_{n+1},T_{n},y_{n}^{k})-\\mathcal{G}(T_{n+1},T_{n},y_{n}^{k})\\right],\n$$\n其中 $\\mathcal{G}$ 是步长为 $\\Delta T=1$ 的 Forward Euler 步：\n$$\n\\mathcal{G}(T_{n+1},T_{n},y_{n})=y_{n}+\\Delta T \\cdot f(T_{n},y_{n}),\n$$\n$\\mathcal{F}$ 是在每个子区间上使用两步（步长 $\\delta t=0.5$）的 RK4 方法。从 $t_{i}$ 到 $t_{i+1}=t_{i}+\\delta t$，值为 $y_{i}$ 的一个 RK4 步为\n$$\n\\begin{aligned}\nk_{1}=\\delta t\\,f(t_{i},y_{i}),\\\\\nk_{2}=\\delta t\\,f\\!\\left(t_{i}+\\tfrac{\\delta t}{2},\\,y_{i}+\\tfrac{k_{1}}{2}\\right),\\\\\nk_{3}=\\delta t\\,f\\!\\left(t_{i}+\\tfrac{\\delta t}{2},\\,y_{i}+\\tfrac{k_{2}}{2}\\right),\\\\\nk_{4}=\\delta t\\,f\\!\\left(t_{i}+\\delta t,\\,y_{i}+k_{3}\\right),\\\\\ny_{i+1}=y_{i}+\\tfrac{1}{6}\\left(k_{1}+2k_{2}+2k_{3}+k_{4}\\right).\n\\end{aligned}\n$$\n\n步骤 1：初始粗略轨迹 ($k=0$)。给定 $y_{0}^{0}=10$ 和 $\\Delta T=1$，\n$$\ny_{1}^{0}=\\mathcal{G}(1,0,10)=10+1 \\cdot f(0,10)=10+\\left(0.5\\cdot 10-0.005\\cdot 10^{2}\\right)=10+4.5=14.5,\n$$\n$$\n\\begin{aligned}\nf(1,14.5)=0.5\\cdot 14.5-0.005\\cdot(14.5)^{2}=7.25-1.05125=6.19875,\\\\\ny_{2}^{0}=\\mathcal{G}(2,1,14.5)=14.5+1 \\cdot 6.19875=20.69875.\n\\end{aligned}\n$$\n\n步骤 2：在 $n=0$ 处的第一次 parareal 校正给出\n$$\ny_{1}^{1}=\\mathcal{G}(1,0,y_{0}^{1})+\\left[\\mathcal{F}(1,0,y_{0}^{0})-\\mathcal{G}(1,0,y_{0}^{0})\\right]=\\mathcal{F}(1,0,10),\n$$\n所以我们用 RK4 方法通过两个半步计算 $\\mathcal{F}(1,0,10)$。\n\n子区间 $[0,0.5]$，从 $y=10$ 开始：\n$$\n\\delta t=0.5,\\quad k_{1}=0.5\\,f(0,10)=0.5\\cdot 4.5=2.25,\n$$\n$$\nk_{2}=0.5\\,f\\!\\left(0.25,\\,10+\\tfrac{2.25}{2}\\right)=0.5\\,f(11.125)=0.5\\cdot 4.943671875=2.4718359375,\n$$\n$$\nk_{3}=0.5\\,f\\!\\left(0.25,\\,10+\\tfrac{2.4718359375}{2}\\right)=0.5\\,f(11.23591796875)\\approx 2.49336486068625,\n$$\n$$\nk_{4}=0.5\\,f\\!\\left(0.5,\\,10+2.49336486068625\\right)=0.5\\,f(12.49336486068625)\\approx 2.73313080137868,\n$$\n$$\ny(0.5)=10+\\tfrac{1}{6}\\left(2.25+2\\cdot 2.4718359375+2\\cdot 2.49336486068625+2.73313080137868\\right)\\approx 12.4855887329585.\n$$\n\n子区间 $[0.5,1]$，从 $y\\approx 12.4855887329585$ 开始：\n$$\nk_{1}=0.5\\,f(12.4855887329585)\\approx 2.73167236817963,\\quad\nk_{2}=0.5\\,f(13.8514249170483)\\approx 2.98320129867894,\n$$\n$$\nk_{3}=0.5\\,f(13.9771893822979)\\approx 3.00589278881362,\\quad\nk_{4}=0.5\\,f(15.4914815217721)\\approx 3.27290538106303,\n$$\n$$\ny(1)=12.4855887329585+\\tfrac{1}{6}\\left(2.73167236817963+2\\cdot 2.98320129867894+2\\cdot 3.00589278881362+3.27290538106303\\right)\\approx 15.4827163869965.\n$$\n因此 $y_{1}^{1}\\approx 15.4827163869965$。\n\n步骤 3：在 $[1,2]$ 上使用 $y_{1}^{0}=14.5$ 计算括号项：\n我们需要 $\\mathcal{F}(2,1,14.5)$ 和 $\\mathcal{G}(2,1,14.5)=20.69875$。\n\n从 $y=14.5$ 开始，应用 RK4 方法并走两个半步。\n\n子区间 $[1,1.5]$，从 $y=14.5$ 开始：\n$$\nk_{1}=0.5\\,f(14.5)=3.099375,\\quad\nk_{2}=0.5\\,f(16.0496875)\\approx 3.36844070288086,\n$$\n$$\nk_{3}=0.5\\,f(16.1842203514404)\\approx 3.39123261690612,\\quad\nk_{4}=0.5\\,f(17.8912326169061)\\approx 3.67256764286451,\n$$\n$$\ny(1.5)=14.5+\\tfrac{1}{6}\\left(3.099375+2\\cdot 3.36844070288086+2\\cdot 3.39123261690612+3.67256764286451\\right)\\approx 17.8818815470731.\n$$\n\n子区间 $[1.5,2]$，从 $y\\approx 17.8818815470731$ 开始：\n$$\nk_{1}=0.5\\,f(17.8818815470731)\\approx 3.67106616760706,\\quad\nk_{2}=0.5\\,f(19.7174146308766)\\approx 3.95741255839837,\n$$\n$$\nk_{3}=0.5\\,f(19.8605878262723)\\approx 3.97903958455471,\\quad\nk_{4}=0.5\\,f(21.8609211316278)\\approx 4.27048060109804,\n$$\n$$\ny(2)=17.8818815470731+\\tfrac{1}{6}\\left(3.67106616760706+2\\cdot 3.95741255839837+2\\cdot 3.97903958455471+4.27048060109804\\right)\\approx 21.8509567228416.\n$$\n因此 $\\mathcal{F}(2,1,14.5)\\approx 21.8509567228416$，括号项为\n$$\n\\mathcal{F}(2,1,14.5)-\\mathcal{G}(2,1,14.5)\\approx 21.8509567228416-20.69875=1.1522067228416.\n$$\n\n步骤 4：在 $n=1$ 处的第一次 parareal 校正：\n计算 $\\mathcal{G}(2,1,y_{1}^{1})=y_{1}^{1}+\\Delta T \\cdot f(y_{1}^{1})$，其中 $y_{1}^{1}\\approx 15.4827163869965$，\n$$\nf(15.4827163869965)=0.5\\cdot 15.4827163869965-0.005\\cdot(15.4827163869965)^{2}\\approx 6.54278565989877,\n$$\n$$\n\\mathcal{G}(2,1,y_{1}^{1})\\approx 15.4827163869965+6.54278565989877=22.0255020468953.\n$$\n因此，\n$$\ny_{2}^{1}=\\mathcal{G}(2,1,y_{1}^{1})+\\left[\\mathcal{F}(2,1,y_{1}^{0})-\\mathcal{G}(2,1,y_{1}^{0})\\right]\\approx 22.0255020468953+1.1522067228416=23.1777087697369.\n$$\n\n四舍五入到四位有效数字，$y_{2}^{1}\\approx 23.18$。", "answer": "$$\\boxed{23.18}$$", "id": "2158974"}, {"introduction": "在了解 Parareal 算法的运作机制之后，理解其为何能够收敛至关重要。这个练习从具体的数值例子转向通用的理论分析，使用标准的线性测试方程来考察算法的收敛性。通过推导误差放大因子，你将深入了解决定该算法稳定性与收敛速度的关键条件[@problem_id:1126848]。", "problem": "Parareal 算法是一种时间并行积分方法，旨在求解形如 $y'(t) = f(y(t), t)$ 的初值问题 (IVPs)。时间域 $[T_0, T_f]$ 被划分为 $N$ 个长度相等的粗时间区间 $[T_n, T_{n+1}]$，其时长为 $\\Delta T = T_{n+1} - T_n$。该算法在粗时间点上迭代地逼近解 $U_n \\approx y(T_n)$。\n\n设 $\\mathcal{G}(T_{n+1}, T_n, V)$ 表示一个低成本、低精度的**粗传播子**，它从 $T_n$ 时的值 $V$ 开始，逼近 $T_{n+1}$ 时的解。类似地，设 $\\mathcal{F}(T_{n+1}, T_n, V)$ 是一个高成本、高精度的**细传播子**。Parareal 迭代（由 $k$ 索引）根据以下公式更新近似解 $U_n^k$：\n$$\nU_{n+1}^{k+1} = \\mathcal{G}(T_{n+1}, T_n, U_n^{k+1}) + \\mathcal{F}(T_{n+1}, T_n, U_n^k) - \\mathcal{G}(T_{n+1}, T_n, U_n^k)\n$$\n迭代从通过串行应用粗传播子获得的初始猜测 $U_n^0$ 开始：$U_{n+1}^0 = \\mathcal{G}(T_{n+1}, T_n, U_n^0)$。\n\n考虑将 Parareal 算法应用于线性测试问题 $y'(t) = \\lambda y(t)$，其中 $\\lambda$ 是一个复常数。设粗传播子 $\\mathcal{G}$ 是在粗区间 $\\Delta T$ 上的单步**前向欧拉法**。设细传播子 $\\mathcal{F}$ 由 $M$ 步**后向欧拉法**组成，每步的细时间步长为 $\\Delta t = \\Delta T / M$。\n\n算法的收敛性可以通过研究误差 $\\epsilon_n^k = U_n^k - U_n^*$ 相对于串行计算的精细解的演化来分析。对于线性测试问题，对时间片索引 $n$ 应用 z 变换（即 $\\hat{\\epsilon}^k(z) = \\sum_{n=0}^{\\infty} \\epsilon_n^k z^{-n}$）表明，误差从一次迭代到下一次迭代的变换遵循关系式 $\\hat{\\epsilon}^{k+1}(z) = \\rho(z) \\hat{\\epsilon}^k(z)$。函数 $\\rho(z)$ 是**误差放大因子**，其模的大小决定了 Parareal 迭代的收斂性。\n\n确定在这种特定的 Parareal 设置下的误差放大因子 $\\rho(z)$。用 z 变换变量 $z$、问题参数 $\\lambda$、粗时间步长 $\\Delta T$ 和细步数 $M$ 来表示你的答案。", "solution": "1. 对于 $y'= \\lambda y$ 在 $\\Delta T$ 上的粗传播子和细传播子：\n   $$g = \\mathcal{G} = 1 + \\lambda\\,\\Delta T,$$\n   $$f = \\mathcal{F} = \\Bigl(1 - \\lambda\\,\\tfrac{\\Delta T}{M}\\Bigr)^{-M}.$$\n\n2. 对于 $E_n^k = U_n^k - U_n^*$ 的 Parareal 误差迭代：\n   $$E_{n+1}^{\\,k+1} = g\\,E_n^{\\,k+1} + (f - g)\\,E_n^k.$$\n\n3. 进行 z 变换 $\\hat E^k(z)=\\sum_{n\\ge0}E_n^k\\,z^{-n}$，并使用 $E_0^k=0$，\n   \n$$\n     \\hat E^{\\,k+1}(z)\n     = g\\,z^{-1}\\,\\hat E^{\\,k+1}(z)\n       + (f-g)\\,z^{-1}\\,\\hat E^k(z).\n   $$\n\n   整理得，\n   $$(1 - g\\,z^{-1})\\,\\hat E^{\\,k+1}(z) = (f-g)\\,z^{-1}\\,\\hat E^k(z).$$\n\n4. 因此误差放大因子为\n   $$\\rho(z) = \\frac{\\hat E^{\\,k+1}(z)}{\\hat E^k(z)}\n               = \\frac{(f-g)\\,z^{-1}}{1 - g\\,z^{-1}}\n               = \\frac{f-g}{\\,z - g\\,}.$$\n\n5. 代入 $f$ 和 $g$，\n   $$\\rho(z)\n     = \\frac{\\,(1 - \\frac{\\lambda\\,\\Delta T}{M})^{-M} - (1 + \\lambda\\,\\Delta T)\\,}\n            {\\,z - (1 + \\lambda\\,\\Delta T)\\,}.$$", "answer": "$$\\boxed{\\frac{\\bigl(1 - \\tfrac{\\lambda\\Delta T}{M}\\bigr)^{-M} - \\bigl(1 + \\lambda\\Delta T\\bigr)}{z - \\bigl(1 + \\lambda\\Delta T\\bigr)}}$$", "id": "1126848"}, {"introduction": "并行算法的最终目标是实现加速。这个练习专注于对 Parareal 算法的性能进行建模，推导其可实现的加速比上限。通过这个过程，你将学会如何识别限制算法性能的关键因素，例如粗略求解器的计算成本和所需的迭代次数[@problem_id:3329274]。", "problem": "您正在对一个非定常计算流体动力学（CFD）模拟进行建模，该模拟的时间区间被划分为 $N_t$ 个连续的时间片。Parareal 算法使用一个粗略传播算子 $G$ 和一个精细传播算子 $F$，通过利用跨时间片的并行性来加速时间积分。粗略传播算子 $G$ 是一个稳定、低精度的时​​间积分器，而精细传播算子 $F$ 是一个定义了目标串行解的高精度时间积分器。设通过一次 $G$ 的应用推进一个时间片的计算成本为 $t_G$，通过一次 $F$ 的应用推进一个时间片的计算成本为 $t_F$，且 $t_F \\gg t_G$。假设一个由 $P=N_t$ 个相同处理器组成的同构平台专用于时间并行执行，通信和同步开销可忽略不计，且实现了完美的负载均衡。\n\n(a) 定义在 $N_t$ 个时间片上的 Parareal 算法，使用粗略传播算子 $G$ 和精细传播算子 $F$，包括表示在第 $k$ 次迭代时更新迭代值 $\\{y_n^{k}\\}_{n=0}^{N_t}$ 的初始化和迭代步骤。\n\n(b) 从并行性能建模的基本原理出发，使用并行机上加速比 $S$、功（work）和跨度（span）的标准定义，推导在 $K$ 次 Parareal 迭代后可实现加速比的严格上限。具体来说，从以下几点出发：\n- 仅使用精细算子的串行执行时间，\n- 基于功守恒（work conservation）和 $P=N_t$ 个处理器的 Parareal 并行执行时间的下界，以及\n- 算法依赖结构所导致的因果关系约束，\n然后根据需要放宽此界限，以证明加速比 $S$ 满足\n$$\nS \\leq \\frac{N_t\\, t_F}{\\,t_G + \\frac{t_F}{K}\\,}。\n$$\n\n您的推导不得假设任何超出功和依赖约束所隐含的未说明的重叠，并且必须明确证明用于放宽界限的每个不等式的合理性。将您的最终答案表示为关于 $N_t$、$t_F$、$t_G$ 和 $K$ 的单个解析表达式。最终表达式无需进行数值计算，也无需单位。", "solution": "该问题要求定义 Parareal 算法，并在特定的理想化假设下推导其加速比的上限。\n\n### (a) Parareal 算法的定义\n\n设问题为在区间 $[T_0, T_{end}]$ 上对常微分方程组（ODEs）$u'(t) = f(u(t), t)$ 进行时间积分，给定初始条件 $u(T_0) = u_0$。时间区间被划分为 $N_t$ 个连续的子区间，或称时间片，$[T_{n-1}, T_n]$，其中 $n=1, \\dots, N_t$。\n\nParareal 算法使用两个传播算子来近似每个时间片末端的解 $u(T_n)$：\n1.  一个**精细传播算子** $F$，其计算成本高昂（每个时间片成本为 $t_F$），但保真度高。串行解由相继应用 $F$ 定义：$y_n = F(y_{n-1})$。\n2.  一个**粗略传播算子** $G$，其计算成本低廉（每个时间片成本为 $t_G$，且 $t_G \\ll t_F$），但保真度低。\n\n设 $y_n^k$ 是 Parareal 算法第 $k$ 次迭代时解 $u(T_n)$ 的近似值。该算法按以下步骤进行：\n\n**1. 初始化 ($k=0$):**\n使用粗略传播算子顺序计算所有时间片的初始近似值。这为迭代校正过程提供了一个初始猜测。\n$$\ny_0^0 = u_0\n$$\n$$\ny_n^0 = G(y_{n-1}^0) \\quad \\text{for } n = 1, 2, \\dots, N_t\n$$\n此步骤本质上是串行的，执行 $N_t$ 次粗略求解。\n\n**2. 迭代 (对于 $k=0, 1, \\dots, K-1$):**\n对于每次迭代 $k$，算法校正前一次的近似值 $y_n^k$，以产生新的近似值 $y_n^{k+1}$。这包括两个主要步骤：\n\n*   **步骤 2a (并行精细求解):** 在所有 $N_t$ 个时间片上并行应用昂贵的精细传播算子 $F$。处理器 $n$ 从上一次迭代的解 $y_{n-1}^k$ 开始，计算时间片 $[T_{n-1}, T_n]$ 上的精细解。由于有 $P=N_t$ 个处理器，每个处理器被分配一个时间片，所有精细求解都并行执行。\n*   **步骤 2b (串行校正):** 来自并行精细求解的结果用于校正下一次的粗略传播。下一次迭代状态 $y_n^{k+1}$ 的更新公式由下式给出：\n    $$\n    y_n^{k+1} = G(y_{n-1}^{k+1}) + F(y_{n-1}^k) - G(y_{n-1}^k)\n    $$\n    这个公式可以解释为使用粗略求解器 $G(y_{n-1}^{k+1})$ 传播解，然后加上一个校正项 $F(y_{n-1}^k) - G(y_{n-1}^k)$。该校正项是（在步骤 2a 中计算的）前一个时间片上更精确的精细解与用于生成第 $k$ 次迭代值的粗略解之间的差值。注意对 $y_{n-1}^{k+1}$ 的依赖，这使得此校正步骤在时间片之间是串行的。\n\n经过 $K$ 次迭代后，最终的近似解为 $\\{y_n^K\\}_{n=0}^{N_t}$。\n\n### (b) 加速比上限的推导\n\n加速比 $S$ 定义为串行执行时间与并行执行时间的比值，$S = \\frac{T_{serial}}{T_{par}(K)}$。为了推导 $S$ 的上限，我们需要并行执行时间 $T_{par}(K)$ 的一个下界。\n\n**1. 串行执行时间 ($T_{serial}$):**\n基准串行执行定义为仅使用高保真度的精细传播算子 $F$ 顺序地处理所有 $N_t$ 个时间片。总时间为：\n$$\nT_{serial} = N_t t_F\n$$\n\n**2. 并行执行时间的下界 ($T_{par}(K)$):**\n我们通过首先计算算法所需的总计算功，然后应用功守恒原理来建立并行执行时间的下界。\n\n*   **总功 ($W$):** 总功是算法执行的所有任务的计算成本之和。\n    *   **初始化:** 此步骤涉及 $N_t$ 次对粗略传播算子 $G$ 的顺序应用。其功为 $W_{init} = N_t t_G$。\n    *   **K 次迭代:** $K$ 次迭代中的每一次都包括：\n        *   $N_t$ 次精细传播算子 $F$ 的应用，每个时间片一次。每次迭代中精细求解的总功为 $N_t t_F$。\n        *   在串行校正步骤中 $N_t$ 次粗略传播算子 $G$ 的应用。每次迭代中粗略求解的总功为 $N_t t_G$。\n    $K$ 次迭代的功为 $W_{iters} = K (N_t t_F + N_t t_G)$。\n    *   **总功:** 整个算法的总功是初始化和迭代功的总和。\n        $$\n        W = W_{init} + W_{iters} = N_t t_G + K N_t (t_F + t_G) = N_t (K t_F + (K+1) t_G)\n        $$\n\n*   **功守恒得出的下界:** 并行计算的一个基本原理是，在 $P$ 个处理器上的并行执行时间 $T_{par}$ 不能小于总功 $W$ 除以 $P$。这得出了一个基于每个处理器平均工作负载的下界。给定 $P = N_t$：\n    $$\n    T_{par}(K) \\ge \\frac{W}{P} = \\frac{N_t (K t_F + (K+1) t_G)}{N_t} = K t_F + (K+1) t_G\n    $$\n    这个界限是算法所需的总功和可用处理器数量的直接结果。功的计算隐式地考虑了算法的因果结构，因为它对所有必要的计算步骤进行了求和。\n\n**3. 下界的放宽:**\n问题要求一个特定形式的加速比界限，这个界限可能比我们直接从功守恒界限推导出的那个更宽松。我们可以通过放宽 $T_{par}(K)$ 的下界来获得所需的形式。我们已经确定：\n$$\nT_{par}(K) \\ge K t_F + (K+1) t_G\n$$\n我们现在证明 $K t_F + (K+1) t_G \\ge t_G + \\frac{t_F}{K}$，从而将 $t_G + \\frac{t_F}{K}$ 确立为 $T_{par}(K)$ 的一个有效的（尽管更弱的）下界。\n\n让我们分别检查各项：\n*   对于涉及 $t_F$ 的项：由于算法要执行任何校正，迭代次数 $K$ 必须至少为 1，因此我们有 $K \\ge 1$。这意味着 $K^2 \\ge 1$，因此 $K \\ge \\frac{1}{K}$。两边乘以 $t_F > 0$ 得到 $K t_F \\ge \\frac{t_F}{K}$。\n*   对于涉及 $t_G$ 的项：由于 $K \\ge 0$，我们有 $K+1 \\ge 1$。两边乘以 $t_G > 0$ 得到 $(K+1) t_G \\ge t_G$。\n\n结合这两个不等式，我们可以为我们基于功的不等式的右侧构建一个更弱的下界：\n$$\nK t_F + (K+1) t_G \\ge \\frac{t_F}{K} + t_G\n$$\n因此，我们成功地放宽了并行时间的下界：\n$$\nT_{par}(K) \\ge t_G + \\frac{t_F}{K}\n$$\n\n**4. 加速比上限的推导:**\n使用加速比的定义 $S = \\frac{T_{serial}}{T_{par}(K)}$，并将 $T_{par}(K)$ 的放宽后的下界代入分母，我们得到 $S$ 的一个上限：\n$$\nS = \\frac{N_t t_F}{T_{par}(K)} \\le \\frac{N_t t_F}{t_G + \\frac{t_F}{K}}\n$$\n这就是所求的可实现加速比上限的表达式。\n\n加速比 $S$ 的上限的最终表达式是：\n$$\nS \\leq \\frac{N_t\\, t_F}{\\,t_G + \\frac{t_F}{K}\\,}\n$$", "answer": "$$\n\\boxed{\\frac{N_t t_F}{t_G + \\frac{t_F}{K}}}\n$$", "id": "3329274"}]}