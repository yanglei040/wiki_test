{"hands_on_practices": [{"introduction": "任何有限元方法的核心要求是其正确性。本练习将引导你完成“分片检验”（Patch Test），这是验证单元实现能否正确表示基本物理状态的黄金标准。我们将从第一性原理出发，实现一个双线性四边形单元，并测试其精确再现线性位移场和恒定应变场的能力，这一性质也称为仿射不变性。此实践旨在构建进行更复杂模拟所需的核心编程技能和信心 [@problem_id:3525426]。", "problem": "构造一个完整且可运行的程序，用于验证双线性等参四边形单元的线性分片检验、数值积分下的一致性，以及在给定仿射映射下插值和应变的仿射不变性。在没有物理单位的纯数学和逻辑环境中进行。所有定义必须根据等参有限元的基本原理从头实现：等参映射、参考正方形上的双线性拉格朗日形函数、小应变运动学以及高斯积分。除这些核心定义外，不得假定任何预先推导的有限元公式。\n\n从以下基础出发：\n\n- 参考单元是正方形 $[-1,1]\\times[-1,1]$，其局部坐标为 $(\\xi,\\eta)$，节点排序为：$1:(-1,-1)$、$2:(1,-1)$、$3:(1,1)$、$4:(-1,1)$。\n- 双线性拉格朗日形函数 $N_i(\\xi,\\eta)$ 是在每个变量中均为线性、在节点 $i$ 处为 $1$、在其他节点处为 $0$ 的唯一多项式。\n- 从参考坐标到物理坐标的等参映射为 $x(\\xi,\\eta)=\\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,X_i$ 和 $y(\\xi,\\eta)=\\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,Y_i$，其中 $(X_i,Y_i)$ 是节点 $i$ 的物理坐标。\n- 雅可比矩阵为 $J(\\xi,\\eta)=\\begin{bmatrix}\\partial x/\\partial \\xi & \\partial x/\\partial \\eta\\\\ \\partial y/\\partial \\xi & \\partial y/\\partial \\eta\\end{bmatrix}$，关于物理坐标的导数满足 $\\nabla_{\\mathbf{x}} N_i = J^{-1}\\,\\nabla_{\\xi} N_i$。\n- 对于位移场 $u=(u,v)$，二维小应变张量为 $\\varepsilon=\\begin{bmatrix}\\varepsilon_{xx}\\\\ \\varepsilon_{yy}\\\\ \\gamma_{xy}\\end{bmatrix}=\\begin{bmatrix}\\partial u/\\partial x\\\\ \\partial v/\\partial y\\\\ \\partial u/\\partial y + \\partial v/\\partial x\\end{bmatrix}$。\n- 双线性四边形的单元应变-位移矩阵 $B$ 的尺寸为 $3\\times 8$，由 $\\partial N_i/\\partial x$ 和 $\\partial N_i/\\partial y$ 构建，使得 $\\varepsilon = B\\,d_e$，其中 $d_e=[u_1,v_1,u_2,v_2,u_3,v_3,u_4,v_4]^T$ 是单元节点位移自由度。\n- 弹性模量为 $E$、泊松比为 $\\nu$ 的各向同性固体的平面应力本构矩阵为 $D = \\dfrac{E}{1-\\nu^2}\\begin{bmatrix}1 & \\nu & 0\\\\ \\nu & 1 & 0\\\\ 0 & 0 & \\dfrac{1-\\nu}{2}\\end{bmatrix}$，单元刚度为 $K_e=\\int_{-1}^{1}\\int_{-1}^{1} B^T D B \\,\\det(J)\\, d\\xi\\, d\\eta$。\n- 在 $[-1,1]$ 上的张量积高斯积分，对于 $1\\times 1$ 点，使用点 $(\\xi,\\eta)=(0,0)$ 和权重 $w=4$；对于 $2\\times 2$ 点，使用点 $(\\xi,\\eta)=\\left(\\pm 1/\\sqrt{3},\\pm 1/\\sqrt{3}\\right)$ 和单位权重。\n\n使用以下给定的从参考域到物理域的仿射映射，由 $x = A\\,\\hat{x} + t$ 给出，其中 $\\hat{x}=(\\xi,\\eta)^T$，$A\\in\\mathbb{R}^{2\\times 2}$ 可逆且 $t\\in\\mathbb{R}^2$：\n\n- 映射 $\\mathcal{A}_1$: $A_1=\\begin{bmatrix}1 & 0\\\\ 0 & 1\\end{bmatrix}$, $t_1=\\begin{bmatrix}0\\\\ 0\\end{bmatrix}$。\n- 映射 $\\mathcal{A}_2$: $A_2=\\begin{bmatrix}1.7320508075688772 & -0.25\\\\ 1.0 & 0.4330127018922193\\end{bmatrix}$, $t_2=\\begin{bmatrix}0\\\\ 0\\end{bmatrix}$。\n- 映射 $\\mathcal{A}_3$: $A_3=\\begin{bmatrix}1.5 & 0.9\\\\ 0.0 & 1.5\\end{bmatrix}$, $t_3=\\begin{bmatrix}0.3\\\\ -0.2\\end{bmatrix}$。\n- 映射 $\\mathcal{A}_4$: $A_4=\\begin{bmatrix}1.0 & 0.3\\\\ 0.0 & 0.001\\end{bmatrix}$, $t_4=\\begin{bmatrix}0.0\\\\ 0.0\\end{bmatrix}$。\n\n使用以下物理坐标系中的线性位移场：\n$$\nu(x,y)=a_0 + a_1 x + a_2 y,\\qquad v(x,y)=b_0 + b_1 x + b_2 y,\n$$\n系数为 $a_0=0.1$，$a_1=0.2$，$a_2=-0.3$，$b_0=-0.05$，$b_1=0.4$，$b_2=0.25$。该场的精确小应变为常数：\n$$\n\\varepsilon_{xx}^{\\text{exact}}=a_1,\\quad \\varepsilon_{yy}^{\\text{exact}}=b_2,\\quad \\gamma_{xy}^{\\text{exact}}=a_2+b_1.\n$$\n\n实现并评估以下检验：\n\n- 插值仿射不变性检验（单个单元）：对于每个映射 $\\mathcal{A}_k$，通过映射四个参考角点 $(-1,-1)$、$(1,-1)$、$(1,1)$、$(-1,1)$ 来构造一个单一的双线性四边形单元。通过在物理节点坐标处评估给定的线性场来计算节点位移值。对于四个参考采样点 $(\\xi,\\eta)\\in\\{(0,0),\\, (1/\\sqrt{3},-1/\\sqrt{3}),\\, (-0.3,0.9),\\, (0.8,0.1)\\}$，评估 $(u,v)$ 的等参插值，并将其与在映射后的物理点处评估的精确 $(u,v)$进行比较。为每个映射报告一个布尔值，指示四个点上的最大绝对分量误差是否最多为 $\\varepsilon_{\\text{interp}}=10^{-10}$。\n\n- 应变仿射不变性检验（单个单元）：对于每个映射 $\\mathcal{A}_k$，使用与上述相同的单元和节点位移值，构造应变-位移矩阵 $B$ 并计算在 $(\\xi,\\eta)=(0,0)$ 处的有限元应变 $\\varepsilon=B\\,d_e$。为每个映射报告一个布尔值，指示误差的欧几里得范数 $\\|\\varepsilon-\\varepsilon^{\\text{exact}}\\|_2$ 是否最多为 $\\varepsilon_{\\text{strain}}=\\varepsilon_{\\text{abs}}+\\varepsilon_{\\text{rel}}\\|\\varepsilon^{\\text{exact}}\\|_2$，其中 $\\varepsilon_{\\text{abs}}=10^{-12}$ 和 $\\varepsilon_{\\text{rel}}=10^{-8}$。\n\n- 积分一致性检验（单个单元）：对于映射 $\\mathcal{A}_2$，分别使用 $1\\times 1$ 高斯积分和 $2\\times 2$ 高斯积分计算单元刚度矩阵 $K_e$。报告一个布尔值，指示相对弗罗贝尼乌斯范数差异是否最多为 $\\varepsilon_{K}=10^{-12}$。\n\n- 在 $2\\times 2$ 网格上的线性分片检验：通过将参考正方形 $[-1,1]\\times[-1,1]$ 细分为四个全等的正方形，节点位于 $3\\times 3$ 网格 $\\{(-1,0,1)\\}\\times\\{(-1,0,1)\\}$ 上，来构建一个 $2\\times 2$ 的双线性四边形单元网格，然后通过 $\\mathcal{A}_3$ 映射所有节点。使用平面应力本构模型（$E=1.0$，$\\nu=0.25$，厚度 $t=1$）组装全局刚度矩阵。通过在所有边界节点上规定精确位移值来施加狄利克雷边界条件。让内部节点自由，其位移等于精确值。用零外力形成全局内力向量 $f^{\\text{int}}=K\\,d$。报告一个布尔值，指示两个内部自由度上残差的欧几里得范数是否最多为 $\\varepsilon_{\\text{patch}}=10^{-12}$。\n\n您的程序必须根据上述定义实现这些功能，并生成一行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。结果必须按以下顺序排列：\n$[\\text{I}_1,\\text{I}_2,\\text{I}_3,\\text{I}_4,\\text{S}_1,\\text{S}_2,\\text{S}_3,\\text{S}_4,\\text{K}_{\\text{consistency}},\\text{P}_{\\text{patch}}]$，\n其中 $\\text{I}_k$ 是插值检验的布尔值，$\\text{S}_k$ 是应变检验的布尔值，$\\text{K}_{\\text{consistency}}$ 是积分一致性检验的布尔值，$\\text{P}_{\\text{patch}}$ 是分片检验的布尔值。程序必须是自包含的，并且无需用户输入即可运行。\n\n测试套件摘要：\n- 仿射映射：如上指定的 $\\mathcal{A}_1$、$\\mathcal{A}_2$、$\\mathcal{A}_3$、$\\mathcal{A}_4$。\n- 采样点：$(0,0)$、$(1/\\sqrt{3},-1/\\sqrt{3})$、$(-0.3,0.9)$、$(0.8,0.1)$。\n- 位移系数：$a_0=0.1$、$a_1=0.2$、$a_2=-0.3$、$b_0=-0.05$、$b_1=0.4$、$b_2=0.25$。\n- 平面应力参数：$E=1.0$，$\\nu=0.25$，厚度 $t=1$。\n- 容差：$\\varepsilon_{\\text{interp}}=10^{-10}$，$\\varepsilon_{\\text{abs}}=10^{-12}$，$\\varepsilon_{\\text{rel}}=10^{-8}$，$\\varepsilon_{K}=10^{-12}$，$\\varepsilon_{\\text{patch}}=10^{-12}$。\n\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[true,false,true,...]\"）。", "solution": "所提供的问题是一个为双线性等参四边形有限元设计的、定义明确且科学合理的验证套件。它测试了正确实现所需的基本属性，即精确表示线性位移场（插值）的能力、精确再现由这些场产生的恒定应变状态（应变不变性）的能力、在特定情况下刚度矩阵公式在不同数值积分方案下的一致性，以及一组单元在恒定应变状态下满足平衡（分片检验）。所有必需的定义和数据均已提供，并且检验的结构旨在产生清晰、可验证的布尔结果。该问题是有效的，可以按所述方式解决。\n\n该解决方案是通过根据问题陈述中指定的第一性原理，实现等参有限元方法的核心组件来构建的。\n\n### 1. 基础实现：形函数和等参映射\n\n起点是 $(\\xi, \\eta)$ 局部坐标系中的参考方形单元，其中 $\\xi, \\eta \\in [-1, 1]$。四个节点从 $(-1, -1)$ 开始逆时针排序。双线性拉格朗日形函数 $N_i(\\xi, \\eta)$ 定义为：\n$$\n\\begin{aligned}\nN_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta) \\\\\nN_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta) \\\\\nN_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta) \\\\\nN_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n\\end{aligned}\n$$\n这些函数在节点坐标 $(\\xi_j, \\eta_j)$ 处满足克罗内克-德尔塔性质，$N_i(\\xi_j, \\eta_j) = \\delta_{ij}$。一个关键性质是单位分解：对于所有的 $(\\xi, \\eta)$，$\\sum_{i=1}^{4} N_i(\\xi, \\eta) = 1$。\n\n等参映射使用这些相同的形函数将局部坐标关联到物理坐标 $(x, y)$：\n$$\nx(\\xi,\\eta)=\\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,X_i, \\qquad y(\\xi,\\eta)=\\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,Y_i\n$$\n其中 $(X_i, Y_i)$ 是节点 $i$ 的物理坐标。当物理单元是通过对参考单元进行仿射映射 $x=A\\hat{x}+t$ 形成时，物理节点坐标为 $X_i=A\\hat{x}_i+t$，其中 $\\hat{x}_i$ 是参考节点坐标。由于形函数能够再现线性函数（特别是 $\\sum N_i \\xi_i = \\xi$ 和 $\\sum N_i \\eta_i = \\eta$），映射简化为：\n$$\nx(\\xi,\\eta) = A \\begin{pmatrix} \\xi \\\\ \\eta \\end{pmatrix} + t\n$$\n因此，此变换的雅可比矩阵 $J = \\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)}$ 对于任何由仿射映射生成的单元都是常数，并且等于矩阵 $A$：\n$$\nJ(\\xi,\\eta) = \\begin{bmatrix} \\partial x/\\partial \\xi & \\partial x/\\partial \\eta \\\\ \\partial y/\\partial \\xi & \\partial y/\\partial \\eta \\end{bmatrix} = A\n$$\n与一般四边形单元（其中 $J$ 将是 $(\\xi, \\eta)$ 的线性函数）相比，这是一个显著的简化。\n\n### 2. 应变分析：B 矩阵和应变再现\n\n小应变张量 $\\varepsilon = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$ 是通过应变-位移矩阵 $B$ 从节点位移 $d_e$ 计算得出的，即 $\\varepsilon = B\\,d_e$。$B$ 矩阵的尺寸为 $3 \\times 8$，由形函数的物理导数 $\\partial N_i/\\partial x$ 和 $\\partial N_i/\\partial y$ 构成。这些导数是使用雅可比矩阵的逆从局部坐标导数获得的：\n$$\n\\begin{pmatrix} \\partial N_i/\\partial x \\\\ \\partial N_i/\\partial y \\end{pmatrix} = J^{-1} \\begin{pmatrix} \\partial N_i/\\partial \\xi \\\\ \\partial N_i/\\partial \\eta \\end{pmatrix} = A^{-1} \\begin{pmatrix} \\partial N_i/\\partial \\xi \\\\ \\partial N_i/\\partial \\eta \\end{pmatrix}\n$$\n由于导数 $\\partial N_i/\\partial \\xi$ 和 $\\partial N_i/\\partial \\eta$ 是 $\\xi$ 和 $\\eta$ 的线性函数，且 $A^{-1}$ 是常数，因此物理导数 $\\partial N_i/\\partial x$ 和 $\\partial N_i/\\partial y$ 也是 $\\xi, \\eta$ 的线性函数。$B$ 矩阵通过为每个节点 $i=1..4$ 排列这些导数构成：\n$$\nB_i(\\xi, \\eta) = \\begin{bmatrix} \\partial N_i/\\partial x & 0 \\\\ 0 & \\partial N_i/\\partial y \\\\ \\partial N_i/\\partial y & \\partial N_i/\\partial x \\end{bmatrix}, \\qquad B = [B_1, B_2, B_3, B_4]\n$$\n等参公式的一个基本性质是，它能精确再现其基函数中存在的任何位移场。由于基函数包含线性项，线性场 $u(x,y) = a_0+a_1x+a_2y$ 可以被精确插值。因此，其导数也被精确再现。计算出的应变向量 $\\varepsilon(\\xi,\\eta) = B(\\xi,\\eta) d_e$ 将在整个单元内保持恒定，并等于精确应变向量 $[\\varepsilon_{xx}^{\\text{exact}}, \\varepsilon_{yy}^{\\text{exact}}, \\gamma_{xy}^{\\text{exact}}]^T = [a_1, b_2, a_2+b_1]^T$。\n\n### 3. 验证检验\n\n该问题规定了四个检验来数值验证这些属性。\n\n**插值和应变不变性检验：** 这些检验确认了上述属性。对于每个仿射映射 $\\mathcal{A}_k$，我们形成一个单元。节点位移由给定的线性场计算。在各个采样点处的插值位移应与精确场在机器精度内匹配。类似地，在单元中心计算的应变应在指定的容差内与恒定的精确应变向量匹配。对于所有非退化的仿射映射，这些检验预计都将通过。\n\n**积分一致性检验：** 此检验比较了使用两种不同的高斯积分法则（$1 \\times 1$ 和 $2 \\times 2$）计算的单元刚度矩阵 $K_e$。刚度矩阵由以下积分给出：\n$$\nK_e=\\int_{-1}^{1}\\int_{-1}^{1} B^T(\\xi,\\eta) D B(\\xi,\\eta) \\,\\det(J)\\, d\\xi\\, d\\eta\n$$\n这里，$D$ 是常数平面应力本构矩阵，$\\det(J) = \\det(A)$ 是常数。$B$ 矩阵的项是 $\\xi$ 和 $\\eta$ 的线性函数。因此，被积函数 $B^T D B$ 是一个关于 $\\xi$ 和 $\\eta$ 的二次多项式矩阵。一个 $2 \\times 2$ 高斯积分法则能精确积分最高 3 次的多项式，因此它将精确计算 $K_e$ 的积分。一个 $1 \\times 1$ 法则仅对最高 1 次的多项式是精确的。由于被积函数是二次的，一般情况下 $1 \\times 1$ 法则不会得到精确的积分。因此，两个计算出的刚度矩阵 $K_{e,1 \\times 1}$ 和 $K_{e,2 \\times 2}$ 预计不会相同。该检验将按规定实施，其布尔结果将反映这一数学事实。\n\n**线性分片检验：** 此检验验证了单元集合能够共同再现恒定应变状态，而不会产生伪节点力。创建一个 $2 \\times 2$ 的网格，并由 $\\mathcal{A}_3$ 进行映射。我们为所有节点规定来自线性场的精确位移。全局内力向量计算为 $f^{\\text{int}} = K d$。如果无约束内部节点的自由度上的力为零（在机器精度内），则分片检验通过。由于双线性单元可以精确再现恒定应变状态，内应力场处于平衡状态，任何自由节点上的合力必须为零。只要使用足够精确的积分法则来计算单元刚度矩阵，此检验应能通过。$2 \\times 2$ 积分法则对于这些平行四边形单元是精确的，因此是合适的选择。\n\n实现将通过为每个数学构造和检验创建函数来进行。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all verification tests for a bilinear isoparametric quadrilateral element.\n    \"\"\"\n\n    # --- Problem Givens ---\n\n    # Affine Mappings: x = A*x_hat + t\n    mappings = {\n        'A1': (np.array([[1.0, 0.0], [0.0, 1.0]]), np.array([0.0, 0.0])),\n        'A2': (np.array([[1.7320508075688772, -0.25], [1.0, 0.4330127018922193]]), np.array([0.0, 0.0])),\n        'A3': (np.array([[1.5, 0.9], [0.0, 1.5]]), np.array([0.3, -0.2])),\n        'A4': (np.array([[1.0, 0.3], [0.0, 0.001]]), np.array([0.0, 0.0]))\n    }\n\n    # Linear Displacement Field Coefficients\n    disp_coeffs = {'a0': 0.1, 'a1': 0.2, 'a2': -0.3, 'b0': -0.05, 'b1': 0.4, 'b2': 0.25}\n\n    # Material and Geometric Properties for Stiffness\n    E, nu, thickness = 1.0, 0.25, 1.0\n\n    # Test Tolerances\n    epsilon_interp = 1e-10\n    epsilon_strain_abs = 1e-12\n    epsilon_strain_rel = 1e-8\n    epsilon_K = 1e-12\n    epsilon_patch = 1e-12\n    \n    # Reference element nodes\n    ref_nodes = np.array([[-1.0, -1.0], [1.0, -1.0], [1.0, 1.0], [-1.0, 1.0]])\n\n    # --- Core FEM Functions ---\n\n    def shape_functions(xi, eta):\n        return 0.25 * np.array([\n            (1-xi)*(1-eta),\n            (1+xi)*(1-eta),\n            (1+xi)*(1+eta),\n            (1-xi)*(1+eta)\n        ])\n\n    def shape_function_derivatives(xi, eta):\n        # Returns derivatives wrt xi and eta for each shape function\n        # Shape: (4, 2) where row i is [dNi/dxi, dNi/deta]\n        return 0.25 * np.array([\n            [-(1-eta), -(1-xi)],\n            [ (1-eta), -(1+xi)],\n            [ (1+eta),  (1+xi)],\n            [-(1+eta),  (1-xi)]\n        ])\n\n    def get_B_matrix(xi, eta, node_coords):\n        dN_dxieta = shape_function_derivatives(xi, eta)\n        \n        # For an affine map x = A*xi + t, the Jacobian J = A\n        # Here we compute it generally for correctness.\n        # J = node_coords.T @ dN_dxieta would be correct due to specific data structure\n        # Let's use the property J = A for affine mappings for robustness and simplicity\n        # Element nodes are X_i = A*ref_nodes_i + t\n        # x(xi,eta) = sum(N_i * X_i) = A * sum(N_i*ref_nodes_i) + t * sum(N_i) = A*[xi,eta]^T + t\n        # So J = A. We need A. We can recover A from node_coords.\n        # X1 = A*[-1,-1]+t, X2=A*[1,-1]+t, X4=A*[-1,1]+t\n        # X2-X1 = A*[2,0], X4-X1 = A*[0,2]\n        # A_col1 = (X2-X1)/2, A_col2 = (X4-X1)/2\n        A = np.zeros((2, 2))\n        A[:, 0] = (node_coords[1] - node_coords[0]) / 2.0\n        A[:, 1] = (node_coords[3] - node_coords[0]) / 2.0\n        \n        J_inv = np.linalg.inv(A)\n        \n        # Derivatives wrt x, y\n        # dN_dxy = dN_dxieta @ J_inv.T\n        dN_dxy = dN_dxieta @ J_inv.T\n\n        B = np.zeros((3, 8))\n        for i in range(4):\n            B[0, 2*i]     = dN_dxy[i, 0]\n            B[1, 2*i + 1] = dN_dxy[i, 1]\n            B[2, 2*i]     = dN_dxy[i, 1]\n            B[2, 2*i + 1] = dN_dxy[i, 0]\n        return B\n\n    def get_constitutive_matrix(E, nu):\n        factor = E / (1 - nu**2)\n        return factor * np.array([\n            [1, nu, 0],\n            [nu, 1, 0],\n            [0, 0, (1 - nu) / 2.]\n        ])\n\n    def exact_displacement(x, y, coeffs):\n        u = coeffs['a0'] + coeffs['a1'] * x + coeffs['a2'] * y\n        v = coeffs['b0'] + coeffs['b1'] * x + coeffs['b2'] * y\n        return np.array([u, v])\n\n    def exact_strain(coeffs):\n        return np.array([\n            coeffs['a1'],\n            coeffs['b2'],\n            coeffs['a2'] + coeffs['b1']\n        ])\n\n    # --- Test Implementations ---\n\n    def run_interpolation_test(A, t, coeffs, tol):\n        phys_nodes = (A @ ref_nodes.T).T + t\n        nodal_disps = np.zeros((4, 2))\n        for i in range(4):\n            nodal_disps[i, :] = exact_displacement(phys_nodes[i, 0], phys_nodes[i, 1], coeffs)\n\n        sample_points = [(0, 0), (1/np.sqrt(3), -1/np.sqrt(3)), (-0.3, 0.9), (0.8, 0.1)]\n        max_err = 0.0\n\n        for xi, eta in sample_points:\n            N = shape_functions(xi, eta)\n            phys_pt = N @ phys_nodes\n            interp_disp = N @ nodal_disps\n            exact_disp = exact_displacement(phys_pt[0], phys_pt[1], coeffs)\n            \n            err = np.max(np.abs(interp_disp - exact_disp))\n            if err > max_err:\n                max_err = err\n        \n        return max_err = tol\n\n    def run_strain_test(A, t, coeffs, tol_abs, tol_rel):\n        phys_nodes = (A @ ref_nodes.T).T + t\n        d_e = np.zeros(8)\n        for i in range(4):\n            disp = exact_displacement(phys_nodes[i, 0], phys_nodes[i, 1], coeffs)\n            d_e[2*i] = disp[0]\n            d_e[2*i+1] = disp[1]\n\n        xi, eta = 0.0, 0.0\n        B = get_B_matrix(xi, eta, phys_nodes)\n        fe_strain = B @ d_e\n        \n        true_strain = exact_strain(coeffs)\n        \n        err_norm = np.linalg.norm(fe_strain - true_strain)\n        tolerance = tol_abs + tol_rel * np.linalg.norm(true_strain)\n        \n        return err_norm = tolerance\n\n    def compute_element_stiffness(phys_nodes, D, thickness, qp_points, qp_weights):\n        Ke = np.zeros((8, 8))\n        for i in range(len(qp_points)):\n            xi, eta = qp_points[i]\n            w = qp_weights[i]\n            \n            # Recompute A for Jacobian for generality/safety, although it's constant\n            A = np.zeros((2, 2))\n            A[:, 0] = (phys_nodes[1] - phys_nodes[0]) / 2.0\n            A[:, 1] = (phys_nodes[3] - phys_nodes[0]) / 2.0\n            detJ = np.linalg.det(A)\n            \n            B = get_B_matrix(xi, eta, phys_nodes)\n            Ke += B.T @ D @ B * detJ * w * thickness\n        return Ke\n        \n    def run_quadrature_test(A, t, E, nu, thickness, tol):\n        phys_nodes = (A @ ref_nodes.T).T + t\n        D = get_constitutive_matrix(E, nu)\n        \n        # 1x1 Quadrature\n        qp1 = [(0.0, 0.0)]\n        qw1 = [4.0]\n        K1 = compute_element_stiffness(phys_nodes, D, thickness, qp1, qw1)\n        \n        # 2x2 Quadrature\n        p = 1.0 / np.sqrt(3)\n        qp2 = [(-p, -p), (p, -p), (p, p), (-p, p)]\n        qw2 = [1.0, 1.0, 1.0, 1.0]\n        K2 = compute_element_stiffness(phys_nodes, D, thickness, qp2, qw2)\n        \n        diff_norm = np.linalg.norm(K1 - K2, 'fro')\n        norm_K2 = np.linalg.norm(K2, 'fro')\n        \n        if norm_K2 == 0: return diff_norm = tol # Should not happen\n        return (diff_norm / norm_K2) = tol\n\n    def run_patch_test(A, t, coeffs, E, nu, thickness, tol):\n        # 2x2 mesh on [-1,1]x[-1,1] reference domain, mapped by A, t\n        ref_grid_pts = np.array([\n            [-1,-1], [0,-1], [1,-1],\n            [-1, 0], [0, 0], [1, 0],\n            [-1, 1], [0, 1], [1, 1]\n        ])\n        \n        phys_grid_pts = (A @ ref_grid_pts.T).T + t\n        \n        # Node connectivity for 4 elements (0-indexed)\n        # Elem 1 (BL), 2(BR), 3(TL), 4(TR)\n        # My previous thought was: Elem 1: 0,1,4,3, Elem 2: 1,2,5,4, Elem 3: 3,4,7,6, Elem 4: 4,5,8,7\n        # Correctly following the node numbering of the grid:\n        # e.g., 0,1,2 / 3,4,5 / 6,7,8 -> Elem BL uses nodes 0,1,4,3.\n        connectivity = [\n            [0, 1, 4, 3], # Bottom-left\n            [1, 2, 5, 4], # Bottom-right\n            [3, 4, 7, 6], # Top-left\n            [4, 5, 8, 7]  # Top-right\n        ]\n        \n        D = get_constitutive_matrix(E, nu)\n        \n        # Quadrature for assembly (2x2 is standard for full integration)\n        p = 1.0 / np.sqrt(3)\n        qp2 = [(-p, -p), (p, -p), (p, p), (-p, p)]\n        qw2 = [1.0, 1.0, 1.0, 1.0]\n        \n        K_global = np.zeros((18, 18))\n        \n        # Assembly\n        for elem_nodes_g_idx in connectivity:\n            phys_nodes_elem = phys_grid_pts[elem_nodes_g_idx, :]\n            Ke = compute_element_stiffness(phys_nodes_elem, D, thickness, qp2, qw2)\n            \n            dof_map = []\n            for node_idx in elem_nodes_g_idx:\n                dof_map.extend([2*node_idx, 2*node_idx + 1])\n            \n            for i_loc in range(8):\n                for j_loc in range(8):\n                    i_glob = dof_map[i_loc]\n                    j_glob = dof_map[j_loc]\n                    K_global[i_glob, j_glob] += Ke[i_loc, j_loc]\n                    \n        # Global displacement vector d\n        d_global = np.zeros(18)\n        for i in range(9):\n            disp = exact_displacement(phys_grid_pts[i,0], phys_grid_pts[i,1], coeffs)\n            d_global[2*i] = disp[0]\n            d_global[2*i+1] = disp[1]\n\n        # Internal forces F_int = K*d\n        f_internal = K_global @ d_global\n        \n        # Check residual at interior node (node 4, DOFs 8 and 9)\n        interior_node_idx = 4\n        residual = f_internal[2*interior_node_idx : 2*interior_node_idx + 2]\n        \n        return np.linalg.norm(residual) = tol\n\n    # --- Execute Tests and Collect Results ---\n    \n    results = []\n\n    # Interpolation tests\n    for k in ['A1', 'A2', 'A3', 'A4']:\n        A, t = mappings[k]\n        results.append(run_interpolation_test(A, t, disp_coeffs, epsilon_interp))\n        \n    # Strain tests\n    for k in ['A1', 'A2', 'A3', 'A4']:\n        A, t = mappings[k]\n        results.append(run_strain_test(A, t, disp_coeffs, epsilon_strain_abs, epsilon_strain_rel))\n\n    # Quadrature consistency test\n    A_q, t_q = mappings['A2']\n    results.append(run_quadrature_test(A_q, t_q, E, nu, thickness, epsilon_K))\n\n    # Patch test\n    A_p, t_p = mappings['A3']\n    results.append(run_patch_test(A_p, t_p, disp_coeffs, E, nu, thickness, epsilon_patch))\n\n    # --- Format and Print Final Output ---\n    # Convert booleans to lowercase strings as per Python's str(True) -> 'True' -> 'true'\n    str_results = [str(r).lower() for r in results]\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```", "id": "3525426"}, {"introduction": "许多物理现象涉及矢量场，例如流体通量或电场，这超出了位移等标量场的范畴。为了确保质量守恒等物理定律得到遵守，映射这些场需要一种特殊的变换（Piola 变换）。本实践要求你在一个 $H(\\mathrm{div})$ 整合空间中实现矢量场的映射，并在一个弯曲单元上数值验证散度定理。这个练习对于理解如何在多物理场模拟中建立局部守恒格式至关重要 [@problem_id:3525417]。", "problem": "考虑单个二维曲线四边形单元上的稳态 Darcy-热输运耦合问题。流体质量守恒由散度形式控制，热输运包含一个对流贡献项。离散化采用混合方法，对 Darcy 通量使用平方可积散度的 Sobolev 空间 (H(div))，对温度使用一阶 Sobolev 空间 (H$^1$)。几何形状通过从参考正方形出发的等参双线性映射表示，该映射使用双线性形函数。\n\n从以下基本和核心定义出发：\n- 矢量场的散度定理指出，一个域上散度的积分等于其边界上的外向法向通量积分。\n- 等参概念使用同一族形函数来描述几何形状和场，将参考单元映射到物理单元。\n- H(div) 中的最低阶混合 Raviart–Thomas 方法（在参考单元上每个面具有分片常数法向通量）支持法向通量自由度和分片常数散度。\n- 热输运对温度使用带有双线性形函数的 H$^1$ 空间，从而可以在单元内计算梯度。\n\n你需要通过以下步骤，对弯曲（非仿射）四边形单元实现局部守恒的计算检验：\n1. 使用从坐标为 $(\\xi,\\eta) \\in [-1,1]^2$ 的参考正方形出发的等参双线性映射来表示物理四边形。\n2. 在参考单元上构建一个最低阶 Raviart–Thomas 通量，其在每个参考面上的法向通量为常数。设参考通量为一个形式为 $\\hat{\\boldsymbol{q}}(\\xi,\\eta) = [a + b\\,\\xi,\\;c + d\\,\\eta]$ 的矢量场，其四个参考面上的面积分法向通量自由度为给定值。根据散度定理，参考单元上散度的积分是一个常数，且必须等于各面积分法向通量之和。\n3. 通过等参双线性映射和适用于 H(div) 的相关变换，将参考通量映射到物理单元，并计算沿物理边界（按逆时针方向）积分的外向法向通量。\n4. 在物理坐标中定义一个源项，使得局部守恒在连续层面上成立。然后，数值计算该源项在物理单元上的面积分，并与边界通量积分进行比较，从而在数值上验证局部守恒。\n5. 在相同的几何形状上，使用双线性形函数引入一个 H$^1$ 温度场并计算其梯度，从而展示混合 H(div)/H$^1$ 离散化背景。对流项无需报告；只需在内部计算梯度，以确保梯度计算与映射一致。\n\n你的程序必须：\n- 为四边形顶点实现带有形函数 $N_i(\\xi,\\eta)$ 的双线性等参映射，并计算雅可比矩阵 $\\boldsymbol{J}(\\xi,\\eta)$ 及其行列式。\n- 根据参考单元上给定的面积分法向通量，构建参考 Raviart–Thomas 系数 $(a,b,c,d)$。\n- 将参考通量映射到物理单元并执行数值积分：\n  - 对于边界通量积分，通过以逆时针方向参数化四个物理边，并使用旋转切线公式计算外向法向测度，来积分 $ \\int_{\\partial \\Omega} \\boldsymbol{q} \\cdot \\boldsymbol{n}\\, \\mathrm{d}s $。\n  - 对于源项积分，使用在参考正方形上的积分法，并带有适当的雅可比行列式加权，来积分 $ \\int_{\\Omega} f\\, \\mathrm{d}\\Omega $。\n- 对每个测试用例，返回绝对残差 $R = \\left| \\int_{\\partial \\Omega} \\boldsymbol{q} \\cdot \\boldsymbol{n}\\,\\mathrm{d}s \\;-\\; \\int_{\\Omega} f\\, \\mathrm{d}\\Omega \\right|$，其形式为一个浮点数。\n\n本练习中所有量均视为无量纲；无需物理单位。角度不出现，也无需指定。你的程序必须生成单行输出，其中包含所有测试用例的残差，形式为方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$）。\n\n在参考正方形上使用以下双线性形函数：\n$$\nN_1(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_3(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1+\\eta).\n$$\n\n将参考 Raviart–Thomas 面积分法向通量自由度定义为分别在左、右、下、上四个面上给定的四个数值。参考矢量场为 $\\hat{\\boldsymbol{q}}(\\xi,\\eta) = [a + b\\,\\xi,\\;c + d\\,\\eta]$，其中 $(a,b,c,d)$ 由这四个给定的面积分通量唯一确定。\n\n对于源项，定义 $f(\\boldsymbol{x}(\\xi,\\eta))$ 使得 $f(\\boldsymbol{x}(\\xi,\\eta)) = \\dfrac{b+d}{\\det \\boldsymbol{J}(\\xi,\\eta)}$，这确保了对于任何非仿射双线性映射，物理映射后的散度积分与边界通量积分一致。程序应在单元内部和每条边上使用足够精度的高斯积分来计算这些积分。\n\n测试套件：\n提供四个测试用例，每个用例包含物理四边形的四个顶点坐标（按逆时针顺序）和四个参考面积分法向通量 $(F_{\\text{left}},F_{\\text{right}},F_{\\text{bottom}},F_{\\text{top}})$：\n\n- 案例 1（非仿射、扭曲的四边形；常规“顺利通过”路径）：\n  - 顶点：$(0,0)$, $(2,0.2)$, $(2.1,1.9)$, $(0.1,2.0)$。\n  - 参考面积分通量：$F_{\\text{left}} = 0.7$, $F_{\\text{right}} = 1.1$, $F_{\\text{bottom}} = -0.4$, $F_{\\text{top}} = 0.2$。\n\n- 案例 2（仿射平行四边形；雅可比行列式为常数）：\n  - 顶点：$(0,0)$, $(1.5,0.0)$, $(2.2,1.0)$, $(0.7,1.0)$。\n  - 参考面积分通量：$F_{\\text{left}} = -0.3$, $F_{\\text{right}} = 0.6$, $F_{\\text{bottom}} = 0.15$, $F_{\\text{top}} = -0.05$。\n\n- 案例 3（倾斜但有效；零通量边界情况）：\n  - 顶点：$(0,0)$, $(1.0,0.0)$, $(1.1,0.2)$, $(0.2,1.1)$。\n  - 参考面积分通量：$F_{\\text{left}} = 0.0$, $F_{\\text{right}} = 0.0$, $F_{\\text{bottom}} = 0.0$, $F_{\\text{top}} = 0.0$。\n\n- 案例 4（强扭曲四边形；敏感的雅可比行列式变化）：\n  - 顶点：$(0,0)$, $(2.0,-0.2)$, $(2.2,1.8)$, $(0.0,2.1)$。\n  - 参考面积分通量：$F_{\\text{left}} = 1.0$, $F_{\\text{right}} = -0.5$, $F_{\\text{bottom}} = 0.3$, $F_{\\text{top}} = -0.1$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含案例 1 到 4 的结果，形式为方括号括起来的浮点残差的逗号分隔列表；例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是上面定义的绝对残差。不应打印任何其他文本。", "solution": "用户提供的问题是偏微分方程数值方法领域，特别是有限元法（FEM）中一个有效、适定的计算练习。它要求实现和验证与 H(div) 协调矢量场的等参映射相关的基本概念。该问题在科学上是合理的、自洽的，并且提供了求解所需的所有数据和定义。我们将着手提供一个完整的解决方案。\n\n问题的核心是在单个、一般的曲线四边形单元上数值验证散度定理。该定理指出，对于域 $\\Omega$（其边界为 $\\partial \\Omega$）上的一个足够光滑的矢量场 $\\boldsymbol{q}$，以下恒等式成立：\n$$\n\\int_{\\Omega} (\\nabla \\cdot \\boldsymbol{q}) \\, d\\Omega = \\int_{\\partial \\Omega} \\boldsymbol{q} \\cdot \\boldsymbol{n} \\, ds\n$$\n其中 $\\boldsymbol{n}$ 是边界的外向单位法向量。问题定义了一个源项 $f = \\nabla \\cdot \\boldsymbol{q}$，因此需要验证的恒等式是 $\\int_{\\Omega} f \\, d\\Omega = \\int_{\\partial \\Omega} \\boldsymbol{q} \\cdot \\boldsymbol{n} \\, ds$。验证过程包括通过数值积分独立计算这两个积分，并比较其结果。\n\n以下是所需计算的分步推导和解释。\n\n### 1. 等参映射与几何因子\n\n物理四边形单元 $\\Omega$ 的几何形状由一个从参考正方形 $\\hat{\\Omega} = [-1,1]^2$（局部坐标为 $(\\xi, \\eta)$）出发的等参映射所描述。该映射 $\\boldsymbol{x}: \\hat{\\Omega} \\to \\Omega$ 由下式给出：\n$$\n\\boldsymbol{x}(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) \\boldsymbol{x}_i\n$$\n其中 $\\boldsymbol{x}_i = (x_i, y_i)$ 是物理单元四个顶点的坐标，而 $N_i$ 是所提供的双线性形函数：\n$$\nN_1 = \\tfrac{1}{4}(1-\\xi)(1-\\eta), \\quad N_2 = \\tfrac{1}{4}(1+\\xi)(1-\\eta), \\quad N_3 = \\tfrac{1}{4}(1+\\xi)(1+\\eta), \\quad N_4 = \\tfrac{1}{4}(1-\\xi)(1+\\eta)\n$$\n变换的局部行为由雅可比矩阵 $\\boldsymbol{J}$ 表征，其分量是映射函数的偏导数：\n$$\n\\boldsymbol{J}(\\xi, \\eta) = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} \\sum_i \\frac{\\partial N_i}{\\partial \\xi} x_i  \\sum_i \\frac{\\partial N_i}{\\partial \\eta} x_i \\\\ \\sum_i \\frac{\\partial N_i}{\\partial \\xi} y_i  \\sum_i \\frac{\\partial N_i}{\\partial \\eta} y_i \\end{pmatrix}\n$$\n雅可比行列式 $\\det \\boldsymbol{J}$ 关联了微分面积元：$d\\Omega = \\det \\boldsymbol{J}(\\xi, \\eta) \\, d\\xi d\\eta$。\n\n### 2. 最低阶 Raviart–Thomas (RT$_0$) 通量\n\n在参考单元上，一个矢量场 $\\hat{\\boldsymbol{q}}$ 定义在最低阶 Raviart–Thomas 空间中。其形式如下：\n$$\n\\hat{\\boldsymbol{q}}(\\xi, \\eta) = \\begin{pmatrix} a + b\\xi \\\\ c + d\\eta \\end{pmatrix}\n$$\n四个系数 $(a,b,c,d)$ 由四个自由度唯一确定，这些自由度是参考正方形四个面上的积分法向通量。设给定的通量为 $F_{\\text{left}}, F_{\\text{right}}, F_{\\text{bottom}}, F_{\\text{top}}$。关系如下：\n- 左面 $(\\xi=-1)$: $\\int_{-1}^1 \\hat{\\boldsymbol{q}}(-1, \\eta) \\cdot \\begin{pmatrix}-1 \\\\ 0\\end{pmatrix} d\\eta = \\int_{-1}^1 -(a-b) \\, d\\eta = -2(a-b) = F_{\\text{left}}$\n- 右面 $(\\xi=1)$: $\\int_{-1}^1 \\hat{\\boldsymbol{q}}(1, \\eta) \\cdot \\begin{pmatrix}1 \\\\ 0\\end{pmatrix} d\\eta = \\int_{-1}^1 (a+b) \\, d\\eta = 2(a+b) = F_{\\text{right}}$\n- 下面 $(\\eta=-1)$: $\\int_{-1}^1 \\hat{\\boldsymbol{q}}(\\xi, -1) \\cdot \\begin{pmatrix}0 \\\\ -1\\end{pmatrix} d\\xi = \\int_{-1}^1 -(c-d) \\, d\\xi = -2(c-d) = F_{\\text{bottom}}$\n- 上面 $(\\eta=1)$: $\\int_{-1}^1 \\hat{\\boldsymbol{q}}(\\xi, 1) \\cdot \\begin{pmatrix}0 \\\\ 1\\end{pmatrix} d\\xi = \\int_{-1}^1 (c+d) \\, d\\xi = 2(c+d) = F_{\\text{top}}$\n\n解此线性方程组可得系数：\n$$\na = \\frac{F_{\\text{right}} - F_{\\text{left}}}{4}, \\quad b = \\frac{F_{\\text{right}} + F_{\\text{left}}}{4}, \\quad c = \\frac{F_{\\text{top}} - F_{\\text{bottom}}}{4}, \\quad d = \\frac{F_{\\text{top}} + F_{\\text{bottom}}}{4}\n$$\n\n### 3. 源项及其积分\n\n源项 $f$ 的定义是为了确保局部守恒，即 $f = \\nabla \\cdot \\boldsymbol{q}$。一个 H(div) 场的散度通过 Piola 恒等式从参考单元变换而来：$\\nabla \\cdot \\boldsymbol{q} = (\\det \\boldsymbol{J})^{-1} (\\hat{\\nabla} \\cdot \\hat{\\boldsymbol{q}})$。对于我们的参考场，其散度为 $\\hat{\\nabla} \\cdot \\hat{\\boldsymbol{q}} = \\frac{\\partial}{\\partial\\xi}(a+b\\xi) + \\frac{\\partial}{\\partial\\eta}(c+d\\eta) = b+d$。因此，源项为：\n$$\nf(\\boldsymbol{x}(\\xi, \\eta)) = \\frac{b+d}{\\det \\boldsymbol{J}(\\xi, \\eta)}\n$$\n此源项在物理单元 $\\Omega$ 上的积分通过换元到参考单元 $\\hat{\\Omega}$ 来计算：\n$$\nI_{\\text{src}} = \\int_{\\Omega} f \\, d\\Omega = \\int_{-1}^1 \\int_{-1}^1 f(\\boldsymbol{x}(\\xi, \\eta)) \\det \\boldsymbol{J}(\\xi, \\eta) \\, d\\xi d\\eta = \\int_{-1}^1 \\int_{-1}^1 \\left(\\frac{b+d}{\\det \\boldsymbol{J}}\\right) \\det \\boldsymbol{J} \\, d\\xi d\\eta = \\int_{-1}^1 \\int_{-1}^1 (b+d) \\, d\\xi d\\eta\n$$\n该积分的解析结果为 $4(b+d)$。根据问题的要求，将使用二维高斯积分法进行计算，以测试积分机制。\n\n### 4. 边界通量积分\n\n边界积分 $I_{\\text{bnd}} = \\int_{\\partial \\Omega} \\boldsymbol{q} \\cdot \\boldsymbol{n} \\, ds$ 是通过对物理四边形四条边上的积分求和来计算的。物理通量 $\\boldsymbol{q}$ 是使用协变矢量的 Piola 变换从参考通量 $\\hat{\\boldsymbol{q}}$ 得到的：\n$$\n\\boldsymbol{q}(\\boldsymbol{x}(\\xi, \\eta)) = \\frac{1}{\\det \\boldsymbol{J}(\\xi, \\eta)} \\boldsymbol{J}(\\xi, \\eta) \\hat{\\boldsymbol{q}}(\\xi, \\eta)\n$$\n边界积分通过参数化每条边，并计算物理通量与外向法向微分元的点积来求值。对于一条逆时针遍历的路径 $\\boldsymbol{c}(t)$，外向法向测度由 $(c_y'(t), -c_x'(t)) \\, dt$ 给出。我们将此方法应用于四条边，这些边沿着参考正方形的边界由 $\\xi$ 或 $\\eta$ 参数化。总边界通量是四个一维积分之和，这些积分使用高斯积分法计算。\n\n-   **边 1 (下边, 1→2):** $\\eta=-1$，$\\xi \\in [-1,1]$。法向测度为 $(\\frac{\\partial y}{\\partial \\xi}, -\\frac{\\partial x}{\\partial \\xi}) d\\xi$。\n-   **边 2 (右边, 2→3):** $\\xi=1$，$\\eta \\in [-1,1]$。法向测度为 $(\\frac{\\partial y}{\\partial \\eta}, -\\frac{\\partial x}{\\partial \\eta}) d\\eta$。\n-   **边 3 (上边, 3→4):** $\\eta=1$。路径从 $\\xi=1$ 到 $\\xi=-1$。法向测度为 $(-\\frac{\\partial y}{\\partial \\xi}, \\frac{\\partial x}{\\partial \\xi}) d\\xi$。积分范围从 $\\xi=1$ 到 $-1$。\n-   **边 4 (左边, 4→1):** $\\xi=-1$。路径从 $\\eta=1$ 到 $\\eta=-1$。法向测度为 $(-\\frac{\\partial y}{\\partial \\eta}, \\frac{\\partial x}{\\partial \\eta}) d\\eta$。积分范围从 $\\eta=1$ 到 $-1$。\n\n这些积分可以通过将积分域重新映射到 $[-1,1]$ 并应用标准高斯积分法则来实现。\n\n### 5. H$^1$ (Lagrange) 温度场\n\n作为背景，问题要求考虑一个 H$^1$ 协调温度场，该温度场使用相同的双线性形函数定义：$T(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) T_i$，其中 $T_i$ 是节点温度。物理梯度 $\\nabla T$ 通过 $\\nabla T = \\boldsymbol{J}^{-T} \\hat{\\nabla} T$ 与参考梯度 $\\hat{\\nabla} T$ 相关联。此计算在内部执行，以展示完整的混合元背景，但对最终残差没有贡献。\n\n### 6. 残差计算\n\n最终结果是绝对残差 $R = |I_{\\text{bnd}} - I_{\\text{src}}|$。该值应接近于零，任何非零值都可归因于高斯积分的数值误差，因为根据构造，该恒等式在连续层面上是精确成立的。使用足够高阶的积分将使此误差最小化。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the local conservation residual for a series of curvilinear quadrilaterals.\n    \"\"\"\n\n    # Defines shape functions and their derivatives on the reference square [-1,1]^2\n    N_funcs = [\n        lambda xi, eta: 0.25 * (1 - xi) * (1 - eta),\n        lambda xi, eta: 0.25 * (1 + xi) * (1 - eta),\n        lambda xi, eta: 0.25 * (1 + xi) * (1 + eta),\n        lambda xi, eta: 0.25 * (1 - xi) * (1 + eta)\n    ]\n    # Derivatives w.r.t. xi\n    dN_dxi_funcs = [\n        lambda xi, eta: -0.25 * (1 - eta),\n        lambda xi, eta: 0.25 * (1 - eta),\n        lambda xi, eta: 0.25 * (1 + eta),\n        lambda xi, eta: -0.25 * (1 + eta)\n    ]\n    # Derivatives w.r.t. eta\n    dN_deta_funcs = [\n        lambda xi, eta: -0.25 * (1 - xi),\n        lambda xi, eta: -0.25 * (1 + xi),\n        lambda xi, eta: 0.25 * (1 + xi),\n        lambda xi, eta: 0.25 * (1 - xi)\n    ]\n\n    class IsoparametricQuad:\n        \"\"\"\n        Handles all calculations related to a single isoparametric quadrilateral element.\n        \"\"\"\n        def __init__(self, vertices, n_quad_pts=16):\n            self.vertices = np.array(vertices) # Shape (4, 2)\n            self.x_coords = self.vertices[:, 0]\n            self.y_coords = self.vertices[:, 1]\n            \n            # Gaussian quadrature points and weights for high precision\n            self.xi_pts, self.w_pts = np.polynomial.legendre.leggauss(n_quad_pts)\n\n        def jacobian(self, xi, eta):\n            \"\"\"Computes the Jacobian matrix at a point (xi, eta) in the reference element.\"\"\"\n            dx_dxi = sum(dNi_dxi(xi, eta) * self.x_coords[i] for i, dNi_dxi in enumerate(dN_dxi_funcs))\n            dx_deta = sum(dNi_deta(xi, eta) * self.x_coords[i] for i, dNi_deta in enumerate(dN_deta_funcs))\n            dy_dxi = sum(dNi_dxi(xi, eta) * self.y_coords[i] for i, dNi_dxi in enumerate(dN_dxi_funcs))\n            dy_deta = sum(dNi_deta(xi, eta) * self.y_coords[i] for i, dNi_deta in enumerate(dN_deta_funcs))\n            return np.array([[dx_dxi, dx_deta], [dy_dxi, dy_deta]])\n\n        def jacobian_det(self, xi, eta):\n            \"\"\"Computes the determinant of the Jacobian.\"\"\"\n            J = self.jacobian(xi, eta)\n            return np.linalg.det(J)\n            \n        def compute_temperature_gradient(self, xi, eta, nodal_temps):\n            \"\"\"Computes the physical temperature gradient (for context, not used in residual).\"\"\"\n            J = self.jacobian(xi, eta)\n            det_J = np.linalg.det(J)\n            J_inv_T = (1.0 / det_J) * np.array([[J[1, 1], -J[1, 0]], [-J[0, 1], J[0, 0]]])\n            \n            dT_dxi = sum(dNi_dxi(xi, eta) * nodal_temps[i] for i, dNi_dxi in enumerate(dN_dxi_funcs))\n            dT_deta = sum(dNi_deta(xi, eta) * nodal_temps[i] for i, dNi_deta in enumerate(dN_deta_funcs))\n            \n            grad_T_ref = np.array([dT_dxi, dT_deta])\n            \n            grad_T_phys = J_inv_T @ grad_T_ref\n            return grad_T_phys\n\n\n    def compute_residual(vertices, face_fluxes):\n        \"\"\"\n        Computes the conservation residual for a given element geometry and flux data.\n        R = | integral(div(q)) dV - integral(q.n) dA |\n        \"\"\"\n        F_left, F_right, F_bottom, F_top = face_fluxes\n\n        # 1. Determine Raviart-Thomas coefficients\n        a = (F_right - F_left) / 4.0\n        b = (F_right + F_left) / 4.0\n        c = (F_top - F_bottom) / 4.0\n        d = (F_top + F_bottom) / 4.0\n\n        quad = IsoparametricQuad(vertices)\n\n        # 2. Compute the source integral over the element area\n        # Integrand in reference space is simply (b+d)\n        # Using 2D quadrature as required by the problem statement\n        source_integral = 0.0\n        for i in range(len(quad.xi_pts)):\n            for j in range(len(quad.xi_pts)):\n                w_i = quad.w_pts[i]\n                w_j = quad.w_pts[j]\n                integrand = b + d\n                source_integral += integrand * w_i * w_j\n\n        # This is an internal check for the H1-gradient calculation part of the problem.\n        # This function call is made to satisfy the prompt's requirement but its output is not used further.\n        _ = quad.compute_temperature_gradient(0.5, -0.5, np.array([1.0, 2.0, 3.0, 4.0]))\n\n        # 3. Compute the boundary flux integral\n        def q_phys(xi, eta):\n            q_ref = np.array([a + b * xi, c + d * eta])\n            J = quad.jacobian(xi, eta)\n            det_J = np.linalg.det(J)\n            if abs(det_J)  1e-12: # Avoid division by zero for degenerate mappings\n                return np.array([0.0, 0.0])\n            return (1.0 / det_J) * (J @ q_ref)\n\n        boundary_integral = 0.0\n        # Edge 1 (bottom: eta = -1)\n        for i, xi in enumerate(quad.xi_pts):\n            eta = -1.0\n            J = quad.jacobian(xi, eta)\n            normal_measure = np.array([J[1, 0], -J[0, 0]])\n            boundary_integral += np.dot(q_phys(xi, eta), normal_measure) * quad.w_pts[i]\n            \n        # Edge 2 (right: xi = 1)\n        for i, eta in enumerate(quad.xi_pts):\n            xi = 1.0\n            J = quad.jacobian(xi, eta)\n            normal_measure = np.array([J[1, 1], -J[0, 1]])\n            boundary_integral += np.dot(q_phys(xi, eta), normal_measure) * quad.w_pts[i]\n\n        # Edge 3 (top: eta = 1)\n        for i, xi in enumerate(quad.xi_pts):\n            eta = 1.0\n            J = quad.jacobian(xi, eta)\n            normal_measure = np.array([-J[1, 0], J[0, 0]]) # Outward normal is opposite to bottom\n            boundary_integral += np.dot(q_phys(xi, eta), normal_measure) * quad.w_pts[i]\n\n        # Edge 4 (left: xi = -1)\n        for i, eta in enumerate(quad.xi_pts):\n            xi = -1.0\n            J = quad.jacobian(xi, eta)\n            normal_measure = np.array([-J[1, 1], J[0, 1]]) # Outward normal is opposite to right\n            boundary_integral += np.dot(q_phys(xi, eta), normal_measure) * quad.w_pts[i]\n            \n        # 4. Compute the absolute residual\n        return abs(boundary_integral - source_integral)\n\n    # Test cases from the problem statement\n    test_cases = [\n        {\n            \"vertices\": [(0, 0), (2, 0.2), (2.1, 1.9), (0.1, 2.0)],\n            \"fluxes\": (0.7, 1.1, -0.4, 0.2)\n        },\n        {\n            \"vertices\": [(0, 0), (1.5, 0.0), (2.2, 1.0), (0.7, 1.0)],\n            \"fluxes\": (-0.3, 0.6, 0.15, -0.05)\n        },\n        {\n            \"vertices\": [(0, 0), (1.0, 0.0), (1.1, 0.2), (0.2, 1.1)],\n            \"fluxes\": (0.0, 0.0, 0.0, 0.0)\n        },\n        {\n            \"vertices\": [(0, 0), (2.0, -0.2), (2.2, 1.8), (0.0, 2.1)],\n            \"fluxes\": (1.0, -0.5, 0.3, -0.1)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        residual = compute_residual(case[\"vertices\"], case[\"fluxes\"])\n        results.append(residual)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3525417"}, {"introduction": "等参映射的巧妙之处伴随着一个微妙的问题：映射的雅可比行列式成为被积函数的一部分，可能增加其多项式次数。若未能考虑到这一点，将导致积分误差，从而引入非物理的人为效应。最后一个实践将通过分析一个弯曲高阶单元上的热力学耦合项，来探讨几何与数值积分之间的这种关键联系。你将确定精确积分所需的最低积分阶数，并亲眼见证积分阶数不足会如何影响模拟的准确性 [@problem_id:3525420]。", "problem": "考虑一个用于有限元法 (FEM) 的单参数四边形单元，该单元具有双三次场近似，通常表示为 $Q_3$。参考域是参数坐标 $(\\xi,\\eta)$ 中的正方形 $[-1,1]\\times[-1,1]$。$Q_3$ 单元在每个参数方向上使用节点位于 $\\{-1,-\\tfrac{1}{3},\\tfrac{1}{3},1\\}$ 的一维3次拉格朗日多项式的张量积。到物理空间 $(x,y)$ 的等参映射使用相同的 $Q_3$ 形函数。对于一个耦合热机能量泛函，只考虑体积热机耦合项\n$$\n\\mathcal{I}_c[T,\\boldsymbol{u}] \\;=\\; \\int_{\\Omega} \\beta\\,T\\,\\nabla\\cdot\\boldsymbol{u}\\,\\mathrm{d}\\Omega,\n$$\n其中 $\\beta$ 是一个常数耦合系数，$T$ 是温度，$\\boldsymbol{u}$ 是位移。设 $\\beta=1$，因此 $\\beta$ 不带单位。使用从物理域 $\\Omega$ 到参考域的标准等参变量代换，以及恒等式 $J^{-1}\\det J = \\operatorname{adj}(\\mathbf{J})^{\\top}$，其中 $\\mathbf{J}$ 是映射的雅可比矩阵，$\\det J$ 是其行列式，$\\operatorname{adj}(\\mathbf{J})$ 是其伴随矩阵。该耦合积分变换为\n$$\n\\mathcal{I}_c[T,\\boldsymbol{u}] \\;=\\; \\int_{-1}^1 \\int_{-1}^1 T(\\xi,\\eta)\\,\\mathrm{tr}\\!\\left(\\operatorname{adj}(\\mathbf{J}(\\xi,\\eta))^{\\top}\\,\\nabla_{\\xi} \\boldsymbol{u}(\\xi,\\eta)\\right)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta,\n$$\n当 $T$ 和 $\\boldsymbol{u}$ 是 $Q_3$ 且几何是等参 $Q_3$ 时，这是一个二元多项式。这里 $\\nabla_{\\xi}\\boldsymbol{u}$ 表示一个 $2\\times 2$ 矩阵，其列分别是 $\\boldsymbol{u}$ 对 $\\xi$ 和 $\\eta$ 的导数。\n\n您的任务是，从第一性原理出发，确定在每个方向上精确积分 $\\mathcal{I}_c$ 所需的最小一维高斯-勒让德 (GL) 求积阶数 $p$，从而避免由求积误差引起的人为耦合。使用以下基本事实：一个具有 $p$ 个点的一维 GL 法则能精确积分所有在一维中次数不超过 $2p-1$ 的多项式，并且二维中的张量积 GL 法则对于任何二元多项式都是精确的，只要其在每个变量中的次数不超过 $2p-1$。\n\n在共同构成测试套件的两个测试用例中进行工作：\n\n- 测试用例 A (曲线三次几何)：物理坐标 $(x(\\xi,\\eta),y(\\xi,\\eta))$ 由以下 $Q_3$ 可表示的多项式规定，\n$$\n\\begin{aligned}\nx(\\xi,\\eta) = 1 + \\xi + 0.1\\,\\eta + 0.15\\,\\xi\\eta + 0.05\\,\\xi^3 - 0.04\\,\\eta^3,\\\\\ny(\\xi,\\eta) = -0.2 + 0.2\\,\\xi + \\eta + 0.07\\,\\xi^2 - 0.05\\,\\eta^2 + 0.03\\,\\xi^2\\eta.\n\\end{aligned}\n$$\n这些表达式通过在 $Q_3$ 节点位置 $(\\xi,\\eta)\\in\\{-1,-\\tfrac{1}{3},\\tfrac{1}{3},1\\}^2$ 进行求值来定义物理节点坐标。温度和位移场是通过对以下多项式进行采样获得的节点值进行 $Q_3$ 插值得到的：\n$$\n\\begin{aligned}\nT(\\xi,\\eta) = 0.7 + 0.9\\,\\xi - 0.6\\,\\eta + 0.5\\,\\xi^2 + 0.3\\,\\xi\\eta - 0.4\\,\\eta^2 + 0.2\\,\\xi^3 - 0.25\\,\\xi^2\\eta + 0.15\\,\\xi\\eta^2 + 0.1\\,\\eta^3,\\\\\nu_x(\\xi,\\eta) = 0.4 - 0.5\\,\\xi + 0.6\\,\\eta + 0.3\\,\\xi^2 - 0.2\\,\\xi\\eta + 0.1\\,\\eta^2 + 0.05\\,\\xi^3 - 0.07\\,\\xi^2\\eta + 0.02\\,\\xi\\eta^2,\\\\\nu_y(\\xi,\\eta) = -0.2 + 0.3\\,\\xi - 0.4\\,\\eta + 0.25\\,\\xi^2 + 0.05\\,\\xi\\eta - 0.15\\,\\eta^2 + 0.08\\,\\eta^3 + 0.04\\,\\xi^3.\n\\end{aligned}\n$$\n\n- 测试用例 B (仿射几何)：物理坐标是双线性的（因此可以由 $Q_3$ 等参映射精确表示），\n$$\nx(\\xi,\\eta) = 1.2 + 1.0\\,\\xi + 0.2\\,\\eta,\\qquad y(\\xi,\\eta) = -0.3 + 0.1\\,\\xi + 0.9\\,\\eta,\n$$\n使用与测试用例 A 中相同的 $T(\\xi,\\eta)$、$u_x(\\xi,\\eta)$ 和 $u_y(\\xi,\\eta)$ 来生成节点值。\n\n在这两种情况下，都使用张量网格 $\\{-1,-\\tfrac{1}{3},\\tfrac{1}{3},1\\}^2$ 上的 $Q_3$ 拉格朗日插值来定义等参几何和场。实现 $Q_3$ 形函数及其关于 $\\xi$ 和 $\\eta$ 的一阶导数。对于被积函数，使用恒等式\n$$\n\\mathrm{tr}\\!\\left(\\operatorname{adj}(\\mathbf{J})^{\\top}\\,\\nabla_{\\xi} \\boldsymbol{u}\\right) \\;=\\; y_{,\\eta}\\,u_{x,\\xi} + x_{,\\xi}\\,u_{y,\\eta} - y_{,\\xi}\\,u_{y,\\xi} - x_{,\\eta}\\,u_{x,\\eta},\n$$\n其中逗号表示对指定参数的偏导数。\n\n从第一性原理推导测试用例 A 和测试用例 B 中耦合被积函数里每个变量的最大多项式次数，并由此确定最小的 $p$，使得 $2p-1$ 至少等于每个变量中的该最大次数。然后，通过向上扫描 $p$ 并将数值积分 $\\mathcal{I}_c$ 与用 $p_{\\mathrm{ref}}=20$ 计算的高阶参考值进行比较，来数值验证该预测。将在 $10^{-11}$ 的绝对容差内达到一致的最小 $p$ 声明为发现的最小阶数。\n\n您的程序必须输出单行，其中包含一个方括号内的逗号分隔列表，依次包含：\n- 测试用例 A 的理论预测最小 $p$（整数），\n- 测试用例 A 的发现的最小 $p$（整数），\n- 一个布尔值，指示测试用例 A 中发现的最小 $p$ 是否与理论预测相符，\n- 测试用例 B 的理论预测最小 $p$（整数），\n- 测试用例 B 的发现的最小 $p$（整数），\n- 一个布尔值，指示测试用例 B 中发现的最小 $p$ 是否与理论预测相符，\n- 一个布尔值，指示在测试用例 A 中使用比预测最小 $p$ 低一阶的欠积分是否会导致相对于参考值的不可忽略的差异（绝对误差大于 $10^{-8}$），\n- 一个布尔值，指示测试用例 B 中的类似欠积分差异。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3,result4,result5,result6,result7,result8]\"）。不应打印任何附加文本。", "solution": "### 步骤 1：提取已知条件\n- **单元类型**：一个 $Q_3$ 等参四边形单元。\n- **参考域**：参数坐标 $(\\xi, \\eta)$ 中的一个正方形，其中 $\\xi \\in [-1, 1]$ 且 $\\eta \\in [-1, 1]$。\n- **插值基**：一维3次拉格朗日多项式的张量积。\n- **一维节点坐标**：在每个参数方向 $\\xi$ 和 $\\eta$ 上的点集 $\\{ -1, -\\frac{1}{3}, \\frac{1}{3}, 1 \\}$。\n- **耦合积分**：体积热机耦合项为 $\\mathcal{I}_c[T,\\boldsymbol{u}] = \\int_{\\Omega} \\beta\\,T\\,\\nabla\\cdot\\boldsymbol{u}\\,\\mathrm{d}\\Omega$。\n- **耦合系数**：$\\beta=1$。\n- **变换后的积分**：在参考域中，积分为 $\\mathcal{I}_c = \\int_{-1}^1 \\int_{-1}^1 T(\\xi,\\eta)\\,\\mathrm{tr}\\!\\left(\\operatorname{adj}(\\mathbf{J}(\\xi,\\eta))^{\\top}\\,\\nabla_{\\xi} \\boldsymbol{u}(\\xi,\\eta)\\right)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$。\n- **被积函数恒等式**：迹项展开为 $\\mathrm{tr}(\\dots) = y_{,\\eta}\\,u_{x,\\xi} + x_{,\\xi}\\,u_{y,\\eta} - y_{,\\xi}\\,u_{y,\\xi} - x_{,\\eta}\\,u_{x,\\eta}$，其中逗号表示偏导数（例如，$y_{,\\eta} = \\partial y / \\partial \\eta$）。\n- **求积法则**：一个具有 $p$ 个点的一维高斯-勒让德 (GL) 法则能精确积分次数最高为 $2p-1$ 的多项式。如果每个变量中的次数最多为 $2p-1$，则张量积 GL 法则对于二元多项式是精确的。\n- **任务**：从理论上确定精确积分所需的最小 GL 求积阶数 $p$，并通过数值方法进行验证。\n- **测试用例 A (曲线几何)**：\n  - $x(\\xi,\\eta) = 1 + \\xi + 0.1\\,\\eta + 0.15\\,\\xi\\eta + 0.05\\,\\xi^3 - 0.04\\,\\eta^3$\n  - $y(\\xi,\\eta) = -0.2 + 0.2\\,\\xi + \\eta + 0.07\\,\\xi^2 - 0.05\\,\\eta^2 + 0.03\\,\\xi^2\\eta$\n  - $T(\\xi,\\eta) = 0.7 + 0.9\\,\\xi - 0.6\\,\\eta + 0.5\\,\\xi^2 + 0.3\\,\\xi\\eta - 0.4\\,\\eta^2 + 0.2\\,\\xi^3 - 0.25\\,\\xi^2\\eta + 0.15\\,\\xi\\eta^2 + 0.1\\,\\eta^3$\n  - $u_x(\\xi,\\eta) = 0.4 - 0.5\\,\\xi + 0.6\\,\\eta + 0.3\\,\\xi^2 - 0.2\\,\\xi\\eta + 0.1\\,\\eta^2 + 0.05\\,\\xi^3 - 0.07\\,\\xi^2\\eta + 0.02\\,\\xi\\eta^2$\n  - $u_y(\\xi,\\eta) = -0.2 + 0.3\\,\\xi - 0.4\\,\\eta + 0.25\\,\\xi^2 + 0.05\\,\\xi\\eta - 0.15\\,\\eta^2 + 0.08\\,\\eta^3 + 0.04\\,\\xi^3$\n- **测试用例 B (仿射几何)**：\n  - $x(\\xi,\\eta) = 1.2 + 1.0\\,\\xi + 0.2\\,\\eta$\n  - $y(\\xi,\\eta) = -0.3 + 0.1\\,\\xi + 0.9\\,\\eta$\n  - $T, u_x, u_y$ 与测试用例 A 中相同。\n- **数值验证**：将向上扫描 $p$ 的结果与用 $p_{\\mathrm{ref}}=20$ 计算的参考积分进行比较。一致性由 $10^{-11}$ 的绝对容差定义。欠积分差异用 $10^{-8}$ 的绝对容差检查。\n\n### 步骤 2：使用提取的已知条件进行验证\n对问题进行验证：\n- **科学依据**：该问题植根于有限元法 (FEM)，具体涉及等参映射和数值求积，这些是计算力学和应用数学中标准的、完善的课题。方程和概念是正确的。\n- **良态的**：问题要求根据明确的标准（精确积分一个多项式）确定一个特定的整数，即求积阶数 $p$。这是一个定义明确且具有唯一解的数学任务。数值验证过程也得到了明确的规定。\n- **客观的**：问题以精确、正式和无偏见的语言陈述。\n- **不完整或矛盾的设置**：问题提供了所有必要的信息，包括单元定义、几何和场的显式多项式形式、积分表达式、求积法则的性质以及数值检查的容差。没有明显的矛盾。\n- **不切实际或不可行**：该设置代表了 FEM 中一个标准的、尽管复杂的学术练习。多项式系数是任意的，但没有造成任何物理或数学上的荒谬。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。这是一个计算工程科学中严谨且自洽的问题。将提供详细的解决方案。\n\n### 基于原理的解答\n\n目标是找到每个方向上精确积分热机耦合项 $\\mathcal{I}_c$ 所需的最小高斯-勒让德求积点数 $p$。其控制原理是，一个 $p$ 点高斯-勒让德法则能精确积分任何次数最高为 $2p-1$ 的一维多项式。对于此处使用的二维张量积法则，如果被积函数在每个变量 $\\xi$ 和 $\\eta$ 中的多项式次数不超过 $2p-1$，则可实现精确性。\n\n令 $d(f) = (\\deg_{\\xi}(f), \\deg_{\\eta}(f))$ 表示函数 $f(\\xi, \\eta)$ 在其每个变量中的最大多项式次数对。多项式乘积的次数是它们次数的总和，$d(fg) = d(f) + d(g)$，而多项式和的次数是它们次数的逐分量最大值。\n\n被积函数由 $I(\\xi, \\eta) = T(\\xi, \\eta) \\cdot S(\\xi, \\eta)$ 给出，其中 $S(\\xi, \\eta) = y_{,\\eta}\\,u_{x,\\xi} + x_{,\\xi}\\,u_{y,\\eta} - y_{,\\xi}\\,u_{y,\\xi} - x_{,\\eta}\\,u_{x,\\eta}$。被积函数的次数为 $d(I) = d(T) + d(S)$。\n\n几何 $(x, y)$ 和场 $(T, u_x, u_y)$ 由 $Q_3$ 拉格朗日插值定义。为这些量提供的解析表达式是双次数最多为 $(3, 3)$ 的多项式，因此可以由 $Q_3$ 基精确表示。因此，我们可以直接使用给定多项式的次数。\n\n#### 测试用例 A：曲线三次几何\n首先，我们确定几何、场及其导数的次数。\n\n-   $d(x) = (3, 3) \\implies d(x_{,\\xi}) = (2, 3), d(x_{,\\eta}) = (3, 2)$\n-   $d(y) = (2, 2) \\implies d(y_{,\\xi}) = (1, 2), d(y_{,\\eta}) = (2, 1)$\n-   $d(T) = (3, 3)$\n-   $d(u_x) = (3, 2) \\implies d(u_{x,\\xi}) = (2, 2), d(u_{x,\\eta}) = (3, 1)$\n-   $d(u_y) = (3, 3) \\implies d(u_{y,\\xi}) = (2, 3), d(u_{y,\\eta}) = (3, 2)$\n\n接下来，我们求 $S(\\xi, \\eta)$ 中每一项的次数：\n1.  $d(y_{,\\eta} u_{x,\\xi}) = d(y_{,\\eta}) + d(u_{x,\\xi}) = (2, 1) + (2, 2) = (4, 3)$\n2.  $d(x_{,\\xi} u_{y,\\eta}) = d(x_{,\\xi}) + d(u_{y,\\eta}) = (2, 3) + (3, 2) = (5, 5)$\n3.  $d(y_{,\\xi} u_{y,\\xi}) = d(y_{,\\xi}) + d(u_{y,\\xi}) = (1, 2) + (2, 3) = (3, 5)$\n4.  $d(x_{,\\eta} u_{x,\\eta}) = d(x_{,\\eta}) + d(u_{x,\\eta}) = (3, 2) + (3, 1) = (6, 3)$\n\n$S(\\xi, \\eta)$ 的次数是其各项次数的逐分量最大值：\n$d(S) = (\\max(4, 5, 3, 6), \\max(3, 5, 5, 3)) = (6, 5)$。\n\n完整被积函数 $I(\\xi, \\eta) = T \\cdot S$ 的次数是：\n$d(I) = d(T) + d(S) = (3, 3) + (6, 5) = (9, 8)$。\n\n需要积分的最大多项式次数是 $d_{\\max} = \\max(9, 8) = 9$。为确保精确积分，我们需要：\n$2p_A - 1 \\ge d_{\\max} \\implies 2p_A - 1 \\ge 9 \\implies 2p_A \\ge 10 \\implies p_A \\ge 5$。\n最小整数阶为 $p_A = 5$。\n\n#### 测试用例 B：仿射几何\n对仿射几何重复该分析。场 $T, u_x, u_y$ 及其导数的次数与案例 A 相同。几何现在是双线性的。\n\n-   $d(x) = (1, 1) \\implies d(x_{,\\xi}) = (0, 0), d(x_{,\\eta}) = (0, 0)$ (因为 $x_{,\\xi}=1.0, x_{,\\eta}=0.2$)\n-   $d(y) = (1, 1) \\implies d(y_{,\\xi}) = (0, 0), d(y_{,\\eta}) = (0, 0)$ (因为 $y_{,\\xi}=0.1, y_{,\\eta}=0.9$)\n\n几何导数是常数（次数为0）。$S(\\xi, \\eta)$ 中各项的次数现在仅由场导数确定：\n1.  $d(y_{,\\eta} u_{x,\\xi}) = (0,0) + (2,2) = (2, 2)$\n2.  $d(x_{,\\xi} u_{y,\\eta}) = (0,0) + (3,2) = (3, 2)$\n3.  $d(y_{,\\xi} u_{y,\\xi}) = (0,0) + (2,3) = (2, 3)$\n4.  $d(x_{,\\eta} u_{x,\\eta}) = (0,0) + (3,1) = (3, 1)$\n\n$S(\\xi, \\eta)$ 的次数变为：\n$d(S) = (\\max(2, 3, 2, 3), \\max(2, 2, 3, 1)) = (3, 3)$。\n\n完整被积函数 $I(\\xi, \\eta) = T \\cdot S$ 的次数是：\n$d(I) = d(T) + d(S) = (3, 3) + (3, 3) = (6, 6)$。\n\n需要积分的最大多项式次数是 $d_{\\max} = \\max(6, 6) = 6$。精确积分的要求是：\n$2p_B - 1 \\ge d_{\\max} \\implies 2p_B - 1 \\ge 6 \\implies 2p_B \\ge 7 \\implies p_B \\ge 3.5$。\n最小整数阶为 $p_B = 4$。\n\n#### 理论预测总结\n- 对于测试用例 A (曲线几何)，理论预测的最小求积阶数为 $p_A = 5$。\n- 对于测试用例 B (仿射几何)，理论预测的最小求积阶数为 $p_B = 4$。\n\n这些预测将通过数值实现来证实。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\nclass Q3Evaluator:\n    \"\"\"\n    Evaluates Q3 fields and their derivatives based on nodal values.\n    The interpolation is based on 1D Lagrange polynomials over the nodes\n    [-1, -1/3, 1/3, 1].\n    \"\"\"\n    def __init__(self):\n        self.nodes_1d = np.array([-1.0, -1.0/3.0, 1.0/3.0, 1.0])\n        self.num_nodes_1d = len(self.nodes_1d)\n        degree = self.num_nodes_1d - 1\n\n        self.L_polys = []\n        self.L_prime_polys = []\n\n        for i in range(self.num_nodes_1d):\n            y = np.zeros(self.num_nodes_1d)\n            y[i] = 1.0\n            # Use np.polyfit to find coefficients of the Lagrange polynomial\n            coeffs = np.polyfit(self.nodes_1d, y, degree)\n            poly = np.poly1d(coeffs)\n            self.L_polys.append(poly)\n            self.L_prime_polys.append(poly.deriv())\n\n    def eval_1d_basis(self, xi):\n        \"\"\"Evaluates 1D basis functions and their derivatives at a point xi.\"\"\"\n        L_vals = np.array([p(xi) for p in self.L_polys])\n        L_prime_vals = np.array([dp(xi) for dp in self.L_prime_polys])\n        return L_vals, L_prime_vals\n\n    def evaluate_field(self, xi, eta, nodal_values):\n        \"\"\"Evaluates a field given its 4x4 nodal values.\"\"\"\n        L_xi, _ = self.eval_1d_basis(xi)\n        L_eta, _ = self.eval_1d_basis(eta)\n        # Tensor product summation: value = sum_{i,j} nodal_values[i,j] * L_i(xi) * L_j(eta)\n        # Note: numpy einsum is efficient, but nodal_values should be (i,j)\n        # corresponding to (xi, eta) directions. We will use (eta, xi) for ij indexing.\n        return np.einsum('j,i,ij-', L_eta, L_xi, nodal_values)\n\n    def evaluate_derivatives(self, xi, eta, nodal_values):\n        \"\"\"Evaluates field derivatives w.r.t. xi and eta.\"\"\"\n        L_xi, L_prime_xi = self.eval_1d_basis(xi)\n        L_eta, L_prime_eta = self.eval_1d_basis(eta)\n        \n        # Derivative w.r.t. xi\n        deriv_xi = np.einsum('j,i,ij-', L_eta, L_prime_xi, nodal_values)\n        # Derivative w.r.t. eta\n        deriv_eta = np.einsum('j,i,ij-', L_prime_eta, L_xi, nodal_values)\n        \n        return deriv_xi, deriv_eta\n\ndef get_nodal_values(poly_func, evaluator):\n    \"\"\"Samples a polynomial function at the Q3 nodes.\"\"\"\n    nodal_values = np.zeros((evaluator.num_nodes_1d, evaluator.num_nodes_1d))\n    for i, xi_node in enumerate(evaluator.nodes_1d):\n        for j, eta_node in enumerate(evaluator.nodes_1d):\n            nodal_values[j, i] = poly_func(xi_node, eta_node)\n    return nodal_values\n\ndef compute_integral(p_order, integrand_func):\n    \"\"\"Performs 2D Gauss-Legendre quadrature.\"\"\"\n    points, weights = roots_legendre(p_order)\n    integral_val = 0.0\n    for i in range(p_order):\n        for j in range(p_order):\n            xi, w_xi = points[i], weights[i]\n            eta, w_eta = points[j], weights[j]\n            integrand_val = integrand_func(xi, eta)\n            integral_val += w_xi * w_eta * integrand_val\n    return integral_val\n\ndef solve():\n    \"\"\"Main solver function to perform the analysis for both test cases.\"\"\"\n    \n    # Polynomial definitions from the problem statement\n    polys = {\n        'A': {\n            'x': lambda xi, eta: 1 + xi + 0.1*eta + 0.15*xi*eta + 0.05*xi**3 - 0.04*eta**3,\n            'y': lambda xi, eta: -0.2 + 0.2*xi + eta + 0.07*xi**2 - 0.05*eta**2 + 0.03*xi**2*eta,\n        },\n        'B': {\n            'x': lambda xi, eta: 1.2 + 1.0*xi + 0.2*eta,\n            'y': lambda xi, eta: -0.3 + 0.1*xi + 0.9*eta,\n        },\n        'fields': {\n            'T': lambda xi, eta: 0.7 + 0.9*xi - 0.6*eta + 0.5*xi**2 + 0.3*xi*eta - 0.4*eta**2 + 0.2*xi**3 - 0.25*xi**2*eta + 0.15*xi*eta**2 + 0.1*eta**3,\n            'ux': lambda xi, eta: 0.4 - 0.5*xi + 0.6*eta + 0.3*xi**2 - 0.2*xi*eta + 0.1*eta**2 + 0.05*xi**3 - 0.07*xi**2*eta + 0.02*xi*eta**2,\n            'uy': lambda xi, eta: -0.2 + 0.3*xi - 0.4*eta + 0.25*xi**2 + 0.05*xi*eta - 0.15*eta**2 + 0.08*eta**3 + 0.04*xi**3,\n        }\n    }\n    \n    test_cases = [\n        ('A', polys['A'], 5),\n        ('B', polys['B'], 4),\n    ]\n\n    all_results = []\n\n    for case_name, geo_polys, p_theory in test_cases:\n        evaluator = Q3Evaluator()\n        \n        # Generate nodal values for all functions\n        x_nodes = get_nodal_values(geo_polys['x'], evaluator)\n        y_nodes = get_nodal_values(geo_polys['y'], evaluator)\n        T_nodes = get_nodal_values(polys['fields']['T'], evaluator)\n        ux_nodes = get_nodal_values(polys['fields']['ux'], evaluator)\n        uy_nodes = get_nodal_values(polys['fields']['uy'], evaluator)\n        \n        def integrand(xi, eta):\n            T_val = evaluator.evaluate_field(xi, eta, T_nodes)\n            x_dxi, x_deta = evaluator.evaluate_derivatives(xi, eta, x_nodes)\n            y_dxi, y_deta = evaluator.evaluate_derivatives(xi, eta, y_nodes)\n            ux_dxi, ux_deta = evaluator.evaluate_derivatives(xi, eta, ux_nodes)\n            uy_dxi, uy_deta = evaluator.evaluate_derivatives(xi, eta, uy_nodes)\n            \n            trace_term = y_deta * ux_dxi + x_dxi * uy_deta - y_dxi * uy_dxi - x_deta * ux_deta\n            \n            return T_val * trace_term\n            \n        # Compute reference integral\n        p_ref = 20\n        ref_integral = compute_integral(p_ref, integrand)\n        \n        # Find minimal p for convergence\n        p_discovered = -1\n        for p in range(1, p_ref):\n            current_integral = compute_integral(p, integrand)\n            if np.isclose(current_integral, ref_integral, atol=1e-11, rtol=0):\n                p_discovered = p\n                break\n        \n        # Check for under-integration discrepancy\n        p_under = p_theory - 1\n        if p_under > 0:\n            under_integral = compute_integral(p_under, integrand)\n            under_int_discrepancy = abs(under_integral - ref_integral) > 1e-8\n        else:\n            under_int_discrepancy = True # p_under=0 is definitely an under-integration\n\n        all_results.append({\n            'p_theory': p_theory,\n            'p_discovered': p_discovered,\n            'match': p_discovered == p_theory,\n            'under_int_discrepancy': under_int_discrepancy\n        })\n\n    # Format final output string\n    final_list = [\n        all_results[0]['p_theory'], all_results[0]['p_discovered'], all_results[0]['match'],\n        all_results[1]['p_theory'], all_results[1]['p_discovered'], all_results[1]['match'],\n        all_results[0]['under_int_discrepancy'], all_results[1]['under_int_discrepancy']\n    ]\n\n    formatted_results = []\n    for item in final_list:\n        if isinstance(item, bool):\n            formatted_results.append(str(item).lower())\n        else:\n            formatted_results.append(str(item))\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3525420"}]}