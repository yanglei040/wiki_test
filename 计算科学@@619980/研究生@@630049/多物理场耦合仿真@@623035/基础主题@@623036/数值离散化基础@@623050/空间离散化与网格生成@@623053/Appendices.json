{"hands_on_practices": [{"introduction": "在有限元分析中，网格质量直接影响数值解的稳定性和准确性。这个练习将带你亲手计算一个三角形单元的关键质量指标——最小内角和纵横比，这是评估网格是否适用于多物理场耦合仿真的第一步。通过这个基础计算，你将深入理解单元几何形状如何与数值方法的稳健性直接关联起来[@problem_id:3526260]。", "problem": "一个热弹性流固耦合离散化方法，使用有限元法（FEM）和混合稳定化方法，在共享的非结构化三角形网格上耦合了不可压缩流体和热方程。为了保证矫顽性和算子条件，施加了局部单元质量要求：最小内角必须超过预设阈值，且纵横比必须有界。考虑一个平面上的三角形，其顶点为 $A = (0, 0)$，$B = (1.8, 0.6)$ 和 $C = (0.2, 2.0)$。您需要计算最小内角和一个由外接圆半径与内切圆半径之比定义的纵横比，然后构建一个标量稳定性度量。\n\n从核心的欧几里得几何定义和经过充分检验的公式出发，执行以下操作：\n- 使用欧几里得范数计算边长。\n- 使用叉积的大小计算面积。\n- 使用两个向量之间夹角的点积定义计算每个内角。\n- 通过基本关系式，由面积和边长计算内切圆半径和外接圆半径。\n- 将纵横比定义为 $\\rho = \\dfrac{R}{r}$，其中 $R$ 是外接圆半径，$r$ 是内切圆半径。\n- 设稳定性度量为 $q = \\dfrac{\\theta_{\\min}}{\\rho}$，其中 $\\theta_{\\min}$ 是以弧度为单位的最小内角。\n- 预设的稳定性阈值为 $\\theta_{\\min} \\geq \\theta_{0}$（其中 $\\theta_{0} = 0.6$）和 $\\rho \\leq \\rho_{0}$（其中 $\\rho_{0} = 3.0$）。评估该三角形是否满足这两个阈值，但只报告标量 $q$。\n\n将最终的稳定性度量 $q$ 四舍五入到四位有效数字。所有角度均以弧度表示。最终答案必须是一个实数值。", "solution": "该问题要求为一个由其在二维平面中的顶点定义的给定三角形单元计算稳定性度量 $q$。这个过程涉及计算三角形的几个几何属性：边长、面积、内角、内切圆半径和外接圆半径。\n\n三角形的顶点给出为 $A = (0, 0)$，$B = (1.8, 0.6)$ 和 $C = (0.2, 2.0)$。\n\n首先，我们定义与三角形各边相对应的向量。\n从 $A$ 到 $B$ 的向量是 $\\vec{AB} = B - A = (1.8 - 0, 0.6 - 0) = (1.8, 0.6)$。\n从 $A$ 到 $C$ 的向量是 $\\vec{AC} = C - A = (0.2 - 0, 2.0 - 0) = (0.2, 2.0)$。\n从 $B$ 到 $C$ 的向量是 $\\vec{BC} = C - B = (0.2 - 1.8, 2.0 - 0.6) = (-1.6, 1.4)$。\n\n接下来，我们计算边的长度，即这些向量的欧几里得范数。设 $a$、$b$ 和 $c$ 分别是顶点 $A$、$B$ 和 $C$ 对边的长度。\n$c = |\\vec{AB}| = \\sqrt{(1.8)^{2} + (0.6)^{2}} = \\sqrt{3.24 + 0.36} = \\sqrt{3.6} \\approx 1.897367$。\n$b = |\\vec{AC}| = \\sqrt{(0.2)^{2} + (2.0)^{2}} = \\sqrt{0.04 + 4.0} = \\sqrt{4.04} \\approx 2.009975$。\n$a = |\\vec{BC}| = \\sqrt{(-1.6)^{2} + (1.4)^{2}} = \\sqrt{2.56 + 1.96} = \\sqrt{4.52} \\approx 2.126029$。\n\n三角形的面积 $\\mathcal{A}$ 可以计算为构成其两条边的向量（例如 $\\vec{AB}$ 和 $\\vec{AC}$）的二维叉积大小的一半。\n$$ \\mathcal{A} = \\frac{1}{2} |\\det(\\vec{AB}, \\vec{AC})| = \\frac{1}{2} |(1.8)(2.0) - (0.6)(0.2)| $$\n$$ \\mathcal{A} = \\frac{1}{2} |3.6 - 0.12| = \\frac{1}{2} (3.48) = 1.74 $$\n面积恰好是 $1.74$。\n\n内角使用点积公式计算：$\\vec{u} \\cdot \\vec{v} = |\\vec{u}| |\\vec{v}| \\cos(\\theta)$，由此得到 $\\theta = \\arccos\\left(\\frac{\\vec{u} \\cdot \\vec{v}}{|\\vec{u}| |\\vec{v}|}\\right)$。所有角度都以弧度表示。\n\n顶点 $A$ 处的角 $\\theta_A$ 是 $\\vec{AB}$ 和 $\\vec{AC}$ 之间的夹角：\n$$ \\vec{AB} \\cdot \\vec{AC} = (1.8)(0.2) + (0.6)(2.0) = 0.36 + 1.2 = 1.56 $$\n$$ \\cos(\\theta_A) = \\frac{1.56}{c \\cdot b} = \\frac{1.56}{\\sqrt{3.6} \\sqrt{4.04}} = \\frac{1.56}{\\sqrt{14.544}} \\approx 0.409048 $$\n$$ \\theta_A = \\arccos(0.409048) \\approx 1.14918 \\text{ rad} $$\n\n顶点 $B$ 处的角 $\\theta_B$ 是 $\\vec{BA} = -\\vec{AB}$ 和 $\\vec{BC}$ 之间的夹角：\n$$ \\vec{BA} \\cdot \\vec{BC} = (-1.8)(-1.6) + (-0.6)(1.4) = 2.88 - 0.84 = 2.04 $$\n$$ \\cos(\\theta_B) = \\frac{2.04}{c \\cdot a} = \\frac{2.04}{\\sqrt{3.6} \\sqrt{4.52}} = \\frac{2.04}{\\sqrt{16.272}} \\approx 0.505716 $$\n$$ \\theta_B = \\arccos(0.505716) \\approx 1.04073 \\text{ rad} $$\n\n顶点 $C$ 处的角 $\\theta_C$ 是 $\\vec{CA} = -\\vec{AC}$ 和 $\\vec{CB} = -\\vec{BC}$ 之间的夹角：\n$$ \\vec{CA} \\cdot \\vec{CB} = (-0.2)(1.6) + (-2.0)(-1.4) = -0.32 + 2.8 = 2.48 $$\n$$ \\cos(\\theta_C) = \\frac{2.48}{b \\cdot a} = \\frac{2.48}{\\sqrt{4.04} \\sqrt{4.52}} = \\frac{2.48}{\\sqrt{18.2608}} \\approx 0.580350 $$\n$$ \\theta_C = \\arccos(0.580350) \\approx 0.95168 \\text{ rad} $$\n\n最小内角是 $\\theta_{\\min} = \\theta_C \\approx 0.95168$ 弧度。问题要求与阈值 $\\theta_0 = 0.6$ 进行评估，由于 $0.95168 \\ge 0.6$，此条件得到满足。\n\n接下来，我们计算内切圆半径 $r$ 和外接圆半径 $R$。半周长 $s$ 为：\n$s = \\frac{a+b+c}{2} = \\frac{\\sqrt{4.52} + \\sqrt{4.04} + \\sqrt{3.6}}{2} \\approx \\frac{2.126029 + 2.009975 + 1.897367}{2} \\approx 3.016686$。\n\n内切圆半径 $r$ 由 $r = \\frac{\\mathcal{A}}{s}$ 给出：\n$$ r \\approx \\frac{1.74}{3.016686} \\approx 0.576850 $$\n\n外接圆半径 $R$ 由 $R = \\frac{abc}{4\\mathcal{A}}$ 给出：\n$$ R = \\frac{\\sqrt{4.52} \\sqrt{4.04} \\sqrt{3.6}}{4(1.74)} = \\frac{\\sqrt{65.73888}}{6.96} \\approx \\frac{8.107952}{6.96} \\approx 1.164936 $$\n\n纵横比定义为 $\\rho = \\frac{R}{r}$：\n$$ \\rho \\approx \\frac{1.164936}{0.576850} \\approx 2.019528 $$\n问题要求与阈值 $\\rho_0 = 3.0$ 进行评估，由于 $2.019528 \\le 3.0$，此条件也得到满足。\n\n最后，稳定性度量 $q$ 定义为 $q = \\frac{\\theta_{\\min}}{\\rho}$：\n$$ q \\approx \\frac{0.95168}{2.019528} \\approx 0.471241 $$\n将结果四舍五入到 4 位有效数字，得到 $q = 0.4712$。", "answer": "$$\\boxed{0.4712}$$", "id": "3526260"}, {"introduction": "单个元素的质量固然重要，但最终衡量空间离散化效果的是整个求解方案的收敛行为。本练习介绍了一种强大的验证技术——网格收敛指数($GCI$)分析，它允许我们量化离散化误差。你将使用一组在系统加密网格上得到的仿真数据，计算观察到的收敛阶并评估最精细网格解的不确定性[@problem_id:3526279]。", "problem": "使用有限元法 (FEM) 对锂离子软包电池中由电化学驱动的传热进行多物理场耦合仿真。该电池被建模为一个分层固体，具有各向异性热导率和由电化学子模型提供的体积焦耳热。空间离散化使用三个系统性加密的非结构化四面体网格，其特征单元尺寸分别为 $h_1$、$h_2$ 和 $h_3$，满足 $h_1/h_2 = h_2/h_3 = r$ 且 $r$ 为常数。目标量是域积分焦耳热 $Q(h)$，该值从每个网格级别上的稳态耦合解中获得。记录的数据如下：\n- $h_1 = 0.008\\,\\text{m}$，$Q_1 = 5.432\\,\\text{W}$；\n- $h_2 = 0.004\\,\\text{m}$，$Q_2 = 5.308\\,\\text{W}$；\n- $h_3 = 0.002\\,\\text{m}$，$Q_3 = 5.276\\,\\text{W}$。\n\n假设解的误差是渐近的，并且可以用主阶 Richardson 展开 $Q(h) = Q^{\\ast} + C h^{p} + \\mathcal{O}(h^{p+1})$ 来表示，其中 $Q^{\\ast}$ 是网格无关值，$C$ 是一个常数，$p$ 是观测精度阶。仅使用此基本表示和给定数据：\n1. 根据三组解和加密比 $r$ 确定观测阶 $p$。\n2. 基于观测阶，计算最密网格解的网格收敛指数 (GCI)，该指数定义在网格对 $(h_2,h_3)$ 上，安全因子 $F_s = 1.25$，以估计由空间离散化引起的 $Q_3$ 的分数不确定度。\n\n以无量纲分数形式提供 GCI（不带百分号）。如果选择用小数形式表示最终数字，请将答案四舍五入至四位有效数字。此外，简要解释这三组解是否与单调渐近收敛一致，以及计算出的 GCI 对 $Q_3$ 中由离散化引起的不确定性意味着什么。", "solution": "该问题是有效的，因为它为使用 Richardson 外推法进行标准网格收敛性研究提供了一组适定的条件和数据，Richardson 外推法是计算科学与工程中验证和确认的基石。其物理背景具有科学依据，并且所有必要的参数都已提供且没有矛盾。\n\n分析分三部分进行：首先，简要检查单调收敛性；其次，确定观测精度阶 $p$；第三，计算网格收敛指数 (GCI)。\n\n在三个网格加密级别上，域积分焦耳热 $Q$ 的给定数据为：\n- 网格 1 (粗): $h_1 = 0.008$, $Q_1 = 5.432$\n- 网格 2 (中): $h_2 = 0.004$, $Q_2 = 5.308$\n- 网格 3 (细): $h_3 = 0.002$, $Q_3 = 5.276$\n\n首先，我们评估收敛行为。网格加密是系统性的，具有恒定的加密比 $r = h_1/h_2 = 0.008/0.004 = 2$ 和 $h_2/h_3 = 0.004/0.002 = 2$。解为 $Q_1 > Q_2 > Q_3$。由于随着特征单元尺寸 $h$ 的减小，解值单调递减，因此该解表现出单调收敛。这是一个理想的特性，表明数值格式是稳定的，没有表现出振荡误差行为。\n\n分析的核心依赖于目标量 $Q(h)$ 的假设 Richardson 误差展开，该展开表明，特征尺寸为 $h$ 的网格上的解与精确解或网格无关解 $Q^{\\ast}$ 的关系如下：\n$$Q(h) = Q^{\\ast} + C h^{p} + \\mathcal{O}(h^{p+1})$$\n其中 $p$ 是精度阶，$C$ 是一个常数。对于三个网格级别，忽略高阶项，我们有：\n$$Q_1 \\approx Q^{\\ast} + C h_1^{p}$$\n$$Q_2 \\approx Q^{\\ast} + C h_2^{p}$$\n$$Q_3 \\approx Q^{\\ast} + C h_3^{p}$$\n为了求出观测精度阶 $p$，我们构造连续解之间的差值以消去未知数 $Q^{\\ast}$：\n$$Q_1 - Q_2 \\approx C(h_1^{p} - h_2^{p})$$\n$$Q_2 - Q_3 \\approx C(h_2^{p} - h_3^{p})$$\n取这两个差值的比率以消去常数 $C$：\n$$\\frac{Q_1 - Q_2}{Q_2 - Q_3} \\approx \\frac{h_1^{p} - h_2^{p}}{h_2^{p} - h_3^{p}}$$\n使用恒定的加密比 $r = h_1/h_2 = h_2/h_3$，我们可以用更粗的网格尺寸表示 $h_1$ 和 $h_2$：$h_1 = r h_2$ 和 $h_2 = r h_3$。将这些代入比率可得：\n$$\\frac{Q_1 - Q_2}{Q_2 - Q_3} \\approx \\frac{(r h_2)^{p} - h_2^{p}}{(r h_3)^{p} - h_3^{p}} = \\frac{h_2^{p}(r^p - 1)}{h_3^{p}(r^p - 1)} = \\left(\\frac{h_2}{h_3}\\right)^p = r^p$$\n现在我们可以求解 $p$：\n$$p = \\frac{\\ln\\left(\\frac{Q_1 - Q_2}{Q_2 - Q_3}\\right)}{\\ln(r)}$$\n代入给定的数值：\n$$Q_1 - Q_2 = 5.432 - 5.308 = 0.124$$\n$$Q_2 - Q_3 = 5.308 - 5.276 = 0.032$$\n加密比为 $r=2$。因此，\n$$p = \\frac{\\ln\\left(\\frac{0.124}{0.032}\\right)}{\\ln(2)} = \\frac{\\ln(3.875)}{\\ln(2)} \\approx \\frac{1.35455}{0.69315} \\approx 1.95418$$\n观测精度阶为 $p \\approx 1.954$。这个值接近 $2$，这是许多常见有限元格式的理论阶，表明解处于渐近收敛范围内。\n\n接下来，我们基于解对 $(Q_2, Q_3)$ 计算最密网格解的网格收敛指数 (GCI)。GCI 提供了对最密网格解中分数误差的估计值。其公式为：\n$$\\text{GCI}_{\\text{fine}} = \\text{GCI}_{23} = \\frac{F_s}{|r^p - 1|} \\left| \\frac{Q_3 - Q_2}{Q_3} \\right|$$\n给定安全因子 $F_s = 1.25$。我们使用这对网格的加密比 $r = h_2/h_3 = 2$ 和我们刚刚计算出的 $p$ 值。\n项 $r^p$ 就是我们之前求出的解差之比：\n$$r^p = 2^{p} = \\frac{Q_1 - Q_2}{Q_2 - Q_3} = 3.875$$\n相对差异项为：\n$$\\left| \\frac{Q_3 - Q_2}{Q_3} \\right| = \\left| \\frac{5.276 - 5.308}{5.276} \\right| = \\left| \\frac{-0.032}{5.276} \\right| \\approx 0.006065201$$\n现在，我们可以将所有值代入 GCI 公式：\n$$\\text{GCI}_{23} = \\frac{1.25}{|3.875 - 1|} \\times 0.006065201 = \\frac{1.25}{2.875} \\times 0.006065201 \\approx 0.00263695$$\n按照要求将结果四舍五入至四位有效数字：\n$$\\text{GCI}_{23} \\approx 0.002637$$\n\n这三组解与单调渐近收敛一致，其证明依据是有序的解值 ($Q_1 > Q_2 > Q_3$) 和一个稳定的、接近理论整数值 $2$ 的观测精度阶 $p \\approx 1.954$。计算出的值 $\\text{GCI}_{23} \\approx 0.002637$ (或 $0.2637\\%$) 意味着，最密网格解 $Q_3$ 中的离散化不确定度估计约为 $0.26\\%$。这个低值表明最密网格上的解已经相当准确，进一步的网格加密只会对域积分焦耳热产生微小的改变。该数值结果是稳健的。", "answer": "$$\\boxed{0.002637}$$", "id": "3526279"}, {"introduction": "理想的网格生成器总能产生有效的单元，但在实践中，复杂的几何形状或算法限制可能导致畸变甚至翻转的单元。一个稳健的有限元程序必须能够识别并纠正这些问题，以避免仿真失败。这个高级编程练习将指导你实现算法，用于诊断和修复无效的四边形单元，具体方法包括节点重排序和单元细分[@problem_id:3561775]。", "problem": "您的任务是形式化、分析并稳健地修正计算岩土力学中使用的二维双线性四边形有限元中等参映射的失效问题。问题侧重于空间离散化、网格划分和形函数，从等参映射的基本定义开始，最终到雅可比行列式失去正定性时的算法补救措施。您的程序必须为一小组网格实现并测试这些概念。\n\n起点是双线性四边形单元的等参映射。从参数坐标 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ 中的参考正方形到物理坐标 $(x,y)$ 的映射定义为\n$$\nx(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,x_i,\\quad\ny(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,y_i,\n$$\n其中 $(x_i,y_i)$ 是物理节点的坐标，而 $N_i(\\xi,\\eta)$ 是与参考正方形角点相关的双线性形函数。对于参考节点顺序为 $i=1,2,3,4$ 对应角点 $(-1,-1)$、$(1,-1)$、$(1,1)$、$(-1,1)$ 的四边形，其双线性形函数为\n$$\nN_1(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_3(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1+\\eta).\n$$\n该映射的雅可比矩阵是\n$$\n\\mathbf{J}(\\xi,\\eta) = \n\\begin{bmatrix}\n\\dfrac{\\partial x}{\\partial \\xi}  \\dfrac{\\partial x}{\\partial \\eta} \\\\\n\\dfrac{\\partial y}{\\partial \\xi}  \\dfrac{\\partial y}{\\partial \\eta}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\sum_{i=1}^{4}\\dfrac{\\partial N_i}{\\partial \\xi}\\,x_i  \\sum_{i=1}^{4}\\dfrac{\\partial N_i}{\\partial \\eta}\\,x_i \\\\\n\\sum_{i=1}^{4}\\dfrac{\\partial N_i}{\\partial \\xi}\\,y_i  \\sum_{i=1}^{4}\\dfrac{\\partial N_i}{\\partial \\eta}\\,y_i\n\\end{bmatrix},\n$$\n雅可比行列式，记为 $J(\\xi,\\eta)=\\det\\mathbf{J}(\\xi,\\eta)$，表示映射的局部可逆性和方向。一个有效的保向等参映射的必要条件是在单元内部任何地方都有 $J(\\xi,\\eta)0$。正定性的丧失会导致单元反转或折叠等失效模式，这可能引起数值积分失效和非物理性的解。\n\n您的任务是：\n- 实现双线性形函数 $N_i(\\xi,\\eta)$ 及其参数导数 $\\partial N_i/\\partial \\xi$ 和 $\\partial N_i/\\partial \\eta$。\n- 对于由其物理节点坐标 $(x_i,y_i)$ 定义的任何给定四边形单元，其隐含的参考节点顺序 $i=1,2,3,4$ 对应于 $(-1,-1)$、$(1,-1)$、$(1,1)$、$(-1,1)$，计算在参数点内部采样网格上的雅可比行列式 $J(\\xi,\\eta)$\n$$\n\\Xi=\\{-0.75,\\,-0.25,\\,0,\\,0.25,\\,0.75\\},\\quad \\text{在所有 $25$ 对 $(\\xi,\\eta)\\in\\Xi\\times\\Xi$ 上求值}。\n$$\n使用数值公差 $10^{-9}$ 来判断严格正定性。\n- 有意构造在某些区域违反 $J(\\xi,\\eta)0$ 的单元，分析其失效模式，并提出两种稳健的补救措施：\n  1. 局部重参数化：将物理节点列表 $(x_i,y_i)$ 视为一种可以根据正方形的八个对称性（八阶二面体群）进行排列的标签。在这些排列中，找出能使采样点上最小 $J(\\xi,\\eta)$ 值最大化的那一个，如果它能实现严格大于公差的最小正值，则应用该排列。\n  2. 细分为线性三角形：如果没有任何重参数化能在采样网格上产生严格为正的最小 $J(\\xi,\\eta)$ 值，则将四边形沿其中一条对角线细分为两个三角形，选择能使两个三角形的最小正有向面积最大化的对角线（如有必要，通过节点重排序确保逆时针方向），并报告此最小面积作为修正后的度量。\n\n每个测试用例的输出规范：\n- 计算任何修正前的最小采样雅可比行列式，记为 $J_{\\min}^{\\text{before}}$。\n- 决定修正策略代码 $c$（整数）：如果不需要修正（已严格为正），则 $c=0$；如果使用局部重参数化，则 $c=1$；如果使用细分为三角形，则 $c=2$。\n- 计算修正后度量 $m$：如果 $c=0$ 或 $c=1$，将 $m$ 设置为所选重参数化（如果无需修正，则为原始配置）后的最小采样雅可比行列式；如果 $c=2$，将 $m$ 设置为细分并进行适当定向后的最小正三角形面积。\n- 对于数值输出，必须使用浮点数；不涉及物理单位。\n\n您的程序必须实现上述功能，并在以下三个四边形单元的测试套件上运行，每个单元由隐含参考顺序 $i=1,2,3,4$ 的四个物理节点坐标 $(x_i,y_i)$ 列表指定：\n- 测试用例 A（凸单元，预期有效）：$[(0,0),(2,0),(2,1),(0,1)]$。\n- 测试用例 B（因节点顺序导致方向反转，预期可通过重参数化修正）：$[(0,0),(0,1),(2,1),(2,0)]$。\n- 测试用例 C（自相交蝶形，预期无法通过重参数化修正，需要细分）：$[(0,0),(2,0),(0,1),(2,1)]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的三元组列表，每个测试用例一个，并用方括号括起来。每个三元组必须为 $[J_{\\min}^{\\text{before}},c,m]$ 的形式，其中数字以浮点数形式打印，整数代码 $c$ 以整数形式打印。例如：$[[0.5,0,0.5],[-0.5,1,0.5],[\\ldots,2,\\ldots]]$。", "solution": "该解决方案旨在验证和修正二维双线性四边形单元的等参映射，这是计算岩土力学和有限元分析中的一项基本任务。该过程始于分析所提供的单元几何形状，若几何形状无效，则执行修正程序。\n\n### 1. 等参映射和雅可比行列式\n\n问题的核心在于等参映射，它将一个简单的参考单元（参数坐标 $(\\xi, \\eta) \\in [-1,1]\\times[-1,1]$ 中的一个正方形）关联到物理空间中坐标为 $(x,y)$ 的通用四边形单元。该映射使用形函数 $N_i(\\xi, \\eta)$ 定义：\n$$\nx(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,x_i \\quad \\text{and} \\quad y(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,y_i\n$$\n其中 $(x_i, y_i)$ 是第 $i$ 个物理节点的坐标，对应于参考正方形的第 $i$ 个节点。对于节点 $1, 2, 3, 4$ 分别位于 $(-1,-1), (1,-1), (1,1), (-1,1)$ 的参考正方形，其双线性形函数为：\n$$\nN_1(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta) \\\\\nN_2(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1-\\eta) \\\\\nN_3(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1+\\eta) \\\\\nN_4(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1+\\eta)\n$$\n为了使映射在物理和数学上有效，它必须是可逆且保向的。此特性由雅可比矩阵的行列式 $J(\\xi,\\eta) = \\det(\\mathbf{J})$ 来表征。雅可比矩阵包含物理坐标相对于参数坐标的偏导数：\n$$\n\\mathbf{J}(\\xi,\\eta) = \n\\begin{bmatrix}\n\\dfrac{\\partial x}{\\partial \\xi}  \\dfrac{\\partial x}{\\partial \\eta} \\\\\n\\dfrac{\\partial y}{\\partial \\xi}  \\dfrac{\\partial y}{\\partial \\eta}\n\\end{bmatrix}\n$$\n$\\mathbf{J}$ 的分量是节点坐标的线性组合，其系数是形函数的导数。例如，$\\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^{4}\\frac{\\partial N_i}{\\partial \\xi}\\,x_i$。有效映射的条件是雅可比行列式在整个单元域内必须严格为正，即 $J(\\xi,\\eta)  0$。正行列式确保了从 $(\\xi, \\eta)$ 空间到 $(x, y)$ 空间存在一个唯一的、一对一的映射，并保持局部方向（即，将逆时针路径映射为逆时针路径）。如果 $J(\\xi,\\eta) \\le 0$ 在任何一点成立，单元可能会发生折叠、反转或退化，导致高斯积分等数值过程出现灾难性故障。\n\n为评估给定单元的有效性，我们在参考域内的一组离散采样点网格上计算 $J(\\xi, \\eta)$。问题指定了一个 $5 \\times 5$ 的网格，其中 $\\xi$ 和 $\\eta$ 的取值均来自 $\\Xi=\\{-0.75,\\,-0.25,\\,0,\\,0.25,\\,0.75\\}$。将在此网格上找到的行列式最小值 $J_{\\min}$ 与 $10^{-9}$ 的严格正定性公差进行比较。如果 $J_{\\min}  10^{-9}$，则无需修正，修正代码为 $c=0$。否则，需要采取修正措施。\n\n### 2. 修正策略 1：局部重参数化\n\n如果初始配置无效（$J_{\\min} \\le 10^{-9}$），第一种补救方法是尝试重新排序物理节点。雅可比行列式为负的一个常见原因是，对于一个假定为逆时针 (CCW) 约定的参考单元，节点却以顺时针 (CW) 顺序排列。有时，通过找到对同一组物理顶点的不同遍历方式，可以纠正更复杂的无效几何形状。问题要求测试节点列表的所有 8 种排列，这些排列对应于参考正方形的对称性（二面体群 $D_4$）。这些排列代表了参考单元节点标签的所有可能旋转和反射。\n\n对于初始节点列表 $[p_1, p_2, p_3, p_4]$，这 8 种排列是：\n1. 恒等：$[p_1, p_2, p_3, p_4]$\n2. 逆时针旋转 $90^\\circ$：$[p_4, p_1, p_2, p_3]$\n3. 旋转 $180^\\circ$：$[p_3, p_4, p_1, p_2]$\n4. 逆时针旋转 $270^\\circ$：$[p_2, p_3, p_4, p_1]$\n5. 沿垂直轴翻转：$[p_2, p_1, p_4, p_3]$\n6. 沿水平轴翻转：$[p_4, p_3, p_2, p_1]$\n7. 沿反对角线翻转：$[p_1, p_4, p_3, p_2]$\n8. 沿主对角线翻转：$[p_3, p_2, p_1, p_4]$\n\n对于这 8 种节点配置中的每一种，我们都在采样网格上计算最小雅可比行列式 $J_{\\min}^{\\text{perm}}$。然后，我们找到这些值的最大值，$J_{\\min}^{\\text{best}} = \\max(\\{J_{\\min}^{\\text{perm}}\\})$。如果 $J_{\\min}^{\\text{best}}  10^{-9}$，则重参数化成功。修正代码设为 $c=1$，修正后度量 $m$ 设为 $J_{\\min}^{\\text{best}}$。\n\n### 3. 修正策略 2：细分为三角形\n\n如果没有任何重参数化方法能产生严格为正的最小雅可比行列式，则该单元的几何形状可能过于扭曲（例如，在所有有效排序中均为非凸或自相交），不适用于从凸正方形进行的双线性映射。在这种情况下，备用策略是将四边形细分为两个线性三角形。线性三角形具有恒定的雅可比行列式，而一个有效的三角形（具有不共线的顶点）总会有非零的面积，通过确保逆时针的顶点排序可以使其面积为正。\n\n一个四边形可以沿其两条对角线中的任意一条进行细分：\n1. 连接节点 1 和 3 的对角线：产生三角形 $(p_1, p_2, p_3)$ 和 $(p_1, p_3, p_4)$。\n2. 连接节点 2 和 4 的对角线：产生三角形 $(p_2, p_3, p_4)$ 和 $(p_2, p_4, p_1)$。\n\n细分的质量通过所产生三角形的面积来评判。一个顶点为 $(x_a,y_a), (x_b,y_b), (x_c,y_c)$ 的三角形面积由公式 $A = \\frac{1}{2} [x_a(y_b - y_c) + x_b(y_c - y_a) + x_c(y_a - y_b)]$ 给出。正面积对应于逆时针排序。我们为每条可能的对角线计算两个三角形的绝对面积。对于每条对角线，我们找出两个三角形面积的最小值。所选的对角线是使这个最小面积最大化的那一条。此策略旨在避免产生非常细长或微小的三角形。\n\n设 $m_1$ 为第一条对角线的最小面积，$m_2$ 为第二条对角线的最小面积。修正后度量为 $m = \\max(m_1, m_2)$。修正代码设为 $c=2$。\n\n### 算法实现\n\n实现过程封装了这些步骤。对于由四个节点坐标列表定义的每个测试用例：\n1.  计算初始节点排序的 $J_{\\min}^{\\text{before}}$。\n2.  如果 $J_{\\min}^{\\text{before}}  10^{-9}$，结果为 $[J_{\\min}^{\\text{before}}, 0, J_{\\min}^{\\text{before}}]$。\n3.  否则，尝试重参数化。计算 8 种对称排列下的最小雅可比行列式的最大值。如果此最大值为正，则结果为 $[J_{\\min}^{\\text{before}}, 1, J_{\\min}^{\\text{best}}]$。\n4.  如果重参数化失败，则执行细分。通过比较两种对角线选择来计算细分度量 $m$。结果为 $[J_{\\min}^{\\text{before}}, 2, m]$。\n\n这种结构化方法确保能够找到一个有效的单元表示，无论是通过对轻度扭曲的单元重新标记，还是通过对严重扭曲的单元进行网格细化，从而为计算模拟中的单元处理提供了一个稳健的解决方案。", "answer": "```python\nimport numpy as np\n\ndef get_shape_func_derivs(xi, eta):\n    \"\"\"\n    Computes the derivatives of the 4-node quad shape functions with respect to xi and eta.\n    Nodal order: (-1,-1), (1,-1), (1,1), (-1,1)\n    \"\"\"\n    dNdxi = np.array([\n        -0.25 * (1.0 - eta),\n         0.25 * (1.0 - eta),\n         0.25 * (1.0 + eta),\n        -0.25 * (1.0 + eta)\n    ])\n    dNdeta = np.array([\n        -0.25 * (1.0 - xi),\n        -0.25 * (1.0 + xi),\n         0.25 * (1.0 + xi),\n         0.25 * (1.0 - xi)\n    ])\n    return dNdxi, dNdeta\n\ndef compute_jacobian_det(xi, eta, nodes):\n    \"\"\"\n    Computes the Jacobian determinant for a given (xi, eta) and node coordinates.\n    nodes: a 4x2 numpy array of (x,y) coordinates.\n    \"\"\"\n    dNdxi, dNdeta = get_shape_func_derivs(xi, eta)\n    \n    x_coords = nodes[:, 0]\n    y_coords = nodes[:, 1]\n    \n    j11 = np.dot(dNdxi, x_coords)\n    j12 = np.dot(dNdeta, x_coords)\n    j21 = np.dot(dNdxi, y_coords)\n    j22 = np.dot(dNdeta, y_coords)\n    \n    return j11 * j22 - j12 * j21\n\ndef calculate_min_j(nodes, grid_points):\n    \"\"\"\n    Calculates the minimum Jacobian determinant over a grid of sample points.\n    \"\"\"\n    min_j = float('inf')\n    for xi in grid_points:\n        for eta in grid_points:\n            j_det = compute_jacobian_det(xi, eta, nodes)\n            if j_det  min_j:\n                min_j = j_det\n    return min_j\n\ndef get_permutations(nodes):\n    \"\"\"\n    Generates 8 permutations of the node list corresponding to the dihedral group D4.\n    \"\"\"\n    p1, p2, p3, p4 = nodes\n    # Permutations based on re-labeling of reference square corners\n    return [\n        np.array([p1, p2, p3, p4]),  # Identity\n        np.array([p4, p1, p2, p3]),  # Rotate 90 deg CCW\n        np.array([p3, p4, p1, p2]),  # Rotate 180 deg\n        np.array([p2, p3, p4, p1]),  # Rotate 270 deg CCW\n        np.array([p2, p1, p4, p3]),  # Flip vertical\n        np.array([p4, p3, p2, p1]),  # Flip horizontal\n        np.array([p1, p4, p3, p2]),  # Flip anti-diagonal (y=-x)\n        np.array([p3, p2, p1, p4]),  # Flip main diagonal (y=x)\n    ]\n\ndef triangle_area(p1, p2, p3):\n    \"\"\"\n    Calculates the signed area of a triangle.\n    \"\"\"\n    return 0.5 * (p1[0]*(p2[1] - p3[1]) + p2[0]*(p3[1] - p1[1]) + p3[0]*(p1[1] - p2[1]))\n\ndef process_case(nodes_tuple):\n    \"\"\"\n    Processes a single quadrilateral element, returning the analysis results.\n    \"\"\"\n    nodes = np.array(nodes_tuple, dtype=float)\n    grid_points = np.array([-0.75, -0.25, 0.0, 0.25, 0.75])\n    tolerance = 1e-9\n\n    # 1. Compute min Jacobian for the original configuration\n    j_min_before = calculate_min_j(nodes, grid_points)\n\n    # 2. Check if fix is needed\n    if j_min_before > tolerance:\n        return [j_min_before, 0, j_min_before]\n\n    # 3. Try Fix 1: Local Reparameterization\n    permutations = get_permutations(nodes)\n    min_j_values = [calculate_min_j(p, grid_points) for p in permutations]\n\n    max_of_min_j = -np.inf\n    if min_j_values:\n        max_of_min_j = max(min_j_values)\n    \n    if max_of_min_j > tolerance:\n        return [j_min_before, 1, max_of_min_j]\n\n    # 4. Fix 2: Subdivision into triangles\n    p1, p2, p3, p4 = nodes\n\n    # Diagonal 1-3\n    area1a = triangle_area(p1, p2, p3)\n    area1b = triangle_area(p1, p3, p4)\n    m1 = min(abs(area1a), abs(area1b))\n\n    # Diagonal 2-4\n    area2a = triangle_area(p2, p3, p4)\n    area2b = triangle_area(p2, p4, p1)\n    m2 = min(abs(area2a), abs(area2b))\n\n    m_postfix = max(m1, m2)\n    \n    return [j_min_before, 2, m_postfix]\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Test case A (convex element, expected valid)\n        [(0.0, 0.0), (2.0, 0.0), (2.0, 1.0), (0.0, 1.0)],\n        # Test case B (inverted orientation, fix by reparameterization)\n        [(0.0, 0.0), (0.0, 1.0), (2.0, 1.0), (2.0, 0.0)],\n        # Test case C (bow-tie, requires subdivision)\n        [(0.0, 0.0), (2.0, 0.0), (0.0, 1.0), (2.0, 1.0)],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(result)\n\n    def format_result(res):\n        # Format to match output specification: [float,int,float] with no spaces.\n        return f\"[{res[0]},{int(res[1])},{res[2]}]\"\n\n    formatted_results = [format_result(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3561775"}]}