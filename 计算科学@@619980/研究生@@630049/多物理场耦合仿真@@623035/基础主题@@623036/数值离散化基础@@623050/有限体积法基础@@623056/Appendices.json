{"hands_on_practices": [{"introduction": "许多多物理场问题都涉及反应扩散方程。本练习将指导您从零开始构建一个一维有限体积求解器，重点是为刚性反应源项设计一种保证物理量非负的格式。通过实践 [@problem_id:3507785] 中稳健的数值方法，您将掌握确保模拟结果稳定且具有物理意义的基础技能。", "problem": "考虑一个守恒广延量（单位体积）的标量反应扩散方程，它在一个空间域上以纯守恒形式表示，\n$$\n\\partial_t c = \\nabla \\cdot \\left( D \\nabla c \\right) + R(c),\n$$\n其中 $c$ 是浓度（单位为 $\\mathrm{mol/m^3}$），$D$ 是扩散系数（单位为 $\\mathrm{m^2/s}$），$R(c)$ 是源项（单位为 $\\mathrm{mol/(m^3\\,s)}$）。从局部守恒定律和散度定理出发，构建一个一维域上的单元中心有限体积法。该方法需满足零通量（齐次诺伊曼）边界条件，并能保证通量的精确离散守恒以及浓度的非负性。通过向后欧拉步长对扩散项进行隐式处理，并使用保证 $c \\ge 0$ 的产生-销毁分解对源项进行隐式分裂。该分裂必须满足：仅通量部分能精确保持总质量守恒；在 $R \\equiv 0$ 的特殊情况下，完整更新步骤能保持总质量守恒；在一般情况下，总质量的变化量精确等于源项的离散积分。\n\n你必须从守恒第一性原理出发，推导跨越控制体交界面的离散通量。在交界面上使用与可变扩散系数 $D$ 一致且能对空间单调状态强制保持正值的两点通量近似。为隐式扩散步骤组装最终的线性系统。然后，对于源项，将 $R(c)$ 表示为产生-销毁分裂形式 $R(c) = P(c) - Q(c)\\,c$，其中 $P(c) \\ge 0$ 且 $Q(c) \\ge 0$，并设计一个对每个控制体都是局部的且能保持 $c \\ge 0$ 的向后欧拉更新。\n\n实现一个包含以下步骤的单次隐式算子分裂时间步：\n- 一个隐式扩散步骤，\n- 接着一个基于产生-销毁分裂的隐式源项步骤。\n\n在一维域 $x \\in [0,L]$ 上进行计算，该域具有均匀的单元和单位横截面积。使用齐次诺伊曼边界条件（在 $x=0$ 和 $x=L$ 处扩散通量为零）。总质量应计算为黎曼和 $M = \\sum_i c_i\\,\\Delta x$（单位为 $\\mathrm{mol/m^2}$，这里指浓度在单位面积下对长度的积分）。对于每个测试用例，你必须数值上检验以下性质：\n- 非负性：在完整步骤之后，验证 $\\min_i c_i \\ge 0$。\n- 通量守恒：在扩散步骤之后（源项步骤之前），验证总质量 $M$ 在指定的绝对容差范围内保持不变。\n- 源项一致性：在源项步骤之后，验证总质量变化等于源项的离散积分，即 $M^{n+1} - M^{n+1/2} = \\Delta t \\sum_i \\left[P_i - Q_i\\,c_i^{n+1}\\right]\\,\\Delta x$，其差值在指定的绝对容差范围内。\n\n你的程序必须实现上述方法，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个条目对应一个测试用例，是一个布尔值，指示非负性和质量性质是否都通过了检验。在所有情况下，用于质量检查的绝对容差为 $10^{-10}$。\n\n所有物理参数均使用上述单位表示。不使用角度。输出中的所有结果均为无量纲的布尔值。\n\n测试套件：\n- 测试用例 $1$（仅扩散，可变扩散系数）：\n  - 域长度 $L = 1\\,\\mathrm{m}$，单元数量 $N = 50$，时间步长 $\\Delta t = 1\\,\\mathrm{s}$。\n  - 初始条件 $c(x) = 1 + 0.1 \\cos(2\\pi x/L)$，单位 $\\mathrm{mol/m^3}$。\n  - 扩散系数 $D(x) = 10^{-3} + 5\\times 10^{-4} \\sin(2\\pi x/L)$，单位 $\\mathrm{m^2/s}$。\n  - 源项分裂 $P \\equiv 0$ 和 $Q \\equiv 0$。\n  - 边界条件：在 $x=0$ 和 $x=L$ 处为齐次诺伊曼条件。\n- 测试用例 $2$（带扩散的刚性衰减）：\n  - 域长度 $L = 1\\,\\mathrm{m}$，单元数量 $N = 100$，时间步长 $\\Delta t = 10^{-2}\\,\\mathrm{s}$。\n  - 初始条件 $c(x) = 1\\times 10^{-3} + \\exp\\left(-\\dfrac{(x - 0.5 L)^2}{5\\times 10^{-3}}\\right)$，单位 $\\mathrm{mol/m^3}$。\n  - 扩散系数 $D(x) = 10^{-3}\\left(1 + 0.9\\,\\exp\\left(-\\dfrac{(x - 0.5 L)^2}{10^{-2}} \\right)\\right)$，单位 $\\mathrm{m^2/s}$。\n  - 源项分裂 $P \\equiv 0$，$Q \\equiv k$，其中 $k = 10^{3}\\,\\mathrm{s^{-1}}$。\n  - 边界条件：在 $x=0$ 和 $x=L$ 处为齐次诺伊曼条件。\n- 测试用例 $3$（带扩散的刚性产生-销毁）：\n  - 域长度 $L = 1\\,\\mathrm{m}$，单元数量 $N = 80$，时间步长 $\\Delta t = 5\\times 10^{-2}\\,\\mathrm{s}$。\n  - 初始条件 $c(x) = 0.2 + 0.2 \\sin(3\\pi x/L)$，单位 $\\mathrm{mol/m^3}$。\n  - 扩散系数 $D(x) = 5\\times 10^{-4}$，单位 $\\mathrm{m^2/s}$。\n  - 源项分裂 $P \\equiv 0.5\\,\\mathrm{mol/(m^3\\,s)}$，$Q \\equiv 200\\,\\mathrm{s^{-1}}$。\n  - 边界条件：在 $x=0$ 和 $x=L$ 处为齐次诺伊曼条件。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是字符串 $\\texttt{True}$ 或 $\\texttt{False}$。", "solution": "该问题要求为标量反应扩散方程构建并实现一个一维、单元中心的有限体积法 (FVM)。该格式必须是保正的并且离散守恒。\n\n推导从局部守恒定律的积分形式开始。\n\n控制偏微分方程为：\n$$\n\\partial_t c = \\nabla \\cdot \\left( D \\nabla c \\right) + R(c)\n$$\n其中 $c$ 是浓度，$D$ 是扩散系数，$R(c)$ 是反应源项。\n\n我们将一维域 $x \\in [0, L]$ 离散化为 $N$ 个均匀的控制体（单元），每个宽度为 $\\Delta x = L/N$。第 $i$ 个单元 $V_i$ 覆盖区间 $[x_{i-1/2}, x_{i+1/2}]$，其中心位于 $x_i = (i+0.5)\\Delta x$，$i=0, 1, \\dots, N-1$。单元平均浓度定义为 $c_i(t) \\approx \\frac{1}{\\Delta x} \\int_{V_i} c(x,t) dx$。\n\n在控制体 $V_i$ 上对偏微分方程进行积分（假设单位横截面积）可得：\n$$\n\\int_{V_i} \\partial_t c \\, dx = \\int_{V_i} \\frac{\\partial}{\\partial x} \\left( D \\frac{\\partial c}{\\partial x} \\right) dx + \\int_{V_i} R(c) \\, dx\n$$\n对扩散项应用微积分基本定理（一维散度定理）并对积分进行近似，得到单元平均浓度 $c_i$ 的半离散方程：\n$$\n\\frac{d c_i}{dt} \\Delta x = \\left. \\left( D \\frac{\\partial c}{\\partial x} \\right) \\right|_{x_{i+1/2}} - \\left. \\left( D \\frac{\\partial c}{\\partial x} \\right) \\right|_{x_{i-1/2}} + R(c_i) \\Delta x\n$$\n令 $F = D \\frac{\\partial c}{\\partial x}$ 为扩散通量。方程变为：\n$$\n\\frac{d c_i}{dt} = \\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2}) + R(c_i)\n$$\n为了得到一个相容且守恒的格式，单元 $i$ 和单元 $i+1$ 之间交界面上的通量 $F_{i+1/2}$ 采用两点通量近似 (TPFA) 进行逼近。梯度由中心差分近似，$\\frac{\\partial c}{\\partial x} \\approx \\frac{c_{i+1}-c_i}{\\Delta x}$。为处理可变的扩散系数 $D(x)$，交界面上的有效扩散系数 $D_{i+1/2}$ 使用相邻单元中的值 $D_i = D(x_i)$ 和 $D_{i+1} = D(x_{i+1})$ 的调和平均值计算：\n$$\nF_{i+1/2} \\approx D_{i+1/2} \\frac{c_{i+1} - c_i}{\\Delta x}, \\quad \\text{where} \\quad D_{i+1/2} = \\frac{2 D_i D_{i+1}}{D_i + D_{i+1}}\n$$\n这种选择确保了通量的连续性和物理上的一致性。齐次诺伊曼边界条件对应于在域边界处通量为零：在 $x=0$ 处 $F_{-1/2} = 0$，在 $x=L$ 处 $F_{N-1/2} = 0$。\n\n使用一阶算子分裂（Lie 分裂）来分别处理扩散项和反应项。从 $t^n$到 $t^{n+1}=t^n+\\Delta t$ 的单个时间步包含两个连续的子步骤：\n1.  **隐式扩散步骤**：从 $t^n$ 到 $t^{n+1}$ 求解 $\\frac{\\partial c}{\\partial t} = \\nabla \\cdot (D \\nabla c)$，得到中间解 $c^{n+1/2}$。\n2.  **隐式源项步骤**：以 $c^{n+1/2}$ 为初始条件，从 $t^n$ 到 $t^{n+1}$ 求解 $\\frac{\\partial c}{\\partial t} = R(c)$，得到最终解 $c^{n+1}$。\n\n扩散步骤使用向后欧拉法进行离散化，以保证无条件稳定性：\n$$\n\\frac{c_i^{n+1/2} - c_i^n}{\\Delta t} = \\frac{1}{\\Delta x} (F_{i+1/2}^{n+1/2} - F_{i-1/2}^{n+1/2})\n$$\n代入通量近似，得到关于未知浓度 $\\mathbf{c}^{n+1/2} = [c_0^{n+1/2}, \\dots, c_{N-1}^{n+1/2}]^T$ 的线性方程组。对于内部单元 $i \\in [1, N-2]$：\n$$\nc_i^{n+1/2} - \\frac{\\Delta t}{\\Delta x^2} \\left[ D_{i+1/2}(c_{i+1}^{n+1/2} - c_i^{n+1/2}) - D_{i-1/2}(c_i^{n+1/2} - c_{i-1}^{n+1/2}) \\right] = c_i^n\n$$\n对单元 $i$ 重新整理各项：\n$$\n-\\frac{\\Delta t}{\\Delta x^2} D_{i-1/2} c_{i-1}^{n+1/2} + \\left(1 + \\frac{\\Delta t}{\\Delta x^2} (D_{i+1/2} + D_{i-1/2})\\right) c_i^{n+1/2} - \\frac{\\Delta t}{\\Delta x^2} D_{i+1/2} c_{i+1}^{n+1/2} = c_i^n\n$$\n对于边界单元，我们应用零通量条件。对于单元 $i=0$：$F_{-1/2}=0$，因此方程为 $-\\frac{\\Delta t}{\\Delta x^2} D_{1/2} c_{1}^{n+1/2} + \\left(1 + \\frac{\\Delta t}{\\Delta x^2} D_{1/2}\\right) c_0^{n+1/2} = c_0^n$。对于单元 $i=N-1$：$F_{N-1/2}=0$，因此方程为 $-\\frac{\\Delta t}{\\Delta x^2} D_{N-3/2} c_{N-2}^{n+1/2} + \\left(1 + \\frac{\\Delta t}{\\Delta x^2} D_{N-3/2}\\right) c_{N-1}^{n+1/2} = c_{N-1}^n$。\n这形成了一个对称的、对角占优的三对角线性系统 $\\mathbf{A} \\mathbf{c}^{n+1/2} = \\mathbf{c}^n$，可以被高效求解。得到的矩阵 $\\mathbf{A}$ 是一个M-矩阵，这保证了如果对所有 $i$ 都有 $c_i^n \\ge 0$，那么 $c_i^{n+1/2} \\ge 0$。\n\n扩散步骤的总质量 $M = \\sum_i c_i \\Delta x$ 是守恒的。将半离散扩散方程对所有单元求和：\n$$\n\\sum_{i=0}^{N-1} \\frac{c_i^{n+1/2} - c_i^n}{\\Delta t} \\Delta x = \\sum_{i=0}^{N-1} (F_{i+1/2}^{n+1/2} - F_{i-1/2}^{n+1/2}) = F_{N-1/2}^{n+1/2} - F_{-1/2}^{n+1/2}\n$$\n右边的和是一个伸缩级数。在零通量边界条件下，$F_{-1/2} = F_{N-1/2} = 0$，所以 $\\sum_i (c_i^{n+1/2} - c_i^n) = 0$。这证实了扩散步骤的精确离散质量守恒。\n\n源项步骤从 $c_i^{n+1/2}$ 开始，对每个单元求解常微分方程组 $\\frac{dc_i}{dt} = R(c_i)$。源项被分裂为产生和销毁部分，$R(c) = P(c) - Q(c)c$，其中 $P(c) \\ge 0$ 且 $Q(c) \\ge 0$。应用向后欧拉法可得：\n$$\n\\frac{c_i^{n+1} - c_i^{n+1/2}}{\\Delta t} = P(c_i^{n+1}) - Q(c_i^{n+1}) c_i^{n+1}\n$$\n对于测试用例，$P$ 和 $Q$ 是常数。这使得可以直接求解 $c_i^{n+1}$：\n$$\nc_i^{n+1} (1 + \\Delta t Q) = c_i^{n+1/2} + \\Delta t P \\quad \\implies \\quad c_i^{n+1} = \\frac{c_i^{n+1/2} + \\Delta t P}{1 + \\Delta t Q}\n$$\n这个更新保证了正性：由于扩散步骤确保了 $c_i^{n+1/2} \\ge 0$，并且给定 $\\Delta t > 0$，$P \\ge 0$，$Q \\ge 0$，因此分子是非负的，分母是正的，所以 $c_i^{n+1} \\ge 0$。\n\n源项步骤中总质量的变化与源项的积分是一致的。从更新规则可知：\n$$\nc_i^{n+1} - c_i^{n+1/2} = \\Delta t (P - Q c_i^{n+1})\n$$\n对所有单元求和并乘以 $\\Delta x$：\n$$\n\\sum_i (c_i^{n+1} - c_i^{n+1/2}) \\Delta x = \\Delta t \\sum_i (P - Q c_i^{n+1}) \\Delta x\n$$\n$$\nM^{n+1} - M^{n+1/2} = \\Delta t \\sum_i R(c_i^{n+1}) \\Delta x\n$$\n这验证了总质量的变化量精确等于在新的时间层级上计算的源项的离散积分，这正是隐式方法的要求。\n整个格式在时间上是一阶精确的，对于常数 $D$ 在空间上是二阶精确的，并且被设计为鲁棒的守恒和保正格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef run_one_step(params):\n    \"\"\"\n    Performs a single operator-split time step for the reactive diffusion equation\n    and verifies conservation and positivity properties.\n    \"\"\"\n    L, N, dt, c_init_func, D_func, P, Q, tol = params\n\n    # 1. Setup Grid and Initial Conditions\n    dx = L / N\n    # Cell centers\n    x_centers = (np.arange(N) + 0.5) * dx\n    c_n = c_init_func(x_centers, L)\n\n    # 2. Implicit Diffusion Step\n    \n    # Calculate D at cell centers\n    D_cell = D_func(x_centers, L)\n    \n    # Calculate D at internal faces using harmonic mean.\n    # D_face[i] corresponds to face between cell i and i+1\n    D_face = 2 * D_cell[:-1] * D_cell[1:] / (D_cell[:-1] + D_cell[1:] + 1e-30) # Add epsilon for safety\n    \n    # Assemble the tridiagonal system matrix A for A * c_half = c_n\n    # The system is rearranged from c_h - c_n = dt * Op * c_h to (I - dt*Op)c_h = c_n\n    alpha = dt / dx**2\n    \n    # The matrix for solve_banded is specified by its diagonals.\n    # It has shape (l+u+1, N), where l=1, u=1 are lower/upper bandwidths.\n    # ab[0, 1:] = upper diagonal\n    # ab[1, :]  = main diagonal\n    # ab[2, :-1]= lower diagonal\n    ab = np.zeros((3, N))\n    \n    # Upper/Lower diagonals (symmetric matrix)\n    # The element in the upper diagonal of row i is -alpha * D_{i+1/2}\n    # solve_banded expects ab[0, i+1] to be the (i, i+1) element.\n    # The element in the lower diagonal of row i is -alpha * D_{i-1/2}\n    # solve_banded expects ab[2, i-1] to be the (i, i-1) element.\n    \n    diag_val = -alpha * D_face\n    ab[0, 1:] = diag_val\n    ab[2, :-1] = diag_val\n    \n    # Main diagonal: 1 + alpha*(D_{i+1/2} + D_{i-1/2})\n    # For i=0, it's 1 + alpha*D_{1/2}. For i=N-1, it's 1 + alpha*D_{N-3/2}\n    main_diag = np.ones(N)\n    main_diag[:-1] += alpha * D_face\n    main_diag[1:] += alpha * D_face\n    ab[1, :] = main_diag\n\n    # Solve the tridiagonal system\n    c_half_step = solve_banded((1, 1), ab, c_n)\n    \n    # 3. Implicit Source Step\n    c_final = (c_half_step + dt * P) / (1.0 + dt * Q)\n    \n    # 4. Verification Checks\n    \n    # 4.1. Non-negativity of the final concentration\n    pass_negativity = np.min(c_final) >= 0.0\n    \n    # 4.2. Mass conservation during the diffusion step\n    mass_n = np.sum(c_n) * dx\n    mass_half = np.sum(c_half_step) * dx\n    pass_flux_cons = np.abs(mass_half - mass_n) = tol\n\n    # 4.3. Consistency of mass change with the source term\n    mass_final = np.sum(c_final) * dx\n    mass_change_actual = mass_final - mass_half\n    \n    # Theoretical mass change from source term integral: dt * sum(R(c_final)) * dx\n    # Where R(c) = P - Q*c is evaluated implicitly\n    source_integral = dt * np.sum(P - Q * c_final) * dx\n    pass_source_cons = np.abs(mass_change_actual - source_integral) = tol\n\n    return pass_negativity and pass_flux_cons and pass_source_cons\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the simulation and verification for each.\n    \"\"\"\n    tol = 1e-10\n\n    test_cases = [\n        # Case 1: Diffusion-only, variable D\n        (\n            1.0, 50, 1.0, \n            lambda x, L: 1.0 + 0.1 * np.cos(2 * np.pi * x / L),\n            lambda x, L: 1e-3 + 5e-4 * np.sin(2 * np.pi * x / L),\n            0.0, 0.0, tol\n        ),\n        # Case 2: Stiff decay with diffusion\n        (\n            1.0, 100, 1e-2,\n            lambda x, L: 1e-3 + np.exp(-(x - 0.5 * L)**2 / 5e-3),\n            lambda x, L: 1e-3 * (1.0 + 0.9 * np.exp(-(x - 0.5 * L)**2 / 1e-2)),\n            0.0, 1e3, tol\n        ),\n        # Case 3: Stiff production-destruction with diffusion\n        (\n            1.0, 80, 5e-2,\n            lambda x, L: 0.2 + 0.2 * np.sin(3 * np.pi * x / L),\n            lambda x, L: 5e-4 + 0*x, # Constant D\n            0.5, 200.0, tol\n        ),\n    ]\n\n    results = []\n    for params in test_cases:\n        test_passed = run_one_step(params)\n        results.append(test_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3507785"}, {"introduction": "在复杂的模拟中，将具有不匹配网格的多个计算域耦合在一起是常见的需求。本练习将介绍“砂浆法”(mortar method)，这是一种功能强大的技术，可确保通量在这些“非协调”界面上守恒地传递。掌握 [@problem_id:3507765] 中高效的算法实现，对于开发灵活且精确的多域模型至关重要。", "problem": "考虑一个多物理场环境中的平面界面 $\\Gamma$，该界面位于两个计算子域之间，并为有限体积法（FVM）进行了离散化。该界面由一个嵌入二维空间、单位深度为1的一维线段表示，因此面面积简化为线段长度乘以单位深度1。在界面的每一侧，网格将 $\\Gamma$ 划分为多个面，这些面在界面上的投影是区间。设左侧界面分区为 $\\{I_i\\}_{i=1}^{N_L}$，其端点为 $\\{x^L_i\\}_{i=0}^{N_L}$；右侧界面分区为 $\\{J_j\\}_{j=1}^{N_R}$，其端点为 $\\{x^R_j\\}_{j=0}^{N_R}$。这些分区满足 $x^L_0 = x^R_0 = 0$，$x^L_{N_L} = x^R_{N_R} = L$，并且是严格递增的。\n\n假设供给侧（为明确起见，选择左侧）的法向通量密度在各个面上是分段常数：在 $I_i$ 上其值为 $f_i$，表示 $\\mathbf{F}\\cdot\\mathbf{n}$，其中单位法向量在界面两侧全局一致。穿过一个面的积分通量为 $f_i A_i$，其中面面积 $A_i$ 等于线段长度 $|I_i|$ 乘以单位深度1。一个守恒砂浆传输方法在每个 $J_j$ 上定义了接收侧的通量密度 $g_j$，使得每个接收面上的积分通量都守恒：\n$$\ng_j\\,|J_j| \\;=\\; \\sum_{i=1}^{N_L} f_i\\,|I_i \\cap J_j|\\,,\n$$\n其中 $|I_i \\cap J_j|$ 是供给面 $I_i$ 与接收面 $J_j$ 重叠部分的测度（长度）。\n\n从局部守恒律和散度定理出发，并根据FVM中跨界面通量定义为各面积分法向通量之和，从第一性原理推导上述砂浆传输规则，并设计一个算法，给定供给侧分区端点 $\\{x^L_i\\}$、供给侧通量密度 $\\{f_i\\}$ 和接收侧分区端点 $\\{x^R_j\\}$，该算法仅使用区间重叠来计算 $\\{g_j\\}$。然后，实现一个程序，通过检查\n$$\n\\sum_{i=1}^{N_L} f_i\\,|I_i| \\;\\text{ 和 }\\; \\sum_{j=1}^{N_R} g_j\\,|J_j|\n$$\n在容差阈值 $\\tau$ 内是否相等，来验证全局守恒性是否达到机器精度。其中 $\\tau$ 取 $10^{-12}$。相等性应解释为 $|\\sum_{i=1}^{N_L} f_i\\,|I_i| - \\sum_{j=1}^{N_R} g_j\\,|J_j|| \\le \\tau$。\n\n物理单位：将 $\\mathbf{F}\\cdot\\mathbf{n}$ 视为热通量密度，单位为 $\\mathrm{W\\,m^{-2}}$；面面积 $A_f$ 单位为 $\\mathrm{m^2}$；积分通量 $f_i A_i$ 单位为 $\\mathrm{W}$。程序的输出是布尔值，因此无单位，但输入在物理上是一致的。\n\n角度单位：不适用；未使用角度。\n\n您的算法不得假设网格匹配，并且必须稳健地计算重叠部分。使用双指针扫描法在线性时间 $N_L+N_R$ 内计算重叠。\n\n测试套件。对于每个测试用例，界面长度为 $L=1.0$ 米，单位深度为 $1.0$ 米，因此面面积等于线段长度。两侧的法向量从左到右方向一致。\n\n定义四个测试用例，用于检验守恒砂浆传输的不同方面：\n\n$1.$ 正常情况下的非匹配分区，具有正负混合的通量密度。从供给侧（左）到接收侧（右）：\n- 左侧端点：$\\{0.0, 0.3, 0.7, 1.0\\}$，因此 $N_L=3$。\n- 左侧通量密度 $\\{f_i\\}$，单位 $\\mathrm{W\\,m^{-2}}$：$\\{1.5, -2.0, 3.25\\}$。\n- 右侧端点：$\\{0.0, 0.5, 1.0\\}$，因此 $N_R=2$。\n检查 $|\\sum_i f_i |I_i| - \\sum_j g_j |J_j|| \\le \\tau$，其中 $\\tau = 10^{-12}$。\n\n$2.$ 反向映射（右侧供给到左侧接收），使用不同的非匹配分区，且一个面上的通量为零：\n- 右侧端点：$\\{0.0, 0.4, 0.9, 1.0\\}$，因此 $N_R=3$。\n- 右侧通量密度，单位 $\\mathrm{W\\,m^{-2}}$：$\\{-1.0, 0.0, 2.0\\}$。\n- 左侧端点：$\\{0.0, 0.2, 0.6, 0.65, 0.85, 1.0\\}$，因此 $N_L=5$。\n从右到左进行映射，并使用相同的容差 $\\tau = 10^{-12}$ 检查守恒性。\n\n$3.$ 边界情况，单个接收面覆盖整个界面：\n- 左侧端点：$\\{0.0, 0.25, 0.5, 0.75, 1.0\\}$，因此 $N_L=4$。\n- 左侧通量密度，单位 $\\mathrm{W\\,m^{-2}}$：$\\{2.0, 2.0, 2.0, 2.0\\}$。\n- 右侧端点：$\\{0.0, 1.0\\}$，因此 $N_R=1$。\n从左到右进行映射，并使用 $\\tau = 10^{-12}$ 检查守恒性。\n\n$4.$ 边缘情况，一个非常小的供给段和变化的通量密度：\n- 左侧端点：$\\{0.0, 1.0\\times 10^{-6}, 0.4, 1.0\\}$，因此 $N_L=3$。\n- 左侧通量密度，单位 $\\mathrm{W\\,m^{-2}}$：$\\{1000.0, -250.0, 500.0\\}$。\n- 右侧端点：$\\{0.0, 0.3, 0.7, 1.0\\}$，因此 $N_R=3$。\n从左到右进行映射，并使用 $\\tau = 10^{-12}$ 检查守恒性。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含四个测试用例的结果，格式为方括号括起来的逗号分隔列表，例如，如果所有测试都通过，则为 $\\texttt{[True,True,True,True]}$。每个条目必须是一个布尔值，指示该测试用例的全局守恒性是否在容差 $\\tau$ 内成立。不应打印任何其他文本。", "solution": "该问题要求推导并实现一种守恒砂浆传输方法，用于在有限体积法（FVM）的背景下，耦合平面界面上非共形网格之间的通量。\n\n### 1. 守恒砂浆传输规则的推导\n\n推导始于物理量局部守恒的基本原理，该原理由一个守恒律控制。对于一个稳态问题，在控制体内没有源或汇的情况下，通量矢量 $\\mathbf{F}$ 的守恒律表示为：\n$$\n\\nabla \\cdot \\mathbf{F} = 0\n$$\n将此方程在一个任意控制体 $V$ 上积分，并应用高斯-散度定理，得到：\n$$\n\\int_V \\nabla \\cdot \\mathbf{F} \\, dV = \\oint_{\\partial V} \\mathbf{F} \\cdot \\mathbf{n} \\, dA = 0\n$$\n这表明，穿过任何控制体边界 $\\partial V$ 的净通量为零。\n\n在有限体积法中，计算域被划分为一组离散的控制体（单元）。对每个单元强制执行积分通量守恒。边界积分近似为单元各面上积分通量之和：\n$$\n\\sum_{f \\in \\text{faces}(V)} \\int_{A_f} \\mathbf{F} \\cdot \\mathbf{n}_f \\, dA = 0\n$$\n其中 $A_f$ 是面 $f$ 的面积，$\\mathbf{n}_f$ 是其向外的法向量。$\\mathcal{F}_f = \\int_{A_f} \\mathbf{F} \\cdot \\mathbf{n}_f \\, dA$ 项表示通过面 $f$ 的积分通量。\n\n现在，我们考虑两个子域之间的界面 $\\Gamma$，一个“供给”侧（左侧）和一个“接收”侧（右侧）。从供给侧到接收侧，跨越该界面的总通量必须守恒。设 $\\mathbf{n}$ 为从供给侧指向接收侧的单位法向量，在 $\\Gamma$ 上保持一致。跨界面的总通量为：\n$$\n\\mathcal{F}_{\\Gamma} = \\int_{\\Gamma} \\mathbf{F} \\cdot \\mathbf{n} \\, dA\n$$\n问题规定，在供给侧，界面 $\\Gamma$ 被划分为一组面 $\\{I_i\\}_{i=1}^{N_L}$。垂直于界面的通量密度 $\\mathbf{F} \\cdot \\mathbf{n}$ 在此分区上被假定为分段常数，在面 $I_i$ 上的值为 $f_i$。因此，总通量可以写为供给侧各面上通量之和：\n$$\n\\mathcal{F}_{\\Gamma} = \\sum_{i=1}^{N_L} \\int_{I_i} (\\mathbf{F} \\cdot \\mathbf{n}) \\, dA = \\sum_{i=1}^{N_L} f_i \\int_{I_i} dA = \\sum_{i=1}^{N_L} f_i A_i\n$$\n根据问题简化为单位深度（$1$）的二维设定，面面积 $A_i$ 在数值上等于线段 $I_i$ 的长度，记为 $|I_i|$。\n$$\n\\mathcal{F}_{\\Gamma,\\text{donor}} = \\sum_{i=1}^{N_L} f_i |I_i|\n$$\n类似地，在接收侧，界面被划分为面 $\\{J_j\\}_{j=1}^{N_R}$。我们为每个接收面 $J_j$ 定义一个分段常数通量密度 $g_j$。从接收侧计算的总通量为：\n$$\n\\mathcal{F}_{\\Gamma,\\text{receiver}} = \\sum_{j=1}^{N_R} g_j |J_j|\n$$\n全局守恒要求 $\\mathcal{F}_{\\Gamma,\\text{donor}} = \\mathcal{F}_{\\Gamma,\\text{receiver}}$。然而，为了实现物理上一致且稳定的数值耦合，需要一种更强、更局部的守恒形式。守恒砂浆方法通过将供给侧分区的通量投影到接收侧分区上来强制实现这一点。这是通过要求进入每个独立接收面 $J_j$ 的积分通量必须等于从供给域穿过同一几何区域 $J_j$ 的总通量来实现的。\n\n根据定义，进入接收面 $J_j$ 的积分通量为 $g_j |J_j|$。\n\n从供给侧穿过 $J_j$ 覆盖区域的通量为 $\\int_{J_j} (\\mathbf{F} \\cdot \\mathbf{n})_{\\text{donor}} \\, dA$。由于供给侧通量密度是分段常数（在 $I_i$ 上为 $f_i$），此积分必须根据供给侧分区进行分解：\n$$\n\\int_{J_j} (\\mathbf{F} \\cdot \\mathbf{n})_{\\text{donor}} \\, dA = \\sum_{i=1}^{N_L} \\int_{I_i \\cap J_j} (\\mathbf{F} \\cdot \\mathbf{n})_{\\text{donor}} \\, dA\n$$\n在重叠区域 $I_i \\cap J_j$ 上，供给侧通量密度为 $f_i$。因此：\n$$\n\\int_{J_j} (\\mathbf{F} \\cdot \\mathbf{n})_{\\text{donor}} \\, dA = \\sum_{i=1}^{N_L} f_i \\int_{I_i \\cap J_j} dA = \\sum_{i=1}^{N_L} f_i |I_i \\cap J_j|\n$$\n将进入接收面 $J_j$ 的通量与来自同一区域的供给侧通量相等，便得到了局部守恒律，即指定的砂浆传输规则：\n$$\ng_j |J_j| = \\sum_{i=1}^{N_L} f_i |I_i \\cap J_j|\n$$\n此推导证实了所提供的公式是强制在每个接收面上通过投影给定的分段常数供给侧通量分布来实现通量守恒的直接结果。将此关系对所有接收面 $j$求和，表明它也意味着全局守恒：\n$$\n\\sum_{j=1}^{N_R} g_j |J_j| = \\sum_{j=1}^{N_R} \\sum_{i=1}^{N_L} f_i |I_i \\cap J_j| = \\sum_{i=1}^{N_L} f_i \\left( \\sum_{j=1}^{N_R} |I_i \\cap J_j| \\right)\n$$\n由于接收侧分区 $\\{J_j\\}_{j=1}^{N_R}$ 覆盖了整个界面，给定供给面 $I_i$ 与所有接收面重叠的长度之和等于 $I_i$ 本身的长度：$\\sum_{j=1}^{N_R} |I_i \\cap J_j| = |I_i|$。这导致：\n$$\n\\sum_{j=1}^{N_R} g_j |J_j| = \\sum_{i=1}^{N_L} f_i |I_i|\n$$\n因此，每个接收面上的局部守恒保证了整个界面的全局守恒，这也是程序需要验证的。\n\n### 2. 算法设计\n\n核心任务是计算每个接收面上的积分通量 $g_j |J_j|$，这需要对所有供给面 $I_i$ 的贡献 $f_i |I_i \\cap J_j|$ 进行求和。一个简单的双重循环（遍历 $i$ 和 $j$）的时间复杂度为 $O(N_L N_R)$。可以设计一种更高效的线性时间算法 $O(N_L + N_R)$，即使用双指针扫描，它利用了两个分区都沿界面排序的事实。\n\n设供给侧分区由端点 $\\{x^D_i\\}_{i=0}^{N_D}$ 和通量密度 $\\{f_i\\}_{i=1}^{N_D}$ 定义。一个供给面 $I_i$ 是区间 $[x^D_{i-1}, x^D_i]$。\n设接收侧分区由端点 $\\{x^R_j\\}_{j=0}^{N_R}$ 定义。一个接收面 $J_j$ 是区间 $[x^R_{j-1}, x^R_j]$。\n\n算法流程如下：\n\n1.  **初始化**:\n    -   初始化两个指针（索引）：一个供给侧指针 $i = 1$ 和一个接收侧指针 $j = 1$。\n    -   创建一个大小为 $N_R$ 的数组 `integrated_receiver_flux`，并初始化为零。`integrated_receiver_flux[j-1]` 将累加 $g_j|J_j|$ 的值。\n\n2.  **扫描循环**:\n    -   当 $i \\le N_D$ 且 $j \\le N_R$ 时进行迭代。在每一步中，我们考虑当前的供给面 $I_i = [x^D_{i-1}, x^D_i]$ 和接收面 $J_j = [x^R_{j-1}, x^R_j]$。\n    -   **计算重叠**: 计算两个区间的交集。重叠的起始点是 $\\text{start} = \\max(x^D_{i-1}, x^R_{j-1})$，结束点是 $\\text{end} = \\min(x^D_i, x^R_j)$。重叠部分的长度是 $\\text{length} = \\max(0, \\text{end} - \\text{start})$。\n    -   **累加通量**: 如果重叠长度为正，计算此重叠的通量贡献，并将其加到相应接收面的积分通量上：\n        `integrated_receiver_flux[j-1] += f_i * length`\n    -   **推进指针**: 比较当前区间的端点，以决定推进哪个指针。先结束的那个区间所对应的指针被推进，因为该区间不可能与另一侧后续的任何区间重叠。\n        -   如果 $x^D_i  x^R_j$：供给面 $I_i$ 已用尽。通过递增 $i$ 移动到下一个供给面。\n        -   如果 $x^R_j  x^D_i$：接收面 $J_j$ 已用尽。通过递增 $j$ 移动到下一个接收面。\n        -   如果 $x^D_i = x^R_j$：两个面在同一点结束。它们相互之间都已用尽。同时递增 $i$ 和 $j$。\n\n3.  **终止与验证**:\n    -   当其中一个指针超出其分区的末端时，循环终止。由于两个分区都覆盖了相同的总区间 $[0, L]$，两个指针都将到达终点。\n    -   计算供给侧总通量：$\\mathcal{F}_{\\text{donor}} = \\sum_{i=1}^{N_D} f_i (x^D_i - x^D_{i-1})$。\n    -   计算接收侧总通量：$\\mathcal{F}_{\\text{receiver}} = \\sum_{j=1}^{N_R} \\text{integrated\\_receiver\\_flux}[j-1]$。\n    -   通过检查 $|\\mathcal{F}_{\\text{donor}} - \\mathcal{F}_{\\text{receiver}}| \\le \\tau$ 来验证全局守恒性，其中 $\\tau$ 是指定的容差（$10^{-12}$）。\n\n该算法对两个分区的每个面只处理一次，沿界面从左到右移动。指针递增的总次数最多为 $N_D + N_R$，从而实现了所期望的线性时间复杂度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the mortar transfer test suite.\n    \"\"\"\n    \n    # Define the tolerance for the conservation check.\n    tau = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Happy path nonmatching, mixed flux\n        {\n            \"donor_endpoints\": np.array([0.0, 0.3, 0.7, 1.0]),\n            \"donor_fluxes\": np.array([1.5, -2.0, 3.25]),\n            \"receiver_endpoints\": np.array([0.0, 0.5, 1.0]),\n        },\n        # Case 2: Reverse direction (right-to-left), zero flux\n        {\n            \"donor_endpoints\": np.array([0.0, 0.4, 0.9, 1.0]),  # Right side is donor\n            \"donor_fluxes\": np.array([-1.0, 0.0, 2.0]),\n            \"receiver_endpoints\": np.array([0.0, 0.2, 0.6, 0.65, 0.85, 1.0]), # Left side is receiver\n        },\n        # Case 3: Boundary case with single receiver face\n        {\n            \"donor_endpoints\": np.array([0.0, 0.25, 0.5, 0.75, 1.0]),\n            \"donor_fluxes\": np.array([2.0, 2.0, 2.0, 2.0]),\n            \"receiver_endpoints\": np.array([0.0, 1.0]),\n        },\n        # Case 4: Edge case with a very small donor segment\n        {\n            \"donor_endpoints\": np.array([0.0, 1.0e-6, 0.4, 1.0]),\n            \"donor_fluxes\": np.array([1000.0, -250.0, 500.0]),\n            \"receiver_endpoints\": np.array([0.0, 0.3, 0.7, 1.0]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        is_conserved = check_conservation(\n            case[\"donor_endpoints\"],\n            case[\"donor_fluxes\"],\n            case[\"receiver_endpoints\"],\n            tau\n        )\n        results.append(is_conserved)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef check_conservation(donor_endpoints, donor_fluxes, receiver_endpoints, tolerance):\n    \"\"\"\n    Computes flux transfer using a two-pointer sweep algorithm and verifies global conservation.\n\n    Args:\n        donor_endpoints (np.ndarray): Sorted endpoints of the donor partition.\n        donor_fluxes (np.ndarray): Flux densities for each donor face.\n        receiver_endpoints (np.ndarray): Sorted endpoints of the receiver partition.\n        tolerance (float): The tolerance for checking conservation.\n\n    Returns:\n        bool: True if global flux is conserved within the tolerance, False otherwise.\n    \"\"\"\n    \n    # Calculate total integrated flux from the donor side\n    donor_lengths = np.diff(donor_endpoints)\n    total_donor_flux = np.sum(donor_fluxes * donor_lengths)\n\n    # Initialize variables for the two-pointer sweep\n    num_donor_faces = len(donor_fluxes)\n    num_receiver_faces = len(receiver_endpoints) - 1\n    \n    integrated_receiver_flux = np.zeros(num_receiver_faces)\n    \n    donor_idx = 0\n    receiver_idx = 0\n    \n    # Two-pointer sweep algorithm\n    while donor_idx  num_donor_faces and receiver_idx  num_receiver_faces:\n        # Get current donor and receiver interval endpoints\n        donor_start = donor_endpoints[donor_idx]\n        donor_end = donor_endpoints[donor_idx + 1]\n        \n        receiver_start = receiver_endpoints[receiver_idx]\n        receiver_end = receiver_endpoints[receiver_idx + 1]\n        \n        # Calculate overlap interval and length\n        overlap_start = max(donor_start, receiver_start)\n        overlap_end = min(donor_end, receiver_end)\n        overlap_length = max(0.0, overlap_end - overlap_start)\n        \n        # If there is an overlap, add its flux contribution to the receiver face\n        if overlap_length > 0:\n            flux_density = donor_fluxes[donor_idx]\n            integrated_receiver_flux[receiver_idx] += flux_density * overlap_length\n        \n        # Advance the pointer of the interval that ends first\n        if donor_end  receiver_end:\n            donor_idx += 1\n        elif receiver_end  donor_end:\n            receiver_idx += 1\n        else:  # Endpoints coincide\n            donor_idx += 1\n            receiver_idx += 1\n            \n    # Calculate total integrated flux on the receiver side\n    total_receiver_flux = np.sum(integrated_receiver_flux)\n    \n    # Check for conservation within the specified tolerance\n    return abs(total_donor_flux - total_receiver_flux) = tolerance\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3507765"}, {"introduction": "隐式时间积分格式通常会产生非线性代数方程组，而牛顿法是求解这些方程组的标准工具。然而，标准的牛顿法迭代步可能会导致浓度等物理量出现不符合物理现实的负值。本练习 [@problem_id:3507801] 深入探讨了在非线性求解器内部强制实施物理量非负性这一关键挑战，并揭示了在数值修正与严格遵守物理守恒定律之间存在的重要权衡。", "problem": "考虑一个单物种、等温的输运-反应问题，该问题建立在长度为 $L$ 的一维域上，浓度场为 $c(x,t)$。其潜在的物种平衡是局部守恒定律\n$$\n\\frac{\\partial c}{\\partial t} = \\nabla \\cdot \\left( D \\nabla c \\right) + R(c),\n$$\n其中 $D$ 是扩散系数，$R(c)$ 是反应源项。在一维设定中，采用齐次诺伊曼（零通量）边界条件，并使用一个由 $N$ 个宽度为 $\\Delta x = L/N$ 的控制体积组成的均匀网格。应用有限体积法 (FVM)：在每个控制体积 $V_i$ 上对守恒定律进行积分，并对面通量使用两点通量近似，从而产生离散平衡。使用大小为 $\\Delta t$ 的时间步长进行后向欧拉时间积分，可以得到一个关于新时间层上未知浓度 $\\{c_i^{n+1}\\}_{i=1}^N$ 的非线性代数系统，该系统可以写成残差形式\n$$\nF_i(\\mathbf{c}^{n+1}) = c_i^{n+1} - c_i^{n} - \\Delta t \\left( \\frac{D}{\\Delta x^2} \\sum_{j \\in \\mathcal{N}(i)} a_{ij} c_j^{n+1} + R(c_i^{n+1}) \\right) = 0,\n$$\n其中 $\\mathcal{N}(i)$ 表示在齐次诺伊曼边界条件下由两点通量离散化所产生的单元 $i$ 的邻居模板，$a_{ij}$ 是离散拉普拉斯模板系数。对于内部单元 $i$，这些系数强制执行二阶差分，而在边界处，它们通过适当的虚拟单元消除来编码零通量。\n\n我们关注非线性反应 $R(c) = -k_2 c^2$（其中 $k_2 \\ge 0$），设置 $L=1$，并考虑无量纲量。该非线性系统将通过牛顿法求解，其更新方式如下\n$$\n\\mathbf{c}^{(m+1)} = \\mathbf{c}^{(m)} + \\gamma^{(m)} \\Delta \\mathbf{c}^{(m)},\n\\quad\n\\text{其中}\n\\quad\n\\left[ \\mathbf{J}(\\mathbf{c}^{(m)}) \\right] \\Delta \\mathbf{c}^{(m)} = - \\mathbf{F}(\\mathbf{c}^{(m)}).\n$$\n其中 $\\mathbf{J}$ 是雅可比矩阵，$\\gamma^{(m)} \\in (0,1]$ 是为确保残差单调递减而选择的线搜索参数。为防止牛顿迭代过程中出现非物理的负浓度，一种策略是通过以下定义将试探性更新投影到可行集 $c_i \\ge 0$ 上\n$$\n\\mathbf{c}^{(m+1)} = \\mathcal{P}_{\\mathbb{R}_+^N} \\left( \\mathbf{c}^{(m)} + \\gamma^{(m)} \\Delta \\mathbf{c}^{(m)} \\right),\n$$\n其中 $\\mathcal{P}_{\\mathbb{R}_+^N}$ 表示到非负象限的欧几里得投影，即当分量为负时将其截断为零。这种投影会修改可行集边界附近的牛顿步，并可能影响收敛性质和离散守恒性。\n\n您的任务是编写一个完整的程序，该程序：\n- 为所述问题实现一维隐式 FVM 残差 $\\mathbf{F}(\\mathbf{c})$ 和雅可比矩阵 $\\mathbf{J}(\\mathbf{c})$，其中包含齐次诺伊曼边界条件和二次汇项 $R(c) = -k_2 c^2$。\n- 用两种变体求解非线性系统：一种是无约束牛顿法，另一种是投影牛顿法，后者在每次试探性更新后应用投影 $\\mathcal{P}_{\\mathbb{R}_+^N}$，并使用回溯线搜索来单调减小残差范数。\n- 对每个变体，报告从 $\\mathbf{c}^n$ 到 $\\mathbf{c}^{n+1}$ 的单个隐式步的以下指标：\n    1. $I_{\\text{conv}}$：一个整数指示符，如果求解器收敛到残差范数小于容差，则为 $1$，否则为 $0$。\n    2. $k_{\\text{it}}$：执行的牛顿迭代次数。\n    3. $c_{\\min}$：最终浓度向量的最小值。\n    4. $M_{\\text{err}}$：离散质量平衡误差，定义为 $\\sum_{i=1}^{N} F_i(\\mathbf{c}^{n+1})$，在残差方程的精确解处该值为零，否则量化了守恒性的违反程度。\n    5. $r_{\\text{norm}}$：最终的残差 $2$-范数 $\\|\\mathbf{F}(\\mathbf{c}^{n+1})\\|_2$。\n\n牛顿法必须从 $\\mathbf{c}^{(0)} = \\mathbf{c}^n$ 开始。线搜索必须单调地减小残差范数，并在达到足够的减小量或步长变得过小时终止。取残差范数容差为 $\\varepsilon = 10^{-10}$，最大迭代次数为 $50$。\n\n设计 $L=1$ 且有 $N$ 个单元的均匀网格，并使用以下参数值和初始条件的测试套件，这些测试套件检验了方法的不同方面：\n\n- 测试用例 1（仅扩散，理想情况）：\n    - $N = 50$，$\\Delta t = 0.01$，$D = 0.1$，$k_2 = 0$。\n    - 初始条件：$c_i^n = 1 + 0.2 \\sin(2\\pi x_i)$，其中 $x_i = (i+0.5)\\Delta x$，$i=0,\\dots,N-1$。\n- 测试用例 2（具有弱扩散的刚性非线性汇项）：\n    - $N = 50$，$\\Delta t = 0.1$，$D = 0.01$，$k_2 = 50$。\n    - 初始条件：$c_i^n = 0.05 + 0.02 \\sin(2\\pi x_i)$。\n- 测试用例 3（仅有反应且包含零的边界情况）：\n    - $N = 10$，$\\Delta t = 0.2$，$D = 0$，$k_2 = 100$。\n    - 初始条件：$c_i^n = \\max(0, 0.1 - 0.02 i)$。\n\n您的程序必须为每个测试用例计算出包含 10 个结果的元组（10-tuple）\n$$\n\\left[\nI_{\\text{conv}}^{\\text{proj}},\nk_{\\text{it}}^{\\text{proj}},\nc_{\\min}^{\\text{proj}},\nM_{\\text{err}}^{\\text{proj}},\nr_{\\text{norm}}^{\\text{proj}},\nI_{\\text{conv}}^{\\text{unproj}},\nk_{\\text{it}}^{\\text{unproj}},\nc_{\\min}^{\\text{unproj}},\nM_{\\text{err}}^{\\text{unproj}},\nr_{\\text{norm}}^{\\text{unproj}}\n\\right],\n$$\n其中“proj”和“unproj”分别表示投影牛顿法和无约束牛顿法变体。所有浮点输出必须四舍五入到六位小数。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含三个测试用例的结果，格式为无空格、逗号分隔的列表的列表，例如\n$$\n\\left[ [ r_{11}, r_{12}, \\dots, r_{1,10} ], [ r_{21}, \\dots, r_{2,10} ], [ r_{31}, \\dots, r_{3,10} ] \\right],\n$$\n精确打印为\n$[[r_{11},r_{12},\\dots,r_{1,10}],[r_{21},\\dots,r_{2,10}],[r_{31},\\dots,r_{3,10}]]$,\n其中每个 $r_{jk}$ 都遵守上述类型和四舍五入的规范。\n\n角度单位未出现。由于问题是无量纲化的，因此不需要物理单位；因此，所有报告的量都是无单位的实数或整数。程序不得要求任何用户输入，并且必须是完全自包含的。", "solution": "该问题是适定的、科学上合理的，并提供了求解所需的所有必要信息。它构成了使用有限体积法结合牛顿-克雷洛夫求解器求解非线性偏微分方程的一个标准练习。我们开始进行求解。\n\n问题的核心是求解一个非线性代数方程组，该方程组源于对控制反应-扩散偏微分方程（PDE）的离散化。该 PDE 由以下公式给出：\n$$\n\\frac{\\partial c}{\\partial t} = \\nabla \\cdot \\left( D \\nabla c \\right) + R(c)\n$$\n该方程定义在一维域 $x \\in [0, L]$（$L=1$）上，并在 $x=0$ 和 $x=L$ 处服从齐次诺伊曼（零通量）边界条件。指定的反应项是一个二阶汇项，$R(c) = -k_2 c^2$。\n\n我们首先对 PDE 进行离散化。在一个由 $N$ 个宽度为 $\\Delta x = L/N$ 的控制体积组成的均匀网格上应用有限体积法 (FVM)。单元 $i$（其中 $i=0, \\dots, N-1$）的中心位于 $x_i = (i+0.5)\\Delta x$。在控制体积 $V_i = [x_i - \\Delta x/2, x_i + \\Delta x/2]$ 上对 PDE 进行积分并应用散度定理，得到：\n$$\n\\int_{V_i} \\frac{\\partial c}{\\partial t} dV = \\int_{\\partial V_i} (D \\nabla c) \\cdot \\mathbf{n} dS + \\int_{V_i} R(c) dV\n$$\n对单元 $i$ 逐个单元地近似积分，我们得到：\n$$\n\\Delta x \\frac{d c_i}{d t} \\approx \\left( D \\frac{\\partial c}{\\partial x} \\right)_{i+1/2} - \\left( D \\frac{\\partial c}{\\partial x} \\right)_{i-1/2} + \\Delta x R(c_i)\n$$\n其中 $c_i$ 是单元 $i$ 中的平均浓度，导数在单元面上求值。对单元面上的通量使用中心差分近似，内部单元的扩散项变为：\n$$\n\\frac{1}{\\Delta x} \\left[ D \\frac{c_{i+1}-c_i}{\\Delta x} - D \\frac{c_i-c_{i-1}}{\\Delta x} \\right] = \\frac{D}{\\Delta x^2} (c_{i-1} - 2c_i + c_{i+1})\n$$\n使用虚拟单元来强制执行零通量边界条件。在 $x=0$ 处，通量为零，这意味着 $c_{-1}=c_0$。在 $x=L$ 处，通量为零，这意味着 $c_N=c_{N-1}$。这导出了以下离散扩散算子：\n- 对于单元 $i=0$：$\\frac{D}{\\Delta x^2} (c_1 - c_0)$\n- 对于单元 $i \\in (0, N-1)$：$\\frac{D}{\\Delta x^2} (c_{i-1} - 2c_i + c_{i+1})$\n- 对于单元 $i=N-1$：$\\frac{D}{\\Delta x^2} (c_{N-2} - c_{N-1})$\n\n应用后向欧拉法进行时间积分，其中 $\\frac{dc_i}{dt} \\approx \\frac{c_i^{n+1} - c_i^n}{\\Delta t}$，我们得到了关于未知浓度 $\\mathbf{c}^{n+1} = (c_0^{n+1}, \\dots, c_{N-1}^{n+1})$ 的非线性系统。该系统可以写成残差形式 $\\mathbf{F}(\\mathbf{c}^{n+1}) = \\mathbf{0}$，其中第 $i$ 个分量是：\n$$\nF_i(\\mathbf{c}^{n+1}) = c_i^{n+1} - c_i^{n} - \\Delta t \\left( \\text{Diffusion}_i(\\mathbf{c}^{n+1}) + R(c_i^{n+1}) \\right) = 0\n$$\n代入推导出的各项，我们得到关于 $\\mathbf{c} \\equiv \\mathbf{c}^{n+1}$ 的表达式：\n- 对于 $i=0$：$F_0(\\mathbf{c}) = c_0 - c_0^n - \\Delta t \\left( \\frac{D}{\\Delta x^2}(c_1 - c_0) - k_2 c_0^2 \\right)$\n- 对于 $0  i  N-1$：$F_i(\\mathbf{c}) = c_i - c_i^n - \\Delta t \\left( \\frac{D}{\\Delta x^2}(c_{i-1} - 2c_i + c_{i+1}) - k_2 c_i^2 \\right)$\n- 对于 $i=N-1$：$F_{N-1}(\\mathbf{c}) = c_{N-1} - c_{N-1}^n - \\Delta t \\left( \\frac{D}{\\Delta x^2}(c_{N-2} - c_{N-1}) - k_2 c_{N-1}^2 \\right)$\n\n这个非线性系统使用牛顿法求解。在每次迭代 $m$ 中，我们求解线性系统以获得更新量 $\\Delta\\mathbf{c}^{(m)}$：\n$$\n\\mathbf{J}(\\mathbf{c}^{(m)}) \\Delta\\mathbf{c}^{(m)} = -\\mathbf{F}(\\mathbf{c}^{(m)})\n$$\n其中 $\\mathbf{J}$ 是雅可比矩阵，其元素为 $J_{ij} = \\frac{\\partial F_i}{\\partial c_j}$。雅可比矩阵是一个三对角矩阵。定义 $\\alpha = \\frac{D \\Delta t}{\\Delta x^2}$，其非零元素为：\n- 对角线元素 $J_{ii}$：\n  - $J_{00} = 1 + \\alpha + 2 \\Delta t k_2 c_0$\n  - $J_{ii} = 1 + 2\\alpha + 2 \\Delta t k_2 c_i$ for $0  i  N-1$\n  - $J_{N-1,N-1} = 1 + \\alpha + 2 \\Delta t k_2 c_{N-1}$\n- 非对角线元素：\n  - $J_{i, i+1} = -\\alpha$ for $i=0, \\dots, N-2$\n  - $J_{i, i-1} = -\\alpha$ for $i=1, \\dots, N-1$\n\n解通过 $\\mathbf{c}^{(m+1)} = \\mathbf{c}^{(m)} + \\gamma^{(m)} \\Delta\\mathbf{c}^{(m)}$ 进行更新，其中 $\\gamma^{(m)} \\in (0, 1]$ 是通过回溯线搜索确定的步长，以确保残差范数单调递减，即 $\\|\\mathbf{F}(\\mathbf{c}^{(m+1)})\\|_2  \\|\\mathbf{F}(\\mathbf{c}^{(m)})\\|_2$。\n\n为保持物理约束 $c_i \\ge 0$，投影牛顿法修改了更新步骤：\n$$\n\\mathbf{c}^{(m+1)} = \\mathcal{P}_{\\mathbb{R}_+^N} \\left( \\mathbf{c}^{(m)} + \\gamma^{(m)} \\Delta \\mathbf{c}^{(m)} \\right)\n$$\n其中 $\\mathcal{P}_{\\mathbb{R}_+^N}(\\mathbf{v})_i = \\max(v_i, 0)$ 是到非负象限的逐分量投影。该投影在线搜索内部、计算试探步之后、评估新残差之前应用。\n\n单个时间步的算法如下：\n1. 初始化牛顿迭代：$\\mathbf{c}^{(0)} = \\mathbf{c}^n$，迭代计数器 $k_{\\text{it}} = 0$。\n2. 迭代直至收敛或达到最大迭代次数（$50$）为止：\n    a. 计算残差 $\\mathbf{F}(\\mathbf{c}^{(k_{\\text{it}})})$ 及其 $2$-范数 $r_{\\text{norm}}$。\n    b. 如果 $r_{\\text{norm}}  10^{-10}$，则求解器已收敛。设置 $I_{\\text{conv}}=1$ 并退出循环。\n    c. 以带状格式组装雅可比矩阵 $\\mathbf{J}(\\mathbf{c}^{(k_{\\text{it}})})$。\n    d. 使用高效的带状求解器求解三对角系统 $\\mathbf{J} \\Delta\\mathbf{c} = -\\mathbf{F}$，以获得牛顿更新量 $\\Delta\\mathbf{c}$。\n    e. 执行回溯线搜索：从 $\\gamma=1$ 开始，并减小它（例如，减半），直到满足 $\\|\\mathbf{F}(\\mathbf{c}_{\\text{new}})\\|  r_{\\text{norm}}$ 或 $\\gamma$ 变得过小。对于无约束方法，新的候选解是 $\\mathbf{c}_{\\text{new}} = \\mathbf{c}^{(k_{\\text{it}})} + \\gamma \\Delta\\mathbf{c}$；对于投影方法，则是 $\\mathbf{c}_{\\text{new}} = \\mathcal{P}_{\\mathbb{R}_+^N}(\\mathbf{c}^{(k_{\\text{it}})} + \\gamma \\Delta\\mathbf{c})$。\n    f. 如果找到合适的步长，则更新 $\\mathbf{c}^{(k_{\\text{it}}+1)} = \\mathbf{c}_{\\text{new}}$。否则，线搜索失败，迭代终止。\n    g. 增加迭代计数器。\n3. 循环终止后，计算最终指标：$I_{\\text{conv}}$、$k_{\\text{it}}$、$c_{\\min} = \\min(\\mathbf{c}^{n+1})$、$M_{\\text{err}} = \\sum_i F_i(\\mathbf{c}^{n+1})$ 和 $r_{\\text{norm}} = \\|\\mathbf{F}(\\mathbf{c}^{n+1})\\|_2$。\n\n此过程针对无约束和投影牛顿变体实现，并应用于三个指定的测试用例。然后按要求收集并格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef calculate_residual(c, cn, N, dx, dt, D, k2):\n    \"\"\"\n    Computes the residual vector F(c) for the nonlinear system.\n    F(c) = c - cn - dt * (Diffusion(c) + Reaction(c)) = 0\n    \"\"\"\n    if np.any(np.isinf(c)) or np.any(np.isnan(c)):\n        return np.full_like(c, np.inf)\n\n    # Diffusion term\n    diff = np.zeros(N)\n    if D > 0:\n        # Interior cells\n        diff[1:-1] = (c[:-2] - 2 * c[1:-1] + c[2:])\n        # Neumann boundary conditions\n        diff[0] = (c[1] - c[0])\n        diff[-1] = (c[-2] - c[-1])\n        diff *= (D / dx**2)\n\n    # Reaction term\n    reac = -k2 * c**2\n    \n    res = c - cn - dt * (diff + reac)\n    return res\n\ndef calculate_jacobian(c, N, dx, dt, D, k2):\n    \"\"\"\n    Computes the Jacobian matrix J(c) in banded format for solve_banded.\n    J_ij = d(F_i)/d(c_j)\n    The format is l=1 lower diagonal, u=1 upper diagonal.\n    ab[0,:] = super-diagonal\n    ab[1,:] = main-diagonal\n    ab[2,:] = sub-diagonal\n    \"\"\"\n    ab = np.zeros((3, N))\n    alpha = D * dt / dx**2\n    \n    # Main diagonal: d/dc_i (c_i - dt*Diff_i - dt*Reac_i)\n    main_diag = 1.0 + 2.0 * dt * k2 * c\n    if D > 0:\n        main_diag += 2.0 * alpha\n    \n    ab[1, :] = main_diag\n    if D > 0:\n        # Boundary corrections for main diagonal\n        ab[1, 0] = 1.0 + alpha + 2.0 * dt * k2 * c[0]\n        ab[1, -1] = 1.0 + alpha + 2.0 * dt * k2 * c[-1]\n    \n    # Off-diagonals\n    if D > 0:\n        # Upper diagonal: d/dc_{i+1}\n        ab[0, 1:] = -alpha\n        # Lower diagonal: d/dc_{i-1}\n        ab[2, :-1] = -alpha\n        \n    return ab\n\ndef newton_solver(cn, N, dx, dt, D, k2, projected):\n    \"\"\"\n    Solves the nonlinear system F(c) = 0 using a Newton method.\n    \"\"\"\n    max_iter = 50\n    tol = 1e-10\n    \n    c = cn.copy()\n    i_conv = 0\n    k_it = 0\n\n    for k in range(max_iter):\n        res = calculate_residual(c, cn, N, dx, dt, D, k2)\n        res_norm = np.linalg.norm(res)\n\n        if res_norm  tol:\n            i_conv = 1\n            k_it = k\n            break\n        \n        k_it = k + 1\n\n        J_banded = calculate_jacobian(c, N, dx, dt, D, k2)\n        \n        try:\n            delta_c = solve_banded((1, 1), J_banded, -res)\n        except np.linalg.LinAlgError:\n            # Jacobian is singular, cannot proceed\n            break\n        \n        # Backtracking line search\n        gamma = 1.0\n        c_new = c  # Fallback if line search fails\n        found_step = False\n        while gamma > 1e-8:\n            c_temp = c + gamma * delta_c\n            if projected:\n                c_temp[c_temp  0] = 0.0\n            \n            res_new = calculate_residual(c_temp, cn, N, dx, dt, D, k2)\n            res_norm_new = np.linalg.norm(res_new)\n            \n            if res_norm_new  res_norm:\n                c_new = c_temp\n                found_step = True\n                break\n            \n            gamma /= 2.0\n        \n        if not found_step:\n            break\n        \n        c = c_new\n    else: # Loop finished without break\n        # Check final residual if max_iter was reached\n        res = calculate_residual(c, cn, N, dx, dt, D, k2)\n        res_norm = np.linalg.norm(res)\n        if res_norm  tol:\n            i_conv = 1\n            k_it = max_iter\n\n    # Final metrics\n    final_res = calculate_residual(c, cn, N, dx, dt, D, k2)\n    final_res_norm = np.linalg.norm(final_res)\n    c_min = np.min(c)\n    m_err = np.sum(final_res)\n    \n    # Final check on convergence status\n    if final_res_norm >= tol:\n        i_conv = 0\n\n    return [i_conv, k_it, c_min, m_err, final_res_norm]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # (N, dt, D, k2, ic_type, ic_params)\n    test_cases = [\n        (50, 0.01, 0.1, 0.0, 'func', [lambda x: 1 + 0.2 * np.sin(2 * np.pi * x)]),\n        (50, 0.1, 0.01, 50.0, 'func', [lambda x: 0.05 + 0.02 * np.sin(2 * np.pi * x)]),\n        (10, 0.2, 0.0, 100.0, 'vector', [0.1, 0.02]),\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        N, dt, D, k2, ic_type, ic_params = case\n        L = 1.0\n        dx = L / N\n        \n        if ic_type == 'func':\n            xi = (np.arange(N) + 0.5) * dx\n            func = ic_params[0]\n            cn = func(xi)\n        elif ic_type == 'vector':\n            c_start, slope_coeff = ic_params\n            cn = np.maximum(0, c_start - slope_coeff * np.arange(N))\n\n        # Projected Newton solver\n        res_proj = newton_solver(cn, N, dx, dt, D, k2, projected=True)\n        # Unconstrained Newton solver\n        res_unproj = newton_solver(cn, N, dx, dt, D, k2, projected=False)\n        \n        # Combine and round floats\n        combined = res_proj + res_unproj\n        \n        formatted_list = [\n            combined[0], combined[1], round(combined[2], 6), round(combined[3], 6), round(combined[4], 6),\n            combined[5], combined[6], round(combined[7], 6), round(combined[8], 6), round(combined[9], 6)\n        ]\n        \n        all_results.append(formatted_list)\n\n    # Format the final output string\n    result_strings = []\n    for res_list in all_results:\n        result_strings.append(f\"[{','.join(map(str, res_list))}]\")\n        \n    print(f\"[[{','.join(result_strings)}]]\")\n\nsolve()\n```", "id": "3507801"}]}