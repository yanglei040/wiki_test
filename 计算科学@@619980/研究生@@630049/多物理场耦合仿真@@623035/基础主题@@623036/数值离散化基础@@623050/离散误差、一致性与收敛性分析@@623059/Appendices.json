{"hands_on_practices": [{"introduction": "许多复杂的多物理场问题通过分区方法求解，其中每个物理场被交替或同时求解，并通过迭代来耦合。这些分区迭代的收敛性对于整个仿真的鲁棒性和效率至关重要。本练习将通过一个简化的热力耦合问题，指导你推导两种常见分区策略（块雅可比和块高斯-赛德尔）的误差传播矩阵，并计算它们的谱半径来定量评估收敛性 [@problem_id:3504785]。", "problem": "一根长度为 $L$、横截面积为 $A$ 的一维线性热弹性杆，在参考绝对温度 $\\theta_{0}$ 附近的小应变和小温升条件下进行建模。该杆左端固定，右端有轴向位移 $u$；温度场假设为均匀的，并由单个自由度 $T$ 表示。力学平衡是准静态的（无惯性），热平衡采用包含热容的 Fourier 传导。考虑从时间 $t^{n}$ 到 $t^{n+1}$ 的一个大小为 $\\Delta t$ 的后向（隐式）Euler 时间步，以及力学和热学均简化为单自由度的单个线性两节点杆单元。由此产生的关于未知数 $(u^{n+1}, T^{n+1})$ 的整体线性系统呈分块形式\n$$\n\\begin{pmatrix}\nK & -C \\\\\nD_{\\mathrm{eff}} & H\n\\end{pmatrix}\n\\begin{pmatrix}\nu^{n+1} \\\\[4pt]\nT^{n+1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nr_{u} \\\\[4pt]\nr_{T}\n\\end{pmatrix},\n$$\n其中\n- $K = E A / L$ 为轴向刚度，\n- $H = c \\rho A L / \\Delta t + \\kappa A / L$ 为热学后向 Euler 有效热容加导热系数，\n- $C = E A \\alpha_{\\mathrm{th}}$ 为进入力学方程的热弹性热载荷系数，\n- $D_{\\mathrm{eff}} = \\theta_{0} \\alpha_{\\mathrm{th}} E A / \\Delta t$ 为时间离散化后进入热学方程的有效热弹性耦合系数，\n这里 $E$ 是杨氏模量，$\\alpha_{\\mathrm{th}}$ 是热膨胀系数，$\\kappa$ 是导热系数， $c$ 是比热容，$\\rho$ 是质量密度。假设右端项 $(r_{u}, r_{T})$ 是有界的。\n\n考虑采用两种分区定点策略来求解该耦合系统：\n- Block-Jacobi（同时）分区迭代：在第 $k+1$ 次迭代中，分别使用右端的 $T^{k}$ 和 $u^{k}$ 求解力学和热学子问题。\n- Block-Gauss–Seidel（顺序）分区迭代：在第 $k+1$ 次迭代中，使用 $T^{k}$ 从力学子问题更新 $u^{k+1}$，然后使用 $u^{k+1}$ 从热学子问题更新 $T^{k+1}$。\n\n任务：\n1) 从上述两种分区迭代的定义和整体分块系统出发，推导迭代误差 $e_{u}^{k} = u^{k} - u^{\\star}$ 和 $e_{T}^{k} = T^{k} - T^{\\star}$ 的线性误差传播映射，其中 $(u^{\\star}, T^{\\star})$ 是整体系统的解。然后，仅使用线性代数和谱半径的定义，用 $K$、$H$、$C$ 和 $D_{\\mathrm{eff}}$ 表示 Block-Jacobi 和 Block-Gauss–Seidel 误差传播矩阵的谱半径 $\\rho_{\\mathrm{J}}$ 和 $\\rho_{\\mathrm{GS}}$。\n2) 使用物理上一致的参数\n- $E = 210 \\times 10^{9}$, $A = 10^{-4}$, $L = 1$, $\\alpha_{\\mathrm{th}} = 1.2 \\times 10^{-5}$,\n- $\\kappa = 45$, $c = 450$, $\\rho = 7800$, $\\theta_{0} = 293$, $\\Delta t = 1$,\n计算 $K$、$H$、$C$ 和 $D_{\\mathrm{eff}}$，然后评估 $\\rho_{\\mathrm{J}}$ 和 $\\rho_{\\mathrm{GS}}$ 的数值。\n\n答案规格：\n- 以有序对 $(\\rho_{\\mathrm{J}}, \\rho_{\\mathrm{GS}})$ 的形式提供最终答案。\n- 将 $\\rho_{\\mathrm{J}}$ 和 $\\rho_{\\mathrm{GS}}$ 四舍五入到四位有效数字。\n- 最终答案是无量纲的，并且必须不带单位报告。", "solution": "首先通过提取所有给定信息并检查其科学一致性、完整性和清晰度来验证问题。\n\n## 问题验证\n\n### 第1步：提取给定信息\n- **系统**：长度为 $L$、面积为 $A$ 的一维线性热弹性杆。\n- **假设**：在 $\\theta_{0}$ 附近小应变、小温升，准静态力学，包含热容的 Fourier 传导。\n- **离散化**：单个两节点线性单元，位移（$u$）和温度（$T$）各一个自由度。大小为 $\\Delta t$ 的单个后向 Euler 时间步。\n- **整体系统**：\n$$\n\\begin{pmatrix}\nK & -C \\\\\nD_{\\mathrm{eff}} & H\n\\end{pmatrix}\n\\begin{pmatrix}\nu^{n+1} \\\\\nT^{n+1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nr_{u} \\\\\nr_{T}\n\\end{pmatrix}\n$$\n- **系数定义**：\n  - 刚度：$K = E A / L$\n  - 热有效矩阵：$H = c \\rho A L / \\Delta t + \\kappa A / L$\n  - 力学耦合：$C = E A \\alpha_{\\mathrm{th}}$\n  - 热耦合：$D_{\\mathrm{eff}} = \\theta_{0} \\alpha_{\\mathrm{th}} E A / \\Delta t$\n- **物理参数**：\n  - 杨氏模量：$E = 210 \\times 10^{9}$\n  - 面积：$A = 10^{-4}$\n  - 长度：$L = 1$\n  - 热膨胀系数：$\\alpha_{\\mathrm{th}} = 1.2 \\times 10^{-5}$\n  - 导热系数：$\\kappa = 45$\n  - 比热容：$c = 450$\n  - 质量密度：$\\rho = 7800$\n  - 参考温度：$\\theta_{0} = 293$\n  - 时间步长：$\\Delta t = 1$\n- **分区方案**：\n  - Block-Jacobi：使用上一次迭代的 $u^k$ 和 $T^k$ 求解 $u^{k+1}$ 和 $T^{k+1}$。\n  - Block-Gauss-Seidel：使用 $T^k$ 求解 $u^{k+1}$，然后使用新的 $u^{k+1}$ 求解 $T^{k+1}$。\n- **任务**：\n  1. 推导误差传播矩阵谱半径 $\\rho_{\\mathrm{J}}$ 和 $\\rho_{\\mathrm{GS}}$ 的表达式。\n  2. 计算 $\\rho_{\\mathrm{J}}$ 和 $\\rho_{\\mathrm{GS}}$ 的数值。\n\n### 第2步：使用提取的给定信息进行验证\n该问题描述了一个标准的、简化的线性热弹性模型，这是计算多物理场中的一个基本问题。控制方程、系数定义和物理参数与连续介质力学和传热学的既定原理一致。离散化方法（空间上使用有限元法 FEM，时间上使用后向 Euler 法）是标准的。所提供的参数对于钢是符合实际的。问题是自洽的、适定的、客观的。它没有违反任何无效性标准。\n\n### 第3步：结论和行动\n问题有效。将提供完整解答。\n\n## 解答\n\n设整体系统的精确解为 $(u^{\\star}, T^{\\star})$。该解满足：\n$$ K u^{\\star} - C T^{\\star} = r_{u} $$\n$$ D_{\\mathrm{eff}} u^{\\star} + H T^{\\star} = r_{T} $$\n第 $k$ 步的迭代误差定义为 $e_{u}^{k} = u^{k} - u^{\\star}$ 和 $e_{T}^{k} = T^{k} - T^{\\star}$。\n\n### 任务1：谱半径的推导\n\n**Block-Jacobi 分区迭代**\n\nBlock-Jacobi 方案的定义是独立求解对角块，对非对角耦合项使用上一次迭代 $k$ 的值：\n$$ K u^{k+1} = r_{u} + C T^{k} $$\n$$ H T^{k+1} = r_{T} - D_{\\mathrm{eff}} u^{k} $$\n从迭代方程中减去精确解方程，得到误差传播方程：\n$$ K (u^{k+1} - u^{\\star}) = C (T^{k} - T^{\\star}) \\implies K e_{u}^{k+1} = C e_{T}^{k} $$\n$$ H (T^{k+1} - T^{\\star}) = -D_{\\mathrm{eff}} (u^{k} - u^{\\star}) \\implies H e_{T}^{k+1} = -D_{\\mathrm{eff}} e_{u}^{k} $$\n将这些方程整理成关于误差向量 $\\mathbf{e}^{k+1} = \\begin{pmatrix} e_{u}^{k+1} & e_{T}^{k+1} \\end{pmatrix}^T$ 的系统：\n$$ e_{u}^{k+1} = K^{-1} C e_{T}^{k} $$\n$$ e_{T}^{k+1} = -H^{-1} D_{\\mathrm{eff}} e_{u}^{k} $$\n误差传播由矩阵关系 $\\mathbf{e}^{k+1} = G_{\\mathrm{J}} \\mathbf{e}^{k}$ 控制，其中 $G_{\\mathrm{J}}$ 是 Block-Jacobi 迭代矩阵：\n$$ G_{\\mathrm{J}} = \\begin{pmatrix} 0 & K^{-1} C \\\\ -H^{-1} D_{\\mathrm{eff}} & 0 \\end{pmatrix} $$\n$G_{\\mathrm{J}}$ 的谱半径 $\\rho_{\\mathrm{J}}$ 是其特征值 $\\lambda$ 的最大绝对值。特征值由特征方程 $\\det(G_{\\mathrm{J}} - \\lambda I) = 0$ 求得：\n$$ \\det \\begin{pmatrix} -\\lambda & K^{-1} C \\\\ -H^{-1} D_{\\mathrm{eff}} & -\\lambda \\end{pmatrix} = (-\\lambda)(-\\lambda) - (K^{-1} C)(-H^{-1} D_{\\mathrm{eff}}) = \\lambda^2 + K^{-1} H^{-1} C D_{\\mathrm{eff}} = 0 $$\n$$ \\lambda^2 = - \\frac{C D_{\\mathrm{eff}}}{K H} $$\n由于所有系数 $K, H, C, D_{\\mathrm{eff}}$ 都是正标量，特征值是纯虚数：\n$$ \\lambda = \\pm i \\sqrt{\\frac{C D_{\\mathrm{eff}}}{K H}} $$\n谱半径是这些特征值的模：\n$$ \\rho_{\\mathrm{J}} = \\left| \\pm i \\sqrt{\\frac{C D_{\\mathrm{eff}}}{K H}} \\right| = \\sqrt{\\frac{C D_{\\mathrm{eff}}}{K H}} $$\n\n**Block-Gauss-Seidel 分区迭代**\n\nBlock-Gauss-Seidel 方案顺序更新变量。首先，使用 $T^k$ 计算 $u^{k+1}$，然后立即使用这个新值 $u^{k+1}$ 来计算 $T^{k+1}$：\n$$ K u^{k+1} = r_{u} + C T^{k} $$\n$$ H T^{k+1} = r_{T} - D_{\\mathrm{eff}} u^{k+1} $$\n同样，我们减去精确解方程来找到误差传播：\n$$ K e_{u}^{k+1} = C e_{T}^{k} \\implies e_{u}^{k+1} = K^{-1} C e_{T}^{k} $$\n$$ H e_{T}^{k+1} = -D_{\\mathrm{eff}} e_{u}^{k+1} $$\n将第一个方程中 $e_{u}^{k+1}$ 的表达式代入第二个方程：\n$$ H e_{T}^{k+1} = -D_{\\mathrm{eff}} (K^{-1} C e_{T}^{k}) \\implies e_{T}^{k+1} = -H^{-1} D_{\\mathrm{eff}} K^{-1} C e_{T}^{k} $$\n误差传播方程可以写成矩阵形式 $\\mathbf{e}^{k+1} = G_{\\mathrm{GS}} \\mathbf{e}^{k}$：\n$$ \\begin{pmatrix} e_{u}^{k+1} \\\\ e_{T}^{k+1} \\end{pmatrix} = \\begin{pmatrix} 0 & K^{-1} C \\\\ 0 & -H^{-1} D_{\\mathrm{eff}} K^{-1} C \\end{pmatrix} \\begin{pmatrix} e_{u}^{k} \\\\ e_{T}^{k} \\end{pmatrix} $$\n迭代矩阵是：\n$$ G_{\\mathrm{GS}} = \\begin{pmatrix} 0 & K^{-1} C \\\\ 0 & - \\frac{C D_{\\mathrm{eff}}}{K H} \\end{pmatrix} $$\n由于 $G_{\\mathrm{GS}}$ 是一个上三角矩阵，其特征值即为对角线元素：$\\lambda_1 = 0$ 和 $\\lambda_2 = - \\frac{C D_{\\mathrm{eff}}}{K H}$。\n谱半径 $\\rho_{\\mathrm{GS}}$ 是它们绝对值的最大值：\n$$ \\rho_{\\mathrm{GS}} = \\max \\left( |0|, \\left|- \\frac{C D_{\\mathrm{eff}}}{K H}\\right| \\right) = \\frac{C D_{\\mathrm{eff}}}{K H} $$\n注意 $\\rho_{\\mathrm{GS}} = (\\rho_{\\mathrm{J}})^2$，这是此类问题的一个已知结果。\n\n### 任务2：数值计算\n\n首先，我们使用提供的国际单位制（SI）物理参数计算各系数的数值。\n- $K = \\frac{E A}{L} = \\frac{(210 \\times 10^{9}) (10^{-4})}{1} = 2.1 \\times 10^{7}$\n- $C = E A \\alpha_{\\mathrm{th}} = (210 \\times 10^{9}) (10^{-4}) (1.2 \\times 10^{-5}) = 252$\n- $D_{\\mathrm{eff}} = \\frac{\\theta_{0} \\alpha_{\\mathrm{th}} E A}{\\Delta t} = \\frac{293 \\times (1.2 \\times 10^{-5}) (210 \\times 10^{9}) (10^{-4})}{1} = 73836$\n- $H = \\frac{c \\rho A L}{\\Delta t} + \\frac{\\kappa A}{L} = \\frac{450 \\times 7800 \\times 10^{-4} \\times 1}{1} + \\frac{45 \\times 10^{-4}}{1} = 351 + 0.0045 = 351.0045$\n\n接下来，我们计算无量纲耦合参数 $\\gamma = \\frac{C D_{\\mathrm{eff}}}{K H}$：\n$$ \\gamma = \\frac{252 \\times 73836}{(2.1 \\times 10^{7}) \\times 351.0045} = \\frac{18606672}{7371094500} \\approx 0.002524263 $$\n现在我们可以计算谱半径：\n- $\\rho_{\\mathrm{GS}} = \\gamma \\approx 0.002524263$\n- $\\rho_{\\mathrm{J}} = \\sqrt{\\gamma} \\approx \\sqrt{0.002524263} \\approx 0.050242048$\n\n按要求四舍五入到四位有效数字：\n- $\\rho_{\\mathrm{GS}} = 0.002524$\n- $\\rho_{\\mathrm{J}} = 0.05024$\n\n最终答案是有序对 $(\\rho_{\\mathrm{J}}, \\rho_{\\mathrm{GS}})$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.05024 & 0.002524\n\\end{pmatrix}\n}\n$$", "id": "3504785"}, {"introduction": "理论上，一个数值格式的收敛阶数是在离散化误差远大于其他所有误差源的“渐进区”中测量的。然而在实践中，分区求解器的不完全收敛会引入“迭代误差”，如果这个误差不够小，它会掩盖真实的离散化误差，导致错误的收敛阶数。本练习要求你通过编程实现一个制造解法验证，亲手揭示当迭代收敛容差固定时，迭代误差如何“污染”离散化误差的收敛性研究，从而破坏观测到的收敛阶数 [@problem_id:3504784]。", "problem": "考虑一个在空间区间 $[0,1]$ 上的一维、稳态、双场、线性耦合的反应扩散系统，其边界条件为齐次狄利克雷边界条件。未知场为 $u(x)$ 和 $v(x)$，其控制方程为\n$$\n-\\,u''(x) + a\\,u(x) + b\\,v(x) = s_u(x), \\quad -\\,v''(x) + c\\,v(x) + d\\,u(x) = s_v(x),\n$$\n其中 $u(0)=u(1)=0$ 且 $v(0)=v(1)=0$。假设一个构造的精确解 $u_e(x) = \\sin(\\pi x)$ 和 $v_e(x) = \\sin(2\\pi x)$。设正反应系数为 $a=1$ 和 $c=2$，耦合系数为 $b=0.1$ 和 $d=0.2$。源项的构造使得构造解满足连续方程：\n$$\ns_u(x) = \\pi^2 \\sin(\\pi x) + a \\sin(\\pi x) + b \\sin(2\\pi x), \\quad s_v(x) = (2\\pi)^2 \\sin(2\\pi x) + c \\sin(2\\pi x) + d \\sin(\\pi x).\n$$\n\n您将使用包含 $N$ 个点（包括边界）的均匀网格对空间域进行离散化，网格间距为 $h=1/(N-1)$，并使用二阶中心差分来处理扩散算子。对于内部网格点，近似于 $-u''$（以及类似地近似于 $-v''$）的离散算子是\n$$\n\\frac{2 u_i - u_{i-1} - u_{i+1}}{h^2},\n$$\n并且反应项按点处理。由此产生的 $u$ 和 $v$ 的非耦合离散算子是三对角的且严格对角占优。为了处理耦合，在代数层面使用分块高斯-赛德尔（Gauss–Seidel）迭代法：给定内部网格上的一个迭代 $(u^{(k)}, v^{(k)})$，通过依次求解以下两个线性系统来计算下一个迭代，\n$$\nA\\,u^{(k+1)} = s_u - b\\,v^{(k)}, \\quad C\\,v^{(k+1)} = s_v - d\\,u^{(k+1)},\n$$\n其中 $A$ 和 $C$ 分别是 $u$ 和 $v$ 的离散非耦合算子，$s_u, s_v$ 是通过在内部网格点上对解析的 $s_u(x), s_v(x)$ 进行采样得到的离散源向量。在内部网格上初始化 $u^{(0)}=0$ 和 $v^{(0)}=0$。基于连续迭代之间的组合变化量的容差来终止迭代，\n$$\n\\| (u^{(k+1)} - u^{(k)}, v^{(k+1)} - v^{(k)}) \\|_{2,h} \\le \\mathrm{tol},\n$$\n其中内部网格上的离散 $L^2$ 范数定义为\n$$\n\\| (x,y) \\|_{2,h} = \\left( h \\sum_{i} x_i^2 + h \\sum_{i} y_i^2 \\right)^{1/2}.\n$$\n\n核心问题是关于离散化误差、相容性和收敛性，以及耦合迭代误差如何掩盖渐近离散化误差。总数值误差（相对于在网格上采样的连续构造解）在误差足够小的情况下可以被认为是两个贡献之和：\n$$\nE_{\\mathrm{tot}}(h,\\mathrm{tol}) \\approx E_{\\mathrm{disc}}(h) + E_{\\mathrm{iter}}(h,\\mathrm{tol}),\n$$\n其中 $E_{\\mathrm{disc}}(h)$ 是由空间离散化引起的（在足够光滑的条件下，对于二阶中心差分，其预期阶数为 $p=2$），而 $E_{\\mathrm{iter}}(h,\\mathrm{tol})$ 是由耦合迭代的过早终止引起的。如果 $\\mathrm{tol}$ 是固定的（不随 $h$ 缩放），那么当 $h \\to 0$ 时，$E_{\\mathrm{disc}}(h) \\to 0$，而 $E_{\\mathrm{iter}}(h,\\mathrm{tol})$ 保持近似恒定，从而掩盖了离散化误差，并破坏了观测到的渐近收敛率。\n\n任务：实现一个程序，进行数值实验来量化和分离这些误差贡献。对于每次运行，计算 $u$ 和 $v$ 的组合离散 $L^2$ 误差：\n$$\nE_{\\mathrm{tot}}(h,\\mathrm{tol}) = \\left( h \\sum_{i} \\left(u^{(k_{\\mathrm{final})}}_i - u_e(x_i)\\right)^2 + h \\sum_{i} \\left(v^{(k_{\\mathrm{final})}}_i - v_e(x_i)\\right)^2 \\right)^{1/2}.\n$$\n此外，在比较相同 $h$ 下的两次运行时，通过以下公式估计耦合迭代误差：\n$$\nE_{\\mathrm{iter,est}}(h) = \\left( h \\sum_{i} \\left(u_{\\mathrm{loose},i} - u_{\\mathrm{tight},i}\\right)^2 + h \\sum_{i} \\left(v_{\\mathrm{loose},i} - v_{\\mathrm{tight},i}\\right)^2 \\right)^{1/2},\n$$\n其中“tight”表示使用极小容差的运行，而“loose”表示使用固定容差的运行。\n\n设计一个测试套件，包含三次运行，每次都在三种网格分辨率 $N\\in\\{33,65,129\\}$ 上进行评估：\n\n- 情况 A（严格容差，接近整体收敛）：$\\mathrm{tol} = 10^{-12}$，最大迭代次数 $500$。\n- 情况 B（宽松容差，预期出现掩盖效应）：$\\mathrm{tol} = 10^{-4}$，最大迭代次数 $500$。\n- 情况 C（迭代严重不足，边缘情况）：$\\mathrm{tol}$ 任意，最大迭代次数 $1$。\n\n对于每种情况，计算每个网格上的总误差，然后使用两个最精细的网格估计观测到的精度阶数 $p_{\\mathrm{obs}}$：\n$$\np_{\\mathrm{obs}} = \\frac{\\ln\\left( E_{\\mathrm{tot}}(h_2,\\mathrm{tol}) / E_{\\mathrm{tot}}(h_3,\\mathrm{tol}) \\right)}{\\ln\\left( h_2 / h_3 \\right)},\n$$\n其中 $h_2=1/(65-1)$ 和 $h_3=1/(129-1)$。此外，对于最精细网格（$N=129$）上的情况 B，计算比率\n$$\nr_{\\mathrm{fine}} = \\frac{E_{\\mathrm{iter,est}}(h_3)}{E_{\\mathrm{tot}}(h_3,\\mathrm{tol}_{\\mathrm{loose}})}.\n$$\n\n您的程序必须生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中包含以下六个条目：\n- 使用两个最精细网格计算的情况 A 的观测阶数 $p_{\\mathrm{obs}}$，以浮点数表示。\n- 使用两个最精细网格计算的情况 B 的观测阶数 $p_{\\mathrm{obs}}$，以浮点数表示。\n- 使用两个最精细网格计算的情况 C 的观测阶数 $p_{\\mathrm{obs}}$，以浮点数表示。\n- 在 $N=129$ 时情况 B 的比率 $r_{\\mathrm{fine}}$，以 $[0,1]$ 范围内的浮点数表示。\n- 一个布尔值，指示严格容差的观测阶数是否在 $[1.8,2.2]$ 范围内。\n- 一个布尔值，指示在情况 B 中是否观测到掩盖效应，定义为同时满足 $p_{\\mathrm{obs}}<1.0$ 和 $r_{\\mathrm{fine}}>0.5$。\n\n所有量纲均为无量纲，因此不需要物理单位。您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[p_A,p_B,p_C,r_{\\mathrm{fine}},\\mathrm{bool}_A,\\mathrm{bool}_B]$）。程序必须是自包含的，并且无需任何输入或外部文件即可运行。数值实验必须严格遵守所述的离散化和耦合迭代过程，并逐字使用指定的测试套件参数。", "solution": "用户提供了一个有效且适定的问题。本响应提供其解决方案。\n\n### 1. 理论框架\n\n该问题要求对一个耦合的、一维的、稳态的反应扩散系统进行数值研究。在域 $x \\in [0,1]$ 上，两个场 $u(x)$ 和 $v(x)$ 的控制偏微分方程（PDE）是：\n$$\n-\\,u''(x) + a\\,u(x) + b\\,v(x) = s_u(x)\n$$\n$$\n-\\,v''(x) + c\\,v(x) + d\\,u(x) = s_v(x)\n$$\n这些方程受齐次狄利克雷边界条件约束，$u(0)=u(1)=0$ 和 $v(0)=v(1)=0$。给定的系数为 $a=1$、$c=2$、$b=0.1$ 和 $d=0.2$。\n\n为了便于进行定量的误差分析，采用了构造解法（Method of Manufactured Solutions）。我们指定了精确的解析解 $u_e(x) = \\sin(\\pi x)$ 和 $v_e(x) = \\sin(2\\pi x)$，这些解恰好满足边界条件。然后，通过将这些精确解代入控制方程来推导源项 $s_u(x)$ 和 $s_v(x)$：\n$$\ns_u(x) = -(-\\pi^2 \\sin(\\pi x)) + a \\sin(\\pi x) + b \\sin(2\\pi x) = \\pi^2 \\sin(\\pi x) + a \\sin(\\pi x) + b \\sin(2\\pi x)\n$$\n$$\ns_v(x) = -(-(2\\pi)^2 \\sin(2\\pi x)) + c \\sin(2\\pi x) + d \\sin(\\pi x) = (2\\pi)^2 \\sin(2\\pi x) + c \\sin(2\\pi x) + d \\sin(\\pi x)\n$$\n有了这些源项，连续问题就有了已知的唯一解，为我们的数值解提供了一个可以进行比较的基准。\n\n### 2. 数值离散化与求解策略\n\n连续域使用一个包含 $N$ 个点的均匀网格进行离散化，点坐标为 $x_i = i \\cdot h$，$i=0, 1, \\dots, N-1$，其中网格间距为 $h=1/(N-1)$。内部网格点的索引从 $i=1$ 到 $N-2$。\n\n二阶导数项 $-u''$ 和 $-v''$ 使用二阶精度的中心有限差分格式进行近似。对于内部网格点 $x_i$，该近似为：\n$$\n-u''(x_i) \\approx \\frac{-u_{i-1} + 2u_i - u_{i+1}}{h^2}\n$$\n其中 $u_i$ 是 $u(x_i)$ 的数值近似。将此应用于每个内部点 $i$ 的第一个偏微分方程，可以得到一个线性方程组：\n$$\n\\frac{-u_{i-1} + 2u_i - u_{i+1}}{h^2} + a u_i + b v_i = (s_u)_i\n$$\n对 $u$ 场重新整理各项，我们可以将离散系统表示为矩阵形式。令 $\\mathbf{u}$ 为未知值向量 $[u_1, u_2, \\dots, u_{N-2}]^T$。$u$ 的非耦合算子可以写成矩阵 $A$，使得方程变为 $A\\mathbf{u} + b\\mathbf{v} = \\mathbf{s}_u$。矩阵 $A$ 是一个 $(N-2) \\times (N-2)$ 的三对角矩阵，其对角线元素为 $(2/h^2 + a)$，非对角线元素为 $-1/h^2$。由于反应系数 $a=1$ 是正数，矩阵 $A$ 是严格对角占优的，这保证了其可逆性以及数值求解器的稳定性。同样地，可以为 $v$ 场构造一个矩阵 $C$，由于 $c=2 > 0$，该矩阵也是三对角且严格对角占优的。\n\n完全耦合的离散系统是一个块矩阵系统：\n$$\n\\begin{pmatrix} A & \\mathrm{diag}(b) \\\\ \\mathrm{diag}(d) & C \\end{pmatrix} \\begin{pmatrix} \\mathbf{u} \\\\ \\mathbf{v} \\end{pmatrix} = \\begin{pmatrix} \\mathbf{s}_u \\\\ \\mathbf{s}_v \\end{pmatrix}\n$$\n为了求解这个系统，采用了分块（或块）Gauss-Seidel 迭代格式。从一个初始猜测（通常是 $\\mathbf{u}^{(0)}=\\mathbf{0}$ 和 $\\mathbf{v}^{(0)}=\\mathbf{0}$）开始，该格式对 $k=0, 1, 2, \\dots$ 进行迭代，依次求解两个较小的非耦合系统：\n1.  **求解** $\\mathbf{u}^{(k+1)}$: $A\\,\\mathbf{u}^{(k+1)} = \\mathbf{s}_u - b\\,\\mathbf{v}^{(k)}$\n2.  **求解** $\\mathbf{v}^{(k+1)}$: $C\\,\\mathbf{v}^{(k+1)} = \\mathbf{s}_v - d\\,\\mathbf{u}^{(k+1)}$\n\n在每一步中，都会求解一个三对角线性系统。这可以通过专门的算法（如托马斯算法）或使用库函数（如 `scipy.linalg.solve_banded`）来高效执行。迭代持续进行，直到连续迭代之间的变化量小于指定的容差 $\\mathrm{tol}$，该变化量用离散 $L^2$-范数来衡量：\n$$\n\\| (\\mathbf{u}^{(k+1)} - \\mathbf{u}^{(k)}, \\mathbf{v}^{(k+1)} - \\mathbf{v}^{(k)}) \\|_{2,h} = \\left( h \\sum_{i=1}^{N-2} (u_i^{(k+1)} - u_i^{(k)})^2 + h \\sum_{i=1}^{N-2} (v_i^{(k+1)} - v_i^{(k)})^2 \\right)^{1/2} \\le \\mathrm{tol}\n$$\n\n### 3. 误差分析与实验设计\n\n目标是区分最终数值解中两种误差来源：\n1.  **离散化误差（$E_{\\mathrm{disc}}$）**：这种误差源于用有限差分公式近似连续微分算子。对于所使用的二阶格式，我们预期该误差会随网格间距的平方减小，即 $E_{\\mathrm{disc}} \\propto h^2$。\n2.  **迭代误差（$E_{\\mathrm{iter}}$）**：这种误差是由于在迭代的 Gauss-Seidel 求解器完全收敛到离散代数系统的精确解之前就终止了它。该误差由容差 $\\mathrm{tol}$ 控制。\n\n总误差 $E_{\\mathrm{tot}}$ 是这些贡献的总和：$E_{\\mathrm{tot}}(h,\\mathrm{tol}) \\approx E_{\\mathrm{disc}}(h) + E_{\\mathrm{iter}}(h,\\mathrm{tol})$。如果在网格加密（即 $h \\to 0$）的同时保持容差 $\\mathrm{tol}$ 不变，离散化误差 $E_{\\mathrm{disc}}(h)$ 将会减小。然而，迭代误差 $E_{\\mathrm{iter}}(h,\\mathrm{tol})$ 将大致保持不变，最终成为总误差的主要部分。这种现象称为**误差掩盖**，它阻止了观测到的收敛率达到其理论渐近值 $p=2$。\n\n为了证明这一点，我们在一个网格序列 $N \\in \\{33, 65, 129\\}$ 上进行了三个数值实验：\n-   **情况 A（严格容差）**：当 $\\mathrm{tol} = 10^{-12}$ 时，迭代误差被降至可忽略的水平。总误差 $E_{\\mathrm{tot}}$ 应主要由离散化误差 $E_{\\mathrm{disc}}$ 主导，观测到的精度阶数 $p_{\\mathrm{obs}}$ 应接近理论值 $2$。\n-   **情况 B（宽松容差）**：当 $\\mathrm{tol} = 10^{-4}$ 时，迭代误差会很显著。在粗网格上，它可能小于离散化误差，但在细网格上，它将占主导地位，导致 $p_{\\mathrm{obs}}$ 显著低于 $2$。\n-   **情况 C（迭代不足）**：仅进行一次迭代时，解远未收敛。由此产生的误差很大，“精度阶数”的计算预计不会得出有意义的值，这凸显了足够迭代的重要性。\n\n观测到的精度阶数是根据两个最精细网格（$N_2=65$，$N_3=129$）上的总误差，使用以下公式计算的：\n$$\np_{\\mathrm{obs}} = \\frac{\\ln\\left( E_{\\mathrm{tot}}(h_2,\\mathrm{tol}) / E_{\\mathrm{tot}}(h_3,\\mathrm{tol}) \\right)}{\\ln\\left( h_2 / h_3 \\right)}\n$$\n最后，对于最精细的网格，通过比较宽松容差的解（情况 B）与严格容差的解（情况 A，作为精确离散解的代理），直接估计迭代误差。这个估计的迭代误差与宽松情况下总误差的比值 $r_{\\mathrm{fine}}$，量化了误差掩盖的程度。\n\n实现将通过系统地运行这些情况、计算误差并推导出最终输出所需的量来进行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef run_simulation(N, tol, max_iter):\n    \"\"\"\n    Solves the coupled reaction-diffusion system for a given grid size,\n    tolerance, and max iterations.\n    \n    Args:\n        N (int): Number of grid points (including boundaries).\n        tol (float): Convergence tolerance for the Gauss-Seidel iteration.\n        max_iter (int): Maximum number of Gauss-Seidel iterations.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray, float]: Tuple containing the final solution\n        vector u, the final solution vector v, and the total L2 error.\n    \"\"\"\n    # 1. Setup grid and parameters\n    h = 1.0 / (N - 1)\n    x = np.linspace(0, 1, N)\n    x_int = x[1:-1]  # Interior points\n    num_int_pts = N - 2\n    \n    # Coefficients from problem statement\n    a, c = 1.0, 2.0\n    b, d = 0.1, 0.2\n    \n    # 2. Manufactured solution and source terms on the interior grid\n    pi = np.pi\n    u_exact_int = np.sin(pi * x_int)\n    v_exact_int = np.sin(2 * pi * x_int)\n    \n    s_u_int = pi**2 * u_exact_int + a * u_exact_int + b * v_exact_int\n    s_v_int = (2*pi)**2 * v_exact_int + c * v_exact_int + d * u_exact_int\n    \n    # 3. Construct uncoupled operators A and C in banded format for SciPy\n    # The banded format for a tridiagonal matrix (l=1, u=1) requires 3 rows:\n    # row 0: upper diagonal (shifted left)\n    # row 1: main diagonal\n    # row 2: lower diagonal (shifted right)\n    \n    # Matrix A for -u'' + a*u\n    A_banded = np.zeros((3, num_int_pts))\n    A_banded[0, 1:] = -1.0 / h**2\n    A_banded[1, :]  = 2.0 / h**2 + a\n    A_banded[2, :-1] = -1.0 / h**2\n    \n    # Matrix C for -v'' + c*v\n    C_banded = np.zeros((3, num_int_pts))\n    C_banded[0, 1:] = -1.0 / h**2\n    C_banded[1, :]  = 2.0 / h**2 + c\n    C_banded[2, :-1] = -1.0 / h**2\n    \n    # 4. Partitioned Gauss-Seidel Iteration\n    u_k = np.zeros(num_int_pts)\n    v_k = np.zeros(num_int_pts)\n    \n    for k in range(max_iter):\n        u_prev = u_k.copy()\n        v_prev = v_k.copy()\n        \n        # Solve for u^(k+1)\n        rhs_u = s_u_int - b * v_k\n        u_k = solve_banded((1, 1), A_banded, rhs_u)\n        \n        # Solve for v^(k+1)\n        rhs_v = s_v_int - d * u_k\n        v_k = solve_banded((1, 1), C_banded, rhs_v)\n        \n        # Check for convergence\n        diff_u = u_k - u_prev\n        diff_v = v_k - v_prev\n        norm_diff = np.sqrt(h * (np.sum(diff_u**2) + np.sum(diff_v**2)))\n        \n        if norm_diff = tol:\n            break\n            \n    # 5. Calculate total error against the exact manufactured solution\n    err_u = u_k - u_exact_int\n    err_v = v_k - v_exact_int\n    total_error = np.sqrt(h * (np.sum(err_u**2) + np.sum(err_v**2)))\n    \n    return u_k, v_k, total_error\n\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiments and compute the final results.\n    \"\"\"\n    # Define test parameters\n    resolutions = [33, 65, 129]\n    cases = {\n        'A': {'tol': 1e-12, 'max_iter': 500},\n        'B': {'tol': 1e-4,  'max_iter': 500},\n        'C': {'tol': 1e-4,  'max_iter': 1}  # tol is arbitrary for 1 iteration\n    }\n    \n    # Store results from all runs\n    results_data = {}\n    \n    # Run simulations for all cases and resolutions\n    for case_name, params in cases.items():\n        results_data[case_name] = {}\n        for N in resolutions:\n            u, v, error = run_simulation(N, params['tol'], params['max_iter'])\n            results_data[case_name][N] = {'u': u, 'v': v, 'error': error}\n    \n    # ---------- Calculate Final Outputs ----------\n    \n    # 1. Observed order of accuracy (p_obs) for each case\n    h_values = {N: 1.0 / (N - 1) for N in resolutions}\n    p_obs = {}\n    for case_name in cases:\n        err_h2 = results_data[case_name][65]['error']\n        err_h3 = results_data[case_name][129]['error']\n        h2 = h_values[65]\n        h3 = h_values[129]\n        # p_obs = log(E2/E3) / log(h2/h3) where h2/h3 is approx 2\n        p_obs[case_name] = np.log(err_h2 / err_h3) / np.log(h2 / h3)\n        \n    pA = p_obs['A']\n    pB = p_obs['B']\n    pC = p_obs['C']\n    \n    # 2. Ratio r_fine for Case B at N=129\n    N_fine = 129\n    h_fine = h_values[N_fine]\n    \n    # 'tight' solution is from Case A, 'loose' is from Case B\n    u_tight = results_data['A'][N_fine]['u']\n    v_tight = results_data['A'][N_fine]['v']\n    u_loose = results_data['B'][N_fine]['u']\n    v_loose = results_data['B'][N_fine]['v']\n    \n    # Estimate iteration error as difference between loose and tight solutions\n    diff_u_iter = u_loose - u_tight\n    diff_v_iter = v_loose - v_tight\n    iter_err_est = np.sqrt(h_fine * (np.sum(diff_u_iter**2) + np.sum(diff_v_iter**2)))\n    \n    # Total error for the loose case at the finest grid\n    total_err_loose_fine = results_data['B'][N_fine]['error']\n    \n    r_fine = iter_err_est / total_err_loose_fine\n\n    # 3. Boolean checks\n    # Check if tight-tolerance order is close to theoretical value of 2\n    bool_A = 1.8 = pA = 2.2\n    # Check if error masking is observed in Case B\n    bool_B = (pB  1.0) and (r_fine > 0.5)\n\n    # Compile final results into a list\n    final_list = [pA, pB, pC, r_fine, bool_A, bool_B]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_list))}]\")\n\nsolve()\n```", "id": "3504784"}, {"introduction": "在验证一个用于瞬态问题的数值方法时，区分和量化空间和时间上的离散化误差至关重要。此外，只有当离散步长足够小，使得误差行为进入渐进区时，测得的收敛阶数才具有理论意义。本练习将指导你设计并执行一个全面的收敛性研究，通过对一个瞬态耦合问题分别进行空间和时间加密，你将学习如何分离不同来源的误差，并识别出从“前渐进区”到“渐进区”的过渡，确保你的验证结果是可靠的 [@problem_id:3504818]。", "problem": "考虑一个一维耦合系统，该系统定义在空间域 $[0,1]$ 和时间区间 $[0,T]$ 上，旨在表示扩散过程和反应过程之间的简化多物理场耦合。该耦合系统由一个抛物型偏微分方程（关于 $u(x,t)$，带有齐次狄利克雷边界条件）和一个线性常微分方程（关于 $v(t)$）组成：\n- $u_t(x,t) = \\kappa\\,u_{xx}(x,t) + \\gamma\\,v(t)\\,\\phi(x) + s(x,t)$，对于 $x \\in (0,1)$ 和 $t \\in (0,T]$，\n- $u(0,t)=0$， $u(1,t)=0$，对于 $t \\in [0,T]$，\n- $u(x,0)=u_0(x)$，对于 $x \\in [0,1]$，\n- $v'(t) = -\\lambda\\,v(t) + r(t)$，对于 $t \\in (0,T]$，\n- $v(0)=v_0$。\n\n所有量均为无量纲。函数 $\\phi(x)$ 是一个给定的光滑函数。为了进行人造解研究，使用以下精确场：\n- $u(x,t) = \\sin(\\pi x)\\,\\exp\\!\\left(-\\kappa\\,\\pi^2\\,t\\right) + t^2 \\sin(2\\pi x)$，\n- $v(t) = \\exp(-\\lambda t) + t^3$，\n- $\\phi(x) = \\sin(\\pi x)$。\n\n选择 $s(x,t)$ 和 $r(t)$，使得对于任何正参数 $\\kappa$、$\\gamma$ 和 $\\lambda$，精确的人造场都满足该耦合系统。通过直接求导并代入耦合系统，该要求唯一地确定了 $s(x,t)$ 和 $r(t)$：\n- $u_t(x,t) = -\\kappa\\,\\pi^2\\,\\sin(\\pi x)\\,\\exp\\!\\left(-\\kappa\\,\\pi^2 t\\right) + 2t\\,\\sin(2\\pi x)$，\n- $u_{xx}(x,t) = -\\pi^2\\,\\sin(\\pi x)\\,\\exp\\!\\left(-\\kappa\\,\\pi^2 t\\right) - 4\\pi^2 t^2 \\sin(2\\pi x)$，\n- $s(x,t) = 2t\\,\\sin(2\\pi x) + 4\\kappa\\,\\pi^2 t^2 \\sin(2\\pi x) - \\gamma\\,v(t)\\,\\sin(\\pi x)$，\n- $v'(t) = -\\lambda \\exp(-\\lambda t) + 3 t^2$，\n- $r(t) = v'(t) + \\lambda v(t) = 3 t^2 + \\lambda t^3$，\n- $u_0(x) = u(x,0) = \\sin(\\pi x)$，\n- $v_0 = v(0) = 1$。\n\n在具有 $N$ 个内部点和间距 $h = 1/(N+1)$ 的均匀网格上对空间进行离散化。对内部的 $u_{xx}$ 使用标准的二阶中心有限差分，并采用齐次狄利克雷边界条件。对于步长为 $\\Delta t$ 的时间步进，对抛物型方程使用二阶、无条件稳定的 Crank–Nicolson 方法，并与常微分方程的二阶梯形法则耦合。将作用于内部网格值的离散拉普拉斯算子记为 $L_h$：\n$$\n(L_h \\mathbf{w})_i = \\frac{\\mathbf{w}_{i-1} - 2 \\mathbf{w}_i + \\mathbf{w}_{i+1}}{h^2}, \\quad i=1,\\dots,N, \\quad \\mathbf{w}_0=\\mathbf{w}_{N+1}=0.\n$$\n令 $t^n = n\\,\\Delta t$，并将在内部节点 $x_i=i h$ 处的 $u(x_i,t^n)$ 的近似值记为 $u_i^n$，将 $v(t^n)$ 的近似值记为 $v^n$。全离散格式为\n- $v$ 的梯形法则：\n$$\n\\frac{v^{n+1}-v^n}{\\Delta t} = -\\frac{\\lambda}{2}(v^{n+1}+v^n) + \\frac{1}{2}\\left(r(t^{n+1})+r(t^n)\\right).\n$$\n- $u$ 的 Crank–Nicolson 方法：\n$$\n\\frac{\\mathbf{u}^{n+1}-\\mathbf{u}^{n}}{\\Delta t} = \\frac{\\kappa}{2}\\left(L_h \\mathbf{u}^{n+1}+ L_h \\mathbf{u}^n\\right) + \\frac{\\gamma}{2}\\left(v^{n+1}+v^n\\right)\\,\\boldsymbol{\\phi} + \\frac{1}{2}\\left(\\mathbf{s}(t^{n+1})+\\mathbf{s}(t^n)\\right),\n$$\n其中 $\\boldsymbol{\\phi}_i = \\phi(x_i)$ 且 $\\mathbf{s}_i(t) = s(x_i,t)$。\n\n目标是设计并执行一项数值研究，以识别从前渐近区域到渐近收敛区域的过渡，并计算空间和时间细化下的观测精度阶。使用以下原则：\n- 空间细化研究：固定一个足够小的 $\\Delta t$，使得在所选的 $N$ 范围内，时间误差相对于空间误差可以忽略不计。计算 $u(\\cdot,T)$ 的离散空间 $L^2$ 误差，\n$$\nE_h = \\left( h \\sum_{i=1}^N \\left(u_i^T - u(x_i,T)\\right)^2 \\right)^{1/2},\n$$\n并对于间距为 $h_j$ 和 $h_{j+1}$ 的连续细化，计算局部观测空间阶\n$$\np_{h,j} = \\frac{\\log(E_{h_j}/E_{h_{j+1}})}{\\log(h_j/h_{j+1})}.\n$$\n- 时间细化研究：固定一个足够精细的空间分辨率 $N$，使得在所选的 $\\Delta t$ 范围内，空间误差相对于时间误差可以忽略不计。计算相应的误差 $E_{\\Delta t}$ 和局部观测时间阶\n$$\np_{\\Delta t,j} = \\frac{\\log(E_{\\Delta t_j}/E_{\\Delta t_{j+1}})}{\\log(\\Delta t_j/\\Delta t_{j+1})}.\n$$\n\n将空间和时间的设计阶定义为 $p^\\star = 2$。定义一个过渡检测规则：给定一个容差 $\\tau  0$ 和一个连续 $m \\in \\mathbb{N}$ 层的要求，当第一个索引 $j$ 满足以下条件时，声明已进入渐近区域：\n$$\n|p_{(\\cdot),j} - p^\\star| \\le \\tau, \\quad |p_{(\\cdot),j+1} - p^\\star| \\le \\tau, \\quad \\dots, \\quad |p_{(\\cdot),j+m-1} - p^\\star| \\le \\tau.\n$$\n如果可用序列中不存在这样的索引，则报告 $j=0$。\n\n实现求解器，并对以下每个测试用例运行两种细化研究。所有量均为无量纲。对于每个用例，给出空间和时间细化的观测渐近阶和过渡索引。使用 $m=2$ 和 $\\tau=0.2$。\n\n测试套件：\n- 用例 1：$\\kappa=0.5$，$\\gamma=1.0$，$\\lambda=2.0$， $T=0.2$。\n  - 空间细化：$N \\in \\{16,32,64,128\\}$，固定的 $\\Delta t = 0.0001$。\n  - 时间细化：固定的 $N=256$，$\\Delta t \\in \\{T/40, T/80, T/160, T/320, T/640\\}$。\n- 用例 2：$\\kappa=0.1$，$\\gamma=0.2$，$\\lambda=0.5$， $T=0.05$。\n  - 空间细化：$N \\in \\{12,24,48,96\\}$，固定的 $\\Delta t = 0.00005$。\n  - 时间细化：固定的 $N=256$，$\\Delta t \\in \\{T/20, T/40, T/80, T/160, T/320\\}$。\n- 用例 3：$\\kappa=2.0$，$\\gamma=0.5$，$\\lambda=5.0$， $T=0.1$。\n  - 空间细化：$N \\in \\{16,32,64,128\\}$，固定的 $\\Delta t = 0.0001$。\n  - 时间细化：固定的 $N=256$，$\\Delta t \\in \\{T/20, T/40, T/80, T/160, T/320\\}$。\n\n你的程序必须：\n- 使用人造源项 $s(x,t)$ 和 $r(t)$ 以及初始数据 $u_0(x)$ 和 $v_0$ 来实现上述离散化。\n- 为每个细化级别计算 $u(\\cdot,T)$ 中的离散空间 $L^2$ 误差。\n- 对于每项研究，计算连续细化之间的局部观测阶，并使用指定的规则（$p^\\star=2$, $\\tau=0.2$, $m=2$）检测从前渐近到渐近的过渡索引。\n- 对于每个用例，返回一个形式为 $[p_h^{\\mathrm{asy}}, j_h, p_{\\Delta t}^{\\mathrm{asy}}, j_{\\Delta t}]$ 的 4 元组，其中 $p_h^{\\mathrm{asy}}$ 是最后一个局部观测空间阶（一个浮点数），$j_h$ 是检测到的空间过渡索引（一个整数，如果未找到则报告 $0$），$p_{\\Delta t}^{\\mathrm{asy}}$ 是最后一个局部观测时间阶（一个浮点数），$j_{\\Delta t}$ 是检测到的时间过渡索引（一个整数，如果未找到则报告 $0$）。将 $p_h^{\\mathrm{asy}}$ 和 $p_{\\Delta t}^{\\mathrm{asy}}$ 表示为四舍五入到三位小数的十进制数。\n- 你的程序应该生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素本身都是一个表示用例的列表，例如，“[[result_case1],[result_case2],[result_case3]]”。不要打印任何附加文本。\n\n此处不使用角度或物理单位。所有值都是无量纲的。输出中不得使用百分比；仅报告指定的小数。解决方案应具有通用性，并可用任何现代编程语言实现，但您的最终答案必须是指定的可执行程序。离散化误差、相容性和收敛性分析必须从控制方程和所选的数值格式推导出来，不得使用任何预先提供的快捷公式。", "solution": "该问题要求实现并分析一个耦合系统（由一个偏微分方程(PDE)和一个常微分方程(ODE)组成）的数值解。该分析涉及使用人造解方法进行收敛性研究，以验证所选数值格式的理论二阶精度。\n\n耦合系统由以下方程给出：\n$$ u_t(x,t) = \\kappa\\,u_{xx}(x,t) + \\gamma\\,v(t)\\,\\phi(x) + s(x,t) $$\n$$ v'(t) = -\\lambda\\,v(t) + r(t) $$\n带有指定的初始条件和边界条件。分析将使用全离散格式进行。空间使用二阶中心有限差分进行离散化，时间使用耦合的二阶隐式格式进行推进：对ODE使用梯形法则，对PDE使用Crank-Nicolson方法。\n\n首先，我们构建在每个离散时间步必须求解的代数方程。令 $t^n = n\\,\\Delta t$ 为第 $n$ 步的时间。我们寻求在给定状态 $(v^n, \\mathbf{u}^n)$ 的情况下，找到状态 $(v^{n+1}, \\mathbf{u}^{n+1})$。\n\n对于常微分方程 $v'(t) = -\\lambda v(t) + r(t)$ 的梯形法则是：\n$$ \\frac{v^{n+1}-v^n}{\\Delta t} = -\\frac{\\lambda}{2}(v^{n+1}+v^n) + \\frac{1}{2}\\left(r(t^{n+1})+r(t^n)\\right) $$\n这是一个关于 $v^{n+1}$ 的线性方程。重新整理各项以求解 $v^{n+1}$，我们将所有含 $v^{n+1}$ 的项分组到左侧：\n$$ v^{n+1}\\left(\\frac{1}{\\Delta t} + \\frac{\\lambda}{2}\\right) = v^n\\left(\\frac{1}{\\Delta t} - \\frac{\\lambda}{2}\\right) + \\frac{1}{2}\\left(r(t^{n+1})+r(t^n)\\right) $$\n乘以 $\\Delta t$ 可得：\n$$ v^{n+1}\\left(1 + \\frac{\\lambda \\Delta t}{2}\\right) = v^n\\left(1 - \\frac{\\lambda \\Delta t}{2}\\right) + \\frac{\\Delta t}{2}\\left(r(t^{n+1})+r(t^n)\\right) $$\n由于这是一种单向耦合，其中PDE依赖于ODE，但反之不然，我们可以先求解 $v^{n+1}$。$v^{n+1}$ 的显式更新公式为：\n$$ v^{n+1} = \\frac{\\left(1 - \\frac{\\lambda \\Delta t}{2}\\right)v^n + \\frac{\\Delta t}{2}\\left(r(t^{n+1})+r(t^n)\\right)}{1 + \\frac{\\lambda \\Delta t}{2}} $$\n\n接下来，我们构建 PDE 分量 $u(x,t)$ 的方程。应用于 PDE 的 Crank-Nicolson 方法是：\n$$ \\frac{\\mathbf{u}^{n+1}-\\mathbf{u}^{n}}{\\Delta t} = \\frac{\\kappa}{2}\\left(L_h \\mathbf{u}^{n+1}+ L_h \\mathbf{u}^n\\right) + \\frac{\\gamma}{2}\\left(v^{n+1}+v^n\\right)\\,\\boldsymbol{\\phi} + \\frac{1}{2}\\left(\\mathbf{s}(t^{n+1})+\\mathbf{s}(t^n)\\right) $$\n其中 $\\mathbf{u}^n$ 是在时间 $t^n$、内部空间网格点 $x_i = ih$ 处的数值解向量，$L_h$ 是离散拉普拉斯算子。我们重新整理这个方程，将时间 $t^{n+1}$ 的未知项分组到左侧，将时间 $t^n$ 的已知项分组到右侧。\n$$ \\mathbf{u}^{n+1} - \\frac{\\kappa\\Delta t}{2}L_h \\mathbf{u}^{n+1} = \\mathbf{u}^{n} + \\frac{\\kappa\\Delta t}{2}L_h \\mathbf{u}^n + \\frac{\\gamma\\Delta t}{2}\\left(v^{n+1}+v^n\\right)\\,\\boldsymbol{\\phi} + \\frac{\\Delta t}{2}\\left(\\mathbf{s}(t^{n+1})+\\mathbf{s}(t^n)\\right) $$\n令 $A_h$ 为离散拉普拉斯算子 $L_h$ 在具有齐次狄利克雷边界条件的内部网格点上的 $N \\times N$ 矩阵表示。矩阵 $A_h$ 是一个对称三对角矩阵，主对角线上的元素为 $-2/h^2$，次对角线和上对角线上的元素为 $1/h^2$。令 $I$ 为 $N \\times N$ 单位矩阵。关于 $\\mathbf{u}^{n+1}$ 的方程成为一个线性代数方程组：\n$$ \\left(I - \\frac{\\kappa\\Delta t}{2}A_h\\right) \\mathbf{u}^{n+1} = \\mathbf{b}^n $$\n其中右侧向量 $\\mathbf{b}^n$ 由所有已知量组成：\n$$ \\mathbf{b}^n = \\left(I + \\frac{\\kappa\\Delta t}{2}A_h\\right)\\mathbf{u}^n + \\frac{\\gamma\\Delta t}{2}\\left(v^{n+1}+v^n\\right)\\,\\boldsymbol{\\phi} + \\frac{\\Delta t}{2}\\left(\\mathbf{s}(t^{n+1})+\\mathbf{s}(t^n)\\right) $$\n\n从 $t^n$ 到 $t^{n+1}$ 的整体时间步进算法如下：\n1.  利用已知的 $v^n$ 和 $\\mathbf{u}^n$ 值，首先使用从梯形法则推导出的直接更新公式计算 $v^{n+1}$。\n2.  为 $u$ 系统构建右侧向量 $\\mathbf{b}^n$。这包括在时间 $t^n$ 和 $t^{n+1}$ 处计算人造源项 $r(t)$ 和 $\\mathbf{s}(t)$，将已知的矩阵算子 $(I + \\frac{\\kappa\\Delta t}{2}A_h)$ 应用于 $\\mathbf{u}^n$，并包含涉及 $v^n$ 和新计算出的 $v^{n+1}$ 的耦合项。\n3.  求解线性系统 $\\left(I - \\frac{\\kappa\\Delta t}{2}A_h\\right) \\mathbf{u}^{n+1} = \\mathbf{b}^n$ 以获得未知向量 $\\mathbf{u}^{n+1}$。系统矩阵 $\\left(I - \\frac{\\kappa\\Delta t}{2}A_h\\right)$ 是三对角、对称且正定的，这使得可以使用专门的带状线性求解器（如托马斯算法）进行高效求解。\n\n此过程以离散初始条件 $\\mathbf{u}^0_i = u_0(x_i)$ 和 $v^0 = v_0$ 开始，并重复进行直到达到最终时间 $T$。\n\n对于收敛性研究，我们对每个测试用例进行两组数值实验：空间细化研究和时间细化研究。\n- 在空间研究中，我们将时间步长 $\\Delta t$ 固定为一个较小的值，并对一系列递减的网格间距 $h_j$（即递增的 $N_j$）进行模拟。\n- 在时间研究中，我们将空间网格 $h$ 固定得非常精细（大的 $N$），并对一系列递减的时间步长 $\\Delta t_j$ 进行模拟。\n\n对于每次模拟，在最终时间 $T$ 计算离散空间 $L^2$ 误差：\n$$ E = \\left( h \\sum_{i=1}^N \\left(u_i^T - u(x_i,T)\\right)^2 \\right)^{1/2} $$\n其中 $u_i^T$ 是数值解，$u(x_i,T)$ 是在网格点 $x_i$ 和最终时间 $T$ 处的精确人造解。\n\n从一系列细化 $\\{h_j\\}$ 或 $\\{\\Delta t_j\\}$ 获得的一系列误差 $\\{E_j\\}$ 中，计算连续细化之间的局部观测精度阶：\n$$ p_j = \\frac{\\log(E_j/E_{j+1})}{\\log(h_j/h_{j+1})} \\quad \\text{或} \\quad p_j = \\frac{\\log(E_j/E_{j+1})}{\\log(\\Delta t_j/\\Delta t_{j+1})} $$\n鉴于本问题中的细化比率为 $2$，这可简化为 $p_j = \\log_2(E_j/E_{j+1})$。\n\n通过在观测阶序列 $\\{p_j\\}$ 中找到第一个索引 $j$，使得从 $p_j$ 开始的连续 $m$ 个阶都满足 $|p_k - p^\\star| \\le \\tau$，来识别从前渐近区域到渐近区域的过渡。其中设计阶为 $p^\\star=2$，容差为 $\\tau=0.2$，连续层数为 $m=2$。如果未找到这样的索引，则报告过渡索引为 $0$。最终报告的渐近阶是序列中计算的最后一个局部阶，即 $p_{N-1}$，其中 $N$ 是细化的次数。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiments and print the final results.\n    \"\"\"\n\n    def u_exact(x, t, kappa):\n        pi = np.pi\n        return np.sin(pi * x) * np.exp(-kappa * pi**2 * t) + t**2 * np.sin(2 * pi * x)\n\n    def v_exact(t, lambda_val):\n        return np.exp(-lambda_val * t) + t**3\n\n    def phi_func(x):\n        return np.sin(np.pi * x)\n        \n    def r_source(t, lambda_val):\n        return 3 * t**2 + lambda_val * t**3\n\n    def s_source(x, t, kappa, gamma, lambda_val):\n        pi = np.pi\n        v_val = v_exact(t, lambda_val)\n        term1 = 2 * t * np.sin(2 * pi * x)\n        term2 = 4 * kappa * pi**2 * t**2 * np.sin(2 * pi * x)\n        term3 = -gamma * v_val * np.sin(pi * x)\n        return term1 + term2 + term3\n\n    def find_transition_index(orders, p_star, m, tau):\n        \"\"\"\n        Finds the transition index to the asymptotic regime.\n        Index is 1-based.\n        \"\"\"\n        if len(orders)  m:\n            return 0\n        for j in range(len(orders) - m + 1):\n            is_asymptotic = True\n            for k in range(m):\n                if abs(orders[j + k] - p_star) > tau:\n                    is_asymptotic = False\n                    break\n            if is_asymptotic:\n                return j + 1\n        return 0\n\n    def run_simulation(N, dt, T, kappa, gamma, lambda_val):\n        \"\"\"\n        Runs a single simulation for a given set of discretization parameters.\n        Returns the final L2 error in u.\n        \"\"\"\n        h = 1.0 / (N + 1)\n        x = np.linspace(h, 1.0 - h, N)\n        num_steps = int(round(T / dt))\n\n        # Initial conditions\n        u_n = u_exact(x, 0, kappa)\n        v_n = v_exact(0, lambda_val)\n        \n        # Assemble constant LHS matrix for the u-system\n        # M = I - (kappa*dt/2) * A_h\n        main_diag_val = 1.0 + kappa * dt / h**2\n        off_diag_val = -kappa * dt / (2 * h**2)\n        \n        # Banded matrix for scipy.linalg.solve_banded: (l, u), ab, b\n        # ab is (3, N) for l=1, u=1. ab[0,1:], ab[1,:], ab[2,:-1]\n        ab = np.zeros((3, N))\n        ab[0, 1:] = off_diag_val\n        ab[1, :] = main_diag_val\n        ab[2, :-1] = off_diag_val\n\n        phi_vec = phi_func(x)\n\n        for n in range(num_steps):\n            t_n = n * dt\n            t_np1 = (n + 1) * dt\n\n            # Step 1: Solve for v_np1\n            r_n = r_source(t_n, lambda_val)\n            r_np1 = r_source(t_np1, lambda_val)\n            v_num = (1 - lambda_val * dt / 2) * v_n + (dt / 2) * (r_np1 + r_n)\n            v_den = 1 + lambda_val * dt / 2\n            v_np1 = v_num / v_den\n\n            # Step 2: Construct RHS for u-system\n            # Part 1: (I + (kappa*dt/2) * A_h) * u_n\n            u_padded = np.concatenate(([0], u_n, [0]))\n            A_h_u_n = (u_padded[:-2] - 2 * u_padded[1:-1] + u_padded[2:]) / h**2\n            rhs_pde_part = u_n + (kappa * dt / 2) * A_h_u_n\n            \n            # Part 2: Source and coupling terms\n            s_n = s_source(x, t_n, kappa, gamma, lambda_val)\n            s_np1 = s_source(x, t_np1, kappa, gamma, lambda_val)\n            rhs_forcing_part = (gamma * dt / 2) * (v_np1 + v_n) * phi_vec + \\\n                               (dt / 2) * (s_np1 + s_n)\n            \n            rhs = rhs_pde_part + rhs_forcing_part\n\n            # Step 3: Solve for u_np1\n            u_np1 = solve_banded((1, 1), ab, rhs)\n\n            # Update for next step\n            u_n = u_np1\n            v_n = v_np1\n        \n        # Compute final error\n        u_exact_final = u_exact(x, T, kappa)\n        error = np.sqrt(h * np.sum((u_n - u_exact_final)**2))\n        return error\n\n    def run_convergence_study(params, is_spatial):\n        kappa, gamma, lambda_val, T = params[:4]\n\n        if is_spatial:\n            N_list, dt_fixed = params[4], params[5]\n            refinements = [1.0 / (N + 1) for N in N_list]\n            errors = [run_simulation(N, dt_fixed, T, kappa, gamma, lambda_val) for N in N_list]\n        else: # Temporal\n            N_fixed, dt_divs = params[6], params[7]\n            dt_list = [T / div for div in dt_divs]\n            refinements = dt_list\n            errors = [run_simulation(N_fixed, dt, T, kappa, gamma, lambda_val) for dt in dt_list]\n\n        orders = []\n        if len(errors) > 1:\n            for j in range(len(errors) - 1):\n                # Ratio of refinements is expected to be 2\n                ratio_ref = refinements[j] / refinements[j+1]\n                if errors[j] > 0 and errors[j+1] > 0:\n                    orders.append(np.log(errors[j] / errors[j+1]) / np.log(ratio_ref))\n                else:\n                    orders.append(0.0)\n        \n        last_order = orders[-1] if orders else 0.0\n        p_star, m, tau = 2.0, 2, 0.2\n        trans_idx = find_transition_index(orders, p_star, m, tau)\n        \n        return round(last_order, 3), trans_idx\n\n    test_cases = [\n        # Case 1: kappa, gamma, lambda, T, N_space, dt_space, N_time, dt_time_divs\n        (0.5, 1.0, 2.0, 0.2, [16, 32, 64, 128], 0.0001, 256, [40, 80, 160, 320, 640]),\n        # Case 2\n        (0.1, 0.2, 0.5, 0.05, [12, 24, 48, 96], 0.00005, 256, [20, 40, 80, 160, 320]),\n        # Case 3\n        (2.0, 0.5, 5.0, 0.1, [16, 32, 64, 128], 0.0001, 256, [20, 40, 80, 160, 320])\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        p_h_asy, j_h = run_convergence_study(case_params, is_spatial=True)\n        p_dt_asy, j_dt = run_convergence_study(case_params, is_spatial=False)\n        all_results.append(f\"[{p_h_asy},{j_h},{p_dt_asy},{j_dt}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3504818"}]}