{"hands_on_practices": [{"introduction": "掌握牛顿法的任何旅程都始于第一步：为一个小型非线性系统手动执行一次迭代。本练习旨在巩固对核心机制的理解，即如何构建残差向量 $\\mathbf{F}(\\mathbf{x})$ 和雅可比矩阵 $J(\\mathbf{x})$，并求解线性系统 $J(\\mathbf{x}_k) \\Delta \\mathbf{x}_k = -\\mathbf{F}(\\mathbf{x}_k)$ 以获得搜索方向。通过这个基础计算，我们将为后续更复杂的应用打下坚实的基础。[@problem_id:2190442]", "problem": "一个传感器被放置在一个二维平面上。其最终位置的坐标 $(x, y)$ 必须同时满足两个环境约束。第一个约束是传感器位于以原点为中心、半径为 2 的圆上。第二个约束来自一个信号强度模型，由方程 $\\exp(x) + y = 1$ 给出。\n\n为了找到传感器的坐标，我们可以使用牛顿-拉夫逊方法来求解相应的非线性方程组：\n$f_1(x, y) = x^2 + y^2 - 4 = 0$\n$f_2(x, y) = \\exp(x) + y - 1 = 0$\n\n从初始猜测 $\\mathbf{x}_0 = (x_0, y_0)^T = (1, 1)^T$ 开始，计算第一个搜索方向向量 $\\Delta \\mathbf{x}_0 = (\\Delta x_0, \\Delta y_0)^T$ 的分量。请以 $\\Delta x_0$ 和 $\\Delta y_0$ 的精确解析表达式对的形式给出你的答案。", "solution": "我们有方程组\n$$\nf_{1}(x,y)=x^{2}+y^{2}-4=0,\\qquad f_{2}(x,y)=\\exp(x)+y-1=0.\n$$\n一个系统的牛顿-拉夫逊更新使用雅可比矩阵 $J(x,y)$ 并求解\n$$\nJ(x_{0},y_{0})\\,\\Delta \\mathbf{x}_{0}=-\\mathbf{f}(x_{0},y_{0}),\n$$\n其中 $\\Delta \\mathbf{x}_{0}=(\\Delta x_{0},\\Delta y_{0})^{T}$ 且 $\\mathbf{f}=(f_{1},f_{2})^{T}$。\n\n首先计算雅可比矩阵：\n$$\nJ(x,y)=\\begin{pmatrix}\n\\frac{\\partial f_{1}}{\\partial x} & \\frac{\\partial f_{1}}{\\partial y} \\\\\n\\frac{\\partial f_{2}}{\\partial x} & \\frac{\\partial f_{2}}{\\partial y}\n\\end{pmatrix}\n=\\begin{pmatrix}\n2x & 2y \\\\\n\\exp(x) & 1\n\\end{pmatrix}.\n$$\n在初始猜测 $(x_{0},y_{0})=(1,1)$ 处，我们有\n$$\nJ(1,1)=\\begin{pmatrix}\n2 & 2 \\\\\n\\exp(1) & 1\n\\end{pmatrix}.\n$$\n在 $(1,1)$ 处计算函数向量：\n$$\n\\mathbf{f}(1,1)=\\begin{pmatrix}\n1^{2}+1^{2}-4 \\\\\n\\exp(1)+1-1\n\\end{pmatrix}\n=\\begin{pmatrix}\n-2 \\\\\n\\exp(1)\n\\end{pmatrix}.\n$$\n因此牛顿系统是\n$$\n\\begin{pmatrix}\n2 & 2 \\\\\n\\exp(1) & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n\\Delta x_{0} \\\\\n\\Delta y_{0}\n\\end{pmatrix}\n=\n-\\begin{pmatrix}\n-2 \\\\\n\\exp(1)\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n2 \\\\\n-\\exp(1)\n\\end{pmatrix}.\n$$\n这对应于线性方程组\n$$\n2\\Delta x_{0}+2\\Delta y_{0}=2,\\qquad \\exp(1)\\Delta x_{0}+\\Delta y_{0}=-\\exp(1).\n$$\n从第一个方程，$\\Delta y_{0}=1-\\Delta x_{0}$。代入第二个方程：\n$$\n\\exp(1)\\Delta x_{0}+(1-\\Delta x_{0})=-\\exp(1)\n\\;\\Rightarrow\\;\n\\left(\\exp(1)-1\\right)\\Delta x_{0}=-\\exp(1)-1,\n$$\n所以\n$$\n\\Delta x_{0}=-\\frac{\\exp(1)+1}{\\exp(1)-1}.\n$$\n然后\n$$\n\\Delta y_{0}=1-\\Delta x_{0}\n=1-\\left(-\\frac{\\exp(1)+1}{\\exp(1)-1}\\right)\n=1+\\frac{\\exp(1)+1}{\\exp(1)-1}\n=\\frac{(\\exp(1)-1)+(\\exp(1)+1)}{\\exp(1)-1}\n=\\frac{2\\exp(1)}{\\exp(1)-1}.\n$$\n因此，\n$$\n\\Delta x_{0}=-\\frac{\\exp(1)+1}{\\exp(1)-1},\\qquad\n\\Delta y_{0}=\\frac{2\\exp(1)}{\\exp(1)-1}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix} -\\frac{\\exp(1)+1}{\\exp(1)-1} \\\\ \\frac{2\\exp(1)}{\\exp(1)-1} \\end{pmatrix}}$$", "id": "2190442"}, {"introduction": "在科学与工程计算中，牛顿法的主要威力体现在求解由连续模型（如偏微分方程）离散化后产生的庞大非线性方程组。这个练习将牛顿法置于一个实际的科学计算场景中：求解一个非线性扩散反应方程经过时间离散后得到的代数系统。通过为这个更复杂的矢量值函数推导雅可比矩阵，你将把抽象的牛顿法与数值分析的实际应用联系起来。[@problem_id:3455013]", "problem": "考虑从一维非线性扩散反应偏微分方程 (PDE) $u_{t} = \\nu u_{xx} + \\alpha u - \\beta u^{3}$（定义在区间 $x \\in (0,L)$ 上，并带有齐次狄利克雷边界条件 $u(0,t) = u(L,t) = 0$）得到的半离散系统。使用一个包含两个内部点（因此未知量数量为 $m=2$）的均匀空间网格，带有齐次狄利克雷边界条件的中心差分拉普拉斯算子得到矩阵 $A \\in \\mathbb{R}^{2 \\times 2}$，其形式为 $A = \\begin{pmatrix} -2  1 \\\\ 1  -2 \\end{pmatrix}$，网格间距为 $h = L/3$。由此得到的半离散常微分方程 (ODE) 系统为 $u'(t) = f(u(t))$，其中 $f: \\mathbb{R}^{2} \\to \\mathbb{R}^{2}$ 定义为 $f(u) = \\frac{\\nu}{h^{2}} A u + \\alpha u - \\beta u^{\\odot 3}$，$u^{\\odot 3}$ 表示对 $u$ 的每个分量求立方。\n\n时间积分采用通用$\\theta$-方法。对于从 $t^{n}$ 到 $t^{n+1} = t^{n} + \\Delta t$ 的一个时间步长，该方法建立如下非线性系统：\n$$\nG(u^{n+1}) = u^{n+1} - u^{n} - \\Delta t \\Big[(1-\\theta) f(u^{n}) + \\theta f(u^{n+1})\\Big] = 0,\n$$\n需对此方程求解 $u^{n+1} \\in \\mathbb{R}^{2}$。\n\n从非线性系统的牛顿法标准定义和矩阵微积分的基本法则出发，完成以下任务：\n\n1. 构建求解 $G(u^{n+1}) = 0$ 的牛顿迭代格式，明确指出牛顿更新量和每次迭代中需要求解的线性系统。\n2. 对给定的 $f(u)$，显式地推导雅可比矩阵 $\\frac{\\partial G}{\\partial u}(u)$，并用 $\\nu$、$\\alpha$、$\\beta$、$h$、$\\Delta t$、$\\theta$、$A$ 和 $u$ 表示。\n3. 对于参数值 $L = 3$、$\\nu = 0.5$、$\\alpha = 1$、$\\beta = 2$、$\\Delta t = 0.1$、$\\theta = 0.7$ 以及求值点 $u^{n+1} = \\begin{pmatrix} 0.1 \\\\ -0.2 \\end{pmatrix}$，计算雅可比矩阵 $\\frac{\\partial G}{\\partial u}(u^{n+1})$ 的行列式。\n\n将最终的行列式值四舍五入至四位有效数字。将最终答案表示为一个纯数（无单位）。", "solution": "### 第1部分：构建牛顿迭代格式\n\n任务是求解关于未知向量 $u^{n+1} \\in \\mathbb{R}^{2}$ 的非线性方程组 $G(u^{n+1}) = 0$。该系统由下式给出：\n$$\nG(u^{n+1}) = u^{n+1} - u^{n} - \\Delta t \\Big[(1-\\theta) f(u^{n}) + \\theta f(u^{n+1})\\Big] = 0\n$$\n牛顿法是用于寻找向量值函数 $G(x)=0$ 根的一种迭代方法。从一个初始猜测值 $x_{(0)}$ 开始，它通过以下更新公式生成一系列近似值 $x_{(k)}$：\n$$\nx_{(k+1)} = x_{(k)} - \\left[ J_G(x_{(k)}) \\right]^{-1} G(x_{(k)})\n$$\n其中 $J_G(x) = \\frac{\\partial G}{\\partial x}(x)$ 是 $G$ 在 $x$ 处求值的雅可比矩阵。\n\n在实践中，通常不直接计算雅可比矩阵的逆。而是在每次迭代 $k$ 中，我们求解一个关于更新向量 $\\delta x = x_{(k+1)} - x_{(k)}$ 的线性系统。该线性系统为：\n$$\nJ_G(x_{(k)}) \\delta x = -G(x_{(k)})\n$$\n一旦求出 $\\delta x$，下一个近似值就通过 $x_{(k+1)} = x_{(k)} + \\delta x$ 计算得出。\n\n对于当前问题，未知量是 $u^{n+1}$。我们用向量 $u_{(k)}$ 表示 $u^{n+1}$ 的第 $k$ 次牛顿迭代值。一个常见的初始猜测值是 $u_{(0)} = u^{n}$。迭代过程如下：\n对 $k = 0, 1, 2, \\dots$ 进行迭代，直到收敛：\n1.  **计算牛顿更新量** $\\delta u \\in \\mathbb{R}^{2}$。这是迭代的核心步骤，需要求解以下 $2 \\times 2$ 线性系统：\n    $$\n    \\frac{\\partial G}{\\partial u}(u_{(k)}) \\delta u = -G(u_{(k)})\n    $$\n    此处，$\\frac{\\partial G}{\\partial u}(u_{(k)})$ 是 $G$ 在当前迭代值 $u_{(k)}$ 处的雅可比矩阵，而 $G(u_{(k)})$ 是残差向量：\n    $$\n    G(u_{(k)}) = u_{(k)} - u^{n} - \\Delta t \\Big[(1-\\theta) f(u^{n}) + \\theta f(u_{(k)})\\Big]\n    $$\n\n2.  **更新解**：\n    $$\n    u_{(k+1)} = u_{(k)} + \\delta u\n    $$\n重复此迭代过程，直到更新量的范数 $\\|\\delta u\\|$ 或残差的范数 $\\|G(u_{(k+1)})\\|$ 小于某个预设的容差。\n\n### 第2部分：雅可比矩阵的推导\n\n下一个任务是推导雅可比矩阵 $\\frac{\\partial G}{\\partial u}(u)$ 的解析表达式。为简化符号，我们用 $u$ 代表变量 $u^{n+1}$。函数 $G$ 为：\n$$\nG(u) = u - u^{n} - \\Delta t \\Big[(1-\\theta) f(u^{n}) + \\theta f(u)\\Big]\n$$\n为求雅可比矩阵，我们对 $G(u)$ 关于向量 $u$ 求导。在此微分过程中，$u^{n}$ 和 $f(u^{n})$ 是常数项。\n$$\n\\frac{\\partial G}{\\partial u}(u) = \\frac{\\partial}{\\partial u}(u) - \\frac{\\partial}{\\partial u}(u^{n}) - \\Delta t (1-\\theta) \\frac{\\partial}{\\partial u}(f(u^{n})) - \\Delta t \\theta \\frac{\\partial}{\\partial u}(f(u))\n$$\n常数项的导数为零。$u$ 对自身的导数是单位矩阵 $I \\in \\mathbb{R}^{2 \\times 2}$。\n$$\n\\frac{\\partial G}{\\partial u}(u) = I - 0 - 0 - \\Delta t \\theta \\frac{\\partial f}{\\partial u}(u) = I - \\Delta t \\theta \\frac{\\partial f}{\\partial u}(u)\n$$\n现在我们需要求 $f(u)$ 的雅可比矩阵，其中 $f(u) = \\frac{\\nu}{h^{2}} A u + \\alpha u - \\beta u^{\\odot 3}$。\n函数 $f(u)$ 由一个线性部分和一个非线性部分组成。线性部分 $\\frac{\\nu}{h^{2}} A u + \\alpha u = (\\frac{\\nu}{h^{2}} A + \\alpha I)u$ 的雅可比矩阵就是其矩阵系数：\n$$\n\\frac{\\partial}{\\partial u} \\left(\\frac{\\nu}{h^{2}} A u + \\alpha u\\right) = \\frac{\\nu}{h^{2}} A + \\alpha I\n$$\n非线性部分是 $-\\beta u^{\\odot 3}$。设 $u = \\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix}$，则 $-\\beta u^{\\odot 3} = -\\beta \\begin{pmatrix} u_1^3 \\\\ u_2^3 \\end{pmatrix}$。这一项的雅可比矩阵是：\n$$\n\\frac{\\partial}{\\partial u} (-\\beta u^{\\odot 3}) = -\\beta \\begin{pmatrix} \\frac{\\partial(u_1^3)}{\\partial u_1} & \\frac{\\partial(u_1^3)}{\\partial u_2} \\\\ \\frac{\\partial(u_2^3)}{\\partial u_1} & \\frac{\\partial(u_2^3)}{\\partial u_2} \\end{pmatrix} = -\\beta \\begin{pmatrix} 3u_1^2 & 0 \\\\ 0 & 3u_2^2 \\end{pmatrix} = -3\\beta \\cdot \\text{diag}(u_1^2, u_2^2)\n$$\n这可以简记为 $-3\\beta \\cdot \\text{diag}(u^{\\odot 2})$。\n结合 $f(u)$ 各部分的雅可比矩阵：\n$$\n\\frac{\\partial f}{\\partial u}(u) = \\frac{\\nu}{h^{2}} A + \\alpha I - 3\\beta \\cdot \\text{diag}(u^{\\odot 2})\n$$\n最后，将此结果代入 $\\frac{\\partial G}{\\partial u}(u)$ 的表达式中：\n$$\n\\frac{\\partial G}{\\partial u}(u) = I - \\Delta t \\theta \\left[ \\frac{\\nu}{h^{2}} A + \\alpha I - 3\\beta \\cdot \\text{diag}(u^{\\odot 2}) \\right]\n$$\n展开标量因子，得到雅可比矩阵的最终表达式：\n$$\n\\frac{\\partial G}{\\partial u}(u) = (1 - \\Delta t \\theta \\alpha)I - \\frac{\\Delta t \\theta \\nu}{h^2} A + 3 \\Delta t \\theta \\beta \\cdot \\text{diag}(u^{\\odot 2})\n$$\n\n### 第3部分：行列式的计算\n\n题目要求我们根据给定的参数值计算雅可比矩阵 $\\frac{\\partial G}{\\partial u}(u^{n+1})$ 的行列式。\n参数如下：\n$L = 3$，$\\nu = 0.5$，$\\alpha = 1$，$\\beta = 2$，$\\Delta t = 0.1$，$\\theta = 0.7$。\n求值点为 $u^{n+1} = \\begin{pmatrix} 0.1 \\\\ -0.2 \\end{pmatrix}$。\n首先，我们计算网格间距 $h$：\n$h = L/3 = 3/3 = 1$。\n\n接下来，我们计算雅可比矩阵表达式中的标量系数：\n单位矩阵 $I$ 的系数：\n$$\n1 - \\Delta t \\theta \\alpha = 1 - (0.1)(0.7)(1) = 1 - 0.07 = 0.93\n$$\n矩阵 $A$ 的系数：\n$$\n-\\frac{\\Delta t \\theta \\nu}{h^2} = -\\frac{(0.1)(0.7)(0.5)}{1^2} = -0.035\n$$\n对角矩阵的系数：\n$$\n3 \\Delta t \\theta \\beta = 3(0.1)(0.7)(2) = 0.42\n$$\n现在，我们根据求值点 $u = u^{n+1}$ 构建对角矩阵项：\n$$\nu^{\\odot 2} = \\begin{pmatrix} (0.1)^2 \\\\ (-0.2)^2 \\end{pmatrix} = \\begin{pmatrix} 0.01 \\\\ 0.04 \\end{pmatrix}\n$$\n所以，完整的对角项是：\n$$\n3 \\Delta t \\theta \\beta \\cdot \\text{diag}(u^{\\odot 2}) = 0.42 \\begin{pmatrix} 0.01 & 0 \\\\ 0 & 0.04 \\end{pmatrix} = \\begin{pmatrix} 0.0042 & 0 \\\\ 0 & 0.0168 \\end{pmatrix}\n$$\n现在我们可以组合出雅可比矩阵，记为 $J_G$：\n$$\nJ_G = 0.93 \\cdot I - 0.035 \\cdot A + \\begin{pmatrix} 0.0042 & 0 \\\\ 0 & 0.0168 \\end{pmatrix}\n$$\n代入 $I = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}$ 和 $A = \\begin{pmatrix} -2 & 1 \\\\ 1 & -2 \\end{pmatrix}$：\n$$\nJ_G = 0.93 \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} - 0.035 \\begin{pmatrix} -2 & 1 \\\\ 1 & -2 \\end{pmatrix} + \\begin{pmatrix} 0.0042 & 0 \\\\ 0 & 0.0168 \\end{pmatrix}\n$$\n$$\nJ_G = \\begin{pmatrix} 0.93 & 0 \\\\ 0 & 0.93 \\end{pmatrix} + \\begin{pmatrix} 0.07 & -0.035 \\\\ -0.035 & 0.07 \\end{pmatrix} + \\begin{pmatrix} 0.0042 & 0 \\\\ 0 & 0.0168 \\end{pmatrix}\n$$\n将矩阵逐分量相加：\n$$\nJ_G = \\begin{pmatrix} 0.93 + 0.07 + 0.0042 & -0.035 \\\\ -0.035 & 0.93 + 0.07 + 0.0168 \\end{pmatrix}\n$$\n$$\nJ_G = \\begin{pmatrix} 1.0042 & -0.035 \\\\ -0.035 & 1.0168 \\end{pmatrix}\n$$\n最后，我们计算这个 $2 \\times 2$ 矩阵的行列式：\n$$\n\\det(J_G) = (1.0042)(1.0168) - (-0.035)(-0.035)\n$$\n$$\n\\det(J_G) = 1.02107496 - (0.035)^2\n$$\n$$\n\\det(J_G) = 1.02107496 - 0.001225\n$$\n$$\n\\det(J_G) = 1.01984996\n$$\n题目要求将结果四舍五入至四位有效数字。前四位有效数字是 $1, 0, 1, 9$。第五位数字是 $8$，因此我们将第四位数字向上进位。\n$$\n\\det(J_G) \\approx 1.020\n$$\n在此情况下，末尾的零是有效数字。", "answer": "$$\\boxed{1.020}$$", "id": "3455013"}, {"introduction": "对于大型多物理场耦合问题，在每个迭代步中计算并求逆完整的雅可比矩阵的成本往往高得令人望而却步。这个练习引入了“非精确”牛顿法的概念，其中真实的雅可比矩阵被一个更易于处理的近似矩阵所取代。具体来说，我们将探讨一种在分区多物理场求解器中常见的策略——块高斯-赛德尔（Block Gauss–Seidel）近似，并学习如何通过分析迭代矩阵的谱半径来预测其收敛性。[@problem_id:3518059]", "problem": "考虑一个源于多物理场模型的耦合非线性系统，其抽象形式为求解向量值函数 $F(x) = 0$ 的根，其中 $x \\in \\mathbb{R}^{n}$，雅可比矩阵为 $J(x) = \\partial F / \\partial x$。在一个分块公式中，假设未知向量被拆分为 $x = \\begin{bmatrix} x_{1} \\\\ x_{2} \\end{bmatrix}$，相应的残差分量为 $F(x) = \\begin{bmatrix} F_{1}(x_{1}, x_{2}) \\\\ F_{2}(x_{1}, x_{2}) \\end{bmatrix}$，当前迭代点的雅可比矩阵表示为\n$$\nJ = \\begin{bmatrix} A  B \\\\ C  D \\end{bmatrix},\n$$\n其中 $A \\in \\mathbb{R}^{n_{1} \\times n_{1}}$，$B \\in \\mathbb{R}^{n_{1} \\times n_{2}}$，$C \\in \\mathbb{R}^{n_{2} \\times n_{1}}$ 且 $D \\in \\mathbb{R}^{n_{2} \\times n_{2}}$。非精确牛顿法用一个近似雅可比矩阵 $M$ 替代精确雅可比矩阵 $J$，以构建用于更新的线性模型。在分块高斯-赛德尔 (GS) 近似中，使用分块下三角矩阵\n$$\nM = \\begin{bmatrix} A  0 \\\\ C  D \\end{bmatrix}.\n$$\n从光滑函数 $F$ 的基本牛顿线性化定义出发：$F(x + \\delta x) \\approx F(x) + J \\, \\delta x$，非精确牛顿法在每次迭代中求解 $M \\, \\delta x = -F(x)$ 而非 $J \\, \\delta x = -F(x)$，然后应用更新 $x \\leftarrow x + \\delta x$。该方案在解 $x^\\star$ 附近的局部线性收敛性可以通过分析由 $J$ 和 $M$ 之间的模型误差导出的不动点误差传播算子来预测。\n\n任务：\n1) 从牛顿法和线性化的第一性原理出发，推导将当前线性化误差映射到下一次线性化误差的精确线性算子。此算子适用于采用上述分块高斯-赛德尔 (GS) 近似雅可比矩阵 $M$ 的非精确牛顿法。请将该算子纯粹用 $J$ 和 $M$ 表示。\n2) 将你的推导应用于给定的分块结构，并将该算子简化为以 $A$、$B$、$C$ 和 $D$ 表示的显式分块形式。然后，确定其谱如何依赖于这些分块。\n3) 实现一个程序，对于一组给定的测试用例（指定分块 $A$、$B$、$C$ 和 $D$），计算你在第2部分中推导出的迭代矩阵的谱半径（特征值绝对值的最大值）。谱半径必须以实数形式报告。除了明确给出的条件外，不应假设对称性或交换性。\n4) 使用以下测试套件。所有矩阵都应被视为量纲一致且无物理单位的实矩阵。对每个案例，计算迭代矩阵的谱半径，并将其四舍五入到八位小数。\n- 测试用例1（理想情况，弱耦合，方块矩阵）：$A = I_{2}$，$D = I_{2}$，$B = 0.2 \\, I_{2}$，$C = 0.3 \\, I_{2}$。\n- 测试用例2（中等耦合，非对称分块）：\n  $A = \\begin{bmatrix} 2  0 \\\\ 0  1 \\end{bmatrix}$，\n  $D = \\begin{bmatrix} 3  1 \\\\ 1  2 \\end{bmatrix}$，\n  $B = \\begin{bmatrix} 0.5  0.1 \\\\ 0.2  0.3 \\end{bmatrix}$，\n  $C = \\begin{bmatrix} 0.4  0.0 \\\\ 0.1  0.6 \\end{bmatrix}$。\n- 测试用例3（上分块解耦，精确求解）：\n  $A = \\begin{bmatrix} 4  1 \\\\ 1  3 \\end{bmatrix}$，\n  $D = \\begin{bmatrix} 2  0.5 \\\\ 0.5  1.5 \\end{bmatrix}$，\n  $B = \\begin{bmatrix} 0  0 \\\\ 0  0 \\end{bmatrix}$，\n  $C = \\begin{bmatrix} 0.7  -0.2 \\\\ 0.1  0.9 \\end{bmatrix}$。\n- 测试用例4（标量分块，接近收敛）：$A = [2]$，$D = [5]$，$B = [3.3]$，$C = [3.0]$。\n- 测试用例5（标量分块，边界情况）：$A = [2]$，$D = [5]$，$B = [2.0]$，$C = [5.0]$。\n- 测试用例6（标量分块，发散）：$A = [2]$，$D = [5]$，$B = [3.0]$，$C = [3.5]$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含六个测试用例的谱半径，按顺序排列，以逗号分隔，并用方括号括起来。每个数值必须四舍五入到八位小数。例如，一个包含两个假设结果的输出应如下所示：$\\texttt{[0.12345678,0.87654321]}$。\n- 每个测试用例的答案必须是实数（浮点数）。不应打印任何其他文本。", "solution": "### 第1部分：通用误差传播算子的推导\n\n令 $x^{(k)}$ 为逼近非线性系统 $F(x) = 0$ 的解 $x^{\\star}$ 的第 $k$ 次迭代。本次迭代的误差定义为 $e^{(k)} = x^{(k)} - x^{\\star}$。根据定义，有 $F(x^{\\star}) = 0$。\n\n在解 $x^{\\star}$ 附近对 $F(x)$ 进行泰勒展开可得：\n$$\nF(x^{(k)}) = F(x^{\\star} + e^{(k)}) \\approx F(x^{\\star}) + J(x^{\\star}) e^{(k)}\n$$\n其中 $J(x^{\\star})$ 是 $F$ 在解处求得的雅可比矩阵。由于 $F(x^{\\star}) = 0$，对于一个足够接近 $x^{\\star}$ 的迭代点 $x^{(k)}$，我们有如下近似：\n$$\nF(x^{(k)}) \\approx J e^{(k)}\n$$\n在这里，我们将解处的雅可比矩阵记为 $J = J(x^{\\star})$，并且为了进行局部收敛性分析，我们假设当前迭代点 $J(x^{(k)})$ 的雅可比矩阵约等于 $J(x^{\\star})$。\n\n非精确牛顿法通过求解线性系统 $M \\, \\delta x^{(k)} = -F(x^{(k)})$ 来定义更新步长 $\\delta x^{(k)}$，其中 $M$ 是真实雅可比矩阵 $J$ 的一个近似。然后应用更新 $x^{(k+1)} = x^{(k)} + \\delta x^{(k)}$。\n\n求解 $\\delta x^{(k)}$ 可得 $\\delta x^{(k)} = -M^{-1} F(x^{(k)})$。下一次迭代为 $x^{(k+1)} = x^{(k)} - M^{-1} F(x^{(k)})$。\n\n现在我们可以写出下一次迭代的误差表达式，$e^{(k+1)} = x^{(k+1)} - x^{\\star}$：\n$$\ne^{(k+1)} = (x^{(k)} - M^{-1} F(x^{(k)})) - x^{\\star} = (x^{(k)} - x^{\\star}) - M^{-1} F(x^{(k)}) = e^{(k)} - M^{-1} F(x^{(k)})\n$$\n将线性化关系 $F(x^{(k)}) \\approx J e^{(k)}$ 代入此方程，得到连续误差之间的关系：\n$$\ne^{(k+1)} \\approx e^{(k)} - M^{-1} (J e^{(k)}) = (I - M^{-1} J) e^{(k)}\n$$\n将当前线性化误差映射到下一个线性化误差的线性算子是矩阵 $G = I - M^{-1} J$，称为迭代矩阵。这完成了第一项任务。\n\n### 第2部分：应用于分块结构\n\n给定真实雅可比矩阵 $J$ 和近似雅可比矩阵 $M$ 的分块结构如下：\n$$\nJ = \\begin{bmatrix} A & B \\\\ C & D \\end{bmatrix}, \\quad M = \\begin{bmatrix} A & 0 \\\\ C & D \\end{bmatrix}\n$$\n为了求得迭代矩阵 $G = I - M^{-1} J$，我们首先需要计算分块下三角矩阵 $M$ 的逆。我们假设对角分块 $A$ 和 $D$ 是可逆的，这是该方法适用性的一个标准要求。其逆矩阵 $M^{-1}$ 也将是分块下三角矩阵：\n$$\nM^{-1} = \\begin{bmatrix} A^{-1} & 0 \\\\ -D^{-1}CA^{-1} & D^{-1} \\end{bmatrix}\n$$\n通过检验 $M M^{-1} = I$ 可以验证这一点。\n\n接下来，我们计算乘积 $M^{-1}J$：\n$$\nM^{-1}J = \\begin{bmatrix} A^{-1} & 0 \\\\ -D^{-1}CA^{-1} & D^{-1} \\end{bmatrix} \\begin{bmatrix} A & B \\\\ C & D \\end{bmatrix}\n$$\n$$\nM^{-1}J = \\begin{bmatrix} (A^{-1}A + 0 \\cdot C) & (A^{-1}B + 0 \\cdot D) \\\\ (-D^{-1}CA^{-1}A + D^{-1}C) & (-D^{-1}CA^{-1}B + D^{-1}D) \\end{bmatrix}\n$$\n$$\nM^{-1}J = \\begin{bmatrix} I & A^{-1}B \\\\ (-D^{-1}C + D^{-1}C) & (I - D^{-1}CA^{-1}B) \\end{bmatrix}\n$$\n$$\nM^{-1}J = \\begin{bmatrix} I & A^{-1}B \\\\ 0 & I - D^{-1}CA^{-1}B \\end{bmatrix}\n$$\n现在，我们可以求得迭代矩阵 $G$：\n$$\nG = I - M^{-1}J = \\begin{bmatrix} I & 0 \\\\ 0 & I \\end{bmatrix} - \\begin{bmatrix} I & A^{-1}B \\\\ 0 & I - D^{-1}CA^{-1}B \\end{bmatrix}\n$$\n$$\nG = \\begin{bmatrix} 0 & -A^{-1}B \\\\ 0 & D^{-1}CA^{-1}B \\end{bmatrix}\n$$\n这就是迭代矩阵的显式分块形式。\n\n分块（上或下）三角矩阵的特征值是其对角分块特征值的并集。在本例中，$G$ 的对角分块是零矩阵 $0 \\in \\mathbb{R}^{n_1 \\times n_1}$ 和矩阵 $K = D^{-1}CA^{-1}B \\in \\mathbb{R}^{n_2 \\times n_2}$。\n\n零矩阵的特征值全为 $0$。因此，$G$ 的谱由下式给出：\n$$\n\\text{spec}(G) = \\text{spec}(0) \\cup \\text{spec}(D^{-1}CA^{-1}B) = \\{0\\} \\cup \\text{spec}(D^{-1}CA^{-1}B)\n$$\n非精确牛顿法的收敛性由谱半径 $\\rho(G) = \\max_{\\lambda \\in \\text{spec}(G)} |\\lambda|$ 决定。根据上面推导出的谱，迭代矩阵的谱半径为：\n$$\n\\rho(G) = \\max(\\{0\\} \\cup \\{|\\lambda| : \\lambda \\in \\text{spec}(D^{-1}CA^{-1}B)\\}) = \\rho(D^{-1}CA^{-1}B)\n$$\n因此，局部收敛率由矩阵乘积 $D^{-1}CA^{-1}B$ 的谱半径决定。\n\n### 第3和第4部分：实现与计算\n\n最后的任务是实现一个程序，为所提供的测试用例计算 $\\rho(K)$，其中 $K = D^{-1}CA^{-1}B$。这包括构造矩阵，执行矩阵乘法和求逆，找到结果矩阵 $K$ 的特征值，并取其绝对值的最大值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the spectral radius of the iteration matrix for a block Gauss-Seidel\n    inexact Newton method for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: happy path, weak coupling, square blocks\n        {\n            \"A\": np.identity(2, dtype=float),\n            \"B\": 0.2 * np.identity(2, dtype=float),\n            \"C\": 0.3 * np.identity(2, dtype=float),\n            \"D\": np.identity(2, dtype=float),\n        },\n        # Test Case 2: moderate coupling, nonsymmetric blocks\n        {\n            \"A\": np.array([[2., 0.], [0., 1.]]),\n            \"B\": np.array([[0.5, 0.1], [0.2, 0.3]]),\n            \"C\": np.array([[0.4, 0.0], [0.1, 0.6]]),\n            \"D\": np.array([[3., 1.], [1., 2.]]),\n        },\n        # Test Case 3: uncoupled upper block, exact solve\n        {\n            \"A\": np.array([[4., 1.], [1., 3.]]),\n            \"B\": np.zeros((2, 2), dtype=float),\n            \"C\": np.array([[0.7, -0.2], [0.1, 0.9]]),\n            \"D\": np.array([[2., 0.5], [0.5, 1.5]]),\n        },\n        # Test Case 4: scalar blocks, near-convergent\n        {\n            \"A\": np.array([[2.]]),\n            \"B\": np.array([[3.3]]),\n            \"C\": np.array([[3.0]]),\n            \"D\": np.array([[5.]]),\n        },\n        # Test Case 5: scalar blocks, boundary\n        {\n            \"A\": np.array([[2.]]),\n            \"B\": np.array([[2.0]]),\n            \"C\": np.array([[5.0]]),\n            \"D\": np.array([[5.]]),\n        },\n        # Test Case 6: scalar blocks, divergent\n        {\n            \"A\": np.array([[2.]]),\n            \"B\": np.array([[3.0]]),\n            \"C\": np.array([[3.5]]),\n            \"D\": np.array([[5.]]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        A, B, C, D = case[\"A\"], case[\"B\"], case[\"C\"], case[\"D\"]\n\n        # The iteration matrix for the error is G, with spectral radius\n        # rho(G) = rho(K), where K = D^{-1} * C * A^{-1} * B.\n        \n        # Calculate matrix K\n        inv_A = np.linalg.inv(A)\n        inv_D = np.linalg.inv(D)\n        \n        K = inv_D @ C @ inv_A @ B\n        \n        # Compute eigenvalues of K.\n        # If K is a 0x0 matrix (empty), its spectrum is empty, and spectral radius is 0.\n        if K.size == 0:\n            spec_rad = 0.0\n        else:\n            eigenvalues = np.linalg.eigvals(K)\n            # Spectral radius is the maximum absolute value of the eigenvalues.\n            spec_rad = np.max(np.abs(eigenvalues))\n        \n        results.append(spec_rad)\n\n    # Format results to eight decimal places and print in the specified format.\n    formatted_results = [f\"{r:.8f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3518059"}]}