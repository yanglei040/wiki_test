{"hands_on_practices": [{"introduction": "本练习是多速率积分方法的基础，它侧重于为一个基本的一维守恒律实现局部时间步进（LTS）方案。在多速率方法中，确保跨越粗细网格界面的通量守恒至关重要。本练习将通过实现通量累加这一标准技术来解决该问题，从而加深您对守恒子循环核心机制的理解。[@problem_id:3516710]", "problem": "考虑一个具有常系数线性平流的标量守恒律的一维、周期性、有限体积离散化。控制方程是每个控制体积上的积分形式的守恒律：单元平均值的变化率等于通过其边界的净通量。从守恒原理出发，对于一个单元索引为 $i$、宽度为 $\\Delta x$ 的控制体积，其单元平均值 $u_i(t)$ 的演化遵循\n$$\n\\frac{d}{dt}\\left(u_i(t)\\right) = -\\frac{1}{\\Delta x}\\left(f_{i+\\frac{1}{2}}(t) - f_{i-\\frac{1}{2}}(t)\\right),\n$$\n其中 $f_{i+\\frac{1}{2}}(t)$ 是单元 $i$ 右侧界面上的物理通量。对于速度为常数 $a$（无量纲）的线性平流，通量为 $f(x,t)=a\\,u(x,t)$。在一个具有 $N$ 个单元和周期性边界条件的均匀网格上，我们将单元 $i$ 和 $i+1$ 之间的界面表示为索引 $i+\\frac{1}{2}$，并采用周期性环绕，因此单元索引的算术运算在模 $N$ 下进行。\n\n对于常数平流速度 $a$，一阶迎风显式有限体积法使用数值通量\n$$\nF_{i+\\frac{1}{2}}(t) = \n\\begin{cases}\na\\,u_i(t), & a \\ge 0,\\\\\na\\,u_{i+1}(t), & a < 0,\n\\end{cases}\n$$\n也就是说，$F_{i+\\frac{1}{2}}(t) = a\\,u_{\\text{upwind}}(t)$，其中 $u_{\\text{upwind}}(t)$ 是 $t$ 时刻的迎风单元平均值。\n\n你需要设计一个多速率局部时间步长方案，该方案通过子循环进行通量更新，在一个宏观步长内，将使用精细时间步长的单元与使用粗略时间步长的单元耦合起来。设一个布尔掩码指示哪些单元是精细单元，哪些是粗略单元。所有精细单元使用 $m$ 个大小为 $\\Delta t_f$ 的均匀子步长进行推进，而所有粗略单元使用宏观步长 $\\Delta t_c = m\\,\\Delta t_f$ 推进一次。必须在所有区域强制执行 Courant–Friedrichs–Lewy 条件，即 $|a|\\,\\Delta t_f/\\Delta x \\le 1$ 和 $|a|\\,\\Delta t_c/\\Delta x \\le 1$，以确保迎风方案的数值稳定性。\n\n你的任务：\n\n1. 根据守恒律和数值通量的定义，论证为何粗略单元在宏观步长上的更新必须使用精细单元在 $m$ 个子步长中累积的时间积分界面通量，即对于每个界面 $i+\\frac{1}{2}$，时间积分 $\\int_{t^n}^{t^{n}+\\Delta t_c} F_{i+\\frac{1}{2}}(t)\\,dt$ 应由累积和 $\\sum_{k=1}^m F_{i+\\frac{1}{2}}^{(k)}\\,\\Delta t_f$ 来近似，其中 $F_{i+\\frac{1}{2}}^{(k)}$ 是在第 $k$ 个子步长中计算的数值通量。利用这一点，写出每个粗略单元在宏观步长上的守恒更新公式，用这些累积通量和来表示。\n\n2. 对于精细单元，使用每个子步长中的迎风通量和时间步长 $\\Delta t_f$ 推导其 $m$ 子步长的更新公式，并应用周期性边界条件。\n\n3. 实现一个程序，对于下面的每个测试用例，使用所述的多速率子循环策略将系统精确推进一个宏观步长 $\\Delta t_c = m\\,\\Delta t_f$。实现必须：\n- 在 $m$ 个子步长期间，维护界面通量积分的运行累积值 $S_{i+\\frac{1}{2}} = \\sum_{k=1}^m F_{i+\\frac{1}{2}}^{(k)}\\,\\Delta t_f$。\n- 在每个子步长期间，仅使用显式迎风法更新精细单元。\n- 完成 $m$ 个子步长后，使用累积的 $S_{i\\pm\\frac{1}{2}}$ 对每个粗略单元进行一次精确更新，以确保守恒性。\n- 使用周期性边界，因此索引算术运算在模 $N$ 下进行。\n\n所有量都是无量纲的。不出现角度，也不使用百分比。最终输出是单元平均值，它们是无单位的实数。对于数值输出，将每个单元平均值四舍五入到8位小数。\n\n测试套件：\n\n对于每个测试用例，给定元组 $(N,\\Delta x,a,\\Delta t_f,m,\\text{fine\\_mask},u^0)$，其中 $N$ 是单元数，$\\Delta x$ 是单元宽度， $a$ 是平流速度，$\\Delta t_f$ 是精细时间步长， $m$ 是每个宏观步长中的精细子步长数，$\\text{fine\\_mask}$ 是一个长度为 $N$ 的布尔列表，其中 `True` 值标记精细单元，`False` 值标记粗略单元，而 $u^0$ 是 $t^n$ 时刻的初始单元平均值列表。宏观步长为 $\\Delta t_c=m\\,\\Delta t_f$。测试如下：\n\n- $\\text{案例 }1$：$(N=\\;4,\\;\\Delta x=\\;1.0,\\;a=\\;1.0,\\;\\Delta t_f=\\;0.4,\\;m=\\;2,\\;\\text{fine\\_mask}=[\\text{True},\\text{True},\\text{False},\\text{False}],\\;u^0=[1.0,2.0,3.0,4.0])$。\n- $\\text{案例 }2$：$(N=\\;4,\\;\\Delta x=\\;1.0,\\;a=\\;-1.0,\\;\\Delta t_f=\\;0.3,\\;m=\\;3,\\;\\text{fine\\_mask}=[\\text{False},\\text{True},\\text{True},\\text{False}],\\;u^0=[0.0,1.0,0.0,0.0])$。\n- $\\text{案例 }3$：$(N=\\;4,\\;\\Delta x=\\;1.0,\\;a=\\;0.0,\\;\\Delta t_f=\\;0.2,\\;m=\\;5,\\;\\text{fine\\_mask}=[\\text{True},\\text{False},\\text{True},\\text{False}],\\;u^0=[0.5,0.0,-0.5,1.0])$。\n- $\\text{案例 }4$：$(N=\\;4,\\;\\Delta x=\\;1.0,\\;a=\\;2.0,\\;\\Delta t_f=\\;0.5,\\;m=\\;1,\\;\\text{fine\\_mask}=[\\text{True},\\text{True},\\text{True},\\text{True}],\\;u^0=[1.0,0.0,0.0,0.0])$。\n- $\\text{案例 }5$：$(N=\\;4,\\;\\Delta x=\\;1.0,\\;a=\\;1.0,\\;\\Delta t_f=\\;0.25,\\;m=\\;4,\\;\\text{fine\\_mask}=[\\text{False},\\text{False},\\text{True},\\text{True}],\\;u^0=[1.0,0.0,0.0,0.0])$。\n\n你的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的列表，并用方括号括起来。列表中的每个条目本身都是一个用方括号括起来的逗号分隔列表，包含该测试用例的 $N$ 个更新后的单元平均值（在时间 $t^{n}+\\Delta t_c$），并四舍五入到8位小数。例如，输出格式必须严格如 $[[\\dots],[\\dots],\\dots]$，不含空格。", "solution": "我们从具有周期性边界、宽度为 $\\Delta x$ 的一维控制体积的有限体积守恒声明开始。对于单元索引 $i$，设 $u_i(t)$ 表示守恒量的单元平均值。守恒律给出\n$$\n\\frac{d}{dt}\\left(u_i(t)\\right) = -\\frac{1}{\\Delta x}\\left(f_{i+\\frac{1}{2}}(t) - f_{i-\\frac{1}{2}}(t)\\right).\n$$\n对于速度为常数 $a$ 的线性平流，物理通量为 $f(x,t) = a\\,u(x,t)$。对于常数 $a$，一个标准的一阶迎风数值通量是\n$$\nF_{i+\\frac{1}{2}}(t) = a\\,u_{\\text{upwind}}(t) = \n\\begin{cases}\na\\,u_i(t), & a \\ge 0,\\\\\na\\,u_{i+1}(t), & a < 0.\n\\end{cases}\n$$\n在时间上使用显式欧拉法对一个步长 $\\Delta t$ 进行离散化，得到著名的一阶迎风有限体积更新公式\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right).\n$$\n为保证该显式迎风法的稳定性，必须满足 Courant–Friedrichs–Lewy 条件：\n$$\n\\frac{|a|\\,\\Delta t}{\\Delta x} \\le 1.\n$$\n\n为了构建一个带子循环的多速率局部时间步长方法，我们将单元集合划分为两个子集：精细单元（用小步长 $\\Delta t_f$ 推进）和粗略单元（用大步长 $\\Delta t_c$ 推进）。设存在一个整数 $m \\ge 1$，使得 $\\Delta t_c = m\\,\\Delta t_f$。考虑从时间 $t^n$ 开始，将解精确推进一个宏观步长 $\\Delta t_c$。该方案按如下步骤进行。\n\n对于每个子步长索引 $k=1,\\dots,m$，我们执行：\n- 在时间 $t^{n} + (k-1)\\Delta t_f$ 时，使用迎风规则和当前的单元平均值计算数值通量 $F_{i+\\frac{1}{2}}^{(k)}$。精细单元已在之前的子步长中更新，而粗略单元在整个 $m$ 个子步长中保持其初始值 $u_i^n$。\n- 根据在 $\\Delta t_f$ 上的显式迎风更新公式来更新每个精细单元 $i$：\n$$\nu_i^{(k)} = u_i^{(k-1)} - \\frac{\\Delta t_f}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^{(k)} - F_{i-\\frac{1}{2}}^{(k)}\\right),\n$$\n其中 $u_i^{(0)} = u_i^n$。这使得粗略单元在子循环期间保持不变。\n- 使用黎曼和累积宏观步长上的时间积分界面通量\n$$\nS_{i+\\frac{1}{2}} \\leftarrow S_{i+\\frac{1}{2}} + F_{i+\\frac{1}{2}}^{(k)}\\,\\Delta t_f,\n$$\n在宏观步长开始时初始化 $S_{i+\\frac{1}{2}}=0$。\n\n完成所有 $m$ 个子步长后，我们使用时间积分通量对每个粗略单元 $j$ 在宏观步长上进行一次更新，以保持守恒性：\n$$\nu_j^{n+1} = u_j^n - \\frac{1}{\\Delta x}\\left(S_{j+\\frac{1}{2}} - S_{j-\\frac{1}{2}}\\right).\n$$\n这个公式直接来自于将守恒律在时间区间 $[t^n,t^n+\\Delta t_c]$ 上积分：\n$$\nu_j^{n+1} - u_j^n = -\\frac{1}{\\Delta x}\\int_{t^n}^{t^n+\\Delta t_c} \\left(F_{j+\\frac{1}{2}}(t) - F_{j-\\frac{1}{2}}(t)\\right)\\,dt,\n$$\n并通过由子步长构建的累积黎曼和 $S$ 来近似每个界面时间积分 $\\int F\\,dt$。这种构造确保了在宏观步长上跨越任何界面的通量被相邻的两个单元一致地使用：对于精细单元，通过其子步长更新；对于粗略单元，通过积分更新，从而保证了离散层面的守恒性。\n\n周期性边界条件通过对所有单元索引取模 $N$ 来强制执行，因此 $i+1$ 从 $N-1$ 环绕到 $0$，而 $i-1$ 从 $0$ 环绕到 $N-1$。界面索引 $i+\\frac{1}{2}$ 由整数 $i$ 表示，代表单元 $i$ 和 $i+1$ 之间的界面。\n\n稳定性：由于粗略单元在子步长期间不被更新，它们与其他粗略邻居的界面通量在宏观步长期间保持不变，它们对 $S$ 的贡献恰好是通过重复累积提供的 $F\\,\\Delta t_c$。应用于精细单元的显式更新要求精细库朗数 $|a|\\,\\Delta t_f/\\Delta x \\le 1$，而对于粗略-粗略单元的相互作用，粗略库朗数 $|a|\\,\\Delta t_c/\\Delta x \\le 1$ 在宏观步长上保持稳定性。\n\n每个测试用例的程序算法步骤：\n- 在时间 $t^n$ 初始化状态 $u^0$。\n- 对所有界面 $i=0,\\dots,N-1$ 初始化通量积分 $S_{i+\\frac{1}{2}}=0$。\n- 对于 $k=1$ 到 $m$：\n    - 使用迎风规则和当前状态（精细单元已更新，粗略单元仍为 $u^n$）计算所有界面通量 $F_{i+\\frac{1}{2}}$。\n    - 对所有界面累积 $S_{i+\\frac{1}{2}} \\mathrel{+}= F_{i+\\frac{1}{2}}\\,\\Delta t_f$。\n    - 使用 $u_i \\mathrel{-}= (\\Delta t_f/\\Delta x)\\,(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}})$ 更新每个精细单元。\n- 经过 $m$ 个子步长后，通过以下方式设置宏观步长解 $u^{n+1}$：\n    - 对于精细单元，使用它们在 $m$ 个子步长后的当前值。\n    - 对于粗略单元，使用累积的 $S$ 计算 $u_j^{n+1} = u_j^n - (1/\\Delta x)\\,(S_{j+\\frac{1}{2}} - S_{j-\\frac{1}{2}})$。\n\n最后，将 $u^{n+1}$ 的每个分量四舍五入到8位小数，并输出每个测试用例的单元平均值列表。输出格式必须是单行，为一个不含空格的列表的列表，即形式为 $[[\\dots],[\\dots],\\dots]$。\n\n该方法满足守恒性，并通过在宏观步长上一致地积分界面通量，并以直接从基本守恒律推导出的方式将其应用于精细和粗略单元，从而实现了有限体积通量更新的多速率子循环。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef upwind_flux(u, a):\n    \"\"\"\n    Compute upwind numerical fluxes F_{i+1/2} for constant advection speed a\n    on a periodic 1D grid. Interface index i corresponds to interface between\n    cell i and cell (i+1) mod N.\n    \"\"\"\n    N = u.size\n    F = np.empty(N, dtype=float)\n    if a >= 0.0:\n        # Upwind from the left cell: F_{i+1/2} = a * u_i\n        F[:] = a * u\n    else:\n        # Upwind from the right cell: F_{i+1/2} = a * u_{i+1}\n        F[:] = a * np.roll(u, -1)\n    return F\n\ndef multirate_one_macrostep(u0, dx, a, dt_f, m, fine_mask):\n    \"\"\"\n    Advance solution by one macro-step dt_c = m * dt_f using multirate subcycling.\n    - u0: initial cell averages (numpy array, shape (N,))\n    - dx: cell width\n    - a: advection speed (constant)\n    - dt_f: fine time step\n    - m: number of fine substeps per macro-step\n    - fine_mask: boolean numpy array of length N; True for fine cells, False for coarse\n    Returns: u1 (numpy array), the solution after one macro-step\n    \"\"\"\n    N = u0.size\n    u_current = u0.copy()\n    # Accumulate time-integrated flux at each interface over the macro-step\n    sumFdt = np.zeros(N, dtype=float)\n    # Subcycling: fine cells advance m times; coarse cells remain frozen during substeps\n    for _ in range(m):\n        F = upwind_flux(u_current, a)\n        sumFdt += F * dt_f\n        # Update only fine cells explicitly with upwind scheme over dt_f\n        # u_i -= (dt_f/dx)*(F_{i+1/2} - F_{i-1/2})\n        if np.any(fine_mask):\n            # Compute flux divergence term\n            divF = F - np.roll(F, 1)\n            u_current[fine_mask] -= (dt_f / dx) * divF[fine_mask]\n        # Coarse cells remain unchanged in u_current during subcycling\n    # After subcycling, fine cells are already at macro-step time.\n    # Update coarse cells once using the accumulated flux integrals sumFdt.\n    u1 = u_current.copy()\n    if np.any(~fine_mask):\n        divS = sumFdt - np.roll(sumFdt, 1)\n        u1[~fine_mask] = u0[~fine_mask] - (1.0 / dx) * divS[~fine_mask]\n    return u1\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (N, dx, a, dt_f, m, fine_mask, u0)\n    test_cases = [\n        (4, 1.0, 1.0, 0.4, 2, [True, True, False, False], [1.0, 2.0, 3.0, 4.0]),\n        (4, 1.0, -1.0, 0.3, 3, [False, True, True, False], [0.0, 1.0, 0.0, 0.0]),\n        (4, 1.0, 0.0, 0.2, 5, [True, False, True, False], [0.5, 0.0, -0.5, 1.0]),\n        (4, 1.0, 2.0, 0.5, 1, [True, True, True, True], [1.0, 0.0, 0.0, 0.0]),\n        (4, 1.0, 1.0, 0.25, 4, [False, False, True, True], [1.0, 0.0, 0.0, 0.0]),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, dx, a, dt_f, m, fine_mask_list, u0_list = case\n        fine_mask = np.array(fine_mask_list, dtype=bool)\n        u0 = np.array(u0_list, dtype=float)\n        # Sanity checks for dimensions\n        assert u0.size == N\n        assert fine_mask.size == N\n        # Perform one macro-step\n        u1 = multirate_one_macrostep(u0, dx, a, dt_f, m, fine_mask)\n        # Round to 8 decimals\n        u1_rounded = [float(f\"{val:.8f}\") for val in u1.tolist()]\n        results.append(u1_rounded)\n\n    # Format the output exactly as required: single line, no spaces, nested lists\n    def format_results(res):\n        def fmt_list(lst):\n            return \"[\" + \",\".join(f\"{x:.8f}\" for x in lst) + \"]\"\n        return \"[\" + \",\".join(fmt_list(lst) for lst in res) + \"]\"\n\n    print(format_results(results))\n\nsolve()\n```", "id": "3516710"}, {"introduction": "本练习将我们的注意力从单个离散化的偏微分方程转移到不同子系统的耦合问题上，这在多物理场协同仿真中非常常见。当具有不同时间尺度的子系统耦合时，数据交换的延迟会引入误差。本练习将探讨如何使用外推法来减少这种耦合延迟，并分析整个耦合方案的数值稳定性。[@problem_id:3516696]", "problem": "考虑一个功能样机接口 (FMI) 协同仿真，其中包含两个线性耦合的子系统，它们具有独立的时钟 $t_1$ 和 $t_2$。这两个子系统在宏观时间 $t^n = t_0 + n H$ 进行同步，其中 $H$ 是以秒为单位的宏观步长。子系统 $1$（时钟 $t_1$）仅在宏观时间推进其状态，而子系统 $2$（时钟 $t_2$）在宏观时间之间以精细步长 $\\delta t = H/m$ 进行子周期循环，其中 $m \\in \\mathbb{N}$ 是子周期的数量。连续时间模型为\n$$\n\\frac{dx}{dt} = -\\alpha x,\\qquad \\frac{dy}{dt} = -\\beta y + \\gamma\\, u(t),\n$$\n其中 $x(t)$ 是子系统 1 的状态，$y(t)$ 是子系统 2 的状态，$u(t)$ 是子系统 2 接收的耦合输入，该输入由一个外插算子根据子系统 1 的宏观采样构建。常数 $\\alpha$、$\\beta$ 和 $\\gamma$ 是非负实数，单位为逆秒 $\\mathrm{s}^{-1}$。时间以秒为单位。\n\n在一个宏观区间 $[t^n, t^{n+1}]$ 上的协同仿真协议如下：\n- 子系统 1 使用宏观步长 $H$ 的前向欧拉法，将其状态从 $x^n = x(t^n)$ 推进到 $x^{n+1} = x(t^{n+1})$。\n- 子系统 2 使用精细步长 $\\delta t = H/m$ 的前向欧拉法，在 $m$ 个子步上将其状态从 $y^n = y(t^n)$ 推进到 $y^{n+1} = y(t^{n+1})$，在每个精细子步中消耗一个外插输入 $u(t)$，该输入通过一个 $k$ 阶外插算子 $\\mathcal{E}_k$ 从 $x$ 的过去宏观采样构建。\n\n令 $\\theta \\in [0,1]$ 表示宏观区间内的归一化时间，定义为 $\\theta = (t - t^n)/H$。外插算子 $\\mathcal{E}_k$ 使用最近的 $k+1$ 个宏观采样 $\\{x^n, x^{n-1}, \\dots, x^{n-k}\\}$ 来构建一个关于 $\\theta$ 的 $k$ 阶多项式，该多项式从 $\\theta = 0$ 向前外插至 $\\theta \\in [0,1]$。具体而言：\n- 对于 $k=0$（零阶保持），$\\mathcal{E}_0$ 在宏观区间上是常数：$u(t) = x^n$。\n- 对于 $k=1$（线性外插），$\\mathcal{E}_1$ 是使用节点 $\\theta=0$ 和 $\\theta=-1$ 的拉格朗日多项式：$u(t) = (\\theta+1)\\,x^n - \\theta\\,x^{n-1}$。\n- 对于 $k=2$（二次外插），$\\mathcal{E}_2$ 是使用节点 $\\theta=0,-1,-2$ 的拉格朗日多项式：$u(t) = \\tfrac{1}{2}(\\theta^2 + 3\\theta + 2)\\,x^n - (\\theta^2 + 2\\theta)\\,x^{n-1} + \\tfrac{1}{2}(\\theta^2 + \\theta)\\,x^{n-2}$。\n\n数值积分方案由前向欧拉更新定义：\n$$\nx^{n+1} = x^n + H\\,(-\\alpha x^n),\n$$\n对于子系统 2，在时间 $t_j = t^n + j \\delta t$（因此 $\\theta_j = j/m$）处，有 $m$ 个子步，索引为 $j=0,1,\\dots,m-1$，\n$$\ny_{j+1} = y_j + \\delta t \\left(-\\beta y_j + \\gamma\\,u(t_j)\\right),\\qquad y_0 = y^n,\\qquad y^{n+1} = y_m.\n$$\n此 FMI 协同仿真定义了一个从时间 $t^n$ 的宏观状态到时间 $t^{n+1}$ 的宏观状态的宏观步长线性映射。根据外插阶数 $k$，该宏观步长映射作用于一个增广状态，该状态包含 $\\mathcal{E}_k$ 所需的子系统 1 的过去宏观采样。一个宏观步长的线性放大矩阵记为 $M_k$，在重复宏观步长下，耦合协同仿真的稳定性由谱半径 $\\rho(M_k)$ 决定；当且仅当 $\\rho(M_k) < 1$ 时，宏观更新是稳定的。谱半径是无量纲的。\n\n任务：\n1. 从连续时间模型和定义的数值方案出发，使用所述的外插算子 $\\mathcal{E}_k$ 和前向欧拉更新，推导 $k \\in \\{0,1,2\\}$ 时的精确宏观步长放大矩阵 $M_k$。您的推导必须仅使用基本定律和核心定义，以及经过充分检验的公式。请用标准的 LaTeX 格式表达所有数学对象。\n2. 实现一个程序，对于给定的参数 $(\\alpha,\\beta,\\gamma,H,m,k)$，构建 $M_k$ 并计算其谱半径 $\\rho(M_k)$。\n3. 使用以下参数集测试套件评估 $\\rho(M_k)$，其中所有时间单位为秒，速率单位为逆秒：\n   - 测试用例 1（理想情况，使用零阶保持进行子周期循环）：$(\\alpha,\\beta,\\gamma,H,m,k) = (5,\\,40,\\,8,\\,0.02,\\,10,\\,0)$。\n   - 测试用例 2（与用例 1 相同，使用线性外插）：$(5,\\,40,\\,8,\\,0.02,\\,10,\\,1)$。\n   - 测试用例 3（与用例 1 相同，使用二次外插）：$(5,\\,40,\\,8,\\,0.02,\\,10,\\,2)$。\n   - 测试用例 4（边界类宏观步长，无子周期循环，使用零阶保持）：$(5,\\,40,\\,8,\\,0.0499,\\,1,\\,0)$。\n   - 测试用例 5（精细子周期循环，使用零阶保持）：$(5,\\,40,\\,8,\\,0.05,\\,50,\\,0)$。\n4. 您的程序应生成单行输出，其中包含五个测试用例的谱半径，以逗号分隔并用方括号括起，顺序与上面列出的一致。例如，输出格式必须与以下完全相同：\"[result1,result2,result3,result4,result5]\"。每个 \"result\" 都必须是一个浮点数。\n\n所有输出均为无量纲浮点数。请勿在输出中使用任何单位。时间输入 $\\alpha$、$\\beta$ 和 $\\gamma$ 必须解释为 $\\mathrm{s}^{-1}$，而 $H$ 和 $\\delta t$ 必须解释为秒。本问题不涉及角度。任何地方都不得使用百分比；请以数值方式进行比较。\n\n本问题要求从第一性原理推导宏观步长放大矩阵，并计算谱半径以评估稳定性。在问题陈述中避免使用快捷公式；解答中应给出严谨的推导。", "solution": "经评估，用户提供的问题是有效的。它在科学上基于常微分方程的数值分析原理，特别是在协同仿真和多速率方法的背景下。该问题是适定的、客观的，并包含推导唯一、可验证解所需的所有信息。\n\n目标是为耦合系统推导宏观步长放大矩阵 $M_k$，并计算其在 $k \\in \\{0, 1, 2\\}$ 时的谱半径 $\\rho(M_k)$。协同仿真方案的稳定性由条件 $\\rho(M_k) < 1$ 决定。推导过程按要求从第一性原理开始。\n\n该系统由两个耦合的线性常微分方程描述：\n$$\n\\frac{dx}{dt} = -\\alpha x\n$$\n$$\n\\frac{dy}{dt} = -\\beta y + \\gamma\\, u(t)\n$$\n子系统 1（状态 $x$）在每个宏观步长 $n$ 处，使用步长为 $H$ 的前向欧拉法进行推进：\n$$\nx^{n+1} = x^n + H(-\\alpha x^n) = (1 - \\alpha H) x^n\n$$\n子系统 2（状态 $y$）在宏观区间 $[t^n, t^{n+1}]$ 内，使用步长为 $\\delta t = H/m$ 的前向欧拉法，进行 $m$ 次子步推进。对于在时间 $t_j = t^n + j\\delta t$ 的子步 $j \\in \\{0, 1, \\dots, m-1\\}$：\n$$\ny_{j+1} = y_j + \\delta t(-\\beta y_j + \\gamma u(t_j)) = (1 - \\beta \\delta t) y_j + \\gamma \\delta t u(t_j)\n$$\n其中 $y_0 = y^n$。令 $A_y = 1 - \\beta \\delta t$。此线性递推关系在 $m$ 步后的解为：\n$$\ny^{n+1} = y_m = A_y^m y_n + \\gamma \\delta t \\sum_{j=0}^{m-1} A_y^{m-1-j} u(t_j)\n$$\n耦合输入 $u(t_j)$ 是基于过去宏观状态 $\\{x^n, x^{n-1}, \\ldots, x^{n-k}\\}$ 的 $k$ 阶外插。宏观步长更新是一个线性映射 $Z^{n+1} = M_k Z^n$，其中 $Z^n$ 是一个包含外插所需历史信息的增广状态向量。\n\n**情况 $k=0$（零阶保持）**\n外插为 $u(t) = x^n$。增广状态为 $Z^n = [x^n, y^n]^T$。\n$y^{n+1}$ 的更新变为：\n$$\ny^{n+1} = A_y^m y^n + \\gamma \\delta t \\sum_{j=0}^{m-1} A_y^{m-1-j} x^n = A_y^m y^n + \\left( \\gamma \\delta t \\sum_{j=0}^{m-1} A_y^{m-1-j} \\right) x^n\n$$\n该和是一个几何级数 $\\sum_{p=0}^{m-1} A_y^p$。如果 $\\beta = 0$，则 $A_y=1$ 且和为 $m$。如果 $\\beta \\neq 0$，则和为 $\\frac{1-A_y^m}{1-A_y} = \\frac{1-A_y^m}{\\beta \\delta t}$。两种情况下，乘以 $x^n$ 的项均为 $\\frac{\\gamma}{\\beta}(1-A_y^m)$。\n宏观步长方程为：\n$$\n\\begin{align*}\nx^{n+1} = (1 - \\alpha H) x^n \\\\\ny^{n+1} = \\frac{\\gamma}{\\beta}(1 - (1 - \\beta H/m)^m) x^n + (1 - \\beta H/m)^m y^n\n\\end{align*}\n$$\n这定义了 $2 \\times 2$ 的放大矩阵 $M_0$：\n$$\nM_0 = \\begin{pmatrix}\n1 - \\alpha H & 0 \\\\\n\\frac{\\gamma}{\\beta}(1 - (1 - \\frac{\\beta H}{m})^m) & (1 - \\frac{\\beta H}{m})^m\n\\end{pmatrix}\n$$\n\n**情况 $k=1$（线性外插）**\n外插为 $u(t) = (\\theta+1)x^n - \\theta x^{n-1}$，其中 $\\theta(t) = (t-t^n)/H$。在子步 $j$ 处，$\\theta_j = j/m$。增广状态必须包含历史信息 $x^{n-1}$，因此 $Z^n = [x^n, x^{n-1}, y^n]^T$。下一个状态为 $Z^{n+1} = [x^{n+1}, x^n, y^{n+1}]^T$。\n$y^{n+1}$ 的更新为：\n$$\ny^{n+1} = A_y^m y^n + \\gamma \\delta t \\sum_{j=0}^{m-1} A_y^{m-1-j} \\left( (\\frac{j}{m}+1)x^n - \\frac{j}{m}x^{n-1} \\right)\n$$\n这可以写为 $y^{n+1} = C_1 x^n + D_1 x^{n-1} + A_y^m y^n$，其中\n$$\nC_1 = \\gamma \\delta t \\sum_{j=0}^{m-1} A_y^{m-1-j} (1 + j/m)\n$$\n$$\nD_1 = -\\gamma \\delta t \\sum_{j=0}^{m-1} A_y^{m-1-j} (j/m)\n$$\n状态更新方程为：\n$$\n\\begin{align*}\nx^{n+1} &= (1 - \\alpha H) x^n \\\\\nx^n &= x^n \\\\\ny^{n+1} &= C_1 x^n + D_1 x^{n-1} + (1 - \\beta H/m)^m y^n\n\\end{align*}\n$$\n这定义了 $3 \\times 3$ 的放大矩阵 $M_1$：\n$$\nM_1 = \\begin{pmatrix}\n1 - \\alpha H & 0 & 0 \\\\\n1 & 0 & 0 \\\\\nC_1 & D_1 & (1 - \\frac{\\beta H}{m})^m\n\\end{pmatrix}\n$$\n系数 $C_1$ 和 $D_1$ 通过数值计算这些和得出。\n\n**情况 $k=2$（二次外插）**\n外插为 $u(t) = \\tfrac{1}{2}(\\theta^2 + 3\\theta + 2)x^n - (\\theta^2 + 2\\theta)x^{n-1} + \\tfrac{1}{2}(\\theta^2 + \\theta)x^{n-2}$。增广状态为 $Z^n = [x^n, x^{n-1}, x^{n-2}, y^n]^T$，下一个状态为 $Z^{n+1} = [x^{n+1}, x^n, x^{n-1}, y^{n+1}]^T$。\n$y^{n+1}$ 的更新为：\n$$\ny^{n+1} = A_y^m y^n + \\gamma \\delta t \\sum_{j=0}^{m-1} A_y^{m-1-j} u(t_j)\n$$\n这可以写为 $y^{n+1} = C_2 x^n + D_2 x^{n-1} + E_2 x^{n-2} + A_y^m y^n$，其中系数为：\n$$\nC_2 = \\gamma \\delta t \\sum_{j=0}^{m-1} A_y^{m-1-j} \\left( \\tfrac{1}{2}(\\theta_j^2 + 3\\theta_j + 2) \\right)\n$$\n$$\nD_2 = \\gamma \\delta t \\sum_{j=0}^{m-1} A_y^{m-1-j} \\left( -(\\theta_j^2 + 2\\theta_j) \\right)\n$$\n$$\nE_2 = \\gamma \\delta t \\sum_{j=0}^{m-1} A_y^{m-1-j} \\left( \\tfrac{1}{2}(\\theta_j^2 + \\theta_j) \\right)\n$$\n其中 $\\theta_j = j/m$。状态更新方程为：\n$$\n\\begin{align*}\nx^{n+1} &= (1 - \\alpha H) x^n \\\\\nx^n &= x^n \\\\\nx^{n-1} &= x^{n-1} \\\\\ny^{n+1} &= C_2 x^n + D_2 x^{n-1} + E_2 x^{n-2} + (1 - \\beta H/m)^m y^n\n\\end{align*}\n$$\n这定义了 $4 \\times 4$ 的放大矩阵 $M_2$：\n$$\nM_2 = \\begin{pmatrix}\n1 - \\alpha H & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\nC_2 & D_2 & E_2 & (1 - \\frac{\\beta H}{m})^m\n\\end{pmatrix}\n$$\n系数 $C_2$、 $D_2$ 和 $E_2$ 通过数值计算这些和得出。然后通过计算 $M_k$ 的特征值并找出其模的最大值来得到谱半径 $\\rho(M_k)$。", "answer": "```python\nimport numpy as np\n\ndef get_amplification_matrix(alpha, beta, gamma, H, m, k):\n    \"\"\"\n    Constructs the macro-step amplification matrix M_k.\n\n    Args:\n        alpha (float): Rate for Subsystem 1.\n        beta (float): Rate for Subsystem 2.\n        gamma (float): Coupling strength.\n        H (float): Macro-step size.\n        m (int): Number of subcycles.\n        k (int): Degree of extrapolation.\n\n    Returns:\n        numpy.ndarray: The amplification matrix M_k.\n    \"\"\"\n    if m < 1:\n        raise ValueError(\"Number of subcycles m must be a positive integer.\")\n    if k not in [0, 1, 2]:\n        raise ValueError(\"Extrapolation order k must be 0, 1, or 2.\")\n\n    dt = H / m\n    Ay = 1.0 - beta * dt\n\n    # The size of the matrix is (k+1) for x_history + 1 for y\n    matrix_size = k + 2\n    M = np.zeros((matrix_size, matrix_size))\n\n    # Top-left block for x-state propagation\n    # x^{n+1} = (1 - alpha*H) * x^n\n    M[0, 0] = 1.0 - alpha * H\n    # x^{n-i+1} = x^{n-i} for i = 1..k\n    for i in range(1, k + 1):\n        M[i, i - 1] = 1.0\n\n    # Bottom-right entry for y-state decay\n    # This is the (k+1, k+1) element in 0-based indexing\n    M[k + 1, k + 1] = Ay**m\n\n    # Last row for coupling terms from x to y\n    # These are the coefficients C, D, E...\n    # y_coeffs will store [C, D, E, ...]\n    y_coeffs = np.zeros(k + 1)\n\n    # Numerically compute the sums for the coefficients\n    for j in range(m):\n        theta = j / m\n        term_Ay = Ay**(m - 1 - j)\n        \n        # Lagrange polynomial basis values at theta_j\n        if k == 0:\n            L = [1.0]\n        elif k == 1:\n            L0 = theta + 1.0\n            L1 = -theta\n            L = [L0, L1]\n        elif k == 2:\n            L0 = 0.5 * (theta**2 + 3.0 * theta + 2.0)\n            L1 = -(theta**2 + 2.0 * theta)\n            L2 = 0.5 * (theta**2 + theta)\n            L = [L0, L1, L2]\n        \n        for i in range(k + 1):\n            y_coeffs[i] += term_Ay * L[i]\n\n    # Final multiplication by gamma * dt\n    y_coeffs *= (gamma * dt)\n    \n    # Place coefficients in the last row of M\n    M[k + 1, 0:k + 1] = y_coeffs\n\n    return M\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        (5.0, 40.0, 8.0, 0.02, 10, 0),\n        (5.0, 40.0, 8.0, 0.02, 10, 1),\n        (5.0, 40.0, 8.0, 0.02, 10, 2),\n        (5.0, 40.0, 8.0, 0.0499, 1, 0),\n        (5.0, 40.0, 8.0, 0.05, 50, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, beta, gamma, H, m, k = case\n        \n        # Handle the special case of beta=0, where Ay=1 and the closed-form for k=0 fails.\n        # The numerical summation handles this naturally. However, for k=0, a\n        # closed-form solution is more efficient and direct.\n        if k == 0 and beta != 0:\n            # Using the derived closed-form for k=0\n            matrix_size = 2\n            M = np.zeros((matrix_size, matrix_size))\n            M[0, 0] = 1.0 - alpha * H\n            Ay_m = (1.0 - beta * H / m)**m\n            M[1, 1] = Ay_m\n            M[1, 0] = (gamma / beta) * (1.0 - Ay_m)\n        else:\n            # Use the general numerical summation for k=1, k=2, or k=0 with beta=0\n            M = get_amplification_matrix(alpha, beta, gamma, H, m, k)\n        \n        eigenvalues = np.linalg.eigvals(M)\n        spectral_radius = np.max(np.abs(eigenvalues))\n        results.append(spectral_radius)\n\n    # Format the output as a comma-separated list in brackets.\n    # The repr() function is used to ensure full precision floating-point representation.\n    print(f\"[{','.join(map(repr, results))}]\")\n\nsolve()\n```", "id": "3516696"}, {"introduction": "在固定子循环的基础上，这个高级实践引入了一种自适应方法，代表了更精巧和高效的多速率策略。对于振荡系统，通过将同步点与快速动态的相位对齐，可以显著优化耦合效果。本练习要求您设计并实现一个“相位检测器”，以动态选择最佳同步时刻，从而最小化耦合误差。[@problem_id:3516676]", "problem": "考虑一个双场多物理场模型，该模型包含一个快子系统和一个慢子系统，它们在一个宏观时间步长内的同步点上进行耦合。快子系统是一个谐振子，慢子系统是一个线性弛豫过程，由每个宏观步长内选定同步时间点的快变量采样值驱动。目标是设计一种多速率自适应同步策略，该策略根据快子系统的相位来选择同步时间，以最小化步末失配。\n\n基本原理：\n- 快子系统状态 $y_f(t)$ 由二阶常微分方程 $y_f''(t) + \\omega^2 y_f(t) = 0$ 控制，其中 $\\omega$ 是角频率（单位：rad/s）。对于初始条件 $y_f(0) = A$ 和 $y_f'(0) = 0$，其精确解为 $y_f(t) = A \\cos(\\omega t)$，瞬时相位为 $\\phi(t) = \\omega t$（单位：弧度）。\n- 慢子系统遵循一阶线性常微分方程 $y_s'(t) = -k y_s(t) + \\beta y_f(t_\\mathrm{sync})$，其中 $k$ 和 $\\beta$ 的单位均为秒的倒数（$\\mathrm{s}^{-1}$），$y_f(t_\\mathrm{sync})$ 是在宏观步长内选定的同步时间点采样的快状态。\n\n多速率离散化：\n- 设宏观步为 $[t^n, t^{n+1}]$，其中 $t^{n+1} = t^n + \\Delta t$，$\\Delta t$ 是宏观步长（单位：秒）。\n- 快子系统在每个宏观步内进行 $N_\\mathrm{fast}$ 个均匀子步的子循环，因此候选同步时间为 $t_\\mathrm{sync}^j = t^n + \\theta_j \\Delta t$，其中 $\\theta_j = \\frac{j}{N_\\mathrm{fast}}$ 且 $j \\in \\{1,2,\\dots,N_\\mathrm{fast}-1\\}$，以确保 $\\theta_j \\in (0,1)$。\n- 慢子系统使用显式欧拉法在宏观步上推进，通过使用采样的快变量值进行单次宏观更新：$y_s^{n+1} = y_s^n + \\Delta t \\left(-k y_s^n + \\beta y_f(t_\\mathrm{sync})\\right)$。\n\n基于相位的自适应同步策略：\n- 定义步末失配为 $m^n(\\theta) = \\left| y_f(t^{n+1}) - y_s^{n+1}(\\theta) \\right|$，其中 $y_s^{n+1}(\\theta)$ 是通过使用选定的 $t_\\mathrm{sync} = t^n + \\theta \\Delta t$ 得到的。\n- 使用快变量的精确解 $y_f(t) = A \\cos(\\phi(t))$（其中 $\\phi(t) = \\omega t$），慢变量的更新变为 $y_s^{n+1}(\\theta) = y_s^n + \\Delta t \\left(-k y_s^n + \\beta A \\cos(\\phi(t^n) + \\omega \\theta \\Delta t)\\right)$。\n- 在宏观步结束时，快状态为 $y_f(t^{n+1}) = A \\cos(\\phi(t^n) + \\omega \\Delta t)$。通过选择一个 $\\theta$ 值，使得 $\\cos(\\phi(t^n) + \\omega \\theta \\Delta t)$ 接近于通过匹配 $y_s^{n+1}$ 与 $y_f(t^{n+1})$ 推断出的目标值，可以减小失配。求解 $y_s^{n+1}(\\theta) \\approx y_f(t^{n+1})$ 可得一个目标余弦值：\n$$\nC^\\star = \\frac{A \\cos\\left(\\phi(t^n) + \\omega \\Delta t\\right) - y_s^n + \\Delta t\\,k\\,y_s^n}{\\beta A \\Delta t}.\n$$\n- 一个相位检测器在子循环网格点 $m \\in \\{1,\\dots,N_\\mathrm{fast}-1\\}$ 处计算 $\\phi(t_m) = \\phi(t^n) + \\omega \\frac{m}{N_\\mathrm{fast}} \\Delta t$。然后，它选择能够最小化 $\\left|\\cos(\\phi(t_j)) - \\tilde{C}^\\star\\right|$ 的索引 $j$，其中 $\\tilde{C}^\\star = \\min\\{1, \\max\\{-1, C^\\star\\}\\}$ 将目标值限制在余弦函数的有效范围内。选定的同步时间为 $t_\\mathrm{sync} = t^n + \\theta_j \\Delta t$，其中 $\\theta_j = \\frac{j}{N_\\mathrm{fast}}$。\n\n目标与评估：\n- 在总共 $M$ 个宏观步上，计算由上述自适应策略产生的平均步末失配 $\\bar{m} = \\frac{1}{M} \\sum_{n=0}^{M-1} m^n(\\theta_j)$。\n- 所有角度必须以弧度为单位。时间必须以秒为单位。平均失配 $\\bar{m}$ 是振幅之差，因此是无量纲的（没有单位）。\n\n你的任务：\n- 在一个完整的程序中实现上述策略，该程序针对每个测试用例，模拟 $M$ 个宏观步，执行带有相位检测器的快子循环以在每个宏观步内选择同步点，使用选定的 $y_f(t_\\mathrm{sync})$ 更新慢子系统，并计算平均步末失配 $\\bar{m}$。\n- 使用快变量的精确解 $y_f(t) = A \\cos(\\omega t)$ 进行子循环采样和计算步末值。\n\n测试套件：\n为以下四个参数集提供结果，每个参数集产生一个标量输出 $\\bar{m}$：\n1. 理想情况：$A=1.0$，$\\omega=80.0$ rad/s，$\\Delta t=0.025$ s， $N_\\mathrm{fast}=50$，$k=5.0$ $\\mathrm{s}^{-1}$，$\\beta=2.0$ $\\mathrm{s}^{-1}$，$M=20$，$y_s(0)=A$。\n2. 边界钳位情况：$A=1.0$，$\\omega=80.0$ rad/s，$\\Delta t=0.025$ s， $N_\\mathrm{fast}=50$，$k=5.0$ $\\mathrm{s}^{-1}$，$\\beta=0.05$ $\\mathrm{s}^{-1}$，$M=20$，$y_s(0)=A$。\n3. 每个宏观步的小相位推进：$A=1.0$，$\\omega=10.0$ rad/s，$\\Delta t=0.010$ s， $N_\\mathrm{fast}=5$，$k=1.0$ $\\mathrm{s}^{-1}$，$\\beta=2.0$ $\\mathrm{s}^{-1}$，$M=50$，$y_s(0)=A$。\n4. 每个宏观步的多个周期：$A=1.0$，$\\omega=500.0$ rad/s，$\\Delta t=0.020$ s， $N_\\mathrm{fast}=100$，$k=3.0$ $\\mathrm{s}^{-1}$，$\\beta=1.5$ $\\mathrm{s}^{-1}$，$M=25$，$y_s(0)=A$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个结果，格式为用方括号括起来的逗号分隔列表（例如，要显示列表中的四个浮点数：\"[result1,result2,result3,result4]\"）。每个结果必须是对应测试用例的平均步末失配 $\\bar{m}$，表示为一个无单位的浮点数。", "solution": "该问题要求为一个包含两个常微分方程的耦合系统实现一个自适应多速率时间积分方案。该系统由一个快子系统和一个慢子系统组成。快子系统由谐振子描述，状态为 $y_f(t)$；慢子系统由线性弛豫过程描述，状态为 $y_s(t)$。问题的核心是设计并实现一种自适应同步策略，在每个宏观时间步 $[t^n, t^{n+1}]$ 内选择一个同步时间 $t_\\mathrm{sync}$，以最小化在步末时刻 $t^{n+1}$ 快慢状态之间的失配。\n\n控制方程如下：\n快子系统：$y_f''(t) + \\omega^2 y_f(t) = 0$。在初始条件 $y_f(0) = A$ 和 $y_f'(0) = 0$ 下，精确解为 $y_f(t) = A \\cos(\\omega t)$。瞬时相位为 $\\phi(t) = \\omega t$。\n慢子系统：$y_s'(t) = -k y_s(t) + \\beta y_f(t_\\mathrm{sync})$。\n\n模拟过程在 $M$ 个宏观步上进行，每个步长为 $\\Delta t$。对于每个宏观步 $n$，从初始状态 $(t^n, y_s^n)$ 开始，执行以下算法步骤来计算后续状态 $y_s^{n+1}$ 和相应的失配 $m^n$。\n\n1.  **定义宏观步内的目标**：在步长 $[t^n, t^{n+1}]$ 内的主要目标是选择一个同步时间分数 $\\theta \\in (0,1)$，使得步末得到的慢状态 $y_s^{n+1}(\\theta)$ 尽可能接近该时刻真实的快状态 $y_f(t^{n+1})$。步末失配定义为 $m^n(\\theta) = \\left| y_f(t^{n+1}) - y_s^{n+1}(\\theta) \\right|$。\n\n2.  **建立目标条件**：慢子系统使用单次显式欧拉步在宏观区间上进行更新：\n    $$y_s^{n+1} = y_s^n + \\Delta t \\left(-k y_s^n + \\beta y_f(t_\\mathrm{sync})\\right) = y_s^n (1 - k \\Delta t) + \\beta \\Delta t y_f(t_\\mathrm{sync})$$\n    同步时间为 $t_\\mathrm{sync} = t^n + \\theta \\Delta t$，我们使用快变量的精确解：$y_f(t_\\mathrm{sync}) = A \\cos(\\omega(t^n+\\theta\\Delta t)) = A \\cos(\\phi(t^n) + \\omega \\theta \\Delta t)$。步末的快变量为 $y_f(t^{n+1}) = A \\cos(\\omega(t^n+\\Delta t)) = A \\cos(\\phi(t^n) + \\omega \\Delta t)$。\n    为了最小化失配，我们理想地设置 $y_s^{n+1} \\approx y_f(t^{n+1})$，这给出：\n    $$A \\cos(\\phi(t^n) + \\omega \\Delta t) \\approx y_s^n (1 - k \\Delta t) + \\beta \\Delta t A \\cos(\\phi(t^n) + \\omega \\theta \\Delta t)$$\n    我们可以求解包含未知数 $\\theta$ 的余弦项，我们将其定义为目标余弦值 $C^\\star$:\n    $$\\cos(\\phi(t^n) + \\omega \\theta \\Delta t) \\approx \\frac{A \\cos\\left(\\phi(t^n) + \\omega \\Delta t\\right) - y_s^n (1 - k \\Delta t)}{\\beta A \\Delta t}$$\n    这就是问题陈述中给出的 $C^\\star$ 的表达式。\n\n3.  **实现自适应同步策略**：\n    a.  在第 $n$ 步开始时，使用当前状态值 $y_s^n$ 和 $\\phi(t^n) = \\omega t^n = \\omega n \\Delta t$ 计算目标余弦值 $C^\\star$。\n    b.  $C^\\star$ 的值可能落在余弦函数的有效范围 $[-1, 1]$ 之外。因此，将其钳位到此范围以产生一个可行目标：$\\tilde{C}^\\star = \\min\\{1, \\max\\{-1, C^\\star\\}\\}$。\n    c.  通过将宏观步子循环为 $N_\\mathrm{fast}$ 个均匀间隔来确定候选同步时间分数集。候选分数为 $\\theta_j = \\frac{j}{N_\\mathrm{fast}}}$，其中 $j \\in \\{1, 2, \\dots, N_\\mathrm{fast}-1\\}$。\n    d.  对每个候选索引 $j$，计算其相位的余弦值：$\\cos(\\phi(t^n) + \\omega \\theta_j \\Delta t)$。\n    e.  算法选择最优索引 $j^\\star$，该索引最小化候选余弦值与钳位目标之间的绝对差：$j^\\star = \\arg\\min_{j \\in \\{1, \\dots, N_\\mathrm{fast}-1\\}} \\left|\\cos(\\phi(t^n) + \\omega \\theta_j \\Delta t) - \\tilde{C}^\\star\\right|$。\n\n4.  **更新状态并计算失配**：\n    a.  一旦找到最优索引 $j^\\star$，同步时间就固定为 $t_\\mathrm{sync} = t^n + \\frac{j^\\star}{N_\\mathrm{fast}}} \\Delta t$。\n    b.  此时快变量的值 $y_f(t_\\mathrm{sync}) = A \\cos(\\omega t_\\mathrm{sync})$ 用于更新慢状态：\n        $$y_s^{n+1} = y_s^n (1 - k \\Delta t) + \\beta \\Delta t y_f(t_\\mathrm{sync})$$\n    c.  然后计算第 $n$ 步的步末失配：\n        $$m^n = \\left| y_f(t^{n+1}) - y_s^{n+1} \\right| = \\left| A \\cos(\\omega t^{n+1}) - y_s^{n+1} \\right|$$\n    d.  为下一次迭代更新当前状态：$y_s^n$ 变为 $y_s^{n+1}$。\n\n5.  **计算平均失配**：对总共 $M$ 个宏观步重复此过程。累加总失配，并计算最终平均失配为 $\\bar{m} = \\frac{1}{M} \\sum_{n=0}^{M-1} m^n$。\n\n将这整个过程封装到一个程序中，并对四个指定的测试用例分别执行，以获得最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(A, omega, delta_t, N_fast, k, beta, M, y_s_initial):\n    \"\"\"\n    Runs the multiphysics simulation for one set of parameters.\n\n    Args:\n        A (float): Amplitude of the fast subsystem.\n        omega (float): Angular frequency of the fast subsystem (rad/s).\n        delta_t (float): Macro step size (s).\n        N_fast (int): Number of fast subcycles per macro step.\n        k (float): Relaxation constant for the slow subsystem (s^-1).\n        beta (float): Coupling constant (s^-1).\n        M (int): Total number of macro steps.\n        y_s_initial (float): Initial value of the slow subsystem state.\n\n    Returns:\n        float: The average end-of-step mismatch over M steps.\n    \"\"\"\n    y_s = y_s_initial\n    total_mismatch = 0.0\n\n    # Candidate indices for synchronization j in {1, 2, ..., N_fast-1}\n    j_candidates = np.arange(1, N_fast)\n    theta_candidates = j_candidates / N_fast\n\n    for n in range(M):\n        t_n = n * delta_t\n        phi_n = omega * t_n\n\n        # 1. Calculate the target cosine value C_star\n        phi_end = phi_n + omega * delta_t\n        y_f_end = A * np.cos(phi_end)\n\n        # Denominator of C_star\n        denominator = beta * A * delta_t\n        if np.abs(denominator) < 1e-15: # Avoid division by zero\n            # If beta or A or delta_t is zero, C_star is ill-defined.\n            # In this context, we can assume it will not happen based on problem constraints.\n            # However, for robustness, we can set C_star to a value that leads to a default behavior.\n            # Let's say we pick the middle of the interval.\n            C_star = 0.0\n        else:\n            C_star = (y_f_end - y_s * (1.0 - k * delta_t)) / denominator\n\n        # 2. Clamp C_star to the feasible range [-1, 1]\n        C_star_tilde = np.clip(C_star, -1.0, 1.0)\n        \n        # 3. Find the best synchronization index j\n        candidate_phases = phi_n + omega * theta_candidates * delta_t\n        candidate_cosines = np.cos(candidate_phases)\n        \n        diffs = np.abs(candidate_cosines - C_star_tilde)\n        best_j_idx = np.argmin(diffs)\n        \n        # 4. Get the cosine value for the chosen synchronization point\n        cos_y_f_sync = candidate_cosines[best_j_idx]\n        y_f_sync = A * cos_y_f_sync\n        \n        # 5. Update the slow state y_s\n        y_s_next = y_s * (1.0 - k * delta_t) + beta * delta_t * y_f_sync\n        \n        # 6. Calculate the end-of-step mismatch\n        mismatch = np.abs(y_f_end - y_s_next)\n        total_mismatch += mismatch\n        \n        # 7. Update state for the next step\n        y_s = y_s_next\n\n    # 8. Compute the average mismatch\n    average_mismatch = total_mismatch / M\n    return average_mismatch\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (A, omega, delta_t, N_fast, k, beta, M, y_s(0))\n        (1.0, 80.0, 0.025, 50, 5.0, 2.0, 20, 1.0), # Happy path\n        (1.0, 80.0, 0.025, 50, 5.0, 0.05, 20, 1.0), # Boundary clamp case\n        (1.0, 10.0, 0.010, 5, 1.0, 2.0, 50, 1.0), # Small phase advance\n        (1.0, 500.0, 0.020, 100, 3.0, 1.5, 25, 1.0), # Multiple cycles\n    ]\n\n    results = []\n    for case in test_cases:\n        A, omega, delta_t, N_fast, k, beta, M, y_s0 = case\n        result = run_simulation(A, omega, delta_t, N_fast, k, beta, M, y_s0)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3516676"}]}