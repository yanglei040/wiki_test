{"hands_on_practices": [{"introduction": "理论是实践的基石。在深入研究复杂的内点法实现之前，通过一个简单的例子手工推导和求解核心方程至关重要。这个练习将引导你为对数障碍问题建立拉格朗日函数，推导其 Karush-Kuhn-Tucker (KKT) 条件，并精确求解中心路径上的一个点 ([@problem_id:3453559])。这能帮助你直观地理解算法追踪的“中心路径”是如何被数学定义的。", "problem": "考虑用于稀疏恢复的等式约束凸优化问题，该问题旨在在线性约束下最小化$\\ell_1$-范数：最小化 $\\|x\\|_{1}$，约束条件为 $A x = b$。压缩感知中的一个标准技巧是引入非负分裂 $(u,v)$，其中 $x = u - v$，$u \\ge 0$，$v \\ge 0$，并将问题重写为最小化 $\\mathbf{1}^{\\top}(u+v)$，约束条件为 $A(u-v) = b$，其中 $\\mathbf{1}$ 表示全1向量。内点法引入一个带参数 $t > 0$ 的对数障碍，并考虑等式约束障碍问题：最小化 $t \\,\\mathbf{1}^{\\top}(u+v) - \\sum_{i} \\ln(u_{i}) - \\sum_{i} \\ln(v_{i})$，约束条件为 $A(u-v) = b$，定义域为 $u > 0$，$v > 0$。Karush–Kuhn–Tucker (KKT) 条件是通过将拉格朗日函数的梯度设为零，并结合原始可行性得到的。\n\n请使用精确算术（无浮点近似）。设 $A \\in \\mathbb{R}^{1 \\times 2}$ 由 $A = [\\,1 \\ \\ 1\\,]$ 给出，$b \\in \\mathbb{R}$ 由 $b = 1$ 给出。对于障碍参数 $t = 1$，从第一性原理推导障碍问题的 KKT 最优性条件，用它们来刻画中心路径点 $(u^{\\star}, v^{\\star}, y^{\\star})$，并精确求解唯一的拉格朗日乘子 $y^{\\star} \\in \\mathbb{R}$（与等式约束相关的对偶变量）。作为合理性检查，请符号化地验证所得的 $(u^{\\star}, v^{\\star})$ 位于内部（$u^{\\star} > 0$，$v^{\\star} > 0$）并且满足 $A(u^{\\star}-v^{\\star}) = b$。\n\n请以 $y^{\\star}$ 的精确封闭形式值提供最终答案。不允许使用小数近似值。", "solution": "该问题要求解在$\\ell_1$最小化中出现的一个特定等式约束障碍问题实例的拉格朗日乘子 $y^{\\star}$ 的精确值。\n\n该问题的一般形式是最小化函数 $f(u,v) = t \\,\\mathbf{1}^{\\top}(u+v) - \\sum_{i} \\ln(u_{i}) - \\sum_{i} \\ln(v_{i})$，约束条件为 $A(u-v) = b$。目标函数的定义域施加了隐式约束 $u > 0$ 和 $v > 0$。\n\n我们给定了以下具体参数：\n- 矩阵 $A \\in \\mathbb{R}^{1 \\times 2}$ 为 $A = [\\,1 \\ \\ 1\\,]$。\n- 向量 $b \\in \\mathbb{R}$ 为 $b = 1$。\n- 障碍参数 $t \\in \\mathbb{R}$ 为 $t = 1$。\n- 优化变量为 $x = \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix} \\in \\mathbb{R}^2$，它们被分裂为 $x = u - v$，其中 $u = \\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix}$ 且 $v = \\begin{pmatrix} v_1 \\\\ v_2 \\end{pmatrix}$。\n\n根据这些具体参数，当 $t=1$ 时，要最小化的目标函数是：\n$$f(u,v) = (u_1 + u_2) + (v_1 + v_2) - \\ln(u_1) - \\ln(u_2) - \\ln(v_1) - \\ln(v_2)$$\n等式约束是：\n$$A(u-v) = [\\,1 \\ \\ 1\\,] \\begin{pmatrix} u_1 - v_1 \\\\ u_2 - v_2 \\end{pmatrix} = (u_1 - v_1) + (u_2 - v_2) = 1$$\n\n为了找到这个约束优化问题的解，我们使用拉格朗日乘子法。拉格朗日函数 $L(u, v, y)$ 定义为：\n$$L(u_1, u_2, v_1, v_2, y) = f(u,v) + y \\left( (u_1 - v_1) + (u_2 - v_2) - 1 \\right)$$\n其中 $y \\in \\mathbb{R}$ 是与等式约束相关的拉格朗日乘子。\n\nKarush-Kuhn-Tucker (KKT) 条件指出，在最优点 $(u^{\\star}, v^{\\star}, y^{\\star})$，拉格朗日函数关于原始变量 $(u,v)$ 的梯度必须为零。我们来计算这些偏导数：\n$$\n\\begin{aligned}\n\\frac{\\partial L}{\\partial u_1} = 1 - \\frac{1}{u_1} + y \\\\\n\\frac{\\partial L}{\\partial u_2} = 1 - \\frac{1}{u_2} + y \\\\\n\\frac{\\partial L}{\\partial v_1} = 1 - \\frac{1}{v_1} - y \\\\\n\\frac{\\partial L}{\\partial v_2} = 1 - \\frac{1}{v_2} - y\n\\end{aligned}\n$$\n将这些导数设为零，得到 KKT 条件的第一部分：\n$$\n\\begin{align}\n1 - \\frac{1}{u_1} + y = 0 \\quad \\implies \\quad \\frac{1}{u_1} = 1+y \\label{eq:1} \\\\\n1 - \\frac{1}{u_2} + y = 0 \\quad \\implies \\quad \\frac{1}{u_2} = 1+y \\label{eq:2} \\\\\n1 - \\frac{1}{v_1} - y = 0 \\quad \\implies \\quad \\frac{1}{v_1} = 1-y \\label{eq:3} \\\\\n1 - \\frac{1}{v_2} - y = 0 \\quad \\implies \\quad \\frac{1}{v_2} = 1-y \\label{eq:4}\n\\end{align}\n$$\n从这些方程中，我们可以用对偶变量 $y$ 来表示原始变量 $u_1, u_2, v_1, v_2$：\n$$u_1 = u_2 = \\frac{1}{1+y}$$\n$$v_1 = v_2 = \\frac{1}{1-y}$$\n障碍问题的定义域要求 $u > 0$ 和 $v > 0$，这意味着对 $i=1,2$ 都有 $u_i > 0$ 和 $v_i > 0$。这对 $y$ 施加了条件：\n$$1+y > 0 \\implies y > -1$$\n$$1-y > 0 \\implies y < 1$$\n因此，拉格朗日乘子 $y$ 必须位于区间 $(-1, 1)$ 内。\n\n最后的 KKT 条件是原始可行性，即原始约束：\n$$(u_1 - v_1) + (u_2 - v_2) = 1$$\n由于 $u_1 = u_2$ 且 $v_1 = v_2$，这可以简化为：\n$$2(u_1 - v_1) = 1$$\n现在我们将 $u_1$ 和 $v_1$ 关于 $y$ 的表达式代入：\n$$2 \\left( \\frac{1}{1+y} - \\frac{1}{1-y} \\right) = 1$$\n为了求解 $y$，我们合并分数：\n$$2 \\left( \\frac{(1-y) - (1+y)}{(1+y)(1-y)} \\right) = 1$$\n$$2 \\left( \\frac{-2y}{1-y^2} \\right) = 1$$\n$$\\frac{-4y}{1-y^2} = 1$$\n$$-4y = 1 - y^2$$\n重新排列各项，得到一个关于 $y$ 的二次方程：\n$$y^2 - 4y - 1 = 0$$\n我们使用二次公式 $y = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 来求解这个方程：\n$$y = \\frac{-(-4) \\pm \\sqrt{(-4)^2 - 4(1)(-1)}}{2(1)} = \\frac{4 \\pm \\sqrt{16+4}}{2} = \\frac{4 \\pm \\sqrt{20}}{2}$$\n因为 $\\sqrt{20} = \\sqrt{4 \\times 5} = 2\\sqrt{5}$，我们有：\n$$y = \\frac{4 \\pm 2\\sqrt{5}}{2} = 2 \\pm \\sqrt{5}$$\n这给出了 $y$ 的两个可能值：$y_A = 2 + \\sqrt{5}$ 和 $y_B = 2 - \\sqrt{5}$。我们必须选择满足条件 $-1 < y < 1$ 的解。\n$\\sqrt{5}$ 的值约等于 $2.236$。\n- 对于 $y_A = 2 + \\sqrt{5}$：$y_A \\approx 2 + 2.236 = 4.236$。该值在区间 $(-1, 1)$ 之外，因此不是有效解。\n- 对于 $y_B = 2 - \\sqrt{5}$：$y_B \\approx 2 - 2.236 = -0.236$。该值位于区间 $(-1, 1)$ 之内。\n\n因此，唯一的拉格朗日乘子是 $y^{\\star} = 2 - \\sqrt{5}$。\n\n作为合理性检查，我们验证所得的原始变量 $(u^{\\star}, v^{\\star})$ 位于可行集的内部并且满足约束条件。\n最优原始变量由以下公式给出：\n$$u^{\\star}_1 = u^{\\star}_2 = \\frac{1}{1+y^{\\star}} = \\frac{1}{1+(2-\\sqrt{5})} = \\frac{1}{3-\\sqrt{5}}$$\n对分母进行有理化得到：\n$$u^{\\star}_1 = u^{\\star}_2 = \\frac{1}{3-\\sqrt{5}} \\cdot \\frac{3+\\sqrt{5}}{3+\\sqrt{5}} = \\frac{3+\\sqrt{5}}{9-5} = \\frac{3+\\sqrt{5}}{4}$$\n由于 $3 > 0$ 且 $\\sqrt{5} > 0$，我们有 $u^{\\star}_1, u^{\\star}_2 > 0$。\n\n$$v^{\\star}_1 = v^{\\star}_2 = \\frac{1}{1-y^{\\star}} = \\frac{1}{1-(2-\\sqrt{5})} = \\frac{1}{\\sqrt{5}-1}$$\n对分母进行有理化得到：\n$$v^{\\star}_1 = v^{\\star}_2 = \\frac{1}{\\sqrt{5}-1} \\cdot \\frac{\\sqrt{5}+1}{\\sqrt{5}+1} = \\frac{\\sqrt{5}+1}{5-1} = \\frac{\\sqrt{5}+1}{4}$$\n由于 $\\sqrt{5} > 0$，我们有 $v^{\\star}_1, v^{\\star}_2 > 0$。\n点 $(u^{\\star}, v^{\\star})$ 确实在可行定义域的内部。\n\n最后，我们验证等式约束 $A(u^{\\star}-v^{\\star})=b$，即 $(u^{\\star}_1 - v^{\\star}_1) + (u^{\\star}_2 - v^{\\star}_2) = 1$。\n$$u^{\\star}_1 - v^{\\star}_1 = \\frac{3+\\sqrt{5}}{4} - \\frac{\\sqrt{5}+1}{4} = \\frac{3+\\sqrt{5}-(\\sqrt{5}+1)}{4} = \\frac{2}{4} = \\frac{1}{2}$$\n因此，$(u^{\\star}_1 - v^{\\star}_1) + (u^{\\star}_2 - v^{\\star}_2) = \\frac{1}{2} + \\frac{1}{2} = 1$。\n约束条件得到满足。所有检查都证实了解的有效性。唯一的拉格朗日乘子是 $y^{\\star} = 2-\\sqrt{5}$。", "answer": "$$\\boxed{2 - \\sqrt{5}}$$", "id": "3453559"}, {"introduction": "掌握了中心路径的基本概念后，一个实际的问题是：算法如何开始？任何迭代方法都需要一个好的起点。这个问题展示了一种为$\\ell_1$最小化问题初始化内点法的标准策略：首先求解一个相关的$\\ell_2$正则化最小二乘问题，然后将其解映射为严格内点 ([@problem_id:3453608])。这个练习揭示了不同优化问题之间的巧妙联系，并解决了寻找严格可行初始点的挑战。", "problem": "考虑基追踪问题，该问题通过在满足线性等式约束 $A x = b$ 的条件下最小化$\\ell_1$-范数来寻求稀疏解，即 $\\min \\|x\\|_{1}$。其标准的内点法 (IPM) 形式通过变量分裂 $x = u - v$（其中 $u \\ge 0$ 且 $v \\ge 0$）来构建。一种常见的方法是，通过求解一个$\\ell_{2}$-正则化最小二乘问题来获得一个初始原始解，然后将该解映射为与非负约束相关的对数障碍函数的严格内点，从而初始化用于此$\\ell_{1}$问题的内点法。\n\n从以下数据开始：\n- $A \\in \\mathbb{R}^{2 \\times 3}$ 由 $A = \\begin{bmatrix} 1  0  1 \\\\ 0  1  1 \\end{bmatrix}$ 给出，\n- $b \\in \\mathbb{R}^{2}$ 由 $b = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$ 给出，\n- 正则化参数 $\\gamma = \\tfrac{1}{2}$。\n\n从基本原理出发，按如下方式构造初始化：\n1. 计算严格凸问题 $\\min_{x \\in \\mathbb{R}^{3}} \\tfrac{1}{2}\\|A x - b\\|_{2}^{2} + \\gamma \\|x\\|_{2}^{2}$ 的唯一最小化子 $x_{0} \\in \\mathbb{R}^{3}$。\n2. 通过标准分裂和一个均匀位移 $\\tau = 1$ 将 $x_{0}$ 映射到严格正的 $(u_{0}, v_{0}) \\in \\mathbb{R}_{++}^{3} \\times \\mathbb{R}_{++}^{3}$，即 $u_{0} = (x_{0})_{+} + \\tau \\mathbf{1}$ 和 $v_{0} = (x_{0})_{-} + \\tau \\mathbf{1}$，其中 $(x)_{+}$ 和 $(x)_{-}$ 是 $x$ 的逐分量正部和负部，$\\mathbf{1} \\in \\mathbb{R}^{3}$ 是全1向量。\n3. 对于分裂$\\ell_1$形式的对数障碍 KKT 系统，为等式约束 $A(u - v) = b$ 引入对偶变量 $y \\in \\mathbb{R}^{2}$，为 $(u,v) \\ge 0$ 引入非负对偶松弛变量 $(s,t) \\in \\mathbb{R}^{3} \\times \\mathbb{R}^{3}$。设 $y_{0} = 0$，并通过逐分量地强制一个共同的互补水平 $\\mu > 0$（即 $s_{0,i} = \\mu/u_{0,i}$ 和 $t_{0,i} = \\mu/v_{0,i}$）来选择“近中心”的 $(s_{0}, t_{0})$。将对偶可行性残差的平方定义为\n$$\nS(\\mu) \\;\\equiv\\; \\|\\,\\mathbf{1} - A^{\\top} y_{0} - s_{0}\\|_{2}^{2} \\;+\\; \\|\\,\\mathbf{1} + A^{\\top} y_{0} - t_{0}\\|_{2}^{2}.\n$$\n根据第一性原理，以闭合形式确定最小化 $S(\\mu)$ 的唯一 $\\mu^{\\star} > 0$，并精确表示 $S(\\mu^{\\star})$。\n4. 将等式约束的原始可行性残差定义为 $r_{p} \\equiv A(u_{0} - v_{0}) - b$。通过单个标量\n$$\nD \\;\\equiv\\; \\sqrt{\\,\\|r_{p}\\|_{2}^{2} \\;+\\; S(\\mu^{\\star})\\,}.\n$$\n来量化初始化的总可行性距离。\n\n对于上述数据和指定的构造方法，精确计算 $D$。以单个精确表达式给出最终答案。不要近似；无需四舍五入。", "solution": "该问题要求计算一个标量值 $D$，该值用于量化应用于$\\ell_1$最小化问题的内点法初始点的可行性距离。计算过程按四个规定的步骤进行。\n\n问题由矩阵 $A \\in \\mathbb{R}^{2 \\times 3}$、向量 $b \\in \\mathbb{R}^{2}$ 和正则化参数 $\\gamma$ 指定：\n$$A = \\begin{bmatrix} 1  0  1 \\\\ 0  1  1 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}, \\quad \\gamma = \\frac{1}{2}$$\n\n**步骤 1：计算初始原始猜测值 $x_0$**\n我们必须找到目标函数 $f(x) = \\frac{1}{2}\\|A x - b\\|_{2}^{2} + \\gamma \\|x\\|_{2}^{2}$ 的唯一最小化子 $x_0$。当 $\\gamma > 0$ 时，该函数是严格凸的。通过将关于 $x$ 的梯度设为零来找到最小值。\n$$f(x) = \\frac{1}{2}(Ax - b)^{\\top}(Ax - b) + \\gamma x^{\\top}x = \\frac{1}{2}x^{\\top}A^{\\top}Ax - x^{\\top}A^{\\top}b + \\frac{1}{2}b^{\\top}b + \\gamma x^{\\top}x$$\n梯度为：\n$$\\nabla_x f(x) = A^{\\top}Ax - A^{\\top}b + 2\\gamma x$$\n令 $\\nabla_x f(x) = 0$ 可得正规方程：\n$$(A^{\\top}A + 2\\gamma I)x = A^{\\top}b$$\n解为 $x_0 = (A^{\\top}A + 2\\gamma I)^{-1} A^{\\top}b$。我们计算必要的组成部分。当 $\\gamma = \\frac{1}{2}$ 时，我们有 $2\\gamma = 1$。\n$$A^{\\top} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ 1  1 \\end{bmatrix}$$\n$$A^{\\top}A = \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ 1  1 \\end{bmatrix} \\begin{bmatrix} 1  0  1 \\\\ 0  1  1 \\end{bmatrix} = \\begin{bmatrix} 1  0  1 \\\\ 0  1  1 \\\\ 1  1  2 \\end{bmatrix}$$\n需要求逆的矩阵是 $M = A^{\\top}A + I$：\n$$M = \\begin{bmatrix} 1  0  1 \\\\ 0  1  1 \\\\ 1  1  2 \\end{bmatrix} + \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix} = \\begin{bmatrix} 2  0  1 \\\\ 0  2  1 \\\\ 1  1  3 \\end{bmatrix}$$\n$M$ 的行列式为 $\\det(M) = 2(2 \\cdot 3 - 1 \\cdot 1) - 0 + 1(0 \\cdot 1 - 2 \\cdot 1) = 10 - 2 = 8$。\n逆矩阵为 $M^{-1} = \\frac{1}{8} \\begin{bmatrix} 5  1  -2 \\\\ 1  5  -2 \\\\ -2  -2  4 \\end{bmatrix}$。\n等式右边是：\n$$A^{\\top}b = \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ 1  1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 2 \\end{bmatrix}$$\n现在我们可以计算 $x_0$：\n$$x_0 = M^{-1} (A^{\\top}b) = \\frac{1}{8} \\begin{bmatrix} 5  1  -2 \\\\ 1  5  -2 \\\\ -2  -2  4 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 1 \\\\ 2 \\end{bmatrix} = \\frac{1}{8} \\begin{bmatrix} 5(1) + 1(1) - 2(2) \\\\ 1(1) + 5(1) - 2(2) \\\\ -2(1) - 2(1) + 4(2) \\end{bmatrix} = \\frac{1}{8} \\begin{bmatrix} 2 \\\\ 2 \\\\ 4 \\end{bmatrix} = \\begin{bmatrix} 1/4 \\\\ 1/4 \\\\ 1/2 \\end{bmatrix}$$\n\n**步骤 2：将 $x_0$ 映射到严格正的 $(u_0, v_0)$**\n映射由 $u_{0} = (x_{0})_{+} + \\tau \\mathbf{1}$ 和 $v_{0} = (x_{0})_{-} + \\tau \\mathbf{1}$ 定义，其中均匀位移 $\\tau = 1$ 且 $\\mathbf{1}$ 是 $\\mathbb{R}^3$ 中的全1向量。由于 $x_0$ 的所有分量都是正的，其正部为 $(x_0)_+ = x_0$，负部为 $(x_0)_- = \\mathbf{0}$。\n$$u_0 = x_0 + 1 \\cdot \\mathbf{1} = \\begin{bmatrix} 1/4 \\\\ 1/4 \\\\ 1/2 \\end{bmatrix} + \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 5/4 \\\\ 5/4 \\\\ 3/2 \\end{bmatrix}$$\n$$v_0 = \\mathbf{0} + 1 \\cdot \\mathbf{1} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}$$\n\n**步骤 3：确定最优障碍参数 $\\mu^{\\star}$ 和 $S(\\mu^{\\star})$**\n对偶可行性残差的平方为 $S(\\mu) = \\|\\mathbf{1} - A^{\\top} y_{0} - s_{0}\\|_{2}^{2} + \\|\\mathbf{1} + A^{\\top} y_{0} - t_{0}\\|_{2}^{2}$。给定 $y_0 = 0$，这简化为 $S(\\mu) = \\|\\mathbf{1} - s_{0}\\|_{2}^{2} + \\|\\mathbf{1} - t_{0}\\|_{2}^{2}$。\n松弛变量选择为 $s_{0,i} = \\mu/u_{0,i}$ 和 $t_{0,i} = \\mu/v_{0,i}$。以向量形式，令 $p = (1/u_{0,1}, \\dots, 1/u_{0,n})^{\\top}$ 和 $q = (1/v_{0,1}, \\dots, 1/v_{0,n})^{\\top}$。则 $s_0 = \\mu p$ 且 $t_0 = \\mu q$。\n$$S(\\mu) = \\|\\mathbf{1} - \\mu p\\|_{2}^{2} + \\|\\mathbf{1} - \\mu q\\|_{2}^{2} = (\\mathbf{1}^{\\top}\\mathbf{1} - 2\\mu\\mathbf{1}^{\\top}p + \\mu^2 p^{\\top}p) + (\\mathbf{1}^{\\top}\\mathbf{1} - 2\\mu\\mathbf{1}^{\\top}q + \\mu^2 q^{\\top}q)$$\n$S(\\mu) = 2n - 2\\mu(\\mathbf{1}^{\\top}p + \\mathbf{1}^{\\top}q) + \\mu^2(p^{\\top}p + q^{\\top}q)$，其中 $n=3$。对 $\\mu$ 求导并令其为零，得到最小化子 $\\mu^{\\star}$：\n$$\\frac{dS}{d\\mu} = -2(\\mathbf{1}^{\\top}p + \\mathbf{1}^{\\top}q) + 2\\mu(p^{\\top}p + q^{\\top}q) = 0 \\implies \\mu^{\\star} = \\frac{\\mathbf{1}^{\\top}p + \\mathbf{1}^{\\top}q}{p^{\\top}p + q^{\\top}q}$$\n我们从 $u_0$ 和 $v_0$ 计算必要的量：\n$$p = \\begin{bmatrix} 4/5 \\\\ 4/5 \\\\ 2/3 \\end{bmatrix}, \\quad q = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}$$\n$\\mathbf{1}^{\\top}p = \\frac{4}{5} + \\frac{4}{5} + \\frac{2}{3} = \\frac{8}{5} + \\frac{2}{3} = \\frac{24+10}{15} = \\frac{34}{15}$。\n$\\mathbf{1}^{\\top}q = 1+1+1=3$。\n$\\mu^{\\star}$ 的分子：$\\mathbf{1}^{\\top}p + \\mathbf{1}^{\\top}q = \\frac{34}{15} + 3 = \\frac{79}{15}$。\n$p^{\\top}p = \\|p\\|_2^2 = (\\frac{4}{5})^2 + (\\frac{4}{5})^2 + (\\frac{2}{3})^2 = \\frac{16}{25} + \\frac{16}{25} + \\frac{4}{9} = \\frac{32}{25} + \\frac{4}{9} = \\frac{288+100}{225} = \\frac{388}{225}$。\n$q^{\\top}q = \\|q\\|_2^2 = 1^2 + 1^2 + 1^2 = 3$。\n$\\mu^{\\star}$ 的分母：$p^{\\top}p + q^{\\top}q = \\frac{388}{225} + 3 = \\frac{388+675}{225} = \\frac{1063}{225}$。\n$$\\mu^{\\star} = \\frac{79/15}{1063/225} = \\frac{79}{15} \\cdot \\frac{225}{1063} = \\frac{79 \\cdot 15}{1063} = \\frac{1185}{1063}$$\n将 $\\mu^{\\star}$ 代回 $S(\\mu)$ 的表达式中，得到最小值 $S(\\mu^{\\star})$：\n$$S(\\mu^{\\star}) = 2n - \\frac{(\\mathbf{1}^{\\top}p + \\mathbf{1}^{\\top}q)^2}{p^{\\top}p + q^{\\top}q} = 6 - \\frac{(79/15)^2}{1063/225} = 6 - \\frac{79^2/225}{1063/225} = 6 - \\frac{79^2}{1063}$$\n$$S(\\mu^{\\star}) = 6 - \\frac{6241}{1063} = \\frac{6 \\cdot 1063 - 6241}{1063} = \\frac{6378 - 6241}{1063} = \\frac{137}{1063}$$\n\n**步骤 4：计算总可行性距离 $D$**\n原始可行性残差为 $r_p = A(u_0 - v_0) - b$。从步骤 2，我们知道 $u_0 - v_0 = x_0$。\n$$r_p = A x_0 - b$$\n$$A x_0 = \\begin{bmatrix} 1  0  1 \\\\ 0  1  1 \\end{bmatrix} \\begin{bmatrix} 1/4 \\\\ 1/4 \\\\ 1/2 \\end{bmatrix} = \\begin{bmatrix} 1/4 + 1/2 \\\\ 1/4 + 1/2 \\end{bmatrix} = \\begin{bmatrix} 3/4 \\\\ 3/4 \\end{bmatrix}$$\n$$r_p = \\begin{bmatrix} 3/4 \\\\ 3/4 \\end{bmatrix} - \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} -1/4 \\\\ -1/4 \\end{bmatrix}$$\n原始残差的范数平方为：\n$$\\|r_p\\|_2^2 = \\left(-\\frac{1}{4}\\right)^2 + \\left(-\\frac{1}{4}\\right)^2 = \\frac{1}{16} + \\frac{1}{16} = \\frac{2}{16} = \\frac{1}{8}$$\n最后，总可行性距离 $D$ 由下式给出：\n$$D = \\sqrt{\\|r_p\\|_2^2 + S(\\mu^{\\star})} = \\sqrt{\\frac{1}{8} + \\frac{137}{1063}}$$\n为合并各项，我们找到一个公分母：\n$$D = \\sqrt{\\frac{1063 + 8 \\cdot 137}{8 \\cdot 1063}} = \\sqrt{\\frac{1063 + 1096}{8504}} = \\sqrt{\\frac{2159}{8504}}$$", "answer": "$$\\boxed{\\sqrt{\\frac{2159}{8504}}}$$", "id": "3453608"}, {"introduction": "最终的挑战在于构建一个完整且稳健的求解器。这个练习要求你实现一个完整的、更具普适性的非可行初始点原始-对偶预测-校正方法 ([@problem_id:3453597])。它将迫使你面对并解决在实践中至关重要的数值问题，如退化和病态，并引入对角正则化等关键技术来确保算法的稳定性和可靠性。", "problem": "考虑压缩感知中的基追踪凸优化问题：在精确线性测量的约束下，最小化信号的$\\ell_1$-范数。其标准形式为最小化目标函数 $\\,\\|x\\|_{1}\\,$，约束条件为 $\\,A x = b\\,$，其中 $\\,A \\in \\mathbb{R}^{m \\times n}\\,$ 和 $\\,b \\in \\mathbb{R}^{m}\\,$ 是给定的。目标是实现一个不可行原始-对偶内点法，以便在存在退化和近退化的情况下鲁棒地解决此问题。\n\n从以下基本原理出发：\n- $\\ell_1$-范数最小化问题可以通过将变量分裂为非负部分，从而重构为一个线性规划：将 $\\,x\\,$ 表示为 $\\,x = x^{+} - x^{-}\\,$，其中 $\\,x^{+} \\ge 0\\,$ 且 $\\,x^{-} \\ge 0\\,$，并在线性测量约束 $\\,A(x^{+} - x^{-}) = b\\,$ 下最小化 $\\,\\mathbf{1}^{\\top}(x^{+} + x^{-})\\,$。\n- 用于线性规划的成熟内点法方法论，该方法使用对数障碍函数和原始-对偶牛顿更新来沿中心路径进行迭代，并结合 KKT (Karush–Kuhn–Tucker) 条件。\n- 数值鲁棒性原理：对病态法方程进行正则化，以及采用分步到边界线搜索来保持松弛变量和原始变量的正性。\n\n您的实现必须使用变量分裂线性规划。记 $\\,z = \\begin{bmatrix}x^{+} \\\\ x^{-}\\end{bmatrix} \\in \\mathbb{R}^{2n}\\,$，$\\,c = \\mathbf{1}_{2n}\\,$，以及 $\\,G = [A,\\,-A] \\in \\mathbb{R}^{m \\times 2n}\\,$。原始问题是在约束 $\\,G z = b\\,$ 和 $\\,z \\ge 0\\,$ 下最小化 $\\,c^{\\top} z\\,$。对偶变量为 $\\,y \\in \\mathbb{R}^{m}\\,$，松弛变量为 $\\,s \\in \\mathbb{R}^{2n}\\,$，满足 $\\,G^{\\top} y + s = c\\,$ 和 $\\,s \\ge 0\\,$。设计一个不可行原始-对偶内点法，该方法：\n- 从严格为正的原始变量和对偶松弛变量 $\\,z > 0\\,$, $\\,s > 0\\,$ 以及任意的 $\\,y\\,$ 开始。\n- 使用预测-校正策略，该策略首先将互补性驱动至零（仿射缩放预测步），然后应用由当前互补间隙决定的中心化校正步，以保持与中心路径的邻近性。\n- 基于对数障碍公式的KKT条件，推导并求解原始-对偶牛顿系统。仔细消去变量，以获得关于 $\\,y\\,$ 的对称正定法方程。实现该法方程的对角正则化，以处理系统变得病态或奇异的退化或近退化情况。\n- 采用分步到边界的步长规则，以在每次更新后保持 $\\,z\\,$ 和 $\\,s\\,$ 严格为正。使用一个严格小于 $\\,1\\,$ 的统一分数参数来确保数值稳定性。\n- 当原始残差范数 $\\,\\|G z - b\\|_{2}\\,$、对偶残差范数 $\\,\\|G^{\\top} y + s - c\\|_{2}\\,$ 和互补间隙 $\\,z^{\\top} s\\,$ 同时低于一个小的容差时终止。\n\n从第一性原理出发，推导您算法中使用的原始-对偶牛顿方程。解释退化和近退化如何影响线性系统的条件数和迭代点的行为，并论证您选择的数值保障措施的合理性。\n\n测试套件：\n为以下四个由矩阵 $\\,A^{(i)}\\,$ 和向量 $\\,b^{(i)}\\,$ 指定的测试案例实现并运行您的求解器。在所有案例中，报告计算出的解 $\\,x^{(i)}\\,$ 及相关的原始-对偶变量 $\\,z^{(i)}\\,$, $\\,s^{(i)}\\,$ 的以下三个量：\n- 目标函数值 $\\,c^{\\top} z^{(i)}\\,$，\n- 原始残差范数 $\\,\\|A^{(i)} x^{(i)} - b^{(i)}\\|_{2}\\,$，\n- 互补间隙 $\\,\\left(z^{(i)}\\right)^{\\top} s^{(i)}\\,$。\n\n测试案例如下：\n- 案例 $\\,1\\,$ (良态，稀疏基准解)：令 $\\,A^{(1)} \\in \\mathbb{R}^{3 \\times 5}\\,$ 为\n$$\nA^{(1)} = \\begin{bmatrix}\n1  0  0  0  2 \\\\\n0  1  0  2  0 \\\\\n0  0  1  1  1\n\\end{bmatrix}, \\quad\nb^{(1)} = \\begin{bmatrix} 1 \\\\ 0 \\\\ 2 \\end{bmatrix}.\n$$\n- 案例 $\\,2\\,$ (退化，秩亏测量，有多个最优解)：令 $\\,A^{(2)} \\in \\mathbb{R}^{2 \\times 4}\\,$ 为\n$$\nA^{(2)} = \\begin{bmatrix}\n1  1  1  1 \\\\\n0  0  0  0\n\\end{bmatrix}, \\quad\nb^{(2)} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}.\n$$\n- 案例 $\\,3\\,$ (近退化，行向量近似线性相关)：令 $\\,A^{(3)} \\in \\mathbb{R}^{3 \\times 5}\\,$ 为\n$$\nA^{(3)} = \\begin{bmatrix}\n1  0  0  0  0 \\\\\n0  1  10^{-6}  0  0 \\\\\n0  1  0  0  0\n\\end{bmatrix}, \\quad\nb^{(3)} = \\begin{bmatrix} 0 \\\\ 1 \\\\ 1 \\end{bmatrix}.\n$$\n- 案例 $\\,4\\,$ (边界解，零测量值)：令 $\\,A^{(4)} \\in \\mathbb{R}^{3 \\times 5}\\,$ 为\n$$\nA^{(4)} = \\begin{bmatrix}\n2  -1  0  1  0 \\\\\n0  1  -2  0  1 \\\\\n1  0  0  0  0\n\\end{bmatrix}, \\quad\nb^{(4)} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}.\n$$\n\n您的程序必须实现上述的不可行原始-对偶内点法，并生成单行输出，该输出汇总了四个案例的结果，形式为包含在方括号中的逗号分隔列表，并按案例和指标排序：\n$$\n\\big[\\,c^{\\top} z^{(1)}, \\ \\|A^{(1)} x^{(1)} - b^{(1)}\\|_{2}, \\ (z^{(1)})^{\\top} s^{(1)}, \\ c^{\\top} z^{(2)}, \\ \\|A^{(2)} x^{(2)} - b^{(2)}\\|_{2}, \\ (z^{(2)})^{\\top} s^{(2)}, \\ c^{\\top} z^{(3)}, \\ \\|A^{(3)} x^{(3)} - b^{(3)}\\|_{2}, \\ (z^{(3)})^{\\top} s^{(3)}, \\ c^{\\top} z^{(4)}, \\ \\|A^{(4)} x^{(4)} - b^{(4)}\\|_{2}, \\ (z^{(4)})^{\\top} s^{(4)}\\,\\big].\n$$\n该问题不涉及物理单位；所有量均为无量纲实数。输出值必须是浮点数。程序不得读取任何输入，并且除了要求的单行输出外，不得打印任何其他文本。请精确使用指定的运行时环境。", "solution": "### 1. 问题建模与线性规划重构\n\n核心问题是基追踪：\n$$\n\\text{minimize} \\quad \\|x\\|_1 \\quad \\text{subject to} \\quad Ax = b\n$$\n其中 $x \\in \\mathbb{R}^n$，$A \\in \\mathbb{R}^{m \\times n}$，$b \\in \\mathbb{R}^m$。$\\ell_1$范数定义为 $\\|x\\|_1 = \\sum_{i=1}^n |x_i|$。这是一个凸优化问题。\n\n为了使用线性规划 (LP) 方法求解，我们引入一种标准的变量分裂技术。我们将 $x$ 表示为两个非负向量的差，$x = x^+ - x^-$，其中 $x^+ \\ge 0$ 且 $x^- \\ge 0$。$\\ell_1$范数目标函数可以写成 $\\|x\\|_1 = \\sum_i (x_i^+ + x_i^-) = \\mathbf{1}^\\top (x^+ + x^-)$，其中 $\\mathbf{1}$ 是全一向量。这会得到以下线性规划：\n$$\n\\begin{align*}\n\\text{minimize} \\quad  \\mathbf{1}^\\top x^+ + \\mathbf{1}^\\top x^- \\\\\n\\text{subject to} \\quad  A(x^+ - x^-) = b \\\\\n x^+ \\ge 0, \\quad x^- \\ge 0\n\\end{align*}\n$$\n为简化记号，我们定义一个新的变量向量 $z = \\begin{bmatrix} x^+ \\\\ x^- \\end{bmatrix} \\in \\mathbb{R}^{2n}$，一个成本向量 $c = \\mathbf{1}_{2n}$，以及一个约束矩阵 $G = [A, -A] \\in \\mathbb{R}^{m \\times 2n}$。该线性规划，我们称之为原始问题，变为：\n$$\n\\text{(P)} \\quad \\text{minimize} \\quad c^\\top z \\quad \\text{subject to} \\quad Gz = b, \\quad z \\ge 0\n$$\n对应的对偶问题是：\n$$\n\\text{(D)} \\quad \\text{maximize} \\quad b^\\top y \\quad \\text{subject to} \\quad G^\\top y + s = c, \\quad s \\ge 0\n$$\n其中 $y \\in \\mathbb{R}^m$ 是与等式约束相关的对偶变量，$s \\in \\mathbb{R}^{2n}$ 是对偶松弛变量。\n\n### 2. 原始-对偶内点法\n\n我们开发一个不可行原始-对偶 IPM，它不要求初始迭代点是可行的（即，$Gz=b$ 不必成立）。该方法迭代地改进原始-对偶变量 $(z, y, s)$ 以满足 Karush-Kuhn-Tucker (KKT) 最优性条件：\n1.  **原始可行性**: $Gz - b = 0$\n2.  **对偶可行性**: $G^\\top y + s - c = 0$\n3.  **互补松弛性**: $z_i s_i = 0$ for all $i=1, \\dots, 2n$\n4.  **非负性**: $z \\ge 0, s \\ge 0$\n\nIPM 的核心思想是用一个光滑近似来取代严格的非负性和互补松弛性条件。我们将一个对数障碍函数引入原始目标函数，并“松弛”互补条件为 $z_i s_i = \\tau > 0$，其中 $\\tau$ 是一个逐渐趋于零的障碍参数。这个扰动问题的 KKT 条件定义了“中心路径”：\n$$\n\\begin{align*}\nGz = b \\\\\nG^\\top y + s = c \\\\\nZSe = \\tau e\n\\end{align*}\n$$\n其中 $Z = \\text{diag}(z)$，$S = \\text{diag}(s)$，$e$ 是全一向量。我们使用牛顿法来寻找一个朝向中心路径上某点的步长 $(\\Delta z, \\Delta y, \\Delta s)$。对于一个不可行的起始点，用于搜索方向的牛顿系统通过线性化 KKT 条件推导得出：\n$$\n\\begin{bmatrix}\n0  & G & 0 \\\\\nG^\\top & 0 & I \\\\\nS & 0 & Z\n\\end{bmatrix}\n\\begin{bmatrix}\n\\Delta y \\\\\n\\Delta z \\\\\n\\Delta s\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-r_b \\\\\n-r_c \\\\\n\\text{rhs}_z\n\\end{bmatrix}\n$$\n其中 $r_b = Gz - b$ 和 $r_c = G^\\top y + s - c$ 分别是原始残差和对偶残差。\n\n### 3. 预测-校正策略与法方程\n\n我们采用 Mehrotra 的预测-校正策略来改进性能。每个迭代包含两个阶段：\n\n**a) 预测（仿射缩放）步：** 首先，我们通过将目标互补性设为零 ($\\tau=0$) 来计算一个“仿射”步 $(\\Delta z_{aff}, \\Delta y_{aff}, \\Delta s_{aff})$。互补方程的右端项是 $\\text{rhs}_z = -ZSe$。\n\n**b) 校正步：** 我们使用仿射步来估计我们能多接近边界，并计算一个中心化参数 $\\sigma$。一个常见的启发式方法是 $\\sigma = (\\mu_{aff} / \\mu)^3$，其中 $\\mu = z^\\top s / (2n)$ 是当前的对偶间隙，而 $\\mu_{aff}$ 是在走完一个完整的仿射步后的间隙。\n最终的搜索方向 $(\\Delta z, \\Delta y, \\Delta s)$ 随后使用一个“校正后”的右端项来计算，该右端项包含一个中心化项和一个二阶校正项：$\\text{rhs}_z = \\sigma\\mu e - ZSe - \\Delta Z_{aff} \\Delta S_{aff} e$。\n\n为了高效地求解牛顿系统，我们消去 $\\Delta z$ 和 $\\Delta s$ 来获得关于 $\\Delta y$ 的**法方程**：\n$$\n(G D^2 G^\\top) \\Delta y = \\text{rhs}_y\n$$\n其中 $D^2 = S^{-1}Z$ 是一个对角矩阵，其元素为 $D_{ii}^2 = z_i/s_i$。右端项推导如下：\n$$\n\\text{rhs}_y = -r_b - G S^{-1}(\\text{rhs}_z - Z r_c)\n$$\n一旦找到 $\\Delta y$，就可以通过回代恢复 $\\Delta s$ 和 $\\Delta z$：\n$$\n\\begin{align*}\n\\Delta s = -r_c - G^\\top \\Delta y \\\\\n\\Delta z = S^{-1}(\\text{rhs}_z - Z\\Delta s)\n\\end{align*}\n$$\n\n### 4. 数值鲁棒性：正则化与线搜索\n\n**退化与正则化：** 当矩阵 $A$（以及 $G$）是秩亏的或其行/列近似线性相关时，就会出现退化。在这种情况下，法方程矩阵 $M = G D^2 G^\\top$ 会变得奇异或病态，使得牛顿步的计算不稳定或不可能。为了缓解这个问题，我们采用 Tikhonov 正则化，求解一个轻微扰动的系统：\n$$\n(G D^2 G^\\top + \\delta I) \\Delta y = \\text{rhs}_y\n$$\n其中 $\\delta > 0$ 是一个小的正则化参数（例如，$10^{-12}$）。这确保了矩阵总是可逆且良态的，从而稳定了算法。\n\n**分步到边界线搜索：** 在计算出搜索方向后，我们必须确定步长 $\\alpha_{pri}$ 和 $\\alpha_{dual}$ 以保持 $z$ 和 $s$ 的严格正性。我们使用分步到边界规则：\n$$\n\\alpha = \\min(1, \\eta \\cdot \\min_{i: \\Delta v_i < 0} \\{-v_i / \\Delta v_i\\})\n$$\n此规则分别应用于原始变量 $(z, \\Delta z)$ 以获得 $\\alpha_{pri}$，以及对偶松弛变量 $(s, \\Delta s)$ 以获得 $\\alpha_{dual}$。参数 $\\eta \\in (0, 1)$（例如，$\\eta=0.995$）将步长从正象限的边界拉回，防止变量变为零，并确保数值稳定性。最终的更新是：\n$$\nz \\leftarrow z + \\alpha_{pri} \\Delta z, \\quad s \\leftarrow s + \\alpha_{dual} \\Delta s, \\quad y \\leftarrow y + \\alpha_{dual} \\Delta y\n$$\n当原始残差和对偶残差的范数以及总互补间隙 $z^\\top s$ 都低于指定的容差时，算法终止。", "answer": "```python\nimport numpy as np\n\ndef compute_step_length(v, dv, eta):\n    \"\"\"\n    Computes the step length alpha for an update v + alpha*dv to maintain v > 0.\n    The rule is alpha = min(1.0, eta * min_{i | dv_i < 0} {-v_i / dv_i}).\n    If no element of dv is negative, the step is unconstrained and alpha is 1.0.\n\n    Args:\n        v (np.ndarray): The current vector.\n        dv (np.ndarray): The update direction vector.\n        eta (float): The fraction-to-the-boundary parameter (0 < eta < 1).\n\n    Returns:\n        float: The computed step length alpha.\n    \"\"\"\n    alpha = 1.0\n    blocking_indices = dv < 0\n    if np.any(blocking_indices):\n        ratios = -v[blocking_indices] / dv[blocking_indices]\n        alpha = min(1.0, eta * np.min(ratios))\n    return alpha\n\ndef solve_l1_ipm(A, b, tol=1e-8, max_iter=100, eta=0.995, reg_delta=1e-12):\n    \"\"\"\n    Solves the l1 minimization problem: min ||x||_1 s.t. Ax = b\n    using an infeasible primal-dual interior-point method with a\n    predictor-corrector strategy.\n\n    Args:\n        A (np.ndarray): The m x n measurement matrix.\n        b (np.ndarray): The m x 1 measurement vector.\n        tol (float): Tolerance for convergence.\n        max_iter (int): Maximum number of iterations.\n        eta (float): Fraction-to-boundary parameter for line search.\n        reg_delta (float): Regularization parameter for the normal equations.\n\n    Returns:\n        tuple: (objective value, primal residual norm, complementarity gap).\n    \"\"\"\n    m, n = A.shape\n    \n    # LP Reformulation: min c'z s.t. Gz = b, z >= 0\n    # where z = [x+; x-], c = 1, G = [A, -A]\n    G = np.hstack([A, -A])\n    c = np.ones(2 * n)\n    \n    # Initialization (infeasible start with z > 0, s > 0)\n    z = np.ones(2 * n)\n    s = np.ones(2 * n)\n    y = np.zeros(m)\n    \n    I_m = np.eye(m)\n\n    for _ in range(max_iter):\n        # Calculate residuals and complementarity gap\n        r_b = G @ z - b\n        r_c = G.T @ y + s - c\n        mu = (z @ s) / (2 * n)\n\n        # Check termination criteria\n        primal_res_norm = np.linalg.norm(r_b)\n        dual_res_norm = np.linalg.norm(r_c)\n        gap = z @ s\n        if primal_res_norm < tol and dual_res_norm < tol and gap < tol:\n            break\n\n        # --- Predictor Step (Affine Scaling, tau=0) ---\n        D2_vec = z / s\n        M = G @ (D2_vec[:, None] * G.T) + reg_delta * I_m\n        \n        rhs_y_aff = -r_b - G @ (D2_vec * r_c) + G @ z\n        \n        try:\n            dy_aff = np.linalg.solve(M, rhs_y_aff)\n        except np.linalg.LinAlgError:\n            dy_aff = np.linalg.pinv(M) @ rhs_y_aff\n        \n        ds_aff = -r_c - G.T @ dy_aff\n        dz_aff = -z - D2_vec * ds_aff\n\n        # --- Centering Parameter (Mehrotra's heuristic) ---\n        alpha_p_aff = compute_step_length(z, dz_aff, 1.0)\n        alpha_d_aff = compute_step_length(s, ds_aff, 1.0)\n        \n        mu_aff = ((z + alpha_p_aff * dz_aff) @ (s + alpha_d_aff * ds_aff)) / (2 * n)\n        sigma = (mu_aff / mu)**3\n\n        # --- Corrector and Combined Step ---\n        dzds_aff = dz_aff * ds_aff\n        s_inv_vec = 1.0 / s\n        \n        rhs_z_full = sigma * mu - z * s - dzds_aff\n        rhs_y_full = -r_b - G @ (D2_vec * r_c) - G @ (rhs_z_full * s_inv_vec)\n        \n        try:\n            dy = np.linalg.solve(M, rhs_y_full)\n        except np.linalg.LinAlgError:\n            dy = np.linalg.pinv(M) @ rhs_y_full\n\n        ds = -r_c - G.T @ dy\n        dz = (rhs_z_full - z * ds) * s_inv_vec\n        \n        # --- Line Search ---\n        alpha_p = compute_step_length(z, dz, eta)\n        alpha_d = compute_step_length(s, ds, eta)\n        \n        # --- Update Iterates ---\n        z += alpha_p * dz\n        s += alpha_d * ds\n        y += alpha_d * dy\n    \n    # Extract final results and metrics\n    x = z[:n] - z[n:]\n    obj_val = c @ z\n    final_primal_res_norm = np.linalg.norm(A @ x - b)\n    final_comp_gap = z @ s\n    \n    return obj_val, final_primal_res_norm, final_comp_gap\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the solver, and prints the results in the required format.\n    \"\"\"\n    # Test Case 1\n    A1 = np.array([\n        [1, 0, 0, 0, 2],\n        [0, 1, 0, 2, 0],\n        [0, 0, 1, 1, 1]\n    ], dtype=float)\n    b1 = np.array([1, 0, 2], dtype=float)\n\n    # Test Case 2\n    A2 = np.array([\n        [1, 1, 1, 1],\n        [0, 0, 0, 0]\n    ], dtype=float)\n    b2 = np.array([1, 0], dtype=float)\n\n    # Test Case 3\n    A3 = np.array([\n        [1, 0, 0, 0, 0],\n        [0, 1, 1e-6, 0, 0],\n        [0, 1, 0, 0, 0]\n    ], dtype=float)\n    b3 = np.array([0, 1, 1], dtype=float)\n\n    # Test Case 4\n    A4 = np.array([\n        [2, -1, 0, 1, 0],\n        [0, 1, -2, 0, 1],\n        [1, 0, 0, 0, 0]\n    ], dtype=float)\n    b4 = np.array([0, 0, 0], dtype=float)\n\n    test_cases = [(A1, b1), (A2, b2), (A3, b3), (A4, b4)]\n    \n    all_results = []\n    for A, b in test_cases:\n        # Increase max_iter for more difficult cases if needed\n        obj, pres, cgap = solve_l1_ipm(A, b, max_iter=100)\n        all_results.extend([obj, pres, cgap])\n\n    # Format the output as a single line: [res1,res2,res3,...]\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3453597"}]}