{"hands_on_practices": [{"introduction": "在稀疏优化中，我们经常使用正则化项来促进解的特定结构。组套索（group lasso）正则化项是鼓励变量以组为单位稀疏的有力工具。本练习将引导您从最基本的定义出发，证明组套索惩罚项 $\\sum_j w_j \\|x_{G_j}\\|_2$ 实际上是一个由特定原子集生成的规范函数（gauge function）。通过建立这种联系，我们不仅能更深刻地理解其几何本质，还能运用对偶理论推导出其对偶范数，这在理论分析和算法设计中都至关重要 [@problem_id:3452404]。", "problem": "设 $n \\in \\mathbb{N}$，令 $\\{G_j\\}_{j=1}^{m}$ 是 $\\{1,\\dots,n\\}$ 的一个划分，且对所有 $j \\in \\{1,\\dots,m\\}$ 都有 $w_j>0$。考虑 $\\mathbb{R}^n$ 上的函数 $x \\mapsto \\sum_{j=1}^{m} w_j \\|x_{G_j}\\|_2$，其中 $x_{G_j} \\in \\mathbb{R}^n$ 表示通过保留 $x$ 在 $G_j$ 中的坐标并将所有其他坐标设为 $0$ 所得到的向量。请完全根据凸集的规范函数、支撑函数和示性函数的基本定义进行求解。特别地，仅使用以下内容作为出发点：\n\n- 一个非空、闭、凸、平衡且吸收的集合 $C \\subset \\mathbb{R}^n$ 的规范函数（闵可夫斯基泛函）为 $\\gamma_C(x) \\coloneqq \\inf\\{t>0 : x \\in t C\\}$。\n- 集合 $C$ 的示性函数为 $\\delta_C(x) \\coloneqq 0$（若 $x \\in C$）和 $\\delta_C(x) \\coloneqq +\\infty$（其他情况）。\n- 集合 $C$ 的支撑函数为 $\\sigma_C(y) \\coloneqq \\sup\\{\\langle y,x \\rangle : x \\in C\\}$，它等于 $C$ 的示性函数的芬克尔共轭。\n\n对每个 $j \\in \\{1,\\dots,m\\}$，定义原子集 $A_j \\coloneqq \\{a \\in \\mathbb{R}^n : \\mathrm{supp}(a) \\subseteq G_j,\\ \\|a\\|_2 = 1/w_j\\}$ 以及并集 $A \\coloneqq \\bigcup_{j=1}^{m} A_j$。令 $B \\coloneqq \\mathrm{conv}(A)$ 表示 $A$ 的凸包。从上述定义以及欧几里得内积和范数的性质出发，完成以下任务：\n\n- 证明对所有 $x \\in \\mathbb{R}^n$，规范函数 $\\gamma_B(x)$ 等于 $\\sum_{j=1}^{m} w_j \\|x_{G_j}\\|_2$。\n- 仅使用“凸包的支撑函数等于其生成集上支撑函数的上确界”这一事实，以及“对偶范数是单位球的支撑函数”的定义，推导出 $x \\mapsto \\sum_{j=1}^{m} w_j \\|x_{G_j}\\|_2$ 的对偶范数的闭式解析表达式。\n\n最后，在给定的划分 $G_1=\\{1,2\\}$, $G_2=\\{3,4,5\\}$, $G_3=\\{6,7\\}$ 和权重 $w_1=2$, $w_2=3$, $w_3=7$ 下，计算您推导出的对偶范数在特定点 $y \\in \\mathbb{R}^7$ 的值，其中\n$$\ny=\\big(3,4,2,-1,2,5,12\\big).\n$$\n您的最终答案必须是此对偶范数在该点 $y$ 的值的单个实数。请勿对答案进行四舍五入。", "solution": "我们从规范函数和支撑函数的定义以及欧几里得内积和范数的标准性质开始。对每个 $j \\in \\{1,\\dots,m\\}$，我们定义原子集 $A_j \\coloneqq \\{a \\in \\mathbb{R}^n : \\mathrm{supp}(a) \\subseteq G_j,\\ \\|a\\|_2 = 1/w_j\\}$，并令 $A \\coloneqq \\bigcup_{j=1}^{m} A_j$。令 $B \\coloneqq \\mathrm{conv}(A)$ 表示 $A$ 的凸包。$B$ 的规范函数是 $\\gamma_B(x) \\coloneqq \\inf\\{t>0 : x \\in t B\\}$。在凸分析中，一个标准事实是，中心对称原子集 $A$ 的凸包的规范函数与由 $A$ 导出的所谓原子范数相一致。具体来说，根据凸包的规范函数的定义，我们可以表示为\n$$\n\\gamma_B(x) \\;=\\; \\inf\\Big\\{\\sum_{i=1}^{N} c_i \\;:\\; N \\in \\mathbb{N},\\ c_i \\ge 0,\\ a_i \\in A,\\ x = \\sum_{i=1}^{N} c_i a_i \\Big\\}.\n$$\n我们将证明该规范函数等于 $\\sum_{j=1}^{m} w_j \\|x_{G_j}\\|_2$。\n\n为了证明上界，固定 $x \\in \\mathbb{R}^n$，并对每个 $j \\in \\{1,\\dots,m\\}$ 考虑分组分量 $x_{G_j}$。如果 $x_{G_j} \\neq 0$，定义 $a_j \\in A_j$ 为 $a_j \\coloneqq \\frac{x_{G_j}}{\\|x_{G_j}\\|_2} \\cdot \\frac{1}{w_j}$。注意 $\\mathrm{supp}(a_j) \\subseteq G_j$ 且 $\\|a_j\\|_2 = 1/w_j$，因此 $a_j \\in A_j \\subset A$。令 $c_j \\coloneqq w_j \\|x_{G_j}\\|_2$。那么对每个这样的 $j$，都有 $c_j a_j = x_{G_j}$。如果 $x_{G_j} = 0$，我们设 $c_j = 0$ 并任意选择某个 $a_j \\in A_j$（该选择对求和没有贡献）。对 $j$ 求和可得\n$$\nx \\;=\\; \\sum_{j=1}^{m} x_{G_j} \\;=\\; \\sum_{j=1}^{m} c_j a_j,\n$$\n其中 $\\sum_{j=1}^{m} c_j = \\sum_{j=1}^{m} w_j \\|x_{G_j}\\|_2$。根据 $\\gamma_B(x)$ 定义为这类系数和的下确界，我们得到\n$$\n\\gamma_B(x) \\;\\le\\; \\sum_{j=1}^{m} w_j \\|x_{G_j}\\|_2.\n$$\n\n为了证明下界，考虑任意表示 $x = \\sum_{i=1}^{N} c_i a_i$，其中 $c_i \\ge 0$ 且 $a_i \\in A$。通过定义 $I_j \\coloneqq \\{i \\in \\{1,\\dots,N\\} : a_i \\in A_j\\}$，根据组成员关系对索引集 $\\{1,\\dots,N\\}$ 进行划分。由于不同组的支撑集不相交，投影到坐标 $G_j$ 上可得\n$$\nx_{G_j} \\;=\\; \\sum_{i \\in I_j} c_i a_i,\n$$\n其中每个 $a_i$ 的支撑集都在 $G_j$ 中。应用欧几里得范数的三角不等式以及对 $i \\in I_j$ 有 $\\|a_i\\|_2 = 1/w_j$ 这一事实，我们得到\n$$\n\\|x_{G_j}\\|_2 \\;\\le\\; \\sum_{i \\in I_j} c_i \\|a_i\\|_2 \\;=\\; \\sum_{i \\in I_j} c_i \\cdot \\frac{1}{w_j}.\n$$\n两边同乘以 $w_j$ 并对 $j$ 求和可得\n$$\n\\sum_{j=1}^{m} w_j \\|x_{G_j}\\|_2 \\;\\le\\; \\sum_{j=1}^{m} \\sum_{i \\in I_j} c_i \\;=\\; \\sum_{i=1}^{N} c_i.\n$$\n由于该不等式对任意满足 $a_i \\in A$ 和 $c_i \\ge 0$ 的分解 $x = \\sum_{i=1}^{N} c_i a_i$ 都成立，因此对所有此类表示取下确界意味着\n$$\n\\sum_{j=1}^{m} w_j \\|x_{G_j}\\|_2 \\;\\le\\; \\gamma_B(x).\n$$\n结合上界和下界，证明了\n$$\n\\gamma_B(x) \\;=\\; \\sum_{j=1}^{m} w_j \\|x_{G_j}\\|_2 \\quad \\text{对所有 } x \\in \\mathbb{R}^n.\n$$\n\n我们现在推导对偶范数。根据定义，具有单位球 $B$ 的范数的对偶范数是\n$$\n\\|y\\|_{*} \\;=\\; \\sup\\{\\langle y, x \\rangle : x \\in B\\} \\;=\\; \\sigma_{B}(y),\n$$\n也就是说，单位球 $B$ 的支撑函数。由于 $B = \\mathrm{conv}(A)$，支撑函数满足\n$$\n\\sigma_{B}(y) \\;=\\; \\sup\\{\\langle y, x \\rangle : x \\in \\mathrm{conv}(A)\\} \\;=\\; \\sup\\{\\langle y, a \\rangle : a \\in A\\},\n$$\n这里使用了凸包的支撑函数等于在生成集上内积的上确界这一事实。因为 $A = \\bigcup_{j=1}^{m} A_j$，我们有\n$$\n\\sigma_{B}(y) \\;=\\; \\sup_{j \\in \\{1,\\dots,m\\}} \\ \\sup\\{\\langle y, a \\rangle : a \\in A_j\\}.\n$$\n对于一个固定的 $j$，集合 $A_j$ 是在 $G_j$ 所支撑的子空间中半径为 $1/w_j$ 的欧几里得球面。因此，根据柯西-施瓦茨不等式和等号成立的条件，我们得到\n$$\n\\sup\\{\\langle y, a \\rangle : a \\in A_j\\} \\;=\\; \\frac{1}{w_j} \\|y_{G_j}\\|_2.\n$$\n对 $j$ 取上确界可得\n$$\n\\|y\\|_{*} \\;=\\; \\sigma_{B}(y) \\;=\\; \\max_{j \\in \\{1,\\dots,m\\}} \\frac{\\|y_{G_j}\\|_2}{w_j}.\n$$\n因此，$x \\mapsto \\sum_{j=1}^{m} w_j \\|x_{G_j}\\|_2$ 的对偶范数是 $y \\mapsto \\max_{j} \\|y_{G_j}\\|_2/w_j$。\n\n最后，我们在指定点上计算该对偶范数的值。给定 $n=7$, $G_1=\\{1,2\\}$, $G_2=\\{3,4,5\\}$, $G_3=\\{6,7\\}$, $w_1=2$, $w_2=3$, $w_3=7$, 以及\n$$\ny=\\big(3,4,2,-1,2,5,12\\big).\n$$\n我们计算各组的欧几里得范数：\n$$\n\\|y_{G_1}\\|_2 \\;=\\; \\sqrt{3^2 + 4^2} \\;=\\; \\sqrt{9+16} \\;=\\; 5,\n$$\n$$\n\\|y_{G_2}\\|_2 \\;=\\; \\sqrt{2^2 + (-1)^2 + 2^2} \\;=\\; \\sqrt{4+1+4} \\;=\\; 3,\n$$\n$$\n\\|y_{G_3}\\|_2 \\;=\\; \\sqrt{5^2 + 12^2} \\;=\\; \\sqrt{25+144} \\;=\\; 13.\n$$\n除以相应的权重：\n$$\n\\frac{\\|y_{G_1}\\|_2}{w_1} \\;=\\; \\frac{5}{2}, \\quad \\frac{\\|y_{G_2}\\|_2}{w_2} \\;=\\; \\frac{3}{3} \\;=\\; 1, \\quad \\frac{\\|y_{G_3}\\|_2}{w_3} \\;=\\; \\frac{13}{7}.\n$$\n取最大值得\n$$\n\\|y\\|_{*} \\;=\\; \\max\\Big\\{\\frac{5}{2},\\, 1,\\, \\frac{13}{7}\\Big\\} \\;=\\; \\frac{5}{2}.\n$$\n因此，在指定点 $y$ 处对偶范数的值是 $\\frac{5}{2}$。", "answer": "$$\\boxed{\\frac{5}{2}}$$", "id": "3452404"}, {"introduction": "邻近算子（proximal operator）是现代凸优化算法（如 ISTA 和 FISTA）的核心构件，它使我们能够有效处理非光滑的正则化项。本练习聚焦于支撑函数（support function）的邻近算子，它与几何中的欧几里得投影（Euclidean projection）有着深刻而优美的联系。您将通过莫罗分解（Moreau decomposition）推导出这一关键恒等式，并进一步将其转化为可执行的计算机代码，从而将抽象的凸分析理论与具体的数值计算实践联系起来 [@problem_id:3452370]。", "problem": "考虑一个非空紧凸多胞体 $C \\subset \\mathbb{R}^n$，它被描述为一个有限顶点集 $\\{v_i\\}_{i=1}^m$ 的凸包 $C=\\mathrm{conv}\\{v_1,\\dots,v_m\\}$。令 $C$ 的支撑函数为 $\\sigma_C(x)=\\sup_{c\\in C}\\langle c,x \\rangle$，指示函数为 $\\iota_C(x)=0$（若 $x\\in C$）和 $+\\infty$（否则）。对于 $\\lambda \\ge 0$，一个真、下半连续凸函数 $f$ 在点 $x\\in \\mathbb{R}^n$ 的邻近算子定义为 $\\mathrm{prox}_{\\lambda f}(x)=\\arg\\min_{z\\in \\mathbb{R}^n}\\tfrac{1}{2}\\|z-x\\|_2^2+\\lambda f(z)$。你可以将在凸分析中广泛使用的以下事实作为基础：支撑函数和指示函数的 Fenchel 共轭关系，以及邻近算子的 Moreau 分解恒等式，但你必须从这些原理推导出实现中使用的任何具体恒等式。\n\n您的任务是：\n\n- 从上述基本定义和事实出发，推导出一个关于 $\\mathrm{prox}_{\\lambda \\sigma_C}(x)$ 的可用恒等式，该恒等式用欧几里得投影到 $C$ 上来表示，记为 $P_C(y)=\\arg\\min_{z\\in C}\\|z-y\\|_2$。\n\n- 设计并实现一个算法来计算 $P_C(y)$，其中多胞体由其顶点 $\\{v_i\\}_{i=1}^m$ 表示，且不枚举其面。一个有效的规约方法是将其转化为一个关于凸组合系数在概率单纯形上的优化问题，并仅使用确定性数值方法求解。\n\n- 实现 $\\mathrm{prox}_{\\lambda \\sigma_C}(x)$ 的两种独立计算方法：\n  1. 使用你推导出的恒等式和你实现的投影程序 $P_C(\\cdot)$。\n  2. 作为上镜图重构问题 $\\min_{z\\in \\mathbb{R}^n,\\, t\\in \\mathbb{R}} \\tfrac{1}{2}\\|z-x\\|_2^2+\\lambda t$ 的最小化子，其约束条件为对所有 $i\\in\\{1,\\dots,m\\}$ 都有 $\\langle v_i, z\\rangle \\le t$。\n\n- 通过比较两种计算结果以及检查针对此问题实例化的 Moreau 分解关系来验证数值正确性。每次验证都应由一个布尔值量化，该布尔值当且仅当差异低于一个很小的容差时为真（例如，当某个差值的欧几里得范数小于 $10^{-6}$ 时）。\n\n你的程序必须确定性地运行并评估以下测试套件。在每个案例中，$C$ 由其顶点列表给出，$x\\in \\mathbb{R}^n$ 且 $\\lambda\\in \\mathbb{R}_+$：\n\n- 测试1（二维正方形）：$C=\\mathrm{conv}\\{(-1,-1),(1,-1),(1,1),(-1,1)\\}$，$x=(0.3,-2.1)$，$\\lambda=0.5$。\n\n- 测试2（单点多胞体）：$C=\\mathrm{conv}\\{(2,-1)\\}$，$x=(3,4)$，$\\lambda=1.2$。\n\n- 测试3（线段）：$C=\\mathrm{conv}\\{(0,0),(2,0)\\}$，$x=(3,4)$，$\\lambda=0.5$。\n\n- 测试4（五维单纯形外加一个原点顶点）：$C=\\mathrm{conv}\\{(1,0,0,0,0),(0,1,0,0,0),(0,0,1,0,0),(0,0,0,1,0),(0,0,0,0,1),(0,0,0,0,0)\\}$，$x=(1,-2,0.5,-0.7,3)$，$\\lambda=1$。\n\n- 测试5（边界情况 $\\lambda=0$）：$C=\\mathrm{conv}\\{(0,0,0),(1,0,0),(0,1,0)\\}$，$x=(0.2,0.3,0.4)$，$\\lambda=0$。\n\n- 测试6（大尺度缩放）：$C=\\mathrm{conv}\\{(-1,-1),(1,-1),(1,1),(-1,1)\\}$，$x=(10,-10)$，$\\lambda=10$。\n\n对每个测试，产生两个布尔值：\n\n- 第一个布尔值为真，如果两个计算出的邻近点在容差范围内一致，即 $\\|\\hat{z}_{\\mathrm{id}}-\\hat{z}_{\\mathrm{epi}}\\|_2 \\le 10^{-6}$，其中 $\\hat{z}_{\\mathrm{id}}$ 是通过使用 $P_C(\\cdot)$ 的恒等式得到的，而 $\\hat{z}_{\\mathrm{epi}}$ 是通过上镜图最小化得到的。\n\n- 第二个布尔值为真，如果为你的推导恒等式实例化的 Moreau 分解等式在容差范围内成立，具体而言，对于 $\\lambda>0$，如果 $\\|\\hat{z}_{\\mathrm{id}}+\\lambda\\,P_C(x/\\lambda)-x\\|_2 \\le 10^{-6}$；对于 $\\lambda=0$，如果 $\\|\\hat{z}_{\\mathrm{id}}-x\\|_2 \\le 10^{-12}$。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\mathrm{b}_{1,1},\\mathrm{b}_{1,2},\\mathrm{b}_{2,1},\\mathrm{b}_{2,2},\\dots,\\mathrm{b}_{6,1},\\mathrm{b}_{6,2}]$，其中 $\\mathrm{b}_{k,1}$ 和 $\\mathrm{b}_{k,2}$ 是按上述顺序定义的测试 $k$ 的两个布尔值。不涉及任何物理单位或角度；所有量都是实数，欧几里得范数按标准形式理解。", "solution": "该问题提法清晰，并以凸分析原理为科学基础。它提供了推导所需恒等式和实现指定算法所需的所有必要定义和数据。不存在矛盾、歧义或违反科学原理之处。该问题有效，并将提供解决方案。\n\n解决方案分三部分呈现：首先，推导支撑函数邻近算子的可计算恒等式；其次，设计一个算法来计算到由其顶点定义的多胞体上的欧几里得投影；第三，构建一个基于上镜图重构的比较计算方法。\n\n解决方案的一个关键组成部分是 Moreau 分解，它提供了一个真、下半连续凸函数 $f$ 的邻近算子与其 Fenchel 共轭 $f^*$ 的邻近算子之间的基本关系。对于任何 $x \\in \\mathbb{R}^n$ 和 $\\lambda > 0$，该恒等式为：\n$$x = \\mathrm{prox}_{\\lambda f}(x) + \\lambda \\mathrm{prox}_{\\frac{1}{\\lambda} f^*}\\left(\\frac{x}{\\lambda}\\right)$$\n我们感兴趣的情况是 $f$ 为非空紧凸集 $C \\subset \\mathbb{R}^n$ 的支撑函数 $\\sigma_C$。支撑函数 $\\sigma_C$ 的 Fenchel 共轭是集合 $C$ 的指示函数 $\\iota_C$，即 $(\\sigma_C)^* = \\iota_C$。指示函数定义为 $\\iota_C(z) = 0$（若 $z \\in C$）和 $\\iota_C(z) = +\\infty$（若 $z \\notin C$）。将 $f = \\sigma_C$ 和 $f^* = \\iota_C$ 代入 Moreau 分解，得到：\n$$x = \\mathrm{prox}_{\\lambda \\sigma_C}(x) + \\lambda \\mathrm{prox}_{\\frac{1}{\\lambda} \\iota_C}\\left(\\frac{x}{\\lambda}\\right)$$\n为了使此恒等式有用，我们必须为通用参数 $y \\in \\mathbb{R}^n$ 和标量 $\\gamma > 0$ 找到 $\\mathrm{prox}_{\\gamma \\iota_C}(y)$ 项的更简单表达式。根据邻近算子的定义：\n$$\\mathrm{prox}_{\\gamma \\iota_C}(y) = \\arg\\min_{z \\in \\mathbb{R}^n} \\left\\{ \\frac{1}{2}\\|z-y\\|_2^2 + \\gamma \\iota_C(z) \\right\\}$$\n对于任何 $z \\notin C$，目标函数为无穷大。因此，最小化子必须位于 $C$ 内。对于 $z \\in C$，项 $\\gamma \\iota_C(z)$ 为零。因此，最小化问题简化为：\n$$\\mathrm{prox}_{\\gamma \\iota_C}(y) = \\arg\\min_{z \\in C} \\frac{1}{2}\\|z-y\\|_2^2$$\n这正是点 $y$ 到凸集 $C$ 上的欧几里得投影的定义，记为 $P_C(y)$。常数因子 $\\frac{1}{2}$ 不影响最小化子。因此，对于任何 $\\gamma > 0$，我们有 $\\mathrm{prox}_{\\gamma \\iota_C}(y) = P_C(y)$。将此结果应用于我们的 Moreau 恒等式，并设 $\\gamma = \\frac{1}{\\lambda}$ 和 $y = \\frac{x}{\\lambda}$，我们得到：\n$$x = \\mathrm{prox}_{\\lambda \\sigma_C}(x) + \\lambda P_C\\left(\\frac{x}{\\lambda}\\right)$$\n重新整理此方程，得到我们期望的关于 $\\mathrm{prox}_{\\lambda \\sigma_C}(x)$ 在 $\\lambda > 0$ 时的恒等式：\n$$\\mathrm{prox}_{\\lambda \\sigma_C}(x) = x - \\lambda P_C\\left(\\frac{x}{\\lambda}\\right)$$\n对于边界情况 $\\lambda = 0$，邻近算子定义为：\n$$\\mathrm{prox}_{0 \\cdot \\sigma_C}(x) = \\arg\\min_{z \\in \\mathbb{R}^n} \\left\\{ \\frac{1}{2}\\|z-x\\|_2^2 + 0 \\cdot \\sigma_C(z) \\right\\} = \\arg\\min_{z \\in \\mathbb{R}^n} \\frac{1}{2}\\|z-x\\|_2^2 = x$$\n这就完成了对所有 $\\lambda \\ge 0$ 情况的推导。\n\n为了计算投影 $P_C(y) = \\arg\\min_{z \\in C} \\|z-y\\|_2^2$，我们利用 $C$ 作为其顶点凸包的表示，即 $C = \\mathrm{conv}\\{v_1, \\dots, v_m\\}$。任何点 $z \\in C$ 都可以表示为一个凸组合 $z = \\sum_{i=1}^m \\alpha_i v_i = V\\alpha$，其中 $V$ 是一个 $n \\times m$ 的矩阵，其列为 $\\{v_i\\}_{i=1}^m$，而 $\\alpha$ 位于概率单纯形 $\\Delta_m = \\{ \\alpha \\in \\mathbb{R}^m \\mid \\sum_{i=1}^m \\alpha_i = 1, \\alpha_i \\ge 0 \\}$ 中。因此，投影问题被规约为一个关于 $\\alpha$ 的凸二次规划（QP）问题：\n$$\\min_{\\alpha \\in \\Delta_m} \\|V\\alpha - y\\|_2^2$$\n这个二次规划问题可以使用标准的确定性数值优化算法（如序列最小二乘规划，SLSQP）来解决，而无需枚举多胞体的面。一旦找到最优系数向量 $\\alpha^*$，投影点就可以通过 $P_C(y) = V\\alpha^*$ 恢复。\n\n为了进行独立验证，我们通过求解其定义中的优化问题来计算 $\\mathrm{prox}_{\\lambda \\sigma_C}(x)$，即 $\\hat{z} = \\arg\\min_{z \\in \\mathbb{R}^n} \\{ \\frac{1}{2}\\|z-x\\|_2^2 + \\lambda \\sigma_C(z) \\}$。由于 $\\sigma_C(z) = \\max_{i \\in \\{1,\\dots,m\\}} \\langle v_i, z \\rangle$，我们可以使用一个上镜图变量 $t \\in \\mathbb{R}$ 将其重构为一个有约束的二次规划问题：\n$$\\min_{z \\in \\mathbb{R}^n, t \\in \\mathbb{R}} \\quad \\frac{1}{2}\\|z-x\\|_2^2 + \\lambda t$$\n$$\\text{subject to} \\quad \\langle v_i, z \\rangle \\le t, \\quad \\text{for } i=1, \\dots, m$$\n邻近点解 $\\hat{z}_{\\mathrm{epi}}$ 是最优向量 $(z^*, t^*)$ 的 $z$ 分量。\n\n数值验证将包括两项检查。首先，两种方法之间的一致性：$\\|\\hat{z}_{\\mathrm{id}} - \\hat{z}_{\\mathrm{epi}}\\|_2 \\le 10^{-6}$。其次，使用计算值检验 Moreau 恒等式是否满足：对于 $\\lambda > 0$，$\\|\\hat{z}_{\\mathrm{id}} + \\lambda P_C(x/\\lambda) - x\\|_2 \\le 10^{-6}$；对于 $\\lambda=0$，$\\|\\hat{z}_{\\mathrm{id}} - x\\|_2 \\le 10^{-12}$。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\nTOL_AGREEMENT = 1e-6\nTOL_MOREAU_GT0 = 1e-6\nTOL_MOREAU_EQ0 = 1e-12\n\ndef project_onto_polytope(y: np.ndarray, V: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the Euclidean projection of a point y onto the convex hull of vertices V.\n    This solves the QP: min_{alpha} ||V*alpha - y||^2_2 s.t. sum(alpha)=1, alpha>=0.\n    \n    Args:\n        y: The point to project, shape (n,).\n        V: The matrix of vertices, shape (n, m).\n\n    Returns:\n        The projection of y onto conv(V), shape (n,).\n    \"\"\"\n    n, m = V.shape\n    if m == 0:\n        raise ValueError(\"Vertex matrix V cannot be empty.\")\n    \n    # Objective function and its gradient (Jacobian)\n    def obj_fun(alpha):\n        return np.linalg.norm(V @ alpha - y)**2\n    \n    def obj_jac(alpha):\n        return 2 * V.T @ (V @ alpha - y)\n\n    # Constraints: sum(alpha) = 1\n    eq_cons = {'type': 'eq', 'fun': lambda alpha: np.sum(alpha) - 1.0}\n\n    # Bounds: alpha_i >= 0 for all i\n    bnds = tuple((0, None) for _ in range(m))\n\n    # Initial guess for alpha (center of the simplex)\n    alpha0 = np.ones(m) / m\n\n    # Solve the QP\n    res = minimize(obj_fun, alpha0, jac=obj_jac,\n                   bounds=bnds, constraints=[eq_cons],\n                   method='SLSQP',\n                   options={'ftol': 1e-12, 'disp': False})\n\n    if not res.success:\n        # Fallback with higher precision if needed, or raise error.\n        # For this problem set, the default precision is expected to be sufficient.\n        pass\n\n    # The projection is V * alpha_optimal\n    return V @ res.x\n\ndef compute_prox_identity(x: np.ndarray, V: np.ndarray, lam: float) -> np.ndarray:\n    \"\"\"\n    Computes prox_{lambda * sigma_C}(x) using the Moreau decomposition-based identity.\n    prox(x) = x - lambda * P_C(x / lambda).\n    \"\"\"\n    if lam == 0:\n        return x\n    \n    y = x / lam\n    proj_point = project_onto_polytope(y, V)\n    return x - lam * proj_point\n\ndef compute_prox_epigraph(x: np.ndarray, V: np.ndarray, lam: float) -> np.ndarray:\n    \"\"\"\n    Computes prox_{lambda * sigma_C}(x) by solving the epigraph formulation.\n    min_{z,t} 0.5*||z-x||^2 + lambda*t  s.t. V.T*z <= t.\n    \"\"\"\n    n, m = V.shape\n    \n    # Optimization variable u = [z_1, ..., z_n, t] of size n+1\n    def obj_fun(u):\n        z, t = u[:n], u[n]\n        return 0.5 * np.linalg.norm(z - x)**2 + lam * t\n\n    def obj_jac(u):\n        z, t = u[:n], u[n]\n        grad_z = z - x\n        grad_t = np.array([lam])\n        return np.concatenate((grad_z, grad_t))\n\n    # Constraints: V.T @ z <= t  => t - V.T @ z >= 0\n    # Scipy SLSQP expects constraints in the form g(u) >= 0.\n    ineq_cons = {\n        'type': 'ineq',\n        'fun': lambda u: u[n] - V.T @ u[:n],\n        'jac': lambda u: np.hstack((-V.T, np.ones((m, 1))))\n    }\n\n    # Initial guess (feasible point u0 = [x, max(V.T @ x)])\n    t0 = np.max(V.T @ x) if m > 0 else 0.0\n    u0 = np.concatenate((x, [t0]))\n    \n    # Solve the QP\n    res = minimize(obj_fun, u0, jac=obj_jac,\n                   constraints=[ineq_cons],\n                   method='SLSQP',\n                   options={'ftol': 1e-12, 'disp': False})\n    \n    if not res.success:\n        pass # As before, rely on default success for this problem set.\n\n    return res.x[:n]\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the final results.\n    \"\"\"\n    test_cases = [\n        # Test 1: 2D square\n        {\n            'V': np.array([[-1, 1, 1, -1], [-1, -1, 1, 1]]),\n            'x': np.array([0.3, -2.1]),\n            'lambda': 0.5\n        },\n        # Test 2: Single-point polytope\n        {\n            'V': np.array([[2], [-1]]),\n            'x': np.array([3, 4]),\n            'lambda': 1.2\n        },\n        # Test 3: Line segment\n        {\n            'V': np.array([[0, 2], [0, 0]]),\n            'x': np.array([3, 4]),\n            'lambda': 0.5\n        },\n        # Test 4: 5D simplex + origin\n        {\n            'V': np.vstack([np.eye(5), np.zeros(5)]).T,\n            'x': np.array([1, -2, 0.5, -0.7, 3]),\n            'lambda': 1.0\n        },\n        # Test 5: Boundary case lambda=0\n        {\n            'V': np.array([[0, 1, 0], [0, 0, 1], [0, 0, 0]]),\n            'x': np.array([0.2, 0.3, 0.4]),\n            'lambda': 0.0\n        },\n        # Test 6: Large scaling\n        {\n            'V': np.array([[-1, 1, 1, -1], [-1, -1, 1, 1]]),\n            'x': np.array([10, -10]),\n            'lambda': 10.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        V, x, lam = case['V'], case['x'], case['lambda']\n        \n        # Compute proximal point using the two methods\n        z_id = compute_prox_identity(x, V, lam)\n        z_epi = compute_prox_epigraph(x, V, lam)\n        \n        # Verification 1: Compare the two results\n        discrepancy1 = np.linalg.norm(z_id - z_epi)\n        bool1 = discrepancy1 = TOL_AGREEMENT\n        \n        # Verification 2: Check Moreau decomposition identity\n        if lam > 0:\n            proj_point = project_onto_polytope(x / lam, V)\n            discrepancy2 = np.linalg.norm(z_id + lam * proj_point - x)\n            bool2 = discrepancy2 = TOL_MOREAU_GT0\n        else:  # lam == 0\n            discrepancy2 = np.linalg.norm(z_id - x)\n            bool2 = discrepancy2 = TOL_MOREAU_EQ0\n            \n        results.extend([bool1, bool2])\n\n    # Convert boolean to string 'True' or 'False' for final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3452370"}, {"introduction": "在应用正则化方法时，如何选择合适的正则化参数 $\\lambda$ 是一个核心且具有挑战性的问题。本练习将展示如何利用芬克尔-洛克菲勒对偶（Fenchel-Rockafellar duality）框架来解决这一难题。您将推导出保证解为稀疏（具体来说，零向量为最优解）所需的最小 $\\lambda$ 的条件，并发现该条件可以简洁地用支撑函数来表达。这个实践不仅展示了对偶理论的分析威力，也为数据驱动的参数选择提供了理论依据 [@problem_id:3452419]。", "problem": "考虑压缩感知和稀疏优化中的凸正则化最小二乘问题\n$$\n\\min_{x \\in \\mathbb{R}^n} \\;\\; \\frac{1}{2} \\|y - A x\\|_{2}^{2} + \\lambda \\,\\gamma_{C}(x),\n$$\n其中 $A \\in \\mathbb{R}^{m \\times n}$，$y \\in \\mathbb{R}^{m}$，$\\lambda \\ge 0$，且 $\\gamma_{C}$ 是包含原点的非空、紧、凸、对称集合 $C \\subset \\mathbb{R}^{n}$ 的规范函数（Minkowski 泛函）。回顾以下基本定义：\n- 集合 $S$ 的指示函数为 $I_{S}(z) = 0$ 如果 $z \\in S$，否则 $I_{S}(z) = +\\infty$。\n- 集合 $S$ 的支撑函数为 $\\sigma_{S}(u) = \\sup_{s \\in S} \\langle u, s \\rangle$。\n- 集合 $C$ 的规范函数 $\\gamma_{C}$ 为 $\\gamma_{C}(x) = \\inf\\{ t \\ge 0 : x \\in t C \\}$。\n- 极（对偶）集 $C^{\\circ} = \\{ z \\in \\mathbb{R}^{n} : \\langle z, x \\rangle \\le 1 \\;\\; \\forall x \\in C \\}$。\n\n(a) 部分：从复合形式 $\\min_{x} f(Ax) + h(x)$ 的 Fenchel–Rockafellar 对偶性出发，其中 $f(u) = \\frac{1}{2}\\|y-u\\|_{2}^{2}$ 且 $h(x) = \\lambda \\gamma_{C}(x)$，仅使用上述核心定义和标准共轭性质，推导出形如 $A^{\\top} \\eta \\in \\lambda C^{\\circ}$ 的对偶可行性条件，其中 $\\eta \\in \\mathbb{R}^{m}$ 是对偶变量。然后，将确保对偶可行性的最小正则化水平 $\\lambda_{\\min}(\\eta)$ 表示为支撑函数。您的最终表达式必须是仅含 $A$、$\\eta$ 和 $C$ 或 $C^{\\circ}$ 的闭式解析表达式。\n\n(b) 部分：考虑 $n=4, m=3$ 的特殊情况，其中 $\\gamma_{C}$ 是 $\\mathbb{R}^{4}$ 上的 $\\ell_{1}$ 范数（等价地，$C$ 是单位 $\\ell_{1}$ 球）。设\n$$\nA \\;=\\; \\begin{pmatrix}\n1  0  2  -1 \\\\\n0  1  -1  2 \\\\\n1  -1  0  1\n\\end{pmatrix},\n\\qquad\ny \\;=\\; \\begin{pmatrix} 2 \\\\ -1 \\\\ 3 \\end{pmatrix}.\n$$\n采用数据驱动的选择 $\\eta_{0} = -y$，它对应于对偶二次部分的无约束最大化子（等价于数据拟合项在 $x=0$ 处的负梯度）。计算保证 $x=0$ 是原始最优解的最小 $\\lambda$。您的最终答案应为一个精确的数字。不要包含单位。不要四舍五入。", "solution": "此问题包含两部分。我们将依次解决它们。\n\n(a) 部分：推导对偶可行性条件和 $\\lambda_{\\min}(\\eta)$\n\n原始问题表述为：\n$$\n\\min_{x \\in \\mathbb{R}^n} \\;\\; \\frac{1}{2} \\|y - A x\\|_{2}^{2} + \\lambda \\,\\gamma_{C}(x)\n$$\n这是复合形式 $\\min_{x} f(Ax) + h(x)$，其中：\n- $f(u) = \\frac{1}{2}\\|y - u\\|_{2}^{2}$，其中 $u \\in \\mathbb{R}^m$。\n- $h(x) = \\lambda \\gamma_{C}(x)$，其中 $x \\in \\mathbb{R}^n$。\n\nFenchel-Rockafellar 对偶问题由 $\\max_{\\eta \\in \\mathbb{R}^m} -f^*(-\\eta) - h^*(A^{\\top}\\eta)$ 给出，其中 $f^*$ 和 $h^*$ 分别是 $f$ 和 $h$ 的凸共轭。\n\n首先，我们求 $f(u)$ 的共轭：\n$$\nf^*(v) = \\sup_{u \\in \\mathbb{R}^m} \\left( \\langle v, u \\rangle - f(u) \\right) = \\sup_{u \\in \\mathbb{R}^m} \\left( \\langle v, u \\rangle - \\frac{1}{2}\\|y - u\\|_{2}^{2} \\right)\n$$\n上确界内的表达式是关于 $u$ 的严格凹二次函数。当其关于 $u$ 的梯度为零时，达到最大值：\n$$\n\\nabla_u \\left( \\langle v, u \\rangle - \\frac{1}{2}\\|y - u\\|_{2}^{2} \\right) = v - \\frac{1}{2} \\cdot 2(y-u) \\cdot (-1) = v + y - u = 0\n$$\n这给出了最大化时的 $u = v+y$。将其代回表达式中：\n$$\nf^*(v) = \\langle v, v+y \\rangle - \\frac{1}{2}\\|y - (v+y)\\|_{2}^{2} = \\|v\\|_{2}^{2} + \\langle v, y \\rangle - \\frac{1}{2}\\|-v\\|_{2}^{2} = \\frac{1}{2}\\|v\\|_{2}^{2} + \\langle v, y \\rangle\n$$\n对于对偶问题，我们需要 $f^*(-\\eta)$：\n$$\nf^*(-\\eta) = \\frac{1}{2}\\|-\\eta\\|_{2}^{2} + \\langle -\\eta, y \\rangle = \\frac{1}{2}\\|\\eta\\|_{2}^{2} - \\langle \\eta, y \\rangle\n$$\n\n接下来，我们求 $h(x)$ 的共轭：\n$$\nh^*(z) = \\sup_{x \\in \\mathbb{R}^n} \\left( \\langle z, x \\rangle - h(x) \\right) = \\sup_{x \\in \\mathbb{R}^n} \\left( \\langle z, x \\rangle - \\lambda \\gamma_{C}(x) \\right)\n$$\n对于 $\\lambda  0$，我们可以将其写为 $h^*(z) = \\lambda \\sup_{x \\in \\mathbb{R}^n} \\left( \\langle z/\\lambda, x \\rangle - \\gamma_{C}(x) \\right) = \\lambda (\\gamma_C)^*(z/\\lambda)$。\n规范函数 $\\gamma_C$ 的共轭是极集 $C^{\\circ}$ 的指示函数，即 $(\\gamma_C)^*(w) = I_{C^{\\circ}}(w)$。为了证明这一点，如果 $w \\in C^{\\circ}$，则对于所有 $x$，都有 $\\langle w, x \\rangle \\le \\gamma_C(x)$，因此 $\\langle w, x \\rangle - \\gamma_C(x) \\le 0$，且上确界为 $0$（在 $x=0$ 处取得）。如果 $w \\notin C^{\\circ}$，则存在一个 $x_0 \\in C$ 使得 $\\langle w, x_0 \\rangle  1$。那么对于 $x = t x_0$ 且 $t  0$，我们有 $\\gamma_C(x) = t \\gamma_C(x_0) \\le t$。该表达式变为 $\\langle w, t x_0 \\rangle - \\gamma_C(x) \\ge t\\langle w, x_0 \\rangle - t = t(\\langle w, x_0 \\rangle - 1)$。当 $t \\to \\infty$ 时，此式趋向于 $+\\infty$。\n因此，如果 $w \\in C^{\\circ}$，则 $(\\gamma_C)^*(w) = I_{C^{\\circ}}(w) = 0$，否则为 $+\\infty$。\n将其代回，我们得到 $h^*(z) = \\lambda I_{C^{\\circ}}(z/\\lambda)$。如果 $z/\\lambda \\in C^{\\circ}$（即 $z \\in \\lambda C^{\\circ}$），则此值为 $0$，否则为 $+\\infty$。因此，$h^*(z) = I_{\\lambda C^{\\circ}}(z)$。\n\n现在，我们构建对偶问题：\n$$\n\\max_{\\eta \\in \\mathbb{R}^m} -\\left(\\frac{1}{2}\\|\\eta\\|_{2}^{2} - \\langle \\eta, y \\rangle\\right) - I_{\\lambda C^{\\circ}}(A^{\\top}\\eta) = \\max_{\\eta \\in \\mathbb{R}^m} \\left( \\langle \\eta, y \\rangle - \\frac{1}{2}\\|\\eta\\|_{2}^{2} - I_{\\lambda C^{\\circ}}(A^{\\top}\\eta) \\right)\n$$\n对偶问题等价于在指示函数为有限值的定义域上最大化目标函数 $\\langle \\eta, y \\rangle - \\frac{1}{2}\\|\\eta\\|_{2}^{2}$。对偶可行性条件是定义此定义域的约束：\n$$\nA^{\\top} \\eta \\in \\lambda C^{\\circ}\n$$\n这就是所要求的条件。为了找到确保此条件对给定 $\\eta$ 成立的最小正则化水平 $\\lambda_{\\min}(\\eta)$，我们分析此约束。假设 $\\lambda  0$，它可以被写为 $\\frac{1}{\\lambda} A^{\\top}\\eta \\in C^{\\circ}$。根据极集 $C^{\\circ}$ 的定义，这等价于：\n$$\n\\left\\langle \\frac{1}{\\lambda} A^{\\top}\\eta, x \\right\\rangle \\le 1 \\quad \\forall x \\in C\n$$\n重新整理可得：\n$$\n\\langle A^{\\top}\\eta, x \\rangle \\le \\lambda \\quad \\forall x \\in C\n$$\n为使此不等式对所有 $x \\in C$ 成立，$\\lambda$ 必须大于或等于左侧表达式在 $C$ 上的上确界：\n$$\n\\lambda \\ge \\sup_{x \\in C} \\langle A^{\\top}\\eta, x \\rangle\n$$\n右侧的表达式是在向量 $A^{\\top}\\eta$ 处求值的 $C$ 的支撑函数的定义，记为 $\\sigma_{C}(A^{\\top}\\eta)$。因此，$\\lambda$ 的最小值是这个上确界的值。\n$$\n\\lambda_{\\min}(\\eta) = \\sigma_{C}(A^{\\top}\\eta)\n$$\n这就是最小正则化水平的闭式解析表达式。\n\n(b) 部分：具体计算\n\n我们需要找到保证 $x^*=0$ 是原始最优解的最小 $\\lambda$。\n原始问题中 $x^*$ 最优性的一阶必要条件是零向量必须位于目标函数在 $x^*$ 处的次微分中：\n$$\n0 \\in \\partial \\left( \\frac{1}{2} \\|y - A x\\|_{2}^{2} + \\lambda \\,\\gamma_{C}(x) \\right)\\bigg|_{x=x^*}\n$$\n数据拟合项 $\\frac{1}{2} \\|y - A x\\|_{2}^{2}$ 的梯度是 $-A^{\\top}(y-Ax)$。完整目标函数的次微分是光滑部分的梯度与非光滑部分的次微分之和：\n$$\n0 \\in -A^{\\top}(y - Ax^*) + \\lambda \\partial \\gamma_{C}(x^*)\n$$\n要使 $x^*=0$ 成为最优化子，我们必须有：\n$$\n0 \\in -A^{\\top}y + \\lambda \\partial \\gamma_{C}(0) \\quad \\iff \\quad A^{\\top}y \\in \\lambda \\partial \\gamma_{C}(0)\n$$\n规范函数 $\\gamma_C$ 在原点处的次微分是极集 $C^{\\circ}$。这是凸分析中的一个标准结果，因为 $\\gamma_C$ 是 $C^\\circ$ 的支撑函数，而支撑函数 $\\sigma_S$ 在原点处的次微分是集合 $S$ 本身（如果 $S$ 是闭凸集）。因此，$\\partial \\gamma_C(0) = C^{\\circ}$。\n最优性条件变为：\n$$\nA^{\\top}y \\in \\lambda C^{\\circ}\n$$\n这与 (a) 部分的对偶可行性条件形式相同，但使用了特定的向量 $A^\\top y$。我们需要找到满足此包含关系的最小 $\\lambda \\ge 0$。根据规范函数的定义，这个最小值是 $\\gamma_{C^\\circ}(A^\\top y)$。利用恒等式 $\\gamma_{C^\\circ}(z) = \\sigma_C(z)$，我们找到最小的 $\\lambda$ 是：\n$$\n\\lambda_{\\min} = \\gamma_{C^\\circ}(A^\\top y) = \\sigma_C(A^\\top y)\n$$\n在这个具体问题中，正则化子是 $\\ell_1$-范数，因此 $\\gamma_C(x) = \\|x\\|_1$。这意味着 $C$ 是单位 $\\ell_1$-球：$C = \\{x \\in \\mathbb{R}^4 : \\|x\\|_1 \\le 1\\}$。$\\ell_1$-球的极集是 $\\ell_\\infty$-球：$C^{\\circ} = \\{z \\in \\mathbb{R}^4 : \\|z\\|_\\infty \\le 1\\}$。\n$\\ell_1$-球的支撑函数是 $\\ell_\\infty$-范数：$\\sigma_C(z) = \\|z\\|_\\infty$。\n因此，所需的最小 $\\lambda$ 是：\n$$\n\\lambda_{\\min} = \\|A^{\\top}y\\|_{\\infty}\n$$\n我们给定了矩阵 $A$ 和向量 $y$：\n$$\nA \\;=\\; \\begin{pmatrix}\n1  0  2  -1 \\\\\n0  1  -1  2 \\\\\n1  -1  0  1\n\\end{pmatrix},\n\\qquad\ny \\;=\\; \\begin{pmatrix} 2 \\\\ -1 \\\\ 3 \\end{pmatrix}\n$$\n首先，我们计算向量 $A^{\\top}y$：\n$$\nA^{\\top}y = \\begin{pmatrix}\n1  0  1 \\\\\n0  1  -1 \\\\\n2  -1  0 \\\\\n-1  2  1\n\\end{pmatrix}\n\\begin{pmatrix} 2 \\\\ -1 \\\\ 3 \\end{pmatrix}\n= \\begin{pmatrix}\n1 \\cdot 2 + 0 \\cdot (-1) + 1 \\cdot 3 \\\\\n0 \\cdot 2 + 1 \\cdot (-1) + (-1) \\cdot 3 \\\\\n2 \\cdot 2 + (-1) \\cdot (-1) + 0 \\cdot 3 \\\\\n-1 \\cdot 2 + 2 \\cdot (-1) + 1 \\cdot 3\n\\end{pmatrix}\n= \\begin{pmatrix}\n2 + 3 \\\\\n-1 - 3 \\\\\n4 + 1 \\\\\n-2 - 2 + 3\n\\end{pmatrix}\n= \\begin{pmatrix} 5 \\\\ -4 \\\\ 5 \\\\ -1 \\end{pmatrix}\n$$\n最后，我们计算这个结果向量的 $\\ell_\\infty$-范数：\n$$\n\\lambda_{\\min} = \\|A^{\\top}y\\|_{\\infty} = \\left\\| \\begin{pmatrix} 5 \\\\ -4 \\\\ 5 \\\\ -1 \\end{pmatrix} \\right\\|_{\\infty} = \\max\\left(|5|, |-4|, |5|, |-1|\\right) = \\max(5, 4, 5, 1) = 5\n$$\n保证 $x=0$ 是最优解的最小 $\\lambda$ 值为 $5$。\n请注意，在 (a) 部分的公式中使用提示 $\\eta_0 = -y$ 将得到 $\\lambda_{\\min}(-y) = \\sigma_C(A^\\top(-y)) = \\sigma_C(-A^\\top y)$。由于 $C$ 是对称的，$\\sigma_C$ 是一个偶函数，所以 $\\sigma_C(-A^\\top y) = \\sigma_C(A^\\top y) = \\|A^\\top y\\|_\\infty$，这会得到相同的结果。", "answer": "$$\n\\boxed{5}\n$$", "id": "3452419"}]}