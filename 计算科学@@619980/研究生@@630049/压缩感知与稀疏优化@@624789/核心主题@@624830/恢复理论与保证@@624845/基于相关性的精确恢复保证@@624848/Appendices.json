{"hands_on_practices": [{"introduction": "本章的第一个实践练习旨在奠定基础 ([@problem_id:3435250])。我们将从一个核心的理论条件——精确恢复条件（Exact Recovery Condition, ERC）出发，推导出基于互相关性的稀疏恢复保证。这个练习将帮助你理解如何将一个抽象的优化理论与一个简单、可计算的矩阵属性（即互相关性 $\\mu$）联系起来，并让你通过数值模拟来验证该保证在矩阵列向量接近正交时的渐进行为。", "problem": "给定一个具有单位范数列的实矩阵，要求你分析用于稀疏恢复的经典基于互相关性的精确恢复阈值，以及当互相关性消失时其极限行为。所有工作都在有限维实数域上的线性代数框架下进行。所有角度均以弧度为单位，不涉及物理单位。\n\n基本概念：\n- 对于一个具有单位范数列的矩阵，其互相关性定义为 $\\,\\mu(A) \\triangleq \\max_{i\\neq j}\\,|\\langle a_i,a_j\\rangle|\\,$，其中 $\\,a_i\\,$ 表示第 $\\,i\\,$ 列，$\\,\\langle\\cdot,\\cdot\\rangle\\,$ 是标准内积。\n- 列子矩阵 $\\,A_S\\,$ 的格拉姆矩阵为 $\\,G_S \\triangleq A_S^\\top A_S\\,$.\n- 来自稀疏优化的精确恢复条件 (ERC) 指出，对于通过 $\\ell_1$-最小化或正交匹配追踪（Orthogonal Matching Pursuit）唯一恢复任何 $\\,s$-稀疏向量的一个充分条件是\n$$\n\\max_{j\\notin S}\\,\\|A_S^+ a_j\\|_1  1,\n$$\n对于每一个大小为 $\\,|S|=s\\,$ 的支撑集 $\\,S\\subset\\{1,\\dots,n\\}\\,$，其中 $\\,A_S^+ \\triangleq (A_S^\\top A_S)^{-1}A_S^\\top\\,$ 表示满列秩 $\\,A_S\\,$ 的 Moore–Penrose 伪逆。\n- 你可以利用经典的矩阵范数不等式（矩阵范数的次可乘性、向量范数与矩阵范数之间的关系）、用于求逆的 Neumann 级数界 $\\,\\|(I - E)^{-1}\\|\\leq 1/(1-\\|E\\|)\\,$（当 $\\,\\|E\\|1\\,$ 时），以及 Gershgorin 圆盘定理来论证 $\\,G_S\\,$ 的可逆性。\n\n任务 A (推导)：仅从上述基本概念出发，推导一个仅用 $\\,\\mu(A)\\,$ 表示的、保证对所有大小为 $\\,s\\,$ 的支撑集都满足ERC的纯相关性充分阈值。然后分析极限 $\\,\\mu(A)\\to 0\\,$，以表明该阈值的标度关系为\n$$\ns \\;\\approx\\; \\tfrac{1}{2}\\!\\left(1+\\tfrac{1}{\\mu(A)}\\right),\n$$\n其精确意义是，满足由你的界所蕴含的严格不等式的最大整数 $\\,s\\,$ 满足\n$$\n\\lim_{\\mu\\to 0^+}\\; \\mu \\cdot s(\\mu) \\;=\\; \\tfrac{1}{2},\\qquad\n\\lim_{\\mu\\to 0^+}\\; \\frac{s(\\mu)}{\\tfrac{1}{2}(1+\\tfrac{1}{\\mu})} \\;=\\; 1.\n$$\n你的推导必须从定义和所列出的已验证事实出发；不要援引任何将目标阈值作为输入来预设的结论。\n\n任务 B (数值示例)：考虑一个显式的由 $\\,\\varepsilon$-参数化的字典族 $\\,A(\\varepsilon)\\in\\mathbb{R}^{n\\times n}\\,$，其中 $\\,n\\geq 2\\,$，定义如下。令 $\\,\\{e_1,\\dots,e_n\\}\\,$ 为 $\\,\\mathbb{R}^n\\,$ 的标准基。定义\n- $\\,a_1(\\varepsilon) \\triangleq e_1\\,$，\n- 对于每个 $\\,j\\in\\{2,\\dots,n\\}\\,$，$\\,a_j(\\varepsilon) \\triangleq \\varepsilon\\,e_1 + \\sqrt{1-\\varepsilon^2}\\,e_j\\,$，\n并将各列 $\\,a_j(\\varepsilon)\\,$ 组装成 $\\,A(\\varepsilon)\\,$。证明对于每个 $\\,\\varepsilon\\in(0,1]\\,$，$\\,A(\\varepsilon)\\,$ 的列都具有单位范数，并且\n$$\n\\mu\\big(A(\\varepsilon)\\big) \\;=\\; \\max\\{\\varepsilon,\\,\\varepsilon^2\\} \\;=\\; \\varepsilon.\n$$\n\n任务 C (程序规范)：实现一个程序，对每个测试用例 $\\,(\\varepsilon, n)\\,$（其中 $\\,n\\in\\mathbb{N}\\,$ 且 $\\,\\varepsilon\\in(0,1]\\,$）执行以下操作：\n- 按上文所述构造 $\\,A(\\varepsilon)\\in\\mathbb{R}^{n\\times n}\\,$ 并计算 $\\,\\mu\\big(A(\\varepsilon)\\big)\\,$。\n- 计算实值相关性阈值\n$$\ns_{\\mathrm{cont}}(\\mu) \\;\\triangleq\\; \\tfrac{1}{2}\\!\\left(1+\\tfrac{1}{\\mu}\\right),\n$$\n以及满足你推导出的严格不等式的最大整数，其编码为\n$$\ns_{\\mathrm{int}}(\\mu) \\;\\triangleq\\; \\left\\lceil s_{\\mathrm{cont}}(\\mu)\\right\\rceil - 1.\n$$\n- 报告缩放乘积 $\\,\\mu\\cdot s_{\\mathrm{int}}(\\mu)\\,$ 和相对偏差\n$$\n\\mathrm{rel\\_dev} \\;\\triangleq\\; \\frac{\\big|s_{\\mathrm{cont}}(\\mu)-s_{\\mathrm{int}}(\\mu)\\big|}{s_{\\mathrm{cont}}(\\mu)}.\n$$\n- （可选）通过穷举支撑集搜索，在 $\\,s_{\\mathrm{int}}(\\mu)\\,$ 处数值验证精确恢复条件：定义\n$$\nT_{A,s} \\;\\triangleq\\; \\max_{S\\subset\\{1,\\dots,n\\},\\,|S|=s}\\;\\max_{j\\notin S}\\; \\big\\|A_S^+\\,a_j\\big\\|_1.\n$$\n如果 $\\,s_{\\mathrm{int}}(\\mu)\\leq n-1\\,$，通过枚举精确计算 $\\,T_{A,s_{\\mathrm{int}}}\\,$ 并设置一个指示符\n$$\n\\mathrm{erc\\_ok} \\;=\\; \\begin{cases}\n1  \\text{ if } T_{A,s_{\\mathrm{int}}}  1,\\\\\n0  \\text{ otherwise.}\n\\end{cases}\n$$\n如果 $\\,s_{\\mathrm{int}}(\\mu) > n-1\\,$，则跳过验证并输出 $\\,\\mathrm{erc\\_ok}=-1\\,$.\n- 将所有浮点输出四舍五入到 $\\,6\\,$ 位小数。\n\n测试套件：\n- 对所有用例使用 $\\,n=8\\,$ 和以下 $\\,\\varepsilon\\,$ 值：\n  - $\\,\\varepsilon = 0.5\\,$，\n  - $\\,\\varepsilon = \\tfrac{1}{3}\\,$，\n  - $\\,\\varepsilon = 0.2\\,$，\n  - $\\,\\varepsilon = 0.15\\,$，\n  - $\\,\\varepsilon = 0.1\\,$，\n  - $\\,\\varepsilon = 0.05\\,$.\n对于每个用例，程序必须输出一个列表\n$$\n\\big[\\mu,\\, s_{\\mathrm{int}},\\, \\mu\\cdot s_{\\mathrm{int}},\\, \\mathrm{rel\\_dev},\\, \\mathrm{erc\\_ok}\\big],\n$$\n其中实数按规定四舍五入到 $\\,6\\,$ 位小数。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个由各用例列表组成的逗号分隔列表，并用方括号括起来，例如\n$$\n\\big[\\,[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\;[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\;\\dots\\big].\n$$\n不应打印任何其他文本。", "solution": "该问题被验证为具有科学依据、适定且客观。它是压缩感知和稀疏优化领域的标准练习，所有必要组成部分都已定义，并有明确的任务集。\n\n### 任务 A: 基于相关性的恢复阈值推导\n\n主要目标是根据互相关性 $\\mu(A)$ 推导出一个关于稀疏度 $s$ 的充分条件，以保证精确恢复条件 (ERC) 成立。ERC 由下式给出\n$$\n\\max_{S:|S|=s} \\max_{j\\notin S} \\|A_S^+ a_j\\|_1  1\n$$\n其中 $A$ 是一个具有单位范数列的矩阵，$S$ 是一个大小为 $s$ 的支撑集，$a_j$ 是 $A$ 的第 $j$ 列，$A_S^+$ 是由索引在 $S$ 中的列构成的子矩阵 $A_S$ 的 Moore-Penrose 伪逆。我们已知 $A_S^+ = (A_S^\\top A_S)^{-1}A_S^\\top$。\n\n我们固定一个大小为 $|S|=s$ 的支撑集 $S$ 和一个索引 $j \\notin S$。我们需要对 $\\|A_S^+ a_j\\|_1$ 进行界定。\n令 $v_j = A_S^+ a_j = (A_S^\\top A_S)^{-1} (A_S^\\top a_j)$。\n令 $G_S = A_S^\\top A_S$ 为 $A_S$ 的格拉姆矩阵。这是一个 $s \\times s$ 的矩阵。令 $c_j = A_S^\\top a_j$ 为一个 $s$ 维向量。则 $v_j = G_S^{-1} c_j$。\n\n使用标准的矩阵和向量范数不等式，我们有：\n$$\n\\|v_j\\|_1 = \\|G_S^{-1} c_j\\|_1 \\le \\|G_S^{-1}\\|_1 \\|c_j\\|_1\n$$\n我们需要界定右侧的两项。\n\n1.  **界定 $\\|c_j\\|_1$**：向量 $c_j$ 的分量为 $(c_j)_i = \\langle a_i, a_j \\rangle$，对每个 $i \\in S$。互相关性 $\\mu(A)$ 定义为 $\\mu(A) \\triangleq \\max_{i\\neq k}\\,|\\langle a_i, a_k\\rangle|$。由于 $j \\notin S$，对于每个 $i \\in S$，我们有 $i \\ne j$。因此，$|\\langle a_i, a_j \\rangle| \\le \\mu(A)$。\n    $c_j$ 的 $\\ell_1$-范数是其 $s$ 个分量绝对值之和：\n    $$\n    \\|c_j\\|_1 = \\sum_{i \\in S} |\\langle a_i, a_j \\rangle| \\le \\sum_{i \\in S} \\mu(A) = s \\mu(A)\n    $$\n\n2.  **界定 $\\|G_S^{-1}\\|_1$**：格拉姆矩阵 $G_S$ 可以写成 $G_S = I + E$，其中 $I$ 是 $s \\times s$ 的单位矩阵，$E$ 是一个包含非对角内积的矩阵。$G_S$ 的对角线元素是 $(G_S)_{ii} = \\langle a_i, a_i \\rangle = 1$，因为所有列都是单位范数的。非对角线元素是 $(G_S)_{ik} = \\langle a_i, a_k \\rangle$，对于 $i, k \\in S, i \\ne k$。\n    因此，$E$ 的对角线元素为零，其非对角线元素为 $(E)_{ik} = \\langle a_i, a_k \\rangle$，所以对于 $i \\ne k$ 有 $|(E)_{ik}| \\le \\mu(A)$。\n\n    为确保 $G_S$ 是可逆的并界定其逆，我们可以使用 Gershgorin 圆盘定理或 Neumann 级数。让我们使用后者，这需要对 $E$ 的某个范数进行界定。矩阵 $\\ell_\\infty$-范数由最大绝对行和给出：\n    $$\n    \\|E\\|_\\infty = \\max_{i \\in S} \\sum_{k \\in S} |E_{ik}| = \\max_{i \\in S} \\sum_{k \\in S, k \\ne i} |\\langle a_i, a_k \\rangle| \\le \\max_{i \\in S} \\sum_{k \\in S, k \\ne i} \\mu(A) = (s-1)\\mu(A)\n    $$\n    如果 $\\|E\\|_\\infty  1$，即 $(s-1)\\mu(A)  1$，则矩阵 $G_S = I+E$ 是可逆的，我们可以界定其逆的范数：\n    $$\n    \\|G_S^{-1}\\|_\\infty = \\|(I+E)^{-1}\\|_\\infty \\le \\frac{1}{1 - \\|E\\|_\\infty} \\le \\frac{1}{1 - (s-1)\\mu(A)}\n    $$\n    由于 $G_S$ 是一个格拉姆矩阵，它是对称的。其逆 $G_S^{-1}$ 也是对称的。对于任何对称矩阵 $M$，$\\|M\\|_1 = \\|M\\|_\\infty$。因此，\n    $$\n    \\|G_S^{-1}\\|_1 = \\|G_S^{-1}\\|_\\infty \\le \\frac{1}{1 - (s-1)\\mu(A)}\n    $$\n\n结合这些界，我们得到：\n$$\n\\|A_S^+ a_j\\|_1 \\le \\|G_S^{-1}\\|_1 \\|c_j\\|_1 \\le \\frac{s \\mu(A)}{1 - (s-1)\\mu(A)}\n$$\n为使ERC成立，我们要求此上界严格小于 $1$：\n$$\n\\frac{s \\mu(A)}{1 - (s-1)\\mu(A)}  1\n$$\n这个不等式取决于分母为正，这是我们已经施加的条件 $(s-1)\\mu(A)  1$。假设此条件成立，我们可以将不等式两边同乘以分母：\n$$\ns \\mu(A)  1 - (s-1)\\mu(A) \\implies s \\mu(A)  1 - s\\mu(A) + \\mu(A)\n$$\n整理各项得：\n$$\n2s\\mu(A) - \\mu(A)  1 \\implies (2s-1)\\mu(A)  1\n$$\n假设 $\\mu(A) > 0$，我们可以通过除法得到关于 $s$ 的条件：\n$$\n2s-1  \\frac{1}{\\mu(A)} \\implies 2s  1 + \\frac{1}{\\mu(A)} \\implies s  \\frac{1}{2}\\left(1 + \\frac{1}{\\mu(A)}\\right)\n$$\n这是众所周知的基于相关性的精确稀疏恢复充分条件。\n\n现在，我们分析 $\\mu \\to 0^+$ 时的极限行为。令 $s(\\mu)$ 为满足严格不等式 $s  \\frac{1}{2}(1 + 1/\\mu)$ 的最大整数。这由 $s(\\mu) = \\lceil \\frac{1}{2}(1 + 1/\\mu) \\rceil - 1$ 给出。\n令 $f(\\mu) = \\frac{1}{2}(1 + 1/\\mu)$。根据上取整函数的定义，我们有 $f(\\mu) \\le \\lceil f(\\mu) \\rceil  f(\\mu)+1$。减去 $1$ 得到 $f(\\mu)-1 \\le s(\\mu)  f(\\mu)$。\n$\\frac{1}{2}(1 + 1/\\mu) - 1 \\le s(\\mu)  \\frac{1}{2}(1 + 1/\\mu)$。\n$\\frac{1}{2\\mu} - \\frac{1}{2} \\le s(\\mu)  \\frac{1}{2\\mu} + \\frac{1}{2}$。\n\n1.  **$\\mu \\cdot s(\\mu)$ 的极限**：将不等式乘以 $\\mu > 0$：\n    $$\n    \\mu\\left(\\frac{1}{2\\mu} - \\frac{1}{2}\\right) \\le \\mu \\cdot s(\\mu)  \\mu\\left(\\frac{1}{2\\mu} + \\frac{1}{2}\\right) \\implies \\frac{1}{2} - \\frac{\\mu}{2} \\le \\mu \\cdot s(\\mu)  \\frac{1}{2} + \\frac{\\mu}{2}\n    $$\n    当 $\\mu \\to 0^+$ 时，下界和上界都收敛于 $1/2$。根据夹逼定理，$\\lim_{\\mu\\to 0^+} \\mu \\cdot s(\\mu) = \\frac{1}{2}$。\n\n2.  **比率的极限**：将不等式 $f(\\mu)-1 \\le s(\\mu)  f(\\mu)$ 除以 $f(\\mu)$：\n    $$\n    \\frac{f(\\mu)-1}{f(\\mu)} \\le \\frac{s(\\mu)}{f(\\mu)}  \\frac{f(\\mu)}{f(\\mu)} \\implies 1 - \\frac{1}{f(\\mu)} \\le \\frac{s(\\mu)}{f(\\mu)}  1\n    $$\n    当 $\\mu \\to 0^+$ 时，$f(\\mu) = \\frac{1}{2}(1+1/\\mu) \\to \\infty$，所以 $1/f(\\mu) \\to 0$。下界收敛于 $1$。根据夹逼定理，$\\lim_{\\mu\\to 0^+} \\frac{s(\\mu)}{f(\\mu)} = 1$。\n\n### 任务 B: 矩阵族 $A(\\varepsilon)$ 的分析\n\n给定 $A(\\varepsilon) \\in \\mathbb{R}^{n \\times n}$，其中 $n \\ge 2, \\varepsilon \\in (0,1]$，其列为 $a_1(\\varepsilon) = e_1$ 和 $a_j(\\varepsilon) = \\varepsilon e_1 + \\sqrt{1-\\varepsilon^2} e_j$（对于 $j \\ge 2$）。\n\n1.  **单位列范数**：\n    - 对第 1 列：$\\|a_1\\|^2 = \\|e_1\\|^2 = 1^2 = 1$。\n    - 对第 $j \\in \\{2, \\dots, n\\}$ 列：向量 $e_1$ 和 $e_j$ 是正交的。根据勾股定理：\n      $\\|a_j\\|^2 = \\|\\varepsilon e_1 + \\sqrt{1-\\varepsilon^2} e_j\\|^2 = (\\varepsilon)^2 + (\\sqrt{1-\\varepsilon^2})^2 = \\varepsilon^2 + 1 - \\varepsilon^2 = 1$。\n    所有列都具有单位 $\\ell_2$-范数。\n\n2.  **互相关性**：我们计算不同列之间的内积。\n    - 对于 $j \\in \\{2, \\dots, n\\}$：\n      $\\langle a_1, a_j \\rangle = \\langle e_1, \\varepsilon e_1 + \\sqrt{1-\\varepsilon^2} e_j \\rangle = \\varepsilon \\langle e_1, e_1 \\rangle + \\sqrt{1-\\varepsilon^2} \\langle e_1, e_j \\rangle = \\varepsilon \\cdot 1 + 0 = \\varepsilon$。\n    - 对于 $i,j \\in \\{2, \\dots, n\\}$ 且 $i \\ne j$：\n      $\\langle a_i, a_j \\rangle = \\langle \\varepsilon e_1 + \\sqrt{1-\\varepsilon^2} e_i, \\varepsilon e_1 + \\sqrt{1-\\varepsilon^2} e_j \\rangle$。\n      利用 $\\{e_k\\}$ 的正交性展开此式：\n      $\\langle a_i, a_j \\rangle = \\varepsilon^2 \\langle e_1, e_1 \\rangle + (1-\\varepsilon^2) \\langle e_i, e_j \\rangle = \\varepsilon^2 \\cdot 1 + (1-\\varepsilon^2) \\cdot 0 = \\varepsilon^2$。\n    非对角内积的绝对值集合为 $\\{\\varepsilon, \\varepsilon^2\\}$。互相关性是这些值的最大值：\n    $\\mu(A(\\varepsilon)) = \\max \\{|\\varepsilon|, |\\varepsilon^2|\\}$。由于 $\\varepsilon \\in (0,1]$，我们有 $\\varepsilon > 0$ 且 $\\varepsilon^2 \\le \\varepsilon$。因此，$\\mu(A(\\varepsilon)) = \\varepsilon$。\n\n### 任务 C: 程序规范逻辑\n\n该程序将为 $n=8$ 且 $\\varepsilon$ 在 $(0,1]$ 中取多个值的测试套件实现指定的计算。对于每个测试用例 $(\\varepsilon, n)$：\n1.  根据任务 B 的推导，互相关性计算为 $\\mu = \\varepsilon$。\n2.  计算连续和整数稀疏度阈值：\n    $s_{\\mathrm{cont}}(\\mu) = \\frac{1}{2}(1+1/\\mu)$ 和 $s_{\\mathrm{int}}(\\mu) = \\lceil s_{\\mathrm{cont}}(\\mu)\\rceil - 1$。\n3.  计算缩放乘积 $\\mu \\cdot s_{\\mathrm{int}}(\\mu)$ 和相对偏差 $\\mathrm{rel\\_dev} = |s_{\\mathrm{cont}}(\\mu)-s_{\\mathrm{int}}(\\mu)|/s_{\\mathrm{cont}}(\\mu)$。\n4.  对稀疏度 $s = s_{\\mathrm{int}}(\\mu)$ 进行ERC的数值验证。\n    - 如果 $s_{\\mathrm{int}}(\\mu) > n-1$，则无法进行验证，$\\mathrm{erc\\_ok}$ 设为 $-1$。\n    - 否则，构造大小为 $n \\times n$ 的矩阵 $A(\\varepsilon)$。然后程序使用 `itertools.combinations` 穷举迭代所有大小为 $s_{\\mathrm{int}}(\\mu)$ 的支撑集 $S \\subset \\{1, \\dots, n\\}$。\n    - 对每个支撑集 $S$，程序计算在所有 $j \\notin S$ 上的 $\\|A_S^+ a_j\\|_1$ 的最大值。伪逆 $A_S^+$ 使用 `numpy.linalg.pinv` 计算。\n    - 确定在所有支撑集 $S$ 上的总最大值，记为 $T_{A,s_{\\mathrm{int}}}$。\n    - 如果 $T_{A,s_{\\mathrm{int}}}  1$，指示符 $\\mathrm{erc\\_ok}$ 设为 $1$，否则设为 $0$。\n5.  最后，为该测试用例生成一个包含 $[\\mu, s_{\\mathrm{int}}, \\mu \\cdot s_{\\mathrm{int}}, \\mathrm{rel\\_dev}, \\mathrm{erc\\_ok}]$ 的列表，其中所有浮点值都四舍五入到 $6$ 位小数。所有测试用例的结果将汇总成一个列表的列表作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy  # Per library specification, though not strictly used.\nimport math\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the problem by analyzing a parametrized matrix family A(eps)\n    and verifying the derived coherence-based exact recovery threshold.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (epsilon, n)\n        (0.5, 8),\n        (1/3, 8),\n        (0.2, 8),\n        (0.15, 8),\n        (0.1, 8),\n        (0.05, 8),\n    ]\n\n    all_results = []\n    for eps, n in test_cases:\n        # Per Task B, mu(A(eps)) = eps for eps in (0, 1].\n        mu = eps\n\n        # Compute coherence-based thresholds\n        s_cont = 0.5 * (1.0 + 1.0 / mu)\n        s_int = math.ceil(s_cont) - 1\n\n        # Compute derived quantities\n        mu_s_int = mu * s_int\n        if s_cont > 0:\n            rel_dev = abs(s_cont - s_int) / s_cont\n        else:\n            rel_dev = 0.0\n\n        # Numerically verify the Exact Recovery Condition (ERC)\n        erc_ok = -1\n        if s_int > n - 1:\n            erc_ok = -1\n        else:\n            # Construct the matrix A(eps)\n            A = np.zeros((n, n), dtype=float)\n            e1 = np.zeros(n, dtype=float)\n            e1[0] = 1.0\n            A[:, 0] = e1\n            for j in range(1, n):\n                ej = np.zeros(n, dtype=float)\n                ej[j] = 1.0\n                A[:, j] = eps * e1 + math.sqrt(1 - eps**2) * ej\n\n            # Exhaustively check all supports of size s_int\n            max_erc_val = 0.0\n            all_indices = set(range(n))\n            \n            # The number of combinations can be large, but for n=8 and s=7 it's feasible.\n            s = int(s_int)\n            # s=0 is trivial, ERC holds if defined. Let's assume s >= 1.\n            if s >= 1:\n                for s_indices in combinations(range(n), s):\n                    S = list(s_indices)\n                    J = list(all_indices - set(S))\n                    \n                    A_S = A[:, S]\n                    \n                    # Compute the Moore-Penrose pseudoinverse\n                    A_S_plus = np.linalg.pinv(A_S)\n                    \n                    for j in J:\n                        a_j = A[:, j]\n                        \n                        # Calculate the l1-norm of the projection\n                        norm_val = np.linalg.norm(A_S_plus @ a_j, ord=1)\n                        \n                        if norm_val > max_erc_val:\n                            max_erc_val = norm_val\n            \n            # The ERC is T_{A,s}  1\n            erc_ok = 1 if max_erc_val  1.0 else 0\n\n        # Assemble the list of results for this case, with rounding\n        case_result = [\n            round(mu, 6),\n            s_int,\n            round(mu_s_int, 6),\n            round(rel_dev, 6),\n            erc_ok\n        ]\n        all_results.append(case_result)\n\n    # Format the final output string as a list of lists\n    # e.g., [[val1, val2], [val3, val4]]\n    # Using str() on a list of lists produces the desired format with spaces.\n    # The problem asks for comma-separated list of lists, without specifying space behavior.\n    # Using a join of stringified lists is safer.\n    final_output_str = f\"[{','.join([str(res) for res in all_results])}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_str.replace(\" \", \"\"))\n\nsolve()\n```", "id": "3435250"}, {"introduction": "在掌握了基础的相干性保证之后，我们的第二个练习将带你探索该理论的边界 ([@problem_id:3435242])。我们将从另一个基本属性——零空间性质（Null Space Property, NSP）出发，再次推导恢复条件，并构造一类被称为等角紧框架（Equiangular Tight Frames, ETF）的“最优”测量矩阵。通过这个实践，你将亲手构建一个ETF，并展示一个恰好在理论保证边界上导致恢复失败的实例，从而深刻体会到该理论的“紧致性”。", "problem": "设 $A \\in \\mathbb{R}^{m \\times n}$ 是一个感知矩阵，其列 $\\{a_i\\}_{i=1}^n$ 是单位范数列向量。其互相关性定义为 $\\mu(A) \\triangleq \\max_{i \\neq j} \\left|\\langle a_i, a_j \\rangle \\right|$。考虑稀疏恢复问题：给定一个测量向量 $y = A x^\\star$，其中 $x^\\star \\in \\mathbb{R}^n$ 是 $s$-稀疏的（最多有 $s$ 个非零项），尝试通过 Basis Pursuit (BP) 恢复 $x^\\star$。BP 是一个 $\\ell_1$-最小化规划：\n$$\n\\min_{x \\in \\mathbb{R}^n} \\|x\\|_1 \\quad \\text{subject to} \\quad A x = y.\n$$\n你将构建一个特定的矩阵 $A$，它是一个等角紧框架 (Equiangular Tight Frame, ETF)，从第一性原理出发推导一个基于相关性的精确恢复保证，并通过显式的边界情况检验其紧致性。\n\n基本依据：\n- 仅使用以下基本概念。\n    1. 互相关性定义 $\\mu(A)$。\n    2. Basis Pursuit (BP) 的 $\\ell_1$-最小化形式。\n    3. Null Space Property (NSP)：一个矩阵 $A$ 能保证通过 BP 精确恢复所有 $s$-稀疏向量，当且仅当对于所有 $h \\in \\ker(A)$ 和所有索引集 $S \\subset \\{1,\\dots,n\\}$（其中 $|S| \\le s$），都有 $\\|h_S\\|_1  \\|h_{S^c}\\|_1$ 成立，其中 $S^c$ 是 $S$ 的补集。\n    4. Welch 界事实：对于单位范数列向量 $\\{a_i\\}_{i=1}^n \\subset \\mathbb{R}^m$，有 $\\mu(A) \\ge \\sqrt{\\frac{n-m}{m(n-1)}}$，并且当框架为等角紧框架时取等号。\n- 不要使用或假设任何预先推导出的稀疏度阈值公式。从 Null Space Property 和互相关性定义出发，推导基于相关性的精确恢复阈值。\n\n构建任务：\n- 使用正单纯形构造法，在 $\\mathbb{R}^m$ 中构建一个具有 $n = m+1$ 列的实数等角紧框架 (ETF)：\n    1. 设 $n = m+1$，并考虑向量 $w_i = e_i - \\frac{1}{n} \\mathbf{1} \\in \\mathbb{R}^n$，其中 $e_i$ 是标准基向量，$\\mathbf{1}$ 是全一向量。\n    2. 设 $Y \\in \\mathbb{R}^{n \\times m}$ 的列是标准正交的，构成与 $\\mathbf{1}$ 正交的子空间的基。\n    3. 定义 $A = \\alpha Y^\\top [w_1,\\dots,w_n] \\in \\mathbb{R}^{m \\times n}$ 并选择标量 $\\alpha$ 使得 $A$ 的列具有单位范数。\n- 通过计算所有列的成对内积以及框架算子 $A A^\\top$，数值上验证所得框架是等角且紧的。\n\n推导任务：\n- 从 Null Space Property 和仅有的互相关性界 $\\left|\\langle a_i, a_j \\rangle\\right| \\le \\mu(A)$（对于 $i \\neq j$）出发，推导一个关于稀疏度 $s$ 的充分条件（表示为一个包含 $\\mu(A)$ 和 $s$ 的不等式），在该条件下 BP 可以从 $y = A x^\\star$ 中精确恢复任何 $s$-稀疏的 $x^\\star$。\n\n紧致性与边界情况：\n- 使用所构建的具有 $n=m+1$ 列的 ETF，明确展示 BP 成功和失败的边界情况。你的边界情况必须依赖于单纯形 ETF 列之间的精确相关关系（而非随机试验）。特别地，当 $m$ 为偶数时（这样两个集合的大小不同），使用恒等式 $\\sum_{i=1}^n a_i = 0$ 来构建测量向量 $y$，使其允许两个具有不同 $\\ell_1$ 范数的稀疏表示，并验证 BP 是否选择了具有较小 $\\ell_1$ 范数的表示。\n\n测试套件：\n- 为以下参数值和支撑集实现上述过程；在每种情况下，将指定支撑集上的真实系数值设为 $+1$，其余设为零。设 $y = A x^\\star$。\n    1. $m=4$, $n=5$，支撑集 $S=\\{0,1\\}$（顺利通过路径，严格低于推导出的阈值）。\n    2. $m=4$, $n=5$，支撑集 $S=\\{2,3,4\\}$（边界情况；补集大小为 $2$）。\n    3. $m=6$, $n=7$，支撑集 $S=\\{0,1,2\\}$（顺利通过路径，严格低于推导出的阈值）。\n    4. $m=6$, $n=7$，支撑集 $S=\\{3,4,5,6\\}$（边界情况；补集大小为 $3$）。\n- 对于每种情况：\n    1. 从构建的 $A$ 中数值计算互相关性 $\\mu(A)$。\n    2. 检查 $s = |S|$ 是否严格满足推导出的基于相关性的稀疏度条件。\n    3. 通过线性规划求解 BP 以恢复 $\\hat{x}$，并以布尔值形式确定是否成功：如果 $\\|\\hat{x} - x^\\star\\|_\\infty \\le 10^{-6}$，则返回 true，否则返回 false。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含每个测试用例结果的列表。每个结果必须是按以下顺序包含四个条目的列表：\n    1. 数值互相关性 $\\mu(A)$，作为浮点数。\n    2. 稀疏度 $s$，作为整数。\n    3. 一个布尔值，指示是否严格满足推导出的基于相关性的条件。\n    4. 一个布尔值，指示 BP 对指定的真实值是否成功恢复。\n- 最终输出必须打印为这些四元组列表的单一列表，格式为精确的字符串 `“[case1,case2,case3,case4]”`，其中每个 case 本身都以 Python 风格的列表形式打印。", "solution": "我们从基本定义开始。设 $A \\in \\mathbb{R}^{m \\times n}$ 的列 $\\{a_i\\}_{i=1}^n$ 是单位范数列向量。互相关性为 $\\mu(A) \\triangleq \\max_{i \\neq j} |\\langle a_i, a_j \\rangle|$。$\\ell_1$-最小化规划 Basis Pursuit (BP) 寻求 $\\hat{x} = \\arg\\min \\|x\\|_1$ 且满足 $A x = y$，其中 $y = A x^\\star$ 且 $x^\\star$ 是 $s$-稀疏的。Null Space Property (NSP) 指出，BP 能精确恢复所有 $s$-稀疏信号，当且仅当对于每个 $h \\in \\ker(A)$ 和每个索引集 $S$（其中 $|S| \\le s$），我们有 $\\|h_S\\|_1  \\|h_{S^c}\\|_1$。\n\n我们推导一个基于相关性的 BP 精确恢复充分条件。设 $h \\in \\ker(A)$ 是一个非零向量。那么 $A h = 0$ 意味着 $A^\\top A h = 0$。对于每个 $i \\in \\{1,\\dots,n\\}$，\n$$\n0 = \\langle a_i, A h \\rangle = \\sum_{j=1}^n \\langle a_i, a_j \\rangle h_j = h_i + \\sum_{j \\ne i} \\langle a_i, a_j \\rangle h_j,\n$$\n这里我们用到了 $\\|a_i\\|_2 = 1$ 从而 $\\langle a_i, a_i \\rangle = 1$。因此\n$$\nh_i = - \\sum_{j \\ne i} \\langle a_i, a_j \\rangle h_j.\n$$\n取绝对值并使用 $|\\langle a_i, a_j \\rangle| \\le \\mu(A)$（对于 $i \\ne j$），我们得到\n$$\n|h_i| \\le \\sum_{j \\ne i} |\\langle a_i, a_j \\rangle| \\, |h_j| \\le \\mu(A) \\sum_{j \\ne i} |h_j|.\n$$\n固定一个支撑集 $S$，其中 $|S| \\le s$。将上述不等式对 $i \\in S$ 求和，得到\n$$\n\\sum_{i \\in S} |h_i| \\le \\mu(A) \\sum_{i \\in S} \\sum_{j \\ne i} |h_j| = \\mu(A) \\left( \\sum_{i \\in S} \\sum_{j \\in S, j \\ne i} |h_j| + \\sum_{i \\in S} \\sum_{j \\in S^c} |h_j| \\right).\n$$\n我们分别对这两项进行界定。对于支撑集内部的部分，\n$$\n\\sum_{i \\in S} \\sum_{j \\in S, j \\ne i} |h_j| = \\sum_{j \\in S} |h_j| \\cdot \\left(|S| - 1\\right) = \\left(|S| - 1\\right) \\|h_S\\|_1.\n$$\n对于跨支撑集的部分，\n$$\n\\sum_{i \\in S} \\sum_{j \\in S^c} |h_j| = |S| \\cdot \\|h_{S^c}\\|_1.\n$$\n合并得到\n$$\n\\|h_S\\|_1 \\le \\mu(A) \\left( \\left(|S| - 1\\right) \\|h_S\\|_1 + |S| \\cdot \\|h_{S^c}\\|_1 \\right).\n$$\n重新整理（假设 $\\mu(A)\\left(|S| - 1\\right)  1$ 以避免退化情况），\n$$\n\\left(1 - \\mu(A)\\left(|S| - 1\\right)\\right) \\|h_S\\|_1 \\le \\mu(A) |S| \\cdot \\|h_{S^c}\\|_1,\n$$\n因此\n$$\n\\|h_S\\|_1 \\le \\frac{\\mu(A) |S|}{1 - \\mu(A)\\left(|S| - 1\\right)} \\, \\|h_{S^c}\\|_1.\n$$\nNull Space Property 的一个充分条件是，对于所有 $|S| \\le s$，右侧的因子严格小于 $1$，即：\n$$\n\\frac{\\mu(A) s}{1 - \\mu(A)\\left(s - 1\\right)}  1.\n$$\n对这个不等式求解 $s$ 可得\n$$\n\\mu(A) s  1 - \\mu(A)\\left(s - 1\\right)\n\\quad \\Longleftrightarrow \\quad\n\\mu(A) s  1 - \\mu(A) s + \\mu(A)\n\\quad \\Longleftrightarrow \\quad\n2 \\mu(A) s  1 + \\mu(A)\n\\quad \\Longleftrightarrow \\quad\ns  \\frac{1}{2}\\left(1 + \\frac{1}{\\mu(A)}\\right).\n$$\n这就是 BP 精确恢复所有 $s$-稀疏信号的一个基于相关性的充分条件。\n\n接下来，我们使用正单纯形构造一个具有 $n=m+1$ 列的等角紧框架 (ETF)，它达到了最小相关性（即 Welch 界）。设 $n = m+1$，并定义向量 $w_i = e_i - \\frac{1}{n} \\mathbf{1} \\in \\mathbb{R}^n$。这些向量位于与 $\\mathbf{1}$ 正交的子空间中。为该子空间选择一个标准正交基 $Y \\in \\mathbb{R}^{n \\times m}$，并定义 $A = \\alpha Y^\\top [w_1,\\dots,w_n] \\in \\mathbb{R}^{m \\times n}$。选择标量 $\\alpha$ 使得 $A$ 的列具有单位范数。因为 $Y$ 的列是标准正交的，并且 $w_i$ 位于 $Y$ 的张成空间中，所以内积在 $Y^\\top$ 变换下得以保持。范数满足 $\\|w_i\\|_2^2 = 1 - \\frac{1}{n} = \\frac{n-1}{n}$，并且当 $i \\ne j$ 时 $w_i^\\top w_j = -\\frac{1}{n}$。通过标量 $\\alpha = \\sqrt{\\frac{n}{n-1}}$ 进行缩放后，$A$ 的列是单位范数的，并且其成对内积等于 $-\\frac{1}{n-1} = -\\frac{1}{m}$，因此 $\\mu(A) = \\frac{1}{m}$。此外，$A A^\\top = \\frac{n}{m} I_m$，这表明了其紧致性。\n\n我们现在通过显式的边界情况来解释基于相关性的阈值对于 ETF 的紧致性。对于单纯形 ETF，其列满足 $\\sum_{i=1}^n a_i = 0$。考虑 $m$ 为偶数，此时 $n = m+1$ 为奇数。对于一个子集 $S \\subset \\{1,\\dots,n\\}$，其大小为 $|S| = s = \\left\\lceil \\frac{m+1}{2} \\right\\rceil$，它的补集大小为 $n - s = \\left\\lfloor \\frac{m+1}{2} \\right\\rfloor$。那么\n$$\n\\sum_{i \\in S} a_i = - \\sum_{j \\in S^c} a_j.\n$$\n定义 $x^\\star$：当 $i \\in S$ 时 $x^\\star_i = 1$，否则为 $0$；那么 $y = A x^\\star = \\sum_{i \\in S} a_i = - \\sum_{j \\in S^c} a_j = A z$，其中当 $j \\in S^c$ 时 $z_j = -1$，否则为 $0$。这两个可行的表示具有 $\\ell_1$ 范数 $\\|x^\\star\\|_1 = |S|$ 和 $\\|z\\|_1 = |S^c|$。当 $m$ 为偶数时，$|S| > |S^c|$，因此在 $A x = y$ 条件下最小化 $\\ell_1$ 范数的 BP 会严格偏好补集表示，从而无法恢复 $x^\\star$。这具体地展示了在边界值处的失败，而严格不等式条件仍然保证在阈值以下的成功。对于严格低于所推导阈值的 $s$，NSP 成立，BP 对所有 $s$-稀疏的 $x^\\star$ 都能成功恢复。\n\n程序的算法设计：\n- 对于 $m \\in \\{4,6\\}$ 和 $n = m+1$，构建单纯形 ETF $A$：通过对列为 $e_k - e_n$（其中 $k=1, \\dots, n-1$）的矩阵进行瘦 QR 分解，构建与 $\\mathbf{1}$ 正交的子空间的标准正交基，然后用 $\\alpha = \\sqrt{\\frac{n}{n-1}}$ 形成 $A = \\alpha Y^\\top [w_1,\\dots,w_n]$。\n- 数值计算 $\\mu(A)$，即 $A^\\top A$ 的最大非对角线绝对值。\n- 推导基于相关性的严格稀疏度条件 $s  \\frac{1}{2} \\left(1 + \\frac{1}{\\mu(A)}\\right)$ 并对每个测试用例进行评估。\n- 通过线性规划求解 BP。引入辅助变量 $t \\in \\mathbb{R}^n$，约束条件为 $-t \\le x \\le t$ 和 $t \\ge 0$，并在 $A x = y$ 的条件下最小化 $\\sum_i t_i$。这是一个标准的 $\\ell_1$-到-线性规划的转换。使用数值容差来判断是否成功。\n- 对真实值使用指定的支撑集和单位系数：\n    1. $m=4$, $S=\\{0,1\\}$。\n    2. $m=4$, $S=\\{2,3,4\\}$。\n    3. $m=6$, $S=\\{0,1,2\\}$。\n    4. $m=6$, $S=\\{3,4,5,6\\}$。\n- 对于每种情况，以指定的单行输出格式返回元组 $[\\mu(A), s, \\text{strict\\_condition}, \\text{bp\\_success}]$。\n\n此设计忠实地结合了基本的 Null Space Property 和互相关性界来推导条件，构建了达到 Welch 界的等角紧框架，并通过在 $m$ 为偶数时具有严格更小 $\\ell_1$ 范数的显式稀疏备选解来展示边界情况，证明了所推导阈值的紧致性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef simplex_etf(m: int) -> np.ndarray:\n    \"\"\"\n    Construct an m x (m+1) real Equiangular Tight Frame (ETF) via the regular simplex.\n    Returns a matrix A with unit-norm equiangular columns and tight frame property.\n    \"\"\"\n    n = m + 1\n    # Build vectors w_i = e_i - (1/n) * 1 in R^n\n    W = np.eye(n) - (1.0 / n) * np.ones((n, n))  # columns are w_i\n    # Build an orthonormal basis Y of the subspace orthogonal to 1 (dimension m)\n    # Use B whose columns span 1^\\perp: B_k = e_k - e_n for k=1,...,n-1\n    B = np.zeros((n, m))\n    for k in range(m):\n        B[k, k] = 1.0\n        B[-1, k] = -1.0\n    # Thin QR to get orthonormal basis of span(B)\n    Q, R = np.linalg.qr(B, mode='reduced')  # Q is n x m with orthonormal columns\n    Y = Q  # columns of Y form an orthonormal basis of 1^\\perp\n    # Coordinates of w_i in the basis Y: A0 = Y^T W\n    A0 = Y.T @ W\n    # Normalize columns to unit norm using alpha = sqrt(n/(n-1))\n    alpha = np.sqrt(n / (n - 1))\n    A = alpha * A0\n    return A\n\ndef mutual_coherence(A: np.ndarray) -> float:\n    \"\"\"\n    Compute mutual coherence mu(A) as max absolute off-diagonal entry of Gram matrix.\n    Assumes columns of A are unit-norm.\n    \"\"\"\n    G = A.T @ A\n    # mask off-diagonals\n    off_diag = G - np.eye(G.shape[0])\n    mu = np.max(np.abs(off_diag))\n    return float(mu)\n\ndef basis_pursuit(A: np.ndarray, y: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Solve Basis Pursuit: minimize ||x||_1 subject to A x = y via linear programming.\n    Uses variable splitting with auxiliary t >= |x|.\n    Returns the recovered x.\n    \"\"\"\n    m, n = A.shape\n    # Variables: [x (n), t (n)]\n    num_vars = 2 * n\n    c = np.zeros(num_vars)\n    c[n:] = 1.0  # objective: minimize sum(t)\n    # Equality constraints: A x = y\n    A_eq = np.hstack([A, np.zeros((m, n))])\n    b_eq = y.copy()\n    # Inequality constraints: x - t = 0 and -x - t = 0\n    A_ub = np.zeros((2 * n, num_vars))\n    b_ub = np.zeros(2 * n)\n    # x - t = 0\n    for i in range(n):\n        A_ub[i, i] = 1.0\n        A_ub[i, n + i] = -1.0\n    # -x - t = 0  => -(x) - t = 0\n    for i in range(n):\n        A_ub[n + i, i] = -1.0\n        A_ub[n + i, n + i] = -1.0\n    # Bounds: x free, t >= 0\n    bounds = []\n    for i in range(n):\n        bounds.append((None, None))  # x_i free\n    for i in range(n):\n        bounds.append((0.0, None))   # t_i >= 0\n    # Solve LP\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    if not res.success:\n        raise RuntimeError(\"Basis Pursuit LP did not converge: \" + res.message)\n    x_rec = res.x[:n]\n    return x_rec\n\ndef run_case(m: int, support: list) -> list:\n    \"\"\"\n    Run a single test case: construct ETF, compute mu, threshold condition, and BP recovery.\n    Returns [mu, s, strict_condition, bp_success].\n    \"\"\"\n    A = simplex_etf(m)\n    mu = mutual_coherence(A)\n    n = m + 1\n    s = len(support)\n    # Ground truth x*: ones on support, zeros elsewhere\n    x_star = np.zeros(n)\n    x_star[support] = 1.0\n    y = A @ x_star\n    # Derived coherence-based strict condition: s  0.5 * (1 + 1 / mu)\n    threshold = 0.5 * (1.0 + 1.0 / mu)\n    strict_condition = (s  threshold)\n    # Solve BP\n    x_hat = basis_pursuit(A, y)\n    bp_success = bool(np.allclose(x_hat, x_star, atol=1e-6))\n    return [mu, s, strict_condition, bp_success]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (4, [0, 1]),            # Happy path: s=2 below threshold (2.5)\n        (4, [2, 3, 4]),         # Boundary failure: s=3, complement size 2, BP prefers complement\n        (6, [0, 1, 2]),         # Happy path: s=3 below threshold (3.5)\n        (6, [3, 4, 5, 6]),      # Boundary failure: s=4, complement size 3\n    ]\n\n    results = []\n    for m, support in test_cases:\n        result = run_case(m, support)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Each case is a list [mu, s, strict_condition, bp_success]\n    # Print as a single list of these lists.\n    def format_entry(entry):\n        # Ensure booleans print as True/False and floats/ints as default\n        return \"[\" + \",\".join([\n            f\"{entry[0]}\",  # mu float\n            f\"{entry[1]}\",  # s int\n            \"True\" if entry[2] else \"False\",  # strict_condition\n            \"True\" if entry[3] else \"False\"   # bp_success\n        ]) + \"]\"\n    print(\"[\" + \",\".join(format_entry(e) for e in results) + \"]\")\n\nsolve()\n```", "id": "3435242"}, {"introduction": "最后一个练习旨在揭示一个更深层次的观点：互相关性虽然是一个非常有用的工具，但它并不能完全决定恢复算法的成败 ([@problem_id:3435245])。我们将构造两个具有完全相同互相关性的矩阵，但它们在正交匹配追踪（Orthogonal Matching Pursuit, OMP）算法下的恢复表现却截然不同。这个练习将促使你思考超越单一指标的限制，并认识到矩阵的更精细结构（如子矩阵的谱特性）对稀疏恢复的关键影响。", "problem": "构建两个显式的实数字典 $A \\in \\mathbb{R}^{m \\times n}$ 和 $B \\in \\mathbb{R}^{m \\times n}$，它们具有相同的互相关性，但在精心选择的子格拉姆矩阵上具有不同的谱特性，并对几个稀疏信号，凭经验比较正交匹配追踪 (OMP) 的精确恢复情况。整个过程在实数上使用精确算术，不引入物理单位。无需引入角度。任务是根据第一性原理推导并实现以下流程：\n\n1. 定义和要使用的核心对象。\n   - 对于列为单位范数的字典 $D$，其互相关性 $\\mu(D)$ 定义为 $\\mu(D) \\triangleq \\max_{i \\neq j} \\left| \\langle d_i, d_j \\rangle \\right|$，其中 $d_i$ 表示 $D$ 的第 $i$ 列。对于非单位范数的列，格拉姆矩阵中的内积必须在列归一化后计算。\n   - 对于由有限集 $T \\subset \\{1,\\dots,n\\}$ 索引的列子集，其子格拉姆矩阵为 $G_T(D) \\triangleq D_T^\\top D_T$，其中 $D_T$ 是由索引在 $T$ 中的列构成的子矩阵。\n   - 正交匹配追踪 (OMP) 是一种用于稀疏恢复的贪心算法。给定一个字典 $D$、一个测量向量 $y$ 和一个目标稀疏度 $k$，OMP 迭代执行以下步骤：\n     - 选择一个索引，该索引使当前残差的相关性绝对值最大化。\n     - 扩充活动集。\n     - 在活动集上重新计算最小二乘拟合，并更新残差。\n     - 精确重复 $k$ 次迭代，并返回所选的支撑集。\n   - 对于给定实例，精确恢复意味着返回的支撑集等于真实的支撑集。\n\n2. 具体的字典。使用 $m = 4$ 和 $n = 5$。如下定义 $A$ 和 $B$ 的列，其中 $\\mathbf{e}_1,\\mathbf{e}_2,\\mathbf{e}_3,\\mathbf{e}_4$ 是 $\\mathbb{R}^4$ 中的标准基向量：\n   - 对于 $A$：\n     - $a_1 = \\mathbf{e}_1 = [1,0,0,0]^\\top$，\n     - $a_2 = \\mathbf{e}_2 = [0,1,0,0]^\\top$，\n     - $a_3 = \\mathbf{e}_3 = [0,0,1,0]^\\top$，\n     - $a_4 = \\left[\\frac{1}{2}, -\\frac{1}{2}, 0, \\frac{1}{\\sqrt{2}}\\right]^\\top$，\n     - $a_5 = \\left[\\frac{1}{2}, -\\frac{1}{2}, 0, -\\frac{1}{\\sqrt{2}}\\right]^\\top$。\n   - 对于 $B$：\n     - $b_1 = \\mathbf{e}_1 = [1,0,0,0]^\\top$，\n     - $b_2 = \\mathbf{e}_2 = [0,1,0,0]^\\top$，\n     - $b_3 = \\mathbf{e}_3 = [0,0,1,0]^\\top$，\n     - $b_4 = \\left[\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}\\right]^\\top$，\n     - $b_5 = -\\mathbf{e}_4 = [0,0,0,-1]^\\top$。\n   所有列都是单位范数。$A$ 和 $B$ 的互相关性均为 $\\mu = \\frac{1}{2}$，因为在各自按列归一化的格拉姆矩阵中，最大的非对角线元素的绝对值等于 $\\frac{1}{2}$。\n\n3. 用于谱特性比较的子格拉姆矩阵。设目标支撑集为 $S = \\{1,2,3\\}$，并定义 $T = S \\cup \\{4\\} = \\{1,2,3,4\\}$。您必须计算 $G_T(A)$ 和 $G_T(B)$ 的最小特征值。这些值捕捉了尽管 $A$ 和 $B$ 具有相同的互相关性，但列集合 $A_T$ 和 $B_T$ 的条件数有何不同。\n\n4. 稀疏信号的测试套件。对于每个测试，创建一个系数向量 $x \\in \\mathbb{R}^n$，并使用指定的 $D \\in \\{A,B\\}$ 计算 $y = D x$。对于所有测试，真实支撑集为 $S = \\{1,2,3\\}$。\n   - 情况 1（成功路径与失败模式）：$k=3$, $x = [1, 1, 1, 0, 0]^\\top$。\n   - 情况 2（基于相关性保证的边界情况）：$k=1$, $x = [1, 0, 0, 0, 0]^\\top$。\n   - 情况 3（小的相等系数，聚合相关性挑战）：$k=3$, $x = [0.2, 0.2, 0.2, 0, 0]^\\top$。\n   对于每种情况，使用 $D=A$ 和 $D=B$ 运行 OMP 精确 $k$ 次迭代，并报告恢复的支撑集是否等于 $S$。\n\n5. 要求的计算和输出。\n   - 计算 $\\mu(A)$ 和 $\\mu(B)$，并验证它们在数值容差 $\\tau = 10^{-12}$ 内是否相同，每个测试案例报告一个布尔值。\n   - 计算最小特征值 $\\lambda_{\\min}\\!\\left(G_T(A)\\right)$ 和 $\\lambda_{\\min}\\!\\left(G_T(B)\\right)$。\n   - 对于每种情况，按规定运行 OMP，并报告两个布尔值，分别表示使用 $A$ 和使用 $B$ 是否实现了精确支撑集恢复。\n   - 对于每种情况，将结果汇总到一个列表中：\n     - $\\left[\\text{mu\\_equal}, \\lambda_{\\min}\\!\\left(G_T(A)\\right), \\lambda_{\\min}\\!\\left(G_T(B)\\right), \\text{omp\\_success\\_A}, \\text{omp\\_success\\_B}\\right]$,\n     其中 $\\text{mu\\_equal}$、$\\text{omp\\_success\\_A}$ 和 $\\text{omp\\_success\\_B}$ 是布尔值，特征值是四舍五入到 $6$ 位小数的浮点数。\n   - 最终输出格式：您的程序应生成一行输出，包含三个按案例排列的结果列表，即，一行看起来像 $[\\text{case1\\_result},\\text{case2\\_result},\\text{case3\\_result}]$，没有多余的空格或文本。例如：$[[\\text{...}],[\\text{...}],[\\text{...}]]$。\n\n确保您的实现不读取输入，并使用具有固定数值比较容差的确定性线性代数。完全按照上述描述实现正交匹配追踪 (OMP)，在每种情况下精确迭代 $k$ 次后停止。在评估互相关性时，所有内积和格拉姆矩阵必须在列归一化后计算。按规定将浮点特征值四舍五入到 $6$ 位小数。", "solution": "该问题要求构建和分析两个字典 $A$ 和 $B$，以展示子格拉姆矩阵的谱特性（而不仅仅是互相关性）如何影响稀疏恢复算法（如正交匹配追踪 OMP）的成功。我们将首先定义数学对象，然后计算所需指标，最后模拟 OMP 以验证理论预测。\n\n给定 $m=4$ 和 $n=5$ 的字典 $A, B \\in \\mathbb{R}^{m \\times n}$。令 $\\mathbf{e}_i$ 为 $\\mathbb{R}^4$ 中的第 $i$ 个标准基向量。\n\n字典 $A$ 的列为：\n- $a_1 = [1, 0, 0, 0]^\\top$\n- $a_2 = [0, 1, 0, 0]^\\top$\n- $a_3 = [0, 0, 1, 0]^\\top$\n- $a_4 = \\left[\\frac{1}{2}, -\\frac{1}{2}, 0, \\frac{1}{\\sqrt{2}}\\right]^\\top$\n- $a_5 = \\left[\\frac{1}{2}, -\\frac{1}{2}, 0, -\\frac{1}{\\sqrt{2}}\\right]^\\top$\n\n字典 $B$ 的列为：\n- $b_1 = [1, 0, 0, 0]^\\top$\n- $b_2 = [0, 1, 0, 0]^\\top$\n- $b_3 = [0, 0, 1, 0]^\\top$\n- $b_4 = \\left[\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}\\right]^\\top$\n- $b_5 = [0, 0, 0, -1]^\\top$\n\n经验证，两个字典的所有列的欧几里得范数均为 $1$。\n\n对于列为单位范数的字典 $D$，其互相关性 $\\mu(D)$ 为 $\\mu(D) = \\max_{i \\neq j} |\\langle d_i, d_j \\rangle|$。这是格拉姆矩阵 $G(D) = D^\\top D$ 的最大绝对非对角元素。\n\n对于字典 $A$，格拉姆矩阵 $G(A) = A^\\top A$ 为：\n$$ G(A) = \\begin{pmatrix}\n1   0   0   1/2   1/2 \\\\\n0   1   0   -1/2  -1/2 \\\\\n0   0   1   0   0 \\\\\n1/2  -1/2  0   1   0 \\\\\n1/2  -1/2  0   0   1\n\\end{pmatrix} $$\n最大绝对非对角值为 $|\\pm 1/2| = 1/2$。因此，$\\mu(A) = 1/2$。\n\n对于字典 $B$，格拉姆矩阵 $G(B) = B^\\top B$ 为：\n$$ G(B) = \\begin{pmatrix}\n1  0  0  1/2  0 \\\\\n0  1  0  1/2  0 \\\\\n0  0  1  1/2  0 \\\\\n1/2  1/2  1/2  1  0 \\\\\n0  0  0  0  1\n\\end{pmatrix} $$\n最大绝对非对角值为 $1/2$。因此，$\\mu(B) = 1/2$。\n互相关性相同：$\\mu(A) = \\mu(B) = 1/2$。\n\n接下来，我们分析子格拉姆矩阵的谱特性。指定的索引集为 $T = \\{1, 2, 3, 4\\}$，其中包含真实支撑集 $S = \\{1, 2, 3\\}$ 和一个干扰原子。子格拉姆矩阵为 $G_T(A) = A_T^\\top A_T$ 和 $G_T(B) = B_T^\\top B_T$。\n\n子矩阵 $A_T$ 由列 $a_1, a_2, a_3, a_4$ 组成。其格拉姆矩阵为：\n$$ G_T(A) = \\begin{pmatrix}\n1  0  0  1/2 \\\\\n0  1  0  -1/2 \\\\\n0  0  1  0 \\\\\n1/2  -1/2  0  1\n\\end{pmatrix} $$\n特征多项式为 $\\det(G_T(A) - \\lambda I) = (1-\\lambda)^2 ((1-\\lambda)^2 - 1/2)$。特征值为 $\\lambda \\in \\{1, 1, 1 - 1/\\sqrt{2}, 1 + 1/\\sqrt{2}\\}$。最小特征值为 $\\lambda_{\\min}(G_T(A)) = 1 - 1/\\sqrt{2} \\approx 0.292893$。\n\n子矩阵 $B_T$ 由列 $b_1, b_2, b_3, b_4$ 组成。其格拉姆矩阵为：\n$$ G_T(B) = \\begin{pmatrix}\n1  0  0  1/2 \\\\\n0  1  0  1/2 \\\\\n0  0  1  1/2 \\\\\n1/2  1/2  1/2  1\n\\end{pmatrix} $$\n特征多项式为 $\\det(G_T(B) - \\lambda I) = (1-\\lambda)^2 ((1-\\lambda)^2 - 3/4)$。特征值为 $\\lambda \\in \\{1, 1, 1 - \\sqrt{3}/2, 1 + \\sqrt{3}/2\\}$。最小特征值为 $\\lambda_{\\min}(G_T(B)) = 1 - \\sqrt{3}/2 \\approx 0.133975$。\n\n格拉姆矩阵的最小特征值量化了其列的线性无关性程度。值越小，表示这些列“越接近”线性相关。此处，$\\lambda_{\\min}(G_T(B))  \\lambda_{\\min}(G_T(A))$，表明原子集 $\\{b_1, b_2, b_3, b_4\\}$ 的性态比 $\\{a_1, a_2, a_3, a_4\\}$ 更差。这是解释 OMP 性能差异的关键。\n\n正交匹配追踪 (OMP) 是一种迭代贪心算法。对于给定的稀疏度 $k$、字典 $D$ 和测量值 $y = Dx$，它按以下方式操作，迭代 $i=1, \\dots, k$：\n1. 初始化：残差 $r_0 = y$，支撑集 $\\Lambda_0 = \\emptyset$。\n2. 原子选择：找到索引 $j_i = \\arg\\max_{j} |\\langle d_j, r_{i-1} \\rangle|$。\n3. 支撑集更新：$\\Lambda_i = \\Lambda_{i-1} \\cup \\{j_i\\}$。\n4. 信号更新和残差计算：求解最小二乘问题 $x_i = \\arg\\min_{z} \\|y - D_{\\Lambda_i} z\\|_2^2$。新残差为 $r_i = y - D_{\\Lambda_i} x_i$。这等价于将 $y$ 投影到由 $D_{\\Lambda_i}$ 张成的子空间的正交补空间上，即 $r_i = (I - P_{\\Lambda_i})y$，其中 $P_{\\Lambda_i}$ 是投影矩阵。\n最终恢复的支撑集是 $\\Lambda_k$。\n\n我们使用此过程分析测试案例。注意，在实现中索引是基于0的，所以 $S=\\{0,1,2\\}$。\n\n情况 1：$k=3$，$x=[1, 1, 1, 0, 0]^\\top$。真实支撑集是 $S=\\{0,1,2\\}$。\n- 对于字典 $A$：$y_A = A x = a_1 + a_2 + a_3 = [1, 1, 1, 0]^\\top$。OMP 以残差 $r_0 = y_A$ 开始。相关性为 $|\\langle a_1, r_0 \\rangle|=1$、 $|\\langle a_2, r_0 \\rangle|=1$、 $|\\langle a_3, r_0 \\rangle|=1$，其他为 $0$。假设若出现相等情况则选择最小的索引，OMP 将依次选择原子 $0, 1, 2$。恢复的支撑集是 $\\{0, 1, 2\\}$，与 $S$ 相等。因此，恢复成功。\n- 对于字典 $B$：$y_B = B x = b_1 + b_2 + b_3 = [1, 1, 1, 0]^\\top$。初始残差为 $r_0=y_B$。相关性为 $|\\langle b_1, r_0 \\rangle|=1$、 $|\\langle b_2, r_0 \\rangle|=1$、 $|\\langle b_3, r_0 \\rangle|=1$，但是 $|\\langle b_4, r_0 \\rangle| = |\\langle b_4, b_1+b_2+b_3 \\rangle| = |\\frac{1}{2}+\\frac{1}{2}+\\frac{1}{2}|=1.5$。OMP 在第一步错误地选择了原子 $3$（对应于 $b_4$），因为它具有最高的相关性。最终的支撑集不可能是 $S$。恢复失败。这一失败是 $B_T$ 性态不佳的直接后果，正如其较小的 $\\lambda_{\\min}$ 所指示的。原子 $b_4$ 与真实原子 $b_1+b_2+b_3$ 的线性组合高度相关。\n\n情况 2：$k=1$，$x=[1, 0, 0, 0, 0]^\\top$。真实支撑集是 $\\{0\\}$。\n问题规定恢复的支撑集应与 $S=\\{0,1,2\\}$ 进行比较。\n- 对于字典 $A$：$y_A = a_1 = [1, 0, 0, 0]^\\top$。对于 $k=1$，OMP 选择与 $y_A$ 相关性最高的原子。这显然是 $a_1$（索引 $0$），相关性为 $1$。恢复的支撑集是 $\\{0\\}$。由于 $\\{0\\} \\neq \\{0, 1, 2\\}$，该测试被视为失败。\n- 对于字典 $B$：$y_B = b_1 = [1, 0, 0, 0]^\\top$。类似地，OMP 选择原子 $b_1$（索引 $0$）。恢复的支撑集是 $\\{0\\}$，不等于 $S=\\{0, 1, 2\\}$。测试失败。\n在这两个子情况中，OMP 正确地识别了真实的 1-稀疏支撑集，但由于与指定的 3 元素集进行比较而导致测试失败。\n\n情况 3：$k=3$，$x=[0.2, 0.2, 0.2, 0, 0]^\\top$。真实支撑集是 $S=\\{0,1,2\\}$。\n这种情况是情况 1 的一个缩放版本。测量向量 $y$ 只是情况 1 中向量的 $0.2$ 倍。OMP 的选择标准 $\\arg\\max_{j} |\\langle d_j, r_{i-1} \\rangle|$ 对于测量向量（以及所有后续残差）的正数缩放是不变的。因此，对于两个字典，选定原子的序列将与情况 1 完全相同。\n- 对于字典 $A$：恢复成功，得到支撑集 $\\{0, 1, 2\\}$。\n- 对于字典 $B$：恢复失败，因为原子 $3$ 首先被选中。\n\n结果证实，即使互相关性相同，原子子集之间的相关性分布（由子格拉姆矩阵的谱特性所捕捉）对于稀疏恢复而言是一个更具决定性的因素。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the compressed sensing problem by defining two dictionaries,\n    calculating their properties, and running Orthogonal Matching Pursuit (OMP).\n    \"\"\"\n\n    # 1. Define Dictionaries A and B\n    sqrt2 = np.sqrt(2.0)\n    A = np.array([\n        [1.0, 0.0, 0.0, 0.5, 0.5],\n        [0.0, 1.0, 0.0, -0.5, -0.5],\n        [0.0, 0.0, 1.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0, 1.0 / sqrt2, -1.0 / sqrt2]\n    ])\n\n    B = np.array([\n        [1.0, 0.0, 0.0, 0.5, 0.0],\n        [0.0, 1.0, 0.0, 0.5, 0.0],\n        [0.0, 0.0, 1.0, 0.5, 0.0],\n        [0.0, 0.0, 0.0, 0.5, -1.0]\n    ])\n\n    def get_mutual_coherence(D):\n        \"\"\"Computes the mutual coherence of a dictionary.\"\"\"\n        # Normalize columns to be safe, as per problem description\n        D_norm = D / np.linalg.norm(D, axis=0)\n        gram_matrix = D_norm.T @ D_norm\n        np.fill_diagonal(gram_matrix, 0)\n        return np.max(np.abs(gram_matrix))\n\n    def get_min_eigenvalue_subgram(D, T_indices):\n        \"\"\"Computes the minimum eigenvalue of a sub-Gram matrix.\"\"\"\n        D_T = D[:, T_indices]\n        G_T = D_T.T @ D_T\n        # use eigvalsh for Hermitian matrices\n        eigenvalues = np.linalg.eigvalsh(G_T)\n        return np.min(eigenvalues)\n\n    def omp(D, y, k):\n        \"\"\"\n        Orthogonal Matching Pursuit algorithm.\n        Stops after exactly k iterations.\n        \"\"\"\n        num_atoms = D.shape[1]\n        residual = np.copy(y)\n        support = []\n        \n        for _ in range(k):\n            correlations = np.abs(D.T @ residual)\n            # Mask already selected atoms\n            if support:\n                correlations[support] = -1\n            \n            # Find the best atom (smallest index in case of a tie)\n            best_atom_idx = np.argmax(correlations)\n            support.append(best_atom_idx)\n\n            # Update residual using projection\n            D_support = D[:, sorted(support)]\n            \n            # Solve least squares: x = (D_S^T D_S)^-1 D_S^T y\n            # Using pseudoinverse for stability, although solve would also work\n            # as submatrices are full rank here.\n            x_support = np.linalg.pinv(D_support) @ y\n            \n            # Update residual\n            residual = y - D_support @ x_support\n            \n        return set(sorted(support))\n\n    # 2. Define Test Cases and Fixed Parameters\n    T_indices = [0, 1, 2, 3] # Indices for sub-Gram matrix, 0-based {1,2,3,4}\n    S_target = {0, 1, 2}     # Target support set, 0-based {1,2,3}\n    \n    test_cases = [\n        # k, x_coeffs\n        (3, np.array([1.0, 1.0, 1.0, 0.0, 0.0])),\n        (1, np.array([1.0, 0.0, 0.0, 0.0, 0.0])),\n        (3, np.array([0.2, 0.2, 0.2, 0.0, 0.0])),\n    ]\n\n    # Pre-compute dictionary properties as they are the same for all cases\n    mu_A = get_mutual_coherence(A)\n    mu_B = get_mutual_coherence(B)\n    mu_equal = abs(mu_A - mu_B)  1e-12\n\n    lambda_min_A = get_min_eigenvalue_subgram(A, T_indices)\n    lambda_min_B = get_min_eigenvalue_subgram(B, T_indices)\n\n    results = []\n    for k, x in test_cases:\n        # Generate measurement vectors\n        y_A = A @ x\n        y_B = B @ x\n\n        # Run OMP\n        recovered_support_A = omp(A, y_A, k)\n        recovered_support_B = omp(B, y_B, k)\n\n        # Check for exact recovery against the specified target set S\n        omp_success_A = (recovered_support_A == S_target)\n        omp_success_B = (recovered_support_B == S_target)\n\n        # Aggregate results for the case\n        case_result = [\n            mu_equal,\n            round(lambda_min_A, 6),\n            round(lambda_min_B, 6),\n            omp_success_A,\n            omp_success_B\n        ]\n        results.append(case_result)\n        \n    # Final print statement in the exact required format.\n    # The string representation of list of lists is \"[...], [...]\"\n    # We join these with commas and wrap in an outer \"[]\"\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\nsolve()\n```", "id": "3435245"}]}