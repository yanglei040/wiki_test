{"hands_on_practices": [{"introduction": "这个基础练习旨在巩固矩阵的条件数与其伪逆的条件数之间的重要关系。通过计算一个具体矩阵的 2-范数条件数，你将亲手验证 $\\kappa_2(A^\\dagger) = \\kappa_2(A)$ 这一属性，并加深对奇异值在决定矩阵数值稳定性中核心作用的理解。这个练习是后续更高级分析的基石。[@problem_id:959945]", "problem": "计算矩阵\n$$  \nA = \\begin{bmatrix}  \n2  1 \\\\  \n1  2 \\\\  \n1  1  \n\\end{bmatrix}  \n$$  \n的伪逆的 2-范数条件数 $\\kappa_2$。\n矩阵 $B$ 的伪逆记作 $B^\\dagger$。2-范数条件数定义为 $\\kappa_2(B) = \\|B\\|_2 \\|B^\\dagger\\|_2$。对于 $A$ 的伪逆，计算 $\\kappa_2(A^\\dagger)$。", "solution": "为了计算矩阵 $A$ 的伪逆的 2-范数条件数 $\\kappa_2(A^\\dagger)$，我们采用以下关键步骤：\n\n\n### 步骤 1：$\\kappa_2(A^\\dagger)$ 与 $\\kappa_2(A)$ 之间的关系\n矩阵 $B$ 的 2-范数条件数定义为 $\\kappa_2(B) = \\|B\\|_2 \\|B^\\dagger\\|_2$。对于 $B = A^\\dagger$，上式变为：\n\n$$\n\\kappa_2(A^\\dagger) = \\|A^\\dagger\\|_2 \\|(A^\\dagger)^\\dagger\\|_2\n$$\n  \n根据 Moore-Penrose 伪逆的性质，$(A^\\dagger)^\\dagger = A$。因此：\n\n$$\n\\kappa_2(A^\\dagger) = \\|A^\\dagger\\|_2 \\|A\\|_2\n$$\n  \n这正是矩阵 $A$ 的 2-范数条件数，所以 $\\kappa_2(A^\\dagger) = \\kappa_2(A)$。\n\n\n### 步骤 2：$A$ 的奇异值\n$A$ 的 2-范数条件数是 $\\kappa_2(A) = \\frac{\\sigma_1}{\\sigma_r}$，其中 $\\sigma_1$ 是 $A$ 的最大奇异值，$\\sigma_r$ 是最小的非零奇异值。$A$ 的奇异值是 $A^\\top A$ 的特征值的平方根。\n\n对于 $A = \\begin{bmatrix} 2  1 \\\\ 1  2 \\\\ 1  1 \\end{bmatrix}$，计算 $A^\\top A$：\n\n$$\nA^\\top A = \\begin{bmatrix} 2  1  1 \\\\ 1  2  1 \\end{bmatrix} \\begin{bmatrix} 2  1 \\\\ 1  2 \\\\ 1  1 \\end{bmatrix} = \\begin{bmatrix} 6  5 \\\\ 5  6 \\end{bmatrix}\n$$\n\n\n\n### 步骤 3：$A^\\top A$ 的特征值\n$A^\\top A$ 的特征方程是 $\\det(A^\\top A - \\lambda I) = 0$：\n\n$$\n\\det\\left(\\begin{bmatrix} 6-\\lambda  5 \\\\ 5  6-\\lambda \\end{bmatrix}\\right) = (6-\\lambda)^2 - 5^2 = (\\lambda - 11)(\\lambda - 1) = 0\n$$\n  \n因此，特征值为 $\\lambda_1 = 11$ 和 $\\lambda_2 = 1$。\n\n\n### 步骤 4：奇异值和条件数\n$A$ 的奇异值为 $\\sigma_1 = \\sqrt{\\lambda_1} = \\sqrt{11}$ (最大) 和 $\\sigma_2 = \\sqrt{\\lambda_2} = 1$ (最小非零)。因此：\n\n$$\n\\kappa_2(A) = \\frac{\\sigma_1}{\\sigma_2} = \\frac{\\sqrt{11}}{1} = \\sqrt{11}\n$$\n  \n\n\n因为 $\\kappa_2(A^\\dagger) = \\kappa_2(A)$，我们得出结论 $\\kappa_2(A^\\dagger) = \\sqrt{11}$。", "answer": "$$\\boxed{\\sqrt{11}}$$", "id": "959945"}, {"introduction": "从计算转向诠释，本练习将探讨伪逆范数的实际物理意义。你将推导在最小二乘估计中，伪逆的算子范数如何精确量化最坏情况下的噪声放大效应。通过设计一个“对抗性”噪声向量来最大化估计误差，这个练习将抽象的数学概念与可量化的实际后果直接联系起来。[@problem_id:3471152]", "problem": "考虑压缩感知中的一个线性测量模型，$y = A x + e$，其中 $A \\in \\mathbb{R}^{m \\times n}$ 是一个传感矩阵，满足 $m \\geq n$，$x \\in \\mathbb{R}^{n}$ 是一个 k-稀疏向量，其支撑集为 $S \\subset \\{1,\\dots,n\\}$，大小为 $|S| = k$，而 $e \\in \\mathbb{R}^{m}$ 是一个加性噪声向量。假设一个预言机提供了正确的支撑集 $S$，并且 $S$ 上的系数通过约束在支撑集上的最小二乘（LS）法进行估计，即 $\\hat{x}_{S} = \\arg\\min_{z \\in \\mathbb{R}^{n}:\\,\\mathrm{supp}(z)\\subseteq S} \\|y - A z\\|_{2}^{2}$，且 $\\hat{x}_{S^{c}} = 0$。设 $A_{S} \\in \\mathbb{R}^{m \\times k}$ 表示由 $S$ 索引的 $A$ 的列组成的子矩阵，并假设 $A_{S}$ 具有满列秩。$A_{S}$ 的摩尔-彭罗斯伪逆记为 $A_{S}^{\\dagger}$。\n\n仅从摩尔-彭罗斯伪逆、由欧几里得范数诱导的算子范数以及奇异值分解（SVD）的定义出发，执行以下操作：\n\n1. 推导支撑集约束的最小二乘估计的精确最坏情况噪声放大因子，即值\n$$\n\\sup_{e \\neq 0} \\frac{\\|\\hat{x} - x\\|_{2}}{\\|e\\|_{2}},\n$$\n并纯粹用 $A_{S}$ 的奇异值表示。\n\n2. 确定一个能达到该上确界的噪声方向 $e$（作为 $A_{S}$ 的函数），并解释为什么这个方向在最大化支撑集上估计误差的意义上是对抗性的。\n\n3. 现在考虑以下具体实例：设 $m = 6$, $k = 3$，并假设 $A_S$ 的非零奇异值按非增序排列为 $\\sigma_{1} = 5$, $\\sigma_{2} = 3$ 和 $\\sigma_{3} = \\tfrac{1}{5}$。如果噪声的欧几里得范数为 $\\|e\\|_{2} = \\tfrac{1}{50}$，并且噪声如第2项中所述被对抗性地选择，计算估计误差范数 $\\|\\hat{x} - x\\|_{2}$ 的最大可能值。\n\n请以单个实数形式提供最终答案。无需四舍五入，也不涉及任何单位。", "solution": "在尝试任何解答之前，对问题进行验证。\n\n### 步骤 1：提取已知条件\n- 线性测量模型为 $y = A x + e$。\n- $A \\in \\mathbb{R}^{m \\times n}$ 是一个传感矩阵，满足 $m \\geq n$。\n- $x \\in \\mathbb{R}^{n}$ 是一个 k-稀疏向量，其支撑集为 $S \\subset \\{1,\\dots,n\\}$，基数为 $|S| = k$。\n- $e \\in \\mathbb{R}^{m}$ 是一个加性噪声向量。\n- 支撑集 $S$ 是已知的（由一个预言机提供）。\n- 估计值 $\\hat{x}$ 是通过支撑集约束的最小二乘（LS）法获得的：$\\hat{x}_{S} = \\arg\\min_{z \\in \\mathbb{R}^{n}:\\,\\mathrm{supp}(z)\\subseteq S} \\|y - A z\\|_{2}^{2}$，且 $\\hat{x}$ 在支撑集 $S$ 之外的分量为零，即 $\\hat{x}_{S^{c}} = 0$。\n- $A_{S} \\in \\mathbb{R}^{m \\times k}$ 是由 $S$ 索引的 $A$ 的列组成的子矩阵。\n- $A_{S}$ 具有满列秩。\n- $A_{S}^{\\dagger}$ 表示 $A_{S}$ 的摩尔-彭罗斯伪逆。\n- 任务 1：推导最坏情况噪声放大因子 $\\sup_{e \\neq 0} \\frac{\\|\\hat{x} - x\\|_{2}}{\\|e\\|_{2}}$，并用 $A_{S}$ 的奇异值表示。\n- 任务 2：确定一个能达到该上确界的对抗性噪声方向 $e$。\n- 任务 3：对于 $m=6$, $k=3$，$A_S$ 的非零奇异值为 $\\sigma_{1} = 5$, $\\sigma_{2} = 3$, $\\sigma_{3} = \\frac{1}{5}$，以及 $\\|e\\|_{2} = \\frac{1}{50}$ 且噪声方向为对抗性的具体情况，计算 $\\|\\hat{x} - x\\|_{2}$ 的最大值。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在科学上根植于线性代数、数值分析和压缩感知等领域。所有术语，如“摩尔-彭罗斯伪逆”、“奇异值分解”、“最小二乘”和“k-稀疏”，都定义明确且是标准术语。问题的设定是自洽的且内部一致的。$A_S$ 具有满列秩的条件至关重要，它确保了最小二乘问题的适定性。该问题是客观的，陈述精确，不包含任何事实错误、谬误或歧义。它需要严谨的数学推导，然后进行具体的计算，这是一个有效且非平凡的任务。\n\n### 步骤 3：结论与行动\n该问题被视为有效。将提供完整解答。\n\n### 解题推导\n\n分析始于对支撑集约束的最小二乘估计的公式化。设 $x_S \\in \\mathbb{R}^k$ 是 $x$ 在支撑集 $S$ 上的非零系数向量。测量模型可以写成 $y = A_S x_S + e$。$x_S$ 的最小二乘估计量记为 $\\hat{x}_S$，它是 $\\min_{z_S \\in \\mathbb{R}^k} \\|y - A_S z_S\\|_2^2$ 的解。\n\n该最小二乘问题的正规方程组为 $(A_S^T A_S) \\hat{x}_S = A_S^T y$。由于 $A_S$ 是一个具有满列秩（给定 $m \\geq k$）的 $m \\times k$ 矩阵，因此 $k \\times k$ 矩阵 $A_S^T A_S$ 是可逆的。因此，唯一解为 $\\hat{x}_S = (A_S^T A_S)^{-1} A_S^T y$。这个表达式正是一个具有满列秩矩阵的摩尔-彭罗斯伪逆的定义，因此我们有 $\\hat{x}_S = A_S^\\dagger y$。\n\n估计误差向量为 $\\hat{x} - x$。由于 $\\hat{x}$ 和 $x$ 的支撑集都包含在 $S$ 中，它们的差的支撑集也在 $S$ 上。误差向量的非零部分是 $\\hat{x}_S - x_S$。我们可以用噪声向量 $e$ 来表示这个误差：\n$$\n\\hat{x}_S - x_S = A_S^\\dagger y - x_S = A_S^\\dagger(A_S x_S + e) - x_S = (A_S^\\dagger A_S) x_S + A_S^\\dagger e - x_S\n$$\n对于具有满列秩的矩阵 $A_S$，$A_S^\\dagger A_S = I_k$，其中 $I_k$ 是 $k \\times k$ 的单位矩阵。因此，方程简化为：\n$$\n\\hat{x}_S - x_S = I_k x_S + A_S^\\dagger e - x_S = A_S^\\dagger e\n$$\n总估计误差的欧几里得范数为 $\\|\\hat{x} - x\\|_2 = \\|\\hat{x}_S - x_S\\|_2 = \\|A_S^\\dagger e\\|_2$。\n\n**1. 最坏情况噪声放大因子**\n\n我们被要求找出量 $\\sup_{e \\neq 0} \\frac{\\|\\hat{x} - x\\|_{2}}{\\|e\\|_{2}}$。代入误差范数的表达式，我们得到：\n$$\n\\sup_{e \\neq 0} \\frac{\\|A_S^\\dagger e\\|_{2}}{\\|e\\|_{2}}\n$$\n这是矩阵 $A_S^\\dagger$ 的算子范数（或谱范数）的定义，记为 $\\|A_S^\\dagger\\|_2$。为了用 $A_S$ 的奇异值来表示它，我们使用奇异值分解（SVD）。设 $A_S$ 的 SVD 为 $A_S = U \\Sigma V^T$，其中 $U \\in \\mathbb{R}^{m \\times k}$ 是一个具有标准正交列的矩阵（$U^T U = I_k$），$V \\in \\mathbb{R}^{k \\times k}$ 是一个正交矩阵（$V^T V = V V^T = I_k$），$\\Sigma \\in \\mathbb{R}^{k \\times k}$ 是一个包含奇异值 $\\sigma_1 \\geq \\sigma_2 \\geq \\dots \\geq \\sigma_k > 0$ 的对角矩阵。因为 $A_S$ 具有满列秩，所以奇异值均为正。\n\n伪逆 $A_S^\\dagger$ 的 SVD 形式为 $A_S^\\dagger = V \\Sigma^{-1} U^T$。$A_S^\\dagger$ 的奇异值是 $\\Sigma^{-1}$ 的对角元素，即 $\\frac{1}{\\sigma_1}, \\frac{1}{\\sigma_2}, \\dots, \\frac{1}{\\sigma_k}$。\n由于一个矩阵的算子范数是其最大的奇异值，我们有：\n$$\n\\|A_S^\\dagger\\|_2 = \\max\\left(\\frac{1}{\\sigma_1}, \\frac{1}{\\sigma_2}, \\dots, \\frac{1}{\\sigma_k}\\right)\n$$\n给定排序 $\\sigma_1 \\geq \\dots \\geq \\sigma_k > 0$，它们的倒数的最大值是 $\\frac{1}{\\sigma_k}$。因此，最坏情况噪声放大因子是：\n$$\n\\sup_{e \\neq 0} \\frac{\\|\\hat{x} - x\\|_{2}}{\\|e\\|_{2}} = \\|A_S^\\dagger\\|_2 = \\frac{1}{\\sigma_k} = \\frac{1}{\\sigma_{\\min}(A_S)}\n$$\n其中 $\\sigma_{\\min}(A_S)$ 是 $A_S$ 的最小奇异值。\n\n**2. 对抗性噪声方向**\n\n比率 $\\frac{\\|A_S^\\dagger e\\|_2}{\\|e\\|_2}$ 的上确界在向量 $e$ 与 $A_S^\\dagger$ 的最大奇异值所对应的右奇异向量对齐时达到。从 $A_S^\\dagger = V \\Sigma^{-1} U^T$ 的 SVD 中可知，右奇异向量是 $U$ 的列，奇异值为 $\\{1/\\sigma_i\\}_{i=1}^k$。最大的奇异值是 $1/\\sigma_k$，它对应于 $U$ 的第 $k$ 列，记为 $u_k$。\n\n因此，对抗性噪声方向是任何与 $u_k$ 成比例的向量 $e$，即对于任何非零标量 $c \\in \\mathbb{R}$，$e = c \\cdot u_k$。向量 $u_k$ 是原始矩阵 $A_S$ 的最小奇异值 $\\sigma_k$ 所对应的左奇异向量。这个方向是对抗性的，因为它位于算子 $A_S$ 具有最小增益（$\\sigma_k$）的子空间中，这意味着其逆（伪逆 $A_S^\\dagger$）具有最大增益（$1/\\sigma_k$）。当估计信号系数时，这个方向上的噪声被放大得最多。\n\n**3. 具体实例计算**\n\n给定 $m=6$, $k=3$，$A_S$ 的奇异值为 $\\sigma_1 = 5, \\sigma_2 = 3$ 和 $\\sigma_3 = \\frac{1}{5}$。最小的奇异值是 $\\sigma_k = \\sigma_3 = \\frac{1}{5}$。噪声的范数为 $\\|e\\|_2 = \\frac{1}{50}$，并且是对抗性选择的。\n\n当噪声是对抗性的时候，会出现可能的最大估计误差范数 $\\|\\hat{x} - x\\|_2$。在这种情况下，误差范数由以下公式给出：\n$$\n\\|\\hat{x} - x\\|_2 = \\|A_S^\\dagger e\\|_2 = \\|A_S^\\dagger\\|_2 \\|e\\|_2\n$$\n从第1部分，我们知道 $\\|A_S^\\dagger\\|_2 = \\frac{1}{\\sigma_k} = \\frac{1}{\\sigma_3}$。\n代入给定值：\n$$\n\\|A_S^\\dagger\\|_2 = \\frac{1}{\\frac{1}{5}} = 5\n$$\n现在，我们可以计算最大估计误差范数：\n$$\n\\|\\hat{x} - x\\|_2 = (5) \\cdot \\left(\\frac{1}{50}\\right) = \\frac{5}{50} = \\frac{1}{10}\n$$", "answer": "$$\\boxed{\\frac{1}{10}}$$", "id": "3471152"}, {"introduction": "本练习将理论与计算实践联系起来，展示了如何将矩阵调节和伪逆的知识应用于实际算法设计。你将为一个迭代求解器（LSQR）设计一个基于原则的早停准则，该准则利用对伪逆范数的估计来动态平衡逼近误差和噪声放大。这项任务体现了数值线性代数的思想如何用于解决不适定逆问题中的正则化挑战。[@problem_id:3471119]", "problem": "给定一个在压缩感知和稀疏优化背景下的线性反问题。设 $A \\in \\mathbb{R}^{m \\times n}$，$x_{\\mathrm{true}} \\in \\mathbb{R}^{n}$，以及由 $y = A x_{\\mathrm{true}} + e$ 生成的含噪数据 $y \\in \\mathbb{R}^{m}$，其中噪声向量 $e$ 的条目是方差为 $\\sigma^{2}$ 的独立同分布零均值高斯随机变量。考虑使用迭代Krylov子空间方法——最小二乘QR (LSQR)——来求解最小二乘问题 $\\min_{x \\in \\mathbb{R}^{n}} \\|y - A x\\|_{2}$。\n\n核心挑战是为LSQR设计一个有原则的早停准则，以平衡病态条件导致的噪声放大与近似误差。该准则必须仅使用LSQR迭代过程中可用的量：残差范数和对 $A$ 的Moore–Penrose伪逆 (MPP) 的谱范数（表示为 $\\|A^{\\dagger}\\|_{2}$）的估计。伪逆的谱范数定义为 $\\|A^{\\dagger}\\|_{2} = 1/\\sigma_{\\min}(A)$，$A$ 的2-范数条件数定义为 $\\kappa_{2}(A) = \\|A\\|_{2} \\,\\|A^{\\dagger}\\|_{2}$。LSQR在每次迭代时都提供对 $\\|A\\|_{2}$ 和 $\\kappa_{2}(A)$ 的可靠估计，您可以由此通过 $\\|A^{\\dagger}\\|_{2} \\approx \\kappa_{2}(A) / \\|A\\|_{2}$ 来估计 $\\|A^{\\dagger}\\|_{2}$。\n\n令 $x_{k}$ 表示 $k$ 次迭代后的LSQR迭代解， $r_{k} = y - A x_{k}$ 为其残差。令 $\\delta = \\sqrt{m}\\,\\sigma$ 表示噪声范数 $\\|e\\|_{2}$ 的典型尺度。您必须实现以下停止准则：\n\n- 选择固定常数 $\\tau \\ge 1$ 和 $\\alpha \\in (0,1]$。对于此问题，使用 $\\tau = 1.1$ 和 $\\alpha = 1.0$。\n- 使用LSQR在迭代 $k$ 时的内部估计，定义在迭代 $k$ 时的估计伪逆范数为 $\\widehat{\\|A^{\\dagger}\\|}_{2,k} = \\widehat{\\kappa_{2}(A)}_{k} / \\widehat{\\|A\\|}_{2,k}$。\n- 在满足以下两个条件的最小迭代次数 $k \\ge 2$ 处停止：\n  $$\n  \\|r_{k}\\|_{2} \\le \\tau\\,\\delta\n  \\quad\\text{and}\\quad\n  \\|x_{k} - x_{k-1}\\|_{2} \\le \\alpha\\,\\widehat{\\|A^{\\dagger}\\|}_{2,k}\\,\\delta.\n  $$\n如果在最大迭代预算 $k_{\\max}$ 内没有找到这样的 $k$，则返回 $k = k_{\\max}$ 和相应的量。\n\n您的程序必须实现带有上述停止准则的LSQR，并为以下测试套件生成结果。为保证可复现性，请按规定使用固定的伪随机数生成器种子。所有矩阵和向量都是纯粹无量纲的；此问题中没有物理单位。\n\n测试套件（四种情况），每种情况由 $(m,n,\\text{profile},\\sigma,s,\\text{seed})$ 指定：\n- 情况 1：$(40,60,\\text{mild\\_ill},10^{-2},5,0)$。\n- 情况 2：$(60,60,\\text{well},5 \\cdot 10^{-3},10,1)$。\n- 情况 3：$(40,60,\\text{severe\\_ill},10^{-2},5,2)$。\n- 情况 4：$(50,200,\\text{severe\\_ill},5 \\cdot 10^{-3},10,3)$。\n\n矩阵构造：\n- 对于 $\\text{well}$：设 $A$ 具有独立同分布的条目 $A_{ij} \\sim \\mathcal{N}(0,1/m)$，无列缩放。\n- 对于 $\\text{mild\\_ill}$：设 $A$ 如上所述，但将最后 $\\lfloor n/2 \\rfloor$ 列乘以 $10^{-2}$。\n- 对于 $\\text{severe\\_ill}$：设 $A$ 如上所述，但将第 $j$ 列乘以 $10^{-\\gamma}$，其中 $\\gamma = 8 \\cdot \\frac{j-1}{n-1}$，产生的奇异值范围大约在 $[1,10^{-8}]$。\n\n信号构造：\n- 设 $x_{\\mathrm{true}} \\in \\mathbb{R}^{n}$ 是 $s$-稀疏的，其非零条目在随机选择的均匀位置上，并且其值从 $\\mathcal{N}(0,1)$ 中独立同分布采样。\n\n噪声：\n- 设 $e \\in \\mathbb{R}^{m}$ 的条目从 $\\mathcal{N}(0,\\sigma^{2})$ 中独立同分布采样。\n\n对于每种情况，计算 $y = A x_{\\mathrm{true}} + e$，设置 $\\delta = \\sqrt{m}\\,\\sigma$，使用上述停止准则运行LSQR，并将最大迭代次数限制为 $k_{\\max} = \\min\\{m,n\\}$。对于LSQR，使用零绝对和相对容差，无条件数限制停止，即 $\\text{atol} = 0$，$\\text{btol} = 0$，以及 $\\text{conlim} = +\\infty$，并在提取 $x_{k}$ 时严格执行在 $k$ 处的迭代限制。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每种情况，结果是列表 $[k^{\\star}, \\widehat{\\|A^{\\dagger}\\|}_{2,k^{\\star}}, \\|r_{k^{\\star}}\\|_{2}]$，其中 $k^{\\star}$ 是选定的停止迭代次数，$\\widehat{\\|A^{\\dagger}\\|}_{2,k^{\\star}}$ 是停止时的估计伪逆范数，$\\|r_{k^{\\star}}\\|_{2}$ 是停止时的残差范数。因此，最终输出必须是以下形式\n$\n\\big[\n[k_{1}, \\widehat{\\|A^{\\dagger}\\|}_{2,1}, \\|r_{1}\\|_{2}],\n[k_{2}, \\widehat{\\|A^{\\dagger}\\|}_{2,2}, \\|r_{2}\\|_{2}],\n[k_{3}, \\widehat{\\|A^{\\dagger}\\|}_{2,3}, \\|r_{3}\\|_{2}],\n[k_{4}, \\widehat{\\|A^{\\dagger}\\|}_{2,4}, \\|r_{4}\\|_{2}]\n\\big]\n$ 并且必须打印为单行。[@problem_id:481]", "solution": "该问题要求为最小二乘QR (LSQR) 算法实现一个特定的早停准则。LSQR是一种Krylov子空间方法，用于解决线性最小二乘问题 $\\min_{x \\in \\mathbb{R}^{n}} \\|y - A x\\|_{2}$。该系统源于一个线性反问题 $y = A x_{\\mathrm{true}} + e$，其中 $A \\in \\mathbb{R}^{m \\times n}$ 是给定矩阵，$x_{\\mathrm{true}} \\in \\mathbb{R}^{n}$ 是未知的稀疏信号，$e \\in \\mathbb{R}^{m}$ 是一个噪声向量，其条目独立同分布地取自 $\\mathcal{N}(0, \\sigma^2)$。\n\n解决此类反问题的根本挑战，特别是当矩阵 $A$ 病态时，是防止解中噪声的放大。像LSQR这样的迭代方法通过早停提供了一种正则化形式：在迭代开始过度拟合噪声之前终止。问题指定了一个有原则的停止准则，旨在平衡近似误差（$A x_k$ 对 $y$ 的拟合程度）和解稳定性（防止噪声放大）之间的权衡。\n\n该停止准则定义如下：对于给定的常数 $\\tau \\ge 1$ 和 $\\alpha \\in (0,1]$，迭代在同时满足以下两个条件的最小整数 $k \\ge 2$ 处停止：\n1.  $\\|r_{k}\\|_{2} \\le \\tau\\,\\delta$\n2.  $\\|x_{k} - x_{k-1}\\|_{2} \\le \\alpha\\,\\widehat{\\|A^{\\dagger}\\|}_{2,k}\\,\\delta$\n\n在这里，$x_k$ 是第 $k$ 次迭代的解估计，$r_k = y - A x_k$ 是相应的残差。参数 $\\delta = \\sqrt{m}\\,\\sigma$ 代表噪声向量 $e$ 的预期欧几里得范数。第一个条件是差异原则的一种形式；它规定当残差的范数与噪声范数处于同一数量级时，迭代应停止。进一步减小残差很可能对应于拟合噪声 $e$，而不是 $A x_{\\mathrm{true}}$ 中的潜在信号结构。对于此问题，$\\tau = 1.1$。\n\n第二个条件引入了解稳定性检查。项 $\\widehat{\\|A^{\\dagger}\\|}_{2,k}$ 是 $A$ 的Moore-Penrose伪逆的谱范数的估计，它在第 $k$ 次迭代时根据LSQR对条件数 $\\widehat{\\kappa_{2}(A)}_{k}$ 和谱范数 $\\widehat{\\|A\\|}_{2,k}$ 的内部估计计算得出，即 $\\widehat{\\|A^{\\dagger}\\|}_{2,k} = \\widehat{\\kappa_{2}(A)}_{k} / \\widehat{\\|A\\|}_{2,k}$。量 $\\widehat{\\|A^{\\dagger}\\|}_{2,k}\\,\\delta$ 可以解释为传播到解空间的噪声量级的估计。因此，该条件在解向量的变化 $\\|x_k - x_{k-1}\\|_2$ 小于此噪声放大估计时停止迭代，这表明后续更新不太可能对真实信号产生显著改善。对于此问题，$\\alpha = 1.0$。\n\n如果在最大允许迭代次数 $k_{\\max} = \\min\\{m,n\\}$ 内这些条件未能满足，则过程终止并返回第 $k_{\\max}$ 次迭代的结果。\n\n实现过程首先按规定为每种情况生成测试数据。构造一个大小为 $m \\times n$ 的矩阵 $A$，其条目来自 $\\mathcal{N}(0, 1/m)$，并根据指定的病态特征（'well'、'mild_ill' 或 'severe_ill'）对其列进行缩放。生成一个 $s$-稀疏信号向量 $x_{\\mathrm{true}}$，其支撑集随机，非零值呈正态分布。然后计算测量向量 $y = A x_{\\mathrm{true}} + e$，其中 $e$ 是高斯噪声的一个实现。\n\n为了应用自定义停止准则，我们必须访问LSQR每次迭代的量。一种直接的方法是在一个循环内运行标准的 `scipy.sparse.linalg.lsqr` 函数。对于从 $2$ 到 $k_{\\max}$ 的每次迭代 $k$，我们执行 `lsqr` 并设置 `iter_lim=k` 以获得 $x_k$ 以及估计值 $\\widehat{\\|A\\|}_{2,k}$ 和 $\\widehat{\\kappa_{2}(A)}_{k}$。我们还需要 $x_{k-1}$，它从循环的上一步中保留下来。有了这些量，就可以在每个 $k$ 处评估两个停止条件。第一个满足两个条件的 $k$ 被选为停止迭代次数 $k^\\star$。这个迭代过程虽然比单次调用 `lsqr` 的计算成本更高，但通过提供必要的迭代历史，正确地实现了指定的逻辑。\n\n为 `lsqr` 求解器指定的参数是绝对容差 `atol` 为 $0$，相对容差 `btol` 为 $0$，以及无限的条件数限制 `conlim` 为 $+\\infty$，确保求解器的终止完全由我们的外部循环和迭代限制 `iter_lim` 控制。对于每个测试用例，最终输出包括停止迭代次数 $k^{\\star}$、估计的伪逆范数 $\\widehat{\\|A^{\\dagger}\\|}_{2,k^{\\star}}$ 和残差范数 $\\|r_{k^{\\star}}\\|_2$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse.linalg import lsqr\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (m, n, profile, sigma, s, seed)\n        (40, 60, 'mild_ill', 1e-2, 5, 0),\n        (60, 60, 'well', 5e-3, 10, 1),\n        (40, 60, 'severe_ill', 1e-2, 5, 2),\n        (50, 200, 'severe_ill', 5e-3, 10, 3)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(*case)\n        results.append(result)\n\n    # Format the final output string as specified, removing whitespace.\n    formatted_results = [str(res).replace(' ', '') for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef process_case(m, n, profile, sigma, s, seed):\n    \"\"\"\n    Generates data for a single test case and runs the LSQR with the custom stopping rule.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # 1. Generate matrix A\n    A = rng.normal(0, np.sqrt(1/m), size=(m, n))\n    if profile == 'mild_ill':\n        num_cols_to_scale = int(np.floor(n / 2))\n        scaling_factor = 1e-2\n        A[:, -num_cols_to_scale:] *= scaling_factor\n    elif profile == 'severe_ill':\n        for j in range(n):\n            gamma = 8.0 * j / (n - 1)\n            scaling_factor = 10**(-gamma)\n            A[:, j] *= scaling_factor\n\n    # 2. Generate true signal x_true\n    x_true = np.zeros(n)\n    support = rng.choice(n, s, replace=False)\n    x_true[support] = rng.normal(0, 1, size=s)\n\n    # 3. Generate noise e and measurement y\n    e = rng.normal(0, sigma, size=m)\n    y = A @ x_true + e\n\n    # 4. Implement LSQR with the specified stopping rule\n    tau = 1.1\n    alpha = 1.0\n    delta = np.sqrt(m) * sigma\n    k_max = min(m, n)\n\n    k_star = k_max\n    final_report = None\n\n    # Get x_{k-1} for the first iteration of the loop (k=2)\n    # This corresponds to x_1\n    res_prev = lsqr(A, y, damp=0.0, atol=0, btol=0, conlim=float('inf'), iter_lim=1)\n    x_prev = res_prev[0]\n\n    for k in range(2, k_max + 1):\n        res_k = lsqr(A, y, damp=0.0, atol=0, btol=0, conlim=float('inf'), iter_lim=k)\n        x_k = res_k[0]\n        r_norm_k = res_k[3]\n        anorm_k = res_k[5]\n        acond_k = res_k[6]\n        \n        if anorm_k > 0:\n            est_A_dagger_norm_k = acond_k / anorm_k\n        else:\n            est_A_dagger_norm_k = float('inf')\n\n        x_diff_norm_k = np.linalg.norm(x_k - x_prev)\n\n        cond1 = r_norm_k = tau * delta\n        cond2 = x_diff_norm_k = alpha * est_A_dagger_norm_k * delta\n        \n        if cond1 and cond2:\n            k_star = k\n            final_report = [k_star, est_A_dagger_norm_k, r_norm_k]\n            break\n\n        # Update x_prev for the next iteration step\n        x_prev = x_k\n\n    # If the loop completes without stopping, use results from k_max\n    if final_report is None:\n        # The last iteration of the loop was k = k_max. res_k holds its results.\n        res_kmax = lsqr(A, y, damp=0.0, atol=0, btol=0, conlim=float('inf'), iter_lim=k_max)\n        r_norm_kmax = res_kmax[3]\n        anorm_kmax = res_kmax[5]\n        acond_kmax = res_kmax[6]\n        if anorm_kmax > 0:\n            est_A_dagger_norm_kmax = acond_kmax / anorm_kmax\n        else:\n            est_A_dagger_norm_kmax = float('inf')\n        \n        final_report = [k_max, est_A_dagger_norm_kmax, r_norm_kmax]\n\n    return final_report\n\nsolve()\n```", "id": "3471119"}]}