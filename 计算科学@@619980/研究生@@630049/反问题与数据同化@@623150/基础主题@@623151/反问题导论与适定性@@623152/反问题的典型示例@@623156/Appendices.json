{"hands_on_practices": [{"introduction": "本实践旨在通过一个经典的计算机断层扫描（Tomography）问题，深入理解逆问题中的不适定性（ill-posedness）是如何由数据采集几何结构直接导致的。通过亲手构建一个简化的 $2 \\times 2$ 系统的正向算子矩阵并分析其零空间，您将具体地看到哪些结构特征是该采集方案无法重建的 [@problem_id:3370624]。这项练习为了解线性逆问题的基础、正规方程（normal equations）的性质以及解的非唯一性提供了坚实的分析基础。", "problem": "考虑一个二维直射线走时层析成像问题，该问题建立在一个均匀的 $2 \\times 2$ 笛卡尔网格上，网格由方形单元组成，慢度未知量为 $m = (s_{1}, s_{2}, s_{3}, s_{4})^{\\top} \\in \\mathbb{R}^{4}$。射线的连续走时由路径积分 $t = \\int_{\\gamma} s(\\mathbf{x}) \\, \\mathrm{d}\\ell$ 定义，其中 $\\gamma$ 表示直射线路径，$s(\\mathbf{x})$ 是慢度场。在标准的分片常数离散化中，每个测量的走时 $t_{i}$ 由 $m$ 的线性泛函近似，\n$$\nt_{i} \\approx \\sum_{j=1}^{4} L_{ij} s_{j},\n$$\n其中 $L_{ij}$ 是射线 $i$ 在单元 $j$ 内的路径长度。将 $t_{i}$ 堆叠成数据向量 $t \\in \\mathbb{R}^{4}$，将 $L_{ij}$ 堆叠成系统矩阵 $G \\in \\mathbb{R}^{4 \\times 4}$，从而得到 $t \\approx G m$。\n\n假设几何结构和采集方式如下。共有 $4$ 条射线：\n(i) 一条水平射线穿过顶行单元，\n(ii) 一条水平射线穿过底行单元，\n(iii) 一条垂直射线穿过左列单元，以及\n(iv) 一条垂直射线穿过右列单元。\n假设每条射线穿过其相交的每个单元的路径长度为单位长度，即 $L_{ij} \\in \\{0,1\\}$，当且仅当射线 $i$ 穿过单元 $j$ 时，$L_{ij} = 1$。因此，$G$ 的元素是二值的，并编码了这种几何结构。假设测量误差是独立同分布的高斯误差，协方差为 $\\sigma^{2} I$，并采用加权最小二乘 (WLS) 目标函数\n$$\n\\Phi(m) = \\frac{1}{2} \\| t - G m \\|_{2}^{2},\n$$\n因此正规方程组为 $G^{\\top} G \\, m = G^{\\top} t$。\n\n任务：\n(1) 根据所描述的采集几何结构，构建显式矩阵 $G$，并构成正规矩阵 $N = G^{\\top} G$。\n(2) 仅利用 $N$ 的结构，找出 $N$ 的零空间中的一个非平凡向量，并根据采集引起的多义性对其进行解释。\n(3) 按非递增顺序计算 $N$ 的特征值。\n\n将你的最终答案以单行矩阵的形式给出 $N$ 的有序特征值。无需四舍五入；请提供精确整数。最终答案中不包含单位。", "solution": "该问题陈述经证实具有科学依据，适定于分析，客观且自洽。它展示了地球物理层析成像领域中线性反演问题的一个典型示例。所有必需信息均已提供，任务明确。因此，我们可以着手求解。\n\n该问题要求完成与一个 $2 \\times 2$ 走时层析成像问题相关的三项任务。我们将按顺序逐一解决。\n\n我们首先建立一个清晰的索引约定。四个单元按行主序索引：\n- 单元 $1$：左上\n- 单元 $2$：右上\n- 单元 $3$：左下\n- 单元 $4$：右下\n未知慢度向量为 $m = (s_1, s_2, s_3, s_4)^{\\top}$。\n\n四条射线的索引如下：\n- 射线 $1$：水平，顶行\n- 射线 $2$：水平，底行\n- 射线 $3$：垂直，左列\n- 射线 $4$：垂直，右列\n测量走时向量为 $t = (t_1, t_2, t_3, t_4)^{\\top}$。\n\n离散正演模型由线性系统 $t = G m$ 给出，其中 $G_{ij}$ 是射线 $i$ 在单元 $j$ 内的路径长度。问题陈述，$G_{ij}=1$ 如果射线 $i$ 穿过单元 $j$，否则 $G_{ij}=0$。\n\n(1) 构建显式矩阵 $G$ 并构成正规矩阵 $N = G^{\\top} G$。\n\n我们逐行构造矩阵 $G$，其中每一行对应一次射线测量：\n- 射线 $1$ 穿过单元 $1$ 和 $2$。因此，$t_1 = 1 \\cdot s_1 + 1 \\cdot s_2 + 0 \\cdot s_3 + 0 \\cdot s_4$。$G$ 的第一行是 $(1, 1, 0, 0)$。\n- 射线 $2$ 穿过单元 $3$ 和 $4$。因此，$t_2 = 0 \\cdot s_1 + 0 \\cdot s_2 + 1 \\cdot s_3 + 1 \\cdot s_4$。$G$ 的第二行是 $(0, 0, 1, 1)$。\n- 射线 $3$ 穿过单元 $1$ 和 $3$。因此，$t_3 = 1 \\cdot s_1 + 0 \\cdot s_2 + 1 \\cdot s_3 + 0 \\cdot s_4$。$G$ 的第三行是 $(1, 0, 1, 0)$。\n- 射线 $4$ 穿过单元 $2$ 和 $4$。因此，$t_4 = 0 \\cdot s_1 + 1 \\cdot s_2 + 0 \\cdot s_3 + 1 \\cdot s_4$。$G$ 的第四行是 $(0, 1, 0, 1)$。\n\n组合这些行，系统矩阵 $G$ 为：\n$$\nG = \\begin{pmatrix}\n1  1  0  0 \\\\\n0  0  1  1 \\\\\n1  0  1  0 \\\\\n0  1  0  1\n\\end{pmatrix}\n$$\n正规矩阵 $N$ 定义为 $N = G^{\\top} G$。首先，我们写出 $G$ 的转置：\n$$\nG^{\\top} = \\begin{pmatrix}\n1  0  1  0 \\\\\n1  0  0  1 \\\\\n0  1  1  0 \\\\\n0  1  0  1\n\\end{pmatrix}\n$$\n现在我们计算乘积：\n$$\nN = G^{\\top} G = \\begin{pmatrix}\n1  0  1  0 \\\\\n1  0  0  1 \\\\\n0  1  1  0 \\\\\n0  1  0  1\n\\end{pmatrix}\n\\begin{pmatrix}\n1  1  0  0 \\\\\n0  0  1  1 \\\\\n1  0  1  0 \\\\\n0  1  0  1\n\\end{pmatrix}\n= \\begin{pmatrix}\n1 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 1 + 0 \\cdot 0 & 1 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 0 + 0 \\cdot 1 & 1 \\cdot 0 + 0 \\cdot 1 + 1 \\cdot 1 + 0 \\cdot 0 & 1 \\cdot 0 + 0 \\cdot 1 + 1 \\cdot 0 + 0 \\cdot 1 \\\\\n1 \\cdot 1 + 0 \\cdot 0 + 0 \\cdot 1 + 1 \\cdot 0 & 1 \\cdot 1 + 0 \\cdot 0 + 0 \\cdot 0 + 1 \\cdot 1 & 1 \\cdot 0 + 0 \\cdot 1 + 0 \\cdot 1 + 1 \\cdot 0 & 1 \\cdot 0 + 0 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 1 \\\\\n0 \\cdot 1 + 1 \\cdot 0 + 1 \\cdot 1 + 0 \\cdot 0 & 0 \\cdot 1 + 1 \\cdot 0 + 1 \\cdot 0 + 0 \\cdot 1 & 0 \\cdot 0 + 1 \\cdot 1 + 1 \\cdot 1 + 0 \\cdot 0 & 0 \\cdot 0 + 1 \\cdot 1 + 1 \\cdot 0 + 0 \\cdot 1 \\\\\n0 \\cdot 1 + 1 \\cdot 0 + 0 \\cdot 1 + 1 \\cdot 0 & 0 \\cdot 1 + 1 \\cdot 0 + 0 \\cdot 0 + 1 \\cdot 1 & 0 \\cdot 0 + 1 \\cdot 1 + 0 \\cdot 1 + 1 \\cdot 0 & 0 \\cdot 0 + 1 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 1\n\\end{pmatrix}\n$$\n$$\nN = \\begin{pmatrix}\n2  1  1  0 \\\\\n1  2  0  1 \\\\\n1  0  2  1 \\\\\n0  1  1  2\n\\end{pmatrix}\n$$\n\n(2) 仅利用 $N$ 的结构，找出 $N$ 的零空间中的一个非平凡向量并对其进行解释。\n\n一个向量 $v$ 属于 $N=G^\\top G$ 的零空间，当且仅当它属于 $G$ 的零空间。我们寻找一个非零向量 $v = (v_1, v_2, v_3, v_4)^\\top$ 使得 $Gv=0$。这等价于以下线性方程组：\n$$\nv_1 + v_2 = 0 \\\\\nv_3 + v_4 = 0 \\\\\nv_1 + v_3 = 0 \\\\\nv_2 + v_4 = 0\n$$\n由第一个方程得 $v_2 = -v_1$。由第三个方程得 $v_3 = -v_1$。将这些代入第二个方程得到 $(-v_1) + v_4 = 0$，这意味着 $v_4 = v_1$。第四个方程 $v_2+v_4 = (-v_1) + v_1 = 0$ 自动满足，不提供新信息。\n因此，$G$（以及 $N$）的零空间中的任何向量都必须是 $(c, -c, -c, c)^\\top$ 的形式，其中 $c \\in \\mathbb{R}$ 是某个标量。\n通过设置 $c=1$ 可得到一个简单的非平凡向量：\n$$\nv_{\\text{null}} = (1, -1, -1, 1)^\\top\n$$\n该向量代表一种“棋盘格”模式的慢度扰动。如果我们将此模式（按任意常数 $\\alpha$ 缩放）添加到一个给定的慢度模型 $m$ 中，那么新模型 $m' = m + \\alpha v_{\\text{null}}$ 在给定测量数据下与 $m$ 是无法区分的。每条射线的走时保持不变：\n- 射线 $1$：变化为 $\\alpha v_1 + \\alpha v_2 = \\alpha(1-1) = 0$。\n- 射线 $2$：变化为 $\\alpha v_3 + \\alpha v_4 = \\alpha(-1+1) = 0$。\n- 射线 $3$：变化为 $\\alpha v_1 + \\alpha v_3 = \\alpha(1-1) = 0$。\n- 射线 $4$：变化为 $\\alpha v_2 + \\alpha v_4 = \\alpha(-1+1) = 0$。\n这代表了采集几何中的一个根本性多义性：水平和垂直射线集无法分辨慢度场中的棋盘格状结构。非平凡零空间的存在意味着矩阵 $N$ 是奇异的，且反演问题是不适定的（具体来说，解不唯一）。\n\n(3) 按非递增顺序计算 $N$ 的特征值。\n\n我们需要求矩阵 $N$ 的特征值。\n$$\nN = \\begin{pmatrix}\n2  1  1  0 \\\\\n1  2  0  1 \\\\\n1  0  2  1 \\\\\n0  1  1  2\n\\end{pmatrix}\n$$\n由于我们已经在 $N$ 的零空间中找到了一个非零向量，因此其中一个特征值必须是 $\\lambda = 0$。\n\n矩阵 $N$ 具有分块结构。设 $A = \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}$ 和 $I_2 = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}$。则 $N$ 可以写成：\n$$\nN = \\begin{pmatrix} A & I_2 \\\\ I_2 & A \\end{pmatrix}\n$$\n这种形式的分块矩阵的特征值是矩阵 $A+I_2$ 和 $A-I_2$ 的特征值。\n\n首先，我们求子矩阵的特征值。\n对于 $A+I_2$：\n$$\nA+I_2 = \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} + \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 3  1 \\\\ 1  3 \\end{pmatrix}\n$$\n特征方程为 $\\det((A+I_2) - \\lambda I) = 0$：\n$$\n(3-\\lambda)^2 - 1 = 0 \\implies 3-\\lambda = \\pm 1 \\implies \\lambda = 3 \\mp 1\n$$\n这给出了两个特征值：$\\lambda_a = 4$ 和 $\\lambda_b = 2$。\n\n对于 $A-I_2$：\n$$\nA-I_2 = \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} - \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 1  1 \\\\ 1  1 \\end{pmatrix}\n$$\n特征方程为 $\\det((A-I_2) - \\lambda I) = 0$：\n$$\n(1-\\lambda)^2 - 1 = 0 \\implies 1-\\lambda = \\pm 1 \\implies \\lambda = 1 \\mp 1\n$$\n这给出了两个特征值：$\\lambda_c = 2$ 和 $\\lambda_d = 0$。\n\n$N$ 的特征值集合是 $A+I_2$ 和 $A-I_2$ 特征值的并集，即 $\\{4, 2, 2, 0\\}$。\n将这些按非递增顺序排列，我们得到：$4, 2, 2, 0$。\n\n特征值 $\\lambda=0$ 对应我们找到的零空间向量。$N$ 的秩为 $3$，零度为 $1$。零特征值的存在证实了矩阵是奇异的，并且最小二乘问题没有唯一解。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4  2  2  0\n\\end{pmatrix}\n}\n$$", "id": "3370624"}, {"introduction": "在识别出问题的不适定性之后，下一步自然是学习如何获得一个稳定解。本练习通过一个典型的解卷积（deconvolution）问题，演示了吉洪诺夫正则化（Tikhonov regularization）这一基本工具的应用。您将在频率域中从第一性原理出发，推导正则化解，这不仅能加深对卷积定理和帕塞瓦尔定理的理解，还能揭示正则化参数 $\\lambda$ 如何通过调整反演滤波器来抑制噪声放大，从而稳定求解过程 [@problem_id:3370633]。", "problem": "考虑一个经典的离散时间线性逆问题：从由卷积模型 $y[n] = (h * x)[n]$ 生成的测量值 $y[n]$ 中恢复未知序列 $x[n]$，其中 $h[n]$ 是一个已知的点扩散函数。假设重建是通过带有二次惩罚项的 Tikhonov 正则化得到的，即通过在所有平方可和序列 $x[n]$ 上最小化泛函 $\\|h * x - y\\|_{2}^{2} + \\lambda \\|x\\|_{2}^{2}$ 来实现，其中 $\\lambda > 0$ 是正则化参数。\n\n给定一个在 $n=0, 1, 2$ 上有支撑的三抽头平均核 $h[n] = \\tfrac{1}{3}(1, 1, 1)$。使用离散时间傅里叶变换 (DTFT) 在频域中进行求解，其约定为 $X(\\omega) = \\sum_{n=-\\infty}^{\\infty} x[n] \\exp(-\\mathrm{j}\\,\\omega n)$ 和 $Y(\\omega) = \\sum_{n=-\\infty}^{\\infty} y[n] \\exp(-\\mathrm{j}\\,\\omega n)$，其中 $\\omega \\in [-\\pi, \\pi)$，以及卷积定理 $(h * x) \\xleftrightarrow{\\text{DTFT}} H(\\omega) X(\\omega)$。\n\n根据第一性原理以及 DTFT 和最小二乘最小化的标准性质，推导使 $\\|h * x - y\\|_{2}^{2} + \\lambda \\|x\\|_{2}^{2}$ 最小化的频域解 $\\widehat{X}(\\omega)$。然后，对于特定的 $h[n] = \\tfrac{1}{3}(1,1,1)$，计算重建滤波器的闭式频率响应 $G(\\omega)$，使得 $\\widehat{X}(\\omega) = G(\\omega)\\,Y(\\omega)$。将 $G(\\omega)$ 明确地表示为 $\\omega$ 和 $\\lambda$ 的函数，并进行最大程度的简化。\n\n最后，从幅度和相位的角度对重建滤波器进行定性分析：确定滤波器幅度为零的频率，描述当 $\\lambda \\to 0^{+}$ 和 $\\lambda \\to \\infty$ 时的极限行为，并对 $G(\\omega)$ 的相位进行评述。\n\n你的最终答案必须是 $G(\\omega)$ 的单一闭式解析表达式，该表达式应被简化并表示为 $\\omega$ 和 $\\lambda$ 的函数。无需进行数值计算。如果引入任何缩写词，请在首次使用时给出定义。角度单位为弧度。", "solution": "目标是为 Tikhonov 正则化反卷积问题找到重建滤波器 $G(\\omega)$。解 $\\widehat{x}[n]$ 是使以下泛函最小化的序列：\n$$J(x) = \\|h * x - y\\|_{2}^{2} + \\lambda \\|x\\|_{2}^{2}$$\n此处，$x$ 代表未知序列 $x[n]$，$y$ 是测量序列 $y[n]$，$h$ 是已知核 $h[n]$，`*` 表示卷积，$\\lambda > 0$ 是正则化参数。范数 $\\|\\cdot\\|_2$ 是离散时间序列的标准 $\\ell_2$-范数，定义为 $\\|s\\|_{2}^{2} = \\sum_{n=-\\infty}^{\\infty} |s[n]|^2$。\n\n这个问题最方便在频域中使用离散时间傅里叶变换 (DTFT) 求解。我们将利用 Parseval 定理，该定理将序列的平方和与其在频域中的幅度平方的积分联系起来：\n$$\\|s\\|_{2}^{2} = \\sum_{n=-\\infty}^{\\infty} |s[n]|^2 = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} |S(\\omega)|^2 \\, d\\omega$$\n其中 $S(\\omega)$ 是序列 $s[n]$ 的 DTFT。\n\n将 Parseval 定理应用于泛函 $J(x)$ 的两项，我们将最小化问题转换到频域。令 $X(\\omega)$、$Y(\\omega)$ 和 $H(\\omega)$ 分别是 $x[n]$、$y[n]$ 和 $h[n]$ 的 DTFT。根据卷积定理，卷积项 $(h * x)[n]$ 的 DTFT 是 $H(\\omega)X(\\omega)$。\n\n第一项，即数据保真项，变为：\n$$\\|h * x - y\\|_{2}^{2} = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} |H(\\omega)X(\\omega) - Y(\\omega)|^2 \\, d\\omega$$\n第二项，即正则化项，变为：\n$$\\lambda \\|x\\|_{2}^{2} = \\lambda \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} |X(\\omega)|^2 \\, d\\omega$$\n结合这两项，频域中的泛函为：\n$$J(X) = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} \\left( |H(\\omega)X(\\omega) - Y(\\omega)|^2 + \\lambda |X(\\omega)|^2 \\right) \\, d\\omega$$\n为了最小化积分 $J(X)$，我们可以对每个频率 $\\omega \\in [-\\pi, \\pi)$ 逐点最小化被积函数。设被积函数为 $L(\\omega, X(\\omega))$：\n$$L(\\omega, X(\\omega)) = |H(\\omega)X(\\omega) - Y(\\omega)|^2 + \\lambda |X(\\omega)|^2$$\n对于每个频率 $\\omega$，这是一个关于复变量 $X(\\omega)$ 的标准最小二乘问题。我们通过计算 $L$ 关于 $X(\\omega)^*$ 的复导数并将其设为零来找到最小值。\n$$\\frac{\\partial L}{\\partial X(\\omega)^*} = \\frac{\\partial}{\\partial X(\\omega)^*} \\left( (H(\\omega)X(\\omega) - Y(\\omega))(H(\\omega)^*X(\\omega)^* - Y(\\omega)^*) + \\lambda X(\\omega)X(\\omega)^* \\right) = 0$$\n$$\\frac{\\partial L}{\\partial X(\\omega)^*} = (H(\\omega)X(\\omega) - Y(\\omega)) H(\\omega)^* + \\lambda X(\\omega) = 0$$\n$$(|H(\\omega)|^2 + \\lambda) X(\\omega) - H(\\omega)^* Y(\\omega) = 0$$\n求解最优频域表示 $\\widehat{X}(\\omega)$：\n$$(|H(\\omega)|^2 + \\lambda) \\widehat{X}(\\omega) = H(\\omega)^* Y(\\omega)$$\n$$\\widehat{X}(\\omega) = \\frac{H(\\omega)^*}{|H(\\omega)|^2 + \\lambda} Y(\\omega)$$\n这是频域解的一般形式。重建滤波器 $G(\\omega)$ 由关系式 $\\widehat{X}(\\omega) = G(\\omega)Y(\\omega)$ 定义，因此我们可以确定：\n$$G(\\omega) = \\frac{H(\\omega)^*}{|H(\\omega)|^2 + \\lambda}$$\n现在，我们必须为特定的点扩散函数 $h[n] = \\frac{1}{3}(1, 1, 1)$（支撑在 $n = 0, 1, 2$）计算这个表达式。其 DTFT $H(\\omega)$ 为：\n$$H(\\omega) = \\sum_{n=0}^{2} \\frac{1}{3} \\exp(-\\mathrm{j}\\omega n) = \\frac{1}{3} (1 + \\exp(-\\mathrm{j}\\omega) + \\exp(-\\mathrm{j}2\\omega))$$\n这是一个等比级数。我们可以通过提取出一个中心相位项来简化它：\n$$H(\\omega) = \\frac{1}{3} \\exp(-\\mathrm{j}\\omega) (\\exp(\\mathrm{j}\\omega) + 1 + \\exp(-\\mathrm{j}\\omega))$$\n使用恒等式 $2\\cos(\\omega) = \\exp(\\mathrm{j}\\omega) + \\exp(-\\mathrm{j}\\omega)$，我们得到：\n$$H(\\omega) = \\frac{1}{3} \\exp(-\\mathrm{j}\\omega) (1 + 2\\cos(\\omega))$$\n根据这个表达式，我们计算其复共轭 $H(\\omega)^*$ 和幅度平方 $|H(\\omega)|^2$：\n$$H(\\omega)^* = \\frac{1}{3} \\exp(\\mathrm{j}\\omega) (1 + 2\\cos(\\omega))$$\n$$|H(\\omega)|^2 = H(\\omega)H(\\omega)^* = \\left( \\frac{1}{3} \\exp(-\\mathrm{j}\\omega) (1 + 2\\cos(\\omega)) \\right) \\left( \\frac{1}{3} \\exp(\\mathrm{j}\\omega) (1 + 2\\cos(\\omega)) \\right) = \\frac{1}{9} (1 + 2\\cos(\\omega))^2$$\n将这些代入 $G(\\omega)$ 的表达式中：\n$$G(\\omega) = \\frac{\\frac{1}{3} \\exp(\\mathrm{j}\\omega) (1 + 2\\cos(\\omega))}{\\frac{1}{9}(1 + 2\\cos(\\omega))^2 + \\lambda}$$\n为了简化，我们将分子和分母同乘以 $9$：\n$$G(\\omega) = \\frac{3 \\exp(\\mathrm{j}\\omega) (1 + 2\\cos(\\omega))}{(1+2\\cos(\\omega))^2 + 9\\lambda}$$\n这就是重建滤波器 $G(\\omega)$ 的最终闭式表达式。\n\n最后，我们对该滤波器进行定性分析。\n\n幅度：滤波器的幅度为：\n$$|G(\\omega)| = \\frac{3 |1 + 2\\cos(\\omega)|}{(1+2\\cos(\\omega))^2 + 9\\lambda}$$\n当 $1 + 2\\cos(\\omega) = 0$ 时，幅度为零，这发生在频率 $\\omega = \\pm 2\\pi/3$ 处。这些是正向滤波器 $H(\\omega)$ 具有零点的频率，在这些频率上信号的任何信息都无法被恢复。正则化正确地确保了逆滤波器在这些频率处的增益也为零。\n\n相位：$G(\\omega)$ 的相位由项 $ \\exp(\\mathrm{j}\\omega) (1 + 2\\cos(\\omega)) $ 决定。当 $\\lambda > 0$ 时，分母始终是正实数。\n项 $(1 + 2\\cos(\\omega))$ 是实数，但可能为负。\n- 当 $1+2\\cos(\\omega) > 0$ 时，即对于 $|\\omega| < 2\\pi/3$， $G(\\omega)$ 的相位是 $\\omega$。\n- 当 $1+2\\cos(\\omega) < 0$ 时，即对于 $2\\pi/3 < |\\omega| \\leq \\pi$，该项为负，贡献了 $\\pi$ 的相移。$G(\\omega)$ 的相位是 $\\omega + \\pi$（或 $\\omega - \\pi$，以保持在主值范围内）。\n因此，滤波器在频率 $\\omega = \\pm 2\\pi/3$ 处表现出相位反转。\n\n极限行为：\n- 当 $\\lambda \\to 0^{+}$（无正则化）时：\n$$G(\\omega) \\to \\frac{3 \\exp(\\mathrm{j}\\omega) (1 + 2\\cos(\\omega))}{(1+2\\cos(\\omega))^2} = \\frac{3 \\exp(\\mathrm{j}\\omega)}{1+2\\cos(\\omega)} = \\frac{1}{H(\\omega)}$$\n滤波器趋近于朴素逆滤波器，该滤波器是不稳定的，并在 $H(\\omega)$ 为零的频率处无限放大噪声。\n- 当 $\\lambda \\to \\infty$（强正则化）时：\n$$G(\\omega) \\to 0$$\n滤波器增益对所有频率都趋于零。这意味着重建信号 $\\widehat{X}(\\omega) = G(\\omega)Y(\\omega)$ 趋于零，从而得到 $\\widehat{x}[n] = 0$。这是预期的结果，因为对信号能量的无限惩罚会迫使解为零信号，而与测量值无关。", "answer": "$$\\boxed{\\frac{3 \\exp(\\mathrm{j}\\omega) (1 + 2\\cos(\\omega))}{(1+2\\cos(\\omega))^{2} + 9\\lambda}}$$", "id": "3370633"}, {"introduction": "这项高级实践将带您从经典正则化方法迈向现代的稀疏性驱动技术。我们将解决一个波源定位问题，其核心假设是源的分布是稀疏的。您将通过实现基于 $\\ell_1$ 范数的 LASSO 模型，并使用快速迭代收缩阈值算法（FISTA）进行求解，来学习如何将先验知识（稀疏性）融入到反演框架中 [@problem_id:3370666]。这个练习连接了凸优化理论与计算实现，是掌握现代逆问题求解方法的关键一步。", "problem": "考虑在区间 $[0,L]$ 上均匀介质中的一维波传播模型，其波速为常数 $c$，在边界位置 $x=0$ 和 $x=L$ 处有点传感器。未知的源分布被假设是稀疏的，并建模为狄拉克 (Dirac) 点源之和 $s(x) = \\sum_{j=1}^{J} a_j \\,\\delta(x - x_j)$，其中振幅 $a_j$ 是复数值，位置 $x_j$ 位于给定的离散空间网格上。测量的量是对记录的时域信号应用时间傅里叶变换后，在边界传感器上获得的频域轨迹。设角频率用 $\\omega$ 表示（单位为弧度/秒）。在频域中，场 $u(x,\\omega)$ 满足带源项的一维亥姆霍兹 (Helmholtz) 方程。为解决此问题，请使用亥姆霍兹 (Helmholtz) 算子的自由空间一维格林 (Green) 函数来对此从稀疏源分布到边界传感器测量的映射进行建模。对于给定的角频率 $\\omega$，定义 $k = \\omega/c$。那么，在传感器位置 $x_m \\in \\{0,L\\}$ 处的频域测量可以建模为线性叠加\n$$\ny(x_m,\\omega) \\;=\\; \\sum_{j=1}^{J} a_j \\, G_\\omega\\left(|x_m - x_j|\\right),\n$$\n其中\n$$\nG_\\omega(r) \\;=\\; \\frac{i}{2k}\\, e^{i k r},\n$$\n且 $r$ 是从源位置到传感器位置的距离。在此模型下，将多个角频率 $\\{\\omega_\\ell\\}_{\\ell=1}^{F}$ 和两个传感器位置堆叠成一个复数值测量向量，会得到一个形式如下的线性系统\n$$\n\\mathbf{y} \\;=\\; \\mathbf{A}\\,\\mathbf{x} \\;+\\; \\boldsymbol{\\varepsilon},\n$$\n其中 $\\mathbf{x} \\in \\mathbb{C}^{N}$ 是与 $N$ 点空间网格对齐的未知稀疏源振幅向量，$\\mathbf{A} \\in \\mathbb{C}^{MF \\times N}$ 是前向算子，其元素为 $A_{(\\ell,m),j} = G_{\\omega_\\ell}(|x_m - x_j|)$，$M=2$ 是传感器数量，$\\boldsymbol{\\varepsilon}$ 用于模拟测量中的加性复噪声。$e^{i k r}$ 中的相应被解释为弧度。\n\n逆源定位任务是从带噪声的边界测量 $\\mathbf{y}$ 中恢复稀疏向量 $\\mathbf{x}$，并由此推断源所在的支撑集（网格位置）及其振幅。为了稳定反演并促进稀疏性，使用最小绝对收缩和选择算子 (LASSO) 公式，该公式通过最小化一个凸惩罚最小二乘目标函数来寻求 $\\widehat{\\mathbf{x}}$：\n$$\n\\widehat{\\mathbf{x}} \\;=\\; \\arg\\min_{\\mathbf{z}\\in\\mathbb{C}^{N}} \\;\\frac{1}{2}\\,\\|\\mathbf{A}\\,\\mathbf{z} - \\mathbf{y}\\|_2^2 \\;+\\; \\lambda \\,\\|\\mathbf{z}\\|_1,\n$$\n其中 $\\lambda > 0$ 是正则化参数，$\\|\\cdot\\|_2$ 是欧几里得范数，$\\|\\cdot\\|_1$ 是为复向量定义的逐项 $\\ell_1$ 范数，定义为 $\\|\\mathbf{z}\\|_1 = \\sum_{j=1}^{N} |z_j|$。\n\n为上述目标实现一个基于近端梯度原理（使用快速迭代收缩阈值算法 (FISTA)）的求解器。使用多个角频率来改善条件数（多频稳定化），并通过幂迭代法估计 $\\mathbf{A}^*\\mathbf{A}$ 的最大特征值来设置梯度步长，其中 $\\mathbf{A}^*$ 表示共轭转置。使用一个逐项作用的复数值软阈值算子 $S_\\tau(z)$，定义为 $S_\\tau(0)=0$ 和\n$$\nS_\\tau(z) \\;=\\; \\max\\{ |z| - \\tau, \\, 0 \\}\\,\\frac{z}{|z|} \\quad \\text{for } z\\neq 0.\n$$\n\n噪声模型：向 $\\mathbf{y}$ 添加独立同分布的复高斯噪声，其中每个分量的实部和虚部的标准差 $\\sigma$ 由相对噪声水平参数 $\\eta$ 通过 $\\sigma = \\eta \\cdot \\operatorname{median}(|\\mathbf{y}_\\text{clean}|)$ 确定，其中 $\\mathbf{y}_\\text{clean} = \\mathbf{A}\\,\\mathbf{x}_\\text{true}$ 表示无噪声测量向量；如果 $\\operatorname{median}(|\\mathbf{y}_\\text{clean}|) = 0$，则设置 $\\sigma = \\eta$。\n\n检测与评分：如果在网格索引 $j$ 处满足 $|\\widehat{x}_j| \\ge \\tau_\\text{det}$，则声明一个恢复的源，其中 $\\tau_\\text{det}$ 为指定的检测阈值。如果一个恢复源的网格索引与一个真实源索引的差异最多为 $1$，则该恢复源被计为与真实源匹配。对于匹配的源，计算以米为单位的平均绝对位置误差和使用 $|\\,|\\widehat{x}_j| - |x^\\text{true}_j|\\,|$, 计算的平均绝对振幅误差，其中 $x^\\text{true}_j$ 是匹配网格索引处的真实振幅。同时计算误报数，定义为在上述标准下不与任何真实源匹配的恢复源数量。对于每个测试用例，按顺序报告匹配源的整数计数、以米为单位的平均位置误差、平均振幅误差（无单位）以及误报数的整数计数。\n\n单位：位置以米表示，波速以米/秒表示，角频率以弧度/秒表示，时间以秒表示。平均位置误差必须以米报告。振幅误差无单位。除了相位 $k r$ 外，没有出现其他角度，且相位被解释为弧度。\n\n您的程序必须实现上述模型和求解器，并运行以下测试套件。对于每个测试用例，使用一个包含 $N=101$ 个点的均匀空间网格，跨越 $[0,L]$（含端点），在 $x=0$ 和 $x=L$ 处有两个传感器，并使用指定的参数。最多使用 $T=800$ 次 FISTA 迭代，从零向量开始初始化算法，并使用固定的随机种子 $12345$ 生成噪声以确保可复现性。\n\n测试套件：\n- 案例1（两个良好分离的源，中等噪声，多频）：\n  - $L = 1.0$ 米, $c = 1.0$ 米/秒。\n  - 角频率 $\\omega \\in \\{10.0,\\,20.0,\\,30.0,\\,40.0,\\,50.0\\}$ 弧度/秒。\n  - 真实源位置 $x_1 = 0.25$ 米, $x_2 = 0.75$ 米；振幅 $a_1 = 1.0$, $a_2 = 0.7$（无单位），与最近的网格点对齐。\n  - 噪声水平 $\\eta = 0.05$，正则化参数 $\\lambda = 0.05$，检测阈值 $\\tau_\\text{det} = 0.20$。\n- 案例2（单个近边界源，较少频率，较高噪声）：\n  - $L = 1.0$ 米, $c = 1.0$ 米/秒。\n  - 角频率 $\\omega \\in \\{5.0,\\,10.0,\\,15.0\\}$ 弧度/秒。\n  - 真实源位置 $x_1 = 0.02$ 米；振幅 $a_1 = 1.0$（无单位），与最近的网格点对齐。\n  - 噪声水平 $\\eta = 0.10$，正则化参数 $\\lambda = 0.08$，检测阈值 $\\tau_\\text{det} = 0.25$。\n- 案例3（无源，中等噪声，较强正则化）：\n  - $L = 1.0$ 米, $c = 1.0$ 米/秒。\n  - 角频率 $\\omega \\in \\{10.0,\\,20.0,\\,30.0\\}$ 弧度/秒。\n  - 无源（即 $\\mathbf{x}_\\text{true} = \\mathbf{0}$）。\n  - 噪声水平 $\\eta = 0.05$，正则化参数 $\\lambda = 0.10$，检测阈值 $\\tau_\\text{det} = 0.25$。\n- 案例4（两个紧邻的源，较高频率，低噪声）：\n  - $L = 1.0$ 米, $c = 1.0$ 米/秒。\n  - 角频率 $\\omega \\in \\{60.0,\\,80.0,\\,100.0,\\,120.0\\}$ 弧度/秒。\n  - 真实源位置 $x_1 = 0.49$ 米, $x_2 = 0.51$ 米；振幅 $a_1 = 1.0$, $a_2 = 0.8$（无单位），与最近的网格点对齐。\n  - 噪声水平 $\\eta = 0.02$，正则化参数 $\\lambda = 0.04$，检测阈值 $\\tau_\\text{det} = 0.15$。\n\n对于每个测试用例，计算并返回一个包含四个量的列表：匹配源的整数数量、以米为单位的平均绝对位置误差（浮点数）、平均绝对振幅误差（浮点数）以及误报的整数数量。您的程序应生成单行输出，其中包含所有四个测试用例的结果，格式为由方括号括起来的、以逗号分隔的各用例列表，其中不含嵌入的空格。例如，一个有效的输出格式是 $[[1,0.01,0.05,0],[\\dots]]$（所示数字仅为示例，并非实际答案）。", "solution": "用户提供了一个关于一维波传播模型逆源定位的问题。我将首先验证问题陈述，然后提供详细的解决方案。\n\n### 第1步：提取给定信息\n- **物理模型**：在一维区间 $[0,L]$ 上波速为常数 $c$ 的波传播。\n- **源模型**：狄拉克 (Dirac) 点源的稀疏和，$s(x) = \\sum_{j=1}^{J} a_j \\,\\delta(x - x_j)$，其中 $a_j$ 是复振幅，$x_j$ 是离散空间网格上的位置。\n- **测量设置**：在 $x=0$ 和 $x=L$ 处的两个点传感器。测量是在一组角频率 $\\{\\omega_\\ell\\}_{\\ell=1}^{F}$ 下的频域中进行的。\n- **前向算子**：测量向量 $\\mathbf{y} \\in \\mathbb{C}^{MF}$（其中 $M=2$ 是传感器数量）通过线性系统 $\\mathbf{y} = \\mathbf{A}\\,\\mathbf{x} + \\boldsymbol{\\varepsilon}$ 与源振幅向量 $\\mathbf{x} \\in \\mathbb{C}^{N}$（在 $N$ 点网格上离散化）相关。矩阵 $\\mathbf{A} \\in \\mathbb{C}^{MF \\times N}$ 的元素为 $A_{(\\ell,m),j} = G_{\\omega_\\ell}(|x_m - x_j|)$，其中 $G_\\omega(r) = \\frac{i}{2k}\\, e^{i k r}$ 是自由空间格林 (Green) 函数，且 $k = \\omega/c$。\n- **逆问题**：任务是从带噪声的测量 $\\mathbf{y}$ 中恢复稀疏向量 $\\mathbf{x}$，通过求解 LASSO 优化问题：\n$$\n\\widehat{\\mathbf{x}} \\;=\\; \\arg\\min_{\\mathbf{z}\\in\\mathbb{C}^{N}} \\;\\frac{1}{2}\\,\\|\\mathbf{A}\\,\\mathbf{z} - \\mathbf{y}\\|_2^2 \\;+\\; \\lambda \\,\\|\\mathbf{z}\\|_1.\n$$\n- **求解器**：指定使用快速迭代收缩阈值算法 (FISTA)。\n    - 最大迭代次数 $T=800$。\n    - 使用零向量进行初始化。\n    - 梯度步长由 $\\mathbf{A}^*\\mathbf{A}$ 的最大特征值决定，该特征值通过幂迭代法估计。\n    - 近端步骤使用复数值软阈值算子：$z \\neq 0$ 时为 $S_\\tau(z) = \\max\\{|z|-\\tau, 0\\}\\,\\frac{z}{|z|}$。\n- **噪声模型**：加性独立同分布复高斯噪声，其中每个分量的实部和虚部的标准差为 $\\sigma = \\eta \\cdot \\operatorname{median}(|\\mathbf{y}_\\text{clean}|)$，如果中位数为零，则备用值为 $\\sigma = \\eta$。需使用固定的随机种子 $12345$。\n- **评估**：如果在网格索引 $j$ 处 $|\\widehat{x}_j| \\ge \\tau_\\text{det}$，则检测到一个源。如果检测到的源的网格索引与真实源索引的差异在 $1$ 以内，则为匹配。要求的输出指标是匹配数、平均绝对位置误差、平均绝对振幅误差和误报数。\n- **问题参数**：提供了四个不同测试用例的所有参数，包括几何形状 ($L$)、波速 ($c$)、频率 ($\\omega$)、真实源位置和振幅、正则化参数 ($\\lambda$)、噪声水平 ($\\eta$)、检测阈值 ($\\tau_\\text{det}$) 和网格大小 ($N=101$)。\n\n### 第2步：使用提取的信息进行验证\n对问题进行严格的验证检查。\n- **科学基础**：该问题在物理学（亥姆霍兹方程）、逆问题数学和凸优化理论方面有充分的依据。格林函数、LASSO 正则化和 FISTA 算法的使用都是该领域的标准和合理原则。\n- **适定性**：虽然底层的逆问题是不适定的，但 LASSO 公式将其正则化为一个具有唯一解的适定凸优化问题。评估标准清晰明确。\n- **客观性**：问题陈述使用精确、定量和客观的语言，不含任何主观因素。\n- **完整性与一致性**：问题陈述异常详尽，提供了所有必要的参数、常数、算法，甚至随机种子，以确保单一、可复现的结果。没有明显的矛盾。\n- **可行性**：物理和计算参数是合理的，允许在标准环境中计算出解决方案。选择自由空间格林函数作为模型是此基于仿真的问题中一个有效且自洽的简化。\n\n### 第3步：结论与行动\n该问题是**有效的**。这是一个定义明确、科学正确且完整的计算逆理论问题。我将着手开发解决方案。\n\n### 解决方案设计\n\n该解决方案将使用 Python 中的 `numpy` 库实现。总体结构将遵循测试套件，按顺序处理每个案例。对于每个案例，将执行以下步骤：\n\n1.  **模型构建**：\n    - 在域 $[0, L]$ 上创建一个包含 $N=101$ 个点的均匀空间网格。\n    - 通过将给定的源振幅放置在最接近指定物理位置的网格点上，构建真实源向量 $\\mathbf{x}_{\\text{true}} \\in \\mathbb{C}^N$。\n    - 组装前向算子矩阵 $\\mathbf{A} \\in \\mathbb{C}^{MF \\times N}$。每一行对应一个特定的频率和传感器组合，每一列对应网格上的一个潜在源位置。矩阵元素使用提供的格林函数公式 $G_\\omega(r) = \\frac{i}{2k} e^{ikr}$ 计算，其中 $k=\\omega/c$。\n\n2.  **数据生成**：\n    - 计算干净的测量向量 $\\mathbf{y}_{\\text{clean}} = \\mathbf{A}\\,\\mathbf{x}_{\\text{true}}$。\n    - 根据噪声水平 $\\eta$ 和干净测量值绝对值的中位数计算噪声标准差 $\\sigma$。\n    - 使用指定的随机种子（$12345$）生成加性复高斯噪声，并将其添加到干净数据中，以获得带噪声的测量向量 $\\mathbf{y}$。\n\n3.  **逆求解器 (FISTA)**：\n    - 使用 FISTA 最小化 LASSO 目标函数。该函数结合了最小二乘数据拟合项 $\\frac{1}{2}\\|\\mathbf{A}\\mathbf{z} - \\mathbf{y}\\|_2^2$ 和 $\\ell_1$ 范数正则化项 $\\lambda\\|\\mathbf{z}\\|_1$。\n    - **步长**：FISTA 算法需要一个步长 $\\alpha$，该步长设置为最小二乘项梯度利普希茨 (Lipschitz) 常数的倒数。此常数是矩阵 $\\mathbf{A}^*\\mathbf{A}$ 的最大特征值。它通过标准的幂迭代法估计，使用随机向量进行初始化以保证鲁棒性。使用共享的随机数生成器确保可复现性。\n    - **迭代**：FISTA 算法迭代更新解的估计值，共进行 $T=800$ 次迭代。每次迭代包括：\n        a. 一个动量步以加速收敛。\n        b. 一个关于最小二乘项的梯度下降步。\n        c. 一个近端步，涉及应用复数软阈值算子 $S_{\\lambda\\alpha}(\\cdot)$ 以促进稀疏性。\n    - 算法的最终输出是估计的稀疏源向量 $\\widehat{\\mathbf{x}}$。\n\n4.  **结果评估**：\n    - 通过在 $\\widehat{\\mathbf{x}}$ 中找到所有振幅大小 $|\\widehat{x}_j|$ 超过检测阈值 $\\tau_\\text{det}$ 的网格索引 $j$，来识别恢复的源位置。\n    - 实现一个匹配程序，将恢复的源与真实源关联起来。如果一个恢复源的网格索引与真实源的网格索引相差不超过 $1$，则认为它们匹配。为处理歧义，每个恢复的源最多只能匹配一个真实源，反之亦然，采用优先选择更近索引匹配的贪婪方法。\n    - 基于此匹配，计算四个所需的指标：\n        1.  匹配源的总数。\n        2.  匹配对的平均绝对位置误差。\n        3.  匹配对的平均绝对振幅误差。\n        4.  误报数（未匹配任何真实源的恢复源数量）。\n    - 如果没有匹配的源，则平均误差报告为 $0.0$。\n\n整个过程封装在一个函数中，对每个测试用例调用。最终结果被收集并格式化为指定的单个字符串。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the inverse source localization problem.\n    \"\"\"\n\n    test_cases = [\n        # Case 1\n        {\n            \"L\": 1.0, \"c\": 1.0, \"N\": 101,\n            \"omegas\": [10.0, 20.0, 30.0, 40.0, 50.0],\n            \"true_sources\": [(0.25, 1.0), (0.75, 0.7)],\n            \"eta\": 0.05, \"lambda_reg\": 0.05, \"tau_det\": 0.20,\n            \"T\": 800, \"seed\": 12345\n        },\n        # Case 2\n        {\n            \"L\": 1.0, \"c\": 1.0, \"N\": 101,\n            \"omegas\": [5.0, 10.0, 15.0],\n            \"true_sources\": [(0.02, 1.0)],\n            \"eta\": 0.10, \"lambda_reg\": 0.08, \"tau_det\": 0.25,\n            \"T\": 800, \"seed\": 12345\n        },\n        # Case 3\n        {\n            \"L\": 1.0, \"c\": 1.0, \"N\": 101,\n            \"omegas\": [10.0, 20.0, 30.0],\n            \"true_sources\": [],\n            \"eta\": 0.05, \"lambda_reg\": 0.10, \"tau_det\": 0.25,\n            \"T\": 800, \"seed\": 12345\n        },\n        # Case 4\n        {\n            \"L\": 1.0, \"c\": 1.0, \"N\": 101,\n            \"omegas\": [60.0, 80.0, 100.0, 120.0],\n            \"true_sources\": [(0.49, 1.0), (0.51, 0.8)],\n            \"eta\": 0.02, \"lambda_reg\": 0.04, \"tau_det\": 0.15,\n            \"T\": 800, \"seed\": 12345\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_case(params)\n        all_results.append(result)\n\n    list_of_strings = [str(r).replace(' ', '') for r in all_results]\n    print(f\"[{','.join(list_of_strings)}]\")\n\ndef run_case(params):\n    \"\"\"\n    Executes a single test case for the source localization problem.\n    \"\"\"\n    L, c, N = params[\"L\"], params[\"c\"], params[\"N\"]\n    omegas = np.array(params[\"omegas\"])\n    true_sources = params[\"true_sources\"]\n    eta, lambda_reg, tau_det = params[\"eta\"], params[\"lambda_reg\"], params[\"tau_det\"]\n    T_max = params[\"T\"]\n    seed = params[\"seed\"]\n    \n    # Setup grid and sensors\n    grid = np.linspace(0, L, N)\n    sensor_pos = np.array([0.0, L])\n    M = len(sensor_pos)\n    F = len(omegas)\n\n    # Construct true source vector x_true\n    x_true = np.zeros(N, dtype=complex)\n    for pos, amp in true_sources:\n        idx = np.argmin(np.abs(grid - pos))\n        x_true[idx] = amp\n\n    # Construct forward operator A\n    A = np.zeros((M * F, N), dtype=complex)\n    for i_f, omega in enumerate(omegas):\n        k = omega / c\n        if k == 0: continue\n        \n        G_func = lambda r: (1j / (2 * k)) * np.exp(1j * k * r)\n        \n        for i_m, xm in enumerate(sensor_pos):\n            row_idx = i_f * M + i_m\n            r_vec = np.abs(xm - grid)\n            A[row_idx, :] = G_func(r_vec)\n    \n    # Generate noisy measurement vector y\n    y_clean = A @ x_true\n    \n    median_abs_y = np.median(np.abs(y_clean)) if len(y_clean) > 0 else 0.0\n    sigma = eta * median_abs_y if median_abs_y > 0 else eta\n        \n    rng = np.random.RandomState(seed)\n    noise = sigma * (rng.randn(M * F) + 1j * rng.randn(M * F))\n    y = y_clean + noise\n\n    # Solve with FISTA\n    x_hat = fista_solver(A, y, lambda_reg, T_max, rng)\n\n    # Evaluate results\n    true_indices = np.where(np.abs(x_true) > 1e-9)[0]\n    detected_indices = np.where(np.abs(x_hat) >= tau_det)[0]\n\n    matched_pairs = []\n    used_detections = set()\n\n    for jt in sorted(list(true_indices)):\n        candidates = [jd for jd in detected_indices if abs(jd - jt) <= 1 and jd not in used_detections]\n        if candidates:\n            # Find the best match (closest in index) and mark it as used\n            closest_jd = min(candidates, key=lambda jd: abs(jd - jt))\n            matched_pairs.append((jt, closest_jd))\n            used_detections.add(closest_jd)\n            \n    num_matched = len(matched_pairs)\n    num_fp = len(detected_indices) - len(used_detections)\n\n    pos_errors = []\n    amp_errors = []\n    if num_matched > 0:\n        for jt, jd in matched_pairs:\n            pos_errors.append(np.abs(grid[jd] - grid[jt]))\n            amp_errors.append(np.abs(np.abs(x_hat[jd]) - np.abs(x_true[jt])))\n\n    mean_pos_err = np.mean(pos_errors) if pos_errors else 0.0\n    mean_amp_err = np.mean(amp_errors) if amp_errors else 0.0\n\n    return [num_matched, mean_pos_err, mean_amp_err, num_fp]\n\ndef soft_thresholding(z, tau):\n    \"\"\"Complex-valued soft-thresholding operator.\"\"\"\n    abs_z = np.abs(z)\n    shrunk_abs = np.maximum(abs_z - tau, 0.0)\n    \n    # Handle division by zero for elements where abs_z is 0\n    unit_z = np.divide(z, abs_z, out=np.zeros_like(z, dtype=complex), where=abs_z != 0)\n    \n    return shrunk_abs * unit_z\n\ndef fista_solver(A, y, lambda_reg, T_max, rng):\n    \"\"\"\n    Solves the LASSO problem using the FISTA algorithm.\n    \"\"\"\n    N = A.shape[1]\n\n    # Estimate Lipschitz constant via power iteration\n    B = A.conj().T @ A\n    v = rng.randn(N) + 1j * rng.randn(N)\n    v /= np.linalg.norm(v)\n    for _ in range(20): # Power iterations\n        Bv = B @ v\n        v = Bv / np.linalg.norm(Bv)\n    \n    L_f = np.real(v.conj().T @ B @ v)\n    alpha = 1.0 / L_f if L_f > 0 else 1.0\n\n    # FISTA iteration\n    x_k = np.zeros(N, dtype=complex)\n    x_km1 = np.zeros(N, dtype=complex)\n    t_k = 1.0\n    t_km1 = 1.0\n    \n    for _ in range(T_max):\n        y_k = x_k + ((t_km1 - 1.0) / t_k) * (x_k - x_km1)\n        grad_y_k = A.conj().T @ (A @ y_k - y)\n        x_kp1 = soft_thresholding(y_k - alpha * grad_y_k, lambda_reg * alpha)\n        \n        t_kp1 = (1.0 + np.sqrt(1.0 + 4.0 * t_k**2)) / 2.0\n        \n        # Update state for next iteration\n        x_km1 = x_k\n        x_k = x_kp1\n        t_km1 = t_k\n        t_k = t_kp1\n        \n    return x_k\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3370666"}]}