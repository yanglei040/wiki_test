{"hands_on_practices": [{"introduction": "在尝试求解逆问题之前，评估其内在的稳定性至关重要。条件数为此提供了一个简洁而有力的度量，它量化了数据误差在最坏情况下的放大倍数。通过这个练习 [@problem_id:3382306]，我们将学习如何从算子的奇异值中计算出条件数，并理解它对解的可靠性的直接影响。", "problem": "考虑一个定义在赋有欧几里得范数的有限维希尔伯特空间之间的线性正演模型 $y = A x$，其中 $A:\\mathbb{R}^{3}\\to\\mathbb{R}^{3}$ 是一个有界可逆线性算子。相应的逆问题是从含噪数据 $y^{\\delta} = y + \\eta$ 中恢复 $x$，其中 $\\eta$ 是一个未知的扰动。$A$ 的奇异值分解（SVD）得到的奇异值为 $\\sigma_{1}$、$\\sigma_{2}$ 和 $\\sigma_{3}$，其排序满足 $\\sigma_{1} \\ge \\sigma_{2} \\ge \\sigma_{3} > 0$。假设该算子的奇异值分别为 $\\sigma_{1} = 18$，$\\sigma_{2} = 5$ 和 $\\sigma_{3} = 0.09$。\n\n仅使用欧几里得空间上线性算子理论的核心定义，计算正演算子关于欧几里得范数的条件数。然后，从数据到解的映射对数据扰动的最坏情况放大效应的角度，解释该条件数对于逆问题解的可靠性的意义。您最终报告的结果必须是计算出的条件数，以一个不带单位的实数形式给出。无需四舍五入。", "solution": "用户提供了一个有效的问题陈述。\n\n该问题要求做两件事：首先，计算线性算子 $A$ 的条件数；其次，在相关逆问题的背景下解释其意义。算子 $A$ 从 $\\mathbb{R}^{3}$ 映射到 $\\mathbb{R}^{3}$，当赋予标准内积和诱导的欧几里得范数（记作 $\\|\\cdot\\|$）时，它们是有限维希尔伯特空间。欧几里得范数等价于 $L^2$ 范数，因此我们使用记号 $\\|\\cdot\\|_2$。\n\n线性算子 $A$ 关于特定范数的条件数，记作 $\\kappa(A)$，定义为该算子的范数与其逆算子范数的乘积：\n$$\n\\kappa(A) = \\|A\\| \\|A^{-1}\\|\n$$\n问题指定使用欧几里得范数。对于矩阵或线性算子 $A$，其诱导 $2$-范数 $\\|A\\|_2$ 定义为：\n$$\n\\|A\\|_2 = \\sup_{x \\neq 0} \\frac{\\|Ax\\|_2}{\\|x\\|_2}\n$$\n线性代数中的一个基本结论指出，算子 $A$ 的 $2$-范数等于其最大的奇异值 $\\sigma_{\\max}$。$A$ 的奇异值是自伴算子 $A^*A$ 的特征值的平方根，其中 $A^*$ 是 $A$ 的伴随算子。\n\n问题给出了 $A$ 的奇异值为 $\\sigma_{1} = 18$，$\\sigma_{2} = 5$ 和 $\\sigma_{3} = 0.09$，且排序满足 $\\sigma_{1} \\ge \\sigma_{2} \\ge \\sigma_{3} > 0$。因此，最大的奇异值为 $\\sigma_{\\max} = \\sigma_{1} = 18$。\n所以，算子 $A$ 的 $2$-范数为：\n$$\n\\|A\\|_2 = \\sigma_{1} = 18\n$$\n接下来，我们必须求出逆算子 $A^{-1}$ 的范数，即 $\\|A^{-1}\\|_2$。问题陈述算子 $A$ 是可逆的，这与其所有奇异值均为严格正数（$\\sigma_3 = 0.09 > 0$）的事实相符。如果 $A$ 的奇异值是 $\\sigma_i$，那么其逆算子 $A^{-1}$ 的奇异值就是 $\\sigma_i^{-1}$。\n逆算子的范数 $\\|A^{-1}\\|_2$ 等于 $A^{-1}$ 的最大奇异值。由于 $A$ 的奇异值排序为 $\\sigma_1 \\ge \\sigma_2 \\ge \\sigma_3 > 0$，它们的倒数将排序为 $\\sigma_3^{-1} \\ge \\sigma_2^{-1} \\ge \\sigma_1^{-1} > 0$。\n因此，$A^{-1}$ 的最大奇异值是 $\\sigma_3^{-1}$。\n$$\n\\|A^{-1}\\|_2 = \\sigma_{\\max}(A^{-1}) = (\\sigma_{\\min}(A))^{-1} = \\frac{1}{\\sigma_3} = \\frac{1}{0.09}\n$$\n现在我们可以计算关于 $2$-范数的条件数 $\\kappa_2(A)$：\n$$\n\\kappa_2(A) = \\|A\\|_2 \\|A^{-1}\\|_2 = \\sigma_{1} \\cdot \\frac{1}{\\sigma_{3}} = \\frac{\\sigma_{1}}{\\sigma_{3}}\n$$\n代入给定的数值：\n$$\n\\kappa_2(A) = \\frac{18}{0.09} = \\frac{18}{\\frac{9}{100}} = 18 \\cdot \\frac{100}{9} = 2 \\cdot 100 = 200\n$$\n\n问题的第二部分要求解释这个结果对于逆问题解的可靠性的意义。逆问题是在给定含噪数据 $y^{\\delta}$ 的情况下求解 $x$。“真实”的无噪声数据是 $y = Ax$，对应的真实解是 $x = A^{-1}y$。测量数据是 $y^{\\delta} = y + \\eta$，其中 $\\eta$ 是一个未知的扰动。逆问题的一个朴素解法是将逆算子直接应用于含噪数据：\n$$\nx^{\\delta} = A^{-1}y^{\\delta} = A^{-1}(y + \\eta) = A^{-1}y + A^{-1}\\eta = x + A^{-1}\\eta\n$$\n解的误差为 $\\Delta x = x^{\\delta} - x = A^{-1}\\eta$。我们关心的是数据中的相对误差 $\\frac{\\|\\eta\\|_2}{\\|y\\|_2}$ 如何传播到解中的相对误差 $\\frac{\\|\\Delta x\\|_2}{\\|x\\|_2}$。\n我们有以下不等式：\n$$\n\\|\\Delta x\\|_2 = \\|A^{-1}\\eta\\|_2 \\le \\|A^{-1}\\|_2 \\|\\eta\\|_2\n$$\n并且根据正演模型 $y=Ax$：\n$$\n\\|y\\|_2 = \\|Ax\\|_2 \\le \\|A\\|_2 \\|x\\|_2 \\implies \\|x\\|_2 \\ge \\frac{\\|y\\|_2}{\\|A\\|_2}\n$$\n结合这两个不等式，我们可以得到解的相对误差的上界：\n$$\n\\frac{\\|\\Delta x\\|_2}{\\|x\\|_2} \\le \\frac{\\|A^{-1}\\|_2 \\|\\eta\\|_2}{\\frac{\\|y\\|_2}{\\|A\\|_2}} = \\|A\\|_2 \\|A^{-1}\\|_2 \\frac{\\|\\eta\\|_2}{\\|y\\|_2} = \\kappa_2(A) \\frac{\\|\\eta\\|_2}{\\|y\\|_2}\n$$\n这个不等式揭示了条件数的意义。它代表了相对误差的最坏情况放大因子。具体来说，计算解中的相对误差最大可以是测量数据中相对误差的 $\\kappa_2(A)$ 倍。\n在本例中，$\\kappa_2(A) = 200$。这表明该逆问题是病态的。数值为 $200$ 意味着数据中的一个小的相对误差在解中可能被放大高达 $200$ 倍。例如，如果测量数据 $y^{\\delta}$ 的相对噪声水平为 $1\\%$（即 $\\frac{\\|\\eta\\|_2}{\\|y\\|_2} = 0.01$），那么解的相对误差 $\\frac{\\|\\Delta x\\|_2}{\\|x\\|_2}$ 可能高达 $200 \\times 0.01 = 2$，相当于 $200\\%$ 的误差。这表明朴素解 $x^{\\delta} = A^{-1}y^{\\delta}$ 是高度不可靠且可能毫无意义的，因为误差可能比解本身还要大。如此高的条件数表明，必须使用正则化技术来获得逆问题的稳定且有意义的近似解。", "answer": "$$\\boxed{200}$$", "id": "3382306"}, {"introduction": "条件数给出了一个全局的、最坏情况下的不稳定性度量，而离散皮卡德条件则提供了一种更精细的诊断工具。它使我们能够通过比较数据在奇异向量上的投影和奇异值的衰减速率，来判断解的哪些分量被噪声主导。这项实践 [@problem_id:3382319] 训练我们如何通过分析数据来评估一个朴素最小二乘解是否可行，这是逆问题从业者的核心技能。", "problem": "考虑一个线性正演模型 $y = A x_{\\text{true}} + e$，其中 $A \\in \\mathbb{R}^{m \\times n}$ 是一个由数据同化中的线性化观测算子产生的紧算子，$x_{\\text{true}} \\in \\mathbb{R}^{n}$ 是未知状态，$y \\in \\mathbb{R}^{m}$ 是数据，$e \\in \\mathbb{R}^{m}$ 是加性测量噪声。令 $A = U \\Sigma V^\\top$ 表示其奇异值分解 (SVD)，其奇异值为 $\\sigma_1 \\ge \\sigma_2 \\ge \\cdots \\ge \\sigma_r > 0$，其中 $r = \\operatorname{rank}(A)$，左右奇异向量分别为 $\\{u_i\\}_{i=1}^r$ 和 $\\{v_i\\}_{i=1}^r$。\n\n假设 $m = n = 200$ 且已知 $A$ 的奇异值遵循多项式衰减 $\\sigma_i \\approx i^{-2}$，对于 $i = 1,2,\\ldots,200$。一次测量活动产生了数据 $y$，使得经验系数 $|u_i^\\top y|$ 满足以下行为：\n- 对于 $1 \\le i \\le 30$，$|u_i^\\top y| \\approx 0.5\\, i^{-3}$。\n- 对于 $31 \\le i \\le 200$，$|u_i^\\top y| \\approx 2 \\times 10^{-5}$ (一个噪声基底，在测量精度范围内与 $i$ 无关)。\n\n要求您通过比较 $|u_i^\\top y|$ 的衰减与 $\\sigma_i$ 的衰减来评估 Picard 条件，并从这个比较中推断出，在不使用正则化的情况下求解朴素最小二乘 (LS) 问题 $\\min_x \\|A x - y\\|_2^2$ 是否可行，即可行性指的是能否从含噪数据中产生对 $x_{\\text{true}}$ 的稳定估计。\n\n下列哪个陈述最为准确？\n\nA. Picard 条件对所有 $i$ 都成立，因为 $|u_i^\\top y|$ 的衰减速度快于 $\\sigma_i$，所以不带正则化的朴素 LS 会得到一个稳定的解。\n\nB. Picard 条件仅在数据系数衰减的低索引范围（$i \\le 30$）内成立，但在噪声主导的尾部（$i \\ge 31$）被违反，因为在此范围内 $|u_i^\\top y|$ 相对于 $\\sigma_i$ 停止衰减；因此，朴素 LS 会放大噪声，在没有正则化的情况下是不可行的。\n\nC. Picard 条件比较的是 $|u_i^\\top y|$ 与 $\\sigma_i^2$，并且因为 $|u_i^\\top y|$ 的衰减速度快于 $\\sigma_i^2$，所以朴素 LS 是稳定的。\n\nD. $|u_i^\\top y|$ 的衰减与稳定性无关；朴素 LS 的可行性仅取决于 $|v_i^\\top x_{\\text{true}}|$ 的行为，因此在这种情况下朴素 LS 是可行的。", "solution": "该问题陈述是反演问题和数据同化领域中一个有效且适定的场景。它要求基于奇异值的衰减特性和测得的数据系数，来评估朴素最小二乘解的稳定性。\n\n我们首先回顾线性最小二乘问题 $\\min_x \\|A x - y\\|_2^2$ 的形式解。对于一个具有奇异值分解 (SVD) $A = U \\Sigma V^\\top$ 的矩阵 $A$，其中 $U$ 和 $V$ 是正交矩阵，$\\Sigma$ 是由奇异值 $\\sigma_i$ 构成的对角矩阵，其解由 $x_{\\text{LS}} = A^{\\dagger}y$ 给出，其中 $A^{\\dagger} = V \\Sigma^{\\dagger} U^\\top$ 是 Moore-Penrose 伪逆。由于问题指定 $m = n = 200$ 并提供了从 $1$ 到 $200$ 的所有 $i$ 的奇异值，我们假设矩阵 $A$ 是满秩的，因此 $A^{\\dagger} = A^{-1} = V \\Sigma^{-1} U^\\top$。\n\n解可以写成关于奇异分量的和：\n$$\nx_{\\text{LS}} = \\sum_{i=1}^{n} \\frac{u_i^\\top y}{\\sigma_i} v_i\n$$\n其中 $\\{u_i\\}$ 和 $\\{v_i\\}$ 分别是 $U$ 和 $V$ 的列（左奇异向量和右奇异向量）。\n\n数据 $y$ 由 $y = A x_{\\text{true}} + e$ 给出，其中 $x_{\\text{true}}$ 是真实未知状态，$e$ 是测量噪声。将此代入解的公式可得：\n$$\nx_{\\text{LS}} = \\sum_{i=1}^{n} \\frac{u_i^\\top (A x_{\\text{true}} + e)}{\\sigma_i} v_i\n$$\n我们可以将其分为两部分。第一部分涉及真实信号：\n$u_i^\\top A x_{\\text{true}} = u_i^\\top (U \\Sigma V^\\top) x_{\\text{true}} = (U^\\top \\text{的第 } i \\text{ 行})(U \\Sigma V^\\top) x_{\\text{true}} = e_i^\\top \\Sigma V^\\top x_{\\text{true}} = \\sigma_i v_i^\\top x_{\\text{true}}$。\n此处，$e_i$ 是第 $i$ 个标准基向量。\n第二部分是噪声的投影：$u_i^\\top e$。\n因此，解变为：\n$$\nx_{\\text{LS}} = \\sum_{i=1}^{n} \\frac{\\sigma_i v_i^\\top x_{\\text{true}} + u_i^\\top e}{\\sigma_i} v_i = \\sum_{i=1}^{n} (v_i^\\top x_{\\text{true}}) v_i + \\sum_{i=1}^{n} \\frac{u_i^\\top e}{\\sigma_i} v_i\n$$\n第一个求和项 $\\sum_{i=1}^{n} (v_i^\\top x_{\\text{true}}) v_i$ 是 $x_{\\text{true}}$ 在基 $\\{v_i\\}$ 上的投影，它重构了 $x_{\\text{true}}$ 本身。因此：\n$$\nx_{\\text{LS}} = x_{\\text{true}} + \\sum_{i=1}^{n} \\frac{u_i^\\top e}{\\sigma_i} v_i\n$$\n解的稳定性由误差项 $\\sum_{i=1}^{n} \\frac{u_i^\\top e}{\\sigma_i} v_i$ 的大小决定。该问题是不适定的，因为奇异值 $\\sigma_i$ 衰减到零。如果噪声系数 $u_i^\\top e$ 的衰减速度不够快（至少与 $\\sigma_i$ 一样快），那么对于较大的 $i$，比率 $\\frac{u_i^\\top e}{\\sigma_i}$ 将会很大，从而导致噪声被放大，解变得不稳定。\n\n离散 Picard 条件提供了一种诊断这种不稳定性的实用方法。它要求为了获得稳定的重构，系数 $|u_i^\\top y|$ 的衰减速度必须快于奇异值 $\\sigma_i$。如果此条件被违反，则表明噪声分量 $u_i^\\top e$ 正在主导信号分量 $\\sigma_i v_i^\\top x_{\\text{true}}$，而除以小的 $\\sigma_i$ 将会放大这个噪声。\n\n让我们根据这个条件来分析给定的数据：\n已知：$\\sigma_i \\approx i^{-2}$。\n\n情况 1：$1 \\le i \\le 30$\n我们有 $|u_i^\\top y| \\approx 0.5\\, i^{-3}$。\n让我们考察解的求和式中出现的比率：\n$\\frac{|u_i^\\top y|}{\\sigma_i} \\approx \\frac{0.5\\, i^{-3}}{i^{-2}} = 0.5\\, i^{-1}$\n在这个索引范围内，该比率是衰减的。解展开式的系数是良态的。这表明对于 $i \\le 30$，数据由真实信号主导，Picard 条件得到满足。\n\n情况 2：$31 \\le i \\le 200$\n我们有 $|u_i^\\top y| \\approx 2 \\times 10^{-5}$，这是一个恒定的噪声基底。\n现在，比率变为：\n$\\frac{|u_i^\\top y|}{\\sigma_i} \\approx \\frac{2 \\times 10^{-5}}{i^{-2}} = (2 \\times 10^{-5}) i^2$\n在这个范围内，该比率随 $i$ 呈二次方*增长*。这明显违反了 Picard 条件。$|u_i^\\top y|$ 的恒定值表明，任何潜在的信号分量都已降至噪声水平以下，因此 $|u_i^\\top y| \\approx |u_i^\\top e|$。除以快速衰减的 $\\sigma_i$ 将导致解 $x_{\\text{LS}}$ 中的这些噪声分量被极度放大。\n\n因此，对所有 $i$ 直到 $200$ 进行求和的朴素最小二乘解，将被来自 $i \\ge 31$ 项的、大的、错误的、高频的分量所主导。这使得解高度不稳定且没有物理意义。需要使用正则化技术（例如截断 SVD，即在 $i \\approx 30$ 处截断求和）来获得对 $x_{\\text{true}}$ 的稳定且有意义的估计。\n\n现在我们评估给定的选项：\n\nA. 这是**不正确**的。关于 $|u_i^\\top y|$ 衰减速度快于 $\\sigma_i$ 的陈述仅对 $i \\le 30$ 成立。对于 $i \\ge 31$，$|u_i^\\top y|$ 近似为常数，因此衰减速度远慢于 $\\sigma_i$。朴素 LS 是稳定的这一结论是错误的。\n\nB. 这是**正确**的。该陈述准确地描述了我们分析得出的情况。它正确地识别了两种机制，正确地评估了每种机制下的 Picard 条件，并对朴素 LS 解的可行性得出了正确的结论。\n\nC. 这是**不正确**的。LS 解 $x_{\\text{LS}} = \\sum (u_i^\\top y / \\sigma_i) v_i$ 的稳定性取决于系数 $u_i^\\top y / \\sigma_i$ 的行为。因此，相关的比较是在 $|u_i^\\top y|$ 和 $\\sigma_i$ 之间，而不是 $\\sigma_i^2$。比较的基本前提是错误的。\n\nD. 这是**不正确**的。从含噪数据 $y$ 计算出的解的稳定性，关键取决于 $y$ 的属性，其中包括噪声 $e$。如误差项的推导所示，不稳定性直接源于噪声系数 $u_i^\\top e$ 的放大，而它是 $u_i^\\top y$ 的一个分量。声称 $|u_i^\\top y|$ 的衰减无关紧要，是对噪声如何影响反演问题的根本性误解。虽然 $x_{\\text{true}}$ 的属性（反映在 $|v_i^\\top x_{\\text{true}}|$ 中）决定了信号分量，但决定稳定性的却是信号、噪声和算子奇异值之间的相互作用。", "answer": "$$\\boxed{B}$$", "id": "3382319"}, {"introduction": "一旦逆问题被诊断为不适定的，我们就需要一种“治疗”方法来获得稳定且有意义的解。本实践将通过一个编程练习 [@problem_id:3382223]，引导我们应用经典的吉洪诺夫（Tikhonov）正则化方法。练习的重点在于其中最关键的环节：如何选择正则化参数 $\\lambda$，我们将应用差异原则，并深入探讨当噪声存在相关性时，正确应用该原则所面临的实际挑战。", "problem": "考虑一个由矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 表示的线性正演算子和一个未知参数向量 $\\theta^\\star \\in \\mathbb{R}^{n}$。正向问题根据模型 $y = F(\\theta^\\star) + \\varepsilon$ 生成带有噪声的观测数据 $y \\in \\mathbb{R}^{m}$，其中 $F(\\theta) = A \\theta$，$\\varepsilon$ 是一个均值为零、协方差矩阵为 $\\Sigma \\in \\mathbb{R}^{m \\times m}$ 的高斯噪声。反演问题旨在从 $y$ 中恢复 $\\theta^\\star$。这个反演问题使用 Tikhonov 正则化进行正则化，正则化参数为 $\\lambda \\ge 0$，通过将估计量 $\\theta_\\lambda$ 定义为目标函数 $\\|A \\theta - y\\|_2^2 + \\lambda \\|\\theta\\|_2^2$ 的最小化子来实现。差异原则规定选择 $\\lambda$，使得数据失配与预设的噪声水平相匹配。\n\n您的任务是基于差异原则构建一个分类方法，并测试其在相关噪声下的可靠性。使用以下基本依据：\n\n- 正向问题和反演问题的定义：$F(\\theta) = A \\theta$，$y = A \\theta^\\star + \\varepsilon$，以及 $\\varepsilon \\sim \\mathcal{N}(0, \\Sigma)$。\n- Tikhonov 正则化定义：$\\theta_\\lambda$ 最小化 $\\|A \\theta - y\\|_2^2 + \\lambda \\|\\theta\\|_2^2$。\n- 欧几里得范数和马氏范数的定义：对于任意 $r \\in \\mathbb{R}^m$，$\\|r\\|_2 = \\sqrt{r^\\top r}$ 和 $\\|r\\|_{\\Sigma^{-1}} = \\sqrt{r^\\top \\Sigma^{-1} r}$。\n- 差异原则：给定一个噪声水平 $\\delta$，选择 $\\lambda$ 使得 $\\|F(\\theta_\\lambda) - y\\| \\approx \\delta$（在指定的范数下）。\n\n在一个完整的、可运行的程序中实现以下内容：\n\n1. 构建一个科学上真实、病态的正演算子。令 $m = n$。令 $A$ 为均匀网格 $[0,1]$ 上的平滑核的离散化，定义为\n   $$A_{ij} = \\exp\\left(-\\frac{(s_i - t_j)^2}{2 c^2}\\right),$$\n   其中 $s_i = \\frac{i-1}{m-1}$，$t_j = \\frac{j-1}{n-1}$，$c > 0$ 是一个相关长度。通过向 $A$ 添加一个小的正对角项来确保数值稳定性。\n\n2. 生成一个足以揭示病态性的振荡真值 $\\theta^\\star$。使用\n   $$\\theta^\\star_j = \\sin(2 \\pi t_j) + 0.5 \\sin(6 \\pi t_j), \\quad j = 1, \\dots, n.$$\n\n3. 对每个测试用例，构建协方差矩阵 $\\Sigma$ 和相应的噪声 $\\varepsilon \\sim \\mathcal{N}(0,\\Sigma)$，然后生成 $y = A \\theta^\\star + \\varepsilon$。使用差异原则计算两个参数：\n   - $\\lambda_{\\mathrm{E}}$，选择该参数以满足欧几里得差异条件 $\\|A \\theta_{\\lambda_{\\mathrm{E}}} - y\\|_2 \\approx \\delta_{\\mathrm{E}}$，其中 $\\delta_{\\mathrm{E}} = \\sqrt{\\operatorname{trace}(\\Sigma)}$。\n   - $\\lambda_{\\mathrm{M}}$，选择该参数以满足马氏差异条件 $\\|A \\theta_{\\lambda_{\\mathrm{M}}} - y\\|_{\\Sigma^{-1}} \\approx \\delta_{\\mathrm{M}}$，其中 $\\delta_{\\mathrm{M}} = \\sqrt{m}$。\n\n   上述条件应通过使用鲁棒的单调求根方案对 $\\lambda$ 进行求解来数值化地强制执行。\n\n4. 定义相关噪声下欧几里得差异的可靠性分类如下。计算出 $\\lambda_{\\mathrm{E}}$ 后，评估白化残差范数\n   $$\\|A \\theta_{\\lambda_{\\mathrm{E}}} - y\\|_{\\Sigma^{-1}},$$\n   并将其与 $\\delta_{\\mathrm{M}}$ 进行比较。如果相对偏差最多为 $0.05$，则宣布欧几里得差异是可靠的，即\n   $$\\frac{\\left|\\|A \\theta_{\\lambda_{\\mathrm{E}}} - y\\|_{\\Sigma^{-1}} - \\delta_{\\mathrm{M}}\\right|}{\\delta_{\\mathrm{M}}} \\le 0.05.$$\n\n5. 您的程序必须实现上述内容，并为一个涵盖不相关噪声和强相关噪声的测试套件生成可靠性分类。使用以下测试套件（$m = n = 50$，$c = 0.08$）：\n   - 案例 1（理想情况）：$\\Sigma = \\sigma^2 I$，其中 $\\sigma = 10^{-2}$，因此 $\\delta_{\\mathrm{E}} = \\sqrt{m} \\, \\sigma$ 且 $\\delta_{\\mathrm{M}} = \\sqrt{m}$。\n   - 案例 2（中度相关）：$\\Sigma_{ij} = \\sigma^2 \\rho^{|i-j|}$，其中 $\\rho = 0.9$ 且 $\\sigma = 10^{-2}$。\n   - 案例 3（强相关，低噪声）：$\\Sigma_{ij} = \\sigma^2 \\rho^{|i-j|}$，其中 $\\rho = 0.99$ 且 $\\sigma = 3 \\cdot 10^{-3}$。\n\n6. 对每个案例，计算并返回一个布尔值，指示根据上述标准，欧几里得差异是否可靠。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3]$）。\n\n程序必须是自包含的：它应该构建 $A$、$\\theta^\\star$、协方差 $\\Sigma$，模拟 $y$，通过数值搜索计算 $\\lambda_{\\mathrm{E}}$ 和 $\\lambda_{\\mathrm{M}}$，并对这三个案例进行分类评估。不涉及物理单位或角度。所有计算都应在 $\\mathbb{R}$ 中使用指定的范数进行，并且所有输出都必须是布尔值。", "solution": "该问题要求评估在存在相关噪声的情况下，Tikhonov 正则化中欧几里得差异原则的可靠性。我们将构建一个数值实验，以将此原则的结果与理论上合理的数据失配度量进行比较。\n\n**1. 数学公式化**\n\n线性正向问题由模型 $y = F(\\theta^\\star) + \\varepsilon$ 给出，其中正演算子为 $F(\\theta) = A\\theta$。数据 $y \\in \\mathbb{R}^m$ 受到加性高斯噪声 $\\varepsilon \\in \\mathbb{R}^m$ 的污染，该噪声均值为零，协方差矩阵为 $\\Sigma \\in \\mathbb{R}^{m \\times m}$，即 $\\varepsilon \\sim \\mathcal{N}(0, \\Sigma)$。矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 代表一个离散化的线性算子，$\\theta^\\star \\in \\mathbb{R}^n$ 是我们试图估计的未知真实参数向量。\n\n从 $y$ 中寻找 $\\theta$ 的反演问题是病态的，特别是对于指定的病态算子 $A$。我们采用 Tikhonov 正则化来找到一个稳定的解。对于给定的正则化参数 $\\lambda \\ge 0$，Tikhonov 正则化解 $\\theta_\\lambda$ 是目标函数的唯一最小化子：\n$$ J(\\theta) = \\|A\\theta - y\\|_2^2 + \\lambda \\|\\theta\\|_2^2 $$\n第一项衡量欧几里得范数下的数据失配，而第二项惩罚具有大欧几里得范数的解，从而强制施加平滑性。\n\n$\\theta_\\lambda$ 的解析解由正规方程给出：\n$$ \\theta_\\lambda = (A^\\top A + \\lambda I_n)^{-1} A^\\top y $$\n其中 $I_n$ 是 $n \\times n$ 的单位矩阵。\n\n**2. 模型与离散化**\n\n我们设置此问题的一个具体实例，维度为 $m=n=50$。\n正演算子 $A$ 是高斯平滑核的离散化，定义为：\n$$ A_{ij} = \\exp\\left(-\\frac{(s_i - t_j)^2}{2 c^2}\\right) $$\n其中 $s_i = \\frac{i-1}{m-1}$（对于 $i=1, \\dots, m$）和 $t_j = \\frac{j-1}{n-1}$（对于 $j=1, \\dots, n$）是区间 $[0, 1]$ 上的均匀网格。参数 $c=0.08$ 控制核的宽度。这类算子是出了名的病态，因为它们的奇异值会迅速衰减到零。为了确保数值稳定性，向 $A$ 添加了一个小项 $10^{-12} I_m$，这并不会实质性地影响问题的病态性质。\n\n真值参数向量 $\\theta^\\star$ 被选择为振荡的，这使其成为平滑算子恢复的挑战性目标：\n$$ \\theta^\\star_j = \\sin(2 \\pi t_j) + 0.5 \\sin(6 \\pi t_j) $$\n\n**3. 差异原则与相关噪声**\n\n正则化参数 $\\lambda$ 的选择至关重要。差异原则提供了一个选择 $\\lambda$ 的规则，它规定正则化解的残差 $r_\\lambda = A\\theta_\\lambda - y$ 应与噪声 $\\varepsilon$ 的预期量级相匹配。问题的核心在于如何衡量这个“量级”。\n\n如果噪声分量不相关且方差相等，即 $\\Sigma = \\sigma^2 I_m$，则欧几里得范数是合适的。噪声的预期欧几里得范数平方为 $\\mathbb{E}[\\|\\varepsilon\\|_2^2] = \\mathbb{E}[\\varepsilon^\\top\\varepsilon] = \\operatorname{trace}(\\Sigma) = m\\sigma^2$。因此，**欧几里得差异原则**旨在通过求解以下方程来找到 $\\lambda_E$：\n$$ \\|A\\theta_{\\lambda_E} - y\\|_2 = \\delta_E \\quad \\text{其中} \\quad \\delta_E = \\sqrt{\\operatorname{trace}(\\Sigma)} $$\n\n然而，如果噪声是相关的（$\\Sigma$ 不是对角矩阵），欧几里得范数就是一个误导性的失配度量。统计上正确的方法是通过变换将残差转换到一个噪声不相关且单位方差的空间中，从而“白化”残差。这是通过使用由协方差矩阵的逆定义的马氏范数来实现的：$\\|v\\|_{\\Sigma^{-1}} = \\sqrt{v^\\top \\Sigma^{-1} v}$。量 $\\varepsilon^\\top \\Sigma^{-1} \\varepsilon$ 服从自由度为 $m$ 的卡方分布 $\\chi^2_m$，其期望值为 $m$。因此，**马氏差异原则**是通过求解以下方程来找到 $\\lambda_M$：\n$$ \\|A\\theta_{\\lambda_M} - y\\|_{\\Sigma^{-1}} = \\delta_M \\quad \\text{其中} \\quad \\delta_M = \\sqrt{m} $$\n这个原则对噪声相关性是鲁棒的。问题要求我们通过检查更简单的（且常被天真地应用的）欧几里得原则的结果是否与马氏框架一致，来评估其可靠性。\n\n**4. 数值实现**\n\n为了有效地找到参数 $\\lambda_E$，我们必须为不同的 $\\lambda$ 值重复计算残差范数 $\\|A\\theta_\\lambda - y\\|_2$。每一步都通过求逆 $(A^\\top A + \\lambda I_n)$ 的直接实现方法在计算上是昂贵的。一种更优的方法是利用 $A$ 的奇异值分解（SVD）。令 $A = U S V^\\top$，其中 $U \\in \\mathbb{R}^{m \\times n}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 具有标准正交列，而 $S \\in \\mathbb{R}^{n \\times n}$ 是奇异值 $s_k > 0$ 的对角矩阵。\n\n残差向量 $r_\\lambda = A\\theta_\\lambda - y$ 可以使用 SVD 分量高效地表示：\n$$ r_\\lambda = U \\operatorname{diag}\\left(\\frac{-\\lambda}{s_k^2 + \\lambda}\\right) U^\\top y $$\n由于 $U$ 是酉矩阵，残差的欧几里得范数简化为：\n$$ \\|r_\\lambda\\|_2 = \\left\\| \\operatorname{diag}\\left(\\frac{\\lambda}{s_k^2 + \\lambda}\\right) U^\\top y \\right\\|_2 $$\n这个函数，我们称之为 $g(\\lambda) = \\|r_\\lambda\\|_2$，对于 $\\lambda > 0$ 是单调递增的。因此，我们可以使用像 Brent-Dekker 方法（`scipy.optimize.brentq`）这样的鲁棒数值求根算法来找到方程 $g(\\lambda) - \\delta_E = 0$ 的唯一根。\n\n一旦找到 $\\lambda_E$，我们就可以计算相应的残差 $r_{\\lambda_E}$。为了评估可靠性，我们必须计算其马氏范数 $\\|r_{\\lambda_E}\\|_{\\Sigma^{-1}}$。为了数值稳定性，这不通过直接求逆 $\\Sigma$ 来计算。而是使用协方差矩阵的 Cholesky 分解，$\\Sigma = L L^\\top$，其中 $L$ 是一个下三角矩阵。范数则为：\n$$ \\|r_{\\lambda_E}\\|_{\\Sigma^{-1}}^2 = r_{\\lambda_E}^\\top \\Sigma^{-1} r_{\\lambda_E} = r_{\\lambda_E}^\\top (L L^\\top)^{-1} r_{\\lambda_E} = r_{\\lambda_E}^\\top (L^{-1})^\\top L^{-1} r_{\\lambda_E} = \\|L^{-1} r_{\\lambda_E}\\|_2^2 $$\n向量 $z = L^{-1} r_{\\lambda_E}$ 通过求解三角系统 $Lz = r_{\\lambda_E}$ 来高效计算。马氏范数就是 $\\|z\\|_2$。\n\n**5. 可靠性分类**\n\n如果得到的解 $\\theta_{\\lambda_E}$ 产生的白化残差范数接近理论目标 $\\delta_M = \\sqrt{m}$，则欧几里得差异原则被认为是“可靠的”。具体标准是相对偏差最多为 5%：\n$$ \\frac{\\left|\\|A \\theta_{\\lambda_E} - y\\|_{\\Sigma^{-1}} - \\delta_M\\right|}{\\delta_M} \\le 0.05 $$\n将此过程应用于三个具有不同噪声相关程度的测试用例，以展示欧几里得原则在何时是可信的，以及在何时会失效。\n对于不相关噪声的情况（$\\Sigma = \\sigma^2 I_m$），我们有 $\\delta_E = \\sigma\\sqrt{m}$ 和 $\\|r\\|_{\\Sigma^{-1}} = (1/\\sigma)\\|r\\|_2$。欧几里得条件 $\\|r\\|_2 = \\delta_E$ 变为 $\\|r\\|_2 = \\sigma\\sqrt{m}$，而马氏条件 $\\|r\\|_{\\Sigma^{-1}} = \\delta_M$ 变为 $(1/\\sigma)\\|r\\|_2 = \\sqrt{m}$，两者是相同的。因此，对于不相关噪声，这两个原则是一致的，可靠性标准将得到满足。对于相关噪声，这种等价性被打破，预计会出现偏差。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import toeplitz, cholesky, solve_triangular\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the inverse problem for three noise correlation cases and classifies\n    the reliability of the Euclidean discrepancy principle.\n    \"\"\"\n    # Problem constants\n    m = 50\n    n = 50\n    c = 0.08\n    # Use modern random number generation for reproducibility\n    rng = np.random.default_rng(0) \n\n    # 1. Construct the forward operator A and ground truth theta_star\n    s = np.linspace(0, 1, m)\n    t = np.linspace(0, 1, n)\n    t_grid, s_grid = np.meshgrid(t, s)\n    \n    A = np.exp(-((s_grid - t_grid)**2) / (2 * c**2))\n    # Add a small stabilization term as specified\n    A += 1e-12 * np.identity(m)\n    \n    theta_star = np.sin(2 * np.pi * t) + 0.5 * np.sin(6 * np.pi * t)\n\n    # Pre-compute SVD of A for efficient calculations\n    U, s_vals, Vt = np.linalg.svd(A, full_matrices=False)\n\n    # 2. Define the test cases\n    test_cases = [\n        {'sigma': 1e-2, 'rho': 0.0},  # Case 1: Uncorrelated\n        {'sigma': 1e-2, 'rho': 0.9},  # Case 2: Moderately correlated\n        {'sigma': 3e-3, 'rho': 0.99} # Case 3: Strongly correlated\n    ]\n\n    results = []\n\n    for case in test_cases:\n        sigma = case['sigma']\n        rho = case['rho']\n\n        # 3. Construct covariance matrix Sigma and generate data y\n        if rho == 0.0:\n            Sigma = (sigma**2) * np.identity(m)\n        else:\n            autocorr_row = sigma**2 * (rho ** np.arange(m))\n            Sigma = toeplitz(autocorr_row)\n        \n        noise = rng.multivariate_normal(np.zeros(m), Sigma)\n        y = A @ theta_star + noise\n\n        # 4. Use Euclidean Discrepancy Principle to find lambda_E\n        \n        # This function computes the L2 norm of the residual r_lambda\n        # efficiently using the pre-computed SVD of A.\n        y_proj = U.T @ y\n        def get_residual_norm_L2(lam):\n            filter_coeffs = lam / (s_vals**2 + lam)\n            return np.linalg.norm(filter_coeffs * y_proj)\n            \n        # Target for Euclidean discrepancy\n        delta_E = np.sqrt(np.trace(Sigma))\n        \n        # Define the function whose root we want to find\n        func_to_solve = lambda lam: get_residual_norm_L2(lam) - delta_E\n\n        # Solve for lambda_E using Brent's method. A wide bracket is used.\n        # Check if delta_E is in the range of possible residual norms.\n        # As lam -> 0, norm -> ||A*theta_LS-y|| ~ 0. As lam -> inf, norm -> ||y||.\n        norm_y = np.linalg.norm(y)\n        if delta_E >= norm_y:\n            # This unlikely case occurs if the noise realization is much smaller\n            # than its expectation. The best choice is the largest possible lambda.\n            lambda_E = 1e12 \n        else:\n            # Tolerances are set to be tight for high precision.\n            lambda_E = brentq(func_to_solve, 1e-16, 1e12, xtol=1e-16, rtol=1e-15)\n\n        # 5. Evaluate the reliability criterion\n        \n        # Compute the residual vector r_E for the found lambda_E\n        residual_coeffs = -lambda_E / (s_vals**2 + lambda_E)\n        residual_E = U @ (residual_coeffs * y_proj)\n        \n        # Compute the whitened residual norm: ||r_E||_{Sigma^-1}\n        try:\n            # Use Cholesky decomposition for numerical stability:\n            # ||r||_{Sigma^-1} = ||L^-1 * r||_2 where Sigma = L*L^T\n            L = cholesky(Sigma, lower=True)\n            # Solve L*z = residual_E for z=L^-1*residual_E\n            z = solve_triangular(L, residual_E, lower=True)\n            whitened_norm = np.linalg.norm(z)\n        except np.linalg.LinAlgError:\n            # Fallback for matrices where Cholesky might fail.\n            Sigma_inv = np.linalg.inv(Sigma)\n            whitened_norm = np.sqrt(residual_E.T @ Sigma_inv @ residual_E)\n\n        # Theoretical target for the whitened norm\n        delta_M = np.sqrt(m)\n        \n        # Check if the relative deviation is within the 5% tolerance\n        relative_deviation = np.abs(whitened_norm - delta_M) / delta_M\n        is_reliable = relative_deviation = 0.05\n        \n        results.append(is_reliable)\n\n    # Final output formatting\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```", "id": "3382223"}]}