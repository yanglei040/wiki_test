{"hands_on_practices": [{"introduction": "最小二乘问题不仅限于处理超定系统。在数据同化等领域，我们经常遇到欠定系统，即未知数多于观测方程。这个练习将引导你探索如何为这类问题找到唯一的最小范数解。你将学习到，解决这个问题的关键在于对系统矩阵的*转置*进行QR分解，这是一个强大而数值稳定的方法。[@problem_id:3408919]", "problem": "在一个由数据同化引发的线性反演问题中，考虑一个线性观测算子 $H \\in \\mathbb{R}^{m \\times n}$，其中 $m  n$ 且 $H$ 为行满秩，它通过 $Hx = y$ 将状态增量 $x \\in \\mathbb{R}^{n}$ 映射到观测值 $y \\in \\mathbb{R}^{m}$。最小欧几里得范数分析增量定义为在约束条件 $Hx = y$ 下最小化 $\\|x\\|_{2}$ 的唯一向量 $x^{\\star}$。针对此类欠定系统的一类计算策略使用为 $m  n$ 定制的正交-三角分解，例如 $RQ$ 分解（上三角矩阵乘以正交矩阵）或 $LQ$ 分解（下三角矩阵乘以正交矩阵），或者等价地，对 $H^{\\top}$ 进行 $QR$ 分解（正交矩阵乘以上三角矩阵）。\n\n仅从最优性定义“在约束条件 $Hx = y$ 下最小化 $\\|x\\|_{2}$”、欧几里得范数在正交变换下的不变性，以及三角系统可通过回代/前向替换求解的结构特性出发，推导出一个使用适合 $m  n$ 的正交-三角方法的计算过程来求解 $x^{\\star}$。然后，将您的推导应用于 $m=2, n=3$ 的具体实例：\n$$\nH \\;=\\; \\begin{pmatrix}\n1  1  0 \\\\\n0  1  1\n\\end{pmatrix}, \n\\qquad\ny \\;=\\; \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}.\n$$\n计算最小欧几里得范数解 $x^{\\star}$ 的第三个分量，记为 $x^{\\star}_{3}$，并报告其精确值。不要对答案进行四舍五入。", "solution": "问题是求解欠定线性方程组的最小欧几里得范数解 $x^{\\star}$。这是一个约束优化问题，表述为：\n$$\n\\text{最小化 } \\|x\\|_{2} \\quad \\text{约束条件} \\quad Hx = y\n$$\n其中 $x \\in \\mathbb{R}^{n}$，$y \\in \\mathbb{R}^{m}$，且 $H \\in \\mathbb{R}^{m \\times n}$ 满足 $m  n$ 且为行满秩（秩为 $m$）。\n\n我们将首先按照要求，使用正交-三角分解推导一个通用的计算过程，然后将其应用于具体的数值实例。\n\n**通用推导**\n\n推导将基于问题中给出的三个原则：最优性陈述、欧几里得范数在正交变换下的不变性，以及三角系统的可解性。\n\n矩阵 $H$ 是一个 $m \\times n$ 矩阵，满足 $m  n$ 且行满秩。其转置 $H^{\\top}$ 是一个 $n \\times m$ 矩阵，列满秩。列满秩矩阵具有唯一的（瘦）QR 分解。我们来计算 $H^{\\top}$ 的这个分解：\n$$\nH^{\\top} = QR\n$$\n其中 $Q \\in \\mathbb{R}^{n \\times m}$ 是一个具有标准正交列的矩阵（即 $Q^{\\top}Q = I_m$，其中 $I_m$ 是 $m \\times m$ 单位矩阵），$R \\in \\mathbb{R}^{m \\times m}$ 是一个上三角矩阵。由于 $H^{\\top}$ 列满秩，所以 $R$ 是可逆的。\n\n根据这个分解，我们可以将 $H$ 表示为 $H = (QR)^{\\top} = R^{\\top}Q^{\\top}$。约束条件 $Hx=y$ 变为：\n$$\nR^{\\top}Q^{\\top}x = y\n$$\n为了利用范数不变性，我们进行变量替换。$Q$ 的列构成了 $H^{\\top}$ 列空间（也就是 $H$ 的行空间）的一组标准正交基。我们可以通过找到一个矩阵 $Q_{\\perp} \\in \\mathbb{R}^{n \\times (n-m)}$，使其列构成 $H$ 的零空间的一组标准正交基，从而将这组列扩展为 $\\mathbb{R}^n$ 的一个完整的标准正交基。令 $\\bar{Q} = \\begin{pmatrix} Q  Q_{\\perp} \\end{pmatrix} \\in \\mathbb{R}^{n \\times n}$。根据构造，$\\bar{Q}$ 是一个正交矩阵，因此 $\\bar{Q}^{\\top}\\bar{Q} = \\bar{Q}\\bar{Q}^{\\top} = I_n$。\n\n任何向量 $x \\in \\mathbb{R}^n$ 都可以在这个新基下表示为 $x = \\bar{Q}w$，其中 $w \\in \\mathbb{R}^n$ 是唯一的坐标向量。我们将 $w$ 分块为 $w = \\begin{pmatrix} w_{1} \\\\ w_{2} \\end{pmatrix}$，其中 $w_1 \\in \\mathbb{R}^m$ 且 $w_2 \\in \\mathbb{R}^{n-m}$。因此，$x = Qw_1 + Q_{\\perp}w_2$。\n\n目标函数 $\\|x\\|_2$ 可以利用正交变换保持欧几里得范数的性质进行变换：\n$$\n\\|x\\|_{2} = \\|\\bar{Q}w\\|_{2} = \\|w\\|_{2}\n$$\n优化问题现在被转换为关于 $w$ 的等价问题：\n$$\n\\text{最小化 } \\|w\\|_{2} \\quad \\text{约束条件} \\quad H\\bar{Q}w = y\n$$\n我们来分析新的约束矩阵 $H\\bar{Q}$：\n$$\nH\\bar{Q} = R^{\\top}Q^{\\top} \\begin{pmatrix} Q  Q_{\\perp} \\end{pmatrix} = \\begin{pmatrix} R^{\\top}Q^{\\top}Q  R^{\\top}Q^{\\top}Q_{\\perp} \\end{pmatrix}\n$$\n由于 $Q^{\\top}Q = I_m$ 且 $Q_{\\perp}$ 的列与 $Q$ 的列正交，我们有 $Q^{\\top}Q_{\\perp} = 0$。表达式简化为：\n$$\nH\\bar{Q} = \\begin{pmatrix} R^{\\top}I_m  0 \\end{pmatrix} = \\begin{pmatrix} R^{\\top}  0 \\end{pmatrix}\n$$\n那么对 $w$ 的约束是：\n$$\n\\begin{pmatrix} R^{\\top}  0 \\end{pmatrix} \\begin{pmatrix} w_1 \\\\ w_2 \\end{pmatrix} = y \\quad \\implies \\quad R^{\\top}w_1 = y\n$$\n目标是最小化 $\\|w\\|_{2}^{2} = \\|w_1\\|_{2}^{2} + \\|w_2\\|_{2}^{2}$。分量 $w_1$ 完全由约束方程 $R^{\\top}w_1 = y$ 决定。由于 $R$ 是可逆的，所以 $R^{\\top}$ 也是可逆的。因此，$w_1 = (R^{\\top})^{-1}y$ 是唯一确定的。为了最小化总范数，我们必须最小化来自 $w_2$ 的贡献，即 $\\|w_2\\|_2^2$。当 $w_2=0$ 时达到最小值。\n\n最优坐标向量是 $w^{\\star} = \\begin{pmatrix} (R^{\\top})^{-1}y \\\\ 0 \\end{pmatrix}$。\n最后，我们变换回来求最优解 $x^{\\star}$：\n$$\nx^{\\star} = \\bar{Q}w^{\\star} = \\begin{pmatrix} Q  Q_{\\perp} \\end{pmatrix} \\begin{pmatrix} w_1 \\\\ 0 \\end{pmatrix} = Qw_1 = Q(R^{\\top})^{-1}y\n$$\n这引出以下计算步骤：\n1.  构造转置矩阵 $H^{\\top}$。\n2.  计算瘦 QR 分解 $H^{\\top} = QR$。\n3.  通过前向替换求解下三角系统 $R^{\\top}z = y$ 得到向量 $z \\in \\mathbb{R}^m$。这里，为记法清晰，我们使用 $z$ 代替 $w_1$。\n4.  计算最小范数解 $x^{\\star} = Qz$。\n\n**应用于具体实例**\n\n给定：\n$$\nH = \\begin{pmatrix} 1  1  0 \\\\ 0  1  1 \\end{pmatrix}, \\qquad y = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}\n$$\n\n1.  **构造 $H^{\\top}$**：\n    $$\n    H^{\\top} = \\begin{pmatrix} 1  0 \\\\ 1  1 \\\\ 0  1 \\end{pmatrix}\n    $$\n\n2.  **计算 $H^{\\top}$ 的 QR 分解**：我们对 $H^\\top$ 的列（记为 $a_1 = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}$ 和 $a_2 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}$）应用 Gram-Schmidt 过程。\n    $R$ 的第一列是 $R_{11} = \\|a_1\\|_2 = \\sqrt{1^2+1^2+0^2} = \\sqrt{2}$。\n    $Q$ 的第一列是 $q_1 = \\frac{a_1}{R_{11}} = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}$。\n    接下来，$R_{12} = q_1^{\\top}a_2 = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1  1  0 \\end{pmatrix}\\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\frac{1}{\\sqrt{2}}$。\n    正交分量为 $u_2 = a_2 - R_{12}q_1 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix} - \\frac{1}{\\sqrt{2}} \\left( \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix} \\right) = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix} - \\begin{pmatrix} 1/2 \\\\ 1/2 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -1/2 \\\\ 1/2 \\\\ 1 \\end{pmatrix}$。\n    然后，$R_{22} = \\|u_2\\|_2 = \\sqrt{(-1/2)^2 + (1/2)^2 + 1^2} = \\sqrt{\\frac{1}{4} + \\frac{1}{4} + 1} = \\sqrt{\\frac{3}{2}}$。\n    $Q$ 的第二列是 $q_2 = \\frac{u_2}{R_{22}} = \\frac{1}{\\sqrt{3/2}} \\begin{pmatrix} -1/2 \\\\ 1/2 \\\\ 1 \\end{pmatrix} = \\sqrt{\\frac{2}{3}} \\begin{pmatrix} -1/2 \\\\ 1/2 \\\\ 1 \\end{pmatrix} = \\frac{1}{\\sqrt{6}}\\begin{pmatrix} -1 \\\\ 1 \\\\ 2 \\end{pmatrix}$。\n    因此，分解为：\n    $$\n    Q = \\begin{pmatrix} \\frac{1}{\\sqrt{2}}  \\frac{-1}{\\sqrt{6}} \\\\ \\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{6}} \\\\ 0  \\frac{2}{\\sqrt{6}} \\end{pmatrix}, \\qquad R = \\begin{pmatrix} \\sqrt{2}  \\frac{1}{\\sqrt{2}} \\\\ 0  \\sqrt{\\frac{3}{2}} \\end{pmatrix}\n    $$\n\n3.  **求解 $R^{\\top}z = y$**：\n    方程组为 $\\begin{pmatrix} \\sqrt{2}  0 \\\\ \\frac{1}{\\sqrt{2}}  \\sqrt{\\frac{3}{2}} \\end{pmatrix} \\begin{pmatrix} z_1 \\\\ z_2 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$。\n    使用前向替换：\n    从第一行：$\\sqrt{2} z_1 = 1 \\implies z_1 = \\frac{1}{\\sqrt{2}}$。\n    从第二行：$\\frac{1}{\\sqrt{2}} z_1 + \\sqrt{\\frac{3}{2}} z_2 = 2$。\n    代入 $z_1$：$\\frac{1}{\\sqrt{2}} \\left(\\frac{1}{\\sqrt{2}}\\right) + \\sqrt{\\frac{3}{2}} z_2 = 2 \\implies \\frac{1}{2} + \\sqrt{\\frac{3}{2}} z_2 = 2$。\n    $\\sqrt{\\frac{3}{2}} z_2 = \\frac{3}{2} \\implies z_2 = \\frac{3/2}{\\sqrt{3/2}} = \\sqrt{\\frac{3}{2}}$。\n    所以，$z = \\begin{pmatrix} \\frac{1}{\\sqrt{2}} \\\\ \\sqrt{\\frac{3}{2}} \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{\\sqrt{2}} \\\\ \\frac{\\sqrt{6}}{2} \\end{pmatrix}$。\n\n4.  **计算 $x^{\\star} = Qz$**：\n    我们只需要第三个分量 $x^{\\star}_{3}$。\n    $$\n    x^{\\star}_{3} = (Q \\text{ 的第三行}) \\cdot z = \\begin{pmatrix} 0  \\frac{2}{\\sqrt{6}} \\end{pmatrix} \\begin{pmatrix} \\frac{1}{\\sqrt{2}} \\\\ \\frac{\\sqrt{6}}{2} \\end{pmatrix}\n    $$\n    $$\n    x^{\\star}_{3} = 0 \\cdot \\frac{1}{\\sqrt{2}} + \\frac{2}{\\sqrt{6}} \\cdot \\frac{\\sqrt{6}}{2} = 1\n    $$\n最小欧几里得范数解的第三个分量是 $1$。为完整起见，完整的解是 $x^{\\star} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}$。", "answer": "$$\\boxed{1}$$", "id": "3408919"}, {"introduction": "在许多实际应用中，解不仅需要最小化数据失配，还必须精确满足一组线性等式约束。这个练习将带你进入等式约束最小二乘问题的世界。我们将学习一种强大的方法——零空间法，它能将一个复杂的约束优化问题转化为一个更简单的无约束问题。通过这个练习，你将掌握如何利用QR分解系统地构造约束矩阵的零空间基，并最终求解约束最小二乘问题。[@problem_id:3408887]", "problem": "考虑在反问题和数据同化的背景下的等式约束线性最小二乘问题：在线性等式约束下，最小化残差的欧几里得范数。具体地，设 $A \\in \\mathbb{R}^{5 \\times 4}$、$b \\in \\mathbb{R}^{5}$ 以及 $C \\in \\mathbb{R}^{2 \\times 4}$ 由下式给出：\n$$\nA \\;=\\;\n\\begin{pmatrix}\n1  0  1  0 \\\\\n1  1  0  2 \\\\\n0  1  1  2 \\\\\n0  0  0  1 \\\\\n0  0  2  1\n\\end{pmatrix},\\quad\nb \\;=\\;\n\\begin{pmatrix}\n2 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 2\n\\end{pmatrix},\\quad\nC \\;=\\;\n\\begin{pmatrix}\n1  0  0  0 \\\\\n0  1  0  0\n\\end{pmatrix},\\quad\nd \\;=\\;\n\\begin{pmatrix}\n1 \\\\ -1\n\\end{pmatrix}.\n$$\n目标是找到 $x \\in \\mathbb{R}^{4}$，使其在满足 $Cx = d$ 的条件下最小化 $\\|A x - b\\|_{2}$。从欧几里得范数、正交性和正交三角 (QR) 分解的基本定义出发，按以下步骤进行。\n\n1. 使用零空间方法，通过引入一个满足 $Cx_{p} = d$ 的特解 $x_{p}$ 和零空间 $\\ker(C)$ 的一组基 $N$，将约束 $Cx = d$ 重写为 $x = x_{p} + N y$，其中 $y \\in \\mathbb{R}^{k}$ 且 $k$ 为适当的维度。通过计算 $C^{\\top}$ 的正交三角分解，即 $C^{\\top} = Q_{c} R_{c}$（其中 $Q_{c}$ 是正交矩阵，$R_{c}$ 是上三角矩阵），来构造 $N$，然后从 $Q_{c}$ 中提取 $\\ker(C)$ 的一组标准正交基。\n\n2. 对于给定的 $C$，显式计算 $C^{\\top} = Q_{c} R_{c}$，确定 $N$，并选择满足 $Cx_{p} = d$ 的最小欧几里得范数特解 $x_{p}$。\n\n3. 构造简化的无约束问题 $\\min_{y} \\|A N y - (b - A x_{p})\\|_{2}$，并利用 $A N$ 的正交三角分解求解，即计算 $A N = Q R$（其中 $Q$ 具有标准正交列，$R$ 是上三角矩阵），并利用此分解得到最小化子 $y^{\\star}$，进而得到约束最小化子 $x^{\\star} = x_{p} + N y^{\\star}$。\n\n4. 设 $\\kappa_{2}(\\cdot)$ 表示欧几里得范数下的谱条件数，对于一个满列秩矩阵 $M$，其定义为其最大奇异值与最小奇异值之比。利用正交三角分解的性质，从第一性原理出发推导并计算 $\\kappa_{2}(R)$ 和 $\\kappa_{2}(R_{c})$，并给出比值 $\\kappa_{2}(R) / \\kappa_{2}(R_{c})$ 的精确闭式表达式。\n\n将此精确比值作为最终答案报告。无需四舍五入，也不涉及任何单位。最终答案必须是单一的实值闭式表达式。", "solution": "所述问题具有科学依据、内容自洽且提法适定。所有数据和条件均已提供，且该问题遵循线性代数和数值优化的既定原则。我将按照规定的步骤进行求解。\n\n该问题是求解等式约束最小二乘问题，即找到 $x \\in \\mathbb{R}^{4}$：\n$$\n\\min_{x \\in \\mathbb{R}^{4}} \\|A x - b\\|_{2} \\quad \\text{subject to} \\quad C x = d\n$$\n其中矩阵和向量如下所示\n$$\nA \\;=\\;\n\\begin{pmatrix}\n1  0  1  0 \\\\\n1  1  0  2 \\\\\n0  1  1  2 \\\\\n0  0  0  1 \\\\\n0  0  2  1\n\\end{pmatrix},\\quad\nb \\;=\\;\n\\begin{pmatrix}\n2 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 2\n\\end{pmatrix},\\quad\nC \\;=\\;\n\\begin{pmatrix}\n1  0  0  0 \\\\\n0  1  0  0\n\\end{pmatrix},\\quad\nd \\;=\\;\n\\begin{pmatrix}\n1 \\\\ -1\n\\end{pmatrix}.\n$$\n\n步骤 1：解的零空间表示法。\n任何满足线性约束 $C x = d$ 的向量 $x$ 都可以写成一个特解 $x_{p}$（满足 $C x_p = d$）与一个来自 $C$ 的零空间 $\\ker(C)$ 的向量之和。设 $N$ 是一个矩阵，其列构成 $\\ker(C)$ 的一组标准正交基。那么 $\\ker(C)$ 中的任意向量都可以表示为 $Ny$，其中 $y \\in \\mathbb{R}^{k}$ 是某个向量，且 $k = \\dim(\\ker(C))$。因此，$C x = d$ 的通解为 $x = x_p + Ny$。\n\n问题指出，需要通过 $C^{\\top} \\in \\mathbb{R}^{4 \\times 2}$ 的完全正交三角 ($QR$) 分解来找到 $N$。该分解由 $C^{\\top} = Q_{c} R_{c}$ 给出，其中 $Q_{c} \\in \\mathbb{R}^{4 \\times 4}$ 是一个正交矩阵，$R_{c} \\in \\mathbb{R}^{4 \\times 2}$ 是一个上三角矩阵。$Q_{c}$ 的列构成了 $\\mathbb{R}^{4}$ 的一组标准正交基。我们可以将 $Q_{c}$ 分块为 $Q_{c} = [Q_{c1} \\ Q_{c2}]$，其中 $Q_{c1} \\in \\mathbb{R}^{4 \\times 2}$ 的列构成 $C^{\\top}$ 的值域 $\\text{range}(C^{\\top})$ 的一组标准正交基，而 $Q_{c2} \\in \\mathbb{R}^{4 \\times 2}$ 的列构成该值域的正交补 $(\\text{range}(C^{\\top}))^{\\perp}$ 的一组标准正交基。根据线性代数基本定理，$(\\text{range}(C^{\\top}))^{\\perp} = \\ker(C)$。因此，所求的矩阵 $N$ 就是 $Q_{c2}$。\n\n步骤 2：$N$ 和 $x_p$ 的显式计算。\n首先，我们计算 $C^{\\top}$ 的 $QR$ 分解。\n$$\nC^{\\top} \\;=\\;\n\\begin{pmatrix}\n1  0 \\\\\n0  1 \\\\\n0  0 \\\\\n0  0\n\\end{pmatrix}\n$$\n$C^{\\top}$ 的列是 $\\mathbb{R}^{4}$ 的标准基向量 $e_1$ 和 $e_2$。它们已经是标准正交的。为了构成一个完全 $QR$ 分解，我们可以通过追加 $e_3$ 和 $e_4$ 将这个集合扩展为 $\\mathbb{R}^{4}$ 的一组标准正交基。这一选择使得 $Q_{c}$ 为单位矩阵 $I_4$。\n$$\nQ_{c} \\;=\\; I_{4} \\;=\\;\n\\begin{pmatrix}\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  1  0 \\\\\n0  0  0  1\n\\end{pmatrix}\n$$\n于是，从 $R_c = Q_{c}^{\\top} C^{\\top} = I_4 C^{\\top} = C^{\\top}$ 可求得 $R_c$。\n$$\nR_{c} \\;=\\;\n\\begin{pmatrix}\n1  0 \\\\\n0  1 \\\\\n0  0 \\\\\n0  0\n\\end{pmatrix}\n$$\n这个 $R_c$ 是一个大小为 $4 \\times 2$ 的上三角矩阵。\n我们将 $Q_{c}$ 分块为 $Q_{c} = [Q_{c1} \\ Q_{c2}]$，其中 $Q_{c1}$ 由前两列组成，$Q_{c2}$ 由后两列组成。\n$$\nQ_{c1} \\;=\\; \\begin{pmatrix} 1  0 \\\\ 0  1 \\\\ 0  0 \\\\ 0  0 \\end{pmatrix}, \\quad Q_{c2} \\;=\\; N \\;=\\; \\begin{pmatrix} 0  0 \\\\ 0  0 \\\\ 1  0 \\\\ 0  1 \\end{pmatrix}\n$$\n$N$ 的列确实是 $e_3$ 和 $e_4$，它们张成了 $\\ker(C)$。\n接下来，我们求最小欧几里得范数特解 $x_p$。该解是唯一的，且位于 $\\text{range}(C^{\\top})$ 中。因此，对于某个 $\\lambda \\in \\mathbb{R}^{2}$，有 $x_p = C^{\\top} \\lambda$。将其代入约束条件，得到 $C(C^{\\top} \\lambda) = d$。\n$$\nCC^{\\top} \\;=\\; \\begin{pmatrix} 1  0  0  0 \\\\ 0  1  0  0 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 0  1 \\\\ 0  0 \\\\ 0  0 \\end{pmatrix} \\;=\\; \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} \\;=\\; I_2\n$$\n所以，$I_2 \\lambda = d$，这意味着 $\\lambda = d = \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}$。\n特解为 $x_p = C^{\\top} d = \\begin{pmatrix} 1  0 \\\\ 0  1 \\\\ 0  0 \\\\ 0  0 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n\n步骤 3：求解简化的无约束问题。\n将 $x = x_p + Ny$ 代入目标函数，得到在 $y \\in \\mathbb{R}^{2}$ 上最小化 $\\|A(x_p + Ny) - b\\|_{2} = \\|ANy - (b - Ax_p)\\|_{2}$。\n设 $M = AN$ 且 $z = b - Ax_p$。\n$$\nM = AN = \\begin{pmatrix} 1  0  1  0 \\\\ 1  1  0  2 \\\\ 0  1  1  2 \\\\ 0  0  0  1 \\\\ 0  0  2  1 \\end{pmatrix} \\begin{pmatrix} 0  0 \\\\ 0  0 \\\\ 1  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ 0  2 \\\\ 1  2 \\\\ 0  1 \\\\ 2  1 \\end{pmatrix}\n$$\n$$\nAx_p = \\begin{pmatrix} 1  0  1  0 \\\\ 1  1  0  2 \\\\ 0  1  1  2 \\\\ 0  0  0  1 \\\\ 0  0  2  1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n$$\nz = b - Ax_p = \\begin{pmatrix} 2 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 2 \\end{pmatrix} - \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 2 \\end{pmatrix}\n$$\n简化后的问题是 $\\min_{y} \\|My-z\\|_{2}$。我们观察到 $z$ 与 $M$ 的第一列完全相同。设 $m_1, m_2$ 为 $M$ 的列，则 $M=[m_1 \\ m_2]$。问题变为 $\\min_{y_1, y_2} \\|y_1 m_1 + y_2 m_2 - m_1\\|_{2} = \\min_{y_1, y_2} \\|(y_1-1)m_1 + y_2 m_2\\|_{2}$。由于列向量 $m_1$ 和 $m_2$ 线性无关，当系数为零时，范数达到最小值 (为 0)，即：$y_1-1=0 \\implies y_1=1$ 且 $y_2=0$。\n所以最小化子为 $y^{\\star} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。\n约束最小化子为 $x^{\\star} = x_p + N y^{\\star} = \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\\\ 0 \\end{pmatrix} + \\begin{pmatrix} 0  0 \\\\ 0  0 \\\\ 1  0 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -1 \\\\ 1 \\\\ 0 \\end{pmatrix}$。\n为了找到下一步所需的矩阵 $R$，我们计算 $M = AN$ 的瘦 $QR$ 分解。设 $M=QR$，其中 $Q \\in \\mathbb{R}^{5 \\times 2}$ 的列标准正交，$R \\in \\mathbb{R}^{2 \\times 2}$ 是上三角矩阵。对 $M$ 的列使用 Gram-Schmidt 过程：\n$m_1 = (1, 0, 1, 0, 2)^{\\top}$。$\\|m_1\\|_{2} = \\sqrt{1^2+0^2+1^2+0^2+2^2} = \\sqrt{6}$。\n$R_{11} = \\sqrt{6}$。$q_1 = \\frac{1}{\\sqrt{6}} m_1$。\n$m_2 = (0, 2, 2, 1, 1)^{\\top}$。\n$R_{12} = q_1^{\\top} m_2 = \\frac{1}{\\sqrt{6}}(1 \\cdot 0 + 0 \\cdot 2 + 1 \\cdot 2 + 0 \\cdot 1 + 2 \\cdot 1) = \\frac{4}{\\sqrt{6}}$。\n$m_2$ 正交于 $q_1$ 的分量是 $m_2' = m_2 - R_{12} q_1 = m_2 - (q_1^{\\top} m_2) q_1 = m_2 - \\frac{4}{6}m_1 = \\begin{pmatrix} 0 \\\\ 2 \\\\ 2 \\\\ 1 \\\\ 1 \\end{pmatrix} - \\frac{2}{3}\\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 2 \\end{pmatrix} = \\frac{1}{3}\\begin{pmatrix} -2 \\\\ 6 \\\\ 4 \\\\ 3 \\\\ -1 \\end{pmatrix}$。\n$R_{22} = \\|m_2'\\|_{2} = \\frac{1}{3}\\sqrt{(-2)^2+6^2+4^2+3^2+(-1)^2} = \\frac{1}{3}\\sqrt{4+36+16+9+1} = \\frac{\\sqrt{66}}{3}$。\n矩阵 $R$ 为：\n$$\nR \\;=\\; \\begin{pmatrix} R_{11}  R_{12} \\\\ 0  R_{22} \\end{pmatrix} \\;=\\; \\begin{pmatrix} \\sqrt{6}  \\frac{4}{\\sqrt{6}} \\\\ 0  \\frac{\\sqrt{66}}{3} \\end{pmatrix}\n$$\n\n步骤 4：计算条件数及其比值。\n对于一个满列秩矩阵 $M$，其谱条件数 $\\kappa_2(M)$ 是其最大奇异值与最小奇异值之比，即 $\\kappa_2(M) = \\sigma_{\\max}(M)/\\sigma_{\\min}(M)$。$M$ 的奇异值是 $M^{\\top}M$ 的特征值的平方根。对于分解 $M=QR$，有 $M^{\\top}M = (QR)^{\\top}(QR) = R^{\\top}Q^{\\top}QR = R^{\\top}R$。因此，$M$ 的奇异值与 $R$ 的奇异值相同，且 $\\kappa_2(M) = \\kappa_2(R)$。\n我们计算 $M^{\\top}M$：\n$$\nM^{\\top}M = \\begin{pmatrix} 1  0  1  0  2 \\\\ 0  2  2  1  1 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 0  2 \\\\ 1  2 \\\\ 0  1 \\\\ 2  1 \\end{pmatrix} = \\begin{pmatrix} 6  4 \\\\ 4  10 \\end{pmatrix}\n$$\n$M^{\\top}M$ 的特征值 $\\lambda$ 满足特征方程 $\\det(M^{\\top}M - \\lambda I)=0$：\n$$\n(6-\\lambda)(10-\\lambda) - 16 = 0 \\implies \\lambda^2 - 16\\lambda + 60 - 16 = 0 \\implies \\lambda^2 - 16\\lambda + 44 = 0\n$$\n特征值为 $\\lambda = \\frac{16 \\pm \\sqrt{16^2 - 4(44)}}{2} = \\frac{16 \\pm \\sqrt{256 - 176}}{2} = \\frac{16 \\pm \\sqrt{80}}{2} = 8 \\pm 2\\sqrt{5}$。\n$R$ 的奇异值为 $\\sigma_{\\max} = \\sqrt{8+2\\sqrt{5}}$ 和 $\\sigma_{\\min} = \\sqrt{8-2\\sqrt{5}}$。\n条件数 $\\kappa_2(R)$ 为：\n$$\n\\kappa_2(R) = \\frac{\\sigma_{\\max}}{\\sigma_{\\min}} = \\sqrt{\\frac{8+2\\sqrt{5}}{8-2\\sqrt{5}}} = \\sqrt{\\frac{4+\\sqrt{5}}{4-\\sqrt{5}}} = \\sqrt{\\frac{(4+\\sqrt{5})^2}{16-5}} = \\frac{4+\\sqrt{5}}{\\sqrt{11}}\n$$\n接下来，我们计算 $\\kappa_2(R_c)$。矩阵 $R_c \\in \\mathbb{R}^{4 \\times 2}$ 为 $R_c = \\begin{pmatrix} 1  0 \\\\ 0  1 \\\\ 0  0 \\\\ 0  0 \\end{pmatrix}$。它的列是线性无关的，因此它具有满列秩。它的奇异值是 $R_c^{\\top}R_c$ 的特征值的平方根。\n$$\nR_c^{\\top}R_c = \\begin{pmatrix} 1  0  0  0 \\\\ 0  1  0  0 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 0  1 \\\\ 0  0 \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} = I_2\n$$\n特征值为 $\\lambda_1 = 1$ 和 $\\lambda_2 = 1$。奇异值为 $\\sigma_{\\max}(R_c)=1$ 和 $\\sigma_{\\min}(R_c)=1$。\n因此，$\\kappa_2(R_c) = \\frac{1}{1}=1$。\n所求的比值为：\n$$\n\\frac{\\kappa_2(R)}{\\kappa_2(R_c)} = \\frac{(4+\\sqrt{5})/\\sqrt{11}}{1} = \\frac{4+\\sqrt{5}}{\\sqrt{11}}\n$$", "answer": "$$\n\\boxed{\\frac{4+\\sqrt{5}}{\\sqrt{11}}}\n$$", "id": "3408887"}, {"introduction": "从理论计算转向实际编程实现，算法的选择变得至关重要，尤其是在处理源自偏微分方程（PDE）的大型稀疏问题时。对于QR分解，Givens旋转和Householder反射是两种基本的正交变换工具，它们在计算成本和稀疏性保持方面各有优劣。这个练习要求你亲手实现这两种方法，并设计一个混合稀疏性感知的方案，通过一个明确的性能指标来比较它们的效率。[@problem_id:3408903]", "problem": "给定一系列线性最小二乘问题，形式为 $\\min_{x \\in \\mathbb{R}^n} \\lVert A x - b \\rVert_2$，这些问题源于数据同化中的离散偏微分方程（PDE）逆问题。其中，$A \\in \\mathbb{R}^{m \\times n}$ 是一个高且稀疏的矩阵，并且 $m \\ge n$。目标是设计并比较基于 Givens 旋转和 Householder 反射的用于求解最小二乘问题的正交三角分解方法，并构建一个稀疏性感知的混合方案。该方案在列级别上在这两种方法之间进行选择，其动机是保持稀疏性并最小化填充。您必须通过将矩阵 $A$ 的行划分为连续的块来模拟一个分布式同化场景，并在使用 Givens 旋转时，通过按顺序遍历这些分区来处理每一列。\n\n推导和设计所需的基本原理和定义：\n- 用于最小二乘问题的正交三角分解：如果 $A = Q R$，其中 $Q \\in \\mathbb{R}^{m \\times m}$ 是正交矩阵，$R \\in \\mathbb{R}^{m \\times n}$ 在其前导 $n \\times n$ 子块（记为 $R_{11}$）中是上三角矩阵，则 $\\lVert A x - b \\rVert_2$ 的最小化向量 $x^\\star$ 满足 $R_{11} x^\\star = (Q^\\top b)_{1:n}$，并且最小残差满足 $\\lVert A x^\\star - b \\rVert_2 = \\lVert (Q^\\top b)_{n+1:m} \\rVert_2$。\n- Givens 旋转：对于 $a, \\tilde{a} \\in \\mathbb{R}$，一个余弦为 $c$、正弦为 $s$ 的旋转满足 $\\begin{bmatrix} c  s \\\\ -s  c \\end{bmatrix} \\begin{bmatrix} a \\\\ \\tilde{a} \\end{bmatrix} = \\begin{bmatrix} r \\\\ 0 \\end{bmatrix}$，其中 $r = \\sqrt{a^2 + \\tilde{a}^2}$，如果 $r \\ne 0$，则 $(c,s) = (a/r, \\tilde{a}/r)$。对成对的行应用此类旋转可以消去次对角线元素，同时保持正交性。\n- Householder 反射：给定 $x \\in \\mathbb{R}^k$，反射矩阵 $H = I - 2 u u^\\top$（其中 $u = v / \\lVert v \\rVert_2$，$v = x + \\operatorname{sign}(x_1) \\lVert x \\rVert_2 e_1$）将 $x$ 映射到 $\\pm \\lVert x \\rVert_2 e_1$，并且该矩阵是正交且对称的。\n\n设计要求：\n- 实现三种方案，通过用一系列正交变换左乘 $A$ 和 $b$ 来隐式地构造 $Q$，处理过程严格地逐列进行（$k = 0, 1, \\dots, n-1$），不使用主元选择：\n  1. 纯 Givens 旋转方案：对于每一列 $k$，按顺序遍历分区，并在每个分区内，对每个满足 $i > k$ 且 $A_{i,k}$ 非零的行索引 $i$，对行 $(k,i)$ 应用一次 Givens 旋转以消去 $A_{i,k}$。每次消去计为一次正交操作。在每个步骤中仅更新列 $j \\ge k$，以保持三角结构并利用稀疏性。将相同的旋转应用于向量 $b$。\n  2. 纯 Householder 反射方案：对于每一列 $k$，计算一个作用于行 $k$ 到 $m-1$ 的 Householder 反射矩阵，以一次性消去列 $k$ 中所有的次对角线元素。每列计为一次正交操作。将相同的反射矩阵应用于 $b$。\n  3. 稀疏性感知的混合方案：对于每一列 $k$，根据以下规则在 Givens 和 Householder 之间做出选择：如果列 $k$ 中对角线下方的非零元素数量，即 $\\#\\{ i > k : A_{i,k} \\ne 0 \\}$，小于或等于一个阈值 $\\tau$，则对该列使用项目1中的 Givens 旋转方法；否则，对该列使用项目2中的一次 Householder 反射。\n\n- 每次正交操作的平均残差减小量：设 $r_0 = \\lVert b \\rVert_2$ 为对应于零向量 $x = 0$ 的初始残差范数。在每次完整分解结束时（即所有列都处理完毕后），通过求解 $R_{11} x^\\star = (Q^\\top b)_{1:n}$ 计算出 $x^\\star$，并设 $r_\\text{final} = \\lVert A x^\\star - b \\rVert_2$。定义每次正交操作的平均残差减小量为\n  $$ \\Delta_\\text{avg} \\;=\\; \\frac{r_0 - r_\\text{final}}{N_\\text{ops}}, $$\n  其中 $N_\\text{ops}$ 是该方案所使用的正交操作（Givens 旋转或 Householder 反射）的总次数。\n\n- 分布式同化模拟：给定一个分区数 $P$，将 $\\{0,1,\\dots,m-1\\}$ 划分为 $P$ 个大小相差至多为一的连续行块。对于 Givens 方案和混合方案中的 Givens 部分，每列的消去操作必须通过按块索引的递增顺序扫描分区来执行，且仅考虑当前块内的行，并一致地更新全局矩阵和向量。对于 Householder 方案，则全局应用单个列的反射矩阵。\n\n- 数值稳定性：使用上文所述的 Givens 和 Householder 的稳定公式。不要使用列主元选择。\n\n- 输出规格：对于每个测试用例，计算并报告三个浮点数：\n  - Givens 方案每次正交操作的平均残差减小量，记为 $\\Delta_\\text{avg}^\\text{G}$。\n  - Householder 方案每次正交操作的平均残差减小量，记为 $\\Delta_\\text{avg}^\\text{H}$。\n  - 混合方案每次正交操作的平均残差减小量，记为 $\\Delta_\\text{avg}^\\text{Hy}$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表的列表形式的结果，每个内层列表按顺序对应一个测试用例，并包含 `[Δ_avg^G, Δ_avg^H, Δ_avg^Hy]`。例如，一个有效的格式是 `[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]`。\n\n测试套件：\n- 案例 A（类 PDE 的稀疏带状矩阵，两个分区）：\n  - 维度：$m = 8$， $n = 4$，分区 $P = 2$，阈值 $\\tau = 2$。\n  - 矩阵构造：用零初始化 $A \\in \\mathbb{R}^{8 \\times 4}$。对于每列 $j \\in \\{0,1,2,3\\}$，令 $r = 2j$。若 $0 \\le r-1  m$，则设 $A_{r-1,j} += -1$。若 $0 \\le r  m$，则设 $A_{r,j} += 2$。若 $0 \\le r+1  m$，则设 $A_{r+1,j} += -1$。\n  - 右端项：$b \\in \\mathbb{R}^8$，其元素为 $b_i = \\sin(i+1)$，其中 $i \\in \\{0,\\dots,7\\}$，角度以弧度为单位。\n- 案例 B（中等密度矩阵，三个分区）：\n  - 维度：$m = 9$， $n = 4$，分区 $P = 3$，阈值 $\\tau = 2$。\n  - 矩阵构造：设 $A$ 的元素 $A_{i,j}$ 从固定种子 $\\sigma = 42$ 的标准正态分布中抽取以确保可复现性，然后将对角线元素 $A_{j,j}$（$j \\in \\{0,1,2,3\\}$）加上 $0.1$ 以促使其为列满秩。所有随机性必须在种子 $\\sigma$ 下是确定性和可复现的。\n  - 右端项：$b$ 的元素与 $A$ 来自同一个种子 $\\sigma$，为独立的标准正态分布。\n- 案例 C（非常稀疏，两个分区）：\n  - 维度：$m = 10$， $n = 4$，分区 $P = 2$，阈值 $\\tau = 1$。\n  - 矩阵构造：用零初始化 $A$。对于行 $i \\in \\{0,1,2,3\\}$，设 $A_{i,i} = 1$。对于行 $i \\in \\{4,5,6,7,8,9\\}$，设 $A_{i, (i \\bmod 4)} = 0.5 + 0.1 \\cdot (i - 4)$。\n  - 右端项：$b \\in \\mathbb{R}^{10}$，其所有元素 $b_i = 1$。\n\n角度单位：所有三角函数（如有）必须使用弧度。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个 Python 风格的列表的列表的字符串表示形式 `[[\\Delta_\\text{avg}^\\text{G}, \\Delta_\\text{avg}^\\text{H}, \\Delta_\\text{avg}^\\text{Hy}], \\dots]`，用于表示按顺序（案例 A、案例 B、案例 C）排列的三个测试用例的结果，使用默认的浮点数格式，不含任何附加文本。", "solution": "该问题要求设计、实现并比较三种不同的方案，以使用正交三角（$QR$）分解来求解形式为 $\\min_{x} \\lVert A x - b \\rVert_2$ 的线性最小二乘问题。矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 是高矩阵（$m \\ge n$）并且可能是稀疏的。比较的依据是一个自定义度量标准：每次正交操作的平均残差减小量。\n\n通过 $QR$ 分解求解最小二乘问题的基本原理是将原始问题转换为一个等价但更简单的问题。如果 $A = QR$，其中 $Q \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵，$R \\in \\mathbb{R}^{m \\times n}$ 是一个上三角矩阵，则残差的范数在左乘 $Q^\\top$ 后保持不变：\n$$ \\lVert A x - b \\rVert_2^2 = \\lVert Q^\\top (A x - b) \\rVert_2^2 = \\lVert Q^\\top A x - Q^\\top b \\rVert_2^2 = \\lVert R x - Q^\\top b \\rVert_2^2 $$\n我们根据 $A$ 的维度对 $R$ 和 $Q^\\top b$ 进行划分：\n$$ R = \\begin{bmatrix} R_{11} \\\\ 0 \\end{bmatrix}, \\quad Q^\\top b = \\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix} $$\n其中 $R_{11} \\in \\mathbb{R}^{n \\times n}$ 是上三角矩阵，$c_1 \\in \\mathbb{R}^n$，$c_2 \\in \\mathbb{R}^{m-n}$。最小化问题随之变为：\n$$ \\min_{x} \\left\\lVert \\begin{bmatrix} R_{11} \\\\ 0 \\end{bmatrix} x - \\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix} \\right\\rVert_2^2 = \\min_{x} \\left( \\lVert R_{11} x - c_1 \\rVert_2^2 + \\lVert -c_2 \\rVert_2^2 \\right) $$\n最小化向量 $x^\\star$ 可通过求解上三角方程组 $R_{11} x^\\star = c_1$ 得到，这使得第一项为零。最小残差范数则简化为 $\\lVert c_2 \\rVert_2 = \\lVert (Q^\\top b)_{n+1:m} \\rVert_2$。\n\n这三种方案通过对 $A$ 和 $b$ 应用一系列基本正交变换来隐式地构造正交矩阵 $Q$。更新后的 $A$ 变为 $R$，更新后的 $b$ 变为 $Q^\\top b$。\n\n**1. 纯 Givens 旋转方案**\n\nGivens 旋转是一种在二维子空间（一个平面）中操作的正交变换，其设计目的是在向量或矩阵中引入一个零元素。为了使用对角元素 $A_{k,k}$ 将元素 $A_{i,k}$（其中 $i > k$）置零，需要对行 $k$ 和行 $i$ 应用一次旋转。该算法逐列进行（$k=0, 1, \\dots, n-1$）。对于每一列 $k$，它通过应用一系列 Givens 旋转，系统地消去所有次对角线上的非零元 $A_{i,k}$（对于 $i > k$）。每次旋转计为一次正交操作（$N_\\text{ops}$）。这种方法目标性很强，对于对角线下方非零元素较少的列所在的矩阵而言是高效的，因为它一次只修改两行，并且可以保持现有的稀疏性。问题中指定了一个“分布式”模拟，其中对每一列的消去操作都是通过扫描预定义的行分区来执行的，这决定了操作的顺序。\n\n**2. 纯 Householder 反射方案**\n\nHouseholder 反射是一种将向量关于一个超平面进行反射的正交变换。它比 Givens 旋转功能更强大，因为单次反射可以同时将一个向量的多个元素置零。对于每一列 $k$，都基于向量 $A_{k:m,k}$ 构建一次 Householder 反射，以消去其第一个元素之后的所有元素。这个单一的变换被应用于子矩阵 $A_{k:m, k:n}$ 和 $b$ 的相应子向量。虽然功能强大，但 Householder 反射是一种密集操作，通常会影响活动子矩阵的所有行和列，这可能通过引入许多新的非零元素（填充）来破坏稀疏性。对于此方案，每列的变换计为一次正交操作，因此 $N_\\text{ops} = n$（假设没有列被跳过）。\n\n**3. 稀疏性感知的混合方案**\n\n该方案旨在集二者之长。它根据每列的局部稀疏模式进行策略性选择。在处理列 $k$ 之前，它会计算对角线下方的非零元素数量，记为 $\\#\\{ i > k : A_{i,k} \\ne 0 \\}$。\n- 如果此计数小于或等于给定的阈值 $\\tau$，则该列被认为是“足够稀疏”。算法对该列采用更精细的 Givens 旋转方法，因为多次目标明确的旋转所带来的成本被认为更低，且更有利于保持稀疏性。该列的操作计数是执行的旋转次数。\n- 如果计数超过 $\\tau$，则该列被认为是“足够密集”，以至于使用单次、功能强大的 Householder 反射在计算上更有效率，尽管存在填充的风险。该列的操作计数为 $1$。\n这种混合方法使用阈值 $\\tau$ 来平衡 Givens 旋转的细粒度特性与 Householder 反射的粗粒度效率之间的权衡。\n\n**度量标准计算**\n\n对于每种方案，其性能通过 $\\Delta_\\text{avg} = (r_0 - r_\\text{final}) / N_\\text{ops}$ 来量化。这里，$r_0 = \\lVert b \\rVert_2$ 是初始残差范数（对于试探解 $x=0$），$r_\\text{final}$ 是最终的最小残差范数 $\\lVert (Q^\\top b)_{n+1:m} \\rVert_2$，$N_\\text{ops}$ 是正交操作（Givens 旋转或 Householder 反射）的总次数。该度量标准评估了每种方案在每个基本计算单元上减小残差范数的效率，从而为比较提供了基础。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A small tolerance for floating-point comparisons.\nTOL = 1e-15\n\ndef get_partitions(m, P):\n    \"\"\"Computes P contiguous row partitions for m rows.\"\"\"\n    if P == 0:\n        return []\n    q = m // P\n    r = m % P\n    partitions = []\n    current_row = 0\n    for i in range(P):\n        size = q + 1 if i  r else q\n        partitions.append(range(current_row, current_row + size))\n        current_row += size\n    return partitions\n\ndef solve_givens(A_orig, b_orig, P):\n    \"\"\"\n    Solves the least-squares problem using Givens rotations, respecting partitions.\n    \"\"\"\n    A = A_orig.copy().astype(float)\n    b = b_orig.copy().astype(float)\n    m, n = A.shape\n    \n    n_ops = 0\n    r0_norm = np.linalg.norm(b)\n    partitions = get_partitions(m, P)\n\n    for k in range(n):\n        for p_range in partitions:\n            for i in p_range:\n                if i > k:\n                    if not np.isclose(A[i, k], 0, atol=TOL):\n                        n_ops += 1\n                        a = A[k, k]\n                        atilde = A[i, k]\n                        \n                        r = np.hypot(a, atilde)\n                        c = a / r\n                        s = atilde / r\n                        \n                        R_k = A[k, k:].copy()\n                        R_i = A[i, k:].copy()\n                        A[k, k:] = c * R_k + s * R_i\n                        A[i, k:] = -s * R_k + c * R_i\n                        \n                        b_k = b[k]\n                        b_i = b[i]\n                        b[k] = c * b_k + s * b_i\n                        b[i] = -s * b_k + c * b_i\n\n    r_final_norm = np.linalg.norm(b[n:])\n    \n    if n_ops == 0:\n        return 0.0\n    return (r0_norm - r_final_norm) / n_ops\n\ndef solve_householder(A_orig, b_orig):\n    \"\"\"\n    Solves the least-squares problem using Householder reflections.\n    \"\"\"\n    A = A_orig.copy().astype(float)\n    b = b_orig.copy().astype(float)\n    m, n = A.shape\n    \n    n_ops = 0\n    r0_norm = np.linalg.norm(b)\n\n    for k in range(n):\n        # The vector to be transformed\n        x = A[k:m, k]\n        \n        # Only apply reflection if there are subdiagonal elements to annihilate\n        if x.size > 1 and not np.isclose(np.linalg.norm(x[1:]), 0, atol=TOL):\n            n_ops += 1\n            \n            # Stable Householder vector calculation\n            sigma = np.copysign(np.linalg.norm(x), x[0])\n            v = x.copy()\n            v[0] += sigma\n            \n            beta = 2.0 / (v.T @ v)\n            \n            # Apply reflection to submatrix of A and subvector of b\n            w_A = beta * (A[k:m, k:n].T @ v)\n            A[k:m, k:n] -= np.outer(v, w_A)\n            \n            w_b = beta * (b[k:m].T @ v)\n            b[k:m] -= v * w_b\n\n    r_final_norm = np.linalg.norm(b[n:])\n    \n    if n_ops == 0:\n        return 0.0\n    return (r0_norm - r_final_norm) / n_ops\n\ndef solve_hybrid(A_orig, b_orig, P, tau):\n    \"\"\"\n    Solves the least-squares problem using the hybrid Givens-Householder scheme.\n    \"\"\"\n    A = A_orig.copy().astype(float)\n    b = b_orig.copy().astype(float)\n    m, n = A.shape\n\n    n_ops = 0\n    r0_norm = np.linalg.norm(b)\n    partitions = get_partitions(m, P)\n    \n    for k in range(n):\n        sub_col = A[k+1:m, k]\n        nnz = np.count_nonzero(np.abs(sub_col) > TOL)\n\n        if 0  nnz = tau:\n            # Use Givens rotations\n            n_ops += nnz\n            for p_range in partitions:\n                for i in p_range:\n                    if i > k:\n                        if not np.isclose(A[i, k], 0, atol=TOL):\n                            a = A[k, k]\n                            atilde = A[i, k]\n                            r = np.hypot(a, atilde)\n                            c = a / r\n                            s = atilde / r\n                            \n                            R_k = A[k, k:].copy()\n                            R_i = A[i, k:].copy()\n                            A[k, k:] = c * R_k + s * R_i\n                            A[i, k:] = -s * R_k + c * R_i\n                            \n                            b_k = b[k]\n                            b_i = b[i]\n                            b[k] = c * b_k + s * b_i\n                            b[i] = -s * b_k + c * b_i\n        elif nnz > tau:\n            # Use Householder reflection\n            n_ops += 1\n            x = A[k:m, k]\n            \n            sigma = np.copysign(np.linalg.norm(x), x[0])\n            v = x.copy()\n            v[0] += sigma\n            \n            beta = 2.0 / (v.T @ v)\n\n            w_A = beta * (A[k:m, k:n].T @ v)\n            A[k:m, k:n] -= np.outer(v, w_A)\n\n            w_b = beta * (b[k:m].T @ v)\n            b[k:m] -= v * w_b\n\n    r_final_norm = np.linalg.norm(b[n:])\n\n    if n_ops == 0:\n        return 0.0\n    return (r0_norm - r_final_norm) / n_ops\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = []\n\n    # Case A\n    m, n, P, tau = 8, 4, 2, 2\n    A_A = np.zeros((m, n))\n    for j in range(n):\n        r = 2 * j\n        if 0 = r - 1  m: A_A[r-1, j] += -1\n        if 0 = r  m: A_A[r, j] += 2\n        if 0 = r + 1  m: A_A[r+1, j] += -1\n    b_A = np.sin(np.arange(m) + 1)\n    test_cases.append({'A': A_A, 'b': b_A, 'P': P, 'tau': tau})\n\n    # Case B\n    m, n, P, tau = 9, 4, 3, 2\n    rng = np.random.default_rng(seed=42)\n    A_B = rng.standard_normal((m, n))\n    for j in range(n):\n        A_B[j, j] += 0.1\n    b_B = rng.standard_normal(m)\n    test_cases.append({'A': A_B, 'b': b_B, 'P': P, 'tau': tau})\n\n    # Case C\n    m, n, P, tau = 10, 4, 2, 1\n    A_C = np.zeros((m, n))\n    for i in range(n):\n        A_C[i, i] = 1.0\n    for i in range(4, 10):\n        A_C[i, i % n] = 0.5 + 0.1 * (i - 4)\n    b_C = np.ones(m)\n    test_cases.append({'A': A_C, 'b': b_C, 'P': P, 'tau': tau})\n\n    results = []\n    for case in test_cases:\n        A, b, P, tau = case['A'], case['b'], case['P'], case['tau']\n        \n        delta_G = solve_givens(A, b, P)\n        delta_H = solve_householder(A, b)\n        delta_Hy = solve_hybrid(A, b, P, tau)\n        \n        results.append([delta_G, delta_H, delta_Hy])\n\n    # Format the results into the required string representation\n    print(f\"{results}\")\n\nsolve()\n\n```", "id": "3408903"}]}