{"hands_on_practices": [{"introduction": "任何谱方法的第一步都是构建一个合适的基函数集。本练习旨在夯实多项式混沌展开（PCE）中最基础的概念：定义展开所用基函数的多维索引集。通过从组合学的第一性原理出发推导全阶（total-degree）索引集的规模，并亲手列举其所有元素，您将对PCE模型的复杂性及其随维度 $d$ 和阶数 $p$ 的增长方式获得直观且深刻的理解 [@problem_id:3523172]。这项基本功的练习对于后续理解和构建PCE模型至关重要。", "problem": "考虑一个用于多物理场仿真中耦合热弹性-流体系统的非侵入式多项式混沌展开（PCE）。不确定性输入由一个随机向量 $\\boldsymbol{\\xi} \\in \\mathbb{R}^{d}$ 建模，该向量包含 $d$ 个独立分量，对应五个材料和耦合参数（$d=5$）。为了构建一个有限维近似，您使用一个由下式定义的全阶截断多重指标集\n$$\n\\Lambda_{\\mathrm{TD}}(p) \\equiv \\left\\{ \\alpha \\in \\mathbb{N}_{0}^{d} : \\|\\alpha\\|_{1} \\le p \\right\\},\n$$\n其中 $\\|\\alpha\\|_{1} = \\sum_{i=1}^{d} \\alpha_{i}$ 且 $p$ 是最高多项式阶数（$p=3$）。PCE基函数由 $\\alpha \\in \\Lambda_{\\mathrm{TD}}(p)$ 索引，并且关于输入测度是正交的。\n\n从多重指标的基本定义和组合计数的第一性原理（可重复组合）出发，推导指标集 $\\Lambda_{\\mathrm{TD}}(p)$ 在 $d=5$ 和 $p=3$ 时的基数，过程中不得调用任何预先记忆的快捷公式。然后，按字典序显式地枚举所有满足 $\\|\\alpha\\|_{1} \\le 3$ 的多重指标 $\\alpha \\in \\mathbb{N}_{0}^{5}$。", "solution": "该问题要求针对一个具体案例，推导一个全阶截断多重指标集的基数，并显式枚举其所有元素。该集合定义为 $\\Lambda_{\\mathrm{TD}}(p) \\equiv \\left\\{ \\alpha \\in \\mathbb{N}_{0}^{d} : \\|\\alpha\\|_{1} \\le p \\right\\}$，其中维度 $d=5$，最高多项式阶数 $p=3$。\n\n首先，我们按照要求，从组合计数的第一性原理出发，推导 $\\Lambda_{\\mathrm{TD}}(p)$ 的基数，记作 $|\\Lambda_{\\mathrm{TD}}(p)|$。条件是对于一个多重指标 $\\alpha = (\\alpha_1, \\alpha_2, \\dots, \\alpha_d)$，其中每个 $\\alpha_i$ 都是非负整数，其和必须满足 $\\sum_{i=1}^{d} \\alpha_i \\le p$。\n\n这个不等式可以通过引入一个辅助非负整数变量 $\\alpha_{d+1} \\in \\mathbb{N}_0$（通常称为松弛变量）来转换成一个等式。我们定义 $\\alpha_{d+1}$ 使得其和恰好等于 $p$：\n$$\n\\alpha_1 + \\alpha_2 + \\dots + \\alpha_d + \\alpha_{d+1} = p\n$$\n对于任何满足原不等式 $\\sum_{i=1}^{d} \\alpha_i = k \\le p$ 的非负整数集 $(\\alpha_1, \\dots, \\alpha_d)$，都存在一个唯一的非负整数 $\\alpha_{d+1} = p - k$ 满足该等式。反之，对于该等式的任何非负整数解 $(\\alpha_1, \\dots, \\alpha_d, \\alpha_{d+1})$，其前 $d$ 个分量都满足原不等式。因此，$d$ 个变量的不等式的解的数量与 $d+1$ 个变量的等式的非负整数解的数量相同。\n\n后者是一个经典的组合问题，称为“可重复组合”，可以用“隔板法”来解决。我们需要找到将和 $p$ 分解为 $d+1$ 个非负整数项的方法数。这等价于将 $p$ 个相同的物品（星）和 $(d+1)-1 = d$ 个相同的分隔物（条）排成一列。序列中的总位置数为 $p+d$。选择 $d$ 个条的位置（或等价地，选择 $p$ 个星的位置）的方法数决定了唯一解的数量。这个计数由二项式系数给出：\n$$\n|\\Lambda_{\\mathrm{TD}}(p)| = \\binom{p+d}{d} = \\binom{p+d}{p}\n$$\n这个从基本隔板法类比得出的推导过程，满足了不使用预先记忆的快捷公式的要求。\n\n现在，我们将这个推导出的公式应用于给定的参数：$d=5$ 和 $p=3$。\n$$\n|\\Lambda_{\\mathrm{TD}}(3)| = \\binom{3+5}{5} = \\binom{8}{5}\n$$\n二项式系数的值计算如下：\n$$\n\\binom{8}{5} = \\frac{8!}{5!(8-5)!} = \\frac{8!}{5!3!} = \\frac{8 \\times 7 \\times 6}{3 \\times 2 \\times 1} = 8 \\times 7 = 56\n$$\n当 $d=5$ 时，指标集 $\\Lambda_{\\mathrm{TD}}(3)$ 的基数是 $56$。\n\n其次，我们按字典序显式地枚举所有满足 $\\alpha_i \\in \\mathbb{N}_0$ 和 $\\sum_{i=1}^{5} \\alpha_i \\le 3$ 的 $56$ 个多重指标 $\\alpha = (\\alpha_1, \\alpha_2, \\alpha_3, \\alpha_4, \\alpha_5)$。\n\n完整的多重指标列表如下：\n$ (0,0,0,0,0), (0,0,0,0,1), (0,0,0,0,2), (0,0,0,0,3), (0,0,0,1,0), (0,0,0,1,1), (0,0,0,1,2), (0,0,0,2,0), (0,0,0,2,1), (0,0,0,3,0), (0,0,1,0,0), (0,0,1,0,1), (0,0,1,0,2), (0,0,1,1,0), (0,0,1,1,1), (0,0,1,2,0), (0,0,2,0,0), (0,0,2,0,1), (0,0,2,1,0), (0,0,3,0,0), (0,1,0,0,0), (0,1,0,0,1), (0,1,0,0,2), (0,1,0,1,0), (0,1,0,1,1), (0,1,0,2,0), (0,1,1,0,0), (0,1,1,0,1), (0,1,1,1,0), (0,1,2,0,0), (0,2,0,0,0), (0,2,0,0,1), (0,2,0,1,0), (0,2,1,0,0), (0,3,0,0,0), (1,0,0,0,0), (1,0,0,0,1), (1,0,0,0,2), (1,0,0,1,0), (1,0,0,1,1), (1,0,0,2,0), (1,0,1,0,0), (1,0,1,0,1), (1,0,1,1,0), (1,0,2,0,0), (1,1,0,0,0), (1,1,0,0,1), (1,1,0,1,0), (1,1,1,0,0), (1,2,0,0,0), (2,0,0,0,0), (2,0,0,0,1), (2,0,0,1,0), (2,0,1,0,0), (2,1,0,0,0), (3,0,0,0,0) $", "answer": "$$\n\\boxed{56}\n$$", "id": "3523172"}, {"introduction": "多项式混沌展开的核心优势在于能够高效地进行不确定性量化。一旦PCE模型构建完成，我们如何从中提取有价值的统计信息？本练习将揭示PCE系数与模型输出的关键统计矩（如均值和方差）之间的直接联系。通过利用PCE基函数的正交性，您可以推导出这些矩的简洁表达式，从而体会到PCE在进行不确定性传播和敏感性分析中的强大功能 [@problem_id:3341826]。", "problem": "考虑一个频域计算电磁学模型，其中均匀、各向同性介质具有不确定的介电常数 $\\,\\epsilon(\\xi) = \\epsilon_{0}\\,(1+\\xi)\\,$，其中 $\\,\\epsilon_{0}  0\\,$ 是一个确定性常数，$\\,\\xi \\sim \\mathcal{N}(0,\\sigma^{2})\\,$ 是一个方差为 $\\,\\sigma^{2}  0\\,$ 的标量高斯随机输入。设 $\\,u(\\xi)\\,$ 表示在固定点和频率下评估的标量场解的非负幅值，该解从麦克斯韦方程组引出的控制线性边值问题（例如，波数为 $\\,k(\\xi) = \\omega \\sqrt{\\mu\\,\\epsilon(\\xi)}\\,$ 的标量亥姆霍兹算子）得到，其边界条件确保对于 $\\,\\xi\\,$ 的容许值有唯一解。假设 $\\,u(\\xi)\\,$ 属于关于 $\\,\\xi\\,$ 的高斯测度的平方可积空间，因此在 Wiener–Hermite 类中存在多项式混沌展开 (PCE)。\n\n假设 $\\,u(\\xi)\\,$ 由一个相对于适应 $\\,\\xi\\,$ 分布的标准正交 Hermite 基的有限阶 PCE 表示：\n$$\nu(\\xi) \\approx \\sum_{k=0}^{p} \\hat{u}_{k}\\,\\Psi_{k}(\\xi),\n$$\n其中 $\\,p \\in \\mathbb{N}\\,$ 是截断阶数，$\\,\\hat{u}_{k} \\in \\mathbb{R}\\,$ 是确定性系数，$\\,\\{\\Psi_{k}(\\xi)\\}_{k=0}^{p}\\,$ 是一个关于 $\\,\\xi\\,$ 的高斯测度的标准正交多项式基，满足 $\\,\\mathbb{E}[\\Psi_{m}(\\xi)\\,\\Psi_{n}(\\xi)] = \\delta_{mn}\\,$ 且 $\\,\\Psi_{0}(\\xi) \\equiv 1\\,$。\n\n从基本原理——即控制算子相对于场的线性、二阶矩的定义以及 Wiener–Hermite 基的标准正交性——出发，推导均值 $\\,\\mathbb{E}[u(\\xi)]\\,$ 和方差 $\\,\\operatorname{Var}(u(\\xi))\\,$ 关于系数 $\\,\\{\\hat{u}_{k}\\}_{k=0}^{p}\\,$ 的表达式。然后，陈述在输入 $\\,\\xi\\,$、介电常数映射 $\\,\\epsilon(\\xi)\\,$ 和确定性算子上保证截断的 PCE $\\,\\sum_{k=0}^{p} \\hat{u}_{k}\\,\\Psi_{k}(\\xi)\\,$ 在 $\\,p \\to \\infty\\,$ 时均方收敛于 $\\,u(\\xi)\\,$ 的数学上精确的条件。\n\n将你的最终答案以一个单行向量的形式给出，其中包含以 $\\,\\{\\hat{u}_{k}\\}\\,$ 和 $\\,p\\,$ 表示的均值和方差的闭合形式解析表达式。无需四舍五入，最终答案中不应包含单位。", "solution": "该问题要求从随机变量 $u(\\xi)$ 的多项式混沌展开 (PCE) 中推导其均值和方差，并给出保证此展开均方收敛的条件。$u(\\xi)$ 的 PCE 以截断形式给出为 $u_p(\\xi) = \\sum_{k=0}^{p} \\hat{u}_{k}\\,\\Psi_{k}(\\xi)$。\n\n首先，我们推导均值 $\\mathbb{E}[u(\\xi)]$。对于截断级数 $u_p(\\xi)$，通过应用期望算子 $\\mathbb{E}[\\cdot]$ 来求均值。根据期望算子的线性，我们可以将其移到求和内部。由于系数 $\\hat{u}_k$ 是确定性常数，它们可以从期望中提出。\n$$\n\\mathbb{E}[u_p(\\xi)] = \\mathbb{E}\\left[\\sum_{k=0}^{p} \\hat{u}_{k}\\,\\Psi_{k}(\\xi)\\right] = \\sum_{k=0}^{p} \\hat{u}_{k}\\,\\mathbb{E}[\\Psi_{k}(\\xi)]\n$$\n为了评估 $\\mathbb{E}[\\Psi_{k}(\\xi)]$，我们使用给定的标准正交基的性质。我们已知 $\\Psi_0(\\xi) \\equiv 1$，并且标准正交性条件为 $\\mathbb{E}[\\Psi_m(\\xi)\\Psi_n(\\xi)] = \\delta_{mn}$，其中 $\\delta_{mn}$ 是克罗内克 $\\delta$。我们可以将 $\\Psi_k(\\xi)$ 的期望表示为与 $\\Psi_0(\\xi)$ 的内积：\n$$\n\\mathbb{E}[\\Psi_{k}(\\xi)] = \\mathbb{E}[\\Psi_k(\\xi) \\cdot 1] = \\mathbb{E}[\\Psi_k(\\xi)\\,\\Psi_0(\\xi)] = \\delta_{k0}\n$$\n这个结果表明，除了零阶多项式外，任何基多项式的期望都为零，而零阶多项式的期望为一。将此代入 $u_p(\\xi)$ 的均值表达式中：\n$$\n\\mathbb{E}[u_p(\\xi)] = \\sum_{k=0}^{p} \\hat{u}_{k}\\,\\delta_{k0} = \\hat{u}_0 \\cdot 1 + \\hat{u}_1 \\cdot 0 + \\dots + \\hat{u}_p \\cdot 0 = \\hat{u}_0\n$$\n因此，随机场的均值恰好是零阶 PCE 系数。当 $p \\to \\infty$ 时，如果展开收敛，则 $\\mathbb{E}[u(\\xi)] = \\hat{u}_0$。\n\n接下来，我们推导方差 $\\operatorname{Var}(u(\\xi))$。方差定义为 $\\operatorname{Var}(u_p(\\xi)) = \\mathbb{E}[u_p(\\xi)^2] - (\\mathbb{E}[u_p(\\xi)])^2$。我们已经求得 $\\mathbb{E}[u_p(\\xi)] = \\hat{u}_0$。现在我们需要计算二阶矩 $\\mathbb{E}[u_p(\\xi)^2]$。\n$$\n\\mathbb{E}[u_p(\\xi)^2] = \\mathbb{E}\\left[\\left(\\sum_{k=0}^{p} \\hat{u}_{k}\\,\\Psi_{k}(\\xi)\\right)^2\\right] = \\mathbb{E}\\left[\\left(\\sum_{k=0}^{p} \\hat{u}_{k}\\,\\Psi_{k}(\\xi)\\right)\\left(\\sum_{j=0}^{p} \\hat{u}_{j}\\,\\Psi_{j}(\\xi)\\right)\\right]\n$$\n展开乘积并利用期望的线性：\n$$\n\\mathbb{E}[u_p(\\xi)^2] = \\sum_{k=0}^{p}\\sum_{j=0}^{p} \\hat{u}_k \\hat{u}_j \\mathbb{E}[\\Psi_k(\\xi) \\Psi_j(\\xi)]\n$$\n使用标准正交性条件 $\\mathbb{E}[\\Psi_k(\\xi)\\Psi_j(\\xi)] = \\delta_{kj}$：\n$$\n\\mathbb{E}[u_p(\\xi)^2] = \\sum_{k=0}^{p}\\sum_{j=0}^{p} \\hat{u}_k \\hat{u}_j \\delta_{kj} = \\sum_{k=0}^{p} \\hat{u}_k^2\n$$\n这是 $u_p(\\xi)$ 的二阶矩。现在，我们将二阶矩和均值代入方差公式：\n$$\n\\operatorname{Var}(u_p(\\xi)) = \\mathbb{E}[u_p(\\xi)^2] - (\\mathbb{E}[u_p(\\xi)])^2 = \\sum_{k=0}^{p} \\hat{u}_k^2 - (\\hat{u}_0)^2\n$$\n将 $k=0$ 的项从求和中分离出来得到：\n$$\n\\operatorname{Var}(u_p(\\xi)) = \\left(\\hat{u}_0^2 + \\sum_{k=1}^{p} \\hat{u}_k^2\\right) - \\hat{u}_0^2 = \\sum_{k=1}^{p} \\hat{u}_k^2\n$$\n方差是所有高阶 ($k \\geq 1$) PCE 系数的平方和。\n\n最后，我们讨论均方收敛的条件。对于用于高斯随机变量 $\\xi$ 的 Wiener-Hermite PCE，Cameron-Martin 定理为此收敛性提供了充要条件。这个唯一的、数学上精确的条件是函数 $u(\\xi)$ 必须关于高斯概率测度是平方可积的，即它必须属于希尔伯特空间 $L^2(\\mathbb{R}, w(\\xi)d\\xi)$，其中 $w(\\xi)$ 是 $\\xi$ 的高斯概率密度函数。这等价于要求 $u(\\xi)$ 的二阶矩是有限的：\n$$\n\\mathbb{E}[u(\\xi)^2]  \\infty\n$$\n问题陈述明确地假设了这一条件。这个关于输出函数 $u(\\xi)$ 的条件对系统各组成部分施加了隐含的条件：算子、边界条件和特定参数化必须共同确保解 $u(\\xi)$ 满足有限方差条件，这意味着解中的任何奇点在均方意义下必须是可积的。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\hat{u}_{0}  \\sum_{k=1}^{p} \\hat{u}_{k}^{2} \\end{pmatrix}}\n$$", "id": "3341826"}, {"introduction": "从理论走向实践，最后一个练习要求您从零开始，编写一个完整的算法来构建一个稳健的、由数据驱动的PCE代理模型。在解决实际问题时，我们通常无法预知模型的最佳复杂度，因此需要一种系统性的方法来选择最优的多项式阶数。本练习 [@problem_id:3411033] 综合了正则化最小二乘法、高效的留一法交叉验证误差估计以及稳健的模型选择准则，旨在培养您解决真实世界逆问题和数据同化挑战时所必需的计算和建模技能。", "problem": "在反问题和数据同化的背景下，设计并实现一个用于多项式混沌展开（PCE）代理模型预测误差的后验交叉验证估计器，以及一个基于验证损失曲线的总多项式阶数的自适应选择规则。您的实现必须是一个完整的、可运行的程序。\n\n您必须从以下基本原理出发：\n- 多项式混沌展开是利用适应于输入分布的标准正交多项式，对一个平方可积的关注随机量进行的谱表示。对于独立的标准正态输入，其单变量标准正交基由概率论者的Hermite多项式给出，经过归一化后，通过张量积构建的多元基相对于联合标准正态测度是标准正交的。\n- 在具有固定设计矩阵的最小二乘回归中，拟合的预测器是一个线性平滑器。如果将拟合值写为应用于数据向量的线性算子，那么留一法交叉验证可以在不重复拟合模型的情况下，利用平滑矩阵（帽子矩阵）的对角线元素进行后验计算。\n\n问题详述：\n1. 考虑一个标量正向模型输出，表示为一个输入随机向量的函数，该向量具有独立的标准正态分量，记为 $\\boldsymbol{\\Xi} \\in \\mathbb{R}^{d}$，其密度为 $\\mathcal{N}(\\boldsymbol{0}, \\mathbf{I})$。令关注量为 $Y = g(\\boldsymbol{\\Xi}) + \\varepsilon$，其中 $\\varepsilon$ 是一个均值为零、方差有限的独立噪声。代理模型是一个总阶数为 $p$ 的多项式混沌展开：\n   $$ Y \\approx \\sum_{\\boldsymbol{\\alpha} \\in \\mathbb{N}_{0}^{d}, \\lVert \\boldsymbol{\\alpha} \\rVert_{1} \\leq p} c_{\\boldsymbol{\\alpha}} \\, \\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\Xi}), $$\n   其中 $\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\Xi}) = \\prod_{j=1}^{d} \\psi_{\\alpha_{j}}(\\Xi_{j})$，而 $\\psi_{n}$ 是由 $\\sqrt{n!}$ 归一化的单变量标准正交概率论者Hermite多项式 $\\mathrm{He}_{n}$。\n\n2. 给定 $N$ 个独立同分布的样本 $\\{\\boldsymbol{\\xi}^{(i)}, y^{(i)}\\}_{i=1}^{N}$，其中 $\\boldsymbol{\\xi}^{(i)} \\sim \\mathcal{N}(\\boldsymbol{0}, \\mathbf{I})$ 且 $y^{(i)} = g(\\boldsymbol{\\xi}^{(i)}) + \\varepsilon^{(i)}$，通过Tikhonov正则化最小二乘法拟合PCE系数：\n   $$ \\widehat{\\mathbf{c}} = \\arg\\min_{\\mathbf{c}} \\big\\lVert \\mathbf{A} \\mathbf{c} - \\mathbf{y} \\big\\rVert_{2}^{2} + \\lambda \\lVert \\mathbf{c} \\rVert_{2}^{2}, $$\n   其中 $\\mathbf{A}_{i,m} = \\Psi_{\\boldsymbol{\\alpha}^{(m)}}(\\boldsymbol{\\xi}^{(i)})$ 是由最高总阶数为 $p$ 的多元标准正交基构建的设计矩阵，$\\mathbf{y} = [y^{(1)}, \\dots, y^{(N)}]^{\\top}$，$\\lambda  0$ 是一个小的正则化参数。\n\n3. 使用平滑矩阵\n   $$ \\mathbf{S} = \\mathbf{A}(\\mathbf{A}^{\\top}\\mathbf{A} + \\lambda \\mathbf{I})^{-1}\\mathbf{A}^{\\top}, $$\n   和残差向量 $\\mathbf{r} = \\mathbf{y} - \\widehat{\\mathbf{y}}$（其中 $\\widehat{\\mathbf{y}} = \\mathbf{A} \\widehat{\\mathbf{c}}$），通过以下恒等式，推导并实现一个均方根预测误差的后验留一法（LOO）交叉验证估计器：\n   $$ e_{i}^{\\mathrm{LOO}} = \\frac{r_{i}}{1 - S_{ii}}, \\quad \\mathrm{RMSE}_{\\mathrm{LOO}} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left(e_{i}^{\\mathrm{LOO}}\\right)^{2}}. $$\n   为了在实现中保证数值稳定性，如果 $\\lvert 1 - S_{ii} \\rvert$ 非常小，您必须通过用一个带符号的小量级替代值替换 $1 - S_{ii}$ 来避免除以零。\n\n4. 为了使损失具有尺度不变性，计算归一化的留一法均方根误差（NRMSE）为\n   $$ \\mathrm{NRMSE}_{\\mathrm{LOO}} = \\frac{\\mathrm{RMSE}_{\\mathrm{LOO}}}{\\mathrm{std}(\\mathbf{y})}, $$\n   其中 $\\mathrm{std}(\\mathbf{y})$ 是观测输出的样本标准差。\n\n5. 对于自适应模型选择，计算所有阶数 $p \\in \\{0, 1, \\dots, p_{\\max}\\}$ 的 $\\mathrm{NRMSE}_{\\mathrm{LOO}}(p)$，并使用单标准误规则选择阶数：令 $p_{\\min}$ 为 $\\mathrm{NRMSE}_{\\mathrm{LOO}}(p)$ 的一个最小化子，并令 $\\mathrm{SE}(p)$ 表示 $\\mathrm{RMSE}_{\\mathrm{LOO}}(p)$ 的标准误估计。选择\n   $$ p^{\\star} = \\min \\left\\{ p \\in \\{0, \\dots, p_{\\max}\\} \\,:\\, \\mathrm{NRMSE}_{\\mathrm{LOO}}(p) \\leq \\mathrm{NRMSE}_{\\mathrm{LOO}}(p_{\\min}) + \\frac{\\mathrm{SE}(p_{\\min})}{\\mathrm{std}(\\mathbf{y})} \\right\\}。 $$\n   您必须通过Delta方法，从留一法残差 $\\{e_{i}^{\\mathrm{LOO}}\\}_{i=1}^{N}$ 估计 $\\mathrm{SE}(p)$：令 $Z_{i} = \\left(e_{i}^{\\mathrm{LOO}}\\right)^{2}$，$\\widehat{\\mu} = \\frac{1}{N}\\sum_{i=1}^{N} Z_{i}$，$\\widehat{\\sigma}_{Z}^{2} = \\frac{1}{N-1}\\sum_{i=1}^{N} (Z_{i} - \\widehat{\\mu})^{2}$，\n   $$ \\mathrm{SE}(\\mathrm{RMSE}_{\\mathrm{LOO}}) \\approx \\frac{\\sqrt{\\widehat{\\sigma}_{Z}^{2}/N}}{2 \\sqrt{\\widehat{\\mu}}}。 $$\n\n6. 使用上述方法设计一个鲁棒且数值稳定的算法来：\n   - 构建维度为 $d$、最高总阶数为 $p$ 的标准正交多元Hermite基。\n   - 组装设计矩阵并计算 $\\widehat{\\mathbf{c}}$。\n   - 为每个阶数 $p$ 计算后验LOO NRMSE及其标准误估计。\n   - 使用单标准误规则选择 $p^{\\star}$。\n\n测试套件：\n您必须实现以下三个测试用例，并使用固定的随机种子以保证可复现性。对于所有三角函数，使用弧度制角度。所有输入均为独立的标准正态分布。\n\n- 测试用例1（平滑指数函数，中等数据量）：\n  - 维度 $d = 2$。\n  - 样本量 $N = 80$。\n  - 最大阶数 $p_{\\max} = 8$。\n  - 函数 $g(\\boldsymbol{\\xi}) = \\exp(0.8 \\, \\xi_{1} + 0.2 \\, \\xi_{2})$。\n  - 加性噪声 $\\varepsilon \\sim \\mathcal{N}(0, \\sigma^{2})$，其中 $\\sigma = 0.01$。\n\n- 测试用例2（低数据量，接近饱和）：\n  - 维度 $d = 3$。\n  - 样本量 $N = 12$。\n  - 最大阶数 $p_{\\max} = 5$。\n  - 函数 $g(\\boldsymbol{\\xi}) = \\xi_{1}^{2} + \\xi_{2} \\xi_{3}$。\n  - 加性噪声 $\\varepsilon \\sim \\mathcal{N}(0, \\sigma^{2})$，其中 $\\sigma = 0.05$。\n\n- 测试用例3（带噪声的振荡函数）：\n  - 维度 $d = 2$。\n  - 样本量 $N = 60$。\n  - 最大阶数 $p_{\\max} = 10$。\n  - 函数 $g(\\boldsymbol{\\xi}) = \\sin(\\xi_{1}) + 0.1 \\cos(0.5 \\, \\xi_{2})$。\n  - 加性噪声 $\\varepsilon \\sim \\mathcal{N}(0, \\sigma^{2})$，其中 $\\sigma = 0.05$。\n\n随机性：\n- 使用固定的基础种子 $s_{0} = 20240513$。\n- 对于测试用例索引 $k \\in \\{0, 1, 2\\}$，使用种子 $s_{k} = s_{0} + 1000 \\, k$ 初始化随机数生成器。\n\n数值约束：\n- 使用一个小的Tikhonov正则化参数 $\\lambda = 10^{-10}$。\n- 为避免在留一法公式中出现除以零的情况，将任何分母 $1 - S_{ii}$ 替换为 $\\operatorname{sign}(1 - S_{ii}) \\cdot \\max\\{\\lvert 1 - S_{ii} \\rvert, 10^{-12}\\}$。\n\n程序要求输出：\n- 对于每个测试用例，计算选定的阶数 $p^{\\star}$ 和对应的 $\\mathrm{NRMSE}_{\\mathrm{LOO}}(p^{\\star})$。\n- 您的程序应生成单行输出，其中包含按顺序排列的六个结果，格式为用方括号括起来的逗号分隔列表：\n  $$ [p^{\\star}_{1}, \\mathrm{NRMSE}_{1}, p^{\\star}_{2}, \\mathrm{NRMSE}_{2}, p^{\\star}_{3}, \\mathrm{NRMSE}_{3}] $$\n  其中每个 $\\mathrm{NRMSE}$ 必须是浮点数。为便于阅读，您可以将每个浮点数四舍五入到 $6$ 位小数。\n\n关于反问题和数据同化的补充背景：\n- 在贝叶斯反问题和数据同化中，PCE代理模型常用于近似正向模型及其不确定性传播。后验交叉验证误差估计器提供了一种数据驱动的方法来评估和调整代理模型的复杂度，从而防止过拟合并稳定推断流程，尤其是在观测数据稀少或含噪的情况下。\n\n不允许外部输入；您的程序必须能按原样运行并打印所需的输出行。", "solution": "目标是设计并实现一个鲁棒的算法，用于自适应地选择多项式混沌展开（PCE）代理模型的总多项式阶数 $p$。这项工作在反问题和数据同化的背景下完成，其中数据驱动的模型验证至关重要。该方法利用后验留一法交叉验证（LOO-CV）进行误差估计，并采用单标准误规则进行模型选择，从而确保模型准确性与复杂性之间的平衡。\n\n### 基于原理的算法设计\n\n该算法由一系列有充分依据的统计学和数值原理构建而成。\n\n#### 1. 多项式混沌展开（PCE）代理模型\n\n我们考虑一个关注量 $Y$，它是 $d$ 维随机向量 $\\boldsymbol{\\Xi}$ 的函数，其中 $\\boldsymbol{\\Xi}$ 的分量是独立的标准正态随机变量，即 $\\boldsymbol{\\Xi} \\sim \\mathcal{N}(\\boldsymbol{0}, \\mathbf{I})$。模型由 $Y = g(\\boldsymbol{\\Xi}) + \\varepsilon$ 给出，其中 $\\varepsilon$ 是观测噪声。我们使用总阶数为 $p$ 的PCE来近似 $g(\\boldsymbol{\\Xi})$：\n$$ g(\\boldsymbol{\\Xi}) \\approx \\mathcal{M}_{p}(\\boldsymbol{\\Xi}) = \\sum_{\\boldsymbol{\\alpha} \\in \\mathcal{A}_{p,d}} c_{\\boldsymbol{\\alpha}} \\, \\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\Xi}), $$\n其中 $\\mathcal{A}_{p,d} = \\{\\boldsymbol{\\alpha} \\in \\mathbb{N}_{0}^{d} : \\lVert \\boldsymbol{\\alpha} \\rVert_{1} \\leq p\\}$ 是多重指标的集合。基函数 $\\Psi_{\\boldsymbol{\\alpha}}$ 是多元标准正交多项式。对于标准正态测度，这些基函数通过单变量标准正交概率论者Hermite多项式的张量积构建：\n$$ \\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\Xi}) = \\prod_{j=1}^{d} \\psi_{\\alpha_{j}}(\\Xi_{j}) \\quad \\text{其中} \\quad \\psi_{n}(x) = \\frac{\\mathrm{He}_{n}(x)}{\\sqrt{n!}}。 $$\n概率论者的Hermite多项式 $\\mathrm{He}_n(x)$ 通过三项递推关系生成：$\\mathrm{He}_{n+1}(x) = x \\mathrm{He}_n(x) - n \\mathrm{He}_{n-1}(x)$，初始条件为 $\\mathrm{He}_0(x)=1$ 和 $\\mathrm{He}_1(x)=x$。\n\n#### 2. 通过正则化最小二乘法估计系数\n\n给定一组 $N$ 个数据对 $\\{\\boldsymbol{\\xi}^{(i)}, y^{(i)}\\}_{i=1}^{N}$，未知系数 $\\mathbf{c} = \\{c_{\\boldsymbol{\\alpha}}\\}_{\\boldsymbol{\\alpha} \\in \\mathcal{A}_{p,d}}$ 通过求解一个线性回归问题来确定。为了增强数值稳定性并防止过拟合，特别是在基函数数量 $P = |\\mathcal{A}_{p,d}|$ 接近或超过样本数量 $N$ 时，我们采用Tikhonov正则化（岭回归）。系数通过最小化正则化的误差平方和求得：\n$$ \\widehat{\\mathbf{c}} = \\arg\\min_{\\mathbf{c}} \\left\\lVert \\mathbf{A} \\mathbf{c} - \\mathbf{y} \\right\\rVert_{2}^{2} + \\lambda \\lVert \\mathbf{c} \\rVert_{2}^{2}, $$\n其中 $\\mathbf{y} = [y^{(1)}, \\dots, y^{(N)}]^{\\top}$ 是观测向量，$\\lambda  0$ 是正则化参数，$\\mathbf{A}$ 是 $N \\times P$ 的设计矩阵，其元素为 $\\mathbf{A}_{i,m} = \\Psi_{\\boldsymbol{\\alpha}^{(m)}}(\\boldsymbol{\\xi}^{(i)})$。该优化问题的解析解由正规方程给出：\n$$ \\widehat{\\mathbf{c}} = (\\mathbf{A}^{\\top}\\mathbf{A} + \\lambda \\mathbf{I})^{-1}\\mathbf{A}^{\\top}\\mathbf{y}。 $$\n\n#### 3. 后验留一法交叉验证（LOO-CV）\n\n主要目标是估计模型在未见数据上的预测误差。LOO-CV为该误差提供了一个近似无偏的估计。对于线性平滑器，例如由岭回归产生的平滑器，LOO-CV误差可以高效计算，而无需重复拟合模型 $N$ 次。拟合值向量为 $\\widehat{\\mathbf{y}} = \\mathbf{A}\\widehat{\\mathbf{c}} = \\mathbf{S}\\mathbf{y}$，其中\n$$ \\mathbf{S} = \\mathbf{A}(\\mathbf{A}^{\\top}\\mathbf{A} + \\lambda \\mathbf{I})^{-1}\\mathbf{A}^{\\top} $$\n是平滑（或“帽子”）矩阵。第 $i$ 个数据点的LOO预测误差 $e_{i}^{\\mathrm{LOO}} = y^{(i)} - \\widehat{y}^{(-i)}$（其中 $\\widehat{y}^{(-i)}$ 是在除第 $i$ 个点之外的所有数据上训练的模型在 $\\boldsymbol{\\xi}^{(i)}$ 处的预测值）由以下恒等式给出：\n$$ e_{i}^{\\mathrm{LOO}} = \\frac{y^{(i)} - \\widehat{y}^{(i)}}{1 - S_{ii}} = \\frac{r_{i}}{1 - S_{ii}}, $$\n其中 $r_i$ 是第 $i$ 个普通残差，$S_{ii}$ 是平滑矩阵的第 $i$ 个对角元素。留一法均方根误差则为：\n$$ \\mathrm{RMSE}_{\\mathrm{LOO}} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left(e_{i}^{\\mathrm{LOO}}\\right)^{2}}。 $$\n为保证数值稳定性，如果分母 $1 - S_{ii}$ 接近于零，则用 $\\operatorname{sign}(1 - S_{ii}) \\cdot \\max\\{\\lvert 1 - S_{ii} \\rvert, \\epsilon\\}$ 替换，其中 $\\epsilon = 10^{-12}$ 是一个很小的容差。\n\n为高效计算对角元素 $S_{ii}$，我们避免构建完整的 $N \\times N$ 矩阵 $\\mathbf{S}$。令 $\\mathbf{M} = \\mathbf{A}^{\\top}\\mathbf{A} + \\lambda \\mathbf{I}$。我们计算其Cholesky分解 $\\mathbf{M} = \\mathbf{L}\\mathbf{L}^{\\top}$。则 $\\mathbf{S} = \\mathbf{A}(\\mathbf{L}\\mathbf{L}^{\\top})^{-1}\\mathbf{A}^{\\top} = (\\mathbf{A}(\\mathbf{L}^{\\top})^{-1})(\\mathbf{L}^{-1}\\mathbf{A}^{\\top}) = \\mathbf{V}\\mathbf{V}^{\\top}$，其中 $\\mathbf{V} = \\mathbf{A}(\\mathbf{L}^{\\top})^{-1}$。$\\mathbf{V}^{\\top}$ 的列可以通过对 $\\mathbf{A}^\\top$ 的每一列 $\\mathbf{a}_i$ 求解三角系统 $\\mathbf{L}\\mathbf{v}'_i = \\mathbf{a}_i$ 来找到。等价地，我们求解 $\\mathbf{L} \\mathbf{U} = \\mathbf{A}^\\top$ 得到 $\\mathbf{U}$，然后令 $\\mathbf{V}=\\mathbf{U}^\\top$。对角元素则为 $S_{ii} = \\sum_{j=1}^P V_{ij}^2$，即 $\\mathbf{V}$ 的第 $i$ 行元素平方和。\n\n#### 4. 通过单标准误规则进行自适应阶数选择\n\n为了选择最合适的模型复杂度，我们为一系列多项式阶数 $p \\in \\{0, 1, \\dots, p_{\\max}\\}$ 计算归一化LOO-RMSE（NRMSE）：\n$$ \\mathrm{NRMSE}_{\\mathrm{LOO}}(p) = \\frac{\\mathrm{RMSE}_{\\mathrm{LOO}}(p)}{\\mathrm{std}(\\mathbf{y})}, $$\n其中 $\\mathrm{std}(\\mathbf{y})$ 是观测值的样本标准差。这种归一化使得误差度量具有尺度不变性。\n\n单标准误规则是一种倾向于简约模型的启发式方法。它选择性能与最佳模型在统计上相当的最简单模型。令 $p_{\\min}$ 是最小化 $\\mathrm{NRMSE}_{\\mathrm{LOO}}(p)$ 的阶数。我们选择最优阶数 $p^{\\star}$ 为误差在最小误差的一个标准误范围内的最小阶数 $p$：\n$$ p^{\\star} = \\min \\left\\{ p \\in \\{0, \\dots, p_{\\max}\\} \\,:\\, \\mathrm{NRMSE}_{\\mathrm{LOO}}(p) \\leq \\mathrm{NRMSE}_{\\mathrm{LOO}}(p_{\\min}) + \\frac{\\mathrm{SE}(p_{\\min})}{\\mathrm{std}(\\mathbf{y})} \\right\\}。 $$\n$\\mathrm{RMSE}_{\\mathrm{LOO}}$ 的标准误（记为 $\\mathrm{SE}(p)$）使用Delta方法估计。令 $Z_i = (e_{i}^{\\mathrm{LOO}})^2$。则 $\\mathrm{RMSE}_{\\mathrm{LOO}} = \\sqrt{\\widehat{\\mu}_Z}$，其中 $\\widehat{\\mu}_Z = \\frac{1}{N}\\sum Z_i$。$\\sqrt{\\widehat{\\mu}_Z}$ 的标准误近似为：\n$$ \\mathrm{SE}(\\mathrm{RMSE}_{\\mathrm{LOO}}) \\approx \\frac{\\mathrm{SE}(\\widehat{\\mu}_Z)}{2\\sqrt{\\widehat{\\mu}_Z}} = \\frac{\\sqrt{\\widehat{\\sigma}_{Z}^{2}/N}}{2 \\sqrt{\\widehat{\\mu}_Z}}, $$\n其中 $\\widehat{\\sigma}_{Z}^{2} = \\frac{1}{N-1}\\sum_{i=1}^{N} (Z_i - \\widehat{\\mu}_Z)^2$ 是LOO误差平方的样本方差。\n\n最终的算法通过从 $0$ 到 $p_{\\max}$ 遍历阶数 $p$ 来进行。对于每个阶数，它构建基、组装设计矩阵、求解正则化系统、计算LOO NRMSE及其标准误，最后应用单标准误规则于所产生的误差曲线上，以确定 $p^{\\star}$。", "answer": "```python\nimport numpy as np\nfrom scipy.special import hermite, factorial\nfrom scipy.linalg import solve_triangular\nimport math\n\ndef generate_multi_indices(d, p_max):\n    \"\"\"\n    Generates all multi-indices of dimension d with L1 norm up to p_max.\n    \"\"\"\n    if d == 1:\n        return [[i] for i in range(p_max + 1)]\n    \n    indices = []\n    \n    def _recursive_gen(dim_left, p_left, current_index):\n        if dim_left == 1:\n            for i in range(p_left + 1):\n                indices.append(current_index + [i])\n            return\n\n        for i in range(p_left + 1):\n            _recursive_gen(dim_left - 1, p_left - i, current_index + [i])\n\n    _recursive_gen(d, p_max, [])\n    return sorted(indices, key=sum)\n\ndef solve_case(d, N, p_max, g_func, sigma, seed, lambda_reg, denominator_tol):\n    \"\"\"\n    Solves a single test case for PCE model selection.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    xi_samples = rng.normal(size=(N, d))\n    noise = rng.normal(0, sigma, size=N)\n    y_true = np.apply_along_axis(g_func, 1, xi_samples)\n    y = y_true + noise\n    \n    # Use sample standard deviation (ddof=1)\n    y_std = np.std(y, ddof=1)\n    if y_std  1e-15:  # Handle constant output\n        y_std = 1.0\n\n    nrmse_loo_curve = []\n    se_rmse_curve = []\n    \n    all_multi_indices_pmax = generate_multi_indices(d, p_max)\n    \n    # Pre-compute univariate polynomial values\n    # poly_vals[i, j, k] = psi_k(xi_samples[i, j])\n    max_univariate_deg = p_max\n    univariate_poly_vals = np.zeros((N, d, max_univariate_deg + 1))\n    for k in range(max_univariate_deg + 1):\n        norm_const = np.sqrt(factorial(k, exact=False))\n        # Use probabilists' Hermite polynomials (monic=True)\n        he_poly = hermite(k, monic=True)\n        univariate_poly_vals[:, :, k] = he_poly(xi_samples) / norm_const\n\n    for p in range(p_max + 1):\n        multi_indices = [idx for idx in all_multi_indices_pmax if sum(idx) = p]\n        P = len(multi_indices)\n\n        # Assemble design matrix A\n        A = np.zeros((N, P))\n        for m, alpha in enumerate(multi_indices):\n            term = np.ones(N)\n            for j in range(d):\n                term *= univariate_poly_vals[:, j, alpha[j]]\n            A[:, m] = term\n\n        # Solve for coefficients and compute LOO error\n        try:\n            if P == 0: # Should not happen for p>=0\n                raise np.linalg.LinAlgError(\"No basis functions.\")\n            \n            # Ridge regression solution\n            # c_hat = (A.T @ A + lambda_reg * I)^-1 @ A.T @ y\n            M = A.T @ A + lambda_reg * np.identity(P)\n            c_hat = np.linalg.solve(M, A.T @ y)\n            y_hat = A @ c_hat\n            residuals = y - y_hat\n\n            # Efficiently compute diagonal of hat matrix S\n            # S = A @ (A.T @ A + lambda_reg * I)^-1 @ A.T\n            L = np.linalg.cholesky(M)\n            V = solve_triangular(L, A.T, lower=True).T\n            S_diag = np.sum(V**2, axis=1)\n\n            # Compute LOO residuals with numerical stability\n            denominators = 1.0 - S_diag\n            stable_denominators = np.sign(denominators) * np.maximum(\n                np.abs(denominators), denominator_tol\n            )\n            e_loo = residuals / stable_denominators\n            \n            # Compute RMSE_LOO and its standard error\n            Z = e_loo**2\n            mu_hat = np.mean(Z)\n            \n            if mu_hat  1e-24: # Perfect fit, no error\n                rmse_loo = 0.0\n                se_rmse = 0.0\n            else:\n                rmse_loo = np.sqrt(mu_hat)\n                # Use sample variance (ddof=1)\n                sigma_Z_sq = np.var(Z, ddof=1)\n                if sigma_Z_sq  0: sigma_Z_sq = 0.0\n                se_rmse = np.sqrt(sigma_Z_sq / N) / (2.0 * rmse_loo)\n\n        except (np.linalg.LinAlgError, ValueError):\n            rmse_loo = np.inf\n            se_rmse = np.inf\n\n        nrmse_loo_curve.append(rmse_loo / y_std)\n        se_rmse_curve.append(se_rmse)\n\n    # One-standard-error rule for selecting p_star\n    nrmse_loo_curve = np.array(nrmse_loo_curve)\n    se_rmse_curve = np.array(se_rmse_curve)\n    \n    if np.all(np.isinf(nrmse_loo_curve)):\n        p_star = 0 # Default to simplest model if all fail\n    else:\n        p_min_idx = np.nanargmin(nrmse_loo_curve)\n        nrmse_min = nrmse_loo_curve[p_min_idx]\n        se_min = se_rmse_curve[p_min_idx]\n        se_nrmse_min = se_min / y_std\n    \n        threshold = nrmse_min + se_nrmse_min\n        \n        # Find simplest model (smallest p) within the threshold\n        candidate_indices = np.where(nrmse_loo_curve = threshold)[0]\n        p_star = candidate_indices[0] if len(candidate_indices) > 0 else p_min_idx\n\n    nrmse_at_p_star = nrmse_loo_curve[p_star]\n\n    return p_star, nrmse_at_p_star\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    base_seed = 20240513\n    lambda_reg = 1e-10\n    denominator_tol = 1e-12\n\n    test_cases = [\n        {\n            \"d\": 2, \"N\": 80, \"p_max\": 8,\n            \"g_func\": lambda xi: np.exp(0.8 * xi[0] + 0.2 * xi[1]),\n            \"sigma\": 0.01,\n            \"seed\": base_seed + 1000 * 0\n        },\n        {\n            \"d\": 3, \"N\": 12, \"p_max\": 5,\n            \"g_func\": lambda xi: xi[0]**2 + xi[1] * xi[2],\n            \"sigma\": 0.05,\n            \"seed\": base_seed + 1000 * 1\n        },\n        {\n            \"d\": 2, \"N\": 60, \"p_max\": 10,\n            \"g_func\": lambda xi: np.sin(xi[0]) + 0.1 * np.cos(0.5 * xi[1]),\n            \"sigma\": 0.05,\n            \"seed\": base_seed + 1000 * 2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p_star, nrmse = solve_case(\n            case[\"d\"], case[\"N\"], case[\"p_max\"], case[\"g_func\"],\n            case[\"sigma\"], case[\"seed\"], lambda_reg, denominator_tol\n        )\n        results.append(p_star)\n        results.append(f\"{nrmse:.6f}\")\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3411033"}]}