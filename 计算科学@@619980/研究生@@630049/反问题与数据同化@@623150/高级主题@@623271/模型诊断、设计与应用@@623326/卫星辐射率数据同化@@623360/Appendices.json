{"hands_on_practices": [{"introduction": "辐射传输模型本质上是非线性的，而变分资料同化系统在很大程度上依赖于其线性化版本，即切线性模型。本练习将指导您从物理第一性原理出发，推导一个简化辐射传输模型的切线性算子[@problem_id:3365135]。通过数值实验评估不同扰动大小下的线性化误差，您将亲身体验切线性近似的有效性边界，这是理解和诊断现代同化系统性能的关键一步。", "problem": "考虑在地表上方一个水平均匀、晴空、等温的湿层上，对来自单一光谱通道的卫星天底观测热红外辐射率进行同化。设观测算子使用以下基于物理的要素，将大气状态映射到大气层顶 (TOA) 的单色辐射率：\n\n1. 沿视线吸收的 Beer–Lambert law。对于天底几何（天顶角余弦等于 $1$），该层的透射率为\n$$\n\\tau(q) = \\exp\\left(- \\kappa_\\nu \\, q \\, M_{\\text{air}}\\right),\n$$\n其中 $q$ 是比湿，单位为 $\\mathrm{kg}\\,\\mathrm{kg}^{-1}$；$\\kappa_\\nu$ 是水汽在通道波数处的质量吸收系数，单位为 $\\mathrm{m}^2\\,\\mathrm{kg}^{-1}$；$M_{\\text{air}}$ 是单位面积的层内空气质量，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-2}$。\n\n2. 关于光谱辐射率作为绝对温度函数的 Planck's law，写在波数域（单位波数的光谱辐射率）：\n$$\nB_{\\tilde{\\nu}}(T) = \\frac{2 h c^2 \\tilde{\\nu}^3}{\\exp\\!\\left(\\frac{h c \\tilde{\\nu}}{k_B T}\\right) - 1},\n$$\n其中 $h$ 是 Planck 常数，单位为 $\\mathrm{J}\\,\\mathrm{s}$；$c$ 是光速，单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$；$k_B$ 是 Boltzmann 常数，单位为 $\\mathrm{J}\\,\\mathrm{K}^{-1}$；$\\tilde{\\nu}$ 是波数，单位为 $\\mathrm{m}^{-1}$；$T$ 是温度，单位为 $\\mathrm{K}$。$B_{\\tilde{\\nu}}$ 的单位是 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,(\\mathrm{m}^{-1})^{-1}$。\n\n3. 地表是一个发射率为 $\\varepsilon_s$（无量纲）、表面温度为 $T_s$ 的 Lambertian 发射体，且大气层在温度 $T_\\ell$ 下是等温的。对于天底观测和晴空条件，大气层顶 (TOA) 的单色辐射率为\n$$\nH(q) = \\varepsilon_s \\, B_{\\tilde{\\nu}}(T_s)\\, \\tau(q) + \\left(1 - \\tau(q)\\right) B_{\\tilde{\\nu}}(T_\\ell).\n$$\n\n要求您在有限扰动实验中测试观测算子的切线性 (TL) 近似的有效性。设背景比湿为 $q_b$。对于一个扰动 $\\delta q$，将 $H$ 在 $q_b$ 周围的 TL 线性化定义为\n$$\nH(q_b + \\delta q) \\approx H(q_b) + K\\, \\delta q,\n$$\n其中 $K$ 是 TL 算子（$H$ 相对于 $q$ 在 $q_b$ 处的导数）。您的任务是：\n\n- 严格从上述定义和标准微分法则出发，根据给定的物理参数推导 $K$ 在 $q_b$ 处的解析表达式。除所述假设外，不要引入任何非物理的近似。\n\n- 对于每个扰动 $\\delta q$，计算非线性指标（相对 TL 误差）\n$$\n\\mathcal{E}_{\\text{rel}}(\\delta q) = \\frac{\\left|H(q_b+\\delta q) - H(q_b) - K\\,\\delta q\\right|}{\\left|H(q_b+\\delta q) - H(q_b)\\right|},\n$$\n约定如果分母为零，则 $\\mathcal{E}_{\\text{rel}}(\\delta q)$ 定义为 $0$。\n\n- 对于下面的每个测试用例，返回该测试用例中扰动列表上 $\\mathcal{E}_{\\text{rel}}(\\delta q)$ 的最大值，结果为一个标量。\n\n物理常数和单位：\n- 使用 $h = 6.62607015\\times 10^{-34}\\ \\mathrm{J}\\,\\mathrm{s}$，$c = 2.99792458\\times 10^{8}\\ \\mathrm{m}\\,\\mathrm{s}^{-1}$，以及 $k_B = 1.380649\\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$。\n- 使用单一通道，其波数为 $\\tilde{\\nu} = 1000\\ \\mathrm{cm}^{-1} = 100000\\ \\mathrm{m}^{-1}$。\n- 所有温度必须以 $\\mathrm{K}$ 表示，比湿 $q$ 及其扰动 $\\delta q$ 以 $\\mathrm{kg}\\,\\mathrm{kg}^{-1}$ 表示，质量吸收系数 $\\kappa_\\nu$ 以 $\\mathrm{m}^2\\,\\mathrm{kg}^{-1}$ 表示，层质量 $M_{\\text{air}}$ 以 $\\mathrm{kg}\\,\\mathrm{m}^{-2}$ 表示，辐射率以 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,(\\mathrm{m}^{-1})^{-1}$ 表示。\n\n测试套件：\n- 用例 1：$q_b = 0.005$, $T_\\ell = 280$, $T_s = 290$, $\\kappa_\\nu = 0.04$, $M_{\\text{air}} = 4000$, $\\varepsilon_s = 0.98$, $\\delta q \\in \\{10^{-6},\\,10^{-5},\\,10^{-4},\\,5\\times 10^{-4}\\}$。\n- 用例 2：$q_b = 0.015$, $T_\\ell = 270$, $T_s = 300$, $\\kappa_\\nu = 0.05$, $M_{\\text{air}} = 4000$, $\\varepsilon_s = 0.98$, $\\delta q \\in \\{10^{-5},\\,10^{-4},\\,10^{-3},\\,2\\times 10^{-3}\\}$。\n- 用例 3：$q_b = 0.020$, $T_\\ell = 295$, $T_s = 305$, $\\kappa_\\nu = 0.06$, $M_{\\text{air}} = 5000$, $\\varepsilon_s = 0.98$, $\\delta q \\in \\{-10^{-4},\\,-5\\times 10^{-4},\\,5\\times 10^{-4},\\,2\\times 10^{-3}\\}$。\n- 用例 4：$q_b = 0.025$, $T_\\ell = 260$, $T_s = 270$, $\\kappa_\\nu = 0.07$, $M_{\\text{air}} = 6000$, $\\varepsilon_s = 0.98$, $\\delta q \\in \\{10^{-3},\\,3\\times 10^{-3},\\,5\\times 10^{-3}\\}$。\n\n数值和输出要求：\n- 对于每个测试用例，计算其 $\\delta q$ 值范围内的最大相对 TL 误差，并四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按四个用例的顺序排列结果，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个四舍五入到 $6$ 位小数的浮点数。", "solution": "该问题是有效的，因为它科学地基于大气辐射传输的既定原理，在数学上是适定的，并且为获得唯一解提供了所有必要的参数和常数。我们着手解决该问题。\n\n解决方案包括两个主要部分：首先，切线性 (TL) 算子 $K$ 的解析推导；其次，为给定测试用例计算相对 TL 误差的数值实现。\n\n**1. 切线性算子的解析推导**\n\n切线性算子 $K$ 定义为观测算子 $H(q)$ 相对于状态变量 $q$ 的一阶导数，在背景状态 $q_b$ 处求值。\n$$K = \\frac{dH}{dq}\\bigg|_{q=q_b}$$\n大气层顶 (TOA) 单色辐射率的观测算子 $H(q)$ 由下式给出：\n$$H(q) = \\varepsilon_s \\, B_{\\tilde{\\nu}}(T_s)\\, \\tau(q) + \\left(1 - \\tau(q)\\right) B_{\\tilde{\\nu}}(T_\\ell)$$\n其中 $\\varepsilon_s$ 是地表发射率， $T_s$ 是地表温度， $T_\\ell$ 是大气层温度， $B_{\\tilde{\\nu}}(T)$ 是在波数 $\\tilde{\\nu}$ 和温度 $T$ 下的 Planck 辐射率函数。对比湿 $q$ 的依赖完全通过大气层透射率 $\\tau(q)$ 体现。\n\n为了求导清晰，我们可以重排 $H(q)$ 的表达式：\n$$H(q) = \\tau(q) \\left[ \\varepsilon_s B_{\\tilde{\\nu}}(T_s) - B_{\\tilde{\\nu}}(T_\\ell) \\right] + B_{\\tilde{\\nu}}(T_\\ell)$$\nPlanck 函数值 $B_{\\tilde{\\nu}}(T_s)$ 和 $B_{\\tilde{\\nu}}(T_\\ell)$ 相对于 $q$ 是常数。我们应用链式法则对 $H(q)$ 关于 $q$ 求导：\n$$\\frac{dH}{dq} = \\frac{d}{dq} \\left( \\tau(q) \\left[ \\varepsilon_s B_{\\tilde{\\nu}}(T_s) - B_{\\tilde{\\nu}}(T_\\ell) \\right] + B_{\\tilde{\\nu}}(T_\\ell) \\right)$$\n$$\\frac{dH}{dq} = \\left[ \\varepsilon_s B_{\\tilde{\\nu}}(T_s) - B_{\\tilde{\\nu}}(T_\\ell) \\right] \\frac{d\\tau}{dq}$$\n接下来，我们求透射率 $\\tau(q)$ 的导数，它由 Beer-Lambert law 定义：\n$$\\tau(q) = \\exp\\left(- \\kappa_\\nu \\, q \\, M_{\\text{air}}\\right)$$\n其中 $\\kappa_\\nu$ 是质量吸收系数，$M_{\\text{air}}$ 是单位面积的层内空气质量。对 $\\tau(q)$ 关于 $q$ 求导：\n$$\\frac{d\\tau}{dq} = \\frac{d}{dq} \\exp\\left(- \\kappa_\\nu \\, q \\, M_{\\text{air}}\\right)$$\n使用指数函数的链式法则，其中指数的参数是 $q$ 的线性函数：\n$$\\frac{d\\tau}{dq} = \\exp\\left(- \\kappa_\\nu \\, q \\, M_{\\text{air}}\\right) \\cdot \\frac{d}{dq}\\left(- \\kappa_\\nu \\, q \\, M_{\\text{air}}\\right)$$\n$$\\frac{d\\tau}{dq} = \\tau(q) \\cdot (-\\kappa_\\nu M_{\\text{air}})$$\n将此结果代回 $\\frac{dH}{dq}$ 的表达式中：\n$$\\frac{dH}{dq} = \\left[ \\varepsilon_s B_{\\tilde{\\nu}}(T_s) - B_{\\tilde{\\nu}}(T_\\ell) \\right] \\cdot \\left[ -\\kappa_\\nu M_{\\text{air}} \\tau(q) \\right]$$\n这个表达式可以重排为：\n$$\\frac{dH}{dq} = \\kappa_\\nu M_{\\text{air}} \\, \\tau(q) \\, \\left[ B_{\\tilde{\\nu}}(T_\\ell) - \\varepsilon_s B_{\\tilde{\\nu}}(T_s) \\right]$$\n切线性算子 $K$ 是在背景比湿 $q_b$ 处求值的该导数：\n$$K = \\frac{dH}{dq}\\bigg|_{q=q_b} = \\kappa_\\nu M_{\\text{air}} \\, \\tau(q_b) \\, \\left[ B_{\\tilde{\\nu}}(T_\\ell) - \\varepsilon_s B_{\\tilde{\\nu}}(T_s) \\right]$$\n其中 $\\tau(q_b) = \\exp\\left(- \\kappa_\\nu \\, q_b \\, M_{\\text{air}}\\right)$。这是 $K$ 的最终解析表达式。\n\n**2. 数值计算的算法流程**\n\n对于每个测试用例，我们在扰动列表 $\\{\\delta q_i\\}$ 上计算最大相对切线性误差 $\\mathcal{E}_{\\text{rel}}(\\delta q)$。相对误差定义为：\n$$\\mathcal{E}_{\\text{rel}}(\\delta q) = \\frac{\\left|H(q_b+\\delta q) - H(q_b) - K\\,\\delta q\\right|}{\\left|H(q_b+\\delta q) - H(q_b)\\right|}$$\n算法流程如下：\n1.  设置物理常数：$h = 6.62607015\\times 10^{-34}\\ \\mathrm{J}\\,\\mathrm{s}$，$c = 2.99792458\\times 10^{8}\\ \\mathrm{m}\\,\\mathrm{s}^{-1}$，$k_B = 1.380649\\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$，以及波数 $\\tilde{\\nu} = 100000\\ \\mathrm{m}^{-1}$。\n2.  对于每个具有特定参数集（$q_b, T_\\ell, T_s, \\kappa_\\nu, M_{\\text{air}}, \\varepsilon_s$）和扰动列表 $\\{\\delta q_i\\}$ 的测试用例：\n    a.  使用 Planck 函数公式计算层的 Planck 辐射率 $B_\\ell = B_{\\tilde{\\nu}}(T_\\ell)$ 和地表的 Planck 辐射率 $B_s = B_{\\tilde{\\nu}}(T_s)$：\n        $$B_{\\tilde{\\nu}}(T) = \\frac{2 h c^2 \\tilde{\\nu}^3}{\\exp\\!\\left(\\frac{h c \\tilde{\\nu}}{k_B T}\\right) - 1}$$\n    b.  使用观测算子公式计算背景辐射率 $H_b = H(q_b)$。\n    c.  使用在 $q_b$ 处求值的推导出的解析公式计算切线性算子 $K$。\n    d.  初始化一个空列表以存储当前用例的误差。\n    e.  对于列表 $\\{\\delta q_i\\}$ 中的每个扰动 $\\delta q$：\n        i.  计算扰动状态 $q_p = q_b + \\delta q$。\n        ii. 计算真实的扰动辐射率 $H_p = H(q_p)$。\n        iii. 计算误差项的分子：$N = |H_p - H_b - K \\cdot \\delta q|$。\n        iv. 计算误差项的分母：$D = |H_p - H_b|$。\n        v. 如果 $D$ 为零，则相对误差 $\\mathcal{E}_{\\text{rel}}(\\delta q)$ 为 $0$。否则，计算误差为 $\\mathcal{E}_{\\text{rel}}(\\delta q) = N / D$。\n        vi. 将计算出的误差附加到列表中。\n    f.  从计算出的误差列表中确定最大值。\n    g.  将此最大误差四舍五入到 $6$ 位小数，并将其记录为该测试用例的结果。\n3.  将所有测试用例的结果合并到一个列表中，并按要求格式化输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem by calculating the maximum relative \n    Tangent-Linear error for a set of test cases in satellite radiance assimilation.\n    \"\"\"\n\n    # Physical constants\n    H = 6.62607015e-34    # Planck's constant in J.s\n    C = 2.99792458e8      # Speed of light in m/s\n    KB = 1.380649e-23     # Boltzmann's constant in J/K\n    NU_TILDE = 100000.    # Wavenumber in m^-1 (from 1000 cm^-1)\n\n    # Pre-calculate constant parts of the Planck function for efficiency\n    C1 = 2 * H * C**2 * NU_TILDE**3\n    C2 = H * C * NU_TILDE / KB\n\n    def planck(T):\n        \"\"\"\n        Calculates the spectral radiance using Planck's law.\n        :param T: Temperature in Kelvin.\n        :return: Spectral radiance in W m^-2 sr^-1 (m^-1)^-1.\n        \"\"\"\n        # The argument to exp can be large, but temperatures are reasonable.\n        return C1 / (np.exp(C2 / T) - 1)\n\n    def transmittance(q, kappa_nu, M_air):\n        \"\"\"\n        Calculates the layer transmittance using the Beer-Lambert law.\n        :param q: Specific humidity in kg/kg.\n        :param kappa_nu: Mass absorption coefficient in m^2/kg.\n        :param M_air: Layer air mass per unit area in kg/m^2.\n        :return: Transmittance (dimensionless).\n        \"\"\"\n        optical_depth = kappa_nu * q * M_air\n        return np.exp(-optical_depth)\n\n    def H_operator(q, B_ell, B_s, kappa_nu, M_air, eps_s):\n        \"\"\"\n        The observation operator H(q).\n        :param q: Specific humidity in kg/kg.\n        :param B_ell: Pre-calculated layer Planck radiance.\n        :param B_s: Pre-calculated surface Planck radiance.\n        :param kappa_nu, M_air, eps_s: Other physical parameters.\n        :return: Top Of Atmosphere (TOA) radiance.\n        \"\"\"\n        tau = transmittance(q, kappa_nu, M_air)\n        return eps_s * B_s * tau + (1 - tau) * B_ell\n\n    def K_operator(q_b, B_ell, B_s, kappa_nu, M_air, eps_s):\n        \"\"\"\n        The Tangent-Linear operator K = dH/dq at q_b.\n        :param q_b: Background specific humidity.\n        :param B_ell, B_s: Pre-calculated Planck radiances.\n        :param kappa_nu, M_air, eps_s: Other physical parameters.\n        :return: Value of the Tangent-Linear operator K.\n        \"\"\"\n        tau_b = transmittance(q_b, kappa_nu, M_air)\n        # B_diff = eps_s * B_s - B_ell\n        # dtau_dq = -kappa_nu * M_air * tau_b\n        # return B_diff * dtau_dq\n        # Alternative form from derivation:\n        return kappa_nu * M_air * tau_b * (B_ell - eps_s * B_s)\n\n    def calculate_max_error(params):\n        \"\"\"\n        Calculates the maximum relative TL error for a single test case.\n        :param params: A tuple containing all parameters for the case.\n        :return: The maximum relative error, rounded to 6 decimal places.\n        \"\"\"\n        q_b, T_ell, T_s, kappa_nu, M_air, eps_s, delta_q_list = params\n        \n        # Pre-calculate Planck radiances for the case\n        B_ell = planck(T_ell)\n        B_s = planck(T_s)\n        \n        # Calculate H for background state and the K operator\n        H_b = H_operator(q_b, B_ell, B_s, kappa_nu, M_air, eps_s)\n        K = K_operator(q_b, B_ell, B_s, kappa_nu, M_air, eps_s)\n        \n        errors = []\n        for delta_q in delta_q_list:\n            q_p = q_b + delta_q  # Perturbed state\n            \n            # Full non-linear model for perturbed state\n            H_p = H_operator(q_p, B_ell, B_s, kappa_nu, M_air, eps_s)\n            \n            # Numerator of the relative error formula: |H_p - (H_b + K*dq)|\n            numerator = abs(H_p - H_b - K * delta_q)\n            \n            # Denominator of the relative error formula: |H_p - H_b|\n            denominator = abs(H_p - H_b)\n            \n            if denominator == 0.0:\n                # Per problem spec, if denominator is 0, error is 0.\n                rel_error = 0.0\n            else:\n                rel_error = numerator / denominator\n            \n            errors.append(rel_error)\n            \n        max_error = max(errors) if errors else 0.0\n        return round(max_error, 6)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (q_b, T_ell, T_s, kappa_nu, M_air, eps_s, [delta_q values])\n        (0.005, 280, 290, 0.04, 4000, 0.98, [1e-6, 1e-5, 1e-4, 5e-4]),\n        (0.015, 270, 300, 0.05, 4000, 0.98, [1e-5, 1e-4, 1e-3, 2e-3]),\n        (0.020, 295, 305, 0.06, 5000, 0.98, [-1e-4, -5e-4, 5e-4, 2e-3]),\n        (0.025, 260, 270, 0.07, 6000, 0.98, [1e-3, 3e-3, 5e-3]),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_max_error(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3365135"}, {"introduction": "在获得观测算子的线性近似后，同化过程的核心在于如何最优地融合观测信息与背景场，而卡尔曼增益矩阵 $K_a$ 正是决定这一融合权重的关键。本练习将引导您探索观测误差协方差矩阵 $R$ 的结构对分析的影响，特别是通道间误差相关性的作用[@problem_id:3365144]。通过比较对角型 $R$ (误差不相关) 和更真实的非对角型 $R$ (误差相关) 所产生的分析增益，您将揭示误差相关性如何重新分配不同通道的观测信息权重，这是提高卫星资料同化效果的一个核心议题。", "problem": "考虑一个贝叶斯线性高斯设定下的线性化卫星辐射率同化问题。未知状态向量 $x \\in \\mathbb{R}^n$ 代表四个分层的温度（单位：开尔文）。观测向量 $y \\in \\mathbb{R}^m$ 代表由卫星仪器测量的五个红外亮度温度通道（单位：开尔文）。观测算子 $H \\in \\mathbb{R}^{m \\times n}$ 是从状态到辐射率的辐射传输映射的雅可比矩阵，假定在背景场附近是线性的。背景误差协方差 $B \\in \\mathbb{R}^{n \\times n}$ 是对称正定的，观测误差协方差 $R \\in \\mathbb{R}^{m \\times m}$ 也是对称正定的。\n\n基本原理：\n- 先验分布为高斯分布，$x \\sim \\mathcal{N}(x_b, B)$，其中 $x_b$ 是背景状态。\n- 观测模型为 $y = H x + \\varepsilon$，其中 $\\varepsilon \\sim \\mathcal{N}(0, R)$。\n- 后验分布通过应用贝叶斯法则获得，从而得到线性高斯分析，其最优线性估计器在给定协方差下最小化二次贝叶斯代价函数。\n- 在线性高斯情况下，卡尔曼滤波器（KF）是结合 $B$、$H$ 和 $R$ 形成分析更新的标准框架。\n\n您必须在纯数学公式下进行操作，不使用外部数据。所有状态和观测量均以开尔文为单位，以确保卡尔曼增益是无量纲的（开尔文/开尔文）。不使用角度。不需要百分比。\n\n设置：\n- 维度：$n = 4$（状态）和 $m = 5$（通道）。\n- 观测算子 $H$（无量纲灵敏度，开尔文/开尔文）：\n$$\nH = \\begin{bmatrix}\n0.6  0.3  0.1  0.0 \\\\\n0.2  0.5  0.3  0.0 \\\\\n0.1  0.2  0.5  0.2 \\\\\n0.0  0.1  0.4  0.5 \\\\\n0.0  0.0  0.3  0.7\n\\end{bmatrix}.\n$$\n- 背景误差协方差 $B$（单位：开尔文$^2$），由物理上合理的相邻层间指数衰减相关性构建：\n    - 层标准差 $s = [1.0, 0.9, 0.7, 0.6]$（单位：开尔文）。\n    - 背景相关参数 $r_b = 0.6$。\n    - 相关矩阵 $C^{(n)} \\in \\mathbb{R}^{n \\times n}$，其元素为 $C^{(n)}_{ij} = r_b^{|i-j|}$。\n    - 则 $B_{ij} = s_i s_j C^{(n)}_{ij}$。\n- 观测误差协方差 $R$ 依赖于每个通道的标准差 $\\sigma_i$（单位：开尔文）和通过托普利兹（Toeplitz）结构表示的通道间相关参数 $\\rho$：\n    - 相关矩阵 $C^{(m)} \\in \\mathbb{R}^{m \\times m}$，其元素为 $C^{(m)}_{ij} = \\rho^{|i-j|}$。\n    - 对于对角（不相关）误差，设置 $\\rho = 0$，此时 $C^{(m)}$ 成为单位矩阵，且 $R = \\mathrm{diag}(\\sigma_1^2, \\dots, \\sigma_m^2)$。\n    - 对于相关误差，使用托普利兹（Toeplitz）结构 $R_{ij} = \\sigma_i \\sigma_j C^{(m)}_{ij} = \\sigma_i \\sigma_j \\rho^{|i-j|}$。\n\n任务：\n1. 从线性高斯贝叶斯公式和代价最小化原理出发，推导分析增益矩阵 $K_a \\in \\mathbb{R}^{n \\times m}$（用 $B$、$H$ 和 $R$ 表示）。实现对角矩阵 $R$（$\\rho=0$）和相关托普利兹矩阵 $R$（指定 $\\rho$）两种情况下 $K_a$ 的数值稳定计算。\n2. 将通道 $i$ 的通道影响分数定义为 $K_a$ 第 $i$ 列的欧几里得范数，即 $s_i = \\lVert K_a[:, i] \\rVert_2$。使用从零开始的通道索引，通过按 $s_i$ 降序对通道进行排序来确定通道影响排名，若分数相同则按通道索引升序排列。\n3. 通过弗罗贝尼乌斯（Frobenius）范数差 $\\Delta = \\lVert K_a^{(\\mathrm{toeplitz})} - K_a^{(\\mathrm{diag})} \\rVert_F$ 来量化通道间相关性的影响，在开尔文单位设定下，该范数差是无量纲的。\n\n测试套件：\n对于每组参数，使用与上述相同的 $H$ 和 $B$，并使用给定的 $\\sigma$ 和 $\\rho$ 值构造 $R$。\n\n- 情况 A (理想情况): $\\sigma = [0.5, 0.6, 0.4, 0.7, 0.5]$ 开尔文, $\\rho = 0.5$。\n- 情况 B (边界情况，无相关性): $\\sigma = [0.5, 0.6, 0.4, 0.7, 0.5]$ 开尔文, $\\rho = 0.0$。\n- 情况 C (边缘情况，强正相关): $\\sigma = [0.8, 0.8, 0.8, 0.8, 0.8]$ 开尔文, $\\rho = 0.9$。\n- 情况 D (边缘情况，负相关): $\\sigma = [0.5, 0.7, 0.9, 0.7, 0.5]$ 开尔文, $\\rho = -0.3$。\n\n程序要求：\n- 对于每个测试用例，计算：\n    1. 使用对角矩阵 $R$（$\\sigma$ 相同但 $\\rho=0$）的 $K_a$ 与使用指定托普利兹矩阵 $R$ 的 $K_a$ 之间的无量纲弗罗贝尼乌斯范数差 $\\Delta$。\n    2. 对角矩阵 $R$ 情况下的通道排名列表（以从零开始的索引表示）。\n    3. 托普利兹矩阵 $R$ 情况下的通道排名列表（以从零开始的索引表示）。\n    4. 每个通道的排名位移列表，其中通道 $i$ 的位移等于其在托普利兹排名中的位置减去其在对角排名中的位置。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是 $[\\Delta, \\text{diag\\_rank}, \\text{toeplitz\\_rank}, \\text{rank\\_shift}]$ 形式的列表，其中 $\\text{diag\\_rank}$、$\\text{toeplitz\\_rank}$ 和 $\\text{rank\\_shift}$ 是整数列表。最终输出必须将四个测试用例的结果聚合到一个外部列表中，例如：\n$[[\\Delta_A,[\\dots],[\\dots],[\\dots]],[\\Delta_B,[\\dots],[\\dots],[\\dots]],[\\Delta_C,[\\dots],[\\dots],[\\dots]],[\\Delta_D,[\\dots],[\\dots],[\\dots]]]$。", "solution": "所提出的问题是线性高斯数据同化的一个典型例子，特别是卡尔曼滤波器的分析步骤。我们的任务是在给定观测向量 $y \\in \\mathbb{R}^m$（代表卫星亮度温度）的情况下，确定状态向量 $x \\in \\mathbb{R}^n$（代表大气层温度）的最优估计。该问题在贝叶斯框架内进行阐述，其中状态的先验知识与来自观测的新信息相结合，以产生更新的（即后验）估计。\n\n基本组成部分包括：\n1.  状态的先验分布，$x \\sim \\mathcal{N}(x_b, B)$，其中 $x_b$ 是背景（先验均值）状态，$B \\in \\mathbb{R}^{n \\times n}$ 是背景误差协方差矩阵。\n2.  线性观测模型，$y = Hx + \\varepsilon$，其中 $H \\in \\mathbb{R}^{m \\times n}$ 是观测算子（或正向模型），观测误差 $\\varepsilon$ 来自零均值高斯分布 $\\varepsilon \\sim \\mathcal{N}(0, R)$，$R \\in \\mathbb{R}^{m \\times m}$ 是观测误差协方差矩阵。\n\n目标是找到使后验概率密度最大化的分析状态 $x_a$，在高斯情况下，这等同于最小化二次代价函数 $J(x)$。该代价函数衡量候选状态 $x$ 与背景信息和观测值之间的失配度，并由它们各自的误差协方差加权。\n\n代价函数 $J(x)$ 是背景项 $J_b(x)$ 和观测项 $J_o(x)$ 的和：\n$$ J(x) = J_b(x) + J_o(x) = \\frac{1}{2}(x - x_b)^T B^{-1} (x - x_b) + \\frac{1}{2}(y - Hx)^T R^{-1} (y - Hx) $$\n为了找到最小化 $J(x)$ 的分析状态 $x_a$，我们计算 $J(x)$ 对 $x$ 的梯度并将其设为零。梯度为：\n$$ \\nabla_x J(x) = B^{-1}(x - x_b) - H^T R^{-1}(y - Hx) $$\n对最优状态 $x_a$ 设 $\\nabla_x J(x_a) = 0$ 可得：\n$$ B^{-1}(x_a - x_b) - H^T R^{-1}(y - Hx_a) = 0 $$\n重新整理各项以求解 $x_a$：\n$$ (B^{-1} + H^T R^{-1}H)x_a = B^{-1}x_b + H^T R^{-1}y $$\n这导出了分析状态的逆形式解：\n$$ x_a = (B^{-1} + H^T R^{-1}H)^{-1} (B^{-1}x_b + H^T R^{-1}y) $$\n虽然这种形式是正确的，但它通常不适合数值计算，因为它可能需要多次矩阵求逆，包括对通常很大的背景误差协方差矩阵 $B$ 求逆。\n\n一种更常用且数值上更稳定的形式是增益形式，它将分析状态表示为对背景状态的更新：\n$$ x_a = x_b + K_a(y - Hx_b) $$\n在这里，$K_a \\in \\mathbb{R}^{n \\times m}$ 是分析增益矩阵，通常称为卡尔曼增益。项 $(y - Hx_b)$ 是新息（innovation）或离差（departure），代表由观测提供的新信息。增益矩阵 $K_a$ 将这些新信息最优地分配到状态向量的各个分量上。\n\n为了推导 $K_a$ 的表达式，我们将 $x_a$ 的两种形式相等。通过比较 $y$ 的系数，我们可以确定 $K_a$ 的表达式。从逆形式解中，乘以 $y$ 的项是 $(B^{-1} + H^T R^{-1}H)^{-1} H^T R^{-1}$。因此，\n$$ K_a = (B^{-1} + H^T R^{-1}H)^{-1} H^T R^{-1} $$\n应用 Woodbury 矩阵恒等式 $(A+UCV)^{-1} = A^{-1} - A^{-1}U(C^{-1}+VA^{-1}U)^{-1}VA^{-1}$，其中 $A=B^{-1}$、$U=H^T$、$C=R^{-1}$ 且 $V=H$，我们可以变换项 $(B^{-1} + H^T R^{-1}H)^{-1}$ 来获得一个更稳定的 $K_a$ 表达式：\n$$ K_a = [B - BH^T(R+HBH^T)^{-1}HB] H^T R^{-1} $$\n$$ K_a = BH^T R^{-1} - BH^T(R+HBH^T)^{-1}HBH^T R^{-1} $$\n$$ K_a = BH^T (R+HBH^T)^{-1} [ (R+HBH^T) - HBH^T ] R^{-1} $$\n$$ K_a = BH^T (R+HBH^T)^{-1} R R^{-1} $$\n这一简化得出了卡尔曼增益的标准且数值计算上更优的表达式：\n$$ K_a = B H^T (R + H B H^T)^{-1} $$\n这个公式的优点在于它需要对矩阵 $(R + H B H^T)$ 求逆，该矩阵的维度是 $m \\times m$。在许多实际应用中，观测数量 $m$ 远小于状态变量数量 $n$，这使得求逆的计算成本更低。在我们的例子中，$n=4$ 和 $m=5$，维度相当，但这种形式避免了对 $B$ 和 $R$ 的直接求逆。\n\n解决该问题的算法步骤如下：\n1.  **构造协方差矩阵**：\n    -   背景误差协方差 $B$ 构造为 $B_{ij} = s_i s_j r_b^{|i-j|}$，其中 $s$ 是层标准差向量，$r_b$ 是背景相关参数。\n    -   观测误差协方差 $R$ 构造为 $R_{ij} = \\sigma_i \\sigma_j \\rho^{|i-j|}$，其中 $\\sigma$ 是通道标准差向量，$\\rho$ 是通道间相关参数。对于对角情况，我们设置 $\\rho=0$。\n2.  **计算增益矩阵**：对于每个测试用例，我们计算两个增益矩阵：使用指定 $\\rho$ 的 $K_a^{(\\mathrm{toeplitz})}$ 和使用相同 $\\sigma$ 但 $\\rho=0$ 的 $K_a^{(\\mathrm{diag})}$。计算遵循推导出的公式 $K_a = B H^T (R + H B H^T)^{-1}$。\n3.  **计算通道影响和排名**：观测通道 $i$ 的影响通过增益矩阵第 $i$ 列的欧几里得范数来量化，$s_i = \\lVert K_a[:, i] \\rVert_2$。然后根据其影响分数 $s_i$ 对通道进行降序排名，分数相同时按通道索引升序排列。这对 $K_a^{(\\mathrm{toeplitz})}$ 和 $K_a^{(\\mathrm{diag})}$ 都需要进行。\n4.  **量化相关性效应**：\n    -   由于相关性引起的增益矩阵总体变化通过弗罗贝尼乌斯范数差来衡量：$\\Delta = \\lVert K_a^{(\\mathrm{toeplitz})} - K_a^{(\\mathrm{diag})} \\rVert_F$。\n    -   每个通道的排名位移计算为其在托普利兹-R 排名中的位置与在对角-R 排名中的位置之差。\n\n指定的单位（温度和标准差用开尔文）确保雅可比矩阵 $H$ 和最终的增益矩阵 $K_a$ 是无量纲的，因为 $[K_a] = [B][H^T][(R + H B H^T)^{-1}] = \\text{K}^2 \\cdot (\\text{K}/\\text{K}) \\cdot (\\text{K}^2)^{-1} = \\text{无量纲}$。因此，影响分数 $s_i$ 和范数差 $\\Delta$ 也是无量纲的。\n实现将通过系统地对提供的四个测试用例应用这些步骤来完成。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import toeplitz\n\ndef solve():\n    \"\"\"\n    Solves the satellite radiance assimilation problem for the given test cases.\n    \"\"\"\n    \n    # --- Givens (fixed for all cases) ---\n    # State dimension n=4, observation dimension m=5\n    n = 4\n    m = 5\n    \n    # Observation operator H\n    H = np.array([\n        [0.6, 0.3, 0.1, 0.0],\n        [0.2, 0.5, 0.3, 0.0],\n        [0.1, 0.2, 0.5, 0.2],\n        [0.0, 0.1, 0.4, 0.5],\n        [0.0, 0.0, 0.3, 0.7]\n    ])\n\n    # Background error covariance B parameters\n    s_b = np.array([1.0, 0.9, 0.7, 0.6])\n    r_b = 0.6\n\n    # Test suite parameters\n    test_cases = [\n        # Case A\n        {'sigma': np.array([0.5, 0.6, 0.4, 0.7, 0.5]), 'rho': 0.5},\n        # Case B\n        {'sigma': np.array([0.5, 0.6, 0.4, 0.7, 0.5]), 'rho': 0.0},\n        # Case C\n        {'sigma': np.array([0.8, 0.8, 0.8, 0.8, 0.8]), 'rho': 0.9},\n        # Case D\n        {'sigma': np.array([0.5, 0.7, 0.9, 0.7, 0.5]), 'rho': -0.3}\n    ]\n\n    # --- Helper Functions ---\n    def build_B(s_dev, corr_param):\n        \"\"\"Constructs the background error covariance matrix B.\"\"\"\n        dim = len(s_dev)\n        corr_col = np.power(corr_param, np.arange(dim))\n        C = toeplitz(corr_col)\n        D = np.diag(s_dev)\n        B_matrix = D @ C @ D\n        return B_matrix\n\n    def build_R(s_dev, corr_param):\n        \"\"\"Constructs the observation error covariance matrix R.\"\"\"\n        dim = len(s_dev)\n        # Handle the case rho=0 for diagonal R\n        if corr_param == 0.0:\n            return np.diag(s_dev**2)\n        \n        corr_col = np.power(corr_param, np.arange(dim))\n        C = toeplitz(corr_col)\n        D = np.diag(s_dev)\n        R_matrix = D @ C @ D\n        return R_matrix\n\n    def compute_kalman_gain(H_op, B_cov, R_cov):\n        \"\"\"Computes the Kalman gain K_a using the numerically stable formula.\"\"\"\n        H_T = H_op.T\n        S = R_cov + H_op @ B_cov @ H_T  # Innovation covariance\n        S_inv = np.linalg.inv(S)\n        K = B_cov @ H_T @ S_inv\n        return K\n\n    def compute_channel_ranking(K_gain):\n        \"\"\"Computes channel impact scores and returns the ranked channel indices.\"\"\"\n        num_channels = K_gain.shape[1]\n        # Calculate impact score (Euclidean norm of each column)\n        impact_scores = [np.linalg.norm(K_gain[:, i]) for i in range(num_channels)]\n        \n        # Create pairs of (score, channel_index) for sorting\n        # Tie-breaking: ascending channel index\n        score_index_pairs = list(zip(impact_scores, range(num_channels)))\n        \n        # Sort by score descending (-score ascending), then by index ascending\n        score_index_pairs.sort(key=lambda x: (-x[0], x[1]))\n        \n        # Extract the ranked channel indices\n        ranked_indices = [index for score, index in score_index_pairs]\n        return ranked_indices\n    \n    # --- Main Calculation Loop ---\n    \n    # B is constant across test cases\n    B = build_B(s_b, r_b)\n    \n    all_results = []\n    \n    for case in test_cases:\n        sigma_o = case['sigma']\n        rho_o = case['rho']\n        \n        # 1. Compute R for Toeplitz and Diagonal cases\n        R_toeplitz = build_R(sigma_o, rho_o)\n        R_diag = build_R(sigma_o, 0.0) # rho=0 gives diagonal R\n        \n        # 2. Compute gain matrices\n        K_toeplitz = compute_kalman_gain(H, B, R_toeplitz)\n        K_diag = compute_kalman_gain(H, B, R_diag)\n        \n        # 3. Compute Frobenius norm difference\n        delta = np.linalg.norm(K_toeplitz - K_diag, 'fro')\n        \n        # 4. Compute channel rankings\n        diag_rank = compute_channel_ranking(K_diag)\n        toeplitz_rank = compute_channel_ranking(K_toeplitz)\n        \n        # 5. Compute rank shifts\n        # Create maps from channel index to rank position\n        diag_pos_map = {channel: pos for pos, channel in enumerate(diag_rank)}\n        toeplitz_pos_map = {channel: pos for pos, channel in enumerate(toeplitz_rank)}\n        \n        rank_shift = [toeplitz_pos_map[i] - diag_pos_map[i] for i in range(m)]\n        \n        # 6. Aggregate results for the current case\n        case_result = [delta, diag_rank, toeplitz_rank, rank_shift]\n        all_results.append(case_result)\n\n    # --- Format and Print Final Output ---\n    # The output format must exactly match the problem statement, including no spaces after commas.\n    result_strings = []\n    for res in all_results:\n        # Convert each result item to string representation and remove spaces\n        res_str = str(res).replace(\" \", \"\")\n        result_strings.append(res_str)\n        \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3365144"}, {"introduction": "我们已经探讨了观测算子 $H$ 和观测误差 $R$ 的作用，现在我们转向资料同化的最后一个关键要素：背景误差协方差矩阵 $B$。$B$ 矩阵编码了我们对大气真实状态结构和尺度的先验知识，并控制着观测信息如何在空间上传播[@problem_id:3365149]。在本练习中，您将使用一个强大的诊断工具——平均核矩阵 $A$ (averaging kernel)——来量化不同 $B$ 矩阵模型（如指数核与Matérn核）对分析垂直分辨率的影响。这使得您能够定量评估同化系统的性能，并深刻理解背景误差协方差在信息重构中的根本作用。", "problem": "考虑一个一维垂直气柱状态向量 $x \\in \\mathbb{R}^n$，表示在离散高度上大气温度扰动，单位为开尔文 (K)。红外卫星辐射观测在一个背景态附近进行线性化，其关系式为 $y = K x + \\varepsilon$，其中 $y \\in \\mathbb{R}^m$ 是通道亮度温度扰动，单位为开尔文 (K)；$K \\in \\mathbb{R}^{m \\times n}$ 是观测算子的雅可比矩阵（也称为权重函数）；$\\varepsilon \\sim \\mathcal{N}(0, R)$ 是观测误差，其协方差为 $R \\in \\mathbb{R}^{m \\times m}$，单位为 $\\text{K}^2$。背景误差 $e_b = x - x_b$ 满足 $e_b \\sim \\mathcal{N}(0, B)$，其协方差为 $B \\in \\mathbb{R}^{n \\times n}$，单位为 $\\text{K}^2$。\n\n从基本的线性高斯数据同化原理和高斯假设下的最小方差线性估计器出发，推导平均核矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的表达式。该矩阵将真实状态 $x$ 映射到分析场 $x_a$，并编码了分析场的垂直分辨率。你的推导必须从高斯先验和线性观测模型的条件开始，并逻辑地推导出分析算子及其对真实状态的敏感度。未经证明，不得使用任何捷径恒等式。\n\n然后，实现一个数值实验，比较不同的垂直背景协方差结构 $B$ 如何影响从 $A$ 推断出的分析场的垂直分辨率。使用符合以下规范的、科学上一致的离散化和通道配置。\n\n- 垂直网格：\n    - 令 $z_i$ 为高度，单位为公里 (km)，其中 $i = 0, 1, \\dots, n-1$。共 $n = 31$ 个点，从 $z_0 = 0\\,\\text{km}$ 到 $z_{30} = 15\\,\\text{km}$ 均匀分布。\n    - 定义 $\\Delta z = 0.5\\,\\text{km}$。\n\n- 红外观测权重函数（$K$ 的行）：\n    - 使用 $m = 6$ 个通道，其中心高度为 $z_{c,j} \\in \\{1, 3, 5, 7, 9, 12\\}\\,\\text{km}$，其中 $j = 1, \\dots, 6$。\n    - 对每个通道 $j$，定义一个高斯权重函数 $w_j(z) = \\exp\\left(-\\frac{(z - z_{c,j})^2}{2 \\sigma_w^2}\\right)$，其中 $\\sigma_w = 0.8\\,\\text{km}$。\n    - 通过 $K_{j,i} = \\frac{w_j(z_i)\\,\\Delta z}{\\sum_{p=0}^{n-1} w_j(z_p)\\,\\Delta z}$ 来离散化 $K$，使得每个通道在整层气柱上的积分为1。在此归一化下，$K$ 是无量纲的。\n\n- 背景协方差 $B$ 的选择：\n    - 指数核（也称为平滑度 $\\nu = \\tfrac{1}{2}$ 的 Matérn 核）：对于相关长度 $L_z$（单位公里）和方差 $\\sigma_b^2$（单位 $\\text{K}^2$），定义 $B_{ij} = \\sigma_b^2 \\exp\\left(-\\frac{|z_i - z_j|}{L_z}\\right)$。\n    - Matérn 核，平滑度 $\\nu > 0$，相关长度 $L_z$（单位公里），方差 $\\sigma_b^2$（单位 $\\text{K}^2$）：对于 $i \\neq j$，\n      $$B_{ij} = \\sigma_b^2 \\frac{2^{1-\\nu}}{\\Gamma(\\nu)} \\left(\\frac{\\sqrt{2\\nu}\\,|z_i - z_j|}{L_z}\\right)^\\nu K_\\nu\\left(\\frac{\\sqrt{2\\nu}\\,|z_i - z_j|}{L_z}\\right),$$\n      其中 $\\Gamma(\\cdot)$ 是伽马函数，$K_\\nu(\\cdot)$ 是第二类修正贝塞尔函数。对所有 $i$，设置 $B_{ii} = \\sigma_b^2$。\n\n- 观测误差协方差 $R$：\n    - 使用对角阵 $R = \\operatorname{diag}(\\sigma_{y}^2, \\dots, \\sigma_{y}^2)$，单位为 $\\text{K}^2$。\n\n根据推导出的 $A$，在每个高度层 $z_i$ 定义一个定量的垂直分辨率度量，如下所示。令 $a_i$ 为 $A$ 的第 $i$ 行。通过对 $a_i$ 的绝对值进行归一化来计算权重 $u_i$，\n$$u_{i,p} = \\frac{|a_{i,p}|}{\\sum_{q=0}^{n-1} |a_{i,q}|}, \\quad p = 0, \\dots, n-1.$$\n定义质心 $\\bar{z}_i = \\sum_{p=0}^{n-1} u_{i,p} z_p$ 和二阶中心矩 $M_i = \\sum_{p=0}^{n-1} u_{i,p} (z_p - \\bar{z}_i)^2$。在高度层 $z_i$ 的有效垂直分辨率宽度为 $W_i = 2 \\sqrt{M_i}$，单位为公里。为保证数值稳定性，将满足 $\\sum_{p=0}^{n-1} |a_{i,p}| \\le 10^{-12}$ 的高度层从汇总统计中排除；如果在某个测试案例中所有高度层都被排除，则返回总网格跨度 $z_{30} - z_0$ 作为该案例的分辨率度量。通过计算所有被包括的高度层上 $\\{W_i\\}$ 的中位数，为每个实验聚合一个单一的分辨率度量，单位为公里。\n\n构建以下参数集测试套件，以探究问题的不同方面：\n- 案例1（基准指数型）：指数型 $B$，其中 $L_z = 1.5\\,\\text{km}$，$\\sigma_b^2 = 1.0\\,\\text{K}^2$，以及对角阵 $R$，其中 $\\sigma_y^2 = 0.25\\,\\text{K}^2$。\n- 案例2（短程指数型）：指数型 $B$，其中 $L_z = 0.5\\,\\text{km}$，$\\sigma_b^2 = 1.0\\,\\text{K}^2$，以及对角阵 $R$，其中 $\\sigma_y^2 = 0.25\\,\\text{K}^2$。\n- 案例3（Matérn中等平滑度）：Matérn型 $B$，其中 $\\nu = 1.5$，$L_z = 1.5\\,\\text{km}$，$\\sigma_b^2 = 1.0\\,\\text{K}^2$，以及对角阵 $R$，其中 $\\sigma_y^2 = 0.25\\,\\text{K}^2$。\n- 案例4（Matérn更高平滑度和更长相关性）：Matérn型 $B$，其中 $\\nu = 3.0$，$L_z = 2.0\\,\\text{km}$，$\\sigma_b^2 = 1.0\\,\\text{K}^2$，以及对角阵 $R$，其中 $\\sigma_y^2 = 0.25\\,\\text{K}^2$。\n- 案例5（Matérn大观测误差）：Matérn型 $B$，其中 $\\nu = 1.5$，$L_z = 1.5\\,\\text{km}$，$\\sigma_b^2 = 1.0\\,\\text{K}^2$，以及对角阵 $R$，其中 $\\sigma_y^2 = 4.0\\,\\text{K}^2$。\n\n你的程序必须：\n- 使用 $B$、$K$ 和 $R$ 实现为 $A$ 推导出的公式。\n- 为上述定义的五个案例中的每一个，计算有效垂直分辨率宽度的中位数，单位为公里。\n- 以公里为单位表示最终数值答案，并四舍五入到三位小数。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[w_1,w_2,w_3,w_4,w_5]$），其中每个 $w_k$ 是案例 $k$ 的中位数宽度，单位为公里。\n\n不允许用户输入或外部文件；所有常数和参数均已指定。问题中不涉及角度，因此不需要角度单位。问题中不涉及百分比，因此不需要百分比格式。本问题专注于与卫星红外辐射数据的反问题和数据同化相一致的纯数学和算法推导。", "solution": "出发点是线性高斯数据同化框架，其中状态 $x \\in \\mathbb{R}^n$ 和观测 $y \\in \\mathbb{R}^m$ 满足 $y = K x + \\varepsilon$，且 $\\varepsilon \\sim \\mathcal{N}(0, R)$。背景态 $x_b$ 是一个先验估计，其误差为 $e_b = x - x_b \\sim \\mathcal{N}(0, B)$。在这些假设下，使期望平方估计误差最小化的分析场 $x_a$ 是线性最小方差估计器，它可以通过在高斯联合后验中配方法得到，或者等效地，通过对线性观测算子进行标准卡尔曼滤波分析得到。\n\n分析增量由下式给出\n$$x_a - x_b = G \\left(y - K x_b\\right),$$\n其中增益 $G \\in \\mathbb{R}^{n \\times m}$ 为\n$$G = B K^\\top \\left(K B K^\\top + R\\right)^{-1}.$$\n此表达式通过最小化关于 $x$ 的二次型 $(x - x_b)^\\top B^{-1} (x - x_b) + (y - K x)^\\top R^{-1} (y - K x)$ 得出，这导出了正规方程 $(B^{-1} + K^\\top R^{-1} K) x = B^{-1} x_b + K^\\top R^{-1} y$，并通过代数变换和应用矩阵求逆引理，得到解 $x_a = x_b + G (y - K x_b)$。\n\n分析场 $x_a$ 对真实状态 $x$ 的敏感度由平均核矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 捕捉，该矩阵定义为雅可比矩阵 $\\frac{\\partial x_a}{\\partial x}$。在线性设置 $y = K x + \\varepsilon$ 中，将 $x_a$ 对 $x$ 求导得到\n$$\\frac{\\partial x_a}{\\partial x} = G K.$$\n结合 $G$ 的表达式，平均核为\n$$A = B K^\\top \\left(K B K^\\top + R\\right)^{-1} K.$$\n在所选的 $K$ 的归一化方式下，该矩阵是无量纲的，它编码了分析场中固有的垂直平滑作用：$A$ 的第 $i$ 行给出了真实廓线各分量对 $z_i$ 高度层分析场的贡献权重。\n\n为了量化垂直分辨率，我们需要为每个高度层定义一个标量宽度度量，以反映每个平均核行在其中心附近的集中程度。由于平均核的行可能具有振荡或变号的结构，我们根据其行向量的绝对值构造非负权重以避免抵消：\n- 对于第 $i$ 行 $a_i \\in \\mathbb{R}^n$，定义 $u_{i,p} = \\frac{|a_{i,p}|}{\\sum_{q=0}^{n-1} |a_{i,q}|}$。\n- 质心为 $\\bar{z}_i = \\sum_{p=0}^{n-1} u_{i,p} z_p$。\n- 二阶中心矩为 $M_i = \\sum_{p=0}^{n-1} u_{i,p} (z_p - \\bar{z}_i)^2$。\n- 有效宽度为 $W_i = 2 \\sqrt{M_i}$，单位为公里。因子 $2$ 对应于两倍标准差宽度，这是一个不假设高斯分布但能随分布扩展而变化的稳健度量。\n\n我们将满足 $\\sum_p |a_{i,p}| \\le 10^{-12}$（数值上可忽略的敏感度）的高度层从汇总统计中排除。如果没有剩余的高度层，该度量默认为整个网格跨度 $z_{n-1} - z_0$。\n\n数值构建细节：\n- 垂直网格 $z_i$ 从 $0\\,\\text{km}$到$15\\,\\text{km}$ 均匀分布，有 $n = 31$ 个点，$\\Delta z = 0.5\\,\\text{km}$。\n- 权重函数 $w_j(z)$ 是高斯函数，中心点为 $z_{c,j} \\in \\{1, 3, 5, 7, 9, 12\\}\\,\\text{km}$，展宽为 $\\sigma_w = 0.8\\,\\text{km}$。$K$ 的每一行 $K_{j,\\cdot}$ 通过 $K_{j,i} = \\frac{w_j(z_i)\\,\\Delta z}{\\sum_p w_j(z_p)\\,\\Delta z}$ 进行归一化，使其积分为1。\n- 背景协方差 $B$ 使用指数核 $B_{ij} = \\sigma_b^2 \\exp\\left(-\\frac{|z_i - z_j|}{L_z}\\right)$（平稳、正定）或 Matérn 核\n$$B_{ij} = \\begin{cases}\n\\sigma_b^2,  i = j, \\\\\n\\sigma_b^2 \\dfrac{2^{1-\\nu}}{\\Gamma(\\nu)} \\left(\\dfrac{\\sqrt{2\\nu}\\,|z_i - z_j|}{L_z}\\right)^\\nu K_\\nu\\left(\\dfrac{\\sqrt{2\\nu}\\,|z_i - z_j|}{L_z}\\right),  i \\ne j,\n\\end{cases}$$\n构建，后者在 $\\nu > 0$ 时也是平稳和正定的。对角线元素 $B_{ii}=\\sigma_b^2$ 与零距离处的正确方差（Matérn 极限）相匹配。\n- 观测误差协方差为 $R = \\operatorname{diag}(\\sigma_y^2, \\dots, \\sigma_y^2)$。\n\n每个测试案例的算法步骤：\n1. 在指定的网格上构建 $K$。\n2. 使用所选的核类型和参数 $(\\sigma_b^2, L_z, \\nu)$ 构建 $B$。\n3. 使用 $\\sigma_y^2$ 构建 $R$。\n4. 计算 $S = K B K^\\top + R$，然后求解 $S X = K$ 得到 $X$。\n5. 计算 $A = B K^\\top X$。\n6. 对于每个高度层 $i$，使用绝对值归一化的行权重和二阶中心矩计算 $W_i$；排除敏感度可忽略的高度层。\n7. 报告 $\\{W_i\\}$ 的中位数，单位为公里，四舍五入到三位小数。\n\n定性预期：\n- $B$ 中较大的相关长度 $L_z$ 会展宽背景相关性，通常会增加平均核的宽度，从而降低垂直分辨率（即 $W_i$ 更大）。\n- Matérn 核中较高的平滑度 $\\nu$ 会产生更平滑的相关性，对于相同的 $L_z$，与指数核相比，通常会展宽平均核。\n- 较大的观测误差方差 $\\sigma_y^2$ 会增加对背景的依赖，这往往会展宽 $A$ 并增宽度量值，同样表明分辨率降低。\n\n程序精确地实现了这些计算，并输出单行结果，其中包含五个以逗号分隔的浮点数，单位为公里，每个对应一个测试案例，并用方括号括起来。", "answer": "```python\nimport numpy as np\nfrom scipy.special import kv as besselk, gamma\n\ndef build_vertical_grid(n=31, zmin=0.0, zmax=15.0):\n    z = np.linspace(zmin, zmax, n)\n    dz = z[1] - z[0]\n    return z, dz\n\ndef build_K(z, centers, sigma_w, dz):\n    m = len(centers)\n    n = len(z)\n    K = np.zeros((m, n))\n    for j, zc in enumerate(centers):\n        w = np.exp(-0.5 * ((z - zc) / sigma_w) ** 2)\n        w_int = w * dz\n        s = np.sum(w_int)\n        if s == 0.0:\n            # Avoid division by zero; unlikely with positive Gaussian\n            K[j, :] = 0.0\n        else:\n            K[j, :] = w_int / s\n    return K\n\ndef build_B_exponential(z, sigma_b2, Lz):\n    # Exponential kernel: B_ij = sigma_b2 * exp(-|z_i - z_j| / Lz)\n    D = np.abs(z[:, None] - z[None, :])\n    B = sigma_b2 * np.exp(-D / Lz)\n    return B\n\ndef build_B_matern(z, sigma_b2, Lz, nu):\n    # Matérn kernel:\n    # For i != j:\n    # B_ij = sigma_b2 * (2^(1-nu) / Gamma(nu)) * (sqrt(2nu) h / Lz)^nu * K_nu(sqrt(2nu) h / Lz)\n    # For i == j: B_ii = sigma_b2\n    D = np.abs(z[:, None] - z[None, :])\n    B = np.zeros_like(D)\n    # Diagonal\n    np.fill_diagonal(B, sigma_b2)\n    # Off-diagonal\n    mask = D > 0\n    h = D[mask]\n    arg = np.sqrt(2.0 * nu) * h / Lz\n    const = sigma_b2 * (2.0 ** (1.0 - nu)) / gamma(nu)\n    # besselk(nu, arg) is modified Bessel function of the second kind\n    B[mask] = const * (arg ** nu) * besselk(nu, arg)\n    return B\n\ndef build_R(m, sigma_y2):\n    return np.eye(m) * sigma_y2\n\ndef averaging_kernel(B, K, R):\n    # Compute A = B K^T (K B K^T + R)^{-1} K\n    S = K @ B @ K.T + R\n    # Solve S X = K for X\n    X = np.linalg.solve(S, K)\n    A = B @ K.T @ X\n    return A\n\ndef effective_resolution(A, z, eps=1e-12):\n    widths = []\n    for i in range(A.shape[0]):\n        row = A[i, :]\n        w = np.abs(row)\n        s = np.sum(w)\n        if s = eps:\n            continue\n        wn = w / s\n        zbar = np.sum(wn * z)\n        var = np.sum(wn * (z - zbar) ** 2)\n        width = 2.0 * np.sqrt(var)\n        widths.append(width)\n    if len(widths) == 0:\n        return float(z[-1] - z[0])\n    return float(np.median(np.array(widths)))\n\ndef run_case(case_type, params, z, dz, K):\n    sigma_b2 = params[\"sigma_b2\"]\n    sigma_y2 = params[\"sigma_y2\"]\n    if case_type == \"exp\":\n        Lz = params[\"Lz\"]\n        B = build_B_exponential(z, sigma_b2, Lz)\n    elif case_type == \"matern\":\n        Lz = params[\"Lz\"]\n        nu = params[\"nu\"]\n        B = build_B_matern(z, sigma_b2, Lz, nu)\n    else:\n        raise ValueError(\"Unknown case type\")\n    R = build_R(K.shape[0], sigma_y2)\n    A = averaging_kernel(B, K, R)\n    width = effective_resolution(A, z)\n    return width\n\ndef solve():\n    # Grid and weighting functions setup\n    z, dz = build_vertical_grid(n=31, zmin=0.0, zmax=15.0)\n    centers = [1.0, 3.0, 5.0, 7.0, 9.0, 12.0]\n    sigma_w = 0.8\n    K = build_K(z, centers, sigma_w, dz)\n\n    # Define test cases\n    test_cases = [\n        (\"exp\", {\"Lz\": 1.5, \"sigma_b2\": 1.0, \"sigma_y2\": 0.25}),          # Case 1\n        (\"exp\", {\"Lz\": 0.5, \"sigma_b2\": 1.0, \"sigma_y2\": 0.25}),          # Case 2\n        (\"matern\", {\"Lz\": 1.5, \"nu\": 1.5, \"sigma_b2\": 1.0, \"sigma_y2\": 0.25}),  # Case 3\n        (\"matern\", {\"Lz\": 2.0, \"nu\": 3.0, \"sigma_b2\": 1.0, \"sigma_y2\": 0.25}),  # Case 4\n        (\"matern\", {\"Lz\": 1.5, \"nu\": 1.5, \"sigma_b2\": 1.0, \"sigma_y2\": 4.0}),   # Case 5\n    ]\n\n    results = []\n    for case_type, params in test_cases:\n        width = run_case(case_type, params, z, dz, K)\n        results.append(f\"{width:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3365149"}]}