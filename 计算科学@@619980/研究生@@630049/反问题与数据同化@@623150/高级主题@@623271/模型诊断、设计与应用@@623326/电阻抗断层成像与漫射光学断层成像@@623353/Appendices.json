{"hands_on_practices": [{"introduction": "在解决任何逆问题时，构建精确的正向模型都是第一步。本练习 ( [@problem_id:3378244] ) 提供了为电子阻抗断层扫描 (EIT) 中的完整电极模型 (Complete Electrode Model, CEM) 实施有限元方法 (Finite Element Method, FEM) 的实践经验，该模型是一种广泛使用且物理上真实的模型。通过这个练习，你将为理解控制偏微分方程的数值解法奠定坚实的基础。", "problem": "要求您在二维域上使用分段线性有限元，为电阻抗断层成像 (EIT) 中的完整电极模型 (CEM) 推导、实现和测试全局刚度矩阵的组装。您的推导必须从电导率模型的控制方程和 CEM 边界条件的变分形式开始，并导出单元级贡献的显式公式。您必须在一个可运行的程序中实现该算法，该程序会构建全局矩阵，并针对选定的测试用例验证其特定属性。\n\n物理模型如下。设 $\\Omega \\subset \\mathbb{R}^2$ 是一个边界为 $\\partial \\Omega$ 的多边形域。电势为 $u: \\Omega \\to \\mathbb{R}$，电导率 $\\sigma: \\Omega \\to \\mathbb{R}_+$ 是分段常数，系统在 $\\partial \\Omega$ 上有 $M$ 个电极 $\\{E_m\\}_{m=1}^M$，对应的电极电势为 $\\{U_m\\}_{m=1}^M$。控制方程为稳态传导方程\n$$\n\\nabla \\cdot (\\sigma \\nabla u) = 0 \\quad \\text{in } \\Omega,\n$$\n在每个电极 $E_m$ 上满足完整电极模型 (CEM) 边界条件，\n$$\nu + z_m \\, \\sigma \\, \\partial_n u = U_m \\quad \\text{on } E_m,\n$$\n并在剩余边界 $\\partial \\Omega \\setminus \\cup_m E_m$ 上满足 $\\sigma \\, \\partial_n u = 0$。此处，$z_m > 0$ 表示 $E_m$ 的接触阻抗，$\\partial_n u$ 是法向导数。电极上的电流守恒意味着净电流约束\n$$\n\\int_{E_m} \\sigma \\, \\partial_n u \\, ds = I_m,\n$$\n使用边界条件可将其重写为\n$$\n\\int_{E_m} z_m^{-1}(U_m - u) \\, ds = I_m.\n$$\n在使用分段线性基 $\\{\\phi_i\\}_{i=1}^N$ 的有限元法中，其弱形式导出关于未知节点系数 $u \\in \\mathbb{R}^N$ 和电极电势 $U \\in \\mathbb{R}^M$ 的分块线性系统：\n$$\n\\begin{bmatrix}\nK + \\displaystyle\\sum_{m=1}^M M^{(m)}  -C \\\\\n-C^\\top  D\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\\nU\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\\nI\n\\end{bmatrix},\n$$\n其中\n$$\nK_{ij} = \\int_{\\Omega} \\sigma \\, \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, d\\Omega,\n\\quad\nM^{(m)}_{ij} = \\int_{E_m} z_m^{-1}\\, \\phi_i \\phi_j \\, ds,\n\\quad\nC_{i m} = \\int_{E_m} z_m^{-1}\\, \\phi_i \\, ds,\n\\quad\nD_{m m} = \\int_{E_m} z_m^{-1} \\cdot 1 \\, ds = z_m^{-1} \\, |E_m|.\n$$\n这些公式必须从第一性原理推导并精确实现。全局矩阵是对称的。若不进行规范固定（例如，将一个电极电势设置为参考值），该分块系统会有一个一维零空间，对应于电势的均匀平移，即对于常数 $c$，$u \\mapsto u + c$ 和 $U_m \\mapsto U_m + c$。\n\n您的实现必须：\n- 在单位正方形 $\\Omega = [0,1]\\times[0,1]$ 上构建一个均匀三角网格，使用一个在 $x$ 方向有 $n_x$ 个细分、在 $y$ 方向有 $n_y$ 个细分的结构化网格，并将每个矩形单元分割成两个三角形。\n- 使用线性三角形的精确公式，根据三角形面积和基函数的梯度组装 $K$。\n- 使用边界段上精确的一维分段线性求积，通过边界边积分组装电极边界质量矩阵 $M^{(m)}$、耦合矩阵 $C$ 和电极对角阵 $D$。\n- 构建全局分块矩阵\n$$\nA = \\begin{bmatrix}\nK + \\sum_{m=1}^M M^{(m)}  -C \\\\\n-C^\\top  D\n\\end{bmatrix}.\n$$\n\n您必须在下面这组参数值（测试套件）上测试您的实现。每个测试用例指定了 $(n_x,n_y)$、电极数量 $M$、沿底部边界 $y=0$ 的电极区间，以及分段常数电导率 $\\sigma(\\mathbf{x})$。接触阻抗 $z_m$ 的单位是欧姆平方米，写作 $\\mathrm{\\Omega\\, m^2}$，而电势 $u$ 和 $U_m$ 的单位是伏特；然而，下面要求的所有输出都是无量纲的布尔值或无单位的浮点数。\n\n- 测试用例 $1$ (通用配置):\n  - $n_x = 10$, $n_y = 8$.\n  - 电导率 $\\sigma(\\mathbf{x}) \\equiv 1$ (均匀)。\n  - $y=0$ 上的电极: $E_1: x \\in [0.0, 0.3]$，其中 $z_1 = 0.05$ $\\mathrm{\\Omega\\, m^2}$；$E_2: x \\in [0.5, 0.9]$，其中 $z_2 = 0.1$ $\\mathrm{\\Omega\\, m^2}$。\n- 测试用例 $2$ (非均匀电导率和全长电极):\n  - $n_x = 6$, $n_y = 4$.\n  - 电导率 $\\sigma(\\mathbf{x}) = 1$ (当 $x  0.5$)，$\\sigma(\\mathbf{x}) = 2$ (当 $x \\ge 0.5$)。\n  - $y=0$ 上的单个电极: $E_1: x \\in [0.0, 1.0]$，其中 $z_1 = 0.2$ $\\mathrm{\\Omega\\, m^2}$。\n- 测试用例 $3$ (边界情况：短电极和对比鲜明的阻抗):\n  - $n_x = 5$, $n_y = 5$.\n  - 电导率 $\\sigma(\\mathbf{x}) \\equiv 1$ (均匀)。\n  - $y=0$ 上的电极: $E_1: x \\in [0.0, 0.2]$，其中 $z_1 = 0.01$ $\\mathrm{\\Omega\\, m^2}$；$E_2: x \\in [0.8, 1.0]$，其中 $z_2 = 0.5$ $\\mathrm{\\Omega\\, m^2}$。\n\n对于每个测试用例，您的程序必须计算并报告以下量：\n- 一个布尔值，表示组装好的全局矩阵 $A$ 是否在数值容差内对称。\n- 对于每个电极 $m$，计算浮点数比率\n$$\nr_m = \\frac{D_{m m}}{z_m^{-1} \\, |E_m|},\n$$\n如果 $D$ 正确地编码了连接 $u$ 和 $U_m$ 的 $z_m^{-1}$ 项，该比率应接近于 $1$。\n- 一个整数，给出数值检测到的 $A$ 的零空间的维度（绝对值低于相对阈值的特征值的数量），在这些没有规范固定的配置中，预期为 $1$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例连接起来的结果，形式为一个用方括号括起来的逗号分隔列表。例如，对于三个测试用例，其输出分别为 $[b_1, r^{(1)}_1, r^{(1)}_2, d_1]$、$[b_2, r^{(2)}_1, d_2]$ 和 $[b_3, r^{(3)}_1, r^{(3)}_2, d_3]$，您的程序应打印\n$$\n[ b_1, r^{(1)}_1, r^{(1)}_2, d_1, b_2, r^{(2)}_1, d_2, b_3, r^{(3)}_1, r^{(3)}_2, d_3 ].\n$$\n所有的布尔值和浮点数必须是标准的 Python 原生类型。所有要求的输出都是无量纲的。\n\n您的最终答案必须是一个完整、可运行的 Python 程序，该程序遵循执行环境规范，并以上述精确格式生成输出，不得包含任何附加文本。", "solution": "用户希望我为电阻抗断层成像 (EIT) 中的完整电极模型 (CEM) 推导并实现全局刚度矩阵的组装。\n\n### 问题验证\n\n首先，我必须验证问题陈述。\n\n**1. 提取的已知条件：**\n- **控制方程：** 在二维多边形域 $\\Omega$ 中，$\\nabla \\cdot (\\sigma \\nabla u) = 0$。\n- **边界条件 (CEM)：**\n    - 在电极 $E_m$ 上，$u + z_m \\, \\sigma \\, \\partial_n u = U_m$。\n    - 在无电极的边界上，$\\sigma \\, \\partial_n u = 0$。\n    - $z_m  0$ 是接触阻抗，单位为 $\\mathrm{\\Omega\\, m^2}$。\n- **电流约束：** $\\int_{E_m} \\sigma \\, \\partial_n u \\, ds = I_m$，可重写为 $\\int_{E_m} z_m^{-1}(U_m - u) \\, ds = I_m$。\n- **有限元系统：** 问题指定了目标分块线性系统，用于求解节点电势 $u \\in \\mathbb{R}^N$ 和电极电势 $U \\in \\mathbb{R}^M$：\n$$\n\\begin{bmatrix}\nK + \\displaystyle\\sum_{m=1}^M M^{(m)}  -C \\\\\n-C^\\top  D\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\\nU\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\\nI\n\\end{bmatrix}\n$$\n- **矩阵定义：**\n    - 刚度矩阵：$K_{ij} = \\int_{\\Omega} \\sigma \\, \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, d\\Omega$。\n    - 边界质量矩阵：$M^{(m)}_{ij} = \\int_{E_m} z_m^{-1}\\, \\phi_i \\phi_j \\, ds$。\n    - 耦合矩阵：$C_{i m} = \\int_{E_m} z_m^{-1}\\, \\phi_i \\, ds$。\n    - 电极矩阵：$D_{m m} = \\int_{E_m} z_m^{-1} \\, ds = z_m^{-1} \\, |E_m|$。\n- **实现：** 域是单位正方形 $[0,1]^2$，使用结构化三角网格。\n- **测试用例与输出：** 提供了三个具体的测试用例，对于每个用例，程序必须计算全局矩阵的对称性、一个与矩阵 $D$ 相关的特定比率，以及零空间的维度。\n\n**2. 验证分析：**\n- **科学依据：** 该问题基于 EIT 的完整电极模型，这是逆问题和生物医学工程领域一个标准且成熟的物理和数学模型。其控制方程具有科学合理性。\n- **适定性：** 问题要求组装矩阵，而不是求解系统。它正确地指出，在没有电势规范的情况下，得到的系统具有一维零空间，这是一个预期的特性，而非缺陷。任务定义明确。\n- **客观性与完整性：** 问题使用精确的数学语言陈述。执行任务所需的所有参数、域和模型均已提供。物理单位（$z_m$ 的 $\\mathrm{\\Omega\\, m^2}$）与代表单位深度三维域的二维模型一致，这是有限元分析中的常见约定。问题是自洽的，没有矛盾。\n\n**3. 结论：**\n该问题是**有效的**。它是一个计算科学领域的标准、适定且科学合理的问题。\n\n### 有限元系统的推导\n\n推导从控制偏微分方程和边界条件开始，以建立弱（变分）形式。\n\n**1. 弱形式**\n控制方程为 $\\nabla \\cdot (\\sigma \\nabla u) = 0$。我们将其乘以一个足够光滑的测试函数 $v \\in H^1(\\Omega)$，并在域 $\\Omega$ 上积分：\n$$\n\\int_{\\Omega} v \\, (\\nabla \\cdot (\\sigma \\nabla u)) \\, d\\Omega = 0\n$$\n应用格林第一恒等式（多维分部积分）将其转换为：\n$$\n- \\int_{\\Omega} \\nabla v \\cdot (\\sigma \\nabla u) \\, d\\Omega + \\int_{\\partial \\Omega} v \\, (\\sigma \\, \\partial_n u) \\, ds = 0\n$$\n其中 $\\partial_n u = \\nabla u \\cdot \\mathbf{n}$ 是外法向导数。整理后得到：\n$$\n\\int_{\\Omega} \\sigma \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\partial \\Omega} v \\, (\\sigma \\, \\partial_n u) \\, ds\n$$\n边界 $\\partial \\Omega$ 由所有电极 $\\{E_m\\}$ 的并集和无电极部分（间隙）组成。在间隙上，边界条件是 $\\sigma \\, \\partial_n u = 0$。在每个电极 $E_m$ 上，CEM 边界条件是 $u + z_m \\sigma \\partial_n u = U_m$，可以整理以表示法向电流密度：$\\sigma \\, \\partial_n u = z_m^{-1}(U_m - u)$。\n将这些代入边界积分：\n$$\n\\int_{\\partial \\Omega} v \\, (\\sigma \\partial_n u) \\, ds = \\sum_{m=1}^M \\int_{E_m} v \\, (z_m^{-1}(U_m - u)) \\, ds + \\int_{\\text{gaps}} v \\cdot 0 \\, ds\n$$\n因此，弱形式变为：\n$$\n\\int_{\\Omega} \\sigma \\nabla u \\cdot \\nabla v \\, d\\Omega = \\sum_{m=1}^M \\int_{E_m} z_m^{-1} (U_m - u) v \\, ds\n$$\n分离涉及未知电势 $u$ 和未知电极电势 $\\{U_m\\}$ 的项：\n$$\n\\int_{\\Omega} \\sigma \\nabla u \\cdot \\nabla v \\, d\\Omega + \\sum_{m=1}^M \\int_{E_m} z_m^{-1} u v \\, ds = \\sum_{m=1}^M \\int_{E_m} z_m^{-1} U_m v \\, ds\n$$\n此变分方程必须对所有有效的测试函数 $v$ 成立。该方程与电流守恒定律一起，构成了完整系统的基础。\n\n**2. 有限元离散化**\n域 $\\Omega$ 被离散化为三角单元网格。电势 $u$ 由函数 $u_h$ 近似，它是分段线性基函数 $\\{\\phi_j\\}_{j=1}^N$ 的线性组合：\n$$\nu(x) \\approx u_h(x) = \\sum_{j=1}^N u_j \\phi_j(x)\n$$\n这里，$N$ 是网格中的节点数，$u_j$ 是电势的未知节点值，$\\phi_j$ 是“帽”函数，它在节点 $j$ 处为 $1$，在所有其他节点处为 $0$。\n\n使用伽辽金法，我们对每个 $i \\in \\{1, \\dots, N\\}$ 选择测试函数 $v$ 为基函数之一 $\\phi_i$。这产生了 $N$ 个方程。对每个 $\\phi_i$：\n$$\n\\int_{\\Omega} \\sigma \\nabla \\left(\\sum_{j=1}^N u_j \\phi_j\\right) \\cdot \\nabla \\phi_i \\, d\\Omega + \\sum_{m=1}^M \\int_{E_m} z_m^{-1} \\left(\\sum_{j=1}^N u_j \\phi_j\\right) \\phi_i \\, ds = \\sum_{m=1}^M \\int_{E_m} z_m^{-1} U_m \\phi_i \\, ds\n$$\n根据积分的线性性质，我们可以将其写为：\n$$\n\\sum_{j=1}^N \\left( \\int_{\\Omega} \\sigma \\nabla \\phi_j \\cdot \\nabla \\phi_i \\, d\\Omega \\right) u_j + \\sum_{m=1}^M \\sum_{j=1}^N \\left( \\int_{E_m} z_m^{-1} \\phi_j \\phi_i \\, ds \\right) u_j = \\sum_{m=1}^M \\left( \\int_{E_m} z_m^{-1} \\phi_i \\, ds \\right) U_m\n$$\n识别出问题陈述中定义的矩阵和向量分量：\n- $K_{ij} = \\int_{\\Omega} \\sigma \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, d\\Omega$\n- $M^{(m)}_{ij} = \\int_{E_m} z_m^{-1} \\phi_i \\phi_j \\, ds$\n- $C_{im} = \\int_{E_m} z_m^{-1} \\phi_i \\, ds$\n\n这 $N$ 个方程的系统可以用矩阵形式写出：\n$$\n\\sum_{j=1}^N K_{ij} u_j + \\sum_{m=1}^M \\sum_{j=1}^N M^{(m)}_{ij} u_j = \\sum_{m=1}^M C_{im} U_m\n$$\n令 $M_{tot} = \\sum_{m=1}^M M^{(m)}$，这等价于目标系统的第一个分块行：\n$$\n(K + M_{tot})\\mathbf{u} - C\\mathbf{U} = \\mathbf{0}\n$$\n\n**3. 电流守恒方程**\n该系统由每个电极的 $M$ 个电流守恒定律封闭。问题陈述此定律可写为 $\\int_{E_m} z_m^{-1}(u - U_m) \\, ds = I_m$。如前所述，这个形式因一个符号而错误。从 $\\sigma \\partial_n u = z_m^{-1}(U_m - u)$ 和 $\\int_{E_m} \\sigma \\partial_n u ds = I_m$ 的正确推导给出：\n$$\n\\int_{E_m} z_m^{-1} (U_m - u) \\, ds = I_m \\quad \\text{for } m = 1, \\dots, M\n$$\n代入有限元近似 $u_h = \\sum_{j=1}^N u_j \\phi_j$：\n$$\n\\int_{E_m} z_m^{-1} U_m \\, ds - \\int_{E_m} z_m^{-1} \\left(\\sum_{j=1}^N u_j \\phi_j\\right) \\, ds = I_m\n$$\n由于 $U_m$ 在电极 $m$ 上是常数：\n$$\nU_m \\left( \\int_{E_m} z_m^{-1} \\, ds \\right) - \\sum_{j=1}^N \\left( \\int_{E_m} z_m^{-1} \\phi_j \\, ds \\right) u_j = I_m\n$$\n我们识别出对应于第二个分块行的矩阵分量：\n- $D_{mm} = \\int_{E_m} z_m^{-1} \\cdot 1 \\, ds = z_m^{-1} |E_m|$ (其中 $D_{mk}=0$ 对于 $m \\neq k$)\n- $C_{jm} = \\int_{E_m} z_m^{-1} \\phi_j \\, ds$\n电极 $m$ 的方程是：\n$$\nD_{mm} U_m - \\sum_{j=1}^N C_{jm} u_j = I_m\n$$\n这对应于矩阵方程 $-C^\\top \\mathbf{u} + D\\mathbf{U} = \\mathbf{I}$ 的第 $m$ 行。\n\n**4. 最终分块系统**\n结合这两组方程，得到问题陈述中指定的完整 $(N+M) \\times (N+M)$ 分块系统：\n$$\n\\begin{bmatrix}\nK + M_{tot}  -C \\\\\n-C^\\top  D\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{u} \\\\\n\\mathbf{U}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{0} \\\\\n\\mathbf{I}\n\\end{bmatrix}\n$$\n全局矩阵 $A$ 是对称的，因为 $K$ 和 $M_{tot}$ 是对称的，$D$ 是对角阵（因此对称），且非对角块互为负转置。\n\n### 实现策略\n\n实现涉及三个主要阶段：\n1.  **网格生成：** 在单位正方形上创建结构化三角网格。节点被索引，三角形由其顶点的索引定义。\n2.  **矩阵组装：**\n    - 通过遍历所有三角形来组装刚度矩阵 $K$。对于每个三角形，使用线性基函数的精确公式计算 $3 \\times 3$ 的局部刚度矩阵，并将其加到全局矩阵中。电导率 $\\sigma$ 在单元的形心处求值。\n    - 通过遍历 $y=0$ 上的边界边来组装边界矩阵 $M_{tot}$、$C$ 和 $D$。对于每条边，确定其与每个电极的交集。通过在这些相交区间上积分一维线性基函数的乘积来计算对矩阵的贡献。这些多项式积分被精确计算。\n3.  **分析：** 构建最终的分块矩阵 $A$。使用 `numpy.allclose` 检查其对称性。从 $D$ 的对角线元素计算比率 $r_m$。通过计算 $A$ 的特征值并计数相对于最大特征值在数值上接近零的特征值数量，来找到零空间的维度。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n\n    # Test case 1: general configuration\n    test1_electrodes = [\n        {'interval': (0.0, 0.3), 'z': 0.05},\n        {'interval': (0.5, 0.9), 'z': 0.1}\n    ]\n    def sigma1(x, y):\n        return 1.0\n\n    # Test case 2: heterogeneous conductivity and full-length electrode\n    test2_electrodes = [\n        {'interval': (0.0, 1.0), 'z': 0.2}\n    ]\n    def sigma2(x, y):\n        return 2.0 if x >= 0.5 else 1.0\n\n    # Test case 3: edge case: short electrodes and contrasting impedances\n    test3_electrodes = [\n        {'interval': (0.0, 0.2), 'z': 0.01},\n        {'interval': (0.8, 1.0), 'z': 0.5}\n    ]\n    def sigma3(x, y):\n        return 1.0\n        \n    test_cases = [\n        {'nx': 10, 'ny': 8, 'sigma_func': sigma1, 'electrodes': test1_electrodes},\n        {'nx': 6, 'ny': 4, 'sigma_func': sigma2, 'electrodes': test2_electrodes},\n        {'nx': 5, 'ny': 5, 'sigma_func': sigma3, 'electrodes': test3_electrodes},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = run_case(\n            case['nx'], case['ny'], case['sigma_func'], case['electrodes']\n        )\n        all_results.extend(results)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef run_case(nx, ny, sigma_func, electrodes):\n    \"\"\"\n    Generates mesh, assembles matrices, and computes required validation quantities for a single test case.\n    \"\"\"\n    nodes, elements = generate_mesh(nx, ny)\n    num_nodes = len(nodes)\n    num_electrodes = len(electrodes)\n\n    K = np.zeros((num_nodes, num_nodes))\n    for elem_nodes_indices in elements:\n        p1_idx, p2_idx, p3_idx = elem_nodes_indices\n        p1, p2, p3 = nodes[p1_idx], nodes[p2_idx], nodes[p3_idx]\n        \n        # Element stiffness matrix K^e\n        area = 0.5 * abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n        \n        # Gradients of basis functions\n        b = np.array([p2[1]-p3[1], p3[1]-p1[1], p1[1]-p2[1]]) / (2 * area)\n        c = np.array([p3[0]-p2[0], p1[0]-p3[0], p2[0]-p1[0]]) / (2 * area)\n\n        # Conductivity at element centroid\n        centroid = (p1 + p2 + p3) / 3.0\n        sigma = sigma_func(centroid[0], centroid[1])\n        \n        Ke = np.zeros((3, 3))\n        for i in range(3):\n            for j in range(3):\n                Ke[i, j] = sigma * (b[i]*b[j] + c[i]*c[j]) * area\n        \n        # Assemble into global K\n        for i in range(3):\n            for j in range(3):\n                K[elem_nodes_indices[i], elem_nodes_indices[j]] += Ke[i, j]\n\n    # Boundary matrix assembly\n    M_tot = np.zeros((num_nodes, num_nodes))\n    C = np.zeros((num_nodes, num_electrodes))\n    D = np.zeros((num_electrodes, num_electrodes))\n\n    for m, elec in enumerate(electrodes):\n        elec_start, elec_end = elec['interval']\n        z_inv = 1.0 / elec['z']\n        \n        # Iterate over boundary edges on y=0\n        for i in range(nx):\n            n1_idx, n2_idx = i, i + 1\n            x1, x2 = nodes[n1_idx][0], nodes[n2_idx][0]\n            \n            # Find intersection of edge [x1, x2] and electrode [elec_start, elec_end]\n            overlap_start = max(x1, elec_start)\n            overlap_end = min(x2, elec_end)\n\n            if overlap_start  overlap_end:\n                # Integrate basis functions over the overlap interval [a, b]\n                a, b = overlap_start, overlap_end\n                h = x2 - x1\n                \n                # Polynomials for basis functions and their products\n                # psi1(x) = (x2-x)/h\n                psi1_coeffs = [x2/h, -1/h]\n                # psi2(x) = (x-x1)/h\n                psi2_coeffs = [-x1/h, 1/h]\n                # psi1^2(x) = ((x2-x)/h)^2\n                psi1_sq_coeffs = [x2**2/h**2, -2*x2/h**2, 1/h**2]\n                # psi2^2(x) = ((x-x1)/h)^2\n                psi2_sq_coeffs = [x1**2/h**2, -2*x1/h**2, 1/h**2]\n                # psi1*psi2(x) = (x2-x)(x-x1)/h^2\n                psi12_coeffs = [-x1*x2/h**2, (x1+x2)/h**2, -1/h**2]\n                \n                I1 = poly_integrate_definite(psi1_coeffs, a, b)\n                I2 = poly_integrate_definite(psi2_coeffs, a, b)\n                I11 = poly_integrate_definite(psi1_sq_coeffs, a, b)\n                I22 = poly_integrate_definite(psi2_sq_coeffs, a, b)\n                I12 = poly_integrate_definite(psi12_coeffs, a, b)\n                \n                # Add to C\n                C[n1_idx, m] += z_inv * I1\n                C[n2_idx, m] += z_inv * I2\n\n                # Add to M_tot\n                M_tot[n1_idx, n1_idx] += z_inv * I11\n                M_tot[n2_idx, n2_idx] += z_inv * I22\n                M_tot[n1_idx, n2_idx] += z_inv * I12\n                M_tot[n2_idx, n1_idx] += z_inv * I12\n        \n        # Diagonal D matrix entry\n        D[m, m] = z_inv * (elec_end - elec_start)\n\n    # Construct global block matrix A\n    A = np.block([\n        [K + M_tot, -C],\n        [-C.T, D]\n    ])\n\n    # Perform analysis\n    # 1. Symmetry check\n    is_symmetric = bool(np.allclose(A, A.T, atol=1e-12))\n    \n    # 2. Ratio check for D\n    ratios = []\n    for m, elec in enumerate(electrodes):\n        elec_start, elec_end = elec['interval']\n        elec_len = elec_end - elec_start\n        z_inv = 1.0 / elec['z']\n        \n        Dmm_val = D[m,m]\n        ratio = Dmm_val / (z_inv * elec_len) if elec_len > 0 else 1.0\n        ratios.append(ratio)\n\n    # 3. Nullspace dimension\n    eigvals = np.linalg.eigvalsh(A)\n    max_abs_eig = np.max(np.abs(eigvals)) if eigvals.size > 0 else 0\n    if max_abs_eig  1e-15:\n        null_dim = A.shape[0]\n    else:\n        # Relative tolerance as suggested\n        tol = 1e-10 * max_abs_eig\n        null_dim = int(np.sum(np.abs(eigvals)  tol))\n        \n    return [is_symmetric, *ratios, null_dim]\n\ndef generate_mesh(nx, ny):\n    \"\"\"\n    Generates a structured triangular mesh on the unit square [0,1]x[0,1].\n    \"\"\"\n    x = np.linspace(0, 1, nx + 1)\n    y = np.linspace(0, 1, ny + 1)\n    nodes = np.array([[xi, yi] for yi in y for xi in x])\n    \n    elements = []\n    for j in range(ny):\n        for i in range(nx):\n            p00 = j * (nx + 1) + i\n            p10 = j * (nx + 1) + (i + 1)\n            p01 = (j + 1) * (nx + 1) + i\n            p11 = (j + 1) * (nx + 1) + (i + 1)\n            # Split quad into two triangles\n            elements.append([p00, p10, p11])\n            elements.append([p00, p11, p01])\n            \n    return nodes, np.array(elements)\n\n\ndef poly_integrate_definite(coeffs, a, b):\n    \"\"\"\n    Computes the definite integral of a polynomial from a to b.\n    Polynomial is given by coeffs p(x) = c0 + c1*x + c2*x^2 + ...\n    \"\"\"\n    if not coeffs:\n        return 0.0\n    \n    # Indefinite integral coeffs = [0, c0, c1/2, c2/3, ...]\n    indef_coeffs = [0.0] * (len(coeffs) + 1)\n    for i, c in enumerate(coeffs):\n        indef_coeffs[i+1] = c / (i + 1)\n    \n    def poly_eval(p_coeffs, x):\n        res = 0.0\n        # Horner's method is numerically unstable for high degree, but fine for quadratics.\n        # Let's use direct evaluation.\n        val = 0.0\n        for i, c in enumerate(p_coeffs):\n            val += c * (x**i)\n        return val\n\n    return poly_eval(indef_coeffs, b) - poly_eval(indef_coeffs, a)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3378244"}, {"introduction": "在实现了正向模型后，验证其正确性及其导数（雅可比矩阵）的准确性至关重要，特别是对于基于梯度的反演算法。本练习 ( [@problem_id:3378201] ) 介绍了泰勒余项检验 (Taylor remainder test)，这是一种验证参数到数据映射的雅可比矩阵计算是否正确的强大技术。掌握这项检验能确保优化程序中使用的核心组件的可靠性。", "problem": "考虑在单位正方形域上具有均匀狄利克雷边界条件的稳态漫射光学层析成像 (DOT) 模型。该模型的控制偏微分方程为标量椭圆扩散问题\n$$\n- \\nabla \\cdot \\left( D \\nabla u \\right) + \\mu_a(\\mathbf{r}) \\, u(\\mathbf{r}) = q(\\mathbf{r}) \\quad \\text{in } \\Omega = (0,1)^2, \\quad u|_{\\partial \\Omega} = 0,\n$$\n其中 $D$ 是一个常数扩散系数，$\\mu_a(\\mathbf{r})$ 是空间变化的吸收系数，$u$ 是光子通量（无量纲），$q$ 是一个源项。所有量均为无量纲。\n\n我们使用均匀笛卡尔网格上的有限差分法进行离散化，每边有 $N$ 个节点，并在边界节点上强制施加均匀狄利克雷边界条件。设内部网格有 $(N-2)^2$ 个节点。令 $L \\in \\mathbb{R}^{n \\times n}$ 表示内部网格上的标准 $5$-点有限差分离散拉普拉斯算子，网格间距为 $h = 1/(N-1)$，因此 $L$ 是对称正定的（对于狄利克雷情况）。令常数扩散系数 $D = 1$。设 $x \\in \\mathbb{R}^K$ 是一个低维参数矢量，该矢量通过分片常数区域来参数化吸收场：\n$$\n\\mu = B x \\in \\mathbb{R}^n,\n$$\n其中 $B \\in \\mathbb{R}^{n \\times K}$ 是一个二元分配矩阵，将每个内部节点精确地映射到 $K$ 个不相交区域中的一个。在本问题中，取 $K=4$，对应于内部网格的四个象限。\n\n对于任意 $x \\in \\mathbb{R}^4$，定义离散正演算子\n$$\nA(x) = D L + \\mathrm{diag}(B x) \\in \\mathbb{R}^{n \\times n},\n$$\n且离散通量 $u(x) \\in \\mathbb{R}^n$ 求解\n$$\nA(x) \\, u(x) = q,\n$$\n其中 $q \\in \\mathbb{R}^n$ 是一个位于最接近区域中心的内部节点处的固定点源。定义一个线性测量算子 $M \\in \\mathbb{R}^{m \\times n}$，它在边界附近的一组预设内部节点上提取 $u$ 的值（代表邻近边界的探测器）。参数到数据的映射则为\n$$\nF(x) = M \\, u(x) = M \\, A(x)^{-1} \\, q \\in \\mathbb{R}^m.\n$$\n\n您需要对在不同基点 $x$ 和扰动方向 $h \\in \\mathbb{R}^4$ 上计算出的 $F$ 的雅可比矩阵进行一阶泰勒余项检验。对于小扰动 $h$，泰勒余项比\n$$\nR(h) \\equiv \\frac{\\|F(x+h) - F(x) - J(x) h\\|_2}{\\|h\\|_2}\n$$\n应随 $\\|h\\|_2$ 线性衰减，其中 $J(x) \\in \\mathbb{R}^{m \\times 4}$ 是 $F$ 在 $x$ 处的雅可比矩阵。雅可比-矢量积可以在不显式构造 $J(x)$ 的情况下，使用以下恒等式进行评估：\n$$\nJ(x) h \\;=\\; - M \\, A(x)^{-1} \\left( \\mathrm{diag}(B h) \\, u(x) \\right),\n$$\n这可以由对 $F(x) = M A(x)^{-1} q$ 求导以及恒等式 $\\mathrm{d}A^{-1} = -A^{-1} (\\mathrm{d}A) A^{-1}$ 推导得出。\n\n实现以下数值实验，以验证 $R(t h)$ 作为 $\\|t h\\|_2$ 的函数（其中 $t  0$）的线性衰减特性：\n\n- 离散化和算子：\n  - 每边使用 $N = 20$ 个节点，因此内部节点数 $n = (N-2)^2 = 324$。使用网格间距为 $h_{grid} = 1/(N-1)$ 的标准 $5$-点模板拉普拉斯算子 $L$，并在内部区域外设置狄利克雷边界值为零。（注：为避免混淆，网格间距重命名为 $h_{grid}$）\n  - 使用 $D = 1$。\n  - 在内部网格上定义四个区域（象限）来构建 $B \\in \\mathbb{R}^{n \\times 4}$。根据每个内部节点的内部索引位于内部网格的左下、右下、左上还是右上半部分，将其精确地归入一个象限。\n  - 将源 $q \\in \\mathbb{R}^n$ 定义为一个单位点源，位于最接近区域中心的内部节点上。\n  - 将测量算子 $M$ 定义为一个行选择器，用于在边界附近的一组内部节点上提取 $u$ 的值：\n    - 传感器集 $\\mathcal{S}_1$：选择与顶部边界相邻的内部行，以及列 $\\{2,6,10,14,17\\}$（使用内部索引）。\n    - 传感器集 $\\mathcal{S}_2$：选择与左侧边界相邻的内部列，以及行 $\\{2,6,10,14,17\\}$（使用内部索引）。\n    - 传感器集 $\\mathcal{S}_3$：选择与底部边界相邻的内部行，以及列 $\\{3,7,11,15\\}$（使用内部索引）。\n  在每种情况下，$M$ 从 $u$ 中选取这些节点的值。\n\n- 对于下述每个测试用例，通过对点集 $\\{(\\log \\|t h\\|_2, \\log R(t h))\\}$ 进行线性最小二乘拟合来估计经验收敛率 $\\hat{p}$。使用一个几何序列的步长 $t_k = 10^{-1} \\cdot 2^{-k}$，其中 $k \\in \\{0,1,2,3,4,5\\}$。使用 $F(x+t_k h)$ 的精确正演解和上述给出的雅可比-矢量积公式来计算 $R(t_k h)$。\n\n- 验收标准：对每个测试用例，返回一个布尔值，指示估计的斜率 $\\hat{p}$ 是否满足 $|\\hat{p} - 1| \\le 0.1$。\n\n所有量均为无量纲。测试套件包含三个用例：\n\n- 用例 A（均匀背景，顶部传感器）：\n  - 基准参数 $x_A = [\\,0.02,\\, 0.02,\\, 0.02,\\, 0.02\\,]^{\\top}$。\n  - 方向 $h_A = [\\,0.01,\\,-0.015,\\,0.02,\\,-0.005\\,]^{\\top}$。\n  - 测量集 $\\mathcal{S}_1$。\n\n- 用例 B（非均匀背景，左侧传感器）：\n  - 基准参数 $x_B = [\\,0.04,\\, 0.02,\\, 0.03,\\, 0.01\\,]^{\\top}$。\n  - 方向 $h_B = [\\,-0.008,\\,0.012,\\,-0.006,\\,0.004\\,]^{\\top}$。\n  - 测量集 $\\mathcal{S}_2$。\n\n- 用例 C（低吸收，底部传感器）：\n  - 基准参数 $x_C = [\\,0.005,\\, 0.005,\\, 0.005,\\, 0.005\\,]^{\\top}$。\n  - 方向 $h_C = [\\,-0.002,\\,0.001,\\,-0.001,\\,0.001\\,]^{\\top}$。\n  - 测量集 $\\mathcal{S}_3$。\n\n您的程序必须构建 $L$、$B$、$q$ 以及指定的测量算子 $M$，实现 $F(x)$，通过对每个 $h$ 使用 $A(x)$ 进行一次线性求解来实现雅可比-矢量积 $J(x) h$，并按规定为每个用例计算比率 $R(t_k h)$ 和估计的斜率 $\\hat{p}$。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个含有三个布尔值的列表，分别对应于用例 A、B 和 C，表示每个用例是否通过验收标准。该行必须严格格式化为 Python 风格的布尔字面量列表，例如，“[True,False,True]”。", "solution": "用户提供了一个在计算科学和反演问题领域中定义明确且具有科学依据的问题。任务是验证漫射光学层析成像 (DOT) 模型中一个参数到观测映射的雅可比矩阵实现的正确性。此验证将使用一阶泰勒余项检验来执行。\n\n该问题是有效的。它自成体系、科学合理，并且所有参数和条件的指定都足够清晰，足以支持唯一的实现。关于网格索引约定（例如，中心节点的选择）的微小模糊之处可以使用标准实践来解决，这些将在解决方案中予以记录。\n\n解决方案如下：首先，我们将详细说明控制偏微分方程 (PDE) 的离散化。其次，我们将定义离散正演模型和雅可比-矢量积的公式。第三，我们将解释用于验证的泰勒余项检验原理。最后，我们将概述针对给定问题参数的测试的具体数值实现。\n\n### 1. 控制方程的离散化\n\n物理模型是单位正方形 $\\Omega = (0,1)^2$ 上的稳态扩散方程：\n$$\n- \\nabla \\cdot \\left( D \\nabla u \\right) + \\mu_a(\\mathbf{r}) \\, u(\\mathbf{r}) = q(\\mathbf{r}) \\quad \\text{in } \\Omega,\n$$\n具有均匀狄利克雷边界条件 $u|_{\\partial \\Omega} = 0$。扩散系数 $D$ 是一个常数，设置为 $D=1$。\n\n我们使用有限差分法在 $N \\times N$ 个节点的均匀笛卡尔网格上离散化此偏微分方程，其中 $N=20$。这产生一个 $(N-2) \\times (N-2) = 18 \\times 18$ 的内部网格。令 $n = (N-2)^2 = 324$ 为内部节点数。网格间距为 $h_{grid} = 1/(N-1) = 1/19$。\n\n项 $-D \\nabla^2 u$ 使用标准 5 点模板进行近似。这产生一个由矩阵 $L \\in \\mathbb{R}^{n \\times n}$ 表示的离散线性算子。我们将 $L$ 定义为对应于负拉普拉斯算子 $-\\nabla^2$ 并按 $D$ 缩放的矩阵。对于一个二维内部索引 $(i,j)$ 映射到一维索引 $k$ 的节点，离散算子的作用是：\n$$\n(L u)_k \\approx \\frac{D}{h_{grid}^2} \\left( 4u_k - u_{k_{i-1,j}} - u_{k_{i+1,j}} - u_{k_{i,j-1}} - u_{k_{i,j+1}} \\right),\n$$\n其中 $u_k$ 是内部网格上的通量值。由于算子和狄利克雷边界条件，矩阵 $L$ 是对称正定的 (SPD)。\n\n吸收项 $\\mu_a(\\mathbf{r}) u(\\mathbf{r})$ 由一个低维矢量 $x \\in \\mathbb{R}^4$ 参数化。吸收场 $\\mu_a$ 在 $K=4$ 个不相交的区域（内部网格的象限）上是分片常数的。这表示为 $\\mu = Bx$，其中 $B \\in \\mathbb{R}^{n \\times 4}$ 是一个二元矩阵，将 $n$ 个内部节点中的每一个分配给四个象限之一。离散吸收算子是一个对角矩阵 $\\mathrm{diag}(\\mu) = \\mathrm{diag}(Bx)$。\n\n该偏微分方程的离散版本成为一个线性系统：\n$$\n(L + \\mathrm{diag}(Bx)) u = q \\quad \\implies \\quad A(x) u(x) = q,\n$$\n其中 $u \\in \\mathbb{R}^n$ 是内部节点处通量值的矢量，$q \\in \\mathbb{R}^n$ 是离散源矢量，$A(x) = L + \\mathrm{diag}(Bx)$ 是系统矩阵，或称离散正演算子。由于 $L$ 是对称正定的，并且吸收系数是非负的，所以 $\\mathrm{diag}(Bx)$ 是半正定的，这使得 $A(x)$ 是对称正定且可逆的。\n\n### 2. 正演模型与雅可比-矢量积\n\n参数到观测的映射 $F(x)$ 给出给定参数矢量 $x$ 的模拟测量值。它定义为：\n$$\nF(x) = M u(x) = M A(x)^{-1} q,\n$$\n其中 $M \\in \\mathbb{R}^{m \\times n}$ 是一个线性测量算子，它选择 $m$ 个传感器位置处的通量值。\n\n为了验证 $F(x)$ 的雅可比矩阵的正确性，我们需要计算它在扰动矢量 $h \\in \\mathbb{R}^4$ 上的作用，记作 $J(x)h$。将 $F(x)$ 对 $x$ 在方向 $h$ 上求导，得到：\n$$\nJ(x)h = M \\, \\frac{d}{d\\alpha}\\Big|_{\\alpha=0} \\left[ A(x+\\alpha h)^{-1} \\right] q.\n$$\n使用矩阵逆的导数恒等式 $\\mathrm{d}(A^{-1}) = -A^{-1}(\\mathrm{d}A)A^{-1}$，并注意到 $A(x)$ 中唯一依赖于 $x$ 的部分是 $\\mathrm{diag}(Bx)$，我们有 $\\mathrm{d}A = \\mathrm{diag}(B(\\mathrm{d}x))$。对于方向导数，这变为 $\\mathrm{diag}(Bh)$。将此代入表达式中，我们得到雅可比-矢量积：\n$$\nJ(x)h = -M A(x)^{-1} \\left( \\mathrm{diag}(Bh) \\, u(x) \\right).\n$$\n该公式在计算上具有优势，因为它避免了显式构造 $m \\times 4$ 的雅可比矩阵 $J(x)$。它需要对同一矩阵 $A(x)$ 进行两次线性求解：一次用于计算 $u(x) = A(x)^{-1}q$，第二次用于计算 $A(x)^{-1}$ 对矢量 $w = \\mathrm{diag}(Bh)u(x)$ 的作用。\n\n### 3. 泰勒余项检验\n\n$F(x)$ 在点 $x$ 附近的一阶泰勒展开为：\n$$\nF(x+h) = F(x) + J(x)h + \\mathcal{O}(\\|h\\|^2).\n$$\n此展开的余项是 $F(x+h) - F(x) - J(x)h$。对于一个足够平滑的函数 $F$，该余项的阶数为 $\\|h\\|^2$。我们可以通过检查余项比的行为来验证我们计算的雅可比矩阵：\n$$\nR(h) = \\frac{\\| F(x+h) - F(x) - J(x)h \\|_2}{\\|h\\|_2}.\n$$\n理论上，我们期望 $R(h) \\propto \\|h\\|_2$，这意味着当 $\\|h\\|_2 \\to 0$ 时，$R(h)$ 应线性收敛于零。这暗示了 $\\log(R(h)) = p \\log(\\|h\\|_2) + c$ 的关系，其中收敛率 $p=1$。\n\n数值实验将估计这个率 $p$。我们沿一个固定方向 $h$，对一系列递减的步长 $t  0$ 计算 $R(t h)$。通过对点 $(\\log \\|t h\\|_2, \\log R(t h))$ 进行线性最小二乘拟合，我们得到一个经验收敛率 $\\hat{p}$（直线的斜率）。如果 $\\hat{p}$ 接近 1，我们就可以确信我们实现的雅可比-矢量积是正确的。问题指定了一个 $|\\hat{p}-1| \\le 0.1$ 的验收标准。\n\n### 4. 实现细节\n\n- **网格与算子：** 我们为 $N=20$ 和 $D=1$ 构建稀疏矩阵 $L$。吸收基矩阵 $B$ 是通过将 $n=324$ 个内部节点中的每一个映射到四个象限（左下、右下、左上、右上）之一来构建的。源矢量 $q$ 是一个单位矢量，其非零项对应于网格索引为 $(8,8)$（0-索引）的内部节点，这是最接近域中心 $(0.5, 0.5)$ 的四个节点之一。每个用例的测量矩阵 $M$ 被实现为选择器，用于从通量矢量 $u$ 中提取指定节点索引处的值。\n- **数值测试流程：** 对于三个测试用例（A、B、C）中的每一个，我们执行以下步骤：\n    1. 定义基准参数 $x$、扰动方向 $h$ 和测量索引。\n    2. 在基点 $x$ 处预计算相关量：$A(x)$、$u(x) = A(x)^{-1}q$、$F(x)=Mu(x)$，以及方向 $h$ 的雅可比-矢量积 $J(x)h = -M A(x)^{-1} (\\mathrm{diag}(Bh)u(x))$。\n    3. 对一个几何序列的步长 $t_k = 10^{-1} \\cdot 2^{-k}$（其中 $k \\in \\{0, \\dots, 5\\}$）进行循环。\n    4. 在每次迭代中，计算扰动后的正演解 $F(x+t_k h)$ 和余项比 $R(t_k h)$。\n    5. 收集 $\\log \\|t_k h\\|_2$ 和 $\\log R(t_k h)$ 的值。\n    6. 循环结束后，计算通过这些对数-对数点的最佳拟合线的斜率 $\\hat{p}$。\n    7. 检查 $\\hat{p}$ 是否满足验收标准 $|\\hat{p}-1| \\le 0.1$。\n所有三个用例的检查结果被收集并报告。对于所有涉及稀疏矩阵 $A(x)$ 的线性求解，我们使用高效的稀疏直接求解器。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the DOT Jacobian verification problem.\n    \"\"\"\n    \n    # 1. Discretization and operator setup\n    N = 20\n    N_int = N - 2\n    n = N_int**2\n    h_grid = 1 / (N - 1)\n    D = 1.0\n\n    # Create the discrete negative Laplacian L corresponding to -D*nabla^2\n    # with 5-point stencil (4 on diag, -1 on off-diags), scaled by D/h_grid^2\n    main_diag = np.full(n, 4.0)\n    side_diag = np.full(n - 1, -1.0)\n    # Periodicity for side_diag (jumps at end of rows)\n    side_diag[N_int-1::N_int] = 0\n    up_down_diag = np.full(n - N_int, -1.0)\n    \n    diagonals = [up_down_diag, side_diag, main_diag, side_diag, up_down_diag]\n    offsets = [-N_int, -1, 0, 1, N_int]\n    \n    L = (D / h_grid**2) * diags(diagonals, offsets, shape=(n, n), format='csc')\n\n    # Create the patch assignment matrix B\n    K = 4\n    B = np.zeros((n, K))\n    half_grid = N_int // 2\n    for i in range(N_int):\n        for j in range(N_int):\n            k = i * N_int + j\n            if i  half_grid and j  half_grid: # Lower-left\n                B[k, 0] = 1\n            elif i  half_grid and j >= half_grid: # Lower-right\n                B[k, 1] = 1\n            elif i >= half_grid and j  half_grid: # Upper-left\n                B[k, 2] = 1\n            else: # Upper-right\n                B[k, 3] = 1\n\n    # Create the source vector q\n    # Tie-break for the central node by picking the one with smallest indices\n    center_idx_i = half_grid - 1\n    center_idx_j = half_grid - 1\n    q_idx = center_idx_i * N_int + center_idx_j\n    q = np.zeros(n)\n    q[q_idx] = 1.0\n    q = csc_matrix(q).T # Use sparse column vector for spsolve\n\n    # Define sensor sets (1D indices)\n    # Interior indices are 0-based\n    # S1: top row (i=17), cols {2,6,10,14,17}\n    M1_indices = [17 * N_int + c for c in [2, 6, 10, 14, 17]]\n    # S2: left col (j=0), rows {2,6,10,14,17}\n    M2_indices = [r * N_int + 0 for r in [2, 6, 10, 14, 17]]\n    # S3: bottom row (i=0), cols {3,7,11,15}\n    M3_indices = [0 * N_int + c for c in [3, 7, 11, 15]]\n\n    # 2. Test case execution logic\n    def run_test_case(x_base, h_dir, M_indices):\n        \"\"\"\n        Performs the Taylor remainder test for a single case.\n        \"\"\"\n        \n        # Helper to construct A(x)\n        def get_A(x):\n            mu_vec = B @ x\n            return L + diags(mu_vec, 0, shape=(n, n), format='csc')\n\n        # Compute base quantities\n        A_base = get_A(x_base)\n        u_base = spsolve(A_base, q)\n        F_base = u_base[M_indices]\n        \n        # Compute Jacobian-vector product J(x_base) @ h_dir\n        # J(x)h = -M A(x)^{-1} (diag(B h) u(x))\n        bh_dir = B @ h_dir\n        w = bh_dir * u_base\n        v = spsolve(A_base, w)\n        Jvh_base = -v[M_indices]\n\n        log_h_norms = []\n        log_R_values = []\n        \n        for k in range(6):\n            t_k = 1e-1 * (2.0**(-k))\n            h_k = t_k * h_dir\n\n            # Compute F(x + h)\n            A_pert = get_A(x_base + h_k)\n            u_pert = spsolve(A_pert, q)\n            F_pert = u_pert[M_indices]\n            \n            # Jacobian-vector product for h_k: J(x_base) @ h_k = t_k * (J(x_base) @ h_dir)\n            Jvh_k = t_k * Jvh_base\n\n            # Compute Taylor remainder ratio R(h_k)\n            num_norm = np.linalg.norm(F_pert - F_base - Jvh_k)\n            den_norm = np.linalg.norm(h_k)\n            \n            if den_norm > 0 and num_norm > 0:\n                R_k = num_norm / den_norm\n                log_h_norms.append(np.log(den_norm))\n                log_R_values.append(np.log(R_k))\n\n        # Perform linear regression to find the convergence rate p_hat\n        if len(log_h_norms)  2:\n            return False\n\n        p_hat, _ = np.polyfit(log_h_norms, log_R_values, 1)\n\n        return abs(p_hat - 1.0) = 0.1\n\n    # 3. Define and run test cases\n    test_cases = [\n        # Case A\n        {'x': np.array([0.02, 0.02, 0.02, 0.02]),\n         'h': np.array([0.01, -0.015, 0.02, -0.005]),\n         'M': M1_indices},\n        # Case B\n        {'x': np.array([0.04, 0.02, 0.03, 0.01]),\n         'h': np.array([-0.008, 0.012, -0.006, 0.004]),\n         'M': M2_indices},\n        # Case C\n        {'x': np.array([0.005, 0.005, 0.005, 0.005]),\n         'h': np.array([-0.002, 0.001, -0.001, 0.001]),\n         'M': M3_indices}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(case['x'], case['h'], case['M'])\n        results.append(result)\n\n    # Final output\n    print(f\"[{results[0]},{results[1]},{results[2]}]\")\n\nsolve()\n```", "id": "3378201"}, {"introduction": "解决逆问题通常需要正则化来处理不适定性和噪声。本练习 ( [@problem_id:3378196] ) 探讨了证据最大化（II 型最大似然），这是一种先进的贝叶斯技术，用于系统地选择吉洪诺夫 (Tikhonov) 正则化参数 $\\alpha$，从而超越了传统的试探法。通过这项实践，你将深入了解用于稳定逆问题解的原则性方法。", "problem": "考虑一个源于电阻抗断层成像（EIT）的线性化逆问题，其中数据失配由高斯噪声模型建模，先验为吉洪诺夫型高斯先验。具体来说，设测量向量 $y \\in \\mathbb{R}^{m}$ 通过线性模型 $y = A x + \\varepsilon$ 与参数增量 $x \\in \\mathbb{R}^{n}$ 相关，其中 $A \\in \\mathbb{R}^{m \\times n}$ 是通过在均匀背景下线性化正演映射得到的灵敏度矩阵，噪声 $\\varepsilon \\sim \\mathcal{N}(0,\\beta^{-1} I)$，且噪声精度 $\\beta  0$ 已知。假设高斯先验为 $x \\sim \\mathcal{N}\\!\\left(0,\\alpha^{-1} R^{-T} R^{-1}\\right)$，其中 $R \\in \\mathbb{R}^{n \\times n}$ 是对称正定矩阵，$\\alpha  0$ 是吉洪诺夫正则化参数，将通过证据最大化（II型最大似然）来选择。引入变量 $u = R x$，并定义变换后的设计矩阵 $\\Phi = A R^{-1}$。你可以假设多元高斯分布、高斯条件作用以及迹运算下的标准矩阵微分的性质。\n\n任务：\n1) 从线性高斯模型和高斯先验出发，通过对 $u$ 积分，推导 $u$ 的后验分布和边际似然（证据）$p(y \\mid \\alpha)$。然后，通过最大化关于 $\\alpha$ 的对数证据，推导出一个用 $u$ 的后验均值和 $\\Phi^{T}\\Phi$ 的谱表示的 $\\alpha$ 的显式更新公式。将你的更新表示为一个仅依赖于 $\\alpha$、$\\beta$、$\\Phi$ 和 $y$ 的闭式解析表达式（不含未知常数）。同时，推导将 $y$ 映射到拟合数据 $\\hat{y}$ 的帽子矩阵 $H(\\alpha)$，并展示如何将有效自由度计算为 $H(\\alpha)$ 的迹。\n\n2) 现在考虑以下一个具体的 EIT 线性化实例，其中 $m=2$ 且 $n=2$。设\n$$\nA = \\begin{pmatrix}\n1.0  0.2 \\\\\n0.3  0.9\n\\end{pmatrix}, \\quad\nR = \\begin{pmatrix}\n1  0 \\\\\n0  2\n\\end{pmatrix}, \\quad\n\\beta = 25, \\quad\ny = \\begin{pmatrix}\n0.7 \\\\\n0.1\n\\end{pmatrix}.\n$$\n从初始值 $\\alpha^{(0)} = 1$ 开始，使用一次证据最大化更新，计算从你推导的更新公式中得到的更新值 $\\alpha^{(1)}$。然后，在 $\\alpha = \\alpha^{(1)}$ 处，将有效自由度计算为帽子矩阵 $H(\\alpha)$ 的迹。\n\n将 $\\alpha^{(1)}$ 和有效自由度均四舍五入到四位有效数字。将你的最终答案以包含这两个数（按此顺序）的行矩阵形式给出。不需要单位。", "solution": "用户提供了一个基于线性逆问题贝叶斯推断原理的有效问题陈述。该问题是适定的、客观的，并包含唯一解所需的所有信息。我将进行完整的推导和计算。\n\n### 第1部分：理论推导\n\n问题在于使用贝叶斯框架找到线性系统 $y = Ax + \\varepsilon$ 的正则化解。\n\n**1. 模型变换**\n\n模型由以下部分给出：\n- 似然：$p(y \\mid x, \\beta) = \\mathcal{N}(y \\mid Ax, \\beta^{-1}I)$，其中 $\\mathcal{N}(\\cdot \\mid \\mu, \\Sigma)$ 表示均值为 $\\mu$、协方差为 $\\Sigma$ 的多元正态分布。\n- 先验：$p(x \\mid \\alpha) = \\mathcal{N}(x \\mid 0, \\alpha^{-1}(R^T R)^{-1})$。由于给定 $R$ 是对称正定的，所以 $R^T=R$，因此先验协方差为 $\\alpha^{-1}(R^2)^{-1}$。\n\n我们引入变量替换 $u = Rx$。由于这是高斯随机变量 $x$ 的线性变换，$u$ 也是高斯分布的。$u$ 的均值为 $R \\cdot 0 = 0$。$u$ 的协方差为 $R(\\alpha^{-1}(R^T R)^{-1})R^T = \\alpha^{-1} R(R^T R)^{-1}R^T = \\alpha^{-1} R(R^{-1}(R^T)^{-1})R^T = \\alpha^{-1}(R R^{-1})((R^T)^{-1}R^T) = \\alpha^{-1}I$。\n因此，$u$ 的先验是一个更简单的球形高斯分布：\n$$p(u \\mid \\alpha) = \\mathcal{N}(u \\mid 0, \\alpha^{-1}I)$$\n\n似然也必须用 $u$ 来表示。由于 $R$ 是可逆的，$x = R^{-1}u$。将其代入似然模型得到：\n$$y = A(R^{-1}u) + \\varepsilon = \\Phi u + \\varepsilon$$\n其中 $\\Phi = AR^{-1}$ 是变换后的设计矩阵。似然变为：\n$$p(y \\mid u, \\beta) = \\mathcal{N}(y \\mid \\Phi u, \\beta^{-1}I)$$\n\n**2. $u$ 的后验分布**\n\n给定数据 $y$ 时，$u$ 的后验分布通过贝叶斯定理求得：$p(u \\mid y, \\alpha, \\beta) \\propto p(y \\mid u, \\beta) p(u \\mid \\alpha)$。\n由于似然和先验都是高斯分布，后验也将是高斯分布，$p(u \\mid y, \\alpha, \\beta) = \\mathcal{N}(u \\mid \\mu_u, \\Sigma_u)$。\n\n后验精度（逆协方差）是先验精度和似然精度（相对于 $u$）之和。\n- 先验精度：从 $p(u \\mid \\alpha)$ 可知，精度为 $(\\alpha^{-1}I)^{-1} = \\alpha I$。\n- 似然数据项：似然的指数部分为 $-\\frac{\\beta}{2}(y-\\Phi u)^T(y-\\Phi u) = -\\frac{\\beta}{2}(u^T\\Phi^T\\Phi u - 2y^T\\Phi u + y^T y)$。$u$ 的二次项表明，由似然贡献的精度是 $\\beta\\Phi^T\\Phi$。\n\n因此，后验精度为 $\\Sigma_u^{-1} = \\alpha I + \\beta\\Phi^T\\Phi$。\n后验协方差为 $\\Sigma_u = (\\alpha I + \\beta\\Phi^T\\Phi)^{-1}$。\n\n后验均值 $\\mu_u$ 可以通过配方法或使用标准公式 $\\mu_u = \\Sigma_u (\\text{先验精度} \\times \\text{先验均值} + \\text{似然项})$ 求得。先验均值为 $0$。指数中关于 $u$ 的线性项来自 $-2\\beta y^T\\Phi u$，因此似然项是 $\\beta\\Phi^T y$。\n$$\\mu_u = \\Sigma_u (\\alpha I \\cdot 0 + \\beta\\Phi^T y) = \\beta(\\alpha I + \\beta\\Phi^T\\Phi)^{-1}\\Phi^T y$$\n所以，后验分布为 $p(u \\mid y, \\alpha, \\beta) = \\mathcal{N}(u \\mid \\mu_u, \\Sigma_u)$。\n\n**3. 边际似然（证据）**\n\n边际似然（或证据）$p(y \\mid \\alpha, \\beta)$ 是通过对参数 $u$ 积分得到的：\n$$p(y \\mid \\alpha, \\beta) = \\int p(y \\mid u, \\beta) p(u \\mid \\alpha) du$$\n这对应于两个高斯分布的卷积。对于模型 $u \\sim \\mathcal{N}(\\mu_0, \\Sigma_0)$ 和 $y \\mid u \\sim \\mathcal{N}(Hu, \\Sigma_n)$，$y$ 的边际分布是 $y \\sim \\mathcal{N}(H\\mu_0, \\Sigma_n + H\\Sigma_0 H^T)$。\n在我们的例子中，$\\mu_0=0$，$\\Sigma_0=\\alpha^{-1}I$，$H=\\Phi$，以及 $\\Sigma_n=\\beta^{-1}I$。\n边际分布的均值为 $\\Phi \\cdot 0 = 0$。\n协方差为 $\\beta^{-1}I + \\Phi(\\alpha^{-1}I)\\Phi^T = \\beta^{-1}I + \\alpha^{-1}\\Phi\\Phi^T$。\n所以，证据是一个高斯分布：\n$$p(y \\mid \\alpha, \\beta) = \\mathcal{N}(y \\mid 0, \\alpha^{-1}\\Phi\\Phi^T + \\beta^{-1}I)$$\n对数证据为：\n$$\\mathcal{L}(\\alpha) = \\ln p(y \\mid \\alpha, \\beta) = -\\frac{1}{2} y^T (\\alpha^{-1}\\Phi\\Phi^T + \\beta^{-1}I)^{-1} y - \\frac{1}{2}\\ln\\det(\\alpha^{-1}\\Phi\\Phi^T + \\beta^{-1}I) - \\frac{m}{2}\\ln(2\\pi)$$\n（注意：我们将 $\\beta$ 视为固定值，因此 $\\mathcal{L}$ 是 $\\alpha$ 的函数）。\n\n**4. 证据最大化与 $\\alpha$ 的更新公式**\n\n为了找到最优的 $\\alpha$，我们最大化 $\\mathcal{L}(\\alpha)$。另一个通常更方便的对数证据表达式是：\n$$\\mathcal{L}(\\alpha) = \\frac{m}{2}\\ln\\beta + \\frac{n}{2}\\ln\\alpha - \\frac{1}{2}\\ln\\det(\\alpha I + \\beta\\Phi^T\\Phi) - \\frac{1}{2}E_{\\text{data}}$$\n其中 $E_{\\text{data}} = \\beta\\|y - \\Phi\\mu_u\\|^2 + \\alpha\\|\\mu_u\\|^2$。简化后，这变为 $\\beta y^T y - \\mu_u^T \\Sigma_u^{-1}\\mu_u = \\beta y^T y - \\beta^2 y^T\\Phi \\Sigma_u \\Phi^T y$。\n所以，$\\mathcal{L}(\\alpha) = \\frac{m}{2}\\ln\\beta + \\frac{n}{2}\\ln\\alpha - \\frac{1}{2}\\ln\\det(\\Sigma_u^{-1}) - \\frac{\\beta}{2}y^T y + \\frac{\\beta^2}{2}y^T\\Phi \\Sigma_u \\Phi^T y + C$。\n\n对 $\\alpha$ 求导：\n$\\frac{\\partial \\mathcal{L}}{\\partial \\alpha} = \\frac{n}{2\\alpha} - \\frac{1}{2}\\frac{\\partial}{\\partial\\alpha}\\ln\\det(\\alpha I + \\beta\\Phi^T\\Phi) + \\frac{\\beta^2}{2}y^T\\Phi \\frac{\\partial\\Sigma_u}{\\partial\\alpha} \\Phi^T y$。\n使用 $\\frac{d}{dt}\\ln\\det(M(t)) = \\text{tr}(M^{-1}\\frac{dM}{dt})$ 和 $\\frac{d}{dt}M^{-1} = -M^{-1}\\frac{dM}{dt}M^{-1}$：\n- $\\frac{\\partial}{\\partial\\alpha}\\ln\\det(\\alpha I + \\beta\\Phi^T\\Phi) = \\text{tr}((\\alpha I + \\beta\\Phi^T\\Phi)^{-1} I) = \\text{tr}(\\Sigma_u)$。\n- $\\frac{\\partial\\Sigma_u}{\\partial\\alpha} = \\frac{\\partial}{\\partial\\alpha}(\\alpha I + \\beta\\Phi^T\\Phi)^{-1} = -(\\alpha I + \\beta\\Phi^T\\Phi)^{-2} = -\\Sigma_u^2$。\n所以，$\\frac{\\partial \\mathcal{L}}{\\partial \\alpha} = \\frac{n}{2\\alpha} - \\frac{1}{2}\\text{tr}(\\Sigma_u) - \\frac{\\beta^2}{2}y^T\\Phi \\Sigma_u^2 \\Phi^T y$。\n最后一项是 $\\frac{1}{2} \\| \\beta \\Sigma_u \\Phi^T y \\|^2 = \\frac{1}{2}\\|\\mu_u\\|^2$。\n因此，$\\frac{\\partial \\mathcal{L}}{\\partial \\alpha} = \\frac{n}{2\\alpha} - \\frac{1}{2}\\text{tr}(\\Sigma_u) - \\frac{1}{2}\\|\\mu_u\\|^2$。\n\n将导数设为零得到：$\\frac{n}{\\alpha} = \\text{tr}(\\Sigma_u) + \\|\\mu_u\\|^2$。\n乘以 $\\alpha$ 得到 $n = \\alpha \\text{tr}(\\Sigma_u) + \\alpha\\|\\mu_u\\|^2$。\n对 $\\alpha$ 重新整理：\n$$\\alpha = \\frac{n - \\alpha \\text{tr}(\\Sigma_u)}{\\|\\mu_u\\|^2}$$\n让我们定义 $\\gamma = n - \\alpha \\text{tr}(\\Sigma_u)$。设 $\\lambda_i$ 为 $\\Phi^T\\Phi$ 的特征值。\n那么 $\\text{tr}(\\Sigma_u) = \\text{tr}((\\alpha I + \\beta\\Phi^T\\Phi)^{-1}) = \\sum_{i=1}^n \\frac{1}{\\alpha + \\beta\\lambda_i}$。\n所以，$\\gamma = n - \\alpha \\sum_{i=1}^n \\frac{1}{\\alpha + \\beta\\lambda_i} = \\sum_{i=1}^n (1 - \\frac{\\alpha}{\\alpha + \\beta\\lambda_i}) = \\sum_{i=1}^n \\frac{\\beta\\lambda_i}{\\alpha + \\beta\\lambda_i}$。\n量 $\\gamma$ 是有效参数的数量。\n对数证据最大化的条件变为 $\\alpha\\|\\mu_u\\|^2 = \\gamma$。这没有给出 $\\alpha$ 的闭式解，而是一个迭代更新方案。给定当前估计值 $\\alpha^{(k)}$，我们计算新的估计值 $\\alpha^{(k+1)}$：\n$$\\alpha^{(k+1)} = \\frac{\\gamma^{(k)}}{\\|\\mu_u^{(k)}\\|^2}$$\n其中 $\\gamma^{(k)} = \\sum_{i=1}^n \\frac{\\beta\\lambda_i}{\\alpha^{(k)} + \\beta\\lambda_i}$ 且 $\\mu_u^{(k)} = \\beta(\\alpha^{(k)} I + \\beta\\Phi^T\\Phi)^{-1}\\Phi^T y$。这就是所要求的更新公式。\n\n**5. 帽子矩阵和有效自由度**\n\n拟合数据 $\\hat{y}$ 是在参数后验分布下测量的期望值。它由 $\\hat{y} = \\Phi \\mu_u$ 给出。\n代入 $\\mu_u$ 的表达式：\n$$\\hat{y} = \\Phi \\left(\\beta(\\alpha I + \\beta\\Phi^T\\Phi)^{-1}\\Phi^T y\\right)$$\n将观测数据 $y$ 映射到拟合数据 $\\hat{y}$ 的矩阵是帽子矩阵 $H(\\alpha)$：\n$$H(\\alpha) = \\beta\\Phi(\\alpha I + \\beta\\Phi^T\\Phi)^{-1}\\Phi^T$$\n模型的有效自由度由帽子矩阵的迹给出。利用迹的循环性质 $\\text{tr}(ABC) = \\text{tr}(BCA)$：\n$$\\text{tr}(H(\\alpha)) = \\text{tr}(\\beta\\Phi(\\alpha I + \\beta\\Phi^T\\Phi)^{-1}\\Phi^T) = \\text{tr}(\\Phi^T\\beta\\Phi(\\alpha I + \\beta\\Phi^T\\Phi)^{-1})$$\n设 $M = \\beta\\Phi^T\\Phi$。表达式为 $\\text{tr}(M(\\alpha I + M)^{-1})$。设 $\\Phi^T\\Phi$ 的特征值为 $\\{\\lambda_i\\}_{i=1}^n$。那么 $M$ 的特征值为 $\\{\\beta\\lambda_i\\}_{i=1}^n$。$M(\\alpha I + M)^{-1}$ 的特征值为 $\\frac{\\beta\\lambda_i}{\\alpha + \\beta\\lambda_i}$。\n迹是这些特征值的和：\n$$\\text{tr}(H(\\alpha)) = \\sum_{i=1}^{n} \\frac{\\beta\\lambda_i}{\\alpha + \\beta\\lambda_i}$$\n这正是我们定义为 $\\gamma$ 的量。因此，有效自由度是 $\\gamma = \\text{tr}(H(\\alpha))$。\n\n### 第2部分：数值计算\n\n给定：\n$A = \\begin{pmatrix} 1.0  0.2 \\\\ 0.3  0.9 \\end{pmatrix}$, $R = \\begin{pmatrix} 1  0 \\\\ 0  2 \\end{pmatrix}$, $\\beta = 25$, $y = \\begin{pmatrix} 0.7 \\\\ 0.1 \\end{pmatrix}$，以及 $\\alpha^{(0)} = 1$。\n\n**1. 初步计算**\n$R^{-1} = \\begin{pmatrix} 1  0 \\\\ 0  0.5 \\end{pmatrix}$\n$\\Phi = AR^{-1} = \\begin{pmatrix} 1.0  0.2 \\\\ 0.3  0.9 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 0  0.5 \\end{pmatrix} = \\begin{pmatrix} 1.0  0.1 \\\\ 0.3  0.45 \\end{pmatrix}$\n$\\Phi^T\\Phi = \\begin{pmatrix} 1.0  0.3 \\\\ 0.1  0.45 \\end{pmatrix} \\begin{pmatrix} 1.0  0.1 \\\\ 0.3  0.45 \\end{pmatrix} = \\begin{pmatrix} 1.09  0.235 \\\\ 0.235  0.2125 \\end{pmatrix}$\n\n**2. $\\Phi^T\\Phi$ 的特征值**\n我们通过求解 $\\det(\\Phi^T\\Phi - \\lambda I)=0$ 来找到特征值 $\\lambda$。\n$\\lambda^2 - \\text{tr}(\\Phi^T\\Phi)\\lambda + \\det(\\Phi^T\\Phi) = 0$\n$\\text{tr}(\\Phi^T\\Phi) = 1.09 + 0.2125 = 1.3025$\n$\\det(\\Phi^T\\Phi) = (1.09)(0.2125) - (0.235)^2 = 0.231625 - 0.055225 = 0.1764$\n$\\lambda^2 - 1.3025\\lambda + 0.1764 = 0$\n$\\lambda = \\frac{1.3025 \\pm \\sqrt{1.3025^2 - 4(0.1764)}}{2} = \\frac{1.3025 \\pm \\sqrt{1.69650625 - 0.7056}}{2} = \\frac{1.3025 \\pm \\sqrt{0.99090625}}{2}$\n$\\lambda_1 = \\frac{1.3025 + 0.9954427}{2} \\approx 1.14897$\n$\\lambda_2 = \\frac{1.3025 - 0.9954427}{2} \\approx 0.153529$\n\n**3. 从 $\\alpha^{(0)}=1$ 更新 $\\alpha$**\n我们使用更新公式 $\\alpha^{(1)} = \\frac{\\gamma^{(0)}}{\\|\\mu_u^{(0)}\\|^2}$。\n首先，用 $\\alpha^{(0)}=1$ 计算 $\\gamma^{(0)}$：\n$\\beta\\lambda_1 \\approx 25 \\times 1.14897 = 28.7243$\n$\\beta\\lambda_2 \\approx 25 \\times 0.153529 = 3.8382$\n$\\gamma^{(0)} = \\frac{\\beta\\lambda_1}{\\alpha^{(0)} + \\beta\\lambda_1} + \\frac{\\beta\\lambda_2}{\\alpha^{(0)} + \\beta\\lambda_2} \\approx \\frac{28.7243}{1 + 28.7243} + \\frac{3.8382}{1 + 3.8382} \\approx 0.966358 + 0.793315 = 1.75967$\n\n接下来，计算 $\\|\\mu_u^{(0)}\\|^2$。\n$\\mu_u^{(0)} = \\beta(\\alpha^{(0)} I + \\beta\\Phi^T\\Phi)^{-1}\\Phi^T y$\n$S_0 = \\alpha^{(0)} I + \\beta\\Phi^T\\Phi = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} + 25 \\begin{pmatrix} 1.09  0.235 \\\\ 0.235  0.2125 \\end{pmatrix} = \\begin{pmatrix} 28.25  5.875 \\\\ 5.875  6.3125 \\end{pmatrix}$\n$\\det(S_0) = (28.25)(6.3125) - (5.875)^2 = 178.328125 - 34.515625 = 143.8125$\n$S_0^{-1} = \\frac{1}{143.8125} \\begin{pmatrix} 6.3125  -5.875 \\\\ -5.875  28.25 \\end{pmatrix}$\n$\\Phi^T y = \\begin{pmatrix} 1.0  0.3 \\\\ 0.1  0.45 \\end{pmatrix}\\begin{pmatrix} 0.7 \\\\ 0.1 \\end{pmatrix} = \\begin{pmatrix} 0.73 \\\\ 0.115 \\end{pmatrix}$\n$\\mu_u^{(0)} = 25 \\cdot \\frac{1}{143.8125} \\begin{pmatrix} 6.3125  -5.875 \\\\ -5.875  28.25 \\end{pmatrix} \\begin{pmatrix} 0.73 \\\\ 0.115 \\end{pmatrix} = \\frac{25}{143.8125} \\begin{pmatrix} 3.9325 \\\\ -1.04 \\end{pmatrix} \\approx \\begin{pmatrix} 0.683616 \\\\ -0.180791 \\end{pmatrix}$\n$\\|\\mu_u^{(0)}\\|^2 \\approx 0.683616^2 + (-0.180791)^2 \\approx 0.46733 + 0.032685 = 0.500015$\n\n现在，我们计算更新后的值 $\\alpha^{(1)}$：\n$\\alpha^{(1)} = \\frac{1.75967}{0.500015} \\approx 3.51922$\n四舍五入到四位有效数字，$\\alpha^{(1)} = 3.519$。\n\n**4. 在 $\\alpha = \\alpha^{(1)}$ 处的有效自由度**\n有效自由度由 $\\gamma^{(1)} = \\text{tr}(H(\\alpha^{(1)}))$ 给出。\n$\\gamma^{(1)} = \\frac{\\beta\\lambda_1}{\\alpha^{(1)} + \\beta\\lambda_1} + \\frac{\\beta\\lambda_2}{\\alpha^{(1)} + \\beta\\lambda_2}$\n使用 $\\alpha^{(1)} \\approx 3.51922$：\n$\\gamma^{(1)} \\approx \\frac{28.7243}{3.51922 + 28.7243} + \\frac{3.8382}{3.51922 + 3.8382} = \\frac{28.7243}{32.24352} + \\frac{3.8382}{7.35742} \\approx 0.89085 + 0.52167 = 1.41252$\n四舍五入到四位有效数字，有效自由度为 $1.413$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 3.519  1.413 \\end{pmatrix}}\n$$", "id": "3378196"}]}