{"hands_on_practices": [{"introduction": "Matérn核的参数，如相关长度 $\\ell$ 和光滑度 $\\nu$，直接决定了我们对未知场的先验假设。本练习旨在通过一个具体的参数估计任务，加深你对这些超参数物理意义的理解。通过将理论协方差与假设的经验数据进行匹配 [@problem_id:3400800]，你将亲手实践如何从数据中推断出模型的关键特性，这在实际的数据同化应用中是至关重要的一步。", "problem": "考虑一个针对定义在$\\mathbb{R}$上的空间状态场$u(x)$的一维线性反演问题。在数据同化背景下，您将$u(x)$建模为一个零均值高斯过程(GP)，其具有平稳且各向同性的Matérn协方差核。Matérn核由边际方差$\\sigma^{2}  0$、相关长度$\\rho  0$和平滑度参数$\\nu  0$参数化。您假设平滑度参数固定为$\\nu = \\tfrac{1}{2}$。\n\n一个大小为$M$的样本集可供使用，其包含从GP先验中进行的独立抽样，$M$足够大，因此根据大数定律，经验协方差可以很好地近似真实协方差。令$\\widehat{C}(h)$表示在分离距离$h \\ge 0$处的经验协方差，该值是根据平稳性和各向同性假设，使用标准协方差估计量从该样本集中计算得出的。假设从样本集中获得了以下经验值：\n- 在分离距离$h = 0$处，$\\widehat{C}(0) = 1.44$。\n- 在分离距离$h = 3$处，$\\widehat{C}(3) = 0.36$。\n\n仅使用平稳高斯过程协方差函数的基本定义、Matérn类的定义公式以及特殊函数的标准性质，通过将经验协方差与$\\nu = \\tfrac{1}{2}$时的理论Matérn协方差进行匹配，推导相关长度$\\rho$的矩估计方法。然后计算$\\rho$的数值结果。\n\n以与距离$h$相同的空间单位表示您对$\\rho$的最终估计，但只报告数值。将您的答案四舍五入到四位有效数字。", "solution": "该问题要求估计一个零均值高斯过程(GP)的相关长度$\\rho$，该过程的先验协方差由平滑度参数为$\\nu = \\frac{1}{2}$的Matérn核描述。该估计将使用矩估计法进行，即通过将理论协方差与给定的经验协方差值进行匹配。\n\n首先，我们陈述分离距离为$h \\ge 0$的平稳且各向同性的Matérn协方差函数的一般形式：\n$$C(h; \\sigma^2, \\rho, \\nu) = \\sigma^2 \\frac{2^{1-\\nu}}{\\Gamma(\\nu)} \\left( \\frac{\\sqrt{2\\nu} h}{\\rho} \\right)^\\nu K_\\nu \\left( \\frac{\\sqrt{2\\nu} h}{\\rho} \\right)$$\n此处，$\\sigma^2$是边际方差，$\\rho  0$是相关长度，$\\nu  0$是平滑度参数。函数$\\Gamma(\\cdot)$是伽马函数，$K_\\nu(\\cdot)$是阶数为$\\nu$的第二类修正贝塞尔函数。\n\n问题指定平滑度参数固定为$\\nu = \\frac{1}{2}$。我们必须针对此特定情况简化通用的Matérn公式。为此，我们使用$\\nu = \\frac{1}{2}$时特殊函数的标准性质：\n1. $\\frac{1}{2}$处的伽马函数为$\\Gamma\\left(\\frac{1}{2}\\right) = \\sqrt{\\pi}$。\n2. 阶数为$\\frac{1}{2}$的第二类修正贝塞尔函数具有闭合形式表达式：$K_{\\frac{1}{2}}(z) = \\sqrt{\\frac{\\pi}{2z}} \\exp(-z)$。\n\n让我们将$\\nu = \\frac{1}{2}$代入Matérn公式。贝塞尔函数的自变量变为：\n$$ \\frac{\\sqrt{2\\nu} h}{\\rho} = \\frac{\\sqrt{2 \\cdot \\frac{1}{2}} h}{\\rho} = \\frac{h}{\\rho} $$\n现在，将所有部分代入协方差函数表达式：\n$$ C(h) = \\sigma^2 \\frac{2^{1-\\frac{1}{2}}}{\\Gamma\\left(\\frac{1}{2}\\right)} \\left( \\frac{h}{\\rho} \\right)^{\\frac{1}{2}} K_{\\frac{1}{2}} \\left( \\frac{h}{\\rho} \\right) $$\n$$ C(h) = \\sigma^2 \\frac{2^{\\frac{1}{2}}}{\\sqrt{\\pi}} \\left( \\frac{h}{\\rho} \\right)^{\\frac{1}{2}} \\left[ \\sqrt{\\frac{\\pi}{2(h/\\rho)}} \\exp\\left(-\\frac{h}{\\rho}\\right) \\right] $$\n我们现在可以简化指数函数前的乘积项：\n$$ C(h) = \\sigma^2 \\left[ \\frac{\\sqrt{2}}{\\sqrt{\\pi}} \\cdot \\frac{\\sqrt{h}}{\\sqrt{\\rho}} \\cdot \\sqrt{\\frac{\\pi \\rho}{2h}} \\right] \\exp\\left(-\\frac{h}{\\rho}\\right) $$\n$$ C(h) = \\sigma^2 \\sqrt{\\frac{2}{\\pi} \\cdot \\frac{h}{\\rho} \\cdot \\frac{\\pi \\rho}{2h}} \\exp\\left(-\\frac{h}{\\rho}\\right) $$\n$$ C(h) = \\sigma^2 \\sqrt{1} \\exp\\left(-\\frac{h}{\\rho}\\right) $$\n因此，对于$\\nu = \\frac{1}{2}$，Matérn协方差函数简化为众所周知的指数协方差函数：\n$$ C(h) = \\sigma^2 \\exp\\left(-\\frac{h}{\\rho}\\right) $$\n对于一个平稳过程，零分离距离处的协方差$C(0)$等于边际方差$\\sigma^2$。这与我们推导的公式一致，因为$\\exp(0) = 1$。\n$$ C(0) = \\sigma^2 \\exp\\left(-\\frac{0}{\\rho}\\right) = \\sigma^2 $$\n\n矩估计法包括将理论协方差函数$C(h)$与给定数据点的经验估计值$\\widehat{C}(h)$相等。我们已知：\n1. $\\widehat{C}(0) = 1.44$\n2. $\\widehat{C}(3) = 0.36$\n\n我们建立一个包含两个未知数$\\sigma^2$和$\\rho$的方程组：\n$$ C(0) = \\sigma^2 = \\widehat{C}(0) = 1.44 $$\n$$ C(3) = \\sigma^2 \\exp\\left(-\\frac{3}{\\rho}\\right) = \\widehat{C}(3) = 0.36 $$\n\n从第一个方程，我们直接得到方差的矩估计值：\n$$ \\hat{\\sigma}^2 = 1.44 $$\n我们将此值代入第二个方程以求解$\\rho$：\n$$ 1.44 \\cdot \\exp\\left(-\\frac{3}{\\rho}\\right) = 0.36 $$\n两边同除以$1.44$：\n$$ \\exp\\left(-\\frac{3}{\\rho}\\right) = \\frac{0.36}{1.44} = \\frac{36}{144} = \\frac{1}{4} $$\n为了求解$\\rho$，我们对两边取自然对数：\n$$ \\ln\\left[\\exp\\left(-\\frac{3}{\\rho}\\right)\\right] = \\ln\\left(\\frac{1}{4}\\right) $$\n$$ -\\frac{3}{\\rho} = -\\ln(4) $$\n$$ \\frac{3}{\\rho} = \\ln(4) $$\n最后，我们分离出$\\rho$：\n$$ \\rho = \\frac{3}{\\ln(4)} $$\n这就是$\\rho$估计值的精确解析表达式。\n\n问题要求一个四舍五入到四位有效数字的数值。我们计算其值：\n$$ \\ln(4) = \\ln(2^2) = 2 \\ln(2) \\approx 2 \\times 0.693147... = 1.386294... $$\n$$ \\rho = \\frac{3}{1.386294...} \\approx 2.164042... $$\n四舍五入到四位有效数字，我们得到：\n$$ \\rho \\approx 2.164 $$", "answer": "$$\\boxed{2.164}$$", "id": "3400800"}, {"introduction": "在许多科学领域，我们不仅关心场本身的值，还关心它的梯度或变化率。高斯过程框架的强大之处在于，它允许我们对场的导数也进行概率建模和推断。这个练习将引导你完成一个纯分析推导 [@problem_id:3400797]，计算在给定观测数据后，场导数的后验不确定性。这不仅能锻炼你处理协方差函数微分的数学技巧，还能让你深刻体会Matérn核的光滑度参数 $\\nu$ 是如何直接控制场的可微性及其导数的性质的。", "problem": "考虑一个定义在 $\\mathbb{R}$ 上的未知一维标量场 $u(x)$，该场被赋予一个均值为零、平稳的 Matérn 协方差核的高斯过程（GP）先验，其光滑度参数为 $\\nu = 5/2$。两个位置 $x$ 和 $x'$ 之间的 Matérn 协方差核仅取决于间距 $r = |x - x'|$，并定义为\n$$\nk(r) = \\sigma^{2}\\left(1 + \\frac{\\sqrt{5}\\, r}{\\ell} + \\frac{5 r^{2}}{3 \\ell^{2}}\\right)\\exp\\!\\left(-\\frac{\\sqrt{5}\\, r}{\\ell}\\right),\n$$\n其中 $\\sigma^{2}  0$ 是边际方差，$\\ell  0$ 是相关长度。假设由于 $\\nu = 5/2$，导数过程 $u'(x)$ 在均方意义下存在。\n\n在数据同化情境中，通过一个线性测量算子收集单个标量观测值，该算子将场在两个不同位置的值相加，并加上独立的测量噪声：\n$$\ny = u(x_{0}) + u(x_{1}) + \\varepsilon,\n$$\n其中 $\\varepsilon \\sim \\mathcal{N}(0,\\tau^{2})$ 与 $u$ 独立，且噪声方差 $\\tau^{2}  0$ 已知。假设位置满足 $x_{0}  x_{1}  x^{\\ast}$，并定义距离\n$$\nr_{0} = x^{\\ast} - x_{0}, \\quad r_{1} = x^{\\ast} - x_{1}, \\quad d = x_{1} - x_{0}.\n$$\n\n从高斯过程的基本定义、上述给出的 Matérn 核以及联合高斯随机变量的标准性质出发，推导在给定观测值 $y$ 的条件下导数 $u'(x^{\\ast})$ 的后验方差。将最终结果表示为关于 $\\sigma^{2}$、$\\ell$、$\\tau^{2}$、$r_{0}$、$r_{1}$ 和 $d$ 的单个闭式解析表达式。最终答案中不要提供中间计算步骤。不需要数值近似；请提供一个精确表达式。", "solution": "该问题要求推导在单个线性观测值 $y$ 条件下，高斯过程（GP）场 $u(x)$ 的导数 $u'(x^{\\ast})$ 的后验方差。该场 $u(x)$ 由一个均值为零、带有 Matérn 协方差核 $k(r)$（其中光滑度参数 $\\nu = 5/2$）的 GP 先验定义。\n\n问题的核心在于联合高斯随机变量的性质。令目标随机变量为 $T = u'(x^{\\ast})$，观测随机变量为 $Y = y = u(x_{0}) + u(x_{1}) + \\varepsilon$。由于 $u(x)$ 是一个高斯过程，而 $\\varepsilon$ 是一个高斯随机变量，因此 $u(x)$ 和 $\\varepsilon$ 样本的任何线性组合都将是高斯的。具体来说，$u'(x^{\\ast})$、$u(x_0)$ 和 $u(x_1)$ 是联合高斯的，因此 $T$ 和 $Y$ 也是联合高斯的。由于 GP 先验的均值为零且噪声 $\\varepsilon$ 的均值为零，所以 $T$ 和 $Y$ 的均值也为零。\n\nT 和 Y 的联合分布是一个二元高斯分布：\n$$\n\\begin{pmatrix} T \\\\ Y \\end{pmatrix} \\sim \\mathcal{N}\\left( \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} \\text{Var}[T]  \\text{Cov}[T, Y] \\\\ \\text{Cov}[Y, T]  \\text{Var}[Y] \\end{pmatrix} \\right)\n$$\n在观测到 $Y=y$ 的条件下，$T$ 的后验方差由条件高斯分布的标准公式给出：\n$$\n\\text{Var}[T | Y=y] = \\text{Var}[T] - \\frac{(\\text{Cov}[T, Y])^2}{\\text{Var}[Y]}\n$$\n为求得解，我们必须计算右侧的三个量：$\\text{Var}[T]$、$\\text{Var}[Y]$ 和 $\\text{Cov}[T, Y]$。这些量由指定的 Matérn 协方差核 $k(r)$ 及其导数确定。\n\n场 $u(x)$ 的协方差函数由 $k(|x-x'|)$ 给出，其中\n$$\nk(r) = \\sigma^{2}\\left(1 + \\frac{\\sqrt{5}\\, r}{\\ell} + \\frac{5 r^{2}}{3 \\ell^{2}}\\right)\\exp\\left(-\\frac{\\sqrt{5}\\, r}{\\ell}\\right)\n$$\n涉及导数过程 $u'(x)$ 的协方差是通过对核函数求导得到的。相关关系如下：\n$$\n\\text{Cov}[u(x), u(x')] = k(|x-x'|)\n$$\n$$\n\\text{Cov}[u'(x), u(x')] = \\frac{\\partial}{\\partial x} k(|x-x'|) = \\text{sgn}(x-x') \\frac{dk}{dr}(|x-x'|)\n$$\n$$\n\\text{Cov}[u'(x), u'(x')] = \\frac{\\partial^2}{\\partial x \\partial x'} k(|x-x'|) = -\\frac{d^2k}{dr^2}(|x-x'|)\n$$\n对于 $x \\neq x'$。某一点上导数的方差由 $\\text{Var}[u'(x)] = \\lim_{x' \\to x} \\text{Cov}[u'(x), u'(x')] = -\\left. \\frac{d^2k}{dr^2} \\right|_{r=0}$ 给出。\n\n首先，我们计算 $k(r)$ 关于 $r$ 的一阶和二阶导数：\n$$\n\\frac{dk}{dr} = \\frac{d}{dr} \\left[ \\sigma^{2}\\left(1 + \\frac{\\sqrt{5}\\, r}{\\ell} + \\frac{5 r^{2}}{3 \\ell^{2}}\\right)\\exp\\left(-\\frac{\\sqrt{5}\\, r}{\\ell}\\right) \\right]\n$$\n使用乘法法则，我们得到：\n$$\n\\frac{dk}{dr} = \\sigma^{2} \\left[ \\left(\\frac{\\sqrt{5}}{\\ell} + \\frac{10r}{3\\ell^2}\\right) - \\frac{\\sqrt{5}}{\\ell}\\left(1 + \\frac{\\sqrt{5}\\, r}{\\ell} + \\frac{5 r^{2}}{3 \\ell^{2}}\\right) \\right] \\exp\\left(-\\frac{\\sqrt{5}\\, r}{\\ell}\\right)\n$$\n$$\n\\frac{dk}{dr} = \\sigma^{2} \\left[ \\frac{\\sqrt{5}}{\\ell} + \\frac{10r}{3\\ell^2} - \\frac{\\sqrt{5}}{\\ell} - \\frac{5r}{\\ell^2} - \\frac{5\\sqrt{5}r^2}{3\\ell^3} \\right] \\exp\\left(-\\frac{\\sqrt{5}\\, r}{\\ell}\\right)\n$$\n$$\n\\frac{dk}{dr} = -\\frac{5\\sigma^2 r}{3\\ell^2}\\left(1 + \\frac{\\sqrt{5}r}{\\ell}\\right) \\exp\\left(-\\frac{\\sqrt{5}r}{\\ell}\\right)\n$$\n接下来，我们计算二阶导数 $\\frac{d^2k}{dr^2}$：\n$$\n\\frac{d^2k}{dr^2} = \\frac{d}{dr} \\left[ -\\frac{5\\sigma^2}{3\\ell^2}\\left(r + \\frac{\\sqrt{5}r^2}{\\ell}\\right) \\exp\\left(-\\frac{\\sqrt{5}r}{\\ell}\\right) \\right]\n$$\n再次应用乘法法则：\n$$\n\\frac{d^2k}{dr^2} = -\\frac{5\\sigma^2}{3\\ell^2} \\left[ \\left(1+\\frac{2\\sqrt{5}r}{\\ell}\\right) - \\frac{\\sqrt{5}}{\\ell}\\left(r + \\frac{\\sqrt{5}r^2}{\\ell}\\right) \\right] \\exp\\left(-\\frac{\\sqrt{5}r}{\\ell}\\right)\n$$\n$$\n\\frac{d^2k}{dr^2} = -\\frac{5\\sigma^2}{3\\ell^2} \\left(1+\\frac{\\sqrt{5}r}{\\ell} - \\frac{5r^2}{\\ell^2}\\right) \\exp\\left(-\\frac{\\sqrt{5}r}{\\ell}\\right)\n$$\n\n现在我们可以计算所需的方差和协方差。\n\n1.  **目标先验方差 $\\text{Var}[T]$**：\n    $T = u'(x^{\\ast})$，所以其方差是导数过程的先验方差。\n    $$\n    \\text{Var}[T] = \\text{Var}[u'(x^{\\ast})] = -\\left. \\frac{d^2k}{dr^2} \\right|_{r=0} = -\\left( -\\frac{5\\sigma^2}{3\\ell^2} (1+0-0) \\exp(0) \\right) = \\frac{5\\sigma^2}{3\\ell^2}\n    $$\n\n2.  **观测值方差 $\\text{Var}[Y]$**：\n    $Y = u(x_0) + u(x_1) + \\varepsilon$。由于 $\\varepsilon$ 与高斯过程 $u(x)$ 独立，其方差是线性相加的。\n    $$\n    \\text{Var}[Y] = \\text{Var}[u(x_0) + u(x_1)] + \\text{Var}[\\varepsilon]\n    $$\n    $$\n    \\text{Var}[Y] = \\text{Var}[u(x_0)] + \\text{Var}[u(x_1)] + 2\\text{Cov}[u(x_0), u(x_1)] + \\tau^2\n    $$\n    任意点的方差为 $k(0) = \\sigma^2$。$u(x_0)$ 和 $u(x_1)$ 之间的协方差为 $k(|x_1-x_0|) = k(d)$。\n    $$\n    \\text{Var}[Y] = \\sigma^2 + \\sigma^2 + 2k(d) + \\tau^2 = 2\\sigma^2 + 2k(d) + \\tau^2\n    $$\n    代入 $k(d)$ 的表达式：\n    $$\n    \\text{Var}[Y] = 2\\sigma^2 + 2\\sigma^{2}\\left(1 + \\frac{\\sqrt{5}\\, d}{\\ell} + \\frac{5 d^{2}}{3 \\ell^{2}}\\right)\\exp\\left(-\\frac{\\sqrt{5}\\, d}{\\ell}\\right) + \\tau^2\n    $$\n    这可以写成：\n    $$\n    \\text{Var}[Y] = 2\\sigma^2\\left[1 + \\left(1 + \\frac{\\sqrt{5}\\, d}{\\ell} + \\frac{5 d^{2}}{3 \\ell^{2}}\\right)\\exp\\left(-\\frac{\\sqrt{5}\\, d}{\\ell}\\right)\\right] + \\tau^2\n    $$\n\n3.  **目标与观测值之间的协方差 $\\text{Cov}[T, Y]$**：\n    利用协方差的线性性质和 $\\varepsilon$ 的独立性：\n    $$\n    \\text{Cov}[T, Y] = \\text{Cov}[u'(x^{\\ast}), u(x_0) + u(x_1) + \\varepsilon] = \\text{Cov}[u'(x^{\\ast}), u(x_0)] + \\text{Cov}[u'(x^{\\ast}), u(x_1)]\n    $$\n    我们使用公式 $\\text{Cov}[u'(x), u(x')] = \\text{sgn}(x-x') \\frac{dk}{dr}(|x-x'|)$。\n    对于第一项，$x=x^{\\ast}$ 且 $x'=x_0$。由于 $x^{\\ast}  x_0$，$\\text{sgn}(x^{\\ast}-x_0) = 1$。距离为 $|x^{\\ast}-x_0|=r_0$。\n    $$\n    \\text{Cov}[u'(x^{\\ast}), u(x_0)] = \\frac{dk}{dr}(r_0)\n    $$\n    对于第二项，$x=x^{\\ast}$ 且 $x'=x_1$。由于 $x^{\\ast}  x_1$，$\\text{sgn}(x^{\\ast}-x_1) = 1$。距离为 $|x^{\\ast}-x_1|=r_1$。\n    $$\n    \\text{Cov}[u'(x^{\\ast}), u(x_1)] = \\frac{dk}{dr}(r_1)\n    $$\n    因此，\n    $$\n    \\text{Cov}[T, Y] = \\frac{dk}{dr}(r_0) + \\frac{dk}{dr}(r_1)\n    $$\n    代入 $\\frac{dk}{dr}$ 的表达式：\n    $$\n    \\text{Cov}[T, Y] = -\\frac{5\\sigma^2 r_0}{3\\ell^2}\\left(1 + \\frac{\\sqrt{5}r_0}{\\ell}\\right) \\exp\\left(-\\frac{\\sqrt{5}r_0}{\\ell}\\right) -\\frac{5\\sigma^2 r_1}{3\\ell^2}\\left(1 + \\frac{\\sqrt{5}r_1}{\\ell}\\right) \\exp\\left(-\\frac{\\sqrt{5}r_1}{\\ell}\\right)\n    $$\n    $$\n    \\text{Cov}[T, Y] = -\\frac{5\\sigma^2}{3\\ell^2} \\left[ r_0\\left(1 + \\frac{\\sqrt{5}r_0}{\\ell}\\right)\\exp\\left(-\\frac{\\sqrt{5}r_0}{\\ell}\\right) + r_1\\left(1 + \\frac{\\sqrt{5}r_1}{\\ell}\\right)\\exp\\left(-\\frac{\\sqrt{5}r_1}{\\ell}\\right) \\right]\n    $$\n\n最后，我们将这三个分量代入后验方差的公式中：\n$$\n\\text{Var}[u'(x^{\\ast}) | y] = \\text{Var}[T] - \\frac{(\\text{Cov}[T, Y])^2}{\\text{Var}[Y]}\n$$\n得到的单个闭式表达式为：\n$$\n\\frac{5\\sigma^2}{3\\ell^2} - \\frac{\\left(-\\frac{5\\sigma^2}{3\\ell^2} \\left[ r_0\\left(1 + \\frac{\\sqrt{5}r_0}{\\ell}\\right)\\exp\\left(-\\frac{\\sqrt{5}r_0}{\\ell}\\right) + r_1\\left(1 + \\frac{\\sqrt{5}r_1}{\\ell}\\right)\\exp\\left(-\\frac{\\sqrt{5}r_1}{\\ell}\\right) \\right]\\right)^2}{2\\sigma^2\\left[1 + \\left(1 + \\frac{\\sqrt{5}\\, d}{\\ell} + \\frac{5 d^{2}}{3 \\ell^{2}}\\right)\\exp\\left(-\\frac{\\sqrt{5}\\, d}{\\ell}\\right)\\right] + \\tau^2}\n$$\n将分子项平方并化简系数可得：\n$$\n\\frac{5\\sigma^2}{3\\ell^2} - \\frac{\\frac{25\\sigma^4}{9\\ell^4} \\left( r_0\\left(1 + \\frac{\\sqrt{5}r_0}{\\ell}\\right)\\exp\\left(-\\frac{\\sqrt{5}r_0}{\\ell}\\right) + r_1\\left(1 + \\frac{\\sqrt{5}r_1}{\\ell}\\right)\\exp\\left(-\\frac{\\sqrt{5}r_1}{\\ell}\\right) \\right)^2}{2\\sigma^2\\left[1 + \\left(1 + \\frac{\\sqrt{5}\\, d}{\\ell} + \\frac{5 d^{2}}{3 \\ell^{2}}\\right)\\exp\\left(-\\frac{\\sqrt{5}\\, d}{\\ell}\\right)\\right] + \\tau^2}\n$$\n这就是后验方差的最终解析表达式。", "answer": "$$\n\\boxed{\\frac{5\\sigma^2}{3\\ell^2} - \\frac{\\frac{25\\sigma^4}{9\\ell^4} \\left( r_0\\left(1 + \\frac{\\sqrt{5}r_0}{\\ell}\\right)\\exp\\left(-\\frac{\\sqrt{5}r_0}{\\ell}\\right) + r_1\\left(1 + \\frac{\\sqrt{5}r_1}{\\ell}\\right)\\exp\\left(-\\frac{\\sqrt{5}r_1}{\\ell}\\right) \\right)^2}{2\\sigma^2\\left(1 + \\left(1 + \\frac{\\sqrt{5}\\, d}{\\ell} + \\frac{5 d^{2}}{3 \\ell^{2}}\\right)\\exp\\left(-\\frac{\\sqrt{5}\\, d}{\\ell}\\right)\\right) + \\tau^2}}\n$$", "id": "3400797"}, {"introduction": "在实际应用中，我们永远无法知道生成数据的“真实”先验协方差；我们所使用的模型总是一种近似。因此，理解当我们的先验假设（即Matérn核的参数）与现实不符时，我们的估计会受到多大影响，是至关重要的。本练习结合了理论推导与编程实践 [@problem_id:3400798]，要求你量化这种模型误设带来的风险。通过计算“风险膨胀因子”，你将直观地看到不准确的先验假设（例如，错误的光滑度 $\\nu$ 或相关长度 $\\ell$）如何降低数据同化系统的性能，从而培养对模型选择和稳健性分析的深刻认识。", "problem": "考虑一个在一维均匀网格上离散化的零均值高斯随机场，其在数据同化框架内用作一个线性逆问题的先验。先验协方差由 Matérn 核指定。观测算子选择特定的网格点，观测噪声是高斯的且独立的。\n\n基本基础与定义：\n- 状态向量 $x \\in \\mathbb{R}^n$ 上的高斯过程先验定义为 $x \\sim \\mathcal{N}(0, C)$，其中 $C \\in \\mathbb{R}^{n \\times n}$ 是一个对称正定协方差矩阵。\n- 在一维空间中，对于分离距离 $r \\ge 0$，Matérn 协方差核由下式给出\n$$\nk_{\\nu,\\ell,\\sigma}(r) = \\sigma^2 \\frac{2^{1-\\nu}}{\\Gamma(\\nu)} \\left( \\frac{\\sqrt{2\\nu}\\, r}{\\ell} \\right)^{\\nu} K_{\\nu}\\!\\left( \\frac{\\sqrt{2\\nu}\\, r}{\\ell} \\right),\n$$\n其中 $\\nu  0$ 是平滑度参数，$\\ell  0$ 是相关长度，$\\sigma^2  0$ 是边际方差，$\\Gamma(\\cdot)$ 是 Gamma 函数，$K_{\\nu}(\\cdot)$ 是第二类修正贝塞尔函数。其极限值满足 $k_{\\nu,\\ell,\\sigma}(0) = \\sigma^2$。\n- 线性观测被建模为 $y = H x + \\varepsilon$，其中 $H \\in \\mathbb{R}^{m \\times n}$ 是一个选择状态分量的线性算子，且 $\\varepsilon \\sim \\mathcal{N}(0, R)$，其中 $R \\in \\mathbb{R}^{m \\times m}$ 是对称正定的。\n\n问题目标：\n您必须研究后验均值估计器对先验误设的鲁棒性。假设数据同化器使用一个可能误设的 Matérn 协方差 $C_{\\mathrm{mod}}$ 来构建后验均值估计器，而真实状态 $x$ 是从真实的 Matérn 协方差 $C_{\\mathrm{true}}$ 生成的。基于模型先验的估计器是模型下的线性条件均值；将其表示为 $m(y)$。\n\n您的任务：\n1. 从高斯先验和线性观测模型出发，推导在模型协方差 $C_{\\mathrm{mod}}$ 下，后验均值估计器 $m(y)$ 的表达式，该表达式应使用 $H$、$R$ 和 $C_{\\mathrm{mod}}$ 表示。不要假设任何非由多元高斯分布和线性算子性质直接蕴含的简便公式。\n2. 仅使用联合高斯向量的期望定义以及迹和期望的线性性质，推导在真实生成模型下期望平方误差的可计算表达式，\n$$\n\\mathbb{E}\\big[ \\lVert x - m(y) \\rVert_2^2 \\big],\n$$\n其中期望是关于 $x \\sim \\mathcal{N}(0, C_{\\mathrm{true}})$ 和 $y = Hx + \\varepsilon$（其中 $\\varepsilon \\sim \\mathcal{N}(0, R)$ 且独立于 $x$）的联合分布计算的。您的推导必须将结果简化为仅涉及 $H$、$R$、$C_{\\mathrm{true}}$ 和 $C_{\\mathrm{mod}}$ 的矩阵运算。\n3. 将使用正确设定的先验（即 $C_{\\mathrm{true}}$）所形成的后验均值的期望平方误差定义为贝叶斯风险。构建风险膨胀因子\n$$\n\\mathrm{RIF} = \\frac{\\mathbb{E}\\big[ \\lVert x - m_{\\mathrm{mod}}(y) \\rVert_2^2 \\big]}{\\mathbb{E}\\big[ \\lVert x - m_{\\mathrm{true}}(y) \\rVert_2^2 \\big]},\n$$\n其中 $m_{\\mathrm{mod}}(y)$ 是在 $C_{\\mathrm{mod}}$ 下的后验均值，$m_{\\mathrm{true}}(y)$ 是在 $C_{\\mathrm{true}}$ 下的后验均值。\n4. 实现一个程序，通过在单位区间上的均匀网格上离散化 Matérn 核来构建 $C_{\\mathrm{true}}$ 和 $C_{\\mathrm{mod}}$。观测算子 $H$ 选择指定的网格点，$R$ 是一个对角矩阵 $r^2 I_m$，其中标量噪声方差 $r^2  0$。\n5. 对于下面的每个测试用例，将风险膨胀因子 $\\mathrm{RIF}$ 以浮点数形式进行数值计算。\n\n离散化细节：\n- 在区间 $[0,1]$ 上使用一个包含 $n$ 个点的均匀网格。\n- 协方差矩阵 $C_{\\mathrm{true}}$ 和 $C_{\\mathrm{mod}}$ 通过在网格点上成对计算 $k_{\\nu,\\ell,\\sigma}(|x_i - x_j|)$ 来构建。\n\n测试套件：\n对于每个测试用例，参数以 $(n, \\text{obs\\_indices}, r^2, (\\sigma_{\\mathrm{true}}, \\ell_{\\mathrm{true}}, \\nu_{\\mathrm{true}}), (\\sigma_{\\mathrm{mod}}, \\ell_{\\mathrm{mod}}, \\nu_{\\mathrm{mod}}))$ 的形式给出，其中：\n- $n$ 是网格大小，\n- $\\text{obs\\_indices}$ 是被观测网格点的从零开始的索引列表（这些索引定义了 $H$），\n- $r^2$ 是标量观测噪声方差，\n- $(\\sigma_{\\mathrm{true}}, \\ell_{\\mathrm{true}}, \\nu_{\\mathrm{true}})$ 是真实的 Matérn 参数，\n- $(\\sigma_{\\mathrm{mod}}, \\ell_{\\mathrm{mod}}, \\nu_{\\mathrm{mod}})$ 是估计器使用的模型 Matérn 参数。\n\n使用以下五个测试用例：\n- 用例 A（正确设定，中等噪声）：$(50, [5,15,25,35,45], 0.05, (1.0, 0.2, 1.5), (1.0, 0.2, 1.5))$。\n- 用例 B（平滑度误设，中等噪声）：$(50, [5,15,25,35,45], 0.05, (1.0, 0.2, 1.5), (1.0, 0.2, 0.5))$。\n- 用例 C（相关长度误设，中等噪声）：$(50, [5,15,25,35,45], 0.05, (1.0, 0.2, 1.5), (1.0, 0.05, 1.5))$。\n- 用例 D（高噪声，长相关且平滑的模型先验）：$(50, [5,15,25,35,45], 1.0, (1.0, 0.2, 1.5), (1.0, 0.5, 2.5))$。\n- 用例 E（密集观测，极低噪声，模型严重误设）：$(50, [0,1,2,\\dots,49], 1.0\\times 10^{-4}, (1.0, 0.2, 1.5), (1.0, 0.5, 0.5))$。\n\n输出规格：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[rA,rB,rC,rD,rE]”），每个条目是对应案例的风险膨胀因子。条目必须是浮点数。本问题不涉及物理单位。不需要角度单位。不使用百分比。", "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于贝叶斯逆问题和数据同化的原理，在数学上是适定的，完全指定且客观。因此，我们可以着手解决。\n\n该问题需要进行两部分分析：首先，对关键统计量进行理论推导；其次，通过数值实现来计算一组指定测试用例的风险膨胀因子。\n\n### 第 1 部分：后验均值估计器的推导\n\n第一个任务是在模型假设下，推导后验均值估计器（表示为 $m(y)$）的表达式。该模型假设状态向量 $x \\in \\mathbb{R}^n$ 的先验分布为 $x \\sim \\mathcal{N}(0, C_{\\mathrm{mod}})$，线性观测模型为 $y = Hx + \\varepsilon$，其中观测噪声 $\\varepsilon \\in \\mathbb{R}^m$ 的分布为 $\\varepsilon \\sim \\mathcal{N}(0, R)$。状态 $x$ 和噪声 $\\varepsilon$ 被假定为独立的。\n\n为了求得后验均值 $\\mathbb{E}[x|y]$，我们首先描述拼接向量 $\\begin{pmatrix} x \\\\ y \\end{pmatrix}$ 的联合分布。由于 $x$ 和 $y$（作为高斯变量的线性变换）都是高斯变量，它们的联合分布也是高斯分布。\n\n联合向量的均值为：\n$$\n\\mathbb{E}\\left[\\begin{pmatrix} x \\\\ y \\end{pmatrix}\\right] = \\begin{pmatrix} \\mathbb{E}[x] \\\\ \\mathbb{E}[Hx + \\varepsilon] \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ H\\mathbb{E}[x] + \\mathbb{E}[\\varepsilon] \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n\n联合向量的协方差矩阵由下式给出：\n$$\n\\text{Cov}\\left(\\begin{pmatrix} x \\\\ y \\end{pmatrix}\\right) = \\mathbb{E}\\left[ \\begin{pmatrix} x \\\\ y \\end{pmatrix} \\begin{pmatrix} x^T  y^T \\end{pmatrix} \\right] = \\begin{pmatrix} \\mathbb{E}[xx^T]  \\mathbb{E}[xy^T] \\\\ \\mathbb{E}[yx^T]  \\mathbb{E}[yy^T] \\end{pmatrix}\n$$\n\n我们在模型假设下计算该协方差矩阵的每个分块：\n- $\\Sigma_{xx} = \\mathbb{E}[xx^T] = C_{\\mathrm{mod}}$（根据先验的定义）。\n- $\\Sigma_{xy} = \\mathbb{E}[xy^T] = \\mathbb{E}[x(Hx + \\varepsilon)^T] = \\mathbb{E}[x(x^TH^T + \\varepsilon^T)] = \\mathbb{E}[xx^T]H^T + \\mathbb{E}[x\\varepsilon^T]$。由于 $x$ 和 $\\varepsilon$ 独立，$\\mathbb{E}[x\\varepsilon^T] = \\mathbb{E}[x]\\mathbb{E}[\\varepsilon]^T = 0 \\cdot 0^T = 0$。因此，$\\Sigma_{xy} = C_{\\mathrm{mod}}H^T$。\n- $\\Sigma_{yx} = \\mathbb{E}[yx^T] = (\\Sigma_{xy})^T = (C_{\\mathrm{mod}}H^T)^T = HC_{\\mathrm{mod}}$。\n- $\\Sigma_{yy} = \\mathbb{E}[yy^T] = \\mathbb{E}[(Hx + \\varepsilon)(Hx + \\varepsilon)^T] = \\mathbb{E}[Hxx^TH^T + Hx\\varepsilon^T + \\varepsilon x^T H^T + \\varepsilon\\varepsilon^T]$。利用期望的线性和独立性，上式变为 $H\\mathbb{E}[xx^T]H^T + \\mathbb{E}[\\varepsilon\\varepsilon^T] = HC_{\\mathrm{mod}}H^T + R$。\n\n所以，联合分布为：\n$$\n\\begin{pmatrix} x \\\\ y \\end{pmatrix} \\sim \\mathcal{N}\\left(\n\\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix},\n\\begin{pmatrix} C_{\\mathrm{mod}}  C_{\\mathrm{mod}}H^T \\\\ HC_{\\mathrm{mod}}  HC_{\\mathrm{mod}}H^T + R \\end{pmatrix}\n\\right)\n$$\n\n对于一个一般的分块高斯向量 $\\begin{pmatrix} z_1 \\\\ z_2 \\end{pmatrix} \\sim \\mathcal{N}\\left(\\begin{pmatrix} \\mu_1 \\\\ \\mu_2 \\end{pmatrix}, \\begin{pmatrix} \\Sigma_{11}  \\Sigma_{12} \\\\ \\Sigma_{21}  \\Sigma_{22} \\end{pmatrix}\\right)$，给定 $z_2$ 时 $z_1$ 的条件均值为 $\\mathbb{E}[z_1|z_2] = \\mu_1 + \\Sigma_{12}\\Sigma_{22}^{-1}(z_2 - \\mu_2)$。\n\n将此公式应用于我们的情况，令 $z_1=x$ 和 $z_2=y$，我们得到后验均值估计器 $m(y)$：\n$$\nm(y) = 0 + (C_{\\mathrm{mod}}H^T)(HC_{\\mathrm{mod}}H^T + R)^{-1}(y - 0)\n$$\n$$\nm(y) = C_{\\mathrm{mod}}H^T(HC_{\\mathrm{mod}}H^T + R)^{-1}y\n$$\n这个表达式，通常写作 $m(y) = K_{\\mathrm{mod}}y$，其中 $K_{\\mathrm{mod}} = C_{\\mathrm{mod}}H^T(HC_{\\mathrm{mod}}H^T + R)^{-1}$ 是“增益”矩阵，是第一个任务所要求的结果。为清晰起见，我们将此估计器表示为 $m_{\\mathrm{mod}}(y)$。\n\n### 第 2 部分：期望平方误差的推导\n\n第二个任务是推导期望平方误差 $\\mathbb{E}\\big[ \\lVert x - m_{\\mathrm{mod}}(y) \\rVert_2^2 \\big]$，其中期望是在**真实**数据生成过程上计算的。在此过程中，真实状态从 $x \\sim \\mathcal{N}(0, C_{\\mathrm{true}})$ 中抽取，观测值为 $y = Hx + \\varepsilon$，其中 $\\varepsilon \\sim \\mathcal{N}(0, R)$。\n\n令估计误差为 $e = x - m_{\\mathrm{mod}}(y)$。我们感兴趣的量是 $\\mathbb{E}[\\|e\\|_2^2]$。我们使用恒等式 $\\mathbb{E}[\\|e\\|_2^2] = \\mathbb{E}[\\text{tr}(ee^T)] = \\text{tr}(\\mathbb{E}[ee^T]) = \\text{tr}(\\text{Cov}(e))$，因为我们将证明 $\\mathbb{E}[e]=0$。\n\n首先，我们用真实的随机变量 $x$ 和 $\\varepsilon$ 来表示误差 $e$：\n$$\ne = x - m_{\\mathrm{mod}}(y) = x - K_{\\mathrm{mod}}y = x - K_{\\mathrm{mod}}(Hx + \\varepsilon)\n$$\n$$\ne = (I - K_{\\mathrm{mod}}H)x - K_{\\mathrm{mod}}\\varepsilon\n$$\n其中 $I$ 是 $n \\times n$ 的单位矩阵。\n\n期望误差为：\n$$\n\\mathbb{E}[e] = \\mathbb{E}[(I - K_{\\mathrm{mod}}H)x - K_{\\mathrm{mod}}\\varepsilon] = (I - K_{\\mathrm{mod}}H)\\mathbb{E}[x] - K_{\\mathrm{mod}}\\mathbb{E}[\\varepsilon] = 0\n$$\n由于均值误差为零，期望平方误差是误差协方差矩阵的迹，即 $\\text{Cov}(e) = \\mathbb{E}[ee^T]$。\n\n$$\n\\text{Cov}(e) = \\mathbb{E}\\left[ \\left( (I - K_{\\mathrm{mod}}H)x - K_{\\mathrm{mod}}\\varepsilon \\right) \\left( (I - K_{\\mathrm{mod}}H)x - K_{\\mathrm{mod}}\\varepsilon \\right)^T \\right]\n$$\n展开乘积得到四项。由于 $x$ 和 $\\varepsilon$ 独立且零均值，涉及 $x\\varepsilon^T$ 和 $\\varepsilon x^T$ 的交叉项的期望为零。\n$$\n\\text{Cov}(e) = \\mathbb{E}\\left[ (I - K_{\\mathrm{mod}}H)xx^T(I - K_{\\mathrm{mod}}H)^T \\right] + \\mathbb{E}\\left[ K_{\\mathrm{mod}}\\varepsilon\\varepsilon^T K_{\\mathrm{mod}}^T \\right]\n$$\n根据期望的线性性质，并代入真实协方差 $\\mathbb{E}[xx^T] = C_{\\mathrm{true}}$ 和 $\\mathbb{E}[\\varepsilon\\varepsilon^T] = R$：\n$$\n\\text{Cov}(e) = (I - K_{\\mathrm{mod}}H)C_{\\mathrm{true}}(I - K_{\\mathrm{mod}}H)^T + K_{\\mathrm{mod}}RK_{\\mathrm{mod}}^T\n$$\n\n期望平方误差是该矩阵的迹：\n$$\n\\mathbb{E}\\big[ \\lVert x - m_{\\mathrm{mod}}(y) \\rVert_2^2 \\big] = \\text{tr}\\left( (I - K_{\\mathrm{mod}}H)C_{\\mathrm{true}}(I - K_{\\mathrm{mod}}H)^T + K_{\\mathrm{mod}}RK_{\\mathrm{mod}}^T \\right)\n$$\n这就是所要求的可计算表达式。\n\n### 第 3 部分：风险膨胀因子\n\n风险膨胀因子（$\\mathrm{RIF}$）定义为误设估计器的期望平方误差与正确设定估计器的期望平方误差之比。\n$$\n\\mathrm{RIF} = \\frac{\\mathbb{E}\\big[ \\lVert x - m_{\\mathrm{mod}}(y) \\rVert_2^2 \\big]}{\\mathbb{E}\\big[ \\lVert x - m_{\\mathrm{true}}(y) \\rVert_2^2 \\big]}\n$$\n分子是第 2 部分中推导的表达式。分母是贝叶斯风险，对应于模型被正确设定的情况，即 $C_{\\mathrm{mod}} = C_{\\mathrm{true}}$。令 $K_{\\mathrm{true}} = C_{\\mathrm{true}}H^T(HC_{\\mathrm{true}}H^T + R)^{-1}$。贝叶斯风险是通过在误差计算中用 $K_{\\mathrm{true}}$ 替换 $K_{\\mathrm{mod}}$ 以及用 $C_{\\mathrm{true}}$ 替换 $C_{\\mathrm{mod}}$ 得到的。\n\n最优估计器 $m_{\\mathrm{true}}(y)$ 的期望误差是后验协方差矩阵 $C_{\\mathrm{post}}$ 的迹。一个标准结果是 $C_{\\mathrm{post}} = (I - K_{\\mathrm{true}}H)C_{\\mathrm{true}}$。因此，贝叶斯风险为：\n$$\n\\mathbb{E}\\big[ \\lVert x - m_{\\mathrm{true}}(y) \\rVert_2^2 \\big] = \\text{tr}\\left( (I - K_{\\mathrm{true}}H)C_{\\mathrm{true}} \\right)\n$$\n这也可以通过将第 2 部分中的一般误差公式在 $C_{\\mathrm{mod}}=C_{\\mathrm{true}}$ 的情况下进行简化来得到。\n\n$\\mathrm{RIF}$ 的最终表达式为：\n$$\n\\mathrm{RIF} = \\frac{\\text{tr}\\left( (I - K_{\\mathrm{mod}}H)C_{\\mathrm{true}}(I - K_{\\mathrm{mod}}H)^T + K_{\\mathrm{mod}}RK_{\\mathrm{mod}}^T \\right)}{\\text{tr}\\left( (I - K_{\\mathrm{true}}H)C_{\\mathrm{true}} \\right)}\n$$\n\n### 第 4 和 5 部分：数值实现\n\n最后两个任务要求实现这些公式，以计算几个测试用例的 $\\mathrm{RIF}$。对每个用例，实现过程包括以下步骤：\n1.  构建协方差矩阵 $C_{\\mathrm{true}}$ 和 $C_{\\mathrm{mod}}$。这包括在 $[0,1]$ 上创建一个包含 $n$ 个点的均匀网格，计算成对距离矩阵，并根据给定参数评估 Matérn 核函数 $k_{\\nu,\\ell,\\sigma}(r)$。`scipy.special` 库提供了必要的 Gamma 函数（$\\Gamma$）和第二类修正贝塞尔函数（$K_{\\nu}$）。对于 $r=0$ 的情况需要特别注意，此时核函数值为 $\\sigma^2$。\n2.  构建观测算子 $H$，它是一个 $m \\times n$ 矩阵，用于选择与 `obs_indices` 对应的状态向量元素。\n3.  构建观测噪声协方差 $R$，它是一个对角矩阵 $r^2 I_m$。\n4.  使用推导出的公式计算增益矩阵 $K_{\\mathrm{true}}$ 和 $K_{\\mathrm{mod}}$，这涉及矩阵乘法和求逆。\n5.  计算分子（误设风险）和分母（贝叶斯风险）的迹表达式。\n6.  计算它们的比率以求得 $\\mathrm{RIF}$。\n\n最终答案块中提供的 Python 代码对每个测试用例执行这些步骤，并按要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma, kv\n\ndef construct_matern_covariance(n, sigma, l, nu):\n    \"\"\"\n    Constructs the Matérn covariance matrix on a uniform grid.\n\n    Args:\n        n (int): Number of grid points.\n        sigma (float): Marginal standard deviation.\n        l (float): Correlation length scale.\n        nu (float): Smoothness parameter.\n\n    Returns:\n        np.ndarray: The n x n covariance matrix.\n    \"\"\"\n    # Create a uniform grid on [0, 1]\n    x_grid = np.linspace(0.0, 1.0, n)\n    \n    # Compute the pairwise distance matrix\n    dist_matrix = np.abs(x_grid[:, np.newaxis] - x_grid)\n    \n    # The Matérn kernel is evaluated in a way that avoids numerical issues at r=0.\n    # For r > 0:\n    # k(r) = sigma^2 * (2^(1-nu)/Gamma(nu)) * (sqrt(2*nu)*r/l)^nu * K_nu(sqrt(2*nu)*r/l)\n    # For r = 0, k(0) = sigma^2.\n    \n    C = np.zeros((n, n), dtype=float)\n    \n    # Indices where distance is non-zero\n    non_zero_indices = dist_matrix > 0\n    r = dist_matrix[non_zero_indices]\n    \n    # Argument for the Bessel function and the power term\n    arg = np.sqrt(2 * nu) * r / l\n    \n    factor1 = sigma**2 * (2**(1 - nu)) / gamma(nu)\n    factor2 = arg**nu\n    factor3 = kv(nu, arg) # Modified Bessel function of the second kind\n    \n    C[non_zero_indices] = factor1 * factor2 * factor3\n    \n    # Fill the diagonal where distance is zero\n    np.fill_diagonal(C, sigma**2)\n    \n    return C\n\ndef compute_risk_inflation_factor(n, obs_indices, r_sq, true_params, mod_params):\n    \"\"\"\n    Computes the Risk Inflation Factor (RIF) for a given set of parameters.\n\n    Args:\n        n (int): Grid size.\n        obs_indices (list): List of observed grid point indices.\n        r_sq (float): Scalar observation noise variance.\n        true_params (tuple): (sigma_true, l_true, nu_true).\n        mod_params (tuple): (sigma_mod, l_mod, nu_mod).\n\n    Returns:\n        float: The computed Risk Inflation Factor.\n    \"\"\"\n    # Unpack parameters\n    sigma_true, l_true, nu_true = true_params\n    sigma_mod, l_mod, nu_mod = mod_params\n\n    # 1. Construct covariance matrices\n    C_true = construct_matern_covariance(n, sigma_true, l_true, nu_true)\n    C_mod = construct_matern_covariance(n, sigma_mod, l_mod, nu_mod)\n    \n    # 2. Construct observation operator H and noise covariance R\n    m = len(obs_indices)\n    H = np.zeros((m, n))\n    H[np.arange(m), obs_indices] = 1.0\n    R = r_sq * np.eye(m)\n    \n    I_n = np.eye(n)\n\n    # 3. Calculate optimal gain K_true and the Bayes Risk (denominator)\n    inv_term_true = H @ C_true @ H.T + R\n    # K = C H^T S^-1  =>  S K^T = H C^T\n    K_true = np.linalg.solve(inv_term_true, H @ C_true).T\n\n    bayes_risk = np.trace((I_n - K_true @ H) @ C_true)\n    \n    if np.isclose(bayes_risk, 0.0):\n        # This occurs if the posterior variance is zero, implying perfect estimation.\n        # If the mis-specified risk is also zero, RIF is 1. If not, it's infinite.\n        # This case is unlikely with the given parameters, but handle to avoid division by zero.\n        return np.inf\n\n    # 4. Calculate model gain K_mod\n    inv_term_mod = H @ C_mod @ H.T + R\n    K_mod = np.linalg.solve(inv_term_mod, H @ C_mod).T\n\n    # 5. Calculate mis-specified expected error (numerator)\n    term1 = I_n - K_mod @ H\n    err_cov_mis_spec = term1 @ C_true @ term1.T + K_mod @ R @ K_mod.T\n    mis_spec_risk = np.trace(err_cov_mis_spec)\n\n    # 6. Compute RIF\n    rif = mis_spec_risk / bayes_risk\n    \n    return rif\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (correct specification, moderate noise)\n        (50, [5, 15, 25, 35, 45], 0.05, (1.0, 0.2, 1.5), (1.0, 0.2, 1.5)),\n        # Case B (smoothness mis-specified, moderate noise)\n        (50, [5, 15, 25, 35, 45], 0.05, (1.0, 0.2, 1.5), (1.0, 0.2, 0.5)),\n        # Case C (length-scale mis-specified, moderate noise)\n        (50, [5, 15, 25, 35, 45], 0.05, (1.0, 0.2, 1.5), (1.0, 0.05, 1.5)),\n        # Case D (high noise, long and smooth model prior)\n        (50, [5, 15, 25, 35, 45], 1.0, (1.0, 0.2, 1.5), (1.0, 0.5, 2.5)),\n        # Case E (dense observations, very low noise, strongly mis-specified model)\n        (50, list(range(50)), 1.0e-4, (1.0, 0.2, 1.5), (1.0, 0.5, 0.5)),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, obs_indices, r_sq, true_params, mod_params = case\n        rif = compute_risk_inflation_factor(n, obs_indices, r_sq, true_params, mod_params)\n        results.append(rif)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3400798"}]}