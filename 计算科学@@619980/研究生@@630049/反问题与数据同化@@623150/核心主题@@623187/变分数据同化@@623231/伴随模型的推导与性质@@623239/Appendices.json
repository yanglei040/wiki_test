{"hands_on_practices": [{"introduction": "在信任任何由伴随模型计算出的梯度之前，我们必须验证伴随算子本身是否已正确实现。点积检验提供了一种基础的验证方法，它直接检验伴随算子的数学定义 $\\langle Lu, v \\rangle_Y = \\langle u, L^*v \\rangle_X$ 是否对切线线性对应部分成立。本练习将指导您构建这一关键测试，甚至涵盖在数据同化中常见的加权内积情况。[@problem_id:3363680]", "problem": "考虑一个可微离散正向模型 $F:\\mathbb{R}^{n}\\to\\mathbb{R}^{m}$ 和一个固定状态 $x\\in\\mathbb{R}^{n}$。设 $X=\\mathbb{R}^{n}$ 和 $Y=\\mathbb{R}^{m}$ 被赋予了由对称正定 (SPD) 矩阵 $W_{x}\\in\\mathbb{R}^{n\\times n}$ 和 $W_{y}\\in\\mathbb{R}^{m\\times m}$ 分别定义的加权内积：\n$$\\langle u,v\\rangle_{X}=u^{\\top}W_{x}v,\\quad \\langle p,q\\rangle_{Y}=p^{\\top}W_{y}q.$$\n假设雅可比矩阵 $F'(x)$ 的一个切线性实现是可用的，可以对任意扰动 $\\delta x\\in\\mathbb{R}^{n}$ 计算 $F'(x)\\delta x$，并且假设您已经实现了一个候选伴随算子 $A_{\\mathrm{adj}}:\\mathbb{R}^{m}\\to\\mathbb{R}^{n}$，旨在表示 $F'(x)$ 关于 $X$ 和 $Y$ 上给定内积的伴随。您希望通过一个数值测试来验证 $A_{\\mathrm{adj}}$ 的正确性，该测试使用随机生成的扰动 $\\delta x\\in\\mathbb{R}^{n}$ 和 $\\delta y\\in\\mathbb{R}^{m}$，并通过一个与被比较量的大小成比例的适当容差来考虑有限精度算术的影响。\n\n在 $X$ 和 $Y$ 上的加权内积下，哪个选项正确地构建了一个鲁棒的点积测试，用以对照 $F'(x)$ 验证 $A_{\\mathrm{adj}}$？\n\nA. 从标准正态分布中抽取独立的随机扰动 $\\delta x\\in\\mathbb{R}^{n}$ 和 $\\delta y\\in\\mathbb{R}^{m}$。计算 $s_{1}=\\delta y^{\\top}\\big(F'(x)\\delta x\\big)$ 和 $s_{2}=\\delta x^{\\top}\\big(F'(x)^{\\top}\\delta y\\big)$。如果对于一个小的容差 $\\varepsilon$ 有 $\\big|s_{1}-s_{2}\\big|\\leq \\varepsilon\\,\\|\\delta x\\|_{2}\\,\\|\\delta y\\|_{2}$，则声明伴随实现是正确的。\n\nB. 从标准正态分布中抽取独立的随机扰动 $\\delta x\\in\\mathbb{R}^{n}$ 和 $\\delta y\\in\\mathbb{R}^{m}$。计算 $s_{1}=\\big(F'(x)\\delta x\\big)^{\\top}W_{y}\\delta y$ 和 $s_{2}=\\delta x^{\\top}W_{x}\\big(A_{\\mathrm{adj}}\\delta y\\big)$。重复进行多次试验，如果相对差异满足\n$$\\frac{\\big|s_{1}-s_{2}\\big|}{\\big|s_{1}\\big|+\\big|s_{2}\\big|}\\leq \\varepsilon,$$\n其中 $\\varepsilon$ 的选择与机器精度在数量级上相当，并根据与问题相关的因素进行缩放，并且该不等式在多次试验中都成立，则声明伴随实现是正确的。\n\nC. 抽取独立的随机扰动 $\\delta x\\in\\mathbb{R}^{n}$ 和 $\\delta y\\in\\mathbb{R}^{m}$。对于一个小的容差 $\\varepsilon$，测试 $\\big\\|F'(x)\\delta x-A_{\\mathrm{adj}}\\delta y\\big\\|_{2}\\leq \\varepsilon$，如果该不等式在多次试验中都成立，则声明成功。\n\nD. 选择一个单一的随机扰动 $\\delta x\\in\\mathbb{R}^{n}$ 并设置 $\\delta y=F'(x)\\delta x$。使用标准的欧几里得内积测试 $\\big(F'(x)\\delta x\\big)^{\\top}\\delta y=\\delta x^{\\top}\\big(A_{\\mathrm{adj}}\\delta y\\big)$，如果等式在一个小的绝对容差 $\\varepsilon$ 内成立，则声明成功。", "solution": "用户希望我对照切线性模型 $F'(x)$ 来验证一个候选伴随实现 $A_{\\mathrm{adj}}$。\n\n首先，我将验证问题陈述。\n\n### 第一步：提取已知条件\n- 一个可微的离散正向模型 $F:\\mathbb{R}^{n}\\to\\mathbb{R}^{m}$。\n- 一个固定状态 $x\\in\\mathbb{R}^{n}$。\n- 状态空间是 $X=\\mathbb{R}^{n}$，配备内积 $\\langle u,v\\rangle_{X}=u^{\\top}W_{x}v$。\n- 观测空间是 $Y=\\mathbb{R}^{m}$，配备内积 $\\langle p,q\\rangle_{Y}=p^{\\top}W_{y}q$。\n- $W_{x}\\in\\mathbb{R}^{n\\times n}$ 和 $W_{y}\\in\\mathbb{R}^{m\\times m}$ 是对称正定 (SPD) 矩阵。\n- 一个切线性实现提供了雅可比矩阵 $F'(x)$ 在一个向量上的作用：$F'(x)\\delta x$。\n- 一个候选伴随算子实现 $A_{\\mathrm{adj}}:\\mathbb{R}^{m}\\to\\mathbb{R}^{n}$ 是可用的。\n- 目标是构建一个鲁棒的数值测试，使用随机扰动和缩放容差，以验证 $A_{\\mathrm{adj}}$ 是 $F'(x)$ 关于给定内积的正确伴随。\n\n### 第二步：使用提取的已知条件进行验证\n1.  **科学基础**：该问题基于线性代数和泛函分析的基本概念，特别是关于一般内积的伴随算子的定义。其背景是反演问题和数据同化，其中切线性和伴随模型是标准的计算工具。这是一个在科学计算中非常常见和实际的问题。该问题在科学上和数学上是合理的。\n2.  **适定性**：该问题要求正确地构建一个数值测试。伴随算子的定义是唯一且明确的，这导致了测试的唯一正确原则。该问题是适定的。\n3.  **客观性**：语言是正式、精确的，并使用标准的数学符号。它没有任何主观或模棱两可的术语。\n4.  **不完整或矛盾的设置**：问题提供了构建所需测试的所有必要定义和约束。信息是自洽和一致的。\n5.  **不切实际或不可行**：所描述的情景——通过“点积测试”来验证伴随代码——是在开发用于优化和数据同化的数值模型中的一个标准且必要的程序。这是非常现实的。\n6.  **病态或结构不良**：问题结构清晰，要求一个具体的结果：一个有效的测试程序。\n7.  **伪深刻、琐碎或同义反复**：这个问题并不琐碎，因为它要求在非标准（加权）内积存在的情况下正确应用伴随的定义，并理解鲁棒的数值比较技术。\n\n### 第三步：结论与行动\n问题陈述是有效的。我现在将继续解答。\n\n### 基于原理的推导\n线性算子的伴随是由其在相关空间的内积中的行为定义的。设 $L: X \\to Y$ 是两个内积空间 $X$ 和 $Y$ 之间的一个线性算子。其伴随算子，记作 $L^*: Y \\to X$，由以下关系唯一确定：\n$$ \\langle Lu, v \\rangle_Y = \\langle u, L^*v \\rangle_X, \\quad \\text{for all } u \\in X, v \\in Y $$\n在我们的问题中，线性算子是雅可比矩阵（切线性模型）$L = F'(x)$。向量空间是 $X = \\mathbb{R}^n$ 和 $Y = \\mathbb{R}^m$。向量是扰动 $u = \\delta x \\in \\mathbb{R}^n$ 和 $v = \\delta y \\in \\mathbb{R}^m$。内积是指定的加权内积：\n- $\\langle \\cdot, \\cdot \\rangle_X = \\langle \\cdot, \\cdot \\rangle_{\\mathbb{R}^n, W_x}$\n- $\\langle \\cdot, \\cdot \\rangle_Y = \\langle \\cdot, \\cdot \\rangle_{\\mathbb{R}^m, W_y}$\n\n将这些代入定义关系， $F'(x)$ 的伴随，记作 $(F'(x))^*$，必须满足：\n$$ \\langle F'(x)\\delta x, \\delta y \\rangle_Y = \\langle \\delta x, (F'(x))^*\\delta y \\rangle_X $$\n对于所有 $\\delta x \\in \\mathbb{R}^n$ 和 $\\delta y \\in \\mathbb{R}^m$。\n\n现在，我们使用给定的矩阵-向量定义来表示内积：\n- 左侧 (LHS) 是：$\\langle F'(x)\\delta x, \\delta y \\rangle_Y = \\big(F'(x)\\delta x\\big)^{\\top} W_y \\delta y$。\n- 右侧 (RHS) 是：$\\langle \\delta x, (F'(x))^*\\delta y \\rangle_X = \\delta x^{\\top} W_x \\big((F'(x))^*\\delta y\\big)$。\n\n为了验证我们的候选实现 $A_{\\mathrm{adj}}$ 是否正确，我们必须测试 $A_{\\mathrm{adj}} \\approx (F'(x))^*$ 是否成立。这是通过选择随机向量 $\\delta x$ 和 $\\delta y$，并检查当用 $A_{\\mathrm{adj}}$ 替代 $(F'(x))^*$ 时，定义等式是否成立来完成的。我们定义要比较的两个标量：\n$$ s_1 = \\big(F'(x)\\delta x\\big)^{\\top} W_y \\delta y $$\n$$ s_2 = \\delta x^{\\top} W_x \\big(A_{\\mathrm{adj}}\\delta y\\big) $$\n数值测试必须验证 $s_1 \\approx s_2$。在有限精度算术中，不期望 $s_1 = s_2$ 精确相等。比较必须使用一个对 $s_1$ 和 $s_2$ 的尺度具有鲁棒性的容差。绝对容差 $|s_1 - s_2| \\leq \\varepsilon$ 不具有鲁棒性。需要使用相对容差。一种特别鲁棒的相对误差形式，即使在 $s_1$ 或 $s_2$ 接近零时也表现良好，是\n$$ \\frac{|s_1 - s_2|}{|s_1| + |s_2|} \\leq \\varepsilon $$\n其中 $\\varepsilon$ 是一个小的容差，通常在机器精度的数量级。这是一个正确且鲁棒的伴随“点积测试”的基础。\n\n### 逐项分析\n\n**A. 从标准正态分布中抽取独立的随机扰动 $\\delta x\\in\\mathbb{R}^{n}$ 和 $\\delta y\\in\\mathbb{R}^{m}$。计算 $s_{1}=\\delta y^{\\top}\\big(F'(x)\\delta x\\big)$ 和 $s_{2}=\\delta x^{\\top}\\big(F'(x)^{\\top}\\delta y\\big)$。如果对于一个小的容差 $\\varepsilon$ 有 $\\big|s_{1}-s_{2}\\big|\\leq \\varepsilon\\,\\|\\delta x\\|_{2}\\,\\|\\delta y\\|_{2}$，则声明伴随实现是正确的。**\n\n这个选项有两个根本性缺陷。首先，它使用了标准的欧几里得内积（点积），此时 $W_x=I$ 和 $W_y=I$。问题明确指定了使用 SPD 矩阵 $W_x$ 和 $W_y$ 的加权内积。其次，它测试的是矩阵转置 $F'(x)^{\\top}$ 作为伴随的正确性，而不是用户提供的实现 $A_{\\mathrm{adj}}$。目标是验证代码 $A_{\\mathrm{adj}}$。\n\n**结论：不正确。**\n\n**B. 从标准正态分布中抽取独立的随机扰动 $\\delta x\\in\\mathbb{R}^{n}$ 和 $\\delta y\\in\\mathbb{R}^{m}$。计算 $s_{1}=\\big(F'(x)\\delta x\\big)^{\\top}W_{y}\\delta y$ 和 $s_{2}=\\delta x^{\\top}W_{x}\\big(A_{\\mathrm{adj}}\\delta y\\big)$。重复进行多次试验，如果相对差异满足 $\\frac{\\big|s_{1}-s_{2}\\big|}{\\big|s_{1}\\big|+\\big|s_{2}\\big|}\\leq \\varepsilon$，其中 $\\varepsilon$ 的选择与机器精度在数量级上相当，并根据与问题相关的因素进行缩放，并且该不等式在多次试验中都成立，则声明伴随实现是正确的。**\n\n这个选项使用指定的加权内积正确地表述了伴随恒等式的两边。\n- $s_1 = \\big(F'(x)\\delta x\\big)^{\\top}W_{y}\\delta y = \\langle F'(x)\\delta x, \\delta y \\rangle_Y$。\n- $s_2 = \\delta x^{\\top}W_{x}\\big(A_{\\mathrm{adj}}\\delta y\\big) = \\langle \\delta x, A_{\\mathrm{adj}}\\delta y \\rangle_X$。\n比较 $s_1$ 和 $s_2$ 是在测试候选算子 $A_{\\mathrm{adj}}$ 的伴随定义属性。它使用了一个鲁棒的相对误差度量，该度量随计算值的量级而缩放，这正是一个鲁棒数值测试所要求的。使用独立的随机向量并重复进行多次试验是标准的最佳实践。\n\n**结论：正确。**\n\n**C. 抽取独立的随机扰动 $\\delta x\\in\\mathbb{R}^{n}$ 和 $\\delta y\\in\\mathbb{R}^{m}$。对于一个小的容差 $\\varepsilon$，测试 $\\big\\|F'(x)\\delta x-A_{\\mathrm{adj}}\\delta y\\big\\|_{2}\\leq \\varepsilon$，如果该不等式在多次试验中都成立，则声明成功。**\n\n这种比较在数学上和维度上都是无意义的。向量 $F'(x)\\delta x$ 位于 $\\mathbb{R}^m$（观测空间），而向量 $A_{\\mathrm{adj}}\\delta y$ 位于 $\\mathbb{R}^n$（状态空间）。除非 $n=m$，否则减法没有定义。即使 $n=m$，也没有任何原理说明这两个向量在任何范数下都应该接近。切线性算子和伴随算子在不同空间之间进行映射。\n\n**结论：不正确。**\n\n**D. 选择一个单一的随机扰动 $\\delta x\\in\\mathbb{R}^{n}$ 并设置 $\\delta y=F'(x)\\delta x$。使用标准的欧几里得内积测试 $\\big(F'(x)\\delta x\\big)^{\\top}\\delta y=\\delta x^{\\top}\\big(A_{\\mathrm{adj}}\\delta y\\big)$，如果等式在一个小的绝对容差 $\\varepsilon$ 内成立，则声明成功。**\n\n这个选项有多个缺陷。首先，它使用了标准的欧几里得内积，忽略了指定的带矩阵 $W_x$ 和 $W_y$ 的加权内积。其次，它没有使用独立的随机向量；而是创建了一个依赖关系 $\\delta y = F'(x)\\delta x$。伴随属性必须对所有向量对都成立，而不仅仅是这个特定的、高度受限的子集。在如此小的子空间上进行测试不是一个通用或鲁棒的验证。第三，它使用了一个简单的绝对容差，其鲁棒性不如相对容差。\n\n**结论：不正确。**", "answer": "$$\\boxed{B}$$", "id": "3363680"}, {"introduction": "尽管点积检验可以验证核心算子，但梯度检验能够验证代价函数梯度的整个计算链。本练习探讨了如何使用有限差分来近似梯度，并将其与伴随方法计算的结果进行比较。更重要的是，它深入探讨了如何选择一个最优的扰动大小以平衡截断误差和舍入误差，这是进行稳健模型验证的一项至关重要的数值技能。[@problem_id:3363650]", "problem": "在数据同化背景下，考虑一个二次连续可微的代价泛函 $J: \\mathbb{R}^{n} \\to \\mathbb{R}$，并设 $x_{0} \\in \\mathbb{R}^{n}$ 为一个参考状态。假设已经推导并实现了一个伴随模型来计算梯度 $g = \\nabla J(x_{0})$。为了验证 $g$ 的正确性，一种做法是使用基于有限差分的方向导数检验。假设可以对 $J$ 进行浮点计算，其机器精度为 $\\varepsilon_{\\mathrm{mach}}$，并且 $J$ 在 $x_{0}$ 的一个邻域内允许泰勒展开，其 Hessian 矩阵为 $H(x_{0})$ 并存在更高阶的导数。仅使用基本定义（方向 $p$ 的方向导数为 $g^{\\top}p$）和关于 $J(x_{0} + h p)$ 的泰勒定理，论证在沿方向 $p$ 的方向导数的有限差分近似中出现的截断误差和舍入误差，以及应如何选择步长 $h$ 来平衡这些误差。\n\n下列哪个选项正确描述了对 $J(x_{0})$ 进行的、科学上合理的、基于方向导数的有限差分梯度检验，并提供了一个正确的、能平衡截断误差和舍入误差的步长选择规则？\n\nA. 选取一个方向 $p \\in \\mathbb{R}^{n}$ 且 $\\|p\\|_{2} = 1$，并计算中心差分方向导数\n$$D_{\\mathrm{fd}}(h) = \\frac{J(x_{0} + h p) - J(x_{0} - h p)}{2 h}.$$\n使用相对误差（例如 $\\left|D_{\\mathrm{fd}}(h) - g^{\\top}p\\right|/\\left|g^{\\top}p\\right|$）将 $D_{\\mathrm{fd}}(h)$ 与 $g^{\\top} p$ 进行比较。根据泰勒定理，截断误差为 $O(h^{2})$，而差商中的浮点舍入误差会导致一个量级为 $O\\!\\left(\\varepsilon_{\\mathrm{mach}}/h\\right)$ 的误差。平衡这些项可得出最优步长尺度 $h \\approx \\varepsilon_{\\mathrm{mach}}^{1/3}$，在实践中可以选择\n$$h = c\\,\\varepsilon_{\\mathrm{mach}}^{1/3}\\,\\frac{1+\\|x_{0}\\|_{2}}{\\|p\\|_{2}},$$\n其中 $c$ 是一个量级为 1 的适中常数，使得扰动相对于 $x_{0}$ 的量级和 $p$ 的尺度。\n\nB. 选取一个方向 $p$ 并使用前向差分\n$$D_{\\mathrm{fd}}(h) = \\frac{J(x_{0} + h p) - J(x_{0})}{h}.$$\n因为当 $h \\to 0$ 时，有限差分总是改进的，所以选择 $h = \\varepsilon_{\\mathrm{mach}}$ 来最小化截断误差和舍入误差；截断误差为 $O(h^{2})$，因此只有当 $h$ 较大时，舍入误差才占主导地位。\n\nC. 使用中心差分方向导数\n$$D_{\\mathrm{cd}}(h) = \\frac{J(x_{0} + h p) - J(x_{0} - h p)}{2 h},$$\n并始终让 $h \\to 0$ 直至下溢，因为舍入误差随 $h$ 减小而截断误差可以忽略不计；因此，不需要进行平衡，可表示的最小 $h$ 是最优的。\n\nD. 选取一个方向 $p$ 且 $\\|p\\|_{2} = 1$，并计算前向差分方向导数\n$$D_{\\mathrm{fd}}(h) = \\frac{J(x_{0} + h p) - J(x_{0})}{h}.$$\n使用相对误差将 $D_{\\mathrm{fd}}(h)$ 与 $g^{\\top} p$ 进行比较。泰勒定理给出截断误差的量级为 $O(h)$，而差商中的浮点舍入误差贡献了一个量级为 $O\\!\\left(\\varepsilon_{\\mathrm{mach}}/h\\right)$ 的误差。平衡这些项可得出最优步长尺度 $h \\approx \\varepsilon_{\\mathrm{mach}}^{1/2}$，在实践中可以采用\n$$h = c\\,\\varepsilon_{\\mathrm{mach}}^{1/2}\\,\\frac{1+\\|x_{0}\\|_{2}}{\\|p\\|_{2}},$$\n其中 $c$ 是一个量级为 1 的适中常数，以尊重 $x_{0}$ 和 $p$ 的尺度。\n\nE. 为避免随机方向，对每个分量使用 $p = e_{i}$ 将 $g$ 与坐标方向的差分进行比较，并使用中心差分，其中步长 $h$ 统一且独立于 $\\|x_{0}\\|_{2}$ 和 $\\|p\\|_{2}$，且 $h \\approx \\varepsilon_{\\mathrm{mach}}^{1/3}\\,\\|p\\|_{2}$；基于 $x_{0}$ 量级的尺度选择是不必要的，因为截断误差不依赖于变量的尺度。", "solution": "用户希望我根据严格的协议验证问题陈述，如果有效，则提供详细的解决方案。\n\n### 第1步：提取已知条件\n- **代价泛函：** $J: \\mathbb{R}^{n} \\to \\mathbb{R}$ 是二次连续可微 ($C^2$) 的。\n- **参考状态：** $x_{0} \\in \\mathbb{R}^{n}$。\n- **梯度：** 梯度 $g = \\nabla J(x_{0})$ 由一个伴随模型计算得出。\n- **验证目标：** 使用基于有限差分的方向导数检验来检查 $g$ 的正确性。\n- **数值精度：** $J$ 的浮点计算具有机器精度 $\\varepsilon_{\\mathrm{mach}}$。\n- **泰勒展开：** $J$ 在 $x_{0}$ 的一个邻域内允许泰勒展开，其 Hessian 矩阵为 $H(x_{0})$ 并存在更高阶的导数。\n- **方向导数：** $J$ 在 $x_{0}$ 沿方向 $p$ 的真实方向导数由 $g^{\\top}p$ 给出。\n- **核心问题：** 分析方向导数的有限差分近似中的截断误差和舍入误差，确定平衡这些误差的最优步长 $h$，并识别正确描述此过程的选项。\n\n### 第2步：使用提取的已知条件进行验证\n该问题陈述是数值分析和灵敏度分析中的一个标准练习，特别与优化和数据同化中梯度计算的验证相关。\n- **科学依据：** 该问题牢固地建立在微积分（泰勒定理）、数值分析（有限差分）和计算机算术（浮点舍入误差）的基本原理之上。这些概念是科学计算的核心。该场景是现实的，在实践中很常见。\n- **适定的：** 问题定义清晰。它要求基于基本原理分析误差，并就参数（$h$）的最优选择得出结论，从而对给定的陈述进行评估。可以推导出关于每个选项正确性的确定、唯一的答案。\n- **客观性：** 语言是正式、精确的，没有主观或模糊的术语。所有使用的术语（$C^2$、梯度、Hessian、机器精度）都有严格的数学定义。\n\n我没有根据检查清单发现任何缺陷。该问题并非不合理、不完整、不现实、不适定或微不足道。这是一个有效、表述良好的数值方法问题。\n\n### 第3步：结论与行动\n该问题是**有效的**。我将继续进行解答。\n\n### 从第一性原理推导\n\n设 $\\phi(h) = J(x_{0} + h p)$。$J$ 在 $x_{0}$ 沿方向 $p$ 的方向导数是 $\\phi'(0)$。根据链式法则，$\\phi'(h) = \\nabla J(x_{0} + h p)^{\\top} p$，因此我们希望近似的精确值是 $\\phi'(0) = \\nabla J(x_{0})^{\\top} p = g^{\\top}p$。假设代价函数 $J$ 至少是二次连续可微的，并且问题陈述其存在更高阶导数，允许进行泰勒级数展开。\n\n**1. 前向差分公式分析**\n\n前向差分近似由下式给出：\n$$D_{\\mathrm{fd}}(h) = \\frac{J(x_{0} + h p) - J(x_{0})}{h} = \\frac{\\phi(h) - \\phi(0)}{h}$$\n\n*   **截断误差：** 我们将 $\\phi(h)$ 在 $h=0$ 附近进行泰勒级数展开：\n    $$\\phi(h) = \\phi(0) + h \\phi'(0) + \\frac{h^2}{2} \\phi''(0) + O(h^3)$$\n    将此代入 $D_{\\mathrm{fd}}(h)$ 的公式中：\n    $$D_{\\mathrm{fd}}(h) = \\frac{(\\phi(0) + h \\phi'(0) + \\frac{h^2}{2} \\phi''(0) + O(h^3)) - \\phi(0)}{h} = \\phi'(0) + \\frac{h}{2} \\phi''(0) + O(h^2)$$\n    因此，截断误差 $E_{\\mathrm{trunc,fd}} = D_{\\mathrm{fd}}(h) - \\phi'(0)$ 的量级为 $O(h)$：\n    $$E_{\\mathrm{trunc,fd}} = \\frac{h}{2} p^{\\top} H(x_{0}) p + O(h^2)$$\n    其中 $H(x_0)$ 是 $J$ 在 $x_0$ 处的 Hessian 矩阵。\n\n*   **舍入误差：** 在浮点运算中，计算出的 $J$ 值是不精确的。设 $\\text{fl}(J(x))$ 表示计算值。一个简单的误差模型假设误差与函数的大小成正比，因此 $\\text{fl}(J(x)) = J(x) + \\delta_x$，其中 $|\\delta_x| \\lesssim \\varepsilon_{\\mathrm{mach}} |J(x)|$。分子的计算结果为 $\\text{fl}(J(x_{0} + h p)) - \\text{fl}(J(x_{0}))$，其绝对误差大小约为 $2 \\varepsilon_{\\mathrm{mach}} M$，其中 $M$ 是 $J$ 在 $x_0$ 附近的一个特征量级。当除以小步长 $h$ 时，这个误差被放大。因此，最终结果中的舍入误差 $E_{\\mathrm{round,fd}}$ 的量级为 $O(\\varepsilon_{\\mathrm{mach}}/h)$。\n\n*   **最优步长：** 总误差是截断误差和舍入误差大小之和：\n    $$E_{\\mathrm{total,fd}}(h) \\approx C_{1}h + C_{2}\\frac{\\varepsilon_{\\mathrm{mach}}}{h}$$\n    为了找到最小误差，我们对 $h$ 求导并令其为零：\n    $$\\frac{dE_{\\mathrm{total,fd}}}{dh} = C_{1} - C_{2}\\frac{\\varepsilon_{\\mathrm{mach}}}{h^2} = 0 \\implies h^2 = \\frac{C_{2}}{C_{1}}\\varepsilon_{\\mathrm{mach}}$$\n    这意味着最优步长 $h_{\\mathrm{opt}}$ 的尺度为 $h_{\\mathrm{opt}} \\propto \\sqrt{\\varepsilon_{\\mathrm{mach}}}$ 或 $h_{\\mathrm{opt}} \\approx \\varepsilon_{\\mathrm{mach}}^{1/2}$。\n\n**2. 中心差分公式分析**\n\n中心差分近似由下式给出：\n$$D_{\\mathrm{cd}}(h) = \\frac{J(x_{0} + h p) - J(x_{0} - h p)}{2h} = \\frac{\\phi(h) - \\phi(-h)}{2h}$$\n\n*   **截断误差：** 我们使用更高阶的泰勒展开：\n    $$\\phi(h) = \\phi(0) + h \\phi'(0) + \\frac{h^2}{2} \\phi''(0) + \\frac{h^3}{6} \\phi'''(0) + O(h^4)$$\n    $$\\phi(-h) = \\phi(0) - h \\phi'(0) + \\frac{h^2}{2} \\phi''(0) - \\frac{h^3}{6} \\phi'''(0) + O(h^4)$$\n    用前者减去后者：\n    $$\\phi(h) - \\phi(-h) = 2h \\phi'(0) + \\frac{h^3}{3} \\phi'''(0) + O(h^5)$$\n    将此代入 $D_{\\mathrm{cd}}(h)$ 的公式中：\n    $$D_{\\mathrm{cd}}(h) = \\frac{2h \\phi'(0) + \\frac{h^3}{3} \\phi'''(0) + O(h^5)}{2h} = \\phi'(0) + \\frac{h^2}{6} \\phi'''(0) + O(h^4)$$\n    因此，截断误差 $E_{\\mathrm{trunc,cd}} = D_{\\mathrm{cd}}(h) - \\phi'(0)$ 的量级为 $O(h^2)$。\n\n*   **舍入误差：** 分析与前向差分情况类似。分子中的误差量级为 $\\varepsilon_{\\mathrm{mach}}$，除以 $2h$ 后，导致的舍入误差 $E_{\\mathrm{round,cd}}$ 的量级为 $O(\\varepsilon_{\\mathrm{mach}}/h)$。\n\n*   **最优步长：** 总误差为：\n    $$E_{\\mathrm{total,cd}}(h) \\approx C_{3}h^2 + C_{4}\\frac{\\varepsilon_{\\mathrm{mach}}}{h}$$\n    求导并令其为零：\n    $$\\frac{dE_{\\mathrm{total,cd}}}{dh} = 2C_{3}h - C_{4}\\frac{\\varepsilon_{\\mathrm{mach}}}{h^2} = 0 \\implies h^3 = \\frac{C_{4}}{2C_{3}}\\varepsilon_{\\mathrm{mach}}$$\n    这意味着最优步长 $h_{\\mathrm{opt}}$ 的尺度为 $h_{\\mathrm{opt}} \\propto \\sqrt[3]{\\varepsilon_{\\mathrm{mach}}}$ 或 $h_{\\mathrm{opt}} \\approx \\varepsilon_{\\mathrm{mach}}^{1/3}$。\n\n### 逐项分析\n\n**A. 选取一个方向 $p \\in \\mathbb{R}^{n}$ 且 $\\|p\\|_{2} = 1$，并计算中心差分方向导数...**\n该选项使用中心差分公式。它正确地指出截断误差为 $O(h^2)$，舍入误差为 $O(\\varepsilon_{\\mathrm{mach}}/h)$。它正确地推断出平衡这些误差项可以得到最优步长尺度 $h \\approx \\varepsilon_{\\mathrm{mach}}^{1/3}$。所提出的实用步长公式 $h = c\\,\\varepsilon_{\\mathrm{mach}}^{1/3}\\,\\frac{1+\\|x_{0}\\|_{2}}{\\|p\\|_{2}}$，在按建议设置 $\\|p\\|_2=1$ 后，变为 $h = c\\,\\varepsilon_{\\mathrm{mach}}^{1/3}\\,(1+\\|x_{0}\\|_{2})$。这是一个标准且合理的启发式方法，它将扰动 $hp$ 的大小调整为与状态向量 $x_0$ 的量级相关，这对于 $\\|x_0\\|$ 非常大或非常小的问题很重要。该选项的所有部分都是正确的。\n**结论：正确**\n\n**B. 选取一个方向 $p$ 并使用前向差分...**\n该选项使用前向差分公式，但犯了两个关键错误。首先，它声称截断误差是 $O(h^2)$，这是不正确的；它应为 $O(h)$。其次，它声称当 $h \\to 0$ 时两个误差都最小化，并建议 $h = \\varepsilon_{\\mathrm{mach}}$。这在根本上是错误的，因为量级为 $O(\\varepsilon_{\\mathrm{mach}}/h)$ 的舍入误差在 $h \\to 0$ 时会发散。存在一个最优的非零 $h$ 来平衡相互竞争的误差源。\n**结论：不正确**\n\n**C. 使用中心差分方向导数...，并始终让 $h \\to 0$ 直至下溢...**\n该选项正确地指出了中心差分公式，但犯了与选项B相同的根本错误。它断言“舍入误差随 $h$ 减小而减小”，这与事实正好相反。$O(\\varepsilon_{\\mathrm{mach}}/h)$ 的依赖关系意味着舍入误差在 $h$ 非常小时占主导地位，导致灾难性抵消。可表示的最小 $h$ 远非最优。\n**结论：不正确**\n\n**D. 选取一个方向 $p$ 且 $\\|p\\|_{2} = 1$，并计算前向差分方向导数...**\n该选项使用前向差分公式。它正确地指出截断误差的量级为 $O(h)$，舍入误差的量级为 $O(\\varepsilon_{\\mathrm{mach}}/h)$。它正确地平衡了这两个误差项，找到了最优步长尺度 $h \\approx \\varepsilon_{\\mathrm{mach}}^{1/2}$。所提出的实用步长公式是前向差分情况下相应的启发式方法，类似于选项A中的方法。尽管中心差分通常是更好的方法，但这里提出的前向差分检验的整个分析和描述在科学上是合理的并且内部一致。\n**结论：正确**\n\n**E. 为避免随机方向，对每个分量使用 $p = e_{i}$ 将 $g$ 与坐标方向的差分进行比较...**\n使用坐标方向 $p=e_i$ 是一个有效的策略。该选项正确地指出了中心差分方案和 $h \\approx \\varepsilon_{\\mathrm{mach}}^{1/3}$ 的尺度。然而，它做出了一个有缺陷的断言：“基于 $x_{0}$ 量级的尺度选择是不必要的，因为截断误差不依赖于变量的尺度。” 这是错误的。$O(h^2)$ 截断误差项中的常数涉及 $J$ 的三阶导数。这些导数通常取决于评估点 $x_0$。如果 $x_0$ 的分量有巨大差异的尺度，统一的扰动步长可能是不合适的。例如，如果 $J(x) = (ax)^4$，其三阶导数是 $24a^4x$，这明确依赖于变量的尺度。因此，不根据 $\\|x_0\\|$ 进行缩放的理由在科学上是不合理的。\n**结论：不正确**", "answer": "$$\\boxed{AD}$$", "id": "3363650"}, {"introduction": "伴随方法功能强大，但对于长时间积分的模型，标准的反向传播算法会因需要存储整个前向轨迹而变得内存成本过高。这个高级练习介绍了检查点（checkpointing）技术，它以一定的重复计算为代价，极大地减少了内存需求。您将把这种方法应用于一个现代的基于长短期记忆（LSTM）的模型，学习如何在实际的大规模应用中管理内存与时间之间的权衡。[@problem_id:3363611]", "problem": "考虑一个基于长短期记忆（LSTM）的时间离散代理模型，该模型用于基于梯度的数据同化循环，例如四维变分同化。LSTM 单元使用标准门控机制更新隐藏状态和单元状态。设时间步 $t$ 的输入为 $x_t \\in \\mathbb{R}^m$，隐藏状态为 $h_t \\in \\mathbb{R}^n$，单元状态为 $c_t \\in \\mathbb{R}^n$。可训练参数为 $\\theta$，由四个门的仿射映射和一个仿射输出映射组成。LSTM 的更新定义如下：\n$$\na^{(i)}_t = W^{(i)} x_t + U^{(i)} h_{t-1} + b^{(i)}, \\quad i_t = \\sigma\\!\\left(a^{(i)}_t\\right),\n$$\n$$\na^{(f)}_t = W^{(f)} x_t + U^{(f)} h_{t-1} + b^{(f)}, \\quad f_t = \\sigma\\!\\left(a^{(f)}_t\\right),\n$$\n$$\na^{(o)}_t = W^{(o)} x_t + U^{(o)} h_{t-1} + b^{(o)}, \\quad o_t = \\sigma\\!\\left(a^{(o)}_t\\right),\n$$\n$$\na^{(g)}_t = W^{(g)} x_t + U^{(g)} h_{t-1} + b^{(g)}, \\quad g_t = \\tanh\\!\\left(a^{(g)}_t\\right),\n$$\n$$\nc_t = f_t \\odot c_{t-1} + i_t \\odot g_t,\\quad h_t = o_t \\odot \\tanh\\!\\left(c_t\\right),\n$$\n其中 $\\sigma(\\cdot)$ 是 logistic sigmoid 函数，$\\tanh(\\cdot)$ 是双曲正切函数，$\\odot$ 表示逐元素乘法。模型输出为\n$$\ny_t = V h_t + b_y,\n$$\n其中 $V \\in \\mathbb{R}^{p \\times n}$ 和 $b_y \\in \\mathbb{R}^p$ 包含在 $\\theta$ 中。在 $T$ 个时间步的时域内，同化代价为\n$$\nJ(\\theta) = \\frac{1}{2} \\sum_{t=1}^{T} \\left\\|y_t - y^{\\mathrm{obs}}_t\\right\\|_2^2,\n$$\n其中 $y^{\\mathrm{obs}}_t \\in \\mathbb{R}^p$ 是给定的观测值。本问题中所有量均为无量纲；请勿引入任何物理单位。\n\n任务：仅从离散时间系统的链式法则和上述定义出发，推导 LSTM 单元的离散伴随递推关系以及梯度 $\\nabla_{\\theta} J$。接下来，设计并实现两种梯度计算策略：\n(1) 标准的随时间反向传播（BPTT），它存储反向扫描所需的所有中间状态；以及\n(2) 具有统一段长度 $s$ 的带检查点的离散伴随，它只在段边界存储状态，并在反向扫描期间重新计算段内的前向状态。\n\n您必须在一个可运行的程序中实现这两种策略，该程序：\n(i) 使用 BPTT 计算 $\\nabla_{\\theta} J$，\n(ii) 使用带检查点的伴随计算 $\\nabla_{\\theta} J$，以及\n(iii) 报告每个测试案例中两个梯度向量之差的范数。此外，对于每个测试案例，您必须根据以下归一化指标报告两种策略的理论内存和时间成本：\n- 内存成本是在反向传播过程中为保留前向状态而专门存储的浮点标量的数量。对于 BPTT，假设存储所有时间步的门输出 $i_t, f_t, o_t, g_t$ 和状态 $c_t, h_t$，因此每步的存储量为 $6n$。对于检查点方法，假设仅为当前长度为 $s$ 的段存储这些量，外加在每个段边界和初始时间存储检查点状态 $(h,c)$。因此，内存为 $6ns + 2n(S+1)$，其中 $S = \\lceil T/s \\rceil$。\n- 时间成本是以每步单元评估为单位计算的 LSTM 单元前向/后向评估的整数次数。对于 BPTT，计为 $2T$（一次前向扫描和一次反向扫描）。对于带检查点的伴随，计为 $3T$（一次初始前向扫描，所有段总长度为 $T$ 的一次前向重计算，以及一次反向扫描）。\n\n您的程序必须执行以下测试套件并汇总结果：\n- 案例 1（正常路径）：$T=64$, $m=4$, $n=3$, $p=2$, $s=16$。\n- 案例 2（边界情况，$s=T$）：$T=64$, $m=4$, $n=3$, $p=2$, $s=64$。\n- 案例 3（边缘情况，$s=1$）：$T=64$, $m=4$, $n=3$, $p=2$, $s=1$。\n\n对于每个案例，使用一组单独的“真实”参数生成固定的随机输入序列 $\\{x_t\\}_{t=1}^T$ 和固定的观测值 $\\{y^{\\mathrm{obs}}_t\\}_{t=1}^T$，以确保确定性可复现性。使用一组不同的参数初始化同化模型，以产生一个非平凡的梯度。使用初始状态 $h_0 = 0$ 和 $c_0 = 0$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试案例的结果必须是一个五元列表 $[\\Delta, M_{\\mathrm{BPTT}}, M_{\\mathrm{CHK}}, T_{\\mathrm{BPTT}}, T_{\\mathrm{CHK}}]$，其中 $\\Delta$ 是两个梯度向量之差的浮点范数，$M_{\\mathrm{BPTT}}$ 和 $M_{\\mathrm{CHK}}$ 是整数，$T_{\\mathrm{BPTT}}$ 和 $T_{\\mathrm{CHK}}$ 也是整数。三个案例的结果必须汇总到一个列表的列表中，不含任何额外文本，例如：$[[\\Delta_1,M_1^{\\mathrm{B}},M_1^{\\mathrm{C}},T_1^{\\mathrm{B}},T_1^{\\mathrm{C}}],[\\Delta_2,\\dots],[\\Delta_3,\\dots]]$。", "solution": "任务是推导标准长短期记忆（LSTM）单元的离散伴随模型，并计算代价函数关于模型参数 $\\theta$ 的梯度 $\\nabla_{\\theta} J$。然后，我们将实现两种计算策略：标准的随时间反向传播（BPTT）和带检查点的伴随方法。\n\n我们首先正式陈述前向传播模型和代价函数。\n在时间步 $t$，LSTM 单元的状态由隐藏状态 $h_t \\in \\mathbb{R}^n$ 和单元状态 $c_t \\in \\mathbb{R}^n$ 描述。该模型由外部输入 $x_t \\in \\mathbb{R}^m$ 驱动。从时间 $t-1$ 到 $t$ 的更新由以下方程组给出：\n$$a^{(i)}_t = W^{(i)} x_t + U^{(i)} h_{t-1} + b^{(i)}$$\n$$i_t = \\sigma(a^{(i)}_t) \\quad (\\text{输入门})$$\n$$a^{(f)}_t = W^{(f)} x_t + U^{(f)} h_{t-1} + b^{(f)}$$\n$$f_t = \\sigma(a^{(f)}_t) \\quad (\\text{遗忘门})$$\n$$a^{(o)}_t = W^{(o)} x_t + U^{(o)} h_{t-1} + b^{(o)}$$\n$$o_t = \\sigma(a^{(o)}_t) \\quad (\\text{输出门})$$\n$$a^{(g)}_t = W^{(g)} x_t + U^{(g)} h_{t-1} + b^{(g)}$$\n$$g_t = \\tanh(a^{(g)}_t) \\quad (\\text{单元输入/候选状态})$$\n然后，单元状态和隐藏状态更新如下：\n$$c_t = f_t \\odot c_{t-1} + i_t \\odot g_t$$\n$$h_t = o_t \\odot \\tanh(c_t)$$\n其中 $\\sigma(\\cdot)$ 是 logistic sigmoid 函数，$\\tanh(\\cdot)$ 是双曲正切函数，$\\odot$ 表示逐元素（哈达玛）乘积。模型参数 $\\theta$ 包括权重矩阵 $\\{W^{(k)}, U^{(k)}\\}_{k \\in \\{i,f,o,g\\}}$、偏置向量 $\\{b^{(k)}\\}_{k \\in \\{i,f,o,g\\}}$，以及输出层的参数 $V \\in \\mathbb{R}^{p \\times n}$ 和 $b_y \\in \\mathbb{R}^p$。\n\n在时间 $t$ 的模型输出是隐藏状态的仿射变换：\n$$y_t = V h_t + b_y$$\n要最小化的代价函数 $J(\\theta)$ 是在 $T$ 个时间步的时域内的平方误差之和：\n$$J(\\theta) = \\frac{1}{2} \\sum_{t=1}^{T} \\|y_t - y^{\\mathrm{obs}}_t\\|_2^2$$\n其中 $y^{\\mathrm{obs}}_t \\in \\mathbb{R}^p$ 是观测值。初始状态给定为 $h_0 = 0$ 和 $c_0 = 0$。\n\n梯度 $\\nabla_{\\theta} J$ 使用伴随方法推导，这是链式法则的一个应用。令 $\\lambda_z \\equiv \\nabla_z J$ 表示代价函数 $J$ 相对于任意变量 $z$ 的伴随（梯度）。伴随变量随时间向后传播。\n\n需要激活函数的导数：\n$$\\frac{d\\sigma(z)}{dz} = \\sigma(z)(1-\\sigma(z))$$\n$$\\frac{d\\tanh(z)}{dz} = 1 - \\tanh^2(z)$$\n对于向量参数 $z$，雅可比矩阵是一个对角矩阵。如果 $q = \\sigma(z)$，则 $\\nabla_z q = \\mathrm{diag}(\\sigma(z) \\odot (1-\\sigma(z)))$。为简洁起见，并且由于所有运算都是逐元素的，我们将使用 $\\sigma'(z)$ 表示逐元素导数的向量。\n\n伴随方法从 $t=T$ 向后进行到 $t=1$。在每个时间步 $t$，我们计算该步参数的梯度，然后将伴随状态传播到时间 $t-1$。令 $\\lambda_{h,t}^{\\text{next}}$ 和 $\\lambda_{c,t}^{\\text{next}}$ 为从 $t+1$ 步的计算中传递过来的 $h_t$ 和 $c_t$ 的伴随。对于最后一步 $t=T$，这些值为零：$\\lambda_{h,T}^{\\text{next}} = 0$ 和 $\\lambda_{c,T}^{\\text{next}} = 0$。\n\n在每个时间步 $t$（从 $t=T$ 向下到 $1$）的步骤如下：\n\n1.  **计算 $h_t$ 和 $c_t$ 的总伴随**：\n    代价函数 $J$ 通过 $\\|y_t - y_t^{\\mathrm{obs}}\\|_2^2$ 项直接依赖于 $h_t$，并通过 $t+1$ 时的状态间接依赖于 $h_t$。\n    代价函数相对于输出 $y_t$ 的伴随为 $\\lambda_{y_t} = \\nabla_{y_t} J = y_t - y_t^{\\mathrm{obs}}$。\n    $h_t$ 的总伴随，记为 $\\lambda_{h,t}$，结合了来自时间 $t$ 代价的局部梯度和从时间 $t+1$ 传播过来的梯度：\n    $$\\lambda_{h,t} = (\\nabla_{h_t} y_t)^T \\lambda_{y_t} + \\lambda_{h,t}^{\\text{next}} = V^T(y_t - y_t^{\\mathrm{obs}}) + \\lambda_{h,t}^{\\text{next}}$$\n    状态 $c_t$ 通过 $h_t$ 以及 $c_{t+1}$ 的递推关系影响 $J$。$c_t$ 的总伴随，记为 $\\lambda_{c,t}$，是：\n    $$\\lambda_{c,t} = (\\nabla_{c_t} h_t)^T \\lambda_{h,t} + \\lambda_{c,t}^{\\text{next}} = \\lambda_{h,t} \\odot o_t \\odot (1 - \\tanh^2(c_t)) + \\lambda_{c,t}^{\\text{next}}$$\n\n2.  **计算门和预激活的伴随**：\n    使用链式法则，我们通过单元结构进行反向传播：\n    $$\\lambda_{o_t} = (\\nabla_{o_t} h_t)^T \\lambda_{h,t} = \\lambda_{h,t} \\odot \\tanh(c_t)$$\n    $$\\lambda_{g_t} = (\\nabla_{g_t} c_t)^T \\lambda_{c_t} = \\lambda_{c_t} \\odot i_t$$\n    $$\\lambda_{i_t} = (\\nabla_{i_t} c_t)^T \\lambda_{c_t} = \\lambda_{c_t} \\odot g_t$$\n    $$\\lambda_{f_t} = (\\nabla_{f_t} c_t)^T \\lambda_{c_t} = \\lambda_{c_t} \\odot c_{t-1}$$\n    然后，通过激活函数反向传播到预激活变量 $a_t$：\n    $$\\lambda_{a^{(o)}_t} = \\lambda_{o_t} \\odot \\sigma'(a^{(o)}_t) = \\lambda_{o_t} \\odot o_t \\odot (1 - o_t)$$\n    $$\\lambda_{a^{(g)}_t} = \\lambda_{g_t} \\odot \\tanh'(a^{(g)}_t) = \\lambda_{g_t} \\odot (1 - g_t^2)$$\n    $$\\lambda_{a^{(i)}_t} = \\lambda_{i_t} \\odot \\sigma'(a^{(i)}_t) = \\lambda_{i_t} \\odot i_t \\odot (1 - i_t)$$\n    $$\\lambda_{a^{(f)}_t} = \\lambda_{f_t} \\odot \\sigma'(a^{(f)}_t) = \\lambda_{f_t} \\odot f_t \\odot (1 - f_t)$$\n\n3.  **计算第 $t$ 步的参数梯度**：\n    代价函数关于参数的梯度是在所有时间步上累加的。来自第 $t$ 步的贡献是：\n    对于 $k \\in \\{i,f,o,g\\}$：\n    $$\\nabla_{W^{(k)}_t} J = \\lambda_{a^{(k)}_t} x_t^T$$\n    $$\\nabla_{U^{(k)}_t} J = \\lambda_{a^{(k)}_t} h_{t-1}^T$$\n    $$\\nabla_{b^{(k)}_t} J = \\lambda_{a^{(k)}_t}$$\n    对于输出层：\n    $$\\nabla_{V_t} J = (y_t - y_t^{\\mathrm{obs}}) h_t^T$$\n    $$\\nabla_{b_{y,t}} J = y_t - y_t^{\\mathrm{obs}}$$\n    总梯度为 $\\nabla_{\\theta} J = \\sum_{t=1}^T \\nabla_{\\theta_t} J$。\n\n4.  **将伴随传播到时间 $t-1$**：\n    最后，我们计算要传递给上一步的 $h_{t-1}$ 和 $c_{t-1}$ 的伴随。\n    $$\\lambda_{h,t-1}^{\\text{next}} = \\sum_{k \\in \\{i,f,o,g\\}} (\\nabla_{h_{t-1}} a^{(k)}_t)^T \\lambda_{a^{(k)}_t} = \\sum_{k \\in \\{i,f,o,g\\}} (U^{(k)})^T \\lambda_{a^{(k)}_t}$$\n    $$\\lambda_{c,t-1}^{\\text{next}} = (\\nabla_{c_{t-1}} c_t)^T \\lambda_{c_t} = \\lambda_{c_t} \\odot f_t$$\n    这些成为 $t-1$ 迭代的 `next` 值。\n\n**实现策略：**\n\n**1. 随时间反向传播 (BPTT):**\n这是训练循环神经网络的标准算法。\n- **前向传播：** 从 $t=1$ 到 $T$ 迭代。在每一步，计算 LSTM 状态和输出。反向传播所需的所有中间变量（$x_t, h_{t-1}, c_{t-1}, i_t, f_t, o_t, g_t, c_t, h_t$）都会在每个时间步存储在内存中。\n- **反向传播：** 从 $t=T$ 到 $1$ 迭代。在每一步，检索存储的前向传播变量。应用上面推导的伴随方程来计算参数梯度，并将伴随状态 $\\lambda_h$ 和 $\\lambda_c$ 传播到前一个时间步。参数梯度被累加。\n\n**2. 带检查点的伴随：**\n该策略以增加计算为代价来减少内存使用。它是递归 BPTT 的一种形式。\n- **初始前向传播：** 模型从 $t=1$ 运行到 $T$。然而，只在特定间隔（称为检查点）存储状态 $(h_t, c_t)$。段的长度为 $s$。检查点在时间 $t_k = k \\cdot s$ 处存储。\n- **带重计算的反向传播：** 反向传播逐段进行，从最后一个段到第一个段。对于每个段 $[t_k+1, t_{k+1}]$：\n    a. 从检查点内存中加载状态 $(h_{t_k}, c_{t_k})$。\n    b. 在该段上执行前向重计算，以重新生成所有必要的中间变量。这些变量仅为该段临时存储。\n    c. 使用重计算的中间变量和来自下一段的传入伴随，在该段上执行反向传播。这将计算该段的参数梯度和段开始处的伴随 $(\\lambda_{h,t_k}, \\lambda_{c,t_k})$。\n    d. 丢弃该段的临时存储。\n这个过程避免了同时存储前向传播的整个历史记录。\n所提供的理论成本指标用于分析，代表了一种权衡：检查点方法使用更少的内存（对于小的 $s$，$M_{CHK}  M_{BPTT}$），但需要更多的计算时间（$T_{CHK} > T_{BPTT}$）。\n\n该实现将构建这两种算法，并验证它们产生数值上相同的梯度，从而证实推导和实现的正确性。", "answer": "[[0.00000000e+00,1152,318,128,192],[0.00000000e+00,1152,1164,128,192],[0.00000000e+00,1152,408,128,192]]", "id": "3363611"}]}