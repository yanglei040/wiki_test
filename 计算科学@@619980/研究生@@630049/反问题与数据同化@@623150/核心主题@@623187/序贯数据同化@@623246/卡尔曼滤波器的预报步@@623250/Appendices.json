{"hands_on_practices": [{"introduction": "卡尔曼滤波预测步骤的核心在于理解状态不确定性是如何随时间演化的。本练习将从第一性原理出发，推导预测协方差的更新方程，帮助你理解该过程的两个基本组成部分：现有不确定性通过系统动力学的传播，以及模型噪声引入的新不确定性。通过分析动力学矩阵 $A$ 的特征值如何影响不确定性的放大或衰减，你将对预测的内在机制建立起深刻的直觉。[@problem_id:3381758]", "problem": "考虑一个用于反演问题和数据同化中卡尔曼滤波器 (KF) 预测步骤的线性高斯状态转移模型。状态演化遵循 $x_{k} = A x_{k-1} + w_{k-1}$，其中 $x_{k} \\in \\mathbb{R}^{n}$ 是时刻 $k$ 的状态，$A \\in \\mathbb{R}^{n \\times n}$ 是线性传播算子，$w_{k-1}$ 是独立于 $x_{k-1}$ 的零均值过程噪声。设前一时刻的后验协方差为 $P_{k-1|k-1} = \\operatorname{Cov}(x_{k-1} \\mid y_{1:k-1})$。\n\n从协方差的定义出发，仅使用期望、独立性和随机向量线性变换的性质，推导预测协方差 $P_{k|k-1} = \\operatorname{Cov}(x_k \\mid y_{1:k-1})$ 的表达式，并对以下 $n=2$ 的数值案例进行计算：\n$$\nA = \\begin{pmatrix}\n1.5  0.4 \\\\\n0.2  0.7\n\\end{pmatrix}, \\quad\nP_{k-1|k-1} = \\begin{pmatrix}\n2.0  0.5 \\\\\n0.5  1.0\n\\end{pmatrix}, \\quad\nQ = \\begin{pmatrix}\n0.3  0.0 \\\\\n0.0  0.2\n\\end{pmatrix}.\n$$\n然后，基于协方差在线性映射下如何变换的第一性原理，论证算子 $A$ 是沿着其主方向放大还是抑制了预测不确定性，并解释原因。\n\n请精确提供 $P_{k|k-1}$ 的数值矩阵，无需四舍五入。你的最终答案必须是矩阵 $P_{k|k-1}$。", "solution": "在尝试求解之前，对问题陈述进行了严格验证。\n\n### 步骤 1：提取已知条件\n-   状态演化模型：$x_{k} = A x_{k-1} + w_{k-1}$，其中 $x_{k} \\in \\mathbb{R}^{n}$。\n-   $A \\in \\mathbb{R}^{n \\times n}$ 是线性传播算子。\n-   $w_{k-1}$ 是独立于 $x_{k-1}$ 的零均值过程噪声。\n-   前一时刻的后验协方差为 $P_{k-1|k-1} = \\operatorname{Cov}(x_{k-1} \\mid y_{1:k-1})$。\n-   预测协方差为 $P_{k|k-1} = \\operatorname{Cov}(x_k \\mid y_{1:k-1})$。\n-   过程噪声协方差为 $Q = \\operatorname{Cov}(w_{k-1})$。从问题上下文中，这就是给定的矩阵 $Q$。\n-   $n=2$ 的数值案例：\n    -   传播算子矩阵：$A = \\begin{pmatrix} 1.5  0.4 \\\\ 0.2  0.7 \\end{pmatrix}$\n    -   前一时刻的后验协方差：$P_{k-1|k-1} = \\begin{pmatrix} 2.0  0.5 \\\\ 0.5  1.0 \\end{pmatrix}$\n    -   过程噪声协方差：$Q = \\begin{pmatrix} 0.3  0.0 \\\\ 0.0  0.2 \\end{pmatrix}$\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据：** 该问题描述了卡尔曼滤波器的预测步骤，这是估计理论和数据同化中的一个基本算法。状态空间模型、定义和目标都是标准的并且在科学上是正确的。\n-   **适定性：** 问题要求进行标准推导，然后是数值计算和定性分析。所有必要信息都已提供，且存在唯一、有意义的解。\n-   **客观性：** 问题使用精确的数学语言陈述，没有主观性。\n-   **完整性与一致性：** 所有必需的矩阵（$A$, $P_{k-1|k-1}$, $Q$）都已提供，并且对于 $n=2$ 维度是一致的。协方差矩阵 $P_{k-1|k-1}$ 和 $Q$ 按要求是对称的。过程噪声 $w_{k-1}$ 的性质有明确定义。该问题是自洽的。\n\n### 步骤 3：结论与行动\n问题是有效的。它在科学上是合理的、适定的，并且提供了所有必要信息。我们着手求解。\n\n卡尔曼滤波器的预测步骤在融合时刻 $k$ 的测量值之前，将状态估计及其协方差从时刻 $k-1$ 向前传播到时刻 $k$。解答按要求分为三部分：预测协方差方程的推导、给定案例的数值计算以及对算子 $A$ 的分析。\n\n**第 1 部分：预测协方差 $P_{k|k-1}$ 的推导**\n\n预测协方差 $P_{k|k-1}$ 定义为状态 $x_k$ 在截至时刻 $k-1$ 的所有观测 $y_{1:k-1}$ 条件下的协方差。\n$$P_{k|k-1} = \\operatorname{Cov}(x_k \\mid y_{1:k-1}) = E[(x_k - E[x_k \\mid y_{1:k-1}])(x_k - E[x_k \\mid y_{1:k-1}])^T \\mid y_{1:k-1}]$$\n我们定义预测状态估计为 $\\hat{x}_{k|k-1} = E[x_k \\mid y_{1:k-1}]$，前一时刻的后验状态估计为 $\\hat{x}_{k-1|k-1} = E[x_{k-1} \\mid y_{1:k-1}]$。\n\n首先，我们通过对状态演化方程取条件期望来求预测状态估计 $\\hat{x}_{k|k-1}$ 的表达式：\n$$\\hat{x}_{k|k-1} = E[A x_{k-1} + w_{k-1} \\mid y_{1:k-1}]$$\n根据期望的线性性质：\n$$\\hat{x}_{k|k-1} = E[A x_{k-1} \\mid y_{1:k-1}] + E[w_{k-1} \\mid y_{1:k-1}]$$\n由于 $A$ 是一个常数矩阵：\n$$\\hat{x}_{k|k-1} = A E[x_{k-1} \\mid y_{1:k-1}] + E[w_{k-1} \\mid y_{1:k-1}]$$\n第一项是 $A \\hat{x}_{k-1|k-1}$。对于第二项，过程噪声 $w_{k-1}$ 独立于过去的状态，因此也独立于过去的观测 $y_{1:k-1}$。题目还给定其为零均值。因此，$E[w_{k-1} \\mid y_{1:k-1}] = E[w_{k-1}] = 0$。\n因此，状态预测为：\n$$\\hat{x}_{k|k-1} = A \\hat{x}_{k-1|k-1}$$\n\n现在，我们将其代回协方差的定义中。预测误差为 $x_k - \\hat{x}_{k|k-1}$。\n$$x_k - \\hat{x}_{k|k-1} = (A x_{k-1} + w_{k-1}) - (A \\hat{x}_{k-1|k-1}) = A(x_{k-1} - \\hat{x}_{k-1|k-1}) + w_{k-1}$$\n设 $e_{k-1|k-1} = x_{k-1} - \\hat{x}_{k-1|k-1}$ 为时刻 $k-1$ 的后验误差。那么预测误差为 $A e_{k-1|k-1} + w_{k-1}$。\n预测协方差是该误差的期望外积：\n$$P_{k|k-1} = E[(A e_{k-1|k-1} + w_{k-1})(A e_{k-1|k-1} + w_{k-1})^T \\mid y_{1:k-1}]$$\n展开期望内的项：\n$$P_{k|k-1} = E[A e_{k-1|k-1} e_{k-1|k-1}^T A^T + A e_{k-1|k-1} w_{k-1}^T + w_{k-1} e_{k-1|k-1}^T A^T + w_{k-1} w_{k-1}^T \\mid y_{1:k-1}]$$\n再次使用期望的线性性质：\n$$P_{k|k-1} = E[A e_{k-1|k-1} e_{k-1|k-1}^T A^T] + E[A e_{k-1|k-1} w_{k-1}^T] + E[w_{k-1} e_{k-1|k-1}^T A^T] + E[w_{k-1} w_{k-1}^T]$$\n（其中对 $y_{1:k-1}$ 的条件在期望 $E[\\cdot]$ 中是隐含的）。\n我们逐项分析：\n1.  $E[A e_{k-1|k-1} e_{k-1|k-1}^T A^T] = A E[e_{k-1|k-1} e_{k-1|k-1}^T] A^T = A P_{k-1|k-1} A^T$。这是因为 $P_{k-1|k-1} = \\operatorname{Cov}(x_{k-1} \\mid y_{1:k-1}) = E[e_{k-1|k-1}e_{k-1|k-1}^T \\mid y_{1:k-1}]$，且误差 $e_{k-1|k-1}$ 的均值为零。\n2.  交叉项为零。例如，$E[A e_{k-1|k-1} w_{k-1}^T] = A E[e_{k-1|k-1} w_{k-1}^T]$。误差 $e_{k-1|k-1}$ 是截至时刻 $k-1$ 的历史的函数。过程噪声 $w_{k-1}$ 与该历史无关。由于 $w_{k-1}$ 也是零均值，乘积的期望等于期望的乘积：$A E[e_{k-1|k-1}]E[w_{k-1}^T] = A \\cdot 0 \\cdot 0^T = 0$。类似地，$E[w_{k-1} e_{k-1|k-1}^T A^T] = 0$。\n3.  $E[w_{k-1} w_{k-1}^T]$。由于 $w_{k-1}$ 独立于过去的历史并且均值为零，这正是过程噪声的协方差，$Q = \\operatorname{Cov}(w_{k-1})$。\n\n综合这些结果，我们得到预测协方差更新方程：\n$$P_{k|k-1} = A P_{k-1|k-1} A^T + Q$$\n\n**第 2 部分：数值计算**\n\n给定：\n$A = \\begin{pmatrix} 1.5  0.4 \\\\ 0.2  0.7 \\end{pmatrix}$，$P_{k-1|k-1} = \\begin{pmatrix} 2.0  0.5 \\\\ 0.5  1.0 \\end{pmatrix}$，$Q = \\begin{pmatrix} 0.3  0.0 \\\\ 0.0  0.2 \\end{pmatrix}$。\n首先，我们计算 $A P_{k-1|k-1} A^T$ 项。\n$A^T = \\begin{pmatrix} 1.5  0.2 \\\\ 0.4  0.7 \\end{pmatrix}$。\n接下来，我们计算乘积 $A P_{k-1|k-1}$：\n$$A P_{k-1|k-1} = \\begin{pmatrix} 1.5  0.4 \\\\ 0.2  0.7 \\end{pmatrix} \\begin{pmatrix} 2.0  0.5 \\\\ 0.5  1.0 \\end{pmatrix} = \\begin{pmatrix} (1.5)(2.0)+(0.4)(0.5)  (1.5)(0.5)+(0.4)(1.0) \\\\ (0.2)(2.0)+(0.7)(0.5)  (0.2)(0.5)+(0.7)(1.0) \\end{pmatrix}$$\n$$A P_{k-1|k-1} = \\begin{pmatrix} 3.0+0.2  0.75+0.4 \\\\ 0.4+0.35  0.1+0.7 \\end{pmatrix} = \\begin{pmatrix} 3.2  1.15 \\\\ 0.75  0.8 \\end{pmatrix}$$\n现在，我们乘以 $A^T$：\n$$A P_{k-1|k-1} A^T = \\begin{pmatrix} 3.2  1.15 \\\\ 0.75  0.8 \\end{pmatrix} \\begin{pmatrix} 1.5  0.2 \\\\ 0.4  0.7 \\end{pmatrix} = \\begin{pmatrix} (3.2)(1.5)+(1.15)(0.4)  (3.2)(0.2)+(1.15)(0.7) \\\\ (0.75)(1.5)+(0.8)(0.4)  (0.75)(0.2)+(0.8)(0.7) \\end{pmatrix}$$\n$$A P_{k-1|k-1} A^T = \\begin{pmatrix} 4.8+0.46  0.64+0.805 \\\\ 1.125+0.32  0.15+0.56 \\end{pmatrix} = \\begin{pmatrix} 5.26  1.445 \\\\ 1.445  0.71 \\end{pmatrix}$$\n最后，我们加上过程噪声协方差 $Q$：\n$$P_{k|k-1} = A P_{k-1|k-1} A^T + Q = \\begin{pmatrix} 5.26  1.445 \\\\ 1.445  0.71 \\end{pmatrix} + \\begin{pmatrix} 0.3  0.0 \\\\ 0.0  0.2 \\end{pmatrix}$$\n$$P_{k|k-1} = \\begin{pmatrix} 5.26+0.3  1.445+0.0 \\\\ 1.445+0.0  0.71+0.2 \\end{pmatrix} = \\begin{pmatrix} 5.56  1.445 \\\\ 1.445  0.91 \\end{pmatrix}$$\n\n**第 3 部分：对算子 $A$ 传播不确定性的分析**\n\n预测协方差更新有两个组成部分：$A P_{k-1|k-1} A^T$ 代表系统动力学对现有不确定性的传播，而 $Q$ 代表来自过程噪声的新增不确定性。为了分析算子 $A$ 本身的影响，我们必须考察它如何变换不确定性。\n\n根据第一性原理，线性映射 $x \\mapsto Ax$ 变换一个误差分量。如果误差位于 $A$ 的一个特征向量 $v$ 的方向上（即 $Av = \\lambda v$），那么变换后的误差为 $A(\\epsilon v) = \\epsilon(Av) = (\\epsilon \\lambda)v$。该方向上的误差分量的大小按特征值的模 $|\\lambda|$ 进行缩放。算子 $A$ 的主方向即为其特征方向。\n-   如果 $|\\lambda| > 1$，算子 $A$ 会放大沿对应特征向量 $v$ 的任何不确定性分量。\n-   如果 $|\\lambda|  1$，算子 $A$ 会抑制（减小）沿对应特征向量 $v$ 的任何不确定性分量。\n-   如果 $|\\lambda| = 1$，不确定性分量的大小保持不变。\n\n我们通过其特征方程 $\\det(A-\\lambda I) = 0$ 来计算 $A$ 的特征值：\n$$\\det\\begin{pmatrix} 1.5 - \\lambda  0.4 \\\\ 0.2  0.7 - \\lambda \\end{pmatrix} = 0$$\n$$(1.5 - \\lambda)(0.7 - \\lambda) - (0.4)(0.2) = 0$$\n$$\\lambda^2 - 2.2\\lambda + 1.05 - 0.08 = 0$$\n$$\\lambda^2 - 2.2\\lambda + 0.97 = 0$$\n使用二次求根公式 $\\lambda = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$：\n$$\\lambda = \\frac{2.2 \\pm \\sqrt{(-2.2)^2 - 4(1)(0.97)}}{2} = \\frac{2.2 \\pm \\sqrt{4.84 - 3.88}}{2} = \\frac{2.2 \\pm \\sqrt{0.96}}{2}$$\n两个特征值是 $\\lambda_1 = 1.1 + \\sqrt{0.24}$ 和 $\\lambda_2 = 1.1 - \\sqrt{0.24}$。\n由于 $A$ 的元素是实数，其对应于实特征值的特征向量是实向量，定义了 $\\mathbb{R}^2$ 中的实方向。\n让我们来分析它们的大小：\n-   对于 $\\lambda_1 = 1.1 + \\sqrt{0.24}$：因为 $\\sqrt{0.24} > 0$，显然 $\\lambda_1 > 1.1$，所以 $|\\lambda_1| > 1$。\n-   对于 $\\lambda_2 = 1.1 - \\sqrt{0.24}$：我们需要判断这个值是大于1还是小于1。这等价于比较 $0.1$ 和 $\\sqrt{0.24}$。对这两个正数进行平方，我们比较 $0.1^2=0.01$ 和 $(\\sqrt{0.24})^2=0.24$。因为 $0.01  0.24$，所以 $0.1  \\sqrt{0.24}$，这意味着 $1.1 - \\sqrt{0.24}  1.0$。另外，由于 $\\sqrt{0.24}  \\sqrt{1.21} = 1.1$，所以 $\\lambda_2 > 0$。因此，$0  \\lambda_2  1$，从而 $|\\lambda_2|  1$。\n\n结论：算子 $A$ 有两个不同的主方向（其特征向量）。沿着一个方向（对应于特征值 $\\lambda_1 \\approx 1.59$），不确定性被放大。沿着另一个方向（对应于特征值 $\\lambda_2 \\approx 0.61$），不确定性被抑制。因此，算子 $A$ 具有混合效应：它在一个方向上是不稳定或扩张的，而在另一个方向上是稳定或收缩的。", "answer": "$$\\boxed{\\begin{pmatrix} 5.56  1.445 \\\\ 1.445  0.91 \\end{pmatrix}}$$", "id": "3381758"}, {"introduction": "传统的稳定性分析通常聚焦于特征值，但当系统矩阵不可对角化时，情况会变得更为复杂。本练习通过一个具有单位特征值的Jordan block的特殊系统，揭示了一个重要的非直观现象：即使在临界稳定条件下，状态分量间的耦合也能导致不确定性（方差）随时间呈多项式增长。解决这个问题将帮助你超越仅依赖特征值的简单判断，深入理解非正常动力学（non-normal dynamics）对误差增长的深刻影响。[@problem_id:3381710]", "problem": "考虑在卡尔曼滤波器 (KF) 的预测步骤中使用的离散时间线性高斯状态空间模型。状态根据以下线性动力学演化\n$$\nx_{k+1} = F x_k + w_k,\n$$\n其中 $x_k \\in \\mathbb{R}^{2}$，过程噪声 $w_k$ 是零均值的，在时间上是独立的，并且独立于 $x_0$，其协方差为 $\\operatorname{Cov}(w_k) = Q$。初始状态 $x_0$ 的均值为零，协方差为 $\\operatorname{Cov}(x_0) = P_0$。所有量都在 $F$ 的若尔当基中指定。\n\n给定 $F$ 是特征值为 $1$ 的 $2 \\times 2$ 若尔当块，即\n$$\nF = \\begin{pmatrix} 1  1 \\\\ 0  1 \\end{pmatrix},\n$$\n并且 $Q = q I_2$ 和 $P_0 = p_0 I_2$，其中标量 $q > 0$ 和 $p_0 > 0$，$I_2$ 表示 $2 \\times 2$ 单位矩阵。步骤之间没有分析更新；也就是说，预测协方差完全是由初始时间的传播和过程噪声累积产生的。\n\n仅从以下基本定义出发：(i) 线性变换后的随机向量的协方差满足 $\\operatorname{Cov}(A x) = A \\operatorname{Cov}(x) A^{\\top}$（对于任意矩阵 $A$），以及 (ii) 独立分量的协方差可加，即当 $x$ 和 $y$ 独立时，有 $\\operatorname{Cov}(x + y) = \\operatorname{Cov}(x) + \\operatorname{Cov}(y)$，推导时刻 $k$ 第一个坐标的预测方差的显式闭式表达式，即经过 $k$ 步后预测协方差矩阵的 $(1,1)$ 项，\n$$\n\\left[P_{k|0}\\right]_{11} = \\operatorname{Var}\\big((x_k)_1\\big),\n$$\n作为 $k$、$p_0$ 和 $q$ 的函数。将最终答案表示为单个闭式解析表达式；无需四舍五入。", "solution": "该问题要求推导一个根据离散时间线性高斯状态空间模型演化的状态向量第一个坐标的预测方差 $[P_{k|0}]_{11}$ 的闭式表达式。由于没有分析更新，时刻 $k$ 的协方差是通过传播初始状态协方差和累积过程噪声协方差得到的。\n\n状态演化由以下方程控制：\n$$\nx_{k+1} = F x_k + w_k\n$$\n其中 $x_k \\in \\mathbb{R}^2$ 是时刻 $k$ 的状态向量，$F$ 是状态转移矩阵，$w_k$ 是过程噪声。初始状态是 $x_0$。\n\n我们可以通过展开递归，用初始状态 $x_0$ 和过程噪声向量序列 $w_0, w_1, \\dots, w_{k-1}$ 来表示任意时间步 $k$ 的状态 $x_k$：\n$x_1 = F x_0 + w_0$\n$x_2 = F x_1 + w_1 = F(F x_0 + w_0) + w_1 = F^2 x_0 + F w_0 + w_1$\n通过归纳法，我们得到 $x_k$ 的一般表达式：\n$$\nx_k = F^k x_0 + \\sum_{i=0}^{k-1} F^{k-1-i} w_i\n$$\n问题要求预测协方差矩阵 $P_{k|0}$ 的 $(1,1)$ 项，由于没有中间更新，我们将其表示为 $P_k = \\operatorname{Cov}(x_k)$。\n$$\nP_k = \\operatorname{Cov}\\left(F^k x_0 + \\sum_{i=0}^{k-1} F^{k-1-i} w_i\\right)\n$$\n问题陈述初始状态 $x_0$ 和过程噪声项 $w_i$ 都是相互独立的。因此，根据所提供的独立随机向量协方差相加的规则 $\\operatorname{Cov}(x+y) = \\operatorname{Cov}(x) + \\operatorname{Cov}(y)$，我们可以写出：\n$$\nP_k = \\operatorname{Cov}(F^k x_0) + \\operatorname{Cov}\\left(\\sum_{i=0}^{k-1} F^{k-1-i} w_i\\right) = \\operatorname{Cov}(F^k x_0) + \\sum_{i=0}^{k-1} \\operatorname{Cov}(F^{k-1-i} w_i)\n$$\n使用协方差线性变换的规则 $\\operatorname{Cov}(A z) = A \\operatorname{Cov}(z) A^{\\top}$，我们得到：\n$$\nP_k = F^k \\operatorname{Cov}(x_0) (F^k)^{\\top} + \\sum_{i=0}^{k-1} \\left( F^{k-1-i} \\operatorname{Cov}(w_i) (F^{k-1-i})^{\\top} \\right)\n$$\n问题指定了初始协方差 $\\operatorname{Cov}(x_0) = P_0 = p_0 I_2$ 和对所有 $i$ 的过程噪声协方差 $\\operatorname{Cov}(w_i) = Q = q I_2$。将这些代入方程，得到：\n$$\nP_k = F^k (p_0 I_2) (F^k)^{\\top} + \\sum_{i=0}^{k-1} F^{k-1-i} (q I_2) (F^{k-1-i})^{\\top}\n$$\n由于 $p_0$ 和 $q$ 是标量，它们可以被提出来：\n$$\nP_k = p_0 F^k (F^k)^{\\top} + q \\sum_{i=0}^{k-1} F^{k-1-i} (F^{k-1-i})^{\\top}\n$$\n状态转移矩阵是给定的若尔当块 $F = \\begin{pmatrix} 1  1 \\\\ 0  1 \\end{pmatrix}$。我们必须找到其幂 $F^j$ 的表达式。我们可以将 $F$ 写成 $F = I_2 + N$，其中 $N = \\begin{pmatrix} 0  1 \\\\ 0  0 \\end{pmatrix}$。矩阵 $N$ 是幂零矩阵，满足 $N^2 = 0$。因为 $I_2$ 和 $N$ 可交换，我们可以使用二项式定理：\n$$\nF^j = (I_2 + N)^j = \\binom{j}{0}I_2^j N^0 + \\binom{j}{1}I_2^{j-1} N^1 + \\dots = I_2 + jN = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} + j\\begin{pmatrix} 0  1 \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} 1  j \\\\ 0  1 \\end{pmatrix}\n$$\n其转置为 $(F^j)^{\\top} = \\begin{pmatrix} 1  0 \\\\ j  1 \\end{pmatrix}$。\n现在我们计算乘积 $F^j (F^j)^{\\top}$：\n$$\nF^j (F^j)^{\\top} = \\begin{pmatrix} 1  j \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ j  1 \\end{pmatrix} = \\begin{pmatrix} 1+j^2  j \\\\ j  1 \\end{pmatrix}\n$$\n我们现在可以计算 $P_k$ 的两个分量。\n第一项，由初始条件产生，是：\n$$\np_0 F^k (F^k)^{\\top} = p_0 \\begin{pmatrix} 1+k^2  k \\\\ k  1 \\end{pmatrix}\n$$\n该项的 $(1,1)$ 元是 $p_0(1+k^2)$。\n\n第二项，由累积的过程噪声产生，是一个和。我们通过设 $j = k-1-i$ 来改变求和指数。当 $i$ 从 $0$ 到 $k-1$ 时，$j$ 从 $k-1$ 递减到 $0$。该和变为：\n$$\nq \\sum_{j=0}^{k-1} F^j (F^j)^{\\top} = q \\sum_{j=0}^{k-1} \\begin{pmatrix} 1+j^2  j \\\\ j  1 \\end{pmatrix} = q \\begin{pmatrix} \\sum_{j=0}^{k-1}(1+j^2)  \\sum_{j=0}^{k-1}j \\\\ \\sum_{j=0}^{k-1}j  \\sum_{j=0}^{k-1}1 \\end{pmatrix}\n$$\n我们需要该矩阵的 $(1,1)$ 项，即 $q \\sum_{j=0}^{k-1}(1+j^2)$。\n我们使用标准公式来计算这个和：\n$$\n\\sum_{j=0}^{k-1}(1+j^2) = \\sum_{j=0}^{k-1}1 + \\sum_{j=0}^{k-1}j^2\n$$\n第一部分是 $\\sum_{j=0}^{k-1}1 = k$。\n第二部分是前 $k-1$ 个平方数之和（因为 $0^2=0$）：$\\sum_{j=0}^{k-1}j^2 = \\sum_{j=1}^{k-1}j^2$。前 $n$ 个平方数之和的公式是 $\\frac{n(n+1)(2n+1)}{6}$。设 $n=k-1$：\n$$\n\\sum_{j=0}^{k-1}j^2 = \\frac{(k-1)((k-1)+1)(2(k-1)+1)}{6} = \\frac{(k-1)k(2k-1)}{6}\n$$\n因此，总和是：\n$$\n\\sum_{j=0}^{k-1}(1+j^2) = k + \\frac{k(k-1)(2k-1)}{6}\n$$\n我们可以简化这个表达式：\n$$\nk + \\frac{k(2k^2 - 3k + 1)}{6} = \\frac{6k + 2k^3 - 3k^2 + k}{6} = \\frac{2k^3 - 3k^2 + 7k}{6} = \\frac{k(2k^2-3k+7)}{6}\n$$\n$P_k$ 的第二项的 $(1,1)$ 元因此是 $q \\frac{k(2k^2-3k+7)}{6}$。\n\n最后，所求的量 $[P_{k|0}]_{11}$ 是这两项的 $(1,1)$ 元之和：\n$$\n[P_{k|0}]_{11} = p_0(1+k^2) + q \\frac{k(2k^2-3k+7)}{6}\n$$\n这就是第一个状态坐标的预测方差作为 $k$、$p_0$ 和 $q$ 的函数的闭式表达式。", "answer": "$$\n\\boxed{p_0(1+k^2) + q \\frac{k(2k^2-3k+7)}{6}}\n$$", "id": "3381710"}, {"introduction": "在天气预报等大规模应用中，显式地构建和存储巨大的协方差矩阵在计算上是不可行的，且常常导致数值不稳定。本练习将引导你进入平方根滤波的世界，这是一种通过直接操作协方差的“平方根”因子来规避这些问题的高级技术。你将推导并实现一个基于QR分解的预测步骤算法，它不仅避免了协方差矩阵的直接计算，还极大地提升了数值稳定性，这对于解决高维度的实际问题至关重要。[@problem_id:3381740]", "problem": "给定一个线性离散时间动力系统，其形式为卡尔曼滤波器预测步骤的标准形式。设状态为一个 $n$ 维向量，预测模型为线性的：\n$$\n\\mathbf{x}_{k+1} = \\mathbf{F}\\,\\mathbf{x}_k + \\mathbf{w}_k,\n$$\n其中 $\\mathbf{F} \\in \\mathbb{R}^{n \\times n}$ 是模型算子，$\\mathbf{w}_k$ 是过程噪声，其协方差 $\\mathbf{Q} \\in \\mathbb{R}^{n \\times n}$ 是对称半正定矩阵。在基于集合的数据同化中，我们用一个平方根因子 $\\mathbf{S} \\in \\mathbb{R}^{n \\times r}$ 来表示状态协方差，使得\n$$\n\\mathbf{P} = \\mathbf{S}\\,\\mathbf{S}^\\top,\n$$\n其中 $r$ 是因子秩。预测协方差应满足\n$$\n\\mathbf{P}^{f} = \\mathbf{F}\\,\\mathbf{P}\\,\\mathbf{F}^\\top + \\mathbf{Q}.\n$$\n\n你的任务是推导并实现一个平方根集合预报算法，该算法计算一个满足以下条件的预测平方根因子 $\\mathbf{S}^{f}$\n$$\n\\mathbf{S}^{f} \\left(\\mathbf{S}^{f}\\right)^\\top = \\mathbf{F}\\,\\mathbf{S}\\,\\mathbf{S}^\\top\\,\\mathbf{F}^\\top + \\mathbf{Q},\n$$\n同时明确避免构造任何协方差矩阵。你的实现必须对一个仅依赖于 $\\mathbf{F}$、$\\mathbf{S}$ 和 $\\mathbf{Q}$ 的一个平方根因子的适当构造的矩阵，使用单次瘦（经济）QR 分解，并且不得直接构造 $\\mathbf{P}$ 或 $\\mathbf{P}^{f}$ 来计算 $\\mathbf{S}^{f}$。\n\n从第一性原理出发——即卡尔曼滤波器预测步骤的核心定义、平方根分解的性质以及关于格拉姆矩阵 QR 分解的公认事实——你必须：\n- 推导为什么对一个结合了传播后的先验平方根因子和过程噪声的平方根因子的增广矩阵进行单次 QR 分解，可以得到一个有效的预测平方根因子。\n- 在不构造任何协方差矩阵的情况下，解释这种方法如何避免在高维情况下与协方差构造相关的数值问题。\n- 实现所推导的算法，并数值验证所得的预测平方根因子能够再现由模型算子和过程噪声所隐含的预测协方差。\n\n设计一个包含三个测试用例的确定性测试套件。对于每个测试用例，使用指定的随机种子和程序构造矩阵，以使场景在科学上是合理的：\n\n- 测试用例 $1$ (正常路径):\n  - 维度 $n = 5$。\n  - 随机种子 $s = 42$。\n  - 构造 $\\mathbf{P} = \\mathbf{S}\\,\\mathbf{S}^\\top$，其中 $\\mathbf{S}$ 是对称正定矩阵 $\\mathbf{R}\\,\\mathbf{R}^\\top + \\varepsilon\\,\\mathbf{I}$ 的 Cholesky 因子，$\\varepsilon = 10^{-3}$，$\\mathbf{R}$ 的元素是独立同分布的标准正态分布。\n  - 通过生成一个元素为独立同分布标准正态分布的随机矩阵 $\\mathbf{G}$，并用因子 $\\alpha = 0.8 / \\rho(\\mathbf{G})$ 对其进行缩放，来构造一个稳定的 $\\mathbf{F}$，其中 $\\rho(\\mathbf{G})$ 是 $\\mathbf{G}$ 的谱半径，使得 $\\rho(\\mathbf{F}) \\approx 0.8$。\n  - 构造 $\\mathbf{Q}$ 为 $\\mathbf{B}\\,\\mathbf{B}^\\top + \\varepsilon\\,\\mathbf{I}$，其中 $\\mathbf{B}$ 的元素为独立同分布的标准正态分布，$\\varepsilon$ 值相同；取其 Cholesky 因子作为 $\\mathbf{Q}$ 的平方根因子。\n\n- 测试用例 $2$ (高维情况):\n  - 维度 $n = 100$。\n  - 随机种子 $s = 1234$。\n  - 与测试用例1类似地构造 $\\mathbf{S}$、$\\mathbf{F}$ 和 $\\mathbf{Q}$，使用相同的 $\\varepsilon = 10^{-3}$ 和稳定化缩放因子 $\\alpha = 0.8 / \\rho(\\mathbf{G})$。\n\n- 测试用例 $3$ (秩亏过程噪声的边缘情况):\n  - 维度 $n = 40$。\n  - 随机种子 $s = 7$。\n  - 如测试用例1一样构造 $\\mathbf{S}$。\n  - 通过首先生成一个元素为独立同分布标准正态分布的矩阵 $\\mathbf{B}$，然后将 $\\mathbf{B}$ 的最后 $\\lfloor n/4 \\rfloor$ 列设置为零以降低其秩，并定义 $\\mathbf{Q} = \\mathbf{B}\\,\\mathbf{B}^\\top$（其中 $\\mathbf{B}$ 作为其平方根因子），来构造一个秩亏的过程噪声平方根因子。\n  - 如测试用例1一样构造一个稳定的 $\\mathbf{F}$。\n\n对于每个测试用例，仅使用你推导的基于 QR 的算法计算预测平方根因子 $\\mathbf{S}^{f}$，然后，仅为了验证，计算显式的预测协方差 $\\mathbf{P}^{f} = \\mathbf{F}\\,\\mathbf{S}\\,\\mathbf{S}^\\top\\,\\mathbf{F}^\\top + \\mathbf{Q}$。对于每个测试用例，报告从基于 QR 的平方根重构的协方差与显式预测协方差之间的相对 Frobenius 范数误差：\n$$\ne = \\frac{\\left\\| \\mathbf{S}^{f}\\left(\\mathbf{S}^{f}\\right)^\\top - \\mathbf{P}^{f} \\right\\|_F}{\\left\\| \\mathbf{P}^{f} \\right\\|_F}.\n$$\n\n你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$）。每个 $\\text{result}_i$ 必须是等于相应测试用例的相对误差 $e$ 的浮点数。本问题不涉及物理单位或角度单位；所有输出都是无量纲的实数。", "solution": "问题要求推导并实现一个用于线性离散时间动力系统的平方根预测算法。该算法必须计算预测状态协方差的平方根因子 $\\mathbf{S}^f$，而无需显式地构造完整的协方差矩阵。\n\n系统状态根据以下线性模型演化：\n$$\n\\mathbf{x}_{k+1} = \\mathbf{F}\\,\\mathbf{x}_k + \\mathbf{w}_k\n$$\n其中 $\\mathbf{x}_k \\in \\mathbb{R}^n$ 是在时间 $k$ 的状态向量，$\\mathbf{F} \\in \\mathbb{R}^{n \\times n}$ 是模型算子，$\\mathbf{w}_k$ 是零均值过程噪声，其协方差矩阵 $\\mathbf{Q} \\in \\mathbb{R}^{n \\times n}$ 是对称半正定的。\n\n先验状态误差协方差矩阵 $\\mathbf{P}$ 由一个平方根因子 $\\mathbf{S} \\in \\mathbb{R}^{n \\times r}$ 表示，使得 $\\mathbf{P} = \\mathbf{S}\\mathbf{S}^\\top$。预测误差协方差 $\\mathbf{P}^f$ 由传播方程给出：\n$$\n\\mathbf{P}^{f} = \\mathbf{F}\\,\\mathbf{P}\\,\\mathbf{F}^\\top + \\mathbf{Q}\n$$\n我们的目标是找到一个满足 $\\mathbf{S}^{f} \\left(\\mathbf{S}^{f}\\right)^\\top = \\mathbf{P}^{f}$ 的预测平方根因子 $\\mathbf{S}^f$。\n\n### 从第一性原理推导\n\n推导过程从预测协方差和矩阵分解的基本定义出发。\n\n1.  **代入平方根因子**：给定先验协方差的平方根因子 $\\mathbf{P} = \\mathbf{S}\\mathbf{S}^\\top$ 和过程噪声协方差，我们可以为其定义一个因子 $\\mathbf{S}_Q \\in \\mathbb{R}^{n \\times q}$ 使得 $\\mathbf{Q} = \\mathbf{S}_Q \\mathbf{S}_Q^\\top$。将这些代入预测协方差方程可得：\n    $$\n    \\mathbf{P}^{f} = \\mathbf{F}\\,(\\mathbf{S}\\mathbf{S}^\\top)\\,\\mathbf{F}^\\top + \\mathbf{S}_Q \\mathbf{S}_Q^\\top\n    $$\n\n2.  **重排为类格拉姆结构**：使用矩阵转置性质 $(AB)^\\top = B^\\top A^\\top$，第一项可以重写为：\n    $$\n    \\mathbf{F}\\mathbf{S}\\mathbf{S}^\\top\\mathbf{F}^\\top = (\\mathbf{F}\\mathbf{S})(\\mathbf{S}^\\top\\mathbf{F}^\\top) = (\\mathbf{F}\\mathbf{S})(\\mathbf{F}\\mathbf{S})^\\top\n    $$\n    预测协方差现在是两个外积之和：\n    $$\n    \\mathbf{P}^{f} = (\\mathbf{F}\\mathbf{S})(\\mathbf{F}\\mathbf{S})^\\top + \\mathbf{S}_Q \\mathbf{S}_Q^\\top\n    $$\n\n3.  **构造增广矩阵**：这个和可以通过构造一个增广矩阵表示为单个矩阵的外积。我们通过水平拼接传播后的先验因子 $\\mathbf{F}\\mathbf{S}$ 和过程噪声因子 $\\mathbf{S}_Q$ 来定义一个新矩阵 $\\mathbf{M}$：\n    $$\n    \\mathbf{M} = \\begin{bmatrix} \\mathbf{F}\\mathbf{S}  \\mathbf{S}_Q \\end{bmatrix}\n    $$\n    $\\mathbf{M}$ 的维度是 $n \\times (r+q)$，其中 $r$ 和 $q$ 分别是 $\\mathbf{S}$ 和 $\\mathbf{S}_Q$ 的列数。$\\mathbf{M}$ 与其自身的外积是：\n    $$\n    \\mathbf{M}\\mathbf{M}^\\top = \\begin{bmatrix} \\mathbf{F}\\mathbf{S}  \\mathbf{S}_Q \\end{bmatrix} \\begin{bmatrix} (\\mathbf{F}\\mathbf{S})^\\top \\\\ \\mathbf{S}_Q^\\top \\end{bmatrix} = (\\mathbf{F}\\mathbf{S})(\\mathbf{F}\\mathbf{S})^\\top + \\mathbf{S}_Q \\mathbf{S}_Q^\\top\n    $$\n    这证明了关键的恒等式：$\\mathbf{P}^f = \\mathbf{M}\\mathbf{M}^\\top$。\n\n4.  **应用 QR 分解**：我们现在寻找一个矩阵 $\\mathbf{S}^f$ 使得 $\\mathbf{S}^f(\\mathbf{S}^f)^\\top = \\mathbf{M}\\mathbf{M}^\\top$。我们可以使用 QR 分解，而不是计算乘积 $\\mathbf{M}\\mathbf{M}^\\top$，这正是我们必须避免的。让我们对增广矩阵的转置 $\\mathbf{M}^\\top$ 进行瘦（经济）QR 分解：\n    $$\n    \\mathbf{M}^\\top = \\mathbf{Q}_{qr} \\mathbf{R}_{qr}\n    $$\n    这里，$\\mathbf{Q}_{qr}$ 是一个具有标准正交列的矩阵（即 $\\mathbf{Q}_{qr}^\\top \\mathbf{Q}_{qr} = \\mathbf{I}$），而 $\\mathbf{R}_{qr}$ 是一个上三角（或上梯形）矩阵。将此方程转置回去得到 $\\mathbf{M} = (\\mathbf{Q}_{qr} \\mathbf{R}_{qr})^\\top = \\mathbf{R}_{qr}^\\top \\mathbf{Q}_{qr}^\\top$。\n\n5.  **确定预测平方根因子**：现在，我们将 $\\mathbf{M}$ 的这种形式代回到 $\\mathbf{P}^f$ 的表达式中：\n    $$\n    \\mathbf{P}^f = \\mathbf{M}\\mathbf{M}^\\top = (\\mathbf{R}_{qr}^\\top \\mathbf{Q}_{qr}^\\top)(\\mathbf{Q}_{qr} \\mathbf{R}_{qr}) = \\mathbf{R}_{qr}^\\top (\\mathbf{Q}_{qr}^\\top \\mathbf{Q}_{qr}) \\mathbf{R}_{qr}\n    $$\n    由于 $\\mathbf{Q}_{qr}$ 具有标准正交列，$\\mathbf{Q}_{qr}^\\top \\mathbf{Q}_{qr} = \\mathbf{I}$。这可将表达式简化为：\n    $$\n    \\mathbf{P}^f = \\mathbf{R}_{qr}^\\top \\mathbf{I} \\mathbf{R}_{qr} = \\mathbf{R}_{qr}^\\top \\mathbf{R}_{qr}\n    $$\n    我们正在寻找一个满足 $\\mathbf{S}^f(\\mathbf{S}^f)^\\top = \\mathbf{P}^f$ 的矩阵 $\\mathbf{S}^f$。如果我们将预测平方根因子定义为 $\\mathbf{S}^f = \\mathbf{R}_{qr}^\\top$，我们可以验证此条件：\n    $$\n    \\mathbf{S}^f(\\mathbf{S}^f)^\\top = (\\mathbf{R}_{qr}^\\top)(\\mathbf{R}_{qr}^\\top)^\\top = \\mathbf{R}_{qr}^\\top \\mathbf{R}_{qr} = \\mathbf{P}^f\n    $$\n    这证实了 $\\mathbf{S}^f = \\mathbf{R}_{qr}^\\top$ 是一个有效的预测平方根因子。该算法仅使用矩阵-矩阵乘法和单次 QR 分解来计算这个因子，而无需构造 $\\mathbf{P}$、$\\mathbf{Q}$ 或 $\\mathbf{P}^f$。\n\n### 避免数值不稳定性\n\n在高维系统中，协方差矩阵通常是病态的，意味着其奇异值跨越多个数量级。从其平方根因子 $\\mathbf{P} = \\mathbf{S}\\mathbf{S}^\\top$ 构造协方差矩阵的过程涉及一个平方操作。这种平方效应会使奇异值对数的范围加倍，并使矩阵的条件数平方，即 $\\kappa(\\mathbf{P}) \\approx \\kappa(\\mathbf{S})^2$。\n\n例如，如果 $\\mathbf{S}$ 的条件数为 $10^9$，则 $\\mathbf{P}$ 的条件数将为 $10^{18}$。在标准的双精度浮点数算术（其精度约为 $16$ 个十进制数字）中，$\\mathbf{P}$ 的最小奇异值在数值上将与零无法区分，从而导致秩和信息的有效损失。任何涉及 $\\mathbf{P}$ 的后续操作，如求逆或加法，都可能遭受巨大的数值误差或灾难性抵消。\n\n所推导的平方根算法通过直接对因子 $\\mathbf{S}$ 和 $\\mathbf{S}_Q$ 进行操作来规避此问题。核心操作是矩阵乘法和 QR 分解。QR 分解是一种正交变换，已知其是后向稳定的，并能保持矩阵的条件数。通过将这些因子拼接成 $\\mathbf{M}$，然后应用这种稳定的变换，我们有效地结合了由 $\\mathbf{S}$ 和 $\\mathbf{S}_Q$ 表示的不确定性，而没有使其条件数平方。这确保了数值精度的维持，使得该算法即使对于地球科学、工程和其他领域中常见的大规模和病态问题也具有鲁棒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Solves the three test cases specified in the problem and prints the results.\n    \"\"\"\n    \n    test_cases = [\n        # (n, seed, case_type)\n        (5, 42, 'happy_path'),\n        (100, 1234, 'high_dim'),\n        (40, 7, 'rank_deficient'),\n    ]\n\n    results = []\n    for n, seed, case_type in test_cases:\n        error = run_test_case(n, seed, case_type)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_test_case(n, seed, case_type):\n    \"\"\"\n    Generates matrices for a single test case, runs the QR-based square-root\n    forecast algorithm, and computes the verification error.\n    \n    Args:\n        n (int): The dimension of the state space.\n        seed (int): The random seed for reproducibility.\n        case_type (str): The type of test case to run.\n\n    Returns:\n        float: The relative Frobenius-norm error.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    epsilon = 1e-3\n\n    # 1. Construct the prior square-root factor S\n    # P = S S^T. We use Cholesky L, so L L^T. Thus S = L.\n    R_prior = rng.standard_normal((n, n))\n    P_tmp = R_prior @ R_prior.T + epsilon * np.identity(n)\n    S = linalg.cholesky(P_tmp, lower=True)\n\n    # 2. Construct a stable model operator F\n    G = rng.standard_normal((n, n))\n    eigvals = linalg.eigvals(G)\n    rho_G = np.max(np.abs(eigvals))\n    F = (0.8 / rho_G) * G\n\n    # 3. Construct the process noise covariance Q and its square-root factor S_Q\n    if case_type in ['happy_path', 'high_dim']:\n        B = rng.standard_normal((n, n))\n        Q = B @ B.T + epsilon * np.identity(n)\n        S_Q = linalg.cholesky(Q, lower=True)\n    elif case_type == 'rank_deficient':\n        B = rng.standard_normal((n, n))\n        num_zero_cols = n // 4\n        B[:, -num_zero_cols:] = 0.0\n        S_Q = B\n        # For verification, we need the explicit Q\n        Q = S_Q @ S_Q.T\n    else:\n        raise ValueError(\"Invalid case type specified.\")\n\n    # --- QR-Based Square-Root Forecast Algorithm ---\n    # Propagate the prior square-root factor\n    FS = F @ S\n    \n    # Form the augmented matrix M = [FS, S_Q]\n    M = np.hstack([FS, S_Q])\n    \n    # Perform thin QR factorization of M^T = Q_qr R_qr\n    # Using scipy.linalg.qr as specified\n    Q_qr, R_qr = linalg.qr(M.T, mode='economic')\n    \n    # The new forecast square-root factor is S_f = R_qr^T\n    S_f = R_qr.T\n    \n    # --- Verification ---\n    # Reconstruct the forecast covariance from the computed square-root factor\n    P_f_sqrt = S_f @ S_f.T\n\n    # Compute the explicit forecast covariance for direct comparison\n    P = S @ S.T\n    P_f_explicit = F @ P @ F.T + Q\n\n    # Compute the relative Frobenius-norm error\n    # e = || S_f S_f^T - P_f ||_F / || P_f ||_F\n    numerator = linalg.norm(P_f_sqrt - P_f_explicit, 'fro')\n    denominator = linalg.norm(P_f_explicit, 'fro')\n    \n    if denominator == 0:\n        return 0.0 if numerator == 0 else np.inf\n        \n    relative_error = numerator / denominator\n    return relative_error\n\nsolve()\n```", "id": "3381740"}]}