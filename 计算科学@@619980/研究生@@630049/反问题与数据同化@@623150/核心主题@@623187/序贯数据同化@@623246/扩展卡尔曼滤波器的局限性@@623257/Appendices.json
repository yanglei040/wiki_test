{"hands_on_practices": [{"introduction": "扩展卡尔曼滤波器（EKF）的核心局限源于其对非线性模型的线性化近似。此练习旨在揭示当观测模型存在显著曲率时，这种线性化如何导致系统性偏差。通过将 EKF 的更新结果与精确的贝叶斯后验均值进行比较，您将亲手量化这种偏差，从而深刻理解 EKF 作为一种近似方法的内在局限性 [@problem_id:3397756]。", "problem": "考虑一个标量潜伏状态 $x \\in \\mathbb{R}$ 的单步数据同化问题。先验分布为高斯分布 $x \\sim \\mathcal{N}(\\mu, P)$，其均值为 $\\mu$，方差为 $P$。观测模型为 $y = h(x) + v$，其中 $h:\\mathbb{R} \\to \\mathbb{R}$ 是一个二次可微的非线性函数，$v \\sim \\mathcal{N}(0, R)$ 是均值为零、方差为 $R$ 的高斯测量噪声。扩展卡尔曼滤波器（Extended Kalman Filter, EKF）通过在当前估计值处对观测函数 $h(x)$ 进行线性化，并应用线性卡尔曼滤波器更新来进行计算。相比之下，精确的贝叶斯后验均值是通过贝叶斯法则对精确的似然和先验进行积分得到的。\n\n从高斯先验、高斯噪声模型、后验的贝叶斯法则以及一阶泰勒线性化的基本定义出发，您的任务是：\n\n- 使用在 $x = \\mu$ 处对 $h(x)$ 的线性化，实现单一同化步骤的 EKF 测量更新。\n- 计算由下式定义的精确贝叶斯后验均值 $m^\\star(y)$：\n$$\nm^\\star(y) \\equiv \\frac{\\int_{-\\infty}^{\\infty} x \\, \\exp\\!\\left(-\\frac{(x-\\mu)^2}{2P}\\right) \\, \\exp\\!\\left(-\\frac{(y - h(x))^2}{2R}\\right) \\, dx}{\\int_{-\\infty}^{\\infty} \\exp\\!\\left(-\\frac{(x-\\mu)^2}{2P}\\right) \\, \\exp\\!\\left(-\\frac{(y - h(x))^2}{2R}\\right) \\, dx},\n$$\n这是在精确非线性似然下，状态的高斯先验加权期望，其中分子和分母中可以约去的归一化常数已被省略。\n- 将 EKF 后验均值估计中的偏差量化为：\n$$\nb \\equiv m^\\star(y) - m^{\\text{EKF}}(y),\n$$\n其中 $m^{\\text{EKF}}(y)$ 是测量更新后的 EKF 后验均值。偏差 $b$ 是由于线性化和模型曲率导致的 EKF 局限性的直接度量。\n\n对于以下所有测试，请使用角度以弧度为单位的约定。为了分离非线性对偏差的影响，在每个测试案例中，将实现的测量值设为在先验均值处评估的观测函数值，即 $y = h(\\mu)$。在此选择下，根据构造，EKF 的新息将为零，但精确的贝叶斯后验均值可能会因 $h(x)$ 的曲率而发生偏移，从而揭示 EKF 的偏差。\n\n实现一个程序，为以下每个测试案例计算偏差 $b$：\n\n- 测试案例 1（线性观测，“理想情况”）：$h(x) = a x + b$，其中 $a = 1.3$，$b = -0.2$，先验均值 $\\mu = 0.5$，方差 $P = 0.09$，噪声方差 $R = 0.04$，测量值 $y = h(\\mu)$。\n- 测试案例 2（二次观测）：$h(x) = x^2$，先验均值 $\\mu = 0.5$，方差 $P = 0.2$，噪声方差 $R = 0.01$，测量值 $y = h(\\mu)$。\n- 测试案例 3（正弦观测）：$h(x) = \\sin(x)$，先验均值 $\\mu = 0.3$，方差 $P = 0.15$，噪声方差 $R = 0.02$，测量值 $y = h(\\mu)$。角度以弧度为单位。\n- 测试案例 4（饱和观测）：$h(x) = \\tanh(x)$，先验均值 $\\mu = 0.8$，方差 $P = 0.3$，噪声方差 $R = 0.02$，测量值 $y = h(\\mu)$。\n- 测试案例 5（强非线性和大先验方差）：$h(x) = x^2$，先验均值 $\\mu = 1.0$，方差 $P = 1.0$，噪声方差 $R = 0.1$，测量值 $y = h(\\mu)$。\n\n对于每个测试案例，通过对 $x \\in (-\\infty, \\infty)$ 进行如上所述的数值积分来计算精确的贝叶斯后验均值 $m^\\star(y)$，使用在 $x=\\mu$ 处对 $h(x)$ 的线性化和标准的线性卡尔曼更新来计算 EKF 后验均值 $m^{\\text{EKF}}(y)$，然后将偏差 $b$ 报告为浮点数。您的程序应生成单行输出，其中包含五个测试案例的偏差，格式为用方括号括起来的逗号分隔列表。将每个偏差表示为十进制数，并在最终输出中四舍五入到六位小数。最终输出格式必须严格为\n$$\n[\\text{bias}_1,\\text{bias}_2,\\text{bias}_3,\\text{bias}_4,\\text{bias}_5].\n$$", "solution": "该问题经评估有效。这是一个定义明确且具有科学依据的非线性状态估计练习，要求对扩展卡尔曼滤波器（EKF）和精确贝叶斯后验进行定量比较。所有必要的函数、参数和定义都已提供，没有矛盾或事实错误。\n\n任务是计算 EKF 后验均值的偏差，定义为 $b \\equiv m^\\star(y) - m^{\\text{EKF}}(y)$，针对一个标量系统在特定测量条件下。这里，$m^{\\text{EKF}}(y)$ 是 EKF 更新的后验均值，$m^\\star(y)$ 是精确的贝叶斯后验均值。\n\n### 1. EKF 后验均值 $m^{\\text{EKF}}(y)$ 的推导\n\nEKF 通过围绕当前状态估计对非线性函数进行一阶泰勒级数展开，将非线性系统近似为线性系统。对于测量更新，观测函数 $h(x)$ 在先验均值 $x=\\mu$ 附近进行线性化。\n\n测量前的状态及其不确定性由先验分布 $x \\sim \\mathcal{N}(\\mu, P)$ 给出。因此，先验估计为 $\\mu$，方差为 $P$。\n\n$h(x)$ 在 $x=\\mu$ 附近的一阶泰勒展开为：\n$$\nh(x) \\approx h(\\mu) + H(x - \\mu)\n$$\n其中 $H$ 是 $h(x)$ 在 $x=\\mu$ 处求值的雅可比矩阵。由于 $x$ 是标量，$H$ 就是导数：\n$$\nH = \\left. \\frac{dh}{dx} \\right|_{x=\\mu}\n$$\n观测模型 $y = h(x) + v$ 随之被近似为：\n$$\ny \\approx h(\\mu) + H(x - \\mu) + v\n$$\n这是一个关于状态 $x$ 的线性观测模型，相对于“线性化”的测量 $y' = y - h(\\mu) + H\\mu$。更直接地，我们可以应用标准的线性卡尔曼更新方程。\n\n卡尔曼滤波器测量更新的关键组成部分是：\n1.  **新息**（或测量残差）：$\\nu = y - \\hat{y}$，其中 $\\hat{y}$ 是预测的测量值。对于 EKF，预测的测量值是在先验均值处评估的观测函数，所以 $\\hat{y} = h(\\mu)$。\n    $$\n    \\nu = y - h(\\mu)\n    $$\n2.  **新息协方差**：$S = H P H^T + R$。对于我们的标量情况，这变为：\n    $$\n    S = H^2 P + R\n    $$\n3.  **卡尔曼增益**：$K = P H^T S^{-1}$。在标量情况下：\n    $$\n    K = \\frac{PH}{H^2 P + R}\n    $$\n4.  **更新后的状态均值**：后验均值 $m^{\\text{EKF}}(y)$ 由先验均值加上经卡尔曼增益校正的新息给出。\n    $$\n    m^{\\text{EKF}}(y) = \\mu + K \\nu = \\mu + K (y - h(\\mu))\n    $$\n\n问题指定了一个关键条件：测量值 $y$ 被设为在先验均值处的观测函数值，即 $y = h(\\mu)$。将此代入新息方程，得到：\n$$\n\\nu = h(\\mu) - h(\\mu) = 0\n$$\n因此，EKF 状态更新变为：\n$$\nm^{\\text{EKF}}(y) = \\mu + K \\cdot 0 = \\mu\n$$\n这个结果是该问题设计的基础。当测量值设为 $h(\\mu)$ 时，EKF 的后验均值与先验均值相同，因为线性化模型没有看到任何新信息。因此，真实后验均值与 $\\mu$ 的任何偏差都是由线性化引入的误差的直接度量。\n\n### 2. 精确贝叶斯后验均值 $m^\\star(y)$\n\n贝叶斯法则指出，后验概率密度函数 $p(x|y)$ 与似然 $p(y|x)$ 和先验 $p(x)$ 的乘积成正比：\n$$\np(x|y) \\propto p(y|x) p(x)\n$$\n根据问题定义：\n-   先验是高斯分布：$p(x) = \\mathcal{N}(x; \\mu, P) \\propto \\exp\\left(-\\frac{(x - \\mu)^2}{2P}\\right)$。\n-   似然，根据噪声模型 $v \\sim \\mathcal{N}(0, R)$，也是高斯分布：$p(y|x) = \\mathcal{N}(y; h(x), R) \\propto \\exp\\left(-\\frac{(y - h(x))^2}{2R}\\right)$。\n\n将它们结合起来得到未归一化的后验分布：\n$$\np(x|y) \\propto \\exp\\left(-\\frac{(x-\\mu)^2}{2P} - \\frac{(y-h(x))^2}{2R}\\right)\n$$\n精确后验均值 $m^\\star(y)$ 是 $x$ 关于此后验分布的期望值：\n$$\nm^\\star(y) = \\mathbb{E}[x|y] = \\frac{\\int_{-\\infty}^{\\infty} x p(x|y) dx}{\\int_{-\\infty}^{\\infty} p(x|y) dx}\n$$\n代入未归一化的后验表达式，即可得到问题陈述中给出的公式：\n$$\nm^\\star(y) = \\frac{\\int_{-\\infty}^{\\infty} x \\, \\exp\\!\\left(-\\frac{(x-\\mu)^2}{2P}\\right) \\, \\exp\\!\\left(-\\frac{(y - h(x))^2}{2R}\\right) \\, dx}{\\int_{-\\infty}^{\\infty} \\exp\\!\\left(-\\frac{(x-\\mu)^2}{2P}\\right) \\, \\exp\\!\\left(-\\frac{(y - h(x))^2}{2R}\\right) \\, dx}\n$$\n当 $h(x)$ 是非线性时，这些积分通常没有封闭形式的解，必须进行数值计算。\n\n### 3. 偏差计算\n\n偏差 $b$ 是精确后验均值与 EKF 近似的后验均值之间的差：\n$$\nb = m^\\star(y) - m^{\\text{EKF}}(y)\n$$\n使用我们推导出的结果，$m^{\\text{EKF}}(y) = \\mu$：\n$$\nb = m^\\star(y) - \\mu\n$$\n这个偏差直接量化了由于 EKF 线性化而产生的误差，且与随机测量新息的影响相分离。如果后验分布 $p(x|y)$ 由于 $h(x)$ 的非线性（曲率）而变得倾斜，则偏差将非零。\n\n对于线性情况，$h(x) = ax+b$，后验指数是 $x$ 的二次函数。这意味着后验分布 $p(x|y)$ 是精确的高斯分布。高斯分布的均值是其众数（概率最大点）。在这种情况下，均值 $m^\\star(y)$ 将与卡尔曼滤波器的均值相同，因此偏差将为 $0$。对于非线性的 $h(x)$，后验分布是非高斯的，预计会产生偏差。\n\n### 4. 每个测试案例的计算流程\n\n对于每个具有参数 $(\\mu, P, R)$ 和函数 $h(x)$ 的测试案例：\n1.  设置测量值 $y = h(\\mu)$。\n2.  EKF 后验均值为 $m^{\\text{EKF}}(y) = \\mu$。\n3.  定义 $m^\\star(y)$ 分子的被积函数：\n    $$\n    \\text{integrand}_{\\text{num}}(x) = x \\exp\\left(-\\frac{(x-\\mu)^2}{2P} - \\frac{(h(\\mu)-h(x))^2}{2R}\\right)\n    $$\n4.  定义 $m^\\star(y)$ 分母的被积函数：\n    $$\n    \\text{integrand}_{\\text{den}}(x) = \\exp\\left(-\\frac{(x-\\mu)^2}{2P} - \\frac{(h(\\mu)-h(x))^2}{2R}\\right)\n    $$\n5.  数值计算在 $(-\\infty, \\infty)$ 上的积分：\n    $$\n    N = \\int_{-\\infty}^{\\infty} \\text{integrand}_{\\text{num}}(x) \\, dx\n    $$\n    $$\n    D = \\int_{-\\infty}^{\\infty} \\text{integrand}_{\\text{den}}(x) \\, dx\n    $$\n6.  计算精确的后验均值：$m^\\star(y) = N/D$。\n7.  计算偏差：$b = m^\\star(y) - \\mu$。\n将为所有五个提供的测试案例实施此流程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n# language: Python\n# version: 3.12\n# libraries:\n#   name: numpy, version: 1.23.5\n#   name: scipy, version: 1.11.4\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes the bias of the Extended Kalman Filter (EKF) posterior mean for\n    several test cases with nonlinear observation models.\n    \"\"\"\n\n    # Define the observation functions h(x) for each test case.\n    def h_case1(x):\n        a, b = 1.3, -0.2\n        return a * x + b\n\n    def h_case2(x):\n        return x**2\n\n    def h_case3(x):\n        return np.sin(x)\n\n    def h_case4(x):\n        return np.tanh(x)\n\n    # Test cases defined as a list of dictionaries for clarity.\n    # Each dictionary contains the observation function h, prior mean mu,\n    # prior variance P, and measurement noise variance R.\n    test_cases = [\n        # Test Case 1: Linear observation model\n        {'h': h_case1, 'mu': 0.5, 'P': 0.09, 'R': 0.04},\n        # Test Case 2: Quadratic observation model\n        {'h': h_case2, 'mu': 0.5, 'P': 0.2, 'R': 0.01},\n        # Test Case 3: Sinusoidal observation model\n        {'h': h_case3, 'mu': 0.3, 'P': 0.15, 'R': 0.02},\n        # Test Case 4: Saturating observation model\n        {'h': h_case4, 'mu': 0.8, 'P': 0.3, 'R': 0.02},\n        # Test Case 5: Strong nonlinearity and large prior variance\n        {'h': h_case2, 'mu': 1.0, 'P': 1.0, 'R': 0.1},\n    ]\n\n    results = []\n    for case in test_cases:\n        h = case['h']\n        mu = case['mu']\n        P = case['P']\n        R = case['R']\n\n        # Per the problem statement, the measurement y is set to h(mu).\n        y = h(mu)\n\n        # The EKF posterior mean m_ekf simplifies to mu under this condition,\n        # as the innovation is zero.\n        m_ekf = mu\n\n        # Define the unnormalized posterior PDF, which is proportional to\n        # exp(-((x-mu)^2)/(2P) - ((y-h(x))^2)/(2R)).\n        # We define a function for the exponent to avoid re-calculation and\n        # potential underflow with the full exponential.\n        def posterior_log_pdf_unnormalized(x):\n            prior_term = (x - mu)**2 / (2 * P)\n            likelihood_term = (y - h(x))**2 / (2 * R)\n            return -prior_term - likelihood_term\n\n        # Integrand for the numerator of the exact posterior mean E[x|y]\n        def numerator_integrand(x):\n            return x * np.exp(posterior_log_pdf_unnormalized(x))\n\n        # Integrand for the denominator (normalization constant)\n        def denominator_integrand(x):\n            return np.exp(posterior_log_pdf_unnormalized(x))\n\n        # Perform numerical integration over (-inf, inf)\n        # The quad function returns the integral result and an error estimate.\n        numerator_val, _ = quad(numerator_integrand, -np.inf, np.inf)\n        denominator_val, _ = quad(denominator_integrand, -np.inf, np.inf)\n        \n        # Calculate the exact Bayesian posterior mean m_star\n        if denominator_val == 0:\n            # This case should not be reached with the given parameters,\n            # but is included for robustness.\n            m_star = mu\n        else:\n            m_star = numerator_val / denominator_val\n            \n        # The bias is the difference between the exact mean and the EKF mean.\n        bias = m_star - m_ekf\n        results.append(bias)\n\n    # Format the final output as a comma-separated list of biases,\n    # rounded to six decimal places, enclosed in square brackets.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "3397756"}, {"introduction": "EKF 的数学基础建立在系统函数的可微性之上，以便计算雅可比矩阵进行线性化。然而，在实际应用中，模型可能包含诸如绝对值或整流线性单元（ReLU）等不可微的函数。本练习将引导您分析 EKF 在处理这类模型时的表现，通过计算精确的矩传播并与 EKF 的预测进行对比，揭示其在雅可比矩阵未明确定义点上的根本性限制 [@problem_id:3397733]。", "problem": "考虑不可微或分段的标量状态空间映射，并通过基于原理的矩计算来评估扩展卡尔曼滤波器 (EKF) 在此类系统中的局限性。使用以下基础：针对非线性映射的EKF预测，会使用函数在当前均值处的雅可比矩阵对其进行线性化，并如同系统是线性的一样来传播均值和协方差。这假定在线性化点处是可微的，且一阶泰勒展开局部有效。相比之下，精确的矩传播由真实变换下的期望和方差的定义所决定。所有计算均在无量纲量中进行。\n\n您将独立分析两种不同的标量映射，以避免混淆效应：\n\n1. 具有不可微状态转移的过程（时间更新）映射：\n   - 状态转移：$x_{k+1} = f(x_k) + w_k$，其中 $f(x) = |x|$，且 $w_k \\sim \\mathcal{N}(0,q)$。\n   - 先验：$x_k \\sim \\mathcal{N}(\\mu,\\sigma^2)$，其中 $\\sigma \\ge 0$。\n   - EKF预测约定：在 $x=\\mu$ 处对 $f$ 进行线性化，其雅可比矩阵 $F = \\frac{d f}{dx}\\big|_{x=\\mu}$ 在 $\\mu  0$ 时取 $F = 1$，在 $\\mu  0$ 时取 $F = -1$，在 $\\mu = 0$ 时取 $F = 0$。\n   - EKF预测的矩：$\\mu^{\\text{EKF}}_{\\text{pred}} = f(\\mu)$ 和 $\\sigma^{2,\\text{EKF}}_{\\text{pred}} = F^2 \\sigma^2 + q$。\n   - 精确预测的矩：$\\mu^{\\text{exact}}_{\\text{pred}} = \\mathbb{E}[|X|]$ 和 $\\sigma^{2,\\text{exact}}_{\\text{pred}} = \\operatorname{Var}(|X|) + q$，其中 $X \\sim \\mathcal{N}(\\mu,\\sigma^2)$。\n   - 您必须从第一性原理推导出 $\\mathbb{E}[|X|]$ 和 $\\operatorname{Var}(|X|)$ 并正确实现它们，包括 $\\sigma = 0$ 的退化情况。\n\n2. 具有分段线性、不可微测量函数的测量（观测）映射：\n   - 测量：$y = h(x) + v$，其中 $h(x) = \\max(0,x)$ 且 $v \\sim \\mathcal{N}(0,r)$。\n   - 先验：$x \\sim \\mathcal{N}(\\mu,\\sigma^2)$，其中 $\\sigma \\ge 0$。\n   - EKF测量预测约定：在 $x=\\mu$ 处对 $h$ 进行线性化，其雅可比矩阵 $H = \\frac{d h}{dx}\\big|_{x=\\mu}$ 在 $\\mu  0$ 时取 $H = 1$，在 $\\mu \\le 0$ 时取 $H = 0$。\n   - EKF预测的测量矩：$\\hat{y}^{\\text{EKF}} = h(\\mu)$ 和 $S^{\\text{EKF}} = H^2 \\sigma^2 + r$。\n   - 精确预测的测量矩：$\\hat{y}^{\\text{exact}} = \\mathbb{E}[\\max(0,X)]$ 和 $S^{\\text{exact}} = \\operatorname{Var}(\\max(0,X)) + r$，其中 $X \\sim \\mathcal{N}(\\mu,\\sigma^2)$。\n   - 您必须通过截断高斯积分从第一性原理推导出 $\\mathbb{E}[\\max(0,X)]$ 和 $\\operatorname{Var}(\\max(0,X))$ 并正确实现它们，包括 $\\sigma = 0$ 的退化情况。\n\n对于下面的每个测试用例，计算EKF预测的矩与精确矩之间的差异。具体来说：\n- 对于过程映射，输出对 $[\\mu^{\\text{EKF}}_{\\text{pred}} - \\mu^{\\text{exact}}_{\\text{pred}},\\ \\sigma^{2,\\text{EKF}}_{\\text{pred}} - \\sigma^{2,\\text{exact}}_{\\text{pred}}]$。\n- 对于测量映射，输出对 $[\\hat{y}^{\\text{EKF}} - \\hat{y}^{\\text{exact}},\\ S^{\\text{EKF}} - S^{\\text{exact}}]$。\n\n实现一个程序来评估以下测试套件：\n\n- 过程（预测）测试用例 $(\\mu,\\sigma,q)$:\n  1. $(0, 1, 0.1)$\n  2. $(2, 0.5, 0.01)$\n  3. $(-2, 1.5, 0)$\n  4. $(0, 0.01, 0)$\n\n- 测量（预测）测试用例 $(\\mu,\\sigma,r)$:\n  5. $(0, 1, 0.1)$\n  6. $(2, 0.5, 0.01)$\n  7. $(-2, 0.75, 0)$\n  8. $(0, 0.01, 0)$\n\n所有计算都是无量纲的。不涉及角度。\n\n您的程序应生成单行输出，其中包含所有结果，形式为方括号内用逗号分隔的列表，并按以下顺序和格式：\n- 首先列出测试用例1的两个浮点数，然后是测试用例2的两个浮点数，以此类推，直到测试用例8。\n- 即，输出一个长度为16的列表：$[\\Delta_1^{(m)},\\Delta_1^{(v)},\\Delta_2^{(m)},\\Delta_2^{(v)},\\ldots,\\Delta_8^{(m)},\\Delta_8^{(v)}]$，其中每个 $\\Delta^{(m)}$ 是对应情况下的均值差异，每个 $\\Delta^{(v)}$ 是方差差异。\n\n推导必须从期望和方差的基本定义、高斯概率密度函数以及截断高斯积分的性质开始。在不可微的地方，不要假定可微性；相反，应在不可微点应用所述的EKF线性化约定。不允许使用其他捷径。", "solution": "该问题要求分析扩展卡尔曼滤波器（EKF）应用于具有不可微非线性系统的局限性。我们将计算状态和测量预测的精确一阶和二阶矩，并将其与EKF生成的近似值进行比较。分析分为两部分，一部分针对不可微的过程模型，另一部分针对不可微的测量模型。\n\n设标量随机变量 $X$ 服从高斯分布，$X \\sim \\mathcal{N}(\\mu, \\sigma^2)$，其概率密度函数 (PDF) 为 $p(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)$。我们用 $\\phi(z) = \\frac{1}{\\sqrt{2\\pi}}\\exp(-z^2/2)$ 表示标准正态PDF，用 $\\Phi(z) = \\int_{-\\infty}^{z} \\phi(t) dt$ 表示标准正态累积分布函数 (CDF)。\n\n### 1. 对过程模型 $f(x) = |x|$ 的分析\n\n过程模型由 $x_{k+1} = |x_k| + w_k$ 给出，其中先验状态 $x_k \\sim \\mathcal{N}(\\mu, \\sigma^2)$，过程噪声 $w_k \\sim \\mathcal{N}(0, q)$。我们被要求比较 $x_{k+1}$ 的EKF预测矩与精确矩。\n\n首先，考虑 $\\sigma = 0$ 的退化情况。状态 $x_k$ 确定性地等于 $\\mu$。变换后的状态是 $|x_k| = |\\mu|$。在加上噪声之前，变换后状态的精确矩是 $\\mathbb{E}[|\\mu|] = |\\mu|$ 和 $\\operatorname{Var}(|\\mu|) = 0$。\n\n对于 $\\sigma  0$ 的一般情况，我们必须计算随机变量 $Y = |X|$ 的矩，其中 $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$。\n\n**精确二阶矩：**\n$Y$ 的二阶矩是 $\\mathbb{E}[Y^2] = \\mathbb{E}[|X|^2]$。由于 $|X|^2 = X^2$，这等同于 $X$ 的二阶矩。对于任何随机变量，$\\mathbb{E}[X^2] = \\operatorname{Var}(X) + (\\mathbb{E}[X])^2$。给定 $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$，我们有：\n$$ \\mathbb{E}[|X|^2] = \\sigma^2 + \\mu^2 $$\n\n**精确一阶矩：**\n$Y = |X|$ 的一阶矩或期望由期望的定义给出：\n$$ \\mathbb{E}[|X|] = \\int_{-\\infty}^{\\infty} |x| p(x) dx = \\int_{0}^{\\infty} x p(x) dx + \\int_{-\\infty}^{0} (-x) p(x) dx $$\n让我们计算 $\\int_a^b x p(x) dx$。使用换元法 $z = (x-\\mu)/\\sigma$，我们有 $x = \\sigma z + \\mu$ 和 $p(x)dx = \\phi(z)dz$。\n$$ \\int_a^b x p(x) dx = \\int_{(a-\\mu)/\\sigma}^{(b-\\mu)/\\sigma} (\\sigma z + \\mu) \\phi(z) dz = \\sigma [-\\phi(z)]_{(a-\\mu)/\\sigma}^{(b-\\mu)/\\sigma} + \\mu [\\Phi(z)]_{(a-\\mu)/\\sigma}^{(b-\\mu)/\\sigma} $$\n将此应用于我们的积分：\n$$ \\int_{0}^{\\infty} x p(x) dx = \\sigma\\phi(-\\mu/\\sigma) + \\mu(1-\\Phi(-\\mu/\\sigma)) = \\sigma\\phi(\\mu/\\sigma) + \\mu\\Phi(\\mu/\\sigma) $$\n$$ \\int_{-\\infty}^{0} x p(x) dx = -\\sigma\\phi(-\\mu/\\sigma) + \\mu\\Phi(-\\mu/\\sigma) = -\\sigma\\phi(\\mu/\\sigma) + \\mu(1-\\Phi(\\mu/\\sigma)) $$\n因此，\n$$ \\mathbb{E}[|X|] = (\\sigma\\phi(\\mu/\\sigma) + \\mu\\Phi(\\mu/\\sigma)) - (-\\sigma\\phi(\\mu/\\sigma) + \\mu(1-\\Phi(\\mu/\\sigma))) $$\n$$ \\mathbb{E}[|X|] = 2\\sigma\\phi(\\mu/\\sigma) + \\mu(2\\Phi(\\mu/\\sigma) - 1) $$\n此表达式适用于 $\\sigma  0$。如果 $\\mu = 0$，它简化为 $\\mathbb{E}[|X|] = 2\\sigma\\phi(0) = \\sigma\\sqrt{2/\\pi}$。\n\n**精确矩与EKF矩的总结（过程）：**\n$|X|$ 的精确矩是：\n$$ \\mu_{|X|} = \\mathbb{E}[|X|] = \\begin{cases} 2\\sigma\\phi(\\mu/\\sigma) + \\mu(2\\Phi(\\mu/\\sigma) - 1)   \\text{若 } \\sigma  0 \\\\ |\\mu|   \\text{若 } \\sigma = 0 \\end{cases} $$\n$$ \\sigma^2_{|X|} = \\operatorname{Var}(|X|) = \\mathbb{E}[|X|^2] - (\\mathbb{E}[|X|])^2 = (\\mu^2 + \\sigma^2) - (\\mu_{|X|})^2 $$\n包含过程噪声 $w_k$ 的总预测矩是：\n$$ \\mu^{\\text{exact}}_{\\text{pred}} = \\mu_{|X|} $$\n$$ \\sigma^{2,\\text{exact}}_{\\text{pred}} = \\sigma^2_{|X|} + q $$\nEKF 使用线性化 $F = \\frac{d|x|}{dx}|_{x=\\mu}$，约定为 $\\mu0$ 时 $F = 1$，$\\mu0$ 时 $F=-1$，$\\mu=0$ 时 $F=0$。EKF预测的矩是：\n$$ \\mu^{\\text{EKF}}_{\\text{pred}} = | \\mu | $$\n$$ \\sigma^{2,\\text{EKF}}_{\\text{pred}} = F^2\\sigma^2 + q $$\n差异计算如下：$[\\mu^{\\text{EKF}}_{\\text{pred}} - \\mu^{\\text{exact}}_{\\text{pred}},\\ \\sigma^{2,\\text{EKF}}_{\\text{pred}} - \\sigma^{2,\\text{exact}}_{\\text{pred}}]$。\n\n### 2. 对测量模型 $h(x) = \\max(0, x)$ 的分析\n\n测量模型是 $y = \\max(0, x) + v$，其中先验状态 $x \\sim \\mathcal{N}(\\mu, \\sigma^2)$，测量噪声 $v \\sim \\mathcal{N}(0, r)$。我们比较EKF预测的测量矩与精确矩。\n\n令 $Y = \\max(0, X)$。对于 $\\sigma = 0$，$Y$ 确定性地等于 $\\max(0, \\mu)$，所以 $\\mathbb{E}[Y] = \\max(0, \\mu)$ 且 $\\operatorname{Var}(Y)=0$。\n\n对于 $\\sigma  0$：\n\n**精确一阶矩：**\n$Y$ 的期望是：\n$$ \\mathbb{E}[\\max(0, X)] = \\int_{-\\infty}^{\\infty} \\max(0, x) p(x) dx = \\int_{0}^{\\infty} x p(x) dx $$\n这与为过程模型计算的第一个积分相同。\n$$ \\mathbb{E}[\\max(0, X)] = \\sigma\\phi(\\mu/\\sigma) + \\mu\\Phi(\\mu/\\sigma) $$\n\n**精确二阶矩：**\n$Y$ 的二阶矩是：\n$$ \\mathbb{E}[(\\max(0, X))^2] = \\int_{-\\infty}^{\\infty} (\\max(0, x))^2 p(x) dx = \\int_{0}^{\\infty} x^2 p(x) dx $$\n为了计算这个，我们使用标准正态变量 $Z = (X-\\mu)/\\sigma \\sim \\mathcal{N}(0,1)$，所以 $X=\\sigma Z+\\mu$。积分变为：\n$$ \\mathbb{E}[Y^2] = \\mathbb{E}[(\\sigma Z+\\mu)^2 \\mathbb{I}(Z  -\\mu/\\sigma)] = \\sigma^2 \\mathbb{E}[Z^2 \\mathbb{I}(Z\\alpha)] + 2\\mu\\sigma \\mathbb{E}[Z\\mathbb{I}(Z\\alpha)] + \\mu^2 \\mathbb{E}[\\mathbb{I}(Z\\alpha)] $$\n其中 $\\alpha = -\\mu/\\sigma$。我们有 $\\mathbb{E}[\\mathbb{I}(Z\\alpha)] = 1-\\Phi(\\alpha)=\\Phi(\\mu/\\sigma)$，$\\mathbb{E}[Z\\mathbb{I}(Z\\alpha)] = \\phi(\\alpha)=\\phi(\\mu/\\sigma)$，以及 $\\mathbb{E}[Z^2\\mathbb{I}(Z\\alpha)] = [ -z\\phi(z)+\\Phi(z) ]_\\alpha^\\infty = \\alpha\\phi(\\alpha)+\\Phi(\\infty)-\\Phi(\\alpha) = \\alpha\\phi(\\alpha)+1-\\Phi(\\alpha)$。\n代入这些得到：\n$$ \\mathbb{E}[(\\max(0, X))^2] = (\\mu^2 + \\sigma^2)\\Phi(\\mu/\\sigma) + \\mu\\sigma\\phi(\\mu/\\sigma) $$\n\n**精确矩与EKF矩的总结（测量）：**\n对于 $\\sigma0$，$\\max(0,X)$ 的精确矩是：\n$$ \\hat{y}^{\\text{exact}} = \\mathbb{E}[\\max(0,X)] = \\mu\\Phi(\\mu/\\sigma) + \\sigma\\phi(\\mu/\\sigma) $$\n$$ \\operatorname{Var}(\\max(0,X)) = \\mathbb{E}[(\\max(0,X))^2] - (\\hat{y}^{\\text{exact}})^2 $$\n对于 $\\sigma=0$，它们分别是 $\\max(0,\\mu)$ 和 $0$。\n总的预测测量均值和新息协方差是：\n$$ \\hat{y}^{\\text{exact}} = \\mathbb{E}[\\max(0, X)] $$\n$$ S^{\\text{exact}} = \\operatorname{Var}(\\max(0, X)) + r $$\nEKF 使用线性化 $H = \\frac{d\\max(0, x)}{dx}|_{x=\\mu}$，约定为 $\\mu0$ 时 $H = 1$，$\\mu \\le 0$ 时 $H=0$。EKF预测的测量矩是：\n$$ \\hat{y}^{\\text{EKF}} = \\max(0, \\mu) $$\n$$ S^{\\text{EKF}} = H^2\\sigma^2 + r $$\n差异计算如下：$[\\hat{y}^{\\text{EKF}} - \\hat{y}^{\\text{exact}}, S^{\\text{EKF}} - S^{\\text{exact}}]$。\n\n这些推导为评估指定不可微系统中EKF近似与精确矩传播之间的差异提供了必要的公式。将基于这些结果进行实现。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef calculate_process_discrepancy(mu, sigma, q):\n    \"\"\"\n    Computes the discrepancy between EKF and exact moments for the process model.\n    Process model: x_{k+1} = |x_k| + w_k, w_k ~ N(0, q)\n    Prior: x_k ~ N(mu, sigma^2)\n    \"\"\"\n    # EKF Prediction\n    mu_ekf = np.abs(mu)\n    if mu  0:\n        F = 1.0\n    elif mu  0:\n        F = -1.0\n    else:  # mu == 0\n        F = 0.0\n    var_ekf = F**2 * sigma**2 + q\n\n    # Exact Moment Prediction\n    if sigma == 0:\n        mu_exact_transform = np.abs(mu)\n        var_exact_transform = 0.0\n    else:\n        # Standardized variable xi = mu / sigma\n        xi = mu / sigma\n        phi_xi = norm.pdf(xi)\n        Phi_xi = norm.cdf(xi)\n        \n        # Mean of |X| where X ~ N(mu, sigma^2)\n        # Formula: E[|X|] = 2*sigma*phi(mu/sigma) + mu*(2*Phi(mu/sigma) - 1)\n        mu_exact_transform = 2 * sigma * phi_xi + mu * (2 * Phi_xi - 1)\n        \n        # Variance of |X|\n        # Var[|X|] = E[|X|^2] - (E[|X|])^2 = (mu^2 + sigma^2) - (E[|X|])^2\n        e_abs_x_sq = mu**2 + sigma**2\n        var_exact_transform = e_abs_x_sq - mu_exact_transform**2\n\n    mu_exact = mu_exact_transform\n    var_exact = var_exact_transform + q\n\n    # Discrepancy\n    delta_mu = mu_ekf - mu_exact\n    delta_var = var_ekf - var_exact\n    \n    return [delta_mu, delta_var]\n\n\ndef calculate_measurement_discrepancy(mu, sigma, r):\n    \"\"\"\n    Computes the discrepancy between EKF and exact moments for the measurement model.\n    Measurement model: y = max(0, x) + v, v ~ N(0, r)\n    Prior: x ~ N(mu, sigma^2)\n    \"\"\"\n    # EKF Measurement Prediction\n    y_hat_ekf = np.maximum(0, mu)\n    if mu  0:\n        H = 1.0\n    else:  # mu = 0\n        H = 0.0\n    S_ekf = H**2 * sigma**2 + r\n\n    # Exact Measurement Moment Prediction\n    if sigma == 0:\n        y_hat_exact_transform = np.maximum(0, mu)\n        var_exact_transform = 0.0\n    else:\n        # Standardized variable xi = mu / sigma\n        xi = mu / sigma\n        phi_xi = norm.pdf(xi)\n        Phi_xi = norm.cdf(xi)\n        \n        # Mean of max(0, X) where X ~ N(mu, sigma^2)\n        # Formula: E[max(0,X)] = mu*Phi(mu/sigma) + sigma*phi(mu/sigma)\n        y_hat_exact_transform = mu * Phi_xi + sigma * phi_xi\n        \n        # Variance of max(0, X)\n        # Var[Y] = E[Y^2] - (E[Y])^2\n        # E[Y^2] = (mu^2 + sigma^2)*Phi(mu/sigma) + mu*sigma*phi(mu/sigma)\n        e_max_0_x_sq = (mu**2 + sigma**2) * Phi_xi + mu * sigma * phi_xi\n        var_exact_transform = e_max_0_x_sq - y_hat_exact_transform**2\n\n    y_hat_exact = y_hat_exact_transform\n    S_exact = var_exact_transform + r\n    \n    # Discrepancy\n    delta_y_hat = y_hat_ekf - y_hat_exact\n    delta_S = S_ekf - S_exact\n\n    return [delta_y_hat, delta_S]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    process_test_cases = [\n        (0.0, 1.0, 0.1),\n        (2.0, 0.5, 0.01),\n        (-2.0, 1.5, 0.0),\n        (0.0, 0.01, 0.0),\n    ]\n\n    measurement_test_cases = [\n        (0.0, 1.0, 0.1),\n        (2.0, 0.5, 0.01),\n        (-2.0, 0.75, 0.0),\n        (0.0, 0.01, 0.0),\n    ]\n\n    results = []\n    \n    for case in process_test_cases:\n        mu, sigma, q = case\n        discrepancy = calculate_process_discrepancy(mu, sigma, q)\n        results.extend(discrepancy)\n\n    for case in measurement_test_cases:\n        mu, sigma, r = case\n        discrepancy = calculate_measurement_discrepancy(mu, sigma, r)\n        results.extend(discrepancy)\n\n    # Format output as a comma-separated list of floats in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3397733"}, {"introduction": "除了线性化带来的理论误差，EKF 的实际性能还受到数值稳定性的严重影响。在计算机的有限精度下，常用的协方差更新公式可能失去其对称性和正定性，导致滤波器发散。本练习通过对比代数简化形式与数值上更稳健的“约瑟夫形式”（Joseph form）协方差更新，让您直观地看到数值误差如何破坏协方差矩阵的物理意义，并理解保证滤波器稳定性的重要性 [@problem_id:3397785]。", "problem": "考虑一个用于逆问题和数据同化的离散时间非线性状态空间模型：\n$$\nx_{k+1} = f(x_k) + w_k, \\quad z_k = h(x_k) + v_k,\n$$\n其中 $x_k \\in \\mathbb{R}^2$ 是状态，$z_k \\in \\mathbb{R}$ 是测量值，$w_k \\sim \\mathcal{N}(0,Q)$ 是过程噪声，$v_k \\sim \\mathcal{N}(0,R)$ 是测量噪声。协方差矩阵 $Q \\in \\mathbb{R}^{2 \\times 2}$ 和 $R \\in \\mathbb{R}$ 是对称半正定的。扩展卡尔曼滤波器（Extended Kalman Filter, EKF）使用雅可比矩阵对非线性模型进行线性化。一个有效的协方差在预测和更新后必须保持对称半正定性。\n\n在实践中，已知某些代数简化的协方差更新公式会因线性化误差和浮点舍入误差而失去半正定性，而 Joseph 稳定形式则能保持对称性和半正定性。本问题要求您使用明确定义的非线性动力学和测量函数，推导、实现并凭经验验证代数简化的协方差更新与 Joseph 稳定形式相比的局限性。\n\n使用以下非线性函数及其雅可比矩阵：\n$$\nf(x) = \\begin{bmatrix} x_1 + \\Delta t \\, x_2 \\\\ x_2 + \\Delta t \\, \\alpha \\, \\sin(x_1) \\end{bmatrix}, \\quad\nF(x) = \\frac{\\partial f}{\\partial x}(x) = \\begin{bmatrix} 1  \\Delta t \\\\ \\Delta t \\, \\alpha \\, \\cos(x_1)  1 \\end{bmatrix},\n$$\n$$\nh(x) = x_1^2 + \\tfrac{1}{2} x_2, \\quad\nH(x) = \\frac{\\partial h}{\\partial x}(x) = \\begin{bmatrix} 2 x_1  \\tfrac{1}{2} \\end{bmatrix}.\n$$\n\n从协方差、线性高斯同化和 EKF 线性化的定义出发，为分析步骤推导两种不同的协方差更新表达式：\n- 实现中常用的、消除了一个对称项的代数简化更新。\n- 明确保留了对称性和半正定性所需项的 Joseph 稳定形式。\n\n然后按如下方式实现单个 EKF 预测-更新循环：\n1. 预测：\n   - 计算 $x_{k|k-1} = f(x_{k-1|k-1})$ 和 $F = F(x_{k-1|k-1})$。\n   - 计算 $P_{k|k-1} = F P_{k-1|k-1} F^\\top + Q$。\n\n2. 更新：\n   - 计算 $H = H(x_{k|k-1})$、新息 $y_k = z_k - h(x_{k|k-1})$ 以及新息协方差 $S_k = H P_{k|k-1} H^\\top + R$。\n   - 计算卡尔曼增益 $K_k = P_{k|k-1} H^\\top S_k^{-1}$。\n   - 计算更新后的状态 $x_{k|k} = x_{k|k-1} + K_k y_k$。\n   - 计算两个版本的更新后协方差：\n     - 代数简化的协方差更新。\n     - Joseph 稳定形式的协方差更新。\n\n对于每个更新后的协方差矩阵，评估：\n- 使用弗罗贝尼乌斯范数（Frobenius norm）计算对称误差 $e_{\\text{sym}} = \\|P - P^\\top\\|_F$。\n- 对称化协方差 $P_{\\text{sym}} = (P + P^\\top)/2$ 的最小特征值 $\\lambda_{\\min}$。\n- 一个布尔值，用于表示半正定性，定义为 $e_{\\text{sym}} \\leq 10^{-12}$ 且 $\\lambda_{\\min} \\geq -10^{-12}$。\n\n对以下测试套件执行该过程，每个测试用例指定 $(\\Delta t, \\alpha, x_{0}, P_0, Q, R, z_1)$，并且所有标量角度均以弧度为单位：\n\n- 测试用例 1 (理想情况):\n  - $\\Delta t = 0.1$, $\\alpha = 5.0$,\n  - $x_0 = \\begin{bmatrix} 0.5 \\\\ -0.2 \\end{bmatrix}$,\n  - $P_0 = \\begin{bmatrix} 0.5  0.1 \\\\ 0.1  0.5 \\end{bmatrix}$,\n  - $Q = \\begin{bmatrix} 10^{-3}  0 \\\\ 0  10^{-3} \\end{bmatrix}$,\n  - $R = 0.05$,\n  - $z_1 = h(x_0) + 0.1$.\n\n- 测试用例 2 (接近奇异的先验):\n  - $\\Delta t = 0.1$, $\\alpha = 5.0$,\n  - $x_0 = \\begin{bmatrix} 0.01 \\\\ 0.0 \\end{bmatrix}$,\n  - $P_0 = \\begin{bmatrix} 10^{-8}  0 \\\\ 0  10^{-4} \\end{bmatrix}$,\n  - $Q = \\begin{bmatrix} 10^{-12}  0 \\\\ 0  10^{-10} \\end{bmatrix}$,\n  - $R = 10^{-8}$,\n  - $z_1 = h(x_0) - 0.05$.\n\n- 测试用例 3 (强非线性和高相关性):\n  - $\\Delta t = 0.2$, $\\alpha = 15.0$,\n  - $x_0 = \\begin{bmatrix} 2.0 \\\\ 1.0 \\end{bmatrix}$,\n  - $P_0 = \\begin{bmatrix} 1.0  0.99 \\\\ 0.99  1.0 \\end{bmatrix}$,\n  - $Q = \\begin{bmatrix} 10^{-3}  0 \\\\ 0  10^{-3} \\end{bmatrix}$,\n  - $R = 10^{-6}$,\n  - $z_1 = h(x_0) - 0.2$.\n\n- 测试用例 4 (病态新息):\n  - $\\Delta t = 0.05$, $\\alpha = 7.0$,\n  - $x_0 = \\begin{bmatrix} -3.0 \\\\ 0.1 \\end{bmatrix}$,\n  - $P_0 = \\begin{bmatrix} 0.2  -0.19 \\\\ -0.19  0.2 \\end{bmatrix}$,\n  - $Q = \\begin{bmatrix} 10^{-5}  0 \\\\ 0  10^{-5} \\end{bmatrix}$,\n  - $R = 10^{-4}$,\n  - $z_1 = h(x_0)$.\n\n对于每个测试用例，您的程序必须输出一个列表\n$$\n[\\text{is\\_naive\\_psd}, \\ \\text{is\\_joseph\\_psd}, \\ \\lambda_{\\min}^{\\text{naive}}, \\ \\lambda_{\\min}^{\\text{joseph}}, \\ e_{\\text{sym}}^{\\text{naive}}, \\ e_{\\text{sym}}^{\\text{joseph}}],\n$$\n其中布尔值表示相应协方差更新的半正定性，特征值为浮点数，对称误差为浮点数。\n\n最终输出格式规范：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”）。每个“result”本身必须是其对应测试用例的上述列表，并按所提供测试套件的顺序排列。", "solution": "任务是推导、实现和比较扩展卡尔曼滤波器（EKF）在特定非线性动力学下的两种协方差更新公式，并评估它们的数值稳定性。\n\n### 第 1 部分：协方差更新公式的推导\n\n我们考虑一个非线性系统，其状态为 $x_k \\in \\mathbb{R}^n$，测量值为 $z_k \\in \\mathbb{R}^m$：\n$$\nx_{k+1} = f(x_k) + w_k, \\quad w_k \\sim \\mathcal{N}(0,Q)\n$$\n$$\nz_k = h(x_k) + v_k, \\quad v_k \\sim \\mathcal{N}(0,R)\n$$\nEKF 更新步骤围绕预测状态 $x_{k|k-1}$ 对测量模型进行线性化。分析状态 $x_{k|k}$ 及其协方差 $P_{k|k}$ 是根据预测状态 $x_{k|k-1}$、其协方差 $P_{k|k-1}$、测量值 $z_k$ 和线性化测量矩阵 $H_k = \\frac{\\partial h}{\\partial x}(x_{k|k-1})$ 计算得出的。\n\n更新的关键组成部分是：\n- 新息：$y_k = z_k - h(x_{k|k-1})$\n- 新息协方差：$S_k = H_k P_{k|k-1} H_k^\\top + R$\n- 卡尔曼增益：$K_k = P_{k|k-1} H_k^\\top S_k^{-1}$\n- 状态更新：$x_{k|k} = x_{k|k-1} + K_k y_k$\n\n由此，我们推导出协方差更新 $P_{k|k}$ 的两种形式。\n\n**1. 代数简化的协方差更新**\n\n这是入门教材中最常见的形式，由卡尔曼增益表达式推导而来。它始于后验协方差更基本的表达式，该表达式可通过伍德伯里矩阵恒等式（Woodbury matrix identity）获得：\n$$\nP_{k|k} = P_{k|k-1} - P_{k|k-1} H_k^\\top (H_k P_{k|k-1} H_k^\\top + R)^{-1} H_k P_{k|k-1}\n$$\n代入 $S_k$ 和 $K_k$ 的表达式：\n$$\nP_{k|k} = P_{k|k-1} - (P_{k|k-1} H_k^\\top S_k^{-1}) H_k P_{k|k-1}\n$$\n$$\nP_{k|k} = P_{k|k-1} - K_k H_k P_{k|k-1}\n$$\n这可以因式分解为**代数简化形式**：\n$$\nP_{k|k} = (I - K_k H_k) P_{k|k-1}\n$$\n尽管在代数上是正确的，但这个公式在数值上是不稳定的。由于有限精度算术（灾难性抵消），减法运算 $P_{k|k-1} - K_k H_k P_{k|k-1}$ 可能导致正定性的丧失。此外，由于矩阵乘积 $K_k H_k P_{k|k-1}$ 通常不是对称的，即使 $P_{k|k-1}$ 是完全对称的，微小的浮点误差也可能导致 $P_{k|k}$ 失去其对称性。\n\n**2. Joseph 稳定协方差更新**\n\n这种形式是直接从估计误差的传播中推导出来的。分析误差为 $e_{k|k} = x_k - x_{k|k}$。代入状态更新方程和线性化测量模型：\n$$\ne_{k|k} = x_k - \\left(x_{k|k-1} + K_k (z_k - h(x_{k|k-1}))\\right)\n$$\n$$\ne_{k|k} \\approx x_k - \\left(x_{k|k-1} + K_k (H_k(x_k - x_{k|k-1}) + v_k)\\right)\n$$\n令 $e_{k|k-1} = x_k - x_{k|k-1}$ 为预测误差，我们得到：\n$$\ne_{k|k} \\approx e_{k|k-1} - K_k H_k e_{k|k-1} - K_k v_k = (I - K_k H_k) e_{k|k-1} - K_k v_k\n$$\n分析协方差为 $P_{k|k} = E[e_{k|k} e_{k|k}^\\top]$。由于预测误差 $e_{k|k-1}$ 和测量噪声 $v_k$ 不相关，其交叉项消失：\n$$\nP_{k|k} = E\\left[ \\left((I - K_k H_k) e_{k|k-1}\\right)\\left((I - K_k H_k) e_{k|k-1}\\right)^\\top \\right] + E\\left[ (- K_k v_k)(- K_k v_k)^\\top \\right]\n$$\n$$\nP_{k|k} = (I - K_k H_k) E[e_{k|k-1}e_{k|k-1}^\\top] (I - K_k H_k)^\\top + K_k E[v_k v_k^\\top] K_k^\\top\n$$\n代入 $P_{k|k-1} = E[e_{k|k-1}e_{k|k-1}^\\top]$ 和 $R = E[v_k v_k^\\top]$ 得出 **Joseph 稳定形式**：\n$$\nP_{k|k} = (I - K_k H_k) P_{k|k-1} (I - K_k H_k)^\\top + K_k R K_k^\\top\n$$\n这种形式通过构造天然具有对称性。如果 $P_{k|k-1}$ 和 $R$ 是对称半正定（Symmetric-Positive-Semidefinite, SPSD）的，那么和中的每一项都形如 $M \\Sigma M^\\top$，这也是 SPSD 的。SPSD 矩阵的和仍然是 SPSD 的，所以结果 $P_{k|k}$ 保证是 SPSD 的。这种形式避免了困扰简化形式的相减抵消问题，确保了数值稳定性。\n\n### 第 2 部分：实现与经验验证\n\n所提供的问题通过为四个不同的测试用例实现 EKF 的单个预测-更新循环来解决。每个案例都使用两种推导出的协方差更新公式，并对得到的协方差矩阵进行对称性和半正定性评估。\n\n**过程：**\n对于每个具有参数 $(\\Delta t, \\alpha, x_{0}, P_0, Q, R, z_1)$ 的测试用例：\n1.  **预测**：使用非线性动力学函数 $f$ 向前预测状态，并使用线性化动力学矩阵 $F$ 预测协方差。\n    -   $x_{1|0} = f(x_0)$\n    -   $F_0 = F(x_0)$\n    -   $P_{1|0} = F_0 P_0 F_0^\\top + Q$\n2.  **更新**：使用测量值 $z_1$ 执行更新。\n    -   $H_1 = H(x_{1|0})$\n    -   新息协方差：$S_1 = H_1 P_{1|0} H_1^\\top + R$\n    -   卡尔曼增益：$K_1 = P_{1|0} H_1^\\top S_1^{-1}$\n3.  **协方差计算**：计算更新后协方差 $P_{1|1}$ 的两个版本。\n    -   朴素形式：$P_{\\text{naive}} = (I - K_1 H_1) P_{1|0}$\n    -   Joseph 形式：$P_{\\text{joseph}} = (I - K_1 H_1) P_{1|0} (I - K_1 H_1)^\\top + K_1 R K_1^\\top$\n4.  **评估**：根据以下标准评估每个结果协方差矩阵 $P$：\n    -   对称误差：$e_{\\text{sym}} = \\|P - P^\\top\\|_F$\n    -   最小特征值：对称化矩阵 $(P + P^\\top)/2$ 的 $\\lambda_{\\min}$\n    -   半正定性（PSD）：如果 $e_{\\text{sym}} \\leq 10^{-12}$ 且 $\\lambda_{\\min} \\geq -10^{-12}$，则布尔标志设置为真。\n\n实现将表明，虽然在良态（well-conditioned）情况下两种形式产生相似的结果，但在涉及高相关性或病态（ill-conditioned）矩阵的挑战性场景中，朴素形式可能无法保持对称性和半正定性，而 Joseph 形式则保持稳健。", "answer": "```python\nimport numpy as np\nfrom numpy.linalg import norm, eigvalsh\n\ndef solve():\n    \"\"\"\n    Main function to run the EKF cycle for all test cases and print results.\n    \"\"\"\n\n    # Helper functions for h(x) to compute z1 values\n    def h_func(x):\n        return x[0]**2 + 0.5 * x[1]\n\n    # Test cases as defined in the problem statement\n    test_cases = [\n        {\n            \"dt\": 0.1, \"alpha\": 5.0,\n            \"x0\": np.array([0.5, -0.2]),\n            \"P0\": np.array([[0.5, 0.1], [0.1, 0.5]]),\n            \"Q\": np.array([[1e-3, 0], [0, 1e-3]]),\n            \"R\": 0.05,\n            \"z1\": h_func(np.array([0.5, -0.2])) + 0.1,\n        },\n        {\n            \"dt\": 0.1, \"alpha\": 5.0,\n            \"x0\": np.array([0.01, 0.0]),\n            \"P0\": np.array([[1e-8, 0], [0, 1e-4]]),\n            \"Q\": np.array([[1e-12, 0], [0, 1e-10]]),\n            \"R\": 1e-8,\n            \"z1\": h_func(np.array([0.01, 0.0])) - 0.05,\n        },\n        {\n            \"dt\": 0.2, \"alpha\": 15.0,\n            \"x0\": np.array([2.0, 1.0]),\n            \"P0\": np.array([[1.0, 0.99], [0.99, 1.0]]),\n            \"Q\": np.array([[1e-3, 0], [0, 1e-3]]),\n            \"R\": 1e-6,\n            \"z1\": h_func(np.array([2.0, 1.0])) - 0.2,\n        },\n        {\n            \"dt\": 0.05, \"alpha\": 7.0,\n            \"x0\": np.array([-3.0, 0.1]),\n            \"P0\": np.array([[0.2, -0.19], [-0.19, 0.2]]),\n            \"Q\": np.array([[1e-5, 0], [0, 1e-5]]),\n            \"R\": 1e-4,\n            \"z1\": h_func(np.array([-3.0, 0.1])),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_ekf_cycle(\n            case[\"dt\"], case[\"alpha\"], case[\"x0\"], case[\"P0\"],\n            case[\"Q\"], case[\"R\"], case[\"z1\"]\n        )\n        results.append(result)\n\n    # Format the final output as a string representing a list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_ekf_cycle(dt, alpha, x0, P0, Q, R, z1):\n    \"\"\"\n    Performs a single EKF predict-update cycle for a given test case.\n\n    Args:\n        dt (float): Time step.\n        alpha (float): Parameter in the dynamic model.\n        x0 (np.ndarray): Initial state vector x_{0|0}.\n        P0 (np.ndarray): Initial covariance matrix P_{0|0}.\n        Q (np.ndarray): Process noise covariance matrix.\n        R (float): Measurement noise variance.\n        z1 (float): Measurement at step 1.\n\n    Returns:\n        list: A list containing the assessment metrics for naive and Joseph forms.\n              [is_naive_psd, is_joseph_psd, lambda_min_naive, \n               lambda_min_joseph, e_sym_naive, e_sym_joseph]\n    \"\"\"\n    \n    # State and measurement model functions\n    def f(x, dt, alpha):\n        x1, x2 = x\n        return np.array([x1 + dt * x2, x2 + dt * alpha * np.sin(x1)])\n\n    def h(x):\n        x1, x2 = x\n        return x1**2 + 0.5 * x2\n\n    # Jacobian functions\n    def F_jac(x, dt, alpha):\n        x1, _ = x\n        return np.array([[1.0, dt], [dt * alpha * np.cos(x1), 1.0]])\n\n    def H_jac(x):\n        x1, _ = x\n        return np.array([[2.0 * x1, 0.5]])\n\n    # ---- 1. Prediction Step ----\n    # Predicted state x_{1|0}\n    x_pred = f(x0, dt, alpha)\n    # Jacobian of dynamics at x0\n    F0 = F_jac(x0, dt, alpha)\n    # Predicted covariance P_{1|0}\n    P_pred = F0 @ P0 @ F0.T + Q\n\n    # ---- 2. Update Step ----\n    # Jacobian of measurement at x_pred\n    H1 = H_jac(x_pred)\n    # Innovation\n    y = z1 - h(x_pred)\n    # Innovation covariance (S is a 1x1 matrix)\n    S = H1 @ P_pred @ H1.T + R\n    S_inv = 1.0 / S[0, 0]\n    # Kalman gain K\n    K = P_pred @ H1.T * S_inv\n\n    # ---- 3. Covariance Update (Two Forms) ----\n    I = np.identity(2)\n    # Algebraically simplified (naive) form\n    P_naive = (I - K @ H1) @ P_pred\n    # Joseph stabilized form\n    term1 = (I - K @ H1) @ P_pred @ (I - K @ H1).T\n    term2 = K @ np.array([[R]]) @ K.T\n    P_joseph = term1 + term2\n\n    # ---- 4. Assessment ----\n    def assess_covariance(P):\n        # Symmetry error\n        e_sym = norm(P - P.T, 'fro')\n        # Symmetrize for eigenvalue calculation\n        P_sym = 0.5 * (P + P.T)\n        # Minimum eigenvalue\n        try:\n            # eigvalsh is for symmetric/Hermitian matrices\n            min_eig = np.min(eigvalsh(P_sym))\n        except np.linalg.LinAlgError:\n            min_eig = -np.inf\n            \n        # Check for positive semidefiniteness (PSD)\n        is_psd = (e_sym = 1e-12) and (min_eig = -1e-12)\n        return is_psd, min_eig, e_sym\n\n    is_naive_psd, lambda_min_naive, e_sym_naive = assess_covariance(P_naive)\n    is_joseph_psd, lambda_min_joseph, e_sym_joseph = assess_covariance(P_joseph)\n    \n    return [is_naive_psd, is_joseph_psd, lambda_min_naive, lambda_min_joseph, e_sym_naive, e_sym_joseph]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3397785"}]}