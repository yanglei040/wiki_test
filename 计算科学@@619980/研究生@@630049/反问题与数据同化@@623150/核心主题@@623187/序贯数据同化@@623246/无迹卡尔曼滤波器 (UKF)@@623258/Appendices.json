{"hands_on_practices": [{"introduction": "这个练习提供了一个具体的、分步的无迹卡尔曼滤波器（UKF）预测阶段的演练。通过手动计算西格玛点（sigma points）通过一个非线性状态转移函数的传播过程，你将对无迹变换（unscented transform）的核心机制获得实践性的理解。这种练习对于建立一个直观的感觉至关重要，即UKF如何在不计算雅可比矩阵的情况下近似预测的状态分布 [@problem_id:2888306]。", "problem": "考虑一个离散时间非线性随机系统\n$$\nx_{k+1} \\;=\\; \\begin{bmatrix} x_{1,k} + \\sin(x_{2,k}) \\\\ x_{2,k} \\end{bmatrix} \\;+\\; w_k,\n\\qquad\ny_k \\;=\\; \\begin{bmatrix} x_{1,k}^2 \\end{bmatrix} \\;+\\; v_k,\n$$\n其中 $w_k$ 和 $v_k$ 是相互独立、零均值的高斯白噪声，其协方差矩阵分别为 $Q$ 和 $R$。假设 $Q = 0.01 I_2$，并注意过程噪声是加性噪声。在时间 $k$，先验状态估计是高斯分布，其均值为\n$$\n\\hat{x}_{k|k} \\;=\\; \\begin{bmatrix} 0.5 \\\\ 0.1 \\end{bmatrix}\n$$\n协方差为\n$$\nP_{k|k} \\;=\\; \\begin{bmatrix} 0.04  & 0.01 \\\\ 0.01 & 0.09 \\end{bmatrix}.\n$$\n您将使用无迹变换（参数为 $\\alpha = 10^{-3}$，$\\beta = 2$，$\\kappa = 0$）和标准的 sigma 点构造方法，执行一步无迹卡尔曼滤波器 (UKF) 的预测步骤。假设正弦函数的参数单位为弧度。\n\n从预测步骤的基本定义出发，即通过匹配从高斯先验中抽取的确定性选择的 sigma 点集的变换后矩，来近似随机变量 $x_{k+1} = f(x_k) + w_k$（其中 $f(x) = [x_1 + \\sin(x_2),\\; x_2]^\\top$）的前两阶矩，推导基于无迹变换的第一个状态分量的预测均值 $\\hat{x}_{1,k+1|k}$。\n\n报告标量 $\\hat{x}_{1,k+1|k}$ 的值。将您的答案四舍五入到八位有效数字。无需单位。", "solution": "本题要求使用无迹卡尔曼滤波器 (UKF) 的预测步骤，为一个给定的离散时间非线性系统计算预测状态均值，特别是第一个分量 $\\hat{x}_{1,k+1|k}$。\n\n首先验证题目的有效性。\n已知条件：\n- 状态动态方程：$x_{k+1} = f(x_k) + w_k$，其中 $f(x) = \\begin{bmatrix} x_1 + \\sin(x_2) \\\\ x_2 \\end{bmatrix}$。\n- 过程噪声：$w_k \\sim \\mathcal{N}(0, Q)$，其中 $Q = 0.01 I_2 = \\begin{bmatrix} 0.01  0 \\\\ 0  0.01 \\end{bmatrix}$。\n- 测量方程：$y_k = h(x_k) + v_k$，其中 $h(x) = [x_1^2]$。\n- $k$ 时刻状态估计的均值：$\\hat{x}_{k|k} = \\begin{bmatrix} 0.5 \\\\ 0.1 \\end{bmatrix}$。\n- $k$ 时刻状态估计的协方差：$P_{k|k} = \\begin{bmatrix} 0.04  0.01 \\\\ 0.01  0.09 \\end{bmatrix}$。\n- UKF 参数：$\\alpha = 10^{-3}$，$\\beta = 2$，$\\kappa = 0$。正弦函数参数单位为弧度。\n\n验证结论：\n该问题具有科学依据，提法恰当，客观，并且对于所需任务是完整的。这是无迹卡尔曼滤波器的一个标准应用。所提供的数据是一致的，足以执行预测步骤。该问题被认为是有效的。\n\nUKF 的预测步骤通过将一组确定性选择的“sigma 点”通过非线性状态动态方程进行传播，来计算预测均值 $\\hat{x}_{k+1|k}$ 和协方差 $P_{k+1|k}$。由于过程噪声 $w_k$ 是加性的且均值为零，其对预测均值的贡献为零。预测均值计算为传播后的 sigma 点的加权平均值：\n$$ \\hat{x}_{k+1|k} = \\sum_{i=0}^{2n} W_i^{(m)} \\mathcal{X}_{i, k+1|k}^* $$\n其中 $\\mathcal{X}_{i, k+1|k}^* = f(\\mathcal{X}_{i, k|k})$ 是传播后的 sigma 点，$W_i^{(m)}$ 是用于计算均值的权重。\n\n步骤 1：计算 UKF 权重\n状态维度为 $n=2$。缩放参数 $\\lambda$ 由以下公式给出：\n$$ \\lambda = \\alpha^2(n + \\kappa) - n $$\n代入给定值：\n$$ \\lambda = (10^{-3})^2(2 + 0) - 2 = 2 \\times 10^{-6} - 2 = -1.999998 $$\n用于计算均值的权重 $W_i^{(m)}$ 为：\n$$ W_0^{(m)} = \\frac{\\lambda}{n+\\lambda} = \\frac{-1.999998}{2 - 1.999998} = \\frac{-1.999998}{0.000002} = -999999 $$\n$$ W_i^{(m)} = \\frac{1}{2(n+\\lambda)} = \\frac{1}{2(0.000002)} = 250000 \\quad \\text{对于 } i=1, \\dots, 2n $$\n注意，权重之和为 1：$W_0^{(m)} + 2n \\cdot W_i^{(m)} = -999999 + 4 \\cdot 250000 = 1$。这些权重数值很大，这警示我们，如果进行朴素计算，可能会由于灾难性抵消而导致数值不稳定。\n\n步骤 2：生成 Sigma 点\n这 $2n+1 = 5$ 个 sigma 点 $\\mathcal{X}_{i, k|k}$ 是基于均值 $\\hat{x}_{k|k}$ 和协方差 $P_{k|k}$ 生成的。\n$$ \\mathcal{X}_{0, k|k} = \\hat{x}_{k|k} $$\n$$ \\mathcal{X}_{i, k|k} = \\hat{x}_{k|k} + (\\sqrt{(n+\\lambda)P_{k|k}})_i \\quad \\text{对于 } i=1, \\dots, n $$\n$$ \\mathcal{X}_{i+n, k|k} = \\hat{x}_{k|k} - (\\sqrt{(n+\\lambda)P_{k|k}})_i \\quad \\text{对于 } i=1, \\dots, n $$\n其中 $(\\cdot)_i$ 表示矩阵平方根的第 $i$ 列，通常通过 Cholesky 分解计算。令 $S = \\sqrt{(n+\\lambda)P_{k|k}}$。\n$$ (n+\\lambda)P_{k|k} = 2 \\times 10^{-6} \\begin{bmatrix} 0.04  0.01 \\\\ 0.01  0.09 \\end{bmatrix} = \\begin{bmatrix} 8 \\times 10^{-8}  2 \\times 10^{-8} \\\\ 2 \\times 10^{-8}  1.8 \\times 10^{-7} \\end{bmatrix} $$\nCholesky 分解 $S S^\\top = (n+\\lambda)P_{k|k}$ 产生一个下三角矩阵 $S$：\n$$ S_{11} = \\sqrt{8 \\times 10^{-8}} = 2\\sqrt{2} \\times 10^{-4} \\approx 2.8284 \\times 10^{-4} $$\n$$ S_{21} = \\frac{2 \\times 10^{-8}}{S_{11}} = \\frac{1}{\\sqrt{2}} \\times 10^{-4} \\approx 0.7071 \\times 10^{-4} $$\n$$ S_{12} = 0 $$\n$$ S_{22} = \\sqrt{(1.8 \\times 10^{-7}) - S_{21}^2} = \\sqrt{1.8 \\times 10^{-7} - 0.5 \\times 10^{-8}} = \\sqrt{17.5 \\times 10^{-8}} \\approx 4.1833 \\times 10^{-4} $$\n位移向量（$S$ 的列）是 $d_1 = [S_{11}, S_{21}]^\\top$ 和 $d_2 = [S_{12}, S_{22}]^\\top = [0, S_{22}]^\\top$。\n\n步骤 3：传播 Sigma 点并计算预测均值\n将 sigma 点通过状态转移函数 $f(x) = [x_1 + \\sin(x_2), x_2]^\\top$ 进行传播。我们关心的是预测均值的第一个分量 $\\hat{x}_{1, k+1|k}$。\n传播后点的第一个分量为：\n$$ \\mathcal{X}_{1,0}^* = (\\hat{x}_{1,k|k}) + \\sin(\\hat{x}_{2,k|k}) = 0.5 + \\sin(0.1) $$\n$$ \\mathcal{X}_{1,1}^* = (\\hat{x}_{1,k|k} + S_{11}) + \\sin(\\hat{x}_{2,k|k} + S_{21}) $$\n$$ \\mathcal{X}_{1,2}^* = (\\hat{x}_{1,k|k} + S_{12}) + \\sin(\\hat{x}_{2,k|k} + S_{22}) = 0.5 + \\sin(0.1 + S_{22}) $$\n$$ \\mathcal{X}_{1,3}^* = (\\hat{x}_{1,k|k} - S_{11}) + \\sin(\\hat{x}_{2,k|k} - S_{21}) $$\n$$ \\mathcal{X}_{1,4}^* = (\\hat{x}_{1,k|k} - S_{12}) + \\sin(\\hat{x}_{2,k|k} - S_{22}) = 0.5 + \\sin(0.1 - S_{22}) $$\n预测均值是加权和：\n$$ \\hat{x}_{1,k+1|k} = W_0^{(m)} \\mathcal{X}_{1,0}^* + \\sum_{i=1}^{4} W_i^{(m)} \\mathcal{X}_{1,i}^* $$\n为避免因大数相减导致的数值不稳定，我们简化此表达式。使用 $W_0^{(m)} = 1 - 4W_i^{(m)}$：\n$$ \\hat{x}_{1,k+1|k} = (1 - 4W_i^{(m)})\\mathcal{X}_{1,0}^* + W_i^{(m)} \\sum_{i=1}^{4} \\mathcal{X}_{1,i}^* = \\mathcal{X}_{1,0}^* + W_i^{(m)} \\left(\\sum_{i=1}^{4} \\mathcal{X}_{1,i}^* - 4\\mathcal{X}_{1,0}^* \\right) $$\n让我们分析求和项：\n$$ \\sum_{i=1}^{4} \\mathcal{X}_{1,i}^* = (0.5+S_{11})+(0.5)+(0.5-S_{11})+(0.5) + \\sin(0.1+S_{21}) + \\sin(0.1+S_{22}) + \\sin(0.1-S_{21}) + \\sin(0.1-S_{22}) $$\n$$ = 2 + [\\sin(0.1+S_{21}) + \\sin(0.1-S_{21})] + [\\sin(0.1+S_{22}) + \\sin(0.1-S_{22})] $$\n使用恒等式 $\\sin(A+B)+\\sin(A-B) = 2\\sin(A)\\cos(B)$：\n$$ = 2 + 2\\sin(0.1)\\cos(S_{21}) + 2\\sin(0.1)\\cos(S_{22}) $$\n均值公式中括号内的项变为：\n$$ \\sum_{i=1}^{4} \\mathcal{X}_{1,i}^* - 4\\mathcal{X}_{1,0}^* = 2 + 2\\sin(0.1)[\\cos(S_{21}) + \\cos(S_{22})] - 4(0.5 + \\sin(0.1)) $$\n$$ = 2 + 2\\sin(0.1)[\\cos(S_{21}) + \\cos(S_{22})] - 2 - 4\\sin(0.1) $$\n$$ = 2\\sin(0.1)[\\cos(S_{21}) + \\cos(S_{22}) - 2] $$\n将此代回 $\\hat{x}_{1,k+1|k}$ 的公式，并使用 $W_i^{(m)} = 1/(2(n+\\lambda))$：\n$$ \\hat{x}_{1,k+1|k} = \\mathcal{X}_{1,0}^* + \\frac{1}{2(n+\\lambda)} \\left( 2\\sin(0.1)[\\cos(S_{21}) + \\cos(S_{22}) - 2] \\right) $$\n$$ \\hat{x}_{1,k+1|k} = 0.5 + \\sin(0.1) + \\frac{\\sin(0.1)}{n+\\lambda} [\\cos(S_{21}) + \\cos(S_{22}) - 2] $$\n由于 $S_{21}$ 和 $S_{22}$ 非常小，我们使用泰勒展开 $\\cos(x) \\approx 1 - x^2/2$。方括号中的项变为：\n$$ [\\cos(S_{21}) + \\cos(S_{22}) - 2] \\approx (1 - S_{21}^2/2) + (1 - S_{22}^2/2) - 2 = -\\frac{1}{2}(S_{21}^2 + S_{22}^2) $$\n根据 Cholesky 分解的性质，$S_{21}^2 + S_{22}^2 = ((n+\\lambda)P_{k|k})_{22} = (n+\\lambda)P_{22,k|k}$。\n$$ [\\cos(S_{21}) + \\cos(S_{22}) - 2] \\approx -\\frac{1}{2}(n+\\lambda)P_{22,k|k} $$\n对于给定的参数，这个近似非常精确。代入均值表达式中：\n$$ \\hat{x}_{1,k+1|k} \\approx 0.5 + \\sin(0.1) + \\frac{\\sin(0.1)}{n+\\lambda} \\left[ -\\frac{1}{2}(n+\\lambda)P_{22,k|k} \\right] $$\n$$ \\hat{x}_{1,k+1|k} \\approx 0.5 + \\sin(0.1) - \\frac{1}{2} P_{22,k|k} \\sin(0.1) $$\n$$ \\hat{x}_{1,k+1|k} \\approx 0.5 + \\sin(0.1) \\left( 1 - \\frac{P_{22,k|k}}{2} \\right) $$\n现在，我们代入数值：$P_{22,k|k}=0.09$。\n$$ \\hat{x}_{1,k+1|k} \\approx 0.5 + \\sin(0.1) \\left( 1 - \\frac{0.09}{2} \\right) = 0.5 + 0.955 \\sin(0.1) $$\n使用高精度的 $\\sin(0.1) \\approx 0.09983341664682815$ 值：\n$$ \\hat{x}_{1,k+1|k} \\approx 0.5 + 0.955 \\times 0.09983341664682815 $$\n$$ \\hat{x}_{1,k+1|k} \\approx 0.5 + 0.0953409128977209 $$\n$$ \\hat{x}_{1,k+1|k} \\approx 0.5953409128977209 $$\n四舍五入到八位有效数字，结果是 $0.59534091$。\n\n这个结果与期望值的二阶泰勒级数展开是一致的，而无迹变换的设计目的就是为了精确地近似这个值。符号简化对于获得数值稳定的计算是必要的。", "answer": "$$\\boxed{0.59534091}$$", "id": "2888306"}, {"introduction": "扩展卡尔曼滤波器（EKF）对系统进行线性化，而UKF则使用一种确定性采样方法。这项分析性练习通过展示UKF如何精确地捕捉变换后高斯分布的二阶矩，从而揭示了UKF的根本优势，而这正是EKF的一阶近似所忽略的。解决这个问题将阐明UKF在许多非线性系统中具有更高精度的根源 [@problem_id:3380789]。", "problem": "考虑一个标量、离散时间、由噪声驱动的非线性动力学系统，其状态 $x \\in \\mathbb{R}$ 由下式给出\n$$\nx_{k+1} = f(x_k) + w_k, \\quad f(x) = x + \\beta x^{2},\n$$\n其中 $\\beta \\in \\mathbb{R}$ 是一个已知参数，$w_k$ 是零均值过程噪声，且与 $x_k$ 独立。假设在 $k$ 时刻的先验分布是均值和方差如下的高斯分布\n$$\nx_k \\sim \\mathcal{N}(m, P), \\quad P > 0.\n$$\n要求您在两种高斯滤波近似下分析预测均值。\n\n任务：\n1. 使用扩展卡尔曼滤波器 (EKF) 的定义，将 $f$ 在先验均值处进行一阶线性化，推导预测均值 $\\mu_{\\mathrm{EKF}}$。\n2. 使用无迹卡尔曼滤波器 (UKF) 和无迹变换 (UT)，在维数 $L=1$ 以及通用缩放参数 $\\alpha > 0$ 和 $\\kappa \\in \\mathbb{R}$ 的条件下，推导预测均值 $\\mu_{\\mathrm{UKF}}$。使用 $L=1$ 的标准 sigma 点构造方法：\n   - 定义 $\\lambda = \\alpha^{2}(L+\\kappa) - L$。\n   - 定义 sigma 点\n     $$\n     \\chi_{0} = m, \\quad \\chi_{1} = m + \\sqrt{(L+\\lambda)P}, \\quad \\chi_{2} = m - \\sqrt{(L+\\lambda)P}.\n     $$\n   - 使用均值权重\n     $$\n     W_{0}^{(m)} = \\frac{\\lambda}{L+\\lambda}, \\quad W_{1}^{(m)} = W_{2}^{(m)} = \\frac{1}{2(L+\\lambda)}.\n     $$\n   此处不需要出现在协方差公式中的第三个 UT 参数。请明确显示结果对 UT 参数的依赖性或独立性。\n3. 仅使用高斯多项式期望的性质，将精确预测均值 $\\mu_{\\mathrm{exact}} = \\mathbb{E}[f(x_k)]$ 写成 $m$、$P$ 和 $\\beta$ 的函数。\n4. 通过比较您的 EKF 和 UKF 表达式，量化二阶偏差差异，此处定义为预测均值之差 $\\mu_{\\mathrm{UKF}} - \\mu_{\\mathrm{EKF}}$，并将其表示为 $P$、$m$ 和 $\\beta$ 的函数。请以单个简化的解析表达式形式给出最终答案。无需进行数值计算。\n\n答案格式要求：您最终提交的答案必须是单个闭式解析表达式。不包含单位。不要四舍五入。", "solution": "该问题要求分析一个标量非线性系统在三种不同计算方法下的预测均值：扩展卡尔曼滤波器 (EKF)、无迹卡尔曼滤波器 (UKF) 和精确解析期望。最终目标是量化 UKF 和 EKF 预测均值之间的差异。\n\n该系统由状态空间模型 $x_{k+1} = f(x_k) + w_k$ 描述，其中非线性函数为 $f(x) = x + \\beta x^2$。在 $k$ 时刻的状态 $x_k$ 是一个服从高斯分布的随机变量，$x_k \\sim \\mathcal{N}(m, P)$，其中 $m$ 是均值，$P$ 是方差。过程噪声 $w_k$ 是零均值，即 $\\mathbb{E}[w_k] = 0$，且与 $x_k$ 独立。在 $k+1$ 时刻的预测均值为 $\\mathbb{E}[x_{k+1}] = \\mathbb{E}[f(x_k) + w_k] = \\mathbb{E}[f(x_k)] + \\mathbb{E}[w_k] = \\mathbb{E}[f(x_k)]$。因此，任务简化为使用指定方法计算变换后状态的期望 $\\mathbb{E}[f(x_k)]$。\n\n1. EKF 预测均值 $\\mu_{\\mathrm{EKF}}$ 的推导\n\n扩展卡尔曼滤波器使用围绕状态均值 $m$ 的一阶泰勒级数展开来近似非线性函数 $f(x)$。该近似为：\n$$\nf(x_k) \\approx f(m) + f'(m)(x_k - m)\n$$\n$f(x) = x + \\beta x^2$ 对 $x$ 的导数是 $f'(x) = 1 + 2\\beta x$。在 $x=m$ 处求值得到 $f'(m) = 1 + 2\\beta m$。\n\nEKF 预测均值 $\\mu_{\\mathrm{EKF}}$ 是这个线性化函数的期望：\n$$\n\\mu_{\\mathrm{EKF}} = \\mathbb{E}[f(m) + f'(m)(x_k - m)]\n$$\n根据期望的线性性质：\n$$\n\\mu_{\\mathrm{EKF}} = \\mathbb{E}[f(m)] + \\mathbb{E}[f'(m)(x_k - m)]\n$$\n由于 $m$ 是一个常数，所以 $f(m)$ 和 $f'(m)$ 对于关于 $x_k$ 的期望也是常数。因此，我们可以写成：\n$$\n\\mu_{\\mathrm{EKF}} = f(m) + f'(m)\\mathbb{E}[x_k - m]\n$$\n根据定义，$x_k$ 的期望是 $m$，所以 $\\mathbb{E}[x_k - m] = \\mathbb{E}[x_k] - m = m - m = 0$。\n因此，第二项消失：\n$$\n\\mu_{\\mathrm{EKF}} = f(m) = m + \\beta m^2\n$$\n\n2. UKF 预测均值 $\\mu_{\\mathrm{UKF}}$ 的推导\n\n无迹卡尔曼滤波器使用无迹变换 (UT) 来估计变换后分布的均值。它涉及将一组确定性选择的 sigma 点通过真实的非线性函数 $f(x)$ 进行传播，并计算加权平均值。\n\n对于维数 $L=1$，UT 的参数如下：\n- 缩放参数 $\\lambda = \\alpha^2(L+\\kappa) - L = \\alpha^2(1+\\kappa) - 1$。\n- 项 $L+\\lambda = \\alpha^2(1+\\kappa)$。\n- sigma 点为：\n  - $\\chi_0 = m$\n  - $\\chi_1 = m + \\sqrt{(L+\\lambda)P} = m + \\sqrt{\\alpha^2(1+\\kappa)P}$\n  - $\\chi_2 = m - \\sqrt{(L+\\lambda)P} = m - \\sqrt{\\alpha^2(1+\\kappa)P}$\n- 均值的权重为：\n  - $W_0^{(m)} = \\frac{\\lambda}{L+\\lambda} = \\frac{\\lambda}{1+\\lambda}$\n  - $W_1^{(m)} = W_2^{(m)} = \\frac{1}{2(L+\\lambda)} = \\frac{1}{2(1+\\lambda)}$\n\n权重之和为 $W_0^{(m)} + W_1^{(m)} + W_2^{(m)} = \\frac{\\lambda}{1+\\lambda} + 2\\left(\\frac{1}{2(1+\\lambda)}\\right) = \\frac{\\lambda+1}{1+\\lambda} = 1$。\n\nUKF 预测均值为 $\\mu_{\\mathrm{UKF}} = \\sum_{i=0}^{2} W_i^{(m)} f(\\chi_i)$。\n首先，在每个 sigma 点上计算 $f(x) = x + \\beta x^2$：\n- $f(\\chi_0) = f(m) = m + \\beta m^2$\n- $f(\\chi_1) = (m + \\sqrt{(1+\\lambda)P}) + \\beta(m + \\sqrt{(1+\\lambda)P})^2 = m + \\sqrt{(1+\\lambda)P} + \\beta(m^2 + 2m\\sqrt{(1+\\lambda)P} + (1+\\lambda)P)$\n- $f(\\chi_2) = (m - \\sqrt{(1+\\lambda)P}) + \\beta(m - \\sqrt{(1+\\lambda)P})^2 = m - \\sqrt{(1+\\lambda)P} + \\beta(m^2 - 2m\\sqrt{(1+\\lambda)P} + (1+\\lambda)P)$\n\n现在，我们计算加权和：\n$$\n\\mu_{\\mathrm{UKF}} = W_0^{(m)}f(\\chi_0) + W_1^{(m)}f(\\chi_1) + W_2^{(m)}f(\\chi_2)\n$$\n由于 $W_1^{(m)} = W_2^{(m)}$，我们可以对项进行分组：\n$$\n\\mu_{\\mathrm{UKF}} = W_0^{(m)}f(\\chi_0) + W_1^{(m)}(f(\\chi_1) + f(\\chi_2))\n$$\n我们来计算和 $f(\\chi_1) + f(\\chi_2)$：\n$$\nf(\\chi_1) + f(\\chi_2) = (2m) + \\beta( (m^2 + 2m\\sqrt{\\dots} + (1+\\lambda)P) + (m^2 - 2m\\sqrt{\\dots} + (1+\\lambda)P) )\n$$\n$$\nf(\\chi_1) + f(\\chi_2) = 2m + \\beta(2m^2 + 2(1+\\lambda)P) = 2(m + \\beta m^2) + 2\\beta(1+\\lambda)P\n$$\n将此代回 $\\mu_{\\mathrm{UKF}}$ 的表达式中：\n$$\n\\mu_{\\mathrm{UKF}} = W_0^{(m)}(m + \\beta m^2) + W_1^{(m)}[2(m + \\beta m^2) + 2\\beta(1+\\lambda)P]\n$$\n$$\n\\mu_{\\mathrm{UKF}} = (W_0^{(m)} + 2W_1^{(m)})(m + \\beta m^2) + 2W_1^{(m)}\\beta(1+\\lambda)P\n$$\n由于权重之和为 $W_0^{(m)} + 2W_1^{(m)} = 1$，且 $2W_1^{(m)} = 2\\left(\\frac{1}{2(1+\\lambda)}\\right) = \\frac{1}{1+\\lambda}$，这可以简化为：\n$$\n\\mu_{\\mathrm{UKF}} = 1 \\cdot (m + \\beta m^2) + \\frac{1}{1+\\lambda}\\beta(1+\\lambda)P = m + \\beta m^2 + \\beta P\n$$\nUKF 预测均值为 $\\mu_{\\mathrm{UKF}} = m + \\beta m^2 + \\beta P$。值得注意的是，这个结果与 UT 的缩放参数 $\\alpha$ 和 $\\kappa$ 无关。\n\n3. 精确预测均值 $\\mu_{\\mathrm{exact}}$ 的推导\n\n精确预测均值是在 $x_k \\sim \\mathcal{N}(m, P)$ 的条件下 $f(x_k)$ 的真实期望。\n$$\n\\mu_{\\mathrm{exact}} = \\mathbb{E}[f(x_k)] = \\mathbb{E}[x_k + \\beta x_k^2]\n$$\n利用期望的线性性质：\n$$\n\\mu_{\\mathrm{exact}} = \\mathbb{E}[x_k] + \\beta \\mathbb{E}[x_k^2]\n$$\n我们已知 $\\mathbb{E}[x_k] = m$。二阶矩 $\\mathbb{E}[x_k^2]$ 通过公式 $\\mathrm{Var}(x_k) = \\mathbb{E}[x_k^2] - (\\mathbb{E}[x_k])^2$ 与均值和方差相关联。\n已知 $\\mathrm{Var}(x_k) = P$，我们有：\n$$\n\\mathbb{E}[x_k^2] = \\mathrm{Var}(x_k) + (\\mathbb{E}[x_k])^2 = P + m^2\n$$\n将此代入 $\\mu_{\\mathrm{exact}}$ 的表达式中：\n$$\n\\mu_{\\mathrm{exact}} = m + \\beta (P + m^2) = m + \\beta m^2 + \\beta P\n$$\n这表明对于二次非线性，无迹变换提供了精确的预测均值，即 $\\mu_{\\mathrm{UKF}} = \\mu_{\\mathrm{exact}}$。\n\n4. 二阶偏差差异的计算\n\n问题将二阶偏差差异定义为 UKF 和 EKF 预测均值之差，即 $\\mu_{\\mathrm{UKF}} - \\mu_{\\mathrm{EKF}}$。使用前面部分的结果：\n- $\\mu_{\\mathrm{EKF}} = m + \\beta m^2$\n- $\\mu_{\\mathrm{UKF}} = m + \\beta m^2 + \\beta P$\n\n差值为：\n$$\n\\mu_{\\mathrm{UKF}} - \\mu_{\\mathrm{EKF}} = (m + \\beta m^2 + \\beta P) - (m + \\beta m^2)\n$$\n$$\n\\mu_{\\mathrm{UKF}} - \\mu_{\\mathrm{EKF}} = \\beta P\n$$\n这个项 $\\beta P$ 代表了 EKF 均值预测中的主阶误差，或称偏差。这种偏差的产生是因为 EKF 近似对函数进行了线性化，从而忽略了其曲率（二阶导数）对变换后分布均值的影响。而 UKF 通过其对称的 sigma 点集，正确地捕捉到了这个二阶项，从而得出了一个更准确的均值估计，在这个二次函数的情况下，这个估计是精确的。两个滤波器预测值之间的差异正是这个二阶项。\n最终要求的表达式是这个差异的解析形式。", "answer": "$$\\boxed{\\beta P}$$", "id": "3380789"}, {"introduction": "没有滤波器是完美的，了解一个工具的局限性与了解其优势同样重要。这个练习呈现了一个精心设计的场景，其中UKF尽管其设计复杂，但由于非线性的特性和滤波器参数的选择，其性能可能比更简单的EKF更差。通过分析这种“失效模式”，你将对应用UKF形成一种更具批判性和细致入微的视角，突显了参数调整以及理解西格玛点与系统动力学之间相互作用的重要性 [@problem_id:3429813]。", "problem": "考虑一个没有过程噪声或观测噪声的确定性、离散时间、一维状态空间系统。令状态表示为 $x_k \\in \\mathbb{R}$，其根据一个分段线性切换映射演化，该映射由一个线性映射与一个符号切换复合而成。具体来说，动力学函数 $f$ 和观测函数 $h$ 定义如下\n- $f(x) = a \\, s(x) \\, x$，其中如果 $x \\ge 0$，$s(x) = 1$，否则 $s(x) = -1$，并且 $a \\in \\mathbb{R}$ 是一个已知常数，\n- $h(x) = x$。\n假设系统中没有任何过程噪声和测量噪声，并且不进行任何测量数据融合；只执行时间传播。\n\n给定时间 $k=0$ 时的初始高斯先验状态分布，记为 $\\mathcal{N}(m_0, P_0)$，其中 $m_0 \\in \\mathbb{R}$ 且 $P_0 > 0$。真实状态 $x_k$ 从 $x_0 = m_0$ 开始，通过 $x_{k+1} = f(x_k)$ 确定性地演化。由于 $s(x)$ 的符号结构和下面选择的参数，真实状态在所有感兴趣的时间内都保持在单个线性分支上。\n\n您的任务是：\n- 为上述系统实现扩展卡尔曼滤波器 (EKF) 和无迹卡尔曼滤波器 (UKF) 的均值和协方差传播器。对于 UKF，使用带有参数 $\\alpha$、$\\kappa$ 和 $\\beta$ 的标准无迹变换，其中状态维度 $n=1$。参数 $\\beta$ 应设置为高斯先验的标准值。\n- 在没有任何测量更新的情况下，将两个滤波器传播 $T$ 个时间步。\n- 对于每个测试的 $(\\alpha,\\kappa)$ 对，计算从 $x_0 = m_0$ 开始的 UKF 在时间 $T$ 的均值相对于真实状态 $x_T$ 的绝对误差。\n- 使用 EKF 验证其在这种情况下保持精确（此验证是内部的，无需在最终输出中报告；必须在您的代码中使用它以确保科学和数值的正确性）。\n- 对于每个 $(\\alpha,\\kappa)$，根据以下标准返回一个布尔标志，指示 UKF 是否发散。\n\n基本原理和约束：\n- 确定性传播：$x_{k+1} = f(x_k)$，其中 $f(x) = a \\, s(x) \\, x$，且系统中无任何噪声。\n- 确定性映射下的高斯先验传播：对于 $X_k \\sim \\mathcal{N}(m_k, P_k)$，精确均值演化为 $m_{k+1} = \\mathbb{E}[f(X_k)]$，而 EKF 和 UKF 以不同方式逼近该均值。\n- 扩展卡尔曼滤波器 (EKF) 在当前均值处对动力学进行线性化，并使用局部雅可比矩阵传播均值和协方差，就好像映射在均值邻域内是线性的一样。\n- 无迹卡尔曼滤波器 (UKF) 通过无迹变换，使用由 $\\alpha$、$\\kappa$ 和 $\\beta$ 决定的权重的 $2n+1$ 个 sigma 点来逼近均值和协方差。\n\n要使用的场景参数：\n- $n = 1$，\n- $a = 1.5$ (无单位)，\n- $m_0 = 0.05$ (无单位)，\n- $P_0 = 0.04$ (无单位)，\n- $T = 10$ (无单位时间步)，\n- $\\beta = 2$ (高斯先验的标准选择)。\n\n发散的定义：\n- 定义发散阈值为 $\\tau = 0.5$ (无单位)。如果绝对误差 $|m_T^{\\text{UKF}} - x_T|$ 超过 $\\tau$，则称 UKF 对于给定的 $(\\alpha,\\kappa)$ 发散，其中 $m_T^{\\text{UKF}}$ 是经过 $T$ 次传播后的 UKF 均值，而 $x_T$ 是从 $x_0 = m_0$ 开始经过 $T$ 步后的真实状态。\n\n测试套件：\n为以下 $(\\alpha,\\kappa)$ 对评估发散标志：\n- 情况 $1$：$(\\alpha,\\kappa) = (0.1, 0.0)$，\n- 情况 $2$：$(\\alpha,\\kappa) = (0.5, 0.0)$，\n- 情况 $3$：$(\\alpha,\\kappa) = (1.0, 0.0)$，\n- 情况 $4$：$(\\alpha,\\kappa) = (0.9, -0.5)$，\n- 情况 $5$：$(\\alpha,\\kappa) = (0.05, 2.0)$。\n\n附加要求和说明：\n- 确保在所有测试用例中，无迹变换的缩放量 $n+\\lambda$ 为正，其中 $\\lambda = \\alpha^2 (n+\\kappa) - n$，以便 sigma 点有良好定义。以上测试值满足此条件。\n- 不涉及角度；除了提供的无单位标量外，不需要特殊的单位处理。\n- 程序必须为每个测试用例计算一个布尔结果，根据上述标准指示 UKF 是否发散（真）或不发散（假）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，布尔值采用编程语言原生布尔字符串格式（例如，$[True,False,True,False,True]$）。顺序必须与上述五个情况相匹配。", "solution": "问题陈述被评估为有效。它在科学上基于估计理论，在数学上是适定的，并且所有参数和条件都得到了明确的规定。\n\n核心任务是通过随时间传播初始高斯分布，并将滤波器的预测均值与真实的确定性状态演化进行比较，来分析无迹卡尔曼滤波器 (UKF) 在一维非线性系统中的性能。\n\n**1. 系统动力学和真实状态演化**\n\n系统状态根据离散时间映射 $x_{k+1} = f(x_k)$ 演化。函数 $f(x)$ 定义为 $f(x) = a \\cdot s(x) \\cdot x$，其中 $a = 1.5$，$s(x)$ 是一个类符号函数，当 $x \\ge 0$ 时 $s(x)=1$，当 $x  0$ 时 $s(x)=-1$。我们可以更紧凑地表示 $f(x)$。\n- 如果 $x \\ge 0$，$f(x) = a \\cdot (1) \\cdot x = ax = a|x|$。\n- 如果 $x  0$，$f(x) = a \\cdot (-1) \\cdot x = -ax = a|x|$。\n因此，对于所有 $x \\in \\mathbb{R}$，动力学由函数 $f(x) = a|x|$ 给出。\n\n真实状态在 $x_0 = m_0 = 0.05$ 处初始化并确定性地演化。由于 $x_0 > 0$ 且 $a = 1.5 > 1$，第一个状态是 $x_1 = f(x_0) = 1.5 \\cdot |0.05| = 0.075$。通过归纳法，如果 $x_k > 0$，则 $x_{k+1} = a x_k > x_k > 0$。因此，真实状态 $x_k$ 对所有 $k \\ge 0$ 保持为正。演化是一个简单的几何级数：\n$$x_k = a^k x_0$$\n经过 $T=10$ 个时间步后，真实状态为 $x_T = a^T m_0 = (1.5)^{10} \\cdot 0.05$。该值作为评估 UKF 准确性的基准真相。\n\n**2. 作为参考的扩展卡尔曼滤波器 (EKF)**\n\nEKF 通过在当前均值附近对动力学进行线性化来传播均值 $m_k$ 和协方差 $P_k$。预测均值由 $m_{k+1}^{\\text{EKF}} = f(m_k^{\\text{EKF}})$ 给出。\n从 $m_0^{\\text{EKF}} = m_0 = 0.05 > 0$ 开始，EKF 的均值在所有后续步骤中也保持为正，遵循与真实状态相同的逻辑。因此，$f(m_k^{\\text{EKF}}) = a \\cdot |m_k^{\\text{EKF}}| = a \\cdot m_k^{\\text{EKF}}$。EKF 均值演化如下：\n$$m_{k+1}^{\\text{EKF}} = a \\cdot m_k^{\\text{EKF}}$$\n这与真实状态 $x_k$ 的递推关系相同。由于它们从相同的初始条件 ($m_0^{\\text{EKF}} = x_0$) 开始，EKF 均值在所有时间都完美地跟踪真实状态：$m_k^{\\text{EKF}} = x_k$。\n问题中提到 EKF 是“精确的”指的是这一事实：其均值估计 $m_T^{\\text{EKF}}$ 与真实的确定性状态 $x_T$ 完全相同。因此，误差 $|m_T^{\\text{UKF}} - x_T|$ 等价于 $|m_T^{\\text{UKF}} - m_T^{\\text{EKF}}|$。\n\n**3. 无迹卡尔曼滤波器 (UKF) 传播算法**\n\nUKF 通过将一组确定性选择的“sigma 点”通过真实的非线性函数进行传播来避免直接线性化。然后从这些传播后的点重构均值和协方差。\n\n对于状态维度 $n=1$，UKF 使用 $2n+1=3$ 个 sigma 点。它们的位置由当前均值 $m_k$、协方差 $P_k$ 以及参数 $\\alpha$、$\\kappa$ 决定。缩放参数 $\\lambda$ 计算如下：\n$$\\lambda = \\alpha^2 (n+\\kappa) - n = \\alpha^2 (1+\\kappa) - 1$$\n步骤 $k$ 的 sigma 点为：\n$$\n\\begin{align*}\n\\mathcal{X}_k^{(0)} = m_k^{\\text{UKF}} \\\\\n\\mathcal{X}_k^{(1)} = m_k^{\\text{UKF}} + \\sqrt{(n+\\lambda)P_k^{\\text{UKF}}} \\\\\n\\mathcal{X}_k^{(2)} = m_k^{\\text{UKF}} - \\sqrt{(n+\\lambda)P_k^{\\text{UKF}}}\n\\end{align*}\n$$\n用于重构均值 ($W^{(m)}$) 和协方差 ($W^{(c)}$) 的权重使用 $\\lambda$、$\\alpha$ 和 $\\beta=2$ 定义：\n$$\n\\begin{align*}\nW_0^{(m)} = \\frac{\\lambda}{n+\\lambda} \\quad  W_i^{(m)} = \\frac{1}{2(n+\\lambda)} \\quad \\text{for } i=1,2 \\\\\nW_0^{(c)} = \\frac{\\lambda}{n+\\lambda} + (1-\\alpha^2+\\beta) \\quad  W_i^{(c)} = \\frac{1}{2(n+\\lambda)} \\quad \\text{for } i=1,2\n\\end{align*}\n$$\n每个时间步 $k$ 的传播过程如下：\n1.  **传播点**：每个 sigma 点都通过非线性函数 $f(x)=a|x|$ 进行传播：\n    $$\\mathcal{Y}_k^{(i)} = f(\\mathcal{X}_k^{(i)}) = a|\\mathcal{X}_k^{(i)}| \\quad \\text{for } i=0,1,2$$\n2.  **预测均值**：预测均值 $m_{k+1}^{\\text{UKF}}$ 是传播后各点的加权平均值：\n    $$m_{k+1}^{\\text{UKF}} = \\sum_{i=0}^{2} W_i^{(m)} \\mathcal{Y}_k^{(i)}$$\n3.  **预测协方差**：预测协方差 $P_{k+1}^{\\text{UKF}}$ 是平方偏差的加权和：\n    $$P_{k+1}^{\\text{UKF}} = \\sum_{i=0}^{2} W_i^{(c)} (\\mathcal{Y}_k^{(i)} - m_{k+1}^{\\text{UKF}})^2$$\n\n**4. UKF 行为和发散分析**\n\nUKF 行为的关键在于其 sigma 点如何与 $x=0$ 处的非线性相互作用。sigma 点的散布由项 $\\sqrt{(n+\\lambda)P_k} = \\sqrt{\\alpha^2(1+\\kappa)P_k} = |\\alpha|\\sqrt{(1+\\kappa)P_k}$ 控制。\n-   如果所有三个 sigma 点 $\\mathcal{X}_k^{(0)}, \\mathcal{X}_k^{(1)}, \\mathcal{X}_k^{(2)}$ 都是非负的，则变换在这些点上实际上是线性的 ($f(x)=ax$)。在这种情况下，UKF 均值更新得出 $m_{k+1}^{\\text{UKF}} = a m_k^{\\text{UKF}}$，其行为与 EKF 完全相同。这发生在散布足够小，以至于 $m_k^{\\text{UKF}} - |\\alpha|\\sqrt{(1+\\kappa)P_k^{\\text{UKF}}} \\ge 0$ 时。\n-   如果散布足够大，下 sigma 点 $\\mathcal{X}_k^{(2)}$ 可能会变为负数，而中心点 $m_k^{\\text{UKF}}$ 保持为正。函数 $f(x)=a|x|$ 将这个负点“折叠”到一个正值：$\\mathcal{Y}_k^{(2)} = a|\\mathcal{X}_k^{(2)}|  0$。由于传播后的点 $\\mathcal{Y}_k^{(1)}$ 和 $\\mathcal{Y}_k^{(2)}$ 现在相对于传播后的中心点 $\\mathcal{Y}_k^{(0)}$ 不对称地分布，重构的均值 $m_{k+1}^{\\text{UKF}}$ 会发生偏斜，通常会偏向一个比真实状态演化所暗示的要大得多的值。\n\n这个误差在 $T=10$ 个步骤中累积。导致 sigma 点散布更大的参数 $(\\alpha, \\kappa)$ 将导致这种交叉更早、更严重地发生，从而增加最终误差 $|m_T^{\\text{UKF}} - x_T|$。如果此误差超过阈值 $\\tau=0.5$，则认为滤波器已发散。\n\n**5. 实现与评估**\n\n所描述的 UKF 传播算法将为五个测试用例 $(\\alpha, \\kappa)$ 中的每一个实现。从初始状态 $m_0=0.05$ 和 $P_0=0.04$ 开始，滤波器迭代 $T=10$ 步。计算最终的 UKF 均值 $m_T^{\\text{UKF}}$ 并与真实状态 $x_T=(1.5)^{10} \\cdot 0.05$ 进行比较。然后为每种情况确定发散的布尔标志 $|m_T^{\\text{UKF}} - x_T| > 0.5$。程序将按指定顺序输出这些布尔标志。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Unscented Kalman Filter (UKF) time propagation for a \n    1D nonlinear system and checks for divergence against the true state.\n    \"\"\"\n    # Define problem constants and parameters\n    a = 1.5         # Dynamics parameter\n    m0 = 0.05       # Initial mean\n    P0 = 0.04       # Initial covariance\n    T = 10          # Number of time steps\n    beta = 2.0      # UKF parameter for Gaussian priors\n    tau = 0.5       # Divergence threshold\n    n = 1.0         # State dimension (as float for calculations)\n\n    # Test suite of (alpha, kappa) pairs\n    test_cases = [\n        (0.1, 0.0),\n        (0.5, 0.0),\n        (1.0, 0.0),\n        (0.9, -0.5),\n        (0.05, 2.0),\n    ]\n\n    # Calculate the true final state x_T after T steps of deterministic evolution.\n    # The true state x_k remains positive since x0 > 0 and a > 1, so x_{k+1} = a*x_k.\n    x_T = m0 * (a ** T)\n\n    results = []\n    \n    # The dynamics function f(x) = a * s(x) * x simplifies to a * |x|.\n    def f_dynamics(x, a_param):\n        return a_param * np.abs(x)\n\n    # Iterate through each test case\n    for alpha, kappa in test_cases:\n        # Initialize UKF mean and covariance for the current case\n        m_ukf = m0\n        P_ukf = P0\n\n        # --- UKF Parameter and Weight Calculation ---\n        # Calculate the composite scaling parameter lambda\n        lambda_ = alpha**2 * (n + kappa) - n\n\n        # Calculate weights for the mean (Wm) and covariance (Wc)\n        # We need 2n+1 = 3 weights\n        Wm = np.full(3, 0.5 / (n + lambda_))\n        Wc = np.full(3, 0.5 / (n + lambda_))\n        Wm[0] = lambda_ / (n + lambda_)\n        Wc[0] = lambda_ / (n + lambda_) + (1 - alpha**2 + beta)\n\n        # --- UKF Time Propagation Loop ---\n        for _ in range(T):\n            # 1. Generate sigma points\n            # The square root of the matrix P_ukf must be handled carefully.\n            # For 1D, this is just the standard deviation.\n            # The scaling factor gamma is sqrt(n + lambda).\n            gamma = np.sqrt(n + lambda_)\n            sigma_offset = gamma * np.sqrt(P_ukf)\n            \n            # Sigma points for n=1 state\n            X0 = m_ukf\n            X1 = m_ukf + sigma_offset\n            X2 = m_ukf - sigma_offset\n            \n            # 2. Propagate sigma points through the nonlinear dynamics\n            Y0 = f_dynamics(X0, a)\n            Y1 = f_dynamics(X1, a)\n            Y2 = f_dynamics(X2, a)\n\n            # 3. Predict the new mean from propagated points\n            m_ukf = Wm[0] * Y0 + Wm[1] * Y1 + Wm[2] * Y2\n\n            # 4. Predict the new covariance\n            P_ukf = (Wc[0] * (Y0 - m_ukf)**2 +\n                     Wc[1] * (Y1 - m_ukf)**2 +\n                     Wc[2] * (Y2 - m_ukf)**2)\n\n        # After T steps, compare the final UKF mean to the true state\n        error = np.abs(m_ukf - x_T)\n        diverged = error > tau\n        results.append(diverged)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```", "id": "3429813"}]}