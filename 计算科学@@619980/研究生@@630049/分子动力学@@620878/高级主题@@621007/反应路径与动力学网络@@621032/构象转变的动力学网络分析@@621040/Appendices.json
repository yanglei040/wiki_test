{"hands_on_practices": [{"introduction": "动态网络分析的第一步是将连续的分子动力学轨迹数据转化为一个离散的状态网络。本练习将指导您完成这一基本流程，从将数据点聚类成微观状态，到构建一个描述状态间转移的概率矩阵，为所有后续分析奠定基础。通过这个实践 [@problem_id:3408877]，您将掌握从原始（合成的）数据到可分析的网络模型的完整构建方法。", "problem": "给定一个低维嵌入空间中按时间排序的构型，该嵌入模拟了经历罕见构象转变的分子动力学轨迹的扩散图坐标。您的任务是，从基本原理出发，实现一个处理流程，该流程通过在主要扩散坐标中进行聚类来构建微观态，然后根据这些微观态之间观测到的跃迁建立一个有向动力学网络。您必须编写一个单一程序，该程序能够生成确定性的合成嵌入轨迹，在主要扩散坐标中使用 $k$-均值算法进行聚类，根据微观态之间的观测跃迁估计一个离散时间马尔可夫链，并报告每个测试用例指定的标量诊断指标。\n\n基本出发点和定义：\n- 微观态分解是将构型空间划分为 $K$ 个不相交的簇。$k$-均值算法旨在寻找一个划分 $\\{C_1,\\dots,C_K\\}$ 和质心 $\\{\\mu_1,\\dots,\\mu_K\\}$，以最小化 $\\sum_{i=1}^{K} \\sum_{x \\in C_i} \\lVert x - \\mu_i \\rVert^2$，其中 $\\lVert \\cdot \\rVert$ 表示欧几里得范数。\n- 给定一个按时间排序的微观态标签序列 $\\{s_t\\}_{t=0}^{T-1}$，经验跃迁计数矩阵 $N \\in \\mathbb{N}^{K \\times K}$ 定义为 $N_{ij} = \\#\\{t \\in \\{0,\\dots,T-2\\} : s_t = i, s_{t+1} = j\\}$。行随机跃迁概率矩阵 $P \\in \\mathbb{R}^{K \\times K}$ 通过 $P_{ij} = N_{ij} / \\sum_{j'} N_{ij'}$（如果 $\\sum_{j'} N_{ij'} > 0$）和 $P_{ij} = 0$（否则）来估计。\n- $P$ 的特征值满足 $\\lambda_1 = 1$（对于任何行随机矩阵 $P$）。第二大特征值模 (SLEM) 定义为 $\\max\\{|\\lambda| : \\lambda \\text{ is an eigenvalue of } P, \\lambda \\neq 1\\}$（当至少存在两个特征值时）；如果 $K=1$ 因而只有一个特征值，则按惯例将 SLEM 取为 $0$。\n\n每个测试用例的数据生成：您将如下合成一个确定性的、按时间排序的嵌入轨迹 $X \\in \\mathbb{R}^{T \\times d}$，其中 $d=3$。定义一个慢变切换信号 $s(t)$，它有两个可能的盆地（值接近 $-1$ 和 $+1$）和最多两个斜坡：\n- 令 $t \\in \\{0, 1, \\dots, T-1\\}$。\n- 对所有 $t$ 初始化 $s(t) = -1$。\n- 定义一个从 $t_{\\text{up}}$ 开始、持续 $R$ 帧的上升斜坡：对于 $t_{\\text{up}} \\le t  \\min(t_{\\text{up}} + R, T)$，设置 $s(t) = -1 + 2\\,(t - t_{\\text{up}})/R$；对于 $t \\ge \\min(t_{\\text{up}} + R, T)$，设置 $s(t) = +1$（除非被下面的下降斜坡修改）。\n- 定义一个从 $t_{\\text{down}}$ 开始、持续 $R$ 帧的可选下降斜坡：对于 $t_{\\text{down}} \\le t  \\min(t_{\\text{down}} + R, T)$，设置 $s(t) = +1 - 2\\,(t - t_{\\text{down}})/R$；对于 $t \\ge \\min(t_{\\text{down}} + R, T)$，设置 $s(t) = -1$。如果 $t_{\\text{down}} \\ge T$，则不发生下降斜坡。\n- 定义角频率 $\\omega = 2\\pi/M$，单位为弧度/帧。构造坐标\n$$\n\\begin{aligned}\nx_1(t) = s(t) + a \\sin(\\omega t),\\\\\nx_2(t) = \\tfrac{1}{2}\\,s(t) + a \\cos(\\omega t),\\\\\nx_3(t) = \\tfrac{1}{4}\\,\\sin(2 \\omega t).\n\\end{aligned}\n$$\n对每个 $t$ 设置 $X(t,:) = (x_1(t), x_2(t), x_3(t))$。\n\n聚类和网络构建：\n- 仅使用 $X$ 的前 $q$ 个坐标（“主要扩散坐标”）进行聚类。\n- 在聚类之前，沿每个坐标将这 $q$ 个坐标标准化为零均值和单位方差。如果某个坐标的方差为零，则将其标准差视为 $1$ 以避免除以零，从而保持该坐标不变。\n- 使用 Lloyd’s algorithm 和确定性最远点初始化方法，实现具有 $K$ 个簇的 $k$-均值算法：\n  1. 选择欧几里得范数最小的数据点作为第一个中心。\n  2. 对于每个后续的中心，选择与已选中心集中最近的中心距离最大的数据点。\n  3. 迭代分配（依据最近的中心）和更新（质心为算术平均值）步骤，直到标签不再改变或达到最大迭代次数 $M_{\\text{it}}$。如果出现空簇，将其中心重新初始化为与其当前分配的中心距离最大的数据点，然后继续。\n- 根据按时间排序的簇标签，构建经验跃迁计数矩阵 $N$ 和行随机跃迁矩阵 $P$，包括自跃迁。\n\n每个测试用例的所需输出：\n- 令 $E$ 为具有严格正跃迁概率的有向边的数量，即 $P_{ij}  0$ 的条目计数。\n- 令 $\\theta$ 为 $P$ 的第二大特征值模 (SLEM)，如上文所定义。\n- 令 $f_{\\max}$ 为在占据率最高的微观态中花费的时间比例，计算方法为最大占据数除以 $T$。\n- 为每个测试用例报告列表 $[E, \\mathrm{round}(\\theta, 6), \\mathrm{round}(f_{\\max}, 6)]$，其中四舍五入到小数点后 $6$ 位。三角函数的角度必须以弧度计算。\n\n测试套件：\n- 情况 A: $(T, t_{\\text{up}}, t_{\\text{down}}, R, a, M, q, K) = (300, 80, 200, 20, 0.05, 15, 2, 2)$。\n- 情况 B (简并聚类边界): $(T, t_{\\text{up}}, t_{\\text{down}}, R, a, M, q, K) = (180, 60, 140, 10, 0.02, 12, 2, 1)$。\n- 情况 C (单向跃迁边界情况): $(T, t_{\\text{up}}, t_{\\text{down}}, R, a, M, q, K) = (250, 160, 1000, 20, 0.04, 20, 2, 2)$。\n为 $k$-均值算法使用最多 $M_{\\text{it}} = 100$ 次迭代。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身是对应一个测试用例的包含三个数字的方括号列表，顺序与上文所列相同。例如，输出格式必须与\n$[ [E_A,\\theta_A,f_{\\max,A}],[E_B,\\theta_B,f_{\\max,B}],[E_C,\\theta_C,f_{\\max,C}] ]$\n完全一致，除了所示空格外不需要额外的空格，也不需要额外的文本。所有量均为无量纲量，所有三角函数参数均以弧度为单位。", "solution": "该问题要求实现一个确定性的计算流程来分析合成分子动力学数据。该流程涉及合成轨迹，使用 $k$-均值聚类将其划分为微观态，构建一个马尔可夫动力学网络，并计算特定的网络诊断指标。解决方案将遵循所提供的定义和原则，分步进行阐述。\n\n### 1. 轨迹合成\n对于每个测试用例，会生成一个按时间排序的轨迹 $X \\in \\mathbb{R}^{T \\times d}$，其维度为 $d=3$，长度为 $T$ 帧。时间索引为 $t \\in \\{0, 1, \\dots, T-1\\}$。\n\n首先，构建一个慢变切换信号 $s(t)$，它模拟了两个亚稳态盆地（$s \\approx -1$ 和 $s \\approx +1$）之间的跃迁。该信号按以下方式生成：\n1.  初始化一个长度为 $T$ 的数组 $s$，其所有值为 $-1$。\n2.  引入一个从时间 $t_{\\text{up}}$ 开始，持续 $R$ 帧的上升斜坡。在时间步 $t$ 处于区间 $[t_{\\text{up}}, \\min(t_{\\text{up}} + R, T))$ 内，信号从 $-1$ 线性插值到 $+1$：\n    $$s(t) = -1 + 2 \\cdot \\frac{t - t_{\\text{up}}}{R}$$\n    对于所有后续时间 $t \\ge \\min(t_{\\text{up}} + R, T)$，信号被设置为 $s(t) = +1$。\n3.  一个与上升斜坡对称的可选下降斜坡从 $t_{\\text{down}}$ 开始。如果 $t_{\\text{down}}  T$，则在 $t$ 处于区间 $[t_{\\text{down}}, \\min(t_{\\text{down}} + R, T))$ 内，信号从 $+1$ 线性插值到 $-1$：\n    $$s(t) = +1 - 2 \\cdot \\frac{t - t_{\\text{down}}}{R}$$\n    对于所有后续时间 $t \\ge \\min(t_{\\text{down}} + R, T)$，信号被设置为 $s(t) = -1$。这个下降斜坡及其后续影响会覆盖由上升斜坡逻辑设置的任何值。\n\n定义了慢变信号 $s(t)$ 后，构建三维坐标 $X(t,:) = (x_1(t), x_2(t), x_3(t))$。这些坐标将慢速跃迁与更快的周期性局部运动耦合起来，后者由角频率 $\\omega = 2\\pi/M$ 控制：\n$$\n\\begin{aligned}\nx_1(t) = s(t) + a \\sin(\\omega t) \\\\\nx_2(t) = \\tfrac{1}{2}\\,s(t) + a \\cos(\\omega t) \\\\\nx_3(t) = \\tfrac{1}{4}\\,\\sin(2 \\omega t)\n\\end{aligned}\n$$\n参数 $a$ 控制快速涨落的振幅。\n\n### 2. 微观态聚类\n使用 $k$-均值聚类将连续轨迹离散化为一系列微观态。\n\n首先，准备用于聚类的数据。按照规定，仅使用轨迹 $X$ 的前 $q$ 个坐标。然后，对该子矩阵 $X_{:,:q} \\in \\mathbb{R}^{T \\times q}$ 进行标准化。对于这 $q$ 个坐标中的每一个，均值被移至零，方差被缩放为一。如果某个坐标的方差为零（即其标准差为 $0$），则将其标准差视为 $1$ 以防止除以零，从而保持该坐标不变，因为它已经是中心化的。\n\n接着，应用 $k$-均值聚类将 $T$ 个标准化数据点划分为 $K$ 个簇。该实现使用 Lloyd's algorithm 和一种确定性初始化方案，以确保结果可复现。\n-   **初始化（最远点法）**：\n    1.  选择欧几里得范数最小的数据点作为第一个质心。\n    2.  对于从 $2$ 到 $K$ 的每个后续质心 $i$，选择与所有先前选择的质心（$1, \\dots, i-1$）的最小平方欧几里得距离最大的数据点。\n-   **迭代（Lloyd's Algorithm）**：算法迭代执行两个步骤，直到簇分配不再改变或达到最大迭代次数 $M_{\\text{it}} = 100$。\n    1.  **分配步骤**：根据欧几里得距离，将每个数据点分配给相应最近的质心所在的簇。这会产生一个按时间排序的簇标签序列 $\\{z_t\\}_{t=0}^{T-1}$，其中 $z_t \\in \\{0, 1, \\dots, K-1\\}$。\n    2.  **更新步骤**：每个簇的质心被重新计算为分配给该簇的所有数据点的算术平均值。\n-   **空簇处理**：如果在一次迭代中某个簇变为空（即没有点被分配给它），其质心将被重新初始化。新的质心被选为与其自身当前分配的质心具有最大平方欧几里得距离的数据点。此过程“窃取”一个拟合不佳的点来为空簇提供种子，从而确保所有 $K$ 个簇保持活动状态。此操作发生在更新步骤内部、下一次迭代开始之前。\n\n### 3. 动力学网络分析\n微观态标签的时间序列 $\\{z_t\\}$ 用于构建一个离散时间马尔可夫链，由一个跃迁概率矩阵 $P$ 表示。\n\n-   **跃迁计数矩阵 ($N$)**：构建一个 $K \\times K$ 的矩阵 $N$，其中条目 $N_{ij}$ 统计在时间延迟为一帧的情况下，从微观态 $i$ 跃迁到微观态 $j$ 的观测次数：\n    $$N_{ij} = \\#\\{t \\in \\{0, \\dots, T-2\\} : z_t = i, z_{t+1} = j\\}$$\n-   **跃迁概率矩阵 ($P$)**：计数矩阵 $N$ 按行归一化，得到行随机跃迁概率矩阵 $P \\in \\mathbb{R}^{K \\times K}$。从状态 $i$ 跃迁到状态 $j$ 的概率估计为：\n    $$P_{ij} = \\frac{N_{ij}}{\\sum_{k=0}^{K-1} N_{ik}}$$\n    如果一个状态 $i$ 没有观测到出向跃迁（即 $\\sum_{k} N_{ik} = 0$，这种情况只可能在状态 $i$ 仅在最后一个时间步 $t=T-1$ 被访问时发生），其对应的行 $P_{i,:}$ 将被设置为全零。\n\n最后，针对每个测试用例，从此模型中计算三个标量诊断指标：\n1.  **边的数量 ($E$)**：这是网络中有向边的数量，其跃迁概率为正，计算为矩阵 $P$ 中严格正值的条目数：$E = \\#\\{(i,j) : P_{ij}  0\\}$。\n2.  **第二大特征值模 ($\\theta$)**：这是矩阵 $P$ 的 SLEM，定义为 $\\theta = \\max\\{|\\lambda| : \\lambda \\text{ is an eigenvalue of } P, \\lambda \\neq 1\\}$。对于 $K=1$ 的情况，按惯例将 SLEM 取为 $0$。计算上，这通过计算 $P$ 的所有特征值，取其绝对值，进行排序，然后选择第二大的值来实现。由于 $P$ 被构造成行随机（或次随机）的，其最大特征值模保证为 $1$（如果状态图非平凡且连通）。\n3.  **最大分数占据率 ($f_{\\max}$)**：这衡量了在占据率最高的微观态中花费的模拟时间比例。它通过找到具有最大分配帧数的微观态 $k$（$\\text{count}(k)$），然后除以总帧数 $T$ 来计算：\n    $$f_{\\max} = \\frac{\\max_{k \\in \\{0, \\dots, K-1\\}} \\text{count}(k)}{T}$$\n\n计算出的 $\\theta$ 和 $f_{\\max}$ 的值四舍五入到小数点后 $6$ 位。", "answer": "```python\nimport numpy as np\n\ndef generate_trajectory(T, t_up, t_down, R, a, M):\n    \"\"\"\n    Generates a deterministic synthetic trajectory based on the problem specification.\n\n    Args:\n        T (int): Total number of frames.\n        t_up (int): Start time of the upward ramp.\n        t_down (int): Start time of the downward ramp.\n        R (int): Duration of the ramps.\n        a (float): Amplitude of fast fluctuations.\n        M (int): Period of fast fluctuations.\n\n    Returns:\n        np.ndarray: The generated trajectory of shape (T, 3).\n    \"\"\"\n    t_vals = np.arange(T)\n    s = np.full(T, -1.0)\n\n    # Upward ramp and subsequent plateau\n    if t_up  T:\n        up_ramp_end = min(t_up + R, T)\n        ramp_indices = np.arange(t_up, up_ramp_end)\n        if len(ramp_indices) > 0:\n            s[ramp_indices] = -1.0 + 2.0 * (ramp_indices - t_up) / R\n        if up_ramp_end  T:\n            s[up_ramp_end:T] = 1.0\n\n    # Downward ramp and subsequent plateau (overwrites previous values)\n    if t_down  T:\n        down_ramp_end = min(t_down + R, T)\n        ramp_indices = np.arange(t_down, down_ramp_end)\n        if len(ramp_indices) > 0:\n            s[ramp_indices] = 1.0 - 2.0 * (ramp_indices - t_down) / R\n        if down_ramp_end  T:\n            s[down_ramp_end:T] = -1.0\n        \n    omega = 2 * np.pi / M\n    x1 = s + a * np.sin(omega * t_vals)\n    x2 = 0.5 * s + a * np.cos(omega * t_vals)\n    x3 = 0.25 * np.sin(2 * omega * t_vals)\n    \n    return np.stack([x1, x2, x3], axis=1)\n\ndef k_means(data, K, M_it):\n    \"\"\"\n    Performs k-means clustering with deterministic farthest-point initialization.\n\n    Args:\n        data (np.ndarray): The data to cluster, shape (n_samples, n_features).\n        K (int): The number of clusters.\n        M_it (int): The maximum number of iterations.\n\n    Returns:\n        np.ndarray: The final cluster labels for each data point.\n    \"\"\"\n    n_samples, n_features = data.shape\n    \n    if K == 1:\n        return np.zeros(n_samples, dtype=int)\n\n    # 1. Initialization: Farthest-point\n    centers = np.zeros((K, n_features))\n    norms_sq = np.sum(data**2, axis=1)\n    first_center_idx = np.argmin(norms_sq)\n    centers[0] = data[first_center_idx]\n    \n    min_dist_sq = np.full(n_samples, np.inf)\n    for i in range(1, K):\n        dist_sq_to_last_center = np.sum((data - centers[i-1])**2, axis=1)\n        min_dist_sq = np.minimum(min_dist_sq, dist_sq_to_last_center)\n        next_center_idx = np.argmax(min_dist_sq)\n        centers[i] = data[next_center_idx]\n\n    # 2. Lloyd's Algorithm\n    labels = -np.ones(n_samples, dtype=int)\n    for _ in range(M_it):\n        # Assignment step\n        dist_sq = np.sum((data[:, np.newaxis, :] - centers)**2, axis=2)\n        new_labels = np.argmin(dist_sq, axis=1)\n\n        # Convergence check\n        if np.array_equal(new_labels, labels):\n            break\n        labels = new_labels\n\n        # Update step\n        new_centers = np.zeros((K, n_features))\n        empty_clusters = []\n        for k in range(K):\n            points_in_cluster = data[labels == k]\n            if len(points_in_cluster) == 0:\n                empty_clusters.append(k)\n            else:\n                new_centers[k] = points_in_cluster.mean(axis=0)\n\n        # Empty cluster handling\n        if empty_clusters:\n            point_distances_sq = np.sum((data - centers[labels])**2, axis=1)\n            farthest_point_indices = np.argsort(point_distances_sq)[::-1]\n            \n            used_farthest_points = set()\n            farthest_idx_ptr = 0\n            for k in empty_clusters:\n                point_to_reseed_idx = farthest_point_indices[farthest_idx_ptr]\n                while point_to_reseed_idx in used_farthest_points:\n                    farthest_idx_ptr += 1\n                    point_to_reseed_idx = farthest_point_indices[farthest_idx_ptr]\n\n                new_centers[k] = data[point_to_reseed_idx]\n                used_farthest_points.add(point_to_reseed_idx)\n                \n        centers = new_centers\n        \n    return labels\n\ndef calculate_diagnostics(labels, K, T):\n    \"\"\"\n    Calculates network diagnostics E, theta, and f_max.\n\n    Args:\n        labels (np.ndarray): Time-ordered cluster labels.\n        K (int): Number of clusters.\n        T (int): Total number of frames.\n\n    Returns:\n        tuple: A tuple containing (E, theta, f_max).\n    \"\"\"\n    if K == 1:\n        return 1, 0.0, 1.0\n\n    N = np.zeros((K, K), dtype=int)\n    for i in range(T - 1):\n        N[labels[i], labels[i+1]] += 1\n\n    P = np.zeros((K, K))\n    row_sums = N.sum(axis=1)\n    non_zero_rows = row_sums > 0\n    P[non_zero_rows] = N[non_zero_rows] / row_sums[non_zero_rows, np.newaxis]\n\n    E = np.count_nonzero(P)\n\n    eigenvalues = np.linalg.eigvals(P)\n    eigenvalue_moduli = np.abs(eigenvalues)\n    eigenvalue_moduli.sort() \n    theta = eigenvalue_moduli[-2] if len(eigenvalue_moduli) >= 2 else 0.0\n\n    if T > 0:\n        occupancies = np.bincount(labels, minlength=K)\n        f_max = np.max(occupancies) / T\n    else:\n        f_max = 0.0\n        \n    return E, theta, f_max\n\ndef solve():\n    \"\"\"\n    Main function to run the full pipeline for all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        (300, 80, 200, 20, 0.05, 15, 2, 2),  # Case A\n        (180, 60, 140, 10, 0.02, 12, 2, 1),  # Case B\n        (250, 160, 1000, 20, 0.04, 20, 2, 2), # Case C\n    ]\n    M_it = 100\n\n    all_results = []\n    for params in test_cases:\n        T, t_up, t_down, R, a, M, q, K = params\n        \n        X = generate_trajectory(T, t_up, t_down, R, a, M)\n        \n        data_for_clustering = X[:, :q]\n        \n        mean = data_for_clustering.mean(axis=0)\n        std = data_for_clustering.std(axis=0)\n        std[std == 0] = 1.0\n        standardized_data = (data_for_clustering - mean) / std\n        \n        labels = k_means(standardized_data, K, M_it)\n        \n        E, theta, f_max = calculate_diagnostics(labels, K, T)\n        \n        result = [E, round(theta, 6), round(f_max, 6)]\n        all_results.append(result)\n\n    result_str = ','.join([str(r).replace(' ', '') for r in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3408877"}, {"introduction": "从有限数据中构建的模型通常会带有统计噪声，可能不完全满足系统的物理性质。对于处于平衡态的系统，细致平衡（detailed balance）或称可逆性（reversibility）是一个关键的物理约束。本练习 [@problem_id:3408814] 旨在教授如何检验所建模型是否满足此性质，并在必要时通过对称化计数来强制施加此约束，从而得到一个物理意义更明确、分析上更可靠的网络模型。", "problem": "您将获得一个使用马尔可夫状态模型 (MSM) 分析分子动力学中构象转变的框架。在 MSM 中，离散时间马尔可夫链表示亚稳态之间的转变。令 $T$ 表示一个行随机转移概率矩阵，其条目 $T_{ij} \\ge 0$ 且对于所有状态 $i$ 都有 $\\sum_{j} T_{ij} = 1$。链的平稳分布 $\\pi$ 满足左特征向量关系 $\\pi^{\\top} T = \\pi^{\\top}$，并带有归一化条件 $\\sum_{i} \\pi_{i} = 1$。可逆马尔可夫链遵循细致平衡：对于所有 $i,j$，$\\pi_{i} T_{ij} = \\pi_{j} T_{ji}$。在实践中，我们从轨迹数据中估计一个计数矩阵 $C$，其条目 $C_{ij}$ 记录了在选定的延迟时间内从状态 $i$ 到状态 $j$ 的观测到的转变次数。由于有限采样，可能会出现经验上的不可逆性；一种常见的补救方法是通过对称化计数来强制实现可逆性，即 $C^{\\mathrm{sym}}_{ij} = C_{ij} + C_{ji}$，然后通过行归一化构建一个可逆转移矩阵。为减轻零计数伪影，通常建议在归一化之前向所有条目添加一个对称的伪计数 $\\alpha  0$。\n\n从基本基础开始：\n\n- 离散时间马尔可夫链定义：$T$ 是行随机的，$\\sum_{j} T_{ij} = 1$，且 $T_{ij} \\ge 0$。\n- 平稳分布定义：$\\pi^{\\top} T = \\pi^{\\top}$ 且 $\\sum_{i} \\pi_{i} = 1$。\n- 细致平衡（可逆性）条件：对于所有 $i,j$，$\\pi_{i} T_{ij} = \\pi_{j} T_{ji}$。\n- 经验计数矩阵构建：$C_{ij}$ 是从 $i$ 到 $j$ 的观测转变计数。\n- 通过对称计数的可逆估计量：$C^{\\mathrm{sym}}_{ij} = C_{ij} + C_{ji}$，可选地带有伪计数 $\\alpha$，且 $T^{\\mathrm{rev}}_{ij} = \\frac{C^{\\mathrm{sym}}_{ij} + \\alpha}{\\sum_{k} \\left(C^{\\mathrm{sym}}_{ik} + \\alpha \\right)}$。\n\n您的任务是编写一个程序，对每个测试用例执行以下步骤：\n\n1. 给定一个估计的转移矩阵 $T$，通过求解由 $\\pi^{\\top} T = \\pi^{\\top}$ 和 $\\sum_{i} \\pi_{i} = 1$ 所蕴含的线性方程组，计算平稳分布 $\\pi$ 作为具有特征值 $1$ 的归一化左特征向量。\n2. 通过计算最大绝对通量不对称性来量化细致平衡的违反程度\n   $$d = \\max_{i,j} \\left| \\pi_{i} T_{ij} - \\pi_{j} T_{ji} \\right|.$$\n3. 通过检查 $d \\le \\tau$ 来判断细致平衡是否在容差 $\\tau$ 内成立。\n4. 如果违反了细致平衡，则通过对称化计数 $C$ 并向所有条目添加对称伪计数 $\\alpha$ 来构建一个可逆估计 $T^{\\mathrm{rev}}$，然后进行行归一化。计算 $T^{\\mathrm{rev}}$ 的平稳分布 $\\pi^{\\mathrm{rev}}$，并重新计算不对称性 $d^{\\mathrm{rev}}$ 以及在相同容差 $\\tau$ 下的细致平衡布尔检查。\n5. 如果未违反细致平衡，则设置 $\\pi^{\\mathrm{rev}} = \\pi$，$d^{\\mathrm{rev}} = d$，并将对称化后的细致平衡布尔值设为与对称化前检查相同。\n\n所有答案都是无单位的概率和计数；不涉及物理单位。角度不适用。任何地方都不得使用百分比；概率必须表示为 $[0,1]$ 范围内的十进制数。\n\n测试套件：\n\n使用以下三个测试用例，每个用例由一个元组 $(T, C, \\alpha)$ 指定：\n\n- 案例1 (可逆基准):\n  $$\n  T^{(1)} = \\begin{pmatrix}\n  0  \\frac{2}{3}  \\frac{1}{3} \\\\\n  \\frac{2}{3}  0  \\frac{1}{3} \\\\\n  \\frac{1}{2}  \\frac{1}{2}  0\n  \\end{pmatrix}, \\quad\n  C^{(1)} = \\begin{pmatrix}\n  0  2  1 \\\\\n  3  0  1 \\\\\n  1  0  0\n  \\end{pmatrix}, \\quad\n  \\alpha^{(1)} = 0.\n  $$\n- 案例2 (由于不对称计数和转移导致的不可逆):\n  $$\n  T^{(2)} = \\begin{pmatrix}\n  0  0.9  0.1 \\\\\n  0.3  0  0.7 \\\\\n  0.2  0.8  0\n  \\end{pmatrix}, \\quad\n  C^{(2)} = \\begin{pmatrix}\n  0  90  10 \\\\\n  30  0  70 \\\\\n  20  80  0\n  \\end{pmatrix}, \\quad\n  \\alpha^{(2)} = 0.\n  $$\n- 案例3 (零计数边缘案例；伪计数正则化):\n  $$\n  T^{(3)} = \\begin{pmatrix}\n  0  1  0 \\\\\n  0  1  0 \\\\\n  0  1  0\n  \\end{pmatrix}, \\quad\n  C^{(3)} = \\begin{pmatrix}\n  0  0  0 \\\\\n  0  0  0 \\\\\n  0  0  0\n  \\end{pmatrix}, \\quad\n  \\alpha^{(3)} = 1.\n  $$\n\n使用容差 $\\tau = 10^{-12}$ 进行细致平衡检查。\n\n输出规范：\n\n对于每个测试用例，您的程序必须按以下顺序输出一个包含六个元素的列表：\n- 对称化前的平稳分布，以浮点数列表形式表示，每个数四舍五入到 $6$ 位小数，按状态 $[1,2,3]$ 的顺序。\n- 一个布尔值，指示对称化前是否使用容差 $\\tau$ 满足细致平衡。\n- 对称化前的浮点数 $d$。\n- 对称化后的平稳分布，以浮点数列表形式表示，每个数四舍五入到 $6$ 位小数。\n- 一个布尔值，指示对称化后是否使用容差 $\\tau$ 满足细致平衡。\n- 对称化后的浮点数 $d^{\\mathrm{rev}}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result_case_1,result_case_2,result_case_3]”），其中每个 result_case_k 都遵循指定的六元素列表格式。", "solution": "用户提供了一个问题，要求实现一个用于分子动力学中马尔可夫状态模型 (MSM) 的分析流程。我将首先验证问题陈述，然后提供详细的解决方案。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n\n-   **模型：** 用于构象转变的离散时间马尔可夫链。\n-   **转移矩阵 $T$：** 行随机 ($T_{ij} \\ge 0$, $\\sum_{j} T_{ij} = 1$)。\n-   **平稳分布 $\\pi$：** 由 $\\pi^{\\top} T = \\pi^{\\top}$ 和 $\\sum_{i} \\pi_{i} = 1$ 定义。\n-   **细致平衡（可逆性）：** 对于所有 $i,j$，$\\pi_{i} T_{ij} = \\pi_{j} T_{ji}$。\n-   **计数矩阵 $C$：** $C_{ij}$ 是从状态 $i$ 到 $j$ 的观测转变次数。\n-   **可逆估计量 $T^{\\mathrm{rev}}$：** 从对称化的计数矩阵构建，可选择添加伪计数 $\\alpha$：$T^{\\mathrm{rev}}_{ij} = \\frac{C_{ij} + C_{ji} + \\alpha}{\\sum_{k} (C_{ik} + C_{ki} + \\alpha)}$。\n-   **任务步骤：**\n    1.  对于给定的 $T$，计算其平稳分布 $\\pi$。\n    2.  计算最大绝对通量不对称性 $d = \\max_{i,j} \\left| \\pi_{i} T_{ij} - \\pi_{j} T_{ji} \\right|$。\n    3.  检查是否满足细致平衡：$d \\le \\tau$。\n    4.  如果违反，使用给定的 $C$ 和 $\\alpha$ 构建 $T^{\\mathrm{rev}}$，然后重新计算其平稳分布 $\\pi^{\\mathrm{rev}}$ 和不对称性 $d^{\\mathrm{rev}}$。\n    5.  如果不违反，将初始结果 ($\\pi, d$) 复制为“对称化后”的结果。\n-   **容差：** $\\tau = 10^{-12}$。\n-   **测试用例：** 提供了三个用例，每个用例都包含一个转移矩阵 $T$、一个计数矩阵 $C$ 和一个伪计数 $\\alpha$。\n    -   案例 1: $T^{(1)} = \\begin{pmatrix} 0  \\frac{2}{3}  \\frac{1}{3} \\\\ \\frac{2}{3}  0  \\frac{1}{3} \\\\ \\frac{1}{2}  \\frac{1}{2}  0 \\end{pmatrix}$, $C^{(1)} = \\begin{pmatrix} 0  2  1 \\\\ 3  0  1 \\\\ 1  0  0 \\end{pmatrix}$, $\\alpha^{(1)} = 0$。\n    -   案例 2: $T^{(2)} = \\begin{pmatrix} 0  0.9  0.1 \\\\ 0.3  0  0.7 \\\\ 0.2  0.8  0 \\end{pmatrix}$, $C^{(2)} = \\begin{pmatrix} 0  90  10 \\\\ 30  0  70 \\\\ 20  80  0 \\end{pmatrix}$, $\\alpha^{(2)} = 0$。\n    -   案例 3: $T^{(3)} = \\begin{pmatrix} 0  1  0 \\\\ 0  1  0 \\\\ 0  1  0 \\end{pmatrix}$, $C^{(3)} = \\begin{pmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}$, $\\alpha^{(3)} = 1$。\n-   **输出：** 一个单行字符串，表示一个列表的列表。每个内部列表为一个测试用例包含6个项目：$[\\pi_{\\text{before}}, \\text{db}_{\\text{before}}, d_{\\text{before}}, \\pi_{\\text{after}}, \\text{db}_{\\text{after}}, d_{\\text{after}}]$。\n\n**步骤2：使用提取的给定信息进行验证**\n\n-   **科学依据：** 该问题坚实地基于已建立的马尔可夫链数学理论及其在马尔可夫状态模型中的应用，这是计算化学和生物物理学中的标准方法。所有定义和过程都是标准且正确的。\n-   **适定性：** 问题是适定的。任务是实现一个确定性算法。对于有限状态马尔可夫链，计算平稳分布是一个定义明确的线性代数问题。对于通常建模的系统类型（不可约、非周期链），平稳分布的存在性和唯一性是有保证的，并且所提供的矩阵虽然有些是可约的，但可以通过指定的线性代数方法正确处理。\n-   **客观性：** 问题陈述是精确的、定量的，并且没有歧义或主观性。所有术语都有数学定义。\n-   **一致性：** 问题是内部一致的。转移矩阵 $T$ 和计数矩阵 $C$ 作为分析“之前”和“之后”阶段的独立输入提供。这是一个现实的场景，其中人们可能从一个初始的、可能不可逆的 $T$ 估计开始，然后使用底层的原始计数 $C$ 来产生一个修正的、可逆的估计。因此，在测试用例中 $T$ 并不总是可以从 $C$ 推导出来，这并非矛盾。\n\n**步骤3：结论与行动**\n\n该问题在科学上是合理的、适定的、客观的且内部一致。这是一个有效的问题。我将继续提供解决方案。\n\n### 算法解决方案\n\n该解决方案将系统地为每个测试用例实现问题描述中概述的步骤。\n\n**1. 平稳分布的计算 ($\\pi$)**\n\n平稳分布 $\\pi$ 是转移矩阵 $T$ 对应于特征值 $\\lambda=1$ 的归一化左特征向量。它满足两个条件：\n$$ \\pi^{\\top} T = \\pi^{\\top} \\quad \\text{和} \\quad \\sum_{i=1}^{N} \\pi_i = 1 $$\n其中 $N$ 是状态数。第一个条件可以改写为一个齐次线性方程组：\n$$ \\pi^{\\top} (T - I) = \\mathbf{0}^{\\top} $$\n其中 $I$ 是单位矩阵，$\\mathbf{0}$ 是零向量。转置该方程得到：\n$$ (T^{\\top} - I) \\pi = \\mathbf{0} $$\n该系统有非平凡解，因为 $\\lambda=1$ 是 $T$ 的一个特征值，这意味着 $\\det(T^{\\top} - I) = 0$。为了找到代表概率分布的唯一解 $\\pi$，我们必须引入归一化约束 $\\sum_{i} \\pi_i = 1$。我们可以通过用归一化方程替换系统中的一个（线性相关的）方程来实现这一点。对于一个 $N \\times N$ 的系统，我们构建一个新矩阵 $A'$，它取 $(T^{\\top} - I)$ 的前 $N-1$ 行，并将最后一行设置为全1。我们还构建一个新的向量 $b'$，其前 $N-1$ 个元素为零，最后一个元素为1。唯一的平稳分布 $\\pi$ 便是非奇异系统 $A' \\pi = b'$ 的解。\n该系统可以使用标准的线性代数求解器来解决。\n\n**2. 细致平衡违反分析**\n\n有了平稳分布 $\\pi$ 和转移矩阵 $T$，我们量化细致平衡的违反程度。细致平衡条件 $\\pi_i T_{ij} = \\pi_j T_{ji}$ 指出，在平衡状态下，从状态 $i$ 到 $j$ 的概率通量必须等于从 $j$ 到 $i$ 的通量。任意两个状态之间的净通量或通量不对称性为 $F_{ij} = \\pi_i T_{ij} - \\pi_j T_{ji}$。我们计算所有状态对上的最大绝对通量不对称性：\n$$ d = \\max_{i,j} | \\pi_i T_{ij} - \\pi_j T_{ji} | $$\n这个值 $d$ 作为非可逆程度的度量。如果此偏差在给定的数值容差内，即 $d \\le \\tau$，则认为系统满足细致平衡。\n\n**3. 可逆估计量的构建 ($T^{\\mathrm{rev}}$)**\n\n如果发现初始矩阵 $T$ 违反了细致平衡 ($d  \\tau$)，则基于原始转移计数 $C$ 和伪计数 $\\alpha$ 构建一个新的、可逆的转移矩阵 $T^{\\mathrm{rev}}$。\n首先，对计数矩阵进行对称化，以消除有限采样带来的方向性偏差：\n$$ C^{\\mathrm{sym}}_{ij} = C_{ij} + C_{ji} $$\n这确保了任意一对状态 $(i,j)$ 之间的总观测转移次数在两个方向上是相同的。为了处理零计数的情况（这可能导致零概率和状态断开），将一个小的正伪计数 $\\alpha$ 添加到每个条目中：\n$$ C'_{ij} = C^{\\mathrm{sym}}_{ij} + \\alpha $$\n然后，通过对这个调整后的计数矩阵进行行归一化，得到可逆转移矩阵 $T^{\\mathrm{rev}}$：\n$$ T^{\\mathrm{rev}}_{ij} = \\frac{C'_{ij}}{\\sum_k C'_{ik}} $$\n根据构造，这个矩阵 $T^{\\mathrm{rev}}$ 保证满足关于一个平稳分布 $\\pi^{\\mathrm{rev}}$ 的细致平衡条件，该分布的分量与 $C'$ 的行和成比例（即 $\\pi^{\\mathrm{rev}}_i \\propto \\sum_k C'_{ik}$）。构建 $T^{\\mathrm{rev}}$ 后，使用步骤1和2中描述的相同方法计算其平稳分布 $\\pi^{\\mathrm{rev}}$ 和不对称性 $d^{\\mathrm{rev}}$。由于其构造方式，$d^{\\mathrm{rev}}$ 预期为零（或由于浮点精度而为一个非常小的数）。\n\n如果初始矩阵 $T$ 已经满足细致平衡 ($d \\le \\tau$)，则跳过整个构建过程。“之后”的结果（$\\pi^{\\mathrm{rev}}$, $d^{\\mathrm{rev}}$）简单地设置为与“之前”的结果（$\\pi, d$）相同。此逻辑将应用于每个测试用例以生成所需的输出。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve as solve_linear_system\n\ndef analyze_msm(T, C, alpha, tau):\n    \"\"\"\n    Performs MSM analysis for a given test case.\n    \n    Args:\n        T (np.ndarray): The initial transition probability matrix.\n        C (np.ndarray): The transition count matrix.\n        alpha (float): The pseudocount value.\n        tau (float): The tolerance for detailed balance check.\n        \n    Returns:\n        list: A 6-element list containing the results.\n    \"\"\"\n    \n    # 1. Compute stationary distribution for the initial matrix T\n    def compute_stationary_dist(T_matrix):\n        \"\"\"Computes the stationary distribution of a transition matrix.\"\"\"\n        n_states = T_matrix.shape[0]\n        # System is (T.T - I) * pi = 0\n        A = T_matrix.T - np.identity(n_states)\n        # Replace last row with normalization constraint sum(pi) = 1\n        A[-1, :] = 1.0\n        b = np.zeros(n_states)\n        b[-1] = 1.0\n        pi = solve_linear_system(A, b, assume_a='gen')\n        # Ensure positivity and re-normalize due to potential floating point errors\n        pi[pi  0] = 0\n        return pi / np.sum(pi)\n\n    pi = compute_stationary_dist(T)\n    \n    # 2. Quantify detailed balance violation\n    flux_matrix = np.outer(pi, np.ones_like(pi)) * T - (np.outer(pi, np.ones_like(pi)) * T).T\n    d = np.max(np.abs(flux_matrix))\n    \n    # 3. Decide if detailed balance holds\n    is_db = d = tau\n    \n    pi_rounded = [round(p, 6) for p in pi]\n    \n    # 4. If detailed balance is violated, construct reversible estimate\n    if not is_db:\n        # Symmetrize counts\n        C_sym = C + C.T\n        # Add pseudocount\n        C_prime = C_sym + alpha\n        # Row-normalize to get T_rev\n        row_sums = C_prime.sum(axis=1)\n        # Handle case where a row sum could be zero if alpha=0 and counts are all zero for a row\n        if np.any(row_sums == 0):\n             # This case shouldn't happen with the test data, but is a safeguard.\n             # A row of zeros means it's an absorbing state with no way out.\n             # Cannot form a valid stochastic matrix. Let's make it uniform to avoid crash.\n             n_s = C_prime.shape[0]\n             T_rev = np.full((n_s, n_s), 1.0/n_s)\n        else:\n             T_rev = C_prime / row_sums[:, np.newaxis]\n        \n        # Compute stationary distribution and asymmetry for T_rev\n        pi_rev = compute_stationary_dist(T_rev)\n        flux_matrix_rev = np.outer(pi_rev, np.ones_like(pi_rev)) * T_rev - (np.outer(pi_rev, np.ones_like(pi_rev)) * T_rev).T\n        d_rev = np.max(np.abs(flux_matrix_rev))\n        is_db_rev = d_rev = tau\n        pi_rev_rounded = [round(p, 6) for p in pi_rev]\n    else:\n        # 5. If detailed balance holds, copy results\n        pi_rev_rounded = pi_rounded\n        d_rev = d\n        is_db_rev = is_db\n        \n    return [pi_rounded, is_db, d, pi_rev_rounded, is_db_rev, d_rev]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (\n            np.array([[0, 2/3, 1/3], [2/3, 0, 1/3], [1/2, 1/2, 0]]),\n            np.array([[0, 2, 1], [3, 0, 1], [1, 0, 0]]),\n            0.0\n        ),\n        (\n            np.array([[0, 0.9, 0.1], [0.3, 0, 0.7], [0.2, 0.8, 0]]),\n            np.array([[0, 90, 10], [30, 0, 70], [20, 80, 0]]),\n            0.0\n        ),\n        (\n            np.array([[0, 1, 0], [0, 1, 0], [0, 1, 0]]),\n            np.array([[0, 0, 0], [0, 0, 0], [0, 0, 0]]),\n            1.0\n        )\n    ]\n    \n    tau = 1e-12\n    \n    results = []\n    for T, C, alpha in test_cases:\n        result_case = analyze_msm(T, C, alpha, tau)\n        results.append(result_case)\n\n    # The required output is a single line string representing a list of lists.\n    # The template 'f\"[{','.join(map(str, results))}]\"' correctly formats this.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3408814"}, {"introduction": "拥有一个有效的网络模型后，我们便可以计算重要的动力学性质。平均首达时间（Mean First-Passage Time, MFPT）是理解构象转变时间尺度的关键指标。本练习 [@problem_id:3408868] 侧重于如何利用与离散时间模型密切相关的连续时间马尔可夫过程的生成元（generator），来高效地计算这一关键动力学量。", "problem": "一个在有限节点集上的连续时间马尔可夫链 (CTMC) 为动态网络建模，这些网络近似于分子动力学中亚稳态之间的构象转变。设 $T(\\tau)$ 是在延迟时间 $\\tau0$ 时的行随机短延迟转移概率矩阵，设 $K$ 是无穷小生成元。Kolmogorov 前向方程意味着 $\\frac{d}{dt}T(t)\\big|_{t=0}=K$，这导出对于小 $\\tau$ 的一阶近似 $T(\\tau)\\approx I+\\tau K$。给定一个节点的吸收边界集 $B$ 及其补集 $\\bar{B}$，从节点 $i\\in \\bar{B}$ 开始到 $B$ 的平均首达时间 (MFPT) $m_i$ 求解线性系统 $K_{\\bar{B}\\bar{B}}\\,m=-\\mathbf{1}$，边界条件为对于 $j\\in B$ 有 $m_j=0$，其中 $\\mathbf{1}$ 是维度为 $|\\bar{B}|$ 的全一向量。您的任务是为给定的矩阵 $T(\\tau)$、吸收集 $B$ 和起始节点 $s$ 的测试套件实现以下过程：\n1. 使用 $K\\approx (T(\\tau)-I)/\\tau$ 估计生成元。\n2. 通过限制到非吸收索引 $\\bar{B}$ 来构成子矩阵 $K_{\\bar{B}\\bar{B}}$。\n3. 如果起始节点 $s\\in B$，则定义 MFPT 为 $0$。否则，求解 $K_{\\bar{B}\\bar{B}}\\,m=-\\mathbf{1}$ 并报告 $m_s$（对应于起始节点 $s$ 的分量）。\n所有索引都是从零开始的。不需要物理单位。返回的 MFPT 必须是四舍五入到六位小数的实数。\n\n测试套件：\n- 案例 1：\n  - $T^{(1)}=\\begin{bmatrix} 0.88  0.12  0 \\\\ 0.07  0.85  0.08 \\\\ 0  0.06  0.94 \\end{bmatrix}$，\n  - $\\tau^{(1)}=0.1$，\n  - $B^{(1)}=\\{2\\}$，\n  - $s^{(1)}=0$。\n- 案例 2：\n  - $T^{(2)}=\\begin{bmatrix} 0.935  0.045  0.02  0 \\\\ 0.025  0.935  0.03  0.01 \\\\ 0  0.015  0.935  0.05 \\\\ 0  0  0  1 \\end{bmatrix}$，\n  - $\\tau^{(2)}=0.05$，\n  - $B^{(2)}=\\{2,3\\}$，\n  - $s^{(2)}=0$。\n- 案例 3：\n  - $T^{(3)}=\\begin{bmatrix} 0.9975  0.0025 \\\\ 0.0015  0.9985 \\end{bmatrix}$，\n  - $\\tau^{(3)}=0.001$，\n  - $B^{(3)}=\\{1\\}$，\n  - $s^{(3)}=0$。\n- 案例 4：\n  - $T^{(4)}=\\begin{bmatrix} 0.9  0.04  0.06 \\\\ 0.02  0.9  0.08 \\\\ 0.04  0.04  0.92 \\end{bmatrix}$，\n  - $\\tau^{(4)}=0.2$，\n  - $B^{(4)}=\\{0\\}$，\n  - $s^{(4)}=0$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_k$ 是案例 $k$ 的 MFPT，四舍五入到六位小数。", "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上基于连续时间马尔可夫链理论，问题定义良好，具有清晰的算法步骤，并以客观、正式的语言表述。所有必要的数据均已提供且内部一致。\n\n任务是为几个给定场景计算到达一组吸收态的平均首达时间 (MFPT)。通用方法直接源于吸收马尔可夫链理论。设状态空间被划分为一个瞬态集 $\\bar{B}$ 和一个吸收态集 $B$。连续时间马尔可夫链的无穷小生成元表示为 $K$。与瞬态对应的 $K$ 的子矩阵是 $K_{\\bar{B}\\bar{B}}$。MFPT 向量 $m$（其中每个分量 $m_i$ 是从瞬态 $i \\in \\bar{B}$ 开始的 MFPT）通过求解以下线性系统找到：\n$$K_{\\bar{B}\\bar{B}}\\,m = -\\mathbf{1}$$\n其中 $\\mathbf{1}$ 是一个维数适宜的全一列向量。根据定义，从一个已在吸收集 $B$ 中的状态出发的 MFPT 为 $0$。\n\n生成元 $K$ 不是直接给出的，而是使用从矩阵指数关系 $T(\\tau) = e^{\\tau K} \\approx I + \\tau K$ 导出的一阶近似，从短延迟转移概率矩阵 $T(\\tau)$ 估计得出。这产生了以下近似：\n$$K \\approx \\frac{T(\\tau) - I}{\\tau}$$\n其中 $I$ 是单位矩阵，$\\tau$ 是延迟时间。\n\n我们现在将此过程应用于每个测试案例。\n\n案例 1：\n给定：\n- 转移矩阵 $T^{(1)} = \\begin{bmatrix} 0.88  0.12  0 \\\\ 0.07  0.85  0.08 \\\\ 0  0.06  0.94 \\end{bmatrix}$\n- 延迟时间 $\\tau^{(1)} = 0.1$\n- 吸收集 $B^{(1)} = \\{2\\}$\n- 起始节点 $s^{(1)} = 0$\n\n起始节点 $s^{(1)}=0$ 不在吸收集 $B^{(1)}$ 中。非吸收（瞬态）态的集合是 $\\bar{B}^{(1)} = \\{0, 1\\}$。\n首先，我们估计生成元矩阵 $K^{(1)}$：\n$$K^{(1)} \\approx \\frac{1}{0.1} \\left( \\begin{bmatrix} 0.88  0.12  0 \\\\ 0.07  0.85  0.08 \\\\ 0  0.06  0.94 \\end{bmatrix} - \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix} \\right) = \\begin{bmatrix} -1.2  1.2  0 \\\\ 0.7  -1.5  0.8 \\\\ 0  0.6  -0.6 \\end{bmatrix}$$\n接下来，我们通过选择对应于瞬态 $\\{0, 1\\}$ 的行和列来构成子矩阵 $K^{(1)}_{\\bar{B}\\bar{B}}$：\n$$K^{(1)}_{\\bar{B}\\bar{B}} = \\begin{bmatrix} -1.2  1.2 \\\\ 0.7  -1.5 \\end{bmatrix}$$\n我们求解线性系统 $K^{(1)}_{\\bar{B}\\bar{B}} m = -\\mathbf{1}$ 以得到 MFPT 向量 $m = \\begin{pmatrix} m_0 \\\\ m_1 \\end{pmatrix}$：\n$$\\begin{bmatrix} -1.2  1.2 \\\\ 0.7  -1.5 \\end{bmatrix} \\begin{pmatrix} m_0 \\\\ m_1 \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix}$$\n求解该系统得到 $m_0 = 2.8125$ 和 $m_1 \\approx 1.979167$。所需的值是从起始节点 $s^{(1)}=0$ 出发的 MFPT，即 $m_0$。\n案例 1 的结果：$2.8125$。\n\n案例 2：\n给定：\n- 转移矩阵 $T^{(2)} = \\begin{bmatrix} 0.935  0.045  0.02  0 \\\\ 0.025  0.935  0.03  0.01 \\\\ 0  0.015  0.935  0.05 \\\\ 0  0  0  1 \\end{bmatrix}$\n- 延迟时间 $\\tau^{(2)} = 0.05$\n- 吸收集 $B^{(2)} = \\{2, 3\\}$\n- 起始节点 $s^{(2)} = 0$\n\n起始节点 $s^{(2)}=0$ 不在 $B^{(2)}$ 中。瞬态集为 $\\bar{B}^{(2)} = \\{0, 1\\}$。\n生成元矩阵 $K^{(2)}$ 估计为：\n$$K^{(2)} \\approx \\frac{1}{0.05} \\left( T^{(2)} - I \\right) = 20 \\begin{bmatrix} -0.065  0.045  0.02  0 \\\\ 0.025  -0.065  0.03  0.01 \\\\ 0  0.015  -0.065  0.05 \\\\ 0  0  0  0 \\end{bmatrix} = \\begin{bmatrix} -1.3  0.9  0.4  0 \\\\ 0.5  -1.3  0.6  0.2 \\\\ 0  0.3  -1.3  1.0 \\\\ 0  0  0  0 \\end{bmatrix}$$\n瞬态 $\\{0, 1\\}$ 的子矩阵是：\n$$K^{(2)}_{\\bar{B}\\bar{B}} = \\begin{bmatrix} -1.3  0.9 \\\\ 0.5  -1.3 \\end{bmatrix}$$\n我们求解系统 $K^{(2)}_{\\bar{B}\\bar{B}} m = -\\mathbf{1}$：\n$$\\begin{bmatrix} -1.3  0.9 \\\\ 0.5  -1.3 \\end{bmatrix} \\begin{pmatrix} m_0 \\\\ m_1 \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix}$$\n解为 $m_0 \\approx 1.774194$ 和 $m_1 \\approx 1.451613$。所需的 MFPT 是对于起始节点 $s^{(2)}=0$ 的值，即 $m_0$。\n案例 2 的结果：$1.774194$。\n\n案例 3：\n给定：\n- 转移矩阵 $T^{(3)} = \\begin{bmatrix} 0.9975  0.0025 \\\\ 0.0015  0.9985 \\end{bmatrix}$\n- 延迟时间 $\\tau^{(3)} = 0.001$\n- 吸收集 $B^{(3)} = \\{1\\}$\n- 起始节点 $s^{(3)} = 0$\n\n起始节点 $s^{(3)}=0$ 不在 $B^{(3)}$ 中。瞬态集为 $\\bar{B}^{(3)} = \\{0\\}$。\n生成元矩阵 $K^{(3)}$ 估计为：\n$$K^{(3)} \\approx \\frac{1}{0.001} \\left( T^{(3)} - I \\right) = 1000 \\begin{bmatrix} -0.0025  0.0025 \\\\ 0.0015  -0.0015 \\end{bmatrix} = \\begin{bmatrix} -2.5  2.5 \\\\ 1.5  -1.5 \\end{bmatrix}$$\n瞬态 $\\{0\\}$ 的子矩阵是一个 $1 \\times 1$ 矩阵：\n$$K^{(3)}_{\\bar{B}\\bar{B}} = \\begin{bmatrix} -2.5 \\end{bmatrix}$$\n线性系统是一个简单的标量方程：\n$$[-2.5] [m_0] = [-1]$$\n解出 $m_0$ 得到 $m_0 = \\frac{-1}{-2.5} = 0.4$。\n案例 3 的结果：$0.4$。\n\n案例 4：\n给定：\n- 转移矩阵 $T^{(4)} = \\begin{bmatrix} 0.9  0.04  0.06 \\\\ 0.02  0.9  0.08 \\\\ 0.04  0.04  0.92 \\end{bmatrix}$\n- 延迟时间 $\\tau^{(4)} = 0.2$\n- 吸收集 $B^{(4)} = \\{0\\}$\n- 起始节点 $s^{(4)} = 0$\n\n在这种情况下，起始节点 $s^{(4)}=0$ 是吸收集 $B^{(4)}$ 的一个元素。根据问题定义，从一个已在集合中的节点到该集合的 MFPT 是 $0$。无需计算。\n案例 4 的结果：$0.0$。\n\n结果总结，四舍五入到六位小数：\n- 案例 1：$2.812500$\n- 案例 2：$1.774194$\n- 案例 3：$0.400000$\n- 案例 4：$0.000000$\n这些将被格式化为所需的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the Mean First-Passage Time (MFPT) for a series of test cases\n    based on continuous-time Markov chain theory.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"T\": np.array([\n                [0.88, 0.12, 0.00],\n                [0.07, 0.85, 0.08],\n                [0.00, 0.06, 0.94]\n            ]),\n            \"tau\": 0.1,\n            \"B\": {2},\n            \"s\": 0\n        },\n        {\n            \"T\": np.array([\n                [0.935, 0.045, 0.020, 0.000],\n                [0.025, 0.935, 0.030, 0.010],\n                [0.000, 0.015, 0.935, 0.050],\n                [0.000, 0.000, 0.000, 1.000]\n            ]),\n            \"tau\": 0.05,\n            \"B\": {2, 3},\n            \"s\": 0\n        },\n        {\n            \"T\": np.array([\n                [0.9975, 0.0025],\n                [0.0015, 0.9985]\n            ]),\n            \"tau\": 0.001,\n            \"B\": {1},\n            \"s\": 0\n        },\n        {\n            \"T\": np.array([\n                [0.90, 0.04, 0.06],\n                [0.02, 0.90, 0.08],\n                [0.04, 0.04, 0.92]\n            ]),\n            \"tau\": 0.2,\n            \"B\": {0},\n            \"s\": 0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        T = case[\"T\"]\n        tau = case[\"tau\"]\n        B = case[\"B\"]\n        s = case[\"s\"]\n        \n        # If the starting node is in the absorbing set, MFPT is 0 by definition.\n        if s in B:\n            results.append(0.0)\n            continue\n            \n        num_states = T.shape[0]\n        \n        # Step 1: Estimate the generator matrix K\n        I = np.identity(num_states)\n        K = (T - I) / tau\n        \n        # Step 2: Form the submatrix K_BB_bar\n        # Identify non-absorbing (transient) states\n        transient_indices = [i for i in range(num_states) if i not in B]\n        \n        # Use np.ix_ to perform advanced indexing to get the submatrix\n        K_sub = K[np.ix_(transient_indices, transient_indices)]\n        \n        # Step 3: Solve the linear system K_sub * m = -1\n        # The right-hand side is a vector of -1s\n        rhs = np.full(len(transient_indices), -1.0)\n        \n        # Solve for the vector of MFPTs for transient states\n        m_vec = np.linalg.solve(K_sub, rhs)\n        \n        # Find the MFPT for the specific starting node s\n        # This requires finding the index of s within the list of transient states\n        try:\n            start_node_index_in_m = transient_indices.index(s)\n            mfpt = m_vec[start_node_index_in_m]\n            results.append(mfpt)\n        except ValueError:\n            # This case should not be reached if s is not in B\n            # as s must be in transient_indices.\n            # However, it is good practice to handle it.\n            # We can't determine MFPT if starting node is not in the system.\n            # We treat this as an anomaly, though the problem spec avoids this.\n            results.append(np.nan)\n\n\n    # Format the final output string with results rounded to six decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3408868"}]}