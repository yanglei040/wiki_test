{"hands_on_practices": [{"introduction": "在基于结构的粗粒化建模中，一个核心任务是迭代地改进势函数，以匹配一个目标结构性质，例如径向分布函数 (RDF)。迭代玻尔兹曼反转 (Iterative Boltzmann Inversion, IBI) 是一种强大的启发式方法，用于推导有效的对势。本练习将引导你完成 IBI 算法中的一个关键更新步骤，从而将抽象的算法具体化，并展示模拟结构 $g_n(r)$、目标结构 $g^{\\mathrm{target}}(r)$ 与势能函数 $U(r)$ 之间的直接联系 [@problem_id:3402194]。", "problem": "考虑一个Lennard–Jones流体的单点粗粒化映射，其中每个分子由单个相互作用位点表示。该体系在正则系综中进行模拟，温度 $T = 300\\,\\mathrm{K}$，数密度 $\\rho = 0.80\\,\\mathrm{nm}^{-3}$。您希望使用迭代玻尔兹曼反演（Iterative Boltzmann Inversion, IBI）方法来优化粗粒化对势 $U(r)$。此处IBI定义为一个迭代调整 $U(r)$ 的过程，使得粗粒化径向分布函数（radial distribution function, RDF），记作 $g(r)$，与一个目标RDF $g^{\\mathrm{target}}(r)$ 相匹配，该目标RDF是通过映射全原子参考轨迹得到的。\n\n在第 $n$ 次IBI迭代中，在间距 $r^{\\ast} = 0.80\\,\\mathrm{nm}$ 处测得的粗粒化RDF为 $g_{n}(r^{\\ast}) = 1.20$，而该间距处的目标RDF为 $g^{\\mathrm{target}}(r^{\\ast}) = 0.85$。该间距处当前的对势为 $U_{n}(r^{\\ast}) = 2.50\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。请仅使用正则系综的基本关系式以及平均力势 $w(r)$ 根据RDF的定义，推导在单个间距 $r^{\\ast}$ 处的IBI更新规则，并数值计算新的势能值 $U_{n+1}(r^{\\ast})$。假设更新基于将粗粒化对势的变化替换为平均力势的变化， $w(r)$ 中的任何加性常数均与更新无关，并且能量以摩尔为单位处理，因此玻尔兹曼常数 $k_{B}$ 被摩尔气体常数 $R = 8.314462618 \\times 10^{-3}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$ 替代。\n\n以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 为单位表示最终能量，并将您的答案四舍五入到四位有效数字。", "solution": "首先根据指定标准对问题进行验证。\n\n### 问题验证\n\n**步骤1：提取给定条件**\n- 系综：正则系综\n- 温度：$T = 300\\,\\mathrm{K}$\n- 数密度：$\\rho = 0.80\\,\\mathrm{nm}^{-3}$\n- 粗粒化方法：迭代玻尔兹曼反演（IBI）\n- 迭代次数：$n$\n- 关注的间距：$r^{\\ast} = 0.80\\,\\mathrm{nm}$\n- 在 $r^{\\ast}$ 处的测量RDF：$g_{n}(r^{\\ast}) = 1.20$\n- 在 $r^{\\ast}$ 处的目标RDF：$g^{\\mathrm{target}}(r^{\\ast}) = 0.85$\n- 在 $r^{\\ast}$ 处的当前对势：$U_{n}(r^{\\ast}) = 2.50\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$\n- 摩尔气体常数：$R = 8.314462618 \\times 10^{-3}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$\n- 前提1：更新基于将粗粒化对势的变化替换为平均力势的变化。\n- 前提2：平均力势 $w(r)$ 中的加性常数无关紧要。\n- 前提3：能量以摩尔为单位处理，因此玻尔兹曼常数 $k_{B}$ 被摩尔气体常数 $R$ 替代。\n\n**步骤2：使用提取的给定条件进行验证**\n- **科学基础**：该问题在统计力学和计算化学原理，特别是粗粒化建模方面有充分的依据。迭代玻尔兹曼反演是一种标准的、成熟的技术。\n- **适定性**：该问题提供了推导更新规则和计算所要求值所需的所有信息。存在唯一的数值解。数密度 $\\rho$ 的包含对于计算是多余的，但不会使问题无效。\n- **客观性**：该问题以精确、定量和无偏见的语言陈述。\n\n**步骤3：结论与行动**\n该问题在科学上是合理的、自洽的且适定的。因此，它被判定为**有效**。将提供完整的解答。\n\n### 解题推导\n\n迭代玻尔兹曼反演（IBI）方法的核心在于定义模拟中相互作用的对势 $U(r)$ 与由径向分布函数（RDF）$g(r)$ 量化的所得结构之间的关系。这种关系由平均力势（PMF）$w(r)$ 介导。\n\n根据正则系综中的统计力学原理，RDF与PMF的关系如下：\n$$g(r) = \\exp\\left(-\\frac{w(r)}{k_{B}T}\\right)$$\n由于问题规定能量以摩尔为单位处理，我们将玻尔兹曼常数 $k_{B}$ 替换为摩尔气体常数 $R$：\n$$g(r) = \\exp\\left(-\\frac{w(r)}{RT}\\right)$$\n这个基本关系可以反转，以表示PMF作为RDF的函数：\n$$w(r) = -RT \\ln[g(r)]$$\nIBI的目标是找到一个粗粒化对势 $U(r)$，当在模拟中使用时，能够复现一个已知的目标RDF，$g^{\\mathrm{target}}(r)$。目标RDF对应于一个目标PMF，$w^{\\mathrm{target}}(r)$：\n$$w^{\\mathrm{target}}(r) = -RT \\ln[g^{\\mathrm{target}}(r)]$$\n在IBI的第 $n$ 次迭代中，使用当前猜测的势 $U_n(r)$ 进行模拟，得到一个测量的RDF，$g_n(r)$。与此测量RDF对应的PMF是：\n$$w_n(r) = -RT \\ln[g_n(r)]$$\n问题陈述，更新规则是通过“将粗粒化对势的变化替换为平均力势的变化”来推导的。这是IBI的一个关键启发式方法，可以形式化为类似线性响应的假设。从迭代 $n$ 移动到 $n+1$ 所需的势能变化，记为 $\\Delta U_n(r) = U_{n+1}(r) - U_n(r)$，被设定为等于匹配目标所需的PMF变化，即 $\\Delta w(r) = w^{\\mathrm{target}}(r) - w_n(r)$。\n因此，势的更新为：\n$$U_{n+1}(r) - U_n(r) = w^{\\mathrm{target}}(r) - w_n(r)$$\n代入PMF的表达式：\n$$U_{n+1}(r) - U_n(r) = \\left(-RT \\ln[g^{\\mathrm{target}}(r)]\\right) - \\left(-RT \\ln[g_n(r)]\\right)$$\n$$U_{n+1}(r) - U_n(r) = RT \\left(\\ln[g_n(r)] - \\ln[g^{\\mathrm{target}}(r)]\\right)$$\n利用对数的性质，这可以简化为：\n$$U_{n+1}(r) - U_n(r) = RT \\ln\\left[\\frac{g_n(r)}{g^{\\mathrm{target}}(r)}\\right]$$\n整理得到新势 $U_{n+1}(r)$，我们获得标准的IBI更新方程：\n$$U_{n+1}(r) = U_n(r) + RT \\ln\\left[\\frac{g_n(r)}{g^{\\mathrm{target}}(r)}\\right]$$\n\n### 数值计算\n\n现在我们可以使用提供的数据，计算在特定间距 $r^{\\ast} = 0.80\\,\\mathrm{nm}$ 处更新后的势能值 $U_{n+1}(r^{\\ast})$：\n- $U_{n}(r^{\\ast}) = 2.50\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$\n- $T = 300\\,\\mathrm{K}$\n- $R = 8.314462618 \\times 10^{-3}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$\n- $g_{n}(r^{\\ast}) = 1.20$\n- $g^{\\mathrm{target}}(r^{\\ast}) = 0.85$\n\n首先，计算热能项 $RT$：\n$$RT = (8.314462618 \\times 10^{-3}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}) \\times (300\\,\\mathrm{K}) = 2.4943387854\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$$\n接下来，将数值代入更新方程：\n$$U_{n+1}(r^{\\ast}) = 2.50\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} + (2.4943387854\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}) \\times \\ln\\left(\\frac{1.20}{0.85}\\right)$$\n自然对数的参数是：\n$$\\frac{1.20}{0.85} \\approx 1.4117647$$\n该值的自然对数是：\n$$\\ln\\left(\\frac{1.20}{0.85}\\right) \\approx 0.344840486$$\n现在，计算势能校正项：\n$$\\Delta U_n(r^{\\ast}) = (2.4943387854\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}) \\times (0.344840486) \\approx 0.8599446\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$$\n最后，将此校正值加到当前势能上：\n$$U_{n+1}(r^{\\ast}) = 2.50\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} + 0.8599446\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} = 3.3599446\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$$\n问题要求将最终答案四舍五入到四位有效数字。\n$$U_{n+1}(r^{\\ast}) \\approx 3.360\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$$", "answer": "$$\\boxed{3.360}$$", "id": "3402194"}, {"introduction": "除了基于结构的方法，力匹配 (force matching) 是另一种主流的粗粒化参数化策略，它将粗粒化力场拟合到全原子模拟中得到的力。然而，分子动力学轨迹中连续的样本点并非相互独立，而是存在时间相关性。本练习旨在探讨这些时间相关性如何放大我们参数估计的统计误差，并介绍诸如块平均 (block averaging) 等实用方法，以获得可靠的不确定性估计 [@problem_id:3402199]。", "problem": "在平衡分子动力学 (MD) 中，粗粒化 (CG) 力匹配通过最小化映射的原子尺度力与 CG 力模型之间的平方偏差来估计参数矢量。考虑一个标量参数 $\\theta$ 线性地进入 CG 力模型，因此力匹配估计量 $\\hat{\\theta}$ 通过最小化 $\\sum_{i=1}^{M} \\left(f_i \\theta - y_i\\right)^2$ 得到，其中 $f_i$ 是由 CG 映射决定的已知标量特征，$y_i$ 是映射的原子尺度力。假设映射的力 $y_i$ 构成一个平稳时间序列，采样间隔为 $\\Delta t$，其均值为零，自协方差为 $\\operatorname{Cov}(y_{i}, y_{j}) = \\sigma^2 \\rho(|i-j|)$，其中 $\\rho(k)$ 是离散时间自相关函数。该分析的重点是时间相关性如何导致 $\\hat{\\theta}$ 的方差相对于独立同分布 (IID) 的情况发生膨胀，以及如何通过分块平均或子采样来校正有效样本量。\n\n从平稳时间序列的方差和协方差的定义出发，推导作为样本线性平均的估计量的方差膨胀因子，并将其应用于力匹配的背景中，论证时间相关性如何改变方差标度。在设计矩阵是良态的且相关性的主要影响通过残差的时间协方差表现出来的情况下进行分析。特别地，证明对于大的 $M$，\n$$\n\\operatorname{Var}\\left(\\hat{\\theta}\\right)\\propto \\frac{\\sigma^2}{M}\\left[1 + 2 \\sum_{k=1}^{M-1}\\left(1 - \\frac{k}{M}\\right)\\rho(k)\\right]\\approx \\frac{\\sigma^2}{M} g,\n$$\n并定义有效样本量 $N_{\\mathrm{eff}} = M/g$。\n\n现在，考虑 $\\rho(k) = \\exp\\left(-k \\Delta t / \\tau_c\\right)$（单指数衰减）的具体情况，其中 $M = 10000$，$\\Delta t = 0.1\\,\\mathrm{ps}$，相关时间 $\\tau_c = 2.5\\,\\mathrm{ps}$。计算方差膨胀因子 $g$ 和有效样本量 $N_{\\mathrm{eff}}$。然后，提出一种科学上合理的策略，在估计方差时通过以下任一方式校正相关性：\n\n- 为分块平均选择一个块长度 $L_b$，使得块均值近似独立，或者\n- 选择一个子采样步长 $s$，使得子采样序列的残余自相关可以忽略不计。\n\n下列哪些陈述是正确的？\n\nA. 方差膨胀因子为 $g = 1 + 2 \\sum_{k=1}^{\\infty} \\rho(k)$，对于 $\\rho(k) = \\exp\\left(-k \\Delta t / \\tau_c\\right)$，其等于 $g = 1 + 2 \\dfrac{e^{-\\Delta t / \\tau_c}}{1 - e^{-\\Delta t / \\tau_c}}$。当 $M = 10000$，$\\Delta t = 0.1\\,\\mathrm{ps}$，$\\tau_c = 2.5\\,\\mathrm{ps}$ 时，$g \\approx 50$ 且 $N_{\\mathrm{eff}} \\approx 200$。\n\nB. 因为遍历性保证了无偏估计量，所以时间相关性不影响方差，因此无论 $\\rho(k)$ 如何，$N_{\\mathrm{eff}} = M$。\n\nC. 一种分块平均策略是取块长度 $L_b$ 使得 $L_b \\Delta t \\ge 2 \\tau_{\\mathrm{int}}$，这会产生近似独立的块均值；对于单指数 $\\rho$，$\\tau_{\\mathrm{int}} = \\tau_c$，因此选择 $L_b \\approx \\left\\lceil 2 \\tau_c / \\Delta t \\right\\rceil$ 会使得独立块的数量 $K \\approx M / L_b$ 并得到 $N_{\\mathrm{eff}} \\approx K$。\n\nD. 每隔 $s = \\left\\lceil \\tau_c/\\Delta t \\right\\rceil$ 帧进行子采样，可以保证连续样本的独立性，意味着 $N_{\\mathrm{eff}} = M/s$。\n\nE. 时间相关性导致的方差膨胀可以通过在回归前从力 $y_i$ 中减去样本均值来消除；不需要分块平均或子采样来校正方差估计。", "solution": "用户希望我扮演一位严谨的STEM教授，验证所提供的问题，然后解决它。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n*   **模型：** 标量参数 $\\theta$ 的粗粒化 (CG) 力匹配估计量 $\\hat{\\theta}$ 通过最小化平方偏差和得到：$\\sum_{i=1}^{M} \\left(f_i \\theta - y_i\\right)^2$。\n*   **变量：**\n    *   $f_i$：由CG映射决定的已知标量特征。\n    *   $y_i$：映射的原子尺度力。\n    *   $M$：总样本数。\n*   **数据的随机特性：**\n    *   映射的力 $y_i$ 构成一个平稳时间序列。\n    *   采样间隔为 $\\Delta t$。\n    *   力的均值为零：$\\mathbb{E}[y_i] = 0$。\n    *   自协方差为 $\\operatorname{Cov}(y_{i}, y_{j}) = \\sigma^2 \\rho(|i-j|)$，其中 $\\rho(k)$ 是离散时间自相关函数，$\\sigma^2$ 是方差。\n*   **要使用/推导的公式：**\n    *   对于大的 $M$：$\\operatorname{Var}\\left(\\hat{\\theta}\\right)\\propto \\frac{\\sigma^2}{M}\\left[1 + 2 \\sum_{k=1}^{M-1}\\left(1 - \\frac{k}{M}\\right)\\rho(k)\\right]\\approx \\frac{\\sigma^2}{M} g$。\n    *   方差膨胀因子：$g$。\n    *   有效样本量：$N_{\\mathrm{eff}} = M/g$。\n*   **具体案例数据：**\n    *   自相关模型：$\\rho(k) = \\exp\\left(-k \\Delta t / \\tau_c\\right)$。\n    *   $M = 10000$。\n    *   $\\Delta t = 0.1\\,\\mathrm{ps}$。\n    *   $\\tau_c = 2.5\\,\\mathrm{ps}$。\n*   **任务：**\n    1.  展示时间相关性如何改变方差标度，证明所提供的 $\\operatorname{Var}(\\hat{\\theta})$ 公式。\n    2.  计算具体案例中的方差膨胀因子 $g$ 和有效样本量 $N_{\\mathrm{eff}}$。\n    3.  提出一种校正策略（分块平均或子采样）。\n    4.  评估给定的陈述（A、B、C、D、E）。\n\n**步骤2：使用提取的已知条件进行验证**\n\n*   **科学合理性：** 该问题牢固地植根于分子动力学模拟中使用的统计力学和数据分析技术。力匹配是参数化CG模型的标准方法。将模拟数据视为平稳时间序列、自相关分析、方差膨胀概念以及有效样本量的使用，都是该领域中标准且关键的概念。分块平均和子采样是分析相关数据误差的经典方法。\n*   **问题定义良好：** 问题定义良好。它提供了所有必要的定义、数据和清晰的模型 ($\\rho(k)$)，以执行所需的推导和计算。目标陈述明确。\n*   **客观性：** 问题以精确、客观和技术的语言表述。没有主观或基于意见的元素。\n*   **一致性和完整性：** 问题设置是自洽和内部一致的。它没有信息缺失或矛盾的约束。要求“在设计矩阵是良态的”情况下工作，提供了一个有效的简化，允许将重点放在残差的时间相关性上，这是此类分析中的标准方法。\n\n**步骤3：结论与行动**\n\n问题陈述是**有效的**。它在科学上是合理的，问题定义良好，客观且完整。我将继续进行推导和求解。\n\n### 推导与求解\n\n问题要求我们找到估计量 $\\hat{\\theta}$，推导其方差，然后将其应用于一个具体案例。\n\n**1. 估计量及其方差的推导**\n\n估计量 $\\hat{\\theta}$ 最小化目标函数 $L(\\theta) = \\sum_{i=1}^{M} (f_i \\theta - y_i)^2$。我们通过将关于 $\\theta$ 的导数设为零来找到最小值：\n$$\n\\frac{dL}{d\\theta} = \\sum_{i=1}^{M} 2(f_i \\theta - y_i)f_i = 0\n$$\n解出 $\\theta$ 得到最小二乘估计量 $\\hat{\\theta}$：\n$$\n\\hat{\\theta} \\sum_{i=1}^{M} f_i^2 = \\sum_{i=1}^{M} f_i y_i \\implies \\hat{\\theta} = \\frac{\\sum_{i=1}^{M} f_i y_i}{\\sum_{j=1}^{M} f_j^2}\n$$\n该估计量的方差由下式给出：\n$$\n\\operatorname{Var}(\\hat{\\theta}) = \\operatorname{Var}\\left(\\frac{\\sum_{i=1}^{M} f_i y_i}{\\sum_{j=1}^{M} f_j^2}\\right) = \\frac{1}{\\left(\\sum_{j=1}^{M} f_j^2\\right)^2} \\operatorname{Var}\\left(\\sum_{i=1}^{M} f_i y_i\\right)\n$$\n和的方差是：\n$$\n\\operatorname{Var}\\left(\\sum_{i=1}^{M} f_i y_i\\right) = \\sum_{i=1}^{M} \\sum_{j=1}^{M} \\operatorname{Cov}(f_i y_i, f_j y_j) = \\sum_{i=1}^{M} \\sum_{j=1}^{M} f_i f_j \\operatorname{Cov}(y_i, y_j)\n$$\n使用给定的自协方差 $\\operatorname{Cov}(y_i, y_j) = \\sigma^2 \\rho(|i-j|)$，我们有：\n$$\n\\operatorname{Var}(\\hat{\\theta}) = \\frac{\\sigma^2}{\\left(\\sum_{k=1}^{M} f_k^2\\right)^2} \\sum_{i=1}^{M} \\sum_{j=1}^{M} f_i f_j \\rho(|i-j|)\n$$\n问题指出我们应该关注残差中相关性的主要影响。这通常通过考虑特征 $f_i$ 是常数或相对于噪声 $y_i$ 变化缓慢的情况来完成。一个简化但有说明性的案例是估计均值，这对应于对所有 $i$ 设置 $f_i=1$。在这种情况下，$\\hat{\\theta}$ 成为样本均值 $\\bar{y}$（除了一个与方差标度无关的缩放常数）。让我们分析样本均值 $\\bar{y} = \\frac{1}{M} \\sum_{i=1}^M y_i$ 的方差：\n$$\n\\operatorname{Var}(\\bar{y}) = \\frac{1}{M^2} \\operatorname{Var}\\left(\\sum_{i=1}^{M} y_i\\right) = \\frac{1}{M^2} \\sum_{i=1}^{M} \\sum_{j=1}^{M} \\operatorname{Cov}(y_i, y_j) = \\frac{\\sigma^2}{M^2} \\sum_{i=1}^{M} \\sum_{j=1}^{M} \\rho(|i-j|)\n$$\n双重求和可以通过延迟 $k = |i-j|$ 重新索引。对于每个延迟 $k \\in \\{1, 2, ..., M-1\\}$，求和中有 $2(M-k)$ 个对 $(i,j)$。对于 $k=0$，有 $M$ 个对 $(i,i)$。由于 $\\rho(0)=1$：\n$$\n\\sum_{i=1}^{M} \\sum_{j=1}^{M} \\rho(|i-j|) = M \\rho(0) + \\sum_{k=1}^{M-1} 2(M-k)\\rho(k) = M\\left[1 + 2\\sum_{k=1}^{M-1} \\left(1-\\frac{k}{M}\\right)\\rho(k)\\right]\n$$\n将此代入均值的方差表达式中：\n$$\n\\operatorname{Var}(\\bar{y}) = \\frac{\\sigma^2}{M^2} \\cdot M\\left[1 + 2\\sum_{k=1}^{M-1} \\left(1-\\frac{k}{M}\\right)\\rho(k)\\right] = \\frac{\\sigma^2}{M}\\left[1 + 2\\sum_{k=1}^{M-1} \\left(1-\\frac{k}{M}\\right)\\rho(k)\\right]\n$$\n该推导证明了问题陈述中提供的形式是正确的，表明对相关数据的线性平均的方差与括号中的因子成比例。这个因子就是方差膨胀因子 $g$。对于大的 $M$，其中相关性 $\\rho(k)$ 的衰减速度远快于 $k$ 接近 $M$ 的速度，项 $k/M$ 可以忽略不计，并且求和可以扩展到无穷大：\n$$\ng = 1 + 2\\sum_{k=1}^{M-1} \\left(1-\\frac{k}{M}\\right)\\rho(k) \\approx 1 + 2\\sum_{k=1}^{\\infty}\\rho(k)\n$$\n对于独立同分布 (IID) 过程，方差将是 $\\operatorname{Var}_{\\mathrm{IID}}(\\bar{y}) = \\sigma^2/M$。有效样本量 $N_{\\mathrm{eff}}$ 的定义使得方差具有IID形式：$\\operatorname{Var}(\\bar{y}) = \\sigma^2/N_{\\mathrm{eff}}$。将此与 $\\operatorname{Var}(\\bar{y}) = g(\\sigma^2/M)$ 进行比较，我们发现 $N_{\\mathrm{eff}} = M/g$。\n\n**2. 具体案例的计算**\n\n给定 $\\rho(k) = \\exp\\left(-k \\Delta t / \\tau_c\\right)$，$M = 10000$，$\\Delta t = 0.1\\,\\mathrm{ps}$，以及 $\\tau_c = 2.5\\,\\mathrm{ps}$。指数为 $k \\Delta t / \\tau_c = k \\times 0.1 / 2.5 = k/25 = 0.04k$。\n我们使用大 $M$ 近似来计算 $g$：\n$$\ng \\approx 1 + 2 \\sum_{k=1}^{\\infty} e^{-k\\Delta t/\\tau_c} = 1 + 2 \\sum_{k=1}^{\\infty} (e^{-\\Delta t/\\tau_c})^k\n$$\n这是一个公比为 $r = e^{-\\Delta t/\\tau_c} = e^{-0.04}$ 的几何级数。其和为 $\\sum_{k=1}^{\\infty} r^k = r/(1-r)$。\n$$\ng \\approx 1 + 2 \\frac{e^{-0.04}}{1-e^{-0.04}}\n$$\n数值上，$e^{-0.04} \\approx 0.9607894$。\n$$\ng \\approx 1 + 2 \\frac{0.9607894}{1 - 0.9607894} = 1 + 2 \\frac{0.9607894}{0.0392106} \\approx 1 + 2(24.5031) \\approx 1 + 49.0062 = 50.0062\n$$\n所以，方差膨胀因子 $g \\approx 50$。\n有效样本量是：\n$$\nN_{\\mathrm{eff}} = \\frac{M}{g} \\approx \\frac{10000}{50} = 200\n$$\n在10000个相关样本中，我们只拥有相当于200个独立样本的统计功效。\n\n**3. 选项评估**\n\n**A. 方差膨胀因子为 $g = 1 + 2 \\sum_{k=1}^{\\infty} \\rho(k)$，对于 $\\rho(k) = \\exp\\left(-k \\Delta t / \\tau_c\\right)$，其等于 $g = 1 + 2 \\dfrac{e^{-\\Delta t / \\tau_c}}{1 - e^{-\\Delta t / \\tau_c}}$。当 $M = 10000$，$\\Delta t = 0.1\\,\\mathrm{ps}$，$\\tau_c = 2.5\\,\\mathrm{ps}$ 时，$g \\approx 50$ 且 $N_{\\mathrm{eff}} \\approx 200$。**\n该陈述给出了正确的大 $M$ 下 $g$ 的公式，对给定 $\\rho(k)$ 的几何级数的正确求值，以及 $g \\approx 50$ 和 $N_{\\mathrm{eff}} \\approx 200$ 的正确数值计算。我的推导和计算证实了这一点。\n**结论：正确。**\n\n**B. 因为遍历性保证了无偏估计量，所以时间相关性不影响方差，因此无论 $\\rho(k)$ 如何，$N_{\\mathrm{eff}} = M$。**\n这个陈述有根本性的错误。遍历性关联了时间平均和系综平均，确保估计量在大样本量时收敛到正确的值（渐近无偏性）。它没有说明收敛速度或有限样本量下估计量的方差。如上所述，时间相关性会使估计量的方差膨胀，这意味着 $g > 1$ 且 $N_{\\mathrm{eff}} < M$。\n**结论：错误。**\n\n**C. 一种分块平均策略是取块长度 $L_b$ 使得 $L_b \\Delta t \\ge 2 \\tau_{\\mathrm{int}}$，这会产生近似独立的块均值；对于单指数 $\\rho$，$\\tau_{\\mathrm{int}} = \\tau_c$，因此选择 $L_b \\approx \\left\\lceil 2 \\tau_c / \\Delta t \\right\\rceil$ 会使得独立块的数量 $K \\approx M / L_b$ 并得到 $N_{\\mathrm{eff}} \\approx K$。**\n这个陈述描述了一种处理相关数据的标准且科学合理的方法。\n- 积分自相关时间 $\\tau_{\\mathrm{int}}$ 定义为 $\\int_0^\\infty \\rho(t)dt$。对于 $\\rho(t) = e^{-t/\\tau_c}$，我们有 $\\tau_{\\mathrm{int}} = \\int_0^\\infty e^{-t/\\tau_c}dt = \\tau_c$。这部分是正确的。\n- 分块平均的经验法则是选择一个块的时间长度 $L_b \\Delta t$ 为 $\\tau_{\\mathrm{int}}$ 的几倍。选择 $L_b \\Delta t \\ge 2\\tau_{\\mathrm{int}}$ 是一个合理的启发式方法，以确保块均值几乎不相关。由此，$L_b = \\lceil 2\\tau_c / \\Delta t \\rceil = \\lceil 2 \\times 2.5 / 0.1 \\rceil = \\lceil 50 \\rceil = 50$。\n- 使用这个块长度，块的数量为 $K = M/L_b = 10000/50 = 200$。\n- 分块平均的核心思想是，基本独立的样本数量就是块的数量，所以 $N_{\\mathrm{eff}} \\approx K$。\n这个过程得到 $N_{\\mathrm{eff}} \\approx 200$，这与A部分的直接计算结果一致。该陈述正确地描述了一个有效的策略，其结果是一致的。关系式 $g \\approx 2\\tau_c/\\Delta t$（对于 $\\Delta t \\ll \\tau_c$）连接了这两种方法，因为 $L_b \\approx g$。\n**结论：正确。**\n\n**D. 每隔 $s = \\left\\lceil \\tau_c/\\Delta t \\right\\rceil$ 帧进行子采样，可以保证连续样本的独立性，意味着 $N_{\\mathrm{eff}} = M/s$。**\n这个陈述有多个错误。\n- 提议的子采样步长是 $s = \\lceil \\tau_c/\\Delta t \\rceil = \\lceil 2.5/0.1 \\rceil = 25$。\n- 子采样后连续点之间的自相关是 $\\rho(s) = \\rho(25) = \\exp(-25 \\times 0.04) = e^{-1} \\approx 0.368$。这是一个显著的相关性，所以这个步长绝不能“保证独立性”。需要更大的步长，例如 $s \\Delta t = 5 \\tau_c$，才能接近独立。\n- 原始数据集的有效样本量是 $N_{\\mathrm{eff}} \\approx 200$。子采样集中的样本数量是 $M/s = 10000/25 = 400$。这些值不相等。子采样在统计上是低效的，而且这个具体的实现是有缺陷的。\n**结论：错误。**\n\n**E. 时间相关性导致的方差膨胀可以通过在回归前从力 $y_i$ 中减去样本均值来消除；不需要分块平均或子采样来校正方差估计。**\n这个陈述混淆了去均值和去相关。给定的力 $y_i$ 已经具有零均值（$\\mathbb{E}[y_i]=0$）。减去样本均值 $\\bar{y}$ 只是将数据中心化到零，但不会改变时间相关结构。对于大的 $M$，新序列 $y'_i = y_i - \\bar{y}$ 的协方差函数将与原始 $y_i$ 的非常相似。它肯定不会使相关性消失。方差膨胀是这些相关性的直接后果，不受此操作的影响。\n**结论：错误。**\n\n总而言之，陈述A和C都是与问题相关的统计特性和分析方法的正确表述。", "answer": "$$\\boxed{AC}$$", "id": "3402199"}, {"introduction": "一个成功的粗粒化模型不仅要重现系统的静态结构特性，还应能准确描述或至少关联其动力学行为。由于粗粒化过程平滑了能量形貌，这通常会导致动力学过程被人为地加速。本练习将展示如何通过计算时间重缩放因子 $\\alpha$ 来量化这种加速效应，该因子通过匹配广义朗之万方程 (Generalized Langevin Equation) 和 Kramers 理论预测的越垒速率，将粗粒化模拟时间与真实的物理时间联系起来 [@problem_id:3402208]。", "problem": "考虑一个从原子级全原子 (AA) 体系中提取的一维集体变量 $x(t)$，以及一个为再现其平均力势 (PMF) $F(x)$ 而构建的相应的保守粗粒化 (CG) 模型。AA 体系沿 $x$ 的动力学由用于描述越垒动力学的过阻尼极限下的广义朗之万方程 (GLE) 描述，而 CG 动力学则由一个具有白噪声的马尔可夫朗之万方程控制。您需要量化有效时间重标因子 $\\alpha$，使得通过 $\\alpha$ 重标 CG 时间 $t_{\\mathrm{CG}}$ 后，CG 模型中跨越 PMF 势垒的平均首过时间 (MFPT) 与 AA 模型的 MFPT 相匹配。\n\n使用以下基本依据：\n- 牛顿定律及速度定义 $v(t) = dx/dt$。\n- 适用于 AA 集体变量的广义朗之万方程 (GLE)，其包含与涨落-耗散定理一致的附加记忆摩擦和热噪声。\n- Smoluchowski 对过阻尼越垒过程的描述以及经典的用于描述 MFPT 与摩擦的标度关系的高摩擦 Kramers 理论。\n- PMF 势垒高度 $\\Delta F$ 的定义以及在势阱最小值和势垒顶部附近的局域二次近似。\n\n将 AA 有效摩擦定义为 $\\zeta_{\\mathrm{eff}} = \\zeta_{0} + \\int_{0}^{\\infty} K(t)\\,dt$，其中 $\\zeta_{0}$ 是瞬时 (马尔可夫) 摩擦分量，$K(t)$ 是记忆核。将 CG 摩擦定义为 $\\zeta_{\\mathrm{CG}}$ (马尔可夫)。假设 AA 和 CG 具有相同的 PMF $F(x)$。在位于 $x_{\\mathrm{m}}$ 的势阱和位于 $x_{\\mathrm{b}}$ 的势垒的高摩擦过阻尼区域中，MFPT $T$ 与摩擦成线性关系，与势垒高度成指数关系，其指前因子由局域曲率 $F''(x_{\\mathrm{m}})$ 和 $F''(x_{\\mathrm{b}})$ 决定。\n\n您的任务是：\n1. 基于上述基本依据，推导一个必须应用于 CG 动力学的时间重标因子 $\\alpha$ 的表达式，以使跨越 PMF 势垒的 MFPT 与 AA 动力学的 MFPT 相匹配。用 $\\zeta_{0}$、$\\zeta_{\\mathrm{CG}}$ 和 $\\int_{0}^{\\infty} K(t)\\,dt$ 表示 $\\alpha$。\n2. 实现一个程序，对于每个提供的测试用例，通过以下步骤计算 $\\alpha$：\n   - 计算给定 $K(t)$ 的积分记忆 $\\int_{0}^{\\infty} K(t)\\,dt$，\n   - 计算 $\\zeta_{\\mathrm{eff}} = \\zeta_{0} + \\int_{0}^{\\infty} K(t)\\,dt$，\n   - 匹配 MFPT 以获得 $\\alpha$。\n3. 为进行验证，您的实现还应使用相同的 PMF 势垒和曲率，通过过阻尼高摩擦 Kramers 标度关系计算 AA 和 CG 的 MFPT，并确认 MFPT 的比率等于 $\\alpha$。MFPT 必须以秒为单位表示。\n\n单位和定义：\n- 温度 $T$ 以开尔文为单位，玻尔兹曼常数 $k_{\\mathrm{B}}$ 为 $1.380649 \\times 10^{-23}$ 焦耳/开尔文。\n- 势垒高度指定为热能的倍数：$\\Delta F = n \\, k_{\\mathrm{B}} T$，单位为焦耳。\n- 曲率 $F''(x_{\\mathrm{m}})$ 和 $F''(x_{\\mathrm{b}})$ 以 $\\mathrm{kg}/\\mathrm{s}^{2}$ 为单位，其中 $F''(x_{\\mathrm{b}}) < 0$；在适当情况下使用 $|F''(x_{\\mathrm{b}})|$。\n- 摩擦系数 $\\zeta_{\\mathrm{CG}}$ 和 $\\zeta_{0}$ 以 $\\mathrm{kg}/\\mathrm{s}$ 为单位。\n- 记忆核以指数和的形式提供：$K(t) = \\sum_{i} a_{i} e^{-t/\\tau_{i}}$，其中振幅 $a_{i}$ 的单位为 $\\mathrm{kg}/\\mathrm{s}^{2}$，时间尺度 $\\tau_{i}$ 的单位为 $\\mathrm{s}$。\n\n测试套件：\n为以下五个测试用例提供计算，每个用例指定为一个元组 $(T, n, F''(x_{\\mathrm{m}}), F''(x_{\\mathrm{b}}), \\zeta_{\\mathrm{CG}}, \\zeta_{0}, \\{(a_{i}, \\tau_{i})\\}_{i})$：\n- 案例 1：$T = 300$, $n = 12$, $F''(x_{\\mathrm{m}}) = 2.0$, $F''(x_{\\mathrm{b}}) = -3.0$, $\\zeta_{\\mathrm{CG}} = 1.0$, $\\zeta_{0} = 0.7$, 记忆项 $\\{(0.3, 2.0)\\}$。\n- 案例 2：$T = 300$, $n = 8$, $F''(x_{\\mathrm{m}}) = 1.2$, $F''(x_{\\mathrm{b}}) = -1.8$, $\\zeta_{\\mathrm{CG}} = 1.0$, $\\zeta_{0} = 1.0$, 记忆项 $\\{\\}$。\n- 案例 3：$T = 310$, $n = 15$, $F''(x_{\\mathrm{m}}) = 2.5$, $F''(x_{\\mathrm{b}}) = -2.0$, $\\zeta_{\\mathrm{CG}} = 0.9$, $\\zeta_{0} = 0.6$, 记忆项 $\\{(0.5, 0.5), (0.2, 3.0)\\}$。\n- 案例 4：$T = 280$, $n = 10$, $F''(x_{\\mathrm{m}}) = 1.0$, $F''(x_{\\mathrm{b}}) = -4.0$, $\\zeta_{\\mathrm{CG}} = 0.8$, $\\zeta_{0} = 0.8$, 记忆项 $\\{(50.0, 0.01)\\}$。\n- 案例 5：$T = 300$, $n = 20$, $F''(x_{\\mathrm{m}}) = 3.0$, $F''(x_{\\mathrm{b}}) = -6.0$, $\\zeta_{\\mathrm{CG}} = 1.5$, $\\zeta_{0} = 0.4$, 记忆项 $\\{(0.6, 1.0)\\}$。\n\n输出规范：\n- 对于每个测试用例，计算时间重标因子 $\\alpha$ 作为一个浮点数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个 $\\alpha$ 值四舍五入到六位小数（例如，$[1.234567,0.500000,2.000000]$）。", "solution": "核心任务是确定时间重标因子 $\\alpha$，该因子可使一维越垒过程中粗粒化 (CG) 模型的动力学与其相应的全原子 (AA) 父模型保持一致。这种一致性要求在重标后的 CG 动力学和 AA 动力学中，跨越平均力势 (PMF) 势垒的平均首过时间 (MFPT) 是相同的。假设两种表示的 PMF (表示为 $F(x)$) 是相同的。\n\nCG 模型的动力学由一个简单的、针对集体变量 $x(t)$ 的马尔可夫过阻尼朗之万方程描述：\n$$\n\\zeta_{\\mathrm{CG}} \\frac{dx(t)}{dt} = -\\frac{dF(x)}{dx} + R_{\\mathrm{CG}}(t)\n$$\n此处，$\\zeta_{\\mathrm{CG}}$ 是 CG 模型的常数 (马尔可夫) 摩擦系数，$R_{\\mathrm{CG}}(t)$ 是满足涨落-耗散定理的白噪声热力：$\\langle R_{\\mathrm{CG}}(t) R_{\\mathrm{CG}}(t') \\rangle = 2 k_{\\mathrm{B}} T \\zeta_{\\mathrm{CG}} \\delta(t-t')$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是温度。\n\nAA 模型的动力学由更复杂的、包含记忆效应的过阻尼极限下的广义朗之万方程 (GLE) 描述：\n$$\n\\zeta_{0} \\frac{dx(t)}{dt} + \\int_{0}^{t} K(t-t') \\frac{dx(t')}{dt'} dt' = -\\frac{dF(x)}{dx} + R_{\\mathrm{AA}}(t)\n$$\n在此方程中，$\\zeta_{0}$ 是瞬时摩擦分量，$K(t)$ 是记忆核，它解释了由被积掉的自由度引起的时间相关力。项 $R_{\\mathrm{AA}}(t)$ 代表热噪声，通过第二涨落-耗散定理与 $\\zeta_0$ 和 $K(t)$ 相关联。\n\n对于诸如跨越高峰值势垒之类的慢过程，速度 $\\frac{dx}{dt}$ 的变化时间尺度远长于记忆核 $K(t)$ 的衰减时间。这允许使用所谓的零频近似，其中速度 $\\frac{dx(t')}{dt'}$ 在记忆积分的持续时间内可被视为常数并提取出来：\n$$\n\\int_{0}^{t} K(t-t') \\frac{dx(t')}{dt'} dt' \\approx \\frac{dx(t)}{dt} \\int_{0}^{t} K(\\tau) d\\tau\n$$\n对于一个已经演化了很长时间的过程，积分的上限可以扩展到无穷大。这将 GLE 简化为一个有效的马尔可夫朗之万方程：\n$$\n\\left( \\zeta_{0} + \\int_{0}^{\\infty} K(\\tau) d\\tau \\right) \\frac{dx(t)}{dt} \\approx -\\frac{dF(x)}{dx} + R_{\\mathrm{AA}}(t)\n$$\n该方程与简单的朗之万方程形式相同，但具有一个由下式给出的有效摩擦系数 $\\zeta_{\\mathrm{eff}}$：\n$$\n\\zeta_{\\mathrm{eff}} = \\zeta_{0} + \\int_{0}^{\\infty} K(t) dt\n$$\n问题将记忆核指定为指数和：$K(t) = \\sum_{i} a_{i} e^{-t/\\tau_{i}}$。该积分可以解析计算：\n$$\n\\int_{0}^{\\infty} K(t) dt = \\int_{0}^{\\infty} \\sum_{i} a_{i} e^{-t/\\tau_{i}} dt = \\sum_{i} a_{i} \\int_{0}^{\\infty} e^{-t/\\tau_{i}} dt\n$$\n每个指数项的积分是 $\\int_{0}^{\\infty} e^{-t/\\tau_{i}} dt = [-\\tau_i e^{-t/\\tau_i}]_0^{\\infty} = \\tau_i$。因此，积分记忆为：\n$$\n\\int_{0}^{\\infty} K(t) dt = \\sum_{i} a_{i} \\tau_{i}\n$$\nAA 模型的有效摩擦为 $\\zeta_{\\mathrm{eff}} = \\zeta_{0} + \\sum_{i} a_{i} \\tau_{i}$。\n\n在高摩擦（过阻尼）极限下，从势阱越过势垒的 MFPT 由 Kramers 理论给出。对于位于 $x_{\\mathrm{m}}$ 的势阱和位于 $x_{\\mathrm{b}}$ 的势垒，MFPT, $T_{\\mathrm{MFPT}}$ 为：\n$$\nT_{\\mathrm{MFPT}} = \\frac{2 \\pi \\zeta}{\\sqrt{F''(x_{\\mathrm{m}}) |F''(x_{\\mathrm{b}})|}} \\exp\\left(\\frac{\\Delta F}{k_{\\mathrm{B}} T}\\right)\n$$\n其中 $\\zeta$ 是相关的摩擦系数，$\\Delta F$ 是势垒高度，$F''(x_{\\mathrm{m}})$ 和 $F''(x_{\\mathrm{b}})$ 分别是 PMF 在最小值和势垒顶部的曲率。\n\n将此公式应用于我们的两个模型，我们使用其有效摩擦 $\\zeta_{\\mathrm{eff}}$ 得到 AA 体系的 MFPT：\n$$\nT_{\\mathrm{MFPT, AA}} = \\frac{2 \\pi \\zeta_{\\mathrm{eff}}}{\\sqrt{F''(x_{\\mathrm{m}}) |F''(x_{\\mathrm{b}})|}} \\exp\\left(\\frac{\\Delta F}{k_{\\mathrm{B}} T}\\right)\n$$\n对于 CG 体系，使用其摩擦系数 $\\zeta_{\\mathrm{CG}}$：\n$$\nT_{\\mathrm{MFPT, CG}} = \\frac{2 \\pi \\zeta_{\\mathrm{CG}}}{\\sqrt{F''(x_{\\mathrm{m}}) |F''(x_{\\mathrm{b}})|}} \\exp\\left(\\frac{\\Delta F}{k_{\\mathrm{B}} T}\\right)\n$$\n时间重标因子 $\\alpha$ 通过 $t_{\\mathrm{AA}} = \\alpha \\cdot t_{\\mathrm{CG}}$ 将 AA 模拟中的时间 ($t_{\\mathrm{AA}}$) 与 CG 模拟中的时间 ($t_{\\mathrm{CG}}$) 联系起来。为了匹配动力学，跨越势垒的物理时间必须相同。AA 体系的物理时间是 $T_{\\mathrm{MFPT, AA}}$。与 CG 模拟事件对应的物理时间是 $\\alpha \\cdot T_{\\mathrm{MFPT, CG}}$。令它们相等可得：\n$$\nT_{\\mathrm{MFPT, AA}} = \\alpha \\cdot T_{\\mathrm{MFPT, CG}}\n$$\n现在我们可以求解 $\\alpha$：\n$$\n\\alpha = \\frac{T_{\\mathrm{MFPT, AA}}}{T_{\\mathrm{MFPT, CG}}} = \\frac{\\frac{2 \\pi \\zeta_{\\mathrm{eff}}}{\\sqrt{F''(x_{\\mathrm{m}}) |F''(x_{\\mathrm{b}})|}} \\exp\\left(\\frac{\\Delta F}{k_{\\mathrm{B}} T}\\right)}{\\frac{2 \\pi \\zeta_{\\mathrm{CG}}}{\\sqrt{F''(x_{\\mathrm{m}}) |F''(x_{\\mathrm{b}})|}} \\exp\\left(\\frac{\\Delta F}{k_{\\mathrm{B}} T}\\right)}\n$$\n由于两个模型的 PMF ($F(x)$) 相同，涉及势垒高度 $\\Delta F$ 和曲率 $F''$ 的项完全抵消，只留下一个简单的摩擦系数比率：\n$$\n\\alpha = \\frac{\\zeta_{\\mathrm{eff}}}{\\zeta_{\\mathrm{CG}}}\n$$\n代入推导出的 $\\zeta_{\\mathrm{eff}}$ 表达式：\n$$\n\\alpha = \\frac{\\zeta_{0} + \\sum_{i} a_{i} \\tau_{i}}{\\zeta_{\\mathrm{CG}}}\n$$\n这是用于计算的最终表达式。程序将为每个案例计算 $\\sum_{i} a_{i} \\tau_{i}$，确定 $\\zeta_{\\mathrm{eff}}$，然后计算 $\\alpha$。完整的 MFPT 计算作为验证步骤执行，以确认它们的比率确实等于 $\\alpha$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the time rescaling factor alpha for five test cases based on\n    the principles of coarse-grained modeling and barrier-crossing kinetics.\n    \"\"\"\n    \n    # Define physical constants\n    K_B = 1.380649e-23  # Boltzmann constant in J/K\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (T, n, F_ddot_m, F_ddot_b, zeta_cg, zeta_0, memory_terms)\n    # where memory_terms is a list of (a_i, tau_i) tuples.\n    test_cases = [\n        (300, 12, 2.0, -3.0, 1.0, 0.7, [(0.3, 2.0)]),\n        (300, 8, 1.2, -1.8, 1.0, 1.0, []),\n        (310, 15, 2.5, -2.0, 0.9, 0.6, [(0.5, 0.5), (0.2, 3.0)]),\n        (280, 10, 1.0, -4.0, 0.8, 0.8, [(50.0, 0.01)]),\n        (300, 20, 3.0, -6.0, 1.5, 0.4, [(0.6, 1.0)]),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        T, n, F_ddot_m, F_ddot_b, zeta_cg, zeta_0, memory_terms = case\n\n        # 1. Compute the integrated memory kernel\n        # integral(K(t) dt) = sum(a_i * tau_i)\n        integrated_memory = sum(a * tau for a, tau in memory_terms)\n\n        # 2. Compute the AA effective friction\n        zeta_eff = zeta_0 + integrated_memory\n\n        # 3. Match MFPTs to obtain alpha\n        # alpha = T_MFPT_AA / T_MFPT_CG = zeta_eff / zeta_cg\n        alpha = zeta_eff / zeta_cg\n        \n        results.append(alpha)\n\n        # 4. Verification step (as required by the problem statement)\n        # This part computes the MFPTs explicitly to confirm the ratio is alpha.\n        # These values are not part of the final output but are computed for validation.\n        \n        # PMF barrier height in Joules\n        delta_F = n * K_B * T\n        \n        # Geometric prefactor component (same for AA and CG)\n        # Note: F_ddot_b is negative.\n        geometric_factor = np.sqrt(F_ddot_m * abs(F_ddot_b))\n        \n        # Exponential term (same for AA and CG)\n        # Note: delta_F / (K_B * T) simply equals n\n        exp_term = np.exp(n)\n        \n        # Common factor in MFPT expression\n        common_mfpt_factor = (2 * np.pi / geometric_factor) * exp_term\n\n        # Calculate MFPT for AA and CG systems\n        T_mfpt_aa = common_mfpt_factor * zeta_eff\n        T_mfpt_cg = common_mfpt_factor * zeta_cg\n\n        # Confirm that the ratio of MFPTs equals alpha\n        # This confirms the correctness of the derivation and implementation.\n        # A small tolerance is used due to potential floating-point inaccuracies.\n        assert np.isclose(alpha, T_mfpt_aa / T_mfpt_cg), \"Verification failed: alpha != T_aa / T_cg\"\n        \n    # Format the results into the required string format\n    # Each alpha is rounded to six decimal places.\n    output_str = f\"[{','.join([f'{res:.6f}' for res in results])}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "3402208"}]}