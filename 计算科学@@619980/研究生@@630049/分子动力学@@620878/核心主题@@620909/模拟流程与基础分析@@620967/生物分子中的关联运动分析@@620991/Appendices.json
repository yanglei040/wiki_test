{"hands_on_practices": [{"introduction": "任何相关性分析的基础都是一条有效的分子动力学轨迹。这项实践将指导您从头开始构建一个简单的郎之万动力学（Langevin dynamics）模拟器，从而巩固分子动力学背后的基本物理原理，例如牛顿第二定律和涨落-耗散定理。通过比较基于位置的相关性 $C_{ij}$ 和基于速度的相关性 $C^{v}_{ij}$ [@problem_id:3406448]，您将亲身体会到像惯性耦合这样的物理现象如何在不同时间尺度上体现在相关性数据中。", "problem": "一维粗粒化生物分子片段可以理想化为一条由 $N$ 个质点组成的链，质点之间通过最近邻谐波耦合相互作用。在分子动力学（MD）中，研究人员通过基于位置的相关性来研究关联运动，并在快速时间尺度上通过基于速度的相关性来评估惯性耦合。考虑以下物理上一致的模型，该模型由牛顿第二定律、线性阻尼和热策动（朗之万动力学）所支配。链的状态由位置 $x_i(t)$ 和速度 $v_i(t)$ 描述，其中 $i \\in \\{1,\\dots,N\\}$。总势能是谐波的，具有最近邻耦合和一个弱的在位锚定以消除全局漂移。确定性力是线性的，$F(x) = -K x$，其中 $K$ 是一个对称正定刚度矩阵，由链的拉普拉斯算子加上一个在位项构成。连续时间运动方程为\n$$\nm \\,\\frac{d^2 x}{dt^2} \\;=\\; F(x) \\;-\\; \\gamma \\, \\frac{dx}{dt} \\;+\\; \\sqrt{2 \\gamma \\, k_{\\mathrm{B}} T} \\,\\eta(t),\n$$\n其中 $m$ 是质量（假设所有位点相同），$\\gamma$ 是每个自由度的摩擦系数，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度，$\\eta(t)$ 是一个由独立标准高斯白噪声组成的向量。使用约化单位制，其中 $k_{\\mathrm{B}} T$ 以与势能相同的能量单位表示，并取 $k_{\\mathrm{B}}=1$，使得 $T$ 在数值上等于热能。假设质量矩阵为 $m I$，摩擦是各向同性的（标量 $\\gamma$）。您必须从第一性原理出发，在离散时间内模拟此系统，而不依赖任何黑箱分子动力学库。\n\n您的任务是：\n- 仅从牛顿第二定律、谐波势产生的线性和以及涨落-耗散关系出发，为朗之万动力学推导出一个稳定的、时间可逆的分解积分器。该积分器能精确处理 Ornstein–Uhlenbeck 速度子步骤，并对漂移和力的施加使用对称的半步长。\n- 实现该模拟器，并在均匀时间网格 $t_n = n \\,\\Delta t$（整数 $n \\ge 0$，时间步长为 $\\Delta t$）上生成采样轨迹 $x_i(t_n)$ 和 $v_i(t_n)$。\n- 根据采样轨迹，分别计算位置和速度的跨位点皮尔逊相关矩阵，其中时间样本作为观测值。用 $C$ 表示基于位置的相关矩阵（其元素为 $C_{ij}$），用 $C^{v}$ 表示基于速度的相关矩阵（其元素为 $C^{v}_{ij}$）。\n- 将惯性耦合指数定义为平均绝对最近邻速度相关性与平均绝对最近邻位置相关性之差：\n$$\n\\mathcal{I} \\;=\\; \\frac{1}{N-1} \\sum_{i=1}^{N-1} \\left( \\left| C^{v}_{i,i+1} \\right| \\;-\\; \\left| C_{i,i+1} \\right| \\right).\n$$\n该指数是无量纲的。正的 $\\mathcal{I}$ 表示平均而言，最近邻速度相关性超过位置相关性，这与惯性耦合在快速时间尺度上占主导地位相符；负的 $\\mathcal{I}$ 则表示相反情况。\n\n对于具有最近邻耦合常数 $k$ 和在位锚定 $k_{\\mathrm{a}}$ 的线性链，刚度矩阵 $K$ 构建如下：\n$$\nK \\;=\\; k \\, L \\;+\\; k_{\\mathrm{a}} \\, I,\n$$\n其中 $L$ 是路径图的 $N \\times N$ 拉普拉斯矩阵：$(L)_{ii} = 2$ 对 $i \\in \\{2,\\dots,N-1\\}$，$(L)_{11}=(L)_{NN}=1$，以及 $(L)_{i,i+1}=(L)_{i+1,i}=-1$ 对所有最近邻。使用初始条件 $x(0)=0$ 和 $v(0)=0$，除非指定了脉冲；如果给定了脉冲振幅 $v_0$，则设置 $v_{\\lfloor N/2 \\rfloor}(0) \\leftarrow v_{\\lfloor N/2 \\rfloor}(0) + v_0$。为确保可复现性，随机数生成器必须使用种子 $s=12345$ 进行初始化。\n\n测试套件。请精确运行以下三个测试用例，每个用例指定为一个元组 $(N, m, k, k_{\\mathrm{a}}, \\gamma, T, \\Delta t, \\text{steps}, \\text{warmup}, v_0)$，其中 $\\text{steps}$ 是总积分步数，$\\text{warmup}$ 是在为计算相关性收集数据之前要丢弃的初始步数，而 $v_0$ 是脉冲振幅：\n- 用例 1（无热噪声的欠阻尼瞬态）：$(N, m, k, k_{\\mathrm{a}}, \\gamma, T, \\Delta t, \\text{steps}, \\text{warmup}, v_0) = (6, 1, 100, 1, 0.1, 0, 0.001, 20000, 0, 8)$。\n- 用例 2（强阻尼热平衡）：$(N, m, k, k_{\\mathrm{a}}, \\gamma, T, \\Delta t, \\text{steps}, \\text{warmup}, v_0) = (6, 1, 100, 1, 5, 1, 0.001, 80000, 20000, 0)$。\n- 用例 3（中等阻尼热平衡）：$(N, m, k, k_{\\mathrm{a}}, \\gamma, T, \\Delta t, \\text{steps}, \\text{warmup}, v_0) = (6, 1, 100, 1, 1, 1, 0.001, 80000, 20000, 0)$。\n\n所有输出均为无量纲。您的程序应生成单行输出，其中包含上述用例的三个 $\\mathcal{I}$ 值，按顺序排列，格式为用方括号括起来的逗号分隔列表（例如，$[\\mathcal{I}_1,\\mathcal{I}_2,\\mathcal{I}_3]$）。不应打印任何其他文本。", "solution": "该问题是有效的，因为它提出了一个在计算统计物理学领域中定义明确、有科学依据的任务。它是自洽的，提供了所有必要的参数、初始条件和定义，以获得一个唯一且可验证的数值解。该模型，即谐波链的朗之万动力学，是分子动力学中的一个标准和基础系统。验证清单未显示任何缺陷。\n\n问题的核心是模拟一维质点链的朗之万动力学。位置 $x(t) \\in \\mathbb{R}^N$ 的运动方程是一个二阶随机微分方程：\n$$\nm \\frac{d^2 x}{dt^2} = F(x) - \\gamma \\frac{dx}{dt} + \\sqrt{2 \\gamma T} \\eta(t)\n$$\n这里，我们使用了指定的约化单位制，其中玻尔兹曼常数 $k_{\\mathrm{B}}=1$。变量包括质量 $m$（一个标量，因为质量矩阵是 $mI$）、摩擦系数 $\\gamma$、温度 $T$ 以及一个由独立标准高斯白噪声组成的向量 $\\eta(t)$。确定性力是线性的，$F(x) = -Kx$，源自一个谐波势，其中 $K$ 是刚度矩阵。\n\n为对此进行数值求解，我们需要一个稳定的、时间可逆的积分器。问题要求使用一种分解方法，该方法能精确处理速度动力学的 Ornstein-Uhlenbeck (OU) 部分，并对位置和力的更新使用对称半步长。BAOAB 积分器完美地满足了这些要求。\n\n动力学可以形式化地由一个刘维尔算子 $\\mathcal{L}$ 描述，该算子可以分解为三个部分：\n1.  **漂移 (A)：** 由速度引起的位置演化，$\\dot{x} = v$。相关算子为 $\\mathcal{L}_A = v \\cdot \\nabla_x$。\n2.  **踢动 (B)：** 由确定性力引起的速度演化，$\\dot{v} = F(x)/m$。相关算子为 $\\mathcal{L}_B = (F(x)/m) \\cdot \\nabla_v$。\n3.  **OU 过程 (O)：** 由摩擦和热噪声引起的速度演化，$\\dot{v} = -(\\gamma/m)v + \\sqrt{2 \\gamma T}/m \\, \\eta(t)$。相关算子为 $\\mathcal{L}_O$。\n\nBAOAB 方法是一种对称的 Strang 分解，形式为 $e^{\\mathcal{L} \\Delta t} \\approx e^{\\frac{\\Delta t}{2}\\mathcal{L}_B} e^{\\frac{\\Delta t}{2}\\mathcal{L}_A} e^{\\Delta t\\mathcal{L}_O} e^{\\frac{\\Delta t}{2}\\mathcal{L}_A} e^{\\frac{\\Delta t}{2}\\mathcal{L}_B}$。这一系列操作定义了单个时间步长 $\\Delta t$ 的算法。\n\n让我们推导每个子步骤的精确传播子：\n- **传播子 $e^{\\tau \\mathcal{L}_A}$ (漂移)：** 对于时间间隔 $\\tau$，此步骤在假设速度恒定的情况下更新位置：$x \\rightarrow x + v\\tau$。\n- **传播子 $e^{\\tau \\mathcal{L}_B}$ (踢动)：** 对于时间间隔 $\\tau$，此步骤在假设力恒定的情况下更新速度：$v \\rightarrow v + (F(x)/m)\\tau$。\n- **传播子 $e^{\\tau \\mathcal{L}_O}$ (OU 过程)：** 此步骤涉及在保持位置 $x$ 固定的情况下，求解速度 $v$ 的线性随机微分方程：\n$$\nd v = - \\frac{\\gamma}{m} v dt + \\frac{\\sqrt{2 \\gamma T}}{m} dW_t\n$$\n其中 $dW_t = \\eta(t)dt$ 是一个维纳过程向量。在时间间隔 $\\tau$ 内，速度向量的每个分量的精确解是：\n$$\nv_i(\\tau) = v_i(0) e^{-(\\gamma/m)\\tau} + R_i\n$$\n其中 $R_i$ 是一个高斯随机数，其均值为 $\\mathbb{E}[R_i] = 0$，方差为：\n$$\n\\text{Var}(R_i) = \\frac{2\\gamma T}{m^2} \\int_0^\\tau e^{-2(\\gamma/m)(\\tau-s)} ds = \\frac{T}{m} \\left( 1 - e^{-2(\\gamma/m)\\tau} \\right)\n$$\n因此，在整个时间步长 $\\Delta t$ 内，O-步骤的速度更新可以写成：\n$$\nv \\rightarrow c_1 v + c_2 \\mathcal{N}(0, I)\n$$\n其中 $\\mathcal{N}(0, I)$ 是一个由独立标准正态随机变量组成的向量，常数为：\n$$\nc_1 = e^{-(\\gamma/m)\\Delta t} \\quad \\text{and} \\quad c_2 = \\sqrt{\\frac{T}{m}(1 - c_1^2)}\n$$\n\n根据 BAOAB 分解组合这些传播子，得到从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的一个积分步骤的算法如下，从状态 $(x_n, v_n)$ 开始：\n1.  **B-步骤（半个踢动）：** 计算力 $F_n = -Kx_n$。更新速度：\n    $$v_{n+1/2}^{(1)} = v_n + \\frac{\\Delta t}{2m} F_n$$\n2.  **A-步骤（半个漂移）：** 使用新速度更新位置：\n    $$x_{n+1/2} = x_n + \\frac{\\Delta t}{2} v_{n+1/2}^{(1)}$$\n3.  **O-步骤（完整 OU）：** 用摩擦和噪声更新速度：\n    $$v_{n+1/2}^{(2)} = c_1 v_{n+1/2}^{(1)} + c_2 \\mathcal{N}_n$$\n    其中 $\\mathcal{N}_n$ 是一个新的标准正态随机数向量。\n4.  **A-步骤（半个漂移）：** 使用后OU速度再次更新位置：\n    $$x_{n+1} = x_{n+1/2} + \\frac{\\Delta t}{2} v_{n+1/2}^{(2)}$$\n5.  **B-步骤（半个踢动）：** 计算新位置处的力 $F_{n+1} = -Kx_{n+1}$，并完成速度更新：\n    $$v_{n+1} = v_{n+1/2}^{(2)} + \\frac{\\Delta t}{2m} F_{n+1}$$\n\n该算法被实现用来生成位置 $x(t_n)$ 和速度 $v(t_n)$ 的轨迹。在舍弃初始的 `warmup` 周期后，收集到的轨迹被用于计算所需的相关矩阵。\n\n刚度矩阵 $K$ 的构造方式为 $K = k L + k_{\\mathrm{a}} I$，其中 $I$ 是单位矩阵，$L$ 是一维链（路径图）的拉普拉斯算子：\n$$\n(L)_{ij} = \\begin{cases} 1  \\text{if } i=j \\text{ and } i \\in \\{1,N\\} \\\\ 2  \\text{if } i=j \\text{ and } i \\in \\{2,\\dots,N-1\\} \\\\ -1  \\text{if } |i-j|=1 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n从位置轨迹 $\\{x_i(t_n)\\}$ 和速度轨迹 $\\{v_i(t_n)\\}$（存储为数据矩阵 $X$ 和 $V$，其中列表示位点，行表示时间样本），计算位置的皮尔逊相关矩阵（$C$）和速度的皮尔逊相关矩阵（$C^v$）。元素 $C_{ij}$ 是位点 $i$ 和位点 $j$ 的时间序列之间的相关性。\n\n最后，惯性耦合指数 $\\mathcal{I}$ 计算为速度和位置的绝对最近邻相关性之差的平均值：\n$$\n\\mathcal{I} = \\frac{1}{N-1} \\sum_{i=1}^{N-1} \\left( | C^v_{i,i+1} | - | C_{i,i+1} | \\right)\n$$\n此方案应用于指定的三个测试用例中的每一个。随机数生成器被设定种子以确保可复现性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_inertial_index(N, m, k, k_a, gamma, T, dt, steps, warmup, v0, rng):\n    \"\"\"\n    Simulates a 1D harmonic chain with Langevin dynamics and computes the inertial coupling index.\n    \"\"\"\n    \n    # 1. Build the stiffness matrix K\n    L = np.zeros((N, N))\n    if N > 1:\n        np.fill_diagonal(L, 2)\n        L[0, 0] = 1\n        L[N-1, N-1] = 1\n        np.fill_diagonal(L[1:], -1)\n        np.fill_diagonal(L[:, 1:], -1)\n    elif N == 1:\n        L[0,0] = 0 # No neighbors\n        \n    K = k * L + k_a * np.identity(N)\n    \n    # 2. Initialization\n    x = np.zeros(N)\n    v = np.zeros(N)\n    \n    if v0 != 0 and N > 0:\n        center_idx = N // 2\n        v[center_idx] += v0\n        \n    # 3. Integrator constants for BAOAB\n    c1 = np.exp(-gamma * dt / m)\n    if T > 0:\n        # k_B is 1\n        c2 = np.sqrt(T * (1 - c1**2) / m)\n    else:\n        c2 = 0.0\n\n    # 4. Simulation Loop\n    x_traj = []\n    v_traj = []\n    \n    for step in range(steps):\n        # B-step (half kick)\n        F = -K @ x\n        v_half = v + (dt / (2.0 * m)) * F\n        \n        # A-step (half drift)\n        x_half = x + (dt / 2.0) * v_half\n        \n        # O-step (full)\n        if c2 > 0:\n            R = rng.standard_normal(N)\n            v_prime_half = c1 * v_half + c2 * R\n        else:\n            v_prime_half = c1 * v_half\n\n        # A-step (half drift)\n        x_new = x_half + (dt / 2.0) * v_prime_half\n        \n        # B-step (half kick)\n        F_new = -K @ x_new\n        v_new = v_prime_half + (dt / (2.0 * m)) * F_new\n        \n        # Update state\n        x, v = x_new, v_new\n        \n        # Store trajectories after warmup\n        if step >= warmup:\n            x_traj.append(x)\n            v_traj.append(v)\n            \n    # 5. Post-processing and Analysis\n    if not x_traj or N <= 1:\n        return 0.0\n\n    X_data = np.array(x_traj)\n    V_data = np.array(v_traj)\n    \n    # Handle potential constant trajectories by checking std dev\n    # This avoids RuntimeWarning from np.corrcoef\n    if np.any(np.std(X_data, axis=0) < 1e-12) or np.any(np.std(V_data, axis=0) < 1e-12):\n        # Center data manually\n        X_data_centered = X_data - np.mean(X_data, axis=0)\n        V_data_centered = V_data - np.mean(V_data, axis=0)\n        # Compute covariance matrices\n        cov_pos = X_data_centered.T @ X_data_centered / X_data_centered.shape[0]\n        cov_vel = V_data_centered.T @ V_data_centered / V_data_centered.shape[0]\n        # Compute standard deviations, adding epsilon to avoid division by zero\n        std_pos = np.sqrt(np.diag(cov_pos)) + 1e-12\n        std_vel = np.sqrt(np.diag(cov_vel)) + 1e-12\n        # Compute correlation matrices\n        C_pos = cov_pos / np.outer(std_pos, std_pos)\n        C_vel = cov_vel / np.outer(std_vel, std_vel)\n    else:\n        C_pos = np.corrcoef(X_data, rowvar=False)\n        C_vel = np.corrcoef(V_data, rowvar=False)\n\n    abs_nn_corr_pos = np.abs(np.diag(C_pos, k=1))\n    abs_nn_corr_vel = np.abs(np.diag(C_vel, k=1))\n    \n    inertial_index = np.mean(abs_nn_corr_vel - abs_nn_corr_pos)\n    \n    return inertial_index\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, m, k, k_a, gamma, T, dt, steps, warmup, v0)\n        (6, 1, 100, 1, 0.1, 0, 0.001, 20000, 0, 8),\n        (6, 1, 100, 1, 5, 1, 0.001, 80000, 20000, 0),\n        (6, 1, 100, 1, 1, 1, 0.001, 80000, 20000, 0),\n    ]\n\n    results = []\n    # Initialize a single random number generator for reproducibility\n    rng = np.random.default_rng(seed=12345)\n\n    for case in test_cases:\n        N, m, k, k_a, gamma, T, dt, steps, warmup, v0 = case\n        result = calculate_inertial_index(N, m, k, k_a, gamma, T, dt, steps, warmup, v0, rng)\n        # Format result to a reasonable number of decimal places for consistency\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3406448"}, {"introduction": "在我们能够计算相关性之后，评估其统计显著性便成为至关重要的一步，因为没有误差估计的相关系数是缺乏意义的。这项实践深入探讨了时间序列分析的统计学基础，利用积分自相关时间 $\\tau_{\\mathrm{int}}$ 的概念来确定一条相关轨迹中的有效独立样本数量。您将学会如何预先规划模拟，通过估算达到特定精度的协方差估计所需的轨迹长度[@problem_id:3406452]，这对于进行高效且严谨的计算研究是一项至关重要的技能。", "problem": "考虑一个由标量可观测量 $Y(t) = \\left(X_i(t) - \\mu_i\\right)\\left(X_j(t) - \\mu_j\\right)$ 定义的平稳分子动力学时间序列，其中 $X_i(t)$ 和 $X_j(t)$ 是生物分子中两个原子（或位点）的笛卡尔坐标分量，而 $\\mu_i$ 和 $\\mu_j$ 是它们的平稳均值。我们感兴趣的量是协方差 $C_{ij} = \\mathbb{E}[Y(t)] = \\mathrm{Cov}(X_i,X_j)$。假设该过程是遍历且混合的，因此随着总轨迹时长 $T$ 的增长，时间平均收敛于系综平均，并且 $\\left(X_i,X_j\\right)$ 的涨落是联合高斯分布，具有零均值（中心化后）和有限方差。进一步假设 $Y(t)$ 具有归一化自相关函数 $\\rho_Y(\\tau)$，且 $\\rho_Y(0)=1$。\n\n您通过时间平均 $\\widehat{C}_{ij} = \\frac{1}{T}\\int_0^T Y(t)\\,dt$ 从总长度为 $T$ 的轨迹中估计 $C_{ij}$。对于较长的 $T$，平稳混合过程的中心极限定理指出，$\\widehat{C}_{ij}$ 的分布近似为正态分布，其方差随 $T$ 衰减。定义积分自相关时间为 $\\tau_{\\mathrm{int}} = \\int_0^{\\infty} \\rho_Y(\\tau)\\,d\\tau$。令 $\\sigma_Y^2 = \\mathrm{Var}\\left(Y(t)\\right)$ 表示 $Y(t)$ 的边际方差。在分子动力学的时间序列分析中，一个经过充分检验的事实是，对于较大的 $T$，$\\widehat{C}_{ij}$ 的方差遵循 $\\mathrm{Var}\\left(\\widehat{C}_{ij}\\right) \\approx \\frac{2\\,\\sigma_Y^2\\,\\tau_{\\mathrm{int}}}{T}$。因此，有效样本大小为 $N_{\\mathrm{eff}} \\approx \\frac{T}{2\\tau_{\\mathrm{int}}}$，与独立抽样相比，方差减小了 $N_{\\mathrm{eff}}$ 倍。采用双侧置信区间，其高斯分位数为 $z$，使得半宽为 $z\\sqrt{\\mathrm{Var}\\left(\\widehat{C}_{ij}\\right)}$。\n\n假设 $\\left(X_i,X_j\\right)$ 的联合高斯性，因此四阶矩恒等式（Isserlis 定理）意味着 $E\\!\\left[X_i^2 X_j^2\\right] = \\sigma_i^2 \\sigma_j^2 + 2 C_{ij}^2$，其中 $\\sigma_i^2 = \\mathrm{Var}(X_i)$ 和 $\\sigma_j^2 = \\mathrm{Var}(X_j)$。因此，$\\sigma_Y^2 = \\sigma_i^2 \\sigma_j^2 + C_{ij}^2$。令 $\\rho_{ij}$ 表示 $X_i$ 和 $X_j$ 之间的皮尔逊相关系数，因此 $C_{ij} = \\rho_{ij}\\,\\sigma_i\\,\\sigma_j$。\n\n您的任务是：编写一个完整的、可运行的程序，为每个指定的测试用例计算所需的最小轨迹长度 $T_{\\min}$（以纳秒为单位），以确保 $\\widehat{C}_{ij}$ 的相对双侧置信区间半宽不超过规定的容差 $\\varepsilon$，即 $z\\,\\sqrt{\\mathrm{Var}\\left(\\widehat{C}_{ij}\\right)}/\\lvert C_{ij}\\rvert \\le \\varepsilon$。使用大 $T$ 渐近和上述定义。使用以下 $\\rho_Y(\\tau)$ 模型，并通过计算相应的积分来计算 $\\tau_{\\mathrm{int}}$：\n- 指数模型：$\\rho_Y(\\tau) = \\exp\\!\\left(-\\tau/\\tau_c\\right)$，其中 $\\tau_{\\mathrm{int}} = \\int_0^{\\infty} e^{-\\tau/\\tau_c} d\\tau$。\n- 双指数模型：$\\rho_Y(\\tau) = a\\,\\exp\\!\\left(-\\tau/\\tau_1\\right) + (1-a)\\,\\exp\\!\\left(-\\tau/\\tau_2\\right)$，其中 $a \\in (0,1)$，且 $\\tau_{\\mathrm{int}} = \\int_0^{\\infty} \\left[a\\,e^{-\\tau/\\tau_1} + (1-a)\\,e^{-\\tau/\\tau_2}\\right] d\\tau$。\n- 幂律模型（可积长尾）：$\\rho_Y(\\tau) = \\left(1 + \\tau/\\tau_0\\right)^{-\\alpha}$，其中 $\\alpha > 1$，且 $\\tau_{\\mathrm{int}} = \\int_0^{\\infty} \\left(1+\\tau/\\tau_0\\right)^{-\\alpha} d\\tau$。\n\n物理单位和报告：\n- 所有时间必须以纳秒为单位。\n- 所有长度必须以纳米为单位。\n- 置信水平为双侧， $z = 1.96$（约对应 $95$ 百分位）。\n- 以纳秒为单位报告每个 $T_{\\min}$，四舍五入到三位小数。\n\n测试套件：\n- 案例 1（理想情况，单指数）：$\\tau_c = 5$ ns，$\\sigma_i = 0.3$ nm，$\\sigma_j = 0.3$ nm，$\\rho_{ij} = 0.5$，$\\varepsilon = 0.1$，$z = 1.96$。\n- 案例 2（双指数，强慢模）：$a = 0.7$，$\\tau_1 = 20$ ns，$\\tau_2 = 1$ ns，$\\sigma_i = 0.2$ nm，$\\sigma_j = 0.4$ nm，$\\rho_{ij} = 0.3$，$\\varepsilon = 0.1$，$z = 1.96$。\n- 案例 3（弱协方差，单指数）：$\\tau_c = 2$ ns，$\\sigma_i = 0.25$ nm，$\\sigma_j = 0.25$ nm，$\\rho_{ij} = 0.05$，$\\varepsilon = 0.1$，$z = 1.96$。\n- 案例 4（可积重尾）：$\\tau_0 = 1$ ns，$\\alpha = 1.1$，$\\sigma_i = 0.15$ nm，$\\sigma_j = 0.35$ nm，$\\rho_{ij} = 0.2$，$\\varepsilon = 0.2$，$z = 1.96$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按四个案例的顺序排列结果，每个 $T_{\\min}$ 以纳秒为单位四舍五入到三位小数。例如，打印的行必须具有 [$t_1$,$t_2$,$t_3$,$t_4$] 的形式，其中每个 $t_k$ 是一个代表纳秒并四舍五入到三位小数的浮点数。", "solution": "问题陈述已经过严格验证，并被确定为具有科学依据、提法恰当且内部一致。所有提供的参数、定义和假设在统计力学和分子动力学模拟分析领域都是标准的。该问题可按所述方式求解。\n\n主要目标是确定估计两个原子坐标 $X_i$ 和 $X_j$ 之间的协方差 $C_{ij}$ 所需的最小模拟时间 $T_{\\min}$，使得估计量 $\\widehat{C}_{ij}$ 的双侧置信区间的相对半宽不大于指定的容差 $\\varepsilon$。\n\n关于相对置信区间半宽的条件由下式给出：\n$$ \\frac{z\\sqrt{\\mathrm{Var}\\left(\\widehat{C}_{ij}\\right)}}{\\lvert C_{ij}\\rvert} \\le \\varepsilon $$\n为了找到最小时间 $T_{\\min}$，我们在不等式的边界处求解此表达式，即左侧等于 $\\varepsilon$。\n\n问题陈述指出，对于持续时间为 $T$ 的长轨迹，时间平均估计量 $\\widehat{C}_{ij}$ 的方差由以下渐近公式给出：\n$$ \\mathrm{Var}\\left(\\widehat{C}_{ij}\\right) \\approx \\frac{2\\,\\sigma_Y^2\\,\\tau_{\\mathrm{int}}}{T} $$\n此处，$\\sigma_Y^2 = \\mathrm{Var}\\left(Y(t)\\right)$ 是可观测量 $Y(t) = (X_i(t)-\\mu_i)(X_j(t)-\\mu_j)$ 的方差，而 $\\tau_{\\mathrm{int}} = \\int_0^{\\infty} \\rho_Y(\\tau)\\,d\\tau$ 是其积分自相关时间。\n\n将方差表达式代入条件中得到：\n$$ \\frac{z\\sqrt{\\frac{2\\,\\sigma_Y^2\\,\\tau_{\\mathrm{int}}}{T}}}{\\lvert C_{ij}\\rvert} = \\varepsilon $$\n求解 $T$ 可得到所需的最小时间 $T_{\\min}$：\n$$ \\frac{z^2}{C_{ij}^2} \\left( \\frac{2\\,\\sigma_Y^2\\,\\tau_{\\mathrm{int}}}{T_{\\min}} \\right) = \\varepsilon^2 $$\n$$ T_{\\min} = \\frac{2\\,z^2\\,\\sigma_Y^2\\,\\tau_{\\mathrm{int}}}{\\varepsilon^2\\,C_{ij}^2} $$\n问题提供了 $\\sigma_Y^2$、坐标方差 $\\sigma_i^2$ 和 $\\sigma_j^2$ 以及协方差 $C_{ij}$ 之间的关系，该关系源自联合高斯变量的 Isserlis 定理：\n$$ \\sigma_Y^2 = \\sigma_i^2 \\sigma_j^2 + C_{ij}^2 $$\n协方差 $C_{ij}$ 也通过 $C_{ij} = \\rho_{ij}\\sigma_i\\sigma_j$ 与皮尔逊相关系数 $\\rho_{ij}$ 相关。我们可以使用这些关系来简化 $T_{\\min}$ 的表达式。比率 $\\sigma_Y^2 / C_{ij}^2$ 可以表示为：\n$$ \\frac{\\sigma_Y^2}{C_{ij}^2} = \\frac{\\sigma_i^2 \\sigma_j^2 + C_{ij}^2}{C_{ij}^2} = \\frac{\\sigma_i^2 \\sigma_j^2}{(\\rho_{ij}\\sigma_i\\sigma_j)^2} + 1 = \\frac{\\sigma_i^2 \\sigma_j^2}{\\rho_{ij}^2\\sigma_i^2\\sigma_j^2} + 1 = \\frac{1}{\\rho_{ij}^2} + 1 $$\n将此简化比率代回 $T_{\\min}$ 的方程，我们得到一个更直接的公式，它依赖于 $\\rho_{ij}$ 但不显式依赖于 $\\sigma_i$ 或 $\\sigma_j$：\n$$ T_{\\min} = \\frac{2\\,z^2\\,\\tau_{\\mathrm{int}}}{\\varepsilon^2} \\left( \\frac{1}{\\rho_{ij}^2} + 1 \\right) $$\n这是我们计算的核心方程。下一步是为归一化自相关函数 $\\rho_Y(\\tau)$ 的三种模型中的每一种找到积分自相关时间 $\\tau_{\\mathrm{int}}$ 的表达式。\n\n1.  **指数模型**: $\\rho_Y(\\tau) = \\exp(-\\tau/\\tau_c)$\n    $$ \\tau_{\\mathrm{int}} = \\int_0^{\\infty} \\exp(-\\tau/\\tau_c) \\,d\\tau = \\left[-\\tau_c \\exp(-\\tau/\\tau_c)\\right]_0^{\\infty} = 0 - (-\\tau_c e^0) = \\tau_c $$\n\n2.  **双指数模型**: $\\rho_Y(\\tau) = a\\,\\exp(-\\tau/\\tau_1) + (1-a)\\exp(-\\tau/\\tau_2)$\n    $$ \\tau_{\\mathrm{int}} = \\int_0^{\\infty} \\left[a\\,\\exp(-\\tau/\\tau_1) + (1-a)\\exp(-\\tau/\\tau_2)\\right] \\,d\\tau = a\\tau_1 + (1-a)\\tau_2 $$\n\n3.  **幂律模型**: $\\rho_Y(\\tau) = (1 + \\tau/\\tau_0)^{-\\alpha}$ for $\\alpha > 1$\n    $$ \\tau_{\\mathrm{int}} = \\int_0^{\\infty} (1 + \\tau/\\tau_0)^{-\\alpha} \\,d\\tau = \\tau_0 \\int_1^{\\infty} u^{-\\alpha} \\,du = \\tau_0 \\left[\\frac{u^{1-\\alpha}}{1-\\alpha}\\right]_1^{\\infty} = \\frac{\\tau_0}{\\alpha - 1} $$\n    由于 $\\alpha > 1$，这使得指数 $1-\\alpha$ 为负，因此积分收敛。\n\n有了这些公式，我们现在可以评估每个测试用例。\n\n**案例 1**：指数模型\n- 参数：$\\tau_c = 5$ ns, $\\rho_{ij} = 0.5$, $\\varepsilon = 0.1$, $z = 1.96$。\n- $\\tau_{\\mathrm{int}} = \\tau_c = 5$ ns.\n- $T_{\\min} = \\frac{2 \\times (1.96)^2 \\times 5}{(0.1)^2} \\left( \\frac{1}{(0.5)^2} + 1 \\right) = \\frac{38.416}{0.01} (4 + 1) = 3841.6 \\times 5 = 19208.0$ ns。\n\n**案例 2**：双指数模型\n- 参数：$a = 0.7$, $\\tau_1 = 20$ ns, $\\tau_2 = 1$ ns, $\\rho_{ij} = 0.3$, $\\varepsilon = 0.1$, $z = 1.96$。\n- $\\tau_{\\mathrm{int}} = 0.7 \\times 20 + (1 - 0.7) \\times 1 = 14 + 0.3 = 14.3$ ns。\n- $T_{\\min} = \\frac{2 \\times (1.96)^2 \\times 14.3}{(0.1)^2} \\left( \\frac{1}{(0.3)^2} + 1 \\right) = \\frac{109.86736}{0.01} \\left( \\frac{1}{0.09} + 1 \\right) = 10986.736 \\times \\frac{1.09}{0.09} \\approx 133061.580$ ns。\n\n**案例 3**：指数模型（弱协方差）\n- 参数：$\\tau_c = 2$ ns, $\\rho_{ij} = 0.05$, $\\varepsilon = 0.1$, $z = 1.96$。\n- $\\tau_{\\mathrm{int}} = \\tau_c = 2$ ns。\n- $\\rho_{ij}$ 的小值将急剧增加所需的模拟时间。\n- $T_{\\min} = \\frac{2 \\times (1.96)^2 \\times 2}{(0.1)^2} \\left( \\frac{1}{(0.05)^2} + 1 \\right) = \\frac{15.3664}{0.01} (400 + 1) = 1536.64 \\times 401 = 616192.64$ ns。\n\n**案例 4**：幂律模型（可积重尾）\n- 参数：$\\tau_0 = 1$ ns, $\\alpha = 1.1$, $\\rho_{ij} = 0.2$, $\\varepsilon = 0.2$, $z = 1.96$。\n- $\\alpha$ 的值接近 1 表明相关性衰减缓慢，导致较大的 $\\tau_{\\mathrm{int}}$。\n- $\\tau_{\\mathrm{int}} = \\frac{\\tau_0}{\\alpha - 1} = \\frac{1}{1.1 - 1} = \\frac{1}{0.1} = 10$ ns。\n- $T_{\\min} = \\frac{2 \\times (1.96)^2 \\times 10}{(0.2)^2} \\left( \\frac{1}{(0.2)^2} + 1 \\right) = \\frac{76.832}{0.04} (25 + 1) = 1920.8 \\times 26 = 49940.8$ ns。\n\n这些计算得出了每个案例所需的最小模拟时间，这将在提供的程序中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed for this problem.\n\ndef solve():\n    \"\"\"\n    Calculates the minimum trajectory length T_min required to estimate\n    the covariance C_ij with a specified relative precision.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # The parameters sigma_i and sigma_j are not needed for the simplified\n    # final formula but are kept here for completeness relative to the problem statement.\n    test_cases = [\n        {'model': 'exponential', 'params': {'tau_c': 5.0}, 'rho_ij': 0.5, 'epsilon': 0.1, 'z': 1.96},\n        {'model': 'bi_exponential', 'params': {'a': 0.7, 'tau_1': 20.0, 'tau_2': 1.0}, 'rho_ij': 0.3, 'epsilon': 0.1, 'z': 1.96},\n        {'model': 'exponential', 'params': {'tau_c': 2.0}, 'rho_ij': 0.05, 'epsilon': 0.1, 'z': 1.96},\n        {'model': 'power_law', 'params': {'tau_0': 1.0, 'alpha': 1.1}, 'rho_ij': 0.2, 'epsilon': 0.2, 'z': 1.96},\n    ]\n\n    results = []\n    for case in test_cases:\n        model = case['model']\n        params = case['params']\n        rho_ij = case['rho_ij']\n        epsilon = case['epsilon']\n        z = case['z']\n\n        tau_int = 0.0\n        if model == 'exponential':\n            # For the exponential model, tau_int = tau_c\n            tau_int = params['tau_c']\n        elif model == 'bi_exponential':\n            # For the bi-exponential model, tau_int = a*tau_1 + (1-a)*tau_2\n            tau_int = params['a'] * params['tau_1'] + (1.0 - params['a']) * params['tau_2']\n        elif model == 'power_law':\n            # For the power-law model, tau_int = tau_0 / (alpha - 1)\n            tau_int = params['tau_0'] / (params['alpha'] - 1.0)\n\n        # The simplified analytical formula for the minimum trajectory length is:\n        # T_min = (2 * z^2 * tau_int / epsilon^2) * (1/rho_ij^2 + 1)\n        # This formula is derived in the solution text by combining the expressions for\n        # Var(C_ij_hat), sigma_Y^2, and C_ij.\n        \n        term_prefactor = (2.0 * z**2 * tau_int) / (epsilon**2)\n        term_correlation = (1.0 / rho_ij**2) + 1.0\n        T_min = term_prefactor * term_correlation\n\n        # Append the result rounded to three decimal places.\n        results.append(f\"{T_min:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3406452"}, {"introduction": "在处理复杂的生物分子系统时，标准的分子动力学模拟往往效率低下，因此必须采用伞形采样（umbrella sampling）或元动力学（metadynamics）等增强采样方法来加速构象探索。然而，这种加速并非没有代价。这项实践将利用一个简化的谐振子模型，让您能够通过解析和数值计算的方式，探究沿特定集合变量施加的偏置势如何扭曲其他正交自由度中的固有相关性。通过学习量化这些由偏置引起的扭曲[@problem_id:3406465]，您将对高级模拟技术形成一种批判性的审视能力，从而更好地确保分析结果的物理真实性。", "problem": "考虑一个过阻尼分子动力学 (MD) 系统，该系统具有三个构型自由度，一个指定的集体变量 (CV) $x$ 和两个正交坐标 $y$ 和 $z$。假设位置的稳态分布由玻尔兹曼形式给出，在无量纲单位中逆热能 $\\beta = 1$，且原始势能是具有双线性耦合的谐波形式，\n$$\nU(x,y,z) = \\frac{1}{2} k_x x^2 + \\frac{1}{2} k_y y^2 + \\frac{1}{2} k_z z^2 + k_{yz} y z + k_{xy} x y + k_{xz} x z,\n$$\n其 Hessian 矩阵是正定的。将正交子空间中的原始协方差矩阵定义为\n$$\n\\Sigma^{\\text{native}} = \\begin{pmatrix}\n\\mathrm{Cov}(y,y)  \\mathrm{Cov}(y,z) \\\\\n\\mathrm{Cov}(z,y)  \\mathrm{Cov}(z,z)\n\\end{pmatrix}.\n$$\n沿 CV $x$ 应用两种偏置方案：\n1. 使用谐波偏置的伞形采样，\n$$\nV_{\\mathrm{umb}}(x) = \\frac{1}{2} k_{\\mathrm{umb}} (x - x_0)^2,\n$$\n2. 使用表示为高斯山之和的静态极限偏置的元动力学，\n$$\nV_{\\mathrm{meta}}(x) = \\sum_{n=1}^{N} h_n \\exp\\left(-\\frac{(x - s_n)^2}{2 w^2}\\right).\n$$\n从基本定义出发，包括玻尔兹曼分布 $p(\\mathbf{q}) \\propto \\exp(-U(\\mathbf{q}))$（其中 $\\mathbf{q} = (x,y,z)$）和协方差定义 $C_{ij} = \\langle q_i q_j \\rangle - \\langle q_i \\rangle \\langle q_j \\rangle$，推导添加偏置 $V(x)$ 如何改变 $x$ 的有效分布，并以谐波参数的形式传播到正交协方差矩阵 $\\Sigma^{V}$ 中。使用相对 Frobenius 范数量化偏置在正交子空间中引起的原始协方差的畸变，\n$$\n\\Delta(V) = \\frac{\\left\\| \\Sigma^{V} - \\Sigma^{\\text{native}} \\right\\|_F}{\\left\\| \\Sigma^{\\text{native}} \\right\\|_F},\n$$\n其中 $\\|\\cdot\\|_F$ 表示 Frobenius 范数。所有能量和变量均为无量纲，且 $\\beta = 1$。\n\n你的任务是实现一个程序，为每个提供的测试用例计算两个浮点数：\n- 伞形偏置的 $\\Delta(V_{\\mathrm{umb}})$，\n- 元动力学偏置的 $\\Delta(V_{\\mathrm{meta}})$，\n并输出所有测试用例的汇总结果。\n\n推导必须基于：\n- 玻尔兹曼分布和高斯积分的性质，\n- 协方差的定义以及谐波势中的线性耦合如何影响条件分布和边际分布。\n\n对于伞形偏置，由于其二次型形式，$x$ 的方差可以解析地表示。对于元动力学偏置，通过一维数值积分计算 $x$ 的方差，\n$$\n\\mathrm{Var}_{V_{\\mathrm{meta}}}(x) = \\frac{\\int_{-\\infty}^{\\infty} x^2 \\exp\\left(-U_{\\mathrm{eff}}(x) - V_{\\mathrm{meta}}(x)\\right) \\, dx}{\\int_{-\\infty}^{\\infty} \\exp\\left(-U_{\\mathrm{eff}}(x) - V_{\\mathrm{meta}}(x)\\right) \\, dx},\n$$\n其中 $U_{\\mathrm{eff}}(x)$ 是在对 $y$ 和 $z$ 积分后得到的 $x$ 的有效二次项。使用得到的方差，通过其对 $x$ 和 $(y,z)$ 之间耦合的依赖关系来计算正交协方差 $\\Sigma^{V}$。\n\n测试套件：\n为以下参数集提供结果，每个参数集指定为元组 $(k_x,k_y,k_z,k_{yz},k_{xy},k_{xz},k_{\\mathrm{umb}},x_0,N,\\{h_n\\},\\{s_n\\},w)$：\n\n- 情况 1 (一般的“理想路径”)：\n  $(3.0, 2.0, 1.5, 0.2, 0.3, -0.25, 4.0, 0.5, 3, \\{0.8, 0.6, 0.4\\}, \\{-0.5, 0.0, 0.5\\}, 0.4)$\n- 情况 2 (边界情况，正交自由度中与 $x$ 的耦合为零)：\n  $(2.2, 1.8, 1.3, 0.3, 0.0, 0.0, 3.0, -0.1, 2, \\{1.0, 0.5\\}, \\{-0.2, 0.7\\}, 0.5)$\n- 情况 3 (边缘情况，强正交耦合和中等 $x$ 耦合)：\n  $(5.0, 1.5, 1.1, 0.9, 0.7, 0.6, 0.5, -0.2, 4, \\{2.0, 1.7, 1.3, 0.9\\}, \\{-1.0, -0.3, 0.3, 1.1\\}, 0.3)$\n\n算法要求：\n- 计算原始正交协方差 $\\Sigma^{\\text{native}}$。\n- 使用组合的有效二次系数下 $x$ 的解析方差，计算伞形采样偏置下的正交协方差 $\\Sigma^{V_{\\mathrm{umb}}}$。\n- 使用数值积分计算 $\\mathrm{Var}_{V_{\\mathrm{meta}}}(x)$，以计算元动力学偏置下的正交协方差 $\\Sigma^{V_{\\mathrm{meta}}}$。\n- 为每种情况计算 $\\Delta(V_{\\mathrm{umb}})$ 和 $\\Delta(V_{\\mathrm{meta}})$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个由列表组成的列表的结果，每个内部列表包含一个测试用例的两个浮点数，格式为\n“[ [delta_case1_umb, delta_case1_meta], [delta_case2_umb, delta_case2_meta], [delta_case3_umb, delta_case3_meta] ]”。\n无需单位，因为所有量都是无量纲的。不涉及角度。", "solution": "我们考虑一个三维谐波系统，其坐标为 $(x,y,z)$，能量为\n$$\nU(x,y,z) = \\frac{1}{2} k_x x^2 + \\frac{1}{2} k_y y^2 + \\frac{1}{2} k_z z^2 + k_{yz} y z + k_{xy} x y + k_{xz} x z,\n$$\n且 $\\beta = 1$，因此稳态分布为 $p(x,y,z) \\propto \\exp(-U(x,y,z))$。我们将正交坐标定义为向量 $\\mathbf{o} = (y,z)^\\top$。令\n$$\nA = \\begin{pmatrix} k_y  k_{yz} \\\\ k_{yz}  k_z \\end{pmatrix}, \\quad b = \\begin{pmatrix} k_{xy} \\\\ k_{xz} \\end{pmatrix}.\n$$\n则能量可以用块符号表示的二次型写出，\n$$\nU(x,\\mathbf{o}) = \\frac{1}{2} k_x x^2 + \\frac{1}{2} \\mathbf{o}^\\top A \\mathbf{o} + x b^\\top \\mathbf{o}.\n$$\n我们要求完整的 Hessian 矩阵是正定的，以便积分收敛。\n\n原理 1：玻尔兹曼分布和高斯条件化。对于一个与 $\\exp\\left(-\\frac{1}{2} [x,\\mathbf{o}]^\\top H [x,\\mathbf{o}] \\right)$ 成正比的联合高斯分布，给定 $x$ 时 $\\mathbf{o}$ 的条件分布是高斯分布，其协方差为 $A^{-1}$，均值随 $x$ 线性偏移。对 $\\mathbf{o}$ 进行配方，我们得到\n$$\nU(x,\\mathbf{o}) = \\frac{1}{2} \\left( \\mathbf{o} + A^{-1} b x \\right)^\\top A \\left( \\mathbf{o} + A^{-1} b x \\right) + \\frac{1}{2} \\left( k_x - b^\\top A^{-1} b \\right) x^2.\n$$\n对 $\\mathbf{o}$ 积分得到 $x$ 的有效能量，\n$$\nU_{\\mathrm{eff}}(x) = \\frac{1}{2} \\left( k_x - b^\\top A^{-1} b \\right) x^2 + \\text{const},\n$$\n因此原始系统中 $x$ 的边际分布是方差为\n$$\n\\mathrm{Var}_{\\text{native}}(x) = \\frac{1}{k_x - b^\\top A^{-1} b}\n$$\n的高斯分布。这确定了沿 $x$ 的有效刚度，\n$$\nk_x^{\\mathrm{eff}} = k_x - b^\\top A^{-1} b,\n$$\n为保证可归一化性，该值必须为正。\n\n原理 2：通过全协方差定律计算正交协方差。给定 $x$ 时 $\\mathbf{o}$ 的条件协方差是常数，等于 $A^{-1}$，因为 $\\mathbf{o}$ 的条件二次型矩阵为 $A$。条件均值为 $\\mathbb{E}[\\mathbf{o}\\mid x] = -A^{-1} b x$。使用全协方差定律，\n$$\n\\mathrm{Cov}(\\mathbf{o}) = \\mathbb{E}[\\mathrm{Cov}(\\mathbf{o}\\mid x)] + \\mathrm{Cov}(\\mathbb{E}[\\mathbf{o}\\mid x]).\n$$\n第一项就是 $A^{-1}$。第二项涉及 $x$ 的方差：\n$$\n\\mathrm{Cov}(\\mathbb{E}[\\mathbf{o}\\mid x]) = \\mathrm{Cov}(-A^{-1} b x) = A^{-1} b \\, \\mathrm{Var}(x) \\, b^\\top A^{-1}.\n$$\n因此，对于任何只改变 $x$ 分布的偏置 $V(x)$，正交协方差变为\n$$\n\\Sigma^{V} = A^{-1} + A^{-1} b \\, \\mathrm{Var}_{V}(x) \\, b^\\top A^{-1}.\n$$\n当 $\\mathrm{Var}_{V}(x)$ 等于 $\\mathrm{Var}_{\\text{native}}(x)$ 时，可恢复原始正交协方差。\n\n伞形采样。对于伞形偏置 $V_{\\mathrm{umb}}(x) = \\frac{1}{2} k_{\\mathrm{umb}} (x - x_0)^2$，沿 $x$ 的有效能量为\n$$\nU_{\\mathrm{eff}}^{\\mathrm{umb}}(x) = \\frac{1}{2} k_x^{\\mathrm{eff}} x^2 + \\frac{1}{2} k_{\\mathrm{umb}} (x - x_0)^2,\n$$\n这是一个二次型。$x$ 的方差仅取决于总的二次项系数，而与偏移量 $x_0$ 无关：\n$$\n\\mathrm{Var}_{\\mathrm{umb}}(x) = \\frac{1}{k_x^{\\mathrm{eff}} + k_{\\mathrm{umb}}}.\n$$\n因此，\n$$\n\\Sigma^{V_{\\mathrm{umb}}} = A^{-1} + A^{-1} b \\, \\frac{1}{k_x^{\\mathrm{eff}} + k_{\\mathrm{umb}}} \\, b^\\top A^{-1}.\n$$\n\n元动力学。对于作为高斯山之和的元动力学偏置 $V_{\\mathrm{meta}}(x)$， $x$ 的有效一维分布是非高斯的：\n$$\np_{V_{\\mathrm{meta}}}(x) \\propto \\exp\\left(-U_{\\mathrm{eff}}(x) - V_{\\mathrm{meta}}(x)\\right) = \\exp\\left(-\\frac{1}{2} k_x^{\\mathrm{eff}} x^2 - \\sum_{n=1}^N h_n \\exp\\left(-\\frac{(x - s_n)^2}{2 w^2}\\right)\\right).\n$$\n方差通过一维数值积分计算，\n$$\n\\mathrm{Var}_{\\mathrm{meta}}(x) = \\frac{\\int_{-\\infty}^{\\infty} x^2 \\exp\\left(-\\frac{1}{2} k_x^{\\mathrm{eff}} x^2 - \\sum_{n=1}^N h_n \\exp\\left(-\\frac{(x - s_n)^2}{2 w^2}\\right)\\right) \\, dx}{\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{1}{2} k_x^{\\mathrm{eff}} x^2 - \\sum_{n=1}^N h_n \\exp\\left(-\\frac{(x - s_n)^2}{2 w^2}\\right)\\right) \\, dx}.\n$$\n然后\n$$\n\\Sigma^{V_{\\mathrm{meta}}} = A^{-1} + A^{-1} b \\, \\mathrm{Var}_{\\mathrm{meta}}(x) \\, b^\\top A^{-1}.\n$$\n\n畸变度量。原始正交协方差为\n$$\n\\Sigma^{\\text{native}} = A^{-1} + A^{-1} b \\, \\frac{1}{k_x^{\\mathrm{eff}}} \\, b^\\top A^{-1}.\n$$\n对于每个偏置 $V$，计算\n$$\n\\Delta(V) = \\frac{\\left\\| \\Sigma^{V} - \\Sigma^{\\text{native}} \\right\\|_F}{\\left\\| \\Sigma^{\\text{native}} \\right\\|_F}.\n$$\n\n程序中实现的算法步骤：\n1. 构造 $A$ 并计算 $A^{-1}$。\n2. 计算 $b$ 和 $k_x^{\\mathrm{eff}} = k_x - b^\\top A^{-1} b$；检查正定性。\n3. 使用 $\\mathrm{Var}_{\\text{native}}(x) = 1/k_x^{\\mathrm{eff}}$ 计算 $\\Sigma^{\\text{native}}$。\n4. 伞形采样：计算 $\\mathrm{Var}_{\\mathrm{umb}}(x) = 1/(k_x^{\\mathrm{eff}} + k_{\\mathrm{umb}})$ 和 $\\Sigma^{V_{\\mathrm{umb}}}$。\n5. 元动力学：使用数值积分计算 $\\mathrm{Var}_{\\mathrm{meta}}(x)$ 的分子和分母积分，然后计算 $\\Sigma^{V_{\\mathrm{meta}}}$。\n6. 通过 Frobenius 范数计算 $\\Delta(V_{\\mathrm{umb}})$ 和 $\\Delta(V_{\\mathrm{meta}})$。\n7. 按规定汇总结果。\n\n边缘情况分析：\n- 当 $b = \\mathbf{0}$ (即 $x$ 和 $(y,z)$ 之间没有耦合) 时，$\\Sigma^{V}$ 简化为 $A^{-1}$，而与 $x$ 的方差无关。因此，对于任何偏置，$\\Delta(V) = 0$，反映了原始正交协方差的完美保持。\n- 强正交耦合（$|k_{yz}|$ 较大但 $A$ 仍为正定）通过 $A^{-1}$ 增加了 $\\Sigma^{\\text{native}}$ 对 $b$ 的敏感性，使得当 $\\mathrm{Var}(x)$ 改变时畸变更加明显。\n\n数值计算考量：\n- 元动力学积分是一维的，并且由于 $k_x^{\\mathrm{eff}} > 0$ 设定的高斯包络而快速收敛；我们使用高精度的积分容差。\n- 所有计算都在无量纲单位中进行，$\\beta = 1$，不涉及角度。\n\n最终的程序遵循这些步骤处理提供的测试用例，并为每种情况打印包含一对 $[\\Delta(V_{\\mathrm{umb}}), \\Delta(V_{\\mathrm{meta}})]$ 的列表的单行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef frobenius_norm(mat):\n    return np.linalg.norm(mat, 'fro')\n\ndef compute_A_inverse(k_y, k_z, k_yz):\n    A = np.array([[k_y, k_yz],\n                  [k_yz, k_z]], dtype=float)\n    # Ensure positive definiteness for numerical stability\n    # Inverse via numpy\n    A_inv = np.linalg.inv(A)\n    return A, A_inv\n\ndef effective_kx(k_x, b_vec, A_inv):\n    # kx_eff = k_x - b^T A^{-1} b\n    return k_x - float(b_vec.T @ A_inv @ b_vec)\n\ndef sigma_orth(A_inv, b_vec, var_x):\n    # Sigma^V = A^{-1} + A^{-1} b var_x b^T A^{-1}\n    term = A_inv @ np.outer(b_vec, b_vec) @ A_inv\n    return A_inv + var_x * term\n\ndef umbrella_var_x(kx_eff, k_umb):\n    # Analytical variance for quadratic umbrella bias\n    return 1.0 / (kx_eff + k_umb)\n\ndef meta_var_x(kx_eff, hills, centers, width):\n    # Compute Var(x) under metadynamics bias via 1D quadrature\n    # V_meta(x) = sum h_n exp(-(x - s_n)^2 / (2 w^2))\n    def V_meta(x):\n        # Use vectorized-like sum\n        total = 0.0\n        for h, s in zip(hills, centers):\n            dx = x - s\n            total += h * np.exp(-0.5 * (dx * dx) / (width * width))\n        return total\n\n    def weight(x):\n        return np.exp(-0.5 * kx_eff * x * x - V_meta(x))\n\n    # Compute Z = ∫ w(x) dx and M2 = ∫ x^2 w(x) dx\n    # Use high accuracy; integrand decays rapidly due to quadratic term\n    Z, _ = integrate.quad(lambda x: weight(x), -np.inf, np.inf, epsabs=1e-10, epsrel=1e-10, limit=200)\n    M2, _ = integrate.quad(lambda x: x * x * weight(x), -np.inf, np.inf, epsabs=1e-10, epsrel=1e-10, limit=200)\n    return M2 / Z\n\ndef compute_distortions(case):\n    # Unpack parameters\n    (k_x, k_y, k_z, k_yz, k_xy, k_xz,\n     k_umb, x0, N, hills, centers, w) = case\n\n    # Build matrices and vectors\n    A, A_inv = compute_A_inverse(k_y, k_z, k_yz)\n    b = np.array([k_xy, k_xz], dtype=float)\n\n    # Effective stiffness along x\n    kx_eff = effective_kx(k_x, b, A_inv)\n    if kx_eff <= 0:\n        # For robustness, raise an error if parameters are not physically consistent\n        raise ValueError(\"Effective stiffness kx_eff must be positive for normalizable distribution.\")\n\n    # Native variance of x and native orthogonal covariance\n    var_x_native = 1.0 / kx_eff\n    Sigma_native = sigma_orth(A_inv, b, var_x_native)\n\n    # Umbrella variance (independent of x0) and covariance\n    var_x_umb = umbrella_var_x(kx_eff, k_umb)\n    Sigma_umb = sigma_orth(A_inv, b, var_x_umb)\n\n    # Metadynamics variance and covariance\n    # Ensure hills and centers lengths == N\n    hills = list(hills)[:N]\n    centers = list(centers)[:N]\n    var_x_meta = meta_var_x(kx_eff, hills, centers, w)\n    Sigma_meta = sigma_orth(A_inv, b, var_x_meta)\n\n    # Distortions relative to native\n    denom = frobenius_norm(Sigma_native)\n    if denom == 0:\n        # Avoid division by zero if native norm is zero\n        return [frobenius_norm(Sigma_umb), frobenius_norm(Sigma_meta)]\n\n    delta_umb = frobenius_norm(Sigma_umb - Sigma_native) / denom\n    delta_meta = frobenius_norm(Sigma_meta - Sigma_native) / denom\n\n    return [delta_umb, delta_meta]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: happy path\n        (3.0, 2.0, 1.5, 0.2, 0.3, -0.25, 4.0, 0.5, 3, [0.8, 0.6, 0.4], [-0.5, 0.0, 0.5], 0.4),\n        # Case 2: boundary, zero coupling to x\n        (2.2, 1.8, 1.3, 0.3, 0.0, 0.0, 3.0, -0.1, 2, [1.0, 0.5], [-0.2, 0.7], 0.5),\n        # Case 3: edge case, strong orthogonal coupling and moderate x coupling\n        (5.0, 1.5, 1.1, 0.9, 0.7, 0.6, 0.5, -0.2, 4, [2.0, 1.7, 1.3, 0.9], [-1.0, -0.3, 0.3, 1.1], 0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        deltas = compute_distortions(case)\n        results.append(deltas)\n\n    # Final print statement in the exact required format.\n    # Produce a single line of output containing the list of lists.\n    # Ensure no extra text is printed.\n    def format_inner_list(lst):\n        return \"[\" + \",\".join(f\"{x:.10f}\" for x in lst) + \"]\"\n    print(\"[\" + \",\".join(format_inner_list(r) for r in results) + \"]\")\n\nsolve()\n```", "id": "3406465"}]}