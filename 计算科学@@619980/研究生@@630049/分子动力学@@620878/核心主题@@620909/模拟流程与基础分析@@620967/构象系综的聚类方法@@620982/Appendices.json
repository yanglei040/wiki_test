{"hands_on_practices": [{"introduction": "分子构象通常通过二面角来描述，而这些角度具有周期性。本练习 [@problem_id:3401852] 旨在让你直面一个常见的陷阱：将欧几里得统计方法天真地应用于循环数据。通过分析一个简单但极具启发性的例子，你将理解为何标准平均法会失效，并推导出使用环形平均值的原则性方法，这是在拉马钱德兰（Ramachandran）式空间中正确分析构象系综的基石。", "problem": "在分子动力学 (MD) 的构象系综分析中，主链二面角是圆上的元素，这意味着对于任意整数 $k$，任何二面角 $\\theta$ 在物理上都等价于 $\\theta + 2\\pi k$。在一个类Ramachandran空间中，一个构象由一对 $(\\phi, \\psi)$ 描述，其中两个坐标都位于圆的乘积（一个$2$-维环面）上。考虑通过平均为一组构象定义簇中心的目标。仅从二面角以 $2\\pi$ 为周期以及旋转在圆上复合这些基本事实出发，分析实直线上的算术平均是否合适，并推导出一个尊重圆上旋转对称性的、有原则的簇中心构造方法。\n\n给定一个包含3个构象的系综，其二面角对 $(\\phi, \\psi)$ 分别为：\n- $x_1 = (\\pi - 0.1, \\pi - 0.2)$，\n- $x_2 = (-\\pi + 0.1, -\\pi + 0.2)$，\n- $x_3 = (-\\pi, -\\pi)$。\n\n除非另有说明，假设角度在主分支 $(-\\pi, \\pi]$ 内进行数值表示。基于角度周期性和圆对称性的第一性原理，评估欧几里得平均的失效模式，并为$2$-维环面提出一个合适的簇中心定义。然后，将你的推理应用于此数据集以确定簇中心的位置。\n\n以下哪个陈述是正确的？\n\nA. 因为三个 $\\phi$ 值和三个 $\\psi$ 值都对称地排列在分支切割周围，所以在 $(-\\pi, \\pi]$ 中对角度进行欧几里得平均会得到正确的中心；数值上，该中心是 $(\\bar{\\phi}, \\bar{\\psi}) = (-\\pi/3, -\\pi/3)$。\n\nB. 任何角度的平均过程都必须对加上 $2\\pi$ 的整数倍保持不变。一种通过组合圆上的方向然后提取平均方向来尊重这种不变性的构造方法，对于此数据集，得出的簇中心 $(\\bar{\\phi}, \\bar{\\psi})$ 等于 $(\\pi, \\pi)$ 模 $2\\pi$。\n\nC. 在进行欧几里得平均之前将角度重新映射到 $[0, 2\\pi)$，通常可以修复分支切割问题；它能保证为任何角度数据集提供一个与表示无关且正确的中心。\n\nD. 对于类Ramachandran空间上的 $k$-均值聚类，一个有原则的修正是将角度坐标中的欧几里得距离平方替换为每个圆上单位向量的弦距离平方，并通过归一化每个角度坐标中的向量和来更新质心；这会得到一个对旋转等变且在合向量长度非零时良定义的质心。", "solution": "从二面角作为单位圆上一个点的基本表示开始。任何物理角度 $\\theta$ 都是在 $\\theta \\sim \\theta + 2\\pi k$（对于任意整数 $k$）关系下的一个等价类，因此平均过程必须尊重这种商关系。欧几里得平均的失效源于实直线上的算术平均依赖于所选的分支切割，而分支切割是一种没有物理意义的任意表示选择。\n\n圆上圆周平均的基于原理的推导：\n- 圆带有一个自然的旋转概念：如果 $\\theta_i$ 是观测到的角度，并且我们将所有观测值旋转一个角度 $\\alpha$，任何合理的平均值 $\\mu$ 都应该旋转到 $\\mu + \\alpha$。这就是旋转等变性。\n- 获得这样一个估计量的典范方法是：将每个角度 $\\theta_i$ 嵌入为圆上的单位向量 $\\mathbf{u}_i = (\\cos\\theta_i, \\sin\\theta_i)$，在平面中对这些向量求平均得到 $\\mathbf{R} = \\sum_i \\mathbf{u}_i$，然后取 $\\mathbf{R}$ 的辐角作为平均方向：$\\mu = \\operatorname{atan2}(R_y, R_x)$，其中 $(R_x, R_y)$ 是 $\\mathbf{R}$ 的分量。等价地，在复数表示法中，将 $\\theta_i \\mapsto e^{\\mathrm{i}\\theta_i}$ 映射，并设 $\\mu = \\arg\\left(\\sum_i e^{\\mathrm{i}\\theta_i}\\right)$。这种构造在 $\\theta_i \\mapsto \\theta_i + 2\\pi k_i$ 下是不变的，是旋转等变的，并且与典范圆周分布 von Mises 分布下的位置参数的最大似然估计量 (MLE) 相一致。\n- 在一个 $(\\phi, \\psi)$ 的$2$-维环面上，使用乘积度量，圆周平均是解耦的，并且可以通过在每个圆上逐分量地应用上述构造来获得，前提是合向量长度非零，从而方向有定义。\n\n对数据集的定量应用：\n- 计算 $(-\\pi, \\pi]$ 中的欧几里得平均以展示其失效。对于 $\\phi$：\n$$\\bar{\\phi}_{\\text{Euc}} = \\frac{(\\pi - 0.1) + (-\\pi + 0.1) + (-\\pi)}{3} = \\frac{-\\pi}{3} = -\\frac{\\pi}{3}.$$\n对于 $\\psi$：\n$$\\bar{\\psi}_{\\text{Euc}} = \\frac{(\\pi - 0.2) + (-\\pi + 0.2) + (-\\pi)}{3} = \\frac{-\\pi}{3} = -\\frac{\\pi}{3}.$$\n这些值远离分支切割附近的实际密集区域。这种对所选分支 $(-\\pi, \\pi]$ 的依赖性立即显示出表示依赖性。\n\n- 如果我们转而将角度重新映射到 $[0, 2\\pi)$，则数值代表变为，对于 $\\phi$：$\\pi - 0.1$、$\\pi + 0.1$ 和 $\\pi$（因为 $-\\pi \\equiv \\pi$），其欧几里得平均为\n$$\\frac{(\\pi - 0.1) + (\\pi + 0.1) + \\pi}{3} = \\pi.$$\n对于 $\\psi$，类似地：\n$$\\frac{(\\pi - 0.2) + (\\pi + 0.2) + \\pi}{3} = \\pi.$$\n这得出了 $(\\pi, \\pi)$，证明了欧几里得平均依赖于任意的分支切割，因此它不是表示无关的，也不是一个有原则的构造。\n\n- 现在使用向量加法计算圆周平均。对于任何小的 $\\epsilon > 0$，我们有\n$$e^{\\mathrm{i}(\\pi - \\epsilon)} = -\\cos\\epsilon + \\mathrm{i}\\sin\\epsilon,\\quad e^{\\mathrm{i}(-\\pi + \\epsilon)} = -\\cos\\epsilon - \\mathrm{i}\\sin\\epsilon,\\quad e^{\\mathrm{i}(-\\pi)} = -1.$$\n因此，对于 $\\phi$ 且 $\\epsilon = 0.1$，\n$$\\sum_{j=1}^{3} e^{\\mathrm{i}\\phi_j} = \\left(-\\cos 0.1 + \\mathrm{i}\\sin 0.1\\right) + \\left(-\\cos 0.1 - \\mathrm{i}\\sin 0.1\\right) + (-1) = -2\\cos 0.1 - 1.$$\n虚部相消，留下一个负实数；因此平均方向是\n$$\\bar{\\phi}_{\\text{circ}} = \\arg\\left(\\sum_{j=1}^{3} e^{\\mathrm{i}\\phi_j}\\right) = \\pi \\quad \\text{mod } 2\\pi.$$\n对于 $\\psi$ 且 $\\epsilon = 0.2$，发生同样的相消，得到\n$$\\bar{\\psi}_{\\text{circ}} = \\pi \\quad \\text{mod } 2\\pi.$$\n因此，圆周平均簇中心是 $(\\bar{\\phi}, \\bar{\\psi}) = (\\pi, \\pi)$ 模 $2\\pi$，这与输入数值如何包装无关。\n\n扩展到$2$-维环面上的聚类更新：\n- 在 $k$-均值算法中，质心使得到达已分配点的距离平方和最小化。在圆上，与旋转对称性一致的一个自然距离平方是单位向量之间的弦距离平方，对于两个角度 $\\theta$ 和 $\\mu$ 来说，它是\n$$d^2_{\\text{chord}}(\\theta, \\mu) = \\left\\|\\begin{pmatrix}\\cos\\theta \\\\ \\sin\\theta\\end{pmatrix} - \\begin{pmatrix}\\cos\\mu \\\\ \\sin\\mu\\end{pmatrix}\\right\\|^2 = 2 - 2\\cos(\\theta - \\mu).$$\n最小化 $\\sum_i d^2_{\\text{chord}}(\\theta_i, \\mu)$ 等价于最大化 $\\sum_i \\cos(\\theta_i - \\mu)$，当合向量长度非零时，其最大化者正是 $\\mu = \\arg\\left(\\sum_i e^{\\mathrm{i}\\theta_i}\\right)$。在具有乘积度量的$2$-维环面上，质心更新是通过将此方法逐分量地应用于 $\\phi$ 和 $\\psi$ 来获得的。这个质心在旋转下是等变的，并且与角度分支的选择无关。\n\n逐选项分析：\n- 选项 A：它断言在 $(-\\pi, \\pi]$ 中的欧几里得平均是正确的。我们计算出该分支上的欧几里得平均为 $\\left(-\\frac{\\pi}{3}, -\\frac{\\pi}{3}\\right)$，这远离 $(\\pi, \\pi)$ 附近的密集区域，并且关键的是，如果选择不同的分支，该值会改变。这违反了圆上所需的不变性；因此，声称它是正确的中心是错误的。结论：错误。\n\n- 选项 B：它陈述了不变性要求（加上 $2\\pi$ 的整数倍不改变物理性质），并提出一种基于组合圆上方向的平均构造，对于此数据集，它得到 $(\\pi, \\pi)$ 模 $2\\pi$。这与基于原理的推导和显式计算相匹配。结论：正确。\n\n- 选项 C：它声称将角度重新映射到 $[0, 2\\pi)$ 然后进行欧几里得平均可以普遍解决问题。虽然对于这个数据集，$[0, 2\\pi)$ 的欧几里得平均恰好等于 $(\\pi, \\pi)$，但结果依赖于所选的分支切割，并且在重新映射下可能改变。如前所示，对于相同的物理数据，$(-\\pi, \\pi]$ 的欧几里得平均给出 $\\left(-\\frac{\\pi}{3}, -\\frac{\\pi}{3}\\right)$，而 $[0, 2\\pi)$ 的欧几里得平均给出 $(\\pi, \\pi)$。因此，这种方法不是表示无关的，并且不能普遍解决问题。结论：错误。\n\n- 选项 D：它提出了一个在$2$-维环面上有原则的 $k$-均值修改，使用弦距离平方和通过归一化每个坐标的向量和来进行质心更新。这源于最小化弦距离平方和，并在合向量长度非零时产生圆周平均方向。它是旋转等变的并尊重周期性。结论：正确。", "answer": "$$\\boxed{BD}$$", "id": "3401852"}, {"introduction": "在掌握了环形统计学的概念之后，本次实践 [@problem_id:3401829] 将从理论走向实现。你将设计并编写一个复合距离度量，它巧妙地结合了笛卡尔坐标（通过RMSD）和周期性的二面角。这项动手任务将展示如何创建一个更具物理意义的构象相似性度量，并让你直接观察到一个能够感知周期性的度量，在对接近任意设定的 $-\\pi/\\pi$ 边界的结构进行聚类时所带来的优势。", "problem": "设计并实现一种用于比较分子构象的复合距离，该距离通过将二面角映射到单位圆上，融合了笛卡尔坐标均方根偏差 (RMSD) 与扭转周期性。目标是探究当角度跨越 $-\\pi/\\pi$ 边界时聚类的敏感性。请完全采用可在任何编程语言中实现的纯数学规范进行描述。\n\n定义和要求：\n- 每个构象由一组 $M$ 个三维笛卡尔坐标（单位为埃）和一个包含 $K$ 个扭转角（单位为弧度）的向量指定。角度必须以弧度处理。\n- 两个坐标集之间的均方根偏差 (RMSD) 必须在最佳刚体疊加（无反射）后计算，该疊加通过最小化欧几里得平方距离之和的正交旋转获得。这是使用奇异值分解 (SVD) 的经典 Kabsch 对齐方法，然后通过平移对齐质心。\n- 为处理扭转周期性，通过 $\\phi(\\theta) = (\\cos \\theta, \\sin \\theta) \\in \\mathbb{R}^2$ 将每个扭转角 $\\theta \\in \\mathbb{R}$ 映射到单位圆上。对于扭转角向量 $\\boldsymbol{\\theta} \\in \\mathbb{R}^K$，将其嵌入定义为 $\\Phi(\\boldsymbol{\\theta}) = (\\cos \\theta_1, \\sin \\theta_1, \\ldots, \\cos \\theta_K, \\sin \\theta_K) \\in \\mathbb{R}^{2K}$。\n- 定义两个扭转角向量 $\\boldsymbol{\\theta}^{(A)}$ 和 $\\boldsymbol{\\theta}^{(B)}$ 之间的循环扭转距离为欧几里得范数 $\\left\\|\\Phi(\\boldsymbol{\\theta}^{(A)}) - \\Phi(\\boldsymbol{\\theta}^{(B)})\\right\\|_2$，该距离对于在 $-\\pi/\\pi$ 边界处的环绕是不变的。\n- 定义朴素线性扭转距离为 $\\left\\|\\boldsymbol{\\theta}^{(A)} - \\boldsymbol{\\theta}^{(B)}\\right\\|_2$（无模环绕）。\n- 定义构象 $A$ 和 $B$ 之间的复合循环距离为\n$$\nd_{\\mathrm{circ}}(A,B) = \\sqrt{\\alpha \\cdot \\mathrm{RMSD}(A,B)^2 + \\beta \\cdot \\left\\|\\Phi(\\boldsymbol{\\theta}^{(A)}) - \\Phi(\\boldsymbol{\\theta}^{(B)})\\right\\|_2^2},\n$$\n以及复合线性角度距离为\n$$\nd_{\\mathrm{lin}}(A,B) = \\sqrt{\\alpha \\cdot \\mathrm{RMSD}(A,B)^2 + \\beta \\cdot \\left\\|\\boldsymbol{\\theta}^{(A)} - \\boldsymbol{\\theta}^{(B)}\\right\\|_2^2}.\n$$\n此处 $\\alpha$ 和 $\\beta$ 为非负权重。\n\n聚类规则 (带阈值的单链接)：\n- 给定一组构象、一个距离函数 $d(\\cdot,\\cdot)$ 和一个阈值 $\\tau \\ge 0$，在构象上构建一个无向图，其中节点 $i$ 和 $j$ 之间存在边的充要条件是 $d(i,j) \\le \\tau$。簇是该图的连通分量。\n- 对于一个包含 $N$ 个构象的有序集合，其簇标签必须是一个包含 $N$ 个整数的列表，其中标签按首次出现的顺序分配，并从 $0$ 开始；也就是说，第一个构象获得标签 $0$，后续每个构象获得其已标记的连通分量成员中尚未使用过的最小非负整数。\n\n数据集 (所有测试共享)：\n- 每个构象的原子数：$M = 4$。\n- 每个构象的扭转角数：$K = 2$。\n- 六个构象，索引为 $0$ 到 $5$。对每个构象，笛卡尔坐标（单位为埃）以 $4 \\times 3$ 数组形式列出，扭转角（单位为弧度）以$2$-维向量形式列出。\n\n构象 $0$:\n- 坐标:\n  $[ [\\,0.00,\\, 0.00,\\, 0.00\\,], [\\,1.54,\\, 0.00,\\, 0.00\\,], [\\,3.08,\\, 0.10,\\, 0.00\\,], [\\,4.62,\\, 0.10,\\, 0.05\\,] ]$\n- 扭转角:\n  $[\\,3.091592653589793,\\, 0.30\\,]$.\n\n构象 $1$:\n- 坐标:\n  $[ [\\,0.00,\\, 0.00,\\, 0.00\\,], [\\,1.54,\\, 0.01,\\, 0.00\\,], [\\,3.08,\\, 0.08,\\, 0.00\\,], [\\,4.62,\\, 0.12,\\, 0.05\\,] ]$\n- 扭转角:\n  $[\\, -3.101592653589793,\\, 0.31\\,]$.\n\n构象 $2$:\n- 坐标:\n  $[ [\\,0.00,\\, 0.00,\\, 0.00\\,], [\\,1.54,\\, -0.01,\\, 0.00\\,], [\\,3.08,\\, 0.11,\\, 0.00\\,], [\\,4.62,\\, 0.09,\\, 0.05\\,] ]$\n- 扭转角:\n  $[\\,3.081592653589793,\\, 0.29\\,]$.\n\n构象 $3$:\n- 坐标:\n  $[ [\\,0.00,\\, 0.00,\\, 0.00\\,], [\\,1.54,\\, 0.05,\\, 0.00\\,], [\\,3.08,\\, 0.25,\\, 0.05\\,], [\\,4.62,\\, 0.35,\\, 0.10\\,] ]$\n- 扭转角:\n  $[\\,1.20,\\, -2.00\\,]$.\n\n构象 $4$:\n- 坐标:\n  $[ [\\,0.00,\\, 0.00,\\, 0.00\\,], [\\,1.54,\\, 0.06,\\, 0.00\\,], [\\,3.08,\\, 0.26,\\, 0.04\\,], [\\,4.62,\\, 0.36,\\, 0.12\\,] ]$\n- 扭转角:\n  $[\\,1.22,\\, -2.02\\,]$.\n\n构象 $5$ (与构象 $4$ 相同):\n- 坐标:\n  $[ [\\,0.00,\\, 0.00,\\, 0.00\\,], [\\,1.54,\\, 0.06,\\, 0.00\\,], [\\,3.08,\\, 0.26,\\, 0.04\\,], [\\,4.62,\\, 0.36,\\, 0.12\\,] ]$\n- 扭转角:\n  $[\\,1.22,\\, -2.02\\,]$.\n\n测试套件：\n- 测试 $1$ (正常路径，循环度量下两个清晰分离的簇):\n  - 子集索引: $[\\,0,\\,1,\\,2,\\,3,\\,4\\,]$。\n  - 权重: $\\alpha = 1.0$, $\\beta = 1.0$。\n  - 阈值: $\\tau = 1.0$。\n  - 距离: $d_{\\mathrm{circ}}$。\n  - 输出: 簇的整数数量。\n\n- 测试 $2$ ($-\\pi/\\pi$ 边界敏感性):\n  - 子集索引: $[\\,0,\\,1\\,]$。\n  - 权重: $\\alpha = 1.0$, $\\beta = 1.0$。\n  - 阈值: $\\tau = 0.3$。\n  - 距离: 比较 $d_{\\mathrm{lin}}$ 和 $d_{\\mathrm{circ}}$。\n  - 输出: 簇数量的整数差，定义为 $\\text{clusters}_{\\mathrm{lin}} - \\text{clusters}_{\\mathrm{circ}}$。\n\n- 测试 $3$ (退化重复项):\n  - 子集索引: $[\\,4,\\,5\\,]$。\n  - 权重: $\\alpha = 1.0$, $\\beta = 1.0$。\n  - 阈值: $\\tau = 10^{-12}$。\n  - 距离: $d_{\\mathrm{lin}}$ 或 $d_{\\mathrm{circ}}$ 均可 (对于相同构象，两者一致)。\n  - 输出: 簇的整数数量。\n\n- 测试 $4$ (循环度量下的权重敏感性):\n  - 子集索引: $[\\,0,\\,2,\\,3\\,]$。\n  - 阈值: $\\tau = 0.3$。\n  - 距离: 使用两种权重的 $d_{\\mathrm{circ}}$：\n    - 情况 A: $\\alpha = 1.0$, $\\beta = 1.0$。\n    - 情况 B: $\\alpha = 1.0$, $\\beta = 0.0$。\n  - 输出: 一个布尔值，指示情况 A 和情况 B 的簇标签是否相同 (若相同则为 True，否则为 False)。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试 $1$ 到 $4$ 的结果，格式为一个逗号分隔的 Python 风格列表，例如 $[\\,r_1, r_2, r_3, r_4\\,]$，其中 $r_1$ 和 $r_3$ 是整数，$r_2$ 是整数，$r_4$ 是布尔值。输出行中此列表前后不得有任何附加文本。", "solution": "用户提供了一个问题，要求设计和实现一种用于分子构象的复合距离度量以及后续的聚类算法。在尝试给出解决方案之前，需要对该问题的科学合理性、适定性和客观性进行验证。\n\n### 第一步：提取已知信息\n- **构象表示**: 每个构象由 $M$ 个 $\\mathbb{R}^3$ 中的笛卡尔坐标和 $K$ 个 $\\mathbb{R}$ 中的扭转角组成。\n- **均方根偏差 (RMSD)**: 使用 Kabsch 算法（基于 SVD，处理反射）进行最佳刚体疊加后计算。\n- **扭转角映射**: 角度 $\\theta$ 被映射到单位圆上，记为 $\\phi(\\theta) = (\\cos \\theta, \\sin \\theta) \\in \\mathbb{R}^2$。$K$ 个角度的向量 $\\boldsymbol{\\theta}$ 被映射为 $\\Phi(\\boldsymbol{\\theta}) \\in \\mathbb{R}^{2K}$。\n- **距离度量**:\n    - **循环扭转距离**: $d_{\\mathrm{tors,circ}}(\\boldsymbol{\\theta}^{(A)}, \\boldsymbol{\\theta}^{(B)}) = \\left\\|\\Phi(\\boldsymbol{\\theta}^{(A)}) - \\Phi(\\boldsymbol{\\theta}^{(B)})\\right\\|_2$。\n    - **线性扭转距离**: $d_{\\mathrm{tors,lin}}(\\boldsymbol{\\theta}^{(A)}, \\boldsymbol{\\theta}^{(B)}) = \\left\\|\\boldsymbol{\\theta}^{(A)} - \\boldsymbol{\\theta}^{(B)}\\right\\|_2$。\n    - **复合循环距离**: $d_{\\mathrm{circ}}(A,B) = \\sqrt{\\alpha \\cdot \\mathrm{RMSD}(A,B)^2 + \\beta \\cdot d_{\\mathrm{tors,circ}}(\\boldsymbol{\\theta}^{(A)}, \\boldsymbol{\\theta}^{(B)})^2}$。\n    - **复合线性角度距离**: $d_{\\mathrm{lin}}(A,B) = \\sqrt{\\alpha \\cdot \\mathrm{RMSD}(A,B)^2 + \\beta \\cdot d_{\\mathrm{tors,lin}}(\\boldsymbol{\\theta}^{(A)}, \\boldsymbol{\\theta}^{(B)})^2}$。\n- **聚类规则**:\n    - 构建一个图，节点为构象，如果构象 $i$ 和 $j$ 之间的距离 $d(i,j) \\le \\tau$（其中 $\\tau$ 是给定阈值），则它们之间存在一条边。\n    - 簇是该图的连通分量。\n    - 标签分配：对于一个有序的构象集合，标签是从 $0$ 开始的整数。构象的标签由其所在连通分量在有序遍历构象过程中首次遇到的标签决定。\n- **数据集**: $M=4$, $K=2$。提供了六个构象（索引为 0 到 5）的笛卡尔坐标和扭转角。构象 4 和 5 相同。\n- **测试套件**: 定义了四个具体测试，每个测试都指定了构象子集、参数（$\\alpha, \\beta, \\tau$）、使用的距离度量以及需要计算的特定输出（簇的数量、簇数量的差异或标签的布尔比较）。\n\n### 第二步：使用提取的已知信息进行验证\n1.  **科学依据**：该问题在计算生物物理学和结构生物学中有充分的理论基础。RMSD、Kabsch 算法、扭转角和聚类都是标准概念。对周期性数据（角度）使用循环度量是一种常用且有效的技术。该问题具有科学合理性。\n2.  **适定性**：该问题提供了所有必要的定义、数据和参数。距离公式是明确的。基于阈值距离图寻找连通分量的聚类算法是一个定义明确的过程。标签分配规则虽然措辞稍显复杂，但对应一个标准的确定性算法：找到连通分量，然后按照遍历输入构象时首次遇到这些分量的顺序为它们分配标签。这确保了每个测试用例都有唯一的解。该问题是适定的。\n3.  **客观性**：语言精确且数学化。所有要求都以形式化方式陈述，没有歧义或主观元素。该问题是客观的。\n4.  **完整性与一致性**：问题是自洽的。所有数据和常量均已提供。不存在矛盾。构象 4 和 5 相同是测试 3 的特意设计，并非错误。\n5.  **可行性**：指定的计算（SVD、矩阵运算、图分量分析）在计算上是可行的，并且是科学计算库中的标准功能。数据值对于分子结构是realistic的。\n\n### 第三步：结论与行动\n该问题是有效的。它是一个基于既定科学原理、表述清晰的计算任务。我将继续提供解决方案。\n\n### 基于原则的解决方案设计\n该解决方案的结构是围绕创建一系列封装问题中定义的核心概念的函数，然后由一个主程序执行指定的测试。\n\n1.  **RMSD 计算 (`calculate_rmsd`)**: 此函数实现用于最佳分子疊加的 Kabsch 算法。\n    - **输入**: 两个点集 $P$ 和 $Q$，作为 $M \\times 3$ 的 NumPy 数组。\n    - **原则**: 目标是找到一个旋转矩阵 $R$ 和平移向量 $t$，以最小化均方根偏差，$\\mathrm{RMSD}(P, Q) = \\min_{R,t} \\sqrt{\\frac{1}{M}\\sum_{i=1}^M \\| (R P_i + t) - Q_i \\|^2}$。\n    - **算法**:\n        1.  最佳平移使两个点集的质心对齐。我们首先平移 $P$ 和 $Q$，使其质心位于原点：$P' = P - \\bar{P}$，$Q' = Q - \\bar{Q}$。\n        2.  最佳旋转是通过最大化 $R^T C$ 的迹来找到的，其中 $C = P'^T Q'$ 是协方差矩阵。这个最大化问题通过对 $C$ 进行奇异值分解 (SVD) 来解决。\n        3.  令 $C = U S V^T$。最佳旋转矩阵为 $R = V U^T$。\n        4.  如果 $\\det(R)  0$，则会出现特殊情况，这对应于一个反射（非正常旋转）。为确保是正常旋转（$\\det(R)=+1$），我们必须校正 $R$。这通过在计算 $R$ 之前，将 $V$ 中对应于最小奇异值的列的符号反转来完成。\n        5.  找到 $R$ 后，我们将其应用于 $P$ 的中心化坐标，即 $P'' = P' R$。\n        6.  然后，RMSD 计算为变换后的点 $P''$ 和中心化点 $Q'$ 之间的欧几里得距离，在所有点上取平均值：$\\mathrm{RMSD} = \\sqrt{\\frac{1}{M} \\sum_{i=1}^M \\| P''_i - Q'_i \\|^2}$。\n\n2.  **距离度量 (`calculate_composite_distance`)**: 此函数根据所选的度量类型计算两个构象之间的复合距离。\n    - **输入**: 两个构象（每个都包含坐标和扭转角）、权重 $\\alpha$ 和 $\\beta$，以及一个指示是使用循环还是线性扭转距离的标志。\n    - **原则**: 它将笛卡尔坐标和内坐标距离组合成一个单一的度量。循环度量正确处理了扭转角 $2\\pi$ 的周期性。\n    - **算法**:\n        1.  使用 `calculate_rmsd` 函数计算 $\\mathrm{RMSD}(A,B)$。\n        2.  计算扭转距离项。对于线性距离，它是扭转角向量之差的 $L^2$-范数。对于循环距离，它首先将每个扭转角向量 $\\boldsymbol{\\theta}$ 映射到其在单位圆上的 $2K$-维表示 $\\Phi(\\boldsymbol{\\theta})$，然后计算这些表示之差的 $L^2$-范数。\n        3.  根据 $d_{\\mathrm{circ}}$ 或 $d_{\\mathrm{lin}}$ 的公式，使用权重 $\\alpha$ 和 $\\beta$ 组合平方 RMSD 和平方扭转距离。\n\n3.  **聚类 (`perform_clustering`)**: 此函数实现指定的带阈值的单链接聚类。\n    - **输入**: 一个构象列表、一个距离函数、一个阈值 $\\tau$ 以及距离函数的任何参数（例如 $\\alpha, \\beta$）。\n    - **原则**: 聚类将相似的对象分组。在这里，“相似性”被定义为两个构象之间的距离小于或等于阈值 $\\tau$。这定义了一个图，簇就是其连通分量。\n    - **算法**:\n        1.  为给定的构象子集计算一个 $N \\times N$ 的成对距离矩阵。\n        2.  构建一个邻接矩阵，如果构象 $i$ 和 $j$ 之间的距离 $\\le \\tau$，则条目 $(i,j)$ 为 $1$，否则为 $0$。\n        3.  使用 `scipy.sparse.csgraph.connected_components` 函数找到由邻接矩阵表示的图的连通分量。此函数返回分量数和每个构象的原始整数标签数组。\n        4.  为了满足问题中的标签规则（“首次出现顺序”），需要重新映射这些原始标签。我们按构象的原始输入顺序进行迭代。当第一次遇到一个原始分量标签时，为其分配下一个可用的最终标签（从 $0$ 开始）。然后使用此映射生成最终的标签列表。\n\n4.  **主执行逻辑 (`solve`)**: 此函数设置数据并协调执行问题描述中的四个测试，以指定的格式打印结果。它使用每个测试的适当参数调用辅助函数。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import connected_components\n\ndef calculate_rmsd(coords_p, coords_q):\n    \"\"\"\n    Calculates the Root Mean Square Deviation (RMSD) between two sets of\n    3D coordinates (P and Q) after optimal rigid-body superposition.\n    \"\"\"\n    # Number of atoms must be the same\n    if coords_p.shape[0] != coords_q.shape[0]:\n        raise ValueError(\"Coordinate sets must have the same number of atoms.\")\n\n    # 1. Center coordinates by subtracting their centroids\n    p_centroid = coords_p.mean(axis=0)\n    q_centroid = coords_q.mean(axis=0)\n    p_centered = coords_p - p_centroid\n    q_centered = coords_q - q_centroid\n\n    # 2. Compute the covariance matrix\n    cov_matrix = p_centered.T @ q_centered\n\n    # 3. Compute the SVD of the covariance matrix\n    U, S, Vt = np.linalg.svd(cov_matrix)\n\n    # 4. Determine the optimal rotation matrix, correcting for reflections\n    # The determinant of Vt.T @ U.T can be -1 (reflection).\n    # If so, we must invert the sign of the last column of V (or last row of Vt)\n    # to ensure a proper rotation.\n    det_check = np.linalg.det(Vt.T @ U.T)\n    if det_check  0:\n        Vt[-1, :] *= -1\n\n    R = Vt.T @ U.T\n\n    # 5. Apply the rotation to the centered coordinates of P\n    p_rotated = p_centered @ R\n\n    # 6. Calculate the squared differences and the RMSD\n    diff = p_rotated - q_centered\n    rmsd_sq = np.sum(diff * diff) / coords_p.shape[0]\n    return np.sqrt(rmsd_sq)\n\ndef calculate_composite_distance(conf_a, conf_b, alpha, beta, use_circular_torsion):\n    \"\"\"\n    Calculates the composite distance between two conformations A and B.\n    \"\"\"\n    rmsd_val = calculate_rmsd(conf_a['coords'], conf_b['coords'])\n    \n    if use_circular_torsion:\n        # Map torsions to the unit circle\n        phi_a = np.empty(2 * len(conf_a['torsions']))\n        phi_a[0::2] = np.cos(conf_a['torsions'])\n        phi_a[1::2] = np.sin(conf_a['torsions'])\n        \n        phi_b = np.empty(2 * len(conf_b['torsions']))\n        phi_b[0::2] = np.cos(conf_b['torsions'])\n        phi_b[1::2] = np.sin(conf_b['torsions'])\n        \n        torsion_dist_sq = np.sum((phi_a - phi_b)**2)\n    else:\n        torsion_dist_sq = np.sum((conf_a['torsions'] - conf_b['torsions'])**2)\n        \n    composite_dist_sq = alpha * (rmsd_val**2) + beta * torsion_dist_sq\n    return np.sqrt(composite_dist_sq)\n\ndef perform_clustering(subset_indices, conformations, alpha, beta, tau, use_circular_torsion):\n    \"\"\"\n    Performs single-linkage clustering with a threshold and returns the\n    number of clusters and the final labels.\n    \"\"\"\n    num_confs = len(subset_indices)\n    if num_confs == 0:\n        return 0, []\n\n    dist_matrix = np.zeros((num_confs, num_confs))\n    \n    for i in range(num_confs):\n        for j in range(i + 1, num_confs):\n            conf_i = conformations[subset_indices[i]]\n            conf_j = conformations[subset_indices[j]]\n            dist = calculate_composite_distance(conf_i, conf_j, alpha, beta, use_circular_torsion)\n            dist_matrix[i, j] = dist_matrix[j, i] = dist\n            \n    # Build adjacency matrix based on the threshold\n    adjacency_matrix = dist_matrix = tau\n    \n    # Find connected components, which are the clusters\n    graph = csr_matrix(adjacency_matrix)\n    n_components, raw_labels = connected_components(csgraph=graph, directed=False, return_labels=True)\n    \n    # Re-label according to the \"first appearance\" rule\n    final_labels = -np.ones(num_confs, dtype=int)\n    label_map = {}\n    next_label = 0\n    for i in range(num_confs):\n        raw_label = raw_labels[i]\n        if raw_label not in label_map:\n            label_map[raw_label] = next_label\n            next_label += 1\n        final_labels[i] = label_map[raw_label]\n        \n    return n_components, final_labels.tolist()\n\ndef solve():\n    \"\"\"\n    Main function to define data, run tests, and print results.\n    \"\"\"\n    conformations_data = {\n        0: {'coords': np.array([[0.00, 0.00, 0.00], [1.54, 0.00, 0.00], [3.08, 0.10, 0.00], [4.62, 0.10, 0.05]]),\n            'torsions': np.array([3.091592653589793, 0.30])},\n        1: {'coords': np.array([[0.00, 0.00, 0.00], [1.54, 0.01, 0.00], [3.08, 0.08, 0.00], [4.62, 0.12, 0.05]]),\n            'torsions': np.array([-3.101592653589793, 0.31])},\n        2: {'coords': np.array([[0.00, 0.00, 0.00], [1.54, -0.01, 0.00], [3.08, 0.11, 0.00], [4.62, 0.09, 0.05]]),\n            'torsions': np.array([3.081592653589793, 0.29])},\n        3: {'coords': np.array([[0.00, 0.00, 0.00], [1.54, 0.05, 0.00], [3.08, 0.25, 0.05], [4.62, 0.35, 0.10]]),\n            'torsions': np.array([1.20, -2.00])},\n        4: {'coords': np.array([[0.00, 0.00, 0.00], [1.54, 0.06, 0.00], [3.08, 0.26, 0.04], [4.62, 0.36, 0.12]]),\n            'torsions': np.array([1.22, -2.02])},\n        5: {'coords': np.array([[0.00, 0.00, 0.00], [1.54, 0.06, 0.00], [3.08, 0.26, 0.04], [4.62, 0.36, 0.12]]),\n            'torsions': np.array([1.22, -2.02])},\n    }\n\n    # Test 1\n    subset1 = [0, 1, 2, 3, 4]\n    alpha1, beta1, tau1 = 1.0, 1.0, 1.0\n    num_clusters1, _ = perform_clustering(subset1, conformations_data, alpha1, beta1, tau1, use_circular_torsion=True)\n    result1 = num_clusters1\n\n    # Test 2\n    subset2 = [0, 1]\n    alpha2, beta2, tau2 = 1.0, 1.0, 0.3\n    num_clusters_lin, _ = perform_clustering(subset2, conformations_data, alpha2, beta2, tau2, use_circular_torsion=False)\n    num_clusters_circ, _ = perform_clustering(subset2, conformations_data, alpha2, beta2, tau2, use_circular_torsion=True)\n    result2 = num_clusters_lin - num_clusters_circ\n\n    # Test 3\n    subset3 = [4, 5]\n    alpha3, beta3, tau3 = 1.0, 1.0, 1e-12\n    # Distance function doesn't matter since conformations are identical (dist=0)\n    num_clusters3, _ = perform_clustering(subset3, conformations_data, alpha3, beta3, tau3, use_circular_torsion=True)\n    result3 = num_clusters3\n\n    # Test 4\n    subset4 = [0, 2, 3]\n    tau4 = 0.3\n    # Case A\n    alpha4a, beta4a = 1.0, 1.0\n    _, labels_A = perform_clustering(subset4, conformations_data, alpha4a, beta4a, tau4, use_circular_torsion=True)\n    # Case B\n    alpha4b, beta4b = 1.0, 0.0\n    _, labels_B = perform_clustering(subset4, conformations_data, alpha4b, beta4b, tau4, use_circular_torsion=True)\n    result4 = labels_A == labels_B\n    \n    results = [result1, result2, result3, result4]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3401829"}, {"introduction": "当我们拥有了一个稳健的距离度量后，下一个挑战是如何将聚类方法应用于现代分子动力学模拟产生的海量数据集。本练习 [@problem_id:3401895] 模拟了一个真实的计算场景，你必须根据内存限制和数据集大小选择最高效的聚类策略。通过分析不同 $k$-中心点（k-medoids）算法的计算和内存成本，你将培养进行大规模数据分析所需的关键技能——算法决策能力。", "problem": "您将处理一个来自分子动力学（MD）分析的场景，其中蛋白质结构的构象系综由一个逐对的均方根偏差（RMSD）矩阵表示。您的目标是设计并分析一个计算流程，使用$k$-中心点算法将这些结构聚类成构象状态。该矩阵对应于$N$个快照（结构），任务是为$N=10000$的情况提供一个计算上高效的方法，其中要包括算法复杂度分析和内存考量。均方根偏差（RMSD）是结构之间的一种度量距离，$k$-中心点目标是最小化每个点到其最近中心点的距离之和。您不需要计算RMSD值；相反，您必须在一个标准化的计数模型下，对距离矩阵查找和基本算术运算进行计数。\n\n基本基础和定义：\n- $k$-中心点目标是选择一个包含$k$个索引的集合$M$，以最小化到最近中心点的距离之和，即对于度量$d(\\cdot,\\cdot)$，最小化$\\sum_{i=1}^{N} \\min_{m \\in M} d(i,m)$。\n- 您将获得一个预先计算好的逐对RMSD矩阵，因此对任意一对结构使用该矩阵被视为常数时间查找。运算计数如下：\n  1. 一次距离查找等于从内存中访问一次$d(i,j)$。\n  2. 一次基本加法等于将两个标量值相加一次。\n- 经典的围绕中心点划分（PAM）方法有一个用于选择初始中心点的BUILD步骤和一个用于优化它们的SWAP步骤；现代加速方法通过使用缓存的最近和次近中心点距离进行多重交换评估，将每轮迭代的主要成本降低到$N^{2}$数量级。\n- 一个完整的对称矩阵可以以大小为$N(N-1)/2$个条目的压缩布局存储。如果元素大小为$b$字节，则压缩矩阵使用$b \\cdot N(N-1)/2$字节。用于存储最近和次近距离以及当前分配的辅助数组的规模为$\\mathcal{O}(N)$，并在下面明确计数。\n- 子采样（如在大型应用聚类 CLARA 中）在大小为$s \\ll N$的样本上评估PAM，重复$r$次，然后将所有$N$个点分配给找到的最佳中心点。\n- 基于地标的初始化使用$L$个地标结构和$N \\cdot L$个预计算的地标距离来设定中心点种子，然后对完整数据集进行少量优化迭代。\n\n您的程序中要使用的计数和内存模型：\n- 对于采用多重交换$k$-中心点优化（一次“类FastPAM”迭代）的完整压缩距离矩阵方法：\n  - 每次迭代的距离查找次数：$N \\cdot k + N \\cdot (N - k)$，其中第二项计为使用缓存的最近和次近距离，将所有非中心点作为候选对象进行一次扫描。\n  - 每次迭代的加法次数：等于距离查找次数（假设在更新目标增量时每次查找对应一次加法）。\n  - 在$t$次迭代中的总计：乘以$t$。\n  - 内存（字节）：$b \\cdot \\left( \\frac{N(N-1)}{2} + 3N \\right) + 8k$。$3N$表示两个缓存的距离数组和一个分配数组；中心点索引计为$8k$字节。\n- 对于样本大小为$s$且重启$r$次的类CLARA子采样方法：\n  - 在样本上每次迭代的距离查找次数：$s \\cdot k + s \\cdot (s - k)$。\n  - 样本总查找次数：$r \\cdot t \\cdot \\left( s \\cdot k + s \\cdot (s - k) \\right)$。\n  - 每次运行的完整数据评估加上最终分配：$r \\cdot (N \\cdot k) + (N \\cdot k)$次查找。\n  - 加法次数：等于总查找次数。\n  - 内存（字节）：$b \\cdot \\left( \\frac{s(s-1)}{2} + 3s \\right) + 8k$（存储样本压缩矩阵和$\\mathcal{O}(s)$缓存；完整数据评估是流式的，不存储$\\mathcal{O}(N)$数组）。\n- 对于通过流式处理上三角矩阵来精确求解$k=1$中心点的方法：\n  - 距离查找次数：$\\frac{N(N-1)}{2}$（每对一次）。\n  - 加法次数：$N(N-1)$（每对两次加法，用于对称地累加两个行和）。\n  - 内存（字节）：$b \\cdot N$（用于存储运行中的行和）$+ 8$（用于存储最佳中心点的索引）。\n- 对于使用$L$个地标和$t_{\\mathrm{refine}}$次类FastPAM优化迭代的基于地标的初始化方法：\n  - 地标距离查找次数：$N \\cdot L$。\n  - 优化查找次数：$t_{\\mathrm{refine}} \\cdot \\left( N \\cdot k + N \\cdot (N - k) \\right)$。\n  - 最终分配查找次数：$N \\cdot k$。\n  - 加法次数：等于总查找次数。\n  - 内存（字节）：$b \\cdot \\left( N \\cdot L + 3N \\right) + 8k$。\n\n要实现的流程选择规则：\n- 如果$k=1$，选择精确流式$k=1$中心点流程。\n- 否则，如果带有缓存的完整压缩矩阵能装入内存（字节 $\\leq B$），选择完整的类FastPAM流程。\n- 否则，如果具有给定$L$的地标方案能装入内存（字节 $\\leq B$），选择具有指定$t_{\\mathrm{refine}}$的基于地标的初始化流程。\n- 否则，选择具有给定$s$和$r$的CLARA子采样流程。\n\n您的任务：\n- 实现一个程序，对于每个测试用例，根据选择规则确定所选的流程，计算完整压缩矩阵在预算内是否可行，计算所选流程使用的内存（以字节为单位），并根据上述计数模型计算距离查找和加法的总次数。\n\n角度单位不适用。物理单位不适用。所有内存必须以字节为单位报告。所有计数必须是整数。\n\n测试套件：\n- 案例 1：$N = 10000$，$k = 20$，$t = 5$，$b = 4$，$B = 250000000$。\n- 案例 2：$N = 10000$，$k = 100$，$t = 5$，$b = 8$，$B = 300000000$，CLARA参数：$s = 2000$，$r = 5$。\n- 案例 3：$N = 10000$，$k = 1$，$t = 3$，$b = 4$，$B = 50000000$。\n- 案例 4：$N = 10000$，$k = 50$，$t = 4$，$b = 4$，$B = 180000000$，地标参数：$L = 100$，$t_{\\mathrm{refine}} = 1$。\n\n输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个元素按上述顺序对应一个测试用例。每个测试用例结果本身必须是一个包含五个整数的列表：\n  1. 完整压缩矩阵在预算内的可行性，表示为$0$或$1$。\n  2. 所选流程的标识符：$0$代表完整的类FastPAM流程，$1$代表CLARA子采样，$2$代表精确$k=1$流式处理，$3$代表带优化的基于地标的初始化。\n  3. 所选流程使用的内存（以字节为单位）。\n  4. 距离查找总次数。\n  5. 加法总次数。\n- 例如，您的输出应类似于$[[a_{1},a_{2},a_{3},a_{4},a_{5}],[b_{1},b_{2},b_{3},b_{4},b_{5}],\\dots]$，不含任何空白字符。", "solution": "该问题已经过验证，并被确定为计算科学中一个良构的、有科学依据的问题。\n\n### 第1步：提取已知信息\n\n该问题为分析用于分子动力学轨迹数据$k$-中心点聚类的计算流程提供了以下数据、定义和规则。\n\n**通用参数：**\n- $N$：快照（结构）的数量。\n- $k$：簇（中心点）的数量。\n- $t$：迭代算法的优化迭代次数。\n- $b$：单个距离矩阵元素的大小（字节）（例如，一个浮点数）。\n- $B$：总内存预算（字节）。\n\n**特定算法参数：**\n- 对于CLARA：$s$（样本大小），$r$（重启次数）。\n- 对于基于地标的初始化：$L$（地标数量），$t_{\\mathrm{refine}}$（优化迭代次数）。\n\n**基本定义：**\n- $k$-中心点目标是找到一个包含$k$个中心点的集合$M$，以最小化$\\sum_ {i=1}^{N} \\min_ {m \\in M} d(i,m)$，其中$d(\\cdot, \\cdot)$是度量距离。\n- 一次距离矩阵查找是指访问$d(i,j)$，计为1次操作。\n- 一次基本加法是指将两个标量相加，计为1次操作。\n\n**成本模型：**\n1.  **完整压缩矩阵（类FastPAM）：**\n    - 每次迭代的距离查找次数：$N \\cdot k + N \\cdot (N - k)$。\n    - 每次迭代的加法次数：等于距离查找次数。\n    - 在$t$次迭代中的总操作次数：$t \\times (\\text{每次迭代的成本})$。\n    - 内存（字节）：$b \\cdot \\left( \\frac{N(N-1)}{2} + 3N \\right) + 8k$。\n\n2.  **类CLARA子采样：**\n    - 基于样本的查找次数：$r \\cdot t \\cdot \\left( s \\cdot k + s \\cdot (s - k) \\right)$。\n    - 完整数据评估查找次数：$r \\cdot (N \\cdot k) + (N \\cdot k)$。\n    - 总查找次数：以上两项之和。\n    - 总加法次数：等于总距离查找次数。\n    - 内存（字节）：$b \\cdot \\left( \\frac{s(s-1)}{2} + 3s \\right) + 8k$。\n\n3.  **精确$k=1$流式处理：**\n    - 距离查找次数：$\\frac{N(N-1)}{2}$。\n    - 加法次数：$N(N-1)$。\n    - 内存（字节）：$b \\cdot N + 8$。\n\n4.  **基于地标的初始化：**\n    - 地标距离查找次数：$N \\cdot L$。\n    - 优化查找次数：$t_{\\mathrm{refine}} \\cdot \\left( N \\cdot k + N \\cdot (N - k) \\right)$。\n    - 最终分配查找次数：$N \\cdot k$。\n    - 总查找次数：以上三项之和。\n    - 总加法次数：等于总距离查找次数。\n    - 内存（字节）：$b \\cdot \\left( N \\cdot L + 3N \\right) + 8k$。\n\n**流程选择规则：**\n必须遵循严格的分层决策过程：\n1.  如果$k=1$，选择“精确$k=1$流式处理”流程。\n2.  否则，如果“完整压缩矩阵”流程的内存需求在预算内（$\\le B$），则选择它。\n3.  否则，如果定义了地标方案（给定参数$L, t_{\\mathrm{refine}}$）并且其内存需求在预算内（$\\le B$），则选择“基于地标的初始化”流程。\n4.  否则，选择“类CLARA子采样”流程。\n\n**测试套件：**\n- 案例 1：$N = 10000$，$k = 20$，$t = 5$，$b = 4$，$B = 250000000$。\n- 案例 2：$N = 10000$，$k = 100$，$t = 5$，$b = 8$，$B = 300000000$，$s = 2000$，$r = 5$。\n- 案例 3：$N = 10000$，$k = 1$，$t = 3$，$b = 4$，$B = 50000000$。\n- 案例 4：$N = 10000$，$k = 50$，$t = 4$，$b = 4$，$B = 180000000$，$L = 100$，$t_{\\mathrm{refine}} = 1$。\n\n### 第2步：使用提取的已知信息进行验证\n\n所提供的问题是计算分析和算法决策方面一个定义明确的练习。\n- **科学依据（关键）：** 该问题植根于从分子动力学模拟中聚类构象系综这一常见任务，这是计算生物物理学中的一个标准程序。RMSD、$k$-中心点以及像PAM和CLARA这样的相关算法的使用是完全常规且科学合理的。成本模型虽然经过简化，但是被明确定义，并基于对算法复杂度的合理近似。\n- **良构性：** 该问题是根据确定性规则构建的。为每个测试用例提供了一组清晰的输入，并且“流程选择规则”是一个明确的决策算法。用于计算输出指标（内存、查找、加法）的公式是明确的。这种结构保证了每个测试用例都有唯一且稳定的解。\n- **客观性（关键）：** 问题陈述纯粹是定量的和算法性的。它避免了任何主观语言、模糊性或基于观点的断言。\n\n该问题没有表现出任何诸如科学不健全、不完整、矛盾或依赖于不可形式化的概念等缺陷。这是一个有效的计算问题。\n\n### 第3步：结论与行动\n\n问题有效。将提供完整的解决方案。\n\n### 解决方案推导\n\n解决方案要求为每个测试用例实现指定的流程选择逻辑和相应的成本计算。对于每个案例，我们将首先确定完整矩阵方法是否可行，然后应用选择规则来确定所选的流程。最后，我们计算所选流程的内存使用量、总距离查找次数和总加法次数。\n\n**案例1分析：**\n- 参数：$N = 10000$，$k = 20$，$t = 5$，$b = 4$，$B = 250000000$。\n- 完整矩阵内存：$M_{\\text{full}} = b \\cdot (\\frac{N(N-1)}{2} + 3N) + 8k = 4 \\cdot (\\frac{10000 \\cdot 9999}{2} + 3 \\cdot 10000) + 8 \\cdot 20 = 4 \\cdot (49995000 + 30000) + 160 = 200100160$ 字节。\n- 完整矩阵的可行性：$200100160 \\le 250000000$，这是成立的。可行性为$1$。\n- 选择：由于$k \\neq 1$且完整矩阵可行，因此选择“完整的类FastPAM”流程（ID $0$）。\n- 使用的内存：$200100160$ 字节。\n- 总查找次数：$L_{\\text{total}} = t \\cdot (N \\cdot k + N \\cdot (N - k)) = t \\cdot N^2 = 5 \\cdot (10000)^2 = 500000000$。\n- 总加法次数：$A_{\\text{total}} = L_{\\text{total}} = 500000000$。\n- 结果：$[1, 0, 200100160, 500000000, 500000000]$。\n\n**案例2分析：**\n- 参数：$N = 10000$，$k = 100$，$t = 5$，$b = 8$，$B = 300000000$，$s = 2000$，$r = 5$。\n- 完整矩阵内存：$M_{\\text{full}} = 8 \\cdot (\\frac{10000 \\cdot 9999}{2} + 3 \\cdot 10000) + 8 \\cdot 100 = 8 \\cdot (50025000) + 800 = 400200800$ 字节。\n- 完整矩阵的可行性：$400200800 \\le 300000000$，这是不成立的。可行性为$0$。\n- 选择：$k \\neq 1$，完整矩阵不可行。未给出地标参数。规则默认采用“CLARA子采样”流程（ID $1$）。\n- 使用的内存：$M_{\\text{CLARA}} = b \\cdot (\\frac{s(s-1)}{2} + 3s) + 8k = 8 \\cdot (\\frac{2000 \\cdot 1999}{2} + 3 \\cdot 2000) + 8 \\cdot 100 = 8 \\cdot (1999000 + 6000) + 800 = 16040800$ 字节。\n- 总查找次数：$L_{\\text{total}} = r \\cdot t \\cdot (s \\cdot k + s \\cdot (s - k)) + (r+1) \\cdot N \\cdot k = r \\cdot t \\cdot s^2 + (r+1) \\cdot N \\cdot k = 5 \\cdot 5 \\cdot 2000^2 + (5+1) \\cdot 10000 \\cdot 100 = 100000000 + 6000000 = 106000000$。\n- 总加法次数：$A_{\\text{total}} = L_{\\text{total}} = 106000000$。\n- 结果：$[0, 1, 16040800, 106000000, 106000000]$。\n\n**案例3分析：**\n- 参数：$N = 10000$，$k = 1$，$t = 3$，$b = 4$，$B = 50000000$。\n- 完整矩阵内存：$M_{\\text{full}} = 4 \\cdot (\\frac{10000 \\cdot 9999}{2} + 3 \\cdot 10000) + 8 \\cdot 1 = 200100008$ 字节。\n- 完整矩阵的可行性：$200100008 \\le 50000000$，这是不成立的。可行性为$0$。\n- 选择：由于$k=1$，无论其他条件如何，都选择“精确$k=1$流式处理”流程（ID $2$）。\n- 使用的内存：$M_{k=1} = b \\cdot N + 8 = 4 \\cdot 10000 + 8 = 40008$ 字节。\n- 总查找次数：$L_{\\text{total}} = \\frac{N(N-1)}{2} = \\frac{10000 \\cdot 9999}{2} = 49995000$。\n- 总加法次数：$A_{\\text{total}} = N(N-1) = 99980000$。\n- 结果：$[0, 2, 40008, 49995000, 99980000]$。\n\n**案例4分析：**\n- 参数：$N = 10000$，$k = 50$，$t = 4$，$b = 4$，$B = 180000000$，$L = 100$，$t_{\\mathrm{refine}} = 1$。\n- 完整矩阵内存：$M_{\\text{full}} = 4 \\cdot (\\frac{10000 \\cdot 9999}{2} + 3 \\cdot 10000) + 8 \\cdot 50 = 200100400$ 字节。\n- 完整矩阵的可行性：$200100400 \\le 180000000$，这是不成立的。可行性为$0$。\n- 选择：$k \\neq 1$，完整矩阵不可行。我们接下来检查基于地标的方法。\n- 地标内存：$M_{\\text{landmark}} = b \\cdot (N \\cdot L + 3N) + 8k = 4 \\cdot (10000 \\cdot 100 + 3 \\cdot 10000) + 8 \\cdot 50 = 4 \\cdot (1000000 + 30000) + 400 = 4120400$ 字节。\n- 地标可行性：$4120400 \\le 180000000$，这是成立的。选择“基于地标的初始化”流程（ID $3$）。\n- 使用的内存：$4120400$ 字节。\n- 总查找次数：$L_{\\text{total}} = N \\cdot L + t_{\\mathrm{refine}} \\cdot (N \\cdot k + N \\cdot (N-k)) + N \\cdot k = N \\cdot L + t_{\\mathrm{refine}} \\cdot N^2 + N \\cdot k = 10000 \\cdot 100 + 1 \\cdot (10000)^2 + 10000 \\cdot 50 = 1000000 + 100000000 + 500000 = 101500000$。\n- 总加法次数：$A_{\\text{total}} = L_{\\text{total}} = 101500000$。\n- 结果：$[0, 3, 4120400, 101500000, 101500000]$。\n\n这些计算将在提供的Python代码结构中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are imported from scipy or elsewhere.\n\ndef solve():\n    \"\"\"\n    Analyzes computational pipelines for k-medoids clustering based on a given set of rules\n    and cost models, for several test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: N=10000, k=20, t=5, b=4, B=250000000\n        {'N': 10000, 'k': 20, 't': 5, 'b': 4, 'B': 250000000},\n        # Case 2: N=10000, k=100, t=5, b=8, B=300000000, CLARA params: s=2000, r=5\n        {'N': 10000, 'k': 100, 't': 5, 'b': 8, 'B': 300000000, 's': 2000, 'r': 5},\n        # Case 3: N=10000, k=1, t=3, b=4, B=50000000\n        {'N': 10000, 'k': 1, 't': 3, 'b': 4, 'B': 50000000},\n        # Case 4: N=10000, k=50, t=4, b=4, B=180000000, landmark params: L=100, t_refine=1\n        {'N': 10000, 'k': 50, 't': 4, 'b': 4, 'B': 180000000, 'L': 100, 't_refine': 1},\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        k = case['k']\n        b = case['b']\n        B = case['B']\n        t = case.get('t', 0) # Not used for all pipelines, default to 0\n\n        # Calculate memory for the full matrix approach to determine feasibility\n        mem_full = b * (N * (N - 1) // 2 + 3 * N) + 8 * k\n        is_full_feasible = 1 if mem_full = B else 0\n\n        chosen_pipeline_id = -1\n        mem_used = -1\n        lookups = -1\n        additions = -1\n\n        # Apply the pipeline selection rule\n        if k == 1:\n            # Pipeline 2: Exact k=1 streaming\n            chosen_pipeline_id = 2\n            mem_used = b * N + 8\n            lookups = N * (N - 1) // 2\n            additions = N * (N - 1)\n        elif is_full_feasible:\n            # Pipeline 0: Full FastPAM-like\n            chosen_pipeline_id = 0\n            mem_used = mem_full\n            # Lookups/Additions: t * (N*k + N*(N-k)) simplifies to t * N^2\n            ops_count = t * (N * k + N * (N - k))\n            lookups = ops_count\n            additions = ops_count\n        elif 'L' in case:\n            # Check landmark pipeline\n            L = case['L']\n            t_refine = case['t_refine']\n            mem_landmark = b * (N * L + 3 * N) + 8 * k\n            if mem_landmark = B:\n                # Pipeline 3: Landmark-initialized\n                chosen_pipeline_id = 3\n                mem_used = mem_landmark\n                # Ops: N*L + t_refine * (N*k + N*(N-k)) + N*k\n                ops_count = N * L + t_refine * (N * k + N * (N - k)) + N * k\n                lookups = ops_count\n                additions = ops_count\n            else:\n                # Fallback to CLARA\n                chosen_pipeline_id = 1\n        else:\n            # Default to CLARA if full and landmark are not feasible/available\n            chosen_pipeline_id = 1\n\n        # If CLARA was chosen (either by direct fallback or because landmark failed)\n        if chosen_pipeline_id == 1:\n            s = case['s']\n            r = case['r']\n            mem_used = b * (s * (s - 1) // 2 + 3 * s) + 8 * k\n            # Ops: r*t*(s*k + s*(s-k)) + r*N*k + N*k\n            ops_count = r * t * (s * k + s * (s - k)) + r * N * k + N * k\n            lookups = ops_count\n            additions = ops_count\n\n        results.append([is_full_feasible, chosen_pipeline_id, mem_used, lookups, additions])\n\n    # Format the final output string as specified\n    # Example: [[a,b,c],[d,e,f]] with no whitespace.\n    result_str = str(results).replace(\" \", \"\")\n    print(result_str)\n\nsolve()\n```", "id": "3401895"}]}