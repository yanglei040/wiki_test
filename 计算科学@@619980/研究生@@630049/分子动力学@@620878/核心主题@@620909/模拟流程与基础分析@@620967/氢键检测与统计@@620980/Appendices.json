{"hands_on_practices": [{"introduction": "在周期性边界条件 (PBC) 下进行分子动力学模拟时，正确计算原子间距离至关重要。直接计算坐标差会因原子穿越边界而导致错误的、过大的距离，从而严重影响氢键检测的准确性。本练习将通过编程实践，让您亲手实现并对比忽略PBC的朴素算法与采用最小镜像约定 (MIC) 的正确算法，并量化由此产生的偏差，从而深刻理解MIC在模拟分析中的核心作用。[@problem_id:3416826]", "problem": "在分子动力学中，您有一项任务：严格评估周期性边界条件（PBC）和映象选择对立方模拟盒子边缘附近氢键检测的影响。您的目标是从基本原理出发，推导出一个用于氢键几何评估的最小映象一致性算法，并量化由此在氢键径向-角向分布函数（表示为 $g_{\\mathrm{HB}}(r,\\theta)$，其中 $r$ 是受体-氢距离，$\\theta$ 是供体-氢-受体角度）中产生的偏差。在一个边长为 $L$ 的立方盒子中，使用周期性边界条件进行计算，并将所有分子视为刚性类水实体，以构建供体和受体集合。\n\n从以下基本原理开始：\n- 在周期性边界条件下，物理系统被建模为主模拟盒子的无限平铺，并且必须使用“最近映象”几何来计算原子间矢量。最小映象约定规定，两个位置之间物理相关的位移矢量是在所有周期性映象中具有最小欧几里得范数的那个矢量。\n- 氢键几何由数对 $(r,\\theta)$ 定义，其中 $r$ 等于从氢到受体重原子的矢量的范数，$\\theta$ 等于在氢原子处，从氢到其供体重原子的矢量与从氢到受体重原子的矢量之间的夹角。距离必须以埃（ångström）为单位表示，角度必须以度为单位表示。\n\n您的程序必须实现两种算法，用于评估测试套件中所有帧的所有供体-受体候选对的 $(r,\\theta)$：\n1. 一种朴素的、非映象的算法，该算法计算原始笛卡尔坐标差，而不调用周期性最小映象映射。\n2. 一种最小映象一致性算法，该算法对供体-氢矢量和氢-受体矢量使用相同的周期性映射，确保与周期性边界条件的兼容性。\n\n使用这两种算法，计算近似 $g_{\\mathrm{HB}}(r,\\theta)$ 的二维直方图（在固定的区间上），并将其归一化为概率密度，使得在直方图域上的积分等于 $1$。通过计算归一化直方图之间的均方根差，来量化朴素算法相对于最小映象一致性算法所引入的偏差。对于每个测试用例，将此单个标量偏差报告为无量纲浮点数。\n\n测试套件和几何规格：\n- 使用类水分子，每个分子有一个位于位置 $\\mathbf{O}$ 的供体重原子和两个位于位置 $\\mathbf{H}_1$ 和 $\\mathbf{H}_2$ 的氢原子。氢相对于 $\\mathbf{O}$ 的位置使用固定的偏移量 $\\Delta \\mathbf{r}_1 = (0.95,0,0)$ 和 $\\Delta \\mathbf{r}_2 = (-0.24,0.93,0)$（单位为埃）来放置，然后对每个氢的每个笛卡尔分量使用模运算将其坐标包裹到主盒子 $[0,L)$ 内。供体重原子是每个分子的氧原子 $\\mathbf{O}$。每个氧原子 $\\mathbf{O}$ 也作为其他分子的所有氢的受体（仅限跨分子对）。\n- 对于每个测试用例，程序必须评估两帧。距离必须以埃为单位计算，角度以度为单位。径向直方图必须使用区间边界 $[1.5,1.9,2.3,2.7,3.1,3.5]$（单位为埃），角向直方图必须使用区间边界 $[120,130,140,150,160,170,180]$（单位为度）。二维直方图必须归一化为概率密度 $g_{\\mathrm{HB}}(r,\\theta)$，使得所有区间的 $g_{\\mathrm{HB}}(r,\\theta)\\,\\Delta r\\,\\Delta \\theta$ 之和等于 $1$，其中 $\\Delta r$ 和 $\\Delta \\theta$ 分别是 $r$ 和 $\\theta$ 的区间宽度。如果一个测试用例在直方图域内没有产生任何数对，则将其直方图定义为恒等于零，偏差为 $0$。\n- 测试套件包含四个用例，参数如下：\n    - 用例 1：$L = 10$ 埃，第 1 帧分子：\n        - 分子 $\\mathrm{A}$：$\\mathbf{O} = (9.8,5.0,5.0)$，$\\mathbf{H}_1 = (0.75,5.0,5.0)$，$\\mathbf{H}_2 = (9.56,5.93,5.0)$。\n        - 分子 $\\mathrm{B}$：$\\mathbf{O} = (2.4,5.2,5.0)$，$\\mathbf{H}_1 = (3.35,5.2,5.0)$，$\\mathbf{H}_2 = (2.16,6.13,5.0)$。\n      第 2 帧分子：\n        - 分子 $\\mathrm{A}$：$\\mathbf{O} = (9.9,5.1,5.0)$，$\\mathbf{H}_1 = (0.85,5.1,5.0)$，$\\mathbf{H}_2 = (9.66,6.03,5.0)$。\n        - 分子 $\\mathrm{B}$：$\\mathbf{O} = (2.5,5.1,5.0)$，$\\mathbf{H}_1 = (3.45,5.1,5.0)$，$\\mathbf{H}_2 = (2.26,6.03,5.0)$。\n    - 用例 2：$L = 20$ 埃，第 1 帧分子：\n        - 分子 $\\mathrm{C}$：$\\mathbf{O} = (10.0,10.0,10.0)$，$\\mathbf{H}_1 = (10.95,10.0,10.0)$，$\\mathbf{H}_2 = (9.76,10.93,10.0)$。\n        - 分子 $\\mathrm{D}$：$\\mathbf{O} = (14.0,14.0,14.0)$，$\\mathbf{H}_1 = (14.95,14.0,14.0)$，$\\mathbf{H}_2 = (13.76,14.93,14.0)$。\n      第 2 帧分子：\n        - 分子 $\\mathrm{C}$：$\\mathbf{O} = (10.1,10.1,10.0)$，$\\mathbf{H}_1 = (11.05,10.1,10.0)$，$\\mathbf{H}_2 = (9.86,11.03,10.0)$。\n        - 分子 $\\mathrm{D}$：$\\mathbf{O} = (13.9,14.1,14.0)$，$\\mathbf{H}_1 = (14.85,14.1,14.0)$，$\\mathbf{H}_2 = (13.66,15.03,14.0)$。\n    - 用例 3：$L = 8$ 埃，第 1 帧分子：\n        - 分子 $\\mathrm{E}$：$\\mathbf{O} = (7.9,3.0,3.0)$，$\\mathbf{H}_1 = (0.85,3.0,3.0)$，$\\mathbf{H}_2 = (7.66,3.93,3.0)$。\n        - 分子 $\\mathrm{F}$：$\\mathbf{O} = (2.4,3.1,3.0)$，$\\mathbf{H}_1 = (3.35,3.1,3.0)$，$\\mathbf{H}_2 = (2.16,4.03,3.0)$。\n      第 2 帧分子：\n        - 分子 $\\mathrm{E}$：$\\mathbf{O} = (7.85,3.1,3.0)$，$\\mathbf{H}_1 = (0.80,3.1,3.0)$，$\\mathbf{H}_2 = (7.61,4.03,3.0)$。\n        - 分子 $\\mathrm{F}$：$\\mathbf{O} = (2.5,3.2,3.0)$，$\\mathbf{H}_1 = (3.45,3.2,3.0)$，$\\mathbf{H}_2 = (2.26,4.13,3.0)$。\n    - 用例 4：$L = 12$ 埃，第 1 帧分子：\n        - 分子 $\\mathrm{G}$：$\\mathbf{O} = (1.0,1.0,1.0)$，$\\mathbf{H}_1 = (1.95,1.0,1.0)$，$\\mathbf{H}_2 = (0.76,1.93,1.0)$。\n        - 分子 $\\mathrm{H}$：$\\mathbf{O} = (9.5,9.5,9.5)$，$\\mathbf{H}_1 = (10.45,9.5,9.5)$，$\\mathbf{H}_2 = (9.26,10.43,9.5)$。\n      第 2 帧分子：\n        - 分子 $\\mathrm{G}$：$\\mathbf{O} = (1.5,1.5,1.0)$，$\\mathbf{H}_1 = (2.45,1.5,1.0)$，$\\mathbf{H}_2 = (1.26,2.43,1.0)$。\n        - 分子 $\\mathrm{H}$：$\\mathbf{O} = (9.0,9.0,10.0)$，$\\mathbf{H}_1 = (9.95,9.0,10.0)$，$\\mathbf{H}_2 = (8.76,9.93,10.0)$。\n\n程序要求：\n- 实现朴素算法和最小映象一致性算法，以计算每个测试用例中所有帧和分子的所有供体-受体候选对的 $(r,\\theta)$，其中供体是 $(\\mathbf{O},\\mathbf{H}_k)$ 对，受体是其他分子的 $\\mathbf{O}$。\n- 在指定的 $r$（单位为埃）和 $\\theta$（单位为度）的区间边界上构建二维直方图，并按前述方式归一化为概率密度 $g_{\\mathrm{HB}}(r,\\theta)$。\n- 对每个测试用例，计算定义为两个归一化直方图之间均方根差的偏差。\n\n最终输出：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是按上述顺序对应的测试用例的偏差值（无量纲浮点数）。", "solution": "该问题要求在周期性边界条件（PBC）下的分子动力学环境中，对两种计算氢键几何的算法进行严格比较。目标是量化一种忽略PBC的朴素算法相对于物理上正确的最小映象一致性（MIC）算法所引入的偏差。该偏差通过两种方法产生的归一化二维径向-角向分布函数 $g_{\\mathrm{HB}}(r,\\theta)$ 之间的均方根差来衡量。\n\n基本原理和算法设计详述如下。所有数学实体均按要求使用LaTeX渲染。\n\n### 1. 周期性边界条件与最小映象约定\n\n在块状物质的计算机模拟中，采用周期性边界条件来减轻有限尺寸效应。模拟盒子被视为无限晶格的原胞，从而有效地创建一个无限的周期性系统。当计算两个粒子 $i$ 和 $j$（位置分别为 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$）之间的相互作用或几何关系时，必须考虑粒子 $i$ 与粒子 $j$ 的所有周期性映象之间的相互作用。\n\n最小映象约定（MIC）是处理此问题的标准程序。它规定，物理上相关的位移是粒子 $i$ 与粒子 $j$ 的任意映象之间的最短矢量。对于边长为 $L$ 的立方模拟盒子，原始位移矢量为 $\\mathbf{d} = \\mathbf{r}_j - \\mathbf{r}_i$。最小映象矢量 $\\mathbf{d}_{\\text{mic}}$ 的每个笛卡尔分量被计算到区间 $[-L/2, L/2]$ 内。这可以通过分量级运算实现：\n$$\nd_{k, \\text{mic}} = d_k - L \\cdot \\left\\lfloor \\frac{d_k}{L} + \\frac{1}{2} \\right\\rfloor \\quad \\text{其中 } k \\in \\{x, y, z\\}\n$$\n其中 $\\lfloor \\cdot \\rfloor$ 是向下取整函数。此操作有效地找到粒子 $j$ 相对于粒子 $i$ 的最近映象。我们定义一个矢量函数 $\\text{MIC}(\\mathbf{d}, L)$，它将此操作应用于 $\\mathbf{d}$ 的所有分量。\n\n### 2. 氢键几何定义\n\n氢键由一个供体-氢-受体的三原子组来表征。设它们的位置分别为 $\\mathbf{r}_D$（供体重原子）、$\\mathbf{r}_H$（氢）和 $\\mathbf{r}_A$（受体重原子）。其几何形状由两个参数定义：\n1. 氢-受体距离 $r$，即从 $\\mathbf{H}$ 到 $\\mathbf{A}$ 的矢量的范数。\n2. 供体-氢-受体角度 $\\theta$，即在氢原子处形成的夹角。\n\n两种算法的关键区别在于如何计算定义 $r$ 和 $\\theta$ 的矢量。我们定义从氢原子出发的基本矢量：\n- 从氢到供体的矢量：$\\mathbf{v}_{HD} = \\mathbf{r}_D - \\mathbf{r}_H$\n- 从氢到受体的矢量：$\\mathbf{v}_{HA} = \\mathbf{r}_A - \\mathbf{r}_H$\n\n### 3. 算法实现\n\n#### a. 朴素（非映象）算法\n此算法使用原始笛卡尔位移矢量计算几何参数，未考虑PBC。这种方法在根本上是有缺陷的，因为它忽略了系统的周期性，导致对跨越盒子边界的原子对计算出错误的距离和角度。\n\n- 距离：$r_{\\text{naive}} = ||\\mathbf{r}_A - \\mathbf{r}_H||_2$\n- 角度：根据原始矢量的点积计算角度。\n    $$\n    \\theta_{\\text{naive}} = \\arccos\\left(\\frac{(\\mathbf{r}_D - \\mathbf{r}_H) \\cdot (\\mathbf{r}_A - \\mathbf{r}_H)}{||\\mathbf{r}_D - \\mathbf{r}_H||_2 \\cdot ||\\mathbf{r}_A - \\mathbf{r}_H||_2}\\right)\n    $$\n    结果从弧度转换为度。\n\n#### b. 最小映象一致性（MIC）算法\n此算法正确地将MIC应用于几何计算中使用的所有位移矢量。这确保了几何形状能反映在周期性复制空间中的真实邻近关系。\n\n1. 计算从 $\\mathbf{H}$ 到 $\\mathbf{D}$ 的最小映象矢量：$\\mathbf{v}_{HD}^{\\text{mic}} = \\text{MIC}(\\mathbf{r}_D - \\mathbf{r}_H, L)$。\n2. 计算从 $\\mathbf{H}$ 到 $\\mathbf{A}$ 的最小映象矢量：$\\mathbf{v}_{HA}^{\\text{mic}} = \\text{MIC}(\\mathbf{r}_A - \\mathbf{r}_H, L)$。\n3. 使用这些经MIC校正的矢量计算距离和角度：\n    - 距离：$r_{\\text{mic}} = ||\\mathbf{v}_{HA}^{\\text{mic}}||_2$\n    - 角度：\n        $$\n        \\theta_{\\text{mic}} = \\arccos\\left(\\frac{\\mathbf{v}_{HD}^{\\text{mic}} \\cdot \\mathbf{v}_{HA}^{\\text{mic}}}{||\\mathbf{v}_{HD}^{\\text{mic}}||_2 \\cdot ||\\mathbf{v}_{HA}^{\\text{mic}}||_2}\\right)\n        $$\n        结果从弧度转换为度。\n\n### 4. 统计分析与偏差量化\n\n对于每种算法，收集所有有效的供体-受体候选对在所有帧中计算出的所有 $(r, \\theta)$ 对的集合。\n\n#### a. 直方图构建\n使用提供的区间边界构建一个二维直方图：\n- 径向区间 ($r$)：边界位于 $[1.5, 1.9, 2.3, 2.7, 3.1, 3.5]$ 埃。这产生 $5$ 个区间，每个宽度为 $\\Delta r = 0.4$ Å。\n- 角向区间 ($\\theta$)：边界位于 $[120, 130, 140, 150, 160, 170, 180]$ 度。这产生 $6$ 个区间，每个宽度为 $\\Delta \\theta = 10$ 度。\n原始直方图 $N_{ij}$ 包含落入区间 $(i, j)$ 的 $(r, \\theta)$ 对的数量。\n\n#### b. 归一化\n原始计数 $N_{ij}$ 被归一化为概率密度函数 $g_{ij}$，使得在域上的积分为1。设 $N_{\\text{total}} = \\sum_{i,j} N_{ij}$ 为落入直方图范围内的总对数。区间 $(i, j)$ 中的归一化密度为：\n$$\ng_{ij} = \\frac{N_{ij}}{N_{\\text{total}} \\cdot \\Delta r \\cdot \\Delta \\theta}\n$$\n这在 $N_{\\text{total}} > 0$ 时有效。如果 $N_{\\text{total}} = 0$，则所有 $g_{ij}$ 定义为 $0$。此归一化确保 $\\sum_{i,j} g_{ij} \\Delta r \\Delta \\theta = 1$。\n\n#### c. 偏差计算\n由朴素算法引入的偏差通过两个归一化直方图 $g^{\\text{naive}}$ 和 $g^{\\text{mic}}$ 之间的均方根差（RMSD）来量化。求和遍历直方图的所有 $N_{\\text{bins}} = 5 \\times 6 = 30$ 个区间。\n$$\n\\text{Bias} = \\sqrt{\\frac{1}{N_{\\text{bins}}} \\sum_{i,j} (g_{ij}^{\\text{naive}} - g_{ij}^{\\text{mic}})^2}\n$$\n如果两个直方图都为空（即，两种算法在指定范围内均未找到任何数对），则偏差为 $0$。\n\n### 5. 计算流程\n\n解决方案通过为每个测试用例执行以下步骤来进行：\n1. 初始化空列表，用于存储两种算法的 $(r, \\theta)$ 对。\n2. 遍历为测试用例提供的两帧。\n3. 对每一帧，遍历所有可能的跨分子供体-受体配对。根据问题陈述，对于两个分子（例如A和B），配对为（供体A，受体B）和（供体B，受体A）。\n4. 对每个配对，遍历供体分子的两个氢原子。\n5. 对每个产生的D-H-A三元组，使用朴素算法和MIC算法计算 $(r, \\theta)$。存储结果。\n6. 处理完所有配对后，根据收集的数对和指定的区间边界生成二维直方图 $N_{ij}^{\\text{naive}}$ 和 $N_{ij}^{\\text{mic}}$。\n7. 将两个直方图归一化以获得概率密度 $g_{ij}^{\\text{naive}}$ 和 $g_{ij}^{\\text{mic}}$。\n8. 使用RMSD公式计算最终的标量偏差。\n收集所有四个用例得到的偏差值并报告。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hydrogen bond geometry problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"L\": 10.0,\n            \"frames\": [\n                [ # Frame 1\n                    {\"O\": (9.8, 5.0, 5.0), \"H1\": (0.75, 5.0, 5.0), \"H2\": (9.56, 5.93, 5.0)},\n                    {\"O\": (2.4, 5.2, 5.0), \"H1\": (3.35, 5.2, 5.0), \"H2\": (2.16, 6.13, 5.0)}\n                ],\n                [ # Frame 2\n                    {\"O\": (9.9, 5.1, 5.0), \"H1\": (0.85, 5.1, 5.0), \"H2\": (9.66, 6.03, 5.0)},\n                    {\"O\": (2.5, 5.1, 5.0), \"H1\": (3.45, 5.1, 5.0), \"H2\": (2.26, 6.03, 5.0)}\n                ]\n            ]\n        },\n        # Case 2\n        {\n            \"L\": 20.0,\n            \"frames\": [\n                [ # Frame 1\n                    {\"O\": (10.0, 10.0, 10.0), \"H1\": (10.95, 10.0, 10.0), \"H2\": (9.76, 10.93, 10.0)},\n                    {\"O\": (14.0, 14.0, 14.0), \"H1\": (14.95, 14.0, 14.0), \"H2\": (13.76, 14.93, 14.0)}\n                ],\n                [ # Frame 2\n                    {\"O\": (10.1, 10.1, 10.0), \"H1\": (11.05, 10.1, 10.0), \"H2\": (9.86, 11.03, 10.0)},\n                    {\"O\": (13.9, 14.1, 14.0), \"H1\": (14.85, 14.1, 14.0), \"H2\": (13.66, 15.03, 14.0)}\n                ]\n            ]\n        },\n        # Case 3\n        {\n            \"L\": 8.0,\n            \"frames\": [\n                [ # Frame 1\n                    {\"O\": (7.9, 3.0, 3.0), \"H1\": (0.85, 3.0, 3.0), \"H2\": (7.66, 3.93, 3.0)},\n                    {\"O\": (2.4, 3.1, 3.0), \"H1\": (3.35, 3.1, 3.0), \"H2\": (2.16, 4.03, 3.0)}\n                ],\n                [ # Frame 2\n                    {\"O\": (7.85, 3.1, 3.0), \"H1\": (0.80, 3.1, 3.0), \"H2\": (7.61, 4.03, 3.0)},\n                    {\"O\": (2.5, 3.2, 3.0), \"H1\": (3.45, 3.2, 3.0), \"H2\": (2.26, 4.13, 3.0)}\n                ]\n            ]\n        },\n        # Case 4\n        {\n            \"L\": 12.0,\n            \"frames\": [\n                [ # Frame 1\n                    {\"O\": (1.0, 1.0, 1.0), \"H1\": (1.95, 1.0, 1.0), \"H2\": (0.76, 1.93, 1.0)},\n                    {\"O\": (9.5, 9.5, 9.5), \"H1\": (10.45, 9.5, 9.5), \"H2\": (9.26, 10.43, 9.5)}\n                ],\n                [ # Frame 2\n                    {\"O\": (1.5, 1.5, 1.0), \"H1\": (2.45, 1.5, 1.0), \"H2\": (1.26, 2.43, 1.0)},\n                    {\"O\": (9.0, 9.0, 10.0), \"H1\": (9.95, 9.0, 10.0), \"H2\": (8.76, 9.93, 10.0)}\n                ]\n            ]\n        }\n    ]\n\n    r_bins = np.array([1.5, 1.9, 2.3, 2.7, 3.1, 3.5])\n    theta_bins = np.array([120, 130, 140, 150, 160, 170, 180])\n    delta_r = 0.4\n    delta_theta = 10.0\n    bin_area = delta_r * delta_theta\n    num_bins = (len(r_bins) - 1) * (len(theta_bins) - 1)\n\n\n    def calculate_bias_for_case(case_data):\n        L = case_data[\"L\"]\n        frames = case_data[\"frames\"]\n\n        pairs_naive = []\n        pairs_mic = []\n\n        def apply_mic(v, box_L):\n            return v - box_L * np.floor(v / box_L + 0.5)\n\n        for molecules_in_frame in frames:\n            mol_indices = range(len(molecules_in_frame))\n            for i in mol_indices:\n                for j in mol_indices:\n                    if i == j:\n                        continue\n                    \n                    donor_mol = molecules_in_frame[i]\n                    acceptor_mol = molecules_in_frame[j]\n\n                    r_D = np.array(donor_mol['O'])\n                    r_A = np.array(acceptor_mol['O'])\n                    \n                    hydrogens = [np.array(donor_mol['H1']), np.array(donor_mol['H2'])]\n\n                    for r_H in hydrogens:\n                        # Naive calculation\n                        v_HD_naive = r_D - r_H\n                        v_HA_naive = r_A - r_H\n                        norm_v_HD_naive = np.linalg.norm(v_HD_naive)\n                        norm_v_HA_naive = np.linalg.norm(v_HA_naive)\n\n                        if norm_v_HD_naive > 1e-9 and norm_v_HA_naive > 1e-9:\n                            r_naive = norm_v_HA_naive\n                            cos_theta_naive = np.dot(v_HD_naive, v_HA_naive) / (norm_v_HD_naive * norm_v_HA_naive)\n                            theta_naive = np.degrees(np.arccos(np.clip(cos_theta_naive, -1.0, 1.0)))\n                            pairs_naive.append((r_naive, theta_naive))\n\n                        # MIC calculation\n                        v_HD_mic = apply_mic(r_D - r_H, L)\n                        v_HA_mic = apply_mic(r_A - r_H, L)\n                        norm_v_HD_mic = np.linalg.norm(v_HD_mic)\n                        norm_v_HA_mic = np.linalg.norm(v_HA_mic)\n                        \n                        if norm_v_HD_mic > 1e-9 and norm_v_HA_mic > 1e-9:\n                            r_mic = norm_v_HA_mic\n                            cos_theta_mic = np.dot(v_HD_mic, v_HA_mic) / (norm_v_HD_mic * norm_v_HA_mic)\n                            theta_mic = np.degrees(np.arccos(np.clip(cos_theta_mic, -1.0, 1.0)))\n                            pairs_mic.append((r_mic, theta_mic))\n\n        # Histogramming and Normalization\n        if not pairs_naive and not pairs_mic:\n             return 0.0\n\n        if pairs_naive:\n            r_vals_naive = [p[0] for p in pairs_naive]\n            theta_vals_naive = [p[1] for p in pairs_naive]\n            H_naive, _, _ = np.histogram2d(r_vals_naive, theta_vals_naive, bins=[r_bins, theta_bins])\n        else:\n            H_naive = np.zeros((len(r_bins) - 1, len(theta_bins) - 1))\n        \n        if pairs_mic:\n            r_vals_mic = [p[0] for p in pairs_mic]\n            theta_vals_mic = [p[1] for p in pairs_mic]\n            H_mic, _, _ = np.histogram2d(r_vals_mic, theta_vals_mic, bins=[r_bins, theta_bins])\n        else:\n            H_mic = np.zeros((len(r_bins) - 1, len(theta_bins) - 1))\n\n        N_total_naive = np.sum(H_naive)\n        N_total_mic = np.sum(H_mic)\n\n        g_naive = np.zeros_like(H_naive)\n        if N_total_naive > 0:\n            g_naive = H_naive / (N_total_naive * bin_area)\n        \n        g_mic = np.zeros_like(H_mic)\n        if N_total_mic > 0:\n            g_mic = H_mic / (N_total_mic * bin_area)\n        \n        # Bias calculation\n        if N_total_naive == 0 and N_total_mic == 0:\n            return 0.0\n            \n        rms_diff = np.sqrt(np.mean((g_naive - g_mic)**2))\n        return rms_diff\n\n    results = [calculate_bias_for_case(case) for case in test_cases]\n    \n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3416826"}, {"introduction": "在确定了如何正确计算氢键之后，下一个挑战是效率。对于包含数百万个原子的系统，检查所有可能的施主-受主对（一个 $O(N^2)$ 的问题）在计算上是不可行的。本练习将引导您推导细胞列表（一种将复杂度降低到 $O(N)$ 的基本优化技术）的计算标度，并估算其在实际应用中的计算成本，从而揭示算法设计对大规模科学计算可行性的决定性影响。[@problem_id:3416805]", "problem": "一个代表分子动力学 (MD) 模拟的立方周期性体系包含一种适用于氢键分析的均匀流体。该体系在体积为 $V$ 的立方盒子中包含 $N$ 个均匀分布的分子，其数密度为 $\\rho = N/V$。在几何氢键判据中，只有欧几里得距离小于截断值 $r_c$ 的供体-受体对才被认为满足距离条件；角度判据在距离条件筛选之后应用。\n\n考虑一种类水流体，其中每个分子提供 $m_{d}$ 个供体位点和 $m_{a}$ 个受体位点，且供体和受体遵循与分子相同的空间均匀性，进行均匀且独立的分布。氢键检测是逐帧进行的，通过遍历所有供体位点，并对每个供体，将其与受体的距离同 $r_c$ 进行比较评估。检查所有供体-受体对的朴素方法的计算量与系统尺寸的平方成正比。\n\n为了加速距离搜索，通过将盒子分割成边长为 $a$ 的等大立方胞元来构建胞元列表，其中 $a = r_c$。对于每个供体位点，仅考虑位于其自身所在胞元以及相邻的 $3 \\times 3 \\times 3$ 胞元块中的受体位点进行距离评估；周期性边界条件确保了该邻域在盒子边界处也能被明确定义。\n\n从数密度和均匀空间分布的定义出发，且不引用任何未声明的公式，推导在胞元列表算法下，一个均匀体系中每帧进行供体-受体距离评估的期望次数的标度关系。然后，使用以下参数\n- $N = 1.0 \\times 10^{5}$ 个分子，\n- $\\rho = 3.34 \\times 10^{1}\\ \\mathrm{nm}^{-3}$，\n- $m_{d} = 2$ 个供体/分子，\n- $m_{a} = 2$ 个受体/分子，\n- $r_{c} = 3.5 \\times 10^{-1}\\ \\mathrm{nm}$，\n- $a = r_{c}$，\n并假设供体与受体之间相互独立且空间均匀分布，计算由胞元列表算法执行的每帧供体-受体距离计算的总期望次数。将最终答案表示为一个纯计数（无单位），并四舍五入至四位有效数字。", "solution": "问题陈述已经过严格验证，并被确定为具有科学依据、良构、客观且自洽。它提出了一个计算统计力学中标准的、可解的问题。\n\n任务是首先推导标度关系，然后计算使用胞元列表算法的分子动力学模拟中每帧进行供体-受体距离评估的总期望次数。推导必须从基本定义开始。\n\n设 $N$ 为体积为 $V$ 的立方盒子中分子的总数。分子的数密度为 $\\rho = N/V$。每个分子拥有 $m_d$ 个供体位点和 $m_a$ 个受体位点。体系中供体位点的总数为 $N_d = N m_d$，受体位点的总数为 $N_a = N m_a$。\n\n问题陈述指出，分子以及供体和受体位点在整个体积 $V$ 中是均匀且独立分布的。此空间均匀性原理意味着任何种类位点的数密度在整个盒子中都是恒定的。因此，受体位点的数密度 $\\rho_a$ 为：\n$$ \\rho_a = \\frac{N_a}{V} = \\frac{N m_a}{V} = \\left(\\frac{N}{V}\\right) m_a = \\rho m_a $$\n\n胞元列表算法通过遍历体系中所有的供体位点来进行。对于每个供体位点，它计算与一部分受体位点的距离。总的距离评估次数是为每个供体执行的评估次数之和。根据期望的线性性质，评估的总期望次数 $\\mathbb{E}[E]$ 是供体位点总数 $N_d$ 与单个任意供体位点的期望评估次数 $\\mathbb{E}[E_{\\text{per donor}}]$ 的乘积。\n$$ \\mathbb{E}[E] = N_d \\cdot \\mathbb{E}[E_{\\text{per donor}}] $$\n\n为了求得 $\\mathbb{E}[E_{\\text{per donor}}]$，我们必须确定为给定供体检查的受体位点数量。该算法为每个供体定义了一个搜索邻域，该邻域由其自身所在的胞元加上周围26个相邻胞元组成，形成一个 $3 \\times 3 \\times 3$ 的胞元块。此搜索邻域中的胞元总数为27个。\n\n胞元是边长为 $a$ 的立方体。问题指明 $a=r_c$，其中 $r_c$ 是氢键的距离截断值。单个胞元的体积是 $V_{\\text{cell}} = a^3 = r_c^3$。单个供体的搜索邻域总体积 $V_{\\text{search}}$ 是：\n$$ V_{\\text{search}} = 27 \\cdot V_{\\text{cell}} = 27 a^3 = 27 r_c^3 $$\n由于使用了周期性边界条件，这个搜索体积对于体系中的每个供体都是恒定的，无论其位置如何。\n\n位于此搜索体积内的受体位点的期望数 $\\mathbb{E}[N_{a, \\text{search}}]$，由受体位点密度 $\\rho_a$ 和搜索体积 $V_{\\text{search}}$ 的乘积给出。这是均匀空间分布的直接结果。\n$$ \\mathbb{E}[N_{a, \\text{search}}] = \\rho_a \\cdot V_{\\text{search}} = (\\rho m_a) \\cdot (27 r_c^3) $$\n这个量代表了每个供体位点的距离评估期望次数，因此 $\\mathbb{E}[E_{\\text{per donor}}] = \\mathbb{E}[N_{a, \\text{search}}]$。\n\n我们现在可以为每帧的总期望距离评估次数 $\\mathbb{E}[E]$ 建立表达式：\n$$ \\mathbb{E}[E] = N_d \\cdot \\mathbb{E}[N_{a, \\text{search}}] = (N m_d) \\cdot (27 \\rho m_a r_c^3) $$\n$$ \\mathbb{E}[E] = 27 N m_d m_a \\rho r_c^3 $$\n\n这就完成了任务的第一部分：推导。为确定其标度关系，我们分析此表达式。对于给定热力学状态下的给定流体，参数 $m_d$、$m_a$、$\\rho$ 和 $r_c$ 都是常数。因此，总计算期望次数 $\\mathbb{E}[E]$ 与分子数 $N$ 成正比。\n$$ \\mathbb{E}[E] \\propto N $$\n评估期望次数的标度关系与系统尺寸呈线性关系，记为 $O(N)$。\n\n任务的第二部分是使用提供的参数计算 $\\mathbb{E}[E]$ 的数值：\n- $N = 1.0 \\times 10^{5}$\n- $\\rho = 3.34 \\times 10^{1}\\ \\mathrm{nm}^{-3}$\n- $m_d = 2$\n- $m_a = 2$\n- $r_c = 3.5 \\times 10^{-1}\\ \\mathrm{nm}$\n\n将这些值代入推导出的公式中：\n$$ \\mathbb{E}[E] = 27 \\cdot (1.0 \\times 10^{5}) \\cdot (2) \\cdot (2) \\cdot (3.34 \\times 10^{1}\\ \\mathrm{nm}^{-3}) \\cdot (3.5 \\times 10^{-1}\\ \\mathrm{nm})^3 $$\n单位 $(\\mathrm{nm}^{-3}) \\cdot (\\mathrm{nm})^3$ 相消，得到一个预期的无量纲计数。让我们来计算数值结果。\n$$ (3.5 \\times 10^{-1})^3 = 3.5^3 \\times (10^{-1})^3 = 42.875 \\times 10^{-3} $$\n$$ \\mathbb{E}[E] = 27 \\cdot (1.0 \\times 10^{5}) \\cdot 4 \\cdot (33.4) \\cdot (42.875 \\times 10^{-3}) $$\n$$ \\mathbb{E}[E] = (27 \\cdot 4 \\cdot 33.4 \\cdot 42.875) \\cdot (10^5 \\cdot 10^{-3}) $$\n$$ \\mathbb{E}[E] = (108 \\cdot 33.4 \\cdot 42.875) \\cdot 10^2 $$\n$$ \\mathbb{E}[E] = (3607.2 \\cdot 42.875) \\cdot 10^2 $$\n$$ \\mathbb{E}[E] = 154651.5 \\cdot 10^2 $$\n$$ \\mathbb{E}[E] = 15,465,150 $$\n用标准科学记数法表示，这等于 $1.546515 \\times 10^7$。\n\n问题要求最终答案四舍五入到四位有效数字。\n$$ \\mathbb{E}[E] \\approx 1.547 \\times 10^7 $$", "answer": "$$ \\boxed{1.547 \\times 10^{7}} $$", "id": "3416805"}, {"introduction": "能够正确并高效地检测氢键为我们分析其动力学性质打开了大门，例如氢键的寿命。本练习将指导您实现一个流式（在线）算法来计算氢键自相关函数，这是一种衡量氢键持续时间的常用方法。您将学习如何在有界内存的约束下处理超长轨迹，这对于处理现代模拟产生海量数据的挑战至关重要。[@problem_id:3416818]", "problem": "您的任务是设计并实现一个用于分子动力学（MD）轨迹的流式（在线）氢键检测器，该检测器使用有界内存计算运行估计值，并与完整的离线分析进行验证。该检测器必须处理一系列水分子的笛卡尔坐标，并生成两种统计数据：(i) 每帧氢键数量的时间平均值，记为 $\\langle n_{\\mathrm{HB}}\\rangle$，以及 (ii) 在离散的帧延迟 $k \\in \\{0,1,\\dots,L\\}$ 处的间歇性氢键自相关函数 $C(k)$，其中 $L$ 是一个小的非负整数。\n\n氢键将使用以下几何规则确定，该规则源自简单的矢量几何和公认的分子标准：\n\n- 供体是一个水分子的氧原子及其两个氢原子之一。\n- 受体是一个水分子的氧原子。\n- 禁止分子内氢键（供体和受体必须属于不同的水分子）。\n- 在供体氧 $D$（及其连接的氢 $H$）和受体氧 $A$ 之间存在氢键，当且仅当以下两个条件同时成立：\n  1. 供体-受体距离最多为一个截断值，$| \\mathbf{r}_{A} - \\mathbf{r}_{D} | \\le r_c$。\n  2. 供体-氢-受体角满足 $\\theta = \\angle D\\text{–}H\\cdots A \\ge \\theta_{\\min}$，其中 $\\theta$ 是向量 $\\mathbf{r}_{D}-\\mathbf{r}_{H}$ 和 $\\mathbf{r}_{A}-\\mathbf{r}_{H}$ 之间的夹角，使用点积定义计算。角度必须以度为单位计算。\n\n在每一帧 $t$，定义一个供体-受体对 $(D,A)$ 的集合 $S(t)$，对于集合中的每一对，与 $D$ 相连的至少一个氢原子满足氢键的几何标准。每一对 $(D,A)$ 每帧只计数一次，无论有多少个氢原子满足角度标准。第 $t$ 帧的氢键总数为 $n_{\\mathrm{HB}}(t) = |S(t)|$。\n\n设 $T$ 为总帧数。时间平均值 $\\langle n_{\\mathrm{HB}}\\rangle$ 是样本平均值\n$$\n\\langle n_{\\mathrm{HB}}\\rangle = \\frac{1}{T}\\sum_{t=0}^{T-1} n_{\\mathrm{HB}}(t).\n$$\n将整数延迟 $k \\in \\{0,\\dots,L\\}$ 的间歇性氢键自相关函数定义为\n$$\nC(k) = \\frac{\\sum\\limits_{t=0}^{T-1-k} \\sum\\limits_{(D,A)} \\mathbb{1}\\!\\left[(D,A) \\in S(t)\\right] \\, \\mathbb{1}\\!\\left[(D,A) \\in S(t+k)\\right]}{\\sum\\limits_{t=0}^{T-1-k} \\sum\\limits_{(D,A)} \\mathbb{1}\\!\\left[(D,A) \\in S(t)\\right]} \\,,\n$$\n这等价于\n$$\nC(k) = \\frac{\\sum\\limits_{t=0}^{T-1-k} | S(t) \\cap S(t+k) |}{\\sum\\limits_{t=0}^{T-1-k} | S(t) |}.\n$$\n根据构造，当分母非零时，$C(0) = 1$。\n\n您的程序必须同时实现：\n- 一个流式估计器，它逐帧处理，维持不随 $T$ 增长的有界内存（它可以随 $L$ 以及最近 $L$ 帧中瞬时氢键对的数量增长），并在不存储整个轨迹的情况下，增量更新 $\\langle n_{\\mathrm{HB}}\\rangle$ 和 $C(k)$（对于 $k \\in \\{0,\\dots,L\\}$）。\n- 一个完整的离线分析，它从所有帧的 $S(t)$ 中精确计算 $\\langle n_{\\mathrm{HB}}\\rangle$ 和 $C(k)$。\n\n核心算法要求必须源自以下基本原则：\n- 三维欧几里得距离：对于向量 $\\mathbf{a}$ 和 $\\mathbf{b}$，距离为 $|\\mathbf{a}-\\mathbf{b}| = \\sqrt{(a_x-b_x)^2 + (a_y-b_y)^2 + (a_z-b_z)^2}$。\n- 非零向量 $\\mathbf{u}$ 和 $\\mathbf{v}$ 之间的夹角 $\\theta$ 满足 $\\cos \\theta = \\dfrac{\\mathbf{u}\\cdot \\mathbf{v}}{\\|\\mathbf{u}\\| \\, \\|\\mathbf{v}\\|}$；使用反余弦计算 $\\theta$（以弧度为单位），然后转换为度。\n- 时间平均值和自相关应如上所述，使用样本和进行计算。\n\n单位和约定：\n- 所有距离都必须以埃（ångström）为单位，记为 $\\mathrm{\\AA}$。\n- 所有角度都必须以度为单位。\n- 供体和受体是为水分子定义的，每个分子的原子顺序为 $(\\mathrm{O}, \\mathrm{H}, \\mathrm{H})$。每个水分子贡献一个带有两个氢原子的供体氧和一个受体氧（是同一个氧原子）。\n\n实现三个测试用例。对于每个用例，提供氢键截断值 $r_c$ 和 $\\theta_{\\min}$、延迟上限 $L$ 以及轨迹坐标。您的代码必须使用这些精确值。\n\n所有测试用例的全局参数：\n- 截断距离 $r_c = 3.5\\,\\mathrm{\\AA}$。\n- 角度阈值 $\\theta_{\\min} = 150.0$ 度。\n- 最大延迟 $L = 2$ 帧。\n- 每个原子的坐标都以埃为单位。不应用周期性边界条件。\n\n测试用例 A（正常路径；氢键形成后断裂）：\n- 两个水分子，共 $6$ 帧。\n- 分子 $1$ 的原子：$\\mathrm{O}_1=(0,0,0)$; $\\mathrm{H}_{1a}=(1,0,0)$; $\\mathrm{H}_{1b}=(0,1,0)$，所有帧均如此。\n- 帧 $t \\in \\{0,1,2\\}$ 中分子 $2$ 的原子：$\\mathrm{O}_2=(2.8,0,0)$; $\\mathrm{H}_{2a}=(2.8,1,0)$; $\\mathrm{H}_{2b}=(2.8,0,1)$。\n- 帧 $t \\in \\{3,4,5\\}$ 中分子 $2$ 的原子：$\\mathrm{O}_2=(6.0,0,0)$; $\\mathrm{H}_{2a}=(6.0,1,0)$; $\\mathrm{H}_{2b}=(6.0,0,1)$。\n\n测试用例 B（边界包容性；在两个阈值处均相等）：\n- 两个水分子，共 $4$ 个相同的帧。\n- 分子 $1$ 的原子固定：$\\mathrm{O}_1=(0,0,0)$; $\\mathrm{H}_{1a}=(1,0,0)$; $\\mathrm{H}_{1b}=(0,1,0)$。\n- 分子 $2$ 的氧位于 $\\mathrm{O}_2 = \\left(3.25,\\; \\frac{1}{4}\\sqrt{27},\\; 0\\right)$，这意味着在 $\\mathrm{H}_{1a}$ 处，$|\\mathrm{O}_2 - \\mathrm{O}_1| = 3.5\\,\\mathrm{\\AA}$ 且 $\\angle \\mathrm{D}\\text{–}\\mathrm{H}\\cdots \\mathrm{A} = 150.0$ 度；氢原子 $\\mathrm{H}_{2a} = \\mathrm{O}_2 + (0,1,0)$ 和 $\\mathrm{H}_{2b} = \\mathrm{O}_2 + (0,0,1)$。\n\n测试用例 C（多对与切换；测试对级别的相关性）：\n- 三个水分子，共 $4$ 帧。\n- 分子 $1$ 固定：$\\mathrm{O}_1=(0,0,0)$; $\\mathrm{H}_{1a}=(1,0,0)$; $\\mathrm{H}_{1b}=(-1,0,0)$，所有帧均如此。\n- 分子 $2$ 的氢原子正交设置：$\\mathrm{H}_{2a}=\\mathrm{O}_2 + (0,1,0)$; $\\mathrm{H}_{2b}=\\mathrm{O}_2 + (0,0,1)$，所有帧均如此。\n- 分子 $3$ 的氢原子正交设置：$\\mathrm{H}_{3a}=\\mathrm{O}_3 + (0,1,0)$; $\\mathrm{H}_{3b}=\\mathrm{O}_3 + (0,0,1)$，所有帧均如此。\n- 按帧划分的氧原子位置：\n  - 帧 $0$: $\\mathrm{O}_2=(2.9,0,0)$; $\\mathrm{O}_3=(-2.9,0,0)$。\n  - 帧 $1$: $\\mathrm{O}_2=(2.9,0,0)$; $\\mathrm{O}_3=(-6.0,0,0)$。\n  - 帧 $2$: $\\mathrm{O}_2=(6.0,0,0)$; $\\mathrm{O}_3=(-2.9,0,0)$。\n  - 帧 $3$: $\\mathrm{O}_2=(2.9,0,0)$; $\\mathrm{O}_3=(-2.9,0,0)$。\n\n您的实现要求：\n- 每帧的氢键检测必须仅使用指定的几何标准。对于每个供体-受体对 $(D,A)$，如果供体的任何一个氢原子与距离标准同时满足角度标准，则该对在该帧的 $S(t)$ 中计数一次。\n- 流式算法必须维护：\n  - 使用每次接收到新帧时进行增量更新的方式，来维护 $\\langle n_{\\mathrm{HB}}\\rangle$ 的一个运行估计值。\n  - 对于每个延迟 $k \\in \\{0,\\dots,L\\}$，维护运行中的分子和分母，以便在处理帧 $t$ 时，仅使用最后 $L$ 个存储的集合 $S(t')$ 来更新时间起点为 $t-k$ 的对的贡献。\n  - 有界内存，最多存储最后 $L$ 个集合 $S(t)$ 和聚合计数器。\n- 离线算法必须为所有帧计算精确的 $S(t)$，然后使用上述定义直接计算 $\\langle n_{\\mathrm{HB}}\\rangle$ 和 $C(k)$。\n\n验证目标和输出：\n- 对于每个测试用例，计算流式和离线估计的 $\\langle n_{\\mathrm{HB}}\\rangle$ 的绝对差，以及 $C(k)$ 在 $k \\in \\{0,1,2\\}$ 上的最大绝对差。对于每个测试用例，将这两个绝对差中的最大值报告为一个浮点数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表的结果（例如，$[x_A,x_B,x_C]$），其中 $x_A$、$x_B$ 和 $x_C$ 分别是测试用例 A、B 和 C 的结果。在整个过程中，距离必须解释为 $\\mathrm{\\AA}$，角度必须解释为度。输出的数字应为标准十进制浮点数。\n\n覆盖性设计：\n- 测试用例 A 检验了氢键持续几帧然后消失的一般操作。\n- 测试用例 B 检验了在恰好为 $r_c$ 和 $\\theta_{\\min}$ 时的边界包容性，由于不等式是包含性的，这种情况必须计为成键。\n- 测试用例 C 检验了多个同时存在的氢键以及不同供体-受体对之间的切换，强调了正确的对级别相关性逻辑。\n\n您的任务是实现一个完整的、可运行的程序，该程序构建上述轨迹，执行两种分析，并打印所需的单行输出。", "solution": "用户提供的问题是分子动力学（MD）模拟分析领域中一个明确定义的计算任务。它要求实现两种算法——一种离线（批量）和一种在线（流式）——以从原子坐标轨迹中计算氢键统计数据。目标是根据精确的离线计算来验证流式算法。问题陈述在科学上是合理的，在数学上是精确的，在算法上是完整的。因此，提供一个解决方案是必要的。\n\n### 氢键检测原理\n\n氢键是一种非共价相互作用，对许多化学体系（尤其是水）的结构至关重要。问题指定了一种常见的几何定义，该定义基于供体氧（$D$）、其共价键合的氢（$H$）和受体氧（$A$）的相对位置。当且仅当满足两个条件时，氢键存在：\n1.  供体和受体氧原子之间的距离小于或等于一个截断值，$|\\mathbf{r}_{A} - \\mathbf{r}_{D}| \\le r_c$。\n2.  由供体氧、氢和受体氧形成的角大于或等于一个最小阈值，$\\theta = \\angle D\\text{–}H\\cdots A \\ge \\theta_{\\min}$。\n\n这些几何标准是使用三维欧几里得空间中矢量代数的基本原理计算的。给定原子的笛卡尔坐标，距离的平方计算为 $(\\mathbf{r}_A - \\mathbf{r}_D) \\cdot (\\mathbf{r}_A - \\mathbf{r}_D)$。角 $\\theta$ 是通过定义夹角两臂的向量 $\\mathbf{u} = \\mathbf{r}_D - \\mathbf{r}_H$ 和 $\\mathbf{v} = \\mathbf{r}_A - \\mathbf{r}_H$ 的点积导出的，通过以下关系式：\n$$\n\\cos \\theta = \\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\| \\|\\mathbf{v}\\|}\n$$\n然后通过取反余弦并从弧度转换为度来找到角 $\\theta$。对于每一帧 $t$，我们识别出形成至少一个氢键的所有唯一供体-受体分子对 $(D, A)$ 的集合 $S(t)$。该帧中的氢键数则为 $n_{\\mathrm{HB}}(t) = |S(t)|$。\n\n### 统计分析：离线与在线算法\n\n问题要求计算两个关键的统计量：氢键数量的时间平均值 $\\langle n_{\\mathrm{HB}}\\rangle$ 和间歇性氢键自相关函数 $C(k)$。\n\n**1. 离线（批量）算法**\n\n离线算法代表了一种标准的两遍（two-pass）分析。\n-   **遍（Pass）1**：遍历从 $0$ 到 $T-1$ 的所有帧 $t$。对于每一帧，将几何标准应用于所有可能的供体-受体对，以计算成键对的集合 $S(t)$。将所有这些集合存储在内存中，例如，存储在一个列表 `[S(0), S(1), ..., S(T-1)]` 中。\n-   **遍（Pass）2**：在所有 $S(t)$ 都可用的情况下，直接根据其定义计算最终统计数据：\n    -   平均氢键数为 $\\langle n_{\\mathrm{HB}}\\rangle = \\frac{1}{T}\\sum_{t=0}^{T-1} |S(t)|$。\n    -   对于每个延迟 $k \\in \\{0, \\dots, L\\}$，自相关函数为 $C(k) = \\frac{\\sum_{t=0}^{T-1-k} | S(t) \\cap S(t+k) |}{\\sum_{t=0}^{T-1-k} | S(t) |}$。这涉及对每个延迟 $k$ 遍历适当的时间窗口，并使用预先计算的集合 $S(t)$。\n\n这种方法简单直接，但内存密集，因为它需要存储整个轨迹的信息。\n\n**2. 在线（流式）算法**\n\n在线算法一次处理一帧轨迹，并以有界内存增量更新统计数据，该内存不会随总帧数 $T$ 扩展。\n\n-   **内存**：该算法维护用于统计的运行总和以及一个用于存储最近 $L+1$ 帧氢键集的小型缓冲区。循环缓冲区是完成此任务的有效数据结构。\n-   **处理帧 $t$**：在接收到帧 $t$ 的坐标后：\n    1.  计算当前的氢键集合 $S(t)$ 及其大小 $n_{\\mathrm{HB}}(t)$。\n    2.  更新平均值的运行总和：一个运行总计 $\\Sigma_n$ 增加 $n_{\\mathrm{HB}}(t)$。在帧 $t$ 的平均值为 $\\frac{\\Sigma_n}{t+1}$。\n    3.  将 $S(t)$ 存储在循环缓冲区中，覆盖来自帧 $t-(L+1)$ 的数据。\n    4.  更新 $C(k)$ 的运行总和。对于每个延迟 $k \\in \\{0, \\dots, L\\}$，如果 $t \\ge k$，则帧对 $(t-k, t)$ 对相关性有贡献。我们从缓冲区中检索历史集合 $S(t-k)$，并计算其与 $S(t)$ 的交集。\n        -   $C(k)$ 的分子总和增加 $|S(t-k) \\cap S(t)|$。\n        -   $C(k)$ 的分母总和增加 $|S(t-k)|$。\n\n处理完所有帧后，通过将累积的总和相除来计算最终统计数据。这种在线方法在数学上与离线方法等效，并且将产生相同的结果，除非存在浮点精度问题。问题要求计算两者之间的差异，这是一种验证流式实现正确性的稳健方法。\n\n### 实现与验证\n\n提供的解决方案将实现这两种算法。一个核心函数执行每帧的氢键检测。离线和流式函数将调用此核心函数，但如上所述以不同方式管理数据和计算。测试用例旨在检验各种场景：简单的键形成/解离事件（A）、几何标准的边界条件（B）以及多个竞争性键合伙伴（C）。最终输出报告两种方法结果之间的最大绝对差，预计将是一个零数组，从而证实了在线算法设计和实现的正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\n# Global parameters from the problem statement\nR_C = 3.5  # Angstrom\nTHETA_MIN = 150.0  # degrees\nL_MAX = 2\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run analyses, and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {\n            \"num_molecules\": 2,\n            \"num_frames\": 6,\n            \"get_coords\": lambda t: np.array([\n                [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]],\n                [[2.8, 0.0, 0.0], [2.8, 1.0, 0.0], [2.8, 0.0, 1.0]]\n            ]) if t  3 else np.array([\n                [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]],\n                [[6.0, 0.0, 0.0], [6.0, 1.0, 0.0], [6.0, 0.0, 1.0]]\n            ])\n        },\n        # Test Case B\n        {\n            \"num_molecules\": 2,\n            \"num_frames\": 4,\n            \"get_coords\": lambda t: np.array([\n                [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]],\n                [\n                    [3.25, np.sqrt(27)/4.0, 0.0],\n                    [3.25, np.sqrt(27)/4.0 + 1.0, 0.0],\n                    [3.25, np.sqrt(27)/4.0, 1.0]\n                ]\n            ])\n        },\n        # Test Case C\n        {\n            \"num_molecules\": 3,\n            \"num_frames\": 4,\n            \"get_coords\": lambda t: np.array([\n                [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [-1.0, 0.0, 0.0]],\n                *({\n                    0: [[[2.9,0,0],[2.9,1,0],[2.9,0,1]],[[-2.9,0,0],[-2.9,1,0],[-2.9,0,1]]],\n                    1: [[[2.9,0,0],[2.9,1,0],[2.9,0,1]],[[-6.0,0,0],[-6.0,1,0],[-6.0,0,1]]],\n                    2: [[[6.0,0,0],[6.0,1,0],[6.0,0,1]],[[-2.9,0,0],[-2.9,1,0],[-2.9,0,1]]],\n                    3: [[[2.9,0,0],[2.9,1,0],[2.9,0,1]],[[-2.9,0,0],[-2.9,1,0],[-2.9,0,1]]]\n                }[t])\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        trajectory = [case[\"get_coords\"](t) for t in range(case[\"num_frames\"])]\n        \n        n_hb_offline, c_k_offline = offline_analyzer(trajectory, case[\"num_molecules\"])\n        n_hb_streaming, c_k_streaming = streaming_analyzer(trajectory, case[\"num_molecules\"])\n        \n        diff_n_hb = abs(n_hb_offline - n_hb_streaming)\n        diff_c_k = np.max(np.abs(np.array(c_k_offline) - np.array(c_k_streaming)))\n        \n        results.append(max(diff_n_hb, diff_c_k))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef detect_hbonds_frame(coords, num_molecules):\n    \"\"\"\n    Detects hydrogen bonds in a single frame based on geometric criteria.\n    - coords: (num_molecules, 3 atoms, 3 coords) numpy array\n    Returns a set of (donor_idx, acceptor_idx) tuples.\n    \"\"\"\n    hbond_pairs = set()\n    for d_idx in range(num_molecules):\n        for a_idx in range(num_molecules):\n            if d_idx == a_idx:\n                continue\n\n            r_d = coords[d_idx, 0]\n            r_a = coords[a_idx, 0]\n\n            dist_vec = r_a - r_d\n            dist_sq = np.dot(dist_vec, dist_vec)\n            if dist_sq > R_C**2:\n                continue\n            \n            # Distance criterion met, check angles\n            is_h_bonded = False\n            for h_idx in [1, 2]: # H1 and H2\n                r_h = coords[d_idx, h_idx]\n                \n                vec_dh = r_d - r_h\n                vec_ah = r_a - r_h\n\n                norm_dh = np.linalg.norm(vec_dh)\n                norm_ah = np.linalg.norm(vec_ah)\n\n                if norm_dh == 0 or norm_ah == 0:\n                    continue\n\n                cos_theta = np.dot(vec_dh, vec_ah) / (norm_dh * norm_ah)\n                # Clamp cos_theta to handle potential floating point inaccuracies\n                cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                \n                theta_rad = np.arccos(cos_theta)\n                theta_deg = np.rad2deg(theta_rad)\n\n                if theta_deg >= THETA_MIN:\n                    is_h_bonded = True\n                    break # Pair is counted once\n\n            if is_h_bonded:\n                hbond_pairs.add((d_idx, a_idx))\n    \n    return hbond_pairs\n\ndef offline_analyzer(trajectory, num_molecules):\n    \"\"\"\n    Computes H-bond statistics by processing the entire trajectory in batch.\n    \"\"\"\n    num_frames = len(trajectory)\n    if num_frames == 0:\n        return 0.0, [1.0] + [0.0] * L_MAX\n\n    all_s_t = [detect_hbonds_frame(coords, num_molecules) for coords in trajectory]\n    n_hb_list = [len(s) for s in all_s_t]\n\n    # Calculate avg(n_HB)\n    avg_n_hb = np.mean(n_hb_list) if n_hb_list else 0.0\n\n    # Calculate C(k)\n    c_k = []\n    for k in range(L_MAX + 1):\n        if num_frames = k:\n            c_k.append(0.0) # Not enough frames for this lag\n            continue\n        \n        numerator = 0.0\n        denominator = 0.0\n        for t in range(num_frames - k):\n            numerator += len(all_s_t[t].intersection(all_s_t[t+k]))\n            denominator += len(all_s_t[t])\n        \n        c_k.append(numerator / denominator if denominator > 0 else (1.0 if k == 0 else 0.0))\n\n    return avg_n_hb, c_k\n\ndef streaming_analyzer(trajectory, num_molecules):\n    \"\"\"\n    Computes H-bond statistics by processing the trajectory frame by frame.\n    \"\"\"\n    num_frames = len(trajectory)\n    if num_frames == 0:\n        return 0.0, [1.0] + [0.0] * L_MAX\n\n    sum_n_hb = 0.0\n    \n    c_k_numerators = np.zeros(L_MAX + 1)\n    c_k_denominators = np.zeros(L_MAX + 1)\n    \n    s_buffer = collections.deque(maxlen=L_MAX + 1)\n\n    for t in range(num_frames):\n        coords = trajectory[t]\n        current_s = detect_hbonds_frame(coords, num_molecules)\n        current_n_hb = len(current_s)\n        \n        # Update mean n_HB\n        sum_n_hb += current_n_hb\n        \n        s_buffer.append(current_s)\n        \n        # Update C(k)\n        for k in range(L_MAX + 1):\n            if t >= k:\n                # The pair of frames is (t-k, t)\n                # s_buffer[len-1] is current_s, s_buffer[len-1-k] is S(t-k)\n                past_s = s_buffer[len(s_buffer) - 1 - k]\n                c_k_numerators[k] += len(past_s.intersection(current_s))\n                c_k_denominators[k] += len(past_s)\n\n    avg_n_hb = sum_n_hb / num_frames if num_frames > 0 else 0.0\n    \n    c_k = []\n    for k in range(L_MAX + 1):\n        if c_k_denominators[k] > 0:\n            c_k.append(c_k_numerators[k] / c_k_denominators[k])\n        else:\n            # Handle cases with no bonds, C(0) should be 1 if any frame with bonds exists,\n            # but if no bonds ever, denominator will be 0.\n            c_k.append(1.0 if k == 0 and sum_n_hb > 0 else 0.0)\n            if k == 0 and sum_n_hb == 0: c_k[-1] = 1.0 # C(0) is 1 by convention if frames exist.\n            if num_frames = k: c_k[-1] = 0.0 # Match offline behavior if trajectory is too short\n    \n    # Special case, C(0) is 1 if there's at least one frame.\n    if num_frames > 0:\n        sum_of_hb_counts = c_k_denominators[0]\n        c_k[0] = 1.0 if sum_of_hb_counts > 0 else (1.0 if num_frames > 0 else 0.0)\n\n    # If num_frames is small, some lags may not be computable\n    for k in range(L_MAX + 1):\n        if num_frames = k:\n            c_k[k] = 0.0\n\n    return avg_n_hb, c_k\n\n\n# Execute the solution\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3416818"}]}