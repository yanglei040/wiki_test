{"hands_on_practices": [{"introduction": "在分子动力学模拟中，选择合适的积分算法至关重要。本练习将从最简单的显式欧拉法入手，通过模拟一个Lennard-Jones双原子体系，您将亲手实现该算法并量化其固有的能量漂移。通过这个实践[@problem_id:3412384]，您将深刻理解为何像显式欧拉法这样的非辛算法不适用于长时间的能量守恒模拟，并为学习更高级的算法（如Verlet积分法）打下基础。", "problem": "考虑两个质量为 $m$ 的相同点状粒子，它们在三维空间中通过Lennard–Jones势相互作用，并在简化的Lennard–Jones单位制中建模，其中 $m=1$，$\\varepsilon=1$ 且 $\\sigma=1$。在此单位制中，自然时间单位为 $\\tau=\\sigma\\sqrt{m/\\varepsilon}=1$。Lennard–Jones势定义为\n$$\nU(r) = 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right],\n$$\n粒子1受到粒子2的成对力由下式给出\n$$\n\\mathbf{F}_{12} = -\\nabla U(r) = 24\\varepsilon\\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\mathbf{r}}{r^2},\n$$\n其中 $\\mathbf{r}=\\mathbf{x}_1-\\mathbf{x}_2$ 且 $r=\\|\\mathbf{r}\\|$。系统根据牛顿第二定律演化，其总能量为\n$$\nE(t) = \\sum_{i=1}^{2}\\frac{1}{2}m\\|\\mathbf{v}_i(t)\\|^2 + U(\\|\\mathbf{x}_1(t)-\\mathbf{x}_2(t)\\|).\n$$\n你将使用经典动力学的显式欧拉有限差分法来近似动力学：\n$$\n\\mathbf{x}_i^{n+1} = \\mathbf{x}_i^n + \\Delta t\\,\\mathbf{v}_i^n,\\quad\n\\mathbf{v}_i^{n+1} = \\mathbf{v}_i^n + \\Delta t\\,\\mathbf{a}_i(\\mathbf{x}_1^n,\\mathbf{x}_2^n),\n$$\n其中 $\\mathbf{a}_i=\\mathbf{F}_i/m$，$\\Delta t$ 是时间步长。\n\n初始化：设 $r_{\\mathrm{eq}}=2^{1/6}\\sigma$ 为Lennard–Jones势能最小值的平衡间距。沿 $x$ 轴对称地设置初始位置，使得质心位于原点，\n$$\n\\mathbf{x}_1(0)=\\left(\\frac{r_0}{2},0,0\\right),\\quad \\mathbf{x}_2(0)=\\left(-\\frac{r_0}{2},0,0\\right),\n$$\n其中 $r_0=r_{\\mathrm{eq}}(1+a)$ 且 $a=0.02$。将初始速度设置为零，即 $\\mathbf{v}_1(0)=\\mathbf{0}$ 和 $\\mathbf{v}_2(0)=\\mathbf{0}$。在整个过程中使用简化单位制 $m=1$, $\\varepsilon=1$ 和 $\\sigma=1$。将系统演化总物理时间 $T=50\\tau$。\n\n任务：对于每个指定的时间步长 $\\Delta t$，使用上面定义的显式欧拉法，将系统从 $t=0$ 积分到 $t=T$。计算单位时间的全局能量漂移，\n$$\nD(\\Delta t) = \\frac{E(T)-E(0)}{T},\n$$\n以 $\\varepsilon/\\tau$ 为单位表示。报告 $D(\\Delta t)$，结果四舍五入到六位有效数字。\n\n从第一性原理出发，并结合势能最小值附近的适当线性化，解释为什么你观察到的 $D(\\Delta t)$ 对 $\\Delta t$ 的依赖关系会是这样。\n\n测试集：使用以下时间步长，均以 $\\tau$ 为单位，\n- $\\Delta t_1=5\\times 10^{-5}$,\n- $\\Delta t_2=2\\times 10^{-4}$,\n- $\\Delta t_3=8\\times 10^{-4}$,\n- $\\Delta t_4=1.2\\times 10^{-3}$.\n\n最终输出格式：你的程序应产生单行输出，其中包含计算出的漂移值 $[D(\\Delta t_1),D(\\Delta t_2),D(\\Delta t_3),D(\\Delta t_4)]$，形式为用方括号括起来的逗号分隔列表，每个条目四舍五入到六位有效数字，并且值以 $\\varepsilon/\\tau$ 为单位表示。", "solution": "出发点是牛顿第二定律，描述两个质量为 $m$ 的相同粒子通过中心势 $U(r)$ 相互作用，\n$$\nm\\ddot{\\mathbf{x}}_1 = \\mathbf{F}_{12},\\quad m\\ddot{\\mathbf{x}}_2 = \\mathbf{F}_{21}=-\\mathbf{F}_{12},\n$$\n其中 $\\mathbf{F}_{12}=-\\nabla U(r)$ 且 $r=\\|\\mathbf{x}_1-\\mathbf{x}_2\\|$。Lennard–Jones势为\n$$\nU(r)=4\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^6\\right],\n$$\n因此其径向导数为\n$$\n\\frac{dU}{dr}=4\\varepsilon\\left(-12\\frac{\\sigma^{12}}{r^{13}}+6\\frac{\\sigma^6}{r^7}\\right),\n$$\n并且力矢量由 $\\mathbf{F}=-\\frac{dU}{dr}\\frac{\\mathbf{r}}{r}$ 得出，如下所示\n$$\n\\mathbf{F}_{12}=4\\varepsilon\\left(12\\frac{\\sigma^{12}}{r^{14}}-6\\frac{\\sigma^6}{r^8}\\right)\\mathbf{r} = 24\\varepsilon\\left[2\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\mathbf{r}}{r^2}.\n$$\n总能量是动能和势能之和，\n$$\nE(t) = \\frac{1}{2}m\\|\\mathbf{v}_1(t)\\|^2 + \\frac{1}{2}m\\|\\mathbf{v}_2(t)\\|^2 + U(\\|\\mathbf{x}_1(t)-\\mathbf{x}_2(t)\\|).\n$$\n在连续时间下，对于精确动力学，$E(t)$ 是守恒的，因为力是保守的。当使用显式欧拉法进行离散化时，更新步骤为\n$$\n\\mathbf{x}_i^{n+1} = \\mathbf{x}_i^n + \\Delta t\\,\\mathbf{v}_i^n,\\quad \\mathbf{v}_i^{n+1} = \\mathbf{v}_i^n + \\Delta t\\,\\frac{\\mathbf{F}_i(\\mathbf{x}_1^n,\\mathbf{x}_2^n)}{m}.\n$$\n显式欧拉法是一种一阶方法，它不是辛的，并且对于哈密顿系统不保持能量；因此，预计会出现系统性的能量漂移。\n\n为了分析平衡点附近的 $\\Delta t$ 依赖性，我们在Lennard–Jones势能最小值处（间距为 $r_{\\mathrm{eq}}=2^{1/6}\\sigma$）对动力学进行线性化，在该点 $U'(r_{\\mathrm{eq}})=0$。对于小位移 $q=r-r_{\\mathrm{eq}}$，泰勒展开得到\n$$\nU(r) \\approx U(r_{\\mathrm{eq}}) + \\frac{1}{2}k\\,q^2,\\quad k=U''(r_{\\mathrm{eq}}).\n$$\n在 $m=1$ 且 $\\sigma=\\varepsilon=1$ 的简化单位制中，相对坐标服从小振荡的有效一维方程。对于两个等质量的粒子，相对坐标 $\\mathbf{r}=\\mathbf{x}_1-\\mathbf{x}_2$ 满足\n$$\n\\ddot{\\mathbf{r}} = \\frac{2}{m}\\mathbf{F}(\\mathbf{r}) \\approx -\\omega^2 \\mathbf{q},\\quad \\omega^2 = \\frac{k}{\\mu},\\quad \\mu=\\frac{m}{2}.\n$$\n此处，$\\mu$ 是约化质量，$\\mathbf{q}$ 是沿中心连线方向偏离平衡位置的位移。对于谐振子 $\\ddot{q}=-\\omega^2 q$，将显式欧拉法应用于一阶系统\n$$\n\\dot{q}=v,\\quad \\dot{v}=-\\omega^2 q\n$$\n的更新方式如下\n$$\n\\begin{pmatrix} q^{n+1} \\\\ v^{n+1} \\end{pmatrix}\n=\n\\begin{pmatrix}\n1  \\Delta t \\\\\n-\\omega^2 \\Delta t  1\n\\end{pmatrix}\n\\begin{pmatrix} q^{n} \\\\ v^{n} \\end{pmatrix}.\n$$\n该更新矩阵的特征值为\n$$\n\\lambda_{\\pm} = 1 \\pm i\\,\\omega\\,\\Delta t,\n$$\n其模为\n$$\n|\\lambda_{\\pm}| = \\sqrt{1+\\omega^2\\Delta t^2} = 1 + \\frac{1}{2}\\omega^2\\Delta t^2 + \\mathcal{O}(\\Delta t^4).\n$$\n因此，每个步长振幅增长一个因子 $|\\lambda|$，而能量（在谐振子近似下与振幅的平方成正比）每个步长增长一个因子\n$$\n|\\lambda|^2 = 1 + \\omega^2\\Delta t^2 + \\mathcal{O}(\\Delta t^4).\n$$\n因此，每步的能量增量为\n$$\n\\Delta E_{\\text{step}} \\approx \\omega^2 \\Delta t^2\\, E.\n$$\n在 $N=T/\\Delta t$ 个步长之后，总能量变化近似满足\n$$\nE(T) - E(0) \\approx N\\,\\Delta E_{\\text{step}} \\approx \\frac{T}{\\Delta t}\\,\\omega^2\\Delta t^2\\,E(0) = \\omega^2 E(0)\\, T\\, \\Delta t,\n$$\n这里忽略了高阶修正项和积分过程中 $E$ 的缓慢变化。除以 $T$ 得到单位时间的全局能量漂移，\n$$\nD(\\Delta t) = \\frac{E(T)-E(0)}{T} \\approx \\omega^2 E(0)\\,\\Delta t,\n$$\n对于足够小的 $\\Delta t$，该漂移与 $\\Delta t$ 成线性关系。这个论证依赖于最小值附近的线性化以及显式欧拉法的一阶性质；该方法的全局截断误差为 $\\mathcal{O}(\\Delta t)$，并且非辛离散化导致了能量的长期增长。\n\n算法设计：\n- 使用简化的Lennard–Jones单位制，其中 $m=\\varepsilon=\\sigma=1$，因此力和能量是无量纲的，时间以 $\\tau=1$ 的倍数度量。\n- 在 $r_0=r_{\\mathrm{eq}}(1+a)$ 处对称地初始化两个粒子（其中 $a=0.02$），初始速度为零，确保质心位于原点。\n- 实现显式欧拉法：\n  - 计算分离矢量 $\\mathbf{r}$、其模长 $r$ 以及Lennard–Jones力 $\\mathbf{F}_{12}$。\n  - 通过 $\\mathbf{x}_i^{n+1}=\\mathbf{x}_i^n+\\Delta t\\,\\mathbf{v}_i^n$ 更新位置。\n  - 通过 $\\mathbf{v}_1^{n+1}=\\mathbf{v}_1^n+\\Delta t\\,\\mathbf{F}_{12}/m$ 和 $\\mathbf{v}_2^{n+1}=\\mathbf{v}_2^n-\\Delta t\\,\\mathbf{F}_{12}/m$ 更新速度。\n- 计算 $t=0$ 和 $t=T$ 时的总能量，并报告 $D(\\Delta t)$ 为 $(E(T)-E(0))/T$。\n- 对测试集 $\\Delta t\\in\\{5\\times 10^{-5}, 2\\times 10^{-4}, 8\\times 10^{-4}, 1.2\\times 10^{-3}\\}$ 重复上述过程。\n- 将每个 $D(\\Delta t)$ 四舍五入到六位有效数字，并以 $\\varepsilon/\\tau$ 为单位输出。\n\n结果解释：\n- 对于最小的 $\\Delta t$，$D(\\Delta t)$ 应该非常小，并且与 $\\Delta t$ 近似成线性关系，这与从谐振子近似和显式欧拉方案性质推导出的单位时间 $\\mathcal{O}(\\Delta t)$ 全局能量漂移一致。\n- 在小步长范围内，随着 $\\Delta t$ 的增加，$D(\\Delta t)$ 近似与 $\\Delta t$ 成比例增加，从而验证了理论上的依赖关系。在较大的 $\\Delta t$ 下可能会出现偏差，这是由于线性近似的失效以及振荡幅度的增长，但其趋势仍然表明了该方法的一阶、非辛特性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lj_force(r_vec, epsilon=1.0, sigma=1.0):\n    \"\"\"\n    Compute the Lennard-Jones force vector on particle 1 due to particle 2.\n    r_vec: separation vector r = x1 - x2\n    \"\"\"\n    r2 = np.dot(r_vec, r_vec)\n    r = np.sqrt(r2)\n    # Avoid division by zero; if r is extremely small, cap the force direction\n    if r == 0.0:\n        return np.zeros_like(r_vec)\n    inv_r2 = 1.0 / r2\n    inv_r6 = (sigma**2 * inv_r2)**3  # (sigma/r)^6\n    inv_r12 = inv_r6**2              # (sigma/r)^12\n    # Force magnitude factor for vector form:\n    # F = 24*epsilon * [2*(sigma/r)^12 - (sigma/r)^6] * r_vec / r^2\n    factor = 24.0 * epsilon * (2.0 * inv_r12 - inv_r6) * inv_r2\n    return factor * r_vec\n\ndef lj_potential(r, epsilon=1.0, sigma=1.0):\n    \"\"\"\n    Compute Lennard-Jones potential U(r).\n    \"\"\"\n    inv_r6 = (sigma / r)**6\n    inv_r12 = inv_r6**2\n    return 4.0 * epsilon * (inv_r12 - inv_r6)\n\ndef total_energy(x1, v1, x2, v2, epsilon=1.0, sigma=1.0, m=1.0):\n    \"\"\"\n    Compute total energy: kinetic + potential.\n    \"\"\"\n    ke = 0.5 * m * np.dot(v1, v1) + 0.5 * m * np.dot(v2, v2)\n    r = np.linalg.norm(x1 - x2)\n    pe = lj_potential(r, epsilon=epsilon, sigma=sigma)\n    return ke + pe\n\ndef energy_drift_per_unit_time(dt, T=50.0, a=0.02, epsilon=1.0, sigma=1.0, m=1.0):\n    \"\"\"\n    Integrate the Lennard-Jones dimer with explicit Euler and compute\n    the global energy drift per unit time (E(T) - E(0)) / T.\n    Units: epsilon/tau, with tau=1 in reduced units.\n    \"\"\"\n    # Equilibrium separation for LJ minimum\n    r_eq = 2.0**(1.0/6.0) * sigma\n    r0 = r_eq * (1.0 + a)\n\n    # Initial positions and velocities (center of mass at origin)\n    x1 = np.array([0.5 * r0, 0.0, 0.0], dtype=float)\n    x2 = np.array([-0.5 * r0, 0.0, 0.0], dtype=float)\n    v1 = np.zeros(3, dtype=float)\n    v2 = np.zeros(3, dtype=float)\n\n    E0 = total_energy(x1, v1, x2, v2, epsilon=epsilon, sigma=sigma, m=m)\n\n    # Number of steps\n    N = int(np.floor(T / dt))\n    # Time integration via explicit Euler\n    for _ in range(N):\n        # Compute force on particle 1 due to particle 2\n        r_vec = x1 - x2\n        F12 = lj_force(r_vec, epsilon=epsilon, sigma=sigma)\n\n        # Update positions\n        x1 = x1 + dt * v1\n        x2 = x2 + dt * v2\n\n        # Update velocities\n        v1 = v1 + dt * (F12 / m)\n        v2 = v2 - dt * (F12 / m)\n\n    E_end = total_energy(x1, v1, x2, v2, epsilon=epsilon, sigma=sigma, m=m)\n    drift = (E_end - E0) / T  # Units: epsilon/tau in reduced units\n    return drift\n\ndef solve():\n    # Define the test cases from the problem statement (time steps in tau units).\n    test_cases = [\n        5e-5,\n        2e-4,\n        8e-4,\n        1.2e-3,\n    ]\n\n    results = []\n    for dt in test_cases:\n        d = energy_drift_per_unit_time(dt)\n        # Round to six significant figures as specified\n        results.append(f\"{d:.6g}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3412384"}, {"introduction": "即使使用了如Velocity Verlet这样的辛积分器，能量守恒也并非唾手可得，因为力的计算方式同样关键。在实际模拟中，势能面往往以离散表格的形式给出，本练习[@problem_id:3412357]将探讨如何从这些表格数据中计算作用力。您将比较对称的中心差分格式与非对称的前向/后向差分格式，并通过数值实验揭示力场计算的非对称性如何破坏辛积分器的能量守恒特性。", "problem": "考虑一个质量为 $m$ 的单个经典粒子，在一个空间维度中，受标量势能函数 $V_{\\text{true}}(r)$ 的作用运动。其运动遵循牛顿第二定律 $m\\,d^2 r/dt^2 = F(r)$，其中 $F(r)$ 是作为位置 $r$ 函数的力。在分子动力学中，力通常是通过有限差分法，根据网格上 $V(r)$ 的列表值计算得出。您的任务是实现并比较三种基于列表势能构建的有限差分力估算器，然后使用速度Verlet (VV) 方法对运动方程进行积分，以量化由非对称力离散化引起的系统性能量漂移。\n\n使用以下物理上合理且平滑的双势阱作为参考势能：\n$$\nV_{\\text{true}}(r) = \\tfrac{1}{4}\\,r^4 - \\tfrac{1}{2}\\,r^2.\n$$\n\n在均匀网格 $r_i = r_{\\min} + i\\,h$（其中 $i=0,1,\\dots,n-1$）上将此势能制成列表，其中 $r_{\\min}=-2$，$r_{\\max}=2$，间距 $h$ 由每个测试案例指定。列表值为 $V_i = V_{\\text{true}}(r_i)$。对于积分过程中遇到的任何网格点外位置 $r$，定义单元格索引\n$$\ni = \\left\\lfloor \\frac{r - r_{\\min}}{h} \\right\\rfloor,\n$$\n并约束数组访问，以使其在各种方案中均保持在有效索引范围内。根据列表值 $V_i$，定义三种力估算器 $F_{\\text{fd}}(r)$ 如下：\n- 前向差分（在当前单元格 $[r_i,r_{i+1})$ 上的分段常数斜率）：\n$$\nF_{\\text{fwd}}(r) = -\\frac{V_{i+1} - V_{i}}{h}.\n$$\n- 后向差分（在前一个单元格 $[r_{i-1},r_{i})$ 上的斜率）：\n$$\nF_{\\text{bwd}}(r) = -\\frac{V_{i} - V_{i-1}}{h}.\n$$\n- 中心差分（跨越 $[r_{i-1},r_{i+1}]$ 的对称两点斜率）：\n$$\nF_{\\text{cen}}(r) = -\\frac{V_{i+1} - V_{i-1}}{2h}.\n$$\n\n使用速度Verlet (VV) 算法对运动方程进行积分，该算法基于牛顿第二定律和速度定义 $v = dr/dt$ 构建，以恒定时间步长 $\\Delta t$（由每个测试案例指定）来推进位置 $r$ 和速度 $v$随时间的变化。在VV更新步骤中，使用所选的 $F_{\\text{fd}}(r)$ 来计算加速度 $a(r) = F_{\\text{fd}}(r)/m$。在整个模拟过程中，使用参考势能计算瞬时总能量，\n$$\nE(t) = \\tfrac{1}{2}\\,m\\,v(t)^2 + V_{\\text{true}}(r(t)).\n$$\n通过对整个模拟轨迹上的 $E(t)$ 与 $t$ 进行普通最小二乘线性回归来量化系统性能量漂移，并报告每个测试案例的最佳拟合斜率 $dE/dt$ 作为单个标量。每个报告的斜率都以单位时间的能量单位表示。\n\n以下测试套件指定了所有参数。对于每个案例，使用 $m=1$（无量纲质量）、初始位置 $r(0)=1.2$ 和初始速度 $v(0)=0$。对于所有案例，取 $r_{\\min}=-2$ 和 $r_{\\max}=2$。对于每个案例，模拟 $N_{\\text{steps}}$ 个大小为 $\\Delta t$ 的时间步，并如上所述计算最小二乘斜率 $dE/dt$。\n\n- 案例 1（理想情况，细网格，对称力）：方案 = 中心差分，$h=0.02$，$\\Delta t = 0.02$，$N_{\\text{steps}}=30000$。\n- 案例 2（细网格，非对称前向力）：方案 = 前向差分，$h=0.02$，$\\Delta t = 0.02$，$N_{\\text{steps}}=30000$。\n- 案例 3（细网格，非对称后向力）：方案 = 后向差分，$h=0.02$，$\\Delta t = 0.02$，$N_{\\text{steps}}=30000$。\n- 案例 4（粗网格，对称力）：方案 = 中心差分，$h=0.20$，$\\Delta t = 0.02$，$N_{\\text{steps}}=30000$。\n- 案例 5（粗网格，非对称前向力）：方案 = 前向差分，$h=0.20$，$\\Delta t = 0.02$，$N_{\\text{steps}}=30000$。\n- 案例 6（粗网格，非对称后向力）：方案 = 后向差分，$h=0.20$，$\\Delta t = 0.02$，$N_{\\text{steps}}=30000$。\n\n您的程序必须完全按照定义实现列表和力估算器，使用从牛顿定律推导出的标准速度Verlet算法，并计算每个案例的最小二乘斜率。如果由于数值误差，$r$ 离开了列表区间 $[r_{\\min}, r_{\\max}]$，请约束有限差分索引以确保数组访问保持有效并继续积分；不要施加任何额外的边界力。\n\n最终输出格式要求：\n- 生成单行输出，包含从案例1到案例6的六个漂移率，以单位时间的能量单位表示。该行必须是方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3,x_4,x_5,x_6]$。允许使用科学记数法。不得打印任何其他文本。", "solution": "该问题要求研究速度Verlet积分算法在与不同的力计算有限差分方案结合使用时，其长期能量守恒特性。我们将模拟一个经典粒子的一维运动，并量化由数值不精确性（特别是由力估算器的非对称性）引起的系统性能量漂移。\n\n该粒子质量为 $m$，其運動遵循牛顿第二定律 $m\\ddot{r} = F(r)$，其中 $r$ 是位置，$F(r)$ 是力。真实的物理系统由一个平滑、连续的势能函数 $V_{\\text{true}}(r) = \\tfrac{1}{4}r^4 - \\tfrac{1}{2}r^2$ 定义。相应的真实力为 $F_{\\text{true}}(r) = -dV_{\\text{true}}/dr = - (r^3 - r)$。在这个精确的物理系统中，总能量 $E(t) = \\tfrac{1}{2}m v(t)^2 + V_{\\text{true}}(r(t))$ 是一个守恒量，即 $dE/dt = 0$。\n\n在典型的数值模拟中，力不是解析已知的，而是从一个在离散网格上制成列表的势能面推导出来的。我们给定一个点网格 $r_i = r_{\\min} + i h$（其中 $i=0, \\dots, n-1$），其上的势能值为 $V_i = V_{\\text{true}}(r_i)$。粒子在任意位置 $r$ 上受到的力必须根据这些列表值来估算。问题指定了三种常见的有限差分估算器。对于位于网格单元 $[r_i, r_{i+1})$（其中 $i = \\lfloor (r - r_{\\min})/h \\rfloor$）中位置为 $r$ 的粒子，估算器如下：\n\n1.  **前向差分**：$F_{\\text{fwd}}(r) = -\\frac{V_{i+1} - V_{i}}{h}$。该估算器基于粒子当前所在单元格上的势能斜率。它是对真实导数的一阶精确近似，误差为 $\\mathcal{O}(h)$ 阶。它本质上是非对称的。\n2.  **后向差分**：$F_{\\text{bwd}}(r) = -\\frac{V_{i} - V_{i-1}}{h}$。它使用粒子刚刚离开的单元格上的斜率。它也是一阶精确的，误差为 $\\mathcal{O}(h)$，并且是非对称的。\n3.  **中心差分**：$F_{\\text{cen}}(r) = -\\frac{V_{i+1} - V_{i-1}}{2h}$。它对称地使用当前单元格基点 $r_i$ 两侧的点。它是一个二阶精确近似，误差为 $\\mathcal{O}(h^2)$。\n\n粒子的轨迹是通过对运动方程进行数值积分生成的。问题指定了速度Verlet (VV) 算法，这是分子动力学中的一个标准选择，因为它具有出色的稳定性和长期能量守恒特性。给定时间 $t$ 时的位置 $r(t)$、速度 $v(t)$ 和加速度 $a(t) = F_{\\text{fd}}(r(t))/m$，时间 $t+\\Delta t$ 时的状态计算如下：\n$$\nr(t+\\Delta t) = r(t) + v(t)\\Delta t + \\tfrac{1}{2}a(t)(\\Delta t)^2\n$$\n$$\na(t+\\Delta t) = F_{\\text{fd}}(r(t+\\Delta t))/m\n$$\n$$\nv(t+\\Delta t) = v(t) + \\tfrac{1}{2}\\left[ a(t) + a(t+\\Delta t) \\right] \\Delta t\n$$\nVV算法是时间可逆和辛的。当与一个作为某个势能的精确梯度（即保守力）的力计算相结合时，VV算法能精确地守恒一个附近的“影子”哈密顿量，从而导致能量在一个恒定值附近有界波动。然而，这里定义的有限差分力是分段常数，并且通常不是某个单一、平滑势能函数的梯度。因此，能量守恒的质量取决于力近似的性质。对称的中心差分方案预计会产生更优的能量守恒效果（最小的系统性漂移），而非对称的前向和后向差分方案预计会产生非零的系统性漂移，导致能量随时间稳定增加或减少。对于更粗的网格（更大的 $h$），这种效应的幅度应该更显著。\n\n我们的实现将针对每个测试案例按以下步骤进行：\n1.  **系统设置**：设置参数 $m=1$，$r_{\\min}=-2$，$r_{\\max}=2$，以及初始条件 $r(0)=1.2$，$v(0)=0$。为该案例选择特定的方案、网格间距 $h$ 和时间步长 $\\Delta t$。\n2.  **势能列表化**：创建一个从 $r_{\\min}$ 到 $r_{\\max}$，间距为 $h$ 的位置网格 $r_i$。对每个网格点计算并存储势能 $V_{\\text{true}}(r_i)$，从而创建列表 $V_i$。网格点数为 $n = (r_{\\max} - r_{\\min}) / h + 1$。\n3.  **力函数**：实现一个函数来计算力 $F_{\\text{fd}}(r)$。该函数首先确定网格索引 $i = \\lfloor(r - r_{\\min})/h\\rfloor$。然后执行索引钳制，以确保对 $V_i$ 列表的所有查找都在有效边界 $[0, n-1]$ 内。例如，对于中心差分方案，$i$被钳制在范围 $[1, n-2]$ 内，以确保 $i-1$ 和 $i+1$ 是有效索引。然后使用钳制后的索引应用相应的有限差分公式。\n4.  **数值积分**：一个循环运行 $N_{\\text{steps}}$ 次迭代。在每次迭代中，速度Verlet算法使用步骤3中函数计算出的力来更新粒子的位置和速度。每步之后，使用真实的、连续的势能函数计算总能量 $E(t) = \\tfrac{1}{2}m v^2 + V_{\\text{true}}(r)$。存储时间和相应的能量。\n5.  **漂移分析**：模拟完成后，我们得到一个总能量值的时间序列 $\\{E(t_k)\\}$。对这些数据与时间进行普通最小二乘线性回归，拟合模型 $E(t) = at+b$。得到的斜率 $a = dE/dt$ 提供了系统性能量漂移的定量度量。该斜率是每个案例的最终结果。\n\n通过比较所得的漂移率，我们将经验性地验证对称力离散化对于辛积分方案中的长期能量守恒至关重要的理论预期。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    \n    # Define physical constants and initial conditions as per the problem.\n    M_PARTICLE = 1.0\n    R_MIN = -2.0\n    R_MAX = 2.0\n    R_INITIAL = 1.2\n    V_INITIAL = 0.0\n\n    # Define the reference potential energy function.\n    def V_true(r):\n        \"\"\"\n        Calculates the true potential energy V_true(r) = 1/4*r^4 - 1/2*r^2.\n        \"\"\"\n        return 0.25 * r**4 - 0.5 * r**2\n\n    def run_simulation(scheme, h, dt, n_steps):\n        \"\"\"\n        Runs a single molecular dynamics simulation for a given set of parameters.\n\n        Args:\n            scheme (str): The force estimation scheme ('centered', 'forward', 'backward').\n            h (float): The grid spacing for the potential tabulation.\n            dt (float): The time step for the Velocity Verlet integrator.\n            n_steps (int): The total number of integration steps.\n\n        Returns:\n            float: The slope of the energy vs. time, representing the energy drift rate.\n        \"\"\"\n        # 1. Tabulate the potential on a uniform grid.\n        # Use round() to avoid float precision issues in calculating n_grid.\n        n_grid = int(round((R_MAX - R_MIN) / h)) + 1\n        r_grid = np.linspace(R_MIN, R_MAX, n_grid)\n        V_grid = V_true(r_grid)\n\n        # 2. Define the force calculation function based on the tabulated potential.\n        def get_force(r_pos):\n            \"\"\"\n            Calculates the force at position r_pos using a finite-difference scheme.\n            Includes index clamping to handle boundary conditions.\n            \"\"\"\n            # Determine the grid cell index for the current position.\n            i_float = (r_pos - R_MIN) / h\n            i = int(np.floor(i_float))\n\n            # Apply index clamping to ensure array access is always valid.\n            if scheme == 'centered':\n                i = np.clip(i, 1, n_grid - 2)\n                force = -(V_grid[i + 1] - V_grid[i - 1]) / (2.0 * h)\n            elif scheme == 'forward':\n                i = np.clip(i, 0, n_grid - 2)\n                force = -(V_grid[i + 1] - V_grid[i]) / h\n            elif scheme == 'backward':\n                i = np.clip(i, 1, n_grid - 1)\n                force = -(V_grid[i] - V_grid[i - 1]) / h\n            else:\n                # This case should not be reached with valid problem inputs.\n                raise ValueError(f\"Unknown scheme: {scheme}\")\n            \n            return force\n\n        # 3. Initialize simulation variables.\n        r = R_INITIAL\n        v = V_INITIAL\n        \n        times = np.arange(n_steps + 1) * dt\n        energies = np.zeros(n_steps + 1)\n        \n        # Store initial energy.\n        energies[0] = 0.5 * M_PARTICLE * v**2 + V_true(r)\n        \n        # Calculate initial acceleration.\n        a = get_force(r) / M_PARTICLE\n\n        # 4. Perform the Velocity Verlet integration.\n        for step in range(n_steps):\n            # Update position.\n            r_new = r + v * dt + 0.5 * a * dt**2\n            \n            # Update force/acceleration at the new position.\n            a_new = get_force(r_new) / M_PARTICLE\n            \n            # Update velocity.\n            v_new = v + 0.5 * (a + a_new) * dt\n            \n            # Update state for the next iteration.\n            r, v, a = r_new, v_new, a_new\n            \n            # Calculate and store the total energy using the true potential.\n            energies[step + 1] = 0.5 * M_PARTICLE * v**2 + V_true(r)\n\n        # 5. Quantify energy drift via linear regression.\n        # np.polyfit(x, y, 1) returns [slope, intercept] for a linear fit.\n        slope, _ = np.polyfit(times, energies, 1)\n        \n        return slope\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, fine grid, symmetric force)\n        {'scheme': 'centered', 'h': 0.02, 'dt': 0.02, 'n_steps': 30000},\n        # Case 2 (fine grid, asymmetric forward force)\n        {'scheme': 'forward',  'h': 0.02, 'dt': 0.02, 'n_steps': 30000},\n        # Case 3 (fine grid, asymmetric backward force)\n        {'scheme': 'backward', 'h': 0.02, 'dt': 0.02, 'n_steps': 30000},\n        # Case 4 (coarse grid, symmetric force)\n        {'scheme': 'centered', 'h': 0.20, 'dt': 0.02, 'n_steps': 30000},\n        # Case 5 (coarse grid, asymmetric forward force)\n        {'scheme': 'forward',  'h': 0.20, 'dt': 0.02, 'n_steps': 30000},\n        # Case 6 (coarse grid, asymmetric backward force)\n        {'scheme': 'backward', 'h': 0.20, 'dt': 0.02, 'n_steps': 30000},\n    ]\n\n    results = []\n    for case in test_cases:\n        drift_rate = run_simulation(case['scheme'], case['h'], case['dt'], case['n_steps'])\n        results.append(drift_rate)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```", "id": "3412357"}, {"introduction": "为了提高计算效率，尤其是在处理具有多时间尺度的系统时，自适应步长算法应运而生。然而，这种效率的提升往往伴随着代价。本练习[@problem_id:3412413]要求您为一个Velocity Verlet积分器实现自适应步长控制，并通过与固定步长方案的对比，来量化其对长时间能量守恒的影响。这个实践将帮助您理解在可变步长下辛结构被破坏的后果，并掌握在模拟效率与物理保真度之间进行权衡的关键考量。", "problem": "您将使用速度 Verlet (VV) 方法，为经典动力学实现并分析自适应时间步进。从牛顿第二运动定律出发，在分子动力学中常用的简化无量纲单位系统内进行研究，其中质量和势能参数均被归一化。您的任务结合了原理性推导、算法设计以及对长期能量行为的定量评估。\n\n使用以下物理设置和单位约定：\n- 系统是一个一维谐振子，其质量为 $m$，弹簧常数为 $k$。其受力满足 $F(x) = -kx$，在简化单位下 $m=1$，$k=1$。\n- 系统的状态由位置 $x(t)$ 和速度 $v(t)$ 描述，其总能量在无量纲单位下为 $E(t) = \\tfrac{1}{2} m v(t)^2 + \\tfrac{1}{2} k x(t)^2$。\n\n必需的算法组件：\n1. 从 $m \\ddot{x} = F(x)$ 出发，推导速度 Verlet (VV) 积分器的显式更新规则，然后实现该算法。\n2. 通过比较一个大小为 $\\Delta t$ 的完整 VV 步与两个大小为 $\\Delta t/2$ 的连续 VV 半步（两者均从相同的当前状态 $(x,v)$ 开始）来实现一个局域误差估计器。将局域误差定义为状态空间范数\n$$\ne = \\sqrt{\\left(x_{\\mathrm{full}} - x_{\\mathrm{half}}\\right)^2 + \\left(\\Delta t\\,(v_{\\mathrm{full}} - v_{\\mathrm{half}})\\right)^2}\\,,\n$$\n该范数使用当前的 $\\Delta t$ 来平衡位置和速度的差异，从而使得两项都具有位置的单位。\n3. 实现一个由估计的局域误差 $e$ 和容差 $\\varepsilon$ 驱动的自适应时间步长控制器：\n   - 如果 $e \\le \\varepsilon$，则接受该步，并将时间推进 $\\Delta t$。使用两个半步得到的状态 $(x_{\\mathrm{half}},v_{\\mathrm{half}})$ 作为接受的下一状态。\n   - 如果 $e  \\varepsilon$，则拒绝该步，将 $\\Delta t$ 乘以因子 $r_{\\downarrow}$ 减小，并从相同的当前状态重新计算，时间不推进。\n   - 在接受一个步之后，如果 $e  \\varepsilon/2$，则为下一次提议将 $\\Delta t$ 乘以因子 $r_{\\uparrow}$ 增大；否则，保持 $\\Delta t$ 不变。\n   - 始终强制 $\\Delta t \\in [\\Delta t_{\\min}, \\Delta t_{\\max}]$。\n4. 同时，使用初始步长 $\\Delta t_0$ 运行一个不含任何自适应调整的基准固定步长 VV 模拟。\n5. 对于自适应和固定步长两种运行方式，通过对整个模拟区间内的 $E(t)$ 与 $t$ 的关系进行直线拟合，并取其斜率的绝对值，来量化长期能量漂移。也就是说，计算最小二乘拟合参数 $(\\alpha,\\beta)$ 以最小化 $\\sum_i \\left(E(t_i) - (\\alpha t_i + \\beta)\\right)^2$，并将 $D = |\\alpha|$ 作为每单位时间的能量漂移率（无量纲）报告。\n6. 在您的解决方案中，讨论当 $\\Delta t$ 变化时因破坏辛性而引入的权衡，并将其与观测到的能量漂移联系起来。\n\n模拟与单位：\n- 使用简化的无量纲单位，其中 $m=1$ 和 $k=1$，因此时间、位置、速度和能量都是无量纲的。\n- 以每单位时间的无量纲能量来表示最终的能量漂移率 $D$。\n\n测试套件：\n对于每个测试用例，从相同的初始条件 $(x(0),v(0))$ 和总模拟时间 $T$ 开始，运行自适应和固定步长两种模拟，并报告下面指定的三个度量指标。使用以下参数集：\n\n- 测试用例 1：$T=200$，$x(0)=1$，$v(0)=0$，$\\Delta t_0=0.1$，$\\varepsilon=10^{-5}$，$\\Delta t_{\\min}=10^{-4}$，$\\Delta t_{\\max}=0.3$，$r_{\\uparrow}=1.25$，$r_{\\downarrow}=0.5$。\n- 测试用例 2：$T=50$，$x(0)=1$，$v(0)=0$，$\\Delta t_0=0.05$，$\\varepsilon=10^{-8}$，$\\Delta t_{\\min}=10^{-5}$，$\\Delta t_{\\max}=0.2$，$r_{\\uparrow}=1.25$，$r_{\\downarrow}=0.5$。\n- 测试用例 3：$T=200$，$x(0)=1$，$v(0)=0$，$\\Delta t_0=0.1$，$\\varepsilon=10^{-3}$，$\\Delta t_{\\min}=10^{-4}$，$\\Delta t_{\\max}=0.5$，$r_{\\uparrow}=1.25$，$r_{\\downarrow}=0.5$。\n- 测试用例 4：$T=200$，$x(0)=1$，$v(0)=0$，$\\Delta t_0=0.2$，$\\varepsilon=5\\times 10^{-4}$，$\\Delta t_{\\min}=10^{-4}$，$\\Delta t_{\\max}=0.8$，$r_{\\uparrow}=1.25$，$r_{\\downarrow}=0.5$。\n\n最终输出格式：\n- 对于每个测试用例 $j$，计算：\n  1. $D_{\\mathrm{adapt}}^{(j)}$：自适应 VV 运行的绝对能量漂移率。\n  2. $D_{\\mathrm{fixed}}^{(j)}$：固定步长 VV 运行的绝对能量漂移率。\n  3. $\\langle \\Delta t \\rangle^{(j)}$：自适应 VV 运行中的平均接受步长。\n- 您的程序应生成单行输出，其中包含所有结果，形式为一个用方括号括起来的逗号分隔列表，并按测试用例 $j=1,2,3,4$ 的顺序展开：\n$$\n\\bigl[D_{\\mathrm{adapt}}^{(1)},\\,D_{\\mathrm{fixed}}^{(1)},\\,\\langle \\Delta t \\rangle^{(1)},\\,D_{\\mathrm{adapt}}^{(2)},\\,D_{\\mathrm{fixed}}^{(2)},\\,\\langle \\Delta t \\rangle^{(2)},\\,D_{\\mathrm{adapt}}^{(3)},\\,D_{\\mathrm{fixed}}^{(3)},\\,\\langle \\Delta t \\rangle^{(3)},\\,D_{\\mathrm{adapt}}^{(4)},\\,D_{\\mathrm{fixed}}^{(4)},\\,\\langle \\Delta t \\rangle^{(4)}\\bigr]\\,.\n$$\n所有量均为无量纲浮点数。", "solution": "该问题要求针对一维谐振子，实现并分析一种用于速度 Verlet (VV) 积分器的自适应时间步进方案。此自适应方案的性能将与标准的固定步长 VV 模拟进行比较，重点关注长期能量守恒性。\n\n系统是一个质量为 $m=1$ 的粒子，在简化的无量纲单位系统中，受到一个弹簧常数为 $k=1$ 的线性恢复力 $F(x) = -kx$ 的作用。总能量是动能和势能之和：\n$$\nE(t) = \\frac{1}{2} m v(t)^2 + \\frac{1}{2} k x(t)^2 = \\frac{1}{2} v(t)^2 + \\frac{1}{2} x(t)^2\n$$\n\n首先，我们推导速度 Verlet 积分器的更新规则。该算法源于位置 $x(t)$ 和速度 $v(t)$ 的泰勒级数展开。\n时刻 $t+\\Delta t$ 的位置展开到二阶：\n$$\nx(t+\\Delta t) = x(t) + v(t)\\Delta t + \\frac{1}{2} a(t) \\Delta t^2 + \\mathcal{O}(\\Delta t^3)\n$$\n其中 $v(t) = \\dot{x}(t)$ 是速度，而 $a(t) = \\ddot{x}(t) = F(x(t))/m$ 是加速度。\n\n速度的更新被构造成时间对称的，这是该算法稳定性和辛性的关键。我们使用梯形法则来近似速度积分，即对时间步开始和结束时的加速度进行平均：\n$$\nv(t+\\Delta t) = v(t) + \\int_{t}^{t+\\Delta t} a(\\tau) d\\tau \\approx v(t) + \\frac{1}{2}\\left[ a(t) + a(t+\\Delta t) \\right] \\Delta t\n$$\n其中 $a(t+\\Delta t) = F(x(t+\\Delta t))/m$。这导出了以下广泛使用的单步速度 Verlet 实现：\n1.  从时刻 $t_n=t$ 的状态计算新位置 $x_{n+1} = x(t+\\Delta t)$：\n    $$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2$$\n2.  使用新位置计算新加速度 $a_{n+1}$：\n    $$a_{n+1} = \\frac{F(x_{n+1})}{m}$$\n3.  计算新速度 $v_{n+1} = v(t+\\Delta t)$：\n    $$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\n该算法是时间可逆的，并且对于固定的步长 $\\Delta t$，它是辛的。\n\n接下来，我们设计自适应时间步进方案。其核心思想是估计单步的局域截断误差，并调整 $\\Delta t$ 以将此误差控制在指定的容差 $\\varepsilon$ 以下。一种常见的误差估计方法是比较一个大小为 $\\Delta t$ 的步长的结果与两个大小为 $\\Delta t/2$ 的步长的结果。\n设时刻 $t$ 的状态为 $(x, v)$。\n-   一个大小为 $\\Delta t$ 的“完整”步产生状态 $(x_{\\mathrm{full}}, v_{\\mathrm{full}})$。\n-   两个连续的大小为 $\\Delta t/2$ 的“半”步产生状态 $(x_{\\mathrm{half}}, v_{\\mathrm{half}})$。\n两个半步的结果更准确。这两个计算出的状态之间的差异提供了局域误差的估计。问题定义了一个特定的标量误差度量 $e$：\n$$\ne = \\sqrt{\\left(x_{\\mathrm{full}} - x_{\\mathrm{half}}\\right)^2 + \\left(\\Delta t\\,(v_{\\mathrm{full}} - v_{\\mathrm{half}})\\right)^2}\n$$\n速度项中的因子 $\\Delta t$ 确保两项都具有位置的单位，从而提供了一个平衡的状态空间误差范数。\n\n对于一个提议的步长 $\\Delta t$，步长控制器按以下方式运行：\n1.  如果估计误差 $e$ 大于容差 $\\varepsilon$ ($e > \\varepsilon$)，则拒绝该步。时间步长被减小，$\\Delta t \\to \\Delta t \\times r_{\\downarrow}$，并从相同的初始状态重新尝试该步。时间不推进。\n2.  如果误差在容差范围内 ($e \\le \\varepsilon$)，则接受该步。系统状态推进到更准确的半步结果，$(x, v) \\to (x_{\\mathrm{half}}, v_{\\mathrm{half}})$，并且时间推进 $\\Delta t$。\n3.  在接受一个步之后，会调整下一次提议的步长。如果误差足够小，即 $e  \\varepsilon/2$，则增加步长：$\\Delta t \\to \\Delta t \\times r_{\\uparrow}$。否则，步长保持不变。\n4.  在任何时候，步长都被限制在范围 $[\\Delta t_{\\min}, \\Delta t_{\\max}]$ 内。\n\n此问题的一个关键方面是局域精度和长期稳定性之间的权衡。固定步长的速度 Verlet 积分器是辛的。对于一个哈密顿系统，这意味着它精确地保守一个“影子”哈密顿量 $H_{\\Delta t}$，该哈密顿量接近于真实的哈密顿量 $H$。这一性质导致在非常长的模拟中，能量在一个恒定值附近有界涨落，并且没有系统性的能量漂移。当时间步长 $\\Delta t$ 像我们的自适应方案中那样变化时，积分器在每一步都会在不同的辛映射之间切换，每个辛映射都对应一个不同的影子哈密顿量。这些映射的复合不再是辛的。因此，没有任何一个单一的影子哈密顿量是守恒的，从而丧失了优异的长期能量守恒性。尽管每一步的局域误差都得到了控制，但这通常表现为总能量的系统性线性漂移。\n\n为了量化这一点，我们将自适应模拟与使用初始步长 $\\Delta t_0$ 的基准固定步长模拟进行比较。对于这两种运行，我们通过对能量数据 $E(t_i)$ 与时间 $t_i$ 进行线性最小二乘拟合来计算能量漂移率 $D$。漂移率 $D$ 是该拟合直线斜率的绝对值，即 $D=|\\alpha|$，其中拟合方程为 $E(t) = \\alpha t + \\beta$。我们预期 $D_{\\mathrm{fixed}}$ 会非常接近于零（反映了有界振荡），而 $D_{\\mathrm{adapt}}$ 会更大，这表明了因破坏辛性而引起的能量漂移。我们还计算自适应运行的平均接受步长 $\\langle \\Delta t \\rangle$ 以衡量其效率。\n\n该实现将为每个测试用例模拟系统，运行自适应和固定步长两种方案。然后，它将计算三个指定的度量指标（$D_{\\mathrm{adapt}}$，$D_{\\mathrm{fixed}}$，$\\langle \\Delta t \\rangle$）并以要求的格式报告它们。线性拟合使用 NumPy 的 `polyfit` 函数来执行。所有模拟都在指定的无量纲单位下进行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed, numpy.polyfit is sufficient.\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations and print the final results.\n    \"\"\"\n    # Define physical constants in reduced units\n    M_MASS = 1.0\n    K_SPRING = 1.0\n\n    def force(x):\n        \"\"\"Calculates the force F(x) = -kx for the harmonic oscillator.\"\"\"\n        return -K_SPRING * x\n\n    def energy(x, v):\n        \"\"\"Calculates the total energy E = 1/2*m*v^2 + 1/2*k*x^2.\"\"\"\n        return 0.5 * M_MASS * v**2 + 0.5 * K_SPRING * x**2\n\n    def vv_step(x, v, dt):\n        \"\"\"\n        Performs a single step of the Velocity Verlet algorithm.\n        \"\"\"\n        a = force(x) / M_MASS\n        x_new = x + v * dt + 0.5 * a * dt**2\n        a_new = force(x_new) / M_MASS\n        v_new = v + 0.5 * (a + a_new) * dt\n        return x_new, v_new\n\n    def run_fixed_step(x0, v0, T, dt0):\n        \"\"\"\n        Runs a simulation with a fixed time step.\n        \"\"\"\n        t = 0.0\n        x, v = x0, v0\n        \n        times = [t]\n        energies = [energy(x, v)]\n        \n        while t  T:\n            # Ensure the last step hits T exactly\n            current_dt = min(dt0, T - t)\n            if current_dt  1e-12: break\n            \n            x, v = vv_step(x, v, current_dt)\n            t += current_dt\n            \n            times.append(t)\n            energies.append(energy(x, v))\n            \n        return np.array(times), np.array(energies)\n\n    def run_adaptive_step(x0, v0, T, dt0, eps, dt_min, dt_max, r_up, r_down):\n        \"\"\"\n        Runs a simulation with an adaptive time step.\n        \"\"\"\n        t = 0.0\n        x, v = x0, v0\n        dt = dt0\n        \n        times = [t]\n        energies = [energy(x, v)]\n        accepted_dts = []\n\n        while t  T:\n            actual_dt = min(dt, T - t)\n            \n            # Failsafe for the very last, potentially tiny step\n            if actual_dt  1e-12:\n                break\n\n            step_accepted = False\n            while not step_accepted:\n                # One full step\n                x_full, v_full = vv_step(x, v, actual_dt)\n                \n                # Two half steps\n                x_mid, v_mid = vv_step(x, v, actual_dt / 2.0)\n                x_half, v_half = vv_step(x_mid, v_mid, actual_dt / 2.0)\n\n                # Calculate local error\n                error = np.sqrt((x_full - x_half)**2 + (actual_dt * (v_full - v_half))**2)\n\n                if error = eps:  # Accept step\n                    step_accepted = True\n                    \n                    # Advance to new state using more accurate half-step result\n                    t += actual_dt\n                    x, v = x_half, v_half\n                    \n                    times.append(t)\n                    energies.append(energy(x, v))\n                    accepted_dts.append(actual_dt)\n                    \n                    # Update dt for the NEXT proposal\n                    if error  eps / 2.0 and dt  dt_max:\n                        dt_proposal = dt * r_up\n                    else:\n                        dt_proposal = dt\n                    \n                    dt = min(dt_max, dt_proposal)\n\n                else:  # Reject step\n                    dt_proposal = dt * r_down\n                    dt = max(dt_min, dt_proposal)\n                    actual_dt = min(dt, T - t) # Update dt for retry\n                    if actual_dt  1e-12: # Avoid infinite loop if dt becomes too small\n                        step_accepted = True # effectively give up and finish\n                        t = T \n\n        return np.array(times), np.array(energies), np.array(accepted_dts)\n\n    def calculate_drift(times, energies):\n        \"\"\"\n        Calculates the energy drift rate |alpha| from a linear fit E(t) = alpha*t + beta.\n        \"\"\"\n        if len(times)  2:\n            return 0.0\n        slope, _ = np.polyfit(times, energies, 1)\n        return abs(slope)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # T, x0, v0, dt0, eps, dt_min, dt_max, r_up, r_down\n        (200.0, 1.0, 0.0, 0.1, 1e-5, 1e-4, 0.3, 1.25, 0.5),\n        (50.0, 1.0, 0.0, 0.05, 1e-8, 1e-5, 0.2, 1.25, 0.5),\n        (200.0, 1.0, 0.0, 0.1, 1e-3, 1e-4, 0.5, 1.25, 0.5),\n        (200.0, 1.0, 0.0, 0.2, 5e-4, 1e-4, 0.8, 1.25, 0.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        T, x0, v0, dt0, eps, dt_min, dt_max, r_up, r_down = case\n        \n        # Adaptive run\n        t_adapt, E_adapt, dts_adapt = run_adaptive_step(x0, v0, T, dt0, eps, dt_min, dt_max, r_up, r_down)\n        D_adapt = calculate_drift(t_adapt, E_adapt)\n        avg_dt = np.mean(dts_adapt) if len(dts_adapt) > 0 else 0.0\n\n        # Fixed-step run\n        t_fixed, E_fixed = run_fixed_step(x0, v0, T, dt0)\n        D_fixed = calculate_drift(t_fixed, E_fixed)\n        \n        results.extend([D_adapt, D_fixed, avg_dt])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3412413"}]}