{"hands_on_practices": [{"introduction": "四元数表示法中的一个关键特性是其对三维旋转群 $\\mathrm{SO}(3)$ 的双重覆盖，即四元数 $\\mathbf{q}$ 和 $-\\mathbf{q}$ 代表完全相同的物理旋转。这个练习将探讨这种符号模糊性在分析模拟轨迹时可能引入的人为不连续性，并介绍几种旨在最小化帧间跳跃的“解环”约定。通过这个实践，你将掌握处理和分析四元数轨迹数据的关键技能，确保对旋转运动的分析具有物理意义。[@problem_id:3442442]", "problem": "考虑一个在周期性边界条件下的分子动力学中的刚体。该刚体在离散时间索引 $t$ 的取向由一个单位四元数 $q_t \\in \\mathbb{H}$ 表示，其标量部分为 $q_{t,0}$，矢量部分为 $\\mathbf{q}_{t,v}$，且满足 $\\|q_t\\| = 1$。单位四元数表示是三维特殊正交群 $\\mathrm{SO}(3)$ 的双重覆盖，这意味着 $q$ 和 $-q$ 代表相同的物理旋转。当对记录的取向轨迹进行简单的后处理时，这种符号不确定性会产生人为的不连续性，尤其是在坐标通过周期性边界条件进行重映射或在不考虑时间连续性的情况下强制施加固定半球符号规则时。\n\n从以下基本依据和定义开始：\n- 一个单位四元数 $q = (q_0, \\mathbf{q}_v)$ 通过映射 $q = \\left(\\cos(\\theta/2), \\hat{\\mathbf{u}} \\sin(\\theta/2)\\right)$ 表示绕单位轴 $\\hat{\\mathbf{u}}$ 旋转角度 $\\theta \\in [0, 2\\pi)$。\n- 单位四元数的逆是其共轭，即 $q^{-1} = \\bar{q} = (q_0, -\\mathbf{q}_v)$。\n- 哈密顿积 $\\otimes$ 用于复合旋转：如果 $p$ 和 $q$ 是单位四元数，则 $p \\otimes q$ 对应于在旋转 $p$ 之后施加旋转 $q$。\n- 对于两个取向 $p$ 和 $q$，其相对取向为 $r = p^{-1} \\otimes q$，这对应于绕某个轴旋转角度 $\\Delta \\theta \\in [0, 2\\pi]$，其中 $\\Delta \\theta$ 通过其标量部分 $r_0$ 计算得出：$\\Delta \\theta = 2 \\arccos(\\max(-1,\\min(1,r_0)))$。本问题中所有角度都必须以弧度表示。\n\n任务。您必须为一个单位四元数序列 $\\{q_t\\}_{t=0}^{N-1}$ 实现三种符号卷绕约定，并为每种约定计算最大帧间旋转角 $\\max_{t \\ge 1} \\Delta \\theta_t$，具体如下：\n- 约定 $\\mathcal{N}$（“none”，无）：保持序列不变。对每个 $t \\ge 1$，计算相对四元数 $r_t = \\bar{q}_{t-1} \\otimes q_t$ 和步长角 $\\Delta \\theta_t = 2 \\arccos(\\max(-1,\\min(1,(r_t)_0)))$，使用 $r_t$ 的标量部分 $(r_t)_0$。\n- 约定 $\\mathcal{H}$（“hemisphere”，半球）：当且仅当 $q_{t,0} < 0$ 时，将每个 $q_t$ 乘以 $-1$ 映射到 $q_t'$，否则保持不变。然后，对 $\\{q_t'\\}$ 使用相同的相对四元数程序计算 $\\Delta \\theta_t$。\n- 约定 $\\mathcal{S}$（“smooth-min-jump”，平滑最小跳跃）：从 $q_0' = q_0$ 开始，对 $t \\ge 1$ 递归地从 $\\{q_t, -q_t\\}$ 中选择 $q_t'$，使得 $q_{t-1}'$ 和 $q_t'$ 之间的瞬时帧间旋转角最小化，即选择 $q_t'$ 的符号以最小化从 $r_t' = \\overline{q_{t-1}'} \\otimes q_t'$ 计算出的 $\\Delta \\theta_t$。然后使用 $\\{q_t'\\}$ 计算 $\\Delta \\theta_t$。\n\n您应实现以下测试套件，其中每个轨迹由一个固定的单位轴 $\\hat{\\mathbf{u}}$、每帧的角增量 $\\omega$、长度 $N$ 以及一个可选的索引集 $\\mathcal{F}$ 定义，在这些索引处，记录的四元数被乘以 $-1$ 以模拟后处理引入的符号翻转：\n- 轨迹 $\\mathsf{A}$：$\\hat{\\mathbf{u}}_{\\mathsf{A}} = (0,0,1)$，$\\omega_{\\mathsf{A}} = 0.1$，$N_{\\mathsf{A}} = 200$，$\\mathcal{F}_{\\mathsf{A}} = \\{50, 120, 121\\}$。定义 $q_t^{\\mathsf{A}} = \\left(\\cos(\\theta_t/2), \\hat{\\mathbf{u}}_{\\mathsf{A}} \\sin(\\theta_t/2)\\right)$，其中 $\\theta_t = \\omega_{\\mathsf{A}} t$。构造序列后，对所有 $t \\in \\mathcal{F}_{\\mathsf{A}}$ 应用 $q_t^{\\mathsf{A}} \\leftarrow - q_t^{\\mathsf{A}}$。\n- 轨迹 $\\mathsf{B}$：$\\hat{\\mathbf{u}}_{\\mathsf{B}} = (1,0,0)$，$\\omega_{\\mathsf{B}} = 0.2$，$N_{\\mathsf{B}} = 100$，$\\mathcal{F}_{\\mathsf{B}} = \\varnothing$。以类似方式构造 $q_t^{\\mathsf{B}}$，其中 $\\theta_t = \\omega_{\\mathsf{B}} t$。\n- 轨迹 $\\mathsf{C}$：$\\hat{\\mathbf{u}}_{\\mathsf{C}} = \\frac{1}{\\sqrt{14}}(1,2,3)$，$\\omega_{\\mathsf{C}} = 1.3\\pi$，$N_{\\mathsf{C}} = 5$，$\\mathcal{F}_{\\mathsf{C}} = \\varnothing$。以类似方式构造 $q_t^{\\mathsf{C}}$，其中 $\\theta_t = \\omega_{\\mathsf{C}} t$。\n\n对于每个轨迹 $\\mathsf{X} \\in \\{\\mathsf{A}, \\mathsf{B}, \\mathsf{C}\\}$ 和每个约定 $\\mathcal{C} \\in \\{\\mathcal{N}, \\mathcal{H}, \\mathcal{S}\\}$，计算最大帧间旋转角\n$$\nJ(\\mathsf{X}, \\mathcal{C}) = \\max_{1 \\le t \\le N_{\\mathsf{X}}-1} \\left[ 2 \\arccos\\left(\\max(-1,\\min(1, (r_t^{\\mathcal{C}})_0))\\right) \\right],\n$$\n其中 $r_t^{\\mathcal{C}}$ 是根据上述定义的约定 $\\mathcal{C}$ 从后处理序列中计算出的相对四元数。所有角度必须以弧度为单位。\n\n最终输出格式。您的程序应生成单行输出，包含九个浮点数结果\n$$\n\\left[ J(\\mathsf{A},\\mathcal{N}), J(\\mathsf{A},\\mathcal{H}), J(\\mathsf{A},\\mathcal{S}), J(\\mathsf{B},\\mathcal{N}), J(\\mathsf{B},\\mathcal{H}), J(\\mathsf{B},\\mathcal{S}), J(\\mathsf{C},\\mathcal{N}), J(\\mathsf{C},\\mathcal{H}), J(\\mathsf{C},\\mathcal{S}) \\right]\n$$\n四舍五入到六位小数，以方括号括起来的逗号分隔列表形式打印，例如 $[x_1,x_2,\\dots,x_9]$，其中每个 $x_i$ 是一个以弧度为单位的十进制数，小数点后恰好有六位数字。", "solution": "目标是通过计算在三种不同的符号解卷绕约定下的最大帧间角位移，来分析表示刚体旋转的四元数轨迹。这解决了分子动力学模拟中的一个常见伪影，即四元数的符号模糊性（$q$ 和 $-q$ 表示相同的旋转）可能导致时间序列中出现伪跳跃。该分析涉及实现这些约定，并将它们应用于三个测试轨迹 $\\mathsf{A}$、$\\mathsf{B}$ 和 $\\mathsf{C}$。\n\n基础数学框架依赖于单位四元数代数。一个单位四元数 $q = (q_0, \\mathbf{q}_v)$，其标量部分 $q_0 \\in \\mathbb{R}$ 和矢量部分 $\\mathbf{q}_v \\in \\mathbb{R}^3$ 满足条件 $\\|q\\|^2 = q_0^2 + \\|\\mathbf{q}_v\\|^2 = 1$。\n\n关键运算有：\n1. **四元数共轭**：单位四元数 $q$ 的逆是其共轭 $\\bar{q} = (q_0, -\\mathbf{q}_v)$。\n2. **哈密顿积**：由四元数 $p$ 和 $q$ 表示的两次旋转的复合由它们的哈密顿积 $p \\otimes q$ 给出。对于 $p=(p_0, \\mathbf{p}_v)$ 和 $q=(q_0, \\mathbf{q}_v)$，其积 $r=p \\otimes q$ 定义为 $r = (p_0 q_0 - \\mathbf{p}_v \\cdot \\mathbf{q}_v, p_0 \\mathbf{q}_v + q_0 \\mathbf{p}_v + \\mathbf{p}_v \\times \\mathbf{q}_v)$。\n3. **相对取向**：将由 $q_{t-1}$ 表示的取向变换为由 $q_t$ 表示的取向的旋转由相对四元数 $r_t = \\bar{q}_{t-1} \\otimes q_t$ 给出。\n4. **角度提取**：与相对四元数 $r_t$ 对应的旋转角 $\\Delta\\theta_t$ 从其标量部分 $(r_t)_0$ 中通过公式 $\\Delta\\theta_t = 2 \\arccos((r_t)_0)$ 提取。为确保数值稳定性，$\\arccos$ 的参数被限制在区间 $[-1, 1]$ 内。\n\n基于这些运算，我们通过如下方式处理原始四元数序列 $\\{q_t\\}_{t=0}^{N-1}$，来为每个轨迹 $\\mathsf{X}$ 和约定 $\\mathcal{C}$ 评估最大角跳跃 $J(\\mathsf{X}, \\mathcal{C}) = \\max_{1 \\le t \\le N-1} \\Delta\\theta_t$。\n\n**约定 $\\mathcal{N}$（“none”，无）**：\n此约定不对输入轨迹进行任何修改。用于角度计算的序列就是原始序列，即 $\\{q_t'\\} = \\{q_t\\}$。最大角度直接从此序列计算。这作为一个基准，揭示了数据中存在的原始不连续性。\n\n**约定 $\\mathcal{H}$（“hemisphere”，半球）**：\n此约定通过将所有四元数映射到 $S^3$ 超球面的单个半球来强制执行固定的符号选择，通常是指标量部分为非负的那个半球。新序列 $\\{q_t'\\}$ 是从原始序列 $\\{q_t\\}$ 通过以下规则生成的：\n$$\nq_t' = \\begin{cases}\n-q_t & \\text{if } q_{t,0} < 0 \\\\\nq_t & \\text{if } q_{t,0} \\ge 0\n\\end{cases}\n$$\n该规则独立应用于序列中的每个四元数。虽然简单，但此方法不能保证时间上的平滑性，并且可能在轨迹穿过 $q_0=0$ 边界时引入新的不连续性。\n\n**约定 $\\mathcal{S}$（“smooth-min-jump”，平滑最小跳跃）**：\n此约定旨在通过最小化帧间旋转距离来生成时间上平滑的轨迹。这是一个递归过程。从 $q_0' = q_0$ 开始，每个后续的四元数 $q_t'$ 都从配对 $\\{q_t, -q_t\\}$ 中选择，使其与前一个处理过的四元数 $q_{t-1}'$ “更接近”。最小旋转角对应于相对四元数 $r_t' = \\overline{q_{t-1}'} \\otimes q_t'$ 的最大标量部分。$\\overline{q_{t-1}'} \\otimes q_t$ 的标量部分是四维点积 $q_{t-1}' \\cdot q_t$。$\\overline{q_{t-1}'} \\otimes (-q_t)$ 的标量部分是 $-(q_{t-1}' \\cdot q_t)$。因此，要最大化标量部分，必须确保其为非负。递归规则是：\n$q_0' = q_0$\n$$\nq_t' = \\begin{cases}\n-q_t & \\text{if } q_{t-1}' \\cdot q_t < 0 \\\\\nq_t & \\text{if } q_{t-1}' \\cdot q_t \\ge 0\n\\end{cases}\n\\quad \\text{for } t \\ge 1\n$$\n这种贪心方法通过在时间上向前传播一致的符号选择来有效地解卷绕轨迹。\n\n整体计算过程如下：\n1. 对于每个测试用例（$\\mathsf{A}$、$\\mathsf{B}$、$\\mathsf{C}$），使用提供的轴 $\\hat{\\mathbf{u}}$、角增量 $\\omega$、步数 $N$ 和翻转集 $\\mathcal{F}$ 生成原始四元数轨迹 $\\{q_t\\}$。\n2. 对于每种约定（$\\mathcal{N}$、$\\mathcal{H}$、$\\mathcal{S}$），根据其特定规则创建一个处理后的轨迹 $\\{q_t'\\}$。\n3. 对于每个处理后的轨迹，从 $t=1$ 迭代到 $N-1$，计算相对四元数 $r_t' = \\overline{q_{t-1}'} \\otimes q_t'$，提取角度 $\\Delta\\theta_t = 2 \\arccos(\\text{clip}((r_t')_0, -1, 1))$，并确定整个轨迹上的最大角度。\n4. 收集九个结果值，将它们格式化为六位小数，并以指定的列表格式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quaternion trajectory processing problem.\n    This function defines the quaternion operations, trajectory generation,\n    processing conventions, and then computes the required metrics for the\n    given test cases.\n    \"\"\"\n\n    # --- Quaternion Operations ---\n\n    def hamilton_product(p, q):\n        \"\"\"Computes the Hamilton product of two quaternions.\"\"\"\n        p0, pv = p[0], p[1:]\n        q0, qv = q[0], q[1:]\n        r0 = p0 * q0 - np.dot(pv, qv)\n        rv = p0 * qv + q0 * pv + np.cross(pv, qv)\n        return np.array([r0, rv[0], rv[1], rv[2]])\n\n    def conjugate(q):\n        \"\"\"Computes the conjugate of a quaternion.\"\"\"\n        return np.array([q[0], -q[1], -q[2], -q[3]])\n\n    # --- Trajectory Generation ---\n\n    def generate_trajectory(u, w, N, flips):\n        \"\"\"Generates a quaternion trajectory.\"\"\"\n        q_traj = np.zeros((N, 4))\n        for t in range(N):\n            theta = w * float(t)\n            q0 = np.cos(theta / 2.0)\n            qv = u * np.sin(theta / 2.0)\n            q = np.array([q0, qv[0], qv[1], qv[2]])\n            if t in flips:\n                q = -q\n            q_traj[t] = q\n        return q_traj\n\n    # --- Processing Conventions ---\n\n    def process_none(q_traj):\n        \"\"\"Convention N: No modification.\"\"\"\n        return q_traj\n\n    def process_hemisphere(q_traj):\n        \"\"\"Convention H: Map to q0 >= 0 hemisphere.\"\"\"\n        q_prime = q_traj.copy()\n        # Vectorized operation for efficiency\n        q_prime[q_prime[:, 0] < 0] *= -1\n        return q_prime\n\n    def process_smooth(q_traj):\n        \"\"\"Convention S: Minimize frame-to-frame jump.\"\"\"\n        q_prime = np.zeros_like(q_traj)\n        q_prime[0] = q_traj[0]\n        for t in range(1, len(q_traj)):\n            # The 4D dot product determines the shorter rotational path.\n            # A negative dot product implies the rotation via -q_t is shorter.\n            if np.dot(q_prime[t-1], q_traj[t]) < 0:\n                q_prime[t] = -q_traj[t]\n            else:\n                q_prime[t] = q_traj[t]\n        return q_prime\n\n    # --- Main Calculation ---\n\n    def compute_max_angle(q_traj):\n        \"\"\"Computes the max frame-to-frame angle for a trajectory.\"\"\"\n        max_angle = 0.0\n        if len(q_traj) < 2:\n            return 0.0\n            \n        for t in range(1, len(q_traj)):\n            q_prev = q_traj[t-1]\n            q_curr = q_traj[t]\n            \n            # Relative quaternion r = q_prev^{-1} * q_curr\n            r = hamilton_product(conjugate(q_prev), q_curr)\n            \n            # Clip to handle potential floating-point inaccuracies\n            r0 = np.clip(r[0], -1.0, 1.0)\n            \n            angle = 2.0 * np.arccos(r0)\n            if angle > max_angle:\n                max_angle = angle\n                \n        return max_angle\n\n    # --- Test Case Definitions ---\n\n    uA = np.array([0.0, 0.0, 1.0])\n    wA = 0.1\n    NA = 200\n    fA = {50, 120, 121}\n\n    uB = np.array([1.0, 0.0, 0.0])\n    wB = 0.2\n    NB = 100\n    fB = set()\n\n    uC_unnormalized = np.array([1.0, 2.0, 3.0])\n    uC = uC_unnormalized / np.linalg.norm(uC_unnormalized)\n    wC = 1.3 * np.pi\n    NC = 5\n    fC = set()\n    \n    test_cases = [\n        {'u': uA, 'w': wA, 'N': NA, 'flips': fA},\n        {'u': uB, 'w': wB, 'N': NB, 'flips': fB},\n        {'u': uC, 'w': wC, 'N': NC, 'flips': fC}\n    ]\n\n    results = []\n    \n    # --- Execution Loop ---\n    \n    for case in test_cases:\n        traj = generate_trajectory(case['u'], case['w'], case['N'], case['flips'])\n        \n        # Convention N\n        traj_N = process_none(traj)\n        max_angle_N = compute_max_angle(traj_N)\n        results.append(max_angle_N)\n        \n        # Convention H\n        traj_H = process_hemisphere(traj)\n        max_angle_H = compute_max_angle(traj_H)\n        results.append(max_angle_H)\n        \n        # Convention S\n        traj_S = process_smooth(traj)\n        max_angle_S = compute_max_angle(traj_S)\n        results.append(max_angle_S)\n        \n    # --- Final Output ---\n    \n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3442442"}, {"introduction": "在理解了四元数的表示特性后，下一步是学习如何利用它来施加几何约束。本练习要求你为一个刚体推导并实现一个定向排列约束，该约束将刚体的特定方向与空间中的一个固定方向对齐。你将运用虚功原理和拉格朗日乘子法，将一个抽象的几何条件转化为一个具体的约束转矩。[@problem_id:3442479]", "problem": "考虑一个用于分子动力学模拟的刚体，其方向由一个单位Hamilton四元数 $\\,\\mathbf{q}=(q_0,q_1,q_2,q_3)\\,$ 表示，并采用标量优先的顺序。设 $\\,R(\\mathbf{q})\\in\\mathbb{R}^{3\\times 3}\\,$ 是对应于 $\\,\\mathbf{q}\\,$ 的旋转矩阵，它将体固定坐标系中的向量映射到空间（实验室）坐标系。将方向对齐约束定义为标量函数\n$$\ng(\\mathbf{q})=\\hat{\\mathbf{e}}_z\\cdot R(\\mathbf{q})\\hat{\\mathbf{n}}-c,\n$$\n其中 $\\,\\hat{\\mathbf{e}}_z=(0,0,1)\\,$ 是沿空间坐标系 $z$ 轴的单位向量，$\\,\\hat{\\mathbf{n}}\\in\\mathbb{R}^3\\,$ 是固定在体坐标系中的单位向量，而 $\\,c\\in[-1,1]\\,$ 是一个给定的常数。角度以弧度为单位。所有力矩必须以牛顿·米（N·m）表示。\n\n从适用于刚体动力学和分子动力学的第一性原理出发：\n- 使用完整约束的虚功原理和小转动的四元数运动学关系，推导与 $\\,g(\\mathbf{q})\\,$ 相关的广义约束力矩 $\\,\\boldsymbol{\\tau}_c(\\mathbf{q},\\lambda)\\,$ 的表达式，其中 $\\,\\lambda\\,$ 是单位为牛顿·米的拉格朗日乘子。\n- 使用四元数微积分以及无穷小角变分 $\\,\\delta\\boldsymbol{\\theta}\\in\\mathbb{R}^3\\,$ 与四元数变分 $\\,\\delta\\mathbf{q}\\,$ 之间的映射关系，推导梯度 $\\,\\nabla_{\\mathbf{q}} g(\\mathbf{q})\\in\\mathbb{R}^4\\,$。设 $\\,E(\\mathbf{q})\\in\\mathbb{R}^{4\\times 3}\\,$ 表示对于角速度 $\\,\\boldsymbol{\\omega}\\,$ 满足 $\\,\\dot{\\mathbf{q}}=\\tfrac{1}{2}E(\\mathbf{q})\\boldsymbol{\\omega}\\,$ 的矩阵；用它来表示 $\\,\\nabla_{\\mathbf{q}} g(\\mathbf{q})\\,$ 的闭合形式表达式。\n\n您必须实现一个完整的程序，该程序能够：\n1. 将任何输入的四元数 $\\,\\mathbf{q}\\,$ 和任何输入的体固定方向 $\\,\\hat{\\mathbf{n}}\\,$ 归一化至单位长度。\n2. 从归一化后的四元数计算 $\\,R(\\mathbf{q})\\,$。\n3. 根据您的推导计算约束力矩 $\\,\\boldsymbol{\\tau}_c(\\mathbf{q},\\lambda)\\,$ 和四元数梯度 $\\,\\nabla_{\\mathbf{q}} g(\\mathbf{q})\\,$。\n4. 对于下面测试套件中的每个测试用例，输出大小 $\\,\\|\\boldsymbol{\\tau}_c\\|\\,$（以N·m为单位），并四舍五入到六位小数。\n\n使用以下参数值的测试套件：\n- 测试用例 1（一般非平凡对齐）：$\\,\\mathbf{q}=\\big(\\cos(\\pi/8),\\,0,\\,\\sin(\\pi/8),\\,0\\big),\\ \\hat{\\mathbf{n}}=(0,0,1),\\ c=0.7,\\ \\lambda=1.0\\,$.\n- 测试用例 2（边界对齐，零力矩方向）：$\\,\\mathbf{q}=(1,0,0,0),\\ \\hat{\\mathbf{n}}=(0,0,1),\\ c=1.0,\\ \\lambda=5.0\\,$.\n- 测试用例 3（未归一化四元数，离轴体方向）：$\\,\\mathbf{q}=(0.9,0.3,0.1,0.1),\\ \\hat{\\mathbf{n}}=(1,0,0),\\ c=0.0,\\ \\lambda=2.0\\,$.\n- 测试用例 4（反向对齐，零力矩方向）：$\\,\\mathbf{q}=(0,1,0,0),\\ \\hat{\\mathbf{n}}=(0,0,1),\\ c=-1.0,\\ \\lambda=3.0\\,$.\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。具体来说，按上述顺序列出四个测试用例的力矩大小，每个都四舍五入到六位小数，例如 $\\,\\big[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\big]\\,$。", "solution": "问题陈述已经过验证，并被认为是有科学依据的、适定的和客观的。它为约束刚体动力学中的一个标准问题提供了一个完整且一致的设定。\n\n任务是推导约束力矩 $\\boldsymbol{\\tau}_c$ 和约束函数的四元数梯度 $\\nabla_{\\mathbf{q}} g(\\mathbf{q})$ 的表达式，然后实现这些表达式以计算几个测试用例的力矩大小。按照要求，所有数学推导和步骤都将从第一性原理出发进行阐述。\n\n### 约束力矩 $\\boldsymbol{\\tau}_c$ 的推导\n\n该约束由完整方程 $g(\\mathbf{q}) = \\hat{\\mathbf{e}}_z \\cdot R(\\mathbf{q})\\hat{\\mathbf{n}} - c = 0$ 给出。与此约束相关的广义力（在此情况下为力矩）可以使用虚功原理推导得出。在无穷小虚转动 $\\delta\\boldsymbol{\\theta}$（在空间坐标系中表示）下，由约束力矩 $\\boldsymbol{\\tau}_c$ 所做的虚功 $\\delta W_c$ 为：\n$$\n\\delta W_c = \\boldsymbol{\\tau}_c \\cdot \\delta\\boldsymbol{\\theta}\n$$\n根据拉格朗日乘子法，该虚功也可由 $\\delta W_c = -\\lambda \\delta g$ 给出，其中 $\\lambda$ 是拉格朗日乘子，$\\delta g$ 是约束函数的变分。\n我们通过对 $g(\\mathbf{q})$ 取变分来计算 $\\delta g$：\n$$\n\\delta g = \\delta (\\hat{\\mathbf{e}}_z \\cdot R(\\mathbf{q})\\hat{\\mathbf{n}} - c) = \\hat{\\mathbf{e}}_z \\cdot (\\delta R(\\mathbf{q})) \\hat{\\mathbf{n}}\n$$\n因为 $\\hat{\\mathbf{e}}_z$、$\\hat{\\mathbf{n}}$ 和 $c$ 是常数。\n\n空间坐标系中的无穷小转动 $\\delta\\boldsymbol{\\theta}$ 引起旋转矩阵 $R$ 的变化，该变化由 $\\delta R = [\\delta\\boldsymbol{\\theta}]_{\\times} R$ 给出，其中 $[\\mathbf{v}]_{\\times}$ 是对应于叉积算子的斜对称矩阵，使得 $[\\mathbf{v}]_{\\times}\\mathbf{u} = \\mathbf{v} \\times \\mathbf{u}$。将此代入 $\\delta g$ 的表达式中：\n$$\n\\delta g = \\hat{\\mathbf{e}}_z \\cdot ([\\delta\\boldsymbol{\\theta}]_{\\times} R(\\mathbf{q})\\hat{\\mathbf{n}}) = \\hat{\\mathbf{e}}_z \\cdot (\\delta\\boldsymbol{\\theta} \\times (R(\\mathbf{q})\\hat{\\mathbf{n}}))\n$$\n使用标量三重积恒等式 $\\mathbf{a} \\cdot (\\mathbf{b} \\times \\mathbf{c}) = \\mathbf{b} \\cdot (\\mathbf{c} \\times \\mathbf{a})$，我们得到：\n$$\n\\delta g = \\delta\\boldsymbol{\\theta} \\cdot (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)\n$$\n现在，我们令两个虚功的表达式相等：\n$$\n\\boldsymbol{\\tau}_c \\cdot \\delta\\boldsymbol{\\theta} = -\\lambda \\, \\delta g = -\\lambda \\, \\delta\\boldsymbol{\\theta} \\cdot (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)\n$$\n这个等式必须对任意虚转动 $\\delta\\boldsymbol{\\theta}$ 成立。因此，我们可以令向量系数相等：\n$$\n\\boldsymbol{\\tau}_c = -\\lambda (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z) = \\lambda (\\hat{\\mathbf{e}}_z \\times R(\\mathbf{q})\\hat{\\mathbf{n}})\n$$\n这是空间坐标系中约束力矩的表达式。其大小为 $\\|\\boldsymbol{\\tau}_c\\| = |\\lambda| \\|\\hat{\\mathbf{e}}_z \\times R(\\mathbf{q})\\hat{\\mathbf{n}}\\|$。由于 $\\hat{\\mathbf{e}}_z$ 和 $\\hat{\\mathbf{n}}$ 是单位向量且 $R(\\mathbf{q})$ 是旋转矩阵，因此 $R(\\mathbf{q})\\hat{\\mathbf{n}}$ 也是一个单位向量。大小可简化为 $\\|\\boldsymbol{\\tau}_c\\| = |\\lambda| \\sqrt{1 - (\\hat{\\mathbf{e}}_z \\cdot R(\\mathbf{q})\\hat{\\mathbf{n}})^2}$。\n\n### 四元数梯度 $\\nabla_{\\mathbf{q}} g(\\mathbf{q})$ 的推导\n\n标量函数 $g(\\mathbf{q})$ 关于四元数 $\\mathbf{q} \\in \\mathbb{R}^4$ 的梯度将变分 $\\delta g$ 与四元数变分 $\\delta\\mathbf{q}$ 联系起来：\n$$\n\\delta g = (\\nabla_{\\mathbf{q}} g)^T \\delta\\mathbf{q}\n$$\n问题给出了四元数运动学方程，该方程将四元数的时间导数 $\\dot{\\mathbf{q}}$ 与体坐标系角速度 $\\boldsymbol{\\omega}_b$ 联系起来：\n$$\n\\dot{\\mathbf{q}} = \\frac{1}{2}E(\\mathbf{q})\\boldsymbol{\\omega}_b\n$$\n对于一个无穷小时间步长 $\\delta t$，变分由 $\\delta\\mathbf{q} = \\dot{\\mathbf{q}}\\delta t$ 和 $\\delta\\boldsymbol{\\theta}_s = \\boldsymbol{\\omega}_s \\delta t$ 关联，其中 $\\boldsymbol{\\omega}_s$ 是空间坐标系中的角速度。空间坐标系和体坐标系的角速度通过 $\\boldsymbol{\\omega}_s = R(\\mathbf{q})\\boldsymbol{\\omega}_b$ 相关联，或者说 $\\boldsymbol{\\omega}_b = R(\\mathbf{q})^T\\boldsymbol{\\omega}_s$。\n将此代入 $\\delta\\mathbf{q}$ 的表达式中：\n$$\n\\delta\\mathbf{q} = \\frac{1}{2} E(\\mathbf{q}) (R(\\mathbf{q})^T \\boldsymbol{\\omega}_s) \\delta t = \\frac{1}{2} E(\\mathbf{q}) R(\\mathbf{q})^T \\delta\\boldsymbol{\\theta}_s\n$$\n将此代入 $\\delta g$ 的梯度关系式中：\n$$\n\\delta g = (\\nabla_{\\mathbf{q}} g)^T \\left( \\frac{1}{2} E(\\mathbf{q}) R(\\mathbf{q})^T \\delta\\boldsymbol{\\theta}_s \\right) = \\frac{1}{2} (\\nabla_{\\mathbf{q}} g)^T E(\\mathbf{q}) R(\\mathbf{q})^T \\delta\\boldsymbol{\\theta}_s\n$$\n我们之前已经发现 $\\delta g = (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)^T \\delta\\boldsymbol{\\theta}_s$。比较 $\\delta g$ 的两个表达式，我们可以确定 $\\delta\\boldsymbol{\\theta}_s$ 的系数：\n$$\n(R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)^T = \\frac{1}{2} (\\nabla_{\\mathbf{q}} g)^T E(\\mathbf{q}) R(\\mathbf{q})^T\n$$\n对两边取转置：\n$$\nR(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z = \\frac{1}{2} R(\\mathbf{q}) E(\\mathbf{q})^T \\nabla_{\\mathbf{q}} g\n$$\n为了求解 $\\nabla_{\\mathbf{q}} g$，我们从左侧乘以 $R(\\mathbf{q})^T$ 并利用 $R(\\mathbf{q})$ 的正交性：\n$$\nR(\\mathbf{q})^T(R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z) = \\frac{1}{2} E(\\mathbf{q})^T \\nabla_{\\mathbf{q}} g\n$$\n此方程将一个3维向量与4维向量 $\\nabla_{\\mathbf{q}} g$ 的投影联系起来。我们需要一个附加条件。由于 $\\mathbf{q}$ 是单位四元数，任何有效的变分 $\\delta\\mathbf{q}$ 必须与 $\\mathbf{q}$ 正交（即 $\\mathbf{q}^T\\delta\\mathbf{q}=0$）。因此，$\\nabla_{\\mathbf{q}} g$ 的物理上有意义的分量也必须与 $\\mathbf{q}$ 正交。矩阵 $E(\\mathbf{q})$ 具有其列向量与 $\\mathbf{q}$ 正交的性质（$E(\\mathbf{q})^T\\mathbf{q} = \\mathbf{0}$）。所以，$\\nabla_{\\mathbf{q}} g$ 必须位于 $E(\\mathbf{q})$ 的列空间中，即 $\\nabla_{\\mathbf{q}} g = E(\\mathbf{q})\\mathbf{u}$ 对于某个向量 $\\mathbf{u} \\in \\mathbb{R}^3$ 成立。\n将此代入我们的方程中：\n$$\nR(\\mathbf{q})^T(R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z) = \\frac{1}{2} E(\\mathbf{q})^T (E(\\mathbf{q})\\mathbf{u}) = \\frac{1}{2} (E(\\mathbf{q})^T E(\\mathbf{q})) \\mathbf{u}\n$$\n对于单位四元数，$E(\\mathbf{q})^T E(\\mathbf{q}) = \\|\\mathbf{q}\\|^2 I_{3\\times3} = I_{3\\times3}$。因此，我们可以解出 $\\mathbf{u}$：\n$$\n\\mathbf{u} = 2 R(\\mathbf{q})^T (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)\n$$\n最后，将 $\\mathbf{u}$ 代回 $\\nabla_{\\mathbf{q}} g$ 的表达式中：\n$$\n\\nabla_{\\mathbf{q}} g(\\mathbf{q}) = 2 E(\\mathbf{q}) R(\\mathbf{q})^T (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)\n$$\n这是四元数梯度的闭合形式表达式。\n\n### 计算步骤\n对每个测试用例，执行以下步骤：\n1.  将输入的四元数 $\\mathbf{q}_{in}$ 和体固定向量 $\\hat{\\mathbf{n}}_{in}$ 归一化至单位长度，得到 $\\mathbf{q}$ 和 $\\hat{\\mathbf{n}}$。\n2.  旋转矩阵 $R(\\mathbf{q})$ 由归一化后的四元数 $\\mathbf{q} = (q_0, q_1, q_2, q_3)^T$ 的分量构造得出：\n    $$\n    R(\\mathbf{q}) = \\begin{pmatrix}\n    q_0^2 + q_1^2 - q_2^2 - q_3^2 & 2(q_1q_2 - q_0q_3) & 2(q_1q_3 + q_0q_2) \\\\\n    2(q_1q_2 + q_0q_3) & q_0^2 - q_1^2 + q_2^2 - q_3^2 & 2(q_2q_3 - q_0q_1) \\\\\n    2(q_1q_3 - q_0q_2) & 2(q_2q_3 + q_0q_1) & q_0^2 - q_1^2 - q_2^2 + q_3^2\n    \\end{pmatrix}\n    $$\n3.  计算旋转后的体向量 $\\mathbf{v}_s = R(\\mathbf{q})\\hat{\\mathbf{n}}$。\n4.  使用推导出的公式计算空间坐标系中的约束力矩：$\\boldsymbol{\\tau}_c = \\lambda (\\hat{\\mathbf{e}}_z \\times \\mathbf{v}_s)$，其中 $\\hat{\\mathbf{e}}_z=(0,0,1)^T$。\n5.  计算并存储欧几里得范数（大小）$\\|\\boldsymbol{\\tau}_c\\|$。\n6.  程序输出力矩大小的列表，每个值都四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating the constraint torque magnitude for each test case.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Format: (quaternion, body_vector_n, constant_c, lambda)\n    test_cases = [\n        ((np.cos(np.pi/8), 0, np.sin(np.pi/8), 0), (0, 0, 1), 0.7, 1.0),\n        ((1, 0, 0, 0), (0, 0, 1), 1.0, 5.0),\n        ((0.9, 0.3, 0.1, 0.1), (1, 0, 0), 0.0, 2.0),\n        ((0, 1, 0, 0), (0, 0, 1), -1.0, 3.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        q_in, n_in, c, lambda_val = case\n        \n        # The constant c is part of the constraint g(q)=0 definition but does not\n        # enter the expression for the torque, which depends on the gradient of g.\n        \n        # 1. Normalize quaternion and body-fixed vector\n        q_in = np.array(q_in, dtype=float)\n        q = q_in / np.linalg.norm(q_in)\n\n        n_in = np.array(n_in, dtype=float)\n        norm_n = np.linalg.norm(n_in)\n        # Avoid division by zero if n_in is a zero vector, though not in test cases.\n        n = n_in / norm_n if norm_n > 0 else n_in\n\n        # 2. Compute rotation matrix R(q) from the normalized quaternion\n        q0, q1, q2, q3 = q[0], q[1], q[2], q[3]\n\n        R = np.array([\n            [q0**2 + q1**2 - q2**2 - q3**2, 2*(q1*q2 - q0*q3), 2*(q1*q3 + q0*q2)],\n            [2*(q1*q2 + q0*q3), q0**2 - q1**2 + q2**2 - q3**2, 2*(q2*q3 - q0*q1)],\n            [2*(q1*q3 - q0*q2), 2*(q2*q3 + q0*q1), q0**2 - q1**2 - q2**2 + q3**2]\n        ])\n        \n        # 3. Compute rotated vector and constraint torque\n        e_z = np.array([0.0, 0.0, 1.0])\n        v_s = R @ n\n        \n        # From derivation: tau_c = lambda * (e_z x R*n)\n        tau_c = lambda_val * np.cross(e_z, v_s)\n        \n        # 4. Compute the magnitude of the torque\n        tau_c_magnitude = np.linalg.norm(tau_c)\n        results.append(f\"{tau_c_magnitude:.6f}\")\n\n        # The problem also asks for the derivation of the quaternion gradient,\n        # but not for its computation in the output. The derived formula is:\n        # grad_g = 2 * E(q) * R(q)^T * (R(q)n x e_z)\n        # The following lines could be uncommented to compute it.\n        # E = np.array([\n        #     [-q1, -q2, -q3],\n        #     [ q0, -q3,  q2],\n        #     [ q3,  q0, -q1],\n        #     [-q2,  q1,  q0]\n        # ])\n        # grad_g = 2 * E @ R.T @ np.cross(v_s, e_z)\n\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3442479"}, {"introduction": "将动力学与约束相结合是刚体模拟的核心。这个综合性练习要求你设计并实现一个完整的时间步进积分器，用于模拟无转矩刚体的旋转动力学。你将把欧拉方程与四元数运动学相结合，并实现经典的SHAKE和RATTLE算法，以确保在数值积分过程中四元数单位范数和速度约束得到满足，从而保证能量的守恒性。[@problem_id:3442413]", "problem": "您的任务是在分子动力学环境中，设计并分析一种用于单个刚体受约束旋转动力学的数值方案，该方案使用单位四元数来表示朝向。基本原理必须是牛顿-欧拉刚体动力学和四元数运动学。目标是实现一个时间步进积分器，该积分器能够维持单位四元数约束并尊重等价关系 $q \\sim -q$，然后量化不同约束投影策略对测量的旋转温度的影响。\n\n假设一个刚体，其对角主转动惯量在体坐标系中表示为 $I = \\operatorname{diag}(I_1,I_2,I_3)$。设体坐标系中的角速度为 $\\omega \\in \\mathbb{R}^3$，朝向四元数为 $q \\in \\mathbb{R}^4$，其分量为 $q = (q_0,q_x,q_y,q_z)$。该四元数必须满足完整约束 $C(q) = q^\\top q - 1 = 0$，并且物理上相同的朝向满足等价关系 $q \\sim -q$。力矩为零，因此无力矩刚体方程成立。\n\n使用以下基础：\n- 体坐标系中的无力矩欧拉方程为 $I \\dot{\\omega} = - \\omega \\times (I \\omega)$，其中 $I$ 是惯性张量，$\\times$ 是矢量叉乘。\n- 四元数运动学为 $\\dot{q} = \\tfrac{1}{2} q \\otimes \\Omega$，其中 $\\otimes$ 表示四元数乘法，$\\Omega = (0,\\omega)$ 是矢量部分为 $\\omega$ 的纯虚四元数。\n- 旋转动能为 $K = \\tfrac{1}{2} \\omega^\\top I \\omega$。\n- 瞬时旋转温度（使用能量均分定理）为 $T_{\\text{rot}} = \\dfrac{2 K}{f k_B}$，其中旋转自由度 $f = 3$，玻尔兹曼常数 $k_B$。使用 $k_B = 1$ 的约化单位。\n\n实现一个具有以下结构和科学真实约束的单分子模拟：\n1. 使用一阶显式更新从欧拉方程对 $\\omega$ 进行时间积分：$\\omega_{n+1} = \\omega_n + \\Delta t \\, I^{-1} \\left( - \\omega_n \\times (I \\omega_n) \\right)$，时间步长 $\\Delta t$ 以秒为单位。角度以弧度为单位。\n2. 使用显式更新对 $q$ 进行时间积分：$q_{n+1}^{\\text{unc}} = q_n + \\Delta t \\, \\dot{q}_n$，其中 $\\dot{q}_n = \\tfrac{1}{2} q_n \\otimes (0,\\omega_{n+1})$。\n3. 位置约束投影（“SHAKE”）：通过将 $q_{n+1}^{\\text{unc}}$ 归一化为 $q_{n+1} = \\dfrac{q_{n+1}^{\\text{unc}}}{\\|q_{n+1}^{\\text{unc}}\\|}$ 来强制执行 $\\|q_{n+1}\\| = 1$。\n4. 符号等价性处理 $q \\sim -q$：归一化后，可选择使用下面定义的策略之一将 $q_{n+1}$ 投影到一个规范代表上。\n5. 速度约束投影（“RATTLE”）：位置投影后，强制执行速度级约束 $q^\\top \\dot{q} = 0$。设 $S(q)$ 是一个 $4 \\times 3$ 矩阵，使得对于给定的 $q$，$\\dot{q} = \\tfrac{1}{2} S(q) \\omega$ 对 $\\omega$ 线性成立。通过 $\\dot{q}^{\\text{proj}} = \\dot{q} - (q^\\top \\dot{q}) q$ 将 $\\dot{q}$ 投影到切空间，然后通过最小二乘法恢复调整后的角速度 $\\omega' = \\arg\\min_{\\omega} \\| \\tfrac{1}{2} S(q) \\omega - \\dot{q}^{\\text{proj}} \\|_2$，即以最小二乘方式求解 $S(q)\\omega = 2 \\dot{q}^{\\text{proj}}$。如果所选策略包含 RATTLE，则将校正后的角速度设置为 $\\omega'$ 用于下一步。\n\n设计并比较以下三种投影策略：\n- 策略 P0：归一化 $q$ (SHAKE)。不强制任何符号约定，也不对 $\\omega$ 应用 RATTLE。\n- 策略 P1：归一化 $q$ (SHAKE)，通过翻转 $q$ 以确保 $q_0 \\ge 0$ (如果 $q_0 < 0$，则使用 $q \\leftarrow -q$) 来强制执行半球符号约定，并通过上述最小二乘程序应用 RATTLE 校正 $\\omega$。\n- 策略 P2：归一化 $q$ (SHAKE)，通过翻转 $q$ 以最大化 $q \\cdot q_{\\text{prev}}$ (如果 $q^\\top q_{\\text{prev}} < 0$，则使用 $q \\leftarrow -q$) 来强制执行最大重叠符号约定，并通过最小二乘法应用 RATTLE 校正 $\\omega$。\n\n对于每种策略，模拟 $N$ 步并计算轨迹上瞬时旋转温度 $T_{\\text{rot}}$ 的时间平均值。通过报告平均测量温度 $\\overline{T_{\\text{rot}}}$ 与根据初始 $\\omega_0$ 和 $I$ 计算的理论基线 $T_0 = \\dfrac{2 K_0}{f k_B}$ 之间的差异来量化每种策略的效果，使用 $f = 3$ 和 $k_B = 1$。具体来说，报告每种策略的 $\\Delta T = \\overline{T_{\\text{rot}}} - T_0$。\n\n角度必须以弧度为单位，时间以秒为单位，惯量以千克-米平方为单位，角速度以弧度/秒为单位。温度必须以与 $k_B = 1$ 一致的能量单位报告。\n\n您可以使用任何现代语言实现该程序，但最终答案必须是一个完整、可运行的Python程序。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按下面指定的顺序包含所有策略和所有测试用例的 $\\Delta T$ 值。\n\n使用以下探测不同物理和数值体系的测试套件：\n\n- 测试用例 1 (理想情况，球形陀螺): $I = \\operatorname{diag}(1,1,1)$, $q_0 = (1,0,0,0)$, $\\omega_0 = (0.2,0.3,0.4)$, $\\Delta t = 0.01$, $N = 1000$。按 P0、P1、P2 的顺序报告三个浮点数。\n\n- 测试用例 2 (符号边界，球形陀螺): $I = \\operatorname{diag}(1,1,1)$, $q_0 = (-0.001,0.70710678,0,0.70710678)$, $\\omega_0 = (0.8,0.0,0.0)$, $\\Delta t = 0.02$, $N = 1200$。按 P0、P1、P2 的顺序报告三个浮点数。\n\n- 测试用例 3 (不对称陀螺，中等时间步长): $I = \\operatorname{diag}(1.0,1.5,2.0)$, $q_0 = (0.92387953,0.38268343,0,0)$, $\\omega_0 = (0.7,0.01,0.02)$, $\\Delta t = 0.02$, $N = 1500$。按 P0、P1、P2 的顺序报告三个浮点数。\n\n- 测试用例 4 (不对称陀螺，较大时间步长，接近符号翻转): $I = \\operatorname{diag}(0.8,1.2,1.6)$, $q_0 = (0.0,0.70710678,0.70710678,0.0)$, $\\omega_0 = (0.5,0.5,0.0)$, $\\Delta t = 0.05$, $N = 600$。按 P0、P1、P2 的顺序报告三个浮点数。\n\n您的程序必须计算上述每个测试用例和策略的 $\\Delta T$ 值，并以完全如下的格式打印单行：一个包含十二个逗号分隔浮点数的列表，对应于 $[\\Delta T_{\\text{P0,TC1}},\\Delta T_{\\text{P1,TC1}},\\Delta T_{\\text{P2,TC1}},\\Delta T_{\\text{P0,TC2}},\\Delta T_{\\text{P1,TC2}},\\Delta T_{\\text{P2,TC2}},\\Delta T_{\\text{P0,TC3}},\\Delta T_{\\text{P1,TC3}},\\Delta T_{\\text{P2,TC3}},\\Delta T_{\\text{P0,TC4}},\\Delta T_{\\text{P1,TC4}},\\Delta T_{\\text{P2,TC4}}]$。", "solution": "用户提供了一个具有科学依据、问题明确、客观且自成体系的问题；因此，该问题被视为**有效**。我们将提供完整的解决方案。\n\n该问题要求实现并分析一个用于无力矩刚体旋转动力学的数值积分器。朝向由单位四元数 $q$ 描述，其演化与体坐标系角速度 $\\omega$ 耦合。问题的核心在于比较三种不同的策略（P0、P1、P2），这些策略用于处理违反四元数单位范数约束的数值误差，以及管理四元数表示中固有的符号模糊性（$q \\sim -q$）。\n\n### 1. 理论框架\n\n刚体的动力学由牛顿-欧拉方程控制。对于一个无力矩系统，体固主轴坐标系中的旋转运动由欧拉方程描述：\n$$\nI \\dot{\\omega} = - \\omega \\times (I \\omega)\n$$\n其中 $I = \\operatorname{diag}(I_1, I_2, I_3)$ 是主转动惯量的对角张量，$\\omega \\in \\mathbb{R}^3$ 是体坐标系中的角速度矢量。\n\n物体的朝向由一个单位四元数 $q = (q_0, q_x, q_y, q_z) \\in \\mathbb{R}^4$ 表示，它必须满足完整约束 $C(q) = q^\\top q - 1 = 0$。将四元数的时间导数与角速度关联起来的运动学方程是：\n$$\n\\dot{q} = \\frac{1}{2} q \\otimes \\Omega\n$$\n其中 $\\Omega = (0, \\omega)$ 是一个纯四元数（标量部分为零），$\\otimes$ 表示四元数乘法。\n\n旋转动能由 $K = \\frac{1}{2} \\omega^\\top I \\omega$ 给出。根据能量均分定理，对于一个具有 $f=3$ 个自由度的系统，瞬时旋转温度为 $T_{\\text{rot}} = \\frac{2K}{f k_B}$。使用玻尔兹曼常数 $k_B=1$ 的约化单位，这简化为：\n$$\nT_{\\text{rot}} = \\frac{2}{3} K = \\frac{1}{3} \\omega^\\top I \\omega\n$$\n\n### 2. 数值积分方案\n\n构建一个离散时间步进算法来求解这些耦合的微分方程。模拟从初始状态 $(q_0, \\omega_0)$ 开始，时间步长为 $\\Delta t$。必须以归一化的四元数开始，因此提供的初始 $q_0$ 首先被缩放以具有单位长度。每一步 $n \\to n+1$ 都包含以下序列：\n\n**步骤 2.1: 角速度预测**\n使用显式前向欧拉步骤来预测下一个时间步的角速度：\n$$\n\\omega_{n+1}^{\\text{pred}} = \\omega_n + \\Delta t \\, I^{-1} (-\\omega_n \\times (I \\omega_n))\n$$\n这个新速度 $\\omega_{n+1}^{\\text{pred}}$ 是一个未校正的预测值。\n\n**步骤 2.2: 四元数更新**\n使用半隐式方案更新四元数，其中朝向 $q_n$ 使用预测的角速度 $\\omega_{n+1}^{\\text{pred}}$ 进行推进：\n$$\n\\dot{q}_n = \\frac{1}{2} q_n \\otimes (0, \\omega_{n+1}^{\\text{pred}})\n$$\n$$\nq_{n+1}^{\\text{unc}} = q_n + \\Delta t \\, \\dot{q}_n\n$$\n由于离散化误差，得到的四元数 $q_{n+1}^{\\text{unc}}$ 将不具有完美的单位范数。\n\n### 3. 约束和等价性处理\n\n为了保持物理和数学上的一致性，必须在每一步强制执行约束。问题为此定义了三种策略。\n\n**策略 P0：仅 SHAKE**\n这是最简单的策略。它只通过归一化非约束四元数来强制执行位置级约束 $q^\\top q = 1$。此过程通常被称为针对位置的 SHAKE。\n$$\nq_{n+1} = \\frac{q_{n+1}^{\\text{unc}}}{\\|q_{n+1}^{\\text{unc}}\\|}\n$$\n在这种策略中，下一步的角速度就是预测值，即 $\\omega_{n+1} = \\omega_{n+1}^{\\text{pred}}$。此方法不校正速度以与校正后的位置保持一致，这通常会导致系统总能量的系统性漂移。\n\n**策略 P1 & P2：SHAKE、符号约定和 RATTLE**\n这些策略更为复杂。它们在 SHAKE 的基础上增加了四元数的符号约定和对角速度的 RATTLE 校正。\n\n**步骤 3.1: 符号约定 (P1 和 P2)**\n归一化（SHAKE）之后，将四元数 $q_{n+1}$ 投影到一个规范表示上，以处理 $q \\sim -q$ 的等价性。\n- **P1 (半球):** 如果四元数的标量部分为负，则翻转它，确保 $q_{n+1, 0} \\ge 0$。这将表示强制到四维超球体的一侧。\n- **P2 (最大重叠):** 如果四元数与上一步的四元数反平行，则翻转它，确保 $q_{n+1}^\\top q_n \\ge 0$。这最小化了轨迹中连续四元数之间的“距离”，通常能带来更平滑、更稳定的模拟。\n\n**步骤 3.2: 速度校正 (RATTLE)**\n离散化破坏了速度级约束，该约束规定 $\\dot{q}$ 必须在 $q$ 处与单位超球面相切（即 $q^\\top\\dot{q}=0$）。RATTLE 校正角速度以恢复此属性。\n首先，我们定义一个矩阵 $S(q) \\in \\mathbb{R}^{4 \\times 3}$，它通过 $\\dot{q} = \\frac{1}{2}S(q)\\omega$ 将 $\\omega$ 与 $\\dot{q}$ 线性关联起来：\n$$\nS(q) = \\begin{pmatrix} -q_x & -q_y & -q_z \\\\ q_0 & -q_z & q_y \\\\ q_z & q_0 & -q_x \\\\ -q_y & q_x & q_0 \\end{pmatrix}\n$$\nRATTLE 过程如下：\n1.  使用校正后的位置 $q_{n+1}$ 和预测的角速度 $\\omega_{n+1}^{\\text{pred}}$ 定义一个临时的四元数速度：$\\dot{q}^{\\text{temp}} = \\frac{1}{2}S(q_{n+1})\\omega_{n+1}^{\\text{pred}}$。\n2.  通过移除其法向分量，将此速度投影到 $q_{n+1}$ 处的切空间上：$\\dot{q}^{\\text{proj}} = \\dot{q}^{\\text{temp}} - (q_{n+1}^\\top \\dot{q}^{\\text{temp}}) q_{n+1}$。\n3.  通过以最小二乘方式求解 $\\frac{1}{2}S(q_{n+1})\\omega = \\dot{q}^{\\text{proj}}$ 来找到产生此投影速度的校正角速度 $\\omega_{n+1}$。矩阵 $S(q)$ 有一个有用的性质：对于单位四元数 $q$，$S(q)^\\top S(q) = I_{3\\times3}$，其中 $I_{3 \\times 3}$ 是单位矩阵。这意味着伪逆就是 $S(q)^\\top$。因此，解是一个直接的计算：\n    $$\n    \\omega_{n+1} = 2 S(q_{n+1})^\\top \\dot{q}^{\\text{proj}}\n    $$\n这个 $\\omega_{n+1}$ 是该步骤的最终校正角速度，用于计算动能和将动力学传播到下一步。\n\n### 4. 分析\n\n对于每种策略和每个测试用例，模拟运行 $N$ 步。在每一步 $i=1, \\dots, N$ 使用该步的最终状态 $(q_i, \\omega_i)$ 计算瞬时旋转温度 $T_i$。时间平均温度为 $\\overline{T_{\\text{rot}}} = \\frac{1}{N}\\sum_{i=1}^{N} T_i$。将其与从初始状态 $(q_0, \\omega_0)$ 推导出的理论基线温度 $T_0$ 进行比较。最终报告的值是偏差 $\\Delta T = \\overline{T_{\\text{rot}}} - T_0$，它量化了每种策略的能量守恒特性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and strategies\n    and print the results in the required format.\n    \"\"\"\n\n    def quaternion_mult(q1, q2):\n        \"\"\"\n        Performs quaternion multiplication q1 * q2.\n        q1 and q2 are 4-element NumPy arrays.\n        \"\"\"\n        q1_0, q1_v = q1[0], q1[1:]\n        q2_0, q2_v = q2[0], q2[1:]\n        \n        result_0 = q1_0 * q2_0 - np.dot(q1_v, q2_v)\n        result_v = q1_0 * q2_v + q2_0 * q1_v + np.cross(q1_v, q2_v)\n        \n        return np.array([result_0, result_v[0], result_v[1], result_v[2]])\n\n    def get_S_matrix(q):\n        \"\"\"\n        Constructs the 4x3 matrix S(q) such that q_dot = 0.5 * S(q) * omega.\n        \"\"\"\n        q0, qx, qy, qz = q\n        S = np.array([\n            [-qx, -qy, -qz],\n            [ q0, -qz,  qy],\n            [ qz,  q0, -qx],\n            [-qy,  qx,  q0]\n        ])\n        return S\n\n    def run_simulation(I_diag, q_initial, omega_initial, dt, N, strategy):\n        \"\"\"\n        Runs a single rigid body simulation for N steps.\n        \n        Args:\n            I_diag (tuple): Principal moments of inertia (I1, I2, I3).\n            q_initial (tuple): Initial orientation quaternion (q0, qx, qy, qz).\n            omega_initial (tuple): Initial angular velocity (wx, wy, wz).\n            dt (float): Time step.\n            N (int): Number of steps.\n            strategy (str): 'P0', 'P1', or 'P2'.\n            \n        Returns:\n            float: The temperature difference Delta_T = avg(T_rot) - T0.\n        \"\"\"\n        I = np.diag(I_diag).astype(np.float64)\n        I_inv = np.diag(1.0 / np.array(I_diag)).astype(np.float64)\n        \n        q = np.array(q_initial, dtype=np.float64)\n        # Normalize the initial quaternion to ensure it satisfies the constraint\n        q /= np.linalg.norm(q)\n        \n        omega = np.array(omega_initial, dtype=np.float64)\n        \n        # Calculate baseline kinetic energy and temperature from initial conditions\n        K0 = 0.5 * np.dot(omega, np.dot(I, omega))\n        T0 = (2.0 * K0) / 3.0  # Given f=3, kB=1\n        \n        total_temperature = 0.0\n        \n        for _ in range(N):\n            # Step 1: Predict angular velocity using explicit Euler\n            torque = -np.cross(omega, np.dot(I, omega))\n            omega_pred = omega + dt * np.dot(I_inv, torque)\n            \n            # Step 2: Update quaternion with a semi-implicit step\n            omega_pred_quat = np.concatenate(([0], omega_pred))\n            q_dot = 0.5 * quaternion_mult(q, omega_pred_quat)\n            q_unc = q + dt * q_dot\n            \n            # Step 3: Enforce position constraint (SHAKE)\n            q_next = q_unc / np.linalg.norm(q_unc)\n            \n            omega_next = omega_pred\n            \n            # Step 4  5: Apply sign conventions and velocity constraints (RATTLE)\n            if strategy == 'P0':\n                # No sign convention, no RATTLE.\n                pass\n            \n            elif strategy == 'P1':\n                # Hemisphere sign convention\n                if q_next[0]  0:\n                    q_next = -q_next\n                \n                # RATTLE correction\n                q_dot_temp = 0.5 * np.dot(get_S_matrix(q_next), omega_pred)\n                lambda_val = np.dot(q_next, q_dot_temp)\n                q_dot_proj = q_dot_temp - lambda_val * q_next\n                \n                S_next = get_S_matrix(q_next)\n                # S(q)^T S(q) = ||q||^2 * I_3. For unit q, pseudo-inverse is S(q)^T.\n                omega_next = 2.0 * np.dot(S_next.T, q_dot_proj)\n            \n            elif strategy == 'P2':\n                # Maximum-overlap sign convention\n                if np.dot(q_next, q)  0:\n                    q_next = -q_next\n                \n                # RATTLE correction\n                q_dot_temp = 0.5 * np.dot(get_S_matrix(q_next), omega_pred)\n                lambda_val = np.dot(q_next, q_dot_temp)\n                q_dot_proj = q_dot_temp - lambda_val * q_next\n                \n                S_next = get_S_matrix(q_next)\n                omega_next = 2.0 * np.dot(S_next.T, q_dot_proj)\n\n            # Update state for the next iteration\n            q = q_next\n            omega = omega_next\n            \n            # Calculate instantaneous kinetic energy and temperature from the final state of the step\n            K_current = 0.5 * np.dot(omega, np.dot(I, omega))\n            T_current = (2.0 * K_current) / 3.0\n            total_temperature += T_current\n            \n        # Compute average temperature over the trajectory and the final difference\n        avg_T_rot = total_temperature / N\n        delta_T = avg_T_rot - T0\n        \n        return delta_T\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # TC1\n        {'I': (1.0, 1.0, 1.0), 'q0': (1.0, 0.0, 0.0, 0.0), 'omega0': (0.2, 0.3, 0.4), 'dt': 0.01, 'N': 1000},\n        # TC2\n        {'I': (1.0, 1.0, 1.0), 'q0': (-0.001, 0.70710678, 0.0, 0.70710678), 'omega0': (0.8, 0.0, 0.0), 'dt': 0.02, 'N': 1200},\n        # TC3\n        {'I': (1.0, 1.5, 2.0), 'q0': (0.92387953, 0.38268343, 0.0, 0.0), 'omega0': (0.7, 0.01, 0.02), 'dt': 0.02, 'N': 1500},\n        # TC4\n        {'I': (0.8, 1.2, 1.6), 'q0': (0.0, 0.70710678, 0.70710678, 0.0), 'omega0': (0.5, 0.5, 0.0), 'dt': 0.05, 'N': 600}\n    ]\n\n    results = []\n    strategies = ['P0', 'P1', 'P2']\n\n    for case in test_cases:\n        for strategy in strategies:\n            delta_T = run_simulation(\n                case['I'], case['q0'], case['omega0'], case['dt'], case['N'], strategy\n            )\n            results.append(delta_T)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3442413"}]}