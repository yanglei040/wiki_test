{"hands_on_practices": [{"introduction": "在构建约束分子系统时，一个基础性的选择是采用笛卡尔坐标还是广义内坐标。虽然笛卡尔坐标系概念简单，但在描述键长、键角等内运动时，可能导致数值计算上的病态问题。本练习 [@problem_id:3416352] 旨在通过对一个简单的三原子分子进行分析，让您亲手推导和比较这两种坐标系下约束执行的数值稳定性（以条件数为指标）和准确性，从而深刻理解为何在特定情况下内坐标是更优越的选择。", "problem": "考虑一个平面三原子分子，其原子标记为 $1$、 $2$ 和 $3$。设广义内坐标为 $q = [r_{12}, r_{23}, \\theta]^\\top$，其中 $r_{12}$ 是原子 $1$ 和原子 $2$ 之间的键长（以埃为单位），$r_{23}$ 是原子 $2$ 和原子 $3$ 之间的键长（以埃为单位），$\\theta$ 是在原子 $2$ 处形成的角度（原子 $2$ 到原子 $1$ 的矢量与原子 $2$ 到原子 $3$ 的矢量之间的夹角），以弧度为单位。通过将原子 $1$ 置于原点，原子 $2$ 置于 $x$ 轴上，原子 $3$ 置于由 $r_{23}$ 和 $\\theta$ 决定的位置，来定义一个从内坐标 $q$ 到笛卡尔坐标 $x \\in \\mathbb{R}^{6}$ 的固定体坐标系映射。具体而言，使用以下映射\n$$\nx(q) = \\begin{bmatrix}\nx_{1x} \\\\ x_{1y} \\\\ x_{2x} \\\\ x_{2y} \\\\ x_{3x} \\\\ x_{3y}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\ 0 \\\\\nr_{12} \\\\ 0 \\\\\nr_{12} + r_{23}\\cos\\theta \\\\\nr_{23}\\sin\\theta\n\\end{bmatrix}.\n$$\n考虑两个完整约束，使键长保持在目标值附近：\n$$\ng_1(x) = \\left\\| x_2 - x_1 \\right\\| - r_{12}^{\\text{target}}, \\quad\ng_2(x) = \\left\\| x_3 - x_2 \\right\\| - r_{23}^{\\text{target}},\n$$\n其中 $r_{12}^{\\text{target}}$ 和 $r_{23}^{\\text{target}}$ 是目标键长（以埃为单位）。在分子动力学（MD）的背景下，这些约束通过拉格朗日乘子来施加。定义笛卡尔坐标下的约束雅可比矩阵 $C_{\\text{cartesian}}(x) = \\partial g/\\partial x \\in \\mathbb{R}^{2\\times 6}$ 和坐标映射的雅可比矩阵 $J(q) = \\partial x/\\partial q \\in \\mathbb{R}^{6\\times 3}$。\n\n您的任务是：\n- 从完整约束的定义和多变量函数的链式法则出发，推导在映射 $x(q)$下，以广义内坐标表示的约束梯度与以笛卡尔坐标表示的约束梯度之间的关系。\n- 对于给定的平面三原子映射，显式计算雅可比矩阵 $J(q)$。\n- 实现一个数值程序来构建 $C_{\\text{cartesian}}(x)$、$J(q)$ 以及通过链式法则计算的内坐标约束雅可比矩阵。数值验证对于此特定映射，内坐标约束雅可比矩阵与解析的内坐标梯度相匹配。\n- 通过求解最小范数线性化校正问题，比较在笛卡尔坐标与内坐标中施加线性化约束：\n    - 笛卡尔空间校正：在最小范数意义下，求解 $C_{\\text{cartesian}}\\delta x = -g(x)$ 的解 $\\delta x$。\n    - 内坐标空间校正：在最小范数意义下，求解 $C_{\\text{internal}}\\delta q = -g(x)$ 的解 $\\delta q$，然后通过 $\\delta x = J \\delta q$ 映射回笛卡尔坐标。\n  在 $2\\times 2$ 的格拉姆矩阵 (Gram matrix) 中加入一个小的吉洪诺夫正则化 (Tikhonov regularization) 项，以处理潜在的近奇异几何构型。\n\n分析数值条件和准确性：\n- 计算 $2\\times 2$ 格拉姆矩阵 $G_{\\text{cartesian}} = C_{\\text{cartesian}}C_{\\text{cartesian}}^\\top$ 和 $G_{\\text{internal}} = C_{\\text{internal}}C_{\\text{internal}}^\\top$ 的条件数。\n- 对笛卡尔和内坐标两种施加方式，评估定义为 $\\|\\delta x\\|_2 / \\|g\\|_2$ 的放大因子。\n- 对两种方法，评估校正后精确的约束残差范数 $\\|g(x+\\delta x)\\|_2$。\n- 评估通过链式法则计算的 $C_{\\text{internal}}$ 与为此映射解析推导的内坐标梯度之间的弗罗贝尼乌斯范数 (Frobenius-norm) 差异。\n\n使用以下参数测试套件。对于每个测试用例，设置 $r_{12}^{\\text{target}} = r_{12}(1+\\varepsilon_1)$ 和 $r_{23}^{\\text{target}} = r_{23}(1+\\varepsilon_2)$，其中 $\\varepsilon_1$ 和 $\\varepsilon_2$ 是给定的。角度必须以弧度为单位，长度必须以埃为单位。向约束残差向量中添加一个小的确定性噪声向量 $n = [s, -s]^\\top$（其中 $s = 10^{-6}$ 埃），以探测灵敏度。\n\n测试套件（每个案例为 $(r_{12}, r_{23}, \\theta, \\varepsilon_1, \\varepsilon_2)$）：\n- 案例 A（正常路径）：$(1.5, 1.2, 1.0, 0.02, -0.015)$。\n- 案例 B（近共线）：$(1.0, 1.0, 0.001, 0.05, 0.05)$。\n- 案例 C（近 $\\pi$）：$(1.0, 1.0, \\pi - 0.001, -0.02, 0.03)$。\n- 案例 D（键长差异大）：$(2.0, 0.5, 1.5, 0.01, -0.01)$。\n\n您的程序必须为每个测试用例计算并按固定顺序输出以下七个浮点数结果：\n1. $G_{\\text{cartesian}}$ 的条件数（无量纲）。\n2. $G_{\\text{internal}}$ 的条件数（无量纲）。\n3. 笛卡尔坐标下的放大因子 $\\|\\delta x_{\\text{cartesian}}\\|_2 / \\|g\\|_2$（无量纲）。\n4. 内坐标下的放大因子 $\\|\\delta x_{\\text{internal}}\\|_2 / \\|g\\|_2$（无量纲）。\n5. 笛卡尔坐标下校正后的精确残差范数 $\\|g(x+\\delta x_{\\text{cartesian}})\\|_2$（以埃为单位）。\n6. 内坐标下校正后的精确残差范数 $\\|g(x+\\delta x_{\\text{internal}})\\|_2$（以埃为单位）。\n7. 通过链式法则计算的内坐标约束雅可比矩阵与解析的内坐标约束雅可比矩阵之间的弗罗贝尼乌斯范数差异（无量纲）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的列表的列表。每个内部列表对应一个测试用例（按测试套件的顺序排列），并包含上述指定的七个值，例如：\"[[v11,v12,...,v17],[v21,v22,...,v27],...]\"。", "solution": "该问题要求对平面三原子分子施加完整约束的两种方法进行详细分析和比较：一种在笛卡尔坐标中操作，另一种在广义内坐标中操作。分析涉及推导相关的雅可比矩阵，求解线性化约束方程，以及评估数值稳定性和准确性指标。\n\n### 步骤 1：理论推导\n\n首先，我们建立连接笛卡尔坐标和内坐标表示的数学框架。\n\n**通过链式法则建立雅可比矩阵之间的关系**\n设完整约束是笛卡尔坐标的向量函数，$g(x) \\in \\mathbb{R}^2$。笛卡尔坐标 $x \\in \\mathbb{R}^6$ 本身是广义内坐标 $q \\in \\mathbb{R}^3$ 的函数，由映射 $x(q)$ 给出。通过复合函数 $g(x(q))$，约束可以用内坐标表示。\n\n多变量函数的链式法则提供了内坐标中的约束雅可比矩阵 $C_{\\text{internal}} = \\partial g / \\partial q$ 与笛卡尔坐标中的约束雅可比矩阵 $C_{\\text{cartesian}} = \\partial g / \\partial x$ 之间的关系。\n$$\n\\frac{\\partial g}{\\partial q} = \\frac{\\partial g}{\\partial x} \\frac{\\partial x}{\\partial q}\n$$\n使用问题中的符号，其中 $J(q) = \\partial x / \\partial q$ 是坐标映射的雅可比矩阵，该关系为：\n$$\nC_{\\text{internal}}(q) = C_{\\text{cartesian}}(x(q)) J(q)\n$$\n这里，$C_{\\text{cartesian}}$ 是一个 $2 \\times 6$ 矩阵，$J(q)$ 是一个 $6 \\times 3$ 矩阵，它们的乘积 $C_{\\text{internal}}$ 是一个 $2 \\times 3$ 矩阵，符合预期。\n\n**坐标映射的显式雅可比矩阵, $J(q)$**\n广义坐标为 $q = [r_{12}, r_{23}, \\theta]^\\top$。到笛卡尔坐标 $x = [x_{1x}, x_{1y}, x_{2x}, x_{2y}, x_{3x}, x_{3y}]^\\top$ 的映射为：\n$$\nx(q) = [0, 0, r_{12}, 0, r_{12} + r_{23}\\cos\\theta, r_{23}\\sin\\theta]^\\top\n$$\n雅可比矩阵 $J(q) = \\partial x / \\partial q$ 是一个 $6 \\times 3$ 矩阵，其列是 $x$ 对 $q$ 的每个分量的偏导数。\n$$\n\\frac{\\partial x}{\\partial r_{12}} = [0, 0, 1, 0, 1, 0]^\\top\n$$\n$$\n\\frac{\\partial x}{\\partial r_{23}} = [0, 0, 0, 0, \\cos\\theta, \\sin\\theta]^\\top\n$$\n$$\n\\frac{\\partial x}{\\partial \\theta} = [0, 0, 0, 0, -r_{23}\\sin\\theta, r_{23}\\cos\\theta]^\\top\n$$\n将这些列组合起来得到雅可比矩阵：\n$$\nJ(q) = \\begin{bmatrix}\n0  0  0 \\\\\n0  0  0 \\\\\n1  0  0 \\\\\n0  0  0 \\\\\n1  \\cos\\theta  -r_{23}\\sin\\theta \\\\\n0  \\sin\\theta  r_{23}\\cos\\theta\n\\end{bmatrix}\n$$\n\n**显式笛卡尔约束雅可比矩阵, $C_{\\text{cartesian}}(x)$**\n约束为 $g_1(x) = \\|x_2 - x_1\\| - r_{12}^{\\text{target}}$ 和 $g_2(x) = \\|x_3 - x_2\\| - r_{23}^{\\text{target}}$，其中 $x_i = [x_{ix}, x_{iy}]^\\top$。$C_{\\text{cartesian}} = \\partial g / \\partial x$ 的行是 $g_1$ 和 $g_2$ 的梯度。范数 $\\|v\\|$ 的梯度是 $v/\\|v\\|$。\n$$\n\\nabla_x g_1 = \\left[ \\frac{-(x_2-x_1)^\\top}{\\|x_2-x_1\\|}, \\frac{(x_2-x_1)^\\top}{\\|x_2-x_1\\|}, \\mathbf{0}^\\top \\right]\n$$\n$$\n\\nabla_x g_2 = \\left[ \\mathbf{0}^\\top, \\frac{-(x_3-x_2)^\\top}{\\|x_3-x_2\\|}, \\frac{(x_3-x_2)^\\top}{\\|x_3-x_2\\|} \\right]\n$$\n在构型 $x=x(q)$ 处求值，我们有 $x_2-x_1 = [r_{12}, 0]^\\top$ 和 $x_3-x_2 = [r_{23}\\cos\\theta, r_{23}\\sin\\theta]^\\top$。它们的范数分别为 $r_{12}$ 和 $r_{23}$。\n将这些代入梯度表达式，得到：\n$$\nC_{\\text{cartesian}}(x(q)) = \\begin{bmatrix}\n-1  0  1  0  0  0 \\\\\n0  0  -\\cos\\theta  -\\sin\\theta  \\cos\\theta  \\sin\\theta\n\\end{bmatrix}\n$$\n\n**内坐标约束雅可比矩阵, $C_{\\text{internal}}(q)$**\n我们现在可以使用链式法则计算 $C_{\\text{internal}}$：\n$$\nC_{\\text{internal}} = C_{\\text{cartesian}}(x(q)) J(q) = \n\\begin{bmatrix}\n-1  0  1  0  0  0 \\\\\n0  0  -\\cos\\theta  -\\sin\\theta  \\cos\\theta  \\sin\\theta\n\\end{bmatrix}\n\\begin{bmatrix}\n0  0  0 \\\\\n0  0  0 \\\\\n1  0  0 \\\\\n0  0  0 \\\\\n1  \\cos\\theta  -r_{23}\\sin\\theta \\\\\n0  \\sin\\theta  r_{23}\\cos\\theta\n\\end{bmatrix}\n= \\begin{bmatrix}\n1  0  0 \\\\\n0  1  0\n\\end{bmatrix}\n$$\n这个通过链式法则推导出的结果，必须与解析的雅可比矩阵进行比较。\n从解析上看，直接用内坐标表示的约束是 $g_1(q) = r_{12} - r_{12}^{\\text{target}}$ 和 $g_2(q) = r_{23} - r_{23}^{\\text{target}}$。因此，解析的雅可比矩阵 $\\partial g / \\partial q$ 为：\n$$\nC_{\\text{internal}}^{\\text{analytical}} = \\frac{\\partial}{\\partial (r_{12}, r_{23}, \\theta)} \\begin{bmatrix} r_{12} - r_{12}^{\\text{target}} \\\\ r_{23} - r_{23}^{\\text{target}} \\end{bmatrix} = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\end{bmatrix}\n$$\n链式法则的结果与解析推导完全匹配，符合预期。数值实现将在机器精度范围内验证这一点。\n\n### 步骤 2：数值程序与分析\n\n任务的核心是求解线性化约束方程 $C \\delta y = -g$ 以获得校正向量 $\\delta y$，其中 $(C, \\delta y, g)$ 可以是笛卡尔坐标或内坐标。由于该方程组是欠定的，我们寻求最小范数解，这通过求解拉格朗日乘子得到。\n\n**笛卡尔坐标下的校正**\n我们求解 $C_{\\text{cartesian}} \\delta x = -g(x)$ 以获得最小范数的 $\\delta x$。解通过拉格朗日乘子 $\\lambda \\in \\mathbb{R}^2$ 来构建：\n$$\n\\delta x = C_{\\text{cartesian}}^\\top \\lambda, \\quad \\text{where} \\quad (C_{\\text{cartesian}}C_{\\text{cartesian}}^\\top) \\lambda = -g(x)\n$$\n矩阵 $G_{\\text{cartesian}} = C_{\\text{cartesian}}C_{\\text{cartesian}}^\\top$ 是格拉姆矩阵。使用推导出的 $C_{\\text{cartesian}}$，我们有：\n$$\nG_{\\text{cartesian}} = \\begin{bmatrix} 2  -\\cos\\theta \\\\ -\\cos\\theta  2 \\end{bmatrix}\n$$\n为了处理潜在的近奇异性，我们引入一个吉洪诺夫正则化参数 $\\alpha > 0$（选择为 $\\alpha = 10^{-14}$）并求解 $(G_{\\text{cartesian}} + \\alpha I) \\lambda = -(g(x)+n)$，其中 $n$ 是指定的噪声项。\n\n**内坐标下的校正**\n类似地，我们求解 $C_{\\text{internal}} \\delta q = -g(x(q))$ 以获得最小范数的 $\\delta q$。解为：\n$$\n\\delta q = C_{\\text{internal}}^\\top \\mu, \\quad \\text{where} \\quad (C_{\\text{internal}}C_{\\text{internal}}^\\top) \\mu = -g(x(q))\n$$\n格拉姆矩阵为 $G_{\\text{internal}} = C_{\\text{internal}}C_{\\text{internal}}^\\top = I_{2 \\times 2}$，即 $2 \\times 2$ 的单位矩阵。该矩阵是完美条件的。我们求解正则化系统 $(G_{\\text{internal}} + \\alpha I) \\mu = -(g(x(q))+n)$。然后通过线性映射 $\\delta x = J(q) \\delta q$ 找到笛卡尔校正量。\n\n**分析指标**\n数值分析侧重于以下指标：\n1.  **条件数：** $\\kappa(G) = \\|\\lambda_{\\max}\\|/\\|\\lambda_{\\min}\\|$。对于 $G_{\\text{cartesian}}$，$\\kappa = (2+|\\cos\\theta|)/(2-|\\cos\\theta|)$，当 $\\theta$ 接近 $0$ 或 $\\pi$（共线构型）时，条件数会恶化。对于 $G_{\\text{internal}}$，所有几何构型的条件数均为 $\\kappa=1$。\n2.  **放大因子：** $\\|\\delta x\\|_2 / \\|g+n\\|_2$。这衡量了输出校正对输入约束违背的灵敏度。\n3.  **校正后残差：** $\\|g(x+\\delta x)\\|_2$。由于约束是非线性的，一个线性校正步骤不会将残差完全清零。较小的值表示更准确的校正。\n4.  **雅可比矩阵验证：** $\\|C_{\\text{internal}}^{\\text{chain}} - C_{\\text{internal}}^{\\text{analytical}}\\|_F$，其值应接近浮点零。\n\n该实现将为每个测试用例计算这七个量，从而为两种坐标系下的约束施加提供定量比较。由于格拉姆矩阵是完美条件的，预计内坐标将显示出更优越的数值稳定性和效率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the molecular dynamics constraint problem for a series of test cases.\n    \"\"\"\n\n    def perform_analysis(r12, r23, theta, eps1, eps2):\n        \"\"\"\n        Performs the full numerical analysis for a single test case.\n        \"\"\"\n        # A small Tikhonov regularization parameter\n        alpha = 1e-14\n        \n        # Small deterministic noise vector\n        s = 1e-6\n        noise = np.array([s, -s])\n\n        # 1. Define internal coordinates and map to Cartesian\n        q = np.array([r12, r23, theta])\n        \n        c, s_theta = np.cos(theta), np.sin(theta)\n\n        # Mapping x(q)\n        x = np.array([\n            0.0,\n            0.0,\n            r12,\n            0.0,\n            r12 + r23 * c,\n            r23 * s_theta\n        ])\n\n        # 2. Define constraint function and target values\n        r12_target = r12 * (1.0 + eps1)\n        r23_target = r23 * (1.0 + eps2)\n\n        def g(x_vec):\n            # x_vec is a 6-element NumPy array\n            x1 = x_vec[0:2]\n            x2 = x_vec[2:4]\n            x3 = x_vec[4:6]\n            g1 = np.linalg.norm(x2 - x1) - r12_target\n            g2 = np.linalg.norm(x3 - x2) - r23_target\n            return np.array([g1, g2])\n\n        # Evaluate initial constraint violation vector and add noise\n        g_val = g(x)\n        g_noisy = g_val + noise\n\n        # 3. Compute Jacobians\n        # Mapping Jacobian J(q) = dx/dq\n        J = np.array([\n            [0.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0],\n            [1.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0],\n            [1.0, c, -r23 * s_theta],\n            [0.0, s_theta, r23 * c]\n        ])\n\n        # Cartesian constraint Jacobian C_cartesian(x(q))\n        C_cart = np.array([\n            [-1.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n            [0.0, 0.0, -c, -s_theta, c, s_theta]\n        ])\n\n        # Internal constraint Jacobian via chain rule\n        C_int_chain = C_cart @ J\n        \n        # Analytical internal constraint Jacobian\n        C_int_analytical = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]])\n        \n        # Metric 7: Frobenius norm difference\n        fro_diff = np.linalg.norm(C_int_chain - C_int_analytical, 'fro')\n\n        # 4. Cartesian-space correction\n        G_cart = C_cart @ C_cart.T\n        cond_G_cart = np.linalg.cond(G_cart) # Metric 1\n        \n        # Solve for Lagrange multipliers lambda\n        rhs = -g_noisy\n        lambda_p = np.linalg.solve(G_cart + alpha * np.identity(2), rhs)\n        \n        # Compute correction dx_cart\n        dx_cart = C_cart.T @ lambda_p\n        \n        # Compute amplification factor\n        g_norm = np.linalg.norm(g_noisy)\n        amp_factor_cart = np.linalg.norm(dx_cart) / g_norm # Metric 3\n        \n        # Compute post-correction residual\n        residual_norm_cart = np.linalg.norm(g(x + dx_cart)) # Metric 5\n        \n        # 5. Internal-space correction\n        G_int = C_int_chain @ C_int_chain.T\n        cond_G_int = np.linalg.cond(G_int) # Metric 2\n        \n        # Solve for Lagrange multipliers mu\n        mu_p = np.linalg.solve(G_int + alpha * np.identity(2), rhs)\n        \n        # Compute correction dq and map to dx_int\n        dq = C_int_chain.T @ mu_p\n        dx_int = J @ dq\n        \n        # Compute amplification factor\n        amp_factor_int = np.linalg.norm(dx_int) / g_norm # Metric 4\n        \n        # Compute post-correction residual\n        residual_norm_int = np.linalg.norm(g(x + dx_int)) # Metric 6\n        \n        return [\n            cond_G_cart,\n            cond_G_int,\n            amp_factor_cart,\n            amp_factor_int,\n            residual_norm_cart,\n            residual_norm_int,\n            fro_diff\n        ]\n\n    # Test suite from the problem description\n    test_cases = [\n        # (r12, r23, theta, eps1, eps2)\n        (1.5, 1.2, 1.0, 0.02, -0.015),          # Case A (happy path)\n        (1.0, 1.0, 0.001, 0.05, 0.05),         # Case B (near-collinear)\n        (1.0, 1.0, np.pi - 0.001, -0.02, 0.03), # Case C (near pi)\n        (2.0, 0.5, 1.5, 0.01, -0.01)           # Case D (bond-length disparity)\n    ]\n\n    results = []\n    for case in test_cases:\n        result_vector = perform_analysis(*case)\n        results.append(result_vector)\n\n    # Format the final output string\n    output_str_parts = []\n    for res_vec in results:\n        # Format each float to a consistent representation\n        formatted_vec = [f\"{v:.7e}\" for v in res_vec]\n        output_str_parts.append(f\"[{','.join(formatted_vec)}]\")\n    \n    print(f\"[{','.join(output_str_parts)}]\")\n\n# Execute the main function\nsolve()\n```", "id": "3416352"}, {"introduction": "当使用大量约束构建复杂的分子模型时，很容易引入冗余约束，导致系统“过约束”。在完整约束系统中，约束图中的几何环路往往会在约束方程之间引入线性相关性，使得拉格朗日乘子方程无解或病态。本练习 [@problem_id:3416369] 将指导您结合图论（圈数）和线性代数（矩阵的秩）知识，构建一个能够诊断此类结构性冗余的算法，并学习如何通过约束剪枝或正则化等方法解决这一问题，这对于模拟具有复杂拓扑结构（如聚合物网络或蛋白质）的系统至关重要。", "problem": "考虑一个由 $N$ 个质点组成的分子动力学系统，其位置为 $q = (r_{1,x}, r_{1,y}, r_{1,z}, \\dots, r_{N,x}, r_{N,y}, r_{N,z}) \\in \\mathbb{R}^{3N}$。该系统受到完整约束，这些约束通过拉格朗日乘子施加，用于固定一个无向约束图上各边连接的质点间的相对位移。每个约束都与图的一条无向边 $(i,j)$ 以及一个笛卡尔分量 $\\alpha \\in \\{x,y,z\\}$ 相关联，其形式为 $g_{(i,j),\\alpha}(q) = r_{i,\\alpha} - r_{j,\\alpha} - d_{(i,j),\\alpha} = 0$，其中 $d_{(i,j),\\alpha} \\in \\mathbb{R}$ 是为边 $(i,j)$ 指定的目标位移分量。约束雅可比矩阵 $C(q) = \\partial g / \\partial q$ 的每一行对应一个标量约束，共有 $3N$ 列；对于约束 $g_{(i,j),\\alpha}$，其对应的行在坐标 $(i,\\alpha)$ 处为 $+1$，在坐标 $(j,\\alpha)$ 处为 $-1$，其余位置均为零。设 $m$ 表示标量约束的总数，即 $m = 3|E|$，其中 $|E|$ 是约束图中的边数。\n\n如果约束是独立的，并且与 $C$ 相关的拉格朗日乘子系统是可解的，那么该系统是自洽的。当约束代数相关时，通常是由于约束图中存在环，就会出现过约束情形。矩阵的秩 $\\operatorname{rank} C$ 可以检测出独立约束的数量，如果 $\\operatorname{rank} C < m$，则说明有些约束是冗余的。以质量加权形式表示的控制拉格朗日乘子的矩阵为 $G = C M^{-1} C^{\\top}$，其中 $M$ 是对角质量矩阵，其对角线元素为每个坐标方向上的粒子质量。在过约束情形下，$G$ 会变得奇异或病态。有两种解决方案：(i) Tikhonov 正则化，即向 $G$ 添加 $\\lambda I$，使其最小特征值高于某个数值阈值；以及 (ii) 约束剪枝，即沿环路移除一个最小约束集以恢复独立性。\n\n您的任务是推导、实现并测试一个算法，该算法能够：\n\n1. 为指定的位移约束集构建约束雅可比矩阵 $C$。\n2. 使用带容差的奇异值分解（SVD）来计算 $\\operatorname{rank} C$ 的数值稳健估计。\n3. 检测无向约束图中的环，并计算圈复杂度 $\\mu = |E| - |V| + c$，其中 $|V|$ 是顶点数，$c$ 是连通分量数。\n4. 通过检查是否满足 $\\operatorname{rank} C < m$ 和 $\\mu > 0$ 来判断是否存在由环引起的特定过约束。\n5. 提出一个正则化参数 $\\lambda \\ge 0$，使得 $G + \\lambda I$ 的最小特征值至少为目标阈值 $\\tau$，其中 $\\tau$ 基于 $G$ 的最大特征值和机器精度来选择。使用由粒子质量构成的 $M^{-1}$；质量矩阵 $M$ 是对角矩阵，每个粒子 $i$ 对应一个块 $(m_i, m_i, m_i)$。\n6. 提出一种约束剪枝策略，通过在生成树森林构建过程中丢弃非树边，为每个独立环恰好移除一条无向边（从而每条被移除的边对应移除 $3$ 个标量约束），然后对剪枝后的集合重新计算 $\\operatorname{rank} C$ 以验证独立性。\n\n请从以下基本原理出发：牛顿第二定律 $\\mathbf{F} = m \\mathbf{a}$；通过拉格朗日乘子施加的完整约束 $g(q) = 0$；约束雅可比矩阵的定义 $C = \\partial g / \\partial q$；以及必须对 $\\lambda$ 可解的质量加权拉格朗日乘子系统 $G = C M^{-1} C^{\\top} \\lambda = -C M^{-1} f$。使用奇异值分解确定秩，使用圈复杂度进行环检测。除这些基础知识外，不要假设任何快捷公式。\n\n实现该算法，并在以下测试套件上进行评估。每个测试用例提供 $N$、位置 $r_i$（用于通过 $d_{(i,j)} = r_i - r_j$ 构建自洽的 $d_{(i,j)}$ 值）、一个无向边列表 $E$ 和一个质量数组 $(m_1, \\dots, m_N)$。\n\n- 测试用例 1（理想路径，无环）：\n  - $N = 4$\n  - 位置：$r_0 = (0,0,0)$，$r_1 = (1,0,0)$，$r_2 = (2,0,0)$，$r_3 = (3,0,0)$\n  - 边：$(0,1), (1,2), (2,3)$\n  - 质量：$(1.0, 1.0, 1.0, 1.0)$\n\n- 测试用例 2（单环，方形环）：\n  - $N = 4$\n  - 位置：$r_0 = (0,0,0)$，$r_1 = (1,0,0)$，$r_2 = (1,1,0)$，$r_3 = (0,1,0)$\n  - 边：$(0,1), (1,2), (2,3), (3,0)$\n  - 质量：$(1.0, 2.0, 1.5, 1.0)$\n\n- 测试用例 3（双环，8字形）：\n  - $N = 5$\n  - 位置：$r_0 = (0,0,0)$，$r_1 = (1,0,0)$，$r_2 = (1,1,0)$，$r_3 = (2,1,0)$，$r_4 = (2,2,0)$\n  - 边：$(0,1), (1,2), (2,0), (2,3), (3,4), (4,2)$\n  - 质量：$(1.0, 1.2, 1.0, 0.8, 1.5)$\n\n- 测试用例 4（边界情况，断开的环）：\n  - $N = 4$\n  - 位置：$r_0 = (0,0,0)$，$r_1 = (1,0,0)$，$r_2 = (1,1,0)$，$r_3 = (0,1,0)$\n  - 边：$(0,1), (1,2), (2,3)$\n  - 质量：$(1.0, 3.0, 1.0, 2.0)$\n\n对于每个测试用例，您的程序必须计算以下量：\n\n- $\\operatorname{rank} C$（整数），\n- $m$（标量约束总数，整数），\n- $\\mu$（圈复杂度，整数），\n- 剪枝移除的标量约束数量（整数），\n- 剪枝后的 $\\operatorname{rank} C$（整数），\n- 正则化参数 $\\lambda$（浮点数），\n- 一个布尔值，指示过约束是否由环引起（如果 $\\operatorname{rank} C < m$ 且 $\\mu > 0$ 则为 true，否则为 false）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个列表，顺序如上所述。例如，输出格式必须为 $[\\,[r_1, m_1, \\mu_1, \\Delta m_1, r^{\\text{pruned}}_1, \\lambda_1, b_1], \\dots, [r_4, m_4, \\mu_4, \\Delta m_4, r^{\\text{pruned}}_4, \\lambda_4, b_4]\\,]$。不需要物理单位，也不涉及角度。所有布尔值都应以其编程语言的规范形式打印（例如，true 或 false）。", "solution": "该问题要求分析一个带有完整约束的分子系统，重点是检测和解决由约束图中的环引起的过约束。解决方案涉及一个多步骤算法，该算法整合了线性代数、图论和数值分析的概念，并以经典力学原理为基础。\n\n基本原理是对一个由 $N$ 个粒子组成的、具有广义坐标 $q \\in \\mathbb{R}^{3N}$ 的系统施加完整约束 $g(q) = 0$。这些约束通过拉格朗日乘子被纳入运动方程。求解拉格朗日乘子 $\\lambda$ 的方程组涉及约束雅可比矩阵 $C(q) = \\partial g / \\partial q$ 和质量矩阵 $M$。具体来说，矩阵 $G = C M^{-1} C^{\\top}$ 必须被求逆。如果约束不是线性无关的，该矩阵会变得奇异，从而导致系统过约束。\n\n我们的算法针对每个测试用例，系统地处理问题陈述中指定的任务。\n\n**1. 约束图和雅可比矩阵的构建**\n\n约束定义在一个图上，其中顶点代表粒子，边 $(i,j)$ 代表固定的相对位移。每条边 $(i,j)$ 对应三个标量约束，每个笛卡尔分量 $\\alpha \\in \\{x,y,z\\}$ 一个：\n$$g_{(i,j),\\alpha}(q) = r_{i,\\alpha} - r_{j,\\alpha} - d_{(i,j),\\alpha} = 0$$\n其中 $r_{i,\\alpha}$ 是粒子 $i$ 的 $\\alpha$ 坐标，$d_{(i,j),\\alpha}$ 是一个恒定的目标位移。标量约束的总数为 $m = 3|E|$，其中 $|E|$ 是约束图中的边数。\n\n约束雅可比矩阵 $C$ 是一个 $m \\times 3N$ 的矩阵。$C$ 的每一行对应一个标量约束函数的梯度。对于约束 $g_{(i,j),\\alpha}$，其对应的行向量在坐标 $r_{i,\\alpha}$ 的列索引处为 $+1$，在坐标 $r_{j,\\alpha}$ 的列索引处为 $-1$。所有其他元素均为零。位置 $r_i$ 和目标位移 $d_{(i,j),\\alpha}$ 的具体值不影响雅可比矩阵 $C$。\n\n**2. 通过奇异值分解（SVD）进行秩分析**\n\n线性无关约束的数量由雅可比矩阵的秩 $\\operatorname{rank} C$ 给出。一种计算秩的数值稳健方法是奇异值分解（SVD）。$C$ 的奇异值中大于一个很小容差的数量决定了其秩。如果 $\\operatorname{rank} C < m$，则该约束集是线性相关的，表明存在冗余和过约束系统。\n\n**3. 图的环检测与圈复杂度**\n\n这种类型的约束系统中的冗余与底层约束图中的环直接相关。沿任何粒子闭环的相对位移矢量之和必须为零，例如 $(r_i-r_j) + (r_j-r_k) + (r_k-r_i) = 0$。这个几何恒等式意味着对于每个笛卡尔分量，相应的约束函数之间存在线性相关性。\n\n为了量化环的数量，我们计算约束图 G=($V$, $E$) 的圈复杂度：\n$$\\mu = |E| - |V| + c$$\n其中 $|V|=N$ 是顶点（粒子）数， $|E|$ 是边（位移约束）数，$c$是图中的连通分量数。$\\mu > 0$ 的值表示存在一个或多个独立环。我们通过执行图遍历（如广度优先搜索 BFS）来确定 $c$，以计算内部连通的不同子图的数量。\n\n**4. 环引起的过约束的识别**\n\n如果同时满足两个条件：系统在数学上是过约束的（$\\operatorname{rank} C < m$）并且约束图包含环（$\\mu > 0$），那么就可将过约束明确地识别为由环引起的。\n\n**5. Tikhonov 正则化**\n\n处理奇异矩阵 $G = C M^{-1} C^{\\top}$ 的一种方法是 Tikhonov 正则化。我们寻求一个参数 $\\lambda \\ge 0$ 来构成一个正则化矩阵 $G' = G + \\lambda I$，该矩阵非奇异且条件良好。$G'$ 的特征值是 $\\lambda'_k = \\lambda_k + \\lambda$，其中 $\\lambda_k$ 是 $G$ 的特征值。由于 $G$ 是对称半正定矩阵，其特征值为实数且非负。如果 $G$ 是奇异的，其最小特征值 $\\lambda_{\\textmin}$ 为 $0$。\n\n我们的目标是确保 $G'$ 的最小特征值 $\\lambda_{\\textmin} + \\lambda$ 高于一个数值稳定性阈值 $\\tau$。该阈值的一个合理选择是 $\\tau = \\lambda_{\\textmax} \\cdot \\epsilon_{\\text{machine}}$，其中 $\\lambda_{\\textmax}$ 是 $G$ 的最大特征值，$\\epsilon_{\\text{machine}}$ 是机器精度。所需的正则化参数则为：\n$$\\lambda = \\max(0, \\tau - \\lambda_{\\textmin})$$\n质量矩阵 $M$ 是一个 $3N \\times 3N$ 的对角矩阵，其中与粒子 $i$ 对应的对角线元素都等于其质量 $m_i$。其逆矩阵 $M^{-1}$ 也是对角矩阵，元素为 $1/m_i$。\n\n**6. 约束剪枝**\n\n消除冗余的一个直接方法是移除约束，直到它们线性无关。对于基于环的冗余，这相当于使约束图变为无环图。这可以通过找到图的生成树森林来实现。生成树森林包含了在不产生环的情况下可能的最大边数。原始图中不在生成树森林里的边就是那些构成环的边。\n\n我们使用图遍历（例如 BFS）构建一个生成树森林，在发现未访问顶点时将边添加到森林中。一个有 $N$ 个顶点和 $c$ 个连通分量的图，其生成树森林的边数为 $N-c$。需要移除的边数是 $|E| - (N-c) = \\mu$。对于每条被移除的边，我们移除其关联的三个标量约束。被移除的标量约束总数为 $3\\mu$。然后，我们仅使用生成樹森林中的边构建一个新的、经过剪枝的雅可比矩阵 $C_{\\text{pruned}}$，并验证其秩等于其行数，从而确认所有冗余都已消除。\n\n通过实施这些步骤，我们可以按要求对每个测试用例进行全面表征。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef process_case(N, edges, masses):\n    \"\"\"\n    Processes a single test case according to the problem description.\n    \"\"\"\n    \n    # Task 3 (Part 1): Graph Analysis to find connected components and spanning forest\n    adj = {i: [] for i in range(N)}\n    unique_edges = set()\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        unique_edges.add(tuple(sorted((u, v))))\n    \n    num_edges = len(unique_edges)\n    visited = [False] * N\n    num_components = 0\n    spanning_forest_edges = []\n    \n    for i in range(N):\n        if not visited[i]:\n            num_components += 1\n            q = deque([i])\n            visited[i] = True\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n                        spanning_forest_edges.append(tuple(sorted((u, v))))\n\n    # Task 3 (Part 2): Compute cyclomatic number\n    mu = num_edges - N + num_components\n\n    # Helper function to construct the Jacobian\n    def construct_jacobian(n_particles, edge_list):\n        n_constraints = 3 * len(edge_list)\n        if n_constraints == 0:\n            return np.zeros((0, 3 * n_particles)), 0\n        \n        C = np.zeros((n_constraints, 3 * n_particles))\n        constraint_idx = 0\n        for u, v in edge_list:\n            for alpha in range(3):\n                col_i = 3 * u + alpha\n                col_j = 3 * v + alpha\n                C[constraint_idx, col_i] = 1\n                C[constraint_idx, col_j] = -1\n                constraint_idx += 1\n        return C, n_constraints\n\n    # Task 1: Construct the full constraint Jacobian\n    C, m = construct_jacobian(N, unique_edges)\n\n    # Task 2: Compute rank of the full Jacobian\n    if m > 0:\n        rank_C = np.linalg.matrix_rank(C)\n    else:\n        rank_C = 0\n\n    # Task 4: Detect overconstraint due to cycles\n    is_overconstrained_by_cycles = (rank_C  m) and (mu > 0)\n\n    # Task 6: Propose and evaluate pruning strategy\n    num_removed_scalar_constraints = 3 * mu\n    C_pruned, m_pruned = construct_jacobian(N, spanning_forest_edges)\n    if m_pruned > 0:\n        rank_C_pruned = np.linalg.matrix_rank(C_pruned)\n    else:\n        rank_C_pruned = 0\n\n    # Task 5: Propose regularization parameter lambda\n    if m == 0:\n        lambda_reg = 0.0\n    else:\n        masses_array = np.array(masses, dtype=float)\n        inv_masses_rep = np.repeat(1.0 / masses_array, 3)\n        \n        # G = C M^-1 C^T, computed efficiently\n        # C_scaled_by_mass = C * inv_masses_rep (broadcasting)\n        # G = C_scaled_by_mass @ C.T\n        temp = C * inv_masses_rep\n        G = temp @ C.T\n        \n        eigvals_G = np.linalg.eigvalsh(G)\n        lambda_min = eigvals_G[0]\n        lambda_max = eigvals_G[-1]\n        \n        # Set threshold tau\n        tau = lambda_max * np.finfo(float).eps\n        \n        # Compute lambda\n        lambda_reg = max(0.0, tau - lambda_min)\n\n    return [\n        int(rank_C),\n        int(m),\n        int(mu),\n        int(num_removed_scalar_constraints),\n        int(rank_C_pruned),\n        float(lambda_reg),\n        is_overconstrained_by_cycles\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 4,\n            \"positions\": {0:(0,0,0), 1:(1,0,0), 2:(2,0,0), 3:(3,0,0)},\n            \"edges\": [(0,1), (1,2), (2,3)],\n            \"masses\": [1.0, 1.0, 1.0, 1.0]\n        },\n        {\n            \"N\": 4,\n            \"positions\": {0:(0,0,0), 1:(1,0,0), 2:(1,1,0), 3:(0,1,0)},\n            \"edges\": [(0,1), (1,2), (2,3), (3,0)],\n            \"masses\": [1.0, 2.0, 1.5, 1.0]\n        },\n        {\n            \"N\": 5,\n            \"positions\": {0:(0,0,0), 1:(1,0,0), 2:(1,1,0), 3:(2,1,0), 4:(2,2,0)},\n            \"edges\": [(0,1), (1,2), (2,0), (2,3), (3,4), (4,2)],\n            \"masses\": [1.0, 1.2, 1.0, 0.8, 1.5]\n        },\n        {\n            \"N\": 4,\n            \"positions\": {0:(0,0,0), 1:(1,0,0), 2:(1,1,0), 3:(0,1,0)},\n            \"edges\": [(0,1), (1,2), (2,3)],\n            \"masses\": [1.0, 3.0, 1.0, 2.0]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = process_case(case['N'], case['edges'], case['masses'])\n        all_results.append(result)\n\n    # Format the output as specified\n    formatted_results = []\n    for res in all_results:\n        res[-1] = str(res[-1]).lower()  # Convert boolean to \"true\"/\"false\"\n        str_res = [str(x) for x in res]\n        formatted_results.append(f\"[{','.join(str_res)}]\")\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3416369"}, {"introduction": "每个约束模拟时间步的核心任务是求解拉格朗日乘子。这个任务通常可以归结为一个涉及“舒尔补”矩阵 $S = C M^{-1} C^{\\top}$ 的线性方程组求解问题，该矩阵的性质和问题规模决定了最佳求解策略。在本练习 [@problem_id:3416388] 中，您将实现并比较两种主流求解方法：基于高斯消元的直接求解器和迭代共轭梯度（CG）法。这种亲手实践的比较将揭示算法在鲁棒性、速度和内存使用之间的权衡，这对于开发高效且可扩展的分子动力学软件至关重要。", "problem": "在一个具有完整约束的约束分子动力学系统中，设有 $N$ 个粒子，其位置为 $q \\in \\mathbb{R}^{3N}$，速度为 $v \\in \\mathbb{R}^{3N}$，以及一个对角质量矩阵 $M \\in \\mathbb{R}^{3N \\times 3N}$，其中 $M = \\mathrm{diag}(m_1 I_3, m_2 I_3, \\dots, m_N I_3)$，$m_i  0$ 且 $I_3$ 是 $3 \\times 3$ 的单位矩阵。考虑一组 $m$ 个形式为 $g_k(q) = 0$ 的完整约束，其雅可比行向量为 $C_k \\in \\mathbb{R}^{1 \\times 3N}$，这些行向量组装成约束雅可比矩阵 $C \\in \\mathbb{R}^{m \\times 3N}$。为了使用拉格朗日乘子强制或投影形式为 $C \\Delta v = \\dot{\\eta}$ 的速度级约束，应用了形式为 $\\Delta v = M^{-1} C^\\top \\lambda$ 的速度修正，其中 $\\lambda \\in \\mathbb{R}^{m}$ 是拉格朗日乘子。消去 $\\Delta v$ 会得到舒尔补线性系统\n$$\n(C M^{-1} C^\\top) \\lambda = \\dot{\\eta}.\n$$\n从牛顿第二定律和带拉格朗日乘子的完整约束的定义出发，推导上述速度级的舒尔补系统。然后，实现一个程序，该程序针对给定的测试套件，从成对距离约束构造 $C$，组装 $S = C M^{-1} C^\\top$，并使用直接稠密线性求解器和用于对称正定（SPD）矩阵的迭代共轭梯度法求解 $\\lambda$。对于近奇异情况，使用 Tikhonov 正则化，通过求解 $(S + \\varepsilon I)\\lambda = \\dot{\\eta}$ 来解决，其中给定了 $\\varepsilon \\ge 0$。\n\n在本问题中，所有变量都是无量纲的。不使用角度。不需要物理单位。\n\n成对距离约束的构造：对于位置为 $r_i, r_j \\in \\mathbb{R}^3$ 的粒子 $i$ 和 $j$ 之间的一个约束，定义 $d_{ij} = r_j - r_i \\in \\mathbb{R}^3$。对应的雅可比行 $C_k$ 除了粒子 $i$ 和粒子 $j$ 的 $3$-分块外，其余处处为零，其中粒子 $i$ 的分块为 $-d_{ij}^\\top$，粒子 $j$ 的分块为 $+d_{ij}^\\top$。这一选择对应于距离平方约束的时间导数，并产生与 $d_{ij} \\cdot (v_j - v_i)$ 成比例的速度级约束。\n\n您必须：\n- 从第一性原理推导舒尔补系统 $(C M^{-1} C^\\top) \\lambda = \\dot{\\eta}$。\n- 实现两种求解 $\\lambda$ 的求解器：一种直接稠密求解器和一种迭代共轭梯度求解器，停止准则为 $\\lVert r_k \\rVert_2 \\le \\max(\\tau_{\\mathrm{rel}} \\lVert \\dot{\\eta} \\rVert_2, \\tau_{\\mathrm{abs}})$，其中 $r_k$ 是第 $k$ 次迭代的残差。使用 $\\tau_{\\mathrm{rel}} = 10^{-12}$ 和 $\\tau_{\\mathrm{abs}} = 10^{-14}$，以及最大 $10^4$ 次迭代。\n- 对下面的每个测试用例，从位置和约束对构造 $C$，组装 $S = C M^{-1} C^\\top$，形成 $A = S + \\varepsilon I$，用两种方法求解 $A \\lambda = \\dot{\\eta}$，并报告：\n  - 两种解之间差值的无穷范数，$\\lVert \\lambda_{\\mathrm{direct}} - \\lambda_{\\mathrm{CG}} \\rVert_{\\infty}$。\n  - 2-范数残差 $\\lVert A \\lambda_{\\mathrm{direct}} - \\dot{\\eta} \\rVert_2$ 和 $\\lVert A \\lambda_{\\mathrm{CG}} - \\dot{\\eta} \\rVert_2$。\n\n测试套件（以下描述中的所有索引均为 1-基；根据需要使用 0-基索引实现）：\n- 用例 $1$ (正常情况，单一约束):\n  - $N = 2$, $m = 1$。\n  - 质量: $[12, 16]$。\n  - 位置: $r_1 = (0, 0, 0)$, $r_2 = (1, 0, 0)$。\n  - 约束: $(1, 2)$。\n  - 右端项 $\\dot{\\eta} = [0.1]$。\n  - 正则化 $\\varepsilon = 0$。\n- 用例 $2$ (多个约束，链式):\n  - $N = 3$, $m = 2$。\n  - 质量: $[12, 14, 12]$。\n  - 位置: $r_1 = (0, 0, 0)$, $r_2 = (1, 0, 0)$, $r_3 = (2, 0, 0)$。\n  - 约束: $(1, 2)$ 和 $(2, 3)$。\n  - 右端项 $\\dot{\\eta} = [0, 0.05]$。\n  - 正则化 $\\varepsilon = 0$。\n- 用例 $3$ (近冗余约束，正则化):\n  - $N = 3$, $m = 2$。\n  - 质量: $[12, 12, 12]$。\n  - 位置: $r_1 = (0, 0, 0)$, $r_2 = (1, 0, 0)$, $r_3 = (1, 10^{-6}, 0)$。\n  - 约束: $(1, 2)$ 和 $(1, 3)$。\n  - 右端项 $\\dot{\\eta} = [0.01, 0.01]$。\n  - 正则化 $\\varepsilon = 10^{-12}$。\n- 用例 $4$ (边界情况，零右端项，极端质量):\n  - $N = 2$, $m = 1$。\n  - 质量: $[10^{-6}, 10]$。\n  - 位置: $r_1 = (0, 0, 0)$, $r_2 = (0.5, 0, 0)$。\n  - 约束: $(1, 2)$。\n  - 右端项 $\\dot{\\eta} = [0]$。\n  - 正则化 $\\varepsilon = 0$。\n- 用例 $5$ (极端质量比，约束链):\n  - $N = 4$, $m = 3$。\n  - 质量: $[100, 0.1, 0.1, 100]$。\n  - 位置: $r_1 = (0, 0, 0)$, $r_2 = (1, 0, 0)$, $r_3 = (2, 0, 0)$, $r_4 = (3, 0, 0)$。\n  - 约束: $(1, 2)$, $(2, 3)$, $(3, 4)$。\n  - 右端项 $\\dot{\\eta} = [0.02, -0.01, 0]$。\n  - 正则化 $\\varepsilon = 0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。对于每个用例，按以下顺序输出三个浮点数：$[\\lVert \\lambda_{\\mathrm{direct}} - \\lambda_{\\mathrm{CG}} \\rVert_{\\infty}, \\lVert A \\lambda_{\\mathrm{direct}} - \\dot{\\eta} \\rVert_2, \\lVert A \\lambda_{\\mathrm{CG}} - \\dot{\\eta} \\rVert_2]$。将所有用例的结果按顺序聚合到一个扁平列表中。例如，如果有两个用例，输出可能看起来像 $[d_1, r_{d,1}, r_{i,1}, d_2, r_{d,2}, r_{i,2}]$。\n- 不应打印任何其他文本。", "solution": "我们从牛顿第二定律和通过拉格朗日乘子强制施加的完整约束开始。设 $q \\in \\mathbb{R}^{3N}$ 为位置，$v = \\dot{q} \\in \\mathbb{R}^{3N}$ 为速度。无约束运动方程为 $M \\dot{v} = f(q, v, t)$，其中 $M \\in \\mathbb{R}^{3N \\times 3N}$ 对于点质量而言是对称正定且对角的。对于完整约束 $g_k(q) = 0$，$k \\in \\{1, \\dots, m\\}$，其约束雅可比矩阵 $C(q) \\in \\mathbb{R}^{m \\times 3N}$ 的行向量为 $C_k = \\partial g_k / \\partial q$。引入拉格朗日乘子 $\\lambda \\in \\mathbb{R}^m$，约束方程为\n$$\nM \\dot{v} = f + C^\\top \\lambda,\n$$\n以及速度级的运动学约束\n$$\nC v = 0,\n$$\n用于随时间精确地强制执行完整约束。\n\n为了投影速度或施加一个修正冲量以实现满足\n$$\nC \\Delta v = \\dot{\\eta},\n$$\n的期望变化 $\\Delta v$，我们考虑一个在瞬时修正期间忽略其他力的冲量修正。与乘子 $\\lambda$ 相关联的冲量引起速度变化\n$$\n\\Delta v = M^{-1} C^\\top \\lambda.\n$$\n将其代入速度级约束可得\n$$\nC \\Delta v = C M^{-1} C^\\top \\lambda = \\dot{\\eta},\n$$\n这即是舒尔补系统\n$$\n(C M^{-1} C^\\top) \\lambda = \\dot{\\eta}.\n$$\n对于独立的约束，$S := C M^{-1} C^\\top$ 是对称正定（SPD）的，因此是可逆的，并且系统有唯一解。当约束接近冗余时，$S$ 可能是病态的；Tikhonov 正则化用 $A := S + \\varepsilon I$（其中 $\\varepsilon \\ge 0$）替换 $S$ 来稳定求解过程。\n\n成对距离的约束构造：考虑形式为 $g_{ij}(q) = \\|r_j - r_i\\|^2 - \\ell_{ij}^2 = 0$ 的完整约束。其雅可比行向量为\n$$\nC_{ij} = \\left[ \\dots, \\frac{\\partial g_{ij}}{\\partial r_i}, \\dots, \\frac{\\partial g_{ij}}{\\partial r_j}, \\dots \\right] = \\left[ \\dots, -2 (r_j - r_i)^\\top, \\dots, 2 (r_j - r_i)^\\top, \\dots \\right].\n$$\n在速度级，$\\dot{g}_{ij} = C_{ij} v = 2 (r_j - r_i) \\cdot (v_j - v_i)$。标量因子 $2$ 可以在不失一般性的情况下被吸收到乘子中；因此我们等价地使用一个与方向向量成比例的雅可比行向量，\n$$\n\\tilde{C}_{ij} = \\left[ \\dots, -(r_j - r_i)^\\top, \\dots, (r_j - r_i)^\\top, \\dots \\right],\n$$\n这会生成相同的零空间，并导致一个按常数缩放的等价舒尔系统。使用这种线性化形式，我们通过堆叠所有约束的此类行来组装 $C$。\n\n每个测试用例的算法步骤：\n- 构建 $M^{-1}$ 作为一个对角矩阵，其中每个质量 $m_i$ 为其三个空间分量重复，因此 $M^{-1} = \\mathrm{diag}(m_1^{-1} I_3, \\dots, m_N^{-1} I_3)$。\n- 使用上述规则，以 $d_{ij} = r_j - r_i$ 组装 $C \\in \\mathbb{R}^{m \\times 3N}$。\n- 通过用适当的逆质量缩放 $C$ 的列，然后将 $S$ 形成一个稠密乘积，来高效地计算 $S = C M^{-1} C^\\top$。\n- 形成 $A = S + \\varepsilon I$。\n- 求解 $A \\lambda = \\dot{\\eta}$，方法如下：\n  - 使用高斯消元法进行直接稠密求解（例如，一个通用的稠密线性求解器）。\n  - 共轭梯度法（CG），该方法适用，因为对于 $\\varepsilon \\ge 0$ 和独立约束，$A$ 是对称正定的。使用停止条件 $\\lVert r_k \\rVert_2 \\le \\max(\\tau_{\\mathrm{rel}} \\lVert \\dot{\\eta} \\rVert_2, \\tau_{\\mathrm{abs}})$，其中 $\\tau_{\\mathrm{rel}} = 10^{-12}$，$\\tau_{\\mathrm{abs}} = 10^{-14}$，最大迭代次数为 $10^4$。\n- 报告诊断信息：\n  - 解之间差值的无穷范数，$\\lVert \\lambda_{\\mathrm{direct}} - \\lambda_{\\mathrm{CG}} \\rVert_{\\infty}$。\n  - 残差范数 $\\lVert A \\lambda_{\\mathrm{direct}} - \\dot{\\eta} \\rVert_2$ 和 $\\lVert A \\lambda_{\\mathrm{CG}} - \\dot{\\eta} \\rVert_2$。\n\n为何适用共轭梯度法：对于独立约束，$S = C M^{-1} C^\\top$ 是对称正定的，因为对于任何非零的 $x \\in \\mathbb{R}^m$，\n$$\nx^\\top S x = x^\\top C M^{-1} C^\\top x = (C^\\top x)^\\top M^{-1} (C^\\top x)  0,\n$$\n由于 $M^{-1}$ 是对称正定的，并且对于独立约束 $C^\\top x \\ne 0$。对于 $\\varepsilon \\ge 0$，加上 $\\varepsilon I$ 会保持对称性和正定性，即使当 $C$ 是秩亏的时候，如果 $\\varepsilon  0$，也能保持严格正定性。因此 CG 收敛。\n\n测试套件覆盖范围的基本原理：\n- 用例 $1$ 验证了基本的单一约束场景。\n- 用例 $2$ 测试了通过链式结构连接的多个约束和耦合。\n- 用例 $3$ 探究了近冗余性以及使用 $\\varepsilon = 10^{-12}$ 进行正则化的必要性。\n- 用例 $4$ 强制使用零右端项和极端质量缩放，其中精确解为 $\\lambda = 0$，残差应达到机器精度。\n- 用例 $5$ 通过极端的质量比和多个耦合约束来测试系统的条件数。\n\n预期结果：在所有良态情况下，直接解和 CG 解应在数值精度范围内一致，因此 $\\lVert \\lambda_{\\mathrm{direct}} - \\lambda_{\\mathrm{CG}} \\rVert_{\\infty}$ 应接近机器精度，并且两个残差范数都应很小（在停止容差的量级或更小）。经过正则化的用例 3 由于其对称正定的正则化系统，同样应该产生微小的差异。\n\n最终的程序实现了这些步骤，并按要求为每个用例打印一个包含三个诊断指标的扁平列表。", "answer": "```python\nimport numpy as np\n\ndef build_C(positions, constraints):\n    \"\"\"\n    Build the constraint Jacobian C for pairwise distance constraints.\n    positions: array of shape (N,3)\n    constraints: list of (i,j) with 0-based indices\n    Returns C of shape (m, 3N)\n    \"\"\"\n    N = positions.shape[0]\n    m = len(constraints)\n    C = np.zeros((m, 3 * N), dtype=float)\n    for k, (i, j) in enumerate(constraints):\n        d = positions[j] - positions[i]  # vector r_j - r_i\n        # Place -d^T in block for i, +d^T in block for j\n        C[k, 3 * i:3 * i + 3] = -d\n        C[k, 3 * j:3 * j + 3] = +d\n    return C\n\ndef assemble_S(C, masses):\n    \"\"\"\n    Assemble S = C M^{-1} C^T given C and masses.\n    masses: array of length N\n    \"\"\"\n    N = len(masses)\n    inv_masses = 1.0 / np.asarray(masses, dtype=float)\n    # Scale columns of C by inverse masses for each 3-block\n    C_scaled = C.copy()\n    for i in range(N):\n        C_scaled[:, 3 * i:3 * i + 3] *= inv_masses[i]\n    S = C_scaled @ C.T\n    return S\n\ndef conjugate_gradient(A, b, tol_rel=1e-12, tol_abs=1e-14, maxiter=10_000):\n    \"\"\"\n    Conjugate Gradient for SPD dense matrix A and vector b.\n    Stops when ||r||_2 = max(tol_rel * ||b||_2, tol_abs)\n    Returns x, iters, final_res_norm\n    \"\"\"\n    n = A.shape[0]\n    x = np.zeros(n, dtype=float)\n    r = b - A @ x\n    p = r.copy()\n    rsold = float(r @ r)\n    bnorm = np.linalg.norm(b)\n    tol = max(tol_rel * bnorm, tol_abs)\n    if np.sqrt(rsold) = tol:\n        return x, 0, np.sqrt(rsold)\n    for k in range(1, maxiter + 1):\n        Ap = A @ p\n        pAp = float(p @ Ap)\n        if pAp = 0.0:\n            # Breakdown; return current iterate\n            resn = np.sqrt(rsold)\n            return x, k - 1, resn\n        alpha = rsold / pAp\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rsnew = float(r @ r)\n        if np.sqrt(rsnew) = tol:\n            return x, k, np.sqrt(rsnew)\n        beta = rsnew / rsold\n        p = r + beta * p\n        rsold = rsnew\n    return x, maxiter, np.sqrt(rsold)\n\ndef solve_case(masses, positions, constraint_pairs, dot_eta, epsilon):\n    \"\"\"\n    Solve one test case:\n    - Build C from positions and constraints\n    - Assemble S = C M^{-1} C^T\n    - Form A = S + epsilon * I\n    - Solve A lambda = dot_eta by direct solve and CG\n    - Return diagnostics: inf-norm difference, residual norms for direct and CG\n    \"\"\"\n    masses = np.array(masses, dtype=float)\n    positions = np.array(positions, dtype=float)\n    C = build_C(positions, constraint_pairs)\n    S = assemble_S(C, masses)\n    m = S.shape[0]\n    if epsilon != 0.0:\n        A = S + epsilon * np.eye(m)\n    else:\n        A = S.copy()\n    b = np.array(dot_eta, dtype=float)\n\n    # Direct solve\n    try:\n        lam_direct = np.linalg.solve(A, b)\n    except np.linalg.LinAlgError:\n        # Fallback to least squares if singular (should not happen with epsilon > 0)\n        lam_direct, *_ = np.linalg.lstsq(A, b, rcond=None)\n\n    # CG solve\n    lam_cg, iters, res_cg = conjugate_gradient(A, b, tol_rel=1e-12, tol_abs=1e-14, maxiter=10000)\n\n    # Diagnostics\n    diff_inf = float(np.max(np.abs(lam_direct - lam_cg))) if lam_direct.size > 0 else 0.0\n    resid_direct = float(np.linalg.norm(A @ lam_direct - b))\n    resid_cg = float(np.linalg.norm(A @ lam_cg - b))\n\n    return diff_inf, resid_direct, resid_cg\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"masses\": [12.0, 16.0],\n            \"positions\": [\n                [0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n            ],\n            \"constraints\": [(0, 1)],\n            \"dot_eta\": [0.1],\n            \"epsilon\": 0.0,\n        },\n        # Case 2\n        {\n            \"masses\": [12.0, 14.0, 12.0],\n            \"positions\": [\n                [0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [2.0, 0.0, 0.0],\n            ],\n            \"constraints\": [(0, 1), (1, 2)],\n            \"dot_eta\": [0.0, 0.05],\n            \"epsilon\": 0.0,\n        },\n        # Case 3\n        {\n            \"masses\": [12.0, 12.0, 12.0],\n            \"positions\": [\n                [0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [1.0, 1e-6, 0.0],\n            ],\n            \"constraints\": [(0, 1), (0, 2)],\n            \"dot_eta\": [0.01, 0.01],\n            \"epsilon\": 1e-12,\n        },\n        # Case 4\n        {\n            \"masses\": [1e-6, 10.0],\n            \"positions\": [\n                [0.0, 0.0, 0.0],\n                [0.5, 0.0, 0.0],\n            ],\n            \"constraints\": [(0, 1)],\n            \"dot_eta\": [0.0],\n            \"epsilon\": 0.0,\n        },\n        # Case 5\n        {\n            \"masses\": [100.0, 0.1, 0.1, 100.0],\n            \"positions\": [\n                [0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [2.0, 0.0, 0.0],\n                [3.0, 0.0, 0.0],\n            ],\n            \"constraints\": [(0, 1), (1, 2), (2, 3)],\n            \"dot_eta\": [0.02, -0.01, 0.0],\n            \"epsilon\": 0.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        diff_inf, resid_direct, resid_cg = solve_case(\n            case[\"masses\"],\n            case[\"positions\"],\n            case[\"constraints\"],\n            case[\"dot_eta\"],\n            case[\"epsilon\"],\n        )\n        results.extend([diff_inf, resid_direct, resid_cg])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3416388"}]}