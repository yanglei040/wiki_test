{"hands_on_practices": [{"introduction": "能量均分定理是经典统计力学的基石，但我们如何使用分子动力学模拟的数据来验证其有效性呢？本练习将指导您完成一个严谨的统计检验过程 [@problem_id:3411252]。您将探索单个正交模（作为二次自由度）的动能如何在理论平均值 $\\frac{1}{2} k_B T$ 附近波动，并通过从模拟数据构建置信区间，学习一项计算科学家的关键技能：如何用有限的、有涨落的数值结果来检验理论预测，并量化结论的统计确定性。", "problem": "您的任务是构建一个完整、可运行的程序，在经典的分子动力学（MD）设置中，通过分析从模拟的平衡速度数据和质量加权简正模投影计算出的模式分解动能，来数值验证能量均分定理。验证应以统计上严谨的方式进行，通过将模式平均能量与热力学基准进行比较，并使用宽度明确取决于采样长度的置信区间来量化偏差。\n\n起点和定义：考虑一个三维空间中由 $N$ 个点粒子组成的系统，粒子质量为 $m_j$，其中 $j \\in \\{1,\\dots,N\\}$。笛卡尔坐标系中的瞬时速度矢量为 $v \\in \\mathbb{R}^{3N}$，质量加权速度定义为 $u = \\mathrm{diag}(\\sqrt{m_1}, \\sqrt{m_1}, \\sqrt{m_1}, \\dots, \\sqrt{m_N}, \\sqrt{m_N}, \\sqrt{m_N}) \\, v \\in \\mathbb{R}^{3N}$。设 $E \\in \\mathbb{R}^{3N \\times M}$ 的列在质量加权空间中关于欧几里得内积是标准正交的，代表 $M$ 个简正模矢量。模态速度坐标为 $a = E^\\top u \\in \\mathbb{R}^M$。模式 $i$ 中的瞬时动能定义为 $K_i = \\frac{1}{2} a_i^2$，单位为焦耳（$\\textrm{J}$）。在绝对温度 $T$ 下，每个二次自由度的热力学基准是 $k_{\\mathrm{B}} T / 2$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。温度以开尔文（$\\textrm{K}$）为单位，质量以原子质量单位（$\\textrm{amu}$）提供，并且必须使用 $1\\,\\textrm{amu} = 1.66053906660 \\times 10^{-27}\\,\\textrm{kg}$ 转换为千克（$\\textrm{kg}$）。能量必须以焦耳（$\\textrm{J}$）计算。角度未出现，因此不需要角度单位。最终报告的结果必须是区间 $[0,1]$ 内的无单位小数。\n\n程序要求：\n- 对于每个测试案例，在指定的温度 $T_{\\mathrm{true}}$ 下，从平衡（正则）分布中采样，生成合成的 MD 速度数据。此采样在时间样本之间必须是独立的，并具有指定的采样长度 $n$。每个测试案例使用固定的随机种子以确保可复现性。\n- 通过生成一个随机矩阵并执行标准正交化过程，在 $\\mathbb{R}^{3N}$ 中构建一个由 $M$ 个质量加权简正模组成的随机标准正交集 $E$，然后选择其前 $M$ 列。\n- 对于每个模式 $i \\in \\{1,\\dots,M\\}$，计算 $n$ 个样本上瞬时模态动能 $K_i$ 的样本均值。仅使用采样长度 $n$ 和正则系综中二次自由度的分布结构，为真实平均模态动能构建一个双侧 $95\\%$ 置信区间。然后，判断热力学基准 $k_{\\mathrm{B}} T_{\\mathrm{rep}} / 2$（其中 $T_{\\mathrm{rep}}$ 是用于验证的报告温度）是否位于此置信区间内。\n- 对于每个测试案例，返回基准 $k_{\\mathrm{B}} T_{\\mathrm{rep}} / 2$ 位于计算出的置信区间内的模式所占的比例（一个小数）。此比例必须在 $[0,1]$ 区间内。\n\n测试套件：\n使用以下四个测试案例，每个案例都有一个指定的随机种子 $s$：\n- 案例 1（正常路径）：$N=5$， $M=10$，每个粒子的质量为 $12\\,\\textrm{amu}$，$T_{\\mathrm{true}}=300\\,\\textrm{K}$，$T_{\\mathrm{rep}}=300\\,\\textrm{K}$，采样长度 $n=20000$，种子 $s=271828$。\n- 案例 2（异质质量，小样本）：$N=3$，$M=9$，每个粒子的质量为 $[1, 12, 197]\\,\\textrm{amu}$，$T_{\\mathrm{true}}=300\\,\\textrm{K}$，$T_{\\mathrm{rep}}=300\\,\\textrm{K}$，采样长度 $n=200$，种子 $s=314159$。\n- 案例 3（验证温度不匹配）：$N=4$，$M=12$，每个粒子的质量为 $[39.948, 1.008, 15.999, 12.011]\\,\\textrm{amu}$，$T_{\\mathrm{true}}=600\\,\\textrm{K}$，$T_{\\mathrm{rep}}=300\\,\\textrm{K}$，采样长度 $n=5000$，种子 $s=141421$。\n- 案例 4（边界情况：单模式）：$N=1$，$M=1$，质量 $[16]\\,\\textrm{amu}$，$T_{\\mathrm{true}}=300\\,\\textrm{K}$，$T_{\\mathrm{rep}}=300\\,\\textrm{K}$，采样长度 $n=50$，种子 $s=161803$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，即 $[f_1,f_2,f_3,f_4]$，其中 $f_k$ 是测试案例 $k$ 的结果分数（一个小数），对应于其平均动能的 $95\\%$ 置信区间包含 $k_{\\mathrm{B}} T_{\\mathrm{rep}} / 2$ 的模式所占的比例。", "solution": "该问题要求在经典分子动力学背景下，对能量均分定理进行数值验证。此验证将通过以下步骤执行：生成合成速度数据，将其投影到一组简正模上，然后使用统计置信区间将每个模式的平均动能与理论基准进行核对。\n\n### 理论基础\n\n该系统由 $N$ 个粒子组成，其质量为 $m_j$，其中 $j \\in \\{1,\\dots,N\\}$。系统的状态由笛卡尔速度矢量 $v \\in \\mathbb{R}^{3N}$ 描述。总动能 $K$ 由下式给出：\n$$ K = \\sum_{j=1}^{N} \\frac{1}{2} m_j (v_{j,x}^2 + v_{j,y}^2 + v_{j,z}^2) $$\n为了简化动能的表达式，通常的做法是引入质量加权速度坐标。设 $W$ 为 $3N \\times 3N$ 的质量对角矩阵，其元素为 $(m_1, m_1, m_1, \\dots, m_N, m_N, m_N)$。质量加权速度矢量 $u \\in \\mathbb{R}^{3N}$ 定义为 $u = W^{1/2}v$。用 $u$ 表示，总动能变为一个简单的平方和：\n$$ K = \\frac{1}{2} v^\\top W v = \\frac{1}{2} (W^{-1/2}u)^\\top W (W^{-1/2}u) = \\frac{1}{2} u^\\top W^{-1/2} W W^{-1/2} u = \\frac{1}{2} u^\\top u = \\frac{1}{2} \\sum_{k=1}^{3N} u_k^2 $$\n在温度为 $T_{\\mathrm{true}}$ 的热平衡正则系综中，每个笛卡尔速度分量 $v_k$（对应质量为 $m'_k$ 的粒子）都是一个独立的随机变量，服从均值为 $0$、方差为 $k_{\\mathrm{B}} T_{\\mathrm{true}} / m'_k$ 的高斯分布。因此，每个质量加权速度分量 $u_k = \\sqrt{m'_k} v_k$ 是一个独立同分布（i.i.d.）的随机变量，服从均值为 $E[u_k] = 0$、方差为 $\\mathrm{Var}(u_k) = (\\sqrt{m'_k})^2 \\mathrm{Var}(v_k) = m'_k (k_{\\mathrm{B}} T_{\\mathrm{true}} / m'_k) = k_{\\mathrm{B}} T_{\\mathrm{true}}$ 的高斯分布。因此，整个向量 $u$ 服从多元正态分布：$u \\sim N(0, k_{\\mathrm{B}} T_{\\mathrm{true}} I_{3N})$，其中 $I_{3N}$ 是 $3N \\times 3N$ 的单位矩阵。\n\n问题将一组 $M$ 个简正模定义为矩阵 $E \\in \\mathbb{R}^{3N \\times M}$ 的列，这些列是标准正交的，满足 $E^\\top E = I_M$。模态速度坐标是通过将 $u$ 投影到这些模式上获得的：$a = E^\\top u$。由于这是高斯随机向量的线性变换，$a$ 也是一个高斯随机向量。其均值为 $E[a] = E^\\top E[u] = 0$。其协方差矩阵为：\n$$ \\mathrm{Cov}(a) = E[aa^\\top] = E[E^\\top u u^\\top E] = E^\\top E[uu^\\top] E = E^\\top (k_{\\mathrm{B}} T_{\\mathrm{true}} I_{3N}) E = k_{\\mathrm{B}} T_{\\mathrm{true}} (E^\\top E) = k_{\\mathrm{B}} T_{\\mathrm{true}} I_M $$\n这个关键结果表明，模态坐标 $a_i$（其中 $i \\in \\{1,\\dots,M\\}$）是独立同分布的随机变量，每个都服从分布 $a_i \\sim N(0, k_{\\mathrm{B}} T_{\\mathrm{true}})$。\n\n模式 $i$ 的瞬时动能为 $K_i = \\frac{1}{2} a_i^2$。如果我们定义一个标准正态变量 $Z_i = a_i / \\sqrt{k_{\\mathrm{B}} T_{\\mathrm{true}}}$，那么 $Z_i \\sim N(0,1)$。模态能量可以写成：\n$$ K_i = \\frac{1}{2} (Z_i \\sqrt{k_{\\mathrm{B}} T_{\\mathrm{true}}})^2 = \\frac{1}{2} k_{\\mathrm{B}} T_{\\mathrm{true}} Z_i^2 $$\n标准正态变量的平方 $Z_i^2$ 服从自由度为 1 的卡方分布，记作 $\\chi^2(1)$。因此，模式 $i$ 的真实平均动能 $\\langle K_i \\rangle$ 为：\n$$ \\langle K_i \\rangle = E[K_i] = \\frac{1}{2} k_{\\mathrm{B}} T_{\\mathrm{true}} E[Z_i^2] = \\frac{1}{2} k_{\\mathrm{B}} T_{\\mathrm{true}} \\cdot 1 = \\frac{1}{2} k_{\\mathrm{B}} T_{\\mathrm{true}} $$\n这证实了能量均分定理：每个二次模态自由度的平均能量为 $\\frac{1}{2} k_{\\mathrm{B}} T_{\\mathrm{true}}$。\n\n### 统计验证方法\n\n任务是使用大小为 $n$ 的有限样本对该结果进行数值验证。对于每个模式 $i$，我们从 $n$ 个独立样本中计算样本平均动能 $\\bar{K}_i = \\frac{1}{n} \\sum_{j=1}^{n} K_{i,j}$。然后我们必须为真实均值 $\\langle K_i \\rangle$ 构建一个 $95\\%$ 的置信区间，并验证基准能量 $E_{\\mathrm{bench}} = \\frac{1}{2} k_{\\mathrm{B}} T_{\\mathrm{rep}}$ 是否落在此区间内。\n\n问题指定置信区间的构建必须使用已知的分布结构。$K_i$ 的 $n$ 个独立同分布样本之和与 $\\chi^2(n)$ 分布有关。考虑量 $Y$：\n$$ Y = \\sum_{j=1}^{n} \\frac{2 K_{i,j}}{\\langle K_i \\rangle \\cdot 2} = \\sum_{j=1}^{n} \\frac{K_{i,j}}{\\frac{1}{2} k_{\\mathrm{B}} T_{\\mathrm{true}}} = \\sum_{j=1}^{n} Z_{i,j}^2 $$\n由于每个 $Z_{i,j}^2$ 是一个独立同分布的 $\\chi^2(1)$ 变量，它们的和 $Y$ 服从自由度为 $n$ 的卡方分布，即 $Y \\sim \\chi^2(n)$。我们可以用样本均值 $\\bar{K}_i$ 来表示 $Y$：\n$$ Y = \\frac{n \\bar{K}_i}{\\langle K_i \\rangle} $$\n对于 $95\\%$ 的置信水平（$\\alpha = 0.05$），我们从 $\\chi^2(n)$ 分布中找到下临界值 $q_1 = \\chi^2_{\\alpha/2}(n)$ 和上临界值 $q_2 = \\chi^2_{1-\\alpha/2}(n)$，使得 $P(q_1  Y  q_2) = 1-\\alpha = 0.95$。代入 $Y$ 的表达式并整理不等式以求解 $\\langle K_i \\rangle$：\n$$ q_1  \\frac{n \\bar{K}_i}{\\langle K_i \\rangle}  q_2 \\implies \\frac{n \\bar{K}_i}{q_2}  \\langle K_i \\rangle  \\frac{n \\bar{K}_i}{q_1} $$\n这就给出了真实平均模态动能的精确 $95\\%$ 置信区间：\n$$ \\mathrm{CI}_{95\\%} = \\left[ \\frac{n \\bar{K}_i}{\\chi^2_{0.975}(n)}, \\frac{n \\bar{K}_i}{\\chi^2_{0.025}(n)} \\right] $$\n然后我们检查 $E_{\\mathrm{bench}} = \\frac{1}{2}k_{\\mathrm{B}} T_{\\mathrm{rep}}$ 是否落在此计算出的区间内。\n\n### 算法实现\n\n该解决方案以 Python 程序实现，采用向量化方法以提高效率。对于每个测试案例：\n1.  **初始化**：定义常数 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\textrm{J/K}$ 和 amu 到 kg 的转换因子 $1.66053906660 \\times 10^{-27}\\,\\textrm{kg/amu}$。设置特定案例的参数（$N$、$M$、质量、温度 $T_{\\mathrm{true}}$ 和 $T_{\\mathrm{rep}}$、样本大小 $n$ 和随机种子 $s$）。使用随机种子确保可复现性。\n2.  **系统表示**：将粒子质量转换为千克，并组织成一个对应于每个笛卡尔自由度的 $3N$ 维向量。生成一个随机的 $3N \\times M$ 矩阵，并使用 QR 分解（`numpy.linalg.qr`）获得具有标准正交列的 $3N \\times M$ 矩阵 $E$，代表简正模。\n3.  **合成数据生成**：根据推导出的统计数据，对一批 $n$ 个速度向量 $v$ 进行采样。这是通过首先生成一个来自 $N(0,1)$ 的 $n \\times 3N$ 随机数矩阵，然后将其每列 $j$ 按其对应速度分量的标准差 $\\sigma_{v_j} = \\sqrt{k_{\\mathrm{B}} T_{\\mathrm{true}} / m'_j}$ 进行缩放来完成的。然后对这些速度向量进行质量加权（$U = V \\cdot W^{1/2}$），并投影到模式上（$A = U E$），生成一个 $n \\times M$ 的矩阵 `a_samples`，其中包含所有模态坐标的时间序列。\n4.  **能量计算与统计检验**：瞬时模态动能计算为 $K_{i,j} = \\frac{1}{2} a_{i,j}^2$。为每个模式计算样本均值 $\\bar{K}_i$。使用 $T_{\\mathrm{rep}}$ 计算基准能量 $E_{\\mathrm{bench}}$。使用 `scipy.stats.chi2.ppf` 获得分位数 $\\chi^2_{0.025}(n)$ 和 $\\chi^2_{0.975}(n)$。使用 NumPy 的向量操作同时计算所有 $M$ 个模式的置信区间下界和上界。\n5.  **结果汇总**：一个布尔数组指示基准能量 $E_{\\mathrm{bench}}$ 落在哪些模式的置信区间内。该数组的总和给出了“成功”模式的总数。将此计数除以 $M$ 即可获得该测试案例的最终比例。\n对所有测试案例重复此过程，并报告所得的比例。当 $T_{\\mathrm{true}} = T_{\\mathrm{rep}}$ 时，该比例预计将接近 0.95，这反映了置信区间的定义。当 $T_{\\mathrm{true}} \\neq T_{\\mathrm{rep}}$ 时，样本均值将围绕一个不同于基准的值，对于足够大的样本量 $n$，窄的置信区间很可能不会包含该基准，从而导致比例接近 0。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    # Define physical constants\n    K_B = 1.380649e-23  # Boltzmann constant in J/K\n    AMU_TO_KG = 1.66053906660e-27  # Atomic mass unit to kg conversion\n\n    # Define the test cases as specified in the problem statement.\n    test_cases = [\n        # Case 1 (happy path)\n        {'N': 5, 'M': 10, 'masses_amu': [12.0]*5, 'T_true': 300.0, 'T_rep': 300.0, 'n': 20000, 'seed': 271828},\n        # Case 2 (heterogeneous masses, small sample)\n        {'N': 3, 'M': 9, 'masses_amu': [1.0, 12.0, 197.0], 'T_true': 300.0, 'T_rep': 300.0, 'n': 200, 'seed': 314159},\n        # Case 3 (mismatched verification temperature)\n        {'N': 4, 'M': 12, 'masses_amu': [39.948, 1.008, 15.999, 12.011], 'T_true': 600.0, 'T_rep': 300.0, 'n': 5000, 'seed': 141421},\n        # Case 4 (boundary: single mode)\n        {'N': 1, 'M': 1, 'masses_amu': [16.0], 'T_true': 300.0, 'T_rep': 300.0, 'n': 50, 'seed': 161803},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case, K_B, AMU_TO_KG)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_case(case_params, k_b, amu_to_kg):\n    \"\"\"\n    Processes a single test case for equipartition verification.\n    \n    Args:\n        case_params (dict): A dictionary containing all parameters for the test case.\n        k_b (float): Boltzmann constant.\n        amu_to_kg (float): Conversion factor from AMU to kilograms.\n        \n    Returns:\n        float: The fraction of modes for which the benchmark energy is within the 95% CI.\n    \"\"\"\n    # Unpack parameters\n    N = case_params['N']\n    M = case_params['M']\n    masses_amu = case_params['masses_amu']\n    T_true = case_params['T_true']\n    T_rep = case_params['T_rep']\n    n = case_params['n']\n    seed = case_params['seed']\n\n    # Set random seed for reproducibility\n    np.random.seed(seed)\n\n    # 1. System Setup\n    dim = 3 * N\n    masses_kg = np.array(masses_amu) * amu_to_kg\n    # Create the 3N-dimensional vector of masses for each Cartesian component\n    mass_vec_kg = np.repeat(masses_kg, 3)\n    sqrt_mass_vec_kg = np.sqrt(mass_vec_kg)\n\n    # 2. Construct Orthonormal Modes E\n    # Generate a random matrix and use QR decomposition to get an orthonormal basis\n    A = np.random.randn(dim, M)\n    E, _ = np.linalg.qr(A, mode='reduced')\n\n    # 3. Generate Synthetic Velocity Data and Project to Modes\n    # Standard deviation for each Cartesian velocity component\n    v_scales = np.sqrt(k_b * T_true / mass_vec_kg)\n    \n    # Generate n samples of the 3N-dimensional velocity vector V\n    # This is done in a fully vectorized manner for efficiency.\n    V_samples = np.random.normal(loc=0.0, scale=v_scales, size=(n, dim))\n    \n    # Transform to mass-weighted velocities U\n    U_samples = V_samples * sqrt_mass_vec_kg # Broadcasting applies this element-wise\n    \n    # Project onto normal modes to get modal velocities a\n    a_samples = U_samples @ E  # (n, 3N) @ (3N, M) -> (n, M)\n\n    # 4. Compute Modal Energies and Sample Means\n    # Instantaneous kinetic energy for each mode at each sample\n    K_samples = 0.5 * a_samples**2  # (n, M)\n    \n    # Sample mean kinetic energy for each mode\n    K_bar_vector = np.mean(K_samples, axis=0) # (M,)\n\n    # 5. Construct Confidence Intervals and Test\n    # Calculate the thermal benchmark energy for verification\n    E_bench = 0.5 * k_b * T_rep\n\n    # Get the critical values from the chi-squared distribution for a 95% CI\n    # df = n (degrees of freedom is the sample size)\n    # alpha = 0.05\n    q1 = chi2.ppf(0.025, df=n)\n    q2 = chi2.ppf(0.975, df=n)\n\n    # Calculate the confidence interval bounds for all modes simultaneously\n    CI_lower = (n * K_bar_vector) / q2\n    CI_upper = (n * K_bar_vector) / q1\n\n    # Check for which modes the benchmark falls within the CI\n    is_inside = (CI_lower = E_bench)  (E_bench = CI_upper)\n    count = np.sum(is_inside)\n\n    # 6. Calculate and return the fraction\n    fraction = count / M\n    return fraction\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3411252"}, {"introduction": "经典的能量均分定理在低温或高频振动下会失效，这是催生量子革命的关键观察之一。本练习将对经典力学和量子力学的预测进行直接的、定量的比较 [@problem_id:3411248]。您将对比经典预测（每个谐振模式的平均能量为 $k_B T$）与基于玻色-爱因斯坦分布的量子预测，后者显示当 $\\hbar \\omega \\gg k_B T$ 时能量会被“冻结”。通过实现这两种模型，您将具体理解量子效应在何种条件下变得至关重要，以及经典近似何时不再有效。", "problem": "要求您形式化、推导并实现一个定量比较，该比较针对一组无相互作用的一维谐振子模式，在使用白噪声恒温器（经典能量均分）的经典分子动力学（MD）与强制执行符合涨落-耗散原理的频率相关噪声（量子色噪声）的量子恒温器之间进行。测试目标是通过检验定容热容和模式热能的温度依赖性，来探究经典能量均分在高频下的失效情况。您必须从基本原理出发，不得使用问题陈述中提供的任何快捷公式。\n\n考虑一个由 $N$ 个独立的角频率为 $\\{\\omega_i\\}_{i=1}^N$ 的一维谐振子模式组成的系统，该系统与温度为 $T$ 的热环境耦合。经典恒温器被建模为一个白噪声朗之万浴，在平衡状态下，它能为二次自由度产生经典能量均分的结果。量子恒温器被建模为一个色噪声浴，其噪声谱受线性振子量子涨落-耗散关系的约束；它应当能在平衡状态下重现谐振子模式的正确量子热占据。\n\n任务：\n- 从第一性原理和核心定义出发，推导：\n  - 对于经典恒温器：平衡状态下单个一维谐振子的模式热平均能量 $E_{\\mathrm{cl}}(\\omega,T)$ 和模式定容热容 $C_{V,\\mathrm{cl}}(\\omega,T)$。\n  - 对于量子恒温器：不包括任何零点能贡献的模式热平均能量 $E_{\\mathrm{q}}(\\omega,T)$，以及相应的模式定容热容 $C_{V,\\mathrm{q}}(\\omega,T) = \\partial E_{\\mathrm{q}}/\\partial T$。您的推导应仅使用诸如谐振子的正则配分函数和线性响应的量子形式涨落-耗散原理等基本依据，而不是任何预先给定的目标表达式。\n- 使用推导出的表达式，实现一个程序，为下方的每个测试案例计算：\n  1. 总经典热容 $C_{V,\\mathrm{cl}}^{\\mathrm{tot}}(T) = \\sum_{i=1}^N C_{V,\\mathrm{cl}}(\\omega_i,T)$，单位为 $\\mathrm{J}\\,\\mathrm{K}^{-1}$。\n  2. 总量子热容 $C_{V,\\mathrm{q}}^{\\mathrm{tot}}(T) = \\sum_{i=1}^N C_{V,\\mathrm{q}}(\\omega_i,T)$，单位为 $\\mathrm{J}\\,\\mathrm{K}^{-1}$。\n  3. 平均经典模式热能 $\\overline{E}_{\\mathrm{cl}}(T) = \\frac{1}{N}\\sum_{i=1}^N E_{\\mathrm{cl}}(\\omega_i,T)$，单位为 $\\mathrm{J}$。\n  4. 平均量子模式热能 $\\overline{E}_{\\mathrm{q}}(T) = \\frac{1}{N}\\sum_{i=1}^N E_{\\mathrm{q}}(\\omega_i,T)$，单位为 $\\mathrm{J}$。\n  5. 一个失效指标 $b(T)$，定义为以下谓词的布尔值：存在至少一个模式 $\\omega_i$ 使得 $E_{\\mathrm{q}}(\\omega_i,T) \\le \\alpha\\,k_{\\mathrm{B}} T$ 成立，其中 $\\alpha = 0.5$。此处 $k_{\\mathrm{B}}$ 表示玻尔兹曼常数。\n\n您可以使用的基本依据：\n- 平衡态下二次自由度的经典能量均分定理。\n- 谐振子的正则配分函数。\n- 线性系统的经典及量子形式的涨落-耗散原理。\n- 标准热力学恒等式，例如 $C_V = \\left(\\partial \\langle E \\rangle/\\partial T\\right)_V$。\n- 量子谐振子中不包括零点能的热能定义。\n\n常量：\n- 使用 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$。\n- 使用 $\\hbar = 1.054571817\\times 10^{-34}\\ \\mathrm{J}\\,\\mathrm{s}$。\n\n单位和数值要求：\n- 角频率 $\\omega$ 的单位为 $\\mathrm{s}^{-1}$。\n- 温度 $T$ 的单位为 $\\mathrm{K}$。\n- 能量必须以 $\\mathrm{J}$ 为单位报告，热容必须以 $\\mathrm{J}\\,\\mathrm{K}^{-1}$ 为单位报告。\n- 所有浮点数输出均需四舍五入至 $8$ 位有效数字。\n\n测试套件：\n- 案例 $\\mathrm{A}$：$T = 300\\ \\mathrm{K}$，$\\{\\omega_i\\} = [1.0\\times 10^{12},\\ 1.0\\times 10^{13},\\ 1.0\\times 10^{14}]\\ \\mathrm{s}^{-1}$。\n- 案例 $\\mathrm{B}$：$T = 5\\ \\mathrm{K}$，$\\{\\omega_i\\} = [1.0\\times 10^{12},\\ 1.0\\times 10^{13},\\ 1.0\\times 10^{14}]\\ \\mathrm{s}^{-1}$。\n- 案例 $\\mathrm{C}$：$T = 300\\ \\mathrm{K}$，$\\{\\omega_i\\} = [1.0\\times 10^{10},\\ 2.0\\times 10^{10},\\ 5.0\\times 10^{10}]\\ \\mathrm{s}^{-1}$。\n- 案例 $\\mathrm{D}$：$T = 300\\ \\mathrm{K}$，$\\{\\omega_i\\} = [5.0\\times 10^{14}]\\ \\mathrm{s}^{-1}$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个含四个结果的列表，每个结果对应一个测试案例，并按 $\\mathrm{A}$、$\\mathrm{B}$、$\\mathrm{C}$、$\\mathrm{D}$ 的顺序排列。每个结果本身必须是一个列表，其中完全按照上述顺序包含五个条目：$[C_{V,\\mathrm{cl}}^{\\mathrm{tot}},\\ C_{V,\\mathrm{q}}^{\\mathrm{tot}},\\ \\overline{E}_{\\mathrm{cl}},\\ \\overline{E}_{\\mathrm{q}},\\ b]$。\n- 该行必须是一个用方括号括起来的逗号分隔列表，且不得包含任何空格。例如，总体形状必须匹配 $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$。", "solution": "我们考虑一组角频率为 $\\{\\omega_i\\}_{i=1}^N$ 的独立一维谐振子模式。坐标 $q_i$ 和动量 $p_i$ 由二次哈密顿量 $H_i = \\frac{p_i^2}{2m_i} + \\frac{1}{2} m_i \\omega_i^2 q_i^2$ 控制。我们将推导经典浴和量子浴下的热平均能量和定容热容。我们强调，对于量子情况，我们定义的热能不包括与温度无关的零点能。\n\n经典情况：\n根据经典能量均分定理，在温度 $T$ 下，每个独立的二次项对平均能量的贡献为 $\\frac{1}{2} k_{\\mathrm{B}} T$。对于一维谐振子，存在两个二次项，因此每个模式的平均能量为\n$$\nE_{\\mathrm{cl}}(\\omega,T) = k_{\\mathrm{B}} T.\n$$\n由于此结果与 $\\omega$ 无关，每个模式的定容热容为\n$$\nC_{V,\\mathrm{cl}}(\\omega,T) = \\left(\\frac{\\partial E_{\\mathrm{cl}}}{\\partial T}\\right)_V = k_{\\mathrm{B}}.\n$$\n对 $N$ 个独立模式求和，得到总经典热容 $C_{V,\\mathrm{cl}}^{\\mathrm{tot}}(T) = N k_{\\mathrm{B}}$，平均模式能量仍为 $\\overline{E}_{\\mathrm{cl}}(T) = k_{\\mathrm{B}} T$。\n\n量子情况：\n存在两种互补的基本方法：正则配分函数方法，以及从与遵守量子涨落-耗散定理（FDT）的热浴耦合的线性振子的角度出发。两者都能得出一致的平衡平均值。\n\n配分函数推导：\n量子谐振子的能谱为 $\\epsilon_n = \\hbar \\omega \\left(n + \\frac{1}{2}\\right)$，其中 $n \\in \\{0,1,2,\\ldots\\}$。在逆温度 $\\beta = 1/(k_{\\mathrm{B}} T)$ 下，正则配分函数为\n$$\nZ(\\beta) = \\sum_{n=0}^\\infty e^{-\\beta \\hbar \\omega \\left(n + \\frac{1}{2}\\right)} = \\frac{e^{-\\frac{1}{2}\\beta \\hbar \\omega}}{1 - e^{-\\beta \\hbar \\omega}}.\n$$\n平均能量为 $\\langle E \\rangle = - \\frac{\\partial}{\\partial \\beta} \\ln Z(\\beta)$，得出\n$$\n\\langle E \\rangle = \\frac{1}{2} \\hbar \\omega + \\frac{\\hbar \\omega}{e^{\\beta \\hbar \\omega} - 1}.\n$$\n我们将热能（不包括零点项）定义为\n$$\nE_{\\mathrm{q}}(\\omega,T) = \\langle E \\rangle - \\frac{1}{2} \\hbar \\omega = \\frac{\\hbar \\omega}{e^{\\beta \\hbar \\omega} - 1}.\n$$\n每个模式的定容热容为\n$$\nC_{V,\\mathrm{q}}(\\omega,T) = \\left(\\frac{\\partial E_{\\mathrm{q}}}{\\partial T}\\right)_V = k_{\\mathrm{B}} \\frac{(\\beta \\hbar \\omega)^2 e^{\\beta \\hbar \\omega}}{\\left(e^{\\beta \\hbar \\omega} - 1\\right)^2}.\n$$\n\n涨落-耗散原理：\n对于一个质量为 $m$、角频率为 $\\omega_0$ 的线性振子，其与一个具有记忆核 $\\gamma(\\omega)$ 的热浴耦合，量子FDT约束了力噪声功率谱密度 $S_{FF}(\\omega)$ 相对于响应函数 $\\chi(\\omega)$ 虚部的关系，使得热涨落编码了因子 $\\coth\\!\\left(\\frac{\\hbar \\omega}{2 k_{\\mathrm{B}} T}\\right)$。对于平衡态下的谐振子，在线性响应范围内使用此FDT可得到一个与正则平均相对应的稳态方差，并且在排除零点能贡献后，得出与上述相同的热能 $E_{\\mathrm{q}}(\\omega,T)$。因此，一个正确设计的量子色噪声恒温器能够重现相同的 $E_{\\mathrm{q}}(\\omega,T)$ 和 $C_{V,\\mathrm{q}}(\\omega,T)$。\n\n一致性检验与极限：\n- 经典极限：对于 $x \\equiv \\beta \\hbar \\omega \\ll 1$，我们有 $E_{\\mathrm{q}}(\\omega,T) \\approx \\hbar \\omega \\left(\\frac{1}{x} - \\frac{1}{2} + \\ldots\\right) = k_{\\mathrm{B}} T - \\frac{1}{2}\\hbar \\omega + \\ldots$，并且在排除零点项之后，$E_{\\mathrm{q}}(\\omega,T) \\to k_{\\mathrm{B}} T$。类似地，$C_{V,\\mathrm{q}}(\\omega,T) \\to k_{\\mathrm{B}}$。\n- 量子高频或低温极限：对于 $x \\gg 1$，$E_{\\mathrm{q}}(\\omega,T) \\approx \\hbar \\omega e^{-x}$ 呈指数级减小，而 $C_{V,\\mathrm{q}}(\\omega,T) \\approx k_{\\mathrm{B}} x^2 e^{-x}$ 趋于零，这标志着经典能量均分的严重失效。\n\n算法设计：\n- 输入：对于每个测试案例，获取温度 $T$ 和角频率列表 $\\{\\omega_i\\}$（单位为 $\\mathrm{s}^{-1}$）。\n- 常量：使用 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$ 和 $\\hbar = 1.054571817\\times 10^{-34}\\ \\mathrm{J}\\,\\mathrm{s}$。\n- 经典量：\n  - 每模式：$E_{\\mathrm{cl}}(\\omega_i,T) = k_{\\mathrm{B}} T$，$C_{V,\\mathrm{cl}}(\\omega_i,T) = k_{\\mathrm{B}}$。\n  - 总热容：$C_{V,\\mathrm{cl}}^{\\mathrm{tot}} = N k_{\\mathrm{B}}$。\n  - 平均能量：$\\overline{E}_{\\mathrm{cl}} = k_{\\mathrm{B}} T$。\n- 量子量：\n  - 定义 $x_i = \\frac{\\hbar \\omega_i}{k_{\\mathrm{B}} T}$。\n  - 每模式热能：$E_{\\mathrm{q}}(\\omega_i,T) = \\frac{\\hbar \\omega_i}{\\exp(x_i) - 1}$；对于小的 $x_i$，建议使用 `expm1` 函数进行数值稳定的计算。\n  - 每模式热容：$C_{V,\\mathrm{q}}(\\omega_i,T) = k_{\\mathrm{B}} \\frac{x_i^2 e^{x_i}}{\\left(e^{x_i} - 1\\right)^2}$；为避免对小的 $x_i$ 产生抵消误差，可使用 `expm1` 函数进行计算。\n  - 总热容：$C_{V,\\mathrm{q}}^{\\mathrm{tot}} = \\sum_i C_{V,\\mathrm{q}}(\\omega_i,T)$。\n  - 平均能量：$\\overline{E}_{\\mathrm{q}} = \\frac{1}{N} \\sum_i E_{\\mathrm{q}}(\\omega_i,T)$。\n- 失效指标：\n  - 定义 $b(T)$ 为真，如果 $\\exists i$ 使得 $E_{\\mathrm{q}}(\\omega_i,T) \\le 0.5\\,k_{\\mathrm{B}} T$。\n- 数值输出：\n  - 将所有浮点输出四舍五入到8位有效数字。\n  - 报告每个测试案例的 $[C_{V,\\mathrm{cl}}^{\\mathrm{tot}},\\ C_{V,\\mathrm{q}}^{\\mathrm{tot}},\\ \\overline{E}_{\\mathrm{cl}},\\ \\overline{E}_{\\mathrm{q}},\\ b]$，并将四个案例的结果按 $\\mathrm{A}$、$\\mathrm{B}$、$\\mathrm{C}$、$\\mathrm{D}$ 的顺序聚合到单个无空格、逗号分隔的方括号列表中，如要求所示。\n\n该算法直接测试了能量均分的量子失效：在高频或低温区，量子热能和热容远小于其经典对应值，失效指标变为真。在低频或高温区，经典和量子结果在数值容差范围内一致，失效指标变为假。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants (SI units)\nK_B = 1.380649e-23       # Boltzmann constant, J/K\nHBAR = 1.054571817e-34   # Reduced Planck constant, J*s\n\ndef quantum_thermal_energy(omega, T):\n    \"\"\"\n    Thermal energy (excluding zero-point) for a quantum harmonic oscillator mode.\n    E_q = ħω / (exp(ħω/(k_B T)) - 1)\n    Uses numerically stable computations via expm1.\n    \"\"\"\n    x = (HBAR * omega) / (K_B * T)\n    # Use expm1 for stability at small x; avoid division by zero by handling T>0 guaranteed in test suite.\n    denom = np.expm1(x)\n    # For very large x, expm1(x) ~ exp(x) leading to tiny energies; no special handling needed.\n    # If denom is zero (due to underflow for very small x), x is also very small.\n    # The Taylor expansion is ħω / (x + x^2/2 + ...) = k_B*T / (1 + x/2 + ...) approx k_B*T.\n    # np.expm1(x) is accurate for small x, so this case is handled.\n    with np.errstate(divide='ignore'):\n        E = (HBAR * omega) / denom\n    # Handle the classical limit where x is tiny and denom could be zero.\n    E[denom == 0] = K_B * T\n    return E\n\ndef quantum_heat_capacity(omega, T):\n    \"\"\"\n    Heat capacity for a quantum harmonic oscillator mode (thermal part).\n    C_V = k_B * (x^2 * exp(x)) / (expm1(x)^2), where x = ħω/(k_B T).\n    \"\"\"\n    x = (HBAR * omega) / (K_B * T)\n    ex = np.exp(x)\n    exm1 = np.expm1(x)\n    # Handle small x stably using exm1; for large x this is also stable enough.\n    # Taylor expansion for small x: x^2*ex / exm1^2 -> x^2*(1+x)/(x+x^2/2)^2 -> (1+x)/(1+x/2)^2 -> 1\n    # So C -> k_B for small x.\n    with np.errstate(divide='ignore', invalid='ignore'):\n        C = K_B * (x * x * ex) / (exm1 * exm1)\n    C[np.isnan(C)] = K_B # Replace NaN from 0/0 with the classical limit\n    return C\n\ndef classical_thermal_energy(T):\n    \"\"\"\n    Classical thermal energy per 1D harmonic oscillator mode (kinetic + potential).\n    E_cl = k_B T\n    \"\"\"\n    return K_B * T\n\ndef classical_heat_capacity():\n    \"\"\"\n    Classical heat capacity per 1D harmonic oscillator mode.\n    C_V = k_B\n    \"\"\"\n    return K_B\n\ndef format_no_spaces(obj):\n    \"\"\"\n    Serialize nested Python lists containing floats/booleans into a string\n    with no spaces and floats formatted to 8 significant figures.\n    \"\"\"\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(format_no_spaces(e) for e in obj) + \"]\"\n    elif isinstance(obj, bool):\n        return \"True\" if obj else \"False\"\n    elif isinstance(obj, (float, np.floating, int, np.integer)):\n        if isinstance(obj, (int, np.integer)):\n            return str(int(obj))\n        # format to 8 significant figures, using scientific notation as needed\n        return \"{:.8g}\".format(obj)\n    else:\n        # Fallback to string\n        return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (T in K, list of omegas in s^-1)\n    test_cases = [\n        (300.0, [1.0e12, 1.0e13, 1.0e14]),          # Case A\n        (5.0,   [1.0e12, 1.0e13, 1.0e14]),          # Case B\n        (300.0, [1.0e10, 2.0e10, 5.0e10]),          # Case C\n        (300.0, [5.0e14]),                          # Case D\n    ]\n\n    results = []\n    alpha = 0.5  # breakdown threshold factor\n\n    for T, omega_list in test_cases:\n        omegas = np.array(omega_list, dtype=float)\n        N = len(omegas)\n\n        # Classical per-mode quantities\n        E_cl_mode = classical_thermal_energy(T)\n        C_cl_mode = classical_heat_capacity()\n\n        # Classical totals and averages\n        C_cl_tot = C_cl_mode * N\n        E_cl_avg = E_cl_mode\n\n        # Quantum per-mode quantities\n        E_q_modes = quantum_thermal_energy(omegas, T)\n        C_q_modes = quantum_heat_capacity(omegas, T)\n\n        # Quantum totals and averages\n        C_q_tot = float(np.sum(C_q_modes))\n        E_q_avg = float(np.mean(E_q_modes))\n\n        # Breakdown indicator: exists mode with E_q = alpha * k_B T\n        breakdown = bool(np.any(E_q_modes = alpha * K_B * T))\n\n        results.append([\n            float(C_cl_tot), \n            float(C_q_tot), \n            float(E_cl_avg), \n            float(E_q_avg), \n            breakdown\n        ])\n\n    # Final print statement in the exact required format: no spaces.\n    print(format_no_spaces(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3411248"}, {"introduction": "能量均分定理描述了平衡态 [@problem_id:3411252]，但并未说明系统如何或以多快的速度达到该状态。著名的 Fermi–Pasta–Ulam–Tsingou (FPUT) 问题揭示了通往热平衡的道路可能异常复杂和缓慢。本练习将探索系统势能中的非线性如何作为关键机制，促使能量在不同振动模式之间流动，最终实现热化 [@problem_id:3411203]。通过模拟FPUT链，您将研究遍历性和热化动力学，深入了解为何长时间运行模拟本身并不足以保证系统已完全探索其相空间并达到能量均分。", "problem": "考虑一个由 $N$ 个相同的单位质量组成的、两端固定的 Fermi–Pasta–Ulam–Tsingou (FPUT) 链。设其位置为 $\\{x_i(t)\\}_{i=1}^N$，边界条件为 $x_0(t)=0$ 和 $x_{N+1}(t)=0$。其动力学遵循牛顿第二定律 $m\\,\\ddot{x}_i(t)=F_i(t)$，其中 $m=1$，并由一个包含线性弹簧和三次非线性的最近邻势能所支配。总势能为\n$$\nV(x)=\\sum_{j=0}^{N}\\left(\\frac{1}{2}\\,r_j^2+\\frac{\\alpha}{3}\\,r_j^3\\right),\n$$\n其中 $r_j=x_{j+1}-x_j$，$\\alpha$ 是一个控制非线性强度的标量参数。粒子 $i$ 上受到的力为\n$$\nF_i=\\left(r_i+\\alpha\\,r_i^2\\right)-\\left(r_{i-1}+\\alpha\\,r_{i-1}^2\\right),\\quad i=1,\\dots,N,\n$$\n其中在边界处的 $r_j$ 定义为 $r_0=x_1-x_0=x_1$ 和 $r_N=x_{N+1}-x_N=-x_N$。所有三角函数表达式中使用的角度单位均为弧度。\n\n为了量化底层谐振子链的线性简正模中的能量均分过程，定义标准正交离散正弦基\n$$\nS_{i,k}=\\sqrt{\\frac{2}{N+1}}\\sin\\left(\\frac{\\pi k i}{N+1}\\right),\\quad i=1,\\dots,N,\\quad k=1,\\dots,N,\n$$\n以及线性模频率\n$$\n\\omega_k=2\\sin\\left(\\frac{\\pi k}{2(N+1)}\\right).\n$$\n$t$ 时刻的线性模态坐标和动量为\n$$\nQ_k(t)=\\sum_{i=1}^N x_i(t)\\,S_{i,k},\\qquad P_k(t)=\\sum_{i=1}^N \\dot{x}_i(t)\\,S_{i,k},\n$$\n其线性模态能量为\n$$\nE_k(t)=\\frac{1}{2}\\left(P_k(t)^2+\\omega_k^2\\,Q_k(t)^2\\right).\n$$\n令“高频子集”为索引 $k\\in\\{ \\lfloor \\tfrac{2N}{3}\\rfloor+1,\\dots,N\\}$ 的模态集合，并定义瞬时高频能量分数\n$$\n\\phi(t)=\\frac{\\sum_{k=\\lfloor 2N/3\\rfloor+1}^N E_k(t)}{\\sum_{k=1}^N E_k(t)}.\n$$\n\n你必须编写一个程序，使用速度 Verlet 方案，在自然的无量纲时间单位 $t_0=\\sqrt{m/k}$ (其中 $m=1$ 且线性弹簧常数 $k=1$，因此 $t_0=1$) 下对 FPUT 运动方程进行积分。使用以下数值参数：时间步长 $dt=0.02$，用于诊断性评估模态能量的采样间隔为 $n_s=25$ 步，最大步数 $n_{\\max}=15000$ (因此 $T_{\\max}=n_{\\max}\\,dt=300$)，以及阈值分数 $\\phi_{\\mathrm{th}}=0.15$。初始条件应仅激发最低频率的线性模态，且初始速度为零，即\n$$\nx_i(0)=A\\,\\sin\\left(\\frac{\\pi i}{N+1}\\right),\\quad \\dot{x}_i(0)=0,\n$$\n其中振幅 $A$ 的选择应使模态 $k=1$ 中的初始线性能量等于 $E_0=1$，即\n$$\nE_1(0)=\\frac{1}{2}\\omega_1^2\\,Q_1(0)^2=1.\n$$\n作为解答的一部分，你需要推导并实现此约束下 $A$ 的表达式。\n\n将“高频转移时间尺度” $t^\\ast$ 定义为 $\\phi(t)$ 首次超过 $\\phi_{\\mathrm{th}}$ 的最早时间。由于模态能量每 $n_s$ 步评估一次，通过在包含 $\\phi_{\\mathrm{th}}$ 的最近两个 $\\phi(t)$ 采样值之间进行线性插值来估计 $t^\\ast$。如果在 $T_{\\max}$ 之前 $\\phi(t)$ 从未超过 $\\phi_{\\mathrm{th}}$，则设 $t^\\ast=T_{\\max}$。此外，通过归一化谱熵定义 $T_{\\max}$ 时刻的“均分邻近指数”\n$$\nS_{\\mathrm{norm}}(T_{\\max})=\\frac{-\\sum_{k=1}^{N} p_k(T_{\\max})\\ln p_k(T_{\\max})}{\\ln N},\\quad p_k(T_{\\max})=\\frac{E_k(T_{\\max})}{\\sum_{j=1}^{N}E_j(T_{\\max})}.\n$$\n根据定义，$S_{\\mathrm{norm}}(T_{\\max})\\in[0,1]$，值越接近 $1$ 表示能量在各模态间的分布越均匀。\n\n实现你的求解器，并为以下参数对 $(N,\\alpha)$ 的测试套件计算 $\\{t^\\ast,S_{\\mathrm{norm}}(T_{\\max})\\}$：\n- 情况 1：$(N,\\alpha)=(32,0.25)$，具有中等非线性和系统规模的“理想路径”。\n- 情况 2：$(N,\\alpha)=(32,0.01)$，一个低非线性的边界情况，其中能量转移可能非常缓慢。\n- 情况 3：$(N,\\alpha)=(48,0.25)$，在相同非线性下更大的系统规模。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式为 $[t^\\ast_1,S_1,t^\\ast_2,S_2,t^\\ast_3,S_3]$，其中 $t^\\ast_j$ 以无量纲时间单位 $t_0$ 表示，$S_j=S_{\\mathrm{norm}}(T_{\\max})$ 是无量纲的。输出中的每个浮点数必须四舍五入到六位小数。例如，输出格式应类似于 $[0.123456,0.987654,300.000000,0.543210,1.234567,0.876543]$。", "solution": "该问题要求对 Fermi–Pasta–Ulam–Tsingou (FPUT) 链进行数值模拟，以研究能量均分过程。我们的任务是积分运动方程，分析线性简正模中的能量分布，并计算两个特定的诊断量：能量转移到高频模态的时间尺度 $t^\\ast$，以及在最终模拟时刻的均分指数 $S_{\\mathrm{norm}}$。该分析将针对三组参数 $(N,\\alpha)$ 进行。\n\n首先，我们确定系统的初始状态。初始位置由最低频率简正模的形状给出，$x_i(0)=A\\,\\sin\\left(\\frac{\\pi i}{N+1}\\right)$，初始速度为零，$\\dot{x}_i(0)=0$。振幅 $A$ 由模态 $k=1$ 中的初始能量为 $E_1(0)=1$ 的约束条件确定。模态坐标 $Q_k(t)$ 和动量 $P_k(t)$ 是物理坐标和速度在简正模基 $S_{i,k}$ 上的投影。在时间 $t=0$ 时，由于所有速度 $\\dot{x}_i(0)$ 均为零，所有模态动量也为零，$P_k(0)=0$ 对所有 $k$ 成立。初始模态坐标由下式给出：\n$$\nQ_k(0) = \\sum_{i=1}^N x_i(0) S_{i,k} = \\sum_{i=1}^N \\left( A\\sin\\left(\\frac{\\pi i}{N+1}\\right) \\right) \\left( \\sqrt{\\frac{2}{N+1}}\\sin\\left(\\frac{\\pi k i}{N+1}\\right) \\right)\n$$\n认识到 $\\sin\\left(\\frac{\\pi i}{N+1}\\right)$ 与模态 $k=1$ 的基向量成正比，具体来说是 $S_{i,1} = \\sqrt{\\frac{2}{N+1}}\\sin\\left(\\frac{\\pi i}{N+1}\\right)$，我们可以写出 $x_i(0) = A\\sqrt{\\frac{N+1}{2}}S_{i,1}$。将此代入 $Q_k(0)$ 的表达式中：\n$$\nQ_k(0) = \\sum_{i=1}^N \\left(A\\sqrt{\\frac{N+1}{2}}S_{i,1}\\right) S_{i,k} = A\\sqrt{\\frac{N+1}{2}} \\sum_{i=1}^N S_{i,1} S_{i,k}\n$$\n由于基向量的标准正交性，$\\sum_{i=1}^N S_{i,j} S_{i,k} = \\delta_{jk}$，其中 $\\delta_{jk}$ 是克罗内克 delta。因此，只有当 $k=1$ 时，该和才非零，得到 $Q_k(0) = A\\sqrt{\\frac{N+1}{2}}\\delta_{1k}$。这证实了初始时只有第一个模态被激发。该模态中的能量为：\n$$\nE_1(0) = \\frac{1}{2} \\left( P_1(0)^2 + \\omega_1^2 Q_1(0)^2 \\right) = \\frac{1}{2} \\omega_1^2 \\left( A\\sqrt{\\frac{N+1}{2}} \\right)^2 = \\frac{1}{4} A^2 \\omega_1^2 (N+1)\n$$\n设 $E_1(0)=1$ 并求解 $A$ (振幅取正根) 得：\n$$\nA = \\frac{2}{\\omega_1 \\sqrt{N+1}}\n$$\n结合 $\\omega_1 = 2\\sin\\left(\\frac{\\pi}{2(N+1)}\\right)$，这就完全确定了对于任意给定 $N$ 的初始条件。\n\n接下来，我们使用指定的速度 Verlet 算法对运动方程 $\\ddot{x}_i = F_i$ (因为质量 $m=1$) 进行积分。对于从 $1$ 到 $N$ 的每个粒子 $i$，这是一个二阶精确的方案，它在一个时间步长 $dt$ 内更新位置 $x_i$ 和速度 $v_i$：\n$1$. 将速度更新到时间步长的中点：$v_i(t+dt/2) = v_i(t) + \\ddot{x}_i(t) \\frac{dt}{2}$。\n$2$. 将位置更新到时间步长的末尾：$x_i(t+dt) = x_i(t) + v_i(t+dt/2) dt$。\n$3$. 使用新位置 $x_i(t+dt)$ 计算力 $F_i(t+dt)$。粒子 $i$ 上的力是 $F_i=(r_i+\\alpha\\,r_i^2)-(r_{i-1}+\\alpha\\,r_{i-1}^2)$，其中伸长量 $r_j=x_{j+1}-x_j$ 是根据边界条件 $x_0=0$ 和 $x_{N+1}=0$ 计算的。新的加速度为 $\\ddot{x}_i(t+dt) = F_i(t+dt)$。\n$4$. 将速度更新到时间步长的末尾：$v_i(t+dt) = v_i(t+dt/2) + \\ddot{x}_i(t+dt) \\frac{dt}{2}$。\n这个过程重复 $n_{\\max}=15000$ 步，从 $t=0$ 到 $T_{\\max}=300$。\n\n诊断量每 $n_s=25$ 个时间步计算一次。在每个采样时间 $t$，我们进行一次简正模分析。\n首先，我们将物理位置 $x_i(t)$ 和速度 $\\dot{x}_i(t)$ 变换为模态坐标 $Q_k(t)$ 和动量 $P_k(t)$。这是通过与预先计算的离散正弦变换矩阵 $S_{i,k}$ 进行矩阵-向量乘积来实现的。设 $\\vec{x}(t)$ 和 $\\vec{v}(t)$ 分别是位置和速度的列向量，并设 $\\mathbf{S}$ 是元素为 $S_{i,k}$ 的矩阵。那么模态坐标和动量的向量为 $\\vec{Q}(t) = \\mathbf{S}^T \\vec{x}(t)$ 和 $\\vec{P}(t) = \\mathbf{S}^T \\vec{v}(t)$。\n然后，每个线性模态中的能量计算为 $E_k(t)=\\frac{1}{2}(P_k(t)^2+\\omega_k^2 Q_k(t)^2)$。\n\n根据模态能量，我们计算高频能量分数 $\\phi(t)$。这是高频模态（索引 $k$ 从 $\\lfloor \\frac{2N}{3}\\rfloor+1$ 到 $N$）中的能量与总模态能量 $\\sum_{k=1}^N E_k(t)$ 的比值。\n时间尺度 $t^\\ast$ 是 $\\phi(t)$ 首次穿过阈值 $\\phi_{\\mathrm{th}}=0.15$ 的时间。我们找到两个连续的采样时间 $t_{prev}$ 和 $t_{curr}$，满足 $\\phi(t_{prev}) \\le \\phi_{\\mathrm{th}}  \\phi(t_{curr})$。然后通过线性插值找到 $t^\\ast$：\n$$\nt^\\ast = t_{prev} + (t_{curr} - t_{prev}) \\frac{\\phi_{\\mathrm{th}} - \\phi(t_{prev})}{\\phi(t_{curr}) - \\phi(t_{prev})}\n$$\n如果阈值从未被穿过，则将 $t^\\ast$ 设为 $T_{\\max}=300$。如果穿越发生在第一次采样之前，则使用 $t=0$ 时的初始条件 $\\phi(0)=0$ 进行插值。\n\n最后，在模拟结束时（$t=T_{\\max}$），我们计算均分邻近指数 $S_{\\mathrm{norm}}$。这需要计算每个模态的能量份额，$p_k = E_k(T_{\\max}) / \\sum_j E_j(T_{\\max})$。然后，归一化谱熵为：\n$$\nS_{\\mathrm{norm}}(T_{\\max}) = \\frac{-\\sum_{k=1}^{N} p_k \\ln p_k}{\\ln N}\n$$\n在求和中，当 $p_k=0$ 时，项的贡献为 $0$。$S_{\\mathrm{norm}}$ 的值接近 $1$ 表示能量均匀地分布在所有模态上，接近热平衡（能量均分）。接近 $0$ 的值表示能量局域化在少数几个模态中。\n\n整体算法包含一个主函数，该函数遍历三个测试用例 $(N, \\alpha)$。对于每种情况，一个专用的模拟函数会根据 $N$ 初始化系统，运行速度 Verlet 积分循环 $n_{\\max}$ 步，并以 $n_s$ 步为间隔计算诊断量，最终确定并返回数值对 $\\{t^\\ast, S_{\\mathrm{norm}}(T_{\\max})\\}$。最终结果被收集并按规定格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_fput_simulation(N, alpha, dt, n_max, n_s, phi_th):\n    \"\"\"\n    Runs a single FPUT simulation for a given N and alpha.\n    \"\"\"\n    # 1. System Initialization\n    \n    # 1a. Define basis vectors and frequencies\n    k_vec = np.arange(1, N + 1)\n    i_vec = np.arange(1, N + 1)\n    \n    # S_matrix[i-1, k-1] corresponds to S_{i,k}\n    S_matrix = np.sqrt(2 / (N + 1)) * np.sin(np.pi * np.outer(i_vec, k_vec) / (N + 1))\n    \n    # omega_k[k-1] corresponds to omega_k\n    omega_k = 2 * np.sin(np.pi * k_vec / (2 * (N + 1)))\n\n    # 1b. Calculate initial amplitude A for E_1(0) = 1\n    omega_1 = omega_k[0]\n    A = 2 / (omega_1 * np.sqrt(N + 1))\n    \n    # 1c. Set initial positions and velocities\n    x = A * np.sin(np.pi * i_vec / (N + 1))  # Initial position vector\n    v = np.zeros(N)                         # Initial velocity vector\n    \n    # Helper function for force calculation\n    def calculate_forces(pos, alpha_val):\n        # Pad positions with fixed boundaries x_0=0, x_{N+1}=0\n        x_padded = np.zeros(N + 2)\n        x_padded[1:-1] = pos\n        # Stretches r_j = x_{j+1} - x_j\n        r = np.diff(x_padded)\n        # Intermediate force term\n        f_term = r + alpha_val * r**2\n        # Force F_i = f_term_i - f_term_{i-1}\n        return f_term[1:] - f_term[:-1]\n\n    # Initial acceleration (since m=1)\n    a = calculate_forces(x, alpha)\n    \n    # 2. Main Integration Loop\n    t_star = n_max * dt  # Initialize to T_max\n    found_t_star = False\n    \n    # For interpolation, store previous phi and time\n    # Initialize with t=0 values: phi(0)=0\n    phi_prev, t_prev = 0.0, 0.0\n    \n    # To hold the final modal energies needed for S_norm\n    E_k_final = np.zeros(N)\n\n    for step in range(n_max):\n        # Velocity Verlet integration step\n        v_half = v + 0.5 * dt * a\n        x = x + dt * v_half\n        a_new = calculate_forces(x, alpha)\n        v = v_half + 0.5 * dt * a_new\n        a = a_new\n        \n        current_time = (step + 1) * dt\n        \n        # 3. Diagnostics (every n_s steps)\n        if (step + 1) % n_s == 0:\n            # Transform to modal coordinates/momenta\n            Q = S_matrix.T @ x\n            P = S_matrix.T @ v\n            \n            # Calculate modal energies\n            E_k = 0.5 * (P**2 + (omega_k * Q)**2)\n            \n            # Calculate high-frequency energy fraction phi(t)\n            E_total = np.sum(E_k)\n            phi_current = 0.0\n            if E_total  1e-12: # Avoid division by zero\n                k_high_start_idx = int(2 * N / 3) \n                E_high = np.sum(E_k[k_high_start_idx:])\n                phi_current = E_high / E_total\n\n            # Check for t_star crossing\n            if not found_t_star and phi_current  phi_th:\n                # Linearly interpolate to find t_star\n                if np.abs(phi_current - phi_prev)  1e-12:\n                    t_star = t_prev + (current_time - t_prev) * (phi_th - phi_prev) / (phi_current - phi_prev)\n                else: # Fallback if denominator is zero\n                    t_star = current_time\n                found_t_star = True\n\n            # Update previous values for next potential interpolation\n            t_prev = current_time\n            phi_prev = phi_current\n\n            # If this is the last step, store E_k for S_norm\n            if step == n_max - 1:\n                E_k_final = E_k\n\n    # 4. Final equipartition index S_norm\n    # Ensure E_k_final is populated if sim ends before a sample point\n    if np.sum(E_k_final) == 0:\n        Q = S_matrix.T @ x\n        P = S_matrix.T @ v\n        E_k_final = 0.5 * (P**2 + (omega_k * Q)**2)\n\n    E_total_final = np.sum(E_k_final)\n    S_norm = 0.0\n    if E_total_final  1e-12:\n        p_k = E_k_final / E_total_final\n        # Filter p_k > 0 to avoid log(0)\n        p_k_nonzero = p_k[p_k  0]\n        entropy = -np.sum(p_k_nonzero * np.log(p_k_nonzero))\n        S_norm = entropy / np.log(N)\n\n    return t_star, S_norm\n\ndef solve():\n    # Define the problem parameters and test cases.\n    dt = 0.02\n    n_s = 25\n    n_max = 15000\n    phi_th = 0.15\n    \n    test_cases = [\n        (32, 0.25),  # Case 1\n        (32, 0.01),  # Case 2\n        (48, 0.25),  # Case 3\n    ]\n\n    results = []\n    for N, alpha in test_cases:\n        t_star, S_norm = run_fput_simulation(N, alpha, dt, n_max, n_s, phi_th)\n        results.append(t_star)\n        results.append(S_norm)\n\n    # Format the final output as a comma-separated list of floats with 6 decimal places.\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3411203"}]}