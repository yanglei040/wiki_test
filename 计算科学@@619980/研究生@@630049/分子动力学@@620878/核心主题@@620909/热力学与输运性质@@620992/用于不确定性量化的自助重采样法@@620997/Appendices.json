{"hands_on_practices": [{"introduction": "Jarzynski 等式是从非平衡功的测量中计算平衡态自由能差异的强大工具。然而，它的经验估计量对罕见的、低功值的事件极其敏感，这些事件主导了指数平均值，导致功分布出现重尾行为。本练习将指导您应用分层自助法（stratified bootstrap），这是一种专门为确保对分布的尾部进行充分抽样而设计的技术，从而稳定不确定性估计，并为自由能计算提供更可靠的置信区间 [@problem_id:3399592]。", "problem": "给定一个非平衡分子动力学 (MD) 情景，在该情景中，自由能差通过 Jarzynski 等式进行估计。其基本依据是源于非平衡统计力学的 Jarzynski 等式，该等式指出，对于一个初始处于温度 $T$ 平衡态的系统，两个状态之间的自由能差 $\\Delta G$ 可以通过在某个转换过程中所做的非平衡功 $W$ 的重复实现来获得，具体如下\n$$\n\\Delta G = - k_{\\mathrm{B}} T \\ln \\left\\langle e^{-\\beta W} \\right\\rangle,\n$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度，$\\beta = \\frac{1}{k_{\\mathrm{B}} T}$，尖括号表示对独立实现的系综平均，$W$ 是沿每条轨迹所做的功。经验估计量使用从分子动力学轨迹中获得的有限个独立功值样本 $\\{W_i\\}_{i=1}^N$。由于存在指数权重 $e^{-\\beta W}$，稀有的低功值事件可能会主导估计结果，从而产生重尾行为和巨大的不确定性。目标是使用分层自助法 (stratified bootstrap) 来量化这种不确定性，该方法在功分布的由分位数定义的分层内进行重抽样，以稳定重尾的贡献。\n\n从上述基本依据和非参数自助法重抽样的定义出发，设计一个算法，该算法能够：\n- 通过使用样本分位数或秩将样本 $\\{W_i\\}_{i=1}^N$ 划分成 $S$ 个频率大致相等的层，构建一个基于 $W$ 分位数的分层自助法。\n- 通过在每个层内进行有放回的抽样生成 $B$ 个自助法副本，保持原始层的大小不变，并对每个副本使用重抽样数据计算 Jarzynski 估计量 $\\widehat{\\Delta G}$。\n- 报告基于原始数据的点估计 $\\widehat{\\Delta G}$、自助法标准误 $\\sigma_{\\mathrm{boot}}$，以及基于百分位法在 $95\\%$ 水平上的双侧置信区间 $[\\mathrm{CI}_{\\mathrm{low}}, \\mathrm{CI}_{\\mathrm{high}}]$（即，以小数而非百分比表示的第 $2.5$ 和 $97.5$ 个经验分位数）。\n\n在为重尾数据计算 $\\ln \\left\\langle e^{-\\beta W} \\right\\rangle$ 时需要数值稳定性。您的算法必须实现一种稳定的计算方法，避免上溢和下溢，例如使用 log-sum-exp 恒等式。\n\n所有能量单位均以焦耳 $\\mathrm{J}$ 表示。温度必须以开尔文 $\\mathrm{K}$ 表示。不涉及角度。所用的玻尔兹曼常数为 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J}/\\mathrm{K}$。为保证可复现性，请将伪随机数生成器的种子设置为 $123$。\n\n测试套件。您的程序必须从一个科学上合理的混合模型中生成合成的功数据 $\\{W_i\\}$，该模型模仿在非平衡 MD 拉伸实验中观察到的重尾行为，其中 $W$ 从两个正态分布的混合体中独立抽样：\n- 以概率 $p$，$W$ 从均值为 $\\mu_{\\mathrm{main}}$、标准差为 $\\sigma_{\\mathrm{main}}$ 的正态分布中抽取。\n- 以概率 $1-p$，$W$ 从均值为 $\\mu_{\\mathrm{tail}}$、标准差为 $\\sigma_{\\mathrm{tail}}$ 的正态分布中抽取。\n为保持物理标度，均值和标准差以 $k_{\\mathrm{B}} T$ 为单位进行参数化，即，设置 $\\mu_{\\mathrm{main}} = c_{\\mu,\\mathrm{main}}\\,k_{\\mathrm{B}}T$，$\\sigma_{\\mathrm{main}} = c_{\\sigma,\\mathrm{main}}\\,k_{\\mathrm{B}}T$，$\\mu_{\\mathrm{tail}} = c_{\\mu,\\mathrm{tail}}\\,k_{\\mathrm{B}}T$，以及 $\\sigma_{\\mathrm{tail}} = c_{\\sigma,\\mathrm{tail}}\\,k_{\\mathrm{B}}T$，然后转换为焦耳。令 $N$ 表示样本大小，$S$ 表示分层数，$B$ 表示自助法副本数。使用以下三个测试用例，它们分别涵盖典型情况、小样本情况和极端重尾情况：\n\n- 用例 $1$ (典型重尾): $N = 1000$, $T = 300\\,\\mathrm{K}$, $p = 0.95$, $c_{\\mu,\\mathrm{main}} = 10$, $c_{\\sigma,\\mathrm{main}} = 3$, $c_{\\mu,\\mathrm{tail}} = -5$, $c_{\\sigma,\\mathrm{tail}} = 2$, $S = 10$, $B = 1000$.\n- 用例 $2$ (小样本，更重的尾部): $N = 200$, $T = 300\\,\\mathrm{K}$, $p = 0.90$, $c_{\\mu,\\mathrm{main}} = 6$, $c_{\\sigma,\\mathrm{main}} = 2$, $c_{\\mu,\\mathrm{tail}} = -8$, $c_{\\sigma,\\mathrm{tail}} = 3$, $S = 8$, $B = 1500$.\n- 用例 $3$ (稀有但极端的负功事件): $N = 1000$, $T = 300\\,\\mathrm{K}$, $p = 0.98$, $c_{\\mu,\\mathrm{main}} = 12$, $c_{\\sigma,\\mathrm{main}} = 2$, $c_{\\mu,\\mathrm{tail}} = -20$, $c_{\\sigma,\\mathrm{tail}} = 5$, $S = 10$, $B = 1000$.\n\n您的程序必须：\n- 对每个用例，使用上述定义的混合模型生成 $\\{W_i\\}$。\n- 计算以 $\\mathrm{J}$ 为单位的点估计 $\\widehat{\\Delta G}$、以 $\\mathrm{J}$ 为单位的自助法标准误 $\\sigma_{\\mathrm{boot}}$，以及以 $\\mathrm{J}$ 为单位的百分位法置信区间端点 $\\mathrm{CI}_{\\mathrm{low}}$ 和 $\\mathrm{CI}_{\\mathrm{high}}$。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个用例的结果为列表 $[\\widehat{\\Delta G},\\sigma_{\\mathrm{boot}},\\mathrm{CI}_{\\mathrm{low}},\\mathrm{CI}_{\\mathrm{high}}]$。所有数字必须以科学记数法打印，保留六位有效数字，并以 $\\mathrm{J}$ 为单位。例如，输出格式必须为 $[[x_1,y_1,z_1,w_1],[x_2,y_2,z_2,w_2],[x_3,y_3,z_3,w_3]]$，其中每个 $x_i$、$y_i$、$z_i$、$w_i$ 都是科学记数法表示的浮点数。", "solution": "该问题要求设计并实现一个算法，使用 Jarzynski 等式从一组非平衡功值 $\\{W_i\\}$ 计算自由能差 $\\Delta G$。此任务的核心是为 $\\Delta G$ 估计提供一个稳健的不确定性量化方法，该方法使用分层自助法 (stratified bootstrap) 程序，此程序特别适用于此类问题中常见的重尾功分布。\n\n基本原理是 Jarzynski 等式：\n$$\n\\Delta G = -k_{\\mathrm{B}} T \\ln \\left\\langle e^{-\\beta W} \\right\\rangle\n$$\n其中 $\\Delta G$ 是亥姆霍兹自由能差，$k_{\\mathrm{B}}$ 是玻尔兹曼常数（$1.380649 \\times 10^{-23}\\,\\mathrm{J}/\\mathrm{K}$），$T$ 是绝对温度，$\\beta = (k_{\\mathrm{B}} T)^{-1}$，尖括号 $\\left\\langle \\cdot \\right\\rangle$ 表示对无限个非平衡轨迹的系综平均。在实践中，我们有一个包含 $N$ 个功值的有限样本 $\\{W_i\\}_{i=1}^N$，这引出了经验估计量：\n$$\n\\widehat{\\Delta G} = -k_{\\mathrm{B}} T \\ln \\left( \\frac{1}{N} \\sum_{i=1}^{N} e^{-\\beta W_i} \\right)\n$$\n一个重大的挑战来自于指数权重项 $e^{-\\beta W}$。具有小功值或负功值的轨迹，尽管很稀有，但可能对总和做出不成比例的贡献，导致估计量被少数事件主导并表现出高方差。这使得估计在数值上不稳定，其不确定性也难以评估。\n\n一个用于减轻求和中数值上溢的标准技术是 log-sum-exp 恒等式。我们可以将估计量重写为更稳定的形式。令 $W_{\\min} = \\min_{i} \\{W_i\\}$。对数的参数变为：\n$$\n\\frac{1}{N} \\sum_{i=1}^{N} e^{-\\beta W_i} = \\frac{1}{N} \\sum_{i=1}^{N} e^{-\\beta (W_i - W_{\\min} + W_{\\min})} = \\frac{e^{-\\beta W_{\\min}}}{N} \\sum_{i=1}^{N} e^{-\\beta (W_i - W_{\\min})}\n$$\n将此代回 $\\widehat{\\Delta G}$ 的估计量中：\n$$\n\\widehat{\\Delta G} = -k_{\\mathrm{B}} T \\ln \\left( \\frac{e^{-\\beta W_{\\min}}}{N} \\sum_{i=1}^{N} e^{-\\beta (W_i - W_{\\min})} \\right)\n$$\n$$\n\\widehat{\\Delta G} = -k_{\\mathrm{B}} T \\left( -\\beta W_{\\min} + \\ln \\left( \\frac{1}{N} \\sum_{i=1}^{N} e^{-\\beta (W_i - W_{\\min})} \\right) \\right)\n$$\n由于 $\\beta = (k_{\\mathrm{B}} T)^{-1}$，这可以简化为一个数值上稳健的表达式：\n$$\n\\widehat{\\Delta G} = W_{\\min} - k_{\\mathrm{B}} T \\ln \\left( \\frac{1}{N} \\sum_{i=1}^{N} e^{-\\frac{W_i - W_{\\min}}{k_{\\mathrm{B}} T}} \\right)\n$$\n这种形式可以防止浮点数上溢，因为和中的最大指数为 $0$，对应于 $W_i = W_{\\min}$。\n\n为了量化不确定性，我们采用分层自助法程序。对于重尾分布，此方法优于简单的自助法，因为它能确保分布的所有部分，包括关键的尾部区域，在每个自助法副本中都得到体现。该算法按以下步骤进行：\n\n1.  **分层**：将包含 $N$ 个功值 $\\{W_i\\}$ 的原始样本按升序排序。然后将排序后的样本划分为 $S$ 个层，每个层包含大约 $N/S$ 个连续的数据点。这种划分确保了最低的功值被隔离在它们自己的层中，从而保证了它们在重抽样过程中的代表性。\n\n2.  **重抽样**：生成 $B$ 个自助法副本。每个副本都是一个大小为 $N$ 的新样本，通过以下过程构建：对于每个包含 $n_j$ 个数据点的层 $j$，我们从该层中*有放回地*抽取 $n_j$ 个样本。然后将所有层的重抽样数据合并，形成一个自助法副本。此过程保留了源自原始分布每个分位数范围的数据点数量。\n\n3.  **估计与分析**：对于 $B$ 个自助法副本中的每一个（记为 $\\{W_i^*\\}_{k}$，其中 $k=1, \\dots, B$），使用数值稳定的公式计算 Jarzynski 估计值 $\\widehat{\\Delta G}_k^*$。这将产生一个包含 $B$ 个自助法估计值的集合 $\\{\\widehat{\\Delta G}_k^*\\}_{k=1}^B$。\n    - 自助法标准误 $\\sigma_{\\mathrm{boot}}$ 是该集合的样本标准差：\n      $$\n      \\sigma_{\\mathrm{boot}} = \\sqrt{\\frac{1}{B-1} \\sum_{k=1}^{B} (\\widehat{\\Delta G}_k^* - \\overline{\\widehat{\\Delta G}^*})^2}\n      $$\n      其中 $\\overline{\\widehat{\\Delta G}^*}$ 是自助法估计值的均值。\n    - 通过找到已排序的自助法估计值分布 $\\{\\widehat{\\Delta G}_k^*\\}$ 的第 $2.5$ 和第 $97.5$ 个百分位数，构建一个 $95\\%$ 的百分位法置信区间 $[\\mathrm{CI}_{\\mathrm{low}}, \\mathrm{CI}_{\\mathrm{high}}]$。\n\n用于测试此算法的合成功数据是从一个双组分正态混合模型生成的，该模型是对单分子拉伸实验中功分布的一种合理解释。一个数据点 $W$ 以概率 $p$ 从“主”分布 $\\mathcal{N}(\\mu_{\\mathrm{main}}, \\sigma_{\\mathrm{main}}^2)$ 中抽取，并以概率 $1-p$ 从“尾”分布 $\\mathcal{N}(\\mu_{\\mathrm{tail}}, \\sigma_{\\mathrm{tail}}^2)$ 中抽取。这些分布的参数通过热能 $k_{\\mathrm{B}} T$进行缩放，以保持其物理相关性。\n\n最终的算法综合了这些组成部分：它生成指定的合成数据，从完整数据集中计算点估计 $\\widehat{\\Delta G}$，然后执行分层自助法程序来计算 $\\sigma_{\\mathrm{boot}}$ 和置信区间端点 $\\mathrm{CI}_{\\mathrm{low}}$ 和 $\\mathrm{CI}_{\\mathrm{high}}$。所有能量值均以焦耳报告。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Jarzynski equality problem with stratified bootstrap for uncertainty.\n    \"\"\"\n    \n    # Define physical constant and random number generator\n    K_B = 1.380649e-23  # Boltzmann constant in J/K\n    RNG = np.random.default_rng(123)\n\n    # Define test cases as per the problem description\n    test_cases = [\n        # Case 1 (typical heavy-tail)\n        {'N': 1000, 'T': 300.0, 'p': 0.95, 'c_mu_main': 10.0, 'c_sigma_main': 3.0, \n         'c_mu_tail': -5.0, 'c_sigma_tail': 2.0, 'S': 10, 'B': 1000},\n        # Case 2 (small sample, heavier tail)\n        {'N': 200, 'T': 300.0, 'p': 0.90, 'c_mu_main': 6.0, 'c_sigma_main': 2.0, \n         'c_mu_tail': -8.0, 'c_sigma_tail': 3.0, 'S': 8, 'B': 1500},\n        # Case 3 (rare but extreme negative-work events)\n        {'N': 1000, 'T': 300.0, 'p': 0.98, 'c_mu_main': 12.0, 'c_sigma_main': 2.0, \n         'c_mu_tail': -20.0, 'c_sigma_tail': 5.0, 'S': 10, 'B': 1000},\n    ]\n\n    results = []\n\n    def jarzynski_estimator(work_values, T):\n        \"\"\"\n        Calculates the Jarzynski free energy estimate using a numerically stable\n        log-sum-exp formulation.\n        \n        Args:\n            work_values (np.ndarray): Array of work values in Joules.\n            T (float): Temperature in Kelvin.\n        \n        Returns:\n            float: The estimated free energy difference in Joules.\n        \"\"\"\n        if len(work_values) == 0:\n            return np.nan\n        \n        kBT = K_B * T\n        beta = 1.0 / kBT\n        \n        w_min = np.min(work_values)\n        \n        # Numerically stable calculation: delta_G = W_min - kBT * log(mean(exp(-beta*(W-W_min))))\n        shifted_exp_terms = np.exp(-beta * (work_values - w_min))\n        mean_of_exponentials = np.mean(shifted_exp_terms)\n        \n        delta_g = w_min - kBT * np.log(mean_of_exponentials)\n        return delta_g\n\n    for case in test_cases:\n        N, T, p, S, B = case['N'], case['T'], case['p'], case['S'], case['B']\n        kBT = K_B * T\n\n        # Generate synthetic work data from the mixture model\n        # 1. Determine number of samples from each distribution\n        num_main = RNG.binomial(N, p)\n        num_tail = N - num_main\n\n        # 2. Define distribution parameters in Joules\n        mu_main = case['c_mu_main'] * kBT\n        sigma_main = case['c_sigma_main'] * kBT\n        mu_tail = case['c_mu_tail'] * kBT\n        sigma_tail = case['c_sigma_tail'] * kBT\n\n        # 3. Generate samples\n        work_main = RNG.normal(loc=mu_main, scale=sigma_main, size=num_main)\n        work_tail = RNG.normal(loc=mu_tail, scale=sigma_tail, size=num_tail)\n        W = np.concatenate((work_main, work_tail))\n        RNG.shuffle(W)\n\n        # Calculate the point estimate from the original data\n        delta_g_hat = jarzynski_estimator(W, T)\n\n        # --- Stratified Bootstrap Procedure ---\n        \n        # 1. Stratify the data\n        W_sorted = np.sort(W)\n        strata = np.array_split(W_sorted, S)\n        \n        # 2. Resampling and Estimation\n        bootstrap_estimates = np.empty(B)\n        for i in range(B):\n            bootstrap_sample_parts = []\n            for stratum in strata:\n                n_stratum = len(stratum)\n                resampled_part = RNG.choice(stratum, size=n_stratum, replace=True)\n                bootstrap_sample_parts.append(resampled_part)\n            \n            bootstrap_sample = np.concatenate(bootstrap_sample_parts)\n            bootstrap_estimates[i] = jarzynski_estimator(bootstrap_sample, T)\n            \n        # 3. Analyze bootstrap results\n        # Bootstrap standard error (sample standard deviation, ddof=1)\n        sigma_boot = np.std(bootstrap_estimates, ddof=1)\n        \n        # 95% percentile confidence interval\n        ci_low = np.percentile(bootstrap_estimates, 2.5)\n        ci_high = np.percentile(bootstrap_estimates, 97.5)\n        \n        # Store results for this case\n        results.append([delta_g_hat, sigma_boot, ci_low, ci_high])\n\n    # Format the final output string\n    output_str = f\"[{','.join([f'[{\",\".join([f\"{v:.6e}\" for v in r])}]' for r in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3399592"}, {"introduction": "热容是另一个关键的热力学性质，可以通过分子动力学模拟中的能量涨落来计算。与 Jarzynski 估计量类似，如果能量分布具有非常重的尾部（可能导致无限方差），其计算可能会变得不稳定，使得标准误差估计失效。本练习将引导您实现 $m$-out-of-$n$ 自助法，这是一种强大的技术，专门设计用于处理这类具有挑战性的统计情景，从而为热容估计提供稳健的不确定性量化 [@problem_id:3399551]。", "problem": "考虑一个正则系综分子动力学可观测量，其瞬时能量表示为 $E$。在正则系综中，$E$ 的分布由玻尔兹曼权重决定，定容热容定义为平均能量对温度的导数。重尾涨落可能会使关于估计量抽样分布的高斯假设失效。你的任务是设计一个程序，在能量样本是重尾分布的情况下，使用 $m$-out-of-$n$ bootstrap 方法对热容进行不确定性量化。\n\n从以下基本原理开始：\n- 正则系综的逆温度 $\\beta$ 由 $\\beta = 1/(k_B T)$ 给出，其中 $k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。\n- 对于离散的 $E$，配分函数为 $Z(\\beta) = \\sum_E g(E)\\, e^{-\\beta E}$（对于连续的 $E$，则是类似的积分形式），其中 $g(E)$ 是态密度。\n- 平均能量为 $\\langle E \\rangle = -\\frac{\\partial}{\\partial \\beta}\\ln Z(\\beta)$，其涨落与 $\\ln Z(\\beta)$ 的导数有关。\n\n基于这些原理，推导出用平衡能量涨落表示的热容，并实现一个使用有限能量样本的估计量。不要使用任何高斯近似的捷径；你的推理应基于上述正则系综的定义。\n\n合成的重尾能量样本应按如下方式生成。对于给定的样本大小 $n$，定义参数 $E_0$（基线能量偏移）、$\\sigma$（高斯涨落尺度）、$p_{\\mathrm{tail}}$（重尾跳跃概率）、$x_m$（帕累托尺度）和 $\\nu$（帕累托形状）。对于每个 $i \\in \\{1,\\dots,n\\}$：\n- 抽取一个高斯涨落 $G_i \\sim \\mathcal{N}(0,\\sigma^2)$。\n- 抽取一个伯努利指示变量 $J_i \\in \\{0,1\\}$，其中 $\\mathbb{P}(J_i=1) = p_{\\mathrm{tail}}$。\n- 抽取一个帕累托跳跃 $P_i = x_m \\left(1 + Y_i\\right)$，其中 $Y_i \\sim \\mathrm{Pareto}(\\nu)$，其支撑集为 $Y_i \\ge 1$。\n- 将能量样本定义为 $E_i = E_0 + G_i + J_i\\, P_i$。\n\n对于每个合成数据集，使用你推导的基于涨落的定义，从大小为 $n$ 的全样本中计算热容估计量，并使用 $m$-out-of-$n$ bootstrap 方法量化其不确定性，其中 $m = \\lfloor n^\\alpha \\rfloor$，$\\alpha$ 为指定的满足 $0  \\alpha  1$ 的值。在 bootstrap 过程中：\n- 从 $\\{1,\\dots,n\\}$ 中有放回地重抽样 $m$ 个索引。\n- 对重抽样得到的能量值计算相同的热容估计量。\n- 重复 $B$ 次 bootstrap 抽样，以获得该估计量的 bootstrap 分布。\n- 从 bootstrap 分布中，计算 bootstrap 标准误和置信水平为 $0.95$ 的双侧百分位置信区间。\n\n以物理单位报告结果：热容必须以焦耳每开尔文 (J/K) 表示，bootstrap 标准误必须以焦耳每开尔文 (J/K) 表示，置信区间的端点也必须以焦耳每开尔文 (J/K) 表示。温度必须以开尔文 (K) 为单位。不涉及角度。数值输出应表示为十进制浮点数。\n\n测试套件。你的程序必须运行以下四个参数集并汇总输出：\n- 情况 1（一般重尾，有限方差）：$n=1000$，$\\alpha=0.7$，$T=300\\,\\mathrm{K}$，$E_0=1.0\\times 10^{-19}\\,\\mathrm{J}$，$\\sigma=2.0\\times 10^{-21}\\,\\mathrm{J}$，$p_{\\mathrm{tail}}=0.02$，$x_m=3.0\\times 10^{-20}\\,\\mathrm{J}$，$\\nu=2.5$，$B=1000$。\n- 情况 2（强重尾，无限方差）：$n=100$，$\\alpha=0.5$，$T=300\\,\\mathrm{K}$，$E_0=8.0\\times 10^{-20}\\,\\mathrm{J}$，$\\sigma=4.0\\times 10^{-21}\\,\\mathrm{J}$，$p_{\\mathrm{tail}}=0.05$，$x_m=1.0\\times 10^{-19}\\,\\mathrm{J}$，$\\nu=1.5$，$B=1000$。\n- 情况 3（大样本，轻度重尾）：$n=10000$，$\\alpha=0.9$，$T=300\\,\\mathrm{K}$，$E_0=1.2\\times 10^{-19}\\,\\mathrm{J}$，$\\sigma=2.0\\times 10^{-21}\\,\\mathrm{J}$，$p_{\\mathrm{tail}}=0.01$，$x_m=2.0\\times 10^{-20}\\,\\mathrm{J}$，$\\nu=3.0$，$B=300$。\n- 情况 4（小 $m$ 的边界行为）：$n=500$，$\\alpha=0.3$，$T=350\\,\\mathrm{K}$，$E_0=1.0\\times 10^{-19}\\,\\mathrm{J}$，$\\sigma=1.5\\times 10^{-21}\\,\\mathrm{J}$，$p_{\\mathrm{tail}}=0.03$，$x_m=5.0\\times 10^{-20}\\,\\mathrm{J}$，$\\nu=2.0$，$B=1000$。\n\n取玻尔兹曼常数为 $k_B = 1.380649\\times 10^{-23}\\,\\mathrm{J}/\\mathrm{K}$。为每种情况使用固定的、可复现的伪随机种子，以使结果具有确定性。\n\n最终输出格式。你的程序应生成单行输出，包含一个由四元素列表组成的逗号分隔列表，每个四元素列表对应一种情况，其中包含全样本热容估计值、bootstrap 标准误以及置信水平为 $0.95$ 的双侧百分位置信区间的下端点和上端点。输出必须用方括号括起来，且不含空格，例如：$[[c_1,s_1,\\ell_1,u_1],[c_2,s_2,\\ell_2,u_2],[c_3,s_3,\\ell_3,u_3],[c_4,s_4,\\ell_4,u_4]]$，其中 $c_i$、$s_i$、$\\ell_i$、$u_i$ 是情况 $i$ 的以 $\\mathrm{J}/\\mathrm{K}$ 为单位的十进制浮点数。", "solution": "该问题要求设计一个程序，用于从正则系综中抽取的有限能量样本来估计定容热容 $C_V$，并使用 $m$-out-of-$n$ bootstrap 方法量化此估计的不确定性。能量样本由一个表现出重尾分布的合成模型生成。解决方案分为四个部分：首先，从统计力学原理推导热容公式；其次，构建基于有限样本的估计量；第三，描述合成数据的生成过程；第四，详细阐述用于不确定性量化的 $m$-out-of-$n$ bootstrap 过程。\n\n**1. 热容公式的推导**\n\n定容热容 $C_V$ 定义为在恒定体积 $V$ 下，平均能量 $\\langle E \\rangle$ 对温度 $T$ 的偏导数：\n$$\nC_V = \\left( \\frac{\\partial \\langle E \\rangle}{\\partial T} \\right)_V\n$$\n在正则系综中，使用逆温度 $\\beta = 1/(k_B T)$ 更为方便，其中 $k_B$ 是玻尔兹曼常数。利用链式法则，我们可以将对 $T$ 的导数用对 $\\beta$ 的导数来表示：\n$$\n\\frac{\\partial}{\\partial T} = \\frac{d\\beta}{dT} \\frac{\\partial}{\\partial \\beta} = \\left( -\\frac{1}{k_B T^2} \\right) \\frac{\\partial}{\\partial \\beta} = -k_B \\beta^2 \\frac{\\partial}{\\partial \\beta}\n$$\n将此式代入 $C_V$ 的定义得到：\n$$\nC_V = -k_B \\beta^2 \\left( \\frac{\\partial \\langle E \\rangle}{\\partial \\beta} \\right)_V\n$$\n平均能量 $\\langle E \\rangle$ 与正则配分函数 $Z(\\beta) = \\sum_i g(E_i) e^{-\\beta E_i}$ 相关，其中 $g(E_i)$ 是能级 $E_i$ 的态密度。该关系式为：\n$$\n\\langle E \\rangle = -\\frac{\\partial}{\\partial \\beta} \\ln Z(\\beta)\n$$\n将 $\\langle E \\rangle$ 的这个表达式代入 $C_V$ 的方程，我们得到：\n$$\nC_V = -k_B \\beta^2 \\frac{\\partial}{\\partial \\beta} \\left( -\\frac{\\partial}{\\partial \\beta} \\ln Z(\\beta) \\right) = k_B \\beta^2 \\frac{\\partial^2}{\\partial \\beta^2} \\ln Z(\\beta)\n$$\n为了计算该二阶导数，我们首先回顾 $\\frac{\\partial}{\\partial \\beta} \\ln Z(\\beta) = -\\langle E \\rangle$。将其对 $\\beta$ 求导可得：\n$$\n\\frac{\\partial^2}{\\partial \\beta^2} \\ln Z(\\beta) = -\\frac{\\partial \\langle E \\rangle}{\\partial \\beta}\n$$\n平均能量 $\\langle E \\rangle = (\\sum_i E_i e^{-\\beta E_i})/Z$ 对 $\\beta$ 的导数是：\n$$\n\\frac{\\partial \\langle E \\rangle}{\\partial \\beta} = \\frac{(\\sum_i -E_i^2 e^{-\\beta E_i})Z - (\\sum_i E_i e^{-\\beta E_i})(\\sum_j -E_j e^{-\\beta E_j})}{Z^2} = -\\frac{\\langle E^2 \\rangle Z^2}{Z^2} + \\frac{(\\langle E \\rangle Z)^2}{Z^2} = -(\\langle E^2 \\rangle - \\langle E \\rangle^2)\n$$\n$\\langle E^2 \\rangle - \\langle E \\rangle^2$ 这一项是能量的方差，记作 $\\sigma_E^2$。因此，我们有：\n$$\n\\frac{\\partial^2}{\\partial \\beta^2} \\ln Z(\\beta) = \\langle E^2 \\rangle - \\langle E \\rangle^2 = \\sigma_E^2\n$$\n最后，将此结果代回我们关于 $C_V$ 的表达式，我们便得到了热容的涨落-耗散公式：\n$$\nC_V = k_B \\beta^2 \\sigma_E^2 = k_B \\left( \\frac{1}{k_B T} \\right)^2 \\sigma_E^2 = \\frac{\\sigma_E^2}{k_B T^2}\n$$\n这个基本结果将宏观热力学性质——热容，与系统能量的微观涨落联系起来。\n\n**2. 有限样本的估计量**\n\n给定一个来自分子动力学模拟的、包含 $n$ 个能量值的有限样本 $\\{E_1, E_2, \\dots, E_n\\}$，我们可以为 $C_V$ 构建一个估计量。我们用基于样本的估计值来代替真实的总体方差 $\\sigma_E^2$。样本方差由下式给出：\n$$\n\\hat{\\sigma}_E^2 = \\frac{1}{n} \\sum_{i=1}^n (E_i - \\bar{E})^2 = \\left(\\frac{1}{n} \\sum_{i=1}^n E_i^2\\right) - \\left(\\frac{1}{n} \\sum_{i=1}^n E_i\\right)^2\n$$\n其中 $\\bar{E} = \\frac{1}{n} \\sum_{i=1}^n E_i$ 是样本均值。因此，热容的估计量 $\\hat{C}_V$ 为：\n$$\n\\hat{C}_{V,n} = \\frac{\\hat{\\sigma}_E^2}{k_B T^2}\n$$\n这就是要从大小为 $n$ 的完整合成数据集中计算的估计量。\n\n**3. 合成重尾能量模型**\n\n问题指定了一个合成数据生成过程，用以模拟包含罕见、大幅值事件的能量涨落，这是重尾分布的特征。对于大小为 $n$ 的样本，每个能量值 $E_i$（其中 $i \\in \\{1, \\dots, n\\}$）按如下方式生成：\n$$\nE_i = E_0 + G_i + J_i P_i\n$$\n各个组成部分为：\n- $E_0$：一个恒定的基线能量。\n- $G_i$：一个高斯涨落，$G_i \\sim \\mathcal{N}(0, \\sigma^2)$，代表围绕均值的典型热涨落。\n- $J_i$：一个伯努利随机变量，$J_i \\sim \\text{Bernoulli}(p_{\\mathrm{tail}})$，它作为重尾事件的指示器。$J_i=1$ 的概率为 $p_{\\mathrm{tail}}$，否则 $J_i=0$。\n- $P_i$：重尾跳跃的幅值。它被定义为 $P_i = x_m(1 + Y_i)$，其中 $x_m$ 是一个尺度参数，$Y_i$ 是一个来自帕累托分布的随机变量，其形状参数为 $\\nu$，支撑集在 $[1, \\infty)$ 上。一个形状为 $\\nu$、尺度（最小值）为 $1$ 的标准帕累托分布具有所需的支撑集。只有当 $\\nu  2$ 时，这个帕累托分布的方差才是有限的。因此，只有当 $\\nu  2$ 时，总能量 $E_i$ 的方差才是有限的。该模型允许在有限和无限方差两种条件下测试统计方法。\n\n**4. 用于不确定性量化的 $m$-out-of-$n$ Bootstrap 方法**\n\n当底层数据分布具有重尾，特别是无限方差（即 $\\nu \\le 2$）时，标准的 bootstrap 方法（重抽样大小为 $n$）无法对抽样分布产生一致的估计。$m$-out-of-$n$ bootstrap 是一种为处理此类情况而设计的修正方法。它涉及重抽样一个更小的样本量 $m  n$，其中 $m$ 的选择使其增长速度慢于 $n$（例如，对于 $0  \\alpha  1$，$m = \\lfloor n^\\alpha \\rfloor$）。这种子抽样方法确保了 bootstrap 近似在更弱的矩条件下的一致性。\n\n其过程如下：\n1.  从大小为 $n$ 的数据集中计算全样本估计值 $\\hat{C}_{V,n}$。\n2.  设置 bootstrap 重抽样的大小为 $m = \\lfloor n^\\alpha \\rfloor$。\n3.  对于 $B$ 次 bootstrap 重复中的每一次：\n    a. 从原始的 $n$ 个能量值中有放回地抽取一个大小为 $m$ 的样本。这得到一个 bootstrap 样本 $\\{E_1^*, \\dots, E_m^*\\}$。\n    b. 在这个 bootstrap 样本上计算热容估计值：$\\hat{C}_{V,m}^* = \\frac{\\text{Var}(\\{E_j^*\\})}{k_B T^2}$。\n4.  这个过程产生了由 $B$ 个估计值组成的 bootstrap 分布 $\\{\\hat{C}_{V,m,1}^*, \\dots, \\hat{C}_{V,m,B}^*\\}$。\n\n从这个 bootstrap 分布中，我们计算标准误和置信区间。这些公式必须考虑到原始估计（样本大小为 $n$）和 bootstrap 重复（样本大小为 $m$）之间样本大小的差异。\n\n-   **Bootstrap 标准误：** bootstrap 分布的标准差 $\\text{std}(\\{\\hat{C}_{V,m,i}^*\\})$, 是基于大小为 $m$ 的样本的估计量的标准误的估计值。为了估计基于大小为 $n$ 的原始估计量的标准误，需要一个缩放因子。假设估计量的方差与 $1/(\\text{样本大小})$ 成比例，则标准误与 $1/\\sqrt{\\text{样本大小}}$ 成比例。因此，$\\hat{C}_{V,n}$ 的估计标准误是：\n    $$\n    \\widehat{\\text{SE}}(\\hat{C}_{V,n}) = \\sqrt{\\frac{m}{n}} \\cdot \\text{std}(\\{\\hat{C}_{V,m,i}^*\\})\n    $$\n\n-   **百分位置信区间：**直接从 $\\{\\hat{C}_{V,m,i}^*\\}$ 的分位数构建的简单百分位区间是不正确的，因为它估计的是基于大小为 $m$ 而非 $n$ 的统计量的区间。对于 $m$-out-of-$n$ bootstrap，一种理论上合理的方法是使用适当缩放的枢轴量法。枢轴量 $\\sqrt{n}(\\hat{C}_{V,n} - C_V)$ 的分布可以通过 $\\sqrt{m}(\\hat{C}_{V,m}^* - \\hat{C}_{V,n})$ 的 bootstrap 分布来近似。\n    令 $q^*_{p}$ 表示 $\\{\\sqrt{m}(\\hat{C}_{V,m,i}^* - \\hat{C}_{V,n})\\}_{i=1}^B$ 经验分布的第 $p$ 分位数。那么 $C_V$ 的一个 $(1-\\gamma)$ 置信区间由下式给出：\n    $$\n    \\left[ \\hat{C}_{V,n} - \\frac{q^*_{1-\\gamma/2}}{\\sqrt{n}}, \\quad \\hat{C}_{V,n} - \\frac{q^*_{\\gamma/2}}{\\sqrt{n}} \\right]\n    $$\n    对于 $95\\%$ 的置信区间，$\\gamma = 0.05$，因此我们使用中心化和缩放后的 bootstrap 分布的第 $2.5$ 和第 $97.5$ 百分位数。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import pareto\n\ndef run_case(n, alpha, T, E0, sigma, p_tail, xm, nu, B, seed):\n    \"\"\"\n    Runs a single test case for heat capacity estimation and uncertainty quantification.\n\n    Args:\n        n (int): Total number of energy samples.\n        alpha (float): Exponent for determining m-out-of-n bootstrap sample size.\n        T (float): Temperature in Kelvin.\n        E0 (float): Baseline energy offset in Joules.\n        sigma (float): Gaussian fluctuation scale in Joules.\n        p_tail (float): Probability of a heavy-tailed jump.\n        xm (float): Pareto jump scale parameter in Joules.\n        nu (float): Pareto shape parameter.\n        B (int): Number of bootstrap replicates.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        tuple: A 4-element tuple containing:\n            - c_v_n (float): Heat capacity estimate from the full sample (J/K).\n            - se_c_v (float): Bootstrap standard error of the estimate (J/K).\n            - ci_low (float): Lower bound of the 95% confidence interval (J/K).\n            - ci_high (float): Upper bound of the 95% confidence interval (J/K).\n    \"\"\"\n    # Boltzmann constant in J/K\n    K_B = 1.380649e-23\n\n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # 1. Generate synthetic heavy-tailed energy samples\n    gauss_fluct = rng.normal(0.0, sigma, n)\n    jump_indicator = rng.binomial(1, p_tail, n)\n    pareto_y = pareto.rvs(b=nu, size=n, random_state=rng)\n    pareto_jump = xm * (1.0 + pareto_y)\n    \n    energies = E0 + gauss_fluct + jump_indicator * pareto_jump\n\n    # 2. Compute heat capacity estimator from the full sample of size n\n    # C_V = Var(E) / (k_B * T^2)\n    var_n = np.var(energies, ddof=0)\n    c_v_n = var_n / (K_B * T**2)\n    \n    # 3. Perform m-out-of-n bootstrap\n    m = int(np.floor(n**alpha))\n    bootstrap_estimates = np.zeros(B)\n    \n    # Generate all indices for bootstrap samples at once for efficiency\n    bootstrap_indices = rng.choice(n, size=(B, m), replace=True)\n    \n    # Use array operations to compute variances for all bootstrap samples\n    bootstrap_samples = energies[bootstrap_indices]\n    var_m_star = np.var(bootstrap_samples, axis=1, ddof=0)\n    \n    bootstrap_estimates = var_m_star / (K_B * T**2)\n\n    # 4. Compute bootstrap standard error and confidence interval\n    \n    # Bootstrap Standard Error\n    # SE(C_V_n) ≈ sqrt(m/n) * std(C_V_m*)\n    std_bootstrap_dist = np.std(bootstrap_estimates, ddof=1)\n    se_c_v = np.sqrt(m / n) * std_bootstrap_dist\n    \n    # Bootstrap Confidence Interval (scaled pivotal method)\n    # The interval for C_V is [C_V_n - q*_0.975/√n, C_V_n - q*_0.025/√n]\n    # where q* are quantiles of sqrt(m)(C_V_m* - C_V_n)\n    scaled_deltas = np.sqrt(m) * (bootstrap_estimates - c_v_n)\n    \n    # Quantiles at 2.5% and 97.5%\n    q_low_star = np.percentile(scaled_deltas, 2.5)\n    q_high_star = np.percentile(scaled_deltas, 97.5)\n    \n    # Confidence Interval\n    ci_low = c_v_n - q_high_star / np.sqrt(n)\n    ci_high = c_v_n - q_low_star / np.sqrt(n)\n    \n    return c_v_n, se_c_v, ci_low, ci_high\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: general heavy-tailed, finite variance\n        {'n': 1000, 'alpha': 0.7, 'T': 300.0, 'E0': 1.0e-19, 'sigma': 2.0e-21, \n         'p_tail': 0.02, 'xm': 3.0e-20, 'nu': 2.5, 'B': 1000, 'seed': 0},\n        # Case 2: strong heavy tail, infinite variance\n        {'n': 100, 'alpha': 0.5, 'T': 300.0, 'E0': 8.0e-20, 'sigma': 4.0e-21,\n         'p_tail': 0.05, 'xm': 1.0e-19, 'nu': 1.5, 'B': 1000, 'seed': 1},\n        # Case 3: large sample, mild heavy tail\n        {'n': 10000, 'alpha': 0.9, 'T': 300.0, 'E0': 1.2e-19, 'sigma': 2.0e-21,\n         'p_tail': 0.01, 'xm': 2.0e-20, 'nu': 3.0, 'B': 300, 'seed': 2},\n        # Case 4: small m boundary behavior\n        {'n': 500, 'alpha': 0.3, 'T': 350.0, 'E0': 1.0e-19, 'sigma': 1.5e-21,\n         'p_tail': 0.03, 'xm': 5.0e-20, 'nu': 2.0, 'B': 1000, 'seed': 3}\n    ]\n\n    results_str_list = []\n    for params in test_cases:\n        result = run_case(**params)\n        results_str_list.append(f\"[{result[0]},{result[1]},{result[2]},{result[3]}]\")\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```", "id": "3399551"}, {"introduction": "在实施了自助法之后，一个自然的实践问题是：需要多少次自助法重复（$B$）才能获得可靠的结果？使用过少的重复次数会引入其自身的误差来源（蒙特卡洛误差），从而影响我们对不确定性估计的信心。本练习提供了一个理论框架，通过推导自助法分位数标准误差的上界来选择 $B$ 的大小，确保我们的统计分析本身是稳健和精确的 [@problem_id:3399625]。", "problem": "对一个 Lennard-Jones 流体进行分子动力学 (MD) 模拟，模拟时间足够长，使得按非重叠时间块计算的摩尔势能的块平均值可以被视为近似独立同分布的。设这 $m$ 个块平均值表示为 $\\{X_{i}\\}_{i=1}^{m}$，单位为 $\\mathrm{kJ}\\ \\mathrm{mol}^{-1}$。为量化由有限抽样引起的平均势能估计的不确定性，我们采用非参数自助法 (nonparametric bootstrap)：从 $\\{X_{i}\\}_{i=1}^{m}$ 的经验分布中，生成 $B$ 个自助重抽样样本，并从每个重抽样样本中计算相应的统计量 $T^{*}$（重抽样均值）。将 $T^{*}$ 的自助分布表示为 $F^{*}$，将其 $\\alpha$-分位数表示为 $q_{\\alpha}^{*}$。\n\n关注在使用 $B$ 个自助法复制样本 $\\{T^{*}_{b}\\}_{b=1}^{B}$ 的经验 $\\alpha$-分位数 $\\hat{q}_{\\alpha}^{(B)}$ 来估计 $\\alpha$-分位数 $q_{\\alpha}^{*}$ 时，仅由有限的自助重抽样次数 $B$ 引起的蒙特卡洛误差。从经验累积分布函数 (CDF) 的定义和分位数作为 CDF 反函数的定义出发，仅使用关于指示随机变量的基本概率事实以及 CDF 在分位数处的微分性，推导 $\\hat{q}_{\\alpha}^{(B)}$ 的蒙特卡洛标准误差关于 $B$ 的上界。推导需基于以下正则性假设：自助分布具有密度函数 $f^{*}$，该函数在 $q_{\\alpha}^{*}$ 处连续，且在该点的下界为一个已知的正常数 $c0$，即 $f^{*}(q_{\\alpha}^{*}) \\ge c$。\n\n然后，对于上述特定的 MD 研究，假设一个具有非常大重抽样次数的引导性自助法和核密度估计表明，在 $\\alpha = 0.95$ 时，密度满足 $f^{*}(q_{0.95}^{*}) \\ge c$，其中 $c = 2.0 \\times 10^{-2}\\ (\\mathrm{kJ}\\ \\mathrm{mol}^{-1})^{-1}$。如果要求由有限 $B$ 引起的 $\\alpha$-分位数估计量的蒙特卡洛标准误差不大于 $\\delta = 0.20\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}$，请使用您推导出的上界来选择满足此要求的 $B$。\n\n- 以 $\\alpha$、$B$ 和 $c$ 的形式符号化地推导出该上界。\n- 然后计算保证蒙特卡洛标准误差上界最多为 $\\delta$ 的最小整数 $B$ 值。\n\n将最终答案表示为最小整数自助重抽样次数 $B$。最终答案中不应包含任何单位。", "solution": "该问题要求我们首先推导自助法分位数估计量的蒙特卡洛标准误差的上界，然后利用此上界确定达到所需精度水平所需的最小自助重抽样次数 $B$。\n\n设自助统计量 $T^{*}$ 的真实累积分布函数 (CDF) 为 $F^{*}(t) = P(T^{*} \\le t)$，其概率密度函数 (PDF) 为 $f^{*}(t) = (F^{*})'(t)$。真实的 $\\alpha$-分位数 $q_{\\alpha}^{*}$ 由关系式 $F^{*}(q_{\\alpha}^{*}) = \\alpha$ 定义。\n\n我们有一组 $B$ 个自助法复制样本 $\\{T^{*}_{b}\\}_{b=1}^{B}$，它们是从分布 $F^{*}$ 中抽取的独立同分布 (i.i.d.) 的随机变量。基于这些复制样本的经验 CDF 由下式给出：\n$$ \\hat{F}_{B}^{*}(t) = \\frac{1}{B} \\sum_{b=1}^{B} I(T^{*}_{b} \\le t) $$\n其中 $I(\\cdot)$ 是指示函数。经验 $\\alpha$-分位数 $\\hat{q}_{\\alpha}^{(B)}$ 是 $q_{\\alpha}^{*}$ 的估计量，定义为经验 CDF 的反函数：$\\hat{q}_{\\alpha}^{(B)} = (\\hat{F}_{B}^{*})^{-1}(\\alpha) = \\inf\\{t : \\hat{F}_{B}^{*}(t) \\ge \\alpha\\}$。\n\n我们的目标是求出蒙特卡洛标准误差 $\\mathrm{SE}(\\hat{q}_{\\alpha}^{(B)}) = \\sqrt{\\mathrm{Var}(\\hat{q}_{\\alpha}^{(B)})}$，其中方差是针对 $B$ 个自助法复制样本的分布计算的。\n\n推导的核心在于将分位数估计量 $\\hat{q}_{\\alpha}^{(B)}$ 的变异性与经验 CDF 估计量 $\\hat{F}_{B}^{*}(t)$ 的变异性联系起来。后者更易于分析。这种关系可以通过一阶近似来建立，该近似在 $f^{*}$ 于 $q_{\\alpha}^{*}$ 处连续且非零的假设下对大 $B$ 有效。这是样本分位数渐近理论中一个公认的结果（与 Bahadur 表示法相关）。该近似为：\n$$ \\hat{q}_{\\alpha}^{(B)} - q_{\\alpha}^{*} \\approx -\\frac{\\hat{F}_{B}^{*}(q_{\\alpha}^{*}) - F^{*}(q_{\\alpha}^{*})}{f^{*}(q_{\\alpha}^{*})} $$\n代入 $F^{*}(q_{\\alpha}^{*}) = \\alpha$，我们得到：\n$$ \\hat{q}_{\\alpha}^{(B)} \\approx q_{\\alpha}^{*} - \\frac{\\hat{F}_{B}^{*}(q_{\\alpha}^{*}) - \\alpha}{f^{*}(q_{\\alpha}^{*})} $$\n我们现在可以计算 $\\hat{q}_{\\alpha}^{(B)}$ 的方差。由于 $q_{\\alpha}^{*}$、$\\alpha$ 和 $f^{*}(q_{\\alpha}^{*})$ 对于蒙特卡洛抽样是常数（它们是真实的、潜在的自助分布 $F^{*}$ 的属性），该表达式的方差由 $\\hat{F}_{B}^{*}(q_{\\alpha}^{*})$ 的方差决定。\n$$ \\mathrm{Var}(\\hat{q}_{\\alpha}^{(B)}) \\approx \\mathrm{Var}\\left( q_{\\alpha}^{*} - \\frac{\\hat{F}_{B}^{*}(q_{\\alpha}^{*}) - \\alpha}{f^{*}(q_{\\alpha}^{*})} \\right) = \\mathrm{Var}\\left( - \\frac{\\hat{F}_{B}^{*}(q_{\\alpha}^{*})}{f^{*}(q_{\\alpha}^{*})} \\right) = \\frac{1}{[f^{*}(q_{\\alpha}^{*})]^2} \\mathrm{Var}(\\hat{F}_{B}^{*}(q_{\\alpha}^{*})) $$\n接下来，我们确定 $\\mathrm{Var}(\\hat{F}_{B}^{*}(q_{\\alpha}^{*}))$。项 $\\hat{F}_{B}^{*}(q_{\\alpha}^{*})$ 是 $B$ 个独立同分布的伯努利随机变量 $Y_b = I(T^{*}_{b} \\le q_{\\alpha}^{*})$ 的平均值。每次试验“成功”的概率为 $p = P(T^{*}_{b} \\le q_{\\alpha}^{*}) = F^{*}(q_{\\alpha}^{*}) = \\alpha$。单个伯努利($p$)随机变量的方差是 $p(1-p)$。\n$B$ 个这样的独立同分布变量的平均值的方差是单个变量方差的 $\\frac{1}{B}$ 倍：\n$$ \\mathrm{Var}(\\hat{F}_{B}^{*}(q_{\\alpha}^{*})) = \\mathrm{Var}\\left(\\frac{1}{B}\\sum_{b=1}^{B} Y_b\\right) = \\frac{1}{B^2} \\sum_{b=1}^{B} \\mathrm{Var}(Y_b) = \\frac{1}{B^2} (B \\cdot p(1-p)) = \\frac{p(1-p)}{B} $$\n代入 $p=\\alpha$，我们有：\n$$ \\mathrm{Var}(\\hat{F}_{B}^{*}(q_{\\alpha}^{*})) = \\frac{\\alpha(1-\\alpha)}{B} $$\n将此结果代回到分位数估计量的方差表达式中：\n$$ \\mathrm{Var}(\\hat{q}_{\\alpha}^{(B)}) \\approx \\frac{\\alpha(1-\\alpha)}{B [f^{*}(q_{\\alpha}^{*})]^2} $$\n蒙特卡洛标准误差是方差的平方根：\n$$ \\mathrm{SE}(\\hat{q}_{\\alpha}^{(B)}) = \\sqrt{\\mathrm{Var}(\\hat{q}_{\\alpha}^{(B)})} \\approx \\frac{\\sqrt{\\alpha(1-\\alpha)}}{\\sqrt{B} f^{*}(q_{\\alpha}^{*})} $$\n问题给出了正则性条件，即密度 $f^{*}(q_{\\alpha}^{*})$ 由一个已知的正常数 $c$ 作为下界，即 $f^{*}(q_{\\alpha}^{*}) \\ge c  0$。由于 $f^{*}(q_{\\alpha}^{*})$ 出现在分母中，这个下界使我们能够建立标准误差的上界：\n$$ \\mathrm{SE}(\\hat{q}_{\\alpha}^{(B)}) \\le \\frac{\\sqrt{\\alpha(1-\\alpha)}}{c\\sqrt{B}} $$\n这就是 $\\alpha$-分位数估计量的蒙特卡洛标准误差的符号化上界。\n\n现在，我们进行问题的数值计算部分。给定以下值：\n我们关心的分位数是 $\\alpha = 0.95$。\n密度的下界是 $c = 2.0 \\times 10^{-2}\\ (\\mathrm{kJ}\\ \\mathrm{mol}^{-1})^{-1}$。\n标准误差要求的上限是 $\\delta = 0.20\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}$。\n\n我们需要找到满足条件 $\\mathrm{SE}(\\hat{q}_{\\alpha}^{(B)}) \\le \\delta$ 的最小整数 $B$。为保证这一点，我们对推导出的上界施加此条件：\n$$ \\frac{\\sqrt{\\alpha(1-\\alpha)}}{c\\sqrt{B}} \\le \\delta $$\n我们对这个不等式求解 $B$。由于所有量都是正数，我们可以重新排列和平方而不改变不等式的方向。\n$$ \\sqrt{B} \\ge \\frac{\\sqrt{\\alpha(1-\\alpha)}}{c\\delta} $$\n$$ B \\ge \\frac{\\alpha(1-\\alpha)}{(c\\delta)^2} $$\n现在，我们代入数值：\n$$ \\alpha(1-\\alpha) = 0.95 \\times (1 - 0.95) = 0.95 \\times 0.05 = 0.0475 $$\n$$ c\\delta = (2.0 \\times 10^{-2}) \\times 0.20 = 0.02 \\times 0.2 = 0.004 = 4 \\times 10^{-3} $$\n$$ (c\\delta)^2 = (4 \\times 10^{-3})^2 = 16 \\times 10^{-6} = 1.6 \\times 10^{-5} $$\n将这些值代入关于 $B$ 的不等式中：\n$$ B \\ge \\frac{0.0475}{1.6 \\times 10^{-5}} = \\frac{4.75 \\times 10^{-2}}{1.6 \\times 10^{-5}} = \\frac{4.75}{1.6} \\times 10^3 = 2.96875 \\times 10^3 = 2968.75 $$\n由于自助重抽样次数 $B$ 必须是整数，我们必须取该值的向上取整 (ceiling) 以满足不等式。\n$$ B = \\lceil 2968.75 \\rceil = 2969 $$\n因此，为确保估计的 $0.95$-分位数的蒙特卡洛标准误差不超过 $0.20\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}$ 所需的最小整数自助重抽样次数为 $2969$。", "answer": "$$ \\boxed{2969} $$", "id": "3399625"}]}