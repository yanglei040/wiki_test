{"hands_on_practices": [{"introduction": "模型参数化的选择会显著影响正演问题的性态，尤其是在反演中。本练习通过一个简化的一维声学问题，分析性地比较了两种常见的参数化方式——体积模量 $K$ 和压缩率 $\\kappa = 1/K$。我们将探讨哪种参数化能使模型与数据之间的关系“更线性”，这对于反演算法的收敛性至关重要 [@problem_id:3616719]。", "problem": "考虑在一维均匀、各向同性介质中的声波传播，该介质具有恒定的质量密度 $\\rho_0$ 和体积模量 $K_0$。在角频率为 $\\omega$ 的频域中，标量压力场 $p(x;\\theta)$ 满足亥姆霍兹型方程 $p''(x) + k^2(\\theta)\\,p(x) = 0$，其中 $k(\\theta)$ 是用模型参数 $\\theta$ 表示的波数。对于压缩率参数化，$\\theta=\\kappa$ 且 $\\kappa=1/K$，波数为 $k(\\kappa)=\\omega\\sqrt{\\rho_0\\,\\kappa}$；对于体积模量参数化，$\\theta=K$，波数为 $k(K)=\\omega\\sqrt{\\rho_0/K}$。一个单位振幅的右行平面波在 $x=0$ 处入射，正演数据是在 $x=L>0$ 处的复压力，即 $d(\\theta)=p(L;\\theta)=\\exp\\!\\big(i\\,k(\\theta)\\,L\\big)$。\n\n定义在背景值 $\\theta_0$ 处、振幅为 $\\varepsilon$ 的等比例扰动下，参数化 $\\theta$ 的“二阶玻恩度量”为\n$$\nM_{\\theta} \\equiv \\left|\\frac{\\frac{1}{2}\\,d''(\\theta_0)\\,\\big(\\delta\\theta\\big)^2}{d'(\\theta_0)\\,\\delta\\theta}\\right|, \\quad \\delta\\theta=\\varepsilon\\,\\theta_0,\\quad 0<\\varepsilon\\ll 1,\n$$\n其中 $d'(\\theta_0)$ 和 $d''(\\theta_0)$ 是 $d(\\theta)$ 关于 $\\theta$ 在 $\\theta=\\theta_0$ 处求得的一阶和二阶导数。对于给定的参数化，在相同的比例扰动下，该度量量化了二阶玻恩项相对于一阶玻恩项的大小。\n\n使用 $K_0$ 和 $\\kappa_0=1/K_0$ 作为两种参数化的背景值，推导比率\n$$\n\\mathcal{R} \\equiv \\frac{M_{K}}{M_{\\kappa}}\n$$\n的闭式表达式，用 $L$、$\\omega$、$\\rho_0$ 和 $K_0$ 表示。将你的最终答案表示为单个解析表达式。不需要进行数值计算或四舍五入，最终表达式中不应出现物理单位。", "solution": "用户提供了一个有效的问题陈述。\n\n**1. 问题验证**\n\n**第1步：提取已知条件**\n-   控制方程: $p''(x) + k^2(\\theta)\\,p(x) = 0$\n-   介质属性: 恒定质量密度 $\\rho_0$，恒定体积模量 $K_0$。\n-   压缩率参数化: $\\theta=\\kappa=1/K$，波数为 $k(\\kappa)=\\omega\\sqrt{\\rho_0\\,\\kappa}$。\n-   体积模量参数化: $\\theta=K$，波数为 $k(K)=\\omega\\sqrt{\\rho_0/K}$。\n-   正演数据: $d(\\theta)=p(L;\\theta)=\\exp(i\\,k(\\theta)\\,L)$，其中 $L>0$。\n-   二阶玻恩度量: $M_{\\theta} \\equiv \\left|\\frac{\\frac{1}{2}\\,d''(\\theta_0)\\,\\big(\\delta\\theta\\big)^2}{d'(\\theta_0)\\,\\delta\\theta}\\right|$。\n-   扰动: $\\delta\\theta=\\varepsilon\\,\\theta_0$，其中 $0<\\varepsilon\\ll 1$。\n-   背景值: $K$参数化为 $\\theta_0=K_0$；$\\kappa$参数化为 $\\theta_0=\\kappa_0=1/K_0$。\n-   目标: 推导比率 $\\mathcal{R} \\equiv \\frac{M_{K}}{M_{\\kappa}}$ 的表达式，用 $L$、$\\omega$、$\\rho_0$ 和 $K_0$ 表示。\n\n**第2步：使用提取的已知条件进行验证**\n-   **科学基础：** 问题使用标准的一维声波方程（亥姆霍兹形式）以及波数和材料属性（$K$、$\\kappa$、$\\rho_0$）的正确物理定义。通过泰勒级数展开（在玻恩近似背景下）分析模型参数化是计算地球物理学和反演理论中的一种标准技术。该问题在根本上是合理的。\n-   **适定性：** 提供了推导所要求的比率所需的所有必要定义、方程和变量。任务是具体的，并能导出一个唯一的解析解。\n-   **客观性：** 问题以精确的数学和物理术语陈述，没有主观性或模糊性。\n\n**第3步：结论与行动**\n该问题被认为是有效的，因为其具有科学基础、适定性和客观性。我将继续进行求解。\n\n**2. 解题推导**\n\n目标是计算比率 $\\mathcal{R} = M_K / M_\\kappa$。首先，我们简化度量 $M_\\theta$ 的表达式。\n$$\nM_{\\theta} \\equiv \\left|\\frac{\\frac{1}{2}\\,d''(\\theta_0)\\,\\big(\\delta\\theta\\big)^2}{d'(\\theta_0)\\,\\delta\\theta}\\right| = \\left|\\frac{1}{2}\\frac{d''(\\theta_0)}{d'(\\theta_0)}\\delta\\theta\\right|\n$$\n代入 $\\delta\\theta=\\varepsilon\\,\\theta_0$，我们得到：\n$$\nM_{\\theta} = \\frac{\\varepsilon\\,\\theta_0}{2} \\left| \\frac{d''(\\theta_0)}{d'(\\theta_0)} \\right|\n$$\n计算的核心涉及数据函数 $d(\\theta) = \\exp(i\\,k(\\theta)\\,L)$ 的二阶和一阶导数之比。我们首先一般性地计算这些导数。\n使用链式法则：\n$$\nd'(\\theta) = \\frac{d}{d\\theta}\\exp(i\\,k(\\theta)\\,L) = i\\,L\\,k'(\\theta)\\,\\exp(i\\,k(\\theta)\\,L)\n$$\n使用乘积法则进行二次求导：\n\\begin{align*}\nd''(\\theta) = \\frac{d}{d\\theta} \\left[ i\\,L\\,k'(\\theta)\\,\\exp(i\\,k(\\theta)\\,L) \\right] \\\\\n= i\\,L\\,k''(\\theta)\\,\\exp(i\\,k(\\theta)\\,L) + i\\,L\\,k'(\\theta) \\left[ i\\,L\\,k'(\\theta)\\,\\exp(i\\,k(\\theta)\\,L) \\right] \\\\\n= \\left[ i\\,L\\,k''(\\theta) + (i\\,L\\,k'(\\theta))^2 \\right] \\exp(i\\,k(\\theta)\\,L) \\\\\n= \\left[ i\\,L\\,k''(\\theta) - L^2(k'(\\theta))^2 \\right] \\exp(i\\,k(\\theta)\\,L)\n\\end{align*}\n导数之比为：\n$$\n\\frac{d''(\\theta)}{d'(\\theta)} = \\frac{\\left[ i\\,L\\,k''(\\theta) - L^2(k'(\\theta))^2 \\right] \\exp(i\\,k(\\theta)\\,L)}{i\\,L\\,k'(\\theta)\\,\\exp(i\\,k(\\theta)\\,L)} = \\frac{k''(\\theta)}{k'(\\theta)} - \\frac{L\\,k'(\\theta)}{i} = \\frac{k''(\\theta)}{k'(\\theta)} + i\\,L\\,k'(\\theta)\n$$\n这个通用表达式将针对每种参数化在其背景值处进行求值。令 $k_0 = \\omega\\sqrt{\\rho_0/K_0} = \\omega\\sqrt{\\rho_0\\kappa_0}$ 为背景波数。\n\n**体积模量参数化 ($\\theta = K$)**\n这里，$\\theta_0=K_0$。波数为 $k(K) = \\omega\\sqrt{\\rho_0} K^{-1/2}$。\n关于 $K$ 的导数是：\n$$\nk'(K) = \\omega\\sqrt{\\rho_0} \\left(-\\frac{1}{2}\\right) K^{-3/2} = -\\frac{1}{2K} \\left(\\omega\\sqrt{\\rho_0} K^{-1/2}\\right) = -\\frac{k(K)}{2K}\n$$\n$$\nk''(K) = \\omega\\sqrt{\\rho_0} \\left(-\\frac{1}{2}\\right) \\left(-\\frac{3}{2}\\right) K^{-5/2} = \\frac{3}{4} \\omega\\sqrt{\\rho_0} K^{-5/2}\n$$\n在背景值 $K_0$ 处：\n$$\nk'(K_0) = -\\frac{k_0}{2K_0}\n$$\n波数导数之比为：\n$$\n\\frac{k''(K_0)}{k'(K_0)} = \\frac{\\frac{3}{4}\\omega\\sqrt{\\rho_0}K_0^{-5/2}}{-\\frac{1}{2}\\omega\\sqrt{\\rho_0}K_0^{-3/2}} = -\\frac{3}{2}K_0^{-1} = -\\frac{3}{2K_0}\n$$\n代入数据导数之比的通用表达式中：\n$$\n\\left.\\frac{d''(K)}{d'(K)}\\right|_{K_0} = \\frac{k''(K_0)}{k'(K_0)} + i\\,L\\,k'(K_0) = -\\frac{3}{2K_0} + i\\,L\\left(-\\frac{k_0}{2K_0}\\right) = -\\frac{1}{2K_0}(3 + i\\,L\\,k_0)\n$$\n现在我们计算度量 $M_K$：\n$$\nM_K = \\frac{\\varepsilon\\,K_0}{2} \\left| -\\frac{1}{2K_0}(3 + i\\,L\\,k_0) \\right| = \\frac{\\varepsilon\\,K_0}{4K_0} |3 + i\\,L\\,k_0| = \\frac{\\varepsilon}{4}\\sqrt{3^2 + (L\\,k_0)^2} = \\frac{\\varepsilon}{4}\\sqrt{9 + (L\\,k_0)^2}\n$$\n\n**压缩率参数化 ($\\theta = \\kappa$)**\n这里，$\\theta_0 = \\kappa_0 = 1/K_0$。波数为 $k(\\kappa) = \\omega\\sqrt{\\rho_0} \\kappa^{1/2}$。\n关于 $\\kappa$ 的导数是：\n$$\nk'(\\kappa) = \\omega\\sqrt{\\rho_0}\\left(\\frac{1}{2}\\right)\\kappa^{-1/2} = \\frac{1}{2\\kappa}\\left(\\omega\\sqrt{\\rho_0}\\kappa^{1/2}\\right) = \\frac{k(\\kappa)}{2\\kappa}\n$$\n$$\nk''(\\kappa) = \\omega\\sqrt{\\rho_0}\\left(\\frac{1}{2}\\right)\\left(-\\frac{1}{2}\\right)\\kappa^{-3/2} = -\\frac{1}{4}\\omega\\sqrt{\\rho_0}\\kappa^{-3/2}\n$$\n在背景值 $\\kappa_0$ 处：\n$$\nk'(\\kappa_0) = \\frac{k_0}{2\\kappa_0}\n$$\n波数导数之比为：\n$$\n\\frac{k''(\\kappa_0)}{k'(\\kappa_0)} = \\frac{-\\frac{1}{4}\\omega\\sqrt{\\rho_0}\\kappa_0^{-3/2}}{\\frac{1}{2}\\omega\\sqrt{\\rho_0}\\kappa_0^{-1/2}} = -\\frac{1}{2}\\kappa_0^{-1} = -\\frac{1}{2\\kappa_0}\n$$\n代入数据导数之比的通用表达式中：\n$$\n\\left.\\frac{d''(\\kappa)}{d'(\\kappa)}\\right|_{\\kappa_0} = \\frac{k''(\\kappa_0)}{k'(\\kappa_0)} + i\\,L\\,k'(\\kappa_0) = -\\frac{1}{2\\kappa_0} + i\\,L\\left(\\frac{k_0}{2\\kappa_0}\\right) = \\frac{1}{2\\kappa_0}(-1 + i\\,L\\,k_0)\n$$\n现在我们计算度量 $M_\\kappa$：\n$$\nM_\\kappa = \\frac{\\varepsilon\\,\\kappa_0}{2}\\left|\\frac{1}{2\\kappa_0}(-1 + i\\,L\\,k_0)\\right| = \\frac{\\varepsilon\\,\\kappa_0}{4\\kappa_0}|-1 + i\\,L\\,k_0| = \\frac{\\varepsilon}{4}\\sqrt{(-1)^2+(L\\,k_0)^2} = \\frac{\\varepsilon}{4}\\sqrt{1 + (L\\,k_0)^2}\n$$\n\n**最终比率计算**\n最后，我们计算比率 $\\mathcal{R} = M_K/M_\\kappa$：\n$$\n\\mathcal{R} = \\frac{M_K}{M_\\kappa} = \\frac{\\frac{\\varepsilon}{4}\\sqrt{9 + (L\\,k_0)^2}}{\\frac{\\varepsilon}{4}\\sqrt{1 + (L\\,k_0)^2}} = \\sqrt{\\frac{9 + (L\\,k_0)^2}{1 + (L\\,k_0)^2}}\n$$\n问题要求答案用 $L$、$\\omega$、$\\rho_0$ 和 $K_0$ 表示。我们代入背景波数的平方表达式，$(k_0)^2 = \\omega^2 \\rho_0/K_0$。\n$$\n\\mathcal{R} = \\sqrt{\\frac{9 + L^2 \\omega^2 \\frac{\\rho_0}{K_0}}{1 + L^2 \\omega^2 \\frac{\\rho_0}{K_0}}}\n$$\n这就是该比率的最终闭式表达式。", "answer": "$$\\boxed{\\sqrt{\\frac{9 + L^2 \\omega^2 \\frac{\\rho_0}{K_0}}{1 + L^2 \\omega^2 \\frac{\\rho_0}{K_0}}}}$$", "id": "3616719"}, {"introduction": "本练习将理论与计算相结合，要求您为一维波动方程实现一个时域有限差分模型。练习的重点是推导并数值验证Fréchet导数，它量化了波场对波速模型变化的敏感度。通过这个练习，您将学会如何为不同的参数化（例如 $c$ 与 $\\log c$）计算这些敏感度，并使用数值有限差分来验证解析结果的正确性，这是模型开发中的一项关键技能 [@problem_id:3616640]。", "problem": "考虑空间区间 $[0,L]$ 上的一维声波方程 $u_{tt}(x,t) = c^2(x)\\,u_{xx}(x,t) + s(x,t)$，其边界条件为齐次狄利克雷边界条件 $u(0,t)=u(L,t)=0$，初始条件为 $u(x,0)=0$ 和 $u_t(x,0)=0$。此处，$u(x,t)$ 是位移场，$c(x)$ 是空间变化的波速，$s(x,t)$ 是给定的源项。所有量都已无量纲化，三角函数使用弧度。\n\n任务 A（离散化）：从时间二阶导数和空间二阶导数的中心有限差分定义出发，推导用于在时间上将 $u^n$推进到 $u^{n+1}$ 的内部网格点的显式蛙跳格式更新。其中，空间网格使用 $N$ 个均匀间隔点 $x_i = i\\,\\Delta x$（$i=0,1,\\dots,N-1$，$\\Delta x = L/(N-1)$），时间网格使用时间步长 $\\Delta t$，$u_i^n \\approx u(x_i, n\\,\\Delta t)$。对所有 $n$，强制施加边界条件 $u_0^n = u_{N-1}^n = 0$。清晰地标示出近似 $u_{xx}$ 的离散算子，并精确说明模型参数化 $c(x)$ 是如何进入方程 $u_{tt}=c^2(x)\\,u_{xx}+s(x,t)$ 的离散算子的。\n\n任务 B（模型参数化与敏感度）：令 $S$ 表示应用于网格函数的离散空间二阶导数算子（标准的中心二阶有限差分格式），令 $C(c)$ 表示对角线元素为 $c_i^2$ 的对角算子。在固定的 $u^{n}$ 和 $u^{n-1}$ 以及固定的 $s^n = s(\\cdot, n\\,\\Delta t)$ 条件下，考虑单步显式更新映射 $F(c): u^n \\mapsto u^{n+1}$。使用链式法则，推导在两种情况下 $F$ 相对于模型参数化的 Fréchet 导数：(i) 直接以 $c$ 进行参数化（模型向量为 $p=c$），以及 (ii) 以 $m=\\log c$ 进行参数化（$c_i=\\exp(m_i)$）。将单个网格索引 $j$ 的方向导数 $\\partial u^{n+1}/\\partial c_j$ 和 $\\partial u^{n+1}/\\partial m_j$ 用 $u^n$、$S u^n$ 和 $c_j$ 表示。\n\n数值实验与测试套件：实现推导出的格式和敏感度，以通过有限差分来验证解析 Fréchet 导数。使用以下参数值和程序。\n\n- 空间域长度：$L = 1$。\n- 网格点数：$N = 201$。\n- 空间步长：$\\Delta x = L/(N-1)$。\n- 非均匀波速：$c(x) = c_0 \\left(1 + a \\sin\\!\\left(2\\pi x/L\\right)\\right)$，其中 $c_0=1$，$a=0.2$。为每个网格节点计算 $c_i = c(x_i)$。\n- 时间步长：选择 $\\Delta t = 0.9\\,\\Delta x / \\max_i c_i$，以保守地满足显式格式的 Courant–Friedrichs–Lewy (CFL) 稳定性条件。\n- 源：位于网格索引 $i_s = \\lfloor 0.3\\,(N-1)\\rfloor$ 的点状 Ricker 子波，即如果 $i=i_s$，则 $s_i^n = r(n\\,\\Delta t)$，否则 $s_i^n = 0$。其中 $r(t) = \\left(1 - 2(\\pi f_0 (t-t_0))^2\\right)\\exp\\!\\left(-(\\pi f_0 (t-t_0))^2\\right)$，中心频率 $f_0=5$，时间偏移 $t_0 = 3/f_0$。\n- 时间步进：使用任务 A 中推导的显式更新，将解从 $t=0$ 推进到 $t = K\\,\\Delta t$，共 $K=100$ 步。这将生成一对 $(u^{K-1}, u^K)$，用于下一步的敏感度检查。\n- 在时间索引 $n=K$ 处，使用 $u^K$、$u^{K-1}$、$c$ 和 $s^K$ 构成单步更新 $u^{K+1}$，并利用任务 B 的结果计算在指定索引处模型相关的解析 Fréchet 导数向量。\n- 有限差分验证：对于小扰动 $\\varepsilon = 10^{-6}$，通过扰动单个索引处的模型并重新计算单步更新 $u^{K+1}$（所有其他项保持不变），来构造敏感度的有限差分近似。\n\n定义以下三个测试用例，以评估实现的不同方面。\n\n- 测试用例 1（内部点，直接 $c$ 参数化）：索引 $j_1 = \\lfloor N/2 \\rfloor$。计算解析导数向量 $\\partial u^{K+1}/\\partial c_{j_1}$ 与仅对 $c_{j_1}$ 施加 $+\\varepsilon$ 扰动得到的有限差分近似之间的相对 2-范数误差。\n- 测试用例 2（边界邻近点，直接 $c$ 参数化）：索引 $j_2 = 1$（边界旁的第一个内部节点）。计算与测试用例 1 类似的相对 2-范数误差，但针对 $j_2$。\n- 测试用例 3（内部点，对数参数化 $m=\\log c$）：索引 $j_3 = \\lfloor N/3 \\rfloor$。计算解析导数向量 $\\partial u^{K+1}/\\partial m_{j_3}$ 与仅对 $m_{j_3}$ 施加 $+\\varepsilon$ 扰动并通过 $c_i=\\exp(m_i)$ 映射回得到的有限差分近似之间的相对 2-范数误差。\n\n所有计算均在无量纲单位下进行。正弦函数和 Ricker 函数中的角度使用弧度。\n\n输出规格：您的程序应生成单行输出，其中包含三个测试用例的三个相对误差，格式为方括号内以逗号分隔的列表，顺序为 $[\\text{error}_1,\\text{error}_2,\\text{error}_3]$。每个条目必须是一个浮点数。", "solution": "该问题要求推导并验证一维声波方程的数值格式，以及其相对于模型参数的敏感度。验证过程分两个阶段进行：理论推导，然后是数值实现与验证。\n\n### 问题验证\n解析问题陈述并根据指定标准进行验证。\n\n**已知条件：**\n- **偏微分方程 (PDE)**：在 $x \\in [0,L]$ 上的 $u_{tt}(x,t) = c^2(x)\\,u_{xx}(x,t) + s(x,t)$。\n- **边界条件**：$u(0,t)=u(L,t)=0$（齐次狄利克雷边界条件）。\n- **初始条件**：$u(x,0)=0, u_t(x,0)=0$。\n- **离散化**：在均匀网格 $x_i=i\\,\\Delta x$, $i=0,\\dots,N-1$ 上使用有限差分，其中 $\\Delta x=L/(N-1)$。时间步长为 $\\Delta t$。\n- **数值参数**：$L=1$, $N=201$, $K=100$。\n- **波速**：$c(x) = c_0 (1 + a \\sin(2\\pi x/L))$，其中 $c_0=1, a=0.2$。\n- **时间步长**：$\\Delta t = 0.9\\,\\Delta x / \\max_i c_i$。\n- **源**：Ricker 子波 $r(t) = (1 - 2(\\pi f_0 (t-t_0))^2)\\exp(-(\\pi f_0 (t-t_0))^2)$，其中 $f_0=5, t_0=3/f_0$，应用于 $x_{i_s}$ 处，其中 $i_s = \\lfloor 0.3(N-1)\\rfloor$。\n- **敏感度分析**：在时间步长 $n=K$ 时，针对扰动 $\\varepsilon=10^{-6}$，将解析 Fréchet 导数与有限差分近似进行对比检查。\n- **测试用例**：相对 $L_2$-范数误差：(1) 在 $j = \\lfloor N/2 \\rfloor$ 处的 $\\partial u^{K+1}/\\partial c_j$；(2) 在 $j = 1$ 处的 $\\partial u^{K+1}/\\partial c_j$；(3) 在 $j = \\lfloor N/3 \\rfloor$ 处的 $\\partial u^{K+1}/\\partial m_j$（其中 $m=\\log c$）。\n\n**结论：**\n该问题是**有效的**。这是一个来自计算地球物理学的适定的、有科学依据的问题。物理模型、数值方法和验证程序都是标准的且明确规定。所有必需的参数和条件都已提供，没有矛盾或模糊之处。\n\n### 任务 A：离散化\n\n一维声波方程由下式给出\n$$ u_{tt}(x,t) = c^2(x)\\,u_{xx}(x,t) + s(x,t) $$\n我们在具有空间点 $x_i = i\\,\\Delta x$ 和时间点 $t_n = n\\,\\Delta t$ 的网格上离散化此方程。位移场近似为 $u_i^n \\approx u(x_i, t_n)$。\n\n时间二阶导数 $u_{tt}$ 在时间 $t_n$ 处使用二阶中心有限差分进行近似：\n$$ u_{tt}(x_i, t_n) \\approx \\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{(\\Delta t)^2} $$\n空间二阶导数 $u_{xx}$ 在位置 $x_i$ 处使用二阶中心有限差分进行近似：\n$$ u_{xx}(x_i, t_n) \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2} $$\n这定义了离散空间导数算子 $S$ 在网格函数 $u^n$ 上的作用：\n$$ (S u^n)_i = \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2} $$\n将这些近似代入偏微分方程，我们得到每个内部网格点 $i \\in \\{1, \\dots, N-2\\}$ 的离散方程：\n$$ \\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{(\\Delta t)^2} = c(x_i)^2 (S u^n)_i + s(x_i, t_n) $$\n令 $c_i=c(x_i)$ 和 $s_i^n=s(x_i,t_n)$，我们可以重新整理此式以求解 $u_i^{n+1}$，从而得到显式蛙跳格式更新法则：\n$$ u_i^{n+1} = 2u_i^n - u_i^{n-1} + (\\Delta t)^2 \\left( c_i^2 (S u^n)_i + s_i^n \\right) $$\n齐次狄利克雷边界条件 $u(0,t)=u(L,t)=0$ 通过在所有时间步 $n$ 设置 $u_0^n=0$ 和 $u_{N-1}^n=0$ 来强制施加。这些条件自然地被整合到计算邻近边界的点（例如，对于 $i=1$，$u_0^n$ 被使用）的 $(S u^n)_i$ 中。\n\n模型参数化 $c(x)$ 在每个网格点 $x_i$ 处被求值，形成速度向量 $c_i$，然后进入离散系统。在更新方程中，速度的平方 $c_i^2$ 作为标量乘数作用于离散空间拉普拉斯向量 $(S u^n)_i$ 的相应分量。在矩阵向量表示法中，如果我们考虑内部网格点的向量，该项为 $(\\Delta t)^2 C (S u^n)$，其中 $C$ 是一个对角矩阵，其元素为 $c_i^2$。\n\n### 任务 B：模型参数化与敏感度\n\n单步更新映射 $F$ 将状态 $(u^n, u^{n-1})$ 变换到 $u^{n+1}$，并依赖于模型参数（速度向量 $c$）。对于固定的状态和源，我们分析下一状态 $u^{n+1}$ 对模型扰动的敏感度。解向量的第 $i$ 个分量的更新为：\n$$ u_i^{n+1} = F_i(c; u^n, u^{n-1}, s^n) = 2u_i^n - u_i^{n-1} + (\\Delta t)^2 c_i^2 (S u^n)_i + (\\Delta t)^2 s_i^n $$\n项 $u^n$、$u^{n-1}$ 和 $s^n$ 保持不变。向量 $u^{n+1}$ 关于单个模型参数的 Fréchet 导数是一个向量，其分量是每个 $u_i^{n+1}$ 关于该参数的偏导数。\n\n**(i) 直接参数化, $p=c$:**\n我们寻求向量 $u^{n+1}$ 关于参数 $c_j$ 的导数。该导数向量的第 $i$ 个分量是 $\\partial u_i^{n+1} / \\partial c_j$。\n$$ \\frac{\\partial u_i^{n+1}}{\\partial c_j} = \\frac{\\partial}{\\partial c_j} \\left[ 2u_i^n - u_i^{n-1} + (\\Delta t)^2 c_i^2 (S u^n)_i + (\\Delta t)^2 s_i^n \\right] $$\n只有包含 $c_i^2$ 的项依赖于模型。利用偏导数的性质：\n$$ \\frac{\\partial u_i^{n+1}}{\\partial c_j} = (\\Delta t)^2 (S u^n)_i \\frac{\\partial (c_i^2)}{\\partial c_j} = (\\Delta t)^2 (S u^n)_i \\cdot (2 c_i \\delta_{ij}) $$\n其中 $\\delta_{ij}$ 是克罗内克 δ (Kronecker delta)。这表明向量 $\\partial u^{n+1}/\\partial c_j$ 除了索引 $i=j$ 处外，处处为零。非零分量是：\n$$ \\left(\\frac{\\partial u^{n+1}}{\\partial c_j}\\right)_j = 2 (\\Delta t)^2 c_j (S u^n)_j $$\n\n**(ii) 对数参数化, $m=\\log c$ (即, $c_i=\\exp(m_i)$):**\n我们寻求 $u^{n+1}$ 关于参数 $m_j$ 的导数。使用链式法则：\n$$ \\frac{\\partial u_i^{n+1}}{\\partial m_j} = \\frac{\\partial}{\\partial m_j} \\left[ (\\Delta t)^2 c_i^2 (S u^n)_i \\right] = (\\Delta t)^2 (S u^n)_i \\frac{\\partial (c_i^2)}{\\partial m_j} $$\n我们计算 $c_i^2$ 关于 $m_j$ 的导数：\n$$ \\frac{\\partial (c_i^2)}{\\partial m_j} = 2 c_i \\frac{\\partial c_i}{\\partial m_j} = 2 c_i \\frac{\\partial (\\exp(m_i))}{\\partial m_j} = 2 c_i (\\exp(m_i) \\delta_{ij}) = 2 c_i^2 \\delta_{ij} $$\n将其代回，我们发现导数向量 $\\partial u^{n+1}/\\partial m_j$ 同样仅在索引 $i=j$ 处非零。非零分量是：\n$$ \\left(\\frac{\\partial u^{n+1}}{\\partial m_j}\\right)_j = 2 (\\Delta t)^2 c_j^2 (S u^n)_j $$\n这些解析表达式用于在数值实验中与有限差分近似进行对比验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the full numerical experiment to derive and verify sensitivities\n    for the 1D acoustic wave equation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Parameter set 1): Handled by j1\n        # (Parameter set 2): Handled by j2\n        # (Parameter set 3): Handled by j3\n    ]\n\n    # --- Setup Constants and Grid ---\n    L = 1.0\n    N = 201\n    K = 100\n    epsilon = 1e-6\n    c0 = 1.0\n    a = 0.2\n    f0 = 5.0\n    t0 = 3.0 / f0\n\n    # Grid setup\n    dx = L / (N - 1)\n    x = np.linspace(0, L, N)\n    \n    # --- Define Model and Source ---\n    # Model parameterization (heterogeneous wave speed)\n    c = c0 * (1.0 + a * np.sin(2.0 * np.pi * x / L))\n    \n    # Time step from CFL condition\n    dt = 0.9 * dx / np.max(c)\n\n    # Source setup\n    # Note: problem statement floor can be achieved with integer division //\n    i_s = (3 * (N - 1)) // 10\n    \n    def ricker(t, f0, t0):\n        # Ricker wavelet function\n        arg = (np.pi * f0 * (t - t0))**2\n        return (1.0 - 2.0 * arg) * np.exp(-arg)\n\n    # Source time function\n    time_vec = np.arange(K + 2) * dt # Need up to K+1 for s_K\n    stf = ricker(time_vec, f0, t0)\n    \n    # --- Implement Forward Simulation ---\n    # Initialize wavefields\n    u_past = np.zeros(N)  # u^{n-1}\n    u_now = np.zeros(N)   # u^n\n    \n    # Special first time step (n=0) based on u_t(x,0)=0\n    # u^1 = 0.5 * dt^2 * s^0\n    s0 = np.zeros(N)\n    s0[i_s] = stf[0]\n    u_now = 0.5 * dt**2 * s0  # u_now is now u^1\n    # u_past remains u^0 = 0\n    \n    # Main time-stepping loop for n from 1 to K-1\n    for n in range(1, K):\n        S_u_now = np.zeros(N)\n        S_u_now[1:-1] = (u_now[2:] - 2.0 * u_now[1:-1] + u_now[:-2]) / dx**2\n        \n        u_fut = np.zeros(N)\n        u_fut[1:-1] = 2.0 * u_now[1:-1] - u_past[1:-1] + dt**2 * c[1:-1]**2 * S_u_now[1:-1]\n        \n        u_fut[i_s] += dt**2 * stf[n]\n\n        u_past, u_now = u_now, u_fut\n\n    # State for sensitivity analysis: u_K = u_now, u_K_minus_1 = u_past\n    u_K = u_now\n    u_K_minus_1 = u_past\n    \n    # --- Sensitivity Analysis at n=K ---\n    def one_step_update(u_n, u_n_minus_1, c_vec, s_n_scalar):\n        u_n_plus_1 = np.zeros_like(u_n)\n        S_u_n = np.zeros_like(u_n)\n        S_u_n[1:-1] = (u_n[2:] - 2.0 * u_n[1:-1] + u_n[:-2]) / dx**2\n        \n        u_n_plus_1[1:-1] = 2.0 * u_n[1:-1] - u_n_minus_1[1:-1] + \\\n                           dt**2 * c_vec[1:-1]**2 * S_u_n[1:-1]\n        \n        u_n_plus_1[i_s] += dt**2 * s_n_scalar\n        return u_n_plus_1\n\n    u_K_plus_1_base = one_step_update(u_K, u_K_minus_1, c, stf[K])\n    \n    S_u_K = np.zeros(N)\n    S_u_K[1:-1] = (u_K[2:] - 2.0 * u_K[1:-1] + u_K[:-2]) / dx**2\n    \n    results = []\n    \n    # --- Test Case 1 ---\n    j1 = N // 2\n    grad_c1_analytic = np.zeros(N)\n    grad_c1_analytic[j1] = 2.0 * dt**2 * c[j1] * S_u_K[j1]\n    \n    c_perturbed = c.copy()\n    c_perturbed[j1] += epsilon\n    u_K_plus_1_pert_c1 = one_step_update(u_K, u_K_minus_1, c_perturbed, stf[K])\n    grad_c1_fd = (u_K_plus_1_pert_c1 - u_K_plus_1_base) / epsilon\n    \n    norm_analytic_1 = np.linalg.norm(grad_c1_analytic)\n    if norm_analytic_1  1e-15:\n        error1 = 0.0 if np.linalg.norm(grad_c1_fd)  1e-15 else float('inf')\n    else:\n        error1 = np.linalg.norm(grad_c1_analytic - grad_c1_fd) / norm_analytic_1\n    results.append(error1)\n    \n    # --- Test Case 2 ---\n    j2 = 1\n    grad_c2_analytic = np.zeros(N)\n    grad_c2_analytic[j2] = 2.0 * dt**2 * c[j2] * S_u_K[j2]\n    \n    c_perturbed = c.copy()\n    c_perturbed[j2] += epsilon\n    u_K_plus_1_pert_c2 = one_step_update(u_K, u_K_minus_1, c_perturbed, stf[K])\n    grad_c2_fd = (u_K_plus_1_pert_c2 - u_K_plus_1_base) / epsilon\n    \n    norm_analytic_2 = np.linalg.norm(grad_c2_analytic)\n    if norm_analytic_2  1e-15:\n        error2 = 0.0 if np.linalg.norm(grad_c2_fd)  1e-15 else float('inf')\n    else:\n        error2 = np.linalg.norm(grad_c2_analytic - grad_c2_fd) / norm_analytic_2\n    results.append(error2)\n    \n    # --- Test Case 3 ---\n    j3 = N // 3\n    m = np.log(c)\n    grad_m3_analytic = np.zeros(N)\n    grad_m3_analytic[j3] = 2.0 * dt**2 * c[j3]**2 * S_u_K[j3]\n    \n    m_perturbed = m.copy()\n    m_perturbed[j3] += epsilon\n    c_from_m_perturbed = np.exp(m_perturbed)\n    u_K_plus_1_pert_m3 = one_step_update(u_K, u_K_minus_1, c_from_m_perturbed, stf[K])\n    grad_m3_fd = (u_K_plus_1_pert_m3 - u_K_plus_1_base) / epsilon\n\n    norm_analytic_3 = np.linalg.norm(grad_m3_analytic)\n    if norm_analytic_3  1e-15:\n        error3 = 0.0 if np.linalg.norm(grad_m3_fd)  1e-15 else float('inf')\n    else:\n        error3 = np.linalg.norm(grad_m3_analytic - grad_m3_fd) / norm_analytic_3\n    results.append(error3)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3616640"}, {"introduction": "伴随状态法是处理大规模地球物理反演中高效梯度计算的基石。本练习要求您从第一性原理出发，为一个稳态问题推导伴随法，并实现梯度（$J^T r$）的计算。通过数值验证伴随状态恒等式，您将深刻理解数据残差是如何被反向传播，从而生成模型更新图的 [@problem_id:3616704]。", "problem": "考虑单位正方形域 $\\Omega=[0,1]^2$ 上的标量椭圆偏微分方程 (PDE) $\\,\\nabla\\cdot(\\sigma\\nabla\\phi)=q\\,$，其边界 $\\partial\\Omega$ 上满足齐次 Dirichlet 边界条件 $\\,\\phi=0\\,$。未知场是位势 $\\,\\phi(x,y)\\,$，模型参数是电导率 $\\,\\sigma(x,y)0\\,$，而 $\\,q(x,y)\\,$ 是一个给定的源分布。测量值由一个作用于 $\\,\\phi\\,$ 的线性算子 $\\,P\\,$ 给出，产生 $\\,d=P\\phi\\,$。令 $\\,r\\,$ 表示数据残差向量。正问题和模型参数化用以下术语进行描述：\n\n- 正算子将 $\\,\\sigma\\,$ 映射到数据 $\\,d=P\\phi\\,$，其中 $\\,\\phi\\,$ 是在 $\\,\\partial\\Omega$ 上满足 $\\,\\phi=0\\,$ 的方程 $\\,\\nabla\\cdot(\\sigma\\nabla\\phi)=q\\,$ 的解。\n- 雅可比 $\\,J\\,$ 是数据映射关于参数 $\\,\\sigma\\,$ 的 Fréchet 导数，$\\,J^T r\\,$ 表示对数据残差 $\\,r\\,$ 的伴随作用。\n- 您必须使用伴随状态法计算 $\\,J^T r\\,$，不得借助任何快捷公式。从 PDE 的弱形式以及变分法和线性算子的第一性原理出发，推导出一个算法，用于将作用 $\\,\\delta\\sigma\\mapsto r^T P\\,\\delta\\phi\\,$ 计算为 $\\,J^T r\\,$ 与扰动 $\\,\\delta\\sigma\\,$ 之间的 $\\,L^2(\\Omega)\\,$ 内积。\n\n您将使用一个 $\\,N\\times N\\,$ 点的均匀笛卡尔网格对 $\\,\\Omega\\,$ 进行离散化，两个方向上的间距均为 $\\,h=\\frac{1}{N-1}\\,$，在边界点上强制施加 $\\,\\phi=0\\,$，并使用 $\\,\\sigma\\,$ 的面心算术平均法组装一个对称正定线性系统，该系统代表与 $\\,\\nabla\\cdot(\\sigma\\nabla\\phi)\\,$ 相关的离散算子。您将实现以下计算任务：\n\n1. 求解正问题以获得 $\\,\\phi\\,$。\n2. 根据数据残差 $\\,r\\,$，以与测量算子 $\\,P\\,$ 一致的方式构造伴随源，并求解伴随问题以获得伴随场 $\\,\\lambda\\,$。\n3. 根据第一性原理计算场 $\\,J^T r\\,$ 在网格上的离散近似。\n4. 对于给定的扰动 $\\,\\delta\\sigma\\,$，通过比较标量 $\\,r^T P\\,\\delta\\phi\\,$ 和域积分 $\\,\\int_\\Omega (J^T r)\\,\\delta\\sigma\\,\\mathrm{d}x\\,\\mathrm{d}y\\,$ 来验证线性化响应恒等式在数值上是否成立，其中 $\\,\\delta\\phi\\,$ 是由 $\\,\\delta\\sigma\\,$ 引起的线性化正向方程的解。将绝对不匹配值报告为浮点数。\n\n您必须解释对于一般的线性测量算子 $\\,P\\,$，以及当 $\\,P\\,$ 在网格点上对 $\\,\\phi\\,$ 进行采样时的特殊情况，如何从数据残差 $\\,r\\,$ 构造伴随源。\n\n您的程序必须实现以上要求，并生成单行输出，其中包含下述测试套件的绝对不匹配值，格式为逗号分隔的列表并用方括号括起。每个不匹配值都必须是浮点数。\n\n使用以下测试套件。所有量纲均为无量纲。\n\n- 测试用例 1 (基线，恒定电导率，残差与正向数据关联):\n  - 网格尺寸：$\\,N=32$。\n  - 电导率：$\\,\\sigma(x,y)=1$（处处）。\n  - 源：中心网格点上的单位点源，即设置 $\\,q_{i_0,j_0}=1\\,$，其中 $\\,i_0=j_0=\\lfloor N/2\\rfloor\\,$，其他地方为零。\n  - 测量：$\\,P\\,$ 在索引为 $\\,[(\\lfloor N/4\\rfloor,\\lfloor N/4\\rfloor),(\\lfloor N/2\\rfloor,\\lfloor N/3\\rfloor),(\\lfloor 3N/4\\rfloor,\\lfloor 3N/4\\rfloor)]$ 的三个内部点上对 $\\,\\phi\\,$ 进行采样。\n  - 残差：设置 $\\,d_{\\text{obs}}=0\\,$ 且 $\\,r=d_{\\text{obs}}-P\\phi\\,$。\n  - 扰动：$\\,\\delta\\sigma\\,$ 是一个小的零均值随机场，从 $\\,[-0.1,0.1]\\,$ 上的均匀分布中抽取，使用固定的随机种子以保证可复现性。\n\n- 测试用例 2 (非均匀电导率，给定的残差):\n  - 网格尺寸：$\\,N=40$。\n  - 电导率：$\\,\\sigma(x,y)=1+0.5\\sin(2\\pi x)\\sin(2\\pi y)$，在网格点上求值。\n  - 源：索引为 $\\,(\\lfloor N/3\\rfloor,\\lfloor N/2\\rfloor)$ 的单位点源。\n  - 测量：$\\,P\\,$ 在索引为 $\\,[(\\lfloor N/5\\rfloor,\\lfloor N/5\\rfloor),(\\lfloor 2N/5\\rfloor,\\lfloor 3N/7\\rfloor),(\\lfloor N/2\\rfloor,\\lfloor 2N/3\\rfloor),(\\lfloor 3N/5\\rfloor,\\lfloor 2N/5\\rfloor),(\\lfloor 4N/5\\rfloor,\\lfloor 4N/5\\rfloor)]$ 的五个内部点上对 $\\,\\phi\\,$ 进行采样。\n  - 残差：$\\,r=[1,-0.5,0.25,-0.25,0.1]^T$。\n  - 扰动：$\\,\\delta\\sigma\\,$ 是一个小的零均值随机场，从 $\\,[-0.05,0.05]\\,$ 上的均匀分布中抽取，使用固定的随机种子以保证可复现性。\n\n- 测试用例 3 (边界情况，零正向场):\n  - 网格尺寸：$\\,N=24$。\n  - 电导率：$\\,\\sigma(x,y)=1$（处处）。\n  - 源：$\\,q=0\\,$（处处）。\n  - 测量：位于索引 $\\, (0,\\lfloor N/2\\rfloor)$ 的单个边界点。\n  - 残差：$\\,r=[1]^T$。\n  - 扰动：$\\,\\delta\\sigma\\,$ 是一个小的零均值随机场，从 $\\,[-0.02,0.02]\\,$ 上的均匀分布中抽取，使用固定的随机种子以保证可复现性。\n\n您的程序应生成单行输出，其中包含三个测试用例的绝对不匹配值，格式为用方括号括起的逗号分隔列表，例如 $\\,[m_1,m_2,m_3]\\,$，其中 $\\,m_k\\,$ 是第 $\\,k\\,$ 个测试用例的不匹配值。", "solution": "该问题要求推导并实现伴随状态法，以计算量 $J^T r$，该量表示数据敏感度雅可比的伴随算子对数据残差向量的作用。物理模型由单位正方形 $\\Omega=[0,1]^2$ 上的标量椭圆 PDE $\\nabla\\cdot(\\sigma\\nabla\\phi)=q$ 控制，边界 $\\partial\\Omega$ 上满足齐次 Dirichlet 边界条件 $\\phi=0$。我们必须从第一性原理出发推导算法，并对其进行数值验证。\n\n该方法的核心是为场 $G = J^T r$ 找到一个满足伴随算子定义关系的显式表达式：\n$$\n\\langle r, J \\delta\\sigma \\rangle_{\\text{data}} = \\langle J^T r, \\delta\\sigma \\rangle_{L^2(\\Omega)}\n$$\n其中 $\\delta\\sigma$ 是模型参数（电导率 $\\sigma$）的扰动，$J\\delta\\sigma$ 是预测数据的相应变化。预测数据 $d=P\\phi$ 是通过作用于位势场 $\\phi$ 的线性测量算子 $P$ 获得的。因此，数据的变化为 $J\\delta\\sigma = P\\delta\\phi$，其中 $\\delta\\phi$ 是位势的变化。需要验证的恒等式变为 $r^T(P\\delta\\phi) = \\int_\\Omega (J^T r)\\delta\\sigma \\, d\\Omega$。\n\n我们的推导分三步进行：\n1.  **线性化正向方程**：我们从 PDE 的弱形式 $\\int_\\Omega \\sigma \\nabla\\phi \\cdot \\nabla v \\, d\\Omega = -\\int_\\Omega q v \\, d\\Omega$（对于所有合适的测试函数 $v$）出发。通过关于扰动 $\\delta\\sigma$ 对其进行线性化，我们找到控制相应位势扰动 $\\delta\\phi$ 的方程：\n    $$\n    \\int_\\Omega \\sigma \\nabla\\delta\\phi \\cdot \\nabla v \\, d\\Omega = -\\int_\\Omega \\delta\\sigma \\nabla\\phi \\cdot \\nabla v \\, d\\Omega\n    $$\n2.  **伴随方程**：我们引入一个伴随场 $\\lambda$，将项 $r^T P\\delta\\phi$ 与线性化方程关联起来。项 $r^T P\\delta\\phi$ 可以写成函数空间中的内积，即 $\\langle P^T r, \\delta\\phi \\rangle = \\int_\\Omega (P^T r) \\delta\\phi \\, d\\Omega$。我们将伴随场 $\\lambda$ 定义为伴随 PDE $\\nabla \\cdot (\\sigma \\nabla \\lambda) = P^T r$（在 $\\partial\\Omega$ 上 $\\lambda=0$）的解。由于微分算子是自伴的，该方程与正向 PDE 具有相同的形式。其弱形式为 $\\int_\\Omega \\sigma \\nabla\\lambda \\cdot \\nabla w \\, d\\Omega = -\\int_\\Omega (P^T r) w \\, d\\Omega$。选择测试函数 $w = \\delta\\phi$，我们得到：\n    $$\n    -\\int_\\Omega (P^T r) \\delta\\phi \\, d\\Omega = -r^T P\\delta\\phi = \\int_\\Omega \\sigma \\nabla\\lambda \\cdot \\nabla \\delta\\phi \\, d\\Omega\n    $$\n3.  **$J^T r$ 的识别**：在线性化正向方程中选择测试函数 $v = \\lambda$，我们得到 $\\int_\\Omega \\sigma \\nabla\\delta\\phi \\cdot \\nabla \\lambda \\, d\\Omega = -\\int_\\Omega \\delta\\sigma \\nabla\\phi \\cdot \\nabla \\lambda \\, d\\Omega$。左侧与上面推导的伴随关系的右侧相同。令余项相等，得到：\n    $$\n    -r^T P\\delta\\phi = -\\int_\\Omega (\\nabla\\phi \\cdot \\nabla \\lambda) \\delta\\sigma \\, d\\Omega\n    $$\n    这可以简化为 $r^T P\\delta\\phi = \\int_\\Omega (\\nabla\\phi \\cdot \\nabla \\lambda) \\delta\\sigma \\, d\\Omega$。将此与伴随作用的定义进行比较，我们识别出所求场的显式表达式：\n    $$\n    J^T r = \\nabla\\phi \\cdot \\nabla\\lambda\n    $$\n对于逐点测量，伴随源 $P^T r$ 变为位于测量点的一系列 Dirac delta 分布之和，并由相应的残差值加权。在离散情况下，这意味着将残差值放置在各自的网格节点上。\n\n以下程序实现了这种伴随状态法。它数值求解了 $\\phi$ 的正问题和 $\\lambda$ 的伴随问题，并将 $J^T r$ 计算为它们梯度的点积。然后，它显式地计算恒等式 $r^T P\\delta\\phi = \\int (J^T r) \\delta\\sigma \\,d\\Omega$ 两边的值，并报告它们的绝对差，以验证推导和实现的正确性。离散化在网格的内部节点上采用了五点有限差分格式，从而产生一个可以被高效求解的稀疏、对称、正定的线性系统。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    def solve_case(N, sigma_func, q_loc, meas_loc_indices, r_val, delta_sigma_dist, seed):\n        \"\"\"\n        Solves a single test case for the adjoint verification problem.\n        \"\"\"\n        h = 1.0 / (N - 1)\n        x = np.linspace(0, 1, N)\n        y = np.linspace(0, 1, N)\n        xx, yy = np.meshgrid(x, y)\n\n        sigma = sigma_func(xx, yy)\n        q_grid = np.zeros((N, N))\n        if q_loc:\n            q_grid[q_loc] = 1.0\n\n        meas_loc_indices = np.array(meas_loc_indices)\n        meas_rows, meas_cols = meas_loc_indices[:, 0], meas_loc_indices[:, 1]\n\n        np.random.seed(seed)\n        delta_sigma = np.random.uniform(delta_sigma_dist[0], delta_sigma_dist[1], size=(N, N))\n        delta_sigma -= np.mean(delta_sigma)\n\n        def build_operator(s_field):\n            \"\"\"Builds the discrete operator B for -div(sigma*grad).\"\"\"\n            n_int = N - 2\n            n_dof = n_int * n_int\n            if n_dof == 0: return csr_matrix((0, 0))\n            A = lil_matrix((n_dof, n_dof))\n\n            for i_int in range(n_int):\n                for j_int in range(n_int):\n                    k = i_int * n_int + j_int\n                    i, j = i_int + 1, j_int + 1\n\n                    diag_val = 0.0\n\n                    # East neighbor\n                    s_e = 0.5 * (s_field[i, j] + s_field[i, j + 1])\n                    diag_val += s_e\n                    if j_int  n_int - 1:\n                        A[k, k + 1] = -s_e / h**2\n\n                    # West neighbor\n                    s_w = 0.5 * (s_field[i, j] + s_field[i, j - 1])\n                    diag_val += s_w\n                    if j_int > 0:\n                        A[k, k - 1] = -s_w / h**2\n\n                    # North neighbor\n                    s_n = 0.5 * (s_field[i, j] + s_field[i + 1, j])\n                    diag_val += s_n\n                    if i_int  n_int - 1:\n                        A[k, k + n_int] = -s_n / h**2\n\n                    # South neighbor\n                    s_s = 0.5 * (s_field[i, j] + s_field[i - 1, j])\n                    diag_val += s_s\n                    if i_int > 0:\n                        A[k, k - n_int] = -s_s / h**2\n                        \n                    A[k, k] = diag_val / h**2\n            return csr_matrix(A)\n\n        # 1. Solve forward problem for phi: B*phi = -q\n        B_op = build_operator(sigma)\n        q_interior = q_grid[1:-1, 1:-1].flatten()\n        phi = np.zeros((N, N))\n        if B_op.shape[0] > 0 and q_interior.any():\n            phi_vec = spsolve(B_op, -q_interior)\n            phi[1:-1, 1:-1] = phi_vec.reshape((N - 2, N - 2))\n\n        # Define residual r\n        if r_val is None:\n            d_calc = phi[meas_rows, meas_cols]\n            d_obs = 0.0\n            r = d_obs - d_calc\n        else:\n            r = np.array(r_val)\n\n        # 2. Solve adjoint problem for lambda: B*lambda = -q_adj\n        q_adj_grid = np.zeros((N, N))\n        for idx, res_val in zip(meas_loc_indices, r):\n            if 1 = idx[0]  N - 1 and 1 = idx[1]  N - 1:\n                q_adj_grid[tuple(idx)] = res_val\n        \n        q_adj_interior = q_adj_grid[1:-1, 1:-1].flatten()\n        lam = np.zeros((N, N))\n        if B_op.shape[0] > 0 and q_adj_interior.any():\n            lambda_vec = spsolve(B_op, -q_adj_interior)\n            lam[1:-1, 1:-1] = lambda_vec.reshape((N - 2, N - 2))\n        \n        # 3. Compute J^T r field\n        grad_phi_y, grad_phi_x = np.gradient(phi, h, edge_order=2)\n        grad_lam_y, grad_lam_x = np.gradient(lam, h, edge_order=2)\n        JTr_field = grad_phi_x * grad_lam_x + grad_phi_y * grad_lam_y\n\n        # 4. Verify identity\n        # LHS: r^T P delta_phi\n        # Solve B*delta_phi = -[B(sigma+delta_sigma) - B(sigma)]*phi\n        delta_phi = np.zeros((N, N))\n        if B_op.shape[0] > 0:\n            B_perturbed = build_operator(sigma + delta_sigma)\n            phi_interior_vec = phi[1:-1, 1:-1].flatten()\n            \n            b_lin_vec = - (B_perturbed - B_op) @ phi_interior_vec\n            delta_phi_vec = spsolve(B_op, b_lin_vec)\n            delta_phi[1:-1, 1:-1] = delta_phi_vec.reshape((N - 2, N - 2))\n        \n        P_delta_phi = delta_phi[meas_rows, meas_cols]\n        lhs = r @ P_delta_phi\n        \n        # RHS: integral of (J^T r) * delta_sigma\n        rhs = np.sum(JTr_field * delta_sigma) * h**2\n        \n        mismatch = np.abs(lhs - rhs)\n        return mismatch\n\n    # Test Case 1\n    N1 = 32\n    case1_params = {\n        'N': N1,\n        'sigma_func': lambda x, y: 1.0 + 0 * x,\n        'q_loc': (N1 // 2, N1 // 2),\n        'meas_loc_indices': [(N1 // 4, N1 // 4), (N1 // 2, N1 // 3), (3 * N1 // 4, 3 * N1 // 4)],\n        'r_val': None,\n        'delta_sigma_dist': (-0.1, 0.1),\n        'seed': 0\n    }\n\n    # Test Case 2\n    N2 = 40\n    case2_params = {\n        'N': N2,\n        'sigma_func': lambda x, y: 1.0 + 0.5 * np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y),\n        'q_loc': (N2 // 3, N2 // 2),\n        'meas_loc_indices': [(N2 // 5, N2 // 5), (2 * N2 // 5, 3 * N2 // 7), (N2 // 2, 2 * N2 // 3), (3 * N2 // 5, 2 * N2 // 5), (4 * N2 // 5, 4 * N2 // 5)],\n        'r_val': [1.0, -0.5, 0.25, -0.25, 0.1],\n        'delta_sigma_dist': (-0.05, 0.05),\n        'seed': 1\n    }\n\n    # Test Case 3\n    N3 = 24\n    case3_params = {\n        'N': N3,\n        'sigma_func': lambda x, y: 1.0 + 0 * x,\n        'q_loc': None,\n        'meas_loc_indices': [(0, N3 // 2)],\n        'r_val': [1.0],\n        'delta_sigma_dist': (-0.02, 0.02),\n        'seed': 2\n    }\n\n    test_cases = [case1_params, case2_params, case3_params]\n    results = []\n    for params in test_cases:\n        mismatch = solve_case(**params)\n        results.append(mismatch)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3616704"}]}