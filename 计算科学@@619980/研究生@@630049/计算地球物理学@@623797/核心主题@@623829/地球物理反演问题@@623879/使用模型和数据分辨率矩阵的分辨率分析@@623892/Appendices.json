{"hands_on_practices": [{"introduction": "要真正掌握分辨率分析，从理论走向实践至关重要。我们的第一个动手练习 [@problem_id:3613752] 将通过一个简单且易于解析的例子来帮助您建立核心直觉。这个练习要求您从基本原理出发，为一个 $2 \\times 2$ 的小问题推导模型分辨率矩阵 $R_m$，并分析当问题变得病态时其特征值的变化，从而具体理解 $R_m$ 是如何量化分辨率损失的。", "problem": "考虑一个计算地球物理学中的线性反演问题，其中数据向量 $\\mathbf{d} \\in \\mathbb{R}^{2}$ 由 $\\mathbf{d} = G \\mathbf{m} + \\mathbf{e}$ 建模，模型向量为 $\\mathbf{m} \\in \\mathbb{R}^{2}$，正演算子为 $G \\in \\mathbb{R}^{2 \\times 2}$，数据噪声 $\\mathbf{e}$ 被建模为一个零均值高斯随机向量，其协方差矩阵为 $C_{d} = \\sigma^{2} I$，其中 $\\sigma  0$ 且 $I$ 是单位矩阵。正演算子为\n$$\nG = \\begin{bmatrix} 1  1 \\\\ 0  \\alpha \\end{bmatrix},\n$$\n其中 $\\alpha  0$。为在可能存在不适定性的情况下稳定反演，考虑采用阻尼参数为 $\\lambda  0$ 的零阶吉洪诺夫正则化，其中模型估计值通过最小化目标泛函\n$$\n\\|\\mathbf{d} - G \\mathbf{m}\\|_{C_{d}^{-1}}^{2} + \\lambda^{2} \\|\\mathbf{m}\\|^{2}\n$$\n获得，并且模型分辨率矩阵 $R_{m}$ 根据估计量对真实模型的作用来定义。请从加权最小二乘法和正则化的基本原理出发，推导模型分辨率矩阵 $R_{m}$ 并分析其特征结构。\n\n您的任务是提供模型分辨率矩阵 $R_{m}$ 的最小特征值作为 $\\alpha$、$\\sigma$ 和 $\\lambda$ 的函数的精确闭式表达式。不要四舍五入；请以精确的符号形式提供您的最终表达式。此外，在您的推导过程中，解释当 $\\alpha \\to 0$ 时的行为如何揭示反演问题中近零空间的出现。最终答案必须是 $R_{m}$ 最小特征值的单个闭式解析表达式。", "solution": "该问题是有效的，因为它具有科学依据、适定且客观。它代表了计算地球物理学中正则化线性反演问题的标准表述形式。所有提供的信息都是自洽和一致的。\n\n目标是求解使用吉洪诺夫方法正则化的线性反演问题中，模型分辨率矩阵 $R_{m}$ 的最小特征值。模型估计 $\\hat{\\mathbf{m}}$ 通过最小化目标泛函 $J(\\mathbf{m})$ 求得：\n$$\nJ(\\mathbf{m}) = \\|\\mathbf{d} - G \\mathbf{m}\\|_{C_{d}^{-1}}^{2} + \\lambda^{2} \\|\\mathbf{m}\\|^{2}\n$$\n已知数据协方差矩阵为 $C_{d} = \\sigma^{2} I$，其逆矩阵为 $C_{d}^{-1} = \\frac{1}{\\sigma^{2}} I$。泛函变为：\n$$\nJ(\\mathbf{m}) = \\frac{1}{\\sigma^{2}} (\\mathbf{d} - G \\mathbf{m})^{T} (\\mathbf{d} - G \\mathbf{m}) + \\lambda^{2} \\mathbf{m}^{T} \\mathbf{m}\n$$\n为求得使 $J(\\mathbf{m})$ 最小化的模型估计 $\\hat{\\mathbf{m}}$，我们计算其关于 $\\mathbf{m}$ 的梯度并令其为零：\n$$\n\\nabla_{\\mathbf{m}} J(\\mathbf{m}) = \\frac{1}{\\sigma^{2}} \\nabla_{\\mathbf{m}} (\\mathbf{d}^{T}\\mathbf{d} - 2\\mathbf{d}^{T}G\\mathbf{m} + \\mathbf{m}^{T}G^{T}G\\mathbf{m}) + \\lambda^{2} \\nabla_{\\mathbf{m}} (\\mathbf{m}^{T}\\mathbf{m})\n$$\n$$\n\\nabla_{\\mathbf{m}} J(\\mathbf{m}) = \\frac{1}{\\sigma^{2}} (-2G^{T}\\mathbf{d} + 2G^{T}G\\mathbf{m}) + 2\\lambda^{2}\\mathbf{m} = \\mathbf{0}\n$$\n两边乘以 $\\frac{\\sigma^{2}}{2}$ 并整理可得：\n$$\n(G^{T}G)\\mathbf{m} - G^{T}\\mathbf{d} + \\sigma^{2}\\lambda^{2}\\mathbf{m} = \\mathbf{0}\n$$\n$$\n(G^{T}G + \\sigma^{2}\\lambda^{2}I)\\mathbf{m} = G^{T}\\mathbf{d}\n$$\n因此，估计的模型 $\\hat{\\mathbf{m}}$ 为：\n$$\n\\hat{\\mathbf{m}} = (G^{T}G + \\sigma^{2}\\lambda^{2}I)^{-1} G^{T}\\mathbf{d}\n$$\n模型分辨率矩阵 $R_{m}$ 将估计量 $\\hat{\\mathbf{m}}$ 的期望值与真实模型 $\\mathbf{m}_{\\text{true}}$ 联系起来。我们将正演模型 $\\mathbf{d} = G \\mathbf{m}_{\\text{true}} + \\mathbf{e}$ 代入 $\\hat{\\mathbf{m}}$ 的表达式中：\n$$\n\\hat{\\mathbf{m}} = (G^{T}G + \\sigma^{2}\\lambda^{2}I)^{-1} G^{T} (G \\mathbf{m}_{\\text{true}} + \\mathbf{e})\n$$\n$$\n\\hat{\\mathbf{m}} = (G^{T}G + \\sigma^{2}\\lambda^{2}I)^{-1} G^{T}G \\mathbf{m}_{\\text{true}} + (G^{T}G + \\sigma^{2}\\lambda^{2}I)^{-1} G^{T} \\mathbf{e}\n$$\n取期望，并利用噪声是零均值 ($\\mathbb{E}[\\mathbf{e}] = \\mathbf{0}$) 这一事实：\n$$\n\\mathbb{E}[\\hat{\\mathbf{m}}] = (G^{T}G + \\sigma^{2}\\lambda^{2}I)^{-1} G^{T}G \\mathbf{m}_{\\text{true}}\n$$\n根据定义，$\\mathbb{E}[\\hat{\\mathbf{m}}] = R_{m} \\mathbf{m}_{\\text{true}}$，因此模型分辨率矩阵为：\n$$\nR_{m} = (G^{T}G + \\sigma^{2}\\lambda^{2}I)^{-1} G^{T}G\n$$\n为求 $R_{m}$ 的特征值，我们首先求矩阵 $A = G^{T}G$ 的特征值。设 $\\eta$ 是 $A$ 的一个特征值，其对应的特征向量为 $\\mathbf{v}$，满足 $A\\mathbf{v} = \\eta\\mathbf{v}$。然后我们可以分析 $R_{m}$ 对 $\\mathbf{v}$ 的作用：\n$$\nR_{m}\\mathbf{v} = (A + \\sigma^{2}\\lambda^{2}I)^{-1} A \\mathbf{v} = (A + \\sigma^{2}\\lambda^{2}I)^{-1} (\\eta \\mathbf{v}) = \\eta (A + \\sigma^{2}\\lambda^{2}I)^{-1} \\mathbf{v}\n$$\n由于 $(A + \\sigma^{2}\\lambda^{2}I)\\mathbf{v} = A\\mathbf{v} + \\sigma^{2}\\lambda^{2}\\mathbf{v} = (\\eta + \\sigma^{2}\\lambda^{2})\\mathbf{v}$，我们有 $(A + \\sigma^{2}\\lambda^{2}I)^{-1}\\mathbf{v} = \\frac{1}{\\eta + \\sigma^{2}\\lambda^{2}}\\mathbf{v}$。\n将此代回，我们得到：\n$$\nR_{m}\\mathbf{v} = \\eta \\left(\\frac{1}{\\eta + \\sigma^{2}\\lambda^{2}}\\right) \\mathbf{v} = \\frac{\\eta}{\\eta + \\sigma^{2}\\lambda^{2}} \\mathbf{v}\n$$\n因此，$R_{m}$ 的特征值（记为 $\\rho$）通过表达式 $\\rho = \\frac{\\eta}{\\eta + \\sigma^{2}\\lambda^{2}}$ 与 $G^{T}G$ 的特征值（记为 $\\eta$）相关联。函数 $f(\\eta) = \\frac{\\eta}{\\eta + \\mu}$ (其中 $\\mu = \\sigma^{2}\\lambda^{2}  0$) 对于 $\\eta  0$ 是单调递增的。因此，$R_{m}$ 的最小特征值对应于 $G^{T}G$ 的最小特征值。\n\n现在我们计算给定正演算子 $G = \\begin{bmatrix} 1  1 \\\\ 0  \\alpha \\end{bmatrix}$ 的 $G^{T}G$：\n$$\nG^{T}G = \\begin{bmatrix} 1  0 \\\\ 1  \\alpha \\end{bmatrix} \\begin{bmatrix} 1  1 \\\\ 0  \\alpha \\end{bmatrix} = \\begin{bmatrix} 1  1 \\\\ 1  1+\\alpha^{2} \\end{bmatrix}\n$$\n$G^{T}G$ 的特征值 $\\eta$ 是特征方程 $\\det(G^{T}G - \\eta I) = 0$ 的根：\n$$\n\\det \\begin{bmatrix} 1-\\eta  1 \\\\ 1  1+\\alpha^{2}-\\eta \\end{bmatrix} = 0\n$$\n$$\n(1-\\eta)(1+\\alpha^{2}-\\eta) - 1 = 0\n$$\n$$\n\\eta^{2} - (1+\\alpha^{2}+1)\\eta + (1+\\alpha^{2}) - 1 = 0\n$$\n$$\n\\eta^{2} - (2+\\alpha^{2})\\eta + \\alpha^{2} = 0\n$$\n使用二次方程求根公式求解 $\\eta$：\n$$\n\\eta = \\frac{(2+\\alpha^{2}) \\pm \\sqrt{(2+\\alpha^{2})^{2} - 4\\alpha^{2}}}{2} = \\frac{2+\\alpha^{2} \\pm \\sqrt{4+4\\alpha^{2}+\\alpha^{4} - 4\\alpha^{2}}}{2} = \\frac{2+\\alpha^{2} \\pm \\sqrt{4+\\alpha^{4}}}{2}\n$$\n$G^{T}G$ 的两个特征值为 $\\eta_{1} = \\frac{2+\\alpha^{2} + \\sqrt{4+\\alpha^{4}}}{2}$ 和 $\\eta_{2} = \\frac{2+\\alpha^{2} - \\sqrt{4+\\alpha^{4}}}{2}$。最小的特征值为 $\\eta_{\\min}$：\n$$\n\\eta_{\\min} = \\frac{2+\\alpha^{2} - \\sqrt{4+\\alpha^{4}}}{2}\n$$\n模型分辨率矩阵对应的最小特征值 $\\rho_{\\min}$ 为：\n$$\n\\rho_{\\min} = \\frac{\\eta_{\\min}}{\\eta_{\\min} + \\sigma^{2}\\lambda^{2}} = \\frac{\\frac{2+\\alpha^{2} - \\sqrt{4+\\alpha^{4}}}{2}}{\\frac{2+\\alpha^{2} - \\sqrt{4+\\alpha^{4}}}{2} + \\sigma^{2}\\lambda^{2}}\n$$\n分子和分母同乘以 $2$ 得到最终表达式：\n$$\n\\rho_{\\min} = \\frac{2+\\alpha^{2} - \\sqrt{4+\\alpha^{4}}}{2+\\alpha^{2} - \\sqrt{4+\\alpha^{4}} + 2\\sigma^{2}\\lambda^{2}}\n$$\n当 $\\alpha \\to 0$ 时，正演算子 $G$ 趋近于 $G_0 = \\begin{bmatrix} 1  1 \\\\ 0  0 \\end{bmatrix}$，该矩阵是奇异的。$G_0$ 的零空间由满足 $v_{1} + v_{2} = 0$ 的向量 $\\mathbf{v}$ 组成，由向量 $[1, -1]^{T}$ 张成。这个向量代表模型中一个不产生任何数据的分量，因此是完全不受约束的。$\\alpha \\to 0$ 的极限意味着零空间的出现，使得问题变得不适定。\n在此极限下，$G^{T}G$ 的最小特征值变为：\n$$\n\\lim_{\\alpha \\to 0} \\eta_{\\min} = \\lim_{\\alpha \\to 0} \\frac{2+\\alpha^{2} - \\sqrt{4+\\alpha^{4}}}{2} = \\frac{2 - \\sqrt{4}}{2} = 0\n$$\n$G^T G$ 的一个特征值趋近于零是正在出现的零空间的标志。$G^T G$ 对应的特征向量趋近于零空间向量 $[1, -1]^T$。因此，分辨率矩阵 $R_{m}$ 的最小特征值也趋近于零（假定 $\\lambda  0$）：\n$$\n\\lim_{\\alpha \\to 0} \\rho_{\\min} = \\frac{0}{0 + 2\\sigma^{2}\\lambda^{2}} = 0\n$$\n分辨率矩阵的特征值等于 $0$ 表明对应的模型分量（特征向量）完全没有分辨率。对于小的 $\\alpha  0$，$\\rho_{\\min}$ 将接近于零，这表明与近零空间相关的模型分量被数据解析得非常差。由 $\\lambda$ 控制的正则化通过抑制这个不受约束的分量来稳定反演过程，但代价是分辨率的降低，正如 $\\rho_{\\min}$ 的小值所量化的那样。", "answer": "$$\\boxed{\\frac{2+\\alpha^{2} - \\sqrt{4+\\alpha^{4}}}{2+\\alpha^{2} - \\sqrt{4+\\alpha^{4}} + 2\\sigma^{2}\\lambda^{2}}}$$", "id": "3613752"}, {"introduction": "在实际应用中，地球物理模型可能包含数千甚至数百万个参数，这使得完整的分辨率矩阵过于庞大而难以计算或直接分析。一种更有效的方法是计算并可视化其独立的列，即点扩散函数 (Point-Spread Functions, PSFs)。这个计算练习 [@problem_id:3613732] 将引导您完成一个模拟的层析成像问题来生成PSFs，让您能够直观地评估分辨率如何随空间位置变化，以及它如何受到射线覆盖范围和正则化选择等因素的影响。", "problem": "给定一个在单位正方形域上的二维线性反演问题，该域上有一个均匀的矩形单元网格，这是计算地球物理学中直线射线走时层析成像的典型问题。正演模型是一个线性算子，它将单元模型映射为该模型沿直线射线的路径积分。您将通过点扩散函数分析阻尼平滑最小二乘估计的分辨率特性，并以模型为中心的方式量化扩散的各向异性。\n\n从以下基础出发：线性方程组由 $\\,\\mathbf{d} = \\mathbf{G}\\,\\mathbf{m} + \\boldsymbol{\\epsilon}\\,$ 给出，其中 $\\,\\mathbf{G}\\,$ 是由沿直线射线路径的单元贡献的线积分构成的灵敏度矩阵，$\\,\\mathbf{m}\\,$ 是在网格上均匀采样的未知模型，$\\,\\mathbf{d}\\,$ 是数据向量（每条射线一个数据点），而 $\\,\\boldsymbol{\\epsilon}\\,$ 是加性噪声。该估计是通过最小化带二次平滑惩罚项的加权最小二乘目标函数得到的。平滑算子 $\\,\\mathbf{L}\\,$ 是根据两个网格轴方向上相邻单元的一阶差分构建的，并且可以通过为水平和垂直差分选择不同的权重来使其具有各向异性。\n\n通过在选定单元注入一个 delta 模型并执行反演来获得估计模型，从而构建点扩散函数。这个估计模型就是点扩散函数，它等于模型分辨率矩阵的相应列。然后，通过计算关于中心单元的二阶矩张量，并构成一个测量扩散伸长程度的平方根特征值比率，来量化每个扩散函数的各向异性。\n\n需严格遵循的实现细节：\n- 域和网格：\n  - 域是单位正方形 $[\\,0,1\\,]\\times[\\,0,1\\,]$。\n  - 使用一个具有 $\\,n\\times n\\,$ 个单元的均匀网格。记为 $\\,N = n^2\\,$。\n  - 网格索引为 $\\,(\\,i,j\\,)\\,$ (零基索引) 的单元中心坐标是 $\\,\\big(\\,(j+\\tfrac{1}{2})/n,\\,(i+\\tfrac{1}{2})/n\\,\\big)\\,$。\n  - 使用 $\\,n = 16\\,$。\n  - 分析单元（注入 delta 模型的单元）是索引为 $\\,(\\,i_0,j_0\\,)=(\\,\\lfloor n/2 \\rfloor,\\lfloor n/2 \\rfloor\\,)\\,$ 的网格单元。对于 $\\,n=16\\,$，这确定为 $\\,(\\,8,8\\,)\\,$。\n- 射线和正演算子 $\\,\\mathbf{G}\\,$：\n  - 每条射线定义为连接单位正方形边界上两点的直线段。\n  - 正演算子 $\\,\\mathbf{G}\\,$ 的每一行对应一条射线，每一列对应一个单元。条目 $\\,G_{r,c}\\,$ 等于射线 $\\,r\\,$ 穿过单元 $\\,c\\,$ 的近似路径长度。\n  - 通过沿每条射线段进行均匀采样来近似线积分：设端点为 $\\,\\mathbf{p}_0=(x_0,y_0)\\,$ 和 $\\,\\mathbf{p}_1=(x_1,y_1)\\,$。沿线段使用 $\\,S=200\\,$ 个等距的内采样点，线段长度为 $\\,\\ell=\\lVert \\mathbf{p}_1-\\mathbf{p}_0\\rVert_2\\,$，步长为 $\\,\\Delta s = \\ell/S\\,$。对于第 $\\,s\\,$ 个样本，$\\,\\mathbf{p}=\\mathbf{p}_0 + \\big(s+\\tfrac{1}{2}\\big)\\,(\\mathbf{p}_1-\\mathbf{p}_0)/S\\,$，其中 $\\,s\\in\\{0,1,\\dots,S-1\\}\\,$。将 $\\,\\Delta s\\,$ 分配给包含 $\\,\\mathbf{p}\\,$ 的单元（通过对 $\\,x\\cdot n\\,$ 和 $\\,y\\cdot n\\,$ 进行整数截断，并丢弃越界的样本）。\n- 平滑算子 $\\,\\mathbf{L}\\,$：\n  - 将 $\\,\\mathbf{L}\\,$ 构建为相邻单元之间一阶差分的堆叠。对于公共行 $\\,i\\,$ 和相邻列 $\\,j-1\\,$ 与 $\\,j\\,$ 的每个水平相邻对，包含一个等于 $\\,w_x\\,(m_{i,j}-m_{i,j-1})\\,$ 的行。对于公共列 $\\,j\\,$ 和相邻行 $\\,i-1\\,$ 与 $\\,i\\,$ 的每个垂直相邻对，包含一个等于 $\\,w_y\\,(m_{i,j}-m_{i-1,j})\\,$ 的行。这里 $\\,w_x\\,$ 和 $\\,w_y\\,$ 是控制平滑各向异性的非负权重。平滑惩罚项为 $\\,\\lVert \\mathbf{L}\\,\\mathbf{m}\\rVert_2^2\\,$。\n- 估计：\n  - 使用标准的阻尼平滑最小二乘估计，该估计最小化残差平方和 $+\\,$ 平滑惩罚项的非负倍数 $\\,\\lambda^2\\,$。将数据权重视为单位矩阵。求解相关的正规方程组，以获得每个注入的 delta 模型的估计模型。\n- 点扩散函数和各向异性：\n  - 对于给定的索引 $\\,c_0\\,$（对应于单元 $\\,(\\,i_0,j_0\\,)\\,$），构建 delta 模型 $\\,\\mathbf{e}_{c_0}\\,$。\n  - 生成合成数据 $\\,\\mathbf{d}=\\mathbf{G}\\,\\mathbf{e}_{c_0}\\,$，并使用相同的平滑和阻尼求解估计模型 $\\,\\widehat{\\mathbf{m}}\\,$。向量 $\\,\\widehat{\\mathbf{m}}\\,$ 就是点扩散函数。\n  - 为了量化各向异性，使用非负权重 $\\,w_k = \\widehat{m}_k^{\\,2}\\,$ 计算关于中心单元坐标 $\\,(\\,x_c,y_c\\,)\\,$ 的加权二阶矩张量，其中 $\\,\\widehat{m}_k\\,$ 是单元 $\\,k\\,$ 的值，$\\,(\\,x_k,y_k\\,)\\,$ 是其中心。令 $\\,\\Delta x_k = x_k - x_c\\,$ 和 $\\,\\Delta y_k = y_k - y_c\\,$。定义 $\\,2\\times 2\\,$ 的对称张量\n    $$\\mathbf{M} = \\frac{1}{\\sum_k w_k}\\sum_k w_k \\begin{bmatrix} \\Delta x_k^2  \\Delta x_k \\Delta y_k \\\\ \\Delta x_k \\Delta y_k  \\Delta y_k^2 \\end{bmatrix}.$$\n    令 $\\,\\mu_{\\max}\\,$ 和 $\\,\\mu_{\\min}\\,$ 为 $\\,\\mathbf{M}\\,$ 的特征值，且 $\\,\\mu_{\\max}\\ge \\mu_{\\min}\\ge 0\\,$。将各向异性比率定义为\n    $$\\rho = \\sqrt{\\frac{\\mu_{\\max}}{\\mu_{\\min} + \\epsilon}},$$\n    其中 $\\,\\epsilon\\,$ 是一个小的正常数正则化常数，应取 $\\,\\epsilon = 10^{-12}\\,$ 以避免除以零。各向异性比率 $\\,\\rho\\,$ 是无量纲的。\n- 单位：\n  - 本问题中的所有量都是无量纲的。在任何内部实现中使用的角度，可以根据方便以弧度或度为单位处理，但您的实现应遵循下文的射线定义，这些定义以边界点对的形式指定，不需要显式的角度输入。\n\n测试套件。对于以下所有情况，使用 $\\,n=16\\,$，每条射线 $\\,S=200\\,$ 个样本，分析单元位于 $\\,(\\,i_0,j_0\\,)=(\\,8,8\\,)\\,$，并按上述定义计算各向异性比率 $\\,\\rho\\,$。射线由边界到边界的线段族定义；每个族生成 $\\,8\\,$ 条射线。\n\n定义以下射线族：\n- 族 $\\,\\mathrm{LR\\_hor}\\,$：从左到右的水平射线。对于 $\\,k\\in\\{1,3,5,7,9,11,13,15\\}\\,$，定义 $\\,y_0 = k/16\\,$ 以及从 $\\,(\\,0,\\,y_0\\,)\\,$ 到 $\\,(\\,1,\\,y_0\\,)\\,$ 的线段。\n- 族 $\\,\\mathrm{LR\\_pos}\\,$：从左到右的正斜率射线。使用相同的 $\\,y_0\\,$ 集合，定义从 $\\,(\\,0,\\,y_0\\,)\\,$ 到 $\\,(\\,1,\\,\\min(1,\\,y_0+0.4)\\,)\\,$ 的线段。\n- 族 $\\,\\mathrm{LR\\_neg}\\,$：从左到右的负斜率射线。使用相同的 $\\,y_0\\,$ 集合，定义从 $\\,(\\,0,\\,y_0\\,)\\,$ 到 $\\,(\\,1,\\,\\max(0,\\,y_0-0.4)\\,)\\,$ 的线段。\n- 族 $\\,\\mathrm{BT\\_ver}\\,$：从下到上的垂直射线。对于 $\\,k\\in\\{1,3,5,7,9,11,13,15\\}\\,$，定义 $\\,x_0 = k/16\\,$ 以及从 $\\,(\\,x_0,\\,0\\,)\\,$ 到 $\\,(\\,x_0,\\,1\\,)\\,$ 的线段。\n- 族 $\\,\\mathrm{BT\\_pos}\\,$：从下到上的正斜率射线。使用相同的 $\\,x_0\\,$ 集合，定义从 $\\,(\\,x_0,\\,0\\,)\\,$ 到 $\\,(\\,\\min(1,\\,x_0+0.4),\\,1\\,)\\,$ 的线段。\n- 族 $\\,\\mathrm{BT\\_neg}\\,$：从下到上的负斜率射线。使用相同的 $\\,x_0\\,$ 集合，定义从 $\\,(\\,x_0,\\,0\\,)\\,$ 到 $\\,(\\,\\max(0,\\,x_0-0.4),\\,1\\,)\\,$ 的线段。\n\n需要实现的四个测试用例是：\n- 用例 1（均衡覆盖，各向同性平滑）：使用所有六个族 $\\,\\{\\mathrm{LR\\_hor},\\mathrm{LR\\_pos},\\mathrm{LR\\_neg},\\mathrm{BT\\_ver},\\mathrm{BT\\_pos},\\mathrm{BT\\_neg}\\}\\,$ 共计 $\\,48\\,$ 条射线；使用平滑权重 $\\,w_x = 1\\,$ 和 $\\,w_y = 1\\,$；阻尼参数 $\\,\\lambda = 0.1\\,$。\n- 用例 2（方向受限覆盖）：仅使用族 $\\,\\{\\mathrm{BT\\_ver}\\}\\,$，共计 $\\,8\\,$ 条射线；使用平滑权重 $\\,w_x = 1\\,$ 和 $\\,w_y = 1\\,$；阻尼参数 $\\,\\lambda = 0.1\\,$。\n- 用例 3（均衡覆盖，强平滑）：使用与用例 1 相同的射线；使用平滑权重 $\\,w_x = 1\\,$ 和 $\\,w_y = 1\\,$；阻尼参数 $\\,\\lambda = 1.0\\,$。\n- 用例 4（均衡覆盖，各向异性平滑）：使用与用例 1 相同的射线；使用平滑权重 $\\,w_x = 5\\,$ 和 $\\,w_y = 1\\,$；阻尼参数 $\\,\\lambda = 0.1\\,$。\n\n您的任务：\n- 通过上述采样方案实现 $\\,\\mathbf{G}\\,$ 的构建。\n- 通过带权重 $\\,w_x\\,$ 和 $\\,w_y\\,$ 的一阶差分实现 $\\,\\mathbf{L}\\,$ 的构建。\n- 对于每个用例，在 $\\,(\\,i_0,j_0\\,)\\,$ 处注入 delta 模型，合成 $\\,\\mathbf{d}\\,$，求解对应于单位数据权重以及指定的 $\\,\\lambda\\,$ 和 $\\,\\mathbf{L}\\,$ 的正规方程组，以获得点扩散函数 $\\,\\widehat{\\mathbf{m}}\\,$，并用 $\\,\\epsilon=10^{-12}\\,$ 计算各向异性比率 $\\,\\rho\\,$。\n- 您的程序的请求输出是对应于用例 1 到 4 的列表 $[\\rho_1,\\rho_2,\\rho_3,\\rho_4]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个各向异性比率四舍五入到三位小数，例如 $[\\rho_1,\\rho_2,\\rho_3,\\rho_4]$。各向异性比率是无量纲的，必须打印为小数，不带任何附加文本。", "solution": "用户提供的问题是计算地球物理学中一个定义明确的任务，具体涉及线性反演问题的分辨率分析。该问题具有科学依据，逻辑一致，并提供了所有必要的参数和定义，以得出一个唯一的、可计算的解。所有步骤都得到了明确说明，从网格和射线几何形状到正则化最小二乘估计器的数学公式以及量化各向异性的方法。因此，该问题被视为**有效**。\n\n求解过程如下，严格遵循所述方法。\n\n**1. 模型离散化与几何**\n域是一个单位正方形 $[\\,0,1\\,]\\times[\\,0,1\\,]$，被离散化为一个 $\\,n \\times n\\,$ 的均匀单元网格，其中 $\\,n=16\\,$。模型参数（单元）的总数为 $\\,N = n^2 = 256\\,$。一个二维单元索引 $\\,(\\,i,j\\,)\\,$，其中 $\\,i\\,$ 是行（y 轴），$\\,j\\,$ 是列（x 轴），被映射到一个单一的向量索引 $\\,c = i \\cdot n + j\\,$。单元 $\\,(\\,i,j\\,)\\,$ 的中心位于坐标 $\\,\\big(\\,(j+\\tfrac{1}{2})/n, \\, (i+\\tfrac{1}{2})/n\\,\\big)\\,$。分析以索引为 $\\,(\\,i_0,j_0\\,) = (\\,\\lfloor n/2 \\rfloor, \\lfloor n/2 \\rfloor\\,) = (\\,8,8\\,)\\,$ 的单元为中心，其对应的线性索引为 $\\,c_0 = 8 \\cdot 16 + 8 = 136\\,$。\n\n**2. 正演算子 $\\,\\mathbf{G}\\,$**\n正演问题由线性系统 $\\,\\mathbf{d} = \\mathbf{G}\\,\\mathbf{m}\\,$ 描述，其中 $\\,\\mathbf{G}\\,$ 是灵敏度矩阵。条目 $\\,G_{r,c}\\,$ 表示射线 $\\,r\\,$ 穿过单元 $\\,c\\,$ 的路径长度。这通过在每条射线上以 $\\,S=200\\,$ 个等距点进行采样来近似。对于从 $\\,\\mathbf{p}_0\\,$ 到 $\\,\\mathbf{p}_1\\,$ 的长度为 $\\,\\ell\\,$ 的射线段，每个采样点代表一个长度为 $\\,\\Delta s = \\ell/S\\,$ 的路径段。对于落在域内的每个采样点 $\\,\\mathbf{p}=(x,y)\\,$，相应的单元索引由 $\\,j = \\lfloor x \\cdot n \\rfloor\\,$ 和 $\\,i = \\lfloor y \\cdot n \\rfloor\\,$ 确定。然后将值 $\\,\\Delta s\\,$ 加到条目 $\\,G_{r,c}\\,$ 中，其中 $\\,c = i \\cdot n + j\\,$。射线按规定被组织成族，并为每个测试用例的射线集构建矩阵 $\\,\\mathbf{G}\\,$。\n\n**3. 平滑算子 $\\,\\mathbf{L}\\,$**\n引入二次平滑惩罚项 $\\,\\lVert \\mathbf{L}\\,\\mathbf{m}\\rVert_2^2\\,$ 来对解进行正则化。算子 $\\,\\mathbf{L}\\,$ 通过惩罚相邻单元值之间的一阶差分来强制平滑。它被构建为一个稀疏矩阵，其中每一行对应于一对相邻单元之间的差分。\n- 对于位于 $\\,(\\,i, j-1\\,)\\,$ 和 $\\,(\\,i, j\\,)\\,$ 的水平单元对，在 $\\,\\mathbf{L}\\,$ 中创建一行，在对应这些单元的列上分别具有条目 $\\,-w_x\\,$ 和 $\\,+w_x\\,$。这对所有的 $\\,i \\in \\{0, \\dots, n-1\\}\\,$ 和 $\\,j \\in \\{1, \\dots, n-1\\}\\,$ 执行。\n- 对于位于 $\\,(\\,i-1, j\\,)\\,$ 和 $\\,(\\,i, j\\,)\\,$ 的垂直单元对，在 $\\,\\mathbf{L}\\,$ 中创建一行，在相应的列上具有条目 $\\,-w_y\\,$ 和 $\\,+w_y\\,$。这对所有的 $\\,i \\in \\{1, \\dots, n-1\\}\\,$ 和 $\\,j \\in \\{0, \\dots, n-1\\}\\,$ 执行。\n权重 $\\,w_x\\,$ 和 $\\,w_y\\,$ 控制平滑各向异性的程度。\n\n**4. 正则化最小二乘估计与点扩散函数 (PSF)**\n估计模型 $\\,\\widehat{\\mathbf{m}}\\,$ 是通过最小化目标函数找到的：\n$$ J(\\mathbf{m}) = \\lVert \\mathbf{G}\\,\\mathbf{m} - \\mathbf{d} \\rVert_2^2 + \\lambda^2 \\lVert \\mathbf{L}\\,\\mathbf{m} \\rVert_2^2 $$\n最小化器是正规方程组的解：\n$$ (\\mathbf{G}^T\\mathbf{G} + \\lambda^2 \\mathbf{L}^T\\mathbf{L})\\,\\widehat{\\mathbf{m}} = \\mathbf{G}^T\\mathbf{d} $$\n目标单元 $\\,c_0\\,$ 处的点扩散函数 (PSF) 定义为当真实模型是 delta 函数 $\\,\\mathbf{m}_{\\text{true}} = \\mathbf{e}_{c_0}\\,$ 时的估计模型 $\\,\\widehat{\\mathbf{m}}\\,$，其中 $\\,\\mathbf{e}_{c_0}\\,$ 是在索引 $\\,c_0\\,$ 处为 $\\,1\\,$ 且在其他位置为零的规范基向量。该模型的合成数据为 $\\,\\mathbf{d} = \\mathbf{G}\\,\\mathbf{e}_{c_0} = \\mathbf{g}_{c_0}\\,$，其中 $\\,\\mathbf{g}_{c_0}\\,$ 是 $\\,\\mathbf{G}\\,$ 的第 $\\,c_0\\,$ 列。因此，我们表示为 $\\,\\widehat{\\mathbf{m}}_{\\text{psf}}\\,$ 的 PSF 是通过求解以下方程获得的：\n$$ (\\mathbf{G}^T\\mathbf{G} + \\lambda^2 \\mathbf{L}^T\\mathbf{L})\\,\\widehat{\\mathbf{m}}_{\\text{psf}} = \\mathbf{G}^T\\mathbf{g}_{c_0} $$\n对于每个测试用例，求解此线性系统以获得 $\\,\\widehat{\\mathbf{m}}_{\\text{psf}}\\,$。\n\n**5. 各向异性量化**\n分析 PSF 的空间扩散以确定其各向异性。计算加权二阶矩张量 $\\,\\mathbf{M}\\,$。每个单元 $\\,k\\,$ 的权重由 PSF 值的平方给出，即 $\\,w_k = (\\widehat{m}_{\\text{psf}, k})^2\\,$。张量分量是相对于目标单元的中心 $\\,(\\,x_c, y_c\\,)\\,$ 计算的：\n$$ \\mathbf{M} = \\frac{1}{\\sum_k w_k} \\sum_k w_k \\begin{bmatrix} (\\Delta x_k)^2  \\Delta x_k \\Delta y_k \\\\ \\Delta x_k \\Delta y_k  (\\Delta y_k)^2 \\end{bmatrix} $$\n其中 $\\,\\Delta x_k = x_k - x_c\\,$ 和 $\\,\\Delta y_k = y_k - y_c\\,$。这个 $\\,2 \\times 2\\,$ 对称张量的特征值 $\\,\\mu_{\\max}\\,$ 和 $\\,\\mu_{\\min}\\,$ 表示扩散沿其主轴的方差。各向异性比率 $\\,\\rho\\,$ 定义为：\n$$ \\rho = \\sqrt{\\frac{\\mu_{\\max}}{\\mu_{\\min} + \\epsilon}} $$\n其中 $\\,\\epsilon = 10^{-12}\\,$ 以防止除以零。$\\,\\rho \\approx 1\\,$ 的值表示各向同性（圆形）扩散，而 $\\,\\rho  1\\,$ 表示各向异性（拉长）扩散。\n\n将此完整过程应用于四个指定的测试用例中的每一个，并计算和报告所得的各向异性比率。", "answer": "```python\nimport numpy as np\n\ndef build_ray_families(n):\n    \"\"\"\n    Defines the 6 ray families based on the problem description for a grid of size n.\n    \"\"\"\n    k_vals = [1, 3, 5, 7, 9, 11, 13, 15]\n    \n    families = {\n        \"LR_hor\": [], \"LR_pos\": [], \"LR_neg\": [],\n        \"BT_ver\": [], \"BT_pos\": [], \"BT_neg\": []\n    }\n\n    # Left-to-Right families\n    y0_vals = [k / n for k in k_vals]\n    for y0 in y0_vals:\n        # LR_hor\n        families[\"LR_hor\"].append((np.array([0.0, y0]), np.array([1.0, y0])))\n        # LR_pos\n        families[\"LR_pos\"].append((np.array([0.0, y0]), np.array([1.0, min(1.0, y0 + 0.4)])))\n        # LR_neg\n        families[\"LR_neg\"].append((np.array([0.0, y0]), np.array([1.0, max(0.0, y0 - 0.4)])))\n\n    # Bottom-to-Top families\n    x0_vals = [k / n for k in k_vals]\n    for x0 in x0_vals:\n        # BT_ver\n        families[\"BT_ver\"].append((np.array([x0, 0.0]), np.array([x0, 1.0])))\n        # BT_pos\n        families[\"BT_pos\"].append((np.array([x0, 0.0]), np.array([min(1.0, x0 + 0.4), 1.0])))\n        # BT_neg\n        families[\"BT_neg\"].append((np.array([x0, 0.0]), np.array([max(0.0, x0 - 0.4), 1.0])))\n        \n    return families\n\ndef build_G(rays, n, S):\n    \"\"\"\n    Constructs the sensitivity matrix G by sampling rays.\n    \"\"\"\n    num_rays = len(rays)\n    N = n * n\n    G = np.zeros((num_rays, N))\n    \n    for r_idx, (p0, p1) in enumerate(rays):\n        length = np.linalg.norm(p1 - p0)\n        if length == 0:\n            continue\n        ds = length / S\n        direction_vec = (p1 - p0)\n        \n        for s in range(S):\n            # Sample point at the midpoint of the sub-segment\n            p = p0 + (s + 0.5) * direction_vec / S\n            x, y = p\n            \n            # Assign path length ds to the cell containing the sample point\n            if 0 = x  1.0 and 0 = y  1.0:\n                j = int(x * n)\n                i = int(y * n)\n                c_idx = i * n + j\n                G[r_idx, c_idx] += ds\n                \n    return G\n\ndef build_L(n, wx, wy):\n    \"\"\"\n    Constructs the first-order difference smoothing operator L.\n    \"\"\"\n    N = n * n\n    num_horiz_diffs = n * (n - 1)\n    num_vert_diffs = n * (n - 1)\n    L = np.zeros((num_horiz_diffs + num_vert_diffs, N))\n    \n    row_idx = 0\n    # Horizontal differences\n    for i in range(n):\n        for j in range(1, n):\n            c1 = i * n + j\n            c2 = i * n + (j - 1)\n            L[row_idx, c1] = wx\n            L[row_idx, c2] = -wx\n            row_idx += 1\n            \n    # Vertical differences\n    for i in range(1, n):\n        for j in range(n):\n            c1 = i * n + j\n            c2 = (i - 1) * n + j\n            L[row_idx, c1] = wy\n            L[row_idx, c2] = -wy\n            row_idx += 1\n            \n    return L\n    \ndef calculate_anisotropy(m_hat, n, i0, j0, epsilon):\n    \"\"\"\n    Computes the anisotropy ratio rho for a given point-spread function m_hat.\n    \"\"\"\n    N = n * n\n    \n    # Center of the analysis cell (c_0)\n    xc = (j0 + 0.5) / n\n    yc = (i0 + 0.5) / n\n    \n    # All cell center coordinates\n    j_coords = np.tile(np.arange(n), n)\n    i_coords = np.repeat(np.arange(n), n)\n    x_k = (j_coords + 0.5) / n\n    y_k = (i_coords + 0.5) / n\n    \n    # Displacements from the center\n    dx_k = x_k - xc\n    dy_k = y_k - yc\n    \n    # Weights for second-moment tensor are the squared PSF values\n    w_k = m_hat**2\n    w_sum = np.sum(w_k)\n    \n    if w_sum = 1e-15: # Effectively zero, spread is undefined\n        return 1.0 # Default to isotropic\n        \n    # Second-moment tensor M\n    M = np.zeros((2, 2))\n    M[0, 0] = np.sum(w_k * dx_k**2) / w_sum\n    M[1, 1] = np.sum(w_k * dy_k**2) / w_sum\n    M[0, 1] = M[1, 0] = np.sum(w_k * dx_k * dy_k) / w_sum\n    \n    # Eigenvalues of M\n    eigvals = np.linalg.eigvalsh(M)\n    mu_min, mu_max = eigvals[0], eigvals[1]\n    \n    # Anisotropy ratio rho\n    rho = np.sqrt(mu_max / (mu_min + epsilon))\n    \n    return rho\n\ndef solve():\n    \"\"\"\n    Main function to run the four test cases and compute anisotropy ratios.\n    \"\"\"\n    n = 16\n    S = 200\n    i0, j0 = 8, 8\n    c0 = i0 * n + j0\n    epsilon = 1e-12\n    \n    all_ray_families = build_ray_families(n)\n    \n    test_cases = [\n        {\"families\": [\"LR_hor\", \"LR_pos\", \"LR_neg\", \"BT_ver\", \"BT_pos\", \"BT_neg\"], \"wx\": 1.0, \"wy\": 1.0, \"lambda_val\": 0.1},\n        {\"families\": [\"BT_ver\"], \"wx\": 1.0, \"wy\": 1.0, \"lambda_val\": 0.1},\n        {\"families\": [\"LR_hor\", \"LR_pos\", \"LR_neg\", \"BT_ver\", \"BT_pos\", \"BT_neg\"], \"wx\": 1.0, \"wy\": 1.0, \"lambda_val\": 1.0},\n        {\"families\": [\"LR_hor\", \"LR_pos\", \"LR_neg\", \"BT_ver\", \"BT_pos\", \"BT_neg\"], \"wx\": 5.0, \"wy\": 1.0, \"lambda_val\": 0.1},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # 1. Setup rays and build the sensitivity matrix G\n        rays = []\n        for fam_name in case[\"families\"]:\n            rays.extend(all_ray_families[fam_name])\n        G = build_G(rays, n, S)\n        \n        # 2. Build the smoothing operator L\n        L = build_L(n, case[\"wx\"], case[\"wy\"])\n        \n        # 3. Form and solve the normal equations for the Point-Spread Function (PSF)\n        lambda_sq = case[\"lambda_val\"]**2\n        \n        # System matrix A = G^T G + lambda^2 L^T L\n        A = G.T @ G + lambda_sq * (L.T @ L)\n        \n        # Right-hand side b = G^T g_{c0}, where g_{c0} is the c0-th column of G\n        g_c0 = G[:, c0]\n        b = G.T @ g_c0\n        \n        # Solve A * m_hat = b for the PSF m_hat\n        m_hat = np.linalg.solve(A, b)\n        \n        # 4. Calculate the anisotropy ratio rho\n        rho = calculate_anisotropy(m_hat, n, i0, j0, epsilon)\n        results.append(rho)\n        \n    # Format and print the final results as specified\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```", "id": "3613732"}, {"introduction": "棋盘格测试是另一种广泛使用的工具，用于评估反演设置解析特定尺寸特征的能力。最后一个练习 [@problem_id:3613703] 将这个经典测试与模型分辨率矩阵的显式结构联系起来。通过实施棋盘格测试，并将其恢复质量与从 $R_m$ 的对角和非对角带导出的度量进行比较，您将更深刻地体会到矩阵元素如何直接对应于最终模型中的模糊和平均伪影。", "problem": "考虑一个计算地球物理学中的线性反演问题，其空间分布的模型向量 $m \\in \\mathbb{R}^{N}$ 定义在一个大小为 $N_x \\times N_z$ 的均匀二维网格上，因此 $N = N_x N_z$。数据由 $d \\in \\mathbb{R}^{N}$ 表示，并由一个线性正演算子 $G \\in \\mathbb{R}^{N \\times N}$ 加上加性噪声 $e$ 生成，遵循经过充分检验的观测模型 $d = G m + e$。对于棋盘格测试，假设噪声为零，即 $e = 0$。使用一个带有稳定化算子 $L \\in \\mathbb{R}^{M \\times N}$ 和正则化权重 $\\lambda \\ge 0$ 的 Tikhonov 正则化最小二乘估计器，从无噪声数据 $d = G m_{\\text{true}}$ 中估计模型。目标是通过显式地构建模型分辨率矩阵来进行分辨率分析，并量化棋盘格恢复度量如何与模型分辨率矩阵中非对角带的范数相关联。\n\n您的推导必须仅基于以下基本要素，并且不得引入除此之外的任何额外假设：\n- 线性观测模型 $d = G m + e$，对于棋盘格测试，$e=0$。\n- Tikhonov 正则化最小二乘估计器，定义为 $J(m) = \\|G m - d\\|_2^2 + \\lambda^2 \\|L m\\|_2^2$（$\\lambda \\ge 0$）的最小化子。\n- 模型分辨率矩阵 $R_m$ 的定义，即当 $d = G m_{\\text{true}}$ 时，将 $m_{\\text{true}}$ 映射到无噪声估计 $\\hat{m}$ 的确定性线性算子。\n\n您必须在程序中实现以下内容：\n- 构建一个具有 $N_x$ 列和 $N_z$ 行的二维网格。使用线性索引 $i = i_z N_x + i_x$ 按字典序对模型向量 $m$ 进行索引，其中 $i_x \\in \\{0,\\dots,N_x - 1\\}$ 且 $i_z \\in \\{0,\\dots,N_z - 1\\}$。\n- 定义正演算子 $G$，以表示在一个边长为 $w$ 个单元（假设 $w$ 是奇数正整数）的中心方形窗口内对模型进行的局部空间平均。对于对应于网格单元 $(i_x,i_z)$ 的每个数据位置，$G$ 的行对所有满足 $|j_x - i_x| \\le (w-1)/2$ 和 $|j_z - i_z| \\le (w-1)/2$ 的模型单元 $(j_x,j_z)$ 进行平均，并限制在网格边界内。该行中每个平均权重必须相等且总和为 $1$。\n- 定义正则化算子 $L$ 为沿 $x$ 和 $z$ 方向的一阶前向有限差分的串联，即 $L$ 的行表示对所有 $x$ 方向的有效对形如 $m(i_x{+}1,i_z) - m(i_x,i_z)$ 的项，以及对所有 $z$ 方向的有效对形如 $m(i_x,i_z{+}1) - m(i_x,i_z)$ 的项。\n- 在 $e=0$ 的条件下，为 Tikhonov 正则化估计器推导并计算模型分辨率矩阵 $R_m$。然后，对于由 $m_{\\text{true}}(i_x,i_z) = (-1)^{i_x + i_z}$ 定义的棋盘格，计算恢复的棋盘格模型 $\\hat{m} = R_m m_{\\text{true}}$。\n- 定义棋盘格振幅恢复度量 $A$ 为标量\n$$\nA = \\frac{m_{\\text{true}}^\\top \\hat{m}}{m_{\\text{true}}^\\top m_{\\text{true}}}.\n$$\n- 使用常数索引偏移 $\\pm 1$ 和 $\\pm N_x$ 定义 $R_m$ 中对应于水平和垂直最近邻的非对角带。为尊重二维几何结构，在使用 $\\pm 1$ 偏移时，排除跨行边界的环绕耦合；仅包括 $j=i+1$ 且 $(i \\bmod N_x) \\ne N_x - 1$ 的对 $(i,j)$，以及 $j=i-1$ 且 $(i \\bmod N_x) \\ne 0$ 的对。对于 $\\pm N_x$ 偏移，仅包括有效的网格内垂直邻居。令 $B$ 表示这些非对角元素的集合。\n- 设对角线幅度为 $D_1 = \\sum_{i=0}^{N-1} |(R_m)_{ii}|$，双边最近邻带幅度为 $B_1 = \\sum_{(i,j)\\in B} |(R_m)_{ij}|$。构建带比率 $r = B_1 / D_1$ 和基于带的预测器 $\\tilde{A} = 1 - r$。\n- 对于每个测试用例，将绝对差异 $|A - \\tilde{A}|$ 报告为一个浮点数。\n\n测试套件：\n- 情况 1：$N_x = 8$, $N_z = 8$, $w = 1$, $\\lambda = 0.0$。\n- 情况 2：$N_x = 8$, $N_z = 8$, $w = 3$, $\\lambda = 0.5$。\n- 情况 3：$N_x = 8$, $N_z = 8$, $w = 5$, $\\lambda = 1.5$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试套件的三个结果，格式为逗号分隔的列表并用方括号括起，例如 $[x_1,x_2,x_3]$，其中每个 $x_k$ 是情况 $k$ 的绝对差异 $|A - \\tilde{A}|$。不涉及角度，也不需要物理单位。每个 $x_k$ 必须是浮点数。", "solution": "目标是为一个计算地球物理学中的线性反演问题进行分辨率分析。这涉及到为 Tikhonov 正则化最小二乘问题推导模型分辨率矩阵，然后用它来量化棋盘格测试恢复的质量。\n\n问题的核心在于找到一个估计模型 $\\hat{m}$，使其最小化 Tikhonov 目标函数 $J(m)$：\n$$\nJ(m) = \\|G m - d\\|_2^2 + \\lambda^2 \\|L m\\|_2^2\n$$\n其中 $d \\in \\mathbb{R}^N$ 是数据向量，$m \\in \\mathbb{R}^N$ 是模型向量，$G \\in \\mathbb{R}^{N \\times N}$ 是正演算子，$L \\in \\mathbb{R}^{M \\times N}$ 是正则化算子，$\\lambda \\ge 0$ 是正则化权重。\n\n为了找到最小化子 $\\hat{m}$，我们计算 $J(m)$ 关于 $m$ 的梯度并将其设为零。目标函数可以用向量转置的形式写出：\n$$\nJ(m) = (G m - d)^\\top (G m - d) + \\lambda^2 (L m)^\\top (L m)\n$$\n展开此表达式得到：\n$$\nJ(m) = m^\\top G^\\top G m - 2d^\\top G m + d^\\top d + \\lambda^2 m^\\top L^\\top L m\n$$\n关于 $m$ 的梯度是：\n$$\n\\nabla_m J(m) = 2 G^\\top G m - 2 G^\\top d + 2 \\lambda^2 L^\\top L m\n$$\n将梯度设为零，$\\nabla_m J(m) = 0$，得到正规方程：\n$$\n(G^\\top G + \\lambda^2 L^\\top L) m = G^\\top d\n$$\n求解该系统的估计模型 $\\hat{m}$ 是：\n$$\n\\hat{m} = (G^\\top G + \\lambda^2 L^\\top L)^{-1} G^\\top d\n$$\n此表达式为任何给定的数据向量 $d$ 提供了估计模型。\n\n问题要求基于无噪声的棋盘格测试进行分辨率分析。在这种情况下，数据由已知的真实模型 $m_{\\text{true}}$ 生成且无噪声（$e=0$），因此 $d = G m_{\\text{true}}$。将此代入 $\\hat{m}$ 的方程中：\n$$\n\\hat{m} = (G^\\top G + \\lambda^2 L^\\top L)^{-1} G^\\top (G m_{\\text{true}})\n$$\n这可以写成：\n$$\n\\hat{m} = \\left[ (G^\\top G + \\lambda^2 L^\\top L)^{-1} G^\\top G \\right] m_{\\text{true}}\n$$\n根据定义，模型分辨率矩阵 $R_m$ 是关联真实模型与估计模型的线性算子，$\\hat{m} = R_m m_{\\text{true}}$。因此，我们确定模型分辨率矩阵为：\n$$\nR_m = (G^\\top G + \\lambda^2 L^\\top L)^{-1} G^\\top G\n$$\n理想的分辨率矩阵是单位矩阵，$R_m = I$，这意味着完美恢复，$\\hat{m} = m_{\\text{true}}$。偏离单位矩阵表示不完美的分辨率，其中某一点的估计值是周围点真实值的加权平均。\n\n每个测试用例的计算实现步骤如下：\n1.  **网格与模型设置**：定义一个大小为 $N_x \\times N_z$ 的二维网格，模型参数按字典序排列成一个大小为 $N = N_x N_z$ 的向量。为棋盘格测试构建真实模型，即一个向量 $m_{\\text{true}}$，其中网格单元 $(i_x, i_z)$ 处的值为 $m_{\\text{true}}(i_x, i_z) = (-1)^{i_x + i_z}$。\n\n2.  **算子构建**：\n    - 正演算子 $G$ 是一个 $N \\times N$ 矩阵。每一行 $i$ 对应于网格单元 $(i_x, i_z)$ 处的一个数据点。该行中的非零项对应于以 $(i_x, i_z)$ 为中心、边长为 $w$ 的方形窗口内的模型单元 $(j_x, j_z)$。这些项的值是 $1/k$，其中 $k$ 是窗口内的单元数（考虑边界截断）。对于 $w=1$，$G$ 是单位矩阵。\n    - 正则化算子 $L$ 通过堆叠两个矩阵构建：$L_x$ 用于 $x$ 方向的一阶前向差分，和 $L_z$ 用于 $z$ 方向的差分。这些可以使用单位矩阵和一维差分矩阵的 Kronecker 积优雅地形成。\n\n3.  **分辨率矩阵与模型恢复**：\n    - 定义了 $G$、$L$ 和 $\\lambda$ 后，我们计算矩阵 $H = G^\\top G + \\lambda^2 L^\\top L$。\n    - 模型分辨率矩阵则为 $R_m = H^{-1} (G^\\top G)$。\n    - 计算恢复的棋盘格模型为 $\\hat{m} = R_m m_{\\text{true}}$。\n\n4.  **度量计算**：\n    - 棋盘格振幅恢复度量 $A$ 计算为 $A = (m_{\\text{true}}^\\top \\hat{m}) / (m_{\\text{true}}^\\top m_{\\text{true}})$。由于 $m_{\\text{true}}^\\top m_{\\text{true}} = N$，这简化为 $A = (m_{\\text{true}} \\cdot \\hat{m}) / N$。\n    - 对角线幅度 $D_1$ 是 $R_m$ 对角线元素绝对值的总和：$D_1 = \\sum_{i=0}^{N-1} |(R_m)_{ii}|$。\n    - 最近邻非对角带幅度 $B_1$ 是 $R_m$ 中对应于最近邻对（水平和垂直）的元素绝对值的总和：$B_1 = \\sum_{(i, j) \\in B} |(R_m)_{ij}|$，其中 $B$ 是最近邻的索引对集合。\n    - 计算带比率 $r = B_1 / D_1$ 和基于带的预测器 $\\tilde{A} = 1 - r$。\n    - 最后，计算并报告每个情况的绝对差异 $|A - \\tilde{A}|$。\n\n该过程应用于三个指定的测试用例，这些用例探索了不同水平的正演模型模糊（$w$）和正则化强度（$\\lambda$）。当 $w=1$ 且 $\\lambda=0$ 时，对应于完美数据且无正则化的情况，我们期望完美恢复（$A=1$）和完美预测（$\\tilde{A}=1$），从而产生 0 的差异。其他情况将测试预测器 $\\tilde{A}$ 在非理想条件下的鲁棒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef construct_G_operator(Nx, Nz, w):\n    \"\"\"Constructs the forward operator G for local spatial averaging.\"\"\"\n    N = Nx * Nz\n    G = np.zeros((N, N))\n    half_w = (w - 1) // 2\n\n    for i in range(N):\n        ix = i % Nx\n        iz = i // Nx\n        \n        # Determine the window bounds\n        ix_min = max(0, ix - half_w)\n        ix_max = min(Nx - 1, ix + half_w)\n        iz_min = max(0, iz - half_w)\n        iz_max = min(Nz - 1, iz + half_w)\n\n        count = 0\n        indices = []\n        for jz in range(iz_min, iz_max + 1):\n            for jx in range(ix_min, ix_max + 1):\n                j = jz * Nx + jx\n                indices.append(j)\n                count += 1\n        \n        if count > 0:\n            avg_weight = 1.0 / count\n            for j in indices:\n                G[i, j] = avg_weight\n    return G\n\ndef construct_L_operator(Nx, Nz):\n    \"\"\"Constructs the regularization operator L using Kronecker products.\"\"\"\n    # 1D finite difference matrix (forward)\n    def diff_matrix(n):\n        D = np.eye(n - 1, n, k=1) - np.eye(n - 1, n, k=0)\n        return D\n\n    Dx = diff_matrix(Nx)\n    Dz = diff_matrix(Nz)\n    \n    # Kronecker products to form 2D difference operators\n    # Lx for differences along x-axis for each z-row\n    Lx = np.kron(np.eye(Nz), Dx)\n    # Lz for differences along z-axis for each x-column\n    Lz = np.kron(Dz, np.eye(Nx))\n    \n    # Concatenate to form the full L operator\n    L = np.vstack([Lx, Lz])\n    return L\n\ndef calculate_band_magnitude(R_m, Nx, Nz):\n    \"\"\"Computes the nearest-neighbor off-diagonal band magnitude B1.\"\"\"\n    N = Nx * Nz\n    B1 = 0.0\n    for i in range(N):\n        ix = i % Nx\n        iz = i // Nx\n\n        # Right neighbor\n        if ix  Nx - 1:\n            j = i + 1\n            B1 += np.abs(R_m[i, j])\n            \n        # Left neighbor\n        if ix > 0:\n            j = i - 1\n            B1 += np.abs(R_m[i, j])\n\n        # Down neighbor\n        if iz  Nz - 1:\n            j = i + Nx\n            B1 += np.abs(R_m[i, j])\n\n        # Up neighbor\n        if iz > 0:\n            j = i - Nx\n            B1 += np.abs(R_m[i, j])\n            \n    # The problem asks for the sum over entries in the two-sided band.\n    # The loop above iterates over directed edges (i,j) for neighbors.\n    # An alternative is `sum_{j > i, neighbors} |R_ij| + |R_ji|`.\n    # Let's consider the problem statement \"sum over (i,j) in B |(Rm)ij|\"\n    # where B is defined by the four neighbor types.\n    # The sum should be over pairs, but my loop over directed graph edges\n    # sums over pairs twice if the matrix is symmetric. Rm is not always symmetric.\n    # My loop structure calculates sum_{i} sum_{j in N(i)} |R_ij|, which is what is asked.\n    # Example: B includes (i,i+1) and (i+1,i). My loop adds |R_i,i+1| at step i and |R_i+1,i| at step i+1.\n    # This seems correct for non-symmetric matrices.\n    \n    B1_asymmetric = 0.0\n    for i in range(N):\n        ix = i % Nx\n        iz = i // Nx\n\n        # Right neighbor (i, i+1)\n        if ix  Nx - 1:\n            j = i + 1\n            B1_asymmetric += np.abs(R_m[i, j])\n        # Left neighbor (i, i-1)\n        # This pair is (i-1, i), which is covered when the loop is at i-1.\n        # Let's be very careful.\n        # \"Let B denote the set of these off-diagonal entries\". And \"sum over (i,j) in B\".\n        # This suggests B is a set of index pairs.\n        # My loop computes Sum_i Sum_{j in Neigh(i)} |R_ij|, which is what is asked.\n        # This seems correct for non-symmetric matrices.\n    \n    return B1\n    \n\ndef solve():\n    \"\"\"Main function to solve the problem for all test cases.\"\"\"\n    test_cases = [\n        # (Nx, Nz, w, lambda)\n        (8, 8, 1, 0.0),\n        (8, 8, 3, 0.5),\n        (8, 8, 5, 1.5),\n    ]\n\n    results = []\n    for Nx, Nz, w, lam in test_cases:\n        N = Nx * Nz\n\n        # 1. Construct operators and true model\n        G = construct_G_operator(Nx, Nz, w)\n        L = construct_L_operator(Nx, Nz)\n        \n        m_true = np.zeros(N)\n        for i in range(N):\n            ix = i % Nx\n            iz = i // Nx\n            m_true[i] = (-1)**(ix + iz)\n            \n        # 2. Compute model resolution matrix Rm\n        G_T_G = G.T @ G\n        L_T_L = L.T @ L\n        H = G_T_G + lam**2 * L_T_L\n        H_inv = np.linalg.inv(H)\n        R_m = H_inv @ G_T_G\n\n        # 3. Compute recovered model and recovery metric A\n        m_hat = R_m @ m_true\n        A = (m_true.T @ m_hat) / (m_true.T @ m_true)\n        \n        # 4. Compute band magnitudes and predictor A_tilde\n        D1 = np.sum(np.abs(np.diag(R_m)))\n        B1 = calculate_band_magnitude(R_m, Nx, Nz)\n        \n        r = B1 / D1 if D1 != 0 else 0\n        A_tilde = 1.0 - r\n        \n        # 5. Calculate and store the final discrepancy\n        discrepancy = np.abs(A - A_tilde)\n        results.append(discrepancy)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```", "id": "3613703"}]}