{"hands_on_practices": [{"introduction": "在地球物理学的大规模并行模拟中，数值稳定性约束（如CFL条件）必须在所有并行处理单元上得到满足，这通常需要跨进程同步。这项实践将引导您在一个并行波传播模拟的背景下，推导全局稳定的时间步长，并为其所需的同步开销建立性能模型。通过这个练习，您将深入理解数值算法与混合并行计算（共享内存与消息传递）性能成本之间的相互作用 [@problem_id:3614221]。", "problem": "异质介质中的一维声波 $u(x,t)$ 满足偏微分方程 $\\partial_{t}^{2} u = c(x)^{2}\\,\\partial_{x}^{2} u$。考虑一个在分布式内存计算机上应用的显式、中心、时空二阶精度的有限差分格式，该计算机使用混合并行化：$P$ 个分布式内存进程 (rank)，每个 rank 内部使用多线程。Rank $i$ 在其局部子域上以均匀网格间距 $\\Delta x_{i}$ 进行推进，并且由于介质的异质性，使用波速的局部本性上确界 $c_{i} \\equiv \\operatorname{ess\\,sup}_{x \\in \\Omega_{i}} c(x)$ 来保证稳定性。所有 rank 都使用单一的全局时间步长 $\\Delta t$ 进行推进。\n\n假设采用自适应时间步长方案，在每个时间步中，每个 rank 使用其线程间的共享内存并行规约计算 rank 局部的稳定时间步长上界（每步产生一个 rank 内部的壁垒成本 $\\tau_{b}$），然后所有 rank 通过对每个 rank 的一个标量进行消息传递全局最小化来协同确定全局上界。将 rank 间的集体通信建模为一次基于树的规约和一次广播，每次操作都包含 $\\lceil \\log_{2} P \\rceil$ 个阶段，每个阶段的点对点通信成本遵循 Hockney 模型，为 $\\alpha + \\beta s$，其中 $\\alpha$ 是延迟，$\\beta$ 是逆带宽，$s$ 是一个标量的有效载荷大小（以字节为单位）。\n\n从控制方程、给定的离散化选择以及线性傅里叶 (von Neumann) 稳定性分析出发，推导：\n- 最大的全局稳定时间步长 $\\Delta t^{\\star}$，用 $\\{ \\Delta x_{i} \\}_{i=1}^{P}$ 和 $\\{ c_{i} \\}_{i=1}^{P}$ 表示；以及\n- 每个时间步的总同步成本 $T_{\\mathrm{sync}}$ 的估算值，该成本包括 rank 内共享内存壁垒和 rank 间集体通信，用 $P$、$\\alpha$、$\\beta$、$s$ 和 $\\tau_{b}$ 表示。\n\n将您的最终结果以单个解析表达式的形式给出，该表达式为一个行矩阵，其元素为 $\\Delta t^{\\star}$ 和 $T_{\\mathrm{sync}}$。不要代入数值。不要在最终的方框答案中包含单位。", "solution": "问题要求推导一维声波方程并行有限差分模拟中的两个量：最大全局稳定时间步长 $\\Delta t^{\\star}$ 和每个时间步的总同步成本 $T_{\\mathrm{sync}}$。推导过程分为两部分。\n\n首先，我们推导数值格式的稳定性条件。控制偏微分方程为：\n$$\n\\partial_{t}^{2} u = c(x)^{2}\\,\\partial_{x}^{2} u\n$$\n问题指定了一个在时间和空间上都是显式、中心、二阶精度的有限差分格式。令 $u^{n}_{j}$ 表示在网格点 $x_j = j\\Delta x$ 和时间 $t_n = n\\Delta t$ 处 $u(x, t)$ 的数值近似。导数的二阶中心差分近似为：\n$$\n\\partial_{t}^{2} u \\Big|_{j, n} \\approx \\frac{u^{n+1}_{j} - 2u^{n}_{j} + u^{n-1}_{j}}{(\\Delta t)^{2}}\n$$\n$$\n\\partial_{x}^{2} u \\Big|_{j, n} \\approx \\frac{u^{n}_{j+1} - 2u^{n}_{j} + u^{n}_{j-1}}{(\\Delta x)^{2}}\n$$\n将这些近似代入波动方程，使用局部波速 $c$ 和网格间距 $\\Delta x$，得到离散更新方程：\n$$\n\\frac{u^{n+1}_{j} - 2u^{n}_{j} + u^{n-1}_{j}}{(\\Delta t)^{2}} = c^{2} \\frac{u^{n}_{j+1} - 2u^{n}_{j} + u^{n}_{j-1}}{(\\Delta x)^{2}}\n$$\n为了分析该格式的稳定性，我们进行 von Neumann 稳定性分析。我们考虑一个形式为 $u^{n}_{j} = \\xi^{n} e^{i k j \\Delta x}$ 的解的傅里叶单模，其中 $k$ 是波数，$\\xi$ 是放大因子。将此代入差分方程，得到：\n$$\n\\frac{\\xi^{n+1} e^{i k j \\Delta x} - 2\\xi^{n} e^{i k j \\Delta x} + \\xi^{n-1} e^{i k j \\Delta x}}{(\\Delta t)^{2}} = c^{2} \\frac{\\xi^{n} e^{i k (j+1) \\Delta x} - 2\\xi^{n} e^{i k j \\Delta x} + \\xi^{n} e^{i k (j-1) \\Delta x}}{(\\Delta x)^{2}}\n$$\n两边同除以 $\\xi^{n-1} e^{i k j \\Delta x}$ 可简化表达式：\n$$\n\\frac{\\xi^{2} - 2\\xi + 1}{(\\Delta t)^{2}} = c^{2} \\frac{\\xi (e^{i k \\Delta x} - 2 + e^{-i k \\Delta x})}{(\\Delta x)^{2}}\n$$\n使用恒等式 $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$，我们可以写出 $e^{i k \\Delta x} - 2 + e^{-i k \\Delta x} = 2\\cos(k \\Delta x) - 2$。进一步地，利用半角公式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$，此式变为 $-4\\sin^2(k\\Delta x / 2)$。现在的方程是：\n$$\n\\xi^{2} - 2\\xi + 1 = \\left( \\frac{c \\Delta t}{\\Delta x} \\right)^{2} \\xi \\left(-4\\sin^2\\left(\\frac{k\\Delta x}{2}\\right)\\right)\n$$\n令 $C = \\frac{c \\Delta t}{\\Delta x}$ 为 Courant 数。整理各项得到关于放大因子 $\\xi$ 的二次方程：\n$$\n\\xi^{2} - \\left( 2 - 4C^{2}\\sin^2\\left(\\frac{k\\Delta x}{2}\\right) \\right)\\xi + 1 = 0\n$$\n为使格式稳定，放大因子的模必须对所有波数 $k$ 满足 $|\\xi| \\le 1$。二次方程 $A\\xi^2 + B\\xi + C_{_0}=0$ 的根的模小于等于1的条件是其判别式为非正。此处的判别式为 $\\mathcal{D} = \\left( 2 - 4C^{2}\\sin^2\\left(\\frac{k\\Delta x}{2}\\right) \\right)^2 - 4$。为保证稳定性 ($|\\xi|=1$)，我们要求 $\\mathcal{D} \\le 0$：\n$$\n\\left( 2 - 4C^{2}\\sin^2\\left(\\frac{k\\Delta x}{2}\\right) \\right)^2 \\le 4\n$$\n$$\n-2 \\le 2 - 4C^{2}\\sin^2\\left(\\frac{k\\Delta x}{2}\\right) \\le 2\n$$\n不等式的右边 $-4C^{2}\\sin^2(k\\Delta x/2) \\le 0$ 总是成立的。不等式的左边给出了稳定性条件：\n$$\n-2 \\le 2 - 4C^{2}\\sin^2\\left(\\frac{k\\Delta x}{2}\\right) \\implies 4C^{2}\\sin^2\\left(\\frac{k\\Delta x}{2}\\right) \\le 4 \\implies C^{2}\\sin^2\\left(\\frac{k\\Delta x}{2}\\right) \\le 1\n$$\n这个条件必须对所有的 $k$ 都成立。$\\sin^2(k\\Delta x/2)$ 的最大值是 $1$。因此，稳定性条件简化为 $C^{2} \\le 1$，即 $C \\le 1$。这就是 Courant-Friedrichs-Lewy (CFL) 条件。\n$$\n\\frac{c \\Delta t}{\\Delta x} \\le 1 \\implies \\Delta t \\le \\frac{\\Delta x}{c}\n$$\n问题指出，每个 rank $i$ 使用其局部网格间距 $\\Delta x_i$ 和局部最大波速 $c_i$。因此，rank $i$ 的局部稳定性条件是 $\\Delta t \\le \\frac{\\Delta x_i}{c_i}$。由于所有 $P$ 个 rank 都使用单一的全局时间步长 $\\Delta t$，它必须同时满足每个 rank 的稳定性条件。\n$$\n\\Delta t \\le \\frac{\\Delta x_i}{c_i} \\quad \\forall i \\in \\{1, 2, \\dots, P\\}\n$$\n最大的全局稳定时间步长 $\\Delta t^{\\star}$ 是这些条件中最严格的，即所有 rank 中的最小值。\n$$\n\\Delta t^{\\star} = \\min_{i=1, \\dots, P} \\left( \\frac{\\Delta x_i}{c_i} \\right)\n$$\n\n第二，我们推导每个时间步的总同步成本 $T_{\\mathrm{sync}}$。问题描述了一个用于自适应时间步长的两阶段过程。\n$1$. Rank 内计算：$P$ 个 rank 中的每一个都计算其局部的稳定时间步长上界 $\\frac{\\Delta x_i}{c_i}$。这涉及到 rank 内线程间的并行规约。问题指定此步骤产生一个 rank 内部的壁垒成本，即 $T_{\\mathrm{intra}} = \\tau_b$。这个过程在所有 rank 上并行发生。\n$2$. Rank 间通信：所有 $P$ 个 rank 执行一次消息传递的全局最小规约，以找到 $\\Delta t^{\\star} = \\min_{i} (\\frac{\\Delta x_i}{c_i})$。该通信模式被建模为一次基于树的规约操作，后跟一次广播。\n在 $P$ 个进程上进行基于树的集体通信的阶段数为 $\\lceil \\log_{2} P \\rceil$。大小为 $s$ 的单次点对点消息的成本由 Hockney 模型给出，为 $\\alpha + \\beta s$。\n规约阶段包含 $\\lceil \\log_{2} P \\rceil$ 个阶段，因此其成本为 $T_{\\mathrm{reduce}} = (\\alpha + \\beta s)\\lceil \\log_{2} P \\rceil$。\n广播阶段也需要 $\\lceil \\log_{2} P \\rceil$ 个阶段，成本为 $T_{\\mathrm{bcast}} = (\\alpha + \\beta s)\\lceil \\log_{2} P \\rceil$。\nRank 间的总通信成本是这两个阶段的成本之和：\n$$\nT_{\\mathrm{inter}} = T_{\\mathrm{reduce}} + T_{\\mathrm{bcast}} = 2(\\alpha + \\beta s)\\lceil \\log_{2} P \\rceil\n$$\n每个时间步的总同步成本 $T_{\\mathrm{sync}}$ 是串行的 rank 内成本和 rank 间成本之和，因为全局集体通信只有在所有局部值都计算完毕后才能开始。\n$$\nT_{\\mathrm{sync}} = T_{\\mathrm{intra}} + T_{\\mathrm{inter}} = \\tau_{b} + 2(\\alpha + \\beta s)\\lceil \\log_{2} P \\rceil\n$$\n因此，推导出的两个量是 $\\Delta t^{\\star} = \\min_{i=1, \\dots, P} \\left( \\frac{\\Delta x_i}{c_i} \\right)$ 和 $T_{\\mathrm{sync}} = \\tau_{b} + 2(\\alpha + \\beta s)\\lceil \\log_{2} P \\rceil$。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\min_{i=1, \\dots, P} \\left( \\frac{\\Delta x_i}{c_i} \\right)  \\tau_{b} + 2(\\alpha + \\beta s)\\lceil \\log_{2} P \\rceil \\end{pmatrix}}\n$$", "id": "3614221"}, {"introduction": "在共享内存和消息传递这两种并行范式之间进行选择，涉及到性能和编程复杂性上的重要权衡。这项动手练习要求您为模板计算（一种在地球物理模拟中无处不在的核心计算模式）从第一性原理出发建立性能模型。您将研究缓存一致性系统中一个微妙但至关重要的“伪共享”（false sharing）问题，并将其与分布式内存并行中显式的“光环交换”（halo-exchange）成本进行对比，从而为并行架构的选择提供定量的依据 [@problem_id:3614253]。", "problem": "您的任务是设计并实现一个完整的、可运行的程序，用于预测在两种并行范式下地球物理模板更新的每时间步运行时：多核节点上的缓存一致性共享内存和使用消息传递的分布式内存。该预测模型必须基于内存一致性、缓存行粒度以及用于光环交换的邻居通信等第一性原理来构建。您的程序必须使用一个基于计算机体系结构和并行通信基本概念的有原则的成本模型来计算预测的运行时，而不是使用经验性捷径。\n\n计算核心是在一个结构化网格上的最近邻模板更新。每次更新会读取固定数量的邻近元素，并为每个网格点写入一个输出元素。假设每个元素的计算成本相同，并采用写分配缓存。对于共享内存，不同的线程更新不相交的连续块，但可能会无意中写入映射到同一缓存行的不同元素，从而产生伪共享。对于分布式内存，每个进程更新其子域，并与其邻居交换宽度等于模板半径的光环。\n\n从以下基本原理出发：\n- 基于写失效协议的缓存一致性：一个核心对缓存行中任意字的写入，将导致该行在其他核心中失效。如果在某个时间窗口内，两个核心写入同一缓存行的不同字，会引发一致性流量。将此建模为每个冲突缓存行因失效和重填而产生的附加开销。\n- 内存以缓存行粒度进行传输。假设如果缓存行在本地不处于修改（M）状态，每次写入都会触发一次写分配。\n- 理想的工作划分：计算负载均匀分配。\n- 消息传递的邻居交换遵循标准的延迟-带宽模型：发送一个 $b$ 字节消息的时间为 $\\alpha + \\beta b$，其中 $\\alpha$ 是延迟，$\\beta$ 是逆带宽。\n- 在一维中，半径为 $r$ 的模板在每个时间步的每个边界需要宽度为 $r$ 的光环；在二维中，若沿一个轴进行一维划分，则光环的横截面等于正交维度。\n\n推导一个运行时模型，该模型结合了以下从第一性原理出发的组成部分：\n- 基于每元素成本、元素总数和并行度的计算时间贡献。\n- 由于高核心数下协议簿记开销，每个线程产生的与线程数成线性关系的一致性维护成本。\n- 一个与伪共享冲突数量成正比的额外一致性惩罚，其中冲突取决于相邻线程子域的边界是否穿过了正在写入的数组的缓存行。\n\n对于一维网格，假设线程沿单一轴将域划分为连续的块。设每个缓存行的元素数量为 $E_{\\ell} = \\lfloor B_{\\ell}/B_{e} \\rfloor$，其中 $B_{\\ell}$ 是缓存行大小（字节），$B_{e}$ 是元素大小（字节）。如果对于 $L$ 个元素和 $N$ 个线程，每个线程的块大小为 $S = \\lfloor L/N \\rfloor$，那么线程 $k$ 和 $k+1$ 之间的边界位于索引 $k S$ 处。对于 $k \\in \\{1,\\dots,N-1\\}$，如果 $k S \\bmod E_{\\ell} \\neq 0$，则每个边界计为一个伪共享冲突。每步的总冲突数是此类未对齐边界的数量。\n\n对于行主序的二维网格，假设沿 $x$ 轴划分为 $N$ 个连续的板，每个板宽为 $S_{x} = \\lfloor N_{x}/N \\rfloor$ 列，并跨越所有 $N_{y}$ 行。当且仅当 $k S_{x} \\bmod E_{\\ell} \\neq 0$ 时，位于列 $k S_{x}$ 的边界会切割每一行内的缓存行。对于每个未对齐的边界，每行计为一个伪共享冲突，即每个未对齐边界总共有 $N_{y}$ 个冲突。假设只读的邻居加载不会导致失效；在计算伪共享时只考虑对输出数组的写入。\n\n对于采用一维划分的分布式内存，将每步通信时间推导为两次邻居交换（左和右，或上和下）的总和，每次交换的延迟为 $\\alpha$，有效载荷字节数由光环宽度乘以横截面和元素大小给出。假设每个进程每步发送两条消息，每侧一条，这些消息不与计算重叠且线性求和。\n\n物理单位：所有时间必须以秒表示。您的程序必须为每个测试用例生成一个四舍五入到九位有效数字的数值答案。\n\n实现该模型并计算以下测试套件的预测每步运行时。每个测试用例都是独立的，您的程序应为每个用例输出一个浮点数。\n\n测试套件：\n- 案例1（共享内存，一维，对齐）：$L = 1048576$ 个元素，$N = 8$ 个线程，$B_{\\ell} = 64$ 字节，$B_{e} = 8$ 字节，每元素计算成本 $c = 2 \\times 10^{-9}$ 秒，每线程一致性开销 $\\gamma = 10^{-6}$ 秒，每冲突惩罚 $\\delta = 2 \\times 10^{-7}$ 秒。\n- 案例2（共享内存，一维，未对齐）：$L = 1000000$ 个元素，$N = 6$ 个线程，$B_{\\ell} = 64$ 字节，$B_{e} = 8$ 字节，$c = 2 \\times 10^{-9}$ 秒，$\\gamma = 10^{-6}$ 秒，$\\delta = 2 \\times 10^{-7}$ 秒。\n- 案例3（共享内存，一维，多核极限）：$L = 262144$ 个元素，$N = 64$ 个线程，$B_{\\ell} = 64$ 字节，$B_{e} = 8$ 字节，$c = 2 \\times 10^{-9}$ 秒，$\\gamma = 10^{-6}$ 秒，$\\delta = 2 \\times 10^{-7}$ 秒。\n- 案例4（共享内存，二维，未对齐的 $x$ 轴划分）：$N_{x} = 4104$，$N_{y} = 256$，$N = 4$ 个线程，行主序布局，沿 $x$ 轴划分，$B_{\\ell} = 64$ 字节，$B_{e} = 8$ 字节，$c = 2 \\times 10^{-9}$ 秒，$\\gamma = 10^{-6}$ 秒，$\\delta = 2 \\times 10^{-7}$ 秒。\n- 案例5（分布式内存，二维，$x$ 轴划分）：$N_{x} = 4096$，$N_{y} = 256$，$P = 4$ 个进程，模板半径 $r = 1$，元素大小 $B_{e} = 8$ 字节，消息延迟 $\\alpha = 10^{-5}$ 秒，逆带宽 $\\beta = 10^{-9}$ 秒/字节，每元素计算成本 $c = 2 \\times 10^{-9}$ 秒。沿 $x$ 轴划分，使得光环横截面等于 $N_{y}$。\n\n您的程序必须计算：\n- 对于每个共享内存案例，根据您推导的模型计算出的预测每步运行时（秒），其中伪共享冲突的数量按规定计算。\n- 对于分布式内存案例，预测的每步运行时（秒）为计算时间加上无伪共享的双边光环交换时间。\n\n最终输出格式：您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{case1},\\text{case2},\\text{case3},\\text{case4},\\text{case5}]$，其中每个条目是预测的时间（秒），四舍五入到九位有效数字。例如，您的最终输出必须类似于 [$v_{1}$,$v_{2}$,$v_{3}$,$v_{4}$,$v_{5}$]，不含空格。", "solution": "该问题要求推导并应用性能模型，以分析模板计算在两种常见并行架构上的表现：共享内存多核系统和分布式内存集群。这些模型必须按照规定从第一性原理推导得出。\n\n该问题陈述经确认为科学上合理、定义明确、客观且完整。它基于计算机体系结构和并行计算的既定原则，提供了构建所需模型和计算结果所必需的所有参数和明确定义。因此，将提供一个解决方案。\n\n### 共享内存性能模型\n\n每时间步的总运行时 $T_{\\text{shared}}$ 被建模为三个组成部分之和：计算时间 ($T_{\\text{compute}}$)、通用的一致性维护开销 ($T_{\\text{housekeeping}}$) 和伪共享冲突惩罚 ($T_{\\text{fs}}$)。\n\n$$T_{\\text{shared}} = T_{\\text{compute}} + T_{\\text{housekeeping}} + T_{\\text{fs}}$$\n\n1.  **计算时间 ($T_{\\text{compute}}$)**：对于总共 $L$ 个网格元素，每个元素的计算成本为 $c$，在 $N$ 个线程间理想负载均衡地分配，并行计算时间为：\n    $$T_{\\text{compute}} = \\frac{L \\cdot c}{N}$$\n\n2.  **一致性维护开销 ($T_{\\text{housekeeping}}$)**：这是每个线程固定的开销 $\\gamma$，用于解释维持缓存一致性的基线成本。它与线程数 $N$呈线性关系：\n    $$T_{\\text{housekeeping}} = N \\cdot \\gamma$$\n\n3.  **伪共享惩罚 ($T_{\\text{fs}}$)**：当不同线程写入恰好位于同一缓存行中的不同元素时，会发生伪共享。这会触发缓存行失效和传输，从而产生惩罚。该模型将此惩罚定义为与此类冲突数量 $C_{\\text{fs}}$ 成正比，每个冲突的成本为 $\\delta$。\n    $$T_{\\text{fs}} = C_{\\text{fs}} \\cdot \\delta$$\n    冲突数量 $C_{\\text{fs}}$取决于网格的维度和划分方式。一个关键参数是单个缓存行能容纳的元素数量 $E_{\\ell}$，定义为：\n    $$E_{\\ell} = \\bigg\\lfloor \\frac{B_{\\ell}}{B_{e}} \\bigg\\rfloor$$\n    其中 $B_{\\ell}$ 是缓存行大小，$B_{e}$ 是元素大小，单位均为字节。如果新分区的起始元素未与缓存行的起始位置对齐（即其索引不是 $E_{\\ell}$ 的倍数），则在分区边界处发生冲突。\n\n    *   **对于一个大小为 $L$ 的一维网格，在 $N$ 个线程间划分**：域被划分为大小为 $S = \\lfloor L/N \\rfloor$ 的连续块。线程之间有 $N-1$ 个边界。线程 $k-1$ 和线程 $k$ 之间的边界位于索引 $k \\cdot S$ 处（$k=1, \\dots, N-1$）。对于每个索引未对齐的边界，计为一个冲突：\n        $$C_{\\text{fs}}^{\\text{1D}} = \\sum_{k=1}^{N-1} \\mathbb{I}\\left( (k \\cdot S) \\pmod{E_{\\ell}} \\neq 0 \\right)$$\n        其中 $\\mathbb{I}(\\cdot)$ 是艾佛森括号，如果其参数为真则为 $1$，否则为 $0$。\n\n    *   **对于一个大小为 $N_x \\times N_y$ 的二维网格（行主序），沿 x 轴划分为 $N$ 个板**：每个板的宽度为 $S_x = \\lfloor N_x/N \\rfloor$。位于列 $k \\cdot S_x$ 的分区边界会穿过所有 $N_y$ 行。如果此边界相对于缓存行未对齐，则在 $N_y$ 行中的每一行都会发生伪共享冲突。\n        $$C_{\\text{fs}}^{\\text{2D}} = N_y \\cdot \\sum_{k=1}^{N-1} \\mathbb{I}\\left( (k \\cdot S_x) \\pmod{E_{\\ell}} \\neq 0 \\right)$$\n        元素总数为 $L = N_x \\cdot N_y$。\n\n### 分布式内存性能模型\n\n每时间步的总运行时 $T_{\\text{dist}}$ 被建模为计算时间 ($T_{\\text{compute}}$) 和通信时间 ($T_{\\text{comm}}$) 的总和，假设两者之间没有重叠。\n\n$$T_{\\text{dist}} = T_{\\text{compute}} + T_{\\text{comm}}$$\n\n1.  **计算时间 ($T_{\\text{compute}}$)**：总共 $L$ 个元素分布在 $P$ 个进程中，计算时间为：\n    $$T_{\\text{compute}} = \\frac{L \\cdot c}{P} = \\frac{N_x \\cdot N_y \\cdot c}{P}$$\n\n2.  **通信时间 ($T_{\\text{comm}}$)**：通信使用标准的延迟-带宽模型进行建模，其中发送 $b$ 字节消息的时间为 $T_{\\text{msg}}(b) = \\alpha + \\beta b$。对于二维网格的一维划分，一个内部进程必须与两个邻居（例如，左和右）交换光环区域。这两次交换的时间为：\n    $$T_{\\text{comm}} = 2 \\cdot T_{\\text{msg}}(b) = 2(\\alpha + \\beta b)$$\n    光环消息的大小 $b$取决于模板半径 $r$、分区的横截面维度（这里是 $N_y$）和元素大小 $B_e$。\n    $$b = r \\cdot N_y \\cdot B_e$$\n\n### 测试案例应用\n\n**案例1：共享内存，一维，对齐**\n给定：$L = 1048576, N = 8, B_{\\ell} = 64, B_{e} = 8, c = 2 \\times 10^{-9}, \\gamma = 10^{-6}, \\delta = 2 \\times 10^{-7}$。\n$E_{\\ell} = \\lfloor 64/8 \\rfloor = 8$。\n$S = \\lfloor 1048576/8 \\rfloor = 131072$。\n由于 $131072 \\pmod 8 = 0$，对于所有 $k$，$k \\cdot S \\pmod 8 = 0$。因此，$C_{\\text{fs}} = 0$。\n$T_{\\text{compute}} = \\frac{1048576 \\cdot 2 \\times 10^{-9}}{8} = 0.000262144$ 秒。\n$T_{\\text{housekeeping}} = 8 \\cdot 10^{-6} = 0.000008$ 秒。\n$T_{\\text{fs}} = 0 \\cdot 2 \\times 10^{-7} = 0$ 秒。\n$T_1 = 0.000262144 + 0.000008 + 0 = 0.000270144$ 秒。\n\n**案例2：共享内存，一维，未对齐**\n给定：$L = 1000000, N = 6, B_{\\ell} = 64, B_{e} = 8, c = 2 \\times 10^{-9}, \\gamma = 10^{-6}, \\delta = 2 \\times 10^{-7}$。\n$E_{\\ell} = \\lfloor 64/8 \\rfloor = 8$。\n$S = \\lfloor 1000000/6 \\rfloor = 166666$。\n$S \\pmod 8 = 166666 \\pmod 8 = 2$。\n对于 $k=1, \\dots, 5$，$k \\cdot S \\pmod 8$ 的倍数分别为 $2, 4, 6, 0, 2$。有 $4$ 个非零结果。\n$C_{\\text{fs}} = 4$。\n$T_{\\text{compute}} = \\frac{1000000 \\cdot 2 \\times 10^{-9}}{6} = 1/3 \\times 10^{-3} \\approx 0.000333333333$ 秒。\n$T_{\\text{housekeeping}} = 6 \\cdot 10^{-6} = 0.000006$ 秒。\n$T_{\\text{fs}} = 4 \\cdot 2 \\times 10^{-7} = 0.0000008$ 秒。\n$T_2 = 0.000333333333... + 0.000006 + 0.0000008 = 0.000340133333...$ 秒。\n\n**案例3：共享内存，一维，多核**\n给定：$L = 262144, N = 64, B_{\\ell} = 64, B_{e} = 8, c = 2 \\times 10^{-9}, \\gamma = 10^{-6}, \\delta = 2 \\times 10^{-7}$。\n$E_{\\ell} = \\lfloor 64/8 \\rfloor = 8$。\n$S = \\lfloor 262144/64 \\rfloor = 4096$。\n由于 $4096 \\pmod 8 = 0$，所以 $C_{\\text{fs}} = 0$。\n$T_{\\text{compute}} = \\frac{262144 \\cdot 2 \\times 10^{-9}}{64} = 0.000008192$ 秒。\n$T_{\\text{housekeeping}} = 64 \\cdot 10^{-6} = 0.000064$ 秒。\n$T_{\\text{fs}} = 0$ 秒。\n$T_3 = 0.000008192 + 0.000064 = 0.000072192$ 秒。\n\n**案例4：共享内存，二维，未对齐**\n给定：$N_x=4104, N_y=256, N=4, B_{\\ell}=64, B_{e}=8, c=2 \\times 10^{-9}, \\gamma=10^{-6}, \\delta=2 \\times 10^{-7}$。\n$L = 4104 \\cdot 256 = 1050624$。\n$E_{\\ell} = \\lfloor 64/8 \\rfloor = 8$。\n$S_x = \\lfloor 4104/4 \\rfloor = 1026$。\n$S_x \\pmod 8 = 1026 \\pmod 8 = 2$。\n对于 $k=1, 2, 3$，$k \\cdot S_x \\pmod 8$ 的倍数分别为 $2, 4, 6$。所有都非零。未对齐边界数为 $3$。\n$C_{\\text{fs}} = N_y \\cdot 3 = 256 \\cdot 3 = 768$。\n$T_{\\text{compute}} = \\frac{1050624 \\cdot 2 \\times 10^{-9}}{4} = 0.000525312$ 秒。\n$T_{\\text{housekeeping}} = 4 \\cdot 10^{-6} = 0.000004$ 秒。\n$T_{\\text{fs}} = 768 \\cdot 2 \\times 10^{-7} = 0.0001536$ 秒。\n$T_4 = 0.000525312 + 0.000004 + 0.0001536 = 0.000682912$ 秒。\n\n**案例5：分布式内存，二维**\n给定：$N_x=4096, N_y=256, P=4, r=1, B_{e}=8, \\alpha=10^{-5}, \\beta=10^{-9}, c=2 \\times 10^{-9}$。\n$L = 4096 \\cdot 256 = 1048576$。\n$T_{\\text{compute}} = \\frac{1048576 \\cdot 2 \\times 10^{-9}}{4} = 0.000524288$ 秒。\n消息大小 $b = r \\cdot N_y \\cdot B_e = 1 \\cdot 256 \\cdot 8 = 2048$ 字节。\n$T_{\\text{comm}} = 2 \\cdot (\\alpha + \\beta \\cdot b) = 2 \\cdot (10^{-5} + 10^{-9} \\cdot 2048) = 2 \\cdot (0.00001 + 0.000002048) = 0.000024096$ 秒。\n$T_5 = 0.000524288 + 0.000024096 = 0.000548384$ 秒。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_shared_memory(L, N, B_ell, B_e, c, gamma, delta, grid_dim, Nx=None, Ny=None):\n    \"\"\"\n    Computes predicted runtime for the shared-memory model.\n    \"\"\"\n    # Number of elements per cache line\n    E_ell = B_ell // B_e\n\n    # Component 1: Compute time\n    # The problem specifies using L*c/N, assuming ideal load balance for this part.\n    if grid_dim == '2d':\n        L = Nx * Ny\n    T_compute = (L * c) / N\n\n    # Component 2: Coherence housekeeping overhead\n    T_housekeeping = N * gamma\n\n    # Component 3: False sharing penalty\n    C_fs = 0\n    if N  1:\n        if grid_dim == '1d':\n            # Block size per thread\n            S = L // N\n            # Sum conflicts over N-1 boundaries\n            for k in range(1, N):\n                if (k * S) % E_ell != 0:\n                    C_fs += 1\n        elif grid_dim == '2d':\n            # Slab width per thread\n            Sx = Nx // N\n            misaligned_boundaries = 0\n            # Sum misaligned boundaries over N-1 boundaries\n            for k in range(1, N):\n                if (k * Sx) % E_ell != 0:\n                    misaligned_boundaries += 1\n            # One conflict per row for each misaligned boundary\n            C_fs = Ny * misaligned_boundaries\n\n    T_fs = C_fs * delta\n\n    return T_compute + T_housekeeping + T_fs\n\ndef solve_distributed_memory(Nx, Ny, P, r, B_e, alpha, beta, c):\n    \"\"\"\n    Computes predicted runtime for the distributed-memory model.\n    \"\"\"\n    L = Nx * Ny\n    \n    # Component 1: Compute time\n    T_compute = (L * c) / P\n\n    # Component 2: Communication time\n    # Message size in bytes for one halo\n    b = r * Ny * B_e\n    # Time for two neighbor exchanges (e.g., left and right)\n    T_comm = 2 * (alpha + beta * b)\n\n    return T_compute + T_comm\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (shared-memory, 1D, aligned)\n        {'type': 'shared', 'params': {'L': 1048576, 'N': 8, 'B_ell': 64, 'B_e': 8, 'c': 2e-9, 'gamma': 1e-6, 'delta': 2e-7, 'grid_dim': '1d'}},\n        # Case 2 (shared-memory, 1D, misaligned)\n        {'type': 'shared', 'params': {'L': 1000000, 'N': 6, 'B_ell': 64, 'B_e': 8, 'c': 2e-9, 'gamma': 1e-6, 'delta': 2e-7, 'grid_dim': '1d'}},\n        # Case 3 (shared-memory, 1D, manycore)\n        {'type': 'shared', 'params': {'L': 262144, 'N': 64, 'B_ell': 64, 'B_e': 8, 'c': 2e-9, 'gamma': 1e-6, 'delta': 2e-7, 'grid_dim': '1d'}},\n        # Case 4 (shared-memory, 2D, misaligned)\n        {'type': 'shared', 'params': {'L': None, 'N': 4, 'B_ell': 64, 'B_e': 8, 'c': 2e-9, 'gamma': 1e-6, 'delta': 2e-7, 'grid_dim': '2d', 'Nx': 4104, 'Ny': 256}},\n        # Case 5 (distributed memory, 2D)\n        {'type': 'distributed', 'params': {'Nx': 4096, 'Ny': 256, 'P': 4, 'r': 1, 'B_e': 8, 'alpha': 1e-5, 'beta': 1e-9, 'c': 2e-9}}\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'shared':\n            result = solve_shared_memory(**case['params'])\n        elif case['type'] == 'distributed':\n            result = solve_distributed_memory(**case['params'])\n        results.append(result)\n\n    # Format results to nine significant digits and join them into the final string.\n    formatted_results = [f\"{res:.9g}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3614253"}, {"introduction": "除了追求高性能，数值结果的可复现性是稳健科学计算的基石。在并行计算中，由于浮点数运算不满足结合律，非确定性的执行顺序会导致计算结果的波动，这在梯度累加等归约操作中尤为突出。这项实践将带领您量化这种不确定性，并实现一种确定性的求和算法，以掌握确保并行代码不仅高效，而且结果可验证、可复现的关键技术 [@problem_id:3614205]。", "problem": "考虑一个离散地球物理反演问题的伴随状态公式，其中梯度分量是通过局部双线性贡献的全局归约累积得到的。设离散正演波场表示为 $u_i$，离散伴随波场表示为 $\\lambda_i$，其中 $i$ 是组合时空格网的索引。单个模型参数的离散梯度累积可以写为序列 $g_i = u_i \\lambda_i$（其中 $i = 1, \\dots, n$）的浮点归约，产生 $G = \\sum_{i=1}^n g_i$。在实际的共享内存和消息传递环境中，非确定性调度可能会重新排序 $\\{g_i\\}$ 的求和过程，由于浮点数的非结合性，这会导致每次运行结果都可能不同。\n\n假设算术运算采用电气与电子工程师协会（Institute of Electrical and Electronics Engineers, IEEE）$754$ 标准的二进制 $64$ 位双精度浮点数，并使用“舍入到最近，偶数优先”（round-to-nearest, ties to even）的舍入模式。浮点舍入采用标准一阶模型：对于实数 $a$ 和 $b$ 上的任何基本运算 $\\mathrm{op}$，计算结果 $\\mathrm{fl}(a \\ \\mathrm{op} \\ b)$ 满足 $\\mathrm{fl}(a \\ \\mathrm{op} \\ b) = (a \\ \\mathrm{op} \\ b)(1 + \\delta)$，其中 $|\\delta| \\le \\epsilon$，单位舍入误差 $\\epsilon$ 为 $2^{-53}$。\n\n您的任务是：\n\n1. 通过模拟以下情况，评估 $G$ 在非确定性调度下的可复现性：\n   - 共享内存可变性：随机排列 $n$ 次加法的顺序，并对多个排列计算简单的从左到右求和。\n   - 消息传递可变性：将 $\\{g_i\\}$ 分成 $p$ 个连续的块（代表进程），确定性地计算每个块的和，然后随机排列块和的聚合顺序，并以从左到右的方式求和。\n\n2. 设计并实现一个确定性的 $\\sum_{i=1}^n g_i$ 归约算法，该算法使用成对求和（pairwise summation），组织为对序列的固定二叉树归约，且与调度无关。该算法必须定义为：在每一层级上，对相邻元素进行逐次成对相加，形成一个新序列；如果长度为奇数，则将剩余的元素原样传递到下一层，直到只剩下一个值为止。对于给定的输入序列顺序，此过程必须是确定性的。\n\n3. 用一个关于 $\\epsilon$ 的函数来界定确定性成对求和的舍入误差。推导并使用以下形式的界：\n$$\n|G_{\\mathrm{pair}} - G_{\\mathrm{exact}}| \\le \\epsilon \\left\\lceil \\log_2(n) \\right\\rceil \\sum_{i=1}^n |g_i|,\n$$\n其中 $G_{\\mathrm{pair}}$ 是在二进制 $64$ 位算术中确定性成对求和的结果，$G_{\\mathrm{exact}}$ 是已经舍入的 $g_i$ 值的精确实数和。为了数值上验证此界，请使用高精度十进制算术计算 $G_{\\mathrm{exact}}$，该算术将每个二进制 $64$ 位的 $g_i$ 精确表示为一个 Decimal 对象，并以足够高的精度对它们求和，以避免在累积过程中产生舍入。\n\n4. 报告每个测试用例的以下内容：\n   - 共享内存可变性下的结果范围，定义为在 $K$ 次独立的随机排列和简单的从左到右求和中得到的 $\\max(G_{\\mathrm{perm}}) - \\min(G_{\\mathrm{perm}})$，其中 $G_{\\mathrm{perm}}$ 表示这样的一次求和结果。\n   - 消息传递可变性下的结果范围，其定义与前者类似，在计算确定性的块和之后，对 $K$ 次试验中块聚合的顺序进行随机排列。\n   - 确定性成对归约相对于精确实数和的绝对误差 $|G_{\\mathrm{pair}} - G_{\\mathrm{exact}}|$。\n   - 边界值 $B = \\epsilon \\left\\lceil \\log_2(n) \\right\\rceil \\sum_{i=1}^n |g_i|$。\n   - 一个布尔值，指示是否满足 $|G_{\\mathrm{pair}} - G_{\\mathrm{exact}}| \\le B$。\n\n使用的基本前提和假设：\n- 浮点数的非结合性以及一阶舍入模型 $\\mathrm{fl}(a \\ \\mathrm{op} \\ b) = (a \\ \\mathrm{op} \\ b)(1 + \\delta)$，其中 $|\\delta| \\le \\epsilon$ 且 $\\epsilon = 2^{-53}$。\n- 结构化为平衡二叉树的确定性成对求和的深度为 $\\left\\lceil \\log_2(n) \\right\\rceil$。\n- 随机调度的可变性通过随机排列加法顺序来建模；消息传递的可变性通过随机排列一组固定的块和来建模。\n\n测试套件：\n对每个用例，完全按照下述说明构造 $\\{u_i\\}$ 和 $\\{\\lambda_i\\}$，然后在进行任何归约之前，在二进制 $64$ 位算术中形成 $g_i = \\mathrm{fl}(u_i \\cdot \\lambda_i)$。不涉及角度。不需要物理单位。\n\n- 测试 1（正常路径，中等规模，随机正态分布）：\n  - $n = 4096$, $p = 16$, $K = 32$。\n  - 用 $12345$ 作为随机数生成器的种子。\n  - $u_i$ 和 $\\lambda_i$ 是独立的标准正态分布抽样。\n- 测试 2（强相消，奇数长度）：\n  - $n = 4097$, $p = 7$, $K = 32$。\n  - 对于 $i = 0, 1, \\dots, n-1$，$u_i = (-1)^i$。\n  - 对所有 $i$，$\\lambda_i = 10^{-8}$。\n- 测试 3（宽动态范围，正项）：\n  - $n = 2048$, $p = 8$, $K = 32$。\n  - 对于 $i = 0, 1, \\dots, n-1$，$u_i = 10^{-i/8}$。\n  - 对所有 $i$，$\\lambda_i = 1$。\n- 测试 4（极小量级与一量级的混合）：\n  - $n = 1000$, $p = 10$, $K = 32$。\n  - 用 $67890$ 作为随机数生成器的种子。\n  - 对于 $i = 0, \\dots, 499$：$u_i$ 是 $\\{-1, +1\\}$ 中的独立随机符号，$\\lambda_i = 10^{-300}$。\n  - 对于 $i = 500, \\dots, 999$：$u_i$ 是独立的标准正态分布抽样，$\\lambda_i = 1$。\n- 测试 5（边界情况，单个元素）：\n  - $n = 1$, $p = 1$, $K = 32$。\n  - $u_0 = 3.141592653589793$, $\\lambda_0 = 2.718281828459045$。\n\n程序要求：\n- 实现所述的确定性成对求和。\n- 通过排列长度为 $n$ 的 $g_i$ 序列并对每个排列执行简单的从左到右求和，模拟 $K$ 个用于共享内存可变性的随机调度。\n- 通过以下方式模拟 $K$ 次随机的消息传递聚合：将序列划分为 $p$ 个大小尽可能相等的连续块，通过成对求和确定性地计算每个块的和，然后排列这 $p$ 个块和，并对每个排列从左到右进行聚合。\n- 使用高精度十进制算术计算精确实数和 $G_{\\mathrm{exact}}$，该算术将每个 $g_i$ 精确表示为一个 Decimal 对象，并以至少 $200$ 位十进制数字的精度求和。\n- 对每个测试用例，生成列表 $[\\text{range\\_shared}, \\text{range\\_message}, |G_{\\mathrm{pair}} - G_{\\mathrm{exact}}|, B, \\text{bound\\_ok}]$，其中所有量均如上文定义。\n- 最终输出格式：您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，每个测试用例一个列表，按给定顺序排列，例如 $[[\\cdots],[\\cdots],\\dots]$。\n\n输出中的所有数值量必须表示为标准的 Python 字面量（浮点数和布尔值）。不应打印任何附加文本。", "solution": "该问题要求在地球物理反演问题的背景下，分析浮点数求和的可复现性，比较非确定性和确定性求和算法，并验证确定性算法的理论误差界。问题的核心在于浮点加法的非结合性，这是计算机算术的一个基本属性。\n\n### 原理：浮点算术与非结合性\n\n该问题基于标准的浮点算术模型，该模型符合电气与电子工程师协会（Institute of Electrical and Electronics Engineers, IEEE）$754$ 标准。对于两个实数 $a$ 和 $b$ 上的任何二元运算 $\\mathrm{op}$（如加法或乘法），其计算结果（表示为 $\\mathrm{fl}(a \\ \\mathrm{op} \\ b)$）不是精确的。它由以下模型描述：\n$$\n\\mathrm{fl}(a \\ \\mathrm{op} \\ b) = (a \\ \\mathrm{op} \\ b)(1 + \\delta)\n$$\n其中 $|\\delta| \\le \\epsilon$。这里，$\\epsilon$ 是单位舍入误差，对于二进制 $64$ 位（双精度）算术，$\\epsilon = 2^{-53}$。\n\n这个舍入模型的一个直接后果是浮点加法不满足结合律。也就是说，对于三个浮点数 $x$、$y$ 和 $z$，以下等式通常不成立：\n$$\n\\mathrm{fl}(\\mathrm{fl}(x + y) + z) = \\mathrm{fl}(x + \\mathrm{fl}(y + z))\n$$\n运算的顺序可以并且经常会改变最终结果。在并行计算环境中，线程的调度程序（在共享内存系统中）或消息的到达顺序（在消息传递系统中）可能是非确定性的。如果一个全局和，例如梯度累积 $G = \\sum_{i=1}^n g_i$，是使用简单的从左到右归约来计算的，那么加法的有效顺序可能每次运行都不同，从而导致不可复现的结果。这在科学计算中是一个重要问题，因为在验证和调试时通常需要位对位（bit-for-bit）的可复现性。\n\n### 非确定性求和的模拟\n\n为了量化这种可变性，我们模拟了两种常见的并行编程范式。所有求和的输入序列为 $\\{g_i\\}_{i=1}^n$，其中每个 $g_i = \\mathrm{fl}(u_i \\cdot \\lambda_i)$ 都以二进制 $64$ 位格式计算和存储。\n\n1.  **共享内存可变性**：通过假设 $n$ 个项可以按任何顺序相加来建模。我们通过生成序列 $\\{g_i\\}$ 的 $K$ 个独立的随机排列来模拟这一点。对每个排列，计算一个简单的从左到右的和。可变性由这 $K$ 个结果的范围来衡量：$\\max(G_{\\mathrm{perm}}) - \\min(G_{\\mathrm{perm}})$。\n\n2.  **消息传递可变性**：这模拟了一种域分解范式，其中 $p$ 个进程各自计算一个局部部分和，然后这 $p$ 个部分和被聚合（归约）成一个最终的全局和。序列 $\\{g_i\\}$ 被划分为 $p$ 个连续的块。每个块的和是确定性计算的。问题指定了对这些块和的非确定性聚合。我们通过计算这 $p$ 个块和，然后在 $K$ 次试验中，随机排列这 $p$ 个和，并用从左到右的求和方式将它们聚合起来，以此来模拟这一过程。可变性就是这 $K$ 个最终聚合和的范围。\n\n### 确定性成对求和\n\n为了保证可复现性，需要一个确定性的求和算法。问题指定了一种特定形式的成对求和，可以将其看作一个二叉树归约。给定一个数字序列，该算法按层级进行：\n1.  在第一层，将相邻的数字对相加：$(g_1+g_2), (g_3+g_4), \\dots$。这会形成一个新的、更短的序列。如果原始序列的元素数量为奇数，则最后一个元素将原封不动地传递到下一层。\n2.  对新序列重复此过程，直到只剩下一个数字为止。\n\n这个算法是确定性的：对于一个固定的输入序列 $\\{g_i\\}$，无论并行执行环境如何，结果总是相同的，因为加法的顺序是由算法的结构固定的。\n\n### 成对求和的误差分析\n\n除了确定性之外，成对求和的一个关键优势是，与朴素求和相比，它具有更高的精度，特别是对于长序列或量级变化大的序列。提供的误差界为：\n$$\n|G_{\\mathrm{pair}} - G_{\\mathrm{exact}}| \\le \\epsilon \\left\\lceil \\log_2(n) \\right\\rceil \\sum_{i=1}^n |g_i|\n$$\n这里，$G_{\\mathrm{pair}}$ 是通过成对求和算法计算出的和，$G_{\\mathrm{exact}} = \\sum_{i=1}^n g_i$ 是初始浮点数集 $\\{g_i\\}$ 的精确数学和。\n\n这个界可以直观地理解。求和树的深度为 $d = \\left\\lceil \\log_2(n) \\right\\rceil$。任何输入值 $g_i$ 最多参与 $d$ 次加法来贡献于最终的和。在每次加法中，都会引入一个小的舍入误差。该界形式化了这些误差的最坏情况累积。$\\sum_{i=1}^n |g_i|$ 这一项的出现是因为舍入误差是相对的，所以它们的绝对大小与被加数的量级成比例。这个界明显优于朴素求和的相应界，后者的因子是 $n$ 而不是 $\\log_2(n)$。\n\n为了数值上验证这个界，我们需要 $G_{\\mathrm{exact}}$。由于输入 $\\{g_i\\}$ 是二进制 $64$ 位数，它们有精确的有限十进制表示。我们可以使用一个高精度算术库（例如 Python 的 `decimal` 模块）来精确表示每个 $g_i$，并以足够高的精度（例如，$200$ 位数字）对它们求和，以确保求和本身不引入舍入误差。其结果是 $G_{\\mathrm{exact}}$ 的一个高精度参考值。\n\n### 实现计划\n\n对每个测试用例，执行以下步骤：\n1.  根据测试用例的规范生成输入序列 $\\{u_i\\}$ 和 $\\{\\lambda_i\\}$。\n2.  计算乘积序列 $g_i = \\mathrm{fl}(u_i \\cdot \\lambda_i)$，并将其作为二进制 $64$ 位浮点数数组存储。\n3.  **可变性分析**：\n    -   通过计算 $\\{g_i\\}$ 随机排列的 $K$ 次朴素求和的范围，来计算共享内存的可变性。\n    -   计算消息传递的可变性。首先，将 $\\{g_i\\}$ 分成 $p$ 个块。对每个块计算一个确定性的成对和。然后，找到这 $p$ 个块和的随机排列的 $K$ 次朴素求和的范围。\n4.  **确定性计算与误差验证**：\n    -   计算 $\\{g_i\\}$ 的确定性成对和 $G_{\\mathrm{pair}}$。\n    -   使用高精度十进制算术计算“精确”和 $G_{\\mathrm{exact}}$。\n    -   计算绝对误差 $|G_{\\mathrm{pair}} - G_{\\mathrm{exact}}|$。\n    -   计算误差界 $B = \\epsilon \\left\\lceil \\log_2(n) \\right\\rceil \\sum_{i=1}^n |g_i|$，其中 $\\epsilon=2^{-53}$。\n    -   执行布尔检查 $|G_{\\mathrm{pair}} - G_{\\mathrm{exact}}| \\le B$。\n5.  收集并报告五个所需的量——$\\text{range\\_shared}$、$\\text{range\\_message}$、 $|G_{\\mathrm{pair}} - G_{\\mathrm{exact}}|$、$B$ 和布尔结果。", "answer": "```python\nimport numpy as np\nimport decimal\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the geophysical summation problem by simulating variability,\n    implementing a deterministic summation, and verifying its error bound.\n    \"\"\"\n\n    # Set precision for Decimal calculations to be safely higher than needed.\n    decimal.getcontext().prec = 200\n    \n    # IEEE 754 binary64 unit roundoff\n    EPSILON = 2**-53\n\n    # Definition of the deterministic pairwise summation algorithm.\n    def pairwise_sum(arr):\n        \"\"\"\n        Computes the sum of an array of floats using deterministic\n        pairwise summation.\n        \"\"\"\n        if not isinstance(arr, list):\n            s = arr.tolist()\n        else:\n            s = arr.copy()\n        \n        if len(s) == 0:\n            return 0.0\n        \n        while len(s)  1:\n            next_s = []\n            # Sum adjacent pairs\n            for i in range(len(s) // 2):\n                next_s.append(s[2*i] + s[2*i+1])\n            # Propagate leftover element if length is odd\n            if len(s) % 2 == 1:\n                next_s.append(s[-1])\n            s = next_s\n        \n        return s[0]\n\n    test_cases = [\n        {\n            \"id\": 1, \"n\": 4096, \"p\": 16, \"K\": 32, \"seed\": 12345,\n            \"gen\": lambda rng, n: (rng.standard_normal(n, dtype=np.float64), rng.standard_normal(n, dtype=np.float64))\n        },\n        {\n            \"id\": 2, \"n\": 4097, \"p\": 7, \"K\": 32, \"seed\": None,\n            \"gen\": lambda rng, n: ((-1)**np.arange(n, dtype=np.float64), np.full(n, 1e-8, dtype=np.float64))\n        },\n        {\n            \"id\": 3, \"n\": 2048, \"p\": 8, \"K\": 32, \"seed\": None,\n            \"gen\": lambda rng, n: (10.0**(-np.arange(n, dtype=np.float64)/8.0), np.ones(n, dtype=np.float64))\n        },\n        {\n            \"id\": 4, \"n\": 1000, \"p\": 10, \"K\": 32, \"seed\": 67890,\n            \"gen\": lambda rng, n: (\n                np.concatenate([rng.choice([-1.0, 1.0], n//2), rng.standard_normal(n - n//2, dtype=np.float64)]),\n                np.concatenate([np.full(n//2, 1e-300, dtype=np.float64), np.ones(n - n//2, dtype=np.float64)])\n            )\n        },\n        {\n            \"id\": 5, \"n\": 1, \"p\": 1, \"K\": 32, \"seed\": None,\n            \"gen\": lambda rng, n: (np.array([3.141592653589793], dtype=np.float64), np.array([2.718281828459045], dtype=np.float64))\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        n, p, K = case[\"n\"], case[\"p\"], case[\"K\"]\n        \n        if case[\"seed\"] is not None:\n            rng = np.random.default_rng(case[\"seed\"])\n        else:\n            # Create a default RNG instance even if no seed, for consistency\n            rng = np.random.default_rng()\n\n        u, lam = case[\"gen\"](rng, n)\n        \n        # Compute g_i = fl(u_i * lambda_i) in binary64\n        g = (u * lam).astype(np.float64)\n\n        # 1. Shared-memory variability simulation\n        shared_sums = []\n        for _ in range(K):\n            perm_g = rng.permutation(g)\n            # Use Python's sum for a simple left-to-right accumulation\n            shared_sums.append(sum(perm_g))\n        range_shared = max(shared_sums) - min(shared_sums) if K  0 and len(set(shared_sums))  1 else 0.0\n\n        # 2. Message-passing variability simulation\n        # Partition g into p contiguous blocks\n        blocks = np.array_split(g, p)\n        # Compute block sums deterministically using pairwise summation\n        block_sums = np.array([pairwise_sum(block) for block in blocks])\n\n        mpi_sums = []\n        for _ in range(K):\n            perm_block_sums = rng.permutation(block_sums)\n            mpi_sums.append(sum(perm_block_sums))\n        range_message = max(mpi_sums) - min(mpi_sums) if K  0 and len(set(mpi_sums))  1 else 0.0\n\n        # 3. Deterministic reduction and error analysis\n        # Compute pairwise sum\n        g_pair = pairwise_sum(g)\n\n        # Compute \"exact\" sum using high-precision decimal arithmetic\n        g_decimal = [decimal.Decimal(x) for x in g]\n        g_exact = sum(g_decimal)\n        \n        # Absolute error relative to exact sum\n        abs_error = abs(decimal.Decimal(g_pair) - g_exact)\n\n        # Compute the theoretical error bound B\n        if n  1:\n            log2n_ceil = math.ceil(math.log2(n))\n        else:\n            log2n_ceil = 0 # Depth of summation tree for n=1 is 0\n        \n        sum_abs_g = np.sum(np.abs(g))\n        bound_B = decimal.Decimal(EPSILON) * decimal.Decimal(log2n_ceil) * decimal.Decimal(sum_abs_g)\n        \n        # Check if the error is within the bound\n        bound_ok = abs_error = bound_B\n\n        all_results.append([\n            float(range_shared),\n            float(range_message),\n            float(abs_error),\n            float(bound_B),\n            bool(bound_ok)\n        ])\n\n    # Format the final output as a string representing a list of lists\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3614205"}]}