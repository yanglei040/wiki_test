{"hands_on_practices": [{"introduction": "共轭梯度（CG）方法的效率在很大程度上依赖于系统矩阵的对称性。本练习通过一个具体的计算任务，向您展示当使用非对称预处理器破坏这种对称性时会发生什么。通过这个简单的 $2 \\times 2$ 算例，您将亲眼见证作为 CG 收敛理论基石的 $A$-正交性是如何被破坏的。[@problem_id:3605546]", "problem": "在计算地球物理学中，椭圆偏微分方程（如具有齐次狄利克雷边界条件的一维扩散方程）的离散化会产生具有对称正定（SPD）矩阵的线性系统。诸如共轭梯度（CG）法之类的迭代求解器依赖于这种对称性来保持搜索方向的 $A$-正交性。实践中使用的经典预条件子包括雅可比法和对称逐次超松弛（SSOR）法。现在考虑一个由前向高斯-赛德尔分裂得到的非对称右预条件子。\n\n设 SPD 系统矩阵为\n$$\nA \\;=\\; \\begin{pmatrix} 2  -1 \\\\ -1  2 \\end{pmatrix},\n$$\n该矩阵源于在具有单位间距的 $N=2$ 个内部网格点上对一维拉普拉斯算子进行的二阶中心有限差分离散。定义非对称右预条件子\n$$\nP \\;=\\; D + L \\;=\\; \\begin{pmatrix} 2  0 \\\\ -1  2 \\end{pmatrix},\n$$\n其中 $D$ 是 $A$ 的对角部分，$L$ 是 $A$ 的严格下三角部分。考虑右预处理系统\n$$\nA P^{-1} \\mathbf{y} \\;=\\; \\mathbf{b},\n$$\n其中\n$$\n\\mathbf{b} \\;=\\; \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix},\n\\qquad \\mathbf{y}_0 \\;=\\; \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}.\n$$\n对系数矩阵 $A P^{-1}$ 应用标准共轭梯度法，在 $\\mathbf{y}$ 变量中使用常规欧几里得内积和基于残差的更新，在 $\\mathbf{y}$ 空间中生成搜索方向 $\\{\\mathbf{d}_k\\}_{k\\ge 0}$。通过以下方式将更新和方向映射到原始的 $\\mathbf{x}$ 变量：\n$$\n\\mathbf{x}_k \\;=\\; P^{-1} \\mathbf{y}_k, \\qquad \\mathbf{p}_k \\;=\\; P^{-1} \\mathbf{d}_k.\n$$\n计算标量 $\\mathbf{p}_0^{\\top} A \\mathbf{p}_1$，它衡量前两个映射搜索方向的 $A$-正交性。将最终结果精确表示为一个有理数。无需四舍五入，答案不带单位。", "solution": "用户提供了一个有效的问题陈述。唯一解所需的所有数据和条件都已给出，并且该问题在数值线性代数领域具有科学依据，特别是关于求解线性系统的迭代方法。问题的核心是对一个系数矩阵非对称的系统应用标准共轭梯度（CG）算法，并计算一个衡量在原始变量空间中搜索方向之间由此导致的 $A$-正交性损失的量。\n\n待解系统是右预处理系统 $A P^{-1} \\mathbf{y} = \\mathbf{b}$，其中系数矩阵为 $M = A P^{-1}$。我们对这个关于变量 $\\mathbf{y}$ 的系统应用标准 CG 算法。\n\n给定的矩阵和向量如下：\n对称正定（SPD）矩阵 $A$：\n$$\nA = \\begin{pmatrix} 2  -1 \\\\ -1  2 \\end{pmatrix}\n$$\n非对称右预条件子 $P$：\n$$\nP = D + L = \\begin{pmatrix} 2  0 \\\\ -1  2 \\end{pmatrix}\n$$\n右端向量 $\\mathbf{b}$：\n$$\n\\mathbf{b} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\n预处理变量 $\\mathbf{y}$ 的初始猜测值：\n$$\n\\mathbf{y}_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n对于具有初始猜测值 $\\mathbf{y}_0$ 的系统 $M \\mathbf{y} = \\mathbf{b}$，标准共轭梯度算法的步骤如下：\n1. 计算初始残差：$\\mathbf{r}_0 = \\mathbf{b} - M \\mathbf{y}_0$。\n2. 设置初始搜索方向：$\\mathbf{d}_0 = \\mathbf{r}_0$。\n3. 对于 $k = 0, 1, 2, \\dots$：\n    a. 计算步长：$\\alpha_k = \\frac{\\mathbf{r}_k^{\\top} \\mathbf{r}_k}{\\mathbf{d}_k^{\\top} M \\mathbf{d}_k}$。\n    b. 更新解：$\\mathbf{y}_{k+1} = \\mathbf{y}_k + \\alpha_k \\mathbf{d}_k$。\n    c. 更新残差：$\\mathbf{r}_{k+1} = \\mathbf{r}_k - \\alpha_k M \\mathbf{d}_k$。\n    d. 计算改进因子：$\\beta_k = \\frac{\\mathbf{r}_{k+1}^{\\top} \\mathbf{r}_{k+1}}{\\mathbf{r}_k^{\\top} \\mathbf{r}_k}$。\n    e. 更新搜索方向：$\\mathbf{d}_{k+1} = \\mathbf{r}_{k+1} + \\beta_k \\mathbf{d}_k$。\n\n首先，我们需要预条件子 $P$ 的逆矩阵 $P^{-1}$。$P$ 的行列式为 $\\det(P) = (2)(2) - (0)(-1) = 4$。\n$$\nP^{-1} = \\frac{1}{4} \\begin{pmatrix} 2  0 \\\\ 1  2 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2}  0 \\\\ \\frac{1}{4}  \\frac{1}{2} \\end{pmatrix}\n$$\n系统的系数矩阵是 $M = A P^{-1}$：\n$$\nM = A P^{-1} = \\begin{pmatrix} 2  -1 \\\\ -1  2 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{2}  0 \\\\ \\frac{1}{4}  \\frac{1}{2} \\end{pmatrix} = \\begin{pmatrix} 2(\\frac{1}{2}) - 1(\\frac{1}{4})   2(0) - 1(\\frac{1}{2}) \\\\ -1(\\frac{1}{2}) + 2(\\frac{1}{4})  -1(0) + 2(\\frac{1}{2}) \\end{pmatrix} = \\begin{pmatrix} \\frac{3}{4}  -\\frac{1}{2} \\\\ 0  1 \\end{pmatrix}\n$$\n注意，$M$ 不是对称的，这是该问题的核心。\n\n现在我们执行 CG 算法。\n\n**初始化 ($k=0$):**\n- 初始残差：由于 $\\mathbf{y}_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$，初始残差为 $\\mathbf{r}_0 = \\mathbf{b} - M \\mathbf{y}_0 = \\mathbf{b}$。\n$$\n\\mathbf{r}_0 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\n- 初始搜索方向：\n$$\n\\mathbf{d}_0 = \\mathbf{r}_0 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\n\n**第一次迭代 ($k=0$):**\n- 我们需要计算乘积 $M \\mathbf{d}_0$：\n$$\nM \\mathbf{d}_0 = (A P^{-1}) \\mathbf{d}_0 = \\begin{pmatrix} \\frac{3}{4}  -\\frac{1}{2} \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -\\frac{1}{2} \\\\ 1 \\end{pmatrix}\n$$\n- 计算步长 $\\alpha_0$：\n$$\n\\alpha_0 = \\frac{\\mathbf{r}_0^{\\top} \\mathbf{r}_0}{\\mathbf{d}_0^{\\top} M \\mathbf{d}_0} = \\frac{\\begin{pmatrix} 0  1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}}{\\begin{pmatrix} 0  1 \\end{pmatrix} \\begin{pmatrix} -\\frac{1}{2} \\\\ 1 \\end{pmatrix}} = \\frac{0^2 + 1^2}{0(-\\frac{1}{2}) + 1(1)} = \\frac{1}{1} = 1\n$$\n- 更新残差 $\\mathbf{r}_1$：\n$$\n\\mathbf{r}_1 = \\mathbf{r}_0 - \\alpha_0 M \\mathbf{d}_0 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} - 1 \\begin{pmatrix} -\\frac{1}{2} \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2} \\\\ 0 \\end{pmatrix}\n$$\n- 为求得下一个搜索方向 $\\mathbf{d}_1$，我们计算 $\\beta_0$：\n$$\n\\beta_0 = \\frac{\\mathbf{r}_1^{\\top} \\mathbf{r}_1}{\\mathbf{r}_0^{\\top} \\mathbf{r}_0} = \\frac{\\begin{pmatrix} \\frac{1}{2}  0 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{2} \\\\ 0 \\end{pmatrix}}{\\begin{pmatrix} 0  1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}} = \\frac{(\\frac{1}{2})^2 + 0^2}{0^2 + 1^2} = \\frac{\\frac{1}{4}}{1} = \\frac{1}{4}\n$$\n- 更新搜索方向得到 $\\mathbf{d}_1$：\n$$\n\\mathbf{d}_1 = \\mathbf{r}_1 + \\beta_0 \\mathbf{d}_0 = \\begin{pmatrix} \\frac{1}{2} \\\\ 0 \\end{pmatrix} + \\frac{1}{4} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2} \\\\ \\frac{1}{4} \\end{pmatrix}\n$$\n我们现在已经找到了 $\\mathbf{y}$ 空间中的前两个搜索方向：$\\mathbf{d}_0 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$ 和 $\\mathbf{d}_1 = \\begin{pmatrix} \\frac{1}{2} \\\\ \\frac{1}{4} \\end{pmatrix}$。\n\n问题要求我们计算 $\\mathbf{p}_0^{\\top} A \\mathbf{p}_1$，其中原始 $\\mathbf{x}$ 变量空间中的搜索方向 $\\mathbf{p}_k$ 由 $\\mathbf{p}_k = P^{-1} \\mathbf{d}_k$ 给出。\n\n首先，我们计算 $\\mathbf{p}_0$ 和 $\\mathbf{p}_1$：\n$$\n\\mathbf{p}_0 = P^{-1} \\mathbf{d}_0 = \\begin{pmatrix} \\frac{1}{2}   0 \\\\ \\frac{1}{4}   \\frac{1}{2} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2}(0) + 0(1) \\\\ \\frac{1}{4}(0) + \\frac{1}{2}(1) \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ \\frac{1}{2} \\end{pmatrix}\n$$\n$$\n\\mathbf{p}_1 = P^{-1} \\mathbf{d}_1 = \\begin{pmatrix} \\frac{1}{2}   0 \\\\ \\frac{1}{4}   \\frac{1}{2} \\end{pmatrix} \\begin{pmatrix} \\frac{1}{2} \\\\ \\frac{1}{4} \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2}(\\frac{1}{2}) + 0(\\frac{1}{4}) \\\\ \\frac{1}{4}(\\frac{1}{2}) + \\frac{1}{2}(\\frac{1}{4}) \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{4} \\\\ \\frac{1}{8} + \\frac{1}{8} \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{4} \\\\ \\frac{2}{8} \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{4} \\\\ \\frac{1}{4} \\end{pmatrix}\n$$\n最后，我们计算目标标量值 $\\mathbf{p}_0^{\\top} A \\mathbf{p}_1$。我们首先计算向量 $A \\mathbf{p}_1$：\n$$\nA \\mathbf{p}_1 = \\begin{pmatrix} 2   -1 \\\\ -1   2 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{4} \\\\ \\frac{1}{4} \\end{pmatrix} = \\begin{pmatrix} 2(\\frac{1}{4}) - 1(\\frac{1}{4}) \\\\ -1(\\frac{1}{4}) + 2(\\frac{1}{4}) \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{4} \\\\ \\frac{1}{4} \\end{pmatrix}\n$$\n现在，我们计算点积：\n$$\n\\mathbf{p}_0^{\\top} A \\mathbf{p}_1 = \\begin{pmatrix} 0   \\frac{1}{2} \\end{pmatrix} \\begin{pmatrix} \\frac{1}{4} \\\\ \\frac{1}{4} \\end{pmatrix} = 0(\\frac{1}{4}) + \\frac{1}{2}(\\frac{1}{4}) = \\frac{1}{8}\n$$\n结果 $\\mathbf{p}_0^{\\top} A \\mathbf{p}_1 = \\frac{1}{8}$ 非零，表明搜索方向 $\\mathbf{p}_0$ 和 $\\mathbf{p}_1$ 不是 $A$-正交的。这是预期的结果，因为标准 CG 算法生成 $A$-正交搜索方向的保证依赖于系统矩阵的对称性，而 $M = A P^{-1}$ 不满足这一条件。", "answer": "$$\n\\boxed{\\frac{1}{8}}\n$$", "id": "3605546"}, {"introduction": "在明确了对称性的重要性后，我们转向对称逐次超松弛（SSOR）预处理器。这个编程练习旨在解决计算地球物理学中的一个实际挑战：波动方程模型产生的系统矩阵可能是病态甚至不定的。您将实现 SSOR 预处理器，并使用 Cholesky 分解这一标准数值工具来检验其是否满足预处理共轭梯度法所要求的对称正定（SPD）性，同时为检验失败的情况设计一种实用的备选策略。[@problem_id:3605479]", "problem": "考虑在一维情况下，波在轻微阻尼下传播产生的频域亥姆霍兹算子，该算子在均匀网格上使用狄利克雷边界条件进行离散化。设连续算子定义在区间 $[0,L]$ 上：\n$$\n\\mathcal{H}u(x) = -\\frac{d^2 u}{dx^2}(x) - k(x)^2 u(x) + \\delta u(x),\n$$\n其中 $k(x)$ 是空间变化的波数，$\\delta \\ge 0$ 是一个小的实数阻尼。在 $N$ 个内部网格点上使用标准的二阶中心有限差分，网格间距为 $h = L/(N+1)$，得到的离散线性系统为 $A \\mathbf{u} = \\mathbf{f}$，其中 $A \\in \\mathbb{R}^{N \\times N}$ 是一个对称三对角矩阵，其模板系数为\n$$\nA_{i,i} = \\frac{2}{h^2} - k_i^2 + \\delta,\\quad A_{i,i-1} = A_{i,i+1} = -\\frac{1}{h^2},\\quad 1 \\le i \\le N,\n$$\n其中 $k_i = k(x_i)$，$x_i = i h$。矩阵 $A$ 可能是对称正定 (SPD) 的、不定的或病态的，这取决于 $k(x)$ 和 $\\delta$。\n\n定义对角部分 $D = \\operatorname{diag}(A)$、$A$ 的严格下三角部分 $L$ 和 $A$ 的严格上三角部分 $U$。对于松弛参数 $\\omega$，对称逐次超松弛 (SSOR) 预条件子为\n$$\nM_{\\mathrm{SSOR}}(\\omega) = \\frac{\\omega}{2 - \\omega} \\left( D + \\omega L \\right) D^{-1} \\left( D + \\omega U \\right),\n$$\n前提是 $0  \\omega  2$。对于对称高斯-赛德尔预条件子，设置 $\\omega = 1$。雅可比预条件子是 $M_{\\mathrm{J}} = D$。在预处理共轭梯度法中，$M$ 必须是 SPD 的。对于不定的 $A$，$M_{\\mathrm{SSOR}}(\\omega)$ 可能会失去 SPD 性，这可以通过 Cholesky 分解的失败来检测。\n\n您的任务是编写一个完整的程序，该程序：\n- 根据上述公式为几个测试用例构建矩阵 $A$。\n- 为每个用例构建 $M_{\\mathrm{SSOR}}(\\omega)$。\n- 通过尝试对 $M_{\\mathrm{SSOR}}(\\omega)$ 进行 Cholesky 分解来检测 $M_{\\mathrm{SSOR}}(\\omega)$ 是否是 SPD 的。\n- 如果 $M_{\\mathrm{SSOR}}(\\omega)$ 不是 SPD 的，则将索引集 $\\{1,2,\\dots,N\\}$ 划分为大小相等的连续块 $B$，并对每个块检查其主子矩阵 $A_{\\mathrm{block}}$。如果 $A_{\\mathrm{block}}$ 是 SPD 的，则为该块推荐对称高斯-赛德尔预条件子；否则推荐雅可比预条件子。报告被推荐使用对称高斯-赛德尔和雅可比预条件子的块数。\n\n使用以下测试套件，它通过改变波数和松弛参数来测试 SPD、不定和边界情况。在所有情况下，设置 $L = 1$：\n- 情况 1：$N = 64$，均匀 $k(x) \\equiv 0$，$\\delta = 0$，$\\omega = 1$，块大小 $B = 16$。\n- 情况 2：$N = 64$，均匀 $k(x) \\equiv 5$，$\\delta = 0.1$，$\\omega = 1.2$，块大小 $B = 16$。\n- 情况 3：$N = 64$，分段 $k(x)$，当 $x \\in [0,0.5)$ 时 $k(x) \\equiv 2$，当 $x \\in [0.5,1]$ 时 $k(x) \\equiv 5$，$\\delta = 0.05$，$\\omega = 1$，块大小 $B = 8$。\n- 情况 4：$N = 64$，均匀 $k(x) \\equiv 2$，$\\delta = 0$，$\\omega = 1.99$，块大小 $B = 16$。\n- 情况 5：$N = 64$，均匀 $k(x) \\equiv 2$，$\\delta = 0$，$\\omega = 2.1$，块大小 $B = 16$。\n\n对于每个用例，程序必须生成一个列表，其中包含：\n- 一个布尔值，指示 $M_{\\mathrm{SSOR}}(\\omega)$ 是否是 SPD 的。\n- 一个整数，表示推荐使用对称高斯-赛德尔预条件子的块数。\n- 一个整数，表示推荐使用雅可比预条件子的块数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个元素对应一个测试用例，并且本身是 $[ \\text{布尔值}, \\text{整数}, \\text{整数} ]$ 形式的列表。例如，一个包含两个假设用例的输出将类似于 $[[\\text{True},2,3],[\\text{False},1,4]]$。输出中不得包含任何单位。", "solution": "当前任务是分析离散化的一维亥姆霍兹算子的对称逐次超松弛 (SSOR) 预条件子的对称正定 (SPD) 属性。如果 SSOR 预条件子不是 SPD 的，则需采用一种基于对系统矩阵进行分块分析的备用策略。\n\n连续亥姆霍兹算子由以下公式给出：\n$$\n\\mathcal{H}u(x) = -\\frac{d^2 u}{dx^2}(x) - k(x)^2 u(x) + \\delta u(x)\n$$\n定义在域 $x \\in [0,L]$ 上，其中 $k(x)$ 是波数，$\\delta \\ge 0$ 是一个阻尼项。在一个具有 $N$ 个内部点、间距为 $h = L/(N+1)$ 的均匀网格上，使用二阶中心有限差分格式将其转换为一个线性系统 $A \\mathbf{u} = \\mathbf{f}$。矩阵 $A$ 是一个 $N \\times N$ 的实对称三对角矩阵，其非零元素由以下模板定义：\n$$\nA_{i,i} = \\frac{2}{h^2} - k_i^2 + \\delta, \\quad A_{i,i-1} = A_{i,i+1} = -\\frac{1}{h^2}\n$$\n对于 $1 \\le i \\le N$，其中 $k_i = k(x_i)$ 在网格点 $x_i = i h$ 处。根据 $k_i$ 的值，矩阵 $A$ 可能是 SPD 的或不定的。\n\nSSOR 预条件子 $M_{\\mathrm{SSOR}}(\\omega)$ 是使用松弛参数 $\\omega$ 从 $A$ 构建的。我们首先将 $A$ 分解为 $A = D + L + U$，其中 $D$ 是其对角部分，$L$ 是其严格下三角部分，$U$ 是其严格上三角部分。然后，SSOR 预条件子矩阵定义为：\n$$\nM_{\\mathrm{SSOR}}(\\omega) = \\frac{\\omega}{2 - \\omega} \\left( D + \\omega L \\right) D^{-1} \\left( D + \\omega U \\right)\n$$\n此公式在 $\\omega \\in \\mathbb{R} \\setminus \\{2\\}$ 时有效。为了在加速 SPD 系统的迭代方法中普遍使用，$\\omega$ 通常被限制在区间 $0  \\omega  2$ 内，这确保了前置因子 $\\frac{\\omega}{2-\\omega}$ 为正。当 $\\omega=1$ 时，此预条件子被称为对称高斯-赛德尔 (SGS) 预条件子。最简单的预条件子是雅可比预条件子，$M_{\\mathrm{J}} = D$。\n\n将预条件子 $M$ 与预处理共轭梯度 (PCG) 方法一起使用的一个关键要求是 $M$ 必须是 SPD 的。验证一个对称矩阵是否为正定的一个标准且数值上稳健的方法是尝试对其进行 Cholesky 分解。一个矩阵 $M$ 是 SPD 的当且仅当它具有 Cholesky 分解 $M = R^T R$，其中 $R$ 是一个对角线元素为正的上三角矩阵。计算此分解的数值库如果遇到非 SPD 矩阵，将会失败并引发错误。\n\n每个测试用例的算法流程如下：\n1.  **构建矩阵 $A$**：给定参数 $N$、$L$、$\\delta$ 和函数 $k(x)$，计算网格间距 $h = L/(N+1)$。确定网格点 $x_i$ 和相应的波数 $k_i$。然后根据其定义构建三对角矩阵 $A$。\n2.  **构建预条件子 $M_{\\mathrm{SSOR}}(\\omega)$**：从 $A$ 中提取矩阵 $D$、$L$ 和 $U$。通过对其对角元素求逆来计算对角矩阵的逆 $D^{-1}$。然后使用公式将这些分量组合成 $M_{\\mathrm{SSOR}}(\\omega)$。此步骤对任何指定的 $\\omega \\neq 2$ 执行。请注意，如果 $\\omega > 2$，前置因子 $\\frac{\\omega}{2-\\omega}$ 为负，这通常会使 $M_{\\mathrm{SSOR}}(\\omega)$ 不是正定的。\n3.  **测试 SPD 属性**：尝试对 $M_{\\mathrm{SSOR}}(\\omega)$ 进行 Cholesky 分解。如果分解成功，$M_{\\mathrm{SSOR}}(\\omega)$ 被确认为 SPD。如果失败，则该矩阵不是 SPD。\n4.  **备用分块分析**：如果发现 $M_{\\mathrm{SSOR}}(\\omega)$ 不是 SPD 的，则问题指定了一个备用程序。将索引集 $\\{1, 2, \\dots, N\\}$ 划分为给定大小 $B$ 的连续块。对于每个块，提取原始系统矩阵的相应主子矩阵 $A_{\\mathrm{block}}$。然后通过 Cholesky 分解测试每个 $A_{\\mathrm{block}}$ 的 SPD 属性。\n5.  **推荐与报告**：基于分块分析：\n    - 如果子矩阵 $A_{\\mathrm{block}}$ 是 SPD 的，则对该块的建议是使用对称高斯-赛德尔 (SGS) 预条件子，这对于 SPD 问题是一个很好的选择。\n    - 如果 $A_{\\mathrm{block}}$ 不是 SPD 的，则推荐使用更安全、更简单的雅可比预条件子 ($M_J=D$)。\n    该用例的最终输出是一个列表，包含一个表示 $M_{\\mathrm{SSOR}}(\\omega)$ 的 SPD 状态的布尔值，以及分别推荐使用 SGS 和雅可比预条件子的块数的整数计数。如果 $M_{\\mathrm{SSOR}}(\\omega)$ 是 SPD 的，则这两个计数都为零，因为不会触发备用策略。\n\n此过程系统地应用于每个测试用例，通过改变物理和数值参数来探索问题的不同状况。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import cholesky, LinAlgError\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    def run_case(N, k_func, delta, omega, B):\n        \"\"\"\n        Processes a single test case.\n\n        Args:\n            N (int): Number of interior grid points.\n            k_func (callable): Function defining k(x).\n            delta (float): Damping coefficient.\n            omega (float): SSOR relaxation parameter.\n            B (int): Block size for fallback analysis.\n\n        Returns:\n            list: A list containing [is_M_spd, sgs_count, jacobi_count].\n        \"\"\"\n        L_domain = 1.0\n        h = L_domain / (N + 1)\n        x = np.arange(1, N + 1) * h\n        k = k_func(x)\n\n        # Construct the matrix A\n        diag_A = 2.0 / h**2 - k**2 + delta\n        off_diag_A = -1.0 / h**2\n        \n        A = np.diag(diag_A)\n        if N  1:\n            A += np.diag([off_diag_A] * (N - 1), k=1)\n            A += np.diag([off_diag_A] * (N - 1), k=-1)\n\n        # Initialize results\n        is_M_spd = False\n        sgs_count = 0\n        jacobi_count = 0\n        \n        # Check for invalid omega that leads to division by zero\n        if omega == 2.0:\n            # The formula for M_ssor is undefined, so it cannot be SPD.\n            is_M_spd = False\n        else:\n            # Construct the SSOR preconditioner M_ssor\n            D = np.diag(np.diag(A))\n            if np.any(np.diag(D) == 0):\n                # D is not invertible, M_ssor cannot be formed correctly. Treat as not SPD.\n                is_M_spd = False\n            else:\n                L_mat = np.tril(A, k=-1)\n                U_mat = np.triu(A, k=1)\n                D_inv = np.diag(1.0 / np.diag(D))\n                \n                prefactor = omega / (2.0 - omega)\n                \n                # Using @ for matrix multiplication\n                term1 = D + omega * L_mat\n                term2 = D + omega * U_mat\n                M_ssor = prefactor * (term1 @ D_inv @ term2)\n\n                # Test if M_ssor is SPD using Cholesky factorization\n                try:\n                    cholesky(M_ssor, lower=True)\n                    is_M_spd = True\n                except LinAlgError:\n                    is_M_spd = False\n\n        # If M_ssor is not SPD, perform block-wise analysis of A\n        if not is_M_spd:\n            num_blocks = N // B\n            for i in range(num_blocks):\n                start_idx = i * B\n                end_idx = (i + 1) * B\n                A_block = A[start_idx:end_idx, start_idx:end_idx]\n                \n                try:\n                    cholesky(A_block, lower=True)\n                    sgs_count += 1\n                except LinAlgError:\n                    jacobi_count += 1\n                    \n        return [is_M_spd, sgs_count, jacobi_count]\n\n    test_cases = [\n        # Case 1: N=64, k(x)=0, delta=0, omega=1, B=16\n        (64, lambda x: np.zeros_like(x), 0.0, 1.0, 16),\n        # Case 2: N=64, k(x)=5, delta=0.1, omega=1.2, B=16\n        (64, lambda x: np.full_like(x, 5.0), 0.1, 1.2, 16),\n        # Case 3: N=64, piecewise k(x), delta=0.05, omega=1, B=8\n        (64, lambda x: np.where(x  0.5, 2.0, 5.0), 0.05, 1.0, 8),\n        # Case 4: N=64, k(x)=2, delta=0, omega=1.99, B=16\n        (64, lambda x: np.full_like(x, 2.0), 0.0, 1.99, 16),\n        # Case 5: N=64, k(x)=2, delta=0, omega=2.1, B=16\n        (64, lambda x: np.full_like(x, 2.0), 0.0, 2.1, 16),\n    ]\n\n    results = []\n    for case in test_cases:\n        N_val, k_f, delta_val, omega_val, B_val = case\n        result = run_case(N_val, k_f, delta_val, omega_val, B_val)\n        results.append(result)\n\n    # Format the final output string\n    # str() on a list prints with spaces, e.g., '[True, 0, 0]'.\n    # The requirement is just a comma-separated list of lists.\n    # No spaces within the inner lists.\n    results_str = [f\"[{res[0]},{res[1]},{res[2]}]\" for res in results]\n    print(f\"[{','.join(results_str)}]\")\n\n\nsolve()\n```", "id": "3605479"}, {"introduction": "本练习将我们的视角提升到更高层次，将雅可比和 SSOR 等预处理器视为强大的多重网格框架中的“光滑子”。您将为一个具有挑战性的非均质扩散问题实现一个完整的双网格循环。核心任务是运用局部傅里叶分析（LFA）来预测光滑子的性能，并通过直接数值模拟来验证这些理论预测，从而架起解析理论与计算结果之间的桥梁。[@problem_id:3605541]", "problem": "你需要实现一个完整且可运行的程序，该程序执行局部傅里叶分析，以预测和验证在计算地球物理学中用作预条件子的两种经典光滑子（加权雅可比和对称逐次超松弛(SSOR)）的双网格收敛因子。该椭圆算子源于对非均匀渗透率场的离散化。你的预测将基于将系数局部冻结为常数值（背景和通道），而验证将在高对比度通道化场上测量代表性傅里叶模式的放大因子。\n\n从以下基本基础开始：\n- 多孔介质中的离散化流动由微分算子 $-\\nabla \\cdot (k(\\mathbf{x}) \\nabla u)$ 产生的标量扩散算子建模。\n- 在具有 $N$ 个点的一维均匀周期性网格上，对 $- \\frac{d}{dx} \\left( k(x) \\frac{du}{dx} \\right)$ 进行守恒二阶有限体积离散化，会产生一个线性系统 $A \\mathbf{u} = \\mathbf{b}$，其中三对角矩阵 $A$ 由面心传导率构建。对于周期性边界条件，$A$ 有两条次对角线，外加第一个和最后一个未知数之间的环绕耦合。\n- 如果 $k$ 是常数且网格是周期性的，离散傅里叶模式 $\\phi_\\theta(i) = \\exp(\\mathrm{i} \\theta i)$ 是该算子的特征向量，其特征值（符号）为 $a(\\theta) = 2k (1 - \\cos \\theta)$。\n- 针对 $A \\mathbf{u} = \\mathbf{b}$ 的加权雅可比松弛更新为 $\\mathbf{u}^{(m+1)} = \\mathbf{u}^{(m)} + \\omega_J D^{-1} (\\mathbf{b} - A \\mathbf{u}^{(m)})$，其中 $D$ 是 $A$ 的对角线，$\\omega_J$ 是松弛参数。相应的线性误差传播算子是 $E_J = I - \\omega_J D^{-1} A$。\n- 使用参数 $\\omega_S$ 的对称逐次超松弛 (SSOR) 应用一次前向逐次超松弛 (SOR) 扫描，然后进行一次后向 SOR 扫描。每次 SOR 扫描执行由松弛增强的字典序高斯-赛德尔更新。\n- 具有一个预光滑步骤和一个后光滑步骤的双网格循环应用以下操作：预光滑、残差计算、限制到粗网格、粗网格精确求解、在细网格上延长和校正，以及后光滑。在一维中使用标准的全加权限制和线性插值延长。\n\n你的任务是：\n1) 通过在单元面使用调和平均，从给定的渗透率场 $k_i$ 组装一维周期性细网格算子 $A_f$。也就是说，如果 $k_i$ 是单元中心的渗透率，那么在 $i+\\tfrac{1}{2}$ 处的面中心渗透率是 $k_{i+\\frac{1}{2}} = \\frac{2 k_i k_{i+1}}{k_i + k_{i+1}}$，并带有周期性环绕。矩阵项为 $A_{i,i} = k_{i-\\frac{1}{2}} + k_{i+\\frac{1}{2}}$，$A_{i,i-1} = -k_{i-\\frac{1}{2}}$，$A_{i,i+1} = -k_{i+\\frac{1}{2}}$，索引带有周期性环绕。\n2) 定义两种光滑子：\n   - 使用参数 $\\omega_J$ 的加权雅可比，误差更新如上所示为 $E_J$。\n   - 使用参数 $\\omega_S$ 的对称逐次超松弛 (SSOR)，通过对误差应用一次前向 SOR 扫描和一次后向 SOR 扫描，并将右侧项设为零。直接为周期性三对角加环绕算子实现三角更新，使用字典序，并在每个扫描方向上将环绕项一致地视为上三角或下三角部分。\n3) 构建一个具有一个预光滑和一个后光滑步骤的双网格循环。在一维中使用全加权限制和线性插值延长。对于粗网格求解，通过 Moore-Penrose 伪逆在最小范数意义下进行精确求解，这对于与零空间正交的残差是良定义的。通过在具有 $N/2$ 个点的粗网格上进行重新离散化来组装粗网格算子，其中粗单元的渗透率定义为两个底层细单元的算术平均值，而粗单元面的渗透率是相邻粗单元的调和平均值。\n4) 局部傅里叶分析预测：对于分别对应于背景和通道渗透率的常系数区域，通过对细网格傅里叶模式 $\\phi_\\theta(i) = \\exp(\\mathrm{i} \\theta i)$（其中 $\\theta = \\frac{2\\pi k}{N}$）应用一个双网格循环，然后将结果投影回同一模式以提取标量放大因子，来计算给定傅里叶模式的双网格放大因子。因为在常系数情况下算子是平移不变的，所以这个投影产生了该模式的特征放大。\n5) 在非均匀高对比度通道化场上进行验证：构建一个背景渗透率为 $k_{\\mathrm{bg}}$ 的通道化渗透率 $k_i$，其中一个具有预设宽度和位置的连续“通道”段具有高渗透率 $k_{\\mathrm{ch}} \\gg k_{\\mathrm{bg}}$。在这个非均匀的 $A_f$ 上，对相同的傅里叶模式应用相同的双网格循环，并通过投影到该模式上来测量放大因子，就像在常系数情况下一样。这得出了沿所选傅里叶模式的输出误差分量。\n\n使用纯数学单位；不需要物理单位。角度以弧度为单位，定义为 $\\theta = \\frac{2\\pi k}{N}$。\n\n测试套件：\n- 网格尺寸：$N=128$ 个点，周期性。\n- 背景渗透率：$k_{\\mathrm{bg}} = 1$。\n- 通道渗透率：$k_{\\mathrm{ch}} = 10^3$。\n- 通道几何形状：一个宽度为域宽度分数 $w = 0.25$ 的连续块，位于域中点。\n- 光滑子和参数：加权雅可比，$\\omega_J = 0.7$；SSOR，$\\omega_S = 1.5$。\n- 双网格设置：一个预光滑步骤和一个后光滑步骤。\n- 要测试的傅里叶模式：索引 $k \\in \\{1, N/4, N/2 - 2\\}$，即 $\\{1, 32, 62\\}$。\n- 对于每对（光滑子，模式），计算三个浮点数值：\n  - 恒定背景区域（$k \\equiv k_{\\mathrm{bg}}$）的预测双网格放大因子。\n  - 恒定通道区域（$k \\equiv k_{\\mathrm{ch}}$）的预测双网格放大因子。\n  - 非均匀通道化场的测量放大因子。\n- 将每个放大因子四舍五入到 $6$ 位小数。\n\n最终输出格式：\n- 你的程序应该生成一行输出，其中包含一个类 Python 的列表的列表：\n  - 对于每个测试用例，应有一个内部列表，按下面列出的顺序排列。\n  - 每个内部列表必须是 $[g_{\\mathrm{bg}}, g_{\\mathrm{ch}}, g_{\\mathrm{het}}]$ 的形式，其中每个条目都是一个四舍五入到 $6$ 位小数的浮点数。\n  - 测试用例的顺序是：\n    1. 加权雅可比，$\\omega_J = 0.7$, $k = 1$。\n    2. 加权雅可比，$\\omega_J = 0.7$, $k = N/4$。\n    3. 加权雅可比，$\\omega_J = 0.7$, $k = N/2 - 2$。\n    4. SSOR，$\\omega_S = 1.5$, $k = 1$。\n    5. SSOR，$\\omega_S = 1.5$, $k = N/4$。\n    6. SSOR，$\\omega_S = 1.5$, $k = N/2 - 2$。\n- 例如，你的程序应打印一行类似 $[[g_{1,\\mathrm{bg}},g_{1,\\mathrm{ch}},g_{1,\\mathrm{het}}],\\dots,[g_{6,\\mathrm{bg}},g_{6,\\mathrm{ch}},g_{6,\\mathrm{het}}]]$ 的内容，前后不带任何额外文本。", "solution": "用户要求编写一个程序，对具有非均匀渗透率场的一维标量扩散问题，执行双网格方法的局部傅里叶分析（LFA）。该程序必须预测常系数算子（LFA）的双网格收敛因子，并与高对比度通道化场上测得的放大因子进行验证。\n\n### 方法论阐述\n\n该解决方案通过实现指定的算子和循环组件来构建，然后将它们组装起来以模拟双网格过程，并测量其对特定傅里叶模式的影响。\n\n#### 1. 离散化与算子组装\n控制方程 $-\\frac{d}{dx} (k(x) \\frac{du}{dx}) = f$ 在一个包含 $N$ 个单元的周期性网格上使用二阶有限体积法进行离散化。单元中心的渗透率为 $k_i$。关键是在单元面 $i+1/2$ 处使用调和平均计算渗透率：\n$$\nk_{i+\\frac{1}{2}} = \\frac{2 k_i k_{i+1}}{k_i + k_{i+1}}\n$$\n对于不连续系数，这种选择是保持通量连续性的标准方法。使用周期性索引，这会产生一个稀疏、对称、半正定的线性系统 $A\\mathbf{u} = \\mathbf{b}$。由于周期性，矩阵 $A$ 在其主对角线、第一条次对角线以及角落处有非零项。具体来说，对于每一行 $i$：\n$$\nA_{i,i} = k_{i-\\frac{1}{2}} + k_{i+\\frac{1}{2}}\n$$\n$$\nA_{i, i-1 \\pmod N} = -k_{i-\\frac{1}{2}}\n$$\n$$\nA_{i, i+1 \\pmod N} = -k_{i+\\frac{1}{2}}\n$$\n$A$ 的零空间由常数向量 $\\mathbf{1}$ 张成，这反映了纯诺伊曼问题的解在相差一个常数的情况下是唯一的。\n\n#### 2. 光滑子实现\n该分析要求实现两种经典光滑子作为误差传播算子 ($E$)。\n\n**加权雅可比：** 误差更新由 $\\mathbf{e}^{(m+1)} = (I - \\omega_J D^{-1} A) \\mathbf{e}^{(m)}$ 给出，其中 $D = \\text{diag}(A)$。因此，误差传播算子为：\n$$\nE_J = I - \\omega_J D^{-1} A\n$$\n\n**对称逐次超松弛 (SSOR)：** SSOR 由一次前向 SOR 扫描和一次后向 SOR 扫描组成。我们为每次扫描定义误差传播算子并将它们复合。使用分解 $A = D+L+U$（其中 $D$ 是对角部分， $L$ 是严格下三角部分， $U$ 是严格上三角部分，周期性环绕项根据字典序一致地分配给 $L$ 和 $U$），前向 SOR 误差算子为：\n$$\nE_{\\text{fwd}} = (D+\\omega_S L)^{-1}((1-\\omega_S)D - \\omega_S U)\n$$\n而后向 SOR 误差算子为：\n$$\nE_{\\text{bwd}} = (D+\\omega_S U)^{-1}((1-\\omega_S)D - \\omega_S L)\n$$\n总的 SSOR 误差传播算子是这两个算子的乘积：\n$$\nE_{SSOR} = E_{\\text{bwd}} E_{\\text{fwd}}\n$$\n由于 $D+\\omega_S L$ 是下三角矩阵，$D+\\omega_S U$ 是上三角矩阵，它们的逆可以通过三角求解高效处理。\n\n#### 3. 双网格循环组件\n双网格循环涉及网格间传递算子和粗网格问题。\n\n**网格间传递：**\n- **限制 ($R$)：** 使用全加权。对于对应于细网格点 $2j$ 的粗网格点 $j$，模板 $[\\frac{1}{4}, \\frac{1}{2}, \\frac{1}{4}]$ 应用于点 $2j-1, 2j, 2j+1$ 处的细网格值（使用周期性索引）。\n- **延长 ($P$)：** 使用标准线性插值。粗网格点 $j$ 处的值被复制到细网格点 $2j$，而奇数索引的细网格点的值是其两个相邻粗网格点值的平均值。\n\n**粗网格问题：**\n粗网格算子 $A_c$ 通过重新离散化（“系数的伽辽金方法”）形成。粗单元 $j$ 的渗透率是其下属的两个细单元渗透率的算术平均值：$k_{c,j} = \\frac{1}{2}(k_{f,2j} + k_{f,2j+1})$。然后使用与 $A_f$ 相同的调和平均规则组装 $A_c$。由于 $A_c$ 也是奇异的，粗网格方程使用 Moore-Penrose 伪逆 $A_c^\\dagger$ 在最小范数意义下求解。\n\n#### 4. 双网格算子与分析\n具有一个预光滑和一个后光滑步骤的双网格循环的误差传播算子是：\n$$\nM_{TG} = S (I - P A_c^\\dagger R A_f) S\n$$\n其中 $S$ 是所选的光滑算子（$E_J$ 或 $E_{SSOR}$），$I$ 是单位矩阵。\n\n分析通过将此算子应用于细网格傅里叶模式 $\\phi_k(j) = \\exp(i \\frac{2\\pi k}{N} j)$ 并测量其产生的放大来进行。放大因子 $g$ 是输出向量沿原始模式的分量，通过投影得到：\n$$\ng = \\frac{\\langle M_{TG} \\phi_k, \\phi_k \\rangle}{\\langle \\phi_k, \\phi_k \\rangle} = \\frac{\\phi_k^H (M_{TG} \\phi_k)}{N}\n$$\n$|g|$ 的大小是该模式的收敛因子。此过程针对三种情况执行：\n1.  **LFA 预测（背景）：** $A_f$ 和 $A_c$ 由常数渗透率场 $k(x) \\equiv k_{\\mathrm{bg}}$ 构建。\n2.  **LFA 预测（通道）：** $A_f$ 和 $A_c$ 由常数渗透率场 $k(x) \\equiv k_{\\mathrm{ch}}$ 构建。\n3.  **非均匀验证：** $A_f$ 和 $A_c$ 由高对比度通道化场构建。\n\n比较这三个值在不同光滑子和傅里叶模式下的结果，揭示了局部傅里叶分析在预测多重网格方法在非均匀问题上性能的有效性。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Performs local Fourier analysis to predict and validate two-grid convergence\n    factors for weighted Jacobi and SSOR smoothers on a 1D diffusion problem.\n    \"\"\"\n    # Use complex numbers throughout for Fourier analysis\n    DTYPE = np.complex128\n\n    def create_k_field(N, k_bg, k_ch, w):\n        \"\"\"Creates a 1D permeability field with a central channel.\"\"\"\n        k = np.full(N, k_bg, dtype=float)\n        if w > 0:\n            channel_width = int(N * w)\n            start_idx = (N - channel_width) // 2\n            end_idx = start_idx + channel_width\n            k[start_idx:end_idx] = k_ch\n        return k\n\n    def assemble_operator(k):\n        \"\"\"Assembles the 1D periodic finite-volume matrix A.\"\"\"\n        N = len(k)\n        A = np.zeros((N, N), dtype=float)\n        \n        k_face = np.zeros(N, dtype=float)\n        for i in range(N):\n            k_face[i] = 2 * k[i] * k[(i + 1) % N] / (k[i] + k[(i + 1) % N])\n\n        for i in range(N):\n            k_prev = k_face[(i - 1 + N) % N]\n            k_next = k_face[i]\n            A[i, i] = k_prev + k_next\n            A[i, (i - 1 + N) % N] = -k_prev\n            A[i, (i + 1) % N] = -k_next\n            \n        return A.astype(DTYPE)\n\n    def get_transfer_ops(N_f):\n        \"\"\"Builds 1D full-weighting restriction (R) and linear interpolation (P).\"\"\"\n        if N_f % 2 != 0:\n            raise ValueError(\"Fine grid size N_f must be even.\")\n        N_c = N_f // 2\n        \n        R = np.zeros((N_c, N_f), dtype=DTYPE)\n        for j in range(N_c):\n            R[j, (2 * j - 1 + N_f) % N_f] = 0.25\n            R[j, 2 * j] = 0.5\n            R[j, (2 * j + 1) % N_f] = 0.25\n            \n        P = np.zeros((N_f, N_c), dtype=DTYPE)\n        for j in range(N_c):\n            P[2 * j, j] = 1.0\n            P[2 * j + 1, j] = 0.5\n            P[2 * j + 1, (j + 1) % N_c] = 0.5\n\n        return R, P\n\n    def get_jacobi_smoother_op(A, omega_J):\n        \"\"\"Returns the weighted Jacobi error propagation operator.\"\"\"\n        N = A.shape[0]\n        D_inv = np.diag(1.0 / np.diag(A))\n        E_J = np.eye(N, dtype=DTYPE) - omega_J * (D_inv @ A)\n        return E_J\n\n    def get_ssor_smoother_op(A, omega_S):\n        \"\"\"Returns the SSOR error propagation operator.\"\"\"\n        N = A.shape[0]\n        D = np.diag(np.diag(A))\n        L = np.tril(A, k=-1)\n        U = np.triu(A, k=1)\n        \n        # Forward SOR error operator: E_fwd = inv(D+wL) * ((1-w)D - wU)\n        RHS_fwd = (1 - omega_S) * D - omega_S * U\n        LHS_fwd = D + omega_S * L\n        E_fwd = linalg.solve_triangular(LHS_fwd, RHS_fwd, lower=True)\n\n        # Backward SOR error operator: E_bwd = inv(D+wU) * ((1-w)D - wL)\n        RHS_bwd = (1 - omega_S) * D - omega_S * L\n        LHS_bwd = D + omega_S * U\n        E_bwd = linalg.solve_triangular(LHS_bwd, RHS_bwd, lower=False)\n\n        E_ssor = E_bwd @ E_fwd\n        return E_ssor\n\n    def get_two_grid_cycle_op(A_f, S, P, R, A_c_inv):\n        \"\"\"Returns the two-grid cycle error propagation operator.\"\"\"\n        N_f = A_f.shape[0]\n        I_f = np.eye(N_f, dtype=DTYPE)\n        \n        C = I_f - P @ A_c_inv @ R @ A_f\n        M_TG = S @ C @ S\n        return M_TG\n\n    # --- Test Suite Parameters ---\n    N = 128\n    k_bg = 1.0\n    k_ch = 1000.0\n    w = 0.25\n    omega_J = 0.7\n    omega_S = 1.5\n    mode_indices = [1, 32, 62]\n\n    # --- Setup ---\n    R, P = get_transfer_ops(N)\n    \n    fourier_modes = {}\n    for k in mode_indices:\n        theta = 2 * np.pi * k / N\n        fourier_modes[k] = np.exp(1j * theta * np.arange(N, dtype=float)).astype(DTYPE)\n\n    test_cases = [\n        (\"jacobi\", omega_J, 1), (\"jacobi\", omega_J, 32), (\"jacobi\", omega_J, 62),\n        (\"ssor\", omega_S, 1), (\"ssor\", omega_S, 32), (\"ssor\", omega_S, 62),\n    ]\n\n    all_results = []\n    \n    for smoother_type, omega, mode_k in test_cases:\n        mode_vector = fourier_modes[mode_k]\n        case_results = []\n        \n        scenarios = [\n            (k_bg, k_bg, 0.0),    # Background constant field\n            (k_ch, k_ch, 0.0),    # Channel constant field\n            (k_bg, k_ch, w)       # Heterogeneous field\n        ]\n\n        for k1, k2, width_frac in scenarios:\n            k_f = create_k_field(N, k1, k2, width_frac)\n            A_f = assemble_operator(k_f)\n            \n            if smoother_type == \"jacobi\":\n                S = get_jacobi_smoother_op(A_f, omega)\n            else:\n                S = get_ssor_smoother_op(A_f, omega)\n\n            N_c = N // 2\n            k_c = np.array([0.5 * (k_f[2*j] + k_f[2*j+1]) for j in range(N_c)])\n            A_c = assemble_operator(k_c)\n            A_c_inv = np.linalg.pinv(A_c)\n\n            M_TG = get_two_grid_cycle_op(A_f, S, P, R, A_c_inv)\n            \n            output_vector = M_TG @ mode_vector\n            amp_factor = np.vdot(mode_vector, output_vector) / np.vdot(mode_vector, mode_vector)\n            \n            case_results.append(round(np.abs(amp_factor), 6))\n        \n        all_results.append(case_results)\n\n    # --- Final Output Formatting ---\n    output_str = \"[\"\n    for i, sublist in enumerate(all_results):\n        output_str += \"[\" + \",\".join(map(str, sublist)) + \"]\"\n        if i  len(all_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3605541"}]}