{"hands_on_practices": [{"introduction": "理解不完全 LU 分解（ILU）的关键在于其丢弃策略，即在保持稀疏性的同时如何选择性地保留最重要的信息。本练习将引导您亲手执行一次带阈值的不完全 LU 分解（ILUT）中的关键步骤，通过计算来具体体验 ILUT 算法如何在精度和计算成本之间做出权衡。这个基础练习对于掌握更高级的 ILU 变种至关重要 (Citations: [@problem_id:3604446])。", "problem": "在一个由非均匀地壳模型中声波方程的有限差分离散化产生的稀疏线性系统中，构建一个带阈值的不完全LU分解（ILUT）预条件子。考虑上三角因子 $U$ 的第 $i$ 行的单次消元步骤。在应用当前的主元更新后，第 $i$ 行的中间填充候选元素由集合 $\\{(j, a_{j})\\}$ 表示，其中 $j$ 是列位置的索引，$a_{j}$ 是对应的候选元素值。ILUT选择规则定义如下：计算候选元素值的欧几里得范数（二范数），使用舍弃容差 $\\tau$ 形成一个阈值 $\\theta = \\tau \\|\\mathbf{a}\\|_{2}$，在满足 $|a_{j}| \\ge \\theta$ 的元素中，最多保留 $p$ 个绝对值最大的元素，并舍弃其余元素。被舍弃的值共同构成了该行的残差向量，其二范数在此被称为“被舍弃残差的行范数”。\n\n对于特定的第 $i$ 行，中间填充候选元素集合为\n$$\n\\{(4,\\, 0.036),\\ (8,\\,-0.204),\\ (11,\\, 0.011),\\ (14,\\, 0.158),\\ (17,\\,-0.072),\\ (19,\\, 0.005),\\ (21,\\,-0.119),\\ (25,\\, 0.033),\\ (27,\\,-0.002)\\}.\n$$\n使用参数 $p=3$ 和 $\\tau=0.1$ 的 ILUT，执行上述定义的一个ILUT选择步骤。计算该行被舍弃的残差向量的欧几里得范数。请用一个不带单位的纯数字表示你的答案，并将结果四舍五入到四位有效数字。", "solution": "该问题被验证为具有科学依据、适定、客观且信息自洽。它描述了数值线性代数中的一个标准过程（带阈值的不完全LU分解），并应用于一个合理的科学计算背景（计算地球物理学）。所有必要的数据和参数都已提供，目标明确。未发现任何缺陷。\n\n任务是为一个给定行执行一步ILUT（带阈值的不完全LU分解）选择过程，并计算被舍弃元素构成的向量的欧几里得范数。\n\n给定的第 $i$ 行的中间填充候选元素集合是：\n$$\nS = \\{(4,\\, 0.036),\\ (8,\\,-0.204),\\ (11,\\, 0.011),\\ (14,\\, 0.158),\\ (17,\\,-0.072),\\ (19,\\, 0.005),\\ (21,\\,-0.119),\\ (25,\\, 0.033),\\ (27,\\,-0.002)\\}\n$$\nILUT参数为填充限制 $p=3$ 和舍弃容差 $\\tau=0.1$。\n\nILUT选择规则涉及两个标准：一个基于候选行范数的阈值，以及一个保留非零元素数量的限制。\n\n首先，我们定义候选元素值的向量 $\\mathbf{a}$：\n$$\n\\mathbf{a} = \\begin{pmatrix} 0.036  -0.204  0.011  0.158  -0.072  0.005  -0.119  0.033  -0.002 \\end{pmatrix}\n$$\n接下来，我们计算这个向量的欧几里得范数（二范数），$\\|\\mathbf{a}\\|_{2}$：\n$$\n\\|\\mathbf{a}\\|_{2} = \\sqrt{0.036^2 + (-0.204)^2 + 0.011^2 + 0.158^2 + (-0.072)^2 + 0.005^2 + (-0.119)^2 + 0.033^2 + (-0.002)^2}\n$$\n平方和为：\n$$\n\\sum a_j^2 = 0.001296 + 0.041616 + 0.000121 + 0.024964 + 0.005184 + 0.000025 + 0.014161 + 0.001089 + 0.000004 = 0.08846\n$$\n所以，范数是：\n$$\n\\|\\mathbf{a}\\|_{2} = \\sqrt{0.08846} \\approx 0.29742226\n$$\n现在，我们使用舍弃容差 $\\tau=0.1$ 计算阈值 $\\theta$：\n$$\n\\theta = \\tau \\|\\mathbf{a}\\|_{2} = 0.1 \\times \\sqrt{0.08846} \\approx 0.029742226\n$$\n选择规则规定，我们保留满足 $|a_j| \\ge \\theta$ 的元素 $(j, a_j)$，并在这些元素中，最多保留 $p=3$ 个绝对值最大的元素。所有其他元素都将被舍弃。\n\n让我们计算每个候选元素的绝对值：\n\\begin{itemize}\n    \\item $|a_4| = |0.036| = 0.036$\n    \\item $|a_8| = |-0.204| = 0.204$\n    \\item $|a_{11}| = |0.011| = 0.011$\n    \\item $|a_{14}| = |0.158| = 0.158$\n    \\item $|a_{17}| = |-0.072| = 0.072$\n    \\item $|a_{19}| = |0.005| = 0.005$\n    \\item $|a_{21}| = |-0.119| = 0.119$\n    \\item $|a_{25}| = |0.033| = 0.033$\n    \\item $|a_{27}| = |-0.002| = 0.002$\n\\end{itemize}\n我们找出满足阈值条件 $|a_j| \\ge \\theta \\approx 0.02974$ 的元素：\n\\begin{itemize}\n    \\item $|a_4| = 0.036 \\ge \\theta$\n    \\item $|a_8| = 0.204 \\ge \\theta$\n    \\item $|a_{11}| = 0.011  \\theta$\n    \\item $|a_{14}| = 0.158 \\ge \\theta$\n    \\item $|a_{17}| = 0.072 \\ge \\theta$\n    \\item $|a_{19}| = 0.005  \\theta$\n    \\item $|a_{21}| = 0.119 \\ge \\theta$\n    \\item $|a_{25}| = 0.033 \\ge \\theta$\n    \\item $|a_{27}| = 0.002  \\theta$\n\\end{itemize}\n满足阈值条件的候选元素集合包含 $6$ 个元素。我们必须从中选择最多 $p=3$ 个，特别是那些绝对值最大的。让我们按绝对值降序排列它们：\n$0.204  0.158  0.119  0.072  0.036  0.033$。\n\n要保留的前 $p=3$ 个元素是对应于绝对值 $0.204$、$0.158$ 和 $0.119$ 的元素。\n保留的元素集合是：\n$$\nS_{\\text{kept}} = \\{(8, -0.204), (14, 0.158), (21, -0.119)\\}\n$$\n被舍弃的元素是原始候选集 $S$ 中的所有其他元素。被舍弃的元素集合是 $S_{\\text{dropped}} = S \\setminus S_{\\text{kept}}$：\n$$\nS_{\\text{dropped}} = \\{(4, 0.036), (11, 0.011), (17, -0.072), (19, 0.005), (25, 0.033), (27, -0.002)\\}\n$$\n“被舍弃残差的行范数”是由这些被舍弃元素的值构成的向量的欧几里得范数。设此向量为 $\\mathbf{r}_{\\text{dropped}}$：\n$$\n\\mathbf{r}_{\\text{dropped}} = \\begin{pmatrix} 0.036  0.011  -0.072  0.005  0.033  -0.002 \\end{pmatrix}\n$$\n我们计算其欧几里得范数：\n$$\n\\|\\mathbf{r}_{\\text{dropped}}\\|_{2} = \\sqrt{0.036^2 + 0.011^2 + (-0.072)^2 + 0.005^2 + 0.033^2 + (-0.002)^2}\n$$\n平方和为：\n$$\n\\sum r_{\\text{dropped},j}^2 = 0.001296 + 0.000121 + 0.005184 + 0.000025 + 0.001089 + 0.000004 = 0.007719\n$$\n范数是：\n$$\n\\|\\mathbf{r}_{\\text{dropped}}\\|_{2} = \\sqrt{0.007719} \\approx 0.0878578396\n$$\n问题要求答案四舍五入到四位有效数字。\n这个数是 $0.0878578...$。前四位有效数字是 $8, 7, 8, 5$。第五位有效数字是 $7$，大于等于 $5$，所以我们将第四位有效数字向上取整。\n$$\n0.08786\n$$", "answer": "$$\n\\boxed{0.08786}\n$$", "id": "3604446"}, {"introduction": "预条件子的选择不仅影响收敛速度，还可能深刻影响数值解的物理保真度，尤其是在求解守恒律方程时。本实践要求您通过编程对比标准 ILU(0) 和修正 ILU (MILU) 预条件子，以量化它们在平流-扩散问题中对质量守恒的影响。通过这个练习，您将深入理解为何 MILU 在许多地球物理模拟中是维持离散守恒性的首选 (Citations: [@problem_id:3604408])。", "problem": "您必须编写一个完整且可运行的程序，该程序构建一个由二维对流扩散问题在周期性矩形网格上的后向欧拉隐式时间步所产生的线性系统，然后比较标准的非完全下上 (ILU) 分解和修正的非完全下上 (MILU) 分解在作为定常 Richardson 迭代中的左预条件子时，每次迭代产生的全局质量误差。目的是明确展示一种场景：在该场景中，标准 ILU 在迭代层面破坏了守恒性，而 MILU 通过保持离散的行和性质来减少这一缺陷。\n\n构建过程必须基于以下基础且经过充分检验的要素和定义。\n\n1) 离散通量下的守恒性。考虑一个在 $x$ 方向有 $N_x$ 个单元格、在 $y$ 方向有 $N_y$ 个单元格的均匀矩形网格；用 $n = N_x N_y$ 表示总单元格数，用 $\\Delta x = 1/N_x$ 和 $\\Delta y = 1/N_y$ 表示网格间距，用 $i \\in \\{0,\\dots,N_x-1\\}$，$j \\in \\{0,\\dots,N_y-1\\}$ 表示单元格索引。通过具有周期性边界条件的守恒通量平衡，使用恒定的速度分量 $u_x$ 和 $u_y$ 以及恒定的扩散系数 $\\kappa \\ge 0$，定义一个离散算子 $L \\in \\mathbb{R}^{n \\times n}$：\n- 设从一个单元格到其四个直接相邻单元格的流出率为 $w_E = \\kappa/\\Delta x^2 + \\max(u_x,0)/\\Delta x$，$w_W = \\kappa/\\Delta x^2 + \\max(-u_x,0)/\\Delta x$，$w_N = \\kappa/\\Delta y^2 + \\max(u_y,0)/\\Delta y$，$w_S = \\kappa/\\Delta y^2 + \\max(-u_y,0)/\\Delta y$。\n- 对于该线性算子，将对应东、西、北、南相邻单元格的非对角线元素分别设置为 $-w_E$，$-w_W$，$-w_N$ 和 $-w_S$，对角线元素设置为 $w_E + w_W + w_N + w_S$。对于周期性，$(N_x-1,j)$ 的东邻居是 $(0,j)$，$(0,j)$ 的西邻居是 $(N_x-1,j)$，$(i,N_y-1)$ 的北邻居是 $(i,0)$，$(i,0)$ 的南邻居是 $(i,N_y-1)$。\n- 根据构造，这得到 $L \\mathbf{1} = \\mathbf{0}$，等价于 $\\mathbf{1}^\\top L = \\mathbf{0}^\\top$，其中 $\\mathbf{1}$ 是全为一的向量。\n\n2) 后向欧拉隐式步。对于大小为 $\\Delta t  0$ 的时间步，定义系统矩阵 $B \\in \\mathbb{R}^{n \\times n}$ 为 $B = I + \\Delta t \\, L$，其中 $I$ 是单位矩阵。由于 $\\mathbf{1}^\\top L = \\mathbf{0}^\\top$，这意味着行和性质 $\\mathbf{1}^\\top B = \\mathbf{1}^\\top$。\n\n3) 离散系统中的质量守恒。对于给定的右侧向量 $b \\in \\mathbb{R}^n$，$B x = b$ 的精确解 $x^\\star$ 满足 $\\mathbf{1}^\\top x^\\star = \\mathbf{1}^\\top b$。这是 $\\mathbf{1}^\\top B = \\mathbf{1}^\\top$ 的直接推论。\n\n4) 带左预条件的迭代求解。考虑带有左预条件子 $P \\approx B$ 的定常 Richardson 迭代：\n$$\nx^{(k+1)} \\;=\\; x^{(k)} + P^{-1}\\left(b - B x^{(k)}\\right),\n$$\n初始猜测为 $x^{(0)} = \\mathbf{0}$。定义第 $k$ 次迭代后的每次迭代全局质量误差为\n$$\nE^{(k)}(P) \\;=\\; \\left| \\mathbf{1}^\\top x^{(k)} - \\mathbf{1}^\\top b \\right|.\n$$\n因为 $\\mathbf{1}^\\top B = \\mathbf{1}^\\top$，所以 $E^{(k)}(P)$ 量化了在迭代层面质量守恒的缺陷。\n\n5) 预条件子。构建 $B$ 的两种带丢弃策略的分解，其填充不超出原始非零模式（也称为0级填充）。\n- 标准非完全下上分解 (ILU($0$))：执行高斯消元，但仅限于原始稀疏模式，丢弃模式外的填充项，不作补偿。\n- 修正的非完全下上分解 (MILU($0$))：使用与 ILU($0$) 相同的操作顺序，但是当一个将在允许模式之外产生填充的更新 $d$ 发生时，丢弃它，并将其值加到当前行的对角线元素上。这种对角线吸收保持了近似分解 $P = L U$ 的行和，从而使得 $\\mathbf{1}^\\top P = \\mathbf{1}^\\top B$。\n\n程序要求。\n\nA) 系统组装。对于每组指定的参数集 $(N_x,N_y,u_x,u_y,\\kappa,\\Delta t)$，完全按照上述方式组装 $B = I + \\Delta t\\, L$。通过使用固定的种子从 $[0,1]$ 上的均匀分布中抽取独立样本来构建初始状态 $x^{(0)}_{\\text{phys}}$，然后设置 $b = x^{(0)}_{\\text{phys}}$，以此来构造右侧项 $b$。这确保了 $\\mathbf{1}^\\top b$ 是已知且固定的。\n\nB) 预条件子和迭代。通过 ILU($0$) 构建 $P_{\\text{ILU}}$，通过带丢弃更新的对角线吸收的 MILU($0$) 构建 $P_{\\text{MILU}}$。对每个预条件子，完全按照上文所述，使用松弛参数 $\\omega = 1$ 运行 $K=3$ 次 Richardson 迭代（即无额外缩放），并在每次迭代后报告 $k \\in \\{1,2,3\\}$ 的 $E^{(k)}(P)$。\n\nC) 测试套件。您的程序必须运行以下四个测试用例并汇总其结果。所有量均为无量纲，因此不需要物理单位。为保证可复现性，请使用指定的随机种子。测试套件如下：\n- 案例 A (理想路径)：$N_x = 10$，$N_y = 10$，$u_x = 1.0$，$u_y = 0.3$，$\\kappa = 0.02$，$\\Delta t = 0.1$，种子 $= 42$。\n- 案例 B (对称扩散)：$N_x = 8$，$N_y = 8$，$u_x = 0.0$，$u_y = 0.0$，$\\kappa = 0.1$，$\\Delta t = 0.2$，种子 $= 7$。\n- 案例 C (对流主导，各向异性网格)：$N_x = 16$，$N_y = 4$，$u_x = 3.0$，$u_y = -1.0$，$\\kappa = 0.005$，$\\Delta t = 0.05$，种子 $= 123$。\n- 案例 D (逆流，中等扩散)：$N_x = 12$，$N_y = 6$，$u_x = -2.0$，$u_y = 2.5$，$\\kappa = 0.01$，$\\Delta t = 0.08$，种子 $= 2024$。\n\nD) 输出。对于每个案例，生成一个长度为 6 的扁平列表，其中包含标准 ILU($0$) 和 MILU($0$) 的三次迭代全局质量误差，按以下顺序交错排列\n$$\n\\left[ E^{(1)}(P_{\\text{ILU}}), \\; E^{(1)}(P_{\\text{MILU}}), \\; E^{(2)}(P_{\\text{ILU}}), \\; E^{(2)}(P_{\\text{MILU}}), \\; E^{(3)}(P_{\\text{ILU}}), \\; E^{(3)}(P_{\\text{MILU}}) \\right].\n$$\n您的程序应生成单行输出，其中包含所有四个测试用例的结果，格式为一个由这些列表组成的、以逗号分隔的列表，并用方括号括起来。每个浮点数必须以科学记数法格式化，小数点后精确到六位数字（例如，$1.234567 \\times 10^{-3}$ 必须打印为 $1.234567\\text{e-}03$）。\n\n总而言之，您必须实现用于 $B = I + \\Delta t \\, L$ 的离散算子组装，在得到的五点周期性模板上实现带 0 级填充的 ILU($0$) 和 MILU($0$) 分解，为每个预条件子执行 $K=3$ 次预处理的 Richardson 迭代，并按规定报告每次迭代的全局质量误差。输出必须是单行，表示一个包含四个列表的列表，每个列表对应一个测试用例，长度为 6，且顺序和格式如上所述。", "solution": "用户要求编写一个程序，用于比较在使用标准非完全下上(ILU)分解和修正的非完全下上(MILU)分解作为预条件子，求解一个源自二维对流扩散问题的线性系统时，二者的质量守恒特性。该问题定义明确，科学上合理，且所有参数均已指定。我将开始提供解决方案。\n\n### 基于原理的设计\n\n问题的核心在于，在偏微分方程(PDEs)的守恒数值格式背景下，展示两种相关的预处理技术 ILU($0$) 和 MILU($0$) 之间的一个关键差异。\n\n**1. 物理与数学基础**\n\n问题始于对流扩散方程，这是许多 STEM 领域中用于描述某个量（如热量、污染物浓度、质量）输运的基本模型。在周期性域上使用守恒的有限体积法或有限差分法进行空间离散，会得到一个常微分方程组 $\\frac{d\\mathbf{\\phi}}{dt} = -L\\mathbf{\\phi}$，其中 $\\mathbf{\\phi}$ 是单元格平均量的向量，$L$ 是表示空间算子的矩阵。\n\n在周期性域上，守恒离散化的一个关键性质是，仅由空间算子作用时，总质量/总量 $\\mathbf{1}^\\top \\mathbf{\\phi}$ 随时间是守恒的。在数学上，这意味着离散算子矩阵 $L$ 的列和为零，即 $\\mathbf{1}^\\top L = \\mathbf{0}^\\top$。所提供的 $L$ 的构造方法（对流项使用迎风通量，扩散项使用中心差分）确保了这一性质，因为对于常系数，从一个单元流出的通量恰好是流入其相邻单元的通量，这导致整个网格的列和相消为零。\n\n应用后向欧拉方法进行时间积分，$(\\mathbf{\\phi}^{k+1} - \\mathbf{\\phi}^k)/\\Delta t = -L \\mathbf{\\phi}^{k+1}$，得到线性系统 $(I + \\Delta t L)\\mathbf{\\phi}^{k+1} = \\mathbf{\\phi}^k$。我们定义系统矩阵 $B = I + \\Delta t L$ 和右侧项 $b = \\mathbf{\\phi}^k$。性质 $\\mathbf{1}^\\top L = \\mathbf{0}^\\top$ 直接意味着 $B$ 的列和全为一：$\\mathbf{1}^\\top B = \\mathbf{1}^\\top(I + \\Delta t L) = \\mathbf{1}^\\top I + \\Delta t (\\mathbf{1}^\\top L) = \\mathbf{1}^\\top$。这是线性系统精确解的质量守恒的离散模拟：如果 $Bx^\\star = b$，那么 $\\mathbf{1}^\\top x^\\star = \\mathbf{1}^\\top b$。\n\n**2. 迭代求解器与预处理**\n\n对于大型系统，直接求解器成本过高，因此需要使用迭代方法，如预处理的 Richardson 迭代：$x^{(k+1)} = x^{(k)} + P^{-1}(b - B x^{(k)})$。预条件子 $P$ 是 $B$ 的一个近似，其逆矩阵的计算成本要低得多。\n\n$P$ 的选择不仅影响收敛速度，还影响中间解 $x^{(k)}$ 的性质。全局质量误差 $E^{(k)}(P) = |\\mathbf{1}^\\top x^{(k)} - \\mathbf{1}^\\top b|$ 衡量了每个迭代解在多大程度上遵守了全局守恒律。\n\n对迭代方程求和，我们得到 $\\mathbf{1}^\\top x^{(k+1)} = \\mathbf{1}^\\top x^{(k)} + (\\mathbf{1}^\\top P^{-1})(b - Bx^{(k)})$。为了在迭代层面保持质量守恒（即 $\\mathbf{1}^\\top x^{(k+1)} = \\mathbf{1}^\\top b$），我们需要一个特定的关系成立。\n\n**3. ILU($0$) 与 MILU($0$) 的对比**\n\n这就是两种预条件子之间区别的关键所在。\n\n-   **ILU($0$) (标准非完全 LU)：** 这种分解执行高斯消元，但将填充限制在矩阵 $B$ 的原始稀疏模式内。当一个更新 $a_{ij} \\leftarrow a_{ij} - a_{ik}a_{kk}^{-1}a_{kj}$ 将创建一个新的非零项（填充项）时，该更新被直接丢弃。这个过程通常不保持原始矩阵 $B$ 的列和性质。因此，$\\mathbf{1}^\\top P_{\\text{ILU}} \\neq \\mathbf{1}^\\top B$，这导致 $\\mathbf{1}^\\top P_{\\text{ILU}}^{-1} \\neq \\mathbf{1}^\\top$。结果，项 $(\\mathbf{1}^\\top P_{\\text{ILU}}^{-1})(b - Bx^{(k)})$ 在每次迭代中都会引入质量误差。\n\n-   **MILU($0$) (修正的非完全 LU)：** 这种方法专门设计用来纠正质量守恒问题。当一个填充项将被丢弃时，它的值会被加到其所在行的对角线元素上。在我们的分解算法中，对于一个将被丢弃的对 $a_{ij}$ 的更新，其值为 $v = a_{ik}a_{kk}^{-1}a_{kj}$，我们修改对角线元素 $a_{ii} \\leftarrow a_{ii} + v$。这个过程强制使分解后矩阵的行和与原始矩阵保持一致。由于我们问题的对称结构（常系数），这也保持了列和。因此，$P_{\\text{MILU}}$ 被构造成与 $B$ 具有相同的列和，即 $\\mathbf{1}^\\top P_{\\text{MILU}} = \\mathbf{1}^\\top B = \\mathbf{1}^\\top$。这意味着 $\\mathbf{1}$ 是 $P_{\\text{MILU}}^\\top$ 的一个特征向量，特征值为 1。因此，$\\mathbf{1}$ 也是 $(P_{\\text{MILU}}^\\top)^{-1} = (P_{\\text{MILU}}^{-1})^\\top$ 的一个特征向量，特征值为 1。这导出了关键的恒等式 $\\mathbf{1}^\\top P_{\\text{MILU}}^{-1} = \\mathbf{1}^\\top$。\n    \n    将此代入 Richardson 迭代的质量平衡方程中，得到：\n    $$ \\mathbf{1}^\\top x^{(k+1)} = \\mathbf{1}^\\top x^{(k)} + \\mathbf{1}^\\top(b - Bx^{(k)}) = \\mathbf{1}^\\top x^{(k)} + \\mathbf{1}^\\top b - (\\mathbf{1}^\\top B)x^{(k)} = \\mathbf{1}^\\top x^{(k)} + \\mathbf{1}^\\top b - \\mathbf{1}^\\top x^{(k)} = \\mathbf{1}^\\top b $$\n    因此，对于 MILU($0$)，对所有 $k \\ge 1$，迭代解 $x^{(k)}$ 的总质量等于 $b$ 的总质量（在机器精度范围内），这展示了在迭代层面的完美守恒性。\n\n**4. 实现策略**\n\n对于每个测试用例，实现将包括四个主要部分：\n1.  **系统组装：** 一个函数将以 `scipy.sparse.lil_matrix` 格式构建稀疏矩阵 $B = I + \\Delta t L$，这种格式对于逐元素组装（尤其是在有周期性边界条件时）非常高效。该函数还生成右侧向量 $b$。\n2.  **分解：** 一个自定义函数将实现 ILU($0$)/MILU($0$) 的分解逻辑。它将接收一个 `lil_matrix` 格式的矩阵和一个指示是标准 ILU 还是修正 ILU 的标志，并基于适用于稀疏矩阵的教科书式 `i-k-j` 索引高斯消元算法执行就地分解。\n3.  **迭代求解器：** 一个函数将运行预处理的 Richardson 迭代指定的步数。它将使用 `scipy.sparse.linalg.spsolve_triangular` 来执行应用预条件子逆 $P^{-1}=(LU)^{-1}=U^{-1}L^{-1}$ 所需的前向和后向替换。\n4.  **主循环：** 主 `solve` 函数将协调整个过程，遍历测试用例，调用辅助函数，并完全按照规定格式化结果。\n\n这种结构化方法确保了正确性和清晰性，直接反映了程序旨在阐述的底层数学原理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.sparse as sp\nfrom scipy.sparse.linalg import spsolve_triangular\n\ndef assemble_system(Nx, Ny, ux, uy, kappa, dt, seed):\n    \"\"\"\n    Assembles the system matrix B and the right-hand side vector b for the\n    2D advection-diffusion problem on a periodic grid.\n    \"\"\"\n    n = Nx * Ny\n    dx = 1.0 / Nx\n    dy = 1.0 / Ny\n\n    # Define outflow rates based on upwind scheme for advection\n    w_E = kappa / dx**2 + max(ux, 0) / dx\n    w_W = kappa / dx**2 + max(-ux, 0) / dx\n    w_N = kappa / dy**2 + max(uy, 0) / dy\n    w_S = kappa / dy**2 + max(-uy, 0) / dy\n    diag_val = w_E + w_W + w_N + w_S\n\n    # Assemble the spatial operator matrix L using LIL format for efficiency\n    L = sp.lil_matrix((n, n))\n    for j in range(Ny):\n        for i in range(Nx):\n            k = i + j * Nx\n            \n            # Neighbor indices with periodic boundary conditions\n            k_E = ((i + 1) % Nx) + j * Nx\n            k_W = ((i - 1 + Nx) % Nx) + j * Nx\n            k_N = i + ((j + 1) % Ny) * Nx\n            k_S = i + ((j - 1 + Ny) % Ny) * Nx\n            \n            L[k, k] = diag_val\n            L[k, k_E] = -w_E\n            L[k, k_W] = -w_W\n            L[k, k_N] = -w_N\n            L[k, k_S] = -w_S\n\n    # The system matrix for Backward-Euler is B = I + dt*L\n    B = sp.identity(n, format='csc') + dt * L.tocsc()\n    \n    # Generate the right-hand side vector b\n    np.random.seed(seed)\n    b = np.random.uniform(0, 1, size=n)\n    \n    return B, b\n\ndef perform_factorization(A_lil, is_milu):\n    \"\"\"\n    Performs ILU(0) or MILU(0) factorization on matrix A.\n    The input matrix A_lil must be in LIL format for efficient modification.\n    The factorization is performed in-place.\n    \"\"\"\n    n = A_lil.shape[0]\n    \n    # Generate sparsity pattern from the original matrix.\n    rows, cols = A_lil.nonzero()\n    pattern = set(zip(rows, cols))\n\n    # In-place Gaussian elimination for ILU(0)/MILU(0) (i-k-j variant)\n    for i in range(1, n):\n        row_sum_correction = 0.0\n        \n        # Identify pivot columns k  i that affect row i\n        pivot_cols_k = sorted([k for k in A_lil.rows[i] if k  i])\n        \n        for k in pivot_cols_k:\n            pivot_val = A_lil[k, k]\n            if pivot_val == 0.0:\n                continue\n            \n            # Compute multiplier and store it in the L part of the matrix\n            factor = A_lil[i, k] / pivot_val\n            A_lil[i, k] = factor\n            \n            # Update row i based on row k (for entries j > k)\n            update_cols_j = [j for j in A_lil.rows[k] if j > k]\n            \n            for j in update_cols_j:\n                update_val = factor * A_lil[k, j]\n                \n                if (i, j) in pattern:\n                    # Update entry if it's in the original sparsity pattern\n                    A_lil[i, j] -= update_val\n                elif is_milu:\n                    # For MILU, accumulate dropped fill-in for row sum correction\n                    row_sum_correction += update_val\n\n        # For MILU, add the accumulated correction to the diagonal of row i\n        if is_milu and row_sum_correction != 0.0:\n            A_lil[i, i] += row_sum_correction\n            \n    return A_lil\n\ndef run_richardson_iterations(B, b, P_fact, K):\n    \"\"\"\n    Runs K preconditioned Richardson iterations and computes global mass error.\n    \"\"\"\n    n = B.shape[0]\n    \n    # Extract L and U factors from the in-place factorized matrix P_fact\n    P_csr = P_fact.tocsr()\n    U = sp.triu(P_csr, format='csr')\n    L = sp.tril(P_csr, k=-1, format='csr') + sp.identity(n, format='csr')\n\n    x = np.zeros(n)\n    mass_b = np.sum(b)\n    mass_errors = []\n\n    for _ in range(K):\n        # Calculate residual: r = b - Bx\n        residual = b - B.dot(x)\n        \n        # Solve P * delta_x = r, which implies LU * delta_x = residual\n        # 1. Solve Lz = residual (forward substitution)\n        z = spsolve_triangular(L, residual, lower=True)\n        # 2. Solve U * delta_x = z (backward substitution)\n        delta_x = spsolve_triangular(U, z, lower=False)\n\n        # Update solution: x_{k+1} = x_k + delta_x (omega=1)\n        x += delta_x\n\n        # Calculate and store the global mass error for this iteration\n        mass_x = np.sum(x)\n        error = np.abs(mass_x - mass_b)\n        mass_errors.append(error)\n\n    return mass_errors\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and generate the final output.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, ux, uy, kappa, dt, seed)\n        (10, 10, 1.0, 0.3, 0.02, 0.1, 42),\n        (8, 8, 0.0, 0.0, 0.1, 0.2, 7),\n        (16, 4, 3.0, -1.0, 0.005, 0.05, 123),\n        (12, 6, -2.0, 2.5, 0.01, 0.08, 2024),\n    ]\n\n    all_results = []\n    \n    for params in test_cases:\n        Nx, Ny, ux, uy, kappa, dt, seed = params\n        \n        # 1. Assemble the linear system\n        B, b = assemble_system(Nx, Ny, ux, uy, kappa, dt, seed)\n        \n        # 2. Perform ILU(0) factorization and run iterations\n        P_ilu_lil = B.copy().tolil()\n        P_ilu_fact = perform_factorization(P_ilu_lil, is_milu=False)\n        errors_ilu = run_richardson_iterations(B, b, P_ilu_fact, K=3)\n        \n        # 3. Perform MILU(0) factorization and run iterations\n        P_milu_lil = B.copy().tolil()\n        P_milu_fact = perform_factorization(P_milu_lil, is_milu=True)\n        errors_milu = run_richardson_iterations(B, b, P_milu_fact, K=3)\n        \n        # 4. Interleave results and format for output\n        case_results = []\n        for i in range(3):\n            case_results.append(errors_ilu[i])\n            case_results.append(errors_milu[i])\n        \n        formatted_results = [f\"{x:.6e}\" for x in case_results]\n        all_results.append(f\"[{','.join(formatted_results)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3604408"}, {"introduction": "在地球物理学中，介质属性（如电导率）的巨大差异会导致线性系统矩阵的严重病态，从而挑战 ILU 预条件子的稳定性。本练习将通过一个编程任务，探索雅可比缩放（Jacobi Scaling）作为一种预处理技术，如何能显著改善 ILU(0) 在高对比度问题中的稳定性和鲁棒性。完成此练习将使您掌握一种在实际应用中增强 ILU 性能的强大而简单的方法 (Citations: [@problem_id:3604435])。", "problem": "考虑在单位正方形上，由 $-\\nabla \\cdot \\left( \\sigma \\nabla u \\right) = f$ 形式的非均匀扩散算子的二维离散化所产生的稀疏线性系统，该系统具有齐次狄利克雷边界条件，其中 $\\sigma$ 是一个空间变化的正常数电导率。在计算地球物理学中，此类系统是低频（扩散）状态下计算电磁学的核心。令 $A \\in \\mathbb{R}^{n \\times n}$ 表示由标准的五点有限差分近似（在面上进行调和平均，网格间距 $h = 1$）所产生的稀疏对称正定刚度矩阵。雅可比缩放指对角平衡 $A_s = D^{-1/2} A D^{-1/2}$，其中 $D = \\mathrm{diag}(A)$ 且 $D^{-1/2} = \\mathrm{diag}(A)^{-1/2}$。零级不完全下上三角分解（零填充不完全 LU，ILU(0)）是通过将高斯消去法应用于仅限于 $A$ 的稀疏模式且不进行主元选择而获得的。增长因子定义为比率 $g = \\max_{i,j} \\left( \\max\\{ |L_{ij}|, |U_{ij}| \\} \\right) / \\max_{i,j} |A_{ij}|$，不包括 $L$ 的隐式单位对角线。为进行稳定性诊断，定义一个估计的崩溃计数 $b$，其为所有行中以下事件的总和：如果 $U_{ii} \\le \\epsilon_{\\mathrm{abs}}$ 或 $U_{ii} \\le \\epsilon_{\\mathrm{rel}} A_{ii}$，则存在主元风险；如果 $U_{ii} \\le \\theta \\sum_{ji} |U_{ij}|$（其中求和是对同一行中的严格上三角元素进行的），则存在优势风险；如果该行中任何 $|L_{ij}| \\ge \\lambda$，则存在乘子增长风险。常数固定为 $\\epsilon_{\\mathrm{abs}} = 10^{-14}$，$\\epsilon_{\\mathrm{rel}} = 10^{-8}$，$\\theta = 0.5$ 和 $\\lambda = 5$。\n\n从第一性原理出发，在均匀网格上使用基于节点的电导率进行五点离散化和调和平均，对于每个内部节点 $(i,j)$（其索引映射为 $\\kappa(i,j) = i + j n_x$），分配矩阵项：\n$$\nA_{\\kappa(i,j),\\kappa(i,j)} = \\sum_{(p,q) \\in \\mathcal{N}(i,j)} w_{(i,j)\\leftrightarrow(p,q)}, \\quad\nA_{\\kappa(i,j),\\kappa(p,q)} = - w_{(i,j)\\leftrightarrow(p,q)},\n$$\n其中 $\\mathcal{N}(i,j)$ 列出了网格上的四个最近邻居，而 $w_{(i,j)\\leftrightarrow(p,q)} = \\left( \\frac{2}{\\sigma_{i,j}^{-1} + \\sigma_{p,q}^{-1}} \\right)$ 是跨共享面的调和平均值。狄利克雷边界节点通过设置 $A_{\\kappa(i,j),\\kappa(i,j)} = 1$ 以及该行中所有其他条目等于 $0$ 来强制执行。\n\n从上述核心定义出发，编写一个程序，该程序：\n- 根据指定的离散化和边界条件，为给定的电导率场 $\\sigma$ 组装 $A$。\n- 应用雅可比缩放形成 $A_s = D^{-1/2} A D^{-1/2}$，其中 $D = \\mathrm{diag}(A)$。\n- 实现具有自然排序和零填充的 ILU(0)，其定义为将高斯消去更新限制在 $A$ 的稀疏模式内。对于行 $i$，使用先前计算的主元 $U_{jj}$ 和 $U$ 的行来计算存在于 $A$ 中的 $j  i$ 的 $L_{ij}$，然后使用已计算的 $L_{ik}$ 和 $U_{kj}$（其中 $k  i$）来计算存在于 $A$ 中的 $j \\ge i$ 的 $U_{ij}$。\n- 计算如上定义的增长因子 $g$ 和估计的崩溃计数 $b$。\n\n使用上述方法，通过比较未缩放和缩放的 ILU(0) 对以下电导率场测试套件的影响，来评估雅可比缩放对增长和崩溃的影响，每个测试套件都在大小为 $n_x \\times n_y$ 的均匀网格上定义：\n1. 基准均匀情况（理想情况）：$n_x = 8$，$n_y = 8$，均匀 $\\sigma = 1$。这测试了无对比度、良态的基准情况。\n2. 电阻背景中的中心导电块：$n_x = 16$，$n_y = 16$，背景 $\\sigma = 1$，中心块占据索引 $i \\in [5,10]$，$j \\in [5,10]$，设置为 $\\sigma_{\\mathrm{block}} = 10^6$。这测试了局部高对比度夹杂物。\n3. 棋盘格极端对比度：$n_x = 16$，$n_y = 16$，如果 $(i+j)$ 是偶数，则 $\\sigma_{i,j} = 1$；如果 $(i+j)$ 是奇数，则 $\\sigma_{i,j} = 10^{-6}$。这测试了在网格尺度上普遍存在的高对比度交替。\n4. 穿过电阻介质的导电通道：$n_x = 32$，$n_y = 8$，背景 $\\sigma = 10^{-6}$，在行 $j = \\lfloor n_y/2 \\rfloor$ 处有一条通道，其中所有 $i$ 的 $\\sigma = 1$。这测试了一个细长的导电特征。\n\n对于每个测试用例 $t$，计算：\n- 对 $A$ 进行 ILU(0) 得到的 $b_{\\mathrm{unscaled}}^{(t)}$，\n- 对 $A_s$ 进行 ILU(0) 得到的 $b_{\\mathrm{scaled}}^{(t)}$，\n- 估计崩溃的减少量 $r^{(t)} = b_{\\mathrm{unscaled}}^{(t)} - b_{\\mathrm{scaled}}^{(t)}$。\n\n您的程序应生成单行输出，其中包含列表 $[r^{(1)}, r^{(2)}, r^{(3)}, r^{(4)}]$，格式为方括号内以逗号分隔的列表，每个元素都以整数形式打印。输出不需要物理单位。不涉及角度。不使用百分比。\n\n所有计算都必须以双精度浮点算术进行。代码必须是自包含的，并且不得读取任何输入或写入任何文件。ILU(0) 的实现必须遵循上述描述的模式限制高斯消去法，不得进行超出原始稀疏结构的任何主元选择或填充。", "solution": "该问题是适定且具有科学依据的，它要求通过编程来评估雅可比缩放在改善 ILU(0) 分解稳定性方面的作用。问题中提供了构建矩阵、执行缩放、实现 ILU(0) 以及计算稳定性诊断所需的所有定义。本解决方案将解释实现这些步骤的逻辑。\n\n### 解决方案设计\n\n为了解决这个问题，程序被分解为几个逻辑部分，每个部分对应问题描述中的一个核心任务。\n\n**1. 矩阵组装 (`assemble_matrix`)**\n\n该函数负责根据给定的电导率场 $\\sigma$ 和网格尺寸 $(n_x, n_y)$ 构建稀疏刚度矩阵 $A$。\n- **边界条件**：代码首先遍历所有网格节点。如果一个节点位于边界上（$i=0$, $i=n_x-1$, $j=0$, 或 $j=n_y-1$），则执行齐次狄利克雷边界条件。这通过将该节点对应的矩阵行设置为单位向量（对角线为1，其余为0）来实现。\n- **内部节点**：对于内部节点，代码实现五点有限差分模板。它计算与东、西、南、北四个邻居的连接权重。\n- **调和平均**：每个权重 $w$ 都根据问题描述使用调和平均公式 $w = 2 / (\\sigma_{ij}^{-1} + \\sigma_{pq}^{-1})$ 计算，这对于处理介质属性的剧烈变化是至关重要的。\n- **矩阵填充**：非对角线元素 $A_{k, k_{\\text{neighbor}}}$ 被设置为 $-w$，对角线元素 $A_{k,k}$ 被设置为所有四个权重的总和。这确保了矩阵的对称性和（对于内部节点）行和为零的性质。\n- **稀疏格式**：矩阵最初使用 `LIL` (List of Lists) 格式构建，这对于逐元素构建稀疏矩阵非常高效，最后转换为 `CSR` (Compressed Sparse Row) 格式以进行高效的矩阵运算。\n\n**2. ILU(0) 分解 (`ilu0`)**\n\n该函数对给定的 `CSR` 格式矩阵执行零填充不完全 LU 分解。\n- **就地计算**：分解是在输入矩阵的一个副本上就地执行的，最终这个副本将同时包含 $L$（在严格下三角部分）和 $U$（在上三角部分，包括对角线）的元素。\n- **高斯消元**：代码按行遍历矩阵（从第1行到第 $n-1$ 行，因为第0行不变）。对于每一行 $i$，它遍历所有列索引 $k  i$ 且 $A_{ik}$ 在原始稀疏模式中非零的位置。\n- **零填充约束**：对于每个这样的 $k$，它计算乘子 $L_{ik} = A_{ik} / U_{kk}$，并用它来更新行 $i$ 中所有 $jk$ 的元素：$A_{ij} \\leftarrow A_{ij} - L_{ik} U_{kj}$。关键在于，这个更新只对那些在原始矩阵的稀疏模式中已经存在的 $A_{ij}$ 执行。任何会产生新非零项（填充）的更新都被隐式地忽略了。\n\n**3. 崩溃计数计算 (`compute_breakdown_count`)**\n\n此函数根据问题中定义的三个标准，对分解后的 `LU` 矩阵进行稳定性诊断。\n- **提取 L 和 U**：首先从 `LU` 矩阵中分别提取上三角部分 $U$ 和严格下三角部分 $L$。\n- **逐行检查**：然后它遍历每一行，检查是否存在数值不稳定性的迹象：\n    1.  **主元风险**：检查对角线元素 $U_{ii}$ 是否过小（绝对值小于 $\\epsilon_{\\text{abs}}$ 或相对于原始对角线元素 $A_{ii}$ 小于 $\\epsilon_{\\text{rel}}$）。\n    2.  **优势风险**：检查对角线元素 $U_{ii}$ 是否小于其所在行中其他非对角线元素绝对值总和的一半（由 $\\theta=0.5$ 加权）。\n    3.  **乘子增长风险**：检查该行在 $L$ 因子中的任何乘数（非对角线元素）的绝对值是否超过了阈值 $\\lambda=5$。\n- **累加计数**：每当检测到上述任何一种风险时，总崩溃计数 $b$ 就加一。\n\n**4. 主分析流程 (`run_analysis_for_case` 和 `solve`)**\n\n- **测试用例**：`solve` 函数定义了四个测试用例，每个用例都有不同的网格尺寸和电导率分布函数。\n- **未缩放与缩放**：对于每个案例，`run_analysis_for_case` 函数执行两次分析。\n    - **未缩放**：它直接在组装好的矩阵 $A$ 上执行 `ilu0` 并计算 `b_unscaled`。\n    - **缩放**：它首先计算雅可比缩放矩阵 $A_s = D^{-1/2} A D^{-1/2}$，其中 $D$ 是 $A$ 的对角线。然后在此缩放后的矩阵上执行 `ilu0` 并计算 `b_scaled`。\n- **结果计算**：最后，它计算崩溃计数的减少量 $r = b_{\\text{unscaled}} - b_{\\text{scaled}}$，并将其存储起来。\n- **输出格式化**：`solve` 函数收集所有四个测试用例的减少量，并将它们格式化为单个列表输出，完全符合问题要求。\n\n通过比较 `b_unscaled` 和 `b_scaled`，该程序量化了雅可比缩放在高对比度电导率问题中稳定 ILU(0) 分解的有效性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix, diags, triu, tril\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the assembly, factorization, and analysis\n    for the specified test cases.\n    \"\"\"\n    \n    # Define constants from the problem description\n    EPS_ABS = 1e-14\n    EPS_REL = 1e-8\n    THETA = 0.5\n    LAMBDA = 5.0\n\n    def assemble_matrix(sigma, nx, ny):\n        \"\"\"Assembles the sparse stiffness matrix A for a given conductivity field.\"\"\"\n        n = nx * ny\n        mat = lil_matrix((n, n), dtype=np.float64)\n        \n        for j in range(ny):\n            for i in range(nx):\n                k = i + j * nx\n                \n                # Enforce homogeneous Dirichlet boundary conditions\n                is_boundary = (i == 0) or (i == nx - 1) or (j == 0) or (j == ny - 1)\n                if is_boundary:\n                    mat[k, k] = 1.0\n                    continue\n                \n                # Handle interior nodes using a five-point stencil with harmonic averaging\n                diag_sum = 0.0\n                neighbors = [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]\n                \n                for p, q in neighbors:\n                    k_neighbor = p + q * nx\n                    \n                    sigma_ij = sigma[j, i]\n                    sigma_pq = sigma[q, p]\n                    \n                    # Harmonic mean of conductivity\n                    # Note: sigma is guaranteed to be positive in the test cases\n                    w = 2.0 / (1.0 / sigma_ij + 1.0 / sigma_pq)\n                    \n                    mat[k, k_neighbor] = -w\n                    diag_sum += w\n                \n                mat[k, k] = diag_sum\n                \n        return mat.tocsr()\n\n    def ilu0(A_csr):\n        \"\"\"\n        Performs ILU(0) factorization on a CSR matrix A.\n        The factorization is done on a copy of A, which is converted to LIL for modification.\n        \"\"\"\n        n = A_csr.shape[0]\n        LU = A_csr.tolil()\n\n        for i in range(1, n):\n            # For each structurally non-zero element A(i, k) with k  i\n            for k in sorted([col for col in LU.rows[i] if col  i]):\n                pivot = LU[k, k]\n\n                if abs(pivot)  1e-99: # Avoid division by zero\n                    continue\n                \n                multiplier = LU[i, k] / pivot\n                LU[i, k] = multiplier\n\n                # Update row i based on row k (for entries j > k)\n                for j in [col for col in LU.rows[k] if col > k]:\n                    if j in LU.rows[i]: # ILU(0) condition: update only if element exists\n                        LU[i, j] -= multiplier * LU[k, j]\n        return LU.tocsr()\n\n\n    def compute_breakdown_count(A_orig, LU):\n        \"\"\"Computes the estimated breakdown count b based on stability diagnostics.\"\"\"\n        n = A_orig.shape[0]\n        b = 0\n\n        U = triu(LU, format='csr')\n        L = tril(LU, k=-1, format='csr')\n        diag_A = A_orig.diagonal()\n        diag_U = U.diagonal()\n\n        for i in range(n):\n            U_ii = diag_U[i]\n            A_ii = diag_A[i]\n            is_risky_row = False\n\n            # 1. Pivot risk\n            if U_ii = EPS_ABS or (abs(A_ii) > 1e-99 and U_ii = EPS_REL * A_ii):\n                b += 1\n                is_risky_row = True\n            \n            # 2. Dominance risk\n            if not is_risky_row:\n                u_row_start, u_row_end = U.indptr[i], U.indptr[i+1]\n                u_row_indices = U.indices[u_row_start:u_row_end]\n                u_row_data = U.data[u_row_start:u_row_end]\n                \n                sum_abs_Uij = 0.0\n                for j_idx, j in enumerate(u_row_indices):\n                    if j > i:\n                        sum_abs_Uij += abs(u_row_data[j_idx])\n                \n                if U_ii = THETA * sum_abs_Uij:\n                    b += 1\n                    is_risky_row = True\n                \n            # 3. Multiplier growth risk\n            if not is_risky_row:\n                l_row_start, l_row_end = L.indptr[i], L.indptr[i+1]\n                if l_row_end > l_row_start:\n                    l_row_data = L.data[l_row_start:l_row_end]\n                    if np.max(np.abs(l_row_data)) >= LAMBDA:\n                        b += 1\n        return b\n\n    def run_analysis_for_case(nx, ny, sigma_func):\n        \"\"\"Runs the unscaled and scaled analysis for a single test case.\"\"\"\n        sigma = sigma_func(nx, ny)\n        \n        # Unscaled analysis\n        A_unscaled = assemble_matrix(sigma, nx, ny)\n        LU_unscaled = ilu0(A_unscaled)\n        b_unscaled = compute_breakdown_count(A_unscaled, LU_unscaled)\n        \n        # Scaled analysis\n        diag_A = A_unscaled.diagonal()\n        diag_A[np.abs(diag_A)  1e-99] = 1.0 \n        D_inv_sqrt = diags(1.0 / np.sqrt(diag_A))\n        A_scaled = (D_inv_sqrt @ A_unscaled @ D_inv_sqrt).tocsr()\n        \n        LU_scaled = ilu0(A_scaled)\n        b_scaled = compute_breakdown_count(A_scaled, LU_scaled)\n        \n        return b_unscaled - b_scaled\n\n    # Define the conductivity generation functions for each test case\n    def sigma_1(nx, ny):\n        return np.ones((ny, nx), dtype=np.float64)\n\n    def sigma_2(nx, ny):\n        sigma = np.ones((ny, nx), dtype=np.float64)\n        sigma[5:11, 5:11] = 1e6\n        return sigma\n\n    def sigma_3(nx, ny):\n        sigma = np.ones((ny, nx), dtype=np.float64)\n        rows, cols = np.indices((ny, nx))\n        sigma[(rows + cols) % 2 != 0] = 1e-6\n        return sigma\n\n    def sigma_4(nx, ny):\n        sigma = np.full((ny, nx), 1e-6, dtype=np.float64)\n        channel_row = ny // 2\n        sigma[channel_row, :] = 1.0\n        return sigma\n\n    test_cases = [\n        (8, 8, sigma_1),\n        (16, 16, sigma_2),\n        (16, 16, sigma_3),\n        (32, 8, sigma_4),\n    ]\n\n    results = []\n    for nx, ny, sigma_func in test_cases:\n        reduction = run_analysis_for_case(nx, ny, sigma_func)\n        results.append(int(reduction))\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3604435"}]}