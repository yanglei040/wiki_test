{"hands_on_practices": [{"introduction": "我们从有限元方法中的一个基本问题开始：如何确保数值积分的精确计算。本练习 [@problem_id:3577235] 专注于为一个简单的双线性单元确定计算其质量矩阵所需的最小求积阶数，为理解基函数与数值积分之间的相互作用奠定坚实的基础。", "problem": "在计算地球物理学的有限元分析中，考虑一个在参考正方形 $[-1,1] \\times [-1,1]$ 上定义的、具有双线性 ($Q_1$) 基函数的四边形等参单元。单个单元上的一致质量矩阵项由下式给出\n$$\nM_{ij} = \\int_{\\Omega_e} \\rho \\, N_i(\\boldsymbol{x}) \\, N_j(\\boldsymbol{x}) \\, \\mathrm{d}\\Omega,\n$$\n其中 $\\rho$ 是单元密度，$\\Omega_e$ 是物理单元，而 $N_i$ 是 $Q_1$ 形函数。该单元使用从参考坐标 $(\\xi,\\eta) \\in [-1,1]^2$ 到物理坐标 $\\boldsymbol{x}(\\xi,\\eta)$ 的等参映射，使得雅可比行列式 $|J|$ 在单元上为常数（即等参映射是仿射的）。假设 $\\rho$ 在单元内是常数。\n\n单元积分使用在 $[-1,1]^2$ 上每个参数方向上为 $n$ 阶的张量积高斯-勒让德 (GL) 求积法进行计算。在给定假设下，对于 $Q_1$ 单元的所有节点对 $(i,j)$，要精确积分一致质量矩阵项 $M_{ij}$，求每个方向上所需的最小阶数 $n$。请以单个整数形式提供您的答案。无需四舍五入，也无需单位。", "solution": "问题要求确定，对于使用双线性 ($Q_1$) 基函数的四边形等参单元，为精确积分一致质量矩阵项 $M_{ij}$ 所需的张量积高斯-勒让德 (GL) 求积的最小阶数 $n$。\n\n一致质量矩阵项的表达式如下：\n$$\nM_{ij} = \\int_{\\Omega_e} \\rho \\, N_i(\\boldsymbol{x}) \\, N_j(\\boldsymbol{x}) \\, \\mathrm{d}\\Omega\n$$\n其中 $\\rho$ 是密度，$\\Omega_e$ 是物理单元域，而 $N_i(\\boldsymbol{x})$ 是物理坐标中的形函数。\n\n问题指出使用了等参映射。这意味着用于插值场变量的基函数也同样用于将几何形状从参考单元映射到物理单元。积分从物理域 $\\Omega_e$ 变换到参考域，即 $(\\xi, \\eta)$ 坐标系下的正方形 $[-1,1] \\times [-1,1]$。变换涉及映射 $\\boldsymbol{x}(\\xi, \\eta)$ 的雅可比矩阵行列式 $|J|$：\n$$\n\\mathrm{d}\\Omega = |J| \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta\n$$\n对于等参单元，形函数自然地在参考坐标中定义，因此有 $N_i(\\boldsymbol{x}) = N_i(\\xi, \\eta)$。将这些代入质量矩阵公式，得到：\n$$\nM_{ij} = \\int_{-1}^{1} \\int_{-1}^{1} \\rho \\, N_i(\\xi, \\eta) \\, N_j(\\xi, \\eta) \\, |J| \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta\n$$\n问题指出了两个关键的简化条件：\n1. 单元内的密度 $\\rho$ 是常数。\n2. 单元上的雅可比行列式 $|J|$ 是常数。这意味着几何映射是仿射的，对于矩形或平行四边形形状的物理单元即是如此。\n\n由于 $\\rho$ 和 $|J|$ 是常数，它们可以从积分中提出：\n$$\nM_{ij} = \\rho |J| \\int_{-1}^{1} \\int_{-1}^{1} N_i(\\xi, \\eta) \\, N_j(\\xi, \\eta) \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta\n$$\n为了确定所需的求积阶数，我们必须分析被积函数 $I(\\xi, \\eta) = N_i(\\xi, \\eta) N_j(\\xi, \\eta)$ 的多项式次数。\n\n4 节点双线性四边形单元 ($Q_1$) 的基函数由下式给出：\n$$\nN_k(\\xi, \\eta) = \\frac{1}{4}(1 + \\xi_k \\xi)(1 + \\eta_k \\eta) \\quad \\text{for } k=1,2,3,4\n$$\n其中 $(\\xi_k, \\eta_k)$ 是参考正方形中节点的坐标：$(-1,-1)$、$(1,-1)$、$(1,1)$ 和 $(-1,1)$。每个基函数 $N_k$ 是关于 $\\xi$ 的 1 次多项式和关于 $\\eta$ 的 1 次多项式。其一般形式为 $N_k(\\xi, \\eta) = a_0 + a_1\\xi + a_2\\eta + a_3\\xi\\eta$。\n\n被积函数是两个此类函数 $N_i(\\xi, \\eta)$ 和 $N_j(\\xi, \\eta)$ 的乘积。两个关于 $\\xi$ 的线性多项式的乘积是一个关于 $\\xi$ 的二次多项式。同样，两个关于 $\\eta$ 的线性多项式的乘积是一个关于 $\\eta$ 的二次多项式。\n我们来验证一个泛型乘积：\n$$\nN_i(\\xi, \\eta) N_j(\\xi, \\eta) = \\left[\\frac{1}{4}(1 + \\xi_i \\xi)(1 + \\eta_i \\eta)\\right] \\left[\\frac{1}{4}(1 + \\xi_j \\xi)(1 + \\eta_j \\eta)\\right]\n$$\n$$\n= \\frac{1}{16} [(1 + \\xi_i \\xi)(1 + \\xi_j \\xi)] [(1 + \\eta_i \\eta)(1 + \\eta_j \\eta)]\n$$\n涉及 $\\xi$ 的项是 $(1 + \\xi_i \\xi)(1 + \\xi_j \\xi) = 1 + (\\xi_i + \\xi_j)\\xi + (\\xi_i \\xi_j)\\xi^2$。由于 $\\xi_k = \\pm 1$，系数 $\\xi_i \\xi_j$ 要么是 $1$ 要么是 $-1$。因此，被积函数中 $\\xi$ 的最高次幂是 $\\xi^2$。\n涉及 $\\eta$ 的项是 $(1 + \\eta_i \\eta)(1 + \\eta_j \\eta) = 1 + (\\eta_i + \\eta_j)\\eta + (\\eta_i \\eta_j)\\eta^2$。同样，被积函数中 $\\eta$ 的最高次幂是 $\\eta^2$。\n\n因此，对于任意节点对 $(i,j)$，被积函数 $N_i(\\xi, \\eta) N_j(\\xi, \\eta)$ 是一个关于 $\\xi$ 最高次数为 2、关于 $\\eta$ 最高次数为 2 的多项式。\n\n问题指出，在每个方向上使用 $n$ 阶张量积高斯-勒让德求积法。这意味着对关于 $\\xi$ 的积分应用 $n$ 点 GL 法则，对关于 $\\eta$ 的积分也应用 $n$ 点 GL 法则。\n具有 $n$ 个点（$n$ 阶）的一维高斯-勒让德求积法可以精确积分最高为 $2n-1$ 次的任意多项式。\n\n为使二重积分精确，求积法则必须在每个维度上独立地精确。\n为了精确地积分 $\\xi$ 方向上的多项式（其最高次数为 $p_\\xi = 2$），阶数 $n$ 必须满足：\n$$\n2n - 1 \\ge p_\\xi\n$$\n$$\n2n - 1 \\ge 2\n$$\n$$\n2n \\ge 3\n$$\n$$\nn \\ge 1.5\n$$\n由于 $n$ 必须是表示求积点数的整数，因此 $n$ 的最小整数值为 2。\n\n同样的逻辑也适用于 $\\eta$ 方向，因为最高多项式次数 $p_\\eta$ 也是 2。这也得出 $n \\ge 1.5$，因此最小整数 $n$ 是 2。\n因此，每个方向上所需的最小阶数为 $n=2$。这对应于参考单元上的 $2 \\times 2$ 高斯求积法则，在给定 $\\rho$ 为常数和 $|J|$ 为常数的假设下，该法则将精确地积分质量矩阵。", "answer": "$$\\boxed{2}$$", "id": "3577235"}, {"introduction": "在掌握了基本积分方法之后，我们进一步探讨基函数本身的性质及其在真实世界中的影响。本练习 [@problem_id:3577185] 将引导你分析一个8节点“serendipity”单元，揭示其多项式空间中的一个关键缺陷，并将这一抽象的数学细节与地球物理模型中常见的剪切自锁这一实际问题联系起来。", "problem": "考虑参数平面中的参考四边形单元，其坐标为 $(\\xi,\\eta) \\in [-1,1] \\times [-1,1]$。设等参映射由用于场变量插值的相同形函数定义，且插值为节点插值，共有 $8$ 个节点：四个角点位于 $(\\xi,\\eta) = (\\pm 1,\\pm 1)$，四个边中点位于 $(\\xi,\\eta) = (0,\\pm 1)$ 和 $(\\xi,\\eta) = (\\pm 1,0)$。8 节点 serendipity 四边形单元采用 Lagrange 型基函数 $\\{N_i(\\xi,\\eta)\\}_{i=1}^{8}$，这些基函数在节点上满足 Kronecker-delta 性质，并且沿每条边都是二次的。\n\n从等参插值和节点 Lagrange 完备性的定义出发，通过强制施加节点插值条件和多项式边上完备性，构造 8 节点 serendipity 基函数 $\\{N_i(\\xi,\\eta)\\}_{i=1}^{8}$。使用以下要求：当限制在任何单元边上时，插值空间能重现边参数中所有次数最高为 $2$ 的一元多项式。然后，通过分析所得基的多项式重现特性以及双二次空间 $Q_2 = \\operatorname{span}\\{\\xi^i \\eta^j : 0 \\le i \\le 2,\\ 0 \\le j \\le 2\\}$ 的结构，确定 $Q_2$ 空间中唯一一个不包含在 8 节点 serendipity 基函数张成空间内的单项式。最后，讨论这一缺失对于计算地球物理学中以弯曲为主的问题的影响，在这些问题中，板或壳状行为导致的精度要求由曲率场和相关的能量范数决定。\n\n你的最终答案必须是写成 $(\\xi,\\eta)$ 的闭式解析表达式的单个缺失单项式。不需要进行数值取整。", "solution": "首先验证问题的科学合理性、适定性和客观性。\n\n### 步骤 1：提取已知条件\n- **区域**：参数平面中的参考四边形单元，坐标为 $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$。\n- **单元**：一个 8 节点 serendipity 四边形单元。\n- **节点**：8 个节点，位于四个角点 $(\\pm 1, \\pm 1)$ 和四个边中点 $(0, \\pm 1)$ 及 $(\\pm 1, 0)$。\n- **基函数**：一组 Lagrange 型基函数 $\\{N_i(\\xi, \\eta)\\}_{i=1}^{8}$，满足 Kronecker-delta 性质 $N_i(\\xi_j, \\eta_j) = \\delta_{ij}$，其中 $(\\xi_j, \\eta_j)$ 是第 $j$ 个节点的坐标。\n- **插值特性**：基函数沿每条边都是二次的，这意味着它们在边上的限制张成了一元二次多项式空间。\n- **任务**：\n    1. 构造基函数 $\\{N_i(\\xi, \\eta)\\}_{i=1}^{8}$。\n    2. 分析基的多项式重现特性。\n    3. 确定双二次空间 $Q_2 = \\operatorname{span}\\{\\xi^i \\eta^j : 0 \\le i \\le 2, 0 \\le j \\le 2\\}$ 中不包含在 $\\{N_i\\}$ 张成空间内的唯一单项式。\n    4. 讨论这一缺失对计算地球物理学中以弯曲为主的问题的影响。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题陈述是有限元法（FEM）理论中的一个标准练习。所有概念——等参映射、参考单元、serendipity 基函数、多项式完备性以及双二次多项式空间 $Q_2$——都定义明确，是计算力学及其在计算地球物理学等领域应用的基础。该问题是自洽的，为构造和分析提供了所有必要信息。不存在科学上的不准确、矛盾或含糊之处。与计算地球物理学的关联是恰当的，因为板壳弯曲分析是该领域的常见应用。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。将提供完整的解答。\n\n### 解答构造\n\n根据问题要求，解答分三个阶段进行：(1) 构造基函数，(2) 分析它们张成的多项式空间以找到缺失的单项式，以及 (3) 讨论其影响。\n\n**1. 构造 8 节点 Serendipity 基函数**\n\n基函数 $\\{N_i(\\xi, \\eta)\\}_{i=1}^{8}$ 必须满足 Lagrange 性质 $N_i(\\xi_j, \\eta_j) = \\delta_{ij}$。Serendipity 单元的标准构造方法是结合线性和二次多项式的乘积来实现这一性质。我们将节点分为角节点和边中点节点。\n\n设节点编号如下：\n- 角节点：$1: (-1, -1)$, $2: (1, -1)$, $3: (1, 1)$, $4: (-1, 1)$。\n- 边中点节点：$5: (0, -1)$, $6: (1, 0)$, $7: (0, 1)$, $8: (-1, 0)$。\n\n**对于位于 $(\\xi_i, \\eta_i)$ 且 $\\xi_i, \\eta_i \\in \\{-1, 1\\}$ 的角节点 $i$：**\n基函数由三项的乘积构造而成。前两项 $\\frac{1}{4}(1 + \\xi_i\\xi)(1 + \\eta_i\\eta)$ 构成了 4 节点四边形的双线性基函数。该项在节点 $i$ 处为 $1$，在所有其他角节点处为 $0$。添加一个线性修正项以使函数在相邻的边中点节点处为零。其一般形式为：\n$$N_i(\\xi, \\eta) = \\frac{1}{4}(1 + \\xi_i\\xi)(1 + \\eta_i\\eta)(\\xi_i\\xi + \\eta_i\\eta - 1)$$\n例如，对于节点 $1$，位于 $(\\xi_1, \\eta_1) = (-1, -1)$：\n$$N_1(\\xi, \\eta) = \\frac{1}{4}(1 - \\xi)(1 - \\eta)(-\\xi - \\eta - 1)$$\n\n**对于位于 $(\\xi_i, \\eta_i)$ 的边中点节点 $i$：**\n这些函数通过在一个方向上使用二次项和在另一个方向上使用线性项来构造。\n- 如果节点位于水平边上，则 $\\eta_i = \\pm 1$ 且 $\\xi_i = 0$。函数必须在对边（$\\eta = -\\eta_i$ 处）以及同一边上的其他节点处为零。这可以通过以下形式实现：\n$$N_i(\\xi, \\eta) = \\frac{1}{2}(1 - \\xi^2)(1 + \\eta_i\\eta)$$\n例如，对于节点 $5$，位于 $(\\xi_5, \\eta_5) = (0, -1)$：\n$$N_5(\\xi, \\eta) = \\frac{1}{2}(1 - \\xi^2)(1 - \\eta)$$\n- 如果节点位于垂直边上，则 $\\xi_i = \\pm 1$ 且 $\\eta_i = 0$。类似地，其形式为：\n$$N_i(\\xi, \\eta) = \\frac{1}{2}(1 - \\eta^2)(1 + \\xi_i\\xi)$$\n例如，对于节点 $6$，位于 $(\\xi_6, \\eta_6) = (1, 0)$：\n$$N_6(\\xi, \\eta) = \\frac{1}{2}(1 - \\eta^2)(1 + \\xi)$$\n\n这些函数在所有 8 个节点上都满足 Kronecker-delta 性质，并且沿每条边都是二次的，从而满足了题目的要求。例如，在边 $\\eta = -1$ 上，非零基函数为 $N_1(\\xi, -1) = \\frac{1}{2}\\xi(\\xi-1)$、$N_2(\\xi, -1) = \\frac{1}{2}\\xi(1+\\xi)$ 和 $N_5(\\xi, -1) = 1-\\xi^2$。这三个函数是针对节点 $\\xi = -1, 1, 0$ 的标准一维二次 Lagrange 基函数，它们张成了关于 $\\xi$ 的二次多项式空间。\n\n**2. 多项式空间分析与缺失单项式的确定**\n\n由基函数张成的空间 $S_2 = \\operatorname{span}\\{N_i(\\xi, \\eta)\\}_{i=1}^{8}$ 是完全双二次空间 $Q_2 = \\operatorname{span}\\{\\xi^i \\eta^j : 0 \\le i, j \\le 2\\}$ 的一个 8 维子空间。空间 $Q_2$ 的维数为 $3 \\times 3 = 9$。我们必须确定 $Q_2$ 的基 $\\{1, \\xi, \\eta, \\xi^2, \\xi\\eta, \\eta^2, \\xi^2\\eta, \\xi\\eta^2, \\xi^2\\eta^2\\}$ 中的哪个单项式不包含在 $S_2$ 中。\n\n我们可以利用插值性质来检验一个给定的多项式函数 $f(\\xi, \\eta)$ 是否属于 $S_2$。如果 $f \\in S_2$，那么它必须能够由其节点插值精确表示：\n$$f(\\xi, \\eta) = \\sum_{i=1}^{8} f(\\xi_i, \\eta_i) N_i(\\xi, \\eta)$$\n我们来测试构成 $Q_2$ 基的各个单项式：\n- $f=1$：$\\sum N_i = 1$ (单位分解性)。这些基函数满足此性质。\n- $f=\\xi$：$\\xi = \\sum \\xi_i N_i = -N_1+N_2+N_3-N_4+N_6-N_8$。所以 $\\xi \\in S_2$。\n- $f=\\eta$：$\\eta = \\sum \\eta_i N_i = -N_1-N_2+N_3+N_4-N_5+N_7$。所以 $\\eta \\in S_2$。\n- $f=\\xi\\eta$：$\\xi\\eta = \\sum \\xi_i\\eta_i N_i = N_1-N_2+N_3-N_4$。所以 $\\xi\\eta \\in S_2$。\n- $f=\\xi^2$：$\\xi^2 = \\sum \\xi_i^2 N_i = N_1+N_2+N_3+N_4+N_6+N_8$。所以 $\\xi^2 \\in S_2$。\n- $f=\\eta^2$：$\\eta^2 = \\sum \\eta_i^2 N_i = N_1+N_2+N_3+N_4+N_5+N_7$。所以 $\\eta^2 \\in S_2$。\n- $f=\\xi^2\\eta$：$\\xi^2\\eta = \\sum \\xi_i^2\\eta_i N_i = -N_1-N_2+N_3+N_4$。所以 $\\xi^2\\eta \\in S_2$。\n- $f=\\xi\\eta^2$：$\\xi\\eta^2 = \\sum \\xi_i\\eta_i^2 N_i = -N_1+N_2+N_3-N_4$。所以 $\\xi\\eta^2 \\in S_2$。\n\nSerendipity 基函数的张成空间包含 8 个单项式 $\\{1, \\xi, \\eta, \\xi^2, \\xi\\eta, \\eta^2, \\xi^2\\eta, \\xi\\eta^2\\}$。\n现在考虑 $Q_2$ 基中的最后一个单项式 $f = \\xi^2\\eta^2$。我们尝试表示它。\n$$f(\\xi_i, \\eta_i) = \\xi_i^2\\eta_i^2$$\n对于所有角节点 $(\\pm 1, \\pm 1)$，$f(\\xi_i, \\eta_i) = (\\pm 1)^2(\\pm 1)^2 = 1$。\n对于所有边中点节点，$\\xi_i$ 或 $\\eta_i$ 中至少有一个为 0，因此 $f(\\xi_i, \\eta_i) = 0$。\n其节点插值将是：\n$$f_{interp}(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta)$$\n我们对四个角节点的基函数求和：\n$N_1+N_2+N_3+N_4 = \\frac{1}{4} \\sum_{i=1}^4 (1 + \\xi_i\\xi)(1 + \\eta_i\\eta)(\\xi_i\\xi + \\eta_i\\eta - 1)$\n一个更直接的方法是检查基函数本身的多项式项。\n对于角节点：$N_i \\propto (1 + \\xi_i\\xi)(1 + \\eta_i\\eta)(\\xi_i\\xi + \\eta_i\\eta - 1)$。最高阶项的形式为 $\\xi^2\\eta$ 和 $\\xi\\eta^2$。\n对于边中点节点：$N_i$ 的形式可以是 $(1-\\xi^2)(1+\\eta_i\\eta)$ 或 $(1-\\eta^2)(1+\\xi_i\\xi)$。最高阶项为 $\\xi^2\\eta$ 和 $\\xi\\eta^2$。\n8 个基函数 $N_i(\\xi, \\eta)$ 都不包含 $\\xi^2\\eta^2$ 项。因此，这些基函数的任何线性组合都不能产生单项式 $\\xi^2\\eta^2$。\n\n$Q_2$ 空间中，不包含在 8 节点 serendipity 基函数张成空间内的唯一单项式是 $\\xi^2\\eta^2$。\n\n**3. 对计算地球物理学中以弯曲为主的问题的影响**\n\n以弯曲为主的问题，例如构造板块（岩石圈）或冰架在载荷作用下的挠曲，通常使用板壳理论进行建模。这些问题的有限元解的精度关键取决于单元表示弯曲能的能力，而弯曲能是位移场曲率（二阶导数）的函数。\n\n单元的多项式完备性决定了其收敛性质。8 节点 serendipity 单元是二次完备的（它包含完整的 $P_2$ 空间），这保证了一定的收敛阶。然而，它对于双二次空间 $Q_2$ 却不是完备的，因为它缺少 $\\xi^2\\eta^2$ 项。这一缺失带来了严重后果。\n\n$\\xi^2\\eta^2$ 模式对应于非均匀的扭转或翘曲变形。其二阶导数为：\n$$\\frac{\\partial^2}{\\partial \\xi^2}(\\xi^2\\eta^2) = 2\\eta^2$$\n$$\\frac{\\partial^2}{\\partial \\eta^2}(\\xi^2\\eta^2) = 2\\xi^2$$\n$$\\frac{\\partial^2}{\\partial \\xi \\partial \\eta}(\\xi^2\\eta^2) = 4\\xi\\eta$$\nSerendipity 单元无法表示该项，意味着它无法模拟涉及二次变化的法向曲率或线性变化的扭转曲率的变形状态，即使在未扭曲的参考单元上也是如此。\n\n在薄板和薄壳分析（例如，使用 Mindlin-Reissner 理论）的背景下，这种缺陷常常导致一种称为**剪切自锁**的数值病态问题。当板变薄时，横向剪切应变必须趋近于零。然而，一个不能精确表示所需弯曲模式（如纯扭转）的单元可能会产生虚假的、非零的剪切应变作为补偿。这会人为地增加单元响应的刚度，导致位移的严重低估和应力预测的不准确。这在地球物理模型中尤其成问题，因为在这些模型中，预测挠曲沉降的量级或岩石圈的应力状态对于理解地质过程至关重要。\n\n例如，恒定扭转状态是一种基本的弯曲模式，它要求位移场包含能产生恒定 $\\frac{\\partial^2 w}{\\partial x \\partial y}$ 的项。Serendipity 单元只有在单元边与坐标轴平行时（此时映射的雅可比矩阵为常数）才能表示恒定的扭转状态。对于一个普遍扭曲的单元，该单元难以表示即便是这种基本模式，从而导致自锁。\n\n相比之下，9 节点 Lagrange 单元的基张成了完整的 $Q_2$ 空间（包括 $\\xi^2\\eta^2$），可以正确表示这种模式，并且在弯曲问题中通常表现得更好，对剪切自锁的敏感性较低。因此，在地球物理学中对弯曲和扭转很重要的板状结构进行高保真分析时，通常首选 9 节点单元，或者必须为 8 节点单元采用专门的“无自锁”列式。这一选择影响了对火山载荷下岩石圈挠曲或冰架对海洋强迫响应等现象预测的可靠性。", "answer": "$$\\boxed{\\xi^2\\eta^2}$$", "id": "3577185"}, {"introduction": "最后的这项练习将理论与计算相结合，旨在解决在复杂扭曲几何体上进行积分的挑战。你将编写一个程序 [@problem_id:3577183]，以数值方式研究几何畸变如何影响高阶谱元积分的精度，并将积分误差与雅可比行列式的变化进行关联。这项练习让你能够亲手实践，学习如何在高级计算模拟中诊断潜在的误差来源。", "problem": "令参考六面体为参数坐标 $(\\xi,\\eta,\\zeta)$ 中的立方体 $[-1,1]^3$。考虑一个等参三二次映射，该映射根据以下公式将此参考立方体扭曲为物理六面体：\n$$\nx(\\xi,\\eta,\\zeta) = \\xi + \\frac{\\alpha}{2}\\,\\xi\\,\\eta,\\quad\ny(\\xi,\\eta,\\zeta) = \\eta + \\frac{\\alpha}{2}\\,\\eta\\,\\zeta,\\quad\nz(\\xi,\\eta,\\zeta) = \\zeta + \\frac{\\alpha}{2}\\,\\xi\\,\\zeta,\n$$\n其中 $\\alpha \\ge 0$ 是一个标量扭曲振幅，控制着偏离仿射映射的程度。此映射的雅可比矩阵为\n$$\nJ(\\xi,\\eta,\\zeta) = \\begin{bmatrix}\n\\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta}  \\frac{\\partial x}{\\partial \\zeta} \\\\\n\\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta}  \\frac{\\partial y}{\\partial \\zeta} \\\\\n\\frac{\\partial z}{\\partial \\xi}  \\frac{\\partial z}{\\partial \\eta}  \\frac{\\partial z}{\\partial \\zeta}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 + \\frac{\\alpha}{2}\\eta  \\frac{\\alpha}{2}\\xi  0 \\\\\n0  1 + \\frac{\\alpha}{2}\\zeta  \\frac{\\alpha}{2}\\eta \\\\\n\\frac{\\alpha}{2}\\zeta  0  1 + \\frac{\\alpha}{2}\\xi\n\\end{bmatrix},\n$$\n其行列式为\n$$\n\\det J(\\xi,\\eta,\\zeta) = \\left(1+\\frac{\\alpha}{2}\\eta\\right)\\left(1+\\frac{\\alpha}{2}\\zeta\\right)\\left(1+\\frac{\\alpha}{2}\\xi\\right) + \\left(\\frac{\\alpha}{2}\\xi\\right)\\left(\\frac{\\alpha}{2}\\eta\\right)\\left(\\frac{\\alpha}{2}\\zeta\\right).\n$$\n令测试被积函数为光滑函数\n$$\ng(x,y,z) = \\exp\\!\\left(0.3\\,x + 0.2\\,y - 0.1\\,z\\right) + \\sin\\!\\left(2.1\\,x\\right)\\,\\cos\\!\\left(1.7\\,y\\right)\\,\\sinh\\!\\left(0.5\\,z\\right).\n$$\n我们感兴趣的物理体积积分由变量替换公式定义：\n$$\nI(\\alpha) = \\iiint_{[-1,1]^3} g\\!\\left(x(\\xi,\\eta,\\zeta),\\,y(\\xi,\\eta,\\zeta),\\,z(\\xi,\\eta,\\zeta)\\right)\\,\\left|\\det J(\\xi,\\eta,\\zeta)\\right|\\,d\\xi\\,d\\eta\\,d\\zeta.\n$$\n您将使用每个坐标有 $N$ 个节点的张量积 Gauss–Lobatto–Legendre (GLL) 求积法来近似 $I(\\alpha)$。在一维中，对于给定的 $N \\ge 3$，GLL 节点 $\\{ \\xi_i \\}_{i=1}^N$ 由端点 $\\xi_1=-1$、$\\xi_N=1$ 以及 Legendre 多项式 $P_{N-1}(\\xi)$ 导数的 $N-2$ 个内部根组成，相应的权重 $\\{ w_i \\}_{i=1}^N$ 由下式给出：\n$$\nw_i = \\frac{2}{N(N-1)\\,[P_{N-1}(\\xi_i)]^2}.\n$$\n三维 GLL 近似是一维规则的张量积：\n$$\nI_{GLL}(N,\\alpha) = \\sum_{i=1}^N \\sum_{j=1}^N \\sum_{k=1}^N w_i\\,w_j\\,w_k \\; g\\!\\left(x(\\xi_i,\\eta_j,\\zeta_k),\\, y(\\xi_i,\\eta_j,\\zeta_k),\\, z(\\xi_i,\\eta_j,\\zeta_k)\\right)\\,\\left|\\det J(\\xi_i,\\eta_j,\\zeta_k)\\right|.\n$$\n为评估精度，使用每个坐标有 $M=30$ 个节点的张量积 Gauss–Legendre (GL) 求积法获得高保真参考值 $I_{\\text{ref}}(\\alpha)$：\n$$\nI_{\\text{ref}}(\\alpha) \\approx \\sum_{p=1}^{M} \\sum_{q=1}^{M} \\sum_{r=1}^{M} \\omega_p\\,\\omega_q\\,\\omega_r \\; g\\!\\left(x(\\hat{\\xi}_p,\\hat{\\eta}_q,\\hat{\\zeta}_r),\\, y(\\hat{\\xi}_p,\\hat{\\eta}_q,\\hat{\\zeta}_r),\\, z(\\hat{\\xi}_p,\\hat{\\eta}_q,\\hat{\\zeta}_r)\\right)\\,\\left|\\det J(\\hat{\\xi}_p,\\hat{\\eta}_q,\\hat{\\zeta}_r)\\right|,\n$$\n其中 $\\{(\\hat{\\xi}_p,\\omega_p)\\}$、$\\{(\\hat{\\eta}_q,\\omega_q)\\}$、$\\{(\\hat{\\zeta}_r,\\omega_r)\\}$ 是一维 GL 节点和在 $[-1,1]$ 上的权重。\n\n定义相对误差\n$$\ne(N,\\alpha) = \\frac{\\left|I_{GLL}(N,\\alpha) - I_{\\text{ref}}(\\alpha)\\right|}{\\left|I_{\\text{ref}}(\\alpha)\\right|}.\n$$\n将在 GLL 求积采样点上的雅可比行列式变化的无量纲度量定义为变异系数\n$$\nV(N,\\alpha) = \\frac{\\operatorname{std}\\left(\\left\\{\\left|\\det J(\\xi_i,\\eta_j,\\zeta_k)\\right|\\right\\}_{i,j,k=1}^N\\right)}{\\operatorname{mean}\\left(\\left\\{\\left|\\det J(\\xi_i,\\eta_j,\\zeta_k)\\right|\\right\\}_{i,j,k=1}^N\\right)}.\n$$\n您的任务是实现一个程序，该程序针对一组 $(N,\\alpha)$ 测试对，计算相对误差列表 $e(N,\\alpha)$ 以及在整个测试集上 $e(N,\\alpha)$ 和 $V(N,\\alpha)$ 之间的 Pearson 相关系数。请使用以下测试集：\n- 情况 1：$N=3$, $\\alpha=0.0$。\n- 情况 2：$N=9$, $\\alpha=0.0$。\n- 情况 3：$N=5$, $\\alpha=0.3$。\n- 情况 4：$N=5$, $\\alpha=0.6$。\n- 情况 5：$N=11$, $\\alpha=0.3$。\n- 情况 6：$N=11$, $\\alpha=0.6$。\n- 情况 7：$N=7$, $\\alpha=0.45$。\n- 情况 8：$N=13$, $\\alpha=0.2$。\n\n算法和约束：\n1. 完全按照上述定义，根据 $P_{N-1}(\\xi)$ 的导数根和权重公式，构造 GLL 一维节点和权重。\n2. 使用标准的 Gauss–Legendre 规则，每个坐标有 $M=30$ 个点，构造 GL 一维节点和权重。\n3. 在参考坐标中，通过张量积求积法计算 $I_{GLL}(N,\\alpha)$ 和 $I_{\\text{ref}}(\\alpha)$，使用映射和 $|\\det J|$ 作为变量替换的权重。\n4. 对每个测试用例，按上述定义计算 $e(N,\\alpha)$ 和 $V(N,\\alpha)$。\n5. 计算所有八个测试用例的向量 $\\{e(N,\\alpha)\\}$ 和 $\\{V(N,\\alpha)\\}$ 之间的 Pearson 相关系数。如果任一向量的标准差为零，则将相关性定义为 $0$。\n\n此问题中没有物理单位；所有量均为无量纲。角度以弧度为单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表：前八个条目是按给定顺序列出的八个情况的浮点相对误差 $e(N,\\alpha)$，最后一个（第九个）条目是浮点相关系数。为确保确定性评估，请以包含十二位有效数字的科学记数法打印所有浮点数（例如，$1.23456789012\\mathrm{e}{-06}$）。例如，输出格式必须为\n$$\n[\\text{e1},\\text{e2},\\text{e3},\\text{e4},\\text{e5},\\text{e6},\\text{e7},\\text{e8},\\text{corr}],\n$$\n其中每个占位符都替换为以十二位有效数字的科学记数法表示的相应计算数值。", "solution": "问题陈述已经过验证，并被确定为数值分析领域中一个适定、有科学依据的问题，特别是在计算科学和其他工程学科中使用的有限元法或谱元法的背景下。该问题是自包含的，指定了所有必要的数学定义、参数和算法。对于给定的 $\\alpha$ 范围，雅可比行列式被确认为正，从而确保等参映射是有效的（即可逆且保持方向）。\n\n解决方案通过逐步实现指定的算法来进行。\n\n1.  **求积法则生成**：\n    *   **Gauss–Lobatto–Legendre (GLL) 求积**：创建一个函数来生成区间 $[-1, 1]$ 上一维 GLL 求积的 $N$ 个节点 $\\{\\xi_i\\}$ 和权重 $\\{w_i\\}$。根据规定，节点由端点 $-1$ 和 $1$ 以及 $N-1$ 次 Legendre 多项式 $P'_{N-1}(\\xi)$ 一阶导数的 $N-2$ 个根组成。`scipy.special.legendre` 函数是一个方便的工具，它返回一个多项式对象，其 `deriv()` 和 `roots` 方法可以直接且稳健地计算这些内部节点。然后使用提供的公式计算相应的权重 $\\{w_i\\}$：$w_i = \\frac{2}{N(N-1)\\,[P_{N-1}(\\xi_i)]^2}$。\n    *   **Gauss–Legendre (GL) 求积**：高保真度参考积分需要标准的 Gauss-Legendre 求积法则。`scipy.special.roots_legendre` 函数用于为此生成 $M=30$ 个节点和权重。\n\n2.  **特定于问题的函数**：\n    *   等参映射函数 $x(\\xi,\\eta,\\zeta)$、$y(\\xi,\\eta,\\zeta)$ 和 $z(\\xi,\\eta,\\zeta)$ 根据其定义直接实现。\n    *   雅可比行列式 $\\det J(\\xi,\\eta,\\zeta)$ 使用提供的封闭式表达式实现。\n    *   测试被积函数 $g(x,y,z)$ 按照定义实现，使用 `numpy` 库中的标准数学函数。\n\n3.  **数值积分**：\n    *   一个核心函数执行三维张量积求积。为避免计算成本高昂的嵌套 Python 循环，此函数使用 `numpy.meshgrid` 进行向量化，以同时为所有 $N^3$（对于 GLL）或 $M^3$（对于 GL）个求积点生成坐标。\n    *   通过在参考域中的每个点上计算被积函数 $g(x,y,z)$ 和雅可比行列式 $|\\det J|$，将结果乘以相应的一维求积权重（$w_i w_j w_k$）的乘积，然后将它们相加来计算积分 $I(\\alpha)$。这个单一函数用于计算 $I_{GLL}(N,\\alpha)$（使用 GLL 节点/权重）和 $I_{\\text{ref}}(\\alpha)$（使用 GL 节点/权重）。\n\n4.  **分析和最终计算**：\n    *   **误差和变异**：对于测试集中的每个 $(N, \\alpha)$ 对，使用其定义 $e = |I_{GLL} - I_{\\text{ref}}| / |I_{\\text{ref}}|$ 计算相对误差 $e(N, \\alpha)$。雅可比变异 $V(N, \\alpha)$，定义为 GLL 求积点上 $|\\det J|$ 的变异系数（标准差除以平均值），也被计算出来。为提高效率，此计算也进行了向量化。\n    *   **相关性**：遍历所有测试用例后，使用 `numpy.corrcoef` 计算收集到的误差列表 $\\{e(N,\\alpha)\\}$ 和变异列表 $\\{V(N,\\alpha)\\}$ 之间的 Pearson 相关系数。根据规定，如果任一列表的标准差为零，则相关系数明确设置为 $0$。\n    *   **输出格式化**：最终结果，包括八个误差值和一个相关系数值，被格式化为一个字符串。每个数字都以包含十二位有效数字的科学记数法（`.11e` 格式说明符）表示，并以单行、逗号分隔的列表形式呈现在方括号内。\n\n这种结构化的方法确保了问题的所有要求都得到精确而高效的满足。为避免对具有相同 $\\alpha$ 的测试用例重复计算成本高昂的参考积分， $I_{\\text{ref}}(\\alpha)$ 的结果被缓存（记忆化）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre, roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes numerical integration errors and their correlation with Jacobian variation\n    for a warped hexahedral element.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3, 0.0),\n        (9, 0.0),\n        (5, 0.3),\n        (5, 0.6),\n        (11, 0.3),\n        (11, 0.6),\n        (7, 0.45),\n        (13, 0.2),\n    ]\n\n    def gll_nodes_weights(N):\n        \"\"\"\n        Computes 1D Gauss-Lobatto-Legendre quadrature nodes and weights.\n        \"\"\"\n        if N  3:\n            raise ValueError(\"N must be >= 3 as per problem statement.\")\n\n        # Interior nodes are roots of the derivative of P_{N-1}(x).\n        p_nm1 = legendre(N - 1)\n        p_nm1_deriv = p_nm1.deriv()\n        interior_nodes = p_nm1_deriv.roots\n        \n        # Combine with endpoints and sort.\n        nodes = np.concatenate(([-1.0], np.sort(interior_nodes), [1.0]))\n        \n        # Calculate weights based on the formula.\n        vals_p_nm1 = p_nm1(nodes)\n        weights = 2.0 / (N * (N - 1) * vals_p_nm1**2)\n        \n        return nodes, weights\n\n    def mapping(xi, eta, zeta, alpha):\n        \"\"\"Isoparametric mapping from reference to physical coordinates.\"\"\"\n        x = xi + (alpha / 2.0) * xi * eta\n        y = eta + (alpha / 2.0) * eta * zeta\n        z = zeta + (alpha / 2.0) * xi * zeta\n        return x, y, z\n\n    def det_J(xi, eta, zeta, alpha):\n        \"\"\"Determinant of the Jacobian matrix of the mapping.\"\"\"\n        a = alpha / 2.0\n        term1 = (1.0 + a * eta) * (1.0 + a * zeta) * (1.0 + a * xi)\n        term2 = (a * xi) * (a * eta) * (a * zeta)\n        return term1 + term2\n\n    def g_func(x, y, z):\n        \"\"\"Test integrand function g(x, y, z).\"\"\"\n        term1 = np.exp(0.3 * x + 0.2 * y - 0.1 * z)\n        term2 = np.sin(2.1 * x) * np.cos(1.7 * y) * np.sinh(0.5 * z)\n        return term1 + term2\n\n    def integrate_3d(nodes, weights, alpha):\n        \"\"\"\n        Performs 3D tensor-product quadrature. Vectorized for efficiency.\n        \"\"\"\n        # Create 3D grids of nodes and weights. 'ij' indexing ensures\n        # the tensor product sum is computed correctly.\n        XI, ETA, ZETA = np.meshgrid(nodes, nodes, nodes, indexing='ij')\n        WX, WY, WZ = np.meshgrid(weights, weights, weights, indexing='ij')\n\n        # Apply mapping to grid points\n        X, Y, Z = mapping(XI, ETA, ZETA, alpha)\n        \n        # Evaluate Jacobian determinant and integrand at all points\n        DETJ_vals = np.abs(det_J(XI, ETA, ZETA, alpha))\n        G_vals = g_func(X, Y, Z)\n        \n        # Compute the integral by summing weighted values\n        integrand_at_points = WX * WY * WZ * G_vals * DETJ_vals\n        integral_val = np.sum(integrand_at_points)\n\n        return integral_val\n\n    def calculate_V(nodes, alpha):\n        \"\"\"\n        Computes the Jacobian variation V(N, alpha).\n        \"\"\"\n        # Create a 3D grid of nodes.\n        XI, ETA, ZETA = np.meshgrid(nodes, nodes, nodes, indexing='ij')\n        \n        # Evaluate |det J| at all grid points\n        DETJ_vals = np.abs(det_J(XI, ETA, ZETA, alpha))\n        \n        mean_detj = np.mean(DETJ_vals)\n        std_detj = np.std(DETJ_vals)\n        \n        if mean_detj == 0:\n            return 0.0\n            \n        return std_detj / mean_detj\n\n    # Main logic\n    M = 30\n    gl_nodes_ref, gl_weights_ref = roots_legendre(M)\n\n    e_values = []\n    v_values = []\n    \n    # Memoization cache for the reference integral to avoid re-computation.\n    ref_integral_cache = {}\n\n    for N, alpha in test_cases:\n        # Calculate reference integral (or retrieve from cache)\n        if alpha not in ref_integral_cache:\n            I_ref = integrate_3d(gl_nodes_ref, gl_weights_ref, alpha)\n            ref_integral_cache[alpha] = I_ref\n        I_ref = ref_integral_cache[alpha]\n\n        # Get GLL nodes and weights for the current case\n        gll_nodes, gll_weights = gll_nodes_weights(N)\n        \n        # Calculate GLL integral\n        I_gll = integrate_3d(gll_nodes, gll_weights, alpha)\n        \n        # Calculate relative error e(N, alpha)\n        if np.abs(I_ref) == 0:\n            # Handle potential division by zero, though unlikely here.\n            error = 0.0 if np.abs(I_gll) == 0 else np.inf\n        else:\n            error = np.abs(I_gll - I_ref) / np.abs(I_ref)\n        e_values.append(error)\n        \n        # Calculate Jacobian variation V(N, alpha)\n        v = calculate_V(gll_nodes, alpha)\n        v_values.append(v)\n        \n    # Compute Pearson correlation coefficient\n    e_vec = np.array(e_values)\n    v_vec = np.array(v_values)\n    \n    corr = 0.0\n    # Per problem, if either std is zero, correlation is 0.\n    if np.std(e_vec) > 1e-15 and np.std(v_vec) > 1e-15:\n        corr_matrix = np.corrcoef(e_vec, v_vec)\n        corr = corr_matrix[0, 1]\n\n    # Combine results and format for output\n    final_results = e_values + [corr]\n    # Format to scientific notation with 12 significant digits (1 before, 11 after decimal)\n    formatted_results = [f\"{x:.11e}\" for x in final_results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3577183"}]}