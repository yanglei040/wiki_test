{"hands_on_practices": [{"introduction": "有限元方法的核心思想是将一个复杂的问题分解为称为“单元”的更简单的部分。此过程的核心是推导“单元刚度矩阵”，它代表了单个单元上的物理行为（如热传导）。这项基础练习旨在构建任何有限元模拟的核心组件，让您理解控制微分方程是如何转化为离散代数形式的。[@problem_id:3595232]", "problem": "考虑沿水平坐标 $x$ 的层状地质构造中的一维稳态导热问题，该过程受能量守恒和傅里叶定律控制。在没有内部储热的稳态条件下，能量守恒意味着传导热通量的散度与体积热源相平衡。将温度记为 $u(x)$，导热系数记为 $a(x)$，在区间 $\\Omega=[0,L]$ 上的强形式为\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right)=f(x),\n$$\n在 $x=0$ 和 $x=L$ 处有合适的边界条件。在有限元法 (FEM) 中，区域 $\\Omega$ 被划分为一个网格，其节点为 $x_0", "solution": "该问题提法恰当，具有科学依据，并包含了获得唯一解所需的所有信息。这是有限元法 (FEM) 中关于二阶边值问题的标准练习。我将开始推导和计算。\n\n问题要求推导一维线性有限元的单元刚度矩阵 $k_e$。出发点是控制微分方程的弱形式，\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right)=f(x) \\quad \\text{for } x \\in [x_i, x_{i+1}]\n$$\n为了得到弱形式，我们乘以一个检验函数 $w(x)$ 并在单元域 $[x_i, x_{i+1}]$ 上积分：\n$$\n-\\int_{x_i}^{x_{i+1}} w(x) \\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) dx = \\int_{x_i}^{x_{i+1}} w(x) f(x) dx\n$$\n对左侧应用分部积分，将一个导数从试探解 $u(x)$ 转移到检验函数 $w(x)$：\n$$\n\\int_{x_i}^{x_{i+1}} a(x)\\frac{du}{dx}\\frac{dw}{dx} dx - \\left[ w(x) a(x) \\frac{du}{dx} \\right]_{x_i}^{x_{i+1}} = \\int_{x_i}^{x_{i+1}} w(x) f(x) dx\n$$\n重新整理得到局部弱形式：\n$$\n\\int_{x_i}^{x_{i+1}} a(x)\\frac{du}{dx}\\frac{dw}{dx} dx = \\int_{x_i}^{x_{i+1}} w(x) f(x) dx + \\left[ w(x) a(x) \\frac{du}{dx} \\right]_{x_i}^{x_{i+1}}\n$$\n左边的项是双线性形式，它产生了刚度矩阵。右边包含载荷向量和边界通量项。\n\n在伽辽金有限元法中，试探解 $u(x)$ 由一个函数 $u_h(x)$ 近似，该函数来自一个由基函数张成的有限维空间，在该单元上，这些基函数是线性形函数 $N_1(x)$ 和 $N_2(x)$。该近似被写成节点值 $U_1$ 和 $U_2$（对应于节点 $x_i$ 和 $x_{i+1}$）的线性组合：\n$$\nu_h(x) = U_1 N_1(x) + U_2 N_2(x) = \\sum_{n=1}^{2} U_n N_n(x)\n$$\n检验函数 $w(x)$ 选自同一空间，因此我们设 $w(x) = N_m(x)$，其中 $m \\in \\{1, 2\\}$。在单元上，导热系数被假定为常数，$a(x) = a_e$。将这些代入双线性形式，得到：\n$$\n\\int_{x_i}^{x_{i+1}} a_e \\frac{d}{dx}\\left( \\sum_{n=1}^{2} U_n N_n(x) \\right) \\frac{d N_m(x)}{dx} dx = \\sum_{n=1}^{2} \\left( \\int_{x_i}^{x_{i+1}} a_e \\frac{dN_m}{dx}(x) \\frac{dN_n}{dx}(x) dx \\right) U_n\n$$\n这个表达式代表了系统 $k_e U_e$ 的第 $m$ 行，其中 $U_e$ 是节点未知数的向量。因此，单元刚度矩阵 $k_e$ 的各项由问题陈述中提供的积分给出：\n$$\n(k_e)_{mn} = \\int_{x_i}^{x_{i+1}} a_e \\frac{dN_m}{dx}(x) \\frac{dN_n}{dx}(x) dx\n$$\n我们现在计算这些项。\n\n首先，我们为长度为 $h_e = x_{i+1}-x_i$ 的区间 $[x_i, x_{i+1}]$ 上的单元定义线性形函数 $N_1(x)$ 和 $N_2(x)$。\n形函数 $N_1(x)$ 由条件 $N_1(x_i)=1$ 和 $N_1(x_{i+1})=0$ 定义。满足这些条件的唯一线性多项式是：\n$$\nN_1(x) = \\frac{x_{i+1} - x}{x_{i+1} - x_i} = \\frac{x_{i+1} - x}{h_e}\n$$\n形函数 $N_2(x)$ 由 $N_2(x_i)=0$ 和 $N_2(x_{i+1})=1$ 定义。这给出：\n$$\nN_2(x) = \\frac{x - x_i}{x_{i+1} - x_i} = \\frac{x - x_i}{h_e}\n$$\n\n接下来，我们计算形函数关于 $x$ 的导数：\n$$\n\\frac{dN_1}{dx} = \\frac{d}{dx} \\left( \\frac{x_{i+1} - x}{h_e} \\right) = -\\frac{1}{h_e}\n$$\n$$\n\\frac{dN_2}{dx} = \\frac{d}{dx} \\left( \\frac{x - x_i}{h_e} \\right) = \\frac{1}{h_e}\n$$\n这些导数在单元上是常数。\n\n现在我们可以计算 $2 \\times 2$ 刚度矩阵 $k_e$ 的四个项。\n\n情况 1：$m=1, n=1$\n$$\n(k_e)_{11} = \\int_{x_i}^{x_{i+1}} a_e \\left(-\\frac{1}{h_e}\\right) \\left(-\\frac{1}{h_e}\\right) dx = \\int_{x_i}^{x_{i+1}} \\frac{a_e}{h_e^2} dx = \\frac{a_e}{h_e^2} [x]_{x_i}^{x_{i+1}} = \\frac{a_e}{h_e^2} (x_{i+1} - x_i) = \\frac{a_e}{h_e^2} h_e = \\frac{a_e}{h_e}\n$$\n\n情况 2：$m=1, n=2$\n$$\n(k_e)_{12} = \\int_{x_i}^{x_{i+1}} a_e \\left(-\\frac{1}{h_e}\\right) \\left(\\frac{1}{h_e}\\right) dx = \\int_{x_i}^{x_{i+1}} -\\frac{a_e}{h_e^2} dx = -\\frac{a_e}{h_e^2} [x]_{x_i}^{x_{i+1}} = -\\frac{a_e}{h_e^2} h_e = -\\frac{a_e}{h_e}\n$$\n\n情况 3：$m=2, n=1$\n由于被积函数的对称性，$(k_e)_{21} = (k_e)_{12}$。\n$$\n(k_e)_{21} = \\int_{x_i}^{x_{i+1}} a_e \\left(\\frac{1}{h_e}\\right) \\left(-\\frac{1}{h_e}\\right) dx = -\\frac{a_e}{h_e}\n$$\n\n情况 4：$m=2, n=2$\n$$\n(k_e)_{22} = \\int_{x_i}^{x_{i+1}} a_e \\left(\\frac{1}{h_e}\\right) \\left(\\frac{1}{h_e}\\right) dx = \\int_{x_i}^{x_{i+1}} \\frac{a_e}{h_e^2} dx = \\frac{a_e}{h_e^2} [x]_{x_i}^{x_{i+1}} = \\frac{a_e}{h_e^2} h_e = \\frac{a_e}{h_e}\n$$\n\n将这些项组装成矩阵 $k_e$：\n$$\nk_e = \\begin{pmatrix} (k_e)_{11}  (k_e)_{12} \\\\ (k_e)_{21}  (k_e)_{22} \\end{pmatrix} = \\begin{pmatrix} \\frac{a_e}{h_e}  -\\frac{a_e}{h_e} \\\\ -\\frac{a_e}{h_e}  \\frac{a_e}{h_e} \\end{pmatrix}\n$$\n提取公因式 $\\frac{a_e}{h_e}$ 得到单元刚度矩阵的最终闭式表达式。\n$$\nk_e = \\frac{a_e}{h_e} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$", "answer": "$$\n\\boxed{\\frac{a_e}{h_e} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}}\n$$", "id": "3595232"}, {"introduction": "在处理完微分算子（刚度矩阵）后，我们必须考虑外部影响，例如由“载荷向量”表示的热源。本练习演示了如何计算载荷向量的分量，以及至关重要的是，如何通过将在共享节点上的单元贡献相加来“组装”全局向量。掌握此组装过程是构建有限元求解器最终要处理的完整线性方程组的关键。[@problem_id:3595233]", "problem": "在计算地球物理学的背景下，考虑一个水平分层岩石圈中的稳态一维 ($1$D) 热传导问题，该问题由区间 $[0,L]$ 上的偏微分方程 (PDE) $-k\\,u''(x)=f(x)$ 控制，其中 $k>0$ 是一个常数热导率，$u(x)$ 是温度，$f(x)$ 是一个体积热源项。给定常数 $T_0$ 和 $T_L$，施加狄利克雷边界条件 $u(0)=T_0$ 和 $u(L)=T_L$。将区间 $[0,L]$ 通过一个严格递增的网格 $0=x_0", "solution": "该问题陈述经过严格验证，确认有效。它具有科学依据，是适定的、客观的、自洽的，代表了有限元法应用中的一个标准问题。\n\n任务是推导与内部节点 $x_j$（其中 $j \\in \\{1, \\dots, n-1\\}$）相关联的全局载荷向量分量 $F_j$ 的闭式表达式。该载荷向量分量由以下积分定义：\n$$\nF_j = \\int_0^L f(x) \\, \\phi_j(x) \\, \\mathrm{d}x\n$$\n这里，$f(x)$ 是分片常数热源项，而 $\\phi_j(x)$ 是与节点 $x_j$ 相关联的分片线性节点基函数（或称“帽函数”）。\n\n节点基函数 $\\phi_j(x)$ 的一个性质是，它仅在与节点 $x_j$ 相邻的单元上非零。由于 $j$ 是一个内部节点索引，这些单元是 $e_j = [x_{j-1}, x_j]$ 和 $e_{j+1} = [x_j, x_{j+1}]$。在所有其他单元上，$\\phi_j(x)=0$。因此， $F_j$ 的积分可以简化，因为其积分域可以限制在 $\\phi_j(x)$ 的支集上：\n$$\nF_j = \\int_{x_{j-1}}^{x_{j+1}} f(x) \\, \\phi_j(x) \\, \\mathrm{d}x\n$$\n这个积分可以分为两部分，$\\phi_j(x)$ 支集中的每个单元对应一部分：\n$$\nF_j = \\int_{x_{j-1}}^{x_j} f(x) \\, \\phi_j(x) \\, \\mathrm{d}x + \\int_{x_j}^{x_{j+1}} f(x) \\, \\phi_j(x) \\, \\mathrm{d}x\n$$\n问题陈述指出，热源 $f(x)$ 是分片常数，使得对于 $x \\in e_k = [x_{k-1}, x_k]$，$f(x)=f_k$。将此应用于我们的积分，我们得到：\n$$\nF_j = \\int_{x_{j-1}}^{x_j} f_j \\, \\phi_j(x) \\, \\mathrm{d}x + \\int_{x_j}^{x_{j+1}} f_{j+1} \\, \\phi_j(x) \\, \\mathrm{d}x\n$$\n由于 $f_j$ 和 $f_{j+1}$ 是常数，它们可以从积分中提出：\n$$\nF_j = f_j \\int_{x_{j-1}}^{x_j} \\phi_j(x) \\, \\mathrm{d}x + f_{j+1} \\int_{x_j}^{x_{j+1}} \\phi_j(x) \\, \\mathrm{d}x\n$$\n接下来，我们必须定义基函数 $\\phi_j(x)$ 在这两个单元上各自的解析表达式。\n基函数 $\\phi_j(x)$ 在每个单元上都是线性的，并满足 $\\phi_j(x_j)=1$ 和当 $i \\neq j$ 时 $\\phi_j(x_i)=0$。\n\n在单元 $e_j = [x_{j-1}, x_j]$ 上，函数 $\\phi_j(x)$ 从 $x_{j-1}$ 处的 $0$ 线性增加到 $x_j$ 处的 $1$。该线段的方程为：\n$$\n\\phi_j(x) = \\frac{x - x_{j-1}}{x_j - x_{j-1}} = \\frac{x - x_{j-1}}{h_j} \\quad \\text{对于 } x \\in [x_{j-1}, x_j]\n$$\n在单元 $e_{j+1} = [x_j, x_{j+1}]$ 上，函数 $\\phi_j(x)$ 从 $x_j$ 处的 $1$ 线性减小到 $x_{j+1}$ 处的 $0$。该线段的方程为：\n$$\n\\phi_j(x) = \\frac{x_{j+1} - x}{x_{j+1} - x_j} = \\frac{x_{j+1} - x}{h_{j+1}} \\quad \\text{对于 } x \\in [x_j, x_{j+1}]\n$$\n现在，我们将这些表达式代回到积分中。\n\n对于第一个积分，在单元 $e_j$ 上：\n$$\n\\int_{x_{j-1}}^{x_j} \\phi_j(x) \\, \\mathrm{d}x = \\int_{x_{j-1}}^{x_j} \\frac{x - x_{j-1}}{h_j} \\, \\mathrm{d}x = \\frac{1}{h_j} \\left[ \\frac{(x - x_{j-1})^2}{2} \\right]_{x_{j-1}}^{x_j}\n$$\n在积分上下限处计算反导数：\n$$\n\\frac{1}{h_j} \\left( \\frac{(x_j - x_{j-1})^2}{2} - \\frac{(x_{j-1} - x_{j-1})^2}{2} \\right) = \\frac{1}{h_j} \\left( \\frac{h_j^2}{2} - 0 \\right) = \\frac{h_j}{2}\n$$\n对于第二个积分，在单元 $e_{j+1}$ 上：\n$$\n\\int_{x_j}^{x_{j+1}} \\phi_j(x) \\, \\mathrm{d}x = \\int_{x_j}^{x_{j+1}} \\frac{x_{j+1} - x}{h_{j+1}} \\, \\mathrm{d}x = \\frac{1}{h_{j+1}} \\left[ -\\frac{(x_{j+1} - x)^2}{2} \\right]_{x_j}^{x_{j+1}}\n$$\n在积分上下限处计算反导数：\n$$\n\\frac{1}{h_{j+1}} \\left( -\\frac{(x_{j+1} - x_{j+1})^2}{2} - \\left(-\\frac{(x_{j+1} - x_j)^2}{2}\\right) \\right) = \\frac{1}{h_{j+1}} \\left( 0 + \\frac{h_{j+1}^2}{2} \\right) = \\frac{h_{j+1}}{2}\n$$\n这些积分代表了构成帽函数 $\\phi_j(x)$ 的两个三角形的面积。\n\n最后，我们将这些结果代回到 $F_j$ 的表达式中：\n$$\nF_j = f_j \\left( \\frac{h_j}{2} \\right) + f_{j+1} \\left( \\frac{h_{j+1}}{2} \\right)\n$$\n合并各项，即可得到内部节点 $j$ 处载荷向量分量的所需闭式表达式：\n$$\nF_j = \\frac{1}{2} (f_j h_j + f_{j+1} h_{j+1})\n$$\n根据问题陈述的要求，此表达式仅取决于相邻单元的尺寸 $h_j$ 和 $h_{j+1}$，以及相应的分片常数源值 $f_j$ 和 $f_{j+1}$。", "answer": "$$\n\\boxed{\\frac{f_j h_j + f_{j+1} h_{j+1}}{2}}\n$$", "id": "3595233"}, {"introduction": "从理论走向实践，本练习要求您从头开始构建一个完整的一维有限元求解器。我们将使用此求解器来研究离散极值原理（DMP），这是一个关键属性，它能确保数值解在物理上表现合理（例如，在没有源的情况下，域内不会出现新的温度极值）。这项动手编码任务将理论单元推导与功能性模拟联系起来，提供了关于单元类型（$p=1$ 与 $p=2$）等选择如何影响解的基本定性属性的深刻见解。[@problem_id:3595268]", "problem": "考虑区间 $[0,1]$ 上带有齐次狄利克雷边界条件的一维边值问题，其强形式为 $-(k(x)\\,u'(x))'=f(x)$，其中 $k(x)>0$ 几乎处处成立且 $f(x)\\ge 0$。其弱形式为：求解 $u\\in H_0^1(0,1)$，使得对于所有 $v\\in H_0^1(0,1)$，都有 $\\int_0^1 k(x)\\,u'(x)\\,v'(x)\\,dx=\\int_0^1 f(x)\\,v(x)\\,dx$。在计算地球物理学中，当模拟扩散过程（例如，热传导、水头扩散）时，单调性和离散极值原理（Discrete Maximum Principle, DMP）非常重要。对于一维网格上的线性有限元，在网格和系数满足适当条件的情况下，预计会满足单调性。\n\n您的任务是实现一个一维空间内的完整有限元求解器，该求解器支持 $p\\in\\{1,2\\}$ 次的连续分段多项式。您必须：\n\n- 假设 $k(x)$ 在每个单元上是分段常数，使用精确的单元公式从双线性形式 $a(u,v)=\\int_0^1 k(x)\\,u'(x)\\,v'(x)\\,dx$ 中组装全局刚度矩阵 $\\mathbf{A}$。\n- 对于分段常数 $f(x)$，使用精确的单元公式从线性泛函 $\\ell(v)=\\int_0^1 f(x)\\,v(x)\\,dx$ 中组装全局载荷向量 $\\mathbf{b}$，并在指定情况下，在单元的子区间上使用精确的解析积分。\n- 通过从线性系统中移除边界自由度来施加齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。\n\n在 $f(x)\\ge 0$ 和 $k(x)>0$ 的设定下，为离散极值原理（DMP）定义以下检查：\n\n1. 如果一个矩阵是对称正定的，并且其非对角线元素为非正值，则该矩阵是斯蒂尔吉斯矩阵。检查 $\\mathbf{A}$ 是否对称，是否具有严格为正的对角线元素，是否为正定，以及是否具有非正的非对角线元素。在一维情况下，对于线性有限元，此条件足以保证节点解的单调性。\n2. 检查组装的载荷向量 $\\mathbf{b}$ 是否是逐项非负的。对于线性有限元（$p=1$），局部形函数在其支撑上是非负的，这确保了当 $f(x)\\ge 0$ 时 $\\mathbf{b}$ 的非负性。对于二次有限元（$p=2$），局部形函数可能会变号，因此即使 $f(x)\\ge 0$，$\\mathbf{b}$ 也可能含有负值；这可能会违反DMP。\n3. 求解 $\\mathbf{A}\\mathbf{u}=\\mathbf{b}$，并检查计算出的节点值向量 $\\mathbf{u}$（对于内部自由度）是否是逐项非负的。\n\n就本问题而言，当且仅当上述所有三项检查都通过时，我们定义给定案例的DMP成立。\n\n实现以下测试案例套件（所有网格均位于区间 $[0,1]$ 上）：\n\n- 案例 $\\mathrm{T1}$（分段线性元，均匀网格，常系数）：使用 $p=1$，$N=10$ 个单元，节点位于 $x_i=i/N$（其中 $i=0,1,\\dots,N$），令 $k(x)\\equiv 1$ 且 $f(x)\\equiv 1$。报告DMP是否成立。\n- 案例 $\\mathrm{T2}$（分段线性元，高度非均匀网格，强变系数）：使用 $p=1$，$N=7$ 个单元，节点为 $x=\\big[0,\\,0.01,\\,0.02,\\,0.05,\\,0.15,\\,0.40,\\,0.70,\\,1\\big]$，每个单元上的分段常系数为 $k_e=\\big[10,\\,0.1,\\,100,\\,0.2,\\,50,\\,1.5,\\,5\\big]$。令 $f(x)\\equiv 1$。报告DMP是否成立。\n- 案例 $\\mathrm{T3}$（分段二次单元，均匀网格，常系数）：使用 $p=2$，$N=6$ 个单元，节点位于 $x_i=i/N$（其中 $i=0,1,\\dots,N$），令 $k(x)\\equiv 1$ 且 $f(x)\\equiv 1$。报告DMP是否成立。注意：对于 $p=2$，全局刚度矩阵在某些顶点自由度之间具有正的非对角线元素，因此该矩阵不满足斯蒂尔吉斯性质；因此，即使解恰好是非负的，也应报告DMP不成立。\n- 案例 $\\mathrm{T4}$（分段二次单元，均匀网格，在子区间上的定向正强迫项）：使用 $p=2$，$N=4$ 个单元，节点位于 $x_i=i/N$（其中 $i=0,1,\\dots,N$），令 $k(x)\\equiv 1$，并将 $f(x)$ 定义为仅在单元 $e=2$ 的右半部分（即在 $[x_2+\\tfrac{h}{2},x_3]$ 上，其中 $h=x_3-x_2$）严格为正，其值为 $C=100$，在其他地方为零。由于二次基函数会变号，这个 $f(x)\\ge 0$ 会在该单元的内部顶点节点处的载荷向量中产生一个负值，从而违反DMP。报告DMP是否成立。\n\n您的程序必须完全按照描述实现组装和检查。对于每个案例，输出一个布尔值，指示DMP是否成立。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是相应案例的布尔值。", "solution": "该问题要求为区间 $[0,1]$ 上带有齐次狄利克雷边界条件 $u(0)=u(1)=0$ 的边值问题 $-\\frac{d}{dx}(k(x)\\frac{du}{dx}) = f(x)$ 实现一个一维有限元方法（FEM）求解器。该求解器必须支持连续分段线性（$p=1$）和分段二次（$p=2$）基函数。一个关键方面是验证四个指定测试案例的离散极值原理（DMP）。DMP被定义为当且仅当满足三个条件时才成立：1) 内部自由度的全局刚度矩阵是斯蒂尔吉斯矩阵，2) 组装的内部自由度全局载荷向量是逐项非负的，3) 得到的数值解是逐项非负的。\n\n解决方案首先推导 $p=1$ 和 $p=2$ 单元的单元刚度矩阵和载荷向量。然后，描述组装过程、边界条件的施加以及DMP检查的实现。最后，根据这些原理分析每个测试案例。\n\n**有限元离散化与单元级计算**\n\n将域 $[0,1]$ 离散为 $N$ 个单元。对于一个跨越 $[x_e, x_{e+1}]$、长度为 $h_e = x_{e+1} - x_e$ 的单元 $e$，我们使用从参考单元 $\\hat{K} = [-1, 1]$到物理单元的映射。单元刚度矩阵的积分为 $A^e_{ij} = \\int_{x_e}^{x_{e+1}} k_e \\phi'_i(x) \\phi'_j(x) dx$，单元载荷向量为 $b^e_i = \\int_{x_e}^{x_{e+1}} f_e(x) \\phi_i(x) dx$。我们假设 $k(x) = k_e$ 在单元 $e$ 上是常数。\n\n**1. 分段线性单元 ($p=1$)**\n一个单元有2个节点，每个端点一个。参考单元 $\\hat{K}$ 上的基函数是 $\\hat{\\phi}_1(\\xi) = \\frac{1-\\xi}{2}$ 和 $\\hat{\\phi}_2(\\xi) = \\frac{1+\\xi}{2}$。它们的导数是 $\\frac{d\\hat{\\phi}_1}{d\\xi} = -\\frac{1}{2}$ 和 $\\frac{d\\hat{\\phi}_2}{d\\xi} = \\frac{1}{2}$。\n\n通过将积分变换到参考单元来找到单元刚度矩阵：\n$$ A^e_{ij} = \\int_{-1}^{1} k_e \\left(\\frac{d\\hat{\\phi}_i}{d\\xi}\\frac{2}{h_e}\\right) \\left(\\frac{d\\hat{\\phi}_j}{d\\xi}\\frac{2}{h_e}\\right) \\frac{h_e}{2} d\\xi = \\frac{2k_e}{h_e} \\int_{-1}^{1} \\frac{d\\hat{\\phi}_i}{d\\xi} \\frac{d\\hat{\\phi}_j}{d\\xi} d\\xi $$\n计算积分得到一维扩散问题著名的单元刚度矩阵：\n$$ \\mathbf{A}^e = \\frac{k_e}{h_e} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} $$\n对于分段常数强迫函数 $f(x)=f_e$，单元载荷向量是：\n$$ b^e_i = \\int_{-1}^{1} f_e \\hat{\\phi}_i(\\xi) \\frac{h_e}{2} d\\xi $$\n这给出了单元载荷向量，它对应于积分的梯形法则：\n$$ \\mathbf{b}^e = f_e \\frac{h_e}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} $$\n\n**2. 分段二次单元 ($p=2$)**\n一个单元有3个节点：每个端点一个（顶点节点）和中点一个（内部节点）。在 $\\hat{K}$ 上对应于节点 $\\xi = -1, 0, 1$ 的基函数是：\n- $\\hat{\\phi}_1(\\xi) = \\frac{\\xi(\\xi-1)}{2}$ (左顶点)\n- $\\hat{\\phi}_2(\\xi) = 1-\\xi^2$ (中点)\n- $\\hat{\\phi}_3(\\xi) = \\frac{\\xi(\\xi+1)}{2}$ (右顶点)\n它们的导数是 $\\frac{d\\hat{\\phi}_1}{d\\xi} = \\xi - \\frac{1}{2}$，$\\frac{d\\hat{\\phi}_2}{d\\xi} = -2\\xi$，和 $\\frac{d\\hat{\\phi}_3}{d\\xi} = \\xi + \\frac{1}{2}$。\n使用与 $p=1$ 相同的变换计算出的单元刚度矩阵是：\n$$ \\mathbf{A}^e = \\frac{k_e}{3h_e} \\begin{pmatrix} 7  -8  1 \\\\ -8  16  -8 \\\\ 1  -8  7 \\end{pmatrix} $$\n注意正的非对角线元素 $A^e_{13} = A^e_{31} = \\frac{k_e}{3h_e}$。这些项连接相邻的顶点节点，并导致全局刚度矩阵不满足斯蒂尔吉斯性质（非正非对角线元素）。\n\n对于常数强迫项 $f(x)=f_e$，单元载荷向量为：\n$$ \\mathbf{b}^e = f_e \\frac{h_e}{6} \\begin{pmatrix} 1 \\\\ 4 \\\\ 1 \\end{pmatrix} $$\n这对应于积分的辛普森法则。\n\n对于案例 T4，强迫函数是 $f(x) = C = 100$，作用在单元 $e=2$ 的右半部分，这对应于参考单元上的区间 $[\\xi_0, \\xi_1] = [0, 1]$。单元载荷向量计算为 $b^e_i = \\int_0^1 C \\hat{\\phi}_i(\\xi) \\frac{h_e}{2} d\\xi$。\n- 对于左顶点节点 ($\\hat{\\phi}_1$): $b^e_1 = C\\frac{h_e}{2} \\int_0^1 \\frac{\\xi(\\xi-1)}{2} d\\xi = C\\frac{h_e}{2} \\left(-\\frac{1}{12}\\right)$。由于 $C>0$ 和 $h_e>0$，此项为负。\n- 对于中点节点 ($\\hat{\\phi}_2$): $b^e_2 = C\\frac{h_e}{2} \\int_0^1 (1-\\xi^2) d\\xi = C\\frac{h_e}{2} \\left(\\frac{2}{3}\\right)$。\n- 对于右顶点节点 ($\\hat{\\phi}_3$): $b^e_3 = C\\frac{h_e}{2} \\int_0^1 \\frac{\\xi(\\xi+1)}{2} d\\xi = C\\frac{h_e}{2} \\left(\\frac{5}{12}\\right)$。\n$b^e_1$ 的负值表明，当使用在单元上并非处处非负的高阶基函数时，一个非负的强迫函数 $f(x) \\ge 0$ 如何能在载荷向量中产生负值项。\n\n**全局组装与边界条件**\n全局刚度矩阵 $\\mathbf{A}$ 和载荷向量 $\\mathbf{b}$ 是通过遍历每个单元，计算其局部矩阵 $\\mathbf{A}^e$ 和向量 $\\mathbf{b}^e$，并将其贡献加到相应的全局自由度（DoFs）上来构建的。\n对于 $p=1$，有 $N+1$ 个自由度，索引为 $0, \\dots, N$。对于 $p=2$，有 $2N+1$ 个自由度，索引为 $0, \\dots, 2N$。\n齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$ 通过从全局系统中移除与边界自由度（第一个和最后一个）相对应的行和列来施加。这会产生一个更小的线性系统 $\\mathbf{A}_{int}\\mathbf{u}_{int} = \\mathbf{b}_{int}$，用于求解未知的内部节点值 $\\mathbf{u}_{int}$。\n\n**DMP检查与测试案例分析**\n如果对内部系统的以下三项检查都通过，则认为DMP成立：\n1.  **斯蒂尔吉斯矩阵：** $\\mathbf{A}_{int}$ 是对称、正定的，并且具有非正的非对角线元素。\n2.  **非负载荷向量：** $\\mathbf{b}_{int}$ 的所有元素都是非负的。\n3.  **非负解：** 解 $\\mathbf{u}_{int} = \\mathbf{A}_{int}^{-1}\\mathbf{b}_{int}$ 的所有元素都是非负的。\n\n- **案例 T1（$p=1$，均匀网格，常系数）：**\n  1. 矩阵 $\\mathbf{A}_{int}$ 是一个三对角矩阵，对角线元素为 $\\frac{2k}{h}$，非对角线元素为 $-\\frac{k}{h}$。它是对称的，对角占优且对角线元素为正（因此是正定的），并且具有非正的非对角线元素。**检查1通过。**\n  2. 载荷向量 $\\mathbf{b}_{int}$ 的元素为 $f \\cdot h > 0$。**检查2通过。**\n  3. 由于 $\\mathbf{A}_{int}$ 是一个M-矩阵且 $\\mathbf{b}_{int}$ 是非负的，解 $\\mathbf{u}_{int} = \\mathbf{A}_{int}^{-1}\\mathbf{b}_{int}$ 保证是非负的。**检查3通过。**\n  **T1的结果：DMP成立（True）。**\n\n- **案例 T2（$p=1$，非均匀网格，变系数）：**\n  1. 与 T1 类似，$\\mathbf{A}_{int}$ 是三对角的。对角线元素为 $(\\frac{k_{i-1}}{h_{i-1}} + \\frac{k_i}{h_i})>0$，非对角线元素为 $-\\frac{k_i}{h_i}0$。该矩阵对称、正定，且具有非正的非对角线元素。**检查1通过。**\n  2. 载荷向量元素为 $f \\frac{h_{i-1}+h_i}{2} > 0$。**检查2通过。**\n  3. T1的论证同样适用。**检查3通过。**\n  **T2的结果：DMP成立（True）。**\n\n- **案例 T3（$p=2$，均匀网格，常系数）：**\n  1. 组装包含正非对角线元素的 $\\mathbf{A}^e$ 矩阵，会导致全局矩阵 $\\mathbf{A}_{int}$ 具有连接相邻顶点自由度的正非对角线元素。例如，耦合顶点节点 $x_i$ 和顶点节点 $x_{i+1}$ 的元素是正的。因此，$\\mathbf{A}_{int}$ 不是斯蒂尔吉斯矩阵。**检查1失败。**\n  根据问题定义，若有任何一项检查失败，则DMP不成立。\n  **T3的结果：DMP不成立（False）。**\n\n- **案例 T4（$p=2$，特殊强迫项）：**\n  1. 如 T3 一样，刚度矩阵 $\\mathbf{A}_{int}$ 不是斯蒂尔吉斯矩阵。**检查1失败。**\n  2. 如上文推导，强迫函数 $f(x)>0$ 在单元 $e=2$ 的右半部分，会在对应于该单元左顶点（$x_2=0.5$）的节点的局部载荷向量 $\\mathbf{b}^e$ 中产生一个负值项。由于前一个单元上的 $f(x)=0$，这个负贡献不会被抵消，导致 $\\mathbf{b}_{int}$ 中相应的元素变为负值。**检查2失败。**\n  由于多项检查失败，DMP不成立。\n  **T4的结果：DMP不成立（False）。**\n\n最终输出是 T1、T2、T3 和 T4 的布尔结果列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(p, N, nodes, k_vals, f_type, f_params):\n    \"\"\"\n    Assembles and solves a 1D FEM problem, then performs DMP checks.\n\n    Args:\n        p (int): Polynomial degree (1 or 2).\n        N (int): Number of elements.\n        nodes (np.ndarray): Array of node coordinates.\n        k_vals (list or np.ndarray): Piecewise constant k values for each element.\n        f_type (str): Type of forcing function ('const' or 'special').\n        f_params (dict): Parameters for the forcing function.\n\n    Returns:\n        bool: True if DMP holds, False otherwise.\n    \"\"\"\n    # 1. Setup based on polynomial degree\n    if p == 1:\n        num_dofs = N + 1\n        interior_dof_indices = slice(1, N)\n    elif p == 2:\n        num_dofs = 2 * N + 1\n        interior_dof_indices = slice(1, 2 * N)\n    else:\n        raise ValueError(\"Polynomial degree p must be 1 or 2.\")\n\n    A = np.zeros((num_dofs, num_dofs))\n    b = np.zeros(num_dofs)\n\n    # 2. Assembly loop over elements\n    for e in range(N):\n        x_left = nodes[e]\n        x_right = nodes[e+1]\n        h = x_right - x_left\n        k_e = k_vals[e]\n\n        if p == 1:\n            # Element stiffness matrix for p=1\n            A_e = (k_e / h) * np.array([[1, -1], [-1, 1]])\n            \n            # Element load vector for p=1\n            f_e_val = 0.0\n            if f_type == 'const':\n                f_e_val = f_params['val']\n            b_e = (f_e_val * h / 2.0) * np.array([1, 1])\n            \n            # Global assembly indices\n            dofs = [e, e + 1]\n            A[np.ix_(dofs, dofs)] += A_e\n            b[dofs] += b_e\n        \n        elif p == 2:\n            # Element stiffness matrix for p=2\n            A_e = (k_e / (3.0 * h)) * np.array([[7, -8, 1],\n                                                  [-8, 16, -8],\n                                                  [1, -8, 7]])\n            \n            # Element load vector for p=2\n            b_e = np.zeros(3)\n            if f_type == 'const':\n                f_e_val = f_params['val']\n                b_e = (f_e_val * h / 6.0) * np.array([1, 4, 1])\n            elif f_type == 'special' and e == f_params['elem_idx']:\n                C = f_params['val']\n                # Integrals of basis functions over the right half of ref element [0,1]\n                integrals = np.array([-1.0/12.0, 2.0/3.0, 5.0/12.0])\n                b_e = (C * h / 2.0) * integrals\n            \n            # Global assembly indices\n            dofs = [2*e, 2*e + 1, 2*e + 2]\n            A[np.ix_(dofs, dofs)] += A_e\n            b[dofs] += b_e\n\n    # 3. Apply BCs by extracting interior system\n    A_int = A[interior_dof_indices, interior_dof_indices]\n    b_int = b[interior_dof_indices]\n\n    # 4. Perform DMP checks\n    # Check 1: A_int is a Stieltjes matrix\n    # A small tolerance for floating point comparisons\n    tol = 1e-12\n    is_symmetric = np.allclose(A_int, A_int.T)\n    has_pos_diag = np.all(np.diag(A_int) > tol)\n    \n    is_pos_def = False\n    if is_symmetric:\n        try:\n            # Cholesky decomposition is a standard test for SPD matrices\n            np.linalg.cholesky(A_int)\n            is_pos_def = True\n        except np.linalg.LinAlgError:\n            is_pos_def = False\n    \n    A_off_diag = A_int.copy()\n    np.fill_diagonal(A_off_diag, 0.0)\n    has_nonpos_offdiag = np.all(A_off_diag <= tol)\n    \n    check1_passed = is_symmetric and has_pos_diag and is_pos_def and has_nonpos_offdiag\n\n    # Check 2: b_int is entrywise non-negative\n    check2_passed = np.all(b_int >= -tol)\n\n    # Check 3: Solution u_int is entrywise non-negative\n    check3_passed = False\n    if check1_passed and check2_passed: # Optimization, no need to solve if properties fail\n        try:\n            u_int = np.linalg.solve(A_int, b_int)\n            check3_passed = np.all(u_int >= -tol)\n        except np.linalg.LinAlgError:\n            # System is singular, solution does not exist or is not unique\n            check3_passed = False\n            \n    # Per the problem, DMP holds if and only if ALL three checks pass.\n    # The check3_passed will implicitly be False if check1 or check2 fail\n    # because of the conditional block, so we just need to and the results.\n    return check1_passed and check2_passed and check3_passed\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the FEM solver for each.\n    \"\"\"\n    T1_N = 10\n    T2_N = 7\n    T3_N = 6\n    T4_N = 4\n\n    test_cases = [\n        {\n            'p': 1, 'N': T1_N, 'nodes': np.linspace(0, 1, T1_N + 1), \n            'k_vals': [1.0] * T1_N, 'f_type': 'const', 'f_params': {'val': 1.0}\n        },\n        {\n            'p': 1, 'N': T2_N,\n            'nodes': np.array([0, 0.01, 0.02, 0.05, 0.15, 0.40, 0.70, 1]),\n            'k_vals': [10.0, 0.1, 100.0, 0.2, 50.0, 1.5, 5.0],\n            'f_type': 'const', 'f_params': {'val': 1.0}\n        },\n        {\n            'p': 2, 'N': T3_N, 'nodes': np.linspace(0, 1, T3_N + 1),\n            'k_vals': [1.0] * T3_N, 'f_type': 'const', 'f_params': {'val': 1.0}\n        },\n        {\n            'p': 2, 'N': T4_N, 'nodes': np.linspace(0, 1, T4_N + 1),\n            'k_vals': [1.0] * T4_N, 'f_type': 'special',\n            'f_params': {'val': 100.0, 'elem_idx': 2}\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        dmp_holds = run_case(\n            p=case['p'],\n            N=case['N'],\n            nodes=case['nodes'],\n            k_vals=case['k_vals'],\n            f_type=case['f_type'],\n            f_params=case['f_params']\n        )\n        results.append(dmp_holds)\n\n    # Format output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3595268"}]}