{"hands_on_practices": [{"introduction": "在求解任何实际的地球物理问题之前，我们必须首先确保我们构建的有限元模型在根本上是正确的。一个关键的验证步骤是检查模型如何响应刚体运动，因为一个无约束的弹性体不应该对纯平移或旋转产生任何抵抗力。这项实践 [@problem_id:3588944] 将指导你完成一个至关重要的验证步骤：通过计算来确认你所组装的全局刚度矩阵 $\\mathbf{K}$ 的零空间（null space）是否精确地对应于物理上的刚体模态，并探索这对求解线性系统 $\\mathbf{K}\\mathbf{u} = \\mathbf{f}$ 的意义。", "problem": "考虑一个处于无量纲环境下的二维小应变线性弹性体，该物体使用常应变三节点三角形通过有限元方法 (FEM) 进行离散化。其本构行为是平面应力条件下的线性各向同性弹性。未知位移场由向量 $\\mathbf{u}$ 表示，该向量按 $\\left[u_{x1}, u_{y1}, u_{x2}, u_{y2}, \\dots \\right]^{\\top}$ 的顺序集合了所有节点位移。组装后的全局刚度矩阵为 $\\mathbf{K}$，全局载荷向量为 $\\mathbf{f}$。刚体模态是对应于两个平移和一个平面内旋转的三种位移模式。\n\n使用的基本原理：\n- 虚功原理：对于任意虚位移 $\\delta \\mathbf{u}$，内虚功等于外虚功，即 $\\int_{\\Omega} \\boldsymbol{\\sigma} : \\delta \\boldsymbol{\\varepsilon} \\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\mathbf{b} \\cdot \\delta \\mathbf{u} \\, \\mathrm{d}\\Omega + \\int_{\\Gamma_{t}} \\bar{\\mathbf{t}} \\cdot \\delta \\mathbf{u} \\, \\mathrm{d}\\Gamma$。经过有限元离散化后，得到 $\\delta \\mathbf{u}^{\\top} \\mathbf{K} \\mathbf{u} = \\delta \\mathbf{u}^{\\top} \\mathbf{f}$。\n- 线性运动学：对于每个单元，$\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{u}_{e}$，其中 $\\mathbf{B}$ 为常应变-位移矩阵。\n- 平面应力条件下的线性各向同性弹性：$\\boldsymbol{\\sigma} = \\mathbf{D} \\, \\boldsymbol{\\varepsilon}$，其中\n$$\n\\mathbf{D} = \\dfrac{E}{1-\\nu^{2}} \\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\dfrac{1-\\nu}{2} \\end{bmatrix}\n$$\n$E$ 为杨氏模量，$\\nu$ 为泊松比。\n- 常应变三角形（厚度为 $t$）的单元刚度矩阵：$\\mathbf{K}_{e} = t \\, A_{e} \\, \\mathbf{B}^{\\top} \\mathbf{D} \\mathbf{B}$，其中 $A_{e}$ 是三角形面积，$\\mathbf{B}$ 由节点坐标通过标准的常应变三角形公式计算得出。\n\n任务：\n1. 为一个单位正方形域 $\\Omega = [0,1] \\times [0,1]$ 组装全局刚度矩阵 $\\mathbf{K}$。该域被离散为两个线性三角形单元，节点位于 $(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$，单元分别为 $\\{(0,0),(1,0),(1,1)\\}$ 和 $\\{(0,0),(1,1),(0,1)\\}$。使用平面应力条件，厚度 $t = 1$。所有量均为无量纲，因此输出中无需物理单位。\n2. 构建三个大小为 $2N$ 的刚体模态向量 $\\mathbf{r}_{1}$、$\\mathbf{r}_{2}$、$\\mathbf{r}_{3}$，分别对应于：x方向平移（对于所有节点，$\\mathbf{r}_{1}$ 中 $u_{xi} = 1$, $u_{yi} = 0$），y方向平移（$\\mathbf{r}_{2}$ 中 $u_{xi} = 0$, $u_{yi} = 1$），以及绕原点的单位旋转（$\\mathbf{r}_{3}$ 中节点 $i$ 处 $u_{xi} = -y_{i}$，$u_{yi} = x_{i}$）。\n3. 通过计算 $\\|\\mathbf{K} \\mathbf{r}_{j}\\|_{2}$（其中 $j \\in \\{1,2,3\\}$）来验证每个组装好的 $\\mathbf{K}$ 的刚体模态，并将这些范数以浮点数形式报告。在精确算术和正确组装的情况下，$\\mathbf{K} \\mathbf{r}_{j} = \\mathbf{0}$。\n4. 证明任何与所有刚体模态正交的载荷向量 $\\mathbf{f}$（即对于 $j \\in \\{1,2,3\\}$，$\\mathbf{r}_{j}^{\\top} \\mathbf{f} = 0$）都能产生一个可解的系统 $\\mathbf{K} \\mathbf{u} = \\mathbf{f}$（即至少存在一个解）。通过计算最小范数解 $\\mathbf{u} = \\mathbf{K}^{+} \\mathbf{f}$（其中 $\\mathbf{K}^{+}$ 是Moore–Penrose伪逆）来数值验证其可解性，并以浮点数形式报告残差范数 $\\|\\mathbf{K}\\mathbf{u} - \\mathbf{f}\\|_{2}$。\n5. 设计一个载荷向量 $\\mathbf{f}$，它会错误地激发受约束的（刚体）模态，即它不与刚体模态子空间正交。通过计算 $\\mathbf{f}$ 在 $\\{\\mathbf{r}_{1}, \\mathbf{r}_{2}, \\mathbf{r}_{3}\\}$ 所张成子空间上的投影大小，并以浮点数形式报告此大小，来检测这种情况。同时报告一个布尔标志以指示检测结果，如果该大小超过容差 $\\varepsilon = 10^{-10}$ 则定义为true，否则为false。\n\n使用以下参数值和载荷的测试套件：\n- 测试用例 #1：$E = 2$, $\\nu = 0.25$, $t = 1$。载荷 $\\mathbf{f}$ 是自平衡的，且与刚体模态正交：在节点 $(1,0)$ 的x方向施加+1，在节点 $(0,0)$ 的x方向施加-1，其他地方为零。\n- 测试用例 #2：$E = 1$, $\\nu = 0$, $t = 1$。载荷 $\\mathbf{f}$ 是一个确定性随机向量，它被投影以与所有刚体模态正交。\n- 测试用例 #3：$E = 2$, $\\nu = 0.25$, $t = 1$。载荷 $\\mathbf{f}$ 是一个均匀向下的节点载荷：在每个节点的y方向施加-1，x方向为零。\n\n对于每个测试用例，按顺序生成以下输出：\n- 三个浮点数 $\\|\\mathbf{K} \\mathbf{r}_{1}\\|_{2}$、$\\|\\mathbf{K} \\mathbf{r}_{2}\\|_{2}$、$\\|\\mathbf{K} \\mathbf{r}_{3}\\|_{2}$。\n- 使用 $\\mathbf{u} = \\mathbf{K}^{+} \\mathbf{f}$ 计算的浮点数残差范数 $\\|\\mathbf{K}\\mathbf{u} - \\mathbf{f}\\|_{2}$。\n- $\\mathbf{f}$ 在刚体模态子空间上投影的浮点数量值大小。\n- 布尔检测标志，如果投影大小超过 $\\varepsilon = 10^{-10}$ 则为true，否则为false。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含所有三个测试用例的串联结果，形式为方括号括起来的逗号分隔列表，即 $\\left[ \\text{case1\\_n1}, \\text{case1\\_n2}, \\text{case1\\_n3}, \\text{case1\\_res}, \\text{case1\\_proj}, \\text{case1\\_flag}, \\text{case2\\_n1}, \\dots, \\text{case3\\_flag} \\right]$。所有数字必须打印为不带单位的原始十进制值，布尔值则以编程语言的原生布尔字面量形式（true或false）打印。", "solution": "所提出的问题是有效的。这是一个在计算固体力学领域中使用有限元方法 (FEM) 的适定且有科学依据的练习。所有必要的数据，包括几何形状、材料属性和加载条件，都已提供，并且任务与线性弹性力学和数值线性代数的既定原则相符。该问题没有矛盾、歧义和事实错误。\n\n求解过程首先为平面应力条件下的常应变三角形 (CST) 单元建立理论框架。随后，为指定的双单元网格组装全局刚度矩阵。构建并验证刚体模态。最后，对于每个测试用例，通过利用Moore-Penrose伪逆和将载荷向量投影到刚体模态子空间上来评估系统的可解性。\n\n**1. 单元公式**\n\n对于处于二维平面应力状态下的3节点三角形单元，常应变向量 $\\boldsymbol{\\varepsilon} = [\\varepsilon_x, \\varepsilon_y, \\gamma_{xy}]^\\top$ 与节点位移向量 $\\mathbf{u}_e = [u_{x1}, u_{y1}, u_{x2}, u_{y2}, u_{x3}, u_{y3}]^\\top$ 之间的关系由 $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{u}_e$ 给出。对于节点坐标为 $(x_1, y_1)$, $(x_2, y_2)$ 和 $(x_3, y_3)$ 的单元，其应变-位移矩阵 $\\mathbf{B}$ 为：\n$$\n\\mathbf{B} = \\frac{1}{2A_e}\n\\begin{bmatrix}\ny_2 - y_3 & 0 & y_3 - y_1 & 0 & y_1 - y_2 & 0 \\\\\n0 & x_3 - x_2 & 0 & x_1 - x_3 & 0 & x_2 - x_1 \\\\\nx_3 - x_2 & y_2 - y_3 & x_1 - x_3 & y_3 - y_1 & x_2 - x_1 & y_1 - y_2\n\\end{bmatrix}\n$$\n其中 $A_e$ 是单元面积。\n\n平面应力条件下的线性各向同性弹性本构关系为 $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$，其中弹性矩阵 $\\mathbf{D}$ 由下式给出：\n$$\n\\mathbf{D} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1 & \\nu & 0 \\\\\n\\nu & 1 & 0 \\\\\n0 & 0 & \\frac{1-\\nu}{2}\n\\end{bmatrix}\n$$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。\n\n大小为 $6 \\times 6$ 的单元刚度矩阵 $\\mathbf{K}_e$ 由虚功原理推导得出，计算公式如下：\n$$\n\\mathbf{K}_e = t A_e \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B}\n$$\n其中 $t$ 是单元厚度，给定为 $t=1$。\n\n**2. 全局刚度矩阵组装**\n\n系统包含 $N=4$ 个节点，从而产生 $2N = 8$ 个全局自由度 (DOF)，按 $\\mathbf{u} = [u_{x0}, u_{y0}, u_{x1}, u_{y1}, u_{x2}, u_{y2}, u_{x3}, u_{y3}]^\\top$ 的顺序排列。节点坐标指定为节点0: $(0,0)$，节点1: $(1,0)$，节点2: $(1,1)$ 和节点3: $(0,1)$。网格由两个单元组成：\n- 单元 1：节点 $(0, 1, 2)$。其自由度映射到全局自由度 $(0, 1, 2, 3, 4, 5)$。\n- 单元 2：节点 $(0, 2, 3)$。其自由度映射到全局自由度 $(0, 1, 4, 5, 6, 7)$。\n\n对于每个单元，我们计算其 $6 \\times 6$ 的刚度矩阵 $\\mathbf{K}_e$。通过将每个单元矩阵的贡献累加到相应的全局自由度位置，来组装 $8 \\times 8$ 的全局刚度矩阵 $\\mathbf{K}$。\n\n**3. 刚体模态**\n\n对于没有边界条件的结构（一个“浮动”结构），全局刚度矩阵 $\\mathbf{K}$ 是奇异的。其零空间由刚体模态 (RBM) 张成。对于一个二维系统，存在3个刚体模态：两个平移和一个平面内旋转。这些模态由8维节点位移空间中的向量表示。\n- x方向平移：$\\mathbf{r}_1 = [1, 0, 1, 0, 1, 0, 1, 0]^\\top$。\n- y方向平移：$\\mathbf{r}_2 = [0, 1, 0, 1, 0, 1, 0, 1]^\\top$。\n- 绕原点 $(0,0)$ 旋转：坐标为 $(x_i, y_i)$ 的节点 $i$ 处的位移为 $(u_{xi}, u_{yi}) = (-y_i, x_i)$。这给出 $\\mathbf{r}_3 = [0, 0, 0, 1, -1, 1, -1, 0]^\\top$。\n\n一个关键特性是刚体运动不产生应变，因此不产生内力。在数学上，这意味着对于 $j=1, 2, 3$，$\\mathbf{K}\\mathbf{r}_j = \\mathbf{0}$。这通过计算L2范数 $\\|\\mathbf{K}\\mathbf{r}_j\\|_2$ 来验证，其值在数值精度范围内必须为零。\n\n**4. 系统可解性与载荷向量分析**\n\n线性系统 $\\mathbf{K}\\mathbf{u} = \\mathbf{f}$ 有解，当且仅当载荷向量 $\\mathbf{f}$ 位于 $\\mathbf{K}$ 的列空间（值域）中。由于 $\\mathbf{K}$ 是对称的，其值域是其零空间的正交补。因此，解存在的充要条件是 $\\mathbf{f}$ 与零空间中的每个向量都正交，即对于 $j=1, 2, 3$，$\\mathbf{r}_j^\\top \\mathbf{f} = 0$。这样的载荷向量是自平衡的。\n\n如果满足此条件，系统将有形如 $\\mathbf{u}_p + \\mathbf{u}_h$ 的无穷多解，其中 $\\mathbf{u}_p$ 是一个特解，而 $\\mathbf{u}_h$ 是刚体模态的任意线性组合。Moore-Penrose伪逆 $\\mathbf{K}^{+}$ 提供了唯一的最小范数解 $\\mathbf{u} = \\mathbf{K}^{+}\\mathbf{f}$。如果 $\\mathbf{f}$ 位于 $\\mathbf{K}$ 的值域内，残差范数 $\\|\\mathbf{K}\\mathbf{u} - \\mathbf{f}\\|_2$ 将（在容差范围内）为零。\n\n如果 $\\mathbf{f}$ 与刚体模态不正交，它在 $\\mathbf{K}^\\top = \\mathbf{K}$ 的零空间中存在分量，因此不在 $\\mathbf{K}$ 的值域中。在这种情况下，不存在精确解。伪逆仍然给出最小范数最小二乘解，该解最小化了 $\\|\\mathbf{K}\\mathbf{u} - \\mathbf{f}\\|_2$，但这个最小范数将不为零。\n\n为了检测 $\\mathbf{f}$ 是否激发了刚体模态，我们将其投影到由 $\\{\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3\\}$ 张成的子空间上。首先，我们为此子空间构建一个标准正交基，例如，通过对矩阵 $\\mathbf{R} = [\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3]$ 应用QR分解，得到一个具有标准正交列的矩阵 $\\mathbf{Q}$。$\\mathbf{f}$ 在此子空间上的投影为 $\\mathbf{f}_{proj} = \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{f}$。此投影的大小为 $\\|\\mathbf{f}_{proj}\\|_2 = \\|\\mathbf{Q}^\\top \\mathbf{f}\\|_2$。如果此大小超过一个很小的容差 $\\varepsilon=10^{-10}$，则表示载荷未被正确平衡，并激发了刚体运动。\n\n算法通过为每个提供的测试用例实施这些步骤来继续。\n- 对于测试用例 #1，载荷是自平衡的，投影大小应接近于零。\n- 对于测试用例 #2，载荷被构造成与刚体模态正交，因此其投影大小也将接近于零。\n- 对于测试用例 #3，载荷代表一个净向下的力，因此它不是自平衡的。其在刚体模态子空间上的投影将不为零，并且最小二乘解的残差范数也将不为零。", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Solves a set of finite element analysis problems for a 2D elastic solid.\n    \"\"\"\n\n    # --- Nodal and Element Definitions ---\n    nodes = np.array([\n        [0.0, 0.0],  # Node 0\n        [1.0, 0.0],  # Node 1\n        [1.0, 1.0],  # Node 2\n        [0.0, 1.0],  # Node 3\n    ])\n    elements = [\n        [0, 1, 2],\n        [0, 2, 3]\n    ]\n    num_nodes = len(nodes)\n    num_dofs = 2 * num_nodes\n    thickness = 1.0\n\n    # --- Test Case Definitions ---\n    test_cases = [\n        {'E': 2.0, 'nu': 0.25, 'load_type': 'equilibrated'},\n        {'E': 1.0, 'nu': 0.0, 'load_type': 'projected_random'},\n        {'E': 2.0, 'nu': 0.25, 'load_type': 'uniform_downward'},\n    ]\n\n    all_results = []\n    \n    # --- Rigid Body Modes ---\n    r1 = np.tile([1.0, 0.0], num_nodes)  # x-translation\n    r2 = np.tile([0.0, 1.0], num_nodes)  # y-translation\n    r3 = np.zeros(num_dofs)  # rotation about origin\n    for i in range(num_nodes):\n        x, y = nodes[i]\n        r3[2 * i] = -y\n        r3[2 * i + 1] = x\n    \n    R = np.vstack([r1, r2, r3]).T\n    Q_rbm, _ = np.linalg.qr(R) # Orthonormal basis for RBM space\n\n    for case in test_cases:\n        E = case['E']\n        nu = case['nu']\n\n        # --- Assemble Global Stiffness Matrix K ---\n        K = np.zeros((num_dofs, num_dofs))\n        # Constitutive matrix D for plane stress\n        c = E / (1.0 - nu**2)\n        D = c * np.array([\n            [1.0, nu, 0.0],\n            [nu, 1.0, 0.0],\n            [0.0, 0.0, (1.0 - nu) / 2.0]\n        ])\n\n        for el_nodes in elements:\n            # Element coordinates\n            n1_coords, n2_coords, n3_coords = nodes[el_nodes]\n            x1, y1 = n1_coords\n            x2, y2 = n2_coords\n            x3, y3 = n3_coords\n\n            # Element area\n            area = 0.5 * np.linalg.det(np.array([[1, x1, y1], [1, x2, y2], [1, x3, y3]]))\n            \n            # B matrix\n            b1 = y2 - y3\n            b2 = y3 - y1\n            b3 = y1 - y2\n            c1 = x3 - x2\n            c2 = x1 - x3\n            c3 = x2 - x1\n            \n            B = (1.0 / (2.0 * area)) * np.array([\n                [b1, 0, b2, 0, b3, 0],\n                [0, c1, 0, c2, 0, c3],\n                [c1, b1, c2, b2, c3, b3]\n            ])\n\n            # Element stiffness matrix\n            Ke = thickness * area * (B.T @ D @ B)\n\n            # Assemble into global K\n            dofs = np.array([2*n for n in el_nodes for _ in range(2)]) + np.array([0,1]*len(el_nodes))\n            K[np.ix_(dofs, dofs)] += Ke\n\n        # --- Task 3: Verify Rigid Body Modes ---\n        norm_Kr1 = np.linalg.norm(K @ r1)\n        norm_Kr2 = np.linalg.norm(K @ r2)\n        norm_Kr3 = np.linalg.norm(K @ r3)\n        \n        # --- Define Load Vector f ---\n        f = np.zeros(num_dofs)\n        if case['load_type'] == 'equilibrated':\n            f[2 * 1 + 0] = 1.0  # +1 in x-dir at node 1 (1,0)\n            f[2 * 0 + 0] = -1.0 # -1 in x-dir at node 0 (0,0)\n        elif case['load_type'] == 'projected_random':\n            rng = np.random.default_rng(seed=1234) # Deterministic random\n            f_rand = rng.random(num_dofs)\n            # Project f_rand onto orthogonal complement of RBM space\n            f = f_rand - Q_rbm @ (Q_rbm.T @ f_rand)\n        elif case['load_type'] == 'uniform_downward':\n            for i in range(num_nodes):\n                f[2 * i + 1] = -1.0\n\n        # --- Task 4: Compute Minimum-Norm Solution and Residual ---\n        K_pinv = scipy.linalg.pinv(K)\n        u = K_pinv @ f\n        residual_norm = np.linalg.norm(K @ u - f)\n\n        # --- Task 5: Detect Load Projection on RBM Space ---\n        proj_mag = np.linalg.norm(Q_rbm.T @ f)\n        detection_flag = proj_mag > 1e-10\n        \n        # --- Collect Results for This Case ---\n        case_results = [\n            norm_Kr1,\n            norm_Kr2,\n            norm_Kr3,\n            residual_norm,\n            proj_mag,\n            str(detection_flag).lower()\n        ]\n        all_results.extend(case_results)\n\n    # --- Final Print ---\n    # Ensure raw float values are printed without scientific notation for small numbers\n    formatted_results = [f\"{x:.15e}\" if isinstance(x, float) else x for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3588944"}, {"introduction": "真实的地球物理系统，如地壳和岩石圈，通常处在由重力引起的巨大初始应力（即岩石静压力）之下。一个可靠的地球物理模拟器必须能够精确地再现这种静力平衡状态，其中由初始应力产生的内力必须与重力体力及边界上的压力精确抵消。这项练习 [@problem_id:3588957] 让你通过一个经典的静水平衡测试（hydrostatic balance test）来验证你的代码，你需要精确地计算与初始应力、重力和边界牵引力相关的力向量 $\\mathbf{f}_{\\sigma_0}$、$\\mathbf{f}_g$ 和 $\\mathbf{f}_t$，并确认在零位移时它们的合力为零。", "problem": "考虑一个二维垂直矩形域 $\\Omega = [0,W] \\times [0,H]$，它代表一个处于平面应变状态且平面外单位厚度的地球物理柱。设垂直坐标为 $z$，向下为正，顶边界位于 $z=0$，底边界位于 $z=H$。材料是线性弹性、均质、各向同性的，其杨氏模量为 $E$，泊松比为 $\\nu$。重力加速度为 $\\mathbf{g} = (0,g)$，其中 $g$ 为严格正值，单位为 $\\mathrm{m/s^2}$。质量密度是分层的，仅依赖于 $z$，是由水平层定义的的分段常数函数 $\\rho(z)$。\n\n假设小应变运动学、Cauchy 应力对称性和静态平衡（无惯性）。从线性动量平衡和任意容许虚位移场的平衡弱形式出发，推导所需的有限元表达式以：\n- 对于双线性四边形（四节点）单元，使用标准的双线性形函数并通过合适的高斯求积进行精确面积分，形成与重力相关的一致的单元体力荷载向量。\n- 形成与施加的初始应力场相关的单元内部节点力向量。初始应力场为静水（各向同性）应力，$\\boldsymbol{\\sigma}_0(z) = -p(z)\\,\\mathbf{I}$，其中压力 $p(z)$ 满足 $dp/dz = \\rho(z)\\,g$ 且 $p(H)=0$。根据给定的分层 $\\rho(z)$ 显式构造 $p(z)$。\n- 包括与静水初始应力一致的边界牵引力贡献，即在每个带有外单位法向量 $\\mathbf{n}$ 的边界段上，$\\mathbf{t}(z) = \\boldsymbol{\\sigma}_0(z)\\,\\mathbf{n}$。\n\n通过将 $\\Omega$ 划分为 $N_x \\times N_z$ 个轴对齐的双线性四边形单元来定义有限元网格，每个单元在母单元坐标 $(\\xi,\\eta)\\in[-1,1]^2$ 中具有标准的四节点参数化。使用平面应变和单位厚度。组装全局向量：\n- 通过在域上对体力 $\\rho(z)\\,\\mathbf{g}$ 与形函数进行积分，得到重力荷载向量 $\\mathbf{f}_g$。\n- 通过在域上对应变-位移矩阵的转置乘以 $\\boldsymbol{\\sigma}_0$ 进行积分，得到初始应力内力向量 $\\mathbf{f}_{\\sigma_0}$。\n- 通过沿所有域边界对静水牵引力进行积分，得到边界牵引力向量 $\\mathbf{f}_t$。\n\n使用组装好的向量，在零位移 $\\mathbf{u}_0 = \\mathbf{0}$ 处测试静水平衡。在一致的弱形式中，如果静水初始应力和重力精确平衡，则 $\\mathbf{u}_0=\\mathbf{0}$ 处的平衡要求全局残差\n$$\n\\mathbf{r}(\\mathbf{u}_0) = \\mathbf{f}_{\\sigma_0} - \\mathbf{f}_g - \\mathbf{f}_t\n$$\n为零向量。为每个测试案例计算 $\\mathbf{r}(\\mathbf{u}_0)$ 的无穷范数（最大绝对分量）。\n\n您必须根据以下要求实现完整的计算：\n- 在积分中使用精确的质量密度分层。如果任何单元跨越层界面，将其垂直积分划分为与密度层对齐的子区域，并在每个子区域中应用高斯求积。\n- 对面积分在每个参数化方向上使用双线性四边形单元和两点高斯求积，对一维边积分使用两点高斯求积。\n- 采用平面应变及平面外单位厚度。\n- 重力加速度以 $\\mathrm{m/s^2}$ 表示，弹性模量以 $\\mathrm{Pa}$ 表示，尺寸以 $\\mathrm{m}$ 表示，密度以 $\\mathrm{kg/m^3}$ 表示，力以 $\\mathrm{N}$ 表示。以 $\\mathrm{N}$ 为单位报告残差范数。\n\n测试套件：\n对于以下三组参数集，分别组装 $\\mathbf{f}_g$、$\\mathbf{f}_{\\sigma_0}$ 和 $\\mathbf{f}_t$，计算 $\\|\\mathbf{r}(\\mathbf{u}_0)\\|_\\infty$，并将三个结果以指定的最终格式作为单行输出。\n\n- 案例 A（均匀层，理想情况）：\n  - $W = 100\\,\\mathrm{m}$, $H = 1000\\,\\mathrm{m}$, $N_x = 2$, $N_z = 2$.\n  - $E = 3.0 \\times 10^{10}\\,\\mathrm{Pa}$, $\\nu = 0.25$, $g = 9.81\\,\\mathrm{m/s^2}$.\n  - 分层：一层 $[0,1000]$，密度 $\\rho = 2200\\,\\mathrm{kg/m^3}$。\n\n- 案例 B（两层，单元界面未对齐）：\n  - $W = 80\\,\\mathrm{m}$, $H = 900\\,\\mathrm{m}$, $N_x = 3$, $N_z = 3$.\n  - $E = 2.5 \\times 10^{10}\\,\\mathrm{Pa}$, $\\nu = 0.30$, $g = 9.81\\,\\mathrm{m/s^2}$.\n  - 分层：$[0,500]$ 密度 $\\rho = 2000\\,\\mathrm{kg/m^3}$ 和 $[500,900]$ 密度 $\\rho = 2500\\,\\mathrm{kg/m^3}$。\n\n- 案例 C（薄低密度层，边缘情况）：\n  - $W = 120\\,\\mathrm{m}$, $H = 1000\\,\\mathrm{m}$, $N_x = 4$, $N_z = 5$.\n  - $E = 3.5 \\times 10^{10}\\,\\mathrm{Pa}$, $\\nu = 0.20$, $g = 9.81\\,\\mathrm{m/s^2}$.\n  - 分层：$[0,300]$ 密度 $\\rho = 1800\\,\\mathrm{kg/m^3}$，$[300,305]$ 密度 $\\rho = 100\\,\\mathrm{kg/m^3}$，$[305,1000]$ 密度 $\\rho = 2600\\,\\mathrm{kg/m^3}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个残差范数，通过默认字符串转换进行四舍五入，格式为方括号内以逗号分隔的列表（例如，“[resultA,resultB,resultC]”），其中每个结果是一个浮点数，代表相应案例的 $\\|\\mathbf{r}(\\mathbf{u}_0)\\|_\\infty$（单位为 $\\mathrm{N}$）。", "solution": "该问题要求使用有限元法验证二维地球物理柱的静水平衡。通过计算残差力向量 $\\mathbf{r}(\\mathbf{u}_0)$ 来验证零位移时的平衡状态，对于精确解，该向量必须为零向量。问题指定了使用双线性四边形单元和高斯求积的特定数值实现，由于近似误差，我们预计残差会很小但非零。\n\n残差向量定义为 $\\mathbf{r}(\\mathbf{u}_0) = \\mathbf{f}_{\\sigma_0} - \\mathbf{f}_g - \\mathbf{f}_t$，其中 $\\mathbf{f}_g$ 是重力荷载向量，$\\mathbf{f}_{\\sigma_0}$ 是由初始静水应力产生的内力向量，$\\mathbf{f}_t$ 是与初始应力一致的边界牵引力向量。我们将对这些向量逐一进行公式化和计算。\n\n### 1. 理论框架\n\n**离散化**：将域 $\\Omega = [0,W] \\times [0,H]$ 离散化为 $N_x \\times N_z$ 个双线性四边形单元的网格。对于一个单元 $e$，几何和位移场使用从母单元 $(\\xi, \\eta) \\in [-1,1]^2$ 出发的等参映射，通过节点值进行插值。我们对物理单元采用标准的逆时针节点编号（1-2-3-4），从左上角开始，并将其映射到母单元的标准节点顺序（左下、右下、右上、左上），这给出了一个正的雅可比行列式 $\\det(\\mathbf{J}) = w_e h_e / 4$，其中 $w_e$ 和 $h_e$ 分别是单元的宽度和高度。\n\n**静水压力**：初始应力为静水应力，$\\boldsymbol{\\sigma}_0(z) = -p(z)\\mathbf{I}$，其中 $p(z)$ 是压力。在条件 $dp/dz = \\rho(z)g$ 和 $p(H)=0$ 下，任意深度 $z$ 处的压力是其下方材料柱的重量：\n$$\np(z) = \\int_z^H \\rho(s) g \\, ds\n$$\n由于密度 $\\rho(z)$ 是分段常数，因此 $p(z)$ 是一个关于 $z$ 的连续分段线性函数。\n\n**平衡弱形式**：在零位移（$\\mathbf{u}=\\mathbf{0}$，因此 $\\boldsymbol{\\sigma}=\\boldsymbol{\\sigma}_0$）下评估的虚功原理指出，内力必须与外力平衡：\n$$\n\\int_{\\Omega} \\mathbf{B}^T \\boldsymbol{\\sigma}_0 \\, d\\Omega = \\int_{\\Omega} \\mathbf{N}^T \\mathbf{b} \\, d\\Omega + \\int_{\\partial\\Omega} \\mathbf{N}^T \\mathbf{t} \\, d\\Gamma\n$$\n其中 $\\mathbf{N}$ 是形函数矩阵，$\\mathbf{B}$ 是应变-位移矩阵，$\\mathbf{b}=[0, \\rho(z)g]^T$ 是体力，$\\mathbf{t}$ 是边界牵引力。这三项分别对应于 $\\mathbf{f}_{\\sigma_0}$、$\\mathbf{f}_g$ 和 $\\mathbf{f}_t$。虽然在连续意义上通过精确积分这些项是相等的，但使用有限精度求积进行数值计算会引入差异。\n\n### 2. 单元力向量的公式化\n\n我们现在为组装过程公式化单元级向量。所有积分都使用指定的求积法则进行。关键挑战在于处理跨越密度层边界的单元。对于此类单元，在 $\\eta \\in [-1, 1]$ 上的垂直积分被分割成子区间，并对每个子区间应用高斯求积。\n\n**A. 重力荷载向量（$\\mathbf{f}_g^e$）**：\n单元局部节点 $i$ 上重力的 $z$ 分量为：\n$$\nf_{giz}^e = \\int_{\\Omega_e} N_i(x,z) \\rho(z) g \\, d\\Omega = g \\int_{-1}^1\\int_{-1}^1 N_i(\\xi, \\eta) \\rho(z(\\eta)) \\det(\\mathbf{J}) \\, d\\xi d\\eta\n$$\n对于双线性单元，对 $\\xi$ 进行解析积分可将其简化为：\n$$\nf_{giz}^e = g \\frac{w_e h_e}{8} \\int_{-1}^1 (1 + \\eta_i \\eta) \\rho(z(\\eta)) \\, d\\eta\n$$\n其中 $(\\xi_i, \\eta_i)$ 是节点 $i$ 的母单元坐标。剩余的一维积分进行数值计算。\n\n**B. 初始应力力向量（$\\mathbf{f}_{\\sigma_0}^e$）**：\n节点 $i$ 上由初始应力产生的内力为：\n$$\n\\mathbf{f}_{\\sigma_0,i}^e = \\int_{\\Omega_e} \\mathbf{B}_i^T \\boldsymbol{\\sigma}_0(z) \\, d\\Omega = \\int_{\\Omega_e} \\begin{bmatrix} -p(z) \\frac{\\partial N_i}{\\partial x} \\\\ -p(z) \\frac{\\partial N_i}{\\partial z} \\end{bmatrix} d\\Omega\n$$\n使用等参映射并对 $\\xi$ 进行解析积分可得：\n$$\nf_{\\sigma_0,ix}^e = -\\frac{\\xi_i h_e}{4} \\int_{-1}^1 (1 + \\eta_i \\eta) p(z(\\eta)) \\, d\\eta\n$$\n$$\nf_{\\sigma_0,iz}^e = -\\frac{\\eta_i w_e}{4} \\int_{-1}^1 p(z(\\eta)) \\, d\\eta\n$$\n这些一维积分进行数值计算。被积函数是线性函数（$N_i$）和分段线性函数（$p(z)$）的乘积，结果是分段二次函数，对此两点高斯求积并非精确。\n\n**C. 边界牵引力向量（$\\mathbf{f}_t^e$）**：\n牵引力 $\\mathbf{t} = \\boldsymbol{\\sigma}_0\\mathbf{n} = -p(z)\\mathbf{n}$ 施加在域边界上。\n-   **顶边界 ($z=0$)：** $\\mathbf{n}=(0,-1)$，因此 $\\mathbf{t}=(0, p(0))$。这贡献于节点力的 $z$ 分量。\n-   **左边界 ($x=0$)：** $\\mathbf{n}=(-1,0)$，因此 $\\mathbf{t}=(p(z), 0)$。这贡献于 $x$ 分量。\n-   **右边界 ($x=W$)：** $\\mathbf{n}=(1,0)$，因此 $\\mathbf{t}=(-p(z), 0)$。这也贡献于 $x$ 分量。\n-   **底边界 ($z=H$)：** $p(H)=0$，因此 $\\mathbf{t}=\\mathbf{0}$。\n对于位于垂直边界上的单元边，该边上节点 $j$ 的力通过一维积分计算，例如，在左边界上：\n$$\nf_{tx,j}^e = \\int_{z_{edge,1}}^{z_{edge,2}} N_j^{\\text{1D}}(z) p(z) \\, dz = \\frac{h_e}{2} \\int_{-1}^1 N_j^{\\text{1D}}(\\eta) p(z(\\eta)) \\, d\\eta\n$$\n这个一维积分包含一个分段二次被积函数，也使用两点高斯求积（在层边界处分割）进行评估，这会引入数值误差。\n\n### 3. 实现细节\n\n该实现遍历每个单元，计算三个单元级力向量（$\\mathbf{f}_g^e, \\mathbf{f}_{\\sigma_0}^e, \\mathbf{f}_t^e$），并将它们组装成全局向量。计算的核心是一个鲁棒的一维积分函数，它通过细分积分域并在每个子区间上应用两点高斯求积来处理分层介质。最后，计算全局残差 $\\mathbf{r}$，并报告其无穷范数 $\\|\\mathbf{r}\\|_\\infty$。非零结果量化了用两点高斯求积近似二次或更高阶多项式的积分所引入的不一致性。", "answer": "```python\nimport numpy as np\n\n# Global constants for 2-point Gauss quadrature\nGAUSS_POINTS = np.array([-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)])\nGAUSS_WEIGHTS = np.array([1.0, 1.0])\n\ndef solve():\n    \"\"\"\n    Main driver function to process all test cases defined in the problem.\n    \"\"\"\n    test_cases = [\n        # Case A: Uniform layer, happy path\n        {\n            \"W\": 100.0, \"H\": 1000.0, \"Nx\": 2, \"Nz\": 2, \"g\": 9.81,\n            \"layers\": [(0.0, 1000.0, 2200.0)],\n        },\n        # Case B: Two layers, non-aligned element interfaces\n        {\n            \"W\": 80.0, \"H\": 900.0, \"Nx\": 3, \"Nz\": 3, \"g\": 9.81,\n            \"layers\": [(0.0, 500.0, 2000.0), (500.0, 900.0, 2500.0)],\n        },\n        # Case C: Thin low-density layer, edge case\n        {\n            \"W\": 120.0, \"H\": 1000.0, \"Nx\": 4, \"Nz\": 5, \"g\": 9.81,\n            \"layers\": [\n                (0.0, 300.0, 1800.0),\n                (300.0, 305.0, 100.0),\n                (305.0, 1000.0, 2600.0),\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        residual_norm = compute_residual(**case)\n        results.append(residual_norm)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef create_pressure_function(H, g, layers):\n    \"\"\"\n    Creates a callable function p(z) for the hydrostatic pressure.\n    The pressure is pre-calculated at layer interfaces for efficiency.\n    \"\"\"\n    p_at_interface = {H: 0.0}\n    # Integrate from bottom to top\n    for i in range(len(layers) - 1, -1, -1):\n        z_start, z_end, rho = layers[i]\n        layer_overburden = rho * g * (z_end - z_start)\n        p_at_interface[z_start] = p_at_interface.get(z_end, 0.0) + layer_overburden\n\n    def p(z):\n        if z >= H: return 0.0\n        # Find the layer containing z\n        for z_start, z_end, rho in layers:\n            if z_start = z = z_end:\n                # Pressure is from layers below plus contribution from within the layer\n                return p_at_interface.get(z_end, 0.0) + rho * g * (z_end - z)\n        return 0.0  # Should be reached only for z=H\n\n    return p\n\ndef integrate_1d_layered(integrand_func, z_min, z_max, layers):\n    \"\"\"\n    Numerically integrates a 1D function over [z_min, z_max], splitting at layer boundaries.\n    The integration is transformed to parent coordinates eta in [-1, 1].\n    \"\"\"\n    h_e = z_max - z_min\n    z_c = z_min + h_e / 2.0\n    \n    eta_splits = [-1.0, 1.0]\n    for z_start, _, _ in layers:\n        if z_min  z_start  z_max:\n            eta_split = (z_start - z_c) / (h_e / 2.0)\n            eta_splits.append(eta_split)\n    eta_splits = sorted(list(set(eta_splits)))\n\n    total_integral = 0.0\n    for i in range(len(eta_splits) - 1):\n        eta_a, eta_b = eta_splits[i], eta_splits[i+1]\n        \n        # Map [eta_a, eta_b] to [-1, 1] for Gauss quadrature\n        transform = lambda zeta: 0.5 * (eta_b - eta_a) * zeta + 0.5 * (eta_a + eta_b)\n        jacobian_1d = 0.5 * (eta_b - eta_a)\n        \n        integral_piece = 0.0\n        for k in range(len(GAUSS_POINTS)):\n            eta_val = transform(GAUSS_POINTS[k])\n            z_val = z_c + (h_e / 2.0) * eta_val\n            integrand_val = integrand_func(eta_val, z_val)\n            integral_piece += GAUSS_WEIGHTS[k] * integrand_val\n        \n        total_integral += jacobian_1d * integral_piece\n        \n    return total_integral\n\ndef compute_element_vectors(x_min, z_min, w_e, h_e, g, layers, p_func, H, W, ix, iz, Nx, Nz):\n    \"\"\"\n    Computes and returns element-level force vectors fg, f_sigma0, and f_t.\n    \"\"\"\n    fg_e_z = np.zeros(4)\n    f_sigma0_e = np.zeros(8)\n    ft_e = np.zeros(8)\n\n    xi_eta_nodes = np.array([[-1, -1], [1, -1], [1, 1], [-1, 1]]) # Local node coords\n\n    def get_rho(z):\n        if z >= H: return layers[-1][2]\n        for z_start, z_end, rho_val in layers:\n            if z_start = z = z_end:\n                 return rho_val\n        raise ValueError(f\"Density not found for z={z}\")\n\n    # ===== 1. Gravity Load Vector f_g (z-components only) =====\n    for i in range(4):\n        _, eta_i = xi_eta_nodes[i]\n        def integrand_fg(eta, z): return g * get_rho(z) * (1.0 + eta_i * eta)\n        integral_val = integrate_1d_layered(integrand_fg, z_min, z_min + h_e, layers)\n        fg_e_z[i] = (w_e * h_e / 8.0) * integral_val\n\n    # ===== 2. Initial Stress Vector f_sigma0 =====\n    for i in range(4):\n        xi_i, eta_i = xi_eta_nodes[i]\n        # X-component\n        def integrand_x(eta, z): return (1.0 + eta_i * eta) * p_func(z)\n        integral_x = integrate_1d_layered(integrand_x, z_min, z_min + h_e, layers)\n        f_sigma0_e[2 * i] = - (xi_i * h_e / 4.0) * integral_x\n        \n        # Z-component\n        def integrand_z(eta, z): return p_func(z)\n        integral_z = integrate_1d_layered(integrand_z, z_min, z_min + h_e, layers)\n        f_sigma0_e[2 * i + 1] = - (eta_i * w_e / 4.0) * integral_z\n\n    # ===== 3. Boundary Traction Vector f_t =====\n    if iz == 0:  # Top boundary (z=0)\n        p0 = p_func(0.0)\n        ft_e[2*0 + 1] += p0 * w_e / 2.0  # Node 1 z-comp\n        ft_e[2*1 + 1] += p0 * w_e / 2.0  # Node 2 z-comp\n\n    if ix == 0:  # Left boundary (x=0)\n        def integrand_l1(eta, z): return p_func(z) * 0.5 * (1.0 - eta)\n        def integrand_l4(eta, z): return p_func(z) * 0.5 * (1.0 + eta)\n        ft_e[2*0] += (h_e/2.0) * integrate_1d_layered(integrand_l1, z_min, z_min+h_e, layers) # Node 1 x-comp\n        ft_e[2*3] += (h_e/2.0) * integrate_1d_layered(integrand_l4, z_min, z_min+h_e, layers) # Node 4 x-comp\n\n    if ix == Nx - 1:  # Right boundary (x=W)\n        def integrand_r2(eta, z): return -p_func(z) * 0.5 * (1.0 - eta)\n        def integrand_r3(eta, z): return -p_func(z) * 0.5 * (1.0 + eta)\n        ft_e[2*1] += (h_e/2.0) * integrate_1d_layered(integrand_r2, z_min, z_min+h_e, layers) # Node 2 x-comp\n        ft_e[2*2] += (h_e/2.0) * integrate_1d_layered(integrand_r3, z_min, z_min+h_e, layers) # Node 3 x-comp\n\n    return fg_e_z, f_sigma0_e, ft_e\n\ndef compute_residual(W, H, Nx, Nz, g, layers):\n    \"\"\"\n    Assembles global vectors and computes the infinity norm of the residual.\n    \"\"\"\n    dx, dz = W / Nx, H / Nz\n    num_nodes_x, num_nodes_z = Nx + 1, Nz + 1\n    num_dofs = 2 * num_nodes_x * num_nodes_z\n\n    f_g, f_sigma0, f_t = np.zeros(num_dofs), np.zeros(num_dofs), np.zeros(num_dofs)\n    p_func = create_pressure_function(H, g, layers)\n\n    for iz in range(Nz):\n        for ix in range(Nx):\n            x_min, z_min = ix * dx, iz * dz\n            \n            fg_e_z, f_sigma0_e, ft_e = compute_element_vectors(\n                x_min, z_min, dx, dz, g, layers, p_func, H, W, ix, iz, Nx, Nz)\n            \n            # Node indices (top-left, top-right, bottom-right, bottom-left)\n            node_indices = [\n                iz * num_nodes_x + ix,\n                iz * num_nodes_x + ix + 1,\n                (iz + 1) * num_nodes_x + ix + 1,\n                (iz + 1) * num_nodes_x + ix,\n            ]\n            # My local 0 (xi-1,eta-1) maps to physical top-left (i,j) for my choice of mapping\n            # My local 1 (xi+1,eta-1) maps to physical top-right (i+1,j)\n            # My local 2 (xi+1,eta+1) maps to physical bot-right (i+1,j+1)\n            # My local 3 (xi-1,eta+1) maps to physical bot-left (i,j+1)\n            # The local node order in xi_eta_nodes is (-1,-1), (1,-1), (1,1), (-1,1)\n            # This corresponds to my node_indices order.\n            \n            # Assemble\n            for i in range(4):\n                glob_idx = node_indices[i]\n                dof_x, dof_z = 2 * glob_idx, 2 * glob_idx + 1\n\n                f_g[dof_z] += fg_e_z[i]\n                \n                f_sigma0[dof_x] += f_sigma0_e[2 * i]\n                f_sigma0[dof_z] += f_sigma0_e[2 * i + 1]\n                \n                f_t[dof_x] += ft_e[2 * i]\n                f_t[dof_z] += ft_e[2 * i + 1]\n\n    residual = f_sigma0 - f_g - f_t\n    return np.max(np.abs(residual))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3588957"}, {"introduction": "在模拟如饱和多孔介质或地幔物质等近不可压缩材料时，标准有限元方法常会遇到“体积闭锁”（volumetric locking）的数值问题，导致结果过于僵硬。一种常见的解决方法是使用减缩积分（reduced integration），但这又可能引入被称为“沙漏模式”（hourglass modes）的非物理零能模式，使模型变得不稳定。这项高级实践 [@problem_id:3588945] 让你深入探索这一核心数值挑战，你将亲手实现减缩积分，分析其对刚度矩阵谱特性的影响，并设计一个稳定化方案来抑制沙漏模式，从而构建出在近不可压缩条件下既精确又稳健的高性能单元。", "problem": "考虑一个具有四个节点的单 isoparametric 双线性四边形单元，在平面应变条件下的二维小应变线性弹性问题。位移场由双线性形函数插值，材料近似不可压缩，其特征是泊松比接近 $0.5$。基本出发点是虚功原理以及相关的应变-位移关系和本构关系。您必须基于这些基础来推导单元刚度矩阵和载荷向量，检验减缩积分对单元刚度的影响，并设计一种能保持载荷一致性的、基于散度的稳定性方法。\n\n使用的基本原理如下：\n- 虚功原理：对于任意容许的虚位移场，内虚功等于外虚功。\n- 小应变运动学：无穷小应变张量是位移的对称梯度。\n- 平面应变条件下的线弹性本构定律。\n- 用于数值积分的 isoparametric 双线性插值和标准高斯求积。\n\n在以下设定下进行工作：\n- 几何：一个单一双线性四边形单元，其物理坐标 $(x,y)$ 节点为 $\\{(0,0),(1,0),(1,1),(0,1)\\}$，单位为米。在平面外方向使用单位厚度。单元域记为 $\\Omega_e$，其面积为 $|\\Omega_e|$。\n- 位移：节点位移向量 $d_e \\in \\mathbb{R}^8$，按 $[u_{1x},u_{1y},u_{2x},u_{2y},u_{3x},u_{3y},u_{4x},u_{4y}]^T$ 顺序排列，单位为米。\n- 材料：杨氏模量 $E$（帕斯卡），泊松比 $\\nu$（无量纲），由这些参数隐含平面应变本构矩阵。\n- 体力：恒定向量 $b = (b_x,b_y)$，单位为牛顿/立方米。\n- 求积：对于减缩积分刚度，使用位于单元中心的单个高斯点进行减缩积分；对于完全积分和稳定项，使用标准的 $2 \\times 2$ 高斯积分。\n- 稳定性设计参数：一个正标量 $\\tau$，选择与剪切模量成比例，以正则化零能模式，同时不污染不可压缩极限。\n\n需要完成的任务：\n1) 从虚功原理和小应变运动学出发，推导单元的减缩积分刚度矩阵 $K_e^{\\text{red}}$，该矩阵通过在单元中心的单个高斯点上计算双线性形式得到。确保使用等参映射和双线性形函数，在该高斯点构造应变-位移矩阵 $B(\\xi,\\eta)$，并使用平面应变本构矩阵 $C(E,\\nu)$。\n2) 使用相同的基础出发点，推导一个基于散度的稳定矩阵，其形式为\n$$\nK_{\\text{stab}} = \\tau \\int_{\\Omega_e} H^T H \\, d\\Omega,\n$$\n其中 $H$ 将节点位移映射到到位移散度，即对于节点位移 $d_e$，插值位移的散度为 $(\\nabla \\cdot u_h) = H d_e$。在一个求积点上，用双线性形函数的空间导数表示 $H$，并使用标准的 $2 \\times 2$ 高斯积分计算 $K_{\\text{stab}}$。指定一个在基本材料和几何尺度上量纲一致且不降低近似不可压缩极限的 $\\tau$ 的选择。\n3) 从虚功原理中具有恒定体力的外功项出发，推导一致节点体力向量\n$$\nf_e = \\int_{\\Omega_e} N^T b \\, d\\Omega,\n$$\n其中 $N$ 是将节点位移映射到场的双线性形函数矩阵。使用标准的 $2 \\times 2$ 高斯积分计算此向量，并解析验证对于此单位厚度和面积为 $|\\Omega_e|$ 的单元上的恒定 $b$ 值，该积分必须等于什么。\n4) 从第一性原理出发，解释为什么添加 $K_{\\text{stab}}$ 不需要修改一致体力向量来保持恒定体力的载荷一致性，以及为什么该稳定项不应对刚体运动引入伪功。\n5) 数值研究减缩积分和所提出的稳定项对刚度矩阵谱的影响，包括其零空间的维数以及移除刚体模式后的条件数。\n\n实现一个程序，对以下测试套件执行上述操作。使用指定的物理单位：长度为米，杨氏模量为帕斯卡，体力为牛顿/立方米。不涉及角度。当需要数值公差来判断一个特征值是否有效为零时，使用一个相对阈值，即数值低于最大量级特征值的 $10^{-8}$ 倍的值被视为零。\n\n参数值和测试套件：\n- 单元节点坐标：$(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$，单位为米。单位厚度。\n- 材料参数：$E = 10^6$ 帕斯卡，$\\nu = 0.4999$（无量纲）。\n- 稳定项缩放：选择 $\\tau = \\beta \\, \\mu \\, h^2$，其中 $\\mu$ 是由 $(E,\\nu)$ 在平面应变条件下隐含的剪切模量，而 $h = \\sqrt{|\\Omega_e|}$。使用 $\\beta = 1/3$（无量纲）。对于此单元， $|\\Omega_e| = 1$ 平方米，因此 $h = 1$ 米。\n- 用于载荷一致性检查的体力：$b = (3.2,-1.7)$ 牛顿/立方米。\n\n您的程序必须：\n- 组装并存储以下单元矩阵：\n  - $K_e^{\\text{red}}$ 使用单元中心的一点减缩积分。\n  - $K_e^{\\text{full}}$ 使用标准的 $2 \\times 2$ 高斯积分。\n  - $K_{\\text{stab}}$ 使用标准的 $2 \\times 2$ 高斯积分和所选的 $\\tau$。\n  - $K_e^{\\text{tot}} = K_e^{\\text{red}} + K_{\\text{stab}}$。\n- 使用 $2 \\times 2$ 高斯积分计算一致体力向量 $f_e$，并将其与在 $\\Omega_e$ 上恒定 $b$ 所隐含的解析值进行比较。\n- 计算以下定量输出：\n  1) 一个整数，等于 $K_e^{\\text{red}}$ 的特征值中低于有效零阈值的数量（零度）。\n  2) 一个整数，等于 $K_e^{\\text{tot}}$ 的特征值中低于有效零阈值的数量。\n  3) 一个浮点数，等于数值积分得到的 $f_e$ 与恒定体力 $b$ 的解析 $f_e$ 之间的最大分量绝对差。\n  4) 一个布尔值，指示 $f_e$ 中节点力分量的总和是否等于单元上的总体力，即 $\\sum_i (f_{e,ix}, f_{e,iy})$ 是否在相同的数值公差内等于 $(b_x |\\Omega_e|, b_y |\\Omega_e|)$。\n  5) 一个浮点数，等于 $K_e^{\\text{full}}$ 限制在其正谱上的条件数的 $\\log_{10}$ 值（最大正特征值除以最小正特征值）。\n  6) 一个浮点数，等于 $K_e^{\\text{tot}}$ 限制在其正谱上的条件数的 $\\log_{10}$ 值。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个方括号括起来的逗号分隔列表，按上述顺序列出结果。例如，生成形式为 $[r_1,r_2,r_3,r_4,r_5,r_6]$ 的输出，其中 $r_1$ 和 $r_2$ 是整数， $r_3$、$r_5$ 和 $r_6$ 是浮点数，$r_4$ 是布尔值。", "solution": "该问题要求对一个平面应变条件下的4节点四边形有限元进行全面的推导和数值实现，重点关注近似不可压缩性带来的挑战。我将首先建立理论框架，然后详细阐述所要求的具体推导和分析。\n\n### 1. 理论基础：虚功原理与有限元离散化\n\n固体力学有限元法的基础是虚功原理。对于一个占据域 $V$、边界为 $\\Gamma$、在体力 $b$ 和表面牵引力 $\\bar{t}$ 作用下处于平衡状态的物体，该原理指出，对于任何运动学容许的虚位移场 $\\delta u$，内虚功等于外虚功：\n$$\n\\delta W_{\\text{int}} = \\delta W_{\\text{ext}}\n$$\n$$\n\\int_V \\delta\\varepsilon^T \\sigma \\, dV = \\int_V \\delta u^T b \\, dV + \\int_{\\Gamma_t} \\delta u^T \\bar{t} \\, d\\Gamma\n$$\n这里，$\\sigma$ 是柯西应力张量，$\\varepsilon$ 是无穷小应变张量，两者均采用 Voigt 记法。虚应变为 $\\delta\\varepsilon$。对于小应变线弹性问题，本构关系为 $\\sigma = C \\varepsilon$，应变-位移关系为 $\\varepsilon = \\mathcal{L}u$，其中 $\\mathcal{L}$ 是一个微分算子。\n\n在有限元法中，域被离散为单元。在一个单元 $\\Omega_e$（体积为 $V_e$）内，位移场 $u$ 及其变分 $\\delta u$ 通过形函数矩阵 $N$ 从节点值 $d_e$ 和 $\\delta d_e$ 插值得到：\n$$\nu(x) = N(x) d_e \\quad \\text{和} \\quad \\delta u(x) = N(x) \\delta d_e\n$$\n然后，应变通过包含形函数空间导数的应变-位移矩阵 $B$ 与节点位移相关联：\n$$\n\\varepsilon(x) = B(x) d_e \\quad \\text{和} \\quad \\delta\\varepsilon(x) = B(x) \\delta d_e\n$$\n将这些代入单个单元的虚功方程（本问题忽略表面牵引力）可得：\n$$\n\\int_{V_e} (B \\delta d_e)^T C (B d_e) \\, dV = \\int_{V_e} (N \\delta d_e)^T b \\, dV\n$$\n由于 $\\delta d_e$ 是任意的，这导出了单元方程组 $K_e d_e = f_e$，其中单元刚度矩阵 $K_e$ 和一致节点力向量 $f_e$ 为：\n$$\nK_e = \\int_{V_e} B^T C B \\, dV \\quad \\text{和} \\quad f_e = \\int_{V_e} N^T b \\, dV\n$$\n对于单位厚度 $t=1$ 的二维问题，体积积分 $dV$ 变为面积积分 $d\\Omega$。积分在参考单元域 $(\\xi, \\eta) \\in [-1, 1]^2$ 上使用高斯求积进行数值计算：\n$$\nK_e = \\int_{-1}^1 \\int_{-1}^1 B(\\xi, \\eta)^T C B(\\xi, \\eta) \\det(J(\\xi, \\eta)) \\, t \\, d\\xi d\\eta\n$$\n其中 $J$ 是从参考坐标到物理坐标的等参映射的雅可比矩阵。\n\n### 2. Isoparametric 双线性单元\n\n该单元的节点位于 $\\{(0,0), (1,0), (1,1), (0,1)\\}$。从参考坐标 $(\\xi, \\eta)$ 到物理坐标 $(x,y)$ 的映射为 $x(\\xi, \\eta) = \\sum_i N_i(\\xi, \\eta) x_i$ 和 $y(\\xi, \\eta) = \\sum_i N_i(\\xi, \\eta) y_i$。对于给定的节点，这导致了仿射映射 $x = \\frac{1}{2}(1+\\xi)$ 和 $y = \\frac{1}{2}(1+\\eta)$。该映射的雅可比矩阵是常数：\n$$\nJ = \\begin{pmatrix} \\partial x / \\partial \\xi  \\partial y / \\partial \\xi \\\\ \\partial x / \\partial \\eta  \\partial y / \\partial \\eta \\end{pmatrix} = \\begin{pmatrix} 1/2  0 \\\\ 0  1/2 \\end{pmatrix}\n$$\n其行列式为 $\\det(J) = 1/4$。形函数 $N_i$ 的空间导数使用逆雅可比矩阵求得：$\\begin{pmatrix} N_{i,x} \\\\ N_{i,y} \\end{pmatrix} = J^{-1} \\begin{pmatrix} N_{i,\\xi} \\\\ N_{i,\\eta} \\end{pmatrix}$。\n\n### 3. 任务1：减缩积分刚度矩阵 $K_e^{\\text{red}}$\n\n刚度矩阵为 $K_e = \\int_{\\Omega_e} B^T C B \\, d\\Omega$。平面应变本构矩阵 $C$ 由下式给出：\n$$\nC = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{pmatrix} 1-\\nu  \\nu  0 \\\\ \\nu  1-\\nu  0 \\\\ 0  0  \\frac{1-2\\nu}{2} \\end{pmatrix}\n$$\n应变-位移矩阵 $B(\\xi, \\eta)$ 是一个 $3 \\times 8$ 的矩阵，由形函数的空间导数构成。对于节点 $i$，相应的列为 $B_i = [ \\begin{smallmatrix} N_{i,x}  0 \\\\ 0  N_{i,y} \\\\ N_{i,y}  N_{i,x} \\end{smallmatrix} ]$。\n\n减缩积分在单元中心 $(\\xi, \\eta) = (0, 0)$ 使用单个高斯点，权重为 $w=4$（对于 $[-1,1]^2$ 域）。刚度矩阵积分简化为单点计算：\n$$\nK_e^{\\text{red}} = \\left. B^T C B \\right|_{(\\xi, \\eta)=(0,0)} \\cdot |\\Omega_e|\n$$\n其中 $|\\Omega_e| = \\int_{-1}^1\\int_{-1}^1 \\det(J) \\, d\\xi d\\eta = 1/4 \\cdot 4 = 1$。在 $(\\xi, \\eta) = (0,0)$ 处，B 所需的所有形函数空间导数矩阵为：\n$$\n\\left[ \\{N_{i,x}\\}_{i=1}^4, \\{N_{i,y}\\}_{i=1}^4 \\right]_{(0,0)} = \\frac{1}{2}\\begin{bmatrix} -1  1  1  -1 \\\\ -1  -1  1  1 \\end{bmatrix}\n$$\n这定义了 $B(0,0)$，然后用它与材料矩阵 $C$ 一起计算 $K_e^{\\text{red}}$。\n\n### 4. 任务2：基于散度的稳定矩阵 $K_{\\text{stab}}$\n\n为了抵消减缩积分引入的伪零能（“沙漏”）模式，在虚功公式中增加一个稳定项：\n$$\n\\delta W_{\\text{stab}} = \\int_{V_e} \\tau (\\nabla \\cdot \\delta u_h) (\\nabla \\cdot u_h) \\, dV\n$$\n插值位移场 $u_h$ 的散度为 $\\nabla \\cdot u_h = \\sum_i (N_{i,x} u_{ix} + N_{i,y} u_{iy})$。这可以写成 $(\\nabla \\cdot u_h) = H d_e$，其中 $H$ 是 $1 \\times 8$ 的行向量：\n$$\nH(\\xi, \\eta) = [N_{1,x}, N_{1,y}, N_{2,x}, N_{2,y}, N_{3,x}, N_{3,y}, N_{4,x}, N_{4,y}]\n$$\n因此，稳定矩阵为：\n$$\nK_{\\text{stab}} = \\int_{V_e} \\tau H^T H \\, dV = \\tau \\int_{\\Omega_e} H^T H \\, t \\, d\\Omega\n$$\n该积分使用标准的 $2 \\times 2$ 高斯求积进行计算。\n\n稳定参数 $\\tau$ 被指定为 $\\tau = \\beta \\mu h^2$。给定 $\\beta=1/3$，$h=\\sqrt{|\\Omega_e|}=1 \\text{ m}$，以及剪切模量 $\\mu = E/(2(1+\\nu))$，这得出 $\\tau = \\frac{1}{3}\\mu$。必须注意，问题中给出的公式 $\\tau = \\beta \\mu h^2$ 在量纲上是不一致的。在这种公式中，稳定参数 $\\tau$ 必须具有压力单位（帕斯卡），就像剪切模量 $\\mu$ 一样。$h^2$ 项引入了一个额外的长度平方因子。然而，由于问题指定 $h=1$ 米，所使用的数值 $\\tau = \\beta \\mu$ 在物理和量纲上是合理的。\n\n### 5. 任务3：一致体力向量 $f_e$\n\n一致节点力向量源于体力 $b=(b_x, b_y)$ 的外虚功：\n$$\nf_e = \\int_{V_e} N^T b \\, dV = t \\int_{\\Omega_e} N^T b \\, d\\Omega\n$$\n其中 $N$ 是 $2 \\times 8$ 的形函数矩阵。对于恒定的体力 $b$，节点 $i$ 上的力 $f_{ei} = b \\cdot t \\int_{\\Omega_e} N_i \\, d\\Omega$ 的积分可以解析计算。单个双线性形函数在单元面积上的积分为 $\\int_{\\Omega_e} N_i d\\Omega = |\\Omega_e|/4$。因此，对于单位正方形单元（$|\\Omega_e|=1, t=1$），每个节点均分总力：$f_{ei} = b/4$。总力向量为 $f_e = [b_x/4, b_y/4, \\dots, b_x/4, b_y/4]^T$。$2 \\times 2$ 求积足以精确积分线性形函数，因此数值结果应与解析结果在机器精度内匹配。\n\n### 6. 任务4：载荷一致性与刚体运动\n\n稳定项被添加到内虚功中，从而修改了平衡方程的刚度部分。导出载荷向量 $f_e$ 的外虚功项保持不变。这种分离确保了作为内部惩罚的稳定项不会改变外部物理载荷的表示。因此，为了保持载荷一致性，不需要对 $f_e$ 进行修改。\n\n一个有效的稳定项不能惩罚刚体运动，因为它们是无应变的变形。二维刚体运动（2个平移，1个旋转）的散度均为零（$\\nabla \\cdot u_{RBM} = 0$）。由于稳定项与 $(\\nabla \\cdot u_h)^2$ 成正比，它对于任何刚体运动都恒等于零。因此，矩阵 $K_{\\text{stab}}$ 不会对这些模式施加任何伪力或能量惩罚，正确地将它们保留在单元刚度矩阵的零空间中。这可以通过注意到如果 $d_{RBM}$ 是刚体运动的节点向量，则 $H d_{RBM} = 0$，因此 $K_{stab} d_{RBM} = (\\tau \\int H^T H d\\Omega)d_{RBM} = 0$ 来证明。\n\n### 7. 任务5：数值研究计划\n\n所提供的 Python 代码将计算执行先前的理论步骤。它将：\n1.  组装完全积分的刚度矩阵 $K_e^{\\text{full}}$、减缩积分矩阵 $K_e^{\\text{red}}$ 和稳定矩阵 $K_{\\text{stab}}$。\n2.  形成最终的稳定刚度矩阵 $K_e^{\\text{tot}} = K_e^{\\text{red}} + K_{\\text{stab}}$。\n3.  计算一致载荷向量 $f_e$。\n4.  对 $K_e^{\\text{red}}$ 和 $K_e^{\\text{tot}}$ 进行特征值分析，以确定它们的零度。我们期望 $K_e^{\\text{red}}$ 的零度为 5（3个刚体模式 + 2个沙漏模式），而 $K_e^{\\text{tot}}$ 的零度为 3（稳定项消除了沙漏模式）。\n5.  计算 $K_e^{\\text{full}}$ 和 $K_e^{\\text{tot}}$ 的正定部分的条件数。我们期望由于体积自锁，$K_e^{\\text{full}}$ 是病态的，而 $K_e^{\\text{tot}}$ 的条件数应显著更优。\n6.  验证计算出的载荷向量 $f_e$ 相对于其解析值的准确性，并检查总力的守恒性。\n\n这项数值研究的结果将为减缩积分和稳定项在近似不可压缩极限下对单元性能的影响提供定量的见解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the FEM problem for a single bilinear quadrilateral element as specified.\n    \"\"\"\n    # Parameter values and test suite\n    E = 1.0e6  # Young's modulus in Pascals\n    nu = 0.4999  # Poisson's ratio (dimensionless)\n    b_vec = np.array([3.2, -1.7])  # Body force in N/m^3\n    beta = 1.0 / 3.0  # Stabilization coefficient\n    \n    # Element Geometry\n    # node_coords = np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]])\n    thickness = 1.0  # Unit thickness in meters\n    area = 1.0  # Area in square meters\n    h = np.sqrt(area)  # Characteristic length in meters\n\n    # Material properties\n    # Plane strain constitutive matrix\n    C_factor = E / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    C = C_factor * np.array([\n        [1.0 - nu, nu, 0.0],\n        [nu, 1.0 - nu, 0.0],\n        [0.0, 0.0, (1.0 - 2.0 * nu) / 2.0]\n    ])\n    \n    # Shear modulus and stabilization parameter\n    mu = E / (2.0 * (1.0 + nu))\n    # Using the formula from the problem statement: tau = beta * mu * h^2\n    # Since h=1, this is numerically equivalent to tau = beta * mu.\n    tau = beta * mu * h**2\n\n    # Quadrature rules\n    # 2x2 Gauss Quadrature for [-1, 1] x [-1, 1]\n    gp_val = 1.0 / np.sqrt(3.0)\n    gauss_pts_2x2 = [(-gp_val, -gp_val), (gp_val, -gp_val),\n                     (gp_val, gp_val), (-gp_val, gp_val)]\n    gauss_w_2x2 = [1.0, 1.0, 1.0, 1.0]\n\n    # Shape functions and their derivatives in the reference element\n    def get_shape_info(xi, eta):\n        N = 0.25 * np.array([(1 - xi) * (1 - eta),\n                             (1 + xi) * (1 - eta),\n                             (1 + xi) * (1 + eta),\n                             (1 - xi) * (1 + eta)])\n        \n        dNdxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n        dNdeta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n        \n        return N, dNdxi, dNdeta\n\n    # Jacobian is constant for this specific geometry (unit square)\n    # Mapping: x = 0.5*(1+xi), y = 0.5*(1+eta)\n    J = np.array([[0.5, 0.0], [0.0, 0.5]])\n    detJ = np.linalg.det(J)\n    invJ = np.linalg.inv(J)\n\n    def get_B_and_H_matrices(dNdxi, dNdeta):\n        B = np.zeros((3, 8))\n        H = np.zeros(8)\n        for i in range(4):\n            dNd_phys = invJ @ np.array([dNdxi[i], dNdeta[i]])\n            dNdx_i, dNdy_i = dNd_phys[0], dNd_phys[1]\n            \n            # Strain-displacement matrix B for node i\n            B[0, 2 * i] = dNdx_i\n            B[1, 2 * i + 1] = dNdy_i\n            B[2, 2 * i] = dNdy_i\n            B[2, 2 * i + 1] = dNdx_i\n            \n            # Divergence operator H for node i\n            H[2 * i] = dNdx_i\n            H[2 * i + 1] = dNdy_i\n            \n        return B, H\n\n    # Assemble K_full, K_stab, and f_e using 2x2 quadrature\n    K_full = np.zeros((8, 8))\n    K_stab = np.zeros((8, 8))\n    f_e = np.zeros(8)\n\n    for i in range(len(gauss_pts_2x2)):\n        xi, eta = gauss_pts_2x2[i]\n        w = gauss_w_2x2[i]\n        \n        N, dNdxi, dNdeta = get_shape_info(xi, eta)\n        B, H = get_B_and_H_matrices(dNdxi, dNdeta)\n        \n        K_full += B.T @ C @ B * detJ * w * thickness\n        K_stab += tau * np.outer(H, H) * detJ * w * thickness\n        \n        # Consistent load vector contribution\n        N_mat = np.zeros((2, 8))\n        for j in range(4):\n            N_mat[0, 2 * j] = N[j]\n            N_mat[1, 2 * j + 1] = N[j]\n        f_e += N_mat.T @ b_vec * detJ * w * thickness\n\n    # Assemble K_red using 1-point quadrature\n    xi_red, eta_red = 0.0, 0.0\n    _, dNdxi_red, dNdeta_red = get_shape_info(xi_red, eta_red)\n    B_red, _ = get_B_and_H_matrices(dNdxi_red, dNdeta_red)\n    K_red = B_red.T @ C @ B_red * area * thickness\n\n    # Total stabilized stiffness matrix\n    K_tot = K_red + K_stab\n    \n    # --- Perform Numerical Analysis ---\n\n    # 1. Nullity of K_red\n    e_vals_red = np.linalg.eigvalsh(K_red)\n    lambda_max_red = np.max(np.abs(e_vals_red))\n    tol_red = 1e-8 * lambda_max_red if lambda_max_red > 1e-15 else 1e-8\n    nullity_red = np.sum(np.abs(e_vals_red)  tol_red)\n    \n    # 2. Nullity of K_tot\n    e_vals_tot = np.linalg.eigvalsh(K_tot)\n    lambda_max_tot = np.max(np.abs(e_vals_tot))\n    tol_tot = 1e-8 * lambda_max_tot if lambda_max_tot > 1e-15 else 1e-8\n    nullity_tot = np.sum(np.abs(e_vals_tot)  tol_tot)\n\n    # 3. Maximum absolute difference in force vector\n    f_analytic = np.tile(b_vec * area * thickness / 4.0, 4)\n    f_diff = np.max(np.abs(f_e - f_analytic))\n\n    # 4. Consistency of total nodal force\n    sum_f_num = np.array([np.sum(f_e[0::2]), np.sum(f_e[1::2])])\n    sum_f_analytic = b_vec * area * thickness\n    is_consistent = np.allclose(sum_f_num, sum_f_analytic, rtol=1e-8, atol=1e-9)\n\n    # Helper for condition number calculation\n    def get_log10_cond(matrix, tol_factor=1e-8):\n        e_vals = np.linalg.eigvalsh(matrix)\n        lambda_max = np.max(e_vals)\n        tol = tol_factor * lambda_max if lambda_max > 1e-15 else tol_factor\n        positive_eigs = e_vals[e_vals > tol]\n        if len(positive_eigs) == 0:\n            return np.inf\n        return np.log10(np.max(positive_eigs) / np.min(positive_eigs))\n\n    # 5. Log10 condition number of K_full\n    cond_full_log10 = get_log10_cond(K_full)\n    \n    # 6. Log10 condition number of K_tot\n    cond_tot_log10 = get_log10_cond(K_tot)\n\n    # --- Format and Print Final Output ---\n    results = [\n        int(nullity_red), \n        int(nullity_tot), \n        float(f_diff), \n        bool(is_consistent), \n        float(cond_full_log10), \n        float(cond_tot_log10)\n    ]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3588945"}]}