{"hands_on_practices": [{"introduction": "在构建大型有限元全局矩阵之前，一个关键的计算步骤是为其高效分配内存。这需要预先确定矩阵的稀疏模式。本练习将指导你推导出一个公式，用于计算结构化三维网格中每行非零元素的数量，这是构建高性能有限元求解器（例如使用压缩稀疏行 (CSR) 格式）的基础。这个过程相当于在填充实际数值之前，为全局矩阵搭建起计算的“脚手架”。[@problem_id:3600273]", "problem": "您的任务是设计一个算法并实现一个可运行的程序，用于为计算地球物理学中使用的、在结构化六面体网格上的三维高阶 $Q_p$ 有限元所产生的全局刚度矩阵预分配压缩稀疏行（CSR）存储空间。目标是在不构造矩阵元素本身的情况下，计算全局矩阵的逐行非零元数量，并基于单元重叠和基函数的局部性，从第一性原理出发论证该算法的复杂度。\n\n从以下基础出发：\n\n- 用于求解标量二阶椭圆算子（例如，$-\\nabla \\cdot (\\kappa \\nabla u) = f$ 并附带适当的边界条件）的 Galerkin 有限元方法会生成一个全局稀疏矩阵，其元素是通过对各单元贡献求和得到的。全局自由度 $I$ 和 $J$ 之间的矩阵元素为非零，当且仅当存在至少一个单元，使得与这两个自由度对应的基函数的支集在该单元上发生重叠，并产生一个非零的双线性形式。\n- 在三维空间中，一个节点型 $Q_p$ 单元每个单元拥有 $(p+1)^3$ 个局部自由度，并且每个基函数的支集被限制在包含其节点的单元内。\n- 在一个沿三个坐标轴方向分别有 $n_x$、$n_y$ 和 $n_z$ 个单元的结构化网格中，全局节点网格在各坐标轴上分别有 $N_x = n_x p + 1$、$N_y = n_y p + 1$ 和 $N_z = n_z p + 1$ 个节点。全局节点索引是三元组 $(i,j,k)$，其中 $i \\in \\{0,\\dots,N_x-1\\}$，$j \\in \\{0,\\dots,N_y-1\\}$，$k \\in \\{0,\\dots,N_z-1\\}$。\n\n仅基于以上基础，推导一个公式，用于计算与全局节点 $(i,j,k)$ 相关联的全局矩阵行中的非零元数量，该公式需用每个坐标方向上的关联单元数量来表示。得出一个以 $p$ 和各方向局部关联单元重数表示的封闭形式表达式。然后，设计一个算法，通过遍历所有全局节点并应用推导出的公式，来计算 CSR 的行指针数组和非零元总数，而无需显式构建邻接集。最后，以 $n_x$、$n_y$、$n_z$ 和 $p$ 的函数形式，使用 $\\mathcal{O}$ 符号论证算法的复杂度。\n\n实现要求：\n\n- 您必须实现一个程序，对每个测试用例，计算以下内容：\n    - 全局矩阵中的非零元总数 $nnz$，\n    - 单行最大非零元数量，\n    - 单行最小非零元数量，\n    - 一个布尔一致性标志，如果封闭形式的行计数与在一组固定的、确定性的样本行上进行的直接单元并集枚举结果一致，则该标志为真。\n- 您不得构造全局矩阵的元素或完整的列索引数组；仅需预分配计数和 CSR 行指针的长度。\n\n测试套件：\n\n在以下参数集 $(n_x,n_y,n_z,p)$ 上评估您的实现：\n\n- 用例 $1$：$(n_x,n_y,n_z,p) = (1,1,1,4)$。\n- 用例 $2$：$(n_x,n_y,n_z,p) = (2,2,2,3)$。\n- 用例 $3$：$(n_x,n_y,n_z,p) = (10,1,1,1)$。\n- 用例 $4$：$(n_x,n_y,n_z,p) = (3,2,1,5)$。\n\n输出规范：\n\n- 您的程序应产生单行输出，其中包含四个用例的结果，格式为一个由逗号分隔的列表组成的列表，并用方括号括起来。每个内部列表的形式必须是 $[nnz,\\max\\_row,\\min\\_row,consistency]$，其中 $nnz$、$\\max\\_row$ 和 $\\min\\_row$ 是整数，$consistency$ 是布尔值。例如，输出格式必须与 $[[nnz_1,\\max\\_1,\\min\\_1,consistency_1],[nnz_2,\\max\\_2,\\min\\_2,consistency_2],[nnz_3,\\max\\_3,\\min\\_3,consistency_3],[nnz_4,\\max\\_4,\\min\\_4,consistency_4]]$ 完全一致。\n\n本任务不涉及物理单位、角度单位或百分比；所有输出均为无单位的整数或布尔值。您的算法和程序必须具有通用性，并且仅依赖于从基函数局部性和单元重叠的原理推导。特别是，您对复杂度的论证必须基于以下事实：一个全局自由度 $(i,j,k)$ 与包含节点 $(i,j,k)$ 的所有单元的并集内的所有自由度耦合，并且该并集的大小由每个坐标方向上的重叠重数决定。", "solution": "在有限元方法（FEM）模拟中，为稀疏矩阵预分配存储空间是提高计算效率的关键步骤。我们的任务是确定一个在结构化网格上使用 $Q_p$ 六面体单元离散的三维问题的全局刚度矩阵每行的非零元（$nnz$）数量。这使得我们可以在不实际组装矩阵的情况下，构造压缩稀疏行（CSR）的`row_pointer`数组。\n\n### 基本原理\n\n在有限元方法的背景下，全局刚度矩阵 $\\mathbf{K}$ 由单元级刚度矩阵 $\\mathbf{k}^e$ 组装而成。全局矩阵中对应于全局自由度（DoFs）$I$ 和 $J$ 的元素 $K_{IJ}$ 为非零，当且仅当与这些自由度关联的基函数 $\\phi_I$ 和 $\\phi_J$ 的支集重叠且它们的相互作用积分为非零。对于标准的节点型 $Q_p$ 单元，基函数 $\\phi_I$ 的支集是共享节点 $I$ 的所有单元的并集。源于像拉普拉斯算子这样的二阶椭圆算子的相互作用积分，在节点 $I$ 和 $J$ 属于至少一个共同单元时为非零。因此，与自由度 $I$ 耦合的自由度集合（即第 $I$ 行的非零元）对应于包含在与节点 $I$ 关联的所有单元的并集内的所有唯一自由度的集合。\n\n### 行非零元计数公式的推导\n\n设计算域由一个 $n_x \\times n_y \\times n_z$ 的六面体单元结构化网格离散。对于 $Q_p$ 单元（其中 $p$ 为多项式次数），每个单元的每条边上有 $p+1$ 个节点。这会形成一个包含 $N = N_x \\times N_y \\times N_z$ 个节点的全局网格，其中 $N_x = n_x p + 1$，$N_y = n_y p + 1$，$N_z = n_z p + 1$。每个全局节点对应一个唯一的自由度，由三元组 $(i, j, k)$ 索引，其中 $i \\in \\{0, \\dots, N_x-1\\}$，$j \\in \\{0, \\dots, N_y-1\\}$，$k \\in \\{0, \\dots, N_z-1\\}$。\n\n对应于节点 $(i,j,k)$ 的行中的非零元数量，记作 $R(i,j,k)$，是围绕节点 $(i,j,k)$ 的单元片（patch）中唯一节点的总数。该单元片的大小和形状取决于节点相对于单元边界的位置。\n\n一个关键的洞见是，由于结构化网格和 $Q_p$ 基函数都具有张量积的性质，该问题可以按坐标方向解耦。让我们定义 $m_x(i)$、$m_y(j)$ 和 $m_z(k)$ 为节点 $(i,j,k)$ 在各个方向上所关联的单元“层”数。\n\n1.  **在一个方向上的重数（例如 x 方向）：** 全局 x 索引为 $i$ 的节点，如果其索引不是 $p$ 的倍数，则它位于单元块的内部（沿 x 轴）。如果 $i$ 是 $p$ 的倍数（即，对于某个整数 $q$，$i = q \\cdot p$）且它不在全局域的边界上（即 $0  i  N_x-1$），那么它位于两个相邻单元之间的界面上。\n    - 内部单元界面的 x 索引为 $\\{p, 2p, \\dots, (n_x-1)p\\}$。\n    - 因此，如果 $i$ 是一个内部界面索引，则重数 $m_x(i)$ 为 $2$，否则为 $1$。\n    $$ m_x(i) = \\begin{cases} 2  \\text{ if } i \\in \\{p, 2p, \\dots, (n_x-1)p\\} \\\\ 1  \\text{ otherwise} \\end{cases} $$\n    类似的定义适用于 $m_y(j)$ 和 $m_z(k)$（分别相对于 $n_y, p$ 和 $n_z, p$）。\n\n2.  **耦合节点片：** 一个节点 $(i,j,k)$ 关联一个由 $m_x(i) \\times m_y(j) \\times m_z(k)$ 个单元组成的单元片。这个单元片形成一个“宏单元”。这个宏单元中节点的总数决定了行的非零元数量。\n\n3.  **对单元片中的节点计数：** 在一维中，一个由 $m_x(i)$ 个相邻单元组成的单元片跨越 $m_x(i) \\cdot p + 1$ 个节点。通过张量积结构将其扩展到三维，与节点 $(i,j,k)$ 关联的单元片中的唯一节点总数，是每个方向上所跨越节点数量的乘积。\n\n这就得到了节点 $(i,j,k)$ 所在行的非零元数量的封闭形式表达式：\n$$ R(i,j,k) = (m_x(i)p + 1) \\cdot (m_y(j)p + 1) \\cdot (m_z(k)p + 1) $$\n\n例如，一个深处于单元内部且不位于任何单元边界上的节点，其 $(m_x, m_y, m_z) = (1,1,1)$，得到 $R=(p+1)^3$ 个非零元（即该单个单元的所有节点）。一个位于八个内部单元共享顶点处的节点，其 $(m_x, m_y, m_z) = (2,2,2)$，得到 $R=(2p+1)^3$ 个非零元。该公式能正确处理所有情况，包括位于全局域边界上的节点，其相应的重数始终为 $1$。\n\n### 算法设计与复杂度分析\n\n该算法利用推导出的公式来计算所需的度量指标，而无需构建任何显式的邻接信息。\n\n1.  **初始化：** 给定参数 $(n_x, n_y, n_z, p)$，计算全局节点网格维度 $N_x, N_y, N_z$。为每个方向预先计算界面索引集，以实现高效查找。初始化 `total_nnz`、`max_row_count` 和 `min_row_count`。\n\n2.  **迭代：** 遍历从 $(0,0,0)$ 到 $(N_x-1, N_y-1, N_z-1)$ 的每个全局节点 $(i,j,k)$。在每次迭代中：\n    a. 通过检查索引 $i,j,k$ 是否属于预先计算的界面集来确定重数 $m_x(i)$、$m_y(j)$、$m_z(k)$。这是一个 $\\mathcal{O}(1)$ 操作。\n    b. 应用公式计算该行的非零元数量 $R(i,j,k)$。\n    c. 将此计数加到 `total_nnz` 上，并更新 `max_row_count` 和 `min_row_count`。\n\n3.  **一致性检查：** 为了验证公式，在一个固定的、确定性的节点样本上使用直接枚举法。对于一个样本节点 $(i,j,k)$：\n    a. 识别出关联的单元块，其大小为 $m_x(i) \\times m_y(j) \\times m_z(k)$。\n    b. 显式生成包含在该单元块内的所有唯一节点索引的集合。\n    c. 该集合的大小即为 `direct_count`。\n    d. 将 `direct_count` 与 `formula_count` 进行比较。如果任何样本节点的计数值不匹配，则将一致性标志设置为 `False`。\n\n4.  **复杂度分析：** 主要的计算开销在于遍历所有全局节点的三重嵌套循环。节点总数为 $N = N_x N_y N_z = (n_x p + 1)(n_y p + 1)(n_z p + 1)$。在循环内部，所有操作都是 $\\mathcal{O}(1)$ 的。因此，算法的时间复杂度与总自由度数呈线性关系：\n    $$ \\mathcal{O}(N) = \\mathcal{O}((n_x p + 1)(n_y p + 1)(n_z p + 1)) $$\n    对于 $n_x, n_y, n_z \\gg 1$ 的大型网格，这可以简化为 $\\mathcal{O}(n_x n_y n_z p^3)$。一致性检查是在一个小的、常数数量的样本上执行的，其每个样本的复杂度为 $\\mathcal{O}(p^3)$，这不会改变总体的渐近复杂度。\n\n这种方法为预分配组装全局刚度矩阵所需的 CSR 数据结构提供了一种高效且理论上可靠的方法。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main entry point to solve the problem for all specified test cases.\n    \"\"\"\n    test_cases = [\n        (1, 1, 1, 4),\n        (2, 2, 2, 3),\n        (10, 1, 1, 1),\n        (3, 2, 1, 5),\n    ]\n\n    case_results = []\n    for case in test_cases:\n        nnz, max_r, min_r, cons = solve_case(*case)\n        # Format each result as '[nnz,max_r,min_r,Consistency]'\n        case_results.append(f\"[{nnz},{max_r},{min_r},{cons}]\")\n\n    # Final output must be a single line in the specified format.\n    print(f\"[{','.join(case_results)}]\")\n\n\ndef solve_case(nx, ny, nz, p):\n    \"\"\"\n    Computes CSR pre-allocation data for a single set of parameters.\n\n    Args:\n        nx (int): Number of elements along the x-axis.\n        ny (int): Number of elements along the y-axis.\n        nz (int): Number of elements along the z-axis.\n        p (int): Polynomial degree of the Qp elements.\n\n    Returns:\n        tuple: (total_nnz, max_row_count, min_row_count, is_consistent)\n    \"\"\"\n    if p == 0:  # Gracefully handle Q0 elements, though problem implies p=1\n        # For Q0, each element is typically one DoF. The global matrix would\n        # be diagonal if using a Discontinuous Galerkin method. Assuming\n        # cell-centered DoFs with no coupling for simplicity.\n        num_dof = nx * ny * nz\n        return num_dof, 1, 1, True\n\n    # Calculate global grid dimensions\n    Nx = nx * p + 1\n    Ny = ny * p + 1\n    Nz = nz * p + 1\n\n    # Define sets of interface indices for O(1) average time lookup\n    interfaces_x = {k * p for k in range(1, nx)}\n    interfaces_y = {k * p for k in range(1, ny)}\n    interfaces_z = {k * p for k in range(1, nz)}\n\n    total_nnz = 0\n    max_row_count = 0\n    # Initialize min_row_count to a value guaranteed to be larger than any possible count\n    min_row_count = (2 * p + 1)**3 + 1\n\n    # Main loop to compute metrics by iterating over all global nodes\n    for i in range(Nx):\n        for j in range(Ny):\n            for k in range(Nz):\n                # Determine multiplicities based on node position\n                m_x = 2 if i in interfaces_x else 1\n                m_y = 2 if j in interfaces_y else 1\n                m_z = 2 if k in interfaces_z else 1\n\n                # Calculate row nonzero count using the derived formula\n                row_nnz = (m_x * p + 1) * (m_y * p + 1) * (m_z * p + 1)\n\n                # Update aggregates\n                total_nnz += row_nnz\n                if row_nnz  max_row_count:\n                    max_row_count = row_nnz\n                if row_nnz  min_row_count:\n                    min_row_count = row_nnz\n    \n    # Perform consistency check\n    is_consistent = check_consistency(nx, ny, nz, p, interfaces_x, interfaces_y, interfaces_z)\n\n    return int(total_nnz), max_row_count, min_row_count, is_consistent\n\n\ndef check_consistency(nx, ny, nz, p, interfaces_x, interfaces_y, interfaces_z):\n    \"\"\"\n    Validates the formula against a direct element-union enumeration on a sample of nodes.\n    \"\"\"\n    Nx, Ny, Nz = nx * p + 1, ny * p + 1, nz * p + 1\n    \n    # Define a deterministic, fixed set of sample nodes to test\n    sample_nodes = {(0, 0, 0)}\n    # Add nodes near origin\n    sample_nodes.add((min(1, Nx - 1), 0, 0))\n    sample_nodes.add((0, min(1, Ny - 1), 0))\n    sample_nodes.add((0, 0, min(1, Nz - 1)))\n    # Add nodes on first internal interface\n    if nx  1: sample_nodes.add((p, min(1, Ny - 1), 0))\n    if ny  1: sample_nodes.add((min(1, Nx - 1), p, 0))\n    if nz  1: sample_nodes.add((0, 0, p))\n    # Add nodes on interface intersections\n    if nx  1 and ny  1: sample_nodes.add((p, p, 0))\n    if nx  1 and ny  1 and nz  1: sample_nodes.add((p, p, p))\n\n    for i, j, k in sample_nodes:\n        # Ensure sample node is within the grid dimensions\n        if not (i  Nx and j  Ny and k  Nz):\n            continue\n\n        # 1. Calculate count using the formula\n        m_x = 2 if i in interfaces_x else 1\n        m_y = 2 if j in interfaces_y else 1\n        m_z = 2 if k in interfaces_z else 1\n        formula_count = (m_x * p + 1) * (m_y * p + 1) * (m_z * p + 1)\n\n        # 2. Calculate count using direct element-union enumeration\n        # Find the starting element index of the patch of incident elements\n        ex_start = i // p - 1 if m_x == 2 else i // p\n        ey_start = j // p - 1 if m_y == 2 else j // p\n        ez_start = k // p - 1 if m_z == 2 else k // p\n\n        # Define the ranges of incident elements\n        ex_range = range(ex_start, ex_start + m_x)\n        ey_range = range(ey_start, ey_start + m_y)\n        ez_range = range(ez_start, ez_start + m_z)\n\n        # Build the union of all nodes from all incident elements\n        union_of_nodes = set()\n        for ex in ex_range:\n            for ey in ey_range:\n                for ez in ez_range:\n                    for inode in range(ex * p, (ex + 1) * p + 1):\n                        for jnode in range(ey * p, (ey + 1) * p + 1):\n                            for knode in range(ez * p, (ez + 1) * p + 1):\n                                union_of_nodes.add((inode, jnode, knode))\n        \n        direct_count = len(union_of_nodes)\n\n        if formula_count != direct_count:\n            return False\n\n    return True\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3600273"}, {"introduction": "理论上，描述扩散等物理过程的刚度矩阵 $\\mathbf{K}$ 由于其变分形式的内在属性而应具备对称性。然而，在实际编程实现中，尤其是在处理扭曲单元和各向异性材料时，不恰当的计算细节可能会无意中破坏这种对称性。本练习模拟了这样一个场景，要求你检测并纠正由于坐标变换处理不一致而导致的装配非对称性，这是开发稳健且精确的模拟代码所需的一项关键调试技能。[@problem_id:3600339]", "problem": "您的任务是研究用于地幔对流模拟的三维各向异性扩散问题的有限元法 (FEM) 刚度矩阵的全局集成，重点关注集成过程中产生的非对称性。从定义在域 $\\Omega \\subset \\mathbb{R}^3$ 上的标量场 $T(\\mathbf{x})$ 的稳态扩散强形式开始，其电导率张量 $\\mathbf{A}(\\mathbf{x})$ 是对称正定的，方程为 $-\\nabla \\cdot (\\mathbf{A} \\nabla T) = 0$。其 Galerkin 弱形式为：寻找 $T \\in V$，使得对于所有测试函数 $v \\in V_0$，\n$$\na(T,v) = \\int_{\\Omega} (\\nabla v)^{\\top} \\mathbf{A}(\\mathbf{x}) \\nabla T \\, d\\mathbf{x} = 0,\n$$\n其中 $V$ 是一个合适的 Sobolev 空间，$V_0$ 用于处理 Dirichlet 边界条件。双线性形式 $a(\\cdot,\\cdot)$ 是对称的，因为 $\\mathbf{A}(\\mathbf{x})$ 是对称正定的。在一个等参三线性六面体单元中，从参考单元 $\\hat{K} = [-1,1]^3$到物理单元 $K$ 的映射 $\\mathbf{x}(\\boldsymbol{\\xi})$ 由与解插值相同的形函数定义。将映射的雅可比矩阵记为 $\\mathbf{J} = \\partial \\mathbf{x}/\\partial \\boldsymbol{\\xi}$。形函数 $N_i$ 在物理坐标下的梯度通过 Piola 变换 $\\nabla_{\\mathbf{x}} N_i = \\mathbf{J}^{-T} \\nabla_{\\boldsymbol{\\xi}} N_i$ 获得。通过精确积分和一致的映射，单元刚度矩阵为\n$$\n\\mathbf{K}^{(e)} = \\int_{\\hat{K}} \\mathbf{B}(\\boldsymbol{\\xi})^{\\top} \\mathbf{A}(\\mathbf{x}(\\boldsymbol{\\xi})) \\, \\mathbf{B}(\\boldsymbol{\\xi}) \\, \\det(\\mathbf{J}(\\boldsymbol{\\xi})) \\, d\\boldsymbol{\\xi},\n$$\n其中 $\\mathbf{B}(\\boldsymbol{\\xi})$ 的列是形函数的物理梯度。该表达式根据其构造是对称的。然而，在实践中，非仿射映射和实现上的不一致性可能导致在集成过程中对其中一个梯度因子使用不正确的拉回时，产生的单元刚度矩阵不是对称的。\n\n您的任务是实现一个程序，该程序：\n- 使用高斯积分和各向异性的对称正定电导率张量，为三线性六面体构建单元刚度矩阵。\n- 证明对于仿射映射，并在梯度变换中一致地使用 $\\mathbf{J}^{-1}$ 时，集成后的刚度矩阵是对称的。\n- 证明对于扭曲（非仿射）的映射，如果在单元被积函数中对左梯度因子错误地应用 $\\mathbf{J}^{-T}$，而对右梯度因子应用 $\\mathbf{J}^{-1}$，则得到的单元刚度矩阵是非对称的。\n- 通过计算斜对称部分的 Frobenius 范数来检测和量化非对称性。\n- 通过将 $\\mathbf{K}$ 替换为 $\\tfrac{1}{2}(\\mathbf{K} + \\mathbf{K}^{\\top})$ 在全局层面校正非对称性，并验证校正后的对称性。\n- 对于一组指定的 Dirichlet 节点，验证校正后的、经过 Dirichlet 约减的全局矩阵的正定性。\n\n使用以下基本原理和事实：\n- $\\mathbf{A}$ 的对称正定性意味着在适当的边界条件下，连续双线性形式 $a(\\cdot,\\cdot)$ 是对称且强制的。\n- 在具有映射 $\\mathbf{x}(\\boldsymbol{\\xi})$ 的等参单元中，梯度的正确拉回是 $\\nabla_{\\mathbf{x}} N = \\mathbf{J}^{-T} \\nabla_{\\boldsymbol{\\xi}} N$。当在单元被积函数的左右梯度因子中一致地实现时，会产生一个对称的单元张量。\n- 当 $\\mathbf{A}$ 在单元内为常数且映射为仿射时，$2\\times 2\\times 2$ 点的高斯积分规则足以精确积分三线性六面体单元的刚度。对于非仿射三线性映射，它提供了一个标准的一致近似。\n\n将各向异性电导率张量定义为在每个单元内恒定，并由下式给出\n$$\n\\mathbf{A} = \\mathbf{R} \\, \\mathrm{diag}(k_1,k_2,k_3) \\, \\mathbf{R}^{\\top},\n$$\n其中 $k_1 = 6.0$，$k_2 = 1.0$，$k_3 = 0.5$。旋转矩阵 $\\mathbf{R}$ 是 $\\mathbf{R} = \\mathbf{R}_z(\\theta_z)\\mathbf{R}_y(\\theta_y)\\mathbf{R}_x(\\theta_x)$ 的复合，使用的角度（以弧度为单位）为 $\\theta_x = -0.2$，$\\theta_y = 0.5$，$\\theta_z = 0.3$。\n\n在参考六面体上使用三线性形函数，其标准节点排序对应于角点 $(\\xi_i,\\eta_i,\\zeta_i) \\in \\{-1,1\\}^3$：\n- $(\\xi_1,\\eta_1,\\zeta_1) = (-1,-1,-1)$,\n- $(\\xi_2,\\eta_2,\\zeta_2) = (1,-1,-1)$,\n- $(\\xi_3,\\eta_3,\\zeta_3) = (1,1,-1)$,\n- $(\\xi_4,\\eta_4,\\zeta_4) = (-1,1,-1)$,\n- $(\\xi_5,\\eta_5,\\zeta_5) = (-1,-1,1)$,\n- $(\\xi_6,\\eta_6,\\zeta_6) = (1,-1,1)$,\n- $(\\xi_7,\\eta_7,\\zeta_7) = (1,1,1)$,\n- $(\\xi_8,\\eta_8,\\zeta_8) = (-1,1,1)$.\n\n采用 $2\\times 2\\times 2$ 的高斯积分，其在每个方向上的横坐标为 $\\pm 1/\\sqrt{3}$，权重为 $1$。\n\n测试套件。您必须实现并评估以下三个测试案例和一个验证：\n\n- 案例 A（基线仿射，一致）：\n  - 单个单元（单位立方体）的物理节点坐标：\n    - $\\mathbf{X}_1 = (0,0,0)$, $\\mathbf{X}_2 = (1,0,0)$, $\\mathbf{X}_3 = (1,1,0)$, $\\mathbf{X}_4 = (0,1,0)$,\n    - $\\mathbf{X}_5 = (0,0,1)$, $\\mathbf{X}_6 = (1,0,1)$, $\\mathbf{X}_7 = (1,1,1)$, $\\mathbf{X}_8 = (0,1,1)$.\n  - 在被积函数两侧使用正确的梯度拉回集成单元刚度。进行全局集成（单个单元）并计算 Frobenius 范数\n    $$\n    s_A = \\left\\| \\mathbf{K} - \\mathbf{K}^{\\top} \\right\\|_F.\n    $$\n    以浮点数形式返回 $s_A$。\n\n- 案例 B（扭曲映射，破坏性集成以引发非对称性）：\n  - 单个扭曲单元的物理节点坐标：\n    - $\\mathbf{X}_1 = (0,0,0)$, $\\mathbf{X}_2 = (1,0,0)$, $\\mathbf{X}_3 = (1,1.02,0)$, $\\mathbf{X}_4 = (0,1,0)$,\n    - $\\mathbf{X}_5 = (0,0,1)$, $\\mathbf{X}_6 = (1.03,0,1)$, $\\mathbf{X}_7 = (1.05,0.95,1.02)$, $\\mathbf{X}_8 = (0,1.01,1)$.\n  - 使用形式为 ... 的不一致被积函数来集成单元刚度\n    $$\n    \\tilde{\\mathbf{K}}^{(e)} = \\int_{\\hat{K}} \\tilde{\\mathbf{B}}(\\boldsymbol{\\xi})^{\\top} \\mathbf{A} \\, \\mathbf{B}(\\boldsymbol{\\xi}) \\, \\det(\\mathbf{J}(\\boldsymbol{\\xi})) \\, d\\boldsymbol{\\xi},\n    $$\n    其中 $\\mathbf{B}$ 使用正确的拉回 $\\nabla_{\\mathbf{x}} N = \\mathbf{J}^{-T}\\nabla_{\\boldsymbol{\\xi}} N$，而 $\\tilde{\\mathbf{B}}$ 对左梯度因子使用不正确的拉回 $\\nabla_{\\mathbf{x}} N = \\mathbf{J}^{-1}\\nabla_{\\boldsymbol{\\xi}} N$。进行全局集成（单个单元）并计算\n    $$\n    s_B = \\left\\| \\tilde{\\mathbf{K}} - \\tilde{\\mathbf{K}}^{\\top} \\right\\|_F.\n    $$\n    以浮点数形式返回 $s_B$。\n\n- 案例 C（对称性校正）：\n  - 基于案例 B，将校正后的全局刚度定义为\n    $$\n    \\mathbf{K}_{\\mathrm{corr}} = \\tfrac{1}{2}\\left(\\tilde{\\mathbf{K}} + \\tilde{\\mathbf{K}}^{\\top}\\right).\n    $$\n  - 计算\n    $$\n    s_C = \\left\\| \\mathbf{K}_{\\mathrm{corr}} - \\mathbf{K}_{\\mathrm{corr}}^{\\top} \\right\\|_F.\n    $$\n    以浮点数形式返回 $s_C$。\n\n- 验证 D（Dirichlet 约减下的正定性）：\n  - 对案例 B 中扭曲单元的最小 $x$ 坐标节点所在的面施加齐次 Dirichlet 条件，即所有满足 $x_i = \\min_j x_j$ 的节点 $\\mathbf{X}_i$。\n  - 从 $\\mathbf{K}_{\\mathrm{corr}}$ 中提取与剩余无约束节点对应的自由-自由子矩阵 $\\mathbf{K}_{\\mathrm{ff}}$。\n  - 确定 $\\mathbf{K}_{\\mathrm{ff}}$ 的所有特征值是否严格为正（大于数值公差 $10^{-10}$），并返回一个布尔值 $b_D$，当且仅当 $\\mathbf{K}_{\\mathrm{ff}}$ 是正定的时候为真。\n\n数值和实现要求：\n- 所有计算都是无量纲的；不要在输出中包含物理单位。\n- 在参考单元上实现三线性形函数及其导数。在积分点处使用等参映射 $\\mathbf{x}(\\boldsymbol{\\xi}) = \\sum_{i=1}^{8} N_i(\\boldsymbol{\\xi}) \\, \\mathbf{X}_i$ 和 $\\mathbf{J} = \\sum_{i=1}^{8} \\mathbf{X}_i \\, (\\nabla_{\\boldsymbol{\\xi}} N_i)^{\\top}$。\n- 使用高斯积分点，其坐标为 $\\xi,\\eta,\\zeta \\in \\{-1/\\sqrt{3}, 1/\\sqrt{3}\\}$，权重为 $1$。\n- 对于对称性检测，使用 Frobenius 范数 $\\| \\cdot \\|_F$。\n- 对于正定性，使用 $\\mathbf{K}_{\\mathrm{ff}}$ 的稠密特征值计算。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[s_A, s_B, s_C, b_D]$。前三个条目必须是浮点数，第四个条目必须是布尔字面量。例如，一个有效的输出看起来会是 $[0.0,0.1234,0.0,True]$。", "solution": "我们从具有对称正定矩阵 $\\mathbf{A}$ 的强形式 $-\\nabla \\cdot (\\mathbf{A} \\nabla T) = 0$ 开始。在 $\\Omega$ 上的标准 Galerkin 弱形式是 $a(T,v) = \\int_{\\Omega} (\\nabla v)^{\\top} \\mathbf{A} \\, \\nabla T \\, d\\mathbf{x}$。因为 $\\mathbf{A}$ 是对称正定的且梯度是线性的，所以双线性形式 $a(\\cdot,\\cdot)$ 是对称的。这意味着，当一致地离散化时，由单元贡献集成而来的全局刚度矩阵 $\\mathbf{K}$ 应该是对称的：$\\mathbf{K} = \\mathbf{K}^{\\top}$。\n\n对于三线性等参六面体，我们使用相同的形函数 $N_i(\\boldsymbol{\\xi})$ 来插值节点坐标，从而将参考单元 $\\hat{K} = [-1,1]^3$ 映射到物理单元 $K$：$\\mathbf{x}(\\boldsymbol{\\xi}) = \\sum_{i=1}^{8} N_i(\\boldsymbol{\\xi}) \\mathbf{X}_i$。雅可比矩阵为 $\\mathbf{J}(\\boldsymbol{\\xi}) = \\frac{\\partial \\mathbf{x}}{\\partial \\boldsymbol{\\xi}} = \\sum_{i=1}^{8} \\mathbf{X}_i (\\nabla_{\\boldsymbol{\\xi}} N_i(\\boldsymbol{\\xi}))^{\\top}$。形函数的正确物理梯度通过 Piola 变换 $\\nabla_{\\mathbf{x}} N_i = \\mathbf{J}^{-T} \\nabla_{\\boldsymbol{\\xi}} N_i$ 获得，或者对于行向量，等效地表示为 $(\\nabla_{\\mathbf{x}} N_i)^{\\top} = \\mathbf{J}^{-1} (\\nabla_{\\boldsymbol{\\xi}} N_i)^{\\top}$。\n\n一致的单元刚度为\n$$\n\\mathbf{K}^{(e)} = \\int_{\\hat{K}} \\mathbf{B}(\\boldsymbol{\\xi})^{\\top} \\, \\mathbf{A} \\, \\mathbf{B}(\\boldsymbol{\\xi}) \\, \\det(\\mathbf{J}(\\boldsymbol{\\xi})) \\, d\\boldsymbol{\\xi},\n$$\n这是对称的，因为它的形式是 $\\int \\mathbf{C}^{\\top} \\mathbf{A} \\mathbf{C} \\, dV$，其中 $\\mathbf{A} = \\mathbf{A}^{\\top}$。\n\n在实践中，如果在数值计算双线性形式的两个因子时，梯度拉回的应用不一致，就会出现非对称性。这种不一致性的一个例子是，使用 $\\mathbf{J}^{-1}$（对于列向量梯度是不正确的）计算左梯度因子，而使用 $\\mathbf{J}^{-T}$（正确的）计算右梯度因子。这会产生一个形式为 $\\tilde{\\mathbf{B}}^{\\top} \\mathbf{A} \\mathbf{B}$ 的单元级被积函数，其中 $\\tilde{\\mathbf{B}} \\neq \\mathbf{B}$。除非 $\\tilde{\\mathbf{B}} = \\mathbf{B}$，否则这通常不会产生对称张量，因为 $(\\tilde{\\mathbf{B}}^{\\top} \\mathbf{A} \\mathbf{B})^{\\top} = \\mathbf{B}^{\\top} \\mathbf{A} \\tilde{\\mathbf{B}} \\neq \\tilde{\\mathbf{B}}^{\\top} \\mathbf{A} \\mathbf{B}$。\n\n算法设计：\n- 使用标准节点符号 $(\\xi_i,\\eta_i,\\zeta_i) \\in \\{-1,1\\}^3$ 实现三线性形函数 $N_i(\\xi,\\eta,\\zeta) = \\tfrac{1}{8} (1+\\xi \\xi_i)(1+\\eta \\eta_i)(1+\\zeta \\zeta_i)$ 及其参考梯度 $\\nabla_{\\boldsymbol{\\xi}} N_i$。\n- 对于给定的物理节点坐标集 $\\{\\mathbf{X}_i\\}_{i=1}^8$，在每个权重为 $w=1$ 的高斯点 $(\\xi,\\eta,\\zeta)$ 处计算 $\\mathbf{J}$ 和 $\\det(\\mathbf{J})$。检查 $\\det(\\mathbf{J})0$ 以避免单元反转。\n- 计算两个版本的梯度矩阵：\n  - 一致版本：$\\mathbf{B}$ 的列为 $\\nabla_{\\mathbf{x}} N_i = (\\nabla_{\\boldsymbol{\\xi}} N_i)^{\\top} \\mathbf{J}^{-T}$ 或按行表示为 $\\nabla_{\\mathbf{x}} N_i = \\nabla_{\\boldsymbol{\\xi}} N_i \\, \\mathbf{J}^{-1}$。\n  - 破坏版本：$\\tilde{\\mathbf{B}}$ 是通过对左因子错误地使用 $\\nabla_{\\mathbf{x}} N_i = \\nabla_{\\boldsymbol{\\xi}} N_i \\, \\mathbf{J}^{-T}$ 来计算的，而右因子使用正确的 $\\mathbf{B}$。\n- 通过高斯积分计算单元矩阵：\n  - 一致单元：$\\mathbf{K}^{(e)} \\approx \\sum_{q} w_q \\, \\det(\\mathbf{J}_q) \\, \\mathbf{B}_q^{\\top} \\, \\mathbf{A} \\, \\mathbf{B}_q$。\n  - 破坏单元：$\\tilde{\\mathbf{K}}^{(e)} \\approx \\sum_{q} w_q \\, \\det(\\mathbf{J}_q) \\, \\tilde{\\mathbf{B}}_q^{\\top} \\, \\mathbf{A} \\, \\mathbf{B}_q$。\n- 通过对单元贡献求和进行全局集成。对于单个单元，全局矩阵等于单元矩阵。\n- 通过计算斜对称部分的 Frobenius 范数来检测非对称性：$s = \\|\\mathbf{K} - \\mathbf{K}^{\\top}\\|_F$。\n- 通过对称化校正非对称性：$\\mathbf{K}_{\\mathrm{corr}} = \\tfrac{1}{2}(\\mathbf{K} + \\mathbf{K}^{\\top})$，并重新计算非对称性度量 $s_C$。\n- 对于正定性检查，对所有 $x$ 坐标等于单元节点中最小 $x$ 值的节点（即平面 $x = \\min_i x_i$）施加齐次 Dirichlet 条件。从 $\\mathbf{K}_{\\mathrm{corr}}$ 中提取自由-自由子矩阵 $\\mathbf{K}_{\\mathrm{ff}}$ 并计算其特征值。如果 $\\min \\lambda(\\mathbf{K}_{\\mathrm{ff}}) > 10^{-10}$，则报告真；否则报告假。\n\n测试的理由：\n- 案例 A 使用仿射映射和一致的梯度拉回。因为 $\\mathbf{B}$ 是一致计算的，每个被积函数 $\\mathbf{B}^{\\top} \\mathbf{A} \\mathbf{B}$ 都是对称的，所以 $s_A$ 应该在舍入误差的量级，这表明了正确的对称集成。\n- 案例 B 使用扭曲映射和破坏性的左右梯度应用，因此 $s_B$ 应该显著大于舍入误差，这表明了由于不一致实现而导致的可检测到的非对称性。\n- 案例 C 通过投影到对称部分来校正非对称性，因此 $s_C$ 应该接近于零（舍入误差），恢复了扩散算子预期的对称性。\n- 验证 D 表明，在校正并进行适当的 Dirichlet 约减后，矩阵不仅是对称的，而且是正定的，这与 Dirichlet 边界条件下双线性形式的强制性相一致。\n\n各向异性电导率张量构造为 $\\mathbf{A} = \\mathbf{R} \\, \\mathrm{diag}(6.0, 1.0, 0.5) \\, \\mathbf{R}^{\\top}$，其中 $\\mathbf{R}$ 是分别绕 $x$、$y$ 和 $z$ 轴旋转角度 $-0.2$、$0.5$ 和 $0.3$ 弧度的旋转矩阵。这确保了一种非平凡的、旋转的各向异性，这是地幔构造的典型特征。\n\n程序应按规定格式输出单行结果 $[s_A,s_B,s_C,b_D]$，其中前三项为浮点数，最后一项为布尔字面量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotation_matrix_xyz(theta_x, theta_y, theta_z):\n    cx, sx = np.cos(theta_x), np.sin(theta_x)\n    cy, sy = np.cos(theta_y), np.sin(theta_y)\n    cz, sz = np.cos(theta_z), np.sin(theta_z)\n    Rx = np.array([[1.0, 0.0, 0.0],\n                   [0.0, cx, -sx],\n                   [0.0, sx, cx]])\n    Ry = np.array([[cy, 0.0, sy],\n                   [0.0, 1.0, 0.0],\n                   [-sy, 0.0, cy]])\n    Rz = np.array([[cz, -sz, 0.0],\n                   [sz, cz, 0.0],\n                   [0.0, 0.0, 1.0]])\n    # Composition R = Rz * Ry * Rx\n    return Rz @ Ry @ Rx\n\ndef quad_points_2x2x2():\n    g = 1.0/np.sqrt(3.0)\n    pts = []\n    for xi in (-g, g):\n        for eta in (-g, g):\n            for zeta in (-g, g):\n                pts.append((xi, eta, zeta, 1.0))\n    return pts\n\ndef shape_functions_Q1_and_grads(xi, eta, zeta):\n    # Node signs for reference hexahedron\n    signs = np.array([\n        [-1, -1, -1],\n        [ 1, -1, -1],\n        [ 1,  1, -1],\n        [-1,  1, -1],\n        [-1, -1,  1],\n        [ 1, -1,  1],\n        [ 1,  1,  1],\n        [-1,  1,  1],\n    ], dtype=float)\n    N = np.zeros(8, dtype=float)\n    dN_dxi = np.zeros((8, 3), dtype=float)\n    for i in range(8):\n        sx, sy, sz = signs[i]\n        N[i] = 0.125 * (1 + sx*xi) * (1 + sy*eta) * (1 + sz*zeta)\n        dN_dxi[i, 0] = 0.125 * sx * (1 + sy*eta) * (1 + sz*zeta)\n        dN_dxi[i, 1] = 0.125 * sy * (1 + sx*xi) * (1 + sz*zeta)\n        dN_dxi[i, 2] = 0.125 * sz * (1 + sx*xi) * (1 + sy*eta)\n    return N, dN_dxi\n\ndef jacobian_and_grads(phys_nodes, dN_dxi):\n    # phys_nodes: (8,3), dN_dxi: (8,3)\n    # J = X^T * dN_dxi\n    J = phys_nodes.T @ dN_dxi  # (3,8) @ (8,3) - (3,3)\n    detJ = np.linalg.det(J)\n    invJ = np.linalg.inv(J)\n    # Correct physical gradients: grad_x N = dN_dxi @ invJ\n    dN_dx_correct = dN_dxi @ invJ\n    # Wrong/incorrect physical gradients for left factor: using invJ.T\n    dN_dx_wrong = dN_dxi @ invJ.T\n    return J, detJ, dN_dx_correct, dN_dx_wrong\n\ndef element_stiffness(phys_nodes, A, mode=\"consistent\"):\n    # mode: \"consistent\" - K = sum B^T A B\n    #       \"broken\"     - K = sum B_wrong^T A B_right (asymmetric)\n    K = np.zeros((8,8), dtype=float)\n    for xi, eta, zeta, w in quad_points_2x2x2():\n        N, dN_dxi = shape_functions_Q1_and_grads(xi, eta, zeta)\n        J, detJ, dN_dx_correct, dN_dx_wrong = jacobian_and_grads(phys_nodes, dN_dxi)\n        if detJ = 0:\n            raise ValueError(\"Non-positive Jacobian determinant encountered.\")\n        # Build B matrices: 3x8 with columns grad N_i\n        B_right = dN_dx_correct.T  # shape (3,8)\n        if mode == \"consistent\":\n            integrand = B_right.T @ A @ B_right  # (8,3)(3,3)(3,8) - (8,8), symmetric\n        elif mode == \"broken\":\n            B_left_wrong = dN_dx_wrong.T  # (3,8)\n            integrand = B_left_wrong.T @ A @ B_right  # (8,3)(3,3)(3,8) - (8,8), not symmetric\n        else:\n            raise ValueError(\"Unknown mode.\")\n        K += w * detJ * integrand\n    return K\n\ndef frobenius_norm(M):\n    return np.sqrt(np.sum(M*M))\n\ndef solve():\n    # Define anisotropic conductivity tensor A\n    R = rotation_matrix_xyz(theta_x=-0.2, theta_y=0.5, theta_z=0.3)\n    k = np.diag([6.0, 1.0, 0.5])\n    A = R @ k @ R.T\n\n    # Case A: affine unit cube\n    cube_nodes = np.array([\n        [0.0, 0.0, 0.0],  # X1\n        [1.0, 0.0, 0.0],  # X2\n        [1.0, 1.0, 0.0],  # X3\n        [0.0, 1.0, 0.0],  # X4\n        [0.0, 0.0, 1.0],  # X5\n        [1.0, 0.0, 1.0],  # X6\n        [1.0, 1.0, 1.0],  # X7\n        [0.0, 1.0, 1.0],  # X8\n    ], dtype=float)\n    K_A = element_stiffness(cube_nodes, A, mode=\"consistent\")\n    s_A = frobenius_norm(K_A - K_A.T)\n\n    # Case B: distorted element, broken assembly\n    distorted_nodes = np.array([\n        [0.0,   0.0,  0.0],   # X1\n        [1.0,   0.0,  0.0],   # X2\n        [1.0,   1.02, 0.0],   # X3\n        [0.0,   1.0,  0.0],   # X4\n        [0.0,   0.0,  1.0],   # X5\n        [1.03,  0.0,  1.0],   # X6\n        [1.05,  0.95, 1.02],  # X7\n        [0.0,   1.01, 1.0],   # X8\n    ], dtype=float)\n    K_B = element_stiffness(distorted_nodes, A, mode=\"broken\")\n    s_B = frobenius_norm(K_B - K_B.T)\n\n    # Case C: symmetrization correction\n    K_corr = 0.5 * (K_B + K_B.T)\n    s_C = frobenius_norm(K_corr - K_corr.T)\n\n    # Verification D: positive definiteness under Dirichlet reduction on min-x face\n    x_coords = distorted_nodes[:, 0]\n    xmin = np.min(x_coords)\n    dirichlet_nodes = np.where(np.abs(x_coords - xmin)  1e-12)[0].tolist()\n    all_nodes = list(range(8))\n    free_nodes = [i for i in all_nodes if i not in dirichlet_nodes]\n    # Extract free-free block\n    if len(free_nodes) == 0:\n        # Degenerate case: no free nodes, treat as vacuously positive definite\n        b_D = True\n    else:\n        K_ff = K_corr[np.ix_(free_nodes, free_nodes)]\n        # Check symmetry just in case\n        K_ff = 0.5 * (K_ff + K_ff.T)\n        # Eigenvalues\n        eigvals = np.linalg.eigvalsh(K_ff)\n        b_D = bool(np.min(eigvals)  1e-10)\n\n    results = [s_A, s_B, s_C, b_D]\n    # Final print statement in the exact required format.\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]}]\")\n\nsolve()\n```", "id": "3600339"}, {"introduction": "全局矩阵的装配策略不仅是计算上的选择，它还会对模拟结果的物理真实性产生深远影响。本练习旨在比较两种常用的质量矩阵装配方法——一致质量矩阵与集中质量矩阵——并研究它们对地震波模拟中数值频散现象的影响。通过这个实践，你将量化不同的装配选择如何改变波速的频率依赖性，从而更深刻地理解计算方法如何影响波动模拟的精度。[@problem_id:3600285]", "problem": "您需要使用有限元法（FEM）对一维、均匀、周期性介质中的标量地震波传播进行建模。从微应变弹性波方程出发，假设密度和剪切模量恒定，从而使波速无量纲化为 $c = 1$。位移 $u(x,t)$ 的控制方程是二阶双曲型偏微分方程\n$$\n\\partial_{tt} u(x,t) = c^2 \\, \\partial_{xx} u(x,t),\n$$\n其中 $c$ 为常数。在间距为 $h$ 的均匀网格上，使用标准 Galerkin 离散化和分段线性基函数，并根据单元贡献构建全局组装系统。考虑两种质量矩阵组装方案：一致质量矩阵和通过对角行和集中法得到的集中质量矩阵。对于无限均匀网格，施加 Bloch-Floquet 周期性，其离散振型为 $v_j = \\exp(i \\kappa j h)$，其中无量纲离散波数 $\\kappa h$ 位于开区间 $(0,\\pi)$ 内，角度以弧度为单位。\n\n从有限元法单元矩阵和全局组装过程的基本定义出发，推导出以下形式的半离散运动方程\n$$\n\\mathbf{M} \\, \\ddot{\\mathbf{u}}(t) + c^2 \\, \\mathbf{K} \\, \\mathbf{u}(t) = \\mathbf{0},\n$$\n其中 $\\mathbf{M}$ 是全局质量矩阵（一致或集中），$\\mathbf{K}$ 是全局刚度矩阵。然后，对于具有无量纲波数 $q \\equiv \\kappa h$ 和简谐时间依赖性的 Bloch 模态，推导出离散色散关系，提取离散角频率 $\\omega(q)$，并定义离散相速度\n$$\nc_{\\mathrm{d}}(q) \\equiv \\frac{\\omega(q)}{\\kappa}.\n$$\n您的目标是计算离散色散曲线，并量化组装选择（一致质量矩阵与集中质量矩阵）如何改变相速度。具体来说，将每种组装的无量纲相速度比定义为 $c_{\\mathrm{d}}(q)/c$，并将组装引起的偏移定义为\n$$\n\\Delta(q) \\equiv \\frac{c_{\\mathrm{d,cons}}(q)}{c} - \\frac{c_{\\mathrm{d,lump}}(q)}{c}.\n$$\n在整个计算过程中使用无量纲变量，设 $c = 1$，角度单位为弧度。\n\n您的程序必须实现推导出的表达式，并针对以下无量纲波数 $q$ 的测试套件评估 $\\Delta(q)$：\n- $q \\to 0$ 时的边界极限，通过在 $q=0$ 处使用适当的极限值进行评估并报告。\n- 正常路径情况 $q = 0.1$。\n- 谱中情况 $q = \\pi/2$。\n- 接近 Nyquist 极限的边界情况 $q = \\pi - 10^{-6}$。\n\n此外，您的程序必须通过在 $N=20001$ 个点的均匀间隔网格上采样，计算在区间 $q \\in (0,\\pi)$ 上的最大绝对组装偏移，并报告\n$$\n\\max_{q \\in (0,\\pi)} \\left| \\Delta(q) \\right|.\n$$\n\n所有角度输入和输出都必须以弧度为单位进行解释。由于公式是无量纲的，因此不涉及物理单位。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按以下顺序排列结果：\n$$\n\\left[ \\Delta(0), \\, \\Delta(0.1), \\, \\Delta\\left(\\frac{\\pi}{2}\\right), \\, \\Delta\\left(\\pi - 10^{-6}\\right), \\, \\max_{q \\in (0,\\pi)} |\\Delta(q)| \\right].\n$$\n每个条目都必须是浮点数。", "solution": "该问题要求使用有限元法（FEM）和两种不同的质量矩阵组装方案，为一维标量波方程推导数值色散关系。然后，我们量化由质量矩阵选择引起的相速度差异。该问题是适定的且在科学上是合理的，基于计算物理学的标准原理。\n\n### 1. FEM 公式化和单元矩阵\n\n控制方程是一维标量波方程：\n$$\n\\partial_{tt} u(x,t) = c^2 \\, \\partial_{xx} u(x,t)\n$$\n我们将一维空间域离散化为长度均匀为 $h$ 的单元。在每个单元内，位移场 $u(x,t)$ 使用分段线性基函数（也称为形函数）$N_a(x)$ 进行近似。对于一个从节点 $j$ 延伸到 $j+1$ 的单元，近似为 $u^e(x,t) = u_j(t) N_j(x) + u_{j+1}(t) N_{j+1}(x)$。\n\n标准的 Galerkin 过程得到单元矩阵系统：\n$$\n\\mathbf{M}^e \\ddot{\\mathbf{u}}^e + c^2 \\mathbf{K}^e \\mathbf{u}^e = \\mathbf{0}\n$$\n其中单元刚度矩阵 $\\mathbf{K}^e$ 和质量矩阵 $\\mathbf{M}^e$ 由下式给出：\n$$\nK^e_{ab} = \\int_{\\text{element}} \\frac{dN_a}{dx} \\frac{dN_b}{dx} \\, dx\n$$\n$$\nM^e_{ab} = \\int_{\\text{element}} N_a N_b \\, dx\n$$\n\n对于长度为 $h$ 的线性单元，在局部坐标 $\\xi = (x-x_j)/h \\in [0,1]$ 中，基函数为 $N_1(\\xi) = 1-\\xi$ 和 $N_2(\\xi) = \\xi$。它们的导数为 $\\frac{dN_1}{dx} = -1/h$ 和 $\\frac{dN_2}{dx} = 1/h$。\n\n单元刚度矩阵计算如下：\n$$\n\\mathbf{K}^e = \\int_0^h \\frac{1}{h^2} \\begin{pmatrix} (-1)(-1)  (-1)(1) \\\\ (1)(-1)  (1)(1) \\end{pmatrix} dx = \\frac{1}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\n\n单元**一致质量矩阵**计算如下：\n$$\n\\mathbf{M}^e_{\\mathrm{cons}} = \\int_0^h \\begin{pmatrix} (1-\\xi)^2  (1-\\xi)\\xi \\\\ \\xi(1-\\xi)  \\xi^2 \\end{pmatrix} dx = h \\int_0^1 \\begin{pmatrix} (1-\\xi)^2  \\xi-\\xi^2 \\\\ \\xi-\\xi^2  \\xi^2 \\end{pmatrix} d\\xi = \\frac{h}{6} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}\n$$\n\n单元**集中质量矩阵**通过将一致质量矩阵的行相加，并将总和置于对角线上得到（行和集中法）：\n$$\n\\mathbf{M}^e_{\\mathrm{lump}} = \\text{diag}\\left(\\frac{h}{6}(2+1), \\frac{h}{6}(1+2)\\right) = \\frac{h}{2} \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}\n$$\n\n### 2. 全局组装和半离散运动方程\n\n对于无限均匀网格，我们可以通过组装来自两个相邻单元——单元 $(j-1, j)$ 和单元 $(j, j+1)$ 的贡献，来写出代表性节点 $j$ 的运动方程。\n\n节点 $j$ 的刚度项是：\n$$\n(\\mathbf{K} \\mathbf{u})_j = \\left(\\frac{1}{h}(u_j - u_{j-1})\\right) + \\left(\\frac{1}{h}(u_j - u_{j+1})\\right) = \\frac{1}{h}(-u_{j-1} + 2u_j - u_{j+1})\n$$\n\n质量项取决于所选的方案：\n对于**一致质量矩阵**：\n$$\n(\\mathbf{M}_{\\mathrm{cons}} \\ddot{\\mathbf{u}})_j = \\left(\\frac{h}{6}(\\ddot{u}_{j-1} + 2\\ddot{u}_j)\\right) + \\left(\\frac{h}{6}(2\\ddot{u}_j + \\ddot{u}_{j+1})\\right) = \\frac{h}{6}(\\ddot{u}_{j-1} + 4\\ddot{u}_j + \\ddot{u}_{j+1})\n$$\n运动方程是：\n$$\n\\frac{h}{6}(\\ddot{u}_{j-1} + 4\\ddot{u}_j + \\ddot{u}_{j+1}) + \\frac{c^2}{h}(-u_{j-1} + 2u_j - u_{j+1}) = 0\n$$\n\n对于**集中质量矩阵**：\n$$\n(\\mathbf{M}_{\\mathrm{lump}} \\ddot{\\mathbf{u}})_j = \\left(\\frac{h}{2}\\ddot{u}_j\\right) + \\left(\\frac{h}{2}\\ddot{u}_j\\right) = h\\ddot{u}_j\n$$\n运动方程是：\n$$\nh\\ddot{u}_j + \\frac{c^2}{h}(-u_{j-1} + 2u_j - u_{j+1}) = 0\n$$\n\n### 3. 色散分析\n\n我们寻求一个形式为 $u_j(t) = A e^{i(\\kappa x_j - \\omega t)}$ 的 Bloch-Floquet 平面波解，其中 $x_j = jh$。代入 $u_j(t) = e^{i(qj - \\omega t)}$ 和无量纲波数 $q = \\kappa h$，我们有：\n$u_{j\\pm 1} = u_j e^{\\pm iq}$ 和 $\\ddot{u}_j = -\\omega^2 u_j$。\n\n对于**一致质量**方案，将其代入运动方程可得：\n$$\n-\\omega^2 \\frac{h}{6}(e^{-iq} + 4 + e^{iq}) + \\frac{c^2}{h}(-e^{-iq} + 2 - e^{iq}) = 0\n$$\n$$\n-\\omega^2 \\frac{h}{6}(2\\cos(q) + 4) + \\frac{c^2}{h}(2 - 2\\cos(q)) = 0\n$$\n求解 $\\omega^2$ 得到色散关系：\n$$\n\\omega^2_{\\mathrm{cons}}(q) = \\frac{6c^2}{h^2} \\frac{1 - \\cos(q)}{2 + \\cos(q)}\n$$\n\n对于**集中质量**方案，代入可得：\n$$\n-h\\omega^2 + \\frac{c^2}{h}(-e^{-iq} + 2 - e^{iq}) = 0\n$$\n$$\n-h\\omega^2 + \\frac{c^2}{h}(2 - 2\\cos(q)) = 0\n$$\n求解 $\\omega^2$ 得到色散关系：\n$$\n\\omega^2_{\\mathrm{lump}}(q) = \\frac{2c^2}{h^2}(1 - \\cos(q))\n$$\n\n### 4. 相速度比和组装引起的偏移\n\n离散相速度定义为 $c_{\\mathrm{d}}(q) = \\omega(q) / \\kappa$。使用 $q = \\kappa h$ 并设置解析波速 $c=1$，无量纲相速度比为 $c_{\\mathrm{d}}(q)/c = c_{\\mathrm{d}}(q) = \\omega(q) h / q$。\n\n对于**一致质量**方案：\n$$\n\\frac{c_{\\mathrm{d,cons}}(q)}{c} = \\frac{h}{q} \\sqrt{\\frac{6}{h^2} \\frac{1 - \\cos(q)}{2 + \\cos(q)}} = \\frac{1}{q} \\sqrt{6 \\frac{2\\sin^2(q/2)}{2 + \\cos(q)}} = \\frac{2|\\sin(q/2)|}{q} \\sqrt{\\frac{3}{2 + \\cos(q)}}\n$$\n由于 $q \\in (0, \\pi)$，$\\sin(q/2) > 0$。我们可以使用 sinc 函数 $\\text{sinc}(x) = \\sin(x)/x$ 来表示：\n$$\n\\frac{c_{\\mathrm{d,cons}}(q)}{c} = \\frac{\\sin(q/2)}{q/2} \\sqrt{\\frac{3}{2 + \\cos(q)}}\n$$\n\n对于**集中质量**方案：\n$$\n\\frac{c_{\\mathrm{d,lump}}(q)}{c} = \\frac{h}{q} \\sqrt{\\frac{2}{h^2}(1 - \\cos(q))} = \\frac{h}{q} \\frac{1}{h} \\sqrt{4\\sin^2(q/2)} = \\frac{2|\\sin(q/2)|}{q} = \\frac{\\sin(q/2)}{q/2}\n$$\n\n组装引起的偏移 $\\Delta(q)$ 是这两个比率之差：\n$$\n\\Delta(q) = \\frac{c_{\\mathrm{d,cons}}(q)}{c} - \\frac{c_{\\mathrm{d,lump}}(q)}{c} = \\frac{\\sin(q/2)}{q/2} \\left[ \\sqrt{\\frac{3}{2 + \\cos(q)}} - 1 \\right]\n$$\n\n对于长波极限（$q \\to 0$），两种相速度比都趋近于 $1$，这对于一个相容的数值方法是符合预期的。我们可以通过使用 $\\lim_{x\\to0} \\sin(x)/x = 1$ 和 $\\cos(0)=1$ 来看到这一点：\n$$\n\\lim_{q\\to 0} \\Delta(q) = \\left(\\lim_{q\\to 0} \\frac{\\sin(q/2)}{q/2}\\right) \\left[ \\sqrt{\\frac{3}{2 + \\cos(0)}} - 1 \\right] = 1 \\cdot \\left[ \\sqrt{\\frac{3}{3}} - 1 \\right] = 0\n$$\n因此，$\\Delta(0) = 0$。对于所有 $q \\in (0, \\pi)$，可以证明 $1 > \\cos(q)$，这意味着 $\\sqrt{3/(2+\\cos q)} > 1$，因此 $\\Delta(q) > 0$。最大绝对偏移因此是 $\\Delta(q)$ 在区间 $(0, \\pi)$ 上的最大值，这必须按要求进行数值计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the assembly-induced phase velocity shift for FEM\n    discretization of the 1D wave equation.\n    \"\"\"\n\n    def delta_q(q_values):\n        \"\"\"\n        Calculates the assembly-induced shift Delta(q) for an array of\n        nondimensional wavenumbers q.\n\n        The formula is Delta(q) = sinc(q/2) * [sqrt(3 / (2 + cos(q))) - 1],\n        where sinc(x) = sin(x)/x.\n        \n        Args:\n            q_values (np.ndarray): An array of nondimensional wavenumbers.\n\n        Returns:\n            np.ndarray: The corresponding values of Delta(q).\n        \"\"\"\n        # np.sinc(x) computes sin(pi*x)/(pi*x). To get sin(y)/y, we need to pass\n        # y/pi as the argument. Here, y = q/2.\n        # This handles the case q=0 correctly, where np.sinc(0) returning 1.\n        q_arr = np.asarray(q_values)\n        sinc_term = np.sinc(q_arr / (2 * np.pi))\n        \n        # The term inside the radical\n        radicand = 3 / (2 + np.cos(q_arr))\n        sqrt_term = np.sqrt(radicand)\n        \n        return sinc_term * (sqrt_term - 1)\n\n    # Define the test cases from the problem statement.\n    test_suite_q = [\n        0.0,\n        0.1,\n        np.pi / 2,\n        np.pi - 1e-6\n    ]\n\n    # Calculate Delta(q) for the specified test cases\n    results = list(delta_q(test_suite_q))\n\n    # Compute the maximum absolute assembly-induced shift\n    # The problem defines q in the open interval (0, pi).\n    # Delta(q)  0 for q in (0, pi) and Delta(0) = 0.\n    # The derivative Delta'(pi) is negative, so the max is not at pi.\n    # Therefore, searching over the closed interval [0, pi] is sufficient to find\n    # the maximum in the open interval (0, pi).\n    N = 20001\n    q_grid = np.linspace(0, np.pi, N)\n    \n    delta_values_on_grid = delta_q(q_grid)\n    \n    # Since Delta(q) = 0 on [0, pi], max|Delta(q)| = max(Delta(q))\n    max_abs_shift = np.max(delta_values_on_grid)\n    results.append(max_abs_shift)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```", "id": "3600285"}]}