{"hands_on_practices": [{"introduction": "动手实践的第一步是将一个连续的边界积分方程转化为一个离散的线性系统，这是边界元方法（BEM）的核心。本练习 [@problem_id:3616082] 旨在通过求解经典的拉普拉斯方程（$\\\\Delta u = 0$），引导您构建并比较两种最基本的BEM离散化方案：配置法和伽辽金法。通过亲手实现并分析它们的收敛性和矩阵属性，您将对不同离散策略的优缺点及其对解精度的影响获得直观而深刻的理解。", "problem": "考虑二维拉普拉斯方程及其在光滑闭合曲线上的边界积分表示。设 $\\Gamma$ 是 $\\mathbb{R}^2$ 中一个单连通区域的边界，并设 $G(x,y) = -\\frac{1}{2\\pi}\\ln\\|x-y\\|$ 是拉普拉斯算子的基本解。单层边界积分算子 $V$ 作用于标量密度 $\\phi$ 上，其形式为 $(V\\phi)(x) = \\int_{\\Gamma} G(x,y)\\phi(y)\\,ds_y$。在边界元法（BEM）中，需要对该算子进行离散化。两种常见的方法是配置法和伽辽金法。在配置法中，通过在离散的边界点上计算积分来构建一个系统；而在伽辽金法中，则使用带有测试函数和基函数的变分形式。\n\n您的任务是，在一个单位圆的多边形近似上，为单层算子 $V$ 在相同的网格上构建这两种离散系统，并分析它们在网格细化下的对称性和收敛性。请使用在直边界段上定义的分段常数基函数，这些边界段通过 $N$ 个等距点来近似单位圆。角度以弧度处理。\n\n几何和代数设置如下：\n\n- 网格：设 $N$ 是一个正整数（$N \\in \\{8,16,32\\}$）。定义边界节点 $x_k = (\\cos(2\\pi k/N), \\sin(2\\pi k/N))$，其中 $k=0,\\dots,N-1$，以及连接 $x_i$ 和 $x_{i+1}$ 的直线段 $\\Gamma_i$，索引对 $N$ 取模。设 $L_i$ 表示线段 $\\Gamma_i$ 的长度，且 $t \\in [0,L_i]$ 通过 $x_i(t) = x_i + \\hat{u}_i t$ 参数化 $\\Gamma_i$，其中 $\\hat{u}_i$ 是沿 $\\Gamma_i$ 的单位方向向量。\n\n- 基函数：使用分段常数基函数 $b_j$，其中在 $\\Gamma_j$ 上 $b_j = 1$，在其他地方 $b_j = 0$。\n\n- 伽辽金系统：定义矩阵 $A \\in \\mathbb{R}^{N\\times N}$，其元素为\n$$\nA_{ij} = \\int_{\\Gamma_i}\\int_{\\Gamma_j} G(x,y)\\,ds_x\\,ds_y.\n$$\n对于 $i=j$ 的情况，使用直线段自作用的精确对角线公式，\n$$\nA_{ii} = -\\frac{1}{2\\pi}\\int_0^{L_i}\\int_0^{L_i}\\ln|s-t|\\,ds\\,dt = -\\frac{1}{2\\pi}\\left(L_i^2\\ln L_i - \\frac{3}{2}L_i^2\\right).\n$$\n对于 $i\\neq j$ 的情况，通过张量积高斯-勒让德求积来计算 $A_{ij}$，每个线段参数使用 $4$ 个点，即在 $[0,L_i]\\times[0,L_j]$ 上使用 $4\\times 4$ 个点。\n\n- 配置系统：选择每个线段 $\\Gamma_i$ 的中点 $x_i^{\\text{mid}} = x_i + \\hat{u}_i L_i/2$ 作为配置点。定义矩阵 $B \\in \\mathbb{R}^{N\\times N}$，其元素为\n$$\nB_{ij} = \\int_{\\Gamma_j} G(x_i^{\\text{mid}},y)\\,ds_y,\n$$\n通过在 $[0,L_j]$ 上使用 $16$ 点高斯-勒让德求积来计算。对于 $j=i$ 的情况，积分核在配置点处有对数奇异性，但它是可积的；使用指定的求积法，无需特殊的奇异处理。\n\n- 对称性分析：计算相对不对称性度量\n$$\n\\sigma_{\\text{gal}} = \\frac{\\|A - A^\\top\\|_F}{\\|A\\|_F}, \\quad \\sigma_{\\text{col}} = \\frac{\\|B - B^\\top\\|_F}{\\|B\\|_F},\n$$\n其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。\n\n- 使用已知密度的收敛性分析：考虑常数密度 $\\phi(y) \\equiv 1$。对于单位圆，单层势的精确边界迹满足 $(V\\phi)(x) = 0$ 对所有 $x\\in\\Gamma$ 成立，因为\n$$\n\\int_0^{2\\pi} \\ln\\left(2\\sin\\frac{\\vartheta}{2}\\right)\\,d\\vartheta = 0\n$$\n并且 $G(x,y)$ 仅取决于圆上的角差。对于配置离散化，定义 $v^{\\text{col}} = B\\mathbf{1}$，其中 $\\mathbf{1}\\in\\mathbb{R}^N$ 是全为1的向量。对于伽辽金离散化，定义 $v^{\\text{gal}} = A\\mathbf{1}$。估计误差\n$$\ne_{\\text{col}}(N) = \\max_{i} |v^{\\text{col}}_i|, \\quad e_{\\text{gal}}(N) = \\max_{i} |v^{\\text{gal}}_i|.\n$$\n使用网格尺寸 $h(N) = \\frac{2\\pi}{N}$ 计算连续细化之间的经验收敛率：\n$$\nr_{\\text{col}}(N_1\\to N_2) = \\frac{\\ln\\left(e_{\\text{col}}(N_1)/e_{\\text{col}}(N_2)\\right)}{\\ln\\left(h(N_1)/h(N_2)\\right)},\\quad\nr_{\\text{gal}}(N_1\\to N_2) = \\frac{\\ln\\left(e_{\\text{gal}}(N_1)/e_{\\text{gal}}(N_2)\\right)}{\\ln\\left(h(N_1)/h(N_2)\\right)}.\n$$\n\n实现要求：\n\n- 数值计算：使用双精度算术。按规定使用高斯-勒让德求积。角度必须以弧度处理。\n\n- 测试套件：对 $N\\in\\{8,16,32\\}$ 计算这些度量。对于每个 $N$，计算 $(\\sigma_{\\text{col}}, \\sigma_{\\text{gal}}, e_{\\text{col}}(N), e_{\\text{gal}}(N))$。此外，计算收敛率 $r_{\\text{col}}(8\\to 16)$、$r_{\\text{col}}(16\\to 32)$、$r_{\\text{gal}}(8\\to 16)$ 和 $r_{\\text{gal}}(16\\to 32)$。\n\n- 输出规格：您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果。该列表必须按以下顺序包含 $12$ 个浮点数：\n$$\n[\\sigma_{\\text{col}}(8),\\sigma_{\\text{gal}}(8),e_{\\text{col}}(8),e_{\\text{gal}}(8),\\sigma_{\\text{col}}(16),\\sigma_{\\text{gal}}(16),e_{\\text{col}}(16),e_{\\text{gal}}(16),\\sigma_{\\text{col}}(32),\\sigma_{\\text{gal}}(32),e_{\\text{col}}(32),e_{\\text{gal}}(32)]\n$$\n其后跟着 $4$ 个收敛率\n$$\n[r_{\\text{col}}(8\\to 16),r_{\\text{col}}(16\\to 32),r_{\\text{gal}}(8\\to 16),r_{\\text{gal}}(16\\to 32)],\n$$\n连接成一个包含 $16$ 个数字的扁平列表。最终输出格式必须严格为\n$$\n[\\text{val}_1,\\text{val}_2,\\dots,\\text{val}_{16}],\n$$\n其中每个 $\\text{val}_k$ 以标准浮点数格式打印。", "solution": "用户提供了一个在边界元法（BEM）领域中定义明确的计算问题。任务是为二维拉普拉斯方程相关的单层势算子实现并分析两种离散化方案：伽辽金法和配置法。该分析涉及在一个特定的测试案例上评估矩阵对称性和经验收敛率。\n\n### 问题验证\n\n1.  **提取已知条件**：问题陈述指定了以下内容：\n    *   **控制方程**：二维拉普拉斯方程，$\\Delta u = 0$。\n    *   **基本解**：$G(x,y) = -\\frac{1}{2\\pi}\\ln\\|x-y\\|$。\n    *   **单层算子**：$(V\\phi)(x) = \\int_{\\Gamma} G(x,y)\\phi(y)\\,ds_y$。\n    *   **几何**：一个内接于单位圆的正 $N$ 边形，其中 $N \\in \\{8, 16, 32\\}$。\n    *   **基函数**：多边形每个线段上的分段常数函数。\n    *   **伽辽金系统**：一个 $N \\times N$ 矩阵 $A$，其元素为 $A_{ij} = \\int_{\\Gamma_i}\\int_{\\Gamma_j} G(x,y)\\,ds_x\\,ds_y$。\n        *   对角元素 $A_{ii}$ 由解析公式 $-\\frac{1}{2\\pi}\\left(L_i^2\\ln L_i - \\frac{3}{2}L_i^2\\right)$ 给出。\n        *   非对角元素 $A_{ij}$ 通过 $4 \\times 4$ 张量积高斯-勒让德求积计算。\n    *   **配置系统**：一个 $N \\times N$ 矩阵 $B$，其元素为 $B_{ij} = \\int_{\\Gamma_j} G(x_i^{\\text{mid}},y)\\,ds_y$，其中 $x_i^{\\text{mid}}$ 是线段 $\\Gamma_i$ 的中点。\n        *   元素通过 $16$ 点高斯-勒让德求积计算，包括奇异情况 $i=j$。\n    *   **分析度量**：\n        *   相对不对称性：$\\sigma = \\frac{\\|M - M^\\top\\|_F}{\\|M\\|_F}$，对于 $M=A, B$。\n        *   误差估计：$e(N) = \\max_i |(M\\mathbf{1})_i|$，用于常数密度 $\\phi=1$ 的测试案例，其中 $\\mathbf{1}$ 是全为1的向量。\n        *   收敛率：$r(N_1\\to N_2) = \\frac{\\ln\\left(e(N_1)/e(N_2)\\right)}{\\ln\\left(h(N_1)/h(N_2)\\right)}$，网格尺寸为 $h(N) = 2\\pi/N$。\n    *   **输出**：一个包含所计算的度量和收敛率的、由 $16$ 个浮点数组成的特定列表。\n\n2.  **使用提取的已知条件进行验证**：\n    *   **科学依据**：该问题植根于势理论和数值分析的标准原理，特别是针对椭圆偏微分方程的BEM。所有定义和公式都是该领域的标准内容。\n    *   **适定性**：问题规定清晰。几何、基函数、求积法则和解析公式为构建矩阵 $A$ 和 $B$ 提供了一套完整且明确的指令。分析度量也得到了精确定义。\n    *   **客观性**：问题以客观的数学术语陈述，没有任何主观或有偏见的语言。\n\n3.  **结论**：该问题是有效的。它是一个适定、科学上合理且客观的任务，可以按描述进行计算求解。\n\n### 求解设计\n\n将使用 `numpy` 和 `scipy` 库在Python中实现解决方案。该方案的核心是一个函数，对于给定的边界元数量 $N$，执行以下步骤：\n\n1.  **几何离散化**：计算内接于单位圆的正 $N$ 边形的顶点。根据这些顶点，确定每个线性线段 $\\Gamma_i$ 的属性：其起点和终点、长度 $L$、中点 $x_i^{\\text{mid}}$ 和单位方向向量 $\\hat{u}_i$。\n\n2.  **求积设置**：使用 `scipy.special.roots_legendre` 为 $4$ 点和 $16$ 点预计算高斯-勒让德求积的节点和权重。这些节点和权重将从标准区间 $[-1, 1]$ 缩放到线段长度区间 $[0, L]$。\n\n3.  **矩阵构建**：组装伽辽金矩阵 $A$ 和配置矩阵 $B$。\n    *   对于**伽辽金矩阵 $A$**：\n        *   对角元素 $A_{ii}$ 使用提供的自作用解析公式计算。\n        *   非对角元素 $A_{ij}$ 通过在分段 $\\Gamma_i$ 和 $\\Gamma_j$ 上的双重数值积分计算，使用 $4 \\times 4$ 张量积高斯-勒让德求积法则。这涉及为所有 $16$ 对求积点计算核函数 $G(x,y)$。\n    *   对于**配置矩阵 $B$**：\n        *   每个元素 $B_{ij}$ 通过在线段 $\\Gamma_j$ 上的单次数值积分计算。核函数 $G(x_i^{\\text{mid}}, y)$ 在 $\\Gamma_j$ 上的 $16$ 个高斯-勒让德求积点处进行评估。严格遵循即使在 $i=j$ 的情况下（此时核函数在积分区间中点是奇异的）也使用此数值求积的指令。\n\n4.  **对称性与收敛性分析**：\n    *   **对称性**：按规定使用弗罗贝尼乌斯范数计算相对不对称性度量 $\\sigma_{\\text{gal}}$ 和 $\\sigma_{\\text{col}}$。理论上，对于正多边形这种高度对称的几何形状，两个矩阵都应是对称的（且是循环矩阵），因此任何不对称性都将归因于浮点表示和求积误差。\n    *   **收敛性**：对于常数密度 $\\phi=1$ 的测试案例，计算离散势 $v^{\\text{gal}} = A\\mathbf{1}$ 和 $v^{\\text{col}} = B\\mathbf{1}$。这些向量中元素绝对值的最大值分别作为误差估计 $e_{\\text{gal}}(N)$ 和 $e_{\\text{col}}(N)$。\n\n主脚本将对每个所需的 $N \\in \\{8, 16, 32\\}$ 值执行此过程，为每个 $N$ 存储四个度量 $(\\sigma_{\\text{col}}, \\sigma_{\\text{gal}}, e_{\\text{col}}, e_{\\text{gal}})$。随后，从连续细化的误差值计算经验收敛率。最后，将所有 $16$ 个计算值收集到一个列表中，并以指定格式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main function to solve the BEM problem, including matrix construction,\n    symmetry analysis, and convergence analysis.\n    \"\"\"\n\n    def compute_metrics_for_N(N: int):\n        \"\"\"\n        Constructs BEM matrices and computes analysis metrics for a polygon with N segments.\n        \n        Args:\n            N (int): The number of segments in the polygonal approximation of the unit circle.\n\n        Returns:\n            A tuple containing:\n            - sigma_col (float): Relative asymmetry of the collocation matrix.\n            - sigma_gal (float): Relative asymmetry of the Galerkin matrix.\n            - e_col (float): Error for the collocation method.\n            - e_gal (float): Error for the Galerkin method.\n        \"\"\"\n        # 1. Geometric Setup\n        # Generate nodes for a regular N-gon inscribed in a unit circle.\n        angles = 2.0 * np.pi * np.arange(N, dtype=np.float64) / N\n        nodes = np.array([np.cos(angles), np.sin(angles)]).T\n\n        # For a regular polygon, all segments have the same length.\n        segment_len = np.linalg.norm(nodes[1] - nodes[0])\n        \n        # Define segment properties\n        start_points = nodes\n        end_points = np.roll(nodes, -1, axis=0)\n        midpoints = (start_points + end_points) / 2.0\n        u_vectors = (end_points - start_points) / (segment_len + 1e-30)\n\n        # 2. Quadrature Setup\n        # Galerkin (off-diagonal): 4 points\n        q_nodes_4, q_weights_4 = roots_legendre(4)\n        q_points_gal = segment_len / 2.0 * (q_nodes_4 + 1.0)\n        q_weights_gal = segment_len / 2.0 * q_weights_4\n\n        # Collocation: 16 points\n        q_nodes_16, q_weights_16 = roots_legendre(16)\n        q_points_col = segment_len / 2.0 * (q_nodes_16 + 1.0)\n        q_weights_col = segment_len / 2.0 * q_weights_16\n\n        # 3. Matrix Assembly\n        A = np.zeros((N, N), dtype=np.float64) # Galerkin matrix\n        B = np.zeros((N, N), dtype=np.float64) # Collocation matrix\n\n        for i in range(N):\n            for j in range(N):\n                # Collocation Matrix B entry B_ij\n                quad_pts_on_j_col = start_points[j] + np.outer(q_points_col, u_vectors[j])\n                dists_col = np.linalg.norm(midpoints[i] - quad_pts_on_j_col, axis=1)\n                kernel_vals_col = -1.0 / (2.0 * np.pi) * np.log(dists_col)\n                B[i, j] = np.sum(kernel_vals_col * q_weights_col)\n\n                # Galerkin Matrix A entry A_ij\n                if i == j:\n                    A[i, i] = -1.0 / (2.0 * np.pi) * (segment_len**2 * np.log(segment_len) - 1.5 * segment_len**2)\n                else:\n                    quad_pts_on_i_gal = start_points[i] + np.outer(q_points_gal, u_vectors[i])\n                    quad_pts_on_j_gal = start_points[j] + np.outer(q_points_gal, u_vectors[j])\n                    dists_gal = np.linalg.norm(quad_pts_on_i_gal[:, None, :] - quad_pts_on_j_gal[None, :, :], axis=2)\n                    kernel_vals_gal = -1.0 / (2.0 * np.pi) * np.log(dists_gal)\n                    weights_prod_gal = np.outer(q_weights_gal, q_weights_gal)\n                    A[i, j] = np.sum(kernel_vals_gal * weights_prod_gal)\n        \n        # 4. Analysis\n        norm_A = np.linalg.norm(A, 'fro')\n        norm_B = np.linalg.norm(B, 'fro')\n        sigma_gal = np.linalg.norm(A - A.T, 'fro') / norm_A if norm_A > 0 else 0.0\n        sigma_col = np.linalg.norm(B - B.T, 'fro') / norm_B if norm_B > 0 else 0.0\n        \n        v_gal = A.sum(axis=1) # Corresponds to A @ ones(N)\n        v_col = B.sum(axis=1) # Corresponds to B @ ones(N)\n        \n        e_gal = np.max(np.abs(v_gal))\n        e_col = np.max(np.abs(v_col))\n\n        return sigma_col, sigma_gal, e_col, e_gal\n\n    # Define the test cases from the problem statement.\n    test_cases_N = [8, 16, 32]\n\n    metrics_results = []\n    error_results_for_rates = {}\n\n    for N in test_cases_N:\n        # Main logic to calculate the result for one case goes here.\n        sig_c, sig_g, e_c, e_g = compute_metrics_for_N(N)\n        metrics_results.extend([sig_c, sig_g, e_c, e_g])\n        error_results_for_rates[N] = {'col': e_c, 'gal': e_g}\n\n    # Post-processing to calculate rates\n    log_h_ratio = np.log(2.0)\n    \n    r_col_8_16 = np.log(error_results_for_rates[8]['col'] / error_results_for_rates[16]['col']) / log_h_ratio\n    r_col_16_32 = np.log(error_results_for_rates[16]['col'] / error_results_for_rates[32]['col']) / log_h_ratio\n    \n    r_gal_8_16 = np.log(error_results_for_rates[8]['gal'] / error_results_for_rates[16]['gal']) / log_h_ratio\n    r_gal_16_32 = np.log(error_results_for_rates[16]['gal'] / error_results_for_rates[32]['gal']) / log_h_ratio\n    \n    rate_results = [r_col_8_16, r_col_16_32, r_gal_8_16, r_gal_16_32]\n    \n    final_output = metrics_results + rate_results\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_output))}]\")\n\nsolve()\n```", "id": "3616082"}, {"introduction": "在掌握了基本的离散化技术后，我们可以进一步探究离散算符的内在属性，这些属性往往源于其背后深刻的物理原理。例如，格林函数的对称性赋予了某些边界积分算符一种称为“互易性”的对称结构。本练习 [@problem_id:3616097] 将让您通过数值实验，检验这种理论上的对称性在多大程度上被离散化过程所保持，并量化几何映射误差等数值因素是如何破坏这种理想属性的。", "problem": "考虑光滑闭合边界 $\\Gamma \\subset \\mathbb{R}^2$ 外部的二维拉普拉斯方程。拉普拉斯算子的基本解（格林函数）为 $G(\\mathbf{x},\\mathbf{y}) = -\\frac{1}{2\\pi}\\log\\|\\mathbf{x}-\\mathbf{y}\\|$，它满足 $G(\\mathbf{x},\\mathbf{y}) = G(\\mathbf{y},\\mathbf{x})$。边界积分互易性意味着由 $G$ 构建的双线性形式在精确几何映射下是对称的。对于标量边界函数 $\\psi$ 和 $\\phi$，定义单层双线性形式 $B(\\psi,\\phi)$ 如下：\n$$\nB(\\psi,\\phi) = \\int_{\\Gamma}\\int_{\\Gamma} G(\\mathbf{x},\\mathbf{y}) \\, \\psi(\\mathbf{x}) \\, \\phi(\\mathbf{y}) \\, \\mathrm{d}s_{\\mathbf{x}} \\, \\mathrm{d}s_{\\mathbf{y}},\n$$\n其中 $\\mathrm{d}s_{\\mathbf{x}}$ 和 $\\mathrm{d}s_{\\mathbf{y}}$ 分别表示 $\\Gamma$ 上在 $\\mathbf{x}$ 和 $\\mathbf{y}$ 处的线元。在精确映射下，$B(\\psi,\\phi) = B(\\phi,\\psi)$。\n\n您的任务是在参数化曲线 $\\Gamma(\\theta)$（其中 $\\theta \\in [0,2\\pi)$）上实现此双线性形式的两种边界元法离散化，并使用基于范数的度量来定量测试所得离散矩阵 $H$ 的对称性。该曲线在参数 $\\theta$ 中被离散为 $N$ 个单元；单元 $i$ 覆盖 $\\theta \\in [\\theta_i,\\theta_{i+1}]$，其中 $\\theta_i = \\frac{2\\pi i}{N}$，我们对每个单元使用分片常数形状函数。\n\n离散化 A (迦辽金法，分片常数)：近似为\n$$\nH_{ij} \\approx \\sum_{p=1}^{n_q} \\sum_{q=1}^{n_q} w^{(i)}_p \\, w^{(j)}_q \\, J(\\theta^{(i)}_p) \\, J(\\theta^{(j)}_q) \\, G\\!\\left(\\Gamma(\\theta^{(i)}_p), \\Gamma(\\theta^{(j)}_q)\\right),\n$$\n其中 $(\\theta^{(i)}_p, w^{(i)}_p)$ 是映射到单元 $i$ 的 $n_q$ 点高斯-勒让德求积节点和权重，而 $J(\\theta) = \\|\\Gamma'(\\theta)\\|$ 是雅可比行列式（度量因子）。为了在 $\\mathbf{x}=\\mathbf{y}$ 时存在对数奇异性的情况下确保数值稳定性，请使用正则化核\n$$\nG_\\delta(\\mathbf{x},\\mathbf{y}) = -\\frac{1}{2\\pi}\\log\\sqrt{\\|\\mathbf{x}-\\mathbf{y}\\|^2 + \\delta^2},\n$$\n其中 $\\delta > 0$ 的选择与下述平均单元长度成正比。\n\n离散化 B (Nyström 配置法，使用分片常数试函数)：对于单元中点 $\\theta^{\\mathrm{c}}_i = \\frac{\\theta_i+\\theta_{i+1}}{2}$，定义\n$$\nH_{ij} \\approx \\sum_{q=1}^{n_q} w^{(j)}_q \\, J(\\theta^{(j)}_q) \\, G_\\delta\\!\\left(\\Gamma(\\theta^{\\mathrm{c}}_i), \\Gamma(\\theta^{(j)}_q)\\right).\n$$\n这种离散化通常不会产生对称矩阵，因为测试函数是点评估的，而试函数是积分的，这在离散层面上破坏了双线性形式的对称性。\n\n几何映射误差模型：为了模拟即使在迦辽金法中也会破坏对称性的映射误差，仅对 $\\mathbf{x}$ 侧的雅可比因子进行如下修改：\n$$\nJ_\\epsilon(\\theta) = J(\\theta)\\left(1 + \\epsilon \\cos(k\\,\\theta)\\right),\n$$\n其中 $\\epsilon \\ge 0$ 控制相对误差大小，$k$ 是一个整数模态指数。$\\mathbf{y}$ 侧保留精确的雅可比行列式 $J(\\theta)$。\n\n对称性度量：对于任何组装的离散矩阵 $H \\in \\mathbb{R}^{N\\times N}$，定义其对称部分和反对称部分\n$$\nH_{\\mathrm{sym}} = \\frac{H + H^\\top}{2}, \\quad H_{\\mathrm{skew}} = \\frac{H - H^\\top}{2},\n$$\n并报告标量度量\n$$\nm = \\frac{\\|H_{\\mathrm{skew}}\\|_F}{\\|H_{\\mathrm{sym}}\\|_F},\n$$\n其中 $\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。该度量是无量纲的。如果矩阵完全对称，则 $m=0$。\n\n正则化选择：令平均单元长度为\n$$\n\\bar{h} = \\frac{1}{N}\\sum_{i=0}^{N-1} \\int_{\\theta_i}^{\\theta_{i+1}} J(\\theta)\\,\\mathrm{d}\\theta,\n$$\n并设置正则化参数为 $\\delta = \\alpha \\,\\bar{h}$，其中固定标量 $\\alpha = 10^{-3}$。\n\n参数化曲线和角度单位：使用以下参数化，其中角度 $\\theta$ 以弧度为单位。\n- 单位圆：$\\Gamma(\\theta) = \\left(\\cos\\theta,\\,\\sin\\theta\\right)$，此时 $J(\\theta) = 1$。\n- 椭圆：$\\Gamma(\\theta) = \\left(a\\cos\\theta,\\,b\\sin\\theta\\right)$，其中 $a>0, b>0$，且 $J(\\theta) = \\sqrt{a^2\\sin^2\\theta + b^2\\cos^2\\theta}$。\n- 星形曲线：$r(\\theta) = 1 + \\rho\\cos(n\\theta)$，$\\Gamma(\\theta) = \\left(r(\\theta)\\cos\\theta,\\,r(\\theta)\\sin\\theta\\right)$，其中 $r'(\\theta) = -\\rho n \\sin(n\\theta)$ 且 $J(\\theta) = \\sqrt{\\left(r'(\\theta)\\cos\\theta - r(\\theta)\\sin\\theta\\right)^2 + \\left(r'(\\theta)\\sin\\theta + r(\\theta)\\cos\\theta\\right)^2}$。\n\n实现基础和要求：\n- 从 $G(\\mathbf{x},\\mathbf{y})$ 的定义、边界积分互易性以及在精确映射下双线性形式 $B(\\psi,\\phi)$ 的对称性开始。\n- 根据测试套件中的指定，使用离散化 A 或 B 组装矩阵 $H$。\n- 每个单元使用 $n_q = 4$ 个高斯-勒让德点。\n- 为每个测试案例计算对称性度量 $m$。\n- 不涉及物理单位；角度必须以弧度为单位。\n- 最终输出必须是单行，包含用方括号括起来的逗号分隔列表的结果，例如 $[\\text{result}_1,\\text{result}_2,\\dots]$。\n\n测试套件：\n- 案例 1：单位圆，离散化 A (迦辽金法)，$N=16$，$\\epsilon=0.0$，$k=3$。\n- 案例 2：单位圆，离散化 B (Nyström 配置法)，$N=16$，$\\epsilon=0.0$，$k=3$。\n- 案例 3：单位圆，离散化 A (迦辽金法)，$N=16$，$\\epsilon=0.05$，$k=3$。\n- 案例 4：单位圆，离散化 A (迦辽金法)，$N=64$，$\\epsilon=0.05$，$k=3$。\n- 案例 5：椭圆，$a=1.0, b=0.5$，离散化 A (迦辽金法)，$N=32$，$\\epsilon=0.0$，$k=3$。\n- 案例 6：椭圆，$a=1.0, b=0.5$，离散化 A (迦辽金法)，$N=32$，$\\epsilon=0.1$，$k=3$。\n- 案例 7：星形曲线，$\\rho=0.3, n=5$，离散化 A (迦辽金法)，$N=64$，$\\epsilon=0.0$，$k=5$。\n- 案例 8：星形曲线，$\\rho=0.3, n=5$，离散化 A (迦辽金法)，$N=64$，$\\epsilon=0.05$，$k=5$。\n\n您的程序必须为这 8 个案例中的每一个计算 $m$，并生成一行包含 8 个浮点数结果的输出，格式如指定。所有角度必须以弧度为单位，且必须按上述说明选择正则化参数。确保程序是自包含的，不需要输入，使用给定的测试套件，并且最终输出格式与指定完全一致。", "solution": "用户要求对所提供的问题进行严格验证，如果问题被认为是有效的，则提供完整的解决方案。\n\n### 问题验证\n\n**第1步：提取已知条件**\n\n*   **方程：** 二维拉普拉斯方程，外部问题。\n*   **基本解：** $G(\\mathbf{x},\\mathbf{y}) = -\\frac{1}{2\\pi}\\log\\|\\mathbf{x}-\\mathbf{y}\\|$。\n*   **双线性形式：** $B(\\psi,\\phi) = \\int_{\\Gamma}\\int_{\\Gamma} G(\\mathbf{x},\\mathbf{y}) \\, \\psi(\\mathbf{x}) \\, \\phi(\\mathbf{y}) \\, \\mathrm{d}s_{\\mathbf{x}} \\, \\mathrm{d}s_{\\mathbf{y}}$。\n*   **边界参数化：** $\\Gamma$ 是由 $\\Gamma(\\theta)$（其中 $\\theta \\in [0,2\\pi)$）参数化的光滑闭合曲线。\n*   **离散化：** $N$ 个单元，单元 $i$ 为 $[\\theta_i, \\theta_{i+1}]$，其中 $\\theta_i = \\frac{2\\pi i}{N}$。形状函数为分片常数。\n*   **离散化 A (迦辽金法)：** $H_{ij} \\approx \\sum_{p=1}^{n_q} \\sum_{q=1}^{n_q} w^{(i)}_p \\, w^{(j)}_q \\, J(\\theta^{(i)}_p) \\, J(\\theta^{(j)}_q) \\, G\\!\\left(\\Gamma(\\theta^{(i)}_p), \\Gamma(\\theta^{(j)}_q)\\right)$。\n*   **离散化 B (Nyström 法)：** $H_{ij} \\approx \\sum_{q=1}^{n_q} w^{(j)}_q \\, J(\\theta^{(j)}_q) \\, G_\\delta\\!\\left(\\Gamma(\\theta^{\\mathrm{c}}_i), \\Gamma(\\theta^{(j)}_q)\\right)$，其中 $\\theta^{\\mathrm{c}}_i = (\\theta_i+\\theta_{i+1})/2$。\n*   **正则化核：** $G_\\delta(\\mathbf{x},\\mathbf{y}) = -\\frac{1}{2\\pi}\\log\\sqrt{\\|\\mathbf{x}-\\mathbf{y}\\|^2 + \\delta^2}$。\n*   **正则化参数：** $\\delta = \\alpha \\,\\bar{h}$，其中 $\\alpha = 10^{-3}$ 且 $\\bar{h} = \\frac{1}{N}\\sum_{i=0}^{N-1} \\int_{\\theta_i}^{\\theta_{i+1}} J(\\theta)\\,\\mathrm{d}\\theta$。\n*   **几何误差模型：** $J_\\epsilon(\\theta) = J(\\theta)\\left(1 + \\epsilon \\cos(k\\,\\theta)\\right)$，应用于 $\\mathbf{x}$ 侧的雅可比行列式。\n*   **对称性度量：** $m = \\frac{\\|H_{\\mathrm{skew}}\\|_F}{\\|H_{\\mathrm{sym}}\\|_F}$，其中 $H_{\\mathrm{sym}} = \\frac{H + H^\\top}{2}$，$H_{\\mathrm{skew}} = \\frac{H - H^\\top}{2}$，且 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。\n*   **曲线几何形状：** 单位圆、椭圆 $\\Gamma(\\theta) = (a\\cos\\theta, b\\sin\\theta)$、星形曲线 $\\Gamma(\\theta) = (r(\\theta)\\cos\\theta, r(\\theta)\\sin\\theta)$。\n*   **数值参数：** $n_q = 4$（每个单元的高斯-勒让德点数），角度以弧度为单位。\n*   **测试套件：** 提供了包含所有已定义参数的 8 个特定案例的列表。\n\n**第2步：使用提取的已知条件进行验证**\n\n*   **科学依据：** 该问题牢固地植根于位势问题理论及其通过边界元法（BEM）的数值求解，这是计算地球物理学、物理学和工程学中的一种标准技术。迦辽金法和 Nyström 法、基本解和数值求积等概念都是标准且正确的。\n*   **适定性：** 问题是适定的。对于每个测试案例，都提供了所有必要的参数、公式和几何定义。目标是计算一个特定的、唯一定义的标量度量 $m$。\n*   **客观性：** 问题以精确、客观的数学语言陈述，没有任何主观或模糊的术语。\n*   **一致性和完整性：** 设置是自包含且一致的。问题提供了实现所需的所有公式，从几何形状到最终度量。需要数值计算平均单元长度 $\\bar{h}$ 的积分是此类数值任务中一个隐含的标准要求，并非不完整的标志。不存在矛盾。\n\n**第3步：结论和行动**\n\n*   **结论：** 问题是有效的。它是偏微分方程数值分析领域一个明确定义的计算任务。\n*   **行动：** 继续进行完整解答。\n\n### 解答\n\n目标是量化对称边界积分算子离散表示中对称性的丧失。连续双线性形式 $B(\\psi, \\phi)$ 的对称性是格林函数对称性 $G(\\mathbf{x},\\mathbf{y}) = G(\\mathbf{y},\\mathbf{x})$ 的直接结果。我们将分析这一基本性质在离散层面上是如何被保持或破坏的。\n\n**1. 离散化框架**\n\n边界 $\\Gamma$ 被划分为 $N$ 个单元。解空间使用分片常数基函数 $\\phi_i(\\mathbf{x})$ 进行近似，其中如果 $\\mathbf{x}$ 在单元 $i$ 上，则 $\\phi_i(\\mathbf{x}) = 1$，否则为 $0$。\n\n双线性形式中的双重积分使用数值求积进行近似。具体来说，我们采用 $n_q$ 点高斯-勒让德求积法则。在 $[-1, 1]$ 上的标准节点 $t_p$ 和权重 $w_p$ 被映射到每个单元 $[\\theta_i, \\theta_{i+1}]$。设 $\\Delta\\theta = \\frac{2\\pi}{N}$ 为参数域中的单元宽度。单元 $i$ 的映射节点和权重为：\n$$\n\\theta^{(i)}_p = \\frac{\\theta_i + \\theta_{i+1}}{2} + \\frac{\\Delta\\theta}{2} t_p = \\frac{\\pi(2i+1)}{N} + \\frac{\\pi}{N} t_p\n$$\n$$\nw^{(i)}_p = \\frac{\\Delta\\theta}{2} w_p = \\frac{\\pi}{N} w_p\n$$\n\n雅可比行列式 $J(\\theta) = \\|\\Gamma'(\\theta)\\|$ 通过 $\\mathrm{d}s = J(\\theta)\\mathrm{d}\\theta$ 将弧长微分 $\\mathrm{d}s$ 与参数微分 $\\mathrm{d}\\theta$ 联系起来。几何误差通过扰动积分的“源”侧的雅可比行列式来建模：$J_\\epsilon(\\theta) = J(\\theta)(1 + \\epsilon \\cos(k\\theta))$。\n\n为了处理当 $\\mathbf{x} \\to \\mathbf{y}$ 时 $G(\\mathbf{x},\\mathbf{y})$ 的对数奇异性，我们使用正则化核 $G_\\delta(\\mathbf{x},\\mathbf{y}) = -\\frac{1}{2\\pi}\\log\\sqrt{\\|\\mathbf{x}-\\mathbf{y}\\|^2 + \\delta^2}$。正则化参数 $\\delta$ 与平均单元长度 $\\bar{h}$ 成比例设置，$\\delta = \\alpha \\bar{h}$ 且 $\\alpha=10^{-3}$。平均单元长度 $\\bar{h} = \\frac{1}{N} \\text{arclength}(\\Gamma)$ 需要计算总弧长，这通过在 $[0, 2\\pi)$ 上对雅可比行列式 $J(\\theta)$ 进行数值积分来完成。\n\n**2. 几何与雅可比行列式**\n\n使用以下几何形状：\n*   **单位圆：** $\\Gamma(\\theta) = (\\cos\\theta, \\sin\\theta)$。其导数为 $\\Gamma'(\\theta) = (-\\sin\\theta, \\cos\\theta)$，因此雅可比行列式为 $J(\\theta) = \\sqrt{(-\\sin\\theta)^2 + (\\cos\\theta)^2} = 1$。\n*   **椭圆：** $\\Gamma(\\theta) = (a\\cos\\theta, b\\sin\\theta)$。其导数为 $\\Gamma'(\\theta) = (-a\\sin\\theta, b\\cos\\theta)$，因此雅可比行列式为 $J(\\theta) = \\sqrt{(-a\\sin\\theta)^2 + (b\\cos\\theta)^2} = \\sqrt{a^2\\sin^2\\theta + b^2\\cos^2\\theta}$。\n*   **星形曲线：** 曲线以极坐标形式给出 $r(\\theta) = 1 + \\rho\\cos(n\\theta)$，因此 $\\Gamma(\\theta) = (r(\\theta)\\cos\\theta, r(\\theta)\\sin\\theta)$。半径的导数为 $r'(\\theta) = -n\\rho\\sin(n\\theta)$。极坐标曲线的雅可比行列式为 $J(\\theta) = \\sqrt{r(\\theta)^2 + r'(\\theta)^2}$。代入可得 $J(\\theta) = \\sqrt{(1 + \\rho\\cos(n\\theta))^2 + (-n\\rho\\sin(n\\theta))^2}$。\n\n**3. 矩阵组装**\n\n**离散化 A (迦辽金法)：**\n迦辽金法对试函数和检验函数使用相同的函数集，从而得到一个离散系统矩阵 $H$，其元素为：\n$H_{ij} = B(\\phi_i, \\phi_j) = \\int_{\\Gamma} \\int_{\\Gamma} G(\\mathbf{x},\\mathbf{y}) \\phi_i(\\mathbf{x}) \\phi_j(\\mathbf{y}) \\mathrm{d}s_{\\mathbf{x}} \\mathrm{d}s_{\\mathbf{y}}$。\n对于分片常数基函数，这变为在单元 $i$ 和单元 $j$ 上的积分。在 $\\mathbf{x}$ 侧（与 $\\phi_i$ 和单元 $i$ 相关）引入几何误差，并应用求积法则，我们得到：\n$$\nH_{ij} = \\sum_{p=1}^{n_q} \\sum_{q=1}^{n_q} w^{(i)}_p w^{(j)}_q J_\\epsilon(\\theta^{(i)}_p) J(\\theta^{(j)}_q) G_\\delta(\\Gamma(\\theta^{(i)}_p), \\Gamma(\\theta^{(j)}_q))\n$$\n当 $\\epsilon=0$ 时，$J_\\epsilon=J$。由于所有单元的求积节点和权重都是对称确定的，并且 $G_\\delta$ 在其参数中是对称的，因此可以得出 $H_{ij} = H_{ji}$。矩阵 $H$ 在数值精度范围内是对称的。当 $\\epsilon > 0$ 时，项 $J_\\epsilon(\\theta^{(i)}_p) J(\\theta^{(j)}_q)$ 不再关于交换索引 $i,p$ 和 $j,q$ 对称，从而破坏了 $H$ 的对称性。\n\n**离散化 B (Nyström 法)：**\nNyström（配置）法在特定点评估积分算子。这里，试函数是分片常数，但检验是在单元中点 $\\mathbf{x}^{\\mathrm{c}}_i = \\Gamma(\\theta^{\\mathrm{c}}_i)$ 进行的。矩阵元素为：\n$H_{ij} = \\int_{\\Gamma_j} G_\\delta(\\mathbf{x}^{\\mathrm{c}}_i, \\mathbf{y}) \\mathrm{d}s_{\\mathbf{y}}$。\n用求积近似积分，得到：\n$$\nH_{ij} = \\sum_{q=1}^{n_q} w^{(j)}_q J(\\theta^{(j)}_q) G_\\delta(\\Gamma(\\theta^{\\mathrm{c}}_i), \\Gamma(\\theta^{(j)}_q))\n$$\n这种形式本质上是非对称的，因为索引 $i$ 和 $j$ 的作用不同：$i$ 索引一个点评估（配置），而 $j$ 索引一个积分单元。没有理由期望 $H_{ij} = H_{ji}$。\n\n**4. 对称性量化**\n\n组装矩阵 $H$ 的不对称程度通过比较其对称部分和反对称部分的大小来衡量，使用弗罗贝尼乌斯范数 $\\|A\\|_F = \\sqrt{\\sum_{k,l} |A_{kl}|^2}$。度量定义为：\n$$\nm = \\frac{\\|H_{\\mathrm{skew}}\\|_F}{\\|H_{\\mathrm{sym}}\\|_F} = \\frac{\\| (H - H^\\top)/2 \\|_F}{\\| (H + H^\\top)/2 \\|_F}\n$$\n这个无量纲度量对于完全对称矩阵为 $0$，并随着不对称程度的增加而增加。\n\n以下程序为指定的测试套件实现了这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate, special\n\n# language: Python\n# version: 3.12\n# libraries:\n#     name: numpy, version: 1.23.5\n#     name: scipy, version: 1.11.4\n\nclass UnitCircle:\n    \"\"\"Represents the unit circle geometry.\"\"\"\n    def __init__(self):\n        pass\n\n    def gamma(self, theta):\n        return np.stack([np.cos(theta), np.sin(theta)], axis=-1)\n\n    def jacobian(self, theta):\n        return np.ones_like(theta) if isinstance(theta, np.ndarray) else 1.0\n\nclass Ellipse:\n    \"\"\"Represents an ellipse geometry.\"\"\"\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def gamma(self, theta):\n        return np.stack([self.a * np.cos(theta), self.b * np.sin(theta)], axis=-1)\n\n    def jacobian(self, theta):\n        return np.sqrt((self.a * np.sin(theta))**2 + (self.b * np.cos(theta))**2)\n\nclass StarShape:\n    \"\"\"Represents a star-shaped geometry.\"\"\"\n    def __init__(self, rho, n):\n        self.rho = rho\n        self.n = n\n\n    def r(self, theta):\n        return 1.0 + self.rho * np.cos(self.n * theta)\n\n    def r_prime(self, theta):\n        return -self.n * self.rho * np.sin(self.n * theta)\n\n    def gamma(self, theta):\n        rad = self.r(theta)\n        return np.stack([rad * np.cos(theta), rad * np.sin(theta)], axis=-1)\n\n    def jacobian(self, theta):\n        return np.sqrt(self.r(theta)**2 + self.r_prime(theta)**2)\n\ndef G_delta(x, y, delta_sq):\n    \"\"\"Regularized 2D Laplace fundamental solution.\"\"\"\n    dist_sq = np.sum((x - y)**2, axis=-1)\n    return -0.5 / np.pi * np.log(np.sqrt(dist_sq + delta_sq))\n\ndef solve():\n    \"\"\"Main solver function.\"\"\"\n    test_cases = [\n        # Case 1\n        {'geom_type': 'circle', 'discr': 'A', 'N': 16, 'eps': 0.0, 'k': 3, 'params': {}},\n        # Case 2\n        {'geom_type': 'circle', 'discr': 'B', 'N': 16, 'eps': 0.0, 'k': 3, 'params': {}},\n        # Case 3\n        {'geom_type': 'circle', 'discr': 'A', 'N': 16, 'eps': 0.05, 'k': 3, 'params': {}},\n        # Case 4\n        {'geom_type': 'circle', 'discr': 'A', 'N': 64, 'eps': 0.05, 'k': 3, 'params': {}},\n        # Case 5\n        {'geom_type': 'ellipse', 'discr': 'A', 'N': 32, 'eps': 0.0, 'k': 3, 'params': {'a': 1.0, 'b': 0.5}},\n        # Case 6\n        {'geom_type': 'ellipse', 'discr': 'A', 'N': 32, 'eps': 0.1, 'k': 3, 'params': {'a': 1.0, 'b': 0.5}},\n        # Case 7\n        {'geom_type': 'star', 'discr': 'A', 'N': 64, 'eps': 0.0, 'k': 5, 'params': {'rho': 0.3, 'n': 5}},\n        # Case 8\n        {'geom_type': 'star', 'discr': 'A', 'N': 64, 'eps': 0.05, 'k': 5, 'params': {'rho': 0.3, 'n': 5}},\n    ]\n\n    alpha = 1e-3\n    nq = 4\n    gl_nodes, gl_weights = special.roots_legendre(nq)\n    \n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        eps = case['eps']\n        k = case['k']\n        \n        if case['geom_type'] == 'circle':\n            geometry = UnitCircle()\n        elif case['geom_type'] == 'ellipse':\n            geometry = Ellipse(**case['params'])\n        elif case['geom_type'] == 'star':\n            geometry = StarShape(**case['params'])\n\n        panel_thetas = np.linspace(0, 2 * np.pi, N + 1)\n        total_length, _ = integrate.quad(geometry.jacobian, 0, 2 * np.pi)\n        h_bar = total_length / N\n        delta = alpha * h_bar\n        delta_sq = delta**2\n\n        H = np.zeros((N, N))\n        \n        # Precompute quadrature points and jacobians for all panels\n        panel_centers = (panel_thetas[:-1] + panel_thetas[1:]) / 2\n        panel_half_widths = (panel_thetas[1:] - panel_thetas[:-1]) / 2\n\n        quad_thetas = panel_centers[:, None] + panel_half_widths[:, None] * gl_nodes[None, :]\n        quad_weights_scaled = panel_half_widths[:, None] * gl_weights[None, :]\n        \n        quad_coords = geometry.gamma(quad_thetas) # Shape (N, nq, 2)\n        quad_jac = geometry.jacobian(quad_thetas) # Shape (N, nq)\n        \n        def jacobian_eps(theta, jacobian_val, eps_val, k_val):\n            return jacobian_val * (1.0 + eps_val * np.cos(k_val * theta))\n\n        if case['discr'] == 'A': # Galerkin\n            quad_jac_eps = jacobian_eps(quad_thetas, quad_jac, eps, k)\n            \n            for i in range(N):\n                for j in range(N):\n                    # Coordinates for panel i and j\n                    coords_i = quad_coords[i, :, :] # (nq, 2)\n                    coords_j = quad_coords[j, :, :] # (nq, 2)\n                    \n                    # Create a grid of points (i_p, j_q)\n                    # Broadcasting helps compute all pairwise distances\n                    # coords_i[:, None, :] -> (nq, 1, 2)\n                    # coords_j[None, :, :] -> (1, nq, 2)\n                    # Difference -> (nq, nq, 2)\n                    G_matrix = G_delta(coords_i[:, None, :], coords_j[None, :, :], delta_sq)\n\n                    # Weights and Jacobians\n                    w_jac_eps_i = quad_weights_scaled[i, :] * quad_jac_eps[i, :]\n                    w_jac_j = quad_weights_scaled[j, :] * quad_jac[j, :]\n\n                    H[i, j] = w_jac_eps_i @ G_matrix @ w_jac_j\n\n        elif case['discr'] == 'B': # Nystrom\n            collocation_points = geometry.gamma(panel_centers)\n            for i in range(N):\n                for j in range(N):\n                    # Collocation point for panel i\n                    coll_pt_i = collocation_points[i, :] # (2,)\n                    \n                    # Quadrature points for panel j\n                    coords_j = quad_coords[j, :, :] # (nq, 2)\n                    \n                    # G_delta between point and array of points\n                    G_vals = G_delta(coll_pt_i[None, :], coords_j, delta_sq) # (nq,)\n                    \n                    # Weights and Jacobian for panel j\n                    w_jac_j = quad_weights_scaled[j, :] * quad_jac[j, :]\n                    \n                    H[i, j] = np.dot(w_jac_j, G_vals)\n        \n        # Compute symmetry metric\n        H_sym = (H + H.T) / 2\n        H_skew = (H - H.T) / 2\n        \n        norm_sym = np.linalg.norm(H_sym, 'fro')\n        norm_skew = np.linalg.norm(H_skew, 'fro')\n        \n        if norm_sym > 1e-15:\n            m = norm_skew / norm_sym\n        else:\n            m = 0.0 if norm_skew  1e-15 else np.inf\n            \n        results.append(m)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```", "id": "3616097"}, {"introduction": "将边界元方法应用于弹性静力学等实际工程问题时，我们常会遇到一个特殊挑战：刚体位移模式。对于一个无约束的弹性体，其控制方程的解并非唯一，因为整个物体可以进行平移和旋转而不产生应力。本练习 [@problem_id:3616146] 通过一个精心设计的代数模型，模拟了这一现象，并指导您如何通过施加约束来消除这些零能模式，从而获得唯一且具有物理意义的解。", "problem": "考虑一个用于线性弹性静力学的二维边界元离散化，该离散化建立在一个光滑闭合边界上，具有 $N$ 个边界节点，并在单位圆上进行参数化。在二维情况下，刚体运动空间维度为 $3$（两个平移和一个平面内旋转）。在离散层面，这表现为边界积分算子的一个非平凡零空间，因此组装后的线性系统会表现出与这些刚体模态相对应的秩亏。对于相关的有限维算子，Fredholm 择一性指出，对于一个由紧算子加有限秩算子扰动而产生的线性系统 $A x = b$（在此离散设置中，为一个具有非平凡零空间的对称半正定矩阵），其可解性要求 $b$ 与 $A^{\\top}$ 的零空间正交。当系统因刚体模态而欠定或存在非唯一解时，可以通过拉格朗日乘子施加辅助约束来消除这些模态并恢复解的唯一性。\n\n您将实现一个完全确定性的、综合的、但物理上一致的代数模型来模拟这种情况。目标是构造一个对称半正定矩阵 $A \\in \\mathbb{R}^{(2N)\\times(2N)}$，其零空间由离散刚体模态张成；通过拉格朗日乘子施加边界约束以消除这些模态；并在完全和有限边界测量下测试其可解性。构造过程必须如下：\n\n- 几何与刚体模态：\n  - 令 $N$ 为边界节点数，取 $N = 12$。在单位圆上以角度 $\\theta_i = \\frac{2\\pi i}{N}$（$i = 0,1,\\dots,N-1$）放置节点，得到坐标 $x_i = \\cos(\\theta_i)$ 和 $y_i = \\sin(\\theta_i)$。\n  - 按节点堆叠位移分量，以形成 $\\mathbb{R}^{2N}$ 中的向量，其顺序为 $(u_{x,0},u_{y,0},u_{x,1},u_{y,1},\\dots,u_{x,N-1},u_{y,N-1})^{\\top}$。\n  - 定义三个离散刚体模态向量 $v_1, v_2, v_3 \\in \\mathbb{R}^{2N}$：\n    - $v_1$ 对应于 $x$ 方向的平移：对所有 $i$，$u_{x,i} = 1, u_{y,i} = 0$。\n    - $v_2$ 对应于 $y$ 方向的平移：对所有 $i$，$u_{x,i} = 0, u_{y,i} = 1$。\n    - $v_3$ 对应于绕原点的平面内旋转：对所有 $i$，$u_{x,i} = -y_i, u_{y,i} = x_i$。\n  - 令 $V = [v_1\\ v_2\\ v_3] \\in \\mathbb{R}^{(2N)\\times 3}$。\n\n- 通过拉格朗日乘子施加约束：\n  - 对每个节点使用常数边界元权重 $w_i = \\frac{2\\pi}{N}$。构造一个对角权重矩阵 $W \\in \\mathbb{R}^{(2N)\\times(2N)}$，其中每个 $w_i$ 对 $u_{x,i}$ 和 $u_{y,i}$ 重复出现。\n  - 定义约束矩阵 $C \\in \\mathbb{R}^{3\\times(2N)}$ 为 $C = V^{\\top} W$。施加 $C x = 0$ 会消除 $x$ 沿刚体模态方向的加权平均分量。\n\n- 综合边界积分算子：\n  - 令 $n = 2N$。使用固定的伪随机数生成器种子，构造一个随机矩阵 $R \\in \\mathbb{R}^{(n-3)\\times n}$，并将其投影到 $\\operatorname{span}(V)$ 的正交补上，以获得 $\\widetilde{R} = R (I - P)$，其中 $P = V (V^{\\top} V)^{-1} V^{\\top}$ 是到 $\\operatorname{span}(V)$ 上的欧几里得投影算子，$I$ 是 $\\mathbb{R}^{n\\times n}$ 中的单位矩阵。然后构造\n  $$\n  A = \\widetilde{R}^{\\top} \\widetilde{R} + \\gamma (I - P),\n  $$\n  其中 $\\gamma = 10^{-1}$。根据构造，$A$ 是对称半正定的，且其零空间为 $\\operatorname{Null}(A) = \\operatorname{span}(V)$。\n\n- 右端项与测量：\n  - 通过抽取一个随机向量并将其投影到 $C$ 的零空间上，以满足 $C x_{\\mathrm{true}} = 0$，来生成基准位移 $x_{\\mathrm{true}} \\in \\mathbb{R}^{n}$。定义完整的右端项 $b_{\\mathrm{full}} = A x_{\\mathrm{true}}$。\n  - 考虑用于选择 $A x = b$ 方程子集（行）的测量掩码。如果 $S \\subset \\{0,1,\\dots,n-1\\}$ 是被测方程的索引集，则定义 $A_S$ 为由 $A$ 中索引在 $S$ 内的行组成的子矩阵，$b_S$ 为 $b$ 中对应的项。\n  - 为施加约束 $C x = 0$，将可行解参数化为 $x = N y$，其中 $N \\in \\mathbb{R}^{n\\times(n-3)}$ 的列构成了 $\\operatorname{Null}(C)$ 的一组标准正交基。求解约束最小二乘系统\n    $$\n    \\min_{y \\in \\mathbb{R}^{n-3}} \\|A_S N y - b_S\\|_2^2,\n    $$\n    当且仅当 $b_S$ 位于 $A_S N$ 的值域内时，该系统是相容的。\n  - 通过将相对残差 $\\|A_S N \\hat{y} - b_S\\|_2 / \\max(\\|b_S\\|_2, \\varepsilon)$ 与容差 $\\tau$ 进行比较来报告可解性，其中 $\\varepsilon = 10^{-16}$ 是一个安全下限，$\\tau = 10^{-8}$。\n\n您的程序必须使用以下固定参数来实现上述构造，以确保可复现性：\n- 边界节点数 $N = 12$。\n- 算子构造的随机种子 $= 2025$。\n- 基准位移的随机种子 $= 7$。\n- 权重参数 $\\gamma = 10^{-1}$。\n- 容差 $\\tau = 10^{-8}$。\n\n按如下方式定义四个测试用例：\n- 测试 $1$（完全、相容）：$S = \\{0,1,\\dots,n-1\\}$ 且 $b = b_{\\mathrm{full}}$。\n- 测试 $2$（完全、不相容）：$S = \\{0,1,\\dots,n-1\\}$ 且 $b = b_{\\mathrm{full}} + \\alpha \\,\\hat{v}_3$，其中 $\\hat{v}_3 = v_3 / \\|v_3\\|_2$ 且 $\\alpha = \\|b_{\\mathrm{full}}\\|_2$。\n- 测试 $3$（有限、相容）：$S = \\{0,2,4,\\dots,n-2\\}$（每个偶数索引）且 $b = b_{\\mathrm{full}}$ 限制在 $S$ 上。\n- 测试 $4$（无测量）：$S = \\varnothing$ 且 $b$ 为空，在约束条件下平凡可解。\n\n对每个测试，计算一个布尔结果，指示约束最小二乘残差是否低于 $\\tau$。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，`[{\\rm True},{\\rm False},{\\rm True},{\\rm True}]`）。不涉及物理单位；所有量均为无量纲。角度以弧度为单位。", "solution": "该问题要求实现并分析一个模拟线性弹性静力学二维边界元法（BEM）公式的综合代数系统。此类系统的一个关键特征是系统矩阵中存在与刚体运动（RBMs）相对应的非平凡零空间。解决方案通过构造一个具有预定义零空间的系统，施加约束以确保解的唯一性，并在各种测量场景下评估可解性来解决此问题。\n\n边界节点数给定为 $N=12$。节点位于单位圆上的坐标 $(x_i, y_i)$ 处，由 $x_i = \\cos(\\theta_i)$ 和 $y_i = \\sin(\\theta_i)$ 定义，其中角度为 $\\theta_i = \\frac{2\\pi i}{N}$，$i \\in \\{0, 1, \\dots, N-1\\}$。位移向量 $x \\in \\mathbb{R}^{n}$（其中 $n=2N=24$）是通过堆叠每个节点位移的 $x$ 和 $y$ 分量形成的：$x = (u_{x,0}, u_{y,0}, u_{x,1}, u_{y,1}, \\dots, u_{x,N-1}, u_{y,N-1})^{\\top}$。\n\n在二维弹性静力学中，存在三种刚体模态：两个平移和一个平面内旋转。它们由三个向量 $v_1, v_2, v_3 \\in \\mathbb{R}^{n}$ 表示：\n-   $x$ 方向平移，$v_1$：每个节点的位移为 $(1, 0)$，因此 $v_1$ 的项为对所有 $i$，$u_{x,i}=1$ 且 $u_{y,i}=0$。\n-   $y$ 方向平移，$v_2$：每个节点的位移为 $(0, 1)$，因此 $v_2$ 的项为对所有 $i$，$u_{x,i}=0$ 且 $u_{y,i}=1$。\n-   绕原点旋转，$v_3$：角度为 $\\phi$ 的小角度旋转将点 $(x_i, y_i)$ 映射到近似于 $(x_i - \\phi y_i, y_i + \\phi x_i)$ 的位置。因此，位移向量为 $(-y_i, x_i)$。向量 $v_3$ 的项为：对所有 $i$，$u_{x,i}=-y_i$ 且 $u_{y,i}=x_i$。\n\n这三个向量被组装成一个矩阵 $V = [v_1, v_2, v_3] \\in \\mathbb{R}^{n \\times 3}$。$V$ 的列空间 $\\operatorname{span}(V)$ 表示离散边界所有可能的刚体运动空间。\n\n为了获得弹性静力学问题 $Ax=b$ 的唯一解，必须消除由刚体运动（RBMs）引入的模糊性。这通过对解向量 $x$ 施加约束来实现。指定的约束为 $Cx = 0$，其中约束矩阵 $C \\in \\mathbb{R}^{3 \\times n}$ 由 $C = V^{\\top}W$ 给出。这里，$W \\in \\mathbb{R}^{n \\times n}$ 是一个对角求积权重矩阵。当边界元权重为常数 $w_i = \\frac{2\\pi}{N}$ 时，$W$ 就是 $\\frac{2\\pi}{N}$ 乘以单位矩阵。条件 $Cx=0$ 强制解 $x$ 在三个刚体模态方向上的加权平均分量为零，从而有效地“钉住”物体，防止刚体运动。因此，容许解空间是 $C$ 的零空间，即 $\\operatorname{Null}(C)$。\n\n问题的核心是构造一个综合系统矩阵 $A \\in \\mathbb{R}^{n \\times n}$，该矩阵是对称半正定（SPSD）的，并且其零空间恰好是刚体模态空间，即 $\\operatorname{Null}(A) = \\operatorname{span}(V)$。构造过程如下：\n首先，我们定义到 $\\operatorname{span}(V)$ 上的欧几里得投影 $P$：\n$$P = V (V^{\\top} V)^{-1} V^{\\top}$$\n矩阵 $I-P$ 则是到 $\\operatorname{span}(V)$ 正交补上的投影。使用固定的种子生成一个随机矩阵 $R \\in \\mathbb{R}^{(n-3) \\times n}$ 以保证可复现性。该矩阵被投影到与刚体运动空间正交的空间上：\n$$\\widetilde{R} = R (I - P)$$\n最后，系统矩阵 $A$ 被组装为：\n$$A = \\widetilde{R}^{\\top} \\widetilde{R} + \\gamma (I - P)$$\n给定常数 $\\gamma = 10^{-1}$。让我们验证一下 $A$ 的性质。\n-   对称性：$A^{\\top} = (\\widetilde{R}^{\\top} \\widetilde{R})^{\\top} + \\gamma (I - P)^{\\top} = \\widetilde{R}^{\\top} \\widetilde{R}^{\\top\\top} + \\gamma(I-P) = A$，因为 $P$ 是一个对称投影。\n-   半正定性：对于任意向量 $z \\in \\mathbb{R}^n$，$z^{\\top}Az = z^{\\top}\\widetilde{R}^{\\top}\\widetilde{R}z + \\gamma z^{\\top}(I-P)z = \\|\\widetilde{R}z\\|_2^2 + \\gamma \\|(I-P)z\\|_2^2 \\ge 0$，因为 $\\gamma  0$ 且 $I-P$ 也是一个投影。\n-   零空间：$Az=0$ 当且仅当上述和中的两项都为零。$\\gamma \\|(I-P)z\\|_2^2 = 0$ 意味着 $(I-P)z=0$，即 $z=Pz$，所以 $z \\in \\operatorname{span}(V)$。如果 $z \\in \\operatorname{span}(V)$，则 $(I-P)z = 0$，这又意味着 $\\widetilde{R}z = R(I-P)z = 0$。因此，$Az=0$ 当且仅当 $z \\in \\operatorname{span}(V)$。此构造是合理的。\n\n问题接着要求在约束 $Cx=0$ 下求解系统 $A_S x = b_S$，其中 $S$ 是一个测量行索引的集合。该约束通过将解参数化为 $x=Ny$ 来处理，其中 $N \\in \\mathbb{R}^{n \\times (n-3)}$ 的列构成了 $\\operatorname{Null}(C)$ 的一组标准正交基。将此代入系统，得到一个关于系数向量 $y \\in \\mathbb{R}^{n-3}$ 的无约束问题：\n$$ A_S N y = b_S $$\n该系统在最小二乘意义下求解，即最小化 $\\|A_S N y - b_S\\|_2^2$。求得 $y$ 的一个解，记为 $\\hat{y}$。通过检查相对残差是否低于容差 $\\tau = 10^{-8}$ 来确定可解性：\n$$ \\frac{\\|A_S N \\hat{y} - b_S\\|_2}{\\max(\\|b_S\\|_2, \\varepsilon)}  \\tau $$\n其中 $\\varepsilon = 10^{-16}$ 是一个数值下限。\n\n这四个测试用例旨在探究该系统的行为：\n1.  **完全、相容**：右端项为 $b_{\\mathrm{full}} = A x_{\\mathrm{true}}$，其中 $x_{\\mathrm{true}}$ 被构造成位于 $\\operatorname{Null}(C)$ 中。系统 $Ax = b_{\\mathrm{full}}$ 求解 $x \\in \\operatorname{Null}(C)$。由于 $b_{\\mathrm{full}}$ 位于 $A$ 的值域内，并且我们在容许解空间中寻找解，因此应该存在一个解，残差应接近于零。\n2.  **完全、不相容**：将来自 $A$ 零空间的向量 $\\hat{v}_3$ 添加到右端项。得到的向量 $b = b_{\\mathrm{full}} + \\alpha \\hat{v}_3$ 不再位于 $A$ 的值域内（因为 $\\operatorname{Range}(A) = (\\operatorname{Null}(A^{\\top}))^{\\perp} = (\\operatorname{Null}(A))^{\\perp}$）。最小二乘问题的残差将不为零，对应于 $b$ 在 $A^{\\top}$ 零空间上的投影。\n3.  **有限、相容**：该系统是欠定的，方程数量（$A$ 的行数）少于未知数数量（$N$ 的列数）。然而，右端项 $b_S$ 是由 $x_{\\mathrm{true}}$ 生成的，确保了 $b_S = (A x_{\\mathrm{true}})_S = (A N y_{\\mathrm{true}})_S = (A_S N) y_{\\mathrm{true}}$。因此，$b_S$ 位于 $A_S N$ 的值域内，系统是相容的，残差应接近于零。\n4.  **无测量**：一个空的方程组是平凡相容的。残差也自然为零。\n\n算法的流程是：构造所有矩阵，为每个测试用例生成数据，求解相应的约束最小二乘问题，并评估可解性准则。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Implements the synthetic boundary element method model, constructs the system,\n    and tests solvability for four different cases.\n    \"\"\"\n    # Define fixed parameters from the problem statement.\n    N = 12\n    n = 2 * N\n    gamma = 10**-1\n    tau = 10**-8\n    epsilon = 10**-16\n    seed_op = 2025\n    seed_disp = 7\n\n    # 1. Geometry and rigid body modes\n    thetas = np.array([2 * np.pi * i / N for i in range(N)])\n    node_coords = np.array([np.cos(thetas), np.sin(thetas)]).T\n\n    # Construct rigid body mode vectors v1, v2, v3\n    v1 = np.zeros(n)\n    v1[0::2] = 1.0  # x-translation\n\n    v2 = np.zeros(n)\n    v2[1::2] = 1.0  # y-translation\n\n    v3 = np.zeros(n)\n    v3[0::2] = -node_coords[:, 1]  # -y_i for rotation\n    v3[1::2] = node_coords[:, 0]   #  x_i for rotation\n\n    V = np.vstack([v1, v2, v3]).T  # V is (n, 3)\n\n    # 2. Constraints via Lagrange multipliers\n    w_i = (2 * np.pi) / N\n    W = np.diag(np.full(n, w_i))\n    C = V.T @ W  # C is (3, n)\n\n    # 3. Synthetic boundary integral operator\n    # Orthonormal basis for Null(C)\n    N_basis = null_space(C)  # N_basis is (n, n-3)\n\n    # Projector onto span(V)\n    I_n = np.identity(n)\n    P = V @ np.linalg.inv(V.T @ V) @ V.T\n\n    # Generate random matrix R\n    rng_op = np.random.default_rng(seed_op)\n    R = rng_op.standard_normal(size=(n - 3, n))\n\n    # Project R\n    R_tilde = R @ (I_n - P)\n\n    # Construct operator A\n    A = R_tilde.T @ R_tilde + gamma * (I_n - P)\n\n    # 4. Right-hand sides and measurements\n    # Generate ground-truth displacement x_true in Null(C)\n    rng_disp = np.random.default_rng(seed_disp)\n    x_rand = rng_disp.standard_normal(size=n)\n    x_true = N_basis @ (N_basis.T @ x_rand)\n\n    # Generate full right-hand side\n    b_full = A @ x_true\n\n    # Define test cases\n    v3_hat = v3 / np.linalg.norm(v3)\n    alpha = np.linalg.norm(b_full)\n    \n    test_cases_defs = [\n        # Test 1: Full, consistent\n        {'S': np.arange(n), 'b_source': b_full},\n        # Test 2: Full, incompatible\n        {'S': np.arange(n), 'b_source': b_full + alpha * v3_hat},\n        # Test 3: Limited, consistent\n        {'S': np.arange(0, n, 2), 'b_source': b_full},\n        # Test 4: No measurements\n        {'S': np.array([], dtype=int), 'b_source': b_full}\n    ]\n\n    results = []\n    for case in test_cases_defs:\n        S = case['S']\n        b_full_source = case['b_source']\n        \n        # Sub-sample A and b\n        A_S = A[S, :]\n        b_S = b_full_source[S]\n\n        # Form the least-squares system matrix\n        M = A_S @ N_basis\n\n        # Solve the least-squares problem min||My - b_S||^2\n        y_hat, residuals, rank, s = np.linalg.lstsq(M, b_S, rcond=None)\n\n        # Calculate the residual norm from the solution y_hat\n        if M.shape[0] == 0: # Empty system\n            residual_norm = 0.0\n        else:\n            residual_norm = np.linalg.norm(M @ y_hat - b_S)\n\n        b_S_norm = np.linalg.norm(b_S)\n        \n        # Calculate relative residual\n        relative_residual = residual_norm / max(b_S_norm, epsilon)\n        \n        # Check for solvability\n        is_solvable = relative_residual  tau\n        results.append(is_solvable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3616146"}]}