{"hands_on_practices": [{"introduction": "球谐函数构成了一个正交归一基，这导致了一个类似于傅里叶级数的帕塞瓦尔定理的强大性质。该恒等式将空间域中场的总能量（积分平方幅值）与谱域中其系数的平方幅值之和相等同，是球谐分析的基石。本练习通过数值方法验证该恒等式，从而加深对球面上正交归一性和数值积分概念的理解。[@problem_id:3615105]", "problem": "您的任务是，在选定的归一化方案下，推导单位球面上的球谐函数的 Parseval 恒等式，并进行数值验证。考虑单位球面上的完全归一化复球谐函数基 $\\{Y_{l}^{m}(\\theta,\\phi)\\}$，其中 $l \\in \\{0,1,2,\\dots\\}$ 且 $m \\in \\{-l,-l+1,\\dots,l\\}$。角度必须以弧度处理。该完全归一化基在单位球面上满足正交归一性条件，\n$$\n\\int_{0}^{2\\pi}\\int_{0}^{\\pi} Y_{l}^{m}(\\theta,\\phi)\\,Y_{l'}^{m'}(\\theta,\\phi)^{*}\\,\\sin\\theta\\,d\\theta\\,d\\phi = \\delta_{ll'}\\,\\delta_{mm'},\n$$\n在变量替换 $\\mu=\\cos\\theta$ 下，该条件给出\n$$\n\\int_{0}^{2\\pi}\\int_{-1}^{1} Y_{l}^{m}(\\arccos\\mu,\\phi)\\,Y_{l'}^{m'}(\\arccos\\mu,\\phi)^{*}\\,d\\mu\\,d\\phi = \\delta_{ll'}\\,\\delta_{mm'}.\n$$\n定义一个截断的球谐展开为\n$$\nf(\\theta,\\phi) = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} f_{lm}\\,Y_{l}^{m}(\\theta,\\phi),\n$$\n其中 $L$ 是一个非负整数截断阶数，$f_{lm} \\in \\mathbb{C}$ 是展开系数。在上述归一化方案下，为此展开推导 Parseval 恒等式：\n$$\n\\int_{0}^{2\\pi}\\int_{-1}^{1} \\left| f(\\arccos\\mu,\\phi) \\right|^{2}\\,d\\mu\\,d\\phi = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} |f_{lm}|^{2}.\n$$\n然后，使用单位球面上的求积方法实现数值验证。使用以下计算策略：\n- 在一个张量积网格上构建场 $f(\\theta,\\phi)$。其中 $\\theta$ 节点通过在 $\\mu=\\cos\\theta$ 上使用 Gauss–Legendre 求积获得，$\\phi$ 节点通过在 $[0,2\\pi)$ 上使用均匀梯形法则获得。\n- 通过在网格上对 $d\\mu$ 使用 Gauss–Legendre 权重、对 $d\\phi$ 使用均匀权重进行求和，来数值近似积分 $\\int_{0}^{2\\pi}\\int_{-1}^{1} |f(\\arccos\\mu,\\phi)|^{2}\\,d\\mu\\,d\\phi$，即，\n$$\n\\int_{0}^{2\\pi}\\int_{-1}^{1} |f(\\arccos\\mu,\\phi)|^{2}\\,d\\mu\\,d\\phi \\approx \\sum_{i=1}^{N_{\\theta}} \\sum_{j=1}^{N_{\\phi}} w_{i}\\,\\Delta\\phi\\,\\left|f(\\theta_{i},\\phi_{j})\\right|^{2},\n$$\n其中 $\\{\\mu_{i},w_{i}\\}_{i=1}^{N_{\\theta}}$ 是 Gauss–Legendre 节点和权重，$\\theta_{i}=\\arccos(\\mu_{i})$，$\\phi_{j}=2\\pi j/N_{\\phi}$，且 $\\Delta\\phi=2\\pi/N_{\\phi}$。\n- 将数值结果与解析和 $\\sum_{l=0}^{L}\\sum_{m=-l}^{l} |f_{lm}|^{2}$ 进行比较，并报告由下式定义的相对误差\n$$\n\\varepsilon = \\frac{\\left|\\left(\\sum_{i=1}^{N_{\\theta}}\\sum_{j=1}^{N_{\\phi}} w_{i}\\,\\Delta\\phi\\,|f(\\theta_{i},\\phi_{j})|^{2}\\right) - \\left(\\sum_{l=0}^{L}\\sum_{m=-l}^{l} |f_{lm}|^{2}\\right)\\right|}{\\sum_{l=0}^{L}\\sum_{m=-l}^{l} |f_{lm}|^{2}}.\n$$\n\n为进行验证，直接从随机选择的系数 $\\{f_{lm}\\}$ 合成场 $f(\\theta,\\phi)$，而不是从 $f(\\theta,\\phi)$ 数值计算 $\\{f_{lm}\\}$。使用可靠的数值库提供的完全归一化球谐函数。确保对于实值场的情况，强制执行共轭对称约束 $f_{l,-m}=(-1)^{m} f_{lm}^{*}$ 和 $f_{l0}\\in\\mathbb{R}$，以使 $f(\\theta,\\phi)\\in\\mathbb{R}$。\n\n角度必须以弧度为单位。除角度单位外，不使用任何物理单位。您的程序必须实现以下测试套件，并为每个测试用例生成相对误差：\n- 测试 1 (正常路径，单极子): $L=0$，$N_{\\theta}=8$，$N_{\\phi}=16$，实值场，随机种子 $42$。\n- 测试 2 (中等，复数场): $L=3$，$N_{\\theta}=40$，$N_{\\phi}=80$，复值场，随机种子 $7$。\n- 测试 3 (更高 $L$，复数场): $L=10$，$N_{\\theta}=64$，$N_{\\phi}=128$，复值场，随机种子 $123$。\n- 测试 4 (更高 $L$，实数场): $L=12$，$N_{\\theta}=80$，$N_{\\phi}=160$，实值场，随机种子 $9001$。\n- 测试 5 (边界情况，粗糙网格): $L=20$，$N_{\\theta}=41$，$N_{\\phi}=41$，复值场，随机种子 $2023$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表 (例如，“[result1,result2,result3,result4,result5]”)。每个结果必须是等于相应测试用例相对误差 $\\varepsilon$ 的浮点数。", "solution": "该问题要求推导截断球谐展开的 Parseval 恒等式并进行数值验证。此问题具有科学依据，提法明确，并包含了获得唯一解所需的所有信息。\n\n### 第 1 部分：Parseval 恒等式的推导\n\nParseval 恒等式将函数在其定义域上的平方幅值积分与其在正交归一基下的展开系数的平方幅值之和联系起来。我们需要为一个由截断球谐展开表示的单位球面上的函数 $f(\\theta,\\phi)$ 推导该恒等式。\n\n设函数 $f(\\theta,\\phi)$ 由其展开至最大阶数 $L$ 定义：\n$$\nf(\\theta,\\phi) = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} f_{lm}\\,Y_{l}^{m}(\\theta,\\phi)\n$$\n其中 $f_{lm} \\in \\mathbb{C}$ 是球谐系数，$\\{Y_{l}^{m}(\\theta,\\phi)\\}$ 是完全归一化复球谐函数的基。分析将使用变量 $\\mu = \\cos\\theta$ 进行，单位球面上的面积元为 $d\\Omega = d\\mu\\,d\\phi = \\sin\\theta\\,d\\theta\\,d\\phi$。\n\n该基的正交归一化条件为：\n$$\n\\int_{0}^{2\\pi}\\int_{-1}^{1} Y_{l}^{m}(\\arccos\\mu,\\phi)\\,Y_{l'}^{m'}(\\arccos\\mu,\\phi)^{*}\\,d\\mu\\,d\\phi = \\delta_{ll'}\\,\\delta_{mm'}\n$$\n其中 $Y_{l'}^{m'}(\\cdot)^{*}$ 是 $Y_{l'}^{m'}(\\cdot)$ 的复共轭，$\\delta_{ij}$ 是 Kronecker delta。\n\n我们希望计算 $f(\\theta,\\phi)$ 的平方幅值在单位球面上的积分。这个量通常与场的总功率或能量有关，其表达式为：\n$$\nI = \\int_{0}^{2\\pi}\\int_{-1}^{1} \\left| f(\\arccos\\mu,\\phi) \\right|^{2}\\,d\\mu\\,d\\phi\n$$\n我们可以将 $|f|^2$ 写为 $f \\cdot f^*$。代入 $f$ 及其复共轭 $f^*$ 的展开式：\n$$\nf(\\arccos\\mu,\\phi)^{*} = \\left( \\sum_{l'=0}^{L}\\sum_{m'=-l'}^{l'} f_{l'm'}\\,Y_{l'}^{m'}(\\arccos\\mu,\\phi) \\right)^{*} = \\sum_{l'=0}^{L}\\sum_{m'=-l'}^{l'} f_{l'm'}^{*}\\,Y_{l'}^{m'}(\\arccos\\mu,\\phi)^{*}\n$$\n注意，为清晰起见，在展开乘积时我们使用了不同的求和索引 $(l', m')$。\n\n现在，将这些展开式代入 $I$ 的积分中：\n$$\nI = \\int_{0}^{2\\pi}\\int_{-1}^{1} \\left( \\sum_{l=0}^{L}\\sum_{m=-l}^{l} f_{lm}\\,Y_{l}^{m}(\\arccos\\mu,\\phi) \\right) \\left( \\sum_{l'=0}^{L}\\sum_{m'=-l'}^{l'} f_{l'm'}^{*}\\,Y_{l'}^{m'}(\\arccos\\mu,\\phi)^{*} \\right) \\,d\\mu\\,d\\phi\n$$\n由于和是有限的，我们可以交换求和与积分的顺序：\n$$\nI = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} \\sum_{l'=0}^{L}\\sum_{m'=-l'}^{l'} f_{lm}\\,f_{l'm'}^{*} \\left( \\int_{0}^{2\\pi}\\int_{-1}^{1} Y_{l}^{m}(\\arccos\\mu,\\phi)\\,Y_{l'}^{m'}(\\arccos\\mu,\\phi)^{*} \\,d\\mu\\,d\\phi \\right)\n$$\n括号中的项正是正交归一性积分，其值为 $\\delta_{ll'}\\,\\delta_{mm'}$。这个性质极大地简化了表达式。Kronecker delta 仅在 $l=l'$ 和 $m=m'$ 时非零（等于 $1$）。因此，四重求和坍缩为双重求和，因为只有索引匹配的项才保留下来：\n$$\nI = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} \\sum_{l'=0}^{L}\\sum_{m'=-l'}^{l'} f_{lm}\\,f_{l'm'}^{*} \\,\\delta_{ll'}\\,\\delta_{mm'} = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} f_{lm}\\,f_{lm}^{*}\n$$\n由于对任意复数 $c$ 都有 $c \\cdot c^{*} = |c|^2$，我们得到 Parseval 恒等式的最终形式：\n$$\n\\int_{0}^{2\\pi}\\int_{-1}^{1} \\left| f(\\arccos\\mu,\\phi) \\right|^{2}\\,d\\mu\\,d\\phi = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} |f_{lm}|^{2}\n$$\n推导至此完成。\n\n### 第 2 部分：数值验证策略\n\n数值验证涉及比较 Parseval 恒等式的两边。左边使用数值求积计算，而右边是给定系数的精确和。\n\n1.  **系数生成**：对于每个具有给定截断阶数 $L$ 的测试用例，使用带种子的伪随机数生成器生成一组复系数 $\\{f_{lm}\\}$（其中 $l \\in [0, L]$ 且 $m \\in [-l, l]$），以确保可复现性。\n    *   **复数场**：系数 $f_{lm}$ 生成为 $a+ib$ 的形式，其中 $a$ 和 $b$ 从均匀分布中抽取。\n    *   **实数场**：为确保 $f(\\theta,\\phi)$ 是实值，系数必须满足对称条件 $f_{l,-m} = (-1)^m f_{lm}^*$。这通过以下方式强制执行：\n        *   对于 $m=0$，$f_{l0}$ 必须是实数。生成一个随机实数。\n        *   对于 $m>0$，为 $f_{lm}$ 生成一个随机复数。然后使用对称关系显式计算系数 $f_{l,-m}$。\n\n2.  **解析和**：Parseval 恒等式的右边，我们记作 $S_{analytic}$，通过对生成的系数的平方幅值求和来计算：\n    $$\n    S_{analytic} = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} |f_{lm}|^{2}\n    $$\n\n3.  **网格和求积权重**：为进行数值积分，构建一个 $(\\theta, \\phi)$ 上的张量积网格。\n    *   **纬度网格**：对 $\\mu \\in [-1, 1]$ 上的积分使用 Gauss-Legendre 求积。对于给定的点数 $N_\\theta$，我们得到一组节点 $\\{\\mu_i\\}$ 和权重 $\\{w_i\\}$。然后余纬节点为 $\\theta_i = \\arccos(\\mu_i)$。\n    *   **经度网格**：对 $\\phi \\in [0, 2\\pi)$ 上的积分使用均匀网格。对于 $N_\\phi$ 个点，节点为 $\\phi_j = 2\\pi j / N_\\phi$，其中 $j \\in \\{0, 1, \\dots, N_\\phi-1\\}$。此周期域上的梯形法则的积分权重是均匀的：$\\Delta\\phi = 2\\pi/N_\\phi$。\n\n4.  **场合成**：通过使用生成的系数对球谐级数求和，在 $(\\theta_i, \\phi_j)$ 网格的每个点上合成函数 $f(\\theta_i, \\phi_j)$：\n    $$\n    f(\\theta_i, \\phi_j) = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} f_{lm}\\,Y_{l}^{m}(\\theta_i, \\phi_j)\n    $$\n    这是通过对每个 $(l, m)$ 在整个网格上评估 `scipy.special` 中的 `sph_harm` 函数并执行加权和来实现的。\n\n5.  **数值积分**：Parseval 恒等式的左边，记作 $S_{numeric}$，由指定的求积和来近似：\n    $$\n    S_{numeric} = \\sum_{i=0}^{N_{\\theta}-1} \\sum_{j=0}^{N_{\\phi}-1} |f(\\theta_i, \\phi_j)|^2 \\, w_i \\, \\Delta\\phi\n    $$\n    具有 $N_\\theta$ 个点的 Gauss-Legendre 求积法则对于最高 $2N_\\theta-1$ 次的多项式是精确的。具有 $N_\\phi$ 个点的梯形法则对于波数最高为 $N_\\phi-1$ 的三角多项式是精确的。函数 $|f|^2$ 的球谐展开最大阶数为 $2L$。为使求积在理论上精确，我们需要 $2N_\\theta - 1 \\ge 2L$ 和 $N_\\phi > 2L$。选择这些测试用例是为了在不同的采样条件下探究其准确性。\n\n6.  **相对误差**：最后，计算数值积分和解析和之间的相对误差 $\\varepsilon$ 以量化数值验证的准确性：\n    $$\n    \\varepsilon = \\frac{| S_{numeric} - S_{analytic} |}{S_{analytic}}\n    $$\n    一个小的相对误差（接近机器精度）表明验证成功，既证实了 Parseval 恒等式的正确性，也证实了数值实现的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import sph_harm\nfrom numpy.polynomial.legendre import leggauss\n\ndef calculate_relative_error(L, N_theta, N_phi, is_real, seed):\n    \"\"\"\n    Calculates the relative error for Parseval's identity validation.\n\n    Args:\n        L (int): Maximum spherical harmonic degree.\n        N_theta (int): Number of latitudinal grid points (Gauss-Legendre nodes).\n        N_phi (int): Number of longitudinal grid points (uniform).\n        is_real (bool): True for a real-valued field, False for complex.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        float: The computed relative error.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # 1. Generate spherical harmonic coefficients\n    flm = {}\n    if is_real:\n        # Enforce f_l,-m = (-1)^m * f_lm* for real fields\n        for l in range(L + 1):\n            # m = 0 case (must be real)\n            flm[(l, 0)] = rng.uniform(-1, 1)\n            # m > 0 cases\n            for m in range(1, l + 1):\n                c = rng.uniform(-1, 1) + 1j * rng.uniform(-1, 1)\n                flm[(l, m)] = c\n                flm[(l, -m)] = ((-1)**m) * np.conj(c)\n    else:\n        # Complex field, no symmetry required\n        for l in range(L + 1):\n            for m in range(-l, l + 1):\n                flm[(l, m)] = rng.uniform(-1, 1) + 1j * rng.uniform(-1, 1)\n\n    # 2. Calculate the analytic sum of squared coefficients\n    analytic_sum = sum(np.abs(c)**2 for c in flm.values())\n    if analytic_sum == 0:\n        return 0.0\n\n    # 3. Set up the spatial grid and quadrature weights\n    # Latitudinal grid (Gauss-Legendre)\n    mu, w = leggauss(N_theta)  # mu are nodes in [-1, 1], w are weights\n    theta = np.arccos(mu)      # theta is in [0, pi]\n\n    # Longitudinal grid (uniform trapezoidal)\n    d_phi = 2 * np.pi / N_phi\n    phi = np.arange(N_phi) * d_phi # phi is in [0, 2pi)\n\n    # Create 2D meshgrids for vectorized calculations\n    phi_grid, theta_grid = np.meshgrid(phi, theta)\n\n    # 4. Synthesize the field f(theta, phi) on the grid\n    f_grid = np.zeros((N_theta, N_phi), dtype=np.complex128)\n    for l in range(L + 1):\n        for m in range(-l, l + 1):\n            # Scipy's sph_harm is Y_l^m(theta, phi) but args are (m, l, phi, theta)\n            Ylm_grid = sph_harm(m, l, phi_grid, theta_grid)\n            f_grid += flm[(l, m)] * Ylm_grid\n\n    # 5. Compute the numerical integral over the sphere\n    integrand = np.abs(f_grid)**2\n    # w needs to be broadcast from (N_theta,) to (N_theta, N_phi)\n    # The integral element is w_i * d_phi\n    numerical_integral = np.sum(integrand * w[:, np.newaxis] * d_phi)\n\n    # 6. Calculate the final relative error\n    relative_error = np.abs(numerical_integral - analytic_sum) / analytic_sum\n    \n    return relative_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # (L, N_theta, N_phi, is_real, seed)\n    test_cases = [\n        (0, 8, 16, True, 42),\n        (3, 40, 80, False, 7),\n        (10, 64, 128, False, 123),\n        (12, 80, 160, True, 9001),\n        (20, 41, 41, False, 2023)\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N_theta, N_phi, is_real, seed = case\n        error = calculate_relative_error(L, N_theta, N_phi, is_real, seed)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3615105"}, {"introduction": "从抽象属性转向地球物理学中的一个关键物理应用。像重力这样的位场满足拉普拉斯方程 $\\nabla^2 V = 0$，这对其径向行为施加了严格的结构。本练习探讨“向上延拓”，推导球谐系数如何随离源距离而缩放。这个实践展示了向上延拓强大的滤波效应，它通过衰减高频分量来自然地平滑场，这是信号与噪声分离中的一个至关重要的概念。[@problem_id:3615149]", "problem": "考虑定义在球面上的一个全局外部位场，例如，它表示行星体外部的引力位。设参考球面的半径为 $a$（单位：$\\mathrm{m}$）。在球面外部，位 $V$ 在球坐标系下满足拉普拉斯方程 $\\nabla^2 V = 0$。用球谐级数将半径为 $r$ 的球面上的位 $V$ 表示出来，该级数截断到最大阶数 $L$，其标量系数按阶数 $l$ 和次数 $m$ 索引。假设在半径 $r=a$ 处的系数受到加性、零均值、不相关的噪声污染，该噪声在不同阶数和次数上是各向同性的，具有不依赖于 $l$ 或 $m$ 的共同方差 $\\sigma^2$。\n\n从外部位场满足 $\\nabla^2 V = 0$ 并且可用球坐标系下变量分离法得到的球谐函数表示这一基本出发点，推导球谐系数在从半径 $r=a$ 向上延拓到半径 $r=a+h$（其中 $h>0$，单位：$\\mathrm{m}$）时的径向缩放行为。利用此径向缩放关系，定义一个向上延拓算子，该算子将半径 $r=a$ 处的系数向量映射到半径 $r=a+h$ 处的系数向量。分析该算子的谱范数意义下的稳定性，并解释在何种条件下向上延拓是衰减噪声的。\n\n为探究带宽限制 $L$ 如何控制噪声衰减，定义各向同性不相关系数噪声的均方根（RMS）衰减因子 $R(a,h,L)$，其值为向上延拓到 $r=a+h$ 后的系数向量的 RMS 与半径 $r=a$ 处系数向量的 RMS 之比，两者均截断到最大阶数 $L$。假设噪声在 $(l,m)$ 上是各向同性的，共同方差为 $\\sigma^2$，利用每个阶对应的次数个数来适当地加权来自每个 $l$ 的贡献，从而用 $a$、$h$ 和 $L$ 表示 $R(a,h,L)$。\n\n你的程序必须实现所推导的向上延拓算子，并为每个测试用例计算两个输出：\n- 均方根衰减因子 $R(a,h,L)$，为一个浮点数。\n- 一个布尔标志 $S(a,h)$，用于表示稳定性。如果向上延拓算子的谱范数严格小于 $1$，则定义为 $S(a,h)=\\mathrm{True}$，否则为 $S(a,h)=\\mathrm{False}$。\n\n使用以下测试套件，所有距离单位均为米（$\\mathrm{m}$），角度不是必需的（无角度单位适用）：\n1. 案例 A: $a=6.371\\times 10^6$, $h=1.0\\times 10^5$, $L=60$。\n2. 案例 B: $a=6.371\\times 10^6$, $h=0$, $L=60$。\n3. 案例 C: $a=6.371\\times 10^6$, $h=1.0\\times 10^5$, $L=0$。\n4. 案例 D: $a=6.371\\times 10^6$, $h=5.0\\times 10^5$, $L=180$。\n5. 案例 E: $a=6.371\\times 10^6$, $h=1.0\\times 10^5$, $L=180$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。此列表的每个元素必须对应一个测试用例，并且本身是一个形式为 $[R,S]$ 的双元素列表，其中 $R$ 是一个浮点数，$S$ 是一个布尔值。例如，输出应类似于 $[[R_1,S_1],[R_2,S_2],\\ldots,[R_5,S_5]]$，其中数值是为指定的测试套件计算得出的。", "solution": "该问题被评估为有效，因为它在科学上基于位势理论，在数学上是适定的，并且为获得唯一解提供了所有必要的参数。\n\n主要任务是分析外部位场从参考球面半径 $a$ 向上延拓到半径 $r = a+h$（其中 $h \\ge 0$）的过程。\n\n首先，我们确定球谐系数的径向依赖性。外部位场 $V$ 满足拉普拉斯方程 $\\nabla^2 V = 0$。在球坐标 $(r, \\theta, \\phi)$ 中，通过变量分离法得到的拉普拉斯方程的通解为：\n$$\nV(r, \\theta, \\phi) = \\sum_{l=0}^{\\infty} \\sum_{m=-l}^{l} \\left( A_{lm} r^l + B_{lm} r^{-(l+1)} \\right) Y_{lm}(\\theta, \\phi)\n$$\n其中 $Y_{lm}(\\theta, \\phi)$ 是阶数为 $l$、次数为 $m$ 的球谐基函数。对于外部位场，位场必须在无穷远处消失，即当 $r \\to \\infty$ 时 $V \\to 0$。此物理约束要求所有 $r^l$（随 $r$ 增长）项的系数 $A_{lm}$ 必须为零。因此，解简化为：\n$$\nV(r, \\theta, \\phi) = \\sum_{l=0}^{\\infty} \\sum_{m=-l}^{l} B_{lm} r^{-(l+1)} Y_{lm}(\\theta, \\phi)\n$$\n在特定半径 $r$ 处，位 $V$ 的球谐系数是函数 $C_{lm}(r)$，使得 $V(r, \\theta, \\phi) = \\sum_{l,m} C_{lm}(r) Y_{lm}(\\theta, \\phi)$。与解的形式进行比较，我们得到：\n$$\nC_{lm}(r) = B_{lm} r^{-(l+1)}\n$$\n常数 $B_{lm}$ 与半径无关，可以由参考半径 $a$ 处的系数确定：\n$$\nC_{lm}(a) = B_{lm} a^{-(l+1)} \\implies B_{lm} = C_{lm}(a) a^{l+1}\n$$\n将此代回，我们求得半径 $r=a+h$ 处的系数 $C_{lm}(a+h)$：\n$$\nC_{lm}(a+h) = B_{lm} (a+h)^{-(l+1)} = \\left( C_{lm}(a) a^{l+1} \\right) (a+h)^{-(l+1)}\n$$\n这得出了外部位场系数的基本径向缩放定律：\n$$\nC_{lm}(a+h) = C_{lm}(a) \\left(\\frac{a}{a+h}\\right)^{l+1}\n$$\n\n接下来，我们定义向上延拓算子并分析其稳定性。令 $\\mathbf{c}(r)$ 为所有系数 $\\{C_{lm}(r)\\}$（其中 $l \\in [0, L]$，$m \\in [-l, l]$）组成的列向量。从 $r=a$ 到 $r=a+h$ 的向上延拓是一个线性算子 $\\mathcal{U}$，满足 $\\mathbf{c}(a+h) = \\mathcal{U} \\mathbf{c}(a)$。根据缩放定律，该算子在球谐基下表现为一个对角矩阵，其中每个系数 $C_{lm}(a)$ 都乘以一个仅依赖于阶数 $l$ 的因子：\n$$\n\\lambda_l = \\left(\\frac{a}{a+h}\\right)^{l+1}\n$$\n对角算子的谱范数是其对角元素绝对值的最大值。我们必须找到 $|\\lambda_l|$ 在阶数范围 $l \\in \\{0, 1, \\dots, L\\}$ 内的最大值。\n$$\n\\|\\mathcal{U}\\|_2 = \\max_{l \\in \\{0, 1, \\dots, L\\}} \\left| \\left(\\frac{a}{a+h}\\right)^{l+1} \\right|\n$$\n由于 $a > 0$ 且 $h \\ge 0$，比率 $q = a/(a+h)$ 在区间 $(0, 1]$ 内。指数 $l+1$ 始终为正。因此，所有 $\\lambda_l$ 均为正值，我们可以去掉绝对值符号。对于 $q \\in (0, 1]$，函数 $f(l) = q^{l+1}$ 是一个关于 $l$ 的非增函数。因此，在最低阶数 $l=0$ 处达到最大值：\n$$\n\\|\\mathcal{U}\\|_2 = \\left(\\frac{a}{a+h}\\right)^{0+1} = \\frac{a}{a+h}\n$$\n稳定性标志 $S(a,h)$ 定义为：如果此谱范数严格小于 $1$，则为 $\\mathrm{True}$。\n$$\nS(a,h) \\equiv \\left( \\|\\mathcal{U}\\|_2  1 \\right) \\iff \\frac{a}{a+h}  1\n$$\n由于 $a$ 是正半径，此不等式当且仅当 $a  a+h$ 时成立，化简为 $h  0$。因此，如果 $h  0$，则 $S(a,h) = \\mathrm{True}$；如果 $h \\le 0$，则为 $\\mathrm{False}$。在相同条件（$h0$）下，向上延拓是噪声衰减的，因为对于所有阶数 $l$，缩放因子 $\\lambda_l = (a/(a+h))^{l+1} \\le (a/(a+h))  1$。通常由噪声主导的高阶系数比低阶信号分量衰减得更强烈，从而降低了总噪声功率。\n\n最后，我们推导均方根衰减因子 $R(a,h,L)$。问题将在 $r=a$ 处对系数 $C_{lm}(a)$ 的噪声定义为加性的、零均值、不相关且各向同性的，所有 $(l,m)$ 具有共同方差 $\\sigma^2$。在给定半径处、截断到阶数 $L$ 的系数向量的均方根（RMS）是系数平方均值的平方根，其中均值是按每个阶对应的次数个数加权的。直到阶数 $L$ 的总系数数量为 $N(L) = \\sum_{l=0}^{L} (2l+1) = (L+1)^2$。\n\n在 $r=a$ 处噪声的均方值为：\n$$\n\\text{MS}_{noise}(a) = \\frac{1}{N(L)} \\sum_{l=0}^{L} \\sum_{m=-l}^{l} E[C_{lm}(a)^2] = \\frac{1}{(L+1)^2} \\sum_{l=0}^{L} (2l+1) \\sigma^2 = \\frac{\\sigma^2}{(L+1)^2} (L+1)^2 = \\sigma^2\n$$\n因此，$r=a$ 处的均方根为 $\\text{RMS}_{noise}(a) = \\sqrt{\\sigma^2} = \\sigma$。\n\n在半径 $r=a+h$ 处，延拓后的系数为 $C_{lm}(a+h) = \\lambda_l C_{lm}(a)$。方差转换为 $E[C_{lm}(a+h)^2] = \\lambda_l^2 E[C_{lm}(a)^2] = \\lambda_l^2 \\sigma^2$。在 $r=a+h$ 处噪声的均方值为：\n$$\n\\text{MS}_{noise}(a+h) = \\frac{1}{(L+1)^2} \\sum_{l=0}^{L} \\sum_{m=-l}^{l} E[C_{lm}(a+h)^2] = \\frac{\\sigma^2}{(L+1)^2} \\sum_{l=0}^{L} (2l+1) \\lambda_l^2\n$$\n在 $r=a+h$ 处的均方根为 $\\text{RMS}_{noise}(a+h) = \\sqrt{\\text{MS}_{noise}(a+h)}$。均方根衰减因子 $R(a,h,L)$ 是以下比率：\n$$\nR(a,h,L) = \\frac{\\text{RMS}_{noise}(a+h)}{\\text{RMS}_{noise}(a)} = \\frac{\\frac{\\sigma}{L+1} \\sqrt{\\sum_{l=0}^{L} (2l+1) \\lambda_l^2}}{\\sigma} = \\frac{1}{L+1} \\sqrt{\\sum_{l=0}^{L} (2l+1) \\lambda_l^2}\n$$\n代入 $\\lambda_l = (a/(a+h))^{l+1}$，我们得到用于实现的最终表达式：\n$$\nR(a,h,L) = \\frac{1}{L+1} \\sqrt{ \\sum_{l=0}^{L} (2l+1) \\left( \\frac{a}{a+h} \\right)^{2(l+1)} }\n$$\n该公式计算均方根衰减因子，而稳定性标志则计算为 $S(a,h) = (h0)$。这就是每个测试用例需要计算的两个量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the geophysical problem of upward continuation noise attenuation.\n\n    This function processes a suite of test cases, each defined by a reference radius 'a',\n    an upward continuation height 'h', and a spherical harmonic truncation degree 'L'.\n    For each case, it calculates:\n    1. R(a, h, L): The Root Mean Square (RMS) attenuation factor for isotropic,\n       uncorrelated noise on spherical harmonic coefficients.\n    2. S(a, h): A boolean stability flag, True if the upward continuation operator\n       is strictly contractive (spectral norm  1), False otherwise.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (a, h, L) with distances in meters.\n    test_cases = [\n        (6.371e6, 1.0e5, 60),   # Case A\n        (6.371e6, 0.0, 60),    # Case B\n        (6.371e6, 1.0e5, 0),    # Case C\n        (6.371e6, 5.0e5, 180),  # Case D\n        (6.371e6, 1.0e5, 180),  # Case E\n    ]\n\n    results = []\n\n    for a, h, L in test_cases:\n        # 1. Calculate the stability flag S(a, h)\n        # The spectral norm of the upward continuation operator is a/(a+h).\n        # The operator is strictly contractive (norm  1) if and only if h > 0.\n        is_stable = h > 0\n\n        # 2. Calculate the RMS attenuation factor R(a, h, L)\n        # R = (1/(L+1)) * sqrt( sum_{l=0 to L} (2l+1) * (a/(a+h))^(2(l+1)) )\n        \n        # Handle the edge case h=0. The ratio a/(a+h) becomes 1.\n        # The sum becomes sum_{l=0 to L} (2l+1) = (L+1)^2.\n        # So R = (1/(L+1)) * sqrt((L+1)^2) = 1.\n        if h == 0:\n            rms_attenuation = 1.0\n        else:\n            # The base of the power term in the sum\n            q = a / (a + h)\n            \n            # The degree range [0, 1, ..., L]\n            l_values = np.arange(L + 1)\n            \n            # Calculate each term in the summation: (2l+1) * q^(2(l+1))\n            # We can write q^(2(l+1)) as (q^2)^(l+1) for numerical stability.\n            q_sq = q * q\n            terms = (2 * l_values + 1) * np.power(q_sq, l_values + 1)\n            \n            # Sum the terms\n            sum_of_terms = np.sum(terms)\n            \n            # Calculate the final RMS attenuation factor\n            rms_attenuation = np.sqrt(sum_of_terms) / (L + 1)\n        \n        results.append([rms_attenuation, is_stable])\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists is desired.\n    # Example: '[[R1, S1], [R2, S2]]'\n    # We join string representations of the inner lists.\n    # e.g., str([0.123, True]) -> '[0.123, True]'\n    output_str = \",\".join(map(str, results))\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```", "id": "3615149"}, {"introduction": "在不同坐标系中表示全球场是一个常见的挑战。本练习通过使用维格纳D矩阵（旋转球函数的数学工具）来解决球谐系数的旋转问题。通过实现这一旋转，学生将验证关键不变量，例如每个阶次内能量的守恒，并获得对球谐分析中最强大和通用的操作之一的实践经验。[@problem_id:3615165]", "problem": "考虑一个在单位球面上用球谐函数表示的实值标量场。设正交复球谐函数定义为 $Y_l^m(\\theta,\\phi)$，其中阶数 $l \\ge 0$ 为整数，级数 $-l \\le m \\le l$ 为整数，并采用常规的 Condon-Shortley 相位和在球面上的正交归一性。一个实值场可以使用实基底进行表示，其系数为 $C_{lm}$ 和 $S_{lm}$ ($m \\ge 0$)，使得其展开式可以写成由复基底构造的实球谐函数 $Y_{lm}^{c}(\\theta,\\phi)$ 和 $Y_{lm}^{s}(\\theta,\\phi)$ 的线性组合。与 $Y_l^m(\\theta,\\phi)$ 相关联的相应复球谐系数 $a_{lm}$ 满足实数约束 $a_{l,-m} = (-1)^m a_{lm}^\\*$，并且对于 $m \\ge 0$ 遵循以下基底关系定义：\n- 对于 $m=0$：$a_{l0} = C_{l0}$。\n- 对于 $m0$：$a_{lm} = \\frac{C_{lm} - i\\,S_{lm}}{\\sqrt{2}}$ 且 $a_{l,-m} = \\frac{(-1)^m\\left(C_{lm} + i\\,S_{lm}\\right)}{\\sqrt{2}}$。\n这些定义明确地固定了实系数相对于正交复球谐基底的归一化方式。\n\n三维空间中的刚体旋转属于三维特殊正交群（SO(3)）。这样一个旋转，由 $z$-$y$-$z$ 约定下的欧拉角 $(\\alpha,\\beta,\\gamma)$（角度以弧度为单位）参数化，通过 Wigner 旋转矩阵 $D^l_{mm'}(\\alpha,\\beta,\\gamma)$ 作用于固定阶数 $l$ 的球谐子空间上，产生旋转后的复系数 $a'_{lm} = \\sum_{m'=-l}^{l} D^l_{mm'}(\\alpha,\\beta,\\gamma)\\,a_{lm'}$。该旋转在每个阶数上保持总功率不变，并且对于系数的这种线性作用，单位变换和逆变换的复合性质均成立。\n\n您的任务是实现一个完整的程序，该程序：\n1. 从 SO(3) 的表示论第一性原理出发，为所有阶数 $l$（直至指定的最大阶数 $L_{\\mathrm{max}}$）构建 Wigner 旋转矩阵 $D^l_{mm'}(\\alpha,\\beta,\\gamma)$。使用标准的 $z$-$y$-$z$ 欧拉角约定，以及 Wigner small-$d$ 矩阵 $d^l_{mm'}(\\beta)$ 作为 $D^l_{mm'}$ 实核心的标准定义。\n2. 使用上述定义将给定的实球谐系数 $(C_{lm}, S_{lm})$ 转换为复系数 $a_{lm}$，通过 $D^l_{mm'}(\\alpha,\\beta,\\gamma)$ 应用旋转，然后将结果以相同的归一化方式一致地转换回旋转后的实系数 $(C'_{lm}, S'_{lm})$。\n3. 使用复数和实数两种表示方法计算旋转前后的阶功率 $P_l$。对于复数表示，使用 $P_l = \\sum_{m=-l}^{l} \\lvert a_{lm} \\rvert^2$。对于实数表示，使用 $P_l = C_{l0}^2 + \\sum_{m=1}^{l} \\left(C_{lm}^2 + S_{lm}^2\\right)$。在相同的归一化选择下，这两种表达式之间的一致性是验证的一部分。\n\n您必须针对一组指定的测试用例测试以下不变量和性质，所有角度均以弧度为单位：\n- 旋转下的阶功率不变性：对于每个阶数 $l$，验证 $P_l$ 在旋转后保持不变，误差在您选择并在实现中说明理由的数值容差范围内。\n- 单位旋转：使用 $(\\alpha,\\beta,\\gamma)=(0,0,0)$ 进行旋转，所有 $l$ 和 $m$ 的 $(C_{lm},S_{lm})$ 保持不变。\n- 逆旋转：先按 $(\\alpha,\\beta,\\gamma)$ 旋转，再进行逆旋转，可以恢复所有 $l$ 和 $m$ 的原始系数。在 $z$-$y$-$z$ 约定中，逆旋转对应于 $(-\\gamma,-\\beta,-\\alpha)$。\n\n实现您的程序以运行以下测试套件。对于每个用例，使用指定的最大阶数 $L_{\\mathrm{max}}$、系数规范以及以弧度为单位的欧拉角 $(\\alpha,\\beta,\\gamma)$。当系数规范为“随机”时，使用给定的种子从可复现的伪随机数生成器生成 $m \\ge 1$ 的 $C_{lm}$ 和 $S_{lm}$，并设置 $S_{l0}=0$；对于 $m=0$，类似地生成 $C_{l0}$。当系数规范为“单一”时，除指定系数外，将所有其他系数设置为零。使用与上述定义一致的正交归一化，并确保您实现的 Wigner 矩阵具有数值稳定性。\n- 用例 1（正常路径）：$L_{\\mathrm{max}}=5$，随机系数，种子为 $42$，$(\\alpha,\\beta,\\gamma)=(0.7,0.3,1.1)$。\n- 用例 2（边界：无倾斜）：$L_{\\mathrm{max}}=6$，随机系数，种子为 $123$，$(\\alpha,\\beta,\\gamma)=(2.0,0.0,-1.2)$。\n- 用例 3（边缘：仅偶极子）：$L_{\\mathrm{max}}=1$，随机系数，种子为 $7$，$(\\alpha,\\beta,\\gamma)=(1.3,0.9,-0.2)$。\n- 用例 4（边缘：仅单极子）：$L_{\\mathrm{max}}=0$，随机系数，种子为 $0$，$(\\alpha,\\beta,\\gamma)=(0.5,2.7,-2.2)$。\n- 用例 5（结构化单系数）：$L_{\\mathrm{max}}=3$，仅有 $C_{2,1}=1.0$ 为非零，所有其他 $C_{lm}$ 和 $S_{lm}$ 均为 $0$，$(\\alpha,\\beta,\\gamma)=(0.3,1.0,0.6)$。\n\n对于每个测试用例，评估三个布尔结果：\n- 在所有阶数 $l \\in \\{0,\\dots,L_{\\mathrm{max}}\\}$ 上的功率不变性。\n- 单位旋转保持系数不变。\n- 逆旋转恢复原始系数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表按顺序包含用例 1 的三个布尔值，接着是用例 2 的，依此类推，直到用例 5。例如，输出格式必须与 $[b_1,b_2,b_3,b_4,b_5,b_6,b_7,b_8,b_9,b_{10},b_{11},b_{12},b_{13},b_{14},b_{15}]$ 完全一样，其中每个 $b_k$ 是布尔字面量 $\\mathrm{True}$ 或 $\\mathrm{False}$。", "solution": "用户的请求是验证并解决一个计算问题，该问题涉及球面上由球谐系数表示的实值标量场的旋转。\n\n该问题被确定为 **有效**。它在科学上是合理的、适定的，并且所有必要的定义、约定和测试用例都已完整、一致地指定。该问题基于旋转群 SO(3) 的标准表示论及其在球谐函数上的应用，这是计算地球物理学和量子力学的基石。所提供的实球谐系数与复球谐系数之间的关系，以及阶功率的定义，都是一致且标准的。\n\n解决方案将按以下步骤进行：\n1.  **Wigner D-矩阵的实现**：SO(3) 中的一个旋转由 $z$-$y$-$z$ 约定下的三个欧拉角 $(\\alpha, \\beta, \\gamma)$ 参数化。它对阶数为 $l$ 的球谐系数的作用由 $(2l+1) \\times (2l+1)$ 的 Wigner D-矩阵 $D^l(\\alpha, \\beta, \\gamma)$ 描述。该矩阵可以分解为：\n    $$\n    D^l_{mm'}(\\alpha, \\beta, \\gamma) = e^{-im\\alpha} d^l_{mm'}(\\beta) e^{-im'\\gamma}\n    $$\n    其中，$d^l(\\beta)$（Wigner small-d 矩阵）表示绕 y 轴的旋转，而 $m, m'$ 是从 $-l$ 到 $l$ 的整数级数。\n\n    实现的核心是构建 $d^l(\\beta)$。“第一性原理”要求使用李群（如 SO(3)）与其李代数之间的基本关系。绕 y 轴旋转角度 $\\beta$ 的旋转算子由相应生成元 $\\hat{J}_y$ 的指数给出：\n    $$\n    \\hat{R}_y(\\beta) = e^{-i\\beta \\hat{J}_y}\n    $$\n    Wigner small-d 矩阵是该算子在球谐函数基底 $|l,m\\rangle$ 中的矩阵表示：\n    $$\n    d^l_{m'm}(\\beta) = \\langle l, m' | e^{-i\\beta \\hat{J}_y} | l, m \\rangle = \\left[ \\exp(-i\\beta J_y^{(l)}) \\right]_{m'm}\n    $$\n    其中 $J_y^{(l)}$ 是 $\\hat{J}_y$ 算子在阶数 $l$ 下的矩阵表示。该矩阵的元素在量子力学中是已知的：\n    $$\n    [J_y^{(l)}]_{m',m} = \\langle l, m' | \\hat{J}_y | l, m \\rangle = \\frac{1}{2i} \\left( \\sqrt{(l-m)(l+m+1)}\\delta_{m',m+1} - \\sqrt{(l+m)(l-m+1)}\\delta_{m',m-1} \\right)\n    $$\n    我们将为每个阶数 $l$ 构建 $(2l+1) \\times (2l+1)$ 的矩阵 $J_y^{(l)}$，然后使用数值稳定的矩阵指数函数 `scipy.linalg.expm` 计算 $d^l(\\beta)$。矩阵 $-i\\beta J_y^{(l)}$ 是实反对称矩阵，这确保了所得的 $d^l(\\beta)$ 是实正交矩阵，符合要求。\n\n2.  **系数的旋转**：复系数向量 $a_l = \\{a_{lm}\\}_{m=-l}^l$ 的旋转执行为 $a'_l = D^l a_l$。为提高计算效率，这分三步实现：\n    a. 绕 z 轴旋转 $\\gamma$：$a^{(1)}_{lm'} = a_{lm'} e^{-im'\\gamma}$。\n    b. 绕 y 轴旋转 $\\beta$：$a^{(2)}_{lm} = \\sum_{m'} d^l_{mm'} a^{(1)}_{lm'}$。\n    c. 绕 z 轴旋转 $\\alpha$：$a'_{lm} = a^{(2)}_{lm} e^{-im\\alpha}$。\n\n3.  **系数基底转换**：问题提供了实系数 $(C_{lm}, S_{lm})$。在旋转前必须将它们转换为复系数 $a_{lm}$，并在旋转后转换回实基底。指定的变换如下：\n    - **实数到复数**：\n      对于 $m=0$：$a_{l0} = C_{l0}$。\n      对于 $m0$：$a_{lm} = \\frac{1}{\\sqrt{2}}(C_{lm} - iS_{lm})$ 且 $a_{l,-m} = \\frac{(-1)^m}{\\sqrt{2}}(C_{lm} + iS_{lm})$。\n    - **复数到实数**：这些是通过反转上述关系得出的。\n      对于 $m=0$：$C'_{l0} = \\text{Re}(a'_{l0})$。\n      对于 $m0$：$C'_{lm} = \\sqrt{2} \\text{Re}(a'_{lm})$ 且 $S'_{lm} = -\\sqrt{2} \\text{Im}(a'_{lm})$。\n    如果旋转后的复系数满足 $a'_{l,-m} = (-1)^m (a'_{lm})^*$，则旋转场的实值性得以保持。我们的物理旋转保证了这一点。\n\n4.  **不变量验证**：对于每个测试用例，将验证三个属性。\n    - **功率不变性**：对旋转前后的每个阶数 $l$ 计算其阶功率 $P_l = C_{l0}^2 + \\sum_{m=1}^{l} (C_{lm}^2 + S_{lm}^2)$。使用 `numpy.isclose` 比较结果以考虑浮点误差。选择 `rtol=1e-9`, `atol=1e-12` 的容差，这对于理论上应相等且使用双精度计算的情况是合适的。\n    - **单位旋转**：用欧拉角 $(\\alpha,\\beta,\\gamma)=(0,0,0)$ 旋转系数。所得系数必须与原始系数相同，使用 `numpy.allclose` 进行检查。\n    - **逆旋转**：系数先按 $(\\alpha,\\beta,\\gamma)$ 旋转，然后将结果按逆旋转角 $(-\\gamma,-\\beta,-\\alpha)$ 旋转。最终系数必须与原始系数相同，使用 `numpy.allclose` 进行检查。\n\n整个过程将在一个 Python 脚本中实现。该脚本定义了用于生成系数、构建旋转矩阵、应用旋转以及为每个指定测试用例执行不变量检查的函数。这些检查的布尔结果将被收集并以指定格式打印。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for spherical harmonic rotations.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: happy path\n        {'L_max': 5, 'coeffs': {'type': 'random', 'seed': 42}, 'angles': (0.7, 0.3, 1.1)},\n        # Case 2: boundary (no tilt)\n        {'L_max': 6, 'coeffs': {'type': 'random', 'seed': 123}, 'angles': (2.0, 0.0, -1.2)},\n        # Case 3: edge (dipole only)\n        {'L_max': 1, 'coeffs': {'type': 'random', 'seed': 7}, 'angles': (1.3, 0.9, -0.2)},\n        # Case 4: edge (monopole only)\n        {'L_max': 0, 'coeffs': {'type': 'random', 'seed': 0}, 'angles': (0.5, 2.7, -2.2)},\n        # Case 5: structured single-coefficient\n        {'L_max': 3, 'coeffs': {'type': 'single', 'l': 2, 'm': 1, 'kind': 'C', 'val': 1.0}, 'angles': (0.3, 1.0, 0.6)},\n    ]\n\n    # Numerical tolerance for floating-point comparisons.\n    # Justification: These values are standard for double-precision floating-point\n    # arithmetic where theoretical equality is expected, accounting for accumulated\n    # errors from multiple operations including matrix exponentiation.\n    RTOL = 1e-9\n    ATOL = 1e-12\n\n    def generate_coefficients(spec, L_max):\n        \"\"\"Generates spherical harmonic coefficients based on the specification.\"\"\"\n        coeffs = {l: {'C': {0: 0.0}, 'S': {0: 0.0}} for l in range(L_max + 1)}\n        if spec['type'] == 'random':\n            rng = np.random.default_rng(spec['seed'])\n            for l in range(L_max + 1):\n                coeffs[l]['C'][0] = rng.random()\n                for m in range(1, l + 1):\n                    coeffs[l]['C'][m] = rng.random()\n                    coeffs[l]['S'][m] = rng.random()\n        elif spec['type'] == 'single':\n            l, m, kind, val = spec['l'], spec['m'], spec['kind'], spec['val']\n            if l = L_max:\n                if m == 0 and kind == 'S':\n                    # S_l0 is always 0 for real fields\n                    pass\n                else:\n                    coeffs[l][kind][m] = val\n        return coeffs\n\n    def get_d_matrix(l: int, beta: float) -> np.ndarray:\n        \"\"\"\n        Computes the Wigner small-d matrix d^l(beta) by exponentiating\n        the generator of rotations J_y.\n        \"\"\"\n        if l == 0:\n            return np.array([[1.0]])\n\n        dim = 2 * l + 1\n        # Index mapping: k = l + m\n        # Matrix element [J_y]_{k_m', k_m}\n        Jy = np.zeros((dim, dim), dtype=complex)\n\n        for k_m in range(dim):\n            m = k_m - l\n            # Element at (m'+1, m) -> (k_m+1, k_m)\n            if m  l:\n                k_mp1 = k_m + 1\n                val = np.sqrt((l - m) * (l + m + 1))\n                Jy[k_mp1, k_m] = 0.5j * val\n            # Element at (m'-1, m) -> (k_m-1, k_m)\n            if m > -l:\n                k_mm1 = k_m - 1\n                val = np.sqrt((l + m) * (l - m + 1))\n                Jy[k_mm1, k_m] = -0.5j * val\n        \n        # d^l(beta) = exp(-i * beta * J_y). The matrix -i * J_y is real,\n        # so the result of expm is real.\n        d_mat = expm(-1j * beta * Jy)\n        return d_mat.real\n\n    def rotate_coefficients(coeffs, L_max, alpha, beta, gamma):\n        \"\"\"\n        Performs a full z-y-z rotation on a set of SH coefficients.\n        \"\"\"\n        rotated_coeffs = {l: {'C': {}, 'S': {}} for l in range(L_max + 1)}\n\n        for l in range(L_max + 1):\n            dim = 2 * l + 1\n            # 1. Convert real coefficients to complex\n            a = np.zeros(dim, dtype=complex)\n            a[l] = coeffs[l]['C'].get(0, 0.0)\n            for m in range(1, l + 1):\n                C_lm = coeffs[l]['C'].get(m, 0.0)\n                S_lm = coeffs[l]['S'].get(m, 0.0)\n                a[l + m] = (C_lm - 1j * S_lm) / np.sqrt(2)\n                a[l - m] = ((-1)**m * (C_lm + 1j * S_lm)) / np.sqrt(2)\n\n            # 2. Apply rotation\n            d_matrix = get_d_matrix(l, beta)\n            m_array = np.arange(-l, l + 1)\n            \n            # Step 1: z-rotation by gamma\n            a_1 = a * np.exp(-1j * m_array * gamma)\n            # Step 2: y-rotation by beta\n            a_2 = d_matrix @ a_1\n            # Step 3: z-rotation by alpha\n            a_prime = a_2 * np.exp(-1j * m_array * alpha)\n\n            # 3. Convert complex coefficients back to real\n            rotated_coeffs[l]['C'][0] = a_prime[l].real\n            rotated_coeffs[l]['S'][0] = 0.0\n            for m in range(1, l + 1):\n                rotated_coeffs[l]['C'][m] = np.sqrt(2) * a_prime[l + m].real\n                rotated_coeffs[l]['S'][m] = -np.sqrt(2) * a_prime[l + m].imag\n        \n        return rotated_coeffs\n\n    def get_degree_power(coeffs, l):\n        \"\"\"Computes the power at a given degree l.\"\"\"\n        power = coeffs[l]['C'].get(0, 0.0) ** 2\n        for m in range(1, l + 1):\n            power += coeffs[l]['C'].get(m, 0.0) ** 2 + coeffs[l]['S'].get(m, 0.0) ** 2\n        return power\n\n    def are_coeffs_close(coeffs1, coeffs2, L_max):\n        \"\"\"Checks if two sets of coefficients are close.\"\"\"\n        for l in range(L_max + 1):\n            for m in range(l + 1):\n                if not np.isclose(coeffs1[l]['C'].get(m, 0.0), coeffs2[l]['C'].get(m, 0.0), rtol=RTOL, atol=ATOL):\n                    return False\n                if m > 0:\n                    if not np.isclose(coeffs1[l]['S'].get(m, 0.0), coeffs2[l]['S'].get(m, 0.0), rtol=RTOL, atol=ATOL):\n                        return False\n        return True\n\n    results = []\n    for case in test_cases:\n        L_max = case['L_max']\n        initial_coeffs = generate_coefficients(case['coeffs'], L_max)\n        alpha, beta, gamma = case['angles']\n\n        # --- Test 1: Power Invariance ---\n        rotated_coeffs = rotate_coefficients(initial_coeffs, L_max, alpha, beta, gamma)\n        power_ok = True\n        for l in range(L_max + 1):\n            power_before = get_degree_power(initial_coeffs, l)\n            power_after = get_degree_power(rotated_coeffs, l)\n            if not np.isclose(power_before, power_after, rtol=RTOL, atol=ATOL):\n                power_ok = False\n                break\n        results.append(power_ok)\n\n        # --- Test 2: Identity Rotation ---\n        id_coeffs = rotate_coefficients(initial_coeffs, L_max, 0.0, 0.0, 0.0)\n        identity_ok = are_coeffs_close(initial_coeffs, id_coeffs, L_max)\n        results.append(identity_ok)\n\n        # --- Test 3: Inverse Rotation ---\n        # Forward rotation is already computed in rotated_coeffs\n        inv_alpha, inv_beta, inv_gamma = -gamma, -beta, -alpha\n        recovered_coeffs = rotate_coefficients(rotated_coeffs, L_max, inv_alpha, inv_beta, inv_gamma)\n        inverse_ok = are_coeffs_close(initial_coeffs, recovered_coeffs, L_max)\n        results.append(inverse_ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3615165"}]}