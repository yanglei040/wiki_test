{"hands_on_practices": [{"introduction": "谱方法的核心优势之一在于其计算周期函数导数的高精度和高效率。这一过程利用了傅里叶变换的一个基本性质：物理空间中的微分运算在频率域中简化为波数的乘法。本练习将通过实现一个基于快速傅里叶变换（FFT）的谱微分算法，并量化其数值误差，帮助您掌握这一关键技术，并直观感受谱方法特有的“谱精度”[@problem_id:3614982]。", "problem": "在计算地球物理学的背景下，您需要为周期函数构建、实现并验证一个谱微分程序。考虑在区间 $[0, 2\\pi]$上定义的函数 $f(x) = \\sin(3x) + 0.1\\cos(9x)$，其中 $x$ 的单位为弧度。目标是使用基于傅里叶级数的谱方法计算 $f(x)$ 的数值导数，并使用双精度算术量化当网格点数 $N$ 变化时的数值误差。\n\n从 $2\\pi$ 周期函数的傅里叶级数的基本定义，以及由该定义推导出的空间微分与其在频域中的对应关系入手。您的实现必须使用与 $[0, 2\\pi]$ 上等距样本一致的离散公式，并且必须依赖通过快速傅里叶变换（FFT）计算的离散傅里叶变换（DFT），其中 FFT 代表快速傅里叶变换。您必须确保该过程遵守周期性边界条件，并与周期性网格的傅里叶级数解释相一致。\n\n对于每个选定的 $N$，在 $[0, 2\\pi)$ 上的 $N$ 个等距点上对函数 $f(x)$ 进行采样，应用傅里叶级数框架所隐含的谱微分，并将计算出的导数与在同一网格上求值的 $f(x)$ 的精确导数进行比较。精确导数需从第一性原理进行解析计算。使用归一化 $L^{2}$ 误差和 $L^{\\infty}$ 误差在网格点上量化误差。归一化 $L^{2}$ 误差必须定义为 $\\sqrt{\\frac{1}{N}\\sum_{j=0}^{N-1} \\left(e_j\\right)^2}$，其中 $e_j$ 是第 $j$ 个网格点上的点态误差；$L^{\\infty}$ 误差必须定义为 $\\max_{0 \\leq j \\leq N-1} |e_j|$。两种误差都是无量纲的。\n\n严格使用双精度进行计算，并相应地处理实数和复数量。整个过程中角度单位必须是弧度。您的程序必须实现该算法，并生成单行输出，总结针对一组固定的 $N$ 值的测试结果。这些 $N$ 值的选择旨在探究不同的数值区域，包括欠解析情况、最高解析频率下的边界情况以及良好解析情况。\n\n使用以下测试集进行测试：$N \\in \\{8, 16, 18, 32, 64, 128\\}$。对于该集合中的每个 $N$，计算并报告一个三元组 $[N, E_{2}, E_{\\infty}]$，其中 $E_{2}$ 是归一化 $L^{2}$ 误差，$E_{\\infty}$ 是 $L^{\\infty}$ 误差。您的程序应生成单行输出，其中包含这些三元组的列表，格式为方括号内以逗号分隔的列表，例如 $[[8, E_{2}, E_{\\infty}], [16, E_{2}, E_{\\infty}], \\dots]$，数值采用标准十进制表示法。由于这些量是无量纲的，并且根据构造，角度单位为弧度，因此不涉及物理单位。", "solution": "谱微分的目标是利用周期函数在傅里叶级数下的结构。一个 $2\\pi$ 周期函数 $f(x)$ 具有傅里叶级数表示\n$$\nf(x) = \\sum_{k=-\\infty}^{\\infty} \\hat{f}_k e^{i k x},\n$$\n其中 $\\hat{f}_k$ 是傅里叶系数。物理空间中的微分在频域中转化为一个简单的代数运算。逐项微分得到\n$$\n\\frac{d f}{d x}(x) = \\sum_{k=-\\infty}^{\\infty} i k \\hat{f}_k e^{i k x}.\n$$\n因此，如果能够计算出 $\\hat{f}_k$，则通过将每个系数乘以 $i k$ 并执行逆变换即可恢复导数。\n\n在离散网格上，我们在 $[0, 2\\pi)$ 上的 $N$ 个等距点进行采样，\n$$\nx_j = \\frac{2\\pi j}{N}, \\quad j = 0, 1, \\dots, N-1,\n$$\n并形成样本 $f_j = f(x_j)$。离散傅里叶变换（DFT）将样本与离散谱系数关联起来。使用快速傅里叶变换（FFT）实现的约定，正变换计算\n$$\nF_n = \\sum_{j=0}^{N-1} f_j e^{-2\\pi i j n / N}, \\quad n = 0, 1, \\dots, N-1,\n$$\n逆变换重构\n$$\nf_j = \\frac{1}{N} \\sum_{n=0}^{N-1} F_n e^{2\\pi i j n / N}.\n$$\n对于在 $x_j = 2\\pi j/N$ 处采样的形式为 $f(x) = \\sum_k \\hat{f}_k e^{i k x}$ 的函数，离散系数 $F_n$ 与连续级数系数对齐，其归一化方式与上述 DFT 定义一致。离散波数 $k$ 由整数表示，这些整数通过频率函数返回的数组映射到索引，该数组编码了排序\n$$\nk \\in \\{0, 1, 2, \\dots, \\lfloor\\frac{N}{2}\\rfloor, -\\lceil\\frac{N}{2}\\rceil, \\dots, -2, -1\\}。\n$$\n通过这种映射，谱微分按以下步骤进行：\n1. 计算采样函数 $f_j$ 的 DFT $F_n$。\n2. 构建与 DFT 排序匹配的整数波数数组 $k_n$。\n3. 计算谱导数系数 $G_n = i k_n F_n$。\n4. 对 $G_n$ 应用逆 DFT，以获得网格点上的导数样本，\n$$\n\\left(\\frac{d f}{d x}\\right)_j = \\frac{1}{N} \\sum_{n=0}^{N-1} G_n e^{2\\pi i j n / N}.\n$$\n由于精确函数是带限于模式 $k=\\pm 3$ 和 $k=\\pm 9$ 的，当这些模式可以在网格上无混叠地表示时，谱微分可以精确地再现导数。对于偶数 $N$ 且 $N/2 \\geq 9$，$k=\\pm 9$ 模式被包含在内；然而，在 $N=18$ 时，$k=9$ 模式对应于奈奎斯特频率。在网格 $x_j = 2\\pi j / 18$ 上，项 $-0.9\\sin(9x_j)$ 恒等于零，因为 $\\sin(9 \\cdot 2\\pi j / 18) = \\sin(\\pi j) = 0$，这与离散表示是一致的：来自奈奎斯特余弦模式的导数贡献在该网格的物理空间中产生零样本。\n\n精确导数通过初等微分法则解析计算得出，\n$$\n\\frac{d f}{d x}(x) = 3\\cos(3x) - 0.9\\sin(9x).\n$$\n我们通过比较谱导数样本与网格点上的精确样本来量化误差。对于每个 $N$，定义点态误差 $e_j = \\left(\\frac{d f}{d x}\\right)_{\\text{spectral}}(x_j) - \\left(\\frac{d f}{d x}\\right)_{\\text{exact}}(x_j)$。我们报告两种度量：\n1. 归一化 $L^{2}$ 误差，\n$$\nE_2 = \\sqrt{\\frac{1}{N}\\sum_{j=0}^{N-1} e_j^2},\n$$\n这是单位区间长度上 $L^2$ 范数的离散近似。\n2. $L^{\\infty}$ 误差，\n$$\nE_{\\infty} = \\max_{0 \\leq j \\leq N-1} |e_j|.\n$$\n这些误差是无量纲的，因为 $f(x)$ 及其导数是无量纲角度变量 $x$（以弧度为单位）的无量纲实值函数。\n\n算法上，步骤如下：\n- 对于测试集 $\\{8, 16, 18, 32, 64, 128\\}$ 中的每个 $N$，以双精度构建网格 $x_j$ 和样本 $f_j$。\n- 使用快速傅里叶变换（FFT）计算 $f_j$ 的 DFT。\n- 使用频率生成器创建与 FFT 排序匹配的整数波数，缩放为整数波数，并将谱系数乘以 $i k$ 以获得谱导数系数。\n- 进行逆变换以获得导数样本，并取实部以消除任何残留的虚部数值噪声。\n- 构建精确的导数样本并计算 $E_2$ 和 $E_{\\infty}$。\n- 将结果汇总为指定输出格式 $[N, E_2, E_{\\infty}]$（针对每个 $N$）。\n\n这种方法遵循基本的傅里叶级数框架，并将傅里叶空间中微分的数学性质通过快速傅里叶变换直接与高效的计算实现联系起来。它避免了无关的近似，并且对于足够大的 $N$，其误差在双精度下接近舍入误差水平，从而展示了光滑周期函数的谱精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef spectral_derivative_on_grid(N):\n    \"\"\"\n    Compute the spectral derivative of f(x) = sin(3x) + 0.1*cos(9x) on [0, 2*pi)\n    using N equispaced points, and return the normalized L2 and Linfty errors\n    versus the exact derivative at the grid points. All computations are\n    performed in double precision.\n    \"\"\"\n    # Double-precision grids and values\n    x = (2.0 * np.pi) * np.arange(N, dtype=np.float64) / np.float64(N)\n    f = np.sin(3.0 * x, dtype=np.float64) + 0.1 * np.cos(9.0 * x, dtype=np.float64)\n\n    # Exact derivative at grid points\n    exact_df = 3.0 * np.cos(3.0 * x, dtype=np.float64) - 0.9 * np.sin(9.0 * x, dtype=np.float64)\n\n    # Compute FFT of f\n    F = np.fft.fft(f.astype(np.float64))\n\n    # Integer wavenumbers consistent with numpy FFT ordering\n    # fftfreq returns frequencies in cycles per sample; multiplying by N gives integer k.\n    k = np.fft.fftfreq(N, d=1.0) * N  # array of ints in float dtype: [0,1,...,N/2-1,-N/2,...,-1]\n    k = k.astype(np.float64)\n\n    # Spectral derivative coefficients: G = i * k * F\n    G = (1j * k) * F\n\n    # Inverse FFT to get derivative samples in physical space\n    df_spec = np.fft.ifft(G)\n\n    # Due to numerical round-off, df_spec may have tiny imaginary parts; take real part\n    df_spec_real = np.real(df_spec).astype(np.float64)\n\n    # Compute errors\n    err = df_spec_real - exact_df\n    # Normalized L2 error: sqrt(mean(err^2))\n    E2 = float(np.sqrt(np.mean(err * err)))\n    # Linfty error: max absolute error\n    Einf = float(np.max(np.abs(err)))\n\n    return E2, Einf\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [8, 16, 18, 32, 64, 128]\n\n    results = []\n    for N in test_cases:\n        E2, Einf = spectral_derivative_on_grid(N)\n        results.append([int(N), E2, Einf])\n\n    # Final print statement in the exact required format.\n    # Single line output: list of triples [N, E2, Einf] as comma-separated list in brackets.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```", "id": "3614982"}, {"introduction": "除了微分，谱方法也为计算周期函数的定积分提供了一种简洁而精确的途径。其基本原理是，函数在一个周期上的积分值仅由其傅里叶级数的零阶模态（即平均值或直流分量）决定，而所有高阶振荡模态的积分为零。通过这个练习，您将从理论上推导并用数值方法验证这一关系，从而深化对傅里叶模态物理意义的理解，并探索谱积分的实现方式[@problem_id:3615007]。", "problem": "您的任务是设计并实现一个数值验证，以检验周期函数在一个周期上的积分与其零阶傅里叶级数模态之间的关系。请从第一性原理开始：对于一个周期为 $L$ 并在区间 $[0,L]$ 上可积的函数 $f(x)$，其傅里叶级数的定义。傅里叶级数表示是复指数函数正交性的一个推论，它由系数 $\\hat{f}_k$ 定义，使得该级数用模态 $e^{i 2\\pi k x / L}$ 来近似 $f(x)$，其中角度必须以弧度为单位。仅使用这些基本定义，推导出将积分 $\\int_0^L f(x)\\,dx$ 与零阶模态 $\\hat{f}_0$ 联系起来的精确表达式，并解释为什么在一个完整周期上，只有零阶模态对积分有贡献。\n\n然后，实现一个程序，该程序：\n- 在均匀周期网格 $x_j = j\\Delta x$（其中 $\\Delta x = L/N$，对于 $j=0,1,\\dots,N-1$，排除端点以保持周期性）上对每个测试函数进行采样，使用快速傅里叶变换 (FFT) 计算离散傅里叶变换 (DFT)，并由此构建与周期 $L$ 的连续傅里叶级数归一化相一致的零阶傅里叶模态 $\\hat{f}_0$ 的离散近似。\n- 通过您推导出的恒等式，使用零阶模态近似来估计一个周期上的积分，并将此估计值与在连续区间上对 $\\int_0^L f(x)\\,dx$ 进行的高精度数值积分结果进行比较。\n- 对于每个测试用例，报告其绝对误差（以浮点数形式），该误差定义为基于谱方法零阶模态的估计值与高精度积分结果之间的绝对差值。\n\n角度单位说明：所有角度都必须以弧度处理。\n\n测试套件：\n对于每种情况，$f(x)$ 是周期为 $L$ 的周期函数，$N$ 是在 $[0,L)$ 上的均匀采样点数。\n1. 光滑、带限且具有非零均值的情况：\n   - $L = 2\\pi$\n   - $f_1(x) = \\sin(x) + \\frac{1}{2}\\cos(2x) + \\frac{1}{4}$\n   - $N = 128$\n2. 解析、非多项式的周期函数，其均值可通过特殊函数得知：\n   - $L = 1$\n   - $f_2(x) = \\exp\\!\\big(\\sin(2\\pi x)\\big)$\n   - $N = 64$\n3. 不连续的周期性斜坡（锯齿波），代表了谱方法中的吉布斯类现象：\n   - $L = 3$\n   - $f_3(x) = \\big((x \\bmod L) - \\frac{L}{2}\\big)$ 在 $[0,L)$ 上并周期性延拓\n   - $N = 129$\n4. 区间内包含多个整数周期，粗采样：\n   - $L = 2$\n   - $f_4(x) = \\cos(3\\pi x) + \\sin(4\\pi x)$\n   - $N = 32$\n\n算法要求：\n- 根据采样点 $\\{f(x_j)\\}_{j=0}^{N-1}$ 的 FFT，使用周期为 $L$ 的连续傅里叶级数归一化方法来构建 $\\hat{f}_0$ 的离散近似。利用连续系数定义与 DFT 之间的关系来确保归一化的一致性，并以弧度表示所有步骤。\n- 在 $[0,L]$ 上使用可靠的积分方案计算 $\\int_0^L f(x)\\,dx$ 的高精度参考值，绝对容差为 $10^{-12}$，相对容差为 $10^{-12}$。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含四个测试用例的绝对误差，格式为方括号内以逗号分隔的列表（例如，\"[e1,e2,e3,e4]\"）。这些值必须是浮点数。不应打印任何其他文本。单位是无量纲的，因为函数是纯数学定义的。", "solution": "该问题要求分两部分作答：首先是周期函数积分与其零阶傅里叶模态之间关系的理论推导，其次是用于验证此关系的数值程序。\n\n### 理论推导与原理\n\n设 $f(x)$ 是一个周期为 $L$ 并在区间 $[0, L]$ 上可积的复值函数。该函数可以由其傅里叶级数表示：\n$$\nf(x) = \\sum_{k=-\\infty}^{\\infty} \\hat{f}_k e^{i 2\\pi k x / L}\n$$\n其中 $k$ 是一个表示模态数（或按 $2\\pi/L$ 缩放的波数）的整数，$\\hat{f}_k$ 是复傅里叶系数。这些系数是通过将 $f(x)$ 投影到正交基函数 $e^{i 2\\pi k x / L}$ 上来确定的。系数 $\\hat{f}_k$ 的公式是利用这些基函数在区间 $[0, L]$ 上的正交性推导出来的：\n$$\n\\int_0^L e^{i 2\\pi m x / L} e^{-i 2\\pi n x / L} \\,dx = \\int_0^L e^{i 2\\pi (m-n) x / L} \\,dx = L \\cdot \\delta_{mn}\n$$\n其中 $\\delta_{mn}$ 是克罗内克 delta。\n\n为了求出 $\\hat{f}_k$，我们将 $f(x)$ 的级数表示乘以 $e^{-i 2\\pi k' x / L}$ 并在一个周期上积分：\n$$\n\\int_0^L f(x) e^{-i 2\\pi k' x / L} \\,dx = \\int_0^L \\left( \\sum_{k=-\\infty}^{\\infty} \\hat{f}_k e^{i 2\\pi k x / L} \\right) e^{-i 2\\pi k' x / L} \\,dx\n$$\n假设级数一致收敛，我们可以交换求和与积分的顺序：\n$$\n\\int_0^L f(x) e^{-i 2\\pi k' x / L} \\,dx = \\sum_{k=-\\infty}^{\\infty} \\hat{f}_k \\int_0^L e^{i 2\\pi (k-k') x / L} \\,dx\n$$\n根据正交性，右侧的积分除非 $k = k'$ 否则为零，在 $k=k'$ 的情况下，其值等于 $L$。因此，无穷级数坍缩为单项：\n$$\n\\int_0^L f(x) e^{-i 2\\pi k' x / L} \\,dx = \\hat{f}_{k'} \\cdot L\n$$\n解出系数 $\\hat{f}_{k'}$（并为了一般性去掉撇号），得到标准定义：\n$$\n\\hat{f}_k = \\frac{1}{L} \\int_0^L f(x) e^{-i 2\\pi k x / L} \\,dx\n$$\n现在，为了建立 $f(x)$ 的积分与零阶模态之间的关系，我们只需在此定义中令 $k=0$：\n$$\n\\hat{f}_0 = \\frac{1}{L} \\int_0^L f(x) e^{-i 2\\pi (0) x / L} \\,dx = \\frac{1}{L} \\int_0^L f(x) e^0 \\,dx = \\frac{1}{L} \\int_0^L f(x) \\,dx\n$$\n直接整理此方程可得到所需的恒等式：\n$$\n\\int_0^L f(x) \\,dx = L \\cdot \\hat{f}_0\n$$\n这个结果表明，周期函数在一个完整周期上的积分完全由其零阶傅里叶模态 $\\hat{f}_0$ 决定，该模态代表了函数在该周期上的平均值（或直流分量）。所有其他 $k \\neq 0$ 的模态，都对应于在区间 $[0, L]$ 上有整数个完整周期的振荡分量（正弦波）。当在此区间上积分时，这些振荡分量下方的净面积为零，意味着它们对总积分没有贡献。\n\n### 数值算法设计\n\n数值验证通过将积分的高精度计算结果与一个从恒等式 $\\int_0^L f(x) \\,dx = L \\hat{f}_0$ 的离散对应形式推导出的估计值进行比较来进行。\n\n1.  **参考积分**：使用标准的数值积分程序（具体为 `scipy.integrate.quad`），并设置严格的容差，来计算 $I_{ref} = \\int_0^L f(x) \\,dx$ 的高精度值，以此作为基准真相。\n\n2.  **谱方法估计**：\n    a. 在周期域 $[0, L)$ 上的一个包含 $N$ 个点的均匀网格上对连续函数 $f(x)$ 进行采样。网格点定义为 $x_j = j \\Delta x = j \\frac{L}{N}$，其中 $j=0, 1, \\dots, N-1$。排除端点 $x=L$ 是为了保持周期性，因为 $f(L) = f(0)$。\n    b. 计算采样值 $\\{f(x_j)\\}_{j=0}^{N-1}$ 的离散傅里叶变换 (DFT)，通常通过快速傅里叶变换 (FFT) 算法实现。结果是一组复系数 $\\{F_k\\}_{k=0}^{N-1}$，其定义为：\n    $$\n    F_k = \\sum_{j=0}^{N-1} f(x_j) e^{-i 2\\pi k j / N}\n    $$\n    c. 必须建立连续傅里叶系数 $\\hat{f}_k$ 的离散近似。这可以通过使用宽度为 $\\Delta x$ 的矩形法，以数值求和来近似 $\\hat{f}_k$ 定义中的积分来实现：\n    $$\n    \\hat{f}_k = \\frac{1}{L} \\int_0^L f(x) e^{-i 2\\pi k x / L} \\,dx \\approx \\frac{1}{L} \\sum_{j=0}^{N-1} f(x_j) e^{-i 2\\pi k x_j / L} \\Delta x\n    $$\n    代入 $x_j = j L/N$ 和 $\\Delta x = L/N$：\n    $$\n    \\hat{f}_k \\approx \\frac{1}{L} \\sum_{j=0}^{N-1} f(x_j) e^{-i 2\\pi k (j L/N) / L} \\left(\\frac{L}{N}\\right) = \\frac{1}{N} \\sum_{j=0}^{N-1} f(x_j) e^{-i 2\\pi k j / N}\n    $$\n    d. 我们发现这个求和就是 DFT 系数 $F_k$ 的定义。因此，连续傅里叶系数的离散近似为：\n    $$\n    \\hat{f}_k \\approx \\frac{F_k}{N}\n    $$\n    e. 对于零阶模态 ($k=0$)，这给出了 $\\hat{f}_0 \\approx F_0/N$，其中 $F_0 = \\sum_{j=0}^{N-1} f(x_j)$ 是采样值的总和。\n    f. 接着，使用推导出的恒等式计算积分的谱方法估计值 $I_{spec}$：\n    $$\n    I_{spec} = L \\cdot \\hat{f}_0 \\approx L \\frac{F_0}{N} = \\frac{L}{N} \\sum_{j=0}^{N-1} f(x_j) = \\Delta x \\sum_{j=0}^{N-1} f(x_j)\n    $$\n    这表明，基于零阶模态的估计等价于使用简单的矩形法或周期性梯形法则来评估积分。\n\n3.  **误差计算**：每个测试用例的绝对误差计算为 $|I_{spec} - I_{ref}|$。对于光滑、良好解析的周期函数，这个误差预计会接近机器精度。对于具有不连续性的函数，收敛速度较慢，误差会更大。", "answer": "```python\nimport numpy as np\nimport scipy.integrate\n\ndef solve():\n    \"\"\"\n    Verifies the relationship between the integral of a periodic function\n    and its zeroth Fourier mode for four test cases.\n    \"\"\"\n\n    # Test Suite Definition\n    test_cases = [\n        {\n            \"L\": 2 * np.pi,\n            \"N\": 128,\n            \"f\": lambda x: np.sin(x) + 0.5 * np.cos(2*x) + 0.25,\n            \"description\": \"Smooth, band-limited function\"\n        },\n        {\n            \"L\": 1.0,\n            \"N\": 64,\n            \"f\": lambda x: np.exp(np.sin(2 * np.pi * x)),\n            \"description\": \"Analytic, non-polynomial periodic function\"\n        },\n        {\n            \"L\": 3.0,\n            \"N\": 129,\n            \"f\": lambda x: (x % 3.0) - 1.5,\n            \"description\": \"Discontinuous periodic ramp (sawtooth)\"\n        },\n        {\n            \"L\": 2.0,\n            \"N\": 32,\n            \"f\": lambda x: np.cos(3 * np.pi * x) + np.sin(4 * np.pi * x),\n            \"description\": \"Multiple integer cycles, coarse sampling\"\n        }\n    ]\n\n    absolute_errors = []\n\n    for case in test_cases:\n        L = case[\"L\"]\n        N = case[\"N\"]\n        f = case[\"f\"]\n        \n        # Step 1: Compute high-accuracy reference integral using quadrature\n        # The quad function returns a tuple (integral_value, error_estimate)\n        I_ref, _ = scipy.integrate.quad(f, 0, L, epsabs=1e-12, epsrel=1e-12)\n\n        # Step 2: Compute spectral estimate of the integral\n        \n        # 2a: Create the uniform periodic grid [0, L)\n        # endpoint=False ensures the grid is x_j for j=0,...,N-1\n        x_j = np.linspace(0, L, N, endpoint=False)\n        \n        # 2b: Sample the function on the grid\n        f_j = f(x_j)\n        \n        # 2c: Compute the Discrete Fourier Transform (DFT) using FFT\n        # F_k = sum_{j=0}^{N-1} f_j * exp(-i*2*pi*k*j/N)\n        F_k = np.fft.fft(f_j)\n        \n        # 2d: Get the zeroth component of the DFT, F_0\n        F_0 = F_k[0]\n        \n        # 2e: Approximate the continuous zeroth Fourier coefficient f_hat_0\n        # The normalization connecting the DFT to the continuous Fourier\n        # series coefficient is f_hat_k approx F_k / N.\n        # For a real-valued input function f(x), F_0 will be purely real, but we\n        # take .real to handle any minor floating-point imaginary parts.\n        f0_hat_approx = F_0.real / N\n        \n        # 2f: Estimate the integral using the identity: Integral = L * f_hat_0\n        I_spec = L * f0_hat_approx\n        \n        # Step 3: Calculate the absolute error\n        error = np.abs(I_spec - I_ref)\n        absolute_errors.append(error)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, absolute_errors))}]\")\n\nsolve()\n```", "id": "3615007"}, {"introduction": "在解决实际的地球物理问题时，我们经常会遇到非线性项，这通常表现为不同函数的乘积。在谱方法中，物理空间中的乘积对应于频率域中的卷积，而在离散网格上直接计算乘积会导致“混叠”（aliasing）误差，即高频分量被错误地表示为低频分量。本练习旨在通过对比精确的谱域卷积和直接的网格点乘法，让您亲手量化混叠误差，并理解在非线性模拟中进行“去混叠”（dealiasing）处理的必要性与方法[@problem_id:3615024]。", "problem": "给定一个周期性域和两个由有限傅里叶级数表示的实值函数。您的任务是使用两种不同的方法计算这些函数乘积的积分，并量化由混叠引起的偏差。其基础是周期性域上的傅里叶级数定义、谱空间中的卷积定义，以及均匀网格上周期性函数的求积。\n\n考虑一个长度为 $2\\pi$ 的一维周期性域，其空间坐标 $x \\in [0,2\\pi)$ 以弧度表示。设 $f(x)$ 和 $g(x)$ 是以三角函数为基底写出的具有有限傅里叶级数的实值函数，\n$$\nf(x) = a_0^{(f)} + \\sum_{k=1}^{K_f} \\left(a_k^{(f)}\\cos(kx) + b_k^{(f)}\\sin(kx)\\right), \\quad\ng(x) = a_0^{(g)} + \\sum_{k=1}^{K_g} \\left(a_k^{(g)}\\cos(kx) + b_k^{(g)}\\sin(kx)\\right).\n$$\n目标是计算乘积 $h(x) = f(x)g(x)$ 在 $[0,2\\pi)$ 上的积分，记为\n$$\nI = \\int_{0}^{2\\pi} h(x)\\,dx,\n$$\n使用两种方法：\n\n1. 一种基于傅里叶级数卷积的去混叠谱空间方法。此计算必须从傅里叶级数原理推导得出，并且在傅里叶系数已知且有限的情况下，必须返回无混叠的正确积分。\n\n2. 一种在 $N$ 个点的均匀网格上使用梯形法则的直接求积方法（对于在等距网格上采样的周期性函数，这等于均匀平均值乘以域长度）。当网格无法解析最高频率内容时，此方法容易产生混叠。\n\n您应实现这两种方法，并将偏差计算为直接求积积分与去混叠谱卷积积分之差，\n$$\n\\Delta I = I_{\\text{direct}} - I_{\\text{dealiased}}.\n$$\n您的程序必须对以下测试套件中的每个测试用例执行这些计算。角度必须解释为弧度。输出必须是一个浮点数列表，每个测试用例一个，表示该用例的 $\\Delta I$。\n\n测试套件（每个用例指定网格大小 $N$，以及 $f$ 和 $g$ 的系数）：\n\n- 用例 1（良好解析，一般情况）：$N=64$，\n  $f(x) = 0 + 1.0\\cdot\\cos(5x) + 0.4\\cdot\\sin(7x)$，\n  $g(x) = 0 + 1.2\\cdot\\cos(5x) - 0.1\\cdot\\sin(7x)$。\n\n- 用例 2（奈奎斯特边界条件）：$N=32$，\n  $f(x) = 0 + 1.0\\cdot\\cos(16x)$，\n  $g(x) = 0 + 1.0\\cdot\\cos(16x)$。\n\n- 用例 3（由于采样不足导致频率碰撞而产生显著的混叠偏差）：$N=32$，\n  $f(x) = 0 + 1.0\\cdot\\cos(18x)$，\n  $g(x) = 0 + 1.0\\cdot\\cos(14x)$。\n\n- 用例 4（多模态混叠场景）：$N=24$，\n  $f(x) = 0 + 1.0\\cdot\\cos(17x) + 0.5\\cdot\\sin(5x)$，\n  $g(x) = 0 + 1.3\\cdot\\cos(7x) + 0.5\\cdot\\sin(17x)$。\n\n- 用例 5（良好解析的多模态情况）：$N=48$，\n  $f(x) = 0 + 0.8\\cdot\\cos(20x) - 0.5\\cdot\\sin(22x)$，\n  $g(x) = 0 + 0.8\\cdot\\cos(20x) - 0.5\\cdot\\sin(22x)$。\n\n需要实现的算法细节：\n\n- 对于去混叠谱空间计算，推导出 $f(x)$ 和 $g(x)$ 的傅里叶级数卷积的零波数（平均）模态的表达式，并用它来计算 $I_{\\text{dealiased}}$。您必须从基本的傅里叶级数定义和谱空间卷积出发，确保在级数有限时结果不受混叠影响。\n\n- 对于直接求积计算，在 $N$ 个等距点 $x_n = \\frac{2\\pi n}{N}$（其中 $n = 0,1,\\dots,N-1$）上对函数进行采样，并将 $I_{\\text{direct}}$ 计算为乘积平均值乘以 $2\\pi$：\n$$\nI_{\\text{direct}} = \\left(\\frac{1}{N}\\sum_{n=0}^{N-1} f(x_n)g(x_n)\\right) \\cdot 2\\pi.\n$$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,result4,result5]”）。每个条目必须是相应案例的 $\\Delta I$ 的浮点值。由于域长度以弧度为单位是 $2\\pi$，并且在此设置中积分为无量纲，因此不需要物理单位。", "solution": "该问题要求计算两个函数乘积 $h(x) = f(x)g(x)$ 在周期性域 $[0, 2\\pi)$ 上的积分。这个积分记为 $I = \\int_{0}^{2\\pi} h(x)\\,dx$，需要使用两种不同的方法进行计算：一种是去混叠的谱空间方法，另一种是均匀网格上的直接求积方法。需要报告的是这两种方法之间的偏差 $\\Delta I = I_{\\text{direct}} - I_{\\text{dealiased}}$。\n\n对问题陈述的验证证实了其科学性、适定性和客观性。这是一个数值分析和谱方法中的标准问题，所有必要的数据和定义都已提供。\n\n解决方案首先基于指定的两种方法推导积分的表达式。\n\n**方法 1：去混叠谱空间积分 ($I_{\\text{dealiased}}$)**\n\n此方法计算具有有限傅里叶级数的两个函数乘积的精确积分。周期性函数在其域上的积分与其平均值成正比，该平均值对应于其傅里叶级数的零波数（$k=0$）系数。\n\n设 $h(x)$ 的傅里叶级数以复数形式表示为 $h(x) = \\sum_{k=-\\infty}^{\\infty} c_k^{(h)} e^{ikx}$。$k=0$ 的系数由 $c_0^{(h)} = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} h(x) e^{-i(0)x} dx = \\frac{1}{2\\pi}I$ 给出。因此，精确积分为 $I = 2\\pi c_0^{(h)}$。\n\n函数 $f(x)$ 和 $g(x)$ 以实三角函数为基底给出：\n$$\nf(x) = a_0^{(f)} + \\sum_{k=1}^{K_f} \\left(a_k^{(f)}\\cos(kx) + b_k^{(f)}\\sin(kx)\\right)\n$$\n对于 $g(x)$ 也是如此。积分 $I = \\int_{0}^{2\\pi} f(x)g(x) dx$ 可以通过代入这些级数并使用三角函数在区间 $[0, 2\\pi)$ 上的正交关系来计算：\n$$\n\\int_{0}^{2\\pi}\\cos(kx)\\cos(jx)dx = \\pi\\delta_{kj} \\quad (k,j > 0)\n$$\n$$\n\\int_{0}^{2\\pi}\\sin(kx)\\sin(jx)dx = \\pi\\delta_{kj} \\quad (k,j > 0)\n$$\n$$\n\\int_{0}^{2\\pi}\\cos(kx)\\sin(jx)dx = 0\n$$\n$$\n\\int_{0}^{2\\pi}\\cos(kx)dx = 0, \\quad \\int_{0}^{2\\pi}\\sin(kx)dx = 0 \\quad (k > 0)\n$$\n$$\n\\int_{0}^{2\\pi} 1 \\cdot 1 \\, dx = 2\\pi\n$$\n在计算乘积 $f(x)g(x)$ 的积分时，唯一能产生非零结果的项是常数项的乘积以及相同类型和相同波数的三角函数的乘积。这导致：\n$$\nI_{\\text{dealiased}} = \\int_{0}^{2\\pi} (a_0^{(f)})(a_0^{(g)}) dx + \\sum_{k=1}^{\\infty} \\int_{0}^{2\\pi} (a_k^{(f)}\\cos(kx))(a_k^{(g)}\\cos(kx)) dx + \\sum_{k=1}^{\\infty} \\int_{0}^{2\\pi} (b_k^{(f)}\\sin(kx))(b_k^{(g)}\\sin(kx)) dx\n$$\n使用正交关系，这可以简化为：\n$$\nI_{\\text{dealiased}} = 2\\pi a_0^{(f)} a_0^{(g)} + \\sum_{k=1}^{\\infty} \\pi(a_k^{(f)} a_k^{(g)} + b_k^{(f)} b_k^{(g)})\n$$\n由于输入的级数是有限的，这个和也是有限的。这个公式是精确且无混叠的，因此它是“去混叠”的结果。\n\n**方法 2：直接求积积分 ($I_{\\text{direct}}$)**\n\n此方法使用梯形法则在 $N$ 个点的均匀网格 $x_n = \\frac{2\\pi n}{N}$（其中 $n = 0, 1, \\dots, N-1$）上近似积分。对于周期性函数，这等价于对网格上的函数值求平均，然后乘以域长度：\n$$\nI_{\\text{direct}} = \\frac{2\\pi}{N} \\sum_{n=0}^{N-1} h(x_n) = \\frac{2\\pi}{N} \\sum_{n=0}^{N-1} f(x_n)g(x_n)\n$$\n这种数值求积方法容易受到混叠的影响。乘积函数 $h(x)$ 包含最高达到 $K_f + K_g$ 的波数。如果这个最大波数超过网格的奈奎斯特波数 $k_{Nyquist} = N/2$，那么高频分量将被错误地表示为低频分量。\n\n通过求积法则计算的离散和精确等于网格所见的混叠函数的积分。混叠关系指出，采样信号 $h(x_n)$ 的离散傅里叶变换系数 $\\hat{h}_k$ 与连续傅里叶级数系数 $c_k^{(h)}$ 通过公式 $\\hat{h}_k = N \\sum_{m=-\\infty}^{\\infty} c_{k+mN}^{(h)}$ 相关联。\n\n直接积分与 DFT 的 $k=0$ 分量有关：$I_{\\text{direct}} = \\frac{2\\pi}{N} \\hat{h}_0$。代入 $\\hat{h}_0$ 的混叠公式：\n$$\nI_{\\text{direct}} = \\frac{2\\pi}{N} \\left( N \\sum_{m=-\\infty}^{\\infty} c_{mN}^{(h)} \\right) = 2\\pi \\sum_{m=-\\infty}^{\\infty} c_{mN}^{(h)}\n$$\n$$\nI_{\\text{direct}} = 2\\pi (c_0^{(h)} + c_N^{(h)} + c_{-N}^{(h)} + c_{2N}^{(h)} + c_{-2N}^{(h)} + \\dots)\n$$\n\n**混叠引起的偏差 ($\\Delta I$)**\n\n偏差是两个计算出的积分之差：\n$$\n\\Delta I = I_{\\text{direct}} - I_{\\text{dealiased}}\n$$\n代入上面推导的表达式：\n$$\n\\Delta I = \\left( 2\\pi \\sum_{m=-\\infty}^{\\infty} c_{mN}^{(h)} \\right) - (2\\pi c_0^{(h)}) = 2\\pi \\sum_{m \\neq 0} c_{mN}^{(h)}\n$$\n由于 $h(x)$ 是实函数，其傅里叶系数满足 $c_{-k}^{(h)} = (c_k^{(h)})^*$，因此偏差可以写为：\n$$\n\\Delta I = 2\\pi \\sum_{m=1}^{\\infty} (c_{mN}^{(h)} + c_{-mN}^{(h)}) = 4\\pi \\sum_{m=1}^{\\infty} \\text{Re}(c_{mN}^{(h)})\n$$\n这表明，当且仅当乘积函数 $h(x)$ 在作为网格大小 $N$ 的非零倍数的波数上具有谱功率时，才会出现非零偏差。这些分量直接混叠到零波数（平均）分量上，从而破坏了积分的估计。如果 $h(x)$ 中的最大波数小于 $N$，则对于所有 $m \\geq 1$，都有 $c_{mN}^{(h)}=0$，导致偏差为零。\n\n解决该问题的算法如下：\n1. 对于每个测试用例，定义函数 $f(x)$ 和 $g(x)$ 的傅里叶系数 $(a_k, b_k)$。\n2. 实现一个函数，使用基于系数乘积的推导公式计算 $I_{\\text{dealiased}}$。\n3. 实现一个函数，该函数合成函数 $f(x)$ 和 $g(x)$，在指定的 $N$ 点网格上对其乘积 $h(x)$ 进行采样，并使用梯形法则求和计算 $I_{\\text{direct}}$。\n4. 对每个用例计算差值 $\\Delta I = I_{\\text{direct}} - I_{\\text{dealiased}}$。\n5. 收集并输出结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the aliasing-induced bias in the integral of a product of two\n    functions for a suite of test cases.\n    \"\"\"\n\n    # Test suite definition: (N, f_coeffs_spec, g_coeffs_spec)\n    # f_coeffs_spec is a list of tuples (type, k, value)\n    # where type is 'a' for cos coefficient or 'b' for sin coefficient.\n    test_cases = [\n        # Case 1: Well-resolved case\n        (64, [('a', 5, 1.0), ('b', 7, 0.4)], [('a', 5, 1.2), ('b', 7, -0.1)]),\n        # Case 2: Nyquist boundary condition\n        (32, [('a', 16, 1.0)], [('a', 16, 1.0)]),\n        # Case 3: Significant aliasing-induced bias\n        (32, [('a', 18, 1.0)], [('a', 14, 1.0)]),\n        # Case 4: Multi-mode aliasing scenario\n        (24, [('a', 17, 1.0), ('b', 5, 0.5)], [('a', 7, 1.3), ('b', 17, 0.5)]),\n        # Case 5: Well-resolved multi-mode case (with aliasing but no bias)\n        (48, [('a', 20, 0.8), ('b', 22, -0.5)], [('a', 20, 0.8), ('b', 22, -0.5)]),\n    ]\n\n    results = []\n    for N, f_spec, g_spec in test_cases:\n        \n        def parse_spec_to_coeffs(spec):\n            \"\"\"Parses coefficient specifications into a dictionary structure.\"\"\"\n            coeffs = {\"a0\": 0.0, \"ak\": {}, \"bk\": {}}\n            for typ, k, val in spec:\n                if typ == 'a' and k != 0:\n                    coeffs[\"ak\"][k] = val\n                elif typ == 'b' and k != 0:\n                    coeffs[\"bk\"][k] = val\n                elif typ == 'a' and k == 0:\n                    coeffs[\"a0\"] = val\n            return coeffs\n\n        f_coeffs = parse_spec_to_coeffs(f_spec)\n        g_coeffs = parse_spec_to_coeffs(g_spec)\n\n        def build_func_from_coeffs(coeffs):\n            \"\"\"Builds a callable Python function from a coefficient dictionary.\"\"\"\n            a0 = coeffs.get(\"a0\", 0.0)\n            ak_coeffs = coeffs.get(\"ak\", {})\n            bk_coeffs = coeffs.get(\"bk\", {})\n            \n            def func(x):\n                val = a0\n                for k, a_k in ak_coeffs.items():\n                    val += a_k * np.cos(k * x)\n                for k, b_k in bk_coeffs.items():\n                    val += b_k * np.sin(k * x)\n                return val\n            return func\n\n        f_func = build_func_from_coeffs(f_coeffs)\n        g_func = build_func_from_coeffs(g_coeffs)\n\n        # Method 1: Dealiased Spectral-Space Integral\n        def calculate_I_dealiased(f_c, g_c):\n            # I_dealiased = 2*pi*a0_f*a0_g + pi * sum(ak_f*ak_g + bk_f*bk_g)\n            a0_f = f_c.get(\"a0\", 0.0)\n            a0_g = g_c.get(\"a0\", 0.0)\n            \n            integral = 2.0 * np.pi * a0_f * a0_g\n            \n            sum_term = 0.0\n            all_k = set(f_c[\"ak\"].keys()) | set(f_c[\"bk\"].keys()) | \\\n                    set(g_c[\"ak\"].keys()) | set(g_c[\"bk\"].keys())\n            \n            for k in all_k:\n                ak_f = f_c[\"ak\"].get(k, 0.0)\n                bk_f = f_c[\"bk\"].get(k, 0.0)\n                ak_g = g_c[\"ak\"].get(k, 0.0)\n                bk_g = g_c[\"bk\"].get(k, 0.0)\n                sum_term += ak_f * ak_g + bk_f * bk_g\n                \n            integral += np.pi * sum_term\n            return integral\n\n        I_dealiased = calculate_I_dealiased(f_coeffs, g_coeffs)\n        \n        # Method 2: Direct Quadrature Integral\n        def calculate_I_direct(func_f, func_g, num_points):\n            # Grid points: x_n = 2*pi*n/N for n = 0,...,N-1\n            x_grid = np.linspace(0.0, 2.0 * np.pi, num_points, endpoint=False)\n            \n            f_vals = func_f(x_grid)\n            g_vals = func_g(x_grid)\n            h_vals = f_vals * g_vals\n            \n            # Trapezoidal rule for periodic function\n            integral = (2.0 * np.pi / num_points) * np.sum(h_vals)\n            return integral\n\n        I_direct = calculate_I_direct(f_func, g_func, N)\n\n        # Compute the bias\n        delta_I = I_direct - I_dealiased\n        results.append(delta_I)\n\n    # Format the final output string exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3615024"}]}