{"hands_on_practices": [{"introduction": "在深入研究复杂的旋转交错网格之前，我们必须首先理解它们试图解决的核心问题：数值各向异性。本练习 [@problem_id:3613876] 将直接比较标准的五点拉普拉斯算子模板与一个包含对角邻居、因而更具各向同性的九点模板。通过经验性地计算收敛阶并量化方向误差，您将对算子模板的选择如何影响模拟精度有切实的理解，并领会为何减少各向异性是计算波场模拟中的一个关键目标。", "problem": "考虑一个在计算地球物理学中常用于评估空间离散化精度和方向（角度）各向异性的二维标量波场模型问题。设标量场为 $f(x,y) = \\cos\\big(k \\big(x \\cos \\alpha + y \\sin \\alpha\\big)\\big)$，定义在一个周期性方形域 $\\Omega = [0,L]^2$ 上，其中 $L$ 是域的长度，$k$ 是波数，$\\alpha$ 是平面波的传播角。该场的精确拉普拉斯算子为 $\\Delta f(x,y) = -k^2 f(x,y)$。\n\n本问题侧重于旋转交错网格类型模板的误差分析、验证和收敛性，通过将一个标准的五点拉普拉斯算子（轴对齐模板）与一个旋转的九点拉普拉斯算子（包含对角线，即旋转邻居的贡献）进行比较。目标是量化截断误差，验证经验收敛阶，并评估各向异性作为传播角度的函数。\n\n你将使用以下两种离散拉普拉斯算子，作用于一个间距为 $h = L/N$ 的均匀网格上，并施加周期性边界条件：\n\n- 标准五点拉普拉斯算子（轴对齐）：\n$$\n\\Delta_h^{(5)} f_{i,j}\n=\n\\frac{f_{i+1,j} + f_{i-1,j} + f_{i,j+1} + f_{i,j-1} - 4 f_{i,j}}{h^2}.\n$$\n\n- 旋转九点拉普拉斯算子（轴对齐加对角线）：\n$$\n\\Delta_h^{(9)} f_{i,j}\n=\n\\frac{1}{6 h^2}\n\\left(\n4\\left(f_{i+1,j} + f_{i-1,j} + f_{i,j+1} + f_{i,j-1}\\right)\n+\n\\left(f_{i+1,j+1} + f_{i-1,j+1} + f_{i+1,j-1} + f_{i-1,j-1}\\right)\n- 20 f_{i,j}\n\\right).\n$$\n\n这些算子将在所有网格节点 $\\{(x_i,y_j)\\}$ 上进行评估，其中 $x_i = i h$，$y_j = j h$，整数 $i,j \\in \\{0,1,\\dots,N-1\\}$，并且索引对 $N$ 取模以强制周期性。具体来说，你必须在采样的标量场 $f_{i,j} = \\cos\\big(k (x_i \\cos \\alpha + y_j \\sin \\alpha)\\big)$ 上计算离散拉普拉斯算子，并将其与精确的拉普拉斯算子 $-k^2 f_{i,j}$进行比较。\n\n将具有 $N \\times N$ 个节点的网格的离散均方根误差（在欧几里得范数下）定义为\n$$\nE^{(s)}(N; k,\\alpha) = \\left(\n\\frac{1}{N^2} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1}\n\\left(\\Delta_h^{(s)} f_{i,j} + k^2 f_{i,j} \\right)^2\n\\right)^{1/2},\n$$\n其中上标 $(s)$ 对于五点算子是 $(5)$，对于九点算子是 $(9)$。\n\n基于第一性原理，你的程序必须：\n- 使用网格加密序列 $N, 2N, 4N$ 来近似经验收敛阶：\n$$\np^{(s)}(N; k,\\alpha) =\n\\frac{\\log\\left( E^{(s)}(N; k,\\alpha) / E^{(s)}(2N; k,\\alpha) \\right)}{\\log(2)}.\n$$\n为提高稳健性，类似地从 $(2N,4N)$ 对计算 $p^{(s)}(2N; k,\\alpha)$，并报告这两个阶数的平均值作为该测试用例的经验阶。\n\n- 在固定分辨率下，通过对多个角度采样误差来量化各向异性，并报告比率\n$$\n\\mathcal{A}^{(s)}(N;k) = \\frac{\\max_{\\alpha \\in \\mathcal{S}} E^{(s)}(N; k,\\alpha)}{\\min_{\\alpha \\in \\mathcal{S}} E^{(s)}(N; k,\\alpha)},\n$$\n其中 $\\mathcal{S}$ 是一组指定的角度。\n\n使用以下科学上一致的参数和测试套件。所有长度单位为米，波数单位为弧度/米，角度单位为弧度。在所有测试中，域长度固定为 $L = 1\\,\\mathrm{m}$。\n\n- 测试用例 1（标准情况）：$k = 12\\pi$，$\\alpha = \\pi/6$，基础分辨率 $N_0 = 24$；计算 $N \\in \\{N_0, 2N_0, 4N_0\\}$ 的经验阶，并报告该用例的列表 $[p^{(5)}, p^{(9)}]$。\n- 测试用例 2（对角线传播）：$k = 16\\pi$，$\\alpha = \\pi/4$，基础分辨率 $N_0 = 32$；如测试用例 1 那样计算经验阶，并报告 $[p^{(5)}, p^{(9)}]$。\n- 测试用例 3（轴对齐传播）：$k = 16\\pi$，$\\alpha = 0$，基础分辨率 $N_0 = 32$；如测试用例 1 那样计算经验阶，并报告 $[p^{(5)}, p^{(9)}]$。\n- 测试用例 4（固定分辨率下的各向异性评估）：$k = 12\\pi$，分辨率 $N = 64$，角度集 $\\mathcal{S} = \\{ m \\pi/12 : m = 0,1,\\dots,11\\}$；计算并报告列表 $[\\mathcal{A}^{(5)}, \\mathcal{A}^{(9)}]$。\n\n程序要求：\n- 角度必须以弧度为单位进行解释。\n- 所有报告的浮点数结果必须打印为四舍五入到六位小数。\n- 最终输出必须是单行，包含一个逗号分隔的列表，其中有四个项目，每个项目是对应上述测试用例的双元素列表。例如，输出必须具有以下确切格式：\n$[[p^{(5)}_1,p^{(9)}_1],[p^{(5)}_2,p^{(9)}_2],[p^{(5)}_3,p^{(9)}_3],[\\mathcal{A}^{(5)},\\mathcal{A}^{(9)}]]$\n且不含任何空白字符。\n\n你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，$ [[\\cdot,\\cdot],[\\cdot,\\cdot],[\\cdot,\\cdot],[\\cdot,\\cdot]] $），并且不得包含任何附加文本。输出中的所有数值都是如上定义的无单位浮点数。角度单位是弧度。域长度为 $L=1\\,\\mathrm{m}$，波数单位是弧度/米。输出值必须四舍五入到六位小数。", "solution": "该问题要求对二维周期域上拉普拉斯算子 $\\Delta = \\partial_{xx} + \\partial_{yy}$ 的两种有限差分近似进行严格比较。分析将集中于它们的数值精度、经验收敛阶和方向（各向异性）误差特性，这些是验证偏微分方程数值格式的基本课题，尤其是在计算地球物理学领域。\n\n首先，我们建立这两种模板的理论性质。分析在傅里叶域中进行，其中离散算子作用于平面波 $f(x,y) = e^{i(k_x x + k_y y)}$ 的效果由其符号 $\\hat{\\Delta}_h$ 表示。精确的连续拉普拉斯算子具有符号 $\\hat{\\Delta} = -(k_x^2+k_y^2) = -k^2$。离散算子的误差由其符号与精确符号之间的差给出。设 $\\theta_x = k_x h$ 和 $\\theta_y = k_y h$，其中 $h$ 是网格间距。\n\n五点模板 $\\Delta_h^{(5)}$ 的符号为：\n$$\n\\hat{\\Delta}_h^{(5)} = \\frac{2}{h^2}(\\cos(\\theta_x) + \\cos(\\theta_y) - 2)\n$$\n使用余弦的泰勒级数展开 $\\cos\\theta = 1 - \\theta^2/2! + \\theta^4/4! - \\dots$ 来展开此符号，得到：\n$$\n\\hat{\\Delta}_h^{(5)} = -k^2 + \\frac{h^2}{12}(k_x^4 + k_y^4) + O(h^4)\n$$\n截断误差的主项是 $\\frac{h^2}{12}(k_x^4 + k_y^4)$。该项的阶为 $O(h^2)$，因此该方法是二阶精度的。误差通过 $k_x = k \\cos\\alpha$ 和 $k_y = k \\sin\\alpha$ 依赖于传播方向 $\\alpha$，具体依赖于 $(\\cos^4\\alpha + \\sin^4\\alpha)$ 项。该项的值从轴对齐传播（$\\alpha=0, \\pi/2, \\dots$）时的最大值 $1$ 变化到对角线传播（$\\alpha=\\pi/4, 3\\pi/4, \\dots$）时的最小值 $1/2$，这表明存在显著的数值各向异性。\n\n九点模板 $\\Delta_h^{(9)}$ 的符号为：\n$$\n\\hat{\\Delta}_h^{(9)} = \\frac{1}{6h^2}(8\\cos(\\theta_x) + 8\\cos(\\theta_y) + 4\\cos(\\theta_x)\\cos(\\theta_y) - 20)\n$$\n对此符号进行类似的泰勒级数展开，可得：\n$$\n\\hat{\\Delta}_h^{(9)} = -k^2 + \\frac{h^2}{12}(k_x^2+k_y^2)^2 + O(h^4) = -k^2 + \\frac{h^2 k^4}{12} + O(h^4)\n$$\n主误差项是 $\\frac{h^2 k^4}{12}$。该算子也是二阶精度，$O(h^2)$。然而，其主误差项与传播角度 $\\alpha$ 无关。这表明九点模板比五点模板具有显著更强的各向同性，这是波传播模拟中一个非常理想的特性。数值实验旨在验证这些理论预测。\n\n解决方案以 Python 程序的形式实现，其结构如下：\n\n1.  定义一个函数 `compute_error(N, k, alpha, stencil_type)` 来执行核心误差计算。它接受网格大小 $N$、波数 $k$、角度 $\\alpha$ 和模板类型（$5$ 或 $9$）作为输入。\n    -   它首先在域 $[0,L]^2$（其中 $L=1$）上构建 $N \\times N$ 网格。\n    -   在该网格上计算解析标量场 $f_{i,j} = \\cos\\big(k (x_i \\cos \\alpha + y_j \\sin \\alpha)\\big)$ 及其精确的拉普拉斯算子 $-k^2 f_{i,j}$。\n    -   为指定的模板计算离散拉普拉斯算子 $\\Delta_h^{(s)} f_{i,j}$。周期性边界条件通过使用 `numpy.roll` 高效处理，该函数对网格数组执行循环移位以访问邻近点 $f_{i\\pm1, j\\pm1}$ 等。\n    -   最后，它计算问题陈述中定义的离散均方根（RMS）误差 $E^{(s)}(N; k,\\alpha)$。\n\n2.  一个函数 `compute_empirical_order(N0, k, alpha, stencil_type)` 用于计算收敛阶。\n    -   它对大小为 $N_0$、$2N_0$ 和 $4N_0$ 的一系列加密网格调用 `compute_error` 三次。\n    -   它使用公式 $p = \\log(E_N/E_{2N})/\\log(2)$，从网格 $(N_0, 2N_0)$ 的误差比计算一个收敛率，再从 $(2N_0, 4N_0)$ 计算另一个。\n    -   它返回这两个率的平均值，以提供对经验阶的更稳健的估计。\n\n3.  主函数 `solve()` 执行四个测试用例：\n    -   对于测试用例 1、2 和 3，使用指定的参数（$k, \\alpha, N_0$）为 $5$ 点和 $9$ 点模板调用 `compute_empirical_order`。结果 $[p^{(5)}, p^{(9)}]$ 被存储起来。\n    -   对于测试用例 4，评估各向异性。在固定分辨率 $N=64$ 和 $k=12\\pi$ 下，对一组角度 $\\mathcal{S} = \\{m\\pi/12\\}$ 调用 `compute_error` 函数。然后为两种模板计算各向异性度量 $\\mathcal{A}^{(s)} = \\max(E^{(s)})/\\min(E^{(s)})$。\n    -   将所有四个测试用例收集到的结果格式化为具有所需精度和结构的单个字符串，然后打印。此过程直接满足了问题的所有要求。\n\n这种基于原理的设计确保了实现不仅能产生正确的数值，而且建立在对所研究的底层数值方法的坚实理论理解之上。预计结果将显示两种模板的收敛阶都接近 $2.0$，且 $\\mathcal{A}^{(9)}$ 的各向异性比远低于 $\\mathcal{A}^{(5)}$，从而证实了理论分析。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_error(N, k, alpha, stencil_type):\n    \"\"\"\n    Computes the RMS error of a discrete Laplacian operator for a given plane wave.\n    \"\"\"\n    L = 1.0\n    h = L / N\n\n    # Grid generation\n    # x corresponds to columns (axis 1), y to rows (axis 0)\n    x_coords = np.arange(N) * h\n    y_coords = np.arange(N) * h\n    xx, yy = np.meshgrid(x_coords, y_coords, indexing='xy')\n\n    # Scalar field\n    f = np.cos(k * (xx * np.cos(alpha) + yy * np.sin(alpha)))\n\n    # Exact Laplacian of the field\n    lap_f_exact = -k**2 * f\n\n    # Discrete Laplacian computation\n    if stencil_type == 5:\n        # Standard 5-point stencil\n        # f_{i+1,j} is f rolled left along axis=1 (x-direction)\n        f_ip1_j = np.roll(f, -1, axis=1)\n        # f_{i-1,j} is f rolled right along axis=1\n        f_im1_j = np.roll(f, 1, axis=1)\n        # f_{i,j+1} is f rolled up along axis=0 (y-direction)\n        f_i_jp1 = np.roll(f, -1, axis=0)\n        # f_{i,j-1} is f rolled down along axis=0\n        f_i_jm1 = np.roll(f, 1, axis=0)\n        \n        lap_f_discrete = (f_ip1_j + f_im1_j + f_i_jp1 + f_i_jm1 - 4 * f) / h**2\n    \n    elif stencil_type == 9:\n        # Rotated 9-point stencil\n        f_ip1_j = np.roll(f, -1, axis=1)\n        f_im1_j = np.roll(f, 1, axis=1)\n        f_i_jp1 = np.roll(f, -1, axis=0)\n        f_i_jm1 = np.roll(f, 1, axis=0)\n        \n        f_ip1_jp1 = np.roll(f, (-1, -1), axis=(0, 1))\n        f_im1_jp1 = np.roll(f, (-1, 1), axis=(0, 1))\n        f_ip1_jm1 = np.roll(f, (1, -1), axis=(0, 1))\n        f_im1_jm1 = np.roll(f, (1, 1), axis=(0, 1))\n\n        S1 = f_ip1_j + f_im1_j + f_i_jp1 + f_i_jm1\n        S2 = f_ip1_jp1 + f_im1_jp1 + f_ip1_jm1 + f_im1_jm1\n        \n        lap_f_discrete = (1 / (6 * h**2)) * (4 * S1 + S2 - 20 * f)\n    \n    else:\n        raise ValueError(\"Invalid stencil type specified. Must be 5 or 9.\")\n\n    # RMS Error calculation\n    # The term to be squared is (Delta_h f + k^2 f), which is (Delta_h f - Delta_exact f)\n    diff_sq = (lap_f_discrete - lap_f_exact)**2\n    rms_error = np.sqrt(np.mean(diff_sq))\n    return rms_error\n\ndef compute_empirical_order(N0, k, alpha, stencil_type):\n    \"\"\"\n    Computes the empirical order of convergence using a grid refinement sequence.\n    \"\"\"\n    E_N0 = compute_error(N0, k, alpha, stencil_type)\n    E_2N0 = compute_error(2 * N0, k, alpha, stencil_type)\n    E_4N0 = compute_error(4 * N0, k, alpha, stencil_type)\n    \n    # Check for non-positive errors to avoid math domain errors\n    if E_N0 == 0 or E_2N0 == 0 or E_4N0 == 0:\n        return np.nan\n\n    p1 = np.log(E_N0 / E_2N0) / np.log(2)\n    p2 = np.log(E_2N0 / E_4N0) / np.log(2)\n    \n    return (p1 + p2) / 2\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    all_results = []\n    \n    # Test Case 1: Empirical order, happy path\n    k1, alpha1, N0_1 = 12 * np.pi, np.pi / 6, 24\n    p5_1 = compute_empirical_order(N0_1, k1, alpha1, 5)\n    p9_1 = compute_empirical_order(N0_1, k1, alpha1, 9)\n    all_results.append([p5_1, p9_1])\n\n    # Test Case 2: Empirical order, diagonal propagation\n    k2, alpha2, N0_2 = 16 * np.pi, np.pi / 4, 32\n    p5_2 = compute_empirical_order(N0_2, k2, alpha2, 5)\n    p9_2 = compute_empirical_order(N0_2, k2, alpha2, 9)\n    all_results.append([p5_2, p9_2])\n\n    # Test Case 3: Empirical order, axis-aligned propagation\n    k3, alpha3, N0_3 = 16 * np.pi, 0.0, 32\n    p5_3 = compute_empirical_order(N0_3, k3, alpha3, 5)\n    p9_3 = compute_empirical_order(N0_3, k3, alpha3, 9)\n    all_results.append([p5_3, p9_3])\n\n    # Test Case 4: Anisotropy assessment\n    k4, N4 = 12 * np.pi, 64\n    angles = [m * np.pi / 12 for m in range(12)]\n    \n    errors5 = [compute_error(N4, k4, alpha, 5) for alpha in angles]\n    errors9 = [compute_error(N4, k4, alpha, 9) for alpha in angles]\n    \n    A5 = np.max(errors5) / np.min(errors5)\n    A9 = np.max(errors9) / np.min(errors9)\n    all_results.append([A5, A9])\n\n    # Format the final output string exactly as required\n    result_strings = []\n    for res_pair in all_results:\n        # Format each number to 6 decimal places and create a string like \"[val1,val2]\"\n        result_strings.append(f\"[{res_pair[0]:.6f},{res_pair[1]:.6f}]\")\n    \n    # Join the individual strings for each test case into the final output format\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3613876"}, {"introduction": "分析任何数值波传播格式的强大工具是其离散频散关系，它将波的频率与波数矢量联系起来。本练习 [@problem_id:3613860] 将从抽象的误差概念转向具有物理意义的量：相速度和群速度。利用一个给定的旋转交错网格格式的频散关系，您将计算这些速度如何偏离其真实的物理值，并探索其对传播方向的依赖性，从而为该格式的数值各向异性提供一个定量的度量。", "problem": "给定一个二维、密度恒定的声学介质，其波速 $c$（单位：$\\mathrm{m/s}$）为常数。考虑声波的一阶速度-压力系统，\n$$\n\\frac{\\partial p}{\\partial t} = -K \\left( \\frac{\\partial v_x}{\\partial x} + \\frac{\\partial v_y}{\\partial y} \\right), \\quad\n\\frac{\\partial v_x}{\\partial t} = -\\frac{1}{\\rho} \\frac{\\partial p}{\\partial x}, \\quad\n\\frac{\\partial v_y}{\\partial t} = -\\frac{1}{\\rho} \\frac{\\partial p}{\\partial y},\n$$\n其中 $p$ 是压力，$v_x$ 和 $v_y$ 是速度分量，$K$ 是体积模量，$\\rho$ 是密度，且 $c^2 = K/\\rho$。该系统在均匀的旋转交错网格上进行离散化，空间上使用二阶精度的中心差分，时间上使用蛙跳格式。网格相对于物理坐标轴旋转了一个角度 $\\varphi$（单位：度）。等距的网格间距为 $\\Delta h$（单位：$\\mathrm{m}$），时间步长为 $\\Delta t$（单位：$\\mathrm{s}$）。定义库朗数 $\\nu = c \\Delta t / \\Delta h$。\n\n在波矢为 $\\mathbf{k}$、角频率为 $\\omega$ 的平面波拟设下，对旋转交错网格格式进行离散傅里叶（冯·诺依曼）分析，可得到形式如下的离散色散关系\n$$\n\\sin\\left( \\frac{\\omega \\Delta t}{2} \\right) = \\nu \\sqrt{ \\sin^2(\\alpha) + \\sin^2(\\beta) },\n$$\n其中\n$$\n\\alpha = \\frac{1}{2} f \\pi \\cos(\\theta - \\varphi), \\quad \\beta = \\frac{1}{2} f \\pi \\sin(\\theta - \\varphi),\n$$\n$f \\in (0,1]$ 是相对于奈奎斯特波数的无量纲波数大小分数（即 $|\\mathbf{k}| = f \\pi / \\Delta h$），$\\theta$（单位：度）是 $\\mathbf{k}$ 在物理坐标系中传播方向的方位角。角度 $\\theta$ 和 $\\varphi$ 在任何计算中都必须以弧度解释。\n\n群速度的大小为 $|\\nabla_{\\mathbf{k}} \\omega|$，相速度为 $c_{\\mathrm{phase}} = \\omega/|\\mathbf{k}|$。由于数值各向异性，两者都依赖于方向。使用上述色散关系，以下无量纲量化了数值各向异性：\n- 归一化群速度大小\n$$\n\\frac{|\\nabla_{\\mathbf{k}} \\omega|}{c} = \\frac{1}{2} \\frac{\\sqrt{ \\sin^2(2\\alpha) + \\sin^2(2\\beta) }}{ \\sqrt{ \\sin^2(\\alpha) + \\sin^2(\\beta) } } \\cdot \\frac{1}{ \\sqrt{ 1 - \\nu^2 \\left( \\sin^2(\\alpha) + \\sin^2(\\beta) \\right) } }.\n$$\n- 归一化相速度\n$$\n\\frac{c_{\\mathrm{phase}}}{c} = \\frac{2}{f \\pi \\nu} \\arcsin\\left( \\nu \\sqrt{ \\sin^2(\\alpha) + \\sin^2(\\beta) } \\right),\n$$\n以及方向相误差\n$$\n\\varepsilon(\\theta) = \\frac{c_{\\mathrm{phase}}}{c} - 1.\n$$\n\n您的任务是：\n- 实现一个程序，对于指定的参数，计算：\n  $1)$ 给定方向 $\\theta$ 上的归一化群速度大小 $|\\nabla_{\\mathbf{k}} \\omega|/c$，\n  $2)$ 同一方向 $\\theta$ 上的方向相误差 $\\varepsilon(\\theta)$，以及\n  $3)$ 对于给定的网格旋转角 $\\varphi$、波数分数 $f$ 和库朗数 $\\nu$，在所有方向 $\\theta \\in [0^\\circ, 360^\\circ)$ 上的最大绝对相误差。\n- 所有角度作为输入参数时必须以度为单位处理，但在内部计算时需转换为弧度。\n- 物理单位：$c$ 单位为 $\\mathrm{m/s}$，$\\Delta h$ 单位为 $\\mathrm{m}$，$\\Delta t$ 单位为 $\\mathrm{s}$。为保证数值稳定性和物理真实性，假设 $\\nu \\in (0,1/\\sqrt{2}]$。\n- 每个测试用例的输出必须是三个浮点数：$|\\nabla_{\\mathbf{k}} \\omega|/c$、$\\varepsilon(\\theta)$ 和 $\\max_{\\theta'} |\\varepsilon(\\theta')|$，每个数都四舍五入到六位小数。这些都是无量纲数。\n\n对所有测试用例使用以下固定的物理参数：\n- $c = 2000 \\ \\mathrm{m/s}$，\n- $\\Delta h = 10 \\ \\mathrm{m}$。\n\n在内部通过 $\\Delta t = \\nu \\Delta h / c$ 计算 $\\Delta t$。\n\n测试套件：\n为以下四组参数 $(\\varphi \\ \\mathrm{[deg]}, f, \\theta \\ \\mathrm{[deg]}, \\nu)$ 提供结果：\n- 测试 $1$：$(0.0, 0.3, 30.0, 0.6)$。\n- 测试 $2$：$(45.0, 0.6, 45.0, 0.6)$。\n- 测试 $3$：$(0.0, 0.8, 0.0, 0.6)$。\n- 测试 $4$：$(22.5, 0.05, 67.5, 0.6)$。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个含四个子列表（每个测试用例一个）的列表。每个子列表必须按顺序包含三个浮点数 $[|\\nabla_{\\mathbf{k}} \\omega|/c, \\varepsilon(\\theta), \\max_{\\theta'} |\\varepsilon(\\theta')|]$，每个数都四舍五入到六位小数。例如：\n\"[[a1,b1,c1],[a2,b2,c2],[a3,b3,c3],[a4,b4,c4]]\"，不含多余的空格或文本。\n\n角度单位要求：所有角度必须按规定以度为单位解释和处理，并在内部计算时转换为弧度。", "solution": "该问题要求对二维声波方程的二阶旋转交错网格有限差分格式引入的数值各向异性进行定量分析。该分析在傅里叶域中进行，从所提供的离散色散关系出发。主要任务是计算归一化群速度、特定传播方向的方向相误差，以及在所有可能方向上的最大绝对相误差。\n\n连续物理系统由一阶速度-压力声波方程描述：\n$$\n\\frac{\\partial p}{\\partial t} = -K \\left( \\frac{\\partial v_x}{\\partial x} + \\frac{\\partial v_y}{\\partial y} \\right)\n$$\n$$\n\\frac{\\partial v_x}{\\partial t} = -\\frac{1}{\\rho} \\frac{\\partial p}{\\partial x}, \\quad \\frac{\\partial v_y}{\\partial t} = -\\frac{1}{\\rho} \\frac{\\partial p}{\\partial y}\n$$\n在此连续介质中，波以等于介质波速 $c = \\sqrt{K/\\rho}$ 的恒定相速度和群速度各向同性地传播。在网格上进行离散化会引入数值色散，其中波速变得依赖于波的频率和相对于网格轴的传播方向。这种方向依赖性被称为数值各向异性。\n\n所提供的离散色散关系源于对数值格式的冯·诺依曼稳定性分析，其形式为\n$$\n\\sin\\left( \\frac{\\omega \\Delta t}{2} \\right) = \\nu \\sqrt{ \\sin^2(\\alpha) + \\sin^2(\\beta) }\n$$\n其中 $\\omega$ 是具有波矢 $\\mathbf{k}$ 的平面波的数值角频率。库朗数为 $\\nu = c \\Delta t / \\Delta h$。项 $\\alpha$ 和 $\\beta$ 是依赖于方向的归一化波数分量：\n$$\n\\alpha = \\frac{1}{2} |\\mathbf{k}| \\Delta h \\cos(\\theta - \\varphi) = \\frac{1}{2} f \\pi \\cos(\\theta - \\varphi)\n$$\n$$\n\\beta = \\frac{1}{2} |\\mathbf{k}| \\Delta h \\sin(\\theta - \\varphi) = \\frac{1}{2} f \\pi \\sin(\\theta - \\varphi)\n$$\n此处，$f$ 是无量纲波数大小，$\\theta$ 是物理传播方向，$\\varphi$ 是网格旋转角。\n\n数值相速度 $c_{\\mathrm{phase}} = \\omega / |\\mathbf{k}|$，衡量了等相面的速度。其归一化形式由色散关系推导得出。重新整理色散关系以解出 $\\omega$：\n$$\n\\omega = \\frac{2}{\\Delta t} \\arcsin\\left( \\nu \\sqrt{ \\sin^2(\\alpha) + \\sin^2(\\beta) } \\right)\n$$\n归一化相速度则为：\n$$\n\\frac{c_{\\mathrm{phase}}}{c} = \\frac{\\omega/|\\mathbf{k}|}{c} = \\frac{\\omega}{c |\\mathbf{k}|} = \\frac{\\omega}{c (f \\pi / \\Delta h)} = \\frac{\\omega \\Delta t}{c \\Delta t (f \\pi / \\Delta h)} = \\frac{\\omega \\Delta t}{\\nu f \\pi}\n$$\n代入 $\\omega$ 的表达式，得到问题陈述中提供的公式：\n$$\n\\frac{c_{\\mathrm{phase}}}{c} = \\frac{2}{f \\pi \\nu} \\arcsin\\left( \\nu \\sqrt{ \\sin^2(\\alpha) + \\sin^2(\\beta) } \\right)\n$$\n方向相误差 $\\varepsilon(\\theta) = c_{\\mathrm{phase}}/c - 1$，量化了与理想各向同性行为的偏差，在理想情况下，该值对所有 $\\theta$ 都应为零。\n\n数值群速度 $\\mathbf{v}_g = \\nabla_{\\mathbf{k}} \\omega$，描述了波包能量的传播速度。其大小为 $|\\nabla_{\\mathbf{k}} \\omega|$。其归一化大小的公式为\n$$\n\\frac{|\\nabla_{\\mathbf{k}} \\omega|}{c} = \\frac{1}{2} \\frac{\\sqrt{ \\sin^2(2\\alpha) + \\sin^2(2\\beta) }}{ \\sqrt{ \\sin^2(\\alpha) + \\sin^2(\\beta) } } \\cdot \\frac{1}{ \\sqrt{ 1 - \\nu^2 \\left( \\sin^2(\\alpha) + \\sin^2(\\beta) \\right) } }\n$$\n是通过对 $\\omega(\\mathbf{k})$ 的表达式关于波矢 $\\mathbf{k}$ 的分量求导得到的。\n\n实施计划如下：\n1.  将创建一套模块化函数来计算所需量。以度为单位提供的角度必须通过关系式 $\\theta_{\\mathrm{rad}} = \\theta_{\\mathrm{deg}} \\cdot \\pi / 180$ 转换为弧度，以便在三角函数中使用。\n2.  函数 `get_group_velocity_norm` 将实现归一化群速度大小的公式。\n3.  函数 `get_phase_error` 将实现方向相误差的公式。\n4.  为了找到最大绝对相误差 $\\max_{\\theta'} |\\varepsilon(\\theta')|$，我们观察到误差函数 $\\varepsilon$ 对 $\\theta'$ 的依赖仅通过差值 $\\theta' - \\varphi$ 体现。项 $\\sin^2(\\alpha)$ 和 $\\sin^2(\\beta)$ 赋予了核心表达式 $\\sin^2(\\alpha) + \\sin^2(\\beta)$ 一个 $\\pi/2$ 弧度（或 $90^\\circ$）的周期性。因此，可以通过在任何长度为 $90^\\circ$ 的区间上搜索来找到所有角度 $\\theta' \\in [0^\\circ, 360^\\circ)$ 上的最大误差。我们将使用 `scipy.optimize.minimize_scalar` 进行数值优化，以在 $\\theta' \\in [0^\\circ, 90^\\circ]$ 的范围内找到负绝对误差 $-|\\varepsilon(\\theta')|$ 的最小值。该最小值的相反数即为所求的最大绝对误差。\n5.  主循环将遍历提供的四个测试用例。对于每个用例，它将使用指定的参数 $(\\varphi, f, \\theta, \\nu)$ 调用已开发的函数，以计算所需的三个值。最终结果将被收集并按规定格式化为单个字符串。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef get_alpha_beta(phi_deg, f, theta_deg):\n    \"\"\"\n    Computes the intermediate angle-dependent terms alpha and beta.\n    All input angles are in degrees.\n    \"\"\"\n    phi_rad = np.deg2rad(phi_deg)\n    theta_rad = np.deg2rad(theta_deg)\n    \n    # Angle of propagation in the rotated grid coordinate system\n    theta_prime = theta_rad - phi_rad\n    \n    alpha = 0.5 * f * np.pi * np.cos(theta_prime)\n    beta = 0.5 * f * np.pi * np.sin(theta_prime)\n    \n    return alpha, beta\n\ndef get_phase_error(phi_deg, f, theta_deg, nu):\n    \"\"\"\n    Computes the directional phase error epsilon(theta).\n    \"\"\"\n    if f  1e-12: # For f -> 0, error is 0\n        return 0.0\n        \n    alpha, beta = get_alpha_beta(phi_deg, f, theta_deg)\n    \n    sin2_alpha = np.sin(alpha)**2\n    sin2_beta = np.sin(beta)**2\n    S = sin2_alpha + sin2_beta\n    \n    # Argument for arcsin must be in [-1, 1]. The stability condition ensures this,\n    # but clipping provides numerical robustness.\n    arg_asin = np.clip(nu * np.sqrt(S), -1.0, 1.0)\n    \n    c_phase_norm = (2.0 / (f * np.pi * nu)) * np.arcsin(arg_asin)\n    \n    return c_phase_norm - 1.0\n\ndef get_group_velocity_norm(phi_deg, f, theta_deg, nu):\n    \"\"\"\n    Computes the normalized group velocity magnitude |grad_k omega| / c.\n    \"\"\"\n    if f  1e-12: # For f -> 0, group velocity is c\n        return 1.0\n        \n    alpha, beta = get_alpha_beta(phi_deg, f, theta_deg)\n    \n    sin2_alpha = np.sin(alpha)**2\n    sin2_beta = np.sin(beta)**2\n    S = sin2_alpha + sin2_beta\n    \n    if S  1e-20: # For k -> 0, group velocity is c\n        return 1.0\n        \n    # Check for instability, though problem constraints should prevent this.\n    stability_term = 1.0 - nu**2 * S\n    if stability_term = 0:\n        return np.inf\n\n    sin2_2alpha = np.sin(2.0 * alpha)**2\n    sin2_2beta = np.sin(2.0 * beta)**2\n    \n    numerator_vg = 0.5 * np.sqrt(sin2_2alpha + sin2_2beta)\n    denominator_vg_1 = np.sqrt(S)\n    denominator_vg_2 = np.sqrt(stability_term)\n    \n    vg_norm = (numerator_vg / denominator_vg_1) / denominator_vg_2\n    return vg_norm\n\ndef get_max_abs_phase_error(phi_deg, f, nu):\n    \"\"\"\n    Finds the maximum absolute phase error over all propagation directions.\n    The error function has a 90-degree period, so we search over [0, 90].\n    \"\"\"\n    # The objective function to minimize is the negative of the absolute error.\n    def objective_func(theta_deg_for_opt):\n        err = get_phase_error(phi_deg, f, theta_deg_for_opt, nu)\n        return -np.abs(err)\n\n    # `minimize_scalar` finds the minimum of the objective function.\n    res = minimize_scalar(\n        objective_func,\n        bounds=(0.0, 90.0),\n        method='bounded'\n    )\n    \n    # The maximum absolute error is the negative of the found minimum.\n    max_abs_error = -res.fun\n    return max_abs_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the formatted results.\n    \"\"\"\n    # Test Suite: (phi [deg], f, theta [deg], nu)\n    test_cases = [\n        (0.0, 0.3, 30.0, 0.6),\n        (45.0, 0.6, 45.0, 0.6),\n        (0.0, 0.8, 0.0, 0.6),\n        (22.5, 0.05, 67.5, 0.6),\n    ]\n\n    # The problem specifies c and delta_h, but only nu is needed for the\n    # dimensionless quantities.\n    # c = 2000.0\n    # delta_h = 10.0\n\n    results_as_strings = []\n    for case in test_cases:\n        phi_deg, f, theta_deg, nu = case\n        \n        # 1. Compute normalized group velocity magnitude\n        vg_norm = get_group_velocity_norm(phi_deg, f, theta_deg, nu)\n        \n        # 2. Compute directional phase error\n        phase_err = get_phase_error(phi_deg, f, theta_deg, nu)\n        \n        # 3. Compute maximum absolute phase error\n        max_phase_err = get_max_abs_phase_error(phi_deg, f, nu)\n        \n        # Format the three results for the current test case\n        # using f-string formatting to ensure 6 decimal places.\n        sublist_str = (\n            f\"[{vg_norm:.6f},\"\n            f\"{phase_err:.6f},\"\n            f\"{max_phase_err:.6f}]\"\n        )\n        results_as_strings.append(sublist_str)\n\n    # Join all formatted sublists into the final output string\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "3613860"}, {"introduction": "除了正演模拟，旋转交错网格格式也是全波形反演 (FWI) 等高级应用的基石，而这些应用需要相应的伴随模型。本练习 [@problem_id:3613858] 将引导您深入一个严谨而关键的过程：为一个旋转网格系统推导其空间传播算子的离散伴随算子。通过在离散网格上应用分部求和原理并执行梯度检验，您将掌握一项开发和验证地球物理反演问题所需工具的核心技能。", "problem": "考虑旋转坐标系中的二维一阶线性声学系统，旋转角为 $\\theta=\\pi/4$（角度以弧度为单位）。设旋转后的单位方向为 $\\mathbf{e}_{s_1}=(\\mathbf{e}_x+\\mathbf{e}_y)/\\sqrt{2}$ 和 $\\mathbf{e}_{s_2}=(\\mathbf{e}_x-\\mathbf{e}_y)/\\sqrt{2}$。其连续介质方程为\n$$\n\\partial_t p \\;=\\; -\\kappa\\left(\\partial_{s_1} v_1 + \\partial_{s_2} v_2\\right),\\qquad\n\\partial_t v_1 \\;=\\; -\\frac{1}{\\rho}\\,\\partial_{s_1} p,\\qquad\n\\partial_t v_2 \\;=\\; -\\frac{1}{\\rho}\\,\\partial_{s_2} p,\n$$\n其中 $p$ 是压力，$v_1$ 和 $v_2$ 分别是沿 $s_1$ 和 $s_2$ 方向的速度分量，$\\kappa$ 是体积模量，$\\rho$ 是密度。\n\n在旋转交错网格上对该系统进行离散化，空间步长为 $\\Delta x=\\Delta y=1$，并在一个 $2\\times 2$ 的单元域上施加周期性边界条件。将 $p_{i,j}$ 放置在单元中心 $(i,j)\\in\\{0,1\\}\\times\\{0,1\\}$，将 $v_1$ 放置在由 $(i,j)\\in\\{0,1\\}^2$ 索引的对角边位置 $(i+\\tfrac{1}{2},j+\\tfrac{1}{2})$，将 $v_2$ 放置在由 $(i,j)\\in\\{0,1\\}^2$ 索引的反向对角边位置 $(i+\\tfrac{1}{2},j-\\tfrac{1}{2})$。定义离散方向导数为\n$$\n\\left[\\partial_{s_1} p\\right]_{i+\\frac{1}{2},\\,j+\\frac{1}{2}} \\;=\\; \\frac{p_{i+1,\\,j+1}-p_{i,\\,j}}{\\sqrt{2}},\\qquad\n\\left[\\partial_{s_2} p\\right]_{i+\\frac{1}{2},\\,j-\\frac{1}{2}} \\;=\\; \\frac{p_{i+1,\\,j}-p_{i,\\,j-1}}{\\sqrt{2}},\n$$\n以及离散散度为\n$$\n\\left[\\partial_{s_1} v_1\\right]_{i,\\,j} \\;=\\; \\frac{v_{1,\\,i+\\frac{1}{2},\\,j+\\frac{1}{2}}-v_{1,\\,i-\\frac{1}{2},\\,j-\\frac{1}{2}}}{\\sqrt{2}},\\qquad\n\\left[\\partial_{s_2} v_2\\right]_{i,\\,j} \\;=\\; \\frac{v_{2,\\,i+\\frac{1}{2},\\,j-\\frac{1}{2}}-v_{2,\\,i-\\frac{1}{2},\\,j+\\frac{1}{2}}}{\\sqrt{2}},\n$$\n所有索引均在模 2 意义下理解，以强制周期性。\n\n定义作用于状态向量 $\\mathbf{u}=[p,\\;v_1,\\;v_2]$ 的线性空间算子（传播子）$\\mathcal{L}$ 为\n$$\n\\left[\\mathcal{L}\\,\\mathbf{u}\\right]_p \\;=\\; \\kappa\\left(\\partial_{s_1} v_1 + \\partial_{s_2} v_2\\right),\\qquad\n\\left[\\mathcal{L}\\,\\mathbf{u}\\right]_{v_1} \\;=\\; \\frac{1}{\\rho}\\,\\partial_{s_1} p,\\qquad\n\\left[\\mathcal{L}\\,\\mathbf{u}\\right]_{v_2} \\;=\\; \\frac{1}{\\rho}\\,\\partial_{s_2} p.\n$$\n\n使用离散内积\n$$\n\\langle \\mathbf{a},\\mathbf{b}\\rangle \\;=\\; \\sum_{i,j} a_{p,\\,i,j}\\,b_{p,\\,i,j}\n\\;+\\; \\sum_{i,j} a_{v_1,\\,i,j}\\,b_{v_1,\\,i,j}\n\\;+\\; \\sum_{i,j} a_{v_2,\\,i,j}\\,b_{v_2,\\,i,j},\n$$\n其中求和遍及 $(i,j)\\in\\{0,1\\}^2$，并设置物理参数为 $\\rho=1$ 和 $\\kappa=2$。\n\n1) 从上述离散定义和伴随算子相对于内积的基本性质出发，推导显式的离散伴随算子 $\\mathcal{L}^\\dagger$，使得对于所有 $\\mathbf{a}$ 和 $\\mathbf{b}$，$\\langle \\mathbf{a}, \\mathcal{L}\\,\\mathbf{b}\\rangle = \\langle \\mathcal{L}^\\dagger \\mathbf{a}, \\mathbf{b}\\rangle$ 均成立。\n\n2) 使用您推导出的 $\\mathcal{L}^\\dagger$，通过对以下特定场计算 $\\langle \\mathbf{a}, \\mathcal{L}\\,\\mathbf{b}\\rangle$ 和 $\\langle \\mathcal{L}^\\dagger \\mathbf{a}, \\mathbf{b}\\rangle$ 的值来进行梯度检验：\n- 对于 $\\mathbf{b}$：\n  - $p^{(b)}_{0,0}=1$, $p^{(b)}_{1,0}=2$, $p^{(b)}_{0,1}=0$, $p^{(b)}_{1,1}=-1$。\n  - $v^{(b)}_{1,\\,0,0}=1$, $v^{(b)}_{1,\\,1,0}=0$, $v^{(b)}_{1,\\,0,1}=2$, $v^{(b)}_{1,\\,1,1}=-1$。\n  - $v^{(b)}_{2,\\,0,0}=3$, $v^{(b)}_{2,\\,1,0}=-2$, $v^{(b)}_{2,\\,0,1}=0$, $v^{(b)}_{2,\\,1,1}=1$。\n- 对于 $\\mathbf{a}$：\n  - $p^{(a)}_{0,0}=0$, $p^{(a)}_{1,0}=1$, $p^{(a)}_{0,1}=-2$, $p^{(a)}_{1,1}=3$。\n  - $v^{(a)}_{1,\\,0,0}=2$, $v^{(a)}_{1,\\,1,0}=-1$, $v^{(a)}_{1,\\,0,1}=1$, $v^{(a)}_{1,\\,1,1}=0$。\n  - $v^{(a)}_{2,\\,0,0}=0$, $v^{(a)}_{2,\\,1,0}=1$, $v^{(a)}_{2,\\,0,1}=-1$, $v^{(a)}_{2,\\,1,1}=2$。\n\n将最终的标量值表示为精确的解析表达式。无需四舍五入，不涉及物理单位。", "solution": "问题分为两部分：第一，对于给定的线性算子 $\\mathcal{L}$ 和指定的内积，推导离散伴随算子 $\\mathcal{L}^\\dagger$；第二，使用特定的场 $\\mathbf{a}$ 和 $\\mathbf{b}$ 进行数值梯度检验。\n\n### 第一部分：伴随算子 $\\mathcal{L}^\\dagger$ 的推导\n\n伴随算子 $\\mathcal{L}^\\dagger$ 由关系式 $\\langle \\mathbf{a}, \\mathcal{L}\\,\\mathbf{b}\\rangle = \\langle \\mathcal{L}^\\dagger \\mathbf{a}, \\mathbf{b}\\rangle$ 定义，对所有状态向量 $\\mathbf{a}=[p^{(a)}, v_1^{(a)}, v_2^{(a)}]$ 和 $\\mathbf{b}=[p^{(b)}, v_1^{(b)}, v_2^{(b)}]$ 均成立。内积由下式给出：\n$$\n\\langle \\mathbf{a},\\mathbf{b}\\rangle \\;=\\; \\sum_{i,j=0,1} p^{(a)}_{i,j}\\,p^{(b)}_{i,j}\n\\;+\\; \\sum_{i,j=0,1} v^{(a)}_{1,\\,i,j}\\,v^{(b)}_{1,\\,i,j}\n\\;+\\; \\sum_{i,j=0,1} v^{(a)}_{2,\\,i,j}\\,v^{(b)}_{2,\\,i,j}\n$$\n此处，整数索引 $(i,j)$ 用作交错网格位置的简写。\n\n我们首先写出伴随定义的左侧，即 $\\langle \\mathbf{a}, \\mathcal{L}\\,\\mathbf{b}\\rangle$：\n$$\n\\langle \\mathbf{a}, \\mathcal{L}\\,\\mathbf{b}\\rangle = \\sum_{i,j} p^{(a)}_{i,j} [\\mathcal{L}\\,\\mathbf{b}]_{p,i,j} + \\sum_{i,j} v^{(a)}_{1,i,j} [\\mathcal{L}\\,\\mathbf{b}]_{v_1,i,j} + \\sum_{i,j} v^{(a)}_{2,i,j} [\\mathcal{L}\\,\\mathbf{b}]_{v_2,i,j}\n$$\n$\\mathcal{L}\\mathbf{b}$ 的分量为：\n$$\n[\\mathcal{L}\\,\\mathbf{b}]_{p,i,j} = \\kappa\\left([\\partial_{s_1} v_1^{(b)}]_{i,j} + [\\partial_{s_2} v_2^{(b)}]_{i,j}\\right)\n$$\n$$\n[\\mathcal{L}\\,\\mathbf{b}]_{v_1,i,j} = \\frac{1}{\\rho}\\,[\\partial_{s_1} p^{(b)}]_{i,j}\n$$\n$$\n[\\mathcal{L}\\,\\mathbf{b}]_{v_2,i,j} = \\frac{1}{\\rho}\\,[\\partial_{s_2} p^{(b)}]_{i,j}\n$$\n代入离散算子：\n$$\n\\langle \\mathbf{a}, \\mathcal{L}\\,\\mathbf{b}\\rangle = \\sum_{i,j} p^{(a)}_{i,j} \\kappa\\left( \\frac{v^{(b)}_{1,i,j}-v^{(b)}_{1,i-1,j-1}}{\\sqrt{2}} + \\frac{v^{(b)}_{2,i,j}-v^{(b)}_{2,i-1,j+1}}{\\sqrt{2}} \\right) \\\\\n+ \\sum_{i,j} v^{(a)}_{1,i,j} \\frac{1}{\\rho} \\left( \\frac{p^{(b)}_{i+1,j+1}-p^{(b)}_{i,j}}{\\sqrt{2}} \\right) \\\\\n+ \\sum_{i,j} v^{(a)}_{2,i,j} \\frac{1}{\\rho} \\left( \\frac{p^{(b)}_{i+1,j}-p^{(b)}_{i,j-1}}{\\sqrt{2}} \\right)\n$$\n我们对每一项进行离散分部求和，将导数算子从 $\\mathbf{b}$ 移到 $\\mathbf{a}$。所有索引均在模 2 意义下处理。\n\n对于第一个和式中包含 $v_1^{(b)}$ 的项：\n$$\n\\sum_{i,j} p^{(a)}_{i,j} (v^{(b)}_{1,i,j}-v^{(b)}_{1,i-1,j-1}) = \\sum_{i,j} p^{(a)}_{i,j} v^{(b)}_{1,i,j} - \\sum_{i,j} p^{(a)}_{i,j} v^{(b)}_{1,i-1,j-1}\n$$\n对第二部分应用索引平移 $i' = i-1, j' = j-1$，得到 $\\sum_{i',j'} p^{(a)}_{i'+1,j'+1} v^{(b)}_{1,i',j'}$。因此，和式变为：\n$$\n\\sum_{i,j} (p^{(a)}_{i,j} - p^{(a)}_{i+1,j+1}) v^{(b)}_{1,i,j}\n$$\n对于第一个和式中包含 $v_2^{(b)}$ 的项：\n$$\n\\sum_{i,j} p^{(a)}_{i,j} (v^{(b)}_{2,i,j}-v^{(b)}_{2,i-1,j+1}) = \\sum_{i,j} p^{(a)}_{i,j} v^{(b)}_{2,i,j} - \\sum_{i,j} p^{(a)}_{i,j} v^{(b)}_{2,i-1,j+1}\n$$\n对第二部分应用索引平移 $i' = i-1, j' = j+1$，得到 $\\sum_{i',j'} p^{(a)}_{i'+1,j'-1} v^{(b)}_{2,i',j'}$。和式变为：\n$$\n\\sum_{i,j} (p^{(a)}_{i,j} - p^{(a)}_{i+1,j-1}) v^{(b)}_{2,i,j}\n$$\n对于第二个和式中（来自 $v_1$ 方程）包含 $p^{(b)}$ 的项：\n$$\n\\sum_{i,j} v^{(a)}_{1,i,j} (p^{(b)}_{i+1,j+1}-p^{(b)}_{i,j}) = \\sum_{i,j} v^{(a)}_{1,i,j} p^{(b)}_{i+1,j+1} - \\sum_{i,j} v^{(a)}_{1,i,j} p^{(b)}_{i,j}\n$$\n对第一部分应用索引平移 $i' = i+1, j' = j+1$，得到 $\\sum_{i',j'} v^{(a)}_{1,i'-1,j'-1} p^{(b)}_{i',j'}$。和式变为：\n$$\n\\sum_{i,j} (v^{(a)}_{1,i-1,j-1} - v^{(a)}_{1,i,j}) p^{(b)}_{i,j}\n$$\n对于第三个和式中（来自 $v_2$ 方程）包含 $p^{(b)}$ 的项：\n$$\n\\sum_{i,j} v^{(a)}_{2,i,j} (p^{(b)}_{i+1,j}-p^{(b)}_{i,j-1}) = \\sum_{i,j} v^{(a)}_{2,i,j} p^{(b)}_{i+1,j} - \\sum_{i,j} v^{(a)}_{2,i,j} p^{(b)}_{i,j-1}\n$$\n在第一部分平移索引 $i' = i+1, j' = j$，在第二部分平移索引 $i'=i, j'=j-1$，得到 $\\sum_{i',j'} (v^{(a)}_{2,i'-1,j'} - v^{(a)}_{2,i',j'+1}) p^{(b)}_{i',j'}$。和式变为：\n$$\n\\sum_{i,j} (v^{(a)}_{2,i-1,j} - v^{(a)}_{2,i,j+1}) p^{(b)}_{i,j}\n$$\n现在，我们收集乘以 $p^{(b)}$、$v_1^{(b)}$ 和 $v_2^{(b)}$ 的项来构造 $\\langle \\mathcal{L}^\\dagger \\mathbf{a}, \\mathbf{b}\\rangle$：\n$$\n\\langle \\mathcal{L}^\\dagger \\mathbf{a}, \\mathbf{b}\\rangle = \\sum_{i,j} p^{(b)}_{i,j} \\frac{1}{\\rho \\sqrt{2}} \\left( (v^{(a)}_{1,i-1,j-1} - v^{(a)}_{1,i,j}) + (v^{(a)}_{2,i-1,j} - v^{(a)}_{2,i,j+1}) \\right) \\\\\n+ \\sum_{i,j} v^{(b)}_{1,i,j} \\frac{\\kappa}{\\sqrt{2}} (p^{(a)}_{i,j} - p^{(a)}_{i+1,j+1}) \\\\\n+ \\sum_{i,j} v^{(b)}_{2,i,j} \\frac{\\kappa}{\\sqrt{2}} (p^{(a)}_{i,j} - p^{(a)}_{i+1,j-1})\n$$\n通过将其与内积 $\\langle \\mathcal{L}^\\dagger \\mathbf{a}, \\mathbf{b}\\rangle$ 的定义进行比较，我们确定 $\\mathcal{L}^\\dagger \\mathbf{a}$ 的分量：\n$$\n[\\mathcal{L}^\\dagger\\mathbf{a}]_{p,i,j} = \\frac{1}{\\rho\\sqrt{2}} \\left( v^{(a)}_{1,i-1,j-1} - v^{(a)}_{1,i,j} + v^{(a)}_{2,i-1,j} - v^{(a)}_{2,i,j+1} \\right) = -\\frac{1}{\\rho}\\left( \\frac{v^{(a)}_{1,i,j} - v^{(a)}_{1,i-1,j-1}}{\\sqrt{2}} + \\frac{v^{(a)}_{2,i,j+1} - v^{(a)}_{2,i-1,j}}{\\sqrt{2}} \\right)\n$$\n$$\n[\\mathcal{L}^\\dagger\\mathbf{a}]_{v_1,i,j} = \\frac{\\kappa}{\\sqrt{2}} (p^{(a)}_{i,j} - p^{(a)}_{i+1,j+1}) = -\\kappa \\frac{p^{(a)}_{i+1,j+1} - p^{(a)}_{i,j}}{\\sqrt{2}}\n$$\n$$\n[\\mathcal{L}^\\dagger\\mathbf{a}]_{v_2,i,j} = \\frac{\\kappa}{\\sqrt{2}} (p^{(a)}_{i,j} - p^{(a)}_{i+1,j-1}) = -\\kappa \\frac{p^{(a)}_{i+1,j-1} - p^{(a)}_{i,j}}{\\sqrt{2}}\n$$\n这些方程定义了显式的离散伴随算子 $\\mathcal{L}^\\dagger$。\n\n### 第二部分：梯度检验\n\n我们现在通过计算给定数值和参数 $\\rho=1$, $\\kappa=2$ 下的 $\\langle \\mathbf{a}, \\mathcal{L}\\,\\mathbf{b}\\rangle$ 和 $\\langle \\mathcal{L}^\\dagger \\mathbf{a}, \\mathbf{b}\\rangle$ 来进行梯度检验。所有索引均在模 2 意义下处理。\n\n输入场为：\n$p^{(b)} = \\begin{pmatrix} 1   2 \\\\ 0  -1 \\end{pmatrix}$, $v^{(b)}_1 = \\begin{pmatrix} 1  0 \\\\ 2  -1 \\end{pmatrix}$, $v^{(b)}_2 = \\begin{pmatrix} 3  -2 \\\\ 0  1 \\end{pmatrix}$\n$p^{(a)} = \\begin{pmatrix} 0  1 \\\\ -2  3 \\end{pmatrix}$, $v^{(a)}_1 = \\begin{pmatrix} 2  -1 \\\\ 1  0 \\end{pmatrix}$, $v^{(a)}_2 = \\begin{pmatrix} 0  1 \\\\ -1  2 \\end{pmatrix}$\n\n**计算 $\\langle \\mathbf{a}, \\mathcal{L}\\,\\mathbf{b}\\rangle$**\n\n首先，我们计算 $\\mathbf{c} = \\mathcal{L}\\mathbf{b}$：\n$c_{p,i,j} = \\frac{2}{\\sqrt{2}}\\left( (v^{(b)}_{1,i,j}-v^{(b)}_{1,i-1,j-1}) + (v^{(b)}_{2,i,j}-v^{(b)}_{2,i-1,j+1}) \\right)$\n$c_{p,0,0} = \\sqrt{2}[(1 - (-1)) + (3 - 1)] = 4\\sqrt{2}$\n$c_{p,1,0} = \\sqrt{2}[(0 - 2) + (-2 - 0)] = -4\\sqrt{2}$\n$c_{p,0,1} = \\sqrt{2}[(2 - 0) + (0 - (-2))] = 4\\sqrt{2}$\n$c_{p,1,1} = \\sqrt{2}[(-1 - 1) + (1 - 3)] = -4\\sqrt{2}$\n\n$c_{v_1,i,j} = \\frac{1}{\\sqrt{2}}(p^{(b)}_{i+1,j+1}-p^{(b)}_{i,j})$\n$c_{v_1,0,0} = \\frac{1}{\\sqrt{2}}(-1-1) = -2/\\sqrt{2}$\n$c_{v_1,1,0} = \\frac{1}{\\sqrt{2}}(0-2) = -2/\\sqrt{2}$\n$c_{v_1,0,1} = \\frac{1}{\\sqrt{2}}(2-0) = 2/\\sqrt{2}$\n$c_{v_1,1,1} = \\frac{1}{\\sqrt{2}}(1-(-1)) = 2/\\sqrt{2}$\n\n$c_{v_2,i,j} = \\frac{1}{\\sqrt{2}}(p^{(b)}_{i+1,j}-p^{(b)}_{i,j-1})$\n$c_{v_2,0,0} = \\frac{1}{\\sqrt{2}}(2-0) = 2/\\sqrt{2}$\n$c_{v_2,1,0} = \\frac{1}{\\sqrt{2}}(1-(-1)) = 2/\\sqrt{2}$\n$c_{v_2,0,1} = \\frac{1}{\\sqrt{2}}(-1-1) = -2/\\sqrt{2}$\n$c_{v_2,1,1} = \\frac{1}{\\sqrt{2}}(0-2) = -2/\\sqrt{2}$\n\n现在，计算内积 $\\langle \\mathbf{a}, \\mathbf{c} \\rangle = \\sum p^{(a)}_{i,j}c_{p,i,j} + \\sum v^{(a)}_{1,i,j}c_{v_1,i,j} + \\sum v^{(a)}_{2,i,j}c_{v_2,i,j}$：\n$\\sum p^{(a)}c_p = 0(4\\sqrt{2}) + 1(-4\\sqrt{2}) + (-2)(4\\sqrt{2}) + 3(-4\\sqrt{2}) = (-4 - 8 - 12)\\sqrt{2} = -24\\sqrt{2}$\n$\\sum v^{(a)}_1 c_{v_1} = \\frac{1}{\\sqrt{2}}[2(-2) + (-1)(-2) + 1(2) + 0(2)] = \\frac{1}{\\sqrt{2}}[-4 + 2 + 2] = 0$\n$\\sum v^{(a)}_2 c_{v_2} = \\frac{1}{\\sqrt{2}}[0(2) + 1(2) + (-1)(-2) + 2(-2)] = \\frac{1}{\\sqrt{2}}[2 + 2 - 4] = 0$\n因此，$\\langle \\mathbf{a}, \\mathcal{L}\\,\\mathbf{b}\\rangle = -24\\sqrt{2}$。\n\n**计算 $\\langle \\mathcal{L}^\\dagger \\mathbf{a}, \\mathbf{b}\\rangle$**\n\n首先，我们计算 $\\mathbf{d} = \\mathcal{L}^\\dagger\\mathbf{a}$：\n$d_{p,i,j} = -\\frac{1}{\\sqrt{2}} \\left( (v^{(a)}_{1,i,j}-v^{(a)}_{1,i-1,j-1}) + (v^{(a)}_{2,i,j+1}-v^{(a)}_{2,i-1,j}) \\right)$\n$d_{p,0,0} = -\\frac{1}{\\sqrt{2}}[(2-0) + (-1-1)] = 0$\n$d_{p,1,0} = -\\frac{1}{\\sqrt{2}}[(-1-1) + (2-0)] = 0$\n$d_{p,0,1} = -\\frac{1}{\\sqrt{2}}[(1-(-1)) + (0-2)] = 0$\n$d_{p,1,1} = -\\frac{1}{\\sqrt{2}}[(0-2) + (1-(-1))] = 0$\n\n$d_{v_1,i,j} = -\\frac{2}{\\sqrt{2}} (p^{(a)}_{i+1,j+1} - p^{(a)}_{i,j})$\n$d_{v_1,0,0} = -\\sqrt{2}(3-0) = -3\\sqrt{2}$\n$d_{v_1,1,0} = -\\sqrt{2}(-2-1) = 3\\sqrt{2}$\n$d_{v_1,0,1} = -\\sqrt{2}(1-(-2)) = -3\\sqrt{2}$\n$d_{v_1,1,1} = -\\sqrt{2}(0-3) = 3\\sqrt{2}$\n\n$d_{v_2,i,j} = -\\frac{2}{\\sqrt{2}} (p^{(a)}_{i+1,j-1} - p^{(a)}_{i,j})$\n$d_{v_2,0,0} = -\\sqrt{2}(p^{(a)}_{1,1}-p^{(a)}_{0,0}) = -\\sqrt{2}(3-0) = -3\\sqrt{2}$\n$d_{v_2,1,0} = -\\sqrt{2}(p^{(a)}_{0,1}-p^{(a)}_{1,0}) = -\\sqrt{2}(-2-1) = 3\\sqrt{2}$\n$d_{v_2,0,1} = -\\sqrt{2}(p^{(a)}_{1,0}-p^{(a)}_{0,1}) = -\\sqrt{2}(1-(-2)) = -3\\sqrt{2}$\n$d_{v_2,1,1} = -\\sqrt{2}(p^{(a)}_{0,0}-p^{(a)}_{1,1}) = -\\sqrt{2}(0-3) = 3\\sqrt{2}$\n\n现在，计算内积 $\\langle \\mathbf{d}, \\mathbf{b} \\rangle = \\sum d_{p,i,j}p^{(b)}_{i,j} + \\sum d_{v_1,i,j}v^{(b)}_{1,i,j} + \\sum d_{v_2,i,j}v^{(b)}_{2,i,j}$：\n$\\sum d_p p^{(b)} = 0$\n$\\sum d_{v_1}v^{(b)}_1 = (-3\\sqrt{2})(1) + (3\\sqrt{2})(0) + (-3\\sqrt{2})(2) + (3\\sqrt{2})(-1) = (-3 - 6 - 3)\\sqrt{2} = -12\\sqrt{2}$\n$\\sum d_{v_2}v^{(b)}_2 = (-3\\sqrt{2})(3) + (3\\sqrt{2})(-2) + (-3\\sqrt{2})(0) + (3\\sqrt{2})(1) = (-9 - 6 + 3)\\sqrt{2} = -12\\sqrt{2}$\n因此，$\\langle \\mathcal{L}^\\dagger \\mathbf{a}, \\mathbf{b}\\rangle = 0 - 12\\sqrt{2} - 12\\sqrt{2} = -24\\sqrt{2}$。\n\n两次计算得到相同的结果，这证实了所推导的伴随算子 $\\mathcal{L}^\\dagger$ 的正确性，并成功完成了梯度检验。最终的标量值为 $-24\\sqrt{2}$。", "answer": "$$\n\\boxed{-24\\sqrt{2}}\n$$", "id": "3613858"}]}