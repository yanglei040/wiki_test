{"hands_on_practices": [{"introduction": "有限元法的核心在于将复杂域上的连续问题分解为一系列在简单“参考单元”上的计算。这个过程的基石是形函数（或称基函数），它们在参考单元上定义，并用于近似真实解。本练习将指导您在标准三角形参考单元上，为线性和二次拉格朗日元构建这些关键的形函数，并验证它们必须满足的基本数学性质——单位分解性和克罗内克-德尔塔插值特性，这是理解有限元插值和后续计算的根本出发点。[@problem_id:3595599]", "problem": "考虑在域 $\\Omega \\subset \\mathbb{R}^{2}$ 上定义的二维泊松方程 $-\\nabla \\cdot \\left( \\kappa \\nabla u \\right) = f$，其中 $\\kappa$ 是一个空间变化的标量传导率，代表计算地球物理学中的地下材料，而 $f$ 是一个源项，例如，代表由密度变化引起的体力。在有限元法 (FEM) 中，使用协调拉格朗日单元来逼近弱解，这需要在一个参考单元上构建形函数，并验证它们的插值性质。\n\n设参考三角形为 $\\hat{K} = \\{ (\\xi,\\eta) \\in \\mathbb{R}^{2} : \\xi \\ge 0,\\ \\eta \\ge 0,\\ \\xi + \\eta \\le 1 \\}$，其顶点位于 $(0,0)$、$(1,0)$ 和 $(0,1)$。用 $\\lambda_{1} = 1 - \\xi - \\eta$，$\\lambda_{2} = \\xi$ 和 $\\lambda_{3} = \\eta$ 表示重心坐标。\n\n任务：\n- 构建在 $\\hat{K}$ 上的分片线性 ($P_{1}$) 拉格朗日单元的形函数，并在三个顶点节点处验证其单位分解性和克罗内克-δ插值性质。\n- 构建在 $\\hat{K}$ 上的与六个节点（三个顶点和三条边的中点）相关联的分片二次 ($P_{2}$) 拉格朗日单元的形函数，并在所有六个节点处验证其单位分解性和克罗内克-δ插值性质。\n- 作为与泊松方程有限元离散化中质量矩阵组装相关的定量一致性检验，计算标量积分\n$$\nJ_{2} \\;=\\; \\int_{\\hat{K}} \\left( \\sum_{i=1}^{6} \\phi_{i}^{(2)}(\\xi,\\eta)^{2} \\right)\\, d\\xi\\, d\\eta,\n$$\n其中 $\\{ \\phi_{i}^{(2)} \\}_{i=1}^{6}$ 是在 $\\hat{K}$ 上构建的 $P_{2}$ 形函数。以单个实数的形式提供 $J_{2}$ 的精确值。不要四舍五入；给出精确值。", "solution": "该问题要求在参考三角形 $\\hat{K}$ 上为线性 ($P_1$) 和二次 ($P_2$) 多项式构建和验证拉格朗日有限元形函数，并通过计算一个涉及 $P_2$ 形函数的特定积分进行后续的定量检验。该问题是适定的且在科学上是合理的，它基于有限元法的基本原理。\n\n设参考三角形为 $\\hat{K} = \\{ (\\xi,\\eta) \\in \\mathbb{R}^{2} : \\xi \\ge 0,\\ \\eta \\ge 0,\\ \\xi + \\eta \\le 1 \\}$。顶点位于 $v_{1} = (0,0)$、$v_{2} = (1,0)$ 和 $v_{3} = (0,1)$。重心坐标是 $\\hat{K}$ 上的线性函数，由 $\\lambda_{1} = 1 - \\xi - \\eta$、$\\lambda_{2} = \\xi$ 和 $\\lambda_{3} = \\eta$ 给出。重心坐标的一个关键性质是，在 $\\hat{K}$ 中的任意点 $(\\xi, \\eta)$，它们都是非负的并且总和为1：$\\lambda_{1} + \\lambda_{2} + \\lambda_{3} = 1$。此外，坐标 $\\lambda_i$ 在顶点 $v_i$ 处等于 $1$，在另外两个顶点处等于 $0$。\n\n**第1部分：$P_1$ 拉格朗日单元**\n\n三角形 $\\hat{K}$ 上的分片线性 ($P_1$) 拉格朗日单元由一组3个节点定义，这些节点是三角形的顶点：$n_1 = v_1 = (0,0)$、$n_2 = v_2 = (1,0)$ 和 $n_3 = v_3 = (0,1)$。相应的形函数，记为 $\\phi_i^{(1)}$，必须是线性多项式，并满足克罗内克-δ性质，即 $\\phi_i^{(1)}(n_j) = \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克-δ。\n\n重心坐标本身就是线性函数，并且在顶点处内在地满足此性质。因此，$P_1$ 形函数就是重心坐标：\n- $\\phi_{1}^{(1)}(\\xi,\\eta) = \\lambda_{1} = 1 - \\xi - \\eta$\n- $\\phi_{2}^{(1)}(\\xi,\\eta) = \\lambda_{2} = \\xi$\n- $\\phi_{3}^{(1)}(\\xi,\\eta) = \\lambda_{3} = \\eta$\n\n我们验证所需的性质：\n1.  **克罗内克-δ性质**：我们在每个节点上计算每个形函数的值。\n    - 在 $n_1 = (0,0)$ 处：$(\\lambda_1, \\lambda_2, \\lambda_3) = (1,0,0)$。所以，$\\phi_{1}^{(1)}(n_1)=1$，$\\phi_{2}^{(1)}(n_1)=0$，$\\phi_{3}^{(1)}(n_1)=0$。\n    - 在 $n_2 = (1,0)$ 处：$(\\lambda_1, \\lambda_2, \\lambda_3) = (0,1,0)$。所以，$\\phi_{1}^{(1)}(n_2)=0$，$\\phi_{2}^{(1)}(n_2)=1$，$\\phi_{3}^{(1)}(n_2)=0$。\n    - 在 $n_3 = (0,1)$ 处：$(\\lambda_1, \\lambda_2, \\lambda_3) = (0,0,1)$。所以，$\\phi_{1}^{(1)}(n_3)=0$，$\\phi_{2}^{(1)}(n_3)=0$，$\\phi_{3}^{(1)}(n_3)=1$。\n    对于 $i,j \\in \\{1,2,3\\}$，性质 $\\phi_i^{(1)}(n_j) = \\delta_{ij}$ 得到满足。\n\n2.  **单位分解性质**：在单元上的任何地方，形函数的总和必须等于1。\n    $$ \\sum_{i=1}^{3} \\phi_{i}^{(1)}(\\xi,\\eta) = \\phi_{1}^{(1)} + \\phi_{2}^{(1)} + \\phi_{3}^{(1)} = \\lambda_{1} + \\lambda_{2} + \\lambda_{3} = (1-\\xi-\\eta) + \\xi + \\eta = 1 $$\n    对于所有 $(\\xi, \\eta) \\in \\hat{K}$，此性质均得到满足。\n\n**第2部分：$P_2$ 拉格朗日单元**\n\n分片二次 ($P_2$) 拉格朗日单元由6个节点定义：3个顶点和3条边的中点。我们将节点定义为：\n- 顶点：$n_1 = (0,0)$、$n_2 = (1,0)$、$n_3 = (0,1)$。\n- 边的中点：$n_4 = (\\frac{1}{2},0)$（$n_1$-$n_2$ 的中点）、$n_5 = (\\frac{1}{2},\\frac{1}{2})$（$n_2$-$n_3$ 的中点）和 $n_6 = (0,\\frac{1}{2})$（$n_3$-$n_1$ 的中点）。\n\n这些节点的重心坐标是：\n- $n_1 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (1,0,0)$\n- $n_2 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (0,1,0)$\n- $n_3 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (0,0,1)$\n- $n_4 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (\\frac{1}{2},\\frac{1}{2},0)$\n- $n_5 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (0,\\frac{1}{2},\\frac{1}{2})$\n- $n_6 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (\\frac{1}{2},0,\\frac{1}{2})$\n\n$P_2$ 形函数 $\\phi_i^{(2)}$ 是使用重心坐标的乘积构造的二次多项式。\n- 对于顶点节点 $n_i$（其中 $i=1,2,3$），形函数的形式为 $\\phi_{i}^{(2)} = c_i \\lambda_i (\\lambda_i - \\frac{1}{2})$。归一化常数 $c_i$ 是通过要求 $\\phi_i^{(2)}(n_i)=1$ 来找到的。在 $n_i$ 处，$\\lambda_i=1$，所以 $c_i(1)(1-\\frac{1}{2}) = 1 \\implies c_i = 2$。因此，$\\phi_{i}^{(2)} = 2\\lambda_i(\\lambda_i - \\frac{1}{2}) = \\lambda_i(2\\lambda_i - 1)$。\n- 对于位于顶点 $n_i$ 和 $n_j$ 之间边上的中点节点 $n_k$（其中 $k=4,5,6$），形函数的形式为 $\\phi_{k}^{(2)} = c_k \\lambda_i \\lambda_j$。常数 $c_k$ 是通过要求 $\\phi_k^{(2)}(n_k)=1$ 来找到的。在 $n_k$ 处，$\\lambda_i=\\lambda_j=\\frac{1}{2}$，所以 $c_k(\\frac{1}{2})(\\frac{1}{2})=1 \\implies c_k=4$。因此，形函数为 $\\phi_{k}^{(2)} = 4\\lambda_i \\lambda_j$。\n\n这6个形函数是：\n- 顶点节点：\n  - $\\phi_{1}^{(2)} = \\lambda_{1}(2\\lambda_{1} - 1)$\n  - $\\phi_{2}^{(2)} = \\lambda_{2}(2\\lambda_{2} - 1)$\n  - $\\phi_{3}^{(2)} = \\lambda_{3}(2\\lambda_{3} - 1)$\n- 中点节点：\n  - $\\phi_{4}^{(2)} = 4\\lambda_{1}\\lambda_{2}$ (对于 $n_1$ 和 $n_2$ 之间的节点 $n_4$)\n  - $\\phi_{5}^{(2)} = 4\\lambda_{2}\\lambda_{3}$ (对于 $n_2$ 和 $n_3$ 之间的节点 $n_5$)\n  - $\\phi_{6}^{(2)} = 4\\lambda_{3}\\lambda_{1}$ (对于 $n_3$ 和 $n_1$ 之间的节点 $n_6$)\n\n我们验证其性质：\n1.  **克罗内克-δ性质**：我们必须验证对于所有的 $i,j \\in \\{1, \\dots, 6\\}$，都有 $\\phi_i^{(2)}(n_j) = \\delta_{ij}$。这是一个系统性的检查。\n    - 对于顶点形函数 $\\phi_i^{(2)}$（$i \\in \\{1,2,3\\}$）：在任何顶点 $n_j$ 处，一个 $\\lambda_k$ 为 $1$，其余为 $0$。所以 $\\phi_i^{(2)}(n_j) = \\delta_{ij}(2\\delta_{ij}-1)|_{n_j} = \\delta_{ij}$。在任何中点 $n_k$ 处，两个 $\\lambda$ 为 $\\frac{1}{2}$，一个为 $0$。如果 $\\phi_i^{(2)}$ 对应于不在这条边上的顶点，则其 $\\lambda_i=0$，因此 $\\phi_i^{(2)}=0$。如果它对应于边上的一个顶点，则其 $\\lambda_i=\\frac{1}{2}$，因此 $\\phi_i^{(2)} = \\frac{1}{2}(2(\\frac{1}{2})-1)=0$。因此，顶点形函数在自己的节点处为 $1$，在所有其他节点处为 $0$。\n    - 对于中点形函数 $\\phi_k^{(2)}$（$k \\in \\{4,5,6\\}$），例如 $\\phi_4^{(2)} = 4\\lambda_1\\lambda_2$：在任何顶点 $n_j$ 处，$\\lambda_1=0$ 或 $\\lambda_2=0$（或两者都为0），因此 $\\phi_4^{(2)}(n_j)=0$。在其自身的节点 $n_4$ 处，$\\lambda_1=\\lambda_2=\\frac{1}{2}$，所以 $\\phi_4^{(2)}(n_4) = 4(\\frac{1}{2})(\\frac{1}{2})=1$。在其他中点 $n_5$ 或 $n_6$ 处，$\\lambda_1=0$ 或 $\\lambda_2=0$，因此 $\\phi_4^{(2)}$ 为零。\n    所有6个形函数都满足克罗内克-δ性质。\n\n2.  **单位分解性质**：\n    $$ \\sum_{i=1}^{6} \\phi_i^{(2)} = \\sum_{i=1}^{3} \\lambda_i(2\\lambda_i - 1) + 4\\lambda_1\\lambda_2 + 4\\lambda_2\\lambda_3 + 4\\lambda_3\\lambda_1 $$\n    $$ = (2\\lambda_1^2 - \\lambda_1) + (2\\lambda_2^2 - \\lambda_2) + (2\\lambda_3^2 - \\lambda_3) + 4\\lambda_1\\lambda_2 + 4\\lambda_2\\lambda_3 + 4\\lambda_3\\lambda_1 $$\n    $$ = 2(\\lambda_1^2 + \\lambda_2^2 + \\lambda_3^2 + 2\\lambda_1\\lambda_2 + 2\\lambda_2\\lambda_3 + 2\\lambda_3\\lambda_1) - (\\lambda_1 + \\lambda_2 + \\lambda_3) $$\n    此表达式使用恒等式 $(\\lambda_1+\\lambda_2+\\lambda_3)^2 = \\lambda_1^2+\\lambda_2^2+\\lambda_3^2+2\\lambda_1\\lambda_2+2\\lambda_2\\lambda_3+2\\lambda_3\\lambda_1$ 进行简化：\n    $$ = 2(\\lambda_1 + \\lambda_2 + \\lambda_3)^2 - (\\lambda_1 + \\lambda_2 + \\lambda_3) $$\n    由于 $\\lambda_1 + \\lambda_2 + \\lambda_3 = 1$，总和为 $2(1)^2 - 1 = 1$。单位分解性质得到满足。\n\n**第3部分：积分 $J_2$ 的计算**\n\n我们需要计算 $J_{2} = \\int_{\\hat{K}} \\left( \\sum_{i=1}^{6} \\phi_{i}^{(2)}(\\xi,\\eta)^{2} \\right)\\, d\\xi\\, d\\eta$。我们可以计算每个形函数平方的积分，然后将结果相加。为此，我们使用三角形上重心坐标中多项式的积分公式：\n$$ \\int_{\\hat{K}} \\lambda_1^a \\lambda_2^b \\lambda_3^c \\, d\\xi d\\eta = 2A \\frac{a! b! c!}{(a+b+c+2)!} $$\n其中 $A$ 是三角形的面积。对于我们的参考三角形 $\\hat{K}$，面积为 $A = \\frac{1}{2}$。该公式简化为：\n$$ \\int_{\\hat{K}} \\lambda_1^a \\lambda_2^b \\lambda_3^c \\, d\\xi d\\eta = \\frac{a! b! c!}{(a+b+c+2)!} $$\n\n1.  **顶点形函数($\\phi_1^{(2)}, \\phi_2^{(2)}, \\phi_3^{(2)}$)的积分**：\n    根据对称性，它们平方的积分是相同的。我们为 $\\phi_1^{(2)}$ 计算：\n    $$ (\\phi_1^{(2)})^2 = (\\lambda_1(2\\lambda_1-1))^2 = 4\\lambda_1^4 - 4\\lambda_1^3 + \\lambda_1^2 $$\n    $$ \\int_{\\hat{K}} (\\phi_1^{(2)})^2 \\, d\\xi d\\eta = \\int_{\\hat{K}} (4\\lambda_1^4 - 4\\lambda_1^3 + \\lambda_1^2) \\, d\\xi d\\eta $$\n    $$ = 4 \\int_{\\hat{K}} \\lambda_1^4 \\,d\\xi d\\eta - 4 \\int_{\\hat{K}} \\lambda_1^3 \\,d\\xi d\\eta + \\int_{\\hat{K}} \\lambda_1^2 \\,d\\xi d\\eta $$\n    使用该公式：\n    - $\\int_{\\hat{K}} \\lambda_1^4 = \\frac{4!0!0!}{(4+0+0+2)!} = \\frac{24}{720} = \\frac{1}{30}$\n    - $\\int_{\\hat{K}} \\lambda_1^3 = \\frac{3!0!0!}{(3+0+0+2)!} = \\frac{6}{120} = \\frac{1}{20}$\n    - $\\int_{\\hat{K}} \\lambda_1^2 = \\frac{2!0!0!}{(2+0+0+2)!} = \\frac{2}{24} = \\frac{1}{12}$\n    积分值为 $4(\\frac{1}{30}) - 4(\\frac{1}{20}) + \\frac{1}{12} = \\frac{2}{15} - \\frac{1}{5} + \\frac{1}{12} = \\frac{8-12+5}{60} = \\frac{1}{60}$。\n    三个顶点形函数的和为 $3 \\times \\frac{1}{60} = \\frac{3}{60} = \\frac{1}{20}$。\n\n2.  **中点形函数($\\phi_4^{(2)}, \\phi_5^{(2)}, \\phi_6^{(2)}$)的积分**：\n    根据对称性，这些积分也是相同的。我们为 $\\phi_4^{(2)}$ 计算：\n    $$ (\\phi_4^{(2)})^2 = (4\\lambda_1\\lambda_2)^2 = 16\\lambda_1^2\\lambda_2^2 $$\n    $$ \\int_{\\hat{K}} (\\phi_4^{(2)})^2 \\, d\\xi d\\eta = 16 \\int_{\\hat{K}} \\lambda_1^2\\lambda_2^2 \\, d\\xi d\\eta $$\n    使用公式，其中 $a=2, b=2, c=0$：\n    $$ \\int_{\\hat{K}} \\lambda_1^2\\lambda_2^2 = \\frac{2!2!0!}{(2+2+0+2)!} = \\frac{4}{6!} = \\frac{4}{720} = \\frac{1}{180} $$\n    积分值为 $16 \\times \\frac{1}{180} = \\frac{4}{45}$。\n    三个中点形函数的和为 $3 \\times \\frac{4}{45} = \\frac{12}{45} = \\frac{4}{15}$。\n\n3.  **总积分 $J_2$**：\n    将所有六个形函数的贡献相加：\n    $$ J_2 = \\sum_{i=1}^{6} \\int_{\\hat{K}} (\\phi_i^{(2)})^2 d\\xi d\\eta = \\frac{1}{20} + \\frac{4}{15} $$\n    为对这些分数求和，我们找到一个公分母，即60：\n    $$ J_2 = \\frac{3}{60} + \\frac{16}{60} = \\frac{19}{60} $$\n积分 $J_2$ 的精确值是 $\\frac{19}{60}$。", "answer": "$$\n\\boxed{\\frac{19}{60}}\n$$", "id": "3595599"}, {"introduction": "掌握了形函数的构建之后，下一步是利用它们将泊松方程的连续弱形式转化为离散的线性方程组 $A\\mathbf{u} = \\mathbf{b}$。本练习提供了一个在简单网格上“手动”组装刚度矩阵和载荷向量的实践机会，让您亲身体验如何将每个单元的贡献（单元刚度矩阵和载荷向量）累加到全局系统中。通过处理一个具有地球物理学意义的各向异性介质问题，您将深刻理解有限元方法的核心组装机制。[@problem_id:3595596]", "problem": "考虑一个二维、均匀但各向异性的稳态扩散模型，该模型代表了地下流的一个横截面。设其控制方程为带有线性本构关系的守恒定律：质量守恒要求通量的散度等于源项，而通量通过一个各向异性的传导率张量与势的梯度成正比。这导出了强形式的扩散方程\n$$\n- \\nabla \\cdot \\left( \\mathbf{K} \\, \\nabla u \\right) = f \\quad \\text{in } \\Omega,\n$$\n该方程定义在域 $\\Omega = [0,1] \\times [0,1]$ 上，边界条件为\n$$\nu = 0 \\quad \\text{on } \\Gamma_{\\mathrm{D}} := \\{ (x,y) \\in \\partial \\Omega : x = 0 \\text{ or } y = 0 \\}, \\qquad \\left( \\mathbf{K} \\nabla u \\right) \\cdot \\mathbf{n} = 0 \\quad \\text{on } \\Gamma_{\\mathrm{N}} := \\partial \\Omega \\setminus \\Gamma_{\\mathrm{D}}.\n$$\n假设源项为常数 $f(x,y) = 1$，传导率张量为一个对称正定的常数张量\n$$\n\\mathbf{K} = \\begin{pmatrix} 2  1 \\\\ 1  3 \\end{pmatrix}.\n$$\n所有量都已无量纲化；将 $u$ 报告为纯数。\n\n使用一阶连续 Lagrange 有限元（通常记为 $P_1$ 元）在单纯形网格上对 $\\Omega$ 进行离散化，该网格通过沿从 $(0,0)$ 到 $(1,1)$ 的对角线将单位正方形划分为两个三角形而形成。网格顶点标记如下：节点 $1$ 在 $(0,0)$，节点 $2$ 在 $(1,0)$，节点 $3$ 在 $(0,1)$，节点 $4$ 在 $(1,1)$。设三角形 $T_1$ 的顶点为 $(1,2,4)$，三角形 $T_2$ 的顶点为 $(1,4,3)$，两者均按逆时针顺序排列。\n\n从控制守恒定律和本构关系出发，推导弱形式，然后在此网格上构建协调的 $P_1$ 有限元离散化。手动组装：\n- $T_1$ 和 $T_2$ 上的单元刚度矩阵和单元载荷向量，\n- 施加本质边界条件之前的全局刚度矩阵和全局载荷向量。\n\n然后通过消元法施加 $\\Gamma_{\\mathrm{D}}$ 上的本质边界条件。求解所得的线性系统，以获得节点 $4$ 处唯一剩余的自由度。在节点 $4$ 处，有限元近似解 $u$ 的值是多少？提供精确值（不要四舍五入）且不带单位。", "solution": "首先根据指定标准对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **控制方程：** $- \\nabla \\cdot \\left( \\mathbf{K} \\, \\nabla u \\right) = f$\n- **域：** $\\Omega = [0,1] \\times [0,1]$\n- **传导率张量：** $\\mathbf{K} = \\begin{pmatrix} 2  1 \\\\ 1  3 \\end{pmatrix}$\n- **源项：** $f(x,y) = 1$\n- **边界条件：**\n  - Dirichlet: $u = 0$ on $\\Gamma_{\\mathrm{D}} := \\{ (x,y) \\in \\partial \\Omega : x = 0 \\text{ or } y = 0 \\}$\n  - Neumann: $\\left( \\mathbf{K} \\nabla u \\right) \\cdot \\mathbf{n} = 0$ on $\\Gamma_{\\mathrm{N}} := \\partial \\Omega \\setminus \\Gamma_{\\mathrm{D}}$\n- **离散化：** 在单纯形网格上使用一阶连续 Lagrange 有限元 ($P_1$ 元)。\n- **网格顶点（节点）：**\n  - 节点 1：$(0,0)$\n  - 节点 2：$(1,0)$\n  - 节点 3：$(0,1)$\n  - 节点 4：$(1,1)$\n- **网格单元（三角形）：**\n  - $T_1$: 顶点 $(1, 2, 4)$，对应坐标 $((0,0), (1,0), (1,1))$\n  - $T_2$: 顶点 $(1, 4, 3)$，对应坐标 $((0,0), (1,1), (0,1))$\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题描述了一个各向异性介质中的稳态扩散过程，由一个二阶椭圆偏微分方程控制。这是许多 STEM 领域（包括物理学（热传导）、工程学（地下流）和计算地球物理学）中的一个基本且成熟的模型。传导率张量 $\\mathbf{K}$ 是对称正定的（$\\det(\\mathbf{K}) = 2 \\cdot 3 - 1 \\cdot 1 = 5 > 0$；主子式为 $2>0, 5>0$），这确保了扩散问题的物理和数学适定性。\n- **适定性：** 该问题是泊松型方程的标准边值问题。在分割的边界上使用混合的 Dirichlet 和齐次 Neumann 边界条件，确保了解的存在性和唯一性（根据 Lax-Milgram 定理）。\n- **客观性：** 问题使用了精确的数学语言和客观数据进行规定。没有主观或含糊的陈述。注意到一个小的不精确之处：$T_2$ 的顶点列为 $(1,4,3)$ 并被描述为“逆时针排序”，但相应的坐标 $((0,0), (1,1), (0,1))$ 描绘的是一条顺时针路径。这种描述上的不一致并不会使问题无效，因为几何形状已由坐标明确定义。计算可以根据给定的坐标一致地进行。\n\n### 步骤 3：结论与行动\n问题是有效的。它具有科学合理性、适定性、客观性，并提供了进行求解所需的所有必要信息。\n\n### 弱形式的推导\n控制方程的强形式为：\n$$ - \\nabla \\cdot (\\mathbf{K} \\nabla u) = f \\quad \\text{in } \\Omega $$\n我们用一个来自合适空间的测试函数 $v$ 乘以方程，并在域 $\\Omega$ 上积分：\n$$ - \\int_{\\Omega} v (\\nabla \\cdot (\\mathbf{K} \\nabla u)) \\, d\\Omega = \\int_{\\Omega} v f \\, d\\Omega $$\n使用散度定理（或格林第一恒等式），我们进行分部积分：\n$$ \\int_{\\Omega} (\\nabla v)^T (\\mathbf{K} \\nabla u) \\, d\\Omega - \\int_{\\partial \\Omega} v (\\mathbf{K} \\nabla u) \\cdot \\mathbf{n} \\, d\\Gamma = \\int_{\\Omega} v f \\, d\\Omega $$\n边界 $\\partial \\Omega$ 被划分为 $\\Gamma_D$ 和 $\\Gamma_N$。测试函数 $v$ 必须属于满足齐次 Dirichlet 条件的有限能量函数空间，即在 $\\Gamma_D$ 上 $v=0$。这使得在 $\\Gamma_D$ 上的边界积分为零。由于指定的齐次 Neumann 条件 $(\\mathbf{K} \\nabla u) \\cdot \\mathbf{n} = 0$ 在 $\\Gamma_N$ 上成立，在 $\\Gamma_N$ 上的边界积分也为零。\n得到的弱形式为：寻找 $u \\in H^1(\\Omega)$ 且在 $\\Gamma_D$ 上 $u=0$，使得对于所有测试函数 $v \\in H^1_0(\\Omega, \\Gamma_D)$：\n$$ \\int_{\\Omega} (\\nabla v)^T \\mathbf{K} \\nabla u \\, d\\Omega = \\int_{\\Omega} v f \\, d\\Omega $$\n这可以写成 $a(u,v) = L(v)$，其中 $a(u,v) = \\int_{\\Omega} (\\nabla v)^T \\mathbf{K} \\nabla u \\, d\\Omega$ 是一个双线性形式，而 $L(v) = \\int_{\\Omega} v f \\, d\\Omega$ 是一个线性泛函。\n\n### 有限元离散化\n域 $\\Omega$ 被离散化为有限元。在每个单元 $T_e$ 内，解被近似为节点基函数 $N_i$ 的线性组合：$u_h(x,y) = \\sum_{j} U_j N_j(x,y)$。应用 Galerkin 方法，我们使用基函数 $N_i$ 作为测试函数。这导出了线性系统 $\\mathbf{S} \\mathbf{U} = \\mathbf{F}$，其中全局刚度矩阵 $\\mathbf{S}$ 和全局载荷向量 $\\mathbf{F}$ 的项为：\n$$ S_{ij} = a(N_j, N_i) = \\int_{\\Omega} (\\nabla N_i)^T \\mathbf{K} \\nabla N_j \\, d\\Omega, \\quad F_i = L(N_i) = \\int_{\\Omega} N_i f \\, d\\Omega $$\n这些是由单元贡献组装而成的：$\\mathbf{s}^{(e)}_{ij} = \\int_{T_e} (\\nabla N_i)^T \\mathbf{K} \\nabla N_j \\, dA$ 和 $\\mathbf{f}^{(e)}_{i} = \\int_{T_e} N_i f \\, dA$。\n\n对于一个 $P_1$ 三角形单元，重心基函数的梯度是常数。单元刚度矩阵由 $\\mathbf{s}^{(e)} = A_e (\\mathbf{B}^{(e)})^T \\mathbf{K} \\mathbf{B}^{(e)}$ 给出，其中 $A_e$ 是单元面积，$\\mathbf{B}^{(e)}$ 是其列为局部基函数梯度的矩阵。对于常数源项 $f$，单元中每个节点 $i$ 的单元载荷向量为 $\\mathbf{f}^{(e)}_i = f \\frac{A_e}{3}$。\n\n### 单元矩阵计算\n**三角形 $T_1$：** 顶点 (1, 2, 4) 位于 $(0,0)$, $(1,0)$, $(1,1)$。\n面积 $A_1 = \\frac{1}{2}$。对应于全局节点 $(1,2,4)$ 的局部节点 $(1,2,3)$ 的梯度矩阵为：\n$$ \\mathbf{B}^{(1)} = \\begin{pmatrix} -1  1  0 \\\\ 0  -1  1 \\end{pmatrix} $$\n节点 $(1,2,4)$ 的单元刚度矩阵 $\\mathbf{s}^{(1)}$ 为：\n$$ \\mathbf{s}^{(1)} = A_1 (\\mathbf{B}^{(1)})^T \\mathbf{K} \\mathbf{B}^{(1)} = \\frac{1}{2} \\begin{pmatrix} -1  0 \\\\ 1  -1 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 2  1 \\\\ 1  3 \\end{pmatrix} \\begin{pmatrix} -1  1  0 \\\\ 0  -1  1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 2  -1  -1 \\\\ -1  3  -2 \\\\ -1  -2  3 \\end{pmatrix} $$\n单元载荷向量 $\\mathbf{f}^{(1)}$ 为：\n$$ \\mathbf{f}^{(1)} = f \\frac{A_1}{3} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = 1 \\cdot \\frac{1/2}{3} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\frac{1}{6} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} $$\n\n**三角形 $T_2$：** 顶点 (1, 4, 3) 位于 $(0,0)$, $(1,1)$, $(0,1)$。\n面积 $A_2 = \\frac{1}{2}$。对应于全局节点 $(1,4,3)$ 的局部节点 $(1,2,3)$ 的梯度矩阵为：\n$$ \\mathbf{B}^{(2)} = \\begin{pmatrix} 0  1  -1 \\\\ -1  0  1 \\end{pmatrix} $$\n节点 $(1,4,3)$ 的单元刚度矩阵 $\\mathbf{s}^{(2)}$ 为：\n$$ \\mathbf{s}^{(2)} = A_2 (\\mathbf{B}^{(2)})^T \\mathbf{K} \\mathbf{B}^{(2)} = \\frac{1}{2} \\begin{pmatrix} 0  -1 \\\\ 1  0 \\\\ -1  1 \\end{pmatrix} \\begin{pmatrix} 2  1 \\\\ 1  3 \\end{pmatrix} \\begin{pmatrix} 0  1  -1 \\\\ -1  0  1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 3  -1  -2 \\\\ -1  2  -1 \\\\ -2  -1  3 \\end{pmatrix} $$\n单元载荷向量 $\\mathbf{f}^{(2)}$ 为：\n$$ \\mathbf{f}^{(2)} = f \\frac{A_2}{3} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = 1 \\cdot \\frac{1/2}{3} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\frac{1}{6} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} $$\n\n### 全局系统的组装与求解\n全局矩阵 $\\mathbf{S}$ 和 $\\mathbf{F}$ 是通过对单元贡献求和来组装的。\n全局刚度矩阵为：\n$$ \\mathbf{S} = \\frac{1}{2} \\begin{pmatrix}\ns^{(1)}_{11}+s^{(2)}_{11}  s^{(1)}_{12}  s^{(2)}_{13}  s^{(1)}_{13}+s^{(2)}_{12} \\\\\ns^{(1)}_{21}  s^{(1)}_{22}  0  s^{(1)}_{23} \\\\\ns^{(2)}_{31}  0  s^{(2)}_{33}  s^{(2)}_{32} \\\\\ns^{(1)}_{31}+s^{(2)}_{21}  s^{(1)}_{32}  s^{(2)}_{23}  s^{(1)}_{33}+s^{(2)}_{22}\n\\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix}\n2+3  -1  -2  -1-1 \\\\\n-1  3  0  -2 \\\\\n-2  0  3  -1 \\\\\n-1-1  -2  -1  3+2\n\\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix}\n5  -1  -2  -2 \\\\\n-1  3  0  -2 \\\\\n-2  0  3  -1 \\\\\n-2  -2  -1  5\n\\end{pmatrix} $$\n全局载荷向量为：\n$$ \\mathbf{F} = \\begin{pmatrix} f^{(1)}_1+f^{(2)}_1 \\\\ f^{(1)}_2 \\\\ f^{(2)}_3 \\\\ f^{(1)}_3+f^{(2)}_2 \\end{pmatrix} = \\begin{pmatrix} 1/6+1/6 \\\\ 1/6 \\\\ 1/6 \\\\ 1/6+1/6 \\end{pmatrix} = \\begin{pmatrix} 1/3 \\\\ 1/6 \\\\ 1/6 \\\\ 1/3 \\end{pmatrix} $$\n完整的系统是 $\\mathbf{S} \\mathbf{U} = \\mathbf{F}$。\n在 $\\Gamma_D$ 上的 Dirichlet 边界条件 $u=0$ 应用于节点 $1$、$2$ 和 $3$。因此，我们有 $U_1=0$、$U_2=0$ 和 $U_3=0$。\n我们只需要求解未知的自由度 $U_4$。我们使用线性系统的第四个方程：\n$$ S_{41}U_1 + S_{42}U_2 + S_{43}U_3 + S_{44}U_4 = F_4 $$\n代入已知值和矩阵项：\n$$ \\frac{1}{2}(-2)U_1 + \\frac{1}{2}(-2)U_2 + \\frac{1}{2}(-1)U_3 + \\frac{1}{2}(5)U_4 = \\frac{1}{3} $$\n$$ \\frac{1}{2}(-2(0) - 2(0) - 1(0) + 5 U_4) = \\frac{1}{3} $$\n$$ \\frac{5}{2}U_4 = \\frac{1}{3} $$\n求解 $U_4$：\n$$ U_4 = \\frac{1}{3} \\cdot \\frac{2}{5} = \\frac{2}{15} $$\n在节点 $4$ 处有限元近似解 $u$ 的值是 $U_4$。", "answer": "$$\\boxed{\\frac{2}{15}}$$", "id": "3595596"}, {"introduction": "计算建模的一个关键环节是理解和控制数值误差。本编程练习旨在通过与精确解的比较，来检验有限元解的收敛性，即误差如何随着网格的加密而减小。通过对比一个包含奇异性（点源）问题的均匀网格加密和局部网格加密策略，本练习将直观地揭示自适应网格划分在高效提升计算精度方面的强大能力，这是在实际地球物理模拟中获得可靠结果的关键技术。[@problem_id:3595604]", "problem": "考虑开区间 $\\Omega = (0,1)$ 上的带有点集中源的一维泊松方程，\n$$\n- \\frac{d^2 u}{dx^2} = f \\quad \\text{in } \\Omega,\n$$\n该方程服从齐次狄利克雷边界条件 $u(0) = 0$ 和 $u(1) = 0$。设源项为位于点 $x_0 \\in (0,1)$ 的单位狄拉克分布，即\n$$\nf = \\delta_{x_0}.\n$$\n其弱形式为：求 $u \\in H^1_0(\\Omega)$，使得对于所有检验函数 $v \\in H^1_0(\\Omega)$，满足\n$$\n\\int_0^1 u'(x) v'(x)\\,dx = v(x_0)\n$$\n您将使用有限元法（FEM），在 $\\Omega$ 的一个剖分（网格）上，采用标准的一阶拉格朗日基函数（通常称为 $P_1$ 元）来近似求解此问题。\n\n目标是计算当网格加密时，有限元解在 $H^1$ 半范数和 $L^2$ 范数下的经验误差衰减率，并比较以下两种策略：\n- 一致加密策略（所有单元大小相等），以及\n- 局部加密策略，在点源 $x_0$ 附近放置更多且更小的单元。\n\n您的程序必须：\n1. 从弱形式中推导出点源对应的正确离散载荷向量。具体来说，对于节点基函数 $\\{\\phi_i\\}$，载荷向量的各项必须满足\n$$\nF_i = \\phi_i(x_0).\n$$\n2. 为 $P_1$ 元组装全局刚度矩阵。对于长度为 $h_e$ 的单元，局部刚度矩阵为\n$$\n\\begin{pmatrix}\n1  -1 \\\\\n-1  1\n\\end{pmatrix} \\frac{1}{h_e}.\n$$\n3. 通过仅求解内部自由度来施加齐次狄利克雷边界条件。\n4. 使用精确连续解进行验证。对于 $(0,1)$ 上带有齐次狄利克雷边界条件和位于 $x_0$ 的单位狄拉克源的算子 $-d^2/dx^2$，其唯一的弱解是格林函数\n$$\nG(x;x_0) =\n\\begin{cases}\n(1 - x_0)\\, x,  \\text{if } x \\le x_0,\\\\\nx_0\\, (1 - x),  \\text{if } x \\ge x_0,\n\\end{cases}\n$$\n且 $u(x) = G(x;x_0)$。在 $x_0$ 的两侧，$u'(x)$ 是常数：当 $x < x_0$ 时，$u'(x) = (1 - x_0)$；当 $x > x_0$ 时，$u'(x) = -x_0$。\n5. 对每个网格，计算有限元解 $u_h$ 相对于 $u$ 的误差：\n   - $H^1$ 半范数误差\n   $$\n   \\|u - u_h\\|_{H^1_0(\\Omega)} := \\left( \\int_0^1 |u'(x) - u_h'(x)|^2\\,dx \\right)^{1/2}.\n   $$\n   - $L^2$ 范数误差\n   $$\n   \\|u - u_h\\|_{L^2(\\Omega)} := \\left( \\int_0^1 |u(x) - u_h(x)|^2\\,dx \\right)^{1/2}.\n   $$\n   由于 $u'(x)$ 和 $u_h'(x)$ 都是分片常数，$H^1$ 半范数误差的积分可以在每个单元上精确计算。对于 $L^2$ 范数，通过分割任何包含 $x_0$ 的单元，并在每个子段上应用两点高斯求积来进行精确的单元计算（这对于分片线性差的平方，即至多二次的多项式，是精确的）。\n6. 按如下方式定义加密策略：\n   - 一致加密：在 $(0,1)$ 上使用 $N \\in \\{32, 64, 128, 256\\}$ 个等尺寸单元。\n   - 围绕 $x_0$ 的局部加密：对于每个 $N \\in \\{32, 64, 128, 256\\}$，选择一个包含 $x_0$ 的子区间 $I = [x_{\\mathrm{L}}, x_{\\mathrm{R}}]$，其中 $x_{\\mathrm{L}} = \\max(0, x_0 - w_{\\mathrm{L}})$，$x_{\\mathrm{R}} = \\min(1, x_0 + w_{\\mathrm{R}})$，$w_{\\mathrm{L}} = 0.282$，$w_{\\mathrm{R}} = 0.318$。将总单元数的一部分（比例为 $p = 0.6$）均匀分配到 $I$ 中，其余单元按其长度比例均匀分布到 $(0, x_{\\mathrm{L}})$ 和 $(x_{\\mathrm{R}}, 1)$。\n7. 对于每种加密策略和每个 $N$，进行组装、求解并计算 $H^1$ 和 $L^2$ 误差。然后通过对 $\\log(\\text{error})$ 与 $\\log(N)$ 进行线性回归来计算经验衰减率，报告由下式定义的斜率大小 $\\alpha$\n$$\n\\log(\\text{error}) \\approx C - \\alpha \\log(N),\n$$\n使得 $\\alpha$ 是一个表示相对于总单元数 $N$ 的衰减率的正数。\n8. 使用以下源位置测试套件：\n   - 测试用例 1：$x_0 = 0.37$（一个普通的内部点）。\n   - 测试用例 2：$x_0 = 0.05$（靠近边界 $x=0$）。\n   - 测试用例 3：$x_0 = \\sqrt{2}/4$（一个无理数位置，以避免偶然对齐）。\n9. 最终输出格式：您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。对于每个测试用例，按以下顺序附加四个浮点数\n$$\n[\\alpha_{H^1,\\mathrm{uniform}},\\, \\alpha_{H^1,\\mathrm{local}},\\, \\alpha_{L^2,\\mathrm{uniform}},\\, \\alpha_{L^2,\\mathrm{local}}],\n$$\n并将三个测试用例的结果连接起来，形成一个包含 12 个浮点数的单一列表：\n$$\n[\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4,\\alpha_5,\\alpha_6,\\alpha_7,\\alpha_8,\\alpha_9,\\alpha_{10},\\alpha_{11},\\alpha_{12}].\n$$\n所有量均为无量纲，不适用物理单位。不使用角度。\n\n您的程序必须是一个完整、可运行的 Python $3.12$ 脚本，实现上述要求并仅打印指定的单行输出。它不得需要任何用户输入、文件或网络访问，并且只能使用 Python 标准库、NumPy $1.23.5$ 和 SciPy $1.11.4$。", "solution": "用户要求编写一个 Python 程序，使用有限元法（FEM）求解带狄拉克 delta 源的一维泊松方程。这涉及在一致加密和局部加密的网格策略下，比较数值解与精确解析解的收敛性。收敛性通过计算 $H^1$ 半范数和 $L^2$ 范数误差的衰减率来量化。\n\n### 1. 问题陈述的验证\n在尝试解决方案之前，问题经过了严格的验证过程。\n\n- **步骤 1：提取已知条件**\n    - **控制方程**：$- \\frac{d^2 u}{dx^2} = f$，在 $\\Omega = (0,1)$ 上。\n    - **边界条件**：齐次狄利克雷，$u(0)=0$ 和 $u(1)=0$。\n    - **源项**：$f = \\delta_{x_0}$，在 $x_0 \\in (0,1)$ 的单位狄拉克 delta 函数。\n    - **弱形式**：求 $u \\in H^1_0(\\Omega)$，使得对于所有 $v \\in H^1_0(\\Omega)$，有 $\\int_0^1 u'(x) v'(x)\\,dx = v(x_0)$。\n    - **有限元离散**：一阶拉格朗日（$P_1$）元。\n    - **载荷向量**：$F_i = \\phi_i(x_0)$，其中 $\\{\\phi_i\\}$ 是节点基函数。\n    - **局部刚度矩阵**：对于长度为 $h_e$ 的单元，$k_e = \\frac{1}{h_e} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。\n    - **精确解**：$u(x) = G(x;x_0)$，其中当 $x \\le x_0$ 时 $G(x;x_0) = (1-x_0)x$，当 $x \\ge x_0$ 时 $G(x;x_0) = x_0(1-x)$。\n    - **精确导数**：当 $x  x_0$ 时 $u'(x) = 1-x_0$，当 $x > x_0$ 时 $u'(x) = -x_0$。\n    - **误差范数**：$H^1$ 半范数 $\\|u - u_h\\|_{H^1_0(\\Omega)}$ 和 $L^2$ 范数 $\\|u - u_h\\|_{L^2(\\Omega)}$。\n    - **误差积分**：\n        - $H^1$ 误差：精确的逐单元积分，分割包含 $x_0$ 的单元。\n        - $L^2$ 误差：在通过在 $x_0$ 处分割单元产生的子段上使用两点高斯求积。\n    - **网格加密**：\n        - 一致：$N \\in \\{32, 64, 128, 256\\}$ 个等大单元。\n        - 局部：对于每个 $N$，将比例为 $p=0.6$ 的单元集中在区间 $I = [x_0 - w_{\\mathrm{L}}, x_0 + w_{\\mathrm{R}}]$（裁剪至 $[0,1]$ 内），其中 $w_{\\mathrm{L}}=0.282$ 和 $w_{\\mathrm{R}}=0.318$。剩余单元均匀分布在 $I$ 之外。\n    - **速率计算**：对 $\\log(\\text{error})$ vs. $\\log(N)$ 进行线性回归，以找到斜率大小 $\\alpha$。\n    - **测试用例**：$x_0 \\in \\{0.37, 0.05, \\sqrt{2}/4\\}$。\n    - **输出格式**：一个包含 12 个浮点数的单一列表：$[\\alpha_{H^1,\\mathrm{uniform}}, \\alpha_{H^1,\\mathrm{local}}, \\alpha_{L^2,\\mathrm{uniform}}, \\alpha_{L^2,\\mathrm{local}}]$，针对每个测试用例进行拼接。\n\n- **步骤 2：使用提取的已知条件进行验证**\n    - **科学依据**：该问题是偏微分方程数值分析（特别是有限元法）中的一个典型示例。泊松方程、弱形式、使用 $P_1$ 元以及作为精确解的格林函数，都是标准且基础合理的。\n    - **适定性**：问题是适定的。算子是椭圆的，齐次狄利克雷边界条件确保了在 $H^1_0(\\Omega)$ 中存在唯一解。计算任务定义清晰。\n    - **客观性**：所有参数、过程和定义都经过数学上的精确规定，没有主观解释的余地。\n    - **无缺陷**：该问题没有违反任何无效性标准。它是自洽的、科学正确的，并且在计算上是可行的。所有必要信息都已提供。\n\n- **步骤 3：结论与行动**\n    该问题是**有效的**。现在将开发一个完整的解决方案。\n\n### 2. 方法与实现\n\n该解决方案按照概述的步骤实现。算法的关键组成部分包括：\n\n1.  **网格生成**：创建一个函数 `_generate_mesh`，为给定的单元数 $N$、源位置 $x_0$ 和策略（`'uniform'` 或 `'local'`）生成节点坐标数组。局部加密策略将 $N$ 个单元小心地划分到三个子域：一个围绕 $x_0$ 的加密中心区域和两侧两个较粗的区域。\n\n2.  **有限元求解器**：`_solve_fem` 函数实现了核心的有限元程序。\n    - 它为内部自由度组装全局刚度矩阵 $K$ 和载荷向量 $F$。由于问题的一维性质和使用最近邻 $P_1$ 基函数，刚度矩阵是三对角的。\n    - 载荷向量 $F$ 基于原理 $F_i = v_i(x_0)$ 进行组装。对于 $P_1$ 节点基函数 $\\phi_i$，这简化为 $F_i = \\phi_i(x_0)$。只有其支撑集包含 $x_0$ 的两个基函数会产生非零项。\n    - 使用 `numpy.linalg.solve` 求解得到的线性系统 $K U_{\\text{interior}} = F$，以获得内部节点值 $U_{\\text{interior}}$。\n    - 通过将 $U_{\\text{interior}}$ 与边界处的零值（根据狄利克雷条件的要求）进行扩充，构造完整的解向量 $U_h$。\n\n3.  **误差计算**：`_compute_errors` 函数计算数值误差。\n    - 它遍历网格的每个单元。\n    - **$H^1$ 半范数误差**通过在每个单元上积分导数差的平方 $(u' - u_h')^2$ 来计算。由于 $u'$ 和 $u_h'$ 都是分片常数，这个积分是精确的。如果一个单元包含奇异点 $x_0$，积分在 $x_0$ 处被分成两部分。\n    - **$L^2$ 范数误差**通过积分 $(u - u_h)^2$ 来计算。在每个单元上，$u_h$ 是线性的。精确解 $u$ 是分片线性的。因此，被积函数是分片二次的。按照规定，使用两点高斯求积精确计算积分。如果一个单元包含 $x_0$，它被分成两个子区间，并对每个子区间应用求积法。\n\n4.  **收敛率计算**：`_compute_rate` 函数接收为网格序列 $N \\in \\{32, 64, 128, 256\\}$ 计算的误差列表，并计算收敛率 $\\alpha$。这是通过对对数-对数数据进行线性最小二乘拟合来完成的：$\\log(\\text{error})$ 与 $\\log(N)$。速率 $\\alpha$ 是这条线的斜率的相反数。\n\n5.  **主执行循环**：主函数遍历为 $x_0$ 指定的测试用例。对于每个 $x_0$，它对一致和局部加密策略在 $N$ 的范围内运行模拟，收集误差，计算四个所需的收敛率（$\\alpha_{H^1,\\text{uniform}}$、$\\alpha_{H^1,\\text{local}}$、$\\alpha_{L^2,\\text{uniform}}$、$\\alpha_{L^2,\\text{local}}$），并将它们附加到一个结果列表中。最后，程序以指定的格式打印连接后的列表。\n\n对于该问题（带有奇异源），在一致网格上的预期理论收敛率是 $\\alpha_{H^1} \\approx 0.5$ 和 $\\alpha_{L^2} \\approx 1.5$。通过适当的局部加密，应能恢复最优收敛率 $\\alpha_{H^1} \\approx 1.0$ 和 $\\alpha_{L^2} \\approx 2.0$（对于光滑问题）。计算结果将与这些理论预期进行基准比较。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the FEM simulation and compute convergence rates.\n    \"\"\"\n    \n    # Constants and parameters from the problem statement\n    W_L = 0.282\n    W_R = 0.318\n    P_REFINE = 0.6\n    Ns = np.array([32, 64, 128, 256], dtype=int)\n    TEST_CASES = [\n        0.37,\n        0.05,\n        np.sqrt(2.0)/4.0,\n    ]\n\n    # --- Helper Functions ---\n\n    def u_exact(x, x0):\n        \"\"\"Computes the exact solution u(x) for a given x0.\"\"\"\n        return np.where(x = x0, (1.0 - x0) * x, x0 * (1.0 - x))\n\n    def du_exact(x, x0):\n        \"\"\"Computes the exact derivative u'(x) for a given x0.\"\"\"\n        return np.where(x  x0, 1.0 - x0, -x0)\n\n    def generate_mesh(N, x0, strategy):\n        \"\"\"Generates the mesh nodes for uniform or local refinement.\"\"\"\n        if strategy == 'uniform':\n            return np.linspace(0.0, 1.0, N + 1)\n        \n        elif strategy == 'local':\n            x_L = max(0.0, x0 - W_L)\n            x_R = min(1.0, x0 + W_R)\n\n            N_refine = int(np.round(P_REFINE * N))\n            N_coarse = N - N_refine\n\n            len_left = x_L\n            len_right = 1.0 - x_R\n            total_coarse_len = len_left + len_right\n            \n            if total_coarse_len  1e-12:\n                N_left = int(np.round(N_coarse * len_left / total_coarse_len))\n            else:\n                N_left = 0\n            N_right = N_coarse - N_left\n            \n            # Ensure total number of elements is exactly N due to rounding\n            current_sum = N_left + N_refine + N_right\n            if current_sum != N:\n                N_right += (N - current_sum)\n\n            nodes_list = []\n            if N_left  0:\n                nodes_list.append(np.linspace(0.0, x_L, N_left, endpoint=False))\n            if N_refine  0:\n                nodes_list.append(np.linspace(x_L, x_R, N_refine, endpoint=False))\n            if N_right  0:\n                nodes_list.append(np.linspace(x_R, 1.0, N_right, endpoint=False))\n            \n            nodes = np.concatenate(nodes_list) if nodes_list else np.array([])\n            nodes = np.append(nodes, 1.0)\n            \n            return nodes\n\n    def solve_fem(nodes, x0):\n        \"\"\"Assembles and solves the FEM system for P1 elements.\"\"\"\n        N_elements = len(nodes) - 1\n        N_nodes = N_elements + 1\n        N_interior = N_nodes - 2\n\n        if N_interior = 0:\n            return np.zeros(N_nodes)\n\n        K = np.zeros((N_interior, N_interior))\n        F = np.zeros(N_interior)\n\n        # Assemble stiffness matrix K (tridiagonal) for interior nodes\n        for i in range(N_interior): # Diagonals based on node i+1\n            glob_idx = i + 1\n            h_left = nodes[glob_idx] - nodes[glob_idx - 1]\n            h_right = nodes[glob_idx + 1] - nodes[glob_idx]\n            K[i, i] = 1.0/h_left + 1.0/h_right\n        for i in range(N_interior - 1): # Off-diagonals\n            glob_idx = i + 1\n            h_right = nodes[glob_idx + 1] - nodes[glob_idx]\n            K[i, i+1] = -1.0/h_right\n            K[i+1, i] = -1.0/h_right\n\n        # Assemble load vector F\n        elem_idx = np.searchsorted(nodes, x0, side='right') - 1\n        elem_idx = min(elem_idx, N_elements - 1)\n        \n        x_j, x_j1 = nodes[elem_idx], nodes[elem_idx+1]\n        h_j = x_j1 - x_j\n        \n        val_phi_j = (x_j1 - x0) / h_j if h_j  1e-14 else (1.0 if np.isclose(x0, x_j) else 0.0)\n        val_phi_j1 = (x0 - x_j) / h_j if h_j  1e-14 else (1.0 if np.isclose(x0, x_j1) else 0.0)\n\n        if elem_idx  0:\n            F[elem_idx - 1] += val_phi_j\n        if elem_idx + 1  N_nodes - 1:\n            F[elem_idx] += val_phi_j1\n\n        U_interior = np.linalg.solve(K, F)\n        U_h = np.zeros(N_nodes)\n        U_h[1:-1] = U_interior\n        return U_h\n\n    def compute_errors(nodes, U_h, x0):\n        \"\"\"Computes H1-seminorm and L2-norm errors.\"\"\"\n        N_elements = len(nodes) - 1\n        h1_err_sq, l2_err_sq = 0.0, 0.0\n\n        gauss_pts = np.array([-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)])\n        gauss_w = np.array([1.0, 1.0])\n\n        for i in range(N_elements):\n            x_i, x_i1 = nodes[i], nodes[i+1]\n            h_e = x_i1 - x_i\n            if h_e  1e-14: continue\n\n            # H1 seminorm error\n            du_h = (U_h[i+1] - U_h[i]) / h_e\n            if x0 = x_i or x0 = x_i1:\n                du_val = du_exact((x_i + x_i1) / 2.0, x0)\n                h1_err_sq += (du_val - du_h)**2 * h_e\n            else:\n                h1_err_sq += (du_exact(x_i, x0) - du_h)**2 * (x0 - x_i)\n                h1_err_sq += (du_exact(x_i1, x0) - du_h)**2 * (x_i1 - x0)\n            \n            # L2 norm error\n            def u_h_local(x): return U_h[i] * (x_i1 - x) / h_e + U_h[i+1] * (x - x_i) / h_e\n            def integrand_sq(x): return (u_exact(x, x0) - u_h_local(x))**2\n\n            def quad_gauss2(func, a, b):\n                h_sub = b - a\n                if h_sub  1e-14: return 0.0\n                pts = 0.5 * h_sub * gauss_pts + 0.5 * (a + b)\n                return 0.5 * h_sub * np.sum(gauss_w * func(pts))\n\n            if x0 = x_i or x0 = x_i1:\n                l2_err_sq += quad_gauss2(integrand_sq, x_i, x_i1)\n            else:\n                l2_err_sq += quad_gauss2(integrand_sq, x_i, x0)\n                l2_err_sq += quad_gauss2(integrand_sq, x0, x_i1)\n            \n        return np.sqrt(h1_err_sq), np.sqrt(l2_err_sq)\n    \n    def compute_rate(errors):\n        \"\"\"Computes convergence rate alpha from log(error) vs log(N).\"\"\"\n        if any(e  1e-16 for e in errors): return np.nan\n        log_N = np.log(Ns)\n        log_err = np.log(errors)\n        slope, _ = np.polyfit(log_N, log_err, 1)\n        return -slope\n\n    # --- Main Calculation Loop ---\n    all_results = []\n    for x0 in TEST_CASES:\n        \n        errors_h1_uni, errors_l2_uni = [], []\n        errors_h1_loc, errors_l2_loc = [], []\n\n        for N in Ns:\n            # Uniform refinement\n            nodes_uni = generate_mesh(N, x0, 'uniform')\n            U_h_uni = solve_fem(nodes_uni, x0)\n            h1, l2 = compute_errors(nodes_uni, U_h_uni, x0)\n            errors_h1_uni.append(h1)\n            errors_l2_uni.append(l2)\n\n            # Local refinement\n            nodes_loc = generate_mesh(N, x0, 'local')\n            U_h_loc = solve_fem(nodes_loc, x0)\n            h1, l2 = compute_errors(nodes_loc, U_h_loc, x0)\n            errors_h1_loc.append(h1)\n            errors_l2_loc.append(l2)\n            \n        # Compute rates for the current test case\n        alpha_h1_uni = compute_rate(errors_h1_uni)\n        alpha_h1_loc = compute_rate(errors_h1_loc)\n        alpha_l2_uni = compute_rate(errors_l2_uni)\n        alpha_l2_loc = compute_rate(errors_l2_loc)\n        \n        all_results.extend([alpha_h1_uni, alpha_h1_loc, alpha_l2_uni, alpha_l2_loc])\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3595604"}]}