{"hands_on_practices": [{"introduction": "在将数值模型用于科学探索之前，我们必须严格验证其实现的正确性。人造解方法（Method of Manufactured Solutions）是验证代码的黄金标准，它通过构造一个已知的精确解来检验数值方法的收敛阶。本练习（[@problem_id:3590474]）将指导您实现一个二维显式热方程求解器，并系统地测量其收敛速率，从而验证您的代码是否达到了理论预期的精度。这是计算科学家必备的一项基本技能。", "problem": "考虑在单位正方形域 $\\,\\Omega = [0,1]\\times[0,1]\\,$ 上的二维热方程，其热扩散系数 $\\,\\kappa\\,$ 为常数，并带有一个光滑源项 $\\,s(\\mathbf{x},t)\\,$，\n$$\n\\frac{\\partial u}{\\partial t}(\\mathbf{x},t) \\;=\\; \\kappa \\,\\Delta u(\\mathbf{x},t) \\;+\\; s(\\mathbf{x},t), \\qquad \\mathbf{x}=(x,y)\\in\\Omega,\\; t\\in[0,T],\n$$\n该方程服从齐次狄利克雷边界条件 $\\,u(\\mathbf{x},t)=0\\,$（对于 $\\,\\mathbf{x}\\in\\partial\\Omega\\,$）和一个指定的初始条件 $\\,u(\\mathbf{x},0)=u_0(\\mathbf{x})\\,$。使用人工解法构造一个光滑的非平凡函数 $\\,u(\\mathbf{x},t)\\,$，并推导出相应的源项 $\\,s(\\mathbf{x},t)\\,$，使得所构造的 $\\,u(\\mathbf{x},t)\\,$ 精确满足该偏微分方程和边界条件。然后，为此问题设计并实现一个时间上采用完全显式向前欧拉、空间上采用中心差分的格式，推导并强制执行其稳定性限制，并在数值上验证观察到的时间和空间收敛率。\n\n你的人工解必须是\n$$\nu(x,y,t) \\;=\\; e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y),\n$$\n在 $\\,\\Omega\\,$ 上且对于 $\\,t\\in[0,T]\\,$。从控制方程和选定的 $\\,u(x,y,t)\\,$ 出发，计算使 $\\,u\\,$ 满足该方程所需的源项 $\\,s(x,y,t)\\,$。使用由 $\\,u\\,$ 导出的齐次狄利克雷边界值以及初始条件 $\\,u(x,y,0)\\,$。使用均匀笛卡尔网格对 $\\,\\Omega\\,$ 进行离散化，在 $\\,x\\,$ 方向上有 $\\,N_x+1\\,$ 个点，在 $\\,y\\,$ 方向上有 $\\,N_y+1\\,$ 个点（包括边界），间距分别为 $\\,\\Delta x=1/N_x\\,$ 和 $\\,\\Delta y=1/N_y\\,$。令 $\\,u_{i,j}^n\\,$ 表示在网格索引 $\\,i,j\\,$ 和时间层 $\\,t^n\\,$ 上的数值近似解。\n\n你的显式格式必须根据以下公式更新内部网格点 $\\,i=1,\\dots,N_x-1\\,$ 和 $\\,j=1,\\dots,N_y-1\\,$\n$$\nu_{i,j}^{n+1} \\;=\\; u_{i,j}^{n} \\;+\\; \\Delta t \\left\\{ \\kappa\\left(\\frac{u_{i+1,j}^{n}-2u_{i,j}^{n}+u_{i-1,j}^{n}}{\\Delta x^2} \\;+\\; \\frac{u_{i,j+1}^{n}-2u_{i,j}^{n}+u_{i,j-1}^{n}}{\\Delta y^2}\\right) \\;+\\; s(x_i,y_j,t^n) \\right\\},\n$$\n每个时间层的边界值都设为零。使用二维显式格式的 Courant-Friedrichs-Lewy (CFL) 稳定性限制，\n$$\n\\Delta t \\;\\le\\; \\frac{1}{2\\,\\kappa\\left(\\frac{1}{\\Delta x^2}+\\frac{1}{\\Delta y^2}\\right)},\n$$\n并且，当 $\\,\\Delta x=\\Delta y\\,$ 时，该条件简化为 $\\,\\Delta t \\le \\frac{\\Delta x^2}{4\\kappa}\\,$。\n\n将最终时间 $\\,T\\,$ 的离散 $\\,L^2\\,$ 误差定义为\n$$\nE \\;=\\; \\left(\\sum_{i=0}^{N_x}\\sum_{j=0}^{N_y} \\left(u_{i,j}^{N_t} - u(x_i,y_j,T)\\right)^2 \\,\\Delta x\\,\\Delta y \\right)^{1/2},\n$$\n其中 $\\,N_t\\,$ 表示最终时间索引，使得 $\\,N_t\\,\\Delta t \\approx T\\,$。使用的 $\\,\\Delta t\\,$ 需经过调整，以使时间网格恰好落在 $\\,T\\,$ 上，即 $\\,\\Delta t_{\\mathrm{eff}} = T/N_t\\,$，其中 $\\,N_t\\,$ 为整数且 $\\,\\Delta t_{\\mathrm{eff}} \\le \\Delta t\\,$。\n\n通过固定一个精细的空间网格，并为一系列通过连续减半得到的时间步长 $\\,\\Delta t_k\\,$ 计算误差 $\\,E(\\Delta t_k)\\,$，来数值估计时间收敛率 $\\,p_t\\,$。通过 $\\,\\log E\\,$ 关于 $\\,\\log \\Delta t\\,$ 的斜率来估计 $\\,p_t\\,$。类似地，通过固定一个稳定的时间步长（与 CFL 条件一致），并为一系列通过连续减半得到的空间网格步长 $\\,\\Delta x_\\ell\\,$ 计算误差 $\\,E(\\Delta x_\\ell)\\,$，来估计空间收敛率 $\\,p_x\\,$，并通过 $\\,\\log E\\,$ 关于 $\\,\\log \\Delta x\\,$ 的斜率来估计 $\\,p_x\\,$。\n\n测试套件：\n- 案例 A（时间收敛率，理想情况）：$\\,\\kappa=0.1\\,$，$\\,N_x=N_y=64\\,$，$\\,T=0.1\\,$，以及 $\\,\\Delta t\\,$ 值 $\\,\\Delta t_0=0.8\\,\\Delta t_{\\mathrm{CFL}}\\,$, $\\,\\Delta t_1=\\Delta t_0/2\\,$, $\\,\\Delta t_2=\\Delta t_1/2\\,$，其中 $\\,\\Delta t_{\\mathrm{CFL}}=\\Delta x^2/(4\\kappa)\\,$。报告测得的 $\\,p_t\\,$。\n- 案例 B（空间收敛率，理想情况）：$\\,\\kappa=0.1\\,$，$\\,T=0.1\\,$，网格的 $\\,N_x=N_y\\in\\{20,40,80\\}\\,$，并且对每个网格，取 $\\,\\Delta t=0.4\\,\\Delta t_{\\mathrm{CFL}}\\,$。报告测得的 $\\,p_x\\,$。\n- 案例 C（在稳定性边界上的时间收敛率，边界情况）：$\\,\\kappa=0.1\\,$，$\\,N_x=N_y=50\\,$，$\\,T=0.05\\,$，以及 $\\,\\Delta t\\,$ 值 $\\,\\Delta t_0=\\Delta t_{\\mathrm{CFL}}\\,$, $\\,\\Delta t_1=\\Delta t_0/2\\,$, $\\,\\Delta t_2=\\Delta t_1/2\\,$。报告测得的 $\\,p_t\\,$。\n\n你的程序必须：\n- 从人工解 $\\,u(x,y,t)\\,$ 和热方程计算 $\\,s(x,y,t)\\,$。\n- 实现带有齐次狄利克雷边界和 CFL 限制的显式格式。\n- 对每个案例，通过对相应的点对 $\\,(\\log \\Delta t_k, \\log E_k)\\,$ 或 $\\,(\\log \\Delta x_\\ell, \\log E_\\ell)\\,$ 进行线性回归来估计收敛率。\n- 生成单行输出，包含三个结果，按 $[p_t^{\\mathrm{A}},p_x^{\\mathrm{B}},p_t^{\\mathrm{C}}]$ 的顺序，以逗号分隔的列表形式并用方括号括起来，每个结果四舍五入到三位小数。由于这些量是无量纲的，因此不需要物理单位。\n\n所有给定测试案例的最终输出必须是浮点数。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3]”）。", "solution": "我们从控制二维热方程开始，其热扩散系数 $\\,\\kappa\\,$ 为常数，\n$$\n\\frac{\\partial u}{\\partial t} \\;=\\; \\kappa \\,\\Delta u \\;+\\; s,\n$$\n该方程定义在单位正方形域 $\\,\\Omega=[0,1]\\times[0,1]\\,$ 上，具有齐次狄利克雷边界条件，即 $\\,u|_{\\partial\\Omega}=0\\,$，以及一个给定的初始条件。在人工解法中，我们选择一个光滑函数 $\\,u(x,y,t)\\,$，并推导出源项 $\\,s(x,y,t)\\,$，使得所选的 $\\,u\\,$ 精确满足方程和边界条件。这使我们能够通过将数值解与精确的人工解进行比较来评估数值方法的收敛特性。\n\n我们选择\n$$\nu(x,y,t) \\;=\\; e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y).\n$$\n该函数满足齐次狄利克雷边界条件，因为 $\\,\\sin(2\\pi x)=0\\,$ 在 $\\,x=0\\,$ 和 $\\,x=1\\,$ 上成立，类似地，$\\,\\sin(2\\pi y)=0\\,$ 在 $\\,y=0\\,$ 和 $\\,y=1\\,$ 上成立，所以对于所有 $\\,t\\,$，在 $\\,\\partial\\Omega\\,$ 上 $\\,u=0\\,$。它的初始条件是 $\\,u(x,y,0)=\\sin(2\\pi x)\\sin(2\\pi y)\\,$。\n\n为了计算源项 $\\,s\\,$，我们使用时间导数和拉普拉斯算子的定义：\n$$\n\\frac{\\partial u}{\\partial t} \\;=\\; e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y) \\;=\\; u,\n$$\n和\n$$\n\\Delta u \\;=\\; \\frac{\\partial^2 u}{\\partial x^2} \\;+\\; \\frac{\\partial^2 u}{\\partial y^2}\n\\;=\\; -\\,(2\\pi)^2\\,e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y) \\;-\\; (2\\pi)^2\\,e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y)\n\\;=\\; -\\,8\\pi^2\\,u.\n$$\n代入热方程可得\n$$\nu_t \\;=\\; \\kappa\\,\\Delta u \\;+\\; s \\;\\;\\Rightarrow\\;\\; s \\;=\\; u_t \\;-\\; \\kappa\\,\\Delta u \\;=\\; u \\;-\\; \\kappa\\,(-8\\pi^2\\,u) \\;=\\; \\left(1+8\\pi^2\\kappa\\right)\\,u.\n$$\n因此，强迫项为\n$$\ns(x,y,t) \\;=\\; \\left(1+8\\pi^2\\kappa\\right)\\,e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y).\n$$\n\n我们用均匀笛卡尔网格离散化空间域：\n$$\nx_i \\;=\\; i\\,\\Delta x,\\quad i=0,\\dots,N_x,\\qquad \\Delta x \\;=\\; \\frac{1}{N_x},\n$$\n$$\ny_j \\;=\\; j\\,\\Delta y,\\quad j=0,\\dots,N_y,\\qquad \\Delta y \\;=\\; \\frac{1}{N_y}.\n$$\n令 $\\,u_{i,j}^n\\,$ 表示在时间层 $\\,t^n=n\\,\\Delta t\\,$ 对 $\\,u(x_i,y_j,t^n)\\,$ 的数值近似。对于内部点 $\\,i=1,\\dots,N_x-1\\,$ 和 $\\,j=1,\\dots,N_y-1\\,$，时间上采用显式向前欧拉、空间上采用二阶中心差分的格式是\n$$\nu_{i,j}^{n+1} \\;=\\; u_{i,j}^{n} \\;+\\; \\Delta t \\left\\{ \\kappa\\left(\\frac{u_{i+1,j}^{n}-2u_{i,j}^{n}+u_{i-1,j}^{n}}{\\Delta x^2} \\;+\\; \\frac{u_{i,j+1}^{n}-2u_{i,j}^{n}+u_{i,j-1}^{n}}{\\Delta y^2}\\right) \\;+\\; s(x_i,y_j,t^n) \\right\\},\n$$\n边界值为 $\\,u_{0,j}^n=u_{N_x,j}^n=u_{i,0}^n=u_{i,N_y}^n=0\\,$ 对所有 $\\,n\\,$ 成立。在 $\\,u\\,$ 具有适当光滑性的假设下，该格式是时间上一阶精确和空间上二阶精确的。\n\n为保证稳定性，具有常数 $\\,\\kappa\\,$ 的二维显式扩散格式的 Courant-Friedrichs-Lewy (CFL) 限制是\n$$\n\\Delta t \\;\\le\\; \\frac{1}{2\\,\\kappa\\left(\\frac{1}{\\Delta x^2}+\\frac{1}{\\Delta y^2}\\right)}.\n$$\n在 $\\,\\Delta x=\\Delta y\\,$ 的特殊情况下，该限制简化为\n$$\n\\Delta t \\;\\le\\; \\frac{\\Delta x^2}{4\\,\\kappa}.\n$$\n我们通过计算一个候选的 $\\,\\Delta t\\,$，然后用 $\\,\\Delta t_{\\mathrm{eff}}=T/N_t\\,$（其中 $\\,N_t=\\left\\lceil T/\\Delta t\\right\\rceil\\,$）进行调整来强制执行此限制，从而使时间网格恰好落在 $\\,T\\,$ 上，同时保持稳定性。\n\n为了量化最终时间 $\\,T\\,$ 的数值误差，我们使用离散 $\\,L^2\\,$ 范数，\n$$\nE \\;=\\; \\left(\\sum_{i=0}^{N_x}\\sum_{j=0}^{N_y} \\left(u_{i,j}^{N_t} - u(x_i,y_j,T)\\right)^2 \\,\\Delta x\\,\\Delta y \\right)^{1/2}.\n$$\n观察到的时间收敛率 $\\,p_t\\,$ 是通过在固定的精细网格上，为一系列通过连续减半得到的时间步长 $\\,\\Delta t_k\\,$ 计算误差 $\\,E_k=E(\\Delta t_k)\\,$，然后对 $\\,\\log E_k\\,$ 与 $\\,\\log \\Delta t_k\\,$ 进行线性回归来估计的。类似地，观察到的空间收敛率 $\\,p_x\\,$ 是通过在固定的稳定时间步长下，为一系列通过连续减半得到的网格步长 $\\,\\Delta x_\\ell\\,$ 计算误差 $\\,E_\\ell=E(\\Delta x_\\ell)\\,$，然后对 $\\,\\log E_\\ell\\,$ 与 $\\,\\log \\Delta x_\\ell\\,$ 进行线性回归来估计的。由于该格式在时间上是一阶的，在空间上是二阶的，我们预期 $\\,p_t\\approx 1\\,$ 和 $\\,p_x\\approx 2\\,$。\n\n每个测试案例的算法步骤：\n1. 设置 $\\,\\kappa\\,$、$\\,T\\,$ 和网格尺寸 $\\,N_x,N_y\\,$。\n2. 计算 $\\,\\Delta x=1/N_x\\,$ 和 $\\,\\Delta y=1/N_y\\,$；构建网格 $\\,x_i\\,$ 和 $\\,y_j\\,$ 以及人工初始条件 $\\,u(x,y,0)\\,$。\n3. 选择与CFL限制一致的候选 $\\,\\Delta t\\,$ 值。对于时间研究，使用通过减半相关的 $\\,\\Delta t\\,$ 序列。对于空间研究，根据CFL极限的固定比例调整每个网格的 $\\,\\Delta t\\,$，以保持稳定和合理的效率。\n4. 对于每个 $\\,\\Delta t\\,$，设置 $\\,N_t=\\lceil T/\\Delta t\\rceil\\,$ 并使用 $\\,\\Delta t_{\\mathrm{eff}}=T/N_t\\,$ 以精确到达 $\\,T\\,$。将显式格式推进 $\\,N_t\\,$ 步：\n   - 在每一步 $\\,n\\,$，从人工解中评估 $\\,s(x_i,y_j,t^n)\\,$，并使用显式公式更新内部点；强制边界值 $\\,u=0\\,$。\n5. 在最终时间 $\\,T\\,$，计算与精确解 $\\,u(x,y,T)\\,$ 的离散 $\\,L^2\\,$ 误差 $\\,E\\,$。\n6. 汇总误差与 $\\,\\Delta t\\,$ 或 $\\,\\Delta x\\,$ 的关系，并通过对 $\\,(\\log \\Delta t,\\log E)\\,$ 或 $\\,(\\log \\Delta x,\\log E)\\,$ 进行线性回归来估计 $\\,p_t\\,$ 或 $\\,p_x\\,$。\n7. 报告测得的速率，四舍五入到三位小数。\n\n测试套件详情：\n- 案例 A：$\\,\\kappa=0.1\\,$，$\\,N_x=N_y=64\\,$，$\\,T=0.1\\,$；时间步长序列 $\\,\\Delta t_0=0.8\\,\\Delta x^2/(4\\kappa)\\,$, $\\,\\Delta t_1=\\Delta t_0/2\\,$, $\\,\\Delta t_2=\\Delta t_1/2\\,$；估计 $\\,p_t\\,$。\n- 案例 B：$\\,\\kappa=0.1\\,$，$\\,T=0.1\\,$；网格 $\\,N_x=N_y\\in\\{20,40,80\\}\\,$；对每个网格，设置 $\\,\\Delta t=0.4\\,\\Delta x^2/(4\\kappa)\\,$；估计 $\\,p_x\\,$。\n- 案例 C：$\\,\\kappa=0.1\\,$，$\\,N_x=N_y=50\\,$，$\\,T=0.05\\,$；时间步长序列 $\\,\\Delta t_0=\\Delta x^2/(4\\kappa)\\,$, $\\,\\Delta t_1=\\Delta t_0/2\\,$, $\\,\\Delta t_2=\\Delta t_1/2\\,$；估计 $\\,p_t\\,$。\n\n最终的程序输出必须是单行，包含 $\\,\\left[p_t^{\\mathrm{A}},p_x^{\\mathrm{B}},p_t^{\\mathrm{C}}\\right]\\,$，格式为用方括号括起来的逗号分隔列表，每个数字四舍五入到三位小数。由于测得的速率是无量纲的，因此不需要物理单位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef manufactured_u(x, y, t):\n    \"\"\"Exact manufactured solution u(x,y,t) = exp(t) * sin(2πx) * sin(2πy).\"\"\"\n    return np.exp(t) * np.sin(2.0 * np.pi * x) * np.sin(2.0 * np.pi * y)\n\ndef source_s(x, y, t, kappa):\n    \"\"\"Source term s = (1 + 8π^2 κ) * u(x,y,t).\"\"\"\n    return (1.0 + 8.0 * (np.pi ** 2) * kappa) * manufactured_u(x, y, t)\n\ndef explicit_heat_2d(kappa, Nx, Ny, T, dt_candidate):\n    \"\"\"\n    Solve the forced heat equation using an explicit scheme on [0,1]x[0,1] with Dirichlet 0 BCs.\n    Uses dt_eff = T / Nt with Nt = ceil(T / dt_candidate) to land exactly at T.\n    Returns the discrete L2 error at time T with respect to the manufactured solution.\n    \"\"\"\n    Lx, Ly = 1.0, 1.0\n    dx = Lx / Nx\n    dy = Ly / Ny\n\n    # CFL time step limit for explicit scheme in 2D with dx=1/Nx, dy=1/Ny:\n    dt_cfl = 1.0 / (2.0 * kappa * (1.0 / dx**2 + 1.0 / dy**2))\n    # Ensure candidate dt is not larger than CFL limit\n    dt = min(dt_candidate, dt_cfl)\n    Nt = int(np.ceil(T / dt))\n    dt_eff = T / Nt  # adjust to land exactly at T, maintains stability since dt_eff = dt\n\n    # Grids\n    x = np.linspace(0.0, Lx, Nx + 1)\n    y = np.linspace(0.0, Ly, Ny + 1)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Initial condition from manufactured solution at t=0\n    u = manufactured_u(X, Y, 0.0)\n\n    # Enforce boundary conditions (Dirichlet zero) explicitly: they are already zero by construction,\n    # but we maintain the boundary to zero at each time step.\n    u[0, :] = 0.0\n    u[-1, :] = 0.0\n    u[:, 0] = 0.0\n    u[:, -1] = 0.0\n\n    # Time stepping\n    t = 0.0\n    inv_dx2 = 1.0 / dx**2\n    inv_dy2 = 1.0 / dy**2\n    for n in range(Nt):\n        # Source term evaluated at current time\n        s = source_s(X, Y, t, kappa)\n\n        # Compute Laplacian with centered differences on interior points\n        # Vectorized update for interior\n        u_center = u[1:-1, 1:-1]\n        lap = (u[2:, 1:-1] - 2.0 * u_center + u[:-2, 1:-1]) * inv_dx2 \\\n            + (u[1:-1, 2:] - 2.0 * u_center + u[1:-1, :-2]) * inv_dy2\n\n        # Update interior\n        u[1:-1, 1:-1] = u_center + dt_eff * (kappa * lap + s[1:-1, 1:-1])\n\n        # Enforce boundary zeros each step\n        u[0, :] = 0.0\n        u[-1, :] = 0.0\n        u[:, 0] = 0.0\n        u[:, -1] = 0.0\n\n        t += dt_eff\n\n    # Exact solution at final time\n    u_exact_T = manufactured_u(X, Y, T)\n\n    # Discrete L2 error over the whole grid\n    err = u - u_exact_T\n    E = np.sqrt(np.sum(err**2) * dx * dy)\n    return E, dx, dy, dt_eff\n\ndef estimate_rate(xs, Es):\n    \"\"\"\n    Estimate convergence rate by linear regression of log(Es) vs log(xs).\n    xs: array of step sizes (Δt or Δx)\n    Es: corresponding errors\n    Returns slope (rate)\n    \"\"\"\n    logx = np.log(xs)\n    logE = np.log(Es)\n    # Fit logE = a + p * logx; p is slope (rate)\n    p, a = np.polyfit(logx, logE, 1)\n    return p\n\ndef case_temporal_convergence(kappa, Nx, Ny, T, dt0, num_levels=3):\n    \"\"\"\n    Measure temporal convergence rate by halving dt on a fixed grid.\n    \"\"\"\n    dts = [dt0 / (2**i) for i in range(num_levels)]\n    errors = []\n    dts_eff = []\n    for dt in dts:\n        E, _, _, dt_eff_val = explicit_heat_2d(kappa, Nx, Ny, T, dt)\n        errors.append(E)\n        dts_eff.append(dt_eff_val)\n    \n    rate = estimate_rate(np.array(dts_eff), np.array(errors))\n    return rate\n\ndef case_spatial_convergence(kappa, Ns, T, dt_fraction=0.4):\n    \"\"\"\n    Measure spatial convergence rate by halving Δx with dt set as a fixed fraction of the CFL limit.\n    Ns: list of N values for Nx=Ny.\n    \"\"\"\n    dxs = []\n    errors = []\n    for N in Ns:\n        # For each N, set dt = dt_fraction * dt_cfl\n        dx = 1.0 / N\n        dy = dx\n        dt_cfl = 1.0 / (2.0 * kappa * (1.0 / dx**2 + 1.0 / dy**2))\n        dt = dt_fraction * dt_cfl\n        E, _, _, _ = explicit_heat_2d(kappa, N, N, T, dt)\n        dxs.append(dx)\n        errors.append(E)\n    rate = estimate_rate(np.array(dxs), np.array(errors))\n    return rate\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case A: Temporal convergence, happy path\n    kappa_A = 0.1\n    Nx_A = Ny_A = 64\n    T_A = 0.1\n    dx_A = 1.0 / Nx_A\n    dt_cfl_A = dx_A**2 / (4.0 * kappa_A)  # for dx=dy\n    dt0_A = 0.8 * dt_cfl_A\n    p_t_A = case_temporal_convergence(kappa_A, Nx_A, Ny_A, T_A, dt0_A, num_levels=3)\n\n    # Case B: Spatial convergence, happy path\n    kappa_B = 0.1\n    T_B = 0.1\n    Ns_B = [20, 40, 80]\n    p_x_B = case_spatial_convergence(kappa_B, Ns_B, T_B, dt_fraction=0.4)\n\n    # Case C: Temporal convergence at the stability boundary, edge case\n    kappa_C = 0.1\n    Nx_C = Ny_C = 50\n    T_C = 0.05\n    dx_C = 1.0 / Nx_C\n    dt_cfl_C = dx_C**2 / (4.0 * kappa_C)\n    dt0_C = dt_cfl_C\n    p_t_C = case_temporal_convergence(kappa_C, Nx_C, Ny_C, T_C, dt0_C, num_levels=3)\n\n    results = [p_t_A, p_x_B, p_t_C]\n\n    # Final print statement in the exact required format (rounded to three decimals).\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```", "id": "3590474"}, {"introduction": "一个优秀的数值格式不仅要收敛，还必须能反映所模拟的物理过程的基本属性。热方程的极值原理（Maximum Principle）就是一个关键物理特性，它保证了在没有热源的情况下，温度不会无故超过其初始和边界的极值。本练习（[@problem_id:3229680]）将带您深入探究这一物理原理与数值稳定性之间的深刻联系，通过实践观察违反稳定性条件如何导致非物理的振荡，从而加深对CFL条件的理解。", "problem": "考虑在空间区间 $[0,1]$ 上的一维热方程，其具有齐次 Dirichlet 边界条件和非负初始条件。其数学模型为抛物型偏微分方程\n$$\nu_t(x,t) = \\alpha\\,u_{xx}(x,t), \\quad x \\in (0,1), \\; t \\ge 0,\n$$\n边界条件为 $u(0,t)=0$ 和 $u(1,t)=0$，初始条件为 $u(x,0)=u_0(x) \\ge 0$。热方程是一个典型的扩散模型，其极值原理指出，在这些条件下且无源项的情况下，解 $u(x,t)$ 在所有未来时间都保持在初始和边界数据的最小值和最大值之间。特别地，如果 $u_0(x) \\ge 0$ 且边界为零，则对于所有 $t \\ge 0$，有 $u(x,t) \\ge 0$ 且 $\\max_x u(x,t) \\le \\max_x u_0(x)$。\n\n您的任务是使用有限差分法数值地验证这一性质，并找出一个常用格式违反离散极值原理类似形式的场景。您必须从数值近似的基本原理出发：从控制方程以及空间和时间有限差分的定义开始，推导相容的时间步进格式，并在带有零 Dirichlet 边界的离散网格上实现它们。不要使用热方程的闭式解。\n\n设置扩散系数 $\\alpha=1$。使用一个具有 $M$ 个内部点的均匀空间网格，索引为 $i=1,2,\\dots,M$，网格间距为 $h=\\frac{1}{M+1}$，网格点为 $x_i = i h$。在所有时间，于 $x=0$ 处施加边界条件 $u_0=0$，于 $x=1$ 处施加边界条件 $u_{M+1}=0$。使用一个非负且局部化的离散初始条件：在中心内部索引 $i=\\lfloor (M+1)/2 \\rfloor$ 处设置 $u_i(0) = 1$，对所有其他内部索引 $i$ 设置 $u_i(0) = 0$。这是一个单位脉冲的纯离散模拟，并且处处非负。使用由无量纲比 $r = \\alpha \\Delta t / h^2$ 通过 $\\Delta t = r\\,h^2/\\alpha$ 确定的时间步长 $\\Delta t$，对每个格式演化解，共计指定的步数 $N_t$。\n\n根据时间上的向前、向后和中心有限差分以及空间上的中心有限差分的定义，推导并实现以下几类热方程的时间步进方法：\n- 显式向前时间中心空间法（通常称为 Forward Euler 或 Forward-Time Centered-Space），通过用向前差分近似 $u_t$ 和用标准中心二阶差分近似 $u_{xx}$ 来构建。\n- 隐式向后时间中心空间法（通常称为 Backward Euler），通过用向后差分近似 $u_t$ 和用标准中心二阶差分近似 $u_{xx}$ 来构建，两者均在新时间点上计算。\n- 时间梯形法（通常称为 Crank–Nicolson），通过将中心空间法与时间上的梯形法则相结合来构建，使得空间二阶差分在旧时间和新时间层级上取平均。\n\n通过强制 $u_0^n = 0$ 和 $u_{M+1}^n=0$ 并在每个时间步只演化 $M$ 个内部未知数来实现齐次 Dirichlet 边界。对于隐式方法，建立并精确求解所得的三对角线性系统（无迭代近似）。\n\n在每个时间层级 $n = 1, 2, \\dots, N_t$ 为内部解向量 $u^n \\in \\mathbb{R}^M$ 数值地检验离散极值原理。由于边界值为零且初始条件非负并在单个内部点处有最大值 $1$，请在每个时间层级验证以下不等式：\n$$\n\\min_{1 \\le i \\le M} u_i^n \\ge 0, \\qquad \\max_{1 \\le i \\le M} u_i^n \\le 1.\n$$\n使用 $10^{-10}$ 的数值容差以考虑舍入误差：将低于 $-10^{-10}$ 的值视为负数，将高于 $1+10^{-10}$ 的值视为超过初始最大值。\n\n设计一个程序，对于每个指定的测试用例，返回一个布尔值，指示在所选格式和参数下，两个边界是否在所有时间层级都得到满足。将所有测试用例的布尔值汇总到一行中，如下所述。\n\n测试套件。使用以下五个测试用例来探究不同的行为：\n1. 显式向前时间中心空间法，参数为 $M=50$, $r=0.4$, $N_t=200$（一个通常稳定且单调的区域）。\n2. 显式向前时间中心空间法，参数为 $M=50$, $r=0.6$, $N_t=20$（一个在经典意义上已知不稳定的区域）。\n3. 隐式向后时间中心空间法，参数为 $M=50$, $r=5.0$, $N_t=1$（时间步长大，但为隐式格式）。\n4. Crank–Nicolson 法，参数为 $M=50$, $r=5.0$, $N_t=1$（时间步长大，时间上为梯形法）。\n5. 显式向前时间中心空间法，参数为 $M=50$, $r=0.5$, $N_t=200$（经常为单调性而讨论的临界情况）。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个方括号内以逗号分隔的列表的结果（例如，`[result1,result2,result3,result4,result5]`），其中每个 `result` 是 `True` 或 `False`，取决于该测试用例是否满足离散极值原理。", "solution": "该问题要求为一维热方程 $u_t(x,t) = \\alpha\\,u_{xx}(x,t)$ 在区域 $x \\in [0,1]$ 上推导并实现三种有限差分格式。该方程具有齐次 Dirichlet 边界条件 $u(0,t)=u(1,t)=0$ 和非负初始条件 $u(x,0)=u_0(x)$。我们被要求在指定条件下，为这些格式数值地验证一个离散的极值原理类似形式。\n\n我们用 $M$ 个内部点 $x_i = i h$（其中 $i=1, \\dots, M$）来离散化空间域，网格间距为 $h=1/(M+1)$。边界点为 $x_0=0$ 和 $x_{M+1}=1$。时间域用大小为 $\\Delta t$ 的步长离散化，使得 $t^n = n \\Delta t$。数值解 $u_i^n$ 近似于真实解 $u(x_i, t^n)$。\n\n空间导数的标准二阶中心差分近似为：\n$$\nu_{xx}(x_i, t) \\approx \\frac{u(x_{i-1}, t) - 2u(x_i, t) + u(x_{i+1}, t)}{h^2}\n$$\n我们将此与时间导数 $u_t$ 的不同近似相结合，以推导所需的格式。将使用无量纲参数 $r = \\alpha \\Delta t / h^2$，并按规定取 $\\alpha=1$。\n\n**1. 显式向前时间中心空间 (FTCS) 法**\n\n此格式对时间导数使用向前差分（在时间层级 $n$ 计算），对空间导数使用中心差分（也在时间层级 $n$ 计算）。\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2}\n$$\n整理以求解未知数 $u_i^{n+1}$，得到显式更新公式：\n$$\nu_i^{n+1} = u_i^n + \\frac{\\alpha \\Delta t}{h^2} (u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\n代入 $r=\\alpha \\Delta t/h^2$，我们有：\n$$\nu_i^{n+1} = u_i^n + r(u_{i+1}^n - 2u_i^n + u_{i-1}^n) = r u_{i-1}^n + (1-2r)u_i^n + r u_{i+1}^n\n$$\n此更新应用于所有内部点 $i=1, \\dots, M$。边界条件 $u_0^{n+1}=0$ 和 $u_{M+1}^{n+1}=0$ 用于更新 $u_1^{n+1}$ 和 $u_M^{n+1}$。为使离散极值原理（特别是非负性）成立，更新模板中的所有系数必须是非负的。这要求 $1-2r \\ge 0$，即 $r \\le 1/2$。如果满足此条件，则保证该格式是单调的。\n\n**2. 隐式向后时间中心空间 (BTCS) 法**\n\n此格式对时间导数使用向后差分，这涉及到在新的时间层级 $n+1$ 上计算空间导数。\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{h^2}\n$$\n整理以将时间层级 $n+1$ 的未知项归到左侧，得到一个线性方程组：\n$$\n-r u_{i-1}^{n+1} + (1+2r)u_i^{n+1} - r u_{i+1}^{n+1} = u_i^n\n$$\n此方程对每个内部点 $i=1, \\dots, M$ 均成立。结合边界条件 $u_0^{n+1}=0$ 和 $u_{M+1}^{n+1}=0$，我们得到一个 $M \\times M$ 的三对角线性系统 $A U^{n+1} = U^n$，其中 $U^n = [u_1^n, \\dots, u_M^n]^T$ 是时间 $n$ 的内部解向量。矩阵 $A$ 的主对角线为 $(1+2r)$，次对角线和超对角线为 $-r$。此系统必须在每个时间步求解。由于对任意 $r0$，矩阵 $A$ 都是严格对角占优的，因此它是可逆的，且该格式是无条件稳定的。此外，$A$ 是一个 M-矩阵，这意味着其逆矩阵 $A^{-1}$ 只包含非负项。因此，如果 $U^n \\ge 0$，则 $U^{n+1} = A^{-1}U^n \\ge 0$，所以该格式是无条件单调的。\n\n**3. Crank-Nicolson 方法**\n\n此方法通过在时间上应用梯形法则推导而来。时间导数在中间点 $t^{n+1/2}$ 处近似，空间导数则在时间层级 $n$ 和 $n+1$ 上取平均。\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left( \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2} + \\frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{h^2} \\right)\n$$\n乘以 $\\Delta t$ 并使用 $r = \\alpha \\Delta t/h^2$，我们将已知项和未知项分组：\n$$\n-\\frac{r}{2} u_{i-1}^{n+1} + (1+r)u_i^{n+1} - \\frac{r}{2} u_{i+1}^{n+1} = \\frac{r}{2} u_{i-1}^{n} + (1-r)u_i^n + \\frac{r}{2} u_{i+1}^{n}\n$$\n这是一个形式为 $A U^{n+1} = B U^n$ 的隐式格式。矩阵 $A$ 是三对角的，主对角线为 $(1+r)$，次对角线和超对角线为 $-r/2$。矩阵 $B$ 也是三对角的，主对角线为 $(1-r)$，次对角线和超对角线为 $r/2$。与 BTCS 一样，此格式对于任意 $r0$ 都是无条件稳定的。然而，其单调性是有条件的。为了保持非负性，矩阵 $B$ 必须将非负向量映射到非负向量。这要求 $B$ 的所有元素都是非负的，从而施加了条件 $1-r \\ge 0$，即 $r \\le 1$。在本问题中，我们将测试一个 $r1$ 的情况，此时预计会出现小幅振荡并违反非负性，特别是对于像这里使用的离散脉冲这样的非光滑初始数据。\n\n**实现**\n\n对于隐式方法（BTCS 和 Crank-Nicolson），三对角线性系统使用 Thomas 算法 (TDMA) 求解，这是一种基于高斯消元法的高效 O(M) 直接求解器。每个测试用例的模拟将进行 $N_t$ 个时间步。在每一步 $n=1, \\dots, N_t$，计算出新的解向量 $U^n$ 后，我们检查它是否满足离散极值原理：\n$$\n\\min_{1 \\le i \\le M} u_i^n \\ge -10^{-10} \\quad \\text{和} \\quad \\max_{1 \\le i \\le M} u_i^n \\le 1 + 10^{-10}\n$$\n如果在任何时间步发生违反，则该测试用例的检查失败。\n\n**数值验证**\n\n我们对所提供的五个测试用例执行此过程。\n1.  **FTCS, $r=0.4$**：由于 $r = 0.4 \\le 0.5$，该格式是单调的。极值原理应成立。\n2.  **FTCS, $r=0.6$**：由于 $r = 0.6  0.5$，该格式是不稳定的。预计解会增长和振荡，从而违反极值原理。\n3.  **BTCS, $r=5.0$**：该格式是无条件单调的。无论 $r$ 的值多大，极值原理都应成立。\n4.  **Crank-Nicolson, $r=5.0$**：当 $r1$ 时，该格式是稳定的但非单调的。对于尖锐的初始脉冲，预计会出现振荡，导致出现负值并违反极值原理。\n5.  **FTCS, $r=0.5$**：这是单调性的临界情况。系数是非负的，因此极值原理应成立。\n程序将根据这些数值实验为每个案例计算一个布尔结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tridiagonal(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal system of equations Ax=d.\n    a: sub-diagonal (length n-1)\n    b: main diagonal (length n)\n    c: super-diagonal (length n-1)\n    d: right-hand side vector (length n)\n    \"\"\"\n    n = len(d)\n    if n == 0:\n        return np.array([])\n    \n    # Create copies to avoid modifying input arrays\n    c_prime = np.zeros(n - 1)\n    d_prime = np.zeros(n)\n    x = np.zeros(n)\n\n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n    for i in range(1, n - 1):\n        m = b[i] - a[i - 1] * c_prime[i - 1]\n        c_prime[i] = c[i] / m\n        d_prime[i] = (d[i] - a[i - 1] * d_prime[i - 1]) / m\n    \n    if n > 1:\n        m_last = b[n - 1] - a[n - 2] * c_prime[n - 2]\n        d_prime[n - 1] = (d[n - 1] - a[n - 2] * d_prime[n - 2]) / m_last\n\n    # Back substitution\n    x[n - 1] = d_prime[n - 1]\n    for i in range(n - 2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i + 1]\n        \n    return x\n\ndef run_simulation(scheme, M, r, Nt):\n    \"\"\"\n    Runs the simulation for a given scheme and parameters.\n    Returns True if the discrete Maximum Principle holds, False otherwise.\n    \"\"\"\n    alpha = 1.0\n    h = 1.0 / (M + 1)\n    \n    # Initialize solution vector for interior points\n    u = np.zeros(M)\n    center_idx = int((M + 1) / 2) - 1\n    u[center_idx] = 1.0\n\n    tolerance = 1e-10\n\n    # Pre-calculate diagonals for implicit methods if needed\n    if scheme == 'BTCS':\n        diag_b = np.full(M, 1.0 + 2.0 * r)\n        diag_a = np.full(M - 1, -r)\n        diag_c = np.full(M - 1, -r)\n    elif scheme == 'CN':\n        # Matrix A (LHS)\n        diag_A_b = np.full(M, 1.0 + r)\n        diag_A_ac = np.full(M - 1, -r / 2.0)\n        # Matrix B (RHS)\n        diag_B_b = 1.0 - r\n        diag_B_ac = r / 2.0\n\n    for _ in range(Nt):\n        if scheme == 'FTCS':\n            u_old = np.copy(u)\n            for i in range(M):\n                u_left = u_old[i-1] if i > 0 else 0.0\n                u_right = u_old[i+1] if i  M-1 else 0.0\n                u[i] = u_old[i] + r * (u_left - 2.0 * u_old[i] + u_right)\n\n        elif scheme == 'BTCS':\n            u = solve_tridiagonal(diag_a, diag_b, diag_c, u)\n\n        elif scheme == 'CN':\n            # Calculate RHS vector d = B * u\n            d = np.zeros(M)\n            for i in range(M):\n                u_left = u[i-1] if i > 0 else 0.0\n                u_right = u[i+1] if i  M-1 else 0.0\n                d[i] = diag_B_ac * u_left + diag_B_b * u[i] + diag_B_ac * u_right\n            u = solve_tridiagonal(diag_A_ac, diag_A_b, diag_A_ac, d)\n\n        # Check discrete Maximum Principle\n        min_u = np.min(u)\n        max_u = np.max(u)\n\n        if min_u  -tolerance or max_u > 1.0 + tolerance:\n            return False\n    \n    return True\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (scheme, M, r, Nt)\n        ('FTCS', 50, 0.4, 200),\n        ('FTCS', 50, 0.6, 20),\n        ('BTCS', 50, 5.0, 1),\n        ('CN', 50, 5.0, 1),\n        ('FTCS', 50, 0.5, 200),\n    ]\n\n    results = []\n    for case in test_cases:\n        scheme, M, r, Nt = case\n        result = run_simulation(scheme, M, r, Nt)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```", "id": "3229680"}, {"introduction": "在地球物理学中，许多过程（如俯冲带中的热传输）同时涉及热的传导（扩散）和物质的运动（对流）。算子分裂法（Operator Splitting）是一种强大而灵活的技术，它允许我们将针对简单物理过程的求解器组合起来，以解决更复杂的多物理场问题。在本练习（[@problem_id:3590410]）中，您将应用算子分裂法来模拟一个对流-扩散系统，推导组合格式的稳定性条件，并量化由于将不同物理过程分开处理而引入的分裂误差。", "problem": "考虑具有常数系数的一维平流扩散形式的热方程，\n$$\n\\frac{\\partial T}{\\partial t} + u \\frac{\\partial T}{\\partial x} = \\kappa \\frac{\\partial^2 T}{\\partial x^2},\n$$\n该方程定义在长度为 $L$、均匀网格间距为 $\\Delta x$、时间步长为 $\\Delta t$ 的周期性域上。其中 $T(x,t)$ 是温度， $u$ 是均匀的固体速度（热的固态平流）， $\\kappa$ 是热扩散率。此设定是俯冲带中沿板片热演化的简化替代模型，捕捉了固态平流与热扩散之间的相互作用。\n\n您必须设计一个显式算子分裂时间积分器，该积分器结合了：\n- 用于平流子步骤的显式一阶迎风格式，以及\n- 用于扩散子步骤的显式前向欧拉中心差分格式，\n\n并采用周期性边界。实现两种分裂变体：\n- Lie 分裂：在每个完整时间步长内，先应用 $\\Delta t$ 的平流，然后应用 $\\Delta t$ 的扩散。\n- Strang 分裂：在每个完整时间步长内，先应用 $\\Delta t/2$ 的平流，然后应用 $\\Delta t$ 的扩散，最后再应用 $\\Delta t/2$ 的平流。\n\n从第一性原理推导此显式组合的 Courant–Friedrichs–Lewy (CFL) 组合稳定性约束。通过将数值解与周期域上常系数平流扩散方程的精确解（通过离散傅里叶变换求得）进行比较，来量化分裂误差。对于具有 $N$ 个点、网格间距 $\\Delta x = L/N$、离散波数 $k_n = 2\\pi n/L$（其中 $n \\in \\{0,1,\\dots,N-1\\}$ 映射到有符号频率）的网格，以及初始条件 $\\widehat{T}(k_n,0)$，其精确谱解由下式给出\n$$\n\\widehat{T}(k_n,t) = \\widehat{T}(k_n,0)\\,\\exp\\!\\big(-\\kappa k_n^2 t\\big)\\,\\exp\\!\\big(-\\mathrm{i} k_n u t\\big),\n$$\n物理空间解则通过逆变换获得。使用此精确解计算相对 $\\ell^2$ 误差。\n\n采用以下初始条件\n$$\nT(x,0) = \\cos\\!\\Big(\\frac{2\\pi x}{L}\\Big) + \\frac{1}{2}\\cos\\!\\Big(\\frac{4\\pi x}{L} + \\phi\\Big),\n$$\n其中相位 $\\phi = 0.3$（弧度）。角度必须以弧度为单位。\n\n定义无量纲参数\n$$\nr = \\frac{|u|\\,\\Delta t}{\\Delta x}, \\qquad \\mu = \\frac{\\kappa\\,\\Delta t}{\\Delta x^2}.\n$$\n\n您的程序必须：\n1. 实现具有周期性边界的 Lie 和 Strang 分裂积分器，使用显式一阶迎风平流子步骤和显式前向欧拉扩散子步骤。\n2. 使用上述谱公式计算在指定最终时间 $t_{\\mathrm{end}}$ 的精确参考解。\n3. 计算相对 $\\ell^2$ 误差\n$$\nE = \\frac{\\|T_{\\mathrm{num}}(\\cdot,t_{\\mathrm{end}}) - T_{\\mathrm{exact}}(\\cdot,t_{\\mathrm{end}})\\|_2}{\\|T_{\\mathrm{exact}}(\\cdot,t_{\\mathrm{end}})\\|_2}.\n$$\n4. 通过比较在相同 $t_{\\mathrm{end}}$ 下、$\\Delta t$ 和 $\\Delta t/2$ 时的误差，估计每种分裂方法在时间上的观测精度阶：\n$$\np = \\frac{\\log\\big(E(\\Delta t)/E(\\Delta t/2)\\big)}{\\log(2)}.\n$$\n5. 根据您推导的约束条件，计算组合的稳定性限制时间步长 $\\Delta t_{\\max}$。所有时间量均以秒表示。\n\n使用以下参数集测试套件。所有长度单位必须是米，时间单位是秒，速度单位是米/秒，扩散率单位是平方米/秒，相位 $\\phi$ 单位是弧度。\n\n- 测试用例 A（扩散限制约束下的收敛指数）：\n  - $L = 10{,}000$，$\\Delta x = 50$，$\\kappa = 10^{-6}$，$u = 0.05/31557600$，$\\phi = 0.3$。\n  - 令 $\\Delta t_{\\max}$ 为您推导的组合稳定性限制时间步长。\n  - 设 $\\Delta t = 0.4\\,\\Delta t_{\\max}$，$\\Delta t/2$ 为细化步长，以及 $t_{\\mathrm{end}} = 100\\,\\Delta t$。\n  - 计算如上定义的 $p_{\\mathrm{Lie}}$ 和 $p_{\\mathrm{Strang}}$。\n\n- 测试用例 B（平流限制约束下的近边界稳定性度量）：\n  - $L = 200{,}000$，$\\Delta x = 1{,}000$，$\\kappa = 10^{-6}$，$u = 0.08/31557600$，$\\phi = 0.3$。\n  - 根据组合约束计算 $\\Delta t_{\\max}$（以秒为单位）。\n  - 使用 $\\Delta t = 0.99\\,\\Delta t_{\\max}$ 并评估 $r$ 和 $\\mu$。\n  - 报告 $\\Delta t_{\\max}$（以秒为单位）、$r$、$\\mu$ 以及一个布尔值 $S$，$S$ 为真当且仅当 $r \\le 1$ 且 $\\mu \\le 1/2$。\n\n- 测试用例 C（中等步长下的分裂误差比）：\n  - $L = 10{,}000$，$\\Delta x = 50$，$\\kappa = 10^{-6}$，$u = 0.05/31557600$，$\\phi = 0.3$。\n  - 计算 $\\Delta t_{\\max}$；使用 $\\Delta t = 0.2\\,\\Delta t_{\\max}$ 和 $t_{\\mathrm{end}} = 100\\,\\Delta t$。\n  - 在相同的 $\\Delta t$ 下，计算比率 $R = E_{\\mathrm{Strang}}/E_{\\mathrm{Lie}}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序包含以下条目：\n  - 测试用例 A 的 $p_{\\mathrm{Lie}}$，\n  - 测试用例 A 的 $p_{\\mathrm{Strang}}$，\n  - 测试用例 B 的 $\\Delta t_{\\max}$（以秒为单位），\n  - 测试用例 B 的 $r$，\n  - 测试用例 B 的 $\\mu$，\n  - 测试用例 B 的 $S$（布尔值），\n  - 测试用例 C 的 $R$。\n例如：\"[pLieA,pStrangA,dtmaxB,rB,muB,SB,Rc]\"。", "solution": "我们从具有常数系数的一维平流扩散热方程开始，\n$$\n\\frac{\\partial T}{\\partial t} + u \\frac{\\partial T}{\\partial x} = \\kappa \\frac{\\partial^2 T}{\\partial x^2},\n$$\n该方程定义在长度为 $L$ 的周期性域上。算子分裂方法将其分解为一个平流算子 $A$ 和一个扩散算子 $D$，\n$$\nA[T] = -u \\frac{\\partial T}{\\partial x}, \\qquad D[T] = \\kappa \\frac{\\partial^2 T}{\\partial x^2},\n$$\n因此完整的生成元为 $L = A + D$。\n\n稳定性约束是通过对离散子步骤应用 Von Neumann 分析推导出来的。对于平流子步骤，我们选择显式一阶迎风格式。在间距为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格上，当 $u \\ge 0$ 时，更新公式为\n$$\nT_i^{n+1} = T_i^n - r\\,(T_i^n - T_{i-1}^n), \\quad r = \\frac{u\\,\\Delta t}{\\Delta x},\n$$\n其中索引是周期性的。对于傅里叶模式 $e^{\\mathrm{i} k i \\Delta x}$，其放大因子为\n$$\ng_A(k) = 1 - r\\,(1 - e^{-\\mathrm{i} k \\Delta x}).\n$$\n迎风格式的一个标准结论是，稳定性要求\n$$\n|g_A(k)| \\le 1 \\quad \\text{对所有 } k \\quad \\Longleftrightarrow \\quad 0 \\le r \\le 1,\n$$\n并且通过对称性，对于 $u  0$ 的情况，要求 $0 \\le |r| \\le 1$。因此，平流的 CFL 约束是\n$$\nr = \\frac{|u|\\,\\Delta t}{\\Delta x} \\le 1 \\quad \\Longleftrightarrow \\quad \\Delta t \\le \\frac{\\Delta x}{|u|}.\n$$\n\n对于扩散子步骤，我们使用显式前向欧拉中心差分格式，\n$$\nT_i^{n+1} = T_i^n + \\mu\\,\\big(T_{i+1}^n - 2 T_i^n + T_{i-1}^n\\big), \\quad \\mu = \\frac{\\kappa\\,\\Delta t}{\\Delta x^2}.\n$$\n其傅里叶放大因子为\n$$\ng_D(k) = 1 - 4\\mu \\sin^2\\!\\Big(\\frac{k \\Delta x}{2}\\Big).\n$$\n稳定性要求对所有 $k$ 都有 $|g_D(k)| \\le 1$，这当且仅当\n$$\n0 \\le \\mu \\le \\frac{1}{2} \\quad \\Longleftrightarrow \\quad \\Delta t \\le \\frac{\\Delta x^2}{2\\kappa}.\n$$\n\n因为我们在每个完整的时间步长内显式地组合子步骤，一个充分的组合稳定性条件是两个子步骤都各自稳定。因此，组合的时间步长约束是\n$$\n\\Delta t \\le \\min\\!\\left(\\frac{\\Delta x}{|u|}, \\frac{\\Delta x^2}{2\\kappa}\\right) \\equiv \\Delta t_{\\max}.\n$$\n\n接下来我们论证分裂误差的阶数。一个时间步长的精确解算子是半群 $e^{\\Delta t (A+D)}$。Lie 分裂先应用 $e^{\\Delta t A}$ 再应用 $e^{\\Delta t D}$，这可以通过 Baker–Campbell–Hausdorff (BCH) 公式与精确算子联系起来：\n$$\ne^{\\Delta t A} e^{\\Delta t D} = e^{\\Delta t (A+D) + \\frac{\\Delta t^2}{2}[A,D] + \\mathcal{O}(\\Delta t^3)},\n$$\n其中 $[A,D] = AD - DA$ 是对易子。由于当 $u \\ne 0$ 和 $\\kappa \\ne 0$ 时 $[A,D] \\ne 0$，每个时间步的局部误差是 $\\mathcal{O}(\\Delta t^2)$，经过 $t_{\\mathrm{end}}/\\Delta t$ 步后，全局误差累积为 $\\mathcal{O}(\\Delta t)$。因此，Lie 分裂在时间上是一阶的。Strang 分裂使用对称组合 $e^{\\frac{\\Delta t}{2} A} e^{\\Delta t D} e^{\\frac{\\Delta t}{2} A}$，其 BCH 展开导致主导的对易子项抵消，并且\n$$\ne^{\\frac{\\Delta t}{2} A} e^{\\Delta t D} e^{\\frac{\\Delta t}{2} A} = e^{\\Delta t (A+D) + \\mathcal{O}(\\Delta t^3)}.\n$$\n因此，局部误差为 $\\mathcal{O}(\\Delta t^3)$，全局误差为 $\\mathcal{O}(\\Delta t^2)$，即在时间上是二阶的。\n\n为了量化误差，我们与可通过谱方法获得的精确周期解进行比较。设 $N = L/\\Delta x$ 和离散波数 $k_n = 2\\pi n/L$，其中 $n \\in \\{0,1,\\dots,N-1\\}$ 使用标准离散傅里叶变换约定映射到有符号频率。如果 $\\widehat{T}(k_n,0)$ 是 $T(\\cdot,0)$ 的离散傅里叶变换，那么精确演化为\n$$\n\\widehat{T}(k_n,t) = \\widehat{T}(k_n,0)\\,\\exp\\!\\big(-\\kappa k_n^2 t\\big)\\,\\exp\\!\\big(-\\mathrm{i} k_n u t\\big),\n$$\n而精确的 $T(\\cdot,t)$ 是其逆变换。相对 $\\ell^2$ 误差使用\n$$\nE = \\frac{\\|T_{\\mathrm{num}} - T_{\\mathrm{exact}}\\|_2}{\\|T_{\\mathrm{exact}}\\|_2},\n$$\n观测到的阶数通过以下方式估计\n$$\np = \\frac{\\log\\big(E(\\Delta t)/E(\\Delta t/2)\\big)}{\\log 2}.\n$$\n\n程序的算法设计：\n- 构建均匀网格 $x_j = j\\,\\Delta x$，$j = 0,1,\\dots,N-1$，并考虑周期性。\n- 初始化 $T(x,0) = \\cos(2\\pi x/L) + \\frac{1}{2}\\cos(4\\pi x/L + \\phi)$，其中 $\\phi = 0.3$（弧度）。\n- 定义显式迎风平流子步骤。对于 $u \\ge 0$，\n$$\nT_j^{\\star} = T_j - r\\,(T_j - T_{j-1}), \\quad r = \\frac{u\\Delta t}{\\Delta x},\n$$\n对于 $u  0$，\n$$\nT_j^{\\star} = T_j - r\\,(T_{j+1} - T_j), \\quad r = \\frac{u\\Delta t}{\\Delta x},\n$$\n其中 $j \\pm 1$ 的索引是周期性的。\n- 定义显式前向欧拉扩散子步骤，\n$$\nT_j^{\\mathrm{new}} = T_j^{\\star} + \\mu\\,(T_{j+1}^{\\star} - 2 T_j^{\\star} + T_{j-1}^{\\star}), \\quad \\mu = \\frac{\\kappa \\Delta t}{\\Delta x^2}.\n$$\n- 对于选定的 $\\Delta t$ 和步数 $n = t_{\\mathrm{end}}/\\Delta t$，根据 Lie 和 Strang 分裂组合子步骤。\n- 使用上述离散傅里叶变换公式计算在 $t_{\\mathrm{end}}$ 时的精确解。\n- 计算相对 $\\ell^2$ 误差和观测阶数。\n- 对于稳定性度量，计算所选 $\\Delta t$ 的 $r$ 和 $\\mu$，并返回是否满足 $r \\le 1$ 和 $\\mu \\le 1/2$。\n\n我们将此应用于三个指定的测试用例：\n\n- 测试用例 A：\n  - $L = 10{,}000$，$\\Delta x = 50$，$\\kappa = 10^{-6}$，$u = 0.05/31557600$，$\\phi = 0.3$。\n  - $\\Delta t_{\\max} = \\min\\!\\big(\\Delta x/|u|,\\ \\Delta x^2/(2\\kappa)\\big)$。\n  - 使用 $\\Delta t = 0.4\\,\\Delta t_{\\max}$，$t_{\\mathrm{end}} = 100\\,\\Delta t$。\n  - 计算 $p_{\\mathrm{Lie}}$ 和 $p_{\\mathrm{Strang}}$。\n\n- 测试用例 B：\n  - $L = 200{,}000$，$\\Delta x = 1{,}000$，$\\kappa = 10^{-6}$，$u = 0.08/31557600$，$\\phi = 0.3$。\n  - 计算 $\\Delta t_{\\max}$，然后使用 $\\Delta t = 0.99\\,\\Delta t_{\\max}$ 报告 $\\Delta t_{\\max}$、$r$、$\\mu$ 和 $S = (r \\le 1)\\wedge(\\mu \\le 1/2)$。\n\n- 测试用例 C：\n  - $L = 10{,}000$，$\\Delta x = 50$，$\\kappa = 10^{-6}$，$u = 0.05/31557600$，$\\phi = 0.3$。\n  - 使用 $\\Delta t = 0.2\\,\\Delta t_{\\max}$ 和 $t_{\\mathrm{end}} = 100\\,\\Delta t$，计算 $R = E_{\\mathrm{Strang}}/E_{\\mathrm{Lie}}$。\n\n所有时间量必须以秒表示。最终打印的输出必须是以下格式的单行：\n$$\n[\\ p_{\\mathrm{Lie}}^{(A)},\\ p_{\\mathrm{Strang}}^{(A)},\\ \\Delta t_{\\max}^{(B)},\\ r^{(B)},\\ \\mu^{(B)},\\ S^{(B)},\\ R^{(C)}\\ ].\n$$", "answer": "```python\nimport numpy as np\n\ndef upwind_advection_step(T, u, dx, dt):\n    \"\"\"First-order upwind advection with periodic boundaries.\"\"\"\n    r = u * dt / dx\n    if u >= 0.0:\n        return T - r * (T - np.roll(T, 1))\n    else:\n        return T - r * (np.roll(T, -1) - T)\n\ndef diffusion_step(T, kappa, dx, dt):\n    \"\"\"Explicit forward Euler diffusion (FTCS) with periodic boundaries.\"\"\"\n    mu = kappa * dt / (dx * dx)\n    return T + mu * (np.roll(T, -1) - 2.0 * T + np.roll(T, 1))\n\ndef lie_splitting(T0, u, kappa, dx, dt, nsteps):\n    \"\"\"Advance by nsteps of Lie splitting: A(dt) then D(dt).\"\"\"\n    T = T0.copy()\n    for _ in range(nsteps):\n        T = upwind_advection_step(T, u, dx, dt)\n        T = diffusion_step(T, kappa, dx, dt)\n    return T\n\ndef strang_splitting(T0, u, kappa, dx, dt, nsteps):\n    \"\"\"Advance by nsteps of Strang splitting: A(dt/2), D(dt), A(dt/2).\"\"\"\n    T = T0.copy()\n    half_dt = 0.5 * dt\n    for _ in range(nsteps):\n        T = upwind_advection_step(T, u, dx, half_dt)\n        T = diffusion_step(T, kappa, dx, dt)\n        T = upwind_advection_step(T, u, dx, half_dt)\n    return T\n\ndef exact_solution_fft(T0, u, kappa, L, dx, t):\n    \"\"\"Exact periodic solution via discrete Fourier transform.\"\"\"\n    N = T0.size\n    # Wavenumbers in radians per meter\n    k = 2.0 * np.pi * np.fft.fftfreq(N, d=dx)\n    T0_hat = np.fft.fft(T0)\n    phase = np.exp(-(kappa * (k ** 2)) * t) * np.exp(-1j * k * u * t)\n    T_hat_t = T0_hat * phase\n    T_t = np.fft.ifft(T_hat_t).real\n    return T_t\n\ndef initial_condition(x, L, phi):\n    \"\"\"Initial condition: cos(2π x/L) + 0.5 cos(4π x/L + phi).\"\"\"\n    return np.cos(2.0 * np.pi * x / L) + 0.5 * np.cos(4.0 * np.pi * x / L + phi)\n\ndef rel_l2_error(a, b):\n    denom = np.linalg.norm(b)\n    if denom == 0.0:\n        return np.inf\n    return np.linalg.norm(a - b) / denom\n\ndef combined_dt_max(dx, u, kappa):\n    \"\"\"Combined explicit stability limit: min(dx/|u|, dx^2/(2*kappa)).\"\"\"\n    adv = np.inf if u == 0.0 else dx / abs(u)\n    diff = (dx * dx) / (2.0 * kappa)\n    return min(adv, diff)\n\ndef observed_order(error_dt, error_dt2):\n    \"\"\"Compute observed order p = log(E(dt)/E(dt/2))/log(2).\"\"\"\n    if error_dt = 0 or error_dt2 = 0:\n        return np.nan\n    return np.log(error_dt / error_dt2) / np.log(2.0)\n\ndef run_test_case_A():\n    # Parameters\n    L = 10000.0\n    dx = 50.0\n    kappa = 1e-6\n    seconds_per_year = 31557600.0 # 365.25 * 24.0 * 3600.0\n    u = 0.05 / seconds_per_year  # 0.05 m/yr in m/s\n    phi = 0.3\n    N = int(round(L / dx))\n    x = np.arange(N) * dx\n    T0 = initial_condition(x, L, phi)\n\n    dt_max = combined_dt_max(dx, u, kappa)\n    dt = 0.4 * dt_max\n    dt2 = 0.5 * dt\n    nsteps = 100\n    tend = nsteps * dt\n\n    T_exact = exact_solution_fft(T0, u, kappa, L, dx, tend)\n    \n    # Lie splitting errors at dt and dt/2\n    T_lie_dt = lie_splitting(T0, u, kappa, dx, dt, nsteps)\n    E_lie_dt = rel_l2_error(T_lie_dt, T_exact)\n\n    nsteps2 = int(round(tend / dt2))\n    T_lie_dt2 = lie_splitting(T0, u, kappa, dx, dt2, nsteps2)\n    E_lie_dt2 = rel_l2_error(T_lie_dt2, T_exact)\n\n    p_lie = observed_order(E_lie_dt, E_lie_dt2)\n\n    # Strang splitting errors at dt and dt/2\n    T_strang_dt = strang_splitting(T0, u, kappa, dx, dt, nsteps)\n    E_strang_dt = rel_l2_error(T_strang_dt, T_exact)\n\n    T_strang_dt2 = strang_splitting(T0, u, kappa, dx, dt2, nsteps2)\n    E_strang_dt2 = rel_l2_error(T_strang_dt2, T_exact)\n\n    p_strang = observed_order(E_strang_dt, E_strang_dt2)\n\n    return float(p_lie), float(p_strang)\n\ndef run_test_case_B():\n    L = 200000.0\n    dx = 1000.0\n    kappa = 1e-6\n    seconds_per_year = 31557600.0\n    u = 0.08 / seconds_per_year  # 0.08 m/yr in m/s\n\n    dt_max = combined_dt_max(dx, u, kappa)\n    dt = 0.99 * dt_max\n    r = abs(u) * dt / dx\n    mu = kappa * dt / (dx * dx)\n    stable = (r = 1.0) and (mu = 0.5)\n    return float(dt_max), float(r), float(mu), bool(stable)\n\ndef run_test_case_C():\n    L = 10000.0\n    dx = 50.0\n    kappa = 1e-6\n    seconds_per_year = 31557600.0\n    u = 0.05 / seconds_per_year  # 0.05 m/yr in m/s\n    phi = 0.3\n    N = int(round(L / dx))\n    x = np.arange(N) * dx\n    T0 = initial_condition(x, L, phi)\n\n    dt_max = combined_dt_max(dx, u, kappa)\n    dt = 0.2 * dt_max\n    nsteps = 100\n    tend = nsteps * dt\n\n    T_exact = exact_solution_fft(T0, u, kappa, L, dx, tend)\n\n    T_lie = lie_splitting(T0, u, kappa, dx, dt, nsteps)\n    E_lie = rel_l2_error(T_lie, T_exact)\n\n    T_strang = strang_splitting(T0, u, kappa, dx, dt, nsteps)\n    E_strang = rel_l2_error(T_strang, T_exact)\n\n    R = E_strang / E_lie if E_lie != 0.0 else np.nan\n    return float(R)\n\ndef solve():\n    p_lie_A, p_strang_A = run_test_case_A()\n    dtmax_B, r_B, mu_B, S_B = run_test_case_B()\n    R_C = run_test_case_C()\n\n    results = [p_lie_A, p_strang_A, dtmax_B, r_B, mu_B, S_B, R_C]\n    \n    # Format boolean as lowercase true/false\n    formatted_results = []\n    for r in results:\n        if isinstance(r, bool):\n            formatted_results.append(str(r).lower())\n        else:\n            formatted_results.append(str(r))\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    # seconds_per_year in problem description is 31557600, using that for consistency\n    # (vs 365.25 * 24 * 3600 = 31557600.0)\n    solve()\n```", "id": "3590410"}]}