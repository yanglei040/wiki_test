{"hands_on_practices": [{"introduction": "我们从一个可以通过解析方法求解的基础问题开始。这个练习旨在模拟大陆地壳中的稳态温度分布，其中一个关键因素是地壳内部放射性生热。通过推导和计算，你将亲身体会到内部热源如何改变地温梯度，并理解这对于确定地壳内最高温度点的位置有何重要意义。这个练习不仅能锻炼你的解析推导能力，还能展示如何通过简化模型获得重要的地球物理洞察 [@problem_id:3611228]。", "problem": "考虑一个导热的大陆地壳，理想化为一个厚度为 $L$ 的有限、均匀的一维（1D）板块，其垂直坐标 $z$ 从地表（$z=0$）向下测量至地壳底部（$z=L$）。假设热导率 $k$ 恒定，且在稳态能量守恒下存在体积内热生成 $H(z)$。其控制方程是带内部加热的一维稳态热方程：\n$$\n\\frac{d}{dz}\\!\\left(k\\,\\frac{dT}{dz}\\right)+H(z)=0,\n$$\n边界条件为固定温度 $T(0)=T_s$ 和 $T(L)=T_b$。设地壳内的放射性生热在空间上是均匀的，即对于 $0\\le z\\le L$，有 $H(z)=H_0$。\n\n从上述基本定律和定义出发，推导温度剖面 $T(z)$，求出板内温度 $T(z)$ 达到最大值时的深度 $z_{\\max}$，并将其与无放射性生热情况（$H_0=0$）进行比较。使用以下参数值：\n- $L=60\\,\\mathrm{km}$，\n- $k=3\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}$，\n- $T_s=273\\,\\mathrm{K}$，\n- $T_b=823\\,\\mathrm{K}$，\n- $H_0=2.0\\times10^{-6}\\,\\mathrm{W\\,m^{-3}}$，\n计算相对于无放射性生热情况，温度最大值的向上位移，定义为 $\\Delta z=L-z_{\\max}$。请用公里表示你的最终答案，并将答案四舍五入至三位有效数字。", "solution": "### 步骤1：推导温度剖面 $T(z)$\n\n对于具有恒定热导率 $k$ 和均匀内热生成 $H_0$ 的一维稳态热传导，其控制方程为：\n$$\nk\\frac{d^2T}{dz^2} + H_0 = 0\n$$\n可改写为：\n$$\n\\frac{d^2T}{dz^2} = -\\frac{H_0}{k}\n$$\n对该方程关于 $z$ 积分一次，得到温度梯度：\n$$\n\\frac{dT}{dz} = -\\frac{H_0}{k}z + C_1\n$$\n其中 $C_1$ 是一个积分常数。第二次积分得到温度剖面 $T(z)$：\n$$\nT(z) = -\\frac{H_0}{2k}z^2 + C_1 z + C_2\n$$\n其中 $C_2$ 是第二个积分常数。我们通过应用边界条件来确定常数 $C_1$ 和 $C_2$。\n\n在地表，$z=0$，温度为 $T(0) = T_s$：\n$$\nT(0) = -\\frac{H_0}{2k}(0)^2 + C_1(0) + C_2 = T_s\n$$\n这直接给出 $C_2 = T_s$。现在温度剖面为：\n$$\nT(z) = -\\frac{H_0}{2k}z^2 + C_1 z + T_s\n$$\n在地壳底部，$z=L$，温度为 $T(L) = T_b$：\n$$\nT(L) = -\\frac{H_0}{2k}L^2 + C_1 L + T_s = T_b\n$$\n我们求解 $C_1$：\n$$\nC_1 L = T_b - T_s + \\frac{H_0 L^2}{2k}\n$$\n$$\nC_1 = \\frac{T_b - T_s}{L} + \\frac{H_0 L}{2k}\n$$\n将 $C_1$ 和 $C_2$ 的表达式代入 $T(z)$ 的通解，我们得到完整的温度剖面：\n$$\nT(z) = -\\frac{H_0}{2k}z^2 + \\left(\\frac{T_b - T_s}{L} + \\frac{H_0 L}{2k}\\right)z + T_s\n$$\n这可以重新整理，以分离线性传导分量和放射性生热分量：\n$$\nT(z) = T_s + (T_b - T_s)\\frac{z}{L} + \\frac{H_0}{2k}(Lz - z^2)\n$$\n\n### 步骤2：最高温度深度 $z_{\\max}$\n\n板内的最高温度出现在温度梯度为零的深度 $z_{\\max}$ 处，即 $\\frac{dT}{dz}|_{z=z_{\\max}} = 0$。使用前面推导出的梯度表达式：\n$$\n\\frac{dT}{dz} = -\\frac{H_0}{k}z + C_1\n$$\n在 $z=z_{\\max}$ 处令梯度为零：\n$$\n0 = -\\frac{H_0}{k}z_{\\max} + C_1\n$$\n求解 $z_{\\max}$：\n$$\nz_{\\max} = \\frac{k C_1}{H_0}\n$$\n代入推导出的 $C_1$ 表达式：\n$$\nz_{\\max} = \\frac{k}{H_0}\\left(\\frac{T_b - T_s}{L} + \\frac{H_0 L}{2k}\\right)\n$$\n$$\nz_{\\max} = \\frac{k(T_b - T_s)}{H_0 L} + \\frac{L}{2}\n$$\n这是温度达到其最大值时的深度。为了使这个最大值物理上位于地壳内部，我们必须有 $0 \\le z_{\\max} \\le L$。\n\n### 步骤3：无放射性生热情况和向上位移 $\\Delta z$\n\n在无放射性生热情况下，$H_0 = 0$。控制方程简化为 $\\frac{d^2T}{dz^2} = 0$，温度剖面变为线性：\n$$\nT(z) = T_s + (T_b - T_s)\\frac{z}{L}\n$$\n温度梯度为 $\\frac{dT}{dz} = \\frac{T_b - T_s}{L}$。由于 $T_b > T_s$，该梯度是一个正常数，意味着温度随深度单调增加。因此，最高温度出现在底部边界，$z = L$。\n\n问题将温度最大值的向上位移 $\\Delta z$ 定义为无放射性生热情况下最大值深度（$L$）与有放射性生热情况下最大值深度（$z_{\\max}$）之差。\n$$\n\\Delta z = L - z_{\\max}\n$$\n代入 $z_{\\max}$ 的表达式：\n$$\n\\Delta z = L - \\left(\\frac{k(T_b - T_s)}{H_0 L} + \\frac{L}{2}\\right)\n$$\n$$\n\\Delta z = \\frac{L}{2} - \\frac{k(T_b - T_s)}{H_0 L}\n$$\n\n### 步骤4：数值计算\n\n给定以下参数值，我们必须将其转换为国际单位制（SI）基本单位：\n- $L = 60\\,\\mathrm{km} = 6 \\times 10^4\\,\\mathrm{m}$\n- $k = 3\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}$\n- $T_s = 273\\,\\mathrm{K}$\n- $T_b = 823\\,\\mathrm{K}$，所以 $T_b - T_s = 550\\,\\mathrm{K}$\n- $H_0 = 2.0 \\times 10^{-6}\\,\\mathrm{W\\,m^{-3}}$\n\n现在我们将这些值代入 $\\Delta z$ 的表达式中：\n$$\n\\Delta z = \\frac{6 \\times 10^4\\,\\mathrm{m}}{2} - \\frac{(3\\,\\mathrm{W\\,m^{-1}\\,K^{-1}})(550\\,\\mathrm{K})}{(2.0 \\times 10^{-6}\\,\\mathrm{W\\,m^{-3}})(6 \\times 10^4\\,\\mathrm{m})}\n$$\n首先，计算第二项：\n$$\n\\frac{k(T_b - T_s)}{H_0 L} = \\frac{1650\\,\\mathrm{W\\,m^{-1}}}{1.2 \\times 10^{-1}\\,\\mathrm{W\\,m^{-2}}} = \\frac{1650}{0.12}\\,\\mathrm{m} = 13750\\,\\mathrm{m}\n$$\n现在，计算 $\\Delta z$：\n$$\n\\Delta z = 30000\\,\\mathrm{m} - 13750\\,\\mathrm{m} = 16250\\,\\mathrm{m}\n$$\n问题要求答案以公里为单位：\n$$\n\\Delta z = 16.25\\,\\mathrm{km}\n$$\n四舍五入到三位有效数字，我们得到：\n$$\n\\Delta z \\approx 16.3\\,\\mathrm{km}\n$$\n作为检验，最高温度的深度为 $z_{\\max} = L - \\Delta z = 60\\,\\mathrm{km} - 16.25\\,\\mathrm{km} = 43.75\\,\\mathrm{km}$。由于 $0  43.75  60$，最大值如预期般位于地壳内部。", "answer": "$$\\boxed{16.3}$$", "id": "3611228"}, {"introduction": "在掌握了解析模型之后，我们将进入更强大、更灵活的数值方法世界。这个练习将处理一个更符合实际的海洋岩石圈模型，其中热导率 $k$ 是随温度 $T$ 变化的。解决这个非线性问题需要你运用计算地球物理学中的核心技术：有限差分法和牛顿法，这为你解决更复杂的真实世界问题打下坚实的基础 [@problem_id:3611187]。", "problem": "考虑一个一维、垂直分层的海洋岩石圈板块，该板块在没有内部热源的稳态下进行热传导。垂直坐标为 $z \\in [0,L]$，从 $z=0$ 的海底算起，向下为正，直至 $z=L$ 的热边界层底部。设海底温度为 $T_s$，基底温度为 $T_m$，两者均以开尔文为单位。热导率 $k(T)$ 与温度相关，其模型为 $k(T) = \\dfrac{k_0}{1+\\beta T}$，其中 $k_0$ 是一个单位为 $\\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$ 的正常数，$\\beta$ 是一个单位为 $\\text{K}^{-1}$ 的非负常数。稳态下的控制能量方程是基于傅里叶热传导定律的能量守恒方程，在一维情况下简化为\n$$\n\\frac{d}{dz}\\left(k(T)\\frac{dT}{dz}\\right) = 0,\n$$\n其狄利克雷边界条件为 $T(0) = T_s$ 和 $T(L) = T_m$。\n\n您必须实现一个牛顿法方案，使用有限差分法（FDM）求解离散化的非线性边值问题。离散化应使用 $N$ 个网格点，均匀间距为 $\\Delta z = L/(N-1)$，并使用以边为中心的热导率来近似传导算子，以确保离散通量的连续性。具体来说，对于任意内部节点索引 $i$（$i=1,\\dots,N-2$），定义 $k_{i+1/2} = k\\!\\left(\\frac{T_i + T_{i+1}}{2}\\right)$ 和 $k_{i-1/2} = k\\!\\left(\\frac{T_{i-1} + T_i}{2}\\right)$，并强制执行离散残差\n$$\nR_i(T) = \\frac{k_{i+1/2}(T_{i+1}-T_i) - k_{i-1/2}(T_i - T_{i-1})}{\\Delta z^2} = 0.\n$$\n通过组装雅可比矩阵来构建牛顿-拉夫逊（NR）线性化。雅可比矩阵包含由链式法则（包括 $\\frac{dk}{dT}(T)$）推导出的精确偏导数 $\\partial R_i/\\partial T_j$，然后进行迭代直至收敛。当内部残差向量的无穷范数 $\\|R\\|_\\infty$ 小于 $10^{-10}$ 时，必须判定为收敛。\n\n对于年龄为 $t$ 的海洋板块的物理相关厚度 $L$，使用扩散长度尺度 $L = 2\\sqrt{\\kappa t}$，其中 $\\kappa$ 是热扩散率（单位为 $\\text{m}^2\\,\\text{s}^{-1}$），$t$ 是年龄（单位为秒）。取年龄 $t$ 对应 3000 万年（$30$ Myr），并使用每年 365.25 天将 $t$ 计算为秒。\n\n在求解出温度分布 $T(z)$ 后，计算海底的向上热通量大小\n$$\nq_{\\text{nl}} = \\left| -\\,k\\!\\left(\\frac{T_0 + T_1}{2}\\right)\\frac{T_1 - T_0}{\\Delta z} \\right|,\n$$\n单位为 $\\text{W}\\,\\text{m}^{-2}$。然后，通过计算恒定热导率下的热通量，来量化假设热导率恒定为其冷表面值 $k_{\\text{const}} = k(T_s)$ 所引入的误差\n$$\nq_{\\text{const}} = \\frac{k_{\\text{const}}(T_m - T_s)}{L},\n$$\n单位为 $\\text{W}\\,\\text{m}^{-2}$，以及相对误差\n$$\nE = \\frac{q_{\\text{const}} - q_{\\text{nl}}}{q_{\\text{nl}}},\n$$\n以小数形式表示（无量纲）。所有通量必须以 $\\text{W}\\,\\text{m}^{-2}$ 计算和解释，所有温度必须以开尔文为单位。\n\n为以下参数集测试套件实现算法并生成结果；对于每种情况，使用相同的年龄 $t=30$ Myr 和热扩散率 $\\kappa = 1.0\\times 10^{-6}\\ \\text{m}^2\\,\\text{s}^{-1}$，并改变温度依赖性和分辨率以测试解的不同方面：\n\n- 情况A（基准“理想”路径）：$k_0 = 3.2\\ \\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$，$\\beta = 4.0\\times 10^{-4}\\ \\text{K}^{-1}$，$T_s = 273\\ \\text{K}$，$T_m = 1573\\ \\text{K}$，$N=101$。\n- 情况B（温度依赖性可忽略的情况）：$k_0 = 3.2\\ \\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$，$\\beta = 0.0\\ \\text{K}^{-1}$，$T_s = 273\\ \\text{K}$，$T_m = 1573\\ \\text{K}$，$N=101$。\n- 情况C（强温度依赖性和更精细的网格）：$k_0 = 3.2\\ \\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$，$\\beta = 1.0\\times 10^{-3}\\ \\text{K}^{-1}$，$T_s = 273\\ \\text{K}$，$T_m = 1573\\ \\text{K}$，$N=201$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序如下：\n$$\n[q_{\\text{nl}}^{(A)}, q_{\\text{const}}^{(A)}, E^{(A)}, q_{\\text{nl}}^{(B)}, q_{\\text{const}}^{(B)}, E^{(B)}, q_{\\text{nl}}^{(C)}, q_{\\text{const}}^{(C)}, E^{(C)}].\n$$\n通量必须以 $\\text{W}\\,\\text{m}^{-2}$ 为单位计算，误差以小数形式表示；打印的值应为不带单位符号的浮点数。", "solution": "**1. 控制方程与离散化**\n\n问题始于稳态、一维、无内部热源的热传导方程：\n$$\n\\frac{d}{dz}\\left(k(T)\\frac{dT}{dz}\\right) = 0\n$$\n其中 $z \\in [0,L]$ 是垂直坐标，$T(z)$ 是温度，$k(T)$ 是与温度相关的热导率，由下式给出：\n$$\nk(T) = \\frac{k_0}{1+\\beta T}\n$$\n该区域服从狄利克雷边界条件：\n$$\nT(0) = T_s, \\quad T(L) = T_m\n$$\n我们使用 $N$ 个网格点 $z_i = i \\Delta z$（$i=0, 1, \\dots, N-1$）对区域进行离散化，其中网格间距为 $\\Delta z = L/(N-1)$。这些点上的温度记为 $T_i = T(z_i)$。边界条件固定了 $T_0 = T_s$ 和 $T_{N-1} = T_m$。剩下的 $N-2$ 个内部温度 $T_1, \\dots, T_{N-2}$ 是未知数。\n\n控制方程使用确保热通量守恒的有限差分格式进行离散化。在每个内部节点 $i \\in \\{1, \\dots, N-2\\}$，我们强制残差 $R_i$ 为零：\n$$\nR_i(\\mathbf{T}) = \\frac{k_{i+1/2}(T_{i+1}-T_i) - k_{i-1/2}(T_i - T_{i-1})}{\\Delta z^2} = 0\n$$\n热导率在节点之间的中点（单元格边缘）进行评估，以确保离散通量的连续性：\n$$\nk_{i+1/2} = k\\left(\\frac{T_i + T_{i+1}}{2}\\right), \\quad k_{i-1/2} = k\\left(\\frac{T_{i-1} + T_i}{2}\\right)\n$$\n这将产生一个关于未知内部温度向量 $\\mathbf{T}_{\\text{int}} = [T_1, T_2, \\dots, T_{N-2}]^T$ 的 $N-2$ 个非线性代数方程组。\n\n**2. 牛顿-拉夫逊方法**\n\n为了求解非线性系统 $\\mathbf{R}(\\mathbf{T}_{\\text{int}}) = \\mathbf{0}$，我们采用牛顿-拉夫逊方法。从一个初始猜测 $\\mathbf{T}^{(0)}$ 开始，我们使用以下更新规则迭代地改进解：\n$$\n\\mathbf{T}^{(k+1)} = \\mathbf{T}^{(k)} + \\delta\\mathbf{T}\n$$\n其中更新步长 $\\delta\\mathbf{T}$ 是线性系统的解：\n$$\nJ(\\mathbf{T}^{(k)}) \\delta\\mathbf{T} = -\\mathbf{R}(\\mathbf{T}^{(k)})\n$$\n这里，$J$ 是雅可比矩阵，其元素为 $J_{ij} = \\frac{\\partial R_i}{\\partial T_j}$（其中 $i,j$ 指的是内部节点的索引，$1, \\dots, N-2$）。迭代持续进行，直到残差向量的无穷范数低于指定容差 $\\|R\\|_\\infty  10^{-10}$。一个线性的温度剖面 $T_i = T_s + (T_m-T_s) \\frac{z_i}{L}$ 是一个很好的初始猜测。\n\n**3. 雅可比矩阵推导**\n\n关键步骤是构建雅可比矩阵。由于残差 $R_i$ 仅依赖于 $T_{i-1}$、$T_i$ 和 $T_{i+1}$，因此雅可比矩阵是一个三对角矩阵。我们使用链式法则和热导率函数的导数 $k'(T) = \\frac{dk}{dT} = -\\beta k_0 (1+\\beta T)^{-2}$ 来推导其元素。\n\n$R_i$ 对未知温度的非零偏导数如下：\n\n*   **次对角线（$J_{i,i-1}$）**：对于 $i \\in \\{2, \\dots, N-2\\}$\n    $$\n    \\frac{\\partial R_i}{\\partial T_{i-1}} = \\frac{1}{\\Delta z^2} \\frac{\\partial}{\\partial T_{i-1}} \\left[ -k_{i-1/2}(T_i - T_{i-1}) \\right] = \\frac{1}{\\Delta z^2} \\left[ -\\frac{1}{2}k'_{i-1/2}(T_i - T_{i-1}) + k_{i-1/2} \\right]\n    $$\n*   **主对角线（$J_{i,i}$）**：对于 $i \\in \\{1, \\dots, N-2\\}$\n    $$\n    \\frac{\\partial R_i}{\\partial T_i} = \\frac{1}{\\Delta z^2} \\frac{\\partial}{\\partial T_i} \\left[ k_{i+1/2}(T_{i+1}-T_i) - k_{i-1/2}(T_i - T_{i-1}) \\right] \\\\\n    = \\frac{1}{\\Delta z^2} \\left[ \\frac{1}{2}k'_{i+1/2}(T_{i+1}-T_i) - k_{i+1/2} - \\frac{1}{2}k'_{i-1/2}(T_i - T_{i-1}) - k_{i-1/2} \\right]\n    $$\n*   **超对角线（$J_{i,i+1}$）**：对于 $i \\in \\{1, \\dots, N-3\\}$\n    $$\n    \\frac{\\partial R_i}{\\partial T_{i+1}} = \\frac{1}{\\Delta z^2} \\frac{\\partial}{\\partial T_{i+1}} \\left[ k_{i+1/2}(T_{i+1}-T_i) \\right] = \\frac{1}{\\Delta z^2} \\left[ \\frac{1}{2}k'_{i+1/2}(T_{i+1}-T_i) + k_{i+1/2} \\right]\n    $$\n\n这个三对角系统 $J\\delta\\mathbf{T} = -\\mathbf{R}$ 可以使用诸如托马斯算法（Thomas algorithm）之类的方法在 $O(N)$ 时间内高效求解，该算法在 `scipy.linalg.solve_banded` 中可用。\n\n**4. 物理参数与后处理**\n\n岩石圈的厚度 $L$ 由年龄为 $t=3000$ 万年的板块的热扩散长度尺度决定。使用 $1 \\text{ 年} = 365.25 \\times 86400 \\text{ 秒}$，我们以秒为单位计算 $t$。\n$$\nL = 2\\sqrt{\\kappa t}\n$$\n其中 $\\kappa=1.0\\times 10^{-6}\\ \\text{m}^2\\,\\text{s}^{-1}$。\n\n在收敛到最终温度剖面 $T(z)$ 后，我们计算所需的量。海底（$z=0$）的向上热通量大小由求解出的近地表温度梯度计算得出：\n$$\nq_{\\text{nl}} = \\left| -k\\left(\\frac{T_0 + T_1}{2}\\right) \\frac{T_1 - T_0}{\\Delta z} \\right| = k\\left(\\frac{T_s + T_1}{2}\\right) \\frac{T_1 - T_s}{\\Delta z}\n$$\n对于恒定热导率 $k_{\\text{const}} = k(T_s)$ 的参考热通量为：\n$$\nq_{\\text{const}} = \\frac{k_{\\text{const}}(T_m - T_s)}{L}\n$$\n然后相对误差计算如下：\n$$\nE = \\frac{q_{\\text{const}} - q_{\\text{nl}}}{q_{\\text{nl}}}\n$$\n对问题中指定的三个测试案例（A、B、C）重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\n# Define global constants\nT_YR_TO_S = 365.25 * 24.0 * 3600.0\n\ndef solve_case(k0, beta, Ts, Tm, N, kappa, t_myr):\n    \"\"\"\n    Solves the 1D steady-state heat conduction problem for a single parameter set.\n    \n    Args:\n        k0 (float): Thermal conductivity constant (W/m/K).\n        beta (float): Temperature dependence of conductivity (1/K).\n        Ts (float): Surface temperature (K).\n        Tm (float): Mantle temperature (K).\n        N (int): Number of grid points.\n        kappa (float): Thermal diffusivity (m^2/s).\n        t_myr (float): Age of the lithosphere (million years).\n\n    Returns:\n        tuple: A tuple containing q_nl, q_const, and E.\n    \"\"\"\n    # 1. Define physical and numerical parameters\n    t_s = t_myr * 1e6 * T_YR_TO_S\n    L = 2.0 * np.sqrt(kappa * t_s)\n    dz = L / (N - 1.0)\n    num_unknowns = N - 2\n    convergence_tol = 1e-10\n\n    # 2. Define temperature-dependent functions for conductivity\n    def k_func(T):\n        # Handle the case beta=0 to avoid potential division by zero in k_prime if not careful\n        if beta == 0.0:\n            return np.full_like(T, k0)\n        return k0 / (1.0 + beta * T)\n\n    def k_prime_func(T):\n        if beta == 0.0:\n            return np.zeros_like(T)\n        return -beta * k0 / (1.0 + beta * T)**2\n\n    # 3. Initial guess for temperature profile (linear)\n    T = np.linspace(Ts, Tm, N, dtype=np.float64)\n\n    # 4. Newton-Raphson iteration\n    max_iterations = 50 # A safeguard against non-convergence\n    for _ in range(max_iterations):\n        # We solve for the `num_unknowns` interior points T[1]...T[N-2]\n        # The full vector T is T[0]...T[N-1]\n        \n        # Assemble the residual vector R for interior nodes i=1...N-2\n        R = np.zeros(num_unknowns, dtype=np.float64)\n        \n        T_int = T[1:-1]\n        T_plus = T[2:]\n        T_minus = T[:-2]\n        \n        T_mid_right = (T_int + T_plus) / 2.0\n        T_mid_left = (T_minus + T_int) / 2.0\n        \n        k_right = k_func(T_mid_right)\n        k_left = k_func(T_mid_left)\n        \n        R = (k_right * (T_plus - T_int) - k_left * (T_int - T_minus)) / dz**2\n\n        # Check for convergence\n        inf_norm_R = np.max(np.abs(R))\n        if inf_norm_R  convergence_tol:\n            break\n\n        # Assemble the Jacobian matrix J (tridiagonal)\n        # J is (num_unknowns x num_unknowns)\n        J_banded = np.zeros((3, num_unknowns), dtype=np.float64)\n        \n        k_prime_right = k_prime_func(T_mid_right)\n        k_prime_left = k_prime_func(T_mid_left)\n\n        # Main diagonal\n        term1 = 0.5 * k_prime_right * (T_plus - T_int) - k_right\n        term2 = -0.5 * k_prime_left * (T_int - T_minus) - k_left\n        J_banded[1, :] = (term1 + term2) / dz**2\n\n        # Super-diagonal\n        J_banded[0, 1:] = (0.5 * k_prime_right[:-1] * (T_plus[:-1] - T_int[:-1]) + k_right[:-1]) / dz**2\n        \n        # Sub-diagonal\n        J_banded[2, :-1] = (-0.5 * k_prime_left[1:] * (T_int[1:] - T_minus[1:]) + k_left[1:]) / dz**2\n      \n        # Solve the linear system J * delta_T = -R\n        delta_T = solve_banded((1, 1), J_banded, -R)\n        \n        # Update the temperature vector\n        T[1:-1] += delta_T\n\n    # 5. Post-processing and output calculation\n    # Nonlinear heat flux magnitude (upward)\n    T0, T1 = T[0], T[1]\n    q_nl = k_func((T0 + T1) / 2.0) * (T1 - T0) / dz\n    \n    # Constant-conductivity heat flux\n    k_const = k_func(Ts)\n    q_const = k_const * (Tm - Ts) / L\n    \n    # Relative error\n    # Handle the case where q_nl is zero to avoid division by zero\n    if abs(q_nl)  1e-12: # Check for near-zero instead of exact zero\n        E = 0.0 if abs(q_const)  1e-12 else np.inf\n    else:\n        E = (q_const - q_nl) / q_nl\n    \n    return q_nl, q_const, E\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: baseline \"happy path\"\n        {'k0': 3.2, 'beta': 4.0e-4, 'Ts': 273.0, 'Tm': 1573.0, 'N': 101, 'kappa': 1.0e-6, 't_myr': 30.0},\n        # Case B: negligible temperature dependence\n        {'k0': 3.2, 'beta': 0.0, 'Ts': 273.0, 'Tm': 1573.0, 'N': 101, 'kappa': 1.0e-6, 't_myr': 30.0},\n        # Case C: strong temperature dependence and refined grid\n        {'k0': 3.2, 'beta': 1.0e-3, 'Ts': 273.0, 'Tm': 1573.0, 'N': 201, 'kappa': 1.0e-6, 't_myr': 30.0},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        qnl, qconst, E = solve_case(**case_params)\n        results.extend([qnl, qconst, E])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3611187"}, {"introduction": "最后一个练习将理论与实际应用联系起来，展示了如何利用岩石圈力学模型来解释地球物理观测数据。你将模拟一个典型的地球物理反演过程：利用合成的重力和地形数据来估算岩石圈的有效弹性厚度 ($T_e$)，这是衡量岩石圈强度的重要指标。通过这个练习，你将学习到正演模拟、统计反演理论以及如何评估模型参数分辨率等高级概念，这些都是现代地球物理研究的核心技能 [@problem_id:3611244]。", "problem": "您的任务是实现一个独立的程序，使用从具有已知高斯噪声的、基于物理的弯曲模型生成的合成频带平均重力-地形导纳观测数据，对均匀弹性岩石圈板块的有效弹性厚度（EET，记为 $T_e$）进行最大似然反演。然后，您必须使用费雪信息（FI）来量化 $T_e$ 估计值作为波数带函数的分辨率。该情景源于线性板块弯曲和重力位理论，您必须严格遵守下述规范。\n\n本问题的基本基础包括以下经过充分检验和广泛使用的定律和定义：\n- 垂直载荷下的线性弹性板块弯曲：一个抗弯刚度为 $D$ 的薄弹性板块漂浮在密度为 $\\rho_m$ 的流体半空间上，其垂直挠度 $w(x,y)$ 遵循带浮力的双谐波平衡。在谱域中，对于径向波数 $k$（单位：弧度/米），表面载荷 $q_s$ 下的力平衡为\n$$\n\\left(D k^4 + \\rho_m g\\right)\\, w(k) = q_s(k),\n$$\n其中 $g$ 是重力加速度。\n- EET为 $T_e$ 的板块的抗弯刚度为\n$$\nD = \\frac{E T_e^3}{12 \\left(1 - \\nu^2\\right)},\n$$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。\n- 对于振幅为 $h(k)$、岩石密度为 $\\rho_c$ 的地形表面载荷，谱载荷为 $q_s(k) = \\rho_c g\\, h(k)$，相应的挠度为\n$$\nw(k) = \\frac{\\rho_c g}{D k^4 + \\rho_m g}\\, h(k).\n$$\n- 频带平均的自由空气重力-地形导纳 $Z(k;T_e)$（单位地形振幅的重力），假设其贡献来自密度差为 $\\Delta \\rho_t$ 的表面地形和从深度 $z_m$ 向上延拓的、密度差为 $\\Delta \\rho_m$ 的莫霍面起伏，其模型为\n$$\nZ(k;T_e) = 2\\pi G\\left[\\Delta \\rho_t + \\Delta \\rho_m\\, e^{-k z_m}\\, \\frac{\\rho_c g}{D k^4 + \\rho_m g}\\right],\n$$\n其中 $G$ 是万有引力常数。该模型仅假设表面加载、线性响应和小坡度。\n\n您必须执行以下步骤来生成所要求的输出：\n1. 使用指定的单位定义物理常数和参数：\n   - $E = 70\\times 10^9$ 帕斯卡（牛顿/平方米），\n   - $\\nu = 0.25$，\n   - $\\rho_c = 2700$ 千克/立方米，\n   - $\\rho_m = 3300$ 千克/立方米，\n   - $\\Delta \\rho_t = 2700$ 千克/立方米，\n   - $\\Delta \\rho_m = 600$ 千克/立方米，\n   - $g = 9.81$ 米/秒平方，\n   - $G = 6.67430\\times 10^{-11}$ 立方米/千克/秒平方，\n   - $z_m = 35\\times 10^3$ 米。\n2. 对于每个波数带，使用上述公式计算 $Z(k;T_e)$，并通过对在频带内均匀采样的 $k$ 值上的 $Z(k;T_e)$ 进行平均，形成频带平均导纳 $\\mu_j(T_e)$。\n3. 通过计算 $\\mu_j(T_e^\\text{true})$ 并为该频带添加具有已知标准差 $\\sigma_j$ 的零均值高斯噪声，生成合成的频带平均观测值 $\\hat{Z}_j$。\n4. 对每个频带独立地进行 $T_e$ 的最大似然反演，方法是在 $T_e \\in [2, 60]$ 公里的范围内进行一维网格搜索。假设观测模型为高斯模型：\n$$\n\\ln \\mathcal{L}(T_e\\,|\\,\\hat{Z}_j) = -\\frac{1}{2}\\,\\frac{\\left(\\hat{Z}_j - \\mu_j(T_e)\\right)^2}{\\sigma_j^2} + \\text{constant}.\n$$\n返回每个频带的最大似然估计值 $\\widehat{T}_{e,j}$。\n5. 使用单个频带平均观测值的费雪信息来量化每个频带的分辨率：\n$$\n\\mathcal{I}_j(T_e) = \\frac{1}{\\sigma_j^2}\\left(\\frac{\\partial \\mu_j(T_e)}{\\partial T_e}\\right)^2,\n$$\n并计算标准差的克拉美-罗下界为\n$$\n\\sigma_{T_e,j} = \\mathcal{I}_j\\left(\\widehat{T}_{e,j}\\right)^{-1/2}.\n$$\n使用数值稳定的有限差分来近似在 $\\widehat{T}_{e,j}$ 处的导数。\n\n单位：\n- 您必须以公里为单位报告所有的 $T_e$ 值和分辨率值。波数 $k$ 的单位是弧度/米，重力-地形导纳 $Z$ 的单位是反秒平方。\n\n您的程序必须为以下测试用例套件实现上述内容，每个用例包含三个波数带和指定的噪声：\n- 波数带（在 $k$ 上均匀采样）：\n  - 频带1（长波长）：$\\lambda \\in [200\\times 10^3,\\, 500\\times 10^3]$ 米，即 $k \\in \\left[\\frac{2\\pi}{500\\times 10^3},\\, \\frac{2\\pi}{200\\times 10^3}\\right]$ 弧度/米。\n  - 频带2（中波长）：$\\lambda \\in [80\\times 10^3,\\, 200\\times 10^3]$ 米，即 $k \\in \\left[\\frac{2\\pi}{200\\times 10^3},\\, \\frac{2\\pi}{80\\times 10^3}\\right]$ 弧度/米。\n  - 频带3（短波长）：$\\lambda \\in [40\\times 10^3,\\, 80\\times 10^3]$ 米，即 $k \\in \\left[\\frac{2\\pi}{80\\times 10^3},\\, \\frac{2\\pi}{40\\times 10^3}\\right]$ 弧度/米。\n  - 对于每个频带，在 $k$ 上使用 $64$ 个均匀间隔的样本。\n- 测试用例A（理想路径）：$T_e^\\text{true} = 25$ 公里；噪声标准差 $(\\sigma_1, \\sigma_2, \\sigma_3) = (1.0\\times 10^{-8},\\, 1.5\\times 10^{-8},\\, 2.0\\times 10^{-8})$ 反秒平方。\n- 测试用例B（薄板块，低噪声）：$T_e^\\text{true} = 5$ 公里；$(\\sigma_1, \\sigma_2, \\sigma_3) = (1.0\\times 10^{-9},\\, 1.0\\times 10^{-9},\\, 1.0\\times 10^{-9})$ 反秒平方。\n- 测试用例C（厚板块，高噪声）：$T_e^\\text{true} = 50$ 公里；$(\\sigma_1, \\sigma_2, \\sigma_3) = (5.0\\times 10^{-8},\\, 5.0\\times 10^{-8},\\, 5.0\\times 10^{-8})$ 反秒平方。\n\n数值要求：\n- 使用带有固定种子的可复现随机数生成器来创建噪声实现。\n- 使用一个从 $2$ 到 $60$ 公里的 $T_e$ 搜索网格，间距为 $0.1$ 公里。\n- 在最大似然估计处进行导数评估的有限差分步长必须为 $0.1$ 公里，并进行边界安全处理。\n\n最终输出格式：\n- 对于每个测试用例，独立报告一个列表，按顺序包含频带1、2和3的：该频带的最大似然估计值 $\\widehat{T}_{e,j}$（单位：公里）和分辨率 $\\sigma_{T_e,j}$（单位：公里）。将三个测试用例的列表聚合到一个列表中，并以方括号括起来的逗号分隔列表形式单行打印。例如，\n\"[[Te_hat_band1_caseA,res_band1_caseA,Te_hat_band2_caseA,res_band2_caseA,Te_hat_band3_caseA,res_band3_caseA],[...caseB...],[...caseC...]]\"。", "solution": "**1. 理论框架：正演模型**\n\n问题的核心是预测重力-地形导纳 $Z$ 作为波数 $k$ 和有效弹性厚度 $T_e$ 的函数的正演模型。\n\n模型从薄弹性板块的抗弯刚度 $D$ 开始，它量化了板块的抗弯曲能力。对于一个杨氏模量为 $E$、泊松比为 $\\nu$、有效弹性厚度为 $T_e$ 的板块，其抗弯刚度由下式给出：\n$$\nD(T_e) = \\frac{E T_e^3}{12 (1 - \\nu^2)}\n$$\n此处，$T_e$ 以公里为单位提供，但在物理计算中必须转换为米以保持量纲一致性。\n\n当施加表面载荷 $q_s(k)$（在谱域中）时，板块会发生垂直挠曲。这种挠曲由板块内部的弹性应力和下方流体地幔的浮力所平衡。对于一个在重力加速度 $g$ 下漂浮于密度为 $\\rho_m$ 的流体上的板块，其垂直挠度 $w(k)$ 与载荷的关系如下：\n$$\n\\left(D k^4 + \\rho_m g\\right) w(k) = q_s(k)\n$$\n其中 $k$ 是径向波数。此方程表示谱域中的力平衡。\n\n对于振幅为 $h(k)$、密度为 $\\rho_c$ 的表面地形载荷，载荷为 $q_s(k) = \\rho_c g h(k)$。将此代入平衡方程，我们可以求解挠度与地形的比率，该比率代表均衡补偿：\n$$\n\\frac{w(k)}{h(k)} = \\frac{\\rho_c g}{D(T_e) k^4 + \\rho_m g}\n$$\n\n自由空气重力-地形导纳 $Z(k; T_e)$ 是重力异常与地形高度的比值。它源于两个主要来源：表面地形本身的质量和补偿性莫霍面挠度 $w(k)$ 引起的质量亏损。所提供的模型是：\n$$\nZ(k; T_e) = 2\\pi G \\left[ \\Delta \\rho_t + \\Delta \\rho_m e^{-k z_m} \\frac{w(k)}{h(k)} \\right]\n$$\n代入 $w(k)/h(k)$ 的表达式，得到特定波数 $k$ 下导纳的完整正演模型：\n$$\nZ(k; T_e) = 2\\pi G \\left[ \\Delta \\rho_t + \\Delta \\rho_m e^{-k z_m} \\frac{\\rho_c g}{D(T_e) k^4 + \\rho_m g} \\right]\n$$\n其中 $G$ 是万有引力常数，$\\Delta \\rho_t$ 是地形相对于周围介质（空气，因此 $\\Delta \\rho_t = \\rho_c$）的密度差，$\\Delta \\rho_m$ 是穿过莫霍面的密度差，$z_m$ 是莫霍面的平均深度。项 $e^{-k z_m}$ 是向上延拓算子，它解释了从深度 $z_m$ 处的莫霍面到地表的重力信号衰减。\n\n最后，对于每个波数带 $j$，通过对在该频带内均匀采样的 $N_k=64$ 个波数集合上的 $Z(k; T_e)$ 取算术平均值，来计算频带平均导纳 $\\mu_j(T_e)$。\n\n**2. 合成数据生成**\n\n为了测试反演方法，我们首先生成合成的“观测”数据。对于一个给定的测试用例，其具有已知的真实弹性厚度 $T_e^{\\text{true}}$ 和指定的噪声标准差 $(\\sigma_1, \\sigma_2, \\sigma_3)$，我们对每个频带 $j$ 执行以下操作：\n1.  使用上述正演模型计算真实的频带平均导纳 $\\mu_j(T_e^{\\text{true}})$。\n2.  从具有指定标准差 $\\sigma_j$ 的零均值高斯（正态）分布中生成一个随机数。这是通过使用带种子的随机数生成器来实现的，以确保可复现性。\n3.  那么，频带 $j$ 的合成观测值就是 $\\hat{Z_j} = \\mu_j(T_e^{\\text{true}}) + \\text{noise}$。\n\n**3. $T_e$ 的最大似然估计**\n\n目标是找到能最好地解释合成观测值 $\\hat{Z_j}$ 的 $T_e$ 值。假设噪声是高斯的，给定模型参数 $T_e$ 的情况下观测到 $\\hat{Z_j}$ 的似然性为：\n$$\n\\mathcal{L}(T_e | \\hat{Z_j}) \\propto \\exp\\left(-\\frac{1}{2}\\frac{(\\hat{Z_j} - \\mu_j(T_e))^2}{\\sigma_j^2}\\right)\n$$\n最大化似然 $\\mathcal{L}$（或其对数 $\\ln\\mathcal{L}$）等价于最小化残差平方项 $R(T_e) = (\\hat{Z_j} - \\mu_j(T_e))^2$。\n\n我们使用一维网格搜索来执行此最小化过程。创建一个候选 $T_e$ 值的网格，范围从 $2$ 到 $60$ 公里，步长为 $0.1$ 公里。对于每个频带 $j$，我们计算该网格上每个 $T_e$ 的模型预测值 $\\mu_j(T_e)$。然后，我们计算每个网格点的残差平方，并找出产生最小残差的 $T_e$ 值。这个值就是我们的最大似然估计值 $\\widehat{T}_{e,j}$。\n\n**4. 通过费雪信息进行分辨率分析**\n\n我们的估计值 $\\widehat{T}_{e,j}$ 的分辨率量化了数据对参数的约束程度。高分辨率（低不确定性）意味着 $T_e$ 的微小变化会引起预测导纳的较大变化，使得参数易于确定。我们使用费雪信息 $\\mathcal{I}_j(T_e)$ 来量化这一点。对于单个高斯观测，其定义为：\n$$\n\\mathcal{I}_j(T_e) = \\left( \\frac{\\partial \\mu_j(T_e)}{\\partial T_e} \\right)^2 \\frac{1}{\\sigma_j^2}\n$$\n导数 $\\frac{\\partial \\mu_j(T_e)}{\\partial T_e}$ 衡量模型对 $T_e$ 变化的敏感度。\n\n克拉美-罗下界（CRLB）指出，任何对 $T_e$ 的无偏估计量的方差至少是费雪信息的倒数。我们使用 CRLB 导出的标准差作为我们的分辨率度量：\n$$\n\\sigma_{T_e,j} = \\sqrt{\\text{Var}(\\widehat{T}_{e,j})} \\ge \\mathcal{I}_j(T_e)^{-1/2}\n$$\n我们在我们的估计值 $\\widehat{T}_{e,j}$ 处计算这个界限：$\\sigma_{T_e,j} = \\mathcal{I}_j(\\widehat{T}_{e,j})^{-1/2}$。\n\n导数 $\\frac{\\partial \\mu_j}{\\partial T_e}$ 使用有限差分格式进行数值计算。由于我们已经在一个规则网格上计算了模型 $\\mu_j(T_e)$，并且指定的有限差分步长（$0.1$ 公里）与网格间距相匹配，因此我们可以使用其邻近点高效地近似对应于 $\\widehat{T}_{e,j}$ 的网格点处的导数。对内部点使用中心差分，而在网格边界处使用前向或后向差分以确保稳定性。使用的是关于 $T_e$（以公里为单位）的导数，因此得到的分辨率 $\\sigma_{T_e,j}$ 也以公里为单位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs maximum likelihood inversion for Effective Elastic Thickness (EET)\n    and quantifies resolution using Fisher Information.\n    \"\"\"\n\n    # 1. Define physical constants and parameters in SI units\n    CONSTANTS = {\n        'E': 70e9,             # Young's modulus (Pa)\n        'nu': 0.25,            # Poisson's ratio\n        'rho_c': 2700.,        # Crust/load density (kg/m^3)\n        'rho_m': 3300.,        # Mantle density (kg/m^3)\n        'Delta_rho_t': 2700.,  # Topography density contrast (kg/m^3)\n        'Delta_rho_m': 600.,   # Moho density contrast (kg/m^3)\n        'g': 9.81,             # Gravitational acceleration (m/s^2)\n        'G': 6.67430e-11,      # Gravitational constant (m^3/kg/s^2)\n        'z_m': 35e3,           # Mean Moho depth (m)\n    }\n\n    # Define wavenumber bands and test cases\n    BANDS = [\n        (2 * np.pi / 500e3, 2 * np.pi / 200e3),  # Band 1: 200-500 km wavelength\n        (2 * np.pi / 200e3, 2 * np.pi / 80e3),   # Band 2: 80-200 km wavelength\n        (2 * np.pi / 80e3, 2 * np.pi / 40e3),    # Band 3: 40-80 km wavelength\n    ]\n    N_K_SAMPLES = 64\n\n    TEST_CASES = {\n        'A': {'Te_true_km': 25.0, 'sigmas': (1.0e-8, 1.5e-8, 2.0e-8)},\n        'B': {'Te_true_km': 5.0,  'sigmas': (1.0e-9, 1.0e-9, 1.0e-9)},\n        'C': {'Te_true_km': 50.0, 'sigmas': (5.0e-8, 5.0e-8, 5.0e-8)},\n    }\n    \n    # Numerical parameters for inversion\n    TE_GRID_KM = np.linspace(2.0, 60.0, int((60.0 - 2.0) / 0.1) + 1)\n    FD_STEP_KM = 0.1\n\n    # Initialize a reproducible random number generator\n    RNG = np.random.default_rng(seed=42)\n\n    def calculate_band_mean_admittance(k_range, Te_km, n_samples, consts):\n        \"\"\"\n        Computes the band-averaged gravity-topography admittance for a given Te.\n        \"\"\"\n        Te_m = Te_km * 1000.0  # Convert Te from km to m\n        _E, _nu, _rho_c, _rho_m, _Delta_rho_t, _Delta_rho_m, _g, _G, _z_m = (\n            consts['E'], consts['nu'], consts['rho_c'], consts['rho_m'],\n            consts['Delta_rho_t'], consts['Delta_rho_m'], consts['g'], \n            consts['G'], consts['z_m']\n        )\n\n        # Flexural rigidity D\n        D = (_E * Te_m**3) / (12 * (1 - _nu**2))\n\n        # Wavenumber samples for the band\n        k_vec = np.linspace(k_range[0], k_range[1], n_samples)\n        \n        # Admittance model Z(k; Te)\n        flexure_term = (_rho_c * _g) / (D * k_vec**4 + _rho_m * _g)\n        Z_k = 2 * np.pi * _G * (_Delta_rho_t + _Delta_rho_m * np.exp(-k_vec * _z_m) * flexure_term)\n\n        # Band-averaged admittance mu\n        return np.mean(Z_k)\n\n    all_results = []\n    \n    for case_id in ['A', 'B', 'C']:\n        case = TEST_CASES[case_id]\n        Te_true_km = case['Te_true_km']\n        sigmas = case['sigmas']\n        \n        case_results = []\n        \n        for band_idx, (k_range, sigma_j) in enumerate(zip(BANDS, sigmas)):\n            \n            # --- Generate Synthetic Data ---\n            mu_true = calculate_band_mean_admittance(k_range, Te_true_km, N_K_SAMPLES, CONSTANTS)\n            noise = RNG.normal(loc=0.0, scale=sigma_j)\n            Z_hat_j = mu_true + noise\n\n            # --- Maximum Likelihood Inversion (Grid Search) ---\n            mu_grid = np.array([\n                calculate_band_mean_admittance(k_range, te, N_K_SAMPLES, CONSTANTS) for te in TE_GRID_KM\n            ])\n            \n            residuals_sq = (Z_hat_j - mu_grid)**2\n            best_idx = np.argmin(residuals_sq)\n            Te_hat_km = TE_GRID_KM[best_idx]\n\n            # --- Quantify Resolution using Fisher Information ---\n            # Use pre-computed grid for efficient finite difference\n            if best_idx == 0:  # Forward difference at lower boundary\n                dmu_dTe = (mu_grid[1] - mu_grid[0]) / FD_STEP_KM\n            elif best_idx == len(TE_GRID_KM) - 1:  # Backward difference at upper boundary\n                dmu_dTe = (mu_grid[best_idx] - mu_grid[best_idx - 1]) / FD_STEP_KM\n            else:  # Central difference for interior points\n                dmu_dTe = (mu_grid[best_idx + 1] - mu_grid[best_idx - 1]) / (2 * FD_STEP_KM)\n\n            fisher_info = (dmu_dTe**2) / (sigma_j**2)\n\n            if fisher_info > 1e-30: # Avoid division by zero for flat likelihoods\n                resolution_km = 1.0 / np.sqrt(fisher_info)\n            else:\n                resolution_km = np.inf # Unconstrained\n\n            case_results.extend([Te_hat_km, resolution_km])\n            \n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    case_strs = []\n    for res_list in all_results:\n        # Using repr to get good precision without scientific notation for these numbers\n        case_strs.append(f\"[{','.join(map(repr, res_list))}]\")\n    print(f\"[{','.join(case_strs)}]\")\n\nsolve()\n```", "id": "3611244"}]}