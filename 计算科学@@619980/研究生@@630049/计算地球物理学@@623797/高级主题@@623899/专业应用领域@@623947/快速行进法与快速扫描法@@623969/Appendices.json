{"hands_on_practices": [{"introduction": "在将任何数值算法应用于复杂问题之前，首要步骤是验证其正确性和实现。收敛性研究是验证数值偏微分方程求解器的黄金标准。通过在已知解析解的简单情况下运行求解器，并在逐步加密的网格上将数值结果与精确解进行比较，我们可以实证地测量该方法的收敛阶，并确认其与理论预测相符。这个实践练习 [@problem_id:3591153] 将指导您完成这一基本过程，为您的一阶程函方程求解器建立坚实的基础。", "problem": "考虑各项同性介质中首波走时的二维程函方程，该偏微分方程由下式给出\n$$\\lvert \\nabla T(\\mathbf{x}) \\rvert = s,$$\n其中 $T(\\mathbf{x})$ 是以秒为单位的走时场，$\\mathbf{x} = (x,y)$ 是以米为单位的位置，而 $s$ 是单位为秒/米的常慢度。在以米为单位的矩形域 $[0,1]\\times[0,1]$ 上，考虑一个位于中心 $(x_s,y_s) = (0.5,0.5)$ 米的点源，其边界条件为 $T(x_s,y_s) = 0$ 秒。对于常数 $s$，其在连续域上的解析解为\n$$T(x,y) = s \\sqrt{(x-x_s)^2 + (y-y_s)^2}.$$\n\n您的任务是使用程函方程的一阶单调迎风离散化方法建立一个网格加密研究，并针对几个不同的慢度值，在误差范数 $\\lVert T_h - T \\rVert$ 与网格间距 $h$ 的对数-对数图中，计算经验收敛斜率。这里，$T_h$ 表示在间距为 $h$ 的均匀笛卡尔网格上计算出的数值解，$T$ 表示解析解。请使用适用于一阶格式的求解器（例如，快速行进法或快速扫描法），该求解器需与单调迎风离散化方法一致，并能产生因果解。\n\n基本依据和要求：\n- 使用由程函方程 $\\lvert \\nabla T \\rvert = s$（其中 $s$ 为常数）和狄利克雷数据 $T(x_s,y_s)=0$ 控制的各项同性介质中的走时定义。\n- 在间距为 $h$ 米的均匀网格上使用经过充分测试的一阶 Godunov 迎风离散化方法。在网格节点 $(i,j)$ 处，离散走时 $T_{i,j}$ 的局部更新必须通过求解一个二次方程来获得，该方程使用坐标方向上最小的迎风邻居值来强制执行离散的程函方程条件。具体来说，如果 $a$ 是 $x$ 方向上两个邻居中的最小值，$b$ 是 $y$ 方向上两个邻居中的最小值，则更新值 $U$ 满足以下方程\n$$\\left(\\max\\left(\\frac{U-a}{h},0\\right)\\right)^2 + \\left(\\max\\left(\\frac{U-b}{h},0\\right)\\right)^2 = s^2,$$\n并满足可采纳条件 $U \\ge \\max(a,b)$。这给出了封闭形式的更新公式\n$$\nU =\n\\begin{cases}\n\\min(a,b) + h s,  \\text{if } \\lvert a-b \\rvert \\ge h s, \\\\\n\\dfrac{a+b + \\sqrt{2(h s)^2 - (a-b)^2}}{2},  \\text{otherwise}.\n\\end{cases}\n$$\n- 数值解必须以秒为单位计算。网格间距必须以米为单位。慢度必须以秒/米为单位。\n- 为了在远离点源奇点处分离出渐近阶，计算误差范数时应排除源点周围半径为 $2h$ 的小圆盘区域。也就是说，只包括那些与 $(x_s,y_s)$ 的欧几里得距离严格大于 $2h$ 的节点。\n\n误差范数和收敛斜率：\n- 对于给定的网格间距 $h$，计算离散 $L^2$ 误差\n$$\\lVert T_h - T \\rVert_{2,h} = \\sqrt{ h^2 \\sum_{i,j} \\left(T_{i,j} - T(x_i,y_j)\\right)^2 },$$\n和离散 $L^\\infty$ 误差\n$$\\lVert T_h - T \\rVert_{\\infty,h} = \\max_{i,j} \\lvert T_{i,j} - T(x_i,y_j)\\rvert,$$\n其中，求和与求最大值操作仅在以 $(x_s,y_s)$ 为中心、半径为 $2h$ 的排除圆盘区域之外的网格节点上进行。\n- 对于一组网格间距 $\\{h_k\\}$，使用最小二乘法对数据点 $\\left(\\log_{10} h_k, \\log_{10} \\lVert T_h - T \\rVert\\right)$ 进行直线拟合，以获得每种范数的经验斜率。一个一阶格式预期会产生接近于 1 的斜率。\n\n测试套件和最终输出：\n- 使用以下慢度值（单位为秒/米）：$s \\in \\{0.75, 1.5, 3.0\\}$。\n- 对于每个 $s$，使用均匀网格，每个维度的节点数为 $N \\in \\{33, 65, 129, 257\\}$。网格间距为 $h = 1/(N-1)$ 米。\n- 对于每个 $s$，基于四个网格级别计算 $L^2$ 误差和 $L^\\infty$ 误差的经验斜率。\n- 您的程序应生成单行输出，其中包含六个结果，以逗号分隔的列表形式并用方括号括起，顺序如下\n$$[\\text{slope}_{L^2}(s{=}0.75), \\text{slope}_{L^\\infty}(s{=}0.75), \\text{slope}_{L^2}(s{=}1.5), \\text{slope}_{L^\\infty}(s{=}1.5), \\text{slope}_{L^2}(s{=}3.0), \\text{slope}_{L^\\infty}(s{=}3.0)].$$\n所有数字必须以十进制数打印（输出行中不含单位），并由程序自行决定舍入方式。在内部，请确保所有走时以秒为单位，所有距离以米为单位，所有慢度值以秒/米为单位。", "solution": "该问题要求进行一次网格加密研究，以确定二维程函方程一阶数值解的经验收敛阶。该问题在科学上和数学上是适定的，提供了所有必要的组成部分：控制性偏微分方程、一个具有解析解的特定案例、数值离散格式、误差度量以及研究参数。\n\n物理问题是在一个慢度为常数 $s$ 的介质中，求解从一个点源发出的波的首波走时 $T(\\mathbf{x})$。该问题由定义域 $\\mathbf{x} = (x,y) \\in [0,1] \\times [0,1]$ 米上的程函方程 $\\lvert \\nabla T(\\mathbf{x}) \\rvert = s$ 控制。给定一个位于 $(x_s, y_s) = (0.5, 0.5)$ 米的点源，其走时定义为零，即 $T(x_s, y_s) = 0$ 秒，那么在连续域上的解析解为 $T(x,y) = s \\sqrt{(x-x_s)^2 + (y-y_s)^2}$ 秒。\n\n为了数值求解该方程，我们采用指定的一阶 Godunov 迎风有限差分格式。该格式将区域离散化为间距为 $h$ 的均匀笛卡尔网格，并在每个网格节点 $(i,j)$ 处近似程函方程。走时 $T_{i,j}$ 根据其迎风邻居的走时进行更新，即波前到达的邻居。问题提供了节点更新走时 $U$ 的正确封闭解，该解由离散化梯度算子产生的二次方程导出：\n$$\nU =\n\\begin{cases}\n\\min(a,b) + h s,  \\text{if } \\lvert a-b \\rvert \\ge h s, \\\\\n\\dfrac{a+b + \\sqrt{2(h s)^2 - (a-b)^2}}{2},  \\text{otherwise},\n\\end{cases}\n$$\n其中 $a$ 和 $b$ 分别是 $x$ 和 $y$ 方向上邻居中的最小走时。这个非线性方程组需要专门的求解器。\n\n选择快速行进法（FMM）作为求解离散系统的算法。FMM 是一种高效的单遍算法，它通过按走时递增的顺序传播波前，正确地捕捉到粘性解，这类似于图上的 Dijkstra 算法。该方法通过维护三组网格点来运行：`KNOWN`（其最终走时已计算出的点）、`TRIAL`（代表当前波前的、邻近已知区域的窄带点）和 `FAR`（所有其他点）。一个最小优先队列管理 `TRIAL` 点。算法迭代过程如下：\n1. 初始化走时网格，除源点 $T(x_s, y_s) = 0$ 外，所有点的值均为 $\\infty$。将源点添加到优先队列中。\n2. 当优先队列不为空时，取出具有最小走时的 `TRIAL` 点。\n3. 将此点从 `TRIAL` 集合移动到 `KNOWN` 集合。\n4. 对于这个新加入 `KNOWN` 集合的点的每个邻居，使用 Godunov 更新公式计算一个潜在的新走时。如果这个新时间小于邻居的当前时间，则更新邻居的时间，并将其添加到队列中（或更新其在队列中的优先级）。\n\n对于收敛性研究，此 FMM 求解器将在一个包含四个网格（每边节点数 $N \\in \\{33, 65, 129, 257\\}$）的序列上，针对每个指定的慢度 $s \\in \\{0.75, 1.5, 3.0\\}$ 秒/米 执行。网格间距为 $h = 1/(N-1)$ 米。在每个网格上计算出数值解 $T_h$ 后，我们通过将其与解析解 $T$ 进行比较来计算误差。离散 $L^2$ 和 $L^\\infty$ 误差范数按规定计算：\n$$ \\lVert T_h - T \\rVert_{2,h} = \\sqrt{ h^2 \\sum_{i,j} \\left(T_{i,j} - T(x_i,y_j)\\right)^2 }, \\quad \\lVert T_h - T \\rVert_{\\infty,h} = \\max_{i,j} \\lvert T_{i,j} - T(x_i,y_j)\\rvert. $$\n关键的是，求和与求最大值的操作仅在以源点为中心、半径为 $2h$ 的圆盘区域之外的网格点上进行。这排除了点源奇点周围的区域，在该区域解析解不可微，且数值误差不遵循格式的渐近行为，因此可以清晰地测量收敛率。\n\n最后，对于每个慢度 $s$ 和每种误差范数，通过对四个数据点 $(\\log_{10} h_k, \\log_{10} \\text{error}_k)$ 进行线性最小二乘回归，由最佳拟合线的斜率确定经验收敛阶。对于一阶格式，该斜率预期接近于 1。该实现将计算这六个斜率，并将其格式化为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to perform the grid-refinement study and compute convergence slopes.\n    \"\"\"\n    \n    def godunov_update(a, b, h, s):\n        \"\"\"\n        Computes the travel time update using the first-order Godunov scheme.\n        a: min travel time in x-direction\n        b: min travel time in y-direction\n        h: grid spacing\n        s: slowness\n        \"\"\"\n        hs = h * s\n        # This handles the case where one or both of a, b are np.inf\n        # abs(np.inf - finite) is np.inf, correctly triggering the 1D update\n        if np.abs(a - b) >= hs:\n            return min(a, b) + hs\n        else:\n            # This case requires both a and b to be finite\n            term_under_sqrt = 2 * (hs**2) - (a - b)**2\n            # A numerically robust check to prevent sqrt of small negative number\n            if term_under_sqrt < 0:\n                return min(a, b) + hs\n            return (a + b + np.sqrt(term_under_sqrt)) / 2\n\n    def run_fmm(N, h, s):\n        \"\"\"\n        Solves the Eikonal equation using the Fast Marching Method.\n        \"\"\"\n        # Constants for node states\n        KNOWN = 2\n        TRIAL = 1\n        FAR = 0\n        \n        T = np.full((N, N), np.inf, dtype=np.float64)\n        states = np.full((N, N), FAR, dtype=np.int8)\n        \n        # Source setup\n        source_idx = (N - 1) // 2\n        isrc, jsrc = source_idx, source_idx\n        T[isrc, jsrc] = 0.0\n        \n        trial_heap = [(0.0, isrc, jsrc)]\n        \n        while trial_heap:\n            t, i, j = heapq.heappop(trial_heap)\n            \n            if states[i, j] == KNOWN:\n                continue\n                \n            states[i, j] = KNOWN\n            \n            # Update neighbors\n            for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if not (0 <= ni < N and 0 <= nj < N):\n                    continue\n                \n                if states[ni, nj] == KNOWN:\n                    continue\n\n                t_x1 = T[ni - 1, nj] if ni > 0 else np.inf\n                t_x2 = T[ni + 1, nj] if ni < N - 1 else np.inf\n                a = min(t_x1, t_x2)\n\n                t_y1 = T[ni, nj - 1] if nj > 0 else np.inf\n                t_y2 = T[ni, nj + 1] if nj < N - 1 else np.inf\n                b = min(t_y1, t_y2)\n                \n                if a == np.inf and b == np.inf:\n                    continue\n\n                U = godunov_update(a, b, h, s)\n\n                if U < T[ni, nj]:\n                    T[ni, nj] = U\n                    states[ni, nj] = TRIAL\n                    heapq.heappush(trial_heap, (U, ni, nj))\n                    \n        return T\n\n    def calculate_analytical(N, h, s, source_pos):\n        \"\"\"\n        Computes the analytical solution on the grid.\n        \"\"\"\n        grid_coords = np.linspace(0.0, 1.0, N)\n        xx, yy = np.meshgrid(grid_coords, grid_coords, indexing='ij')\n        xs, ys = source_pos\n        T_exact = s * np.sqrt((xx - xs)**2 + (yy - ys)**2)\n        return T_exact\n\n    def calculate_errors(T_h, T_exact, N, h, source_pos):\n        \"\"\"\n        Computes L2 and Linf errors, excluding a disk of radius 2h around the source.\n        \"\"\"\n        exclusion_radius = 2.0 * h\n        xs, ys = source_pos\n        \n        sum_sq_err = 0.0\n        max_abs_err = 0.0\n        \n        grid_coords = np.linspace(0.0, 1.0, N)\n        \n        for i in range(N):\n            for j in range(N):\n                xi, yj = grid_coords[i], grid_coords[j]\n                dist_from_source = np.sqrt((xi - xs)**2 + (yj - ys)**2)\n                \n                if dist_from_source > exclusion_radius:\n                    abs_err = np.abs(T_h[i, j] - T_exact[i, j])\n                    sum_sq_err += abs_err**2\n                    if abs_err > max_abs_err:\n                        max_abs_err = abs_err\n        \n        l2_err = np.sqrt(h**2 * sum_sq_err)\n        linf_err = max_abs_err\n        \n        return l2_err, linf_err\n\n    # --- Main Execution Logic ---\n    s_values = [0.75, 1.5, 3.0]\n    N_values = [33, 65, 129, 257]\n    source_pos = (0.5, 0.5)\n    \n    all_slopes = []\n\n    for s in s_values:\n        log_h_vals = []\n        log_l2_errors = []\n        log_linf_errors = []\n\n        for N in N_values:\n            h = 1.0 / (N - 1)\n            \n            T_h = run_fmm(N, h, s)\n            T_exact = calculate_analytical(N, h, s, source_pos)\n            \n            l2_err, linf_err = calculate_errors(T_h, T_exact, N, h, source_pos)\n            \n            if l2_err > 0 and linf_err > 0:\n                log_h_vals.append(np.log10(h))\n                log_l2_errors.append(np.log10(l2_err))\n                log_linf_errors.append(np.log10(linf_err))\n\n        # Perform linear regression to find the slope (order of convergence)\n        # using numpy.polyfit for least-squares\n        if len(log_h_vals) > 1:\n            slope_l2 = np.polyfit(log_h_vals, log_l2_errors, 1)[0]\n            slope_linf = np.polyfit(log_h_vals, log_linf_errors, 1)[0]\n            all_slopes.extend([slope_l2, slope_linf])\n        else:\n            # Handle case where not enough data points were collected\n            all_slopes.extend([np.nan, np.nan])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_slopes))}]\")\n\nsolve()\n```", "id": "3591153"}, {"introduction": "虽然我们验证过的基本求解器在远离源点的区域表现良好，但它在点源本身的奇异性附近会遇到精度问题，因为在该点，走时场的梯度是未定义的。为了解决这个问题，我们可以采用一种称为“分解法” (factoring method) 的先进技术，它将解分解为一个解析已知的奇异部分和一个行为良好的数值校正项。这项实践 [@problem_id:3591136] 将带您实现这种可加分解法，通过将奇异性进行解析处理，从而显著提高点源附近的数值精度。", "problem": "您需要实现并比较两种用于二维空间中各向同性程函方程的一阶数值方法，以及它们用于减小点源奇点的加性分解变体。这些方法是快速行进法 (Fast Marching Method, FMM) 和快速扫描法 (Fast Sweeping Method, FSM)。您的程序必须是一个完整、可运行的 Python 脚本，用于在存在闭式解的均匀介质中计算定量的误差减小度量。\n\n基本原理：\n- 在波速为 $c(\\mathbf{x})$ 的介质中，走时 $T(\\mathbf{x})$ 的各向同性程函方程为\n$$ \\|\\nabla T(\\mathbf{x})\\| = \\frac{1}{c(\\mathbf{x})}, \\quad \\mathbf{x} \\in \\Omega \\subset \\mathbb{R}^2, $$\n服从于源点位置 $\\mathbf{x}_s$ 处的点源边界条件 $T(\\mathbf{x}_s) = 0$。\n- 对于波速恒为 $c_0$ 的均匀介质，精确的点源解为\n$$ T_0(\\mathbf{x}) = \\frac{\\|\\mathbf{x} - \\mathbf{x}_s\\|}{c_0}. $$\n\n离散化基础：\n- 在两个空间方向上使用间距为 $h$ (单位：米) 的均匀笛卡尔网格。设网格为 $N \\times N$，索引为 $i,j \\in \\{0,\\dots,N-1\\}$。源点位于与物理坐标 $\\mathbf{x}_s$ 对应的中心网格点 $(i_s, j_s)$。\n- 对各向同性程函方程应用标准的迎风 Godunov 离散化。对于网格节点 $(i,j)$，使用 $x$ 方向的最小值 $a = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $y$ 方向的最小值 $b = \\min(T_{i,j-1}, T_{i,j+1})$，则 $T_{i,j}$ 的局部更新值 $t^\\star$ 满足以下二次条件\n$$ \\left( \\max\\left( \\frac{t^\\star - a}{h}, 0 \\right) \\right)^2 + \\left( \\max\\left( \\frac{t^\\star - b}{h}, 0 \\right) \\right)^2 = \\left(\\frac{1}{c_{i,j}}\\right)^2, $$\n其中 $c_{i,j} = c_0$。使用与迎风因果性一致的最小非负可行解。\n- 在加性分解格式中，记 $T(\\mathbf{x}) = T_0(\\mathbf{x}) + \\tau(\\mathbf{x})$，其中 $T_0(\\mathbf{x})$ 是上述的均匀介质精确解，而 $\\tau(\\mathbf{x})$ 满足\n$$ \\|\\nabla \\tau(\\mathbf{x}) + \\nabla T_0(\\mathbf{x})\\| = \\frac{1}{c(\\mathbf{x})}. $$\n同样应用 Godunov 离散化原理，但这次是应用于 $\\tau$。在网格节点 $(i,j)$ 处，$\\tau_{i,j}$ 的局部更新使用移位的邻近量\n$$ a_\\tau = \\min\\left( \\tau_{i-1,j} + T_{0,i-1,j} - T_{0,i,j}, \\ \\tau_{i+1,j} + T_{0,i+1,j} - T_{0,i,j} \\right), $$\n$$ b_\\tau = \\min\\left( \\tau_{i,j-1} + T_{0,i,j-1} - T_{0,i,j}, \\ \\tau_{i,j+1} + T_{0,i,j+1} - T_{0,i,j} \\right), $$\n并使用与未分解情况相同的二次条件，但用 $a_\\tau$ 和 $b_\\tau$ 替换 $a$ 和 $b$。这通过精确计算 $T_0$ 的离散增量来实现加性分解。\n\n算法基础：\n- 快速行进法 (FMM) 是一种类似于 Dijkstra 算法的标签设置法，它对“试探”节点使用一个以当前 $T$ 值作为键值的最小堆（优先队列）。节点根据最小的 $T$ 值从“未知”过渡到“试探”，再到“接受”。每当一个节点被接受，其紧邻的邻居节点就使用上述局部二次公式进行更新。对于加性分解 FMM，您必须维护 $\\tau$ 值，并使用移位的邻近量来计算总走时 $T = \\tau + T_0$ 的更新，但堆的排序和接受测试始终基于总走时 $T$。\n- 快速扫描法 (FSM) 是一种 Gauss–Seidel 不动点迭代法，它对网格的四种交替扫描顺序（例如，沿四个对角线方向的字典序）进行迭代。在每个网格节点（源点固定不变），FSM 使用当前的邻居节点值应用局部二次更新。对于加性分解 FSM，$\\tau$ 使用上述移位的邻近量进行更新，并推导出总走时 $T = \\tau + T_0$ 以评估误差。\n\n科学真实性与单位：\n- 恒定波速使用 $c_0 = 2000$ m/s。\n- 在 $x$ 和 $y$ 方向上均使用网格间距 $h = 10$ m。\n- 计算域为边长 $L = h (N-1)$ m 的正方形，源点位于几何中心。\n- 所有走时输出和误差必须以秒为单位表示。\n\n任务：\n1. 在均匀介质的二维网格上，为程函方程实现标准 FMM（未分解）和加性分解 FMM。\n2. 为同一问题实现标准 FSM（未分解）和加性分解 FSM。\n3. 对于每个计算出的走时场 $T_{ij}$，计算相对于均匀介质精确解 $T_0(\\mathbf{x}_{ij})$ 的均方根误差 (RMSE)：\n$$ \\mathrm{RMSE} = \\sqrt{ \\frac{1}{N^2} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left( T_{ij} - T_0(\\mathbf{x}_{ij}) \\right)^2 }. $$\nRMSE 必须以秒为单位报告。\n\n测试套件与输出规范：\n- 测试套件包含四种情况，用于探测方法类型和网格分辨率：\n  - 情况 1：快速行进法，粗网格 $N=21$。\n  - 情况 2：快速行进法，细网格 $N=101$。\n  - 情况 3：快速扫描法，粗网格 $N=21$。\n  - 情况 4：快速扫描法，细网格 $N=101$。\n- 对于每种情况，计算标准求解器的 RMSE ($\\mathrm{RMSE}_\\mathrm{std}$) 和加性分解求解器的 RMSE ($\\mathrm{RMSE}_\\mathrm{fact}$)，然后计算误差减小因子\n$$ R = \\frac{\\mathrm{RMSE}_\\mathrm{std}}{\\max(\\mathrm{RMSE}_\\mathrm{fact}, 10^{-12})}. $$\n更大的 $R$ 值表示加性分解对奇点引起的误差减小得更多。\n- 最终输出格式：您的程序应生成单行输出，其中包含四个情况下四个减小因子的逗号分隔列表，并用方括号括起，顺序必须为 [情况1, 情况2, 情况3, 情况4]。例如：\"[r1,r2,r3,r4]\"。", "solution": "该问题要求实现并比较两种用于求解二维各向同性程函方程的一阶数值方法：快速行进法 (FMM) 和快速扫描法 (FSM)。对于每种方法，我们必须实现一个标准版本和一个旨在提高点源附近精度的加性分解版本。比较的依据是在已知精确解析解的均匀介质中，均方根误差 (RMSE) 的减小情况。\n\n首先，我们建立数学和数值框架。各向同性程函方程是一个非线性偏微分方程，描述了波前的走时 $T(\\mathbf{x})$：\n$$ \\|\\nabla T(\\mathbf{x})\\| = \\frac{1}{c(\\mathbf{x})} $$\n这里，$\\mathbf{x}$ 是域 $\\Omega \\subset \\mathbb{R}^2$ 中的一个点，$c(\\mathbf{x})$ 是波速。给定一个源点位置 $\\mathbf{x}_s$ 处的点源条件 $T(\\mathbf{x}_s) = 0$。对于 $c(\\mathbf{x}) = c_0$ 的均匀介质特例，精确解是到源点的距离乘以慢度 ($1/c_0$)：\n$$ T_0(\\mathbf{x}) = \\frac{\\|\\mathbf{x} - \\mathbf{x}_s\\|}{c_0} $$\n该解在 $\\mathbf{x}_s$ 处有一个锥形奇点，其梯度在此处未定义。这个奇点对标准数值格式构成了挑战。\n\n该域被离散化为一个大小为 $N \\times N$、网格间距为 $h$ 的均匀笛卡尔网格。网格节点由 $(i,j)$ 索引。标准的一阶 Godunov 迎风有限差分格式近似了梯度的大小。为了更新网格节点 $(i,j)$ 处的走时 $T_{i,j}$，我们定义邻居值 $a = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $b = \\min(T_{i,j-1}, T_{i,j+1})$。更新后的走时 $t^\\star$ 是二次方程的最小非负解：\n$$ \\left( \\max\\left( \\frac{t^\\star - a}{h}, 0 \\right) \\right)^2 + \\left( \\max\\left( \\frac{t^\\star - b}{h}, 0 \\right) \\right)^2 = s_{i,j}^2 $$\n其中 $s_{i,j} = 1/c_{i,j}$ 是慢度。对于常数慢度 $s_0 = 1/c_0$，解 $t^\\star$ 由下式给出：\n$$ t^\\star = \\begin{cases} \\min(a, b) + h s_0  \\text{若 } |a-b| \\ge h s_0 \\\\ \\frac{a+b + \\sqrt{2(h s_0)^2 - (a-b)^2}}{2}  \\text{若 } |a-b| < h s_0 \\end{cases} $$\n这个更新规则是因果的，只使用走时较小（迎风）方向的信息。\n\n加性分解方法旨在减轻源点奇点带来的误差。它通过将总走时 $T(\\mathbf{x})$ 写成已知奇异解 $T_0(\\mathbf{x})$ 和一个校正项 $\\tau(\\mathbf{x})$ 的和来重新表述问题：$T(\\mathbf{x}) = T_0(\\mathbf{x}) + \\tau(\\mathbf{x})$。将此代入程函方程，得到一个关于 $\\tau(\\mathbf{x})$ 的方程：\n$$ \\|\\nabla \\tau(\\mathbf{x}) + \\nabla T_0(\\mathbf{x})\\| = s(\\mathbf{x}) $$\n在离散层面，这通过应用相同的 Godunov 更新逻辑来处理，但对象是 $\\tau_{i,j}$ 而非 $T_{i,j}$。邻居值被修改以包含已知的解析解 $T_0$。移位的邻居值为：\n$$ a_\\tau = \\min\\left( \\tau_{i-1,j} + T_{0,i-1,j} - T_{0,i,j}, \\ \\tau_{i+1,j} + T_{0,i+1,j} - T_{0,i,j} \\right) $$\n$$ b_\\tau = \\min\\left( \\tau_{i,j-1} + T_{0,i,j-1} - T_{0,i,j}, \\ \\tau_{i,j+1} + T_{0,i,j+1} - T_{0,i,j} \\right) $$\n然后使用相同的二次更新公式，以 $a_\\tau$ 和 $b_\\tau$ 作为输入来计算新的 $\\tau_{i,j}$。由于 $\\tau(\\mathbf{x})$ 在源点附近的平滑度通常远高于 $T(\\mathbf{x})$，该方法能产生更精确的数值解。\n\n用于求解所得方程组的两种算法是：\n\n$1$. **快速行进法 (FMM)**：这是一种标签设置算法，类似于 Dijkstra 算法。网格节点被分为三类：`ACCEPTED`（走时已最终确定）、`TRIAL`（具有临时的走时值）和 `UNKNOWN`（未知）。该算法维护一个 `TRIAL` 节点的最小优先队列，按其走时排序。在每一步中，具有最小走时的 `TRIAL` 节点被移至 `ACCEPTED` 集合。然后，其非 `ACCEPTED` 的邻居节点使用 Godunov 格式进行更新，其状态被设为 `TRIAL` 并被添加或更新到优先队列中。该过程从源节点开始向外行进。对于分解 FMM，优先队列按总走时 $T = \\tau + T_0$ 排序，但更新是为 $\\tau$ 计算的。\n\n$2$. **快速扫描法 (FSM)**：这是一种基于 Gauss-Seidel 迭代的方法。它以不同的方向重复扫描整个网格。问题指定了四种交替的扫描方向（例如，按 $i$ 和 $j$ 索引的递增/递减顺序）。在每次扫描中，每个网格点（固定的源点除外）都使用其邻居节点的最新值，通过 Godunov 格式进行更新。这个迭代过程会持续固定的迭代次数或直到收敛。多种扫描方向确保了特征（信息流）在整个域内正确传播。对于分解 FSM，扫描更新的是 $\\tau$ 场而不是 $T$ 场。\n\n实现将按以下步骤进行：\n- 设置网格参数：$N \\in \\{21, 101\\}$，$h = 10$ m，$c_0 = 2000$ m/s。源点位于中心网格点。\n- 在网格上预计算精确解 $T_0$。\n- 实现一个 Godunov 更新规则的函数。\n- 实现 FMM（标准版和分解版）。FMM 将使用 Python 的 `heapq` 模块来实现优先队列。\n- 实现 FSM（标准版和分解版）。FSM 将执行 20 次迭代，每次迭代包含四次扫描。\n- 对于指定的四个测试案例（粗/细网格上的 FMM，粗/细网格上的 FSM），计算走时场 $T_{\\text{std}}$ 和 $T_{\\text{fact}} = \\tau_{\\text{fact}} + T_0$。\n- 计算相对于精确解 $T_0$ 的均方根误差 $\\mathrm{RMSE}_\\mathrm{std}$ 和 $\\mathrm{RMSE}_\\mathrm{fact}$。\n- 计算误差减小因子 $R = \\mathrm{RMSE}_\\mathrm{std} / \\max(\\mathrm{RMSE}_\\mathrm{fact}, 10^{-12})$。\n- 最终输出将是四个计算出的 $R$ 值的列表。", "answer": "```python\nimport numpy as np\nimport heapq\n\n# Per the problem context, scipy is available but not strictly necessary for this implementation.\n# The core algorithms are implemented from scratch using numpy and the standard library.\n\ndef solve_eikonal_update(a, b, h, c_val):\n    \"\"\"\n    Solves the Godunov update for the Eikonal equation.\n    \n    Args:\n        a (float): Minimum travel time from x-neighbors.\n        b (float): Minimum travel time from y-neighbors.\n        h (float): Grid spacing.\n        c_val (float): Wave speed.\n\n    Returns:\n        float: Updated travel time.\n    \"\"\"\n    a, b = float(a), float(b)\n    \n    if np.isinf(a) and np.isinf(b):\n        return np.inf\n\n    h_over_c = h / c_val\n\n    if np.isinf(a) or np.isinf(b):\n        return min(a, b) + h_over_c\n\n    if abs(a - b) >= h_over_c:\n        return min(a, b) + h_over_c\n    else:\n        discriminant = 2 * h_over_c**2 - (a - b)**2\n        # Discriminant should be non-negative due to the check above,\n        # but floating point issues might make it slightly negative.\n        if discriminant < 0:\n            return min(a,b) + h_over_c\n        return (a + b + np.sqrt(discriminant)) / 2.0\n\n\ndef fast_marching_method(N, h, c0, isrc, jsrc, factored, T0):\n    \"\"\"\n    Implements the Fast Marching Method for the Eikonal equation.\n    \"\"\"\n    if factored:\n        values = np.full((N, N), np.inf)  # This will store tau\n        values[isrc, jsrc] = 0.0\n    else:\n        values = np.full((N, N), np.inf)  # This will store T\n        values[isrc, jsrc] = 0.0\n\n    states = np.zeros((N, N), dtype=int)  # 0: UNKNOWN, 1: TRIAL, 2: ACCEPTED\n    heap = []\n\n    # Initializing the source\n    T_val = T0[isrc, jsrc] if factored else 0.0\n    heapq.heappush(heap, (T_val, (isrc, jsrc)))\n    states[isrc, jsrc] = 1\n\n    while heap:\n        t_total, (i, j) = heapq.heappop(heap)\n\n        if states[i, j] == 2:\n            continue\n        \n        current_T_val = (values[i, j] + T0[i, j]) if factored else values[i, j]\n        if t_total > current_T_val:\n            continue\n\n        states[i, j] = 2  # Accept the node\n\n        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ni, nj = i + di, j + dj\n\n            if 0 <= ni < N and 0 <= nj < N and states[ni, nj] != 2:\n                \n                # Get upwind values from accepted neighbors\n                if not factored:\n                    a = np.inf\n                    if ni > 0 and states[ni - 1, nj] == 2: a = min(a, values[ni - 1, nj])\n                    if ni < N-1 and states[ni + 1, nj] == 2: a = min(a, values[ni + 1, nj])\n                    \n                    b = np.inf\n                    if nj > 0 and states[ni, nj - 1] == 2: b = min(b, values[ni, nj - 1])\n                    if nj < N-1 and states[ni, nj + 1] == 2: b = min(b, values[ni, nj + 1])\n                    \n                    if np.isinf(a) and np.isinf(b): continue\n                    \n                    t_new = solve_eikonal_update(a, b, h, c0)\n\n                    if t_new < values[ni, nj]:\n                        values[ni, nj] = t_new\n                        states[ni, nj] = 1\n                        heapq.heappush(heap, (t_new, (ni, nj)))\n                else: # Factored\n                    a_tau = np.inf\n                    if ni > 0 and states[ni - 1, nj] == 2:\n                        val = values[ni-1, nj] + T0[ni-1, nj] - T0[ni, nj]\n                        a_tau = min(a_tau, val)\n                    if ni < N-1 and states[ni + 1, nj] == 2:\n                        val = values[ni+1, nj] + T0[ni+1, nj] - T0[ni, nj]\n                        a_tau = min(a_tau, val)\n                    \n                    b_tau = np.inf\n                    if nj > 0 and states[ni, nj-1] == 2:\n                        val = values[ni, nj-1] + T0[ni, nj-1] - T0[ni, nj]\n                        b_tau = min(b_tau, val)\n                    if nj < N-1 and states[ni, nj+1] == 2:\n                        val = values[ni, nj+1] + T0[ni, nj+1] - T0[ni, nj]\n                        b_tau = min(b_tau, val)\n\n                    if np.isinf(a_tau) and np.isinf(b_tau): continue\n                    \n                    tau_new = solve_eikonal_update(a_tau, b_tau, h, c0)\n\n                    if tau_new < values[ni, nj]:\n                        values[ni, nj] = tau_new\n                        T_new = tau_new + T0[ni, nj]\n                        states[ni, nj] = 1\n                        heapq.heappush(heap, (T_new, (ni, nj)))\n\n    return values\n\n\ndef fast_sweeping_method(N, h, c0, isrc, jsrc, factored, T0, num_iter=20):\n    \"\"\"\n    Implements the Fast Sweeping Method for the Eikonal equation.\n    \"\"\"\n    if factored:\n        values = np.full((N, N), np.inf)  # tau\n        values[isrc, jsrc] = 0.0\n    else:\n        values = np.full((N, N), np.inf)  # T\n        values[isrc, jsrc] = 0.0\n\n    sweep_ranges = [\n        (range(N), range(N)),\n        (range(N - 1, -1, -1), range(N)),\n        (range(N - 1, -1, -1), range(N - 1, -1, -1)),\n        (range(N), range(N - 1, -1, -1))\n    ]\n\n    for _ in range(num_iter):\n        for i_range, j_range in sweep_ranges:\n            for i in i_range:\n                for j in j_range:\n                    if (i, j) == (isrc, jsrc):\n                        continue\n                    \n                    if not factored:\n                        a = min(values[i-1,j] if i>0 else np.inf, values[i+1,j] if i<N-1 else np.inf)\n                        b = min(values[i,j-1] if j>0 else np.inf, values[i,j+1] if j<N-1 else np.inf)\n                        t_new = solve_eikonal_update(a, b, h, c0)\n                        values[i,j] = min(values[i,j], t_new)\n                    else: # Factored\n                        a_tau = min( (values[i-1,j] + T0[i-1,j] - T0[i,j]) if i>0 else np.inf,\n                                     (values[i+1,j] + T0[i+1,j] - T0[i,j]) if i<N-1 else np.inf )\n                        b_tau = min( (values[i,j-1] + T0[i,j-1] - T0[i,j]) if j>0 else np.inf,\n                                     (values[i,j+1] + T0[i,j+1] - T0[i,j]) if j<N-1 else np.inf )\n                        tau_new = solve_eikonal_update(a_tau, b_tau, h, c0)\n                        values[i,j] = min(values[i,j], tau_new)\n                        \n    return values\n\n\ndef main_solver():\n    \"\"\"Main function to run the test cases and print the result.\"\"\"\n    \n    test_cases = [\n        {'method': 'FMM', 'N': 21},\n        {'method': 'FMM', 'N': 101},\n        {'method': 'FSM', 'N': 21},\n        {'method': 'FSM', 'N': 101}\n    ]\n    \n    params = {'h': 10.0, 'c0': 2000.0}\n    reduction_factors = []\n\n    for case in test_cases:\n        N = case['N']\n        h = params['h']\n        c0 = params['c0']\n        \n        isrc = jsrc = (N - 1) // 2\n        xs = ys = isrc * h\n        \n        # Pre-compute analytical solution T0\n        x_coords = np.arange(N) * h\n        y_coords = np.arange(N) * h\n        xx, yy = np.meshgrid(x_coords, y_coords, indexing='ij')\n        T0 = np.sqrt((xx - xs)**2 + (yy - ys)**2) / c0\n\n        method = fast_marching_method if case['method'] == 'FMM' else fast_sweeping_method\n\n        # Standard solver\n        T_std = method(N, h, c0, isrc, jsrc, factored=False, T0=T0)\n        rmse_std = np.sqrt(np.mean((T_std - T0)**2))\n\n        # Factored solver\n        tau_fact = method(N, h, c0, isrc, jsrc, factored=True, T0=T0)\n        T_fact = tau_fact + T0\n        rmse_fact = np.sqrt(np.mean((T_fact - T0)**2))\n\n        # Reduction factor\n        R = rmse_std / max(rmse_fact, 1e-12)\n        reduction_factors.append(R)\n\n    print(f\"[{','.join(map(str, reduction_factors))}]\")\n\nif __name__ == '__main__':\n    main_solver()\n```", "id": "3591136"}, {"introduction": "实际的地球物理问题很少发生在无限的均匀介质中；它们通常包含会反射波场的边界，例如地表或地层界面。简单地在计算域的边缘截断并不能准确地模拟这些物理效应。镜像法 (method-of-images) 为处理均匀介质中的镜面反射提供了一个物理上严谨且优雅的框架。这个练习 [@problem_id:3591123] 旨在将这一物理洞察力融入快速扫描法 (Fast Sweeping Method) 求解器中，通过引入“虚拟单元” (ghost cells) 来精确地施加反射边界条件，并量化这种方法相比标准实现所带来的精度提升。", "problem": "您的任务是设计并实现一个边界感知的数值求解器，用于求解均匀各向同性介质中由程函方程控制的高频走时，并通过使用镜像法的源点扩展方法，量化反射边界对其附近数值精度的影响。理论基础包括用于走时的程函方程和 Hamilton-Jacobi 理论、用于均匀介质中镜面反射的镜像法，以及用于一阶非线性偏微分方程的 Godunov 迎风离散格式。计算区域是一个二维矩形网格，其底边为反射边界。求解器必须基于快速扫描法（Fast Sweeping Method），并且必须与不带边界感知源点扩展的标准点源初始化方法进行比较。\n\n从程函方程开始\n$$\n\\lvert \\nabla T(x,y) \\rvert \\,=\\, s(x,y),\n$$\n其中 $T(x,y)$ 是初至走时，$s(x,y)$ 是慢度场，$s(x,y) = 1/v(x,y)$，其中 $v(x,y)$ 是波速。假设介质是均匀各向同性的，其中 $v(x,y) \\equiv v_0$ 是一个常数，因此 $s(x,y) \\equiv s_0 = 1/v_0$。计算区域在一个两个方向上间距均为 $h$ 的均匀网格上离散化，计算索引为 $i \\in \\{0,\\dots,N_x-1\\}$ 和 $j \\in \\{0,\\dots,N_y-1\\}$，对应的物理坐标为 $x_i = i h$ 和 $y_j = j h$。位于 $y = 0$ 的底边界是镜面反射的（对于射线呈 Neumann 型行为），位于内部 $(x_s,y_s)$ 的一个点源通过 $T(x_s,y_s) = 0$ 初始化走时场。\n\n实现两种数值方案：\n- A 方案（标准点源）：在源网格节点 $(i_s,j_s)$ 处用 $T_{i_s,j_s} = 0$ 进行初始化，并在区域边界使用单边格式执行快速扫描更新（无特殊的边界感知源点扩展）。\n- B 方案（边界感知源点扩展）：使用镜像法在底边界 ($j=-1$) 外侧立即构建一个边界感知的虚拟层，其值 $T_0(i)$ 从位于 $(x_s,-y_s)$ 的镜像源获得。具体来说，通过以下公式定义虚拟节点 $(x_i,y_{-1}) = (i h,-h)$ 上的值：\n$$\nT_0(i) \\,=\\, \\frac{1}{v_0}\\sqrt{(x_i - x_s)^2 + (y_{-1} - (-y_s))^2} \\,=\\, \\frac{1}{v_0}\\sqrt{(x_i - x_s)^2 + (y_s - h)^2}.\n$$\n这些 $T_0(i)$ 并非 $y=0$ 上的狄利克雷边界条件，而是在计算快速扫描更新时，用于 $j=0$ 处节点的迎风格式中的边界感知虚拟值。\n\n作为参考，对于均匀介质和域内源点 $(x_s,y_s)$，底边界上的解析初至走时由下式给出：\n$$\nT^{\\text{true}}(x,0) \\,=\\, \\frac{1}{v_0}\\sqrt{(x - x_s)^2 + y_s^2}.\n$$\n\n设计并实现一个二维快速扫描法，该方法在笛卡尔网格上使用适用于程函方程的 Godunov 迎风离散格式，其中底部虚拟层仅在 B 方案中引入。在两个方向上均使用常数慢度 $s_0 = 1/v_0$ 和均匀间距 $h$。您的实现必须计算 A 方案和 B 方案的数值走时场 $T_{i,j}$，然后通过将 $T_{i,0}$ 与解析边界值 $T^{\\text{true}}(x_i,0)$ 进行比较，来评估沿底边界 $j=0$ 的最大绝对误差。\n\n必须统一使用物理单位：波速 $v_0$ 单位为米/秒 (m/s)，网格间距 $h$ 单位为米 (m)，走时 $T$ 单位为秒 (s)。误差必须以秒 (s) 为单位报告，改进因子必须是无量纲的比率。\n\n测试套件：\n- 案例 1（靠近边界的常规路径）：$N_x = N_y = 101$，$h = 10$ 米，$v_0 = 2000$ 米/秒，源点 $(x_s,y_s) = (500\\,\\text{m}, 10\\,\\text{m})$，对应 $(i_s,j_s) = (50,1)$。\n- 案例 2（与边界对齐的源点）：$N_x = N_y = 101$，$h = 10$ 米，$v_0 = 2000$ 米/秒，源点 $(x_s,y_s) = (500\\,\\text{m}, 0\\,\\text{m})$，对应 $(i_s,j_s) = (50,0)$。\n- 案例 3（远离边界）：$N_x = N_y = 101$，$h = 10$ 米，$v_0 = 2000$ 米/秒，源点 $(x_s,y_s) = (500\\,\\text{m}, 300\\,\\text{m})$，对应 $(i_s,j_s) = (50,30)$。\n- 案例 4（靠近角落）：$N_x = N_y = 101$，$h = 10$ 米，$v_0 = 2000$ 米/秒，源点 $(x_s,y_s) = (10\\,\\text{m}, 10\\,\\text{m})$，对应 $(i_s,j_s) = (1,1)$。\n\n对每个案例，计算 A 方案和 B 方案沿底边界的最大绝对误差，分别记为 $E_{\\text{A}}$ 和 $E_{\\text{B}}$（单位为秒）。然后计算改进因子\n$$\n\\rho \\,=\\, \\frac{E_{\\text{A}}}{E_{\\text{B}}}.\n$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试案例的改进因子，格式为方括号括起来的逗号分隔列表，每个值四舍五入到六位小数（例如，$\\left[\\rho_1,\\rho_2,\\rho_3,\\rho_4\\right]$）。输出必须是无量纲的。", "solution": "该问题要求设计并实现一个数值求解器，用于求解带有反射边界的二维均匀介质中的程函方程。核心任务是比较快速扫描法（FSM）求解器的两种变体：一种是标准实现（A 方案），另一种是使用镜像法通过边界感知源点扩展增强的实现（B 方案）。目标是量化反射边界附近的精度改进。\n\n### 1. 程函方程与 Godunov 离散化\n\n在慢度为 $s(x,y)$ 的介质中，初至走时 $T(x,y)$ 由程函方程控制：\n$$\n|\\nabla T(x,y)|^2 = s(x,y)^2\n$$\n在波速恒为 $v_0$ 的均匀介质中，慢度也为常数，$s(x,y) = s_0 = 1/v_0$。在间距为 $h$ 的均匀笛卡尔网格上，$T_{i,j}$ 表示点 $(x_i, y_j) = (ih, jh)$ 处的走时，方程可写为：\n$$\n\\left( \\frac{\\partial T}{\\partial x} \\right)^2 + \\left( \\frac{\\partial T}{\\partial y} \\right)^2 = s_0^2\n$$\n一个稳定的数值格式是 Godunov 型迎风有限差分法。对于节点 $(i,j)$ 的更新，空间导数仅使用“迎风”信息进行近似，即来自走时更小且波正从此传播而来的相邻节点。这导出了一个关于候选更新时间 $\\hat{T}_{i,j}$ 的局部非线性方程。设 $T_x = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $T_y = \\min(T_{i,j-1}, T_{i,j+1})$ 分别为 $x$ 和 $y$ 方向上相邻节点的最小走时。更新后的时间 $\\hat{T}_{i,j}$ 必须满足：\n$$\n\\left( \\frac{\\max(\\hat{T}_{i,j}-T_x, 0)}{h} \\right)^2 + \\left( \\frac{\\max(\\hat{T}_{i,j}-T_y, 0)}{h} \\right)^2 = s_0^2\n$$\n可以解此方程求得 $\\hat{T}_{i,j}$。一个通用且稳健的流程如下：\n设 $t_{min} = \\min(T_x, T_y)$ 和 $t_{max} = \\max(T_x, T_y)$。\n1. 首先，尝试使用时间最小的邻居进行一维更新：$\\hat{T}_{1D} = t_{min} + h s_0$。\n2. 如果此次更新得到的时间小于或等于另一个邻居的时间（$\\hat{T}_{1D} \\le t_{max}$），则接受该更新。这对应于到达 $(i,j)$ 的特征线（射线路径）主要与一个网格轴对齐的情况。\n3. 如果 $\\hat{T}_{1D} > t_{max}$，则两个邻居都有贡献，更新值通过求解完整的二次方程确定，从而得到二维更新：\n    $$\n    \\hat{T}_{2D} = \\frac{t_{min} + t_{max} + \\sqrt{2(hs_0)^2 - (t_{max} - t_{min})^2}}{2}\n    $$\n节点 $(i,j)$ 的新候选时间为 $\\hat{T}$。最终值通过高斯-赛德尔方法更新：$T_{i,j} \\leftarrow \\min(T_{i,j}, \\hat{T})$。\n\n### 2. 快速扫描法 (FSM)\n\nFSM 是一种有效求解离散化程函方程的迭代算法。它利用了上述类高斯-赛德尔更新，并系统地以不同方向扫描网格，以正确地从源点传播信息。\n该算法流程如下：\n1.  **初始化**：走时网格 $T$ 在源点位置 $(i_s, j_s)$ 处初始化为 $T_{i_s, j_s} = 0$，在所有其他网格点处初始化为 $T=\\infty$。\n2.  **扫描**：该方法在一组覆盖所有特征传播方向的四次扫描中迭代：\n    - 扫描 1：$i = 0, \\dots, N_x-1$；$j = 0, \\dots, N_y-1$（从左下到右上）\n    - 扫描 2：$i = N_x-1, \\dots, 0$；$j = 0, \\dots, N_y-1$（从右下到左上）\n    - 扫描 3：$i = N_x-1, \\dots, 0$；$j = N_y-1, \\dots, 0$（从右上到左下）\n    - 扫描 4：$i = 0, \\dots, N_x-1$；$j = N_y-1, \\dots, 0$（从左上到右下）\n    在每次扫描中，每个非源点的网格点都使用 Godunov 格式进行更新。\n3.  **收敛**：重复四次扫描的循环，直到走时场 $T$ 收敛，即两次完整循环之间任何 $T_{i,j}$ 的最大变化量低于一个小的容差。对于均匀介质，通常只需几次循环即可收敛。\n\n### 3. 边界条件变体\n\n两种变体之间的关键区别在于对位于 $y=0$（$j=0$）的底边界的处理。\n\n**A 方案（标准点源）**：\n在区域边界，使用标准的单边有限差分。当更新底边界上的一个节点 $(i,0)$ 时，在 $y$ 方向的迎风邻居搜索只考虑内部邻居 $T_{i,1}$。越界的邻居 $T_{i,-1}$ 被有效视为具有无限大走时，因此 $T_y = T_{i,1}$。这是一种简单但通常不准确的边界条件近似方法。\n\n**B 方案（边界感知源点扩展）**：\n该变体使用镜像法来模拟位于 $y=0$ 的镜面反射边界。对于位于 $(x_s, y_s)$ 的源点，一个镜像源被放置在 $(x_s, -y_s)$。这个镜像源被用来定义位于 $y_{-1} = -h$ 的一层“虚拟”节点上的走时。虚拟节点 $(x_i, y_{-1})$ 处的走时 $T_0(i)$ 是从镜像源传播到该虚拟节点所需的时间：\n$$\nT_0(i) \\,=\\, \\frac{1}{v_0}\\sqrt{(x_i - x_s)^2 + (y_{-1} - (-y_s))^2} \\,=\\, \\frac{1}{v_0}\\sqrt{(x_i - x_s)^2 + (y_s - h)^2}\n$$\n当更新物理边界上的节点 $(i,0)$ 时，这些虚拟值被用于迎风格式中。在 $y$ 方向的最小邻居时间变为 $T_y = \\min(T_0(i), T_{i,1})$。这为求解器提供了来自边界“另一侧”的准确信息，有效地强制执行了正确的反射物理规律，并对边界附近的初至走时场产生了更精确的数值解。\n\n### 4. 误差量化\n\n为了评估每个方案的准确性，将沿底边界的数值计算走时 $T_{i,0}$ 与解析解进行比较。对于均匀介质，从源点 $(x_s, y_s)$ 到达边界上一点 $(x,0)$ 的初至走时就是直线路径距离除以速度：\n$$\nT^{\\text{true}}(x,0) \\,=\\, \\frac{1}{v_0}\\sqrt{(x - x_s)^2 + y_s^2}\n$$\nA 方案（$E_{\\text{A}}$）和 B 方案（$E_{\\text{B}}$）的最大绝对误差沿此边界计算。改进因子 $\\rho = E_{\\text{A}} / E_{\\text{B}}$ 量化了边界感知方法的性能增益。", "answer": "```python\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main solver to run test cases and compute improvement factors.\n    \"\"\"\n    test_cases = [\n        {'Nx': 101, 'Ny': 101, 'h': 10.0, 'v0': 2000.0, 'xs': 500.0, 'ys': 10.0},\n        {'Nx': 101, 'Ny': 101, 'h': 10.0, 'v0': 2000.0, 'xs': 500.0, 'ys': 0.0},\n        {'Nx': 101, 'Ny': 101, 'h': 10.0, 'v0': 2000.0, 'xs': 500.0, 'ys': 300.0},\n        {'Nx': 101, 'Ny': 101, 'h': 10.0, 'v0': 2000.0, 'xs': 10.0, 'ys': 10.0},\n    ]\n\n    improvement_factors = []\n\n    for case in test_cases:\n        Nx, Ny, h, v0 = case['Nx'], case['Ny'], case['h'], case['v0']\n        xs, ys = case['xs'], case['ys']\n        s0 = 1.0 / v0\n        ix_s = int(round(xs / h))\n        iy_s = int(round(ys / h))\n\n        def solve_for_T_at_node(i, j, T, T_ghost, h_s0):\n            \"\"\"Calculates the updated travel time at a single node.\"\"\"\n            # Get minimum travel times from neighbors\n            Tx_min = np.inf\n            if i > 0: Tx_min = min(Tx_min, T[i - 1, j])\n            if i < Nx - 1: Tx_min = min(Tx_min, T[i + 1, j])\n\n            Ty_min = np.inf\n            if j > 0:\n                Ty_min = min(Ty_min, T[i, j - 1])\n            elif T_ghost is not None:  # Variant B at j=0\n                Ty_min = min(Ty_min, T_ghost[i])\n\n            if j < Ny - 1: Ty_min = min(Ty_min, T[i, j + 1])\n\n            t_min = min(Tx_min, Ty_min)\n            if t_min == np.inf:\n                return np.inf\n\n            # Attempt 1D update\n            t_new = t_min + h_s0\n\n            # If 2D update is necessary and possible\n            t_max = max(Tx_min, Ty_min)\n            if t_max != np.inf and t_new > t_max:\n                discriminant = 2.0 * h_s0**2 - (t_max - t_min)**2\n                if discriminant >= 0:\n                    t_new = (t_min + t_max + np.sqrt(discriminant)) / 2.0\n            \n            return t_new\n\n        def run_fsm(variant):\n            \"\"\"Performs the Fast Sweeping Method for a given variant.\"\"\"\n            T = np.full((Nx, Ny), np.inf)\n            if 0 <= ix_s < Nx and 0 <= iy_s < Ny:\n                T[ix_s, iy_s] = 0.0\n\n            T_ghost = None\n            if variant == 'B':\n                y_ghost = -h\n                T_ghost = s0 * np.sqrt((np.arange(Nx) * h - xs)**2 + (ys - h)**2)\n\n            h_s0 = h * s0\n            \n            for _ in range(20):  # FSM converges quickly in homogeneous media\n                T_old = T.copy()\n                \n                # Sweep 1: i ->, j ->\n                for i in range(Nx):\n                    for j in range(Ny):\n                        if i == ix_s and j == iy_s: continue\n                        t_updated = solve_for_T_at_node(i, j, T, T_ghost, h_s0)\n                        T[i, j] = min(T[i, j], t_updated)\n                \n                # Sweep 2: i <-, j ->\n                for i in range(Nx - 1, -1, -1):\n                    for j in range(Ny):\n                        if i == ix_s and j == iy_s: continue\n                        t_updated = solve_for_T_at_node(i, j, T, T_ghost, h_s0)\n                        T[i, j] = min(T[i, j], t_updated)\n                \n                # Sweep 3: i <-, j <-\n                for i in range(Nx - 1, -1, -1):\n                    for j in range(Ny - 1, -1, -1):\n                        if i == ix_s and j == iy_s: continue\n                        t_updated = solve_for_T_at_node(i, j, T, T_ghost, h_s0)\n                        T[i, j] = min(T[i, j], t_updated)\n                \n                # Sweep 4: i ->, j <-\n                for i in range(Nx):\n                    for j in range(Ny - 1, -1, -1):\n                        if i == ix_s and j == iy_s: continue\n                        t_updated = solve_for_T_at_node(i, j, T, T_ghost, h_s0)\n                        T[i, j] = min(T[i, j], t_updated)\n                        \n                if np.max(np.abs(T - T_old)) < 1e-12:\n                    break\n            \n            return T\n\n        # Run both variants\n        T_A = run_fsm(variant='A')\n        T_B = run_fsm(variant='B')\n\n        # Calculate analytical solution and errors\n        x_coords = np.arange(Nx) * h\n        T_true_boundary = s0 * np.sqrt((x_coords - xs)**2 + ys**2)\n\n        error_A = np.max(np.abs(T_A[:, 0] - T_true_boundary))\n        error_B = np.max(np.abs(T_B[:, 0] - T_true_boundary))\n        \n        if error_B < 1e-15:\n            rho = 1.0 if error_A < 1e-15 else np.inf\n        else:\n            rho = error_A / error_B\n            \n        improvement_factors.append(rho)\n\n    print(f\"[{','.join([f'{r:.6f}' for r in improvement_factors])}]\")\n\nsolve()\n```", "id": "3591123"}]}