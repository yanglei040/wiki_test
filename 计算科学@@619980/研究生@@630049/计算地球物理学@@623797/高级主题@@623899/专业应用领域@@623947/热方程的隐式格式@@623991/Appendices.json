{"hands_on_practices": [{"introduction": "这个基础练习将引导你从零开始构建一个隐式差分格式。我们将采用向后欧拉方法对热传导方程进行离散化，推导出其对应的三对角线性系统。通过这个过程，你将理解为什么该系统具有严格对角占优的性质（这是保证数值求解稳定性的关键），并学会使用托马斯算法（Thomas algorithm）高效求解，并分析其计算成本。这是将一个偏微分方程转化为可计算程序的第一步，也是后续更复杂分析的基础 [@problem_id:3604199]。", "problem": "考虑空间区间 $[0,1]$ 上的一维热方程 $u_{t}=\\kappa\\,u_{xx}$，其边界条件为齐次狄利克雷边界条件 $u(0,t)=0$ 和 $u(1,t)=0$，其中 $\\kappa>0$ 为常数。设空间网格是均匀的，有 $N+1$ 个节点 $x_{j}=j\\,h$（$j=0,1,\\dots,N$），且 $h=1/N$。设时间以步长 $\\Delta t>0$ 进行离散化。将在时间层 $t^{n}=n\\,\\Delta t$ 的全离散解记为 $U_{j}^{n}\\approx u(x_{j},t^{n})$。使用时间上的后向欧拉法和空间上的二阶中心差分，对内部节点 $j=1,2,\\dots,N-1$ 从 $t^{n}$ 推进到 $t^{n+1}$，并在 $j=0$ 和 $j=N$ 处施加边界条件。\n\n从上述微分方程和定义出发，推导求解 $U^{n+1}=\\{U_j^{n+1}\\}_{j=1}^{N-1}$（用 $U^n=\\{U_j^n\\}_{j=1}^{N-1}$ 表示）所必须求解的线性系统，并解释为何对于 $\\Delta t>0$ 该系统是严格对角占优的。然后，假设该系统通过 Thomas 算法（即不带主元选择的三对角高斯消元法）求解，并将任何单个标量浮点数的加、减、乘、除定义为一次浮点运算（flop），确定一个后向欧拉步（求解一次 $U^{n+1}$）所需的精确浮点运算次数，表示为仅含 $N$ 的表达式。只计算算术运算；忽略内存访问和比较。\n\n将最终答案表示为仅含 $N$ 的单个闭式表达式，不要包含任何单位。无需四舍五入。", "solution": "该问题是有效的，因为它具有科学依据、是适定的、客观的，并包含推导唯一解所需的所有必要信息。这是偏微分方程数值分析领域中的一个标准问题。\n\n该问题要求三件事：\n1. 推导一维热方程后向欧拉离散化后的线性系统。\n2. 解释为何得到的系统矩阵是严格对角占优的。\n3. 使用 Thomas 算法在单个时间步内求解此系统的精确浮点运算次数，作为 $N$ 的函数。\n\n我们依次解决每个部分。\n\n首先，给定一维热方程：\n$$u_{t}=\\kappa\\,u_{xx}$$\n定义在空间域 $x \\in [0,1]$ 上，具有恒定的热扩散系数 $\\kappa > 0$。边界条件为齐次狄利克雷条件：$u(0,t)=0$ 和 $u(1,t)=0$。\n\n空间域用均匀网格 $x_j = j h$（$j=0, 1, \\dots, N$）进行离散化，其中步长为 $h=1/N$。时间域用均匀步长 $\\Delta t > 0$ 进行离散化，使得 $t^n = n \\Delta t$。在网格点 $(x_j, t^n)$ 的数值解记为 $U_j^n \\approx u(x_j, t^n)$。\n\n后向欧拉法是一种隐式方法，这意味着空间导数在未来的时间层 $t^{n+1}$ 上进行计算。在 $(x_j, t^{n+1})$ 处的时间导数 $u_t$ 用一阶后向差分近似：\n$$\\frac{\\partial u}{\\partial t}\\bigg|_{(x_j, t^{n+1})} \\approx \\frac{U_j^{n+1} - U_j^n}{\\Delta t}$$\n在 $(x_j, t^{n+1})$ 处的空间二阶导数 $u_{xx}$ 用二阶中心差分近似：\n$$\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_j, t^{n+1})} \\approx \\frac{U_{j-1}^{n+1} - 2U_j^{n+1} + U_{j+1}^{n+1}}{h^2}$$\n将这些近似代入热方程，对内部节点 $j=1, 2, \\dots, N-1$，可得：\n$$\\frac{U_j^{n+1} - U_j^n}{\\Delta t} = \\kappa \\frac{U_{j-1}^{n+1} - 2U_j^{n+1} + U_{j+1}^{n+1}}{h^2}$$\n为简化起见，我们引入无量纲扩散数 $s$：\n$$s = \\frac{\\kappa \\Delta t}{h^2}$$\n由于 $\\kappa > 0$，$\\Delta t > 0$ 且 $h^2 > 0$，因此 $s > 0$。将 $s$ 代入离散化方程得到：\n$$U_j^{n+1} - U_j^n = s (U_{j-1}^{n+1} - 2U_j^{n+1} + U_{j+1}^{n+1})$$\n我们重新整理这个方程，将时间层 $n+1$ 的未知项放在左侧，时间层 $n$ 的已知项放在右侧：\n$$-s U_{j-1}^{n+1} + (1 + 2s) U_j^{n+1} - s U_{j+1}^{n+1} = U_j^n$$\n该方程对内部网格点 $j=1, 2, \\dots, N-1$ 成立。未知向量 $U^{n+1} = \\{U_j^{n+1}\\}_{j=1}^{N-1}$ 的大小为 $N-1$。\n我们必须并入边界条件 $U_0^{n+1} = u(0, t^{n+1}) = 0$ 和 $U_N^{n+1} = u(1, t^{n+1}) = 0$。\n\n对于第一个内部节点 $j=1$：\n$$-s U_0^{n+1} + (1 + 2s) U_1^{n+1} - s U_2^{n+1} = U_1^n$$\n由于 $U_0^{n+1}=0$，方程变为：\n$$(1 + 2s) U_1^{n+1} - s U_2^{n+1} = U_1^n$$\n对于最后一个内部节点 $j=N-1$：\n$$-s U_{N-2}^{n+1} + (1 + 2s) U_{N-1}^{n+1} - s U_N^{n+1} = U_{N-1}^n$$\n由于 $U_N^{n+1}=0$，方程变为：\n$$-s U_{N-2}^{n+1} + (1 + 2s) U_{N-1}^{n+1} = U_{N-1}^n$$\n这 $(N-1)$ 个方程构成一个形如 $A U^{n+1} = U^n$ 的线性系统，其中 $A$ 是一个 $(N-1) \\times (N-1)$ 的三对角矩阵，而 $U^{n+1}$ 和 $U^n$ 是大小为 $N-1$ 的列向量。矩阵 $A$ 为：\n$$\nA = \\begin{pmatrix}\n1+2s  -s  0  \\cdots  0 \\\\\n-s  1+2s  -s  \\ddots  \\vdots \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n\\vdots  \\ddots  -s  1+2s  -s \\\\\n0  \\cdots  0  -s  1+2s\n\\end{pmatrix}\n$$\n\n接下来，我们解释为什么矩阵 $A$ 是严格对角占优的。如果一个矩阵的每一行中，对角元素的绝对值都严格大于该行所有其他非对角元素绝对值之和，则该矩阵是严格对角占优的。设 $A = [a_{ij}]$，则条件为对所有 $i$ 都有 $|a_{ii}| > \\sum_{j \\neq i} |a_{ij}|$。\n\n我们有 $s > 0$。因此，所有对角元素都是正的，所有非对角元素都是负的。\n1. 对于第一行（$i=1$）：对角元素是 $a_{11} = 1+2s$。只有一个非对角元素 $a_{12} = -s$。我们必须检验是否 $|1+2s| > |-s|$。因为 $s>0$，这个不等式是 $1+2s > s$，可以简化为 $1+s > 0$。由于 $s > 0$，这是成立的。\n2. 对于内部行（$i=2, \\dots, N-2$）：对角元素是 $a_{ii} = 1+2s$。有两个非对角元素 $a_{i,i-1} = -s$ 和 $a_{i,i+1} = -s$。我们必须检验是否 $|1+2s| > |-s| + |-s|$。这个不等式是 $1+2s > s + s$，可以简化为 $1+2s > 2s$，即 $1 > 0$。这是成立的。\n3. 对于最后一行（$i=N-1$）：此情况与第一行对称。对角元素是 $a_{N-1,N-1} = 1+2s$，唯一的非对角元素是 $a_{N-1,N-2}=-s$。检验条件为 $|1+2s| > |-s|$，如第一行所示，这是成立的。\n\n由于严格对角占优的条件对所有行都成立，因此对于任何 $\\Delta t > 0$ 的选择，矩阵 $A$ 都是严格对角占优的。\n\n最后，我们确定使用 Thomas 算法求解系统 $A U^{n+1} = U^n$ 的精确浮点运算次数。一次“flop”被定义为一次加、减、乘或除运算。问题要求的是求解步骤本身的浮点运算次数，如括号中所示（“one solve for $U^{n+1}$”）。三对角系统的大小是 $m \\times m$，其中 $m = N-1$。\n\nThomas 算法包括两个阶段：前向消元和回代。\n阶段 1：前向消元\n此阶段通过消去次对角线元素将系统转换为上双对角形式。对于一个具有次对角线 $b_i$、主对角线 $a_i$ 和超对角线 $c_i$ 的一般三对角系统，算法对 $i=2, \\dots, m$ 按以下步骤进行：\n- `w = b_i / a_{i-1}`：1 次除法。\n- `a_i = a_i - w * c_{i-1}`：1 次乘法，1 次减法（2 次 flops）。\n- `d_i = d_i - w * d_{i-1}`：1 次乘法，1 次减法（2 次 flops）。\n循环的每一步需要 $1+2+2 = 5$ 次 flops。循环运行 $i=2, \\dots, m$，即 $m-1$ 次迭代。\n前向消元的总 flops = $5(m-1)$。\n\n阶段 2：回代\n前向消元后，从最后一个未知数开始通过回代求解。\n- `U_m = d_m / a_m`：1 次除法。\n- 对于 $i=m-1, \\dots, 1$：\n  - `U_i = (d_i - c_i * U_{i+1}) / a_i`：1 次乘法，1 次减法，1 次除法（3 次 flops）。\n这个循环运行 $m-1$ 次。\n回代的总 flops = $1 + 3(m-1)$。\n\nThomas 算法的总浮点运算次数：\n总 flops 数是两个阶段 flops 数之和：\n$$ \\text{Flops} = 5(m-1) + 1 + 3(m-1) = 8(m-1) + 1 = 8m - 7 $$\n问题要求答案用 $N$ 表示。我们系统的规模是 $m=N-1$。将此代入 flop 计数表达式：\n$$ \\text{Flops} = 8(N-1) - 7 = 8N - 8 - 7 = 8N - 15 $$\n这就是单次求解步骤的精确 flop 次数。", "answer": "$$\\boxed{8N - 15}$$", "id": "3604199"}, {"introduction": "不同的隐式格式具有不同的数值特性。本练习将一阶精度的向后欧拉（Backward Euler）方法与二阶精度的克兰克-尼科尔森（Crank-Nicolson）方法进行比较，重点关注它们在数值耗散（numerical dissipation）上的差异。你将学会通过推导理论放大因子来量化不同格式对不同频率模式的衰减效果，并通过数值实验进行验证，从而深刻理解为何在特定问题中某种格式可能优于另一种格式 [@problem_id:3604206]。", "problem": "考虑在有限域上具有恒定热扩散系数 $\\kappa$ 和齐次狄利克雷边界条件的一维热传导偏微分方程 (PDE)。控制方程为 $u_t=\\kappa u_{xx}$，定义在 $x\\in[0,L]$ 上，边界条件为 $u(0,t)=0$ 和 $u(L,t)=0$，初始条件 $u(x,0)$ 为单一正弦模态。使用均匀空间网格和有限差分法 (FDM) 对二阶导数进行离散，构建带有齐次狄利克雷边界条件的离散拉普拉斯算子。使用 Crank–Nicolson (CN) 和 Backward Euler (BE) 两种方法实现一个隐式时间步，其中 Crank–Nicolson (CN) 和 Backward Euler (BE) 是用于抛物型偏微分方程的标准隐式时间积分格式。\n\n从基本偏微分方程和边界条件出发，利用由二阶中心差分导出的离散拉普拉斯算子，通过使用作为离散拉普拉斯算子特征向量的离散正弦模态，来量化每种格式在单个时间步内的数值耗散。单个时间步的数值耗散在此定义为时间步之后与时间步之前的离散 $\\ell^2$ 范数之比，即 $\\|u^{n+1}\\|_2 / \\|u^n\\|_2$，该比值为无量纲。对于索引为 $m$ 的离散本征模态，$\\|u^n\\|_2$ 表示在时间层 $n$ 的内部节点值向量的欧几里得范数。由于初始条件被选为离散拉普拉斯算子的特征向量（一个与齐次狄利克雷边界兼容的正弦模态），在线性隐式步进下，解的形状保持与该模态成比例，因此这个范数比等于每步放大因子的绝对值。\n\n你的程序必须：\n- 构建对应于 $N$ 个内部点上二阶中心差分的一维离散拉普拉斯矩阵，该矩阵具有齐次狄利克雷边界条件，网格间距为 $\\Delta x = L/(N+1)$。\n- 将内部节点值初始化为离散正弦模态 $u_j^0=\\sin\\!\\left(\\frac{m\\pi j}{N+1}\\right)$，其中 $j=1,2,\\dots,N$。这对应于在 $[0,L]$ 上波数为 $\\frac{m\\pi}{L}$ 的正弦模态。\n- 使用时间步长 $\\Delta t$ 执行一个 BE 步和一个 CN 步，并计算经验耗散因子 $g_{\\mathrm{BE,emp}}=\\|u^{1}_{\\mathrm{BE}}\\|_2/\\|u^{0}\\|_2$ 和 $g_{\\mathrm{CN,emp}}=\\|u^{1}_{\\mathrm{CN}}\\|_2/\\|u^{0}\\|_2$。\n- 通过对离散拉普拉斯算子进行特征值分析，计算离散模态的理论耗散因子，得到用模态 $m$ 的离散特征值以及参数 $\\kappa$、$\\Delta t$ 和 $L$ 表示的 $g_{\\mathrm{BE,th}}$ 和 $g_{\\mathrm{CN,th}}$。不要使用问题描述中给出的任何快捷公式；从方法的第一性原理和离散拉普拉斯算子的特征结构推导表达式。\n\n对每个测试用例，报告一个包含四个浮点数的列表 $[g_{\\mathrm{CN,emp}},g_{\\mathrm{BE,emp}},g_{\\mathrm{CN,th}},g_{\\mathrm{BE,th}}]$。\n\n使用以下科学一致的测试套件，以确保覆盖不同的区域：\n1. $L=1$, $N=63$, $\\kappa=1$, $\\Delta t=0.01$, $m=1$。\n2. $L=1$, $N=63$, $\\kappa=1$, $\\Delta t=0.01$, $m=63$。\n3. $L=1$, $N=63$, $\\kappa=0.5$, $\\Delta t=10^{-6}$, $m=32$。\n4. $L=1$, $N=3$, $\\kappa=1$, $\\Delta t=0.1$, $m=1$。\n5. $L=2$, $N=63$, $\\kappa=2$, $\\Delta t=0.5$, $m=22$。\n\n所有量都是无量纲的，因此不需要进行物理单位转换。三角函数中出现的角度应解释为弧度。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且本身是一个按 $[g_{\\mathrm{CN,emp}},g_{\\mathrm{BE,emp}},g_{\\mathrm{CN,th}},g_{\\mathrm{BE,th}}]$ 顺序排列的列表，例如 $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],\\dots]$，其中 $a_i, b_i, c_i, d_i$ 是第 $i$ 个测试用例的浮点数。", "solution": "用户希望我解决一个与热方程数值方法相关的问题。\n\n这是我的计划：\n1.  **验证问题陈述。**\n    *   逐字提取所有给定信息。\n    *   检查科学合理性、适定性、客观性、完整性及其他有效性标准。该问题似乎是一个标准的数值分析任务，因此很可能是有效的。它涉及一维热方程、有限差分法 (FDM)、Crank-Nicolson、向后欧拉法 (Backward Euler) 以及离散算子的特征值分析。这些都是计算科学与工程中公认的概念。\n    *   参数和测试用例看起来是合理的。\n    *   我需要从第一性原理推导理论放大因子，这是任务的关键部分。\n\n2.  **如果问题有效，则继续求解。**\n    *   **理论耗散因子的推导：**\n        *   从连续偏微分方程开始：$u_t = \\kappa u_{xx}$。\n        *   在空间上进行离散化。域为 $x \\in [0, L]$。设有 $N$ 个内部点 $x_j = j \\Delta x$，其中 $j=1, \\dots, N$，$\\Delta x = L/(N+1)$。边界点为 $x_0 = 0$ 和 $x_{N+1} = L$。\n        *   在内部点 $x_j$ 处，二阶空间导数的二阶中心差分近似为：\n            $$ u_{xx}(x_j, t) \\approx \\frac{u(x_{j-1}, t) - 2u(x_j, t) + u(x_{j+1}, t)}{(\\Delta x)^2} $$\n        *   令 $u_j(t) \\approx u(x_j, t)$。对于向量 $\\mathbf{u}(t) = [u_1(t), u_2(t), \\dots, u_N(t)]^T$，半离散常微分方程组为：\n            $$ \\frac{d\\mathbf{u}}{dt} = \\frac{\\kappa}{(\\Delta x)^2} A \\mathbf{u} $$\n            其中 $A$ 是 $N \\times N$ 的离散拉普拉斯矩阵。对于齐次狄利克雷边界条件（$u_0=0, u_{N+1}=0$），矩阵 $A$ 是一个三对角矩阵：\n            $$ A = \\begin{pmatrix}\n            -2  1  0  \\dots  0 \\\\\n            1  -2  1  \\dots  0 \\\\\n            0  1  -2  \\dots  0 \\\\\n            \\vdots  \\vdots  \\ddots  \\ddots  \\vdots \\\\\n            0  0  \\dots  1  -2\n            \\end{pmatrix} $$\n        *   问题陈述指明初始条件是一个离散正弦模态，它是离散拉普拉斯算子的一个特征向量。我们来验证这一点。矩阵 $A$ 的特征向量 $\\mathbf{v}^{(m)}$ 和特征值 $\\lambda_m$ 是众所周知的：\n            *   第 $m$ 个特征向量的第 $j$ 个分量是 $v_j^{(m)} = \\sin\\left(\\frac{m \\pi j}{N+1}\\right)$，其中 $j=1, \\dots, N$ 且 $m=1, \\dots, N$。\n            *   对应的特征值为 $\\lambda_m = -4 \\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right)$。\n            *   我们来复核一下这个特征值。\n                *   $(A \\mathbf{v}^{(m)})_j = v_{j-1}^{(m)} - 2v_j^{(m)} + v_{j+1}^{(m)}$\n                *   $= \\sin\\left(\\frac{m \\pi (j-1)}{N+1}\\right) - 2\\sin\\left(\\frac{m \\pi j}{N+1}\\right) + \\sin\\left(\\frac{m \\pi (j+1)}{N+1}\\right)$\n                *   使用恒等式 $\\sin(a-b) + \\sin(a+b) = 2\\sin(a)\\cos(b)$，其中 $a = \\frac{m \\pi j}{N+1}$ 且 $b = \\frac{m \\pi}{N+1}$：\n                *   $= 2\\sin\\left(\\frac{m \\pi j}{N+1}\\right)\\cos\\left(\\frac{m \\pi}{N+1}\\right) - 2\\sin\\left(\\frac{m \\pi j}{N+1}\\right)$\n                *   $= \\left(2\\cos\\left(\\frac{m \\pi}{N+1}\\right) - 2\\right) \\sin\\left(\\frac{m \\pi j}{N+1}\\right)$\n                *   使用半角公式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$：\n                *   $= -2 \\left(1 - \\cos\\left(\\frac{m \\pi}{N+1}\\right)\\right) \\sin\\left(\\frac{m \\pi j}{N+1}\\right)$\n                *   $= -2 \\left(2\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right)\\right) \\sin\\left(\\frac{m \\pi j}{N+1}\\right)$\n                *   $= -4\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right) v_j^{(m)}$\n            *   所以，$\\lambda_m = -4\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right)$。这是正确的。\n\n        *   现在，我们来看时间积分格式。半离散系统是 $\\frac{d\\mathbf{u}}{dt} = M \\mathbf{u}$，其中 $M = \\frac{\\kappa}{(\\Delta x)^2} A$。\n        *   $M$ 的特征值为 $\\mu_m = \\frac{\\kappa}{(\\Delta x)^2} \\lambda_m = -\\frac{4\\kappa}{(\\Delta x)^2}\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right)$。\n\n        *   **向后欧拉法 (Backward Euler, BE):**\n            *   该格式为 $\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = M \\mathbf{u}^{n+1}$。\n            *   整理可得：$(I - \\Delta t M) \\mathbf{u}^{n+1} = \\mathbf{u}^n$。\n            *   因此，$\\mathbf{u}^{n+1} = (I - \\Delta t M)^{-1} \\mathbf{u}^n$。\n            *   “放大矩阵”为 $G_{BE} = (I - \\Delta t M)^{-1}$。\n            *   如果初始条件 $\\mathbf{u}^0$ 是 $M$ 的一个特征向量 $\\mathbf{v}^{(m)}$，其特征值为 $\\mu_m$，那么 $\\mathbf{u}^1 = g_{BE}(\\mu_m) \\mathbf{u}^0$。\n            *   此模态的放大因子是 $G_{BE}$ 相应的特征值。\n            *   $G_{BE}$ 的特征值为 $(1 - \\Delta t \\mu_m)^{-1}$。\n            *   所以，理论耗散因子 $g_{\\mathrm{BE,th}}$ 是该特征值的绝对值：\n                $$ g_{\\mathrm{BE,th}} = |(1 - \\Delta t \\mu_m)^{-1}| = \\left| \\frac{1}{1 - \\Delta t \\mu_m} \\right| $$\n            *   由于 $\\mu_m$ 是实数且为负，分母 $1 - \\Delta t \\mu_m > 1$。\n                $$ g_{\\mathrm{BE,th}} = \\frac{1}{1 - \\Delta t \\mu_m} = \\frac{1}{1 + \\Delta t \\frac{4\\kappa}{(\\Delta x)^2}\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right)} $$\n\n        *   **Crank-Nicolson (CN):**\n            *   该格式为 $\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} M (\\mathbf{u}^{n+1} + \\mathbf{u}^n)$。\n            *   整理可得：$(I - \\frac{\\Delta t}{2} M) \\mathbf{u}^{n+1} = (I + \\frac{\\Delta t}{2} M) \\mathbf{u}^n$。\n            *   因此，$\\mathbf{u}^{n+1} = (I - \\frac{\\Delta t}{2} M)^{-1} (I + \\frac{\\Delta t}{2} M) \\mathbf{u}^n$。\n            *   放大矩阵为 $G_{CN} = (I - \\frac{\\Delta t}{2} M)^{-1} (I + \\frac{\\Delta t}{2} M)$。\n            *   $G_{CN}$ 的特征值为 $\\frac{1 + \\frac{\\Delta t}{2} \\mu_m}{1 - \\frac{\\Delta t}{2} \\mu_m}$。\n            *   理论耗散因子 $g_{\\mathrm{CN,th}}$ 是该特征值的绝对值：\n                $$ g_{\\mathrm{CN,th}} = \\left| \\frac{1 + \\frac{\\Delta t}{2} \\mu_m}{1 - \\frac{\\Delta t}{2} \\mu_m} \\right| $$\n            *   由于 $\\mu_m$ 是实数且为负，分子是 $1 + \\frac{\\Delta t}{2} \\mu_m$，分母是 $1 - \\frac{\\Delta t}{2} \\mu_m$。\n            *   该值为实数。耗散因子是此放大因子的绝对值。\n                $$ g_{\\mathrm{CN,th}} = \\left| \\frac{1 - \\frac{\\Delta t}{2} |\\mu_m|}{1 + \\frac{\\Delta t}{2} |\\mu_m|} \\right| = \\left| \\frac{1 - \\frac{2\\kappa \\Delta t}{(\\Delta x)^2}\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right)}{1 + \\frac{2\\kappa \\Delta t}{(\\Delta x)^2}\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right)} \\right| $$\n            \n        *   问题将数值耗散定义为离散 $\\ell^2$ 范数之比，即 $\\|u^{n+1}\\|_2 / \\|u^n\\|_2$。由于初始条件 $\\mathbf{u}^n$ 是一个特征向量，后续的解 $\\mathbf{u}^{n+1}$ 只是它的一个标量倍数，即 $\\mathbf{u}^{n+1} = g \\mathbf{u}^n$，其中 $g$ 是标量放大因子。\n        *   因此，$\\|\\mathbf{u}^{n+1}\\|_2 = \\|g \\mathbf{u}^n\\|_2 = |g| \\|\\mathbf{u}^n\\|_2$。\n        *   范数比为 $\\|\\mathbf{u}^{n+1}\\|_2 / \\|\\mathbf{u}^n\\|_2 = |g|$。这验证了理论耗散因子确实是上面推导出的放大因子的绝对值。\n\n3.  **实现细节：**\n    *   对于每个具有参数 $(L, N, \\kappa, \\Delta t, m)$ 的测试用例：\n        *   计算 $\\Delta x = L/(N+1)$。\n        *   **理论计算：**\n            *   计算缩放后的离散拉普拉斯算子 $M$ 的特征值：\n                $$ \\mu_m = -\\frac{4\\kappa}{(\\Delta x)^2}\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right) $$\n            *   计算 $g_{\\mathrm{BE,th}}$：\n                $$ g_{\\mathrm{BE,th}} = \\frac{1}{1 - \\Delta t \\mu_m} $$\n            *   计算 $g_{\\mathrm{CN,th}}$：\n                $$ g_{\\mathrm{CN,th}} = \\left| \\frac{1 + \\Delta t \\mu_m / 2}{1 - \\Delta t \\mu_m / 2} \\right| $$\n        *   **经验计算：**\n            *   创建初始条件向量 $\\mathbf{u}^0$：\n                $$ u_j^0 = \\sin\\left(\\frac{m \\pi j}{N+1}\\right) \\quad \\text{for } j=1, \\dots, N $$\n            *   计算初始范数 $\\|\\mathbf{u}^0\\|_2$。\n            *   **向后欧拉步：**\n                *   建立并求解线性系统 $(I - \\frac{\\kappa \\Delta t}{(\\Delta x)^2} A) \\mathbf{u}^1_{BE} = \\mathbf{u}^0$ 以得到 $\\mathbf{u}^1_{BE}$。\n            *   计算 $\\|\\mathbf{u}^1_{BE}\\|_2$。\n            *   计算 $g_{\\mathrm{BE,emp}} = \\|\\mathbf{u}^1_{BE}\\|_2 / \\|\\mathbf{u}^0\\|_2$。\n            *   **Crank-Nicolson 步：**\n                *   首先，计算右侧向量 $\\mathbf{rhs} = (I + \\frac{\\kappa \\Delta t}{2(\\Delta x)^2} A) \\mathbf{u}^0$。\n                *   然后，求解线性系统 $(I - \\frac{\\kappa \\Delta t}{2(\\Delta x)^2} A) \\mathbf{u}^1_{CN} = \\mathbf{rhs}$ 以得到 $\\mathbf{u}^1_{CN}$。\n            *   计算 $\\|\\mathbf{u}^1_{CN}\\|_2$。\n            *   计算 $g_{\\mathrm{CN,emp}} = \\|\\mathbf{u}^1_{CN}\\|_2 / \\|\\mathbf{u}^0\\|_2$。\n\n此过程为每个测试用例提供了所需的四个量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes theoretical and empirical numerical dissipation factors for Backward Euler\n    and Crank-Nicolson schemes for the 1D heat equation.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, N, kappa, dt, m)\n        (1.0, 63, 1.0, 0.01, 1),\n        (1.0, 63, 1.0, 0.01, 63),\n        (1.0, 63, 0.5, 1e-6, 32),\n        (1.0, 3, 1.0, 0.1, 1),\n        (2.0, 63, 2.0, 0.5, 22),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, kappa, dt, m = case\n\n        # Physical and discretization parameters\n        dx = L / (N + 1)\n        j_indices = np.arange(1, N + 1)\n\n        # --- Theoretical Dissipation Factor Calculation ---\n        \n        # Eigenvalue of the scaled discrete Laplacian M = (kappa/dx^2) * A for mode m\n        # lambda_m = -4 * sin^2(m*pi/(2*(N+1))) is the eigenvalue of A.\n        sin_term_sq = np.sin(m * np.pi / (2 * (N + 1)))**2\n        mu_m = -4 * kappa / (dx**2) * sin_term_sq\n\n        # Theoretical amplification factor for Backward Euler\n        # g_be = 1 / (1 - dt * mu_m)\n        g_be_th = 1.0 / (1.0 - dt * mu_m)\n\n        # Theoretical amplification factor for Crank-Nicolson\n        # g_cn = (1 + dt * mu_m / 2) / (1 - dt * mu_m / 2)\n        # The dissipation factor is the magnitude.\n        g_cn_th = np.abs((1.0 + dt * mu_m / 2.0) / (1.0 - dt * mu_m / 2.0))\n\n        # --- Empirical Dissipation Factor Calculation ---\n        \n        # Initial condition: discrete sine mode (eigenvector of the discrete Laplacian)\n        u0 = np.sin(m * np.pi * j_indices / (N + 1))\n        norm_u0 = np.linalg.norm(u0)\n\n        # Build the discrete Laplacian matrix A for N interior points\n        # A is an N x N tridiagonal matrix with (-2, 1, 1) entries\n        main_diag = -2.0 * np.ones(N)\n        off_diag = np.ones(N - 1)\n        A = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n        \n        I = np.identity(N)\n\n        # 1. Backward Euler (BE)\n        # (I - dt * kappa / dx^2 * A) u_1 = u_0\n        c_be = kappa * dt / (dx**2)\n        M_be = I - c_be * A\n        u1_be = np.linalg.solve(M_be, u0)\n        norm_u1_be = np.linalg.norm(u1_be)\n        g_be_emp = norm_u1_be / norm_u0\n\n        # 2. Crank-Nicolson (CN)\n        # (I - dt/2 * kappa / dx^2 * A) u_1 = (I + dt/2 * kappa / dx^2 * A) u_0\n        c_cn = kappa * dt / (2 * dx**2)\n        LHS_cn = I - c_cn * A\n        RHS_cn_matrix = I + c_cn * A\n        rhs_cn_vector = RHS_cn_matrix @ u0\n        u1_cn = np.linalg.solve(LHS_cn, rhs_cn_vector)\n        norm_u1_cn = np.linalg.norm(u1_cn)\n        g_cn_emp = norm_u1_cn / norm_u0\n        \n        # Store results in the specified order\n        results.append([g_cn_emp, g_be_emp, g_cn_th, g_be_th])\n\n    # Final print statement in the exact required format.\n    # The format string ensures that nested lists are printed correctly.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```", "id": "3604206"}, {"introduction": "你如何确定自己编写的复杂数值代码是正确的？最后的这个练习将介绍“制造解方法”（Method of Manufactured Solutions, MMS），这是一种强有力的代码验证技术。通过设计一个具有已知精确解的问题，你将能够通过实验测量你所实现的向后欧拉和克兰克-尼科尔森格式的收敛阶，并检验它们是否与理论预期相符。这是建立对任何科学模拟工具信心的关键一步 [@problem_id:3604151]。", "problem": "考虑一个均匀介质中的一维热传导方程，其热扩散系数为 $\\kappa$，空间域为 $x \\in [0,1]$，时间区间为 $t \\in [0,T]$，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\kappa \\frac{\\partial^2 u}{\\partial x^2}(x,t) + f(x,t),\n$$\n该方程服从狄利克雷边界条件和一个由人工解法选择的初始条件。定义人工解\n$$\nu_{\\mathrm{exact}}(x,t) = e^{-t}\\sin(\\pi x)\n$$\n并推导强迫项 $f(x,t)$，使得对于给定的 $\\kappa$，$u_{\\mathrm{exact}}(x,t)$ 精确满足热方程。对所有 $t$ 施加狄利克雷边界条件 $u(0,t) = u(1,t) = 0$，以及初始条件 $u(x,0) = u_{\\mathrm{exact}}(x,0)$。\n\n你的任务是使用空间二阶中心有限差分，为空间离散化问题实现两种隐式时间步进格式：\n- Backward Euler（时间上一阶精确）。\n- Crank–Nicolson（时间上二阶精确）。\n\n使用一个包含 $N$ 个内部点的均匀网格，网格间距为 $h = \\frac{1}{N+1}$，时间点为 $t_n = n \\Delta t$, $n=0,1,\\dots,\\lfloor T/\\Delta t \\rfloor$。组装与齐次狄利克雷边界条件下 $\\frac{\\partial^2 u}{\\partial x^2}$ 的中心有限差分近似相一致的标准二阶导数矩阵。在每个时间步，与人工解一致地施加强迫项和边界条件。\n\n将最终时间 $T$ 的离散 $\\ell^2$-范数误差定义为\n$$\nE(h,\\Delta t;\\kappa,\\text{scheme}) = \\left( h \\sum_{i=1}^{N} \\left( u_i^{\\text{num}}(T) - u_{\\mathrm{exact}}(x_i,T) \\right)^2 \\right)^{1/2},\n$$\n其中 $x_i = i h$，$u_i^{\\text{num}}(T)$ 是在 $x_i$ 和时间 $T$ 的数值近似解。\n\n经验收敛率定义为\n$$\np_{\\Delta t} = \\frac{\\log\\left( E(h,\\Delta t_1)/E(h,\\Delta t_2) \\right)}{\\log\\left( \\Delta t_1 / \\Delta t_2 \\right)},\\quad\np_{h} = \\frac{\\log\\left( E(h_1,\\Delta t)/E(h_2,\\Delta t) \\right)}{\\log\\left( h_1 / h_2 \\right)},\n$$\n分别对应于固定 $h$ 并细化 $\\Delta t$ 时，以及固定 $\\Delta t$ 并细化 $h$ 时。\n\n实现这些格式并为以下测试套件计算经验收敛率。所有量均为无量纲；将所有数值结果报告为无量纲浮点数。\n\n测试套件：\n1. Backward Euler 时间加密（“理想情况”）：$\\kappa = 0.35$，$T = 0.2$，$N = 1000$（因此 $h = \\frac{1}{1001}$ 固定），$\\Delta t_1 = 0.1$，$\\Delta t_2 = 0.05$。计算 Backward Euler 的 $p_{\\Delta t}$。\n2. Backward Euler 空间加密（“理想情况”）：$\\kappa = 0.35$，$T = 0.2$，$\\Delta t = 5\\times 10^{-5}$ 固定，$N_1 = 50$，$N_2 = 100$（因此 $h_1 = \\frac{1}{51}$，$h_2 = \\frac{1}{101}$）。计算 Backward Euler 的 $p_{h}$。\n3. Crank–Nicolson 时间加密（“理想情况”）：$\\kappa = 0.35$，$T = 0.2$，$N = 1000$ 固定，$\\Delta t_1 = 0.1$，$\\Delta t_2 = 0.05$。计算 Crank–Nicolson 的 $p_{\\Delta t}$。\n4. Backward Euler 在污染区域下的空间加密（“边界情况”）：$\\kappa = 0.35$，$T = 0.2$，$\\Delta t = 0.05$ 固定（时间误差不可忽略），$N_1 = 20$，$N_2 = 40$。计算 Backward Euler 的 $p_{h}$ 并观察与预期空间阶数的偏差。\n5. Backward Euler 在强扩散下的时间加密（“边界情况”）：$\\kappa = 5.0$，$T = 0.2$，$N = 1000$ 固定，$\\Delta t_1 = 0.1$，$\\Delta t_2 = 0.05$。计算 Backward Euler 的 $p_{\\Delta t}$ 以评估在刚度增加情况下时间阶数的稳健性。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按上述五个测试用例顺序排列的结果。例如：“[result1,result2,result3,result4,result5]”。", "solution": "该问题要求使用人工解法实现并验证用于一维热方程的隐式有限差分格式。\n\n**1. 问题建模与强迫项推导**\n\n控制偏微分方程 (PDE) 是带有源项 $f(x,t)$ 的热方程：\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\kappa \\frac{\\partial^2 u}{\\partial x^2}(x,t) + f(x,t)\n$$\n在空间域 $x \\in [0,1]$ 和时间区间 $t \\in [0,T]$ 上。热扩散系数用 $\\kappa$ 表示。\n\n为验证数值格式，我们使用人工解法。我们假设一个精确解，并将其代入 PDE 以推导相应的强迫项 $f(x,t)$。所选的人工解为：\n$$\nu_{\\mathrm{exact}}(x,t) = e^{-t}\\sin(\\pi x)\n$$\n我们计算 $u_{\\mathrm{exact}}(x,t)$ 的偏导数：\n$$\n\\frac{\\partial u_{\\mathrm{exact}}}{\\partial t} = -e^{-t}\\sin(\\pi x)\n$$\n$$\n\\frac{\\partial u_{\\mathrm{exact}}}{\\partial x} = \\pi e^{-t}\\cos(\\pi x) \\implies \\frac{\\partial^2 u_{\\mathrm{exact}}}{\\partial x^2} = -\\pi^2 e^{-t}\\sin(\\pi x)\n$$\n将这些代入热方程，我们求解 $f(x,t)$：\n$$\nf(x,t) = \\frac{\\partial u_{\\mathrm{exact}}}{\\partial t} - \\kappa \\frac{\\partial^2 u_{\\mathrm{exact}}}{\\partial x^2} = -e^{-t}\\sin(\\pi x) - \\kappa(-\\pi^2 e^{-t}\\sin(\\pi x))\n$$\n$$\nf(x,t) = (\\kappa \\pi^2 - 1)e^{-t}\\sin(\\pi x)\n$$\n边界和初始条件由 $u_{\\mathrm{exact}}(x,t)$ 推导得出：\n-   初始条件 ($t=0$): $u(x,0) = u_{\\mathrm{exact}}(x,0) = e^{-0}\\sin(\\pi x) = \\sin(\\pi x)$。\n-   边界条件 ($x=0, x=1$):\n    -   $u(0,t) = u_{\\mathrm{exact}}(0,t) = e^{-t}\\sin(0) = 0$。\n    -   $u(1,t) = u_{\\mathrm{exact}}(1,t) = e^{-t}\\sin(\\pi) = 0$。\n如问题所述，这些是齐次狄利克雷边界条件。\n\n**2. 数值离散化**\n\n我们在均匀网格上对问题进行离散化。空间域 $[0,1]$ 被划分为 $N+1$ 个宽度为 $h = \\frac{1}{N+1}$ 的子区间，从而产生 $N$ 个内部网格点 $x_i = i h$，$i=1, 2, \\dots, N$。时间域被离散为大小为 $\\Delta t$ 的步长，时间点为 $t_n = n \\Delta t$。\n\n**2.1. 空间离散化**\n\n空间二阶导数 $\\frac{\\partial^2 u}{\\partial x^2}$ 在每个内部网格点 $x_i$ 处使用二阶精确的中心有限差分进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i, t) \\approx \\frac{u(x_{i-1}, t) - 2u(x_i, t) + u(x_{i+1}, t)}{h^2}\n$$\n设 $\\mathbf{u}(t)$ 为内部网格点上近似解的向量，$\\mathbf{u}(t) = [u_1(t), u_2(t), \\dots, u_N(t)]^T$，其中 $u_i(t) \\approx u(x_i, t)$。将此离散化应用于 PDE，得到一个包含 $N$ 个耦合常微分方程（ODEs）的方程组：\n$$\n\\frac{d\\mathbf{u}}{dt} = \\frac{\\kappa}{h^2} A \\mathbf{u}(t) + \\mathbf{f}(t)\n$$\n这里，$\\mathbf{f}(t) = [f(x_1,t), f(x_2,t), \\dots, f(x_N,t)]^T$ 是在网格点上求值的强迫项向量。矩阵 $A$ 是表示带有齐次狄利克雷边界条件的离散拉普拉斯算子的 $N \\times N$ 三对角矩阵：\n$$\nA = \\begin{pmatrix}\n-2  1  0  \\dots  0 \\\\\n1  -2  1  \\dots  0 \\\\\n0  1  -2  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  1 \\\\\n0  \\dots  0  1  -2\n\\end{pmatrix}\n$$\n\n**2.2. 时间离散化**\n\n设 $\\mathbf{u}^n$ 为时间 $t_n$ 处的数值解向量。\n\n**Backward Euler (BE):** 这是一种一阶精确的隐式格式。时间导数由后向差分近似，右侧项在下一个时间步 $t_{n+1}$ 进行求值：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{\\kappa}{h^2} A \\mathbf{u}^{n+1} + \\mathbf{f}^{n+1}\n$$\n重新整理以求解未知向量 $\\mathbf{u}^{n+1}$，我们得到一个线性系统：\n$$\n\\left(I - \\frac{\\kappa \\Delta t}{h^2} A\\right) \\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\mathbf{f}^{n+1}\n$$\n其中 $I$ 是 $N \\times N$ 单位矩阵。左侧的矩阵是三对角的、对称的且正定的，这使得可以使用带状线性求解器进行高效求解。\n\n**Crank–Nicolson (CN):** 这是一种二阶精确的隐式格式，它对时间 $t_n$ 和 $t_{n+1}$ 的右侧项求平均值：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2}\\left(\\frac{\\kappa}{h^2} A \\mathbf{u}^{n+1} + \\mathbf{f}^{n+1}\\right) + \\frac{1}{2}\\left(\\frac{\\kappa}{h^2} A \\mathbf{u}^{n} + \\mathbf{f}^{n}\\right)\n$$\n将包含 $\\mathbf{u}^{n+1}$ 的项分到左边，已知项分到右边，得到线性系统：\n$$\n\\left(I - \\frac{\\kappa \\Delta t}{2h^2} A\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{\\kappa \\Delta t}{2h^2} A\\right) \\mathbf{u}^{n} + \\frac{\\Delta t}{2}(\\mathbf{f}^{n+1} + \\mathbf{f}^n)\n$$\n与 BE 格式类似，左侧的矩阵是三对角的，该系统可以在每个时间步高效求解。\n\n**3. 误差分析与算法流程**\n\nBE 的总离散误差预期为 $O(\\Delta t, h^2)$，CN 的总离散误差预期为 $O(\\Delta t^2, h^2)$。我们使用最终模拟时间 $T^* = \\lfloor T/\\Delta t \\rfloor \\Delta t$ 的离散 $\\ell^2$-范数来量化误差：\n$$\nE(h,\\Delta t) = \\left( h \\sum_{i=1}^{N} \\left( u_i^{\\text{num}}(T^*) - u_{\\mathrm{exact}}(x_i,T^*) \\right)^2 \\right)^{1/2}\n$$\n计算经验收敛率以验证理论精度阶。对于固定 $h$ 和两个时间步长 $\\Delta t_1, \\Delta t_2$ 的时间加密：\n$$\np_{\\Delta t} = \\frac{\\log\\left( E(h,\\Delta t_1)/E(h,\\Delta t_2) \\right)}{\\log\\left( \\Delta t_1 / \\Delta t_2 \\right)}\n$$\n对于固定 $\\Delta t$ 和两个网格间距 $h_1, h_2$ 的空间加密：\n$$\np_{h} = \\frac{\\log\\left( E(h_1,\\Delta t)/E(h_2,\\Delta t) \\right)}{\\log\\left( h_1 / h_2 \\right)}\n$$\n算法流程如下：\n1.  初始化参数：$\\kappa$, $T$, $N$, $\\Delta t$。\n2.  建立空间网格 ($h, x_i$) 并设置初始解 $\\mathbf{u}^0 = \\sin(\\pi \\mathbf{x})$。\n3.  为所选格式（BE 或 CN）构建系统矩阵。由于该矩阵在所有时间步中都是恒定的，因此只需组装一次。\n4.  从 $n=0$ 迭代到 $N_t-1$，其中 $N_t = \\lfloor T/\\Delta t \\rfloor$：\n    a. 组装右侧向量，该向量取决于前一时间步的解 $\\mathbf{u}^n$ 和强迫项 $\\mathbf{f}$。\n    b. 求解得到的三对角线性系统以获得 $\\mathbf{u}^{n+1}$。\n5.  循环结束后，通过将数值解 $\\mathbf{u}^{N_t}$ 与精确解 $u_{\\mathrm{exact}}(x_i, T^*)$ 进行比较来计算最终误差 $E$。\n6.  使用不同运行计算出的误差，为每个测试用例计算经验收敛率 $p_{\\Delta t}$ 或 $p_h$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def exact_solution(x, t):\n        \"\"\"Computes the exact manufactured solution.\"\"\"\n        return np.exp(-t) * np.sin(np.pi * x)\n\n    def forcing_term(x, t, kappa):\n        \"\"\"Computes the forcing term for the manufactured solution.\"\"\"\n        return (kappa * np.pi**2 - 1.0) * np.exp(-t) * np.sin(np.pi * x)\n\n    def run_simulation(scheme, kappa, T, N, dt):\n        \"\"\"\n        Runs a single simulation of the 1D heat equation.\n\n        Args:\n            scheme (str): 'BE' for Backward Euler or 'CN' for Crank-Nicolson.\n            kappa (float): Thermal diffusivity.\n            T (float): Final time.\n            N (int): Number of interior spatial grid points.\n            dt (float): Time step size.\n\n        Returns:\n            float: The discrete l2-norm of the error at the final time.\n        \"\"\"\n        h = 1.0 / (N + 1)\n        x = np.linspace(h, 1.0 - h, N, dtype=np.float64)\n        \n        num_steps = int(np.floor(T / dt))\n        if num_steps == 0:\n            # If dt is larger than T, no steps are taken. The error is then computed\n            # at t=0, which is zero. This case may arise with large dt values.\n            return 0.0\n            \n        final_time = num_steps * dt\n\n        # Initial condition\n        u = exact_solution(x, 0.0)\n\n        if scheme == 'BE':\n            # System: (I - alpha * A) u_n+1 = u_n + dt * f_n+1\n            alpha = dt * kappa / h**2\n            # LHS matrix for solve_banded, shape (3, N) for (l=1, u=1)\n            M_diags = np.zeros((3, N), dtype=np.float64)\n            M_diags[0, 1:] = -alpha      # Super-diagonal\n            M_diags[1, :] = 1.0 + 2.0 * alpha  # Main diagonal\n            M_diags[2, :-1] = -alpha     # Sub-diagonal\n            \n            for n in range(num_steps):\n                t_next = (n + 1) * dt\n                f_next = forcing_term(x, t_next, kappa)\n                rhs = u + dt * f_next\n                # solve_banded solves A*x=b, where A is given by 'M_diags'\n                u = solve_banded((1, 1), M_diags, rhs)\n                \n        elif scheme == 'CN':\n            # System: (I - alpha * A) u_n+1 = (I + alpha * A) u_n + dt/2 * (f_n+1 + f_n)\n            # where alpha = dt * kappa / (2 * h^2)\n            alpha = dt * kappa / (2.0 * h**2)\n            \n            # LHS matrix M_CN\n            M_CN_diags = np.zeros((3, N), dtype=np.float64)\n            M_CN_diags[0, 1:] = -alpha\n            M_CN_diags[1, :] = 1.0 + 2.0 * alpha\n            M_CN_diags[2, :-1] = -alpha\n            \n            # Function to apply the RHS matrix N_CN = (I + alpha * A)\n            def apply_N_CN(vec):\n                res = (1.0 - 2.0 * alpha) * vec\n                res[1:] += alpha * vec[:-1]\n                res[:-1] += alpha * vec[1:]\n                return res\n\n            for n in range(num_steps):\n                t_curr = n * dt\n                t_next = (n + 1) * dt\n                \n                f_curr = forcing_term(x, t_curr, kappa)\n                f_next = forcing_term(x, t_next, kappa)\n                \n                rhs_u_part = apply_N_CN(u)\n                rhs_f_part = dt / 2.0 * (f_curr + f_next)\n                \n                rhs = rhs_u_part + rhs_f_part\n                u = solve_banded((1, 1), M_CN_diags, rhs)\n        else:\n            raise ValueError(f\"Unknown scheme: {scheme}\")\n            \n        u_exact_final = exact_solution(x, final_time)\n        \n        # Calculate discrete l2-norm of the error\n        error = np.sqrt(h * np.sum((u - u_exact_final)**2))\n        \n        return error\n\n    def compute_p_dt(err1, err2, dt1, dt2):\n        \"\"\"Computes temporal convergence rate.\"\"\"\n        if err2 == 0.0 or err1 == 0.0: return np.nan\n        return np.log(err1 / err2) / np.log(dt1 / dt2)\n\n    def compute_p_h(err1, err2, h1, h2):\n        \"\"\"Computes spatial convergence rate.\"\"\"\n        if err2 == 0.0 or err1 == 0.0: return np.nan\n        return np.log(err1 / err2) / np.log(h1 / h2)\n\n    test_cases = [\n        # 1. BE time refinement\n        {'type': 'p_dt', 'scheme': 'BE', 'kappa': 0.35, 'T': 0.2, 'N': 1000, 'dt1': 0.1, 'dt2': 0.05},\n        # 2. BE space refinement\n        {'type': 'p_h', 'scheme': 'BE', 'kappa': 0.35, 'T': 0.2, 'dt': 5e-5, 'N1': 50, 'N2': 100},\n        # 3. CN time refinement\n        {'type': 'p_dt', 'scheme': 'CN', 'kappa': 0.35, 'T': 0.2, 'N': 1000, 'dt1': 0.1, 'dt2': 0.05},\n        # 4. BE space refinement (contaminated)\n        {'type': 'p_h', 'scheme': 'BE', 'kappa': 0.35, 'T': 0.2, 'dt': 0.05, 'N1': 20, 'N2': 40},\n        # 5. BE time refinement (stiff)\n        {'type': 'p_dt', 'scheme': 'BE', 'kappa': 5.0, 'T': 0.2, 'N': 1000, 'dt1': 0.1, 'dt2': 0.05},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'p_dt':\n            err1 = run_simulation(case['scheme'], case['kappa'], case['T'], case['N'], case['dt1'])\n            err2 = run_simulation(case['scheme'], case['kappa'], case['T'], case['N'], case['dt2'])\n            rate = compute_p_dt(err1, err2, case['dt1'], case['dt2'])\n            results.append(rate)\n        elif case['type'] == 'p_h':\n            h1 = 1.0 / (case['N1'] + 1)\n            h2 = 1.0 / (case['N2'] + 1)\n            err1 = run_simulation(case['scheme'], case['kappa'], case['T'], case['N1'], case['dt'])\n            err2 = run_simulation(case['scheme'], case['kappa'], case['T'], case['N2'], case['dt'])\n            rate = compute_p_h(err1, err2, h1, h2)\n            results.append(rate)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3604151"}]}