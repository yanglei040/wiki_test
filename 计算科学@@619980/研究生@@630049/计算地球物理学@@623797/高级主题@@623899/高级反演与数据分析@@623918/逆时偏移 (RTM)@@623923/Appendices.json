{"hands_on_practices": [{"introduction": "实践是掌握逆时偏移（RTM）的基石。此练习将指导您从头开始构建一个频域RTM算法。您将从声波方程的频域形式——亥姆霍兹方程——出发，利用玻恩近似来模拟简单散射体产生的散射数据。核心任务是通过将源波场与反向传播的接收波场进行互相关来执行成像步骤，并通过多频率叠加来展示如何提高最终图像的带宽和分辨率[@problem_id:3613775]。", "problem": "使用单频亥姆霍兹方程，为二维恒定密度声学介质实现一个频域逆时偏移（RTM）成像实验。从恒定密度声波方程出发，推导一个适用于构建单散射体Born近似的频域公式。利用此公式定义背景波场的正演模拟算子、由慢度平方的局部扰动引起的散射场的二次源，以及通过相关型成像条件进行成像的伴随（反向传播）算子。\n\n您的程序必须构建计算网格，组装带有均匀狄利克雷边界条件和用于模拟弱吸收的微小复数位移的离散亥姆霍兹算子，求解正演场和伴随场，计算单个频率的图像，然后执行多频叠加，以近似时域图像的带宽和分辨率。每个测试用例的最终输出是一个标量度量，用于量化已知散射体位置处的峰旁瓣比。\n\n基本原理和定义：\n- 物理空间中的恒定密度声波方程由下式给出\n$$\n\\frac{\\partial^2 p(\\mathbf{x},t)}{\\partial t^2} - v(\\mathbf{x})^2 \\nabla^2 p(\\mathbf{x},t) = s(\\mathbf{x},t),\n$$\n其中 $p$ 是压力，$v$ 是波速（单位为 $\\mathrm{m/s}$），$\\nabla^2$ 是拉普拉斯算子，$s$ 是源项。\n- 在单频时谐假设 $p(\\mathbf{x},t) = \\Re\\{u(\\mathbf{x},\\omega) e^{-i \\omega t}\\}$ 下，角频率为 $\\omega$（单位为 $\\mathrm{rad/s}$），场 $u(\\mathbf{x},\\omega)$ 满足非齐次亥姆霍兹方程\n$$\n\\left(\\nabla^2 + \\omega^2 m(\\mathbf{x})\\right) u(\\mathbf{x},\\omega) = q(\\mathbf{x},\\omega),\n$$\n其中 $m(\\mathbf{x}) = v(\\mathbf{x})^{-2}$ 是慢度平方（单位为 $\\mathrm{s^2/m^2}$），$q$ 是频域源。\n- 对于相对于已知背景 $m_0(\\mathbf{x})$ 的慢度平方的微小扰动 $\\delta m(\\mathbf{x})$，一阶Born近似给出的散射场 $u_s$ 满足\n$$\n\\left(\\nabla^2 + \\omega^2 m_0(\\mathbf{x})\\right) u_s(\\mathbf{x},\\omega) = - \\omega^2 \\delta m(\\mathbf{x}) u_0(\\mathbf{x},\\omega),\n$$\n其中 $u_0$ 是背景场，满足\n$$\n\\left(\\nabla^2 + \\omega^2 m_0(\\mathbf{x})\\right) u_0(\\mathbf{x},\\omega) = q(\\mathbf{x},\\omega).\n$$\n\n离散化与数值设置：\n- 在大小为 $N_x \\times N_z = 50 \\times 50$ 的均匀笛卡尔网格上进行计算，网格间距为 $\\Delta x = \\Delta z = 10\\,\\mathrm{m}$。计算域具有均匀狄利克雷边界条件（边界上压力为零）。为了模拟弱吸收并减少人工反射，在质量项中使用一个复数位移，使得离散算子为\n$$\n\\mathbf{A}(\\omega) = \\mathbf{L} + \\omega^2 m_0 (1 - i \\eta)\\mathbf{I},\n$$\n其中 $\\mathbf{L}$ 是带有狄利克雷边界处理的标准五点离散拉普拉斯算子，$\\mathbf{I}$ 是单位矩阵，$\\eta = 0.05$ 是一个无量纲的阻尼参数。\n- 使用均匀背景速度 $v_0 = 2000\\,\\mathrm{m/s}$，因此 $m_0 = v_0^{-2}$（单位为 $\\mathrm{s^2/m^2}$）。\n- 在水平中心，地表下方一个网格单元处放置一个单点源。在代码中，使用从零开始的索引，其位置为 $(i_x,i_z) = (N_x/2, 1)$。将源在右端项 $q$ 中建模为单位幅值的克罗内克δ函数。\n- 在地表下方一个网格单元处的水平线上放置接收器，覆盖除边界外的每一网格列。即，在 $i_z=1$ 处，对于 $i_x \\in \\{1,2,\\dots,N_x-2\\}$。\n- 在区域中心的索引 $(i_x,i_z) = (N_x/2, N_z/2)$ 处放置一个单一的局部慢度平方扰动，其幅度为\n$$\n\\delta m(\\mathbf{x}_\\star) = \\alpha m_0,\\quad \\alpha = 0.02,\n$$\n其他地方为零。这定义了一个单散射体Born模型。\n\n正演模拟与成像：\n- 对于给定的频率 $f$（单位为 $\\mathrm{Hz}$），计算 $\\omega = 2\\pi f$。通过求解 $\\mathbf{A}(\\omega)\\mathbf{u}_0 = \\mathbf{q}$ 得到背景场 $\\mathbf{u}_0$。\n- 形成二次源向量 $\\mathbf{s}_\\mathrm{sc} = -\\omega^2\\,\\delta \\mathbf{m} \\odot \\mathbf{u}_0$，其中 $\\odot$ 表示逐点乘法，$\\delta \\mathbf{m}$ 是离散化的扰动场。通过求解 $\\mathbf{A}(\\omega)\\mathbf{u}_s = \\mathbf{s}_\\mathrm{sc}$ 得到散射场 $\\mathbf{u}_s$。\n- 从 $\\mathbf{u}_s$ 中提取接收器索引处的记录数据向量 $\\mathbf{d}$。\n- 通过求解 $\\mathbf{A}(\\omega)\\boldsymbol{\\lambda} = \\mathbf{r}$ 来反向传播数据，其中 $\\mathbf{r}$ 是一个零向量，但在接收器位置处的条目等于记录数据（建模为点注入）。\n- 通过相关型成像条件形成单频图像\n$$\n\\mathbf{I}_f = \\Re\\left\\{\\overline{\\mathbf{u}_0} \\odot \\boldsymbol{\\lambda}\\right\\}。\n$$\n\n多频叠加：\n- 对于频率列表 $\\{f_k\\}$，为每个 $k$ 计算 $\\mathbf{I}_{f_k}$，并通过简单求和进行叠加\n$$\n\\mathbf{I}_\\mathrm{stack} = \\sum_k \\mathbf{I}_{f_k}。\n$$\n\n可测试输出的度量：\n- 设 $\\mathbf{x}_\\star$ 表示真实散射体的网格索引。将在频率 $f$ 处的峰旁瓣比定义为\n$$\nR(f) = \\frac{\\left|\\mathbf{I}_f(\\mathbf{x}_\\star)\\right|}{\\max_{\\mathbf{x} \\in \\Omega \\setminus \\mathcal{N}} \\left|\\mathbf{I}_f(\\mathbf{x})\\right| + \\varepsilon},\n$$\n其中 $\\Omega$ 是所有网格点的集合，$\\mathcal{N}$ 是围绕 $\\mathbf{x}_\\star$ 的一个排除邻域，在 $\\ell_\\infty$ 意义下半径为 $r_\\mathrm{exc} = 3$ 个网格单元，$\\varepsilon = 10^{-12}$ 是一个小的稳定子。对于多频叠加，通过将 $\\mathbf{I}_f$ 替换为 $\\mathbf{I}_\\mathrm{stack}$ 来类似地定义 $R_\\mathrm{stack}$。\n\n单位与数值精度：\n- 所有物理输入均使用上述单位。度量 $R$ 是无量纲的，必须以浮点数形式报告，并四舍五入到小数点后六位。\n\n测试套件：\n- 使用以下四个测试用例，每个用例产生一个标量结果：\n    - 用例1（单频）：$f = 25\\,\\mathrm{Hz}$。\n    - 用例2（单频）：$f = 35\\,\\mathrm{Hz}$。\n    - 用例3（多频叠加）：$f \\in \\{20\\,\\mathrm{Hz}, 25\\,\\mathrm{Hz}, 30\\,\\mathrm{Hz}, 35\\,\\mathrm{Hz}\\}$。\n    - 用例4（边界情况，低频）：$f = 10\\,\\mathrm{Hz}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含四个用例的结果，格式为方括号括起来的逗号分隔列表，例如\n$[\\;r_1,r_2,r_3,r_4\\;]$,\n其中 $r_j$ 是按上述规定四舍五入的四个浮点度量值，不打印任何额外文本。", "solution": "我们从恒定密度声波方程开始\n$$\n\\frac{\\partial^2 p(\\mathbf{x},t)}{\\partial t^2} - v(\\mathbf{x})^2 \\nabla^2 p(\\mathbf{x},t) = s(\\mathbf{x},t).\n$$\n对于角频率为 $\\omega$ 的时谐场，使用假设 $p(\\mathbf{x},t) = \\Re\\{u(\\mathbf{x},\\omega) e^{-i \\omega t}\\}$，代入后得到\n$$\n(-\\omega^2) u(\\mathbf{x},\\omega) - v(\\mathbf{x})^2 \\nabla^2 u(\\mathbf{x},\\omega) = s_\\omega(\\mathbf{x}),\n$$\n或等效地\n$$\n\\left(\\nabla^2 + \\omega^2 m(\\mathbf{x})\\right) u(\\mathbf{x},\\omega) = q(\\mathbf{x},\\omega),\n$$\n其中 $m(\\mathbf{x}) = v(\\mathbf{x})^{-2}$ 且 $q(\\mathbf{x},\\omega) = -v(\\mathbf{x})^{-2} s_\\omega(\\mathbf{x})$。在表示为背景场加上一个小扰动的介质中，$m(\\mathbf{x}) = m_0(\\mathbf{x}) + \\delta m(\\mathbf{x})$ 且 $\\|\\delta m\\| \\ll \\|m_0\\|$，背景场 $u_0$ 和散射场 $u_s$ 满足以下方程组\n$$\n\\left(\\nabla^2 + \\omega^2 m_0\\right) u_0 = q,\\qquad\n\\left(\\nabla^2 + \\omega^2 m_0\\right) u_s = -\\omega^2 \\delta m\\, u_0,\n$$\n这就是一阶Born近似。散射方程的右端项扮演了等效源的角色，该源由扰动与背景场的相互作用产生。\n\n对于逆时偏移（RTM），使用正演模拟算子的伴随算子将记录数据反向传播到成像空间。在频域中，对于实数背景 $m_0$ 和均匀边界条件，亥姆霍兹算子除了边界辐射条件外是自伴的。在数值上，为了减轻来自截断域的虚假反射，我们添加一个小的复数位移来模拟吸收，从而形成一个算子\n$$\n\\mathbf{A}(\\omega) = \\mathbf{L} + \\omega^2 m_0 (1 - i \\eta)\\mathbf{I},\n$$\n其中 $\\mathbf{L}$ 是五点离散拉普拉斯算子，$\\mathbf{I}$ 是单位矩阵，$\\eta > 0$ 是一个小数。这在离散设置中保持了一致的伴随作用。我们在间距为 $\\Delta x$ 和 $\\Delta z$ 的规则 $N_x \\times N_z$ 网格上进行离散化，并通过将与边界节点对应的行替换为单位行来强制执行均匀狄利克雷边界条件，这将边界场设置为零。\n\n给定地表下方一个网格单元处的单个震源和沿浅层水平线的接收器，对于给定的频率 $f$（其中 $\\omega = 2\\pi f$），我们按以下步骤操作：\n1. 从 $\\mathbf{L}$ 和复数位移质量项 $\\omega^2 m_0 (1 - i \\eta)$ 组装 $\\mathbf{A}(\\omega)$。带有狄利克雷边界的五点拉普拉斯算子使用以下模板\n$$\n\\left(\\mathbf{L} u\\right)_{i,j} = \\frac{u_{i+1,j} - 2 u_{i,j} + u_{i-1,j}}{\\Delta x^2} + \\frac{u_{i,j+1} - 2 u_{i,j} + u_{i,j-1}}{\\Delta z^2},\n$$\n仅应用于内部节点；边界值通过单位行设置为零。\n2. 求解背景场 $\\mathbf{A}(\\omega)\\mathbf{u}_0 = \\mathbf{q}$，其中 $\\mathbf{q}$ 是在震源网格索引处的单位幅值离散δ函数。\n3. 构建离散Born源 $\\mathbf{s}_\\mathrm{sc} = -\\omega^2 \\delta \\mathbf{m} \\odot \\mathbf{u}_0$ 并求解 $\\mathbf{A}(\\omega)\\mathbf{u}_s = \\mathbf{s}_\\mathrm{sc}$。\n4. 通过在接收器位置采样 $\\mathbf{u}_s$ 来提取数据向量 $\\mathbf{d}$。\n5. 通过在接收器位置注入记录数据进行反向传播：形成 $\\mathbf{r}$，该向量处处为零，但在接收器索引处等于 $\\mathbf{d}$，然后求解 $\\mathbf{A}(\\omega)\\boldsymbol{\\lambda} = \\mathbf{r}$。\n6. 应用相关型成像条件\n$$\n\\mathbf{I}_f = \\Re\\{\\overline{\\mathbf{u}_0} \\odot \\boldsymbol{\\lambda}\\}。\n$$\n\n为了近似时域成像的宽带特性，通过对一组频率 $\\{f_k\\}$ 的单频图像求和来进行多频叠加，\n$$\n\\mathbf{I}_\\mathrm{stack} = \\sum_k \\mathbf{I}_{f_k}。\n$$\n这种叠加通过在真实散射体位置的相长干涉和在其他地方的部分相消来减少与频率相关的旁瓣并提高分辨率。\n\n为了进行定量评估，我们计算峰旁瓣比\n$$\nR(f) = \\frac{\\left|\\mathbf{I}_f(\\mathbf{x}_\\star)\\right|}{\\max_{\\mathbf{x}\\in \\Omega \\setminus \\mathcal{N}} \\left|\\mathbf{I}_f(\\mathbf{x})\\right| + \\varepsilon},\n$$\n其中排除邻域 $\\mathcal{N}$ 的半径为 $r_\\mathrm{exc} = 3$ 个网格单元，围绕真实位置 $\\mathbf{x}_\\star$，稳定子 $\\varepsilon = 10^{-12}$。当 $\\mathbf{I}_f$ 被 $\\mathbf{I}_\\mathrm{stack}$ 替换时，同样的公式定义了 $R_\\mathrm{stack}$。\n\n算法设计选择与数值考虑：\n- 均匀狄利克雷边界条件和复数位移 $\\eta = 0.05$ 减少了非物理边界反射，同时保持了求解器的简单和稳健。\n- 网格间距 $\\Delta x = \\Delta z = 10\\,\\mathrm{m}$ 和高达 $f = 35\\,\\mathrm{Hz}$ 的频率，对于 $v_0 = 2000\\,\\mathrm{m/s}$ 的速度，确保了每个波长至少有几个网格点，从而保证了亥姆霍兹算子的合理离散化。\n- Born扰动幅度 $\\alpha = 0.02$ 足够小，与线性化假设一致，同时能产生可测量的散射信号。\n- 反向传播的右端项 $\\mathbf{r}$ 直接在接收器位置插入记录的压力；由于算子是带有少量吸收的复对称算子，这模拟了RTM所需的伴随作用。\n- 图像取为相关 $\\overline{\\mathbf{u}_0} \\odot \\boldsymbol{\\lambda}$ 的实部以消除相位模糊，这与常规的单频成像条件一致。\n\n测试套件解释：\n- 用例1（$f = 25\\,\\mathrm{Hz}$）提供了一个中频段的单频图像，具有中等的分辨率和对比度。\n- 用例2（$f = 35\\,\\mathrm{Hz}$）提高了分辨率；由于波长更短、聚焦更好，我们期望峰旁瓣比会增加。\n- 用例3（在 $f \\in \\{20,25,30,35\\}\\,\\mathrm{Hz}$ 上叠加）近似了更宽的带宽；我们期望在真实位置出现相长叠加，同时部分旁瓣相消，从而相对于大多数单频情况提高该比率。\n- 用例4（$f = 10\\,\\mathrm{Hz}$）代表了一个低频、长波长的情形；我们期望分辨率较差，因此比率较低。\n\n最终程序将组装算子，计算指定用例的场和图像，评估度量 $R$，将每个结果四舍五入到小数点后六位，并以要求的列表格式打印单行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef build_helmholtz_operator(nx, nz, dx, dz, m0, omega, eta):\n    \"\"\"\n    Build 2D Helmholtz operator with homogeneous Dirichlet boundary conditions\n    and a small complex shift (1 - i*eta) on the mass term.\n    \"\"\"\n    n = nx * nz\n    rows = []\n    cols = []\n    data = []\n    k2 = (omega ** 2) * m0 * (1.0 - 1j * eta)\n\n    inv_dx2 = 1.0 / (dx * dx)\n    inv_dz2 = 1.0 / (dz * dz)\n\n    def idx(ix, iz):\n        return iz * nx + ix\n\n    for iz in range(nz):\n        for ix in range(nx):\n            p = idx(ix, iz)\n            # Boundary nodes: enforce u = 0 by identity row\n            if ix == 0 or ix == nx - 1 or iz == 0 or iz == nz - 1:\n                rows.append(p); cols.append(p); data.append(1.0 + 0j)\n            else:\n                # Center\n                diag = -2.0 * inv_dx2 - 2.0 * inv_dz2 + k2\n                rows.append(p); cols.append(p); data.append(diag)\n                # Left neighbor\n                rows.append(p); cols.append(idx(ix - 1, iz)); data.append(inv_dx2)\n                # Right neighbor\n                rows.append(p); cols.append(idx(ix + 1, iz)); data.append(inv_dx2)\n                # Up neighbor\n                rows.append(p); cols.append(idx(ix, iz - 1)); data.append(inv_dz2)\n                # Down neighbor\n                rows.append(p); cols.append(idx(ix, iz + 1)); data.append(inv_dz2)\n\n    A = csr_matrix((np.array(data, dtype=np.complex128),\n                    (np.array(rows, dtype=np.int32), np.array(cols, dtype=np.int32))),\n                   shape=(n, n))\n    return A\n\ndef solve_field(A, rhs):\n    return spsolve(A, rhs)\n\ndef rtm_single_frequency(f_hz, nx, nz, dx, dz, v0, eta, alpha, src_ix, src_iz, rec_iz, scat_ix, scat_iz):\n    \"\"\"\n    Compute single-frequency RTM image and return the peak-to-sidelobe ratio at the true scatterer.\n    \"\"\"\n    omega = 2.0 * np.pi * f_hz\n    m0 = 1.0 / (v0 * v0)\n\n    # Build operator\n    A = build_helmholtz_operator(nx, nz, dx, dz, m0, omega, eta)\n\n    n = nx * nz\n    def lin(ix, iz):\n        return iz * nx + ix\n\n    # Source RHS\n    q = np.zeros(n, dtype=np.complex128)\n    q[lin(src_ix, src_iz)] = 1.0 + 0j\n\n    # Background field\n    u0 = solve_field(A, q)\n\n    # Born perturbation\n    dm = np.zeros(n, dtype=np.complex128)\n    dm[lin(scat_ix, scat_iz)] = alpha * m0\n\n    # Scattered field RHS\n    s_sc = - (omega ** 2) * dm * u0\n    us = solve_field(A, s_sc)\n\n    # Receivers along a horizontal line rec_iz at all interior ix\n    rec_ixs = list(range(1, nx - 1))\n    rec_ids = [lin(ix, rec_iz) for ix in rec_ixs]\n    d = us[rec_ids].copy()\n\n    # Back-propagation RHS: inject recorded data at receivers\n    r = np.zeros(n, dtype=np.complex128)\n    r[rec_ids] = d\n\n    lamb = solve_field(A, r)\n\n    # Imaging condition\n    I = np.real(np.conj(u0) * lamb)\n\n    # Peak-to-sidelobe ratio at true scatterer\n    I2d = I.reshape(nz, nx)\n    peak_val = abs(I2d[scat_iz, scat_ix])\n\n    # Exclude a neighborhood around the true location\n    r_exc = 3\n    mask = np.ones((nz, nx), dtype=bool)\n    i0 = max(0, scat_iz - r_exc)\n    i1 = min(nz, scat_iz + r_exc + 1)\n    j0 = max(0, scat_ix - r_exc)\n    j1 = min(nx, scat_ix + r_exc + 1)\n    mask[i0:i1, j0:j1] = False\n\n    side_max = np.max(np.abs(I2d[mask])) if np.any(mask) else 0.0\n    eps = 1e-12\n    ratio = peak_val / (side_max + eps)\n    return ratio, I2d\n\ndef rtm_stack_frequencies(f_list, nx, nz, dx, dz, v0, eta, alpha, src_ix, src_iz, rec_iz, scat_ix, scat_iz):\n    \"\"\"\n    Compute multi-frequency stacked RTM image and return the peak-to-sidelobe ratio at the true scatterer.\n    \"\"\"\n    I_stack = np.zeros((nz, nx), dtype=np.float64)\n    for f in f_list:\n        _, I2d = rtm_single_frequency(f, nx, nz, dx, dz, v0, eta, alpha,\n                                          src_ix, src_iz, rec_iz, scat_ix, scat_iz)\n        I_stack += I2d\n\n    peak_val = abs(I_stack[scat_iz, scat_ix])\n    r_exc = 3\n    mask = np.ones_like(I_stack, dtype=bool)\n    i0 = max(0, scat_iz - r_exc)\n    i1 = min(nz, scat_iz + r_exc + 1)\n    j0 = max(0, scat_ix - r_exc)\n    j1 = min(nx, scat_ix + r_exc + 1)\n    mask[i0:i1, j0:j1] = False\n\n    side_max = np.max(np.abs(I_stack[mask])) if np.any(mask) else 0.0\n    eps = 1e-12\n    ratio = peak_val / (side_max + eps)\n    return ratio\n\ndef solve():\n    # Grid and physical parameters\n    nx, nz = 50, 50\n    dx = dz = 10.0  # meters\n    v0 = 2000.0     # m/s\n    eta = 0.05      # dimensionless damping\n    alpha = 0.02    # relative perturbation in m0\n\n    # Geometry\n    src_ix = nx // 2\n    src_iz = 1\n    rec_iz = 1\n    scat_ix = nx // 2\n    scat_iz = nz // 2\n\n    # Test cases:\n    # 1: single frequency 25 Hz\n    # 2: single frequency 35 Hz\n    # 3: stack frequencies [20, 25, 30, 35] Hz\n    # 4: single frequency 10 Hz (low-frequency edge case)\n    test_cases = [\n        (\"single\", 25.0),\n        (\"single\", 35.0),\n        (\"stack\", [20.0, 25.0, 30.0, 35.0]),\n        (\"single\", 10.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        mode, val = case\n        if mode == \"single\":\n            ratio, _ = rtm_single_frequency(val, nx, nz, dx, dz, v0, eta, alpha,\n                                            src_ix, src_iz, rec_iz, scat_ix, scat_iz)\n            results.append(f\"{ratio:.6f}\")\n        elif mode == \"stack\":\n            ratio = rtm_stack_frequencies(val, nx, nz, dx, dz, v0, eta, alpha,\n                                          src_ix, src_iz, rec_iz, scat_ix, scat_iz)\n            results.append(f\"{ratio:.6f}\")\n        else:\n            # Should not occur\n            results.append(f\"{0.0:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3613775"}, {"introduction": "标准的RTM图像是一个最终的叠加结果，但其计算过程中产生的波场本身蕴含着更丰富的信息。本练习将引导您从源波场和接收波场中提取局部传播方向，即局部波数矢量。通过分析这些矢量，您可以构建角度域共成像道集（ADCIGs），这是一个用于RTM质量控制、速度模型验证和振幅随角度（AVA）分析的强大诊断工具[@problem_id:3613787]。", "problem": "考虑从局部平面波估计构建的逆时偏移 (RTM) 角度域共成像道集。假设一个具有坐标 $x$ 和 $z$ 的二维空间网格，以及震源波场 $u_s(x,z)$ 和接收点波场 $u_r(x,z)$ 的复时间谐波快照。目标是计算局部波数向量并构建角度域能量道集，然后针对已知的入射配置验证聚焦情况。\n\n使用的基本原理：\n- 声波传播由声波方程描述，在时间谐波域中简化为亥姆霍兹方程。该方程存在平面波解，其空间相位梯度等于局部波数向量。\n- 逆时偏移 (RTM) 中的零延迟互相关成像条件将反射率与震源波场和接收点波场的相关性联系起来。\n- 角度域共成像道集 (ADCIG) 是通过将局部波数对映射到散射角来构建的，散射角量化了震源和接收点局部传播方向之间的夹角。\n\n任务：\n1. 给定定义在均匀网格上的复数场 $u_s(x,z)$ 和 $u_r(x,z)$，其在 $x$ 和 $z$ 方向上分别有 $N_x$ 和 $N_z$ 个采样点，间距为 $\\Delta x$ 和 $\\Delta z$（单位：米），使用将 $\\nabla u / u$ 的虚部与相位梯度关联的相位梯度原理，估计局部波数向量 $\\mathbf{k}_s(x,z)$ 和 $\\mathbf{k}_r(x,z)$。使用中心有限差分和步长 $\\Delta x$、$\\Delta z$ 来近似空间梯度。\n2. 对于每个网格位置，如果 $\\|\\mathbf{k}_s(x,z)\\|$ 和 $\\|\\mathbf{k}_r(x,z)\\|$ 都超过一个小阈值（以避免除以接近零的值），则将波数对 $\\big(\\mathbf{k}_s(x,z), \\mathbf{k}_r(x,z)\\big)$ 映射到一个散射角 $\\theta(x,z)$，其单位为弧度，范围在 $[0,\\pi]$ 内，定义为两个局部波数向量之间的夹角。通过在相应的角度区间中累积一个非负权重 $w(x,z)$ 来构建一个角度域能量直方图 $E(\\theta)$。使用 $w(x,z) = |u_s(x,z)|\\,|u_r(x,z)|$ 作为权重。该直方图必须有 $N_\\theta$ 个均匀覆盖 $[0,\\pi]$ 的区间。\n3. 对于每个指定的测试用例，计算一个聚焦度量 $F$，其值为包含已知真实散射角 $\\theta_{\\text{true}}$ 的区间中的能量与所有区间的总能量之比。如果没有有效样本对直方图有贡献，则定义 $F$ 为 $0.0$。所有计算中，$\\theta$ 均以弧度表示。最终输出为无量纲浮点数。\n4. 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，\"[result1,result2,result3]\"）。\n\n网格和单位：\n- 使用具有 $N_x$ 和 $N_z$ 个采样点的笛卡尔网格，间距 $\\Delta x$ 和 $\\Delta z$ 的单位为米。\n- 角度在内部处理和报告时必须使用弧度。\n\n测试套件：\n对于每个测试用例，除非另有说明，将 $u_s(x,z)$ 和 $u_r(x,z)$ 构建为具有已知波数方向的复平面波。设 $k_0$ 为波数向量的共同模，单位为弧度/米。定义 $\\mathbf{k}_s$ 和 $\\mathbf{k}_r$ 相对于 $x$ 轴的角度 $\\alpha_s$ 和 $\\alpha_r$（单位为弧度），使得 $\\mathbf{k}_s = k_0[\\cos(\\alpha_s),\\sin(\\alpha_s)]$ 和 $\\mathbf{k}_r = k_0[\\cos(\\alpha_r),\\sin(\\alpha_r)]$。将波场构建为 $u_s(x,z) = \\exp\\big(i(\\mathbf{k}_s \\cdot \\mathbf{x})\\big)$ 和 $u_r(x,z) = \\exp\\big(i(\\mathbf{k}_r \\cdot \\mathbf{x})\\big)$，其中 $\\mathbf{x} = [x,z]$。对于边界情况，将 $u_r(x,z)$ 设置为相位无变化的空间常数场，这使得 $\\mathbf{k}_r = \\mathbf{0}$ 在所有地方都成立。\n\n- 测试用例 1 (理想路径): $N_x = 64$, $N_z = 64$, $\\Delta x = 10\\,\\text{m}$, $\\Delta z = 10\\,\\text{m}$, $k_0 = 0.2\\,\\text{rad/m}$, $\\alpha_s = 0.0\\,\\text{rad}$, $\\alpha_r = 0.0\\,\\text{rad}$, $N_\\theta = 180$。真实角度为 $\\theta_{\\text{true}} = 0.0\\,\\text{rad}$。\n- 测试用例 2 (斜向，一般情况): $N_x = 64$, $N_z = 64$, $\\Delta x = 10\\,\\text{m}$, $\\Delta z = 10\\,\\text{m}$, $k_0 = 0.4\\,\\text{rad/m}$, $\\alpha_s = 0.3\\,\\text{rad}$, $\\alpha_r = 1.1\\,\\text{rad}$, $N_\\theta = 180$。真实角度为 $\\theta_{\\text{true}} = |\\alpha_r - \\alpha_s|\\,\\text{rad}$。\n- 测试用例 3 (近乎相反的方向): $N_x = 64$, $N_z = 64$, $\\Delta x = 10\\,\\text{m}$, $\\Delta z = 10\\,\\text{m}$, $k_0 = 0.5\\,\\text{rad/m}$, $\\alpha_s = 0.0\\,\\text{rad}$, $\\alpha_r = \\pi\\,\\text{rad}$, $N_\\theta = 180$。真实角度为 $\\theta_{\\text{true}} = \\pi\\,\\text{rad}$。\n- 测试用例 4 (接收点波数无效的边界情况): $N_x = 64$, $N_z = 64$, $\\Delta x = 10\\,\\text{m}$, $\\Delta z = 10\\,\\text{m}$, $k_0 = 0.3\\,\\text{rad/m}$, $\\alpha_s = 0.7\\,\\text{rad}$，且 $u_r(x,z)$ 是一个相位无变化的空间常数场 (因此 $\\mathbf{k}_r = \\mathbf{0}$)。使用 $N_\\theta = 180$。预期的聚焦度量为 $F = 0.0$，因为无法形成有效角度。\n\n算法细节：\n- 使用中心差分计算 $\\partial u/\\partial x$ 和 $\\partial u/\\partial z$。\n- 通过分量方式应用 $\\mathbf{k}(x,z) \\approx \\operatorname{Im}\\left(\\frac{\\nabla u(x,z)}{u(x,z)}\\right)$ 来估计局部波数。\n- 定义一个小阈值 $\\varepsilon = 10^{-8}$（单位：弧度/米），并排除任何满足 $\\|\\mathbf{k}_s(x,z)\\|  \\varepsilon$ 或 $\\|\\mathbf{k}_r(x,z)\\|  \\varepsilon$ 的网格点。\n- 直方图权重必须为 $w(x,z) = |u_s(x,z)|\\,|u_r(x,z)|$。\n- 最终输出必须是形如“[F1,F2,F3,F4]”的单行，其中每个 $Fj$ 是一个浮点数。\n\n您的程序应实现上述内容，并以指定的格式，即在单行上用方括号括起来的逗号分隔列表，输出聚焦度量。", "solution": "该问题被认为是有效的，因为它以波传播和计算地球物理学的原理为科学基础，在数学上是适定的，并以客观、明确的标准进行定义。它提出了一个清晰、可形式化的任务，该任务基于诸如逆时偏移 (RTM)、亥姆霍兹方程以及从波场相位梯度估计局部波数等已建立的概念。所提供的测试用例，包括一个探索空间混叠的用例和另一个边界情况的用例，都经过精心设计，以测试指定算法的鲁棒实现。\n\n解决方案通过实现规定的操作序列来推进。问题的核心基于三个主要原则：局部波数的估计、到散射角的映射，以及构建角度域直方图以推导聚焦度量。\n\n**1. 局部波数向量的估计**\n\n对于由复函数 $u(\\mathbf{x}) = A(\\mathbf{x}) e^{i\\phi(\\mathbf{x})}$ 描述的单色声波场，其中 $A(\\mathbf{x})$ 是振幅，$\\phi(\\mathbf{x})$ 是位置 $\\mathbf{x} = [x, z]$ 处的相位，局部波数向量 $\\mathbf{k}(\\mathbf{x})$ 定义为相位的梯度：\n$$\n\\mathbf{k}(\\mathbf{x}) = \\nabla \\phi(\\mathbf{x})\n$$\n复数场的梯度为 $\\nabla u = (\\nabla A) e^{i\\phi} + A (i\\nabla\\phi) e^{i\\phi}$。除以 $u$ 得到：\n$$\n\\frac{\\nabla u}{u} = \\frac{\\nabla A}{A} + i \\nabla \\phi = \\frac{\\nabla A}{A} + i\\mathbf{k}\n$$\n通过取此表达式的虚部，我们可以分离出局部波数向量：\n$$\n\\mathbf{k}(\\mathbf{x}) = \\operatorname{Im}\\left(\\frac{\\nabla u(\\mathbf{x})}{u(\\mathbf{x})}\\right)\n$$\n此原理应用于震源波场 $u_s(x,z)$ 和接收点波场 $u_r(x,z)$，以获得它们各自的局部波数向量场 $\\mathbf{k}_s(x,z)$ 和 $\\mathbf{k}_r(x,z)$。\n\n在数值上，空间网格是离散的，间距为 $\\Delta x$ 和 $\\Delta z$。梯度 $\\nabla u = [\\frac{\\partial u}{\\partial x}, \\frac{\\partial u}{\\partial z}]$ 使用二阶精度的中心有限差分格式进行近似。对于一个内部网格点 $(x_i, z_j)$，其导数为：\n$$\n\\frac{\\partial u}{\\partial x}(x_i, z_j) \\approx \\frac{u(x_{i+1}, z_j) - u(x_{i-1}, z_j)}{2\\Delta x}\n$$\n$$\n\\frac{\\partial u}{\\partial z}(x_i, z_j) \\approx \\frac{u(x_i, z_{j+1}) - u(x_i, z_{j-1})}{2\\Delta z}\n$$\n此计算在整个网格上对 $u_s$ 和 $u_r$ 执行。\n\n**2. 将波数映射到散射角**\n\n在每个网格点 $(x,z)$，局部波数向量对 $(\\mathbf{k}_s, \\mathbf{k}_r)$ 代表了震源波场和接收点波场的局部传播方向。散射角 $\\theta(x,z)$ 是这两个向量之间的夹角。它使用点积公式计算：\n$$\n\\theta(x,z) = \\arccos\\left(\\frac{\\mathbf{k}_s(x,z) \\cdot \\mathbf{k}_r(x,z)}{\\|\\mathbf{k}_s(x,z)\\| \\|\\mathbf{k}_r(x,z)\\|}\\right)\n$$\n$\\arccos$ 函数的结果自然地落在所需的 $[0, \\pi]$ 范围内。此计算仅在被视为有效的网格位置上执行，即两个波数向量的模都超过一个小阈值 $\\varepsilon = 10^{-8}$ 的位置。这个条件可以防止因除以零而产生的数值不稳定性，这种情况会发生在波数为零的零相位或恒定相位区域。\n\n**3. 直方图构建与聚焦度量**\n\n角度域共成像道集 (ADCIG) 被构建为一个直方图 $E(\\theta)$，它将能量作为散射角的函数进行累积。范围 $[0, \\pi]$ 被划分为 $N_\\theta$ 个均匀的区间。对于每个有效的网格点 $(x,z)$，计算出的散射角 $\\theta(x,z)$ 决定了其所在的区间，并将一个权重 $w(x,z)$ 添加到该区间的累加器中。问题指定的权重为：\n$$\nw(x,z) = |u_s(x,z)|\\,|u_r(x,z)|\n$$\n处理完所有有效网格点后，直方图中的总能量为 $E_{\\text{total}} = \\sum_{j=1}^{N_\\theta} E(\\theta_j)$。\n\n聚焦度量 $F$ 量化了能量在理论上已知的真实散射角 $\\theta_{\\text{true}}$ 处的集中程度。它被定义为包含 $\\theta_{\\text{true}}$ 的特定区间中的能量与直方图中总能量的比率：\n$$\nF = \\frac{E(\\text{bin containing } \\theta_{\\text{true}})}{E_{\\text{total}}}\n$$\n如果因为没有找到有效的网格点（如测试用例4中），直方图为空，则分子和分母都为零，并且 $F$ 被定义为 $0.0$。\n\n对于在间距违反奈奎斯特定理（即 $k_{max} > \\pi/\\Delta$）的网格上的平面波测试用例，梯度的有限差分近似会引入数值频散。估计的波数 $k_{\\text{est}} = \\frac{\\sin(k_{\\text{true}}\\Delta x)}{\\Delta x}$ 将不同于真实的波数 $k_{\\text{true}}$。这导致估计的散射角偏离 $\\theta_{\\text{true}}$，从而产生较低的聚焦度量 $F$，这正确地反映了算法在这种条件下的性能下降。实现必须严格遵循指定的算法，包括这些数值效应。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_focusing_metric(\n    Nx, Nz, dx, dz, us_func, ur_func, N_theta, theta_true, k_thresh\n):\n    \"\"\"\n    Computes the focusing metric for angle-domain common image gathers.\n    \n    Args:\n        Nx (int): Number of grid points in x.\n        Nz (int): Number of grid points in z.\n        dx (float): Grid spacing in x (meters).\n        dz (float): Grid spacing in z (meters).\n        us_func (callable): Function to generate source wavefield u_s(x, z).\n        ur_func (callable): Function to generate receiver wavefield u_r(x, z).\n        N_theta (int): Number of angle bins for the histogram.\n        theta_true (float): True scattering angle (radians).\n        k_thresh (float): Threshold for wavenumber magnitude.\n\n    Returns:\n        float: The focusing metric F.\n    \"\"\"\n    # 1. Create grid and wavefields\n    x = np.arange(Nx) * dx\n    z = np.arange(Nz) * dz\n    xx, zz = np.meshgrid(x, z)\n\n    u_s = us_func(xx, zz)\n    u_r = ur_func(xx, zz)\n\n    # 2. Estimate local wavenumbers using phase-gradient\n    # np.gradient returns gradients along each axis. For a 2D array (Nz, Nx),\n    # it returns (grad_z, grad_x). The spacings must be provided in the same order (dz, dx).\n    grad_s_z, grad_s_x = np.gradient(u_s, dz, dx, edge_order=2)\n    grad_r_z, grad_r_x = np.gradient(u_r, dz, dx, edge_order=2)\n    \n    # Add a small epsilon to the denominator to avoid division by zero\n    # in case u_s or u_r is zero somewhere, although not for the given test cases.\n    denom_s = u_s + 1e-12\n    denom_r = u_r + 1e-12\n\n    k_s_x = np.imag(grad_s_x / denom_s)\n    k_s_z = np.imag(grad_s_z / denom_s)\n    \n    k_r_x = np.imag(grad_r_x / denom_r)\n    k_r_z = np.imag(grad_r_z / denom_r)\n\n    # 3. Filter points based on wavenumber magnitude\n    k_s_norm = np.sqrt(k_s_x**2 + k_s_z**2)\n    k_r_norm = np.sqrt(k_r_x**2 + k_r_z**2)\n    \n    valid_mask = (k_s_norm >= k_thresh)  (k_r_norm >= k_thresh)\n    \n    if not np.any(valid_mask):\n        return 0.0\n\n    # 4. Map valid wavenumbers to scattering angles\n    k_s_x_valid = k_s_x[valid_mask]\n    k_s_z_valid = k_s_z[valid_mask]\n    k_r_x_valid = k_r_x[valid_mask]\n    k_r_z_valid = k_r_z[valid_mask]\n\n    k_s_norm_valid = k_s_norm[valid_mask]\n    k_r_norm_valid = k_r_norm[valid_mask]\n    \n    dot_product = k_s_x_valid * k_r_x_valid + k_s_z_valid * k_r_z_valid\n    \n    # Clip argument to arccos to handle potential floating point inaccuracies\n    cos_theta = np.clip(dot_product / (k_s_norm_valid * k_r_norm_valid), -1.0, 1.0)\n    angles = np.arccos(cos_theta)\n    \n    # 5. Construct angle-domain energy histogram\n    weights = np.abs(u_s[valid_mask]) * np.abs(u_r[valid_mask])\n    \n    bin_edges = np.linspace(0, np.pi, N_theta + 1)\n    hist_E, _ = np.histogram(angles, bins=bin_edges, weights=weights)\n\n    total_E = np.sum(hist_E)\n    \n    if total_E == 0:\n        return 0.0\n\n    # 6. Compute focusing metric F\n    bin_width = np.pi / N_theta\n    # Calculate the index of the bin containing the true angle\n    # Handle the edge case where theta_true = pi\n    true_bin_index = int(theta_true / bin_width)\n    if true_bin_index >= N_theta:\n        true_bin_index = N_theta - 1\n        \n    E_true = hist_E[true_bin_index]\n    \n    F = E_true / total_E\n    \n    return F\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the results.\n    \"\"\"\n    def make_plane_wave(k0, alpha):\n        kx = k0 * np.cos(alpha)\n        kz = k0 * np.sin(alpha)\n        return lambda x, z: np.exp(1j * (kx * x + kz * z))\n\n    def make_constant_field():\n        return lambda x, z: np.ones_like(x, dtype=np.complex128)\n\n    test_cases = [\n        # Case 1: Happy path\n        {'Nx': 64, 'Nz': 64, 'dx': 10.0, 'dz': 10.0, 'k0': 0.2, 'alpha_s': 0.0, 'alpha_r': 0.0, 'N_theta': 180},\n        # Case 2: Oblique, general\n        {'Nx': 64, 'Nz': 64, 'dx': 10.0, 'dz': 10.0, 'k0': 0.4, 'alpha_s': 0.3, 'alpha_r': 1.1, 'N_theta': 180},\n        # Case 3: Near-opposite directions\n        {'Nx': 64, 'Nz': 64, 'dx': 10.0, 'dz': 10.0, 'k0': 0.5, 'alpha_s': 0.0, 'alpha_r': np.pi, 'N_theta': 180},\n        # Case 4: Edge case with invalid receiver wavenumber\n        {'Nx': 64, 'Nz': 64, 'dx': 10.0, 'dz': 10.0, 'k0': 0.3, 'alpha_s': 0.7, 'N_theta': 180},\n    ]\n\n    results = []\n    k_thresh = 1e-8\n\n    for i, params in enumerate(test_cases):\n        if i == 3: # Test Case 4\n            us_func = make_plane_wave(params['k0'], params['alpha_s'])\n            ur_func = make_constant_field()\n            # As per problem, kr is zero, so no valid angle can be formed. \n            # The manual calculation is not strictly needed as the code handles it.\n            theta_true = 0.0 # dummy value, not used for F=0 case\n        else:\n            us_func = make_plane_wave(params['k0'], params['alpha_s'])\n            ur_func = make_plane_wave(params['k0'], params['alpha_r'])\n            theta_true = np.abs(params['alpha_r'] - params['alpha_s'])\n        \n        F = compute_focusing_metric(\n            params['Nx'], params['Nz'], params['dx'], params['dz'],\n            us_func, ur_func, params['N_theta'], theta_true, k_thresh\n        )\n        results.append(F)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3613787"}, {"introduction": "真实地球介质并非完美弹性体，地震波在传播过程中会因内在衰减（粘弹性效应）而损失能量并改变形态。本练习将探讨这一关键的复杂物理现象，通过在一个一维粘声学模型中，对比两种常见的成像条件——互相关与反褶积。通过该练习，您将能够量化评估每种方法在校正由介质衰减引起的振幅损失和相位畸变方面的表现，从而更深入地理解RTM在应用于真实数据时面临的挑战[@problem_id:3613786]。", "problem": "要求您对逆时偏移（RTM）中使用的两种零延迟成像条件进行定量比较：互相关成像条件和反褶积成像条件，研究对象是具有空间可变衰减的一维粘滞声学介质。您的目标是从第一性原理出发，推导出一个可复现的算法，该算法以物理上合理的方式合成数据，实现两种成像条件，在相位上对齐反射事件，然后将两种成像条件的振幅和相位保真度量化为逆品质因子和主频的显式函数。\n\n起点和物理假设。从含耗散的线性化声波方程开始，在小衰减意义下，使用恒定品质因子（品质因子 $Q$ 是无量纲的）来模拟粘滞声学损耗。使用均匀背景波速 $v$（单位：$\\mathrm{m/s}$）和一个具有空间可变品质因子 $Q_1$ 和 $Q_2$ 的双层衰减模型。假设在深度 $z_r$（单位：$\\mathrm{m}$）处有一个单个水平反射体，其反射率为实标量 $r$，并在地表采用平面震源-接收器配置。总双程走时为 $t_0 = 2 z_r / v$。震源子波是具有主频 $f_0$（单位：$\\mathrm{Hz}$）和单位峰值振幅的紧支集 Ricker 子波。\n\n粘滞声学传播模型。在恒定$Q$介质的小损耗近似下，平面波谱振幅随角频率和有效衰减时间的乘积呈指数衰减，而因果性意味着存在一个随频率对数变化的一阶频散相位校正。对于一个双层衰减模型，其中第一层从 $z=0$ 延伸到 $z=z_{\\mathrm{int}}$，品质因子为 $Q_1$，第二层从 $z=z_{\\mathrm{int}}$ 延伸到 $z=z_r$，品质因子为 $Q_2$，通过将在每一层中两个单程段的贡献相加，并将结果加倍以计算往返行程，来构建双程衰减和频散算子。将频散校正锚定在等于主频的参考频率 $f_{\\mathrm{ref}} = f_0$ 上，以避免任意的绝对相位，并通过将极低频率处的 $|f|$ 的下限钳制为 $f_0$ 的一小部分来对数进行正则化，以避免在 $f=0$ 处的奇点。您必须基于线性化、平面波渐近理论和 Kramers–Kronig 因果关系，明确证明您所实现的公式的合理性。\n\n数据合成。在时间域内，在一个持续时间为 $T$、采样间隔为 $\\Delta t$ 的均匀采样网格上生成震源子波（使用的 $T$ 和 $\\Delta t$ 值应能实际地捕捉到量级为 $t_0$ 的双程时间而无时间环绕；请指明您的选择）。将子波变换到频率域。通过将震源谱与双层模型的双程粘滞声学传播算子以及标量反射率 $r$ 相乘，来构建频率域数据。确保您的实现相对于正负频率是对称的，以便逆变换产生一个实值时间序列。\n\n成像条件。根据合成的单道数据和已知的震源谱，实现反射体位置处反射率的两种估计器：\n- 互相关成像条件：将其视为频率域中的匹配滤波器估计器，并通过震源能量进行归一化，使估计结果无量纲。在进行谱求和之前，通过移除与传播延迟 $t_0$ 对应的已知无频散双程相位项来对齐反射事件的相位（解调因子必须使用弧度制角度）。\n- 反褶积成像条件：将其视为数据与震源的稳定谱除法，并在频带上进行平均。实现 Tikhonov 型稳定化，以避免在震源谱零点附近出现不稳定性。使用与互相关中相同的无频散相位解调，并明确包含一个良态归一化，以便反褶积估计也是无量纲的。\n\n保真度度量。为每个成像条件定义两个保真度度量：\n- 振幅保真度，定义为估计的反射率振幅与真实反射率振幅 $r$ 的比值，即 $| \\hat{r} | / r$（无量纲）。\n- 相位误差，定义为估计的反射率 $\\arg(\\hat{r})$ 的复宗量的主值，以弧度为单位（角度必须是弧度）。\n\n您的程序必须实现以上步骤，并为一组探索逆品质因子和主频变化的测试用例计算这两个度量。所有案例使用以下固定的物理参数：背景速度 $v = 2000$（单位：$\\mathrm{m/s}$），反射体深度 $z_r = 1000$（单位：$\\mathrm{m}$），界面深度 $z_{\\mathrm{int}} = 400$（单位：$\\mathrm{m}$），反射率 $r = 0.2$（无量纲）。对于离散傅里叶变换，使用总记录长度 $T = 8.192$（单位：$\\mathrm{s}$）和时间采样间隔 $\\Delta t = 0.001$（单位：$\\mathrm{s}$）。\n\n定义以下测试套件，每个案例由 $(Q_1, Q_2, f_0)$ 指定：\n- 案例 1（理想路径，中等损耗）：$(Q_1, Q_2, f_0) = (200, 100, 20)$。\n- 案例 2（近无损基线）：$(Q_1, Q_2, f_0) = (1000, 1000, 20)$。\n- 案例 3（强损耗，较高频带）：$(Q_1, Q_2, f_0) = (40, 25, 30)$。\n- 案例 4（中等损耗，低频带边缘）：$(Q_1, Q_2, f_0) = (200, 100, 5)$。\n- 案例 5（中等损耗，高频带边缘）：$(Q_1, Q_2, f_0) = (200, 100, 40)$。\n\n为了在反褶积成像条件中保持数值稳定性，实现一个稳定化参数 $\\epsilon$，定义为震源谱能量峰值的一小部分，具体为 $\\epsilon = 10^{-6} \\max_{\\omega} |S(\\omega)|^2$，其中 $S(\\omega)$ 是震源谱，$\\omega$ 是角频率（单位：$\\mathrm{rad/s}$）。对于频散相位正则化，在任何对数函数内部，将 $|f|$ 的下限钳制为 $0.1 f_0$，其中 $f$ 是时间频率（单位：$\\mathrm{Hz}$）。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含所有案例的保真度度量，形式为一个扁平的浮点数列表，四舍五入到六位小数，每个案例按以下顺序排列：互相关的振幅保真度、反褶积的振幅保真度、互相关的相位误差（以弧度为单位）、反褶积的相位误差（以弧度为单位）。因此，总的输出顺序必须是：\n$[\\mathrm{amp\\_cc}^{(1)}, \\mathrm{amp\\_dc}^{(1)}, \\mathrm{phi\\_cc}^{(1)}, \\mathrm{phi\\_dc}^{(1)}, \\ldots, \\mathrm{amp\\_cc}^{(5)}, \\mathrm{amp\\_dc}^{(5)}, \\mathrm{phi\\_cc}^{(5)}, \\mathrm{phi\\_dc}^{(5)}]$。\n\n所有距离必须以 $\\mathrm{m}$ 为单位，时间以 $\\mathrm{s}$ 为单位，波速以 $\\mathrm{m/s}$ 为单位，频率以 $\\mathrm{Hz}$ 为单位。角度必须以弧度为单位。振幅保真度是无量纲的。相位误差必须表示为一个实数，单位是弧度（不是度）。最终输出必须打印为单行，以逗号分隔的列表形式，并用方括号括起来，不含任何其他文本。", "solution": "用户要求对逆时偏移（RTM）的两种零延迟成像条件——互相关和反褶积——在一维双层粘滞声学介质中进行定量比较。这涉及从第一性原理推导理论框架，合成必要的地震数据，实现成像条件，并计算明确定义的保真度度量。解决方案将首先建立波传播的物理模型，然后定义数据合成和成像算法，最后指定用于比较的度量。\n\n### 1. 粘滞声学波传播模型\n\n我们从经修改以包含固有衰减的线性化声波方程开始。对于一个角频率为 $\\omega$、在速度为 $v$、品质因子为 $Q$ 的均匀介质中传播的平面波，恒定$Q$模型是一个标准且有物理依据的选择。在小损耗近似（$Q \\gg 1$）下，描述波在传播距离 $z$ 上的演化的传播算子可以从强制执行因果性的 Kramers-Kronig 关系推导出来。单程路径的传播算子 $G_{1way}$ 在频率域中表示为一个无频散走时项、一个衰减项和一个频散相位项的乘积。\n\n复波数 $k(\\omega)$ 近似为：\n$$ k(\\omega) \\approx \\frac{\\omega}{v} + \\frac{i\\omega \\operatorname{sgn}(\\omega)}{2vQ} - \\frac{\\omega}{\\pi v Q} \\ln\\left|\\frac{\\omega}{\\omega_{\\text{ref}}}\\right| $$\n假设时间依赖性为 $e^{-i\\omega t}$，则传播距离 $z$ 的传播算子为 $e^{ikz}$，代入 $k(\\omega)$ 并使用 $t(z) = z/v$ 后变为：\n$$ G_{1way}(\\omega, z) = \\exp\\left(-\\frac{|\\omega| t(z)}{2Q}\\right) \\exp\\left(-i\\frac{\\omega t(z)}{\\pi Q} \\ln\\left|\\frac{\\omega}{\\omega_{\\text{ref}}}\\right|\\right) \\exp\\left(i\\omega t(z)\\right) $$\n问题要求一个双层模型，反射体位于深度 $z_r$，界面位于 $z_{\\mathrm{int}}$。波向下传播然后返回，因此在第一层（深度从 $0$ 到 $z_{\\mathrm{int}}$，品质因子为 $Q_1$）中的总双程走时为 $t_1 = 2z_{\\mathrm{int}}/v$，在第二层（深度从 $z_{\\mathrm{int}}$ 到 $z_r$，品质因子为 $Q_2$）中的总双程走时为 $t_2 = 2(z_r - z_{\\mathrm{int}})/v$。总的无频散双程走时为 $t_0 = t_1 + t_2 = 2 z_r / v$。\n\n总双程传播算子 $G(\\omega)$ 是各段效应的乘积。我们定义一个有效逆Q时间 $\\tau_Q$，它整合了路径的衰减特性：\n$$ \\tau_Q = \\frac{t_1}{Q_1} + \\frac{t_2}{Q_2} = \\frac{2z_{\\mathrm{int}}}{vQ_1} + \\frac{2(z_r-z_{\\mathrm{int}})}{vQ_2} $$\n完整的双程传播算子 $G(\\omega)$ 随后可以表示为：\n$$ G(\\omega) = G_{\\text{visco}}(\\omega) \\cdot e^{i\\omega t_0} $$\n此处，$e^{i\\omega t_0}$ 是对应于走时 $t_0$ 的无频散相移。$G_{\\text{visco}}(\\omega)$ 项包含所有衰减和频散效应。参考频率设为震源的主频，$f_{\\text{ref}} = f_0$（或 $\\omega_{\\text{ref}} = \\omega_0 = 2\\pi f_0$），以锚定相位。为避免在 $\\omega=0$ 处的奇点，对数函数中的频率进行了正则化。\n$$ G_{\\text{visco}}(\\omega) = \\exp\\left(-\\frac{|\\omega| \\tau_Q}{2}\\right) \\exp\\left(-i\\frac{\\omega \\tau_Q}{\\pi} \\ln\\left(\\frac{\\max(|\\omega|, 0.1\\omega_0)}{\\omega_0}\\right)\\right) $$\n这将用于合成数据。\n\n### 2. 数据合成\n\n震源子波 $s(t)$ 是一个具有主频 $f_0$ 和单位峰值振幅的 Ricker 子波，并由时间 $t_s$ 平移以使其在记录窗口内居中：\n$$ s(t; f_0, t_s) = \\left[1 - 2\\left(\\pi f_0 (t-t_s)\\right)^2\\right] e^{-\\left(\\pi f_0 (t-t_s)\\right)^2} $$\n通过对时域子波 $s(t)$ 进行快速傅里叶变换（FFT），可以获得震源谱 $S(\\omega)$。对于反射率为 $r$ 的反射体，在地表记录的合成数据 $D(\\omega)$ 是震源谱和双程传播算子的乘积：\n$$ D(\\omega) = r \\cdot G(\\omega) \\cdot S(\\omega) = r \\cdot G_{\\text{visco}}(\\omega) \\cdot e^{i\\omega t_0} \\cdot S(\\omega) $$\n为确保逆FFT产生实值时间序列，频谱必须表现出厄米对称性，即 $D(-\\omega) = D^*(\\omega)$，如果 $S(\\omega)$ 来自实值 $s(t)$，则此构造自然满足该条件。\n\n### 3. 成像条件\n\n目标是从数据 $D(\\omega)$ 和震源 $S(\\omega)$ 中获得反射率的估计值 $\\hat{r}$。这是在零延迟下完成的，对应于已知的反射体时间 $t_0$。两种成像条件的第一步都是通过移除无频散走时相位 $e^{i\\omega t_0}$ 来对数据进行解调。此处，我们通过乘以 $e^{-i\\omega t_0}$ 来对齐相位：\n$$ D_{\\text{demod}}(\\omega) = D(\\omega) e^{-i\\omega t_0} = r \\cdot G_{\\text{visco}}(\\omega) \\cdot S(\\omega) $$\n\n**互相关（CC）成像条件：**\n此条件是一个匹配滤波器。估计值 $\\hat{r}_{\\text{CC}}$ 是通过将解调后的数据与震源谱进行相关，并按震源能量进行归一化以确保结果无量纲而获得的。在频率域中，这表示为：\n$$ \\hat{r}_{\\text{CC}} = \\frac{\\sum_{k} D_{\\text{demod}}(\\omega_k) S^*(\\omega_k)}{\\sum_{k} S(\\omega_k) S^*(\\omega_k)} = \\frac{\\sum_{k} r \\cdot G_{\\text{visco}}(\\omega_k) S(\\omega_k) S^*(\\omega_k)}{\\sum_{k} |S(\\omega_k)|^2} = r \\frac{\\sum_{k} |S(\\omega_k)|^2 G_{\\text{visco}}(\\omega_k)}{\\sum_{k} |S(\\omega_k)|^2} $$\n这是粘滞声学传播算子 $G_{\\text{visco}}$ 的加权平均，权重为震源功率谱 $|S(\\omega_k)|^2$。\n\n**反褶积（DC）成像条件：**\n此条件试图反演震源子波效应。使用稳定谱除法来避免在震源能量低的频率处放大噪声。使用 Tikhonov 正则化，估计的反射率 $\\hat{r}_{\\text{DC}}$ 为：\n$$ \\hat{r}_{\\text{DC}} = \\frac{\\sum_{k} \\frac{D_{\\text{demod}}(\\omega_k) S^*(\\omega_k)}{|S(\\omega_k)|^2 + \\epsilon}}{\\sum_{k} \\frac{S(\\omega_k) S^*(\\omega_k)}{|S(\\omega_k)|^2 + \\epsilon}} $$\n其中 $\\epsilon = 10^{-6} \\max_{\\omega} |S(\\omega)|^2$ 是稳定化参数。代入 $D_{\\text{demod}}(\\omega)$ 的表达式，我们得到：\n$$ \\hat{r}_{\\text{DC}} = r \\frac{\\sum_{k} \\frac{|S(\\omega_k)|^2}{|S(\\omega_k)|^2 + \\epsilon} G_{\\text{visco}}(\\omega_k)}{\\sum_{k} \\frac{|S(\\omega_k)|^2}{|S(\\omega_k)|^2 + \\epsilon}} $$\n这也是 $G_{\\text{visco}}$ 的加权平均，但其权重在震源的通带内近似为 $1$，在通带外近似为 $0$，从而提供了对介质响应更直接的估计。归一化确保了如果 $G_{\\text{visco}}(\\omega) = 1$（无衰减或频散），则 $\\hat{r}_{\\text{DC}} = r$。\n\n### 4. 保真度度量\n\n为了量化每个成像条件的性能，我们定义两个度量：\n- **振幅保真度**：估计反射率的模与真实反射率的比值。它衡量振幅恢复的准确性。\n$$ \\text{Fidelity}_{\\text{amp}} = \\frac{|\\hat{r}|}{r} $$\n- **相位误差**：复值估计反射率的宗量（相位角）。它衡量由未补偿的粘滞声学效应引入的相位畸变。\n$$ \\text{Error}_{\\text{phase}} = \\arg(\\hat{r}) \\quad [\\text{单位：弧度}] $$\n\n该算法将为问题陈述中指定的每个测试用例计算这四个值（$\\text{Fidelity}_{\\text{amp, CC}}$、$\\text{Fidelity}_{\\text{amp, DC}}$、$\\text{Error}_{\\text{phase, CC}}$、$\\text{Error}_{\\text{phase, DC}}$）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    # Define the fixed physical and numerical parameters from the problem statement.\n    v = 2000.0  # m/s\n    z_r = 1000.0  # m\n    z_int = 400.0  # m\n    r_true = 0.2  # dimensionless reflectivity\n    T = 8.192  # s\n    dt = 0.001  # s\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Q1, Q2, f0)\n        (200, 100, 20),  # Case 1: moderate loss\n        (1000, 1000, 20),# Case 2: near lossless baseline\n        (40, 25, 30),    # Case 3: strong loss, higher band\n        (200, 100, 5),   # Case 4: moderate loss, low band\n        (200, 100, 40),  # Case 5: moderate loss, higher band\n    ]\n\n    results = []\n\n    for case in test_cases:\n        Q1, Q2, f0 = case\n\n        # --- 1. Grid and Source Wavelet Setup ---\n        N = int(T / dt)\n        t = np.arange(N) * dt\n        freq = fftfreq(N, dt)\n        omega = 2 * np.pi * freq\n\n        # Generate Ricker wavelet in time domain with unit peak amplitude\n        # A time shift is used to center the wavelet away from t=0.\n        t_s = 0.5  # seconds, a fixed shift\n        x_arg = np.pi * f0 * (t - t_s)\n        source_t = (1.0 - 2.0 * x_arg**2) * np.exp(-x_arg**2)\n\n        # Transform source to frequency domain\n        source_w = fft(source_t)\n\n        # --- 2. Viscoacoustic Propagator Construction ---\n        # Travel times for the two-way path\n        t1 = 2.0 * z_int / v\n        t2 = 2.0 * (z_r - z_int) / v\n        t0 = t1 + t2 # Total two-way travel time\n\n        # Effective inverse Q-time\n        tau_Q = t1 / Q1 + t2 / Q2\n\n        # Angular frequencies for reference and regularization\n        w0 = 2.0 * np.pi * f0\n        w_reg = np.maximum(np.abs(omega), 0.1 * w0)\n        \n        # Avoid log(0) at omega=0 explicitly\n        log_term = np.zeros_like(omega)\n        non_zero_mask = w_reg != 0\n        log_term[non_zero_mask] = np.log(w_reg[non_zero_mask] / w0)\n\n\n        # Attenuation and dispersion operators\n        attenuation_op = np.exp(-np.abs(omega) * tau_Q / 2.0)\n        dispersion_op = np.exp(-1j * (omega * tau_Q / np.pi) * log_term)\n\n        # Viscoacoustic part of the propagator (excluding travel time phase)\n        G_visco = attenuation_op * dispersion_op\n        \n        # --- 3. Data Synthesis ---\n        # The full propagator includes the non-dispersive travel time\n        # Using exp(-iwt) transform convention, propagator has exp(+iwt0) for a delay t0\n        full_propagator_w = G_visco * np.exp(1j * omega * t0)\n        \n        # Synthesize data in frequency domain\n        data_w = r_true * full_propagator_w * source_w\n        \n        # --- 4. Imaging Conditions ---\n        # Demodulate data by removing the non-dispersive travel time phase\n        # This is multiplication by exp(-i*omega*t0)\n        data_demod_w = data_w * np.exp(-1j * omega * t0)\n\n        # Cross-Correlation (CC) Imaging\n        # Numerator is the sum of D_demod * S*\n        # Denominator is the source energy (sum of S * S*)\n        num_cc = np.sum(data_demod_w * np.conj(source_w))\n        den_cc = np.sum(source_w * np.conj(source_w))\n        r_hat_cc = num_cc / den_cc\n\n        # Deconvolution (DC) Imaging\n        # Tikhonov regularization parameter\n        source_power = np.abs(source_w)**2\n        epsilon = 1e-6 * np.max(source_power)\n\n        # Numerator is stabilized deconvolution of D_demod by S\n        # Denominator is the normalization factor\n        num_dc = np.sum(data_demod_w * np.conj(source_w) / (source_power + epsilon))\n        den_dc = np.sum(source_power / (source_power + epsilon))\n        r_hat_dc = num_dc / den_dc\n        \n        # --- 5. Fidelity Metrics ---\n        # Amplitude fidelity: |r_hat| / r_true\n        amp_fidelity_cc = np.abs(r_hat_cc) / r_true\n        amp_fidelity_dc = np.abs(r_hat_dc) / r_true\n\n        # Phase error: arg(r_hat) in radians\n        phase_error_cc = np.angle(r_hat_cc)\n        phase_error_dc = np.angle(r_hat_dc)\n\n        # Append results for the current case, rounded to 6 decimal places\n        results.extend([\n            round(amp_fidelity_cc, 6),\n            round(amp_fidelity_dc, 6),\n            round(phase_error_cc, 6),\n            round(phase_error_dc, 6)\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3613786"}]}