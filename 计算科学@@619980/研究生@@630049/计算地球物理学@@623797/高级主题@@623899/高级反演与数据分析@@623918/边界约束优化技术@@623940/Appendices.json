{"hands_on_practices": [{"introduction": "在着手求解一个优化问题之前，我们必须首先明确“解”的定义。本练习将引导您推导并应用 Karush-Kuhn-Tucker (KKT) 条件，这是有约束优化问题最优解的基本必要条件。通过解决一个具体的地球物理反演问题，您将在抽象理论和实际计算之间建立起一座桥梁。[@problem_id:3578366]", "problem": "在线性化地震振幅反演步骤中，模型扰动向量 $m \\in \\mathbb{R}^{n}$ 是通过在简单边界约束下最小化一个Tikhonov正则化数据失配项来估计的。其原始问题为\n$$\n\\min_{m \\in \\mathbb{R}^{n}} \\; J(m) = \\frac{1}{2}\\|F m - d\\|_{2}^{2} + \\frac{\\alpha}{2}\\|L m\\|_{2}^{2}\n\\quad \\text{subject to} \\quad l \\le m \\le u,\n$$\n其中 $F$ 是一个源于Born近似的线性化正演算子，$d$ 是观测数据，$L$ 是一个表示先验平滑性的稳定化算子，而 $l,u$ 是按元素作用的下界和上界，它们为模型编码了可行的物理范围。\n\n从拉格朗日函数的定义和约束凸优化的基本必要条件出发，推导这个边界约束问题的Karush–Kuhn–Tucker (KKT) 最优性系统，用梯度 $\\nabla J(m)$ 以及分别与上界和下界相关的非负拉格朗日乘子 $\\lambda^{+}, \\lambda^{-} \\in \\mathbb{R}^{n}$ 来表示。\n\n然后，将其特殊化为以下与单位权重的最小二乘数据项和零阶Tikhonov正则化子相符的适定二维实例：\n- $n = 2$,\n- $F = I_{2}$ ($2 \\times 2$ 单位矩阵),\n- $L = I_{2}$,\n- $\\alpha = 1$,\n- $d = \\begin{pmatrix} 2 \\\\ \\frac{1}{10} \\end{pmatrix}$,\n- $l = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$,\n- $u = \\begin{pmatrix} \\frac{3}{5} \\\\ \\frac{1}{5} \\end{pmatrix}$.\n\n计算满足你推导出的KKT系统的唯一最优解 $m^{\\star}$ 及相关的KKT乘子 $\\lambda^{+}, \\lambda^{-}$。报告上界乘子的第一个分量 $\\lambda^{+}_{1}$ 的标量值作为你的最终答案。将最终值表示为最简分数。无需单位。", "solution": "用户希望我解决一个边界约束的优化问题。\n\n首先，我将验证问题陈述。\n\n### 步骤1：提取已知条件\n- **目标函数**：关于 $m \\in \\mathbb{R}^{n}$ 最小化 $J(m) = \\frac{1}{2}\\|F m - d\\|_{2}^{2} + \\frac{\\alpha}{2}\\|L m\\|_{2}^{2}$。\n- **约束条件**：$l \\le m \\le u$，其中不等式是按元素作用的。\n- **问题参数**：\n    - $m \\in \\mathbb{R}^{n}$：模型扰动向量。\n    - $F$：线性化正演算子。\n    - $d$：观测数据向量。\n    - $L$：稳定化算子。\n    - $\\alpha$：标量正则化参数。\n    - $l, u \\in \\mathbb{R}^{n}$：按元素作用的下界和上界。\n- **具体实例**：\n    - $n = 2$。\n    - $F = I_{2}$ ($2 \\times 2$ 单位矩阵)。\n    - $L = I_{2}$。\n    - $\\alpha = 1$。\n    - $d = \\begin{pmatrix} 2 \\\\ \\frac{1}{10} \\end{pmatrix}$。\n    - $l = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。\n    - $u = \\begin{pmatrix} \\frac{3}{5} \\\\ \\frac{1}{5} \\end{pmatrix}$。\n- **任务**：\n    1. 推导一般边界约束问题的Karush–Kuhn–Tucker (KKT) 最优性系统。\n    2. 对具体实例，求解最优解 $m^{\\star}$ 和相关的拉格朗日乘子 $\\lambda^{+}, \\lambda^{-}$。\n    3. 报告上界乘子的第一个分量 $\\lambda^{+}_{1}$ 的值。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题在科学上和数学上都是合理的。它描述了一个带箱式约束的标准Tikhonov正则化最小二乘问题，这是计算科学与工程中的一个常见任务，尤其是在地球物理反演中。对于 $\\alpha > 0$ 以及合理的 $F$ 和 $L$ (在具体实例中 $F=L=I_2$ 满足此条件)，目标函数 $J(m)$ 是一个严格凸二次函数。约束集是一个闭的、非空的凸超矩形。在此类集合上最小化一个严格凸函数是一个适定问题，保证有唯一解。给定具体实例的数据在维度上是一致且完备的。因此，该问题是有效的。\n\n### 步骤3：结论与行动\n问题是有效的。将提供完整的解答。\n\n### 第一部分：KKT系统的推导\n\n优化问题是：\n$$\n\\min_{m \\in \\mathbb{R}^{n}} \\; J(m) = \\frac{1}{2}\\|F m - d\\|_{2}^{2} + \\frac{\\alpha}{2}\\|L m\\|_{2}^{2}\n\\quad \\text{subject to} \\quad l \\le m \\le u.\n$$\n约束可以写成两组不等式：\n$$\nm - u \\le 0 \\quad (\\text{按元素})\n$$\n$$\nl - m \\le 0 \\quad (\\text{按元素})\n$$\n我们为上界和下界约束分别引入非负拉格朗日乘子 $\\lambda^{+} \\in \\mathbb{R}^{n}$ 和 $\\lambda^{-} \\in \\mathbb{R}^{n}$。拉格朗日函数 $\\mathcal{L}$ 是：\n$$\n\\mathcal{L}(m, \\lambda^{+}, \\lambda^{-}) = J(m) + (\\lambda^{+})^T (m - u) + (\\lambda^{-})^T (l - m)\n$$\n最优性的Karush–Kuhn–Tucker (KKT) 条件如下：\n\n1.  **平稳性**：拉格朗日函数关于 $m$ 的梯度必须为零。\n    $$\n    \\nabla_{m} \\mathcal{L}(m, \\lambda^{+}, \\lambda^{-}) = \\nabla J(m) + \\lambda^{+} - \\lambda^{-} = 0\n    $$\n2.  **原始可行性**：必须满足原始约束。\n    $$\n    l \\le m \\le u\n    $$\n3.  **对偶可行性**：拉格朗日乘子必须是非负的。\n    $$\n    \\lambda^{+} \\ge 0, \\quad \\lambda^{-} \\ge 0 \\quad (\\text{按元素})\n    $$\n4.  **互补松弛性**：每个乘子与其对应的约束函数之积必须为零。对于每个分量 $i = 1, \\dots, n$：\n    $$\n    \\lambda_i^{+} (m_i - u_i) = 0\n    $$\n    $$\n    \\lambda_i^{-} (l_i - m_i) = 0\n    $$\n目标函数的梯度 $\\nabla J(m)$ 可以通过展开平方范数得到：\n$J(m) = \\frac{1}{2}(Fm-d)^T(Fm-d) + \\frac{\\alpha}{2}(Lm)^T(Lm) = \\frac{1}{2}(m^T F^T F m - 2 d^T F m + d^T d) + \\frac{\\alpha}{2} m^T L^T L m$.\n对 $m$ 求梯度：\n$$\n\\nabla J(m) = F^T(Fm - d) + \\alpha L^T L m\n$$\n将此代入平稳性条件即可得到完整的KKT系统。这个方程和不等式系统定义了解 $m^{\\star}$ 必须满足的必要条件。对于像这样的凸问题，这些条件也是充分的。\n\n### 第二部分：具体实例的求解\n\n给定： $n = 2$, $F = L = I_{2}$, $\\alpha = 1$, $d = \\begin{pmatrix} 2 \\\\ \\frac{1}{10} \\end{pmatrix}$, $l = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$, $u = \\begin{pmatrix} \\frac{3}{5} \\\\ \\frac{1}{5} \\end{pmatrix}$。\n\n目标函数简化为：\n$$\nJ(m) = \\frac{1}{2}\\|m - d\\|_{2}^{2} + \\frac{1}{2}\\|m\\|_{2}^{2}\n$$\n梯度是：\n$$\n\\nabla J(m) = (m - d) + m = 2m - d\n$$\n对于每个分量 $i=1,2$ 的KKT平稳性条件是：\n$$\n2m_i - d_i + \\lambda_i^{+} - \\lambda_i^{-} = 0\n$$\n为了找到解，我们首先通过设置 $\\nabla J(m) = 0$ 来计算无约束最小化解，这得到 $2m - d = 0$，即 $m = d/2$。\n$$\nm_{\\text{unconstrained}} = \\frac{1}{2} \\begin{pmatrix} 2 \\\\ \\frac{1}{10} \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ \\frac{1}{20} \\end{pmatrix}\n$$\n接下来，我们检查这个无约束解是否满足边界 $l \\le m \\le u$ 的可行性。\n边界为 $l = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$ 和 $u = \\begin{pmatrix} \\frac{3}{5} \\\\ \\frac{1}{5} \\end{pmatrix} = \\begin{pmatrix} 0.6 \\\\ 0.2 \\end{pmatrix}$。\n\n对于第一个分量，$m_1 = 1$。约束为 $0 \\le m_1 \\le 0.6$。由于 $1 > 0.6$，违反了上界约束。\n对于第二个分量，$m_2 = \\frac{1}{20} = 0.05$。约束为 $0 \\le m_2 \\le 0.2$。此约束得到满足。\n\n因为问题是凸的，解 $m^{\\star}$ 可以通过将无约束解投影到可行域（由 $l$ 和 $u$ 定义的箱型区域）上来找到。\n- 对于 $m_1^{\\star}$，由于无约束值 $1$ 超出了上界 $u_1 = \\frac{3}{5}$，最优值将位于上界处。因此，$m_1^{\\star} = u_1 = \\frac{3}{5}$。\n- 对于 $m_2^{\\star}$，由于无约束值 $\\frac{1}{20}$ 位于可行区间 $[0, \\frac{1}{5}]$ 内，最优值就是无约束值。因此，$m_2^{\\star} = \\frac{1}{20}$。\n\n所以，最优解是 $m^{\\star} = \\begin{pmatrix} \\frac{3}{5} \\\\ \\frac{1}{20} \\end{pmatrix}$。\n\n现在，我们使用KKT条件计算拉格朗日乘子。\n\n**对于分量1**：\n- $m_1^{\\star} = u_1 = \\frac{3}{5}$。上界是激活的。\n- 根据互补松弛性，由于 $m_1^{\\star} - u_1 = 0$，$\\lambda_1^{+}$可以为非零。\n- 由于 $l_1  m_1^{\\star}$ ($0  \\frac{3}{5}$)，下界是非激活的。互补松弛性要求 $\\lambda_1^{-} = 0$。\n- $m_1$ 的平稳性条件是 $2m_1^{\\star} - d_1 + \\lambda_1^{+} - \\lambda_1^{-} = 0$。\n- 代入已知值：\n$$\n2\\left(\\frac{3}{5}\\right) - 2 + \\lambda_1^{+} - 0 = 0\n$$\n$$\n\\frac{6}{5} - \\frac{10}{5} + \\lambda_1^{+} = 0\n$$\n$$\n-\\frac{4}{5} + \\lambda_1^{+} = 0\n$$\n$$\n\\lambda_1^{+} = \\frac{4}{5}\n$$\n这满足对偶可行性条件 $\\lambda_1^{+} \\ge 0$。\n\n**对于分量2**：\n- $m_2^{\\star} = \\frac{1}{20}$。解位于可行区间 $[0, \\frac{1}{5}]$ 的内部。\n- 上界和下界都是非激活的：$l_2  m_2^{\\star}  u_2$。\n- 根据互补松弛性，这意味着 $\\lambda_2^{+} = 0$ 且 $\\lambda_2^{-} = 0$。\n- 我们验证 $m_2$ 的平稳性条件：$2m_2^{\\star} - d_2 + \\lambda_2^{+} - \\lambda_2^{-} = 0$。\n$$\n2\\left(\\frac{1}{20}\\right) - \\frac{1}{10} + 0 - 0 = \\frac{1}{10} - \\frac{1}{10} = 0\n$$\n该条件恒等满足。\n\n完整的解是：\n$m^{\\star} = \\begin{pmatrix} \\frac{3}{5} \\\\ \\frac{1}{20} \\end{pmatrix}$，$\\lambda^{+} = \\begin{pmatrix} \\frac{4}{5} \\\\ 0 \\end{pmatrix}$，$\\lambda^{-} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。\n\n问题要求上界乘子的第一个分量的标量值，即 $\\lambda_1^{+}$。我们的计算表明该值为 $\\frac{4}{5}$。", "answer": "$$\\boxed{\\frac{4}{5}}$$", "id": "3578366"}, {"introduction": "确立了最优解的理论目标（即满足KKT条件的点）之后，下一步是设计算法来找到它。本练习将向您介绍投影梯度法，这是一种处理边界约束的基础迭代技术。通过亲手实现算法的核心步骤，包括确保目标函数充分下降的关键Armijo线搜索，您将获得处理约束优化问题的宝贵实践经验。[@problem_id:3578294]", "problem": "考虑计算地球物理学中的边界约束最小二乘失配问题，其函数定义为 $f(x) = \\tfrac{1}{2}\\lVert A x - b \\rVert_2^2$，其中给定 $A \\in \\mathbb{R}^{m \\times n}$ 和 $b \\in \\mathbb{R}^m$。变量 $x \\in \\mathbb{R}^n$ 被约束在盒子 $\\mathcal{C} = \\{x \\in \\mathbb{R}^n : \\ell \\le x \\le u\\}$ 内，其中的不等式按分量进行解释，$\\ell, u \\in \\mathbb{R}^n$ 分别指定了下界和上界。到 $\\mathcal{C}$ 上的欧几里得投影记为 $P_{\\mathcal{C}}$。\n\n从欧几里得范数和可微映射微积分的基本定义出发，您的任务是：\n- 为投影梯度更新推导一个可行步长，并基于投影方向推导一个 Armijo 类型的充分下降条件，确保更新线段上的所有点都具有可行性。\n- 实现单次迭代，给定 $A$、$b$、$\\ell$、$u$、$x$、试验步长 $\\tau$、Armijo 参数 $c$（$0  c  1$）以及回溯因子 $\\beta$（$0  \\beta  1$），计算投影方向 $s = P_{\\mathcal{C}}(x - \\tau \\nabla f(x)) - x$，然后对 $\\alpha \\in \\{1, \\beta, \\beta^2, \\dots\\}$ 执行回溯，以找到能使 Armijo 充分下降条件\n$$\nf(x + \\alpha s) \\le f(x) + c \\,\\alpha \\,\\nabla f(x)^{\\top} s\n$$\n成立的 $\\beta$ 的最小次幂。如果 $s = 0$，则设置 $\\alpha = 0$ 并返回未改变的失配值。\n\n您的程序必须为以下测试套件实现上述逻辑。对于每个案例，Armijo 常数是共享的，给定为 $c = 10^{-4}$ 和 $\\beta = 0.5$。\n\n测试案例 1 (一般情况):\n$$\nA^{(1)} = \\begin{bmatrix}\n3  -1  0  2 \\\\\n0  2  -1  1 \\\\\n-2  0  1  -3 \\\\\n1.5  -0.5  0  1 \\\\\n0  1  1  0\n\\end{bmatrix},\\quad\nb^{(1)} = \\begin{bmatrix}\n1 \\\\ -2 \\\\ 0.5 \\\\ 3 \\\\ -1\n\\end{bmatrix},\\quad\n\\ell^{(1)} = \\begin{bmatrix}\n-1 \\\\ -0.5 \\\\ -0.25 \\\\ -2\n\\end{bmatrix},\\quad\nu^{(1)} = \\begin{bmatrix}\n2 \\\\ 1.5 \\\\ 1.75 \\\\ 3\n\\end{bmatrix},\\quad\nx^{(1)} = \\begin{bmatrix}\n0.5 \\\\ 0 \\\\ 1.5 \\\\ -1\n\\end{bmatrix},\\quad\n\\tau^{(1)} = 0.7.\n$$\n\n测试案例 2 (边界交互情况):\n$$\nA^{(2)} = \\begin{bmatrix}\n2  0  -1 \\\\\n0  1  0 \\\\\n1  -2  3\n\\end{bmatrix},\\quad\nb^{(2)} = \\begin{bmatrix}\n1 \\\\ -1 \\\\ 2\n\\end{bmatrix},\\quad\n\\ell^{(2)} = \\begin{bmatrix}\n-1 \\\\ -0.5 \\\\ -0.5\n\\end{bmatrix},\\quad\nu^{(2)} = \\begin{bmatrix}\n1 \\\\ 0.5 \\\\ 1\n\\end{bmatrix},\\quad\nx^{(2)} = \\begin{bmatrix}\n0.9 \\\\ 0.5 \\\\ 1\n\\end{bmatrix},\\quad\n\\tau^{(2)} = 0.6.\n$$\n\n测试案例 3 (投影方向为零的边缘情况):\n$$\nA^{(3)} = I_3,\\quad\nb^{(3)} = \\begin{bmatrix}\n-3 \\\\ -2 \\\\ 0\n\\end{bmatrix},\\quad\n\\ell^{(3)} = \\begin{bmatrix}\n-2 \\\\ -1 \\\\ 1\n\\end{bmatrix},\\quad\nu^{(3)} = \\begin{bmatrix}\n0 \\\\ 2 \\\\ 3\n\\end{bmatrix},\\quad\nx^{(3)} = \\ell^{(3)},\\quad\n\\tau^{(3)} = 0.9.\n$$\n\n对于每个测试案例，输出接受的回溯步长 $\\alpha$ 和得到的失配值 $f(x + \\alpha s)$。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，每个测试案例贡献一个形式为 $[\\alpha, f_{\\text{new}}]$ 的双元素列表。例如，格式应类似于 $[[\\alpha_1, f_1],[\\alpha_2, f_2],[\\alpha_3, f_3]]$，其中符号由数值代替。不涉及物理单位，也不存在角度；所有数值输出均为无单位的实数。", "solution": "该问题要求针对一个边界约束的线性最小二乘问题，推导并实现带有 Armijo 回溯线搜索的投影梯度法的单次迭代。该问题定义明确，数学上合理，并为获得唯一解提供了所有必要信息。\n\n设目标函数为 $f(x) = \\frac{1}{2}\\lVert A x - b \\rVert_2^2$，其中 $x \\in \\mathbb{R}^n$ 服从边界约束 $\\ell \\le x \\le u$。这些约束定义了一个凸闭集 $\\mathcal{C} = \\{x \\in \\mathbb{R}^n : \\ell_i \\le x_i \\le u_i, \\forall i=1,\\dots,n\\}$。\n\n首先，我们推导目标函数的梯度 $\\nabla f(x)$。平方欧几里得范数可以写成内积形式：\n$$\nf(x) = \\frac{1}{2} (Ax - b)^{\\top}(Ax - b) = \\frac{1}{2} (x^{\\top}A^{\\top}Ax - x^{\\top}A^{\\top}b - b^{\\top}Ax + b^{\\top}b)\n$$\n由于标量项 $x^{\\top}A^{\\top}b$ 等于其转置 $b^{\\top}Ax$，我们可以合并这些项：\n$$\nf(x) = \\frac{1}{2} (x^{\\top}A^{\\top}Ax - 2b^{\\top}Ax + b^{\\top}b)\n$$\n为了求梯度，我们将 $f(x)$ 对向量 $x$ 求导。使用标准矩阵微积分恒等式 $\\nabla_x (x^{\\top}Mx) = (M+M^{\\top})x$ 和 $\\nabla_x (c^{\\top}x) = c$，并注意到 $A^{\\top}A$ 是对称的，我们得到：\n$$\n\\nabla f(x) = \\frac{1}{2} (2A^{\\top}Ax - 2A^{\\top}b) = A^{\\top}(Ax - b)\n$$\n投影梯度法通过先沿负梯度方向走一步，然后将得到的点投影回可行集 $\\mathcal{C}$ 来生成搜索方向。给定一个当前可行点 $x$ 和一个试验步长 $\\tau > 0$，投影方向 $s$ 定义为：\n$$\ns = P_{\\mathcal{C}}(x - \\tau \\nabla f(x)) - x\n$$\n其中 $P_{\\mathcal{C}}$ 是到集合 $\\mathcal{C}$ 上的欧几里得投影。对于盒子约束，该投影是按分量计算的：$(P_{\\mathcal{C}}(y))_i = \\max(\\ell_i, \\min(y_i, u_i))$。\n\n该方向的一个重要性质是，对于任意步长 $\\alpha \\in [0, 1]$，步进 $x_{new} = x + \\alpha s$ 保持可行。这是因为 $x_{new}$ 可以写成 $\\mathcal{C}$ 中两个点的凸组合：\n$$\nx + \\alpha s = x + \\alpha (P_{\\mathcal{C}}(x - \\tau \\nabla f(x)) - x) = (1-\\alpha)x + \\alpha P_{\\mathcal{C}}(x - \\tau \\nabla f(x))\n$$\n由于 $x \\in \\mathcal{C}$ 且 $P_{\\mathcal{C}}(\\cdot)$ 将任何点映射到 $\\mathcal{C}$，而 $\\mathcal{C}$ 是一个凸集，因此这两个点的凸组合也必定位于 $\\mathcal{C}$ 内。\n\n如果 $x$ 不是稳定点，则方向 $s$ 是一个下降方向，即 $\\nabla f(x)^{\\top}s  0$。对于此约束问题，一个稳定点满足条件 $x = P_{\\mathcal{C}}(x - \\tau \\nabla f(x))$（对任意 $\\tau > 0$），这意味着 $s = 0$。如果 $s \\neq 0$，则 $s$ 保证是一个下降方向。\n\n为确保目标函数的充分下降和整体算法的收敛，我们采用 Armijo 回溯线搜索。我们从序列 $\\{1, \\beta, \\beta^2, \\dots\\}$ 中寻找最大的步长 $\\alpha$（其中 $\\beta \\in (0, 1)$ 是一个回溯因子），使得以下充分下降条件成立：\n$$\nf(x + \\alpha s) \\le f(x) + c \\alpha \\nabla f(x)^{\\top} s\n$$\n此处，$c \\in (0, 1)$ 是一个控制参数。由于对于非稳定点有 $\\nabla f(x)^{\\top}s  0$，因此当 $\\alpha > 0$ 时，右侧的项严格小于 $f(x)$。线搜索从 $\\alpha=1$（即朝向投影点的完整步长）开始，并不断将 $\\alpha$ 乘以因子 $\\beta$ 进行缩减，直到满足该条件。由于 $f$ 是连续可微的，该过程保证会以一个正的步长终止。\n\n单次迭代的完整算法如下：\n1.  给定当前可行点 $x$、问题数据 $A, b, \\ell, u$ 以及参数 $\\tau, c, \\beta$。\n2.  计算梯度：$\\nabla f(x) = A^{\\top}(Ax-b)$。\n3.  计算投影方向：$s = P_{\\mathcal{C}}(x - \\tau \\nabla f(x)) - x$。\n4.  如果 $s=0$（在数值容差范围内），则该点为稳定点。设置 $\\alpha=0$，新的失配值为 $f(x)$。\n5.  如果 $s \\neq 0$，计算 Armijo 条件所需的项：$d = \\nabla f(x)^{\\top}s$。\n6.  初始化步长 $\\alpha = 1$。\n7.  开始回溯循环：\n    a. 计算新的候选点 $x_{new} = x + \\alpha s$。\n    b. 在新点处评估目标函数值 $f(x_{new})$。\n    c. 检查 Armijo 条件：$f(x_{new}) \\le f(x) + c \\alpha d$。\n    d. 如果条件满足，则接受 $\\alpha$ 和 $f(x_{new})$，然后终止循环。\n    e. 如果不满足，则缩减步长：$\\alpha \\leftarrow \\beta \\alpha$，并继续循环。\n8.  返回接受的步长 $\\alpha$ 和对应的失配值 $f(x_{new})$。\n对每个给定的测试案例都实现了此过程。", "answer": "```python\nimport numpy as np\n\ndef perform_iteration(A, b, l, u, x, tau, c, beta):\n    \"\"\"\n    Performs a single iteration of the projected gradient method with Armijo line search.\n    \n    Args:\n        A (np.ndarray): The matrix A.\n        b (np.ndarray): The vector b.\n        l (np.ndarray): The lower bounds for x.\n        u (np.ndarray): The upper bounds for x.\n        x (np.ndarray): The current point.\n        tau (float): The trial step size for the projection.\n        c (float): The Armijo condition parameter.\n        beta (float): The backtracking factor.\n        \n    Returns:\n        tuple[float, float]: The accepted step length alpha and the new misfit value.\n    \"\"\"\n    \n    # 1. Compute misfit and gradient at the current point x\n    res = A @ x - b\n    f_x = 0.5 * np.dot(res, res)\n    grad_f = A.T @ res\n    \n    # 2. Compute the projected direction s\n    x_trial = x - tau * grad_f\n    x_proj = np.clip(x_trial, l, u)\n    s = x_proj - x\n    \n    # 3. Handle the stationary point case (s is the zero vector)\n    if np.allclose(s, 0.0):\n        return 0.0, f_x\n        \n    # 4. Compute the directional derivative term for Armijo condition\n    # This is grad_f.T @ s\n    directional_derivative_term = np.dot(grad_f, s)\n\n    # 5. Perform Armijo backtracking line search\n    alpha = 1.0\n    while True:\n        x_new = x + alpha * s\n        res_new = A @ x_new - b\n        f_new = 0.5 * np.dot(res_new, res_new)\n        \n        # Check Armijo condition\n        if f_new = f_x + c * alpha * directional_derivative_term:\n            return alpha, f_new\n        \n        # Backtrack\n        alpha *= beta\n        # Safety break for cases where floating point issues might cause an infinite loop\n        if alpha  1e-16:\n             return alpha / beta, f_new # return the last calculated valid state\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    # Armijo constants\n    c = 1e-4\n    beta = 0.5\n\n    # Test Case 1\n    A1 = np.array([\n        [3, -1, 0, 2],\n        [0, 2, -1, 1],\n        [-2, 0, 1, -3],\n        [1.5, -0.5, 0, 1],\n        [0, 1, 1, 0]\n    ])\n    b1 = np.array([1, -2, 0.5, 3, -1])\n    l1 = np.array([-1, -0.5, -0.25, -2])\n    u1 = np.array([2, 1.5, 1.75, 3])\n    x1 = np.array([0.5, 0, 1.5, -1])\n    tau1 = 0.7\n\n    # Test Case 2\n    A2 = np.array([\n        [2, 0, -1],\n        [0, 1, 0],\n        [1, -2, 3]\n    ])\n    b2 = np.array([1, -1, 2])\n    l2 = np.array([-1, -0.5, -0.5])\n    u2 = np.array([1, 0.5, 1])\n    x2 = np.array([0.9, 0.5, 1])\n    tau2 = 0.6\n    \n    # Test Case 3\n    A3 = np.identity(3)\n    b3 = np.array([-3, -2, 0])\n    l3 = np.array([-2, -1, 1])\n    u3 = np.array([0, 2, 3])\n    x3 = np.array([-2, -1, 1])  # x is at the lower bound\n    tau3 = 0.9\n\n    test_cases = [\n        (A1, b1, l1, u1, x1, tau1),\n        (A2, b2, l2, u2, x2, tau2),\n        (A3, b3, l3, u3, x3, tau3)\n    ]\n    \n    results = []\n    for case in test_cases:\n        alpha, f_new = perform_iteration(*case, c, beta)\n        results.append([alpha, f_new])\n\n    # Format the final output string exactly as requested\n    formatted_results = \",\".join([f\"[{res[0]},{res[1]}]\" for res in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "3578294"}, {"introduction": "对于地球物理学中常见的大规模问题，简单的梯度法收敛速度可能较慢。本练习将探索 L-BFGS-B 算法，这是一种先进的拟牛顿方法，它通过近似问题的曲率信息来加速收敛。您将深入了解这一强大算法的核心机制，包括其为保证计算效率而设计的著名双循环递归，以及为处理真实世界噪声数据所必需的曲率阻尼策略。[@problem_id:3578350]", "problem": "在对地下密度参数具有箱式约束的大尺度重力反演中，您需要最小化一个目标函数，该函数是最小二乘数据失配项和受边界约束的 Tikhonov 正则化项之和，即 $\\min_{m \\in [m_{\\min}, m_{\\max}]} \\ \\phi(m)$。在第 $k$ 次迭代时，带边界约束的限域记忆 Broyden–Fletcher–Goldfarb–Shanno (L-BFGS-B) 方法构造一个搜索方向 $p_k = -H_k g_k^{P}$，其中 $H_k$ 是一个限域记忆逆 Hessian 近似，而 $g_k^{P}$ 是投影梯度，它在处于边界上的活动变量上为零，在自由变量上等于真实梯度。由于随机正演模拟和伴随计算，梯度差分是含噪声的，并且保证正定性所需的曲率条件可能会被违反。\n\n从拟牛顿法的基本原理可知，对于割线条件 $B_{k+1} s_k = y_k$（其中 $s_k = m_{k+1}-m_k$ 且 $y_k = \\nabla \\phi(m_{k+1}) - \\nabla \\phi(m_k)$），当 $s_k^{\\top} y_k > 0$ 时，Broyden–Fletcher–Goldfarb–Shanno (BFGS) 更新会保持正定性。在限域记忆形式中，只存储最近的 $m$ 个曲率对，并通过双循环递归将得到的 $H_k$ 应用于一个向量，而无需显式构造 $H_k$。对于边界约束问题，递归必须遵循活动集。当含噪声的梯度导致 $s_i^{\\top} y_i \\le 0$ 时，必须使用一种阻尼策略来保持 $H_k \\succ 0$，同时忠实于割线信息。\n\n哪个选项正确地指明了以下两点：\n(i) 使用存储的曲率对计算 $p_k = -H_k g_k^{P}$ 的双循环递归，包括如何处理边界；以及\n(ii) 一种在含噪声的地球物理梯度下保证 $H_k \\succ 0$ 的合理曲率阻尼策略，其参数选择能对 $s_i^{\\top} y_i$ 强制施加一个定量的下界？\n\nA. 令 $\\mathcal{F}_k$ 为第 $k$ 次迭代时的自由集，令 $Z_k$ 为到 $\\mathcal{F}_k$ 上的选择算子。定义 $q = Z_k^{\\top} g_k^{P}$ (即限制在 $\\mathcal{F}_k$ 上的梯度)。对于限制在 $\\mathcal{F}_k$ 上的存储对 $\\{(s_i, y_i)\\}_{i=k-m+1}^{k}$，设 $\\rho_i = 1/(y_i^{\\top} s_i)$。后向循环：对于 $i=k, k-1, \\dots, k-m+1$，计算 $\\alpha_i = \\rho_i \\, s_i^{\\top} q$ 并更新 $q \\leftarrow q - \\alpha_i y_i$。选择初始逆 Hessian 缩放 $H_0 = \\gamma_k I$，其中若 $k \\ge 1$，则 $\\gamma_k = (s_{k-1}^{\\top} y_{k-1})/(y_{k-1}^{\\top} y_{k-1}) > 0$，并设 $r = H_0 q$。前向循环：对于 $i=k-m+1, \\dots, k$，计算 $\\beta_i = \\rho_i \\, y_i^{\\top} r$ 并更新 $r \\leftarrow r + s_i (\\alpha_i - \\beta_i)$。最后，设 $p_k = -Z_k r$。对于含噪声梯度下的曲率阻尼，将任何违反 $s_i^{\\top} y_i \\ge \\mu \\|s_i\\|_2^2$（对于用户选择的 $\\mu > 0$）的 $y_i$ 替换为 $\\tilde y_i = y_i + \\lambda_i s_i$，其中 $\\lambda_i = \\max\\{0, \\mu \\|s_i\\|_2^2 - s_i^{\\top} y_i\\}/\\|s_i\\|_2^2$。这能确保 $s_i^{\\top} \\tilde y_i \\ge \\mu \\|s_i\\|_2^2$ 并保持限域记忆 BFGS 更新在自由子空间上的正定性。\n\nB. 通过在所有变量上设置 $q = H_0 g_k$ 来初始化双循环递归，并首先执行前向循环：对于 $i=k-m+1, \\dots, k$，计算 $\\alpha_i = (y_i^{\\top} q)/(s_i^{\\top} y_i)$ 并更新 $q \\leftarrow q - \\alpha_i s_i$。然后应用 $H_0 = \\gamma_k I$，其中 $\\gamma_k = (y_{k-1}^{\\top} y_{k-1})/(s_{k-1}^{\\top} y_{k-1})$，最后执行后向循环以获得 $p_k = -q$。边界通过在递归后投影 $p_k$ 来处理。为在噪声下强制保持正定性，保持 $y_i$ 不变，而是将 $s_i$ 阻尼为 $\\tilde s_i = \\theta_i s_i$，其中选择 $\\theta_i \\in (0,1)$ 以使得 $\\tilde s_i^{\\top} y_i > 0$。\n\nC. 将双循环递归应用于全空间中的完整梯度 $g_k$ 和所有存储的对，忽略活动边界，以得到 $p_k = -H_k g_k$，然后将得到的 $p_k$ 投影到可行集上。为数值稳定性使用 $H_0 = I$。如果任何 $s_i^{\\top} y_i \\le 0$，不修改 $y_i$，仅将初始尺度 $\\gamma_k$ 调整得非常小以保持稳定性。\n\nD. 对于阻尼，使用 Powell 的阻尼 BFGS 方法与 $B$ 空间曲率：如果 $s_i^{\\top} y_i  c \\, s_i^{\\top} B s_i$ (对于某个 $c \\in (0,1)$)，设 $\\tilde y_i = y_i + \\eta_i B s_i$，其中选择 $\\eta_i$ 使得 $s_i^{\\top} \\tilde y_i = c \\, s_i^{\\top} B s_i$，然后在 L-BFGS 中存储 $(s_i, \\tilde y_i)$。通过 $y_i$ 近似 $B s_i$ 以避免构造 $B$。由于阻尼已经校正了曲率，边界处理与无约束情况相同。双循环递归不变。", "solution": "用户要求对问题陈述进行严格验证，然后基于第一性原理进行推导，并评估在地球物理反演背景下关于 L-BFGS-B 算法的所提供选项。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n-   **背景**：对地下密度参数 $m \\in [m_{\\min}, m_{\\max}]$ 具有箱式约束的大尺度重力反演。\n-   **目标函数**：$\\min_{m} \\ \\phi(m)$，其中 $\\phi(m)$ 是最小二乘数据失配项和 Tikhonov 正则化项的和。\n-   **算法**：带边界约束的限域记忆 Broyden–Fletcher–Goldfarb–Shanno (L-BFGS-B)。\n-   **搜索方向**：在第 $k$ 次迭代时，$p_k = -H_k g_k^{P}$。\n-   **定义**：\n    -   $H_k$：一个限域记忆逆 Hessian 近似。\n    -   $g_k^{P}$：投影梯度，对于处于边界上的活动变量为零，对于自由变量等于真实梯度 $\\nabla \\phi(m_k)$。\n    -   $s_k = m_{k+1}-m_k$。\n    -   $y_k = \\nabla \\phi(m_{k+1}) - \\nabla \\phi(m_k)$。\n-   **条件与挑战**：\n    -   由于随机正演模拟和伴随计算，梯度是含噪声的。\n    -   BFGS 更新所需正定性的曲率条件 $s_k^{\\top} y_k > 0$ 可能会被违反（$s_k^{\\top} y_k \\le 0$）。\n    -   L-BFGS 存储最近的 $m$ 个曲率对 $\\{(s_i, y_i)\\}$，并使用双循环递归计算乘积 $H_k v$。\n    -   对于边界约束问题，递归必须遵循约束的活动集。\n    -   当 $s_i^{\\top} y_i \\le 0$ 时，需要一种阻尼策略来保持 $H_k \\succ 0$（正定）。\n-   **问题**：识别出正确指定以下两项的选项：\n    (i) 用于计算 $p_k = -H_k g_k^{P}$ 并处理边界的双循环递归。\n    (ii) 一种合理的曲率阻尼策略，保证在有噪声的情况下 $H_k \\succ 0$，并对 $s_i^{\\top} y_i$ 强制施加一个定量的下界。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学依据**：该问题在数值优化和计算地球物理学领域有充分的科学依据。L-BFGS-B 是用于大规模边界约束优化的标准算法。Tikhonov 正则化的使用、投影梯度的概念，以及由含噪声梯度导致的曲率条件违反等挑战，都是解决反演问题时的标准和现实方面。\n-   **适定性**：该问题是适定的。它要求对一个已知算法 (L-BFGS-B) 的两个关键组成部分进行正确描述，而不是求解一个未充分定义的优化问题。这些算法描述的正确性可以对照已有文献进行验证，例如 Nocedal 和 Wright 的《Numerical Optimization》或 Byrd, Lu, Nocedal 和 Zhu 的原始论文。\n-   **客观性**：问题陈述是客观的，并使用了数值分析中精确的技术术语。没有主观或含糊的陈述。\n-   **一致性与完整性**：问题陈述内部一致，并提供了足够的信息来评估选项。它正确地构建了 L-BFGS 方法、其对边界约束的扩展 (L-BFGS-B)，以及为处理含噪声函数评估而进行修改的需求。\n\n**步骤 3：结论与行动**\n问题陈述是有效的。它在科学上是合理的、适定的、客观的，并为评估所提出的算法描述提供了明确的基础。解题过程可以继续。\n\n**推导与选项分析**\n\n任务是识别在含噪声条件下 L-BFGS-B 算法的两个组成部分的正确描述：(i) 考虑边界的双循环递归和 (ii) 曲率阻尼策略。\n\n**(i) L-BFGS-B 的双循环递归**\nL-BFGS-B 算法不只是简单地将最终搜索方向投影到可行集上，因为这样效率低下。相反，它识别出当前迭代点 $m_k$ 的*自由变量*集（即那些不处于下界或上界的变量），并在这个子空间上执行 L-BFGS 更新。\n\n令 $\\mathcal{F}_k$ 为第 $k$ 次迭代时自由变量的索引集。搜索方向 $p_k$ 对于不在 $\\mathcal{F}_k$ 中的变量，其分量必须为零。令 $Z_k$ 为一个投影矩阵，它选择一个向量中对应于自由变量的分量。L-BFGS 的机制被应用于由 $Z_k$ 定义的子空间。\n\n对于无约束问题，计算 $r = H_k g$ 的标准双循环递归是：\n1.  令 $q \\leftarrow g$。\n2.  **后向循环**：对于 $i = k-1, \\ldots, k-m$：\n    $\\alpha_i \\leftarrow \\rho_i s_i^\\top q$，其中 $\\rho_i = 1 / (y_i^\\top s_i)$。\n    $q \\leftarrow q - \\alpha_i y_i$。\n3.  令 $r \\leftarrow H_k^0 q$，其中 $H_k^0 = \\gamma_k I$ 是一个初始逆 Hessian 近似。一个常见的选择是 $\\gamma_k = (s_{k-1}^\\top y_{k-1}) / (y_{k-1}^\\top y_{k-1})$。\n4.  **前向循环**：对于 $i = k-m, \\ldots, k-1$：\n    $\\beta_i \\leftarrow \\rho_i y_i^\\top r$。\n    $r \\leftarrow r + s_i (\\alpha_i - \\beta_i)$。\n5.  结果是 $r$。\n\n对于带边界约束的情况 (L-BFGS-B)，此递归应用于自由变量的子空间。使用的梯度是投影梯度 $g_k^P$，限制在自由子空间内。存储的向量 $s_i$ 和 $y_i$ 同样限制在该子空间内。在子空间中得到的搜索方向 $\\hat{p}_k$ 然后被映射回全空间，活动变量对应的分量为零。\n\n遵循此逻辑，程序应该是：\n1.  定义自由子空间上的梯度：$\\hat{g}_k = Z_k^\\top g_k^P$。\n2.  使用子空间向量 $\\hat{s}_i = Z_k^\\top s_i$ 和 $\\hat{y}_i = Z_k^\\top y_i$ 将双循环递归应用于 $\\hat{g}_k$，以获得子空间方向 $\\hat{r}$。\n3.  搜索方向则为 $p_k = -Z_k \\hat{r}$。\n\n**(ii) 曲率阻尼策略**\nBFGS 更新当且仅当曲率条件 $s_k^\\top y_k > 0$ 满足时才保持正定性。对于含噪声的梯度，可能会出现 $s_k^\\top y_k \\le 0$。一种常见的策略是通过将 $y_k$ 修改为一个满足强化条件的新向量 $\\tilde{y}_k$ 来*阻尼*更新。一种稳健的方法是要求 $s_k^\\top \\tilde{y}_k \\ge \\mu \\|s_k\\|_2^2$，其中 $\\mu$ 是某个小的正常数。\n\n实现此目的的一种方法是寻找对 $y_k$ 的最小修改。考虑形式为 $\\tilde{y}_k = y_k + \\lambda_k s_k$ 的修正。我们希望找到最小的 $\\lambda_k \\ge 0$ 使得 $s_k^\\top(y_k + \\lambda_k s_k) \\ge \\mu \\|s_k\\|_2^2$。\n$$ s_k^\\top y_k + \\lambda_k s_k^\\top s_k \\ge \\mu \\|s_k\\|_2^2 $$\n$$ \\lambda_k \\|s_k\\|_2^2 \\ge \\mu \\|s_k\\|_2^2 - s_k^\\top y_k $$\n如果 $s_k^\\top y_k \\ge \\mu \\|s_k\\|_2^2$，则条件已经满足，我们可以选择 $\\lambda_k=0$。否则，我们需要选择 $\\lambda_k \\ge (\\mu \\|s_k\\|_2^2 - s_k^\\top y_k) / \\|s_k\\|_2^2$。最小的此类非负 $\\lambda_k$ 正是这个值。\n因此，修正因子为：\n$$ \\lambda_k = \\max\\left\\{0, \\frac{\\mu \\|s_k\\|_2^2 - s_k^\\top y_k}{\\|s_k\\|_2^2}\\right\\} $$\n修改后的梯度差分为 $\\tilde{y}_k = y_k + \\lambda_k s_k$。这是一个标准的、有充分理由的阻尼过程。\n\n**选项评估**\n\n*   **选项 A**：\n    -   **(i) 递归**：此选项正确地描述了 L-BFGS-B 的子空间方法。它定义了 $q = Z_k^{\\top} g_k^{P}$，即限制在自由变量上的梯度。它正确地陈述了后向循环、缩放 $\\gamma_k = (s_{k-1}^{\\top} y_{k-1})/(y_{k-1}^{\\top} y_{k-1})$、前向循环以及最终的映射 $p_k = -Z_k r$。递归的描述是正确的。\n    -   **(ii) 阻尼**：此选项描述了上面推导出的确切的阻尼策略。它用 $\\tilde y_i = y_i + \\lambda_i s_i$ 替换 $y_i$，并使用 $\\lambda_i = \\max\\{0, \\mu \\|s_i\\|_2^2 - s_i^{\\top} y_i\\}/\\|s_i\\|_2^2$ 来强制 $s_i^{\\top} \\tilde y_i \\ge \\mu \\|s_i\\|_2^2$。这是一个合理且标准的方法。\n    -   **结论**：**正确**。\n\n*   **选项 B**：\n    -   **(i) 递归**：此选项颠倒了循环的顺序（先向前再向后），这对于逆 Hessian 近似 $H_k$ 是不正确的。它还在开始时应用了初始缩放 $H_0$，这是错误的。给出的更新公式对于标准的 $H_k g$ 递归也是不正确的。处理边界的策略（“在递归后投影 $p_k$”）是幼稚的，并且不是 L-BFGS-B 的做法。\n    -   **(ii) 阻尼**：它建议阻尼 $s_i$ 而不是 $y_i$。向量 $s_i=m_{i+1}-m_i$ 代表了实际采取的步长；修改它将不忠实于优化轨迹。梯度差分 $y_i$ 是曲率信息所在之处，也是噪声的来源，使其成为合乎逻辑的修改目标。\n    -   **结论**：**不正确**。\n\n*   **选项 C**：\n    -   **(i) 递归**：此选项建议在递归期间忽略边界，并投影最终的搜索方向。与选项 B 一样，这是一个次优策略，不是 L-BFGS-B 的工作方式。\n    -   **(ii) 阻尼**：它建议如果 $s_i^{\\top} y_i \\le 0$，只调整初始尺度 $\\gamma_k$。这是不足够的。项 $\\rho_i = 1/(s_i^{\\top} y_i)$ 出现在主要的 BFGS 更新结构中。如果 $s_i^{\\top} y_i \\le 0$，该项为负或未定义，这会损害更新项本身的正定性，而与初始缩放矩阵 $H_0$ 无关。跳过更新是一种可能性，但所提议的对 $\\gamma_k$ 的调整并不能解决曲率对 $(s_i, y_i)$ 的根本问题。\n    -   **结论**：**不正确**。\n\n*   **选项 D**：\n    -   **(i) 递归**：它错误地声称阻尼曲率使得可以像无约束情况一样处理边界。这是两个独立的问题。阻尼确保 Hessian 近似是正定的；处理边界确保迭代保持可行并正确识别最优活动集。\n    -   **(ii) 阻尼**：它引用了 Powell 的方法，但随后引入了一个有缺陷的近似。在条件 $s_i^{\\top} y_i  c \\, s_i^{\\top} B s_i$ 中用梯度差分 $y_i$ 近似 Hessian-向量积 $B s_i$ 会导致无意义的条件 $s_i^{\\top} y_i  c \\, s_i^{\\top} y_i$，如果 $s_i^{\\top} y_i > 0$ 且 $c \\in (0,1)$ 则永不成立，如果 $s_i^{\\top} y_i  0$ 则永远成立。提议的更新 $\\tilde y_i = y_i + \\eta_i B s_i \\approx (1+\\eta_i)y_i$ 不会改变负曲率 $s_i^{\\top}y_i$ 的符号。这是对该方法的严重误用。\n    -   **结论**：**不正确**。\n\n结论：选项 A 是唯一一个对边界处理机制和阻尼策略都给出了正确且连贯的描述，并与 L-BFGS-B 算法的原理一致的选项。", "answer": "$$\\boxed{A}$$", "id": "3578350"}]}