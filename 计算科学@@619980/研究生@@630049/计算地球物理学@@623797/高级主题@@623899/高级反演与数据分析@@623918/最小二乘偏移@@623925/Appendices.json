{"hands_on_practices": [{"introduction": "在最小二乘法偏移（LSM）中，目标函数相对于模型参数的梯度是通过伴随算子（$F^*$）计算的。因此，确保伴随算子实现的正确性是任何基于梯度的反演算法成功的绝对前提。本练习 [@problem_id:3606465] 将指导你通过点积测试（$\\langle F m, y \\rangle = \\langle m, F^* y \\rangle$）来验证这一关键属性，这是验证伴随算子正确性的基本数值方法，也是计算地球物理学中的一项核心技能。", "problem": "以一维常密度声波方程为基本物理模型，其中位移场 $u(x,t)$ 的时间二阶导数等于波速平方缩放后的空间二阶导数与一个外部源项之和。连续模型由下式给出\n$$\n\\frac{\\partial^2 u(x,t)}{\\partial t^2} = c^2 \\frac{\\partial^2 u(x,t)}{\\partial x^2} + f(x,t),\n$$\n其中 $c$ 是波速，$f(x,t)$ 是一个源项。我们将空间域离散化为 $N_x$ 个网格点，间距为 $\\Delta x$；将时间域离散化为 $T$ 个时间步，步长为 $\\Delta t$。在时间和空间上使用二阶精度中心有限差分格式，场 $u^t \\in \\mathbb{R}^{N_x}$ 在时间索引 $t$ 处的离散更新公式为\n$$\nu^{t+1} = 2 u^t - u^{t-1} + \\alpha \\, L \\, u^t + \\Delta t^2 \\, f^t,\n$$\n其中 $L$ 表示离散拉普拉斯算子，且 $\\alpha = \\left( \\frac{c \\, \\Delta t}{\\Delta x} \\right)^2$。离散拉普拉斯算子 $L$ 可以使用狄利克雷（Dirichlet）边界条件（边界位移为零）或周期性边界条件（环绕邻居）构建，在标准欧几里得内积下，这两种条件都会产生一个对称的 $L$。假设初始条件为 $u^{-1} = 0$ 和 $u^0 = 0$。\n\n将模型参数 $m \\in \\mathbb{R}^{N_x}$ 定义为一个空间加权，它在所有空间网格点上对给定的时间源子波 $s^t \\in \\mathbb{R}$ 进行相同的缩放，即\n$$\nf^t = s^t \\, m.\n$$\n令接收点采样算子在一组接收点索引 $\\{r_k\\}_{k=1}^R$ 处提取场 $u^t$，得到数据 $d^{t,k} = u^t[r_k]$。这定义了一个线性正演算子 $F : \\mathbb{R}^{N_x} \\to \\mathbb{R}^{T \\times R}$，它通过时间步进传播算子和接收点采样将 $m$ 映射到数据 $d$。\n\n在最小二乘偏移中，验证离散模拟算子的伴随一致性至关重要。在欧几里得内积下，伴随算子 $F^\\ast$ 定义为\n$$\n\\langle F m, y \\rangle = \\langle m, F^\\ast y \\rangle\n$$\n对于所有 $m \\in \\mathbb{R}^{N_x}$ 和 $y \\in \\mathbb{R}^{T \\times R}$，其中\n$$\n\\langle F m, y \\rangle = \\sum_{t=0}^{T-1} \\sum_{k=1}^{R} d^{t,k} \\, y^{t,k}, \\quad \\text{以及} \\quad \\langle m, n \\rangle = \\sum_{i=0}^{N_x-1} m_i \\, n_i.\n$$\n你必须构建一个可微的离散波传播算子，并对其计算图使用逆模式自动微分来计算任意 $y$ 的 $F^\\ast y$。具体来说，逆模式扫描必须从离散更新方程导出，使用正向传播中遇到的线性算子的转置，并通过源注入项 $\\Delta t^2 \\, s^t \\, m$ 累积关于 $m$ 的梯度。\n\n你的任务：\n- 实现离散正向传播算子，该算子将 $F$ 应用于 $m$ 以生成数据 $d$，使用上述有限差分格式，并支持狄利克雷和周期性两种边界条件。拉普拉斯算子 $L$ 必须是与所选边界条件一致的标准二阶模板构建的。\n- 实现逆模式自动微分，通过在时间步进格式上进行反向传播来计算任意 $y \\in \\mathbb{R}^{T \\times R}$ 的 $F^\\ast y$。逆模式更新必须使用正向格式中算子的转置操作，注意在欧几里得内积下，离散拉普拉斯算子和由此产生的线性算子 $A = 2 I + \\alpha L$ 都是对称的。\n- 对每个测试用例，计算标量梯度不匹配值\n$$\n\\Delta = \\left| \\langle F m, y \\rangle - \\langle m, F^\\ast y \\rangle \\right|.\n$$\n所有量均为无量纲；输出必须是实值浮点数。\n\n测试套件：\n提供四个测试用例，通过改变离散化和边界设置来衡量不同配置下的不匹配值。每个测试用例由元组 $(N_x, T, \\Delta x, \\Delta t, c, \\text{boundary}, \\text{receivers})$ 定义：\n1. $(64, 120, 1.0, 0.5, 1.0, \\text{狄利克雷}, [16,48])$，使用主频 $f_p = 0.05$ 的Ricker子波。\n2. $(64, 120, 1.0, 0.5, 1.0, \\text{周期性}, [16,48])$，子波参数与用例1相同。\n3. $(16, 80, 1.0, 0.5, 1.0, \\text{狄利克雷}, [4,12])$，使用 $f_p = 0.08$。\n4. $(64, 100, 1.0, 0.9, 1.0, \\text{狄利克雷}, [20,44])$，使用 $f_p = 0.06$。\n\n为保证可复现性，对每个用例，使用每个用例唯一的固定随机种子生成长度为 $N_x$ 的向量 $m$ 和一个 $(T \\times R)$ 的数组 $y$。使用由下式定义的 Ricker子波 $s^t$\n$$\ns(t) = \\left(1 - 2 (\\pi f_p t)^2 \\right) \\exp\\left( - (\\pi f_p t)^2 \\right),\n$$\n在离散时间 $t = t^t = t \\, \\Delta t$（其中 $t = 0,1,\\dots,T-1$）处求值。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含四个不匹配值，按上述测试用例的顺序排列，格式为逗号分隔的列表并用方括号括起，例如“[v1,v2,v3,v4]”。每个 $v_i$ 必须是浮点数。\n\n你的实现必须是一个单一、完整、可运行的程序。不允许用户输入、文件操作和网络访问。", "solution": "该问题要求实现并验证一个一维声波方程传播算子的伴随算子。验证将通过点积测试进行，这是在最小二乘反演和偏移中断言伴随算子正确性的基本要求。该问题具有科学依据，定义明确，并为得到唯一的、可验证的解提供了所有必要信息。因此，该问题被认定为有效。\n\n问题的核心在于线性算子 $F$ 与其在指定内积下的伴随算子 $F^\\ast$ 之间的关系：\n$$\n\\langle F m, y \\rangle = \\langle m, F^\\ast y \\rangle\n$$\n在这里，$F$ 代表将模型 $m$ 映射到预测数据 $d$ 的整个操作序列，即 $d=Fm$。算子 $F^\\ast$ 将数据空间向量 $y$ 映射回模型空间。我们将构建 $F$ 和 $F^\\ast$，然后计算绝对差 $\\Delta = \\left| \\langle F m, y \\rangle - \\langle m, F^\\ast y \\rangle \\right|$ 来验证一致性。一个接近机器精度的 $\\Delta$ 值表明实现是正确的。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags, lil_matrix\n\ndef get_ricker_wavelet(T, dt, fp):\n    \"\"\"\n    Generates a Ricker wavelet.\n    \"\"\"\n    t_vals = np.arange(T, dtype=np.float64) * dt\n    arg_sq = (np.pi * fp * t_vals) ** 2\n    return (1.0 - 2.0 * arg_sq) * np.exp(-arg_sq)\n\ndef get_laplacian(Nx, dx, boundary='Dirichlet'):\n    \"\"\"\n    Constructs the 1D discrete Laplacian operator as a sparse matrix.\n    \"\"\"\n    diagonals = [np.ones(Nx - 1), -2.0 * np.ones(Nx), np.ones(Nx - 1)]\n    offsets = [-1, 0, 1]\n    # Use LIL format for efficient item assignment, then convert to CSR for mat-vec products\n    L = diags(diagonals, offsets, shape=(Nx, Nx), format='lil', dtype=np.float64)\n\n    if boundary == 'Periodic':\n        L[0, -1] = 1.0\n        L[-1, 0] = 1.0\n    \n    return L.asformat('csr') / (dx**2)\n\ndef forward_propagator(m, Nx, T, dx, dt, c, boundary, receivers, fp):\n    \"\"\"\n    Applies the forward operator F to a model m.\n    \"\"\"\n    # Setup operators and sources\n    s = get_ricker_wavelet(T, dt, fp)\n    L = get_laplacian(Nx, dx, boundary)\n    alpha = (c * dt / dx)**2\n    I = diags([np.ones(Nx)], [0], shape=(Nx, Nx), dtype=np.float64, format='csr')\n    A = (2.0 * I) + (alpha * L)\n    \n    # Initialize wavefields\n    u_prev = np.zeros(Nx, dtype=np.float64)\n    u_curr = np.zeros(Nx, dtype=np.float64)\n    \n    # Initialize data array\n    R = len(receivers)\n    d = np.zeros((T, R), dtype=np.float64)\n    \n    # Time-stepping loop\n    for t in range(T):\n        # Sample data at current time step\n        d[t, :] = u_curr[receivers]\n        \n        # Compute source injection\n        source_term = (dt**2 * s[t]) * m\n        \n        # Compute next wavefield\n        u_next = A @ u_curr - u_prev + source_term\n        \n        # Update wavefields\n        u_prev, u_curr = u_curr, u_next\n        \n    return d\n\ndef adjoint_propagator(y, Nx, T, dx, dt, c, boundary, receivers, fp):\n    \"\"\"\n    Applies the adjoint operator F* to a data-space vector y.\n    \"\"\"\n    # Setup operators and sources\n    s = get_ricker_wavelet(T, dt, fp)\n    L = get_laplacian(Nx, dx, boundary)\n    alpha = (c * dt / dx)**2\n    I = diags([np.ones(Nx)], [0], shape=(Nx, Nx), dtype=np.float64, format='csr')\n    A = (2.0 * I) + (alpha * L)\n    \n    # Initialize adjoint variables\n    grad_m = np.zeros(Nx, dtype=np.float64)\n    v_curr = np.zeros(Nx, dtype=np.float64)\n    v_next = np.zeros(Nx, dtype=np.float64)\n    \n    # Adjoint time-stepping loop (backward in time)\n    for t in range(T - 1, -1, -1):\n        # Inject adjoint source from data\n        adj_source = np.zeros(Nx, dtype=np.float64)\n        adj_source[receivers] = y[t, :]\n        \n        # Compute previous adjoint wavefield\n        v_prev = A @ v_curr - v_next + adj_source\n        \n        # Accumulate gradient w.r.t. m\n        grad_m += (dt**2 * s[t]) * v_curr\n        \n        # Update adjoint fields\n        v_next, v_curr = v_curr, v_prev\n        \n    return grad_m\n\ndef run_dot_product_test(case_params, seed):\n    \"\"\"\n    Runs the full dot-product test for a single case.\n    \"\"\"\n    Nx, T, dx, dt, c, boundary, receivers, fp = case_params\n    R = len(receivers)\n    \n    # Generate reproducible random vectors for m and y\n    rng = np.random.default_rng(seed)\n    m = rng.standard_normal(size=Nx, dtype=np.float64)\n    y = rng.standard_normal(size=(T, R), dtype=np.float64)\n    \n    # Forward operation: d = F(m)\n    d = forward_propagator(m, Nx, T, dx, dt, c, boundary, receivers, fp)\n\n    # Adjoint operation: g = F*(y)\n    g = adjoint_propagator(y, Nx, T, dx, dt, c, boundary, receivers, fp)\n\n    # Compute dot products\n    lhs = np.sum(d * y)\n    rhs = np.sum(m * g)\n    \n    # Return the mismatch\n    return np.abs(lhs - rhs)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (64, 120, 1.0, 0.5, 1.0, 'Dirichlet', [16, 48], 0.05),\n        (64, 120, 1.0, 0.5, 1.0, 'Periodic', [16, 48], 0.05),\n        (16, 80, 1.0, 0.5, 1.0, 'Dirichlet', [4, 12], 0.08),\n        (64, 100, 1.0, 0.9, 1.0, 'Dirichlet', [20, 44], 0.06),\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        mismatch = run_dot_product_test(case, seed=i)\n        results.append(mismatch)\n\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3606465"}, {"introduction": "在验证了算子的正确性之后，下一个关键步骤是理解给定观测数据究竟能够解析出模型的哪些特征。最小二乘法偏移问题的核心是求解正规方程，而正规算子（$A^H A$）的性质决定了反演问题的结构和可解性。本练习 [@problem_id:3606528] 引导你通过无矩阵（matrix-free）方法构建正规算子，并分析其数值秩如何受观测孔径和采样密度的影响，从而深入理解地震勘探所能捕获的信息内容。", "problem": "考虑一个在二维恒速介质中，单一角频率下的线性化声波散射模型，该模型采用单次散射（Born）近似。设恒定波速为 $c$（单位为 $\\mathrm{m/s}$），时间频率为 $f$（单位为 $\\mathrm{Hz}$），角频率为 $\\omega = 2\\pi f$（单位为 $\\mathrm{rad/s}$）。定义波数 $k = \\omega / c$（单位为 $\\mathrm{rad/m}$）。位于横向坐标 $x_s$ 和深度 $z=0$ 的一个点源以及位于横向坐标 $x_r$ 和深度 $z=0$ 的一个接收器，从位于固定深度 $z_m > 0$ 的反射率分布 $m(x)$ 采集频域数据。在二维自由空间格林函数的高频近似下，格林函数被建模为\n$$\nG(r) \\approx \\frac{e^{\\mathrm{i} k r}}{\\sqrt{r}},\n$$\n其中 $r$ 是以米为单位的欧几里得距离，$\\mathrm{i}$ 是虚数单位。对于单一角频率 $\\omega$，从反射率 $m(x)$ 到由 $(x_s, x_r)$ 索引的数据的线性化正演映射，由 Born 近似核定义的连续线性算子的离散求积给出：\n$$\nd(x_s, x_r) \\approx \\int m(x) \\, G\\!\\left(\\sqrt{(x - x_s)^2 + z_m^2}\\right) \\, G\\!\\left(\\sqrt{(x - x_r)^2 + z_m^2}\\right) \\, \\mathrm{d}x.\n$$\n在固定深度 $z_m$ 上，将反射率 $m(x)$ 在一个均匀横向网格 $\\{x_j\\}_{j=1}^{M}$ 上离散化，网格间距为 $\\Delta x$（单位为 $\\mathrm{m}$），形成一个向量 $\\mathbf{m} \\in \\mathbb{C}^{M}$。将采集系统离散化，设置 $N_s$ 个震源，坐标为 $\\{x_s^{(p)}\\}_{p=1}^{N_s}$，以及 $N_r$ 个接收器，坐标为 $\\{x_r^{(q)}\\}_{q=1}^{N_r}$。震源和接收器都位于一个长度等于孔径 $A$（单位为 $\\mathrm{m}$）、以原点为中心并均匀采样的地表线段上，是该线段的子集。将所有震源-接收器对堆叠成一个数据向量 $\\mathbf{d} \\in \\mathbb{C}^{N}$，其中 $N = N_s N_r$。离散正演算子 $A : \\mathbb{C}^{M} \\to \\mathbb{C}^{N}$ 通过应用以下求积法则定义\n$$\n\\mathbf{d}_{(p,q)} = \\Delta x \\sum_{j=1}^{M} \\mathbf{m}_j \\, G\\!\\left(\\sqrt{(x_j - x_s^{(p)})^2 + z_m^2}\\right) \\, G\\!\\left(\\sqrt{(x_j - x_r^{(q)})^2 + z_m^2}\\right),\n$$\n对所有 $p \\in \\{1,\\dots,N_s\\}$ 和 $q \\in \\{1,\\dots,N_r\\}$ 成立，其中索引 $(p,q)$ 表示堆叠数据向量中对应于震源 $p$ 和接收器 $q$ 的元素。伴随算子 $A^{H} : \\mathbb{C}^{N} \\to \\mathbb{C}^{M}$（在标准复欧几里得内积下的厄米转置）由以下恒等式隐式定义\n$$\n\\langle A \\mathbf{m}, \\mathbf{d} \\rangle = \\langle \\mathbf{m}, A^{H} \\mathbf{d} \\rangle,\n$$\n对所有 $\\mathbf{m} \\in \\mathbb{C}^{M}$ 和 $\\mathbf{d} \\in \\mathbb{C}^{N}$ 成立，其中 $\\langle \\cdot,\\cdot \\rangle$ 表示标准复内积。您必须使用上述核函数，将 $A$ 和 $A^{H}$ 实现为无矩阵的算子应用，而无需显式地构建 $A$ 的稠密矩阵表示。\n\n您的任务是：\n1. 通过将正规算子 $A^{H} A$ 应用于 $\\mathbb{C}^{M}$ 中的标准基向量 $\\{\\mathbf{e}_j\\}_{j=1}^{M}$，构建 $A^{H} A \\in \\mathbb{C}^{M \\times M}$ 的离散近似。也就是说，对于每个 $j$，通过连续的无矩阵应用 $A$ 和 $A^{H}$ 来计算 $A^{H} A \\mathbf{e}_j$，并将得到的向量作为 $A^{H} A$ 矩阵近似的列进行组装。在任何步骤中都不要显式地构建 $A$。\n2. 对于每个构建的 $A^{H} A$，计算其所有特征值，并将其数值秩估计为大于或等于最大特征值乘以相对阈值 $\\tau$ 的特征值的数量。具体来说，如果特征值为 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_M \\ge 0$，则将数值秩定义为满足 $\\lambda_j \\ge \\tau \\lambda_1$ 的索引 $j$ 的计数。使用容差 $\\tau = 10^{-3}$。\n3. 在保持角频率固定的情况下，研究该数值秩对采集采样和孔径的依赖关系。\n\n在所有测试用例中，使用以下固定的物理和离散化参数：\n- 波速 $c = 2000$ $\\mathrm{m/s}$。\n- 频率 $f = 10$ $\\mathrm{Hz}$，因此 $\\omega = 2\\pi f$ $\\mathrm{rad/s}$ 且 $k = \\omega / c$ $\\mathrm{rad/m}$。\n- 散射体深度 $z_m = 800$ $\\mathrm{m}$。\n- 反射率模型横向网格点数 $M = 25$，在一个从 $x_{\\min} = -800$ $\\mathrm{m}$ 到 $x_{\\max} = 800$ $\\mathrm{m}$ 的均匀网格上，因此 $\\Delta x = (x_{\\max} - x_{\\min})/(M-1)$ $\\mathrm{m}$。\n- 使用上面给出的高频格林函数，其中欧几里得距离 $r = \\sqrt{(x - x_{s/r})^2 + z_m^2}$（单位为 $\\mathrm{m}$）；角度以弧度为单位。\n\n将每个测试用例的采集采样定义为在以原点为中心的孔径 $A$ 上的均匀震源和接收器采样，即 $x_s^{(p)}$ 和 $x_r^{(q)}$ 在区间 $[-A/2, A/2]$（单位为 $\\mathrm{m}$）内均匀分布。使用以下测试用例套件，每个用例指定为一个三元组 $(N_s, N_r, A)$：\n- 用例 1：$(9, 9, 1000)$。\n- 用例 2：$(3, 3, 1000)$。\n- 用例 3：$(9, 9, 200)$。\n- 用例 4：$(17, 17, 1500)$。\n\n所有距离单位必须为 $\\mathrm{m}$，速度单位为 $\\mathrm{m/s}$，频率单位为 $\\mathrm{Hz}$，角度单位为弧度。\n\n程序要求：\n- 实现 $A$ 和 $A^{H}$ 作为无矩阵的例程，将核函数应用于向量，而无需显式构建 $A$。\n- 通过将 $A^{H} A$ 应用于标准基来组装 $A^{H} A$ 的离散近似。\n- 对于每个测试用例，计算组装好的 $A^{H} A$ 的特征值，使用相对阈值 $\\tau = 10^{-3}$ 确定数值秩，并以整数形式报告该秩。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个用例的数值秩，形式为一个用方括号括起来的逗号分隔列表（例如，$\"[r_1,r_2,r_3,r_4]\"$），其中每个 $r_i$ 都是一个整数。", "solution": "该问题要求分析与线性化声波散射模型相关的正规算子 $A^{H} A$。分析过程包括通过正演算子 $A$ 及其伴随算子 $A^{H}$ 的无矩阵应用来构建 $A^{H} A$ 矩阵，然后通过检查其特征值谱来确定该矩阵的数值秩。对几种采集几何重复此过程，以研究采样和孔径如何影响地震勘探所捕获的信息含量。\n\n首先，我们建立数学框架。物理系统在二维空间中针对单一角频率 $\\omega$ 进行建模。将地下反射率模型 $\\mathbf{m} \\in \\mathbb{C}^{M}$ 映射到测量的地震数据 $\\mathbf{d} \\in \\mathbb{C}^{N}$ 的正演过程由线性算子 $A$ 描述。数据空间维度为 $N = N_s N_r$，其中 $N_s$ 是震源数量，$N_r$ 是接收器数量。模型空间维度为 $M$，即反射率模型中的离散点数。\n\n离散正演算子 $A: \\mathbb{C}^{M} \\to \\mathbb{C}^{N}$ 由其对模型向量 $\\mathbf{m}$ 的作用定义。生成的数据向量 $\\mathbf{d}$ 中，对应于震源 $x_s^{(p)}$ 和接收器 $x_r^{(q)}$ 的元素由以下求积公式给出：\n$$\n\\mathbf{d}_{(p,q)} = \\Delta x \\sum_{j=1}^{M} \\mathbf{m}_j \\, G\\!\\left(\\sqrt{(x_j - x_s^{(p)})^2 + z_m^2}\\right) \\, G\\!\\left(\\sqrt{(x_j - x_r^{(q)})^2 + z_m^2}\\right)\n$$\n其中 $\\Delta x$ 是模型网格间距，$z_m$ 是反射层的深度，$G(r) = \\frac{e^{\\mathrm{i} k r}}{\\sqrt{r}}$ 是二维格林函数的高频近似，波数为 $k = \\omega / c$。为便于实现，可以方便地定义一个核\n$$\nK(j,p,q) = G\\!\\left(\\sqrt{(x_j - x_s^{(p)})^2 + z_m^2}\\right) \\, G\\!\\left(\\sqrt{(x_j - x_r^{(q)})^2 + z_m^2}\\right).\n$$\n于是正演操作可以简洁地写为 $\\mathbf{d}_{(p,q)} = \\Delta x \\sum_{j=1}^{M} K(j,p,q) \\mathbf{m}_j$。\n\n下一个关键步骤是推导伴随算子 $A^{H}: \\mathbb{C}^{N} \\to \\mathbb{C}^{M}$。对于所有 $\\mathbf{m}$ 和 $\\mathbf{d}$，伴随算子由性质 $\\langle A \\mathbf{m}, \\mathbf{d} \\rangle = \\langle \\mathbf{m}, A^{H} \\mathbf{d} \\rangle$ 定义，其中 $\\langle \\cdot, \\cdot \\rangle$ 是标准复欧几里得内积，例如 $\\langle \\mathbf{u}, \\mathbf{v} \\rangle = \\sum_i u_i \\overline{v_i}$。\n让我们写出左侧的内积：\n$$\n\\langle A \\mathbf{m}, \\mathbf{d} \\rangle = \\sum_{p=1}^{N_s} \\sum_{q=1}^{N_r} (A \\mathbf{m})_{(p,q)} \\, \\overline{\\mathbf{d}_{(p,q)}} = \\sum_{p,q} \\left( \\Delta x \\sum_{j=1}^{M} K(j,p,q) \\mathbf{m}_j \\right) \\overline{\\mathbf{d}_{(p,q)}}\n$$\n通过重新排列求和顺序，我们得到：\n$$\n\\langle A \\mathbf{m}, \\mathbf{d} \\rangle = \\sum_{j=1}^{M} \\mathbf{m}_j \\left( \\Delta x \\sum_{p,q} K(j,p,q) \\overline{\\mathbf{d}_{(p,q)}} \\right)\n$$\n将此与伴随算子定义的右侧 $\\langle \\mathbf{m}, A^H \\mathbf{d} \\rangle = \\sum_{j=1}^{M} \\mathbf{m}_j \\overline{(A^H \\mathbf{d})_j}$ 进行比较，我们可以识别出与 $\\overline{(A^H \\mathbf{d})_j}$ 对应的项。\n$$\n\\overline{(A^H \\mathbf{d})_j} = \\Delta x \\sum_{p,q} K(j,p,q) \\overline{\\mathbf{d}_{(p,q)}}\n$$\n对两边取复共轭，得出伴随算子的作用：\n$$\n(A^H \\mathbf{d})_j = \\Delta x \\sum_{p=1}^{N_s} \\sum_{q=1}^{N_r} \\overline{K(j,p,q)} \\mathbf{d}_{(p,q)}\n$$\n这个表达式定义了伴随算子的无矩阵实现，这在地震处理中对应于偏移操作。\n\n任务的核心是构建正规算子矩阵 $A^H A \\in \\mathbb{C}^{M \\times M}$。由于我们有用以应用 $A$ 和 $A^H$ 的无矩阵函数，我们可以逐列构建矩阵 $A^H A$，而无需构建（可能非常大的）矩阵 A。任何矩阵 $H$ 的第 $j$ 列由乘积 $H \\mathbf{e}_j$ 给出，其中 $\\mathbf{e}_j$ 是第 $j$ 个标准基向量（一个在第 $j$ 个位置为 1，其余位置为 0 的向量）。\n因此，$A^H A$ 的第 $j$ 列，记为 $(\\mathbf{A^H A})_j$，计算如下：\n$$\n(\\mathbf{A^H A})_j = A^H (A \\mathbf{e}_j)\n$$\n构建 $A^H A$ 的算法如下：\n1.  初始化一个 $M \\times M$ 的零矩阵 $H_{A^H A}$。\n2.  对于每个列索引 $j$（从 1 到 $M$）：\n    a.  创建基向量 $\\mathbf{e}_j \\in \\mathbb{C}^M$。\n    b.  使用无矩阵正演算子计算数据向量 $\\mathbf{d}_j = A \\mathbf{e}_j$。\n    c.  使用无矩阵伴随算子计算模型空间向量 $\\mathbf{c}_j = A^H \\mathbf{d}_j$。\n    d.  将此向量赋给 $H_{A^H A}$ 的第 $j$ 列：$H_{A^H A}[:, j] = \\mathbf{c}_j$。\n\n一旦矩阵 $H_{A^H A}$ 构建完成，我们就分析其性质。根据构造，$A^H A$ 矩阵是厄米矩阵，因此其特征值是实数。我们使用适用于厄米矩阵的数值特征求解器计算所有 $M$ 个特征值 $\\{\\lambda_j\\}_{j=1}^{M}$。设特征值按降序排列：$\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_M \\ge 0$。\n然后，通过计算相对于最大特征值而言是显著的特征值的数量来估计数值秩。使用给定的相对阈值 $\\tau = 10^{-3}$，数值秩是满足 $\\lambda_j \\ge \\tau \\lambda_1$ 的特征值 $\\lambda_j$ 的数量。这个秩代表了在给定采集几何下，模型空间中可以被稳健地解析的独立基函数的数量。\n\n对由参数 $(N_s, N_r, A)$ 指定的四个测试用例中的每一个重复这整个过程，其中 $A$ 在此表示采集孔径。在所有用例中均使用固定的参数：$c=2000 \\, \\mathrm{m/s}$，$f=10 \\, \\mathrm{Hz}$，$z_m=800 \\, \\mathrm{m}$，以及模型离散化（在 $[-800, 800] \\, \\mathrm{m}$ 上 $M=25$）。最终输出是这四个用例的整数数值秩列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational geophysics problem by analyzing the normal operator A^H A.\n    \"\"\"\n    # Define fixed physical and discretization parameters.\n    c = 2000.0  # Wave speed in m/s\n    f = 10.0    # Frequency in Hz\n    omega = 2 * np.pi * f  # Angular frequency in rad/s\n    k = omega / c  # Wavenumber in rad/m\n    zm = 800.0  # Scatterer depth in m\n    M = 25      # Number of lateral grid points for reflectivity model\n    x_min = -800.0\n    x_max = 800.0\n    x_vec = np.linspace(x_min, x_max, M)  # Model space grid\n    dx = (x_max - x_min) / (M - 1)  # Model grid spacing\n    tau = 1e-3  # Relative threshold for numerical rank\n\n    # Define the test cases (Ns, Nr, Aperture).\n    test_cases = [\n        (9, 9, 1000.0),   # Case 1\n        (3, 3, 1000.0),   # Case 2\n        (9, 9, 200.0),    # Case 3\n        (17, 17, 1500.0)  # Case 4\n    ]\n\n    results = []\n\n    # Helper for the high-frequency 2D Green's function\n    def green_function(r, k_val):\n        # Avoid division by zero if r is zero, though not expected in this geometry.\n        # Add a small epsilon to the denominator for stability.\n        return np.exp(1j * k_val * r) / np.sqrt(r + 1e-12)\n\n    for Ns, Nr, A_aperture in test_cases:\n        # Set up acquisition geometry for the current case.\n        xs_grid = np.linspace(-A_aperture / 2, A_aperture / 2, Ns)\n        xr_grid = np.linspace(-A_aperture / 2, A_aperture / 2, Nr)\n\n        # Define matrix-free forward operator A\n        def apply_A(m_vec):\n            d_matrix = np.zeros((Ns, Nr), dtype=np.complex128)\n            for p in range(Ns):\n                for q in range(Nr):\n                    xs = xs_grid[p]\n                    xr = xr_grid[q]\n                    # Vectorized computation over model grid\n                    rs_vec = np.sqrt((x_vec - xs)**2 + zm**2)\n                    rr_vec = np.sqrt((x_vec - xr)**2 + zm**2)\n                    \n                    kernel_vec = green_function(rs_vec, k) * green_function(rr_vec, k)\n                    d_matrix[p, q] = np.sum(kernel_vec * m_vec)\n            \n            return dx * d_matrix.flatten()\n\n        # Define matrix-free adjoint operator A^H\n        def apply_AH(d_flat):\n            d_matrix = d_flat.reshape((Ns, Nr))\n            m_adj = np.zeros(M, dtype=np.complex128)\n            \n            # Pre-compute meshgrid for source/receiver positions for vectorized calculation\n            xs_mat, xr_mat = np.meshgrid(xs_grid, xr_grid, indexing='ij')\n\n            for j in range(M):\n                xj = x_vec[j]\n                # Vectorized computation over source/receiver grid\n                rs_mat = np.sqrt((xj - xs_mat)**2 + zm**2)\n                rr_mat = np.sqrt((xj - xr_mat)**2 + zm**2)\n\n                kernel_mat = green_function(rs_mat, k) * green_function(rr_mat, k)\n                m_adj[j] = np.sum(np.conj(kernel_mat) * d_matrix)\n                \n            return dx * m_adj\n\n        # Construct the normal operator matrix A^H A\n        AHA_matrix = np.zeros((M, M), dtype=np.complex128)\n        for j in range(M):\n            e_j = np.zeros(M, dtype=np.complex128)\n            e_j[j] = 1.0\n            \n            # Apply A^H A to the j-th basis vector\n            col_j = apply_AH(apply_A(e_j))\n            AHA_matrix[:, j] = col_j\n\n        # Compute eigenvalues and numerical rank\n        # np.linalg.eigh is for Hermitian matrices and returns real eigenvalues.\n        eigenvalues = np.linalg.eigh(AHA_matrix)[0]\n        \n        # Sort eigenvalues in descending order\n        eigenvalues = np.sort(eigenvalues)[::-1]\n        \n        lambda_max = eigenvalues[0] if M > 0 else 0.0\n        \n        if lambda_max > 0:\n            numerical_rank = np.sum(eigenvalues >= tau * lambda_max)\n        else:\n            numerical_rank = 0\n            \n        results.append(int(numerical_rank))\n\n    # Print results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3606528"}, {"introduction": "标准的最小二乘法偏移假设噪声服从高斯分布，但这在现实世界中往往不成立，异常值或相干噪声会严重影响成像质量。为了应对这一挑战，我们可以使用更稳健的统计模型，例如学生t分布，它对具有长尾效应的噪声不那么敏感。本练习 [@problem_id:3606487] 将指导你实现一种基于学生t损失函数和迭代重加权最小二乘法（IRLS）的稳健偏移算法，从而让你掌握处理非$L_2$范数问题并提高成像质量的实用高级技术。", "problem": "考虑玻恩近似下的线性化声学成像设置，其中反射率模型 $m \\in \\mathbb{R}^n$ 通过一个已知的线性算子 $A \\in \\mathbb{R}^{p \\times n}$ 映射到观测数据 $d \\in \\mathbb{R}^p$，其关系为 $d = A m + \\varepsilon$。在最小二乘偏移中，我们寻求一个估计值 $\\hat{m}$，它能在解释数据 $d$ 的同时控制模型的粗糙度。在重尾噪声条件下，用稳健的学生t分布损失函数替代 $L_2$ 范数拟合差可以提高稳定性。带有 Tikhonov 正则化参数 $\\lambda > 0$ 的稳健目标函数为\n$$\nJ(m) = \\sum_{i=1}^p \\frac{\\nu+1}{2}\\,\\log\\!\\left(1 + \\frac{r_i(m)^2}{\\nu\\,\\sigma^2}\\right) + \\frac{\\lambda}{2}\\,\\|m\\|_2^2,\n$$\n其中 $r(m) = A m - d$ 是残差，$\\nu > 0$ 是自由度参数，$\\sigma > 0$ 是尺度参数。迭代重加权最小二乘（IRLS）方法源于得分函数 $\\psi(r_i) = \\partial J/\\partial r_i$，并产生对角权重 $w_i = \\psi(r_i)/r_i$。这些权重随后被用于求解一系列加权正规方程。\n\n从玻恩近似下的线性反问题以及重尾噪声下的最大似然估计的基本定义和原理出发，推导针对学生t分布损失的IRLS更新规则，并实现它以执行稳健的最小二乘偏移。使用一个物理上合理的合成算子 $A$，它被构造为一个带有离散 Ricker 子波核的 Toeplitz 卷积矩阵，以模拟带限的反偏移。具体要求如下：\n\n- 设模型大小为 $n = 64$，Ricker 子波长度为 $\\ell = 15$。使用以下公式定义离散 Ricker 核 $h \\in \\mathbb{R}^\\ell$\n$$\nh_k = \\Big(1 - 2\\,(\\pi\\,f_0\\,t_k)^2\\Big)\\,\\exp\\!\\Big(-(\\pi\\,f_0\\,t_k)^2\\Big),\n$$\n对于 $k = 0, 1, \\dots, \\ell-1$，其中 $t_k = (k - (\\ell-1)/2)\\,\\Delta t$，且 $\\Delta t = 1$，中心频率 $f_0 = 0.25$。构造 $A$ 使得当索引 $i-j$ 满足 $0 \\le i-j \\le \\ell-1$ 时，$(A m)_i = \\sum_{j=0}^{n-1} h_{i-j}\\,m_j$；否则 $(A m)_i = 0$。由此得到的数据长度为 $p = n + \\ell - 1$。\n\n- 生成一个稀疏的真实反射率模型 $m_{\\text{true}} \\in \\mathbb{R}^n$，包含 $k = 8$ 个非零尖峰，其位置是无放回随机选择的，振幅在 $[-1,1]$ 内均匀分布。为确保可复现性，每个测试案例使用指定的伪随机数种子。\n\n- 将相干多次波污染模型 $m_{\\text{mult}}$ 定义为 $m_{\\text{true}}$ 的一个移位平滑版本。设移位量为 $s = 5$。通过将 $m_{\\text{true}}$ 循环移位 $s$ 个采样点，并与一个长度为3的盒式核 $b = [1/3, 1/3, 1/3]$ 进行卷积来构造 $m_{\\text{mult}}$。那么，受污染的数据为 $d = A m_{\\text{true}} + \\gamma\\,A m_{\\text{mult}} + \\eta$，其中 $\\gamma \\ge 0$ 控制相干污染，$\\eta$ 是随机噪声。\n\n- 通过 $\\eta_i \\sim \\sigma\\,\\mathrm{Student}\\text{-}t(\\nu)$ 对重尾随机噪声进行建模，其中 $i=1,\\dots,p$ 独立同分布，使用由 $\\sigma$ 缩放的标准学生t分布。在一个边缘案例中，向噪声中添加 $q$ 个振幅为 $A_{\\text{out}}$ 的随机离群尖峰。\n\n- 推导学生t分布损失的IRLS权重，并实现迭代过程，在第 $k$ 次迭代中求解\n$$\n\\big(A^\\top W^{(k)} A + \\lambda I\\big)\\,m^{(k+1)} = A^\\top W^{(k)} d,\n$$\n其中 $W^{(k)} = \\mathrm{diag}\\big(w_i^{(k)}\\big)$，而 $w_i^{(k)}$ 是根据当前残差 $r^{(k)} = A m^{(k)} - d$ 计算得出的。以 $m^{(0)} = 0$ 初始化，并在目标函数的相对变化量 $\\Delta J / J$ 低于 $\\epsilon$ 或迭代次数达到 $K_{\\max}$ 时停止。\n\n- 在不同的噪声机制和污染条件下，量化收敛性和偏差。对每个测试案例，报告：\n    1. 达到停止条件时所用的 IRLS 迭代次数 $k^\\star$。\n    2. 相对模型误差 $e_{\\text{rel}} = \\|m^{(k^\\star)} - m_{\\text{true}}\\|_2 / \\|m_{\\text{true}}\\|_2$。\n    3. 相干多次波偏差 $b_{\\text{mult}}$，定义为模型误差在 $m_{\\text{mult}}$ 上的标量投影，\n    $$\n    b_{\\text{mult}} = \\frac{\\langle m^{(k^\\star)} - m_{\\text{true}},\\, m_{\\text{mult}} \\rangle}{\\|m_{\\text{mult}}\\|_2^2}.\n    $$\n\n用单一程序实现上述过程，评估以下测试套件，每个测试由 $(\\nu, \\sigma, \\gamma, \\text{seed}, q, A_{\\text{out}})$ 指定：\n\n- 测试 1 (重尾噪声，理想路径): $(\\nu = 3,\\, \\sigma = 0.1,\\, \\gamma = 0.0,\\, \\text{seed} = 123,\\, q = 0,\\, A_{\\text{out}} = 0.0)$。\n- 测试 2 (带离群点的极端重尾噪声): $(\\nu = 2,\\, \\sigma = 0.15,\\, \\gamma = 0.0,\\, \\text{seed} = 456,\\, q = 3,\\, A_{\\text{out}} = 5.0)$。\n- 测试 3 (相干多次波污染): $(\\nu = 3,\\, \\sigma = 0.05,\\, \\gamma = 0.6,\\, \\text{seed} = 789,\\, q = 0,\\, A_{\\text{out}} = 0.0)$。\n- 测试 4 (近高斯基线): $(\\nu = 100,\\, \\sigma = 0.1,\\, \\gamma = 0.0,\\, \\text{seed} = 101112,\\, q = 0,\\, A_{\\text{out}} = 0.0)$。\n\n使用固定的正则化参数 $\\lambda = 10^{-3}$、容差 $\\epsilon = 10^{-6}$ 和最大迭代次数 $K_{\\max} = 50$。所有量均为无量纲。您的程序应生成单行输出，其中包含聚合为一个由方括号括起来的逗号分隔列表的结果，顺序如下\n$$\n[\\;k^\\star_1,\\, e_{\\text{rel},1},\\, b_{\\text{mult},1},\\, k^\\star_2,\\, e_{\\text{rel},2},\\, b_{\\text{mult},2},\\, k^\\star_3,\\, e_{\\text{rel},3},\\, b_{\\text{mult},3},\\, k^\\star_4,\\, e_{\\text{rel},4},\\, b_{\\text{mult},4}\\;].\n$$", "solution": "该问题要求使用迭代重加权最小二乘（IRLS）方法，推导并实现一种稳健的最小二乘偏移算法。其稳健性是通过用学生t分布对数似然函数替代标准的二次（$L_2$）数据拟合差来实现的，该函数对离群值和重尾噪声不那么敏感。该方法应用于一个基于玻恩近似的合成一维地震成像问题。\n\n正演模型由线性系统 $d = A m + \\varepsilon$ 给出，其中 $m \\in \\mathbb{R}^n$ 是地下反射率模型，$d \\in \\mathbb{R}^p$ 是观测数据，$A \\in \\mathbb{R}^{p \\times n}$ 是正演算子（反偏移），$\\varepsilon$ 表示噪声。我们旨在通过最小化以下正则化目标函数来寻找真实模型 $m_{\\text{true}}$ 的一个估计 $\\hat{m}$：\n$$\nJ(m) = \\sum_{i=1}^p \\frac{\\nu+1}{2}\\,\\log\\!\\left(1 + \\frac{r_i(m)^2}{\\nu\\,\\sigma^2}\\right) + \\frac{\\lambda}{2}\\,\\|m\\|_2^2\n$$\n此处，$r(m) = A m - d$ 是残差向量，$\\lambda > 0$ 是控制模型平滑度的 Tikhonov 正则化参数，$\\nu > 0$ 是学生t分布的自由度，$\\sigma > 0$ 是一个尺度参数。第一项与数据在噪声 $\\varepsilon$ 服从缩放学生t分布的假设下的负对数似然成正比，第二项是正则化惩罚项。\n\n$J(m)$ 的最小值出现在其关于 $m$ 的梯度为零的地方。梯度为：\n$$\n\\nabla_m J(m) = \\nabla_m \\left( \\sum_{i=1}^p \\frac{\\nu+1}{2}\\,\\log\\!\\left(1 + \\frac{( (Am)_i - d_i )^2}{\\nu\\,\\sigma^2}\\right) \\right) + \\nabla_m \\left( \\frac{\\lambda}{2}\\,m^\\top m \\right)\n$$\n使用链式法则，和式中第 $i$ 项对模型参数 $m_j$ 的导数为：\n$$\n\\frac{\\partial}{\\partial m_j} \\left( \\dots \\right) = \\frac{\\partial J}{\\partial r_i} \\frac{\\partial r_i}{\\partial m_j}\n$$\n首先，我们求对残差 $r_i$ 的导数：\n$$\n\\psi(r_i) = \\frac{\\partial J}{\\partial r_i} = \\frac{\\nu+1}{2} \\frac{1}{1 + \\frac{r_i^2}{\\nu\\,\\sigma^2}} \\left( \\frac{2r_i}{\\nu\\,\\sigma^2} \\right) = \\frac{(\\nu+1)r_i}{\\nu\\,\\sigma^2 + r_i^2}\n$$\n这个函数 $\\psi(r_i)$ 被称为得分函数。导数 $\\partial r_i / \\partial m_j$ 就是算子矩阵的元素 $A_{ij}$。组合梯度向量：\n$$\n\\nabla_m J(m) = A^\\top \\psi(r(m)) + \\lambda m\n$$\n其中 $\\psi(r(m))$ 是分量为 $\\psi(r_i(m))$ 的向量。令梯度为零，得到最小值的必要条件：\n$$\nA^\\top \\psi(r(m)) + \\lambda m = 0\n$$\n这是一个关于 $m$ 的非线性方程组，因为得分函数 $\\psi$ 非线性地依赖于残差 $r$，而残差 $r$ 又依赖于 $m$。\n\nIRLS算法提供了一个求解该系统的迭代过程。它基于一个观察：得分函数可以写成 $\\psi(r_i) = w_i r_i$ 的形式，其中 $w_i$ 是一个权重。根据我们推导出的 $\\psi(r_i)$ 表达式：\n$$\nw_i = \\frac{\\psi(r_i)}{r_i} = \\frac{\\nu+1}{\\nu\\,\\sigma^2 + r_i^2}\n$$\n这些权重依赖于残差。IRLS方法通过求解一系列加权最小二乘问题来逼近解。在每次迭代 $k$ 中，使用当前模型估计 $m^{(k)}$ 的残差 $r^{(k)} = A m^{(k)} - d$ 来计算权重 $w_i^{(k)}$。然后，这些权重被固定，用于将模型更新为 $m^{(k+1)}$。将 $\\psi(r) = W r$ 代入梯度为零的条件中：\n$$\nA^\\top W(r) (Am - d) + \\lambda m = 0 \\implies (A^\\top W(r) A + \\lambda I) m = A^\\top W(r) d\n$$\n因此，IRLS的更新步骤被表述为使用第 $k$ 次迭代的权重来求解第 $k+1$ 次迭代的模型：\n$$\n\\big(A^\\top W^{(k)} A + \\lambda I\\big)\\,m^{(k+1)} = A^\\top W^{(k)} d\n$$\n其中 $W^{(k)} = \\mathrm{diag}(w_1^{(k)}, \\dots, w_p^{(k)})$。这是一个关于 $m^{(k+1)}$ 的线性系统，可以使用标准方法求解。该过程从一个初始猜测（通常是 $m^{(0)} = 0$）开始，并迭代直到满足收敛准则。\n\n实现计划如下：\n1.  **合成模型设置**：对每个测试案例，使用给定的种子建立一个可复现的随机环境。\n    - 正演算子 $A$ 被构造为一个 Toeplitz 矩阵，表示与长度为 $\\ell=15$、中心频率为 $f_0=0.25$ 的离散 Ricker 子波进行卷积。这模拟了带限地震源的作用。模型大小为 $n=64$，产生的数据长度为 $p = n+\\ell-1 = 78$。\n    - 生成一个稀疏的真实模型 $m_{\\text{true}}$，其中包含 $k=8$ 个随机放置、随机振幅的尖峰。\n    - 通过对 $m_{\\text{true}}$ 进行循环移位和平滑，创建一个相干噪声模型 $m_{\\text{mult}}$。\n    - 最终数据 $d$ 合成为 $d = A m_{\\text{true}} + \\gamma\\,A m_{\\text{mult}} + \\eta$，其中 $\\eta$ 是从具有参数 $\\nu$ 和 $\\sigma$ 的缩放学生t分布中抽取的噪声，可能包含大幅度离群值。\n\n2.  **IRLS迭代**：算法以 $m^{(0)} = 0$ 初始化。循环最多进行 $K_{\\max} = 50$ 次迭代：\n    - 在每次迭代 $k$ 中，计算残差 $r^{(k)} = A m^{(k)} - d$。\n    - 计算目标函数值 $J(m^{(k)})$。如果相对变化 $|J(m^{(k)}) - J(m^{(k-1)})| / |J(m^{(k)})|$ 低于容差 $\\epsilon = 10^{-6}$，则宣布收敛。\n    - 计算对角权重 $w_i^{(k)} = (\\nu+1) / (\\nu\\sigma^2 + (r_i^{(k)})^2)$。\n    - 构造并求解加权正规方程 $(A^\\top W^{(k)} A + \\lambda I) m^{(k+1)} = A^\\top W^{(k)} d$ 以获得下一个模型估计 $m^{(k+1)}$，正则化参数为 $\\lambda=10^{-3}$。\n\n3.  **性能评估**：在IRLS算法收敛或达到最大迭代次数后，使用三个指标评估最终估计模型 $\\hat{m} = m^{(k^\\star)}$ 的质量：\n    - 迭代次数 $k^\\star$。\n    - 相对模型误差 $e_{\\text{rel}} = \\|\\hat{m} - m_{\\text{true}}\\|_2 / \\|m_{\\text{true}}\\|_2$。\n    - 相干多次波偏差 $b_{\\text{mult}} = \\langle \\hat{m} - m_{\\text{true}}, m_{\\text{mult}} \\rangle / \\|m_{\\text{mult}}\\|_2^2$，它量化了模型误差在相干噪声结构上的投影。\n\n这一综合过程允许在各种噪声条件下对稳健偏移算法进行定量评估，包括重尾噪声、离散离群值和相干干扰。这些测试案例旨在探索这些不同的机制，从简单的重尾情况到包含极端离群值、相干伪影以及用于比较的近高斯基线（大的 $\\nu$）的场景。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import toeplitz\n\ndef run_irls_test(nu, sigma, gamma, seed, q, A_out):\n    \"\"\"\n    Performs a robust least-squares migration using IRLS for a single test case.\n    \"\"\"\n    # Fixed parameters\n    n = 64  # Model size\n    l = 15  # Ricker wavelet length\n    p = n + l - 1  # Data size\n    f0 = 0.25  # Ricker wavelet central frequency\n    dt = 1.0  # Time sampling interval\n    k_spikes = 8  # Number of spikes in true model\n    s_shift = 5  # Shift for coherent multiple model\n    lambda_reg = 1e-3  # Tikhonov regularization parameter\n    epsilon = 1e-6  # Convergence tolerance\n    K_max = 50  # Maximum number of iterations\n\n    # Set seed for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # 1. Generate operators and models\n    \n    # Ricker wavelet kernel h\n    t = (np.arange(l) - (l - 1) / 2.0) * dt\n    arg_sq = (np.pi * f0 * t)**2\n    h = (1.0 - 2.0 * arg_sq) * np.exp(-arg_sq)\n\n    # Forward operator A (convolution matrix)\n    first_col = np.zeros(p)\n    first_col[:l] = h\n    first_row = np.zeros(n)\n    first_row[0] = h[0]\n    A = toeplitz(first_col, first_row)\n    A_T = A.T\n\n    # Ground truth model m_true\n    m_true = np.zeros(n)\n    spike_pos = rng.choice(n, k_spikes, replace=False)\n    spike_amps = rng.uniform(-1.0, 1.0, k_spikes)\n    m_true[spike_pos] = spike_amps\n\n    # Coherent multiple model m_mult\n    boxcar_kernel = np.array([1/3.0, 1/3.0, 1/3.0])\n    m_true_shifted = np.roll(m_true, s_shift)\n    m_mult = np.convolve(m_true_shifted, boxcar_kernel, mode='same')\n\n    # 2. Generate data d\n    \n    # Noise-free data component\n    d_clean = A @ m_true\n    if gamma > 0:\n        d_clean += gamma * (A @ m_mult)\n\n    # Heavy-tailed noise eta\n    eta = sigma * rng.standard_t(nu, size=p)\n    \n    # Add outliers if specified\n    if q > 0:\n        outlier_pos = rng.choice(p, q, replace=False)\n        eta[outlier_pos] += A_out\n\n    d = d_clean + eta\n\n    # 3. IRLS Loop\n    \n    m_k = np.zeros(n)\n    j_prev = np.inf\n    k_star = K_max\n\n    for k_iter in range(1, K_max + 1):\n        # Calculate residuals and objective function\n        r_k = A @ m_k - d\n        \n        # Student-t log-likelihood term\n        log_term = np.sum(np.log(1 + r_k**2 / (nu * sigma**2)))\n        # Full objective function\n        j_k = 0.5 * (nu + 1) * log_term + 0.5 * lambda_reg * np.dot(m_k, m_k)\n\n        # Check for convergence\n        if k_iter > 1:\n            # Using abs(j_k) in denominator as J is non-negative\n            if abs(j_k) > 1e-9 and abs(j_k - j_prev) / abs(j_k)  epsilon:\n                k_star = k_iter - 1\n                break\n        j_prev = j_k\n\n        # Calculate IRLS weights\n        w_k = (nu + 1) / (nu * sigma**2 + r_k**2)\n\n        # Solve the weighted normal equations for m_k+1\n        # (A.T @ W @ A + lambda*I) m = A.T @ W @ d\n        # W is diagonal, so W@A can be done by row-wise multiplication\n        # and A.T@W by column-wise multiplication before transpose.\n        # Let's use broadcasting: w_k[:, None] * A\n        \n        LHS = A_T @ (w_k[:, None] * A) + lambda_reg * np.eye(n)\n        RHS = A_T @ (w_k * d)\n\n        try:\n            m_k_plus_1 = np.linalg.solve(LHS, RHS)\n        except np.linalg.LinAlgError:\n            # If solver fails, stop and report failure with K_max\n            m_k = np.full_like(m_k, np.nan) # Mark as failure\n            break\n\n        m_k = m_k_plus_1\n    \n    m_final = m_k\n\n    # 4. Calculate output metrics\n    \n    # Relative model error\n    norm_m_true = np.linalg.norm(m_true)\n    if norm_m_true > 1e-9:\n        e_rel = np.linalg.norm(m_final - m_true) / norm_m_true\n    else:\n        e_rel = np.linalg.norm(m_final)\n\n    # Coherent multiple bias\n    model_error = m_final - m_true\n    norm_sq_m_mult = np.dot(m_mult, m_mult)\n    if norm_sq_m_mult > 1e-9:\n        b_mult = np.dot(model_error, m_mult) / norm_sq_m_mult\n    else:\n        b_mult = 0.0\n\n    return k_star, e_rel, b_mult\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases: (nu, sigma, gamma, seed, q, A_out)\n    test_cases = [\n        (3.0, 0.1, 0.0, 123, 0, 0.0),      # Test 1\n        (2.0, 0.15, 0.0, 456, 3, 5.0),     # Test 2\n        (3.0, 0.05, 0.6, 789, 0, 0.0),     # Test 3\n        (100.0, 0.1, 0.0, 101112, 0, 0.0), # Test 4\n    ]\n\n    results = []\n    for params in test_cases:\n        nu, sigma, gamma, seed, q, A_out = params\n        k_star, e_rel, b_mult = run_irls_test(nu, sigma, gamma, seed, q, A_out)\n        results.extend([k_star, e_rel, b_mult])\n\n    # Format output as a single comma-separated list in brackets\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "3606487"}]}