{"hands_on_practices": [{"introduction": "快速多极方法 (FMM) 的准确性关键取决于多极展开的截断阶数 $p$。本练习将通过一个基础的验证测试，来巩固您对这一核心参数的理解。您将构建一个已知多极矩的合成场，并验证您的代码是否能在截断阶数 $p$ 设置正确时，精确地重构该场，从而确保算法核心的正确性。[@problem_id:3591359]", "problem": "设计并实现一个诊断程序，用于在计算地球物理学背景下，验证三维 Laplace 势的 Fast Multipole Method (FMM) 中的截断阶数选择。该程序必须为合成的、轴对称的质量分布重建精确的远场势，这些分布的非零多极子含量通过一组有限的球多极矩先验已知（即，只有有限多个球谐函数阶数非零）。您必须利用此属性来确定在严格的数值公差内精确再现目标场所需的最小截断阶数 $p$。\n\n从以下基本基础开始：\n- 在一个无源区域中，标量引力势 $V(\\mathbf{r})$ 满足 Laplace’s equation $\\nabla^{2} V = 0$。\n- 三维 Laplace operator 的 Green’s function 是 $G(\\mathbf{r},\\mathbf{r}') = \\|\\mathbf{r}-\\mathbf{r}'\\|^{-1}$。\n- 通过变量分离法，有界源区域之外的 $r = \\|\\mathbf{r}\\|$ 的一般外部解可以表示为一个关于球谐函数 $Y_{\\ell m}(\\theta,\\phi)$ 的级数，其中 $\\ell \\in \\{0,1,2,\\dots\\}$ 且 $m \\in \\{-\\ell,\\dots,\\ell\\}$。球谐函数在单位球面上构成一个完备的正交基。\n\n您的任务是：\n1. 通过仅为阶数 $\\ell \\leq L$ 且严格 $m=0$ 的情况指定非零球多极矩，来构造合成的、轴对称的“精确场”。这定义了一个有限带宽的多极场，使得精确的外部势完全由这些有限的矩确定。对于轴对称情况，球谐函数简化为 $Y_{\\ell 0}(\\theta)$，其为实值。\n2. 对于每个合成场，在一组预设的源区域外的观测点上计算精确势。\n3. 独立地计算一个仅包含阶数 $0 \\leq \\ell \\leq p$ 的截断多极重构，并确定使得所有观测点上的最大相对误差低于指定公差的最小整数 $p$。\n4. 对于每个测试用例，报告满足精度要求的最小 $p$。\n\n精度和单位：\n- 将所有量视为无量纲。\n- 所有角度必须以弧度为单位解释。\n- 使用相对误差容限 $\\varepsilon = 10^{-12}$，定义如下：如果 $V_{\\text{exact}}(\\mathbf{r}_{i})$ 是观测点 $i$ 处的精确势，而 $V_{p}(\\mathbf{r}_{i})$ 是截断重构，定义\n$$\n\\mathcal{E}(p) \\equiv \\frac{\\max_{i} \\left| V_{p}(\\mathbf{r}_{i}) - V_{\\text{exact}}(\\mathbf{r}_{i}) \\right|}{\\max_{i} \\left| V_{\\text{exact}}(\\mathbf{r}_{i}) \\right|}.\n$$\n最小 $p$ 是满足 $\\mathcal{E}(p) \\le \\varepsilon$ 的最小非负整数。\n\n实现约束：\n- 使用正交归一球谐函数约定（Condon–Shortley 相位）和标准 Legendre polynomials $P_{\\ell}(\\cos \\theta)$。对于轴对称情况 $m=0$，您可以使用 $Y_{\\ell 0}(\\theta)$ 与 $P_{\\ell}(\\cos \\theta)$ 成比例的性质。\n- 从指定的多极矩有限集合构造精确势。截断重构必须只包含阶数最高为 $p$ 的项。\n- 在精确重构和截断重构中一致地使用相同的归一化，使得当 $p \\ge L$ 时，等式成立是场带宽限制在 $\\ell \\le L$ 的直接结果。\n\n测试套件：\n- 观测点（球坐标 $(r,\\theta,\\phi)$，角度单位为弧度）：\n  - 点 1：$(r,\\theta,\\phi) = (5.0, 0.7, 0.1)$。\n  - 点 2：$(r,\\theta,\\phi) = (4.2, 1.1, 1.2)$。\n  - 点 3：$(r,\\theta,\\phi) = (10.0, 2.2, 2.4)$。\n  - 点 4：$(r,\\theta,\\phi) = (3.3, 0.5, 2.0)$。\n- 合成矩集（轴对称，仅 $m=0$；所有未指定的矩均为零）：\n  - 情况 A（纯单极子）：阶数 $L=0$ 的非零矩，振幅为 $Q_{00} = 2.0$。\n  - 情况 B（纯偶极子）：阶数 $L=1$ 的非零矩，振幅为 $Q_{10} = -0.75$。\n  - 情况 C（纯四极子）：阶数 $L=2$ 的非零矩，振幅为 $Q_{20} = 0.8$。\n\n计算内容：\n- 对于每种情况，仅使用指定到阶数 $L$ 的非零矩，计算观测点上的精确势。\n- 对于 $p = 0,1,2,\\dots,6$，计算截断重构和相应的 $\\mathcal{E}(p)$。\n- 确定使 $\\mathcal{E}(p) \\le 10^{-12}$ 的最小 $p$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个最小截断阶数，形式为用方括号括起来的逗号分隔列表，顺序为 [情况 A, 情况 B, 情况 C]。例如，如果最小阶数是 $p=0$，$p=1$ 和 $p=2$，则输出必须是 \"[0,1,2]\"。", "solution": "该问题要求实现一个诊断程序，以确定多极展开所需的最小截断阶数 $p$，从而准确表示一个合成的、轴对称的引力势。已知这些势场是带宽受限的，这意味着它们的非零多极子含量仅存在于某个最大球谐函数阶数 $L$ 以下。这个验证练习在像 Fast Multipole Method (FMM) 这样的计算方法中是基础性的，在这些方法中，控制截断误差对于准确性和效率至关重要。\n\n该问题的理论基础是在无源区域中三维 Laplace’s equation $\\nabla^2 V = 0$ 的解。由有界质量分布产生的势 $V$ 在外部区域可以用球坐标 $(\\mathbf{r}) = (r, \\theta, \\phi)$ 中的多极展开表示。该展开式形式如下：\n$$\nV(r, \\theta, \\phi) = \\sum_{\\ell=0}^{\\infty} \\sum_{m=-\\ell}^{\\ell} M_{\\ell m} \\frac{Y_{\\ell m}(\\theta, \\phi)}{r^{\\ell+1}}\n$$\n其中 $M_{\\ell m}$ 是源分布的多极矩，而 $Y_{\\ell m}(\\theta, \\phi)$ 是使用 Condon–Shortley 相位定义的正交归一球谐函数。所有量都视为无量纲。\n\n问题指定了轴对称场，这意味着势与方位角 $\\phi$无关。这在只有纬向矩（$m=0$）非零时发生。展开式简化为：\n$$\nV(r, \\theta) = \\sum_{\\ell=0}^{\\infty} M_{\\ell 0} \\frac{Y_{\\ell 0}(\\theta, \\phi)}{r^{\\ell+1}}\n$$\n纬向球谐函数 $Y_{\\ell 0}$ 是实值的，并且与 $\\ell$ 阶的 Legendre polynomial $P_{\\ell}(x)$ 相关，其公式为：\n$$\nY_{\\ell 0}(\\theta, \\phi) = \\sqrt{\\frac{2\\ell+1}{4\\pi}} P_{\\ell}(\\cos\\theta)\n$$\n该问题通过提供一组有限的“矩振幅”（表示为 $Q_{\\ell 0}$）来定义合成势场。我们将这些振幅解释为上述展开式中的多极矩 $M_{\\ell 0}$。因此，对于给定的矩集 $Q_{\\ell 0}$，势为：\n$$\nV(r, \\theta) = \\sum_{\\ell=0}^{\\infty} Q_{\\ell 0} \\frac{1}{r^{\\ell+1}} \\sqrt{\\frac{2\\ell+1}{4\\pi}} P_{\\ell}(\\cos\\theta)\n$$\n\n问题的核心在于“精确”场与其“截断重构”之间的区别。合成场是带宽受限的，意味着存在一个最大阶数 $L$，使得对于所有 $\\ell > L$，$Q_{\\ell 0} = 0$。在给定的测试用例中，每个场都由阶数为 $L$ 的单个非零矩生成。因此，精确势 $V_{\\text{exact}}$ 是一个有限和：\n$$\nV_{\\text{exact}}(r, \\theta) = \\sum_{\\ell=0}^{L} Q_{\\ell 0} \\frac{1}{r^{\\ell+1}} \\sqrt{\\frac{2\\ell+1}{4\\pi}} P_{\\ell}(\\cos\\theta)\n$$\n相比之下，截断重构 $V_p$ 是通过对同一级数求和来计算的，但仅求和到指定的截断阶数 $p$：\n$$\nV_{p}(r, \\theta) = \\sum_{\\ell=0}^{p} Q_{\\ell 0} \\frac{1}{r^{\\ell+1}} \\sqrt{\\frac{2\\ell+1}{4\\pi}} P_{\\ell}(\\cos\\theta)\n$$\n任务是找到满足精度标准 $\\mathcal{E}(p) \\le \\varepsilon$ 的最小非负整数 $p$，其中 $\\varepsilon=10^{-12}$，相对误差 $\\mathcal{E}(p)$ 定义为：\n$$\n\\mathcal{E}(p) \\equiv \\frac{\\max_{i} \\left| V_{p}(\\mathbf{r}_{i}) - V_{\\text{exact}}(\\mathbf{r}_{i}) \\right|}{\\max_{i} \\left| V_{\\text{exact}}(\\mathbf{r}_{i}) \\right|}\n$$\n截断势与精确势之差为：\n$$\nV_{p}(r, \\theta) - V_{\\text{exact}}(r, \\theta) = \\left( \\sum_{\\ell=0}^{p} - \\sum_{\\ell=0}^{L} \\right) Q_{\\ell 0} \\frac{Y_{\\ell 0}(\\theta)}{r^{\\ell+1}}\n$$\n如果截断阶数 $p$ 大于或等于场的最大阶数 $L$（即 $p \\ge L$），则两个和是相同的，因为所有 $\\ell > L$ 的矩 $Q_{\\ell 0}$ 都为零。在这种情况下，$V_p = V_{\\text{exact}}$，误差 $\\mathcal{E}(p)$ 将变为零（在机器精度范围内）。\n如果 $p  L$，则差值为对缺失项的求和：\n$$\nV_{p}(r, \\theta) - V_{\\text{exact}}(r, \\theta) = - \\sum_{\\ell=p+1}^{L} Q_{\\ell 0} \\frac{Y_{\\ell 0}(\\theta)}{r^{\\ell+1}}\n$$\n对于所提供的具体测试用例，其中只有一个矩 $Q_{L0}$ 非零，对于任何 $p  L$，这个和简化为一个单一的项。因此，只要 $p  L$，误差将非零。只有当 $p \\ge L$ 时，误差才会变为零。因此，满足 $\\mathcal{E}(p) \\le \\varepsilon$ 的最小整数 $p$ 必须是 $L$ 本身。\n\n- **情况 A**: 纯单极子场，$L=0$。最小的 $p$ 必须是 $0$。\n- **情况 B**: 纯偶极子场，$L=1$。最小的 $p$ 必须是 $1$。\n- **情况 C**: 纯四极子场，$L=2$。最小的 $p$ 必须是 $2$。\n\n预期结果是一个列表 `[0, 1, 2]`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import eval_legendre\n\ndef solve():\n    \"\"\"\n    Computes the minimal truncation order p for reconstructing axisymmetric\n    Laplace potentials with known finite multipole content.\n    \"\"\"\n    \n    # Define the observation points from the problem statement.\n    # Coordinates are spherical (r, theta, phi) with angles in radians.\n    observation_points = [\n        (5.0, 0.7, 0.1),\n        (4.2, 1.1, 1.2),\n        (10.0, 2.2, 2.4),\n        (3.3, 0.5, 2.0),\n    ]\n\n    # Define the synthetic test cases. Each case has a maximum degree L\n    # and a dictionary of non-zero axisymmetric moments Q_l0.\n    test_cases = [\n        {'L': 0, 'moments': {0: 2.0}},    # Case A: Pure monopole\n        {'L': 1, 'moments': {1: -0.75}},  # Case B: Pure dipole\n        {'L': 2, 'moments': {2: 0.8}},    # Case C: Pure quadrupole\n    ]\n\n    # Define the relative error tolerance and the maximum truncation order to test.\n    tolerance = 1e-12\n    p_max = 6\n    \n    final_results = []\n\n    def calculate_potential(r, theta, moments, p_limit):\n        \"\"\"\n        Calculates the axisymmetric potential at a point (r, theta) by summing\n        the multipole expansion up to a given truncation order p_limit.\n\n        Args:\n            r (float): Radial distance.\n            theta (float): Polar angle in radians.\n            moments (dict): A dictionary {l: Q_l0} of non-zero multipole moments.\n            p_limit (int): The maximum degree l to include in the sum.\n\n        Returns:\n            float: The calculated potential.\n        \"\"\"\n        potential = 0.0\n        cos_theta = np.cos(theta)\n        \n        for l in range(p_limit + 1):\n            if l in moments:\n                Q_l0 = moments.get(l, 0.0)\n                \n                # Associated Legendre polynomial P_l^0(cos(theta)) is P_l(cos(theta))\n                pl_cos_theta = eval_legendre(l, cos_theta)\n                \n                # Orthonormal spherical harmonic Y_l0(theta)\n                y_l0_norm = np.sqrt((2 * l + 1) / (4 * np.pi))\n                y_l0 = y_l0_norm * pl_cos_theta\n\n                # Term in the multipole expansion\n                term = Q_l0 * y_l0 / (r**(l + 1))\n                potential += term\n                \n        return potential\n\n    for case in test_cases:\n        L = case['L']\n        moments = case['moments']\n        \n        # 1. Calculate the exact potential at all observation points.\n        # The 'exact' potential is computed using all specified moments up to L.\n        V_exact_vals = np.array([\n            calculate_potential(r, theta, moments, L)\n            for r, theta, phi in observation_points\n        ])\n        \n        # 2. Determine the normalization factor for the relative error.\n        max_abs_V_exact = np.max(np.abs(V_exact_vals))\n\n        min_p_found = -1  # Sentinel for not found\n\n        # 3. Iterate through truncation orders p to find the minimal one.\n        for p in range(p_max + 1):\n            # Calculate the truncated potential for the current p.\n            V_p_vals = np.array([\n                calculate_potential(r, theta, moments, p)\n                for r, theta, phi in observation_points\n            ])\n            \n            # Calculate the maximum absolute difference.\n            max_abs_diff = np.max(np.abs(V_p_vals - V_exact_vals))\n            \n            # Calculate relative error, handling the case where the exact potential is zero.\n            if max_abs_V_exact > tolerance:\n                error = max_abs_diff / max_abs_V_exact\n            else:\n                # If the exact potential is effectively zero, the truncated one must be too.\n                error = 0.0 if max_abs_diff = tolerance else float('inf')\n\n            # 4. Check if the error is within tolerance.\n            if error = tolerance:\n                min_p_found = p\n                break  # Minimal p found, no need to check higher p.\n        \n        final_results.append(min_p_found)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3591359"}, {"introduction": "FMM 的原理不仅限于标准的 $1/r$ 引力势或静电势，其应用范围更为广泛。本练习挑战您将 FMM 的误差分析应用于汤川势，该势在地球物理学等领域中用于模拟屏蔽相互作用。通过推导新的截断误差界和多极接受准则，您将深入理解物理内核的特性如何直接影响算法参数的选择。[@problem_id:3591354]", "problem": "在计算地球物理学中，一个常见的任务是加速由分布源产生的屏蔽势的计算，这些屏蔽势通过 Yukawa 格林函数 $K(r)=\\exp(-\\kappa r)/r$ 建模。快速多极子方法（FMM）依赖于将多极展开和局域展开在 $p$ 阶截断，并使用基于距离的多极子接受准则（MAC）来确保精度。\n\n考虑一个半径为 $a$ 的立方体源盒，其中包含位于位置 $\\{\\mathbf{r}_i\\}$、带符号强度为 $\\{q_i\\}$ 的点源，以及一个距离源盒中心为 $R$ 的目标点，其中 $R>a$。假设总绝对强度有界于 $A$，即 $\\sum_i |q_i| \\leq A$。相对于 Laplace 核 $1/r$，Yukawa 核 $K(r)$ 提供了一种屏蔽相互作用。从格林函数的基本加法性质和多极截断误差（定义为球谐阶数 $\\ell \\geq p+1$ 的贡献）出发，通过使用最小间距 $R-a$ 对核函数进行限定，构建目标点绝对截断误差关于 $a$、$R$、$\\kappa$、$p$ 和 $A$ 的严格上界。\n\n使用此上界来：\n- 推导为达到给定的绝对误差容限 $\\varepsilon$，截断阶数 $p$ 必须如何缩放，并明确分离出对 $\\kappa$ 的依赖关系。\n- 推导一个适用于 Yukawa 核的修正 MAC，该准则在 $\\kappa \\to 0$ 时退化为标准的 Laplace MAC。\n\n然后，对于数值算例：$A=1.5$，$a=0.2$ (米)，$R=2.0$ (米)，$\\kappa=3.0$ (米⁻¹)，以及绝对误差容限 $\\varepsilon=1.0\\times 10^{-8}$，计算根据您推导的边界，保证满足该容限的最小整数截断阶数 $p$。将 $p$ 报告为一个无量纲整数。由于 $p$ 是整数，无需指定舍入规则。", "solution": "该问题陈述具有科学依据、良定且客观。它提出了计算物理学中的一个标准任务：分析用于 Yukawa 势的快速多极子方法（FMM）的截断误差。所有必要的参数和条件都已提供，不存在内部矛盾或违反物理原理的情况。因此，该问题被认为是有效的，并将构建一个解决方案。\n\n由位于位置 $\\{\\mathbf{r}_i\\}$ 的一组源电荷 $\\{q_i\\}$ 在目标点 $\\mathbf{x}$ 处产生的势由叠加原理给出：$\\Phi(\\mathbf{x}) = \\sum_i q_i K(|\\mathbf{x}-\\mathbf{r}_i|)$，其中核函数是 Yukawa 格林函数，$K(r) = \\frac{\\exp(-\\kappa r)}{r}$。源被包含在以原点为中心、半径为 $a$ 的区域内，即对所有 $i$ 都有 $|\\mathbf{r}_i| \\le a$。目标点距离原点的距离为 $R=|\\mathbf{x}| > a$。总绝对源强度有界于 $\\sum_i |q_i| \\le A$。\n\n**第一部分：截断误差界的推导**\n\nFMM 通过对远场相互作用使用截断的多极展开来近似计算势。这种近似的误差来源于忽略级数中的高阶项，特别是那些对应于球谐阶数 $\\ell \\ge p+1$ 的项。对 Yukawa 核的误差界进行严格推导涉及加法定理以及修正的球贝塞尔函数和球汉克尔函数的性质。然而，通过将 FMM 已知的几何收敛性质与基于核函数大小的最坏情况缩放相结合，可以构建一个合理且广泛使用的上界。\n\n对于 Laplace 核（$1/r$），其截断误差已知被一个项所界定，该项依赖于总电荷、反映源与目标分离的几何因子以及距离。对于半径为 $a$ 的球体内的源和距离为 $R$ 的目标，误差和是一个关于 $|\\mathbf{r}_i|/R \\le a/R$ 幂次的几何级数。该级数的尾部（从第 $p+1$ 项开始）之和被一个与 $\\frac{(a/R)^{p+1}}{1-a/R}$ 成比例的因子所界定。\n\n对于 Yukawa 核，基本的几何收敛率是相同的，但总体大小被指数屏蔽项 $\\exp(-\\kappa r)$ 所调制。一个保守的界是通过在源与目标之间可能的最小距离 $R-a$ 处评估核函数来获得的。\n\n绝对误差 $|E_p|$ 是被忽略项产生的势之和的绝对值。我们可以用每个源的绝对误差之和来界定它，然后使用总绝对强度 $A$ 进行界定：\n$|E_p| = \\left| \\sum_i q_i (\\text{对源 } i \\text{ 的误差}) \\right| \\le \\sum_i |q_i| |\\text{对单位源的误差}| \\le A \\cdot \\max_i |\\text{对单位源的误差}|$。\n\n单位源的最大误差是通过将最坏情况下的势值大小与几何衰减项相结合来获得的。势值大小在最小分离距离 $R-a$ 处最大化。因此，该界的核函数部分为 $K(R-a) = \\frac{\\exp(-\\kappa(R-a))}{R-a}$。将其与多极级数尾部的几何因子相结合，得到以下绝对截断误差上界：\n$$ |E_p| \\le A \\frac{\\exp(-\\kappa(R-a))}{R-a} \\frac{(a/R)^{p+1}}{1-a/R} $$\n此表达式提供了所要求的、用 $a$、$R$、$\\kappa$、$p$ 和 $A$ 表示的严格绝对截断误差上界。\n\n**第二部分：截断阶数 $p$ 的缩放关系**\n\n为达到给定的绝对误差容限 $\\varepsilon$，我们要求 $|E_p| \\le \\varepsilon$。使用上面推导的界：\n$$ A \\frac{\\exp(-\\kappa(R-a))}{R-a} \\frac{(a/R)^{p+1}}{1-a/R} \\le \\varepsilon $$\n我们对此不等式求解 $p$。首先，分离出含 $p$ 的项：\n$$ \\left(\\frac{a}{R}\\right)^{p+1} \\le \\frac{\\varepsilon(R-a)(1-a/R)}{A \\exp(-\\kappa(R-a))} $$\n代入 $1-a/R = (R-a)/R$：\n$$ \\left(\\frac{a}{R}\\right)^{p+1} \\le \\frac{\\varepsilon(R-a)^2}{A R \\exp(-\\kappa(R-a))} $$\n这是一个有效但繁琐的表达式。一个更简单的形式来自于认识到，对于分离良好的盒子，$(1-a/R)^{-1}$ 是一个接近 $1$ 的缓慢变化的因子，它源于对几何级数的求和。一个稍微更松但更常见的界是 $|E_p| \\le \\frac{A}{R-a} \\exp(-\\kappa(R-a)) (a/R)^{p+1}$，它简化了代数运算。为获得更高的精度，让我们从原始的、更紧的界重新推导缩放关系。\n$$ \\left(\\frac{a}{R}\\right)^{p+1} \\le \\frac{\\varepsilon}{A} \\frac{R-a}{1-a/R} \\exp(\\kappa(R-a)) = \\frac{\\varepsilon}{A} \\frac{R-a}{(R-a)/R} \\exp(\\kappa(R-a)) = \\frac{\\varepsilon R}{A} \\exp(\\kappa(R-a)) $$\n对两边取自然对数：\n$$ (p+1) \\ln\\left(\\frac{a}{R}\\right) \\le \\ln\\left(\\frac{\\varepsilon R}{A}\\right) + \\kappa(R-a) $$\n由于 $R>a$，项 $\\ln(a/R)$ 是负数。除以它会使不等号反向：\n$$ p+1 \\ge \\frac{\\ln\\left(\\frac{\\varepsilon R}{A}\\right) + \\kappa(R-a)}{\\ln(a/R)} $$\n重写 $\\ln(a/R) = -\\ln(R/a)$ 和 $\\ln(\\varepsilon R / A) = -\\ln(A/(\\varepsilon R))$：\n$$ p+1 \\ge \\frac{-\\ln\\left(\\frac{A}{\\varepsilon R}\\right) + \\kappa(R-a)}{-\\ln(R/a)} = \\frac{\\ln\\left(\\frac{A}{\\varepsilon R}\\right) - \\kappa(R-a)}{\\ln(R/a)} $$\n这给出了 $p$ 所需的缩放关系：\n$$ p \\ge \\frac{\\ln(A/(\\varepsilon R)) - \\kappa(R-a)}{\\ln(R/a)} - 1 $$\n对容限 $\\varepsilon$ 的依赖关系为 $p \\propto \\frac{\\ln(1/\\varepsilon)}{\\ln(R/a)}$。对屏蔽参数 $\\kappa$ 的依赖关系为 $p \\propto -\\frac{\\kappa(R-a)}{\\ln(R/a)}$。负号表示更强的屏蔽（更大的 $\\kappa$）会降低在给定精度下所需的截断阶数 $p$。这在物理上是直观的，因为指数衰减更强烈地抑制了高阶多极子贡献，从而允许更早的截断。\n\n**第三部分：修正的多极子接受准则 (MAC) 的推导**\n\nMAC 是一个几何条件，用于确定多极近似何时足够精确。对于 Laplace 核（$\\kappa=0$），误差主要由几何因子 $(a/R)^{p+1}$ 决定。一个典型的 MAC 要求此因子很小，这转化为对分离比的条件，例如 $R/a > C$，其中 $C$ 是某个常数（例如 $C=2$）。\n\n对于 Yukawa 核，误差被附加因子 $\\exp(-\\kappa(R-a))$ 所抑制。这意味着可以用一个不那么严格的几何分离来达到相同的精度。设 $R_L$ 是 Laplace MAC 为达到给定 $p$ 的某个误差目标所需的最小分离距离。设 $R_Y$ 是 Yukawa 核对应的最小分离距离。误差项必须相等：\n$$ C_{\\text{prefactor}} \\left(\\frac{a}{R_L}\\right)^{p+1} = C'_{\\text{prefactor}} \\exp(-\\kappa(R_Y-a)) \\left(\\frac{a}{R_Y}\\right)^{p+1} $$\n假设前置因子是可比较的，我们令衰减因子相等：\n$$ \\left(\\frac{a}{R_L}\\right)^{p+1} \\approx \\exp(-\\kappa(R_Y-a)) \\left(\\frac{a}{R_Y}\\right)^{p+1} $$\n$$ \\left(\\frac{R_Y}{R_L}\\right)^{p+1} \\approx \\exp\\left(-\\frac{\\kappa(R_Y-a)}{p+1}\\right) $$\n$$ \\frac{R_Y}{R_L} \\approx \\exp\\left(-\\frac{\\kappa(R_Y-a)}{p+1}\\right) $$\n$$ R_Y \\approx R_L \\exp\\left(-\\frac{\\kappa(R_Y-a)}{p+1}\\right) $$\n这个隐式方程定义了修正的 MAC。如果 Laplace MAC 是 $R > R_L$，则 Yukawa MAC 是 $R > R_Y$，其中 $R_Y$ 是此方程的解。由于当 $\\kappa>0$ 时指数项小于 $1$，我们有 $R_Y  R_L$，这意味着 Yukawa MAC 的限制更少。当 $\\kappa \\to 0$ 时，指数项趋近于 $1$，且 $R_Y \\to R_L$。因此，在无屏蔽的极限情况下，修正的 MAC 正确地退化为标准的 Laplace MAC。\n\n**第四部分：$p$ 的数值计算**\n\n我们给定的参数是：$A=1.5$，$a=0.2$ 米，$R=2.0$ 米，$\\kappa=3.0$ 米⁻¹，以及误差容限 $\\varepsilon=1.0\\times 10^{-8}$。我们寻求最小整数截断阶数 $p$。\n\n我们使用第二部分推导出的不等式：\n$$ p \\ge \\frac{\\ln(A/(\\varepsilon R)) - \\kappa(R-a)}{\\ln(R/a)} - 1 $$\n首先，我们计算各个组成项：\n- 分离比为 $R/a = 2.0 / 0.2 = 10$。\n- 该比值的对数为 $\\ln(R/a) = \\ln(10)$。\n- 最小分离距离为 $R-a = 2.0 - 0.2 = 1.8$。\n- 屏蔽因子参数为 $\\kappa(R-a) = 3.0 \\times 1.8 = 5.4$。\n- 主对数项的参数为 $\\frac{A}{\\varepsilon R} = \\frac{1.5}{(1.0 \\times 10^{-8})(2.0)} = \\frac{1.5}{2.0 \\times 10^{-8}} = 0.75 \\times 10^8 = 7.5 \\times 10^7$。\n- 那么分子项为 $\\ln(7.5 \\times 10^7) - 5.4 = \\ln(7.5) + 7\\ln(10) - 5.4$。\n\n使用近似值 $\\ln(10) \\approx 2.30259$ 和 $\\ln(7.5) \\approx 2.01490$：\n$$ p \\ge \\frac{(2.01490 + 7 \\times 2.30259) - 5.4}{2.30259} - 1 $$\n$$ p \\ge \\frac{(2.01490 + 16.11813) - 5.4}{2.30259} - 1 $$\n$$ p \\ge \\frac{18.13303 - 5.4}{2.30259} - 1 $$\n$$ p \\ge \\frac{12.73303}{2.30259} - 1 $$\n$$ p \\ge 5.5309 - 1 $$\n$$ p \\ge 4.5309 $$\n由于截断阶数 $p$ 必须是整数，满足此条件的最小整数值为 $p=5$。", "answer": "$$\\boxed{5}$$", "id": "3591354"}, {"introduction": "在保证算法正确性和适应性之后，实际应用中的下一个挑战是在并行计算机上实现高性能。本练习旨在解决分布式 FMM 中的一个关键瓶颈：通信延迟，指导您建模并模拟一种流水线策略以隐藏通信开销。掌握这种性能优化技术对于开发高效的并行科学计算软件至关重要。[@problem_id:3591372]", "problem": "您的任务是在高度非均匀源分布的分布式内存设置下，为快速多极子方法（FMM）设计并分析一种重叠策略，目标是通过将多极子到局部（M2L）操作与消息传递接口（MPI）通信进行流水线处理，以最大化强扩展性。其背景是计算地球物理学，其中FMM用于加速由拉普拉斯方程控制的势场的远程相互作用的评估。目标是从第一性原理出发，推导出一个能感知并发性的性能模型，并实现一个算法，该算法能够预测在给定的分布式工作负载和网络参数下的强扩展效率，并能自动选择分组策略以优化重叠。\n\n您必须从以下基本基础出发：\n- 由拉普拉斯方程控制的源的势场在充分分离的距离上允许进行多极展开。快速多极子方法利用这一点，通过将源分层聚合到盒子中，并通过展开而不是逐对求和来计算相互作用，从而相对于直接评估实现了亚二次复杂度。\n- 在FMM中，多极子到局部（M2L）算子将充分分离的源盒子的多极展开转换为目标盒子的局部展开。阶数为 $p$ 的球谐展开中的系数数量为 $(p+1)^2$。\n- 在通过消息传递接口（MPI）实现的分布式内存并行计算中，必须进行远程数据通信。每个消息的标准通信时间模型使用延迟-带宽分解 $T_{\\mathrm{comm}} = L + S/B$，其中 $L$ 是以秒为单位的延迟，$B$ 是以字节/秒为单位的带宽，$S$ 是以字节为单位的消息大小。\n- 由于涉及的系数数量，一次M2L相互作用的计算时间与展开阶数 $p$ 的平方成正比。我们采用一个模型，其中每对M2L相互作用的时间为 $T_{\\mathrm{pair}} = k \\, p^2$，其中 $k$ 的单位是秒/系数平方。\n\n考虑在 $P$ 个进程上进行分布式FMM评估。每个进程 $i$ 具有：\n- $L_i$ 个不依赖于远程数据的本地M2L对，\n- $R_i$ 个需要远程多极子系数的远程M2L对，\n- $B_i$ 个其多极子系数必须被通信的远程源盒子。\n\n为了重叠通信和计算，您将在每个进程上跨越 $G$ 个组对M2L进行流水线处理。您将总的本地对 $L_i$ 平均分配到 $G$ 个组中，同样地，也将总的远程对 $R_i$ 和总的远程盒子 $B_i$ 平均分配。对于进程 $i$ 上的每个组 $g$，您执行以下调度：\n1. 计算该组的纯本地工作，耗时 $T_{\\mathrm{pre}}^{(i)} = \\dfrac{L_i}{G} \\, k \\, p^2$。\n2. 通信该组的远程多极子系数。每个盒子的系数数量为 $(p+1)^2$，每个系数为 $8$ 字节，因此消息大小为 $S^{(i)} = \\dfrac{B_i}{G} \\cdot (p+1)^2 \\cdot 8$。通信时间为 $T_{\\mathrm{comm}}^{(i)} = L + \\dfrac{S^{(i)}}{B}$。\n3. 一旦纯本地的预计算和通信都完成，计算该组的远程依赖工作，耗时 $T_{\\mathrm{post}}^{(i)} = \\dfrac{R_i}{G} \\, k \\, p^2$。\n\n流水线设计在时间 $t=0$ 时开始组 $g=1$ 的通信。对于 $g>1$，组 $g$ 的通信在组 $g-1$ 的远程依赖计算开始时开始。您必须模拟此调度以获得在给定 $G$ 下每个进程 $i$ 的总时间 $T_i(G)$（考虑到通信的并发进程和计算资源的顺序使用）。并行完成时间是所有进程中的最大时间，即 $T_P(G) = \\max_i T_i(G)$。\n\n将完整问题规模的单进程运行时间 $T_1$（即，如果所有工作都在一个进程上执行且无通信）定义为\n$$\nT_1 = k \\, p^2 \\sum_{i=1}^P (L_i + R_i).\n$$\n\n在分组 $G$ 下，$P$ 个进程的强扩展效率定义为\n$$\nE_s(P;G) = \\frac{T_1}{P \\, T_P(G)}.\n$$\n\n对于每个测试用例，您的程序必须在一组候选组数 $G \\in \\{1,2,4,8,16,32\\}$ 中搜索，并选择最大化 $E_s(P;G)$（等效于最小化 $T_P(G)$）的 $G$。输出相应的最优强扩展效率 $E_s(P)$，形式为四舍五入到六位小数的十进制数。\n\n所有时间必须以秒表示和处理。消息大小必须以字节计算。程序的最终输出必须是单行文本，其中包含一个用方括号括起来的、所有测试用例的强扩展效率的逗号分隔列表（例如，“[0.932100,0.871553,0.998765]”）。\n\n测试套件：\n- 测试用例1（均衡工作负载，中等网络）：\n    - $P = 4$, $p = 8$, $k = 2.0 \\times 10^{-7}$, $L = 5.0 \\times 10^{-5}$, $B = 2.0 \\times 10^{8}$,\n    - $L_i = [40000, 38000, 42000, 41000]$,\n    - $R_i = [5000, 5200, 4800, 5100]$,\n    - $B_i = [800, 820, 780, 790]$.\n- 测试用例2（高度非均匀工作负载；一个进程具有大量远程工作）：\n    - $P = 4$, $p = 10$, $k = 1.5 \\times 10^{-7}$, $L = 2.0 \\times 10^{-4}$, $B = 1.0 \\times 10^{8}$,\n    - $L_i = [20000, 15000, 14000, 13000]$,\n    - $R_i = [60000, 4000, 3000, 2000]$,\n    - $B_i = [10000, 600, 500, 400]$.\n- 测试用例3（延迟主导的网络但计算均衡）：\n    - $P = 8$, $p = 6$, $k = 2.5 \\times 10^{-7}$, $L = 1.0 \\times 10^{-3}$, $B = 3.0 \\times 10^{7}$,\n    - $L_i = [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]$,\n    - $R_i = [800, 800, 800, 800, 800, 800, 800, 800]$,\n    - $B_i = [200, 200, 200, 200, 200, 200, 200, 200]$.\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个强扩展效率都四舍五入到六位小数，并以十进制形式表示（无百分号）。", "solution": "用户提供了一个问题，要求推导并实现一个用于分布式快速多极子方法（FMM）算法的性能模型。目标是确定最优的流水线策略，以最大化强扩展效率。\n\n### 第1步：提取已知条件\n- **领域**：计算地球物理学，用于拉普拉斯方程的FMM。\n- **并行性**：在 $P$ 个进程上使用消息传递接口（MPI）的分布式内存。\n- **核心操作**：多极子到局部（M2L）转换。\n- **展开阶数**：$p$。\n- **系数数量**：每个球谐展开为 $(p+1)^2$ 个。\n- **M2L计算时间模型**：每对M2L的时间为 $T_{\\mathrm{pair}} = k \\, p^2$。$k$ 是一个以秒为单位的常数。\n- **通信时间模型**：$T_{\\mathrm{comm}} = L + S/B$，其中 $L$ 是延迟（秒），$B$ 是带宽（字节/秒），$S$ 是消息大小（字节）。\n- **每个进程 $i$ 的数据**：\n    - $L_i$：本地M2L对的数量。\n    - $R_i$：远程M2L对的数量。\n    - $B_i$：远程源盒子的数量。\n- **流水线策略**：\n    - 每个进程上的工作负载被分成 $G$ 个组。\n    - **第1步（预计算）**：计算一个组的纯本地工作。时间：$T_{\\mathrm{pre}}^{(i)} = \\dfrac{L_i}{G} \\, k \\, p^2$。\n    - **第2步（通信）**：为一个组通信远程多极子系数。消息大小：$S^{(i)} = \\dfrac{B_i}{G} \\cdot (p+1)^2 \\cdot 8$ 字节（假设每个系数为 $8$ 字节）。通信时间：$T_{\\mathrm{comm}}^{(i)} = L + \\dfrac{S^{(i)}}{B}$。\n    - **第3步（后计算）**：计算一个组的远程依赖工作。时间：$T_{\\mathrm{post}}^{(i)} = \\dfrac{R_i}{G} \\, k \\, p^2$。\n- **流水线调度**：\n    - 组 $g=1$ 的通信在时间 $t=0$ 开始。\n    - 对于 $g > 1$，组 $g$ 的通信在组 $g-1$ 的后计算开始时启动。\n    - 一个组的计算只有在前一个组的计算完成后才能开始（计算资源的顺序使用）。\n    - 一个组的后计算只有在其对应的预计算和通信都完成后才能开始。\n- **性能指标**：\n    - **每个进程的总时间**：$T_i(G)$，进程 $i$ 上所有 $G$ 个组完成所需的时间。\n    - **并行完成时间**：$T_P(G) = \\max_i T_i(G)$。\n    - **单进程运行时间**：$T_1 = k \\, p^2 \\sum_{i=1}^P (L_i + R_i)$。\n    - **强扩展效率**：$E_s(P;G) = \\frac{T_1}{P \\, T_P(G)}$。\n- **目标**：对于给定的参数集，从集合 $\\{1,2,4,8,16,32\\}$ 中找到使 $E_s(P;G)$ 最大化的组数 $G$，并输出这个最大效率。\n- **测试用例**：提供了三个具有所有必要参数的不同测试用例。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学基础**：该问题在高性能计算和数值方法方面有充分的依据。FMM、MPI、使用延迟-带宽的性能建模以及流水线都是标准且有效的概念。物理背景（势场）是恰当的。\n- **适定性**：该问题是适定的。它提供了所有必要的输入、一个用于计算和通信的确定性模型、一个明确的任务（时间线模拟）以及一个明确的目标函数（效率最大化）。优化参数 $G$ 的搜索空间是有限且已指定的。\n- **客观性**：该问题以精确、客观的数学和算法术语陈述，没有主观因素。\n- **一致性**：该问题是内部一致的。计算时间（$k \\cdot p^2$）和通信大小（基于 $(p+1)^2$）的定义在问题描述中被明确陈述并一致使用。虽然这可能是对现实世界场景的简化，但这在问题定义的模型内不构成矛盾。\n- **完整性**：该问题是自包含的，提供了解决问题所需的所有数据和模型。\n- **可行性**：测试用例中给出的参数对于一个计算科学模拟来说在数值上是合理的。\n\n### 第3步：结论与行动\n该问题被判定为**有效**。这是一个定义明确的性能建模和算法模拟练习。我现在将着手构建解决方案。\n\n### 基于原理的解决方案设计\n\n问题的核心是为每个进程精确地模拟所提出的流水线调度，以确定其总执行时间 $T_i(G)$。整体并行执行时间（完成时间）$T_P(G)$ 是这些单个进程时间的最大值。\n\n**为单个进程建模流水线**\n\n让我们分析一个给定组数 $G$ 的单个进程 $i$ 的执行时间线。为简化符号，我们暂时省略上标 $(i)$。每个组的基本任务所用时间如下：\n- 每个组的预计算时间：$T_{\\mathrm{pre}} = \\dfrac{L_i}{G} \\, k \\, p^2$\n- 每个组的后计算时间：$T_{\\mathrm{post}} = \\dfrac{R_i}{G} \\, k \\, p^2$\n- 每个组的通信时间：$T_{\\mathrm{comm}} = L + \\dfrac{1}{B} \\left( \\dfrac{B_i}{G} \\cdot (p+1)^2 \\cdot 8 \\right)$\n\n我们需要跟踪所涉及的两种资源的状态：计算单元（CPU）和通信网络。CPU是顺序使用的，而通信可以与计算并发进行。我们定义 `t_sp[g]` 为组 $g$ 的后计算任务的开始时间，`t_ep[g]` 为其结束时间。我们可以通过从 $g=1$ 到 $g=G$ 逐组模拟其进展来构建一个递推关系。\n\n我们初始化 `t_sp[0] = 0` 和 `t_ep[0] = 0` 来表示任何工作开始之前的状态。\n\n对于组 $g = 1, 2, \\dots, G$：\n\n1.  **预计算任务 (`C-pre_g`)**：CPU是顺序使用的。组 $g$ 的预计算只有在组 $g-1$ 的所有计算都完成后才能开始。CPU在时间 `t_ep[g-1]` 变为空闲。\n    - `C-pre_g` 的开始时间：`t_ep[g-1]`\n    - `C-pre_g` 的结束时间：`t_end_pre_g = t_ep[g-1] + T_{\\mathrm{pre}}`\n\n2.  **通信任务 (`Comm_g`)**：根据规则，组 $g$ 的通信与组 $g-1$ 的后计算同时开始。对于第一个组（$g=1$），这个开始时间是 $t=0$，这与我们 `t_sp[0]=0` 的初始化是一致的。\n    - `Comm_g` 的开始时间：`t_start_comm_g = t_sp[g-1]`\n    - `Comm_g` 的结束时间：`t_end_comm_g = t_start_comm_g + T_{\\mathrm{comm}}`\n\n3.  **后计算任务 (`C-post_g`)**：此任务只有在满足两个条件时才能开始：\n    a) CPU可用，并已完成该组的预计算（在时间 `t_end_pre_g`）。\n    b) 所需的远程数据已到达，意味着该组的通信已完成（在时间 `t_end_comm_g`）。\n    因此，开始时间是这两个完成时间的最大值。\n    - `C-post_g` 的开始时间：`t_sp[g] = \\max(t_end_pre_g, t_end_comm_g)`\n    - `C-post_g` 的结束时间：`t_ep[g] = t_sp[g] + T_{\\mathrm{post}}`\n\n进程的总时间 $T_i(G)$ 是最后一个任务的完成时间，即 `t_ep[G]`。\n\n这种迭代模拟正确地建模了问题中描述的依赖关系和资源约束。\n\n**寻找最优效率的算法**\n\n完整的算法流程如下：\n1.  对于每个测试用例，解析输入参数：$P, p, k, L, B$ 以及数组 $L_i, R_i, B_i$。\n2.  计算串行参考时间，$T_1 = k \\, p^2 \\sum_{j=1}^P (L_j + R_j)$。\n3.  初始化变量 `max_efficiency` 为一个小于任何可能效率的值（例如，-1.0）。\n4.  遍历每个候选组数 $G \\in \\{1, 2, 4, 8, 16, 32\\}$。\n    a. 对于当前的 $G$，计算并行完成时间 $T_P(G)$。这需要另一个循环遍历每个进程 $i=1, \\dots, P$。\n        i. 对于每个进程 $i$，通过实现上述迭代流水线模拟来计算其总时间 $T_i(G)$。\n        ii. 完成时间是这些时间的最大值：$T_P(G) = \\max_{i} T_i(G)$。\n    b. 计算此 $G$ 的强扩展效率：$E_s(P;G) = \\frac{T_1}{P \\cdot T_P(G)}$。\n    c. 更新 `max_efficiency = \\max(max_efficiency, E_s(P;G))$。\n5.  检查完所有候选 $G$ 值后，得到的 `max_efficiency` 即为该测试用例的最优效率。\n6.  收集所有测试用例的最优效率，并将它们格式化为所需的字符串输出。\n\n此方法提供了一个健壮且可验证的解决方案，它直接实现了问题陈述中指定的模型。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_time_for_process(G, p, k, L_val, R_val, B_val, L_comm, B_comm):\n    \"\"\"\n    Simulates the pipelined execution for a single process to find its total runtime.\n\n    Args:\n        G (int): The number of groups.\n        p (int): The expansion order.\n        k (float): The compute time constant.\n        L_val (int): The number of local M2L pairs for this process.\n        R_val (int): The number of remote M2L pairs for this process.\n        B_val (int): The number of remote source boxes for this process.\n        L_comm (float): The network latency.\n        B_comm (float): The network bandwidth.\n\n    Returns:\n        float: The total execution time for this process.\n    \"\"\"\n    # Calculate per-group timings based on the problem's model\n    T_pre = (L_val / G) * k * p**2\n    T_post = (R_val / G) * k * p**2\n    \n    # Message size includes (p+1)^2 coefficients, each 8 bytes\n    msg_size_per_group = (B_val / G) * (p + 1)**2 * 8\n    T_comm = L_comm + msg_size_per_group / B_comm\n    \n    # Initialize timing variables for the pipeline simulation\n    # t_ep_prev: end time of the previous group's post-computation (CPU free time)\n    # t_sp_prev: start time of the previous group's post-computation\n    t_ep_prev = 0.0\n    t_sp_prev = 0.0\n    \n    # Iterate through each group to simulate the Gantt chart\n    for _ in range(G):\n        # The pre-computation for the current group starts after the previous group's\n        # entire computation (pre and post) is finished.\n        t_end_pre = t_ep_prev + T_pre\n        \n        # The communication for the current group starts when the previous group's\n        # post-computation began. For g=1, t_sp_prev is 0.\n        t_start_comm = t_sp_prev\n        t_end_comm = t_start_comm + T_comm\n        \n        # The post-computation for the current group can only start after its own\n        # pre-computation is done AND its communication has completed.\n        t_sp_curr = max(t_end_pre, t_end_comm)\n        \n        # The end time is the start time plus the duration.\n        t_ep_curr = t_sp_curr + T_post\n        \n        # Update state for the next iteration\n        t_ep_prev = t_ep_curr\n        t_sp_prev = t_sp_curr\n        \n    # The total time for the process is the end time of the last group's computation\n    return t_ep_prev\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"P\": 4, \"p\": 8, \"k\": 2.0e-7, \"L\": 5.0e-5, \"B\": 2.0e8,\n            \"L_i\": [40000, 38000, 42000, 41000],\n            \"R_i\": [5000, 5200, 4800, 5100],\n            \"B_i\": [800, 820, 780, 790]\n        },\n        {\n            \"P\": 4, \"p\": 10, \"k\": 1.5e-7, \"L\": 2.0e-4, \"B\": 1.0e8,\n            \"L_i\": [20000, 15000, 14000, 13000],\n            \"R_i\": [60000, 4000, 3000, 2000],\n            \"B_i\": [10000, 600, 500, 400]\n        },\n        {\n            \"P\": 8, \"p\": 6, \"k\": 2.5e-7, \"L\": 1.0e-3, \"B\": 3.0e7,\n            \"L_i\": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000],\n            \"R_i\": [800, 800, 800, 800, 800, 800, 800, 800],\n            \"B_i\": [200, 200, 200, 200, 200, 200, 200, 200]\n        }\n    ]\n    \n    candidate_G = [1, 2, 4, 8, 16, 32]\n    \n    results = []\n    \n    for case in test_cases:\n        P = case['P']\n        p = case['p']\n        k = case['k']\n        L_comm = case['L']\n        B_comm = case['B']\n        L_i = case['L_i']\n        R_i = case['R_i']\n        B_i = case['B_i']\n        \n        # Calculate the single-process reference time T1\n        total_m2l_pairs = sum(L_i) + sum(R_i)\n        T1 = k * p**2 * total_m2l_pairs\n        \n        max_efficiency = -1.0\n        \n        # Search for the optimal number of groups G\n        for G in candidate_G:\n            makespan_T_P_G = 0.0\n            # Find the maximum execution time (makespan) across all processes\n            for i in range(P):\n                T_i_G = calculate_time_for_process(\n                    G, p, k, L_i[i], R_i[i], B_i[i], L_comm, B_comm\n                )\n                if T_i_G > makespan_T_P_G:\n                    makespan_T_P_G = T_i_G\n            \n            # Calculate strong scaling efficiency\n            if makespan_T_P_G > 0:\n                efficiency = T1 / (P * makespan_T_P_G)\n            else:\n                efficiency = 0.0 # Should not occur in valid cases\n                \n            if efficiency > max_efficiency:\n                max_efficiency = efficiency\n                \n        results.append(f\"{max_efficiency:.6f}\")\n        \n    # Print the final results in the specified format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3591372"}]}