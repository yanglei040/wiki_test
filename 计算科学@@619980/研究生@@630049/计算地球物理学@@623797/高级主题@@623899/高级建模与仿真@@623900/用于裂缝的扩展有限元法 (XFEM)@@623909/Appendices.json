{"hands_on_practices": [{"introduction": "在扩展有限元方法（XFEM）中，首要任务是精确描述裂纹相对于不连续背景网格的几何位置。该实践将引导你使用水平集函数来隐式定义裂纹，并亲手实现定位裂纹与单元边界交点、求解裂纹尖端精确位置以及建立尖端局部坐标系的核心算法。这些都是实现裂纹尖端奇异性富集和在裂纹面施加边界条件的基础步骤 [@problem_id:3590698]。", "problem": "给定一个四节点（$4$-node）等参四边形单元，其节点按逆时针顺序编号为 $\\{0,1,2,3\\}$。几何形状由节点坐标 $\\{\\boldsymbol{x}_i\\}_{i=0}^3$ 指定，其中 $\\boldsymbol{x}_i = (x_i,y_i)$，单位为米。在每个节点上，提供了两个水平集场：$\\phi_i$ 和 $\\psi_i$。在扩展有限元法（XFEM）的背景下，假设 $\\phi(\\boldsymbol{x})$ 和 $\\psi(\\boldsymbol{x})$ 分别是 $\\{\\phi_i\\}$ 和 $\\{\\psi_i\\}$ 的等参双线性插值，并且它们表示在一条直裂纹附近，沿局部裂纹法向和裂纹切向的有符号距离。裂纹集由曲线 $\\Gamma_c := \\{\\boldsymbol{x} \\, | \\, \\phi(\\boldsymbol{x}) = 0, \\, \\psi(\\boldsymbol{x}) \\le 0\\}$ 定义，其中不等式选择了位于裂纹尖端处或其后方的零水平集部分。裂纹尖端是满足方程组 $\\phi(\\boldsymbol{x})=0$ 和 $\\psi(\\boldsymbol{x})=0$ 的唯一（可能在单元外部的）点。\n\n您的任务是根据第一性原理推导并实现一个完整的程序，对于下方的每个测试案例，该程序执行以下操作：\n\n1) 裂纹与边的交点。将每个单元边视为其两节点之间的线段。仅使用该边上 $\\phi$ 的节点值以及 $\\phi$ 沿该边线性变化的假设，确定曲线 $\\{\\phi=0\\}$ 是否在该边的开区间或闭区间内与其相交。如果相交，则在该边上定位唯一的交点。在任何这样的候选交点处，通过对两端点节点 $\\psi$ 值进行线性插值，来沿同一条边计算 $\\psi$ 的值，并且当且仅当 $\\psi \\le 0$ 时保留该交点。结果是在单元边界上保留的一组 $m \\in \\{0,1,2\\}$ 个交点。如果一个节点的 $\\phi=0$，则将该节点视为一个有效的候选交点；如果它位于两条边上，不要重复该点。按顺序 $(0,1)$, $(1,2)$, $(2,3), (3,0)$ 处理各边，并按相同顺序报告保留的交点。\n\n2) 裂纹尖端定位。使用标准母坐标 $\\boldsymbol{\\xi}=(\\xi,\\eta)\\in[-1,1]^2$ 上的等参双线性插值来模拟单元内部的 $\\phi(\\boldsymbol{\\xi})$ 和 $\\psi(\\boldsymbol{\\xi})$，并使用从 $(\\xi,\\eta)=(0,0)$ 开始的 Newton 迭代法求解非线性方程组\n$$\n\\phi(\\xi,\\eta) = 0, \\qquad \\psi(\\xi,\\eta)=0\n$$\n以得到 $(\\xi,\\eta)$。使用由节点坐标定义的相同等参映射，将 $(\\xi,\\eta)$ 映射到物理尖端位置 $\\boldsymbol{x}_{\\mathrm{tip}}$。\n\n3) 局部裂纹尖端坐标系和极坐标。通过等参映射，利用链式法则计算在 $\\boldsymbol{x}_{\\mathrm{tip}}$ 处的物理坐标系下的梯度 $\\nabla \\phi$ 和 $\\nabla \\psi$。定义标准正交局部基底为 $\\hat{\\boldsymbol{t}} := \\nabla \\psi / \\|\\nabla \\psi\\|$（局部裂纹切向）和 $\\hat{\\boldsymbol{n}} := \\nabla \\phi / \\|\\nabla \\phi\\|$（局部裂纹法向）。对于每个 Gauss 点 $\\boldsymbol{x}_{gp}$，构建 $\\Delta \\boldsymbol{x} := \\boldsymbol{x}_{gp} - \\boldsymbol{x}_{\\mathrm{tip}}$，计算局部分量 $x_{\\mathrm{loc}} := \\hat{\\boldsymbol{t}}\\cdot \\Delta\\boldsymbol{x}$ 和 $y_{\\mathrm{loc}} := \\hat{\\boldsymbol{n}}\\cdot \\Delta\\boldsymbol{x}$，然后计算极坐标\n$$\nr := \\sqrt{x_{\\mathrm{loc}}^2 + y_{\\mathrm{loc}}^2}, \\qquad \\theta := \\operatorname{atan2}(y_{\\mathrm{loc}}, x_{\\mathrm{loc}}).\n$$\n此处 $r$ 必须以米为单位报告，$\\theta$ 必须以弧度为单位报告。\n\n在母坐标系中使用标准的双点张量积 Gauss 求积法，横坐标为 $\\pm 1/\\sqrt{3}$（无需使用权重）。母坐标系下的 Gauss 点为 $(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$。使用等参双线性映射将每个点映射到物理空间。\n\n数值细节和约定：\n- 任何与零的比较都使用 $10^{-12}$ 的严格数值公差。\n- 保留交点时，使用相同的公差应用条件 $\\psi \\le 0$。\n- 如果 $m=1$，您仍必须为两个交点输出空间：对缺失的点使用占位符值 $-9999.0$ 米。如果 $m=0$，则报告的两个交点都必须是占位符。\n- 所有浮点输出均需四舍五入至恰好六位小数。角度必须以弧度为单位。坐标和距离必须以米为单位。\n- 单元边必须按顺序 $((0,1), (1,2), (2,3), (3,0))$ 进行处理和报告。\n\n测试套件。对于每个测试，都提供了以米为单位的 $\\{\\boldsymbol{x}_i\\}_{i=0}^3$ 以及节点数组 $\\{\\phi_i\\}_{i=0}^3$ 和 $\\{\\psi_i\\}_{i=0}^3$：\n\n- 测试 A（尖端在内部，一个保留的边界交点）：\n  - $\\boldsymbol{x}_0=(0,0)$, $\\boldsymbol{x}_1=(1,0)$, $\\boldsymbol{x}_2=(1,1)$, $\\boldsymbol{x}_3=(0,1)$。\n  - $\\phi = [-0.5,-0.5,0.5,0.5]$。\n  - $\\psi = [-0.25,0.75,0.75,-0.25]$。\n\n- 测试 B（完全切割的单元，两个保留的交点）：\n  - $\\boldsymbol{x}_0=(0,0)$, $\\boldsymbol{x}_1=(1,0)$, $\\boldsymbol{x}_2=(1,1)$, $\\boldsymbol{x}_3=(0,1)$。\n  - $\\phi = [-0.5,-0.5,0.5,0.5]$。\n  - $\\psi = [-2.0,-1.0,-1.0,-2.0]$。\n\n- 测试 C（斜向尖端在内部，一个保留的边界交点）：\n  - $\\boldsymbol{x}_0=(0,0)$, $\\boldsymbol{x}_1=(1,0)$, $\\boldsymbol{x}_2=(1,1)$, $\\boldsymbol{x}_3=(0,1)$。\n  - $\\phi \\approx [-0.219615242271,-0.719615242271,0.146410161514,0.646410161514]$。\n  - $\\psi \\approx [-0.819615242271,0.046410161514,0.546410161514,-0.319615242271]$。\n\n- 测试 D（一个交点处 $\\psi=0$ 的临界包含情况）：\n  - $\\boldsymbol{x}_0=(0,0)$, $\\boldsymbol{x}_1=(1,0)$, $\\boldsymbol{x}_2=(1,1)$, $\\boldsymbol{x}_3=(0,1)$。\n  - $\\phi = [-0.5,-0.5,0.5,0.5]$。\n  - $\\psi = [-1.0,0.0,0.0,-1.0]$。\n\n您的程序必须生成单行输出，其中包含测试 A–D 的结果，格式为逗号分隔的列表的列表，用方括号括起来，不含空格，顺序为 [A,B,C,D]。每个测试的结果本身就是一个列表，包含：\n- 整数 $m$，\n- 最多两个保留的边界交点的坐标（单位为米），按发现顺序排列，格式为 $(x_1,y_1,x_2,y_2)$，必要时使用 $-9999.0$，\n- 接着是四个 Gauss 点的局部极坐标，按固定顺序 $(\\xi,\\eta) = (-g,-g),(+g,-g),(+g,+g),(-g,+g)$，其中 $g=1/\\sqrt{3}$，格式为 $(r_1,\\theta_1,r_2,\\theta_2,r_3,\\theta_3,r_4,\\theta_4)$。\n\n因此，每个测试产生一个长度为 13 的列表：$[m,x_1,y_1,x_2,y_2,r_1,\\theta_1,r_2,\\theta_2,r_3,\\theta_3,r_4,\\theta_4]$，最终输出必须是以下形式的单行：\n$[[\\dots],[\\dots],[\\dots],[\\dots]]$\n不含空格，所有浮点数四舍五入至六位小数，角度以弧度为单位，长度以米为单位。", "solution": "该问题是有效的，因为它科学地基于扩展有限元法（XFEM）的原理，问题提法清晰完整，表述客观。它提出了一个断裂力学中标准的（尽管详细的）计算任务，其逻辑、物理或数学设置上没有任何明显的缺陷。\n\n该解决方案源自等参有限元公式和用于几何描述的水平集方法的基本原理。整个过程分为三个不同但相互关联的任务：定位裂纹与单元边界的交点，确定裂纹尖端的精确位置，以及在尖端建立一个局部坐标系来表征应力场邻域。\n\n在坐标为 $\\boldsymbol{x}=(x,y)$ 的二维物理空间中定义了一个四节点四边形单元。单元几何形状从一个标准的母单元映射而来，该母单元是一个由母坐标 $\\boldsymbol{\\xi}=(\\xi,\\eta) \\in [-1,1]^2$ 定义的正方形。该映射是使用节点 $i=0,1,2,3$ 的等参双线性形函数 $N_i(\\xi, \\eta)$ 实现的：\n$$\n\\boldsymbol{x}(\\xi, \\eta) = \\sum_{i=0}^{3} N_i(\\xi, \\eta) \\boldsymbol{x}_i\n$$\n其中 $\\boldsymbol{x}_i$ 是节点坐标。形函数由下式给出：\n$N_0(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$\n$N_1(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$\n$N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$\n$N_3(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$\n\n单元内的标量场，如水平集函数 $\\phi$ 和 $\\psi$，是使用相同的形函数从其节点值 $\\{\\phi_i\\}$ 和 $\\{\\psi_i\\}$ 插值得到的：\n$$\n\\phi(\\xi, \\eta) = \\sum_{i=0}^{3} N_i(\\xi, \\eta) \\phi_i, \\qquad \\psi(\\xi, \\eta) = \\sum_{i=0}^{3} N_i(\\xi, \\eta) \\psi_i\n$$\n\n裂纹由这两个水平集函数隐式定义。构成裂纹曲线 $\\Gamma_c$ 的点集是那些裂纹法向水平集 $\\phi$ 为零，且裂纹切向水平集 $\\psi$ 为非正的点：$\\Gamma_c = \\{\\boldsymbol{x} \\, | \\, \\phi(\\boldsymbol{x}) = 0, \\, \\psi(\\boldsymbol{x}) \\le 0\\}$。$\\psi$ 上的条件确定了裂纹的范围，裂纹尖端是两个场都为零的唯一一个点：$\\phi(\\boldsymbol{x}_{\\text{tip}})=0$ 和 $\\psi(\\boldsymbol{x}_{\\text{tip}})=0$。\n\n1) 裂纹与边的交点：\n为了找到裂纹与单元边界的交点，我们分析其四条边。对于连接节点 $i$ 和 $j$ 的边，我们假设水平集函数是线性变化的。如果节点值 $\\phi_i$ 和 $\\phi_j$ 异号或其中一个为零，即 $\\phi_i \\phi_j \\le 0$，则存在交点。交点在边上的位置可以通过线性插值找到。设 $\\alpha \\in [0,1]$ 为插值参数。交点处 $\\phi=0$ 的条件得出：\n$$\n\\phi_{\\text{int}} = (1-\\alpha)\\phi_i + \\alpha\\phi_j = 0 \\implies \\alpha = \\frac{\\phi_i}{\\phi_i - \\phi_j}\n$$\n这在 $\\phi_i \\neq \\phi_j$ 时有效。如果 $\\phi_i = \\phi_j$，则在开线段内没有交点。如果一个节点本身位于裂纹轨迹上（例如，对于一个很小的公差 $\\epsilon$ 有 $|\\phi_i|  \\epsilon$），它就是一个对应于 $\\alpha=0$ 的候选交点。那么交点的物理坐标 $\\boldsymbol{x}_{\\text{int}}$ 是：\n$$\n\\boldsymbol{x}_{\\text{int}} = (1-\\alpha)\\boldsymbol{x}_i + \\alpha\\boldsymbol{x}_j\n$$\n为了确定该点是否是裂纹 $\\Gamma_c$ 的一部分，我们使用相同的线性插值在该位置计算 $\\psi$：\n$$\n\\psi_{\\text{int}} = (1-\\alpha)\\psi_i + \\alpha\\psi_j\n$$\n当且仅当 $\\psi_{\\text{int}} \\le \\epsilon$ 时，该交点被保留。对所有四条边按指定顺序 $(0,1), (1,2), (2,3), (3,0)$ 重复此过程。编译一个保留交点的列表，并对两条边共享的节点执行去重步骤，以确保每个唯一的点只报告一次，同时保留发现的顺序。最终结果是一组 $m \\in \\{0, 1, 2\\}$ 个点。\n\n2) 裂纹尖端定位：\n裂纹尖端是母域中同时求解非线性方程组的点 $(\\xi_{\\text{tip}}, \\eta_{\\text{tip}})$：\n$$\n\\boldsymbol{F}(\\xi, \\eta) = \\begin{pmatrix} \\phi(\\xi, \\eta) \\\\ \\psi(\\xi, \\eta) \\end{pmatrix} = \\begin{pmatrix} \\sum_i N_i(\\xi, \\eta) \\phi_i \\\\ \\sum_i N_i(\\xi, \\eta) \\psi_i \\end{pmatrix} = \\boldsymbol{0}\n$$\n该方程组使用 Newton-Raphson 方法求解。从初始猜测 $(\\xi_0, \\eta_0) = (0,0)$ 开始，通过迭代更新规则找到逐次逼近值：\n$$\n\\begin{pmatrix} \\xi_{k+1} \\\\ \\eta_{k+1} \\end{pmatrix} = \\begin{pmatrix} \\xi_k \\\\ \\eta_k \\end{pmatrix} - \\boldsymbol{J}_{\\boldsymbol{F}}^{-1}(\\xi_k, \\eta_k) \\boldsymbol{F}(\\xi_k, \\eta_k)\n$$\n其中 $\\boldsymbol{J}_{\\boldsymbol{F}}$ 是 $\\boldsymbol{F}$ 关于 $(\\xi, \\eta)$ 的 Jacobian 矩阵：\n$$\n\\boldsymbol{J}_{\\boldsymbol{F}} = \\begin{pmatrix} \\frac{\\partial \\phi}{\\partial \\xi}  \\frac{\\partial \\phi}{\\partial \\eta} \\\\ \\frac{\\partial \\psi}{\\partial \\xi}  \\frac{\\partial \\psi}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} \\sum_i \\frac{\\partial N_i}{\\partial \\xi} \\phi_i  \\sum_i \\frac{\\partial N_i}{\\partial \\eta} \\phi_i \\\\ \\sum_i \\frac{\\partial N_i}{\\partial \\xi} \\psi_i  \\sum_i \\frac{\\partial N_i}{\\partial \\eta} \\psi_i \\end{pmatrix}\n$$\n形函数的导数是解析计算的。迭代持续固定步数，直到达到收敛至 $(\\xi_{\\text{tip}}, \\eta_{\\text{tip}})$。然后通过应用等参映射找到裂纹尖端的物理位置 $\\boldsymbol{x}_{\\text{tip}}$：$\\boldsymbol{x}_{\\text{tip}} = \\boldsymbol{x}(\\xi_{\\text{tip}}, \\eta_{\\text{tip}})$。\n\n3) 局部裂纹尖端坐标系和极坐标：\n裂纹尖端的局部坐标系对于分析周围场至关重要。该系统由两个标准正交基向量定义：$\\hat{\\boldsymbol{t}}$，与裂纹相切；以及 $\\hat{\\boldsymbol{n}}$，与裂纹垂直。这些由尖端处水平集函数的梯度确定：\n$$\n\\hat{\\boldsymbol{t}} = \\frac{\\nabla \\psi}{\\|\\nabla \\psi\\|}, \\qquad \\hat{\\boldsymbol{n}} = \\frac{\\nabla \\phi}{\\|\\nabla \\phi\\|}\n$$\n梯度 $\\nabla\\phi = (\\frac{\\partial\\phi}{\\partial x}, \\frac{\\partial\\phi}{\\partial y})$ 和 $\\nabla\\psi$ 必须在物理坐标中计算。这需要使用链式法则从母域转换梯度：\n$$\n\\begin{pmatrix} \\frac{\\partial f}{\\partial x} \\\\ \\frac{\\partial f}{\\partial y} \\end{pmatrix} = \\boldsymbol{J}_{\\text{map}}^{-T} \\begin{pmatrix} \\frac{\\partial f}{\\partial \\xi} \\\\ \\frac{\\partial f}{\\partial \\eta} \\end{pmatrix}\n$$\n其中 $f$ 是 $\\phi$ 或 $\\psi$，$\\boldsymbol{J}_{\\text{map}}$ 是坐标映射 $\\boldsymbol{x}(\\xi, \\eta)$ 的 Jacobian 矩阵，在 $(\\xi_{\\text{tip}}, \\eta_{\\text{tip}})$ 处求值：\n$$\n\\boldsymbol{J}_{\\text{map}} = \\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} \\sum_i \\frac{\\partial N_i}{\\partial \\xi} x_i  \\sum_i \\frac{\\partial N_i}{\\partial \\eta} x_i \\\\ \\sum_i \\frac{\\partial N_i}{\\partial \\xi} y_i  \\sum_i \\frac{\\partial N_i}{\\partial \\eta} y_i \\end{pmatrix}\n$$\n建立了局部基底 $(\\hat{\\boldsymbol{t}}, \\hat{\\boldsymbol{n}})$ 后，我们可以找到任意点（例如 Gauss 求积点 $\\boldsymbol{x}_{\\text{gp}}$）的局部坐标。首先，将 Gauss 点的母坐标 $(\\xi_{\\text{gp}},\\eta_{\\text{gp}})$ 映射到物理空间。然后，将从尖端到 Gauss 点的向量 $\\Delta \\boldsymbol{x} = \\boldsymbol{x}_{\\text{gp}} - \\boldsymbol{x}_{\\text{tip}}$ 投影到局部基底上：\n$$\nx_{\\text{loc}} = \\Delta \\boldsymbol{x} \\cdot \\hat{\\boldsymbol{t}}, \\qquad y_{\\text{loc}} = \\Delta \\boldsymbol{x} \\cdot \\hat{\\boldsymbol{n}}\n$$\n最后，将这些局部笛卡尔坐标转换为极坐标 $(r, \\theta)$：\n$$\nr = \\sqrt{x_{\\text{loc}}^2 + y_{\\text{loc}}^2}, \\qquad \\theta = \\operatorname{atan2}(y_{\\text{loc}}, x_{\\text{loc}})\n$$\n对指定的四个 Gauss 点执行此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the XFEM crack problem for a 4-node quadrilateral element\n    for a suite of test cases.\n    \"\"\"\n\n    # Helper functions for isoparametric calculations\n    def shape_functions(xi, eta):\n        N = 0.25 * np.array([\n            (1.0 - xi) * (1.0 - eta),\n            (1.0 + xi) * (1.0 - eta),\n            (1.0 + xi) * (1.0 + eta),\n            (1.0 - xi) * (1.0 + eta)\n        ])\n        return N\n\n    def shape_derivatives(xi, eta):\n        dNdxi = 0.25 * np.array([\n            -(1.0 - eta),\n             (1.0 - eta),\n             (1.0 + eta),\n            -(1.0 + eta)\n        ])\n        dNdeta = 0.25 * np.array([\n            -(1.0 - xi),\n            -(1.0 + xi),\n             (1.0 + xi),\n             (1.0 - xi)\n        ])\n        return dNdxi, dNdeta\n\n    # Test cases definition\n    test_cases = [\n        {\n            \"coords\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"phi\": np.array([-0.5, -0.5, 0.5, 0.5]),\n            \"psi\": np.array([-0.25, 0.75, 0.75, -0.25])\n        },\n        {\n            \"coords\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"phi\": np.array([-0.5, -0.5, 0.5, 0.5]),\n            \"psi\": np.array([-2.0, -1.0, -1.0, -2.0])\n        },\n        {\n            \"coords\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"phi\": np.array([-0.219615242271, -0.719615242271, 0.146410161514, 0.646410161514]),\n            \"psi\": np.array([-0.819615242271, 0.046410161514, 0.546410161514, -0.319615242271])\n        },\n        {\n            \"coords\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"phi\": np.array([-0.5, -0.5, 0.5, 0.5]),\n            \"psi\": np.array([-1.0, 0.0, 0.0, -1.0])\n        },\n    ]\n\n    results = []\n    tol = 1e-12\n\n    for case in test_cases:\n        coords = case[\"coords\"]\n        phi_vals = case[\"phi\"]\n        psi_vals = case[\"psi\"]\n        \n        # --- 1) Crack-edge intersections ---\n        raw_intersections = []\n        edges = [(0, 1), (1, 2), (2, 3), (3, 0)]\n        for i, j in edges:\n            phi_i, phi_j = phi_vals[i], phi_vals[j]\n            if phi_i * phi_j = tol * tol:\n                if abs(phi_i - phi_j) > tol:\n                    alpha = phi_i / (phi_i - phi_j)\n                    if 0.0 = alpha = 1.0:\n                        psi_i, psi_j = psi_vals[i], psi_vals[j]\n                        psi_int = (1.0 - alpha) * psi_i + alpha * psi_j\n                        if psi_int = tol:\n                            x_i, x_j = coords[i], coords[j]\n                            x_int = (1.0 - alpha) * x_i + alpha * x_j\n                            raw_intersections.append(x_int)\n                else: # phi_i approx phi_j\n                    if abs(phi_i) = tol: # Edge is on phi=0 contour\n                        # Check both nodes\n                        if psi_vals[i] = tol:\n                           raw_intersections.append(coords[i])\n                        if psi_vals[j] = tol:\n                           raw_intersections.append(coords[j])\n        \n        # De-duplicate while preserving order\n        intersections = []\n        for p in raw_intersections:\n            is_duplicate = any(np.linalg.norm(p - up)  tol for up in intersections)\n            if not is_duplicate:\n                intersections.append(p)\n        \n        m = len(intersections)\n        intersections_coords = np.full((2, 2), -9999.0)\n        if m > 0:\n            intersections_coords[:m, :] = np.array(intersections)\n\n        # --- 2) Crack-tip location ---\n        xi, eta = 0.0, 0.0\n        for _ in range(10): # Newton-Raphson iterations\n            N = shape_functions(xi, eta)\n            dNdxi, dNdeta = shape_derivatives(xi, eta)\n            \n            F = np.array([N @ phi_vals, N @ psi_vals])\n            \n            J_F = np.array([\n                [dNdxi @ phi_vals, dNdeta @ phi_vals],\n                [dNdxi @ psi_vals, dNdeta @ psi_vals]\n            ])\n            \n            delta = np.linalg.solve(J_F, -F)\n            xi += delta[0]\n            eta += delta[1]\n        \n        tip_xi_eta = np.array([xi, eta])\n        x_tip = shape_functions(xi, eta) @ coords\n\n        # --- 3) Local crack-tip frame and polar coordinates ---\n        dNdxi_tip, dNdeta_tip = shape_derivatives(tip_xi_eta[0], tip_xi_eta[1])\n        \n        J_map = np.array([\n            [dNdxi_tip @ coords[:, 0], dNdeta_tip @ coords[:, 0]],\n            [dNdxi_tip @ coords[:, 1], dNdeta_tip @ coords[:, 1]]\n        ])\n        \n        grad_phi_parent = np.array([dNdxi_tip @ phi_vals, dNdeta_tip @ phi_vals])\n        grad_psi_parent = np.array([dNdxi_tip @ psi_vals, dNdeta_tip @ psi_vals])\n        \n        J_map_inv_T = np.linalg.inv(J_map).T\n        \n        grad_phi_phys = J_map_inv_T @ grad_phi_parent\n        grad_psi_phys = J_map_inv_T @ grad_psi_parent\n        \n        n_hat = grad_phi_phys / np.linalg.norm(grad_phi_phys)\n        t_hat = grad_psi_phys / np.linalg.norm(grad_psi_phys)\n        \n        g = 1.0 / np.sqrt(3.0)\n        gauss_points_parent = [(-g, -g), (g, -g), (g, g), (-g, g)]\n        \n        polar_coords = []\n        for xi_gp, eta_gp in gauss_points_parent:\n            x_gp = shape_functions(xi_gp, eta_gp) @ coords\n            delta_x = x_gp - x_tip\n            \n            x_loc = np.dot(delta_x, t_hat)\n            y_loc = np.dot(delta_x, n_hat)\n            \n            r = np.hypot(x_loc, y_loc)\n            theta = np.arctan2(y_loc, x_loc)\n            polar_coords.extend([r, theta])\n\n        # Assemble final result for the current case\n        case_result = [m] + list(intersections_coords.flatten()) + polar_coords\n        results.append(case_result)\n\n    # Format the final output string\n    output_parts = []\n    for res_list in results:\n        items = [str(res_list[0])]\n        for val in res_list[1:]:\n             items.append(f\"{val:.6f}\")\n        output_parts.append(\"[\" + \",\".join(items) + \"]\")\n    final_str = \"[\" + \",\".join(output_parts) + \"]\"\n    print(final_str)\n\nsolve()\n```", "id": "3590698"}, {"introduction": "一旦确定了裂纹在单元内的几何路径，下一步便是在弱形式中正确计入其影响，这通常涉及到沿裂纹面的线积分。本练习聚焦于其中一个关键环节：推导雅可比行列式，以便将物理空间中的积分（如施加在裂纹面上的力）转换到标准参考区间上进行数值求积。掌握这一变换对于在扩展有限元框架中施加载荷或模拟接触至关重要 [@problem_id:3590767]。", "problem": "在二维小应变线性弹性理论中，考虑当使用扩展有限元法 (XFEM) 表示裂纹并在其表面施加诺伊曼边界条件时，弱形式中出现的内面力功项。对于一个被直线裂纹面切割的单元，穿过该单元的裂纹面线段所产生的贡献表示为以下形式的一维线积分：\n$$\n\\int_{\\Gamma_{c}^{e}} \\boldsymbol{N}^{\\top}(\\boldsymbol{x})\\,\\boldsymbol{t}(\\boldsymbol{x})\\,\\mathrm{d}\\Gamma,\n$$\n其中 $\\Gamma_{c}^{e}$ 是单元内部的裂纹面部分，$\\boldsymbol{N}$ 是在积分点处求值的有限元形函数矩阵，$\\boldsymbol{t}$ 是面力矢量。\n\n假设一个双线性四边形有限元，其物理空间节点坐标（单位：米）为 $\\boldsymbol{x}_{1}=(0,0)$、$\\boldsymbol{x}_{2}=(2,0)$、$\\boldsymbol{x}_{3}=(2,1)$ 和 $\\boldsymbol{x}_{4}=(0,1)$。该直线裂纹面与此单元相交于两个物理空间点 $\\boldsymbol{P}_{a}=(0.5,\\,0.2)$ 和 $\\boldsymbol{P}_{b}=(1.5,\\,0.8)$，因此 $\\Gamma_{c}^{e}$ 是连接 $\\boldsymbol{P}_{a}$ 和 $\\boldsymbol{P}_{b}$ 的直线段。\n\n从线积分的定义以及一个用单一参数 $\\eta\\in[-1,1]$ 参数化线段 $\\Gamma_{c}^{e}$ 的一维等参映射出发，推导该线段的一维映射雅可比 $J(\\eta)=\\left\\|\\frac{\\mathrm{d}\\boldsymbol{x}}{\\mathrm{d}\\eta}\\right\\|$，并确定用于沿 $\\Gamma_{c}^{e}$ 积分面力项的、在区间 $[-1,1]$ 上的两点高斯-勒让德法则的转换后求积权重。区间 $[-1,1]$ 上的两点高斯-勒让德法则的横坐标和权重可视为已知。\n\n请报告雅可比 $J$ 和两个物理空间求积权重的数值（单位为米），并将结果四舍五入至四位有效数字。", "solution": "施加在被切割单元内部的裂纹面线段 $\\Gamma_{c}^{e}$ 上的面力所产生的弱形式贡献由以下一维线积分给出：\n$$\n\\int_{\\Gamma_{c}^{e}} \\boldsymbol{N}^{\\top}(\\boldsymbol{x})\\,\\boldsymbol{t}(\\boldsymbol{x})\\,\\mathrm{d}\\Gamma,\n$$\n其中几何测度 $\\mathrm{d}\\Gamma$ 是沿裂纹线段的线元。为对此积分进行数值计算，我们使用从参考坐标 $\\eta\\in[-1,1]$ 到物理坐标 $\\boldsymbol{x}(\\eta)$ 的等参仿射映射来参数化 $\\boldsymbol{P}_{a}$ 和 $\\boldsymbol{P}_{b}$ 之间的直线段：\n$$\n\\boldsymbol{x}(\\eta) \\;=\\; \\frac{1-\\eta}{2}\\,\\boldsymbol{P}_{a} \\;+\\; \\frac{1+\\eta}{2}\\,\\boldsymbol{P}_{b}.\n$$\n该映射满足 $\\boldsymbol{x}(-1)=\\boldsymbol{P}_{a}$ 和 $\\boldsymbol{x}(+1)=\\boldsymbol{P}_{b}$。线元变换关系如下：\n$$\n\\mathrm{d}\\Gamma \\;=\\; \\left\\| \\frac{\\mathrm{d}\\boldsymbol{x}}{\\mathrm{d}\\eta} \\right\\| \\,\\mathrm{d}\\eta \\;\\equiv\\; J(\\eta)\\,\\mathrm{d}\\eta.\n$$\n将 $\\boldsymbol{x}(\\eta)$ 对 $\\eta$ 求导可得：\n$$\n\\frac{\\mathrm{d}\\boldsymbol{x}}{\\mathrm{d}\\eta} \\;=\\; -\\frac{1}{2}\\,\\boldsymbol{P}_{a} \\;+\\; \\frac{1}{2}\\,\\boldsymbol{P}_{b} \\;=\\; \\frac{1}{2}\\left(\\boldsymbol{P}_{b}-\\boldsymbol{P}_{a}\\right).\n$$\n因此，雅可比沿该线段为常数：\n$$\nJ(\\eta) \\;=\\; \\left\\| \\frac{1}{2}\\left(\\boldsymbol{P}_{b}-\\boldsymbol{P}_{a}\\right) \\right\\| \\;=\\; \\frac{1}{2}\\,\\left\\|\\boldsymbol{P}_{b}-\\boldsymbol{P}_{a}\\right\\|.\n$$\n定义线段矢量及其长度：\n$$\n\\Delta \\boldsymbol{P} \\;=\\; \\boldsymbol{P}_{b}-\\boldsymbol{P}_{a}, \\qquad L \\;=\\; \\|\\Delta \\boldsymbol{P}\\|.\n$$\n则\n$$\nJ(\\eta) \\;=\\; \\frac{L}{2}.\n$$\n根据给定的点 $\\boldsymbol{P}_{a}=(0.5,\\,0.2)$ 和 $\\boldsymbol{P}_{b}=(1.5,\\,0.8)$（单位：米），我们计算：\n$$\n\\Delta \\boldsymbol{P} \\;=\\; \\begin{pmatrix} 1.5-0.5 \\\\ 0.8-0.2 \\end{pmatrix} \\;=\\; \\begin{pmatrix} 1.0 \\\\ 0.6 \\end{pmatrix},\n$$\n从而\n$$\nL \\;=\\; \\sqrt{(1.0)^{2} + (0.6)^{2}} \\;=\\; \\sqrt{1.36}.\n$$\n因此，\n$$\nJ \\;=\\; \\frac{L}{2} \\;=\\; \\frac{\\sqrt{1.36}}{2}.\n$$\n对于在区间 $[-1,1]$ 上使用两点高斯-勒让德法则进行的数值积分，其参考横坐标为 $\\eta_{1}=-\\frac{1}{\\sqrt{3}}$ 和 $\\eta_{2}=+\\frac{1}{\\sqrt{3}}$，参考权重为 $w_{1}=w_{2}=1$。线积分的转换后物理空间求积公式为：\n$$\n\\int_{-1}^{1} f(\\eta)\\,J\\,\\mathrm{d}\\eta \\;\\approx\\; \\sum_{i=1}^{2} w_{i}\\,J\\,f(\\eta_{i}),\n$$\n因此物理空间权重为\n$$\nw_{i}^{\\text{phys}} \\;=\\; w_{i}\\,J \\;=\\; J, \\qquad i=1,2.\n$$\n数值上，使用 $L=\\sqrt{1.36}$，\n$$\nL \\;=\\; \\sqrt{1.36} \\;\\approx\\; 1.166190378\\ldots, \\qquad J \\;=\\; \\frac{L}{2} \\;\\approx\\; 0.583095189\\ldots\n$$\n四舍五入到四位有效数字（并按要求以米表示），我们得到：\n$$\nJ \\;\\approx\\; 0.5831, \\qquad w_{1}^{\\text{phys}} \\;\\approx\\; 0.5831, \\qquad w_{2}^{\\text{phys}} \\;\\approx\\; 0.5831.\n$$\n这些值分别是直线段映射的常数雅可比，以及用于沿被切割单元内的裂纹面线段进行积分的两个相同的转换后高斯-勒让德权重。", "answer": "$$\\boxed{\\begin{pmatrix}0.5831  0.5831  0.5831\\end{pmatrix}}$$", "id": "3590767"}, {"introduction": "在显式动力学模拟中，扩展有限元方法面临一个重大的实际挑战，即“小切割单元问题”。当裂纹切割单元时，会产生用于数值积分的极小尺寸子域，这会严重限制稳定时间步长。本练习将引导你推导适用于扩展有限元方法的 Courant-Friedrichs-Lewy (CFL) 稳定性条件，从而深刻理解最小单元尺寸与最大稳定时间步长之间的直接联系 [@problem_id:3590742]。", "problem": "考虑在密度为 $\\,\\rho\\,$、杨氏模量为 $\\,E\\,$、泊松比为 $\\,\\nu\\,$ 的均质、各向同性岩石中的小应变、线性、平面应变弹性动力学问题。裂纹通过扩展有限元法 (XFEM) 进行表示，该方法通过增强被不连续面切割的单元中的位移近似来实现。在被切割的单元中，数值积分通过将被切割的多边形进行子三角剖分，划分为多个积分单元来执行。在采用对角（集中）质量的显式中心差分时间积分方案中，Courant–Friedrichs–Lewy (CFL) 条件通过网格所支持的最高离散波频率来约束稳定时间步长。在一个被裂纹穿过的增强单元中，某个积分单元是一个狭长薄片，其最小尺寸等于 $\\,\\ell_{\\min}\\,$。假设：\n- 增强近似不会改变连续介质的波速，但可以产生任意小的积分单元。\n- 最具限制性的离散模式沿狭长薄片的最小尺寸 $\\,\\ell_{\\min}\\,$ 方向局部化，该模式决定了切割处附近半离散系统的最大本征频率。\n- 显式格式使用与 Lamé 参数 $\\,\\lambda\\,$ 和 $\\,\\mu\\,$ 相一致的线性弹性理论，并且质量集中方式与底层线性有限元相一致。\n\n从运动方程 $\\,\\rho\\,\\ddot{\\boldsymbol{u}}=\\nabla\\cdot\\boldsymbol{\\sigma}\\,$（其中 $\\,\\boldsymbol{\\sigma}=\\lambda\\,\\mathrm{tr}(\\boldsymbol{\\varepsilon})\\boldsymbol{I}+2\\mu\\,\\boldsymbol{\\varepsilon}\\,$）以及平面应变下的压缩波和剪切波速定义出发，推导稳定显式时间步长 $\\,\\Delta t_{\\mathrm{crit}}\\,$ 的一个解析上界，该上界用最小切割子单元尺寸 $\\,\\ell_{\\min}\\,$ 和材料参数表示。您的推导必须从这些场方程开始，并通过一个基于能量或色散的论证来进行，该论证将最大本征频率与狭长薄片上的最小可表示波长联系起来，其中狭长薄片被建模为沿 $\\,\\ell_{\\min}\\,$ 方向的一维质量-弹簧链替代模型。然后，使用以下材料和几何数据对您推导的界限进行数值计算：\n- $\\,E=40\\,\\mathrm{GPa}\\,$，\n- $\\,\\nu=0.25\\,$，\n- $\\,\\rho=2600\\,\\mathrm{kg/m^{3}}\\,$，\n- $\\,\\ell_{\\min}=0.50\\,\\mathrm{mm}\\,$。\n\n将最终时间步长以微秒为单位表示，并将答案四舍五入到四位有效数字。最终答案必须是一个单独的实数值。", "solution": "用户要求在扩展有限元法 (XFEM) 模拟中推导稳定显式时间步长的上界，并进行数值评估。\n\n该问题在计算固体力学和地球物理学领域是公认的。弹性动力学、平面应变、XFEM、集中质量矩阵、显式时间积分以及 Courant–Friedrichs–Lewy (CFL) 稳定性条件等概念都是标准的、科学上合理的。由微小的“狭长薄片”单元决定稳定时间步长的问题是这些方法中一个已知的、实践中的挑战。该问题是适定的，它提供了所有必要的物理定律、假设和数值数据，以得出一个唯一的解析表达式及其数值。\n\n线性弹性动力学的控制方程是 Navier-Cauchy 方程：\n$$ \\rho\\,\\ddot{\\boldsymbol{u}} = (\\lambda + \\mu) \\nabla(\\nabla \\cdot \\boldsymbol{u}) + \\mu \\nabla^2 \\boldsymbol{u} $$\n该方程支持的最快波是压缩波（P波），其传播速度 $v_p$ 决定了稳定性：\n$$ v_p = \\sqrt{\\frac{\\lambda + 2\\mu}{\\rho}} $$\n对于平面应变，Lamé 参数与杨氏模量 $E$ 和泊松比 $\\nu$ 的关系是：\n$$ \\mu = \\frac{E}{2(1+\\nu)}, \\qquad \\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)} $$\n因此，平面应变P波模量 $M = \\lambda + 2\\mu$ 为：\n$$ M = \\frac{E(1-\\nu)}{(1+\\nu)(1-2\\nu)} $$\nP波速度为：\n$$ v_p = \\sqrt{\\frac{E(1-\\nu)}{\\rho(1+\\nu)(1-2\\nu)}} $$\n\n按照问题的指示，我们将沿狭长薄片最小尺寸 $\\ell_{\\min}$ 的动力学建模为一维质量-弹簧链。对于采用集中质量的线性有限元，半离散运动方程的色散分析表明，网格所支持的最高频率 $\\omega_{\\max}$ 出现在最短可表示波长 $\\lambda_{\\text{grid}} = 2\\ell$ 处：\n$$ \\omega_{\\max} = \\frac{2c}{\\ell} $$\n其中 $c$ 是连续介质波速，$\\ell$ 是单元长度。显式中心差分时间积分格式是稳定的，当且仅当时间步长 $\\Delta t$ 满足以下条件：\n$$ \\Delta t \\le \\frac{2}{\\omega_{\\max}} = \\frac{\\ell}{c} $$\n\n根据问题陈述，稳定性由狭长子单元决定。因此，特征长度 $\\ell$ 是狭长薄片的最小尺寸 $\\ell_{\\min}$。波速 $c$ 必须是材料中最快的波速，即P波速度 $v_p$。所以，临界时间步长上界为：\n$$ \\Delta t_{\\mathrm{crit}} = \\frac{\\ell_{\\min}}{v_p} $$\n将 $v_p$ 的表达式代入，我们得到上界的最终解析表达式：\n$$ \\Delta t_{\\mathrm{crit}} = \\ell_{\\min} \\sqrt{\\frac{\\rho(1+\\nu)(1-2\\nu)}{E(1-\\nu)}} $$\n\n现在我们将给定的数值代入公式中。\n-   $E = 40\\,\\mathrm{GPa} = 40 \\times 10^9\\,\\mathrm{Pa}$\n-   $\\nu = 0.25$\n-   $\\rho = 2600\\,\\mathrm{kg/m^{3}}$\n-   $\\ell_{\\min} = 0.50\\,\\mathrm{mm} = 0.50 \\times 10^{-3}\\,\\mathrm{m}$\n\n首先，我们计算P波速度 $v_p$：\n$$ v_p = \\sqrt{\\frac{(40 \\times 10^9\\,\\mathrm{Pa})(1-0.25)}{(2600\\,\\mathrm{kg/m^3})(1+0.25)(1-2 \\times 0.25)}} = \\sqrt{\\frac{30 \\times 10^9}{1625}}\\,\\mathrm{m/s} \\approx 4296.6892\\,\\mathrm{m/s} $$\n接下来，我们计算临界时间步长 $\\Delta t_{\\mathrm{crit}}$：\n$$ \\Delta t_{\\mathrm{crit}} = \\frac{\\ell_{\\min}}{v_p} = \\frac{0.50 \\times 10^{-3}\\,\\mathrm{m}}{4296.6892\\,\\mathrm{m/s}} \\approx 1.16368 \\times 10^{-7}\\,\\mathrm{s} $$\n最后，我们将结果转换为微秒（$1\\,\\mu\\mathrm{s} = 10^{-6}\\,\\mathrm{s}$）并按要求四舍五入到四位有效数字：\n$$ \\Delta t_{\\mathrm{crit}} = 0.116368\\,\\mu\\mathrm{s} \\approx 0.1164\\,\\mu\\mathrm{s} $$", "answer": "$$\\boxed{0.1164}$$", "id": "3590742"}]}