{"hands_on_practices": [{"introduction": "在许多由表面张力或几何流驱动的界面演化问题中，精确计算曲率至关重要。本练习聚焦于数值实现中的一个关键环节：在边界处保持计算精度。它演示了如何运用泰勒级数分析，为诺伊曼（Neumann）边界条件设计一个“虚拟节点”模板，从而确保离散曲率计算达到二阶精度。掌握此技术 [@problem_id:3607078] 对于开发稳健的数值求解器，避免由边界引入伪振荡或误差至关重要。", "problem": "在计算地球物理学中，诸如岩浆前缘或盐水入侵舌之类的移动界面通常由一个标量水平集函数 $\\phi(x,y)$ 来表示，其零水平集描绘了前进的边界。该水平集的平均曲率 $\\kappa$ 定义为单位法向量场 $\\,\\mathbf{n} = \\nabla \\phi / |\\nabla \\phi|\\,$ 的散度，即 $\\kappa = \\nabla \\cdot \\mathbf{n}$。在不可渗透壁附近精确计算 $\\kappa$ 需要谨慎处理边界条件和虚拟节点模板，以使离散近似保持二阶精度。\n\n考虑一个二维笛卡尔网格，在 $y$ 方向上的间距均匀为 $h$，在 $y=0$ 处有一堵墙，内部节点位于 $y_j = j h$（$j \\geq 0$）。设 $\\phi$ 是光滑的，并且在墙附近的局部邻域内，其形式为\n$$\n\\phi(x,y) = y + a y^{2} + s x,\n$$\n其中常数 $a$ 和 $s$ 分别表示在垂直于墙壁方向上的局部二次变化和在平行于墙壁方向上的均匀梯度。这个通用的局部模型旨在揭示曲率对垂直于墙壁方向的二阶导数的敏感性以及平行于墙壁方向的梯度的作用。\n\n为了在墙壁节点 $(x_i,y_0)$ 处使用二阶中心差分来近似 $\\kappa$，需要一个位于 $y=-h$ 处的虚拟值 $\\phi_{i,-1}$。假设在 $y=0$ 处施加了垂直于墙壁的 Neumann 边界条件：\n$$\n\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{y=0} = g,\n$$\n其中 $g$ 等于给定 $\\phi$ 的精确值 $\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{y=0}$。提出一族形式如下的单虚拟节点 Neumann 模板：\n$$\n\\phi_{i,-1} = \\phi_{i,1} - m\\, h\\, g,\n$$\n其中 $m$ 是一个待定常数，其取值需确保从 $\\phi$ 计算出的在 $(x_i,y_0)$ 处的离散曲率 $\\kappa$ 在 $h$ 上保持二阶精度。\n\n从几何定义 $\\kappa = \\nabla \\cdot \\left( \\nabla \\phi / |\\nabla \\phi| \\right)$ 出发，并在 $x$ 和 $y$ 方向上均使用二阶中心差分，分析上述 Neumann 虚拟节点模板对曲率计算所需的离散的、垂直于墙壁方向的二阶导数的影响。对于给定的局部模型 $\\phi(x,y) = y + a y^{2} + s x$，推导标量 $m$ 的唯一值，该值可以消除 $O(h^{-1})$ 污染，并确保在墙壁节点处的离散曲率具有二阶精度。\n\n将 $m$ 的最终答案表示为一个实数。无需四舍五入。无需单位。", "solution": "该问题要求我们确定 Neumann 边界条件的虚拟节点模板中的常数 `$m$` 的值，使得平均曲率 `$\\kappa$` 的有限差分近似在墙壁处具有二阶精度。\n\n水平集 `$\\phi(x,y)=C$` 的平均曲率 `$\\kappa$` 由单位法向量 `$\\mathbf{n} = \\nabla \\phi / |\\nabla \\phi|$` 的散度给出。其完整表达式为：\n$$\n\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right) = \\frac{\\phi_{xx} \\phi_y^2 - 2 \\phi_x \\phi_y \\phi_{xy} + \\phi_{yy} \\phi_x^2}{(\\phi_x^2 + \\phi_y^2)^{3/2}}\n$$\n其中下标表示偏导数（例如，`$\\phi_x = \\frac{\\partial \\phi}{\\partial x}$`，`$\\phi_{yy} = \\frac{\\partial^2 \\phi}{\\partial y^2}$`）。\n\n我们被要求在墙壁节点 `$(x_i, y_0)$`（其中 `$y_0=0$`）处评估 `$\\kappa$` 的离散近似。问题指定使用二阶中心差分。主要挑战在于在边界 `$y=0$` 处近似导数，这需要在域外的“虚拟”节点处有一个值 `$\\phi_{i,-1} = \\phi(x_i, -h)$`。\n\n所提供的水平集函数局部模型为：\n$$\n\\phi(x,y) = y + a y^{2} + s x\n$$\n在 `$y=0$` 处的 Neumann 边界条件是 `$\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{y=0} = g$`。我们可以从给定的 `$\\phi(x,y)$` 精确计算出 `$g$`：\n$$\n\\frac{\\partial \\phi}{\\partial y} = 1 + 2ay\n$$\n$$\ng = \\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{y=0} = 1 + 2a(0) = 1\n$$\n\n所提出的虚拟节点模板为：\n$$\n\\phi_{i,-1} = \\phi_{i,1} - m h g\n$$\n由于 `$g=1$`，上式简化为 `$\\phi_{i,-1} = \\phi_{i,1} - m h$`。\n\n问题指出，离散曲率中的 `$O(h^{-1})$` 污染源于垂直于墙壁的二阶导数 `$\\phi_{yy}$`。让我们来分析在墙壁节点 `$(x_i, y_0=0)$` 处 `$\\phi_{yy}$` 的中心差分近似。令 `$\\tilde{\\phi}_{yy}$` 表示此离散近似。\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\frac{\\phi(x_i, h) - 2\\phi(x_i, 0) + \\phi(x_i, -h)}{h^2} = \\frac{\\phi_{i,1} - 2\\phi_{i,0} + \\phi_{i,-1}}{h^2}\n$$\n将虚拟节点模板 `$\\phi_{i,-1} = \\phi_{i,1} - m h g$` 代入此表达式：\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\frac{\\phi_{i,1} - 2\\phi_{i,0} + (\\phi_{i,1} - m h g)}{h^2} = \\frac{2\\phi_{i,1} - 2\\phi_{i,0} - m h g}{h^2}\n$$\n为了分析此近似的精度，我们在点 `$(x_i, 0)$` 周围对 `$\\phi_{i,1} = \\phi(x_i, h)$` 进行泰勒级数展开：\n$$\n\\phi(x_i, h) = \\phi(x_i, 0) + h \\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{(x_i,0)} + \\frac{h^2}{2} \\left.\\frac{\\partial^2 \\phi}{\\partial y^2}\\right|_{(x_i,0)} + O(h^3)\n$$\n使用记法 `$\\phi_{i,0} = \\phi(x_i, 0)$`，`$\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{(x_i,0)} = g$` 和 `$\\left.\\frac{\\partial^2 \\phi}{\\partial y^2}\\right|_{(x_i,0)} = \\phi_{yy}(x_i,0)$`，我们得到：\n$$\n\\phi_{i,1} = \\phi_{i,0} + h g + \\frac{h^2}{2}\\phi_{yy}(x_i,0) + O(h^3)\n$$\n现在，将此展开式代回 `$\\tilde{\\phi}_{yy}$` 的表达式中：\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\frac{2\\left(\\phi_{i,0} + h g + \\frac{h^2}{2}\\phi_{yy}(x_i,0) + O(h^3)\\right) - 2\\phi_{i,0} - m h g}{h^2}\n$$\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\frac{2\\phi_{i,0} + 2hg + h^2\\phi_{yy}(x_i,0) - 2\\phi_{i,0} - mhg + O(h^3)}{h^2}\n$$\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\frac{(2-m)hg + h^2\\phi_{yy}(x_i,0) + O(h^3)}{h^2}\n$$\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\phi_{yy}(x_i,0) + \\frac{(2-m)g}{h} + O(h)\n$$\n二阶导数的精确值是 `$\\phi_{yy}(x_i,0)$`。我们近似的误差为 `$\\tilde{\\phi}_{yy}(x_i, 0) - \\phi_{yy}(x_i,0) = \\frac{(2-m)g}{h} + O(h)$`。\n\n此表达式清楚地显示了一个 `$O(h^{-1})$` 阶的误差项，这正是问题中提到的污染。除非将其消除，否则当网格间距 `$h$` 细化时，该项将导致数值解发散。要消除此项，其系数必须为零：\n$$\n(2-m)g = 0\n$$\n正如我们计算的，`$g=1$`。由于 `$g \\neq 0$`，我们必须有：\n$$\n2 - m = 0 \\implies m = 2\n$$\n这是消除 `$O(h^{-1})$` 污染的 `$m$` 的唯一值。\n当 `$m=2$` 时，二阶导数的近似变为 `$\\tilde{\\phi}_{yy}(x_i, 0) = \\phi_{yy}(x_i,0) + O(h)`，这是一个一阶精度的近似。\n\n对于特定的 `$\\phi(x,y)=y+ay^2+sx$`，我们有 `$\\phi_{yyy} = 0$`，所以 `$\\phi_{i,1}$` 的泰勒展开终止，`$O(h^3)$` 项为零。这使得当 `$m=2$` 时，`$\\phi_{yy}$` 的近似是精确的：`$\\tilde{\\phi}_{yy} = \\phi_{yy} = 2a$`。此外，对于这个特定的多项式，`$\\phi_x, \\phi_{xx}, \\phi_{xy}` 的中心差分近似也是精确的。当 `$m=2$` 时，近似 `$\\tilde{\\phi}_y = \\frac{\\phi_{i,1}-\\phi_{i,-1}}{2h} = \\frac{mhg}{2h} = \\frac{2(1)(1)}{2}=1$` 也是精确的。由于曲率公式中的所有导数都被精确近似，离散曲率 `$\\tilde{\\kappa}$` 将等于精确曲率 `$\\kappa$`。零误差自然是 `$O(h^2)$`，因此满足了二阶精度的要求。\n\n关键步骤，也是问题的明确要求，是消除 `$O(h^{-1})$` 项，这唯一地确定了 `$m$`。\n`$m$` 的值是 `$2$`。", "answer": "$$\\boxed{2}$$", "id": "3607078"}, {"introduction": "界面捕捉方法的一个主要优势是其能够处理跨越界面的材料属性不连续性。本实践将虚拟流体法（Ghost-Fluid Method, GFM）应用于一个稳态热传导问题，其中热导率在一个静止界面上发生跳变。您将基于物理原理推导正确的通量条件，并实现一个有限体积求解器来计算温度分布。通过构建求解器并与精确解进行验证 [@problem_id:3607108]，您将获得如何将物理跳跃条件优雅地融入离散数值框架的实践经验。", "problem": "考虑一个空间坐标为 $x \\in [0,L]$ 的一维线段上的稳态热传导问题。该材料的热导率 $k(x)$ 在界面位置 $x=s$ 处存在不连续性，其形式为：\n$$\nk(x) = \\begin{cases} k_{-} & \\text{如果 } x  s \\\\ k_{+}  \\text{如果 } x > s \\end{cases}\n$$\n其中 $k_{-} > 0$ 和 $k_{+} > 0$ 是给定的常数。温度场 $T(x)$ 由稳态热传导方程 $\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right)=0$ 控制，并满足边界条件 $T(0)=T_0$ 和 $T(L)=T_L$。\n\n您的任务是实现一个基于有限体积法的数值求解器，并使用虚拟流体法（Ghost-Fluid Method, GFM）来精确处理界面 $x=s$ 处的通量。具体来说，您需要为横跨界面的控制体面推导一个有效的传导系数。\n\n使用您的求解器，为下面提供的一系列测试用例计算数值解，并报告每个用例中数值解与精确解析解之间的最大绝对误差 $\\max_i |T_i - T_{\\text{exact}}(x_i)|$。\n\n测试用例在 Python 答案代码中提供。", "solution": "用户提供的问题是一个有效的稳态热传导边值问题。它在科学上是合理的、适定的、客观的，并且包含了进行唯一求解所需的所有必要信息。\n\n### 1. 理论框架\n\n#### 1.1. 精确解析解\n该问题描述了一维稳态热传导，其控制方程为 $\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right)=0$。对该方程积分一次可知，热通量 $q(x) = -k(x)\\frac{dT}{dx}$ 在整个区域 $x \\in [0, L]$ 内必须是恒定的。设此恒定通量为 $q_c$。\n\n热导率 $k(x)$ 是分段常数，在界面 $x=s$ 处存在不连续性：\n$$\nk(x) = \\begin{cases} k_{-}  x  s \\\\ k_{+}  x > s \\end{cases}\n$$\n对傅里叶定律 $dT/dx = -q_c/k(x)$ 积分，得到一个分段线性的温度分布。\n对于 $x \\in [0, s]$，应用边界条件 $T(0)=T_0$：\n$$ T(x) = T_0 - \\frac{q_c}{k_{-}}x $$\n界面处的温度为 $T(s) = T_0 - \\frac{q_c s}{k_{-}}$。由于温度的连续性，该值被用作第二个区域的起始点。\n对于 $x \\in [s, L]$：\n$$ T(x) = T(s) - \\frac{q_c}{k_{+}}(x-s) = \\left(T_0 - \\frac{q_c s}{k_{-}}\\right) - \\frac{q_c}{k_{+}}(x-s) $$\n应用边界条件 $T(L)=T_L$：\n$$ T_L = T_0 - q_c \\left( \\frac{s}{k_{-}} + \\frac{L-s}{k_{+}} \\right) $$\n括号中的项是复合材料的总热阻，即两个部分串联热阻之和：$R_{total} = \\frac{s}{k_{-}} + \\frac{L-s}{k_{+}}$。\n求解恒定通量 $q_c$：\n$$ q_c = - \\frac{T_L - T_0}{R_{total}} = - \\frac{T_L - T_0}{\\frac{s}{k_{-}} + \\frac{L-s}{k_{+}}} $$\n已知 $q_c$ 后，即可计算任意点的精确温度 $T_{\\mathrm{exact}}(x)$。这可作为我们数值解的基准。\n\n#### 1.2. 鬼点法 (GFM) 与界面通量\n题目要求我们使用 GFM 方法推导跨越控制体面的通量，该面横跨界面。考虑一个均匀网格 $x_i = i\\Delta x$ 和两个相邻节点 $x_j$ 和 $x_{j+1}$，使得界面位于它们之间：$x_j  s  x_{j+1}$。在 $x=s$ 处，温度和通量连续性的物理原理必须成立。\n\n假设温度分布是局部线性的，恒定通量 $q_c$ 可以从界面的左右两侧近似得到：\n来自左侧的通量，使用位于 $x_j$ 的节点温度 $T_j$ 和位于 $x=s$ 的未知界面温度 $T_s$：\n$$ q_c \\approx -k_{-} \\frac{T_s - T_j}{s - x_j} $$\n来自右侧的通量，使用位于 $x_{j+1}$ 的节点温度 $T_{j+1}$ 和位于 $x=s$ 的 $T_s$：\n$$ q_c \\approx -k_{+} \\frac{T_{j+1} - T_s}{x_{j+1} - s} $$\n通过令这两个表达式相等来强制实现通量连续性，从而可以求解界面温度 $T_s$：\n$$ k_{-} \\frac{T_s - T_j}{s - x_j} = k_{+} \\frac{T_{j+1} - T_s}{x_{j+1} - s} \\implies T_s = \\frac{k_{-}(x_{j+1}-s)T_j + k_{+}(s-x_j)T_{j+1}}{k_{-}(x_{j+1}-s) + k_{+}(s-x_j)} $$\n将此 $T_s$ 代回任一通量近似式，即可得到节点 $j$ 和 $j+1$ 之间的期望通量，我们记为 $q_{j+1/2}$：\n$$ q_{j+1/2} = -k_{-} \\frac{1}{s-x_j} \\left( \\frac{k_{-}(x_{j+1}-s)T_j + k_{+}(s-x_j)T_{j+1}}{k_{-}(x_{j+1}-s) + k_{+}(s-x_j)} - T_j \\right) $$\n经过代数简化后，得到：\n$$ q_{j+1/2} = - \\left( \\frac{k_{-}k_{+}}{k_{+}(s-x_j) + k_{-}(x_{j+1}-s)} \\right) (T_{j+1} - T_j) $$\n这个表达式等效于一个串联热阻模型。乘以温差的分数项的分母是节点间的总热阻：$R_{j,j+1} = \\frac{s-x_j}{k_{-}} + \\frac{x_{j+1}-s}{k_{+}}$。数值通量则为 $q_{j+1/2} = -\\frac{T_{j+1}-T_j}{R_{j,j+1}}$。该单元对的有效传导系数为 $C^{\\text{eff}}_{j+1/2} = 1/R_{j,j+1}$。\n\n### 2. 数值实现\n\n我们使用以节点为中心的有限体积法。对于内部节点 $i$（从 $i=1$ 到 $N-2$），控制体为 $[x_{i-1/2}, x_{i+1/2}]$，其中 $x_{i\\pm1/2} = (x_i+x_{i\\pm1})/2$。对守恒定律在该体积上积分，得到通量平衡：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{d}{dx}q(x) dx = q(x_{i+1/2}) - q(x_{i-1/2}) = 0 $$\n面上的通量近似为 $q_{i+1/2} = -C_{i+1/2}(T_{i+1}-T_i)$，其中 $C_{i+1/2}$ 是节点 $i$ 和 $i+1$ 之间的传导系数。\n节点 $i$ 的方程为：\n$$ -C_{i-1/2}(T_i - T_{i-1}) - (-C_{i+1/2}(T_{i+1} - T_i)) = 0 $$\n$$ C_{i-1/2}T_{i-1} - (C_{i-1/2} + C_{i+1/2})T_i + C_{i+1/2}T_{i+1} = 0 $$\n传导系数 $C_{i+1/2}$ 取决于界面 $s$ 是否位于区间 $(x_i, x_{i+1})$ 内：\n- **无界面：** 如果区间 $(x_i, x_{i+1})$ 内的热导率 $k$ 为常数（如果 $x_{i+1/2}  s$ 则为 $k_{-}$，如果 $x_{i+1/2} > s$ 则为 $k_{+}$），则标准传导系数为 $C_{i+1/2} = k / \\Delta x$。\n- **存在界面：** 如果 $x_i  s  x_{i+1}$，则传导系数为从 GFM 推导出的有效传导系数：$C_{i+1/2} = C^{\\text{eff}}_{i+1/2} = \\left(\\frac{s-x_i}{k_{-}} + \\frac{x_{i+1}-s}{k_{+}}\\right)^{-1}$。\n\n这些针对 $i=1, \\dots, N-2$ 的方程，连同狄利克雷边界条件 $T_0=T_0$ 和 $T_{N-1}=T_L$，构成了一个用于求解节点温度向量 $\\mathbf{T} = [T_0, \\dots, T_{N-1}]^T$ 的 $N \\times N$ 三对角线性系统 $A\\mathbf{T}=\\mathbf{b}$。求解该系统即可得到数值解。\n\n### 3. 误差计算\n由于数值格式的构建是连续问题（其解为分段线性）的精确模拟，因此在节点处评估的数值解应与在相同节点处评估的精确解析解相同，误差仅限于机器浮点精度。计算最大绝对误差 $\\max_i |T_i - T_{\\mathrm{exact}}(x_i)|$ 以验证这一点。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (happy path)\n        {'L': 1.0, 'N': 129, 'k_minus': 1.0, 'k_plus': 5.0, 's': 0.37, 'T0': 0.0, 'T_L': 1.0},\n        # Test 2 (interface exactly at a node)\n        {'L': 1.0, 'N': 129, 'k_minus': 1.0, 'k_plus': 10.0, 's': 0.5, 'T0': 100.0, 'T_L': 300.0},\n        # Test 3 (extreme conductivity contrast)\n        {'L': 1.0, 'N': 257, 'k_minus': 0.1, 'k_plus': 1000.0, 's': 0.8, 'T0': 10.0, 'T_L': 11.0},\n        # Test 4 (near-face intersection and k-=k+)\n        {'L': 1.0, 'N': 129, 'k_minus': 2.0, 'k_plus': 2.0, 's': 0.499, 'T0': 0.0, 'T_L': 1.0},\n        # Test 5 (interface near boundary)\n        {'L': 1.0, 'N': 129, 'k_minus': 0.5, 'k_plus': 3.5, 's': 0.02, 'T0': 0.0, 'T_L': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = compute_error_for_case(**case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_error_for_case(L, N, k_minus, k_plus, s, T0, T_L):\n    \"\"\"\n    Computes the maximum absolute error for a single test case.\n    \"\"\"\n    # 1. Setup Grid\n    dx = L / (N - 1)\n    x = np.linspace(0.0, L, N)\n\n    # 2. Assemble Linear System Ax = b\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n\n    # Boundary Conditions\n    A[0, 0] = 1.0\n    b[0] = T0\n    A[N - 1, N - 1] = 1.0\n    b[N - 1] = T_L\n\n    # Function to get conductance between nodes i and i+1\n    def get_conductance(i):\n        # Check if interface s is strictly within the interval (x[i], x[i+1])\n        if x[i]  s and x[i+1] > s:\n            # GFM / Series Resistance model for interface-straddling cell\n            dist_minus = s - x[i]\n            dist_plus = x[i+1] - s\n            resistance = dist_minus / k_minus + dist_plus / k_plus\n            return 1.0 / resistance\n        else:\n            # Standard model for cell with constant conductivity\n            # Use conductivity at the face midpoint to decide which k to use.\n            mid_point = (x[i] + x[i+1]) / 2.0\n            k = k_minus if mid_point  s else k_plus\n            return k / dx\n\n    # Interior Nodes: assemble equations from i=1 to N-2\n    for i in range(1, N - 1):\n        # Conductance for flux q_{i-1/2} (between i-1 and i)\n        C_left = get_conductance(i - 1)\n        \n        # Conductance for flux q_{i+1/2} (between i and i+1)\n        C_right = get_conductance(i)\n        \n        A[i, i - 1] = C_left\n        A[i, i] = -(C_left + C_right)\n        A[i, i + 1] = C_right\n        b[i] = 0.0\n\n    # 3. Solve for Numerical Temperature\n    T_num = np.linalg.solve(A, b)\n\n    # 4. Calculate Exact Solution\n    res_minus = s / k_minus if s > 0 else 0.0\n    res_plus = (L - s) / k_plus if s  L else 0.0\n    total_resistance = res_minus + res_plus\n    \n    # Avoid division by zero if total_resistance is 0 (e.g., L=0)\n    q_c = -(T_L - T0) / total_resistance if total_resistance > 0 else 0.0\n\n    # Vectorized calculation of exact temperature at all grid points\n    resistance_at_x = np.where(x = s, x / k_minus, s / k_minus + (x - s) / k_plus)\n    T_exact = T0 - q_c * resistance_at_x\n    \n    # 5. Compute Maximum Absolute Error\n    max_error = np.max(np.abs(T_num - T_exact))\n    \n    return max_error\n\n# Execute the solver\nsolve()\n```", "id": "3607108"}, {"introduction": "水平集方法和相场方法各有优劣，尤其是在处理界面拓扑变化方面表现出显著差异。本模拟练习通过模拟两个涡环的碰撞与潜在合并，对这两种方法进行了直接比较。您将分别为锐利界面的水平集平流方程和弥散界面的平流艾伦-凯恩（Allen-Cahn）方程实现求解器。通过观察不同的演化结果 [@problem_id:2408605]，您将对两种方法隐式处理拓扑变化的特性建立直观理解，并领会相场模型中的反应-扩散项在促进平滑拓扑过渡中所扮演的角色。", "problem": "考虑在一个周期性方形域上的两种替代隐式界面模型，这些模型通过在二维平面中传输闭合曲线来近似两个同轴涡环横截面的碰撞。设计算域为方形区域 $\\left[-1,1\\right]\\times\\left[-1,1\\right]$，其在两个方向上都具有周期性边界。设 $N\\times N$ 为均匀网格分辨率，网格间距为 $\\Delta x=\\Delta y=\\dfrac{2}{N}$。定义一个空间变化但与时间无关的速度场 $\\mathbf{u}(x,y)=\\left(u_x(x),u_y(x)\\right)$，其中\n$$\nu_x(x)=-U\\tanh\\!\\left(\\dfrac{x}{\\delta}\\right),\\quad u_y(x)=0,\n$$\n其中 $U0$ 和 $\\delta0$ 是给定的常数。两个初始圆形界面代表两个相同涡环的横截面：分别是半径为 $R$，中心位于 $\\left(-a,0\\right)$ 和 $\\left(+a,0\\right)$ 的圆，其中 $0Ra1$。\n\n您必须实现以下两种界面描述，并将其在时间上推进到指定的最终时间 $T$：\n\n1. 水平集（Level-set）公式。设 $\\phi(x,y,t)$ 是一个标量场，其零水平集代表界面，其负值区域代表“涡核”集的内部。其演化由线性平流方程给出\n$$\n\\partial_t \\phi + \\mathbf{u}\\cdot\\nabla \\phi = 0,\n$$\n初始条件为 $\\phi(x,y,0)=d(x,y)$，等于到两个初始圆并集的有符号距离，即，\n$$\nd(x,y)=\\min\\!\\Big(\\sqrt{(x+a)^2+y^2}-R,\\;\\sqrt{(x-a)^2+y^2}-R\\Big),\n$$\n在任一圆内部 $d(x,y)0$。\n\n2. 相场（Phase-field）公式（平流 Allen–Cahn）。设 $c(x,y,t)$ 是一个标量序参数，它近似一个由 $\\epsilon0$ 控制厚度的弥散界面。其演化由平流 Allen–Cahn 方程给出\n$$\n\\partial_t c + \\mathbf{u}\\cdot\\nabla c = \\dfrac{1}{\\tau}\\Big(\\epsilon^2\\nabla^2 c - f'(c)\\Big),\n$$\n其中 $\\tau0$ 是一个弛豫时间，且 $f(c)=\\dfrac{1}{2}c^2(1-c)^2$，因此 $f'(c)=c(1-c)(1-2c)$。初始条件是同样两个圆的光滑弥散表示，\n$$\nc(x,y,0)=\\dfrac{1}{2}\\left(1-\\tanh\\!\\left(\\dfrac{d(x,y)}{\\sqrt{2}\\,\\epsilon}\\right)\\right),\n$$\n使得在内部 $c\\approx 1$ 而在外部 $c\\approx 0$。\n\n对于每种公式，在时间 $t=T$ 时，定义二元“核心”集\n$$\n\\Omega_{\\mathrm{LS}}(T)=\\{(x,y):\\phi(x,y,T)0\\},\\qquad \\Omega_{\\mathrm{PF}}(T)=\\{(x,y):c(x,y,T)\\tfrac{1}{2}\\}.\n$$\n在周期性域上，使用带周期性回绕的 $8$-连通性来定义二元集的连通分量数。为减少虚假的数值斑点，在计数分量之前，丢弃任何面积（以网格点数计）严格小于 $A_{\\min}$ 的连通分量，其中\n$$\nA_{\\min}=\\left\\lfloor \\theta N^2 \\right\\rfloor,\\quad \\theta=0.002.\n$$\n\n您的任务是为下面测试套件中的每个参数集计算整数对 $\\left(C_{\\mathrm{LS}},C_{\\mathrm{PF}}\\right)$，其中 $C_{\\mathrm{LS}}$ 是 $\\Omega_{\\mathrm{LS}}(T)$ 的连通分量数，$C_{\\mathrm{PF}}$ 是 $\\Omega_{\\mathrm{PF}}(T)$ 的连通分量数。\n\n测试套件（每个案例指定 $\\left(N,R,a,U,\\delta,\\epsilon,\\tau,T\\right)$）：\n\n- 案例 1：$\\left(96,\\;0.22,\\;0.34,\\;0.40,\\;0.10,\\;0.03,\\;1.0,\\;0.295\\right)$。\n- 案例 2：$\\left(96,\\;0.22,\\;0.34,\\;0.20,\\;0.10,\\;0.02,\\;1.0,\\;0.12\\right)$。\n- 案例 3：$\\left(96,\\;0.22,\\;0.34,\\;0.50,\\;0.10,\\;0.03,\\;1.0,\\;0.35\\right)$。\n\n所有量都是无量纲的。如果在您的实现中出现任何角度，必须以弧度为单位。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的六个整数列表，顺序如下\n$$\n\\left[C_{\\mathrm{LS}}^{(1)},C_{\\mathrm{PF}}^{(1)},C_{\\mathrm{LS}}^{(2)},C_{\\mathrm{PF}}^{(2)},C_{\\mathrm{LS}}^{(3)},C_{\\mathrm{PF}}^{(3)}\\right],\n$$\n对应于测试套件中的案例 1、2 和 3。例如，形如 $\\left[2,1,2,2,1,1\\right]$ 的输出表示在案例 1 中水平集有两个分量，相场有一个分量；在案例 2 中两者各有二个分量；在案例 3 中两者各有一个分量。", "solution": "问题陈述经过验证，被认为是科学上可靠、适定且完整的。它描述了计算工程中的一个标准数值实验，比较了两种经典的界面追踪方法——水平集模型和相场模型。所有参数、方程以及初始和边界条件都得到了明确的指定，从而可以得到唯一的解。该问题是有效的。\n\n该解决方案要求在二维周期性域上对两个偏微分方程（PDE）进行数值积分。控制方程是水平集场 $\\phi$ 的线性平流方程和相场序参数 $c$ 的平流 Allen-Cahn 方程。\n\n首先，建立一个计算网格。域 $\\left[-1,1\\right]\\times\\left[-1,1\\right]$ 被离散化为一个 $N\\times N$ 点的均匀网格，网格间距为 $\\Delta x = \\Delta y = 2/N$。网格坐标定义为 $x_i = -1 + i\\Delta x$ 和 $y_j = -1 + j\\Delta y$，其中 $i,j \\in \\{0, \\dots, N-1\\}$。速度场 $\\mathbf{u}(x,y)$ 是纯水平的，$u_x(x)=-U\\tanh(x/\\delta)$，$u_y=0$，在每个网格点 $x_i$ 处进行求值。\n\n偏微分方程中的空间算子使用尊重周期性边界条件的有限差分法进行离散化。使用 `numpy.roll` 来移动网格数据，可以高效地处理周期性。\n平流项 $\\mathbf{u}\\cdot\\nabla\\psi = u_x(x)\\partial_x\\psi$ 使用一阶迎风格式进行离散化。这一选择对于在平流主导问题中保持数值稳定性至关重要。该格式在速度 $u_x$ 为正时使用后向差分计算空间导数 $\\partial_x\\psi$，在 $u_x$ 为负时使用前向差分。\nAllen-Cahn 方程中的拉普拉斯算子 $\\nabla^2 c$ 使用标准的五点模板进行离散化，这是一种二阶精度的中心差分近似。\n\n场 $\\phi(x,y,t)$ 和 $c(x,y,t)$ 的时间演化是通过将半离散化方程（一个关于时间的常微分方程组）从 $t=0$ 积分到最终时间 $T$ 来实现的。由于其高精度和良好的稳定性，采用四阶 Runge-Kutta (RK4) 方法进行此积分。时间步长 $\\Delta t$ 的选择必须满足所有参数集下平流和扩散过程的 Courant-Friedrichs-Lewy (CFL) 稳定性条件。一个保守的全局 $\\Delta t$ 是基于最严格的条件计算的：$\\Delta t \\le \\nu \\cdot \\min(\\Delta x/U_{max}, \\tau (\\Delta x)^2/(4\\epsilon_{min}^2))$，其中使用了一个安全因子 $\\nu  1$。\n\n单个测试案例的演化过程如下：\n1. 根据提供的初始条件公式在网格上初始化场 $\\phi_0 = \\phi(x,y,0)$ 和 $c_0 = c(x,y,0)$，这些公式基于到初始圆对的有符号距离函数 $d(x,y)$。\n2. 对于每个模型（水平集和相场），使用 RK4 格式在时间上向前积分，直到 $t=T$。\n3. 在 $t=T$ 时，通过应用指定的阈值：分别为 $\\phi(x,y,T)  0$ 和 $c(x,y,T) > 1/2$，创建二元核心集 $\\Omega_{\\mathrm{LS}}(T)$ 和 $\\Omega_{\\mathrm{PF}}(T)$。\n\n最后一步是计算每个二元集的连通分量数量，这受到两个关键约束：周期性边界和最小面积过滤器。\n标准的连通分量算法，如 `scipy.ndimage.label`，本身不处理周期性连接。因此，需要一个针对周期性域的正确实现。该过程如下：\n1. 对二元掩码应用具有 $8$-连通性的标准 `scipy.ndimage.label`，它为每个非周期性分量分配一个唯一的整数标签。\n2. 创建一个不相交集并（DSU）数据结构来追踪跨越周期性边界连接的标签的合并情况。\n3. 遍历域边界上的像素（例如，$x= -1$ 和 $y=-1$）。对于属于某个分量的每个像素，检查其在周期意义下的八个邻居。如果一个邻居属于具有不同标签的分量，则使用 DSU 的 `union` 操作合并这两个标签。\n4. 处理完所有边界像素后，DSU 结构包含了构成真正周期性分量的标签等价类。\n5. 通过将其所有构成标签的面积（像素数）相加来计算每个周期性分量的总面积。初始标签的像素数可以使用 `numpy.bincount` 高效地获得。\n6. 最后，计算总面积大于或等于最小面积阈值 $A_{\\min} = \\lfloor \\theta N^2 \\rfloor$ 的合并分量数量。这就得出了最终的分量计数 $C_{\\mathrm{LS}}$ 和 $C_{\\mathrm{PF}}$。\n\n对测试套件中提供的三个参数集中的每一个重复这整个过程，并将得到的六个整数格式化为所需的输出字符串。", "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the vortex collision problem for all test cases.\n    \"\"\"\n\n    # --- Data structure for periodic component merging ---\n    class DSU:\n        def __init__(self, n):\n            self.parent = list(range(n))\n        def find(self, i):\n            if self.parent[i] == i:\n                return i\n            self.parent[i] = self.find(self.parent[i])\n            return self.parent[i]\n        def union(self, i, j):\n            root_i = self.find(i)\n            root_j = self.find(j)\n            if root_i != root_j:\n                self.parent[root_j] = root_i\n\n    # --- Periodic connected component counting function ---\n    def count_components_periodic(mask, N, theta):\n        s = np.ones((3, 3), dtype=int)  # 8-connectivity\n        labeled_array, num_features = label(mask, structure=s, output=np.int32)\n\n        if num_features == 0:\n            return 0\n\n        dsu = DSU(num_features + 1)\n        \n        # Check connections across periodic boundaries (8-connectivity)\n        # Left-Right boundary\n        for i in range(N):\n            if mask[i, 0]:\n                label_left = labeled_array[i, 0]\n                # Neighbors of (i, 0) across the boundary are at x = -1 (N-1)\n                for i_offset in [-1, 0, 1]:\n                    ni = (i + i_offset + N) % N\n                    if mask[ni, -1]:\n                        dsu.union(label_left, labeled_array[ni, -1])\n        \n        # Top-Bottom boundary\n        for j in range(N):\n            if mask[0, j]:\n                label_top = labeled_array[0, j]\n                # Neighbors of (0, j) across the boundary are at y = -1 (N-1)\n                for j_offset in [-1, 0, 1]:\n                    nj = (j + j_offset + N) % N\n                    if mask[-1, nj]:\n                        dsu.union(label_top, labeled_array[-1, nj])\n\n        # Calculate areas of merged components\n        pixel_counts = np.bincount(labeled_array.ravel())\n        root_areas = {}\n        for i in range(1, num_features + 1):\n            if pixel_counts[i] > 0:\n                root = dsu.find(i)\n                if root not in root_areas:\n                    root_areas[root] = 0\n                root_areas[root] += pixel_counts[i]\n\n        # Filter by area\n        A_min = math.floor(theta * N**2)\n        valid_components = sum(1 for area in root_areas.values() if area >= A_min)\n        \n        return valid_components\n\n    # --- PDE Solver for a single case ---\n    def solve_single_case(params):\n        N, R, a, U, delta, epsilon, tau, T = params\n        theta = 0.002\n        \n        # Grid setup\n        dx = 2.0 / N\n        grid_pts = np.linspace(-1, 1, N, endpoint=False)\n        x, y = np.meshgrid(grid_pts, grid_pts)\n\n        # Velocity field\n        ux = -U * np.tanh(x / delta)\n\n        # Initial conditions\n        d = np.minimum(np.sqrt((x + a)**2 + y**2) - R, np.sqrt((x - a)**2 + y**2) - R)\n        phi0 = d\n        c0 = 0.5 * (1.0 - np.tanh(d / (np.sqrt(2.0) * epsilon)))\n        \n        # --- Spatial operators ---\n        inv_dx = 1.0 / dx\n        inv_dx2 = 1.0 / (dx**2)\n\n        def advection(field, u_field):\n            grad_fwd = (np.roll(field, -1, axis=1) - field) * inv_dx\n            grad_bwd = (field - np.roll(field, 1, axis=1)) * inv_dx\n            return np.where(u_field >= 0, u_field * grad_bwd, u_field * grad_fwd)\n\n        def laplacian(field):\n            return (np.roll(field, -1, axis=1) + np.roll(field, 1, axis=1) +\n                    np.roll(field, -1, axis=0) + np.roll(field, 1, axis=0) - 4 * field) * inv_dx2\n\n        # --- RHS of PDEs for RK4 ---\n        def rhs_ls(phi):\n            return -advection(phi, ux)\n\n        def rhs_pf(c):\n            f_prime = c * (1.0 - c) * (1.0 - 2.0 * c)\n            adv = advection(c, ux)\n            reaction_diffusion = (1.0 / tau) * (epsilon**2 * laplacian(c) - f_prime)\n            return -adv + reaction_diffusion\n            \n        # --- RK4 Time Stepper ---\n        def rk4_step(field, rhs_func, dt):\n            k1 = rhs_func(field)\n            k2 = rhs_func(field + 0.5 * dt * k1)\n            k3 = rhs_func(field + 0.5 * dt * k2)\n            k4 = rhs_func(field + dt * k3)\n            return field + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\n        # CFL-based time step\n        dt_adv = dx / U\n        dt_diff = tau * dx**2 / (4 * epsilon**2)\n        dt = 0.25 * min(dt_adv, dt_diff)\n        \n        # --- Time integration loop ---\n        # Level-Set\n        phi = np.copy(phi0)\n        t = 0.0\n        while t  T:\n            current_dt = min(dt, T - t)\n            phi = rk4_step(phi, rhs_ls, current_dt)\n            t += current_dt\n\n        # Phase-Field\n        c = np.copy(c0)\n        t = 0.0\n        while t  T:\n            current_dt = min(dt, T - t)\n            c = rk4_step(c, rhs_pf, current_dt)\n            t += current_dt\n        \n        # --- Component Counting ---\n        mask_ls = phi  0\n        mask_pf = c > 0.5\n        \n        C_LS = count_components_periodic(mask_ls, N, theta)\n        C_PF = count_components_periodic(mask_pf, N, theta)\n\n        return C_LS, C_PF\n\n    # --- Test Suite ---\n    test_cases = [\n        (96, 0.22, 0.34, 0.40, 0.10, 0.03, 1.0, 0.295),\n        (96, 0.22, 0.34, 0.20, 0.10, 0.02, 1.0, 0.12),\n        (96, 0.22, 0.34, 0.50, 0.10, 0.03, 1.0, 0.35),\n    ]\n\n    results = []\n    for params in test_cases:\n        C_LS, C_PF = solve_single_case(params)\n        results.extend([C_LS, C_PF])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2408605"}]}