{"hands_on_practices": [{"introduction": "率与状态摩擦（Rate-and-state friction, RSF）是理解地震周期和断层稳定性的关键理论框架。本练习通过分析系统对滑移速度突变的响应，探讨 RSF 的核心动力学——即时的“直接效应”和随时间演化的“状态演化效应”。通过亲手实现一个理想化的速度阶跃实验，您将为模拟复杂的地震序列建立起关于断层响应的基础直觉。[@problem_id:3581299]", "problem": "一个承受正应力 $\\sigma_n$ 的速率-状态摩擦（RSF）界面，其行为由一个本构关系所控制。该关系描述了摩擦系数 $\\mu(t)$，它依赖于滑动速率 $V(t)$ 和一个具有时间量纲的内部状态变量 $\\theta(t)$。采用 Dieterich-Ruina（老化）状态演化法则。使用以下基本且被广泛接受的初始定律：\n\n- 摩擦定律：$\\mu(t) = \\mu_\\star + a \\ln\\!\\left(\\dfrac{V(t)}{V_\\star}\\right) + b \\ln\\!\\left(\\dfrac{\\theta(t)\\,V_\\star}{D_c}\\right)$，其中 $\\mu_\\star$ 是在参考速率 $V_\\star$ 下的参考摩擦系数，$a$ 和 $b$ 是无量纲经验参数，$D_c$ 是具有长度量纲的特征滑动距离。\n- 状态变量的老化定律（一个常微分方程 (ODE)）：$\\dfrac{d\\theta}{dt} = 1 - \\dfrac{V(t)\\,\\theta(t)}{D_c}$。\n- 剪应力：$\\tau(t) = \\sigma_n\\,\\mu(t)$。\n\n考虑一个给定的速率阶跃历史：在时间 $t  0$ 时，界面以速率 $V_1$ 处于稳态；在 $t = 0$ 时，滑动速率阶跃至一个恒定值 $V_2$ 并保持该值直至 $t \\in [0, T_{\\text{end}}]$。假设系统在 $t=0^-$ 时处于稳态，这意味着初始条件为 $\\theta(0) = D_c / V_1$。仅以上述定律和定义为出发点，推导出在 $t \\in [0, T_{\\text{end}}]$ 区间内获得 $\\mu(t)$ 的计算步骤，并计算该区间内的累积应力降，其定义为 $\\Delta \\tau = \\tau(0^-) - \\tau(T_{\\text{end}})$，以帕斯卡（Pa）为单位表示。此处 $\\tau(0^-)=\\sigma_n\\,\\mu_{\\text{ss}}(V_1)$ 是速率阶跃前瞬间的稳态剪应力。所有速率必须严格为正。\n\n全文使用的物理单位：\n- 滑动速率 $V$ 的单位是米/秒（$\\text{m/s}$）。\n- 特征滑动距离 $D_c$ 的单位是米（$\\text{m}$）。\n- 时间 $t$ 的单位是秒（$\\text{s}$）。\n- 正应力 $\\sigma_n$ 的单位是帕斯卡（$\\text{Pa}$）。\n- 摩擦系数 $\\mu$ 是无量纲的。\n- 最终应力降 $\\Delta \\tau$ 必须以帕斯卡表示。\n\n您的程序必须为以下测试套件实现解决方案。每个测试用例是一个元组 $(a, b, D_c, \\sigma_n, \\mu_\\star, V_\\star, V_1, V_2, T_{\\text{end}})$，其值如下：\n- 用例 A（速率阶跃上升，速率弱化，短时瞬态）：\n  - $(a, b, D_c, \\sigma_n, \\mu_\\star, V_\\star, V_1, V_2, T_{\\text{end}}) = (\\,0.008,\\,0.012,\\,10^{-5},\\,5\\times 10^{7},\\,0.6,\\,10^{-6},\\,10^{-6},\\,10^{-3},\\,1\\,)$.\n- 用例 B（速率阶跃下降，速率弱化，长时瞬态）：\n  - $(a, b, D_c, \\sigma_n, \\mu_\\star, V_\\star, V_1, V_2, T_{\\text{end}}) = (\\,0.008,\\,0.012,\\,10^{-5},\\,5\\times 10^{7},\\,0.6,\\,10^{-6},\\,10^{-4},\\,10^{-6},\\,50\\,)$.\n- 用例 C（$a=b$ 情况下速率阶跃上升，稳态净变化为零）：\n  - $(a, b, D_c, \\sigma_n, \\mu_\\star, V_\\star, V_1, V_2, T_{\\text{end}}) = (\\,0.01,\\,0.01,\\,10^{-5},\\,5\\times 10^{7},\\,0.6,\\,10^{-6},\\,10^{-6},\\,10^{-3},\\,1\\,)$.\n\n对于每个用例，计算并报告以下三个量：\n- $\\mu(0^+)$，在 $t=0^+$ 时速率阶跃后的瞬时摩擦力值。\n- $\\mu(T_{\\text{end}})$，在结束时间的摩擦力值。\n- $\\Delta \\tau = \\tau(0^-) - \\tau(T_{\\text{end}})$，以帕斯卡为单位。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔的结果列表。对于每个用例，输出一个三元素列表 $[\\mu(0^+), \\mu(T_{\\text{end}}), \\Delta \\tau]$，每个浮点数四舍五入到六位小数，并将这三个用例的结果聚合到一个顶级列表中。例如，要求的格式为 $[[x_1,x_2,x_3],[y_1,y_2,y_3],[z_1,z_2,z_3]]$，不含任何额外的空格或文本。", "solution": "该问题在科学上是有效且适定的，其基础是计算地球物理学和地震学中常用的速率-状态摩擦模型的既定原理。我们可以继续对感兴趣的量进行形式推导。\n\n系统由三个基本定律描述：\n$1$. 摩擦定律：$\\mu(t) = \\mu_\\star + a \\ln\\left(\\dfrac{V(t)}{V_\\star}\\right) + b \\ln\\left(\\dfrac{\\theta(t)\\,V_\\star}{D_c}\\right)$。\n$2$. 状态演化定律（老化）：$\\dfrac{d\\theta}{dt} = 1 - \\dfrac{V(t)\\,\\theta(t)}{D_c}$。\n$3$. 剪应力定义：$\\tau(t) = \\sigma_n\\,\\mu(t)$。\n\n我们的目标是计算速率阶跃瞬间的摩擦系数 $\\mu(0^+)$、稍后时间的摩擦系数 $\\mu(T_{\\text{end}})$，以及该区间内的总应力降 $\\Delta \\tau = \\tau(0^-) - \\tau(T_{\\text{end}})$。\n\n首先，我们分析稳态（ss）条件，这对于定义系统的初始状态至关重要。在稳态下，所有时间导数均为零，因此 $\\dfrac{d\\theta}{dt} = 0$。根据状态演化定律，这意味着：\n$$1 - \\dfrac{V_{\\text{ss}}\\,\\theta_{\\text{ss}}}{D_c} = 0 \\implies \\theta_{\\text{ss}}(V) = \\dfrac{D_c}{V}$$\n状态变量的稳态值 $\\theta_{\\text{ss}}$ 与稳态速率 $V_{\\text{ss}}$ 成反比。将此代入摩擦定律，可得出稳态摩擦系数 $\\mu_{\\text{ss}}$ 作为速率 $V$ 的函数：\n$$ \\mu_{\\text{ss}}(V) = \\mu_\\star + a \\ln\\left(\\dfrac{V}{V_\\star}\\right) + b \\ln\\left(\\dfrac{(D_c/V)\\,V_\\star}{D_c}\\right) $$\n$$ \\mu_{\\text{ss}}(V) = \\mu_\\star + a \\ln\\left(\\dfrac{V}{V_\\star}\\right) + b \\ln\\left(\\dfrac{V_\\star}{V}\\right) = \\mu_\\star + (a-b)\\ln\\left(\\dfrac{V}{V_\\star}\\right) $$\n\n问题陈述系统在 $t  0$ 时以速率 $V_1$ 处于稳态。因此，在 $t=0$ 时状态变量的初始条件是：\n$$ \\theta(0) = \\theta_{\\text{ss}}(V_1) = \\dfrac{D_c}{V_1} $$\n阶跃前瞬间，$t=0^-$ 时的剪应力基于 $V_1$ 时的稳态摩擦：\n$$ \\tau(0^-) = \\sigma_n\\,\\mu_{\\text{ss}}(V_1) = \\sigma_n\\left[\\mu_\\star + (a-b)\\ln\\left(\\dfrac{V_1}{V_\\star}\\right)\\right] $$\n\n在 $t=0$ 时，速率瞬时阶跃至 $V_2$。状态变量 $\\theta$ 不能瞬时改变，因此 $\\theta(0^+) = \\theta(0^-) = D_c/V_1$。然而，摩擦系数 $\\mu$ 会立即响应 $V$ 的变化。为了求得 $\\mu(0^+)$，我们将 $V(0^+) = V_2$ 和 $\\theta(0) = D_c/V_1$ 代入摩擦定律：\n$$ \\mu(0^+) = \\mu_\\star + a \\ln\\left(\\dfrac{V_2}{V_\\star}\\right) + b \\ln\\left(\\dfrac{\\theta(0)\\,V_\\star}{D_c}\\right) $$\n$$ \\mu(0^+) = \\mu_\\star + a \\ln\\left(\\dfrac{V_2}{V_\\star}\\right) + b \\ln\\left(\\dfrac{(D_c/V_1)\\,V_\\star}{D_c}\\right) = \\mu_\\star + a \\ln\\left(\\dfrac{V_2}{V_\\star}\\right) - b \\ln\\left(\\dfrac{V_1}{V_\\star}\\right) $$\n该表达式给出了第一个所求量 $\\mu(0^+)$。这被称为速率变化的“直接效应”。\n\n对于 $t > 0$，速率保持恒定在 $V(t) = V_2$。状态演化定律变成了一个关于 $\\theta(t)$ 的一阶线性常微分方程：\n$$ \\dfrac{d\\theta}{dt} = 1 - \\dfrac{V_2\\,\\theta(t)}{D_c} \\quad \\text{或} \\quad \\dfrac{d\\theta}{dt} + \\left(\\dfrac{V_2}{D_c}\\right)\\theta = 1 $$\n这个带有初始条件 $\\theta(0) = D_c/V_1$ 的常微分方程的解可以通过使用积分因子或识别其标准形式来找到。通解为 $\\theta(t) = \\theta_{\\text{ss}}(V_2) + C \\exp(-t / (D_c/V_2))$，其中 $\\theta_{\\text{ss}}(V_2) = D_c/V_2$ 是新的稳态值。我们求解积分常数 $C$：\n$$ \\theta(0) = \\dfrac{D_c}{V_1} = \\dfrac{D_c}{V_2} + C \\implies C = \\dfrac{D_c}{V_1} - \\dfrac{D_c}{V_2} $$\n当 $t \\ge 0$ 时，状态变量的特解是：\n$$ \\theta(t) = \\dfrac{D_c}{V_2} + \\left(\\dfrac{D_c}{V_1} - \\dfrac{D_c}{V_2}\\right) e^{-t\\,V_2/D_c} $$\n\n为求得在 $t=T_{\\text{end}}$ 时的摩擦系数，我们首先使用上述解来计算 $\\theta(T_{\\text{end}})$：\n$$ \\theta(T_{\\text{end}}) = \\dfrac{D_c}{V_2} + \\left(\\dfrac{D_c}{V_1} - \\dfrac{D_c}{V_2}\\right) e^{-T_{\\text{end}}\\,V_2/D_c} $$\n然后，我们将此值和 $V=V_2$ 代入摩擦定律，以获得第二个所求量 $\\mu(T_{\\text{end}})$：\n$$ \\mu(T_{\\text{end}}) = \\mu_\\star + a \\ln\\left(\\dfrac{V_2}{V_\\star}\\right) + b \\ln\\left(\\dfrac{\\theta(T_{\\text{end}})\\,V_\\star}{D_c}\\right) $$\n\n最后，我们计算累积应力降 $\\Delta\\tau = \\tau(0^-) - \\tau(T_{\\text{end}})$。使用应力的表达式：\n$$ \\Delta\\tau = \\sigma_n\\,\\mu_{\\text{ss}}(V_1) - \\sigma_n\\,\\mu(T_{\\text{end}}) = \\sigma_n\\left(\\mu_{\\text{ss}}(V_1) - \\mu(T_{\\text{end}})\\right) $$\n其中 $\\mu_{\\text{ss}}(V_1)$ 和 $\\mu(T_{\\text{end}})$ 由上面推导的公式给出。这是第三个也是最后一个所求量。计算步骤就是实现这些推导出的解析表达式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (a, b, Dc, sigma_n, mu_star, V_star, V1, V2, T_end)\n    test_cases = [\n        # Case A (step up in velocity, velocity-weakening, short transient)\n        (0.008, 0.012, 1e-5, 5e7, 0.6, 1e-6, 1e-6, 1e-3, 1),\n        # Case B (step down in velocity, velocity-weakening, long transient)\n        (0.008, 0.012, 1e-5, 5e7, 0.6, 1e-6, 1e-4, 1e-6, 50),\n        # Case C (step up with a=b, zero net steady-state change)\n        (0.01, 0.01, 1e-5, 5e7, 0.6, 1e-6, 1e-6, 1e-3, 1),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        a, b, Dc, sigma_n, mu_star, V_star, V1, V2, T_end = case\n\n        # 1. Calculate mu(0+), the immediate friction value after the velocity step.\n        # Formula: mu(0+) = mu_star + a*ln(V2/V_star) - b*ln(V1/V_star)\n        term_a = a * np.log(V2 / V_star)\n        term_b = b * np.log(V1 / V_star)\n        mu_0_plus = mu_star + term_a - term_b\n\n        # 2. Calculate theta(T_end), the state variable at the end of the interval.\n        # This is the solution to the ODE d(theta)/dt = 1 - V2*theta/Dc\n        # with initial condition theta(0) = Dc/V1.\n        # Formula: theta(t) = Dc/V2 + (Dc/V1 - Dc/V2) * exp(-t*V2/Dc)\n        C = Dc / V1 - Dc / V2\n        exponent = -T_end * V2 / Dc\n        theta_T_end = (Dc / V2) + C * np.exp(exponent)\n\n        # 3. Calculate mu(T_end), the friction value at the end time.\n        # Formula: mu(T_end) = mu_star + a*ln(V2/V_star) + b*ln(theta(T_end)*V_star/Dc)\n        log_term_b = b * np.log(theta_T_end * V_star / Dc)\n        mu_T_end = mu_star + term_a + log_term_b\n        \n        # 4. Calculate Delta tau = tau(0-) - tau(T_end).\n        # First, find mu_ss(V1), the steady-state friction before the step.\n        # Formula: mu_ss(V) = mu_star + (a-b)*ln(V/V_star)\n        mu_ss_V1 = mu_star + (a - b) * np.log(V1 / V_star)\n        \n        # Delta tau is then sigma_n * (mu_ss(V1) - mu_T_end)\n        delta_tau = sigma_n * (mu_ss_V1 - mu_T_end)\n\n        # Append the results for the current case.\n        all_results.append([mu_0_plus, mu_T_end, delta_tau])\n\n    # Format the final output string exactly as required.\n    # Example: [[x1,x2,x3],[y1,y2,y3],[z1,z2,z3]]\n    # with 6 decimal places for each float and no extra whitespace.\n    result_strings = []\n    for res in all_results:\n        # Format each number to 6 decimal places\n        mu0_str = f\"{res[0]:.6f}\"\n        muT_str = f\"{res[1]:.6f}\"\n        dT_str = f\"{res[2]:.6f}\"\n        # Construct the inner list string\n        inner_str = f\"[{mu0_str},{muT_str},{dT_str}]\"\n        result_strings.append(inner_str)\n    \n    # Join the inner list strings and enclose in the outer list brackets\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3581299"}, {"introduction": "接下来，我们将从离散界面的时间依赖性摩擦转向连续体积内的时间依赖性变形。广义麦克斯韦模型（Generalized Maxwell model）能够有效描述那些既能储存能量又能耗散能量的材料，正如地球地幔在不同时间尺度上所表现出的行为。本练习将重点推导并实现稳健的“指数积分器”（exponential integrator），这是一种在长期模拟中精确捕捉应力松弛和蠕变现象的关键数值技术。[@problem_id:3581349]", "problem": "考虑一个由一个平衡弹簧与一组麦克斯韦分支并联组成的小应变、单轴广义麦克斯韦固体。每个麦克斯韦分支由一个线性弹性弹簧与一个线性粘性阻尼器串联而成。建模的基本依据是弹簧的胡克定律和阻尼器的牛顿粘性定律，以及机械元件的串并联规则。具体来说，对于弹簧，应力通过 $\\sigma = E \\, \\epsilon^{e}$ 与弹性应变相关；对于阻尼器，应力通过 $\\sigma = \\eta \\, \\dot{\\epsilon}^{v}$ 与粘性应变率相关。对于串联连接，两个元件中的应力相等，而应变相加；对于并联连接，各分支的应变相等，而应力相加。\n\n您需要推导麦克斯韦分支所承载的内应力的演化方程，并构建一个无条件稳定的指数时间积分更新方法，用于处理一个应变步，该应变步从步长开始时的已知应变线性变化到步长结束时的已知应变。\n\n任务：\n- 从上述基本定律和定义出发，且不预先引入任何目标公式，推导在小应变条件下，受给定应变历史 $\\epsilon(t)$ 作用的单个麦克斯韦分支所承载应力随时间演化的一阶线性常微分方程。清楚说明所使用的任何假设。\n- 在从时间 $t_n$ 到时间 $t_{n+1}$ 的时间步长 $\\Delta t$ 内使用恒定应变率，其中 $\\epsilon(t)$ 呈线性变化，即 $\\epsilon(t) = \\epsilon_n + \\dfrac{t - t_n}{\\Delta t} \\, \\Delta \\epsilon$，推导用于将该麦克斯韦分支的应力从时间 $t_n$ 推进到时间 $t_{n+1}$ 的精确指数更新表达式。您的推导必须基于使用积分因子求解所推导出的微分方程，并精确计算步长内分段线性应变所产生的卷积。\n- 将结果推广到与模量为 $E_{\\mathrm{eq}}$ 的平衡弹簧并联的两个麦克斯韦分支，并将时间步结束时的总柯西应力表示为平衡弹簧应力与麦克斯韦分支应力之和。明确定义所有量。\n- 在一个程序中实现得到的更新。对于每个测试用例，该程序接受以下输入：\n  - 平衡弹簧模量 $E_{\\mathrm{eq}}$，单位为 $\\mathrm{Pa}$。\n  - 对于两个麦克斯韦分支中的每一个 $i \\in \\{1,2\\}$：弹簧模量 $E_i$（单位为 $\\mathrm{Pa}$）和粘度 $\\eta_i$（单位为 $\\mathrm{Pa \\cdot s}$）。\n  - 初始应变 $\\epsilon_n$（无量纲），步长内的应变增量 $\\Delta \\epsilon$（无量纲），以及初始分支应力 $s_{i,n}$（单位为 $\\mathrm{Pa}$）。\n  - 时间步长 $\\Delta t$，单位为 $\\mathrm{s}$。\n- 您的程序必须为每个测试用例计算更新后的分支应力 $s_{1,n+1}$ 和 $s_{2,n+1}$（单位为 $\\mathrm{Pa}$），以及更新后的总应力 $\\sigma_{n+1}$（单位为 $\\mathrm{Pa}$），假设步长内的应变路径随时间线性变化。\n- 所有应力以 $\\mathrm{Pa}$ 表示，时间以 $\\mathrm{s}$ 表示，应变为无量纲。角度单位不适用。您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔结果列表。对于每个测试用例，输出一个包含三个浮点数的列表 $[s_{1,n+1}, s_{2,n+1}, \\sigma_{n+1}]$；将所有测试用例的结果聚合到单行单个列表中，例如 $[[a,b,c],[d,e,f]]$。允许将每个数字四舍五入到小数点后六位。\n\n使用以下科学一致的测试套件，其选择旨在检验典型、小步长、大步长、零增量和混合符号加载行为。对于任何分支模量 $E_i$ 为零的情况，将该分支视为非活动状态，其应力为零。\n\n测试套件：\n- 情况 A（中等步长；单个活动麦克斯韦分支）：\n  - $E_{\\mathrm{eq}} = 3 \\times 10^{10} \\ \\mathrm{Pa}$，$E_1 = 1 \\times 10^{10} \\ \\mathrm{Pa}$，$\\eta_1 = 1 \\times 10^{14} \\ \\mathrm{Pa \\cdot s}$，$E_2 = 0 \\ \\mathrm{Pa}$，$\\eta_2 = 1 \\ \\mathrm{Pa \\cdot s}$，\n  - $\\epsilon_n = 0$，$\\Delta \\epsilon = 1 \\times 10^{-5}$，$s_{1,n} = 0 \\ \\mathrm{Pa}$，$s_{2,n} = 0 \\ \\mathrm{Pa}$，$\\Delta t = 1 \\times 10^{3} \\ \\mathrm{s}$。\n- 情况 B（零应变增量；仅松弛）：\n  - $E_{\\mathrm{eq}} = 3 \\times 10^{10} \\ \\mathrm{Pa}$，$E_1 = 5 \\times 10^{9} \\ \\mathrm{Pa}$，$\\eta_1 = 1 \\times 10^{12} \\ \\mathrm{Pa \\cdot s}$，$E_2 = 2 \\times 10^{9} \\ \\mathrm{Pa}$，$\\eta_2 = 5 \\times 10^{11} \\ \\mathrm{Pa \\cdot s}$，\n  - $\\epsilon_n = 1 \\times 10^{-4}$，$\\Delta \\epsilon = 0$，$s_{1,n} = 5 \\times 10^{5} \\ \\mathrm{Pa}$，$s_{2,n} = -1 \\times 10^{5} \\ \\mathrm{Pa}$，$\\Delta t = 1 \\times 10^{5} \\ \\mathrm{s}$。\n- 情况 C（极小时间步；麦克斯韦分支中近似弹性响应）：\n  - $E_{\\mathrm{eq}} = 0 \\ \\mathrm{Pa}$，$E_1 = 2 \\times 10^{10} \\ \\mathrm{Pa}$，$\\eta_1 = 1 \\times 10^{16} \\ \\mathrm{Pa \\cdot s}$，$E_2 = 8 \\times 10^{9} \\ \\mathrm{Pa}$，$\\eta_2 = 4 \\times 10^{15} \\ \\mathrm{Pa \\cdot s}$，\n  - $\\epsilon_n = 0$，$\\Delta \\epsilon = 1 \\times 10^{-6}$，$s_{1,n} = 0 \\ \\mathrm{Pa}$，$s_{2,n} = 0 \\ \\mathrm{Pa}$，$\\Delta t = 1 \\ \\mathrm{s}$。\n- 情况 D（极大时间步；阻尼器主导的响应接近粘度乘以应变率）：\n  - $E_{\\mathrm{eq}} = 0 \\ \\mathrm{Pa}$，$E_1 = 5 \\times 10^{9} \\ \\mathrm{Pa}$，$\\eta_1 = 1 \\times 10^{10} \\ \\mathrm{Pa \\cdot s}$，$E_2 = 3 \\times 10^{9} \\ \\mathrm{Pa}$，$\\eta_2 = 3 \\times 10^{10} \\ \\mathrm{Pa \\cdot s}$，\n  - $\\epsilon_n = 0$，$\\Delta \\epsilon = 1 \\times 10^{-2}$，$s_{1,n} = 0 \\ \\mathrm{Pa}$，$s_{2,n} = 0 \\ \\mathrm{Pa}$，$\\Delta t = 1 \\times 10^{5} \\ \\mathrm{s}$。\n- 情况 E（混合符号与部分松弛）：\n  - $E_{\\mathrm{eq}} = 1 \\times 10^{10} \\ \\mathrm{Pa}$，$E_1 = 7 \\times 10^{9} \\ \\mathrm{Pa}$，$\\eta_1 = 7 \\times 10^{12} \\ \\mathrm{Pa \\cdot s}$，$E_2 = 1 \\times 10^{9} \\ \\mathrm{Pa}$，$\\eta_2 = 1 \\times 10^{11} \\ \\mathrm{Pa \\cdot s}$，\n  - $\\epsilon_n = 2 \\times 10^{-4}$，$\\Delta \\epsilon = -5 \\times 10^{-5}$，$s_{1,n} = 1 \\times 10^{6} \\ \\mathrm{Pa}$，$s_{2,n} = -2 \\times 10^{5} \\ \\mathrm{Pa}$，$\\Delta t = 5 \\times 10^{2} \\ \\mathrm{s}$。\n\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个子列表对应于上述顺序的一个情况。每个子列表必须为 $[s_{1,n+1}, s_{2,n+1}, \\sigma_{n+1}]$ 的形式，单位为 $\\mathrm{Pa}$，每个数字四舍五入到小数点后六位，例如 $[[x_{A,1}, x_{A,2}, x_{A,3}],[x_{B,1}, x_{B,2}, x_{B,3}],\\ldots]$。", "solution": "该问题被评估为**有效**。它在科学上基于线性粘弹性理论，这是连续介质力学和地球物理学中的一个基本课题。该问题是适定的，为获得唯一且稳定的解提供了所有必要的参数和条件。语言客观，任务定义明确。我现在将进行完整解答。\n\n### 麦克斯韦分支控制方程的推导\n\n单个麦克斯韦分支由一个线性弹性弹簧和一个线性粘性阻尼器串联而成。设 $s$ 为分支中的单轴应力，$\\epsilon$ 为分支上的总单轴应变。\n\n**假设：**\n1.  材料行为在小应变假设下进行描述。\n2.  材料参数，即弹簧模量 $E$ 和阻尼器粘度 $\\eta$，为常数。\n3.  应力和应变处于单轴状态。\n\n**基本定律和定义：**\n-   对于串联连接，应力在所有元件中是均匀的，总应变是各个应变之和。设 $\\epsilon^e$ 为弹簧中的应变，$\\epsilon^v$ 为阻尼器中的应变。\n    $$s = s^e = s^v$$\n    $$\\epsilon = \\epsilon^e + \\epsilon^v$$\n-   弹簧的胡克定律将应力与弹性应变联系起来：\n    $$s = E \\epsilon^e \\implies \\epsilon^e = \\frac{s}{E}$$\n-   阻尼器的牛顿粘性定律将应力与粘性应变率联系起来：\n    $$s = \\eta \\dot{\\epsilon}^v \\implies \\dot{\\epsilon}^v = \\frac{s}{\\eta}$$\n    其中点号表示对时间 $t$ 的微分，即 $\\dot{\\epsilon}^v = \\frac{d\\epsilon^v}{dt}$。\n\n**推导：**\n为了找到总应变历史 $\\epsilon(t)$ 与分支的应力响应 $s(t)$ 之间的关系，我们将总应变方程对时间求导：\n$$\\dot{\\epsilon} = \\dot{\\epsilon}^e + \\dot{\\epsilon}^v$$\n我们可以用应力 $s$ 来表示右侧的应变率。将弹簧的本构定律对时间求导得到：\n$$\\dot{\\epsilon}^e = \\frac{d}{dt}\\left(\\frac{s}{E}\\right) = \\frac{1}{E}\\dot{s}$$\n阻尼器的定律已经给出了粘性应变率：\n$$\\dot{\\epsilon}^v = \\frac{s}{\\eta}$$\n将这两个表达式代入时间微分后的总应变方程，得到：\n$$\\dot{\\epsilon}(t) = \\frac{1}{E}\\dot{s}(t) + \\frac{1}{\\eta}s(t)$$\n两边乘以 $E$ 并重新整理各项，我们得到受应变历史 $\\epsilon(t)$ 作用的麦克斯韦分支中应力 $s(t)$ 的一阶线性常微分方程（ODE）：\n$$\\dot{s}(t) + \\frac{E}{\\eta}s(t) = E\\dot{\\epsilon}(t)$$\n通常将麦克斯韦分支的松弛时间定义为 $\\tau = \\eta/E$。使用此定义，ODE变为：\n$$\\dot{s}(t) + \\frac{1}{\\tau}s(t) = E\\dot{\\epsilon}(t)$$\n这就是所要求的演化方程。\n\n### 指数时间积分更新的推导\n\n我们的任务是在一个持续时间为 $\\Delta t = t_{n+1} - t_n$ 的离散时间步上求解此 ODE，其中应变从 $t_n$ 时的 $\\epsilon_n$ 线性变化到 $t_{n+1}$ 时的 $\\epsilon_{n+1}$。\n该步长内的应变历史由下式给出：\n$$\\epsilon(t) = \\epsilon_n + \\frac{t - t_n}{\\Delta t}\\Delta\\epsilon \\quad \\text{for } t \\in [t_n, t_{n+1}]$$\n其中 $\\Delta\\epsilon = \\epsilon_{n+1} - \\epsilon_n$。因此，此区间内的应变率是恒定的：\n$$\\dot{\\epsilon}(t) = \\frac{d\\epsilon}{dt} = \\frac{\\Delta\\epsilon}{\\Delta t}$$\n将这个恒定应变率代入控制 ODE，对于 $t \\in [t_n, t_{n+1}]$，我们有：\n$$\\dot{s}(t) + \\frac{1}{\\tau}s(t) = E\\frac{\\Delta\\epsilon}{\\Delta t}$$\n这是一个具有常系数的一阶线性非齐次 ODE。我们按要求使用积分因子来求解它。积分因子 $I(t)$ 为：\n$$I(t) = \\exp\\left(\\int \\frac{1}{\\tau} dt\\right) = e^{t/\\tau}$$\n将 ODE 乘以 $I(t)$：\n$$e^{t/\\tau}\\dot{s}(t) + \\frac{1}{\\tau}e^{t/\\tau}s(t) = E\\frac{\\Delta\\epsilon}{\\Delta t}e^{t/\\tau}$$\n左边是一个乘积的导数：\n$$\\frac{d}{dt}\\left(s(t)e^{t/\\tau}\\right) = E\\frac{\\Delta\\epsilon}{\\Delta t}e^{t/\\tau}$$\n我们对两边从 $t_n$ 到 $t_{n+1}$ 进行积分：\n$$\\int_{t_n}^{t_{n+1}} \\frac{d}{dt}\\left(s(t)e^{t/\\tau}\\right) dt = \\int_{t_n}^{t_{n+1}} E\\frac{\\Delta\\epsilon}{\\Delta t}e^{t/\\tau} dt$$\n$$[s(t)e^{t/\\tau}]_{t_n}^{t_{n+1}} = E\\frac{\\Delta\\epsilon}{\\Delta t} [\\tau e^{t/\\tau}]_{t_n}^{t_{n+1}}$$\n$$s(t_{n+1})e^{t_{n+1}/\\tau} - s(t_n)e^{t_n/\\tau} = E\\frac{\\Delta\\epsilon}{\\Delta t} \\tau (e^{t_{n+1}/\\tau} - e^{t_n/\\tau})$$\n记 $s(t_n) = s_n$ 和 $s(t_{n+1}) = s_{n+1}$，并解出 $s_{n+1}$：\n$$s_{n+1} = s_n e^{(t_n-t_{n+1})/\\tau} + E\\tau\\frac{\\Delta\\epsilon}{\\Delta t}(1 - e^{(t_n-t_{n+1})/\\tau})$$\n利用 $t_n - t_{n+1} = -\\Delta t$，更新后应力的最终表达式为：\n$$s_{n+1} = s_n e^{-\\Delta t/\\tau} + E\\tau\\frac{\\Delta\\epsilon}{\\Delta t}(1 - e^{-\\Delta t/\\tau})$$\n为了进行数值实现，特别是当无量纲时间步 $\\Delta t/\\tau$ 的值很小时，将方程重写为以下形式是有利的：\n$$s_{n+1} = s_n e^{-\\Delta t/\\tau} + E\\Delta\\epsilon \\left( \\frac{1 - e^{-\\Delta t/\\tau}}{\\Delta t/\\tau} \\right)$$\n这种形式隔离了括号中的项，该项在 $\\Delta t/\\tau \\to 0$ 时趋近于 $1$，并且表现良好，可以防止精度损失。对于分段线性应变路径，此更新是精确的，并且对于任何正的 $\\Delta t$ 和 $\\tau$ 都是无条件稳定的。\n\n### 推广到广义麦克斯韦模型\n\n该模型由一个平衡弹簧（模量 $E_{\\mathrm{eq}}$）与两个麦克斯韦分支（索引为 $i=1,2$）并联组成。\n-   对于并联连接，所有元件的应变相同，总应力是每个元件中应力之和。\n-   在时间 $t$ 施加于系统的总应变为 $\\epsilon(t)$。这是平衡弹簧和两个麦克斯韦分支所承受的应变。\n-   总柯西应力 $\\sigma(t)$ 是平衡应力 $s_{\\mathrm{eq}}(t)$ 与两个麦克斯韦分支中的应力 $s_1(t)$ 和 $s_2(t)$ 之和。\n    $$\\sigma(t) = s_{\\mathrm{eq}}(t) + s_1(t) + s_2(t)$$\n\n**时间 $t_{n+1}$ 时的应力更新：**\n时间步结束时的总应力 $\\sigma_{n+1}$ 为：\n$$\\sigma_{n+1} = s_{\\mathrm{eq},n+1} + s_{1,n+1} + s_{2,n+1}$$\n各个分量的计算如下：\n1.  **平衡弹簧应力：** 平衡弹簧是纯弹性的。其在时间 $t_{n+1}$ 的应力仅取决于该时刻的应变 $\\epsilon_{n+1} = \\epsilon_n + \\Delta\\epsilon$。\n    $$s_{\\mathrm{eq},n+1} = E_{\\mathrm{eq}}\\epsilon_{n+1} = E_{\\mathrm{eq}}(\\epsilon_n + \\Delta\\epsilon)$$\n2.  **麦克斯韦分支应力：** 每个麦克斯韦分支 $i \\in \\{1,2\\}$ 中的应力使用推导出的指数公式进行更新。对于每个具有参数 $E_i, \\eta_i$ 和初始应力 $s_{i,n}$ 的分支 $i$：\n    -   首先，我们处理问题中指定的分支可能处于非活动状态的情况。如果 $E_i = 0$，则分支应力 $s_{i,n+1}$ 设置为 $0$。\n    -   如果 $E_i  0$，我们计算其松弛时间 $\\tau_i = \\eta_i/E_i$。更新后的应力 $s_{i,n+1}$ 则为：\n        $$s_{i,n+1} = s_{i,n} e^{-\\Delta t/\\tau_i} + E_i \\Delta\\epsilon \\left( \\frac{1 - e^{-\\Delta t/\\tau_i}}{\\Delta t/\\tau_i} \\right)$$\n        此公式在 $\\tau_i  0$ 时成立。如果 $\\tau_i = 0$（即 $\\eta_i=0$），则应力 $s_{i,n+1}$ 为 $0$。如果 $\\Delta t=0$，假设 $\\Delta\\epsilon=0$，则 $s_{i,n+1} = s_{i,n}$。我们的实现将处理参数 $\\Delta t/\\tau_i$ 为零的情况。\n\n程序将对每个提供的测试用例执行这三个计算，以求得 $s_{1,n+1}$、$s_{2,n+1}$ 和 $\\sigma_{n+1}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the viscoelastic stress update problem for a series of test cases.\n    The model is a generalized Maxwell solid with one equilibrium spring and two\n    Maxwell branches in parallel. The stress update is derived for a linear\n    strain increment over a time step.\n    \"\"\"\n\n    test_cases = [\n        # Case A\n        {'E_eq': 3e10, 'E1': 1e10, 'eta1': 1e14, 'E2': 0, 'eta2': 1.0,\n         'eps_n': 0.0, 'd_eps': 1e-5, 's1_n': 0.0, 's2_n': 0.0, 'dt': 1e3},\n        # Case B\n        {'E_eq': 3e10, 'E1': 5e9, 'eta1': 1e12, 'E2': 2e9, 'eta2': 5e11,\n         'eps_n': 1e-4, 'd_eps': 0.0, 's1_n': 5e5, 's2_n': -1e5, 'dt': 1e5},\n        # Case C\n        {'E_eq': 0.0, 'E1': 2e10, 'eta1': 1e16, 'E2': 8e9, 'eta2': 4e15,\n         'eps_n': 0.0, 'd_eps': 1e-6, 's1_n': 0.0, 's2_n': 0.0, 'dt': 1.0},\n        # Case D\n        {'E_eq': 0.0, 'E1': 5e9, 'eta1': 1e10, 'E2': 3e9, 'eta2': 3e10,\n         'eps_n': 0.0, 'd_eps': 1e-2, 's1_n': 0.0, 's2_n': 0.0, 'dt': 1e5},\n        # Case E\n        {'E_eq': 1e10, 'E1': 7e9, 'eta1': 7e12, 'E2': 1e9, 'eta2': 1e11,\n         'eps_n': 2e-4, 'd_eps': -5e-5, 's1_n': 1e6, 's2_n': -2e5, 'dt': 500.0}\n    ]\n\n    def compute_branch_stress_update(s_n, E, eta, d_eps, dt):\n        \"\"\"\n        Computes the updated stress for a single Maxwell branch.\n        \"\"\"\n        # Per problem statement, if E_i = 0, the branch is inactive and stress is 0.\n        if E == 0.0:\n            return 0.0\n\n        # The relaxation time tau = eta / E. If eta is 0, tau is 0.\n        # If tau is 0, the dashpot offers no resistance, so stress is 0.\n        if eta == 0.0:\n            return 0.0\n\n        tau = eta / E\n        \n        # Dimensionless time step x = dt / tau\n        x = dt / tau\n\n        # The update formula is s_{n+1} = s_n * exp(-x) + E * d_eps * F(x)\n        # where F(x) = (1 - exp(-x)) / x.\n        # This can be unstable for small x. We use a stable formulation.\n        if x == 0.0:\n            # L'Hopital's rule on F(x) gives 1 as x - 0.\n            # This corresponds to a purely elastic increment.\n            F = 1.0\n        else:\n            # np.expm1(y) computes exp(y) - 1 with high accuracy for small y.\n            # F(x) = - (exp(-x) - 1) / x = -expm1(-x) / x\n            F = -np.expm1(-x) / x\n        \n        s_n_plus_1 = s_n * np.exp(-x) + E * d_eps * F\n        return s_n_plus_1\n\n    results = []\n    for params in test_cases:\n        s1_n_plus_1 = compute_branch_stress_update(\n            params['s1_n'], params['E1'], params['eta1'], params['d_eps'], params['dt']\n        )\n\n        s2_n_plus_1 = compute_branch_stress_update(\n            params['s2_n'], params['E2'], params['eta2'], params['d_eps'], params['dt']\n        )\n        \n        # Calculate total strain at the end of the step\n        eps_n_plus_1 = params['eps_n'] + params['d_eps']\n        \n        # Calculate stress in the equilibrium spring\n        s_eq_n_plus_1 = params['E_eq'] * eps_n_plus_1\n        \n        # Total stress is the sum of stresses in parallel components\n        sigma_n_plus_1 = s_eq_n_plus_1 + s1_n_plus_1 + s2_n_plus_1\n        \n        results.append([s1_n_plus_1, s2_n_plus_1, sigma_n_plus_1])\n    \n    # Format the output string as required: [[r1,r2,r3],[r4,r5,r6],...]\n    # with 6 digits after the decimal point and no spaces.\n    outer_parts = []\n    for r in results:\n        inner_parts = [f\"{v:.6f}\" for v in r]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    final_string = f\"[{','.join(outer_parts)}]\"\n\n    print(final_string)\n\nsolve()\n```", "id": "3581349"}, {"introduction": "最后，我们将探讨永久、不可逆的塑性变形，这对于模拟地壳断裂和材料破坏至关重要。摩尔-库仑模型（Mohr-Coulomb model）是描述岩石和土壤等摩擦性材料的经典准则。本练习将深入探讨计算塑性力学的核心——“返回映射算法”（return-mapping algorithm），该算法确保计算出的应力严格遵守材料的破坏极限。对于任何涉及材料失效的地球动力学模拟而言，这都是一个基石般的算法。[@problem_id:3581296]", "problem": "考虑一个小应变、率无关弹塑性问题，其对象为在轴对称压缩状态下服从莫尔–库仑准则的黏聚摩擦土工材料。应力采用压为正的符号约定。弹性响应是各向同性的，其体积模量为 $K$，剪切模量为 $G$。设主应力满足 $\\sigma_1 \\ge \\sigma_2 = \\sigma_3$，并假设加载和返回映射步骤保持主方向不变。定义应力第一不变量（平均应力）为 $p = (\\sigma_1 + \\sigma_2 + \\sigma_3)/3$，偏应力张量为 $\\mathbf{s} = \\boldsymbol{\\sigma} - p \\mathbf{I}$，第二不变量为 $J_2 = \\tfrac{1}{2} \\mathbf{s}:\\mathbf{s}$。定义偏应力量度为 $q = \\sqrt{3 J_2}$。在 $\\sigma_2 = \\sigma_3$ 的轴对称压缩条件下，一个基本事实是 $q = \\sigma_1 - \\sigma_3$ 且 $p = (\\sigma_1 + 2 \\sigma_3)/3$。\n\n设沿三轴压缩子午线的莫尔–库仑屈服函数表示为不变量形式 $f(p,q) = q - M_c p - k_c$，其中摩擦相关系数为 $M_c = \\dfrac{6 \\sin \\phi}{3 - \\sin \\phi}$，与黏聚力相关的截距为 $k_c = \\dfrac{6 c \\cos \\phi}{3 - \\sin \\phi}$。考虑非关联塑性流动，其塑性势函数为 $g(p,q) = q - M_g p$，其中 $M_g = \\dfrac{6 \\sin \\psi}{3 - \\sin \\psi}$ 使用了剪胀角 $\\psi$。返回映射步骤更新试探应力状态，使其在遵守各向同性弹性和流动法则的同时，满足屈服条件和一致性条件。\n\n从上述基本定义（各向同性线弹性、不变量 $p$ 和 $q$、屈服条件 $f(p,q) \\le 0$、塑性势函数 $g(p,q)$ 以及 $\\dot{\\boldsymbol{\\sigma}} = \\mathbb{D} : (\\dot{\\boldsymbol{\\varepsilon}} - \\dot{\\boldsymbol{\\varepsilon}}^p)$，其中 $\\dot{\\boldsymbol{\\varepsilon}}^p = \\dot{\\lambda} \\, \\partial g/\\partial \\boldsymbol{\\sigma}$）出发，从第一性原理推导在三轴压缩子午线上的轴对称试探状态的闭式返回映射更新。具体来说，对于给定的试探主应力状态 $(\\sigma_1^{\\text{tr}}, \\sigma_2^{\\text{tr}}, \\sigma_3^{\\text{tr}})$（其中 $\\sigma_2^{\\text{tr}} = \\sigma_3^{\\text{tr}}$）、材料参数 $(\\phi, c, \\psi)$ 和弹性模量 $(K, G)$，确定：\n- 从一致性条件得到的塑性乘子增量 $\\Delta \\gamma$，\n- 在相同主应力基下的更新后主应力 $(\\sigma_1^{\\text{new}}, \\sigma_2^{\\text{new}}, \\sigma_3^{\\text{new}})$。\n\n如果试探状态严格满足屈服条件（在数值容差范围内 $f(p^{\\text{tr}}, q^{\\text{tr}})  0$），则更新必须保持应力不变并使用 $\\Delta \\gamma = 0$。\n\n输入时，角度 $\\phi$ 和 $\\psi$ 必须以度为单位解释，并在进行三角函数计算时转换为弧度。所有应力和模量都必须以兆帕（MPa）为单位处理。更新后应力的最终答案必须以兆帕（MPa）表示。程序必须将每个测试用例的结果输出为一个浮点数列表 $[\\Delta \\gamma, \\sigma_1^{\\text{new}}, \\sigma_2^{\\text{new}}, \\sigma_3^{\\text{new}}]$，并四舍五入到六位小数。\n\n测试套件：\n- 案例 1（弹性内部）：$K = 5000$ MPa，$G = 3000$ MPa，$\\phi = 30$ 度，$c = 30$ MPa，$\\psi = 5$ 度，试探主应力 $(\\sigma_1^{\\text{tr}}, \\sigma_2^{\\text{tr}}, \\sigma_3^{\\text{tr}}) = (50, 45, 45)$ MPa。\n- 案例 2（塑性返回至光滑子午线）：$K = 5000$ MPa，$G = 3000$ MPa，$\\phi = 30$ 度，$c = 5$ MPa，$\\psi = 10$ 度，试探主应力 $(\\sigma_1^{\\text{tr}}, \\sigma_2^{\\text{tr}}, \\sigma_3^{\\text{tr}}) = (28, 1, 1)$ MPa。\n- 案例 3（在屈服面上，边界）：$K = 5000$ MPa，$G = 3000$ MPa，$\\phi = 30$ 度，$c = 5$ MPa，$\\psi = 10$ 度，试探主应力 $(\\sigma_1^{\\text{tr}}, \\sigma_2^{\\text{tr}}, \\sigma_3^{\\text{tr}}) = (33.928, 5.536, 5.536)$ MPa。\n- 案例 4（塑性返回，零剪胀）：$K = 5000$ MPa，$G = 3000$ MPa，$\\phi = 30$ 度，$c = 5$ MPa，$\\psi = 0$ 度，试探主应力 $(\\sigma_1^{\\text{tr}}, \\sigma_2^{\\text{tr}}, \\sigma_3^{\\text{tr}}) = (28, 1, 1)$ MPa。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表，该列表用方括号括起来，每个元素是对应测试用例的列表 $[\\Delta \\gamma, \\sigma_1^{\\text{new}}, \\sigma_2^{\\text{new}}, \\sigma_3^{\\text{new}}]$，顺序与上面列出的案例相同。例如，输出应如下所示：\n$[[\\Delta \\gamma_1,\\sigma_{1,1}^{\\text{new}},\\sigma_{2,1}^{\\text{new}},\\sigma_{3,1}^{\\text{new}}],[\\Delta \\gamma_2,\\sigma_{1,2}^{\\text{new}},\\sigma_{2,2}^{\\text{new}},\\sigma_{3,2}^{\\text{new}}],\\ldots]$\n所有报告的数字必须四舍五入到六位小数。角度以度为单位，所有应力和模量均以兆帕（MPa）为单位。角度单位已明确指定为度；请勿在输入中使用弧度。", "solution": "该问题要求推导并实现一个闭式返回映射算法，该算法适用于由具有非关联流动法则的莫尔–库仑屈服准则控制的小应变、率无关弹塑性材料。分析是针对轴对称压缩应力状态进行的。\n\n该算法的基础在于计算塑性力学中常见的算子分裂方法，即首先假设总应变增量产生纯弹性应力响应，从而得到一个“试探”应力状态。如果此试探状态违反了屈服条件，则应用塑性修正步骤将应力状态返回到更新后的屈服面上。此过程使用后向欧拉积分方案进行离散化，以保证其无条件稳定性。\n\n应力率 $\\dot{\\boldsymbol{\\sigma}}$、弹性刚度张量 $\\mathbb{D}$、总应变率 $\\dot{\\boldsymbol{\\varepsilon}}$ 和塑性应变率 $\\dot{\\boldsymbol{\\varepsilon}}^p$ 之间的基本关系由下式给出：\n$$ \\dot{\\boldsymbol{\\sigma}} = \\mathbb{D} : (\\dot{\\boldsymbol{\\varepsilon}} - \\dot{\\boldsymbol{\\varepsilon}}^p) $$\n在一个时间步长 $\\Delta t$ 上积分，我们得到增量更新。试探应力状态 $\\boldsymbol{\\sigma}^{\\text{tr}}$ 定义为如果整个应变增量 $\\Delta\\boldsymbol{\\varepsilon}$ 都是纯弹性的，将会达到的应力：\n$$ \\boldsymbol{\\sigma}^{\\text{tr}} = \\boldsymbol{\\sigma}^{\\text{old}} + \\mathbb{D} : \\Delta\\boldsymbol{\\varepsilon} $$\n其中 $\\boldsymbol{\\sigma}^{\\text{old}}$ 是该步骤开始时的应力。然后，通过对塑性应变增量 $\\Delta\\boldsymbol{\\varepsilon}^p$ 进行修正，将更新后的应力 $\\boldsymbol{\\sigma}^{\\text{new}}$ 与试探应力关联起来：\n$$ \\boldsymbol{\\sigma}^{\\text{new}} = \\boldsymbol{\\sigma}^{\\text{tr}} - \\mathbb{D} : \\Delta\\boldsymbol{\\varepsilon}^p $$\n塑性应变增量由流动法则确定。对于后向欧拉方案，流动法则在步骤结束时的状态下进行评估：\n$$ \\Delta\\boldsymbol{\\varepsilon}^p = \\Delta\\gamma \\, \\left. \\frac{\\partial g}{\\partial \\boldsymbol{\\sigma}} \\right|_{\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{\\text{new}}} $$\n其中 $\\Delta\\gamma$ 是非负塑性乘子增量，$g$ 是塑性势函数。最终应力状态 $\\boldsymbol{\\sigma}^{\\text{new}}$ 必须满足屈服条件，即一致性条件：$f(\\boldsymbol{\\sigma}^{\\text{new}}) = 0$。\n\n对于各向同性弹性和压力相关的塑性模型，将应力和应变张量分解为体积和偏量部分是有利的。弹性本构关系由下式给出：\n$$ p = K \\varepsilon_v^e $$\n$$ \\mathbf{s} = 2G \\mathbf{e}^e $$\n其中 $p$ 是平均应力，$\\mathbf{s}$ 是偏应力张量，$\\varepsilon_v^e$ 是弹性体积应变，$\\mathbf{e}^e$ 是弹性偏应变张量，$K$ 是体积模量，$G$ 是剪切模量。应力更新方程可以用不变量表示：\n$$ p^{\\text{new}} = p^{\\text{tr}} - K \\Delta\\varepsilon_v^p $$\n$$ \\mathbf{s}^{\\text{new}} = \\mathbf{s}^{\\text{tr}} - 2G \\Delta\\mathbf{e}^p $$\n塑性应变增量由塑性势函数 $g(p, q)$ 导出，其中 $q = \\sqrt{3J_2}$ 是偏应力量度。所需的导数为：\n$$ \\Delta\\varepsilon_v^p = \\Delta\\gamma \\frac{\\partial g}{\\partial p} $$\n$$ \\Delta\\mathbf{e}^p = \\Delta\\gamma \\frac{\\partial g}{\\partial \\mathbf{s}} = \\Delta\\gamma \\frac{\\partial g}{\\partial q} \\frac{\\partial q}{\\partial \\mathbf{s}} $$\n塑性势函数为 $g(p,q) = q - M_g p$。其导数为：\n$$ \\frac{\\partial g}{\\partial p} = -M_g $$\n$$ \\frac{\\partial g}{\\partial q} = 1 $$\n将这些代入不变量更新方程中：\n$$ p^{\\text{new}} = p^{\\text{tr}} - K (\\Delta\\gamma (-M_g)) = p^{\\text{tr}} + K M_g \\Delta\\gamma $$\n对于偏量更新，我们注意到 $\\frac{\\partial q}{\\partial \\mathbf{s}} = \\frac{3}{2q}\\mathbf{s}$。因此，$\\Delta\\mathbf{e}^p = \\Delta\\gamma \\frac{3}{2q^{\\text{new}}}\\mathbf{s}^{\\text{new}}$。更新为：\n$$ \\mathbf{s}^{\\text{new}} = \\mathbf{s}^{\\text{tr}} - 2G \\left( \\Delta\\gamma \\frac{3}{2q^{\\text{new}}}\\mathbf{s}^{\\text{new}} \\right) \\implies \\mathbf{s}^{\\text{new}}\\left(1 + \\frac{3G\\Delta\\gamma}{q^{\\text{new}}}\\right) = \\mathbf{s}^{\\text{tr}} $$\n这表明 $\\mathbf{s}^{\\text{new}}$ 与 $\\mathbf{s}^{\\text{tr}}$ 共线，允许我们为 $q$ 编写一个标量更新：\n$$ q^{\\text{new}} = q^{\\text{tr}} - 3G\\Delta\\gamma $$\n我们现在有两个关于不变量 $(p^{\\text{new}}, q^{\\text{new}})$ 的更新方程和一个未知数 $\\Delta\\gamma$。最后一部分是一致性条件，$f(p^{\\text{new}}, q^{\\text{new}}) = 0$。莫尔–库仑屈服函数是 $f(p,q) = q - M_c p - k_c$。代入 $p^{\\text{new}}$ 和 $q^{\\text{new}}$ 的表达式：\n$$ (q^{\\text{tr}} - 3G\\Delta\\gamma) - M_c (p^{\\text{tr}} + K M_g \\Delta\\gamma) - k_c = 0 $$\n整理各项可得塑性乘子 $\\Delta\\gamma$ 的显式表达式：\n$$ q^{\\text{tr}} - M_c p^{\\text{tr}} - k_c = \\Delta\\gamma(3G + K M_c M_g) $$\n左边的项是屈服函数在试探状态下的值，$f^{\\text{tr}} = f(p^{\\text{tr}}, q^{\\text{tr}})$。因此，我们求解 $\\Delta\\gamma$：\n$$ \\Delta\\gamma = \\frac{f^{\\text{tr}}}{3G + K M_c M_g} $$\n仅当 $f^{\\text{tr}}  0$ 时才执行此计算。如果 $f^{\\text{tr}} \\le 0$，则该步骤是弹性的，$\\Delta\\gamma = 0$，导致 $\\boldsymbol{\\sigma}^{\\text{new}} = \\boldsymbol{\\sigma}^{\\text{tr}}$。\n\n一旦确定了塑性步骤的 $\\Delta\\gamma$，就计算更新后的不变量。最后，从更新后的不变量 $(p^{\\text{new}}, q^{\\text{new}})$ 重建主应力。对于指定的轴对称压缩状态（$\\sigma_1 \\ge \\sigma_2 = \\sigma_3$），关系式为：\n$$ p = \\frac{\\sigma_1 + 2\\sigma_3}{3}, \\quad q = \\sigma_1 - \\sigma_3 $$\n反解这个系统，可得主应力作为不变量的函数：\n$$ \\sigma_1 = p + \\frac{2}{3}q $$\n$$ \\sigma_3 = p - \\frac{1}{3}q $$\n$$ \\sigma_2 = \\sigma_3 $$\n因此，通过将 $(p^{\\text{new}}, q^{\\text{new}})$ 代入这些重建公式，可以找到更新后的主应力 $(\\sigma_1^{\\text{new}}, \\sigma_2^{\\text{new}}, \\sigma_3^{\\text{new}})$。\n\n完整的算法如下：\n1.  给定材料参数 $(K, G, \\phi, c, \\psi)$ 和一个试探应力状态 $(\\sigma_1^{\\text{tr}}, \\sigma_2^{\\text{tr}}, \\sigma_3^{\\text{tr}})$。\n2.  计算莫尔–库仑参数 $M_c$ 和 $k_c$ 以及非关联流动参数 $M_g$。输入角度 $\\phi$ 和 $\\psi$（以度为单位）必须转换为弧度以进行三角函数计算。\n3.  计算试探不变量 $p^{\\text{tr}}$ 和 $q^{\\text{tr}}$。\n4.  评估屈服函数 $f^{\\text{tr}} = q^{\\text{tr}} - M_c p^{\\text{tr}} - k_c$。\n5.  如果 $f^{\\text{tr}} \\le \\epsilon$（其中 $\\epsilon$ 是一个小容差，例如 $10^{-9}$），则该步骤是弹性的。设置 $\\Delta\\gamma = 0$ 且 $\\boldsymbol{\\sigma}^{\\text{new}} = \\boldsymbol{\\sigma}^{\\text{tr}}$。\n6.  如果 $f^{\\text{tr}}  \\epsilon$，则该步骤是塑性的。计算 $\\Delta\\gamma = f^{\\text{tr}} / (3G + K M_c M_g)$。\n7.  更新不变量：$p^{\\text{new}} = p^{\\text{tr}} + K M_g \\Delta\\gamma$ 和 $q^{\\text{new}} = q^{\\text{tr}} - 3G\\Delta\\gamma$。\n8.  重建新的主应力：$\\sigma_1^{\\text{new}} = p^{\\text{new}} + \\frac{2}{3}q^{\\text{new}}$ 和 $\\sigma_2^{\\text{new}} = \\sigma_3^{\\text{new}} = p^{\\text{new}} - \\frac{1}{3}q^{\\text{new}}$。\n9.  一个用例的最终输出是列表 $[\\Delta\\gamma, \\sigma_1^{\\text{new}}, \\sigma_2^{\\text{new}}, \\sigma_3^{\\text{new}}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_update(K, G, phi_deg, c, psi_deg, sigma_tr):\n    \"\"\"\n    Performs a return-mapping update for a Mohr-Coulomb material in axisymmetric compression.\n\n    Args:\n        K (float): Bulk modulus in MPa.\n        G (float): Shear modulus in MPa.\n        phi_deg (float): Friction angle in degrees.\n        c (float): Cohesion in MPa.\n        psi_deg (float): Dilation angle in degrees.\n        sigma_tr (tuple): Trial principal stresses (s1, s2, s3) in MPa.\n\n    Returns:\n        list: A list containing [delta_gamma, s1_new, s2_new, s3_new].\n    \"\"\"\n    # 1. Convert angles to radians\n    phi_rad = np.deg2rad(phi_deg)\n    psi_rad = np.deg2rad(psi_deg)\n\n    # 2. Calculate material constants\n    sin_phi = np.sin(phi_rad)\n    cos_phi = np.cos(phi_rad)\n    sin_psi = np.sin(psi_rad)\n\n    denominator_mc = 3.0 - sin_phi\n    Mc = (6.0 * sin_phi) / denominator_mc\n    kc = (6.0 * c * cos_phi) / denominator_mc\n\n    denominator_mg = 3.0 - sin_psi\n    if denominator_mg == 0: # Avoid division by zero if sin(psi) = 3 (not physically possible)\n        Mg = float('inf')\n    else:\n        Mg = (6.0 * sin_psi) / denominator_mg\n\n    # 3. Trial state from principal stresses\n    s1_tr, s2_tr, s3_tr = sigma_tr\n\n    # Calculate trial invariants\n    p_tr = (s1_tr + s2_tr + s3_tr) / 3.0\n    # For axisymmetric compression with s1 >= s3, q = s1 - s3\n    q_tr = s1_tr - s3_tr\n\n    # 4. Evaluate yield function at trial state\n    f_tr = q_tr - Mc * p_tr - kc\n\n    # 5. Check for plasticity. Use a small tolerance for floating-point comparison.\n    if f_tr = 1e-9:\n        # Elastic step or on the yield surface\n        delta_gamma = 0.0\n        s1_new, s2_new, s3_new = s1_tr, s2_tr, s3_tr\n    else:\n        # Plastic step: perform return mapping\n        # Calculate plastic multiplier increment\n        denominator_dg = 3.0 * G + K * Mc * Mg\n        if denominator_dg == 0: # Avoid division by zero\n            delta_gamma = float('inf')\n        else:\n            delta_gamma = f_tr / denominator_dg\n\n        # Update invariants\n        p_new = p_tr + K * Mg * delta_gamma\n        q_new = q_tr - 3.0 * G * delta_gamma\n\n        # Reconstruct updated principal stresses from new invariants\n        s1_new = p_new + (2.0 / 3.0) * q_new\n        s3_new = p_new - (1.0 / 3.0) * q_new\n        s2_new = s3_new\n\n    return [delta_gamma, s1_new, s2_new, s3_new]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (K, G, phi, c, psi, (s1_tr, s2_tr, s3_tr))\n        (5000.0, 3000.0, 30.0, 30.0, 5.0, (50.0, 45.0, 45.0)),\n        (5000.0, 3000.0, 30.0, 5.0, 10.0, (28.0, 1.0, 1.0)),\n        (5000.0, 3000.0, 30.0, 5.0, 10.0, (33.928, 5.536, 5.536)),\n        (5000.0, 3000.0, 30.0, 5.0, 0.0, (28.0, 1.0, 1.0)),\n    ]\n\n    all_results_formatted = []\n    for case in test_cases:\n        K, G, phi, c, psi, sigma_tr = case\n        result = calculate_update(K, G, phi, c, psi, sigma_tr)\n        \n        # Format each number to 6 decimal places and create the list string\n        formatted_numbers = [f\"{num:.6f}\" for num in result]\n        all_results_formatted.append(f\"[{','.join(formatted_numbers)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_formatted)}]\")\n\nsolve()\n```", "id": "3581296"}]}