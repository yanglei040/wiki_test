{"hands_on_practices": [{"introduction": "高斯函数在地球物理学等众多科学领域中无处不在，其傅里叶变换具有一个优雅的特性：高斯函数的傅里叶变换仍然是高斯函数。本练习 [@problem_id:3598065] 提供了一个机会，让你对一个二维各向异性高斯函数进行解析推导，这是地球物理学中用于空间平滑的常用模型。通过这个练习，你将深入理解空间域的尺度（宽度）与频率域的尺度之间的反比关系，这是傅里叶分析的核心概念之一。", "problem": "在沉积盆地非均质性的空间建模中，一个常用的平滑核是在平面上定义的各向异性高斯函数 $f(x,y) = \\exp(-a x^{2} - b y^{2})$，其中 $a0$ 且 $b0$。考虑在计算地球物理学中用于空间波数的连续二维傅里叶变换对：\n$$F(k_{x},k_{y}) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} f(x,y) \\,\\exp\\!\\big(-\\mathrm{i}(k_{x} x + k_{y} y)\\big)\\,\\mathrm{d}x\\,\\mathrm{d}y,$$\n及其逆变换\n$$f(x,y) = \\frac{1}{(2\\pi)^{2}} \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} F(k_{x},k_{y}) \\,\\exp\\!\\big(\\mathrm{i}(k_{x} x + k_{y} y)\\big)\\,\\mathrm{d}k_{x}\\,\\mathrm{d}k_{y}.$$\n从这些定义出发，并仅假设对于正的二次系数，高斯积分是收敛的这一经过充分检验的事实，完成以下任务：\n1) 推导 $f(x,y)$ 的二维傅里叶变换 $F(k_{x},k_{y})$ 的精确闭式表达式。\n2) 将所得谱写成标准高斯形式 $\\mathcal{A}\\,\\exp\\!\\big(-\\tfrac{1}{2}\\, \\boldsymbol{k}^{\\top} \\boldsymbol{\\Sigma}_{k}^{-1} \\boldsymbol{k}\\big)$，其中 $\\boldsymbol{k} = (k_{x},k_{y})^{\\top}$，识别振幅 $\\mathcal{A}$，并用 $a$ 和 $b$ 明确表示谱协方差矩阵 $\\boldsymbol{\\Sigma}_{k}$。给出对应于 $k_{x}$ 和 $k_{y}$ 的两个对角协方差元素。\n将你的最终答案表示为一个复合对象，其中包含变换 $F(k_{x},k_{y})$ 以及协方差矩阵 $\\boldsymbol{\\Sigma}_{k}$ 的两个对角元素。无需四舍五入。在最终的方框答案中不要包含单位。", "solution": "用户提供的问题首先经过严格的验证过程。\n\n### 步骤 1：提取已知条件\n- 待变换的函数是一个各向异性高斯核：$f(x,y) = \\exp(-a x^{2} - b y^{2})$。\n- 参数 $a$ 和 $b$ 是正实数：$a0$，$b0$。\n- 二维傅里叶变换的定义如下：$F(k_{x},k_{y}) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} f(x,y) \\,\\exp\\!\\big(-\\mathrm{i}(k_{x} x + k_{y} y)\\big)\\,\\mathrm{d}x\\,\\mathrm{d}y$。\n- 相应的逆变换为：$f(x,y) = \\frac{1}{(2\\pi)^{2}} \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} F(k_{x},k_{y}) \\,\\exp\\!\\big(\\mathrm{i}(k_{x} x + k_{y} y)\\big)\\,\\mathrm{d}k_{x}\\,\\mathrm{d}k_{y}$。\n- 一个明确的假设是，对于 $c0$，形式为 $\\int \\exp(-cx^2)\\,\\mathrm{d}x$ 的高斯积分是收敛的。\n- 任务 1：推导 $F(k_{x},k_{y})$ 的闭式表达式。\n- 任务 2：将结果写成标准高斯形式 $\\mathcal{A}\\,\\exp\\!\\big(-\\tfrac{1}{2}\\, \\boldsymbol{k}^{\\top} \\boldsymbol{\\Sigma}_{k}^{-1} \\boldsymbol{k}\\big)$，其中 $\\boldsymbol{k} = (k_{x},k_{y})^{\\top}$，识别振幅 $\\mathcal{A}$，并确定谱协方差矩阵 $\\boldsymbol{\\Sigma}_{k}$ 的对角元素。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学性**：该问题基于傅里叶变换及其在高斯函数上的应用的成熟数学理论。这些是物理学、工程学和地球物理学中的基本工具。使用各向异性高斯作为平滑核是空间数据分析中的标准技术。该问题在科学上是合理的。\n- **适定性**：由于 $a0$ 和 $b0$，函数 $f(x,y)$ 是 $L^1(\\mathbb{R}^2)$ 中的一个元素，这保证了其傅里叶变换的存在性和唯一性。任务明确，能够导出一个唯一、稳定且有意义的解。\n- **客观性**：问题以精确、客观的数学语言陈述，没有任何主观性或歧义。\n- **完整性和一致性**：提供了所有必要的信息。函数、变换定义以及参数约束都已明确说明。没有矛盾之处。\n- **其他缺陷**：该问题没有表现出任何其他缺陷，如不切实际、不适定、过于简单或无法验证。这是一个标准的、非平凡的傅里叶分析练习。\n\n### 步骤 3：结论与行动\n问题被确定为**有效**。现在开始求解过程。\n\n### 解题推导\n\n第一个任务是计算 $f(x,y)$ 的二维傅里叶变换。我们从给定的定义开始：\n$$F(k_{x},k_{y}) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} \\exp(-a x^{2} - b y^{2}) \\,\\exp(-\\mathrm{i}(k_{x} x + k_{y} y))\\,\\mathrm{d}x\\,\\mathrm{d}y$$\n被积函数和积分域关于变量 $x$ 和 $y$ 是可分离的。我们可以将二重积分重写为两个独立的一维积分的乘积：\n$$F(k_{x},k_{y}) = \\left( \\int_{-\\infty}^{\\infty} \\exp(-a x^{2} - \\mathrm{i}k_{x} x) \\,\\mathrm{d}x \\right) \\left( \\int_{-\\infty}^{\\infty} \\exp(-b y^{2} - \\mathrm{i}k_{y} y) \\,\\mathrm{d}y \\right)$$\n让我们计算第一个积分，记为 $I_x$：\n$$I_x = \\int_{-\\infty}^{\\infty} \\exp(-a x^{2} - \\mathrm{i}k_{x} x) \\,\\mathrm{d}x$$\n为了解这个积分，我们对指数部分进行配方：\n$$-a x^{2} - \\mathrm{i}k_{x} x = -a \\left( x^2 + \\frac{\\mathrm{i}k_{x}}{a}x \\right) = -a \\left( x^2 + 2x\\left(\\frac{\\mathrm{i}k_{x}}{2a}\\right) + \\left(\\frac{\\mathrm{i}k_{x}}{2a}\\right)^2 - \\left(\\frac{\\mathrm{i}k_{x}}{2a}\\right)^2 \\right)$$\n$$-a x^{2} - \\mathrm{i}k_{x} x = -a \\left( \\left(x + \\frac{\\mathrm{i}k_{x}}{2a}\\right)^2 - \\frac{\\mathrm{i}^2 k_x^2}{4a^2} \\right) = -a \\left(x + \\frac{\\mathrm{i}k_{x}}{2a}\\right)^2 - \\frac{k_x^2}{4a}$$\n将此代回 $I_x$ 的积分中：\n$$I_x = \\int_{-\\infty}^{\\infty} \\exp\\left(-a \\left(x + \\frac{\\mathrm{i}k_{x}}{2a}\\right)^2 - \\frac{k_x^2}{4a}\\right) \\,\\mathrm{d}x = \\exp\\left(-\\frac{k_x^2}{4a}\\right) \\int_{-\\infty}^{\\infty} \\exp\\left(-a \\left(x + \\frac{\\mathrm{i}k_{x}}{2a}\\right)^2\\right) \\,\\mathrm{d}x$$\n该积分为标准高斯积分。通过变量代换 $u = x + \\frac{\\mathrm{i}k_{x}}{2a}$，积分路径被移到了复平面上。然而，由于被积函数的解析性质及其在无穷远处的快速衰减，积分的值保持不变。我们使用著名结果 $\\int_{-\\infty}^{\\infty} \\exp(-c z^2) \\,\\mathrm{d}z = \\sqrt{\\frac{\\pi}{c}}$（其中 $\\text{Re}(c)0$）。在我们的例子中，$c=a  0$。\n$$\\int_{-\\infty}^{\\infty} \\exp\\left(-a \\left(x + \\frac{\\mathrm{i}k_{x}}{2a}\\right)^2\\right) \\,\\mathrm{d}x = \\int_{-\\infty}^{\\infty} \\exp(-a u^2) \\,\\mathrm{d}u = \\sqrt{\\frac{\\pi}{a}}$$\n因此，积分 $I_x$ 是：\n$$I_x = \\sqrt{\\frac{\\pi}{a}} \\exp\\left(-\\frac{k_x^2}{4a}\\right)$$\n通过直接类比，关于 $y$ 的积分（我们记为 $I_y$）可以通过将 $x$ 替换为 $y$，$a$ 替换为 $b$，$k_x$ 替换为 $k_y$ 来得到：\n$$I_y = \\sqrt{\\frac{\\pi}{b}} \\exp\\left(-\\frac{k_y^2}{4b}\\right)$$\n完整的二维傅里叶变换是 $I_x$ 和 $I_y$ 的乘积：\n$$F(k_x, k_y) = I_x I_y = \\left(\\sqrt{\\frac{\\pi}{a}}\\right) \\left(\\sqrt{\\frac{\\pi}{b}}\\right) \\exp\\left(-\\frac{k_x^2}{4a}\\right) \\exp\\left(-\\frac{k_y^2}{4b}\\right)$$\n$$F(k_x, k_y) = \\frac{\\pi}{\\sqrt{ab}} \\exp\\left(-\\frac{k_x^2}{4a} - \\frac{k_y^2}{4b}\\right)$$\n这就是傅里叶变换的闭式表达式，完成了任务 1。\n\n对于任务 2，我们必须将此结果写成标准形式 $\\mathcal{A}\\,\\exp\\!\\big(-\\tfrac{1}{2}\\, \\boldsymbol{k}^{\\top} \\boldsymbol{\\Sigma}_{k}^{-1} \\boldsymbol{k}\\big)$ 并识别其组成部分。\n通过与我们推导出的表达式直接比较，振幅 $\\mathcal{A}$ 为：\n$$\\mathcal{A} = \\frac{\\pi}{\\sqrt{ab}}$$\n指数部分的参数在两种形式中必须相等：\n$$-\\frac{k_x^2}{4a} - \\frac{k_y^2}{4b} = -\\frac{1}{2} \\boldsymbol{k}^{\\top} \\boldsymbol{\\Sigma}_{k}^{-1} \\boldsymbol{k}$$\n设逆协方差矩阵为 $\\boldsymbol{\\Sigma}_{k}^{-1} = \\begin{pmatrix} C_{11}  C_{12} \\\\ C_{21}  C_{22} \\end{pmatrix}$。二次型为：\n$$\\boldsymbol{k}^{\\top} \\boldsymbol{\\Sigma}_{k}^{-1} \\boldsymbol{k} = \\begin{pmatrix} k_x  k_y \\end{pmatrix} \\begin{pmatrix} C_{11}  C_{12} \\\\ C_{21}  C_{22} \\end{pmatrix} \\begin{pmatrix} k_x \\\\ k_y \\end{pmatrix} = C_{11}k_x^2 + (C_{12}+C_{21})k_x k_y + C_{22}k_y^2$$\n从变换的表达式中，我们可以看到没有交叉项 $k_x k_y$，这意味着逆协方差矩阵的非对角元素为零：$C_{12} = C_{21} = 0$。\n我们可以令二次项的系数相等：\n$$\\frac{k_x^2}{2a} + \\frac{k_y^2}{2b} = C_{11}k_x^2 + C_{22}k_y^2$$\n这得到 $C_{11} = \\frac{1}{2a}$ 和 $C_{22} = \\frac{1}{2b}$。\n因此，逆谱协方差矩阵为：\n$$\\boldsymbol{\\Sigma}_{k}^{-1} = \\begin{pmatrix} \\frac{1}{2a}  0 \\\\ 0  \\frac{1}{2b} \\end{pmatrix}$$\n谱协方差矩阵 $\\boldsymbol{\\Sigma}_{k}$ 是 $\\boldsymbol{\\Sigma}_{k}^{-1}$ 的逆。对于对角矩阵，这只是对角元素倒数组成的矩阵：\n$$\\boldsymbol{\\Sigma}_{k} = (\\boldsymbol{\\Sigma}_{k}^{-1})^{-1} = \\begin{pmatrix} 2a  0 \\\\ 0  2b \\end{pmatrix}$$\n问题要求给出对应于 $k_x$ 和 $k_y$ 的两个对角协方差元素。它们是 $\\boldsymbol{\\Sigma}_{k}$ 的对角项。让我们将它们表示为 $(\\boldsymbol{\\Sigma}_{k})_{11}$ 和 $(\\boldsymbol{\\Sigma}_{k})_{22}$。\n$$(\\boldsymbol{\\Sigma}_{k})_{11} = 2a$$\n$$(\\boldsymbol{\\Sigma}_{k})_{22} = 2b$$\n这些分别表示谱分布在 $k_x$ 和 $k_y$ 方向上的方差。\n\n最终的复合答案由变换 $F(k_{x},k_{y})$ 和 $\\boldsymbol{\\Sigma}_{k}$ 的两个对角元素组成。\n变换是 $F(k_{x},k_{y}) = \\frac{\\pi}{\\sqrt{ab}} \\exp\\left(-\\frac{k_x^2}{4a} - \\frac{k_y^2}{4b}\\right)$。\n对角元素是 $2a$ 和 $2b$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\pi}{\\sqrt{ab}} \\exp\\left(-\\frac{k_x^{2}}{4a} - \\frac{k_y^{2}}{4b}\\right)  2a  2b\n\\end{pmatrix}\n}\n$$", "id": "3598065"}, {"introduction": "卷积定理是信号处理中最强大的工具之一，它将时域中复杂的卷积运算转化为频域中简单的乘法运算。本练习 [@problem_id:3598100] 将该定理应用于一个实际的地球物理问题：模拟地震多次波。通过分别在时域中直接计算卷积和在频域中通过傅里叶变换进行计算，你将深刻体会到基于傅里叶变换方法的计算效率，并能检验其数值精度。", "problem": "地震处理中的一个零偏移一维多次波模拟步骤，可以被视为对带限信号的线性时不变运算。令 $r(t)$ 表示反射系数序列，$s(t)$ 表示一个确定性带限震源子波，$(\\cdot \\star \\cdot)$ 表示连续时间卷积。模拟的多次波记录定义为 $r(t)$ 与 $s(t)$ 的自卷积的线性卷积。所有角频率和角度都必须以弧度为单位，时间以秒为单位。仅从傅里叶变换和卷积积分的核心定义，以及离散傅里叶变换出发，完成以下任务。\n\n使用的基础定义：\n- 连续时间傅里叶变换：对于任意绝对可积的 $x(t)$，\n$$\\mathcal{F}\\{x\\}(\\omega) = \\int_{-\\infty}^{\\infty} x(t)\\, e^{-i \\omega t}\\, \\mathrm{d}t,$$\n及其逆变换\n$$\\mathcal{F}^{-1}\\{X\\}(t) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} X(\\omega)\\, e^{i \\omega t}\\, \\mathrm{d}\\omega.$$\n- 连续时间卷积：对于任意可积的 $f(t), g(t)$，\n$$(f \\star g)(t) = \\int_{-\\infty}^{\\infty} f(\\tau)\\, g(t - \\tau)\\, \\mathrm{d}\\tau.$$\n- 离散傅里叶变换：对于一个有限长度序列 $\\{x[n]\\}_{n=0}^{N-1}$，\n$$X[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-i 2\\pi kn/N},\\quad k=0,\\dots,N-1,$$\n其逆变换为\n$$x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k]\\, e^{i 2\\pi kn/N},\\quad n=0,\\dots,N-1.$$\n\n任务 A (推导)：\n- 从上述定义出发，不使用任何其他公式，推导通过将 $r(t)$ 与 $s(t)$ 的自卷积进行卷积所模拟的多次波的频域表示。您的推导必须仅使用给定的定义，逻辑地建立输入信号的傅里叶变换与输出信号的傅里叶变换之间的代数关系。\n\n任务 B (算法设计)：\n- 在离散时间下，采样间隔为 $\\Delta t$ 秒，考虑有限长度序列 $r[n] \\approx r(n \\Delta t)$ 和 $s[n] \\approx s(n \\Delta t)$。令 $c[n]$ 为 $s[n]$ 与自身的线性卷积。令 $y_{\\mathrm{time}}[n]$ 为 $r[n]$ 与 $c[n]$ 的线性卷积。独立地，通过使用离散傅里叶变换定义和适当的补零来构造 $y_{\\mathrm{freq}}[n]$，使得循环卷积能精确地复现线性卷积。两种方法都应产生相同长度 $L$ 的线性卷积结果，其中 $L = \\mathrm{len}(r) + \\mathrm{len}(c) - 1$。\n\n任务 C (数值稳定性和舍入误差评估)：\n- 对于下方的每个测试用例，计算：\n  - 最大绝对差 $\\max_n |y_{\\mathrm{time}}[n] - y_{\\mathrm{freq}}[n]|$ (无量纲)。\n  - 相对 $\\ell_2$ 误差 $\\|y_{\\mathrm{time}} - y_{\\mathrm{freq}}\\|_2 / \\|y_{\\mathrm{time}}\\|_2$ (无量纲)，并约定如果 $\\|y_{\\mathrm{time}}\\|_2 = 0$，则相对误差为 $0$。\n  - 震源谱平方的谱动态范围的以 10 为底的对数，计算方法如下。令 $S[k]$ 为在频域方法中使用的相同变换长度下对 $s[n]$ 进行的离散傅里叶变换，并令 $P[k] = |S[k]|^2$。定义 $P_{\\max} = \\max_k P[k]$ 和 $P_{\\min} = \\min\\{P[k] : P[k] \\geq P_{\\max}\\,\\varepsilon\\}$，其中 $\\varepsilon$ 是双精度浮点数的机器 epsilon。报告 $\\log_{10}\\left(P_{\\max}/P_{\\min}\\right)$ (无量纲)。\n  - 一个布尔值，当且仅当相对 $\\ell_2$ 误差小于或等于容差 $\\tau = 10^{-10}$ 时为真。\n- 所有计算必须以双精度进行。在频域方法和谱动态范围计算中使用相同的离散傅里叶变换长度。时间单位为秒，所有角度单位为弧度。\n\n测试套件 (所有时间量单位为秒)：\n- 用例 1 (通用)：$\\Delta t = 0.001$，$r[n]$ 是一个长度为 2048 的稀疏脉冲序列，脉冲概率为 0.01，脉冲振幅在 $[-0.8, 0.8]$ 之间均匀分布 (使用固定的伪随机数生成器种子)，$s[n]$ 是一个长度为 251 的零相位 Ricker 子波，峰值频率 $f_0 = 25$ 赫兹。\n- 用例 2 (边界，平凡)：$\\Delta t = 0.002$, $r[n] = [1.0]$, $s[n] = [1.0]$。\n- 用例 3 (大动态范围，缩放)：$\\Delta t = 0.001$，$r[n]$ 是一个长度为 512 的序列，其样本为均值为零、标准差为 $10^{-3}$ 的独立高斯分布 (使用固定的伪随机数生成器种子)，$s[n]$ 是一个长度为 401 的零相位高斯子波 $s(t) = A \\exp\\left(-\\frac{t^2}{2\\sigma^2}\\right)$，其中 $A = 10^3$ 且 $\\sigma = 0.004$。\n- 用例 4 (非 2 的幂，相移)：$\\Delta t = 0.0015$，$r[n]$ 是一个长度为 401 的序列，其样本在 $[-0.5, 0.5]$ 之间独立均匀分布 (使用固定的伪随机数生成器种子)，$s[n]$ 是一个长度为 73 的 Hann 窗锥削正弦波，定义为 $s[n] = w[n]\\sin(2\\pi f_c n \\Delta t)$，其中 $f_c = 60$ 赫兹，而 $w[n] = \\tfrac{1}{2}\\left(1 - \\cos\\left(\\tfrac{2\\pi n}{N-1}\\right)\\right)$，$N$ 是 $s[n]$ 的长度。\n\n实现要求：\n- 在时域方法中使用线性卷积。\n- 在频域方法中，选择一个离散傅里叶变换长度 $N_{\\mathrm{fft}}$，其值恰好等于所需的线性卷积长度 $L$，以避免循环混叠并使比较有意义。\n- 通过取实部的方式处理离散傅里叶逆变换输出中可忽略的虚部。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个顶层列表，按测试套件的顺序列出四个用例的结果。每个用例的结果必须是一个包含四个条目的列表，顺序如下：最大绝对差 (浮点数)，相对 $\\ell_2$ 误差 (浮点数)，以 10 为底的谱动态范围 (浮点数)，以及通过布尔值。例如，输出必须具有\n$[\\,[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]\\,]$\n的形式，且不含任何附加文本。", "solution": "问题陈述已经过验证，并被确定为信号处理和计算地球物理学领域内一个适定的、有科学依据的问题。所有提供的定义、参数和任务都是清晰、一致且充分的，足以推导出一个唯一且可验证的解。\n\n### 任务 A：频域表示的推导\n\n目标是求出由连续时间卷积 $y(t) = r(t) \\star (s(t) \\star s(t))$ 定义的多次波模拟记录 $y(t)$ 的傅里叶变换。我们被要求完全从所提供的傅里叶变换和卷积的定义出发。\n\n令 $f(t)$ 和 $g(t)$ 为两个绝对可积函数。它们的卷积由下式给出：\n$$ (f \\star g)(t) = \\int_{-\\infty}^{\\infty} f(\\tau)\\, g(t - \\tau)\\, \\mathrm{d}\\tau $$\n根据定义，它们卷积的傅里叶变换是：\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = \\int_{-\\infty}^{\\infty} (f \\star g)(t)\\, e^{-i \\omega t}\\, \\mathrm{d}t $$\n将卷积的定义代入傅里叶变换积分中：\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = \\int_{t=-\\infty}^{\\infty} \\left( \\int_{\\tau=-\\infty}^{\\infty} f(\\tau)\\, g(t - \\tau)\\, \\mathrm{d}\\tau \\right) e^{-i \\omega t}\\, \\mathrm{d}t $$\n假设函数是良态的，从而可以交换积分顺序（根据 Fubini 定理，对于 $L^1(\\mathbb{R})$ 中的函数，这是成立的），我们得到：\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = \\int_{\\tau=-\\infty}^{\\infty} f(\\tau) \\left( \\int_{t=-\\infty}^{\\infty} g(t - \\tau)\\, e^{-i \\omega t}\\, \\mathrm{d}t \\right) \\mathrm{d}\\tau $$\n让我们关注内部积分。我们进行变量替换，令 $u = t - \\tau$。这意味着 $t = u + \\tau$ 且 $\\mathrm{d}t = \\mathrm{d}u$。积分限保持不变。\n$$ \\int_{t=-\\infty}^{\\infty} g(t - \\tau)\\, e^{-i \\omega t}\\, \\mathrm{d}t = \\int_{u=-\\infty}^{\\infty} g(u)\\, e^{-i \\omega (u + \\tau)}\\, \\mathrm{d}u $$\n使用指数函数的性质 $e^{a+b} = e^a e^b$，我们可以分离这些项：\n$$ \\int_{u=-\\infty}^{\\infty} g(u)\\, e^{-i \\omega u} e^{-i \\omega \\tau}\\, \\mathrm{d}u = e^{-i \\omega \\tau} \\int_{u=-\\infty}^{\\infty} g(u)\\, e^{-i \\omega u}\\, \\mathrm{d}u $$\n根据定义，右侧的积分是 $g(u)$ 的傅里叶变换，我们将其记为 $G(\\omega)$。因此内部积分简化为 $e^{-i \\omega \\tau} G(\\omega)$。\n\n将此结果代回卷积的傅里叶变换表达式中：\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = \\int_{\\tau=-\\infty}^{\\infty} f(\\tau) \\left( e^{-i \\omega \\tau} G(\\omega) \\right) \\mathrm{d}\\tau $$\n由于 $G(\\omega)$ 不依赖于积分变量 $\\tau$，我们可以将其从积分中提出：\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = G(\\omega) \\int_{\\tau=-\\infty}^{\\infty} f(\\tau)\\, e^{-i \\omega \\tau}\\, \\mathrm{d}\\tau $$\n剩余的积分是 $f(\\tau)$ 的傅里叶变换的定义，即 $F(\\omega)$。因此，我们推导出了卷积定理：\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = F(\\omega) G(\\omega) $$\n现在，我们将此定理应用于具体问题。模拟记录为 $y(t) = r(t) \\star (s(t) \\star s(t))$。让我们定义一个中间函数 $c(t) = s(t) \\star s(t)$。那么 $y(t) = r(t) \\star c(t)$。\n\n令 $R(\\omega) = \\mathcal{F}\\{r(t)\\}$，$S(\\omega) = \\mathcal{F}\\{s(t)\\}$，$C(\\omega) = \\mathcal{F}\\{c(t)\\}$，以及 $Y(\\omega) = \\mathcal{F}\\{y(t)\\}$。\n\n将卷积定理应用于 $c(t) = s(t) \\star s(t)$：\n$$ C(\\omega) = \\mathcal{F}\\{s(t) \\star s(t)\\} = S(\\omega) S(\\omega) = S(\\omega)^2 $$\n接下来，将卷积定理应用于 $y(t) = r(t) \\star c(t)$：\n$$ Y(\\omega) = \\mathcal{F}\\{r(t) \\star c(t)\\} = R(\\omega) C(\\omega) $$\n最后，代入 $C(\\omega)$ 的表达式：\n$$ Y(\\omega) = R(\\omega) S(\\omega)^2 $$\n这就是多次波模拟记录的频域表示。时域中的卷积在频域中变为乘法。具体来说，震源子波的自卷积对应于其频谱的平方，随后与反射系数序列的卷积对应于乘以反射系数谱。\n\n### 任务 B：算法设计\n\n我们被要求通过两种不同的方法，为离散、有限长度序列 $r[n]$ 和 $s[n]$ 计算最终记录 $y[n]$。\n\n令输入序列的长度为 $N_r = \\mathrm{len}(r)$ 和 $N_s = \\mathrm{len}(s)$。\n\n1.  **时域方法 ($y_{\\mathrm{time}}[n]$)**：此方法使用直接线性卷积。\n    a.  首先，计算震源子波的自卷积，$c[n] = s[n] \\star s[n]$。这个中间序列 $c[n]$ 的长度将是 $N_c = N_s + N_s - 1 = 2N_s - 1$。\n    b.  接下来，将反射系数序列 $r[n]$ 与结果 $c[n]$进行卷积以获得最终记录：$y_{\\mathrm{time}}[n] = r[n] \\star c[n]$。这个最终序列的长度 $L$ 将是 $L = N_r + N_c - 1 = N_r + (2N_s - 1) - 1 = N_r + 2N_s - 2$。\n\n2.  **频域方法 ($y_{\\mathrm{freq}}[n]$)**：此方法利用离散傅里叶变换 (DFT) 来执行卷积。如果序列被补零到足够的长度，DFT 的循环卷积性质可以用来计算线性卷积。\n    a.  DFT 所需的长度 $N_{\\mathrm{fft}}$ 必须至少为最终线性卷积输出的长度 $L$。问题指定使用恰好为 $L$ 的长度。所以，我们设置 $N_{\\mathrm{fft}} = L = N_r + 2N_s - 2$。\n    b.  将输入序列 $r[n]$ 和 $s[n]$ 用零填充到此长度 $N_{\\mathrm{fft}}$。\n    c.  使用给定定义计算填充后序列的 DFT：\n        $$ R[k] = \\mathrm{DFT}\\{r_{\\text{padded}}\\}[k] = \\sum_{n=0}^{N_{\\mathrm{fft}}-1} r_{\\text{padded}}[n]\\, e^{-i 2\\pi kn/N_{\\mathrm{fft}}} $$\n        $$ S[k] = \\mathrm{DFT}\\{s_{\\text{padded}}\\}[k] = \\sum_{n=0}^{N_{\\mathrm{fft}}-1} s_{\\text{padded}}[n]\\, e^{-i 2\\pi kn/N_{\\mathrm{fft}}} $$\n    d.  在离散频域中应用任务 A 中推导出的代数关系：\n        $$ Y[k] = R[k] \\cdot S[k]^2 $$\n        此乘法对每个频率索引 $k=0, \\dots, N_{\\mathrm{fft}}-1$ 按元素进行。\n    e.  计算 $Y[k]$ 的离散傅里叶逆变换，将结果变换回时域：\n        $$ y_{\\mathrm{freq\\_complex}}[n] = \\mathrm{IDFT}\\{Y\\}[n] = \\frac{1}{N_{\\mathrm{fft}}}\\sum_{k=0}^{N_{\\mathrm{fft}}-1} Y[k]\\, e^{i 2\\pi kn/N_{\\mathrm{fft}}} $$\n    f.  由于原始信号 $r[n]$ 和 $s[n]$ 是实值的，它们的卷积 $y[n]$ 也必须是实值的。由于浮点数的不精确性，数值结果 $y_{\\mathrm{freq\\_complex}}[n]$ 会有一个非零但可忽略的虚部。按照指示，我们通过取实部来丢弃它：\n        $$ y_{\\mathrm{freq}}[n] = \\mathrm{Re}\\{y_{\\mathrm{freq\\_complex}}[n]\\} $$\n    序列 $y_{\\mathrm{time}}[n]$ 和 $y_{\\mathrm{freq}}[n]$ 在机器精度范围内应是相同的。\n\n### 任务 C：数值稳定性和舍入误差评估\n\n对于每个测试用例，我们计算四个指标来比较 $y_{\\mathrm{time}}$ 和 $y_{\\mathrm{freq}}$。\n\n1.  **最大绝对差**：该指标量化了两种方法之间最大的逐点差异。\n    $$ \\Delta_{\\max} = \\max_{n} |y_{\\mathrm{time}}[n] - y_{\\mathrm{freq}}[n]| $$\n\n2.  **相对 $\\ell_2$ 误差**：该指标提供了一个归一化的总体差异度量，考虑了信号的能量。向量 $v$ 的 $\\ell_2$-范数为 $\\|v\\|_2 = \\sqrt{\\sum_n |v[n]|^2}$。\n    $$ E_2 = \\frac{\\|y_{\\mathrm{time}} - y_{\\mathrm{freq}}\\|_2}{\\|y_{\\mathrm{time}}\\|_2} $$\n    如果 $\\|y_{\\mathrm{time}}\\|_2 = 0$，则误差定义为 $0$。\n\n3.  **谱动态范围**：该指标评估震源谱的数值条件，这会影响频域运算的准确性。\n    a. 令 $S[k]$ 为在长度为 $N_{\\mathrm{fft}}$ 上对填充后的震源子波 $s[n]$ 进行的 DFT。\n    b. 计算功率谱 $P[k] = |S[k]|^2$。\n    c. 找到最大功率 $P_{\\max} = \\max_k P[k]$。\n    d. 获取双精度浮点数的机器 epsilon, $\\varepsilon$。\n    e. 定义一个噪声基底阈值 $P_{\\mathrm{thresh}} = P_{\\max} \\cdot \\varepsilon$。\n    f. 找到高于此基底的最小功率值：$P_{\\min} = \\min\\{P[k] \\mid P[k] \\geq P_{\\mathrm{thresh}}\\}$。\n    g. 然后动态范围计算如下：\n        $$ D = \\log_{10}\\left(\\frac{P_{\\max}}{P_{\\min}}\\right) $$\n    如果 $P_{\\max} = 0$，这意味着 $s[n]$ 全为零，那么 $P_{\\min}$ 也将为 $0$。在这种情况下，由于没有信号，动态范围可视为 $0$。\n\n4.  **容差检查**：一个布尔标志，指示数值方法是否在可接受的范围内接近。\n    $$ \\mathrm{Pass} = (E_2 \\le \\tau) $$\n    其中容差 $\\tau$ 设定为 $10^{-10}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, ifft\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    # --- Helper function for wavelet generation ---\n\n    def generate_ricker(n_s, f0, dt):\n        \"\"\"Generates a zero-phase Ricker wavelet.\"\"\"\n        if n_s == 1:\n            return np.array([1.0], dtype=np.float64)\n        t = (np.arange(n_s) - (n_s - 1) / 2) * dt\n        pi_f0_t_sq = (np.pi * f0 * t) ** 2\n        return (1 - 2 * pi_f0_t_sq) * np.exp(-pi_f0_t_sq)\n\n    def generate_gaussian_wavelet(n_s, A, sigma, dt):\n        \"\"\"Generates a zero-phase Gaussian wavelet.\"\"\"\n        if n_s == 1:\n            return np.array([A], dtype=np.float64)\n        t = (np.arange(n_s) - (n_s - 1) / 2) * dt\n        return A * np.exp(-t**2 / (2 * sigma**2))\n\n    def generate_hann_tapered_sine(n_s, fc, dt):\n        \"\"\"Generates a Hann-tapered sine wave.\"\"\"\n        if n_s == 1:\n            return np.array([0.0], dtype=np.float64) # sin(0) = 0\n        n = np.arange(n_s)\n        window = 0.5 * (1 - np.cos(2 * np.pi * n / (n_s - 1)))\n        sine_wave = np.sin(2 * np.pi * fc * n * dt)\n        return window * sine_wave\n\n    def solve_case(case_params):\n        \"\"\"\n        Solves a single test case, returning the four required metrics.\n        \"\"\"\n        case_id = case_params['id']\n        dt = case_params['dt']\n        len_r = case_params['len_r']\n        len_s = case_params['len_s']\n        \n        # --- Generate r[n] and s[n] for the current case ---\n        \n        # Seed for reproducibility\n        rng = np.random.default_rng(seed=case_id)\n\n        if case_id == 1:\n            # Sparse spike train r[n]\n            r = np.zeros(len_r, dtype=np.float64)\n            is_spike = rng.random(len_r)  0.01\n            num_spikes = np.sum(is_spike)\n            r[is_spike] = rng.uniform(-0.8, 0.8, num_spikes)\n            # Ricker wavelet s[n]\n            s = generate_ricker(len_s, f0=25.0, dt=dt)\n\n        elif case_id == 2:\n            # Trivial boundary case\n            r = np.array([1.0], dtype=np.float64)\n            s = np.array([1.0], dtype=np.float64)\n\n        elif case_id == 3:\n            # Gaussian noise r[n]\n            r = rng.normal(loc=0.0, scale=1e-3, size=len_r).astype(np.float64)\n            # Gaussian wavelet s[n]\n            s = generate_gaussian_wavelet(len_s, A=1e3, sigma=0.004, dt=dt)\n\n        elif case_id == 4:\n            # Uniform noise r[n]\n            r = rng.uniform(-0.5, 0.5, size=len_r).astype(np.float64)\n            # Hann-tapered sinusoid s[n]\n            s = generate_hann_tapered_sine(len_s, fc=60.0, dt=dt).astype(np.float64)\n\n        # Ensure double precision\n        r = r.astype(np.float64)\n        s = s.astype(np.float64)\n\n        # --- Task B: Time-Domain and Frequency-Domain Pathways ---\n\n        # 1. Time-Domain Pathway\n        c_time = np.convolve(s, s, mode='full')\n        y_time = np.convolve(r, c_time, mode='full')\n        \n        # 2. Frequency-Domain Pathway\n        N_fft = len(y_time) # Use the exact linear convolution length for FFT\n\n        R_fft = fft(r, n=N_fft)\n        S_fft = fft(s, n=N_fft)\n\n        Y_fft = R_fft * (S_fft**2)\n        y_freq_complex = ifft(Y_fft)\n        y_freq = np.real(y_freq_complex)\n\n        # --- Task C: Numerical Stability and Roundoff Assessment ---\n\n        # 1. Maximum Absolute Difference\n        max_abs_diff = np.max(np.abs(y_time - y_freq))\n\n        # 2. Relative l2 Error\n        norm_diff = np.linalg.norm(y_time - y_freq)\n        norm_y_time = np.linalg.norm(y_time)\n        if norm_y_time == 0.0:\n            rel_l2_err = 0.0\n        else:\n            rel_l2_err = norm_diff / norm_y_time\n\n        # 3. Spectral Dynamic Range\n        P = np.abs(S_fft)**2\n        P_max = np.max(P)\n        \n        if P_max == 0.0:\n            dyn_range_log10 = 0.0\n        else:\n            epsilon = np.finfo(np.float64).eps\n            P_min_set = P[P = P_max * epsilon]\n            # The set is guaranteed to be non-empty unless P_max is 0\n            P_min = np.min(P_min_set)\n            if P_min == 0.0: # Should not happen with epsilon guard but as a safety\n                dyn_range_log10 = np.inf\n            else:\n                dyn_range_log10 = np.log10(P_max / P_min)\n\n        # 4. Tolerance Check\n        tolerance = 1e-10\n        passed = rel_l2_err = tolerance\n\n        return [max_abs_diff, rel_l2_err, dyn_range_log10, passed]\n    \n    test_cases_params = [\n        {'id': 1, 'dt': 0.001, 'len_r': 2048, 'len_s': 251},\n        {'id': 2, 'dt': 0.002, 'len_r': 1, 'len_s': 1},\n        {'id': 3, 'dt': 0.001, 'len_r': 512, 'len_s': 401},\n        {'id': 4, 'dt': 0.0015, 'len_r': 401, 'len_s': 73},\n    ]\n\n    results = []\n    for params in test_cases_params:\n        case_result = solve_case(params)\n        results.append(case_result)\n\n    # Format the final output string\n    def format_list(lst):\n        items = []\n        for item in lst:\n            if isinstance(item, list):\n                items.append(format_list(item))\n            elif isinstance(item, bool):\n                items.append(str(item).lower())\n            else:\n                items.append(f\"{item:.15e}\") # High precision float format\n        return f\"[{','.join(items)}]\"\n    \n    # Custom formatting to match the required output style precisely\n    final_output_str = \"[\" + \",\".join([\n        f\"[{res[0]:.15e},{res[1]:.15e},{res[2]:.15e},{str(res[3]).lower()}]\" for res in results\n    ]) + \"]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "3598100"}, {"introduction": "傅里叶分析不仅是强大的信号处理工具，更是设计和分析数值算法（例如用于模拟地震波传播的算法）的关键分析手段。本练习 [@problem_id:3598094] 演示了如何推导有限差分算子的“傅里叶符号”，它揭示了离散算子对不同波数的连续导数的近似精度。通过比较同位网格和交错网格方案，你将学习到不同的离散化选择如何影响数值频散和混叠，从而获得设计高保真度波动方程求解器的洞察力。", "problem": "在计算地球物理学中，空间导数的离散表示是模拟地震波传播的基础。一种标准的分析工具是通过线性、移位不变算子在离散平面波上的作用，在傅里叶域中对其进行表征。考虑一个一维均匀网格，网格间距为 $\\Delta x$（单位为米），以及一个离散平面波 $f_j = \\exp(i k j \\Delta x)$，其中 $j \\in \\mathbb{Z}$ 是网格节点的索引，$k$ 是空间波数（单位为弧度/米）。离散傅里叶变换（DFT）表明，连续空间导数映射为乘以 $i k$，而离散有限差分近似则映射为乘以 $i \\sigma(k)$，其中 $\\sigma(k)$ 是离散算子的傅里叶符号。有效波数 $k_{\\mathrm{eff}}(k)$ 由 $D f_j = i k_{\\mathrm{eff}}(k) f_j$ 定义，其中 $D$ 是离散导数算子。\n\n您将研究两种格式的混叠抑制和频散特性：\n- 一种作用于位于 $\\Delta x$ 整数倍位置的采样点 $f_j$ 的二阶同位网格中心有限差分。\n- 一种作用于半网格和整网格位置之间的二阶交错网格中心有限差分，其采样点 $g_{j+1/2}$ 位于 $(j+1/2)\\Delta x$ 位置，导数在整网格索引上计算。\n\n仅从基本定义（导数的傅里叶域性质、线性移位不变算子对平面波的DFT响应以及下文的模板定义）出发，推导两种格式的傅里叶符号 $\\sigma(k)$，从而得出有效波数 $k_{\\mathrm{eff}}(k)$。所有三角函数求值均使用弧度。模板为：\n- 同位网格中心差分：$D_{\\mathrm{coll}} f_j = \\dfrac{f_{j+1} - f_{j-1}}{2 \\Delta x}$。\n- 交错网格中心差分（从半网格映射到整网格）：$D_{\\mathrm{stag}} g_j = \\dfrac{g_{j+1/2} - g_{j-1/2}}{\\Delta x}$。\n\n将奈奎斯特波数定义为 $k_{\\mathrm{Nyquist}} = \\pi / \\Delta x$（单位为弧度/米）。对于每种格式，通过相对相位误差比 $r(k) = k_{\\mathrm{eff}}(k)/k$ 来量化频散，并通过 $k_{\\mathrm{eff}}$ 在 $k_{\\mathrm{Nyquist}}$ 处的值来量化混叠行为。实现一个程序，对下面列出的每个测试用例执行以下操作：\n- 在 $M$ 个均匀间隔的点上对波数区间 $[0, k_{\\mathrm{Nyquist}}]$ 进行采样。对于涉及除以 $k$ 的比率，计算中排除 $k=0$，并为报告目的将极限 $k \\to 0$ 解释为 $r(0) = 1$。\n- 计算同位网格和交错网格格式的最大相对频散误差 $\\max_{k \\in (0, k_{\\mathrm{Nyquist}}]} |r(k) - 1|$。\n- 确定两个布尔值以指示混叠抑制行为：同位网格格式是否满足 $k_{\\mathrm{eff}}(k_{\\mathrm{Nyquist}}) = 0$ 以及交错网格格式是否满足 $k_{\\mathrm{eff}}(k_{\\mathrm{Nyquist}}) = 0$，使用数值上稳健的相等性测试进行评估。\n- 报告一个改进布尔值，如果交错网格格式的最大相对频散误差严格小于同位网格格式，则该值为真。\n\n物理单位和角度单位要求：\n- 以米报告 $\\Delta x$。\n- 以弧度/米报告波数 $k$。\n- 对任何三角函数参数使用弧度。\n\n测试套件：\n- 用例 1：$N = 256$ 个网格点，$\\Delta x = 10$ 米，$M = 10001$ 个波数样本。\n- 用例 2：$N = 32$ 个网格点，$\\Delta x = 50$ 米，$M = 10001$ 个波数样本。\n- 用例 3：$N = 512$ 个网格点，$\\Delta x = 1$ 米，$M = 10001$ 个波数样本。\n- 用例 4：$N = 16$ 个网格点，$\\Delta x = 25$ 米，$M = 2049$ 个波数样本。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个包含五个条目的子列表，顺序如下：[改进布尔值, 同位网格的最大相对误差 (浮点数), 交错网格的最大相对误差 (浮点数), 同位网格在 $k_{\\mathrm{Nyquist}}$ 处的混叠置零布尔值, 交错网格在 $k_{\\mathrm{Nyquist}}$ 处的混叠置零布尔值]。所有浮点数都应报告小数点后 $8$ 位。例如，总体输出应类似于 $[[\\dots],[\\dots],[\\dots],[\\dots]]$，不含空格。", "solution": "在进行求解之前，需要对问题进行验证。\n\n### 步骤 1：提取给定信息\n- 网格间距：`$\\Delta x$` (米)。\n- 网格节点索引：`$j \\in \\mathbb{Z}$`。\n- 波数：`$k$` (弧度/米)。\n- 同位网格平面波：`$f_j = \\exp(i k j \\Delta x)$`。\n- 交错网格平面波：`$g_{j+1/2} = \\exp(i k (j+1/2) \\Delta x)$`。\n- 有效波数定义：`$D \\phi = i k_{\\mathrm{eff}}(k) \\phi$`，其中 `$\\phi$` 是相应的平面波。\n- 同位网格模板：`$D_{\\mathrm{coll}} f_j = \\dfrac{f_{j+1} - f_{j-1}}{2 \\Delta x}$`。\n- 交错网格模板：`$D_{\\mathrm{stag}} g_j = \\dfrac{g_{j+1/2} - g_{j-1/2}}{\\Delta x}$`。\n- 奈奎斯特波数：`$k_{\\mathrm{Nyquist}} = \\pi / \\Delta x$`。\n- 相对相位误差比：`$r(k) = k_{\\mathrm{eff}}(k)/k$`。\n- `$k=0$` 处比率的极限：`$\\lim_{k \\to 0} r(k) = 1$`。\n- 波数采样：在 `$M$` 个均匀间隔点上对区间 `$[0, k_{\\mathrm{Nyquist}}]$` 进行采样。\n- 要计算的指标：\n    1. 同位网格和交错网格格式的最大相对频散误差 `$\\max_{k \\in (0, k_{\\mathrm{Nyquist}}]} |r(k) - 1|$`。\n    2. 混叠抑制布尔值：`$k_{\\mathrm{eff}}(k_{\\mathrm{Nyquist}}) = 0$` 对于同位网格和交错网格格式。\n    3. 改进布尔值：如果交错网格的最大误差严格小于同位网格的最大误差，则为 `True`。\n- 测试用例：\n    - 用例 1：`$N = 256$`，`$\\Delta x = 10$` 米，`$M = 10001$`。\n    - 用例 2：`$N = 32$`，`$\\Delta x = 50$` 米，`$M = 10001$`。\n    - 用例 3：`$N = 512$`，`$\\Delta x = 1$` 米，`$M = 10001$`。\n    - 用例 4：`$N = 16$`，`$\\Delta x = 25$` 米，`$M = 2049$`。\n- 变量 `$N$`（网格点数）对于无限网格的理论推导是无关的，因此在解析公式中不会使用。\n\n### 步骤 2：使用提取的给定信息进行验证\n该问题在科学上是合理的、适定的和客观的。它基于傅里叶分析的基本原理，并应用于偏微分方程的数值方法，这是计算地球物理学和应用数学中的一个标准课题。定义是精确的，目标是可量化的，并且提供了推导解决方案所需的所有信息。该问题没有违反任何无效标准。\n\n### 步骤 3：结论和行动\n问题有效。将提供完整的解决方案。\n\n### 基于原理的解决方案\n核心任务是确定两种有限差分格式的有效波数 `$k_{\\mathrm{eff}}(k)$`。这通过将离散差分算子 `$D$` 应用于离散平面波，并将输出分解为 `$i k_{\\mathrm{eff}}(k)` 乘以原始平面波的形式来实现。\n\n**1. 同位网格中心差分格式**\n\n算子由 `$D_{\\mathrm{coll}} f_j = \\dfrac{f_{j+1} - f_{j-1}}{2 \\Delta x}$` 给出。我们将此算子应用于平面波 `$f_j = \\exp(i k j \\Delta x)$`。\n\n$$\n\\begin{aligned}\nD_{\\mathrm{coll}} f_j = \\frac{\\exp(i k (j+1) \\Delta x) - \\exp(i k (j-1) \\Delta x)}{2 \\Delta x} \\\\\n= \\frac{\\exp(i k j \\Delta x) \\exp(i k \\Delta x) - \\exp(i k j \\Delta x) \\exp(-i k \\Delta x)}{2 \\Delta x} \\\\\n= f_j \\cdot \\frac{\\exp(i k \\Delta x) - \\exp(-i k \\Delta x)}{2 \\Delta x}\n\\end{aligned}\n$$\n\n使用欧拉恒等式 `$\\sin(\\theta) = \\frac{e^{i\\theta} - e^{-i\\theta}}{2i}$`，我们可以写出 `$\\exp(i k \\Delta x) - \\exp(-i k \\Delta x) = 2i \\sin(k \\Delta x)$`。将此代入方程得到：\n\n$$\nD_{\\mathrm{coll}} f_j = f_j \\cdot \\frac{2i \\sin(k \\Delta x)}{2 \\Delta x} = i \\left( \\frac{\\sin(k \\Delta x)}{\\Delta x} \\right) f_j\n$$\n\n通过将此结果与定义 `$D_{\\mathrm{coll}} f_j = i k_{\\mathrm{eff, coll}}(k) f_j$` 进行比较，我们确定同位网格格式的有效波数为：\n\n$$\nk_{\\mathrm{eff, coll}}(k) = \\frac{\\sin(k \\Delta x)}{\\Delta x}\n$$\n\n**2. 交错网格中心差分格式**\n\n算子为 `$D_{\\mathrm{stag}} g_j = \\dfrac{g_{j+1/2} - g_{j-1/2}}{\\Delta x}$`。它作用于定义在半网格上的平面波 `$g_{j+1/2} = \\exp(i k (j+1/2) \\Delta x)$`，并在整网格上产生结果。\n\n$$\n\\begin{aligned}\nD_{\\mathrm{stag}} g_j = \\frac{\\exp(i k (j+1/2) \\Delta x) - \\exp(i k (j-1/2) \\Delta x)}{\\Delta x} \\\\\n= \\frac{\\exp(i k j \\Delta x) \\exp(i k \\Delta x / 2) - \\exp(i k j \\Delta x) \\exp(-i k \\Delta x / 2)}{\\Delta x} \\\\\n= \\exp(i k j \\Delta x) \\cdot \\frac{\\exp(i k \\Delta x / 2) - \\exp(-i k \\Delta x / 2)}{\\Delta x}\n\\end{aligned}\n$$\n\n再次使用欧拉恒等式，设 `$\\theta = k \\Delta x / 2$`，我们有 `$\\exp(i k \\Delta x / 2) - \\exp(-i k \\Delta x / 2) = 2i \\sin(k \\Delta x / 2)$`。将其代入得到：\n\n$$\nD_{\\mathrm{stag}} g_j = \\exp(i k j \\Delta x) \\cdot \\frac{2i \\sin(k \\Delta x / 2)}{\\Delta x} = i \\left( \\frac{2 \\sin(k \\Delta x / 2)}{\\Delta x} \\right) \\exp(i k j \\Delta x)\n$$\n\n结果与整网格平面波成正比。遵循问题定义的模式，我们将其与 `$i k_{\\mathrm{eff, stag}}(k) f_j$` 进行匹配，其中 `$f_j = \\exp(i k j \\Delta x)$`。这给出了交错网格格式的有效波数：\n\n$$\nk_{\\mathrm{eff, stag}}(k) = \\frac{2 \\sin(k \\Delta x / 2)}{\\Delta x}\n$$\n\n**3. 频散和混叠分析**\n\n相对相位误差比为 `$r(k) = k_{\\mathrm{eff}}(k)/k$`。理想算子具有 `$k_{\\mathrm{eff}}(k) = k$`，因此 `$r(k)=1$`。偏离 `$1$` 表示存在频散误差。\n\n对于同位网格格式：\n$$\nr_{\\mathrm{coll}}(k) = \\frac{k_{\\mathrm{eff, coll}}(k)}{k} = \\frac{\\sin(k \\Delta x)}{k \\Delta x}\n$$\n\n对于交错网格格式：\n$$\nr_{\\mathrm{stag}}(k) = \\frac{k_{\\mathrm{eff, stag}}(k)}{k} = \\frac{2 \\sin(k \\Delta x / 2)}{k \\Delta x} = \\frac{\\sin(k \\Delta x / 2)}{k \\Delta x / 2}\n$$\n\n现在，我们评估在奈奎斯特波数 `$k_{\\mathrm{Nyquist}} = \\pi / \\Delta x$` 处的行为。\n\n同位网格在奈奎斯特波数处：\n$$\nk_{\\mathrm{eff, coll}}(k_{\\mathrm{Nyquist}}) = \\frac{\\sin(k_{\\mathrm{Nyquist}} \\Delta x)}{\\Delta x} = \\frac{\\sin((\\pi/\\Delta x)\\Delta x)}{\\Delta x} = \\frac{\\sin(\\pi)}{\\Delta x} = 0\n$$\n由于 `$k_{\\mathrm{eff, coll}}(k_{\\mathrm{Nyquist}}) = 0$`，该格式完全抑制（置零）了奈奎斯特频率处的混叠。相应的布尔值为 `True`。\n\n交错网格在奈奎斯特波数处：\n$$\nk_{\\mathrm{eff, stag}}(k_{\\mathrm{Nyquist}}) = \\frac{2 \\sin(k_{\\mathrm{Nyquist}} \\Delta x / 2)}{\\Delta x} = \\frac{2 \\sin((\\pi/\\Delta x)\\Delta x/2)}{\\Delta x} = \\frac{2 \\sin(\\pi/2)}{\\Delta x} = \\frac{2}{\\Delta x}\n$$\n由于 `$k_{\\mathrm{eff, stag}}(k_{\\mathrm{Nyquist}}) \\neq 0$`，该格式不抑制奈奎斯特频率处的混叠。布尔值为 `False`。\n\n最后，我们找出在 `$k \\in (0, k_{\\mathrm{Nyquist}}]$` 上的最大相对频散误差 `$\\max |r(k) - 1|$`。\n设 `$y = k \\Delta x$`。`$y$` 的区间变为 `$(0, \\pi]$`。\n设 `$z = k \\Delta x / 2$`。`$z$` 的区间变为 `$(0, \\pi/2]$`。\n比率为 `$r_{\\mathrm{coll}} = \\sin(y)/y$` 和 `$r_{\\mathrm{stag}} = \\sin(z)/z$`。\n在各自的区间 `$(0, \\pi]$` 和 `$(0, \\pi/2]$` 上，`$\\sin(x)/x$` 函数都是单调递减的，并且始终小于或等于 `$1$`。因此，`$|r(k) - 1| = 1 - r(k)$`。最大误差出现在 `$k$` 的最大值处，即 `$k_{\\mathrm{Nyquist}}$`。\n\n最大同位网格误差：\n$$\n\\max |r_{\\mathrm{coll}}(k) - 1| = 1 - r_{\\mathrm{coll}}(k_{\\mathrm{Nyquist}}) = 1 - \\frac{\\sin(\\pi)}{\\pi} = 1 - 0 = 1\n$$\n\n最大交错网格误差：\n$$\n\\max |r_{\\mathrm{stag}}(k) - 1| = 1 - r_{\\mathrm{stag}}(k_{\\mathrm{Nyquist}}) = 1 - \\frac{\\sin(\\pi/2)}{\\pi/2} = 1 - \\frac{1}{\\pi/2} = 1 - \\frac{2}{\\pi}\n$$\n\n由于 `$1 - 2/\\pi \\approx 0.363381$`，交错网格格式具有严格更小的最大相对频散误差。改进布尔值为 `True`。\n\n这些解析结果与 `$\\Delta x$`、`$N$` 和 `$M$` 无关，并将通过实现进行数值验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries are necessary. The problem can be solved with numpy alone.\n\ndef solve():\n    \"\"\"\n    Derives and computes dispersion and alias characteristics for two\n    finite difference schemes for the first spatial derivative.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, delta_x, M), where N is number of grid points,\n    # delta_x is grid spacing, and M is number of wavenumber samples.\n    # The variable N is extraneous to the theoretical calculations.\n    test_cases = [\n        (256, 10.0, 10001),\n        (32, 50.0, 10001),\n        (512, 1.0, 10001),\n        (16, 25.0, 2049),\n    ]\n\n    all_results_str = []\n    \n    for _, dx, M in test_cases:\n        # Calculate the Nyquist wavenumber\n        k_nyquist = np.pi / dx\n        \n        # Sample the wavenumber interval [0, k_Nyquist] at M points.\n        # k=0 is excluded from ratio calculations as specified.\n        k_vec = np.linspace(0, k_nyquist, M)\n        k_vec_nonzero = k_vec[1:]\n\n        # --- Collocated Scheme Analysis ---\n        \n        # Calculate the relative phase error ratio r(k) = k_eff(k)/k\n        # For collocated scheme, r_coll(k) = sin(k*dx) / (k*dx)\n        arg_coll = k_vec_nonzero * dx\n        r_coll = np.sin(arg_coll) / arg_coll\n        \n        # Compute the maximum relative dispersion error\n        max_err_coll = np.max(np.abs(r_coll - 1.0))\n        \n        # Check alias suppression at k_Nyquist: k_eff(k_Nyquist) == 0?\n        # k_eff_coll(k_Nyquist) = sin(pi)/dx = 0\n        k_eff_coll_nyquist = np.sin(k_nyquist * dx) / dx\n        alias_coll_bool = np.isclose(k_eff_coll_nyquist, 0.0)\n\n        # --- Staggered Scheme Analysis ---\n        \n        # Calculate the relative phase error ratio r(k) = k_eff(k)/k\n        # For staggered scheme, r_stag(k) = sin(k*dx/2) / (k*dx/2)\n        arg_stag = k_vec_nonzero * dx / 2.0\n        r_stag = np.sin(arg_stag) / arg_stag\n        \n        # Compute the maximum relative dispersion error\n        max_err_stag = np.max(np.abs(r_stag - 1.0))\n        \n        # Check alias suppression at k_Nyquist: k_eff(k_Nyquist) == 0?\n        # k_eff_stag(k_Nyquist) = (2/dx) * sin(pi/2) = 2/dx != 0\n        k_eff_stag_nyquist = (2.0 / dx) * np.sin(k_nyquist * dx / 2.0)\n        alias_stag_bool = np.isclose(k_eff_stag_nyquist, 0.0)\n        \n        # --- Comparison and Formatting ---\n\n        # Determine if the staggered scheme has strictly smaller max error\n        improvement_bool = max_err_stag  max_err_coll\n        \n        # Format the results for this case into a string with no spaces,\n        # 8 decimal places for floats, and lowercase booleans.\n        case_result_str = (\n            f\"[\"\n            f\"{str(improvement_bool).lower()},\"\n            f\"{max_err_coll:.8f},\"\n            f\"{max_err_stag:.8f},\"\n            f\"{str(alias_coll_bool).lower()},\"\n            f\"{str(alias_stag_bool).lower()}\"\n            f\"]\"\n        )\n        all_results_str.append(case_result_str)\n        \n    # Final print statement in the exact required format: [[...],[...],...]\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "3598094"}]}