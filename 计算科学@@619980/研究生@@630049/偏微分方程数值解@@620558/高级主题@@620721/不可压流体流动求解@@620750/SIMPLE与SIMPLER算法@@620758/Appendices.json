{"hands_on_practices": [{"introduction": "在同位网格 (collocated grid) 上求解不可压流动时，一个常见的数值难题是棋盘格 (checkerboard) 压力振荡的出现。这种现象源于离散算子的选择不当，未能有效耦合相邻节点的压力值。本练习将通过对比一种“朴素”的算子和一种“亥姆霍兹一致” (Helmholtz-consistent) 的算子来深入探讨此问题，从而揭示 Rhie-Chow 插值等稳定化技术背后的核心原理。[@problem_id:3443051]", "problem": "考虑二维周期性域上的稳态、常粘度、不可压缩斯托克斯方程组，表示为：\n$$\n-\\nu \\nabla^2 \\mathbf{u} + \\nabla p = \\mathbf{f}, \\quad \\nabla \\cdot \\mathbf{u} = 0,\n$$\n其中 $\\nu$ 是运动粘度，$\\mathbf{u}$ 是速度， $p$ 是运动压力。在同位均匀网格上，于一个周期性的 $N_x \\times N_y$ 网格上定义网格中心场，网格间距为 $\\Delta x = 1/N_x$ 和 $\\Delta y = 1/N_y$。压力耦合方程组的半隐式方法 (Semi-Implicit Method for Pressure-Linked Equations, SIMPLE) 及其修正版 (SIMPLER) 通过构建面法向质量通量并求解一个由离散连续性约束导出的压力方程来强制执行离散质量守恒。在同位网格配置中，一个众所周知的问题是出现波长为两个单元的虚假压力振荡（即所谓的棋盘格现象），这通常通过 Rhie–Chow 插值来抑制。在本问题中，您将用一种基于离散亥姆霍兹分解 $\\mathbf{u} = \\nabla \\phi + \\nabla \\times \\boldsymbol{\\psi}$ 的一致性压力梯度重构方法来取代 Rhie–Chow 插值，并测试这种方法是否能抑制棋盘格现象。\n\n在周期性均匀网格上，仅使用以下基本、从网格中心到网格面的算子：\n\n- 一个由中心差分定义的离散网格中心梯度 $G_c$，\n$$\nG_c p\\big|_{i,j} = \\left( \\frac{p_{i+1,j} - p_{i-1,j}}{2\\Delta x}, \\frac{p_{i,j+1} - p_{i,j-1}}{2\\Delta y} \\right).\n$$\n\n- 一个离散插值 $I_{c\\to f}$，它通过对面两侧相邻单元进行算术平均，将网格中心矢量映射到面中心。\n\n- 一个离散面法向梯度 $G_f$，它直接作用于网格中心标量场，通过跨面的前向差分生成面中心的法向梯度，例如在单元 $(i,j)$ 和 $(i+1,j)$ 之间的东侧面上，\n$$\n(G_f p)_e\\big|_{i+\\frac{1}{2},j} = \\frac{p_{i+1,j} - p_{i,j}}{\\Delta x},\n$$\n西、北、南侧面同理。\n\n- 一个离散散度 $D_{f\\to c}$，它通过面法向分量的差值除以网格间距，将面中心通量映射到网格中心标量，\n$$\nD_{f\\to c} \\mathbf{w}\\big|_{i,j} = \\frac{w_e\\big|_{i+\\frac{1}{2},j} - w_w\\big|_{i-\\frac{1}{2},j}}{\\Delta x} + \\frac{w_n\\big|_{i,j+\\frac{1}{2}} - w_s\\big|_{i,j-\\frac{1}{2}}}{\\Delta y}.\n$$\n\n您将比较在 SIMPLE/SIMPLER 系列算法中用于同位压力-速度耦合的两种压力梯度重构方法：\n\n1. 一种朴素重构，首先计算网格中心梯度 $G_c p$，然后将其插值到面中心，即 $g_f^{\\mathrm{naive}} = I_{c\\to f}(G_c p)$。这种方法模拟了在没有 Rhie–Chow 插值的 SIMPLE 算法中，导致同位网格上棋盘格解耦的面通量构造方式。\n\n2. 一种亥姆霍兹一致性重构，它使用在面中心计算的标量势的梯度，即 $g_f^{\\mathrm{proj}} = G_f \\phi$。在压力修正步中，势 $\\phi$ 是压力本身或压力修正场。这种方法与离散亥姆霍兹分解是一致的，因为 $D_{f\\to c} G_f \\phi$ 是离散标量拉普拉斯算子 $L\\phi$，即一个矢量场在无旋子空间上的投影。\n\n将棋盘格压力场定义为\n$$\np_{i,j}^{\\mathrm{cb}} = (-1)^{i+j}, \\quad 0 \\leq i  N_x,\\quad 0 \\leq j  N_y,\n$$\n在周期性网格上。\n\n您的任务：\n\n- 在周期性网格上，严格按照上述定义实现四个离散算子 $G_c$、$I_{c\\to f}$、$G_f$ 和 $D_{f\\to c}$。\n\n- 对于棋盘格场 $p^{\\mathrm{cb}}$，计算两种面梯度重构 $g_f^{\\mathrm{naive}}$ 和 $g_f^{\\mathrm{proj}}$，然后计算它们对应的离散散度 $r^{\\mathrm{naive}} = D_{f\\to c} g_f^{\\mathrm{naive}}$ 和 $r^{\\mathrm{proj}} = D_{f\\to c} g_f^{\\mathrm{proj}}$。\n\n- 报告欧几里得范数 $\\|r^{\\mathrm{naive}}\\|_2$ 和 $\\|r^{\\mathrm{proj}}\\|_2$。$\\|r^{\\mathrm{naive}}\\|_2$ 的值接近于零表示棋盘格模式对于朴素构造是“不可见”的（棋盘格现象将持续存在）。严格为正的 $\\|r^{\\mathrm{proj}}\\|_2$ 值则表明亥姆霍兹一致性重构能够检测到棋盘格模式，并且在与 SIMPLE 或 SIMPLER 耦合时会抑制它。\n\n- 此外，构造两个线性算子（以无矩阵作用的方式应用）：\n  - $L_{\\mathrm{naive}} = D_{f\\to c} \\circ I_{c\\to f} \\circ G_c$，\n  - $L_{\\mathrm{proj}} = D_{f\\to c} \\circ G_f$，\n并计算它们在棋盘格矢量 $x = p^{\\mathrm{cb}}$ 上的瑞利商，\n$$\n\\rho_{\\mathrm{naive}} = \\frac{\\langle x,\\; L_{\\mathrm{naive}} x\\rangle}{\\langle x, x\\rangle},\\quad\n\\rho_{\\mathrm{proj}} = \\frac{\\langle x,\\; L_{\\mathrm{proj}} x\\rangle}{\\langle x, x\\rangle}.\n$$\n$\\rho_{\\mathrm{naive}} \\approx 0$ 的值揭示了一个近零模态，而显著非零的瑞利商 $\\rho_{\\mathrm{proj}}$ 则表明了由投影一致性重构引入的耦合。\n\n测试套件：\n- 测试用例1（正常路径）：$(N_x, N_y, \\nu) = (16, 16, 1.0)$。以浮点数形式输出列表 $[\\|r^{\\mathrm{naive}}\\|_2, \\|r^{\\mathrm{proj}}\\|_2]$。\n- 测试用例2（奇数维度边缘情况）：$(N_x, N_y, \\nu) = (15, 17, 1.0)$。以浮点数形式输出列表 $[\\|r^{\\mathrm{naive}}\\|_2, \\|r^{\\mathrm{proj}}\\|_2]$。\n- 测试用例3（在不同粘度下的算子能量检查）：$(N_x, N_y, \\nu) = (32, 32, 0.1)$。以浮点数形式输出列表 $[\\rho_{\\mathrm{naive}}, \\rho_{\\mathrm{proj}}]$。请注意，在这种斯托克斯极限构造中，$\\nu$ 不会出现在 $L_{\\mathrm{naive}}$ 或 $L_{\\mathrm{proj}}$ 中，包含它只是为了强调重构中棋盘格可检测性与物理参数的无关性。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按测试用例顺序排列的三个列表，列表之间用逗号分隔，并用方括号括起来。例如，一个有效的输出格式是\n$$\n[[a_1,a_2],[b_1,b_2],[c_1,c_2]].\n$$\n所有数值输出必须是浮点数。本问题不需要物理单位或角度单位。不得使用百分比。", "solution": "该问题要求在同位网格上分析两种不同的离散压力梯度重构方法，以用于不可压缩斯托克斯方程的数值求解。其目标是确定它们检测并进而抑制虚假棋盘格压力振荡的能力。这通过实现定义的离散算子，将它们应用于一个典型的棋盘格压力场，并评估所得的范数和瑞利商来完成。\n\n问题的核心在于梯度和散度算子的不同离散化方法的属性，这些算子组合起来形成离散拉普拉斯算子。在同位网格上，中心差分算子的朴素组合可能具有一个非平凡的零空间，其中包含高频模式，例如棋盘格模式。因此，这些模式对于像 SIMPLE 这样的算法中的压力修正机制是“不可见”的，从而允许非物理振荡持续存在。所提出的一致性离散化方法，其零空间中不应包含这些高频模式。\n\n首先，我们建立计算域和测试场。该域是一个二维周期性矩形，被离散化为一个 $N_x \\times N_y$ 的单元网格。网格间距为 $\\Delta x = 1/N_x$ 和 $\\Delta y = 1/N_y$。棋盘格压力场在单元中心 $(i,j)$ 处定义为：\n$$\np^{\\mathrm{cb}}_{i,j} = (-1)^{i+j}, \\quad \\text{for } 0 \\leq i  N_x, \\; 0 \\leq j  N_y\n$$\n该场代表了网格上可表示的最高频率模式。\n\n我们被要求在这个周期性网格上实现四个离散算子。周期性将通过数组滚动操作来高效处理，这种操作能自然地环绕边界。\n\n1.  **网格中心梯度 ($G_c$)：** 该算子将一个网格中心标量场 $p$ 映射到一个网格中心矢量场。\n    $$\n    (G_c p)_{x,i,j} = \\frac{p_{i+1,j} - p_{i-1,j}}{2\\Delta x}, \\quad (G_c p)_{y,i,j} = \\frac{p_{i,j+1} - p_{i,j-1}}{2\\Delta y}\n    $$\n2.  **从网格中心到网格面的插值 ($I_{c\\to f}$)：** 该算子将一个网格中心矢量场 $\\mathbf{v}$ 映射到一个面法向场。面上某点的法向分量是来自两个相邻单元的 $\\mathbf{v}$ 的法向分量的算术平均值。对于矢量场 $\\mathbf{v}=(v_x, v_y)$：\n    -   在单元 $(i,j)$ 的东侧面，法向（x-分量）通量为 $w_e = \\frac{(v_x)_{i,j} + (v_x)_{i+1,j}}{2}$。\n    -   在单元 $(i,j)$ 的北侧面，法向（y-分量）通量为 $w_n = \\frac{(v_y)_{i,j} + (v_y)_{i,j+1}}{2}$。\n3.  **面法向梯度 ($G_f$)：** 该算子使用一个两点模板将网格中心标量场 $p$ 直接映射到一个面法向场。\n    -   在单元 $(i,j)$ 的东侧面：$(G_f p)_e = \\frac{p_{i+1,j} - p_{i,j}}{\\Delta x}$。\n    -   在单元 $(i,j)$ 的北侧面：$(G_f p)_n = \\frac{p_{i,j+1} - p_{i,j}}{\\Delta y}$。\n4.  **从网格面到网格中心的散度 ($D_{f\\to c}$)：** 该算子将一个面法向场 $\\mathbf{w}$ 映射到一个网格中心标量场。\n    $$\n    D_{f\\to c} \\mathbf{w}\\big|_{i,j} = \\frac{w_e\\big|_{i+\\frac{1}{2},j} - w_w\\big|_{i-\\frac{1}{2},j}}{\\Delta x} + \\frac{w_n\\big|_{i,j+\\frac{1}{2}} - w_s\\big|_{i,j-\\frac{1}{2}}}{\\Delta y}\n    $$\n\n接下来，我们分析将两个复合算子 $L_{\\mathrm{naive}} = D_{f\\to c} \\circ I_{c\\to f} \\circ G_c$ 和 $L_{\\mathrm{proj}} = D_{f\\to c} \\circ G_f$ 应用于棋盘格场 $p^{\\mathrm{cb}}$ 时的行为。\n\n**朴素重构分析**\n\n我们将 $G_c$ 应用于 $p^{\\mathrm{cb}}$：\n$$\n(G_c p^{\\mathrm{cb}})_{x,i,j} = \\frac{(-1)^{(i+1)+j} - (-1)^{(i-1)+j}}{2\\Delta x} = \\frac{(-1)^{i+j+1} - (-1)^{i+j-1}}{2\\Delta x} = \\frac{-(-1)^{i+j} - (-(-1)^{i+j}))}{2\\Delta x} = 0\n$$\n同理，$(G_c p^{\\mathrm{cb}})_{y,i,j}=0$。因此，$G_c(p^{\\mathrm{cb}}) = \\mathbf{0}$。\n因此，对此零场进行的任何后续操作也将得到零：\n$$\ng_f^{\\mathrm{naive}} = I_{c\\to f}(G_c p^{\\mathrm{cb}}) = I_{c\\to f}(\\mathbf{0}) = \\mathbf{0}\n$$\n$$\nr^{\\mathrm{naive}} = D_{f\\to c}(g_f^{\\mathrm{naive}}) = D_{f\\to c}(\\mathbf{0}) = 0\n$$\n这意味着棋盘格模式位于算子 $L_{\\mathrm{naive}}$ 的零空间中。因此，其范数 $\\|r^{\\mathrm{naive}}\\|_2$ 和瑞利商 $\\rho_{\\mathrm{naive}}$ 都将精确为零。朴素重构对此模式是“盲目”的。\n\n**亥姆霍兹一致性重构分析**\n\n我们将 $G_f$ 应用于 $p^{\\mathrm{cb}}$。我们计算面法向分量。在单元 $(i,j)$ 的东侧面：\n$$\n(G_f p^{\\mathrm{cb}})_e = \\frac{p^{\\mathrm{cb}}_{i+1,j} - p^{\\mathrm{cb}}_{i,j}}{\\Delta x} = \\frac{(-1)^{i+1+j} - (-1)^{i+j}}{\\Delta x} = \\frac{-(-1)^{i+j} - (-1)^{i+j}}{\\Delta x} = -\\frac{2}{\\Delta x}(-1)^{i+j}\n$$\n在单元 $(i,j)$ 的北侧面：\n$$\n(G_f p^{\\mathrm{cb}})_n = \\frac{p^{\\mathrm{cb}}_{i,j+1} - p^{\\mathrm{cb}}_{i,j}}{\\Delta y} = \\frac{(-1)^{i+j+1} - (-1)^{i+j}}{\\Delta y} = -\\frac{2}{\\Delta y}(-1)^{i+j}\n$$\n这些面法向梯度分量显然是非零的。现在，将散度算子 $D_{f\\to c}$ 应用于此场 $g_f^{\\mathrm{proj}} = G_f p^{\\mathrm{cb}}$：\n$$\nr^{\\mathrm{proj}}_{i,j} = \\frac{(g_f^{\\mathrm{proj}})_e - (g_f^{\\mathrm{proj}})_w}{\\Delta x} + \\frac{(g_f^{\\mathrm{proj}})_n - (g_f^{\\mathrm{proj}})_s}{\\Delta y}\n$$\n这里，$(g_f^{\\mathrm{proj}})_e$ 是上面计算的单元 $(i,j)$ 的东侧面梯度，而 $(g_f^{\\mathrm{proj}})_w$ 是单元 $(i-1,j)$ 的东侧面梯度，也就是单元 $(i,j)$ 的西侧面梯度。\n$$\n(g_f^{\\mathrm{proj}})_w = -\\frac{2}{\\Delta x}(-1)^{(i-1)+j} = \\frac{2}{\\Delta x}(-1)^{i+j}\n$$\n同理，$(g_f^{\\mathrm{proj}})_s = \\frac{2}{\\Delta y}(-1)^{i+j}$。将这些代入散度公式：\n$$\nr^{\\mathrm{proj}}_{i,j} = \\frac{-\\frac{2}{\\Delta x}(-1)^{i+j} - \\frac{2}{\\Delta x}(-1)^{i+j}}{\\Delta x} + \\frac{-\\frac{2}{\\Delta y}(-1)^{i+j} - \\frac{2}{\\Delta y}(-1)^{i+j}}{\\Delta y}\n$$\n$$\nr^{\\mathrm{proj}}_{i,j} = \\left(-\\frac{4}{\\Delta x^2} - \\frac{4}{\\Delta y^2}\\right)(-1)^{i+j} = -4(N_x^2 + N_y^2) p^{\\mathrm{cb}}_{i,j}\n$$\n这表明 $L_{\\mathrm{proj}}(p^{\\mathrm{cb}})$ 是 $p^{\\mathrm{cb}}$ 的一个非零倍数。因此，范数 $\\|r^{\\mathrm{proj}}\\|_2$ 将严格为正。对于瑞利商，使用标准内积 $\\langle a,b\\rangle = \\sum_{i,j} a_{i,j}b_{i,j}$，我们得到：\n$$\n\\rho_{\\mathrm{proj}} = \\frac{\\langle p^{\\mathrm{cb}}, L_{\\mathrm{proj}} p^{\\mathrm{cb}}\\rangle}{\\langle p^{\\mathrm{cb}}, p^{\\mathrm{cb}}\\rangle} = \\frac{\\langle p^{\\mathrm{cb}}, -4(N_x^2 + N_y^2) p^{\\mathrm{cb}}\\rangle}{\\langle p^{\\mathrm{cb}}, p^{\\mathrm{cb}}\\rangle} = -4(N_x^2 + N_y^2)\n$$\n算子 $L_{\\mathrm{proj}} = D_{f\\to c} \\circ G_f$ 是拉普拉斯算子 $\\nabla^2$ 的标准五点模板离散化。该算子是负半定的，意味着其特征值非正 ($\\lambda \\le 0$）。因此，对于任何非恒定矢量（如棋盘格模式），其瑞利商必须严格为负。问题陈述中关于 $\\rho_{\\mathrm{proj}} > 0$ 的提法有一个微小的不准确之处；关键点在于 $\\rho_{\\mathrm{proj}}$ 是显著非零的，这表明亥姆霍兹一致性算子能够稳健地检测到棋盘格模式。这种检测机制使得压力求解器能够惩罚并抑制这种虚假模式。\n\n测试用例的计算将证实这些分析结果，得出 $\\|r^{\\mathrm{naive}}\\|_2=0$，$\\rho_{\\mathrm{naive}}=0$，以及 $\\|r^{\\mathrm{proj}}\\|_2$ 和 $\\rho_{\\mathrm{proj}}$ 的推导出的非零值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to perform the calculations for the test suite.\n    \"\"\"\n\n    class StokesOperators:\n        \"\"\"\n        A class to encapsulate the grid parameters and discrete operators.\n        \"\"\"\n        def __init__(self, Nx, Ny):\n            if not (isinstance(Nx, int) and Nx > 0 and isinstance(Ny, int) and Ny > 0):\n                raise ValueError(\"Nx and Ny must be positive integers.\")\n            self.Nx = Nx\n            self.Ny = Ny\n            self.dx = 1.0 / Nx\n            self.dy = 1.0 / Ny\n            \n            # Create checkerboard field\n            I, J = np.meshgrid(np.arange(self.Ny), np.arange(self.Nx))\n            self.p_cb = (-1.0)**(I + J)\n\n        def G_c(self, p):\n            \"\"\"\n            Cell-centered gradient (G_c) using centered differences on a periodic grid.\n            Input: p (Ny, Nx) cell-centered scalar field.\n            Output: (vx, vy) tuple of (Ny, Nx) cell-centered vector components.\n            \"\"\"\n            dp_dx = (np.roll(p, -1, axis=1) - np.roll(p, 1, axis=1)) / (2 * self.dx)\n            dp_dy = (np.roll(p, -1, axis=0) - np.roll(p, 1, axis=0)) / (2 * self.dy)\n            return (dp_dx, dp_dy)\n\n        def I_c_to_f(self, v):\n            \"\"\"\n            Interpolation from cell-centered vectors to face-normal fluxes (I_c->f).\n            Input: v = (vx, vy) tuple of (Ny, Nx) cell-centered vector components.\n            Output: (fx, fy) tuple of (Ny, Nx) face-normal flux components.\n                    fx corresponds to east/west faces.\n                    fy corresponds to north/south faces.\n            \"\"\"\n            vx, vy = v\n            # Average vx across east face of cell (i,j)\n            fx = (vx + np.roll(vx, -1, axis=1)) / 2.0\n            # Average vy across north face of cell (i,j)\n            fy = (vy + np.roll(vy, -1, axis=0)) / 2.0\n            return (fx, fy)\n\n        def G_f(self, p):\n            \"\"\"\n            Face-normal gradient (G_f) using first differences across faces.\n            Input: p (Ny, Nx) cell-centered scalar field.\n            Output: (gx, gy) tuple of (Ny, Nx) face-normal gradient components.\n            \"\"\"\n            # Gradient on east face of cell (i,j)\n            gx = (np.roll(p, -1, axis=1) - p) / self.dx\n            # Gradient on north face of cell (i,j)\n            gy = (np.roll(p, -1, axis=0) - p) / self.dy\n            return (gx, gy)\n\n        def D_f_to_c(self, w):\n            \"\"\"\n            Divergence from face-normal fluxes to cell centers (D_f->c).\n            Input: w = (wx, wy) tuple of (Ny, Nx) face-normal flux components.\n            Output: (Ny, Nx) cell-centered scalar divergence field.\n            \"\"\"\n            wx, wy = w\n            # Difference of fluxes in x-direction (east - west)\n            div_x = (wx - np.roll(wx, 1, axis=1)) / self.dx\n            # Difference of fluxes in y-direction (north - south)\n            div_y = (wy - np.roll(wy, 1, axis=0)) / self.dy\n            return div_x + div_y\n\n        def L_naive(self, p):\n            \"\"\"Matrix-free action of the naive operator L_naive = D . I . G_c.\"\"\"\n            return self.D_f_to_c(self.I_c_to_f(self.G_c(p)))\n\n        def L_proj(self, p):\n            \"\"\"Matrix-free action of the projection operator L_proj = D . G_f.\"\"\"\n            return self.D_f_to_c(self.G_f(p))\n\n    test_cases = [\n        {'case': 1, 'params': (16, 16, 1.0), 'task': 'norm'},\n        {'case': 2, 'params': (15, 17, 1.0), 'task': 'norm'},\n        {'case': 3, 'params': (32, 32, 0.1), 'task': 'quotient'},\n    ]\n\n    results = []\n\n    for test in test_cases:\n        Nx, Ny, nu = test['params']\n        ops = StokesOperators(Nx, Ny)\n        p_cb = ops.p_cb\n\n        if test['task'] == 'norm':\n            # Naive reconstruction\n            r_naive = ops.L_naive(p_cb)\n            norm_naive = np.linalg.norm(r_naive)\n\n            # Projection-based reconstruction\n            r_proj = ops.L_proj(p_cb)\n            norm_proj = np.linalg.norm(r_proj)\n            \n            results.append([norm_naive, norm_proj])\n\n        elif test['task'] == 'quotient':\n            x = p_cb.flatten()\n            norm_x_sq = np.vdot(x, x)\n\n            # Naive Rayleigh quotient\n            y_naive = ops.L_naive(p_cb).flatten()\n            rho_naive = np.vdot(x, y_naive) / norm_x_sq\n\n            # Projection-based Rayleigh quotient\n            y_proj = ops.L_proj(p_cb).flatten()\n            rho_proj = np.vdot(x, y_proj) / norm_x_sq\n\n            results.append([rho_naive, rho_proj])\n\n    # Format output as specified: [[a1,a2],[b1,b2],[c1,c2]]\n    output_str_parts = []\n    for res_pair in results:\n        output_str_parts.append(f\"[{res_pair[0]},{res_pair[1]}]\")\n    \n    final_output = f\"[{','.join(output_str_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3443051"}, {"introduction": "在构建数值格式后，验证其实现的正确性和精度是至关重要的一步。本练习将介绍一种强大的基准测试技术——“制造解方法” (Method of Manufactured Solutions, MMS)。你将通过此方法验证 SIMPLE 族算法的关键组成部分——压力修正方程——是否达到了其理论上的二阶收敛精度，这是确保模拟结果可靠性的基本要求。[@problem_id:3362285]", "problem": "考虑在单位正方形 $\\Omega = (0,1)\\times(0,1)$ 内，具有恒定密度 $\\rho$ 和运动粘度 $\\nu$ 的牛顿流体的稳态、二维、不可压缩流动。其控制方程为稳态不可压缩 Navier–Stokes 方程，\n$$\n\\nabla\\cdot \\mathbf{u} = 0,\\quad\n\\rho\\,(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\rho\\,\\nu\\,\\nabla^2 \\mathbf{u} + \\mathbf{f},\n$$\n速度边界条件为无滑移条件，压力修正的边界条件为在 $\\partial\\Omega$ 上施加如下文所述的 Dirichlet 边界条件。此处 $\\mathbf{u} = (u,v)$ 为速度场，$p$ 为压力。\n\n您将采用人工解法（Method of Manufactured Solutions）构造一个精确解析解，并用它来验证由三种压力-速度耦合算法计算出的压力修正 $p'$ 的空间收敛阶。这三种算法分别是：压力耦合方程组的半隐式方法（SIMPLE）、压力耦合方程组的修正半隐式方法（SIMPLER）以及压力耦合方程组的一致半隐式方法（SIMPLEC）。\n\n构造的解析解：\n- 选择速度场\n$$\nu(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y),\\qquad v(x,y) = -\\cos(\\pi x)\\,\\sin(\\pi y),\n$$\n该速度场对所有 $(x,y)\\in\\Omega$ 均满足 $\\nabla\\cdot\\mathbf{u}=0$。选择压力场\n$$\np(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n该压力场在 $\\partial\\Omega$ 上满足 $p(x,y)=0$。利用这些场，可以构造一个体积力 $\\mathbf{f}(x,y)$，使得 $(\\mathbf{u},p)$ 成为稳态方程的精确解。\n\nSIMPLE 族算法中的压力修正方程：\n- 在压力-速度耦合框架中，压力修正 $p'$ 满足一个类泊松方程（Poisson-type equation），该方程是通过对预测的质量通量强制施加质量守恒而得到的。在均匀网格上，采用中心差分格式且动量方程对角线元素为常数时，压力修正方程简化为\n$$\n\\nabla^2 p'(x,y) = s(x,y),\n$$\n并在边界 $\\partial\\Omega$ 上施加齐次 Dirichlet 边界条件 $p'(x,y)=0$。为了验证，设构造的压力修正为 $p'(x,y) = p(x,y)$，并假设猜测压力为零，从而一致地定义源项为\n$$\ns(x,y) = -\\nabla^2 p'(x,y) = 2\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n使得压力修正方程的精确解为 $p'(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y)$。\n\n您的任务：\n- 从稳态不可压缩 Navier–Stokes 方程和 SIMPLE 族算法中压力修正方程的定义出发，证明在给定的人工假设（均匀网格、恒定系数、中心差分、Dirichlet 边界数据）下，SIMPLE、SIMPLER 和 SIMPLEC 算法的离散化压力修正方程均可简化为对 $p'(x,y)$ 的标量泊松问题的同一个二阶中心差分近似。\n\n- 实现一个求解器，在一系列覆盖 $\\Omega$ 的均匀笛卡尔网格上，使用二阶中心差分来近似 $p'(x,y)$。网格由每个坐标方向上的等分数量 $N\\in\\{8,16,32,64\\}$ 指定，因此网格间距为 $h=1/N$。未知量位于每个方向上的 $N-1$ 个内部点处，且边界上 $p'=0$。对每个 $N$，组装标准的五点离散拉普拉斯算子，并求解得到的线性系统。\n\n- 对每个 $N$，计算数值解 $p'_h$ 相对于精确人工解 $p'(x,y)$ 的离散 $\\ell^2$ 误差。离散 $\\ell^2$ 误差必须定义为\n$$\nE(h) = \\left(\\sum_{i=1}^{N-1}\\sum_{j=1}^{N-1} \\left(p'_h(x_i,y_j) - p'(x_i,y_j)\\right)^2\\right)^{1/2}\\,h,\n$$\n其中 $x_i=i\\,h$ 且 $y_j=j\\,h$，对于 $i=1,\\dots,N-1$ 和 $j=1,\\dots,N-1$。\n\n- 对于每种算法变体（SIMPLE、SIMPLER、SIMPLEC），使用两套最细的网格计算 $p'$ 的观测收敛阶 $r$，公式为\n$$\nr = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)},\n$$\n其中 $h=1/32$ 且 $h/2=1/64$。在这种人工设定的情况下，所有三种算法对压力修正方程使用相同的空间离散格式，因此观测到的 $r$ 值应当相等且接近于 2。\n\n测试套件和输出规范：\n- 使用网格尺寸 $N\\in\\{8,16,32,64\\}$ 作为测试套件，以覆盖粗网格的边缘情况以及逐渐加密的网格。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{SIMPLE},\\text{SIMPLER},\\text{SIMPLEC}]$。列表中的每个条目都是按上述方式计算的浮点数 $r$ 值，例如 $[r_{\\text{SIMPLE}},r_{\\text{SIMPLER}},r_{\\text{SIMPLEC}}]$。", "solution": "控制方程为稳态不可压缩 Navier–Stokes 方程，\n$$\n\\nabla\\cdot \\mathbf{u} = 0,\\qquad\n\\rho\\,(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\rho\\,\\nu\\,\\nabla^2 \\mathbf{u} + \\mathbf{f}.\n$$\n我们选择构造的场\n$$\nu(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y),\\quad v(x,y) = -\\cos(\\pi x)\\,\\sin(\\pi y),\\quad p(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n这些场满足不可压缩性条件，因为\n$$\n\\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}\n= \\pi\\cos(\\pi x)\\,\\cos(\\pi y) - \\pi\\cos(\\pi x)\\,\\cos(\\pi y) = 0.\n$$\n给定 $\\rho$ 和 $\\nu$，可将 $(\\mathbf{u},p)$ 代入动量方程，计算出使 $(\\mathbf{u},p)$ 成为精确解的体积力 $\\mathbf{f}(x,y)$；这利用了控制定律的基本原理。\n\n在压力耦合方程组的半隐式方法（Semi-Implicit Method for Pressure-Linked Equations）族中，会引入一个由猜测压力计算得到的中间速度 $\\mathbf{u}^*$，然后通过压力修正 $p'$ 来校正质量通量以满足连续性方程。该修正步骤满足一个由离散化的连续性方程和离散化的动量方程推导出的压力修正方程。在一般的有限体积形式中，离散的压力修正方程可以写为\n$$\n\\sum_{f\\in \\text{faces}} \\rho\\,d_f\\,\\left(p'_N - p'_P\\right) = \\sum_{f\\in \\text{faces}} \\dot{m}^*_f,\n$$\n其中 $d_f$ 是代表动量方程对角线元素倒数和几何因子的系数，$P$ 表示当前考虑的单元，$N$ 表示相邻单元，$\\dot{m}^*_f$ 是不满足连续性方程的预测质量通量。在具有恒定物性和采用中心差分的均匀网格上，动量方程的对角线元素 $a_P$ 在所有单元上都是常数，面系数 $d_f$ 也变为常数，预测质量通量的离散散度简化为 $p'$ 离散拉普拉斯算子的一个均匀缩放。因此，修正方程简化为标量泊松问题\n$$\n\\nabla^2 p'(x,y) = s(x,y)\n$$\n当猜测压力为零且精确压力在边界上为零时，在 $\\partial\\Omega$ 上对 $p'$ 施加齐次 Dirichlet 边界条件。此简化仅使用了算法的核心定义和结构，未调用任何快捷公式。压力耦合方程组的半隐式方法（SIMPLE）、修正的半隐式方法（SIMPLER）以及一致的半隐式方法（SIMPLEC）之间的区别在于中间速度 $\\mathbf{u}^*$ 和耦合系数的构造方式，但在当前人工构造的、系数均匀的情况下，它们对压力修正方程的空间离散是完全相同的。\n\n为了构造源项，我们取 $p'(x,y) = p(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y)$（这与猜测压力为零的情况一致），于是\n$$\n\\nabla^2 p'(x,y) = \\frac{\\partial^2}{\\partial x^2}\\sin(\\pi x)\\,\\sin(\\pi y) + \\frac{\\partial^2}{\\partial y^2}\\sin(\\pi x)\\,\\sin(\\pi y)\n= -\\pi^2\\sin(\\pi x)\\,\\sin(\\pi y) - \\pi^2\\sin(\\pi x)\\,\\sin(\\pi y) = -2\\pi^2\\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n因此\n$$\ns(x,y) = -\\nabla^2 p'(x,y) = 2\\pi^2\\sin(\\pi x)\\,\\sin(\\pi y).\n$$\n\n我们在均匀网格上离散化泊松方程，网格间距为 $h=1/N$，内部点为 $(x_i,y_j) = (i h, j h)$，其中 $i=1,\\dots,N-1$ 且 $j=1,\\dots,N-1$。在笛卡尔网格上，对 $\\nabla^2 p'$ 的标准二阶中心差分近似得到五点差分格式，\n$$\n\\left(\\nabla^2 p'\\right)_{i,j} \\approx \\frac{p'_{i+1,j} - 2 p'_{i,j} + p'_{i-1,j}}{h^2} + \\frac{p'_{i,j+1} - 2 p'_{i,j} + p'_{i,j-1}}{h^2},\n$$\n该格式提供了关于 $h$ 的二阶近似。在 $\\partial\\Omega$ 上应用齐次 Dirichlet 边界条件 $p'=0$，离散系统呈现为矩阵形式\n$$\n\\mathbf{L}\\,\\mathbf{p} = h^2\\,\\mathbf{s},\n$$\n其中 $\\mathbf{L}$ 是使用五点差分格式的二维离散拉普拉斯算子，$\\mathbf{p}$ 和 $\\mathbf{s}$ 是内部节点上未知量和源项值的向量。\n\n离散 $\\ell^2$ 误差定义为\n$$\nE(h) = \\left(\\sum_{i=1}^{N-1}\\sum_{j=1}^{N-1} \\left(p'_h(x_i,y_j) - p'(x_i,y_j)\\right)^2\\right)^{1/2}\\,h,\n$$\n这是对连续 $L^2$ 范数的一致性求积。对于二阶中心差分，截断误差为 $\\mathcal{O}(h^2)$，并且在均匀网格和 Dirichlet 边界条件下，对于光滑解，离散解的收敛阶为 2，因此我们预期\n$$\nE(h) \\approx C\\,h^2\n$$\n对于某个常数 $C$，这导出的观测收敛阶为\n$$\nr = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)} \\approx 2.\n$$\n\n在所述的人工设定下，压力耦合方程组的半隐式方法（SIMPLE）、修正的半隐式方法（SIMPLER）以及一致的半隐式方法（SIMPLEC）对压力修正方程采用相同的空间离散格式，因此当线性系统求解至收敛时，它们会产生相同的 $p'$ 解。因此，计算 $h=1/32$ 和 $h/2=1/64$ 时的 $E(h)$ 并按上述方式构造 $r$ 时，应得到三个相等且接近 2 的值。该实现使用二维离散拉普拉斯算子的克罗内克和（Kronecker-sum）构造方法以及稀疏直接线性求解器，以消除迭代效应并分离出空间离散误差，这与基于原理的推导和验证任务相符。\n\n程序评估了 $N\\in\\{8,16,32,64\\}$ 时的误差，并报告了根据两套最细网格计算出的三个观测阶数 $[r_{\\text{SIMPLE}}, r_{\\text{SIMPLER}}, r_{\\text{SIMPLEC}}]$，从而在这种人工构造的、系数均匀的极限情况下，验证了所有三种算法中 $p'$ 在网格加密下的二阶收敛性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, kron, identity\nfrom scipy.sparse.linalg import spsolve\n\ndef build_poisson_matrix(m):\n    \"\"\"\n    Build the 2D Poisson matrix with Dirichlet boundary conditions\n    on an m x m interior grid using the 5-point Laplacian.\n    \"\"\"\n    # 1D Laplacian (Dirichlet interior nodes): tridiagonal [1, -2, 1]\n    main = -2.0 * np.ones(m)\n    off = 1.0 * np.ones(m - 1)\n    L1 = diags([off, main, off], offsets=[-1, 0, 1], format='csr')\n    I = identity(m, format='csr')\n    # 2D Laplacian via Kronecker sum\n    L2 = kron(I, L1) + kron(L1, I)\n    return L2\n\ndef manufactured_source_and_exact(N):\n    \"\"\"\n    Compute source term s(x,y) = 2*pi^2*sin(pi*x)*sin(pi*y)\n    and exact p'(x,y) at interior points for grid size N (spacing h=1/N).\n    Returns (s_flat, p_exact_flat).\n    \"\"\"\n    h = 1.0 / N\n    m = N - 1\n    x = np.linspace(h, 1.0 - h, m)\n    y = np.linspace(h, 1.0 - h, m)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    p_exact = np.sin(np.pi * X) * np.sin(np.pi * Y)\n    s = 2.0 * (np.pi ** 2) * p_exact\n    return s.ravel(), p_exact.ravel()\n\ndef solve_poisson(N):\n    \"\"\"\n    Solve L p = -h^2 * s for p on interior grid for given N,\n    with exact source manufactured from p'(x,y) = sin(pi*x)*sin(pi*y).\n    Returns L2 error E(h) with discrete quadrature.\n    \"\"\"\n    h = 1.0 / N\n    m = N - 1\n    # Note: The problem discretizes \\nabla^2 p = s to L_h p = s, where L_h contains 1/h^2.\n    # This leads to (1/h^2) L p_num = s_exact, or L p_num = h^2 s_exact.\n    # L here is the h-independent matrix with [-4, 1, 1, 1, 1] stencil.\n    # The build_poisson_matrix() returns a matrix with [-2, 1, 1] on diagonal blocks and identity off-diagonal.\n    # Multiplying by -1 to match convention L = -\\nabla^2.\n    L = -build_poisson_matrix(m)\n    s_flat, p_exact_flat = manufactured_source_and_exact(N)\n    rhs = (h ** 2) * s_flat\n    # This is equivalent to solving A p_num = s_flat, where A = L/h^2 is the discrete Laplacian.\n    p_num = spsolve(L, rhs)\n    # Discrete L2 error: sqrt(sum((error)^2)) * h\n    err = p_num - p_exact_flat\n    E = np.sqrt(np.sum(err ** 2)) * h\n    return E\n\ndef observed_order(e_h, e_h2):\n    \"\"\"\n    Compute observed order r = log(e_h/e_h2)/log(2),\n    where h2 = h/2 (i.e., N doubled).\n    \"\"\"\n    return np.log(e_h / e_h2) / np.log(2.0)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    grid_sizes = [8, 16, 32, 64]\n\n    # Compute errors for each grid size.\n    errors = {}\n    for N in grid_sizes:\n        errors[N] = solve_poisson(N)\n\n    # Compute observed order using the two finest grids N=32 and N=64.\n    e32 = errors[32]\n    e64 = errors[64]\n    r = observed_order(e32, e64)\n\n    # In this manufactured uniform-coefficient setting, SIMPLE, SIMPLER, and SIMPLEC\n    # produce identical spatial discretizations for the pressure correction equation,\n    # hence identical observed orders.\n    results = [r, r, r]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3362285"}, {"introduction": "SIMPLE 和 SIMPLER 是两种相关但截然不同的压力-速度耦合算法，它们具有不同的性能特点。本练习提供了一个定量比较它们收敛效率的框架。通过分析合成的残差历史数据，你将学习如何衡量迭代次数和渐近收敛速率等关键性能指标，从而能够对不同算法的优劣进行客观评估。[@problem_id:3442976]", "problem": "考虑单位方形域上的稳态、不可压缩、层流顶盖驱动方腔问题。其控制方程为不可压缩 Navier–Stokes 方程：质量守恒方程，由 $\\nabla \\cdot \\mathbf{u} = 0$ 给出；以及动量守恒方程，由 $\\rho (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} = -\\nabla p + \\mu \\nabla^2 \\mathbf{u}$ 给出，其中 $\\mathbf{u}$ 是速度场，$p$ 是压力场。在诸如压力耦合方程组的半隐式方法 (Semi-Implicit Method for Pressure-Linked Equations, SIMPLE) 及其修正算法 (SIMPLE Revised, SIMPLER) 等迭代式压力-速度耦合方案中，外部不动点过程会产生与离散方程相关的一系列残差向量 $\\{\\mathbf{r}_k\\}_{k \\geq 0}$，其中每个 $\\mathbf{r}_k$ 是耦合的动量方程和连续性方程的堆叠残差。在一致性线性化和欠松弛的条件下，该外部迭代可以建模为一个不动点迭代 $\\mathbf{r}_{k+1} \\approx \\mathbf{M} \\mathbf{r}_k$，其迭代矩阵 $\\mathbf{M}$ 取决于算法的耦合策略。对于足够大的 $k$，残差的范数通常呈现几何衰减，其特征是一个与谱半径 $\\rho(\\mathbf{M})$ 相关的渐近收敛因子。\n\n您的任务是实现一个诊断方案，给定在相同的离散化选择、线性求解器和松弛参数下为顶盖驱动方腔问题构建的、合成的但科学上合理的残差历史，比较压力耦合方程组的半隐式方法 (SIMPLE) 和 SIMPLE 修正算法 (SIMPLER) 在迭代次数和残差衰减方面的表现。这些合成历史被设计成使得任何观察到的差异都仅归因于算法耦合策略的不同，同时保持离散化和线性求解器的选择固定。\n\n为确保普遍适用性和纯数学规范，每种算法 $A \\in \\{\\text{SIMPLE}, \\text{SIMPLER}\\}$ 的残差范数历史由一个受控的参数化模型定义：\n$$\nr_k^{(A)} \\;=\\; r_0 \\,\\frac{\\left(c_A\\right)^k \\left(1 + a \\cos(\\pi k)\\right)}{1+a}, \\quad k = 0,1,2,\\dots,K,\n$$\n其中 $r_0 > 0$ 是初始残差范数（两种算法相同），$c_A \\in (0,1)$ 是模拟渐近线性收敛率的基本收缩因子，$a \\in [0,1)$ 是一个振荡幅度，用于模拟在相同的空间离散化和线性求解器选择下的瞬态非正规效应和可能的棋盘格式压力-速度耦合伪影，$K \\in \\mathbb{N}$ 是存储的最大迭代次数。通过 $(1+a)$ 进行归一化可确保 $r_0^{(A)} = r_0$。只要 $a  1$，该模型与具有温和瞬态调制的线性定常迭代的不动点理论一致，并对所有 $k$ 保持 $r_k^{(A)}$ 的正性。\n\n您的程序必须为每种算法和每个测试用例实现以下诊断指标：\n\n- 达到目标的迭代次数 $N_\\tau^{(A)}$：使 $r_k^{(A)} \\le r_0 \\,\\tau$ 成立的最小 $k \\in \\{0,1,\\dots,K\\}$，其中 $\\tau \\in (0,1)$ 是一个预设的下降目标。如果在 $\\{0,1,\\dots,K\\}$ 内不存在这样的 $k$，则报告 $N_\\tau^{(A)} = K+1$。\n\n- 估计的渐近收敛因子 $\\widehat{c}^{(A)}$：定义 $\\Delta_k^{(A)} = \\log r_{k+1}^{(A)} - \\log r_k^{(A)}$ 并估计\n$$\n\\widehat{c}^{(A)} \\;=\\; \\exp\\!\\left( \\frac{1}{m} \\sum_{k=K-m}^{K-1} \\Delta_k^{(A)} \\right),\n$$\n其中 $m = \\min\\{M, K\\}$，$M \\in \\mathbb{N}$ 是一个预设的窗口长度。该估计器旨在计算最后 $m$ 步的几何平均收缩因子，并在标准不动点假设下收敛到渐近因子。\n\n- 单调性违规计数 $V^{(A)}$：使得 $r_{k+1}^{(A)} > r_k^{(A)}$ 成立的索引 $k \\in \\{0,1,\\dots,K-1\\}$ 的数量。\n\n使用这些诊断指标，定义一个 SIMPLER 相对于 SIMPLE 的优势谓词（布尔值）：\n$$\n\\text{Dominates} \\;=\\; \\Big( N_\\tau^{(\\text{SIMPLER})}  N_\\tau^{(\\text{SIMPLE})} \\Big) \\;\\wedge\\; \\Big( \\widehat{c}^{(\\text{SIMPLER})}  \\widehat{c}^{(\\text{SIMPLE})} - \\delta \\Big),\n$$\n其中 $\\delta > 0$ 是一个预设的裕度，用以确保估计的渐近因子之间存在有意义的差距。该谓词将“在保持所有其他条件不变的情况下，SIMPLER 在有限迭代次数内和渐近收敛行为上都比 SIMPLE 更快地减小残差”这一论断可操作化。\n\n实现一个完整、可运行的程序，该程序：\n- 根据上述参数化模型为两种算法和每个测试用例生成残差历史。\n- 对 $A \\in \\{\\text{SIMPLE}, \\text{SIMPLER}\\}$ 计算 $N_\\tau^{(A)}$, $\\widehat{c}^{(A)}$ 和 $V^{(A)}$。\n- 使用裕度 $\\delta$ 评估 SIMPLER 的优势谓词。\n- 对于每个测试用例，生成包含以下列表的最终输出：\n$$\n\\left[\\, N_\\tau^{(\\text{SIMPLE})},\\; N_\\tau^{(\\text{SIMPLER})},\\; \\widehat{c}^{(\\text{SIMPLE})},\\; \\widehat{c}^{(\\text{SIMPLER})},\\; V^{(\\text{SIMPLE})},\\; V^{(\\text{SIMPLER})},\\; \\text{Dominates} \\,\\right],\n$$\n并严格遵循此顺序。\n\n所有测试用例共用的全局参数：\n- 目标下降因子 $\\tau = 10^{-6}$。\n- 估计窗口长度 $M = 20$。\n- 渐近差距裕度 $\\delta = 10^{-2}$。\n\n测试套件规范，涵盖一般情况、边界情况、振荡情况和近停滞边缘情况：\n- 情况 1 (一般情况): $r_0 = 1.0$, $K = 200$, $a = 0.0$, $c_{\\text{SIMPLE}} = 0.85$, $c_{\\text{SIMPLER}} = 0.65$。\n- 情况 2 (边界情况，速率相等): $r_0 = 1.0$, $K = 200$, $a = 0.0$, $c_{\\text{SIMPLE}} = 0.70$, $c_{\\text{SIMPLER}} = 0.70$。\n- 情况 3 (振荡瞬态): $r_0 = 1.0$, $K = 200$, $a = 0.15$, $c_{\\text{SIMPLE}} = 0.80$, $c_{\\text{SIMPLER}} = 0.75$。\n- 情况 4 (SIMPLE 近停滞): $r_0 = 1.0$, $K = 500$, $a = 0.02$, $c_{\\text{SIMPLE}} = 0.99$, $c_{\\text{SIMPLER}} = 0.90$。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个由方括号括起来的、按用例划分的列表的逗号分隔列表，例如，\n`[ [...], [...], [...], [...] ]`。", "solution": "该问题陈述已经过细致验证，并被确定为是合理的。它在科学上基于计算流体力学和数值分析的原理，特别是关于不可压缩 Navier-Stokes 方程的迭代解法。该问题是适定的，提供了一套完整且一致的定义、参数和目标。所有术语都经过了形式化定义，从而能够得到唯一且可验证的解。使用参数化模型来描述残差历史是一种有效且常用的技术，可用于创建一个受控的、合成的环境，以测试和比较数值算法的性能。\n\n任务是实现一组诊断指标，以基于合成的残差历史来比较 SIMPLE 和 SIMPLER 算法的收敛行为。该比较通过三个度量和一个最终的优势谓词来形式化。解决方案的步骤是为四个指定的测试用例中的每一个实现这些诊断指标。\n\n问题的核心是算法 $A \\in \\{\\text{SIMPLE}, \\text{SIMPLER}\\}$ 在迭代 $k$ 时的残差范数历史 $r_k^{(A)}$ 的参数化模型：\n$$\nr_k^{(A)} \\;=\\; r_0 \\,\\frac{\\left(c_A\\right)^k \\left(1 + a \\cos(\\pi k)\\right)}{1+a}, \\quad k = 0,1,2,\\dots,K\n$$\n这里，$r_0$ 是初始残差，$c_A$ 是渐近收敛因子，而涉及振荡幅度 $a$ 和 $\\cos(\\pi k) = (-1)^k$ 的项模拟了实践中经常观察到的瞬态、非单调行为。分母 $1+a$ 确保了归一化 $r_0^{(A)} = r_0$。对于每种算法和每个测试用例，我们首先生成一个残差范数向量 $\\{r_k^{(A)}\\}_{k=0}^K$。\n\n基于这个历史，我们计算以下诊断指标：\n\n1.  **达到目标的迭代次数 $N_\\tau^{(A)}$**：该度量量化了实际的收敛速度。它被定义为使残差范数降至目标阈值以下所需的最小迭代次数 $k$，即 $r_k^{(A)} \\le r_0 \\tau$。目标下降因子给定为 $\\tau = 10^{-6}$。我们在 $\\{0, 1, \\dots, K\\}$ 中搜索满足此条件的最小 $k$。如果在最多 $K$ 次迭代内未满足该条件，则报告次数为 $K+1$。\n\n2.  **估计的渐近收敛因子 $\\widehat{c}^{(A)}$**：该度量估计了算法的底层线性收敛率，该收敛率决定了其长期行为。它使用残差历史的最后 $m = \\min\\{M, K\\}$ 次迭代来计算，其中 $M=20$ 是估计窗口长度。公式为：\n    $$\n    \\widehat{c}^{(A)} \\;=\\; \\exp\\!\\left( \\frac{1}{m} \\sum_{k=K-m}^{K-1} \\left( \\log r_{k+1}^{(A)} - \\log r_k^{(A)} \\right) \\right)\n    $$\n    这是指定窗口内单步下降因子 $r_{k+1}^{(A)}/r_k^{(A)}$ 的几何平均值。对于给定的残差模型，项 $\\log r_{k+1}^{(A)} - \\log r_k^{(A)}$可以展开为 $\\log(c_A) + \\log((1+a(-1)^{k+1})/(1+a(-1)^k))$。当窗口大小 $m$ 是偶数时（此处即是，因为 $M=20$ 且所有 $K \\ge 20$），振荡项形成一个伸缩积，其值为 $1$，其对数为 $0$。因此，该估计器被设计为在这些特定条件下精确地恢复真实的基本收缩因子，即 $\\widehat{c}^{(A)} = c_A$。\n\n3.  **单调性违规计数 $V^{(A)}$**：该度量计算了残差从一次迭代到下一次迭代增加的次数，即 $r_{k+1}^{(A)} > r_k^{(A)}$ 对于 $k \\in \\{0, 1, \\dots, K-1\\}$。这可作为收敛过程非单调性或振荡性质的度量。当振荡幅度 $a$ 相对于收缩因子 $c_A$ 足够大时，预计会得到一个非零值。\n\n最后，这些诊断指标被综合成一个单一的布尔值**优势谓词**：\n$$\n\\text{Dominates} \\;=\\; \\Big( N_\\tau^{(\\text{SIMPLER})}  N_\\tau^{(\\text{SIMPLE})} \\Big) \\;\\wedge\\; \\Big( \\widehat{c}^{(\\text{SIMPLER})}  \\widehat{c}^{(\\text{SIMPLE})} - \\delta \\Big)\n$$\n当且仅当 SIMPLER 算法在达到目标残差所需的迭代次数上更少，并且其渐近收敛因子显著更小（两者同时满足）时，该谓词为真。裕度 $\\delta = 10^{-2}$ 确保了渐近率的差异是有意义的。\n\n实现过程将处理四个测试用例中的每一个，通过生成两个残差历史（一个用于 SIMPLE，一个用于 SIMPLER），为每个历史计算三个诊断指标，评估优势谓词，并按规定收集结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the diagnostic plan for all test cases and print results.\n    \"\"\"\n    \n    # Global parameters common to all test cases\n    tau = 1e-6\n    M = 20\n    delta = 1e-2\n\n    # Test suite specification\n    test_cases = [\n        # Case 1 (general)\n        {'r0': 1.0, 'K': 200, 'a': 0.0, 'c_simple': 0.85, 'c_simpler': 0.65},\n        # Case 2 (boundary equal rates)\n        {'r0': 1.0, 'K': 200, 'a': 0.0, 'c_simple': 0.70, 'c_simpler': 0.70},\n        # Case 3 (oscillatory transients)\n        {'r0': 1.0, 'K': 200, 'a': 0.15, 'c_simple': 0.80, 'c_simpler': 0.75},\n        # Case 4 (near-stagnation for SIMPLE)\n        {'r0': 1.0, 'K': 500, 'a': 0.02, 'c_simple': 0.99, 'c_simpler': 0.90},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        r0 = case['r0']\n        K = case['K']\n        a = case['a']\n        c_simple = case['c_simple']\n        c_simpler = case['c_simpler']\n        \n        params = {\n            'SIMPLE': c_simple,\n            'SIMPLER': c_simpler,\n        }\n        \n        results_per_algo = {}\n\n        for algo_name, c_A in params.items():\n            # Generate residual history\n            k_range = np.arange(K + 1)\n            # The term cos(pi*k) is equivalent to (-1)^k\n            oscillation_term = 1 + a * (-1)**k_range\n            r_k = r0 * (c_A**k_range * oscillation_term) / (1 + a)\n            \n            # --- Diagnostic 1: Iteration-to-target count N_tau ---\n            target_residual = r0 * tau\n            indices_below_target = np.where(r_k = target_residual)[0]\n            if indices_below_target.size > 0:\n                N_tau = indices_below_target[0]\n            else:\n                N_tau = K + 1\n\n            # --- Diagnostic 2: Estimated asymptotic convergence factor c_hat ---\n            m = min(M, K)\n            if m > 0:\n                # Log of residuals in the estimation window [K-m, K]\n                log_r_window = np.log(r_k[K - m : K + 1])\n                # Differences of consecutive log residuals\n                delta_k = log_r_window[1:] - log_r_window[:-1]\n                c_hat = np.exp(np.mean(delta_k))\n            else: # Edge case for K=0, although problem constraints imply K>=1\n                c_hat = np.nan\n\n            # --- Diagnostic 3: Monotonicity violation count V ---\n            # Count where r_{k+1} > r_k for k in [0, K-1]\n            V = np.sum(r_k[1:] > r_k[:-1])\n\n            results_per_algo[algo_name] = {\n                'N_tau': N_tau,\n                'c_hat': c_hat,\n                'V': V,\n            }\n\n        # --- Dominance Predicate ---\n        N_tau_simple = results_per_algo['SIMPLE']['N_tau']\n        N_tau_simpler = results_per_algo['SIMPLER']['N_tau']\n        c_hat_simple = results_per_algo['SIMPLE']['c_hat']\n        c_hat_simpler = results_per_algo['SIMPLER']['c_hat']\n        \n        dominates = (N_tau_simpler  N_tau_simple) and \\\n                    (c_hat_simpler  c_hat_simple - delta)\n\n        # Assemble final list for the case\n        case_result = [\n            N_tau_simple,\n            N_tau_simpler,\n            c_hat_simple,\n            c_hat_simpler,\n            results_per_algo['SIMPLE']['V'],\n            results_per_algo['SIMPLER']['V'],\n            dominates\n        ]\n        all_results.append(case_result)\n\n    # Format the final output string as specified\n    # The str() of a list automatically includes spaces, e.g., '[1, 2, 3]'\n    # Joining these with a comma produces '...,[...],[...],...'\n    # The final wrapping brackets gives '[[...],[...],...]'\n    final_output_string = f\"[{','.join(map(str, all_results))}]\"\n    print(final_output_string.replace(\" \", \"\"))\n\nsolve()\n```", "id": "3442976"}]}