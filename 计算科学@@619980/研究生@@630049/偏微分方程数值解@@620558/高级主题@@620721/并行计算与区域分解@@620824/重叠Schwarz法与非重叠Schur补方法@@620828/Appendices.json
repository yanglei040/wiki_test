{"hands_on_practices": [{"introduction": "任何施瓦茨方法的核心在于耦合相邻子区域的传输条件。虽然简单的狄利克雷(Dirichlet)条件是一个常见的起点，但为了获得稳健的性能，设计针对偏微分方程底层物理特性的更有效条件至关重要。第一个实践练习 [@problem_id:3428557] 将引导您完成一个基础性的推导，展示如何直接从对流扩散方程的守恒律形式中，为该方程构建一个优化的Robin型传输条件。通过完成这个练习，您将深入理解如何将“迎风”信息融入迭代格式中，这是为对流主导现象开发稳定且快速的区域分解方法的关键技术。", "problem": "考虑区间 $[0,L]$ 上的常系数一维对流扩散偏微分方程(PDE)，\n$$\n-\\epsilon\\,u''(x) + b\\,u'(x) = f(x),\n$$\n其中 $\\epsilon>0$ 且 $b\\in\\mathbb{R}$。该区域被分解为两个重叠的子区域 $\\Omega_1=[0,x_\\star+\\delta]$ 和 $\\Omega_2=[x_\\star-\\delta,L]$，其中 $x_\\star\\in(0,L)$ 且重叠半宽度 $\\delta\\in(0,\\min\\{x_\\star,L-x_\\star\\})$。在一个重叠Schwarz迭代方法中，假设子区域解 $u_1$ 和 $u_2$ 在界面点 $x=x_\\star$ 处通过一个形如下式的线性Robin型传输算子进行交换\n$$\n-\\epsilon\\,u_1'(x_\\star) + \\alpha\\,u_1(x_\\star) = -\\epsilon\\,u_2'(x_\\star) + \\alpha\\,u_2(x_\\star),\n$$\n其中参数 $\\alpha\\in\\mathbb{R}$ 待定。请从第一性原理出发，不假设任何预先存在的界面公式，推导出 $\\alpha$ 的选择，使得对于齐次情况 $f\\equiv 0$，能在重叠区域上实现精确的通量传输，并且该选择与 $\\delta$ 无关。\n\n然后，将您的推导推广到 $d$ 维的常系数对流扩散偏微分方程\n$$\n-\\epsilon\\,\\Delta u(\\boldsymbol{x}) + \\boldsymbol{b}\\cdot\\nabla u(\\boldsymbol{x}) = f(\\boldsymbol{x}),\n$$\n其中 $\\epsilon>0$ 且对流向量 $\\boldsymbol{b}\\in\\mathbb{R}^d$ 为常数。令 $\\Gamma$ 表示两个重叠子区域之间的光滑界面，并令 $\\boldsymbol{n}$ 为 $\\Gamma$ 上指向其中一个子区域外部的单位法向量。提出一个形如下式的方向偏置Robin传输算子\n$$\n-\\epsilon\\,\\partial_{\\boldsymbol{n}}u + \\alpha(\\boldsymbol{n})\\,u,\n$$\n并使用一个源于该偏微分方程的基本守恒律论证，确定 $\\alpha(\\boldsymbol{n})$ 的唯一闭式表达式，该表达式可以退化为一维情况下的结果，并且能捕捉相对于对流方向 $\\boldsymbol{b}$ 的迎风偏置。您的最终答案必须是这个单一的 $\\alpha(\\boldsymbol{n})$ 解析表达式。不需要进行数值近似或四舍五入，最终答案中也不应包含任何物理单位。", "solution": "该问题要求推导一个应用于对流扩散方程的重叠Schwarz方法中，Robin型传输算子里的参数 $\\alpha$。该推导首先在一维情况下进行，然后推广到 $d$ 维。推导的核心原则是实现与重叠区域大小无关的“精确通量传输”。\n\n首先，我们分析一维情况。控制偏微分方程(PDE)为\n$$\n-\\epsilon\\,u''(x) + b\\,u'(x) = f(x)\n$$\n其中 $\\epsilon > 0$ 和 $b \\in \\mathbb{R}$ 是常数。问题要求基于齐次情况（即 $f(x) \\equiv 0$）进行推导。齐次方程为\n$$\n-\\epsilon\\,u''(x) + b\\,u'(x) = 0.\n$$\n这个方程可以写成守恒形式。由于 $b$ 是常数，有 $b\\,u'(x) = (b\\,u(x))'$。同时，$-\\epsilon\\,u''(x) = (-\\epsilon\\,u'(x))'$。因此，该偏微分方程可以表示为一个通量的散度（在一维情况下即导数）等于源项的形式：\n$$\n\\frac{d}{dx} \\left( -\\epsilon\\,u'(x) + b\\,u(x) \\right) = f(x).\n$$\n这使我们能够识别出与对流扩散过程相关的物理通量 $J(x)$：\n$$\nJ(x) = -\\epsilon\\,u'(x) + b\\,u(x).\n$$\n对于 $f(x) = 0$ 的齐次情况，方程变为 $\\frac{d}{dx}J(x) = 0$，这意味着对于齐次偏微分方程的任何解 $u(x)$，其通量 $J(x)$ 都是一个常数。\n\n问题指明，子区域解 $u_1$ 和 $u_2$ 在界面点 $x=x_\\star$ 处通过一个线性Robin型算子的连续性进行耦合：\n$$\n-\\epsilon\\,u_1'(x_\\star) + \\alpha\\,u_1(x_\\star) = -\\epsilon\\,u_2'(x_\\star) + \\alpha\\,u_2(x_\\star).\n$$\n问题陈述 $\\alpha$ 的选择必须实现“精确通量传输”。对此要求最直接和基本的解释是，传输算子所保证连续的量必须是物理通量本身。通过比较传输算子的形式 $\\mathcal{T}_\\alpha u(x) = -\\epsilon\\,u'(x) + \\alpha\\,u(x)$ 与物理通量的表达式 $J(x) = -\\epsilon\\,u'(x) + b\\,u(x)$，我们发现它们变得相同当且仅当：\n$$\n\\alpha = b.\n$$\n这个选择确保了传输条件恰好是物理通量的连续性：$J(u_1)(x_\\star) = J(u_2)(x_\\star)$。\n\n问题还指明，这个选择必须与重叠半宽度 $\\delta$ 无关。如果 $\\alpha=b$，则条件是通量的连续性。对于全域 $[0,L]$ 上齐次方程的任何解 $u(x)$，其通量 $J(u)$ 处处为常数。因此，对于其在子区域上的限制 $u_1$ 和 $u_2$，条件 $J(u_1)(x) = J(u_2)(x)$ 在重叠区域 $[x_\\star-\\delta, x_\\star+\\delta]$ 内的任何点 $x$ 都成立，而不仅仅是在 $x_\\star$ 处。所以，这个物理条件的有效性内在地与 $\\delta$ 无关。\n\n现在，我们将这个发现在推广到 $d$ 维。偏微分方程为\n$$\n-\\epsilon\\,\\Delta u(\\boldsymbol{x}) + \\boldsymbol{b}\\cdot\\nabla u(\\boldsymbol{x}) = f(\\boldsymbol{x}),\n$$\n其中 $\\epsilon > 0$ 且 $\\boldsymbol{b} \\in \\mathbb{R}^d$ 是一个常向量。我们可以将此偏微分方程写成守恒形式，注意到 $\\Delta u = \\nabla \\cdot (\\nabla u)$，并且由于 $\\boldsymbol{b}$ 是一个常向量，$\\boldsymbol{b} \\cdot \\nabla u = \\nabla \\cdot (\\boldsymbol{b}u) - u(\\nabla \\cdot \\boldsymbol{b}) = \\nabla \\cdot (\\boldsymbol{b}u)$。因此，该偏微分方程等价于：\n$$\n\\nabla \\cdot (-\\epsilon\\,\\nabla u(\\boldsymbol{x}) + \\boldsymbol{b}u(\\boldsymbol{x})) = f(\\boldsymbol{x}).\n$$\n该方程的形式为 $\\nabla \\cdot \\boldsymbol{J}(\\boldsymbol{x}) = f(\\boldsymbol{x})$，其中 $\\boldsymbol{J}(\\boldsymbol{x})$ 是向量通量：\n$$\n\\boldsymbol{J}(\\boldsymbol{x}) = -\\epsilon\\,\\nabla u(\\boldsymbol{x}) + \\boldsymbol{b}u(\\boldsymbol{x}).\n$$\n一个基本的守恒律论证即基于此通量。量 $u$ 穿过一个具有单位法向量 $\\boldsymbol{n}$ 的光滑界面 $\\Gamma$ 的传输率由通量向量的法向分量 $J_{\\boldsymbol{n}} = \\boldsymbol{J} \\cdot \\boldsymbol{n}$ 给出。\n$$\nJ_{\\boldsymbol{n}}(\\boldsymbol{x}) = \\left( -\\epsilon\\,\\nabla u(\\boldsymbol{x}) + \\boldsymbol{b}u(\\boldsymbol{x}) \\right) \\cdot \\boldsymbol{n} = -\\epsilon\\,(\\nabla u \\cdot \\boldsymbol{n}) + (\\boldsymbol{b} \\cdot \\boldsymbol{n}) u(\\boldsymbol{x}).\n$$\n注意到方向导数 $\\partial_{\\boldsymbol{n}}u = \\nabla u \\cdot \\boldsymbol{n}$，法向通量为：\n$$\nJ_{\\boldsymbol{n}}(\\boldsymbol{x}) = -\\epsilon\\,\\partial_{\\boldsymbol{n}}u(\\boldsymbol{x}) + (\\boldsymbol{b} \\cdot \\boldsymbol{n}) u(\\boldsymbol{x}).\n$$\n问题提出了一个形如 $-\\epsilon\\,\\partial_{\\boldsymbol{n}}u + \\alpha(\\boldsymbol{n})\\,u$ 的方向偏置Robin传输算子。为确保“精确通量传输”，与一维情况类似，我们将此算子与物理法向通量 $J_{\\boldsymbol{n}}$ 相等：\n$$\n-\\epsilon\\,\\partial_{\\boldsymbol{n}}u + \\alpha(\\boldsymbol{n})\\,u = -\\epsilon\\,\\partial_{\\boldsymbol{n}}u + (\\boldsymbol{b} \\cdot \\boldsymbol{n}) u.\n$$\n为使此等式对任何解 $u$ 都成立，$u$ 的系数必须相等。这就得出了 $\\alpha(\\boldsymbol{n})$ 的唯一闭式表达式：\n$$\n\\alpha(\\boldsymbol{n}) = \\boldsymbol{b} \\cdot \\boldsymbol{n}.\n$$\n这个结果满足所有陈述的要求。它是从一个基本的守恒律论证中推导出来的。它可以退化到一维的结果，因为对于沿 $x$ 轴的一维问题，$\\boldsymbol{b}=(b)$ 且 $\\boldsymbol{n}=(1)$，我们有 $\\alpha(1) = b \\cdot 1 = b$。它也捕捉了迎风偏置，因为系数 $\\alpha(\\boldsymbol{n})$ 直接取决于对流向量 $\\boldsymbol{b}$ 与界面法向量 $\\boldsymbol{n}$ 的对齐情况。如果流动与法向一致（$\\boldsymbol{b} \\cdot \\boldsymbol{n} > 0$，出流边界），$\\alpha$ 为正。如果流动与法向相反（$\\boldsymbol{b} \\cdot \\boldsymbol{n} < 0$，入流边界），$\\alpha$ 为负。如果流动与界面相切（$\\boldsymbol{b} \\cdot \\boldsymbol{n} = 0$），则Robin算子的对流贡献消失。", "answer": "$$\\boxed{\\boldsymbol{b} \\cdot \\boldsymbol{n}}$$", "id": "3428557"}, {"introduction": "在探讨了传输条件的理论设计之后，我们现在转向一个计算案例研究，它将展示这些条件对收敛性的深远影响。亥姆霍兹(Helmholtz)方程用于模拟波的传播，对于经典的区域分解方法来说，它是一个出了名的难题，尤其是在高波数的情况下。这个动手实践 [@problem_id:3428516] 将要求您构建一个具体的一维例子，来展示经典的重叠施瓦茨方法为何会无法收敛。接着，您将实现一个采用复数Robin（阻抗）条件的“优化”施瓦茨方法，并通过迭代算子的谱半径来定量地观察这一改进如何将一个发散的迭代过程转变为收敛的过程。", "problem": "考虑一个闭区间上具有齐次狄利克雷数据的一维常系数亥姆霍兹边界值问题，\n$$\n-\\,u''(x)\\;-\\;k^2\\,u(x)\\;=\\;0,\\quad x\\in(0,L),\\qquad u(0)=0,\\quad u(L)=0,\n$$\n其中 $L>0$ 和 $k>0$ 是给定值。您将研究齐次误差方程的两种域分解迭代方法，并通过其迭代算子的谱半径来量化它们的收敛性。\n\n方法A（采用狄利克雷传输条件的经典重叠 Schwarz 方法）：将全局网格划分为两个重叠子域 $\\Omega_1=[0,x_R]$ 和 $\\Omega_2=[x_L,L]$，重叠区域宽度 $x_R-x_L>0$。在针对齐次误差方程的并行（类 Jacobi）重叠 Schwarz 迭代中，每个子域问题都使用取自外部物理边界和内部重叠区域的人工界面上邻域前一次迭代结果的狄利克雷边界条件来求解。界面迭代定义在人工界面上的狄利克雷值对 $g=(g_L,g_R)$ 上，其中 $g_L$ 是施加在 $x=x_L$ 处用于 $\\Omega_2$ 的值，$g_R$ 是施加在 $x=x_R$ 处用于 $\\Omega_1$ 的值。子域求解的线性特性意味着存在一个 $2\\times 2$ 的迭代算子，形式如下\n$$\ng^{(n+1)} \\;=\\; M_D\\, g^{(n)},\\qquad M_D=\\begin{bmatrix} 0  \\alpha \\\\ \\beta  0 \\end{bmatrix},\n$$\n其中系数 $\\alpha$ 和 $\\beta$ 是由两个子域求解引起的狄利克雷-狄利克雷传输。迭代收敛的充要条件是谱半径 $\\rho(M_D) < 1$。\n\n方法B（采用复 Robin 传输条件的非重叠优化 Schwarz 方法）：将域划分为两个非重叠子域 $\\Omega_1=[0,x_\\Gamma]$ 和 $\\Omega_2=[x_\\Gamma,L]$。在公共界面 $x=x_\\Gamma$ 处，施加复 Robin（阻抗）传输算子\n$$\nT_1(u)\\;=\\;\\partial_x u\\;+\\;i\\,\\eta\\,u,\\qquad T_2(u)\\;=\\;-\\partial_x u\\;+\\;i\\,\\eta\\,u,\n$$\n其中阻抗参数 $\\eta>0$ 是选定的。在针对齐次误差方程的并行迭代中，每个子域使用邻域前一次迭代的 Robin 迹作为输入，并生成自己的 Robin 迹作为输出返回。用 $s=(s_L,s_R)$ 表示注入到界面上用于 $\\Omega_2$（左）和 $\\Omega_1$（右）的一对 Robin 数据，线性特性再次给出一个迭代形式\n$$\ns^{(n+1)} \\;=\\; M_R\\, s^{(n)},\\qquad M_R=\\begin{bmatrix} 0  a \\\\ b  0 \\end{bmatrix},\n$$\n其中 $a$ 和 $b$ 是 Robin-Robin 传输。收敛性由 $\\rho(M_R) < 1$ 来刻画。\n\n离散化与迭代算子的构造：使用一个包含 $N+1$ 个节点 $x_j=jh$ 的均匀网格对区间 $[0,L]$ 进行离散化，其中 $h=L/N$ 且 $j\\in\\{0,1,\\dots,N\\}$。使用标准的二阶中心有限差分格式离散亥姆霍兹算子，\n$$\n\\left(\\frac{2}{h^2}-k^2\\right)u_j - \\frac{1}{h^2}u_{j-1} - \\frac{1}{h^2}u_{j+1} = 0,\n$$\n作用于内部节点，并强制 $u_0=0$ 和 $u_N=0$。对于方法A，选择界面索引 $i_L$ 和 $i_R$ 满足 $1 \\le i_L < i_R \\le N-1$。对于方法B，选择界面索引 $i_\\Gamma$ 满足 $1 \\le i_\\Gamma \\le N-1$。您的任务是编写一个Python程序，该程序使用NumPy来构建和求解必要的离散线性系统，以计算矩阵 $M_D$ 和 $M_R$ 的条目，然后计算它们的谱半径 $\\rho(M_D)$ 和 $\\rho(M_R)$。您必须实现一个名为`main`的函数，该函数使用下表中提供的参数运行三个测试用例。对于每个测试用例，您必须计算两个谱半径，并将它们作为浮点数追加到一个列表中。最终，您的程序必须打印一个包含所有六个结果的单一逗号分隔列表，并用方括号括起来，例如`[rho_D1, rho_R1, rho_D2, rho_R2, rho_D3, rho_R3]`。\n\n| 测试用例 | N | k | 重叠 `ov` (方法A) | 阻抗 `eta` (方法B) |\n|---|---|---|---|---|\n| 1 | 400 | $20\\pi$ | 0.05 | $k$ |\n| 2 | 400 | $6\\pi$ | 0.10 | $k$ |\n| 3 | 400 | $20\\pi$ | $h$ (单网格单元) | $0.5k$ |", "solution": "我们从有界区间上的线性常系数亥姆霍兹方程与齐次狄利克雷边界条件开始。所需的核心原理是边界值问题的线性性、具有两个边界条件的二阶两点边值问题解的唯一性，以及通过迭代矩阵对线性定常迭代进行的谱刻画。\n\n离散化原理：在间距为 $h=L/N$ 的均匀网格上，$-u''(x)$ 在网格点处的标准二阶中心有限差分产生离散算子\n$$\n\\mathcal{A}_h u_j \\;=\\; \\left(\\frac{2}{h^2}-k^2\\right)u_j \\;-\\; \\frac{1}{h^2}\\,u_{j-1} \\;-\\; \\frac{1}{h^2}\\,u_{j+1},\n$$\n对于 $j\\in\\{1,2,\\dots,N-1\\}$。我们强制 $u_0=0$ 和 $u_N=0$。\n\n方法A（采用狄利克雷传输条件的经典重叠 Schwarz 方法）：重叠子域由索引 $i_L$ 和 $i_R$ 定义，满足 $1\\le i_L < i_R \\le N-1$。我们通过求解具有单位边界数据的局部问题来计算迭代矩阵的系数 $\\alpha$ 和 $\\beta$。\n\n-   $\\alpha$ 的计算：在子域 $\\Omega_1$ 上求解，该子域在 $j=0$ 处有齐次狄利克雷条件，在 $j=i_R$ 处有非齐次狄利克雷条件 $u_{i_R}=1$。解向量中位于 $j=i_L$ 处的分量即为 $\\alpha$。\n-   $\\beta$ 的计算：在子域 $\\Omega_2$ 上求解，该子域在 $j=L$ 处有齐次狄利克雷条件，在 $j=i_L$ 处有非齐次狄利克雷条件 $u_{i_L}=1$。解向量中位于 $j=i_R$ 处的分量即为 $\\beta$。\n\n由于 $M_D=\\begin{bsmallmatrix} 0 & \\alpha \\\\ \\beta & 0 \\end{bsmallmatrix}$，其特征值为 $\\pm\\sqrt{\\alpha\\beta}$，因此谱半径为 $\\rho(M_D) = \\sqrt{|\\alpha\\beta|}$。\n\n方法B（采用复 Robin 传输条件的非重叠优化 Schwarz 方法）：界面位于索引 $i_\\Gamma$ 处。我们通过求解具有单位Robin数据的局部问题来计算系数 $a$ 和 $b$。这需要在每个子域中构建并求解一个包含复数项的线性系统。\n\n-   $a$ 的计算：在子域 $\\Omega_1$ 上求解，其在 $j=0$ 处有齐次狄利克雷条件，在 $j=i_\\Gamma$ 处有非齐次Robin条件 $(\\partial_x u + i\\eta u)|_{x=i_\\Gamma h} = 1$。然后，将得到的解用于计算出射Robin迹 $(-\\partial_x u + i\\eta u)|_{x=i_\\Gamma h}$，该值即为 $a$。\n-   $b$ 的计算：在子域 $\\Omega_2$ 上求解，其在 $j=L$ 处有齐次狄利克雷条件，在 $j=i_\\Gamma$ 处有非齐次Robin条件 $(-\\partial_x u + i\\eta u)|_{x=i_\\Gamma h} = 1$。然后，将得到的解用于计算出射Robin迹 $(\\partial_x u + i\\eta u)|_{x=i_\\Gamma h}$，该值即为 $b$。\n\n由于 $M_R=\\begin{bsmallmatrix} 0 & a \\\\ b & 0 \\end{bsmallmatrix}$，其谱半径为 $\\rho(M_R) = \\sqrt{|ab|}$。", "answer": "```python\nimport numpy as np\n\ndef build_tridiag_helmholtz(m, h, k):\n    \"\"\"\n    Build the m x m tridiagonal matrix for the discrete Helmholtz operator\n    on interior nodes with stencil: (2/h^2 - k^2) on diagonal and -1/h^2 on off-diagonals.\n    \"\"\"\n    if m == 0:\n        return np.zeros((0, 0), dtype=float)\n    main = (2.0 / h**2 - k**2) * np.ones(m, dtype=float)\n    off = (-1.0 / h**2) * np.ones(m - 1, dtype=float)\n    A = np.diag(main)\n    if m > 1:\n        A += np.diag(off, k=1) + np.diag(off, k=-1)\n    return A\n\ndef spectral_radius_dirichlet(L, N, k, iL, iR):\n    \"\"\"\n    Compute spectral radius of the 2x2 iteration matrix for classical overlapping Schwarz\n    with Dirichlet transmission on a 1D Helmholtz problem.\n    \"\"\"\n    h = L / N\n    # Subdomain 1: indices 0..iR, unknowns j=1..iR-1\n    m1 = max(0, iR - 1)\n    A1 = build_tridiag_helmholtz(m1, h, k)\n    alpha = np.nan\n    # RHS for unit g_R\n    if m1 > 0:\n        b1 = np.zeros(m1, dtype=float)\n        # Contribution from right boundary u_{iR} = g_R to equation at j=iR-1 (index m1-1)\n        b1[-1] += (1.0 / h**2) * 1.0  # g_R = 1\n        # Solve\n        u1 = np.linalg.solve(A1, b1)\n        # Extract u at iL (node index iL) which corresponds to unknown index iL-1 if 1 = iL = iR-1\n        if 1 = iL = iR - 1:\n            alpha = u1[iL - 1]\n        else:\n            alpha = 0.0 if iL == 0 else (1.0 if iR == iL else np.nan)\n\n    # Subdomain 2: indices iL..N, unknowns j=iL+1..N-1\n    m2 = max(0, N - iL - 1)\n    A2 = build_tridiag_helmholtz(m2, h, k)\n    beta = np.nan\n    if m2 > 0:\n        b2 = np.zeros(m2, dtype=float)\n        # Contribution from left boundary u_{iL} = g_L to equation at j=iL+1 (index 0)\n        b2[0] += (1.0 / h**2) * 1.0  # g_L = 1\n        v2 = np.linalg.solve(A2, b2)\n        # Extract u at iR (node index iR) which corresponds to unknown index iR - (iL+1)\n        if iL + 1 = iR = N - 1:\n            beta = v2[iR - (iL + 1)]\n        else:\n            beta = 0.0 if iR == N else (1.0 if iR == iL else np.nan)\n\n    # Iteration matrix M = [[0, alpha], [beta, 0]]\n    # Spectral radius is max(abs(eigs)), eigs = ± sqrt(alpha*beta)\n    val = alpha * beta\n    rho = float(np.sqrt(abs(val)))\n    return rho\n\ndef spectral_radius_robin(L, N, k, iG, eta):\n    \"\"\"\n    Compute spectral radius of the 2x2 iteration matrix for non-overlapping optimized Schwarz\n    with complex Robin transmission on a 1D Helmholtz problem.\n    \"\"\"\n    h = L / N\n    a = np.nan\n    # Subdomain 1: unknowns j=1..iG (size m1=iG)\n    m1 = iG\n    if m1 == 0:\n        a = np.nan\n    else:\n        A1 = np.zeros((m1, m1), dtype=complex)\n        b1 = np.zeros(m1, dtype=complex)\n        # Interior rows for j=1..iG-1 map to p=0..m1-2\n        for j in range(1, iG):\n            p = j - 1\n            A1[p, p] += (2.0 / h**2 - k**2)\n            if p - 1 >= 0:\n                A1[p, p - 1] += (-1.0 / h**2)\n            # left boundary u0=0 contributes nothing\n            if p + 1 = m1 - 1:\n                A1[p, p + 1] += (-1.0 / h**2)\n        # Robin row at j=iG => p=m1-1\n        p = m1 - 1\n        # coefficients: (-1/h) * u_{iG-1} + (1/h + i*eta) * u_{iG} = s_R\n        if m1 - 1 > 0: # Corresponds to j-1 = iG-1 existing\n            A1[p, m1 - 2] += (-1.0 / h)\n        A1[p, m1 - 1] += (1.0 / h + 1j * eta)\n        # Solve for s_R = 1\n        b1[p] = 1.0 + 0j\n        u1 = np.linalg.solve(A1, b1)\n        # Outgoing trace to the left: s_L_out = -(u_{iG} - u_{iG-1})/h + i*eta*u_{iG}\n        u_iG = u1[m1 - 1]\n        u_iGm1 = u1[m1 - 2] if m1 - 1 > 0 else 0.0 + 0j  # if iG=1, then u_{iG-1} = u0 = 0\n        sL = - (u_iG - u_iGm1) / h + 1j * eta * u_iG\n        a = sL\n\n    b = np.nan\n    # Subdomain 2: unknowns j=iG..N-1 (size m2=N - iG)\n    m2 = N - iG\n    if m2 == 0:\n        b = np.nan\n    else:\n        A2 = np.zeros((m2, m2), dtype=complex)\n        b2 = np.zeros(m2, dtype=complex)\n        # Robin row at left boundary j=iG => p=0\n        # (1/h + i*eta) * u_{iG} + (-1/h) * u_{iG+1} = s_L\n        A2[0, 0] += (1.0 / h + 1j * eta)\n        if m2 > 1: # u_{iG+1} exists\n            A2[0, 1] += (-1.0 / h)\n        # Interior rows for j=iG+1..N-1 map to p=1..m2-1\n        for j in range(iG + 1, N):\n            p = j - iG\n            # p runs 1..m2-1\n            A2[p, p] += (2.0 / h**2 - k**2)\n            A2[p, p - 1] += (-1.0 / h**2)\n            if p + 1 = m2 - 1:\n                A2[p, p + 1] += (-1.0 / h**2)\n            # right boundary u_N=0 contributes nothing\n        # Solve for s_L = 1\n        b2[0] = 1.0 + 0j\n        v2 = np.linalg.solve(A2, b2)\n        # Outgoing trace to the right: s_R_out = (u_{iG+1} - u_{iG})/h + i*eta*u_{iG}\n        u_iG = v2[0]\n        u_iGp1 = v2[1] if m2 >= 2 else 0.0 + 0j  # if only one unknown, then u_{iG+1}=u_N=0\n        sR = (u_iGp1 - u_iG) / h + 1j * eta * u_iG\n        b = sR\n\n    val = a * b\n    rho = float(np.sqrt(abs(val)))\n    return rho\n\ndef indices_for_overlap(N, ov, h):\n    \"\"\"\n    Compute iL and iR from desired overlap length ov, centered at the middle index.\n    Clamp to satisfy 1 = iL  iR = N-1.\n    \"\"\"\n    mid = N // 2\n    # convert overlap length to number of nodes across the overlapping region\n    ov_nodes = max(1, int(round(ov / h)))\n    half = ov_nodes // 2\n    iL = max(1, mid - half)\n    iR = min(N - 1, mid + (ov_nodes - half))\n    if iL >= iR:\n        # ensure at least one grid point overlap, i.e. iR > iL\n        iL = max(1, iR - 1)\n        if iL >= iR: # case iR=1\n           iR = min(N-1, iL + 1)\n    return iL, iR\n\ndef main():\n    tests = []\n    L = 1.0\n    # Test 1: N=400, k=20*pi, ov=0.05, eta=k\n    tests.append({\"N\": 400, \"k\": 20.0 * np.pi, \"ov\": 0.05, \"eta_factor\": 1.0})\n    # Test 2: N=400, k=6*pi, ov=0.10, eta=k\n    tests.append({\"N\": 400, \"k\": 6.0 * np.pi, \"ov\": 0.10, \"eta_factor\": 1.0})\n    # Test 3: N=400, k=20*pi, ov=h=L/N, eta=0.5*k\n    tests.append({\"N\": 400, \"k\": 20.0 * np.pi, \"ov\": None, \"eta_factor\": 0.5})  # ov to be set as h\n\n    results = []\n    for t in tests:\n        N = t[\"N\"]\n        k = t[\"k\"]\n        h = L / N\n        ov = t[\"ov\"] if t[\"ov\"] is not None else h\n        eta = t[\"eta_factor\"] * k\n        # Indices for overlap\n        iL, iR = indices_for_overlap(N, ov, h)\n        # Interface index for non-overlapping\n        iG = N // 2\n        # Spectral radii\n        rho_D = spectral_radius_dirichlet(L, N, k, iL, iR)\n        rho_R = spectral_radius_robin(L, N, k, iG, eta)\n        results.append(f\"{rho_D:.6f}\")\n        results.append(f\"{rho_R:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    main()\n```", "id": "3428516"}, {"introduction": "除了波传播问题带来的不定性挑战外，区域分解中的另一个基本问题源于问题的奇异性，例如带有纯诺伊曼(Neumann)边界条件的泊松(Poisson)方程。全局算子的零空间（常数模态）可能会对子区域求解器造成严重破坏，导致所谓的“浮动子区域”在局部也是奇异的。这最后一个实践 [@problem_id:3428530] 对此现象提供了一个计算上的探究。您将学习如何在重叠施瓦茨和非重叠舒尔补两种框架下诊断零空间的存在，并实现一种标准技术——通过增加约束来增广系统——以恢复界面问题的适定性。", "problem": "考虑闭区间 $[0,1]$ 上带齐次诺伊曼边界条件的一维泊松方程模型问题。该连续问题是求解一个函数 $u$，使得在 $(0,1)$ 内满足 $-\\frac{d^2u}{dx^2} = f$，并且满足 $\\frac{du}{dx}(0) = 0$，$\\frac{du}{dx}(1) = 0$。用 $N$ 个等距网格点对区间进行离散，并通过标准的二阶中心有限差分格式来近似负二阶导数。这将产生一个对称半正定线性系统 $A u = b$，其中 $A \\in \\mathbb{R}^{N \\times N}$ 是离散诺伊曼拉普拉斯算子。对于齐次诺伊曼边界条件，矩阵 $A$ 具有一个与常数向量相关的非平凡零空间。\n\n本任务是在离散设置下，从算法和定量角度分析零空间对重叠Schwarz方法和非重叠Schur补方法的影响。仅使用以下基本概念：\n\n- 泊松方程的齐次诺伊曼边界条件的定义及其离散有限差分表示。\n- 区域分解为子区域的概念，以及从分块高斯消元和子区域局部算子出发，在代数层面定义的重叠Schwarz和非重叠Schur补方法。\n- 奇异值分解（Singular Value Decomposition, SVD）的定义，以及如何使用奇异值来确定零空间的维度，并通过最小奇异值来量化奇异性。\n\n使用的定义：\n\n- “浮动子区域”是指其局部算子在所有边界上都具有齐次诺伊曼条件，从而产生一个由常数向量生成的局部零空间的子区域。\n- 在人工子区域边界上施加齐次诺伊曼条件的重叠Schwarz方法中，每个子区域的求解都使用一个局部的离散诺伊曼算子。\n- 在非重叠Schur补方法中，界面自由度 $\\Gamma$ 被保留，而内部自由度 $I$ 通过分块高斯消元被消除，从而在 $\\Gamma$ 上产生一个凝聚算子。在纯诺伊曼设置下，该凝聚算子可能是奇异的；一种补救方法是通过增加单个约束来增广凝聚系统，以消除全局常数模态（例如，通过拉格朗日乘子施加零均值条件）。\n\n为每个测试用例实现以下计算任务：\n\n1. 使用标准的二阶中心有限差分格式构建离散诺伊曼拉普拉斯算子 $A \\in \\mathbb{R}^{N \\times N}$，并在两端施加齐次诺伊曼边界条件。矩阵的元素必须在两个物理边界行上明确反映诺伊曼条件。\n\n2. 通过计算小于或等于固定绝对容差 $10^{-10}$ 的奇异值数量，确定 $A$ 的零空间维度 $d_{\\text{glob}}$。\n\n3. 对于重叠Schwarz方法，通过一个界面索引 $m$ 和一个重叠大小 $o$ 定义一个双子区域分解，将左子区域定义为连续索引集 $\\{0,1,\\dots,m+o\\}$，右子区域定义为连续索引集 $\\{m-o,\\dots,N-1\\}$。对于每个子区域，构建其相应大小的局部离散诺伊曼算子（如步骤1，但使用子区域大小代替 $N$），并使用相同的奇异值阈值判据计算零空间维度 $d_{\\text{sub},1}$ 和 $d_{\\text{sub},2}$。报告这些整数。\n\n4. 对于非重叠Schur补方法，定义界面集 $\\Gamma = \\{m\\}$ 和内部集 $I = \\{0,1,\\dots,m-1,m+1,\\dots,N-1\\}$。通过对内点进行分块高斯消元，形成 $\\Gamma$ 上的Schur补 $S$。通过计算其最小奇异值 $s_{\\min}$ 来量化其奇异性。\n\n5. 通过增加一个均值约束来增广凝聚界面系统，以消除 $\\Gamma$ 上的常数模态。具体来说，构建增广的 $2 \\times 2$ 矩阵\n$$\n\\tilde{S} = \\begin{bmatrix}\nS  1 \\\\\n1  0\n\\end{bmatrix},\n$$\n其中标量 $1$ 将界面未知量与一个用于施加约束的拉格朗日乘子耦合起来。计算 $\\tilde{S}$ 的最小奇异值 $s_{\\min}^{\\text{aug}}$。\n\n数值考虑：\n\n- 在确定零空间维度时，使用 $10^{-10}$ 的绝对奇异值容差。\n- 所有计算都是无量纲的；不需要物理单位。\n\n测试套件和输出规范：\n\n在以下三个测试用例上运行程序：\n- 测试用例1：$N=8$, $m=4$, $o=1$。\n- 测试用例2：$N=7$, $m=3$, $o=2$。\n- 测试用例3（边界边缘情况）：$N=3$, $m=1$, $o=1$。\n\n对于每个测试用例，按以下顺序生成五个结果：\n- $d_{\\text{glob}}$ (整数),\n- $d_{\\text{sub},1}$ (整数),\n- $d_{\\text{sub},2}$ (整数),\n- $s_{\\min}$ (浮点数),\n- $s_{\\min}^{\\text{aug}}$ (浮点数)。\n\n您的程序应生成单行输出，其中包含所有三个测试用例的结果，按上述顺序串联成一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,\\dots,r_{15}]$）。每个条目必须是整数或浮点数；输出行中不得包含任何额外文本。", "solution": "当前任务要求对一维泊松方程齐次诺伊曼边界条件问题中，零空间对两种主流区域分解方法（即重叠Schwarz方法和非重叠Schur补方法）的影响进行计算分析。该分析始于对连续问题的恰当离散化，并通过一系列基于奇异值分解（SVD）的代数操作和量化来进行。\n\n首先，我们处理问题的离散化：求解一个函数 $u$，使得在 $(0,1)$ 内满足 $-\\frac{d^2u}{dx^2} = f$，并满足边界条件 $\\frac{du}{dx}(0) = 0$ 和 $\\frac{du}{dx}(1) = 0$。我们使用 $N$ 个等距点 $x_i = i \\cdot h$（其中 $i \\in \\{0, 1, \\dots, N-1\\}$，网格间距为 $h = 1/(N-1)$）来离散域 $[0,1]$。带有齐次诺伊曼条件的负二阶导数的标准、对称、半正定离散算子可由有限元或有限体积方法推导得出。这将得到一个按 $1/h^2$ 缩放的 $N \\times N$ 矩阵 $A$，其结构如下：\n$$\nA = \\frac{1}{h^2} \\begin{pmatrix}\n1  -1    \\mathbf{0} \\\\\n-1  2  -1   \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  -1  2  -1 \\\\\n\\mathbf{0}    -1  1\n\\end{pmatrix}\n$$\n该矩阵 $A$ 是对称且半正定的。其零空间是一维的，由常数向量 $\\mathbf{1} = [1, 1, \\dots, 1]^T$ 张成，因为每行的和都为零，这意味着 $A \\mathbf{1} = \\mathbf{0}$。\n\n计算任务如下：\n\n1.  **全局零空间维度 ($d_{\\text{glob}}$)**：我们如上所述构建全局矩阵 $A \\in \\mathbb{R}^{N \\times N}$。其零空间的维度 $d_{\\text{glob}}$ 通过计算 $A$ 的奇异值并统计小于或等于指定容差 $\\tau = 10^{-10}$ 的奇异值数量来确定。根据诺伊曼问题的性质，我们预期 $d_{\\text{glob}} = 1$。\n\n2.  **重叠Schwarz子区域零空间 ($d_{\\text{sub},1}, d_{\\text{sub},2}$)**: 区域被分解为两个重叠的子区域。左子区域 $\\Omega_1$ 对应于索引 $\\{0, 1, \\dots, m+o\\}$，右子区域 $\\Omega_2$ 对应于索引 $\\{m-o, \\dots, N-1\\}$。这些子区域的大小分别为 $N_1 = m+o+1$ 和 $N_2 = (N-1) - (m-o) + 1 = N-m+o$。问题规定，这些子区域的局部算子本身就是离散诺伊曼拉普拉斯算子，定义在局部网格上，其网格间距分别为 $h_1 = 1/(N_1-1)$ 和 $h_2 = 1/(N_2-1)$。这些是所谓的“浮动子区域”，因为它们仅具有诺伊曼边界条件（物理的或人工的）。因此，对于 $k \\in \\{1, 2\\}$，每个局部算子 $A_k \\in \\mathbb{R}^{N_k \\times N_k}$ 都将有其自己的一维零空间。我们通过应用相同的基于SVD的阈值方法来计算零空间维度 $d_{\\text{sub},1}$ 和 $d_{\\text{sub},2}$。我们预期 $d_{\\text{sub},1}=1$ 和 $d_{\\text{sub},2}=1$。\n\n3.  **非重叠Schur补奇异性 ($s_{\\min}$)**: 为进行此分析，区域被划分为两个不重叠的内部集 $I_1 = \\{0, \\dots, m-1\\}$ 和 $I_2 = \\{m+1, \\dots, N-1\\}$，以及一个单节点界面集 $\\Gamma = \\{m\\}$。全局线性系统 $Au=b$ 根据内部自由度 $I = I_1 \\cup I_2$ 和界面自由度 $\\Gamma$ 进行重新排序：\n    $$\n    \\begin{pmatrix} A_{II}  A_{I\\Gamma} \\\\ A_{\\Gamma I}  A_{\\Gamma\\Gamma} \\end{pmatrix} \\begin{pmatrix} u_I \\\\ u_\\Gamma \\end{pmatrix} = \\begin{pmatrix} b_I \\\\ b_\\Gamma \\end{pmatrix}\n    $$\n    对内部变量 $u_I$ 进行分块高斯消元，得到界面上的Schur补系统：$S u_\\Gamma = b_\\Gamma - A_{\\Gamma I} A_{II}^{-1} b_I$，其中Schur补算子为 $S = A_{\\Gamma\\Gamma} - A_{\\Gamma I} A_{II}^{-1} A_{I\\Gamma}$。\n    矩阵 $A_{II}$ 是块对角矩阵，因为内部集 $I_1$ 和 $I_2$ 是不相连的，即 $A_{II} = \\text{diag}(A_{I_1I_1}, A_{I_2I_2})$。每个块对应一个一端为诺伊曼条件、另一端（与 $\\Gamma$ 连接处）为狄利克雷条件的离散拉普拉斯算子，因此是可逆的。所以，$A_{II}$ 是可逆的。\n    我们可以证明 $S$ 必须是奇异的。由于全局矩阵 $A$ 有一个零向量 $\\mathbf{1}$，我们有 $A\\mathbf{1} = \\mathbf{0}$。以分块形式表示，这给出：\n    $$\n    A_{II} \\mathbf{1}_I + A_{I\\Gamma} \\mathbf{1}_\\Gamma = \\mathbf{0} \\quad \\text{and} \\quad A_{\\Gamma I} \\mathbf{1}_I + A_{\\Gamma\\Gamma} \\mathbf{1}_\\Gamma = \\mathbf{0}\n    $$\n    由于 $A_{II}$ 是可逆的，从第一个方程我们得到 $\\mathbf{1}_I = -A_{II}^{-1} A_{I\\Gamma} \\mathbf{1}_\\Gamma$。将此代入第二个方程，得到：\n    $$\n    A_{\\Gamma I} (-A_{II}^{-1} A_{I\\Gamma} \\mathbf{1}_\\Gamma) + A_{\\Gamma\\Gamma} \\mathbf{1}_\\Gamma = (A_{\\Gamma\\Gamma} - A_{\\Gamma I} A_{II}^{-1} A_{I\\Gamma}) \\mathbf{1}_\\Gamma = S \\mathbf{1}_\\Gamma = \\mathbf{0}\n    $$\n    由于我们的界面 $\\Gamma$ 只包含一个节点，$S$ 是一个标量，$\\mathbf{1}_\\Gamma$ 也是标量 $1$。这意味着 $S \\cdot 1 = 0$，所以 $S=0$。在数值上，由于浮点运算，我们预期其最小奇异值 $s_{\\min} = |S|$ 会接近于零。\n\n4.  **增广Schur补的正则性 ($s_{\\min}^{\\text{aug}}$)**: $S$ 的奇异性反映了原始诺伊曼问题的全局零空间。为了获得一个可解的界面系统，可以增广Schur补系统以消除这个零空间。一种常见的方法是通过拉格朗日乘子增加一个约束，例如零均值条件。这导致了增广的 $2 \\times 2$ 分块系统：\n    $$\n    \\tilde{S} = \\begin{bmatrix}\n    S  1 \\\\\n    1  0\n    \\end{bmatrix}\n    $$\n    在 $S=0$ 的理想情况下，该矩阵为 $\\tilde{S} = \\begin{bmatrix} 0  1 \\\\ 1  0 \\end{bmatrix}$。其特征值为 $\\lambda = \\pm 1$，奇异值为 $|\\lambda| = 1$。该矩阵是良态的。我们计算数值计算出的 $\\tilde{S}$ 的最小奇异值 $s_{\\min}^{\\text{aug}}$。鉴于 $S \\approx 0$，我们预期 $s_{\\min}^{\\text{aug}} \\approx 1$。\n\n基于此理论基础，每个测试用例的预期结果都是一个形式为 $(1, 1, 1, \\approx 0, \\approx 1)$ 的序列。接下来的实现将对这些预测进行数值验证。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import svdvals\n\ndef create_neumann_laplacian(N: int, h: float) -> np.ndarray:\n    \"\"\"\n    Constructs the N x N discrete 1D Neumann Laplacian matrix.\n    \n    The matrix corresponds to a second-order finite difference/element\n    discretization of the negative second derivative -d^2/dx^2 on a\n    uniform grid with N points and spacing h, with homogeneous Neumann\n    boundary conditions at both ends.\n    \"\"\"\n    if N == 0:\n        return np.array([[]])\n    if N == 1:\n        # A single point with Neumann conditions on both sides has no 'stiffness'.\n        # The operator is the zero operator. It has a 1D null space.\n        return np.array([[0.0]])\n        \n    A = np.zeros((N, N))\n    \n    # Interior nodes\n    for i in range(1, N - 1):\n        A[i, i - 1] = -1.0\n        A[i, i]     = 2.0\n        A[i, i + 1] = -1.0\n        \n    # Boundary nodes\n    A[0, 0] = 1.0\n    A[0, 1] = -1.0\n    \n    A[N - 1, N - 2] = -1.0\n    A[N - 1, N - 1] = 1.0\n    \n    h2 = h * h\n    if h2 > 0:\n      A /= h2\n      \n    return A\n\ndef solve():\n    \"\"\"\n    Executes the computational tasks for the given test suite and prints results.\n    \"\"\"\n    test_cases = [\n        # (N, m, o)\n        (8, 4, 1),\n        (7, 3, 2),\n        (3, 1, 1),\n    ]\n\n    results = []\n    TOL = 1e-10\n\n    for N, m, o in test_cases:\n        # Task 1  2: Global Operator and Null Space\n        if N > 1:\n            h_glob = 1.0 / (N - 1)\n        else:\n            h_glob = 0.0 # Avoid division by zero, handled by create_neumann_laplacian\n        \n        A = create_neumann_laplacian(N, h_glob)\n        s_glob = svdvals(A)\n        d_glob = np.sum(s_glob = TOL)\n        results.append(int(d_glob))\n\n        # Task 3: Overlapping Schwarz Subdomain Null Spaces\n        # Left subdomain\n        N1 = m + o + 1\n        if N1 > 1:\n            h1 = 1.0 / (N1 - 1)\n        else:\n            h1 = 0.0\n        A1 = create_neumann_laplacian(N1, h1)\n        s1 = svdvals(A1)\n        d_sub_1 = np.sum(s1 = TOL)\n        results.append(int(d_sub_1))\n\n        # Right subdomain\n        N2 = N - m + o\n        if N2 > 1:\n            h2 = 1.0 / (N2 - 1)\n        else:\n            h2 = 0.0\n        A2 = create_neumann_laplacian(N2, h2)\n        s2 = svdvals(A2)\n        d_sub_2 = np.sum(s2 = TOL)\n        results.append(int(d_sub_2))\n\n        # Task 4: Non-overlapping Schur Complement Singularity\n        Gamma = [m]\n        I = list(range(m)) + list(range(m + 1, N))\n        \n        A_GG = A[np.ix_(Gamma, Gamma)]\n        A_GI = A[np.ix_(Gamma, I)]\n        A_IG = A[np.ix_(I, Gamma)]\n        A_II = A[np.ix_(I, I)]\n        \n        # Solve A_II * X = A_IG for X, then S = A_GG - A_GI @ X\n        try:\n            x = np.linalg.solve(A_II, A_IG)\n            S_matrix = A_GG - A_GI @ x\n            S = S_matrix[0, 0]\n        except np.linalg.LinAlgError:\n            # This case shouldn't be reached with the given problem setup\n            # as A_II is invertible.\n            S = np.nan\n\n        # Smallest singular value of S (which is a scalar) is its absolute value.\n        s_min = np.abs(S)\n        results.append(s_min)\n        \n        # Task 5: Augmented Schur Complement\n        S_tilde = np.array([[S, 1.0], [1.0, 0.0]])\n        s_tilde_vals = svdvals(S_tilde)\n        s_min_aug = np.min(s_tilde_vals)\n        results.append(s_min_aug)\n\n    # Format output without scientific notation for small floats\n    formatted_results = []\n    for res in results:\n        if isinstance(res, float):\n            formatted_results.append(f\"{res:.15f}\".rstrip('0').rstrip('.'))\n        else:\n            formatted_results.append(str(res))\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3428530"}]}