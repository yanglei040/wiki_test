{"hands_on_practices": [{"introduction": "在并行计算中，使用区域分解方法的第一步是正确地为“幽灵单元”（ghost cells）或“光环”（halo）分配内存。这个练习将带你从最基本的二维情况入手，计算一个进程需要存储的幽灵单元总数。通过这个计算，你将掌握估算并行程序内存占用的基本技能，并理解局部区域尺寸和计算模板（stencil）宽度如何直接影响资源需求。[@problem_id:3399975]", "problem": "考虑一个用于偏微分方程有限差分离散化的二维 ($2$D) 笛卡尔网格。全局网格有 $N_x \\times N_y$ 个内部点，并被分解为 $P_x \\times P_y$ 个大小相等的矩形子域，每个子域映射到一个独立的消息传递接口 (MPI) 进程（rank）。设每个进程的局部内部尺寸为 $n_x = N_x/P_x$ 和 $n_y = N_y/P_y$。为了支持需要最近邻数据的计算模板（stencil），每个进程沿其四个面各分配一个宽度均匀为 $g \\in \\mathbb{N}$ 的光环（halo，也称鬼层，ghost layer）。光环分配策略如下：只存储与面相邻的鬼单元，为避免冗余不存储角落的鬼单元；每个进程的分配是统一的，无论子域是否接触全局域的物理边界。\n\n根据标准定义，一个面旁边宽度为 $g$ 的光环包含 $g$ 层与该面相邻且跨越整个相对内部维度的单元。基于此定义，推导出一个封闭形式表达式，用于计算每个进程存储的鬼单元总数。该表达式仅用 $n_x$、$n_y$ 和 $g$ 表示，且已知计算只包括面而不包括角。\n\n请以单个简化的解析表达式形式给出最终结果。不需要进行数值计算，也不涉及单位。最终答案必须是单个表达式。", "solution": "在进行求解之前，将对问题进行验证。\n\n### 第 1 步：提取已知条件\n问题提供了以下信息：\n- 网格类型：二维 ($2$D) 笛卡尔网格。\n- 全局网格尺寸：$N_x \\times N_y$ 个内部点。\n- 分解：$P_x \\times P_y$ 个大小相等的矩形子域。\n- 映射：每个子域映射到一个独立的 MPI 进程。\n- 局部内部尺寸：每个进程 $n_x = N_x/P_x$ 和 $n_y = N_y/P_y$ 个点。\n- 计算模板要求：离散化模板需要最近邻数据。\n- 光环宽度：每个进程沿其四个面各分配一个宽度均匀为 $g \\in \\mathbb{N}$ 的光环（鬼层）。\n- 光环分配策略：\n  1. 只存储与面相邻的鬼单元。\n  2. 不存储角落的鬼单元。\n  3. 每个进程的分配是统一的，无论子域是否位于全局边界。\n- 光环定义：一个面旁边宽度为 $g$ 的光环包含 $g$ 层与该面相邻且跨越整个相对内部维度的单元。\n- 目标：推导每个进程存储的鬼单元总数的封闭形式表达式。\n- 表达式变量：最终表达式必须仅用 $n_x$、$n_y$ 和 $g$ 表示。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据既定标准对问题进行验证。\n- **科学性**：该问题在高性能计算和求解偏微分方程（PDE）的数值方法领域有坚实的科学基础。域分解、鬼单元（光环）和 MPI 进程映射等概念是标准和基础的技术。\n- **适定性**：该问题是适定的。它提供了清晰且充分的信息来推导唯一解。局部内部域的维度（$n_x, n_y$）、光环宽度（$g$）以及特定的分配策略（仅面、无角）都已明确定义。\n- **客观性**：语言精确、技术性强，没有任何主观或基于意见的陈述。\n- **完整性与一致性**：问题是自洽且一致的。关于如何构建光环以及排除哪些单元（角）的定义是明确的。所有进程分配统一的规则简化了问题，使解决方案与进程在全局网格中的位置无关。没有缺失或矛盾的约束。\n- **现实性**：该设置是科学模拟并行编程中一个现实且常见的情景。\n\n### 第 3 步：结论与行动\n该问题被认定为有效。它在科学上是合理的、适定的，并包含推导唯一确定解所需的所有必要信息。现在开始推导解。\n\n### 解题推导\n目标是计算单个子域（或进程）的鬼单元总数，记为 $N_{ghost}$。\n\n每个进程管理一个维度为 $n_x \\times n_y$ 的局部内部计算单元网格。为了处理该子域边界上的数据依赖关系，需要添加一层鬼单元。问题规定，沿子域的四个面各分配一个宽度均匀为 $g$ 的鬼层。\n\n让我们分析每个面的贡献。策略明确指出不存储角落区域。这可以通过将四个光环视为四个独立的矩形单元带来实现。\n\n1.  **与 x 轴平行的面（顶部和底部）的光环：**\n    一个子域有一个顶面和一个底面。这些面的长度由 x 方向上的内部单元数决定，即 $n_x$。\n    沿顶面的光环是一个矩形单元区域，其长度为 $n_x$，宽度为 $g$。这个顶部光环的单元数是 $g \\times n_x$。\n    同样，沿底面的光环是一个矩形单元区域，其长度为 $n_x$，宽度为 $g$。这个底部光环的单元数是 $g \\times n_x$。\n    顶部和底部面的鬼单元总数是这两者之和，即 $g n_x + g n_x = 2gn_x$。\n\n2.  **与 y 轴平行的面（左侧和右侧）的光环：**\n    一个子域有一个左侧面和一个右侧面。这些面的长度由 y 方向上的内部单元数决定，即 $n_y$。\n    沿右侧面的光环是一个矩形单元区域，其长度为 $n_y$，宽度为 $g$。这个右侧光环的单元数是 $g \\times n_y$。\n    同样，沿左侧面的光环是一个矩形单元区域，其长度为 $n_y$，宽度为 $g$。这个左侧光环的单元数是 $g \\times n_y$。\n    左侧和右侧面的鬼单元总数是这两者之和，即 $g n_y + g n_y = 2gn_y$。\n\n3.  **鬼单元总数：**\n    鬼单元总数 $N_{ghost}$ 是所有四个与面相邻的光环中单元数的总和。由于我们独立计算了四个矩形光环区域，这种构造方法本身就排除了任何角落区域，完全符合问题陈述。\n    $$\n    N_{ghost} = (\\text{Top Halo Size}) + (\\text{Bottom Halo Size}) + (\\text{Left Halo Size}) + (\\text{Right Halo Size})\n    $$\n    代入上面推导出的表达式：\n    $$\n    N_{ghost} = (gn_x) + (gn_x) + (gn_y) + (gn_y)\n    $$\n    $$\n    N_{ghost} = 2gn_x + 2gn_y\n    $$\n    通过提取公因式 $2g$，可以简化该表达式。\n    $$\n    N_{ghost} = 2g(n_x + n_y)\n    $$\n    这就是每个进程存储的鬼单元总数的最终封闭形式表达式，按要求仅用 $n_x$、$n_y$ 和 $g$ 表示。", "answer": "$$\n\\boxed{2g(n_x + n_y)}\n$$", "id": "3399975"}, {"introduction": "在掌握了基本的幽灵单元数量计算后，我们可以进一步探讨一个在高性能计算中至关重要的性能指标：内存开销。这个练习将场景扩展到更常见的三维情况，要求你推导幽灵单元所占内存与有效计算区域内存的比例，即“开销分数”（overhead fraction）。理解并量化这一开销对于分析并行代码的可扩展性至关重要，因为过高的内存开销会削弱并行化带来的性能优势。[@problem_id:3400024]", "problem": "考虑一种三维分块结构化离散方法，用于在分布式内存的高性能计算（HPC）模型下，使用消息传递接口（MPI）在结构化网格上通过有限体积法或有限差分法求解偏微分方程（PDE）。每个计算块存储一个大小为 $n_x \\times n_y \\times n_z$ 个单元的内部区域，并在每个笛卡尔坐标方向上维护宽度为 $g$ 个单元的对称幽灵层，以支持多点模板的晕环交换。幽灵层分配在所有面上，因此由面扩展产生的边和角也一并存在。假设每个单元存储一个标量场，内部单元和幽灵单元的存储大小相同，并忽略任何填充、对齐或额外的元数据。\n\n仅使用数组范围和幽灵单元层的核心定义，从第一性原理推导当存在幽灵层时块内分配的总单元数，将其与仅内部区域的分配进行比较，并将开销比例（额外分配与内部自分配的比率）表示为以 $g$、$n_x$、$n_y$ 和 $n_z$ 为变量的闭式代数表达式。其中 $g \\in \\mathbb{N}_0$ 且 $n_x, n_y, n_z \\in \\mathbb{N}$。以单一解析表达式的形式给出最终答案。无需四舍五入，也无需单位。", "solution": "问题陈述已经过验证，被认为是具有科学依据、适定、客观且完整的。它描述了在高性能科学计算中用于求解偏微分方程数值解的一种标准配置。因此，我们可以继续进行推导。\n\n目标是推导内存分配开销比例的闭式代数表达式，该比例定义为幽灵单元数与内部单元数的比率。给定的参数是内部计算域的维度 $n_x$、$n_y$ 和 $n_z$，以及幽灵单元层的宽度 $g$。\n\n首先，我们确定计算块内部区域的单元数。该区域是一个维度为 $n_x \\times n_y \\times n_z$ 的长方体。内部单元的总数，我们记为 $N_{\\text{int}}$，即为该长方体的体积。\n$$N_{\\text{int}} = n_x n_y n_z$$\n\n接下来，我们确定为该块分配的总单元数，包括幽灵单元层。问题指明在每个笛卡尔坐标方向上都有宽度为 $g$ 的对称幽灵层。这意味着对于每个维度，在内部域的下界和上界都增加了 $g$ 层。\n\n对于 $x$ 维度，内部区域跨越 $n_x$ 个单元。在其两个垂直于 $x$ 轴的面上各有一个宽度为 $g$ 的幽灵层后，$x$ 方向的总范围变为 $g + n_x + g = n_x + 2g$ 个单元。\n\n类似地，$y$ 和 $z$ 方向的总范围分别为 $n_y + 2g$ 和 $n_z + 2g$ 个单元。\n\n问题陈述指出，完全分配的块包括由扩展基于面的幽灵层而产生的角和边。这证实了总分配内存对应于一个具有这些新维度的更大的长方体。分配的总单元数，记为 $N_{\\text{total}}$，是这些总范围的乘积。\n$$N_{\\text{total}} = (n_x + 2g)(n_y + 2g)(n_z + 2g)$$\n\n“额外”的单元数，即幽灵单元的数量，是分配的总单元数与内部单元数之差。我们将其记为 $N_{\\text{ghost}}$。\n$$N_{\\text{ghost}} = N_{\\text{total}} - N_{\\text{int}} = (n_x + 2g)(n_y + 2g)(n_z + 2g) - n_x n_y n_z$$\n\n问题将开销比例 $F_{\\text{overhead}}$ 定义为额外分配与内部自分配的比率。\n$$F_{\\text{overhead}} = \\frac{N_{\\text{ghost}}}{N_{\\text{int}}}$$\n\n代入 $N_{\\text{ghost}}$ 和 $N_{\\text{int}}$ 的表达式：\n$$F_{\\text{overhead}} = \\frac{(n_x + 2g)(n_y + 2g)(n_z + 2g) - n_x n_y n_z}{n_x n_y n_z}$$\n\n这个表达式可以简化为两项：\n$$F_{\\text{overhead}} = \\frac{(n_x + 2g)(n_y + 2g)(n_z + 2g)}{n_x n_y n_z} - \\frac{n_x n_y n_z}{n_x n_y n_z}$$\n$$F_{\\text{overhead}} = \\frac{(n_x + 2g)(n_y + 2g)(n_z + 2g)}{n_x n_y n_z} - 1$$\n\n第一项可以写成各维度比率的乘积：\n$$F_{\\text{overhead}} = \\left(\\frac{n_x + 2g}{n_x}\\right) \\left(\\frac{n_y + 2g}{n_y}\\right) \\left(\\frac{n_z + 2g}{n_z}\\right) - 1$$\n\n最后，简化括号内的项，即可得到开销比例的闭式表达式：\n$$F_{\\text{overhead}} = \\left(1 + \\frac{2g}{n_x}\\right) \\left(1 + \\frac{2g}{n_y}\\right) \\left(1 + \\frac{2g}{n_z}\\right) - 1$$\n\n这就是所要求的以 $g$、$n_x$、$n_y$ 和 $n_z$ 表示的闭式代数表达式。", "answer": "$$\\boxed{\\left(1 + \\frac{2g}{n_x}\\right) \\left(1 + \\frac{2g}{n_y}\\right) \\left(1 + \\frac{2g}{n_z}\\right) - 1}$$", "id": "3400024"}, {"introduction": "我们已经了解了幽灵单元的内存成本，但它们在数值模拟中的核心作用是什么？如果光环交换（halo exchange）中的数据不正确，会产生什么后果？这个练习将深入探讨幽灵单元的根本目的：确保数值格式在跨越子区域边界时依然保持守恒性。通过分析一个因光环交换实现错误而导致的通量不平衡问题，你将深刻理解为何精确、正确的光环交换对于保证模拟结果的物理真实性是不可或缺的。[@problem_id:3400001]", "problem": "考虑一维线性平流守恒律 $\\partial_{t} u + a \\,\\partial_{x} u = 0$，其中 $u(x,t)$ 是一个无量纲守恒标量，以恒定速度 $a>0$ 平流。该区域被划分为两个子域，使用消息传递接口 (MPI) 在两个进程上独立进行计算。左子域具有均匀的有限体积网格，网格单元宽度为 $\\Delta x_{L}$；右子域具有均匀的有限体积网格，网格单元宽度为 $\\Delta x_{R}$。界面位于面 $x=x_{f}$ 上，左子域最右侧的网格单元中心在 $x_{f}-\\Delta x_{L}/2$，右子域最左侧的网格单元中心在 $x_{f}+\\Delta x_{R}/2$。令 $u_{N}$ 表示与界面相邻的左子域最后一个网格单元中的单元平均值，而 $u_{N+1}$ 表示与界面相邻的右子域第一个网格单元中的单元平均值。\n\n两个子域都使用与守恒律一致的一阶迎风（施主单元）有限体积通量：面上的数值通量为 $F = a\\,u_{\\text{donor}}$，当 $a>0$ 时，$u_{\\text{donor}}$ 取自上游（左侧）的网格单元。跨界面的全局守恒要求两个子域在共享面上使用相同的通量，这在这种情况下要求右子域的虚拟单元值被设置为 $u_{N}$。\n\n然而，假设由于一个光环交换（halo exchange）的程序错误，右子域的虚拟单元通过在界面位置对 $u_{N}$ 和 $u_{N+1}$ 进行线性插值而被错误地填充。具体来说，右子域使用的虚拟单元值为\n$$\nu_{g} \\equiv \\lambda\\,u_{N} + (1-\\lambda)\\,u_{N+1}, \\quad \\text{其中} \\quad \\lambda \\equiv \\frac{\\Delta x_{R}}{\\Delta x_{L}+\\Delta x_{R}}.\n$$\n所有物理量均为无量纲。仅使用守恒律有限体积框架和施主单元迎风通量定义，推导由这种不正确的虚拟单元填充所引起的净界面通量不平衡，并由此估算在耦合的双子域系统中每个时间步长 $\\Delta t$ 内引入的全局质量误差。\n\n请以关于 $a$、$\\Delta t$、$\\Delta x_{L}$、$\\Delta x_{R}$、$u_{N}$ 和 $u_{N+1}$ 的单个闭式解析表达式的形式提供您的最终答案。无需四舍五入。", "solution": "用户要求我首先验证一个关于一维平流方程并行有限体积模拟中数值误差的问题，然后解决它。\n\n### 步骤 1：问题验证 - 提取已知条件\n首先，我将列出问题陈述中提供的已知条件。\n-   **控制方程**：一维线性平流守恒律为 $\\partial_{t} u + a \\,\\partial_{x} u = 0$。\n-   **平流速度**：一个恒定速度 $a > 0$。\n-   **区域分解**：区域被划分为左、右两个子域，由两个独立的进程处理。\n-   **网格**：左子域具有均匀网格，网格单元宽度为 $\\Delta x_{L}$。右子域具有均匀网格，网格单元宽度为 $\\Delta x_{R}$。\n-   **界面几何**：界面位于 $x=x_{f}$。左侧最后一个网格单元中心在 $x_{f}-\\frac{\\Delta x_{L}}{2}$。右侧第一个网格单元中心在 $x_{f}+\\frac{\\Delta x_{R}}{2}$。\n-   **界面状态**：左子域最后一个网格单元的单元平均值为 $u_{N}$。右子域第一个网格单元的单元平均值为 $u_{N+1}$。\n-   **数值通量**：两个子域都使用一阶迎风（施主单元）有限体积通量。对于 $a>0$，面上的通量为 $F = a\\,u_{\\text{donor}}$，其中 $u_{\\text{donor}}$ 是上游（左侧）网格单元的单元平均值。\n-   **正确的界面条件**：全局守恒要求右子域的虚拟单元值被设置为 $u_{N}$。\n-   **错误的虚拟单元（程序错误）**：由于一个程序错误，右子域的虚拟单元值通过线性插值被填充为：$u_{g} \\equiv \\lambda\\,u_{N} + (1-\\lambda)\\,u_{N+1}$，其中 $\\lambda \\equiv \\frac{\\Delta x_{R}}{\\Delta x_{L}+\\Delta x_{R}}$。\n-   **目标**：推导净界面通量不平衡，并用它来求出每个时间步长 $\\Delta t$ 内引入的全局质量误差。最终答案应为一个关于 $a$、$\\Delta t$、$\\Delta x_{L}$、$\\Delta x_{R}$、$u_{N}$ 和 $u_{N+1}$ 的解析表达式。\n\n### 步骤 2：问题验证 - 评估\n该问题定义明确，并基于偏微分方程数值方法的原理，特别是在并行计算的区域分解背景下。\n-   **科学上合理**：该问题使用了标准概念：线性平流方程、有限体积法、迎风通量以及虚拟单元/光环交换机制。这些都是科学计算中的基本课题。光环交换中出现错误的场景是一个现实且实际的问题。\n-   **适定的**：该问题是自洽的。所有必要的信息，包括控制方程、数值格式以及错误的虚拟单元值的显式形式都已提供。目标陈述清晰，可以从给定条件中推导出唯一的解析解。\n-   **客观的**：问题以精确、技术性的语言陈述，没有主观性或歧义。\n\n该问题没有违反任何无效性标准。它不是科学上不合理、不可形式化、不完整、不现实或不适定的。它提出了一个数值分析中标准的、尽管是错误的场景。\n\n### 步骤 3：结论与行动\n问题是 **有效的**。我将开始推导解答。\n\n### 解答推导\n问题要求的是由于两个子域之间界面上错误的虚拟单元实现而导致的每个时间步长 $\\Delta t$ 内引入的全局质量误差。对于形如 $\\partial_t u + \\partial_x f(u) = 0$ 的守恒律的有限体积方法，如果所有网格单元界面上的数值通量是一致的，那么系统中的总“质量”（即 $u$ 在整个区域上的积分）是守恒的。如果离开一个网格单元的通量不等于进入相邻网格单元的通量，就会产生质量误差。由于程序错误，这正是在 MPI 界面上发生的情况。\n\n系统中的总质量为 $M = \\sum_i u_i \\Delta x_i$。总质量的变化率由全局域边界上的净通量给出。如果格式不是局部守恒的，内部界面上可能会引入虚假的质量源或汇。这种虚假质量生成率等于界面上的通量不平衡。\n\n我们将位于 $x=x_f$ 的界面记为面 $N+1/2$。\n\n1.  **左子域（进程1）计算的通量**：\n    左子域计算其最右侧网格单元（单元 $N$）流出的通量 $F_{N+1/2}^{\\text{left}}$。数值通量为一阶迎风，$F = a\\,u_{\\text{donor}}$。由于 $a>0$，流动是从左到右，所以施主单元是上游的单元，即单元 $N$。\n    因此，由左侧进程计算的通量是：\n    $$F_{N+1/2}^{\\text{left}} = a \\, u_{N}$$\n\n2.  **右子域（进程2）计算的通量**：\n    右子域计算流入其最左侧网格单元（单元 $N+1$）的通量 $F_{N+1/2}^{\\text{right}}$。对于这个通量计算，施主单元是界面左侧的单元，它在右子域中表示为一个虚拟单元。问题陈述给出了由于程序错误导致的这个虚拟单元的值 $u_g$。\n    由右侧进程计算的通量是：\n    $$F_{N+1/2}^{\\text{right}} = a \\, u_{g}$$\n    代入给定的 $u_g$ 表达式：\n    $$F_{N+1/2}^{\\text{right}} = a \\left( \\lambda\\,u_{N} + (1-\\lambda)\\,u_{N+1} \\right)$$\n    其中 $\\lambda = \\frac{\\Delta x_{R}}{\\Delta x_{L}+\\Delta x_{R}}$。\n\n3.  **净界面通量不平衡**：\n    对于一个全局守恒的格式，我们必须有 $F_{N+1/2}^{\\text{left}} = F_{N+1/2}^{\\text{right}}$。这个程序错误引入了一个差异。作为界面上质量源或汇的净界面通量不平衡是这两个通量之差。\n    $$ \\text{通量不平衡} = F_{N+1/2}^{\\text{right}} - F_{N+1/2}^{\\text{left}} $$\n    $$ \\text{通量不平衡} = a \\left( \\lambda\\,u_{N} + (1-\\lambda)\\,u_{N+1} \\right) - a \\, u_{N} $$\n    $$ \\text{通量不平衡} = a \\left( (\\lambda - 1)u_{N} + (1-\\lambda)u_{N+1} \\right) $$\n    提出公因子 $(1-\\lambda)$：\n    $$ \\text{通量不平衡} = a (1-\\lambda) (u_{N+1} - u_{N}) $$\n    这是问题要求的第一部分。\n\n4.  **每个时间步长的全局质量误差**：\n    通量不平衡代表了在界面上虚假地产生或销毁质量的速率。在一个持续时间为 $\\Delta t$ 的时间步内引入的总质量误差 $\\Delta M_{\\text{error}}$ 是该速率乘以 $\\Delta t$。\n    $$ \\Delta M_{\\text{error}} = (\\text{通量不平衡}) \\times \\Delta t $$\n    $$ \\Delta M_{\\text{error}} = a \\, \\Delta t (1-\\lambda) (u_{N+1} - u_{N}) $$\n    为了得到最终表达式，我们代入 $\\lambda$ 的定义：\n    $$ 1-\\lambda = 1 - \\frac{\\Delta x_{R}}{\\Delta x_{L}+\\Delta x_{R}} = \\frac{(\\Delta x_{L}+\\Delta x_{R}) - \\Delta x_{R}}{\\Delta x_{L}+\\Delta x_{R}} = \\frac{\\Delta x_{L}}{\\Delta x_{L}+\\Delta x_{R}} $$\n    将此代回质量误差的表达式中：\n    $$ \\Delta M_{\\text{error}} = a \\, \\Delta t \\left( \\frac{\\Delta x_{L}}{\\Delta x_{L}+\\Delta x_{R}} \\right) (u_{N+1} - u_{N}) $$\n    这是每个时间步长引入的全局质量误差的最终闭式解析表达式。它用所需的变量 $a$、$\\Delta t$、$\\Delta x_{L}$、$\\Delta x_{R}$、$u_{N}$ 和 $u_{N+1}$ 表示。", "answer": "$$\\boxed{a \\Delta t \\frac{\\Delta x_{L}}{\\Delta x_{L} + \\Delta x_{R}} (u_{N+1} - u_{N})}$$", "id": "3400001"}]}