{"hands_on_practices": [{"introduction": "第一个练习是一项基础的、需要动手计算的任务，旨在揭开伪谱微分矩阵的神秘面纱。通过在一个小的勒让德-高斯-洛巴托网格（$N=4$）上手动计算微分矩阵 [@problem_id:3437283]，您将直接接触其核心组成部分：由多项式根确定的节点、重心权重以及最终的矩阵结构。这项基础实践将巩固理论定义与具体数值对象之间的联系。", "problem": "考虑构建与 $N=4$ 阶勒让德多项式相关的勒让德-高斯-洛巴托 (LGL) 网格的一阶导数伪谱微分矩阵。该矩阵是区间 $[-1,1]$ 上偏微分方程 (PDE) 数值解的伪谱方法的基础。\n\n仅从以下基本要素出发：\n- 勒让德多项式 $\\{P_n(x)\\}_{n \\ge 0}$ 的定义：其为在 $[-1,1]$ 上关于单位权重正交且通过 $P_n(1)=1$ 归一化的唯一多项式。\n- LGL 节点 $\\{x_j\\}_{j=0}^{N}$ 的定义：其为端点 $\\{-1,1\\}$ 和 $P_N'(x)$ 的零点的并集。\n- 与 LGL 网格相关的节点多项式 $\\phi(x)$ 为 $\\phi(x) \\propto (1-x^2)P_N'(x)$（相差一个非零乘法常数），重心权重 $\\{\\lambda_j\\}_{j=0}^{N}$ 的定义为 $\\lambda_j = 1/\\phi'(x_j)$（相差一个公共非零因子）。\n- 重心一阶微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 的定义为\n  $$\n  D_{ij}=\\frac{\\lambda_j}{\\lambda_i(x_i-x_j)} \\quad \\text{for } i\\neq j, \n  \\qquad \n  D_{ii}=-\\sum_{\\substack{j=0\\\\ j\\neq i}}^{N} D_{ij},\n  $$\n针对 $N=4$ 的情况，推导并执行以下步骤：\n\n1. 显式计算节点 $x_j$（排序为 $x_0=-1$, $x_4=1$ 且其间递增），并在每个节点上计算 $P_4'(x_j)$ 的值。\n2. 计算 $\\phi'(x)$，然后通过计算 $\\lambda_j=1/\\phi'(x_j)$ 来求得 $\\{\\lambda_j\\}_{j=0}^{4}$（相差一个公共非零乘法常数）。\n3. 使用 $D$ 的重心公式，在您计算出的量上通过精确算术数值验证 $D\\mathbf{1}=\\mathbf{0}$ 和 $D\\mathbf{x}=\\mathbf{1}$，其中 $\\mathbf{1}=(1,1,1,1,1)^{\\top}$ 和 $\\mathbf{x}=(x_0,x_1,x_2,x_3,x_4)^{\\top}$。\n4. 使用上述节点索引 $i,j\\in\\{0,1,2,3,4\\}$，精确确定单个矩阵元素 $D_{2,4}$。\n\n将您的最终结果表示为 $D_{2,4}$ 的精确值；无需四舍五入，不涉及物理单位。如果出现角度，请以弧度表示（尽管此处预计不会出现）。", "solution": "此解答遵循问题陈述中概述的四个步骤进行推导。\n\n#### 1. 计算节点 $x_j$ 并求解 $P_4'(x_j)$\n\n首先，我们需要阶数为 $N=4$ 的勒让德多项式 $P_4(x)$。其标准形式为 $P_4(x) = \\frac{1}{8}(35x^4 - 30x^2 + 3)$，满足归一化条件 $P_4(1)=1$。\n\n其导数 $P_4'(x)$ 为：\n$$\nP_4'(x) = \\frac{d}{dx} \\left[ \\frac{1}{8}(35x^4 - 30x^2 + 3) \\right] = \\frac{1}{8}(140x^3 - 60x) = \\frac{5}{2}x(7x^2 - 3)\n$$\n当 $N=4$ 时，LGL 节点由端点 $x=-1, 1$ 和 $P_4'(x)$ 的零点组成。我们通过令 $P_4'(x)=0$ 来找到这些零点：\n$$\n\\frac{5}{2}x(7x^2 - 3) = 0\n$$\n这给出 $x=0$ 和 $7x^2-3=0$，即 $x = \\pm\\sqrt{\\frac{3}{7}}$。\n因此，五个 LGL 节点 $\\{x_j\\}_{j=0}^4$ 按升序排列为：\n$$\nx_0 = -1, \\quad x_1 = -\\sqrt{\\frac{3}{7}}, \\quad x_2 = 0, \\quad x_3 = \\sqrt{\\frac{3}{7}}, \\quad x_4 = 1\n$$\n接下来，在这些节点上计算 $P_4'(x)$ 的值：\n- $P_4'(x_0) = P_4'(-1) = -10$\n- $P_4'(x_1) = P_4'(-\\sqrt{3/7}) = 0$\n- $P_4'(x_2) = P_4'(0) = 0$\n- $P_4'(x_3) = P_4'(\\sqrt{3/7}) = 0$\n- $P_4'(x_4) = P_4'(1) = 10$\n\n#### 2. 计算 $\\phi'(x)$ 和权重 $\\lambda_j$\n\n节点多项式为 $\\phi(x) \\propto (1-x^2)P_N'(x)$。根据勒让德多项式的性质，我们有 $\\frac{d}{dx}[(1-x^2)P_n'(x)] = -n(n+1)P_n(x)$。\n因此，对于 $N=4$ 且选择比例常数为1，我们得到 $\\phi(x) = (1-x^2)P_4'(x)$，其导数为：\n$$\n\\phi'(x) = -4(4+1)P_4(x) = -20P_4(x)\n$$\n重心权重定义为 $\\lambda_j = 1/\\phi'(x_j)$，相差一个公共常数。为方便起见，我们可忽略常数 $-20$，并定义 $\\lambda_j \\propto 1/P_4(x_j)$。我们计算节点上的 $P_4(x)$ 值：\n- $P_4(x_0) = P_4(-1) = 1$\n- $P_4(x_4) = P_4(1) = 1$\n- $P_4(x_2) = P_4(0) = \\frac{3}{8}$\n- 对于 $x_{1,3} = \\mp\\sqrt{3/7}$，我们有 $x^2 = 3/7$。\n  $P_4(x_{1,3}) = \\frac{1}{8}\\left(35\\left(\\frac{3}{7}\\right)^2 - 30\\left(\\frac{3}{7}\\right) + 3\\right) = \\frac{1}{8}\\left(\\frac{45}{7} - \\frac{90}{7} + \\frac{21}{7}\\right) = -\\frac{3}{7}$。\n因此，$P_4(x_1) = P_4(x_3) = -3/7$。\n\n为简化计算，我们可以选择一组与 $1/P_4(x_j)$ 成比例且易于处理的权重。例如，我们可以选择 $\\lambda_j = C/P_4(x_j)$，其中 $C$ 是任意非零常数。选择 $C=1$ 得到：\n- $\\lambda_0 = 1$\n- $\\lambda_1 = -7/3$\n- $\\lambda_2 = 8/3$\n- $\\lambda_3 = -7/3$\n- $\\lambda_4 = 1$\n\n#### 3. 验证 $D\\mathbf{1}=\\mathbf{0}$ 和 $D\\mathbf{x}=\\mathbf{1}$\n\n首先，验证 $D\\mathbf{1}=\\mathbf{0}$。向量 $D\\mathbf{1}$ 的第 $i$ 个分量是 $\\sum_{j=0}^4 D_{ij}$。根据对角元素的定义 $D_{ii} = -\\sum_{j \\neq i} D_{ij}$，我们有：\n$$\n(D\\mathbf{1})_i = D_{ii} + \\sum_{j \\neq i} D_{ij} = \\left(-\\sum_{j \\neq i} D_{ij}\\right) + \\sum_{j \\neq i} D_{ij} = 0\n$$\n这对任何 $i$ 都成立，因此 $D\\mathbf{1}=\\mathbf{0}$。此性质由矩阵构造本身保证。\n\n其次，验证 $D\\mathbf{x}=\\mathbf{1}$。此性质要求微分矩阵能精确地对一次多项式求导。$D\\mathbf{x}$ 的第 $i$ 个分量是：\n$$\n(D\\mathbf{x})_i = \\sum_{j=0}^{4} D_{ij}x_j = D_{ii}x_i + \\sum_{j \\neq i} D_{ij}x_j = \\sum_{j \\neq i} D_{ij}(x_j - x_i)\n$$\n代入非对角线元素的定义 $D_{ij} = \\frac{\\lambda_j}{\\lambda_i(x_i-x_j)}$：\n$$\n(D\\mathbf{x})_i = \\sum_{j \\neq i} \\frac{\\lambda_j}{\\lambda_i(x_i-x_j)}(x_j - x_i) = -\\frac{1}{\\lambda_i} \\sum_{j \\neq i} \\lambda_j\n$$\n要使 $(D\\mathbf{x})_i = 1$，必须有 $\\sum_{j \\neq i} \\lambda_j = -\\lambda_i$，这等价于 $\\sum_{j=0}^4 \\lambda_j = 0$。我们来验证这一条件：\n$$\n\\sum_{j=0}^{4} \\lambda_j = 1 + \\left(-\\frac{7}{3}\\right) + \\frac{8}{3} + \\left(-\\frac{7}{3}\\right) + 1 = 2 + \\frac{-7+8-7}{3} = 2 + \\frac{-6}{3} = 2 - 2 = 0\n$$\n总和为零，因此 $D\\mathbf{x}=\\mathbf{1}$ 得以验证。\n\n#### 4. 确定单个元素 $D_{2,4}$\n\n我们需要计算行索引 $i=2$、列索引 $j=4$ 的矩阵元素 $D_{2,4}$。使用非对角线公式：\n$$\nD_{ij} = \\frac{\\lambda_j}{\\lambda_i(x_i - x_j)}\n$$\n对于 $i=2, j=4$，我们代入相应的值：\n- $x_2 = 0$\n- $x_4 = 1$\n- $\\lambda_2 = 8/3$\n- $\\lambda_4 = 1$\n\n$$\nD_{2,4} = \\frac{\\lambda_4}{\\lambda_2(x_2 - x_4)} = \\frac{1}{\\frac{8}{3}(0 - 1)} = \\frac{1}{-\\frac{8}{3}} = -\\frac{3}{8}\n$$\n元素 $D_{2,4}$ 的精确值为 $-3/8$。", "answer": "$$\n\\boxed{-\\frac{3}{8}}\n$$", "id": "3437283"}, {"introduction": "在求解二阶微分方程时，一个常见的困惑是：二阶导数算子应如何正确表示，尤其是在施加边界条件之后？这个概念性问题 [@problem_id:3437294] 直接探讨了这一微妙之处，将简单地对子矩阵求平方的直观方法与数学上正确的构建方式进行了对比。理解这一区别对于正确实现求解边值问题的谱方法至关重要。", "problem": "考虑在区间 $[-1,1]$ 上的伪谱配置法，使用 $N+1$ 个 Chebyshev–Gauss–Lobatto (CGL) 节点 $x_0=1, \\dots, x_N=-1$。令 $D$ 为相应的 $(N+1) \\times (N+1)$ 一阶谱微分矩阵，并定义二阶微分矩阵为 $D^{(2)} = D^2$。在求解形如 $-u''=f$ 的边值问题时，我们需要一个离散算子来表示作用于**内部节点** $(x_1, \\dots, x_{N-1})$ 的二阶导数。\n\n令 $D_{int}$ 表示通过提取 $D$ 的行和列 $1, \\dots, N-1$ 形成的 $(N-1) \\times (N-1)$ 内部子矩阵。\n令 $D^{(2)}_{int}$ 表示通过提取 $D^{(2)}$ 的行和列 $1, \\dots, N-1$ 形成的 $(N-1) \\times (N-1)$ 内部子矩阵。\n\n以下哪项是构建作用于内部未知数向量 $\\mathbf{u}_{int}=(u_1, \\dots, u_{N-1})^T$ 的二阶导数算子的**正确**方法，以便在施加狄利克雷边界条件后求解方程？\n\nA) $(D_{int})^2$ (对内部矩阵求平方)\n\nB) $D^{(2)}_{int}$ (取二阶矩阵的内部子矩阵)\n\nC) 选项 A 和 B 在数学上是等价的。\n\nD) 必须使用基于内部节点的全新拉格朗日插值来重新计算微分矩阵。", "solution": "此问题探讨了在施加边界条件时如何正确地为内部节点构建谱二阶导数算子。正确的答案是 B。\n\n### 原理分析\n伪谱方法的核心在于使用一个**全局**多项式来逼近解。这意味着，即使是内部点 $x_i$ 的导数，也依赖于**所有**节点上的函数值，包括边界点 $x_0$ 和 $x_N$。\n\n1.  **一阶导数：** 内部节点 $x_i$ ($i=1,\\dots,N-1$) 的一阶导数 $(D\\mathbf{u})_i = \\sum_{j=0}^{N} D_{ij} u_j$。这个计算使用了完整的解向量 $\\mathbf{u}=(u_0, \\dots, u_N)^T$。它不能仅通过内部值 $\\mathbf{u}_{int}=(u_1, \\dots, u_{N-1})^T$ 来计算。\n\n2.  **二阶导数：** 二阶导数是再应用一次 $D$ 算子：$\\mathbf{u}'' = D(D\\mathbf{u})$。由于第一步 $(D\\mathbf{u})$ 的结果在每个节点上都依赖于所有原始函数值，第二步 $D(D\\mathbf{u})$ 的结果也将同样具有全局依赖性。因此，计算内部节点二阶导数的正确方法是：\n    a) 计算完整的二阶微分矩阵 $D^{(2)} = D^2$。\n    b) 用它作用于完整的解向量 $\\mathbf{u}$，得到所有节点上的二阶导数值 $\\mathbf{u}'' = D^{(2)}\\mathbf{u}$。\n    c) 提取与内部节点对应的行，即 $(D^{(2)}\\mathbf{u})_{int}$。\n\n在求解边值问题时，我们通常将系统写成 $A_{int}\\mathbf{u}_{int} = \\mathbf{f}_{eff}$ 的形式，其中 $A_{int}$ 是作用于内部未知数的算子。这个算子正是 $D^{(2)}$ 的内部-内部子矩阵，即 $D^{(2)}_{int}$。\n\n### 选项分析\n- **选项 A: $(D_{int})^2$** 是不正确的。$D_{int}$ 是一个只考虑“内部到内部”相互作用的矩阵。对其求平方 $(D_{int})^2$ 意味着在计算一阶和二阶导数时都完全忽略了边界点的影响。这违反了谱方法的全局性原则，会导致不准确的结果。一般来说，$(D^2)_{int} \\neq (D_{int})^2$。\n\n- **选项 B: $D^{(2)}_{int}$** 是正确的。这是从完整的二阶导数算子 $D^2$ 中提取的内部-内部块。它正确地代表了内部未知数如何相互影响，是建立内部问题线性系统的正确算子。\n\n- **选项 C: ** 因为 A 和 B 不相等，所以 C 是错误的。\n\n- **选项 D: ** 虽然可以为内部节点构造一个独立的插值问题，但这将是一个与原始问题不同的 $(N-3)$ 次多项式插值，会丢失信息并导致精度下降。正确的方法是坚持使用单一的、贯穿所有节点的 $N$ 次多项式。\n\n因此，正确的操作顺序是“先求平方，再取子矩阵”，而不是“先取子矩阵，再求平方”。", "answer": "$$\\boxed{B}$$", "id": "3437294"}, {"introduction": "这最后一个练习是总结性的，它将理论与实践概念融合成一个完整的数值求解器。您将实现一个切比雪夫伪谱方法来求解泊松方程——一个经典且普遍存在的边值问题 [@problem_id:3417568]。这项任务要求您构建微分矩阵，正确地形成离散二阶导数算子，施加边界条件，并评估谱方法标志性的高阶精度。", "problem": "考虑一个由泊松方程 $-u''(x) = f(x)$ 在闭区间 $[-1,1]$ 上定义的边值问题，其狄利克雷边界条件为 $u(-1) = g_{-}$ 和 $u(1) = g_{+}$。任务是实现一个使用微分矩阵的伪谱配置法，以在一组配置点上近似求解 $u(x)$，然后评估该方法对于几个光滑右端项的精度。\n\n您必须使用以下基本数值分析基础：\n- 基于 Chebyshev-Lobatto (CL) 节点的谱配置法。CL 节点定义为 $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j = 0,1,\\dots,N$。\n- 拉格朗日基中插值多项式的谱导数。如果 $p(x)$ 是通过节点 $\\{x_j\\}$ 上的样本 $u(x_j)$ 的唯一多项式插值，那么其在节点上的导数可以表示为矩阵-向量乘积，$p'(x_i) = \\sum_{j=0}^{N} D_{ij} u(x_j)$，其中 $D$ 是根据所选节点上的拉格朗日基构建的一阶微分矩阵。节点上的二阶导数则由 $D^{(2)} = D^2$ 表示，且 $p''(x_i) = \\sum_{j=0}^{N} D^{(2)}_{ij} u(x_j)$。\n\n您的程序必须：\n1. 构建 Chebyshev-Lobatto 节点 $\\{x_j\\}_{j=0}^{N}$。\n2. 基于节点上的拉格朗日插值多项式，推导并实现这些节点的谱一阶微分矩阵 $D$（不要使用任何外部预计算的矩阵）。然后通过 $D^{(2)} = D^2$ 形成二阶微分矩阵。\n3. 使用伪谱近似在节点处离散化泊松方程：在所有内部节点上强制执行 $-D^{(2)} u = f$。通过替换线性系统的第一行和最后一行来施加狄利克雷边界条件，以精确强制执行 $u(x_0) = g_{-}$ 和 $u(x_N) = g_{+}$。\n4. 求解得到的线性系统，以获得 $u$ 的节点值。\n5. 对于每个测试用例，计算数值解与一个构造的光滑精确解 $u_{\\text{exact}}(x)$ 在 CL 节点上的最大绝对误差：$\\max_{j} |u_{\\text{num}}(x_j) - u_{\\text{exact}}(x_j)|$。\n\n角度单位说明：当使用三角函数时，角度必须以弧度为单位。\n\n测试套件说明：\n- 测试用例 1 (理想情况)：$N = 16$，$u_{\\text{exact}}(x) = \\sin(3 x)$，$f(x) = -u_{\\text{exact}}''(x)$，以及狄利克雷边界数据 $g_{-} = u_{\\text{exact}}(-1)$，$g_{+} = u_{\\text{exact}}(1)$。\n- 测试用例 2 (更高分辨率的光滑指数函数)：$N = 64$，$u_{\\text{exact}}(x) = e^{x}$，$f(x) = -u_{\\text{exact}}''(x)$，$g_{-} = u_{\\text{exact}}(-1)$，$g_{+} = u_{\\text{exact}}(1)$。\n- 测试用例 3 (多项式边界情况)：$N = 8$，$u_{\\text{exact}}(x) = x^{5} - x$，$f(x) = -u_{\\text{exact}}''(x)$，$g_{-} = u_{\\text{exact}}(-1)$，$g_{+} = u_{\\text{exact}}(1)$。\n- 测试用例 4 (更高频率的光滑三角函数)：$N = 80$，$u_{\\text{exact}}(x) = \\cos(10 x)$，$f(x) = -u_{\\text{exact}}''(x)$，$g_{-} = u_{\\text{exact}}(-1)$，$g_{+} = u_{\\text{exact}}(1)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，其中包含按上述顺序列出的每个测试用例的最大绝对误差。例如，输出格式必须严格为 $[e_1,e_2,e_3,e_4]$ 的形式，其中每个 $e_k$ 是一个浮点数。", "solution": "该问题要求使用伪谱配置法对带狄利克雷边界条件的一维泊松方程进行数值求解。此方法利用 Chebyshev-Lobatto 配置点和相关的谱微分矩阵。该方法的有效性和正确性通过将其应用于一系列具有已知光滑解的测试用例（即构造解法）来评估。\n\n**1. 伪谱配置与离散化**\n伪谱方法的核心思想是用一个单一的全局多项式 $p(x)$ 来近似连续解 $u(x)$。该多项式在 $N+1$ 个预设的配置点 $\\{x_j\\}_{j=0}^N$ 上精确满足微分方程。本问题使用 Chebyshev-Lobatto 节点：\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N}\\right), \\quad j = 0, 1, \\dots, N\n$$\n解 $u(x)$ 由其在这些节点上的值向量 $\\mathbf{u} = [u(x_0), u(x_1), \\dots, u(x_N)]^T$ 表示。\n\n**2. 谱微分**\n一阶和二阶导数通过谱微分矩阵 $D$ 和 $D^{(2)}=D^2$ 来近似。$\\mathbf{u}' \\approx D\\mathbf{u}$，$\\mathbf{u}'' \\approx D^2\\mathbf{u}$。\n\n**3. 线性系统与边界条件**\n我们在内部节点 $x_i$ ($i = 1, \\dots, N-1$) 上强制执行泊松方程 $-u''(x) = f(x)$，得到：\n$$\n-\\sum_{j=0}^{N} (D^{(2)})_{ij} u_j = f(x_i), \\quad \\text{for } i = 1, \\dots, N-1\n$$\n这构成了线性系统 $A\\mathbf{u}=\\mathbf{b}$ 的中间 $N-1$ 行，其中 $A=-D^{(2)}$。\n狄利克雷边界条件 $u(1) = g_+$ 和 $u(-1) = g_-$ 直接固定了解向量的第一个和最后一个元素（注意节点排序 $x_0=1, x_N=-1$）。我们通过修改 $A$ 和 $\\mathbf{b}$ 的第一行和最后一行来施加这些条件：\n- 将第一行替换为 $u_0 = g_+$。\n- 将最后一行替换为 $u_N = g_-$。\n修改后的线性系统 $A_{mod} \\mathbf{u} = \\mathbf{b}_{mod}$ 是非奇异的，可以通过标准线性求解器求解。\n\n**4. 求解代码实现**\n以下 Python 代码实现了上述过程，并对指定的测试用例进行评估。\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef chebyshev_lobatto_nodes(N):\n    \"\"\"\n    Computes the N+1 Chebyshev-Lobatto nodes on the interval [-1, 1].\n    The nodes are ordered from 1 down to -1.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0])\n    j = np.arange(N + 1)\n    x = np.cos(np.pi * j / N)\n    return x\n\ndef chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the first-order Chebyshev spectral differentiation matrix \n    on the Chebyshev-Lobatto nodes.\n    \n    Returns:\n        D (np.ndarray): The (N+1)x(N+1) differentiation matrix.\n        x (np.ndarray): The (N+1) Chebyshev-Lobatto nodes.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.]]), np.array([0.])\n    \n    x = chebyshev_lobatto_nodes(N)\n    D = np.zeros((N + 1, N + 1))\n    \n    # Coefficients c_i\n    c = np.ones(N + 1)\n    c[0] = 2.0\n    c[-1] = 2.0\n    \n    # vectorized computation of off-diagonal elements\n    X = np.tile(x, (N + 1, 1))\n    dX = X - X.T\n    # Add identity to avoid division by zero on diagonal, which is handled later\n    np.fill_diagonal(dX, 1.0)\n\n    # c_i/c_j * (-1)^{i+j}\n    C = np.tile(c, (N + 1, 1))\n    C_ratio = C.T / C\n    \n    I_plus_J = np.add.outer(np.arange(N+1), np.arange(N+1))\n    Sign_matrix = (-1)**I_plus_J\n    \n    D = C_ratio * Sign_matrix / dX\n    np.fill_diagonal(D, 0.0) # Zero out diagonal before computing row sums\n    \n    # Diagonal entries using sum-to-zero property: D_ii = -sum(D_ij for j!=i)\n    row_sums = np.sum(D, axis=1)\n    np.fill_diagonal(D, -row_sums)\n    \n    return D, x\n\ndef solve_poisson_spectral(N, u_exact, f_rhs):\n    \"\"\"\n    Solves the Poisson equation -u'' = f on [-1, 1] using a spectral method.\n    \n    Args:\n        N (int): The degree of the interpolating polynomial. The number of nodes is N+1.\n        u_exact (callable): The exact solution function u(x).\n        f_rhs (callable): The right-hand side function f(x) of the Poisson eq.\n\n    Returns:\n        float: The maximum absolute error between the numerical and exact solutions.\n    \"\"\"\n    # 1. Get differentiation matrix D and nodes x\n    D, x = chebyshev_diff_matrix(N)\n    \n    # 2. Compute second differentiation matrix D2 = D^2\n    D2 = np.dot(D, D)\n    \n    # 3. Assemble the linear system operator A = -D2\n    A = -D2\n    \n    # 4. Assemble the right-hand side vector b\n    b = f_rhs(x)\n    \n    # 5. Define and impose Dirichlet boundary conditions\n    g_plus = u_exact(1.0)  # u(1)\n    g_minus = u_exact(-1.0) # u(-1)\n    \n    # Node ordering is x_0=1, x_N=-1.\n    # Modify first row for u(1) = g_plus\n    A[0, :] = 0.0\n    A[0, 0] = 1.0\n    b[0] = g_plus\n    \n    # Modify last row for u(-1) = g_minus\n    A[-1, :] = 0.0\n    A[-1, -1] = 1.0\n    b[-1] = g_minus\n    \n    # 6. Solve the linear system A * u_num = b\n    u_num = np.linalg.solve(A, b)\n    \n    # 7. Evaluate exact solution at nodes\n    u_exact_vals = u_exact(x)\n    \n    # 8. Compute maximum absolute error\n    max_error = np.max(np.abs(u_num - u_exact_vals))\n    \n    return max_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite specification\n    test_cases = [\n        {\n            \"N\": 16,\n            \"u_exact\": lambda x: np.sin(3 * x),\n            \"f_rhs\": lambda x: 9 * np.sin(3 * x) # f = -u''\n        },\n        {\n            \"N\": 64,\n            \"u_exact\": lambda x: np.exp(x),\n            \"f_rhs\": lambda x: -np.exp(x) # f = -u''\n        },\n        {\n            \"N\": 8,\n            \"u_exact\": lambda x: x**5 - x,\n            \"f_rhs\": lambda x: -20 * x**3 # f = -u''\n        },\n        {\n            \"N\": 80,\n            \"u_exact\": lambda x: np.cos(10 * x),\n            \"f_rhs\": lambda x: 100 * np.cos(10 * x) # f = -u''\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_poisson_spectral(\n            N=case[\"N\"],\n            u_exact=case[\"u_exact\"],\n            f_rhs=case[\"f_rhs\"]\n        )\n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "answer": "$$\n\\boxed{[4.80718715873151e-15, 1.1102230246251565e-16, 3.3306690738754696e-16, 5.806374944111303e-14]}\n$$", "id": "3417568"}]}