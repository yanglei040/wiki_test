{"hands_on_practices": [{"introduction": "傅里叶谱方法的第一步是理解如何将一个函数用其傅里叶系数来表示。本练习旨在通过一个具体的例子，让您动手操作这种转换，并验证一个基本但至关重要的原理——帕塞瓦尔定理 (Parseval's theorem)。这个定理建立了物理空间中函数的能量（$L^2$ 范数平方）与其在谱空间中系数能量之间的直接联系，是谱方法理论的基石。[@problem_id:3396156]", "problem": "考虑在周期性域上使用傅里叶谱方法求解偏微分方程（PDE）时，复傅里叶级数的应用。在区间 $[0,2\\pi)$ 上，一个平方可积函数 $u(x)$ 可以表示为级数 $u(x)=\\sum_{k\\in\\mathbb{Z}}\\hat{u}_{k}\\exp(\\mathrm{i}kx)$，其中 $\\{\\exp(\\mathrm{i}kx)\\}_{k\\in\\mathbb{Z}}$ 是 $L^{2}([0,2\\pi))$ 内积空间中的一个正交基，其内积为 $\\langle f,g\\rangle=\\frac{1}{2\\pi}\\int_{0}^{2\\pi}f(x)\\overline{g(x)}\\,\\mathrm{d}x$，范数为 $\\|f\\|_{L^{2}([0,2\\pi))}^{2}=\\frac{1}{2\\pi}\\int_{0}^{2\\pi}|f(x)|^{2}\\,\\mathrm{d}x$。设在 $[0,2\\pi)$ 上，$u(x)=\\sin x+\\frac{1}{2}\\cos(3x)$。\n\n仅使用 $\\exp(\\mathrm{i}kx)$ 的正交性和 $L^{2}([0,2\\pi))$ 内积的定义，确定此 $u(x)$ 的所有非零复傅里叶系数 $\\hat{u}_{k}$，并通过计算以下量来验证能量平衡：\n$$D=\\frac{1}{2\\pi}\\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x-\\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2}.$$\n请以行向量的形式提供最终答案，其中包含四个非零系数和 $D$，顺序为 $(\\hat{u}_{-3},\\hat{u}_{-1},\\hat{u}_{1},\\hat{u}_{3},D)$。请使用精确值，不要四舍五入。", "solution": "该问题要求确定函数 $u(x) = \\sin(x) + \\frac{1}{2}\\cos(3x)$ 在定义域 $[0, 2\\pi)$ 上的非零复傅里叶系数 $\\hat{u}_{k}$，并验证由量 $D$ 描述的能量平衡。\n\n函数 $u(x)$ 由复傅里叶级数 $u(x) = \\sum_{k \\in \\mathbb{Z}} \\hat{u}_{k} \\exp(\\mathrm{i}kx)$ 表示。基函数 $\\{\\exp(\\mathrm{i}kx)\\}_{k \\in \\mathbb{Z}}$ 对于给定的内积 $\\langle f,g\\rangle = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} f(x)\\overline{g(x)}\\,\\mathrm{d}x$ 是标准正交的。标准正交性意味着 $\\langle \\exp(\\mathrm{i}kx), \\exp(\\mathrm{i}mx) \\rangle = \\delta_{km}$，其中 $\\delta_{km}$ 是克罗内克δ函数。\n\n仅使用正交性来确定系数 $\\hat{u}_{k}$ 的指示意味着我们可以使用投影公式 $\\hat{u}_k = \\langle u(x), \\exp(\\mathrm{i}kx) \\rangle$，或者更直接地，我们可以将 $u(x)$ 表示为复指数基的线性组合，并依赖于在正交基中表示的唯一性，通过观察来确定系数。我们将使用后者，这种方法更有效。\n\n首先，我们使用欧拉公式将三角函数 $\\sin(x)$ 和 $\\cos(3x)$ 表示为复指数形式：\n$$ \\sin(\\theta) = \\frac{\\exp(\\mathrm{i}\\theta) - \\exp(-\\mathrm{i}\\theta)}{2\\mathrm{i}} $$\n$$ \\cos(\\theta) = \\frac{\\exp(\\mathrm{i}\\theta) + \\exp(-\\mathrm{i}\\theta)}{2} $$\n\n将这些公式应用于给定的函数 $u(x)$：\n$$ u(x) = \\left( \\frac{\\exp(\\mathrm{i}x) - \\exp(-\\mathrm{i}x)}{2\\mathrm{i}} \\right) + \\frac{1}{2} \\left( \\frac{\\exp(\\mathrm{i}3x) + \\exp(-\\mathrm{i}3x)}{2} \\right) $$\n化简各项，并使用恒等式 $\\frac{1}{\\mathrm{i}} = -\\mathrm{i}$：\n$$ u(x) = \\frac{1}{2\\mathrm{i}}\\exp(\\mathrm{i}x) - \\frac{1}{2\\mathrm{i}}\\exp(-\\mathrm{i}x) + \\frac{1}{4}\\exp(\\mathrm{i}3x) + \\frac{1}{4}\\exp(-\\mathrm{i}3x) $$\n$$ u(x) = -\\frac{\\mathrm{i}}{2}\\exp(\\mathrm{i}x) + \\frac{\\mathrm{i}}{2}\\exp(-\\mathrm{i}x) + \\frac{1}{4}\\exp(\\mathrm{i}3x) + \\frac{1}{4}\\exp(-\\mathrm{i}3x) $$\n为了将其与级数形式 $u(x) = \\sum_{k\\in\\mathbb{Z}}\\hat{u}_{k}\\exp(\\mathrm{i}kx)$ 相匹配，我们按索引 $k$ 对各项进行排序：\n$$ u(x) = \\frac{1}{4}\\exp(\\mathrm{i}(-3)x) + \\frac{\\mathrm{i}}{2}\\exp(\\mathrm{i}(-1)x) - \\frac{\\mathrm{i}}{2}\\exp(\\mathrm{i}(1)x) + \\frac{1}{4}\\exp(\\mathrm{i}(3)x) $$\n通过将此表达式与一般傅里叶级数进行比较，我们确定非零系数 $\\hat{u}_k$ 如下：\n- 对于 $k=-3$，系数为 $\\hat{u}_{-3} = \\frac{1}{4}$。\n- 对于 $k=-1$，系数为 $\\hat{u}_{-1} = \\frac{\\mathrm{i}}{2}$。\n- 对于 $k=1$，系数为 $\\hat{u}_{1} = -\\frac{\\mathrm{i}}{2}$。\n- 对于 $k=3$，系数为 $\\hat{u}_{3} = \\frac{1}{4}$。\n所有其他对于 $k \\notin \\{-3, -1, 1, 3\\}$ 的系数 $\\hat{u}_k$ 均为零。\n\n接下来，我们计算量 $D = \\frac{1}{2\\pi}\\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x - \\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2}$。这个表达式比较了函数在物理空间中的范数与其系数在频率空间中的范数。对于这个标准正交系，帕塞瓦尔定理指出这两个量是相等的，即 $\\|u\\|_{L^{2}([0,2\\pi))}^{2} = \\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2}$。因此，我们期望 $D=0$。我们必须通过显式计算来验证这一点。\n\n首先，我们计算积分项：\n$$ \\frac{1}{2\\pi}\\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x = \\frac{1}{2\\pi}\\int_{0}^{2\\pi}\\left(\\sin(x) + \\frac{1}{2}\\cos(3x)\\right)^{2}\\,\\mathrm{d}x $$\n展开平方项：\n$$ \\left(\\sin(x) + \\frac{1}{2}\\cos(3x)\\right)^{2} = \\sin^{2}(x) + \\sin(x)\\cos(3x) + \\frac{1}{4}\\cos^{2}(3x) $$\n我们在 $[0, 2\\pi]$ 上逐项积分：\n使用恒等式 $\\int_{0}^{2\\pi}\\sin^{2}(nx)\\,\\mathrm{d}x = \\pi$ 和 $\\int_{0}^{2\\pi}\\cos^{2}(nx)\\,\\mathrm{d}x = \\pi$（对于任意非零整数 $n$），以及正交关系 $\\int_{0}^{2\\pi}\\sin(mx)\\cos(nx)\\,\\mathrm{d}x = 0$（对于整数 $m, n$）：\n$$ \\int_{0}^{2\\pi} \\sin^{2}(x)\\,\\mathrm{d}x = \\pi $$\n$$ \\int_{0}^{2\\pi} \\sin(x)\\cos(3x)\\,\\mathrm{d}x = 0 $$\n$$ \\int_{0}^{2\\pi} \\frac{1}{4}\\cos^{2}(3x)\\,\\mathrm{d}x = \\frac{1}{4}\\int_{0}^{2\\pi} \\cos^{2}(3x)\\,\\mathrm{d}x = \\frac{\\pi}{4} $$\n将这些结果相加，我们得到：\n$$ \\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x = \\pi + 0 + \\frac{\\pi}{4} = \\frac{5\\pi}{4} $$\n因此，$D$ 表达式中的第一项是：\n$$ \\frac{1}{2\\pi}\\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x = \\frac{1}{2\\pi} \\left( \\frac{5\\pi}{4} \\right) = \\frac{5}{8} $$\n\n第二，我们计算系数模的平方和：\n$$ \\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2} = |\\hat{u}_{-3}|^{2} + |\\hat{u}_{-1}|^{2} + |\\hat{u}_{1}|^{2} + |\\hat{u}_{3}|^{2} $$\n这些模为：\n$$ |\\hat{u}_{-3}| = \\left|\\frac{1}{4}\\right| = \\frac{1}{4} \\implies |\\hat{u}_{-3}|^{2} = \\frac{1}{16} $$\n$$ |\\hat{u}_{-1}| = \\left|\\frac{\\mathrm{i}}{2}\\right| = \\frac{1}{2} \\implies |\\hat{u}_{-1}|^{2} = \\frac{1}{4} $$\n$$ |\\hat{u}_{1}| = \\left|-\\frac{\\mathrm{i}}{2}\\right| = \\frac{1}{2} \\implies |\\hat{u}_{1}|^{2} = \\frac{1}{4} $$\n$$ |\\hat{u}_{3}| = \\left|\\frac{1}{4}\\right| = \\frac{1}{4} \\implies |\\hat{u}_{3}|^{2} = \\frac{1}{16} $$\n将这些值相加：\n$$ \\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2} = \\frac{1}{16} + \\frac{1}{4} + \\frac{1}{4} + \\frac{1}{16} = \\frac{2}{16} + \\frac{2}{4} = \\frac{1}{8} + \\frac{1}{2} = \\frac{1+4}{8} = \\frac{5}{8} $$\n\n最后，我们计算 $D$：\n$$ D = \\frac{1}{2\\pi}\\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x - \\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2} = \\frac{5}{8} - \\frac{5}{8} = 0 $$\n这验证了帕塞瓦尔定理所述的能量平衡。\n\n所要求的最终答案是行向量 $(\\hat{u}_{-3}, \\hat{u}_{-1}, \\hat{u}_{1}, \\hat{u}_{3}, D)$。\n$$ \\left(\\frac{1}{4}, \\frac{\\mathrm{i}}{2}, -\\frac{\\mathrm{i}}{2}, \\frac{1}{4}, 0\\right) $$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{4}  \\frac{\\mathrm{i}}{2}  -\\frac{\\mathrm{i}}{2}  \\frac{1}{4}  0\n\\end{pmatrix}\n}\n$$", "id": "3396156"}, {"introduction": "傅里叶谱方法的核心优势之一是其计算空间导数的高效性和高精度。该方法将物理空间中的微分运算，转化为谱空间中与波数 $ik$ 的简单代数乘法。本练习将指导您通过编程实践，利用快速傅里叶变换（FFT）实现谱微分，并分析其误差，从而直观地感受谱方法的强大威力。[@problem_id:3396179]", "problem": "给定一个光滑的 $2\\pi$ 周期函数 $f$，在区间 $[0,2\\pi)$ 上的 $N$ 个等距网格点上进行采样。设网格为 $x_j = \\frac{2\\pi j}{N}$，其中 $j = 0,1,\\dots,N-1$，并将采样值表示为 $f_j = f(x_j)$。目标是通过快速傅里叶变换（FFT）计算导数 $f'(x)$ 在网格点上的谱近似，然后使用 $L^2$ 误差和点态（无穷）误差来量化其精度。\n\n从以下基本原理出发：\n- 对于一个光滑的 $2\\pi$ 周期函数 $f$，其复傅里叶级数为 $f(x) = \\sum_{k\\in\\mathbb{Z}} \\hat{f}_k e^{ikx}$，其中 $\\hat{f}_k$ 是傅里叶系数。物理空间中的微分对应于傅里叶空间中乘以 $ik$：$f'(x) = \\sum_{k\\in\\mathbb{Z}} (ik)\\hat{f}_k e^{ikx}$。\n- 离散傅里叶变换（DFT）将 $N$ 个等距采样点 $\\{f_j\\}_{j=0}^{N-1}$ 映射到一组离散傅里叶模态，这些模态表示与采样网格和周期性一致的整数波数。逆离散傅里叶变换（IDFT）从这些模态重构函数在网格点上的值。\n- 在等距周期网格上的离散梯形法则对于光滑周期函数能以谱精度近似连续 $L^2$ 范数。\n\n基于这些原理，推导出在网格点上计算谱导数的算法，步骤如下：\n1. 对 $\\{f_j\\}$ 应用 DFT，以获得与整数波数 $k$ 相关的离散傅里叶模态。\n2. 将每个模态乘以 $ik$，以表示傅里叶空间中的微分。\n3. 应用逆 DFT（IDFT）返回物理空间，得到 $\\{f'(x_j)\\}$ 的谱近似。\n\n使用快速傅里叶变换（FFT）及其逆变换实现此算法，以确保计算效率。显式构造与 FFT 在区间 $[0,2\\pi)$ 上引起的 DFT 排序一致的整数波数向量 $k$，并确保您的实现能正确处理 $N$ 为偶数和奇数的情况。角度使用弧度。\n\n对每个测试用例，计算：\n- $L^2$ 误差，定义为 $\\|e\\|_{L^2} \\approx \\left(\\sum_{j=0}^{N-1} |e_j|^2 \\,\\Delta x\\right)^{1/2}$，其中 $e_j = f'_{\\text{spec}}(x_j) - f'_{\\text{exact}}(x_j)$ 是在 $x_j$ 处的点态误差，$\\Delta x = \\frac{2\\pi}{N}$。\n- 点态（无穷）误差，定义为 $\\|e\\|_{\\infty} = \\max_{0\\le j\\le N-1} |e_j|$。\n\n您的程序必须为下面指定的每个测试用例计算这两个误差度量。在生成最终输出之前，将每个浮点误差四舍五入到 $8$ 位小数。\n\n测试套件（请精确使用这些函数和分辨率）：\n- 用例 $1$：$f_1(x) = \\sin(3x) + \\cos(5x)$，其中 $N=16$。\n- 用例 $2$：$f_1(x) = \\sin(3x) + \\cos(5x)$，其中 $N=64$。\n- 用例 $3$：$f_2(x) = \\exp(\\sin x)$，其中 $N=32$。\n- 用例 $4$：$f_2(x) = \\exp(\\sin x)$，其中 $N=128$。\n- 用例 $5$：$f_3(x) = \\sin(20x)$，其中 $N=32$。\n- 用例 $6$：$f_1(x) = \\sin(3x) + \\cos(5x)$，其中 $N=8$。\n\n对每个用例，使用其精确导数：\n- $f_1'(x) = 3\\cos(3x) - 5\\sin(5x)$。\n- $f_2'(x) = \\cos(x)\\exp(\\sin x)$。\n- $f_3'(x) = 20\\cos(20x)$。\n\n所有三角函数参数均以弧度为单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个元素对应一个测试用例，其本身是一个包含两个元素的列表，依次为 $L^2$ 误差和无穷误差，两者均四舍五入到 $8$ 位小数。例如，输出应如下所示：“[[e21,einf1],[e22,einf2],...]”，不含空格。确保结果的出现顺序与上面列出的用例 $1$ 到 $6$ 的顺序完全一致。", "solution": "该问题要求使用傅里叶谱方法计算一个光滑 $2\\pi$ 周期函数的导数，并量化该方法的精度。解决方案源于傅里叶分析的基本原理。\n\n谱方法的核心原理是，物理空间中的运算（如微分）对应于频率（或傅里叶）空间中更简单的代数运算。对于一个具有连续傅里叶级数表示的光滑 $2\\pi$ 周期函数 $f(x)$：\n$$\nf(x) = \\sum_{k \\in \\mathbb{Z}} \\hat{f}_k e^{ikx}\n$$\n其中 $\\hat{f}_k$ 是连续傅里叶系数，$k$ 是整数波数。对 $x$ 求导可得：\n$$\nf'(x) = \\frac{d}{dx} \\sum_{k \\in \\mathbb{Z}} \\hat{f}_k e^{ikx} = \\sum_{k \\in \\mathbb{Z}} (ik) \\hat{f}_k e^{ikx}\n$$\n这表明物理空间中的微分等价于将每个傅里叶系数 $\\hat{f}_k$ 乘以因子 $ik$。\n\n在计算环境中，我们处理的是函数的离散表示。函数 $f(x)$ 在区间 $[0, 2\\pi)$ 内的 $N$ 个点的均匀网格上进行采样：\n$$\nx_j = \\frac{2\\pi j}{N}, \\quad j = 0, 1, \\dots, N-1\n$$\n此网格上的函数值为 $f_j = f(x_j)$。傅里叶级数的离散模拟是离散傅里叶变换（DFT）。序列 $\\{f_j\\}_{j=0}^{N-1}$ 的 DFT 是一组 $N$ 个复系数，我们将其记为 $\\hat{f}^N$，通过快速傅里叶变换（FFT）算法计算得出：\n$$\n\\hat{f}^N_k = \\sum_{j=0}^{N-1} f_j e^{-i \\frac{2\\pi kj}{N}}, \\quad k = 0, 1, \\dots, N-1\n$$\n原始函数值可以通过使用逆 DFT（IDFT）从这些系数中完美重构，通常通过逆 FFT（IFFT）计算：\n$$\nf_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{f}^N_k e^{i \\frac{2\\pi kj}{N}} = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{f}^N_k e^{ik_{\\text{phys}}(k) x_j}\n$$\nDFT 输出的索引 $k$ 必须映射到其对应的物理整数波数，记为 $k_{\\text{phys}}(k)$。对于长度为 $N$ 的序列，DFT 系数对应的波数会混叠到网格可分辨的范围内。标准的 FFT 库（如 NumPy）按以下方式对相应的整数波数进行排序：\n- 对于 $k = 0, \\dots, \\lfloor (N-1)/2 \\rfloor$：波数为 $0, 1, \\dots, \\lfloor (N-1)/2 \\rfloor$。\n- 对于 $k = \\lfloor (N-1)/2 \\rfloor + 1, \\dots, N-1$：波数为 $\\lfloor -N/2 \\rfloor, \\dots, -1$。\n标准库提供了一种可靠的方法来生成这个波数向量，我们称之为 $k_{\\text{phys}}$。\n\n为了计算导数，我们将微分-乘法原理应用于离散系数：\n$$\n\\widehat{(f')}^N_k = (i k_{\\text{phys}}(k)) \\hat{f}^N_k\n$$\n当点数 $N$ 为偶数时，会出现一个关键的微妙之处。网格可以表示对应于奈奎斯特波数 $k = N/2$ 的频率分量。在网格点 $x_j$ 上，函数 $\\cos((N/2)x_j) = \\cos(\\pi j) = (-1)^j$。其解析导数为 $-(N/2)\\sin((N/2)x)$，在所有网格点上的值为 $-(N/2)\\sin(\\pi j) = 0$。为确保实值函数的数值导数也是实值，并与函数在网格上的行为保持一致，奈奎斯特模态的导数通常被设为零。这通过将波数向量 $k_{\\text{phys}}$ 中对应于奈奎斯特频率的分量设为 $0$ 来实现。对于奇数点数 $N$，由于没有单一的奈奎斯特频率，因此不需要此类特殊处理。\n\n计算谱导数 $\\{f'_{\\text{spec}}(x_j)\\}$ 的算法如下：\n1.  在网格 $\\{x_j\\}$ 上计算离散函数样本 $\\{f_j\\}$。\n2.  对 $\\{f_j\\}$ 应用 FFT 以获得离散傅里叶系数 $\\{\\hat{f}^N_k\\}$。\n3.  构造物理整数波数向量 $\\{k_{\\text{phys}}\\}$。对于偶数 $N$，将对应于奈奎斯特频率的元素设为 $0$。\n4.  将傅里叶系数乘以 $ik_{\\text{phys}}$ 以获得导数的系数，即 $\\{\\widehat{(f')}^N_k\\} = \\{i k_{\\text{phys}}(k) \\hat{f}^N_k\\}$。\n5.  对 $\\{\\widehat{(f')}^N_k\\}$ 应用 IFFT 以在物理空间中获得谱导数值 $\\{f'_{\\text{spec}}(x_j)\\}$。结果应在机器精度内为实数；取实部可舍弃由于浮点误差产生的微小虚部。\n\n最后，为评估精度，我们计算误差向量 $e_j = f'_{\\text{spec}}(x_j) - f'_{\\text{exact}}(x_j)$。精度使用两种范数进行量化：\n- 离散 $L^2$ 误差，它近似于连续 $L^2$ 范数：\n$$\n\\|e\\|_{L^2} \\approx \\left( \\sum_{j=0}^{N-1} |e_j|^2 \\Delta x \\right)^{1/2}\n$$\n其中网格间距为 $\\Delta x = 2\\pi/N$。\n- 点态无穷误差，它度量网格上的最大绝对误差：\n$$\n\\|e\\|_{\\infty} = \\max_{0 \\le j \\le N-1} |e_j|\n$$\n实现将把此完整过程应用于所提供的每个测试用例。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes spectral derivatives and errors for a suite of test cases.\n    \"\"\"\n\n    # Define the functions and their exact derivatives for the test cases.\n    def f1(x):\n        return np.sin(3 * x) + np.cos(5 * x)\n\n    def f1_prime(x):\n        return 3 * np.cos(3 * x) - 5 * np.sin(5 * x)\n\n    def f2(x):\n        return np.exp(np.sin(x))\n\n    def f2_prime(x):\n        return np.cos(x) * np.exp(np.sin(x))\n\n    def f3(x):\n        return np.sin(20 * x)\n\n    def f3_prime(x):\n        return 20 * np.cos(20 * x)\n\n    # Define the test cases as specified in the problem statement.\n    test_cases = [\n        {'N': 16, 'func': f1, 'deriv': f1_prime},\n        {'N': 64, 'func': f1, 'deriv': f1_prime},\n        {'N': 32, 'func': f2, 'deriv': f2_prime},\n        {'N': 128, 'func': f2, 'deriv': f2_prime},\n        {'N': 32, 'func': f3, 'deriv': f3_prime},\n        {'N': 8, 'func': f1, 'deriv': f1_prime},\n    ]\n\n    results_str = []\n    \n    for case in test_cases:\n        N = case['N']\n        f = case['func']\n        f_prime_exact_func = case['deriv']\n\n        # 1. Create the grid an sample the function.\n        # The domain is [0, 2*pi), so the grid is x_j = 2*pi*j / N.\n        x = np.arange(N) * (2 * np.pi / N)\n        f_values = f(x)\n        \n        # 2. Compute the FFT of the signal.\n        f_hat = np.fft.fft(f_values)\n\n        # 3. Construct the wavenumber vector for differentiation.\n        # numpy.fft.fftfreq(N) returns the unique sampling frequencies.\n        # We multiply by N to get the integer wavenumbers.\n        k = np.fft.fftfreq(N) * N\n        \n        # 4. Handle the Nyquist frequency for even N.\n        # For a real signal, the derivative of the Nyquist mode must be zero\n        # to ensure the derivative is real-valued.\n        if N % 2 == 0:\n            k[N // 2] = 0\n\n        # 5. Differentiate in Fourier space.\n        f_prime_hat = 1j * k * f_hat\n        \n        # 6. Apply inverse FFT to get the derivative in physical space.\n        f_prime_spec = np.fft.ifft(f_prime_hat)\n        \n        # The result must be real for a real input function. Take the real part\n        # to discard any small imaginary noise from floating-point inaccuracies.\n        f_prime_spec = np.real(f_prime_spec)\n        \n        # 7. Compute the exact derivative at the grid points.\n        f_prime_exact = f_prime_exact_func(x)\n        \n        # 8. Calculate the error vector.\n        error_vec = f_prime_spec - f_prime_exact\n        \n        # 9. Compute the L2 and infinity error norms.\n        delta_x = 2 * np.pi / N\n        l2_error = np.sqrt(np.sum(error_vec**2) * delta_x)\n        inf_error = np.max(np.abs(error_vec))\n\n        # 10. Format and store the results.\n        l2_error_str = f\"{l2_error:.8f}\"\n        inf_error_str = f\"{inf_error:.8f}\"\n        results_str.append(f\"[{l2_error_str},{inf_error_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3396179"}, {"introduction": "尽管线性问题在傅里叶空间中处理起来很简单，但非线性项却带来了独特的挑战，即混淆误差（aliasing error）。本练习以无粘性伯格斯方程为例，展示了在伪谱方法中，混淆误差如何导致非物理的能量增长，从而破坏了守恒律。通过对比有无去混淆（dealiasing）技术的结果，您将理解为何以及如何应用去混淆来确保数值解的物理真实性。[@problem_id:3396162]", "problem": "考虑区间 $[0,2\\pi]$ 上无粘伯格斯方程的周期性初值问题，\n$$\nu_t(x,t) + u(x,t)\\,u_x(x,t) = 0, \\quad x \\in [0,2\\pi], \\quad t \\ge 0,\n$$\n其边界条件为周期性，初始条件为光滑函数 $u(x,0) = \\sin(x)$。对于激波形成之前的足够光滑的解，其连续 $L^2$ 能量\n$$\nE(t) = \\frac{1}{2}\\int_{0}^{2\\pi} u(x,t)^2 \\, dx\n$$\n是守恒的。\n\n在傅里叶伪谱离散化中，非线性项 $u\\,u_x$ 的计算方法是：变换到物理空间，进行逐点相乘，然后再变换回傅里叶空间。然而，离散卷积被截断为可用模态，这会引入混叠误差，从而破坏离散守恒性。一个常见的补救措施是使用三分之二规则进行去混叠，即在计算二次非线性项时，对于一个包含 $N$ 个点的网格，将波数大小超过 $N/3$ 的所有傅里叶模态置零。\n\n您的任务是编写一个完整、可运行的程序，该程序能够：\n- 使用 $N$ 个等距点离散化空间域 $[0,2\\pi]$，并用其离散傅里叶变换表示 $u$。\n- 使用傅里叶伪谱法计算空间导数，并为非线性项 $u\\,u_x$ 提供两种变体：\n  1. 混叠变体（不去混叠）：在物理空间中通过逐点乘法计算 $u\\,u_x$，然后变换回去，不进行截断。\n  2. 使用三分之二规则的去混叠变体：在形成非线性乘积之前，将场投影到 $|k|\\le N/3$ 的傅里叶模态上，在物理空间中计算乘积，然后将得到的傅里叶变换结果再投影回 $|k|\\le N/3$ 的模态上。\n- 使用显式四阶 Runge–Kutta 方法，以固定的时间步长 $\\Delta t$ 将解推进到指定的最终时间 $T$。\n- 使用梯形法则计算在时间 $t=0$ 和 $t=T$ 时的离散 $L^2$ 能量（该法则对于周期函数的等距采样是精确的），即\n$$\nE_{\\text{disc}}(t) = \\frac{1}{2}\\,\\Delta x \\sum_{j=0}^{N-1} u(x_j,t)^2,\n$$\n其中 $\\Delta x = 2\\pi/N$ 且 $x_j = j\\,\\Delta x$。\n- 对于每个测试用例，返回无量纲单位下的能量漂移 $E_{\\text{disc}}(T) - E_{\\text{disc}}(0)$，其形式为浮点数。\n\n您的推导和实现应基于以下基本事实：\n- 在激波形成之前，无粘伯格斯方程 $u_t + u u_x = 0$ 具有连续能量守恒定律 $dE/dt = 0$。\n- 傅里叶变换将导数运算转变为乘法运算：如果 $\\widehat{u}(k)$ 表示波数 $k$ 处的离散傅里叶系数，那么 $u_x$ 对应于在傅里叶空间中乘以 $\\mathrm{i}k$。\n- 两个场的伪谱乘积对应于傅里叶空间中的离散卷积，该卷积被截断为可分辨的模态，如果非线性相互作用产生了不可分辨的模态，则可能导致混叠。\n- 对于二次非线性项，三分之二去混叠规则确保了两个截断谱的卷积不会混叠到可分辨频带中：在非线性乘积计算过程中，波数 $|k| > N/3$ 的模态被置零。\n\n为确保科学真实性，最终时间应严格小于激波时间。对于 $u(x,0) = \\sin(x)$，激波时间为 $t_s = 1$，因为 $\\min_x u_x(x,0) = -1$。\n\n测试套件：\n使用以下参数集，其中每个测试用例是一个元组 (N, T, dealias)，$N$ 是网格点数，$T$ 是最终时间，dealias 是一个等于 \"none\" 或 \"2/3\" 的字符串，用以指明非线性计算的变体。\n- 测试 1 (正常路径，中等分辨率，存在混叠): (64, 0.5, \"none\")。\n- 测试 2 (正常路径，中等分辨率，应用去混叠): (64, 0.5, \"2/3\")。\n- 测试 3 (边缘情况，粗分辨率，存在混叠): (16, 0.5, \"none\")。\n- 测试 4 (接近激波时间的边界情况，应用去混叠): (64, 0.95, \"2/3\")。\n\n所有计算都是无量纲的。角度以弧度为单位。您的程序应生成单行输出，其中包含测试套件的能量漂移，形式为用方括号括起来的逗号分隔列表，例如，\n$$\n[\\delta E_1,\\delta E_2,\\delta E_3,\\delta E_4],\n$$\n其中每个 $\\delta E_i$ 等于相应测试用例的 $E_{\\text{disc}}(T)-E_{\\text{disc}}(0)$。这些值应以十进制浮点数输出。\n\n程序必须是自包含的，使用快速傅里叶变换 (FFT)，并遵守为执行环境指定的约束。不允许外部输入，除上述无量纲规范外，不涉及任何物理单位。", "solution": "该问题要求在周期域 $x \\in [0, 2\\pi]$ 上求解无粘伯格斯方程 $u_t + u u_x = 0$ 的数值解，初始条件为 $u(x,0) = \\sin(x)$。解将使用傅里叶伪谱法获得，时间积分则通过四阶 Runge-Kutta (RK4) 格式进行。一个关键方面是通过实现非线性项 $u u_x$ 的两种变体来比较混叠误差对离散能量守恒的影响：一种没有混叠控制，另一种采用三分之二去混叠规则。\n\n该方法的核心是偏微分方程 (PDE) 的半离散化。我们在任意时间 $t$ 将解 $u(x,t)$ 表示为其在 $N$ 个等距点网格上的值，$x_j = j \\Delta x$，其中 $\\Delta x = 2\\pi/N$，$j=0, 1, \\dots, N-1$。对于周期函数，这种空间表示可以在傅里叶空间中得到高效处理。设 $\\widehat{u}_k(t)$ 为 $u(x,t)$ 对应于波数 $k$ 的离散傅里叶系数。所有系数的集合 $\\{\\widehat{u}_k(t)\\}$ 构成了系统的状态。因此，该偏微分方程被转换为关于这些系数的常微分方程组 (ODEs)：\n$$\n\\frac{d\\widehat{u}_k}{dt} = -\\mathcal{F}(u \\cdot u_x)_k\n$$\n其中 $\\mathcal{F}$ 表示离散傅里叶变换，下标 $k$ 表示括号内项的第 $k$ 个傅里叶系数。\n\n空间导数 $u_x$ 在傅里叶空间中被精确计算。傅里叶变换的微分性质指出，实空间中的导数 $\\partial/\\partial x$ 对应于傅里叶空间中的乘法 $ik$，其中 $i = \\sqrt{-1}$，$k$ 是整数波数。对于 $[0, 2\\pi]$ 上的 $N$ 点网格，波数由集合 $k \\in \\{0, \\pm 1, \\dots, \\pm(N/2-1), -N/2\\}$ 给出（对于偶数 $N$）。因此，导数的傅里叶系数 $\\widehat{(u_x)}_k$ 计算如下：\n$$\n\\widehat{(u_x)}_k = i k \\widehat{u}_k\n$$\n\n主要挑战在于计算非线性项 $u u_x$。在伪谱（或配置）法中，该乘积在物理空间中逐点计算。过程如下：\n1.  使用快速傅里叶逆变换 (IFFT) 将 $\\widehat{u}_k$ 和 $\\widehat{(u_x)}_k$ 变换到物理空间，以获得网格点上的值 $u(x_j)$ 和 $u_x(x_j)$。\n2.  计算逐点乘积 $p(x_j) = u(x_j) u_x(x_j)$。\n3.  使用快速傅里叶变换 (FFT) 将乘积变换回傅里叶空间，得到 $\\widehat{p}_k = \\mathcal{F}(p)_k$。\n\n这个过程会引入混叠误差。两个谱限于波数 $|k| \\le K_{max}$ 的函数的乘积，会产生一个谱延伸至 $|k| \\le 2K_{max}$ 的结果。离散网格只能表示达到奈奎斯特极限 $|k| \\le N/2$ 的波数。任何超出此限制产生的谱内容都会被“折叠”回可分辨的波数上，从而污染傅里叶系数。这种现象被称为混叠，它违反了连续卷积的性质，并导致不准确性，包括离散能量守恒的破坏。算法的混叠变体直接实现此过程，不进行任何修正。\n\n为减轻混叠，应用了三分之二去混叠规则。对于像 $u u_x$ 这样的二次非线性，此规则确保谱卷积不会引起环绕误差。这是通过在乘法之前截断因子的傅里叶级数来实现的。具体来说，所有波数大小 $|k| > K_{cut} = \\lfloor N/3 \\rfloor$ 的模态都被置零。去混叠过程如下：\n1.  给定系数 $\\widehat{u}_k$，通过将所有 $|k| > N/3$ 的系数置零来创建一个滤波后的集合 $\\widehat{u}_{k, \\text{trunc}}$。\n2.  计算滤波后的导数系数：$\\widehat{(u_x)}_{k, \\text{trunc}} = i k \\widehat{u}_{k, \\text{trunc}}$。\n3.  将 $\\widehat{u}_{k, \\text{trunc}}$ 和 $\\widehat{(u_x)}_{k, \\text{trunc}}$ 都变换到物理空间，以获得 $u_{\\text{trunc}}(x_j)$ 和 $(u_x)_{\\text{trunc}}(x_j)$。\n4.  计算乘积 $p_{\\text{trunc}}(x_j) = u_{\\text{trunc}}(x_j) (u_x)_{\\text{trunc}}(x_j)$。\n5.  将此乘积变换回傅里叶空间，以获得 $\\widehat{p}_{\\text{trunc}, k}$。\n6.  作为最后一步投影，将 $\\widehat{p}_{\\text{trunc}, k}$ 中所有 $|k| > N/3$ 的系数置零。结果即为非线性项 $-\\mathcal{F}(u u_x)_k$ 的去混叠傅里叶表示。\n\n得到的常微分方程组 $\\frac{d}{dt}\\widehat{U} = F(\\widehat{U})$（其中 $\\widehat{U}$ 是所有 $\\widehat{u}_k$ 的向量，$F$ 是右端函数，其计算可以采用去混叠或不去混叠的方式）使用经典的四阶 Runge-Kutta (RK4) 方法进行时间推进。对于一个时间步长 $\\Delta t$，从时间 $t_n$ 的状态 $\\widehat{U}_n$ 计算时间 $t_{n+1} = t_n + \\Delta t$ 的状态如下：\n$$\n\\begin{aligned}\n    k_1 = F(\\widehat{U}_n) \\\\\n    k_2 = F(\\widehat{U}_n + \\frac{\\Delta t}{2} k_1) \\\\\n    k_3 = F(\\widehat{U}_n + \\frac{\\Delta t}{2} k_2) \\\\\n    k_4 = F(\\widehat{U}_n + \\Delta t k_3) \\\\\n    \\widehat{U}_{n+1} = \\widehat{U}_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\n选择一个小的固定时间步长 $\\Delta t=0.001$ 以确保与正在研究的空间误差相比，时间误差可以忽略不计。\n\n最后，计算初始时间 $t=0$ 和最终时间 $t=T$ 时的离散 $L^2$ 能量。如前规定，这是通过在物理网格值上使用梯形法则完成的，该方法对于周期函数是谱精确的：\n$$\nE_{\\text{disc}}(t) = \\frac{1}{2}\\,\\Delta x \\sum_{j=0}^{N-1} u(x_j,t)^2\n$$\n能量漂移 $E_{\\text{disc}}(T) - E_{\\text{disc}}(0)$ 用作量化混叠和去混叠格式性能的度量标准。连续方程是能量守恒的，因此在一个完美的数值格式中，此漂移应为零。我们预计去混叠格式将表现出显著更小的能量漂移。对于初始条件 $u(x,0)=\\sin(x)$，当 $N>2$ 时，离散初始能量恰好为 $E_{\\text{disc}}(0) = \\pi/2$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, T, dealias_mode, dt):\n    \"\"\"\n    Solves the inviscid Burgers' equation using a Fourier pseudo-spectral method.\n\n    Args:\n        N (int): Number of grid points.\n        T (float): Final time.\n        dealias_mode (str): \"none\" for aliased, \"2/3\" for dealiased.\n        dt (float): Time step.\n\n    Returns:\n        float: The energy drift E(T) - E(0).\n    \"\"\"\n    # 1. Setup grid and initial conditions\n    L = 2.0 * np.pi\n    dx = L / N\n    x = np.arange(N) * dx\n    u0 = np.sin(x)\n    u_hat = np.fft.fft(u0)\n\n    # 2. Wavenumbers for spatial differentiation\n    # The factor N scales frequencies from cycles/sample to integer wavenumbers\n    k_vector = np.fft.fftfreq(N) * N\n\n    # 3. Calculate initial energy\n    E0 = 0.5 * dx * np.sum(u0**2)\n\n    # Pre-compute dealiasing mask if needed\n    high_freq_indices = None\n    if dealias_mode == \"2/3\":\n        k_cutoff = int(N / 3)\n        high_freq_indices = np.abs(k_vector) > k_cutoff\n\n    # 4. Define the RHS function for the ODE d(u_hat)/dt = F(u_hat)\n    def rhs(current_u_hat):\n        if dealias_mode == \"2/3\":\n            # Project field onto resolved modes\n            u_hat_trunc = current_u_hat.copy()\n            u_hat_trunc[high_freq_indices] = 0\n            \n            # Differentiate the truncated field\n            u_x_hat_trunc = 1j * k_vector * u_hat_trunc\n            \n            # Transform to physical space\n            u_trunc = np.fft.ifft(u_hat_trunc)\n            u_x_trunc = np.fft.ifft(u_x_hat_trunc)\n            \n            # Pointwise product of truncated fields\n            nonlinear_term = u_trunc * u_x_trunc\n            \n            # Transform product back to Fourier space\n            nonlinear_term_hat = np.fft.fft(nonlinear_term)\n            \n            # Project the result back onto resolved modes\n            nonlinear_term_hat[high_freq_indices] = 0\n            \n            return -nonlinear_term_hat\n        \n        else:  # \"none\" case (aliased)\n            # Differentiate in Fourier space\n            u_x_hat = 1j * k_vector * current_u_hat\n            \n            # Transform to physical space\n            u = np.fft.ifft(current_u_hat)\n            u_x = np.fft.ifft(u_x_hat)\n            \n            # Pointwise product\n            nonlinear_term = u * u_x\n            \n            # Transform product back to Fourier space\n            nonlinear_term_hat = np.fft.fft(nonlinear_term)\n            \n            return -nonlinear_term_hat\n\n    # 5. Time integration loop (RK4)\n    num_steps = int(round(T / dt))\n\n    for _ in range(num_steps):\n        k1 = rhs(u_hat)\n        k2 = rhs(u_hat + 0.5 * dt * k1)\n        k3 = rhs(u_hat + 0.5 * dt * k2)\n        k4 = rhs(u_hat + dt * k3)\n        u_hat += (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n    \n    # 6. Calculate final energy\n    u_final = np.fft.ifft(u_hat)\n    # The physical solution must be real; numerical errors introduce a small imaginary part.\n    E_final = 0.5 * dx * np.sum(np.real(u_final)**2)\n    \n    # 7. Compute and return drift\n    energy_drift = E_final - E0\n    return energy_drift\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, T, dealias_mode)\n        (64, 0.5, \"none\"),\n        (64, 0.5, \"2/3\"),\n        (16, 0.5, \"none\"),\n        (64, 0.95, \"2/3\"),\n    ]\n\n    # Fixed time step for all simulations to ensure stability and\n    # make temporal errors subdominant to spatial ones.\n    dt = 0.001\n\n    results = []\n    for case in test_cases:\n        N, T, dealias_mode = case\n        drift = run_simulation(N, T, dealias_mode, dt)\n        results.append(drift)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3396162"}]}