{"hands_on_practices": [{"introduction": "本练习是求解非线性偏微分方程的基石。我们将处理$p$-拉普拉斯方程，这是一个非线性扩散问题的模型。核心任务是推导并实现牛顿法，这是求解离散化后产生的非线性系统的主要方法。通过从第一性原理（Gâteaux导数）出发计算雅可比矩阵，并通过正则化处理奇点这一实际问题，您将获得从变分形式到具体数值计算全过程的实践经验。[@problem_id:3380993]", "problem": "考虑在有界多边形域 $\\Omega \\subset \\mathbb{R}^{2}$ 上的非线性偏微分方程 (PDE) $-\\nabla \\cdot \\left(|\\nabla u|^{p-2}\\nabla u\\right) = f$，其具有齐次狄利克雷边界条件 $u=0$ on $\\partial \\Omega$。令 $V := H_{0}^{1}(\\Omega)$，并回顾其弱形式：求 $u \\in V$，使得对于所有 $v \\in V$ 均有 $\\int_{\\Omega}|\\nabla u|^{p-2}\\nabla u \\cdot \\nabla v \\, \\mathrm{d}x = \\int_{\\Omega} f v \\, \\mathrm{d}x$。对 $\\Omega$ 上的一个协调三角剖分，使用标准的连续分片线性有限元方法 (FEM)，并用 $\\{\\varphi_{i}\\}$ 表示全局节点基。\n\n任务：\n1) 从弱形式和伽辽金残差 $R(u_{h}) \\in \\mathbb{R}^{N}$（其分量为 $R_{i}(u_{h}) := \\int_{\\Omega}|\\nabla u_{h}|^{p-2}\\nabla u_{h}\\cdot \\nabla \\varphi_{i}\\,\\mathrm{d}x - \\int_{\\Omega} f \\varphi_{i} \\,\\mathrm{d}x$）的定义出发，通过计算残差在增量 $w_{h}$ 方向上的 Gâteaux 导数，推导出牛顿系统 $J(u_{h}^{(k)})\\,\\delta u^{(k)} = -R(u_{h}^{(k)})$。仅使用基本求导法则（链式法则和乘积法则）和 Gâteaux 导数的定义，将雅可比矩阵项 $J_{ij}(u_{h}^{(k)})$ 表示为仅涉及 $\\nabla \\varphi_{i}$、$\\nabla \\varphi_{j}$ 和 $\\nabla u_{h}^{(k)}$ 的单元积分。\n2) 提出一种正则化策略来处理在 $|\\nabla u|=0$ 处的退化问题，并从第一性原理出发，通过确保非线性通量映射在任意测试函数方向上的可微性来证明其合理性。\n3) 在具有顶点 $(0,0)$、$(1,0)$、$(0,1)$ 的单个三角单元 $T$ 上，考虑与这些顶点相关的局部分片线性基函数 $\\{\\phi_{1},\\phi_{2},\\phi_{3}\\}$，并考虑在 $p=3$ 和正则化参数 $\\varepsilon = 10^{-3}$ 的情况下进行一次牛顿迭代。设当前迭代步在 $T$ 上的节点值为 $u_{1}^{(k)} = 0.3$、$u_{2}^{(k)} = 1.2$、$u_{3}^{(k)} = -0.4$。使用你推导出的正则化雅可比矩阵，计算单个局部雅可比矩阵项 $J_{23}^{(T)}(u_{h}^{(k)})$ 并返回其数值。将答案四舍五入到四位有效数字。无需单位。最终响应必须仅为此数字。", "solution": "该问题分为三个任务：1) 为牛顿法推导雅可比矩阵，2) 为所得系统提出正则化方法，以及 3) 计算局部正则化雅可比矩阵的一个特定项。\n\n**第1部分：雅可比矩阵的推导**\n\n该问题涉及使用有限元方法 (FEM) 数值求解 $p$-拉普拉斯方程 $-\\nabla \\cdot (|\\nabla u|^{p-2}\\nabla u) = f$。离散解 $u_h = \\sum_{j=1}^{N} c_j \\varphi_j$ 是通过求解非线性方程组 $R(u_h) = 0$ 得到的，其中残差向量 $R(u_h) \\in \\mathbb{R}^{N}$ 的分量为\n$$R_i(u_h) := \\int_{\\Omega}|\\nabla u_h|^{p-2}\\nabla u_h \\cdot \\nabla \\varphi_i\\,\\mathrm{d}x - \\int_{\\Omega} f \\varphi_i \\,\\mathrm{d}x = 0$$\n对于 $i=1, \\dots, N$。这里，$\\{\\varphi_i\\}$ 是连续分片线性函数空间 $V_h \\subset H_0^1(\\Omega)$ 的全局节点基，而 $\\{c_j\\}$ 是 $u_h$ 的节点值。\n\n牛顿法用于求解该系统。给定一个迭代步 $u_h^{(k)}$，下一个迭代步为 $u_h^{(k+1)} = u_h^{(k)} + \\delta u_h^{(k)}$，其中更新量 $\\delta u_h^{(k)}$ 是线性系统 $J(u_h^{(k)}) \\delta u_h^{(k)} = -R(u_h^{(k)})$ 的解。矩阵 $J(u_h^{(k)})$ 是残差 $R$ 在 $u_h^{(k)}$ 处求值的雅可比矩阵。\n\n雅可比矩阵的项 $J_{ij}$ 由残差的第 $i$ 个分量 $R_i$ 关于 $u_h$ 沿基函数 $\\varphi_j$ 方向的 Gâteaux 导数给出。泛函 $F(u)$ 在点 $u$ 沿方向 $w$ 的 Gâteaux 导数定义为\n$$DF(u)[w] = \\lim_{t\\to 0} \\frac{F(u+tw) - F(u)}{t}$$\n我们将残差中的非线性算子表示为 $\\mathbf{A}(\\mathbf{q}) = |\\mathbf{q}|^{p-2}\\mathbf{q}$。残差为 $R_i(u_h) = \\int_{\\Omega} \\mathbf{A}(\\nabla u_h) \\cdot \\nabla \\varphi_i \\,\\mathrm{d}x - \\text{常数}$。雅可比矩阵项 $J_{ij}(u_h)$ 是 $R_i(u_h)$ 在方向 $\\varphi_j$ 上的 Gâteaux 导数：\n$$J_{ij}(u_h) = DR_i(u_h)[\\varphi_j] = \\lim_{t\\to 0} \\frac{1}{t} \\left( \\int_{\\Omega} \\mathbf{A}(\\nabla u_h + t\\nabla\\varphi_j) \\cdot \\nabla\\varphi_i \\,\\mathrm{d}x - \\int_{\\Omega} \\mathbf{A}(\\nabla u_h) \\cdot \\nabla\\varphi_i \\,\\mathrm{d}x \\right)$$\n假设有足够的光滑性可以交换极限和积分，我们有\n$$J_{ij}(u_h) = \\int_{\\Omega} \\left( \\lim_{t\\to 0} \\frac{\\mathbf{A}(\\nabla u_h + t\\nabla\\varphi_j) - \\mathbf{A}(\\nabla u_h)}{t} \\right) \\cdot \\nabla\\varphi_i \\,\\mathrm{d}x$$\n极限内的项是在 $\\mathbf{q}=\\nabla u_h$ 处沿方向 $\\delta\\mathbf{q} = \\nabla\\varphi_j$ 的 $\\mathbf{A}(\\mathbf{q})$ 的 Gâteaux 导数。我们来计算这个导数 $D\\mathbf{A}(\\mathbf{q})[\\delta\\mathbf{q}]$。我们对 $\\mathbf{A}(\\mathbf{q}) = (|\\mathbf{q}|^2)^{\\frac{p-2}{2}}\\mathbf{q}$ 使用乘积法则求导：\n$$D\\mathbf{A}(\\mathbf{q})[\\delta\\mathbf{q}] = D\\left((|\\mathbf{q}|^2)^{\\frac{p-2}{2}}\\right)[\\delta\\mathbf{q}] \\, \\mathbf{q} + (|\\mathbf{q}|^2)^{\\frac{p-2}{2}} D(\\mathbf{q})[\\delta\\mathbf{q}]$$\n$|\\mathbf{q}|^2 = \\mathbf{q} \\cdot \\mathbf{q}$ 的导数是 $2\\mathbf{q}\\cdot\\delta\\mathbf{q}$。使用链式法则：\n$$D\\left((|\\mathbf{q}|^2)^{\\frac{p-2}{2}}\\right)[\\delta\\mathbf{q}] = \\frac{p-2}{2}(|\\mathbf{q}|^2)^{\\frac{p-4}{2}}(2\\mathbf{q}\\cdot\\delta\\mathbf{q}) = (p-2)|\\mathbf{q}|^{p-4}(\\mathbf{q}\\cdot\\delta\\mathbf{q})$$\n$\\mathbf{q}$ 的导数就是 $\\delta\\mathbf{q}$。将这些结合起来，我们得到：\n$$D\\mathbf{A}(\\mathbf{q})[\\delta\\mathbf{q}] = (p-2)|\\mathbf{q}|^{p-4}(\\mathbf{q}\\cdot\\delta\\mathbf{q})\\mathbf{q} + |\\mathbf{q}|^{p-2}\\delta\\mathbf{q}$$\n将此代入 $J_{ij}(u_h)$ 的积分中，其中 $\\mathbf{q}=\\nabla u_h^{(k)}$ 且 $\\delta\\mathbf{q}=\\nabla\\varphi_j$：\n$$J_{ij}(u_h^{(k)}) = \\int_{\\Omega} \\left( (p-2)|\\nabla u_h^{(k)}|^{p-4}(\\nabla u_h^{(k)}\\cdot\\nabla\\varphi_j)\\nabla u_h^{(k)} + |\\nabla u_h^{(k)}|^{p-2}\\nabla\\varphi_j \\right) \\cdot \\nabla\\varphi_i \\,\\mathrm{d}x$$\n将与 $\\nabla \\varphi_i$ 的点积分配开，得到雅可比矩阵项的最终表达式：\n$$J_{ij}(u_h^{(k)}) = \\int_{\\Omega} \\left( |\\nabla u_h^{(k)}|^{p-2}(\\nabla\\varphi_i \\cdot \\nabla\\varphi_j) + (p-2)|\\nabla u_h^{(k)}|^{p-4}(\\nabla u_h^{(k)}\\cdot\\nabla\\varphi_i)(\\nabla u_h^{(k)}\\cdot\\nabla\\varphi_j) \\right)\\mathrm{d}x$$\n由于 $u_h^{(k)}$ 是分片线性的，$\\nabla u_h^{(k)}$ 在三角剖分的每个单元 $T$ 上是常数。全局雅可比矩阵是单元雅可比矩阵的组装， $J = \\sum_{T} J^{(T)}$，其中\n$$J_{ij}^{(T)}(u_h^{(k)}) = \\int_{T} \\left( |\\nabla u_h^{(k)}|^{p-2}(\\nabla\\varphi_i \\cdot \\nabla\\varphi_j) + (p-2)|\\nabla u_h^{(k)}|^{p-4}(\\nabla u_h^{(k)}\\cdot\\nabla\\varphi_i)(\\nabla u_h^{(k)}\\cdot\\nabla\\varphi_j) \\right)\\mathrm{d}x$$\n由于被积函数在 $T$ 上是常数，这可简化为被积函数乘以单元的面积 $\\text{Area}(T)$。\n\n**第2部分：正则化策略**\n\n推导出的雅可比矩阵项包含 $|\\nabla u_h^{(k)}|^{p-2}$ 和 $|\\nabla u_h^{(k)}|^{p-4}$ 项。如果 $p2$，则 $|\\nabla u_h^{(k)}|^{p-2}$ 项在 $\\nabla u_h^{(k)} = \\mathbf{0}$ 的点上是奇异的；如果 $p4$，则 $|\\nabla u_h^{(k)}|^{p-4}$ 项也是奇异的。这种退化性为牛顿法带来了问题，因为雅可比矩阵可能不是良定义的。\n\n处理此问题的一个标准方法是引入一个正则化参数 $\\varepsilon  0$。不可微的项 $|\\mathbf{q}|$ 被一个光滑近似 $\\sqrt{|\\mathbf{q}|^2 + \\varepsilon^2}$ 所替代。非线性通量算子 $\\mathbf{A}(\\mathbf{q})$ 被正则化版本 $\\mathbf{A}_\\varepsilon(\\mathbf{q})$ 所替代：\n$$\\mathbf{A}_\\varepsilon(\\mathbf{q}) = (|\\mathbf{q}|^2 + \\varepsilon^2)^{\\frac{p-2}{2}} \\mathbf{q}$$\n只要 $\\varepsilon  0$，该函数对于任何 $\\mathbf{q} \\in \\mathbb{R}^2$ 都是可微的。正则化弱形式旨在寻找 $u_h \\in V_h$，使得对所有 $v_h \\in V_h$：\n$$\\int_{\\Omega} (|\\nabla u_h|^2 + \\varepsilon^2)^{\\frac{p-2}{2}}\\nabla u_h \\cdot \\nabla v_h \\,\\mathrm{d}x = \\int_{\\Omega} f v_h \\,\\mathrm{d}x$$\n正则化问题的雅可比矩阵的推导过程与第1部分中的步骤相同，只需将 $|\\mathbf{q}|^2$ 替换为 $|\\mathbf{q}|^2+\\varepsilon^2$。$\\mathbf{A}_\\varepsilon$ 的 Gâteaux 导数是：\n$$D\\mathbf{A}_\\varepsilon(\\mathbf{q})[\\delta\\mathbf{q}] = (p-2)(|\\mathbf{q}|^2+\\varepsilon^2)^{\\frac{p-4}{2}}(\\mathbf{q}\\cdot\\delta\\mathbf{q})\\mathbf{q} + (|\\mathbf{q}|^2+\\varepsilon^2)^{\\frac{p-2}{2}}\\delta\\mathbf{q}$$\n因此，正则化的雅可比矩阵项 $J_{ij, \\varepsilon}$ 由下式给出：\n$$J_{ij, \\varepsilon}(u_h) = \\int_{\\Omega} \\left( (|\\nabla u_h|^2+\\varepsilon^2)^{\\frac{p-2}{2}}(\\nabla\\varphi_i \\cdot \\nabla\\varphi_j) + (p-2)(|\\nabla u_h|^2+\\varepsilon^2)^{\\frac{p-4}{2}}(\\nabla u_h\\cdot\\nabla\\varphi_i)(\\nabla u_h\\cdot\\nabla\\varphi_j) \\right)\\mathrm{d}x$$\n对于任何 $\\varepsilon  0$，被积函数中的项对所有 $\\nabla u_h$ 都是良定义的，从而解决了退化问题。\n\n**第3部分：雅可比矩阵项的数值计算**\n\n我们需要计算在具有顶点 $V_1=(0,0)$、$V_2=(1,0)$ 和 $V_3=(0,1)$ 的特定三角单元 $T$ 上的局部雅可比矩阵项 $J_{23}^{(T)}$。\n这个三角形的面积是 $\\text{Area}(T) = \\frac{1}{2}|(1-0)(1-0) - (0-0)(0-0)| = \\frac{1}{2}$。\n局部线性基函数 $\\{\\phi_i\\}_{i=1}^3$ 由 $\\phi_i(V_j) = \\delta_{ij}$ 定义。它们是：\n$\\phi_1(x,y) = 1-x-y \\implies \\nabla\\phi_1 = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix}$\n$\\phi_2(x,y) = x \\quad \\quad \\implies \\nabla\\phi_2 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$\n$\\phi_3(x,y) = y \\quad \\quad \\implies \\nabla\\phi_3 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$\n\n当前迭代步 $u_h^{(k)}$ 在 $T$ 上的值由其节点值给出：$u_1^{(k)} = 0.3$、$u_2^{(k)} = 1.2$、$u_3^{(k)} = -0.4$。\n梯度 $\\nabla u_h^{(k)}$ 在 $T$ 上是常数：\n$$\\nabla u_h^{(k)}|_T = u_1^{(k)}\\nabla\\phi_1 + u_2^{(k)}\\nabla\\phi_2 + u_3^{(k)}\\nabla\\phi_3 = 0.3\\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix} + 1.2\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} - 0.4\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -0.3+1.2 \\\\ -0.3-0.4 \\end{pmatrix} = \\begin{pmatrix} 0.9 \\\\ -0.7 \\end{pmatrix}$$\n令 $\\mathbf{g} = \\nabla u_h^{(k)}|_T$。我们计算其模的平方：$|\\mathbf{g}|^2 = (0.9)^2 + (-0.7)^2 = 0.81 + 0.49 = 1.3$。\n\n我们需要为 $p=3$ 和 $\\varepsilon = 10^{-3}$ 计算 $J_{23}^{(T)}(u_h^{(k)})$。正则化雅可比矩阵的单元公式为：\n$$J_{ij, \\varepsilon}^{(T)}(u_h) = \\text{Area}(T) \\left( (|\\nabla u_h|^2+\\varepsilon^2)^{\\frac{p-2}{2}}(\\nabla\\phi_i \\cdot \\nabla\\phi_j) + (p-2)(|\\nabla u_h|^2+\\varepsilon^2)^{\\frac{p-4}{2}}(\\nabla u_h\\cdot\\nabla\\phi_i)(\\nabla u_h\\cdot\\nabla\\phi_j) \\right)$$\n对于 $i=2, j=3, p=3$：\n$$J_{23, \\varepsilon}^{(T)}(u_h^{(k)}) = \\text{Area}(T) \\left( (|\\mathbf{g}|^2+\\varepsilon^2)^{\\frac{1}{2}}(\\nabla\\phi_2 \\cdot \\nabla\\phi_3) + (1)(|\\mathbf{g}|^2+\\varepsilon^2)^{-\\frac{1}{2}}(\\mathbf{g}\\cdot\\nabla\\phi_2)(\\mathbf{g}\\cdot\\nabla\\phi_3) \\right)$$\n我们计算必要的点积：\n$\\nabla\\phi_2 \\cdot \\nabla\\phi_3 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\cdot \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = 0$。\n$\\mathbf{g}\\cdot\\nabla\\phi_2 = \\begin{pmatrix} 0.9 \\\\ -0.7 \\end{pmatrix} \\cdot \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = 0.9$。\n$\\mathbf{g}\\cdot\\nabla\\phi_3 = \\begin{pmatrix} 0.9 \\\\ -0.7 \\end{pmatrix} \\cdot \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = -0.7$。\n此外，我们有 $|\\mathbf{g}|^2=1.3$ 和 $\\varepsilon^2 = (10^{-3})^2 = 10^{-6}$。所以，$|\\mathbf{g}|^2 + \\varepsilon^2 = 1.300001$。\n\n将这些值代入公式中：\n$$J_{23, \\varepsilon}^{(T)} = 0.5 \\left( (1.300001)^{\\frac{1}{2}}(0) + (1.300001)^{-\\frac{1}{2}}(0.9)(-0.7) \\right)$$\n$$J_{23, \\varepsilon}^{(T)} = 0.5 \\left( \\frac{-0.63}{\\sqrt{1.300001}} \\right) = \\frac{-0.315}{\\sqrt{1.300001}}$$\n现在，我们计算其数值：\n$$J_{23, \\varepsilon}^{(T)} \\approx \\frac{-0.315}{1.14017586} \\approx -0.27626900$$\n四舍五入到四位有效数字，我们得到 $-0.2763$。", "answer": "$$\\boxed{-0.2763}$$", "id": "3380993"}, {"introduction": "在离散化非线性项时，数值方法本身可能会引入意想不到的误差。本练习将探讨“混叠”（aliasing）现象，这是伪谱法中常见的数值假象，其中非线性相互作用产生的高频分量会伪装成低频信号，从而污染解的精度。通过一个数值实验，比较朴素计算与使用“2/3反混叠规则”进行滤波计算的结果，您将能够量化这种误差，并理解选择与非线性结构相适应的离散化策略的重要性。[@problem_id:3405943]", "problem": "考虑一个一维周期性域，区间为 $[0,2\\pi]$，由 $N$ 个点的均匀结构化网格离散化。令 $x_n = \\frac{2\\pi n}{N}$，其中整数 $n \\in \\{0,1,\\dots,N-1\\}$。定义一个实值场 $u(x)$，它由具有指定整数波数的正弦和余弦组成的有限傅里叶级数构成。我们关注的非线性项是 $g(x) = u(x)^2$。在伪谱方法中，非线性乘积 $u(x)^2$ 在物理空间中逐点计算，由于离散采样和截断谱，这会将混叠（aliasing）引入到已解析的低阶模态中。“三分之二去混叠规则”通过在乘法前滤除高于截止波数的傅里叶模态，来减轻二次非线性项的混叠。\n\n您必须使用的基本原理是周期域上的傅里叶级数和离散傅里叶变换（DFT）的定义。离散周期信号 $f_n = f(x_n)$ 的DFT为 $\\hat{f}_m = \\sum_{n=0}^{N-1} f_n \\exp\\left(-\\frac{2\\pi i n m}{N}\\right)$，其逆变换为 $f_n = \\frac{1}{N} \\sum_{m=0}^{N-1} \\hat{f}_m \\exp\\left(\\frac{2\\pi i n m}{N}\\right)$。卷积定理指出，乘积的傅里叶变换是变换的卷积，而使用有限数量点的离散采样会导致卷积和的回卷（混叠）到已解析的谱范围内。“三分之二去混叠规则”在计算乘积之前将高于 $k_c = \\lfloor N/3 \\rfloor$ 的模态置零，从而消除已解析范围内的二次非线性项的混叠。\n\n您的任务是实现一个程序，针对下面的每个测试用例，计算以下两者之间的相对误差：\n- 未经滤波的 $u^2$ 的伪谱计算（在分辨率 $N$ 下的朴素逐点乘法），以及一个基于高分辨率计算构建的 $u^2$ 的参考低阶模态投影。\n- 应用“三分之二去混叠规则”（在乘法前将 $|k|  \\lfloor N/3 \\rfloor$ 的模态置零）的滤波伪谱计算，以及相同的参考低阶模态投影。\n\n对于分辨率为 $N$ 的 $g(x) = u(x)^2$ 的参考低阶模态投影，使用一个 $N_{\\mathrm{ref}} = 8N$ 的过采样网格，解析地计算 $u(x)$，计算 $g(x) = u(x)^2$，进行DFT得到 $\\hat{g}_{\\mathrm{ref}}$，然后通过复制 $|k| \\leq N/2$ 的中心傅里叶系数并进行适当缩放（将复制的系数乘以比率 $N/N_{\\mathrm{ref}}$ 以考虑不同的DFT归一化），将低波数内容投影到 $N$ 点谱中，以保留连续傅里叶系数。然后进行逆变换，以获得 $N$ 点网格上的物理空间参考场 $g_{\\mathrm{true}}(x_n)$。\n\n定义候选场 $g(x_n)$ 相对于参考场 $g_{\\mathrm{true}}(x_n)$ 的相对 $\\ell^2$ 误差为\n$$\nE = \\frac{\\left( \\frac{1}{N} \\sum_{n=0}^{N-1} \\left| g(x_n) - g_{\\mathrm{true}}(x_n) \\right|^2 \\right)^{1/2}}{\\left( \\frac{1}{N} \\sum_{n=0}^{N-1} \\left| g_{\\mathrm{true}}(x_n) \\right|^2 \\right)^{1/2}}.\n$$\n\n通过以下步骤实现“三分之二去混叠规则”：\n1. 计算 $N$ 点场 $u(x_n)$ 的DFT $\\hat{u}$。\n2. 将 $|k|  \\lfloor N/3 \\rfloor$ 的中心傅里叶系数置零，得到 $\\hat{u}_{\\mathrm{filtered}}$。\n3. 进行逆变换得到 $u_{\\mathrm{filtered}}(x_n)$，然后形成 $g_{\\mathrm{filtered}}(x_n) = u_{\\mathrm{filtered}}(x_n)^2$。\n4. 将 $g_{\\mathrm{filtered}}$ 投影到 $|k| \\leq N/2$ 范围（$N$点谱的低阶模态），然后逆变换回物理空间进行比较。\n\n对于未滤波的情况，只需形成 $g_{\\mathrm{naive}}(x_n) = u(x_n)^2$，并在逆变换前将其投影到 $N$ 点谱的 $|k| \\leq N/2$ 范围。\n\n测试套件：\n对于每个案例，域均为 $[0,2\\pi]$，角度以弧度为单位。将 $u(x)$ 定义为下面给出的正弦和余弦之和。\n\n- 案例1（理想情况，中等 $N$，混合模态低于三分之二截止频率）：\n  $N = 96$, $u(x) = 1.0 \\cos(30 x) + 0.5 \\sin(31 x) + 0.25 \\cos(2 x)$.\n- 案例2（边界情况，一个模态接近奈奎斯特频率，有更强的混叠可能性）：\n  $N = 48$, $u(x) = 1.0 \\cos(23 x) + 1.0 \\sin(16 x) + 0.3 \\cos(5 x)$.\n- 案例3（接近截止频率的复合高阶模态加一个低阶模态）：\n  $N = 64$, $u(x) = 0.8 \\sin(20 x) + 0.7 \\cos(21 x) - 0.6 \\sin(22 x) + 0.2 \\cos(3 x)$.\n- 案例4（恰好在三分之二截止频率处的边界情况）：\n  $N = 60$, $u(x) = 1.0 \\sin(20 x) + 0.9 \\cos(19 x) + 0.5 \\sin(21 x)$.\n\n您的程序必须为每个案例计算相对 $\\ell^2$ 误差对 $(E_{\\mathrm{naive}}, E_{\\mathrm{filtered}})$，并将它们汇总到单行输出中。最终输出格式必须是单行，包含一个扁平列表，按以下顺序包含所有误差：\n$[E_{\\mathrm{naive}}^{(1)},E_{\\mathrm{filtered}}^{(1)},E_{\\mathrm{naive}}^{(2)},E_{\\mathrm{filtered}}^{(2)},E_{\\mathrm{naive}}^{(3)},E_{\\mathrm{filtered}}^{(3)},E_{\\mathrm{naive}}^{(4)},E_{\\mathrm{filtered}}^{(4)}]$.\n\n最终输出为浮点数。不适用任何物理单位。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$\\[r_1,r_2,\\dots\\]$）。", "solution": "此问题经评估有效。其科学依据源于偏微分方程数值分析的原理，特别是关于伪谱方法中的混叠误差。该问题提法恰当、客观，并提供了构建唯一可计算解所需的所有必要信息。此过程是评估“三分之二去混叠规则”有效性的标准数值实验。\n\n任务是计算二次非线性项 $g(x) = u(x)^2$ 的两种不同伪谱近似解相对于高分辨率参考解的相对误差。域为一维周期性区间 $[0, 2\\pi]$，由 $N$ 个点的均匀网格离散化， $x_n = \\frac{2\\pi n}{N}$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。\n\n### 1. 傅里叶变换与离散化\n\n该问题设置在傅里叶谱方法的背景下。长度为 $N$ 的序列 $f_n$ 的离散傅里叶变换（DFT）定义为：\n$$\n\\hat{f}_m = \\sum_{n=0}^{N-1} f_n \\exp\\left(-\\frac{2\\pi i n m}{N}\\right)\n$$\n相应的逆离散傅里叶变换（IDFT）为：\n$$\nf_n = \\frac{1}{N} \\sum_{m=0}^{N-1} \\hat{f}_m \\exp\\left(\\frac{2\\pi i n m}{N}\\right)\n$$\n整数 $m$ 代表离散波数。对于实信号 $f_n$，波数通常在中心化范围内解释，大约从 $-N/2$ 到 $N/2$。可表示的最高波数幅度是奈奎斯特波数，$k_{\\mathrm{Nyquist}} = N/2$。\n\n### 2. 参考解：$g_{\\mathrm{true}}(x_n)$\n\n为了确定 $g(x) = u(x)^2$ 的低波数内容的基准真相，我们使用高分辨率计算来避免混叠。\n1.  创建一个具有 $N_{\\mathrm{ref}} = 8N$ 个点的过采样网格，$x_j^{\\mathrm{ref}} = \\frac{2\\pi j}{N_{\\mathrm{ref}}}$。该网格的奈奎斯特波数为 $4N$，这足够高，可以无混叠地解析测试用例中出现的所有波数的乘积。\n2.  在此高分辨率网格上计算解析函数 $u(x)$，得到 $u_j^{\\mathrm{ref}} = u(x_j^{\\mathrm{ref}})$。\n3.  逐点计算二次非线性项：$g_j^{\\mathrm{ref}} = (u_j^{\\mathrm{ref}})^2$。\n4.  计算此高分辨率乘积的DFT：$\\hat{g}_{\\mathrm{ref}} = \\text{DFT}(g^{\\mathrm{ref}})$。\n5.  通过从 $\\hat{g}_{\\mathrm{ref}}$ 中提取与 $N$ 点网格可解析的波数（即 $|k| \\leq N/2$）相对应的系数，来获得真实的低波数谱 $\\hat{g}_{\\mathrm{true}}$。应用一个缩放因子以解释不同网格尺寸下DFT的不同归一化。对于大小为 $M$ 的网格，连续傅里叶系数 $c_k$ 和离散傅里叶系数 $\\hat{f}_k$ 之间的关系近似为 $\\hat{f}_k \\approx M c_k$。因此，当从 $N_{\\mathrm{ref}}$ 点上的DFT转移到 $N$ 点上的DFT时，为了保持连续系数，我们按网格尺寸的比率进行缩放：\n    $$\n    \\hat{g}_{\\mathrm{true}, k} = \\hat{g}_{\\mathrm{ref}, k} \\times \\frac{N}{N_{\\mathrm{ref}}}\n    $$\n    对于 $N$ 点网格解析范围内的波数 $k$。\n6.  最后，通过对投影后的谱应用逆DFT，得到低分辨率网格上的物理空间参考解：$g_{\\mathrm{true}}(x_n) = \\text{IDFT}(\\hat{g}_{\\mathrm{true}})$。\n\n### 3. 朴素伪谱方法：$g_{\\mathrm{naive}}(x_n)$\n\n最简单的伪谱方法直接在物理空间中计算非线性项。\n1.  在 $N$ 点网格上计算解析函数 $u(x)$：$u_n = u(x_n)$。\n2.  逐点计算乘积：$g_{\\mathrm{naive}, n} = u_n^2$。\n\n该方法计算效率高，但会产生混叠。当 $u(x)$ 的谱包含高达 $k_{\\mathrm{max}}$ 的波数时，$u(x)^2$ 的谱将包含高达 $2k_{\\mathrm{max}}$ 的波数。如果 $2k_{\\mathrm{max}}  k_{\\mathrm{Nyquist}}$，高波数分量将被“折叠”回可解析范围内，从而污染低波数系数。\n\n### 4. 滤波伪谱方法（三分之二规则）：$g_{\\mathrm{filtered}}(x_n)$\n\n“三分之二去混叠规则”旨在减轻二次非线性项的这种混叠误差。通过在乘法之前移除高波数内容，创建一个滤波后的场 $u_{\\mathrm{filtered}}$。\n1.  在 $N$ 点网格上计算场 $u_n = u(x_n)$。\n2.  对其进行DFT：$\\hat{u} = \\text{DFT}(u)$。\n3.  应用一个谱滤波器。所有波数幅度 $|k|$ 超过截止值 $k_c = \\lfloor N/3 \\rfloor$ 的傅里叶系数 $\\hat{u}_k$ 都被设为零。这将创建一个滤波后的谱 $\\hat{u}_{\\mathrm{filtered}}$。\n    $$\n    \\hat{u}_{\\mathrm{filtered}, k} = \\begin{cases} \\hat{u}_k  \\text{if } |k| \\leq k_c \\\\ 0  \\text{if } |k|  k_c \\end{cases}\n    $$\n4.  将滤波后的谱变换回物理空间：$u_{\\mathrm{filtered}} = \\text{IDFT}(\\hat{u}_{\\mathrm{filtered}})$。\n5.  然后使用这个滤波后的场计算非线性项：$g_{\\mathrm{filtered}, n} = (u_{\\mathrm{filtered}, n})^2$。\n\n通过对输入进行滤波，使其最大波数为 $k_c \\approx N/3$，二次乘积中的最大波数变为 $2k_c \\approx 2N/3$。来自这些乘积模态的任何混叠都将落入波数范围 $|k|  k_c$ 内，从而使“去混叠”范围 $|k| \\leq k_c$ 不受污染。\n\n### 5. 误差计算\n\n对于每种方法（朴素法和滤波法），都计算其相对于参考解 $g_{\\mathrm{true}}$ 的相对 $\\ell^2$ 误差。候选解 $g$ 的误差 $E$ 为：\n$$\nE = \\frac{\\| g - g_{\\mathrm{true}} \\|_2}{\\| g_{\\mathrm{true}} \\|_2} = \\frac{\\left( \\sum_{n=0}^{N-1} \\left| g_n - g_{\\mathrm{true},n} \\right|^2 \\right)^{1/2}}{\\left( \\sum_{n=0}^{N-1} \\left| g_{\\mathrm{true},n} \\right|^2 \\right)^{1/2}}\n$$\n其中问题定义中的因子 $1/N$ 被抵消。算法通过为每个测试用例计算 $(E_{\\mathrm{naive}}, E_{\\mathrm{filtered}})$ 来进行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef u_analytical(x, terms):\n    \"\"\"\n    Computes the analytical function u(x) given a list of its Fourier components.\n\n    Args:\n        x (np.ndarray): Array of points to evaluate the function at.\n        terms (list): A list of tuples, where each tuple is (amplitude, type, wavenumber).\n                      Type is 'sin' or 'cos'.\n\n    Returns:\n        np.ndarray: The values of u(x) at the given points.\n    \"\"\"\n    result = np.zeros_like(x, dtype=float)\n    for amp, f_type, k in terms:\n        if f_type == 'cos':\n            result += amp * np.cos(k * x)\n        elif f_type == 'sin':\n            result += amp * np.sin(k * x)\n    return result\n\ndef get_g_true(N, u_terms):\n    \"\"\"\n    Computes the reference solution g_true on an N-point grid using a\n    high-resolution intermediate calculation to avoid aliasing.\n    \"\"\"\n    N_ref = 8 * N\n    x_ref = np.linspace(0, 2 * np.pi, N_ref, endpoint=False)\n    \n    u_ref = u_analytical(x_ref, u_terms)\n    g_ref_physical = u_ref**2\n    \n    g_hat_ref = np.fft.fft(g_ref_physical)\n    \n    # Project the high-resolution spectrum onto the low-resolution grid\n    # by extracting the low-wavenumber modes.\n    g_hat_true = np.zeros(N, dtype=np.complex128)\n    \n    # For even N, fftfreq gives k = [0, 1, ..., N/2-1, -N/2, ..., -1]\n    # We copy the positive frequencies (and zero) and negative frequencies.\n    half_N = N // 2\n    \n    # Positive frequencies including k=0\n    g_hat_true[0:half_N] = g_hat_ref[0:half_N]\n    \n    # Nyquist and negative frequencies for np.fft convention\n    # The k=-1 mode in an N-point FFT is at index N-1.\n    g_hat_true[half_N:] = g_hat_ref[N_ref - half_N:]\n\n    # Scale coefficients to account for DFT normalization difference\n    g_hat_true *= (N / N_ref)\n    \n    g_true_physical = np.fft.ifft(g_hat_true)\n    \n    return g_true_physical.real\n\ndef calculate_errors(case):\n    \"\"\"\n    Calculates the naive and filtered errors for a single test case.\n    \"\"\"\n    N, u_terms = case\n    k_c = N // 3\n    \n    # 1. Setup low-resolution grid and evaluate u(x)\n    x = np.linspace(0, 2 * np.pi, N, endpoint=False)\n    u_on_grid = u_analytical(x, u_terms)\n    \n    # 2. Compute the high-resolution reference solution\n    g_true = get_g_true(N, u_terms)\n    norm_g_true = np.linalg.norm(g_true)\n    \n    # 3. Naive method\n    g_naive = u_on_grid**2\n    error_naive = np.linalg.norm(g_naive - g_true) / norm_g_true\n    \n    # 4. Filtered method (2/3 rule)\n    u_hat = np.fft.fft(u_on_grid)\n    k_vec = np.fft.fftfreq(N, d=1.0) * N  # Integer wavenumbers\n    \n    u_hat_filtered = u_hat.copy()\n    u_hat_filtered[np.abs(k_vec)  k_c] = 0.0\n    \n    u_filtered = np.fft.ifft(u_hat_filtered)\n    # The squared field should be real, .real handles minor numerical noise\n    g_filtered = u_filtered.real**2\n    \n    error_filtered = np.linalg.norm(g_filtered - g_true) / norm_g_true\n    \n    return error_naive, error_filtered\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: N=96, u(x) = 1.0*cos(30x) + 0.5*sin(31x) + 0.25*cos(2x)\n        (96, [(1.0, 'cos', 30), (0.5, 'sin', 31), (0.25, 'cos', 2)]),\n        \n        # Case 2: N=48, u(x) = 1.0*cos(23x) + 1.0*sin(16x) + 0.3*cos(5x)\n        (48, [(1.0, 'cos', 23), (1.0, 'sin', 16), (0.3, 'cos', 5)]),\n        \n        # Case 3: N=64, u(x) = 0.8*sin(20x) + 0.7*cos(21x) - 0.6*sin(22x) + 0.2*cos(3x)\n        (64, [(0.8, 'sin', 20), (0.7, 'cos', 21), (-0.6, 'sin', 22), (0.2, 'cos', 3)]),\n        \n        # Case 4: N=60, u(x) = 1.0*sin(20x) + 0.9*cos(19x) + 0.5*sin(21x)\n        (60, [(1.0, 'sin', 20), (0.9, 'cos', 19), (0.5, 'sin', 21)]),\n    ]\n\n    results = []\n    for case in test_cases:\n        err_naive, err_filtered = calculate_errors(case)\n        results.append(err_naive)\n        results.append(err_filtered)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "3405943"}, {"introduction": "求解由偏微分方程离散化得到的大规模非线性系统，需要高效的并行算法。本练习将向您介绍区域分解法，这是一种强大的并行化计算范式。您将为一个具有高材料对比度的挑战性拟线性问题，实现并比较两种经典方法：非线性加性Schwarz法（NAS）和加性Schwarz预处理非精确牛顿法（ASPIN）。此实践将让您深入了解算法性能如何随问题难度和求解器参数而扩展，这是高性能科学计算中的一个关键考量。[@problem_id:3381001]", "problem": "考虑单位区间上的拟线性扩散边界值问题，其具有齐次 Dirichlet 边界条件，\n$$\n-\\frac{d}{dx}\\left(a(x,u)\\frac{du}{dx}\\right)=f(x),\\quad x\\in(0,1),\\qquad u(0)=0,\\quad u(1)=0,\n$$\n其中非线性扩散系数为\n$$\na(x,u)=a_0(x)\\left(1+\\alpha\\,u^2\\right),\n$$\n具有空间非均匀性\n$$\na_0(x)=\\begin{cases}\n1, x\\leq 1/2,\\\\\n\\gamma, x1/2,\n\\end{cases}\n$$\n给定对比度参数 $\\gamma\\ge 1$ 和非线性强度 $\\alpha0$。令强迫项为常数，\n$$\nf(x)\\equiv 1.\n$$\n\n在具有 $N$ 个内点、间距为 $h=1/(N+1)$ 的均匀网格上离散化该问题，节点为 $x_i=ih$（整数 $i=0,1,\\dots,N+1$），未知数为 $u_i\\approx u(x_i)$（$i=1,\\dots,N$）。使用保守有限差分通量离散格式，其中扩散项在面上中心化：\n$$\n\\mathcal{R}_i(\\mathbf{u})=\\frac{1}{h^2}\\left(A_{i+1/2}\\left(u_{i+1}-u_i\\right)-A_{i-1/2}\\left(u_i-u_{i-1}\\right)\\right)-f_i,\\quad i=1,\\dots,N,\n$$\n其中面扩散系数为\n$$\nA_{i+1/2}=a\\!\\left(x_{i+1/2},\\frac{u_{i+1}+u_i}{2}\\right),\\quad x_{i+1/2}=(i+1/2)h,\n$$\n且 $f_i=f(x_i)=1$。在计算离散残差时，施加边界值 $u_0=0$ 和 $u_{N+1}=0$。\n\n对内部索引集 $\\{1,2,\\dots,N\\}$ 定义一个一维重叠区域分解，将其分解为 $n_s$ 个连续的核心子区域，并将每个核心子区域向两侧各延伸 $\\delta\\in\\{0,1,2,\\dots\\}$ 个网格点作为重叠区域（裁剪以保持在 $\\{1,\\dots,N\\}$ 内）。将扩展后的子区域索引范围记为 $[L_s,U_s]$，$s=1,\\dots,n_s$。令单位分解权重 $w_i$ 定义为 $w_i=1/n_i$，其中 $n_i$ 是覆盖索引 $i$ 的扩展子区域数量。\n\n考虑以下两种非线性求解器：\n\n- 非线性加性 Schwarz (NAS) 迭代：给定当前全局迭代解 $\\mathbf{u}^{(k)}$，对每个子区域 $s$，求解局部非线性离散问题以获得局部解 $\\mathbf{u}^{(k)}_s$，其在人工边界上的 Dirichlet 边界值取自 $\\mathbf{u}^{(k)}$。在扩展子区域范围内形成局部校正量 $\\mathbf{c}_s=\\mathbf{u}^{(k)}_s-\\mathbf{u}^{(k)}|_{[L_s,U_s]}$。通过单位分解注入法组合成全局校正量，\n$$\nd_i=\\sum_{s:\\,i\\in[L_s,U_s]} w_i\\,(\\mathbf{c}_s)_i,\n$$\n并更新 $\\mathbf{u}^{(k+1)}=\\mathbf{u}^{(k)}+\\mathbf{d}$。重复此过程，直到全局残差范数 $\\|\\mathcal{R}(\\mathbf{u}^{(k)})\\|_2$ 低于预设容差。\n\n- 加性 Schwarz 预处理非精确 Newton (ASPIN)：给定 $\\mathbf{u}^{(k)}$，对每个子区域 $s$，构建局部残差向量和局部雅可比矩阵（雅可比矩阵是局部残差相对于局部未知数的偏导数矩阵，考虑了 $A_{i\\pm 1/2}$ 通过算术平均值对 $u$ 的依赖关系）。求解局部线性系统以获得校正量 $\\delta_s$，\n$$\nJ_s(\\mathbf{u}^{(k)})\\,\\delta_s=-\\mathcal{R}_s(\\mathbf{u}^{(k)}),\n$$\n在人工边界上对校正量 $\\delta_s$ 施加齐次 Dirichlet 边界条件。通过相同的单位分解方案注入局部校正量，以获得全局搜索方向 $\\mathbf{p}$。沿 $\\mathbf{p}$ 方向执行回溯线搜索以减小全局残差范数，并使用选定的步长 $\\alpha\\in(0,1]$ 更新 $\\mathbf{u}^{(k+1)}=\\mathbf{u}^{(k)}+\\alpha\\,\\mathbf{p}$。重复此过程直至收敛。\n\n从零初始向量 $\\mathbf{u}^{(0)}=\\mathbf{0}$ 开始，研究在子区域数量 $n_s$ 和非线性强度 $\\alpha$ 固定的情况下，这两种方法相对于对比度 $\\gamma$ 和重叠大小 $\\delta$ 的可扩展性。使用 $N=64$ 个内点和 $\\alpha=1.0$。对于下方的每个测试用例，运行 NAS 和 ASPIN，直到全局残差范数 $\\|\\mathcal{R}(\\mathbf{u})\\|_2$ 小于 $10^{-8}$，或达到 50 次全局迭代的最大次数。记录每种方法所需的全局迭代次数。\n\n测试参数集 $(\\gamma,\\delta,n_s)$：\n- $(1.0,0,2)$，\n- $(10.0,0,4)$，\n- $(100.0,0,4)$，\n- $(100.0,4,4)$，\n- $(1000.0,0,4)$，\n- $(1000.0,4,4)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例的结果必须是一个包含两个整数的列表 $[\\mathrm{it}_{\\mathrm{NAS}},\\mathrm{it}_{\\mathrm{ASPIN}}]$，分别表示 NAS 和 ASPIN 的全局迭代次数。例如，最终输出格式必须类似于\n$$\n[\\,[\\mathrm{it}_{\\mathrm{NAS},1},\\mathrm{it}_{\\mathrm{ASPIN},1}],\\,[\\mathrm{it}_{\\mathrm{NAS},2},\\mathrm{it}_{\\mathrm{ASPIN},2}],\\,\\dots\\,].\n$$\n此问题不涉及物理单位。", "solution": "用户希望使用两种不同的基于区域分解的并行迭代方案来求解一维拟线性边界值问题。任务是实现这些方案，并报告在给定一组测试参数下达到收敛所需的迭代次数。\n\n### **1. 问题描述与离散化**\n\n控制偏微分方程 (PDE) 是一个拟线性扩散方程：\n$$\n-\\frac{d}{dx}\\left(a(x,u)\\frac{du}{dx}\\right)=f(x),\\quad x\\in(0,1)\n$$\n具有齐次 Dirichlet 边界条件 $u(0)=0$ 和 $u(1)=0$。\n\n扩散系数 $a(x,u)$ 是非线性的且空间非均匀：\n$$\na(x,u)=a_0(x)\\left(1+\\alpha\\,u^2\\right), \\quad \\text{其中} \\quad a_0(x)=\\begin{cases}\n1, x\\leq 1/2\\\\\n\\gamma, x1/2\n\\end{cases}\n$$\n参数 $\\alpha  0$ 和 $\\gamma \\ge 1$ 分别控制非线性强度和介质的对比度。强迫项为常数，$f(x)=1$。\n\n我们使用一个包含 $N$ 个内点 $x_i = ih$（$i=1, \\dots, N$）的均匀网格来离散化区域 $(0,1)$，网格间距为 $h=1/(N+1)$。边界节点为 $x_0=0$ 和 $x_{N+1}=1$。令 $u_i \\approx u(x_i)$ 为内点上解的离散近似。边界条件为 $u_0=0$ 和 $u_{N+1}=0$。\n\n采用保守有限差分格式。每个内点 $i=1, \\dots, N$ 的离散残差 $\\mathcal{R}_i$ 由下式给出：\n$$\n\\mathcal{R}_i(\\mathbf{u})=\\frac{1}{h^2}\\left(A_{i+1/2}\\left(u_{i+1}-u_i\\right)-A_{i-1/2}\\left(u_i-u_{i-1}\\right)\\right)-f_i\n$$\n这表示一个包含 $N$ 个非线性代数方程的系统 $\\mathcal{R}(\\mathbf{u})=\\mathbf{0}$。面心扩散系数 $A_{i\\pm1/2}$ 使用解 $u$ 的算术平均值进行计算：\n$$\nA_{i+1/2}=a\\left(x_{i+1/2},\\frac{u_{i+1}+u_i}{2}\\right)\n$$\n其中 $x_{i+1/2} = (i+1/2)h$。\n\n### **2. 区域分解与求解器**\n\n内部索引集 $\\{1, \\dots, N\\}$ 被划分为 $n_s$ 个连续的核心子区域。每个核心向两侧各延伸 $\\delta$ 个网格点，以创建重叠的扩展子区域。使用单位分解（由权重 $w_i = 1/n_i$ 定义，其中 $n_i$ 是覆盖节点 $i$ 的子区域数量）将局部校正组合成全局更新。\n\n我们从 $\\mathbf{u}^{(0)}=\\mathbf{0}$ 开始，实现两种迭代求解器。\n\n#### **非线性加性 Schwarz (NAS)**\nNAS 方法是一种并行的非线性块 Gauss-Seidel/Jacobi 型迭代。在每次全局迭代 $k$ 中：\n1. 对每个子区域 $s$，求解一个局部非线性边界值问题。未知数是扩展子区域内部的 $u$ 值，人工边界上的 Dirichlet 边界值取自当前全局迭代解 $\\mathbf{u}^{(k)}$。\n2. 这个局部求解得到一个局部解 $\\mathbf{u}_s^{(k)}$。局部校正量为 $\\mathbf{c}_s = \\mathbf{u}_s^{(k)} - \\mathbf{u}^{(k)}|_s$。\n3. 通过对局部校正量进行单位分解加权求和，组合成全局校正量 $\\mathbf{d}$：$d_i = \\sum_{s} w_i (\\mathbf{c}_s)_i$。\n4. 更新全局解：$\\mathbf{u}^{(k+1)} = \\mathbf{u}^{(k)} + \\mathbf{d}$。\n\n局部非线性求解必须使用内部迭代方法来执行。我们将使用一个通用的非线性求解器（`scipy.optimize.root`）来完成此任务。\n\n#### **加性 Schwarz 预处理非精确 Newton (ASPIN)**\nASPIN 是一种非精确 Newton 方法，其中 Newton 校正量是通过对雅可比系统使用加性 Schwarz 预条件子并行计算的。在每次全局迭代 $k$ 中：\n1. 对每个子区域 $s$，计算局部残差 $\\mathcal{R}_s(\\mathbf{u}^{(k)})$ 和局部雅可比矩阵 $J_s(\\mathbf{u}^{(k)})$。雅可比矩阵是局部残差相对于局部未知数的偏导数矩阵。\n2. 求解局部线性系统 $J_s(\\mathbf{u}^{(k)}) \\delta_s = -\\mathcal{R}_s(\\mathbf{u}^{(k)})$ 以获得局部校正量 $\\delta_s$。该系统对应于在子区域上的单次 Newton 步，其中校正量 $\\delta_s$ 在人工边界上具有齐次 Dirichlet 边界条件。\n3. 通过对局部校正量进行单位分解加权求和，组合成全局搜索方向 $\\mathbf{p}$：$p_i = \\sum_{s} w_i (\\delta_s)_i$。\n4. 执行回溯线搜索以找到一个步长 $\\alpha_{LS} \\in (0,1]$，确保全局残差范数充分下降，即 $\\|\\mathcal{R}(\\mathbf{u}^{(k)} + \\alpha_{LS}\\mathbf{p})\\|_2  \\|\\mathcal{R}(\\mathbf{u}^{(k)})\\|_2$。\n5. 更新全局解：$\\mathbf{u}^{(k+1)} = \\mathbf{u}^{(k)} + \\alpha_{LS}\\mathbf{p}$。\n\n局部雅可比矩阵 $J_s$ 的元素是通过将离散残差 $\\mathcal{R}_i$ 对未知数 $u_j$ 求导得出的。由于 $A_{i\\pm1/2}$ 非线性地依赖于 $u$，因此应用了链式法则。对于这个一维问题，得到的雅可比矩阵是三对角的。\n\n### **3. 实现细节**\n\n实现将被封装在单个函数 `solve()` 中，该函数将定义所有必要的辅助函数并执行测试套件。\n- **网格与参数**：我们设置 $N=64$，$\\alpha=1.0$，收敛容差为 $10^{-8}$。\n- **子区域创建**：将从 $0$ 到 $N-1$ 的内部索引分割成大小几乎相等的多个核心子区域。然后将这些核心子区域扩展 $\\delta$ 个点，同时遵守全局区域边界。\n- **NAS 内部求解器**：使用 `scipy.optimize.root` 的 `hybr` 方法来求解局部非线性系统。\n- **ASPIN 线性求解器**：对局部雅可比系统使用标准的 `numpy.linalg.solve`，因为这些系统足够小，所以不一定需要专门的带状求解器。\n- **雅可比计算**：三对角雅可比矩阵的元素被解析计算并组合。为提高效率，使用了向量化的 NumPy 操作。\n- **收敛**：两种方法的迭代都将持续进行，直到全局残差的 $L_2$-范数低于容差或达到 50 次迭代的最大值。如果达到最大迭代次数，则报告该数字，表示未能收敛。\n- **输出**：每个测试用例的结果，包括 NAS 和 ASPIN 的迭代次数，将按照指定格式排版成一个列表的列表。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Solves the specified quasilinear diffusion problem using NAS and ASPIN methods\n    for a suite of test cases and prints the iteration counts.\n    \"\"\"\n    \n    # --- Problem Definition ---\n    N = 64\n    ALPHA = 1.0\n    TOL = 1e-8\n    MAX_ITER = 50\n    H = 1.0 / (N + 1)\n\n    # --- Helper Functions (defined internally for self-containment) ---\n\n    def a0_func(x, gamma):\n        \"\"\"Vectorized spatial heterogeneity function a_0(x).\"\"\"\n        a0 = np.ones_like(x)\n        if gamma != 1.0:\n            a0[x  0.5] = gamma\n        return a0\n\n    def a_func(x, u, gamma):\n        \"\"\"Vectorized nonlinear diffusion coefficient a(x,u).\"\"\"\n        return a0_func(x, gamma) * (1.0 + ALPHA * u**2)\n\n    def compute_residual(u, gamma):\n        \"\"\"Computes the global residual vector R(u).\"\"\"\n        u_full = np.concatenate(([0.0], u, [0.0]))\n        \n        u_faces = (u_full[:-1] + u_full[1:]) / 2.0\n        x_faces = H * (np.arange(N + 1) + 0.5)\n\n        A = a_func(x_faces, u_faces, gamma)\n        F = A * (u_full[1:] - u_full[:-1]) / H\n        \n        R = -(F[1:] - F[:-1]) / H - 1.0\n        return R\n\n    def create_subdomains(ns, delta):\n        \"\"\"Creates subdomain definitions and partition of unity weights.\"\"\"\n        core_indices = np.array_split(np.arange(N), ns)\n        subdomains = []\n        for core in core_indices:\n            L_core, U_core = core[0], core[-1]\n            L_ext = max(0, L_core - delta)\n            U_ext = min(N - 1, U_core + delta)\n            subdomains.append(np.arange(L_ext, U_ext + 1))\n\n        n_coverage = np.zeros(N)\n        for sub_indices in subdomains:\n            n_coverage[sub_indices] += 1\n        weights = 1.0 / n_coverage\n        return subdomains, weights\n\n    # --- Nonlinear Solvers ---\n\n    def solve_nas(gamma, delta, ns):\n        \"\"\"Nonlinear Additive Schwarz (NAS) solver.\"\"\"\n        u = np.zeros(N)\n        subdomains, weights = create_subdomains(ns, delta)\n        \n        for k in range(MAX_ITER):\n            if np.linalg.norm(compute_residual(u, gamma))  TOL:\n                return k\n            \n            d = np.zeros(N)\n            u_full = np.concatenate(([0.0], u, [0.0]))\n            \n            for ext_indices in subdomains:\n                local_size = len(ext_indices)\n                u_bnd_L = u_full[ext_indices[0]]\n                u_bnd_R = u_full[ext_indices[-1] + 2]\n                \n                def local_residual_func(u_local):\n                    u_local_full = np.concatenate(([u_bnd_L], u_local, [u_bnd_R]))\n                    u_faces_local = (u_local_full[:-1] + u_local_full[1:]) / 2.0\n                    x_faces_local = H * (ext_indices[0] + np.arange(local_size + 1) + 0.5)\n                    A_local = a_func(x_faces_local, u_faces_local, gamma)\n                    F_local = A_local * (u_local_full[1:] - u_local_full[:-1]) / H\n                    R_local = -(F_local[1:] - F_local[:-1]) / H - 1.0\n                    return R_local\n\n                u_local_initial = u[ext_indices]\n                sol = root(local_residual_func, u_local_initial, method='hybr', tol=TOL*1e-2)\n                \n                if not sol.success:\n                    return MAX_ITER\n\n                c_s = sol.x - u_local_initial\n                d[ext_indices] += weights[ext_indices] * c_s\n            \n            u += d\n            \n        return MAX_ITER\n\n    def solve_aspin(gamma, delta, ns):\n        \"\"\"Additive Schwarz Preconditioned Inexact Newton (ASPIN) solver.\"\"\"\n        u = np.zeros(N)\n        subdomains, weights = create_subdomains(ns, delta)\n        \n        for k in range(MAX_ITER):\n            R_k = compute_residual(u, gamma)\n            norm_R_k = np.linalg.norm(R_k)\n            if norm_R_k  TOL:\n                return k\n\n            p = np.zeros(N)\n            u_full = np.concatenate(([0.0], u, [0.0]))\n\n            for ext_indices in subdomains:\n                local_size = len(ext_indices)\n                u_local_full = np.concatenate(([u_full[ext_indices[0]]], u[ext_indices], [u_full[ext_indices[-1] + 2]]))\n                \n                # Local residual\n                u_faces_local = (u_local_full[:-1] + u_local_full[1:]) / 2.0\n                x_faces_local = H * (ext_indices[0] + np.arange(local_size + 1) + 0.5)\n                A_local = a_func(x_faces_local, u_faces_local, gamma)\n                F_local = A_local * (u_local_full[1:] - u_local_full[:-1]) / H\n                R_local = -(F_local[1:] - F_local[:-1]) / H - 1.0\n\n                # Local Jacobian\n                J_local = np.zeros((local_size, local_size))\n                a0_faces_local = a0_func(x_faces_local, gamma)\n                dAdu_term = ALPHA * a0_faces_local * u_faces_local\n                u_diffs = u_local_full[1:] - u_local_full[:-1]\n                \n                diag = (dAdu_term[1:-1] * u_diffs[1:-1] - A_local[1:-1]\n                       - dAdu_term[:-2] * u_diffs[:-2] - A_local[:-2]) / H**2\n                np.fill_diagonal(J_local, diag)\n\n                if local_size  1:\n                    sub_diag = (A_local[:-2] - dAdu_term[:-2] * u_diffs[:-2]) / H**2\n                    np.fill_diagonal(J_local[1:], sub_diag)\n                    \n                    sup_diag = (A_local[1:local_size] + dAdu_term[1:local_size] * u_diffs[1:local_size]) / H**2\n                    np.fill_diagonal(J_local[:, 1:], sup_diag)\n                \n                try:\n                    delta_s = np.linalg.solve(J_local, -R_local)\n                except np.linalg.LinAlgError:\n                    return MAX_ITER\n                \n                p[ext_indices] += weights[ext_indices] * delta_s\n\n            # Backtracking line search\n            alpha_ls = 1.0\n            found_step = False\n            for _ in range(10): \n                u_new = u + alpha_ls * p\n                norm_R_new = np.linalg.norm(compute_residual(u_new, gamma))\n                if norm_R_new  norm_R_k:\n                    u = u_new\n                    found_step = True\n                    break\n                alpha_ls /= 2.0\n            \n            if not found_step:\n                return MAX_ITER\n\n        return MAX_ITER\n\n    # --- Main execution loop ---\n    test_cases = [\n        (1.0, 0, 2),\n        (10.0, 0, 4),\n        (100.0, 0, 4),\n        (100.0, 4, 4),\n        (1000.0, 0, 4),\n        (1000.0, 4, 4),\n    ]\n\n    results = []\n    for gamma, delta, ns in test_cases:\n        it_nas = solve_nas(gamma, delta, ns)\n        it_aspin = solve_aspin(gamma, delta, ns)\n        results.append([it_nas, it_aspin])\n    \n    formatted_results = [f\"[{r[0]},{r[1]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3381001"}]}