{"hands_on_practices": [{"introduction": "谱方法的核心思想是用一系列正交多项式来逼近一个函数。这个实践练习将让你亲手计算一个具体函数（$e^x$）的切比雪夫谱系数，并评估截断级数近似的准确性。通过这个过程 [@problem_id:3370275]，你将掌握函数谱表示的基本技能，并直观地理解谱方法的“谱精度”特性。", "problem": "考虑在区间 $[-1,1]$ 上定义的第一类切比雪夫多项式 $T_n(x) = \\cos(n \\arccos x)$。对于一个足够光滑的函数 $f:[-1,1]\\to\\mathbb{R}$，其切比雪夫谱展开为级数\n$$\nf(x) \\sim \\frac{\\hat{f}_0}{2} + \\sum_{n=1}^{\\infty} \\hat{f}_n T_n(x),\n$$\n其中切比雪夫系数 $\\hat{f}_n$ 由 $\\cos(n\\theta)$ 在 $[0,\\pi]$ 上的正交性定义，并由以下积分表示给出\n$$\n\\hat{f}_n = \\frac{2}{\\pi}\\int_{0}^{\\pi} f(\\cos\\theta)\\,\\cos(n\\theta)\\,d\\theta, \\quad n\\ge 0,\n$$\n其中角度 $\\theta$ 以弧度为单位。在切比雪夫谱方法中，N阶截断展开\n$$\nf_N(x) := \\frac{\\hat{f}_0}{2} + \\sum_{n=1}^{N} \\hat{f}_n T_n(x),\n$$\n被用作 $f(x)$ 的一个高阶近似。\n\n要求您计算特定函数 $f(x)=e^x$ 的切比雪夫系数，构建截断级数 $f_{10}(x)$，并在指定场景下评估其相对于 $f(x)$ 的点态误差。您的推导和算法必须从上述基本定义出发，且仅使用经过充分检验的数学事实，而非快捷公式。\n\n角度单位说明：所有角度都必须以弧度处理。\n\n实现一个完整、可运行的程序，执行以下计算：\n\n1. 使用从第一性原理出发的最精确推导，计算函数 $f(x)=e^x$ 在 $n=0,1,\\dots,10$ 时的切比雪夫系数 $\\hat{f}_n$，构建 $f_{10}(x)$，并计算绝对点态误差 $|f(0.5)-f_{10}(0.5)|$。\n\n2. 使用复合梯形法则，在 $\\theta\\in[0,\\pi]$ 上使用 $M=16384$ 个等距面板（即 $M+1$ 个节点）对定义积分进行数值积分，从而近似计算函数 $f(x)=e^x$ 在 $n=0,1,\\dots,10$ 时的切比雪夫系数 $\\hat{f}_n$。使用这些近似系数构建 $f_{10}(x)$，并计算绝对点态误差 $|f(0.5)-f_{10}(0.5)|$。\n\n3. 使用第1项中的最精确系数，通过在 $[-1,1]$ 上的一个包含 $K=20001$ 个点的均匀网格上评估误差并取绝对值的最大值，来计算 $f_{10}(x)$ 在 $[-1,1]$ 上的上确界范数误差，定义为 $\\max_{x\\in[-1,1]} |f(x)-f_{10}(x)|$。\n\n测试套件和答案规范：\n- 测试用例1（正常路径）：如上文第1项所述，输出一个浮点数，其值为在 $x=0.5$ 处的绝对误差。\n- 测试用例2（数值积分覆盖）：如上文第2项所述，输出一个浮点数，其值为在 $x=0.5$ 处的绝对误差。\n- 测试用例3（通过密集网格上的上确界范数进行边界覆盖）：如上文第3项所述，输出一个浮点数，其值为计算出的最大绝对误差。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个测试用例的结果，格式为方括号内以逗号分隔的列表，顺序为 [测试用例1结果, 测试用例2结果, 测试用例3结果]。例如，\n$$\n[\\text{result1},\\text{result2},\\text{result3}]\n$$\n其中每个条目都是一个浮点数。", "solution": "问题陈述经验证具有科学依据、适定且客观。这是数值分析中一个关于切比雪夫谱方法应用的标准问题。该问题是自洽的，没有矛盾或歧义。\n\n该问题要求分析函数 $f(x) = e^x$ 在区间 $x \\in [-1, 1]$ 上的切比雪夫谱近似。N阶切比雪夫级数近似由下式给出\n$$\nf_N(x) = \\frac{\\hat{f}_0}{2} + \\sum_{n=1}^{N} \\hat{f}_n T_n(x)\n$$\n其中 $T_n(x)$ 是第一类切比雪夫多项式，$\\hat{f}_n$ 是切比雪夫系数。这些系数由以下积分定义\n$$\n\\hat{f}_n = \\frac{2}{\\pi}\\int_{0}^{\\pi} f(\\cos\\theta)\\,\\cos(n\\theta)\\,d\\theta, \\quad n \\ge 0.\n$$\n\n对于特定函数 $f(x) = e^x$，被积函数变为 $f(\\cos\\theta) = e^{\\cos\\theta}$。因此，系数的表达式为\n$$\n\\hat{f}_n = \\frac{2}{\\pi}\\int_{0}^{\\pi} e^{\\cos\\theta}\\cos(n\\theta)\\,d\\theta.\n$$\n该积分与第一类修正贝塞尔函数 $I_n(z)$ 的一个标准积分表示直接相关，对于整数阶 $n$，其表达式为\n$$\nI_n(z) = \\frac{1}{\\pi} \\int_0^\\pi e^{z \\cos\\theta} \\cos(n\\theta) d\\theta.\n$$\n通过设置 $z=1$，我们可以在 $e^x$ 的切比雪夫系数与修正贝塞尔函数的值之间建立直接关系。\n$$\n\\hat{f}_n = 2 \\left( \\frac{1}{\\pi} \\int_0^\\pi e^{1 \\cdot \\cos\\theta} \\cos(n\\theta) d\\theta \\right) = 2 I_n(1).\n$$\n这为测试用例1和3中所需的“精确”系数提供了一个解析表达式。这些值可以使用标准科学计算库计算到很高的精度。\n\n为了评估截断级数 $f_N(x)$，我们采用Clenshaw算法，这是一种对满足三项递推关系的多项式级数进行求和的稳定且高效的方法。切比雪夫多项式满足递推关系\n$$\nT_0(x) = 1, \\quad T_1(x) = x, \\quad T_{n+1}(x) = 2x T_n(x) - T_{n-1}(x) \\text{ for } n \\ge 1.\n$$\n设待评估的级数为 $S(x) = \\sum_{k=0}^{N} c'_k T_k(x)$，其中 $c'_0 = \\hat{f}_0/2 = I_0(1)$ 且对于 $k \\ge 1$，$c'_k = \\hat{f}_k = 2I_k(1)$。Clenshaw算法按以下步骤进行：\n初始化 $b_{N+2} = 0$ 和 $b_{N+1} = 0$。\n然后，对于 $k = N, N-1, \\dots, 1$，计算\n$$\nb_k = c'_k + 2x b_{k+1} - b_{k+2}.\n$$\n级数的值则由 $S(x) = c'_0 + x b_1 - b_2$ 给出。\n\n**测试用例1：使用解析推导系数的点态误差**\n对于 $n=0, 1, \\dots, 10$，切比雪夫系数 $\\hat{f}_n$ 使用恒等式 $\\hat{f}_n = 2 I_n(1)$ 计算。$I_n(1)$ 的数值从 `scipy.special.iv` 函数获得。这些系数用于构建Clenshaw系数数组 $c'$。然后使用Clenshaw算法在 $x=0.5$ 处评估多项式 $f_{10}(x)$。绝对误差计算为 $|e^{0.5} - f_{10}(0.5)|$。\n\n**测试用例2：使用数值积分系数的点态误差**\n对于 $n=0, 1, \\dots, 10$，通过对定义积分进行数值评估来近似切比雪夫系数 $\\hat{f}_n$。将复合梯形法则应用于积分 $\\int_{0}^{\\pi} e^{\\cos\\theta}\\cos(n\\theta)\\,d\\theta$，该积分在 $\\theta$ 值的均匀网格上进行。区间 $[0, \\pi]$ 被划分为 $M=16384$ 个面板，创建了 $M+1$ 个节点 $\\theta_j = j\\pi/M$（$j=0, \\dots, M$）。函数 $g(\\theta)$ 的积分 $I$ 可通过\n$$\nI \\approx h \\left( \\frac{g(\\theta_0) + g(\\theta_M)}{2} + \\sum_{j=1}^{M-1} g(\\theta_j) \\right),\n$$\n近似，其中 $h = \\pi/M$ 是步长。对于每个 $n$，使用相应的被积函数 $g_n(\\theta) = e^{\\cos\\theta}\\cos(n\\theta)$。然后，使用得到的近似系数 $\\hat{f}_n^{(\\text{num})}$ 构建一个新的多项式近似 $f_{10}^{(\\text{num})}(x)$。该多项式在 $x=0.5$ 处进行评估，并计算绝对误差 $|e^{0.5} - f_{10}^{(\\text{num})}(0.5)|$。\n\n**测试用例3：上确界范数误差**\n此测试用例要求计算误差的上确界范数的近似值，定义为 $\\max_{x\\in[-1,1]} |f(x)-f_{10}(x)|$。该近似值通过在跨越区间 $[-1, 1]$ 的一个包含 $K=20001$ 个点的密集均匀网格上评估误差来找到。多项式 $f_{10}(x)$ 使用测试用例1中解析推导的系数构建。使用Clenshaw算法的矢量化版本来高效地同时评估所有网格点 $x_j$ 上的 $f_{10}(x_j)$。对每个点计算绝对误差 $|e^{x_j} - f_{10}(x_j)|$，并将这些误差中的最大值作为结果报告。", "answer": "```python\nimport numpy as np\nfrom scipy.special import iv\n\ndef clenshaw_eval(x, c_prime):\n    \"\"\"\n    Evaluates a Chebyshev series using Clenshaw's algorithm.\n    Can handle both scalar and NumPy array inputs for x.\n    \n    Args:\n        x (float or np.ndarray): The point(s) at which to evaluate the series.\n        c_prime (np.ndarray): The coefficients of the series, where c_prime[k]\n                             is the coefficient of T_k(x). The series is\n                             assumed to be sum_{k=0 to N} c_prime[k] T_k(x).\n\n    Returns:\n        float or np.ndarray: The value(s) of the Chebyshev series.\n    \"\"\"\n    N = len(c_prime) - 1\n    if N  0:\n        return 0.0 if not isinstance(x, np.ndarray) else np.zeros_like(x)\n\n    # Ensure x is a NumPy array for vectorized operations\n    is_scalar = not isinstance(x, np.ndarray)\n    if is_scalar:\n        x_arr = np.array([x])\n    else:\n        x_arr = x\n\n    # Initialize b_{N+2} and b_{N+1}\n    b_k_plus_2 = np.zeros_like(x_arr)\n    b_k_plus_1 = np.zeros_like(x_arr)\n\n    # Recurrence loop\n    for k in range(N, 0, -1):\n        b_k = c_prime[k] + 2 * x_arr * b_k_plus_1 - b_k_plus_2\n        b_k_plus_2 = b_k_plus_1\n        b_k_plus_1 = b_k\n    \n    # Final value calculation\n    # val = c_prime[0] * T_0(x) + b_1 * T_1(x) - b_2 * T_0(x)\n    val = c_prime[0] + x_arr * b_k_plus_1 - b_k_plus_2\n    \n    return val.item() if is_scalar else val\n\ndef solve():\n    \"\"\"\n    Solves the three test cases as described in the problem statement.\n    \"\"\"\n    results = []\n    \n    # --- Parameters from the problem statement ---\n    N_degree = 10\n    M_panels = 16384\n    K_points = 20001\n    x_eval_point = 0.5\n\n    # --- Test Case 1: Pointwise error with analytically derived coefficients ---\n\n    # n = 0, 1, ..., N\n    n_values = np.arange(0, N_degree + 1)\n\n    # Exact coefficients f_hat_n = 2 * I_n(1)\n    f_hat_exact = 2 * iv(n_values, 1.0)\n    \n    # Create coefficients for Clenshaw's algorithm (c'_0 = f_hat_0 / 2)\n    c_prime_exact = np.copy(f_hat_exact)\n    c_prime_exact[0] /= 2.0\n    \n    # Evaluate at x = 0.5\n    f_val_exact_pt = np.exp(x_eval_point)\n    f10_val_exact_pt = clenshaw_eval(x_eval_point, c_prime_exact)\n    \n    error1 = np.abs(f_val_exact_pt - f10_val_exact_pt)\n    results.append(error1)\n\n    # --- Test Case 2: Pointwise error with numerically integrated coefficients ---\n    \n    theta = np.linspace(0, np.pi, M_panels + 1)\n    exp_cos_theta = np.exp(np.cos(theta))\n    \n    f_hat_num = np.zeros(N_degree + 1)\n    for n in n_values:\n        integrand = exp_cos_theta * np.cos(n * theta)\n        integral = np.trapz(integrand, theta)\n        f_hat_num[n] = (2.0 / np.pi) * integral\n    \n    # Create coefficients for Clenshaw's algorithm\n    c_prime_num = np.copy(f_hat_num)\n    c_prime_num[0] /= 2.0\n    \n    # Evaluate at x = 0.5\n    f10_val_num_pt = clenshaw_eval(x_eval_point, c_prime_num)\n    \n    error2 = np.abs(f_val_exact_pt - f10_val_num_pt)\n    results.append(error2)\n\n    # --- Test Case 3: Supremum norm error ---\n    \n    x_grid = np.linspace(-1.0, 1.0, K_points)\n    \n    # Use exact coefficients from Test Case 1\n    f10_on_grid = clenshaw_eval(x_grid, c_prime_exact)\n    f_on_grid = np.exp(x_grid)\n    \n    error3 = np.max(np.abs(f_on_grid - f10_on_grid))\n    results.append(error3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3370275"}, {"introduction": "谱方法在求解微分方程中的强大能力，很大程度上依赖于其高效计算导数的方式。这个练习将指导你从第一性原理出发，为切比雪夫和勒让德两种节点集构建谱微分矩阵。你将学会如何将抽象的微分运算转化为具体的矩阵向量乘法，这是实现谱配置法求解微分方程的关键一步 [@problem_id:3370324]。", "problem": "考虑在区间 $[-1,1]$ 上对一个光滑函数进行多项式谱微分。设 $N$ 表示多项式阶数， $N+1$ 个插值节点表示为 $\\{x_j\\}_{j=0}^{N}$。定义与这些节点相关的 Lagrange 基多项式 $\\{\\ell_j(x)\\}_{j=0}^{N}$，其满足条件 $\\ell_j(x_k)=\\delta_{jk}$，其中 $\\delta_{jk}$ 是 Kronecker delta。谱微分矩阵 $D\\in\\mathbb{R}^{(N+1)\\times(N+1)}$ 的定义是通过在节点处计算基多项式的导数得到的，因此插值多项式 $p(x)=\\sum_{j=0}^{N} u_j \\ell_j(x)$ 在节点处的导数值向量为 $Dp$，其中每个分量由 $\\sum_{j=0}^{N} u_j \\ell_j'(x_i)$ 构成。\n\n此构造的基础是多项式插值及其 Lagrange 形式的基本定义：任何一个阶数至多为 $N$ 且插值于数据 $\\{(x_j, u_j)\\}_{j=0}^{N}$ 的多项式，都可以唯一地表示为 $p(x)=\\sum_{j=0}^{N} u_j \\ell_j(x)$。根据微分的线性性质，其导数为 $p'(x)=\\sum_{j=0}^{N} u_j \\ell_j'(x)$。那么，在节点处的导数值由矩阵 $D$ 决定，其元素为 $D_{ij}=\\ell_j'(x_i)$。您必须直接根据这些原理构造 $D$，而不能对任何特殊的节点集使用预先制表的闭式公式。\n\n您将使用两种经典的谱网格：\n- 第一类 Chebyshev–Gauss–Lobatto 节点 (CGL)：$x_j=\\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j=0,1,\\dots,N$。\n- Legendre–Gauss–Lobatto 节点 (LGL)：$x_0=-1$，$x_N=1$，内部节点 $\\{x_j\\}_{j=1}^{N-1}$ 是 $N$ 阶 Legendre 多项式导数 $P_N'(x)=0$ 在 $(-1,1)$ 内的 $N-1$ 个不同根。使用 Legendre 微分方程设计一个 Newton 迭代法，以优化这些内部根的初始猜测值。Legendre 微分方程为 $(1-x^2)P_N''(x)-2xP_N'(x)+N(N+1)P_N(x)=0$。您必须使用此关系来获得一个不依赖于预先制表的根公式的 Newton 更新。\n\n对于目标函数 $u(x)=\\sin(5x)$（角度以弧度为单位），通过将谱微分矩阵 $D$ 应用于 $u(x)$ 的节点值，来近似 $u'(x)$ 在节点处的值，并将此近似值与在相同节点处的精确导数 $u'(x)=5\\cos(5x)$ 进行比较。对于每种情况，计算 $\\ell^\\infty$ 误差，定义为\n$$\nE_{\\infty}=\\max_{0\\le i\\le N} \\left| (Du)_i - u'(x_i) \\right|.\n$$\n\n您的程序必须从第一性原理出发，通过计算节点上的 Lagrange 基导数来构造 $D$（允许使用通用的重心 Lagrange 机制，但不得使用任何针对特定节点族的显式闭式微分矩阵）。对于 Legendre–Gauss–Lobatto 节点，使用 Chebyshev–Gauss–Lobatto 节点初始化内部根的 Newton 迭代，并利用 Legendre 微分方程推导 Newton 更新。\n\n使用以下测试套件，它改变了节点族和阶数：\n1. 使用 $N=8$ 的 CGL。\n2. 使用 $N=32$ 的 CGL。\n3. 使用 $N=64$ 的 CGL。\n4. 使用 $N=8$ 的 LGL。\n5. 使用 $N=32$ 的 LGL。\n6. 使用 $N=64$ 的 LGL。\n\n对于每个测试用例，输出必须是单个浮点数 $E_{\\infty}$。您的程序应生成单行输出，其中包含六个结果，格式为用方括号括起来的逗号分隔列表（例如，“[e1,e2,e3,e4,e5,e6]”）。不应打印任何其他文本。所有角度均以弧度为单位。不适用任何物理单位。", "solution": "该问题要求为 Chebyshev 和 Legendre 网格构建谱微分矩阵，并应用它们来近似给定函数的导数。该构造必须从第一性原理出发，而不借助于已知的微分矩阵本身的闭式表达式。问题的核心在于正确实现节点生成算法，特别是 Legendre–Gauss–Lobatto 节点的生成算法，以及随后使用 Lagrange 插值的一般性质来构建微分矩阵。\n\n### 1. 谱微分矩阵的一般公式\n\n给定区间 $[-1, 1]$ 上的一组 $N+1$ 个不同的插值节点 $\\{x_j\\}_{j=0}^{N}$，任何一个阶数至多为 $N$ 的多项式 $p(x)$ 都可以使用 Lagrange 基多项式 $\\{\\ell_j(x)\\}_{j=0}^{N}$ 唯一地表示为：\n$$\np(x) = \\sum_{j=0}^{N} u_j \\ell_j(x)\n$$\n其中 $u_j = p(x_j)$ 是函数在节点处的值，基多项式满足性质 $\\ell_j(x_k) = \\delta_{jk}$。该多项式的导数由基多项式导数的线性组合给出：\n$$\np'(x) = \\sum_{j=0}^{N} u_j \\ell_j'(x)\n$$\n在插值节点 $x_i$ 处计算该导数可得：\n$$\np'(x_i) = \\sum_{j=0}^{N} u_j \\ell_j'(x_i)\n$$\n这种关系可以表示为矩阵向量乘积 $\\boldsymbol{u}' = D\\boldsymbol{u}$，其中 $\\boldsymbol{u}$ 是节点值的向量 $[u_0, u_1, \\dots, u_N]^T$，$\\boldsymbol{u}'$ 是节点处导数值的向量 $[p'(x_0), \\dots, p'(x_N)]^T$，而 $D$ 是谱微分矩阵。该矩阵的元素由下式给出：\n$$\nD_{ij} = \\ell_j'(x_i)\n$$\n问题禁止对特定节点族使用预先计算的 $D_{ij}$ 公式，但允许使用通用的重心插值机制。Lagrange 基多项式定义为 $\\ell_j(x) = \\prod_{k=0, k \\neq j}^{N} \\frac{x-x_k}{x_j-x_k}$。一种计算其在节点处导数的通用且稳定的方法涉及重心权重。\n\n每个节点 $x_j$ 的重心权重 $w_j$ 由第一性原理定义为：\n$$\nw_j = \\frac{1}{\\prod_{k=0, k \\neq j}^{N} (x_j - x_k)}\n$$\n使用这些权重，微分矩阵的元素可以表示为：\n$$\nD_{ij} = \\frac{w_j/w_i}{x_i - x_j} \\quad \\text{对于 } i \\neq j\n$$\n对于对角线元素 $D_{ii}$，可以使用公式 $D_{ii} = \\sum_{k=0, k \\neq i}^{N} \\frac{1}{x_i-x_k}$。然而，一种数值上更稳健的方法是利用常数函数的导数必须为零的性质。常数函数 $f(x)=1$ 可以被 $p(x)=1$ 精确插值，这对应于一个节点值向量 $\\boldsymbol{u} = [1, 1, \\dots, 1]^T$。其导数处处为零，这意味着 $D\\boldsymbol{1} = \\boldsymbol{0}$。这意味着微分矩阵的每一行之和必须为零：\n$$\n\\sum_{j=0}^{N} D_{ij} = 0 \\quad \\text{对于每个 } i = 0, \\dots, N\n$$\n根据此性质，我们可以将对角线元素计算为同一行中非对角线元素的和的负数：\n$$\nD_{ii} = - \\sum_{j=0, j \\neq i}^{N} D_{ij}\n$$\n这组公式提供了一个为任何一组不同节点构造 $D$ 的通用算法。\n\n### 2. 节点生成与矩阵构造\n\n我们将把这个通用过程应用于两组特定的节点。\n\n#### 2.1. Chebyshev–Gauss–Lobatto (CGL) 节点\nCGL 节点是第一类 Chebyshev 多项式 $T_N(x)$ 的极值点。它们由显式公式给出：\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N}\\right) \\quad \\text{对于 } j=0, 1, \\dots, N\n$$\n对于给定的阶数 $N$，我们首先生成这 $N+1$ 个节点。然后，我们使用基本乘积定义计算每个节点的重心权重 $w_j$。最后，我们使用通用的重心公式来构造 CGL 微分矩阵 $D^{\\text{CGL}}$。\n\n#### 2.2. Legendre–Gauss–Lobatto (LGL) 节点\nLGL 节点包括区间的端点 $x_0 = -1$ 和 $x_N = 1$。$N-1$ 个内部节点 $\\{x_j\\}_{j=1}^{N-1}$ 是 $P_N'(x)$ 的根，其中 $P_N(x)$ 是 $N$ 阶 Legendre 多项式。\n\n问题要求通过 Newton 法找到这些根，初始猜测值由内部 CGL 节点提供。用于寻找函数 $f(x)$ 根的 Newton 迭代法是 $x_{k+1} = x_k - f(x_k)/f'(x_k)$。在我们的例子中，$f(x) = P_N'(x)$，因此迭代为：\n$$\nx_{k+1} = x_k - \\frac{P_N'(x_k)}{P_N''(x_k)}\n$$\n我们必须使用 Legendre 微分方程推导更新项的表达式：\n$$\n(1-x^2)P_N''(x) - 2xP_N'(x) + N(N+1)P_N(x) = 0\n$$\n解出 $P_N''(x)$ 可得：\n$$\nP_N''(x) = \\frac{2xP_N'(x) - N(N+1)P_N(x)}{1-x^2}\n$$\n将此代入 Newton 迭代中，得到更新步骤：\n$$\nx_{k+1} = x_k - \\frac{P_N'(x_k)}{\\frac{2x_k P_N'(x_k) - N(N+1)P_N(x_k)}{1-x_k^2}} = x_k - \\frac{(1-x_k^2)P_N'(x_k)}{2x_k P_N'(x_k) - N(N+1)P_N(x_k)}\n$$\n为了实现此迭代，我们需要计算 $P_N(x)$ 和 $P_N'(x)$。Legendre 多项式 $P_k(x)$ 的值可以使用三项递推关系或标准库函数来计算。其导数 $P_N'(x)$ 可以通过恒等式高效地找到：\n$$\n(1-x^2)P_N'(x) = N(P_{N-1}(x) - xP_N(x))\n$$\n生成 LGL 节点的步骤如下：\n1. 设置端点 $x_0 = -1$ 和 $x_N = 1$。\n2. 对于内部节点，取初始猜测值 $x_j^{(0)} = \\cos(\\frac{\\pi j}{N})$，其中 $j=1, \\dots, N-1$。\n3. 对于每个猜测值，使用推导出的 Newton 更新公式进行迭代，直到根收敛到所需的容差。这需要在每一步计算 $P_N(x)$ 和 $P_{N-1}(x)$。\n4. 收集端点和收敛的内部根，形成 LGL 节点集 $\\{x_j\\}_{j=0}^{N}$。\n5. 在确定节点后，使用与 CGL 情况相同的通用重心方法构造 LGL 微分矩阵 $D^{\\text{LGL}}$。\n\n### 3. 误差计算\n\n对于每个测试用例（一个节点族和一个阶数 $N$）：\n1.  生成相应的节点集 $\\{x_j\\}$。\n2.  构造相应的微分矩阵 $D$。\n3.  在节点处计算目标函数 $u(x) = \\sin(5x)$ 的值，形成向量 $\\boldsymbol{u}$。\n4.  通过矩阵向量乘积 $\\boldsymbol{u}'_{approx} = D\\boldsymbol{u}$ 计算节点处导数的数值近似。\n5.  在节点处计算精确导数 $u'(x) = 5\\cos(5x)$ 的值，形成向量 $\\boldsymbol{u}'_{exact}$。\n6.  计算 $\\ell^\\infty$ 误差，即近似导数值与精确导数值之间绝对差的最大值：\n    $$\n    E_{\\infty} = \\max_{0\\le i\\le N} \\left| (\\boldsymbol{u}'_{approx})_i - (\\boldsymbol{u}'_{exact})_i \\right|\n    $$\n对所有指定的测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import eval_legendre\n\ndef get_cgl_nodes(N):\n    \"\"\"Generates Chebyshev-Gauss-Lobatto nodes.\"\"\"\n    if N == 0:\n        return np.array([0.0])\n    j = np.arange(N + 1)\n    nodes = np.cos(np.pi * j / N)\n    return nodes\n\ndef get_lgl_nodes(N, tol=1e-15, max_iter=100):\n    \"\"\"\n    Generates Legendre-Gauss-Lobatto nodes.\n    The interior nodes are the roots of P_N'(x), found via Newton's method.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0])\n    if N == 1:\n        return np.array([-1.0, 1.0])\n    \n    nodes = np.zeros(N + 1)\n    nodes[0] = -1.0\n    nodes[N] = 1.0\n    \n    # Initial guesses for interior roots are interior CGL nodes\n    j_int = np.arange(1, N)\n    guesses = np.cos(np.pi * j_int / N)\n    \n    for i in range(len(guesses)):\n        x_k = guesses[i]\n        \n        for _ in range(max_iter):\n            # The formulas are valid for x in (-1, 1).\n            # Newton iteration may push x_k slightly outside, clip it.\n            if abs(x_k) > 1.0:\n                x_k = np.sign(x_k)\n\n            # Evaluate Legendre polynomials P_N(x) and P_{N-1}(x)\n            PN_val = eval_legendre(N, x_k)\n            PN_minus_1_val = eval_legendre(N - 1, x_k)\n            \n            # Derivative P_N'(x) using relation (1-x^2)P_N'(x) = N(P_{N-1}(x) - xP_N(x))\n            dPN_val = N * (PN_minus_1_val - x_k * PN_val) / (1 - x_k**2)\n\n            # Newton update for a root of P_N'(x), derived from Legendre DE.\n            # update = (1-x^2)P_N'(x) / (2xP_N'(x) - N(N+1)P_N(x))\n            numerator = (1 - x_k**2) * dPN_val\n            denominator = 2 * x_k * dPN_val - N * (N + 1) * PN_val\n            \n            if abs(denominator)  1e-14:\n                # This may happen if the guess is already a root of the denominator.\n                # In such cases, the iteration is stuck; we just break.\n                break\n                \n            update = numerator / denominator\n            x_k -= update\n            \n            if abs(update)  tol:\n                break\n        \n        nodes[i + 1] = x_k\n        \n    nodes.sort() # Ensure nodes are in descending order (or ascending)\n    return nodes\n\ndef build_diff_matrix(nodes):\n    \"\"\"\n    Constructs the spectral differentiation matrix from first principles\n    using the barycentric formulation for any set of nodes.\n    \"\"\"\n    N = len(nodes) - 1\n    if N == 0:\n        return np.array([[0.0]])\n        \n    D = np.zeros((N + 1, N + 1))\n    \n    # Calculate barycentric weights from their fundamental definition\n    weights = np.zeros(N + 1)\n    for j in range(N + 1):\n        # Create an array of differences (x_j - x_k) for k != j\n        diffs = nodes[j] - np.delete(nodes, j)\n        weights[j] = 1.0 / np.prod(diffs)\n\n    # Off-diagonal entries using D_ij = (w_j/w_i) / (x_i - x_j)\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = (weights[j] / weights[i]) / (nodes[i] - nodes[j])\n    \n    # Diagonal entries using the row-sum property: D_ii = -sum(D_ij) for j != i\n    for i in range(N + 1):\n        D[i, i] = -np.sum(D[i, :])\n        \n    return D\n\ndef compute_error(node_type, N):\n    \"\"\"\n    Main logic to compute the l-infinity error for a given case.\n    \"\"\"\n    if node_type == 'cgl':\n        nodes = get_cgl_nodes(N)\n    elif node_type == 'lgl':\n        nodes = get_lgl_nodes(N)\n    else:\n        raise ValueError(\"Unknown node type\")\n\n    D = build_diff_matrix(nodes)\n    \n    # Target function u(x) and its exact derivative u'(x)\n    u_func = lambda x: np.sin(5 * x)\n    du_exact_func = lambda x: 5 * np.cos(5 * x)\n    \n    # Evaluate at the nodes\n    u_vals = u_func(nodes)\n    du_exact_vals = du_exact_func(nodes)\n    \n    # Approximate derivative using the differentiation matrix\n    du_approx_vals = D @ u_vals\n    \n    # Compute the L-infinity error\n    error = np.max(np.abs(du_approx_vals - du_exact_vals))\n    return error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('cgl', 8),\n        ('cgl', 32),\n        ('cgl', 64),\n        ('lgl', 8),\n        ('lgl', 32),\n        ('lgl', 64),\n    ]\n\n    results = []\n    for case in test_cases:\n        node_type, N = case\n        error = compute_error(node_type, N)\n        results.append(f\"{error:.15e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3370324"}, {"introduction": "在用谱方法求解非线性方程时，一个关键的挑战是如何处理函数乘积项。在网格点上直接相乘再转换回谱空间（即配置法）会引入一种称为“混叠”的误差，高频信息会“伪装”成低频信号。这个练习通过一个经典的例子 $u(x)^2$ [@problem_id:3370334] 让你定量地分析这种混叠误差，从而深刻理解其产生的原因及其对计算结果的影响。", "problem": "考虑第一类切比雪夫多项式，其定义为 $T_n(x) = \\cos(n \\arccos x)$，其中 $x \\in [-1,1]$。设带权内积定义为 $\\langle f, g \\rangle_w = \\int_{-1}^{1} f(x) g(x) w(x) \\, dx$，其权函数为 $w(x) = (1 - x^2)^{-1/2}$。对于在此权函数下具有有限能量的 $[-1,1]$ 上的任意函数 $f$，其切比雪夫模态系数 $\\{a_k\\}_{k \\ge 0}$ 由正交关系定义：$a_0 = \\frac{1}{\\pi} \\int_{-1}^{1} f(x) w(x) \\, dx$，且对于 $k \\ge 1$，$a_k = \\frac{2}{\\pi} \\int_{-1}^{1} f(x) T_k(x) w(x) \\, dx$，因此在 $L^2_w([-1,1])$ 意义下 $f(x) = \\sum_{k=0}^{\\infty} a_k T_k(x)$。$f$ 的 $N$ 阶模态投影是截断 $P_N f(x) = \\sum_{k=0}^{N} a_k T_k(x)$。\n\n定义由 $N+1$ 个节点组成的切比雪夫-洛巴托配置网格，节点为 $x_j = \\cos(\\theta_j)$，其中 $\\theta_j = \\pi j / N$，对于 $j = 0,1,\\dots,N$（对于 $N=0$，将其解释为单个节点 $x_0 = 1$）。给定函数 $v$，其 $N$ 次切比雪夫配置插值多项式 $I_N v$ 是满足 $I_N v(x_j) = v(x_j)$（对于所有网格节点）的次数最多为 $N$ 的唯一多项式。如果 $v$ 是一个次数大于 $N$ 的多项式，与模态投影 $P_N v$ 相比，插值多项式 $I_N v$ 会在模态空间中产生混叠误差。\n\n构建一个数值示例，其中 $u(x) = T_N(x)$，非线性乘积为 $f(x) = u(x)^2$。通过构建节点采样 $f_j = f(x_j)$ 并通过方形线性系统 $\\sum_{k=0}^{N} \\hat{a}_k T_k(x_j) = f_j$（对于 $j=0,1,\\dots,N$）求解切比雪夫基中的插值系数 $\\{ \\hat{a}_k \\}_{k=0}^{N}$，来评估配置乘积。同时，仅使用第一性原理（$T_n$ 的定义性质、内积和三角恒等式）来确定 $f$ 的精确 $N$ 阶模态投影系数 $\\{ a_k \\}_{k=0}^{N}$。将模态 $k$ 的混叠误差定义为 $e_k = \\hat{a}_k - a_k$（对于 $k=0,1,\\dots,N$），并将模态误差 $2$-范数定义为 $\\|e\\|_2 = \\left( \\sum_{k=0}^{N} e_k^2 \\right)^{1/2}$。\n\n您的程序必须以数值方式实现此过程，并为每个测试用例报告两个量：第零个模态系数的绝对误差 $|e_0|$ 和模态误差 $2$-范数 $\\|e\\|_2$。此问题中没有物理单位。所有角度都隐式使用弧度。测试集是多项式次数 $N \\in \\{0, 1, 7, 16, 31\\}$ 的集合。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个包含五个项目的列表，每个项目都是对应于上述指定顺序的 $N$ 值的 2-元素列表 $[|e_0|, \\|e\\|_2]$。该行必须是这些 2-元素列表的单个带方括号的逗号分隔列表，不得包含任何额外文本。例如，语法上有效的输出形式为 $[[a,b],[c,d],[\\dots],\\dots]$，其中每个符号代表一个实数。", "solution": "## 问题验证\n\n### 第1步：提取已知条件\n- **切比雪夫多项式**：$T_n(x) = \\cos(n \\arccos x)$，其中 $x \\in [-1,1]$。\n- **带权内积**：$\\langle f, g \\rangle_w = \\int_{-1}^{1} f(x) g(x) w(x) \\, dx$，权函数为 $w(x) = (1 - x^2)^{-1/2}$。\n- **切比雪夫模态系数**：对于函数 $f(x) = \\sum_{k=0}^{\\infty} a_k T_k(x)$：\n  - $a_0 = \\frac{1}{\\pi} \\int_{-1}^{1} f(x) w(x) \\, dx$\n  - 对于 $k \\ge 1$，$a_k = \\frac{2}{\\pi} \\int_{-1}^{1} f(x) T_k(x) w(x) \\, dx$。\n- **N阶模态投影**：$P_N f(x) = \\sum_{k=0}^{N} a_k T_k(x)$。\n- **切比雪夫-洛巴托配置网格**：$x_j = \\cos(\\theta_j)$，其中 $\\theta_j = \\pi j / N$，对于 $j = 0,1,\\dots,N$。对于 $N=0$，网格是单个节点 $x_0 = 1$。\n- **配置插值**：$I_N v$ 是次数最多为 $N$ 的唯一多项式，满足对所有节点 $x_j$ 都有 $I_N v(x_j) = v(x_j)$。\n- **问题设置**：\n  - 基函数：$u(x) = T_N(x)$。\n  - 非线性乘积：$f(x) = u(x)^2 = T_N(x)^2$。\n- **任务**：\n  1. 确定 $f(x)$ 的精确 $N$ 阶模态投影系数 $\\{a_k\\}_{k=0}^{N}$。\n  2. 通过在节点 $x_j$ 上计算 $f(x)$ 得到 $f_j=f(x_j)$，并求解线性系统 $\\sum_{k=0}^{N} \\hat{a}_k T_k(x_j) = f_j$（对于 $j=0,1,\\dots,N$）来确定配置插值系数 $\\{\\hat{a}_k\\}_{k=0}^{N}$。\n  3. 定义混叠误差：$e_k = \\hat{a}_k - a_k$（对于 $k=0,1,\\dots,N$）。\n  4. 定义模态误差2-范数：$\\|e\\|_2 = \\left( \\sum_{k=0}^{N} e_k^2 \\right)^{1/2}$。\n  5. 报告第零个模态系数的绝对误差 $|e_0|$ 和模态误差2-范数 $\\|e\\|_2$。\n- **测试用例**：$N \\in \\{0, 1, 7, 16, 31\\}$。\n- **输出格式**：包含五个 2-元素列表 $[|e_0|, \\|e\\|_2]$ 的单行列表，对应于测试用例。\n\n### 第2步：使用提取的已知条件进行验证\n该问题是数值分析领域的标准练习，具体涉及用于求解偏微分方程的谱方法。问题的核心是分析使用配置方法计算非线性项时的混叠误差。\n\n- **科学依据**：该问题完全基于成熟的切比雪夫多项式和多项式插值数学理论。所有定义和性质都是标准的、事实正确的。\n- **良态性**：问题定义明确。函数 $f(x)$ 已指定，寻找精确投影系数 ($a_k$) 和插值系数 ($\\hat{a}_k$) 的过程是无歧义的，并且所需的输出有精确定义。存在唯一、稳定且有意义的解。\n- **客观性**：语言是精确和数学化的，不含任何主观性或观点。\n- **无缺陷**：该问题不违反任何无效标准。它是自洽的、一致的，并且可以使用数值分析和线性代数的方法求解。\n\n### 第3步：结论与行动\n此问题有效。将提供完整解答。\n\n## 解答\n该问题要求我们分析在使用切比雪夫-洛巴托网格上的配置方法计算切比雪夫多项式的平方 $f(x) = T_N(x)^2$ 时发生的混叠误差。我们将首先确定 $f(x)$ 投影的精确模态系数，然后是 $f(x)$ 插值多项式的系数，最后计算它们之间的误差。\n\n**1. 精确模态投影系数 ($a_k$)**\n\n函数为 $f(x) = T_N(x)^2$。根据定义，$T_N(x) = \\cos(N \\arccos x)$。令 $x = \\cos(\\theta)$，则 $\\theta = \\arccos(x)$。\n函数变为 $f(x) = (\\cos(N\\theta))^2$。使用三角降幂恒等式 $\\cos^2(\\alpha) = \\frac{1}{2}(1 + \\cos(2\\alpha))$，我们得到：\n$$ f(x) = \\frac{1}{2}(1 + \\cos(2N\\theta)) $$\n将 $\\theta = \\arccos(x)$ 代回：\n$$ f(x) = \\frac{1}{2}(1 + \\cos(2N \\arccos x)) $$\n识别出定义 $T_0(x) = 1$ 和 $T_{2N}(x) = \\cos(2N \\arccos x)$，我们得到 $f(x)$ 的精确切比雪夫级数展开：\n$$ f(x) = \\frac{1}{2} T_0(x) + \\frac{1}{2} T_{2N}(x) $$\n模态投影 $P_N f(x)$ 是此级数截断到 $N$ 次的结果：$P_N f(x) = \\sum_{k=0}^{N} a_k T_k(x)$。我们考虑 $N$ 的两种情况。\n\n情况 $N > 0$：\n$T_{2N}(x)$ 项的次数为 $2N$，大于 $N$。因此，它不属于 $N$ 阶模态投影的一部分。投影为：\n$$ P_N f(x) = \\frac{1}{2} T_0(x) $$\n通过比较系数，精确的投影系数为：\n$$ a_0 = \\frac{1}{2}, \\quad a_k = 0 \\quad \\text{对于 } k = 1, 2, \\dots, N $$\n\n情况 $N = 0$：\n函数为 $f(x) = T_0(x)^2 = 1^2 = 1$。在切比雪夫基中，这即是 $f(x) = T_0(x)$。投影 $P_0 f(x)$ 为 $a_0 T_0(x)$。因此，通过直接比较：\n$$ a_0 = 1 $$\n\n**2. 配置插值系数 ($\\hat{a}_k$)**\n\n配置插值多项式 $I_N f(x) = \\sum_{k=0}^{N} \\hat{a}_k T_k(x)$ 是在切比雪夫-洛巴托节点 $x_j = \\cos(\\frac{\\pi j}{N})$（其中 $j=0, \\dots, N$）上与 $f(x)$ 匹配的次数最多为 $N$ 的唯一多项式。\n我们计算 $f(x)$ 在这些节点上的值：\n$$ f(x_j) = T_N(x_j)^2 = \\left( T_N\\left(\\cos\\left(\\frac{\\pi j}{N}\\right)\\right) \\right)^2 $$\n使用 $T_N(x)$ 的定义：\n$$ T_N\\left(\\cos\\left(\\frac{\\pi j}{N}\\right)\\right) = \\cos\\left(N \\arccos\\left(\\cos\\left(\\frac{\\pi j}{N}\\right)\\right)\\right) = \\cos\\left(N \\frac{\\pi j}{N}\\right) = \\cos(\\pi j) = (-1)^j $$\n因此，在节点上的函数值为：\n$$ f_j = f(x_j) = ((-1)^j)^2 = 1 \\quad \\text{对于所有 } j = 0, 1, \\dots, N $$\n插值多项式 $I_N f(x)$ 必须是一个次数最多为 $N$ 的多项式，在所有 $N+1$ 个不同的节点上取值为 $1$。唯一满足此条件的多项式是常数函数 $p(x) = 1$。在切比雪夫基中，这就是 $T_0(x)$。\n所以，对于任何 $N \\ge 0$：\n$$ I_N f(x) = 1 = T_0(x) $$\n通过将 $I_N f(x) = \\sum_{k=0}^{N} \\hat{a}_k T_k(x)$ 与 $T_0(x)$ 比较，我们根据唯一性找到插值系数：\n$$ \\hat{a}_0 = 1, \\quad \\hat{a}_k = 0 \\quad \\text{对于 } k = 1, 2, \\dots, N $$\n这展示了混叠现象：高频分量 $T_{2N}(x)$ 在网格上与 $T_0(x)$ 不可区分（因为 $T_{2N}(x_j) = \\cos(2\\pi j) = 1 = T_0(x_j)$），其能量完全混叠到了零阶模态上。\n\n**3. 混叠误差和范数**\n\n混叠误差为 $e_k = \\hat{a}_k - a_k$。\n\n情况 $N > 0$：\n$e_0 = \\hat{a}_0 - a_0 = 1 - \\frac{1}{2} = \\frac{1}{2}$\n$e_k = \\hat{a}_k - a_k = 0 - 0 = 0$ 对于 $k = 1, \\dots, N$。\n所需的度量指标是：\n- 第零个系数的绝对误差：$|e_0| = \\frac{1}{2}$。\n- 模态误差2-范数：$\\|e\\|_2 = \\left( \\sum_{k=0}^{N} e_k^2 \\right)^{1/2} = \\sqrt{e_0^2 + \\sum_{k=1}^{N} e_k^2} = \\sqrt{\\left(\\frac{1}{2}\\right)^2 + 0} = \\frac{1}{2}$。\n\n情况 $N = 0$：\n$e_0 = \\hat{a}_0 - a_0 = 1 - 1 = 0$。\n所需的度量指标是：\n- 第零个系数的绝对误差：$|e_0| = 0$。\n- 模态误差2-范数：$\\|e\\|_2 = \\sqrt{e_0^2} = 0$。\n\n**测试用例总结**\n对于测试集 $N \\in \\{0, 1, 7, 16, 31\\}$：\n- 对于 $N=0$：结果为 $[0.0, 0.0]$。\n- 对于 $N \\in \\{1, 7, 16, 31\\}$：结果为 $[0.5, 0.5]$。\n\n数值实现将构造并求解关于 $\\hat{a}_k$ 的线性系统，以验证这些解析结果。该系统为 $M \\mathbf{\\hat{a}} = \\mathbf{f}$，其中 $M_{jk} = T_k(x_j) = \\cos(k \\pi j / N)$ 且 $f_j = 1$。数值解应在机器精度范围内得出 $\\mathbf{\\hat{a}} \\approx [1, 0, \\dots, 0]^T$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the aliasing error for the collocation product of T_N(x)^2.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [0, 1, 7, 16, 31]\n\n    results = []\n    for N in test_cases:\n        # The problem asks to set up and solve the linear system numerically.\n        # This implementation follows that prescription.\n\n        # Handle the N=0 case separately to avoid division by zero.\n        if N == 0:\n            # Analytical result for N=0:\n            # f(x) = T_0(x)^2 = 1^2 = 1 = T_0(x).\n            # The projection is P_0 f(x) = T_0(x), so a_0 = 1.\n            # The grid is x_0=1, f(x_0)=1. The interpolant is I_0 f(x) = 1 = T_0(x), so a_hat_0 = 1.\n            # The error e_0 = a_hat_0 - a_0 = 1 - 1 = 0.\n            results.append([0.0, 0.0])\n            continue\n\n        # For N  0:\n\n        # 1. Determine the exact N-mode modal projection coefficients, {a_k}.\n        # f(x) = T_N(x)^2 = 0.5 * T_0(x) + 0.5 * T_2N(x).\n        # The N-mode projection P_N f(x) truncates modes  N. Since N  0, 2N  N.\n        # P_N f(x) = 0.5 * T_0(x).\n        # So, a_0 = 0.5 and a_k = 0 for k  0.\n        a_k_exact = np.zeros(N + 1)\n        a_k_exact[0] = 0.5\n\n        # 2. Determine the collocation interpolant coefficients, {a_hat_k}.\n        # Define the Chebyshev-Lobatto grid nodes.\n        j_indices = np.arange(N + 1)\n        x_j = np.cos(np.pi * j_indices / N)\n\n        # Evaluate the function f(x) = T_N(x)^2 at the nodes.\n        # Analytically, f(x_j) = T_N(cos(pi*j/N))^2 = (cos(pi*j))^2 = 1 for all j.\n        # We compute this numerically as requested by the problem structure.\n        # Note: np.arccos(x_j) will numerically recover pi*j/N.\n        u_vals_at_nodes = np.cos(N * np.arccos(x_j))\n        f_vals_at_nodes = u_vals_at_nodes**2\n        # Due to floating point arithmetic, f_vals_at_nodes will be very close to 1.0.\n        # Using the exact analytical result f_j=1 is cleaner and avoids floating point noise\n        # in the RHS vector, which is consistent with the problem's analytical nature.\n        f_j = np.ones(N + 1)\n\n        # Construct the square linear system: sum_{k=0 to N} a_hat_k * T_k(x_j) = f_j\n        # The matrix M has entries M_jk = T_k(x_j).\n        k_indices = np.arange(N + 1)\n        # M_jk = cos(k * arccos(x_j)) = cos(k * pi*j/N)\n        M = np.cos(np.pi * np.outer(j_indices, k_indices) / N)\n\n        # Solve the system M * a_hat = f for the coefficients a_hat.\n        a_hat_k = np.linalg.solve(M, f_j)\n\n        # 3. Compute the aliasing error e_k = a_hat_k - a_k_exact.\n        e_k = a_hat_k - a_k_exact\n\n        # 4. Calculate the required metrics.\n        abs_error_mode_0 = np.abs(e_k[0])\n        modal_error_2_norm = np.linalg.norm(e_k)\n\n        results.append([abs_error_mode_0, modal_error_2_norm])\n    \n    # helper to format the output string correctly\n    def format_list(item):\n        return f\"[{item[0]},{item[1]}]\"\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(format_list, results))}]\")\n\nsolve()\n```", "id": "3370334"}]}