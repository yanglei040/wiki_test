{"hands_on_practices": [{"introduction": "理查德森外推法的核心思想是通过组合不同步长下的数值解来消除低阶误差项，从而提升精度。本练习将带你从最基本的误差模型出发，为一阶精度的后向欧拉格式推导出一种能达到二阶精度的外推估计。更重要的是，我们将证明这种精度增强技术并不会牺牲原始格式优良的无条件稳定性，这在求解刚性问题时至关重要。[@problem_id:3440894]", "problem": "考虑一个线性耗散半离散演化系统，该系统由方法线法应用于线性抛物型偏微分方程 (PDE) 产生，写作 $U^{\\prime}(t)=A\\,U(t)+G(t)$，其中 $A$ 是一个时间无关矩阵，其谱包含在闭合左半平面内，$G(t)$ 是一个足够光滑的强迫项。设 $u(t)$ 表示该常微分方程 (ODE) 初值问题在时间 $t$ 的精确解，而 $U_{\\Delta t}(t^{n+1})$ 表示从时间 $t^{n}$ 到 $t^{n+1}=t^{n}+\\Delta t$、步长为 $\\Delta t$ 的单步向后欧拉法产生的全离散近似解。同样地，设 $U_{\\Delta t/2}(t^{n+1})$ 表示从 $t^{n}$ 到 $t^{n+1}$、连续两步步长为 $\\Delta t/2$ 的向后欧拉法的结果。假设在时间 $t^{n+1}$，向后欧拉法的全局误差模型具有渐近展开式 $U_{\\Delta t}(t^{n+1})=u(t^{n+1})+C(t^{n+1})\\,\\Delta t+O\\!\\left((\\Delta t)^{2}\\right)$，其中系数 $C(t)$ 有界且与 $\\Delta t$ 无关。\n\n仅使用上述信息，在时间 $t^{n+1}$ 构造一个外推估计，其形式为线性组合 $\\widehat{U}(t^{n+1})=a\\,U_{\\Delta t/2}(t^{n+1})+b\\,U_{\\Delta t}(t^{n+1})$，使其时间上的截断误差为 $O\\!\\left((\\Delta t)^{2}\\right)$。你的构造必须从给定的误差模型出发，在消除 $O(\\Delta t)$ 项的同时，确保与 $u(t^{n+1})$ 的相容性。然后，从基本原理出发，论证为何此外推估计保留了向后欧拉法的无条件稳定性特征，即，对于某个范数 $|\\!|\\cdot|\\!|$，如果向后欧拉法对于此耗散线性系统在该范数下是无条件稳定的，那么后处理的估计满足形式为 $|\\!|\\,\\widehat{U}(t^{n+1})\\,|\\!|\\leq K\\,|\\!|\\,U^{n}\\,|\\!|$ 的界，其中 $K$ 是一个与 $\\Delta t$ 和 $A$ 的谱无关的常数。\n\n作为最终答案，请提供 $\\widehat{U}(t^{n+1})$ 关于 $U_{\\Delta t/2}(t^{n+1})$ 和 $U_{\\Delta t}(t^{n+1})$ 的显式代数表达式。最终答案中不要包含任何不等式或界。最终答案必须是单一的闭式解析表达式。无需四舍五入。", "solution": "我们从已知的在时间 $t^{n+1}$ 处向后欧拉法的全局误差模型开始：\n$$\nU_{\\Delta t}(t^{n+1})=u(t^{n+1})+C(t^{n+1})\\,\\Delta t+O\\!\\left((\\Delta t)^{2}\\right),\n$$\n其中 $C(t)$ 有界且与 $\\Delta t$ 无关。将相同的模型应用于步长 $\\Delta t/2$，并利用步长为 $\\Delta t/2$ 的两步从 $t^{n}$ 推进到 $t^{n+1}$，我们得到\n$$\nU_{\\Delta t/2}(t^{n+1})=u(t^{n+1})+C(t^{n+1})\\,\\frac{\\Delta t}{2}+O\\!\\left((\\Delta t)^{2}\\right).\n$$\n更精确地说，假设解足够光滑，使得全局误差允许一个渐近级数展开，我们可以写出\n$$\nU_{\\Delta t}(t^{n+1})=u(t^{n+1})+C(t^{n+1})\\,\\Delta t+D(t^{n+1})\\,(\\Delta t)^{2}+O\\!\\left((\\Delta t)^{3}\\right),\n$$\n$$\nU_{\\Delta t/2}(t^{n+1})=u(t^{n+1})+C(t^{n+1})\\,\\frac{\\Delta t}{2}+D(t^{n+1})\\,\\frac{(\\Delta t)^{2}}{4}+O\\!\\left((\\Delta t)^{3}\\right),\n$$\n其中系数 $C(t)$ 和 $D(t)$ 有界且不依赖于 $\\Delta t$，仅依赖于在 $t^{n+1}$ 处的解及其导数。\n\n我们寻求一个线性组合\n$$\n\\widehat{U}(t^{n+1})=a\\,U_{\\Delta t/2}(t^{n+1})+b\\,U_{\\Delta t}(t^{n+1})\n$$\n它既是相容的，又能消除 $O(\\Delta t)$ 项。代入展开式得到\n\\begin{align*}\n\\widehat{U}(t^{n+1})&=a\\left(u(t^{n+1})+C\\,\\frac{\\Delta t}{2}+D\\,\\frac{(\\Delta t)^{2}}{4}+O\\!\\left((\\Delta t)^{3}\\right)\\right)+b\\left(u(t^{n+1})+C\\,\\Delta t+D\\,(\\Delta t)^{2}+O\\!\\left((\\Delta t)^{3}\\right)\\right)\\\\\n&=(a+b)\\,u(t^{n+1})+C\\,\\Delta t\\left(\\frac{a}{2}+b\\right)+D\\,(\\Delta t)^{2}\\left(\\frac{a}{4}+b\\right)+O\\!\\left((\\Delta t)^{3}\\right).\n\\end{align*}\n为了与 $u(t^{n+1})$ 相容，我们要求\n$$\na+b=1.\n$$\n为了消除一阶项，我们要求\n$$\n\\frac{a}{2}+b=0.\n$$\n求解这个线性方程组，第二个方程给出 $a=-2b$，代入第一个方程得到 $-2b+b=1$，因此 $b=-1$ 且 $a=2$。所以，\n$$\n\\widehat{U}(t^{n+1})=2\\,U_{\\Delta t/2}(t^{n+1})-U_{\\Delta t}(t^{n+1}).\n$$\n剩余的截断误差通过将 $a=2$ 和 $b=-1$ 代入 $(\\Delta t)^{2}$ 的系数得到：\n$$\nD\\,(\\Delta t)^{2}\\left(\\frac{a}{4}+b\\right)=D\\,(\\Delta t)^{2}\\left(\\frac{2}{4}-1\\right)=-\\frac{1}{2}\\,D\\,(\\Delta t)^{2},\n$$\n因此外推估计的误差为 $O\\!\\left((\\Delta t)^{2}\\right)$，符合要求。\n\n我们现在论证这种后处理保留了向后欧拉法这个基本方法的无条件稳定性。对于线性测试方程 $y^{\\prime}=\\lambda\\,y$，其中 $\\operatorname{Re}(\\lambda)\\leq 0$，向后欧拉法的放大因子为\n$$\ng(z)=\\frac{1}{1-z},\\quad z=\\lambda\\,\\Delta t,\n$$\n对于所有满足 $\\operatorname{Re}(z)\\leq 0$ 的 $z$，该放大因子满足 $|g(z)|\\leq 1$，因为 $|1-z|=\\sqrt{(1-\\operatorname{Re}(z))^{2}+(\\operatorname{Im}(z))^{2}}\\geq |1-\\operatorname{Re}(z)|\\geq 1$。对于这个标量模型，这是代数稳定性的定义属性，并代表了无条件稳定性。\n\n对于线性系统 $U^{\\prime}=A\\,U+G(t)$，其中 $A$ 在一个适当的能量范数 $|\\!|\\cdot|\\!|$ 下生成一个收缩半群，向后欧拉更新 $(I-\\Delta t\\,A)U^{n+1}=U^{n}+\\Delta t\\,G^{n+1}$ 是无条件稳定的：存在一个与 $\\Delta t$ 和 $A$ 的谱无关的常数 $M$，使得\n$$\n|\\!|\\,U_{\\Delta t}(t^{n+1})\\,|\\!|\\leq M\\left(|\\!|\\,U^{n}\\,|\\!|+\\int_{t^{n}}^{t^{n+1}}|\\!|\\,G(s)\\,|\\!|\\,\\mathrm{d}s\\right),\n$$\n并且同样的界对于产生 $U_{\\Delta t/2}(t^{n+1})$ 的两个半步也成立。外推估计是这两个稳定近似的线性后处理。根据三角不等式，\n\\begin{align*}\n|\\!|\\,\\widehat{U}(t^{n+1})\\,|\\!|&=|\\!|\\,2\\,U_{\\Delta t/2}(t^{n+1})-U_{\\Delta t}(t^{n+1})\\,|\\!|\\\\\n&\\leq 2\\,|\\!|\\,U_{\\Delta t/2}(t^{n+1})\\,|\\!|+|\\!|\\,U_{\\Delta t}(t^{n+1})\\,|\\!|\\\\\n&\\leq (2\\,M+M)\\left(|\\!|\\,U^{n}\\,|\\!|+\\int_{t^{n}}^{t^{n+1}}|\\!|\\,G(s)\\,|\\!|\\,\\mathrm{d}s\\right)\\\\\n&=3\\,M\\left(|\\!|\\,U^{n}\\,|\\!|+\\int_{t^{n}}^{t^{n+1}}|\\!|\\,G(s)\\,|\\!|\\,\\mathrm{d}s\\right).\n\\end{align*}\n因此，外推估计继承了一个无条件稳定性界，其常数因子 $K=3\\,M$ 与 $\\Delta t$ 和 $A$ 的谱无关。这表明通过理查森外推实现的精度提升，并没有牺牲向后欧拉法这个基本积分器的无条件稳定性特征，因为后处理本身不改变演化步骤，并且产生了一个一致有界的估计。\n\n因此，在时间 $t^{n+1}$ 所需的二阶保稳定性外推估计是\n$$\n\\widehat{U}(t^{n+1})=2\\,U_{\\Delta t/2}(t^{n+1})-U_{\\Delta t}(t^{n+1}).\n$$", "answer": "$$\\boxed{2\\,U_{\\Delta t/2}(t^{n+1})-U_{\\Delta t}(t^{n+1})}$$", "id": "3440894"}, {"introduction": "标准的理查德森外推公式依赖于一个关键假设：数值误差可以展开为网格尺寸 $h$ 的整数幂级数。然而，当面对未被充分解析的边界层等复杂情况时，这一假设可能失效。本练习通过一个边界层剖面的具体例子，揭示了标准误差模型的局限性，并指导你推导出一个修正的理查德森外推缩放律。这个过程将加深你对该方法理论基础的理解，并培养在应用数值方法时进行批判性思考的能力。[@problem_id:3440892]", "problem": "考虑一个稳态一维对流-扩散边值问题，其精确解在入流边界处表现出一个边界层。在内层中，解可以很好地由边界层剖面 $u(x)=1-\\exp(-x/\\epsilon)$ 近似，其中 $\\epsilon>0$ 是控制边界层厚度的扩散强度参数。偏微分方程数值解中的一个常见做法是采用两层理查森外推法，该方法假定对于目标量 $Q$、网格间距 $h$、常数 $C$ 和方法阶数 $p$，存在一个形如 $Q(h)=Q+C h^{p}$ 的主阶误差模型。\n\n在存在边界层的情况下，当 $h$ 并不远小于 $\\epsilon$ 时，主导误差是 $h$ 的幂级数的假设可能会失效。具体来说，边界层在单个网格区间 $[0,h]$ 上的欠解析会引入一个主导误差贡献，该贡献与第一个单元内未捕捉到的边界层振幅成正比。对于剖面 $u(x)=1-\\exp(-x/\\epsilon)$，单个网格步长上的这个振幅是差值 $u(h)-u(0)$。\n\n假设对于一个在 $x=0$ 处带有狄利克雷边界的对流-扩散算子的相容空间离散，在一个由边界层主导的目标量 $Q$ 中，网格尺寸为 $h$ 时的主要离散误差与 $u(h)-u(0)$ 成正比，并且同样的比例关系适用于网格尺寸为 $h/2$ 的情况。在此模型下，两层理查森外推法应将缩放因子 $2^{p}$ 替换为一个由 $h$ 和 $h/2$ 处主导误差之比确定的因子。\n\n请以闭式解的形式，推导当主导误差由一个网格步长上未解析的边界层振幅控制时，应在两层理cha森外推公式中替换 $2^{p}$ 的修正缩放律 $r(h,\\epsilon)$。您的最终答案必须是 $r(h,\\epsilon)$ 的单一解析表达式，不带单位。", "solution": "该问题要求推导一种修正的缩放律，用于两层理查森外推法，该方法适用于其主导误差由指数边界层欠解析所控制的数值方法。\n\n标准的两层理查森外推法基于对一个目标量 $Q$ 的假定渐近误差展开，该目标量由一个网格间距为 $h$ 的数值方法近似。设 $Q(h)$ 为数值近似值。误差模型通常是 $h$ 的幂级数：\n$$Q(h) = Q + C h^{p} + O(h^q)$$\n其中 $Q$ 是精确值，$C$ 是与 $h$ 无关的常数，$p$ 是方法的阶数，且 $q > p$。\n\n对于两个网格层级，间距分别为 $h$ 和 $h/2$，我们有近似值：\n$$Q(h) \\approx Q + C h^{p}$$\n$$Q(h/2) \\approx Q + C \\left(\\frac{h}{2}\\right)^{p} = Q + C \\frac{h^{p}}{2^{p}}$$\n\n主阶误差为 $E(h) = Q(h) - Q \\approx C h^{p}$ 和 $E(h/2) = Q(h/2) - Q \\approx C h^{p}/2^{p}$。这些误差的比值定义了外推中使用的缩放因子：\n$$\\frac{E(h)}{E(h/2)} \\approx \\frac{C h^{p}}{C h^{p} / 2^{p}} = 2^{p}$$\n消除主误差项的外推解由下式给出：\n$$Q_{extrap} = \\frac{2^{p} Q(h/2) - Q(h)}{2^{p} - 1}$$\n\n问题指出，由于边界层的欠解析，这种标准的误差模型是无效的。取而代之的是，主导误差与第一个网格单元上未解析的边界层剖面振幅成正比。设 $K$ 为比例常数。在网格间距为 $h$ 和 $h/2$ 时的误差由下式给出：\n$$E(h) = K [u(h) - u(0)]$$\n$$E(h/2) = K [u(h/2) - u(0)]$$\n其中边界层剖面被指定为 $u(x) = 1 - \\exp(-x/\\epsilon)$。\n\n我们记为 $r(h,\\epsilon)$ 的修正缩放律替代了因子 $2^{p}$。它由实际主导误差的比值决定：\n$$r(h, \\epsilon) = \\frac{E(h)}{E(h/2)} = \\frac{K [u(h) - u(0)]}{K [u(h/2) - u(0)]}$$\n比例常数 $K$ 被消去，得到：\n$$r(h, \\epsilon) = \\frac{u(h) - u(0)}{u(h/2) - u(0)}$$\n\n现在我们将给定的 $u(x)$ 函数形式代入此表达式。首先，我们在所需的点上计算函数值：\n在 $x=0$ 处：\n$$u(0) = 1 - \\exp(-0/\\epsilon) = 1 - \\exp(0) = 1 - 1 = 0$$\n在 $x=h$ 处：\n$$u(h) = 1 - \\exp(-h/\\epsilon)$$\n在 $x=h/2$ 处：\n$$u(h/2) = 1 - \\exp\\left(-\\frac{h/2}{\\epsilon}\\right) = 1 - \\exp\\left(-\\frac{h}{2\\epsilon}\\right)$$\n\n将这些值代入 $r(h, \\epsilon)$ 的表达式中：\n$$r(h, \\epsilon) = \\frac{(1 - \\exp(-h/\\epsilon)) - 0}{(1 - \\exp(-h/(2\\epsilon))) - 0} = \\frac{1 - \\exp(-h/\\epsilon)}{1 - \\exp(-h/(2\\epsilon))}$$\n\n为了简化此表达式，我们注意到分子是平方差形式。令 $y = \\exp(-h/(2\\epsilon))$。则 $y^2 = (\\exp(-h/(2\\epsilon)))^2 = \\exp(-h/\\epsilon)$。表达式变为：\n$$r(h, \\epsilon) = \\frac{1 - y^2}{1 - y}$$\n对分子进行因式分解，$1 - y^2 = (1 - y)(1 + y)$，我们得到：\n$$r(h, \\epsilon) = \\frac{(1 - y)(1 + y)}{1 - y}$$\n对于 $h \\neq 0$，$y = \\exp(-h/(2\\epsilon)) \\neq 1$，所以 $(1 - y)$ 项非零，可以从分子和分母中约去。\n$$r(h, \\epsilon) = 1 + y$$\n\n将 $y$ 的表达式代回，我们得到修正后缩放律的最终闭式表达式：\n$$r(h, \\epsilon) = 1 + \\exp\\left(-\\frac{h}{2\\epsilon}\\right)$$\n在指定的误差模型下，这就是理查森外推公式中必须替代 $2^{p}$ 的因子。", "answer": "$$ \\boxed{1 + \\exp\\left(-\\frac{h}{2\\epsilon}\\right)} $$", "id": "3440892"}, {"introduction": "将理论付诸实践是掌握任何数值方法的关键。在这个综合性练习中，你将为经典的热传导方程实现一个更为复杂的时空混合理查德森外推方案。通过结合不同空间网格和时间步长的计算结果，我们将构建一个在时间和空间上都具有更高阶精度的解。此外，本练习还要求分析外推法对系统离散能量演化的影响，将抽象的数值算法与具体的物理量联系起来，从而全面检验你对该技术的掌握程度。[@problem_id:3440885]", "problem": "考虑在区间 $[0,1]$ 上的热传导方程 $u_t=\\alpha \\Delta u$，其边界条件为齐次 Dirichlet 条件，即 $u(0,t)=0$ 和 $u(1,t)=0$，其中 $\\alpha>0$ 是一个常数热扩散系数。假设空间离散化在均匀网格上使用二阶中心差分，内部点为 $x_i=i h$（$i=1,\\dots,M$），其中 $h=1/(M+1)$；时间离散化使用 Crank–Nicolson 方法，时间步长为 $\\Delta t$。将最终时间 $T$ 的全离散解记为 $U(h,\\Delta t)$，并将其视为 $\\mathbb{R}^M$ 中的一个向量。定义离散能量为 $E_h(U)=h\\sum_{i=1}^M U_i^2$，其中 $U_i$ 是 $U$ 的第 $i$ 个分量。\n\n您的任务是：\n\n- 从热传导方程的基本性质（能量衰减和离散拉普拉斯算子的谱结构）出发，论证当初始条件足够光滑时，采用二阶中心差分的 Crank–Nicolson 方法所产生的离散解 $U(h,\\Delta t)$ 的渐近误差在 $h$ 和 $\\Delta t$ 上均存在偶数次幂展开。\n\n- 设计一个方案，在时间和空间上应用 Richardson 外推法，使用比例为 2 的嵌套网格和嵌套时间步长，在粗网格上构造一个混合外推解 $U^{\\star}(h,\\Delta t)$。该方案必须：\n  1. 使用相同的空间网格尺寸 $h$ 及其加密后的 $h/2$，以及相同的时间步长 $\\Delta t$ 及其加密后的 $\\Delta t/2$，生成四个达到相同最终时间 $T$ 的解。\n  2. 通过时间和空间外推，以逻辑上一致的方式组合这些解，以消除 $h$ 和 $\\Delta t$ 中的主导偶数次幂误差项。\n  3. 在粗网格（大小为 $M$）上输出最终的 $U^{\\star}(h,\\Delta t)$，而不是在细网格上。\n\n- 分析该方案引起的离散能量 $E_h(U)$。使用离散拉普拉斯算子的特征模态论证和光滑初始数据，确定在何种关于 $h$、$\\Delta t$ 和 $\\alpha$ 的条件下，混合外推解 $U^{\\star}(h,\\Delta t)$ 能改善离散能量衰减，即能量误差 $|E_h(U^{\\star}(h,\\Delta t))-E_h(u_{\\text{exact}}(\\cdot,T))| < |E_h(U(h,\\Delta t))-E_h(u_{\\text{exact}}(\\cdot,T))|$，其中 $u_{\\text{exact}}(x,T)$ 是在网格点上求值的精确解。将任何角度量以弧度表示，任何分数表示为小数或精确分数；不允许使用百分号。\n\n使用初始条件 $u(x,0)=\\sin(\\pi x)$、扩散系数 $\\alpha=1$ 和精确解 $u_{\\text{exact}}(x,t)=e^{-\\pi^2 t}\\sin(\\pi x)$。对于离散能量的比较，在离散网格点 $x_i=i h$ 上计算 $u_{\\text{exact}}(x_i,T)$，并使用相同的离散能量定义 $E_h(\\cdot)$。\n\n实现一个完整、可运行的程序，该程序：\n- 构建间距为 $h$ 的均匀网格上的离散拉普拉斯算子，应用 Crank–Nicolson 方法计算 $U(h,\\Delta t)$，并对混合 Richardson 外推方案所需的加密网格和时间步长（时间加密因子为 2，空间加密因子为 2）进行类似操作。\n- 通过在每个网格上先进行时间外推，然后进行空间外推，来在粗网格上组装 $U^{\\star}(h,\\Delta t)$，其中使用从细网格到粗网格的一致限制算子，即对内部点每隔一个进行采样。\n- 计算离散能量 $E_h(U(h,\\Delta t))$、$E_h(U^{\\star}(h,\\Delta t))$ 和 $E_h(u_{\\text{exact}}(\\cdot,T))$。\n- 对于下面测试套件中的每个测试用例，输出一个布尔值，该值指示混合外推法相对于基准 Crank–Nicolson 解是否改善了离散能量衰减，即它是否产生了严格更小的绝对能量误差。\n\n测试套件：\n- 用例 1：$M=64$，$\\Delta t=0.01$，$T=0.1$，$\\alpha=1$。\n- 用例 2：$M=16$，$\\Delta t=0.02$，$T=0.1$，$\\alpha=1$。\n- 用例 3：$M=64$，$\\Delta t=0.02$，$T=1.0$，$\\alpha=1$。\n- 用例 4：$M=32$，$\\Delta t=0.1$，$T=0.2$，$\\alpha=1$。\n- 用例 5：$M=8$，$\\Delta t=0.05$，$T=0.1$，$\\alpha=1$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k$ 是对应于上述第 $k$ 个测试用例的布尔值。", "solution": "该问题已经过验证，被确定为数值分析领域中一个适定的、有科学依据的问题。\n\n### 第一部分：渐近误差展开的论证\n\n对偏微分方程（PDE）的数值方法的误差分析，可以通过检查其组成部分来进行：即空间离散化和时间离散化。\n\n在区间 $[0,1]$ 上，拉普拉斯算子 $\\Delta u = u_{xx}$ 的空间离散化在间距为 $h$ 的均匀网格上使用二阶中心差分公式：\n$$\n\\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} = u_{xx}(x_i) + \\frac{h^2}{12}u_{xxxx}(x_i) + O(h^4)\n$$\n这是通过 $u(x_i \\pm h)$ 在 $x_i$ 点的泰勒级数展开得到的。空间算子的局部截断误差为 $O(h^2)$ 阶。关键在于，由于中心差分模板的对称性，只要解 $u$ 足够光滑（具体来说，如果 $u$ 是 $C^6$ 或更高阶，该模式会继续），误差展开式中只包含 $h$ 的偶数次幂。\n\n对得到的常微分方程组（ODEs） $\\frac{d\\mathbf{u}}{dt} = \\mathbf{F}(\\mathbf{u})$ 的时间离散化使用 Crank–Nicolson 方法。对于线性热传导方程，其形式为：\n$$\n\\frac{\\mathbf{U}^{n+1} - \\mathbf{U}^n}{\\Delta t} = \\frac{1}{2} \\left[ \\frac{\\alpha}{h^2}A_h \\mathbf{U}^{n+1} + \\frac{\\alpha}{h^2}A_h \\mathbf{U}^n \\right]\n$$\n其中 $A_h$ 是二阶中心差分算子的矩阵表示。Crank–Nicolson 方法等价于对时间积分应用梯形法则，该法则以时间 $t_{n+1/2} = t_n + \\Delta t/2$ 为中心。这种时间上的对称性导致局部截断误差为 $O(\\Delta t^2)$ 阶。对于像 Crank-Nicolson 这样的稳定方法，在固定时间 $T$ 的全局误差也累积为 $O(\\Delta t^2)$ 阶。由于这种对称性，误差展开式只涉及 $\\Delta t$ 的偶数次幂。\n\n当这两种对称方法结合使用时，对于足够光滑的解，全离散解 $U(h, \\Delta t)$ 在网格点 $(x_i, T)$ 的全局误差具有关于 $h$ 和 $\\Delta t$ 的偶数次幂的渐近展开：\n$$\nU(x_i, T) - u(x_i, T) = \\sum_{j=1, k=0}^{\\infty} c_{jk}(x_i, T) h^{2j} (\\Delta t)^{2k} \\quad (j+k \\ge 1)\n$$\n主导误差项为 $C_1(\\mathbf{x}, T)h^2 + C_2(\\mathbf{x}, T)\\Delta t^2$。正是这种规则的偶数次幂结构，使得 Richardson 外推法成为提高精度的强大工具。\n\n### 第二部分：Richardson 外推方案设计\n\n目标是消除主导的 $O(h^2)$ 和 $O(\\Delta t^2)$ 误差项。该方案需要在最终时间 $T$ 计算四个解。令 $U_h^{\\Delta t} \\equiv U(h, \\Delta t)$ 表示用空间步长 $h$ 和时间步长 $\\Delta t$ 得到的数值解。\n\n1.  **计算四个基础解：**\n    *   $U_1 = U_h^{\\Delta t}$：粗网格（$M$ 个内部点，步长 $h$），粗时间步长（$\\Delta t$）。\n    *   $U_2 = U_h^{\\Delta t/2}$：粗网格，细时间步长（$\\Delta t/2$）。\n    *   $U_3 = U_{h/2}^{\\Delta t}$：细网格（$2M+1$ 个内部点，步长 $h/2$），粗时间步长（$\\Delta t$）。\n    *   $U_4 = U_{h/2}^{\\Delta t/2}$：细网格，细时间步长（$\\Delta t/2$）。\n\n2.  **时间外推（第一步）：**我们首先消除 $O(\\Delta t^2)$ 误差项。对于加密因子为 2 的二阶方法，标准的 Richardson 公式是 $U_{\\text{extrapolated}} = (4 U_{\\text{fine}} - U_{\\text{coarse}}) / 3$。\n    *   在粗空间网格上，我们组合 $U_1$ 和 $U_2$ 以创建一个在时间上具有四阶精度的解：\n        $$U_{h, T} = \\frac{4 U_h^{\\Delta t/2} - U_h^{\\Delta t}}{3} = u(\\cdot, T) + C_1 h^2 + O(\\Delta t^4)$$\n    *   在细空间网格上，我们类似地组合 $U_3$ 和 $U_4$：\n        $$U_{h/2, T} = \\frac{4 U_{h/2}^{\\Delta t/2} - U_{h/2}^{\\Delta t}}{3} = u(\\cdot, T) + C_1 (h/2)^2 + O(\\Delta t^4)$$\n\n3.  **空间外推（第二步）：**现在我们有两个解，$U_{h, T}$ 和 $U_{h/2, T}$，它们在时间上都是四阶精度，但在空间上是二阶精度。\n    *   首先，细网格解 $U_{h/2, T}$ 必须被限制到粗网格上。设 $R$ 为限制算子，它对细网格的每隔一个内部点进行采样。因此，$R(U_{h/2,T})$ 是粗网格上的一个向量。\n    *   我们对 $U_{h, T}$ 和 $R(U_{h/2, T})$ 应用相同的 Richardson 公式以消除 $O(h^2)$ 项：\n        $$U^{\\star}(h, \\Delta t) = \\frac{4 R(U_{h/2, T}) - U_{h, T}}{3}$$\n    这个最终解 $U^{\\star}$ 定义在粗网格上，其理论误差为 $O(h^4, \\Delta t^4)$。\n\n### 第三部分：离散能量分析\n\n离散能量定义为 $E_h(U) = h \\sum_{i=1}^M U_i^2$。初始条件 $u(x,0) = \\sin(\\pi x)$ 是在 $[0,1]$ 上带有齐次 Dirichlet 边界条件的连续拉普拉斯算子的第一特征模态。其对应的特征值为 $-\\pi^2$。类似地，分量为 $U^0_i = \\sin(\\pi x_i) = \\sin(\\pi i h)$ 的离散初始条件向量 $U^0$ 是离散拉普拉斯矩阵 $A_h$ 的第一特征向量。\n\n当初始条件是单个特征向量时，在任何时间 $t$ 的解都与该特征向量保持成比例。在时间 $T = N\\Delta t$ 的数值解为 $U(h, \\Delta t) = C(h, \\Delta t) U^0$，其中 $C(h, \\Delta t)$ 是一个标量系数，表示在 $N$ 个时间步长内的总放大率。同样，在网格点上的精确解是 $u_{exact}(\\cdot, T) = C_{exact} U^0$，其中 $C_{exact} = e^{-\\alpha \\pi^2 T}$。\n\n数值解的离散能量为 $E_h(U(h, \\Delta t)) = [C(h, \\Delta t)]^2 E_h(U^0)$，精确解的能量为 $E_h(u_{exact}) = [C_{exact}]^2 E_h(U^0)$。应用于解向量的 Richardson 外推过程等价于将相同的外推公式应用于标量系数：\n$$\nC^{\\star} = \\frac{4 C_T(h/2) - C_T(h)}{3} \\quad \\text{其中} \\quad C_T(\\cdot) = \\frac{4 C(\\cdot, \\Delta t/2) - C(\\cdot, \\Delta t)}{3}\n$$\n问题要求找出在何种条件下，外推解能改善能量衰减，这转化为更小的绝对能量误差：\n$$\n|E_h(U^{\\star}) - E_h(u_{exact})| < |E_h(U) - E_h(u_{exact})|\n$$\n代入能量表达式，这变为：\n$$\n|[C^{\\star}]^2 - [C_{exact}]^2| < |[C(h, \\Delta t)]^2 - [C_{exact}]^2|\n$$\n如果外推系数 $C^{\\star}$ 比原始数值系数 $C(h, \\Delta t)$ 是对 $C_{exact}$ 更好的近似，则该不等式成立。这是 Richardson 外推法的预期行为，前提是离散化参数 $h$ 和 $\\Delta t$ “足够小”。这个条件确保了渐近误差展开 $C(h, \\Delta t) \\approx C_{exact} + c_1 h^2 + c_2 \\Delta t^2$ 是一个有效的近似，意味着主导误差项占主导地位，而高阶项不会干扰抵消过程。\n\n对于“足够小”，没有简单的通用公式。它取决于问题的具体参数（$\\alpha, T$）和解的光滑性。如果 $h$ 或 $\\Delta t$ 太大，外推法可能无法改善甚至可能恶化精度。数值测试将验证对于给定的哪几组参数，系统处于外推法有益的渐近区域。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(M, dt, T, alpha):\n    \"\"\"\n    Solves the 1D heat equation u_t = alpha * u_xx using Crank-Nicolson.\n    \n    Args:\n        M (int): Number of interior spatial grid points.\n        dt (float): Time step size.\n        T (float): Final time.\n        alpha (float): Thermal diffusivity.\n\n    Returns:\n        np.ndarray: The solution vector at the final time T.\n    \"\"\"\n    h = 1.0 / (M + 1)\n    # Check if T is a multiple of dt to avoid float precision issues for N_steps\n    if not np.isclose(T / dt, round(T / dt)):\n        raise ValueError(\"T must be an integer multiple of dt.\")\n    N_steps = int(round(T / dt))\n\n    # Initial condition\n    x = np.arange(1, M + 1) * h\n    u = np.sin(np.pi * x)\n\n    # Construct Crank-Nicolson matrices\n    # A_h is the discrete Laplacian operator matrix (unscaled)\n    # It has -2 on the main diagonal and 1 on the off-diagonals.\n    A_h = np.diag(np.ones(M - 1), k=1) + np.diag(np.ones(M - 1), k=-1) - 2 * np.diag(np.ones(M))\n    \n    # LHS = (I - c * A_h), RHS = (I + c * A_h) where c = alpha*dt/(2*h^2)\n    # A_h U^{n+1} = B U^n\n    c = alpha * dt / (2.0 * h**2)\n    mat_LHS = np.identity(M) - c * A_h\n    mat_RHS = np.identity(M) + c * A_h\n\n    # Time-stepping loop\n    for _ in range(N_steps):\n        b = mat_RHS @ u\n        u = np.linalg.solve(mat_LHS, b)\n        \n    return u\n\ndef calculate_energy(u_vec, h):\n    \"\"\"Calculates the discrete energy E_h(U) = h * sum(U_i^2).\"\"\"\n    return h * np.sum(u_vec**2)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases for Richardson extrapolation on the heat equation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (M, dt, T, alpha)\n        (64, 0.01, 0.1, 1.0),\n        (16, 0.02, 0.1, 1.0),\n        (64, 0.02, 1.0, 1.0),\n        (32, 0.1,  0.2, 1.0),\n        (8,  0.05, 0.1, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        M_c, dt_c, T, alpha = case\n        \n        # Define coarse and fine parameters\n        M_f = 2 * M_c + 1\n        dt_f = dt_c / 2.0\n        h_c = 1.0 / (M_c + 1)\n\n        # 1. Compute the four base solutions\n        # U(h, dt) -> u_cc (coarse space, coarse time)\n        u_cc = run_simulation(M_c, dt_c, T, alpha)\n        # U(h, dt/2) -> u_cf (coarse space, fine time)\n        u_cf = run_simulation(M_c, dt_f, T, alpha)\n        # U(h/2, dt) -> u_fc (fine space, coarse time)\n        u_fc = run_simulation(M_f, dt_c, T, alpha)\n        # U(h/2, dt/2) -> u_ff (fine space, fine time)\n        u_ff = run_simulation(M_f, dt_f, T, alpha)\n        \n        # 2. Perform Richardson extrapolation: time first, then space\n        # Time extrapolation on coarse grid\n        uT_c = (4.0 * u_cf - u_cc) / 3.0\n        # Time extrapolation on fine grid\n        uT_f = (4.0 * u_ff - u_fc) / 3.0\n\n        # Space extrapolation\n        # Restrict fine-grid solution to coarse grid by sampling every second point.\n        # For M_f = 2*M_c+1 interior points, the coarse grid points i=1..M_c\n        # correspond to fine grid points j=2,4,...,2*M_c.\n        # In 0-based Python indexing, this is u_f[1::2].\n        restricted_uT_f = uT_f[1::2]\n        u_star = (4.0 * restricted_uT_f - uT_c) / 3.0\n\n        # 3. Compute and compare discrete energies\n        # Baseline solution energy (coarse-coarse)\n        E_base = calculate_energy(u_cc, h_c)\n        # Extrapolated solution energy\n        E_star = calculate_energy(u_star, h_c)\n        \n        # Exact solution energy on the coarse grid\n        x_c = np.arange(1, M_c + 1) * h_c\n        u_exact_vec = np.exp(-np.pi**2 * alpha * T) * np.sin(np.pi * x_c)\n        E_exact = calculate_energy(u_exact_vec, h_c)\n\n        # 4. Calculate absolute energy errors\n        err_base = np.abs(E_base - E_exact)\n        err_star = np.abs(E_star - E_exact)\n\n        # Determine if extrapolation improved the energy error\n        is_improved = err_star  err_base\n        results.append(is_improved)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3440885"}]}