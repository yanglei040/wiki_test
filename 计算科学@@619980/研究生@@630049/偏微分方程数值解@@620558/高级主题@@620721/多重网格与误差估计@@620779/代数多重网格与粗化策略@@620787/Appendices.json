{"hands_on_practices": [{"introduction": "在设计代数多重网格（AMG）求解器时，我们不仅需要创建一系列更粗的网格，还必须在粗网格求解速度（要求粗网格问题规模足够小）与算子复杂度（由Galerkin构造过程导致）之间取得平衡。这个练习 [@problem_id:3362567] 提供了计算这些关键指标的实践，帮助您理解决定AMG层次结构效率和内存占用的权衡因素。", "problem": "考虑一个线性系统，该系统源于在单位立方体上使用均匀狄利克雷边界条件的三维泊松方程的离散化。离散化方法为，在均匀网格上使用标准七点有限差分格式，每个空间方向有 $n=128$ 个内部点。由此得到的最细层未知数数量为 $N_0=n^3$。我们使用以下粗化策略构建一个代数多重网格 (AMG) 层次结构：\n\n- 前两次粗化（从层 $l=0$ 到 $l=1$ 以及从 $l=1$ 到 $l=2$）使用激进粗化，粗化率为 $\\rho_a=\\frac{1}{5}$，因此对于 $l\\in\\{0,1\\}$，有 $N_{l+1}=\\rho_a N_l$。\n- 所有后续的粗化（对于 $l\\geq 2$）均使用标准粗化，粗化率为 $\\rho_s=\\frac{33}{100}$，因此对于所有 $l\\geq 2$，有 $N_{l+1}=\\rho_s N_l$。\n\n假设在第 $l$ 层，矩阵每行的平均非零元数量为 $s_l=s_0\\,\\eta^{\\,l}$，其中 $s_0=7$ 且 $\\eta=\\frac{5}{4}$，这反映了由 Galerkin 粗网格算子构造引起的增长。算子复杂度的定义为\n$$\nC_{\\mathrm{op}} \\;=\\; \\frac{\\sum_{l=0}^{L} s_l\\,N_l}{s_0\\,N_0}\\,,\n$$\n其中 $L$ 是最粗层的索引。最粗层被选为满足 $N_L\\leq N_{\\min}$ 的最小 $L\\in\\mathbb{N}$，其中 $N_{\\min}=500$。此外，该层次结构必须满足算子复杂度约束 $C_{\\mathrm{op}}\\leq C_{\\max}$，其中 $C_{\\max}=1.8$。\n\n仅根据这些定义和假设，确定使 $N_L\\leq 500$ 和 $C_{\\mathrm{op}}\\leq 1.8$ 同时成立的最小整数 $L$。请以整数形式提供您的最终答案。无需四舍五入。", "solution": "用户要求我解决一个数值分析领域的问题，具体涉及代数多重网格 (AMG) 方法。\n\n### 步骤 1：提取已知条件\n我将首先列出问题陈述中明确提供的所有数据和定义：\n- 网格尺寸：每个空间方向有 $n=128$ 个内部点。\n- 最细层未知数数量：$N_0 = n^3 = 128^3$。\n- 粗化策略：\n    - 前两个层级（$l=0, 1$）使用激进粗化：$N_{l+1} = \\rho_a N_l$，其中 $\\rho_a = \\frac{1}{5}$。\n    - 后续层级（$l \\geq 2$）使用标准粗化：$N_{l+1} = \\rho_s N_l$，其中 $\\rho_s = \\frac{33}{100}$。\n- 第 $l$ 层矩阵每行的非零元数量：$s_l = s_0 \\eta^l$，其中 $s_0=7$ 且 $\\eta = \\frac{5}{4}$。\n- 算子复杂度定义：$C_{\\mathrm{op}} = \\frac{\\sum_{l=0}^{L} s_l N_l}{s_0 N_0}$。\n- 最粗层终止条件：$L$ 是满足 $N_L \\leq N_{\\min}$ 的最小整数，其中 $N_{\\min}=500$。\n- 附加约束：该层次结构还必须满足 $C_{\\mathrm{op}} \\leq C_{\\max}$，其中 $C_{\\max}=1.8$。\n- 目标是找到同时满足 $N_L \\leq 500$ 和 $C_{\\mathrm{op}} \\leq 1.8$ 的最小整数 $L$。\n\n### 步骤 2：使用提取的已知条件进行验证\n所提出的问题是在分析 AMG 性能的标准框架内一个定义明确的数学练习。\n- **科学基础：** 概念（AMG、粗化、Galerkin 算子、算子复杂度）及其数学公式在偏微分方程数值解领域是标准的。参数是为假设情景选择的，但并非不切实际或无意义。\n- **适定性：** 问题要求找到满足一组明确定义的不等式的最小整数 $L$。这样的整数的存在性和唯一性可以通过直接计算确定。\n- **客观性：** 问题陈述没有歧义、主观性或非科学性主张。所有术语都有数学定义。\n\n该问题不违反任何无效标准。它是一个在数值线性代数中可以形式化和解决的问题。因此，该问题被视为**有效**。\n\n### 步骤 3：结论与行动\n问题是有效的。我现在将着手解决。\n\n### 解题过程\n目标是找到同时满足两个条件的最小整数 $L$：\n1.  $N_L \\leq 500$\n2.  $C_{\\mathrm{op}} \\leq 1.8$\n\n我们来分别分析每个条件。\n\n**条件 1：$N_L \\leq 500$**\n\n首先，我们从 $N_0$ 开始，计算多重网格层次结构中每一层的未知数数量。\n$N_0 = n^3 = 128^3 = 2,097,152$。\n\n使用给定的粗化率，我们可以计算 $l=1, 2, 3, \\dots$ 的 $N_l$：\n- 当 $l=0$ 时：$N_1 = N_0 \\rho_a = 2,097,152 \\times \\frac{1}{5} = 419,430.4$。\n- 当 $l=1$ 时：$N_2 = N_1 \\rho_a = 419,430.4 \\times \\frac{1}{5} = 83,886.08$。\n- 当 $l \\geq 2$ 时，关系为 $N_{l+1} = N_l \\rho_s = N_l \\times \\frac{33}{100}$。\n- 当 $l=2$ 时：$N_3 = N_2 \\rho_s = 83,886.08 \\times 0.33 = 27,682.4064$。\n- 当 $l=3$ 时：$N_4 = N_3 \\rho_s = 27,682.4064 \\times 0.33 = 9,135.194112$。\n- 当 $l=4$ 时：$N_5 = N_4 \\rho_s = 9,135.194112 \\times 0.33 = 3,014.61405696$。\n- 当 $l=5$ 时：$N_6 = N_5 \\rho_s = 3,014.61405696 \\times 0.33 \\approx 994.82$。此值大于 $500$。\n- 当 $l=6$ 时：$N_7 = N_6 \\rho_s = 994.8226387968 \\times 0.33 \\approx 328.29$。此值小于或等于 $500$。\n\n从这个序列中，我们可以看到 $L=7$ 是第一个使得 $N_L \\leq 500$ 的整数。因此，满足第一个条件的整数集合是 $\\{7, 8, 9, \\ldots\\}$。其中最小的整数是 $L=7$。\n\n**条件 2：$C_{\\mathrm{op}} \\leq 1.8$**\n\n接下来，我们评估算子复杂度 $C_{\\mathrm{op}}$。其公式为：\n$$\nC_{\\mathrm{op}} = \\frac{\\sum_{l=0}^{L} s_l N_l}{s_0 N_0}\n$$\n代入 $s_l = s_0 \\eta^l$，我们可以将其简化为：\n$$\nC_{\\mathrm{op}}(L) = \\frac{\\sum_{l=0}^{L} s_0 \\eta^l N_l}{s_0 N_0} = \\sum_{l=0}^{L} \\eta^l \\frac{N_l}{N_0}\n$$\n$C_{\\mathrm{op}}(L)$ 的值是正项之和，因此它是 $L$ 的单调递增函数。\n我们来分析求和的各项，$T_l = \\eta^l \\frac{N_l}{N_0}$：\n- 当 $l=0$ 时：$T_0 = \\eta^0 \\frac{N_0}{N_0} = 1$。\n- 当 $l=1$ 时：$\\frac{N_1}{N_0} = \\rho_a$。所以，$T_1 = \\eta^1 \\rho_a = \\frac{5}{4} \\times \\frac{1}{5} = \\frac{1}{4} = 0.25$。\n- 当 $l=2$ 时：$\\frac{N_2}{N_0} = \\rho_a^2$。所以，$T_2 = \\eta^2 \\rho_a^2 = (\\eta \\rho_a)^2 = (\\frac{1}{4})^2 = \\frac{1}{16} = 0.0625$。\n- 当 $l \\geq 3$ 时：$\\frac{N_l}{N_0} = \\frac{N_2 \\rho_s^{l-2}}{N_0} = \\rho_a^2 \\rho_s^{l-2}$。所以，$T_l = \\eta^l \\rho_a^2 \\rho_s^{l-2} = \\eta^2 \\rho_a^2 (\\eta \\rho_s)^{l-2} = T_2 (\\eta \\rho_s)^{l-2}$。\n\n比值 $\\eta \\rho_s = \\frac{5}{4} \\times \\frac{33}{100} = \\frac{165}{400} = \\frac{33}{80} = 0.4125$。\n由于该比值小于 $1$，当 $L \\to \\infty$ 时，$C_{\\mathrm{op}}$ 的和是收敛的。我们可以计算其极限值，看是否会违反约束条件。\n$$\nC_{\\mathrm{op}}(\\infty) = T_0 + T_1 + T_2 + \\sum_{l=3}^{\\infty} T_l = T_0 + T_1 + T_2 + T_2 \\sum_{l=3}^{\\infty} (\\eta \\rho_s)^{l-2}\n$$\n令 $k = l-2$。求和变为 $\\sum_{k=1}^{\\infty} (\\eta \\rho_s)^k$。这是一个首项和公比均为 $r = \\eta \\rho_s$ 的几何级数。其和为 $\\frac{r}{1-r}$。\n$$\n\\sum_{k=1}^{\\infty} (\\eta \\rho_s)^k = \\frac{\\eta \\rho_s}{1 - \\eta \\rho_s} = \\frac{0.4125}{1 - 0.4125} = \\frac{0.4125}{0.5875} = \\frac{33/80}{47/80} = \\frac{33}{47}\n$$\n所以，$C_{\\mathrm{op}}(\\infty) = 1 + 0.25 + 0.0625 + 0.0625 \\times \\frac{33}{47} = 1.3125 + \\frac{1}{16} \\times \\frac{33}{47} = 1.3125 + \\frac{33}{752} \\approx 1.3125 + 0.04388 \\approx 1.35638$。\n\n由于算子复杂度 $C_{\\mathrm{op}}(L)$ 是 $L$ 的单调递增函数，且其在 $L \\to \\infty$ 时的极限值约为 $1.356$，远低于约束 $C_{\\max}=1.8$，因此对于所有可能的 $L \\geq 0$ 值，条件 $C_{\\mathrm{op}} \\leq 1.8$ 都得到满足。\n\n**结论**\n\n我们需要找到满足两个条件的最小整数 $L$。\n- 满足 $N_L \\leq 500$ 的 $L$ 值集合是 $\\{7, 8, 9, \\ldots\\}$。\n- 满足 $C_{\\mathrm{op}} \\leq 1.8$ 的 $L$ 值集合是 $\\{0, 1, 2, \\ldots\\}$。\n\n这两个集合的交集是 $\\{7, 8, 9, \\ldots\\}$。此交集中的最小整数是 $7$。\n\n因此，使两个条件同时成立的最小整数 $L$ 是 $7$。", "answer": "$$\n\\boxed{7}\n$$", "id": "3362567"}, {"introduction": "AMG方法的有效性取决于“逼近性质”——即粗网格能够有效表示平滑器无法消除的误差分量。此性质直接由粗化策略，特别是插值算子 $P$ 的构造方式决定。通过实现和比较两种截然不同的策略 [@problem_id:3362508]，您将直接洞察理论上的粗化选择如何转化为实际的求解器性能，并用双网格收敛因子进行衡量。", "problem": "考虑一个对称正定线性系统，该系统由单位区间上具有齐次狄利克雷边界条件的一维泊松方程的标准中心差分离散化产生。离散算子是一个三对角矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其对角线元素为 $2$，次对角线和超对角线元素为 $-1$，作用于 $n$ 个内部自由度。\n\n代数多重网格（AMG）中的两网格法由两个基本部分构成：一个光滑子和一个粗网格校正。对于权重 $\\omega \\in (0,1)$，加权雅可比光滑子由迭代矩阵定义\n$$\nS(\\omega) = I - \\omega D^{-1} A,\n$$\n其中 $D$ 是 $A$ 的对角部分，$I$ 是大小为 $n$ 的单位矩阵。使用 $\\nu_1 \\in \\mathbb{N}_0$ 步前光滑和 $\\nu_2 \\in \\mathbb{N}_0$ 步后光滑，总的光滑算子分别为 $S(\\omega)^{\\nu_1}$ 和 $S(\\omega)^{\\nu_2}$。粗网格校正由延长算子 $P \\in \\mathbb{R}^{n \\times n_c}$、限制算子 $R \\in \\mathbb{R}^{n_c \\times n}$ 和伽辽金粗算子定义\n$$\nA_c = R A P \\in \\mathbb{R}^{n_c \\times n_c}.\n$$\n两网格误差传播算子为\n$$\nE_{\\mathrm{TG}} = S(\\omega)^{\\nu_2} \\left( I - P A_c^{-1} R A \\right) S(\\omega)^{\\nu_1}.\n$$\n我们关心的量是谱半径\n$$\n\\rho\\left(E_{\\mathrm{TG}}\\right) = \\max\\{ |\\lambda| : \\lambda \\text{ 是 } E_{\\mathrm{TG}} \\text{ 的一个特征值} \\},\n$$\n它预测了在 $\\ell_2$-范数下每个两网格循环的线性收敛因子。粗空间维数是 $n_c$，即粗网格自由度的数量，等于 $P$ 的列数。\n\n实现并比较两种代数粗化策略：\n\n- 策略 $\\mathrm{R2\\text{-}LI\\text{-}FW}$（比率为2的粗化、线性插值、全加权）：\n  - 选择粗网格索引为每隔一个的细网格索引（在基于1的索引中，索引为 $2,4,6,\\dots$ 直至 $n$）。\n  - 通过分段线性插值定义 $P$：粗网格点以权重 $1$ 注入，位于两个相邻粗网格点之间的细网格点以权重和为 $1$ 的方式进行线性插值；在只有一个相邻粗网格点的边界邻近细网格点处，使用权重 $1$ 插值到该邻居。\n  - 通过全加权定义 $R$：对于与细网格索引 $i$ 相关联的粗网格索引，在细网格索引 $i-1$ 和 $i+1$（如果存在）上设置权重 $\\frac{1}{2}$，在细网格索引 $i$ 上设置权重 $1$。\n- 策略 $\\mathrm{A3\\text{-}PC}$（按大小为3的连续块聚合，分段常数）：\n  - 将有序的细网格索引集划分为大小为 $3$ 的连续聚合体（最后一个聚合体可能更小）；因此，在基于1的索引中，第 $k$ 个聚合体是集合 $\\{3k+1,3k+2,3k+3\\}$，对所有有效的 $k$ 均如此。\n  - 定义 $P$ 在聚合体上为分段常数：如果细网格索引 $i$ 在聚合体 $j$ 中，则 $P_{ij} = 1$，否则 $P_{ij} = 0$。\n  - 定义 $R = P^\\top$。\n\n对于下面的每个测试用例，您必须计算粗空间维数 $n_c$ 和上面定义的谱半径 $\\rho(E_{\\mathrm{TG}})$。使用所描述的精确 $A$、给定的精确 $S(\\omega)$ 和 $E_{\\mathrm{TG}}$，以及精确的 $A_c = R A P$ 而不进行任何近似。\n\n测试套件：\n- 用例 1：$n = 63$，策略 $\\mathrm{R2\\text{-}LI\\text{-}FW}$，$\\omega = \\tfrac{2}{3}$，$\\nu_1 = 1$，$\\nu_2 = 1$。\n- 用例 2：$n = 63$，策略 $\\mathrm{A3\\text{-}PC}$，$\\omega = \\tfrac{2}{3}$，$\\nu_1 = 1$，$\\nu_2 = 1$。\n- 用例 3：$n = 31$，策略 $\\mathrm{R2\\text{-}LI\\text{-}FW}$，$\\omega = 0.8$，$\\nu_1 = 2$，$\\nu_2 = 0$。\n- 用例 4：$n = 5$，策略 $\\mathrm{A3\\text{-}PC}$，$\\omega = 0.5$，$\\nu_1 = 1$，$\\nu_2 = 1$。\n- 用例 5：$n = 3$，策略 $\\mathrm{A3\\text{-}PC}$，$\\omega = \\tfrac{2}{3}$，$\\nu_1 = 1$, $\\nu_2 = 1$。\n\n您的程序必须：\n- 根据规范从第一性原理构造 $A$、$P$ 和 $R$。\n- 对每个用例，构建 $S(\\omega)$、$A_c$、$E_{\\mathrm{TG}}$，并计算 $n_c$ 和 $\\rho\\left(E_{\\mathrm{TG}}\\right)$。\n- 将每个 $\\rho\\left(E_{\\mathrm{TG}}\\right)$ 四舍五入到恰好 $6$ 位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素都是一个双元素列表 $[n_c,\\rho]$，顺序与测试套件相同。例如，一个包含三个用例的输出应类似于 $[[n_{c,1},\\rho_1],[n_{c,2},\\rho_2],[n_{c,3},\\rho_3]]$，其中每个 $\\rho_j$ 都精确打印到 $6$ 位小数，且没有多余的空格。不应打印任何其他文本。", "solution": "首先验证问题，以确保其科学上可靠、适定且客观。\n\n### 第1步：提取已知条件\n- **系统矩阵**：矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是用于一维泊松方程的三对角矩阵，其对角线元素为 $2$，次对角线和超对角线元素为 $-1$。\n- **加权雅可比光滑子迭代矩阵**：$S(\\omega) = I - \\omega D^{-1} A$，其中 $D$ 是 $A$ 的对角部分，$I$ 是单位矩阵，$\\omega \\in (0,1)$ 是一个权重。\n- **光滑步骤**：$\\nu_1 \\in \\mathbb{N}_0$ 步前光滑和 $\\nu_2 \\in \\mathbb{N}_0$ 步后光滑。\n- **粗网格组件**：延长算子 $P \\in \\mathbb{R}^{n \\times n_c}$、限制算子 $R \\in \\mathbb{R}^{n_c \\times n}$ 和伽辽金粗算子 $A_c = R A P \\in \\mathbb{R}^{n_c \\times n_c}$。\n- **两网格误差传播算子**：$E_{\\mathrm{TG}} = S(\\omega)^{\\nu_2} \\left( I - P A_c^{-1} R A \\right) S(\\omega)^{\\nu_1}$。\n- **关心的量**：谱半径 $\\rho\\left(E_{\\mathrm{TG}}\\right)$，即 $E_{\\mathrm{TG}}$ 特征值的最大绝对值。\n- **策略 $\\mathrm{R2\\text{-}LI\\text{-}FW}$**：\n    - **粗化**：粗网格索引为每隔一个的细网格索引，例如 $2, 4, 6, \\dots$（基于1的索引）。\n    - **延长算子 $P$**：分段线性插值。粗网格点注入（权重为 $1$）。位于两个粗网格点之间的细网格点进行线性插值。只有一个粗网格邻居的边界邻近细网格点使用权重 $1$ 插值到该邻居。\n    - **限制算子 $R$**：全加权。对于位于细网格位置 $i$ 的粗网格索引，其权重在 $i-1$ 处为 $\\tfrac{1}{2}$，在 $i$ 处为 $1$，在 $i+1$ 处为 $\\tfrac{1}{2}$。\n- **策略 $\\mathrm{A3\\text{-}PC}$**：\n    - **粗化**：将细网格索引划分为大小为 $3$ 的连续聚合体（最后一个可能更小）。\n    - **延长算子 $P$**：分段常数。如果细网格索引 $i$ 在聚合体 $j$ 中，则 $P_{ij} = 1$，否则为 $0$。\n    - **限制算子 $R$**：$R = P^\\top$。\n- **测试用例**：\n    1. $n = 63$，策略 $\\mathrm{R2\\text{-}LI\\text{-}FW}$，$\\omega = \\tfrac{2}{3}$，$\\nu_1 = 1$，$\\nu_2 = 1$。\n    2. $n = 63$，策略 $\\mathrm{A3\\text{-}PC}$，$\\omega = \\tfrac{2}{3}$，$\\nu_1 = 1$，$\\nu_2 = 1$。\n    3. $n = 31$，策略 $\\mathrm{R2\\text{-}LI\\text{-}FW}$，$\\omega = 0.8$，$\\nu_1 = 2$，$\\nu_2 = 0$。\n    4. $n = 5$，策略 $\\mathrm{A3\\text{-}PC}$，$\\omega = 0.5$，$\\nu_1 = 1$，$\\nu_2 = 1$。\n    5. $n = 3$，策略 $\\mathrm{A3\\text{-}PC}$，$\\omega = \\tfrac{2}{3}$，$\\nu_1 = 1$，$\\nu_2 = 1$。\n- **输出要求**：对于每个用例，计算粗空间维数 $n_c$ 和谱半径 $\\rho(E_{\\mathrm{TG}})$，其中 $\\rho$ 四舍五入到 $6$ 位小数。\n\n### 第2步：使用提取的已知条件进行验证\n该问题定义明确且科学上可靠。它属于数值线性代数领域，特别是研究用于求解偏微分方程的多重网格方法。所有组件（$A$、$S(\\omega)$、$P$、$R$、$A_c$、$E_{\\mathrm{TG}}$）都是两网格分析的标准元素。粗化策略虽然具体（R2-LI-FW 有一个非标准的边界插值规则），但其描述足够精确，可以明确地实现。所有测试用例的参数都是完整且一致的。问题是自包含的，不违反任何数学或科学原理。未发现任何缺陷。\n\n### 第3步：结论与行动\n问题是**有效**的。将提供一个解决方案。\n\n### 解法\n目标是为几个测试用例计算两网格误差传播算子 $E_{\\mathrm{TG}}$ 的粗空间维数 $n_c$ 和谱半径 $\\rho(E_{\\mathrm{TG}})$。这需要根据提供的规范构造所有组成矩阵（$A$、$S(\\omega)$、$P$、$R$、$A_c$）。我们对所有与矩阵和向量相关的计算采用基于零的索引。\n\n首先，我们构造系统矩阵 $A \\in \\mathbb{R}^{n \\times n}$。它是一个对称的三对角矩阵，主对角线上为 $2$，第一条次对角线和超对角线上为 $-1$。\n$A_{ij} = \\begin{cases} 2  & i=j \\\\ -1 & |i-j|=1 \\\\ 0 & \\text{其他情况} \\end{cases}$\n\n接下来，我们定义加权雅可比光滑子 $S(\\omega) = I - \\omega D^{-1} A$。矩阵 $A$ 的对角线元素恒为 $2$，所以其对角部分为 $D=2I$。因此，$D^{-1} = \\frac{1}{2}I$，光滑子简化为 $S(\\omega) = I - \\frac{\\omega}{2} A$。前光滑和后光滑算子分别为 $S(\\omega)^{\\nu_1}$ 和 $S(\\omega)^{\\nu_2}$，通过矩阵幂运算计算。\n\n任务的核心是为两种策略中的每一种构造延长算子 $P$ 和限制算子 $R$。\n\n#### 策略 $\\mathrm{R2\\text{-}LI\\text{-}FW}$（比率为2的粗化、线性插值、全加权）\n1.  **粗化**：选择粗网格点为每隔一个的细网格点。在基于1的索引中，这些是 $\\{2, 4, 6, \\dots\\}$。在基于0的索引中，粗网格点索引为 $C = \\{1, 3, 5, \\dots, 2k+1, \\dots\\}$，对于所有满足 $2k+1  n$ 的 $k$。粗网格点的数量是 $n_c = \\lfloor n/2 \\rfloor$。纯细网格点是剩余的索引 $F = \\{0, 1, \\dots, n-1\\} \\setminus C$。\n\n2.  **延长算子 $P \\in \\mathbb{R}^{n \\times n_c}$**：此矩阵将粗网格向量映射到细网格向量。其列构成了粗空间的一组基。\n    - 对于位于细网格索引 $i=2k+1$（对应第 $k$ 个粗变量）的粗网格点，其值被注入：$P$ 中对应于一个粗网格点的行在该粗变量的列中有一个 $1$。$P_{2k+1, k} = 1$。\n    - 对于内部的纯细网格点 $i=2k$ ($k>0$)，它位于粗网格点 $i-1=2k-1$ 和 $i+1=2k+1$ 之间。它以权重 $\\frac{1}{2}$ 对它们的值进行插值。这意味着 $P_{2k, k-1} = 0.5$ 和 $P_{2k, k} = 0.5$。\n    - 对于边界邻近的细网格点，应用特殊规则。对于细网格点 $i=0$，其唯一的粗网格邻居在索引 $i=1$ 处（第 $0$ 个粗变量）。规则指定权重为 $1$，因此 $P_{0,0}=1$。类似地，如果 $n$ 是奇数，细网格点 $i=n-1$ 邻近于粗网格点 $i=n-2$（第 $(n_c-1)$ 个粗变量）。其权重为 $1$，因此 $P_{n-1, n_c-1}=1$。\n\n3.  **限制算子 $R \\in \\mathbb{R}^{n_c \\times n}$**：此矩阵将细网格向量映射到粗网格向量。\n    - 对于第 $k$ 个粗变量（与细网格索引 $i_c=2k+1$ 相关），限制是在 $i_c-1$、$i_c$ 和 $i_c+1$ 处值的加权平均。指定的模板为 $[\\frac{1}{2}, 1, \\frac{1}{2}]$。\n    - 因此，$R$ 的第 $k$ 行具有非零项：$R_{k, i_c-1} = 0.5$，$R_{k, i_c} = 1$，以及 $R_{k, i_c+1} = 0.5$，前提是这些索引在网格范围内，即在 $\\{0, \\dots, n-1\\}$ 中。\n\n#### 策略 $\\mathrm{A3\\text{-}PC}$（按大小为3的连续块聚合，分段常数）\n1.  **粗化**：细网格索引 $\\{0, 1, \\dots, n-1\\}$ 被划分为大小为 $3$ 的连续聚合体。第 $k$ 个聚合体是 $\\{3k, 3k+1, 3k+2\\}$。如果 $n$ 不是 $3$ 的倍数，最后一个聚合体可能更小。每个聚合体定义一个粗网格变量。粗网格点的数量是 $n_c = \\lceil n/3 \\rceil$。\n\n2.  **延长算子 $P \\in \\mathbb{R}^{n \\times n_c}$**：插值在聚合体上是分段常数。\n    - $P$ 的第 $k$ 列对应于第 $k$ 个聚合体。对于所有属于聚合体 $k$ 的行（细网格索引），其条目为 $1$，其他则为 $0$。\n\n3.  **限制算子 $R \\in \\mathbb{R}^{n_c \\times n}$**：限制算子定义为延长算子的转置，即 $R = P^\\top$。\n\n构造好 $A$、$S(\\omega)$、$P$ 和 $R$ 后，我们形成伽辽金粗算子 $A_c = RAP$。然后计算其逆 $A_c^{-1}$。两网格误差传播算子组装为 $E_{\\mathrm{TG}} = S(\\omega)^{\\nu_2} (I - P A_c^{-1} R A) S(\\omega)^{\\nu_1}$。最后，我们计算 $E_{\\mathrm{TG}}$ 的特征值，并通过取其绝对值的最大值来找到谱半径 $\\rho(E_{\\mathrm{TG}})$。该值四舍五入到 $6$ 位小数。\n\n每个测试用例的结果都通过系统地应用此过程来计算。", "answer": "```python\nimport numpy as np\n\ndef _construct_A(n):\n    \"\"\"Constructs the n x n discrete 1D Poisson matrix A.\"\"\"\n    if n == 0:\n        return np.array([])\n    # Start with a matrix of zeros\n    A = np.zeros((n, n))\n    # Fill diagonal with 2 and off-diagonals with -1\n    np.fill_diagonal(A, 2)\n    if n > 1:\n        np.fill_diagonal(A[1:], -1)\n        np.fill_diagonal(A[:, 1:], -1)\n    return A\n\ndef _construct_R2_LI_FW_operators(n):\n    \"\"\"Constructs P, n_c, and R for the R2-LI-FW strategy.\"\"\"\n    if n  2:\n        return np.zeros((n, 0)), 0, np.zeros((0, n))\n\n    n_c = n // 2\n    P = np.zeros((n, n_c))\n    \n    # Map from fine-grid coarse index to coarse-grid index (0-based)\n    coarse_map = {2 * k + 1: k for k in range(n_c)}\n\n    for i in range(n):\n        if i in coarse_map:  # Coarse point\n            P[i, coarse_map[i]] = 1.0\n        else:  # Fine-only point\n            if i == 0:\n                # Boundary-adjacent fine point with one coarse neighbor at index 1\n                # Coarse neighbor's coarse index is 0\n                P[i, 0] = 1.0\n            elif n % 2 != 0 and i == n - 1:\n                # Boundary-adjacent fine point (only if n is odd)\n                # Coarse neighbor is at n-2, whose coarse index is n_c-1\n                P[i, n_c - 1] = 1.0\n            else:\n                # Interior fine point, interpolate between two coarse neighbors\n                # Fine point i is even. Neighbors are i-1 and i+1.\n                coarse_neighbor1_fine_idx = i - 1\n                coarse_neighbor2_fine_idx = i + 1\n                coarse_neighbor1_coarse_idx = coarse_map[coarse_neighbor1_fine_idx]\n                coarse_neighbor2_coarse_idx = coarse_map[coarse_neighbor2_fine_idx]\n                P[i, coarse_neighbor1_coarse_idx] = 0.5\n                P[i, coarse_neighbor2_coarse_idx] = 0.5\n\n    R = np.zeros((n_c, n))\n    for j in range(n_c):\n        coarse_fine_idx = 2 * j + 1\n        if coarse_fine_idx > 0:\n            R[j, coarse_fine_idx - 1] = 0.5\n        R[j, coarse_fine_idx] = 1.0\n        if coarse_fine_idx  n - 1:\n            R[j, coarse_fine_idx + 1] = 0.5\n            \n    return P, n_c, R\n\ndef _construct_A3_PC_operators(n):\n    \"\"\"Constructs P, n_c, and R for the A3-PC strategy.\"\"\"\n    if n == 0:\n        return np.zeros((0, 0)), 0, np.zeros((0, 0))\n    \n    n_c = (n + 2) // 3  # Integer ceiling division\n    P = np.zeros((n, n_c))\n    \n    for j in range(n_c):\n        start_idx = 3 * j\n        end_idx = min(start_idx + 3, n)\n        P[start_idx:end_idx, j] = 1.0\n        \n    R = P.T\n    return P, n_c, R\n\ndef compute_spectral_radius(n, strategy, omega, nu1, nu2):\n    \"\"\"Computes n_c and rho(E_TG) for a given case.\"\"\"\n    A = _construct_A(n)\n    \n    if strategy == \"R2-LI-FW\":\n        P, n_c, R = _construct_R2_LI_FW_operators(n)\n    elif strategy == \"A3-PC\":\n        P, n_c, R = _construct_A3_PC_operators(n)\n    else:\n        raise ValueError(\"Unknown strategy\")\n\n    if n_c == 0:\n        return 0, 0.0\n\n    # Smoother\n    S_omega = np.identity(n) - (omega / 2.0) * A\n    \n    S1 = np.linalg.matrix_power(S_omega, nu1)\n    S2 = np.linalg.matrix_power(S_omega, nu2)\n    \n    # Coarse grid operator\n    A_c = R @ A @ P\n    \n    # Coarse grid correction operator\n    # For very small n_c, direct inversion is stable and efficient\n    A_c_inv = np.linalg.inv(A_c)\n    CGC = np.identity(n) - P @ A_c_inv @ R @ A\n    \n    # Two-grid error propagation operator\n    E_TG = S2 @ CGC @ S1\n    \n    # Spectral radius\n    eigenvalues = np.linalg.eigvals(E_TG)\n    spectral_radius = np.max(np.abs(eigenvalues))\n    \n    return n_c, spectral_radius\n\ndef solve():\n    test_cases = [\n        {'n': 63, 'strategy': \"R2-LI-FW\", 'omega': 2/3, 'nu1': 1, 'nu2': 1},\n        {'n': 63, 'strategy': \"A3-PC\", 'omega': 2/3, 'nu1': 1, 'nu2': 1},\n        {'n': 31, 'strategy': \"R2-LI-FW\", 'omega': 0.8, 'nu1': 2, 'nu2': 0},\n        {'n': 5, 'strategy': \"A3-PC\", 'omega': 0.5, 'nu1': 1, 'nu2': 1},\n        {'n': 3, 'strategy': \"A3-PC\", 'omega': 2/3, 'nu1': 1, 'nu2': 1},\n    ]\n\n    results = []\n    for case in test_cases:\n        n_c, rho = compute_spectral_radius(\n            case['n'], case['strategy'], case['omega'], case['nu1'], case['nu2']\n        )\n        results.append(f\"[{n_c},{rho:.6f}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3362508"}, {"introduction": "仅仅观察到一个AMG设置比另一个收敛得更快是远远不够的，更深入的理解需要诊断其背后的原因。一个高质量的插值算子 $P$ 必须能够创建一个粗糙空间，该空间能精确逼近细网格上最平滑的误差分量（即系统矩阵 $A$ 对应最小特征值的特征向量）。这个诊断练习 [@problem_id:3362523] 为您提供了一个强大的基于特征值的工具，用以量化评估给定的粗糙空间对这些关键平滑模式的“覆盖”程度，从而为不同粗化策略的性能提供清晰的解释，并指导其改进。", "problem": "您的任务是构建一个基于特征值的诊断工具，用以评估代数多重网格的粗化和延拓如何影响光滑误差模式的表示。这些光滑误差模式是针对由二维 Poisson 方程在齐次 Dirichlet 边界条件下通过标准五点离散格式产生的对称正定矩阵。此任务的基础如下：\n\n- 在 $n \\times n$ 内部网格上的离散算子是一个对称正定矩阵 $A \\in \\mathbb{R}^{N \\times N}$，其中 $N = n^2$。该矩阵通过一维二阶差分算子的 Kronecker 和构造。一维算子是三对角矩阵 $T_n = \\operatorname{tridiag}(-1,2,-1)$。\n- $A$ 的特征对 $(\\lambda_i, v_i)$ 满足 $A v_i = \\lambda_i v_i$，其中 $0  \\lambda_1 \\le \\lambda_2 \\le \\dots \\le \\lambda_N$。对于 Poisson 算子，最小的特征模态对应于最光滑的误差分量。\n- 粗空间由一个延拓算子 $P \\in \\mathbb{R}^{N \\times N_c}$ 定义。Galerkin 粗算子为 $A_c = P^{\\top} A P \\in \\mathbb{R}^{N_c \\times N_c}$。\n- 到 $\\operatorname{range}(P)$ 上的 $A$-正交投影算子是 $\\Pi_P = P \\left(P^{\\top} A P\\right)^{-1} P^{\\top} A$。对于任意向量 $x \\in \\mathbb{R}^N$，$A$-范数为 $\\lVert x \\rVert_A = \\sqrt{x^{\\top} A x}$。\n- 一个非零向量 $x$ 关于 $A$ 的 Rayleigh 商是 $\\mathcal{R}_A(x) = \\dfrac{x^{\\top} A x}{x^{\\top} x}$。如果 $y$ 是 $A_c$ 的一个特征向量，那么细网格向量 $x = P y$ 的 Rayleigh 商可作为在粗空间上逼近 $A$ 特征值的 Ritz 值。\n\n您的程序必须为每个测试用例实现以下诊断功能：\n\n1) 为 $n \\times n$ 网格构造矩阵 $A$。计算 $A$ 的 $k$ 个最小特征对 $(\\lambda_i, v_i)$。\n\n2) 根据指定的粗化策略，在每个空间维度上以粗化因子 $2$ 对正则网格构造延拓算子 $P$：\n   - 对于标记为 \"pc\"（分段常数）的类型，在一维中使用最近邻注入，并通过 Kronecker 积得到二维的 $P$。\n   - 对于标记为 \"linear\" 的类型，在一维中使用标准线性插值（对于齐次 Dirichlet 边界，因子为 $2$ 的几何粗化的精确限制/延拓），并通过 Kronecker 积得到二维的 $P$。\n\n3) 构造 $A_c = P^{\\top} A P$。对于 $A$ 的 $k$ 个最小特征向量 $v_i$ 中的每一个，计算 $A$-正交投影误差\n$$\ne_i = v_i - \\Pi_P v_i = v_i - P\\left(P^{\\top} A P\\right)^{-1} P^{\\top} A v_i,\n$$\n以及相对 $A$-范数覆盖度量\n$$\nc_i = \\frac{\\lVert e_i \\rVert_A}{\\lVert v_i \\rVert_A}。\n$$\n报告平均覆盖率 $\\overline{c} = \\dfrac{1}{k} \\sum_{i=1}^k c_i$ 和最大覆盖率 $\\max_i c_i$。\n\n4) 计算 $A_c$ 的 $k_c$ 个最小特征对 $(\\mu_j, y_j)$，其中 $k_c = \\min\\{k, N_c - 1\\}$ 以满足 $k_c  N_c$。通过 $x_j = P y_j$ 将每个粗网格特征向量映射到细网格，计算其 Rayleigh 商 $\\theta_j = \\mathcal{R}_A(x_j)$，并报告最小粗网格 Ritz 值相对于最小真实细网格特征值的相对误差：\n$$\n\\delta = \\frac{\\min_j \\theta_j - \\lambda_1}{\\lambda_1}。\n$$\n\n5) 构造一个单步光滑延拓 $P_s = \\left(I - \\omega D^{-1} A\\right) P$，其中 $D = \\operatorname{diag}(A)$，$\\omega$ 是一个固定的光滑参数。用 $P_s$ 重新计算 $\\overline{c}_s$，并报告一个改进指标\n$$\n\\text{improved} =\n\\begin{cases}\n1,   \\text{if } \\overline{c}_s  \\overline{c} - \\varepsilon,\\\\\n0,   \\text{otherwise,}\n\\end{cases}\n$$\n容差为 $\\varepsilon = 10^{-12}$。\n\n实现细节和约束：\n\n- 使用上述有限差分离散格式将 $A$ 组装成稀疏矩阵。假设为齐次 Dirichlet 边界条件。\n- 对于 \"pc\"，构建一维最近邻注入延拓 $P_1 \\in \\mathbb{R}^{n \\times m}$，其中 $m = \\lfloor n/2 \\rfloor$，并设置 $P = P_2 \\otimes P_1$，其中 $P_2 = P_1$，$\\otimes$ 表示 Kronecker 积。具体来说，对于行索引 $j \\in \\{1,\\dots,n\\}$，以单位权重映射到粗网格列 $i = \\lfloor \\frac{j+1}{2} \\rfloor$，并将其限制在 $\\{1,\\dots,m\\}$ 范围内。\n- 对于 \"linear\"，按如下方式构建一维线性插值 $P_1 \\in \\mathbb{R}^{n \\times m}$：对于偶数 $j = 2 i$，设置 $(P_1)_{j,i} = 1$；对于奇数 $j = 2 i - 1$，设置 $(P_1)_{j,i} = \\frac{1}{2}$，并且如果 $i > 1$，也设置 $(P_1)_{j,i-1} = \\frac{1}{2}$。然后设置 $P = P_2 \\otimes P_1$，其中 $P_2 = P_1$。\n- 使用 $k = 6$ 和光滑参数 $\\omega = 0.67$。\n- 所有线性代数运算必须使用浮点类型的精确算术执行；不得引入指定之外的启发式方法。\n\n测试套件：\n\n- 案例 1：$n = 16$，延拓类型 \"pc\"。\n- 案例 2：$n = 16$，延拓类型 \"linear\"。\n- 案例 3：$n = 20$，延拓类型 \"pc\"。\n\n对于每个案例，您的程序必须计算并返回列表 $[\\overline{c}, \\max_i c_i, \\delta, \\text{improved}]$，其中 $\\overline{c}$、$\\max_i c_i$ 和 $\\delta$ 是实数，$\\text{improved}$ 是 $\\{0,1\\}$ 中的整数。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔的列表的列表（例如，\"[[a,b,c,d],[e,f,g,h],[i,j,k,l]]\"）。输出中不允许有多余的空格或文本。", "solution": "用户希望实现一套诊断工具，用于分析二维 Poisson 方程的代数多重网格 (AMG) 组件。该分析涉及评估不同的延拓算子在表示细网格系统矩阵的最光滑特征向量方面的性能。这是多重网格方法开发和分析中的一个标准流程。该问题具有扎实的科学基础，算法上是明确的，并且在计算上是可行的。\n\n该分析可以分解为以下系统性步骤：\n\n1.  **系统矩阵组装**：系统矩阵 $A$ 对应于在具有齐次 Dirichlet 边界条件的 $n \\times n$ 网格上对负拉普拉斯算子进行的五点有限差分离散。总自由度为 $N = n^2$。该矩阵可以构造为两个一维二阶差分算子的 Kronecker 和，$A = I_n \\otimes T_n + T_n \\otimes I_n$，其中 $T_n$ 是 $n \\times n$ 的三对角矩阵 $\\operatorname{tridiag}(-1, 2, -1)$。所得矩阵 $A$ 是对称正定 (SPD) 的。其对角线元素均为 $4$，因此其对角阵为 $D = 4I$。\n\n2.  **细网格特征分析**：$A$ 的最小特征值对应的特征向量是网格上最光滑的模态。这些是松弛法（如 Jacobi 或 Gauss-Seidel）收敛缓慢的模态。一个有效的多重网格方法必须能够在粗网格上很好地表示这些光滑模态。我们计算 $A$ 的 $k=6$ 个最小特征值 $\\lambda_i$ 及其对应的特征向量 $v_i$。这是通过使用适用于大型稀疏对称矩阵的迭代特征求解器来实现的。特征向量 $v_i$ 是归一化的，即 $\\lVert v_i \\rVert_2 = 1$。\n\n3.  **延拓算子构造**：延拓（或插值）算子 $P$ 将向量从粗网格映射到细网格。我们考虑一种标准的粗化策略，即每个维度的网格点数减半，从 $n$ 减少到 $m = \\lfloor n/2 \\rfloor$。粗网格点的总数为 $N_c = m^2$。二维延拓算子 $P \\in \\mathbb{R}^{N \\times N_c}$ 由 Kronecker 积 $P = P_1 \\otimes P_1$ 形成，其中 $P_1 \\in \\mathbb{R}^{n \\times m}$ 是一维延拓算子。\n    *   对于 **分段常数** 插值 (\"pc\")，一个粗网格值被复制到一块相邻的细网格点上。根据所提供的公式 $i = \\lfloor(j+1)/2\\rfloor$，来自粗网格点 $i$ 的值被赋给细网格点 $2i-1$ 和 $2i$（在基于 1 的索引中）。\n    *   对于 **线性** 插值 (\"linear\")，细网格点上的值由最近的粗网格点插值得到。在齐次 Dirichlet 边界条件下，这涉及到 $\\frac{1}{2}$ 和 $1$ 的权重。所提供的具体规则正确地构造了标准的一维线性延拓矩阵。\n\n4.  **粗网格算子**：粗网格算子 $A_c$ 使用 Galerkin 投影形成：$A_c = P^\\top A P$。由于 $A$ 是 SPD 且 $P$ 是满列秩的，因此 $A_c$ 也是 SPD。\n\n5.  **投影误差和覆盖度量**：延拓算子 $P$ 的质量通过它表示光滑特征向量 $v_i$ 的能力来衡量。在 $P$ 的值域（表示为 $\\operatorname{range}(P)$）中对 $v_i$ 的最佳逼近是其 $A$-正交投影 $\\Pi_P v_i$。该投影算子由 $\\Pi_P = P(P^\\top A P)^{-1} P^\\top A$ 给出。逼近误差为 $e_i = v_i - \\Pi_P v_i$。一个关键的诊断指标是 $A$-范数下的相对误差，$c_i = \\frac{\\lVert e_i \\rVert_A}{\\lVert v_i \\rVert_A}$。\n    利用 $A$-正交投影算子的性质，对于任意向量 $x$，有 $\\lVert x \\rVert_A^2 = \\lVert \\Pi_P x \\rVert_A^2 + \\lVert (I - \\Pi_P) x \\rVert_A^2$。因此，$\\lVert e_i \\rVert_A^2 = \\lVert v_i \\rVert_A^2 - \\lVert \\Pi_P v_i \\rVert_A^2$。\n    由于 $v_i$ 是 $A$ 的特征向量，对应特征值为 $\\lambda_i$，并且是 $L_2$-归一化的，我们有 $\\lVert v_i \\rVert_A^2 = v_i^\\top A v_i = \\lambda_i v_i^\\top v_i = \\lambda_i$。\n    投影向量的范数为 $\\lVert \\Pi_P v_i \\rVert_A^2 = (\\Pi_P v_i)^\\top A (\\Pi_P v_i) = (P y_i)^\\top A (P y_i) = y_i^\\top (P^\\top A P) y_i = y_i^\\top A_c y_i$，其中 $y_i = (P^\\top A P)^{-1} P^\\top A v_i = A_c^{-1} (P^\\top A v_i)$。代入 $y_i$ 可得 $\\lVert \\Pi_P v_i \\rVert_A^2 = (P^\\top A v_i)^\\top A_c^{-1} (P^\\top A v_i) = (P^\\top A v_i)^\\top y_i$。\n    这导出了计算上高效的覆盖度量平方公式：\n    $$ c_i^2 = 1 - \\frac{\\lVert \\Pi_P v_i \\rVert_A^2}{\\lVert v_i \\rVert_A^2} = 1 - \\frac{(P^\\top A v_i)^\\top y_i}{\\lambda_i} $$\n    我们计算前 $k$ 个特征向量的这些值的平均值 $\\overline{c}$ 和最大值 $\\max_i c_i$。\n\n6.  **粗网格特征值分析**：另一种质量度量是观察粗网格问题 $A_c y = \\mu y$ 对细网格特征问题的逼近程度。$A_c$ 的特征对 $(\\mu_j, y_j)$ 为 $A$ 生成 Ritz 对 $(\\theta_j, x_j)$，其中 $x_j = P y_j$ 且 $\\theta_j$ 是 Rayleigh 商 $\\mathcal{R}_A(x_j) = \\frac{x_j^\\top A x_j}{x_j^\\top x_j}$。最小的 Ritz 值 $\\min_j \\theta_j$ 应该逼近最小的细网格特征值 $\\lambda_1$。我们计算相对误差 $\\delta = (\\min_j \\theta_j - \\lambda_1) / \\lambda_1$。为此，我们计算 $A_c$ 的 $k_c = \\min\\{k, N_c - 1\\}$ 个最小特征对。\n\n7.  **光滑延拓**：通过应用几步松弛法（光滑），通常可以提高 $P$ 的表示质量。我们对 $P$ 应用一步阻尼 Jacobi 光滑。光滑后的延拓算子为 $P_s = (I - \\omega D^{-1} A) P$，阻尼因子 $\\omega=0.67$，且 $D=\\operatorname{diag}(A)=4I$。然后我们使用 $P_s$ 重新评估平均覆盖率 $\\overline{c}_s$，并判断是否有显著改进，如果 $\\overline{c}_s  \\overline{c} - \\varepsilon$（对于一个小的容差 $\\varepsilon=10^{-12}$），则由 $\\text{improved} = 1$ 指示。这个过程模拟了 AMG 中更高级延拓算子的构造。\n\n该实现将依赖于 `scipy.sparse` 的稀疏矩阵表示来有效地管理内存和计算成本。特征问题将使用 `scipy.sparse.linalg.eigsh` 求解，而小型的稠密线性系统将由 `scipy.sparse.linalg.spsolve` 处理。", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg as sla\n\ndef build_poisson_matrix(n):\n    \"\"\"Constructs the 2D Poisson matrix A on an n x n grid.\"\"\"\n    N = n * n\n    T_n = sparse.diags([-1, 2, -1], [-1, 0, 1], shape=(n, n), format='csc')\n    I_n = sparse.identity(n, format='csc')\n    A = sparse.kronsum(T_n, T_n)\n    return A.asformat('csc')\n\ndef build_1d_prolongation(n, p_type):\n    \"\"\"Constructs the 1D prolongation operator P1.\"\"\"\n    if n % 2 != 0:\n        # The problem spec only considers even n, but for robustness\n        # one might need a specification for odd n. We adhere to problem constraints.\n        pass\n    m = n // 2\n    \n    rows, cols, data = [], [], []\n    \n    if p_type == \"pc\":\n        # Piecewise constant interpolation (aggregation of size 2)\n        # 1-based index: j maps to i = floor((j+1)/2)\n        # 0-based index: j maps to i = floor(j/2)\n        for j in range(n):\n            i = j // 2\n            if i  m:\n                rows.append(j)\n                cols.append(i)\n                data.append(1.0)\n    elif p_type == \"linear\":\n        # Linear interpolation\n        # 1-based index: j=2i injects from i. j=2i-1 interpolates from i-1 and i.\n        # 0-based index: coarse node i is at fine 2i+1. fine node 2i interpolates.\n        for i in range(m):\n            # Injection at coarse nodes (maps to odd fine nodes in 0-based)\n            rows.append(2 * i + 1)\n            cols.append(i)\n            data.append(1.0)\n            \n            # Interpolation at fine-only nodes (even fine nodes in 0-based)\n            j_fine = 2 * i\n            if j_fine  n:\n                if i > 0:\n                    rows.append(j_fine)\n                    cols.append(i - 1)\n                    data.append(0.5)\n                # Boundary case for j=0, interpolates between boundary (0) and coarse node 0.\n                rows.append(j_fine)\n                cols.append(i)\n                data.append(0.5)\n\n    return sparse.coo_matrix((data, (rows, cols)), shape=(n, m)).asformat('csc')\n\ndef compute_coverage_metrics(A, P, k, lambdas, vecs):\n    \"\"\"Computes mean and max coverage for a given prolongation P.\"\"\"\n    A_c = P.T @ A @ P\n    \n    coverages = np.zeros(k)\n    for i in range(k):\n        v = vecs[:, i]\n        lambda_i = lambdas[i]\n        \n        b_i = P.T @ (A @ v)\n        \n        y_i = sla.spsolve(A_c, b_i)\n\n        inner_prod = b_i.T @ y_i\n        \n        if abs(lambda_i)  1e-15: \n            c_i_sq = 1.0\n        else:\n            c_i_sq = 1.0 - inner_prod / lambda_i\n        \n        coverages[i] = np.sqrt(max(0, c_i_sq))\n        \n    mean_c = np.mean(coverages)\n    max_c = np.max(coverages)\n    \n    return mean_c, max_c\n\ndef run_case(n, p_type, k, omega, epsilon):\n    \"\"\"Runs a single test case for the AMG diagnostic problem.\"\"\"\n    # 1. Construct A and get its smallest eigenpairs\n    A = build_poisson_matrix(n)\n    N = n * n\n    lambdas, vecs = sla.eigsh(A, k=k, which='SM')\n\n    # 2. Construct prolongation operator P\n    m = n // 2\n    Nc = m * m\n    P1d = build_1d_prolongation(n, p_type)\n    P = sparse.kron(P1d, P1d, format='csc')\n\n    # 3. Compute coverage metrics for P\n    c_bar, c_max = compute_coverage_metrics(A, P, k, lambdas, vecs)\n    \n    # 4. Compute coarse Ritz value error\n    A_c = P.T @ A @ P\n    kc = min(k, Nc - 1)\n    \n    mu, Y = sla.eigsh(A_c, k=kc, which='SM')\n    \n    thetas = np.zeros(kc)\n    for j in range(kc):\n        y_j = Y[:, j]\n        x_j = P @ y_j\n        \n        numerator = x_j.T @ A @ x_j\n        denominator = x_j.T @ x_j\n        thetas[j] = numerator / denominator\n    \n    min_theta = np.min(thetas) if kc > 0 else np.inf\n    lambda_1 = lambdas[0]\n    delta = (min_theta - lambda_1) / lambda_1\n\n    # 5. Compute smoothed prolongation and its coverage\n    D_diag = A.diagonal()\n    d_inv = 1.0 / D_diag[0] # Constant diagonal for this problem\n    Ps = P - (omega * d_inv) * (A @ P)\n\n    cs_bar, _ = compute_coverage_metrics(A, Ps, k, lambdas, vecs)\n    \n    improved = 1 if cs_bar  c_bar - epsilon else 0\n    \n    return [c_bar, c_max, delta, improved]\n\ndef solve():\n    \"\"\"\n    Main function to execute the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (16, \"pc\"),\n        (16, \"linear\"),\n        (20, \"pc\"),\n    ]\n    \n    k = 6\n    omega = 0.67\n    epsilon = 1e-12\n    \n    results = []\n    for n, p_type in test_cases:\n        case_result = run_case(n, p_type, k, omega, epsilon)\n        # Format with general precision to avoid trailing zeros but ensure enough digits.\n        formatted_result = [f\"{x:.7g}\" for x in case_result]\n        # Ensure the last element is an integer\n        formatted_result[-1] = str(int(float(formatted_result[-1])))\n        results.append(f\"[{','.join(formatted_result)}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3362523"}]}