{"hands_on_practices": [{"introduction": "自适应网格加密的核心问题在于：在有限的计算资源下，哪种加密操作——分裂单元（$h$）、提升多项式阶数（$p$）或移动节点（$r$）——能带来最大的“效益”？本练习将指导您构建一个简单而强大的决策模型，通过量化每种加密策略单位成本所带来的误差减少量，来回答这一问题。这为您提供了自适应网格加密背后战略思想的具体实现。[@problem_id:3360869]", "problem": "针对一维空间中的自适应网格加密，构建一个成本感知的决策模型，该模型评估三种加密策略（$h$-加密、$p$-加密和$r$-加密）下每自由度的边际误差减少量。$h$-加密指在固定多项式次数下对单元进行二等分，$p$-加密指局部提升多项式次数，$r$-加密指通过局部节点重定位来收缩单元。工作背景为：使用连续分片多项式有限元在区间上逼近一个已知函数 $u(x)$，并通过 $H^1$ 半范数下的最佳逼近误差来衡量单个单元上的局部离散误差。对于每个指定的测试用例，使用此决策模型选择能够最大化单位成本下估计边际误差减少量的单一加密操作。\n\n您的推导和算法必须基于以下基本定义和事实：\n- 函数 $v$ 在区间 $I = [a,b]$ 上的 $H^1$ 半范数为 $\\|v\\|_{H^1(I)} := \\left(\\int_a^b |v'(x)|^2 \\, dx \\right)^{1/2}$。\n- 对于固定的单元 $I=[a,b]$ 和多项式次数 $p \\in \\mathbb{N}$， $I$ 上的局部有限元空间由次数至多为 $p$ 的多项式组成。其导数张成了 $I$ 上所有次数至多为 $p-1$ 的多项式空间。\n- $I$ 上 $H^1$ 半范数下的最佳逼近误差等于 $u'(x)$ 在 $I$ 上次数至多为 $p-1$ 的多项式子空间上的 $L^2(I)$ 投影误差。\n- 在希尔伯特空间中，正交投影最小化了残差在子空间上的范数。\n\n您必须：\n1. 对于给定的单元 $I=[a,b]$ 和次数 $p$，计算当前局部误差 $E_0(I,p)$，其值为 $\\int_a^b |u'(x)-q(x)|^2\\,dx$ 在所有次数至多为 $p-1$ 的多项式 $q$ 上的最小值。\n2. 对于 $h$-加密，用两个子单元 $I_1=[a,(a+b)/2]$ 和 $I_2=[(a+b)/2,b]$ 替换 $I$，次数 $p$ 保持不变。计算 $E_h(I,p) := E_0(I_1,p) + E_0(I_2,p)$。\n3. 对于 $p$-加密，将 $I$ 上的次数提升至 $p+1$，并计算 $E_p(I,p) := E_0(I,p+1)$。\n4. 对于 $r$-加密，将单元长度按因子 $s \\in (0,1)$ 收缩，同时保持其左端点固定，即 $I_r = [a, a + s(b-a)]$，次数 $p$ 保持不变。计算 $E_r(I,p,s) := E_0(I_r,p)$。\n\n将每种操作的单位成本边际误差减少量定义为\n- $G_h := \\dfrac{\\max\\{E_0(I,p) - E_h(I,p), 0\\}}{C_h(p)}$，\n- $G_p := \\dfrac{\\max\\{E_0(I,p) - E_p(I,p), 0\\}}{C_p}$，\n- $G_r := \\dfrac{\\max\\{E_0(I,p) - E_r(I,p,s), 0\\}}{C_r}$，\n\n成本模型如下（以等效自由度计算）：\n- $C_h(p) := p$ 用于二等分一个次数为 $p$ 的单元，\n- $C_p := 1$ 用于将一个单元的次数 $p$ 提升至 $p+1$，\n- $C_r := c_r$ 用于通过给定因子 $s$ 重定位节点以收缩一个单元，其中 $c_r > 0$ 是给定的。\n\n使用高阶高斯-勒让德求积法来评估所需积分，以确保数值稳定性，并使用参考区间上的正交多项式来构建 $L^2$ 投影，不依赖任何预先计算的快捷公式。所有单元、变量、算子和常数都必须以数学精度处理。\n\n决策规则：对每个测试用例，计算 $G_h$、$G_p$ 和 $G_r$。选择使增益最大化的操作。如果在增益的 $10^{-12}$ 数值容差内出现平局，则按照 $h \\rightarrow p \\rightarrow r$ 的顺序选择索引最小的操作来打破平局。\n\n用于验证不同正则性机制的基准函数 $u(x)$：\n- 光滑解析函数：在 $[0,1]$ 上 $u(x) = \\sin(\\pi x)$。\n- 端点奇异函数（但 $H^1$ 可容许）：在 $[0,1]$ 上 $u(x) = x^{\\alpha}$，其中 $\\alpha = 0.6$。\n\n不涉及角度单位。没有物理单位；所有量均为无量纲。\n\n测试套件：\n对于每个测试用例，您将获得一个元组，指定基准类型、单元区间 $[a,b]$、多项式次数 $p$、$r$-收缩因子 $s$ 和 $r$-成本 $c_r$。对于奇异情况，使用 $\\alpha = 0.6$。测试用例如下：\n- 用例 1：光滑函数，$[a,b]=[0,0.5]$，$p=2$，$s=0.7$，$c_r=1.0$。\n- 用例 2：光滑函数，$[a,b]=[0.5,1]$，$p=2$，$s=0.7$，$c_r=1.0$。\n- 用例 3：奇异函数，$[a,b]=[0,0.5]$，$p=2$，$s=0.7$，$c_r=1.0$。\n- 用例 4：奇异函数，$[a,b]=[0.5,1]$，$p=2$，$s=0.7$，$c_r=1.0$。\n\n您的程序应：\n- 按规定实现该模型。\n- 对于每种情况，输出一个整数编码来表示所选操作，使用 $0$ 表示 $h$-加密，$1$ 表示 $p$-加密，$2$ 表示 $r$-加密。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 `[r_1,r_2,r_3,r_4]`，其中每个 $r_i$ 是按上述顺序给出的第 $i$ 个用例的整数决策。不应产生任何其他输出。", "solution": "用户提供的问题是数值分析领域中一个有效且适定的练习，特别是在自适应有限元方法领域。它要求构建并应用一个决策模型，以在 $h$-、$p$- 和 $r$-加密策略中选择最优的网格加密策略。决策基于最大化单位计算成本下的边际误差减少量。问题的所有组成部分——误差度量、加密策略、成本模型和决策规则——都经过了精确的数学定义，使其成为一个基于既定科学原理的可解问题。\n\n解决方案首先对局部误差的计算进行形式化，然后详细说明每种加密策略的增益计算，最后指定决策逻辑。\n\n### 1. 局部误差计算\n\n模型的核心是计算单个单元 $I = [a,b]$ 上多项式次数为 $p$ 的局部离散误差。问题将此误差定义为 $H^1$ 半范数下的最佳逼近误差。一个关键的已知事实简化了这一点：有限元逼近的 $H^1$ 半范数误差的平方等于其导数的 $L^2$ 范数误差的平方。\n\n具体来说，我们想计算 $E_0(I, p)$，它是函数导数 $u'(x)$ 被一个次数至多为 $p-1$ 的多项式 $q(x)$ 最佳逼近时的平方 $L^2(I)$ 误差。令 $\\mathcal{P}_{k}(I)$ 表示在区间 $I$ 上次数至多为 $k$ 的多项式空间。误差由以下公式给出：\n$$\nE_0(I, p) = \\min_{q \\in \\mathcal{P}_{p-1}(I)} \\int_a^b |u'(x) - q(x)|^2 \\, dx\n$$\n根据希尔伯特空间理论，当 $q$ 是 $u'$ 在 $\\mathcal{P}_{p-1}(I)$ 上的正交 $L^2$ 投影时，达到最小值。设此投影为 $\\Pi_{p-1} u'$。则误差为残差范数的平方：\n$$\nE_0(I, p) = \\|u' - \\Pi_{p-1} u'\\|_{L^2(I)}^2\n$$\n为了数值计算，我们采用一种标准技术，通过仿射变换 $x(\\xi) = a + \\frac{b-a}{2}(\\xi+1)$ 将物理单元 $I = [a,b]$ 映射到参考单元 $\\hat{I} = [-1,1]$。此映射的雅可比行列式为 $J = \\frac{b-a}{2}$。积分变换为 $\\int_a^b f(x) \\, dx = \\int_{-1}^1 f(x(\\xi)) J \\, d\\xi$。\n\n在参考单元上，我们使用勒让德多项式基 $\\{\\hat{L}_k(\\xi)\\}_{k=0}^{\\infty}$，它们关于 $[-1,1]$ 上的标准 $L^2$ 内积是正交的：\n$$\n\\int_{-1}^1 \\hat{L}_i(\\xi) \\hat{L}_j(\\xi) \\, d\\xi = \\frac{2}{2i+1}\\delta_{ij}\n$$\n其中 $\\delta_{ij}$ 是克罗内克δ函数。变换后的导数 $\\hat{u}'(\\xi) = u'(x(\\xi))$ 在 $\\mathcal{P}_{p-1}(\\hat{I})$ 上的投影是 $\\Pi_{p-1}\\hat{u}' = \\sum_{k=0}^{p-1} c_k \\hat{L}_k(\\xi)$，其系数为 $c_k = \\frac{\\langle \\hat{u}', \\hat{L}_k \\rangle}{\\langle \\hat{L}_k, \\hat{L}_k \\rangle}$。\n\n根据正交投影的勾股定理，物理单元上的误差可以计算为：\n$$\nE_0(I, p) = J \\left( \\|\\hat{u}'\\|_{L^2(\\hat{I})}^2 - \\|\\Pi_{p-1}\\hat{u}'\\|_{L^2(\\hat{I})}^2 \\right)\n$$\n其中 $\\|\\hat{u}'\\|_{L^2(\\hat{I})}^2 = \\int_{-1}^1 |\\hat{u}'(\\xi)|^2 \\, d\\xi$ 且 $\\|\\Pi_{p-1}\\hat{u}'\\|_{L^2(\\hat{I})}^2 = \\sum_{k=0}^{p-1} \\frac{\\left( \\int_{-1}^1 \\hat{u}'(\\xi)\\hat{L}_k(\\xi) \\, d\\xi \\right)^2}{\\int_{-1}^1 |\\hat{L}_k(\\xi)|^2 \\, d\\xi}$。\n所有积分都使用高阶高斯-勒让德求积法进行数值计算，以确保准确性。\n\n### 2. 加密策略与增益计算\n\n建立了误差计算方法后，我们对给定的单元 $I=[a,b]$ 和次数 $p$ 评估三种加密策略。\n\n**当前状态：** 初始误差为 $E_{current} = E_0(I, p)$。\n\n**a) $h$-加密：** 单元 $I$ 被二等分为两个子单元 $I_1 = [a, (a+b)/2]$ 和 $I_2 = [(a+b)/2, b]$，多项式次数 $p$ 保持不变。加密后的总误差是子单元上误差之和：\n$$\nE_h(I, p) = E_0(I_1, p) + E_0(I_2, p)\n$$\n成本给定为 $C_h(p) = p$。增益为：\n$$\nG_h = \\frac{\\max\\{0, E_{current} - E_h(I, p)\\}}{C_h(p)}\n$$\n\n**b) $p$-加密：** 原始单元 $I$ 上的多项式次数增加到 $p+1$。加密后的误差为：\n$$\nE_p(I, p) = E_0(I, p+1)\n$$\n成本为 $C_p = 1$。增益为：\n$$\nG_p = \\frac{\\max\\{0, E_{current} - E_p(I, p)\\}}{C_p}\n$$\n\n**c) $r$-加密：** 单元 $I$ 按给定因子 $s$ 收缩为 $I_r = [a, a + s(b-a)]$，而次数 $p$ 保持不变。所得误差在此较小单元上计算：\n$$\nE_r(I, p, s) = E_0(I_r, p)\n$$\n成本为给定常数 $C_r = c_r$。根据问题定义，增益为：\n$$\nG_r = \\frac{\\max\\{0, E_{current} - E_r(I, p, s)\\}}{C_r}\n$$\n\n### 3. 决策模型\n\n对于每个测试用例，计算增益 $G_h$、$G_p$ 和 $G_r$。决策规则是选择与最大增益相对应的加密策略。如果出现平局，即两个或多个增益之间的差异小于 $10^{-12}$ 的容差，则按照规定的顺序 $h$-加密（索引 $0$）、$p$-加密（索引 $1$）和 $r$-加密（索引 $2$）选择索引最小的策略来打破平局。将此过程应用于每个测试用例，以确定最优操作。实现将处理指定的基准函数，一个光滑函数和一个带端点奇异性的函数，以测试模型在不同函数正则性条件下的行为。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\n\ndef compute_error_squared(u_prime_func, interval, p_degree, n_quad=100):\n    \"\"\"\n    Computes the squared H^1-seminorm best-approximation error on an element.\n\n    This is equivalent to the L^2 projection error of the derivative u' onto\n    the space of polynomials of degree p-1.\n\n    Args:\n        u_prime_func (callable): The derivative of the function to approximate, u'(x).\n        interval (list or tuple): The element interval [a, b].\n        p_degree (int): The polynomial degree of the finite element space. Projection is onto P_{p-1}.\n        n_quad (int): The number of Gauss-Legendre quadrature points.\n\n    Returns:\n        float: The computed squared error E_0(I, p).\n    \"\"\"\n    k_proj = p_degree - 1\n    a, b = interval\n\n    if abs(a - b)  1e-15:\n        return 0.0\n\n    nodes, weights = np.polynomial.legendre.leggauss(n_quad)\n    \n    jac = (b - a) / 2.0\n    x_phys = jac * nodes + (a + b) / 2.0\n    \n    u_prime_vals_at_ref_nodes = u_prime_func(x_phys)\n    \n    # Compute the squared L2 norm of u' on the reference interval\n    norm_u_prime_sq = np.sum(weights * u_prime_vals_at_ref_nodes**2)\n    \n    # Compute the squared L2 norm of the projection of u'\n    sum_of_proj_coeffs_sq_norm = 0.0\n    if k_proj >= 0:\n        for j in range(k_proj + 1):\n            # Evaluate j-th Legendre polynomial at quadrature nodes\n            L_j_vals = special.eval_legendre(j, nodes)\n            \n            # Compute inner product", "id": "3360869"}, {"introduction": "在上一练习的后验误差估计策略基础上，我们转向一种更具前瞻性的理论驱动方法。本练习将探索一个深刻的思想：如果我们预先知道解在复平面上的奇点位置，我们就能预测不同加密策略在何处最为有效。您将把近似理论中的伯恩斯坦椭圆（Bernstein ellipse）等概念与一个实用的算法联系起来，用于决定采用 $h$ 型或 $p$ 型加密，甚至为 $r$ 型加密的节点移动方向提供建议。[@problem_id:3360857]", "problem": "您的任务是设计、实现并测试一种用于有界一维区间上偏微分方程解的多项式逼近的hp-自适应算法，该算法基于解析延拓估计。目标是根据从复平面中解的最近奇点推断出的解析性信息，在每个网格单元上确定是优先选择$p$-加密、$h$-加密，还是建议进行网格节点的$r$-移动。该方法必须有理论依据，并源于解析函数的基本逼近理论。\n\n从以下基础且经过充分检验的事实出发：\n\n- 如果一个函数在一个包含给定闭区间的开区域内是解析的，特别是在一个以该区间端点为焦点、参数 $\\rho$ 且 $\\rho > 1$ 的伯恩斯坦椭圆内部是解析的，那么在该区间上的最佳多项式逼近误差会随着多项式次数 $p$ 的增加以 $\\mathcal{O}(\\rho^{-p})$ 的速度几何衰减。这是多项式逼近理论中的一个经典结果，也是谱方法和有限元法（FEM）中的一个标准工具。缩写词 $FEM$ 指的是有限元法（Finite Element Method），而hp-加密表示网格尺寸（$h$）和多项式次数（$p$）的组合自适应策略。\n- 复平面奇点与实轴子区间上的伯恩斯坦椭圆参数 $\\rho$ 之间的关系由茹科夫斯基逆映射给出，该映射将物理坐标中的解析延拓域与辅助复平面中的圆联系起来。在将区间映射到参考区间并应用茹科夫斯基逆变换后，椭圆参数 $\\rho$ 由最接近该区间的奇点确定。\n- 当一个奇点位于单元内部的实轴上时，跨该区间的解析延拓无法延伸到区间本身之外，这意味着有效的 $\\rho$ 最多为 $1$，并且纯粹的 $p$-加密无法实现指数收敛。这启发了 $h$-加密或 $r$-移动策略。\n\n您的程序必须基于这些原则实现一个 $hp$ 决策过程，并提供一个定量的 $r$-移动建议。考虑一个被划分为 $N$ 个均匀单元的一维域 $[0,1]$。给定物理坐标中的一组复奇点 $\\{s_k\\}$、一个目标单元误差容限 $\\tau$、一个指示值得利用的指数 $p$-收敛开始的最小解析性阈值 $\\rho_{\\min}  1$、一个最大允许的多项式次数 $p_{\\max} \\in \\mathbb{N}$，以及一个 $r$-移动积极性参数 $\\theta \\in (0,1)$。\n\n对于每个单元 $I_j = [a_j,b_j]$，仅使用所述的基本原则和定义，执行以下操作：\n\n- 在从 $[a_j,b_j]$ 到参考区间的仿射映射以及茹科夫斯基逆映射下，确定由最近奇点引起的局部伯恩斯坦椭圆参数 $\\rho_j$。如果一个奇点位于 $[a_j,b_j]$ 内部的实轴上，则取 $\\rho_j = 1$。\n- 根据几何收敛原理，确定最小次数 $p_j^\\star$，使得最佳多项式逼近误差满足 $C \\rho_j^{-p_j^\\star} \\le \\tau$ 形式的界，其中 $C$ 是一个良性常数，为了计算规则的目的，您可以将其归一化为 $C=1$。如果 $\\rho_j \\le 1$，则设置 $p_j^\\star = +\\infty$。\n- 分类规则：\n  - 如果 $\\rho_j  \\rho_{\\min}$ 且 $p_j^\\star \\le p_{\\max}$，则将该单元分类为 $p$-可接受（在该单元上优先进行 $p$-加密）。\n  - 否则，将其分类为 $h$-候选（在该单元上优先进行 $h$-加密）。\n- $r$-移动建议：对于相邻单元之间的每个内部界面，如果两个相邻单元中恰好一个是 $h$-候选，另一个是 $p$-可接受，则计算一个建议的界面位移量 $\\delta$，该位移量与局部解析性对比度成正比。使用一个基于 $1/\\rho$ 对比度的量纲一致的代理，该代理通过两个相邻单元的并集长度和 $\\theta$ 进行缩放。通过对所有内部界面的这些贡献求和，并将总和除以域长度，来汇总总的归一化 $r$-移动建议。\n\n您的程序不得读取任何输入，而应精确实现以下测试套件，每个测试用例由 $[N, \\{s_k\\}, \\tau, p_{\\max}, \\rho_{\\min}, \\theta]$ 定义：\n\n- 测试用例 1（一般情况，解析性远离实轴）：$N = 4$，$\\{s_k\\} = \\{0.5 + 1.0\\,\\mathrm{i}\\}$，$\\tau = 10^{-6}$，$p_{\\max} = 12$，$\\rho_{\\min} = 1.05$，$\\theta = 0.25$。\n- 测试用例 2（实轴上的分支点）：$N = 4$，$\\{s_k\\} = \\{0.3 + 0.0\\,\\mathrm{i}\\}$，$\\tau = 10^{-3}$，$p_{\\max} = 10$，$\\rho_{\\min} = 1.02$，$\\theta = 0.25$。\n- 测试用例 3（混合奇点）：$N = 8$，$\\{s_k\\} = \\{0.25 + 0.2\\,\\mathrm{i},\\, 0.75 + 0.0\\,\\mathrm{i}\\}$，$\\tau = 10^{-4}$，$p_{\\max} = 10$，$\\rho_{\\min} = 1.05$，$\\theta = 0.30$。\n- 测试用例 4（附近的复奇点）：$N = 4$，$\\{s_k\\} = \\{0.5 + 0.05\\,\\mathrm{i}\\}$，$\\tau = 10^{-2}$，$p_{\\max} = 8$，$\\rho_{\\min} = 1.10$，$\\theta = 0.20$。\n\n对于每个测试用例，您的程序必须输出一个包含三个值的列表：\n\n- $H$：被分类为 $h$-候选的单元数量（一个整数）。\n- $P_{\\max}^{\\mathrm{sel}}$：在被分类为 $p$-可接受的单元中 $p_j^\\star$ 的最大值（一个整数；如果没有 $p$-可接受的单元，则输出 $0$）。\n- $\\mathcal{R}$：按上述方法计算的总归一化 $r$-移动建议，四舍五入到 $6$ 位小数（一个浮点数）。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表，其中每个条目本身是对应测试用例的列表 $[H, P_{\\max}^{\\mathrm{sel}}, \\mathcal{R}]$。例如，一个包含两个假设用例的输出可能看起来像 $[[2,7,0.031415],[0,5,0.0]]$。\n\n在此问题中，所有量都是无量纲的；不使用物理单位。在复数辐角中隐含的角度，按惯例以弧度为单位，但您不会直接操作角度。\n\n您的实现必须是自包含的，且不得要求任何用户输入、外部文件或网络访问。指定测试套件的数值结果必须是可复现的。", "solution": "该问题要求设计并实现一种用于一维数值方法的自适应网格加密策略。具体来说，它要求一个决策过程，用以为网格单元分类，以决定是进行多项式次数加密（$p$-加密）、网格尺寸加密（$h$-加密）还是网格顶点重分布（$r$-移动）。此决策基于关于解析函数多项式逼近的逼近理论原理。\n\n基本原理是，函数在区间 $[a, b]$ 上的最佳多项式逼近的收敛率由该函数在复平面内的解析性决定。如果一个函数在以 $a$ 和 $b$ 为焦点的伯恩斯坦椭圆内是解析的，那么多项式次数为 $p$ 的最佳逼近误差在最大范数下会指数衰减，其速率与此椭圆的大小有关。该大小由参数 $\\rho$ 表示，即椭圆半长轴和半短轴之和，其中焦点之间的距离被归一化。误差由 $\\mathcal{O}(\\rho^{-p})$ 界定。更大的 $\\rho$ 意味着更大的解析域和更快的收敛速度。函数在区间 $[a, b]$ 附近的奇点会限制可能的最大伯恩斯坦椭圆的大小，从而降低收敛率。\n\n该算法分三个主要阶段进行：单元分析、用于 $r$-移动的界面分析以及结果汇总。\n\n**1. 单元分析**\n\n域，即区间 $[0, 1]$，被划分为 $N$ 个均匀单元 $I_j = [a_j, b_j]$，其中 $j=0, 1, \\dots, N-1$。对于均匀划分，顶点位于 $x_j = j/N$，因此 $a_j = j/N$ 且 $b_j = (j+1)/N$。每个单元的长度为 $h = 1/N$。对于每个单元 $I_j$，我们执行以下步骤：\n\n**a. 解析性参数 $\\rho_j$ 的确定**\n\n参数 $\\rho_j$ 量化了函数在单元 $I_j$ 上的局部解析性。它对应于该单元包含至少一个解的奇点 $\\{s_k\\}$ 的最小伯恩斯坦椭圆。\n\ni. **映射到参考区间：** 我们首先将物理单元 $I_j = [a_j, b_j]$ 映射到标准参考区间 $\\Xi = [-1, 1]$。仿射映射为 $z(\\xi) = \\frac{2\\xi - (a_j+b_j)}{b_j-a_j}$。物理域中的每个奇点 $s_k$ 被映射到相对于参考区间的复平面中的 $z_k = z(s_k)$。\n\nii. **茹科夫斯基逆映射：** 区间 $\\Xi = [-1, 1]$ 的外部可以通过茹科夫斯基逆映射 $w(z)$ 映射到辅助复平面中单位圆盘 $|w|1$ 的外部。$|w(z)| = \\rho  1$ 的水平集恰好是以 $\\pm 1$ 为焦点的伯恩斯坦椭圆。通过点 $z$ 的椭圆参数 $\\rho$ 由 $|w(z)|$ 给出。该映射是 $z = \\frac{1}{2}(w+w^{-1})$ 的解，这给出了 $w^2 - 2zw + 1 = 0$。其根为 $w = z \\pm \\sqrt{z^2-1}$。为了映射到单位圆盘的外部，我们必须选择大小大于或等于 $1$ 的根。一种稳健的计算方法是找到两个根，并取绝对值较大的那个。对于每个映射后的奇点 $z_k$，我们计算相应的参数 $\\rho_j^{(k)} = \\max(|z_k + \\sqrt{z_k^2-1}|, |z_k - \\sqrt{z_k^2-1}|)$。\n\niii. **单元参数 $\\rho_j$：** 函数在单元 $I_j$ 上的解析性受到“最近”奇点的限制。因此，该单元的有效 $\\rho_j$ 是与所有奇点相关的参数中的最小值：$\\rho_j = \\min_k \\rho_j^{(k)}$。\n\niv. **特殊情况（实轴奇点）：** 如果一个奇点 $s_k$ 是实的（即 $\\text{Im}(s_k)=0$）并且严格位于单元内部，$s_k \\in (a_j, b_j)$，那么围绕该区间的伯恩斯坦椭圆无法在不包围该奇点的情况下画出。在这种情况下，指数收敛性会丧失，我们设置 $\\rho_j = 1$。如果一个实奇点位于单元的边界点上，它会映射到 $\\Xi$ 的一个端点（$-1$ 或 $1$），通过茹科夫斯基映射会得到 $\\rho=1$，这正确地捕捉了局部解析性的丧失。\n\n**b. 所需多项式次数 $p_j^\\star$ 的估计**\n\n次数为 $p$ 的最佳多项式逼近误差 $E_p$ 由 $E_p \\le C \\rho_j^{-p}$ 界定。为了达到目标容限 $\\tau$，我们需要 $C \\rho_j^{-p} \\le \\tau$。根据问题陈述，我们将常数归一化为 $C=1$，得到条件 $\\rho_j^{-p} \\le \\tau$。\n\n- 如果 $\\rho_j  1$，我们可以解出 $p$：$-p \\ln(\\rho_j) \\le \\ln(\\tau)$，这意味着 $p \\ge -\\frac{\\ln(\\tau)}{\\ln(\\rho_j)}$。所需的最小整数次数为 $p_j^\\star = \\lceil -\\frac{\\ln(\\tau)}{\\ln(\\rho_j)} \\rceil$。\n- 如果 $\\rho_j \\le 1$，对于任何有限的 $p$（假设 $\\tau  1$），该条件都无法满足，这表明最多是代数收敛。在这种情况下，我们设置 $p_j^\\star = +\\infty$。\n\n**c. 单元分类**\n\n基于 $\\rho_j$ 和 $p_j^\\star$，对每个单元进行分类以指导自适应策略。\n\n- **$p$-可接受：** 如果解析性足够强且所需次数是实际的，则该单元适合进行 $p$-加密。这在 $\\rho_j  \\rho_{\\min}$ 且 $p_j^\\star \\le p_{\\max}$ 时成立。\n- **$h$-候选：** 否则，该单元被标记为进行 $h$-加密。这发生在收敛太慢（$\\rho_j \\le \\rho_{\\min}$）或达到容限所需的次数过高（$p_j^\\star  p_{\\max}$）时。\n\n**2. 用于 $r$-移动的界面分析**\n\n网格重分布（$r$-自适应）旨在移动网格顶点以更好地解析解的特征，例如低正则性区域。当相邻单元的预测加密类型存在强烈对比时，会生成移动界面的建议。\n\n我们检查每个内部界面 $x_{j}$（对于 $j=1, \\dots, N-1$），它分隔了单元 $I_{j-1}$ 和 $I_j$。当且仅当相邻单元中的一个是 $h$-候选而另一个是 $p$-可接受时，才会为位于 $x_j$ 的界面计算位移量 $\\delta_j$。如果满足此条件，位移为：\n$$ \\delta_j = \\theta \\cdot L_{j-1, j} \\cdot \\left|\\frac{1}{\\rho_{j-1}} - \\frac{1}{\\rho_j}\\right| $$\n这里，$\\theta \\in (0, 1)$ 是一个积极性参数，$L_{j-1, j}$ 是两个单元的组合长度（对于均匀网格，$L_{j-1, j} = 2/N$），而 $|\\frac{1}{\\rho_{j-1}} - \\frac{1}{\\rho_j}|$ 项量化了几何收敛因子的对比度。如果不满足该条件，则 $\\delta_j=0$。\n\n**3. 测试用例结果汇总**\n\n最后，对于每个测试用例，我们计算三个汇总统计数据：\n\n- $H$：被分类为 $h$-候选的单元总数。\n- $P_{\\max}^{\\mathrm{sel}}$：所有 $p$-可接受单元中所需的最大次数，即 $P_{\\max}^{\\mathrm{sel}} = \\max(\\{ p_j^\\star \\mid I_j \\text{ is } p\\text{-admissible} \\} \\cup \\{0\\})$。我们在集合中包含 $0$ 以处理没有 $p$-可接受单元的情况。\n- $\\mathcal{R}$：总的归一化 $r$-移动建议。这是所有单个界面位移建议的总和，$\\mathcal{R} = \\sum_{j=1}^{N-1} \\delta_j$，并由域长度（即 $1$）进行归一化。\n\n此过程为在 $hp-r$ 自适应算法中做出局部决策提供了定量的、有理论依据的基础。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests an hp-r adaptation decision algorithm based on\n    analytic continuation estimates.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        (4, {0.5 + 1.0j}, 1e-6, 12, 1.05, 0.25),\n        # Test case 2\n        (4, {0.3 + 0.0j}, 1e-3, 10, 1.02, 0.25),\n        # Test case 3\n        (8, {0.25 + 0.2j, 0.75 + 0.0j}, 1e-4, 10, 1.05, 0.30),\n        # Test case 4\n        (4, {0.5 + 0.05j}, 1e-2, 8, 1.10, 0.20),\n    ]\n\n    all_results = []\n\n    for N, singularities, tau, p_max, rho_min, theta in test_cases:\n        h = 1.0 / N\n        elements_data = []\n\n        # 1. Element-wise Analysis\n        for j in range(N):\n            a_j, b_j = j * h, (j + 1) * h\n            \n            rho_j = np.inf\n            \n            # Check for real singularity inside the element\n            has_real_singularity_inside = False\n            for s in singularities:\n                if np.isreal(s) and a_j  s.real  b_j:\n                    has_real_singularity_inside = True\n                    break\n            \n            if has_real_singularity_inside:\n                rho_j = 1.0\n            else:\n                rho_contributions = []\n                for s_k in singularities:\n                    # Map singularity to reference element coords\n                    z_k = (2 * s_k - (a_j + b_j)) / (b_j - a_j)\n                    \n                    # Handle case where z_k^2 - 1 is negative real\n                    sqrt_val = np.sqrt(z_k**2 - 1)\n                    \n                    # Find the root of w^2 - 2*z_k*w + 1 = 0 with |w| >= 1\n                    w_plus = z_k + sqrt_val\n                    w_minus = z_k - sqrt_val\n                    \n                    # In theory, one has |w|>=1, other |w|=1.\n                    # Taking max handles branch choice implicitly.\n                    rho_k = max(np.abs(w_plus), np.abs(w_minus))\n                    rho_contributions.append(rho_k)\n                \n                if rho_contributions:\n                    rho_j = min(rho_contributions)\n\n            # Determine required polynomial degree p_star\n            p_star_j = np.inf\n            if rho_j > 1:\n                # Need p >= -log(tau) / log(rho_j)\n                p_star_j = np.ceil(-np.log(tau) / np.log(rho_j))\n            \n            # Classify element\n            is_p_admissible = (rho_j > rho_min) and (p_star_j = p_max)\n            classification = 'p' if is_p_admissible else 'h'\n            \n            elements_data.append({\n                'rho': rho_j,\n                'p_star': int(p_star_j) if np.isfinite(p_star_j) else np.inf,\n                'class': classification\n            })\n\n        # 2. Aggregation for H and P_max_sel\n        H = sum(1 for el in elements_data if el['class'] == 'h')\n        \n        p_admissible_degrees = [el['p_star'] for el in elements_data if el['class'] == 'p']\n        P_max_sel = max(p_admissible_degrees) if p_admissible_degrees else 0\n\n        # 3. Interface Analysis for r-movement\n        total_delta = 0.0\n        union_length = 2 * h\n        for j in range(1, N):\n            class_left = elements_data[j-1]['class']\n            class_right = elements_data[j]['class']\n            \n            # Check for mismatch in classification\n            if (class_left == 'h' and class_right == 'p') or \\\n               (class_left == 'p' and class_right == 'h'):\n                rho_left = elements_data[j-1]['rho']\n                rho_right = elements_data[j]['rho']\n                \n                # Prevent division by zero if rho can be zero (not possible here)\n                if rho_left > 0 and rho_right > 0:\n                    contrast = abs(1/rho_left - 1/rho_right)\n                    delta_j = theta * union_length * contrast\n                    total_delta += delta_j\n        \n        R = round(total_delta, 6)\n        \n        all_results.append(f\"[{H},{P_max_sel},{R:.6f}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3360857"}, {"introduction": "最后的练习将探讨一个关键的实际挑战：不同加密类型之间的相互作用。当 $r$ 型自适应造成单元几何扭曲时，用于指导 $p$ 型自适应的误差指示器可能被“污染”而失效。在本练习中，您将实现并比较一个“朴素”的指示器和一个对几何扭曲不敏感的“修正”指示器，从而理解在高级自适应方法中，将近似误差与几何效应解耦的重要性。[@problem_id:3360876]", "problem": "考虑一个通过从参考正方形映射得到的单参数四边形有限元。设参考正方形为 $\\hat{\\Omega} = [-1,1] \\times [-1,1]$，其坐标为 $(\\xi,\\eta)$，物理单元为 $\\Omega_\\varepsilon$，其坐标为 $(x,y)$，通过 $r$-移动映射 $F_\\varepsilon : \\hat{\\Omega} \\to \\Omega_\\varepsilon$ 获得，定义如下\n$$\nx = \\xi,\\quad y = \\varepsilon\\,\\eta,\n$$\n其中 $\\varepsilon  0$ 控制几何畸变，雅可比行列式等于 $\\det(J_{F_\\varepsilon}) = \\varepsilon$。设 $u:\\Omega_\\varepsilon \\to \\mathbb{R}$ 是一个光滑的目标场。在标准的 $p$-加密误差指示中，分层 $p$ 型指标由在 $p$ 次和 $p+1$ 次之间添加的多项式展开的尾部构成。然而，在近奇异雅可比（$\\varepsilon$ 很小）的情况下，误差指标可能因几何映射而失真，而不是反映逼近质量。目标是分析此类指标的稳健性，并设计能够将逼近误差与几何畸变解耦的修正指标。\n\n使用以下基本基底和定义：\n- 在光滑映射 $F$ 下的梯度链式法则：如果 $v = \\hat{v} \\circ F^{-1}$，则\n$$\n\\nabla_x v = J_{F}^{-T} \\,\\nabla_{\\xi} \\hat{v},\n$$\n其中 $J_{F}$ 是 $F$ 的雅可比矩阵，物理积分变换为\n$$\n\\int_{\\Omega} g(x)\\,dx = \\int_{\\hat{\\Omega}} g\\big(F(\\xi)\\big)\\,\\det(J_{F})\\,d\\xi.\n$$\n- 物理单元中的 $H^1$ 半范数为\n$$\n|v|_{H^1(\\Omega)}^2 = \\int_{\\Omega} \\|\\nabla_x v\\|_2^2\\,dx.\n$$\n- 在参考单元上，使用由归一化 Legendre 多项式 $\\{L_i(\\xi)\\}_{i=0}^{\\infty}$ 和 $\\{L_j(\\eta)\\}_{j=0}^{\\infty}$ 构成的张量积层次正交基，其中 $L_n(t) = \\sqrt{\\frac{2n+1}{2}}\\,P_n(t)$，$P_n$ 是 $n$ 次 Legendre 多项式。$p$-加密尾部 $\\delta_{p\\to p+1}$ 是此基上 $(p+1)$ 次投影与 $p$ 次投影之间的差。\n\n定义一个由整数 $n_y \\ge 0$ 参数化的目标场族：\n$$\nu_{n_y}(x,y) = \\begin{cases} \\sin(\\pi x),  n_y = 0 \\\\ \\sin(\\pi x)\\,\\sin(\\pi n_y y),  n_y \\ge 1 \\end{cases}\n$$\n对于任何 $\\varepsilon  0$，这些函数在 $\\Omega_\\varepsilon$ 上都是光滑的。\n\n任务：\n1. 在 $\\hat{\\Omega}$ 上，为每个坐标构建最高到 $p+1$ 次的正交 Legendre 张量积基。\n2. 计算 $u_{n_y}\\circ F_\\varepsilon$ 在最高到 $p+1$ 次和最高到 $p$ 次基上的 $L^2$ 正交投影系数，并形成在 $\\hat{\\Omega}$ 上的分层尾函数 $\\delta_{p\\to p+1}$。\n3. 从上述基本映射恒等式出发，分析以下两个指标相对于几何畸变参数 $\\varepsilon$ 的行为（稳健性）：\n   - 一个在物理空间中度量尾部的朴素 $p$ 型 $H^1$-半范数指标，\n     $$\n     \\mathcal{E}^{\\text{naive}}_{H^1}(\\varepsilon) = \\int_{\\Omega_\\varepsilon} \\|\\nabla_x \\delta_{p\\to p+1}\\|_2^2\\,dx.\n     $$\n   - 一个旨在通过在参考空间中度量尾部来将逼近误差与几何畸变解耦的修正指标，\n     $$\n     \\mathcal{E}^{\\text{mod}}_{\\hat{H}^1} = \\int_{\\hat{\\Omega}} \\|\\nabla_{\\xi} \\delta_{p\\to p+1}\\|_2^2\\,d\\xi d\\eta.\n     $$\n4. 此外，度量物理空间和参考空间中尾部的 $L^2$ 能量，\n   $$\n   \\mathcal{E}^{\\text{phys}}_{L^2}(\\varepsilon) = \\int_{\\Omega_\\varepsilon} |\\delta_{p\\to p+1}|^2\\,dx,\\quad\n   \\mathcal{E}^{\\text{ref}}_{L^2} = \\int_{\\hat{\\Omega}} |\\delta_{p\\to p+1}|^2\\,d\\xi d\\eta,\n   $$\n   并考察比率 $\\mathcal{R}_{L^2}(\\varepsilon) = \\frac{\\mathcal{E}^{\\text{phys}}_{L^2}(\\varepsilon)}{\\mathcal{E}^{\\text{ref}}_{L^2}}$ 如何随 $\\varepsilon$ 变化。\n\n实现细节：\n- 对所有积分使用 $\\hat{\\Omega}$ 上的高斯求积；选择足够高的阶数以解析展开式。\n- 通过三项递推关系实现 Legendre 多项式，并计算其导数以进行梯度计算。\n- 利用正交基的性质，通过在 $\\hat{\\Omega}$ 上进行内积来获得投影系数。\n\n测试套件：\n- 固定 $p = 4$ 并使用以下 $(\\varepsilon, n_y)$ 参数对：\n  1. $(1.0, 1)$，无畸变的通用情况，\n  2. $(0.1, 1)$，中等畸变，\n  3. $(0.01, 1)$，近奇异雅可比，\n  4. $(0.01, 0)$，无 $y$ 方向变化的边缘情况，\n  5. $(0.01, 5)$，近奇异雅可比下的强 $y$ 方向变化。\n\n对于每个测试用例，计算两个浮点数：\n- 比率 $\\mathcal{R}_{H^1}(\\varepsilon) = \\dfrac{\\mathcal{E}^{\\text{naive}}_{H^1}(\\varepsilon)}{\\mathcal{E}^{\\text{mod}}_{\\hat{H}^1}}$，\n- 比率 $\\mathcal{R}_{L^2}(\\varepsilon) = \\dfrac{\\mathcal{E}^{\\text{phys}}_{L^2}(\\varepsilon)}{\\mathcal{E}^{\\text{ref}}_{L^2}}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含结果，形式为用方括号括起来的逗号分隔列表，按测试用例排序并展平。即，\n$$\n[\\mathcal{R}_{H^1}(\\varepsilon_1),\\mathcal{R}_{L^2}(\\varepsilon_1),\\ldots,\\mathcal{R}_{H^1}(\\varepsilon_5),\\mathcal{R}_{L^2}(\\varepsilon_5)]\n$$\n每个条目都是一个浮点数。不涉及单位；所有量纲均为一。程序必须是完全自包含的，并且不需要任何输入。", "solution": "该问题要求分析当有限元方法受到几何畸变时，$p$-加密误差指标的稳健性。问题的核心是比较一个“朴素”误差指标和一个“修正”指标，“朴素”指标直接在畸变的物理空间中评估，而“修正”指标在未畸变的参考空间中评估。这种比较揭示了几何因素如何污染误差估计，而理想情况下，误差估计应仅反映多项式基对解的逼近误差。\n\n分析在物理 $(x,y)$ 坐标系中的单个四边形单元 $\\Omega_\\varepsilon$ 上进行。该单元源自 $(\\xi,\\eta)$ 坐标系中的一个标准参考正方形 $\\hat{\\Omega} = [-1,1] \\times [-1,1]$，通过映射 $F_\\varepsilon: (\\xi,\\eta) \\mapsto (x,y)$ 得到，具体如下：\n$$\nx = \\xi, \\quad y = \\varepsilon\\eta\n$$\n参数 $\\varepsilon  0$ 控制单元的宽高比。当 $\\varepsilon \\to 0$ 时，单元变得越来越畸变或“压扁”。此映射的雅可比矩阵、其行列式及其逆转置是分析的基础：\n$$\nJ_{F_\\varepsilon} = \\begin{pmatrix} 1  0 \\\\ 0  \\varepsilon \\end{pmatrix}, \\quad \\det(J_{F_\\varepsilon}) = \\varepsilon, \\quad J_{F_\\varepsilon}^{-T} = \\begin{pmatrix} 1  0 \\\\ 0  1/\\varepsilon \\end{pmatrix}\n$$\n物理空间和参考空间中梯度之间的关系由链式法则给出：$\\nabla_x v = J_{F_\\varepsilon}^{-T} \\nabla_\\xi \\hat{v}$，其中 $\\hat{v} = v \\circ F_\\varepsilon$。\n\n待逼近的目标函数是 $u_{n_y}(x,y)$，它被拉回到参考单元上以定义 $\\hat{u}_{n_y}(\\xi,\\eta) = u_{n_y}(F_\\varepsilon(\\xi,\\eta))$：\n$$\n\\hat{u}_{n_y}(\\xi,\\eta) =\n\\begin{cases}\n\\sin(\\pi\\xi)   \\text{if } n_y = 0 \\\\\n\\sin(\\pi\\xi)\\sin(\\pi n_y \\varepsilon \\eta)   \\text{if } n_y \\ge 1\n\\end{cases}\n$$\n逼近使用正交 Legendre 多项式的张量积基 $\\phi_{ij}(\\xi,\\eta) = L_i(\\xi)L_j(\\eta)$ 进行。误差指标基于展开式的“尾部” $\\delta_{p\\to p+1}$，它代表了从 $p$ 次到 $p+1$ 次多项式次数中被投影函数的分量。这个尾函数在参考单元 $\\hat{\\Omega}$ 上定义为：\n$$\n\\delta_{p\\to p+1} = \\hat{u}_{p+1} - \\hat{u}_p = \\sum_{i=0}^{p+1}\\sum_{j=0}^{p+1} c_{ij} \\phi_{ij} - \\sum_{i=0}^{p}\\sum_{j=0}^{p} c_{ij} \\phi_{ij} = \\sum_{(i,j) \\in \\text{tail set}} c_{ij} \\phi_{ij}\n$$\n其中 $p=4$，系数 $c_{ij}$ 是 $\\hat{u}_{n_y}$ 的 $L^2(\\hat{\\Omega})$ 投影系数：\n$$\nc_{ij} = \\int_{\\hat{\\Omega}} \\hat{u}_{n_y}(\\xi,\\eta) \\phi_{ij}(\\xi,\\eta) \\,d\\xi d\\eta\n$$\n这些积分以及所有后续积分均使用高阶高斯-勒让德求积法进行数值计算。\n\n我们分析四个量：\n1.  **参考 $L^2$ 能量**：$\\mathcal{E}^{\\text{ref}}_{L^2} = \\int_{\\hat{\\Omega}} |\\delta_{p\\to p+1}|^2\\,d\\xi d\\eta$。由于基 $\\{\\phi_{ij}\\}$ 的正交性，这简化为尾部系数的平方和：\n    $$\n    \\mathcal{E}^{\\text{ref}}_{L^2} = \\sum_{(i,j) \\in \\text{tail set}} c_{ij}^2\n    $$\n2.  **物理 $L^2$ 能量**：$\\mathcal{E}^{\\text{phys}}_{L^2}(\\varepsilon) = \\int_{\\Omega_\\varepsilon} |\\delta_{p\\to p+1}|^2\\,dx dy$。通过将积分变换到参考单元，我们发现它与参考能量有直接关系：\n    $$\n    \\mathcal{E}^{\\text{phys}}_{L^2}(\\varepsilon) = \\int_{\\hat{\\Omega}} |\\delta_{p\\to p+1}|^2 \\det(J_{F_\\varepsilon})\\,d\\xi d\\eta = \\varepsilon \\int_{\\hat{\\Omega}} |\\delta_{p\\to p+1}|^2\\,d\\xi d\\eta = \\varepsilon \\mathcal{E}^{\\text{ref}}_{L^2}\n    $$\n    这为第一个比率提供了一个解析结果：$\\mathcal{R}_{L^2}(\\varepsilon) = \\mathcal{E}^{\\text{phys}}_{L^2}(\\varepsilon) / \\mathcal{E}^{\\text{ref}}_{L^2} = \\varepsilon$。这为数值实现提供了一个有价值的合理性检查。\n\n3.  **修正 $H^1$ 指标**：$\\mathcal{E}^{\\text{mod}}_{\\hat{H}^1} = \\int_{\\hat{\\Omega}} \\|\\nabla_{\\xi} \\delta_{p\\to p+1}\\|_2^2\\,d\\xi d\\eta$。该指标在参考单元的原始几何中度量尾函数的梯度，从而将逼近误差与几何效应分离。它通过求积计算：\n    $$\n    \\mathcal{E}^{\\text{mod}}_{\\hat{H}^1} = \\int_{-1}^1\\int_{-1}^1 \\left( \\left(\\frac{\\partial \\delta_{p\\to p+1}}{\\partial\\xi}\\right)^2 + \\left(\\frac{\\partial \\delta_{p\\to p+1}}{\\partial\\eta}\\right)^2 \\right) \\,d\\xi d\\eta\n    $$\n4.  **朴素 $H^1$ 指标**：$\\mathcal{E}^{\\text{naive}}_{H^1}(\\varepsilon) = \\int_{\\Omega_\\varepsilon} \\|\\nabla_x \\delta_{p\\to p+1}\\|_2^2\\,dx dy$。该指标受到几何形状的污染。将其变换到参考单元揭示了这种依赖性：\n    $$\n    \\mathcal{E}^{\\text{naive}}_{H^1}(\\varepsilon) = \\int_{\\hat{\\Omega}} \\|J_{F_\\varepsilon}^{-T} \\nabla_\\xi \\delta_{p\\to p+1}\\|_2^2 \\det(J_{F_\\varepsilon}) \\,d\\xi d\\eta\n    $$\n    代入我们映射的具体雅可比项得到：\n    $$\n    \\nabla_x \\delta \\leftrightarrow \\begin{pmatrix} \\partial_\\xi \\delta \\\\ \\varepsilon^{-1} \\partial_\\eta \\delta \\end{pmatrix}, \\quad \\| \\nabla_x \\delta \\|_2^2 \\leftrightarrow (\\partial_\\xi \\delta)^2 + \\varepsilon^{-2}(\\partial_\\eta \\delta)^2\n    $$\n    积分变为：\n    $$\n    \\mathcal{E}^{\\text{naive}}_{H^1}(\\varepsilon) = \\int_{\\hat{\\Omega}} \\left( (\\partial_\\xi \\delta)^2 + \\frac{1}{\\varepsilon^2}(\\partial_\\eta \\delta)^2 \\right) \\varepsilon \\,d\\xi d\\eta = \\int_{\\hat{\\Omega}} \\left( \\varepsilon(\\partial_\\xi \\delta)^2 + \\frac{1}{\\varepsilon}(\\partial_\\eta \\delta)^2 \\right) \\,d\\xi d\\eta\n    $$\n    项 $1/\\varepsilon$ 明确显示朴素指标对几何畸变敏感。当 $\\varepsilon \\to 0$ 时，该项可能导致 $\\mathcal{E}^{\\text{naive}}_{H^1}$ 的行为与 $\\mathcal{E}^{\\text{mod}}_{\\hat{H}^1}$ 大相径庭，这正是我们希望用比率 $\\mathcal{R}_{H^1}(\\varepsilon) = \\mathcal{E}^{\\text{naive}}_{H^1}(\\varepsilon) / \\mathcal{E}^{\\text{mod}}_{\\hat{H}^1}$ 来量化的。\n\n当 $n_y=0$ 时出现一个特殊情况，此时 $\\hat{u}_0(\\xi,\\eta) = \\sin(\\pi\\xi)$。该函数与 $\\eta$ 无关，因此其投影系数 $c_{ij}$ 仅在 $j=0$ 时非零。尾函数 $\\delta_{p\\to p+1}$ 也将与 $\\eta$ 无关，使其导数 $\\partial_\\eta \\delta_{p\\to p+1} = 0$。在这种情况下，$H^1$ 指标的表达式简化为：\n$$\n\\mathcal{E}^{\\text{mod}}_{\\hat{H}^1} = \\int_{\\hat{\\Omega}} (\\partial_\\xi \\delta)^2 \\, d\\xi d\\eta \\quad \\text{和} \\quad \\mathcal{E}^{\\text{naive}}_{H^1}(\\varepsilon) = \\int_{\\hat{\\Omega}} \\varepsilon (\\partial_\\xi \\delta)^2 \\, d\\xi d\\eta = \\varepsilon \\mathcal{E}^{\\text{mod}}_{\\hat{H}^1}\n$$\n因此，对于 $n_y=0$ 的情况，我们期望 $\\mathcal{R}_{H^1}(\\varepsilon) = \\varepsilon$。这为实现提供了另一个关键的验证点。对于 $n_y \\ge 1$ 和小的 $\\varepsilon$，预计 $(\\partial_\\eta \\delta)^2/\\varepsilon$ 项将占主导地位，导致 $\\mathcal{R}_{H^1}(\\varepsilon)$ 变大，从而证明朴素指标的非稳健性。\n\n实现过程首先在 $\\hat{\\Omega}$ 上建立一个高阶二维高斯求积规则。在求积点上预先计算正交 Legendre 基函数及其导数。对于每个测试用例，计算投影系数 $c_{ij}$，然后是在求积网格上的尾函数 $\\delta_{p\\to p+1}$ 及其梯度分量。最后，通过数值积分计算四个能量值，以求得所需比率。", "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre, roots_legendre\n\ndef legendre_basis_and_derivs(max_deg, x):\n    \"\"\"\n    Computes orthonormal Legendre basis functions L_n(x) and their derivatives L'_n(x).\n    L_n(t) = sqrt((2n+1)/2) * P_n(t), where P_n is the standard Legendre polynomial.\n\n    Args:\n        max_deg (int): Maximum degree of polynomials to compute.\n        x (np.ndarray): 1D array of points in [-1, 1] to evaluate the functions at.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]:\n            - L_vals: (max_deg+1, num_pts) array of L_n(x) values.\n            - L_prime_vals: (max_deg+1, num_pts) array of L'_n(x) values.\n    \"\"\"\n    num_pts = len(x)\n    L_vals = np.zeros((max_deg + 1, num_pts))\n    L_prime_vals = np.zeros((max_deg + 1, num_pts))\n\n    for n in range(max_deg + 1):\n        Pn = legendre(n)\n        Pn_prime = Pn.deriv(1)\n        \n        norm_const = np.sqrt((2 * n + 1) / 2.0)\n        \n        L_vals[n, :] = norm_const * Pn(x)\n        L_prime_vals[n, :] = norm_const * Pn_prime(x)\n        \n    return L_vals, L_prime_vals\n\ndef solve():\n    \"\"\"\n    Solves the problem of analyzing error indicator robustness for a distorted finite element.\n    \"\"\"\n    p = 4\n    test_cases = [\n        (1.0, 1),\n        (0.1, 1),\n        (0.01, 1),\n        (0.01, 0),\n        (0.01, 5),\n    ]\n\n    # Use a quadrature rule that is sufficiently accurate for the integrands.\n    # The integrands involve products of polynomials and transcendental functions.\n    # A high order is chosen for safety.\n    Nq = 32\n    xi_q, w_q = roots_legendre(Nq)\n    \n    # Pre-compute basis function values and derivatives at quadrature points\n    max_deg = p + 1\n    L_vals, L_prime_vals = legendre_basis_and_derivs(max_deg, xi_q)\n    \n    # 2D quadrature points and weights\n    XI, ETA = np.meshgrid(xi_q, xi_q)\n    W_2D = np.outer(w_q, w_q)\n    \n    results = []\n    \n    for eps, ny in test_cases:\n        # Define the target function on the reference element's quadrature grid\n        if ny == 0:\n            u_hat_vals = np.sin(np.pi * XI)\n        else:\n            u_hat_vals = np.sin(np.pi * XI) * np.sin(np.pi * ny * eps * ETA)\n            \n        # Compute L2 projection coefficients C_ij\n        C = np.zeros((max_deg + 1, max_deg + 1))\n        for i in range(max_deg + 1):\n            L_i_vals_2D = np.tile(L_vals[i, :], (Nq, 1))\n            for j in range(max_deg + 1):\n                L_j_vals_2D = np.tile(L_vals[j, :], (Nq, 1)).T\n                phi_ij_vals = L_i_vals_2D * L_j_vals_2D\n                C[i, j] = np.sum(W_2D * u_hat_vals * phi_ij_vals)\n\n        # Compute reference L^2 energy from coefficients (more accurate)\n        # Tail indices: (i,j) where i=p+1 or j=p+1\n        c_tail_sq = np.sum(C[p + 1, :]**2) + np.sum(C[:p + 1, p + 1]**2)\n        E_ref_L2 = c_tail_sq\n        \n        # Compute physical L^2 energy using the analytical relation\n        E_phys_L2 = eps * E_ref_L2\n        \n        # Compute tail function and its gradient on the grid\n        delta = np.zeros((Nq, Nq))\n        delta_xi = np.zeros((Nq, Nq))\n        delta_eta = np.zeros((Nq, Nq))\n        \n        for i in range(max_deg + 1):\n            L_i_vals_2D = np.tile(L_vals[i, :], (Nq, 1))\n            L_prime_i_vals_2D = np.tile(L_prime_vals[i, :], (Nq, 1))\n            for j in range(max_deg + 1):\n                if i > p or j > p:\n                    L_j_vals_2D = np.tile(L_vals[j, :], (Nq, 1)).T\n                    L_prime_j_vals_2D = np.tile(L_prime_vals[j, :], (Nq, 1)).T\n                    \n                    phi_ij = L_i_vals_2D * L_j_vals_2D\n                    grad_phi_ij_xi = L_prime_i_vals_2D * L_j_vals_2D\n                    grad_phi_ij_eta = L_i_vals_2D * L_prime_j_vals_2D\n                    \n                    delta += C[i, j] * phi_ij\n                    delta_xi += C[i, j] * grad_phi_ij_xi\n                    delta_eta += C[i, j] * grad_phi_ij_eta\n\n        # Compute H^1 seminorm indicators using quadrature\n        integrand_mod = delta_xi**2 + delta_eta**2\n        E_mod_H1 = np.sum(W_2D * integrand_mod)\n        \n        integrand_naive = eps * delta_xi**2 + (1/eps) * delta_eta**2\n        E_naive_H1 = np.sum(W_2D * integrand_naive)\n\n        # Compute ratios\n        if np.isclose(E_mod_H1, 0.0):\n            R_H1 = E_naive_H1 # Should be 0 if E_mod_H1 is 0, unless of numerical error\n        else:\n            R_H1 = E_naive_H1 / E_mod_H1\n\n        if np.isclose(E_ref_L2, 0.0):\n            R_L2 = E_phys_L2 # Should be 0 if E_ref_L2 is 0\n        else:\n            R_L2 = E_phys_L2 / E_ref_L2\n        \n        results.extend([R_H1, R_L2])\n        \n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "3360876"}]}