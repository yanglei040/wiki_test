{"hands_on_practices": [{"introduction": "在着手编写任何代码之前，理解问题的代数结构至关重要。Newmark 方法的核心在于将更新方程重新排列成一个在每个时间步中求解的线性系统。本练习将引导你推导这个有效的线性系统，其形式为 $M_{\\text{eff}} \\ddot{q}_{n+1} = f_{\\text{eff}}$，这是任何隐式 Newmark 求解器的基础，能让你清楚地看到有效质量和有效力是如何产生的。[@problem_id:3424180]", "problem": "考虑线性弹性动力学偏微分方程（PDE）经过空间离散化后得到的半离散形式，它产生了一个二阶常微分方程（ODE）\n$$\nM \\ddot{q}(t) + C \\dot{q}(t) + K q(t) = f(t),\n$$\n其中 $M$、$C$ 和 $K$ 分别是质量矩阵、阻尼矩阵和刚度矩阵，$q(t)$ 是广义位移向量。假设 $M$ 是对称正定的，$C$ 是对称半正定的，$K$ 是对称半正定的，并且 $f(t)$ 是足够光滑的。设时间网格为 $t_{n} = t_{0} + n\\,\\Delta t$，时间步长为 $\\Delta t > 0$。Newmark 时程积分方法族通过参数 $\\beta$ 和 $\\gamma$ 定义更新关系如下\n$$\nq_{n+1} = q_{n} + \\Delta t\\,\\dot{q}_{n} + \\Delta t^{2}\\left(\\tfrac{1}{2} - \\beta\\right)\\ddot{q}_{n} + \\Delta t^{2}\\beta\\,\\ddot{q}_{n+1},\n$$\n$$\n\\dot{q}_{n+1} = \\dot{q}_{n} + \\Delta t\\,(1 - \\gamma)\\,\\ddot{q}_{n} + \\Delta t\\,\\gamma\\,\\ddot{q}_{n+1}.\n$$\n在时间 $t_{n+1}$，半离散平衡方程为\n$$\nM \\ddot{q}_{n+1} + C \\dot{q}_{n+1} + K q_{n+1} = f_{n+1},\n$$\n其中 $f_{n+1} := f(t_{n+1})$。从上述基本关系出发，并且不假设任何额外的简化公式，推导未知加速度 $\\ddot{q}_{n+1}$ 的有效线性系统，其形式为\n$$\nM_{\\text{eff}}\\,\\ddot{q}_{n+1} = f_{\\text{eff}},\n$$\n并明确地以 $\\beta$、$\\gamma$ 和 $\\Delta t$ 的形式，以及已知量 $q_{n}$、$\\dot{q}_{n}$、$\\ddot{q}_{n}$ 和 $f_{n+1}$ 的函数形式，识别出有效质量 $M_{\\text{eff}}$、与 Newmark 参数 $\\gamma$ 和时间步长 $\\Delta t$ 相关的有效阻尼贡献，以及有效右端项 $f_{\\text{eff}}$。以闭合形式提供这些表达式。你的最终答案必须是以解析表达式表示的计算结果。不需要四舍五入，也不应代入任何数值。使用 LaTeX 的 $pmatrix$ 环境，将所要求的三个表达式呈现在单行中。", "solution": "该问题是有效的，因为它科学地基于计算力学的原理，是适定的、客观的且自洽的。任务是为 Newmark 时程积分方法族推导有效线性系统。\n\n推导的起点包括三个基本方程。首先，是在时间 $t_{n+1}$ 处计算的半离散运动方程：\n$$\nM \\ddot{q}_{n+1} + C \\dot{q}_{n+1} + K q_{n+1} = f_{n+1}\n$$\n第二和第三，是位移和速度的 Newmark 更新法则，它们将时间 $t_{n+1}$ 的状态与时间 $t_n$ 的已知状态以及未知的加速度 $\\ddot{q}_{n+1}$ 联系起来：\n$$\nq_{n+1} = q_{n} + \\Delta t\\,\\dot{q}_{n} + \\Delta t^{2}\\left(\\frac{1}{2} - \\beta\\right)\\ddot{q}_{n} + \\Delta t^{2}\\beta\\,\\ddot{q}_{n+1}\n$$\n$$\n\\dot{q}_{n+1} = \\dot{q}_{n} + \\Delta t\\,(1 - \\gamma)\\,\\ddot{q}_{n} + \\Delta t\\,\\gamma\\,\\ddot{q}_{n+1}\n$$\n这里，$q_n, \\dot{q}_n, \\ddot{q}_n$ 是时间 $t_n$ 的已知位移、速度和加速度向量，而 $q_{n+1}, \\dot{q}_{n+1}, \\ddot{q}_{n+1}$ 是时间 $t_{n+1}$ 的相应向量。参数 $\\beta$ 和 $\\gamma$ 定义了 Newmark 方法族中的具体方法。目标是获得一个形如 $M_{\\text{eff}}\\,\\ddot{q}_{n+1} = f_{\\text{eff}}$ 的方程，该方程只涉及未知量 $\\ddot{q}_{n+1}$ 和已知量。\n\n为了实现这一点，我们将 Newmark 更新法则代入 $t_{n+1}$ 时的运动方程。我们可以将依赖于未知量 $\\ddot{q}_{n+1}$ 的项与从前一时间步显式已知的项分离开来。让我们将更新法则重写为：\n$$\nq_{n+1} = \\tilde{q}_{n+1} + \\Delta t^{2}\\beta\\,\\ddot{q}_{n+1}\n$$\n$$\n\\dot{q}_{n+1} = \\tilde{\\dot{q}}_{n+1} + \\Delta t\\,\\gamma\\,\\ddot{q}_{n+1}\n$$\n其中 $\\tilde{q}_{n+1}$ 和 $\\tilde{\\dot{q}}_{n+1}$ 是仅依赖于 $t_n$ 时刻状态的预测量：\n$$\n\\tilde{q}_{n+1} := q_{n} + \\Delta t\\,\\dot{q}_{n} + \\Delta t^{2}\\left(\\frac{1}{2} - \\beta\\right)\\ddot{q}_{n}\n$$\n$$\n\\tilde{\\dot{q}}_{n+1} := \\dot{q}_{n} + \\Delta t\\,(1 - \\gamma)\\,\\ddot{q}_{n}\n$$\n现在，将 $q_{n+1}$ 和 $\\dot{q}_{n+1}$ 的表达式代入运动方程：\n$$\nM \\ddot{q}_{n+1} + C \\left( \\tilde{\\dot{q}}_{n+1} + \\Delta t\\,\\gamma\\,\\ddot{q}_{n+1} \\right) + K \\left( \\tilde{q}_{n+1} + \\Delta t^{2}\\beta\\,\\ddot{q}_{n+1} \\right) = f_{n+1}\n$$\n将矩阵 $C$ 和 $K$ 分配进去：\n$$\nM \\ddot{q}_{n+1} + C \\tilde{\\dot{q}}_{n+1} + \\Delta t\\,\\gamma\\,C \\ddot{q}_{n+1} + K \\tilde{q}_{n+1} + \\Delta t^{2}\\beta\\,K \\ddot{q}_{n+1} = f_{n+1}\n$$\n接下来，我们重新整理这个方程，将所有包含未知向量 $\\ddot{q}_{n+1}$ 的项收集到左侧，并将所有其他已知项移到右侧。\n$$\nM \\ddot{q}_{n+1} + \\Delta t\\,\\gamma\\,C \\ddot{q}_{n+1} + \\Delta t^{2}\\beta\\,K \\ddot{q}_{n+1} = f_{n+1} - C \\tilde{\\dot{q}}_{n+1} - K \\tilde{q}_{n+1}\n$$\n在左侧提出 $\\ddot{q}_{n+1}$ 因子，得到：\n$$\n\\left( M + \\gamma \\Delta t C + \\beta \\Delta t^{2} K \\right) \\ddot{q}_{n+1} = f_{n+1} - C \\tilde{\\dot{q}}_{n+1} - K \\tilde{q}_{n+1}\n$$\n这个方程就是所要求的 $M_{\\text{eff}}\\,\\ddot{q}_{n+1} = f_{\\text{eff}}$ 形式。由此，我们可以明确地识别出所要求的表达式。\n\n有效质量矩阵 $M_{\\text{eff}}$ 是 $\\ddot{q}_{n+1}$ 的矩阵系数：\n$$\nM_{\\text{eff}} = M + \\gamma \\Delta t C + \\beta \\Delta t^{2} K\n$$\n问题特别要求“与 Newmark 参数 $\\gamma$ 和时间步长 $\\Delta t$ 相关的有效阻尼贡献”。这对应于 $M_{\\text{eff}}$ 中包含阻尼矩阵 $C$ 和参数 $\\gamma$ 的项。该项是：\n$$\n\\gamma \\Delta t C\n$$\n有效右端项 $f_{\\text{eff}}$ 是整理后方程的整个右侧。将预测量 $\\tilde{q}_{n+1}$ 和 $\\tilde{\\dot{q}}_{n+1}$ 的完整表达式代回：\n$$\nf_{\\text{eff}} = f_{n+1} - C \\left( \\dot{q}_{n} + \\Delta t\\,(1 - \\gamma)\\,\\ddot{q}_{n} \\right) - K \\left( q_{n} + \\Delta t\\,\\dot{q}_{n} + \\Delta t^{2}\\left(\\frac{1}{2} - \\beta\\right)\\ddot{q}_{n} \\right)\n$$\n这三个表达式就是所要求的结果，它们是直接从 Newmark 方法的基本关系推导出来的。", "answer": "$$\n\\boxed{\\begin{pmatrix} M + \\gamma \\Delta t C + \\beta \\Delta t^{2} K \\\\ \\gamma \\Delta t C \\\\ f_{n+1} - C \\left( \\dot{q}_{n} + (1 - \\gamma) \\Delta t \\ddot{q}_{n} \\right) - K \\left( q_{n} + \\Delta t \\dot{q}_{n} + \\left(\\frac{1}{2} - \\beta\\right) \\Delta t^{2} \\ddot{q}_{n} \\right) \\end{pmatrix}}\n$$", "id": "3424180"}, {"introduction": "学会如何实现该方法后，下一个合乎逻辑的步骤是分析其精度。模态分析是动力学中的一个强大工具，通过它我们可以研究每个模态的误差是如何传播的。本练习将运用模态分析来推导单步误差放大因子，从而量化并预测一个时间步后的数值误差，这对于评估和信任你的模拟结果至关重要。[@problem_id:3424136]", "problem": "考虑一维线性弹性动力学模型，该模型通过对区间 $[0,L]$ 上的经典波动方程 $\\frac{\\partial^{2}u}{\\partial t^{2}}=c^{2}\\frac{\\partial^{2}u}{\\partial x^{2}}$ 使用有限元法（FEM）并施加齐次狄利克雷边界条件进行半离散化得到。得到的常微分方程组为\n$$\n\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{0},\n$$\n其中 $\\mathbf{M}$ 是对称正定质量矩阵，$\\mathbf{K}$ 是对称正定刚度矩阵，$\\mathbf{u}(t)$ 是节点位移向量。设广义特征对 $(\\omega_{j}^{2},\\boldsymbol{\\phi}_{j})$ 求解 $\\mathbf{K}\\boldsymbol{\\phi}_{j}=\\omega_{j}^{2}\\mathbf{M}\\boldsymbol{\\phi}_{j}$，其中 $\\boldsymbol{\\phi}_{j}$ 被选为 $\\mathbf{M}$-正交归一的，因此任何位移场都可以通过振型叠加表示为 $\\mathbf{u}(t)=\\sum_{j}q_{j}(t)\\boldsymbol{\\phi}_{j}$。\n\n时间积分采用参数为 $(\\gamma,\\beta)$ 的 Newmark 单步法族进行，其特点是从 $(\\mathbf{u}_{n},\\dot{\\mathbf{u}}_{n})$ 到时间 $t_{n+1}=t_{n}+\\Delta t$ 时的 $(\\mathbf{u}_{n+1},\\dot{\\mathbf{u}}_{n+1})$ 的隐式更新，其中 $\\Delta t>0$ 是时间步长。假设材料波速为 $c=1$，域长度为 $L=1$，因此当以弧度/秒表示时，连续问题的振型频率为 $\\omega_{j}=j\\pi$（对于 $j=1,2,3$）。假设 Newmark 参数为 $\\gamma=0.55$ 和 $\\beta=0.30$，时间步长为 $\\Delta t=0.05$ 秒。\n\n假设在时间 $t_{0}$ 的初始数值位移误差纯粹是位移误差（每个振型的初始速度误差为零），并且具有振型展开式\n$$\n\\mathbf{e}_{u}(t_{0})=a_{1}\\boldsymbol{\\phi}_{1}+a_{2}\\boldsymbol{\\phi}_{2}+a_{3}\\boldsymbol{\\phi}_{3},\\quad a_{1}=0.010,\\quad a_{2}=0.006,\\quad a_{3}=0.004,\n$$\n其中 $\\boldsymbol{\\phi}_{j}$ 是 $\\mathbf{M}$-正交归一的振型，$a_{j}$ 的单位是米。利用振型叠加，标量振型坐标遵循二阶常微分方程 $q_{j}''(t)+\\omega_{j}^{2}q_{j}(t)=0$，并且每个振型都使用给定参数的 Newmark 方法独立地进行推进。\n\n从基本的半离散模型和 Newmark 方法的定义出发，推导单步位移误差的各振型放大因子，作为无量纲步长参数 $\\Omega_{j}=\\omega_{j}\\Delta t$ 和 Newmark 参数 $(\\gamma,\\beta)$ 的函数，然后用它来构造一个时间步长后的全局位移误差大小的估计值，\n$$\n\\left\\|\\mathbf{e}_{u}(t_{1})\\right\\|=\\left(\\sum_{j=1}^{3}\\left|A(\\Omega_{j};\\gamma,\\beta)\\,a_{j}\\right|^{2}\\right)^{1/2},\n$$\n其中 $A(\\Omega_{j};\\gamma,\\beta)$ 是单步位移误差的各振型放大因子，$\\|\\cdot\\|$ 表示由 $\\mathbf{M}$-正交归一振型基诱导的 $\\mathbf{M}$-范数。根据给定数据计算 $\\left\\|\\mathbf{e}_{u}(t_{1})\\right\\|$ 的数值。将最终答案四舍五入到四位有效数字。以米为单位表示最终的位移误差大小。", "solution": "首先根据指定标准对问题进行验证。\n\n### 步骤 1：提取已知条件\n- 控制常微分方程组 (ODEs)：$\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{0}$，其中 $\\mathbf{M}$ 和 $\\mathbf{K}$ 是对称正定矩阵。\n- 广义特征问题：$\\mathbf{K}\\boldsymbol{\\phi}_{j}=\\omega_{j}^{2}\\mathbf{M}\\boldsymbol{\\phi}_{j}$，其中 $\\boldsymbol{\\phi}_{j}$ 是 $\\mathbf{M}$-正交归一的。\n- 振型叠加：$\\mathbf{u}(t)=\\sum_{j}q_{j}(t)\\boldsymbol{\\phi}_{j}$。\n- 标量振型常微分方程：$q_{j}''(t)+\\omega_{j}^{2}q_{j}(t)=0$。\n- Newmark 方法参数：$\\gamma=0.55$，$\\beta=0.30$。\n- 时间步长：$\\Delta t=0.05$ 秒。\n- 波速：$c=1$。\n- 域长度：$L=1$。\n- 连续问题的振型频率：$\\omega_{j}=j\\pi$ 弧度/秒，对于 $j=1,2,3$。\n- 初始数值位移误差：$\\mathbf{e}_{u}(t_{0})=a_{1}\\boldsymbol{\\phi}_{1}+a_{2}\\boldsymbol{\\phi}_{2}+a_{3}\\boldsymbol{\\phi}_{3}$。\n- 初始数值速度误差：$\\mathbf{e}_{v}(t_{0}) = \\mathbf{0}$。\n- 初始振型位移误差幅值：$a_{1}=0.010$ 米，$a_{2}=0.006$ 米，$a_{3}=0.004$ 米。\n- 任务：推导单步位移误差的各振型放大因子 $A(\\Omega_{j};\\gamma,\\beta)$。\n- 任务：计算一个时间步长后的全局位移误差大小，定义为 $\\left\\|\\mathbf{e}_{u}(t_{1})\\right\\|=\\left(\\sum_{j=1}^{3}\\left|A(\\Omega_{j};\\gamma,\\beta)\\,a_{j}\\right|^{2}\\right)^{1/2}$，其中 $\\Omega_{j}=\\omega_{j}\\Delta t$ 且 $\\|\\cdot\\|$ 是 $\\mathbf{M}$-范数。\n- 将最终数值答案四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，是适定的、客观的。它描述了计算结构动力学中用于分析时间积分方案数值误差的标准程序。\n- **科学性和事实性**：问题陈述基于有限元分析、结构动力学和常微分方程数值方法的既定原则。模型（$\\mathbf{M}\\ddot{\\mathbf{u}}+\\mathbf{K}\\mathbf{u}=\\mathbf{0}$）、振型分析和 Newmark 积分方案都是该领域的经典概念。\n- **适定性**：该问题提供了所有必要的数据（$\\gamma, \\beta, \\Delta t, \\omega_j, a_j$）和一个明确的目标：推导一个标准公式并应用它来计算一个特定的数值。其结构导向一个唯一的解。\n- **客观性**：该问题以精确、正式的语言陈述，没有任何主观性或歧义。\n- **完整性和一致性**：该问题是自洽的。所提供的数据是充分且一致的。\n- **可行性**：对于一个模型问题，所有给定值在数值上都是合理的。\n因此，该问题被认为是有效的。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n每个振型误差的演化遵循与解本身相同的动力学规律。对于单个振型 $j$，振型坐标中的误差（我们称之为 $d_j(t)$）满足标量常微分方程：\n$$\n\\ddot{d}_j(t) + \\omega_j^2 d_j(t) = 0\n$$\n在时间 $t_n$ 的误差状态由对 $(d_j(t_n), \\dot{d}_j(t_n))$ 给出。我们将其表示为 $(d_{j,n}, \\dot{d}_{j,n})$。Newmark 方法族提供了找到 $t_{n+1} = t_n + \\Delta t$ 时状态的更新规则。更新方程为：\n$$\nd_{j,n+1} = d_{j,n} + \\Delta t \\, \\dot{d}_{j,n} + (\\Delta t)^2 \\left[ \\left(\\frac{1}{2}-\\beta\\right) \\ddot{d}_{j,n} + \\beta \\ddot{d}_{j,n+1} \\right]\n$$\n$$\n\\dot{d}_{j,n+1} = \\dot{d}_{j,n} + \\Delta t \\left[ (1-\\gamma) \\ddot{d}_{j,n} + \\gamma \\ddot{d}_{j,n+1} \\right]\n$$\n根据控制常微分方程，我们有关系式 $\\ddot{d}_{j,n} = -\\omega_j^2 d_{j,n}$ 和 $\\ddot{d}_{j,n+1} = -\\omega_j^2 d_{j,n+1}$。将这些代入第一个 Newmark 方程得到：\n$$\nd_{j,n+1} = d_{j,n} + \\Delta t \\, \\dot{d}_{j,n} + (\\Delta t)^2 \\left[ -\\left(\\frac{1}{2}-\\beta\\right) \\omega_j^2 d_{j,n} - \\beta \\omega_j^2 d_{j,n+1} \\right]\n$$\n我们将包含 $d_{j,n+1}$ 的项收集到左侧，将包含第 $n$ 步状态的项收集到右侧。定义无量纲频率 $\\Omega_j = \\omega_j \\Delta t$：\n$$\nd_{j,n+1} \\left( 1 + \\beta (\\omega_j \\Delta t)^2 \\right) = d_{j,n} \\left( 1 - \\left(\\frac{1}{2}-\\beta\\right) (\\omega_j \\Delta t)^2 \\right) + \\Delta t \\, \\dot{d}_{j,n}\n$$\n$$\nd_{j,n+1} \\left( 1 + \\beta \\Omega_j^2 \\right) = d_{j,n} \\left( 1 - \\left(\\frac{1}{2}-\\beta\\right) \\Omega_j^2 \\right) + \\Delta t \\, \\dot{d}_{j,n}\n$$\n问题指定初始误差纯粹是位移误差，意味着初始速度误差为零。对于每个振型 $j$，我们在 $t_0$ 时有初始条件：\n$$\nd_{j,0} = a_j, \\quad \\dot{d}_{j,0} = 0\n$$\n我们需要找到一个时间步长后的位移误差 $d_{j,1}$。在重新排列的更新方程中令 $n=0$ 并代入初始条件：\n$$\nd_{j,1} \\left( 1 + \\beta \\Omega_j^2 \\right) = a_j \\left( 1 - \\left(\\frac{1}{2}-\\beta\\right) \\Omega_j^2 \\right) + \\Delta t \\cdot 0\n$$\n求解 $d_{j,1}$，我们得到：\n$$\nd_{j,1} = a_j \\left( \\frac{1 - \\left(\\frac{1}{2}-\\beta\\right) \\Omega_j^2}{1 + \\beta \\Omega_j^2} \\right)\n$$\n单步位移误差的各振型放大因子 $A(\\Omega_j; \\gamma, \\beta)$ 是乘以初始位移误差 $a_j$ 以得到一步后位移误差的因子。通过比较，我们确定：\n$$\nA(\\Omega_j; \\gamma, \\beta) = \\frac{1 - \\left(\\frac{1}{2}-\\beta\\right) \\Omega_j^2}{1 + \\beta \\Omega_j^2}\n$$\n请注意，对于这种特定情况（初始速度误差为零），位移分量的放大因子与 Newmark 参数 $\\gamma$ 无关。\n\n现在我们进行数值计算。给定参数为：\n$\\gamma = 0.55$，$\\beta = 0.30$，$\\Delta t = 0.05$ 秒。\n$a_1 = 0.010$ 米，$a_2 = 0.006$ 米，$a_3 = 0.004$ 米。\n振型频率为 $\\omega_j = j\\pi$ rad/s。\n\n首先，我们计算无量纲频率 $\\Omega_j = \\omega_j \\Delta t$：\n$\\Omega_1 = \\omega_1 \\Delta t = (1\\pi) \\cdot (0.05) = 0.05\\pi$\n$\\Omega_2 = \\omega_2 \\Delta t = (2\\pi) \\cdot (0.05) = 0.10\\pi$\n$\\Omega_3 = \\omega_3 \\Delta t = (3\\pi) \\cdot (0.05) = 0.15\\pi$\n\n接下来，我们使用 $\\beta=0.30$ 计算每个振型的放大因子 $A_j = A(\\Omega_j; \\gamma, \\beta)$：\n项 $\\frac{1}{2}-\\beta = 0.5 - 0.3 = 0.2$。公式变为：\n$$\nA_j = \\frac{1 - 0.2 \\, \\Omega_j^2}{1 + 0.3 \\, \\Omega_j^2}\n$$\n对于 $j=1$：\n$A_1 = \\frac{1 - 0.2 (0.05\\pi)^2}{1 + 0.3 (0.05\\pi)^2} = \\frac{1 - 0.2 (0.0025\\pi^2)}{1 + 0.3 (0.0025\\pi^2)} = \\frac{1 - 0.0005\\pi^2}{1 + 0.00075\\pi^2} \\approx 0.987754$\n对于 $j=2$：\n$A_2 = \\frac{1 - 0.2 (0.10\\pi)^2}{1 + 0.3 (0.10\\pi)^2} = \\frac{1 - 0.2 (0.01\\pi^2)}{1 + 0.3 (0.01\\pi^2)} = \\frac{1 - 0.002\\pi^2}{1 + 0.003\\pi^2} \\approx 0.952071$\n对于 $j=3$：\n$A_3 = \\frac{1 - 0.2 (0.15\\pi)^2}{1 + 0.3 (0.15\\pi)^2} = \\frac{1 - 0.2 (0.0225\\pi^2)}{1 + 0.3 (0.0225\\pi^2)} = \\frac{1 - 0.0045\\pi^2}{1 + 0.00675\\pi^2} \\approx 0.895905$\n\n在时间 $t_1 = \\Delta t$ 时的振型位移误差为 $e_{u,j}(t_1) = A_j a_j$：\n$e_{u,1}(t_1) = A_1 a_1 \\approx 0.987754 \\times 0.010 = 0.00987754$ 米\n$e_{u,2}(t_1) = A_2 a_2 \\approx 0.952071 \\times 0.006 = 0.00571243$ 米\n$e_{u,3}(t_1) = A_3 a_3 \\approx 0.895905 \\times 0.004 = 0.00358362$ 米\n\n$t_1$ 时的总位移误差向量是 $\\mathbf{e}_u(t_1) = \\sum_{j=1}^3 e_{u,j}(t_1) \\boldsymbol{\\phi}_j$。问题要求计算其 $\\mathbf{M}$-范数，记作 $\\|\\cdot\\|$。由于振型的 $\\mathbf{M}$-正交归一性 ($\\boldsymbol{\\phi}_i^T \\mathbf{M} \\boldsymbol{\\phi}_j = \\delta_{ij}$)，范数计算如下：\n$$\n\\|\\mathbf{e}_u(t_1)\\|^2 = \\mathbf{e}_u(t_1)^T \\mathbf{M} \\mathbf{e}_u(t_1) = \\sum_{j=1}^3 (e_{u,j}(t_1))^2\n$$\n$$\n\\|\\mathbf{e}_u(t_1)\\| = \\left( (e_{u,1}(t_1))^2 + (e_{u,2}(t_1))^2 + (e_{u,3}(t_1))^2 \\right)^{1/2}\n$$\n代入数值：\n$$\n\\|\\mathbf{e}_u(t_1)\\| \\approx \\left( (0.00987754)^2 + (0.00571243)^2 + (0.00358362)^2 \\right)^{1/2}\n$$\n$$\n\\|\\mathbf{e}_u(t_1)\\| \\approx \\left( 9.75658 \\times 10^{-5} + 3.26318 \\times 10^{-5} + 1.28424 \\times 10^{-5} \\right)^{1/2}\n$$\n$$\n\\|\\mathbf{e}_u(t_1)\\| \\approx \\left( 14.3040 \\times 10^{-5} \\right)^{1/2} = \\left( 1.43040 \\times 10^{-4} \\right)^{1/2}\n$$\n$$\n\\|\\mathbf{e}_u(t_1)\\| \\approx 0.0119599 \\text{ m}\n$$\n将最终答案四舍五入到四位有效数字，得到 $0.01196$。", "answer": "$$\\boxed{0.01196}$$", "id": "3424136"}, {"introduction": "真实世界的问题通常是非线性的，数值方法在这些问题中可能表现出线性系统中未见的特性。这项高级实践将探讨非线性波动方程的长期模拟，揭示不同的 Newmark 参数如何影响能量守恒。你还将实现一种校正技术以强制执行这一基本物理定律，从而深入了解几何积分的思想。[@problem_id:3424207]", "problem": "考虑在一维空间上，区间长度为 $2\\pi$ 且具有周期性边界条件的非线性克莱因-戈尔登方程，\n$$\nu_{tt} - c^2 u_{xx} + \\lambda u^3 = 0,\n$$\n它可以写成一个二阶哈密顿系统，其哈密顿量（总能量）为\n$$\n\\mathcal{E}(u,v) = \\int_0^{2\\pi} \\left( \\tfrac{1}{2} v^2 + \\tfrac{c^2}{2} u_x^2 + \\tfrac{\\lambda}{4} u^4 \\right)\\,dx,\n$$\n其中 $v = u_t$。在使用快速傅里叶变换 (FFT) 进行谱精度空间离散化之后，该偏微分方程简化为以下形式的常微分方程组\n$$\n\\mathbf{u}'' + \\mathbf{L}\\,\\mathbf{u} + \\lambda\\,\\mathbf{u}^{\\circ 3} = \\mathbf{0},\n$$\n其中 $\\mathbf{u}$ 集合了空间网格点上的值，$\\mathbf{L}$ 是在 FFT 表示下对应于 $-c^2\\partial_{xx}$ 的离散、对称、半正定算子，而 $\\mathbf{u}^{\\circ 3}$ 表示逐元素的立方非线性。\n\nNewmark 方法族是为二阶系统定义的，由参数 $(\\gamma,\\beta)$ 决定，其更新 $(\\mathbf{u}_{n+1},\\mathbf{v}_{n+1})$ 的方式如下\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t\\,\\mathbf{v}_n + \\Delta t^2\\left(\\tfrac{1}{2}-\\beta\\right)\\mathbf{a}_n + \\beta \\Delta t^2 \\mathbf{a}_{n+1},\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\Delta t \\left((1-\\gamma)\\mathbf{a}_n + \\gamma \\mathbf{a}_{n+1}\\right),\n$$\n其中 $\\mathbf{a}_n$ 是由运动方程定义的加速度，$\\mathbf{a}_n = -\\mathbf{L}\\,\\mathbf{u}_n - \\lambda\\,\\mathbf{u}_n^{\\circ 3}$。对于一般的 $(\\gamma,\\beta)$，该方法是隐式的，因为 $\\mathbf{a}_{n+1}$ 依赖于 $\\mathbf{u}_{n+1}$，这导致在每一步都需要求解一个非线性系统。\n\n您的任务如下，从哈密顿结构和半离散系统开始：\n- 针对半离散系统，推导通用 $(\\gamma,\\beta)$ 参数下的 Newmark 更新方程，并强调 $\\mathbf{L}$ 和非线性项如何进入隐式步骤。\n- 设计一种谱精度且计算高效的方法，使用快速傅里叶变换 (FFT) 来计算 $\\mathbf{L}\\,\\mathbf{u}$ 和 $\\int u_x^2\\,dx$，从而使离散能量的计算与空间离散化保持一致。\n- 在弱非线性区域（$\\lambda$ 很小），对于固定的时间步长和最终时间，分析以最大相对能量误差\n$$\n\\max_{0 \\leq n \\leq N}\\frac{\\left|\\mathcal{E}(\\mathbf{u}_n,\\mathbf{v}_n)-\\mathcal{E}(\\mathbf{u}_0,\\mathbf{v}_0)\\right|}{\\mathcal{E}(\\mathbf{u}_0,\\mathbf{v}_0)},\n$$\n衡量的长期能量漂移。从第一性原理出发，解释为何不同的 $(\\gamma,\\beta)$ 选择会在非线性情况下导致性质上不同的长期行为。\n- 提出并实现一个最小化的修正，用于在弱非线性区域恢复哈密顿量的近似守恒，而不显著改变核心的 Newmark 步骤。该修正必须从哈密顿视角进行论证。一种可行的方法是能量投影，即在每一步重缩放速度以匹配初始能量，同时保持新的位移不变。\n\n实现以下程序要求：\n- 使用长度为 $2\\pi$ 的一维周期性域，包含 $N$ 个等距点，其中 $N = 64$，波速 $c = 1$，初始条件为 $u(x,0) = A\\sin(x)$，$v(x,0)=0$，其中 $A = 0.1$。所有积分都是无量纲的，無需进行物理单位转换。\n- 使用 FFT 计算与 $-c^2\\partial_{xx}$ 对应的算子 $\\mathbf{L}$以及能量计算所需的导数 $u_x$。\n- 对于隐式 Newmark 情况（所有 $\\beta > 0$ 的情况），通过不动点迭代在每个步骤求解非线性系统，该迭代对线性算子进行隐式处理，对三次非线性项使用上一次迭代的值进行滞后处理。具体来说，在每个时间步，通过对右侧的三次项使用最新的迭代值进行迭代，并使用谱反演逐模式地处理左侧，来求解方程\n$$\n\\left(\\mathbf{I} + \\alpha \\mathbf{L}\\right)\\mathbf{u}_{n+1} = \\mathbf{r} - \\alpha \\lambda\\,\\mathbf{u}_{n+1}^{\\circ 3},\n$$\n其中 $\\alpha = \\beta\\Delta t^2$ 且 $\\mathbf{r}$ 是由 Newmark  predictor 构造的已知右端项。\n- 作为提议的修正，在每一步结束时实现一个能量投影，它用一个标量 $s$ 来重缩放 $\\mathbf{v}_{n+1}\\mapsto s\\,\\mathbf{v}_{n+1}$，选择 $s$ 使得离散能量等于初始能量。如果所需动能变为非正值或速度为零，则保持 $\\mathbf{v}_{n+1}$ 不变。\n\n测试套件和输出规范：\n- 使用以下五个测试用例，每个用例指定为 $(\\gamma,\\beta,\\lambda,\\text{corrected},\\Delta t,T)$，其中布尔值 $\\text{corrected}$ 指示是否应用能量投影：\n    - 情况 1: $(\\tfrac{1}{2}, \\tfrac{1}{4}, 0, \\text{False}, 0.05, 50)$。\n    - 情况 2: $(\\tfrac{1}{2}, \\tfrac{1}{4}, 10^{-2}, \\text{False}, 0.05, 50)$。\n    - 情况 3: $(\\tfrac{1}{2}, \\tfrac{1}{6}, 10^{-2}, \\text{False}, 0.05, 50)$。\n    - 情况 4: $(\\tfrac{1}{2}, 0, 10^{-2}, \\text{False}, 0.02, 50)$。\n    - 情况 5: $(\\tfrac{1}{2}, \\tfrac{1}{4}, 10^{-1}, \\text{True}, 0.05, 50)$。\n- 对于每个用例，计算在整个积分区间内的最大相对能量漂移，定义为\n$$\n\\max_{0\\le n\\le N}\\frac{|\\mathcal{E}(\\mathbf{u}_n,\\mathbf{v}_n)-\\mathcal{E}(\\mathbf{u}_0,\\mathbf{v}_0)|}{\\mathcal{E}(\\mathbf{u}_0,\\mathbf{v}_0)}.\n$$\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，按上述用例的顺序排列。每个条目必须是标准十进制表示的浮点数。例如，输出格式类似于 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$。", "solution": "该问题要求对用于半离散化非线性克莱因-戈尔登方程的 Newmark 时间积分方法族进行全面的分析和实现。这涉及推导更新方程，讨论谱方法空间离散化，分析不同积分器的长期能量行为，以及实现一种能量守恒的修正。\n\n### 问题陈述的有效性验证\n该问题在科学上和数学上是合理的。它涉及数学物理中的一个标准模型（克莱因-戈尔登方程）及其求解的一个经典数值方法族（Newmark 方法）。使用谱方法（FFT）进行空间离散化是处理周期性边界条件问题的标准且高度精确的技术。所有参数和初始条件都已提供，使得问题自洽且适定。任务结构逻辑清晰，从理论推导引导到数值实现和分析。所提出的关于能量守恒的问题是研究哈密顿系统数值积分器的核心。该问题是有效的。\n\n### 基于原理的解答\n\n#### 任务1：Newmark 更新方程的推导\n对于形如 $\\mathbf{u}'' = \\mathbf{a}(t, \\mathbf{u}, \\mathbf{u}')$ 的二阶常微分方程组，Newmark 方法族由两个参数 $\\gamma$ 和 $\\beta$ 定义。从时间步 $n$到 $n+1$ 的更新由下式给出：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t\\,\\mathbf{v}_n + \\Delta t^2\\left(\\tfrac{1}{2}-\\beta\\right)\\mathbf{a}_n + \\beta \\Delta t^2 \\mathbf{a}_{n+1}\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\Delta t \\left((1-\\gamma)\\mathbf{a}_n + \\gamma \\mathbf{a}_{n+1}\\right)\n$$\n其中 $\\mathbf{u}_n \\approx \\mathbf{u}(t_n)$，$\\mathbf{v}_n \\approx \\mathbf{u}'(t_n)$，且 $\\mathbf{a}_n = \\mathbf{u}''(t_n)$。对于给定的半离散克莱因-戈尔登系统，加速度是位移 $\\mathbf{u}$ 的函数：\n$$\n\\mathbf{a}(\\mathbf{u}) = -\\mathbf{L}\\,\\mathbf{u} - \\lambda\\,\\mathbf{u}^{\\circ 3}\n$$\n因此，$\\mathbf{a}_n = \\mathbf{a}(\\mathbf{u}_n)$ 且 $\\mathbf{a}_{n+1} = \\mathbf{a}(\\mathbf{u}_{n+1})$。如果 $\\beta \\neq 0$，$\\mathbf{u}_{n+1}$ 的方程依赖于 $\\mathbf{a}_{n+1}$，而后者又依赖于 $\\mathbf{u}_{n+1}$。这使得该方法成为隐式方法。为了明确地看到这一点，我们将 $\\mathbf{a}_{n+1}$ 的表达式代入到位移更新方程中：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t\\,\\mathbf{v}_n + \\Delta t^2\\left(\\tfrac{1}{2}-\\beta\\right)\\mathbf{a}_n - \\beta \\Delta t^2 \\left(\\mathbf{L}\\,\\mathbf{u}_{n+1} + \\lambda\\,\\mathbf{u}_{n+1}^{\\circ 3}\\right)\n$$\n重新整理各项，将未知的 $\\mathbf{u}_{n+1}$ 分离到左侧，得到一个在每个时间步都需要求解的非线性代数系统：\n$$\n\\mathbf{u}_{n+1} + \\beta \\Delta t^2 \\mathbf{L}\\,\\mathbf{u}_{n+1} + \\beta \\Delta t^2 \\lambda\\,\\mathbf{u}_{n+1}^{\\circ 3} = \\mathbf{u}_n + \\Delta t\\,\\mathbf{v}_n + \\Delta t^2\\left(\\tfrac{1}{2}-\\beta\\right)\\mathbf{a}_n\n$$\n令 $\\alpha = \\beta\\Delta t^2$ 并将右侧（由来自步骤 $n$ 的已知量组成）定义为 $\\mathbf{r} = \\mathbf{u}_n + \\Delta t\\,\\mathbf{v}_n + \\Delta t^2\\left(\\tfrac{1}{2}-\\beta\\right)\\mathbf{a}_n$，我们得到：\n$$\n(\\mathbf{I} + \\alpha \\mathbf{L})\\mathbf{u}_{n+1} = \\mathbf{r} - \\alpha \\lambda\\,\\mathbf{u}_{n+1}^{\\circ 3}\n$$\n这就是问题中指定的非线性系统。它可以使用迭代方法（如牛顿法）求解，或者如建议的那样，使用不动点迭代求解，其中右侧的非线性项使用前一次迭代的值进行计算。\n\n#### 任务2：使用 FFT 进行谱精度计算\n对于 $[0, 2\\pi]$ 上的周期函数，使用傅里葉级数表示的谱方法非常有效。网格 $x_j = j(2\\pi/N)$ 上的函数 $u(x)$ 由其值向量 $\\mathbf{u}$ 表示。\n1.  **$\\mathbf{L}\\,\\mathbf{u}$ 的计算**：算子 $\\mathbf{L}$ 对应于 $-c^2\\partial_{xx}$。在傅里叶空间中，微分 $\\partial_{xx}$ 对应于乘以 $(ik)^2 = -k^2$，其中 $k$ 是整数波数。因此，算子 $\\mathbf{L}$ 在傅里叶空间中对应于乘以 $c^2k^2$。其过程如下：\n    *   计算 $\\mathbf{u}$ 的傅里叶系数：$\\hat{\\mathbf{u}} = \\text{FFT}(\\mathbf{u})$。\n    *   设 $\\mathbf{k}$ 是对应于离散傅里叶模式的整数波数向量。离散算子 $\\mathbf{L}$ 的特征值为 $\\{c^2k^2\\}$。逐元素相乘：$\\widehat{\\mathbf{L}\\,\\mathbf{u}} = (c^2\\mathbf{k}^{\\circ 2}) \\odot \\hat{\\mathbf{u}}$。\n    *   变换回物理空间：$\\mathbf{L}\\,\\mathbf{u} = \\text{IFFT}(\\widehat{\\mathbf{L}\\,\\mathbf{u}})$。这种方法的计算复杂度为 $O(N \\log N)$，并避免了构建稠密矩阵 $\\mathbf{L}$。\n\n2.  **求解隐式步骤**：不动点迭代需要在每次迭代中求解形如 $(\\mathbf{I} + \\alpha \\mathbf{L})\\mathbf{w} = \\mathbf{f}$ 的线性系统。这也可以在傅里葉空间中高效完成。对该方程应用 FFT 可得：\n    $$\n    (\\mathbf{I} + \\alpha \\text{diag}(c^2\\mathbf{k}^{\\circ 2})) \\hat{\\mathbf{w}} = \\hat{\\mathbf{f}}\n    $$\n    这个对角系统可以为解的傅里叶系数逐元素求解：$\\hat{w}_k = \\hat{f}_k / (1 + \\alpha c^2 k^2)$。然后通过 IFFT 找到解 $\\mathbf{w}$。\n\n3.  **离散能量计算**：哈密顿量 $\\mathcal{E}$ 是一个积分，我们使用谱精度求积法（周期网格上的梯形法则）来近似它。离散能量为：\n    $$\n    \\mathcal{E}(\\mathbf{u},\\mathbf{v}) = \\frac{2\\pi}{N} \\sum_{j=0}^{N-1} \\left( \\tfrac{1}{2} v_j^2 + \\tfrac{c^2}{2} (u_x)_j^2 + \\tfrac{\\lambda}{4} u_j^4 \\right)\n    $$\n    为保持一致性，空间导数项 $\\mathbf{u}_x$ 也通过谱方法计算：$\\mathbf{u}_x = \\text{IFFT}(i\\mathbf{k} \\odot \\text{FFT}(\\mathbf{u}))$。然后所有项都在物理空间中计算并求和。\n\n#### 任务3：长期能量漂移分析\n应用于哈密顿系统的数值方法的长期行为与其几何性质，特别是辛性，密切相关。辛积分器能精确保持相空间的辛结构，从而能出色地长期保持一个修正哈密顿量，并使原始哈密顿量的误差有界。\n\n*   **情况4：$(\\gamma, \\beta) = (1/2, 0)$ (Störmer-Verlet)**：此方法是显式的。对于可分离的哈密顿量 $H=T(v)+P(u)$，该方法是辛的。克莱因-戈尔登方程具有此结构。因此，Störmer-Verlet 方法预计会表现出优越的长期能量行为。数值能量不会漂移，而是在初始能量附近以小幅度振荡。这是几何积分器的标志。\n\n*   **情况1和2：$(\\gamma, \\beta) = (1/2, 1/4)$ (梯形法则/Crank-Nicolson)**：这是一种隐式的二阶方法。对于线性哈密頓系统（$\\lambda=0$，情况1），它既是辛的，也能精确守恒二次能量。因此，对于情况1，能量误差应处于机器精度水平。对于非线性系统（$\\lambda \\ne 0$，情况2），它不再是辛的。虽然它是 A-稳定的，并且通常被认为具有良好的守恒特性，但它将在长时间内表现出缓慢的、长期的能量漂移。\n\n*   **情况3：$(\\gamma, \\beta) = (1/2, 1/6)$ (线性加速度法)**：这是另一种二阶隐式方法。与梯形法则一样，它对于非线性问题不是辛的。已知该方法会引入少量数值耗散，这通常会导致总能量随时间衰减。我们预期与梯形法则相比，它会产生更明显和系统性的能量漂移（衰减）。\n\n总之，$(\\gamma, \\beta)$ 的选择决定了积分器的几何性质。只有特定的选择，如显式 Störmer-Verlet 格式，对于此类问题是辛的，从而导致性质上更优的长期能量守恒。\n\n#### 任务4：能量投影修正\n由于一般的 Newmark 方法对于非线性问题不是能量守恒的，因此可以采用后验方式强制实现能量守恒。提议的修正是一种投影法。在一个标准的 Newmark 步骤计算出 $(\\tilde{\\mathbf{u}}_{n+1}, \\tilde{\\mathbf{v}}_{n+1})$ 之后，我们修改状态使其位于初始能量面 $\\mathcal{E}(\\mathbf{u}, \\mathbf{v}) = \\mathcal{E}_0$ 上。提议的投影保持位移固定，$\\mathbf{u}_{n+1} = \\tilde{\\mathbf{u}}_{n+1}$，并重缩放速度，$\\mathbf{v}_{n+1} = s \\tilde{\\mathbf{v}}_{n+1}$。\n\n离散能量为 $\\mathcal{E} = K(\\mathbf{v}) + P(\\mathbf{u})$，其中 $K(\\mathbf{v}) = \\frac{\\pi}{N} ||\\mathbf{v}||_2^2$ 是总动能，$P(\\mathbf{u})$ 是总势能。我们强制执行以下条件：\n$$\n\\mathcal{E}(\\mathbf{u}_{n+1}, s \\tilde{\\mathbf{v}}_{n+1}) = K(s \\tilde{\\mathbf{v}}_{n+1}) + P(\\mathbf{u}_{n+1}) = \\mathcal{E}_0\n$$\n由于 $K(s \\tilde{\\mathbf{v}}_{n+1}) = s^2 K(\\tilde{\\mathbf{v}}_{n+1})$，我们可以解出缩放因子 $s$：\n$$\ns^2 K(\\tilde{\\mathbf{v}}_{n+1}) = \\mathcal{E}_0 - P(\\mathbf{u}_{n+1}) \\implies s = \\sqrt{\\frac{\\mathcal{E}_0 - P(\\mathbf{u}_{n+1})}{K(\\tilde{\\mathbf{v}}_{n+1})}}\n$$\n仅当目标动能 $\\mathcal{E}_0 - P(\\mathbf{u}_{n+1})$ 为非负且当前动能 $K(\\tilde{\\mathbf{v}}_{n+1})$ 为正时，才应用此修正。该方法通过构造强制离散能量在每一步都守恒，从而消除了任何漂移。对于情况5，其非线性相对较大，这种投影将抵消底层梯形法则的漂移，从而使能量误差接近机器精度。", "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Solves the nonlinear Klein-Gordon equation using the Newmark family of methods\n    and analyzes energy conservation for different parameter choices.\n    \"\"\"\n    test_cases = [\n        # (gamma, beta, lambda, corrected, dt, T)\n        (0.5, 0.25, 0.0, False, 0.05, 50),\n        (0.5, 0.25, 1e-2, False, 0.05, 50),\n        (0.5, 1/6, 1e-2, False, 0.05, 50),\n        (0.5, 0.0, 1e-2, False, 0.02, 50),\n        (0.5, 0.25, 1e-1, True, 0.05, 50),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        gamma, beta, lam, corrected, dt, T = case\n\n        # --- Setup ---\n        N = 64\n        L = 2 * np.pi\n        c = 1.0\n        A = 0.1\n        dx = L / N\n        \n        x = np.arange(N) * dx\n        # Integer wavenumbers for a domain of length 2*pi\n        k = fftfreq(N) * N\n        \n        # Initial conditions\n        u = A * np.sin(x)\n        v = np.zeros(N)\n\n        # L operator eigenvalues in Fourier space for L = -c^2 * d_xx\n        L_op_fourier = (c * k)**2\n\n        # --- Energy Helper Functions ---\n        def get_potential_energy(u_vec):\n            # Spectral derivative for u_x\n            ux = np.real(ifft(1j * k * fft(u_vec)))\n            # Potential energy from u_x^2 and u^4 terms\n            pot_energy_L = 0.5 * c**2 * np.sum(ux**2)\n            pot_energy_NL = 0.25 * lam * np.sum(u_vec**4)\n            return (pot_energy_L + pot_energy_NL) * dx\n\n        def get_kinetic_energy(v_vec):\n            return 0.5 * np.sum(v_vec**2) * dx\n\n        def get_total_energy(u_vec, v_vec):\n            return get_potential_energy(u_vec) + get_kinetic_energy(v_vec)\n\n        # --- Time Stepping Loop ---\n        num_steps = int(T / dt)\n        energy_history = []\n        u_n, v_n = u, v\n        \n        E0 = get_total_energy(u_n, v_n)\n        # Avoid division by zero if initial energy is zero\n        E0_denom = np.abs(E0) if np.abs(E0) > 1e-15 else 1.0\n        energy_history.append(E0)\n\n        for _ in range(num_steps):\n            # 1. Calculate acceleration at step n\n            # L*u_n is computed spectrally\n            Lu_n = np.real(ifft(L_op_fourier * fft(u_n)))\n            a_n = -Lu_n - lam * u_n**3\n\n            # 2. Find displacement u_{n+1}\n            if beta == 0:  # Explicit method (Störmer-Verlet)\n                u_np1 = u_n + dt * v_n + 0.5 * dt**2 * a_n\n            else:  # Implicit method\n                alpha = beta * dt**2\n                r = u_n + dt * v_n + (0.5 - beta) * dt**2 * a_n\n                \n                # Fixed-point iteration to solve for u_{n+1}\n                u_np1_iter = u_n # Initial guess\n                lin_solver_denom = 1.0 + alpha * L_op_fourier\n                \n                for _ in range(5): # 5 iterations is sufficient for weak nonlinearity\n                    rhs = r - alpha * lam * u_np1_iter**3\n                    u_np1_iter = np.real(ifft(fft(rhs) / lin_solver_denom))\n                \n                u_np1 = u_np1_iter\n\n            # 3. Calculate acceleration at step n+1\n            Lu_np1 = np.real(ifft(L_op_fourier * fft(u_np1)))\n            a_np1 = -Lu_np1 - lam * u_np1**3\n            \n            # 4. Find velocity v_{n+1} (tentative)\n            v_np1_tilde = v_n + dt * ((1 - gamma) * a_n + gamma * a_np1)\n            \n            # 5. Apply energy projection if enabled\n            if corrected:\n                P_np1 = get_potential_energy(u_np1)\n                K_target = E0 - P_np1\n                \n                K_tilde = get_kinetic_energy(v_np1_tilde)\n                \n                if K_target >= 0.0 and K_tilde > 1e-15:\n                    s = np.sqrt(K_target / K_tilde)\n                    v_np1 = s * v_np1_tilde\n                else:\n                    v_np1 = v_np1_tilde # Leave unchanged if conditions not met\n            else:\n                v_np1 = v_np1_tilde\n\n            # Update state for next step\n            u_n, v_n = u_np1, v_np1\n\n            current_E = get_total_energy(u_n, v_n)\n            energy_history.append(current_E)\n        \n        # --- Post-processing ---\n        energy_history = np.array(energy_history)\n        relative_error = np.abs(energy_history - E0) / E0_denom\n        max_relative_error = np.max(relative_error)\n        results.append(max_relative_error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3424207"}]}