{"hands_on_practices": [{"introduction": "第一个实践是基础性的。我们将为一个代表半离散波动方程的通用哈密顿系统实现一个保能量积分器。通过构建一个所谓的“离散梯度”，你将学习如何设计一个即使对于非线性问题也能尊重系统能量这一基本不变量的数值格式 [@problem_id:3384894]。这个练习提供了几何积分核心机理和隐式求解器实现的实践经验。", "problem": "考虑典范形式下的半离散波动方程，该方程通过引入广义动量 $p$（由 $p = M \\dot{q}$ 定义）得到，其中 $M$ 是一个对称正定质量矩阵：\n$$\n\\dot{q} = M^{-1} p, \\quad \\dot{p} = -K q - g(q),\n$$\n其中 $K$ 是对称正定刚度矩阵，$g(q)$ 是非线性恢复力，假设其为一个标量势 $G(q)$ 的梯度，即 $g(q) = \\nabla G(q)$。相关的哈密顿量为\n$$\nH(q,p) = \\tfrac{1}{2} q^\\top K q + G(q) + \\tfrac{1}{2} p^\\top M^{-1} p.\n$$\n\n对于形式为 $\\dot{x} = S \\nabla H(x)$ 的哈密顿系统，可以通过离散梯度法构造一个保能量时间积分器，其中 $S$ 是一个常数斜对称矩阵。对于典范变量 $x = (q, p)$，$S$ 具有分块形式 $S = \\begin{pmatrix} 0  I \\\\ -I  0 \\end{pmatrix}$，其中 $I$ 是单位矩阵。离散梯度 $\\overline{\\nabla} H(x^n, x^{n+1})$ 是满足基本中值性质的任意映射\n$$\nH(x^{n+1}) - H(x^n) = \\overline{\\nabla} H(x^n, x^{n+1}) \\cdot (x^{n+1} - x^n),\n$$\n并且在极限 $x^{n+1} \\to x^n$ 下与精确梯度相容。使用这样的离散梯度，隐式单步法\n$$\n\\frac{x^{n+1} - x^n}{\\Delta t} = S \\, \\overline{\\nabla} H(x^n, x^{n+1})\n$$\n是保能量的，因为 $S$ 是斜对称的。\n\n您的任务是使用 Gonzalez 离散梯度为半离散波动方程的哈密顿量 $H(q,p)$ 实现该方法。对于可分哈密顿量 $H(q,p) = V(q) + T(p)$，其中 $V(q) = \\tfrac{1}{2} q^\\top K q + G(q)$ 且 $T(p) = \\tfrac{1}{2} p^\\top M^{-1} p$，您应构造一个保持中值性质的分块离散梯度\n$$\nH(q^{n+1},p^{n+1}) - H(q^n,p^n) = \\overline{\\nabla}_q V(q^n, q^{n+1}) \\cdot (q^{n+1} - q^n) + \\overline{\\nabla}_p T(p^n, p^{n+1}) \\cdot (p^{n+1} - p^n).\n$$\n二次项的离散梯度应与其精确梯度（在适当点求值以满足中值性质）相容，而 $G(q)$ 的离散梯度应为构造用来满足标量函数 $G$ 中值性质的 Gonzalez 离散梯度。\n\n从哈密顿系统的基本定律和核心定义以及离散梯度的中值性质出发，推导并实现一个稳健的牛顿型求解器，用于求解关于 $(q^{n+1}, p^{n+1})$ 的隐式更新方程。实现必须：\n- 接受对称正定矩阵 $M$ 和 $K$。\n- 接受一个多项式势 $G(q)$，其中 $g(q) = \\nabla G(q)$。\n- 对 $G(q)$ 使用 Gonzalez 离散梯度，以确保在代数层面上的精确离散能量守恒。\n- 通过计算数值轨迹上的哈密顿量 $H(q,p)$，并报告在积分窗口内与初始能量的最大绝对偏差，来数值验证能量守恒。\n\n所有量均为无量纲。不出现角度。最终数值结果必须是浮点数。\n\n测试套件：\n实现程序以运行积分器，并报告以下四个具有指定参数的案例中各自的哈密顿量最大绝对偏差 $E_{\\max}$：\n\n1. 一维线性振子（正常路径）：\n   - $M = [1.0]$，$K = [1.0]$，$G(q) = 0$。\n   - 初始状态：$q(0) = 1.0$, $p(0) = 0.0$。\n   - 时间步长：$\\Delta t = 0.05$。\n   - 步数：$N = 200$。\n\n2. 一维四次非线性：\n   - $M = [1.5]$，$K = [0.7]$，$G(q) = \\lambda \\tfrac{q^4}{4}$，其中 $\\lambda = 0.3$，因此 $g(q) = \\lambda q^3$。\n   - 初始状态：$q(0) = 0.2$, $p(0) = 0.3$。\n   - 时间步长：$\\Delta t = 0.02$。\n   - 步数：$N = 500$。\n\n3. 二维耦合多项式势：\n   - $M = \\mathrm{diag}(1.0, 2.0)$，$K = \\begin{pmatrix} 2.0  0.3 \\\\ 0.3  1.5 \\end{pmatrix}$。\n   - $G(q) = \\alpha \\tfrac{q_1^4 + q_2^4}{4} + \\beta \\tfrac{q_1^2 q_2^2}{2}$，其中 $\\alpha = 0.2$，$\\beta = 0.1$。\n   - 因此 $g(q) = \\begin{pmatrix} \\alpha q_1^3 + \\beta q_1 q_2^2 \\\\ \\alpha q_2^3 + \\beta q_2 q_1^2 \\end{pmatrix}$。\n   - 初始状态：$q(0) = (0.1, -0.2)$, $p(0) = (0.0, 0.25)$。\n   - 时间步长：$\\Delta t = 0.015$。\n   - 步数：$N = 400$。\n\n4. 一维平凡平衡点（边界情况）：\n   - $M = [1.0]$，$K = [2.0]$，$G(q) = \\tfrac{1}{4} q^4$，因此 $g(q) = q^3$。\n   - 初始状态：$q(0) = 0.0$, $p(0) = 0.0$。\n   - 时间步长：$\\Delta t = 0.1$。\n   - 步数：$N = 10$。\n\n输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目是按上述顺序列出的对应测试案例的哈密顿量最大绝对偏差 $E_{\\max}$。例如，输出格式必须严格为：\n$$\n[\\text{E1},\\text{E2},\\text{E3},\\text{E4}]\n$$\n其中每个 $\\text{E}$ 是一个浮点数。", "solution": "用户在几何数值积分领域提供了一个定义明确的问题。任务是使用离散梯度法，特别是针对非线性势使用 Gonzalez 型离散梯度，为一个典范哈密顿系统实现一个保能量时间积分器。该问题在科学上是合理的、自包含的，并且为测试案例提供了所有参数。该问题被认为是有效的。\n\n下面是该数值方法的推导和解释。\n\n系统由以下典范哈密顿方程描述：\n$$\n\\dot{q} = M^{-1} p, \\quad \\dot{p} = -K q - g(q)\n$$\n其中 $q$ 是广义坐标，$p$ 是广义动量，$M$ 是质量矩阵，$K$ 是刚度矩阵。力 $g(q)$ 是一个势的梯度，$g(q) = \\nabla G(q)$。代表系统总能量的哈密顿量是 $q$ 和 $p$ 的一个可分函数：\n$$\nH(q,p) = V(q) + T(p) = \\left(\\tfrac{1}{2} q^\\top K q + G(q)\\right) + \\left(\\tfrac{1}{2} p^\\top M^{-1} p\\right)\n$$\n该系统可以写成紧凑形式 $\\dot{x} = S \\nabla H(x)$，其中 $x=(q, p)$ 且 $S = \\begin{pmatrix} 0  I \\\\ -I  0 \\end{pmatrix}$。\n\n离散梯度法为构造保能量格式提供了一个通用框架。从时间步 $n$ 到 $n+1$ 的更新由以下隐式法则给出：\n$$\n\\frac{x^{n+1} - x^n}{\\Delta t} = S \\, \\overline{\\nabla} H(x^n, x^{n+1})\n$$\n其中 $\\Delta t$ 是时间步长，$\\overline{\\nabla} H$ 是哈密顿量 $H$ 的一个离散梯度。离散梯度必须满足中值性质 $H(x^{n+1}) - H(x^n) = \\overline{\\nabla} H(x^n, x^{n+1}) \\cdot (x^{n+1} - x^n)$ 并且与真实梯度相容，即 $\\overline{\\nabla} H(x, x) = \\nabla H(x)$。该方法的能量守恒性直接源于中值性质和 $S$ 的斜对称性：\n$$\nH(x^{n+1}) - H(x^n) = (x^{n+1} - x^n)^\\top \\overline{\\nabla} H = (\\Delta t \\, S \\, \\overline{\\nabla} H)^\\top \\overline{\\nabla} H = \\Delta t (\\overline{\\nabla} H)^\\top S^\\top \\overline{\\nabla} H = -\\Delta t (\\overline{\\nabla} H)^\\top S \\overline{\\nabla} H = 0\n$$\n最后一个等式成立是因为对于任意向量 $v$，如果 $S$ 是斜对称的，则 $v^\\top S v = 0$。因此，对于所有 $n$，$H(x^{n+1}) = H(x^n)$。\n\n对于可分哈密顿量，我们使用一个可分离散梯度：\n$$\n\\overline{\\nabla} H(x^n, x^{n+1}) = \\begin{pmatrix} \\overline{\\nabla}_q V(q^n, q^{n+1}) \\\\ \\overline{\\nabla}_p T(p^n, p^{n+1}) \\end{pmatrix}\n$$\n将此代入更新法则，得到一对耦合方程：\n$$\n\\frac{q^{n+1} - q^n}{\\Delta t} = \\overline{\\nabla}_p T(p^n, p^{n+1}) \\quad (1)\n$$\n$$\n\\frac{p^{n+1} - p^n}{\\Delta t} = -\\overline{\\nabla}_q V(q^n, q^{n+1}) \\quad (2)\n$$\n\n我们现在必须定义具体的离散梯度。\n对于二次动能 $T(p) = \\frac{1}{2} p^\\top M^{-1} p$，一个满足中值性质的合适离散梯度是中点梯度：\n$$\n\\overline{\\nabla}_p T(p^n, p^{n+1}) = \\nabla_p T \\left( \\frac{p^n + p^{n+1}}{2} \\right) = M^{-1} \\left( \\frac{p^n + p^{n+1}}{2} \\right)\n$$\n类似地，对于势能的二次部分 $\\frac{1}{2} q^\\top K q$，我们使用：\n$$\n\\overline{\\nabla}_q \\left(\\tfrac{1}{2} q^\\top K q\\right)(q^n, q^{n+1}) = K \\left( \\frac{q^n + q^{n+1}}{2} \\right)\n$$\n对于非线性势 $G(q)$，我们使用 Gonzalez 离散梯度。对于可以表示为单坐标函数乘积之和的势，可以推导出一个对称形式。对于一个维度为 $d$ 的多项式势 $G(q)$，其分量 $\\overline{g}_i(q^n, q^{n+1}) = (\\overline{\\nabla}G(q^n, q^{n+1}))_i$ 被构造以满足中值性质。对于测试套件中的势，这会导出可以直接实现的特定代数表达式。例如，对于一维势 $G(q)$，如果 $q^{n+1} \\neq q^n$，则 $\\overline{\\nabla}G(q^n, q^{n+1}) = (G(q^{n+1})-G(q^n))/(q^{n+1}-q^n)$，否则为 $\\nabla G(q^n)$。对于多项式势，这可以写成数值稳定的多项式形式。\n\n完整的更新方程为：\n$$\nq^{n+1} - q^n - \\frac{\\Delta t}{2} M^{-1} (p^n + p^{n+1}) = 0\n$$\n$$\np^{n+1} - p^n + \\frac{\\Delta t}{2} K (q^n + q^{n+1}) + \\Delta t \\, \\overline{\\nabla}G(q^n, q^{n+1}) = 0\n$$\n这是一个关于未知状态 $(q^{n+1}, p^{n+1})$ 的 $2d$ 个非线性代数方程组。我们使用牛顿法求解此系统。设未知数为 $y = (q^{n+1}, p^{n+1})$，方程组为 $F(y) = 0$。牛顿迭代为 $y_{k+1} = y_k - [J_F(y_k)]^{-1} F(y_k)$，其中 $J_F$ 是 $F$ 的雅可比矩阵。迭代从一个初始猜测开始，例如 $y_0 = (q^n, p^n)$。\n\n残差向量为 $F(y_k) = (F_q, F_p)$，其中 $y_k = (q_k, p_k)$：\n$$\nF_q(q_k, p_k) = q_k - q^n - \\frac{\\Delta t}{2} M^{-1} (p^n + p_k)\n$$\n$$\nF_p(q_k, p_k) = p_k - p^n + \\frac{\\Delta t}{2} K (q^n + q_k) + \\Delta t \\, \\overline{\\nabla}G(q^n, q_k)\n$$\n雅可比矩阵 $J_F = \\frac{\\partial F}{\\partial y}$ 由下式给出：\n$$\nJ_F = \\begin{pmatrix} \\partial F_q / \\partial q_k  \\partial F_q / \\partial p_k \\\\ \\partial F_p / \\partial q_k  \\partial F_p / \\partial p_k \\end{pmatrix} = \\begin{pmatrix} I  -\\frac{\\Delta t}{2} M^{-1} \\\\ \\frac{\\Delta t}{2} K + \\Delta t J_{\\overline{g}}  I \\end{pmatrix}\n$$\n其中 $J_{\\overline{g}} = \\frac{\\partial}{\\partial q_k} \\overline{\\nabla}G(q^n, q_k)$ 是 $G$ 的离散梯度的雅可比矩阵。牛顿更新步骤涉及求解线性系统 $J_F \\Delta y = -F$ 以获得更新量 $\\Delta y = (\\Delta q, \\Delta p)$。这个 $2d \\times 2d$ 的系统可以通过分块消元法更有效地求解。我们首先从 $d \\times d$ 系统求解 $\\Delta q$：\n$$\n\\left( \\frac{2}{\\Delta t} M + \\frac{\\Delta t}{2} K + \\Delta t J_{\\overline{g}} \\right) \\Delta q = -F_p - \\frac{2}{\\Delta t} M F_q\n$$\n然后通过代入找到 $\\Delta p$：\n$$\n\\Delta p = \\frac{2}{\\Delta t} M (\\Delta q + F_q)\n$$\n此过程重复进行，直到残差 $F$ 或更新量 $\\Delta y$ 的范数低于选定的容差。该实现将使用这个基于牛顿法的求解器来对每个测试案例进行时间推进，并报告数值计算的哈密顿量的最大偏差。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the energy-conserving integrator.\n    \"\"\"\n\n    def get_hamiltonian_func(M, K, G_func):\n        \"\"\"Constructs the Hamiltonian function for a given system.\"\"\"\n        M_inv = np.linalg.inv(M)\n        def hamiltonian(q, p):\n            T = 0.5 * p.T @ M_inv @ p\n            V_lin = 0.5 * q.T @ K @ q\n            V_nonlin = G_func(q)\n            return float(T + V_lin + V_nonlin)\n        return hamiltonian\n\n    def newton_solver(q_n, p_n, M, K, dG_disc_func, J_dG_disc_func, dt, tol=1e-13, max_iter=20):\n        \"\"\"\n        Solves the implicit update equations for one time step using Newton's method.\n        \"\"\"\n        dim = len(q_n)\n        M_inv = np.linalg.inv(M)\n        \n        # Initial guess for (q_{n+1}, p_{n+1})\n        q_k = np.copy(q_n)\n        p_k = np.copy(p_n)\n\n        for _ in range(max_iter):\n            # Evaluate residuals F_q, F_p\n            F_q = q_k - q_n - (dt / 2.0) * M_inv @ (p_n + p_k)\n            \n            dG = dG_disc_func(q_n, q_k)\n            F_p = p_k - p_n + (dt / 2.0) * K @ (q_n + q_k) + dt * dG\n            \n            residual_norm = np.linalg.norm(np.concatenate([F_q, F_p]))\n            if residual_norm  tol:\n                return q_k, p_k\n            \n            # Evaluate Jacobian of the discrete gradient of G\n            J_dG = J_dG_disc_func(q_n, q_k)\n            \n            # Form and solve the linear system for the update (dq, dp)\n            # A * dq = b\n            A = (2.0 / dt) * M + (dt / 2.0) * K + dt * J_dG\n            b = -F_p - (2.0 / dt) * M @ F_q\n            \n            dq = np.linalg.solve(A, b)\n            dp = (2.0 / dt) * M @ (dq + F_q)\n            \n            q_k += dq\n            p_k += dp\n\n        # Return the last computed value if max_iter is reached.\n        # For this problem setup, convergence should be rapid.\n        return q_k, p_k\n\n    def run_simulation(case):\n        \"\"\"\n        Runs a full simulation for a given test case configuration.\n        \"\"\"\n        M, K = case[\"M\"], case[\"K\"]\n        G_func = case[\"G\"]\n        dG_disc_func = case[\"dG_disc\"]\n        J_dG_disc_func = case[\"J_dG_disc\"]\n        q, p = case[\"q0\"], case[\"p0\"]\n        dt, N = case[\"dt\"], case[\"N\"]\n\n        H_func = get_hamiltonian_func(M, K, G_func)    \n        \n        energies = np.zeros(N + 1)\n        energies[0] = H_func(q, p)\n\n        for i in range(N):\n            q, p = newton_solver(q, p, M, K, dG_disc_func, J_dG_disc_func, dt)\n            energies[i+1] = H_func(q, p)\n            \n        initial_energy = energies[0]\n        max_dev = np.max(np.abs(energies - initial_energy))\n        \n        return max_dev\n\n    # --- Test Case Definitions ---\n\n    # Case 1: 1D Linear Oscillator\n    case1 = {\n        \"M\": np.array([[1.0]]), \"K\": np.array([[1.0]]),\n        \"G\": lambda q: 0.0,\n        \"dG_disc\": lambda q0, q1: np.array([0.0]),\n        \"J_dG_disc\": lambda q0, q1: np.array([[0.0]]),\n        \"q0\": np.array([1.0]), \"p0\": np.array([0.0]),\n        \"dt\": 0.05, \"N\": 200,\n    }\n\n    # Case 2: 1D Quartic Nonlinearity\n    lam = 0.3\n    case2 = {\n        \"M\": np.array([[1.5]]), \"K\": np.array([[0.7]]),\n        \"G\": lambda q: lam * q[0]**4 / 4.0,\n        \"dG_disc\": lambda q0, q1: np.array([\n            lam/4.0 * (q1[0]**3 + q1[0]**2*q0[0] + q1[0]*q0[0]**2 + q0[0]**3)\n        ]),\n        \"J_dG_disc\": lambda q0, q1: np.array([[\n            lam/4.0 * (3*q1[0]**2 + 2*q1[0]*q0[0] + q0[0]**2)\n        ]]),\n        \"q0\": np.array([0.2]), \"p0\": np.array([0.3]),\n        \"dt\": 0.02, \"N\": 500,\n    }\n\n    # Case 3: 2D Coupled Polynomial Potential\n    alpha, beta = 0.2, 0.1\n    def G_case3(q):\n        return alpha * (q[0]**4 + q[1]**4) / 4.0 + beta * q[0]**2 * q[1]**2 / 2.0\n\n    def dG_disc_case3(q0, q1):\n        g1 = alpha/4.0 * (q1[0]**3 + q1[0]**2*q0[0] + q1[0]*q0[0]**2 + q0[0]**3) + \\\n             beta/4.0 * (q1[0] + q0[0]) * (q1[1]**2 + q0[1]**2)\n        g2 = alpha/4.0 * (q1[1]**3 + q1[1]**2*q0[1] + q1[1]*q0[1]**2 + q0[1]**3) + \\\n             beta/4.0 * (q1[0]**2 + q0[0]**2) * (q1[1] + q0[1])\n        return np.array([g1, g2])\n\n    def J_dG_disc_case3(q0, q1):\n        J11 = alpha/4.0 * (3*q1[0]**2 + 2*q1[0]*q0[0] + q0[0]**2) + \\\n              beta/4.0 * (q1[1]**2 + q0[1]**2)\n        J12 = beta/2.0 * (q1[0] + q0[0]) * q1[1]\n        J21 = beta/2.0 * q1[0] * (q1[1] + q0[1])\n        J22 = alpha/4.0 * (3*q1[1]**2 + 2*q1[1]*q0[1] + q0[1]**2) + \\\n              beta/4.0 * (q1[0]**2 + q0[0]**2)\n        return np.array([[J11, J12], [J21, J22]])\n\n    case3 = {\n        \"M\": np.diag([1.0, 2.0]),\n        \"K\": np.array([[2.0, 0.3], [0.3, 1.5]]),\n        \"G\": G_case3,\n        \"dG_disc\": dG_disc_case3,\n        \"J_dG_disc\": J_dG_disc_case3,\n        \"q0\": np.array([0.1, -0.2]), \"p0\": np.array([0.0, 0.25]),\n        \"dt\": 0.015, \"N\": 400,\n    }\n\n    # Case 4: 1D Trivial Equilibrium\n    case4 = {\n        \"M\": np.array([[1.0]]), \"K\": np.array([[2.0]]),\n        \"G\": lambda q: q[0]**4 / 4.0,\n        \"dG_disc\": lambda q0, q1: np.array([\n            1.0/4.0 * (q1[0]**3 + q1[0]**2*q0[0] + q1[0]*q0[0]**2 + q0[0]**3)\n        ]),\n        \"J_dG_disc\": lambda q0, q1: np.array([[\n            1.0/4.0 * (3*q1[0]**2 + 2*q1[0]*q0[0] + q0[0]**2)\n        ]]),\n        \"q0\": np.array([0.0]), \"p0\": np.array([0.0]),\n        \"dt\": 0.1, \"N\": 10,\n    }\n\n    test_cases = [case1, case2, case3, case4]\n    results = [run_simulation(case) for case in test_cases]\n    \n    # Format the output string exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3384894"}, {"introduction": "现实世界的系统通常不是孤立的；它们通过边界与环境相互作用。这个实践将能量守恒的概念扩展到更普适的能量平衡，即能量可以通过边界通量注入或耗散 [@problem_id:3384928]。你将为具有混合边界条件的波动方程推导连续能量平衡定律，然后设计一个有限元格式来离散地模拟这个精确的收支关系，验证能量的变化等于在边界上所做的功。", "problem": "考虑有界域上的标量波动方程，其带有混合边界条件。设 $\\Omega \\subset \\mathbb{R}^d$ 是一个足够正则的区域，将其边界 $\\partial \\Omega$ 分割为一个狄利克雷（Dirichlet）部分 $\\partial \\Omega_D$ 和一个诺伊曼（Neumann）部分 $\\partial \\Omega_N$，满足 $\\partial \\Omega_D \\cap \\partial \\Omega_N = \\emptyset$ 和 $\\partial \\Omega_D \\cup \\partial \\Omega_N = \\partial \\Omega$。标量位移 $u(x,t)$ 满足以下初边值问题\n$$\nu_{tt}(x,t) = c^2 \\Delta u(x,t) \\quad \\text{for } x \\in \\Omega, \\ t \\ge 0,\n$$\n边界条件为\n$$\nu(x,t) = 0 \\ \\text{on } \\partial \\Omega_D, \\qquad c^2 \\frac{\\partial u}{\\partial n}(x,t) = g(x,t) \\ \\text{on } \\partial \\Omega_N,\n$$\n初始数据为 $u(x,0) = u_0(x)$，$u_t(x,0) = v_0(x)$。其中 $c  0$ 是波速，$\\Delta$ 是拉普拉斯算子，$\\partial u/\\partial n$ 是外法向导数。定义机械能\n$$\nE(t) = \\frac{1}{2} \\int_{\\Omega} \\left( u_t(x,t)^2 + c^2 \\left|\\nabla u(x,t)\\right|^2 \\right) \\, dx.\n$$\n\n任务 1 (第一性原理推导)：从给定的偏微分方程和边界条件出发，依据第一性原理推导时间导数 $\\frac{d}{dt} E(t)$ 的精确表达式，用边界通量和内部项表示。说明边界条件如何决定哪些部分对能量变化率有贡献，哪些没有，并仅用定义在 $\\partial \\Omega_N$ 上的量来表示最终的变化率。\n\n任务 2 (离散化设计)：将问题具体化到一维情况，其中 $\\Omega = (0,L)$，$x=0$ 处为狄利克雷边界条件，$x=L$ 处为诺伊曼边界条件。全程使用无量纲单位。在包含 $N_{\\text{el}}$ 个单元的均匀网格上，使用标准的伽辽金（Galerkin）有限元方法，配以连续的分片线性基函数。推导出一阶形式的半离散系统\n$$\n\\mathbf{u}_t = \\mathbf{v}, \\qquad \\mathbf{M} \\mathbf{v}_t + \\mathbf{K} \\mathbf{u} = \\mathbf{f}(t),\n$$\n其中 $\\mathbf{M}$ 是一致质量矩阵，$\\mathbf{K}$ 是经 $c^2$ 加权的刚度矩阵，$\\mathbf{f}(t)$ 是由 $x=L$ 处的边界牵引力组装而成的诺伊曼载荷向量。定义离散能量\n$$\nE_d(t) = \\frac{1}{2} \\mathbf{v}(t)^{\\top} \\mathbf{M} \\mathbf{v}(t) + \\frac{1}{2} \\mathbf{u}(t)^{\\top} \\mathbf{K} \\mathbf{u}(t).\n$$\n推导半离散能量变化率，并展示其如何依赖于施加在 $x=L$ 处的离散边界牵引力。\n\n任务 3 (能量相容的时间积分器)：为该半离散系统设计并实现一个能量相容的时间积分器。对上述一阶形式应用隐式中点格式，其中载荷向量在时间中点进行求值。推导单步更新方程以及每一步需要求解的线性系统。证明在没有诺伊曼边界牵引力的情况下，该方法能精确守恒离散能量；而在有诺伊曼边界牵引力的情况下，一个时间步内的离散能量变化与使用中点求积计算的离散边界功完全匹配。\n\n任务 4 (程序与测试套件)：实现一维有限元组装和隐式中点时间积分器，以数值方式验证能量收支。所有量均为无量纲。对于下方的每个测试用例，使用时间步长 $\\Delta t$ 积分至时间 $T$，并计算绝对误差\n$$\n\\varepsilon = \\left| E_d(T) - E_d(0) - W \\right|,\n$$\n其中 $W$ 是累积的离散边界功，计算方式为\n$$\nW = \\sum_{n=0}^{N-1} \\Delta t \\, \\mathbf{v}_{n+\\frac{1}{2}}^{\\top} \\mathbf{f}\\!\\left(t_{n+\\frac{1}{2}}\\right),\n$$\n其中 $\\mathbf{v}_{n+\\frac{1}{2}}$ 和 $\\mathbf{f}\\!\\left(t_{n+\\frac{1}{2}}\\right)$ 在时间中点 $t_{n+\\frac{1}{2}} = t_n + \\Delta t/2$ 处求值。使用以下测试套件：\n\n- 测试用例 1 (无边界功，能量守恒)：$L = 1$，$c = 1$，$N_{\\text{el}} = 50$，$\\Delta t = 10^{-3}$，$T = 0.5$，诺伊曼牵引力 $g(t) = 0$，初始位移 $u_0(x) = \\sin(\\pi x)$，初始速度 $v_0(x) = 0$。\n- 测试用例 2 (正弦边界功注入)：$L = 1$，$c = 1$，$N_{\\text{el}} = 50$，$\\Delta t = 10^{-3}$，$T = 0.5$，诺伊曼牵引力 $g(t) = \\sin(6\\pi t)$，初始位移 $u_0(x) = 0$，初始速度 $v_0(x) = 0$。\n- 测试用例 3 (斜坡边界功及非零初始速度)：$L = 1$，$c = 0.8$，$N_{\\text{el}} = 60$，$\\Delta t = 5 \\times 10^{-4}$，$T = 0.6$，诺伊曼牵引力 $g(t) = 0.5\\, t$，初始位移 $u_0(x) = 0$，初始速度 $v_0(x) = \\sin(2\\pi x)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”）。每个结果必须是对应测试用例的 $\\varepsilon$ 的浮点值，并按上面列出的顺序排列。", "solution": "所提出的问题是偏微分方程数值分析中的一个综合性练习，特别关注于波动方程的保能量积分器。该问题在科学上是合理的、适定的，其所有组成部分在计算力学和几何数值积分领域都是标准的。该问题被验证为是合理的，并且可以构建一个完整的解决方案。解决方案将按顺序处理四个任务：推导连续能量平衡、有限元半离散化、设计能量相容的时间积分器，以及最后的数值实现与验证。\n\n### 任务 1：连续能量变化率推导\n\n系统的机械能定义为\n$$\nE(t) = \\frac{1}{2} \\int_{\\Omega} \\left( u_t(x,t)^2 + c^2 \\left|\\nabla u(x,t)\\right|^2 \\right) \\, dx.\n$$\n为求其变化率，我们对时间 $t$ 求导。由于区域 $\\Omega$ 是固定的，我们可以将导数移到积分内部（莱布尼兹积分法则）：\n$$\n\\frac{dE}{dt} = \\int_{\\Omega} \\left( \\frac{\\partial}{\\partial t} \\left(\\frac{1}{2} u_t^2\\right) + \\frac{\\partial}{\\partial t} \\left(\\frac{c^2}{2} |\\nabla u|^2\\right) \\right) \\, dx = \\int_{\\Omega} \\left( u_t u_{tt} + c^2 \\nabla u \\cdot \\nabla u_t \\right) \\, dx.\n$$\n我们将波动方程 $u_{tt} = c^2 \\Delta u$ 代入此表达式：\n$$\n\\frac{dE}{dt} = \\int_{\\Omega} \\left( u_t (c^2 \\Delta u) + c^2 \\nabla u \\cdot \\nabla u_t \\right) \\, dx = c^2 \\int_{\\Omega} \\left( u_t \\Delta u + \\nabla u_t \\cdot \\nabla u \\right) \\, dx.\n$$\n注意到被积函数是一个散度的展开式，具体来说，使用乘积法则 $\\nabla \\cdot (\\phi \\mathbf{F}) = (\\nabla \\phi) \\cdot \\mathbf{F} + \\phi (\\nabla \\cdot \\mathbf{F})$，我们令 $\\phi = u_t$ 和 $\\mathbf{F} = \\nabla u$。这给出 $\\nabla \\cdot (u_t \\nabla u) = \\nabla u_t \\cdot \\nabla u + u_t \\Delta u$。被积函数恰好是这个表达式。因此，\n$$\n\\frac{dE}{dt} = c^2 \\int_{\\Omega} \\nabla \\cdot (u_t \\nabla u) \\, dx.\n$$\n应用散度定理 $\\int_{\\Omega} \\nabla \\cdot \\mathbf{V} \\, dx = \\oint_{\\partial \\Omega} \\mathbf{V} \\cdot \\mathbf{n} \\, ds$，其中 $\\mathbf{n}$ 是单位外法向量，我们得到：\n$$\n\\frac{dE}{dt} = c^2 \\oint_{\\partial \\Omega} (u_t \\nabla u) \\cdot \\mathbf{n} \\, ds = c^2 \\oint_{\\partial \\Omega} u_t \\frac{\\partial u}{\\partial n} \\, ds.\n$$\n边界 $\\partial \\Omega$ 被划分为 $\\partial \\Omega_D$ 和 $\\partial \\Omega_N$。我们相应地拆分该积分：\n$$\n\\frac{dE}{dt} = c^2 \\int_{\\partial \\Omega_D} u_t \\frac{\\partial u}{\\partial n} \\, ds + c^2 \\int_{\\partial \\Omega_N} u_t \\frac{\\partial u}{\\partial n} \\, ds.\n$$\n在狄利克雷边界 $\\partial \\Omega_D$ 上，我们有 $u(x,t) = 0$ 对所有 $t \\ge 0$ 成立。这意味着其切向导数为零，其时间导数也为零：$u_t(x,t) = 0$ 对于 $x \\in \\partial \\Omega_D$。因此，第一个积分为零。在诺伊曼边界 $\\partial \\Omega_N$ 上，条件为 $c^2 \\frac{\\partial u}{\\partial n}(x,t) = g(x,t)$。代入这些条件可得到能量变化率的最终表达式：\n$$\n\\frac{dE}{dt} = 0 + \\int_{\\partial \\Omega_N} u_t(x,t) \\left( c^2 \\frac{\\partial u}{\\partial n}(x,t) \\right) \\, ds = \\int_{\\partial \\Omega_N} u_t(x,t) g(x,t) \\, ds.\n$$\n此结果表明，系统机械能的变化率等于诺伊曼边界上的牵引力 $g(x,t)$ 所做的功率。如果 $g=0$ 或 $\\partial\\Omega_N$ 为空集，则能量守恒。\n\n### 任务 2：半离散化与离散能量变化率\n\n对于 $\\Omega = (0,L)$ 上的一维情况，其中 $u(0,t)=0$ 且 $c^2 u_x(L,t) = g(t)$，我们使用伽辽金有限元方法。位移近似为 $u(x,t) \\approx u^h(x,t) = \\sum_{j=1}^{N} u_j(t) \\phi_j(x)$，其中 $\\phi_j(x)$ 是在尺寸为 $h = L/N_{\\text{el}}$ 的均匀网格上的标准分片线性“帽状”基函数（$N=N_{\\text{el}}$ 是自由节点的数量）。基函数 $\\phi_j(x)$ 在节点 $x_j=j \\cdot h$ 处为 $1$，在所有其他节点处为 $0$。求和从 $j=1$ 开始，以强制施加狄利克雷条件 $u(0,t)=0$。PDE 的弱形式通过乘以一个测试函数 $w^h(x) = \\sum_{i=1}^N w_i \\phi_i(x)$ 并在域上积分得到：\n$$\n\\int_0^L w^h u^h_{tt} \\, dx + c^2 \\int_0^L w^h_x u^h_x \\, dx = \\left[ c^2 w^h u^h_x \\right]_0^L.\n$$\n边界项的值为 $w^h(L) g(t)$，因为 $w^h(0)=0$ 且 $c^2 u_x(L,t)=g(t)$。代入 $u^h$ 和 $w^h$ 的有限元展开式，并要求该方程对所有 $w_i$（即对每个基函数 $\\phi_i$）都成立，便得到半离散系统：\n$$\n\\sum_{j=1}^N \\left(\\int_0^L \\phi_i \\phi_j dx\\right) \\ddot{u}_j(t) + c^2 \\sum_{j=1}^N \\left(\\int_0^L \\phi'_i \\phi'_j dx\\right) u_j(t) = \\phi_i(L) g(t), \\quad \\text{for } i=1, \\dots, N.\n$$\n这是一个二阶矩阵系统 $\\mathbf{M} \\ddot{\\mathbf{u}} + \\mathbf{K} \\mathbf{u} = \\mathbf{f}(t)$，其矩阵和向量的项为：\n- 质量矩阵：$M_{ij} = \\int_0^L \\phi_i(x) \\phi_j(x) \\, dx$。\n- 刚度矩阵：$K_{ij} = c^2 \\int_0^L \\phi'_i(x) \\phi'_j(x) \\, dx$。\n- 载荷向量：$f_i(t) = \\phi_i(L) g(t)$。该向量除了最后一个分量 $f_N(t) = \\phi_N(L) g(t) = g(t)$ 外，其余均为零。\n定义 $\\mathbf{v} = \\dot{\\mathbf{u}}$，我们得到一阶系统：$\\dot{\\mathbf{u}} = \\mathbf{v}$，$\\mathbf{M} \\dot{\\mathbf{v}} + \\mathbf{K} \\mathbf{u} = \\mathbf{f}(t)$。\n离散能量为 $E_d(t) = \\frac{1}{2} \\mathbf{v}^{\\top} \\mathbf{M} \\mathbf{v} + \\frac{1}{2} \\mathbf{u}^{\\top} \\mathbf{K} \\mathbf{u}$。其时间导数为：\n$$\n\\frac{dE_d}{dt} = \\dot{\\mathbf{v}}^{\\top} \\mathbf{M} \\mathbf{v} + \\dot{\\mathbf{u}}^{\\top} \\mathbf{K} \\mathbf{u}.\n$$\n（利用了 $\\mathbf{M}$ 和 $\\mathbf{K}$ 的对称性）。代入 $\\dot{\\mathbf{u}}=\\mathbf{v}$ 和 $\\mathbf{M}\\dot{\\mathbf{v}} = \\mathbf{f} - \\mathbf{K}\\mathbf{u}$：\n$$\n\\frac{dE_d}{dt} = (\\mathbf{M}^{-1}(\\mathbf{f} - \\mathbf{K}\\mathbf{u}))^{\\top} \\mathbf{M} \\mathbf{v} + \\mathbf{v}^{\\top} \\mathbf{K} \\mathbf{u} = (\\mathbf{f} - \\mathbf{K}\\mathbf{u})^{\\top} \\mathbf{M}^{-1} \\mathbf{M} \\mathbf{v} + \\mathbf{v}^{\\top} \\mathbf{K} \\mathbf{u} = \\mathbf{f}^{\\top}\\mathbf{v} - \\mathbf{u}^{\\top}\\mathbf{K}\\mathbf{v} + \\mathbf{v}^{\\top}\\mathbf{K}\\mathbf{u}.\n$$\n因为 $\\mathbf{u}^{\\top}\\mathbf{K}\\mathbf{v} = (\\mathbf{v}^{\\top}\\mathbf{K}\\mathbf{u})^{\\top}$ 是一个标量，它等于 $\\mathbf{v}^{\\top}\\mathbf{K}\\mathbf{u}$。包含 $\\mathbf{K}$ 的项相互抵消，剩下：\n$$\n\\frac{dE_d}{dt} = \\mathbf{v}^{\\top} \\mathbf{f}(t).\n$$\n这是连续功率恒等式的离散模拟，其中能量变化率是广义速度向量和外力向量的内积。\n\n### 任务 3：能量相容的时间积分器\n\n对一阶系统在一个时间步 $\\Delta t$（从 $t_n$ 到 $t_{n+1}$）上应用隐式中点格式：\n$$\n\\frac{\\mathbf{u}_{n+1} - \\mathbf{u}_n}{\\Delta t} = \\mathbf{v}_{n+\\frac{1}{2}}, \\qquad \\mathbf{M} \\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{\\Delta t} + \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}} = \\mathbf{f}_{n+\\frac{1}{2}},\n$$\n其中在中点处的量被定义为平均值，例如 $\\mathbf{u}_{n+\\frac{1}{2}} = (\\mathbf{u}_n + \\mathbf{u}_{n+1})/2$。\n为推导单步更新，我们消去 $\\mathbf{v}_{n+1}$ 和 $\\mathbf{v}_{n+\\frac{1}{2}}$。从第一个方程，$\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t \\mathbf{v}_{n+\\frac{1}{2}}$，以及 $\\mathbf{v}_{n+1} = 2\\mathbf{v}_{n+\\frac{1}{2}} - \\mathbf{v}_n$。将这些代入第二个方程，得到一个关于未知数 $\\mathbf{u}_{n+1}$ 的系统。经过代数整理，我们得到每个时间步需要为 $\\mathbf{u}_{n+1}$ 求解的线性系统：\n$$\n\\left(\\mathbf{M} + \\frac{\\Delta t^2}{4}\\mathbf{K}\\right) \\mathbf{u}_{n+1} = \\frac{\\Delta t^2}{2} \\mathbf{f}_{n+\\frac{1}{2}} + \\left(\\mathbf{M} - \\frac{\\Delta t^2}{4}\\mathbf{K}\\right)\\mathbf{u}_n + \\Delta t \\mathbf{M} \\mathbf{v}_n.\n$$\n一旦 $\\mathbf{u}_{n+1}$ 计算出来，$\\mathbf{v}_{n+1}$ 可通过 $\\mathbf{v}_{n+1} = \\frac{2}{\\Delta t}(\\mathbf{u}_{n+1} - \\mathbf{u}_n) - \\mathbf{v}_n$ 求得。\n\n为证明能量相容性，我们考察离散能量在一个步长内的变化 $E_{d,n+1} - E_{d,n}$：\n$$\nE_{d,n+1} - E_{d,n} = \\frac{1}{2}(\\mathbf{v}_{n+1}^{\\top}\\mathbf{M}\\mathbf{v}_{n+1} - \\mathbf{v}_n^{\\top}\\mathbf{M}\\mathbf{v}_n) + \\frac{1}{2}(\\mathbf{u}_{n+1}^{\\top}\\mathbf{K}\\mathbf{u}_{n+1} - \\mathbf{u}_n^{\\top}\\mathbf{K}\\mathbf{u}_n).\n$$\n使用恒等式 $a^2-b^2 = (a-b)(a+b)$，上式变为：\n$$\nE_{d,n+1} - E_{d,n} = (\\mathbf{v}_{n+1} - \\mathbf{v}_n)^{\\top} \\mathbf{M} \\mathbf{v}_{n+\\frac{1}{2}} + (\\mathbf{u}_{n+1} - \\mathbf{u}_n)^{\\top} \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}}.\n$$\n代入中点格式的离散化形式 $\\mathbf{u}_{n+1} - \\mathbf{u}_n = \\Delta t \\mathbf{v}_{n+\\frac{1}{2}}$ 和 $\\mathbf{v}_{n+1} - \\mathbf{v}_n = \\Delta t \\mathbf{M}^{-1}(\\mathbf{f}_{n+\\frac{1}{2}} - \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}})$：\n$$\nE_{d,n+1} - E_{d,n} = \\left(\\Delta t \\mathbf{M}^{-1}(\\mathbf{f}_{n+\\frac{1}{2}} - \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}})\\right)^{\\top} \\mathbf{M} \\mathbf{v}_{n+\\frac{1}{2}} + \\left(\\Delta t \\mathbf{v}_{n+\\frac{1}{2}}\\right)^{\\top} \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}}.\n$$\n这可以简化为：\n$$\nE_{d,n+1} - E_{d,n} = \\Delta t \\left( \\mathbf{f}_{n+\\frac{1}{2}}^{\\top} \\mathbf{v}_{n+\\frac{1}{2}} - \\mathbf{u}_{n+\\frac{1}{2}}^{\\top}\\mathbf{K}\\mathbf{v}_{n+\\frac{1}{2}} \\right) + \\Delta t \\mathbf{v}_{n+\\frac{1}{2}}^{\\top} \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}}.\n$$\n包含 $\\mathbf{K}$ 的项相互抵消，剩下 $E_{d,n+1} - E_{d,n} = \\Delta t \\, \\mathbf{v}_{n+\\frac{1}{2}}^{\\top} \\mathbf{f}_{n+\\frac{1}{2}}$。这个方程表明，在一个时间步内的离散能量变化，与使用中点求积计算的外力功完全相等。对所有时间步求和可得 $E_d(T) - E_d(0) = W$，其中 $W = \\sum_{n=0}^{N-1} \\Delta t \\, \\mathbf{v}_{n+\\frac{1}{2}}^{\\top} \\mathbf{f}_{n+\\frac{1}{2}}$。因此，该方法精确地平衡了离散能量收支。在没有外力（$\\mathbf{f}=0$）的情况下，$W=0$ 且离散能量 $E_d$ 精确守恒。\n\n### 任务 4：程序与测试套件实现\n\n该实现将推导出的数学框架转化为计算机程序。我们开发了一个 Python 脚本，为每个测试用例执行以下步骤：\n1.  **有限元组装**：为包含 $N_{\\text{el}}$ 个分片线性单元（对应 $N=N_{\\text{el}}$ 个无约束自由度）的一维均匀网格组装一致质量矩阵 $\\mathbf{M}$ 和（经 $c^2$ 缩放的）刚度矩阵 $\\mathbf{K}$。\n2.  **初始条件**：通过求解线性系统 $\\mathbf{M}\\mathbf{u}_0 = \\mathbf{b}_u$ 和 $\\mathbf{M}\\mathbf{v}_0 = \\mathbf{b}_v$，将初始位移 $u_0(x)$ 和速度 $v_0(x)$ 投影到有限元基上，其中右侧项通过 $b_i = \\int_0^L f(x)\\phi_i(x)dx$（$f=u_0, v_0$）计算。这确保了离散状态的一致初始化。\n3.  **时间积分**：一个循环为指定数量的时间步执行隐式中点格式。在每一步中，构建并求解关于 $\\mathbf{u}_{n+1}$ 的线性系统。然后更新速度 $\\mathbf{v}_{n+1}$。\n4.  **能量与功的计算**：计算初始能量 $E_d(0)$。在时间步进循环中，每一步都使用速度和力的中点值来更新累积的边界功 $W$。循环结束后，计算最终能量 $E_d(T)$。\n5.  **误差**：计算绝对误差 $\\varepsilon = |E_d(T) - E_d(0) - W|$。由于该格式具有能量相容的特性，该值预期会接近机器精度，从而证实了理论推导。\n\n该程序的结构是运行所提供的测试套件，并为每个案例输出所得的误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef run_simulation(L, c, Nel, dt, T, g_func, u0_func, v0_func):\n    \"\"\"\n    Performs one complete simulation for the 1D wave equation.\n\n    Args:\n        L (float): Length of the domain.\n        c (float): Wave speed.\n        Nel (int): Number of elements.\n        dt (float): Time step.\n        T (float): Final time.\n        g_func (callable): Neumann traction function g(t).\n        u0_func (callable): Initial displacement function u0(x).\n        v0_func (callable): Initial velocity function v0(x).\n\n    Returns:\n        float: The absolute energy discrepancy epsilon.\n    \"\"\"\n    # 1. Mesh and Matrix Assembly\n    N = Nel\n    h = L / float(Nel)\n    nodes = np.linspace(0, L, Nel + 1)\n\n    M = np.zeros((N, N))\n    K = np.zeros((N, N))\n\n    # Assemble tridiagonal M and K matrices for 1D linear elements\n    # Diagonal entries\n    for i in range(N - 1):\n        M[i, i] = 2.0 * h / 3.0\n        K[i, i] = 2.0 * c**2 / h\n    M[N - 1, N - 1] = h / 3.0\n    K[N - 1, N - 1] = c**2 / h\n\n    # Off-diagonal entries\n    for i in range(N - 1):\n        M[i, i + 1] = h / 6.0\n        M[i + 1, i] = h / 6.0\n        K[i, i + 1] = -c**2 / h\n        K[i + 1, i] = -c**2 / h\n    \n    # 2. Initial Conditions (L2 Projection)\n    u = np.zeros(N)\n    v = np.zeros(N)\n\n    # Check if u0 is a non-zero function\n    if np.any(u0_func(np.linspace(0, L, 20)) != 0):\n        b_u = np.zeros(N)\n        for i in range(N):\n            node_idx = i + 1\n            x_center = nodes[node_idx]\n            x_left = nodes[node_idx - 1]\n            \n            # Linear function for the \"up-slope\" part of the hat function\n            def up_slope(x): return (x - x_left) / h\n            integral1 = quad(lambda x: u0_func(x) * up_slope(x), x_left, x_center)[0]\n            \n            if node_idx  N:  # Full hat function\n                x_right = nodes[node_idx + 1]\n                # Linear function for the \"down-slope\"\n                def down_slope(x): return (x_right - x) / h\n                integral2 = quad(lambda x: u0_func(x) * down_slope(x), x_center, x_right)[0]\n                b_u[i] = integral1 + integral2\n            else:  # Half hat function at x=L\n                b_u[i] = integral1\n        u = np.linalg.solve(M, b_u)\n\n    # Check if v0 is a non-zero function\n    if np.any(v0_func(np.linspace(0, L, 20)) != 0):\n        b_v = np.zeros(N)\n        for i in range(N):\n            node_idx = i + 1\n            x_center = nodes[node_idx]\n            x_left = nodes[node_idx - 1]\n            \n            def up_slope(x): return (x - x_left) / h\n            integral1 = quad(lambda x: v0_func(x) * up_slope(x), x_left, x_center)[0]\n\n            if node_idx  N:  # Full hat function\n                x_right = nodes[node_idx + 1]\n                def down_slope(x): return (x_right - x) / h\n                integral2 = quad(lambda x: v0_func(x) * down_slope(x), x_center, x_right)[0]\n                b_v[i] = integral1 + integral2\n            else:  # Half hat function at x=L\n                b_v[i] = integral1\n        v = np.linalg.solve(M, b_v)\n\n    # 3. Energy and Work Calculation\n    def calculate_energy(u_vec, v_vec, M_mat, K_mat):\n        E_kin = 0.5 * v_vec.T @ M_mat @ v_vec\n        E_pot = 0.5 * u_vec.T @ K_mat @ u_vec\n        return E_kin + E_pot\n    \n    E0 = calculate_energy(u, v, M, K)\n    W = 0.0\n\n    # 4. Time Stepping with Implicit Midpoint Rule\n    num_steps = int(round(T / dt))\n    \n    # System matrix for the update equation (constant in time)\n    A_sys = M + (dt**2 / 4.0) * K\n    M_term = M - (dt**2 / 4.0) * K\n    dtM = dt * M\n\n    for n in range(num_steps):\n        t_mid = (n + 0.5) * dt\n        \n        # Neumann force vector\n        f_mid = np.zeros(N)\n        f_mid[-1] = g_func(t_mid)\n\n        # Form the RHS of the linear system\n        b = (dt**2 / 2.0) * f_mid + M_term @ u + dtM @ v\n        \n        # Solve for new displacement\n        u_new = np.linalg.solve(A_sys, b)\n        \n        # Update velocity\n        v_new = (2.0 / dt) * (u_new - u) - v\n        \n        # Midpoint velocity for work calculation\n        v_mid = 0.5 * (v + v_new)\n\n        # Update work\n        work_increment = dt * (v_mid.T @ f_mid)\n        W += work_increment\n        \n        # Update state for next step\n        u, v = u_new, v_new\n        \n    ET = calculate_energy(u, v, M, K)\n    \n    discrepancy = abs(ET - E0 - W)\n    return discrepancy\n\ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        # Test case 1 (L, c, Nel, dt, T, g(t), u0(x), v0(x))\n        (1.0, 1.0, 50, 1e-3, 0.5, \n         lambda t: 0.0, \n         lambda x: np.sin(np.pi * x), \n         lambda x: 0.0),\n        \n        # Test case 2\n        (1.0, 1.0, 50, 1e-3, 0.5, \n         lambda t: np.sin(6 * np.pi * t), \n         lambda x: 0.0, \n         lambda x: 0.0),\n        \n        # Test case 3\n        (1.0, 0.8, 60, 5e-4, 0.6, \n         lambda t: 0.5 * t, \n         lambda x: 0.0, \n         lambda x: np.sin(2 * np.pi * x)),\n    ]\n\n    results = []\n    for params in test_cases:\n        discrepancy = run_simulation(*params)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3384928"}, {"introduction": "许多物理现象，如接触或摩擦，是由非光滑的势能描述的。这个高级实践挑战你调整保能量框架来处理这类情况，在这些情况下，标准的梯度并非处处有定义 [@problem_id:3384885]。你将构建一个基于次梯度概念的积分器，确保即使系统状态通过势能的“扭折点”时也能精确保持能量守恒，从而展示这些几何方法的鲁棒性和普适性。", "problem": "考虑在空间区间 $[0,1]$ 上带有齐次狄利克雷边界条件的半线性一维偏微分方程（PDE）波动模型，\n$$u_{tt}(x,t) - c^2 u_{xx}(x,t) + \\partial V(u(x,t)) = 0,$$\n其中 $c0$ 是波速，$V(u)=\\lambda |u|$ 是一个非光滑势，且 $\\lambda0$。这里 $\\partial V$ 表示关于 $u$ 的次微分，它与绝对值的集值符号函数一致，即 $\\partial(\\lambda |u|)=\\lambda\\,\\mathrm{sign}(u)$，其中 $\\mathrm{sign}(0)$ 被理解为 $[-1,1]$ 中的任意值。\n\n使用具有 $N$ 个内部网格点和网格间距 $h_x=\\frac{1}{N+1}$ 的标准二阶中心有限差分空间半离散化，定义节点值向量 $q(t)\\in\\mathbb{R}^N$ 及其速度 $p(t)=\\dot{q}(t)\\in\\mathbb{R}^N$。该半离散动力学可以写成一个哈密顿系统\n$$\\dot{q}=p,\\quad \\dot{p}=-K q - g(q),$$\n其离散能量（哈密顿量）为\n$$H(q,p)=\\frac{1}{2}\\|p\\|^2 + \\frac{1}{2} q^\\top K q + \\lambda \\sum_{i=1}^N |q_i|,$$\n其中 $K\\in\\mathbb{R}^{N\\times N}$ 是对应于离散狄利克雷拉普拉斯算子的对称正定刚度矩阵，并按 $c^2$ 进行缩放，即 $K=\\frac{c^2}{h_x^2}\\,\\mathrm{tridiag}(-1,2,-1)$，$g(q)\\in\\partial(\\lambda \\sum_i |q_i|)$ 是逐分量选取的任意次梯度。该常微分方程系统在时间上精确保持能量 $H$。\n\n你的任务是：\n1. 从可分离哈密顿量 $H(q,p)=T(p)+W(q)$ 的离散能量守恒基本定义出发，构建一个在所有时间步长上都能精确保持离散能量 $H(q,p)$ 的时间积分器。该积分器需使用 $W(q)$ 的离散梯度，并将绝对值的非光滑次梯度包含在内。不要假设 $V$ 是光滑的，也不要使用预设在 $u=0$ 处可微的公式。该方法必须从第一性原理推导，并且必须明确说明如何处理在尖点 $q_i=0$ 处的次梯度。\n2. 为具有上述定义的矩阵 $K$ 的半离散系统实现该积分器。你的实现必须通过采用一致的次梯度选择来稳健地处理 $q_i=0$ 处的尖点，以确保离散能量守恒恒等式得到满足。\n3. 在每个时间步，使用一种不假设尖点处存在光滑导数的数值稳定方法，求解能量保持结构产生的任何隐式方程。使用一个能保证足够精度以评估能量保持性的停止准则。\n4. 沿数值轨迹计算能量 $H(q^n,p^n)$，并报告在整个模拟过程中与初始能量 $H(q^0,p^0)$ 的最大绝对偏差，定义为\n$$\\Delta H_{\\max}=\\max_{0\\le n\\le N_{\\mathrm{steps}}} \\left| H(q^n,p^n) - H(q^0,p^0) \\right|.$$\n\n测试套件：\n- 情况 A（一般情况，远离尖点）：$N=16$, $c=1.0$, $\\lambda=0.8$, 时间步长 $h=0.02$, 步数 $N_{\\mathrm{steps}}=200$, 初始条件 $q_i^0 = 0.5\\sin(\\pi x_i)$, $p^0=0$，其中 $x_i=i h_x$ for $i=1,\\dots,N$。\n- 情况 B（尖点附近的稳健性，符号频繁变化）：$N=16$, $c=1.0$, $\\lambda=2.0$, 时间步长 $h=0.015$, 步数 $N_{\\mathrm{steps}}=300$, 初始条件 $q_i^0 = 0.05\\sin(6\\pi x_i)$, $p^0=0$。\n- 情况 C（尖点附近的大时间步长压力测试）：$N=10$, $c=1.5$, $\\lambda=1.0$, 时间步长 $h=0.1$, 步数 $N_{\\mathrm{steps}}=120$, 初始条件 $q_i^0 = 0.2\\sin(2\\pi x_i)$, $p^0=0$。\n\n对于每种情况，判断积分器是否在容差 $\\varepsilon_{\\mathrm{energy}}=10^{-8}$ 内实现能量保持，即 $\\Delta H_{\\max} \\le \\varepsilon_{\\mathrm{energy}}$ 是否成立。整个程序的最终输出要求为单行文本，其中包含一个用方括号括起来的、由逗号分隔的三个布尔值列表，分别对应情况A、B和C。例如，输出格式必须严格如下：\n$$[\\mathrm{result}_A,\\mathrm{result}_B,\\mathrm{result}_C],$$\n其中每个 $\\mathrm{result}_\\bullet$ 是 $\\mathrm{True}$ 或 $\\mathrm{False}$。", "solution": "该问题要求构建并实现一个数值积分器，该积分器能精确保持带有非光滑势的半离散化半线性波动方程的离散能量。此问题是适定的且在科学上是合理的，代表了几何数值积分领域的一项标准任务。我们着手进行推导和实现。\n\n### 1. 保能积分器的推导\n\n半离散系统是一个可分离的哈密顿系统，其哈密顿量为 $H(q,p) = T(p) + W(q)$，其中 $T(p) = \\frac{1}{2}\\|p\\|^2$ 是动能，$W(q) = \\frac{1}{2} q^\\top K q + \\lambda \\sum_{i=1}^N |q_i|$ 是势能。运动方程为 $\\dot{q} = \\nabla_p H = p$ 和 $\\dot{p} = -\\nabla_q H = -Kq - g(q)$，其中 $g(q) \\in \\partial_q(\\lambda\\sum_i|q_i|)$ 是一个次梯度。\n\n一个积分器 $(q^n, p^n) \\mapsto (q^{n+1}, p^{n+1})$ 如果对所有步长 $n$ 都满足 $H(q^{n+1}, p^{n+1}) = H(q^n, p^n)$，则它是精确保能的。这可以通过离散梯度法实现。函数 $W(q)$ 的离散梯度 $\\overline{\\nabla} W(q^a, q^b)$ 是一个满足两个性质的向量值函数：\n1.  一致性：在 $W$ 可微的任意点，$\\overline{\\nabla} W(q, q) = \\nabla W(q)$。\n2.  能量关系：$W(q^b) - W(q^a) = (\\overline{\\nabla} W(q^a, q^b))^\\top (q^b - q^a)$。\n\n我们采用一种基于平均向量场法（一种特定的离散梯度积分器）的保能格式，对于可分离哈密顿量，其形式为：\n$$\n\\frac{q^{n+1} - q^n}{h} = \\overline{\\nabla} T(p^n, p^{n+1})\n$$\n$$\n\\frac{p^{n+1} - p^n}{h} = -\\overline{\\nabla} W(q^n, q^{n+1})\n$$\n其中 $h$ 是时间步长。\n\n对于动能 $T(p)=\\frac{1}{2}p^\\top p$，其梯度为 $\\nabla_p T(p) = p$。离散梯度的一个标准选择是中点评估：\n$$\n\\overline{\\nabla} T(p^n, p^{n+1}) = \\frac{p^n + p^{n+1}}{2}\n$$\n该格式的第一个方程变成了运动学关系中常见的梯形法则：\n$$\n\\frac{q^{n+1} - q^n}{h} = \\frac{p^n + p^{n+1}}{2} \\quad (*).\n$$\n\n对于势能 $W(q) = W_{smooth}(q) + W_{nonsmooth}(q)$，其中 $W_{smooth}(q) = \\frac{1}{2}q^\\top K q$ 且 $W_{nonsmooth}(q) = \\lambda \\sum_{i=1}^N |q_i|$，离散梯度是可加构造的：$\\overline{\\nabla} W = \\overline{\\nabla} W_{smooth} + \\overline{\\nabla} W_{nonsmooth}$。\n- 对于二次（光滑）部分，其梯度 $\\nabla W_{smooth}(q)=Kq$ 的中点评估给出了一个有效的离散梯度：\n$$\n\\overline{\\nabla} W_{smooth}(q^n, q^{n+1}) = K\\left(\\frac{q^n + q^{n+1}}{2}\\right)\n$$\n- 对于可分离的非光滑部分 $W_{nonsmooth}(q)$，我们逐分量定义离散梯度。对于每个分量 $w_i(q_i) = \\lambda |q_i|$，离散梯度性质 $w_i(q_i^{n+1}) - w_i(q_i^n) = [\\overline{\\nabla} W_{nonsmooth}]_i (q_i^{n+1}-q_i^n)$ 导出以下定义：\n$$\n[\\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1})]_i = \\lambda \\frac{|q_i^{n+1}| - |q_i^n|}{q_i^{n+1} - q_i^n}, \\quad \\text{当 } q_i^{n+1} \\neq q_i^n \\text{ 时}\n$$\n如果 $q_i^{n+1} = q_i^n$，则离散梯度必须从次微分 $\\partial w_i(q_i^n)$ 中选取。一个一致的选择是，当 $q_i^n \\neq 0$ 时为 $\\lambda\\,\\mathrm{sign}(q_i^n)$，当 $q_i^n = 0$ 时为 $0$。\n\n该格式的第二个方程是：\n$$\n\\frac{p^{n+1} - p^n}{h} = -K\\left(\\frac{q^n + q^{n+1}}{2}\\right) - \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1}) \\quad (**).\n$$\n\n为了证明能量守恒，我们将 $(*)$ 与 $(\\overline{\\nabla} W)^\\top h$ 的内积和 $(**)$ 与 $(p^n+p^{n+1})^\\top h/2$ 的内积相加：\n$W(q^{n+1})-W(q^n) = (\\overline{\\nabla} W)^\\top (q^{n+1}-q^n) = (\\overline{\\nabla} W)^\\top h \\frac{p^n+p^{n+1}}{2}$。\n$T(p^{n+1})-T(p^n) = \\frac{1}{2}(p^{n+1})^\\top p^{n+1} - \\frac{1}{2}(p^n)^\\top p^n = \\frac{1}{2}(p^{n+1}-p^n)^\\top(p^{n+1}+p^n) = -(\\overline{\\nabla} W)^\\top h \\frac{p^n+p^{n+1}}{2}$。\n将这两个等式相加得到 $\\Delta H = (W^{n+1}-W^n) + (T^{n+1}-T^n) = 0$。因此，该格式是精确保能的。\n\n### 2. 隐式求解器构建\n\n该格式是隐式的。我们推导一个关于 $q^{n+1}$ 的方程。从 $(*)$，我们得到 $p^{n+1} = \\frac{2}{h}(q^{n+1}-q^n) - p^n$。将此代入 $(**)$ 得到一个关于 $q^{n+1}$ 的非线性系统：\n$$\n\\frac{1}{h}\\left(\\frac{2}{h}(q^{n+1}-q^n) - p^n - p^n\\right) = -K\\left(\\frac{q^n + q^{n+1}}{2}\\right) - \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1})\n$$\n$$\n\\frac{2}{h^2}(q^{n+1}-q^n) - \\frac{2}{h}p^n = -K\\left(\\frac{q^n + q^{n+1}}{2}\\right) - \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1})\n$$\n乘以 $h^2/2$ 并重新整理各项以求解 $q^{n+1}$：\n$$\nq^{n+1} - q^n - h p^n = -\\frac{h^2}{4} K(q^n + q^{n+1}) - \\frac{h^2}{2} \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1})\n$$\n$$\n\\left(I + \\frac{h^2}{4} K\\right) q^{n+1} = q^n + h p^n - \\frac{h^2}{4} K q^n - \\frac{h^2}{2} \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1})\n$$\n这是一个关于 $z=q^{n+1}$ 的形如 $F(z)=0$ 的非线性向量方程。它必须在每个时间步求解。由于问题要求使用不假设光滑性的方法，我们采用不动点迭代法：\n$$\n\\left(I + \\frac{h^2}{4} K\\right) q^{n+1}_{(k+1)} = q^n + h p^n - \\frac{h^2}{4} K q^n - \\frac{h^2}{2} \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1}_{(k)}),\n$$\n其中 $q^{n+1}_{(k)}$ 是 $q^{n+1}$ 的第 $k$ 次迭代。我们以初始猜测 $q^{n+1}_{(0)} = q^n$ 开始。矩阵 $A = I + \\frac{h^2}{4} K$ 是对称、正定且三对角的。每次迭代步中的线性系统可以使用带状矩阵求解器高效求解。当连续迭代之间的差异低于一个严格的容差（例如 $10^{-14}$）时，迭代停止，从而确保能量守恒性质达到机器精度。\n\n### 3. 实现与数值稳定性\n\n实现时需要小心处理绝对值项的离散梯度，以避免在 $q_i^{n+1} \\approx q_i^n$ 时出现数值不稳定性。表达式 $\\lambda(|v|-|u|)/(v-u)$ 的计算方式如下：\n- 如果 $u$ 和 $v$ 符号相同（或其中一个为零），则为 $\\lambda\\,\\mathrm{sign}(u)$。\n- 如果它们符号不同，则为 $\\lambda(|v|-|u|)/(v-u)$。\n在数值上，如果 $|v-u|$ 小于某个机器精度容差，我们将其视为 $v=u$ 的情况并选择一个次梯度。我们的一致选择是：当 $u \\neq 0$ 时为 $\\lambda\\,\\mathrm{sign}(u)$，当 $u=0$ 时为 $0$。\n\n一旦不动点迭代收敛到解 $q^{n+1}$，新的动量 $p^{n+1}$ 就通过运动学更新计算得出：\n$$\np^{n+1} = \\frac{2}{h}(q^{n+1} - q^n) - p^n\n$$\n然后计算能量 $H(q^{n+1}, p^{n+1})$ 并跟踪其与初始能量 $H(q^0,p^0)$ 的偏差。所有时间步长的最大绝对偏差 $\\Delta H_{\\max}$ 将与指定的容差 $\\varepsilon_{\\mathrm{energy}}=10^{-8}$ 进行比较。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef discrete_gradient_nonsmooth(q_n, q_np1, lam, N):\n    \"\"\"\n    Computes the discrete gradient of the nonsmooth potential W_nonsmooth = lambda * sum(|q_i|).\n    \"\"\"\n    g = np.zeros(N)\n    # Use a small tolerance based on machine epsilon for robust floating point comparison.\n    machine_eps = np.finfo(float).eps * 10.0\n    \n    for i in range(N):\n        q_i_n = q_n[i]\n        q_i_np1 = q_np1[i]\n        diff = q_i_np1 - q_i_n\n        \n        if np.abs(diff)  machine_eps:\n            # Case q_i^{n+1} is numerically equal to q_i^n.\n            # Select a subgradient. A consistent choice is made here.\n            if np.abs(q_i_n)  machine_eps:\n                # Subgradient at q=0. The choice 0 is natural and symmetric.\n                g[i] = 0.0\n            else:\n                # Differentiable region, gradient is sign(q).\n                g[i] = lam * np.sign(q_i_n)\n        else:\n            # Standard discrete gradient formula for |q|.\n            g[i] = lam * (np.abs(q_i_np1) - np.abs(q_i_n)) / diff\n    return g\n\ndef hamiltonian(q, p, K, lam):\n    \"\"\"\n    Computes the total discrete energy (Hamiltonian) of the system.\n    \"\"\"\n    kinetic = 0.5 * np.dot(p, p)\n    potential_smooth = 0.5 * np.dot(q, K @ q)\n    potential_nonsmooth = lam * np.sum(np.abs(q))\n    return kinetic + potential_smooth + potential_nonsmooth\n\ndef run_simulation(N, c, lam, h, N_steps, q0_func):\n    \"\"\"\n    Runs a simulation for one test case and checks for energy preservation.\n    \"\"\"\n    # 1. System setup\n    hx = 1.0 / (N + 1)\n    x = np.array([i * hx for i in range(1, N + 1)])\n\n    # Stiffness matrix K = (c^2/h_x^2) * tridiag(-1, 2, -1)\n    diag_K = np.full(N, 2.0)\n    off_diag_K = np.full(N - 1, -1.0)\n    K = (c**2 / hx**2) * (np.diag(diag_K) + np.diag(off_diag_K, k=1) + np.diag(off_diag_K, k=-1))\n\n    # 2. Initial conditions\n    q = q0_func(x)\n    p = np.zeros(N)\n\n    # Initial energy and tracking variables\n    H0 = hamiltonian(q, p, K, lam)\n    max_energy_deviation = 0.0\n\n    # 3. Setup for the fixed-point solver\n    fixed_point_tol = 1e-14\n    max_fixed_point_iter = 100\n\n    # System matrix A = I + (h^2/4) * K for the implicit solve\n    A_diag = 1.0 + (h**2 / 4.0) * (c**2 / hx**2) * 2.0\n    A_off_diag = -(h**2 / 4.0) * (c**2 / hx**2)\n    \n    A_banded = np.zeros((3, N))\n    A_banded[0, 1:] = A_off_diag  # Super-diagonal\n    A_banded[1, :] = A_diag     # Main diagonal\n    A_banded[2, :-1] = A_off_diag # Sub-diagonal\n    \n    # 4. Time stepping loop\n    for _ in range(N_steps):\n        # --- Solve for q^{n+1} using fixed-point iteration ---\n        rhs_const = q + h * p - (h**2 / 4.0) * (K @ q)\n        q_next_iter = np.copy(q) \n\n        for k in range(max_fixed_point_iter):\n            q_prev_iter = np.copy(q_next_iter)\n            \n            g_nonsmooth = discrete_gradient_nonsmooth(q, q_prev_iter, lam, N)\n            rhs = rhs_const - (h**2 / 2.0) * g_nonsmooth\n            \n            # Solve the banded linear system A * q_next_iter = rhs\n            q_next_iter = solve_banded((1, 1), A_banded, rhs, check_finite=False)\n            \n            if np.linalg.norm(q_next_iter - q_prev_iter, ord=np.inf)  fixed_point_tol:\n                break\n        \n        q_next = q_next_iter\n        \n        # --- Update p^{n+1} ---\n        p_next = (2.0 / h) * (q_next - q) - p\n        \n        # Update state for the next step\n        q, p = q_next, p_next\n        \n        # --- Calculate and record energy deviation ---\n        H_n = hamiltonian(q, p, K, lam)\n        energy_dev = np.abs(H_n - H0)\n        if energy_dev > max_energy_deviation:\n            max_energy_deviation = energy_dev\n            \n    # 5. Final check\n    energy_preservation_tol = 1e-8\n    return max_energy_deviation = energy_preservation_tol\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A: General case, away from kinks\n        {'N': 16, 'c': 1.0, 'lam': 0.8, 'h': 0.02, 'N_steps': 200, 'q0_func': lambda x: 0.5 * np.sin(np.pi * x)},\n        # Case B: Robustness near kinks\n        {'N': 16, 'c': 1.0, 'lam': 2.0, 'h': 0.015, 'N_steps': 300, 'q0_func': lambda x: 0.05 * np.sin(6 * np.pi * x)},\n        # Case C: Large time step stress test\n        {'N': 10, 'c': 1.5, 'lam': 1.0, 'h': 0.1, 'N_steps': 120, 'q0_func': lambda x: 0.2 * np.sin(2 * np.pi * x)},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(\n            N=case['N'],\n            c=case['c'],\n            lam=case['lam'],\n            h=case['h'],\n            N_steps=case['N_steps'],\n            q0_func=case['q0_func']\n        )\n        results.append(result)\n\n    # Format the output as a list of capitalized boolean strings\n    formatted_results = ','.join(map(str, results))\n    print(f\"[{formatted_results}]\")\n\nsolve()\n\n```", "id": "3384885"}]}