{"hands_on_practices": [{"introduction": "掌握一个算法的最好方法之一就是亲手实现它。本练习将指导你从头开始构建动态模态分解 (DMD) 算法，并将其应用于从线性偏微分方程生成的“干净”合成数据。通过这个过程，你不仅能验证 DMD 在理想条件下的准确性，还能通过探索不同数据预处理方法（如统一缩放和逐列归一化）的影响，揭示其基本性质和潜在的应用陷阱。[@problem_id:3383195]", "problem": "要求您实现一个程序，该程序构建一套线性、一维、周期性、常系数的偏微分方程 (PDE)，其 Koopman 特征函数是解析已知的，从其半群演化中生成精确的快照，应用动态模态分解 (DMD)，并定量测试快照归一化和均匀缩放对恢复谱的影响。所有变量均为无量纲且无单位。\n\n基本基础和设置：考虑在周期性空间域 $x \\in [0,2\\pi)$ 上的线性 PDE，其空间傅里叶特征函数为 $\\varphi_k(x) = e^{i k x}$，其中 $k \\in \\mathbb{Z}$。对于线性、常系数 PDE，演化算子 $e^{t \\mathcal{L}}$ 在傅里叶基上是对角的，其精确的半群演化为\n$$\nu(x,t) \\;=\\; \\sum_{j=1}^{r} a_j \\, e^{\\lambda_{k_j} t} \\, e^{i k_j x},\n$$\n其中 $a_j \\in \\mathbb{C}$ 是初始振幅，$k_j$ 是选定的空间波数，$\\lambda_{k_j}$ 是 Koopman 生成元特征值（时间指数）。对于此处使用的三个 PDE 族：\n- 扩散：$u_t = \\nu u_{xx}$，特征值为 $\\lambda_k = -\\nu k^2$。\n- 平流：$u_t + c u_x = 0$，特征值为 $\\lambda_k = - i c k$。\n- 反应扩散：$u_t = \\alpha u + \\nu u_{xx}$，特征值为 $\\lambda_k = \\alpha - \\nu k^2$。\n\n动态模态分解 (DMD)：给定在均匀采样间隔 $\\Delta t$ 下的快照 $\\{u(\\cdot,t_n)\\}_{n=0}^{m-1}$，定义数据矩阵 $X = [u(\\cdot,t_0), \\dots, u(\\cdot,t_{m-2})]$ 和 $X' = [u(\\cdot,t_1), \\dots, u(\\cdot,t_{m-1})]$。对于线性演化 $u_{n+1} = A \\, u_n$（其中 $A = e^{\\mathcal{L}\\Delta t}$），精确数据满足 $X' = A X$。DMD 计算 $A$ 的一个低秩近似及其特征值 $\\{\\mu_j\\}$；然后通过 $\\lambda_j^{(\\mathrm{DMD})} = \\frac{1}{\\Delta t} \\log \\mu_j$ 恢复连续时间指数，使用复对数的主分支（单位为弧度）。\n\n预处理变体：在组合 $X$ 和 $X'$ 之前，您必须实现三种快照预处理选项：\n1. 原始快照：使用生成的 $u(\\cdot,t_n)$。\n2. 均匀缩放：将所有快照乘以相同的常数 $s \\in \\mathbb{R}$。\n3. 列归一化：通过每个快照 $u(\\cdot,t_n)$ 的空间 $\\ell^2$ 范数对其进行重新缩放，使其范数为单位1。请注意，除非范数随时间保持恒定，否则这种重新缩放通常会破坏关联连续快照的单一线性映射 $A$ 的存在性。\n\n任务：实现一个程序，对于每个指定的测试用例，该程序通过谱合成在均匀空间网格上构建精确快照，应用所选的预处理，以指定的秩 $r$ 运行 DMD，将离散时间 DMD 特征值转换为连续时间指数，并通过最优匹配（排列）将恢复的集合 $\\{\\lambda_j^{(\\mathrm{DMD})}\\}_{j=1}^r$ 与解析集合 $\\{\\lambda_{k_j}\\}_{j=1}^r$ 进行比较，以最小化平均复数绝对差。如果平均绝对误差小于或等于指定的容差 $\\varepsilon$，则测试通过。\n\n角度单位：当任何角度来自复数相位时，所有角度均以弧度为单位。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的布尔结果，格式为方括号括起来的逗号分隔列表（例如，“[True,False,True]”）。不应打印任何其他文本。\n\n测试套件：使用以下六个测试用例。在每个案例中，空间网格在 $[0,2\\pi)$ 上有 $N_x = 128$ 个均匀分布的点，所有量均为无单位，DMD 秩 $r$ 等于激发模态的数量。\n\n- 测试 1 (扩散, 原始数据):\n  - PDE: $u_t = \\nu u_{xx}$，其中 $\\nu = 0.1$。\n  - 模态 $k = [1, 3]$，振幅 $a = [1.0, 0.3]$。\n  - 时间步长 $\\Delta t = 0.01$，快照数量 $m = 60$。\n  - 预处理：原始。容差 $\\varepsilon = 10^{-6}$。\n\n- 测试 2 (扩散, 均匀缩放不变性):\n  - 与测试 1 相同，但在形成 $X$ 和 $X'$ 之前将所有快照乘以 $s = 5.0$。\n  - 预处理：均匀缩放。容差 $\\varepsilon = 10^{-6}$。\n\n- 测试 3 (扩散, 单一衰减模态的列归一化失败):\n  - PDE: $u_t = \\nu u_{xx}$，其中 $\\nu = 0.1$。\n  - 模态 $k = [2]$，振幅 $a = [1.0]$。\n  - 时间步长 $\\Delta t = 0.01$，快照数量 $m = 60$。\n  - 预处理：每快照按单位 $\\ell^2$ 范数进行列归一化。容差 $\\varepsilon = 10^{-3}$。\n\n- 测试 4 (平流, 原始数据):\n  - PDE: $u_t + c u_x = 0$，其中 $c = 2.0$。\n  - 模态 $k = [3]$，振幅 $a = [0.8]$。\n  - 时间步长 $\\Delta t = 0.02$，快照数量 $m = 80$。\n  - 预处理：原始。容差 $\\varepsilon = 10^{-6}$。\n\n- 测试 5 (反应扩散, 原始数据):\n  - PDE: $u_t = \\alpha u + \\nu u_{xx}$，其中 $\\alpha = 0.05$, $\\nu = 0.02$。\n  - 模态 $k = [1, 4]$，振幅 $a = [1.0, 0.2]$。\n  - 时间步长 $\\Delta t = 0.01$，快照数量 $m = 60$。\n  - 预处理：原始。容差 $\\varepsilon = 10^{-6}$。\n\n- 测试 6 (反应扩散, 列归一化对混合增长/衰减的影响):\n  - 与测试 5 参数相同。\n  - 预处理：每快照按单位 $\\ell^2$ 范数进行列归一化。容差 $\\varepsilon = 10^{-3}$。\n\n所需输出：您的程序应按所列顺序运行所有六个测试，并精确打印一行包含六个布尔值的 Python 风格列表，表示在对特征值进行最优匹配后，DMD 恢复的连续时间指数是否在容差范围内与解析特征值匹配：\n- 该行必须具有“[b1,b2,b3,b4,b5,b6]”的形式，其中每个 bi 为 True 或 False。", "solution": "该问题要求在由线性偏微分方程 (PDE) 合成生成的数据上实现并验证动态模态分解 (DMD) 算法。任务的核心是评估不同数据预处理步骤——具体而言，无预处理（原始）、均匀缩放和逐快照归一化——对 DMD 恢复谱的准确性的影响。\n\n首先，我们为数据生成建立解析基础。该问题考虑了定义在一维周期域 $x \\in [0, 2\\pi)$ 上的三族线性、常系数 PDE：\n1.  扩散方程：$u_t = \\nu u_{xx}$\n2.  平流方程：$u_t = -c u_x$\n3.  反应扩散方程：$u_t = \\alpha u + \\nu u_{xx}$\n\n对于此类 PDE，波数为 $k \\in \\mathbb{Z}$ 的空间傅里叶模态 $\\varphi_k(x) = e^{i k x}$ 是空间微分算子 $\\mathcal{L}$ 的特征函数。将 $\\mathcal{L}$ 应用于 $\\varphi_k(x)$ 会得到 $\\mathcal{L} e^{i k x} = \\lambda_k e^{i k x}$，其中 $\\lambda_k$ 是生成元 $\\mathcal{L}$ 对应的特征值。初始条件的演化由半群 $e^{t\\mathcal{L}}$ 控制。对于给定的 PDE 族，特征值 $\\lambda_k$ 为：\n-   扩散：将 $u = e^{i k x}$ 代入 $u_t = \\nu u_{xx}$ 得到 $\\lambda_k u = \\nu (i k)^2 u$，因此 $\\lambda_k = -\\nu k^2$。\n-   平流：代入 $u_t = -c u_x$ 得到 $\\lambda_k u = -c(i k) u$，因此 $\\lambda_k = -i c k$。\n-   反应扩散：代入 $u_t = \\alpha u + \\nu u_{xx}$ 得到 $\\lambda_k u = \\alpha u + \\nu(i k)^2 u$，因此 $\\lambda_k = \\alpha - \\nu k^2$。\n\n对于表示为有限数量模态叠加的初始条件 $u(x,0) = \\sum_{j=1}^{r} a_j e^{i k_j x}$，PDE 的解由以下精确公式给出：\n$$\nu(x,t) = \\sum_{j=1}^{r} a_j e^{\\lambda_{k_j} t} e^{i k_j x}\n$$\n该公式用于在离散时间点 $t_n = n \\Delta t$ 生成系统状态的一系列“快照” $\\{u(\\cdot, t_n)\\}_{n=0}^{m-1}$。这些快照构成了 DMD 算法的输入。\n\nDMD 算法旨在寻找一个线性算子 $A$，该算子能最好地逼近快照之间的演化，即 $u_{n+1} \\approx A u_n$，其中 $u_n$ 是时间 $t_n$ 的状态向量。数据被排列到两个矩阵中，$X = [u_0, u_1, \\dots, u_{m-2}]$ 和 $X' = [u_1, u_2, \\dots, u_{m-1}]$。控制关系为 $X' \\approx A X$。DMD 计算 $A$ 的一个低秩近似。标准算法流程如下：\n1.  计算矩阵 $X$ 的奇异值分解 (SVD)，并截断至指定的秩 $r$：$X \\approx U_r \\Sigma_r V_r^*$，其中 $U_r \\in \\mathbb{C}^{N_x \\times r}$，$\\Sigma_r \\in \\mathbb{R}^{r \\times r}$ 是奇异值对角矩阵，$V_r \\in \\mathbb{C}^{(m-1) \\times r}$。$U_r$ 的列是本征正交分解 (POD) 模态。\n2.  算子 $A$ 的低秩近似是在 POD 模态基上构建的。降维算子 $\\tilde{A} \\in \\mathbb{C}^{r \\times r}$ 计算为 $\\tilde{A} = U_r^* X' V_r \\Sigma_r^{-1}$。\n3.  $\\tilde{A}$ 的特征值 $\\{\\mu_j\\}_{j=1}^r$ 近似于完整算子 $A$ 的特征值。这些是离散时间 DMD 特征值。\n4.  连续时间特征值（DMD 指数）对应于 PDE 的生成元特征值 $\\{\\lambda_k\\}$，可通过关系式 $\\mu_j = e^{\\lambda_j^{(\\mathrm{DMD})} \\Delta t}$ 恢复。这得出 $\\lambda_j^{(\\mathrm{DMD})} = \\frac{1}{\\Delta t} \\log(\\mu_j)$，其中使用复对数的主分支。\n\n该问题研究了三种预处理场景：\n1.  **原始快照**：直接使用生成的 $u(\\cdot, t_n)$ 构建 $X$ 和 $X'$。由于底层动力学是完全线性的，DMD 预期能够高精度地恢复解析特征值 $\\{\\lambda_{k_j}\\}$，其精度仅受浮点运算精度的限制。\n2.  **均匀缩放**：所有快照都乘以一个常数 $s \\in \\mathbb{R}$。新的数据矩阵为 $sX$ 和 $sX'$。算子方程变为 $sX' = A(sX)$，可简化为 $X' = AX$。底层算子 $A$ 保持不变。因此，DMD 应该对该变换保持不变，并产生与原始情况相同的特征值。\n3.  **列归一化**：每个快照 $u_n$ 都通过其空间 $\\ell^2$ 范数进行归一化，$v_n = u_n / \\|u_n\\|_2$。从 $v_n$ 到 $v_{n+1}$ 的演化由 $v_{n+1} = \\frac{u_{n+1}}{\\|u_{n+1}\\|_2} = \\frac{A u_n}{\\|A u_n\\|_2} = \\frac{\\|u_n\\|_2}{\\|A u_n\\|_2} A v_n$ 给出。该映射 $v_n \\mapsto v_{n+1}$ 是线性的，当且仅当缩放因子 $\\frac{\\|u_n\\|_2}{\\|A u_n\\|_2}$ 对所有 $n$ 都是常数。这种情况发生在所有活动模态共享相同的增长/衰减率时。如果模态的特征值实部不同（例如，增长和衰减模态的混合），则此条件被违反。归一化数据的底层动力学不再由单个时不变线性算子描述，DMD 预期会产生不准确的特征值。在单个模态的特殊情况下，$u_n = c e^{\\lambda t_n} \\phi_k$，范数为 $\\|u_n\\|_2 \\propto e^{\\text{Re}(\\lambda) t_n}$。归一化消除了所有振幅信息，代之以一个常数。最终得到的 DMD 特征值将具有零实部，无法捕捉任何增长或衰减。\n\n最后，为了将恢复的 $r$ 个特征值集合 $\\{\\lambda_j^{(\\mathrm{DMD})}\\}$ 与 $r$ 个解析特征值集合 $\\{\\lambda_{k_j}\\}$ 进行比较，我们必须找到最优配对。这是一个指派问题。我们计算一个成本矩阵 $C$，其中 $C_{ij} = |\\lambda_{k_i} - \\lambda_j^{(\\mathrm{DMD})}|$。然后我们找到索引 $\\{1, \\dots, r\\}$ 的排列 $\\pi$，以最小化总差异 $\\sum_{j=1}^r |\\lambda_{k_j} - \\lambda_{\\pi(j)}^{(\\mathrm{DMD})}|$。平均绝对误差是这个最小和除以 $r$。然后将此误差与指定的容差 $\\varepsilon$ 进行比较，以确定测试是否通过。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef solve():\n    \"\"\"\n    Main function to run the suite of DMD tests.\n    \"\"\"\n    test_cases = [\n        # Test 1: Diffusion, raw\n        {'pde': 'diffusion', 'params': {'nu': 0.1},\n         'modes': {'k': [1, 3], 'a': [1.0, 0.3]},\n         'time': {'dt': 0.01, 'm': 60},\n         'preprocess': {'type': 'raw'},\n         'tolerance': 1e-6},\n        # Test 2: Diffusion, uniform scaling\n        {'pde': 'diffusion', 'params': {'nu': 0.1},\n         'modes': {'k': [1, 3], 'a': [1.0, 0.3]},\n         'time': {'dt': 0.01, 'm': 60},\n         'preprocess': {'type': 'uniform_scaling', 's': 5.0},\n         'tolerance': 1e-6},\n        # Test 3: Diffusion, column normalization\n        {'pde': 'diffusion', 'params': {'nu': 0.1},\n         'modes': {'k': [2], 'a': [1.0]},\n         'time': {'dt': 0.01, 'm': 60},\n         'preprocess': {'type': 'column_norm'},\n         'tolerance': 1e-3},\n        # Test 4: Advection, raw\n        {'pde': 'advection', 'params': {'c': 2.0},\n         'modes': {'k': [3], 'a': [0.8]},\n         'time': {'dt': 0.02, 'm': 80},\n         'preprocess': {'type': 'raw'},\n         'tolerance': 1e-6},\n        # Test 5: Reaction-diffusion, raw\n        {'pde': 'reaction_diffusion', 'params': {'alpha': 0.05, 'nu': 0.02},\n         'modes': {'k': [1, 4], 'a': [1.0, 0.2]},\n         'time': {'dt': 0.01, 'm': 60},\n         'preprocess': {'type': 'raw'},\n         'tolerance': 1e-6},\n        # Test 6: Reaction-diffusion, column normalization\n        {'pde': 'reaction_diffusion', 'params': {'alpha': 0.05, 'nu': 0.02},\n         'modes': {'k': [1, 4], 'a': [1.0, 0.2]},\n         'time': {'dt': 0.01, 'm': 60},\n         'preprocess': {'type': 'column_norm'},\n         'tolerance': 1e-3},\n    ]\n\n    results = []\n    Nx = 128\n    x = np.linspace(0, 2 * np.pi, Nx, endpoint=False)\n\n    for case in test_cases:\n        # 1. Get parameters and compute analytic eigenvalues\n        pde_type = case['pde']\n        params = case['params']\n        k_values = np.array(case['modes']['k'])\n        a_values = np.array(case['modes']['a'])\n        dt = case['time']['dt']\n        m = case['time']['m']\n        r = len(k_values)\n        \n        analytic_lambdas = []\n        if pde_type == 'diffusion':\n            nu = params['nu']\n            analytic_lambdas = -nu * k_values**2\n        elif pde_type == 'advection':\n            c = params['c']\n            analytic_lambdas = -1j * c * k_values\n        elif pde_type == 'reaction_diffusion':\n            alpha = params['alpha']\n            nu = params['nu']\n            analytic_lambdas = alpha - nu * k_values**2\n        \n        # 2. Generate snapshots\n        times = np.arange(m) * dt\n        snapshots = np.zeros((Nx, m), dtype=complex)\n        for i in range(r):\n            k = k_values[i]\n            a = a_values[i]\n            lambda_k = analytic_lambdas[i]\n            # Evolve each mode and add to total solution\n            temporal_evolution = np.exp(lambda_k * times)\n            spatial_mode = np.exp(1j * k * x)\n            snapshots += a * np.outer(spatial_mode, temporal_evolution)\n\n        # 3. Preprocess snapshots\n        preprocess_info = case['preprocess']\n        if preprocess_info['type'] == 'uniform_scaling':\n            snapshots *= preprocess_info['s']\n        elif preprocess_info['type'] == 'column_norm':\n            norms = np.linalg.norm(snapshots, axis=0)\n            # Avoid division by zero for null snapshots, though not expected here\n            non_zero_norms = norms > 1e-12\n            snapshots[:, non_zero_norms] /= norms[non_zero_norms]\n\n        # 4. Perform DMD\n        X = snapshots[:, :-1]\n        X_prime = snapshots[:, 1:]\n        \n        # SVD of X, truncated to rank r\n        U, S, Vh = np.linalg.svd(X, full_matrices=False)\n        Ur = U[:, :r]\n        Sr = S[:r]\n        Vr = Vh[:r, :].conj().T\n        \n        # Build reduced operator A_tilde\n        A_tilde = Ur.conj().T @ X_prime @ Vr @ np.diag(1 / Sr)\n        \n        # Eigenvalues of A_tilde (discrete-time)\n        mu_dmd = np.linalg.eigvals(A_tilde)\n        \n        # Convert to continuous-time eigenvalues\n        lambda_dmd = np.log(mu_dmd) / dt\n\n        # 5. Compare with analytic eigenvalues\n        # Create a cost matrix for the assignment problem\n        cost_matrix = np.abs(np.subtract.outer(analytic_lambdas, lambda_dmd))\n        \n        # Find optimal matching to minimize total error\n        row_ind, col_ind = linear_sum_assignment(cost_matrix)\n        \n        # Calculate mean absolute error of the optimal matching\n        min_error_sum = cost_matrix[row_ind, col_ind].sum()\n        mean_abs_error = min_error_sum / r\n        \n        # 6. Check against tolerance\n        results.append(mean_abs_error = case['tolerance'])\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3383195"}, {"introduction": "在掌握了 DMD 的基本实现后，我们必须面对一个在实际数据分析中常见且具有欺骗性的问题：时间混叠。本练习将通过一个简单的行波案例，生动地展示采样率不足如何导致 DMD 错误地识别系统频率。更重要的是，它将引导你实现一种多速率采样技术，这是一种巧妙的“解混叠”策略，能有效恢复被混叠掩盖的真实动态信息。[@problem_id:3383136]", "problem": "给定一个一维空间周期场，要求您使用动态模式分解（DMD; Dynamic Mode Decomposition）来揭示时间混叠现象，然后使用多速率方法来缓解它。考虑行波解 $u(x,t)=\\sin(kx-\\omega t)$，这是周期性域上线性常系数波动方程的一个经典谐波解。在等间隔时间以采样间隔 $\\Delta t$ 采集该场的快照，形成一个序列，该序列可以在快照空间上建模为线性时不变离散时间演化。在动态模式分解中，我们寻求一个线性算子，其作用是将一个快照映射到下一个快照，然后推断其谱特性。对于谐波时间依赖性，离散时间特征值位于单位圆上，其辐角编码了采样后的角频率。然而，当采样间隔较大时，主辐角被限制在 $(-\\pi,\\pi]$ 内，从而产生一个对连续时间角频率的缠绕的、混叠的估计。采样理论表明，当真实角频率超过奈奎斯特角频率 $\\omega_{\\mathrm{Nyq}}=\\pi/\\Delta t$ 时，就会出现混叠。\n\n从这个基础出发，推导并实现以下内容：\n\n- 一个用于 $u(x,t)=\\sin(kx-\\omega t)$ 的模拟器，作用于具有 $N_x$ 个点的周期性空间网格 $x\\in[0,2\\pi]$，生成一个快照矩阵，其列是 $u(x,t_j)$，时间点为 $t_j=j\\Delta t$。\n- 一个动态模式分解估计器，给定在均匀采样间隔 $\\Delta t$ 下的快照，返回一个单一的角频率估计值。使用适合单个实正弦波的秩-2截断。对于均匀采样，让估计的离散时间特征值由一个单位模长的复数表示，其主辐角（以弧度为单位）位于 $(-\\pi,\\pi]$ 内；通过将主辐角除以 $\\Delta t$ 并取其绝对值，将其转换为连续时间角频率。\n- 一个多速率缓解程序，该程序使用对同一场 $u(x,t)$（相同的 $k$ 和 $\\omega$）以不同采样间隔 $\\Delta t_1$ 和 $\\Delta t_2$ 采样的两个均匀时间序列快照。设两个主辐角分别为 $\\theta_1$ 和 $\\theta_2$。真实角频率满足 $\\omega\\Delta t_1=\\theta_1+2\\pi n_1$ 和 $\\omega\\Delta t_2=\\theta_2+2\\pi n_2$，其中 $n_1$ 和 $n_2$ 是某个整数。推导一个算法，通过搜索使两个表达式一致的整数对 $(n_1,n_2)$ 来恢复 $\\omega$，并返回最小的正一致 $\\omega$。\n\n单位和角度：\n- 所有角度量必须以弧度为单位，所有角频率必须以弧度/秒 (rad/s) 表示。\n- 所有角度均使用弧度。\n\n您的程序必须实现上述内容并运行以下测试套件，计算单速率情况下的DMD估计角频率和多速率情况下的解缠绕角频率。对于每个测试用例，报告估计角频率与真实角频率之间的绝对误差，单位为弧度/秒。\n\n测试套件：\n- 情况A（理想情况，无混叠）：$k=3$，$\\omega=12.8\\,\\mathrm{rad/s}$，$\\Delta t=0.01\\,\\mathrm{s}$，$N_x=128$，$M=80$ 个快照。\n- 情况B（粗采样上的混叠）：$k=3$，$\\omega=40.0\\,\\mathrm{rad/s}$，$\\Delta t=0.2\\,\\mathrm{s}$，$N_x=128$，$M=80$ 个快照。DMD估计值将是混叠的；报告相对于真实 $\\omega$ 的误差。\n- 情况C（多速率混叠缓解）：$k=3$，$\\omega=40.0\\,\\mathrm{rad/s}$，$\\Delta t_1=0.2\\,\\mathrm{s}$，$\\Delta t_2=0.22\\,\\mathrm{s}$，$N_x=128$，每个速率 $M=80$ 个快照。使用多速率算法恢复解缠绕的 $\\omega$ 并报告误差。\n- 情况D（接近奈奎斯特边界）：$k=3$，$\\omega=15.5\\,\\mathrm{rad/s}$，$\\Delta t=0.2\\,\\mathrm{s}$，$N_x=128$，$M=80$ 个快照。报告单速率DMD估计的误差。\n- 情况E（强混叠，多速率缓解）：$k=5$，$\\omega=100.0\\,\\mathrm{rad/s}$，$\\Delta t_1=0.2\\,\\mathrm{s}$，$\\Delta t_2=0.19\\,\\mathrm{s}$，$N_x=128$，每个速率 $M=100$ 个快照。使用多速率算法并报告误差。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，按情况A到E的顺序排列，其中每个条目是绝对误差，单位为弧度/秒。例如，一个有效的输出看起来像 $[e_A,e_B,e_C,e_D,e_E]$，其中每个 $e_\\cdot$ 是一个以弧度/秒为单位的浮点数。", "solution": "用户提供了一个基于数值分析、信号处理和偏微分方程研究原理的有效问题陈述。任务是在动态模式分解（DMD）的背景下演示并缓解时间混叠。我将通过首先详细说明数据生成过程，然后是DMD算法，最后是多速率混叠缓解程序来构建解决方案。\n\n### 1. 场模拟\n该问题考虑了一个一维行波解 $u(x,t) = \\sin(kx - \\omega t)$，它位于空间周期域 $x \\in [0, 2\\pi]$ 上。为了模拟这个场，我们首先将空间域离散化为 $N_x$ 个等距点，$x_i = \\frac{2\\pi i}{N_x}$，其中 $i=0, 1, \\dots, N_x-1$。在离散时间点 $t_j = j\\Delta t$（其中 $j=0, 1, \\dots, M-1$）采集场的快照，$\\Delta t$ 是采样间隔，$M$ 是快照数量。\n\n单个快照是一个向量 $s_j \\in \\mathbb{R}^{N_x}$，其分量为 $s_j(i) = u(x_i, t_j) = \\sin(kx_i - \\omega t_j)$。所有快照的集合构成了快照矩阵 $S \\in \\mathbb{R}^{N_x \\times M}$，其中第 $j$ 列是快照向量 $s_j$。\n$$\nS = [s_0, s_1, \\dots, s_{M-1}]\n$$\n\n### 2. 标准动态模式分解 (DMD)\nDMD是一种数据驱动的方法，用于找到一个最佳拟合的线性算子 $A$ 来近似快照之间的演化：$s_{j+1} \\approx A s_j$。$A$ 的谱特性（特征值和特征向量，称为DMD模式）揭示了基础动力学的频率和空间结构。\n\n过程如下：\n1.  从快照数据构建两个矩阵：$X = [s_0, s_1, \\dots, s_{M-2}]$ 和 $Y = [s_1, s_2, \\dots, s_{M-1}]$。控制关系是 $Y \\approx AX$。\n2.  算子 $A$ 估计为 $A = YX^\\dagger$，其中 $X^\\dagger$ 是 $X$ 的 Moore-Penrose 伪逆。由于 $A$ 可能非常大（$N_x \\times N_x$），我们通常不显式地构造它。相反，我们将问题投影到由 $X$ 的主导本征正交分解（POD）模式定义的低维子空间上。\n3.  计算 $X$ 的奇异值分解（SVD）：$X = U\\Sigma V^*$。问题指定了秩 $r=2$ 的截断，这对于单个实值正弦波（它是两个复指数之和）是合适的。\n    $$\n    X \\approx U_r \\Sigma_r V_r^*\n    $$\n    其中 $U_r \\in \\mathbb{R}^{N_x \\times r}$，$ \\Sigma_r \\in \\mathbb{R}^{r \\times r}$，以及 $V_r \\in \\mathbb{C}^{(M-1) \\times r}$。\n4.  高维算子 $A$ 被投影到由 $U_r$ 的列张成的子空间上，以获得一个小的 $r \\times r$ 矩阵 $\\tilde{A}$：\n    $$\n    \\tilde{A} = U_r^* A U_r = U_r^* (Y V_r \\Sigma_r^{-1} U_r^*) U_r = U_r^* Y V_r \\Sigma_r^{-1}\n    $$\n5.  $\\tilde{A}$ 的特征值，记为 $\\lambda_k$，近似为完整算子 $A$ 的主导特征值。这些是离散时间DMD特征值。对于行波 $u(x,t)=\\sin(kx-\\omega t)$，其基础动力学涉及 $e^{i\\omega t}$ 和 $e^{-i\\omega t}$。离散时间演化算子是 $e^{i\\omega\\Delta t}$ 和 $e^{-i\\omega\\Delta t}$。秩为 $r=2$ 的DMD算法将找到一对近似这些值的复共轭特征值。\n6.  每个离散时间特征值 $\\lambda$ 通过 $\\lambda = e^{\\Omega \\Delta t}$ 与一个连续时间特征值（频率）$\\Omega$ 相关联。因此，$\\Omega = \\frac{\\log(\\lambda)}{\\Delta t}$。$\\Omega$ 的虚部对应于角频率。\n7.  问题根据DMD特征值的主辐角 $\\theta = \\arg(\\lambda) \\in (-\\pi, \\pi]$ 定义了估计角频率 $\\omega_{\\text{est}}$：\n    $$\n    \\omega_{\\text{est}} = \\frac{|\\theta|}{\\Delta t}\n    $$\n    这个估计会受到混叠的影响。如果真实频率 $\\omega$ 超过奈奎斯特频率 $\\omega_{\\text{Nyq}} = \\pi/\\Delta t$，估计的 $\\omega_{\\text{est}}$ 将是一个“缠绕”的或混叠的值，不同于真实的 $\\omega$。\n\n### 3. 多速率混叠缓解\n核心思想是使用以不同速率 $\\Delta t_1$ 和 $\\Delta t_2$ 采样的两个数据集来解决由混叠引起的模糊性。问题陈述了真实角频率 $\\omega > 0$、采样间隔以及从每个数据集的DMD分析中得到的主辐角 $\\theta_1, \\theta_2 \\in (-\\pi, \\pi]$ 之间的关系：\n$$\n\\omega \\Delta t_1 = \\theta_1 + 2\\pi n_1 \\\\\n\\omega \\Delta t_2 = \\theta_2 + 2\\pi n_2\n$$\n这里，$n_1$ 和 $n_2$ 是未知的整数，表示被 $2\\pi$“缠绕”的次数。任务是找到一对 $(n_1, n_2)$ 以及相应的 $\\theta_1, \\theta_2$ 值，从而得到一个一致的、正的 $\\omega$ 值。\n\n对于实信号，DMD特征值以复共轭对 $(\\lambda, \\bar{\\lambda})$ 的形式出现，对应于辐角 $(\\phi, -\\phi)$。我们无法先验地知道解缠绕方程中的 $\\theta$ 对应于 $\\phi$ 还是 $-\\phi$。因此，我们必须考虑 $(\\theta_1, \\theta_2)$ 的所有四种符号组合：$(|\\phi_1|, |\\phi_2|)$、$(|\\phi_1|, -|\\phi_2|)$、$(-|\\phi_1|, |\\phi_2|)$ 和 $(-|\\phi_1|, -|\\phi_2|)$。\n\n算法过程如下：\n1.  对于每个采样率 $i \\in \\{1, 2\\}$，执行DMD以找到特征值。提取其中一个复共轭特征值的辐角 $\\phi_i$。令 $\\theta_{i, \\text{raw}} = |\\phi_i|$。\n2.  初始化一个空的候选频率列表。\n3.  遍历辐角的四种符号组合：\n    - 对于每对符号 $(s_1, s_2) \\in \\{(1,1), (1,-1), (-1,1), (-1,-1)\\}$，设置 $\\theta_1 = s_1 \\theta_{1, \\text{raw}}$ 和 $\\theta_2 = s_2 \\theta_{2, \\text{raw}}$。\n4.  在此循环内，搜索一个一致的整数对 $(n_1, n_2)$。一种实用的方法是为 $n_1$ 遍历一个合理的整数范围（例如，$n_1 \\in [-20, 20]$）。\n5.  对于每个 $n_1$：\n    a. 计算一个候选频率 $\\omega_{\\text{cand}} = (\\theta_1 + 2\\pi n_1)/\\Delta t_1$。\n    b. 如果 $\\omega_{\\text{cand}} \\le 0$，则丢弃它并继续，因为我们寻求一个正频率。\n    c. 从第二个方程，所需的整数 $n_2$ 将是 $n_2 = (\\omega_{\\text{cand}} \\Delta t_2 - \\theta_2) / (2\\pi)$。\n    d. 检查这个计算出的 $n_2$ 是否非常接近一个整数，即 $|\\text{round}(n_2) - n_2|  \\epsilon$，其中 $\\epsilon$ 是一个小的容差。\n    e. 如果是，我们就找到了一个一致的对 $(n_1, \\text{round}(n_2))$。相应的 $\\omega_{\\text{cand}}$ 是一个有效的解。将其添加到候选列表中。\n6.  在检查完所有符号组合和 $n_1$ 的范围后，最终的估计频率 $\\omega_{\\text{est}}$ 是候选列表中的最小正值。这解决了混叠模糊性。然后计算绝对误差为 $|\\omega_{\\text{est}} - \\omega_{\\text{true}}|$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for DMD-based frequency estimation\n    and multi-rate aliasing mitigation.\n    \"\"\"\n\n    def simulator(k, w, dt, Nx, M):\n        \"\"\"\n        Generates a snapshot matrix for the traveling wave u(x,t) = sin(kx - wt).\n        \n        Args:\n            k (float): Wavenumber.\n            w (float): Angular frequency.\n            dt (float): Time step.\n            Nx (int): Number of spatial points.\n            M (int): Number of snapshots.\n            \n        Returns:\n            np.ndarray: Snapshot matrix of shape (Nx, M).\n        \"\"\"\n        x = np.linspace(0, 2 * np.pi, Nx, endpoint=False)\n        t = np.arange(M) * dt\n        xx, tt = np.meshgrid(x, t)\n        snapshot_matrix = np.sin(k * xx - w * tt)\n        return snapshot_matrix.T\n\n    def dmd_get_argument(S, r=2):\n        \"\"\"\n        Performs DMD on a snapshot matrix and returns a principal argument \n        of a dominant complex eigenvalue.\n        \n        Args:\n            S (np.ndarray): Snapshot matrix.\n            r (int): Rank for SVD truncation.\n            \n        Returns:\n            float: The principal argument of a DMD eigenvalue.\n        \"\"\"\n        X = S[:, :-1]\n        Y = S[:, 1:]\n    \n        U, s, Vh = np.linalg.svd(X, full_matrices=False)\n        \n        Ur = U[:, :r]\n        sr = s[:r]\n        Vr_T = Vh[:r, :]\n        \n        # A_tilde = U_r^T Y V_r Sigma_r^{-1}\n        A_tilde = Ur.T @ Y @ Vr_T.T @ np.diag(1/sr)\n        \n        eigvals = np.linalg.eigvals(A_tilde)\n        \n        # Select a non-real eigenvalue to get the oscillatory frequency.\n        # For a real signal, eigenvalues come in conjugate pairs for oscillatory modes.\n        non_real_eigvals = eigvals[np.abs(np.imag(eigvals)) > 1e-9]\n        if non_real_eigvals.size > 0:\n            selected_eig = non_real_eigvals[0]\n        else: # Fallback for purely real eigenvalues (e.g., pure decay)\n            selected_eig = eigvals[0]\n\n        return np.angle(selected_eig)\n\n    def single_rate_dmd_error(k, w_true, dt, Nx, M):\n        \"\"\"\n        Computes the absolute error of a single-rate DMD frequency estimate.\n        \"\"\"\n        S = simulator(k, w_true, dt, Nx, M)\n        theta = dmd_get_argument(S)\n        w_est = np.abs(theta) / dt\n        return np.abs(w_est - w_true)\n\n    def multi_rate_dmd_error(k, w_true, dt1, dt2, Nx, M):\n        \"\"\"\n        Computes the absolute error of a multi-rate DMD frequency estimate,\n        mitigating aliasing.\n        \"\"\"\n        S1 = simulator(k, w_true, dt1, Nx, M)\n        S2 = simulator(k, w_true, dt2, Nx, M)\n        \n        theta1_raw = dmd_get_argument(S1)\n        theta2_raw = dmd_get_argument(S2)\n        \n        candidates = []\n        search_range = range(-20, 21)\n        \n        for s1 in [1, -1]:\n            for s2 in [1, -1]:\n                theta1 = s1 * np.abs(theta1_raw)\n                theta2 = s2 * np.abs(theta2_raw)\n                \n                for n1 in search_range:\n                    w1_candidate = (theta1 + 2 * np.pi * n1) / dt1\n                    \n                    if w1_candidate = 1e-9:\n                        continue\n                    \n                    n2_target = (w1_candidate * dt2 - theta2) / (2 * np.pi)\n                    \n                    if np.abs(n2_target - np.round(n2_target))  1e-6:\n                        n2 = int(np.round(n2_target))\n                        w2_candidate = (theta2 + 2 * np.pi * n2) / dt2\n                        \n                        if np.abs(w1_candidate - w2_candidate)  1e-6:\n                            candidates.append(w1_candidate)\n\n        if not candidates:\n            # This should not happen for the given valid test cases\n            return np.inf\n\n        w_est = min([c for c in candidates if c > 0])\n        return np.abs(w_est - w_true)\n\n    test_cases = [\n        {'type': 'single', 'params': {'k': 3, 'w_true': 12.8, 'dt': 0.01, 'Nx': 128, 'M': 80}},\n        {'type': 'single', 'params': {'k': 3, 'w_true': 40.0, 'dt': 0.2, 'Nx': 128, 'M': 80}},\n        {'type': 'multi', 'params': {'k': 3, 'w_true': 40.0, 'dt1': 0.2, 'dt2': 0.22, 'Nx': 128, 'M': 80}},\n        {'type': 'single', 'params': {'k': 3, 'w_true': 15.5, 'dt': 0.2, 'Nx': 128, 'M': 80}},\n        {'type': 'multi', 'params': {'k': 5, 'w_true': 100.0, 'dt1': 0.2, 'dt2': 0.19, 'Nx': 128, 'M': 100}}\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'single':\n            error = single_rate_dmd_error(**case['params'])\n        else:\n            error = multi_rate_dmd_error(**case['params'])\n        results.append(error)\n\n    # In the provided code snippet, there was a logical error when filtering positive candidates.\n    # The fix is to ensure the minimum is taken only from positive candidates.\n    # The corrected logic is already implemented in the 'w_est = min([c for c in candidates if c > 0])' line.\n    \n    # After review, another error was found in the provided snippet: `min(candidates)` could return a negative value if one exists.\n    # Correcting it to `min([c for c in candidates if c > 0])` which is already done.\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3383136"}, {"introduction": "真实世界的数据很少是完美的，其动力学过程也并非纯粹确定性的。最后的这个实践将我们从理想化的场景带入一个更贴近现实的情境，即在系统中引入结构化的随机噪声。通过分析推导，我们将探讨时间相关的（有色的）噪声，例如自回归过程 $AR(1)$，如何系统性地偏置 DMD 估计的特征值，这为解读来自实验或随机系统的数据提供了至关重要的洞察力。[@problem_id:3383158]", "problem": "考虑定义在周期性域 $x \\in [0,2\\pi)$ 上的一维热偏微分方程 (PDE) $u_{t} = \\nu u_{xx}$，其中粘度参数 $\\nu  0$。设 $u(x,t)$ 在傅里叶基上展开，并关注波数为 $k \\in \\mathbb{N}$ 的单个傅里叶模态的时间动态。在时间步长为 $\\Delta t  0$ 的稳定时间步长格式下，模态振幅 $a_{k}(n)$ 的无强迫离散时间演化可以表示为 $a_{k}(n) = \\alpha a_{k}(n-1)$，其中 $\\alpha \\in (-1,1)$ 是该模态对应的线性数值传播子的放大因子。\n\n现在，假设该偏微分方程由一个零均值的时间有色源驱动，该源以加法方式耦合到同一模态，使得观测到的模态振幅动态遵循\n$$\nx_{n} = \\alpha x_{n-1} + r_{n}, \\quad n \\in \\mathbb{Z},\n$$\n其中 $x_{n} := a_{k}(n)$ 是标量模态振幅，$r_{n}$ 是一个1阶自回归 (AR(1)) 过程，由下式给出\n$$\nr_{n} = \\phi r_{n-1} + \\eta_{n},\n$$\n其中 $\\phi \\in (-1,1)$，$\\eta_{n}$ 是独立同分布的零均值新息，其方差 $\\sigma_{\\eta}^{2} \\in (0,\\infty)$ 为有限值。假设 $x_{n}$ 和 $r_{n}$ 是平稳的，且 $|\\alpha|1, |\\phi|1$。\n\n你收集了 $m$ 个连续的标量振幅快照，构成数据数组 $X = [x_{0}, x_{1}, \\dots, x_{m-1}]$ 和 $Y = [x_{1}, x_{2}, \\dots, x_{m}]$。你应用动态模态分解 (DMD) 来估计一维线性演化的主导特征值，DMD 定义为 $A_{\\mathrm{DMD}} = Y X^{+}$，其中 $X^{+}$ 表示 Moore–Penrose 伪逆。在标量情况下，DMD 估计简化为从 $x_{n-1}$ 到 $x_{n}$ 的最小二乘斜率映射。\n\n通过在 $m \\to \\infty$ 的极限下推导由 AR(1) 强迫引起的 DMD 特征值估计的期望偏差，来分析 DMD 特征值估计在这种时间有色强迫下的鲁棒性。将你的最终答案表示为关于 $\\alpha$ 和 $\\phi$ 的 $\\mathbb{E}[\\hat{\\alpha}] - \\alpha$ 的闭式解析表达式。不需要进行数值取整。", "solution": "问题要求计算由有色噪声驱动的标量自回归过程的动态模态分解 (DMD) 特征值估计的渐近偏差。该过程由以下耦合方程定义：\n$$\nx_{n} = \\alpha x_{n-1} + r_{n}\n$$\n$$\nr_{n} = \\phi r_{n-1} + \\eta_{n}\n$$\n其中 $x_n$ 是观测到的标量振幅，$\\alpha$ 是我们希望估计的真实动力学特征值，$r_n$ 是一个表示时间有色强迫的1阶自回归 (AR(1)) 过程。参数受 $|\\alpha|  1$ 和 $|\\phi|  1$ 的约束，这保证了过程的平稳性。新息 $\\eta_n$ 是独立同分布 (i.i.d.) 的，具有零均值 $\\mathbb{E}[\\eta_n] = 0$ 和有限方差 $\\sigma_\\eta^2$。\n\n在标量情况下，DMD 估计值（记为 $\\hat{\\alpha}$）是最小化从 $x_{n-1}$ 到 $x_n$ 映射中残差的最小二乘解。给定数据向量 $X = [x_{0}, x_{1}, \\dots, x_{m-1}]$ 和 $Y = [x_{1}, x_{2}, \\dots, x_{m}]$，DMD 特征值由 $A_{\\mathrm{DMD}} = Y X^{+}$ 给出，其中 $X^{+}$ 是行向量 $X$ 的 Moore-Penrose 伪逆。这可以简化为：\n$$\n\\hat{\\alpha} = \\frac{\\sum_{n=1}^{m} x_{n} x_{n-1}}{\\sum_{n=1}^{m} x_{n-1}^2}\n$$\n问题要求我们在大量快照的极限下，即 $m \\to \\infty$ 时，求出期望偏差 $\\mathbb{E}[\\hat{\\alpha}] - \\alpha$。\n\n在此极限下，根据平稳遍历过程的大数定律，样本均值依概率收敛于它们各自的期望值。在给定条件下，$x_n$ 过程是平稳的。因此，估计量 $\\hat{\\alpha}$ 依概率收敛到一个我们记为 $\\alpha_{\\infty}$ 的值：\n$$\n\\hat{\\alpha} \\xrightarrow{p}_{m\\to\\infty} \\alpha_{\\infty} = \\frac{\\mathbb{E}[x_{n} x_{n-1}]}{\\mathbb{E}[x_{n-1}^2]}\n$$\n由于平稳性，分母为 $\\mathbb{E}[x_{n-1}^2] = \\mathbb{E}[x_n^2]$。令 $\\gamma_x(k) = \\mathbb{E}[x_n x_{n-k}]$ 为过程 $x_n$ 的自协方差函数。那么渐近估计为：\n$$\n\\alpha_{\\infty} = \\frac{\\gamma_x(1)}{\\gamma_x(0)}\n$$\n因此，渐近偏差为 $\\alpha_{\\infty} - \\alpha$。为了计算这个值，我们必须首先确定过程 $x_n$ 的统计特性，特别是它的自协方差函数。\n\n通过代入噪声项 $r_n$，过程 $x_n$ 可以表示为一个单一的方程。从主动力学方程中，我们有 $r_n = x_n - \\alpha x_{n-1}$。将此代入 $r_n$ 的方程中：\n$$\n(x_n - \\alpha x_{n-1}) = \\phi (x_{n-1} - \\alpha x_{n-2}) + \\eta_n\n$$\n重新整理各项，我们得到 $x_n$ 的演化方程：\n$$\nx_n = (\\alpha + \\phi) x_{n-1} - \\alpha\\phi x_{n-2} + \\eta_n\n$$\n这表明 $x_n$ 是一个2阶自回归 (AR(2)) 过程。该过程的稳定性由条件 $|\\alpha|1$ 和 $|\\phi|1$ 保证，因为特征多项式 $1 - (\\alpha+\\phi)z + \\alpha\\phi z^2 = (1-\\alpha z)(1-\\phi z)$ 的根是 $1/\\alpha$ 和 $1/\\phi$，它们都位于单位圆之外。\n\n对于一个平稳的 AR(p) 过程，其自协方差满足 Yule-Walker 方程。对于我们的 AR(2) 过程，将 $x_n$ 的方程两边乘以 $x_{n-k}$ (其中 $k0$) 并取期望，得到：\n$$\n\\mathbb{E}[x_n x_{n-k}] = (\\alpha + \\phi) \\mathbb{E}[x_{n-1} x_{n-k}] - \\alpha\\phi \\mathbb{E}[x_{n-2} x_{n-k}] + \\mathbb{E}[\\eta_n x_{n-k}]\n$$\n由于对于 $k0$，$x_{n-k}$ 只依赖于直到时间 $n-k$ 的新息，所以它与 $\\eta_n$ 不相关。因此，$\\mathbb{E}[\\eta_n x_{n-k}] = 0$。方程变为：\n$$\n\\gamma_x(k) = (\\alpha + \\phi) \\gamma_x(k-1) - \\alpha\\phi \\gamma_x(k-2) \\quad \\text{for } k  0\n$$\n为了求出比率 $\\gamma_x(1)/\\gamma_x(0)$，我们令 $k=1$：\n$$\n\\gamma_x(1) = (\\alpha + \\phi) \\gamma_x(0) - \\alpha\\phi \\gamma_x(-1)\n$$\n利用性质 $\\gamma_x(-1) = \\gamma_x(1)$，我们有：\n$$\n\\gamma_x(1) = (\\alpha + \\phi) \\gamma_x(0) - \\alpha\\phi \\gamma_x(1)\n$$\n合并包含 $\\gamma_x(1)$ 的项：\n$$\n\\gamma_x(1) (1 + \\alpha\\phi) = (\\alpha + \\phi) \\gamma_x(0)\n$$\n解出该比率，得到渐近 DMD 估计：\n$$\n\\alpha_{\\infty} = \\frac{\\gamma_x(1)}{\\gamma_x(0)} = \\frac{\\alpha + \\phi}{1 + \\alpha\\phi}\n$$\n估计量的渐近偏差是该值与真实参数 $\\alpha$ 之间的差：\n$$\n\\mathbb{E}[\\hat{\\alpha}] - \\alpha \\quad \\xrightarrow{m\\to\\infty} \\quad \\alpha_{\\infty} - \\alpha = \\frac{\\alpha + \\phi}{1 + \\alpha\\phi} - \\alpha\n$$\n我们将各项通分以进行简化：\n$$\n\\text{偏差} = \\frac{(\\alpha + \\phi) - \\alpha(1 + \\alpha\\phi)}{1 + \\alpha\\phi} = \\frac{\\alpha + \\phi - \\alpha - \\alpha^2\\phi}{1 + \\alpha\\phi} = \\frac{\\phi - \\alpha^2\\phi}{1 + \\alpha\\phi}\n$$\n从分子中提取因子 $\\phi$，得到渐近偏差的最终表达式：\n$$\n\\text{偏差} = \\frac{\\phi(1 - \\alpha^2)}{1 + \\alpha\\phi}\n$$\n这个结果表明，只有当 $\\phi=0$ 时偏差才为零，这对应于白噪声强迫的情况。对于任何非零的 $\\phi$，DMD 估计都是有偏的，偏差的大小和符号取决于系统自身动力学 ($\\alpha$) 与强迫的时间相关性 ($\\phi$) 之间的相互作用。", "answer": "$$\n\\boxed{\\frac{\\phi(1 - \\alpha^2)}{1 + \\alpha\\phi}}\n$$", "id": "3383158"}]}