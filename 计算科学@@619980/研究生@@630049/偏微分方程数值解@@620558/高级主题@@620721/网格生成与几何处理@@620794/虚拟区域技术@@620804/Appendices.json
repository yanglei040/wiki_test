{"hands_on_practices": [{"introduction": "本章的第一个实践练习将从最简单的情况入手，解决虚拟区域方法的核心挑战：一个一维问题中，界面与网格不重合。我们将探讨如何用数值方法表示跨材料界面的物理通量连续性。你将实现并比较一个简单的算术平均方案和一个基于物理的谐波平均方案，后者对于处理高对比度材料至关重要。这个练习 ([@problem_id:3392223]) 为理解为何专门的“稳定”格式对于虚拟区域方法的鲁棒性和准确性是必不可少的，提供了基础性的动手经验。", "problem": "考虑区间 $[-1,1]$ 上的标量椭圆界面问题：求 $u:[-1,1]\\to\\mathbb{R}$ 使得\n$$\n-\\frac{d}{dx}\\left(\\kappa(x)\\,\\frac{du}{dx}\\right)=0 \\quad \\text{for } x\\in(-1,1),\n$$\n满足狄利克雷边界条件 $u(-1)=-1$ 和 $u(1)=1$，其中电导率 $\\kappa(x)$ 是分段常数，在预设的界面点 $\\xi\\in(-1,1)$ 处有单次跳跃，即\n$$\n\\kappa(x)=\n\\begin{cases}\n\\kappa_1,  x  \\xi,\\\\\n\\kappa_2,  x \\ge \\xi,\n\\end{cases}\n$$\n其中 $\\kappa_1$ 和 $\\kappa_2$ 为给定的正常数。界面条件为 $u$ 在 $x=\\xi$ 处的连续性和法向通量的连续性，\n$$\nu(\\xi^-)=u(\\xi^+),\\qquad \\kappa_1\\,\\frac{du}{dx}(\\xi^-)=\\kappa_2\\,\\frac{du}{dx}(\\xi^+).\n$$\n该公式是分析偏微分方程数值解中虚拟区域技术的一个典型模型，其中界面切割位置 $\\xi$ 通常独立于离散化网格。\n\n从弱形式和标准守恒原理出发，您的目标是为该界面问题在均匀网格上设计并实现两种数值格式：\n\n- 一种非稳定格式，使用对切割位置 $\\xi$ 不敏感的朴素界面电导率模型；\n- 一种稳定格式，采用一致的通量模型处理切割面，利用沿被界面分割的界面区间上电导的串联极限行为。\n\n稳定格式必须在高对比度 $\\kappa_1\\ll \\kappa_2$ 下具有鲁棒性，并且无论切割位置 $\\xi$ 如何，都应能捕捉到界面处正确的通量连续性。非稳定格式应通过使用简单的、与位置无关的平均法则来建模界面电导率，从而刻意地缺乏这种鲁棒性。两种格式都必须在内部节点上组装一个三对角对称正定（SPD）线性系统，并强加狄利克雷边界条件。\n\n为使研究可进行量化测试，请按以下步骤操作。\n\n1. 在给定的边界和界面条件下，推导对于一般 $\\xi\\in(-1,1)$ 和正数 $\\kappa_1,\\kappa_2$ 的精确解 $u_{\\text{ex}}(x)$。精确解是分段线性的，在 $(-1,\\xi)$ 和 $(\\xi,1)$ 上具有不同的斜率，受通量连续性约束。\n\n2. 在 $[-1,1]$ 上包含端点的 $N$ 个节点的均匀网格上实现这两种数值格式，步长为 $h=2/(N-1)$。虚拟区域的特点在于，界面 $\\xi$ 可以位于 $(-1,1)$ 内的任何位置，与网格无关；如果界面严格位于区间 $[x_{i-1},x_i]$ 内部，稳定格式必须能反映出跨越该切割区间的正确守恒性。\n\n3. 对每种格式，计算离散解 $u_h$，并使用梯度误差的单元积分来评估 $H^1$ 半范数误差。具体来说，对于每个长度为 $h$ 的单元 $[x_{i-1},x_i]$，将离散解的单元梯度定义为\n$$\ng_h^{(i)}=\\frac{u_h(x_i)-u_h(x_{i-1})}{h}.\n$$\n精确梯度是分段常数，在 $[x_{i-1},x_i]\\subset(-1,\\xi)$ 上等于左侧斜率，在 $[x_{i-1},x_i]\\subset(\\xi,1)$ 上等于右侧斜率；如果界面严格位于单元内部，则需将积分拆分为左右两个子区间。通过下式近似误差的 $H^1$ 半范数\n$$\n\\|u_h-u_{\\text{ex}}\\|_{H^1( -1,1)} \\approx \\left(\\sum_{i=1}^{N-1}\\int_{x_{i-1}}^{x_i}\\big(g_h^{(i)}-u_{\\text{ex}}'(x)\\big)^2\\,dx\\right)^{1/2}.\n$$\n\n4. 通过使用该界面限制问题的理论预期收敛阶对误差进行归一化，来定义每种格式的 $H^1$ 误差常数。由于主要贡献局部化在单个切割单元附近，且精确解的斜率存在不连续性，假设 $H^1$ 半范数的预期收敛阶与 $h^{1/2}$ 成正比，并计算\n$$\nC_{H^1} = \\frac{\\|u_h-u_{\\text{ex}}\\|_{H^1(-1,1)}}{\\sqrt{h}}.\n$$\n分别报告非稳定格式和稳定格式的 $C_{H^1}$。分析 $C_{H^1}$ 如何依赖于对比度参数 $\\kappa_1$ 和 $\\kappa_2$。\n\n您的程序必须实现上述内容，并为以下参数值 $(\\kappa_1,\\kappa_2,\\xi,N)$ 的测试套件生成量化结果：\n\n- 测试1（基准等电导率）：$(\\kappa_1,\\kappa_2,\\xi,N)=(1,1,0.3,501)$。\n- 测试2（中度高对比度）：$(\\kappa_1,\\kappa_2,\\xi,N)=(10^{-3},1,0.3,501)$。\n- 测试3（极端高对比度）：$(\\kappa_1,\\kappa_2,\\xi,N)=(10^{-6},1,0.3,501)$。\n- 测试4（对齐的界面边缘情况）：$(\\kappa_1,\\kappa_2,\\xi,N)=(10^{-6},1,0.0,501)$。\n\n对于每个测试用例，您的程序必须计算并输出一个包含两个浮点数的列表 $[C_{H^1}^{\\text{unstab}}, C_{H^1}^{\\text{stab}}]$，其中 $C_{H^1}^{\\text{unstab}}$ 是非稳定格式的误差常数，$C_{H^1}^{\\text{stab}}$ 是稳定格式的误差常数。最终输出必须将所有测试用例的结果汇总为一行文本，其中包含列表的列表，格式需严格如下：\n\n“您的程序应生成单行输出，其中包含一个以逗号分隔的、由方括号括起来的、针对每个测试用例的双浮点数列表（例如，[[c11,c12],[c21,c22],[c31,c32],[c41,c42]]）。”\n\n此问题不涉及物理单位或角度单位。输出中的浮点数应以数值形式表示（可接受十进制或科学记数法）。该问题侧重于在虚拟区域技术背景下进行推导、鲁棒性分析以及对比度依赖性分析。", "solution": "用户提供的问题是偏微分方程数值分析中一个有效、适定且具有科学依据的练习。所有必要的数据和条件都已提供，足以推导解析解、实现两种不同的数值格式并量化评估其性能。该问题是客观的，直接探讨了虚拟区域技术的核心概念，特别是处理与计算网格不对齐的界面的方法。\n\n### 1. 解析解\n该问题由一维稳态扩散方程控制：\n$$\n-\\frac{d}{dx}\\left(\\kappa(x)\\,\\frac{du}{dx}\\right)=0 \\quad \\text{for } x\\in(-1,1)\n$$\n对 $x$ 积分一次表明，通量 $J(x) = -\\kappa(x) \\frac{du}{dx}$ 必须是一个常数，记为 $J_0$。因此，$\\frac{du}{dx} = -J_0/\\kappa(x)$。再次积分得到分段线性解。我们定义 $C = -J_0$。\n$$\nu'(x) = \\frac{C}{\\kappa(x)} =\n\\begin{cases}\nC/\\kappa_1,  x  \\xi \\\\\nC/\\kappa_2,  x \\ge\\xi\n\\end{cases}\n$$\n积分并应用边界条件 $u(-1)=-1$ 和 $u(1)=1$，并强制解 $u(x)$ 在界面 $x=\\xi$ 处的连续性，我们得到解：\n$$\nu_{\\text{ex}}(x) =\n\\begin{cases}\n\\frac{C}{\\kappa_1}(x+1) - 1,  x \\in [-1, \\xi) \\\\\n\\frac{C}{\\kappa_2}(x-1) + 1,  x \\in [\\xi, 1]\n\\end{cases}\n$$\n常数 $C$ 由连续性条件 $u(\\xi^-)=u(\\xi^+)$ 确定：\n$$\n\\frac{C}{\\kappa_1}(\\xi+1) - 1 = \\frac{C}{\\kappa_2}(\\xi-1) + 1\n$$\n求解 $C$ 可得：\n$$\nC = \\frac{2 \\kappa_1 \\kappa_2}{\\kappa_2(\\xi+1) - \\kappa_1(\\xi-1)}\n$$\n该解析解为误差计算提供了所需的精确梯度 $u_{\\text{ex}}'(x)$，它是分段常数：当 $x  \\xi$ 时，$u_{\\text{ex}}'(x) = C/\\kappa_1$；当 $x \\ge \\xi$ 时，$u_{\\text{ex}}'(x) = C/\\kappa_2$。\n\n### 2. 数值离散化\n我们采用有限体积法，在均匀网格 $x_i = -1 + ih$（其中 $i=0, \\dots, N-1$）上进行计算，网格间距为 $h=2/(N-1)$。将偏微分方程在以每个内部节点 $x_i$ 为中心的控制体 $[x_{i-1/2}, x_{i+1/2}]$ 上积分，得到守恒律：\n$$\n\\left(-\\kappa\\frac{du}{dx}\\right)_{x_{i+1/2}} - \\left(-\\kappa\\frac{du}{dx}\\right)_{x_{i-1/2}} = 0\n$$\n这表示流入控制体的通量等于流出控制体的通量。我们将单元界面 $x_{i-1/2}$（$x_{i-1}$ 和 $x_i$ 之间的中点）处的通量近似为：\n$$\nJ_{i-1/2} = -\\kappa_{i-1/2} \\frac{u_i - u_{i-1}}{h}\n$$\n其中 $u_i \\approx u(x_i)$，$\\kappa_{i-1/2}$ 是区间 $[x_{i-1}, x_i]$ 的有效电导率。每个内部节点 $i=1, \\dots, N-2$ 的离散方程为：\n$$\n-\\kappa_{i+1/2}\\frac{u_{i+1}-u_i}{h} + \\kappa_{i-1/2}\\frac{u_i-u_{i-1}}{h} = 0\n$$\n整理后，我们得到三对角系统的模板：\n$$\n-\\kappa_{i-1/2} u_{i-1} + (\\kappa_{i-1/2} + \\kappa_{i+1/2}) u_i - \\kappa_{i+1/2} u_{i+1} = 0\n$$\n两种所需格式的区别在于界面电导率 $\\kappa_{i-1/2}$ 的定义。\n\n### 3. 非稳定格式\n该格式使用一个朴素的、对位置不敏感的平均法则。一个标准的选择是相邻节点处电导率值的算术平均：\n$$\n\\kappa_{i-1/2}^{\\text{unstab}} = \\frac{\\kappa(x_{i-1}) + \\kappa(x_i)}{2}\n$$\n其中，如果 $x_j  \\xi$，则 $\\kappa(x_j) = \\kappa_1$；如果 $x_j \\ge \\xi$，则 $\\kappa(x_j) = \\kappa_2$。这个模型易于实现，但无法正确表示流经分层介质的物理过程，特别是在高对比度下，因为它只对哪些节点落在界面两侧敏感，而对界面在单元内的精确位置不敏感。\n\n### 4. 稳定格式\n该格式对有效电导率使用物理上一致的模型，反映了电阻的串联极限行为。长度为 $L$、电导率为 $\\kappa$ 的一维段的热/电阻为 $R=L/\\kappa$。对于串联的两个段，电阻相加。长度为 $h$ 的区间 $[x_{i-1}, x_i]$ 的有效电导率 $\\kappa_{i-1/2}$ 从其总电阻推导得出：\n$$\nR_{\\text{cell}} = \\int_{x_{i-1}}^{x_i} \\frac{dx'}{\\kappa(x')} = \\frac{h}{\\kappa_{i-1/2}}\n$$\n这给出了电导率的调和平均值。\n如果界面 $\\xi$ 不在 $(x_{i-1}, x_i)$ 内，则 $\\kappa(x)$ 是常数，$\\kappa_{i-1/2}^{\\text{stab}}$ 为 $\\kappa_1$ 或 $\\kappa_2$。\n如果界面位于单元内，$x_{i-1}  \\xi  x_i$，则积分被拆分：\n$$\n\\int_{x_{i-1}}^{x_i} \\frac{dx'}{\\kappa(x')} = \\int_{x_{i-1}}^{\\xi} \\frac{dx'}{\\kappa_1} + \\int_{\\xi}^{x_i} \\frac{dx'}{\\kappa_2} = \\frac{\\xi-x_{i-1}}{\\kappa_1} + \\frac{x_i-\\xi}{\\kappa_2}\n$$\n因此，稳定的界面电导率为：\n$$\n\\kappa_{i-1/2}^{\\text{stab}} = \\frac{h}{\\frac{\\xi-x_{i-1}}{\\kappa_1} + \\frac{x_i-\\xi}{\\kappa_2}}\n$$\n该公式是鲁棒的，因为它正确地捕捉了低电导率材料的通量限制行为，无论 $\\xi$ 的子网格位置或对比度 $\\kappa_2/\\kappa_1$ 如何。\n\n### 5. 线性系统与边界条件\n对于两种格式，都为未知内部节点值的向量 $\\mathbf{u} = [u_1, \\dots, u_{N-2}]^T$ 组装一个线性系统 $A\\mathbf{u}=\\mathbf{b}$。矩阵 $A$ 是一个 $(N-2)\\times(N-2)$ 的对称正定（SPD）三对角矩阵。狄利克雷边界条件 $u_0 = u(-1) = -1$ 和 $u_{N-1} = u(1) = 1$ 通过将其贡献移至右端向量 $\\mathbf{b}$ 中来并入。\n对于第一个方程（$i=1$）：\n$$\n(\\kappa_{1/2} + \\kappa_{3/2})u_1 - \\kappa_{3/2}u_2 = -\\kappa_{1/2}u_0 = \\kappa_{1/2}\n$$\n对于最后一个方程（$i=N-2$）：\n$$\n-\\kappa_{N-5/2}u_{N-3} + (\\kappa_{N-5/2} + \\kappa_{N-3/2})u_{N-2} = \\kappa_{N-3/2}u_{N-1} = \\kappa_{N-3/2}\n$$\n得到的 SPD 系统可以使用标准的带状矩阵求解器高效求解。\n\n### 6. 误差范数计算\n误差在 $H^1$ 半范数中进行评估，通过对网格单元求和来近似：\n$$\n\\|u_h-u_{\\text{ex}}\\|_{H^1(-1,1)}^2 \\approx \\sum_{i=1}^{N-1}\\int_{x_{i-1}}^{x_i}\\big(g_h^{(i)}-u_{\\text{ex}}'(x)\\big)^2\\,dx\n$$\n其中 $g_h^{(i)} = (u_h(x_i) - u_h(x_{i-1})) / h$ 是数值解的分段常数梯度。每个单元 $[x_{i-1}, x_i]$ 的积分计算考虑两种情况：\n1.  **非切割单元**：如果 $\\xi \\notin (x_{i-1}, x_i)$，$u_{\\text{ex}}'(x)$ 在单元内是常数，积分为 $(g_h^{(i)} - u_{\\text{ex}}')^2 h$。\n2.  **切割单元**：如果 $x_{i-1}  \\xi  x_i$，积分在 $\\xi$ 处被拆分：\n    $$\n    (g_h^{(i)} - C/\\kappa_1)^2(\\xi-x_{i-1}) + (g_h^{(i)} - C/\\kappa_2)^2(x_i-\\xi)\n    $$\n最后，通过使用 $h^{1/2}$ 的预期收敛阶对误差进行归一化，计算误差常数 $C_{H^1}$：\n$$\nC_{H^1} = \\frac{\\|u_h-u_{\\text{ex}}\\|_{H^1(-1,1)}}{\\sqrt{h}}\n$$\n这个常数提供了一种与网格大小 $N$ 无关的方法精度度量，从而可以公平比较各种格式对参数变化（特别是电导率对比度）的鲁棒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (k1, k2, xi, N)\n        (1.0, 1.0, 0.3, 501),\n        (1e-3, 1.0, 0.3, 501),\n        (1e-6, 1.0, 0.3, 501),\n        (1e-6, 1.0, 0.0, 501),\n    ]\n\n    all_results = []\n\n    for k1, k2, xi, N in test_cases:\n        h = 2.0 / (N - 1)\n        x = np.linspace(-1.0, 1.0, N)\n        \n        # Boundary conditions\n        u_left_bc = -1.0\n        u_right_bc = 1.0\n        \n        # Exact solution constant\n        denominator = k2 * (xi + 1.0) - k1 * (xi - 1.0)\n        # Avoid division by zero if conductivities are zero, though problem states positive.\n        if abs(denominator)  1e-15:\n            C_exact = 0.0 # Should not happen with positive k1,k2\n        else:\n            C_exact = (2.0 * k1 * k2) / denominator\n\n        u_prime_left = C_exact / k1 if k1 > 0 else 0\n        u_prime_right = C_exact / k2 if k2 > 0 else 0\n\n        case_results = []\n        for scheme in ['unstabilized', 'stabilized']:\n            # 1. Assemble face conductivities\n            num_faces = N - 1\n            k_face = np.zeros(num_faces)\n            \n            if scheme == 'unstabilized':\n                kappa_node = np.where(x  xi, k1, k2)\n                # Handle the case where xi is exactly on a node\n                # The rule is k(x)=k2 for x >= xi\n                for i in range(N):\n                    if x[i] >= xi:\n                        kappa_node[i] = k2\n                \n                for i in range(num_faces):\n                    k_face[i] = (kappa_node[i] + kappa_node[i+1]) / 2.0\n            \n            else: # stabilized\n                for i in range(num_faces):\n                    x_l, x_r = x[i], x[i+1]\n                    if xi = x_l + 1e-15: # Cell is in a region of k2\n                        k_face[i] = k2\n                    elif xi >= x_r - 1e-15: # Cell is in a region of k1\n                        k_face[i] = k1\n                    else: # Cell is cut by the interface\n                        resist_1 = (xi - x_l) / k1\n                        resist_2 = (x_r - xi) / k2\n                        k_face[i] = h / (resist_1 + resist_2)\n            \n            # 2. Assemble the linear system A*u = b for interior nodes\n            num_interior_nodes = N - 2\n            # Scipy's banded solver format: (l+u+1, M)\n            # Here: l=1, u=1, M = N-2. Matrix is (3, N-2)\n            # ab[0,:] = super-diagonal, ab[1,:] = main-diagonal, ab[2,:] = sub-diagonal\n            ab = np.zeros((3, num_interior_nodes))\n            b = np.zeros(num_interior_nodes)\n\n            # Main diagonal\n            ab[1, :] = k_face[:-1] + k_face[1:]\n            # Off-diagonals\n            ab[0, 1:] = -k_face[1:-1]\n            ab[2, :-1] = -k_face[1:-1]\n            \n            # Incorporate boundary conditions into RHS vector b\n            b[0] = k_face[0] * u_left_bc\n            b[-1] = k_face[-1] * u_right_bc\n\n            # 3. Solve the system\n            u_interior = solve_banded((1, 1), ab, b)\n            u_h = np.concatenate(([u_left_bc], u_interior, [u_right_bc]))\n\n            # 4. Compute H^1 seminorm error\n            error_sq_sum = 0.0\n            for i in range(1, N):\n                x_l, x_r = x[i-1], x[i]\n                g_h_i = (u_h[i] - u_h[i-1]) / h\n                \n                cell_error_sq = 0.0\n                if xi = x_l + 1e-15: # Cell is entirely in right part\n                    cell_error_sq = (g_h_i - u_prime_right)**2 * h\n                elif xi >= x_r - 1e-15: # Cell is entirely in left part\n                    cell_error_sq = (g_h_i - u_prime_left)**2 * h\n                else: # Cell is cut by interface\n                    err_left_part = (g_h_i - u_prime_left)**2 * (xi - x_l)\n                    err_right_part = (g_h_i - u_prime_right)**2 * (x_r - xi)\n                    cell_error_sq = err_left_part + err_right_part\n                \n                error_sq_sum += cell_error_sq\n\n            h1_seminorm_error = np.sqrt(error_sq_sum)\n            C_H1 = h1_seminorm_error / np.sqrt(h)\n            case_results.append(C_H1)\n            \n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'[{res[0]},{res[1]}]' for res in all_results)}]\")\n\nsolve()\n```", "id": "3392223"}, {"introduction": "在解决了一维扩散问题之后，这个实践练习将虚拟区域概念应用到一个经典的流固耦合场景中——沉浸边界法（Immersed Boundary Method, IBM）。你将通过将力从拉格朗日点“散播”到二维欧拉网格上，并反过来“插值”速度，来模拟弹性膜与不可压缩流体之间的相互作用。一个关键的焦点是研究“泄漏”（leakage）现象，这是一种数值伪影，表现为离散化后的流体似乎违反了跨越沉浸边界的质量守恒。通过这个练习 ([@problem_id:3510140])，你将获得关于IBM核心算子的实践经验，并理解数值选择（如正则化核函数和点间距）如何影响模拟的物理保真度。", "problem": "考虑一个二维周期性方形区域，由区间 $[0,1]\\times[0,1]$ 描述，该区域在每个方向上有 $N$ 个点的均匀笛卡尔网格上进行离散化，网格间距为 $h=1/N$。一个闭合的弹性边界由一个半径为 $R$、中心位于 $(0.5,0.5)$ 的圆形膜表示，该膜由 $N_{\\mathrm{L}}$ 个等间距的拉格朗日点离散化，其角度参数化为 $\\theta_i = 2\\pi i/N_{\\mathrm{L}}$（角度以弧度为单位）。假设膜两侧存在均匀的压力跳跃 $\\Delta p$，导致膜上产生等于 $\\Delta p\\,\\mathbf{n}$ 的单位长度法向牵引力，其中 $\\mathbf{n}$ 是向外的单位法向量。\n\n在沉浸边界法（IBM）中，拉格朗日-欧拉耦合使用正则化的狄拉克δ函数将膜的牵引力从拉格朗日点 $(X_i)$ 散布到欧拉网格上，并将欧拉速度插值回拉格朗日点。具体来说，正则化δ函数定义为\n$$\n\\delta_h(\\mathbf{x})=\\frac{1}{h^2}\\,\\phi\\left(\\frac{x}{h}\\right)\\,\\phi\\left(\\frac{y}{h}\\right),\n$$\n其中，紧支撑的一维核函数 $\\phi(\\cdot)$ 从一组候选项中选择。欧拉力密度则为\n$$\n\\mathbf{F}(\\mathbf{x})=\\sum_{i=0}^{N_{\\mathrm{L}}-1} \\Delta p\\,\\mathbf{n}_i\\,\\delta_h(\\mathbf{x}-\\mathbf{X}_i)\\,ds,\n$$\n其中 $ds = 2\\pi R/N_{\\mathrm{L}}$ 是线段长度。在没有惯性效应的情况下，欧拉速度 $\\mathbf{u}$ 由稳态斯托克斯方程控制，\n$$\n-\\nabla p + \\mu \\Delta \\mathbf{u} + \\mathbf{F} = \\mathbf{0},\\qquad \\nabla\\cdot\\mathbf{u} = 0,\n$$\n其中 $\\mu$ 是动力粘度，并采用周期性边界条件。在这个周期性区域上，$\\mathbf{u}$ 的唯一无散解可以通过快速傅里叶变换（FFT）在谱空间上表示，方法是将作用力投影到无散子空间上，并对所有非零波数除以拉普拉斯算子特征值。\n\n拉格朗日速度 $\\mathbf{U}_i$ 通过插值获得，\n$$\n\\mathbf{U}_i = \\sum_{\\text{grid }\\mathbf{x}} \\mathbf{u}(\\mathbf{x}) \\,\\delta_h(\\mathbf{X}_i - \\mathbf{x})\\,h^2,\n$$\n穿过膜的面积通量（在二维情况下，对应于单位深度的体积变化率）通过法向速度的线积分计算，\n$$\n\\frac{dA}{dt} = \\oint_{\\Gamma} \\mathbf{u}\\cdot\\mathbf{n}\\,ds \\approx \\sum_{i=0}^{N_{\\mathrm{L}}-1} \\mathbf{U}_i\\cdot\\mathbf{n}_i\\,ds.\n$$\n在连续介质中，对于包围一个物质体积的不可压缩流（$\\nabla\\cdot\\mathbf{u}=0$），根据散度定理，面积变化率 $dA/dt$ 恒为零。然而，在离散的沉浸边界法中，由于核函数 $\\phi(\\cdot)$ 的选择以及拉格朗日点间距相对于欧拉网格的配置，散布和插值之间存在不匹配，可能导致 $dA/dt$ 非零。这种伪影性的非零 $dA/dt$ 被称为泄露（leakage）。\n\n您的任务是实现一个程序，该程序：\n- 按所述方式离散化膜。\n- 使用选定的正则化δ核函数散布均匀的压力牵引力。\n- 使用谱投影法在周期性区域上求解稳态斯托克斯方程。\n- 将速度插值回膜上。\n- 按所述方式计算面积变化率 $dA/dt$。\n\n您必须以无量纲形式处理所有量。角度必须以弧度为单位。对于核函数 $\\phi(\\cdot)$，您必须至少支持以下选择：\n- Peskin 四点核函数（沉浸边界法核函数）：\n$$\n\\phi(r)=\\begin{cases}\n\\frac{1}{8}\\left(3-2|r|+\\sqrt{1+4|r|-4r^2}\\right),  |r|1,\\\\\n\\frac{1}{8}\\left(5-2|r|-\\sqrt{-7+12|r|-4r^2}\\right),  1\\le |r|2,\\\\\n0,  \\text{其他情况,}\n\\end{cases}\n$$\n- 三次基本B样条：\n$$\n\\phi(r)=\\begin{cases}\n\\frac{1}{6}\\left(4-6|r|^2+3|r|^3\\right),  |r|1,\\\\\n\\frac{1}{6}\\left(2-|r|\\right)^3,  1\\le |r|2,\\\\\n0,  \\text{其他情况。}\n\\end{cases}\n$$\n\n对于所有计算，设置 $N=64$， $h=1/N$， $R=0.25$， $\\mu=1$。定义拉格朗日间距比 $s=ds/h$，并通过 $N_{\\mathrm{L}} = \\left\\lfloor \\frac{2\\pi R}{s\\,h} \\right\\rfloor$ 确定 $N_{\\mathrm{L}}$，约束条件为 $N_{\\mathrm{L}}\\ge 8$。使用向外法向量 $\\mathbf{n}_i=[\\cos\\theta_i,\\sin\\theta_i]$。用于基于FFT的微分的波数必须是 $k_x=2\\pi\\,\\mathrm{freq}_x$ 和 $k_y=2\\pi\\,\\mathrm{freq}_y$，其中 $\\mathrm{freq}$ 是对应间距 $h$ 的标准离散傅里叶频率。\n\n设计您的代码，为以下由参数对 $(\\text{kernel},s)$ 和压力跳跃 $\\Delta p$ 指定的测试参数集计算 $dA/dt$：\n- 情况 1：$(\\text{peskin4},\\,s=1.0)$，$\\Delta p=1$。\n- 情况 2：$(\\text{peskin4},\\,s=0.5)$，$\\Delta p=1$。\n- 情况 3：$(\\text{peskin4},\\,s=2.0)$，$\\Delta p=1$。\n- 情况 4：$(\\text{bspline3},\\,s=1.0)$，$\\Delta p=1$。\n- 情况 5：$(\\text{bspline3},\\,s=0.5)$，$\\Delta p=1$。\n- 情况 6：$(\\text{bspline3},\\,s=2.0)$，$\\Delta p=1$。\n- 情况 7（边界情况）：$(\\text{peskin4},\\,s=1.0)$，$\\Delta p=0$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按情况1到7的顺序排列，每个结果是计算出的浮点数 $dA/dt$。因为所有量都是无量纲的，所以不要在输出中附加任何物理单位。角度单位是弧度；所有输出必须是十进制浮点数。输出格式必须严格为\n$$\n[\\text{result}_1,\\text{result}_2,\\ldots,\\text{result}_7],\n$$\n其中每个 $\\text{result}_i$ 是一个浮点数值。", "solution": "该问题被认为是有效的，因为它在科学上基于计算流体动力学的原理，特别是沉浸边界法（IBM），并且是一个具有完整和一致给定条件的、适定的数值问题。该任务涉及模拟流固耦合，以量化一种已知的数值伪影——“泄露”，这种伪影源于离散化和耦合核函数的选择。\n\n解决方案是为每个测试案例逐步实现所述的数值方法。\n\n**1. 区域与边界的离散化**\n\n物理设置包括一个二维周期性区域 $\\Omega = [0,1] \\times [0,1]$ 和一个半径为 $R=0.25$、中心位于 $(0.5, 0.5)$ 的圆形膜 $\\Gamma$。\n\n- **欧拉网格**：区域 $\\Omega$ 被离散化为一个 $N \\times N$ 个点的均匀笛卡尔网格，其中 $N=64$。网格间距为 $h = 1/N = 1/64$。网格点位于 $\\mathbf{x}_{j,k} = (j h, k h)$，其中 $j,k \\in \\{0, 1, \\dots, N-1\\}$。\n\n- **拉格朗日网格**：膜 $\\Gamma$ 被离散化为 $N_{\\mathrm{L}}$ 个拉格朗日点。点的数量 $N_{\\mathrm{L}}$ 由拉格朗日间距比 $s = ds/h$ 决定，其中 $ds$ 是相邻拉格朗日点之间的弧长。公式为 $N_{\\mathrm{L}} = \\lfloor \\frac{2\\pi R}{s h} \\rfloor$。然后重新计算弧长为 $ds = 2\\pi R/N_{\\mathrm{L}}$，以确保离散化的环是闭合的。拉格朗日点的位置由角度 $\\theta_i = 2\\pi i/N_{\\mathrm{L}}$ (其中 $i \\in \\{0, 1, \\dots, N_{\\mathrm{L}}-1\\}$) 进行参数化给出：\n$$\n\\mathbf{X}_i = (0.5 + R\\cos\\theta_i, 0.5 + R\\sin\\theta_i)\n$$\n在每个点 $\\mathbf{X}_i$ 处的向外单位法向量是 $\\mathbf{n}_i = (\\cos\\theta_i, \\sin\\theta_i)$。\n\n**2. 核函数与正则化Delta函数**\n\n流体（欧拉）与结构（拉格朗日）之间的相互作用由一个正则化的狄拉克δ函数 $\\delta_h(\\mathbf{x})$ 介导，该函数由一维核函数 $\\phi(r)$ 构造。根据其分段定义，实现了两种指定的核函数：Peskin 4点核函数和三次B样条。两种核函数都具有 $4h$ 的紧支撑，意味着当 $|r| \\ge 2$ 时 $\\phi(r)=0$。\n\n**3. 散布：从拉格朗日力到欧拉力密度**\n\n膜两侧的均匀压力跳跃 $\\Delta p$ 产生一个等于 $\\Delta p \\, \\mathbf{n}$ 的单位长度法向力（牵引力）。在每个拉格朗日点 $\\mathbf{X}_i$ 处的离散力是 $\\mathbf{f}_i = \\Delta p \\, \\mathbf{n}_i \\, ds$。\n\n这个拉格朗日力被“散布”到周围的欧拉网格点上，以获得欧拉力密度场 $\\mathbf{F}(\\mathbf{x})$。这个散布操作的公式是：\n$$\n\\mathbf{F}(\\mathbf{x}) = \\sum_{i=0}^{N_{\\mathrm{L}}-1} \\mathbf{f}_i \\, \\delta_h(\\mathbf{x} - \\mathbf{X}_i) = \\frac{1}{h^2} \\sum_{i=0}^{N_{\\mathrm{L}}-1} (\\Delta p \\, \\mathbf{n}_i \\, ds) \\, \\phi\\left(\\frac{x-X_{i,x}}{h}\\right) \\phi\\left(\\frac{y-X_{i,y}}{h}\\right)\n$$\n在数值上，对于每个拉格朗日点 $\\mathbf{X}_i$，我们识别出落在核函数支撑域内的邻近欧拉网格点 $\\mathbf{x}_{j,k}$。然后计算力的贡献并加到欧拉力数组 `Fx` 和 `Fy` 的相应元素上。由于区域是周期性的，距离的计算要考虑网格的环绕特性。\n\n**4. 求解稳态斯托克斯方程**\n\n流体速度 $\\mathbf{u}$ 和压力 $p$ 由具有周期性边界条件的稳态斯托克斯方程控制：\n$$\n-\\nabla p + \\mu \\Delta \\mathbf{u} + \\mathbf{F} = \\mathbf{0}, \\qquad \\nabla\\cdot\\mathbf{u} = 0\n$$\n鉴于周期性，这些方程在傅里叶空间中可以被高效求解。对这些方程应用快速傅里叶变换（FFT）得到：\n$$\n-i\\mathbf{k}\\hat{p} - \\mu |\\mathbf{k}|^2 \\hat{\\mathbf{u}} + \\hat{\\mathbf{F}} = \\mathbf{0}, \\qquad i\\mathbf{k}\\cdot\\hat{\\mathbf{u}} = 0\n$$\n其中 $\\hat{\\cdot}$ 表示傅里叶变换，$\\mathbf{k}=(k_x, k_y)$ 是波矢量，并且 $|\\mathbf{k}|^2=k_x^2+k_y^2$。波数由 $k = 2\\pi f$ 确定，其中 $f$ 是来自 `scipy.fft.fftfreq` 的离散频率。\n\n不可压缩条件 ($i\\mathbf{k}\\cdot\\hat{\\mathbf{u}} = 0$) 意味着速度矢量 $\\hat{\\mathbf{u}}$ 与波矢量 $\\mathbf{k}$ 正交。通过将动量方程投影到无散子空间，我们可以直接求解 $\\hat{\\mathbf{u}}$：\n$$\n\\hat{\\mathbf{u}}(\\mathbf{k}) = \\frac{1}{\\mu |\\mathbf{k}|^2} \\left( \\hat{\\mathbf{F}} - \\frac{(\\mathbf{k} \\cdot \\hat{\\mathbf{F}})\\mathbf{k}}{|\\mathbf{k}|^2} \\right) \\quad \\text{对于 } \\mathbf{k} \\neq \\mathbf{0}\n$$\n对于零波数模式（$\\mathbf{k}=\\mathbf{0}$），$\\hat{\\mathbf{u}}(\\mathbf{0})$ 被设为零，对应于零平均速度。将得到的傅里叶空间中的速度场 $(\\hat{u}_x, \\hat{u}_y)$ 通过逆FFT变换回实空间，得到欧拉速度场 $(u_x, u_y)$。\n\n**5. 插值：从欧拉速度到拉格朗日速度**\n\n膜上各点速度 $\\mathbf{U}_i$ 是通过在拉格朗日位置 $\\mathbf{X}_i$ 插值欧拉速度场 $\\mathbf{u}(\\mathbf{x})$ 得到的。此操作是散布操作的伴随操作：\n$$\n\\mathbf{U}_i = \\sum_{\\text{grid }\\mathbf{x}} \\mathbf{u}(\\mathbf{x}) \\, \\delta_h(\\mathbf{X}_i - \\mathbf{x}) \\, h^2 = \\sum_{\\text{grid }\\mathbf{x}} \\mathbf{u}(\\mathbf{x}) \\, \\phi\\left(\\frac{X_{i,x}-x}{h}\\right) \\phi\\left(\\frac{Y_{i,y}-y}{h}\\right)\n$$\n在数值上，对于每个拉格朗日点 $\\mathbf{X}_i$，我们再次识别出邻近的欧拉网格点，并计算它们速度的加权和以求得 $\\mathbf{U}_i$。\n\n**6. 面积变化率（$dA/dt$）的计算**\n\n最后，膜所包围面积的变化率，作为数值泄露的一种度量，通过近似计算沿边界的法向速度的线积分来得到：\n$$\n\\frac{dA}{dt} = \\oint_{\\Gamma} \\mathbf{u}\\cdot\\mathbf{n}\\,ds \\approx \\sum_{i=0}^{N_{\\mathrm{L}}-1} \\mathbf{U}_i\\cdot\\mathbf{n}_i\\,ds\n$$\n对问题中指定的每个测试案例计算此值。$\\Delta p = 0$ 的情况作为一个空测试，它应产生零力、零速度，因此泄露为零，这验证了基础实现的线性和正确性。", "answer": "```python\nimport numpy as np\nimport scipy.fft\n\ndef peskin4_kernel(r):\n    \"\"\"\n    Computes the Peskin 4-point regularized delta function kernel.\n    \"\"\"\n    r_abs = np.abs(r)\n    val = np.zeros_like(r_abs)\n    \n    # |r|  1\n    mask1 = r_abs  1\n    r1 = r_abs[mask1]\n    val[mask1] = (1/8) * (3 - 2*r1 + np.sqrt(1 + 4*r1 - 4*r1**2))\n    \n    # 1 = |r|  2\n    mask2 = (r_abs >= 1)  (r_abs  2)\n    r2 = r_abs[mask2]\n    # Ensure argument of sqrt is non-negative due to float precision issues\n    sqrt_arg = -7 + 12*r2 - 4*r2**2\n    sqrt_arg[sqrt_arg  0] = 0.0\n    val[mask2] = (1/8) * (5 - 2*r2 - np.sqrt(sqrt_arg))\n\n    return val\n\ndef bspline3_kernel(r):\n    \"\"\"\n    Computes the cardinal cubic B-spline kernel.\n    \"\"\"\n    r_abs = np.abs(r)\n    val = np.zeros_like(r_abs)\n    \n    # |r|  1\n    mask1 = r_abs  1\n    r1 = r_abs[mask1]\n    val[mask1] = (1/6) * (4 - 6*r1**2 + 3*r1**3)\n\n    # 1 = |r|  2\n    mask2 = (r_abs >= 1)  (r_abs  2)\n    r2 = r_abs[mask2]\n    val[mask2] = (1/6) * (2 - r2)**3\n    \n    return val\n\ndef compute_leakage(kernel_name, s, dp):\n    \"\"\"\n    Computes the area change rate (dA/dt) for the given parameters.\n    \"\"\"\n    # System parameters\n    N = 64\n    R = 0.25\n    mu = 1.0\n    h = 1.0 / N\n\n    # Select the kernel function\n    kernels = {'peskin4': peskin4_kernel, 'bspline3': bspline3_kernel}\n    kernel_func = kernels[kernel_name]\n\n    # Lagrangian boundary discretization\n    N_L = int(np.floor(2 * np.pi * R / (s * h)))\n    ds = 2 * np.pi * R / N_L\n    theta = 2 * np.pi * np.arange(N_L) / N_L\n    \n    X_lag = 0.5 + R * np.cos(theta)\n    Y_lag = 0.5 + R * np.sin(theta)\n    nx = np.cos(theta)\n    ny = np.sin(theta)\n\n    # Sanity check: if pressure jump is zero, leakage must be zero\n    if dp == 0:\n        return 0.0\n\n    # --- Step 1: Spreading (Lagrangian force to Eulerian grid) ---\n    Fx = np.zeros((N, N))\n    Fy = np.zeros((N, N))\n    \n    for i in range(N_L):\n        lag_force_x = dp * nx[i] * ds\n        lag_force_y = dp * ny[i] * ds\n        \n        sx = X_lag[i] / h\n        sy = Y_lag[i] / h\n        \n        j_base = int(np.floor(sx))\n        k_base = int(np.floor(sy))\n\n        for dj in range(-1, 3):\n            for dk in range(-1, 3):\n                j = j_base + dj\n                k = k_base + dk\n                \n                rx = sx - j\n                ry = sy - k\n                \n                j_idx, k_idx = j % N, k % N\n                \n                weight = kernel_func(rx) * kernel_func(ry) / h**2\n                \n                Fx[k_idx, j_idx] += lag_force_x * weight\n                Fy[k_idx, j_idx] += lag_force_y * weight\n\n    # --- Step 2: Solve steady Stokes equations in Fourier space ---\n    Fx_hat = scipy.fft.fft2(Fx)\n    Fy_hat = scipy.fft.fft2(Fy)\n\n    freq = scipy.fft.fftfreq(N, h)\n    ky, kx = np.meshgrid(freq, freq, indexing='ij') # Note: meshgrid indexing\n    Kx = 2 * np.pi * kx\n    Ky = 2 * np.pi * ky\n\n\n    Ksq = Kx**2 + Ky**2\n    \n    inv_Ksq = np.zeros_like(Ksq)\n    nonzero_mask = Ksq != 0\n    inv_Ksq[nonzero_mask] = 1.0 / Ksq[nonzero_mask]\n    \n    k_dot_Fhat = Kx * Fx_hat + Ky * Fy_hat\n    \n    Fx_hat_solenoidal = Fx_hat - Kx * k_dot_Fhat * inv_Ksq\n    Fy_hat_solenoidal = Fy_hat - Ky * k_dot_Fhat * inv_Ksq\n    \n    ux_hat = Fx_hat_solenoidal * inv_Ksq / mu\n    uy_hat = Fy_hat_solenoidal * inv_Ksq / mu\n\n    ux = np.real(scipy.fft.ifft2(ux_hat))\n    uy = np.real(scipy.fft.ifft2(uy_hat))\n\n    # --- Step 3: Interpolation (Eulerian velocity to Lagrangian points) ---\n    Ux = np.zeros(N_L)\n    Uy = np.zeros(N_L)\n\n    for i in range(N_L):\n        sx = X_lag[i] / h\n        sy = Y_lag[i] / h\n        \n        j_base = int(np.floor(sx))\n        k_base = int(np.floor(sy))\n\n        for dj in range(-1, 3):\n            for dk in range(-1, 3):\n                j = j_base + dj\n                k = k_base + dk\n                \n                rx = sx - j\n                ry = sy - k\n                \n                j_idx, k_idx = j % N, k % N\n                \n                weight = kernel_func(rx) * kernel_func(ry)\n                \n                Ux[i] += ux[k_idx, j_idx] * weight\n                Uy[i] += uy[k_idx, j_idx] * weight\n                \n    # --- Step 4: Calculate Area Change Rate (Leakage) ---\n    dAdt = np.sum((Ux * nx + Uy * ny)) * ds\n    \n    return dAdt\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (kernel_name, spacing_ratio_s, pressure_jump_dp)\n        ('peskin4', 1.0, 1.0),\n        ('peskin4', 0.5, 1.0),\n        ('peskin4', 2.0, 1.0),\n        ('bspline3', 1.0, 1.0),\n        ('bspline3', 0.5, 1.0),\n        ('bspline3', 2.0, 1.0),\n        ('peskin4', 1.0, 0.0), # Edge case\n    ]\n\n    results = []\n    for kernel_name, s, dp in test_cases:\n        result = compute_leakage(kernel_name, s, dp)\n        results.append(result)\n\n    # Format output as a comma-separated list of floats in brackets\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```", "id": "3510140"}, {"introduction": "在实现了虚拟区域方法之后，关键的下一步是验证其正确性并量化其精度。本实践介绍了一种强大的技术来达到此目的：制造解验证法（method of manufactured solutions）。你将在一个具有挑战性的非均匀网格上测试离散delta函数（IBM方法中网格间信息传递的核心）的一致性。这不仅涉及测量插值误差，还包括实现矩修正格式，以确保离散算子满足基本的数学性质。这个高级实践 ([@problem_id:3510132]) 将让你掌握一种严谨的验证方法论，并加深你对开发高精度沉浸边界代码所需的那些微妙但至关重要的细节的理解。", "problem": "设计并实现一种浸入边界 (IB) 离散化的人工解验证方法，该方法使用离散正则化 delta 核函数，将信息从一个拉格朗日点扩展到一个非均匀欧拉网格。其目标是在一个强非均匀网格上，当核宽度 $ \\varepsilon $ 和局部网格间距 $ h $ 变化时，验证离散卷积的一致性并研究其收敛行为。\n\n该测试基于狄拉克 delta 分布的基本性质，即对于一个光滑函数 $ f $，有\n$$\n\\int_{0}^{1} f(x)\\,\\delta(x - X)\\,dx = f(X).\n$$\n我们用一个满足零阶矩和一阶矩条件的正则化 delta $ \\delta_{\\varepsilon} $ 来替换奇异的狄拉克 delta $ \\delta $，\n$$\n\\int_{0}^{1} \\delta_{\\varepsilon}(x - X)\\,dx = 1,\\quad \\int_{0}^{1} (x - X)\\,\\delta_{\\varepsilon}(x - X)\\,dx = 0,\n$$\n并且我们用离散卷积来近似在非均匀网格上的积分。\n\n使用具有紧支集的 Peskin 四点正则化 delta 核函数 $ \\phi $，其定义为\n$$\n\\phi(s) = \\begin{cases}\n\\dfrac{1}{8}\\left(3 - 2|s| + \\sqrt{1 + 4|s| - 4 s^2}\\right),  \\text{若 } |s| \\le 1, \\\\\n\\dfrac{1}{8}\\left(5 - 2|s| - \\sqrt{-7 + 12|s| - 4 s^2}\\right),  \\text{若 } 1  |s| \\le 2, \\\\\n0,  \\text{若 } |s| > 2.\n\\end{cases}\n$$\n将正则化 delta 定义为\n$$\n\\delta_{\\varepsilon}(x - X) = \\frac{1}{\\varepsilon}\\,\\phi\\!\\left(\\frac{x - X}{\\varepsilon}\\right).\n$$\n\n在域 $ x \\in [0,1] $ 上构建一个强非均匀网格，节点为\n$$\nx_i = \\left(\\frac{i}{N}\\right)^3,\\quad i = 0,1,2,\\ldots,N,\n$$\n其中 $ N $ 是区间数量。使用复合梯形法则权重 $ \\Delta x_i $ 来近似此网格上的积分，定义为\n$$\n\\Delta x_0 = \\frac{x_1 - x_0}{2},\\quad \\Delta x_N = \\frac{x_N - x_{N-1}}{2},\\quad \\Delta x_i = \\frac{x_{i+1} - x_{i-1}}{2}\\ \\text{for}\\ i = 1,2,\\ldots,N-1.\n$$\n\n设人工光滑函数为\n$$\nf(x) = \\sin(2\\pi x) + x^2,\n$$\n拉格朗日点为 $ X \\in (0,1) $。通过离散卷积近似 $ f(X) $\n$$\nI_f \\approx \\sum_{i=0}^{N} f(x_i)\\,W_i\\,\\Delta x_i,\n$$\n其中 $ W_i $ 是由正则化核函数构建的离散 delta 权重，并通过校正以在数值积分下强制满足离散矩条件。具体来说：\n- 计算原始权重\n$$\nw_i = \\delta_{\\varepsilon}(x_i - X) = \\frac{1}{\\varepsilon}\\,\\phi\\!\\left(\\frac{x_i - X}{\\varepsilon}\\right).\n$$\n- 通过以下方式归一化零阶矩\n$$\nc_0 = \\sum_{i=0}^{N} w_i\\,\\Delta x_i,\\quad W_i^{(0)} = \\frac{w_i}{c_0}.\n$$\n- 通过引入线性校正因子 $ \\alpha $ 来强制满足离散一阶矩条件：\n$$\nm_1 = \\sum_{i=0}^{N} (x_i - X)\\,W_i^{(0)}\\,\\Delta x_i,\\quad \\mu_2 = \\sum_{i=0}^{N} (x_i - X)^2\\,W_i^{(0)}\\,\\Delta x_i,\\quad \\alpha = -\\frac{m_1}{\\mu_2},\n$$\n并定义校正后的权重\n$$\n\\widetilde{W}_i = W_i^{(0)}\\left(1 + \\alpha\\,(x_i - X)\\right).\n$$\n- 重新归一化校正后的权重以保持零阶矩：\n$$\n\\widetilde{c}_0 = \\sum_{i=0}^{N} \\widetilde{W}_i\\,\\Delta x_i,\\quad W_i = \\frac{\\widetilde{W}_i}{\\widetilde{c}_0}.\n$$\n\n在拉格朗日点 $ X $ 处的局部网格间距 $ h $ 被定义为与 $ X $ 在 $ \\ell^{\\infty} $ 范数下最近的节点 $ x_j $ 对应的复合梯形权重 $ \\Delta x_j $。设置核宽度为 $ \\varepsilon = \\kappa\\,h $，其中 $ \\kappa $ 是一个无量纲因子。\n\n对于每个测试用例，计算以下量：\n- 绝对插值误差\n$$\nE = \\left|\\,\\sum_{i=0}^{N} f(x_i)\\,W_i\\,\\Delta x_i - f(X)\\,\\right|.\n$$\n- 零阶矩误差\n$$\nE_0 = \\left|\\,1 - \\sum_{i=0}^{N} W_i\\,\\Delta x_i\\,\\right|.\n$$\n- 一阶矩误差\n$$\nE_1 = \\left|\\,\\sum_{i=0}^{N} (x_i - X)\\,W_i\\,\\Delta x_i\\,\\right|.\n$$\n\n您的程序必须实现上述构造，并为指定的测试套件计算 $ E $、$ E_0 $ 和 $ E_1 $。此外，通过计算观察到的阶数量化收敛性：\n- 对于固定的 $ \\kappa = 2.5 $ 和固定的 $ X \\in \\{0.05,\\,0.5,\\,0.95\\} $，比较 $ N = 64 $ 和 $ N = 256 $ 的情况，以计算关于局部网格间距 $ h $ 的观察阶。设 $ E_{64,X} $ 和 $ E_{256,X} $ 为插值误差，$ h_{64,X} $ 和 $ h_{256,X} $ 为相应的局部间距。定义\n$$\np_X = \\frac{\\log(E_{64,X} / E_{256,X})}{\\log(h_{64,X} / h_{256,X})}.\n$$\n- 对于固定的 $ N = 128 $ 和 $ X = 0.5 $，使用 $ \\kappa \\in \\{1.5,\\,2.5,\\,3.5\\} $，通过在对数-对数空间中进行线性回归来估计 $ E $ 相对于 $ \\varepsilon $ 的缩放关系。设 $ \\varepsilon_j $ 和 $ E_j $ 为这三个值；拟合 $ \\log(E_j) \\approx a + q\\,\\log(\\varepsilon_j) $ 以获得斜率 $ q $。\n\n测试套件：\n- 用例 1：$ N = 64 $，$ X = 0.05 $，$ \\kappa = 2.5 $。\n- 用例 2：$ N = 64 $，$ X = 0.5 $，$ \\kappa = 2.5 $。\n- 用例 3：$ N = 64 $，$ X = 0.95 $，$ \\kappa = 2.5 $。\n- 用例 4：$ N = 256 $，$ X = 0.05 $，$ \\kappa = 2.5 $。\n- 用例 5：$ N = 256 $，$ X = 0.5 $，$ \\kappa = 2.5 $。\n- 用例 6：$ N = 256 $，$ X = 0.95 $，$ \\kappa = 2.5 $。\n- 用例 7：$ N = 128 $，$ X = 0.5 $，$ \\kappa = 1.5 $。\n- 用例 8：$ N = 128 $，$ X = 0.5 $，$ \\kappa = 2.5 $。\n- 用例 9：$ N = 128 $，$ X = 0.5 $，$ \\kappa = 3.5 $。\n\n最终输出格式：\n您的程序应生成包含一个列表的单行输出。前九个条目是九个用例中每一个的列表 $ [E, E_0, E_1] $。其后是四个浮点数 $ p_{0.05} $、$ p_{0.5} $、$ p_{0.95} $ 和 $ q $，顺序如此。例如，\n$$\n[\\,[E_1,E_{0,1},E_{1,1}],\\,[E_2,E_{0,2},E_{1,2}],\\,\\ldots,\\,[E_9,E_{0,9},E_{1,9}],\\,p_{0.05},\\,p_{0.5},\\,p_{0.95},\\,q\\,].\n$$\n所有报告的值必须是无量纲实数。不使用角度。不使用百分比。所有值都表示为标准十进制浮点数。", "solution": "用户在数值分析领域提供了一个定义明确的问题，用于验证浸入边界 (IB) 方法的离散化。验证证实了该问题在科学上是合理的、适定的，并且提供了求解所需的所有必要组件。该任务要求实现一个特定的算法并进行收敛性研究。\n\n解决方案的结构如下：\n1.  **方法论概述**：将人工解方法应用于 IB 方法核心的离散卷积算子的方法摘要。\n2.  **域和积分的离散化**：对非均匀欧拉网格以及用于数值积分的复合梯形法则的描述。\n3.  **离散 Delta 函数的构造**：解释构造离散 delta 函数权重 $W_i$ 的过程，包括使用正则化核函数和必要的矩校正步骤。\n4.  **误差分析和收敛性度量**：定义用于评估数值方案准确性和行为的误差量 ($E, E_0, E_1$) 和收敛性度量 ($p_X, q$)。\n5.  **算法实现**：简述如何将这些数学步骤转化为计算算法，以解决给定测试套件的问题。\n\n**1. 方法论概述**\n该问题采用人工解方法来验证离散卷积算子的实现。该算子是浸入边界 (IB) 和其他虚拟区域方法的基础，用于在拉格朗日标记点和欧拉网格之间传递物理量（例如，力、速度）。验证基于狄拉克 delta 分布的一个关键性质，$\\int f(x)\\delta(x-X)dx = f(X)$。在数值计算的背景下，我们用一个正则化核函数 $\\delta_{\\varepsilon}$ 替换奇异的 $\\delta$，并用计算网格上的离散求和来代替积分：\n$$\n\\sum_{i=0}^{N} f(x_i) W_i \\Delta x_i \\approx f(X)\n$$\n这里，$f(x)$ 是一个已知的光滑“人工”函数，$x_i$ 是网格点，$\\Delta x_i$ 是求积权重，$W_i$ 是离散 delta 函数的权重。此近似的准确性是离散化一致性的直接度量。\n\n**2. 域和积分的离散化**\n该问题指定了一个一维域 $x \\in [0,1]$。此域使用强非均匀网格进行离散化。网格节点 $x_i$ 对于 $i=0, 1, \\ldots, N$ 定义为：\n$$\nx_i = \\left(\\frac{i}{N}\\right)^3\n$$\n这种网格选择导致在 $x=0$ 附近点的高度集中，而在 $x=1$ 附近分布稀疏，为数值方案的鲁棒性提供了一个具有挑战性的测试。\n\n在这个非均匀网格上的积分使用离散求和来近似，其权重源自复合梯形法则。对于一个函数 $g(x)$，积分 $\\int g(x) dx$ 由 $\\sum_i g(x_i) \\Delta x_i$ 近似，其中权重 $\\Delta x_i$ 为：\n$$\n\\Delta x_0 = \\frac{x_1 - x_0}{2}, \\quad \\Delta x_N = \\frac{x_N - x_{N-1}}{2}, \\quad \\Delta x_i = \\frac{x_{i+1} - x_{i-1}}{2} \\text{ for } i=1, \\ldots, N-1.\n$$\n这些权重代表与每个网格节点 $x_i$ 相关联的体元。\n\n**3. 离散 Delta 函数的构造**\n离散 delta 权重 $W_i$ 由连续的四点 Peskin 核函数 $\\phi(s)$ 构造。正则化 delta 函数 $\\delta_{\\varepsilon}(x-X)$ 定义为 $\\frac{1}{\\varepsilon}\\phi(\\frac{x-X}{\\varepsilon})$，其中 $\\varepsilon$ 是控制其支集范围的核宽度。\n\n仅仅通过对核函数进行采样来进行的朴素离散化，$w_i = \\delta_{\\varepsilon}(x_i-X)$，并不能保证得到的离散算子在非均匀网格上满足关键的矩条件。也就是说，通常情况下 $\\sum_i w_i \\Delta x_i \\neq 1$ 且 $\\sum_i (x_i-X)w_i \\Delta x_i \\neq 0$。为确保方案具有所需的准确性和守恒性质，应用了以下校正程序：\n1.  **原始权重**：在网格点上对核函数进行采样以获得原始权重，$w_i = \\frac{1}{\\varepsilon}\\phi(\\frac{x_i - X}{\\varepsilon})$。\n2.  **零阶矩校正**：对权重进行归一化，以确保离散和为1（即，它能精确地对常数函数进行积分）。归一化常数为 $c_0 = \\sum_{i} w_i \\Delta x_i$，校正后的权重为 $W_i^{(0)} = w_i / c_0$。\n3.  **一阶矩校正**：引入一个线性校正项 $1 + \\alpha(x_i-X)$，以强制满足离散一阶矩条件。$W^{(0)}$ 的一阶矩计算为 $m_1 = \\sum_{i} (x_i-X)W_i^{(0)}\\Delta x_i$。选择系数 $\\alpha$ 以抵消此矩，得到 $\\alpha = -m_1/\\mu_2$，其中 $\\mu_2 = \\sum_i (x_i-X)^2 W_i^{(0)} \\Delta x_i$ 是二阶矩。新的权重为 $\\widetilde{W}_i = W_i^{(0)}(1+\\alpha(x_i-X))$。\n4.  **重新归一化**：一阶矩校正会改变零阶矩。应用最终的重新归一化来恢复它。最终的权重为 $W_i = \\widetilde{W}_i / \\sum_j \\widetilde{W}_j \\Delta x_j$。这些最终的权重 $W_i$ 在机器精度范围内满足离散的零阶和一阶矩条件。\n\n**4. 误差分析和收敛性度量**\n通过几个度量标准来评估近似的质量：\n-   **插值误差 ($E$)**：准确性的主要度量是绝对误差 $E = \\left|\\sum_{i=0}^{N} f(x_i)W_i\\Delta x_i - f(X)\\right|$。\n-   **矩误差 ($E_0, E_1$)**：为了验证校正程序的成功，我们计算零阶矩误差 $E_0 = \\left|1 - \\sum_i W_i \\Delta x_i\\right|$ 和一阶矩误差 $E_1 = \\left|\\sum_i (x_i - X) W_i \\Delta x_i\\right|$。这些值应接近浮点零。\n\n收敛性研究调查了当离散化参数被细化时，误差 $E$ 的行为。\n-   **局部网格间距 ($h$)**：随着网格变得更细，误差预计会减小。局部网格间距 $h$ 在拉格朗日点 $X$ 处定义为最近网格节点 $x_j$ 的梯形权重 $\\Delta x_j$。对于固定的比率 $\\kappa = \\varepsilon/h$，收敛阶 $p_X$ 计算为 $p_X = \\frac{\\log(E_{\\text{coarse}}/E_{\\text{fine}})}{\\log(h_{\\text{coarse}}/h_{\\text{fine}})}$，它决定了误差随 $h$ 减小的速率。\n-   **核宽度 ($\\varepsilon$)**：对于固定网格，误差也取决于核宽度 $\\varepsilon = \\kappa h$。该问题通过假设幂律关系 $E \\propto \\varepsilon^q$ 来研究误差随 $\\varepsilon$ 的缩放行为。指数 $q$ 通过对 $E$ 与 $\\varepsilon$ 的对数-对数图进行线性回归来确定。\n\n**5. 算法实现**\n解决方案以 Python 脚本的形式实现。一个主函数为九个测试用例中的每一个协调整个过程。对于每个用例，它构造网格，计算求积权重和核函数权重，执行矩校正，并计算误差 $E, E_0,$ 和 $E_1$。结果被存储起来。处理完所有用例后，从存储的结果中计算收敛性度量 ($p_{0.05}, p_{0.5}, p_{0.95}, q$)。最后，将收集到的数据格式化为单个列表并按规定打印。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the manufactured solution verification for an Immersed Boundary discretization\n    as specified in the problem statement.\n    \"\"\"\n\n    def phi(s: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes the Peskin four-point regularized delta kernel.\n        \"\"\"\n        s_abs = np.abs(s)\n        result = np.zeros_like(s, dtype=float)\n\n        # Case 1: |s| = 1\n        mask1 = s_abs = 1\n        s_abs_1 = s_abs[mask1]\n        arg_sqrt1 = 1 + 4 * s_abs_1 - 4 * s_abs_1**2\n        arg_sqrt1[arg_sqrt1  0] = 0  # Avoid numerical issues\n        result[mask1] = (1/8) * (3 - 2 * s_abs_1 + np.sqrt(arg_sqrt1))\n\n        # Case 2: 1  |s| = 2\n        mask2 = (s_abs > 1)  (s_abs = 2)\n        s_abs_2 = s_abs[mask2]\n        arg_sqrt2 = -7 + 12 * s_abs_2 - 4 * s_abs_2**2\n        arg_sqrt2[arg_sqrt2  0] = 0  # Avoid numerical issues\n        result[mask2] = (1/8) * (5 - 2 * s_abs_2 - np.sqrt(arg_sqrt2))\n\n        return result\n\n    def manufactured_f(x: float or np.ndarray) -> float or np.ndarray:\n        \"\"\"\n        Computes the manufactured smooth function.\n        \"\"\"\n        return np.sin(2 * np.pi * x) + x**2\n\n    def calculate_errors_and_h(N: int, X: float, kappa: float) -> tuple:\n        \"\"\"\n        Performs the main calculation for a given test case.\n        \"\"\"\n        # 1. Generate non-uniform mesh\n        i_indices = np.arange(N + 1)\n        x_nodes = (i_indices / N)**3\n\n        # 2. Compute composite trapezoidal-rule weights\n        delta_x = np.zeros(N + 1)\n        delta_x[0] = (x_nodes[1] - x_nodes[0]) / 2\n        delta_x[N] = (x_nodes[N] - x_nodes[N-1]) / 2\n        delta_x[1:N] = (x_nodes[2:] - x_nodes[:-2]) / 2\n\n        # 3. Define local grid spacing h and kernel width epsilon\n        j_nearest = np.argmin(np.abs(x_nodes - X))\n        h = delta_x[j_nearest]\n        epsilon = kappa * h\n\n        # 4. Compute raw weights\n        s = (x_nodes - X) / epsilon\n        w_raw = (1 / epsilon) * phi(s)\n\n        # 5. Normalize zeroth moment\n        c0 = np.sum(w_raw * delta_x)\n        W0 = w_raw / c0 if c0 != 0 else np.zeros_like(w_raw)\n\n        # 6. Enforce first-moment condition\n        x_minus_X = x_nodes - X\n        m1 = np.sum(x_minus_X * W0 * delta_x)\n        mu2 = np.sum(x_minus_X**2 * W0 * delta_x)\n        alpha = -m1 / mu2 if mu2 != 0 else 0\n        W_tilde = W0 * (1 + alpha * x_minus_X)\n\n        # 7. Renormalize to preserve zeroth moment\n        c0_tilde = np.sum(W_tilde * delta_x)\n        W_final = W_tilde / c0_tilde if c0_tilde != 0 else np.zeros_like(W_tilde)\n\n        # 8. Compute errors\n        I_f = np.sum(manufactured_f(x_nodes) * W_final * delta_x)\n        f_at_X = manufactured_f(X)\n        E = np.abs(I_f - f_at_X)\n        \n        E0 = np.abs(1 - np.sum(W_final * delta_x))\n        \n        E1 = np.abs(np.sum(x_minus_X * W_final * delta_x))\n        \n        return E, E0, E1, h\n\n    test_cases = [\n        (64, 0.05, 2.5), (64, 0.5, 2.5), (64, 0.95, 2.5),\n        (256, 0.05, 2.5), (256, 0.5, 2.5), (256, 0.95, 2.5),\n        (128, 0.5, 1.5), (128, 0.5, 2.5), (128, 0.5, 3.5),\n    ]\n\n    all_case_results = []\n    # A dictionary to store results for convergence analysis, keyed by (N, X, kappa)\n    analysis_data = {}\n\n    for N, X, kappa in test_cases:\n        E, E0, E1, h = calculate_errors_and_h(N, X, kappa)\n        all_case_results.append([E, E0, E1])\n        analysis_data[(N, X, kappa)] = {'E': E, 'h': h}\n\n    # --- Convergence Analysis ---\n\n    # Calculate observed order p_X for X in {0.05, 0.5, 0.95}\n    p_values = []\n    for X_val in [0.05, 0.5, 0.95]:\n        kappa_val = 2.5\n        E_64 = analysis_data[(64, X_val, kappa_val)]['E']\n        h_64 = analysis_data[(64, X_val, kappa_val)]['h']\n        E_256 = analysis_data[(256, X_val, kappa_val)]['E']\n        h_256 = analysis_data[(256, X_val, kappa_val)]['h']\n        \n        # Avoid division by zero in log\n        if E_64 == 0 or E_256 == 0 or h_64 == h_256:\n            p = float('nan')\n        else:\n            p = np.log(E_64 / E_256) / np.log(h_64 / h_256)\n        p_values.append(p)\n    \n    p_005, p_05, p_095 = p_values\n\n    # Calculate scaling exponent q\n    N_q, X_q = 128, 0.5\n    kappas_q = np.array([1.5, 2.5, 3.5])\n    errors_q = np.array([analysis_data[(N_q, X_q, k)]['E'] for k in kappas_q])\n    \n    # h is constant for fixed N and X\n    h_q = analysis_data[(N_q, X_q, kappas_q[0])]['h']\n    epsilons_q = kappas_q * h_q\n    \n    log_E = np.log(errors_q)\n    log_eps = np.log(epsilons_q)\n    \n    # Linear regression: log(E) = a + q*log(eps)\n    # np.polyfit returns [slope, intercept] for degree 1\n    q = np.polyfit(log_eps, log_E, 1)[0]\n    \n    # --- Final Output Formatting ---\n    final_output_list = all_case_results + [p_005, p_05, p_095, q]\n    \n    print(final_output_list)\n\nsolve()\n```", "id": "3510132"}]}