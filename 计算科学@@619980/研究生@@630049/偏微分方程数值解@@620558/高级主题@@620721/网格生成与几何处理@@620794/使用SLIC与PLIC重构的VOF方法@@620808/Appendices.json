{"hands_on_practices": [{"introduction": "流体体积（VOF）方法的核心在于追踪和推进流体界面。这个过程的第一步，也是最基本的一步，是根据每个计算单元内部重建的界面来计算跨越单元边界的流体通量。本练习将通过一个简化的二维场景，指导您使用简单线性界面计算（SLIC）方法来完成这一关键任务。通过亲手计算流体通量，您将深入理解VOF平流算法的基本机制，并为掌握更复杂的界面重构方法奠定坚实的基础。", "problem": "考虑一种由流体体积法 (VOF) 指示函数表示的二元流体的二维不可压缩平流。设指示函数表示为 $H(x,y,t)$，其中在液体中 $H=1$，在气体中 $H=0$。单元格中的 VOF 体积分数为 $C=\\frac{1}{\\Delta x\\,\\Delta y}\\iint_{\\text{cell}} H(x,y,t)\\,dx\\,dy$。在时间间隔 $[t^n,t^{n}+\\Delta t]$ 内，使用均匀、恒定的速度场 $u0$ 执行一个 $x$ 方向的算子分裂平流步，其中 Courant–Friedrichs–Lewy (CFL) 数 $\\lambda = \\dfrac{u\\,\\Delta t}{\\Delta x}$ 是预先设定的。\n\n考虑一个 $2\\times 2$ 的方形笛卡尔单元格块，其尺寸为 $\\Delta x=\\Delta y=1.0\\,\\text{m}$。列的索引为 $i=0$ (左) 和 $i=1$ (右)，行的索引为 $j=1$ (底) 和 $j=2$ (顶)。中央垂直面是位于 $x=\\Delta x$ 处的面，它分隔左右两列并横跨两行。在时间 $t^n$ 时的 VOF 值为：\n- 左列中为 $C_{0,1}=0.85$，$C_{0,2}=0.75$，\n- 右列中为 $C_{1,1}=0.10$，$C_{1,2}=0.00$。\n\n在 $x$ 方向扫描期间，采用简单线性界面计算 (SLIC) 重构：在每个单元格中，界面被近似为一个垂直线段，液体区域是一个宽度为 $s_j=C_{0,j}\\,\\Delta x$ 的连续垂直板，对于 $u0$ 的情况，该垂直板附着于上风 (左) 面，且每行 $j$ 都是独立的。\n\nCFL 数给出为 $\\lambda=\\dfrac{u\\,\\Delta t}{\\Delta x}=0.35$。仅使用所述的假设和定义，确定在时间步长 $\\Delta t$ 内，通过中央垂直面输运的、由简单线性界面计算 (SLIC) 预测的每单位深度的总液体体积（即，穿过该面的时间积分通量），并对两行的贡献求和。用平方米每单位深度表示你的最终答案，并将结果四舍五入到四位有效数字。", "solution": "用户希望我解决一个与流体体积法 (VOF) 相关的流体动力学问题。\n\n这是我的计划：\n1.  **验证问题陈述。** 我会将问题分解为其给定组件，并检查其科学合理性、完整性和清晰度。\n2.  **理解核心概念。**\n    *   **VOF 方法：** 一种用于追踪和定位自由表面或流体-流体界面的数值技术。它使用一个标量函数，即 VOF 体积分数 `C`，表示计算单元格中被其中一种流体填充的比例。\n    *   **算子分裂：** 将多维平流方程分解为一系列一维平流问题。在这里，我们只关心 `x` 方向的扫描。\n    *   **SLIC (简单线性界面计算)：** 一种根据单元格的 VOF 体积分数 `C` 重构其内部界面的特定方法。问题明确说明了如何应用 SLIC：界面是一条垂直线，流体形成一个附着在上风面的垂直板。\n    *   **通量计算：** 目标是求出在一个时间步长内穿过特定面的总液体体积。这就是时间积分通量。\n\n3.  **逐步解构问题。**\n    *   **问题设置：**\n        *   二维，不可压缩平流。\n        *   VOF 指示函数 `H`。\n        *   单元格中的 VOF 体积分数 `C`。\n        *   `x` 方向算子分裂平流步。\n        *   均匀、恒定的速度 `u  0`。\n        *   时间间隔 `[t^n, t^n + Δt]`。\n        *   CFL 数：`λ = u * Δt / Δx = 0.35`。\n        *   网格：2x2 方形单元格块。\n        *   单元格尺寸：`Δx = Δy = 1.0 m`。\n        *   单元格索引：`i` 代表列 (0, 1)，`j` 代表行 (1, 2)。\n        *   `t^n` 时的 VOF 值：\n            *   `C_{0,1} = 0.85`\n            *   `C_{0,2} = 0.75`\n            *   `C_{1,1} = 0.10`\n            *   `C_{1,2} = 0.00`\n        *   目标面：位于 `x = Δx` 的中央垂直面。这是单元格 `(0,j)` 和 `(1,j)` 之间的界面。\n    *   **SLIC 重构：**\n        *   问题指定了*上风*单元格的重构，因为 `u  0`，所以这些是 `i=0` 列中的单元格。\n        *   对每行 `j`，单元格 `(0,j)` 中的界面是一条垂直线段。\n        *   液体区域是一个宽度为 `s_j = C_{0,j} * Δx` 的连续垂直板。\n        *   该板附着于单元格的上风（左）面。\n    *   **通量计算：**\n        *   在时间步长 `Δt` 内，从单元格 `(0,j)` 平流到单元格 `(1,j)` 的流体量是单元格 `(0,j)` 中穿过 `x = Δx` 面的流体体积。\n        *   平流距离为 `u * Δt`。\n        *   CFL 数 `λ = u * Δt / Δx` 将此距离表示为单元格宽度的分数：`u * Δt = λ * Δx`。\n        *   将被平流过面的体积是包含在一个宽度为 `u * Δt`、高度为 `Δy` 的“通量盒”中的体积，该通量盒位于上风单元格的下风侧。\n        *   我需要计算每行 `j` 在此通量盒内的液体体积，然后将它们相加。\n\n4.  **执行计算。**\n    *   **单元格几何形状：**\n        *   `Δx = 1.0`\n        *   `Δy = 1.0`\n    *   **平流距离：**\n        *   `λ = 0.35`\n        *   平流距离 `d = u * Δt = λ * Δx = 0.35 * 1.0 = 0.35`。\n    *   **考虑行 `j=1`：**\n        *   上风单元格是 `(0,1)`。VOF 体积分数为 `C_{0,1} = 0.85`。\n        *   SLIC 重构：液体形成一个宽度为 `s_1 = C_{0,1} * Δx = 0.85 * 1.0 = 0.85` 的垂直板。\n        *   该板附着于单元格的左面，因此它占据了单元格 `(0,1)` 内的 `0 ≤ x  0.85` 区域（假设单元格跨越 `0 ≤ x ≤ Δx=1`）。\n        *   “通量盒”是将在 `x=Δx=1` 处穿过界面的区域。这是上风单元格 `(0,1)` 内的区域 `(Δx - u*Δt) ≤ x  Δx`。\n        *   通量盒是 `(1.0 - 0.35) ≤ x  1.0`，即单元格 `(0,1)` 右边缘处一个宽度为 `0.35` 的区域。\n        *   现在我需要找出这个通量盒中有多少被液体填充。\n        *   液体板从 `x=0` 到 `x=0.85`。\n        *   通量盒从 `x=0.65` 到 `x=1.0`。\n        *   液体板和通量盒之间的重叠区域是从 `x=0.65` 到 `x=0.85` 的区域。\n        *   这个重叠区域的宽度是 `0.85 - 0.65 = 0.20`。\n        *   从单元格 `(0,1)` 流出的液体体积是这个重叠宽度乘以单元格高度 `Δy`。\n        *   体积通量 `V_1 = (0.20) * Δy = 0.20 * 1.0 = 0.20`。单位是 `m^2`（每单位深度的体积）。\n    *   **考虑行 `j=2`：**\n        *   上风单元格是 `(0,2)`。VOF 体积分数为 `C_{0,2} = 0.75`。\n        *   SLIC 重构：液体形成一个宽度为 `s_2 = C_{0,2} * Δx = 0.75 * 1.0 = 0.75` 的垂直板。\n        *   该板附着于左面，占据单元格 `(0,2)` 内的 `0 ≤ x  0.75` 区域。\n        *   通量盒和之前一样：区域 `(Δx - u*Δt) ≤ x  Δx`，即 `0.65 ≤ x  1.0`。\n        *   液体板和通量盒之间的重叠区域是从 `x=0.65` 到 `x=0.75` 的区域。\n        *   这个重叠区域的宽度是 `0.75 - 0.65 = 0.10`。\n        *   从单元格 `(0,2)` 流出的液体体积是这个重叠宽度乘以单元格高度 `Δy`。\n        *   体积通量 `V_2 = (0.10) * Δy = 0.10 * 1.0 = 0.10`。单位是 `m^2`。\n    *   **总通量：**\n        *   输运的总液体体积是两行通量的总和。\n        *   `V_{total} = V_1 + V_2 = 0.20 + 0.10 = 0.30`。\n        *   问题要求答案以平方米每单位深度为单位，这正是我计算的单位。\n        *   问题还要求四舍五入到四位有效数字。`0.30` 就是 `0.3000`。\n\n5.  **规范化解题过程。**\n    *   **验证：**\n        *   **已知条件：**\n            *   二维不可压缩平流，二元流体，VOF。\n            *   指示函数 `H(x,y,t)`。\n            *   VOF 体积分数 `C = (1/(Δx Δy)) ∫∫ H dx dy`。\n            *   `x` 方向算子分裂平流。\n            *   速度场 `u  0`，均匀，恒定。\n            *   时间间隔 `[t^n, t^n + Δt]`。\n            *   CFL 数 `λ = u Δt / Δx`。\n            *   网格：2x2，方形单元格，`Δx = Δy = 1.0 m`。\n            *   索引：`i=0,1` (列)，`j=1,2` (行)。\n            *   位于 `x = Δx` 的中央垂直面。\n            *   `t^n` 时的 VOF 值：`C_{0,1}=0.85`, `C_{0,2}=0.75`, `C_{1,1}=0.10`, `C_{1,2}=0.00`。\n            *   SLIC 重构：界面为垂直线段，液体为宽度是 `s_j = C_{0,j} Δx` 的板，对每行 `j` 都附着于上风（左）面。\n            *   CFL 数值：`λ = 0.35`。\n            *   任务：确定在 `Δt` 内通过中央垂直面输运的每单位深度的总液体体积。\n        *   **验证检查：**\n            *   _科学依据_: 是的，这是计算流体动力学中的一个标准问题，特别是在使用 VOF 方法进行多相流模拟的背景下。相关概念（VOF、算子分裂、SLIC、CFL 条件）都已相当成熟。\n            *   _适定性_: 是的，所有必要信息都已提供，可以计算出唯一答案。问题是自洽的。\n            *   _客观性_: 是的，语言精确且专业。没有主观元素。\n            *   _无缺陷_: 问题没有违反任何无效标准。这是一个教科书式的练习题。\n        *   **结论：** 问题有效。\n\n    *   **求解推导：**\n        *   让我们定义两个上风单元格的计算域。对于给定的行 `j`，单元格 `(0,j)` 占据空间 `0 \\le x \\le \\Delta x`。在此一维扫描中，各行是独立的。\n        *   在时间步长 `\\Delta t` 内将要平流过 `x=\\Delta x` 面的流体体积，来源于上风单元格 `(0,j)` 下风侧的一个“通量体积”或“通量盒”。\n        *   这个通量盒的宽度是平流距离 `d = u \\Delta t`。\n        *   根据 CFL 数的定义，`d = u \\Delta t = \\lambda \\Delta x`。\n        *   单元格 `(0,j)` 的通量盒占据区域 `\\Delta x - d \\le x \\le \\Delta x`。\n        *   输运的液体体积 `\\mathcal{F}_j` 是指示函数 `H` 在此通量盒上的积分。\n        *   `\\mathcal{F}_j = \\int_{t^n}^{t^n+\\Delta t} \\int_{j\\Delta y - \\Delta y}^{j\\Delta y} u H(x,y,\\tau)|_{x=\\Delta x} \\, dy \\, d\\tau`。对于恒定的 `u` 和在 `\\Delta t` 上的冻结场假设，这等价于 `\\int_{\\Delta x - u\\Delta t}^{\\Delta x} \\int_{y_{\\text{bottom}}}^{y_{\\text{top}}} H(x,y,t^n) \\, dy \\, dx`。\n        *   让我们使用更简单直接的几何解释。平流的液体体积就是通量盒内的液体体积。\n        *   单元格 `(0,j)` 的 SLIC 重构将液体区域定义为一个宽度为 `s_j = C_{0,j} \\Delta x` 的垂直板，附着于左侧面 `x=0`。因此，在单元格 `(0,j)` 内，当 `0 \\le x \\le s_j` 时 `H(x,y,t^n)=1`，当 `s_j  x \\le \\Delta x` 时 `H=0`。\n        *   通量体积 `\\mathcal{V}_j`（每单位深度）是液体区域和通量盒区域交集的面积。\n        *   液体区域 `L_j`: `[0, s_j] \\times [y_{\\text{cell_bottom}}, y_{\\text{cell_top}}]`。\n        *   通量盒区域 `B`: `[\\Delta x - \\lambda \\Delta x, \\Delta x] \\times [y_{\\text{cell_bottom}}, y_{\\text{cell_top}}]`。\n        *   输运的体积是 `x` 区间 `[0, s_j]` 和 `[\\Delta x - \\lambda \\Delta x, \\Delta x]` 交集的面积乘以单元格高度 `\\Delta y`。\n        *   交集宽度：`w_j = \\max(0, \\min(\\Delta x, s_j) - \\max(0, \\Delta x - \\lambda \\Delta x))`。由于 `s_j \\le \\Delta x`，这可以简化为 `w_j = \\max(0, s_j - (\\Delta x - \\lambda \\Delta x))`。\n        *   `w_j = \\max(0, C_{0,j} \\Delta x - \\Delta x(1-\\lambda)) = \\Delta x \\max(0, C_{0,j} - (1-\\lambda))`。\n        *   第 `j` 行的平流体积为 `\\mathcal{V}_j = w_j \\Delta y = \\Delta x \\Delta y \\max(0, C_{0,j} - 1 + \\lambda)`。\n\n    *   **将公式应用于给定数据：**\n        *   `\\Delta x = 1.0` m, `\\Delta y = 1.0` m。\n        *   `\\lambda = 0.35`。\n        *   `1 - \\lambda = 1 - 0.35 = 0.65`。\n        *   **对于行 `j=1`：**\n            *   `C_{0,1} = 0.85`。\n            *   `\\mathcal{V}_1 = (1.0)(1.0) \\max(0, 0.85 - 1 + 0.35) = \\max(0, 0.85 - 0.65) = \\max(0, 0.20) = 0.20` m$^2$。\n        *   **对于行 `j=2`：**\n            *   `C_{0,2} = 0.75`。\n            *   `\\mathcal{V}_2 = (1.0)(1.0) \\max(0, 0.75 - 1 + 0.35) = \\max(0, 0.75 - 0.65) = \\max(0, 0.10) = 0.10` m$^2$。\n        *   **总输运体积：**\n            *   `\\mathcal{V}_{\\text{total}} = \\mathcal{V}_1 + \\mathcal{V}_2 = 0.20 + 0.10 = 0.30` m$^2$。\n        *   **四舍五入：** 结果必须四舍五入到四位有效数字。\n            *   `0.3000`。\n\n    *   **最终复核：**\n        *   我的手动计算与推导出的公式相符。\n        *   对于这类问题，“通量盒”和“SLIC 重构”的解释是标准的。\n        *   逻辑是合理的。上风单元格（`i=0`）中的流体向右移动。穿过边界 `x=\\Delta x` 的量是包含在单元格最右侧 `u \\Delta t` 切片中的流体。\n        *   这个切片的宽度是 `\\lambda \\Delta x = 0.35 \\times 1.0 = 0.35`。所以我们关心的是区间 `x \\in [1.0 - 0.35, 1.0] = [0.65, 1.0]` 内的流体。\n        *   对于行 `j=1`，`C_{0,1}=0.85`。流体板的宽度为 `0.85`，占据 `x \\in [0, 0.85]`。`[0, 0.85]` 和 `[0.65, 1.0]` 的交集是 `[0.65, 0.85]`，其长度为 `0.20`。每单位深度的体积是 `0.20 \\times \\Delta y = 0.20 \\times 1.0 = 0.20`。\n        *   对于行 `j=2`，`C_{0,2}=0.75`。流体板的宽度为 `0.75`，占据 `x \\in [0, 0.75]`。`[0, 0.75]` 和 `[0.65, 1.0]` 的交集是 `[0.65, 0.75]`，其长度为 `0.10`。每单位深度的体积是 `0.10 \\times \\Delta y = 0.10 \\times 1.0 = 0.10`。\n        *   总体积是 `0.20 + 0.10 = 0.30`。\n        *   最终答案需要是 `0.3000`。\n        *   格式规则是严格的。所有数学公式使用 LaTeX。没有 markdown 标题。XML 标签。最终答案放在方框内。结构是固定的。\n        *   问题是关于“偏微分方程数值解”领域中的“带 SLIC 和 PLIC 重构的流体体积法”。问题正是关于这个主题，所以不是不相关的。\n        *   问题并非故作高深。它是对定义的直接应用。\n        *   一切看起来都很好。我现在将遵循所有规则来编写解决方案。", "answer": "$$\n\\boxed{0.3000}\n$$", "id": "3461623"}, {"introduction": "在掌握了如何使用给定的界面来计算通量之后 ([@problem_id:3461623])，一个自然而然的问题是：这个界面本身是如何确定的？对于更精确的分段线性界面计算（PLIC）方法而言，其核心在于一个精巧的几何反问题。本练习将引导您深入PLIC方法的心脏，通过编写一个程序来求解给定法向量 $\\mathbf{n}$ 和流体体积分数 $C$ 时，确定界面截距 $\\alpha$ 的值。这不仅能让您掌握PLIC重构的关键算法，还能提升您在计算几何和数值求解方面的实践能力。", "problem": "给定一个在单个单位单元内的二维流体体积（VOF）重构问题。在分段线性界面计算（PLIC）中，重构的界面由一条直线表示，该直线通过隐式方程 $\\mathbf{n}\\cdot\\mathbf{x}=\\alpha$ 定义，其法向量为 $\\mathbf{n}\\in\\mathbb{R}^2$，截距参数为 $\\alpha\\in\\mathbb{R}$。液体区域被定义为半空间 $\\{\\mathbf{x}\\in[0,1]^2:\\mathbf{n}\\cdot\\mathbf{x}\\le \\alpha\\}$。单位单元中的液体体积分数 $C$ 是该半空间与单位正方形相交区域的面积除以单元面积。在简单线性界面计算（SLIC）中，重构被限制为轴对齐的切割，这是上述情况中 $\\mathbf{n}$ 与某个坐标轴对齐时的一种特例。\n\n从第一性原理和核心定义出发：\n- 单位正方形中的VOF分数 $C$ 是区域 $\\{\\mathbf{x}\\in[0,1]^2:\\mathbf{n}\\cdot\\mathbf{x}\\le \\alpha\\}$ 的面积。\n- 对于任意固定的非零 $\\mathbf{n}$，面积函数 $A(\\alpha):=\\text{area}(\\{\\mathbf{x}\\in[0,1]^2:\\mathbf{n}\\cdot\\mathbf{x}\\le \\alpha\\})$ 是关于 $\\alpha$ 的连续非递减函数。\n- 线性泛函 $\\mathbf{n}\\cdot\\mathbf{x}$ 在凸多边形 $[0,1]^2$ 上的最小值和最大值出现在其顶点处，因此 $\\alpha$ 的物理相关范围是 $[\\alpha_{\\min},\\alpha_{\\max}]$，其中 $\\alpha_{\\min}=\\min_{\\mathbf{v}\\in\\{(0,0),(1,0),(1,1),(0,1)\\}}\\mathbf{n}\\cdot\\mathbf{v}$ 且 $\\alpha_{\\max}=\\max_{\\mathbf{v}\\in\\{(0,0),(1,0),(1,1),(0,1)\\}}\\mathbf{n}\\cdot\\mathbf{v}$。它们满足 $A(\\alpha_{\\min})=0$ 和 $A(\\alpha_{\\max})=1$。\n- VOF重构的约束条件是 $A(\\alpha)=C$。\n\n您的任务是实现一个程序，对每个测试用例，计算出满足 $A(\\alpha)=C$ 的相应截距参数 $\\alpha$。您必须通过计算单位正方形被半空间 $\\mathbf{n}\\cdot\\mathbf{x}\\le \\alpha$ 裁剪后所得多边形的面积来精确计算 $A(\\alpha)$；不要使用任何预制表格公式或简化表达式。您应该使用一个鲁棒的多边形-半空间裁剪程序，并在区间 $[\\alpha_{\\min},\\alpha_{\\max}]$ 上采用一种利用 $A(\\alpha)$ 单调性的求根方法，例如二分法。对于边界情况 $C=0$ 或 $C=1$，为确保唯一性，应分别返回 $\\alpha=\\alpha_{\\min}$ 和 $\\alpha=\\alpha_{\\max}$。\n\n要求：\n- 每个测试的输入包含一个法向量 $\\mathbf{n}=(n_x,n_y)$（其中 $n_x$ 和 $n_y$ 是可为正、负或零的实数）和一个目标体积分数 $C\\in[0,1]$。\n- 您必须按照上述描述计算满足 $A(\\alpha)=C$ 的 $\\alpha$，并报告其四舍五入到三位有效数字的结果。\n- 问题不涉及角度。问题中没有物理单位。\n- 算法必须对任意非零 $\\mathbf{n}$（不要求是单位向量）都有效。\n\n测试套件：\n对于以下每个测试用例，计算并输出四舍五入到三位有效数字的 $\\alpha$ 值，使用标准的四舍五入规则，当平局时向远离零的方向取整。这六个用例是：\n1. $\\mathbf{n}=(0.6,0.8)$, $C=0.65$。\n2. $\\mathbf{n}=(1.0,0.0)$, $C=0.3$。\n3. $\\mathbf{n}=(0.0,-1.0)$, $C=0.3$。\n4. $\\mathbf{n}=(-0.6,0.8)$, $C=0.25$。\n5. $\\mathbf{n}=(-1.0,-2.0)$, $C=0.0$。\n6. $\\mathbf{n}=(0.2,-0.7)$, $C=1.0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个数字都应四舍五入到三位有效数字，并以定点表示法（无指数表示法）表示。例如，一个有效的输出应类似于“[0.820,0.300,-0.700,-0.110,-3.00,0.200]”。", "solution": "该问题定义明确，要求开发一个数值程序来求解一条直线的截距参数 $\\alpha$，该直线将一个单位正方形分割成两个具有特定面积比的区域。在流体体积（VOF）方法，特别是分段线性界面计算（PLIC）的背景下，这是一个基本的几何问题。\n\n问题要求对于给定的法向量 $\\mathbf{n} \\in \\mathbb{R}^2$ 和体积分数 $C \\in [0,1]$，找到 $\\alpha \\in \\mathbb{R}$，使得区域 $\\{\\mathbf{x} \\in [0,1]^2 : \\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha\\}$ 的面积等于 $C$。由于单位单元 $[0,1]^2$ 的面积为 1，这个面积在数值上等于体积分数 $C$。\n\n我们将面积函数 $A(\\alpha)$ 定义为：\n$$A(\\alpha) = \\text{area}(\\{\\mathbf{x} \\in [0,1]^2 : \\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha\\})$$\n我们的目标是求解方程 $A(\\alpha) = C$ 以得到 $\\alpha$。\n\n**1. 面积函数的性质与二分法**\n\n函数 $\\mathbf{n} \\cdot \\mathbf{x}$ 是 $\\mathbb{R}^2$ 上的一个线性泛函。区域 $\\{\\mathbf{x} : \\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha\\}$ 是一个半平面。随着 $\\alpha$ 的增加，这个半平面会扩张，因此它与固定单位正方形的交集面积 $A(\\alpha)$ 是一个关于 $\\alpha$ 的连续且单调非递减的函数。\n\n线性泛函 $\\mathbf{n} \\cdot \\mathbf{x}$ 在凸集 $[0,1]^2$ 上的最小值和最大值出现在其顶点处，即 $\\mathbf{v}_1=(0,0)$、$\\mathbf{v}_2=(1,0)$、$\\mathbf{v}_3=(1,1)$ 和 $\\mathbf{v}_4=(0,1)$。我们定义：\n$$\\alpha_{\\min} = \\min_{i \\in \\{1,2,3,4\\}} (\\mathbf{n} \\cdot \\mathbf{v}_i)$$\n$$\\alpha_{\\max} = \\max_{i \\in \\{1,2,3,4\\}} (\\mathbf{n} \\cdot \\mathbf{v}_i)$$\n对于任意 $\\alpha  \\alpha_{\\min}$，半平面与单位正方形不相交，因此 $A(\\alpha) = 0$。对于任意 $\\alpha  \\alpha_{\\max}$，半平面完全包含单位正方形，因此 $A(\\alpha) = 1$。所以，$\\alpha$ 的相关范围是 $[\\alpha_{\\min}, \\alpha_{\\max}]$。\n\n$A(\\alpha)$ 在 $[\\alpha_{\\min}, \\alpha_{\\max}]$ 上的单调性使得二分法成为求解 $A(\\alpha) - C = 0$ 的理想选择。\n算法如下：\n1.  建立搜索区间 $[\\alpha_{low}, \\alpha_{high}] = [\\alpha_{\\min}, \\alpha_{\\max}]$。\n2.  如果目标体积分数 $C$ 为 $0$ 或 $1$，根据规定，解分别为 $\\alpha = \\alpha_{\\min}$ 或 $\\alpha = \\alpha_{\\max}$。\n3.  对于 $C \\in (0,1)$，重复对分区间：\n    a. 计算中点 $\\alpha_{mid} = (\\alpha_{low} + \\alpha_{high})/2$。\n    b. 计算面积 $A_{mid} = A(\\alpha_{mid})$。\n    c. 如果 $A_{mid}  C$，根必在区间的上半部分，因此我们设置 $\\alpha_{low} = \\alpha_{mid}$。\n    d. 如果 $A_{mid} \\ge C$，根必在区间的下半部分，因此我们设置 $\\alpha_{high} = \\alpha_{mid}$。\n4.  此过程迭代足够多次（例如100次）以达到高精度。$\\alpha$ 的最终估计值为最终区间的中点。\n\n**2. 面积 $A(\\alpha)$ 的几何计算**\n\n问题的核心是对于给定的 $\\alpha$ 计算 $A(\\alpha)$。这涉及两个计算几何步骤：用半空间裁剪多边形，以及计算所得多边形的面积。\n\n**2.1. 多边形裁剪**\n区域 $\\{\\mathbf{x} \\in [0,1]^2 : \\mathbf{n} \\cdot \\mathbf{x} \\le \\alpha\\}$ 是一个凸多边形。其顶点通过用直线 $\\mathbf{n} \\cdot \\mathbf{x} = \\alpha$ 定义的半空间裁剪单位正方形来找到。Sutherland-Hodgman算法是完成此任务的鲁棒方法。\n\n该算法针对裁剪线处理主体多边形（单位正方形）的每条边。对于从顶点 $S$ 到顶点 $P$ 的一条边：\n- 如果 $S$ 和 $P$ 都在半空间内部（$\\mathbf{n}\\cdot\\mathbf{x} - \\alpha \\le 0$），则将顶点 $P$ 添加到输出顶点列表中。\n- 如果 $S$ 在内部而 $P$ 在外部，则计算它们与直线 $\\mathbf{n}\\cdot\\mathbf{x} = \\alpha$ 的交点，并将其添加到输出列表中。\n- 如果 $S$ 和 $P$ 都在外部，则不添加任何顶点。\n- 如果 $S$ 在外部而 $P$ 在内部，则先添加它们的交点，然后添加顶点 $P$。\n\n点 $S$ 和 $P$ 之间的线段与直线 $\\mathbf{n} \\cdot \\mathbf{x} = \\alpha$ 的交点 $I$ 可以通过参数化方法找到。设线段为 $\\mathbf{x}(t) = S + t(P-S)$，其中 $t \\in [0,1]$。交点出现在满足 $\\mathbf{n} \\cdot (S + t(P-S)) = \\alpha$ 的 $t$ 值处，这给出：\n$$t = \\frac{\\alpha - \\mathbf{n} \\cdot S}{\\mathbf{n} \\cdot (P-S)}$$\n交点为 $I = S + t(P-S)$。此过程生成裁剪后多边形的有序顶点列表。\n\n**2.2. 多边形面积计算**\n给定所得凸多边形的有序顶点 $(x_1, y_1), (x_2, y_2), \\dots, (x_k, y_k)$，其面积可以使用鞋带（或测量员）公式精确计算：\n$$ \\text{Area} = \\frac{1}{2} \\left| \\sum_{i=1}^{k} (x_i y_{i+1} - x_{i+1} y_i) \\right| $$\n其中 $(x_{k+1}, y_{k+1}) = (x_1, y_1)$。\n\n**3. 最终处理**\n最终计算出的 $\\alpha$ 值被四舍五入到三位有效数字。问题指定了标准的四舍五入规则，即平局时向远离零的方向取整。由于标准的Python `round()` 函数可能会舍入到最近的偶数，因此实现了一个自定义函数来处理此问题。然后将结果格式化为能够正确反映三位有效数字的定点表示法。", "answer": "```python\nimport numpy as np\n\ndef round_to_sf_and_format(value, sf=3):\n    \"\"\"\n    Rounds a number to a specified number of significant figures\n    using standard rounding (ties away from zero) and formats it\n    to a string with the correct number of decimal places.\n    \"\"\"\n    if value == 0:\n        return f\"{0.0:.{sf - 1}f}\"\n\n    # Calculate the power of 10 to scale for rounding\n    power = sf - 1 - int(np.floor(np.log10(np.abs(value))))\n    factor = 10**power\n    \n    # Perform rounding (ties away from zero)\n    rounded_value = np.sign(value) * np.floor(np.abs(value) * factor + 0.5) / factor\n\n    # After rounding, a number might change its order of magnitude (e.g., 9.996 - 10.0)\n    # The number of decimal places for formatting must be based on the rounded value.\n    if rounded_value == 0:\n        # This can happen if a small number rounds to 0.\n        return f\"{0.0:.{sf - 1}f}\"\n\n    decimals = sf - 1 - int(np.floor(np.log10(np.abs(rounded_value))))\n    if decimals  0:\n        decimals = 0\n    \n    return f\"{rounded_value:.{decimals}f}\"\n\ndef polygon_area(vertices):\n    \"\"\"\n    Calculates the area of a polygon using the Shoelace formula.\n    Assumes vertices are ordered (clockwise or counter-clockwise).\n    \"\"\"\n    if len(vertices)  3:\n        return 0.0\n    \n    area = 0.0\n    num_vertices = len(vertices)\n    for i in range(num_vertices):\n        j = (i + 1) % num_vertices\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n        \n    return np.abs(area) / 2.0\n\ndef clip_polygon_by_halfspace(subject_polygon, n, alpha):\n    \"\"\"\n    Clips a convex polygon against a half-space defined by n.x = alpha\n    using the Sutherland-Hodgman algorithm.\n    \"\"\"\n    output_list = []\n    input_list = [np.array(p) for p in subject_polygon]\n    \n    if not input_list:\n        return []\n\n    # A small tolerance for floating point comparisons\n    EPS = 1e-12\n\n    S = input_list[-1]\n    \n    for P in input_list:\n        s_val = np.dot(n, S) - alpha\n        p_val = np.dot(n, P) - alpha\n\n        s_inside = s_val  EPS\n        p_inside = p_val  EPS\n\n        if s_inside and p_inside:\n            # Case 1: Both S and P are inside - output P\n            output_list.append(P)\n        elif s_inside and not p_inside:\n            # Case 2: S is inside, P is outside - output intersection\n            denominator = p_val - s_val\n            if abs(denominator)  EPS:\n                t = -s_val / denominator\n                I = S + t * (P - S)\n                output_list.append(I)\n        elif not s_inside and p_inside:\n            # Case 4: S is outside, P is inside - output intersection then P\n            denominator = p_val - s_val\n            if abs(denominator)  EPS:\n                t = -s_val / denominator\n                I = S + t * (P - S)\n                output_list.append(I)\n                output_list.append(P)\n        # Case 3: Both S and P are outside - do nothing\n        \n        S = P\n        \n    return [p.tolist() for p in output_list]\n\ndef calculate_volume_fraction_area(n, alpha):\n    \"\"\"\n    Calculates the area of the unit square clipped by the half-space n.x = alpha.\n    \"\"\"\n    unit_square = [[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]\n    clipped_polygon = clip_polygon_by_halfspace(unit_square, n, alpha)\n    return polygon_area(clipped_polygon)\n\ndef find_alpha_for_volume_fraction(n_vec, C):\n    \"\"\"\n    Finds the intercept 'alpha' for a given normal 'n' and volume fraction 'C'.\n    \"\"\"\n    n = np.array(n_vec)\n    \n    # Define corners of the unit cell\n    corners = np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]])\n    dot_products = corners @ n\n    alpha_min = np.min(dot_products)\n    alpha_max = np.max(dot_products)\n    \n    # Handle boundary cases as specified\n    if C = 0.0:\n        return alpha_min\n    if C = 1.0:\n        return alpha_max\n\n    # Bisection method to find alpha such that Area(alpha) = C\n    low, high = alpha_min, alpha_max\n    for _ in range(100):  # 100 iterations provides more than sufficient precision\n        mid = (low + high) / 2\n        area = calculate_volume_fraction_area(n, mid)\n        if area  C:\n            low = mid\n        else:\n            high = mid\n            \n    return (low + high) / 2.0\n\ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        ((0.6, 0.8), 0.65),\n        ((1.0, 0.0), 0.3),\n        ((0.0, -1.0), 0.3),\n        ((-0.6, 0.8), 0.25),\n        ((-1.0, -2.0), 0.0),\n        ((0.2, -0.7), 1.0),\n    ]\n\n    results = []\n    for n_vec, C in test_cases:\n        alpha = find_alpha_for_volume_fraction(n_vec, C)\n        results.append(alpha)\n\n    formatted_results = [round_to_sf_and_format(r, 3) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3461601"}, {"introduction": "我们已经探讨了SLIC和PLIC这两种界面重构方法的力学原理 ([@problem_id:3461623], [@problem_id:3461601])，但为什么我们需要像PLIC这样复杂的几何方法呢？本练习旨在通过一个直接的对比研究来回答这个问题。您将实现一个简单的一阶代数VOF方案，并将其结果与一个模拟PLIC行为的精确几何平流方案进行比较。通过量化比较两种方法产生的数值扩散，您将直观地认识到几何方法在保持界面清晰度方面的巨大优势，并深刻理解其在高质量多相流模拟中的重要性。", "problem": "您需要实现并分析一个具有清晰界面的一维流体体积 (VOF) 法平流问题，以量化一个代数格式中的数值扩散，并将其与一个几何分段线性界面计算 (PLIC) 参考解进行比较。其基本物理模型是在一个周期性域上的守恒标量场的平流方程。该标量场是被动流体相的体积分数 $F(x,t)$，以恒定速度平流，并遵循守恒律 $\\partial_t F + \\partial_x (u F) = 0$。初始条件是一个对应于连续流体段的清晰阶跃函数。该域是拓扑周期性的，没有外力、源、汇或非守恒效应。\n\n定义：\n- 设 $L$ 为域长度，$M$ 为均匀网格单元的数量，$\\Delta x = L/M$ 为网格间距，$u$ 为恒定平流速度，$\\Delta t$ 为时间步长。\n- 库朗数为 $C = \\dfrac{u \\Delta t}{\\Delta x} \\in (0,1]$，离散时间步的总数为 $N \\in \\mathbb{N}$。\n- 初始体积分数是一个清晰阶跃 $F(x,0) \\in \\{0,1\\}$，对应于周期性区间 $[0,L)$ 上的流体区域 $[0,x_0)$，其中 $x_0 \\in (0,L)$ 指定了初始填充段的长度。初始网格单元值 $F_j^0$ 是每个网格单元区间 $[j\\Delta x,(j+1)\\Delta x)$ 与 $[0,x_0)$ 的精确重叠分数，并按 $\\Delta x$ 进行归一化。\n\n任务：\n1. 使用一种守恒、单调、与周期性域上的线性代数 VOF 输运更新相一致的一阶迎风通量，为体积分数 $F$ 实现一个代数平流格式。将离散场演化 $N$ 步。将结果场表示为 $F^{\\mathrm{alg}}$。\n2. 独立地实现一个一维几何 VOF 参考解，该解通过将清晰流体区域精确平移位移量 $s = u N \\Delta t$ 来模拟恒定速度下的分段线性界面计算 (PLIC) 行为。对每个网格单元，计算 $F^{\\mathrm{plic}}$ 作为平移后区域与网格单元区间的精确重叠分数，并考虑周期性回绕。\n3. 将数值扩散度量定义为代数场和 PLIC 场之间的积分 $L^1$ 范数差，\n   $$ D = \\sum_{j=0}^{M-1} \\left| F^{\\mathrm{alg}}_j - F^{\\mathrm{plic}}_j \\right| \\Delta x, $$\n   该度量量化了代数格式相对于近似无扩散的 PLIC 参考解的虚假混合。将 $D$ 报告为一个无量纲浮点数。\n\n约束和假设：\n- 平流速度 $u$ 是恒定且为正的。所有量都是无量纲的；不需要物理单位转换。\n- 域是周期性的，并且两种格式都必须保持质量守恒。\n- 几何参考解必须通过与平移后的流体段进行逐单元的精确重叠计算，而不是通过在单元中心采样。\n\n测试套件：\n为以下每组参数计算数值扩散度量 $D$：\n- 情况 A (理想情况)：$L=1$，$M=200$，$u=1$，$C=0.2$，$N=50$，$x_0=0.33$。\n- 情况 B (分数位移，部分单元界面)：$L=1$，$M=200$，$u=1$，$C=0.5$，$N=37$，$x_0=0.33$。\n- 情况 C (边界条件与精确整单元位移)：$L=1$，$M=200$，$u=1$，$C=1.0$，$N=12$，$x_0=0.33$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按测试套件情况 A、B、C 顺序排列的扩散度量，格式为逗号分隔的列表并用方括号括起来。例如，格式必须是严格的“[resultA,resultB,resultC]”。每个结果都必须是浮点数。", "solution": "问题陈述已经过仔细验证，并被确定为有效。它在科学上植根于计算流体动力学的原理，特别是使用流体体积 (VOF) 法对平流方程进行数值求解。该问题是适定的，具有一套完整且一致的定义、约束和测试参数，从而可以得出唯一且有意义的解。其目标清晰，并以精确、可验证的术语表述。因此，我们可以进行完整的求解。\n\n该问题要求比较两种不同的一维 VOF 平流格式，用于求解代表流体体积分数的被动标量场 $F(x,t)$。控制方程是在长度为 $L$ 的周期性域上的线性平流方程 $\\partial_t F + \\partial_x (u F) = 0$，其中平流速度 $u$ 为正常数。目标是通过与几何精确参考解进行比较，来量化一阶代数格式中固有的数值扩散。\n\n**1. 离散化和初始条件**\n\n空间域 $[0, L)$ 被离散化为 $M$ 个均匀的计算网格。第 $j$ 个网格（对于 $j \\in \\{0, 1, \\dots, M-1\\}$）是区间 $[x_j, x_{j+1})$，其中 $x_j = j \\Delta x$，网格间距为 $\\Delta x = L/M$。离散体积分数 $F_j$ 代表 $F(x,t)$ 在第 $j$ 个网格上的平均值。\n\n初始条件指定了一个占据区间 $[0, x_0)$ 的流体区域。初始离散体积分数 $F_j^0$ 由每个网格与该初始区域的精确重叠分数确定。网格 $j$ 与 $[0, x_0)$ 的交集长度由 $\\max(0, \\min(x_{j+1}, x_0) - \\max(x_j, 0))$ 给出。通过网格宽度 $\\Delta x$ 进行归一化，网格 $j$ 中的初始体积分数为：\n$$\nF_j^0 = \\frac{1}{\\Delta x} \\max(0, \\min((j+1)\\Delta x, x_0) - j\\Delta x)\n$$\n该公式正确地处理了完全填充 ($F_j^0=1$)、部分填充 ($0  F_j^0  1$) 或空 ($F_j^0=0$) 的网格。\n\n**2. 代数 VOF 平流：一阶迎风格式**\n\n第一个任务是实现一个代数平流格式。对于平流方程，一个守恒的有限体积法将单元平均值 $F_j$ 从时间步 $n$ 更新到 $n+1$ 的公式如下：\n$$\nF_j^{n+1} = F_j^n - \\frac{\\Delta t}{\\Delta x} \\left( \\mathcal{F}_{j+1/2} - \\mathcal{F}_{j-1/2} \\right)\n$$\n其中 $\\mathcal{F}_{j+1/2}$ 是穿过界面 $x_{j+1/2}$ 的数值通量。对于一阶迎风格式，当速度 $u  0$ 为正常数时，界面处的通量由迎风单元的值确定。因此，单元 $j$ 右侧面的通量为 $\\mathcal{F}_{j+1/2} = u F_j^n$，左侧面的通量为 $\\mathcal{F}_{j-1/2} = u F_{j-1}^n$。\n\n将这些通量代入更新方程，得到：\n$$\nF_j^{n+1} = F_j^n - \\frac{u \\Delta t}{\\Delta x} \\left( F_j^n - F_{j-1}^n \\right)\n$$\n引入库朗数 $C = \\frac{u \\Delta t}{\\Delta x}$，更新规则简化为：\n$$\nF_j^{n+1} = F_j^n - C \\left( F_j^n - F_{j-1}^n \\right) = (1-C)F_j^n + C F_{j-1}^n\n$$\n该方程被应用 $N$ 个时间步，以将初始场 $F_j^0$ 演化到最终状态 $F_j^{\\mathrm{alg}} = F_j^N$。周期性边界条件要求对于单元 $j=0$，其迎风单元为 $j-1=M-1$。\n\n众所周知，该格式是单调和守恒的，但会引入显著的数值扩散，表现为对清晰界面的涂抹。\n\n**3. 几何 VOF 参考解：类 PLIC 的精确平移**\n\n第二个任务是计算一个参考解，表示为 $F^{\\mathrm{plic}}$。线性平流方程的精确解是初始剖面的一个简单平移。经过总时间 $T = N \\Delta t$后，初始流体区域 $[0, x_0)$ 被平移了距离 $s = uT = u N \\Delta t$。新的、精确的流体区域是区间 $[s, s+x_0)$。\n\n为了计算 $F_j^{\\mathrm{plic}}$，我们求出这个平移后的区域与每个网格 $[j\\Delta x, (j+1)\\Delta x)$ 的精确重叠分数。为了正确处理域的周期性，我们考虑流体区间的无限周期性镜像集 $\\bigcup_{k \\in \\mathbb{Z}} [s+kL, s+x_0+kL)$，并计算其与每个网格区间的交集。单元 $j$ 的总重叠长度为：\n$$\n\\text{Overlap}_j = \\sum_{k \\in \\mathbb{Z}} \\max\\left(0, \\min((j+1)\\Delta x, s+x_0+kL) - \\max(j\\Delta x, s+kL)\\right)\n$$\n在实践中，该求和只需对少数几个能使交集非零的整数 $k$ 进行求值。然后，参考体积分数为：\n$$\nF_j^{\\mathrm{plic}} = \\frac{\\text{Overlap}_j}{\\Delta x}\n$$\n根据其构造，该方法是无扩散的，并保持了界面的清晰度，可作为衡量代数格式涂抹效应的理想参考。\n\n**4. 数值扩散度量**\n\n数值扩散 $D$ 通过最终代数场 $F^{\\mathrm{alg}}$ 与几何参考场 $F^{\\mathrm{plic}}$ 之间的积分 $L^1$ 范数差来量化：\n$$\nD = \\sum_{j=0}^{M-1} \\left| F^{\\mathrm{alg}}_j - F^{\\mathrm{plic}}_j \\right| \\Delta x\n$$\n该度量代表了由于迎风格式的数值扩散而被虚假重新分布的流体分数的总量。$D=0$ 的值意味着完全一致，而更大的 $D$ 值表示更严重的数值扩散。我们现在将为指定的测试用例计算此值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the VOF advection simulation for all test cases\n    and print the results in the specified format.\n    \"\"\"\n\n    test_cases = [\n        # Case A: L=1, M=200, u=1, C=0.2, N=50, x0=0.33\n        {'L': 1.0, 'M': 200, 'u': 1.0, 'C': 0.2, 'N': 50, 'x0': 0.33},\n        # Case B: L=1, M=200, u=1, C=0.5, N=37, x0=0.33\n        {'L': 1.0, 'M': 200, 'u': 1.0, 'C': 0.5, 'N': 37, 'x0': 0.33},\n        # Case C: L=1, M=200, u=1, C=1.0, N=12, x0=0.33\n        {'L': 1.0, 'M': 200, 'u': 1.0, 'C': 1.0, 'N': 12, 'x0': 0.33},\n    ]\n\n    results = []\n    for params in test_cases:\n        D = compute_diffusion(**params)\n        results.append(D)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\n\ndef compute_diffusion(L: float, M: int, u: float, C: float, N: int, x0: float) - float:\n    \"\"\"\n    Computes the numerical diffusion measure D for a single parameter set.\n    \"\"\"\n    # 1. Calculate derived parameters\n    dx = L / M\n    dt = C * dx / u\n\n    # 2. Compute Initial Conditions F_j^0\n    # Create arrays for the start and end coordinates of each cell.\n    cell_indices = np.arange(M)\n    cell_starts = cell_indices * dx\n    cell_ends = (cell_indices + 1) * dx\n\n    # Calculate the exact overlap of each cell with the initial fluid region [0, x0).\n    initial_overlap_length = np.maximum(0, np.minimum(cell_ends, x0) - np.maximum(cell_starts, 0))\n    F_initial = initial_overlap_length / dx\n\n    # 3. Evolve using Algebraic Advection (First-Order Upwind)\n    F_alg = F_initial.copy()\n    for _ in range(N):\n        # Update rule: F_j^{n+1} = (1-C)*F_j^n + C*F_{j-1}^n\n        # F_{j-1} with periodic boundary is handled efficiently using np.roll.\n        F_alg = (1.0 - C) * F_alg + C * np.roll(F_alg, 1)\n\n    # 4. Compute Geometrical Reference Solution (PLIC-like)\n    total_shift = u * N * dt\n    F_plic = np.zeros(M)\n    \n    # The translated fluid region is the interval [s, s + x0)\n    start_fluid = total_shift\n    end_fluid = total_shift + x0\n    \n    # Calculate exact overlap of each cell with the translated region.\n    # This implementation is general for periodic domains.\n    for j in range(M):\n        start_cell = cell_starts[j]\n        end_cell = cell_ends[j]\n        \n        # Determine the range of periodic images (k) of the fluid segment\n        # that could potentially overlap with the current cell.\n        k_min = int(np.floor((start_cell - end_fluid) / L))\n        k_max = int(np.ceil((end_cell - start_fluid) / L))\n        \n        total_overlap = 0.0\n        for k in range(k_min, k_max + 1):\n             shifted_start_fluid = start_fluid + k * L\n             shifted_end_fluid = end_fluid + k * L\n             \n             # Calculate overlap between a cell and one periodic image of the fluid\n             overlap = max(0.0, min(end_cell, shifted_end_fluid) - max(start_cell, shifted_start_fluid))\n             total_overlap += overlap\n             \n        F_plic[j] = total_overlap / dx\n        \n    # 5. Compute the Numerical Diffusion Measure D\n    D = np.sum(np.abs(F_alg - F_plic)) * dx\n    \n    return D\n\n# Ensure the script runs when executed.\nsolve()\n```", "id": "3461653"}]}