{"hands_on_practices": [{"introduction": "构建了核函数之后，下一个关键步骤是理解它在耦合拉格朗日和欧拉域时的行为。不当的网格间距选择可能会导致数值伪影甚至不稳定，这是实践中常见的挑战。本练习 [@problem_id:3405552] 将引导你对组合的散布和插值过程进行理论分析。通过运用傅里叶分析这一强大工具，你将研究离散耦合矩阵的性质，并确定其保持良态的条件，从而深刻理解如何为稳定和精确的模拟正确配置网格离散化。", "problem": "考虑一个长度为 $L$ 的一维周期性域，该域被一个包含 $N$ 个点、网格尺寸为 $h$ 的欧拉网格离散化，因此 $L = N h$。一个浸入式结构由 $M$ 个均匀分布的拉格朗日标记点表示，其间距为 $s = L/M$。假设 $s$ 是 $h$ 的整数倍，即 $s = q h$，其中 $q \\in \\mathbb{N}$，因此 $N = q M$。\n\n定义欧拉网格上的离散正则化 delta 核为一个对称的三点模板\n$$\ng_{-1} = \\beta, \\quad g_{0} = \\gamma, \\quad g_{1} = \\beta, \\quad g_{i} = 0 \\ \\text{for} \\ |i| \\geq 2,\n$$\n参数为 $\\beta = \\frac{1}{4}$ 和 $\\gamma = \\frac{1}{2}$。考虑离散浸入边界 (IB) 散播算子 $S : \\mathbb{R}^{M} \\to \\mathbb{R}^{N}$ 和插值算子 $J : \\mathbb{R}^{N} \\to \\mathbb{R}^{M}$，其定义（使用周期性索引）如下\n$$\n(S \\mathbf{F})_{i} \\equiv \\sum_{j=0}^{M-1} g_{i - q j} \\, F_{j}, \\qquad (J \\mathbf{u})_{j} \\equiv \\sum_{i=0}^{N-1} g_{i - q j} \\, u_{i},\n$$\n因此在标准欧几里得内积下，$J = S^{\\top}$。复合算子 $G \\equiv J S$ 是一个 $M \\times M$ 的循环格拉姆矩阵，它编码了由 IB 散播和插值引起的离散拉格朗日-拉格朗日耦合。\n\n从周期性网格上离散卷积和离散傅里叶变换的基本性质出发，并且不使用任何 IB 方法的现成公式，推导 $G$ 的傅里叶符号，使其成为比率 $q = s/h$ 和核参数 $(\\beta,\\gamma)$ 的函数。利用此结果分析当 $q$ 变化时 $G$ 的零空间和条件数。然后，对于给定的核参数 $\\beta = \\frac{1}{4}$ 和 $\\gamma = \\frac{1}{2}$，确定最小整数比 $q_{\\star} \\in \\mathbb{N}$，使得 $G$ 是严格正定的（没有非平凡零空间）。将你的最终答案表示为单个整数 $q_{\\star}$。你的分析必须仅依赖于上述基本定义（周期性网格上的离散卷积、循环矩阵和离散傅里叶变换），并且所有步骤都必须由这些原理解释。为了物理真实性，从重新参数化拉格朗日标记点以最小化体积泄漏的角度解释你的结果，但你的最终答案必须仅为上面定义的 $q_{\\star}$ 的值。", "solution": "问题要求找出最小的整数 $q_{\\star} \\in \\mathbb{N}$，使得对于给定的三点核，矩阵 $G \\equiv J S$ 是严格正定的。\n\n首先，我们验证问题陈述的有效性。\n给定条件如下：\n- 一个长度为 $L$ 的一维周期性域。\n- 一个包含 $N$ 个点、网格尺寸为 $h = L/N$ 的欧拉网格。\n- 一个包含 $M$ 个拉格朗地标记点、间距为 $s = L/M$ 的浸入式结构。\n- $s = q h$ 的关系，其中 $q \\in \\mathbb{N}$，这意味着 $N = q M$。\n- 欧拉网格上的离散正则化 delta 核 $g_i$，定义为一个对称的三点模板：$g_{-1} = \\beta$，$g_{0} = \\gamma$，$g_{1} = \\beta$，且当 $|i| \\geq 2$ 时 $g_i = 0$。给定的参数为 $\\beta = \\frac{1}{4}$ 和 $\\gamma = \\frac{1}{2}$。\n- 离散散播算子 $S : \\mathbb{R}^{M} \\to \\mathbb{R}^{N}$ 定义为 $(S \\mathbf{F})_{i} = \\sum_{j=0}^{M-1} g_{i - q j} F_{j}$。\n- 离散插值算子 $J : \\mathbb{R}^{N} \\to \\mathbb{R}^{M}$ 定义为 $(J \\mathbf{u})_{j} = \\sum_{i=0}^{N-1} g_{i - q j} u_{i}$。\n- 问题陈述在标准欧几里得内积下，$J = S^{\\top}$。\n- 需要分析的矩阵是 $G \\equiv J S$，一个 $M \\times M$ 矩阵。\n\n该问题在科学上植根于数值偏微分方程领域，特别是浸入边界法。所有术语都已正式定义，问题是自洽的，并且在数学上是适定的。没有矛盾、歧义或事实上的不健全之处。该问题是有效的。\n\n我们开始求解。矩阵 $G$ 由 $G = J S$ 给出。由于 $J = S^{\\top}$，我们有 $G = S^{\\top} S$。这是与 $S$ 的列向量相关的格拉姆矩阵。因此，对于任何实矩阵 $S$，$G$ 都是对称半正定的。我们的任务是找到使 $G$ 严格正定的条件。\n一个矩阵是严格正定的，当且仅当它的所有特征值都严格为正。\n\n矩阵 $G$ 是一个 $M \\times M$ 矩阵。让我们检查其元素 $G_{kj}$。\n$$\nG_{kj} = (J S)_{kj} = \\sum_{i=0}^{N-1} J_{ki} S_{ij}\n$$\n根据 $S$ 和 $J$ 的定义，它们的矩阵元素是 $S_{ij} = g_{i-qj}$ 和 $J_{ki} = g_{i-qk}$。\n$$\nG_{kj} = \\sum_{i=0}^{N-1} g_{i-qk} g_{i-qj}\n$$\n我们来分析 $G_{kj}$ 对 $k$ 和 $j$ 的依赖关系。令 $p = k-j$。则 $k=j+p$。\n$$\nG_{j+p, j} = \\sum_{i=0}^{N-1} g_{i-q(j+p)} g_{i-qj}\n$$\n令 $i' = i-qj$。利用网格和核的周期性，可以重新对求和进行索引。\n$$\nG_{j+p, j} = \\sum_{i'=0}^{N-1} g_{i'-qp} g_{i'}\n$$\n这个表达式只依赖于差值 $p=k-j$。因此，$G$ 是一个循环矩阵，其中 $G_{kj} = C_{k-j}$（对于某个向量 $C$）。一个 $M \\times M$ 循环矩阵的特征值由其第一行（或第一列）的离散傅里叶变换 (DFT) 给出。\n\n为了找到特征值 $\\lambda_k(G)$，我们在傅里叶空间中分析算子的作用。设 $\\mathbf{F}$ 是拉格朗日网格上的一个向量，$\\mathbf{u}$ 是欧拉网格上的一个向量。它们各自的 DFT 为：\n$$\n\\hat{F}_k = \\sum_{j=0}^{M-1} F_j \\exp\\left(-\\frac{2\\pi i j k}{M}\\right), \\quad k \\in \\{0, \\dots, M-1\\}\n$$\n$$\n\\hat{u}_m = \\sum_{i=0}^{N-1} u_i \\exp\\left(-\\frac{2\\pi i i m}{N}\\right), \\quad m \\in \\{0, \\dots, N-1\\}\n$$\n令 $\\mathbf{f} = S \\mathbf{F}$。我们对 $\\mathbf{f}$ 进行 DFT。\n$$\n\\hat{f}_m = \\sum_{i=0}^{N-1} \\left( \\sum_{j=0}^{M-1} g_{i-qj} F_j \\right) \\exp\\left(-\\frac{2\\pi i i m}{N}\\right) = \\sum_{j=0}^{M-1} F_j \\left( \\sum_{i=0}^{N-1} g_{i-qj} \\exp\\left(-\\frac{2\\pi i i m}{N}\\right) \\right)\n$$\n内部的和是一个移位的 DFT。令 $p=i-qj$。\n$$\n\\sum_{p} g_p \\exp\\left(-\\frac{2\\pi i (p+qj) m}{N}\\right) = \\exp\\left(-\\frac{2\\pi i q j m}{N}\\right) \\sum_{p=0}^{N-1} g_p \\exp\\left(-\\frac{2\\pi i p m}{N}\\right) = \\exp\\left(-\\frac{2\\pi i q j m}{N}\\right) \\hat{g}_m\n$$\n其中 $\\hat{g}_m$ 是核 $g$ 的 DFT。代入回去：\n$$\n\\hat{f}_m = \\hat{g}_m \\sum_{j=0}^{M-1} F_j \\exp\\left(-\\frac{2\\pi i q j m}{N}\\right)\n$$\n使用 $N=qM$，我们有 $q/N = 1/M$。\n$$\n\\hat{f}_m = \\hat{g}_m \\sum_{j=0}^{M-1} F_j \\exp\\left(-\\frac{2\\pi i j m}{M}\\right) = \\hat{g}_m \\hat{F}_{m \\pmod M}\n$$\n这就是关联傅里叶系数的混叠公式。\n\n现在考虑 $\\mathbf{U} = J \\mathbf{f}$。矩阵 $G=JS$ 的作用是 $\\mathbf{U} = G \\mathbf{F}$。在傅里叶空间中，由于 $G$ 是循环矩阵，这个乘法变成一个逐点乘积 $\\hat{U}_k = \\lambda_k(G) \\hat{F}_k$。我们的目标是找到乘子 $\\lambda_k(G)$。\n我们有 $\\hat{U}_k = ( \\widehat{J \\mathbf{f}} )_k$。由于 $J=S^\\top$，算子 $\\hat{J}$ 是 $\\hat{S}$ 的共轭转置（取决于缩放因子）。直接推导可得：\n$$\n\\hat{U}_k = \\frac{1}{q} \\sum_{l=0}^{q-1} \\overline{\\hat{g}_{k+lM}} \\hat{f}_{k+lM}\n$$\n其中上划线表示复共轭。\n代入我们关于 $\\hat{f}_m$ 的表达式：\n$$\n\\hat{f}_{k+lM} = \\hat{g}_{k+lM} \\hat{F}_{(k+lM) \\pmod M} = \\hat{g}_{k+lM} \\hat{F}_k\n$$\n所以，我们有：\n$$\n\\hat{U}_k = \\frac{1}{q} \\sum_{l=0}^{q-1} \\overline{\\hat{g}_{k+lM}} (\\hat{g}_{k+lM} \\hat{F}_k) = \\left( \\frac{1}{q} \\sum_{l=0}^{q-1} |\\hat{g}_{k+lM}|^2 \\right) \\hat{F}_k\n$$\n这给了我们 $G$ 的特征值：\n$$\n\\lambda_k(G) = \\frac{1}{q} \\sum_{l=0}^{q-1} \\left|\\hat{g}_{k+lM}\\right|^2, \\quad k \\in \\{0, \\dots, M-1\\}\n$$\n接下来，我们计算 $\\hat{g}_m$，即核 $g_i$ 在 $N$ 点网格上的 DFT。\n$$\n\\hat{g}_m = \\sum_{i=0}^{N-1} g_i \\exp\\left(-\\frac{2\\pi i i m}{N}\\right) = g_{-1}\\exp\\left(\\frac{2\\pi i m}{N}\\right) + g_0 + g_1\\exp\\left(-\\frac{2\\pi i m}{N}\\right)\n$$\n使用 $g_{-1}=g_1=\\beta$，我们得到：\n$$\n\\hat{g}_m = \\beta \\left(\\exp\\left(\\frac{2\\pi i m}{N}\\right) + \\exp\\left(-\\frac{2\\pi i m}{N}\\right)\\right) + \\gamma = 2\\beta \\cos\\left(\\frac{2\\pi m}{N}\\right) + \\gamma\n$$\n因为 $\\beta$ 和 $\\gamma$ 是实数，$\\hat{g}_m$ 也是实数。因此 $|\\hat{g}_m|^2 = (\\hat{g}_m)^2$。\n将此代入特征值公式并使用 $N=qM$：\n$$\n\\lambda_k(G) = \\frac{1}{q} \\sum_{l=0}^{q-1} \\left( 2\\beta \\cos\\left(\\frac{2\\pi(k+lM)}{qM}\\right) + \\gamma \\right)^2 = \\frac{1}{q} \\sum_{l=0}^{q-1} \\left( 2\\beta \\cos\\left(\\frac{2\\pi k}{qM} + \\frac{2\\pi l}{q}\\right) + \\gamma \\right)^2\n$$\n矩阵 $G$ 是严格正定的，当且仅当对于所有 $k \\in \\{0, \\dots, M-1\\}$ 都有 $\\lambda_k(G) > 0$。由于 $\\lambda_k(G)$ 是非负项之和，$\\lambda_k(G) = 0$ 当且仅当和中的每一项都为零。\n因此，如果存在某个 $k$ 使得下式成立，$G$ 就是奇异的\n$$\n2\\beta \\cos\\left(\\frac{2\\pi k}{qM} + \\frac{2\\pi l}{q}\\right) + \\gamma = 0, \\quad \\text{for all } l \\in \\{0, \\dots, q-1\\}\n$$\n让我们代入给定值 $\\beta = \\frac{1}{4}$ 和 $\\gamma = \\frac{1}{2}$。\n$$\n2\\left(\\frac{1}{4}\\right) \\cos\\left(\\dots\\right) + \\frac{1}{2} = 0 \\implies \\frac{1}{2} \\cos\\left(\\dots\\right) + \\frac{1}{2} = 0 \\implies \\cos\\left(\\dots\\right) = -1\n$$\n所以，如果对于某个 $k$，我们有：\n$$\n\\cos\\left(\\frac{2\\pi k}{qM} + \\frac{2\\pi l}{q}\\right) = -1, \\quad \\text{for all } l \\in \\{0, \\dots, q-1\\}\n$$\n我们要找到最小的整数 $q_{\\star}$，使得对于任何 $k \\in \\{0, \\dots, M-1\\}$，这个条件都永远无法满足。\n\n情况 $q=1$：\n条件变为 $\\cos\\left(\\frac{2\\pi k}{M}\\right) = -1$（求和中只有 $l=0$）。\n如果存在一个 $k$ 使得 $\\frac{2\\pi k}{M} = \\pi + 2n\\pi$ 对于某个整数 $n$ 成立，则该方程有解。\n对于 $n=0$，这给出 $\\frac{2k}{M} = 1$，或 $k = \\frac{M}{2}$。\n如果 $M$ 是偶数，那么 $k = M/2$ 是在 $\\{0, \\dots, M-1\\}$ 范围内的整数，并且对于这个 $k$，$\\lambda_k(G) = 0$。因此，对于 $q=1$，$G$ 可能是奇异的（例如，当拉格朗日标记点数 $M$ 是偶数时）。所以，$q_{\\star} \\neq 1$。\n\n情况 $q=2$：\n该条件要求对于某个 $k$：\n$$\n\\cos\\left(\\frac{2\\pi k}{2M} + \\frac{2\\pi(0)}{2}\\right) = -1 \\quad \\text{and} \\quad \\cos\\left(\\frac{2\\pi k}{2M} + \\frac{2\\pi(1)}{2}\\right) = -1\n$$\n这简化为：\n$$\n\\cos\\left(\\frac{\\pi k}{M}\\right) = -1 \\quad \\text{(for } l=0)\n$$\n$$\n\\cos\\left(\\frac{\\pi k}{M} + \\pi\\right) = -1 \\quad \\text{(for } l=1)\n$$\n使用恒等式 $\\cos(x+\\pi) = -\\cos(x)$，第二个方程变为：\n$$\n-\\cos\\left(\\frac{\\pi k}{M}\\right) = -1 \\implies \\cos\\left(\\frac{\\pi k}{M}\\right) = 1\n$$\n要使 $\\lambda_k(G)$ 为零，我们需要 $\\cos\\left(\\frac{\\pi k}{M}\\right)$ 同时等于 $-1$ 和 $1$。这是一个矛盾。因此，对于 $q=2$，$\\lambda_k(G)$ 的求和中的两项不可能同时为零。由于这些项是平方项，它们是非负的。对于 $\\gamma \\neq 0$，$2\\beta \\cos(\\theta) + \\gamma$ 和 $-2\\beta \\cos(\\theta) + \\gamma$ 不可能同时为零。因此，对于所有 $k$，$\\lambda_k(G)$ 总是严格为正。\n因此，对于 $q=2$，矩阵 $G$ 是严格正定的。\n\n由于 $q=1$ 不是一个有效的选择而 $q=2$ 是，所以最小的整数值是 $q_{\\star}=2$。这个选择对应于拉格朗日标记点间距是欧拉网格间距的两倍（$s = 2h$），这是 IB 方法中确保数值稳定性和准确性的常见做法。", "answer": "$$\\boxed{2}$$", "id": "3405552"}, {"introduction": "现在，我们从分析单个组件转向系统级集成，将浸入边界耦合置于一个完整的不可压缩流求解器的框架中。这最后一个实践练习 [@problem_id:3405586] 将挑战你组装在基于投影法的浸入边界方法中出现的完整线性算子。你将把散布和插值算子与无散投影步骤（许多流体求解器的核心要素）相结合，构建用于强制执行无滑移边界条件的矩阵，并分析其可解性，从而对这些不同组件如何相互作用以形成一个统一的数值方法获得实践性的理解。", "problem": "考虑在周期性方形域 $\\Omega = [0,1]^2$ 上的不可压缩Navier–Stokes方程，其在两个空间方向上均具有周期性边界条件。设空间网格为具有 $N \\times N$ 个点的均匀网格，网格间距为 $h = 1/N$，并设速度场在欧拉网格上离散，而约束则在代表浸入边界的拉格朗日点 $\\{\\mathbf{X}_\\ell\\}_{\\ell=1}^{N_b}$ 上强制执行。浸入边界法通过拉格朗日乘子在拉格朗日位置强制执行无滑移约束，这些乘子通过正则化的狄拉克δ函数散开到欧拉网格上。在投影法中，压力由一个使用快速傅里叶变换（FFT）高效求解的泊松方程确定，并且速度被投影到一个无散场上。\n\n您必须构建一个离散的投影法浸入边界求解器，该求解器将基于FFT的压力求解与由δ函数介导的约束耦合起来。离散化必须基于以下基本要素：\n\n- 不可压缩流约束：$\\nabla \\cdot \\mathbf{u}^{n+1} = 0$。\n- 投影法更新（忽略平流和粘性以分离浸入边界耦合和不可压缩性）：计算一个中间速度 $\\mathbf{u}^* = \\mathbf{u}^n + \\Delta t\\, \\mathbf{f}_{\\text{IB}}$，其中 $\\mathbf{f}_{\\text{IB}}$ 是通过使用正则化狄拉克δ函数将拉格朗日乘子从浸入边界散开到网格上而获得的力密度，然后求解压力泊松方程 $\\Delta p = \\frac{1}{\\Delta t}\\nabla \\cdot \\mathbf{u}^*$，该方程受周期性边界条件和零均值压力约束，最后更新 $\\mathbf{u}^{n+1} = \\mathbf{u}^* - \\Delta t \\nabla p$。\n- 周期域傅里叶空间亥姆霍兹-霍奇分解：对于傅里叶模态波数向量 $\\mathbf{k} = (k_x, k_y)$，当 $\\mathbf{k} \\neq \\mathbf{0}$ 时，无散投影算子为 $\\mathbf{P}(\\mathbf{k}) = \\mathbf{I} - \\frac{\\mathbf{k}\\mathbf{k}^\\top}{\\|\\mathbf{k}\\|^2}$，并且 $\\mathbf{P}(\\mathbf{0}) = \\mathbf{I}$。\n- 用于浸入边界法的正则化狄拉克δ函数：使用四点Peskin核。对于以网格单位表示的一维距离 $r$，定义\n$$\n\\phi(r) =\n\\begin{cases}\n\\frac{1}{8}\\left(3 - 2r + \\sqrt{1 + 4r - 4r^2}\\right), & 0 \\le r < 1, \\\\\n\\frac{1}{8}\\left(5 - 2r - \\sqrt{-7 + 12r - 4r^2}\\right), & 1 \\le r < 2, \\\\\n0, & r \\ge 2,\n\\end{cases}\n$$\n并定义二维张量积核 $\\delta_h(\\mathbf{x} - \\mathbf{X}) = \\phi\\!\\left(\\frac{x - X_x}{h}\\right)\\,\\phi\\!\\left(\\frac{y - X_y}{h}\\right)/h^2$，其中指数进行周期性包裹。散开算子通过 $\\mathbf{f}_{\\text{IB}}(\\mathbf{x}_{ij}) = \\sum_{\\ell=1}^{N_b} \\delta_h(\\mathbf{x}_{ij} - \\mathbf{X}_\\ell)\\,\\boldsymbol{\\lambda}_\\ell$ 将拉格朗日点上的拉格朗日乘子映射到欧拉网格上的力，而插值算子通过 $\\mathbf{U}_\\ell = \\sum_{i,j} \\mathbf{u}(\\mathbf{x}_{ij})\\,\\phi\\!\\left(\\frac{x_{i} - X_{\\ell,x}}{h}\\right)\\,\\phi\\!\\left(\\frac{y_{j} - X_{\\ell,y}}{h}\\right)$ 将欧拉速度映射到拉格朗日速度。\n\n设拉格朗日乘子 $\\{\\boldsymbol{\\lambda}_\\ell\\}$ 的确定方式是使得浸入边界处的无滑移约束在投影后得到满足，即 $\\mathbf{U}_\\ell^{n+1} = \\mathbf{U}_b(\\mathbf{X}_\\ell)$，其中 $\\mathbf{U}_b$ 是预设的边界速度。在线性化设置下，当 $\\Delta t = 1$ 且 $\\mathbf{u}^n = \\mathbf{0}$ 时，散开、投影和插值的耦合导致一个关于 $\\{\\boldsymbol{\\lambda}_\\ell\\}$ 的线性系统，形式为 $\\mathbf{M}\\,\\boldsymbol{\\lambda} = \\mathbf{g}$，其中 $\\mathbf{M} = \\mathbf{J}\\,\\mathbf{P}\\,\\mathbf{S}$，$\\mathbf{S}$ 是散开算子，$\\mathbf{P}$ 是无散投影，$\\mathbf{J}$ 是插值算子。这里 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^{2N_b}$ 堆叠了拉格朗日乘子的分量，而 $\\mathbf{g} \\in \\mathbb{R}^{2N_b}$ 堆叠了目标边界速度。\n\n您的任务：\n\n1.  在均匀周期网格上构建如上定义的离散算子 $\\mathbf{S}$、$\\mathbf{P}$ 和 $\\mathbf{J}$。使用二维FFT，通过波数 $k_x = 2\\pi \\cdot \\text{fftfreq}(N, d=h)$ 和 $k_y = 2\\pi \\cdot \\text{fftfreq}(N, d=h)$ 逐模态地实现傅里叶空间投影 $\\mathbf{P}$。通过 $\\mathbf{P}(\\mathbf{0}) = \\mathbf{I}$ 处理零模态。\n2.  通过将 $\\mathbf{S}$ 应用于 $\\mathbb{R}^{2N_b}$ 中的每个标准基向量，用 $\\mathbf{P}$ 进行投影，并用 $\\mathbf{J}$ 进行插值，来组装稠密矩阵 $\\mathbf{M} \\in \\mathbb{R}^{2N_b \\times 2N_b}$。\n3.  在此周期性设置下，分析无散速度更新的可解性条件。具体来说：\n    -   基于FFT的压力泊松方程当且仅当右侧项的均值为零时是可解的。在投影法的表述中，这转化为要求 $\\frac{1}{|\\Omega|}\\int_{\\Omega} \\nabla \\cdot \\mathbf{u}^*\\,\\mathrm{d}\\mathbf{x} = 0$，这是对中间速度 $\\mathbf{u}^*$ 和任何施加的力的一个条件。使用周期性有限差分实现对 $\\mathbf{u}^*$ 的平均散度的离散检查，并报告该均值的绝对值。\n    -   无滑移约束当且仅当算子 $\\mathbf{M}$ 是满秩时，才可以通过拉格朗日乘子求解。计算 $\\mathbf{M}$ 的奇异值，并报告最小奇异值以及一个布尔值，该布尔值指示 $\\mathbf{M}$ 在数值容差内是否满秩。\n\n使用以下测试套件，每个测试中 $N = 32$，$\\Delta t = 1$，且 $\\mathbf{u}^n = \\mathbf{0}$：\n\n- 测试用例 A（一般位置，单点）：$N_b = 1$，拉格朗日位置 $\\mathbf{X}_1 = (0.35, 0.72)$。\n- 测试用例 B（重合点，潜在的秩亏）：$N_b = 2$，拉格朗日位置 $\\mathbf{X}_1 = (0.10, 0.90)$，$\\mathbf{X}_2 = (0.10, 0.90)$。\n- 测试用例 C（不同点，周期性包裹）：$N_b = 2$，拉格朗日位置 $\\mathbf{X}_1 = (0.99, 0.02)$，$\\mathbf{X}_2 = (0.51, 0.49)$。\n\n对于每个测试用例，构建 $\\mathbf{M}$，计算其最小奇异值 $\\sigma_{\\min}$，通过检查所有奇异值是否超过一个容差（使用固定容差 $10^{-10}$）来确定满秩可解性，并计算由应用于每个列组装的单位拉格朗日乘子向量散开所产生的中间速度 $\\mathbf{u}^*$ 的平均散度绝对值（您也可以等效地使用在组装 $\\mathbf{M}$ 时获得的 $\\mathbf{u}^*$）。为每个测试用例报告三个输出：$\\sigma_{\\min}$（作为浮点数）、满秩可解性（作为布尔值）和平均散度的绝对值（作为浮点数）。\n\n最终输出格式：您的程序应生成单行输出，其中包含九个结果，形式为逗号分隔的列表，并用方括号括起来，顺序为 $[\\sigma_{\\min}^{A}, \\text{full\\_rank}^{A}, |\\overline{\\nabla \\cdot \\mathbf{u}^*}|^{A}, \\sigma_{\\min}^{B}, \\text{full\\_rank}^{B}, |\\overline{\\nabla \\cdot \\mathbf{u}^*}|^{B}, \\sigma_{\\min}^{C}, \\text{full\\_rank}^{C}, |\\overline{\\nabla \\cdot \\mathbf{u}^*}|^{C}]$。", "solution": "用户提供的问题是一个有效且适定的数值分析任务。它要求构建和分析一个在线性浸入边界法（用于不可压缩流体流动）背景下产生的线性算子。该问题在计算流体动力学原理上有坚实的科学基础，提供了一套完整的定义和参数，并要求一个可验证的数值输出。因此，我们可以进行形式化的求解。\n\n问题的核心是构建矩阵 $\\mathbf{M} \\in \\mathbb{R}^{2N_b \\times 2N_b}$，该矩阵表示从拉格朗日力 $\\boldsymbol{\\lambda}$ 到投影到无散场后在拉格朗日点上产生的速度的线性映射。该矩阵由三个算子的复合定义：散开（$\\mathbf{S}$）、投影（$\\mathbf{P}$）和插值（$\\mathbf{J}$），使得 $\\mathbf{M} = \\mathbf{JPS}$。这里的设定是一个简化的投影法步骤，其中中间速度仅由浸入边界力确定。\n\n设计算域为 $\\Omega = [0,1]^2$，具有周期性边界条件，在一个 $N \\times N$ 个点的均匀网格上离散化。网格间距为 $h=1/N$。网格点表示为 $\\mathbf{x}_{ij} = (ih, jh)$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$。浸入边界由一组 $N_b$ 个拉格朗日点 $\\{\\mathbf{X}_\\ell\\}_{\\ell=1}^{N_b}$ 表示。\n\n### 离散化算子\n\n**1. 散开算子 ($\\mathbf{S}$)**\n散开算子 $\\mathbf{S}$ 将 $N_b$ 个拉格朗日乘子的向量 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^{2N_b}$ 映射到网格上的欧拉力密度场 $\\mathbf{f}_{\\text{IB}}$。这是通过一个正则化的狄拉克δ函数 $\\delta_h$ 实现的：\n$$\n\\mathbf{f}_{\\text{IB}}(\\mathbf{x}_{ij}) = (\\mathbf{S}\\boldsymbol{\\lambda})(\\mathbf{x}_{ij}) = \\sum_{\\ell=1}^{N_b} \\delta_h(\\mathbf{x}_{ij} - \\mathbf{X}_\\ell)\\,\\boldsymbol{\\lambda}_\\ell\n$$\n二维δ函数是一维核函数 $\\phi(r)$ 的张量积：\n$$\n\\delta_h(\\mathbf{x} - \\mathbf{X}) = \\frac{1}{h^2} \\phi\\left(\\frac{|x - X_x|_{\\text{periodic}}}{h}\\right)\\,\\phi\\left(\\frac{|y - X_y|_{\\text{periodic}}}{h}\\right)\n$$\n其中 $|d|_{\\text{periodic}} = \\min(|d|, 1-|d|)$ 考虑了长度为 $1$ 的周期域。$\\phi$ 的参数 $r$ 是以网格单位计的距离。四点Peskin核 $\\phi(r)$ 由下式给出：\n$$\n\\phi(r) =\n\\begin{cases}\n\\frac{1}{8}\\left(3 - 2r + \\sqrt{1 + 4r - 4r^2}\\right), & 0 \\le r < 1 \\\\\n\\frac{1}{8}\\left(5 - 2r - \\sqrt{-7 + 12r - 4r^2}\\right), & 1 \\le r < 2 \\\\\n0, & r \\ge 2\n\\end{cases}\n$$\n$\\phi(r)$ 在 $r > 2$ 时的紧支集意味着对于每个拉格朗日点 $\\mathbf{X}_\\ell$，力被散开到其周围一个局部的 $4 \\times 4$ 网格点模板上。\n\n**2. 投影算子 ($\\mathbf{P}$)**\n投影算子 $\\mathbf{P}$ 将一个向量场映射到其无散分量。在周期域中，这在傅里叶空间中实现最为高效。设 $\\hat{\\mathbf{u}}(\\mathbf{k})$ 是速度场 $\\mathbf{u}(\\mathbf{x})$ 在波数向量 $\\mathbf{k}=(k_x, k_y)$ 处的傅里叶变换。傅里叶空间中的投影算子为：\n$$\n\\mathbf{P}(\\mathbf{k}) = \\mathbf{I} - \\frac{\\mathbf{k}\\mathbf{k}^\\top}{\\|\\mathbf{k}\\|^2} \\quad \\text{for } \\mathbf{k} \\neq \\mathbf{0}\n$$\n且 $\\mathbf{P}(\\mathbf{0}) = \\mathbf{I}$，其中 $\\mathbf{I}$ 是 $2 \\times 2$ 单位矩阵。波数向量由 $k_x = 2\\pi \\cdot \\text{fftfreq}(N, d=h)$ 和 $k_y = 2\\pi \\cdot \\text{fftfreq}(N, d=h)$ 给出。$\\mathbf{P}$ 的数值实现包括：\n- 对输入向量场 $\\mathbf{u}^*$ 进行二维快速傅里叶变换（FFT）。\n- 将投影矩阵 $\\mathbf{P}(\\mathbf{k})$ 逐元素地应用于每个傅里叶模态 $\\hat{\\mathbf{u}}^*(\\mathbf{k})$。\n- 进行二维逆FFT以获得物理空间中的投影场 $\\mathbf{u}^{n+1}$。\n\n**3. 插值算子 ($\\mathbf{J}$)**\n插值算子 $\\mathbf{J}$ 将欧拉速度场 $\\mathbf{u}$ 映射到拉格朗日点上的速度 $\\mathbf{U}$。它是散开算子 $\\mathbf{S}$ 的离散伴随算子。其作用由下式给出：\n$$\n\\mathbf{U}_\\ell = (\\mathbf{J}\\mathbf{u})_\\ell = \\sum_{i,j=0}^{N-1} \\mathbf{u}(\\mathbf{x}_{ij})\\,\\phi\\left(\\frac{|x_j - X_{\\ell,x}|_{\\text{periodic}}}{h}\\right)\\,\\phi\\left(\\frac{|y_i - X_{\\ell,y}|_{\\text{periodic}}}{h}\\right)\n$$\n与散开操作一样，这个求和在计算上被限制在每个 $\\mathbf{X}_\\ell$ 周围的 $4 \\times 4$ 模板内。\n\n### 矩阵组装与可解性分析\n矩阵 $\\mathbf{M}$ 是逐列组装的。$\\mathbf{M}$ 的第 $k$ 列是将算子序列 $\\mathbf{JPS}$ 应用于第 $k$ 个标准基向量 $\\mathbf{e}_k \\in \\mathbb{R}^{2N_b}$ 的结果。\n对于每个 $k \\in \\{1, \\dots, 2N_b\\}$：\n1.  设 $\\boldsymbol{\\lambda} = \\mathbf{e}_k$。\n2.  计算 $\\mathbf{u}^* = \\mathbf{S}\\boldsymbol{\\lambda}$，由于 $\\mathbf{u}^n=\\mathbf{0}$ 且 $\\Delta t=1$，这对应于中间速度。\n3.  计算 $\\mathbf{u}_{\\text{proj}} = \\mathbf{P}\\mathbf{u}^*$。\n4.  第 $k$ 列则为 $\\mathbf{m}_k = \\mathbf{J}\\mathbf{u}_{\\text{proj}}$。\n\n分析两个可解性条件：\n1.  **$\\mathbf{M}$ 的秩**：关于拉格朗日乘子的线性系统 $\\mathbf{M}\\boldsymbol{\\lambda} = \\mathbf{g}$ 具有唯一解当且仅当 $\\mathbf{M}$ 是满秩的。这通过使用奇异值分解（SVD）计算 $\\mathbf{M}$ 的奇异值来评估。如果其最小奇异值 $\\sigma_{\\min}$ 大于数值容差 $10^{-10}$，则认为矩阵是满秩的。$\\sigma_{\\min} \\approx 0$ 的值表示秩亏，例如，当拉格朗日点重合时（测试用例 B），可能导致线性相关的约束。\n2.  **平均散度**：具有周期性边界条件的压力泊松方程 $\\Delta p = \\frac{1}{\\Delta t}\\nabla \\cdot \\mathbf{u}^*$ 当且仅当右侧项的均值为零时是可解的，即 $\\int_{\\Omega} \\nabla \\cdot \\mathbf{u}^* d\\mathbf{x} = 0$。根据散度定理，对于周期域，这个条件是自动满足的。在离散情况下，此性质应在数值精度范围内成立。我们通过在周期网格上使用二阶中心差分格式计算 $\\mathbf{u}^*$ 的离散散度的均值来验证这一点：\n   $$\n   (\\nabla_h \\cdot \\mathbf{u}^*)_{ij} = \\frac{u^*_x(x_{i,j+1}) - u^*_x(x_{i,j-1})}{2h} + \\frac{u^*_y(x_{i+1,j}) - u^*_y(x_{i-1,j})}{2h}\n   $$\n   （其中指数对 $N$ 取模）。报告此量的均值的绝对值 $|\\overline{\\nabla_h \\cdot \\mathbf{u}^*}|$。我们期望这个值接近机器精度。\n\n实现将通过构建这些算子并对每个指定的测试用例进行分析来继续。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes the immersed boundary operator M for three test cases.\n    \"\"\"\n\n    def phi(r_in):\n        \"\"\"\n        Computes the four-point Peskin kernel phi(r) for r in grid units.\n        r_in is expected to be a numpy array of non-negative distances.\n        \"\"\"\n        r = np.asarray(r_in)\n        result = np.zeros_like(r, dtype=float)\n\n        # Condition for 0 = r  1\n        cond1 = r  1\n        r1 = r[cond1]\n        arg_sqrt1 = 1.0 + 4.0 * r1 - 4.0 * r1**2\n        arg_sqrt1[arg_sqrt1  0] = 0.0 # Guard against floating point error\n        result[cond1] = 0.125 * (3.0 - 2.0 * r1 + np.sqrt(arg_sqrt1))\n\n        # Condition for 1 = r  2\n        cond2 = (r >= 1)  (r  2)\n        r2 = r[cond2]\n        arg_sqrt2 = -7.0 + 12.0 * r2 - 4.0 * r2**2\n        arg_sqrt2[arg_sqrt2  0] = 0.0 # Guard against floating point error\n        result[cond2] = 0.125 * (5.0 - 2.0 * r2 - np.sqrt(arg_sqrt2))\n\n        return result\n\n    # --- Problem setup ---\n    test_suite = [\n        {'name': 'A', 'X': [(0.35, 0.72)]},\n        {'name': 'B', 'X': [(0.10, 0.90), (0.10, 0.90)]},\n        {'name': 'C', 'X': [(0.99, 0.02), (0.51, 0.49)]},\n    ]\n\n    N = 32\n    h = 1.0 / N\n    \n    # --- Pre-compute FFT-related quantities ---\n    k_vals = 2 * np.pi * np.fft.fftfreq(N, d=h)\n    kx, ky = np.meshgrid(k_vals, k_vals)\n    k_norm_sq = kx**2 + ky**2\n    # Inverse of k_norm_sq, handling the k=0 singularity\n    k_norm_sq_inv = np.divide(1.0, k_norm_sq, out=np.zeros_like(k_norm_sq), where=k_norm_sq!=0)\n\n    all_results = []\n\n    for case in test_suite:\n        X_lagrangian = np.array(case['X'])\n        N_b = len(X_lagrangian)\n        dim = 2 * N_b\n\n        def spread(lambdas_flat):\n            lambdas_vec = lambdas_flat.reshape((N_b, 2))\n            f_field = np.zeros((2, N, N))\n            \n            for l_idx in range(N_b):\n                lambda_x, lambda_y = lambdas_vec[l_idx]\n                if lambda_x == 0 and lambda_y == 0:\n                    continue\n                \n                X_x, X_y = X_lagrangian[l_idx]\n                ix_center = int(np.floor(X_x / h))\n                iy_center = int(np.floor(X_y / h))\n\n                for i_offset in range(-1, 3):\n                    i = (iy_center + i_offset) % N\n                    for j_offset in range(-1, 3):\n                        j = (ix_center + j_offset) % N\n                        \n                        grid_pt_x, grid_pt_y = j * h, i * h\n                        \n                        dist_x = abs(grid_pt_x - X_x)\n                        rx = min(dist_x, 1.0 - dist_x) / h\n                        \n                        dist_y = abs(grid_pt_y - X_y)\n                        ry = min(dist_y, 1.0 - dist_y) / h\n\n                        if rx  2.0 and ry  2.0:\n                            delta_h_val = phi(rx) * phi(ry) / h**2\n                            f_field[0, i, j] += delta_h_val * lambda_x\n                            f_field[1, i, j] += delta_h_val * lambda_y\n            return f_field\n\n        def interpolate(u_field):\n            U_interp_list = []\n            for l_idx in range(N_b):\n                U_x, U_y = 0.0, 0.0\n                X_x, X_y = X_lagrangian[l_idx]\n                ix_center = int(np.floor(X_x / h))\n                iy_center = int(np.floor(X_y / h))\n\n                for i_offset in range(-1, 3):\n                    i = (iy_center + i_offset) % N\n                    for j_offset in range(-1, 3):\n                        j = (ix_center + j_offset) % N\n                        \n                        grid_pt_x, grid_pt_y = j * h, i * h\n                        \n                        dist_x = abs(grid_pt_x - X_x)\n                        rx = min(dist_x, 1.0 - dist_x) / h\n                        \n                        dist_y = abs(grid_pt_y - X_y)\n                        ry = min(dist_y, 1.0 - dist_y) / h\n                        \n                        if rx  2.0 and ry  2.0:\n                            phi_prod = phi(rx) * phi(ry)\n                            U_x += u_field[0, i, j] * phi_prod\n                            U_y += u_field[1, i, j] * phi_prod\n                            \n                U_interp_list.extend([U_x, U_y])\n            return np.array(U_interp_list)\n\n        def project(u_field):\n            u_hat = np.fft.fft2(u_field, axes=(1, 2))\n            \n            k_dot_u_hat = kx * u_hat[0] + ky * u_hat[1]\n            u_hat_proj_x = u_hat[0] - kx * k_dot_u_hat * k_norm_sq_inv\n            u_hat_proj_y = u_hat[1] - ky * k_dot_u_hat * k_norm_sq_inv\n            \n            u_hat_proj = np.array([u_hat_proj_x, u_hat_proj_y])\n            u_proj = np.fft.ifft2(u_hat_proj, axes=(1, 2)).real\n            return u_proj\n\n        # --- Assemble matrix M and perform analysis ---\n        M = np.zeros((dim, dim))\n        mean_div = 0.0\n        \n        # We only need to calculate the mean divergence once, for any u_star that\n        # isn't identically zero. We use the one from the first column assembly.\n        u_star_for_div = None\n\n        for k in range(dim):\n            lambda_k = np.zeros(dim)\n            lambda_k[k] = 1.0\n            \n            # S operator: u_star = S(lambda_k)\n            u_star = spread(lambda_k)\n            if k == 0:\n                u_star_for_div = u_star\n            \n            # P operator\n            u_proj = project(u_star)\n            \n            # J operator\n            M[:, k] = interpolate(u_proj)\n            \n        if u_star_for_div is not None:\n            dux_dx = (np.roll(u_star_for_div[0], shift=-1, axis=1) - np.roll(u_star_for_div[0], shift=1, axis=1)) / (2 * h)\n            duy_dy = (np.roll(u_star_for_div[1], shift=-1, axis=0) - np.roll(u_star_for_div[1], shift=1, axis=0)) / (2 * h)\n            div_u_star = dux_dx + duy_dy\n            mean_div = np.abs(np.mean(div_u_star))\n        else: # Case with no lagrangian points\n            mean_div = 0.0\n\n        if dim > 0:\n            singular_values = linalg.svd(M, compute_uv=False)\n            sigma_min = np.min(singular_values)\n            is_full_rank = np.all(singular_values > 1e-10)\n        else: # Should not be reached by test cases\n            sigma_min = np.nan\n            is_full_rank = True\n\n        all_results.extend([sigma_min, is_full_rank, mean_div])\n    \n    # --- Format and print output ---\n    output_str_parts = []\n    for item in all_results:\n        if isinstance(item, bool):\n            output_str_parts.append(str(item).lower())\n        else:\n            output_str_parts.append(f\"{item:.12g}\")\n    print(f\"[{','.join(output_str_parts)}]\")\n\nsolve()\n```", "id": "3405586"}]}