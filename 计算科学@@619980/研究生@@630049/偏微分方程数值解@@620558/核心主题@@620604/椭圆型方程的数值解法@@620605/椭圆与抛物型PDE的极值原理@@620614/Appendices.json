{"hands_on_practices": [{"introduction": "在数值分析中，高阶格式因其收敛速度快而备受青睐。然而，在求解对流占优问题时，标准的中心差分格式可能会产生非物理的数值振荡，从而违背了极值原理。本练习将通过一个一维对流扩散方程的实例，让您亲手验证这一现象，并展示符合物理特性的迎风格式如何通过保持离散极值原理来确保解的稳定性。[@problem_id:3419376]", "problem": "考虑单位区间上的一维稳态对流扩散边界值问题，该问题具有常系数和狄利克雷边界条件：\n寻找一个在 $(0,1)$ 上的函数 $u(x)$，使得\n$- \\epsilon \\, u''(x) + a \\, u'(x) = 0$，对于 $x \\in (0,1)$，\n并满足边界条件 $u(0) = 0$ 和 $u(1) = 1$，其中 $\\epsilon > 0$ 是扩散系数，$a \\in \\mathbb{R}$ 是均匀对流速度。对于这个连续的一致椭圆算子，连续极值原理成立：$u$ 的最大值和最小值出现在边界上，因此对于所有 $x \\in [0,1]$，都有 $u(x) \\in [0,1]$。\n\n您的任务是通过数值离散化和计算来证明，对流项的中心差分格式在高佩克莱特数（Péclet number）下会违反离散极值原理，而迎风格式可以恢复该原理。\n\n从基本数值定义出发，按以下步骤进行：\n- 使用一个包含 $n$ 个内部点的均匀网格。设网格尺寸为 $h = 1/(n+1)$，网格节点为 $x_i = i h$，其中 $i=0,1,\\dots,n+1$。未知数为 $u_i \\approx u(x_i)$，其中 $i=1,\\dots,n$，而 $u_0 = 0$ 和 $u_{n+1} = 1$ 由边界值固定。\n- 为内部方程实现两个离散算子：\n  1. 一种中心格式，它对 $u''$ 使用标准的二阶中心差分，对 $u'$ 使用中心一阶差分。\n  2. 一种迎风格式，它对 $u''$ 使用中心差分，对 $u'$ 使用一阶迎风差分，并根据 $a$ 的符号切换方向。\n- 使用给定的狄利克雷数据，为内部未知数 $u_1,\\dots,u_n$ 组装相应的线性系统，求解它们，并重构包括边界在内的完整网格解。\n- 为这个齐次源问题（右端项等于 $0$）定义一个离散极值原理检查：离散解必须对所有网格节点 $i=0,1,\\dots,n+1$ 满足 $u_i \\in [0,1]$。如果 $\\min_i u_i  0 - \\tau$ 或 $\\max_i u_i > 1 + \\tau$，则宣告违反。使用数值容差 $\\tau = 10^{-12}$，即如果 $\\min_i u_i  0 - \\tau$ 或 $\\max_i u_i > 1 + \\tau$，则视为违反条件。\n- 对于下述测试集中的每个测试用例，计算两个布尔值：\n  - $b_{\\mathrm{cent}}$：中心格式是否违反上述定义的离散极值原理。\n  - $b_{\\mathrm{up}}$：迎风格式是否违反上述定义的离散极值原理。\n\n测试用例：\n- 用例 1：$\\epsilon = 10^{-3}$，$a = 2$，$n = 49$。\n- 用例 2：$\\epsilon = 10^{-1}$，$a = 1$，$n = 49$。\n- 用例 3：$\\epsilon = 10^{-2}$，$a = 1$，$n = 49$。\n- 用例 4：$\\epsilon = 10^{-3}$，$a = -2$，$n = 49$。\n- 用例 5：$\\epsilon = 5 \\cdot 10^{-3}$，$a = 20$，$n = 19$。\n\n注意：\n- 局部网格佩克莱特数是 $Pe = \\dfrac{|a| \\, h}{2 \\epsilon}$。高的 $Pe$ 值预计会引发中心格式的违规。\n- 无需报告物理单位；所有量均为无量纲。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个逗号分隔的对列表，每个测试用例对应一对，不含空格。每对必须是 $[b_{\\mathrm{cent}},b_{\\mathrm{up}}]$ 的形式，其中每个布尔值打印为字面量 $True$ 或 $False$。\n- 例如，包含两个用例的一行输出应如 $[[True,False],[False,False]]$。", "solution": "经评估，用户提供的问题是有效的。这是偏微分方程数值分析领域一个定义明确的任务，它基于既定的数学原理，没有任何矛盾、歧义或无效前提。其目标是数值地证明对流扩散方程有限差分格式的一个已知性质。\n\n问题要求在区域 $x \\in (0,1)$ 上求解一维稳态对流扩散方程：\n$$-\\epsilon u''(x) + a u'(x) = 0$$\n并满足狄利克雷边界条件 $u(0)=0$ 和 $u(1)=1$。此处，$\\epsilon > 0$ 是扩散系数，$a \\in \\mathbb{R}$ 是恒定对流速度。已知该问题的连续解满足极值原理，意味着其值受边界数据的最小值和最大值所限制，即 $u(x) \\in [0,1]$。我们将研究该性质对于离散近似是否成立。\n\n我们使用一个有 $n$ 个内部点的均匀网格来离散化区域 $(0,1)$。网格节点为 $x_i = ih$，其中 $i=0, 1, \\dots, n+1$，网格尺寸为 $h = 1/(n+1)$。给定值 $u_0=0$ 和 $u_{n+1}=1$。我们求解内部节点 $i=1, \\dots, n$ 的近似解 $u_i \\approx u(x_i)$。\n\n在任意内部节点 $x_i$ 处，我们使用有限差分来近似导数。二阶导数由标准的二阶中心差分近似：\n$$u''(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}$$\n将其代入控制方程，得到离散化形式：\n$$-\\epsilon \\left(\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\\right) + a \\cdot (\\text{approx } u'(x_i)) = 0$$\n\n我们现在将分析一阶导数项的两种不同格式。\n\n**1. 中心差分格式**\n\n一阶导数的中心差分近似是二阶精确的：\n$$u'(x_i) \\approx \\frac{u_{i+1} - u_{i-1}}{2h}$$\n将其代入离散化方程并乘以 $h^2$ 得：\n$$-\\epsilon(u_{i+1} - 2u_i + u_{i-1}) + a \\frac{h}{2}(u_{i+1} - u_{i-1}) = 0$$\n我们重排各项，将未知数 $u_{i-1}$、$u_i$ 和 $u_{i+1}$ 分组：\n$$\\left(-\\epsilon - \\frac{ah}{2}\\right)u_{i-1} + (2\\epsilon)u_i + \\left(-\\epsilon + \\frac{ah}{2}\\right)u_{i+1} = 0$$\n该方程对每个内部节点 $i=1, \\dots, n$ 都成立。这构成了一个关于 $n$ 个未知数 $\\boldsymbol{u} = [u_1, u_2, \\dots, u_n]^T$ 的 $n$ 个线性方程组。该系统可写作 $A\\boldsymbol{u} = \\boldsymbol{b}$。矩阵 $A$ 是一个 $n \\times n$ 的三对角矩阵，其第 $i$ 行的元素如下：\n\\begin{itemize}\n    \\item 次对角线 ($j = i-1$)：$A_{i, i-1} = -\\epsilon - \\frac{ah}{2}$\n    \\item 主对角线 ($j = i$)：$A_{i, i} = 2\\epsilon$\n    \\item 超对角线 ($j = i+1$)：$A_{i, i+1} = -\\epsilon + \\frac{ah}{2}$\n\\end{itemize}\n右端向量 $\\boldsymbol{b}$ 是通过将涉及已知边界值的项移到右边形成的。\n对于 $i=1$：含 $u_0=0$ 的项消失。\n对于 $i=n$：涉及 $u_{n+1}=1$ 的项被移到右边：\n$$A_{n, n-1} u_{n-1} + A_{n,n} u_n = -A_{n,n+1} u_{n+1} = -\\left(-\\epsilon + \\frac{ah}{2}\\right) \\cdot 1 = \\epsilon - \\frac{ah}{2}$$\n所以，$\\boldsymbol{b} = [0, 0, \\dots, 0, \\epsilon - ah/2]^T$。\n\n如果矩阵 $A$ 是一个 M-矩阵，则离散极值原理得到保证。一个充分条件是 $A$ 是对角占优的，其对角线元素为正，非对角线元素为非正。对角线元素 $2\\epsilon$ 是正的。非对角线元素必须为非正：\n$$-\\epsilon - \\frac{ah}{2} \\le 0 \\quad \\text{和} \\quad -\\epsilon + \\frac{ah}{2} \\le 0$$\n这可以简化为 $|ah| \\le 2\\epsilon$，或 $\\frac{|a|h}{2\\epsilon} \\le 1$。量 $Pe = \\frac{|a|h}{2\\epsilon}$ 是网格佩克莱特数。如果 $Pe > 1$，其中一个非对角线元素将变为正，矩阵不再保证是 M-矩阵，可能会出现违反极值原理的伪振荡。\n\n**2. 迎风差分格式**\n\n迎风格式对对流项使用一阶单边差分，其方向根据对流速度 $a$ 的符号来选择。\n\n情况1：$a \\ge 0$ (向右流动)\n我们使用后向差分：$u'(x_i) \\approx \\frac{u_i - u_{i-1}}{h}$。\n离散化方程为：\n$$-\\epsilon \\left(\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\\right) + a \\left(\\frac{u_i - u_{i-1}}{h}\\right) = 0$$\n乘以 $h^2$ 并重排：\n$$(-\\epsilon - ah)u_{i-1} + (2\\epsilon + ah)u_i - \\epsilon u_{i+1} = 0$$\n矩阵元素为：$A_{i, i-1} = -\\epsilon - ah$，$A_{i, i} = 2\\epsilon + ah$，$A_{i, i+1} = -\\epsilon$。\n最后一个方程（$i=n$）的右端项变为 $b_n = -A_{n,n+1} u_{n+1} = -(-\\epsilon) \\cdot 1 = \\epsilon$。\n\n情况2：$a  0$ (向左流动)\n我们使用前向差分：$u'(x_i) \\approx \\frac{u_{i+1} - u_i}{h}$。\n离散化方程为：\n$$-\\epsilon \\left(\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\\right) + a \\left(\\frac{u_{i+1} - u_i}{h}\\right) = 0$$\n乘以 $h^2$ 并重排：\n$$-\\epsilon u_{i-1} + (2\\epsilon - ah)u_i + (-\\epsilon + ah)u_{i+1} = 0$$\n矩阵元素为：$A_{i, i-1} = -\\epsilon$，$A_{i, i} = 2\\epsilon - ah$，$A_{i, i+1} = -\\epsilon + ah$。\n最后一个方程（$i=n$）的右端项变为 $b_n = -A_{n,n+1} u_{n+1} = -(-\\epsilon + ah) \\cdot 1 = \\epsilon - ah$。\n\n在两种迎风情况下，对于任何 $\\epsilon > 0$ 和 $h > 0$，对角线元素均为正，非对角线元素均为非正。该矩阵是对角占优的。因此，它是一个 M-矩阵，离散极值原理总是被满足，无论佩克莱特数是多少。\n\n**数值验证**\n每个测试用例的步骤如下：\n1. 对于一组给定的参数 $(\\epsilon, a, n)$，计算网格尺寸 $h$。\n2. 对于中心格式和迎风格式，分别组装 $n \\times n$ 的三对角矩阵 $A$ 和 $n \\times 1$ 的右端向量 $\\boldsymbol{b}$。\n3. 求解线性系统 $A\\boldsymbol{u} = \\boldsymbol{b}$ 以获得内部解向量 $\\boldsymbol{u}$。\n4. 通过前置 $u_0=0$ 和后置 $u_{n+1}=1$ 来构造完整解。\n5. 检查完整解是否违反极值原理：$\\min(u)  0 - \\tau$ 或 $\\max(u) > 1 + \\tau$，其中容差 $\\tau=10^{-12}$。\n6. 记录违规的布尔结果 $b_{\\mathrm{cent}}$ 和 $b_{\\mathrm{up}}$。\n\n对问题陈述中提供的每个测试用例重复此过程，以证明中心格式在高佩克莱特数下的失效以及迎风格式的鲁棒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef compute_solution_and_check_violation(epsilon, a, n, scheme, tau):\n    \"\"\"\n    Solves the 1D convection-diffusion equation and checks for max principle violation.\n\n    Args:\n        epsilon (float): Diffusion coefficient.\n        a (float): Convection speed.\n        n (int): Number of interior grid points.\n        scheme (str): 'centered' or 'upwind'.\n        tau (float): Numerical tolerance for violation check.\n\n    Returns:\n        bool: True if the maximum principle is violated, False otherwise.\n    \"\"\"\n    # Grid setup\n    h = 1.0 / (n + 1)\n    \n    # Boundary values\n    u0 = 0.0\n    u_np1 = 1.0\n    \n    # Initialize linear system\n    A = np.zeros((n, n))\n    b = np.zeros(n)\n    \n    # Assemble matrix A and vector b based on the scheme\n    if scheme == 'centered':\n        c_sub = -epsilon - a * h / 2.0\n        c_diag = 2.0 * epsilon\n        c_super = -epsilon + a * h / 2.0\n        \n        # Populate diagonals\n        if n > 0:\n            np.fill_diagonal(A, c_diag)\n        if n > 1:\n            np.fill_diagonal(A[1:], c_sub)\n            np.fill_diagonal(A[:, 1:], c_super)\n        \n        # Boundary conditions in RHS\n        # b[0] -= c_sub * u0 is a no-op since u0=0\n        if n > 0:\n            b[n-1] -= c_super * u_np1\n\n    elif scheme == 'upwind':\n        if a >= 0: # Upstream is i-1\n            c_sub = -epsilon - a * h\n            c_diag = 2.0 * epsilon + a * h\n            c_super = -epsilon\n        else: # a  0, upstream is i+1\n            c_sub = -epsilon\n            c_diag = 2.0 * epsilon - a * h\n            c_super = -epsilon + a * h\n            \n        # Populate diagonals\n        if n > 0:\n            np.fill_diagonal(A, c_diag)\n        if n > 1:\n            np.fill_diagonal(A[1:], c_sub)\n            np.fill_diagonal(A[:, 1:], c_super)\n            \n        # Boundary conditions in RHS\n        # b[0] -= c_sub * u0 is a no-op since u0=0\n        if n > 0:\n            b[n-1] -= c_super * u_np1\n    else:\n        raise ValueError(f\"Unknown scheme: {scheme}\")\n        \n    # Solve for interior points\n    if n > 0:\n        u_interior = np.linalg.solve(A, b)\n    else:\n        u_interior = np.array([])\n    \n    # Reconstruct full solution including boundaries\n    u_full = np.concatenate(([u0], u_interior, [u_np1]))\n    \n    # Check for maximum principle violation\n    min_u = np.min(u_full)\n    max_u = np.max(u_full)\n    \n    violation = (min_u  (0.0 - tau)) or (max_u > (1.0 + tau))\n    \n    return violation\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1e-3, 2, 49),          # Case 1\n        (1e-1, 1, 49),          # Case 2\n        (10e-3, 1, 49),         # Case 3 (epsilon=10e-3 is 1e-2)\n        (1e-3, -2, 49),         # Case 4\n        (5e-3, 20, 19),         # Case 5\n    ]\n    \n    # Numerical tolerance for checking the violation\n    tau = 1e-12\n\n    results_list = []\n    for case in test_cases:\n        eps, a, n = case\n        \n        # Check violation for centered scheme\n        b_cent = compute_solution_and_check_violation(eps, a, n, 'centered', tau)\n        \n        # Check violation for upwind scheme\n        b_up = compute_solution_and_check_violation(eps, a, n, 'upwind', tau)\n        \n        # Format as string '[Bool,Bool]'\n        results_list.append(f\"[{b_cent},{b_up}]\")\n\n    # Final print statement in the exact required format.\n    # e.g., [[True,False],[False,False]]\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n```", "id": "3419376"}, {"introduction": "从有限差分法转向更具几何灵活性的有限元法（FEM）时，离散极值原理的有效性变得更加微妙。它不再是自动保证的，而是与网格的几何质量密切相关。这个实践将引导您探究一个关键的几何条件——非钝角条件——如何保证有限元解满足极值原理，并通过数值实验直观地观察当此条件被违背时产生的“过冲”现象。[@problem_id:3419375]", "problem": "考虑一个椭圆偏微分方程的标量扩散模型问题，该问题定义在方形域 $\\Omega = [0,1]\\times [0,1]$ 上，并带有狄利克雷边界条件。连续模型为：找到 $u:\\Omega\\to\\mathbb{R}$ 使得\n$$\n-\\Delta u = f \\quad \\text{in } \\Omega, \\qquad u = g \\quad \\text{on } \\partial\\Omega,\n$$\n其中源项为常数 $f(x,y) = -1$，边界数据为 $g(x,y) = x$。强极值原理指出，如果 $-\\Delta u \\le 0$（等价于 $f \\le 0$），那么解的最大值在边界上达到。因此，连续解满足 $\\max_{\\Omega} u \\le \\max_{\\partial \\Omega} g = 1$。\n\n我们使用协调分片线性有限元方法 (FEM) 在 $\\Omega$ 的一个三角剖分上对此模型进行离散化。组装过程使用标准的双线性形式，其中局部单元梯度在每个三角形上是常数。对于一个顶点为 $(x_i,y_i)$（$i\\in\\{1,2,3\\}$）的三角形，记其面积为 $A$，局部形函数的梯度为 $\\nabla N_i = \\frac{1}{2A}(b_i,c_i)$，其中 $b_i$ 和 $c_i$ 以常规方式由顶点坐标计算得出。局部刚度系数满足\n$$\nK_e(i,j) = \\int_{T} \\nabla N_i \\cdot \\nabla N_j\\,dx = \\frac{b_i b_j + c_i c_j}{4A},\n$$\n对于常数源项 $f=-1$，局部载荷向量的项为\n$$\nF_e(i) = \\int_{T} N_i f\\,dx = -\\frac{A}{3}.\n$$\n全局组装后强施加狄利克雷边界条件，会产生一个关于节点值 $u_h$ 的稀疏线性系统 $K u_h = F$。\n\n有限元方法的离散极值原理 (DMP) 指出，如果全局刚度矩阵是一个 $M$-矩阵（对于各向同性扩散，在非钝角三角剖分上这一点能得到保证），那么对于 $f\\le 0$ 有 $\\max_{\\Omega_h} u_h \\le \\max_{\\partial\\Omega_h} g$。然而，在包含钝角三角形的三角剖分上，刚度矩阵的非对角元可能变为正值，从而违反 $M$-矩阵结构并可能破坏 DMP，使得数值解出现超出边界最大值的过冲。\n\n你的任务是：\n- 构建 $\\Omega$ 的特定三角剖分，以说明 FEM DMP 的满足和违反情况。\n- 对每个三角剖分解离散 FEM 问题。\n- 量化过冲，其定义为\n$$\n\\text{overshoot} := \\max\\left\\{0,\\ \\max_i u_h(i) - \\max_{j\\in\\partial\\Omega} g_j\\right\\},\n$$\n其中边界节点值的最大值为 $\\max_{j\\in\\partial\\Omega} g_j = 1$，因为在 $\\partial\\Omega$ 上 $g(x,y)=x$。\n\n使用的基本假设：\n- 对于 $f\\le 0$ 的椭圆算子，强极值原理意味着在连续情况下，解有一个由边界最大值决定的上界。\n- 分片线性（仿射）FEM 的刚度组装在三角形上使用具有上述局部公式的常数梯度。\n- 当组装的刚度矩阵是 $M$-矩阵时，FEM 的离散极值原理成立，这在各向同性扩散的非钝角网格上得到保证。\n\n三角剖分设计：\n- 使用一个简单的 5 节点网格，包含单位正方形的四个角点和一个内部节点。将内部节点与所有四个角点连接，形成 4 个三角形。\n- 对于非钝角三角剖分，将内部节点放置在中心 $(0.5,0.5)$，这会在内部节点处产生直角。\n- 对于钝角三角剖分，将内部节点沿一根轴向边界移动以引入钝角。判断刚度矩阵是否失去 $M$-矩阵性质，可以通过检查全局组装矩阵中是否存在正的非对角元来完成。\n\n测试套件：\n- 情况 $\\mathbf{A}$（理想情况，DMP 满足）：内部节点位于 $(0.5,0.5)$。\n- 情况 $\\mathbf{B}$（通过垂直移动产生钝角）：沿垂直线 $x=0.5$ 搜索内部节点，以找到一个位置 $(0.5,y)$，使得组装后的全局刚度矩阵至少有一个正的非对角元，表明 DMP 被违反。\n- 情况 $\\mathbf{C}$（通过水平移动产生钝角）：沿水平线 $y=0.5$ 搜索内部节点，以找到一个位置 $(x,0.5)$，使其在某个非对角元上满足相同的正值条件。\n\n算法要求：\n- 使用 $f=-1$ 的局部三角形公式组装全局刚度矩阵 $K$ 和载荷向量 $F$。\n- 通过适当地重置行和列来强施加狄利克雷边界条件，并将边界节点的对角元设置为 1，同时将右端项设置为这些节点上的边界数据 $g$。\n- 求解 $K u_h = F$。\n- 为每种情况计算如上定义的过冲。\n\n角度单位：如果在概念上使用任何角度来检查钝角性，所有角度都应以度为单位处理；但是，程序将通过非对角元的符号来数值上检查 $M$-矩阵条件，而不需要显式地计算角度。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含情况 $\\mathbf{A}$、$\\mathbf{B}$ 和 $\\mathbf{C}$ 的过冲结果，格式为方括号括起来的逗号分隔列表（例如，$[r_A,r_B,r_C]$），其中每个 $r_\\cdot$ 是一个浮点数。\n\n无需外部输入。所有计算都是无量纲的；不涉及物理单位。通过使用双精度算术确保数值稳定性。", "solution": "用户希望验证并解决一个关于泊松方程有限元方法 (FEM) 离散的离散极值原理 (DMP) 的问题。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n-   **PDE 模型**：找到 $u:\\Omega\\to\\mathbb{R}$ 使得在 $\\Omega = [0,1]\\times [0,1]$ 中 $-\\Delta u = f$。\n-   **源项**：$f(x,y) = -1$。\n-   **边界条件**：在 $\\partial\\Omega$ 上 $u = g$，其中 $g(x,y) = x$。\n-   **连续极值原理推论**：$\\max_{\\Omega} u \\le \\max_{\\partial \\Omega} g = 1$。\n-   **离散化**：协调分片线性有限元方法 (P1 FEM)。\n-   **局部刚度公式**：对于面积为 $A$、顶点为 $i,j,k$ 的三角形 $T$，刚度系数为 $K_e(i,j) = \\int_{T} \\nabla N_i \\cdot \\nabla N_j\\,dx = \\frac{b_i b_j + c_i c_j}{4A}$，其中形函数梯度为 $\\nabla N_i = \\frac{1}{2A}(b_i,c_i)$。\n-   **局部载荷向量公式**：对于 $f=-1$，载荷向量项为 $F_e(i) = \\int_{T} N_i f\\,dx = -\\frac{A}{3}$。\n-   **边界条件施加方式**：强施加。\n-   **离散极值原理条件**：全局刚度矩阵 $K$ 必须是一个 M-矩阵，对于各向同性扩散，在非钝角三角剖分上这一点能得到保证。\n-   **过冲定义**：$\\text{overshoot} := \\max\\left\\{0,\\ \\max_i u_h(i) - \\max_{j\\in\\partial\\Omega} g_j\\right\\}$。边界最大值为 $\\max g = 1$。\n-   **网格几何形状**：一个 5 节点网格，包含单位正方形的四个角点 $(0,0), (1,0), (1,1), (0,1)$ 和一个内部节点，形成 4 个三角形。\n-   **测试用例**：\n    -   情况 A (非钝角)：内部节点位于 $(0.5,0.5)$。\n    -   情况 B (钝角)：内部节点位于 $(0.5,y)$，该位置的选择使得 $K$ 不是 M-矩阵。\n    -   情况 C (钝角)：内部节点位于 $(x,0.5)$，该位置的选择使得 $K$ 不是 M-矩阵。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n-   **科学依据**：该问题基于偏微分方程数值分析的标准、公认的原理，特别是针对椭圆问题的有限元方法。离散极值原理、M-矩阵和网格几何（非钝角与钝角）之间的联系是一个经典课题。所提供的公式对于 P1 FEM 是正确的。该问题在科学上是合理的。\n-   **良态性**：连续问题是具有狄利克雷边界数据的良态泊松方程。离散问题涉及求解一个线性系统 $K u_h = F$。对于这个只有一个内部自由度的特定网格，该系统简化为关于内部节点值的单个标量方程。由于算子 $-\\Delta$ 的刚度矩阵 $K$ 是对称正定的，内部节点的对角元将严格为正，从而保证了唯一解。该问题是良态的。\n-   **客观性**：语言正式、精确且数学化。没有主观或模糊的陈述。\n-   **完整性和一致性**：提供了所有必要的数据、方程和定义。问题要求在情况 B 和 C 中“搜索”节点位置，这可以通过提供一个从分析中派生出的有效实例来满足，以展示该原理。设置是完整和一致的。\n\n**步骤 3：结论与行动**\n\n该问题是有效的。将提供一个合理的解决方案。\n\n### 解决方案\n\n该问题要求在单位正方形 $\\Omega = [0,1]\\times[0,1]$ 上求解泊松方程 $-\\Delta u = -1$，边界数据为 $u(x,y)=x$。我们的任务是使用分片线性有限元方法 (FEM) 来展示离散极值原理 (DMP) 的满足和违反情况。\n\nDMP 是连续极值原理的一个离散模拟。对于给定的问题，连续解在边界上达到其最大值，即 $u(x,y) \\le \\max_{\\partial\\Omega} g = 1$。DMP 指出，在某些条件下，离散解 $u_h$ 也满足此性质：$\\max_i u_h(i) \\le \\max_{j \\in \\partial\\Omega_h} g_j$。对于 FEM，DMP 成立的一个充分条件是全局刚度矩阵 $K$ 是一个 M-矩阵。M-矩阵具有正的对角元和非正的非对角元。\n\n对于算子 $-\\Delta$，刚度矩阵的非对角元 $K_{ij}$ 对应于两个三角形 $T_1$ 和 $T_2$ 共享的一条内部边，其由 $K_{ij} = -\\frac{1}{2}\\left(\\cot\\theta_1 + \\cot\\theta_2\\right)$ 给出，其中 $\\theta_1$ 和 $\\theta_2$ 是每个三角形中与边 $(i,j)$ 相对的角。如果三角剖分是非钝角的（所有角 $\\le 90^\\circ$），那么所有的余切值都是非负的，因此所有的非对角元 $K_{ij}$ 都是非正的。这确保了 $K$ 是一个 M-矩阵，且 DMP 成立。如果一个三角形包含一个钝角（例如 $\\theta_1 > 90^\\circ$），其对应的余切值为负。如果 $|\\cot\\theta_1| > \\cot\\theta_2$，则 $K_{ij}$ 会变为正值，违反 M-矩阵性质，并可能导致 DMP 失效，从而产生非物理振荡或“过冲”，即数值解超过边界最大值。\n\n我们构建一个 5 节点网格，节点位于单位正方形的角点（索引为 0 到 3）和一个内部节点（索引为 4）。这构成了四个三角形。自由度是节点值 $u_h(i)$。边界节点（0,1,2,3）的值由狄利克雷条件 $g(x,y)=x$ 固定。唯一未知的是内部节点处的 $u_h(4)$ 值。\n\nFEM 离散化导出一个线性系统 $K u_h = F$。组装后，我们施加边界条件。系统可以划分为内部（I）和边界（B）节点。内部自由度 $u_I$ 的方程是 $K_{II} u_I = F_I - K_{IB} g_B$。在我们的情况下， $I=\\{4\\}$，因此这简化为单个标量方程：\n$$\nK_{44} u_h(4) = F_4 - \\sum_{j=0}^{3} K_{4j} g(x_j, y_j)\n$$\n边界值为 $g_0 = g(0,0) = 0$, $g_1 = g(1,0) = 1$, $g_2 = g(1,1) = 1$, 和 $g_3 = g(0,1) = 0$。边界最大值为 $\\max_{j\\in\\partial\\Omega} g_j = 1$。过冲计算为 $\\max\\{0, u_h(4) - 1\\}$。\n\n步骤如下：\n1.  为每个测试用例定义节点坐标。\n2.  使用提供的局部公式组装 $5\\times5$ 的全局刚度矩阵 $K$ 和 $5\\times1$ 的载荷向量 $F$。源项 $f=-1$ 意味着内部节点上的总载荷为 $F_4 = \\sum_e (-A_e/3) = -(\\text{总面积})/3 = -1/3$，这与内部节点的位置无关。\n3.  求解关于 $u_h(4)$ 的标量方程。\n4.  计算过冲。\n\n**情况 A：内部节点位于 $(0.5, 0.5)$**\n四个三角形是全等的等腰直角三角形。角度为 $90^\\circ$ 和 $45^\\circ$。该三角剖分是非钝角的。刚度矩阵 $K$ 将是一个 M-矩阵。DMP 成立，我们预期过冲为零。计算表明 $u_h(4) = 5/12 \\approx 0.4167$，小于 1，因此过冲为 0。\n\n**情况 B：内部节点位于 $(0.5, y)$ 的钝角三角剖分**\n为了违反 M-矩阵性质，我们必须引入一个钝角。将内部节点置于 $(0.5, y)$ 且 $|y-0.5|$ 较大时（例如 $y$ 接近 0 或 1）会使得一些角为钝角。分析表明，当内部节点 $(0.5, y)$ 满足 $|y|  0.5$ 时，连接 $(0,0)$ 和 $(1,0)$ 的三角形在其内部节点处有一个钝角。我们选择 $y=0.1$ 作为一个代表点。这个选择会使 $K$ 的一个非对角元为正，从而打破 M-矩阵结构并可能导致过冲。\n\n**情况 C：内部节点位于 $(x, 0.5)$ 的钝角三角剖分**\n与情况 B 对称，当内部节点置于 $(x, 0.5)$ 且 $|x|  0.5$ 时，会引入钝角。我们选择 $x=0.1$。这会使三角形 $(0,3,4)$ 内位于内部节点的角为钝角，再次违反 M-矩阵条件。\n\n下面的 Python 代码为这三种情况实现了此过程并计算了由此产生的过冲。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _calculate_local_matrices(coords: np.ndarray):\n    \"\"\"\n    Computes the local stiffness matrix and load vector for a single triangular element.\n\n    Args:\n        coords: A 3x2 numpy array of vertex coordinates (x, y).\n\n    Returns:\n        A tuple (Ke, Fe) where Ke is the 3x3 local stiffness matrix and\n        Fe is the 3-element local load vector.\n    \"\"\"\n    p1, p2, p3 = coords\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n\n    # Area of the triangle using the shoelace formula\n    area = 0.5 * np.abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n    if area  1e-12:\n        raise ValueError(\"Triangle with zero or near-zero area detected.\")\n\n    # b and c coefficients related to the gradients of the P1 basis functions\n    # For a cycle (i,j,k), b_i = y_j - y_k, c_i = x_k - x_j\n    b_coeffs = np.array([y2 - y3, y3 - y1, y1 - y2])\n    c_coeffs = np.array([x3 - x2, x1 - x3, x2 - x1])\n\n    # Local stiffness matrix Ke(i,j) = (b_i*b_j + c_i*c_j) / (4*Area)\n    # This derives from integrating grad(N_i) . grad(N_j) over the triangle.\n    Ke = np.zeros((3, 3), dtype=np.float64)\n    for i in range(3):\n        for j in range(3):\n            Ke[i, j] = (b_coeffs[i] * b_coeffs[j] + c_coeffs[i] * c_coeffs[j]) / (4.0 * area)\n\n    # Local load vector for a constant source f = -1\n    # Fe(i) = integral(N_i * f) dx = f * Area / 3\n    Fe = (-area / 3.0) * np.ones(3, dtype=np.float64)\n\n    return Ke, Fe\n\ndef _calculate_overshoot(interior_node_coords: tuple[float, float]):\n    \"\"\"\n    Assembles the global system for the 5-node mesh, solves for the single \n    interior node, and computes the overshoot.\n\n    Args:\n        interior_node_coords: A tuple (x, y) for the interior node.\n\n    Returns:\n        The computed overshoot value.\n    \"\"\"\n    # 5-node mesh: 4 corners of the unit square and 1 interior node\n    nodes = np.array([\n        [0.0, 0.0],  # Node 0: (0,0)\n        [1.0, 0.0],  # Node 1: (1,0)\n        [1.0, 1.0],  # Node 2: (1,1)\n        [0.0, 1.0],  # Node 3: (0,1)\n        interior_node_coords  # Node 4: interior\n    ], dtype=np.float64)\n\n    # Triangulation: connect interior node to all corners\n    elements = np.array([\n        [0, 1, 4],\n        [1, 2, 4],\n        [2, 3, 4],\n        [3, 0, 4]\n    ])\n\n    num_nodes = len(nodes)\n    K = np.zeros((num_nodes, num_nodes), dtype=np.float64)\n    F = np.zeros(num_nodes, dtype=np.float64)\n\n    # Assemble global stiffness matrix K and load vector F\n    for i, elem_nodes in enumerate(elements):\n        elem_coords = nodes[elem_nodes]\n        Ke, Fe = _calculate_local_matrices(elem_coords)\n        \n        # Add local contributions to global matrices\n        for local_i in range(3):\n            global_i = elem_nodes[local_i]\n            F[global_i] += Fe[local_i]\n            for local_j in range(3):\n                global_j = elem_nodes[local_j]\n                K[global_i, global_j] += Ke[local_i, local_j]\n    \n    # Boundary values g(x,y)=x. Nodes 0,1,2,3 are on the boundary.\n    g_boundary = np.array([\n        nodes[0, 0],  # g(0,0) = 0\n        nodes[1, 0],  # g(1,0) = 1\n        nodes[2, 0],  # g(1,1) = 1\n        nodes[3, 0]   # g(0,1) = 0\n    ], dtype=np.float64)\n\n    # Apply strong Dirichlet BCs by solving for the single interior node (node 4)\n    # The system is K_II * u_I = F_I - K_IB * u_B, where I={4} and B={0,1,2,3}\n    boundary_indices = [0, 1, 2, 3]\n    interior_index = 4\n    \n    # K_IB * u_B part of the equation\n    rhs_boundary_contribution = 0.0\n    for i, b_idx in enumerate(boundary_indices):\n        rhs_boundary_contribution += K[interior_index, b_idx] * g_boundary[i]\n    \n    # Full RHS: F_I - K_IB * u_B\n    rhs_total = F[interior_index] - rhs_boundary_contribution\n    \n    # Solve the 1x1 system for the interior node: K_II * u_I = rhs_total\n    u4 = rhs_total / K[interior_index, interior_index]\n    \n    # Full discrete solution vector\n    u_h = np.zeros(num_nodes, dtype=np.float64)\n    u_h[boundary_indices] = g_boundary\n    u_h[interior_index] = u4\n    \n    # Maximum value of the boundary data g is 1\n    max_g = 1.0\n    \n    # Overshoot is the amount by which the solution maximum exceeds the boundary maximum\n    overshoot = max(0.0, np.max(u_h) - max_g)\n    \n    return overshoot\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Test suite from the problem statement.\n    # Locations for Cases B and C are chosen based on analysis to produce\n    # obtuse triangles and violate the M-matrix condition.\n    test_cases = [\n        (0.5, 0.5),  # Case A: Non-obtuse, DMP satisfied\n        (0.5, 0.1),  # Case B: Obtuse via vertical shift, DMP violated\n        (0.1, 0.5),  # Case C: Obtuse via horizontal shift, DMP violated\n    ]\n\n    results = []\n    for case_coords in test_cases:\n        overshoot = _calculate_overshoot(case_coords)\n        results.append(overshoot)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3419375"}, {"introduction": "除了作为理论分析的基石，极值原理在计算科学中也是一个用于软件验证的强大工具。这个综合性练习将指导您使用“人造解方法”（method of manufactured solutions）构建一个自动化测试框架。您将为椭圆型和抛物型方程的数值格式编写测试，自动检测其是否遵循离散极值原理，从而将理论与可靠的科学计算实践紧密联系起来。[@problem_id:3419390]", "problem": "考虑使用人造解方法对椭圆和抛物型偏微分方程的极值原理进行离散验证。目标是构建一个测试框架，当边界数据和初始条件施加已知的 $L^{\\infty}$ 界时，能够自动检测有限差分格式中违反离散极值原理（DMP）的情况。所有量均为无量纲。在整个问题中，空间计算域是单位正方形 $\\Omega = [0,1] \\times [0,1]$，且网格是均匀和对齐的。假设以下基本事实成立：(i) 关于拉普拉斯算子的连续弱极值原理指出，若在 $\\Omega$ 中 $\\Delta u \\ge 0$ 且 $u$ 在 $\\overline{\\Omega}$ 上连续，则 $u$ 在 $\\overline{\\Omega}$ 上的最大值在边界 $\\partial \\Omega$ 上达到；若 $\\Delta u \\le 0$，则 $u$ 的最小值在边界 $\\partial \\Omega$ 上达到；(ii) 对于带有狄利克雷边界条件的热方程 $u_t = \\Delta u$，其极值原理指出，对于 $t \\ge 0$，$u$ 在时空域上的本质上确界不超过初始数据和边界数据并集的上确界，对于下确界也有类似结论。这些原理为离散格式中的单调性约束提供了理论依据。\n\n您必须实现以下验证任务：\n\n1.  椭圆方程验证（Laplace 和 Poisson 方程）：\n    -   在大小为 $N \\times N$ 的均匀内部网格上，使用算子 $-\\Delta$ 的五点有限差分近似，网格间距为 $h = 1/(N+1)$，内部节点索引为 $(i,j)$，其中 $i,j \\in \\{1,\\dots,N\\}$。对于离散拉普拉斯算子，构建稀疏矩阵，其对角线元素为 $4/h^2$，四个基本方向上直接相邻节点的元素为 $-1/h^2$。通过修改右侧项来并入狄利克雷边界条件（当相邻节点位于边界上时，将已知的边界值乘以 $1/h^2$ 并加到右侧项中）。\n    -   人造边界数据情况（调和边界延拓）：在 $\\partial \\Omega$ 上施加边界数据 $u(x,y) = x$，并在内部节点上求解离散 Laplace 方程 $-\\Delta_h u_h = 0$。离散极值原理预测 $u_h$ 的界在区间 $[0,1]$ 内，因为边界数据的最小值为 $0$，最大值为 $1$。\n    -   人造源项情况（非负强迫项）：在 $\\partial \\Omega$ 上施加齐次狄利克雷边界数据 $u = 0$，并在内部节点上求解离散 Poisson 问题 $-\\Delta_h u_h = f$，其中 $f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y) \\ge 0$。当矩阵是 $M$-矩阵且 $f \\ge 0$ 时，离散最小极值原理预测内部节点上的解 $u_h \\ge 0$。\n    -   对于这两个椭圆方程测试，在内部节点上以容差 $\\tau = 10^{-12}$ 数值验证相应的 DMP 断言。\n\n2.  抛物型方程验证（热方程的显式向前 Euler 格式）：\n    -   考虑在内部尺寸为 $N \\times N$、间距为 $h = 1/(N+1)$ 的均匀网格上，使用显式向前 Euler 方法求解带有狄利克雷边界条件 $u = 0$ on $\\partial \\Omega$ 的热方程 $u_t = \\Delta u$ 的有限差分格式。令 $r = \\Delta t / h^2$。该格式通过以下方式更新内部节点：\n        $$u_{i,j}^{n+1} = u_{i,j}^{n} + r\\left(u_{i+1,j}^{n} + u_{i-1,j}^{n} + u_{i,j+1}^{n} + u_{i,j-1}^{n} - 4u_{i,j}^{n}\\right).$$\n        -   使用初始条件 $u^0(x,y) = \\sin(\\pi x)\\sin(\\pi y)$，该条件在内部节点上满足 $u^0 \\ge 0$ 和 $\\|u^0\\|_{\\infty} = 1$，并在所有时间步 $n$ 上使用零边界数据 $u^n = 0$ on $\\partial \\Omega$。\n        -   在 $T$ 个时间步中，对每个时间步 $n$ 验证离散极值原理断言：具体而言，检查在系数约束 $r \\le 1/4$ 成立的条件下，$u_{i,j}^{n}$ 是否保持在区间 $[0, \\|u^0\\|_{\\infty}]$ 内（容差为 $\\tau = 10^{-12}$）。该约束条件使更新成为相邻值的凸组合，从而保证了单调性。\n        -   通过运行一个 $r > 1/4$ 的案例来演示 DMP 违规的检测；如果在任何步骤中 $u_{i,j}^{n}$ 超出容差范围落在了区间 $[0, \\|u^0\\|_{\\infty}]$ 之外，则标记为违规。\n\n您必须实现一个程序，构建并运行以下测试套件。对于所有测试，使用 $N = 31$，容差 $\\tau = 10^{-12}$，在抛物型方程测试中使用 $T = 50$ 个时间步。每个测试返回一个布尔值，指示 DMP 条件是否满足。\n\n-   测试 $\\mathsf{E1}$（椭圆型，调和边界）：$-\\Delta_h u_h = 0$，边界数据 $u|_{\\partial\\Omega} = x$，断言 $\\min(u_h) \\ge 0 - \\tau$ 和 $\\max(u_h) \\le 1 + \\tau$。\n-   测试 $\\mathsf{E2}$（椭圆型，非负源项）：$-\\Delta_h u_h = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$，边界数据 $u|_{\\partial\\Omega} = 0$，断言 $\\min(u_h) \\ge 0 - \\tau$。\n-   测试 $\\mathsf{P1}$（抛物型，稳定时间步）：显式格式，其中 $r = 0.24$，边界数据 $u^n|_{\\partial\\Omega} = 0$，初始条件 $u^0 = \\sin(\\pi x)\\sin(\\pi y)$，在每个时间步 $n$ 断言 $\\min(u^n) \\ge 0 - \\tau$ 和 $\\max(u^n) \\le 1 + \\tau$。\n-   测试 $\\mathsf{P2}$（抛物型，不稳定时间步）：显式格式，其中 $r = 0.26$，边界数据 $u^n|_{\\partial\\Omega} = 0$，初始条件 $u^0 = \\sin(\\pi x)\\sin(\\pi y)$，断言如 $\\mathsf{P1}$；预期会违规。\n-   测试 $\\mathsf{P3}$（抛物型，临界时间步）：显式格式，其中 $r = 0.25$，边界数据 $u^n|_{\\partial\\Omega} = 0$，初始条件 $u^0 = \\sin(\\pi x)\\sin(\\pi y)$，断言如 $\\mathsf{P1}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4,result5]”）。每个结果必须是对应测试用例（按 $\\mathsf{E1}$、$\\mathsf{E2}$、$\\mathsf{P1}$、$\\mathsf{P2}$、$\\mathsf{P3}$ 的顺序）的布尔值。", "solution": "该验证框架建立在椭圆和抛物型算子的极值原理及其离散模拟之上。其基础是以下一组原理和性质。\n\n对于椭圆方程，考虑在有界域 $\\Omega$ 上带有狄利克雷边界条件的算子 $L u = -\\Delta u$。连续极大值和极小值原理指出，如果 $L u \\ge 0$（等价于 $\\Delta u \\le 0$，$u$ 是超调和的），则 $u$ 的最小值出现在边界 $\\partial \\Omega$ 上；如果 $L u \\le 0$（等价于 $\\Delta u \\ge 0$，$u$ 是次调和的），则 $u$ 的最大值出现在边界 $\\partial \\Omega$ 上。对于五点中心差分格式离散化，内部节点上产生的线性系统为 $A u = b$，其中矩阵 $A$ 的元素为 $A_{p,p} = 4/h^2$，$p$ 的最近邻居 $q$ 对应的元素为 $A_{p,q} = -1/h^2$，其他元素 $A_{p,q} = 0$；右侧项 $b$ 包含了内部源项 $f$ 和边界贡献 $\\sum (1/h^2) g$，其中 $g$ 是狄利克雷边界值。这个矩阵 $A$ 是一个 $M$-矩阵：$A$ 是一个 Z-矩阵（非对角线元素 $\\le 0$），对角占优且严格正定，这意味着 $A^{-1} \\ge 0$（分量式成立）。因此，如果 $b \\ge 0$（分量式成立）（例如，由于非负的 $f$ 和非负的边界贡献），则离散解 $u = A^{-1} b$ 是非负的，这与离散最小极值原理一致。对于齐次右侧项 $f \\equiv 0$，当格式是单调时，离散解 $u$ 的最大值和最小值位于边界值的凸包内。在正方形上构造的边界数据 $u|_{\\partial \\Omega} = x$ 产生的值在 $[0,1]$ 区间内，离散解继承了这些界。\n\n对于抛物型方程，考虑带有狄利克雷边界条件的 $u_t = \\Delta u$。均匀网格上的显式向前 Euler 格式为\n$$u_{i,j}^{n+1} = (1 - 4r) u_{i,j}^{n} + r\\left(u_{i+1,j}^{n} + u_{i-1,j}^{n} + u_{i,j+1}^{n} + u_{i,j-1}^{n}\\right),$$\n其中 $r = \\Delta t / h^2$。如果 $r \\le 1/4$，此更新中的所有系数都是非负的且总和为 1，这使得 $u_{i,j}^{n+1}$ 成为当前值和相邻值的凸组合。对于非负的初始数据和零狄利克雷边界数据，离散解保持非负性，并保持被初始上确界所限制，这与离散极值原理的模拟相符。如果 $r > 1/4$，中心系数变为负数，破坏了单调性，并可能导致超出（overshoots）或低于（undershoots）极值，从而违反极值原理。\n\n验证框架的算法设计：\n\n1.  离散椭圆方程求解器：\n    -   为内部节点构建稀疏的 $N^2 \\times N^2$ 五点拉普拉斯矩阵 $A$。通过 $p = (i-1) N + (j-1)$ 将 $(i,j)$（其中 $i,j \\in \\{1,\\dots,N\\}$）映射到单个索引。\n    -   通过在内部坐标 $(x_i,y_j) = (i h, j h)$ 处对人造源项 $f(x_i,y_j)$ 进行采样并添加狄利克雷边界贡献来计算右侧项 $b$。每个在内部区域外的邻居向 $b$ 添加 $(1/h^2) g$，其中 $g$ 是该邻居坐标处的边界值。这产生了表示 $-\\Delta_h u_h = f$ 的离散系统 $A u = b$。\n    -   使用稀疏线性求解器求解该系统。然后检查 DMP 断言：对于调和边界测试（$f \\equiv 0$，边界 $u|_{\\partial \\Omega} = x$），验证 $\\min(u_h) \\ge 0 - \\tau$ 和 $\\max(u_h) \\le 1 + \\tau$。对于非负源项测试（$f \\ge 0$，边界 $u|_{\\partial \\Omega} = 0$），验证 $\\min(u_h) \\ge 0 - \\tau$。\n\n2.  显式抛物型格式：\n    -   在内部节点上初始化 $u^0_{i,j} = \\sin(\\pi x_i)\\sin(\\pi y_j)$，并将所有时间的边界节点设置为零。计算内部区域上的初始上确界 $\\|u^0\\|_{\\infty}$。\n    -   对于给定的 $r = \\Delta t / h^2$，迭代执行显式更新 $T$ 个时间步。在每个步骤中，在边缘强制边界为零。每次更新后，验证 DMP 断言：检查内部区域的最小值至少为 $0 - \\tau$，最大值不超过 $\\|u^0\\|_{\\infty} + \\tau$。\n    -   对于 $r \\le 1/4$，更新是凸组合，保证了单调性和 DMP 的保持；对于 $r > 1/4$，通过边界检查来检测违规。\n\n测试套件和输出：\n-   测试 $\\mathsf{E1}$：$N = 31$，$h = 1/(N+1)$，边界 $u|_{\\partial \\Omega} = x$，右侧项 $f \\equiv 0$，返回一个布尔值，指示是否同时满足 $\\min(u_h) \\ge 0 - \\tau$ 和 $\\max(u_h) \\le 1 + \\tau$。\n-   测试 $\\mathsf{E2}$：$N = 31$，边界 $u|_{\\partial \\Omega} = 0$，$f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$，返回一个布尔值，指示是否满足 $\\min(u_h) \\ge 0 - \\tau$。\n-   测试 $\\mathsf{P1}$：$N = 31$，$r = 0.24$，$T = 50$，初始条件 $u^0 = \\sin(\\pi x)\\sin(\\pi y)$，边界为零；返回一个布尔值，指示 DMP 界限是否在所有步骤中都得到满足。\n-   测试 $\\mathsf{P2}$：$N = 31$，$r = 0.26$，$T = 50$，相同的初始和边界条件；返回一个布尔值，指示 DMP 界限是否得到满足（预期为 false）。\n-   测试 $\\mathsf{P3}$：$N = 31$，$r = 0.25$，$T = 50$，相同的初始和边界条件；返回一个布尔值，指示 DMP 界限是否得到满足。\n\n最终程序按顺序汇总五个测试结果，并以所需的格式将其打印为单行，确保无需外部输入即可独立执行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef build_5pt_laplacian_matrix(N, h):\n    \"\"\"\n    Build the sparse matrix A for the 5-point discretization of -Delta on an N x N interior grid.\n    Diagonal entries: 4/h^2\n    Off-diagonal (neighbors): -1/h^2\n    \"\"\"\n    n = N * N\n    A = lil_matrix((n, n))\n    inv_h2 = 1.0 / (h * h)\n    for i in range(N):\n        for j in range(N):\n            p = i * N + j\n            # center\n            A[p, p] = 4.0 * inv_h2\n            # left neighbor\n            if i > 0:\n                A[p, (i - 1) * N + j] = -1.0 * inv_h2\n            # right neighbor\n            if i  N - 1:\n                A[p, (i + 1) * N + j] = -1.0 * inv_h2\n            # down neighbor\n            if j > 0:\n                A[p, i * N + (j - 1)] = -1.0 * inv_h2\n            # up neighbor\n            if j  N - 1:\n                A[p, i * N + (j + 1)] = -1.0 * inv_h2\n    return csr_matrix(A)\n\ndef solve_dirichlet_poisson(N, boundary_func, rhs_func):\n    \"\"\"\n    Solve -Delta_h u = f on an N x N interior grid with Dirichlet boundary conditions.\n    boundary_func(x, y) gives boundary value u on the boundary.\n    rhs_func(x, y) gives f at interior points.\n    Returns u_interior (N x N) array of solution values on interior nodes.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    A = build_5pt_laplacian_matrix(N, h)\n    n = N * N\n    b = np.zeros(n, dtype=float)\n    inv_h2 = 1.0 / (h * h)\n\n    # Coordinates: interior nodes at (i=1..N, j=1..N) mapped to x=i*h, y=j*h\n    # Boundary indices are at i=0 and i=N+1 for x, and j=0 and j=N+1 for y.\n    for i in range(1, N + 1):\n        x_i = i * h\n        for j in range(1, N + 1):\n            y_j = j * h\n            p = (i - 1) * N + (j - 1)\n            # RHS f\n            b[p] = rhs_func(x_i, y_j)\n            # Boundary contributions: check neighbors outside interior domain\n            # left neighbor at i-1\n            if i - 1 == 0:\n                # boundary at x=0, interior y_j\n                g = boundary_func(0.0, y_j)\n                b[p] += inv_h2 * g\n            # right neighbor at i+1\n            if i + 1 == N + 1:\n                # boundary at x=1, interior y_j\n                g = boundary_func(1.0, y_j)\n                b[p] += inv_h2 * g\n            # down neighbor at j-1\n            if j - 1 == 0:\n                # boundary at y=0, interior x_i\n                g = boundary_func(x_i, 0.0)\n                b[p] += inv_h2 * g\n            # up neighbor at j+1\n            if j + 1 == N + 1:\n                # boundary at y=1, interior x_i\n                g = boundary_func(x_i, 1.0)\n                b[p] += inv_h2 * g\n\n    # Solve\n    u_vec = spsolve(A, b)\n    u_interior = u_vec.reshape((N, N))\n    return u_interior\n\ndef test_E1(N, tol):\n    \"\"\"\n    Elliptic test E1: -Delta_h u = 0 with boundary u|_{∂Ω} = x.\n    Check that interior solution lies within [0, 1] up to tolerance.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    def boundary_func(x, y):\n        return x\n    def rhs_func(x, y):\n        return 0.0\n\n    u_interior = solve_dirichlet_poisson(N, boundary_func, rhs_func)\n    umin = np.min(u_interior)\n    umax = np.max(u_interior)\n    ok = (umin >= -tol) and (umax = 1.0 + tol)\n    return ok\n\ndef test_E2(N, tol):\n    \"\"\"\n    Elliptic test E2: -Delta_h u = f with f(x,y) = 2*pi^2*sin(pi x)*sin(pi y), and boundary u=0.\n    Check discrete minimum principle: u_interior >= 0 (within tolerance).\n    \"\"\"\n    pi = np.pi\n    def boundary_func(x, y):\n        return 0.0\n    def rhs_func(x, y):\n        return 2.0 * (pi ** 2) * np.sin(pi * x) * np.sin(pi * y)\n\n    u_interior = solve_dirichlet_poisson(N, boundary_func, rhs_func)\n    umin = np.min(u_interior)\n    ok = (umin >= -tol)\n    return ok\n\ndef run_heat_explicit(N, r, T, tol):\n    \"\"\"\n    Run explicit forward Euler for u_t = Delta u with zero Dirichlet boundary.\n    Initial condition u0 = sin(pi x) sin(pi y).\n    Check DMP at each step: interior u stays within [0, initial_max] within tolerance.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    pi = np.pi\n\n    # Full grid including boundaries: (N+2) x (N+2)\n    u = np.zeros((N + 2, N + 2), dtype=float)\n\n    # Initialize interior\n    for i in range(1, N + 1):\n        x_i = i * h\n        for j in range(1, N + 1):\n            y_j = j * h\n            u[i, j] = np.sin(pi * x_i) * np.sin(pi * y_j)\n\n    initial_max = np.max(u[1:N+1, 1:N+1])\n\n    # Time stepping\n    for n in range(T):\n        u_new = np.copy(u)\n        # Update interior using 5-point Laplacian explicit scheme\n        # zero Dirichlet boundaries remain zero\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                u_new[i, j] = (\n                    u[i, j]\n                    + r * (\n                        u[i + 1, j] + u[i - 1, j] + u[i, j + 1] + u[i, j - 1]\n                        - 4.0 * u[i, j]\n                    )\n                )\n        # Enforce boundary zeros explicitly (optional redundancy)\n        u_new[0, :] = 0.0\n        u_new[N + 1, :] = 0.0\n        u_new[:, 0] = 0.0\n        u_new[:, N + 1] = 0.0\n\n        u = u_new\n\n        # Check DMP bounds on interior\n        umin = np.min(u[1:N+1, 1:N+1])\n        umax = np.max(u[1:N+1, 1:N+1])\n        if not (umin >= -tol and umax = initial_max + tol):\n            return False\n    return True\n\ndef test_P1(N, tol):\n    \"\"\"\n    Parabolic test P1: Explicit scheme with r = 0.24 (stable).\n    \"\"\"\n    r = 0.24\n    T = 50\n    return run_heat_explicit(N, r, T, tol)\n\ndef test_P2(N, tol):\n    \"\"\"\n    Parabolic test P2: Explicit scheme with r = 0.26 (unstable, expect DMP violation).\n    \"\"\"\n    r = 0.26\n    T = 50\n    return run_heat_explicit(N, r, T, tol)\n\ndef test_P3(N, tol):\n    \"\"\"\n    Parabolic test P3: Explicit scheme with r = 0.25 (critical, should preserve DMP).\n    \"\"\"\n    r = 0.25\n    T = 50\n    return run_heat_explicit(N, r, T, tol)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    N = 31\n    tol = 1e-12\n    # Run tests E1, E2, P1, P2, P3 in order.\n    results = []\n    results.append(test_E1(N, tol))\n    results.append(test_E2(N, tol))\n    results.append(test_P1(N, tol))\n    results.append(test_P2(N, tol))\n    results.append(test_P3(N, tol))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3419390"}]}