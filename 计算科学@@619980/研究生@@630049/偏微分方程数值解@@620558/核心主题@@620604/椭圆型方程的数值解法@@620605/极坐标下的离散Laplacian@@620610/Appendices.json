{"hands_on_practices": [{"introduction": "在数值方法中，首要任务是将连续的微分算子准确地转化为离散形式。此实践练习应用“制造解方法”（Method of Manufactured Solutions），将离散算子应用于已知的连续方程解析解，通过验证离散算子在网格细化时其数值残差趋于零，您将能验证自己实现的极坐标拉普拉斯算子离散格式的正确性。[@problem_id:3379318]", "problem": "考虑在极坐标中作用于一个足够光滑的标量场 $u(r,\\theta)$ 的拉普拉斯算子，该标量场定义在一个内径严格为正的环形域上，以避免在 $r=0$ 处的坐标奇异点。本任务的目标是，验证极坐标拉普拉斯算子离散近似的一致性，方法是将其应用于在笛卡尔变量中构建并通过 $x=r\\cos\\theta$ 和 $y=r\\sin\\theta$ 映射到极坐标的精确调和函数。一致性意味着，当离散算子应用于连续方程的精确解时，随着离散化的细化，得到的离散残差会趋于零。\n\n基本背景：笛卡尔坐标中的拉普拉斯算子定义为 $\\nabla^2 u = \\partial^2 u/\\partial x^2 + \\partial^2 u/\\partial y^2$，其在极坐标 $(r,\\theta)$ 中的表达式是一个经过充分检验的事实，由 $\\nabla^2 u = \\partial^2 u/\\partial r^2 + (1/r)\\,\\partial u/\\partial r + (1/r^2)\\,\\partial^2 u/\\partial \\theta^2$ 给出。求解偏微分方程（PDE）的一种标准方法是，用在网格上计算的有限差分替换空间导数，同时遵循坐标系所规定的结构。\n\n任务：实现一个程序，在 $(r,\\theta)$ 中构建一个均匀张量积网格，该网格在 $[r_{\\min},R]$ 上有 $N_r$ 个径向节点，在 $[0,2\\pi)$ 上有 $N_\\theta$ 个角向节点，其中角度必须以弧度解释。角向方向必须被视为周期性的，周期为 $2\\pi$。内径必须满足 $r_{\\min}>0$，以避免在 $r=0$ 处的奇异因子 $(1/r)$ 和 $(1/r^2)$。在此网格上，通过对 $r$ 和 $\\theta$ 中的三个导数项进行一致的二阶中心有限差分近似，来定义离散极坐标拉普拉斯算子。将此离散算子应用于以下最初以笛卡尔变量书写、并通过 $x=r\\cos\\theta$ 和 $y=r\\sin\\theta$ 映射到极坐标的精确调和函数：\n- $u_1(x,y) = x^2 - y^2$，映射为 $u_1(r,\\theta) = r^2 \\cos(2\\theta)$。\n- $u_2(x,y) = x$，映射为 $u_2(r,\\theta) = r \\cos(\\theta)$。\n- $u_3(x,y) = \\operatorname{Re}\\big((x+\\mathrm{i}y)^3\\big)$，映射为 $u_3(r,\\theta) = r^3 \\cos(3\\theta)$。\n- $u_4(x,y) = c$（对于一个常数 $c$），映射为 $u_4(r,\\theta) = c$。\n\n对于每个测试用例，计算拉普拉斯算子的离散残差，即离散算子对网格上精确函数值的逐点应用，并报告在所有内部径向指数 $i\\in\\{1,\\dots,N_r-2\\}$ 和所有角向指数 $j\\in\\{0,\\dots,N_\\theta-1\\}$ 上的最大绝对残差。不要将位于 $i=0$ 和 $i=N_r-1$ 的边界径向点包含在残差中，以便只使用内部二阶模板。角向方向必须使用周期性邻居处理，其中 $j=-1$ 和 $j=N_\\theta$ 分别与 $j=N_\\theta-1$ 和 $j=0$ 等同。\n\n角度单位要求：所有角度 $\\theta$ 都必须以弧度表示和解释。\n\n您必须实现程序来评估以下测试套件，其中所有量都是无量纲的：\n- 测试用例 1：$N_r=64$, $N_\\theta=64$, $r_{\\min}=0.1$, $R=1.0$, 函数 $u(r,\\theta)=r^2\\cos(2\\theta)$。\n- 测试用例 2：$N_r=8$, $N_\\theta=16$, $r_{\\min}=0.1$, $R=1.0$, 函数 $u(r,\\theta)=r^2\\cos(2\\theta)$。\n- 测试用例 3：$N_r=64$, $N_\\theta=64$, $r_{\\min}=10^{-3}$, $R=1.0$, 函数 $u(r,\\theta)=r\\cos(\\theta)$。\n- 测试用例 4：$N_r=100$, $N_\\theta=80$, $r_{\\min}=0.05$, $R=2.0$, 函数 $u(r,\\theta)=r^3\\cos(3\\theta)$。\n- 测试用例 5：$N_r=64$, $N_\\theta=64$, $r_{\\min}=0.1$, $R=1.0$, 函数 $u(r,\\theta)=2$。\n\n对于每个测试用例，程序必须计算一个浮点数：在指定内部集合上的最大绝对离散残差。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中 $r_k$ 是第 k 个测试用例的结果，按上述顺序排列。\n\n预期解决方案将通过计算证明，对于更精细的网格，离散残差趋于更小，并且在小的 $r_{\\min}$ 附近保持有界，从而证实离散极坐标拉普拉斯算子对于光滑调和函数与连续算子的一致性。除了指定的角度单位条件外，输出不涉及任何物理单位；所有报告的值都是纯数。", "solution": "## 问题验证\n\n### 步骤1：提取已知条件\n\n- **拉普拉斯算子（笛卡尔坐标）**：$\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$。\n- **拉普拉斯算子（极坐标）**：$\\nabla^2 u = \\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial u}{\\partial r} + \\frac{1}{r^2}\\frac{\\partial^2 u}{\\partial \\theta^2}$。\n- **域**：一个内径为 $r_{\\min} > 0$、外径为 $R$ 的环形域。\n- **网格**：在 $(r,\\theta)$ 中构建一个均匀张量积网格，该网格在 $[r_{\\min}, R]$ 上有 $N_r$ 个径向节点，在 $[0, 2\\pi)$ 上有 $N_\\theta$ 个角向节点。\n- **角向周期性**：角向方向是周期性的，周期为 $2\\pi$。所有角度均以弧度为单位。\n- **离散算子**：对所有三个导数项使用二阶中心有限差分。\n- **调和测试函数**：将离散拉普拉斯算子应用于以下映射到极坐标的精确调和函数：\n    1.  $u_1(x,y) = x^2 - y^2 \\implies u_1(r,\\theta) = r^2 \\cos(2\\theta)$。\n    2.  $u_2(x,y) = x \\implies u_2(r,\\theta) = r \\cos(\\theta)$。\n    3.  $u_3(x,y) = \\operatorname{Re}\\big((x+\\mathrm{i}y)^3\\big) \\implies u_3(r,\\theta) = r^3 \\cos(3\\theta)$。\n    4.  $u_4(x,y) = c \\implies u_4(r,\\theta) = c$。\n- **残差计算**：要计算的量是逐点离散残差的最大绝对值，定义为离散算子对精确函数值的应用。该最大值取自所有内部径向指数 $i \\in \\{1, \\dots, N_r-2\\}$ 和所有角向指数 $j \\in \\{0, \\dots, N_\\theta-1\\}$。\n- **测试套件**：\n    - **用例 1**：$N_r=64$, $N_\\theta=64$, $r_{\\min}=0.1$, $R=1.0$, $u(r,\\theta)=r^2\\cos(2\\theta)$。\n    - **用例 2**：$N_r=8$, $N_\\theta=16$, $r_{\\min}=0.1$, $R=1.0$, $u(r,\\theta)=r^2\\cos(2\\theta)$。\n    - **用例 3**：$N_r=64$, $N_\\theta=64$, $r_{\\min}=10^{-3}$, $R=1.0$, $u(r,\\theta)=r\\cos(\\theta)$。\n    - **用例 4**：$N_r=100$, $N_\\theta=80$, $r_{\\min}=0.05$, $R=2.0$, $u(r,\\theta)=r^3\\cos(3\\theta)$。\n    - **用例 5**：$N_r=64$, $N_\\theta=64$, $r_{\\min}=0.1$, $R=1.0$, $u(r,\\theta)=2$。\n- **输出格式**：单行输出，包含一个用方括号括起来的、针对每个测试用例的逗号分隔的结果列表。例如：`[r_1,r_2,r_3,r_4,r_5]`。\n\n### 步骤2：使用提取的已知条件进行验证\n\n1.  **科学基础**：该问题具有坚实的科学基础。笛卡尔坐标和极坐标中拉普拉斯算子的表达式在向量微积分和物理学中都是正确且标准的。提供的测试函数确实是调和的（即在笛卡尔坐标中 $\\nabla^2 u = 0$），这是制造解方法验证测试的关键要求。使用有限差分来近似导数是偏微分方程数值方法的基础。\n2.  **适定性**：该问题是适定的（或称良构的）。为每个测试用例计算唯一结果所需的所有参数和步骤都已明确定义。网格生成、有限差分模板、周期性边界条件的处理以及计算最终残差的域都得到了明确的规定。这确保了每个测试用例都存在一个稳定且有意义的数值答案。\n3.  **客观性**：问题陈述以精确、客观的数学语言编写。它没有任何模糊性、主观性或基于观点的断言。\n4.  **完整性**：该问题是自包含的。它提供了所有必要的信息，包括网格参数（$N_r, N_\\theta, r_{\\min}, R$）、测试函数的精确形式以及待计算量的精确定义。\n5.  **无其他缺陷**：该问题没有表现出任何其他缺陷，如非形式化、矛盾、不切实际、病态、微不足道或无法验证。这是数值分析领域一个标准且形式良好的问题。\n\n### 步骤3：结论与行动\n该问题是有效的。这是一个在计算数学中用于验证数值方案一致性的明确定义的任务。我现在将继续进行求解。\n\n## 解法\n\n任务是计算极坐标拉普拉斯算子有限差分近似的一致性。一致性通过将离散算子应用于连续方程的已知解析解（$\\nabla^2 u = 0$）来测试，并验证所得的离散残差是否随着网格细化而趋于零。由于连续拉普拉斯算子为零，残差就是离散拉普拉斯算子应用于函数的值。\n\n### 1. 网格与函数离散化\n构建一个 $(r,\\theta)$ 坐标下的离散网格。网格点为 $(r_i, \\theta_j)$，其中：\n- $r_i = r_{\\min} + i \\cdot \\Delta r$，对于 $i \\in \\{0, 1, \\dots, N_r-1\\}$。径向步长为 $\\Delta r = \\frac{R - r_{\\min}}{N_r - 1}$。\n- $\\theta_j = j \\cdot \\Delta \\theta$，对于 $j \\in \\{0, 1, \\dots, N_\\theta-1\\}$。角向步长为 $\\Delta \\theta = \\frac{2\\pi}{N_\\theta}$。$\\theta$ 的域为 $[0, 2\\pi)$。\n\n函数 $u(r,\\theta)$ 在此网格上的值记为 $u_{i,j} = u(r_i, \\theta_j)$。\n\n### 2. 有限差分近似\n极坐标拉普拉斯算子为 $\\nabla^2 u = \\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial u}{\\partial r} + \\frac{1}{r^2}\\frac{\\partial^2 u}{\\partial \\theta^2}$。我们使用二阶中心差分在内部网格点 $(r_i, \\theta_j)$ 处近似每一项：\n\n1.  **二阶径向导数**：\n    $$ \\left. \\frac{\\partial^2 u}{\\partial r^2} \\right|_{i,j} \\approx \\frac{u_{i+1, j} - 2u_{i, j} + u_{i-1, j}}{(\\Delta r)^2} $$\n\n2.  **一阶径向导数**：\n    $$ \\left. \\frac{1}{r} \\frac{\\partial u}{\\partial r} \\right|_{i,j} \\approx \\frac{1}{r_i} \\frac{u_{i+1, j} - u_{i-1, j}}{2 \\Delta r} $$\n\n3.  **二阶角向导数**：\n    $$ \\left. \\frac{1}{r^2} \\frac{\\partial^2 u}{\\partial \\theta^2} \\right|_{i,j} \\approx \\frac{1}{r_i^2} \\frac{u_{i, j+1} - 2u_{i, j} + u_{i, j-1}}{(\\Delta \\theta)^2} $$\n    角向索引采用周期性处理。对于索引 $j$，其邻居为 $(j-1 \\pmod{N_\\theta})$ 和 $(j+1 \\pmod{N_\\theta})$。\n\n### 3. 离散拉普拉斯算子\n在内部点 $(i, j)$（其中 $i \\in \\{1, \\dots, N_r-2\\}$）的离散拉普拉斯算子 $(\\nabla^2_d u)_{i,j}$ 是这三个近似项的和：\n$$ (\\nabla^2_d u)_{i,j} = \\frac{u_{i+1, j} - 2u_{i, j} + u_{i-1, j}}{(\\Delta r)^2} + \\frac{1}{r_i} \\frac{u_{i+1, j} - u_{i-1, j}}{2 \\Delta r} + \\frac{1}{r_i^2} \\frac{u_{i, j+1 \\pmod{N_\\theta}} - 2u_{i, j} + u_{i, j-1 \\pmod{N_\\theta}}}{(\\Delta \\theta)^2} $$\n\n### 4. 最大残差的计算\n残差定义为 $(\\nabla^2_d u)_{i,j}$，因为给定测试函数的精确连续拉普拉斯算子为零。程序将对每个测试用例执行以下步骤：\n1.  设置网格参数 $N_r, N_\\theta, r_{\\min}, R$。\n2.  计算网格步长 $\\Delta r$ 和 $\\Delta \\theta$。\n3.  创建坐标 $(r_i, \\theta_j)$ 的二维网格，并在每个网格点上评估指定的调和函数 $u(r, \\theta)$，以获得矩阵 $U = [u_{i,j}]$。\n4.  对所有内部径向点（即 $i \\in \\{1, \\dots, N_r-2\\}$）计算离散拉普拉斯矩阵 $(\\nabla^2_d U)$。这可以通过矢量化数组操作高效完成。\n5.  在得到的内部残差矩阵的所有元素中，找到最大绝对值。这个浮点数就是该测试用例的结果。\n\n对所有五个测试用例重复此过程，并按指定格式收集和格式化结果。例如，对于常数函数 $u=c$，所有有限差分都恒为零，因此预计残差为 $0.0$。对于其他函数，残差是近似的截断误差，它应随网格细化（即随着 $\\Delta r, \\Delta \\theta \\to 0$）而减小，从而证实该方案的一致性。", "answer": "```python\nimport numpy as np\n\ndef compute_max_residual(Nr, Ntheta, r_min, R, func_name):\n    \"\"\"\n    Computes the maximum absolute residual of a discrete polar Laplacian operator.\n\n    Args:\n        Nr (int): Number of radial grid points.\n        Ntheta (int): Number of angular grid points.\n        r_min (float): Inner radius.\n        R (float): Outer radius.\n        func_name (str): The name of the harmonic function to test ('u1', 'u2', 'u3', 'u4').\n\n    Returns:\n        float: The maximum absolute residual over the interior grid points.\n    \"\"\"\n    # 1. Grid and Function Discretization\n    # Define grid spacing\n    dr = (R - r_min) / (Nr - 1)\n    dtheta = 2 * np.pi / Ntheta\n\n    # Create grid coordinates\n    # r includes both endpoints. Shape: (Nr,)\n    r = np.linspace(r_min, R, Nr)\n    # theta is exclusive of 2*pi. Shape: (Ntheta,)\n    theta = np.linspace(0, 2 * np.pi, Ntheta, endpoint=False)\n\n    # Create a 2D meshgrid. R_grid and T_grid have shape (Nr, Ntheta)\n    R_grid, T_grid = np.meshgrid(r, theta, indexing='ij')\n\n    # Evaluate the test function on the grid\n    U = None\n    if func_name == 'u1':\n        # u(r,θ) = r^2 * cos(2θ)\n        U = R_grid**2 * np.cos(2 * T_grid)\n    elif func_name == 'u2':\n        # u(r,θ) = r * cos(θ)\n        U = R_grid * np.cos(T_grid)\n    elif func_name == 'u3':\n        # u(r,θ) = r^3 * cos(3θ)\n        U = R_grid**3 * np.cos(3 * T_grid)\n    elif func_name == 'u4':\n        # u(r,θ) = 2\n        U = np.full_like(R_grid, 2.0)\n\n    # 2. Finite Difference Approximation on Interior Grid\n    # The residual is only computed on interior radial points i = 1, ..., Nr-2.\n    # We use array slicing to select these points.\n    \n    # Slices of U for neighbor points\n    # U_interior has shape (Nr-2, Ntheta)\n    U_interior = U[1:-1, :]\n    # U_ip1 (i+1) and U_im1 (i-1) also have shape (Nr-2, Ntheta)\n    U_ip1 = U[2:, :]\n    U_im1 = U[:-2, :]\n\n    # Radial grid points corresponding to the interior\n    # r_interior has shape (Nr-2,). We reshape for broadcasting.\n    r_interior = r[1:-1]\n    r_interior_col = r_interior[:, np.newaxis]\n\n    # Calculate radial derivative terms\n    d2u_dr2 = (U_ip1 - 2 * U_interior + U_im1) / (dr**2)\n    du_dr_term = (1 / r_interior_col) * (U_ip1 - U_im1) / (2 * dr)\n    \n    # Calculate angular derivative term with periodic boundary conditions\n    # np.roll handles periodicity efficiently. axis=1 is the theta dimension.\n    U_jp1 = np.roll(U_interior, -1, axis=1)\n    U_jm1 = np.roll(U_interior, 1, axis=1)\n    d2u_dtheta2_term = (1 / r_interior_col**2) * (U_jp1 - 2 * U_interior + U_jm1) / (dtheta**2)\n\n    # 3. Sum terms to get the discrete Laplacian (residual)\n    residual_matrix = d2u_dr2 + du_dr_term + d2u_dtheta2_term\n    \n    # 4. Find the maximum absolute residual\n    max_abs_residual = np.max(np.abs(residual_matrix))\n    \n    return max_abs_residual\n\ndef solve():\n    \"\"\"\n    Executes the defined test suite for the discrete polar Laplacian.\n    \"\"\"\n    # (Nr, Ntheta, r_min, R, function_name)\n    test_cases = [\n        (64, 64, 0.1, 1.0, 'u1'),  # Test case 1\n        (8, 16, 0.1, 1.0, 'u1'),   # Test case 2\n        (64, 64, 1e-3, 1.0, 'u2'), # Test case 3\n        (100, 80, 0.05, 2.0, 'u3'),# Test case 4\n        (64, 64, 0.1, 1.0, 'u4'),  # Test case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        Nr, Ntheta, r_min, R, func_name = case\n        result = compute_max_residual(Nr, Ntheta, r_min, R, func_name)\n        results.append(result)\n\n    # Format the output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3379318"}, {"introduction": "在极坐标系中，一个核心挑战是原点 $r=0$ 处的坐标奇异性，拉普拉斯算子中的 $1/r$ 和 $1/r^2$ 项在此处会发散。一个稳健的数值格式必须通过施加与解在原点处的光滑性物理要求相一致的边界条件来处理这种奇异性。本练习将引导您通过第一性原理分析，为不同傅里叶模式推导正确的渐近边界条件，这是在完整圆盘上求解问题的关键概念。[@problem_id:3379301]", "problem": "考虑在闭合单位圆盘 $\\Omega = \\{(r,\\theta): 0 \\le r \\le 1\\}$ 中求解泊松问题 $-\\Delta u = f$，其中右侧项 $f$ 是光滑的，并服从给定的狄利克雷边界条件 $u(1,\\theta) = g(\\theta)$，其中 $g$ 也是光滑的。在极坐标 $(r,\\theta)$ 中，拉普拉斯算子具有经过充分检验的形式 $\\Delta u = u_{rr} + \\frac{1}{r} u_r + \\frac{1}{r^2} u_{\\theta\\theta}$。在极坐标网格上，标准的有限差分法由于系数 $\\frac{1}{r}$ 和 $\\frac{1}{r^2}$ 的存在，在原点 $r=0$ 处会遇到退化问题。为避免此问题，一种方法是排除原点周围的一个小圆盘，而在环形区域 $\\Omega_\\epsilon = \\{(r,\\theta): \\epsilon \\le r \\le 1\\}$ 上求解，并在 $r=\\epsilon$ 处设置一个人为的内边界，其中 $\\epsilon > 0$ 是一个很小的数，并最终随网格尺寸趋于 $0$。在一个均匀的极坐标网格上，其中 $r_i = \\epsilon + i \\Delta r$ ($i = 0,1,\\dots,N_r$) 且 $\\theta_j = j \\Delta \\theta$ ($j = 0,1,\\dots,N_\\theta-1$)，对所有 $r_i > \\epsilon$ 的内部点应用标准的二阶中心差分格式来近似 $\\Delta$，并为系统补充一个在 $r=\\epsilon$ 处的边界条件。\n\n请从第一性原理出发，论证在这种离散化中排除原点的合理性，并选择在 $r=\\epsilon$ 处的内边界条件，使其在渐近意义上与原点处的光滑性相容，并在极限 $\\epsilon \\to 0$ 时能恢复正确解。您可以假设 $f$ 和 $g$ 是光滑的，且精确解在 $r=0$ 处也是光滑的。\n\n选择所有适用项：\n\n- A. 强制 $u(\\epsilon,\\theta)$ 与 $\\theta$ 无关（即 $u(\\epsilon,\\theta)$ 等于其方位角平均值），并对该方位角平均值施加齐次诺伊曼条件，即 $\\partial_r \\big(\\frac{1}{2\\pi}\\int_0^{2\\pi} u(r,\\varphi)\\,d\\varphi\\big)\\big|_{r=\\epsilon} = 0$。在离散实现中，为方位角平均值设置鬼点层 $u_{0,j}$ 以满足 $u_{0,\\cdot} = u_{2,\\cdot}$，同时约束 $u_{1,j}$ 对 $j$ 为常数。\n\n- B. 在内边界上对所有角度统一施加齐次诺伊曼条件，$\\partial_r u(\\epsilon,\\theta) = 0$ 对所有 $\\theta$ 成立。\n\n- C. 在内边界上对所有角度统一施加齐次狄利克雷条件，$u(\\epsilon,\\theta) = 0$ 对所有 $\\theta$ 成立。\n\n- D. 将 $u$ 分解为关于 $\\theta$ 的傅里叶模态，对方位角平均模态施加齐次狄利克雷条件 $u_0(\\epsilon) = 0$，而对所有非零模态施加齐次诺伊曼条件 $\\partial_r u_m(\\epsilon) = 0$（对所有整数 $m \\ge 1$）。\n\n- E. 将 $u$ 分解为傅里叶模态 $u(r,\\theta) = \\sum_{m\\in\\mathbb{Z}} u_m(r) e^{\\mathrm{i} m \\theta}$，并对 $m=0$ 施加齐次诺伊曼条件 $\\partial_r u_0(\\epsilon) = 0$，对所有 $m \\neq 0$ 施加齐次狄利克雷条件 $u_m(\\epsilon) = 0$。\n\n您的选择必须基于以下要求：对于光滑解，当 $r \\to 0$ 时，$\\Delta u$ 中的所有项都保持有界；并且在 $\\Omega_\\epsilon$ 上的离散格式在 $\\epsilon \\to 0$ 时收敛到正确的极限。", "solution": "用户需要对问题陈述进行批判性验证，然后从第一性原理出发，为求解圆盘上泊松方程的数值格式推导出正确的内边界条件。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n-   **方程**：泊松问题 $-\\Delta u = f$。\n-   **区域**：闭合单位圆盘 $\\Omega = \\{(r,\\theta): 0 \\le r \\le 1\\}$。\n-   **极坐标中的拉普拉斯算子**：$\\Delta u = u_{rr} + \\frac{1}{r} u_r + \\frac{1}{r^2} u_{\\theta\\theta}$。\n-   **外边界条件**：$u(1,\\theta) = g(\\theta)$（狄利克雷类型）。\n-   **光滑性假设**：右侧项 $f$、边界数据 $g$ 以及精确解 $u$ 都是光滑函数，包括在原点 $r=0$ 处。\n-   **数值方法**：均匀极坐标网格上的有限差分法。为处理 $r=0$ 处的坐标奇点，计算区域被修改为环形域 $\\Omega_\\epsilon = \\{(r,\\theta): \\epsilon \\le r \\le 1\\}$，其中 $\\epsilon > 0$ 是一个小参数。\n-   **网格定义**：$r_i = \\epsilon + i \\Delta r$ ($i = 0,1,\\dots,N_r$) 且 $\\theta_j = j \\Delta \\theta$ ($j = 0,1,\\dots,N_\\theta-1$)。\n-   **目标**：论证排除原点的合理性，并选择在 $r=\\epsilon$ 处的内边界条件，使其在渐近意义上与解在原点处的光滑性相容，并在极限 $\\epsilon \\to 0$ 时成立。\n-   **推导约束**：选择必须基于当 $r \\to 0$ 时 $\\Delta u$ 中所有项保持有界的要求。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学基础（关键）**：该问题描述了数值分析中的一个典型问题：偏微分方程中坐标奇点的处理。圆盘上的泊松方程、拉普拉斯算子的极坐标表示以及有限差分法的使用，都是应用数学和计算物理学中标准且成熟的课题。所提出的切除奇点并引入一个人为边界条件的技术是一种常见且有效的方法。该问题有坚实的科学原理基础。\n-   **适定性**：该问题是适定的。它要求基于解的正则性来推导合适的边界条件，这是应用于数值方法的渐近分析中的标准程序。假设存在光滑解（由 $f$ 和 $g$ 的光滑性保证），其在原点附近的行为是唯一确定的，这反过来又指定了正确的渐近边界条件。\n-   **客观性（关键）**：该问题以精确、客观的数学语言陈述。它避免了模糊性和主观性。任务定义清晰，需要严谨的数学推导。\n\n问题设置在科学上或事实上没有不健全之处，是可形式化的、完整的、可行的和结构良好的。它是数值偏微分方程领域一个标准且非平凡的问题。\n\n**步骤 3：结论与行动**\n问题陈述是**有效的**。现在开始求解过程。\n\n### 推导与求解\n\n问题要求我们为圆盘上泊松方程 $-\\Delta u = f$ 的数值解，在人为边界 $r=\\epsilon$ 处确定合适的边界条件。这个条件必须与光滑解在原点 $r=0$ 附近的行为相一致。\n\n**排除原点的理由**\n极坐标中的拉普拉斯算子是 $\\Delta u = u_{rr} + \\frac{1}{r} u_r + \\frac{1}{r^2} u_{\\theta\\theta}$。在原点 $r=0$ 直接应用有限差分格式会涉及计算带有系数 $\\frac{1}{r}$ 和 $\\frac{1}{r^2}$ 的项，导致除以零。这是一个坐标奇点。为避免这种情况，将原点从计算网格中排除，在环形区域 $\\Omega_\\epsilon = \\{(r,\\theta): \\epsilon \\le r \\le 1\\}$ 上求解问题，这就需要在 $r=\\epsilon$ 处设置一个人为的边界条件。\n\n**内边界条件的推导**\n在 $r=\\epsilon$ 处的条件必须反映真实光滑解在 $r \\to 0$ 时的行为。一个光滑解 $u$ 在原点必须有明确定义的值和导数。我们通过将解分解为关于角度 $\\theta$ 的傅里叶级数来分析其行为：\n$$u(r,\\theta) = \\sum_{m=-\\infty}^{\\infty} u_m(r) e^{\\mathrm{i} m \\theta}$$\n偏微分方程 $-\\Delta u = f$ 变换为关于每个傅里叶模态 $u_m(r)$ 的常微分方程（ODE）组：\n$$-\\left( \\frac{d^2 u_m}{dr^2} + \\frac{1}{r} \\frac{du_m}{dr} - \\frac{m^2}{r^2} u_m \\right) = f_m(r)$$\n其中 $f_m(r)$ 是 $f(r,\\theta)$ 的傅里叶模态。\n\n为了理解在 $r=0$ 处所需的行为，我们考虑相应齐次方程的通解：\n-   对于方位角平均（模态 $m=0$）：$u_0(r) = C_1 + C_2 \\ln r$。\n-   对于所有其他模态（$m \\neq 0$）：$u_m(r) = C_1 r^{|m|} + C_2 r^{-|m|}$。\n\n为使解 $u(r,\\theta)$ 在 $r=0$ 处是光滑的（甚至只是连续的），每个模态 $u_m(r)$ 在 $r \\to 0$ 时必须是非奇异的。\n1.  **对于 $m=0$ 模态**：$C_2 \\ln r$ 项在 $r \\to 0$ 时发散。因此，对于一个正则解，我们必须有 $C_2 = 0$。这意味着在原点附近，$u_0(r)$ 的行为像一个常数（不考虑由强迫项 $f_0$ 产生的项）。具体来说，对于一个光滑解，$u_0(r) \\approx u_0(0) + O(r^2)$。其导数为 $\\frac{du_0}{dr}(r) \\approx O(r)$，这意味着 $\\frac{du_0}{dr}(0) = 0$。正确的渐近条件是对方位角平均施加**齐次诺伊曼条件**。\n\n2.  **对于 $m \\neq 0$ 模态**：$C_2 r^{-|m|}$ 项对于任何整数 $m \\neq 0$ 在 $r \\to 0$ 时发散。因此，对于一个正则解，我们必须有 $C_2 = 0$。这意味着在原点附近，$u_m(r)$ 的行为像 $C_1 r^{|m|}$。由于 $|m| \\ge 1$，这意味着当 $r \\to 0$ 时 $u_m(r) \\to 0$。正确的渐近条件是对所有非零模态施加**齐次狄利克雷条件**。\n\n总结一下，需要在 $r=\\epsilon$ 处施加的边界条件（应近似于 $r=0$ 处的行为）是：\n-   $\\frac{\\partial u_0}{\\partial r}(\\epsilon) = 0$\n-   $u_m(\\epsilon) = 0$ 对所有 $m \\in \\mathbb{Z}$, $m \\neq 0$。\n\n### 逐项分析\n\n-   **A. 强制 $u(\\epsilon,\\theta)$ 与 $\\theta$ 无关（即 $u(\\epsilon,\\theta)$ 等于其方位角平均值），并对该方位角平均值施加齐次诺伊曼条件，即 $\\partial_r \\big(\\frac{1}{2\\pi}\\int_0^{2\\pi} u(r,\\varphi)\\,d\\varphi\\big)\\big|_{r=\\epsilon} = 0$。在离散实现中，为方位角平均值设置鬼点层 $u_{0,j}$ 以满足 $u_{0,\\cdot} = u_{2,\\cdot}$，同时约束 $u_{1,j}$ 对 $j$ 为常数。**\n    -   $u(\\epsilon,\\theta)$ 与 $\\theta$ 无关的条件意味着 $u(\\epsilon,\\theta) = u_0(\\epsilon)$，这表明所有 $m \\neq 0$ 的高阶傅里叶模态 $u_m(\\epsilon)$ 必须为零。这等同于对 $m \\neq 0$ 施加 $u_m(\\epsilon) = 0$。\n    -   条件 $\\partial_r \\big(\\frac{1}{2\\pi}\\int_0^{2\\pi} u(r,\\varphi)\\,d\\varphi\\big)\\big|_{r=\\epsilon} = 0$ 正是对 $m=0$ 模态的齐次诺伊曼条件，即 $\\frac{\\partial u_0}{\\partial r}(\\epsilon) = 0$。\n    -   这个选项在物理空间中正确地描述了所需的条件。其关于离散实现的描述也是一种标准的、有效的方法。\n    -   **结论：正确。**\n\n-   **B. 在内边界上对所有角度统一施加齐次诺伊曼条件，$\\partial_r u(\\epsilon,\\theta) = 0$ 对所有 $\\theta$ 成立。**\n    -   这意味着对所有模态 $m$ 都有 $\\frac{\\partial u_m}{\\partial r}(\\epsilon) = 0$。这对 $m=0$ 是正确的，但对 $m \\neq 0$ 是不正确的。例如，一个光滑解可以有 $u(x,y) \\approx c x = c r \\cos\\theta$，它有一个非零的 $m=1$ 模态 $u_1(r) \\propto r$。其导数 $\\frac{\\partial u_1}{\\partial r} \\propto 1$，不为零。强行将此导数设为零是错误的。\n    -   **结论：不正确。**\n\n-   **C. 在内边界上对所有角度统一施加齐次狄利克雷条件，$u(\\epsilon,\\theta) = 0$ 对所有 $\\theta$ 成立。**\n    -   这意味着对所有模态 $m$ 都有 $u_m(\\epsilon) = 0$。这对 $m \\neq 0$ 是正确的，但对 $m=0$ 是不正确的。解在原点的值 $u(0,0)=u_0(0)$ 通常不为零，并由全局问题确定。强行将其设为零是错误的。\n    -   **结论：不正确。**\n\n-   **D. 将 $u$ 分解为关于 $\\theta$ 的傅里叶模态，对方位角平均模态施加齐次狄利克雷条件 $u_0(\\epsilon) = 0$，而对所有非零模态施加齐次诺伊曼条件 $\\partial_r u_m(\\epsilon) = 0$（对所有整数 $m \\ge 1$）。**\n    -   这个选项完全颠倒了正确的条件。它建议对 $m=0$ 使用狄利克雷条件，对 $m \\neq 0$ 使用诺伊曼条件。\n    -   **结论：不正确。**\n\n-   **E. 将 $u$ 分解为傅里叶模态 $u(r,\\theta) = \\sum_{m\\in\\mathbb{Z}} u_m(r) e^{\\mathrm{i} m \\theta}$，并对 $m=0$ 施加齐次诺伊曼条件 $\\partial_r u_0(\\epsilon) = 0$，对所有 $m \\neq 0$ 施加齐次狄利克雷条件 $u_m(\\epsilon) = 0$。**\n    -   这个选项用傅里叶模态的语言精确而正确地陈述了推导出的条件。它要求对 $m=0$ 模态施加齐次诺伊曼条件，对所有 $m \\neq 0$ 模态施加齐次狄利克雷条件。\n    -   **结论：正确。**\n\n选项 A 和 E 是对同一组正确物理条件的等价陈述，其中 A 是用物理空间的语言表述，E 是用傅里叶空间的语言表述。两者都是有效的选择。", "answer": "$$\\boxed{AE}$$", "id": "3379301"}, {"introduction": "虽然均匀网格实现简单，但它并非对所有问题都是最优的，特别是对于那些在原点附近具有陡峭梯度或奇异性的问题。本实践探索了一种自适应网格策略，将标准的均匀 $r$ 坐标网格与在对数坐标 $\\rho = \\ln r$ 中均匀的网格进行比较，后者能自然地将网格点聚集在原点附近。通过这种动手比较，您将定量评估不同网格划分策略之间的权衡，并学习如何选择更适应解行为的坐标系，从而提高计算的准确性和效率。[@problem_id:3379306]", "problem": "您需要研究在环形域上标量场 $u(r,\\theta)$ 的二维拉普拉斯算子在极坐标下的离散近似。目标是比较在径向坐标 $r$ 上的均匀间距与在对数径向坐标 $\\rho=\\ln r$ 上的均匀间距，在解析内部边界 $r\\to 0$ 附近的陡峭梯度时的效果。您的分析和程序必须基于第一性原理，并且除了基础微积分和坐标定义之外，不得依赖于任何预先给定的离散化公式。\n\n您可以使用的基本依据是二维拉普拉斯算子的定义、极坐标变换以及微积分中的链式法则。设环形域由 $r\\in[r_\\min,r_\\max]$ (其中 $r_\\min>0$) 定义，且 $\\theta\\in[0,2\\pi)$ (单位为弧度)。您将考虑一个在 $r=r_\\min$ 附近平滑但陡峭的函数，其形式为 $u(r,\\theta)=r^\\gamma\\cos(k\\theta)$，其中 $\\gamma\\in(0,1)$ 且 $k\\in\\mathbb{N}$。\n\n您必须从笛卡尔坐标下的拉普拉斯算子出发，使用标准坐标变换和链式法则推导出极坐标下的连续拉普拉斯算子，然后在此基础上推导两种情况下的相容的二阶中心差分近似：\n- 在径向坐标 $r$ 和角坐标 $\\theta$ 上均使用均匀网格，并在 $\\theta$ 方向上施加周期性边界条件。\n- 在对数径向坐标 $\\rho=\\ln r$ 和角坐标 $\\theta$ 上均使用均匀网格，同样在 $\\theta$ 方向上施加周期性边界条件。\n\n在这两种情况下，您应仅计算内部径向节点处的离散拉普拉斯算子（为避免边界闭合的复杂性，模板中应排除第一个和最后一个径向节点）。在 $\\theta$ 方向上，利用周期性在所有角坐标节点上构建中心差分格式。角度单位为弧度。\n\n为量化精度，请将离散拉普拉斯算子与通过解析方法得到的 $u(r,\\theta)$ 的精确连续拉普拉斯算子进行比较。使用在所有内部径向节点和所有角坐标节点上计算的面积加权 $L^2$ 相对误差，其中权重由网格上近似的极坐标面积元 $r\\,\\mathrm{d}r\\,\\mathrm{d}\\theta$ 给出。具体而言，如果 $D_h u$ 表示离散拉普拉斯算子，$D u$ 表示精确拉普拉斯算子，您的相对误差应为\n$$\nE = \\frac{\\left(\\sum_{i,j} w_{i,j}\\,\\left(D_h u(r_i,\\theta_j)-D u(r_i,\\theta_j)\\right)^2\\right)^{1/2}}{\\left(\\sum_{i,j} w_{i,j}\\,\\left(D u(r_i,\\theta_j)\\right)^2\\right)^{1/2}},\n$$\n其中 $w_{i,j}$ 是节点 $(r_i,\\theta_j)$ 处面积元 $r\\,\\mathrm{d}r\\,\\mathrm{d}\\theta$ 的近似值，使用相容的内部节点径向间距 $\\mathrm{d}r_i$（例如，在内部节点处，$\\mathrm{d}r_i=\\frac{1}{2}(r_{i+1}-r_{i-1})$）。在 $\\rho$ 均匀的情况下，您应一致地应用坐标变换，并仍然使用 $r\\,\\mathrm{d}r\\,\\mathrm{d}\\theta$ 在物理空间中对误差进行加权。\n\n此外，报告一个分辨率指标，以捕捉对数间距在原点附近的加密优势。将近原点分辨率增益 $G$ 定义为\n$$\nG=\\frac{\\Delta r_{\\min}^{\\text{uniform-}r}}{\\Delta r_{\\min}^{\\text{uniform-}\\rho}},\n$$\n其中 $\\Delta r_{\\min}^{\\text{uniform-}r}$ 是 $r$ 均匀网格上前两个径向节点之间的最小径向间距，而 $\\Delta r_{\\min}^{\\text{uniform-}\\rho}$ 是 $\\rho$ 均匀网格上前两个径向节点之间的最小径向间距。应对每个测试用例计算此比率 $G$。\n\n实现两种离散化方法并计算：\n- $E_r$：均匀 $r$ 网格上离散拉普拉斯算子的面积加权 $L^2$ 相对误差，\n- $E_\\rho$：均匀 $\\rho$ 网格上离散拉普拉斯算子的面积加权 $L^2$ 相对误差，\n- $Q=E_\\rho/E_r$：比较两种离散化方法的误差比，\n- $G$：如上定义的近原点分辨率增益。\n\n您的程序必须评估以下参数集构成的测试套件，这些参数集涵盖了一系列行为，包括一般情况、近原点陡峭梯度、粗分辨率和高角频率。角度单位为弧度。\n\n测试套件：\n- 用例 $1$：$r_\\min=1\\times 10^{-3}$，$r_\\max=1$，$N_r=200$，$N_\\theta=128$，$\\gamma=0.2$，$k=3$。\n- 用例 $2$：$r_\\min=1\\times 10^{-6}$，$r_\\max=1$，$N_r=200$，$N_\\theta=128$，$\\gamma=0.2$，$k=3$。\n- 用例 $3$：$r_\\min=1\\times 10^{-3}$，$r_\\max=1$，$N_r=50$，$N_\\theta=64$，$\\gamma=0.2$，$k=3$。\n- 用例 $4$：$r_\\min=1\\times 10^{-3}$，$r_\\max=10$，$N_r=200$，$N_\\theta=128$，$\\gamma=0.2$，$k=8$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，首先是用例 1 的四个值 $[E_r,E_\\rho,Q,G]$，然后依次是用例 2、用例 3 和用例 4 的结果，平铺成一个单一列表。例如，输出格式必须是\n$[E_{r,1},E_{\\rho,1},Q_1,G_1,E_{r,2},E_{\\rho,2},Q_2,G_2,E_{r,3},E_{\\rho,3},Q_3,G_3,E_{r,4},E_{\\rho,4},Q_4,G_4]$。", "solution": "本问题的目标是推导并比较两种基于有限差分的数值近似方法，用于求解极坐标下拉普拉斯算子，并应用于在原点附近表现出陡峭梯度的函数。比较将在一个由 $r \\in [r_\\min, r_\\max]$ 和 $\\theta \\in [0, 2\\pi)$ 定义的环形域上进行。这两种方案分别基于在 $(r, \\theta)$ 坐标上均匀的网格和在对数-极坐标 $(\\rho, \\theta)$ 上均匀的网格，其中 $\\rho = \\ln r$。\n\n### 1. 连续拉普拉斯算子\n\n分析始于笛卡尔坐标 $(x, y)$ 中的拉普拉斯算子 $\\nabla^2$：\n$$\n\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\n$$\n到极坐标的变换由 $x = r\\cos\\theta$ 和 $y = r\\sin\\theta$ 给出。使用链式法则变换偏导数，可以得到极坐标下拉普拉斯算子的著名表达式：\n$$\n\\nabla^2 u(r, \\theta) = \\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r} \\frac{\\partial u}{\\partial r} + \\frac{1}{r^2} \\frac{\\partial^2 u}{\\partial \\theta^2}\n$$\n该形式适用于在 $r$ 方向上具有均匀间距的网格上的离散化。\n\n对于第二种情况，我们引入对数径向坐标 $\\rho = \\ln r$，这意味着 $r = e^\\rho$。我们使用链式法则变换径向导数：\n$$\n\\frac{\\partial u}{\\partial r} = \\frac{\\partial u}{\\partial \\rho} \\frac{\\mathrm{d}\\rho}{\\mathrm{d}r} = \\frac{\\partial u}{\\partial \\rho} \\frac{1}{r}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial r^2} = \\frac{\\partial}{\\partial r}\\left(\\frac{1}{r} \\frac{\\partial u}{\\partial \\rho}\\right) = -\\frac{1}{r^2}\\frac{\\partial u}{\\partial \\rho} + \\frac{1}{r} \\frac{\\partial}{\\partial r}\\left(\\frac{\\partial u}{\\partial \\rho}\\right) = -\\frac{1}{r^2}\\frac{\\partial u}{\\partial \\rho} + \\frac{1}{r^2}\\frac{\\partial^2 u}{\\partial \\rho^2}\n$$\n将这些代入极坐标拉普拉斯公式可得：\n$$\n\\nabla^2 u = \\left(-\\frac{1}{r^2}\\frac{\\partial u}{\\partial \\rho} + \\frac{1}{r^2}\\frac{\\partial^2 u}{\\partial \\rho^2}\\right) + \\frac{1}{r}\\left(\\frac{1}{r} \\frac{\\partial u}{\\partial \\rho}\\right) + \\frac{1}{r^2}\\frac{\\partial^2 u}{\\partial \\theta^2}\n$$\n$\\rho$ 的一阶导数项相互抵消，从而得到一个非常简洁的形式：\n$$\n\\nabla^2 u(\\rho, \\theta) = \\frac{1}{r^2} \\left( \\frac{\\partial^2 u}{\\partial \\rho^2} + \\frac{\\partial^2 u}{\\partial \\theta^2} \\right) = e^{-2\\rho} \\left( \\frac{\\partial^2 u}{\\partial \\rho^2} + \\frac{\\partial^2 u}{\\partial \\theta^2} \\right)\n$$\n这种形式是有利的，因为括号内的微分算子是在 $(\\rho, \\theta)$ 坐标下的标准笛卡尔拉普拉斯算子，它天然地适用于在 $\\rho$ 和 $\\theta$ 上具有均匀间距的网格。\n\n### 2. 测试函数的解析拉普拉斯算子\n\n问题指定了测试函数 $u(r,\\theta) = r^\\gamma\\cos(k\\theta)$。我们使用极坐标公式计算其精确的拉普拉斯算子，记为 $D u$。所需的偏导数是：\n$$\n\\frac{\\partial u}{\\partial r} = \\gamma r^{\\gamma-1} \\cos(k\\theta)\n$$\n$$\n\\frac{\\partial^2 u}{\\partial r^2} = \\gamma(\\gamma-1) r^{\\gamma-2} \\cos(k\\theta)\n$$\n$$\n\\frac{\\partial^2 u}{\\partial \\theta^2} = -k^2 r^\\gamma \\cos(k\\theta)\n$$\n将这些代入极坐标拉普拉斯方程：\n$$\nD u = \\nabla^2 u = \\gamma(\\gamma-1) r^{\\gamma-2} \\cos(k\\theta) + \\frac{1}{r} (\\gamma r^{\\gamma-1} \\cos(k\\theta)) + \\frac{1}{r^2} (-k^2 r^\\gamma \\cos(k\\theta))\n$$\n$$\nD u = (\\gamma(\\gamma-1) + \\gamma - k^2) r^{\\gamma-2} \\cos(k\\theta) = (\\gamma^2 - k^2) r^{\\gamma-2} \\cos(k\\theta)\n$$\n这就是将与数值近似进行比较的解析表达式。\n\n### 3. 网格生成与离散化\n\n我们在域上定义两种类型的网格，两者都在径向有 $N_r$ 个点，在角向有 $N_\\theta$ 个点。两种情况下角向网格都是均匀的：$\\theta_j = j \\Delta\\theta$，其中 $j=0, 1, \\dots, N_\\theta-1$，且 $\\Delta\\theta = 2\\pi/N_\\theta$。\n\n#### 3.1. 均匀 $(r, \\theta)$ 网格\n径向节点是均匀分布的：$r_i = r_\\min + i \\Delta r$，其中 $i=0, 1, \\dots, N_r-1$，且 $\\Delta r = (r_\\max - r_\\min)/(N_r-1)$。我们在内部节点 $(r_i, \\theta_j)$ 处将二阶中心差分公式应用于极坐标拉普拉斯算子：\n$$\n(D_h u)_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{(\\Delta r)^2} + \\frac{1}{r_i}\\frac{u_{i+1,j} - u_{i-1,j}}{2\\Delta r} + \\frac{1}{r_i^2}\\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{(\\Delta\\theta)^2}\n$$\n此公式仅对内部径向节点 $i=1, \\dots, N_r-2$ 进行计算。对于角向导数，周期性意味着 $u_{i,N_\\theta} = u_{i,0}$ 和 $u_{i,-1} = u_{i,N_\\theta-1}$。\n\n#### 3.2. 均匀 $(\\rho, \\theta)$ 网格\n对数径向节点是均匀分布的：$\\rho_i = \\rho_\\min + i \\Delta\\rho$，其中 $i=0, 1, \\dots, N_r-1$，且 $\\rho_\\min = \\ln r_\\min$, $\\rho_\\max = \\ln r_\\max$, $\\Delta\\rho = (\\rho_\\max - \\rho_\\min)/(N_r-1)$。物理径向节点则为 $r_i = e^{\\rho_i}$。使用 $(\\rho, \\theta)$ 坐标系下简化的拉普拉斯算子形式，在 $(r_i, \\theta_j)$ 处的离散算子为：\n$$\n(D_h u)_{i,j} = \\frac{1}{r_i^2} \\left(\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{(\\Delta\\rho)^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{(\\Delta\\theta)^2}\\right)\n$$\n此公式也仅对 $i=1, \\dots, N_r-2$ 进行计算，并对 $\\theta$ 索引进行周期性处理。\n\n### 4. 误差与分辨率指标\n\n每种离散化方法的精度由面积加权的 $L^2$ 相对误差 $E$ 来量化：\n$$\nE = \\frac{\\left(\\sum_{i,j} w_{i,j}\\,\\left(D_h u(r_i,\\theta_j)-D u(r_i,\\theta_j)\\right)^2\\right)^{1/2}}{\\left(\\sum_{i,j} w_{i,j}\\,\\left(D u(r_i,\\theta_j)\\right)^2\\right)^{1/2}}\n$$\n求和遍及内部径向节点（$i=1, \\dots, N_r-2$）和所有角向节点（$j=0, \\dots, N_\\theta-1$）。面积权重 $w_{i,j}$ 是节点 $(r_i, \\theta_j)$ 处极坐标面积元 $r\\,\\mathrm{d}r\\,\\mathrm{d}\\theta$ 的近似。它由 $w_{i,j} = r_i \\Delta r_i \\Delta\\theta$ 给出，其中 $\\Delta r_i = \\frac{1}{2}(r_{i+1}-r_{i-1})$ 是中心化的径向单元宽度。\n- 对于均匀 $r$ 网格，$\\Delta r_i = \\Delta r$。\n- 对于均匀 $\\rho$ 网格，$\\Delta r_i = \\frac{1}{2}(e^{\\rho_i+\\Delta\\rho} - e^{\\rho_i-\\Delta\\rho}) = r_i \\sinh(\\Delta\\rho)$。\n\n为了比较这两种网格，我们计算误差比 $Q = E_\\rho / E_r$，其中 $E_r$ 和 $E_\\rho$ 分别是均匀 $r$ 网格和均匀 $\\rho$ 网格的误差。\n\n近原点分辨率增益 $G$ 定义为两种网格的第一个径向单元宽度的比值：\n$$\nG = \\frac{\\Delta r_{\\min}^{\\text{uniform-}r}}{\\Delta r_{\\min}^{\\text{uniform-}\\rho}} = \\frac{r_1^{\\text{uniform}}-r_0^{\\text{uniform}}}{r_1^{\\text{log}}-r_0^{\\text{log}}} = \\frac{\\Delta r}{r_\\min (e^{\\Delta\\rho}-1)}\n$$\n该指标量化了对数网格在内部边界 $r=r_\\min$ 附近的精细程度。这些推导出的公式构成了数值实现的基础。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def calculate_metrics_for_case(r_min, r_max, N_r, N_theta, gamma, k):\n        \"\"\"\n        Calculates the error and resolution metrics for a single test case.\n\n        Args:\n            r_min (float): Minimum radius of the annulus.\n            r_max (float): Maximum radius of the annulus.\n            N_r (int): Number of radial grid points.\n            N_theta (int): Number of angular grid points.\n            gamma (float): Exponent in the radial part of the test function.\n            k (int): Wavenumber in the angular part of the test function.\n\n        Returns:\n            list: A list containing [E_r, E_rho, Q, G].\n        \"\"\"\n        # Define the exact analytical functions\n        u_exact_func = lambda r, theta: (r**gamma) * np.cos(k * theta)\n        Du_exact_func = lambda r, theta: (gamma**2 - k**2) * (r**(gamma - 2)) * np.cos(k * theta)\n        \n        # --- Grid Parameters ---\n        theta = np.linspace(0, 2*np.pi, N_theta, endpoint=False)\n        delta_theta = 2 * np.pi / N_theta\n\n        # --- Grid 1: Uniform in r ---\n        \n        # Grid setup\n        r_uniform = np.linspace(r_min, r_max, N_r)\n        delta_r = (r_max - r_min) / (N_r - 1)\n        R_uniform, THETA = np.meshgrid(r_uniform, theta, indexing='ij')\n\n        # Evaluate function on the grid\n        U_r_grid = u_exact_func(R_uniform, THETA)\n\n        # Compute discrete Laplacian (interior radial nodes only)\n        # Slicing extracts interior points: i from 1 to N_r-2\n        U_r_interior = U_r_grid[1:-1, :]\n        u_im1 = U_r_grid[:-2, :]\n        u_ip1 = U_r_grid[2:, :]\n        # np.roll handles periodic boundary conditions in theta\n        u_jm1 = np.roll(U_r_grid, 1, axis=1)[1:-1, :]\n        u_jp1 = np.roll(U_r_grid, -1, axis=1)[1:-1, :]\n        \n        R_interior_2d = R_uniform[1:-1, :]\n        \n        d2u_dr2 = (u_ip1 - 2*U_r_interior + u_im1) / delta_r**2\n        du_dr = (u_ip1 - u_im1) / (2 * delta_r)\n        d2u_dtheta2 = (u_jp1 - 2*U_r_interior + u_jm1) / delta_theta**2\n        \n        DhU_r_grid = d2u_dr2 + (1/R_interior_2d) * du_dr + (1/R_interior_2d**2) * d2u_dtheta2\n        \n        # Error calculation for uniform-r grid\n        Du_r_grid = Du_exact_func(R_interior_2d, THETA[1:-1, :])\n        w_r = R_interior_2d[:, 0] * delta_r * delta_theta\n        w_r_2d = w_r[:, np.newaxis]\n\n        err_norm_sq_r = np.sum(w_r_2d * (DhU_r_grid - Du_r_grid)**2)\n        exact_norm_sq_r = np.sum(w_r_2d * Du_r_grid**2)\n        E_r = np.sqrt(err_norm_sq_r / exact_norm_sq_r)\n\n        # --- Grid 2: Uniform in rho = ln(r) ---\n        \n        # Grid setup\n        rho_min, rho_max = np.log(r_min), np.log(r_max)\n        rho_uniform = np.linspace(rho_min, rho_max, N_r)\n        delta_rho = (rho_max - rho_min) / (N_r - 1)\n        r_log = np.exp(rho_uniform)\n        R_log, THETA_log = np.meshgrid(r_log, theta, indexing='ij')\n\n        # Evaluate function on the grid\n        U_rho_grid = u_exact_func(R_log, THETA_log)\n\n        # Compute discrete Laplacian (interior radial nodes only)\n        U_rho_interior = U_rho_grid[1:-1, :]\n        u_im1_rho = U_rho_grid[:-2, :]\n        u_ip1_rho = U_rho_grid[2:, :]\n        u_jm1_rho = np.roll(U_rho_grid, 1, axis=1)[1:-1, :]\n        u_jp1_rho = np.roll(U_rho_grid, -1, axis=1)[1:-1, :]\n\n        R_log_interior_2d = R_log[1:-1, np.newaxis]\n\n        d2u_drho2 = (u_ip1_rho - 2*U_rho_interior + u_im1_rho) / delta_rho**2\n        d2u_dtheta2_rho = (u_jp1_rho - 2*U_rho_interior + u_jm1_rho) / delta_theta**2\n\n        DhU_rho_grid = (1/R_log_interior_2d**2) * (d2u_drho2 + d2u_dtheta2_rho)\n\n        # Error calculation for uniform-rho grid\n        Du_rho_grid = Du_exact_func(R_log_interior_2d, THETA_log[1:-1, :])\n        dr_i_log = 0.5 * (r_log[2:] - r_log[:-2]) # dr_i = 0.5 * (r_{i+1} - r_{i-1})\n        w_rho = r_log[1:-1] * dr_i_log * delta_theta\n        w_rho_2d = w_rho[:, np.newaxis]\n\n        err_norm_sq_rho = np.sum(w_rho_2d * (DhU_rho_grid - Du_rho_grid)**2)\n        exact_norm_sq_rho = np.sum(w_rho_2d * Du_rho_grid**2)\n        E_rho = np.sqrt(err_norm_sq_rho / exact_norm_sq_rho)\n\n        # --- Final Metrics Q and G ---\n        Q = E_rho / E_r\n        \n        delta_r_min_uniform = delta_r\n        delta_r_min_log = r_log[1] - r_log[0]\n        G = delta_r_min_uniform / delta_r_min_log\n        \n        return [E_r, E_rho, Q, G]\n\n    # Test suite defined in the problem statement\n    test_cases = [\n        # (r_min, r_max, N_r, N_theta, gamma, k)\n        (1e-3, 1.0, 200, 128, 0.2, 3),\n        (1e-6, 1.0, 200, 128, 0.2, 3),\n        (1e-3, 1.0, 50, 64, 0.2, 3),\n        (1e-3, 10.0, 200, 128, 0.2, 8),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = calculate_metrics_for_case(*case)\n        results.extend(case_results)\n\n    # Format the final output as a single comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3379306"}]}