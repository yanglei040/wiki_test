{"hands_on_practices": [{"introduction": "掌握一维扩散问题的数值解法不仅需要理解离散化理论，更需要动手实践以深化理解。本章提供了一系列实践练习，旨在揭示数值格式的内在行为、迭代求解器的关键特性，以及不同误差源之间的相互作用。我们首先从分析一种广泛使用的时间步进格式——Crank-Nicolson方法开始。虽然该方法以其二阶精度和无条件稳定性而闻名，但这并不意味着它在所有情况下都能产生物理上真实可靠的解。这项练习 [@problem_id:3458532] 将通过分析其放大矩阵的谱特性，探讨该格式对解中不同空间频率分量的影响，特别是其对高频模式的阻尼特性以及可能引发的非物理振荡。这项分析对于培养对数值方法的批判性眼光至关重要，它提醒我们，即使是理论上稳定的格式，在实际应用中也需谨慎评估其表现。", "problem": "考虑定义在有界区间上且带有齐次狄利克雷边界条件的一维扩散（热）方程 $u_t = \\kappa u_{xx}$，其中 $\\kappa > 0$ 是扩散系数。用间距为 $h$ 的均匀网格对空间进行离散化，并用标准的二阶中心有限差分算子来近似 $-u_{xx}$，从而得到一个表示 $-u_{xx}$ 离散算子的对称正定三对角矩阵 $T \\in \\mathbb{R}^{N \\times N}$。令 $\\lambda = \\kappa \\Delta t / h^2$，其中 $\\Delta t > 0$ 是时间步长。时间上采用 $\\theta = 1/2$ 的 $\\theta$ 方法（Crank-Nicolson 方法）得到以下线性更新方程：\n$$(I + \\tfrac{\\lambda}{2} T) u^{n+1} = (I - \\tfrac{\\lambda}{2} T) u^n,$$\n因此放大矩阵为：\n$$G = (I + \\tfrac{\\lambda}{2} T)^{-1} (I - \\tfrac{\\lambda}{2} T)。$$\n仅使用关于对称正定矩阵谱性质和偏微分方程（PDE）线性时间步进方法的第一性原理，推导潜在的时间振荡如何与 $G$ 的谱相关联，并解释高频空间模式的阻尼特性。然后，选择最能准确描述在 Crank-Nicolson 格式下，$G$ 的谱半径与高频模式行为之间正确关系的陈述。\n\nA. 对于所有 $\\lambda > 0$ 和任何对称正定矩阵 $T$，$G$ 的所有特征值都位于 $(0,1)$ 内，谱半径 $\\rho(G)$ 严格小于 1，并且不会发生时间振荡。\n\nB. 对于所有 $\\lambda > 0$ 和任何对称正定矩阵 $T$，$G$ 的特征值 $\\gamma$ 都是实数且满足 $\\lvert \\gamma \\rvert \\le 1$；此外，对于 $T$ 的一个特征值 $\\mu$，当且仅当 $\\lambda \\mu > 2$ 时，$\\gamma$ 变为负值，导致这些模态分量出现随时间交替的振荡。随着 $\\lambda$ 的增加，$\\rho(G)$ 趋近于 1，这意味着高频模式的阻尼很弱。\n\nC. 对于足够大的 $\\lambda$，放大矩阵 $G$ 具有模大于 1 的共轭复特征值，因此 Crank-Nicolson 方法由于高频模式的增长而变得不稳定。\n\nD. 增加 $\\lambda$ 会使谱半径 $\\rho(G)$ 严格减小并趋向于 0，因此高频模式被强力阻尼，并且对于任何 $\\lambda$ 都不会发生振荡。", "solution": "用户要求我验证问题陈述，如果有效，则基于关于一维扩散方程的 Crank-Nicolson 方法的第一性原理推导解答。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n*   **偏微分方程 (PDE)**：$u_t = \\kappa u_{xx}$，其中 $\\kappa > 0$。\n*   **区域**：有界区间。\n*   **边界条件**：齐次狄利克雷边界条件。\n*   **空间离散化**：间距为 $h$ 的均匀网格。\n*   **离散算子**：$-u_{xx}$ 由一个对称正定（SPD）三对角矩阵 $T \\in \\mathbb{R}^{N \\times N}$ 近似。\n*   **时间离散化**：采用 $\\theta = 1/2$ 的 $\\theta$ 方法（Crank-Nicolson）。\n*   **参数**：时间步长 $\\Delta t > 0$；扩散数 $\\lambda = \\kappa \\Delta t / h^2 > 0$。\n*   **更新方程**：$(I + \\tfrac{\\lambda}{2} T) u^{n+1} = (I - \\tfrac{\\lambda}{2} T) u^n$。\n*   **放大矩阵**：$G = (I + \\tfrac{\\lambda}{2} T)^{-1} (I - \\tfrac{\\lambda}{2} T)$。\n*   **任务**：\n    1.  推导时间振荡与 $G$ 的谱之间的关系。\n    2.  解释高频空间模式的阻尼特性。\n    3.  选择最能描述 $G$ 的谱半径与高频模式行为之间关系的陈述。\n\n**步骤2：使用提取的已知条件进行验证**\n\n1.  **科学上是合理的**：该问题描述了 Crank-Nicolson 方法在扩散方程上的标准应用。使用有限差分格式得到对应于带齐次狄利克雷边界条件的离散负拉普拉斯算子的对称正定矩阵，是数值偏微分方程分析的基石。所有概念都是标准的并且在科学上是合理的。\n2.  **良定的**：该问题是良定的。给定矩阵 $T$ 的性质，放大矩阵 $G$ 的性质可以被唯一确定和分析。问题要求对这些性质进行具体分析。\n3.  **客观的**：语言是精确的、数学化的，没有主观或含糊的陈述。\n4.  **完整性和一致性**：问题是自洽的。明确说明了 $T$ 是对称正定的关键性质，这对于谱分析来说是必需的全部信息。所提供的更新方程和 $G$ 的定义对于 Crank-Nicolson 方法是正确的。\n5.  **其他缺陷**：该问题不是隐喻性的、琐碎的、无法验证的或病态的。它是该领域一个标准且重要的分析。\n\n**步骤3：结论和行动**\n\n问题陈述是**有效的**。我将继续进行推导和求解。\n\n### 推导\n\n时间步进格式的稳定性和准确性由放大矩阵 $G$ 的谱性质决定。问题陈述指出 $T$ 是一个对称正定（SPD）矩阵。\n\n由于 $T$ 是对称的，它可以通过一组标准正交的特征向量基进行对角化。设 $\\{v_k\\}_{k=1}^N$ 是 $T$ 的特征向量集合，对应的特征值为 $\\{\\mu_k\\}_{k=1}^N$。根据有界域上带有齐次狄利克雷条件的 $-u_{xx}$ 的有限差分近似的性质，以及 $T$ 是正定的已知事实，我们知道它的所有特征值都是实数且严格为正：对于所有 $k=1, \\dots, N$，有 $\\mu_k > 0$。\n\n我们现在分析放大矩阵 $G$ 对 $T$ 的一个特征向量 $v_k$ 的作用：\n$$G v_k = (I + \\tfrac{\\lambda}{2} T)^{-1} (I - \\tfrac{\\lambda}{2} T) v_k$$\n首先，我们应用最右边的部分：\n$$(I - \\tfrac{\\lambda}{2} T) v_k = I v_k - \\tfrac{\\lambda}{2} T v_k = v_k - \\tfrac{\\lambda}{2} \\mu_k v_k = (1 - \\tfrac{\\lambda}{2} \\mu_k) v_k$$\n现在，我们将逆矩阵 $(I + \\tfrac{\\lambda}{2} T)^{-1}$ 应用于此结果。$T$ 的特征向量也是 $(I + \\tfrac{\\lambda}{2} T)$ 的特征向量：\n$$(I + \\tfrac{\\lambda}{2} T) v_k = v_k + \\tfrac{\\lambda}{2} \\mu_k v_k = (1 + \\tfrac{\\lambda}{2} \\mu_k) v_k$$\n因为 $\\lambda > 0$ 且 $\\mu_k > 0$，特征值 $(1 + \\tfrac{\\lambda}{2} \\mu_k)$ 总是严格大于 $1$，所以矩阵 $(I + \\tfrac{\\lambda}{2} T)$ 是可逆的。逆矩阵 $(I + \\tfrac{\\lambda}{2} T)^{-1}$ 的特征值就是 $(I + \\tfrac{\\lambda}{2} T)$ 特征值的倒数。因此：\n$$(I + \\tfrac{\\lambda}{2} T)^{-1} v_k = \\frac{1}{1 + \\tfrac{\\lambda}{2} \\mu_k} v_k$$\n结合这些步骤：\n$$G v_k = (I + \\tfrac{\\lambda}{2} T)^{-1} \\left( (1 - \\tfrac{\\lambda}{2} \\mu_k) v_k \\right) = (1 - \\tfrac{\\lambda}{2} \\mu_k) (I + \\tfrac{\\lambda}{2} T)^{-1} v_k$$\n$$G v_k = (1 - \\tfrac{\\lambda}{2} \\mu_k) \\left( \\frac{1}{1 + \\tfrac{\\lambda}{2} \\mu_k} \\right) v_k = \\left( \\frac{1 - \\tfrac{\\lambda}{2} \\mu_k}{1 + \\tfrac{\\lambda}{2} \\mu_k} \\right) v_k$$\n这表明 $T$ 的特征向量 $v_k$ 也是 $G$ 的特征向量。$G$ 对应的特征值，我们记为 $\\gamma_k$，由以下有理函数给出：\n$$\\gamma_k = \\frac{1 - \\tfrac{\\lambda \\mu_k}{2}}{1 + \\tfrac{\\lambda \\mu_k}{2}}$$\n让我们分析这个放大因子 $\\gamma_k$。因为 $\\lambda > 0$ 且 $\\mu_k > 0$，乘积 $\\lambda \\mu_k$ 是一个正实数。\n$\\gamma_k$ 的模是：\n$$|\\gamma_k| = \\left| \\frac{1 - \\tfrac{\\lambda \\mu_k}{2}}{1 + \\tfrac{\\lambda \\mu_k}{2}} \\right| = \\frac{|1 - \\tfrac{\\lambda \\mu_k}{2}|}{1 + \\tfrac{\\lambda \\mu_k}{2}}$$\n因为 $x \\ge |y|$ 意味着 $x \\ge y$ 和 $x \\ge -y$，我们可以检验对于所有 $\\lambda \\mu_k > 0$，$1 + \\tfrac{\\lambda \\mu_k}{2} \\ge |1 - \\tfrac{\\lambda \\mu_k}{2}|$ 成立。这意味着 $|\\gamma_k| \\le 1$。因此，对于任何 $\\lambda > 0$ 的选择，该方法都是无条件稳定的。等式 $|\\gamma_k|=1$ 在极限 $\\lambda\\mu_k \\to \\infty$ 时成立，此时 $\\gamma_k \\to -1$。对于任何有限的 $\\lambda$ 和 $\\mu_k$，由于 $\\lambda \\mu_k > 0$，所以 $|\\gamma_k|  1$。\n\n**时间振荡**：\n如果解的某个模态分量的放大因子 $\\gamma_k$ 是负数，那么该分量就会经历时间振荡。这会导致该分量振幅的符号在每个时间步都发生翻转。$\\gamma_k$ 为负的条件是：\n$$\\gamma_k  0 \\implies \\frac{1 - \\tfrac{\\lambda \\mu_k}{2}}{1 + \\tfrac{\\lambda \\mu_k}{2}}  0$$\n因为分母 $(1 + \\tfrac{\\lambda \\mu_k}{2})$ 总是正的，所以分子必须是负的：\n$$1 - \\tfrac{\\lambda \\mu_k}{2}  0 \\implies 1  \\tfrac{\\lambda \\mu_k}{2} \\implies \\lambda \\mu_k > 2$$\n因此，当扩散数 $\\lambda$ 和特征值 $\\mu_k$ 的乘积超过 2 时，对应的模式会发生振荡。\n\n**高频模式的阻尼**：\n离散拉普拉斯算子 $T$ 的特征向量 $v_k$ 对应于不同空间频率的离散正弦波。“高频”模式对应于具有最大特征值 $\\mu_k$ 的特征向量。对于 $-u_{xx}$ 的标准二阶中心差分矩阵，其最大特征值 $\\mu_{max}$ 的量级为 $O(h^{-2})$。\n阻尼由 $|\\gamma_k|$ 决定。强阻尼意味着 $|\\gamma_k| \\ll 1$，而弱阻尼意味着 $|\\gamma_k| \\approx 1$。让我们考察高频模式（即大的 $\\mu_k$）下 $\\gamma_k$ 的行为。当 $\\mu_k \\to \\infty$（或更实际地，当 $\\mu_k$ 取其最大值，与 $h^{-2}$ 成正比）时，乘积 $\\lambda \\mu_k = (\\kappa \\Delta t/h^2)\\mu_k$ 也会变得很大。\n在 $\\lambda \\mu_k$ 很大的极限情况下：\n$$\\lim_{\\lambda \\mu_k \\to \\infty} \\gamma_k = \\lim_{\\lambda \\mu_k \\to \\infty} \\frac{1 - \\tfrac{\\lambda \\mu_k}{2}}{1 + \\tfrac{\\lambda \\mu_k}{2}} = \\lim_{x \\to \\infty} \\frac{1/x - 1/2}{1/x + 1/2} = \\frac{-1/2}{1/2} = -1$$\n这意味着对于高频模式，特别是当 $\\lambda$ 很大时，放大因子 $\\gamma_k$ 趋近于 -1。因此，其模 $|\\gamma_k|$ 趋近于 1。这表明高频模式的阻尼非常**弱**，同时会经历强烈的时间振荡。这是 Crank-Nicolson 方法一个众所周知的缺陷。\n\n**谱半径**：\n$G$ 的谱半径为 $\\rho(G) = \\max_k |\\gamma_k|$。$|\\gamma(\\lambda \\mu)|$ 作为正变量 $x = \\lambda \\mu$ 的函数，其行为是从 1（在 $x=0$ 时）减小到 0（在 $x=2$ 时），然后从 0 再次增加，并在 $x \\to \\infty$ 时趋向于 1。因此，谱半径由 $\\rho(G) = \\max(|\\gamma(\\lambda\\mu_{min})|, |\\gamma(\\lambda\\mu_{max})|)$ 给出。随着 $\\lambda$ 的增加，$\\lambda \\mu_{max}$ 会变得很大并占主导地位，因此 $\\rho(G) \\approx |\\gamma(\\lambda \\mu_{max})|$。由于 $\\lim_{x\\to\\infty} |\\gamma(x)| = 1$，我们得出结论，随着 $\\lambda$ 的增加，$\\rho(G)$ 趋近于 1。\n\n### 选项分析\n\n**A. 对于所有 $\\lambda > 0$ 和任何对称正定矩阵 $T$，$G$ 的所有特征值都位于 $(0,1)$ 内，谱半径 $\\rho(G)$ 严格小于 1，并且不会发生时间振荡。**\n这是**不正确的**。如推导所示，如果对于 $T$ 的任意特征值 $\\mu_k$ 有 $\\lambda \\mu_k > 2$，则 $G$ 对应的特征值 $\\gamma_k$ 会变为负数。由于我们总可以选择足够大的 $\\lambda$，所以在某些条件下 $G$ 的特征值会是负的，从而导致振荡。\n\n**B. 对于所有 $\\lambda > 0$ 和任何对称正定矩阵 $T$，$G$ 的特征值 $\\gamma$ 都是实数且满足 $\\lvert \\gamma \\rvert \\le 1$；此外，对于 $T$ 的一个特征值 $\\mu$，当且仅当 $\\lambda \\mu > 2$ 时，$\\gamma$ 变为负值，导致这些模态分量出现随时间交替的振荡。随着 $\\lambda$ 的增加，$\\rho(G)$ 趋近于 1，这意味着高频模式的阻尼很弱。**\n这是**正确的**。我们的推导表明：\n1.  特征值 $\\gamma_k$ 是实数。\n2.  无条件稳定性成立：$|\\gamma_k| \\le 1$。\n3.  当 $\\gamma_k  0$ 时发生振荡，这恰好是当 $\\lambda \\mu_k > 2$ 时。\n4.  随着 $\\lambda$ 的增加，$\\rho(G)$ 由高频模式主导并趋近于 1。\n5.  $|\\gamma_k| \\to 1$ 意味着高频模式的阻尼很弱。\n该陈述准确地总结了分析的所有关键发现。\n\n**C. 对于足够大的 $\\lambda$，放大矩阵 $G$ 具有模大于 1 的共轭复特征值，因此 Crank-Nicolson 方法由于高频模式的增长而变得不稳定。**\n这是**不正确的**。由于 $T$ 是对称正定的，其特征值 $\\mu_k$ 是实数。$\\gamma_k$ 的公式只涉及实数，因此 $\\gamma_k$ 必定是实数。此外，我们证明了 $|\\gamma_k| \\le 1$，所以该方法是无条件稳定的，模永远不会超过 1。\n\n**D. 增加 $\\lambda$ 会使谱半径 $\\rho(G)$ 严格减小并趋向于 0，因此高频模式被强力阻尼，并且对于任何 $\\lambda$ 都不会发生振荡。**\n这是**不正确的**。增加 $\\lambda$ 会导致 $\\rho(G)$ 趋近于 1，而不是 0。这对应于高频模式的弱阻尼，而非强阻尼。对于足够大的 $\\lambda$，振荡可以且确实会发生。", "answer": "$$\\boxed{B}$$", "id": "3458532"}, {"introduction": "在对扩散方程进行时空离散后，我们每一步都需要求解一个大型线性方程组。对于一维问题，高效的Thomas算法是直接求解三对角系统的首选。然而，为了理解更普适于高维问题和高级计算方法中的技术，研究迭代法至关重要。此项练习 [@problem_id:3458583] 聚焦于一种基础的迭代法——高斯-赛德尔（Gauss-Seidel）法，但我们分析的视角并非将其作为一个独立的求解器，而是作为多重网格方法中的一个“平滑器”。我们将运用局部傅里叶分析（Local Fourier Analysis）来推导误差分量在迭代过程中的放大因子，并计算出关键的“平滑因子”$ \\mu_s $。这个练习揭示了多重网格方法效率的核心秘密：平滑器的目标不是完全求解方程，而是快速地衰减那些在粗网格上无法表示的高频误差，为粗网格校正铺平道路。", "problem": "考虑一个均匀网格上的一维扩散模型问题，该问题导出了与离散拉普拉斯算子相关的三对角系统。具体来说，令 $A$ 表示一个 $N \\times N$ 的三对角矩阵，其模板为 $[-1,\\, 2,\\, -1]$，对应于带齐次狄利克雷边界条件的负二阶导数的二阶中心有限差分格式。假设我们使用高斯-赛德尔（GS）方法，采用标准的向前字典序，来求解 $A x = b$。将 $A$ 分解为 $A = L + D + U$，其中 $D$ 是对角部分，$L$ 是严格下三角部分，$U$ 是严格上三角部分。\n\n使用误差传播的观点和周期性延拓来进行局部傅里叶分析（LFA）。即，考虑一次GS扫描后的误差满足 $e^{\\text{new}} = T e^{\\text{old}}$，其中 $T = (D + L)^{-1} U$，并分析 $T$ 在离散傅里叶模 $e_j = \\exp(i j \\theta)$ 上的作用，其中 $j \\in \\mathbb{Z}$，$\\theta \\in [0, \\pi]$。推导标量放大因子 $g(\\theta)$，使得 $T$ 将傅里叶模映射为该模乘以 $g(\\theta)$，然后定义高频集 $\\Theta_H = [\\pi/2,\\, \\pi]$，它是在标准双网格多重网格方法中，下一层更粗网格上可表示的子空间的补集。\n\n从迭代方法和离散算子的第一性原理出发，计算平滑因子\n$$\n\\mu_s \\;=\\; \\sup_{\\theta \\in \\Theta_H} \\, |g(\\theta)|,\n$$\n并将最终结果表示为单个封闭形式的实数。在你的推导中，明确论证为什么这个值可以量化高频误差模式的衰减，并简要解释这种衰减如何与一维双网格多重网格方法的效率相关联。最终的数值必须是精确值，而不是近似值，且不带单位。", "solution": "该问题要求使用局部傅里叶分析（LFA）计算一维离散拉普拉斯算子的高斯-赛德尔平滑因子。\n\n首先，我们验证问题陈述的有效性。\n\n### 第一步：提取已知条件\n- **问题：** 均匀网格上的一维扩散模型。\n- **系统：** 三对角线性系统 $A x = b$。\n- **矩阵A：** 一个由模板 $[-1, 2, -1]$ 定义的 $N \\times N$ 三对角矩阵。这对应于带齐次狄利克雷边界条件的负二阶导数 $-\\frac{d^2}{dx^2}$ 的二阶中心有限差分格式（尽管在LFA中边界条件被忽略）。\n- **迭代方法：** 高斯-赛德尔（GS），采用向前字典序。\n- **矩阵分裂：** $A = L + D + U$，其中 $D$ 是 $A$ 的对角部分，$L$ 是严格下三角部分，$U$ 是严格上三角部分。\n- **分析方法：** 使用周期性延拓的局部傅里叶分析（LFA）。\n- **误差传播算子：** 分析将在算子 $T = (D+L)^{-1} U$ 上进行。误差传播表述为 $e^{\\text{new}} = T e^{\\text{old}}$。\n- **傅里叶模：** $e_j = \\exp(i j \\theta)$，其中 $j \\in \\mathbb{Z}$ 且 $\\theta \\in [0, \\pi]$。\n- **放大因子：** 一个标量 $g(\\theta)$，使得算子 $T$ 将傅里叶模映射为该模乘以 $g(\\theta)$。\n- **高频集：** $\\Theta_H = [\\pi/2, \\pi]$。\n- **目标：** 计算平滑因子 $\\mu_s = \\sup_{\\theta \\in \\Theta_H} |g(\\theta)|$。\n- **附加要求：** 论证 $\\mu_s$ 在量化高频误差衰减中的作用，并解释其与双网格多重网格方法效率的联系。\n\n### 第二步：使用提取的已知条件进行验证\n该问题具有科学依据，是偏微分方程数值分析中的一个标准课题。它是一个适定问题，所有找到唯一解的必要组成部分都已定义。语言客观而精确。设置是自洽和一致的。所要求的推导和解释是标准的教科书内容，使得该问题既不琐碎也不过于复杂。该问题是有效的。\n\n### 第三步：结论与行动\n问题被认为是有效的。我们继续进行求解。\n\n### 平滑因子的推导\n\n设 $v$ 是定义在无限一维网格（用于LFA的“周期性延拓”）上的网格函数。带有模板 $[-1, 2, -1]$ 的矩阵 $A$ 在网格点 $j$ 处的作用由下式给出：\n$$\n(Av)_j = -v_{j-1} + 2v_j - v_{j+1}\n$$\n从分裂 $A = L + D + U$ 中，我们可以确定分量 $L$、$D$ 和 $U$ 的作用：\n- 对角部分：$(Dv)_j = 2v_j$\n- 严格下三角部分：$(Lv)_j = -v_{j-1}$\n- 严格上三角部分：$(Uv)_j = -v_{j+1}$\n\n我们使用LFA来分析算子 $T = (D+L)^{-1}U$ 在离散傅里叶模 $v(\\theta)$ 上的作用，其分量由 $v_j(\\theta) = \\exp(ij\\theta)$ 定义，频率为 $\\theta \\in [0, \\pi]$。放大因子 $g(\\theta)$ 是对应于此傅里叶模的算子的特征值。也就是说，如果 $w = T v(\\theta)$，那么我们寻求 $g(\\theta)$ 使得 $w_j = g(\\theta) v_j$。\n\n定义 $w$ 的方程是 $(D+L)w = U v(\\theta)$。让我们在网格点 $j$ 处按分量写出这个方程：\n$$\n(Dw)_j + (Lw)_j = (Uv(\\theta))_j\n$$\n$$\n2w_j - w_{j-1} = -v_{j+1}(\\theta)\n$$\n我们假设解的形式为 $w_j = g(\\theta) v_j(\\theta) = g(\\theta) \\exp(ij\\theta)$。将此 ansatz 和 $v(\\theta)$ 的定义代入方程得到：\n$$\n2 g(\\theta) \\exp(ij\\theta) - g(\\theta) \\exp(i(j-1)\\theta) = - \\exp(i(j+1)\\theta)\n$$\n将整个方程除以非零项 $\\exp(ij\\theta)$：\n$$\n2 g(\\theta) - g(\\theta) \\exp(-i\\theta) = - \\exp(i\\theta)\n$$\n提出因子 $g(\\theta)$：\n$$\ng(\\theta) (2 - \\exp(-i\\theta)) = - \\exp(i\\theta)\n$$\n求解放大因子 $g(\\theta)$：\n$$\ng(\\theta) = - \\frac{\\exp(i\\theta)}{2 - \\exp(-i\\theta)}\n$$\n这个放大因子 $g(\\theta)$ 是针对问题中定义的算子 $T = (D+L)^{-1}U$ 的。标准的GS误差传播算子是 $T_{GS} = -(D+L)^{-1}U$，其放大因子与 $g(\\theta)$ 相差一个负号。由于平滑因子 $\\mu_s$ 是放大因子模的上确界，这个符号差异不影响最终结果。我们计算 $|g(\\theta)|$ 的平方：\n$$\n|g(\\theta)|^2 = \\left| - \\frac{\\exp(i\\theta)}{2 - \\exp(-i\\theta)} \\right|^2 = \\frac{|\\exp(i\\theta)|^2}{|2 - \\exp(-i\\theta)|^2} = \\frac{1}{(2 - \\exp(-i\\theta))(2 - \\exp(i\\theta))}\n$$\n$$\n|g(\\theta)|^2 = \\frac{1}{4 - 2\\exp(i\\theta) - 2\\exp(-i\\theta) + \\exp(-i\\theta)\\exp(i\\theta)}\n$$\n$$\n|g(\\theta)|^2 = \\frac{1}{4 - 2(\\exp(i\\theta) + \\exp(-i\\theta)) + 1} = \\frac{1}{5 - 2(2\\cos\\theta)} = \\frac{1}{5 - 4\\cos\\theta}\n$$\n所以，放大因子的模是：\n$$\n|g(\\theta)| = \\frac{1}{\\sqrt{5 - 4\\cos\\theta}}\n$$\n平滑因子 $\\mu_s$ 是这个量在高频集 $\\Theta_H = [\\pi/2, \\pi]$ 上的上确界。\n$$\n\\mu_s = \\sup_{\\theta \\in [\\pi/2, \\pi]} \\frac{1}{\\sqrt{5 - 4\\cos\\theta}}\n$$\n为了最大化这个表达式，我们必须最小化分母，这意味着在 $\\theta \\in [\\pi/2, \\pi]$ 上最小化函数 $f(\\theta) = 5 - 4\\cos\\theta$。最小化 $f(\\theta)$ 等价于在区间 $[\\pi/2, \\pi]$ 上最大化项 $\\cos\\theta$。\n\n函数 $\\cos\\theta$ 在区间 $[0, \\pi]$ 上是单调递减的。因此，在子区间 $[\\pi/2, \\pi]$ 上，其最大值出现在左端点 $\\theta = \\pi/2$。\n在 $\\theta = \\pi/2$ 处，我们有 $\\cos(\\pi/2) = 0$。\n在 $\\Theta_H$ 上 $f(\\theta)$ 的最小值是 $f(\\pi/2) = 5 - 4\\cos(\\pi/2) = 5 - 4(0) = 5$。\n函数 $|g(\\theta)|$ 在 $\\Theta_H$ 上是单调递减的，所以其上确界在左端点 $\\theta = \\pi/2$ 处取得。\n\n因此，平滑因子是：\n$$\n\\mu_s = |g(\\pi/2)| = \\frac{1}{\\sqrt{5 - 4\\cos(\\pi/2)}} = \\frac{1}{\\sqrt{5}} = \\frac{\\sqrt{5}}{5}\n$$\n作为验证，在区间的另一端 $\\theta=\\pi$ 处，我们有 $|g(\\pi)| = \\frac{1}{\\sqrt{5 - 4(-1)}} = \\frac{1}{\\sqrt{9}} = \\frac{1}{3}$。由于 $\\frac{1}{\\sqrt{5}} \\approx 0.447 > \\frac{1}{3}$，最大值确实在 $\\theta=\\pi/2$ 处。\n\n### 论证及与多重网格方法的联系\n\n平滑因子 $\\mu_s$ 量化了迭代方法（一个“平滑器”）在衰减误差高频分量方面的最差情况性能。在多重网格方法的背景下，问题在一系列层次化的网格上进行离散化。细网格上的高频误差分量是那些在下一层更粗的网格上无法准确表示的分量。对于标准的粗化比为2的情况，这些模式对应于频率 $\\theta \\in \\Theta_H = [\\pi/2, \\pi]$。\n\n一个有效的平滑器，如高斯-赛德尔方法，其设计目的并非自身能高效求解线性系统，而是为了快速减小这些高频误差分量的振幅。值 $\\mu_s = \\sup_{\\theta \\in \\Theta_H} |g(\\theta)|$ 是所有这些棘手的高频模式中最大的放大因子。一个小于1的 $\\mu_s$ 值保证了所有高频误差都会被衰减。$\\mu_s$ 的值越小，平滑器就越有效。\n\n与多重网格效率的联系是直接的。一个多重网格循环包括两个主要过程：平滑和粗网格校正。\n1.  **平滑：** 应用几次平滑器（例如，高斯-赛德尔）扫描。这一步能有效衰减高频误差，但对低频误差的衰减非常慢（对于GS，最坏情况是 $|g(0)|=1$）。平滑之后，剩余的误差主要由低频分量构成，即误差是“光滑的”。\n2.  **粗网格校正：** 这个光滑的误差可以在更粗的网格上被精确近似。控制误差的残差方程被转移到粗网格上并在那里求解（通常是递归地）。然后，得到的粗网格校正被插值回细网格以更新解，从而有效减少低频误差分量。\n\n整个双网格（并延伸至多重网格）循环的效率取决于这两个步骤之间的相互作用。平滑器必须有效地消除粗网格校正无法处理的误差分量。一个小的平滑因子 $\\mu_s$ 确保了高频误差在几次迭代内被充分衰减，从而使算法能够进入粗网格。因此，$\\mu_s$ 是多重网格方法收敛率的关键预测指标。", "answer": "$$\n\\boxed{\\frac{\\sqrt{5}}{5}}\n$$", "id": "3458583"}, {"introduction": "在解决了时间格式分析和迭代法特性的问题后，我们将在最终的实践中将这些概念融会贯通。在求解大规模科学与工程问题时，为了节约计算资源，每个时间步中的线性系统通常采用迭代法进行非精确求解。这项动手实践 [@problem_id:3458596] 通过一个完整的数值实验，探讨了这种非精确性对全局解精度的累积影响。我们将为后向欧拉格式配置一个迭代求解器，并面临一个核心挑战：如何设定迭代求解器的容忍度$ \\varepsilon $？我们的目标是推导并实现一个选择准则，确保由非精确求解引入的累积代数误差，不会超过时间离散格式本身固有的截断误差。这个练习完美地模拟了真实科研计算中权衡计算成本与求解精度的情景，通过理论分析指导参数选择，并最终通过编码实现来验证理论的正确性，从而完成从理论到实践的闭环。", "problem": "考虑定义域 $[0,1]$ 上的一维扩散方程，其具有齐次狄利克雷边界条件和归一化单位，使得扩散系数等于1。该偏微分方程为 $u_t = u_{xx}$，其中 $u(0,t) = 0$，$u(1,t) = 0$，且对于 $x \\in [0,1]$ 有 $u(x,0) = \\sin(\\pi x)$。使用 $N$ 个内部点对空间进行离散化，以获得均匀的网格间距 $h = \\frac{1}{N+1}$，并使用拉普拉斯算子的标准二阶中心有限差分近似。使用时间步长 $\\Delta t$ 和最终时间 $T$，采用后向欧拉法（全隐式）对时间进行离散化。每个时间步得到的线性系统为 $A u^{n+1} = u^{n}$，其中 $A = I - \\Delta t L_h$，$L_h$ 是带有狄利克雷边界条件的离散拉普拉斯算子，其三对角表示如下\n$$\nA = \\begin{bmatrix}\n1 + \\frac{2\\Delta t}{h^2}  -\\frac{\\Delta t}{h^2}   \\\\\n-\\frac{\\Delta t}{h^2}  1 + \\frac{2\\Delta t}{h^2}  -\\frac{\\Delta t}{h^2}  \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  -\\frac{\\Delta t}{h^2}  1 + \\frac{2\\Delta t}{h^2}  -\\frac{\\Delta t}{h^2} \\\\\n   -\\frac{\\Delta t}{h^2}  1 + \\frac{2\\Delta t}{h^2}\n\\end{bmatrix},\n$$\n其维度为 $N \\times N$，零狄利克雷边界通过内部未知数并入。由于 $A$ 是对称正定矩阵，任何线性求解都可以通过 Thomas 算法（精确到机器精度）或迭代方法（如共轭梯度法 (Conjugate Gradient, CG) 或截断的并行循环规约法 (truncated Parallel Cyclic Reduction, PCR)）来执行。迭代方法可以根据相对残差容差 $\\varepsilon$ 提前停止。\n\n您的任务是检验在每个时间步使用非精确三对角求解器如何影响最终时间 $T$ 的全局时间误差，并建立一个容差选择规则，以确保累积的代数误差保持在时间离散误差以下。请使用以下基本原理。\n- 后向欧拉法在时间上具有一阶精度，因此对于足够光滑的解，其全局时间离散误差表现为 $\\mathcal{O}(\\Delta t)$。\n- 对于线性求解 $A x = b$，若其非精确解为 $\\tilde{x}$，残差为 $r = b - A \\tilde{x}$，则代数解误差在任何从属范数下都满足 $\\|x - \\tilde{x}\\| \\le \\|A^{-1}\\| \\, \\|r\\|$。\n- 对于应用于半离散扩散算子的后向欧拉法，矩阵 $A$ 的特征值为 $\\lambda_k(A) = 1 - \\Delta t \\lambda_k(L_h)$，其中 $\\lambda_k(L_h) = -\\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right)$，对于 $k = 1,\\dots,N$。\n\n基于这些原理，推断由非精确求解引起的每步代数误差的累积效应，并为每步的相对残差 $\\varepsilon$ 推导出一个容差选择规则，以使在时间 $T$ 的总代数误差不超过时间离散误差。\n\n您的程序必须：\n1. 对半离散系统实现后向欧拉时间步进，使用 Thomas 算法进行精确三对角求解，以在时间 $T$ 生成一个参考解。\n2. 在每个时间步实现一个非精确求解，使用一种迭代方法，当相对残差低于预设容差 $\\varepsilon$ 时终止。您可以使用共轭梯度法 (Conjugate Gradient) 作为截断的并行循环规约法 (PCR) 的实用替代品，通过提前停止来实现可控的非精确性。\n3. 通过计算使用步长 $\\Delta t$ 的精确求解后向欧拉解与使用步长 $\\Delta t/2$ 的精确求解后向欧拉解之间的差值，来估计在时间 $T$ 的时间离散误差 $E_{\\text{time}}$。两种解都从相同的初始条件和相同的空间网格开始。使用 $\\mathbb{R}^N$ 中的欧几里得范数进行误差测量。\n4. 通过计算使用步长 $\\Delta t$ 的精确求解后向欧拉解与使用步长 $\\Delta t$ 和所选容差 $\\varepsilon$ 的非精确求解后向欧拉解之间的差值，来估计在时间 $T$ 的代数误差 $E_{\\text{alg}}$。\n5. 根据您的推导，实现容差选择规则 $\\varepsilon = \\theta \\Delta t^2$，其中 $\\theta$ 是利用半离散模型中的可用量来选择的，以确保 $E_{\\text{alg}} \\le E_{\\text{time}}$；$\\theta$ 的具体公式必须在您的解决方案中得到证明并在代码中实现。\n\n使用以下参数值测试套件，并报告该规则是否实现了 $E_{\\text{alg}} \\le E_{\\text{time}}$。\n- 测试案例1：$N=64$, $T=0.1$, $\\Delta t = 10^{-3}$, 容差由规则设定。\n- 测试案例2：$N=64$, $T=0.1$, $\\Delta t = 2 \\times 10^{-3}$, 容差由规则设定。\n- 测试案例3：$N=64$, $T=0.1$, $\\Delta t = 5 \\times 10^{-4}$, 容差由规则设定。\n- 测试案例4（边缘案例，用于测试违反规则时的失败情况）：$N=64$, $T=0.1$, $\\Delta t = 10^{-3}$, 容差被设置为一个与 $\\Delta t$ 成正比的较大值，使得累积代数误差预计将超过时间误差。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,result_3,result_4]$）。每个 $result_i$ 必须是一个布尔值，表示相应测试案例是否满足 $E_{\\text{alg}} \\le E_{\\text{time}}$。由于全程使用归一化单位，输出中不需要物理单位。", "solution": "该问题是有效的，因为它提出了一个在偏微分方程数值分析领域中适定且具有科学依据的任务。所有提供的信息都是一致、完整且符合既定理论的。我们现在将推导所需的容差选择规则，然后实施数值实验。\n\n### 容差选择规则的推导\n\n目标是为每步的相对残差容差 $\\varepsilon$ 推导一个形式为 $\\varepsilon = \\theta \\Delta t^2$ 的规则，使得在最终时间 $T$ 的总累积代数误差 $E_{alg}$ 与全局时间离散误差 $E_{time}$ 处于同一数量级或更小。\n\n令 $u^n$ 为在时间 $t_n = n \\Delta t$ 的数值精确解向量，通过精确求解后向欧拉系统 $A u^{n+1} = u^n$ 获得。令 $\\tilde{u}^n$ 为线性系统被非精确求解时获得的解向量。我们从相同的初始条件开始，因此 $\\tilde{u}^0 = u^0$。\n\n**1. 累积代数误差 ($E_{alg}$) 的界定**\n\n在每个时间步 $n+1$，我们从系统 $A x = \\tilde{u}^n$ 求解 $\\tilde{u}^{n+1}$。非精确求解器产生一个解 $\\tilde{u}^{n+1}$，其残差 $r^{n+1} = \\tilde{u}^n - A \\tilde{u}^{n+1}$ 满足相对容差条件 $\\|r^{n+1}\\| / \\|\\tilde{u}^n\\| \\le \\varepsilon$。所有范数均为欧几里得 $L_2$-范数。这意味着 $\\|r^{n+1}\\| \\le \\varepsilon \\|\\tilde{u}^n\\|$。\n\n在此步骤引入的局部代数误差 $\\delta^{n+1}$ 是该系统精确解与非精确解之间的差值：$\\delta^{n+1} = A^{-1}\\tilde{u}^n - \\tilde{u}^{n+1}$。使用问题陈述中提供的误差界，我们有：\n$$\n\\|\\delta^{n+1}\\| \\le \\|A^{-1}\\| \\|r^{n+1}\\| \\le \\|A^{-1}\\| \\varepsilon \\|\\tilde{u}^n\\|\n$$\n对于扩散方程的后向欧拉离散化，矩阵 $A = I - \\Delta t L_h$ 是对称正定的，其所有特征值都大于或等于1。因此，其逆矩阵 $A^{-1}$ 也是对称正定且特征值小于或等于1，这意味着 $\\|A^{-1}\\| \\le 1$。此外，扩散过程是耗散的，意味着解的范数不会随时间增长：$\\|\\tilde{u}^n\\| \\le \\|\\tilde{u}^{n-1}\\| \\le \\dots \\le \\|\\tilde{u}^0\\| = \\|u^0\\|$。这简化了局部代数误差的界：\n$$\n\\|\\delta^{n+1}\\| \\le \\varepsilon \\|u^0\\|\n$$\n在步骤 $n+1$ 的全局代数误差 $e_{alg}^{n+1} = u^{n+1} - \\tilde{u}^{n+1}$，是由前一步的全局误差和新的局部误差累积而成的：\n$$\ne_{alg}^{n+1} = (A^{-1} u^n) - (A^{-1}\\tilde{u}^n - \\delta^{n+1}) = A^{-1}(u^n - \\tilde{u}^n) + \\delta^{n+1} = A^{-1}e_{alg}^n + \\delta^{n+1}\n$$\n取范数并使用 $\\|A^{-1}\\| \\le 1$：$\\|e_{alg}^{n+1}\\| \\le \\|e_{alg}^n\\| + \\|\\delta^{n+1}\\|$。从 $e_{alg}^0 = 0$ 开始进行归纳，最终时间 $T = N_T \\Delta t$ 的总代数误差受局部误差量值之和的限制：\n$$\nE_{alg} = \\|e_{alg}^{N_T}\\| \\le \\sum_{n=1}^{N_T} \\|\\delta^n\\| \\le \\sum_{n=1}^{N_T} \\varepsilon \\|u^0\\| = N_T \\varepsilon \\|u^0\\| = \\frac{T}{\\Delta t} \\varepsilon \\|u^0\\|\n$$\n因此，累积的代数误差尺度关系为 $E_{alg} \\propto \\varepsilon / \\Delta t$。\n\n**2. 时间离散误差 ($E_{time}$) 的界定**\n\n后向欧拉法在时间上是一阶精确的。对于半离散系统 $du/dt = L_h u$，在步骤 $n+1$ 的局部截断误差 (LTE) 由下式给出：\n$$\n\\tau^{n+1} \\approx \\frac{\\Delta t^2}{2} u_{tt}(t_{n+1})\n$$\n其中 $u_{tt} = \\frac{d^2u}{dt^2}$。由于 $u_t = L_h u$，我们有 $u_{tt} = L_h u_t = L_h(L_h u) = L_h^2 u$。因此，LTE 为：\n$$\n\\|\\tau^{n+1}\\| \\approx \\frac{\\Delta t^2}{2} \\|L_h^2 u(t_{n+1})\\|\n$$\n全局时间离散误差 $E_{time}$ 在主阶上是这些局部误差的累积。一个启发式的论证表明，全局误差受步数乘以最大 LTE 的限制：\n$$\nE_{time} \\approx N_T \\times \\max_n \\|\\tau^n\\| = \\frac{T}{\\Delta t} \\left( \\frac{\\Delta t^2}{2} \\max_n \\|L_h^2 u(t_n)\\| \\right) = \\frac{T \\Delta t}{2} \\max_n \\|L_h^2 u(t_n)\\|\n$$\n\n**3. 平衡误差与推导规则**\n\n为确保代数误差不污染时间精度，我们需要 $E_{alg} \\lesssim E_{time}$：\n$$\n\\frac{T}{\\Delta t} \\varepsilon \\|u^0\\| \\lesssim \\frac{T \\Delta t}{2} \\max_n \\|L_h^2 u(t_n)\\|\n$$\n求解 $\\varepsilon$：\n$$\n\\varepsilon \\lesssim \\frac{\\Delta t^2}{2} \\frac{\\max_n \\|L_h^2 u(t_n)\\|}{\\|u^0\\|}\n$$\n问题指定了初始条件 $u(x,0) = \\sin(\\pi x)$。这是连续算子 $-\\partial^2/\\partial x^2$ 的第一特征函数，特征值为 $\\pi^2$。离散初始条件是离散拉普拉斯算子 $-L_h$ 的第一特征向量的紧密近似，其对应特征值为 $\\lambda_1(-L_h) = - \\lambda_1(L_h) = \\frac{4}{h^2}\\sin^2\\left(\\frac{\\pi}{2(N+1)}\\right) \\approx \\pi^2$。\n半离散系统的解为 $u(t) \\approx e^{\\lambda_1(L_h)t} u^0$。因此，$L_h^2 u(t) \\approx (\\lambda_1(L_h))^2 u(t)$。由于解呈指数衰减，范数 $\\|L_h^2 u(t_n)\\|$ 将在 $t=0$ 时达到最大值。\n$$\n\\max_n \\|L_h^2 u(t_n)\\| \\approx \\|L_h^2 u(0)\\| \\approx \\|(\\lambda_1(L_h))^2 u^0\\| = (\\lambda_1(L_h))^2 \\|u^0\\|\n$$\n将此代入 $\\varepsilon$ 的不等式中：\n$$\n\\varepsilon \\lesssim \\frac{\\Delta t^2}{2} \\frac{(\\lambda_1(L_h))^2 \\|u^0\\|}{\\|u^0\\|} = \\frac{(\\lambda_1(L_h))^2}{2} \\Delta t^2\n$$\n这就得到了所需的形式 $\\varepsilon = \\theta \\Delta t^2$。我们选择 $\\theta = \\frac{(\\lambda_1(L_h))^2}{2}$，这是一个可以直接从空间离散化中计算出的参数。\n$L_h$ 的最小（绝对值）特征值的具体公式为 $\\lambda_1(L_h) = -\\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right)$，其中 $k=1$。我们将在实现中使用这个公式来设置容差。\n$$\n\\theta = \\frac{1}{2} \\left[ -\\frac{4}{h^2}\\sin^2\\left(\\frac{\\pi}{2(N+1)}\\right) \\right]^2 = \\frac{8}{h^4} \\sin^4\\left(\\frac{\\pi}{2(N+1)}\\right)\n$$\n\n### 实现策略\n\n程序将按以下结构组织：\n1.  **`thomas_algorithm`**：Thomas 算法的实现，用于求解三对角系统，用于“精确”求解。\n2.  **`conjugate_gradient`**：共轭梯度算法的实现，用于求解对称正定 (SPD) 系统，用于“非精确”求解。当相对残差低于容差 $\\varepsilon$ 时终止。\n3.  **`solve_diffusion`**：一个主驱动函数，使用 Thomas 或 CG 求解器执行时间步进。它将网格和时间参数、求解器类型和容差作为输入，并返回最终时间 $T$ 的解。\n4.  **`solve`**：协调四个测试案例的主函数。对于每个案例，它将：\n    a. 计算基于规则的系数 $\\theta$。\n    b. 使用精确求解器计算参考解 $u_{\\Delta t}$。\n    c. 使用精确求解器和减半的时间步长计算更精确的参考解 $u_{\\Delta t/2}$。\n    d. 估计时间误差 $E_{time} = \\|u_{\\Delta t} - u_{\\Delta t/2}\\|$。\n    e. 根据推导的规则（或在案例4中使用错误的规则）设置容差 $\\varepsilon$。\n    f. 计算容差为 $\\varepsilon$ 的非精确解 $\\tilde{u}_{\\Delta t}$。\n    g. 计算代数误差 $E_{alg} = \\|u_{\\Delta t} - \\tilde{u}_{\\Delta t}\\|$。\n    h. 记录 $E_{alg} \\le E_{time}$ 是否成立。\n最终输出将是这些布尔结果的列表。", "answer": "```python\nimport numpy as np\n\ndef thomas_algorithm(l, m, u, d):\n    \"\"\"\n    Solves a tridiagonal system of equations Ax=d.\n    l: lower diagonal (length n-1)\n    m: main diagonal (length n)\n    u: upper diagonal (length n-1)\n    d: right-hand side vector (length n)\n    \"\"\"\n    n = len(d)\n    m_copy = np.copy(m) # Avoid modifying the original array\n    d_copy = np.copy(d) # Avoid modifying the original array\n    \n    # Forward elimination\n    for i in range(1, n):\n        factor = l[i-1] / m_copy[i-1]\n        m_copy[i] = m_copy[i] - factor * u[i-1]\n        d_copy[i] = d_copy[i] - factor * d_copy[i-1]\n\n    # Backward substitution\n    x = np.zeros(n)\n    x[n-1] = d_copy[n-1] / m_copy[n-1]\n    for i in range(n - 2, -1, -1):\n        x[i] = (d_copy[i] - u[i] * x[i+1]) / m_copy[i]\n        \n    return x\n\ndef conjugate_gradient(A, b, tolerance, initial_guess):\n    \"\"\"\n    Solves Ax=b for SPD matrix A using the Conjugate Gradient method.\n    Termination is based on relative residual norm.\n    \"\"\"\n    x = initial_guess\n    r = b - A @ x\n    p = r.copy()\n    rs_old = np.dot(r, r)\n    norm_b = np.linalg.norm(b)\n\n    if norm_b == 0:\n        return np.zeros_like(b)\n\n    # Set a reasonable maximum number of iterations\n    max_iter = len(b) * 2\n    for _ in range(max_iter):\n        Ap = A @ p\n        alpha = rs_old / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rs_new = np.dot(r, r)\n        \n        current_rel_residual = np.sqrt(rs_new) / norm_b\n        if current_rel_residual  tolerance:\n            break\n            \n        p = r + (rs_new / rs_old) * p\n        rs_old = rs_new\n        \n    return x\n\ndef solve_diffusion(N, T, dt, solver_type, tolerance=None):\n    \"\"\"\n    Solves the 1D diffusion equation using backward Euler.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    x_grid = np.linspace(h, 1.0 - h, N)\n    u = np.sin(np.pi * x_grid)\n\n    diag_val = 1.0 + 2.0 * dt / h**2\n    offdiag_val = -dt / h**2\n    \n    main_diag = np.full(N, diag_val)\n    off_diag = np.full(N - 1, offdiag_val)\n\n    num_steps = int(round(T / dt))\n\n    if solver_type == 'exact':\n        for _ in range(num_steps):\n            u = thomas_algorithm(off_diag, main_diag, off_diag, u)\n    elif solver_type == 'inexact':\n        # Build dense matrix for CG\n        A = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n        for _ in range(num_steps):\n            # Use previous solution as a warm start for the CG solver\n            u = conjugate_gradient(A, u, tolerance, initial_guess=u.copy())\n            \n    return u\n\ndef solve():\n    test_cases = [\n        # N, T, dt, is_edge_case\n        (64, 0.1, 1e-3, False),\n        (64, 0.1, 2e-3, False),\n        (64, 0.1, 5e-4, False),\n        (64, 0.1, 1e-3, True), # Edge case to test failure\n    ]\n\n    results = []\n    \n    for N, T, dt, is_edge_case in test_cases:\n        # Calculate theta for the tolerance rule\n        h = 1.0 / (N + 1)\n        lambda_1_Lh = -4.0 / h**2 * np.sin(np.pi / (2.0 * (N + 1)))**2\n        theta = (lambda_1_Lh**2) / 2.0\n        \n        # 1. Compute reference solution with step dt\n        u_ref_dt = solve_diffusion(N, T, dt, 'exact')\n        \n        # 2. Compute reference solution with step dt/2 for error estimation\n        u_ref_dt_half = solve_diffusion(N, T, dt / 2.0, 'exact')\n        \n        # 3. Estimate time discretization error\n        E_time = np.linalg.norm(u_ref_dt - u_ref_dt_half)\n        \n        # 4. Set tolerance and compute inexact solution\n        if is_edge_case:\n            # Set a tolerance proportional to dt, which violates the rule\n            # and is expected to lead to larger algebraic error.\n            # 0.1 is an arbitrary constant chosen to make the tolerance large enough.\n            tolerance = 0.1 * dt\n        else:\n            # Use the derived rule\n            tolerance = theta * dt**2\n            \n        u_inexact = solve_diffusion(N, T, dt, 'inexact', tolerance=tolerance)\n        \n        # 5. Estimate algebraic error\n        E_alg = np.linalg.norm(u_ref_dt - u_inexact)\n        \n        # 6. Check if algebraic error is controlled\n        results.append(E_alg = E_time)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3458596"}]}