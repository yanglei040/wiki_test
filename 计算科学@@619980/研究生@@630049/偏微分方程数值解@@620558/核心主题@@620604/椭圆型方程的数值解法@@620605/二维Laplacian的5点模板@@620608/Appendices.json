{"hands_on_practices": [{"introduction": "理解如何在离散网格上近似连续的微分算子，是有限差分法的基石。第一个练习将引导你使用泰勒级数展开，从头开始推导五点拉普拉斯模板 [@problem_id:3310233]。掌握这一基本推导过程，对于理解连续偏微分方程与其离散形式之间的联系，以及领会该方法精度的来源至关重要。", "problem": "考虑二维空间中的稳态扩散模型，该模型由拉普拉斯算子控制，在许多计算流体力学 (CFD) 应用中作为一种典型的偏微分方程 (PDE) 出现。令 $\\Omega = (0,1)\\times(0,1)$，并设 $\\{(x_i,y_j)\\}$ 为一个均匀的笛卡尔网格，在两个方向上的间距均为 $h$，因此对于整数 $i$ 和 $j$，有 $x_i = i h$ 和 $y_j = j h$。用 $u_{i,j} = u(x_i,y_j)$ 表示网格函数值。从拉普拉斯算子的坐标定义 $\\nabla^{2} u = \\frac{\\partial^{2} u}{\\partial x^{2}} + \\frac{\\partial^{2} u}{\\partial y^{2}}$ 出发，并围绕内部节点 $(x_i,y_j)$ 使用多元泰勒级数展开，构建此网格上二维拉普拉斯算子的二阶精度五点有限差分格式。然后，使用此近似，推导与泊松形式 $-\\,\\nabla^{2} u = f$（其中 $f$ 是光滑函数）相关的离散内部节点方程。\n\n您的推导必须仅从拉普拉斯算子的定义和 Taylor 定理开始，并且不得使用任何预先引用的有限差分公式。作为最终答案，请提供此均匀网格上内部节点 $(i,j)$ 处的离散拉普拉斯算子 $\\Delta_h u_{i,j}$ 的显式表达式，该表达式仅用 $u_{i,j}$、其四个面相邻节点以及网格间距 $h$ 表示。最终答案必须是一个无单位的单一闭式解析表达式。", "solution": "该问题要求在均匀笛卡尔网格上，为二维拉普拉斯算子 $\\nabla^{2} u$ 推导二阶精度的五点有限差分格式。推导必须从第一性原理出发，使用 Taylor 级数展开。随后，将使用此格式来编写泊松方程 $-\\nabla^{2} u = f$ 的离散形式。\n\n二维拉普拉斯算子在笛卡尔坐标中的定义为：\n$$\n\\nabla^{2} u = \\frac{\\partial^{2} u}{\\partial x^{2}} + \\frac{\\partial^{2} u}{\\partial y^{2}}\n$$\n我们将分别在内部网格节点 $(x_i, y_j)$ 处，为每个二阶偏导数推导有限差分近似。网格在两个方向上都是均匀的，间距为 $h$，因此 $x_{i\\pm1} = x_i \\pm h$ 且 $y_{j\\pm1} = y_j \\pm h$。我们使用记号 $u_{i,j} = u(x_i, y_j)$。\n\n首先，考虑关于 $x$ 的偏导数 $\\frac{\\partial^{2} u}{\\partial x^{2}}$。我们在点 $(x_i, y_j)$ 处对 $u(x_i+h, y_j)$ 和 $u(x_i-h, y_j)$ 使用 Taylor 级数展开。假设函数 $u(x,y)$ 足够光滑，展开式为：\n$$\nu(x_i+h, y_j) = u_{i+1,j} = u_{i,j} + h \\left(\\frac{\\partial u}{\\partial x}\\right)_{i,j} + \\frac{h^2}{2!} \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} + \\frac{h^3}{3!} \\left(\\frac{\\partial^3 u}{\\partial x^3}\\right)_{i,j} + \\frac{h^4}{4!} \\left(\\frac{\\partial^4 u}{\\partial x^4}\\right)_{i,j} + O(h^5)\n$$\n$$\nu(x_i-h, y_j) = u_{i-1,j} = u_{i,j} - h \\left(\\frac{\\partial u}{\\partial x}\\right)_{i,j} + \\frac{h^2}{2!} \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} - \\frac{h^3}{3!} \\left(\\frac{\\partial^3 u}{\\partial x^3}\\right)_{i,j} + \\frac{h^4}{4!} \\left(\\frac{\\partial^4 u}{\\partial x^4}\\right)_{i,j} + O(h^5)\n$$\n将这两个方程相加可以消去奇数阶导数项：\n$$\nu_{i+1,j} + u_{i-1,j} = 2u_{i,j} + h^2 \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} + \\frac{2h^4}{24} \\left(\\frac{\\partial^4 u}{\\partial x^4}\\right)_{i,j} + O(h^6)\n$$\n重新整理此表达式以求解二阶偏导数，得到：\n$$\n\\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} - \\frac{h^2}{12} \\left(\\frac{\\partial^4 u}{\\partial x^4}\\right)_{i,j} + O(h^4)\n$$\n这为 $\\frac{\\partial^{2} u}{\\partial x^{2}}$ 提供了一个有限差分近似。截断误差的首项与 $h^2$ 成正比，因此这是一个二阶精度的中心差分格式。\n\n通过对 $y$ 方向进行类似的操作，我们考虑 $u(x_i, y_j+h)$ 和 $u(x_i, y_j-h)$ 的 Taylor 展开式：\n$$\nu(x_i, y_j+h) = u_{i,j+1} = u_{i,j} + h \\left(\\frac{\\partial u}{\\partial y}\\right)_{i,j} + \\frac{h^2}{2!} \\left(\\frac{\\partial^2 u}{\\partial y^2}\\right)_{i,j} + \\frac{h^3}{3!} \\left(\\frac{\\partial^3 u}{\\partial y^3}\\right)_{i,j} + O(h^4)\n$$\n$$\nu(x_i, y_j-h) = u_{i,j-1} = u_{i,j} - h \\left(\\frac{\\partial u}{\\partial y}\\right)_{i,j} + \\frac{h^2}{2!} \\left(\\frac{\\partial^2 u}{\\partial y^2}\\right)_{i,j} - \\frac{h^3}{3!} \\left(\\frac{\\partial^3 u}{\\partial y^3}\\right)_{i,j} + O(h^4)\n$$\n将这两个展开式相加并重新整理，得到 $\\frac{\\partial^{2} u}{\\partial y^{2}}$ 的近似：\n$$\n\\left(\\frac{\\partial^2 u}{\\partial y^2}\\right)_{i,j} = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} - \\frac{h^2}{12} \\left(\\frac{\\partial^4 u}{\\partial y^4}\\right)_{i,j} + O(h^4)\n$$\n这也是一个二阶精度的中心差分近似。\n\n现在我们可以通过将两个二阶偏导数的近似相加，来构建拉普拉斯算子的近似：\n$$\n(\\nabla^2 u)_{i,j} = \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} + \\left(\\frac{\\partial^2 u}{\\partial y^2}\\right)_{i,j}\n$$\n代入推导出的表达式：\n$$\n(\\nabla^2 u)_{i,j} = \\left[ \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} \\right] + \\left[ \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} \\right] + T_{i,j}\n$$\n其中 $T_{i,j}$ 是局部截断误差，由下式给出：\n$$\nT_{i,j} = - \\frac{h^2}{12} \\left[ \\left(\\frac{\\partial^4 u}{\\partial x^4}\\right)_{i,j} + \\left(\\frac{\\partial^4 u}{\\partial y^4}\\right)_{i,j} \\right] + O(h^4)\n$$\n由于误差首项与 $h^2$ 成正比，因此得到的格式是二阶精度的。\n\n通过舍去截断误差项，我们得到作用于网格函数 $u_{i,j}$ 的离散拉普拉斯算子，记为 $\\Delta_h$：\n$$\n(\\nabla^2 u)_{i,j} \\approx \\Delta_h u_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2}\n$$\n该表达式是拉普拉斯算子的五点有限差分格式，因为它涉及中心节点 $(i,j)$ 及其四个面相邻节点：$(i+1,j)$、$(i-1,j)$、$(i,j+1)$ 和 $(i,j-1)$。\n\n最后，为了推导泊松形式 $-\\nabla^{2} u = f$ 的离散内部节点方程，我们将节点 $(x_i, y_j)$ 处的连续算子和函数替换为其离散对应项：\n$$\n- (\\nabla^2 u)_{i,j} = f(x_i, y_j)\n$$\n代入离散拉普拉斯算子 $\\Delta_h u_{i,j}$ 并设 $f_{i,j}=f(x_i,y_j)$，得到离散方程：\n$$\n- \\left( \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} \\right) = f_{i,j}\n$$\n这就是内部节点的离散方程。要求提供的最终答案是离散拉普拉斯算子 $\\Delta_h u_{i,j}$ 本身的表达式。", "answer": "$$\n\\boxed{\\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2}}\n$$", "id": "3310233"}, {"introduction": "在理论上推导出算子模板之后，科学计算中的一个关键步骤是通过数值实验来验证其性质。本练习要求你编写程序来测量局部截断误差——即当我们将离散算子应用于精确的连续解时所产生的误差 [@problem_id:2406729]。通过分析该误差如何随网格间距 $h$ 变化，你将以数值方式验证该模板的二阶精度 $O(h^2)$，这是代码验证与确认中的一项基本技能。", "problem": "编写一个完整、可运行的程序，对于二维空间中的光滑函数，分析标准的$5$点差分格式近似二维拉普拉斯算子的局部截断误差与网格间距$h$的关系，并验证其阶数为$O(h^2)$。请使用以下精确的数学定义。\n\n对于一个光滑函数 $u:\\mathbb{R}^2 \\to \\mathbb{R}$ 和网格间距 $h>0$，其在点 $(x,y)$ 处对拉普拉斯算子的离散$5$点差分格式近似定义为\n$$\n\\Delta_h u(x,y) \\;=\\; \\frac{u(x+h,y)+u(x-h,y)+u(x,y+h)+u(x,y-h)-4\\,u(x,y)}{h^2}.\n$$\n在点 $(x_0,y_0)$ 处的局部截断误差 $\\tau_h$ 定义为\n$$\n\\tau_h(x_0,y_0) \\;=\\; \\Delta_h u(x_0,y_0)\\;-\\;\\Delta u(x_0,y_0),\n$$\n其中 $\\Delta u \\equiv u_{xx}+u_{yy}$ 是连续拉普拉斯算子。三角函数中出现的所有角度都必须以弧度为单位。\n\n您的程序必须根据上述定义数值计算 $\\tau_h$，并仅基于在指定 $h$ 值下的这些计算结果，以如下测试套件中指定的实数形式，给出 $\\tau_h=O(h^2)$ 标度关系的量化证据。\n\n需要精确实现的测试套件：\n- 情况1（一般光滑三角函数）：$u_1(x,y)=\\sin(x)\\cos(y)$，点 $(x_0,y_0)=(0.3,-0.2)$，间距 $h_k=2^{-k}$，其中 $k\\in\\{1,2,3,4,5,6\\}$。输出一个实数 $p_1$，表示从数据 $\\{(h_k,\\lvert \\tau_{h_k}(x_0,y_0)\\rvert)\\}$ 中推断出的关于 $h$ 的观测收敛阶。\n- 情况2（一般光滑指数函数）：$u_2(x,y)=\\exp(x+2y)$，点 $(x_0,y_0)=(-0.7,0.4)$，间距 $h_k=2^{-k}$，其中 $k\\in\\{1,2,3,4,5,6\\}$。输出一个实数 $p_2$，表示从数据 $\\{(h_k,\\lvert \\tau_{h_k}(x_0,y_0)\\rvert)\\}$ 中推断出的关于 $h$ 的观测收敛阶。\n- 情况3（使用四次多项式的边界情况）：$u_3(x,y)=x^4+y^4$，点 $(x_0,y_0)=(0.5,-0.5)$，间距 $h=2^{-3}$。输出一个实数 $c_3$，其值等于比率 $\\lvert \\tau_h(x_0,y_0)\\rvert/h^2$。\n\n您的程序最终必须输出单行，其中包含一个带有三个实数 $[p_1,p_2,c_3]$ 的Python列表字面量，其中 $p_1$ 和 $p_2$ 量化观测到的精度阶数，$c_3$ 量化情况3中的首项系数。所有三个实数都必须四舍五入到小数点后三位。答案不涉及物理单位，所有角度都必须以弧度为单位。最终行的格式必须是 $[p_1,p_2,c_3]$ 的单行形式，用逗号分隔，且不含任何附加文本。", "solution": "问题陈述已经过验证，被认定为有效。它具有科学依据、问题适定且客观。它提出了一个偏微分方程数值分析中的标准问题，并提供了所有必要的数据和定义。任务是分析二维拉普拉斯算子的5点有限差分格式的局部截断误差，这是计算物理学中的一个基本概念。\n\n分析始于将一个足够光滑的函数 $u(x,y)$ 在点 $(x,y)$ 附近进行泰勒级数展开。在 $x$ 方向的展开式为：\n$$\nu(x+h, y) = u + h u_x + \\frac{h^2}{2!} u_{xx} + \\frac{h^3}{3!} u_{xxx} + \\frac{h^4}{4!} u_{xxxx} + O(h^5)\n$$\n$$\nu(x-h, y) = u - h u_x + \\frac{h^2}{2!} u_{xx} - \\frac{h^3}{3!} u_{xxx} + \\frac{h^4}{4!} u_{xxxx} - O(h^5)\n$$\n其中所有偏导数均在点 $(x,y)$ 处取值。将这两个表达式相加可以消去奇数阶导数项：\n$$\nu(x+h,y) + u(x-h,y) = 2u + h^2 u_{xx} + \\frac{h^4}{12} u_{xxxx} + O(h^6)\n$$\n对于 $y$ 方向的展开，也存在类似的表达式：\n$$\nu(x,y+h) + u(x,y-h) = 2u + h^2 u_{yy} + \\frac{h^4}{12} u_{yyyy} + O(h^6)\n$$\n离散拉普拉斯算子 $\\Delta_h u(x,y)$ 定义为：\n$$\n\\Delta_h u(x,y) = \\frac{u(x+h,y)+u(x-h,y)+u(x,y+h)+u(x,y-h)-4u(x,y)}{h^2}\n$$\n将泰勒级数和代入此定义得到：\n$$\n\\Delta_h u(x,y) = \\frac{(2u + h^2 u_{xx} + \\frac{h^4}{12} u_{xxxx}) + (2u + h^2 u_{yy} + \\frac{h^4}{12} u_{yyyy}) - 4u + O(h^6)}{h^2}\n$$\n$$\n\\Delta_h u(x,y) = \\frac{h^2(u_{xx} + u_{yy}) + \\frac{h^4}{12}(u_{xxxx} + u_{yyyy}) + O(h^6)}{h^2}\n$$\n$$\n\\Delta_h u(x,y) = (u_{xx} + u_{yy}) + \\frac{h^2}{12}(u_{xxxx} + u_{yyyy}) + O(h^4)\n$$\n连续拉普拉斯算子为 $\\Delta u = u_{xx} + u_{yy}$。局部截断误差 $\\tau_h$ 是离散算子与连续算子之差：\n$$\n\\tau_h(x,y) = \\Delta_h u(x,y) - \\Delta u(x,y) = \\frac{h^2}{12}(u_{xxxx} + u_{yyyy}) + O(h^4)\n$$\n此推导严格地证明了误差的主项与 $h^2$ 成正比，因此 $\\tau_h = O(h^2)$。对于较小的 $h$，误差的量级可以近似为 $|\\tau_h| \\approx C h^p$，其中 $p$ 是收敛阶。为了从数值数据中求出 $p$，我们取自然对数：\n$$\n\\ln(|\\tau_h|) \\approx \\ln(C) + p \\ln(h)\n$$\n这揭示了 $\\ln(|\\tau_h|)$ 和 $\\ln(h)$ 之间的线性关系，其中斜率即为收敛阶 $p$。因此，我们可以通过对数据点 $(\\ln(h_k), \\ln(|\\tau_{h_k}|))$ 进行线性最小二乘回归来计算 $p$。\n\n该问题要求对三个具体情况实现此分析。\n\n对于情况1和情况2，我们必须找出观测收敛阶 $p_1$ 和 $p_2$。对于每种情况，都定义了测试函数 $u(x,y)$ 及其解析拉普拉斯算子 $\\Delta u(x,y)$。我们为一系列网格间距 $h_k = 2^{-k}$ 计算 $\\tau_{h_k}$。然后，我们使用 `numpy.polyfit` 计算 $\\ln(|\\tau_{h_k}|)$ 相对于 $\\ln(h_k)$ 的最佳拟合直线的斜率，以确定阶数 $p$。\n- 对于 $u_1(x,y) = \\sin(x)\\cos(y)$，连续拉普拉斯算子为 $\\Delta u_1 = -\\sin(x)\\cos(y) - \\sin(x)\\cos(y) = -2\\sin(x)\\cos(y)$。\n- 对于 $u_2(x,y) = \\exp(x+2y)$，连续拉普拉斯算子为 $\\Delta u_2 = \\exp(x+2y) + 4\\exp(x+2y) = 5\\exp(x+2y)$。\n\n对于情况3，函数是一个四次多项式 $u_3(x,y)=x^4+y^4$。对于此类函数，所有高于四阶的偏导数都恒等于零。泰勒级数展开变为精确式，$\\tau_h$ 表达式中的 $O(h^4)$ 项消失。\n其四阶导数为 $u_{xxxx} = 24$ 和 $u_{yyyy} = 24$。因此，截断误差由主项精确给出：\n$$\n\\tau_h(x,y) = \\frac{h^2}{12}(u_{xxxx} + u_{yyyy}) = \\frac{h^2}{12}(24 + 24) = 4h^2\n$$\n此结果与点 $(x,y)$ 无关。问题要求计算特定 $h$ 下的比率 $c_3 = |\\tau_h(x_0,y_0)|/h^2$。根据解析推导，该比率必须精确为 $4$。程序将通过数值计算该值来验证理论结果。数值计算 $\\tau_h$ 所需的连续拉普拉斯算子为 $\\Delta u_3 = 12x^2 + 12y^2$。\n\n最终程序将实现这些计算，将所得数值 $p_1, p_2, c_3$ 四舍五入到小数点后三位，并以指定的列表格式呈现它们。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the order of convergence and error coefficients for the 5-point\n    stencil approximation of the 2D Laplacian.\n    \"\"\"\n\n    # === Case 1: u(x,y) = sin(x)cos(y) ===\n    def u1(x, y):\n        return np.sin(x) * np.cos(y)\n\n    def delta_u1(x, y):\n        # u_xx = -sin(x)cos(y), u_yy = -sin(x)cos(y)\n        return -2.0 * np.sin(x) * np.cos(y)\n\n    # === Case 2: u(x,y) = exp(x+2y) ===\n    def u2(x, y):\n        return np.exp(x + 2.0 * y)\n    \n    def delta_u2(x, y):\n        # u_xx = exp(x+2y), u_yy = 4*exp(x+2y)\n        return 5.0 * np.exp(x + 2.0 * y)\n\n    # === Case 3: u(x,y) = x^4 + y^4 ===\n    def u3(x, y):\n        return x**4 + y**4\n\n    def delta_u3(x, y):\n        # u_xx = 12x^2, u_yy = 12y^2\n        return 12.0 * (x**2 + y**2)\n\n    def discrete_laplacian(u_func, x, y, h):\n        \"\"\"Computes the 5-point stencil discrete Laplacian.\"\"\"\n        u_iph = u_func(x + h, y)\n        u_imh = u_func(x - h, y)\n        u_jph = u_func(x, y + h)\n        u_jmh = u_func(x, y - h)\n        u_ij = u_func(x, y)\n        return (u_iph + u_imh + u_jph + u_jmh - 4.0 * u_ij) / h**2\n\n    def get_convergence_order(u_func, delta_u_func, x0, y0, h_values):\n        \"\"\"\n        Calculates the convergence order by performing a linear fit on\n        the log-log plot of truncation error vs. grid spacing.\n        \"\"\"\n        errors = []\n        for h in h_values:\n            delta_h_u = discrete_laplacian(u_func, x0, y0, h)\n            analytic_delta_u = delta_u_func(x0, y0)\n            tau_h = delta_h_u - analytic_delta_u\n            errors.append(np.abs(tau_h))\n        \n        log_h = np.log(h_values)\n        log_error = np.log(errors)\n        \n        # Fit a line: log_error = p * log_h + C\n        # The slope p is the order of convergence.\n        p, _ = np.polyfit(log_h, log_error, 1)\n        return p\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"id\": 1,\n            \"u_func\": u1,\n            \"delta_u_func\": delta_u1,\n            \"point\": (0.3, -0.2),\n            \"h_k_range\": range(1, 7)\n        },\n        {\n            \"id\": 2,\n            \"u_func\": u2,\n            \"delta_u_func\": delta_u2,\n            \"point\": (-0.7, 0.4),\n            \"h_k_range\": range(1, 7)\n        },\n        {\n            \"id\": 3,\n            \"u_func\": u3,\n            \"delta_u_func\": delta_u3,\n            \"point\": (0.5, -0.5),\n            \"h\": 2.0**(-3)\n        },\n    ]\n\n    results = []\n    \n    # Process Case 1\n    case1 = test_cases[0]\n    x0_1, y0_1 = case1[\"point\"]\n    h_values_1 = [2.0**(-k) for k in case1[\"h_k_range\"]]\n    p1 = get_convergence_order(case1[\"u_func\"], case1[\"delta_u_func\"], x0_1, y0_1, h_values_1)\n    \n    # Process Case 2\n    case2 = test_cases[1]\n    x0_2, y0_2 = case2[\"point\"]\n    h_values_2 = [2.0**(-k) for k in case2[\"h_k_range\"]]\n    p2 = get_convergence_order(case2[\"u_func\"], case2[\"delta_u_func\"], x0_2, y0_2, h_values_2)\n\n    # Process Case 3\n    case3 = test_cases[2]\n    x0_3, y0_3 = case3[\"point\"]\n    h_3 = case3[\"h\"]\n    delta_h_u3 = discrete_laplacian(case3[\"u_func\"], x0_3, y0_3, h_3)\n    analytic_delta_u3 = case3[\"delta_u_func\"](x0_3, y0_3)\n    tau_h3 = delta_h_u3 - analytic_delta_u3\n    c3 = np.abs(tau_h3) / h_3**2\n    \n    # Final print statement in the exact required format.\n    print(f\"[{p1:.3f},{p2:.3f},{c3:.3f}]\")\n\nsolve()\n```", "id": "2406729"}, {"introduction": "在推导并局部验证了算子模板之后，我们现在将其应用于其最终目的：求解一个完整的边值问题。这个综合性练习涉及使用五点模板来离散化泊松方程，组装并求解由此产生的线性系统，并执行网格加密研究 [@problem_id:3453785]。通过将你的数值解与一个已知的“人造”解进行比较，你将评估*全局*误差，并确认该方法的整体收敛阶与理论局部精度相符。", "problem": "设计并实现一个在单位正方形上的标量泊松问题的加密研究，以验证基于二维拉普拉斯算子五点模板的有限差分格式的二阶收敛性。问题域为 $\\Omega = (0,1)\\times(0,1)$。考虑在 $\\Omega$ 上的边值问题 $- \\Delta u = f$，其狄利克雷边界条件为 $u|_{\\partial \\Omega} = g$，其中 $g$ 由一个光滑的构造精确解 $u$ 一致地选取。您的任务是：构建并求解由均匀网格上的二阶中心差分产生的离散线性系统，为一系列网格间距 $h$ 计算离散 $L^2$ 误差，并估计观测收敛率。\n\n从以下基本依据出发：\n- 拉普拉斯算子的定义 $\\Delta u = \\partial^2 u/\\partial x^2 + \\partial^2 u/\\partial y^2$。\n- 通过围绕网格点的泰勒展开构造的一维二阶导数的二阶中心差分近似。\n- 在间距为 $h$ 的均匀网格上的离散 $L^2$ 范数，对于在内部网格点上采样的误差场 $e_{i,j}$，其定义为 $\\|e_h\\|_{L^2_h} = \\left(h^2 \\sum_{i,j} |e_{i,j}|^2\\right)^{1/2}$。\n\n在推导离散算子时，您不得使用任何预先给定的模板公式；必须从泰勒展开开始，逐维组合一维近似来推导五点模板。\n\n为每个加密级别构建一个均匀的笛卡尔网格，每个方向有 $n$ 个内部点，间距为 $h = 1/(n+1)$。组装与 $- \\Delta$ 的离散算子相对应的线性系统，并通过将边界值合并到右端项中来施加狄利克雷边界条件。使用任意鲁棒的直接线性求解器求解该线性系统以得到内部未知数。\n\n将网格间距为 $h$ 时的离散 $L^2$ 误差定义为\n$$\nE(h) = \\left(h^2 \\sum_{i=1}^{n}\\sum_{j=1}^{n}\\left(u_h(x_i,y_j) - u(x_i,y_j)\\right)^2\\right)^{1/2},\n$$\n其中 $x_i = i h$，$y_j = j h$，$u_h$ 是定义在内部节点上的数值解。对于连续的网格间距 $h$ 和 $h/2$，将观测阶定义为\n$$\np(h \\to h/2) = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)}.\n$$\n\n为下面测试套件中列出的每个构造精确解 $u$ 实现一个加密研究，使用内部网格尺寸序列 $\\{n\\} = \\{7, 15, 31, 63\\}$，这对应于间距 $h \\in \\{1/8, 1/16, 1/32, 1/64\\}$。对于每个 $u$，计算三个加密步骤的误差序列 $\\{E(h)\\}$ 和观测阶序列 $\\{p(h \\to h/2)\\}$。对于每个 $u$，报告基于两个最密层级（即在 $h=1/32$ 和 $h=1/64$ 之间）的观测阶，并报告一个布尔值，指示所有三个观测阶是否都位于容差区间 $[1.8, 2.2]$ 内。\n\n测试套件：\n- 案例 $\\mathrm{A}$（零边界数据）：$u(x,y) = \\sin(2\\pi x)\\,\\sin(3\\pi y)$，因此 $f(x,y) = -\\Delta u(x,y) = \\left((2\\pi)^2 + (3\\pi)^2\\right) \\sin(2\\pi x)\\,\\sin(3\\pi y)$ 且 $g$ 是 $u$ 在 $\\partial \\Omega$ 上的限制。\n- 案例 $\\mathrm{B}$（非零边界数据，指数形式）：$u(x,y) = e^{x+y}$，因此 $f(x,y) = -\\Delta u(x,y) = -2 e^{x+y}$ 且 $g$ 是 $u$ 在 $\\partial \\Omega$ 上的限制。\n- 案例 $\\mathrm{C}$（多项式，具有混合边界行为）：$u(x,y) = x^2 y^2$，因此 $f(x,y) = -\\Delta u(x,y) = -2(x^2 + y^2)$ 且 $g$ 是 $u$ 在 $\\partial \\Omega$ 上的限制。\n\n您的程序应：\n- 对三种情况中的每一种，在指定的网格序列上执行加密研究，计算误差序列 $\\{E(h)\\}$，计算观测阶 $\\{p(h \\to h/2)\\}$，从最后一个加密步骤中提取最密层级的观测阶 $p_\\mathrm{fine}$，并检查所有三个观测阶是否都在 $[1.8, 2.2]$ 内。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含：三个最密层级的观测阶（每种情况一个，为浮点数），后跟三个布尔值（每种情况一个），指示该情况的所有观测阶是否都在 $[1.8, 2.2]$ 内。例如，输出必须采用以下格式\n$[p_{\\mathrm{A}}, p_{\\mathrm{B}}, p_{\\mathrm{C}}, b_{\\mathrm{A}}, b_{\\mathrm{B}}, b_{\\mathrm{C}}]$，\n其中每个 $p_{\\mathrm{case}}$ 是一个浮点数，每个 $b_{\\mathrm{case}}$ 是 True 或 False。\n\n所有量均为无量纲；无需物理单位。三角函数中出现的角度以弧度为单位。程序必须完全自包含，不接受任何输入，并严格按照指定格式打印一行。", "solution": "该问题要求设计并实现一个数值验证研究，该研究针对应用于单位正方形域 $\\Omega = (0,1) \\times (0,1)$ 上、带有狄利克雷边界条件 $u|_{\\partial\\Omega} = g$ 的二维泊松方程 $-\\Delta u = f$ 的二阶有限差分格式。任务的核心是推导离散算子，构建并求解由此产生的线性系统，并执行加密研究以确认该方法的理论二阶收敛性。这通过构造解法（method of manufactured solutions）来完成。\n\n首先，我们推导拉普拉斯算子 $\\Delta = \\partial^2/\\partial x^2 + \\partial^2/\\partial y^2$ 所需的有限差分近似。这是通过使用泰勒级数展开的第一性原理完成的。对于一个足够光滑的一维函数 $u(x)$，在点 $x_i$ 处关于步长 $h$ 的展开式为：\n$$\nu(x_i + h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2} u''(x_i) + \\frac{h^3}{6} u'''(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) + O(h^5)\n$$\n$$\nu(x_i - h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2} u''(x_i) - \\frac{h^3}{6} u'''(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) - O(h^5)\n$$\n将这两个表达式相加可以消去奇数阶导数项，得到：\n$$\nu(x_i + h) + u(x_i - h) = 2u(x_i) + h^2 u''(x_i) + \\frac{h^4}{12} u^{(4)}(x_i) + O(h^6)\n$$\n通过重新整理该方程以分离出二阶导数，我们得到：\n$$\nu''(x_i) = \\frac{u(x_i - h) - 2u(x_i) + u(x_i + h)}{h^2} - \\frac{h^2}{12} u^{(4)}(x_i) + O(h^4)\n$$\n这提供了一维二阶导数的标准二阶中心差分近似，其主截断误差项为 $O(h^2)$。\n\n为了离散化二维拉普拉斯算子，我们在域上建立一个均匀的笛卡尔网格，网格点为 $(x_i, y_j) = (ih, jh)$，其中 $h=1/(n+1)$ 是两个方向上的网格间距，内部点的索引为 $i,j \\in \\{1, 2, \\dots, n\\}$。令 $u_{i,j} = u(x_i, y_j)$。我们在一个通用的内部点 $(x_i, y_j)$ 处沿每个坐标轴应用一维近似：\n$$\n\\left.\\frac{\\partial^2 u}{\\partial x^2}\\right|_{(x_i, y_j)} \\approx \\frac{u_{i-1,j} - 2u_{i,j} + u_{i+1,j}}{h^2}\n$$\n$$\n\\left.\\frac{\\partial^2 u}{\\partial y^2}\\right|_{(x_i, y_j)} \\approx \\frac{u_{i,j-1} - 2u_{i,j} + u_{i,j+1}}{h^2}\n$$\n拉普拉斯算子是这些偏导数之和。将这些近似值相加，得到著名的拉普拉斯算子五点模板：\n$$\n(\\Delta u)_{i,j} \\approx \\frac{u_{i-1,j} + u_{i+1,j} + u_{i,j-1} + u_{i,j+1} - 4u_{i,j}}{h^2}\n$$\n只要解 $u$ 具有足够高阶的连续导数，该近似的局部截断误差为 $O(h^2)$。\n\n将此离散算子代入泊松方程 $-\\Delta u = f$，我们为每个内部网格点 $(x_i, y_j)$ 获得一个线性方程：\n$$\n-\\frac{u_{i-1,j} + u_{i+1,j} + u_{i,j-1} + u_{i,j+1} - 4u_{i,j}}{h^2} \\approx f(x_i, y_j)\n$$\n乘以 $-h^2$ 并重新整理，得到离散方程：\n$$\n4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} \\approx h^2 f_{i,j}\n$$\n这组针对 $N$ 个内部未知值 $u_{i,j}$ 的 $N=n^2$ 个方程构成一个线性系统 $A \\mathbf{u}_h = \\mathbf{b}$。为了显式地构建该系统，我们将二维未知数网格 $(u_{i,j})$ 映射到一个长度为 $N$ 的一维向量 $\\mathbf{u}_h$。一个标准的选择是行主序，其中网格点 $(i,j)$ 映射到向量索引 $k = (j-1)n + (i-1)$，对于 $i,j \\in \\{1,\\dots,n\\}$。\n\n矩阵 $A$ 代表离散的负拉普拉斯算子。点 $(i,j)$ 处的方程（矩阵的第 $k$ 行）涉及 $u_{i,j}$ 及其四个邻居。这种结构产生了一个具有五条非零对角线的 $N \\times N$ 矩阵 $A$：\n- 主对角线（模板中心，系数为 $4$）位于偏移量 $0$ 处。\n- 次对角线和超对角线（x方向邻居，系数为 $-1$）位于偏移量 $\\pm 1$ 处。\n- 远次对角线和远超对角线（y方向邻居，系数为 $-1$）位于偏移量 $\\pm n$ 处。\n矩阵 $A$ 是稀疏、对称且正定的。\n\n右端向量 $\\mathbf{b}$ 包含了源项 $f$ 和狄利克雷边界条件 $g$。对于以 $(x_i, y_j)$ 为中心的方程，$\\mathbf{b}$ 的相应分量始于 $h^2 f(x_i, y_j)$。如果模板中的四个邻居有任何一个位于边界 $\\partial\\Omega$ 上（例如，当 $i=1$ 时的 $u_{i-1,j}$），其值可从边界函数 $g$ 中获知（例如，$u_{0,j} = g(0, y_j)$）。这个已知值被移到方程的右侧。对应于点 $(x_i, y_j)$ 的右端项分量的完整表达式为：\n$$\nb_{i,j} = h^2 f(x_i, y_j) + \\delta_{i,1}g(0, y_j) + \\delta_{i,n}g(1, y_j) + \\delta_{j,1}g(x_i, 0) + \\delta_{j,n}g(x_i, 1)\n$$\n其中 $\\delta$ 代表克罗内克 delta 符号 (Kronecker delta)。通过将 $b_{i,j}$ 值的网格展平来组装向量 $\\mathbf{b}$，并保持与用于 $\\mathbf{u}_h$ 相同的行主序。\n\n加密研究通过求解系统 $A\\mathbf{u}_h=\\mathbf{b}$ 来进行，针对一系列递减的网格间距 $h$，这些间距对应于给定的内部网格尺寸 $n \\in \\{7, 15, 31, 63\\}$。对于每个解 $u_h$，我们计算离散 $L^2$ 误差：\n$$\nE(h) = \\left(h^2 \\sum_{i=1}^{n}\\sum_{j=1}^{n}\\left(u_h(x_i,y_j) - u(x_i,y_j)\\right)^2\\right)^{1/2}\n$$\n然后使用以下公式在两个连续的加密步骤之间（例如，间距为 $h$ 和 $h/2$）估计观测收敛阶 $p$：\n$$\np(h \\to h/2) = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)}\n$$\n对于一个二阶精确的格式，我们预计当 $h \\to 0$ 时，$p$ 将趋近于 $2$。该实现将为每个加密步骤计算此阶数，并检查结果是否落在理论值的指定容差范围内。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\nimport math\n\n# --- Problem Definition ---\n\n# The scalar Poisson problem is -Delta u = f on Omega = (0,1)x(0,1)\n# with Dirichlet boundary conditions u|dOmega = g.\n\n# --- Numerical Scheme ---\n\n# The implementation uses a second-order central finite difference scheme\n# on a uniform Cartesian grid with n interior points per direction.\n# This results in the 5-point stencil for the negative Laplacian. The\n# discrete equation at an interior node (i,j) is:\n#   4*u_ij - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} = h^2 * f_ij\n#\n# This leads to a linear system A*u_h = b, where A is a sparse,\n# symmetric positive-definite matrix. Boundary conditions are incorporated\n# into the right-hand side vector b.\n\ndef run_refinement_study(u_exact, f_source, n_list):\n    \"\"\"\n    Performs a grid refinement study for a given manufactured solution.\n\n    Args:\n        u_exact (callable): The exact solution u(x, y).\n        f_source (callable): The source term f(x, y) = -Delta u.\n        n_list (list of int): A sequence of interior grid sizes.\n\n    Returns:\n        tuple: A tuple containing:\n            - float: The observed order of convergence on the finest grid.\n            - bool: True if all observed orders are within [1.8, 2.2].\n    \"\"\"\n    errors = []\n    g_boundary = u_exact\n\n    for n in n_list:\n        # Total number of interior unknowns\n        N = n * n\n        # Grid spacing\n        h = 1.0 / (n + 1)\n\n        # 1. Construct the sparse matrix A for the negative Laplacian operator.\n        # The matrix has 5 diagonals based on the 5-point stencil.\n        # We use row-major ordering for mapping (i,j) -> k.\n        \n        # Main diagonal (coefficient 4)\n        d0 = np.ones(N) * 4\n        \n        # Off-diagonals for x-derivatives (coefficient -1)\n        d1 = np.ones(N - 1) * -1\n        # Set stencil connections at row boundaries to zero.\n        d1[n - 1::n] = 0\n        \n        # Off-diagonals for y-derivatives (coefficient -1)\n        dn = np.ones(N - n) * -1\n        \n        A = diags([d0, d1, d1, dn, dn], [0, 1, -1, n, -n], format='csr')\n\n        # 2. Construct the right-hand side vector b.\n        x_coords = np.linspace(h, 1 - h, n)\n        y_coords = np.linspace(h, 1 - h, n)\n        xx, yy = np.meshgrid(x_coords, y_coords, indexing='xy')\n        \n        # Start with the source term f\n        b_grid = h**2 * f_source(xx, yy)\n        \n        # Add contributions from Dirichlet boundary conditions\n        b_grid[0, :] += g_boundary(x_coords, 0.0)      # Bottom boundary (j=1)\n        b_grid[-1, :] += g_boundary(x_coords, 1.0)     # Top boundary (j=n)\n        b_grid[:, 0] += g_boundary(0.0, y_coords)      # Left boundary (i=1)\n        b_grid[:, -1] += g_boundary(1.0, y_coords)     # Right boundary (i=n)\n        \n        b_vec = b_grid.flatten()\n\n        # 3. Solve the linear system A * u_h = b\n        u_h_vec = spsolve(A, b_vec)\n        u_h_grid = u_h_vec.reshape((n, n))\n\n        # 4. Compute the discrete L2 error\n        u_exact_grid = u_exact(xx, yy)\n        error_grid = u_h_grid - u_exact_grid\n        \n        # E(h) = (h^2 * sum(e_ij^2))^(1/2) = h * ||e_ij||_F\n        l2_error = h * np.linalg.norm(error_grid)\n        errors.append(l2_error)\n\n    # 5. Compute the observed orders of convergence\n    orders = []\n    for i in range(len(errors) - 1):\n        # p = log(E(h)/E(h/2)) / log(2)\n        order = math.log(errors[i] / errors[i+1]) / math.log(2)\n        orders.append(order)\n        \n    finest_order = orders[-1]\n    all_in_tolerance = all(1.8 = o = 2.2 for o in orders)\n    \n    return finest_order, all_in_tolerance\n\n\ndef solve():\n    \"\"\"\n    Main driver function to run the test cases and print the final result.\n    \"\"\"\n    # Define the sequence of interior grid sizes for the refinement study\n    n_list = [7, 15, 31, 63]\n\n    # Test Case A: Smooth trigonometric solution, zero on boundary\n    u_A = lambda x, y: np.sin(2 * np.pi * x) * np.sin(3 * np.pi * y)\n    f_A = lambda x, y: ((2 * np.pi)**2 + (3 * np.pi)**2) * u_A(x, y)\n\n    # Test Case B: Exponential solution, non-zero on boundary\n    u_B = lambda x, y: np.exp(x + y)\n    f_B = lambda x, y: -2.0 * np.exp(x + y)\n    \n    # Test Case C: Polynomial solution\n    u_C = lambda x, y: x**2 * y**2\n    f_C = lambda x, y: -2.0 * (x**2 + y**2)\n\n    test_cases = [\n        {\"u\": u_A, \"f\": f_A},\n        {\"u\": u_B, \"f\": f_B},\n        {\"u\": u_C, \"f\": f_C},\n    ]\n\n    # Store results for final output\n    p_results = []\n    b_results = []\n\n    for case in test_cases:\n        p_fine, b_tol = run_refinement_study(case[\"u\"], case[\"f\"], n_list)\n        p_results.append(p_fine)\n        b_results.append(b_tol)\n    \n    final_output_list = p_results + b_results\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, final_output_list))}]\")\n\nsolve()\n```", "id": "3453785"}]}