{"hands_on_practices": [{"introduction": "共轭梯度法 (CG) 的核心是一套优雅的迭代更新规则。为了真正掌握该算法的运作方式，没有什么比通过一个具体的例子亲手进行计算更有效了。本练习 [@problem_id:3436339] 提供了一个简单的 $2 \\times 2$ 对称正定系统，要求您手动执行两步迭代，从而让您熟悉计算步长、更新解和残差以及生成新的 $A$-共轭搜索方向的全过程。", "problem": "考虑一个由椭圆偏微分方程的Galerkin离散化产生的对称正定线性系统，其矩阵为 $A=\\begin{pmatrix}4&1\\\\1&3\\end{pmatrix}$，右端向量为 $b=\\begin{pmatrix}1\\\\2\\end{pmatrix}$，初始猜测值为 $x_0=\\begin{pmatrix}0\\\\0\\end{pmatrix}$。应用共轭梯度(CG)方法，使用精确算术、标准残差 $r_k=b-Ax_k$、$A$-共轭的搜索方向以及为最小化每个搜索方向上的二次能量而选择的步长。令 $x_\\star$ 表示 $Ax_\\star=b$ 的唯一解，令 $e_k=x_\\star-x_k$ 表示第 $k$ 次迭代的误差，并定义能量范数为 $\\|e\\|_A=\\sqrt{e^{\\top}Ae}$。从 $x_0$ 开始，精确执行两次CG迭代，以计算 $x_2$、$r_2$ 和 $\\|e_2\\|_A$。将你的最终答案表示为一个单一的行矩阵，其中按顺序包含 $x_2$ 的两个分量、$r_2$ 的两个分量以及标量 $\\|e_2\\|_A$。请提供精确值，无需四舍五入。", "solution": "首先验证问题，以确保其科学上成立、适定且客观。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n- 该线性系统由矩阵 $A=\\begin{pmatrix}4&1\\\\1&3\\end{pmatrix}$ 和右端向量 $b=\\begin{pmatrix}1\\\\2\\end{pmatrix}$ 定义。\n- 初始猜测值为 $x_0=\\begin{pmatrix}0\\\\0\\end{pmatrix}$。\n- 使用的方法是共轭梯度(CG)方法，采用精确算术。\n- 要执行的迭代次数恰好是 $2$ 次。\n- 需要计算的量是解的估计值 $x_2$、残差 $r_2$ 和误差的能量范数 $\\|e_2\\|_A$。\n- 提供的定义有：残差 $r_k=b-Ax_k$、误差 $e_k=x_\\star-x_k$ (其中 $x_\\star$ 是 $Ax_\\star=b$ 的精确解) 以及能量范数 $\\|e\\|_A=\\sqrt{e^{\\top}Ae}$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学上成立**：该问题要求应用共轭梯度方法，这是数值线性代数中解决对称正定(SPD)矩阵线性系统的典型算法。该问题基于已确立的数学原理。\n- **适定性**：为使CG方法适用，矩阵 $A$ 必须是对称正定的(SPD)。\n  - 对称性：矩阵 $A$ 是对称的，因为 $A_{12} = A_{21} = 1$。\n  - 正定性：我们检查 $A$ 的顺序主子式。一阶顺序主子式是 $\\det(4) = 4 > 0$。二阶顺序主子式是 $\\det(A) = 4 \\times 3 - 1 \\times 1 = 12 - 1 = 11 > 0$。由于所有顺序主子式都为正，根据 Sylvester 判据，$A$ 是正定的。\n- 因为 $A$ 是对称正定的，所以它是可逆的，保证存在唯一解 $x_\\star$。CG 算法是良定义的，并且保证对于一个 $2 \\times 2$ 系统，在精确算术下，至多在 $n=2$ 步内收敛到精确解。\n- **客观性**：该问题使用精确的数学术语、定义和数值进行陈述，没有歧义或主观因素。\n\n**步骤3：结论与行动**\n该问题被判定为**有效**，因为它是科学上合理的、适定的且客观的。将提供完整的解答。\n\n**求解过程**\n\n共轭梯度算法的步骤如下。\n\n**初始化 (k=0):**\n初始猜测值为 $x_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。\n初始残差为 $r_0 = b - A x_0 = b = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$。\n初始搜索方向设为残差：$p_0 = r_0 = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$。\n\n**第1次迭代 (k=0 到 k=1):**\n首先，我们计算步长 $\\alpha_0$：\n$$ \\alpha_0 = \\frac{r_0^{\\top} r_0}{p_0^{\\top} A p_0} $$\n分子是 $r_0^{\\top} r_0 = \\begin{pmatrix} 1 & 2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = 1^2 + 2^2 = 5$。\n对于分母，我们首先计算 $A p_0$：\n$$ A p_0 = \\begin{pmatrix} 4 & 1 \\\\ 1 & 3 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 4(1) + 1(2) \\\\ 1(1) + 3(2) \\end{pmatrix} = \\begin{pmatrix} 6 \\\\ 7 \\end{pmatrix} $$\n然后，$p_0^{\\top} A p_0 = \\begin{pmatrix} 1 & 2 \\end{pmatrix} \\begin{pmatrix} 6 \\\\ 7 \\end{pmatrix} = 1(6) + 2(7) = 20$。\n因此，步长为 $\\alpha_0 = \\frac{5}{20} = \\frac{1}{4}$。\n\n现在，我们更新解和残差：\n$$ x_1 = x_0 + \\alpha_0 p_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} + \\frac{1}{4} \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 1/4 \\\\ 1/2 \\end{pmatrix} $$\n$$ r_1 = r_0 - \\alpha_0 A p_0 = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} - \\frac{1}{4} \\begin{pmatrix} 6 \\\\ 7 \\end{pmatrix} = \\begin{pmatrix} 1 - 6/4 \\\\ 2 - 7/4 \\end{pmatrix} = \\begin{pmatrix} 1 - 3/2 \\\\ 8/4 - 7/4 \\end{pmatrix} = \\begin{pmatrix} -1/2 \\\\ 1/4 \\end{pmatrix} $$\n\n接下来，我们通过计算 $\\beta_0$ 和新的搜索方向 $p_1$ 来为第二次迭代做准备：\n$$ \\beta_0 = \\frac{r_1^{\\top} r_1}{r_0^{\\top} r_0} $$\n新的分子是 $r_1^{\\top} r_1 = \\begin{pmatrix} -1/2 & 1/4 \\end{pmatrix} \\begin{pmatrix} -1/2 \\\\ 1/4 \\end{pmatrix} = (-\\frac{1}{2})^2 + (\\frac{1}{4})^2 = \\frac{1}{4} + \\frac{1}{16} = \\frac{5}{16}$。\n分母 $r_0^{\\top} r_0 = 5$ 已在前面计算过。\n所以，$\\beta_0 = \\frac{5/16}{5} = \\frac{1}{16}$。\n\n新的搜索方向是：\n$$ p_1 = r_1 + \\beta_0 p_0 = \\begin{pmatrix} -1/2 \\\\ 1/4 \\end{pmatrix} + \\frac{1}{16} \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} -8/16 + 1/16 \\\\ 4/16 + 2/16 \\end{pmatrix} = \\begin{pmatrix} -7/16 \\\\ 6/16 \\end{pmatrix} $$\n\n**第2次迭代 (k=1 到 k=2):**\n我们计算步长 $\\alpha_1$：\n$$ \\alpha_1 = \\frac{r_1^{\\top} r_1}{p_1^{\\top} A p_1} $$\n分子 $r_1^{\\top} r_1 = 5/16$ 刚刚计算过。\n对于分母，我们首先计算 $A p_1$：\n$$ A p_1 = \\begin{pmatrix} 4 & 1 \\\\ 1 & 3 \\end{pmatrix} \\begin{pmatrix} -7/16 \\\\ 6/16 \\end{pmatrix} = \\frac{1}{16} \\begin{pmatrix} 4(-7) + 1(6) \\\\ 1(-7) + 3(6) \\end{pmatrix} = \\frac{1}{16} \\begin{pmatrix} -22 \\\\ 11 \\end{pmatrix} $$\n然后，$p_1^{\\top} A p_1 = \\begin{pmatrix} -7/16 & 6/16 \\end{pmatrix} \\frac{1}{16} \\begin{pmatrix} -22 \\\\ 11 \\end{pmatrix} = \\frac{1}{256} \\left( (-7)(-22) + 6(11) \\right) = \\frac{1}{256} (154 + 66) = \\frac{220}{256} = \\frac{55}{64}$。\n因此，步长为 $\\alpha_1 = \\frac{5/16}{55/64} = \\frac{5}{16} \\cdot \\frac{64}{55} = \\frac{1}{1} \\cdot \\frac{4}{11} = \\frac{4}{11}$。\n\n现在我们更新解得到 $x_2$，更新残差得到 $r_2$：\n$$ x_2 = x_1 + \\alpha_1 p_1 = \\begin{pmatrix} 1/4 \\\\ 1/2 \\end{pmatrix} + \\frac{4}{11} \\begin{pmatrix} -7/16 \\\\ 6/16 \\end{pmatrix} = \\begin{pmatrix} 1/4 \\\\ 1/2 \\end{pmatrix} + \\begin{pmatrix} -7/44 \\\\ 6/44 \\end{pmatrix} = \\begin{pmatrix} 11/44 - 7/44 \\\\ 22/44 + 6/44 \\end{pmatrix} = \\begin{pmatrix} 4/44 \\\\ 28/44 \\end{pmatrix} = \\begin{pmatrix} 1/11 \\\\ 7/11 \\end{pmatrix} $$\n$$ r_2 = r_1 - \\alpha_1 A p_1 = \\begin{pmatrix} -1/2 \\\\ 1/4 \\end{pmatrix} - \\frac{4}{11} \\left( \\frac{1}{16} \\begin{pmatrix} -22 \\\\ 11 \\end{pmatrix} \\right) = \\begin{pmatrix} -1/2 \\\\ 1/4 \\end{pmatrix} - \\frac{1}{44} \\begin{pmatrix} -22 \\\\ 11 \\end{pmatrix} = \\begin{pmatrix} -1/2 \\\\ 1/4 \\end{pmatrix} - \\begin{pmatrix} -1/2 \\\\ 1/4 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} $$\n\n所求的量是 $x_2$、$r_2$ 和 $\\|e_2\\|_A$。\n我们已经求得 $x_2 = \\begin{pmatrix} 1/11 \\\\ 7/11 \\end{pmatrix}$ 和 $r_2 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。\n$r_2 = b - A x_2 = 0$ 这一事实意味着 $A x_2 = b$。因此，$x_2$ 是精确解，所以 $x_2 = x_\\star$。\n第2次迭代的误差是 $e_2 = x_\\star - x_2 = x_2 - x_2 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。\n误差的能量范数计算如下：\n$$ \\|e_2\\|_A = \\sqrt{e_2^{\\top} A e_2} = \\sqrt{\\begin{pmatrix} 0 & 0 \\end{pmatrix} \\begin{pmatrix} 4 & 1 \\\\ 1 & 3 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}} = \\sqrt{0} = 0 $$\n\n最终答案要求一个单一的行矩阵，按顺序包含 $x_2$ 的分量、$r_2$ 的分量以及标量 $\\|e_2\\|_A$。\n$x_2$ 的分量是 $1/11$ 和 $7/11$。\n$r_2$ 的分量是 $0$ 和 $0$。\n$\\|e_2\\|_A$ 的值是 $0$。\n得到的行矩阵是 $\\begin{pmatrix} \\frac{1}{11} & \\frac{7}{11} & 0 & 0 & 0 \\end{pmatrix}$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{11} & \\frac{7}{11} & 0 & 0 & 0\n\\end{pmatrix}\n}\n$$", "id": "3436339"}, {"introduction": "共轭梯度法一个深刻的理论性质是其有限终止性：在精确算术下，对于一个具有 $k$ 个不同特征值的矩阵，CG 方法至多在 $k$ 步内就能找到精确解。本练习 [@problem_id:3436325] 要求您构造一个具有两个不同特征值的 $3 \\times 3$ 矩阵，并验证 CG 确实在第二步终止。这个过程不仅能加深您对 CG 收敛理论的理解，还能锻炼您将抽象理论与具体数值实例联系起来的能力。", "problem": "考虑将共轭梯度（CG）法应用于一个由对称正定离散化产生的线性系统，这在椭圆偏微分方程（PDE）的数值解中很常见。您的任务是构造并验证一个具体实例，在该实例中，共轭梯度法在精确算术下恰好在 $2$ 步内终止。\n\n请提供一个显式的 $3 \\times 3$ 对称正定矩阵 $A$，该矩阵恰好有两个不同的特征值，以及一个右端向量 $b$，该向量在与 $A$ 的两个不同特征值相关联的特征空间上的投影分量均不为零。从 $x_0 = 0$ 开始共轭梯度迭代。仅使用共轭梯度法的基本定义（残差、搜索方向以及由 $A$ 诱导的内积和欧几里得内积定义的步长），以符号形式精确地执行前两次迭代，并通过证明 $2$ 步后的误差 $e_2 := x_{\\ast} - x_2$ 为零向量来验证终止，其中 $x_{\\ast}$ 表示 $A x = b$ 的精确解。\n\n作为最终答案，报告平方欧几里得范数 $\\|e_2\\|_2^2$ 的精确值。无需四舍五入，也无需单位。", "solution": "用户是一位严谨、苛刻的STEM领域教授。我必须严格遵守指示。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n*   **任务：** 构造一个显式的 $3 \\times 3$ 对称正定（SPD）矩阵 $A$。\n*   **约束1：** $A$ 必须恰好有两个不同的特征值。\n*   **任务：** 构造一个右端向量 $b$。\n*   **约束2：** 对于 $x_0=0$，初始误差 $x_*=A^{-1}b$ 在与 $A$ 的两个不同特征值相关联的特征空间上的投影必须不为零。这等价于初始残差 $r_0 = b$ 在这些特征空间上有非零投影。\n*   **初始条件：** 共轭梯度（CG）迭代从 $x_0 = 0$ 开始。\n*   **方法：** 使用共轭梯度法的基本定义，以符号形式精确地执行前两次迭代。\n*   **验证：** 证明 2 步后的误差 $e_2 := x_* - x_2$ 是零向量，从而验证在恰好 2 步内终止。\n*   **要求输出：** 报告平方欧几里得范数 $\\|e_2\\|_2^2$ 的精确值。\n\n**步骤2：使用提取的已知条件进行验证**\n\n该问题具有科学依据。共轭梯度法及其收敛性质是数值线性代数的基石。一个著名定理指出，如果系统 $Ax=b$ 中的矩阵 $A$ 有 $k$ 个不同的特征值，并且初始残差在所有相应特征空间上都有分量，那么在精确算术下，CG 方法至多在 $k$ 次迭代内找到精确解。本问题要求对一个具有 $k=2$ 个不同特征值的 $3 \\times 3$ 矩阵，构造并验证该定理的一个具体实例。\n\n该问题是适定且客观的。它为构造一个特定示例（$3 \\times 3$ 对称正定矩阵，2个不同特征值，$x_0=0$）提供了清晰、形式化的约束，并要求一个确定性的验证过程（运行CG 2步并证明所得误差为零）。要求的输出是一个单一、明确的数值。\n\n问题的设置是完整和一致的。构造示例和执行验证所需的所有信息要么已经提供，要么是构造任务本身的一部分。这是一个标准的、非平凡的数值分析练习，旨在测试对CG方法理论基础的理解。它没有违反任何无效性标准。\n\n**步骤3：结论与行动**\n\n问题是有效的。我将继续解答。\n\n### 解答\n\n问题的核心是展示共轭梯度（CG）法的终止性质。该方法保证在至多 $k$ 步内找到 $Ax=b$ 的精确解，其中 $k$ 是矩阵 $A$ 的不同特征值的数量，前提是初始残差在所有相应的特征空间上都有分量。我们将构造一个具有 $k=2$ 个不同特征值的 $3 \\times 3$ 对称正定矩阵 $A$ 和一个向量 $b$，使得CG算法恰好在 $2$ 步内终止。\n\n**1. 构造矩阵 $A$ 和向量 $b$**\n\n设两个不同的特征值为 $\\lambda_1 = 1$ 和 $\\lambda_2 = 2$。对于一个 $3 \\times 3$ 矩阵，其中一个特征值的代数重数必须为 $2$。我们设定 $\\lambda_1=1$（重数为 $1$）和 $\\lambda_2=2$（重数为 $2$）。\n\n为了构造 $A$，我们使用谱分解 $A = Q \\Lambda Q^{\\top}$。我们选择一组简单的正交特征向量基。\n*   对于 $\\lambda_1 = 1$，设归一化特征向量为 $v_1 = \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$。\n*   对于 $\\lambda_2 = 2$，我们需要两个与 $v_1$ 正交的正交特征向量。我们可以选择 $v_2 = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix}$ 和 $v_3 = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 1 \\\\ 1 \\\\ -2 \\end{pmatrix}$。\n\n特征向量矩阵为 $Q = \\begin{pmatrix} v_1 & v_2 & v_3 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{\\sqrt{3}} & \\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{6}} \\\\ \\frac{1}{\\sqrt{3}} & -\\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{6}} \\\\ \\frac{1}{\\sqrt{3}} & 0 & -\\frac{2}{\\sqrt{6}} \\end{pmatrix}$，特征值对角矩阵为 $\\Lambda = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 2 & 0 \\\\ 0 & 0 & 2 \\end{pmatrix}$。\n\n计算 $A = Q \\Lambda Q^{\\top}$：\n$$ A = \\begin{pmatrix} \\frac{1}{\\sqrt{3}} & \\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{6}} \\\\ \\frac{1}{\\sqrt{3}} & -\\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{6}} \\\\ \\frac{1}{\\sqrt{3}} & 0 & -\\frac{2}{\\sqrt{6}} \\end{pmatrix} \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 2 & 0 \\\\ 0 & 0 & 2 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{\\sqrt{3}} & \\frac{1}{\\sqrt{3}} & \\frac{1}{\\sqrt{3}} \\\\ \\frac{1}{\\sqrt{2}} & -\\frac{1}{\\sqrt{2}} & 0 \\\\ \\frac{1}{\\sqrt{6}} & \\frac{1}{\\sqrt{6}} & -\\frac{2}{\\sqrt{6}} \\end{pmatrix} = \\frac{1}{3}\\begin{pmatrix} 5 & -1 & -1 \\\\ -1 & 5 & -1 \\\\ -1 & -1 & 5 \\end{pmatrix} $$\n根据构造，该矩阵是对称的。其特征值为 $1$ 和 $2$，均为正数，因此 $A$ 是正定的。\n\n接下来，我们构造向量 $b$。初始残差为 $r_0 = b - A x_0$。由于 $x_0 = 0$，我们有 $r_0 = b$。为了在恰好 $2$ 步内终止， $r_0$ 必须在 $\\lambda_1$ 的特征空间和 $\\lambda_2$ 的特征空间中都有非零分量。实现这一点的一个简单方法是将 $b$ 定义为来自每个空间的特征向量的线性组合。我们选择 $b = v_1' + v_2'$，其中 $v_1'$ 属于 $\\lambda_1$ 的特征空间，$v_2'$ 属于 $\\lambda_2$ 的特征空间。为简单起见，我们使用未归一化的特征向量：\n$v_1' = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$ 和 $v_2' = \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix}$。\n$$ b = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix} $$\n\n**2. 共轭梯度迭代**\n\n我们应用CG算法求解 $Ax=b$，其中 $x_0=0$。\n该系统为：\n$$ \\frac{1}{3}\\begin{pmatrix} 5 & -1 & -1 \\\\ -1 & 5 & -1 \\\\ -1 & -1 & 5 \\end{pmatrix} x = \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix}, \\quad x_0 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} $$\n\n初始设置：\n$r_0 = b - Ax_0 = b = \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix}$\n$p_0 = r_0 = \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix}$\n\n**迭代 $1$ ($k=0$ 时)：**\n步长 $\\alpha_0 = \\frac{r_0^{\\top} r_0}{p_0^{\\top} A p_0}$：\n$r_0^{\\top} r_0 = 2^2 + 0^2 + 1^2 = 5$\n$A p_0 = \\frac{1}{3}\\begin{pmatrix} 5 & -1 & -1 \\\\ -1 & 5 & -1 \\\\ -1 & -1 & 5 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{3}\\begin{pmatrix} 10 - 1 \\\\ -2 - 1 \\\\ -2 + 5 \\end{pmatrix} = \\frac{1}{3}\\begin{pmatrix} 9 \\\\ -3 \\\\ 3 \\end{pmatrix} = \\begin{pmatrix} 3 \\\\ -1 \\\\ 1 \\end{pmatrix}$\n$p_0^{\\top} A p_0 = r_0^{\\top} (A p_0) = \\begin{pmatrix} 2 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 3 \\\\ -1 \\\\ 1 \\end{pmatrix} = 6 + 0 + 1 = 7$\n$\\alpha_0 = \\frac{5}{7}$\n\n更新解和残差：\n$x_1 = x_0 + \\alpha_0 p_0 = 0 + \\frac{5}{7} \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 10/7 \\\\ 0 \\\\ 5/7 \\end{pmatrix}$\n$r_1 = r_0 - \\alpha_0 A p_0 = \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix} - \\frac{5}{7} \\begin{pmatrix} 3 \\\\ -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 14/7 - 15/7 \\\\ 5/7 \\\\ 7/7 - 5/7 \\end{pmatrix} = \\frac{1}{7}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix}$\n由于 $r_1 \\neq 0$，算法尚未终止。\n\n准备下一次迭代：\n$\\beta_0 = \\frac{r_1^{\\top} r_1}{r_0^{\\top} r_0}$：\n$r_1^{\\top} r_1 = \\left(\\frac{1}{7}\\right)^2 ((-1)^2 + 5^2 + 2^2) = \\frac{1}{49}(1+25+4) = \\frac{30}{49}$\n$\\beta_0 = \\frac{30/49}{5} = \\frac{6}{49}$\n$p_1 = r_1 + \\beta_0 p_0 = \\frac{1}{7}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix} + \\frac{6}{49}\\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{49} \\left( 7\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix} + 6\\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix} \\right) = \\frac{1}{49} \\begin{pmatrix} -7+12 \\\\ 35+0 \\\\ 14+6 \\end{pmatrix} = \\frac{1}{49}\\begin{pmatrix} 5 \\\\ 35 \\\\ 20 \\end{pmatrix} = \\frac{5}{49}\\begin{pmatrix} 1 \\\\ 7 \\\\ 4 \\end{pmatrix}$\n\n**迭代 $2$ ($k=1$ 时)：**\n步长 $\\alpha_1 = \\frac{r_1^{\\top} r_1}{p_1^{\\top} A p_1}$：\n$r_1^{\\top} r_1 = \\frac{30}{49}$\n$A p_1 = \\frac{5}{49} A \\begin{pmatrix} 1 \\\\ 7 \\\\ 4 \\end{pmatrix} = \\frac{5}{49} \\frac{1}{3}\\begin{pmatrix} 5-7-4 \\\\ -1+35-4 \\\\ -1-7+20 \\end{pmatrix} = \\frac{5}{147}\\begin{pmatrix} -6 \\\\ 30 \\\\ 12 \\end{pmatrix} = \\frac{30}{147}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix} = \\frac{10}{49}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix}$\n$p_1^{\\top} A p_1 = \\left(\\frac{5}{49}\\begin{pmatrix} 1 \\\\ 7 \\\\ 4 \\end{pmatrix}^{\\top}\\right) \\left(\\frac{10}{49}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix}\\right) = \\frac{50}{49^2} (1(-1) + 7(5) + 4(2)) = \\frac{50}{49^2}(-1+35+8) = \\frac{50 \\cdot 42}{49^2} = \\frac{50 \\cdot 6 \\cdot 7}{49 \\cdot 49} = \\frac{300}{343}$\n$\\alpha_1 = \\frac{30/49}{300/343} = \\frac{30}{49} \\cdot \\frac{343}{300} = \\frac{1}{10} \\cdot \\frac{7^3}{7^2} = \\frac{7}{10}$\n\n更新解和残差：\n$x_2 = x_1 + \\alpha_1 p_1 = \\begin{pmatrix} 10/7 \\\\ 0 \\\\ 5/7 \\end{pmatrix} + \\frac{7}{10} \\left( \\frac{5}{49}\\begin{pmatrix} 1 \\\\ 7 \\\\ 4 \\end{pmatrix} \\right) = \\begin{pmatrix} 10/7 \\\\ 0 \\\\ 5/7 \\end{pmatrix} + \\frac{1}{14}\\begin{pmatrix} 1 \\\\ 7 \\\\ 4 \\end{pmatrix} = \\begin{pmatrix} 20/14 + 1/14 \\\\ 7/14 \\\\ 10/14 + 4/14 \\end{pmatrix} = \\begin{pmatrix} 21/14 \\\\ 7/14 \\\\ 14/14 \\end{pmatrix} = \\begin{pmatrix} 3/2 \\\\ 1/2 \\\\ 1 \\end{pmatrix}$\n$r_2 = r_1 - \\alpha_1 A p_1 = \\frac{1}{7}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix} - \\frac{7}{10} \\left( \\frac{10}{49}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix} \\right) = \\frac{1}{7}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix} - \\frac{1}{7}\\begin{pmatrix} -1 \\\\ 5 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$\n由于 $r_2=0$，CG算法恰好在第 $2$ 步终止。\n\n**3. 解的验证**\n\n为验证 $x_2$ 是精确解 $x_*$，我们直接求解 $Ax=b$。\n首先，我们求 $A^{-1}$。对于形如 $c_1 I + c_2 J$（其中 $J$ 是全一矩阵）的矩阵，有一个有用的恒等式：$(c_1 I + c_2 J)^{-1} = \\frac{1}{c_1}I - \\frac{c_2}{c_1(c_1+nc_2)}J$。我们的矩阵是 $A = 2I - \\frac{1}{3}J$。此处 $n=3, c_1=2, c_2=-1/3$。\n$$ A^{-1} = \\frac{1}{2}I - \\frac{-1/3}{2(2+3(-1/3))}J = \\frac{1}{2}I + \\frac{1/3}{2(2-1)}J = \\frac{1}{2}I + \\frac{1}{12}J $$\n$$ A^{-1} = \\frac{1}{2}\\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} + \\frac{1}{12}\\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{pmatrix} = \\frac{1}{12}\\begin{pmatrix} 6+1 & 1 & 1 \\\\ 1 & 6+1 & 1 \\\\ 1 & 1 & 6+1 \\end{pmatrix} = \\frac{1}{12}\\begin{pmatrix} 7 & 1 & 1 \\\\ 1 & 7 & 1 \\\\ 1 & 1 & 7 \\end{pmatrix} $$\n等等，这里的推导和我自己的推导不一致。我的推导 $A^{-1} = \\frac{1}{2}I + \\frac{1}{6}J$ 是正确的。原文档中的推导 `(c_1+nc_2)` 似乎有误。让我们用我推导的正确公式。\n$A^{-1} = \\frac{1}{2}I + \\frac{1}{6}J = \\frac{1}{6} \\begin{pmatrix} 3 & 0 & 0 \\\\ 0 & 3 & 0 \\\\ 0 & 0 & 3 \\end{pmatrix} + \\frac{1}{6} \\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{pmatrix} = \\frac{1}{6} \\begin{pmatrix} 4 & 1 & 1 \\\\ 1 & 4 & 1 \\\\ 1 & 1 & 4 \\end{pmatrix}$。\n啊哈，我误读了原文档，它用的公式是 `A^{-1} = 1/2 I + 1/6 J`，这与我的推导一致。我把它与下一个矩阵混淆了。让我们重新看原文档的计算。\n`A^{-1} = 1/6 (4 1 1; 1 4 1; 1 1 4)`。这是对的。\n现在，我们计算精确解 $x_* = A^{-1}b$：\n$$ x_* = \\frac{1}{6}\\begin{pmatrix} 4 & 1 & 1 \\\\ 1 & 4 & 1 \\\\ 1 & 1 & 4 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{6}\\begin{pmatrix} 4(2)+1(0)+1(1) \\\\ 1(2)+4(0)+1(1) \\\\ 1(2)+1(0)+4(1) \\end{pmatrix} = \\frac{1}{6}\\begin{pmatrix} 9 \\\\ 3 \\\\ 6 \\end{pmatrix} = \\begin{pmatrix} 9/6 \\\\ 3/6 \\\\ 6/6 \\end{pmatrix} = \\begin{pmatrix} 3/2 \\\\ 1/2 \\\\ 1 \\end{pmatrix} $$\n将我们的CG结果 $x_2$ 与精确解 $x_*$ 进行比较：\n$$ x_2 = \\begin{pmatrix} 3/2 \\\\ 1/2 \\\\ 1 \\end{pmatrix} = x_* $$\n2步后的误差为 $e_2 = x_* - x_2 = 0$。\n误差的平方欧几里得范数为 $\\|e_2\\|_2^2 = \\|0\\|_2^2 = 0^2+0^2+0^2 = 0$。验证完成。", "answer": "$$\n\\boxed{0}\n$$", "id": "3436325"}, {"introduction": "在理论上，CG 方法保证了误差的能量范数 $\\|e_k\\|_A$ 是单调递减的，这是其收敛性的基石。然而，在实践中我们通常监控更易于计算的残差范数 $\\|r_k\\|_2$ 来判断收敛。本计算练习 [@problem_id:3436372] 旨在揭示一个重要的实践细节：即使能量范数稳定下降，残差范数也可能出现非单调行为。通过构建并求解一个源于偏微分方程离散化的具体例子，您将直观地看到这两种收敛度量之间的区别，并理解为什么基于残差范数设计的朴素停止准则可能存在缺陷。", "problem": "考虑一个一维反应扩散方程在开区间 $(0,1)$ 上的边值问题，其边界条件为齐次狄利克雷（Dirichlet）边界条件：求解 $u : [0,1] \\to \\mathbb{R}$，使得\n$$\n- \\frac{d^2 u}{dx^2} + \\alpha u = f(x), \\quad x \\in (0,1), \\quad u(0) = u(1) = 0,\n$$\n其中 $\\alpha \\ge 0$ 是一个常数反应系数。使用标准的二阶中心有限差分法，在 $n$ 个内部网格点上对该问题进行离散化。设 $h = \\frac{1}{n+1}$，$x_i = i h$，其中 $i = 1,2,\\ldots,n$。离散系统具有以下形式\n$$\nA \\mathbf{u} = \\mathbf{b},\n$$\n其中 $A \\in \\mathbb{R}^{n \\times n}$ 是对称正定矩阵，其形式为 $A = \\frac{1}{h^2} \\operatorname{tridiag}(-1,2,-1) + \\alpha I$，$\\mathbf{u} \\in \\mathbb{R}^n$ 是内部点上解的近似值，$\\mathbf{b} \\in \\mathbb{R}^n$ 包含了 $f(x_i)$ 的值。对于此类问题，当 $A$ 是对称正定时，共轭梯度（Conjugate Gradient, CG）法是求解 $A \\mathbf{u} = \\mathbf{b}$ 的一种基本迭代算法。\n\n定义第 $k$ 次迭代的误差为 $\\mathbf{e}_k = \\mathbf{x}_k - \\mathbf{x}^\\star$，其中 $\\mathbf{x}^\\star$ 是线性系统的精确解；定义残差为 $\\mathbf{r}_k = \\mathbf{b} - A \\mathbf{x}_k$。由 $A$ 诱导的能量范数为 $\\|\\mathbf{e}_k\\|_A = \\sqrt{\\mathbf{e}_k^\\top A \\mathbf{e}_k}$，残差的欧几里得范数为 $\\|\\mathbf{r}_k\\|_2 = \\sqrt{\\mathbf{r}_k^\\top \\mathbf{r}_k}$。\n\n基于以下基本事实：\n- 对于所有 $\\alpha \\ge 0$，有限差分法离散化产生的矩阵 $A$ 都是对称正定的。\n- 共轭梯度法在仿射克雷洛夫（Krylov）序列 $\\mathbf{x}_0 + \\mathcal{K}_k(A,\\mathbf{r}_0)$ 中生成迭代向量 $\\mathbf{x}_k$，其中 $\\mathcal{K}_k(A,\\mathbf{r}_0) = \\operatorname{span}\\{\\mathbf{r}_0, A \\mathbf{r}_0, \\ldots, A^{k-1} \\mathbf{r}_0\\}$，且 $\\mathbf{r}_0 = \\mathbf{b} - A \\mathbf{x}_0$。\n- 共轭梯度法确保在精确计算中，误差的能量范数 $\\|\\mathbf{e}_k\\|_A$ 是单调递减的（除非已达到解，否则是严格递减的），\n请构思并实现一个程序，构建上述离散偏微分方程的特定实例，以证明即使能量范数 $\\|\\mathbf{e}_k\\|_A$ 严格递减，残差范数 $\\|\\mathbf{r}_k\\|_2$ 也可能不具有单调性。请遵循以下设计要求：\n\n1. 在每个测试用例中，将 $\\mathbf{b}$ 构建为 $A$ 的离散正弦特征向量的两种模式的组合，以强调谱分离效应。对于具有 $n$ 个内部点的网格，离散正弦特征向量 $v_j \\in \\mathbb{R}^n$ 的分量定义为 $(v_j)_i = \\sin\\left(\\frac{j \\pi i}{n+1}\\right)$，其中 $j=1,2,\\ldots,n$。在每个测试用例中，令\n$$\n\\mathbf{b} = c_1 v_1 + c_2 v_n,\n$$\n其中系数 $c_1, c_2 \\in \\mathbb{R}$ 已指定。请注意，加上 $\\alpha I$ 项不会改变离散拉普拉斯算子的正弦特征向量，因此这些 $v_j$ 仍然是 $A$ 的特征向量。\n\n2. 实现针对对称正定矩阵的标准共轭梯度法，从初始猜测 $\\mathbf{x}_0 = \\mathbf{0}$ 开始，并在每次迭代 $k$ 时记录：\n   - 残差范数 $\\|\\mathbf{r}_k\\|_2$。\n   - 误差的能量范数 $\\|\\mathbf{e}_k\\|_A$，该值通过使用直接法求解 $A \\mathbf{x}^\\star = \\mathbf{b}$ 得到的精确解 $\\mathbf{x}^\\star$ 来计算。\n\n3. 使用以下停止指标：\n   - 基于残差的指标 $k_{\\mathrm{res}}$：满足 $\\|\\mathbf{r}_k\\|_2 \\le \\tau_{\\mathrm{res}} \\|\\mathbf{r}_0\\|_2$ 的最小迭代次数 $k$，其中 $\\tau_{\\mathrm{res}} = 10^{-8}$。\n   - 基于能量的指标 $k_{\\mathrm{energy}}$：满足 $\\|\\mathbf{e}_k\\|_A \\le \\tau_{\\mathrm{energy}} \\|\\mathbf{e}_0\\|_A$ 的最小迭代次数 $k$，其中 $\\tau_{\\mathrm{energy}} = 10^{-8}$。\n\n4. 检测并报告残差范数序列是否非单调，即是否存在迭代 $k \\ge 1$ 使得 $\\|\\mathbf{r}_k\\|_2 > \\|\\mathbf{r}_{k-1}\\|_2$。同时报告在记录的迭代过程中，能量范数序列是否严格递减，即在终止前，是否对于所有 $k \\ge 1$ 都有 $\\|\\mathbf{e}_k\\|_A < \\|\\mathbf{e}_{k-1}\\|_A$。\n\n5. 评估一个错误地假设残差范数是单调的“朴素”停止规则所带来的影响。在第一次出现 $\\|\\mathbf{r}_k\\|_2 > \\|\\mathbf{r}_{k-1}\\|_2$ 的迭代 $k$ 处定义一个假设性的提早停止点。报告这种朴素停止是否会严格早于达到基于能量的容差，即该迭代指标是否小于 $k_{\\mathrm{energy}}$。\n\n实现您的程序以运行以下测试套件，每个测试用例由三元组 $(n,\\alpha,(c_1,c_2))$ 参数化：\n\n- 测试用例1（通用双模，强谱隙）：$(n,\\alpha,(c_1,c_2)) = (50, 0, (1.0, 0.3))$。\n- 测试用例2（反应项平移下的双模）：$(n,\\alpha,(c_1,c_2)) = (80, 5.0, (1.0, 0.2))$。\n- 测试用例3（单模边界情况）：$(n,\\alpha,(c_1,c_2)) = (60, 0, (1.0, 0.0))$。\n\n对于每个测试用例，您的程序必须输出一个包含五个基本值的列表：\n- 一个布尔值，指示残差范数是否非单调。\n- 一个布尔值，指示能量范数是否在达到容差前的每次迭代中都严格递减。\n- 一个布尔值，指示基于残差增加的朴素停止规则是否会在满足基于能量的容差之前停止。\n- 整数 $k_{\\mathrm{res}}$。\n- 整数 $k_{\\mathrm{energy}}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应于一个测试用例的五个值。例如：“[[true,true,false,2,2],[...],[...] ]”。所有布尔值必须以小写形式打印为“true”或“false”，整数必须为十进制表示法。\n\n此问题不涉及物理单位，如果出现任何角度，应以弧度为单位；但是，此任务中并未明确出现角度。", "solution": "该问题是有效的，因为它在科学上是合理的、适定的，并为数值线性代数中的一个计算实验提供了完整、明确的规范。该实验旨在展示共轭梯度（CG）法的一个著名但并非不重要的性质。我们将着手提供一个解决方案。\n\n### 1. 问题构建与离散化\n\n该问题涉及一维反应扩散边值问题的数值解：\n$$\n- \\frac{d^2 u}{dx^2} + \\alpha u = f(x), \\quad x \\in (0,1)\n$$\n边界条件为齐次狄利克雷条件 $u(0) = u(1) = 0$。常数 $\\alpha \\ge 0$ 代表反应系数。\n\n我们在一个包含 $n$ 个内部点 $x_i = i h$（其中 $i=1, \\dots, n$）的均匀网格上离散化该方程，其中网格间距为 $h = \\frac{1}{n+1}$。使用二阶中心有限差分近似二阶导数，我们得到一个线性方程组 $A \\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} \\in \\mathbb{R}^n$ 是近似解值 $u(x_i)$ 的向量。矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 由下式给出：\n$$\nA = \\frac{1}{h^2} \\operatorname{tridiag}(-1, 2, -1) + \\alpha I\n$$\n其中 $I$ 是 $n \\times n$ 单位矩阵。对于所有 $\\alpha \\ge 0$，矩阵 $A$ 都是对称正定（SPD）的，这是应用共轭梯度法的必要条件。\n\n右端向量 $\\mathbf{b} \\in \\mathbb{R}^n$ 是通过 $A$ 的两个特定特征向量的线性组合构造的。离散拉普拉斯算子（因此也是 $A$）的（未归一化的）特征向量是离散正弦向量 $v_j$，其分量为 $(v_j)_i = \\sin\\left(\\frac{j \\pi i}{n+1}\\right)$。问题指定将 $\\mathbf{b}$ 构造为：\n$$\n\\mathbf{b} = c_1 v_1 + c_2 v_n\n$$\n这种构造激发了系统的最低频率模式（$v_1$）和最高频率模式（$v_n$），它们分别对应于 $A$ 的最小和最大特征值。这是一种研究迭代方法在处理大条件数问题时的收敛行为的标准技术。\n\n### 2. 共轭梯度法与收敛度量\n\n共轭梯度（CG）法是一种用于求解大型稀疏线性系统 $A \\mathbf{x} = \\mathbf{b}$ 的迭代算法，其中 $A$ 是对称正定的。从初始猜测 $\\mathbf{x}_0$ 开始，CG 生成一系列收敛到精确解 $\\mathbf{x}^\\star = A^{-1}\\mathbf{b}$ 的迭代向量 $\\mathbf{x}_k$。\n\nCG 的一个关键性质是，在每次迭代 $k$ 中，迭代向量 $\\mathbf{x}_k$ 在仿射克雷洛夫子空间 $\\mathbf{x}_0 + \\mathcal{K}_k(A, \\mathbf{r}_0)$ 上最小化误差的 $A$-范数 $\\|\\mathbf{e}_k\\|_A$，其中 $\\mathbf{e}_k = \\mathbf{x}_k - \\mathbf{x}^\\star$ 是误差，$\\mathbf{r}_0 = \\mathbf{b} - A\\mathbf{x}_0$ 是初始残差。$A$-范数，或称能量范数，定义为：\n$$\n\\|\\mathbf{e}\\|_A = \\sqrt{\\mathbf{e}^\\top A \\mathbf{e}}\n$$\n由于克雷洛夫子空间是嵌套的（$\\mathcal{K}_k \\subseteq \\mathcal{K}_{k+1}$），这种最小化性质保证了误差的能量范数是单调不增的：\n$$\n\\|\\mathbf{e}_{k+1}\\|_A \\le \\|\\mathbf{e}_k\\|_A\n$$\n在精确计算中，这个不等式是严格的（$\\|\\mathbf{e}_{k+1}\\|_A < \\|\\mathbf{e}_k\\|_A$），除非已经找到了解（$\\mathbf{e}_k = \\mathbf{0}$）。\n\n我们感兴趣的第二个度量是残差的欧几里得范数 $\\|\\mathbf{r}_k\\|_2$，其中 $\\mathbf{r}_k = \\mathbf{b} - A \\mathbf{x}_k$。虽然 $\\|\\mathbf{r}_k\\|_2$ 序列常被用作实际的停止准则，但它并**不**保证是单调的。CG 算法通过短递推关系更新残差，这种方法虽然计算效率高，但可能导致残差范数暂时增加。这种现象在谱条件数较大的问题中最为明显，此时算法试图消除与谱的不同部分相对应的误差分量。从与极值特征值相关的特征向量构造 $\\mathbf{b}$ 的目的正是为了引发这种行为。\n\n### 3. 实现与分析策略\n\n任务的核心是实现 CG 算法并针对特定问题实例跟踪这两种范数。\n\n**步骤1：系统构建**\n对于由 $(n, \\alpha, (c_1, c_2))$ 定义的每个测试用例，我们首先根据提供的公式构建矩阵 $A$ 和向量 $\\mathbf{b}$。\n\n**步骤2：精确解**\n为了计算误差 $\\mathbf{e}_k$ 及其能量范数 $\\|\\mathbf{e}_k\\|_A$，需要精确解 $\\mathbf{x}^\\star$。我们在每个测试用例开始时通过使用直接求解器（例如 `numpy.linalg.solve`）求解 $A \\mathbf{x}^\\star = \\mathbf{b}$ 来计算一次该解。\n\n**步骤3：CG 迭代与数据收集**\n我们实现标准的 CG 算法，从 $\\mathbf{x}_0 = \\mathbf{0}$ 开始。我们迭代足够的步数（例如，$n+1$ 步）以观察收敛行为，并在每次迭代 $k=0, 1, 2, \\dots$ 时记录 $\\|\\mathbf{r}_k\\|_2$ 和 $\\|\\mathbf{e}_k\\|_A$ 的值。\n\n**步骤4：后处理与报告**\n收集范数历史记录后，我们对其进行分析，以确定每个测试用例所需的五个输出：\n1.  **残差非单调性**：我们检查是否存在任何 $k \\ge 1$ 使得 $\\|\\mathbf{r}_k\\|_2 > \\|\\mathbf{r}_{k-1}\\|_2$。\n2.  **能量范数严格递减**：我们验证是否对于所有 $\\|\\mathbf{e}_{k-1}\\|_A$ 不可忽略的 $k \\ge 1$，都有 $\\|\\mathbf{e}_k\\|_A < \\|\\mathbf{e}_{k-1}\\|_A$。在精确计算中，这在收敛前总是成立的。\n3.  **朴素停止条件**：如果残差范数非单调，我们识别出第一次出现增长的迭代次数 $k_{naive}$。然后我们确定满足能量范数容差 $\\|\\mathbf{e}_k\\|_A \\le 10^{-8} \\|\\mathbf{e}_0\\|_A$ 的迭代次数 $k_{\\mathrm{energy}}$。如果 $k_{naive} < k_{\\mathrm{energy}}$，则输出为 `True`，表示基于残差增加的朴素停止规则会过早终止。\n4.  **$k_{\\mathrm{res}}$**：我们找到满足基于残差的停止准则 $\\|\\mathbf{r}_k\\|_2 \\le 10^{-8} \\|\\mathbf{r}_0\\|_2$ 的最小迭代次数 $k$。\n5.  **$k_{\\mathrm{energy}}$**：我们找到满足基于能量的停止准则的最小迭代次数 $k$。\n\n这种系统化的方法将使我们能够严格地展示共轭梯度法指定的收敛特性。对于测试用例3，其中 $\\mathbf{b}$ 是单个特征向量（$c_2=0.0$），我们预计 CG 将在单次迭代中收敛，从而导致范数单调递减，并且不会出现提早停止的情况。", "answer": "```python\nimport numpy as np\n\ndef run_cg_test(n, alpha_const, c_coeffs):\n    \"\"\"\n    Runs a single test case for the Conjugate Gradient method analysis.\n\n    For a given problem configuration (n, alpha, c_coeffs), this function:\n    1. Constructs the problem matrix A and right-hand side b.\n    2. Solves for the exact solution x_star to enable error calculations.\n    3. Implements the Conjugate Gradient algorithm, storing the history of\n       the residual norm and the energy norm of the error.\n    4. Analyzes the norm histories to determine the five required metrics:\n       - Whether the residual norm was non-monotone.\n       - Whether the energy norm was strictly decreasing.\n       - Whether a naive stop based on residual increase would be premature.\n       - The iteration count to meet the residual tolerance (k_res).\n       - The iteration count to meet the energy norm tolerance (k_energy).\n    \n    Returns a tuple of these five results.\n    \"\"\"\n    c1, c2 = c_coeffs\n    h = 1.0 / (n + 1)\n    \n    # Construct the matrix A for the 1D Poisson problem with reaction\n    main_diag = 2.0 * np.ones(n)\n    off_diag = -1.0 * np.ones(n - 1)\n    A = (1.0 / h**2) * (np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1))\n    if alpha_const > 0:\n        A += alpha_const * np.eye(n)\n\n    # Construct the right-hand side vector b from eigenvectors\n    i_vec = np.arange(1, n + 1)\n    v1 = np.sin(np.pi * i_vec / (n + 1))\n    vn = np.sin(n * np.pi * i_vec / (n + 1))\n    b = c1 * v1 + c2 * vn\n\n    # Compute exact solution using a direct solver for error calculation\n    x_star = np.linalg.solve(A, b)\n\n    # CG algorithm initialization\n    x = np.zeros(n)\n    r = b.copy() # Since x_0=0, r_0 = b - A*0 = b\n    p = r.copy()\n    rs_old_sq = r.T @ r\n\n    r0_norm = np.sqrt(rs_old_sq)\n    e0 = x - x_star\n    e0_A_norm = np.sqrt(e0.T @ A @ e0)\n\n    res_norms = []\n    energy_norms = []\n\n    # Run CG for a fixed number of iterations to collect a full history\n    max_iter = n + 1 \n    for k in range(max_iter):\n        # Calculate and store norms for the current iteration k\n        e = x - x_star\n        res_norms.append(np.sqrt(r.T @ r))\n        energy_norms.append(np.sqrt(e.T @ A @ e))\n\n        # Check for convergence to avoid division by zero and unnecessary computation\n        if np.sqrt(rs_old_sq)  1e-16:\n             # Fill remaining norm history if we stopped early\n             for _ in range(k + 1, max_iter):\n                 res_norms.append(res_norms[-1])\n                 energy_norms.append(energy_norms[-1])\n             break\n        \n        # Standard CG step\n        Ap = A @ p\n        alpha_cg = rs_old_sq / (p.T @ Ap)\n        x += alpha_cg * p\n        r -= alpha_cg * Ap\n        rs_new_sq = r.T @ r\n        beta = rs_new_sq / rs_old_sq\n        p = r + beta * p\n        rs_old_sq = rs_new_sq\n\n    # --- Analyze the collected data ---\n    \n    # 1. Check if the residual norm sequence is non-monotone\n    is_res_non_monotone = False\n    naive_stop_iter = -1\n    for k in range(1, len(res_norms)):\n        if res_norms[k] > res_norms[k-1] and res_norms[k-1] > 1e-15:\n            is_res_non_monotone = True\n            if naive_stop_iter == -1: # Record first occurrence\n                naive_stop_iter = k\n    \n    # 2. Check if the energy norm is strictly decreasing\n    is_energy_strictly_decreasing = True\n    for k in range(1, len(energy_norms)):\n        if energy_norms[k-1] > 1e-15: # If previous norm was non-zero\n            if energy_norms[k] >= energy_norms[k-1]:\n                is_energy_strictly_decreasing = False\n                break\n    \n    # 5. Find k_energy: iteration to meet energy norm tolerance\n    tau_energy = 1e-8\n    try:\n        # Use a small tolerance to prevent issues with e0_A_norm being zero\n        if e0_A_norm > 1e-15:\n            k_energy = next(k for k, norm in enumerate(energy_norms) if norm = tau_energy * e0_A_norm)\n        else:\n            k_energy = 0\n    except StopIteration:\n        k_energy = -1 # Sentinel for not converged\n\n    # 3. Check if a naive stop would be premature\n    is_naive_stop_early = False\n    if naive_stop_iter != -1 and (k_energy == -1 or naive_stop_iter  k_energy):\n        is_naive_stop_early = True\n\n    # 4. Find k_res: iteration to meet residual norm tolerance\n    tau_res = 1e-8\n    try:\n        if r0_norm > 1e-15:\n            k_res = next(k for k, norm in enumerate(res_norms) if norm = tau_res * r0_norm)\n        else:\n            k_res = 0\n    except StopIteration:\n        k_res = -1 # Sentinel for not converged\n\n    return is_res_non_monotone, is_energy_strictly_decreasing, is_naive_stop_early, k_res, k_energy\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (50, 0.0, (1.0, 0.3)),\n        (80, 5.0, (1.0, 0.2)),\n        (60, 0.0, (1.0, 0.0)),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        # Unpack n, alpha, and the tuple (c1, c2)\n        n, alpha_const, c_coeffs = params\n        result_tuple = run_cg_test(n, alpha_const, c_coeffs)\n        all_results.append(list(result_tuple))\n    \n    # Format the final output string as specified in the problem statement.\n    # e.g., [[true,true,false,2,2],[...],[...]]\n    item_strs = []\n    for res in all_results:\n        # Convert booleans to lowercase strings \"true\" or \"false\"\n        str_res = [str(r).lower() if isinstance(r, bool) else str(r) for r in res]\n        item_strs.append(f\"[{','.join(str_res)}]\")\n    \n    final_output = f\"[{','.join(item_strs)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3436372"}]}