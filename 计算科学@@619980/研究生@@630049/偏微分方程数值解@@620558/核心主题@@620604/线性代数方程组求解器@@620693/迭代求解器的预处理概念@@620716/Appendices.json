{"hands_on_practices": [{"introduction": "本练习将指导您实现一种最经典的预处理器——不完全Cholesky分解（IC(0)）。您将为泊松方程离散化后得到的拉普拉斯矩阵构建该预处理器，这是理解代数预处理器的基础。通过这个实践 [@problem_id:3434371]，您将掌握处理稀疏矩阵的核心技能，并理解在分解精度和保持稀疏性之间的权衡。此外，通过计算迭代矩阵谱半径，您将学会一种直接评估预处理器质量的理论方法。", "problem": "构造一个程序，针对一个由离散拉普拉斯算子生成的对称正定 (SPD) 稀疏矩阵，构建零填充不完全 Cholesky 分解（记作 IC(0)），并用它来计算预处理误差传播算子的谱半径。推导和算法必须基于基本定义和经过充分检验的事实：\n\n- 从一个具有齐次狄利克雷边界条件的 $N \\times N$ 内部网格上的二维五点离散拉普拉斯算子的定义开始。在每个内部节点上，规范的未缩放五点差分格式会生成一个 SPD 矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其中 $n = N^2$。在该矩阵中，每个内部行对角线元素为 $4$，以及最多四个对应于最近邻居的非对角线元素 $-1$。\n- 使用 SPD 矩阵的 Cholesky 分解定义：对于 SPD 矩阵 $A$，存在一个唯一的具有正对角元的下三角矩阵 $L$，使得 $A = LL^\\top$。不完全 Cholesky 分解 IC(0) 是一种强制 $L$ 的稀疏模式与 $A$ 的严格下三角部分（加上对角线）相匹配的分解，并丢弃超出该模式的填充（fill-in）元素。\n- 定义从 IC(0) 获得的左预条件子 $M = LL^\\top$。预处理算子为 $M^{-1}A$，相应的线性定常误差传播算子为 $E = I - M^{-1}A$，其中 $I$ 是单位矩阵。谱半径为 $\\rho(E) = \\max_i |\\lambda_i(E)|$，其中 $\\lambda_i(E)$ 是 $E$ 的特征值。\n\n你的程序必须：\n\n1. 使用标准的未缩放差分格式，为 $N \\times N$ 内部网格上的二维五点拉普拉斯算子（带齐次狄利克雷边界条件）构造矩阵 $A$。除非指定了置换，否则对网格节点使用字典序。\n2. 构建 IC(0) 预条件子 $M = LL^\\top$，其中 $L$ 的稀疏模式是 $A$ 的下三角部分（包括对角线）。你必须通过强制零填充约束来计算 $L$：仅当 $A_{ij} \\neq 0$ 时才计算每个 $i > j$ 的元素 $L_{ij}$，并且求和仅使用与此稀疏模式一致的索引。\n3. 通过使用 $L$ 和 $L^\\top$ 进行前向和后向三角求解，将 $M^{-1}$ 应用于 $A$ 的每一列，从而计算 $\\rho(I - M^{-1}A)$。\n4. （可选）在计算 IC(0) 之前，将逆 Cuthill–McKee (RCM) 置换（用向量 $p$ 表示置换，用 $P$ 表示置换矩阵）应用于 $A$，形式为 $A_p = P^\\top A P$。当应用置换时，所有计算，包括 IC(0) 和谱半径，都必须在置换后的系统 $A_p$ 上执行。\n\n不涉及物理单位或角度。所有数值答案必须以浮点值的形式返回。你的程序的最终输出必须是单行，包含一个 Python 列表，其中按下方测试套件的顺序列出浮点谱半径，每个谱半径四舍五入到八位小数。\n\n测试套件：\n- 案例 1：$N = 5$，无重排。\n- 案例 2：$N = 3$，无重排。\n- 案例 3：$N = 5$，在构造 IC(0) 之前对 $A$ 应用逆 Cuthill–McKee 重排。\n- 案例 4：$N = 1$，无重排。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。例如，如果有两个结果 $r_1$ 和 $r_2$，程序将精确打印 \"[r_1,r_2]\"。对于本问题，请打印 \"[r_1,r_2,r_3,r_4]\"，其中 $r_k$ 是案例 $k$ 的谱半径，每个都格式化为小数点后八位。", "solution": "该问题要求为一个代表二维离散拉普拉斯算子的矩阵，构造并分析零填充不完全 Cholesky 分解，记作 IC(0)。目标是针对几种网格配置，计算与 IC(0) 预条件子相关的误差传播算子的谱半径。\n\n解决方案主要分为四个步骤：\n1.  构造离散拉普拉斯矩阵 $A$。\n2.  使用逆 Cuthill–McKee (RCM) 算法对 $A$ 进行可选的重排。\n3.  计算 IC(0) 因子 $L$。\n4.  计算迭代矩阵 $E = I - M^{-1}A$ 的谱半径，其中 $M = LL^\\top$。\n\n### 1. 矩阵构造\n问题设置在一个 $N \\times N$ 的内部节点网格上。我们使用从零开始的字典序，其中网格坐标为 $(i, j)$（$0 \\le i, j  N$）的节点被映射到单个索引 $k = iN + j$。这将产生一个大小为 $n \\times n$ 的方阵 $A$，其中 $n = N^2$。\n\n矩阵 $A$ 源自拉普拉斯算子 $-\\Delta u$ 的规范五点差分格式。在每个内部节点 $k$（对应于网格点 $(i, j)$），离散方程为：\n$$4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} = f_{i,j}$$\n齐次狄利克雷边界条件意味着任何边界上的点 $(x,y)$ 的项 $u_{x,y}$ 均为零。这种结构转化为矩阵 $A$：\n-   对角元为 $A_{kk} = 4$。\n-   如果节点 $l$ 是网格上节点 $k$ 的直接北、南、东或西邻居，则非对角元 $A_{kl}$ 为 $-1$。否则，对于 $k \\neq l$，$A_{kl} = 0$。\n\n得到的矩阵 $A$ 是稀疏、对称且正定 (SPD) 的。它具有块三对角结构。\n\n### 2. 逆 Cuthill–McKee (RCM) 重排\n对于某些测试案例，矩阵 $A$ 会被重排以减小其带宽和轮廓。逆 Cuthill–McKee 算法找到一个置换向量 $p$，当应用于矩阵时，它倾向于将非零元素集中在对角线附近。置换后的矩阵由 $A_p = P^\\top A P$ 给出，其中 $P$ 是对应于 $p$ 的置换矩阵。所有后续计算，包括 IC(0) 和谱半径计算，都在置换后的矩阵 $A_p$ 上执行。\n\n### 3. 不完全 Cholesky 分解 (IC(0))\n对于任何 SPD 矩阵 $A$，标准的 Cholesky 分解能找到一个唯一的具有正对角元的下三角矩阵 $L$，使得 $A = LL^\\top$。$L$ 的元素通过以下递推关系计算：\n$$ L_{jj} = \\sqrt{A_{jj} - \\sum_{k=0}^{j-1} L_{jk}^2} $$\n$$ L_{ij} = \\frac{1}{L_{jj}} \\left( A_{ij} - \\sum_{k=0}^{j-1} L_{ik}L_{jk} \\right) \\quad \\text{for } i > j $$\n这个过程通常会引入“填充”（fill-in），即即使 $A_{ij}$ 为零，$L_{ij}$ 也可能非零。\n\nIC(0) 分解通过施加稀疏性约束来防止这种情况：$L$ 的稀疏模式必须是 $A$ 的稀疏模式的子集。具体来说，我们计算一个近似因子 $\\tilde{L}$，使得当 $i > j$ 且 $A_{ij} = 0$ 时，有 $\\tilde{L}_{ij} = 0$。算法修改如下：\n令 $S = \\{(i,j) \\mid i>j, A_{ij} \\neq 0\\}$ 为对应于 $A$ 的严格下三角非零元素的索引对集合。\n$$ \\tilde{L}_{jj} = \\sqrt{A_{jj} - \\sum_{k=0, (j,k) \\in S}^{j-1} \\tilde{L}_{jk}^2} $$\n$$ \\tilde{L}_{ij} = \\frac{1}{\\tilde{L}_{jj}} \\left( A_{ij} - \\sum_{k=0, (i,k) \\in S, (j,k) \\in S}^{j-1} \\tilde{L}_{ik}\\tilde{L}_{jk} \\right) \\quad \\text{for } (i,j) \\in S $$\n这个过程通过迭代矩阵的行和列，并仅对存在于 $A$ 稀疏模式中的索引应用这些公式来实现。对于一个 SPD 矩阵 $A$，通过此算法进行的 IC(0) 分解保证存在，并能产生一个具有正对角元的下三角矩阵 $\\tilde{L}$。此后，我们将 $\\tilde{L}$ 记为 $L$。\n\n### 4. 谱半径计算\nIC(0) 分解提供了一个预条件子 $M = LL^\\top$。我们关心的是定常迭代矩阵 $E = I - M^{-1}A$ 的谱特性。谱半径 $\\rho(E)$ 控制着预处理 Richardson 迭代的收敛速度。\n$$ \\rho(E) = \\max_i |\\lambda_i(E)| $$\n其中 $\\lambda_i(E)$ 是 $E$ 的特征值。\n\n为了计算 $\\rho(E)$，我们首先构造稠密矩阵 $E$，然后求其特征值。$E$ 的第 $j$ 列，记为 $e_j - (M^{-1}A)_j$，是通过首先计算向量 $y_j = M^{-1}a_j$ 来得到的，其中 $a_j$ 是 $A$ 的第 $j$ 列。$y_j$ 的计算是通过求解方程组 $My_j = a_j$ 或 $LL^\\top y_j = a_j$ 来完成的。这可以通过使用前向和后向代入法高效完成，而无需对 $L$ 求逆：\n1.  **前向求解：** 求解 $Lz_j = a_j$ 得到 $z_j$。\n2.  **后向求解：** 求解 $L^\\top y_j = z_j$ 得到 $y_j$。\n\n对每一列 $j = 0, \\dots, n-1$ 重复此过程，以构造矩阵 $M^{-1}A$ 的所有列。然后形成矩阵 $E$，并使用标准的数值库例程计算其特征值。谱半径是这些特征值绝对值的最大值。\n\n特殊情况：对于 $N=1$ 的情况，网格只有一个内部点。矩阵 $A$ 是 $1 \\times 1$ 的矩阵 $[4]$。IC(0) 因子是 $L = [\\sqrt{4}] = [2]$。预条件子是 $M=LL^\\top = [4]$。因此，$M=A$，误差传播矩阵是 $E = I - M^{-1}A = I - A^{-1}A = I - I = [0]$。它唯一的特征值是 $0$，所以谱半径为 $\\rho(E) = 0$。", "answer": "```python\nimport numpy as np\nimport scipy.sparse\nfrom scipy.sparse.csgraph import reverse_cuthill_mckee\nfrom scipy.sparse.linalg import spsolve_triangular\n\ndef construct_laplacian(N):\n    \"\"\"\n    Constructs the 2D discrete Laplacian matrix A for an N x N grid.\n    Uses a 5-point stencil with homogeneous Dirichlet boundary conditions.\n    \"\"\"\n    if N == 0:\n        return scipy.sparse.csr_matrix((0, 0))\n    n = N * N\n    \n    # Use DOK format for easy construction of the sparse matrix\n    A = scipy.sparse.dok_matrix((n, n), dtype=np.float64)\n\n    for i in range(N):\n        for j in range(N):\n            k = i * N + j\n            A[k, k] = 4.0\n            # West neighbor\n            if j > 0:\n                A[k, k - 1] = -1.0\n            # East neighbor\n            if j  N - 1:\n                A[k, k + 1] = -1.0\n            # North neighbor\n            if i > 0:\n                A[k, k - N] = -1.0\n            # South neighbor\n            if i  N - 1:\n                A[k, k + N] = -1.0\n                \n    return A.tocsr()\n\ndef ic0(A_csr):\n    \"\"\"\n    Computes the Incomplete Cholesky factorization with zero fill-in (IC(0)).\n    Input A must be a symmetric positive definite sparse matrix in CSR format.\n    Returns the lower triangular factor L in CSR format.\n    \"\"\"\n    n = A_csr.shape[0]\n    # LIL format is efficient for incremental construction\n    L = scipy.sparse.lil_matrix((n, n), dtype=np.float64)\n    A_dok = A_csr.todok()\n\n    for i in range(n):\n        # Compute off-diagonal entries L[i,j] for j  i\n        # The sparsity pattern of L is the same as the lower triangle of A\n        # We can iterate through relevant column indices from A\n        row_indices = sorted([c for r, c in A_dok.keys() if r == i and c  i])\n\n        for j in row_indices:\n            s = 0.0\n            # Sum over common predecessors: sum(L[i,k] * L[j,k] for k  j)\n            # L.rows[i] gives a list of column indices of non-zero elements in row i\n            L_i_cols = L.rows[i]\n            L_j_cols = L.rows[j]\n            \n            # This can be slow, but is fine for the small matrices in this problem\n            common_cols = set(L_i_cols).intersection(L_j_cols)\n            for k in common_cols:\n                if k  j:\n                    s += L[i,k] * L[j,k]\n            \n            L[i,j] = (A_dok[i,j] - s) / L[j,j]\n\n        # Compute diagonal entry L[i,i]\n        s_diag = 0.0\n        # Sum squares of L[i,j] for j  i which are now computed\n        for j in L.rows[i]:\n             if j  i:\n                s_diag += L[i,j]**2\n\n        diag_val = A_dok[i,i] - s_diag\n        if diag_val = 0:\n            raise ValueError(f\"Matrix is not positive-definite enough for IC(0) at index {i}.\")\n        L[i,i] = np.sqrt(diag_val)\n\n    return L.tocsr()\n\ndef calculate_spectral_radius(A, L):\n    \"\"\"\n    Calculates the spectral radius of the error propagation matrix E = I - (LL^T)^-1 * A.\n    \"\"\"\n    n = A.shape[0]\n    if n == 0:\n        return 0.0\n\n    # The case N=1 is trivial and could be handled separately, but the general\n    # code works as well. A=[[4]], L=[[2]], M=A, M_inv_A=I, E=0, rho=0.\n    \n    L_T = L.transpose().tocsr()\n    \n    # Build the matrix E = I - M_inv_A\n    M_inv_A = np.zeros((n, n), dtype=np.float64)\n    \n    for j in range(n):\n        a_j = A[:, j].toarray()\n        \n        # Solve M * y_j = a_j => LL^T * y_j = a_j\n        # 1. Forward solve: L * z_j = a_j\n        z_j = spsolve_triangular(L, a_j, lower=True)\n        # 2. Backward solve: L^T * y_j = z_j\n        y_j = spsolve_triangular(L_T, z_j, lower=False) # upper triangular system\n        \n        M_inv_A[:, j] = y_j.flatten()\n\n    E = np.identity(n) - M_inv_A\n    eigenvalues = np.linalg.eigvals(E)\n    spectral_radius = np.max(np.abs(eigenvalues))\n    \n    return spectral_radius\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (5, False),  # Case 1\n        (3, False),  # Case 2\n        (5, True),   # Case 3\n        (1, False),  # Case 4\n    ]\n\n    results = []\n    for N, use_rcm in test_cases:\n        A = construct_laplacian(N)\n        \n        # Apply RCM permutation if specified\n        if use_rcm:\n            # RCM for a 1x1 matrix is trivial, but scipy handles it\n            if A.shape[0] > 0:\n                perm = reverse_cuthill_mckee(A, symmetric_mode=False)\n                A = A[perm, :][:, perm]\n        \n        L = ic0(A)\n        \n        rho = calculate_spectral_radius(A, L)\n        \n        results.append(f\"{rho:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3434371"}, {"introduction": "在解决了标量问题之后，我们将进入更复杂的多物理场问题。像不可压缩斯托克斯方程这样的系统，其离散化后会产生具有“鞍点”结构的线性系统，这需要更精密的块结构预处理器。本练习 [@problem_id:3434325] 旨在探索这类预处理器的设计，特别是围绕如何近似舒尔补（Schur complement）这一核心环节。掌握舒尔补近似是现代计算流体力学求解器设计的关键一步。", "problem": "考虑在单位正方形上使用 Marker-And-Cell (MAC) 网格离散的稳态二维不可压缩斯托克斯方程，速度采用齐次狄利克雷边界条件，压力为零均值。设得到的离散线性代数系统为鞍点矩阵 $$A = \\begin{pmatrix} K  B^{\\top} \\\\ B  0 \\end{pmatrix},$$ 其中 $K \\in \\mathbb{R}^{n_u \\times n_u}$ 是速度的对称正定离散向量拉普拉斯算子，$B \\in \\mathbb{R}^{n_p \\times n_u}$ 是将速度自由度映射到压力自由度的离散散度算子，$0$ 分块对应于不可压缩性约束。压力分块的舒尔补为 $$S = B K^{-1} B^{\\top}。$$\n\n一个分块三角预条件子定义为 $$M = \\begin{pmatrix} \\hat{K}  0 \\\\ B  -\\hat{S} \\end{pmatrix},$$ 其中 $\\hat{K}$ 和 $\\hat{S}$ 分别是 $K$ 和 $S$ 的计算上更廉价的近似。预处理后的矩阵则为 $$M^{-1} A。$$\n\n您的任务是实现一个独立的程序，该程序：\n- 对于给定的压力单元数 $N_x \\times N_y$，以及均匀网格间距 $h_x = 1/N_x$ 和 $h_y = 1/N_y$、粘度 $\\mu  0$、速度的齐次狄利克雷边界条件以及通过移除单个压力自由度强制实现的零均值压力，构建离散 MAC 网格斯托克斯矩阵 $K$ 和 $B$。\n- 使用对 $K$ 的直接求解形成精确舒尔补 $S = B K^{-1} B^{\\top}$。\n- 使用指定的 $\\hat{K}$ 和 $\\hat{S}$ 选项构建分块三角预条件子 $M$，可供比较的选项有：\n  - 对于 $\\hat{K}$：使用精确的 $K$ 或雅可比近似 $\\operatorname{diag}(K)$。\n  - 对于 $\\hat{S}$：使用精确的 $S$、其对角线 $\\operatorname{diag}(S)$ 或各向同性缩放 $\\alpha I$，其中 $\\alpha = \\frac{1}{n_p} \\sum_{i=1}^{n_p} S_{ii}$。\n- 通过将 $M^{-1}$ 应用于 $A$ 的各列，或使用关于 $K$、$B$、$\\hat{K}^{-1}$ 和 $\\hat{S}^{-1}$ 的分块代数，形成 $M^{-1} A$ 的稠密矩阵表示。\n- 计算 $M^{-1} A$ 的全谱（所有特征值），并为每个测试用例报告两个量：\n  1. 特征值与 $1$ 的最大绝对偏差，定义为 $\\max_i \\lvert \\lambda_i - 1 \\rvert$，其中 $\\{\\lambda_i\\}$ 是 $M^{-1} A$ 的特征值。\n  2. 一个布尔值，指示所有特征值是否满足 $\\lvert \\lambda_i - 1 \\rvert \\leq 10^{-8}$。\n\n从基本原理出发：定义 MAC 网格未知量、具有齐次狄利克雷边界条件的离散向量拉普拉斯算子以及离散散度。解释舒尔补是如何通过分块消元产生的，以及为什么分块三角预条件子是一个自然的选择。推导当使用精确舒尔补和精确速度分块时 $M^{-1} A$ 的结构，并以此来推断使用近似选项时谱在 $1$ 附近的预期聚类情况。\n\n待遵循的实现细节：\n- 设压力自由度为 $N_x N_y$ 个单元中心，移除一个自由度以强制实现零均值压力。\n- 设水平速度自由度为内部垂直面（索引 $i=1,\\dots,N_x-1$, $j=1,\\dots,N_y$），垂直速度自由度为内部水平面（索引 $i=1,\\dots,N_x$, $j=1,\\dots,N_y-1$）。离散向量拉普拉斯算子 $K$ 是分块对角矩阵，在这两个速度网格上具有五点模板，并按粘度 $\\mu$ 缩放。\n- 离散散度 $B$ 通过有限差分作用于速度：对于每个压力单元 $(i,j)$，$$\\left(B \\begin{bmatrix} \\mathbf{u} \\\\ \\mathbf{v} \\end{bmatrix}\\right)_{ij} = \\frac{u_{i,j} - u_{i-1,j}}{h_x} + \\frac{v_{i,j} - v_{i,j-1}}{h_y},$$ 其中落在物理边界上的索引对应于零狄利克雷速度值，并从未知量中省略。\n\n测试套件和输出规范：\n- 使用以下五个测试用例，通过 $M^{-1} A$ 的谱来比较 $\\hat{K}$ 和 $\\hat{S}$ 的选择：\n  1. $N_x = 3$, $N_y = 3$, $\\mu = 1.0$, $\\hat{K} = K$, $\\hat{S} = S$。\n  2. $N_x = 3$, $N_y = 3$, $\\mu = 1.0$, $\\hat{K} = \\operatorname{diag}(K)$, $\\hat{S} = S$。\n  3. $N_x = 5$, $N_y = 4$, $\\mu = 1.0$, $\\hat{K} = K$, $\\hat{S} = \\operatorname{diag}(S)$。\n  4. $N_x = 5$, $N_y = 4$, $\\mu = 1.0$, $\\hat{K} = \\operatorname{diag}(K)$, $\\hat{S} = \\alpha I$，其中 $\\alpha$ 等于 $S$ 对角线元素的均值。\n  5. $N_x = 4$, $N_y = 4$, $\\mu = 0.1$, $\\hat{K} = K$, $\\hat{S} = \\operatorname{diag}(S)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个 $[\\text{max\\_dev}, \\text{all\\_close}]$ 形式的列表。例如，输出应类似于 $[[0.0,\\text{True}],[0.1234,\\text{False}],\\dots]$。由于输出是无量纲的谱量，因此不需要物理单位。角度单位不适用。百分比不适用。", "solution": "该问题要求对离散不可压缩斯托克斯方程的分块三角预条件子进行分析。我们首先验证问题陈述，然后进行详细的理论推导和实现策略。\n\n### 问题验证\n\n根据指定的验证标准对问题进行评估。\n\n**1. 提取的已知条件：**\n- **方程：** 单位正方形上的稳态二维不可压缩斯托克斯方程。\n- **离散化：** 具有均匀间距 $h_x = 1/N_x$ 和 $h_y = 1/N_y$ 的 Marker-And-Cell (MAC) 网格。\n- **边界条件：** 速度的齐次狄利克雷边界条件。\n- **压力约束：** 零均值压力，通过移除一个压力自由度来强制实现。\n- **代数系统：** 一个鞍点矩阵 $A = \\begin{pmatrix} K  B^{\\top} \\\\ B  0 \\end{pmatrix}$，其中 $K$ 是对称正定离散向量拉普拉斯算子，$B$ 是离散散度算子。\n- **舒尔补：** $S = B K^{-1} B^{\\top}$。\n- **预条件子：** 一个分块三角矩阵 $M = \\begin{pmatrix} \\hat{K}  0 \\\\ B  -\\hat{S} \\end{pmatrix}$，其中 $\\hat{K}$ 和 $\\hat{S}$ 是 $K$ 和 $S$ 的近似。\n- **未知量配置：**\n    - 压力 ($p$)：$N_x N_y$ 个单元中心，移除一个自由度 (DOF)（$n_p = N_x N_y - 1$）。\n    - 水平速度 ($u$)：内部垂直面，$n_{u,x} = (N_x-1)N_y$ 个自由度。\n    - 垂直速度 ($v$)：内部水平面，$n_{u,y} = N_x(N_y-1)$ 个自由度。\n    - 总速度自由度：$n_u = n_{u,x} + n_{u,y}$。\n- **算子定义：**\n    - $K$：由 $u$ 和 $v$ 网格上的五点模板构成的分块对角矩阵，按粘度 $\\mu  0$ 缩放。\n    - $B$：由有限差分公式 $\\left(B [\\mathbf{u};\\mathbf{v}]\\right)_{ij} = \\frac{u_{i,j} - u_{i-1,j}}{h_x} + \\frac{v_{i,j} - v_{i,j-1}}{h_y}$ 定义。\n- **近似选择：**\n    - $\\hat{K}$：精确分块 $K$ 或其对角线 $\\operatorname{diag}(K)$。\n    - $\\hat{S}$：精确舒尔补 $S$、其对角线 $\\operatorname{diag}(S)$ 或各向同性缩放 $\\alpha I$，其中 $\\alpha$ 是 $S$ 对角线元素的均值。\n- **任务：** 对于几个测试用例，构建矩阵，形成预处理矩阵 $M^{-1} A$，计算其谱 $\\{\\lambda_i\\}$，并报告 $\\max_i \\lvert \\lambda_i - 1 \\rvert$ 以及所有特征值是否满足 $\\lvert \\lambda_i - 1 \\rvert \\leq 10^{-8}$。\n\n**2. 验证结论：**\n- 该问题具有**科学依据**，涉及数值分析和计算流体动力学中的标准、成熟的方法。\n- 它是**适定的**，为构建矩阵和执行分析提供了清晰而完整的规范。测试用例的规模在计算上是可行的。通过移除一个自由度来强制实现零均值压力约束是确保压力相关算子可逆性的标准技术。\n- 它是**客观的**，用精确的数学和算法语言陈述。\n- 设置在内部是**一致和完整的**。所有必要的参数和定义都已提供。\n\n该问题被判定为**有效**。我们继续进行求解。\n\n### 基于原理的解决方案\n\n稳态不可压缩斯托克斯方程用于模拟缓慢的粘性流体流动，其形式如下：\n$$ -\\mu \\Delta \\mathbf{u} + \\nabla p = \\mathbf{f} $$\n$$ \\nabla \\cdot \\mathbf{u} = 0 $$\n其中 $\\mathbf{u}$ 是速度， $p$ 是压力， $\\mu$ 是动力粘度， $\\mathbf{f}$ 是体积力（此处假设为零）。\n\n**1. 在 MAC 网格上进行离散化**\n离散化采用交错网格（MAC 网格）。在单位正方形 $[0,1] \\times [0,1]$ 上的 $N_x \\times N_y$ 单元网格上：\n- 压力 $p_{i,j}$ 定义在单元中心 $((i-1/2)h_x, (j-1/2)h_y)$，对于 $i=1,\\dots,N_x, j=1,\\dots,N_y$。\n- 水平速度 $u_{i,j}$ 定义在垂直面 $(ih_x, (j-1/2)h_y)$，对于 $i=1,\\dots,N_x-1, j=1,\\dots,N_y$。\n- 垂直速度 $v_{i,j}$ 定义在水平面 $((i-1/2)h_x, jh_y)$，对于 $i=1,\\dots,N_x, j=1,\\dots,N_y-1$。\n\n施加齐次狄利克雷边界条件 $\\mathbf{u}|_{\\partial\\Omega} = \\mathbf{0}$。在*内部*面上选择自由度，自然地在垂直边界上施加了 $u=0$，在水平边界上施加了 $v=0$。在水平边界上 $u=0$ 和在垂直边界上 $v=0$ 的条件被整合到离散算子中。\n\n得到的离散系统是一个鞍点线性系统 $A \\begin{pmatrix} \\mathbf{x_u} \\\\ \\mathbf{x_p} \\end{pmatrix} = \\begin{pmatrix} \\mathbf{f_d} \\\\ \\mathbf{0} \\end{pmatrix}$，其中 $\\mathbf{x_u}$ 和 $\\mathbf{x_p}$ 分别是速度和压力自由度的向量。系统矩阵为 $A = \\begin{pmatrix} K  B^{\\top} \\\\ B  0 \\end{pmatrix}$。\n\n**2. 离散算子的构建**\n\n- **离散向量拉普拉斯算子 $K$**：矩阵 $K$ 表示负向量拉普拉斯算子 $-\\mu\\Delta$ 对速度向量的作用。它是一个分块对角矩阵：$K = \\mu \\begin{pmatrix} K_u  0 \\\\ 0  K_v \\end{pmatrix}$。\n  - $K_u$ 是大小为 $(N_x-1) \\times N_y$ 的 $u$-速度网格的离散拉普拉斯算子。\n  - $K_v$ 是大小为 $N_x \\times (N_y-1)$ 的 $v$-速度网格的离散拉普拉斯算子。\n  对于大小为 $M \\times N$ 且具有齐次狄利克雷边界条件的笛卡尔网格，使用标准的中心有限差分五点模板来表示负拉普拉斯算子，其离散算子可以通过克罗内克积构建：$L_{M \\times N} = I_N \\otimes \\frac{1}{h_x^2} L_M + \\frac{1}{h_y^2} L_N \\otimes I_M$，其中 $L_k$ 是 $k \\times k$ 的一维拉普拉斯矩阵 $[2, -1, \\dots, -1]$。\n  - $K_u = \\mu(I_{N_y} \\otimes \\frac{1}{h_x^2}L_{N_x-1} + \\frac{1}{h_y^2} L_{N_y} \\otimes I_{N_x-1})$\n  - $K_v = \\mu(\\frac{1}{h_x^2}L_{N_x} \\otimes I_{N_y-1} + I_{N_x} \\otimes \\frac{1}{h_y^2}L_{N_y-1})$\n  这种构造确保 $K$ 是对称正定的（SPD）。\n\n- **离散散度 $B$**：矩阵 $B$ 表示散度算子，将速度向量映射到以单元为中心的压力网格。$B$ 中对应于压力单元 $(i,j)$ 的行由以下公式构建：\n  $$ (\\nabla \\cdot \\mathbf{u})_{i,j} \\approx \\frac{u_{i,j} - u_{i-1,j}}{h_x} + \\frac{v_{i,j} - v_{i,j-1}}{h_y} $$\n  索引落在物理边界 $\\partial\\Omega$ 上的速度项为零并被省略。\n  压力仅在相差一个常数的情况下确定，这表现为 $B^\\top$ 的一个零向量（常数向量）。为了获得唯一的压力解，需要一个约束，如零均值压力。这通过移除一个压力自由度（例如，最后一个）来实现，这对应于从 $B$ 中移除一行，从 $B^\\top$ 中移除一列。得到的 $B$ 有 $n_p = N_x N_y - 1$ 行。\n\n**3. 分块预处理**\n\n由于其鞍点结构，直接求解以 $A$ 为系数的系统是具有挑战性的。分块消元会产生舒尔补 $S = B K^{-1} B^\\top$，它是对称正定且稠密的。求解该系统可以重构为：\n1. 求解 $S \\mathbf{x_p} = B K^{-1} \\mathbf{f_d}$。\n2. 求解 $K \\mathbf{x_u} = \\mathbf{f_d} - B^\\top \\mathbf{x_p}$。\n\n主要的计算成本在于处理 $K^{-1}$。预处理旨在用一个更廉价的操作来替代这个昂贵的操作。分块三角预条件子 $M = \\begin{pmatrix} \\hat{K}  0 \\\\ B  -\\hat{S} \\end{pmatrix}$ 的动机来自于对 $A$ 的近似分块 LU 分解：\n$$ A = \\begin{pmatrix} K  B^\\top \\\\ B  0 \\end{pmatrix} = \\begin{pmatrix} I  0 \\\\ B K^{-1}  I \\end{pmatrix} \\begin{pmatrix} K  B^\\top \\\\ 0  -S \\end{pmatrix} $$\n$M$ 通过用 $\\hat{K}$ 替换 $K$ 和用 $\\hat{S}$ 替换 $S$ 来近似这个分解。$M$ 的逆容易计算：\n$$ M^{-1} = \\begin{pmatrix} \\hat{K}^{-1}  0 \\\\ \\hat{S}^{-1} B \\hat{K}^{-1}  -\\hat{S}^{-1} \\end{pmatrix} $$\n预处理后的矩阵是 $M^{-1} A$：\n$$ M^{-1}A = \\begin{pmatrix} \\hat{K}^{-1} K  \\hat{K}^{-1} B^\\top \\\\ \\hat{S}^{-1} B (\\hat{K}^{-1} K - I)  \\hat{S}^{-1} B \\hat{K}^{-1} B^\\top \\end{pmatrix} $$\n\n**4. 预处理矩阵的谱分析**\n\n预条件子的有效性由预处理矩阵 $M^{-1}A$ 的谱特性决定。一个理想的预条件子会使 $M^{-1}A = I$，其特征值全部为 $1$。\n\n- **理想情况：** 如果我们选择 $\\hat{K} = K$ 和 $\\hat{S} = S = B K^{-1} B^\\top$，预处理矩阵简化为：\n$$ M^{-1}A = \\begin{pmatrix} I  K^{-1} B^\\top \\\\ S^{-1} B (I - I)  S^{-1} (B K^{-1} B^\\top) \\end{pmatrix} = \\begin{pmatrix} I  K^{-1} B^\\top \\\\ 0  I \\end{pmatrix} $$\n这是一个上三角矩阵，所有对角线元素都等于 $1$。因此，它的所有特征值都为 $1$。像 GMRES 这样的迭代求解器将在一次迭代中收敛（在精确算术中）。\n\n- **近似情况：** 当 $\\hat{K}$ 和 $\\hat{S}$ 是近似时，$M^{-1}A$ 的特征值将偏离 $1$。\n  - 如果 $\\hat{K} = K$ 但 $\\hat{S} \\approx S$（例如 $\\hat{S} = \\operatorname{diag}(S)$），矩阵变为 $\\begin{pmatrix} I  K^{-1} B^\\top \\\\ 0  \\hat{S}^{-1} S \\end{pmatrix}$。特征值为 $1$（来自速度分块）和 $\\hat{S}^{-1}S$ 的特征值（来自压力分块）。谱在 $1$ 附近的聚类情况取决于 $\\hat{S}$ 近似 $S$ 的程度。\n  - 如果 $\\hat{K} \\approx K$（例如 $\\hat{K} = \\operatorname{diag}(K)$），$(2,1)$ 分块 $\\hat{S}^{-1} B (\\hat{K}^{-1} K - I)$ 变为非零，特征值会更复杂。与 $1$ 的偏差将取决于两种近似的误差，即 $\\hat{K}^{-1}K$ 和 $\\hat{S}^{-1}(B \\hat{K}^{-1} B^\\top)$ 与单位矩阵的接近程度。\n\n任务是为给定的测试用例计算这些谱，并量化与理想值 $1$ 的偏差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import block_diag\n\ndef laplacian_1d(n):\n    \"\"\"Constructs a 1D Laplacian matrix of size n x n with Dirichlet boundary conditions.\"\"\"\n    L = 2 * np.eye(n)\n    if n > 1:\n        L += -1 * np.eye(n, k=1)\n        L += -1 * np.eye(n, k=-1)\n    return L\n\ndef build_stokes_matrices(Nx, Ny, mu):\n    \"\"\"\n    Constructs the discrete Stokes matrices K and B for a given MAC grid.\n    \"\"\"\n    hx = 1.0 / Nx\n    hy = 1.0 / Ny\n\n    # --- Velocity DOFs ---\n    n_ux = (Nx - 1) * Ny\n    n_uy = Nx * (Ny - 1)\n    n_u = n_ux + n_uy\n\n    # --- Construct K matrix (discrete vector Laplacian) ---\n    # K_u for horizontal velocities\n    Lx_u = laplacian_1d(Nx - 1) / (hx * hx)\n    Ly_u = laplacian_1d(Ny) / (hy * hy)\n    Ku = mu * (np.kron(np.eye(Ny), Lx_u) + np.kron(Ly_u, np.eye(Nx - 1)))\n    \n    # K_v for vertical velocities\n    Lx_v = laplacian_1d(Nx) / (hx * hx)\n    Ly_v = laplacian_1d(Ny - 1) / (hy * hy)\n    Kv = mu * (np.kron(np.eye(Ny - 1), Lx_v) + np.kron(Ly_v, np.eye(Nx)))\n\n    K = block_diag(Ku, Kv)\n\n    # --- Construct B matrix (discrete divergence) ---\n    n_p_full = Nx * Ny\n    B_full = np.zeros((n_p_full, n_u))\n\n    # Mapping from 2D grid indices to 1D vector indices\n    u_idx = lambda i, j: (j - 1) * (Nx - 1) + (i - 1)\n    v_idx = lambda i, j: (j - 1) * Nx + (i - 1)\n    \n    for j_p in range(1, Ny + 1):\n        for i_p in range(1, Nx + 1):\n            p_row_idx = (j_p - 1) * Nx + (i_p - 1)\n\n            # Contribution from (u_{i,j} - u_{i-1,j}) / hx\n            if i_p = Nx - 1:  # u(i_p, j_p) is a DOF\n                col_idx = u_idx(i_p, j_p)\n                B_full[p_row_idx, col_idx] = 1.0 / hx\n            if i_p >= 2:  # u(i_p-1, j_p) is a DOF\n                col_idx = u_idx(i_p - 1, j_p)\n                B_full[p_row_idx, col_idx] = -1.0 / hx\n\n            # Contribution from (v_{i,j} - v_{i,j-1}) / hy\n            v_col_offset = n_ux\n            if j_p = Ny - 1:  # v(i_p, j_p) is a DOF\n                col_idx = v_col_offset + v_idx(i_p, j_p)\n                B_full[p_row_idx, col_idx] = 1.0 / hy\n            if j_p >= 2:  # v(i_p, j_p-1) is a DOF\n                col_idx = v_col_offset + v_idx(i_p, j_p - 1)\n                B_full[p_row_idx, col_idx] = -1.0 / hy\n    \n    # Enforce mean-zero pressure by removing one pressure DOF\n    B = B_full[:-1, :]\n    n_p = n_p_full - 1\n    \n    return K, B, n_u, n_p\n\ndef run_case(Nx, Ny, mu, Khat_choice, Shat_choice):\n    \"\"\"\n    Runs a single test case for the block preconditioner analysis.\n    \"\"\"\n    # 1. Build discrete operators\n    K, B, n_u, n_p = build_stokes_matrices(Nx, Ny, mu)\n    \n    # 2. Form the full saddle-point matrix A\n    A = np.block([\n        [K, B.T],\n        [B, np.zeros((n_p, n_p))]\n    ])\n\n    # 3. Form exact Schur complement S\n    K_inv = np.linalg.inv(K)\n    S = B @ K_inv @ B.T\n    \n    # 4. Construct approximation Khat\n    if Khat_choice == 'exact':\n        Khat = K\n    elif Khat_choice == 'diag':\n        Khat = np.diag(np.diag(K))\n    else:\n        raise ValueError(f\"Unknown Khat_choice: {Khat_choice}\")\n\n    # 5. Construct approximation Shat\n    if Shat_choice == 'exact':\n        Shat = S\n    elif Shat_choice == 'diag':\n        Shat = np.diag(np.diag(S))\n    elif Shat_choice == 'alpha_I':\n        # Need to handle case where S is 1x1 or empty\n        if S.shape[0] > 0:\n            alpha = np.mean(np.diag(S))\n        else:\n            alpha = 1.0\n        Shat = alpha * np.eye(n_p)\n    else:\n        raise ValueError(f\"Unknown Shat_choice: {Shat_choice}\")\n\n    # 6. Construct inverse of preconditioner M\n    Khat_inv = np.linalg.inv(Khat)\n    Shat_inv = np.linalg.inv(Shat) if n_p > 0 else np.array([[]])\n    \n    M_inv_top = np.hstack([Khat_inv, np.zeros((n_u, n_p))])\n    if n_p > 0:\n        M_inv_bot = np.hstack([Shat_inv @ B @ Khat_inv, -Shat_inv])\n        M_inv = np.vstack([M_inv_top, M_inv_bot])\n    else:\n        M_inv = M_inv_top\n\n    # 7. Form preconditioned matrix and find eigenvalues\n    preconditioned_A = M_inv @ A\n    eigvals = np.linalg.eigvals(preconditioned_A)\n    \n    # 8. Compute metrics\n    max_dev = np.max(np.abs(eigvals - 1.0))\n    all_close = bool(max_dev = 1e-8)\n    \n    return [max_dev, all_close]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the formatted results.\n    \"\"\"\n    test_cases = [\n        (3, 3, 1.0, 'exact', 'exact'),\n        (3, 3, 1.0, 'diag', 'exact'),\n        (5, 4, 1.0, 'exact', 'diag'),\n        (5, 4, 1.0, 'diag', 'alpha_I'),\n        (4, 4, 0.1, 'exact', 'diag'),\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        Nx, Ny, mu, Khat_choice, Shat_choice = case\n        result = run_case(Nx, Ny, mu, Khat_choice, Shat_choice)\n        # Python's bool __str__ method correctly produces 'True' or 'False'\n        results.append(f\"[{result[0]:.8e},{str(result[1])}]\")\n\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nsolve()\n\n```", "id": "3434325"}, {"introduction": "本练习将我们的视野转向大规模并行计算，此时区域分解方法变得至关重要。两级加性Schwarz方法是区域分解的基石之一，而其性能的关键在于一个设计良好的“粗空间校正”。通过这个实践 [@problem_id:3434344]，您将亲自实现并比较两种不同的粗空间设计，并通过实验研究当问题规模增长时，它们如何影响预条件共轭梯度法（PCG）的收敛性与可扩展性。", "problem": "考虑在单位正方形 $\\Omega = (0,1)\\times(0,1)$ 上的标量泊松问题 $-\\Delta u = f$，边界条件为齐次狄利克雷条件 $u=0$ on $\\partial\\Omega$。使用一个均匀的笛卡尔内部点网格对 $\\Omega$ 进行离散化，其中 $x$ 方向有 $N_x$ 个点，$y$ 方向有 $N_y$ 个点，并使用标准的五点有限差分格式来近似 $-\\Delta$。这会产生一个维度为 $N = N_x N_y$ 的对称正定线性系统 $A u = b$，其中 $A \\in \\mathbb{R}^{N \\times N}$，$b \\in \\mathbb{R}^{N}$。\n\n设区域被划分为 $n_x \\times n_y$ 个矩形子域，每个子域在每个空间方向上包含 $m$ 个细网格点，因此 $N_x = n_x m$ 且 $N_y = n_y m$。定义一个以细网格层为单位的固定重叠量 $\\delta$，并为每个子域构建其重叠索引集，方法是将其内部向所有方向扩展 $\\delta$ 个网格点（扩展范围被限制在全局内部索引范围内）。对于每个重叠子域索引集 $S_i$，将局部子域矩阵 $A_i$ 定义为通过限制到 $S_i$ 中的索引而从 $A$ 获得的主子矩阵。考虑对称两层加性 Schwarz 预条件子\n$$\nM^{-1} = R_0^\\top A_0^{-1} R_0 + \\sum_{i=1}^{N_s} R_i^\\top A_i^{-1} R_i,\n$$\n其中 $N_s = n_x n_y$，$R_i$ 是从全局向量空间到局部子域索引集 $S_i$ 的限制（注入）算子，而 $A_0$ 是一个粗糙算子，由 Galerkin 投影 $A_0 = R_0 A R_0^\\top$ 定义在一个下面指定的精心选择的粗糙空间上。\n\n您将比较两种粗糙空间设计，这两种设计模拟了来自 Balancing Neumann–Neumann 和 Finite Element Tearing and Interconnecting—Dual-Primal (FETI–DP) 的粗糙约束。比较将依据在固定重叠量下，预条件共轭梯度（PCG）法的迭代次数如何随网格比 $H/h$ 变化而进行：\n- 仅含角点约束：粗糙空间由与子域划分交叉点（角点）对应的基函数张成。交叉点集由笛卡尔网格线定义，这些网格线在 $x$ 方向的索引为 $km$（$k \\in \\{0,1,\\dots,n_x\\}$），在 $y$ 方向的索引为 $\\ell m$（$\\ell \\in \\{0,1,\\dots,n_y\\}$），并被限制在各自有效的内部索引范围 $\\{0,1,\\dots,N_x-1\\}$ 和 $\\{0,1,\\dots,N_y-1\\}$ 内。每个粗糙基函数是在全局索引下对应角点节点的单位向量。\n- 角点加边约束：粗糙空间包含上述角点，并额外为每个划分界面线增加一个边平均约束。对于 $x$ 索引为 $km$（$k \\in \\{1,2,\\dots,n_x-1\\}$）的每个垂直界面线，包含一个粗糙基函数，该函数沿着该列所有内部节点为常数，其权重被归一化为单位欧几里得范数。对于 $y$ 索引为 $\\ell m$（$\\ell \\in \\{1,2,\\dots,n_y-1\\}$）的每个水平界面线，包含一个粗糙基函数，该函数沿着该行所有内部节点为常数，其权重被归一化为单位欧几里得范数。这些额外的边平均粗糙基函数模拟了对偶-原始边约束。\n\nPCG 方法必须应用于 $A u = b$，使用预条件子 $M^{-1}$，初始猜测为 $u_0 = 0$，右端项 $b$ 定义为全1向量，停止准则为 $\\lVert r_k \\rVert_2 \\leq 10^{-8} \\lVert b \\rVert_2$，其中 $r_k$ 是 $k$ 次迭代后的残差。求解器必须使用与 $A$ 的精确矩阵向量乘积以及所定义的预条件子 $M^{-1}$ 的精确应用。\n\n将网格比 $H/h$ 定义为子域的粗细比 $H/h = m$。固定重叠量 $\\delta = 1$。对于固定的 $n_x = 2$ 和 $n_y = 2$ 的划分，跟踪随着 $H/h$ 增长，每种粗糙空间选择的 PCG 迭代次数如何变化。使用以下指定 $(m, n_x, n_y, \\delta)$ 的测试套件：\n- 测试用例 1：$(m, n_x, n_y, \\delta) = (4, 2, 2, 1)$。\n- 测试用例 2：$(m, n_x, n_y, \\delta) = (8, 2, 2, 1)$。\n- 测试用例 3：$(m, n_x, n_y, \\delta) = (16, 2, 2, 1)$。\n- 测试用例 4：$(m, n_x, n_y, \\delta) = (24, 2, 2, 1)$。\n\n对于每个测试用例，运行 PCG 两次：一次使用仅含角点的粗糙空间，另一次使用角点加边的粗糙空间。每次运行的可量化输出是整数形式的 PCG 迭代次数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。列表中的每个元素对应一个测试用例，并且本身是一个双元素列表，顺序为 $[\\text{角点迭代次数}, \\text{角点+边迭代次数}]$。例如，一个包含四个测试用例的输出必须如下所示：\n$[[i_1^{\\text{corners}}, i_1^{\\text{edges}}],[i_2^{\\text{corners}}, i_2^{\\text{edges}}],[i_3^{\\text{corners}}, i_3^{\\text{edges}}],[i_4^{\\text{corners}}, i_4^{\\text{edges}}]]$.\n此问题不涉及物理单位，如果存在任何角度，都将以弧度为单位，但此处没有角度。所有输出必须是整数。", "solution": "用户要求进行一次数值实验，以比较两种不同粗糙空间在两层加性 Schwarz 预条件子中的性能。该问题是针对单位正方形上的标量泊松方程提出的，并使用五点有限差分格式进行离散化。性能指标是预条件共轭梯度（PCG）方法达到收敛所需的迭代次数。\n\n### 问题验证\n根据指定标准对问题陈述进行验证。\n\n- **已知条件提取**：所有参数都已明确说明：偏微分方程（PDE） ($-\\Delta u = f$)、区域 ($\\Omega = (0,1)\\times(0,1)$)、边界条件 ($u=0$ on $\\partial\\Omega$)、离散化方法（均匀网格上的五点有限差分）、线性系统结构 ($Au=b$)、区域分解参数 ($m, n_x, n_y, \\delta$)、加性 Schwarz 预条件子的数学定义 ($M^{-1} = R_0^\\top A_0^{-1} R_0 + \\sum_{i=1}^{N_s} R_i^\\top A_i^{-1} R_i$)、两种独立粗糙空间（“仅含角点”和“角点加边”）的详细构造方法，以及 PCG 求解器的全套参数（初始猜测 $u_0=0$，右端项 $b=\\mathbf{1}$，停止准则 $\\lVert r_k \\rVert_2 \\leq 10^{-8} \\lVert b \\rVert_2$）。测试用例以元组 $(m, n_x, n_y, \\delta)$ 的列表形式指定。\n\n- **验证检查**：\n  - **科学依据**：该问题是数值分析领域的一个标准且公认的基准问题，特别是在迭代求解器和区域分解方法的研究中。所使用的所有概念都是该学科的基础。\n  - **适定性**：该问题是适定的。由带狄利克雷边界条件的负拉普拉斯算子的有限差分离散化产生的系统矩阵 $A$ 是对称正定（SPD）的。预条件子 $M^{-1}$ 的构造也使其成为对称正定的。对于对称正定系统和对称正定预条件子，PCG 算法保证收敛。达到给定容差所需的迭代次数是一个唯一定义的、确定性的量。\n  - **客观性**：问题以精确、客观的数学语言陈述。待计算的量（迭代次数）是明确且可测量的。\n  - 对于给定的参数，该问题是完整、一致且在计算上可行的。不存在科学上不合理、歧义或依赖于不可验证声明等缺陷。\n\n- **结论**：该问题是**有效的**。\n\n### 算法解决方案设计\n\n解决方案需要实现一个由两层加性 Schwarz 方法预条件的 PCG 求解器。关键步骤如下：\n\n1.  **系统矩阵构造**：矩阵 $A \\in \\mathbb{R}^{N \\times N}$ 表示在 $N_x \\times N_y$ 内部点组成的均匀网格上的五点有限差分格式，其中 $N=N_x N_y$。采用字典序对网格点进行排序，矩阵 $A$ 具有块三对角结构。它可以通过两个一维拉普拉斯矩阵的克罗内克和 (`kronsum`) 优雅地构造出来。设 $T_k$ 是一个 $k \\times k$ 的三对角矩阵，其对角线上为 2，次对角线上为 -1。那么系统矩阵为 $A = \\text{kronsum}(T_{N_y}, T_{N_x})$。\n\n2.  **区域分解**：将 $N_x \\times N_y$ 个点的全局区域划分为 $n_x \\times n_y$ 个子域，每个子域的大小为 $m \\times m$ 个内部网格点，其中 $N_x = n_x m$ 且 $N_y = n_y m$。对于每个子域 $i$，通过将该子域向各个方向扩展 $\\delta$ 个网格点来构建一个重叠索引集 $S_i$，扩展范围被限制在全局内部网格的边界内。局部矩阵 $A_i$ 是通过将 $A$ 限制在 $S_i$ 中的索引上得到的主子矩阵。限制算子 $R_i$是相应的注入矩阵。\n\n3.  **粗糙空间构造**：粗糙空间由一组基函数定义，这些基函数构成了限制矩阵 $R_0$ 的行。\n    -   **仅含角点**：基函数是对应于子域角点处网格点的单位向量。对于一个 $n_x \\times n_y$ 的划分，存在 $(n_x+1)(n_y+1)$ 个这样的角点，其索引被限制在有效的内部网格范围内。\n    -   **角点加边**：该空间包括角点基函数，以及为子域间界面添加的额外函数。对于每个界面线（例如，在 $x$ 索引为 $k \\cdot m$ 处），创建一个基函数，该函数在该线上所有节点上具有一个常数值，在其他地方为零。选择该常数以使基向量的欧几里得范数为 1。\n\n4.  **预条件子应用 ($z = M^{-1}r$)**：预条件子对残差向量 $r$ 的作用计算为粗糙校正和局部子域校正之和：\n    $$ z = R_0^\\top A_0^{-1} (R_0 r) + \\sum_{i=1}^{N_s} R_i^\\top A_i^{-1} (R_i r) $$\n    -   粗糙算子 $A_0$ 通过 Galerkin 投影形成：$A_0 = R_0 A R_0^\\top$。由于 $A_0$ 很小，其逆矩阵可以通过密集的线性求解直接计算。\n    -   局部子域求解 $A_i^{-1}(R_i r)$ 是通过在每个预先计算的局部矩阵 $A_i$ 上使用直接求解器（例如，LU 分解）来执行的。然后将结果延拓回去（通过 $R_i^\\top$）并求和。\n\n5.  **预条件共轭梯度（PCG）**：实现一个标准的 PCG 算法来求解 $Au=b$。它需要一个函数来计算矩阵向量乘积 $A \\cdot p$，以及另一个函数来应用预条件子 $z = M^{-1}r$。从 $u_0 = 0$ 开始，迭代进行直到相对残差范数满足 $\\lVert r_k \\rVert_2 / \\lVert b \\rVert_2 \\leq 10^{-8}$。\n\n主程序遍历指定的测试用例，并为每个用例配置和运行两种粗糙空间类型的模拟，记录每次运行的最终迭代次数。", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nimport scipy.sparse.linalg\n\ndef construct_laplacian_2d(Nx, Ny):\n    \"\"\"\n    Constructs the 2D Laplacian matrix A for an Nx x Ny grid\n    using a 5-point finite difference stencil.\n    \"\"\"\n    T_y = sparse.diags([-1, 2, -1], [-1, 0, 1], shape=(Ny, Ny), format='csr')\n    T_x = sparse.diags([-1, 2, -1], [-1, 0, 1], shape=(Nx, Nx), format='csr')\n    # Using lexicographical ordering k = i*Ny + j, where i is the x-index (slow)\n    # and j is the y-index (fast).\n    A = sparse.kronsum(T_y, T_x)\n    return A.tocsr()\n\ndef get_subdomain_data(A, Nx, Ny, nx, ny, m, delta):\n    \"\"\"\n    Computes subdomain index sets and pre-factorizes local matrices.\n    \"\"\"\n    subdomain_indices = []\n    subdomain_solvers = []\n    global_indices_grid = np.arange(Nx * Ny).reshape((Nx, Ny))\n\n    for ix in range(nx):\n        for iy in range(ny):\n            x_start = max(0, ix * m - delta)\n            x_end = min(Nx, (ix + 1) * m + delta)\n            \n            y_start = max(0, iy * m - delta)\n            y_end = min(Ny, (iy + 1) * m + delta)\n\n            indices = global_indices_grid[x_start:x_end, y_start:y_end].flatten()\n            subdomain_indices.append(indices)\n\n            A_local = A[indices, :][:, indices].tocsc()\n            subdomain_solvers.append(scipy.sparse.linalg.splu(A_local))\n            \n    return subdomain_indices, subdomain_solvers\n\ndef build_coarse_space(Nx, Ny, nx, ny, m, space_type):\n    \"\"\"\n    Builds the coarse space restriction operator R0.\n    \"\"\"\n    N = Nx * Ny\n    basis_vectors = []\n\n    # Corners-only space\n    x_lines = [k * m for k in range(nx + 1)]\n    y_lines = [l * m for l in range(ny + 1)]\n    \n    x_coords = sorted(list(set([min(idx, Nx - 1) for idx in x_lines])))\n    y_coords = sorted(list(set([min(idx, Ny - 1) for idx in y_lines])))\n\n    for xc in x_coords:\n        for yc in y_coords:\n            global_idx = xc * Ny + yc\n            vec = sparse.csc_matrix(([1.0], ([0], [global_idx])), shape=(1, N))\n            basis_vectors.append(vec)\n\n    # Corners-plus-edges space\n    if space_type == 'corners+edges':\n        # Vertical edge functions\n        for k in range(1, nx):\n            x_idx = k * m\n            nodes_on_edge = [x_idx * Ny + j for j in range(Ny)]\n            data = np.full(Ny, 1.0 / np.sqrt(Ny))\n            rows = np.zeros(Ny, dtype=int)\n            cols = np.array(nodes_on_edge)\n            vec = sparse.csc_matrix((data, (rows, cols)), shape=(1, N))\n            basis_vectors.append(vec)\n\n        # Horizontal edge functions\n        for l in range(1, ny):\n            y_idx = l * m\n            nodes_on_edge = [i * Ny + y_idx for i in range(Nx)]\n            data = np.full(Nx, 1.0 / np.sqrt(Nx))\n            rows = np.zeros(Nx, dtype=int)\n            cols = np.array(nodes_on_edge)\n            vec = sparse.csc_matrix((data, (rows, cols)), shape=(1, N))\n            basis_vectors.append(vec)\n            \n    return sparse.vstack(basis_vectors, format='csr')\n\ndef pcg(A, b, precon_func, tol=1e-8):\n    \"\"\"\n    Preconditioned Conjugate Gradient solver.\n    \"\"\"\n    n = A.shape[0]\n    x = np.zeros(n)\n    r = b.copy()\n    \n    norm_b = np.linalg.norm(b)\n    if norm_b == 0:\n        return 0\n\n    if np.linalg.norm(r) / norm_b = tol:\n        return 0\n\n    z = precon_func(r)\n    p = z.copy()\n    rs_old = np.dot(r, z)\n\n    for i in range(n): \n        Ap = A.dot(p)\n        alpha = rs_old / np.dot(p, Ap)\n\n        x += alpha * p\n        r -= alpha * Ap\n\n        if np.linalg.norm(r) / norm_b = tol:\n            return i + 1\n\n        z = precon_func(r)\n        rs_new = np.dot(r, z)\n\n        beta = rs_new / rs_old\n        p = z + beta * p\n        rs_old = rs_new\n        \n    return n\n\ndef solve():\n    test_cases = [\n        (4, 2, 2, 1),\n        (8, 2, 2, 1),\n        (16, 2, 2, 1),\n        (24, 2, 2, 1),\n    ]\n\n    all_results = []\n    \n    for m, nx, ny, delta in test_cases:\n        Nx = nx * m\n        Ny = ny * m\n        N = Nx * Ny\n\n        A = construct_laplacian_2d(Nx, Ny)\n        \n        subdomain_indices, subdomain_solvers = get_subdomain_data(A, Nx, Ny, nx, ny, m, delta)\n        \n        case_results = []\n        for space_type in ['corners', 'corners+edges']:\n            R0 = build_coarse_space(Nx, Ny, nx, ny, m, space_type)\n            A0 = (R0 @ A @ R0.T).toarray()\n            A0_inv = np.linalg.inv(A0)\n            \n            def apply_preconditioner(r):\n                z = np.zeros(N)\n                \n                # Coarse correction\n                r0 = R0 @ r\n                w0 = A0_inv @ r0\n                z += R0.T @ w0\n                \n                # Local corrections (Additive Schwarz)\n                for i in range(len(subdomain_solvers)):\n                    indices = subdomain_indices[i]\n                    r_local = r[indices]\n                    w_local = subdomain_solvers[i].solve(r_local)\n                    z[indices] += w_local\n                    \n                return z\n            \n            b = np.ones(N)\n            iterations = pcg(A, b, apply_preconditioner, tol=1e-8)\n            case_results.append(iterations)\n        \n        all_results.append(case_results)\n\n    # Format the final output string to be exactly as required (no spaces)\n    print(repr(all_results).replace(' ', ''))\n\nsolve()\n```", "id": "3434344"}]}