{"hands_on_practices": [{"introduction": "对流扩散问题的数值格式选择是一个直接影响求解质量的关键决策。第一个实践练习将提供一个经验基础，要求您在一系列佩克莱数（Peclet number）下，分别使用中心差分和迎风差分格式求解一个稳态问题 [@problem_id:3430298]。通过将您的数值解在准确性和单调性方面与精确解进行比较，您将直接观察到最根本的权衡：中心格式在低佩克莱数下的高精度，与迎风格式在对流占优时出色的稳定性。", "problem": "考虑在区间 $[0,1]$ 上的具有常系数的稳态一维线性对流扩散边值问题，\n$$-\\,\\kappa\\,u''(x) + \\beta\\,u'(x) = 0,\\quad x\\in(0,1),$$\n边界条件为狄利克雷(Dirichlet)边界条件\n$$u(0)=1,\\quad u(1)=0.$$\n假设 $\\kappa0$ 且 $\\beta\\in\\mathbb{R}$。对于常数 $\\kappa$ 和 $\\beta$，其精确解是良定义的，并在边界值之间严格单调。定义无量纲的网格佩克莱特数 (Péclet number) 为\n$$Pe = \\frac{\\beta\\,h}{\\kappa},$$\n其中 $h$ 是将 $[0,1]$ 均匀剖分为 $N$ 个相等子区间的均匀网格间距，因此 $h=1/N$。\n\n你将在一个具有 $N$ 个子区间的均匀网格（网格节点为 $x_i=i\\,h$，其中 $i=0,1,\\dots,N$）上实现两种相容的有限差分离散化方法，遵循以下原则：\n- 对内部节点，使用标准二阶中心差分来近似扩散算子 $-\\,\\kappa\\,u''(x)$。\n- 用两种方式近似对流算子 $\\beta\\,u'(x)$：\n  - 中心差分（二阶）：对内部节点使用中心差分。\n  - 一阶迎风差分：对内部节点使用与 $\\beta$ 符号一致的单边差分。\n\n在 $x_0=0$ 和 $x_N=1$ 处强施加边界条件。对于每种格式，组装并求解得到的关于内部未知数的线性系统，以获得网格解 $\\{u_i\\}_{i=0}^N$。令 $u^{\\mathrm{CD}}$ 表示使用中心差分计算对流项得到的数值解， $u^{\\mathrm{UD}}$ 表示使用迎风差分计算对流项得到的数值解。\n\n定义相对于精确解 $u(x)$ 的以下误差度量：\n- 离散 $L^2$-范数（使用梯形法则）：\n$$\\|e\\|_{L^2_h} \\;=\\;\\bigg(h\\Big(\\tfrac{1}{2}\\,e_0^2 + \\sum_{i=1}^{N-1} e_i^2 + \\tfrac{1}{2}\\,e_N^2\\Big)\\bigg)^{1/2},\\quad e_i = u_i - u(x_i).$$\n- 离散 $H^1$ 半范数（分片线性重构）：\n$$|e|_{H^1_h} \\;=\\;\\bigg(\\sum_{i=0}^{N-1} h\\,\\Big(\\frac{e_{i+1}-e_i}{h}\\Big)^2\\bigg)^{1/2}\\;=\\;\\bigg(\\frac{1}{h}\\sum_{i=0}^{N-1} (e_{i+1}-e_i)^2\\bigg)^{1/2}.$$\n\n此外，为网格函数 $v_i$ 定义一个单调性指标，它是一个布尔值，当且仅当序列在整个网格上非增时为真，即：\n$$v_{i+1} \\le v_i \\;\\text{ for all } i=0,1,\\dots,N-1,$$\n在 $10^{-10}$ 的数值容差范围内。\n\n实现这两种格式，并为每种格式计算 $\\|e\\|_{L^2_h}$ 和 $|e|_{H^1_h}$。同时为每种格式计算单调性指标。\n\n最后，实现一个仅基于网格佩克莱特数 $Pe$ 的局部格式选择规则：\n- 如果 $|Pe|\\le 2$，选择中心差分。\n- 如果 $|Pe| > 2$，选择迎风差分。\n\n目标是通过误差范数和单调性来量化 $Pe$ 如何影响格式的合适性，并报告基于 $Pe$ 的规则选择了哪种格式。\n\n测试套件：\n使用以下5个测试用例，每个用例由 $(\\beta,\\kappa,N)$ 指定：\n- 用例 1：$(\\beta,\\kappa,N) = (0.2,\\,1.0,\\,50)$。\n- 用例 2：$(\\beta,\\kappa,N) = (1.0,\\,0.02,\\,25)$。\n- 用例 3：$(\\beta,\\kappa,N) = (1.0,\\,0.02,\\,10)$。\n- 用例 4：$(\\beta,\\kappa,N) = (2.0,\\,0.02,\\,20)$。\n- 用例 5：$(\\beta,\\kappa,N) = (-1.0,\\,0.05,\\,10)$。\n\n对于每个用例，你的程序必须：\n- 在网格上计算 $u^{\\mathrm{CD}}$ 和 $u^{\\mathrm{UD}}$。\n- 计算 $\\|e^{\\mathrm{CD}}\\|_{L^2_h}$、$\\|e^{\\mathrm{UD}}\\|_{L^2_h}$、 $|e^{\\mathrm{CD}}|_{H^1_h}$、 $|e^{\\mathrm{UD}}|_{H^1_h}$ 以及 $u^{\\mathrm{CD}}$ 和 $u^{\\mathrm{UD}}$ 的单调性指标。\n- 计算网格佩克莱特数 $Pe=\\beta h/\\kappa$ 并应用选择规则返回一个格式代码：中心差分为 $0$，迎风差分为 $1$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于上面列出的每个测试用例，按顺序输出一个包含以下7个条目的子列表：\n- 由 $Pe$ 规则选择的整数格式代码（中心差分为 $0$，迎风差分为 $1$）。\n- $\\|e^{\\mathrm{CD}}\\|_{L^2_h}$ 的浮点数值。\n- $\\|e^{\\mathrm{UD}}\\|_{L^2_h}$ 的浮点数值。\n- $|e^{\\mathrm{CD}}|_{H^1_h}$ 的浮点数值。\n- $|e^{\\mathrm{UD}}|_{H^1_h}$ 的浮点数值。\n- $u^{\\mathrm{CD}}$ 的布尔单调性指标。\n- $u^{\\mathrm{UD}}$ 的布尔单调性指标。\n\n因此，总输出的形式为\n$$[\\,[\\text{scheme},\\,L2_{\\mathrm{CD}},\\,L2_{\\mathrm{UD}},\\,H1_{\\mathrm{CD}},\\,H1_{\\mathrm{UD}},\\,\\text{mono}_{\\mathrm{CD}},\\,\\text{mono}_{\\mathrm{UD}}],\\ \\dots\\ ].$$\n所有量均为无量纲。程序不得读取输入，必须硬编码上述测试用例。输出必须是指定格式的单行文本。", "solution": "The user wants to solve a steady one-dimensional convection-diffusion boundary value problem and analyze the performance of two finite difference schemes.\n\n### Step 1: Problem Validation\n\nThe problem is stated as:\n- **PDE**: $-\\kappa u''(x) + \\beta u'(x) = 0$ on $x \\in (0,1)$.\n- **Boundary Conditions**: $u(0)=1$, $u(1)=0$.\n- **Parameters**: $\\kappa  0$, $\\beta \\in \\mathbb{R}$.\n\nThe task involves:\n1.  Deriving the analytical solution.\n2.  Discretizing the PDE using two schemes on a uniform grid with $N$ intervals and spacing $h=1/N$:\n    -   Central differencing (CD) for both diffusion and convection.\n    -   Central differencing for diffusion and first-order upwind differencing (UD) for convection.\n3.  Solving the resulting linear systems for the nodal values $\\{u_i\\}_{i=0}^N$.\n4.  Calculating specified error norms (discrete $L^2$ and $H^1$ seminorm) and a monotonicity indicator for both schemes.\n5.  Implementing a scheme selection rule based on the cell Péclet number, $Pe = \\frac{\\beta h}{\\kappa}$.\n6.  Running a suite of test cases and reporting the results in a specified format.\n\nThe problem is a classic exercise in the numerical analysis of partial differential equations. It is scientifically sound, well-posed, objective, and fully specified. The differential equation, boundary conditions, numerical methods, and analysis metrics are all standard and well-defined in the field of computational science and engineering. There are no contradictions, ambiguities, or invalid premises.\n\nThe validation verdict is **valid**.\n\n### Step 2: Analytical Solution\n\nThe governing ordinary differential equation is a second-order linear homogeneous equation with constant coefficients:\n$$-\\kappa u'' + \\beta u' = 0$$\nThe characteristic equation is $-\\kappa r^2 + \\beta r = 0$, which gives $r(-\\kappa r + \\beta) = 0$. The roots are $r_1 = 0$ and $r_2 = \\beta/\\kappa$.\n\n-   If $\\beta = 0$, the roots are repeated ($r_1=r_2=0$), and the general solution is $u(x) = C_1 + C_2 x$. Applying the boundary conditions $u(0)=1$ and $u(1)=0$ yields $C_1=1$ and $C_2=-1$, so $u(x) = 1-x$.\n\n-   If $\\beta \\neq 0$, the roots are distinct, and the general solution is $u(x) = C_1 e^{r_1 x} + C_2 e^{r_2 x} = C_1 + C_2 e^{(\\beta/\\kappa)x}$. Applying the boundary conditions:\n    -   $u(0) = C_1 + C_2 = 1$\n    -   $u(1) = C_1 + C_2 e^{\\beta/\\kappa} = 0$\n    Solving this system for $C_1$ and $C_2$ gives:\n    $$C_1 = \\frac{e^{\\beta/\\kappa}}{e^{\\beta/\\kappa} - 1}, \\quad C_2 = -\\frac{1}{e^{\\beta/\\kappa} - 1}$$\n    The exact solution is therefore:\n    $$u(x) = \\frac{e^{\\beta/\\kappa} - e^{(\\beta/\\kappa)x}}{e^{\\beta/\\kappa} - 1}$$\nFor numerical stability when $\\beta/\\kappa$ is a large positive number, this can be rewritten as:\n$$u(x) = \\frac{1 - e^{(\\beta/\\kappa)(x-1)}}{1 - e^{-\\beta/\\kappa}}$$\n\n### Step 3: Finite Difference Discretization\n\nWe discretize the equation at interior grid nodes $x_i = ih$ for $i=1, \\dots, N-1$. The general form of the discretized equation is:\n$$-\\kappa \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} + \\beta (\\text{approx. of } u'(x_i)) = 0$$\nWe rearrange this to form a linear system $A \\mathbf{u_{int}} = \\mathbf{b}$ for the interior unknowns $\\mathbf{u_{int}} = [u_1, \\dots, u_{N-1}]^T$. The boundary values $u_0=1$ and $u_N=0$ are moved to the right-hand side.\n\n**Scheme 1: Central Differencing (CD)**\nThe convection term is approximated by $\\beta u'(x_i) \\approx \\beta \\frac{u_{i+1} - u_{i-1}}{2h}$. The discrete equation becomes:\n$$ \\left(-\\frac{\\kappa}{h^2} - \\frac{\\beta}{2h}\\right)u_{i-1} + \\left(\\frac{2\\kappa}{h^2}\\right)u_i + \\left(-\\frac{\\kappa}{h^2} + \\frac{\\beta}{2h}\\right)u_{i+1} = 0 $$\nMultiplying by $h^2$ gives the coefficients for the tridiagonal system matrix $A_{CD}$:\n-   Lower diagonal: $l_i = -\\kappa - \\frac{\\beta h}{2}$\n-   Main diagonal: $d_i = 2\\kappa$\n-   Upper diagonal: $u_i = -\\kappa + \\frac{\\beta h}{2}$\n-   The right-hand side vector $\\mathbf{b}_{CD}$ is zero except for the first entry, which incorporates the $u_0=1$ boundary condition: $b_1 = -l_1 u_0 = \\kappa + \\frac{\\beta h}{2}$.\n\n**Scheme 2: Upwind Differencing (UD)**\nThe convection term approximation depends on the sign of $\\beta$:\n-   If $\\beta \\ge 0$ (flow from left to right), use a backward difference: $\\beta u'(x_i) \\approx \\beta \\frac{u_i - u_{i-1}}{h}$.\n-   If $\\beta  0$ (flow from right to left), use a forward difference: $\\beta u'(x_i) \\approx \\beta \\frac{u_{i+1} - u_i}{h}$.\n\nThis leads to the following coefficients for the tridiagonal system matrix $A_{UD}$:\n-   If $\\beta \\ge 0$:\n    -   $l_i = -\\kappa - \\beta h$\n    -   $d_i = 2\\kappa + \\beta h$\n    -   $u_i = -\\kappa$\n    -   $b_1 = -l_1 u_0 = \\kappa + \\beta h$\n-   If $\\beta  0$:\n    -   $l_i = -\\kappa$\n    -   $d_i = 2\\kappa - \\beta h$\n    -   $u_i = -\\kappa + \\beta h$\n    -   $b_1 = -l_1 u_0 = \\kappa$\n\n### Step 4: Analysis and Implementation\n\nFor each test case $(\\beta, \\kappa, N)$, the following steps are executed:\n1.  Calculate grid parameters $h$ and $x_i$.\n2.  Compute the exact solution $u(x_i)$ on the grid using the numerically stable formula.\n3.  For each scheme (CD and UD):\n    a.  Assemble the $(N-1) \\times (N-1)$ tridiagonal matrix $A$ and the right-hand side vector $\\mathbf{b}$.\n    b.  Solve the linear system $A \\mathbf{u_{int}} = \\mathbf{b}$ to find the interior solution.\n    c.  Construct the full solution vector $u_i$ by including the boundary values $u_0=1$ and $u_N=0$.\n4.  For each numerical solution ($u^{\\mathrm{CD}}$, $u^{\\mathrm{UD}}$):\n    a.  Compute the error vector $e_i = u_i - u(x_i)$.\n    b.  Calculate the discrete $L^2$-norm: $\\|e\\|_{L^2_h} = \\left(h \\sum_{i=1}^{N-1} e_i^2\\right)^{1/2}$.\n    c.  Calculate the discrete $H^1$-seminorm: $|e|_{H^1_h} = \\left(h^{-1} \\sum_{i=0}^{N-1} (e_{i+1}-e_i)^2\\right)^{1/2}$.\n    d.  Check for monotonicity: determine if $u_{i+1} \\le u_i$ for all $i=0, \\dots, N-1$. The exact solution is always non-increasing for the given boundary conditions.\n5.  Calculate the cell Péclet number $Pe = \\beta h / \\kappa$ and determine the selected scheme: code $0$ for CD if $|Pe| \\le 2$, and code $1$ for UD if $|Pe| > 2$.\n6.  Collect the seven required output values: scheme code, the four error norms, and the two monotonicity booleans.\n\nThis procedure is implemented in the Python code below, which processes all test cases and generates the output in the specified format. The `scipy` library is not required as `numpy` provides sufficient functionality for assembling and solving the tridiagonal linear systems.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        (0.2, 1.0, 50),\n        (1.0, 0.02, 25),\n        (1.0, 0.02, 10),\n        (2.0, 0.02, 20),\n        (-1.0, 0.05, 10),\n    ]\n\n    results = []\n    for case in test_cases:\n        beta, kappa, N = case\n        case_result = solve_bvp_case(beta, kappa, N)\n        results.append(case_result)\n\n    # Format the final output string as a compact list of lists.\n    # str(results) produces '[...], [...]', with spaces.\n    # .replace(\" \", \"\") makes it compact: '[[...],[...]]'\n    final_output = str(results).replace(\" \", \"\")\n    print(final_output)\n\ndef solve_bvp_case(beta, kappa, N):\n    \"\"\"\n    Solves the 1D convection-diffusion BVP for a single case.\n    Returns a list of 7 metrics as specified in the problem.\n    \"\"\"\n    h = 1.0 / N\n    x_grid = np.linspace(0, 1, N + 1)\n\n    # Analytically compute exact solution on the grid.\n    u_exact = get_exact_solution(beta, kappa, x_grid)\n\n    # Solve using Central Differencing for convection.\n    u_cd = solve_finite_difference(beta, kappa, N, scheme='central')\n    \n    # Solve using Upwind Differencing for convection.\n    u_ud = solve_finite_difference(beta, kappa, N, scheme='upwind')\n\n    # Compute errors for both schemes.\n    e_cd = u_cd - u_exact\n    e_ud = u_ud - u_exact\n\n    # L2 norm of error (using trapezoidal rule on the whole domain for consistency with problem statement)\n    l2_cd = np.sqrt(h * (0.5 * e_cd[0]**2 + np.sum(e_cd[1:-1]**2) + 0.5 * e_cd[-1]**2))\n    l2_ud = np.sqrt(h * (0.5 * e_ud[0]**2 + np.sum(e_ud[1:-1]**2) + 0.5 * e_ud[-1]**2))\n\n    # H1 seminorm of error.\n    h1_cd = np.sqrt(np.sum(np.diff(e_cd)**2) / h)\n    h1_ud = np.sqrt(np.sum(np.diff(e_ud)**2) / h)\n    \n    # Monotonicity check (solution must be non-increasing).\n    mono_cd = bool(np.all(np.diff(u_cd) = 1e-10))\n    mono_ud = bool(np.all(np.diff(u_ud) = 1e-10))\n\n    # Apply scheme selection rule based on cell Peclet number.\n    peclet = beta * h / kappa\n    scheme_code = 1 if abs(peclet) > 2.0 else 0\n    \n    return [scheme_code, l2_cd, l2_ud, h1_cd, h1_ud, mono_cd, mono_ud]\n\ndef get_exact_solution(beta, kappa, x_grid):\n    \"\"\"\n    Computes the exact solution on a given grid, using a numerically\n    stable formulation to avoid floating-point overflow.\n    \"\"\"\n    C = beta / kappa\n    if abs(C)  1e-9: # Essentially beta = 0 case\n        return 1.0 - x_grid\n    \n    if C > 0:\n        # This form avoids exp(C) for a large positive C.\n        if C > 700: # Asymptotic form to avoid 1.0 - exp(-C) becoming 1.0\n             return 1.0 - np.exp(C * (x_grid - 1.0))\n        return (1.0 - np.exp(C * (x_grid - 1.0))) / (1.0 - np.exp(-C))\n    else: # C  0\n        # This form is stable for negative C.\n        return (np.exp(C) - np.exp(C * x_grid)) / (np.exp(C) - 1.0)\n\ndef solve_finite_difference(beta, kappa, N, scheme):\n    \"\"\"\n    Assembles and solves the linear system for a given finite difference scheme.\n    \"\"\"\n    h = 1.0 / N\n    num_interior_pts = N - 1\n\n    if num_interior_pts == 0:\n        return np.array([1.0, 0.0] if N == 1 else [1.0])\n\n    A = np.zeros((num_interior_pts, num_interior_pts))\n    b = np.zeros(num_interior_pts)\n    \n    # Coefficients multiplied by h^2 for better scaling, but we solve directly.\n    if scheme == 'central':\n        lower_diag = -kappa - beta * h / 2.0\n        main_diag = 2.0 * kappa\n        upper_diag = -kappa + beta * h / 2.0\n    elif scheme == 'upwind':\n        if beta >= 0:\n            lower_diag = -kappa - beta * h\n            main_diag = 2.0 * kappa + beta * h\n            upper_diag = -kappa\n        else: # beta  0\n            lower_diag = -kappa\n            main_diag = 2.0 * kappa - beta * h\n            upper_diag = -kappa + beta * h\n    else:\n        raise ValueError(\"Invalid scheme type\")\n\n    # Assemble the tridiagonal matrix A\n    np.fill_diagonal(A, main_diag)\n    if num_interior_pts > 1:\n        np.fill_diagonal(A[1:], lower_diag)\n        np.fill_diagonal(A[:, 1:], upper_diag)\n\n    # Assemble the RHS vector b from the u(0)=1 boundary condition\n    b[0] = -lower_diag * 1.0\n    \n    # Solve the linear system for interior nodes\n    u_int = np.linalg.solve(A, b)\n    \n    # Combine with boundary conditions to get the full solution\n    return np.concatenate(([1.0], u_int, [0.0]))\n\nsolve()\n```", "id": "3430298"}, {"introduction": "在观察了格式选择的实际效果后，我们现在转向其背后的理论。本练习将引导您通过截断误差分析，从数学上解释为什么中心差分会变得不稳定，而迎风差分能保持稳健性 [@problem_id:3430230]。您将推导两种格式的主导误差项，揭示它们对解的导数和佩克莱数的不同依赖关系，并利用这一洞察来构建一个在它们之间切换的准则。", "problem": "考虑一维稳态对流扩散方程\n$$- \\nu\\, u''(x) + a\\, u'(x) = f(x),$$\n该方程定义在一个光滑解域上，采用间距为 $$\\Delta x  0$$ 的均匀网格，且参数 $$\\nu  0$$ 和 $$a  0$$ 为常数。假设 $$u \\in C^{4}$$，因此所有直至四阶的导数都存在且有界。定义单元 Péclet 数（Péclet 数）为\n$$Pe = \\frac{a\\, \\Delta x}{\\nu}.$$\n使用标准的二阶中心差分格式离散化扩散项，并考虑在网格点 $$x_i$$ 处对流项的两种替代方案：\n- 用于 $$u'(x_i)$$ 的二阶中心差分，以及\n- 当 $$a  0$$ 时，用于 $$u'(x_i)$$ 的一阶迎风（后向）差分。\n从 $$x_i$$ 点的泰勒展开出发，推导两种离散化方案在 $$x_i$$ 点的局部截断误差，直至并包含其首个非零项，结果用 $$u^{(k)}(x_i)$$、$$\\nu$$、$$a$$ 和 $$\\Delta x$$ 表示。然后，在一个数据驱动的建模场景的启发下，假设对高分辨率训练场的回归分析得出了以下条件期望\n$$\\mathbb{E}\\!\\left[\\frac{|u^{(3)}(x_i)|}{|u''(x_i)|}\\,\\Big|\\,Pe\\right] = c\\, \\frac{Pe}{\\Delta x},$$\n其中拟合常数 $$c = 1.72$$ 在感兴趣的工作范围内有效。利用这个模型，通过令中心差分和迎风离散化方案的主导对流截断误差的期望大小相等，来提出一个自动的格式切换阈值，并求解该阈值 $$Pe^{\\ast}$$。将你的最终答案表示为一个纯数（无单位），并四舍五入到四位有效数字。", "solution": "根据指定标准，该问题被评估为有效。它具有科学依据，问题定义良好，客观，并包含足够的信息以推导出唯一解。\n\n目标是找到一个阈值 Péclet 数 $Pe^{\\ast}$，用于在一维稳态对流扩散方程中，对流项在中心差分格式和迎风格式之间进行切换。方程由\n$$ - \\nu\\, u''(x) + a\\, u'(x) = f(x) $$\n给出，其中参数 $\\nu  0$ 和 $a  0$ 为常数。阈值 $Pe^{\\ast}$ 通过令两种格式的主导对流截断误差的期望大小相等来确定。\n\n首先，我们推导在网格点 $x_i$ 处对流项 $a u'(x)$ 离散化的局部截断误差。我们使用 $u(x)$ 在 $x_i$ 点附近的泰勒级数展开，假设解 $u$ 足够光滑 ($u \\in C^4$)。设 $u_i = u(x_i)$，$u_{i+1} = u(x_i + \\Delta x)$，以及 $u_{i-1} = u(x_i - \\Delta x)$。展开式为：\n$$ u_{i+1} = u_i + u'_i \\Delta x + \\frac{u''_i}{2!} (\\Delta x)^2 + \\frac{u'''_i}{3!} (\\Delta x)^3 + \\frac{u^{(4)}_i}{4!} (\\Delta x)^4 + O((\\Delta x)^5) $$\n$$ u_{i-1} = u_i - u'_i \\Delta x + \\frac{u''_i}{2!} (\\Delta x)^2 - \\frac{u'''_i}{3!} (\\Delta x)^3 + \\frac{u^{(4)}_i}{4!} (\\Delta x)^4 + O((\\Delta x)^5) $$\n\n问题要求考虑一阶导数项 $u'(x_i)$ 的两种离散化方法。\n\n1.  **二阶中心差分格式：**\n    $u'(x_i)$ 的近似由 $\\frac{u_{i+1} - u_{i-1}}{2\\Delta x}$ 给出。为了找到截断误差，我们代入泰勒展开式：\n    $$ u_{i+1} - u_{i-1} = \\left(u_i + u'_i \\Delta x + \\frac{u''_i}{2}(\\Delta x)^2 + \\frac{u'''_i}{6}(\\Delta x)^3 + \\dots\\right) - \\left(u_i - u'_i \\Delta x + \\frac{u''_i}{2}(\\Delta x)^2 - \\frac{u'''_i}{6}(\\Delta x)^3 + \\dots\\right) $$\n    $$ u_{i+1} - u_{i-1} = 2u'_i \\Delta x + \\frac{2u'''_i}{6}(\\Delta x)^3 + O((\\Delta x)^5) = 2u'_i \\Delta x + \\frac{u'''_i}{3}(\\Delta x)^3 + O((\\Delta x)^5) $$\n    用 $2\\Delta x$ 除以，得到离散化导数的表达式：\n    $$ \\frac{u_{i+1} - u_{i-1}}{2\\Delta x} = u'_i + \\frac{u'''_i}{6}(\\Delta x)^2 + O((\\Delta x)^4) $$\n    对流项的局部截断误差 $\\tau_{conv}^{CD}$ 是离散项与精确项之差：\n    $$ \\tau_{conv}^{CD} = a \\left(\\frac{u_{i+1} - u_{i-1}}{2\\Delta x}\\right) - a u'_i = a \\left(u'_i + \\frac{u'''_i}{6}(\\Delta x)^2 + O((\\Delta x)^4)\\right) - a u'_i $$\n    中心差分格式的对流截断误差的首个非零项是：\n    $$ \\tau_{conv, leading}^{CD} = a \\frac{u'''(x_i)}{6}(\\Delta x)^2 $$\n\n2.  **一阶迎风（后向）差分格式：**\n    因为 $a  0$，迎风方向与流动方向相反，所以我们使用后向差分。$u'(x_i)$ 的近似是 $\\frac{u_i - u_{i-1}}{\\Delta x}$。使用 $u_{i-1}$ 的泰勒展开：\n    $$ \\frac{u_i - u_{i-1}}{\\Delta x} = \\frac{1}{\\Delta x} \\left(u_i - \\left(u_i - u'_i \\Delta x + \\frac{u''_i}{2}(\\Delta x)^2 - \\frac{u'''_i}{6}(\\Delta x)^3 + \\dots\\right)\\right) $$\n    $$ \\frac{u_i - u_{i-1}}{\\Delta x} = \\frac{1}{\\Delta x} \\left(u'_i \\Delta x - \\frac{u''_i}{2}(\\Delta x)^2 + \\frac{u'''_i}{6}(\\Delta x)^3 - \\dots\\right) = u'_i - \\frac{u''_i}{2}\\Delta x + O((\\Delta x)^2) $$\n    对流项的局部截断误差 $\\tau_{conv}^{UW}$ 是：\n    $$ \\tau_{conv}^{UW} = a \\left(\\frac{u_i - u_{i-1}}{\\Delta x}\\right) - a u'_i = a \\left(u'_i - \\frac{u''_i}{2}\\Delta x + O((\\Delta x)^2)\\right) - a u'_i $$\n    迎风格式的对流截断误差的首个非零项是：\n    $$ \\tau_{conv, leading}^{UW} = -a \\frac{u''(x_i)}{2}\\Delta x $$\n\n下一步是通过令这些主导误差的期望大小相等来找到阈值 $Pe^{\\ast}$。\n大小为：\n$$ |\\tau_{conv, leading}^{CD}| = \\left|a \\frac{u'''(x_i)}{6}(\\Delta x)^2\\right| = \\frac{a(\\Delta x)^2}{6}|u'''(x_i)| $$\n$$ |\\tau_{conv, leading}^{UW}| = \\left|-a \\frac{u''(x_i)}{2}\\Delta x\\right| = \\frac{a \\Delta x}{2}|u''(x_i)| $$\n切换条件是 $\\mathbb{E}[|\\tau_{conv, leading}^{CD}| \\,|\\, Pe^{\\ast}] = \\mathbb{E}[|\\tau_{conv, leading}^{UW}| \\,|\\, Pe^{\\ast}]$。\n$$ \\mathbb{E}\\left[\\frac{a(\\Delta x)^2}{6}|u'''(x_i)| \\,\\Big|\\, Pe^{\\ast}\\right] = \\mathbb{E}\\left[\\frac{a \\Delta x}{2}|u''(x_i)| \\,\\Big|\\, Pe^{\\ast}\\right] $$\n由于 $a$ 和 $\\Delta x$ 是常数，我们可以写成：\n$$ \\frac{a(\\Delta x)^2}{6}\\mathbb{E}[|u'''(x_i)| \\,|\\, Pe^{\\ast}] = \\frac{a \\Delta x}{2}\\mathbb{E}[|u''(x_i)| \\,|\\, Pe^{\\ast}] $$\n为了继续，我们使用所提供的数据驱动模型：\n$$ \\mathbb{E}\\!\\left[\\frac{|u^{(3)}(x_i)|}{|u''(x_i)|}\\,\\Big|\\,Pe\\right] = c\\, \\frac{Pe}{\\Delta x} $$\n其中 $c = 1.72$。设 $R = \\frac{|u^{(3)}(x_i)|}{|u''(x_i)|}$。那么 $|u'''(x_i)| = R \\cdot |u''(x_i)|$。取期望，我们得到 $\\mathbb{E}[|u'''(x_i)|] = \\mathbb{E}[R \\cdot |u''(x_i)|]$。在这个数据驱动的建模问题背景下，我们做一个合理的假设，即随机变量 $R$ 和 $|u''(x_i)|$ 是不相关的。因此，$\\mathbb{E}[R \\cdot |u''(x_i)|] \\approx \\mathbb{E}[R]\\mathbb{E}[|u''(x_i)|]$。将此应用于我们在阈值 $Pe^{\\ast}$ 处的等式：\n$$ \\frac{a(\\Delta x)^2}{6}\\mathbb{E}\\left[\\frac{|u'''(x_i)|}{|u''(x_i)|} \\,\\Big|\\, Pe^{\\ast}\\right]\\mathbb{E}[|u''(x_i)| \\,|\\, Pe^{\\ast}] = \\frac{a \\Delta x}{2}\\mathbb{E}[|u''(x_i)| \\,|\\, Pe^{\\ast}] $$\n假设解不是平凡的，$\\mathbb{E}[|u''(x_i)| \\,|\\, Pe^{\\ast}]$ 不为零，所以我们可以用它来除等式两边，同时也可以用 $\\frac{a \\Delta x}{2}$ 来除：\n$$ \\frac{\\Delta x}{3}\\mathbb{E}\\left[\\frac{|u'''(x_i)|}{|u''(x_i)|} \\,\\Big|\\, Pe^{\\ast}\\right] = 1 $$\n现在，我们在 $Pe = Pe^{\\ast}$ 处代入给定的条件期望模型：\n$$ \\frac{\\Delta x}{3} \\left(c \\frac{Pe^{\\ast}}{\\Delta x}\\right) = 1 $$\n简化表达式：\n$$ \\frac{c \\, Pe^{\\ast}}{3} = 1 $$\n求解阈值 Péclet 数 $Pe^{\\ast}$：\n$$ Pe^{\\ast} = \\frac{3}{c} $$\n给定拟合常数 $c = 1.72$，我们可以计算出 $Pe^{\\ast}$ 的数值：\n$$ Pe^{\\ast} = \\frac{3}{1.72} \\approx 1.7441860465... $$\n问题要求答案四舍五入到四位有效数字。\n$$ Pe^{\\ast} \\approx 1.744 $$", "answer": "$$\\boxed{1.744}$$", "id": "3430230"}, {"introduction": "理论和静态分析最终必须转化为能够处理瞬态问题的稳健、有效的代码。最后一个实践练习将挑战您实现一个能够根据瞬时佩克莱数动态调整其对流格式的求解器 [@problem_id:3430209]。通过让您的实现通过一套严格的测试，您将验证切换机制是否平滑无缝，避免了数值振荡或迟滞等常见陷阱，从而确保求解器在流场条件不断变化的模拟中的可靠性。", "problem": "考虑在周期性域 $x \\in [0,1]$ 上的被动标量场 $c(x,t)$ 的一维线性平流-扩散方程：\n$$\n\\frac{\\partial c}{\\partial t} + u(t)\\,\\frac{\\partial c}{\\partial x} = \\nu\\,\\frac{\\partial^2 c}{\\partial x^2},\n$$\n其中 $u(t)$ 是随时间变化的平流速度，$\\nu  0$ 是恒定的运动学扩散系数，并采用周期性边界条件。初始条件是一个以 $x_0$ 为中心、标准差为 $\\sigma$ 的局域化高斯层：\n$$\nc(x,0) = \\exp\\!\\left(-\\frac{d(x,x_0)^2}{2\\sigma^2}\\right), \\quad d(x,x_0) = \\min\\{|x-x_0|,\\,1-|x-x_0|\\}.\n$$\n网格使用包含 $N$ 个点的均匀网格，间距为 $\\Delta x = 1/N$。\n\n无量纲局部面 Péclet 数（Péclet 数）定义为\n$$\nPe(t) = \\frac{|u(t)|\\,\\Delta x}{\\nu}.\n$$\n平流项需要采用一种通量切换离散化方案。该方案必须在每个时间步根据 $Pe(t)$ 自主选择数值通量的类型（由于 $u(t)$ 在空间上是均匀的，所以该选择是全局的）：\n- 如果 $Pe(t)  1$，平流项使用中心通量，即在面 $i+\\tfrac{1}{2}$ 处，$F^{\\text{adv}}_{i+\\frac{1}{2}} = u(t)\\,\\frac{c_i + c_{i+1}}{2}$。\n- 如果 $Pe(t) \\ge 1$，平流项使用一阶迎风通量，即当 $u(t) \\ge 0$ 时 $F^{\\text{adv}}_{i+\\frac{1}{2}} = u(t)\\,c_i$，当 $u(t)  0$ 时 $F^{\\text{adv}}_{i+\\frac{1}{2}} = u(t)\\,c_{i+1}$。\n\n通过隐式-显式 (IMEX) 步长在时间上进行离散化：使用标准的周期性二阶差分算子对扩散项进行隐式处理，并使用所选通量类型的守恒通量差分对平流项进行显式处理。从时间层 $n$ 到 $n+1$，时间步长为 $\\Delta t$ 的半离散更新为\n$$\n\\frac{c^{n+1} - c^n}{\\Delta t} + \\mathcal{A}\\!\\left(u^n, c^n\\right) = \\nu\\,\\mathcal{D}\\,c^{n+1},\n$$\n其中 $\\mathcal{A}$ 是由所选面通量构成的离散平流散度，$\\mathcal{D}$ 是离散周期性拉普拉斯算子。使用满足 Courant 型限制的稳定自适应时间步长\n$$\n\\Delta t = C_{\\text{CFL}}\\min\\!\\left\\{\\frac{\\Delta x^2}{\\nu},\\,\\frac{\\Delta x}{\\max(|u(t)|, \\epsilon)}\\right\\},\n$$\n其中 $C_{\\text{CFL}} \\in (0,1)$ 是一个固定值，$\\epsilon$ 是一个小的正数，用以避免除以零。\n\n使用以下固定的数值参数实现上述方案：\n- $N = 256$，$\\nu = 10^{-3}$，$C_{\\text{CFL}} = 0.4$，$x_0 = 0.3$，$\\sigma = 0.03$。\n- 网格在 $[0,1]$ 上是周期且均匀的。\n\n验证目标：创建一个移动层的基准测试，其中 $Pe(t)$ 的值会穿过 1，并要求方案能自主切换通量类型。通过下面的测试套件，验证切换过程不会引入滞后效应或时间上的尖峰。\n\n测试套件规范。您的程序必须执行以下三个测试用例，并为每个用例返回一个布尔值：\n\n- 测试用例 1 (斜坡穿越，过冲检查)：设 $T_1 = 1$，$u(t) = U_{\\max}\\,\\sin\\!\\left(2\\pi t/T_1\\right)$，其中 $U_{\\max} = 0.6$。这个选择会强制 $Pe(t)$ 穿过 1。演化到时间 $t=T_1$。定义过冲度量\n$$\n\\mathcal{O} = \\max\\!\\{0,\\,\\max_x c(x,T_1) - 1\\} + \\max\\!\\{0,\\, -\\min_x c(x,T_1)\\}.\n$$\n如果 $\\mathcal{O} \\le 5\\times 10^{-3}$，则返回 $\\text{True}$，否则返回 $\\text{False}$。\n\n- 测试用例 2 (阈值切换，通过扩散一致性检验无滞后或尖峰)：设 $T_2 = 0.5$。定义 $u_{\\text{thr}} = \\nu/\\Delta x$。定义 $u_{\\text{low}} = 0.8\\,u_{\\text{thr}}$ 和 $u_{\\text{high}} = 1.2\\,u_{\\text{thr}}$。定义一个分段恒定的零均值切换速度，该速度在 $[0,T_2]$ 区间内以 $\\tau = 0.01$ 为周期，在序列 $\\{+u_{\\text{low}},-u_{\\text{low}},+u_{\\text{high}},-u_{\\text{high}}\\}$ 中循环。这将导致 $Pe(t)=1$ 被反复穿越，且净平流量为零。使用自主切换方案演化到 $t=T_2$。同时，使用相同的初始条件，但在 $u(t)\\equiv 0$（纯扩散）的情况下演化一个参考解至 $t=T_2$。设 $c_{\\text{tog}}(x,T_2)$ 为切换运行的结果，$c_{\\text{diff}}(x,T_2)$ 为纯扩散运行的结果。定义相对 $L^2$ 偏差\n$$\n\\mathcal{E} = \\frac{\\left(\\sum_i \\left[c_{\\text{tog}}(x_i,T_2)-c_{\\text{diff}}(x_i,T_2)\\right]^2\\right)^{1/2}}{\\left(\\sum_i \\left[c_{\\text{diff}}(x_i,T_2)\\right]^2\\right)^{1/2} + 10^{-14}}.\n$$\n如果 $\\mathcal{E} \\le 2\\times 10^{-2}$，则返回 $\\text{True}$，否则返回 $\\text{False}$。\n\n- 测试用例 3 (始终扩散主导，与强制中心格式等效性检验)：设 $T_3 = 0.5$，$u(t)\\equiv U_{\\text{small}}$，其中 $U_{\\text{small}} = 0.05$，使得对于所有 $t$ 都有 $Pe(t)  1$。使用自主切换方案（应始终选择中心通量）演化到 $t=T_3$。独立地，强制在所有时间都使用中心通量（无切换）演化到 $t=T_3$。设最终状态为 $c_{\\text{auto}}(x,T_3)$ 和 $c_{\\text{cent}}(x,T_3)$。定义无穷范数偏差\n$$\n\\Delta_{\\infty} = \\max_i \\left|c_{\\text{auto}}(x_i,T_3)-c_{\\text{cent}}(x_i,T_3)\\right|.\n$$\n如果 $\\Delta_{\\infty} \\le 10^{-12}$，则返回 $\\text{True}$，否则返回 $\\text{False}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\,\\text{result}_1,\\text{result}_2,\\text{result}_3\\,]$），其中每个 $\\text{result}_k$ 是测试用例 $k$ 按上述顺序的布尔结果。本问题中的所有量均为无量纲；输出中不需要物理单位。", "solution": "该问题要求数值求解周期域 $x \\in [0,1]$ 上的一维线性平流-扩散方程，\n$$\n\\frac{\\partial c}{\\partial t} + u(t)\\,\\frac{\\partial c}{\\partial x} = \\nu\\,\\frac{\\partial^2 c}{\\partial x^2},\n$$\n求解过程需要为平流项实现一个由局部 Péclet 数指导的通量切换方案，并采用隐式-显式 (IMEX) 时间积分方法。\n\n**空间离散化**\n空间域 $[0,1]$ 被离散化为 $N$ 个均匀的网格单元，单元中心位于 $x_i = i\\Delta x$（$i=0, \\dots, N-1$），其中 $\\Delta x = 1/N$。在 $(x_i, t)$ 处的离散浓度记为 $c_i(t)$。我们采用有限体积法，单元 $i$ 的半离散方程为：\n$$\n\\frac{d c_i}{dt} = -\\frac{F^{\\text{adv}}_{i+\\frac{1}{2}} - F^{\\text{adv}}_{i-\\frac{1}{2}}}{\\Delta x} + \\frac{F^{\\text{diff}}_{i+\\frac{1}{2}} - F^{\\text{diff}}_{i-\\frac{1}{2}}}{\\Delta x}\n$$\n扩散通量使用中心差分格式进行离散化，得到常见的离散拉普拉斯算子 $\\mathcal{D}$：\n$$\n\\left(\\mathcal{D}c\\right)_i = \\frac{c_{i+1} - 2c_i + c_{i-1}}{\\Delta x^2}\n$$\n平流通量 $F^{\\text{adv}}$ 通过一个依赖于 Péclet 数 $Pe(t) = \\frac{|u(t)|\\Delta x}{\\nu}$ 的切换方案来处理。该数值比较了一个网格单元上平流与扩散的速率。\n如果 $Pe(t)  1$，在网格尺度上扩散占主导，为保证精度，适合使用无耗散的中心通量：\n$$\nF^{\\text{adv}}_{i+\\frac{1}{2}} = u(t)\\,\\frac{c_i + c_{i+1}}{2}\n$$\n这将得到平流项的标准二阶中心差分：$(\\mathcal{A}c)_i = u(t)\\frac{c_{i+1}-c_{i-1}}{2\\Delta x}$。\n如果 $Pe(t) \\ge 1$，平流占主导，需要使用稳定的一阶迎风通量以防止非物理振荡：\n$$\nF^{\\text{adv}}_{i+\\frac{1}{2}} =\n\\begin{cases}\nu(t)\\,c_i  \\text{if } u(t) \\ge 0 \\\\\nu(t)\\,c_{i+1}  \\text{if } u(t)  0\n\\end{cases}\n$$\n这将分别得到平流项的一阶后向差分（当 $u \\ge 0$ 时）或前向差分（当 $u  0$ 时）：当 $u \\ge 0$ 时为 $(\\mathcal{A}c)_i = u(t)\\frac{c_i-c_{i-1}}{\\Delta x}$，当 $u  0$ 时为 $(\\mathcal{A}c)_i = u(t)\\frac{c_{i+1}-c_{i}}{\\Delta x}$。\n周期性边界条件通过对索引应用模运算来处理所有模板操作。\n\n**时间离散化与 IMEX 方案**\n半离散方程为 $ \\frac{dc}{dt} = -\\mathcal{A}(u,c) + \\nu \\mathcal{D}c $。这是一个常微分方程组。扩散项通常会引入刚性，导致显式方法需要过小的时间步长。平流项的时间步长限制则不那么严格。因此，IMEX 方案是理想的选择，它对平流项进行显式处理，对扩散项进行隐式处理。\n应用从时间 $t^n$ 到 $t^{n+1}=t^n+\\Delta t$ 的一阶 IMEX (Euler) 格式：\n$$\n\\frac{c^{n+1} - c^n}{\\Delta t} = -\\mathcal{A}(u(t^n), c^n) + \\nu \\mathcal{D}c^{n+1}\n$$\n重新整理以求解未知状态 $c^{n+1}$：\n$$\n(I - \\Delta t\\,\\nu\\,\\mathcal{D})c^{n+1} = c^n - \\Delta t\\,\\mathcal{A}(u^n, c^n)\n$$\n其中 $I$ 是单位算子，$u^n = u(t^n)$。\n\n**通过 FFT 求解隐式系统**\n关于 $c^{n+1}$ 的方程是一个线性系统。设系统矩阵为 $M = (I - \\Delta t\\,\\nu\\,D)$，其中 $D$ 是周期性离散拉普拉斯算子 $\\mathcal{D}$ 的矩阵表示。由于 $D$ 是一个循环矩阵，因此 $M$ 也是循环矩阵。此类系统可以在傅里叶空间中高效求解。\n设 $\\hat{c} = \\mathcal{F}(c)$ 表示离散傅里叶变换 (DFT)。根据卷积定理，在实空间中应用一个循环矩阵等价于在傅里叶空间中与其特征值进行逐元素相乘。\n离散拉普拉斯算子 $\\mathcal{D}$ 对每个傅里叶模态 $k$ 的特征值 $\\lambda_k$ 为：\n$$\n\\lambda_k = \\frac{2}{\\Delta x^2} \\left(\\cos\\left(\\frac{2\\pi k}{N}\\right) - 1\\right)\n$$\n将系统变换到傅里叶空间得到：\n$$\n(1 - \\Delta t\\,\\nu\\,\\lambda_k)\\hat{c}^{n+1}_k = \\mathcal{F}\\left(c^n - \\Delta t\\,\\mathcal{A}(u^n, c^n)\\right)_k\n$$\n这个对角系统对于每个傅里叶分量 $\\hat{c}^{n+1}_k$ 都可以轻易求解。然后通过逆离散傅里叶变换 (inverse DFT) 恢复解 $c^{n+1}$，即 $c^{n+1} = \\mathcal{F}^{-1}(\\hat{c}^{n+1})$。这种谱方法的每个时间步的计算复杂度为 $\\mathcal{O}(N\\log N)$，效率非常高。\n\n**自适应时间步长**\n显式平流处理的稳定性要求时间步长 $\\Delta t$ 满足 Courant-Friedrichs-Lewy (CFL) 条件，即 $\\Delta t \\lesssim \\Delta x/|u|$。尽管扩散项是隐式处理的（因此是无条件稳定的），但其时间尺度 $\\Delta t \\lesssim \\Delta x^2/\\nu$ 仍与精度相关。按照问题要求，我们使用一个同时满足这两种时间尺度限制的自适应时间步长：\n$$\n\\Delta t = C_{\\text{CFL}}\\min\\!\\left\\{\\frac{\\Delta x^2}{\\nu},\\,\\frac{\\Delta x}{\\max(|u(t)|, \\epsilon)}\\right\\}\n$$\n其中 $C_{\\text{CFL}} = 0.4$。小参数 $\\epsilon$ 用于防止当 $u(t)$ 接近零时发生除零错误。时间步长在每个步长的开始时重新计算。为确保精确达到最终时间，最后一个时间步长在必要时会被截断。\n\n**初始条件**\n初始条件是一个高斯脉冲，使用周期性距离度量来定义，以确保其在区域边界处是平滑的：\n$$\nc(x,0) = \\exp\\!\\left(-\\frac{d(x,x_0)^2}{2\\sigma^2}\\right), \\quad d(x,x_0) = \\min\\{|x-x_0|,\\,1-|x-x_0|\\}.\n$$\n\n**测试用例实现**\n基于上述原理实现了一个单一、鲁棒的求解器函数。该函数接受初始条件、速度剖面 $u(t)$ 的函数句柄以及最终积分时间 $T$。对于测试用例 3，添加一个模式以强制使用中心差分格式，从而绕过 Péclet 数的检查。然后通过使用为每个用例指定的特定参数（$u(t)$，$T$ 等）和验证逻辑调用此求解器来执行三个测试用例。结果被收集并按规定格式化。", "answer": "```python\nimport numpy as np\nfrom numpy.fft import fft, ifft\n\ndef solve():\n    \"\"\"\n    Main function to execute the test suite and print results.\n    \"\"\"\n    # --- Global constants from the problem statement ---\n    N = 256\n    NU = 1e-3\n    C_CFL = 0.4\n    X0 = 0.3\n    SIGMA = 0.03\n    EPSILON = 1e-14\n    DX = 1.0 / N\n\n    class PdeSolver:\n        \"\"\"\n        A solver for the 1D advection-diffusion equation using a flux-switching\n        IMEX scheme.\n        \"\"\"\n        def __init__(self, n_points, nu, cfl, epsilon, flux_mode='auto'):\n            self.N = n_points\n            self.nu = nu\n            self.C_CFL = cfl\n            self.epsilon = epsilon\n            self.dx = 1.0 / self.N\n            self.flux_mode = flux_mode\n\n            # Precompute eigenvalues for the implicit diffusion solver\n            k_freq = np.fft.fftfreq(self.N, d=self.dx)\n            # Eigenvalues of the discrete periodic Laplacian (2nd-order central diff)\n            self.laplacian_eigenvalues = 2 * (np.cos(2 * np.pi * k_freq * self.dx) - 1) / self.dx**2\n\n        def get_advection_divergence(self, c, u_t):\n            \"\"\"\n            Computes the advection term's spatial derivative using a flux-switching scheme.\n            \"\"\"\n            peclet = abs(u_t) * self.dx / self.nu\n            \n            use_centered = (peclet  1.0)\n            if self.flux_mode == 'force_central':\n                use_centered = True\n            \n            c_p1 = np.roll(c, -1)\n            c_m1 = np.roll(c, 1)\n\n            if use_centered:\n                # Centered difference for advection\n                adv_div = u_t * (c_p1 - c_m1) / (2 * self.dx)\n            else:\n                # First-order upwind difference for advection\n                if u_t >= 0:\n                    adv_div = u_t * (c - c_m1) / self.dx\n                else:\n                    adv_div = u_t * (c_p1 - c) / self.dx\n            return adv_div\n\n        def run(self, c0, u_func, T_final):\n            \"\"\"\n            Evolves the PDE from an initial condition c0 to a final time T_final.\n            \"\"\"\n            c = np.copy(c0)\n            t = 0.0\n\n            while t  T_final:\n                u_t = u_func(t)\n                \n                # Adaptive time step based on CFL-like conditions\n                dt_diff = self.dx**2 / self.nu\n                dt_adv = self.dx / max(abs(u_t), self.epsilon)\n                dt = self.C_CFL * min(dt_diff, dt_adv)\n                \n                if t + dt > T_final:\n                    dt = T_final - t\n                \n                if dt = 0:\n                    break\n\n                # Step 1: Explicit advection (forms the RHS of the IMEX scheme)\n                adv_div = self.get_advection_divergence(c, u_t)\n                rhs = c - dt * adv_div\n\n                # Step 2: Implicit diffusion (solved in Fourier space)\n                rhs_hat = fft(rhs)\n                c_hat_new = rhs_hat / (1.0 - self.nu * dt * self.laplacian_eigenvalues)\n                c_new = ifft(c_hat_new).real\n\n                c = c_new\n                t += dt\n                \n            return c\n\n    def setup_initial_condition(n_points, x0, sigma):\n        \"\"\"\n        Generates the periodic Gaussian initial condition.\n        \"\"\"\n        dx = 1.0 / n_points\n        x = np.arange(n_points) * dx\n        d = np.abs(x - x0)\n        d = np.minimum(d, 1.0 - d)\n        return np.exp(-d**2 / (2 * sigma**2))\n\n    def run_test_case_1():\n        \"\"\"\n        Test case 1: Ramp crossing, overshoot check.\n        \"\"\"\n        T1 = 1.0\n        U_max = 0.6\n        def u_func(t):\n            return U_max * np.sin(2 * np.pi * t / T1)\n\n        c0 = setup_initial_condition(N, X0, SIGMA)\n        solver = PdeSolver(N, NU, C_CFL, EPSILON, flux_mode='auto')\n        c_final = solver.run(c0, u_func, T1)\n        \n        overshoot = max(0, np.max(c_final) - 1.0) + max(0, -np.min(c_final))\n        return overshoot = 5e-3\n\n    def run_test_case_2():\n        \"\"\"\n        Test case 2: Toggle around threshold, consistency with pure diffusion.\n        \"\"\"\n        T2 = 0.5\n        tau = 0.01\n        u_thr = NU / DX\n        u_low = 0.8 * u_thr\n        u_high = 1.2 * u_thr\n        \n        def u_toggling_func(t):\n            t_cycle = t % (4 * tau)\n            if t_cycle  tau:\n                return u_low\n            elif t_cycle  2 * tau:\n                return -u_low\n            elif t_cycle  3 * tau:\n                return u_high\n            else:\n                return -u_high\n                \n        def u_zero_func(t):\n            return 0.0\n\n        c0 = setup_initial_condition(N, X0, SIGMA)\n        solver = PdeSolver(N, NU, C_CFL, EPSILON, flux_mode='auto')\n        \n        c_tog = solver.run(c0, u_toggling_func, T2)\n        c_diff = solver.run(c0, u_zero_func, T2)\n        \n        numerator = np.sqrt(np.sum((c_tog - c_diff)**2))\n        denominator = np.sqrt(np.sum(c_diff**2)) + 1e-14\n        error = numerator / denominator\n        \n        return error = 2e-2\n\n    def run_test_case_3():\n        \"\"\"\n        Test case 3: Always diffusive regime, equivalence to forced central scheme.\n        \"\"\"\n        T3 = 0.5\n        U_small = 0.05\n        \n        def u_func(t):\n            return U_small\n\n        c0 = setup_initial_condition(N, X0, SIGMA)\n        solver_auto = PdeSolver(N, NU, C_CFL, EPSILON, flux_mode='auto')\n        solver_central = PdeSolver(N, NU, C_CFL, EPSILON, flux_mode='force_central')\n        \n        c_auto = solver_auto.run(c0, u_func, T3)\n        c_cent = solver_central.run(c0, u_func, T3)\n        \n        discrepancy = np.max(np.abs(c_auto - c_cent))\n        \n        return discrepancy = 1e-12\n\n    test_cases = [\n        run_test_case_1,\n        run_test_case_2,\n        run_test_case_3\n    ]\n    results = [case() for case in test_cases]\n    \n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```", "id": "3430209"}]}