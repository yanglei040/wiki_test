{"hands_on_practices": [{"introduction": "对于非线性双曲型偏微分方程，其特征线的一个显著特性是它们可以相交，这会导致经典解的失效并形成激波。本练习将引导您通过分析著名的伯格斯方程 (Burgers' equation)，亲身体验预测这种解的破裂（即激波形成）的分析过程。掌握这一技能是理解为何需要发展更复杂的解理论（如弱解）的基石。[@problem_id:3369909]", "problem": "考虑标量守恒律，即无粘性Burgers偏微分方程 (PDE)，\n$$u_{t} + \\left(\\frac{u^{2}}{2}\\right)_{x} = 0 \\quad \\text{for} \\quad x \\in \\mathbb{R}, \\ t \\ge 0,$$\n其光滑初始数据为\n$$u(x,0) = u_{0}(x) = -A \\tanh(K x),$$\n其中 $A>0$ 和 $K>0$ 为常数。使用特征线法作为符合该问题的基本方法，论证点 $(x,t)$ 的依赖域与特征流之间的关系，然后确定古典解因特征线相交（激波形成）而失去正则性的最早时间 $t_{s}>0$。请以 $A$ 和 $K$ 的闭合形式给出 $t_{s}$。最终答案必须是单一的解析表达式，无需四舍五入。", "solution": "该问题旨在分析一个标量守恒律——无粘性Burgers方程的解，并确定在特定初始条件下激波形成的时间。\n\n控制偏微分方程 (PDE) 为：\n$$u_{t} + \\left(\\frac{u^{2}}{2}\\right)_{x} = 0 \\quad \\text{for} \\quad x \\in \\mathbb{R}, \\ t \\ge 0$$\n使用链式法则，我们可以将通量项写为 $(\\frac{u^2}{2})_x = \\frac{d}{du}(\\frac{u^2}{2}) \\frac{\\partial u}{\\partial x} = u u_x$。这将该PDE转换为其拟线性形式：\n$$u_{t} + u u_{x} = 0$$\n初始条件为一个光滑函数：\n$$u(x,0) = u_{0}(x) = -A \\tanh(K x)$$\n其中 $A$ 和 $K$ 是正常数，$A>0$ 且 $K>0$。\n\n特征线法是求解此类一阶双曲型PDE的基本工具。其拟线性形式 $u_t + c(u) u_x = 0$（在此，波速为 $c(u) = u$）表明，沿着由 $\\frac{dx}{dt} = c(u)$ 定义的曲线，$u$ 对时间的全导数为零。也就是说，\n$$\\frac{d}{dt} u(x(t), t) = u_{t} + u_{x} \\frac{dx}{dt} = u_{t} + u u_{x} = 0$$\n这意味着解 $u$ 沿着特征曲线是常数，而特征曲线由常微分方程 $\\frac{dx}{dt} = u$ 定义。\n由于 $u$ 沿每条特征线是常数，因此每条特征线的传播速度也是常数。所以，特征曲线是在 $(x,t)$ 平面上的直线。\n\n设一条特征曲线始于初始线上的一点 $(x_0, 0)$。沿着整条曲线的解的值由 $x_0$ 处的初始数据确定，即 $u(x(t), t) = u(x_0, 0) = u_0(x_0)$。那么该特征线的方程为：\n$$\\frac{dx}{dt} = u_{0}(x_0)$$\n将此方程对时间从 $0$ 到 $t$ 积分，得到特征线的显式方程：\n$$x(t) = x_{0} + u_{0}(x_0) t$$\n该方程隐式地定义了解 $u(x,t)$。为求出点 $(x,t)$ 处的 $u$ 值，必须求解方程 $x = x_0 + u_0(x_0) t$ 以得到起始点 $x_0$。解即为 $u(x,t) = u_0(x_0)$。\n\n点 $(x,t)$ 的依赖域是在初始数据曲面（$t=0$ 时）上影响点 $(x,t)$ 处解的点的集合。从特征方程可以明显看出，解 $u(x,t)$ 完全由通过点 $(x,t)$ 的特征线足点 $x_0$ 处的初始数据值唯一确定。因此，对于这个一阶双曲型问题，点 $(x,t)$ 的依赖域是初始线 $t=0$ 上的单点集 $\\{x_0\\}$。\n\n只要在给定的时间 $t$下，从 $x_0$到 $x$ 的映射是一一对应的，古典解就存在。当特征线相交时，这一条件便不再满足，导致出现物理上不可能的多值解。古典解的这种破坏被称为激波形成。\n当两条始于不同点 $x_{0,1}$ 和 $x_{0,2}$ 的特征线在同一点 $(x,t)$ 相遇时，就会发生相交。对于从 $x_0$ 和 $x_0 + dx_0$ 出发的两条无穷小邻近的特征线，它们的相交时间 $t$ 可以通过令其位置相等来求得：\n$$x_0 + u_0(x_0)t = (x_0 + dx_0) + u_0(x_0 + dx_0)t$$\n整理得：\n$$[u_0(x_0) - u_0(x_0 + dx_0)]t = dx_0$$\n$$t = \\frac{dx_0}{u_0(x_0) - u_0(x_0 + dx_0)} = -\\frac{1}{\\frac{u_0(x_0 + dx_0) - u_0(x_0)}{dx_0}}$$\n取极限 $dx_0 \\to 0$，从 $x_0$ 邻域出发的特征线的相交时间为：\n$$t(x_0) = -\\frac{1}{u_0'(x_0)}$$\n激波只能在 $t>0$ 时形成，这要求 $u_0'(x_0) < 0$。该条件意味着特征线是收敛的：一条从稍大初始位置 $x_0+dx_0$ 出发的特征线，其速度 $u_0(x_0+dx_0)$ 比从 $x_0$ 出发的特征线的速度更小（或更负），导致它们相互靠近。\n\n激波首次出现的时间，记为 $t_s$，是在所有使得 $u_{0}'(x_0)<0$ 的起始点 $x_0$ 上，这些相交时间中的最小值：\n$$t_{s} = \\min_{x_0 : u_{0}'(x_0)<0} \\left( -\\frac{1}{u_{0}'(x_0)} \\right)$$\n要找到最小的正 $t_s$，我们需要使分母 $u_0'(x_0)$ 成为绝对值最大的负数，这等价于寻找 $u_0'(x_0)$ 的全局最小值。\n$$t_s = \\frac{-1}{\\min_{x_0 \\in \\mathbb{R}} u_{0}'(x_0)}$$\n给定初始条件 $u_{0}(x) = -A \\tanh(K x)$。我们必须计算其导数 $u_0'(x)$。\n$$u_{0}'(x) = \\frac{d}{dx} \\left( -A \\tanh(K x) \\right)$$\n使用链式法则以及 $\\frac{d}{dz}\\tanh(z) = \\operatorname{sech}^2(z)$ 这一事实，我们得到：\n$$u_{0}'(x) = -A \\cdot (\\operatorname{sech}^2(K x)) \\cdot K = -AK \\operatorname{sech}^2(K x)$$\n由于 $A>0$ 且 $K>0$，乘积 $-AK$ 是负的。函数 $\\operatorname{sech}^2(y)$ 总是非负的。因此，对于所有 $x \\in \\mathbb{R}$ 都有 $u_0'(x) \\le 0$，这证实了特征线总是收敛的或（在无穷远处）是平行的。\n为求得激波时间 $t_s$，我们必须找到 $u_0'(x)$ 的最小值。当正项 $\\operatorname{sech}^2(Kx)$ 达到其最大值时，$u_0'(x)$ 将取得最小值。\n双曲正割函数 $\\operatorname{sech}(z) = \\frac{1}{\\cosh(z)}$ 在 $\\cosh(z)$ 取最小值时达到其最大值。$\\cosh(z)$ 的最小值为 $1$，出现在 $z=0$ 处。\n因此，$\\operatorname{sech}(Kx)$ 的最大值为 $1$，出现在 $Kx=0$ 即 $x=0$ 处。$\\operatorname{sech}^2(Kx)$ 的最大值也为 $1$，出现在 $x=0$ 处。\n因此，导数的最小值为：\n$$\\min_{x \\in \\mathbb{R}} u_{0}'(x) = -AK \\cdot \\max_{x \\in \\mathbb{R}}(\\operatorname{sech}^2(K x)) = -AK \\cdot 1 = -AK$$\n该最小值出现在 $x_0=0$ 处。这是初始剖面中负斜率最陡峭的点，也是特征线收敛速率最快的点。\n\n将此最小值代入激波形成时间的公式中：\n$$t_{s} = \\frac{-1}{\\min_{x_0 \\in \\mathbb{R}} u_{0}'(x_0)} = \\frac{-1}{-AK} = \\frac{1}{AK}$$\n由于 $A>0$ 且 $K>0$，激波时间 $t_s$ 是正的，这与预期相符。", "answer": "$$\\boxed{\\frac{1}{AK}}$$", "id": "3369909"}, {"introduction": "从连续的偏微分方程世界过渡到离散的数值计算世界时，我们必须确保数值格式的结构能够“尊重”方程本身的物理特性。本练习的核心是探索这一原则，即数值格式的计算模板 (stencil) 如何与偏微分方程的物理依赖域 (domain of dependence) 相关联。通过分析著名的 Courant-Friedrichs-Lewy (CFL) 条件，您将从几何角度理解为何必须限制时间步长与空间步长的比率，以确保数值解的收敛性。[@problem_id:3369972]", "problem": "考虑标量线性双曲偏微分方程 $u_t + a\\,u_x = 0$，其中特征速度 $a \\in \\mathbb{R}$ 为常数，该方程定义在间距为 $\\Delta x > 0$ 的均匀网格上，并采用步长为 $\\Delta t > 0$ 的显式时间步进方法。对于一个点 $(x_i, t_N)$（其中 $t_N = N\\,\\Delta t$），其连续依赖域是由特征曲线 $x(t) = x_i - a\\,t$ 决定的单个点 $(x_i - a\\,t_N, 0)$。在线性显式有限差分法中，数值更新可以写为\n$$\nu_i^{n+1} = \\sum_{s \\in \\mathcal{S}} \\alpha_s\\,u_{i+s}^n,\n$$\n其中 $\\mathcal{S}$ 是定义模板的整数偏移量集合，而 $\\alpha_s$ 是满足相容性约束的、与方法相关的系数。$u_0^N$ 的数值依赖域是指在时间层 $n=0$ 上的所有网格索引的集合，这些索引上的值可以通过重复应用更新关系 $N$ 步来影响 $u_0^N$。该集合由 $\\mathcal{S}$ 中元素的所有 $N$ 次求和生成，其在 $N$ 步后的极端索引为\n$$\ni_{\\min}(N) = N\\,\\min(\\mathcal{S}),\\qquad i_{\\max}(N) = N\\,\\max(\\mathcal{S}).\n$$\n$N$ 步后的数值影响包络是从 $i_{\\min}(N)$ 到 $i_{\\max}(N)$ 的空间范围，其物理宽度为\n$$\nW_{\\text{num}}(N) = \\left(i_{\\max}(N) - i_{\\min}(N)\\right)\\,\\Delta x.\n$$\nCourant–Friedrichs–Lewy (CFL) 条件要求 $\\Delta t \\le C\\,\\Delta x/\\max|\\lambda|$，其中 $\\lambda$ 表示双曲系统的特征速度，而 $C$ 是一个与方法相关的常数。对于上述标量方程，$\\max|\\lambda| = |a|$。您的任务是：\n- 从第一性原理推导 CFL 条件如何界定数值依赖域，即当遵守一个依赖于格式的 $C$ 的界时，连续依赖域点 $(x_0 - a\\,t_N, 0)$ 位于数值影响包络之内。\n- 构建并比较两种具有相同 CFL 参数 $C$ 但模板不同的显式格式：\n  1. 紧致迎风模板 $\\mathcal{S}_{\\mathrm{c}} = \\{0,-1\\}$。\n  2. 宽迎风模板 $\\mathcal{S}_{\\mathrm{w}} = \\{0,-1,-2,-3\\}$。\n- 对每种格式，量化其在 $N$ 步后的有效数值域宽度 $W_{\\text{num}}(N)$，并将其与连续依赖域传播距离 $D_{\\text{cont}}(N) = |a|\\,N\\,\\Delta t$ 进行比较。\n\n在无量纲单位下进行计算，以便所有量都是纯数。使用以下参数值测试套件，它探索了典型情况、边界条件和边缘情况：\n1. $(a,\\Delta x,C,N) = (1.0,\\,1.0,\\,0.8,\\,10)$。\n2. $(a,\\Delta x,C,N) = (0.5,\\,0.5,\\,1.0,\\,1)$。\n3. $(a,\\Delta x,C,N) = (1.0,\\,1.0,\\,1.0,\\,5)$。\n4. $(a,\\Delta x,C,N) = (1.0,\\,1.0,\\,1.2,\\,5)$。\n5. $(a,\\Delta x,C,N) = (1.0,\\,1.0,\\,0.7,\\,0)$。\n\n对每个测试用例，计算：\n- 紧致格式的宽度 $W_{\\text{num,c}}(N)$。\n- 宽格式的宽度 $W_{\\text{num,w}}(N)$。\n- 连续传播距离 $D_{\\text{cont}}(N)$。\n- 对每种格式，计算一个布尔标志，指示连续依赖域位置是否位于该格式的数值影响包络内（对于 $a>0$，这简化为检查左侧影响范围 $R_{\\text{left}}(N) = -i_{\\min}(N)\\,\\Delta x$ 是否满足 $R_{\\text{left}}(N) \\ge D_{\\text{cont}}(N)$）。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个测试用例贡献一个形式为\n$$\n[W_{\\text{num,c}},W_{\\text{num,w}},D_{\\text{cont}},\\text{inside\\_compact},\\text{inside\\_wide}],\n$$\n的内部列表，最终的聚合输出必须是这些内部列表组成的单个列表，且列表内没有空格。例如，包含两个测试用例的输出应如下所示：\n$$\n[[w_c^{(1)},w_w^{(1)},d^{(1)},b_c^{(1)},b_w^{(1)}],[w_c^{(2)},w_w^{(2)},d^{(2)},b_c^{(2)},b_w^{(2)}]].\n$$", "solution": "该问题要求推导 Courant-Friedrichs-Lewy (CFL) 条件与线性双曲偏微分方程的依赖域之间的关系，然后对两种特定的有限差分格式进行定量分析。\n\n**1. 几何 CFL 条件的推导**\n\n给定的偏微分方程 (PDE) 是标量线性平流方程：\n$$\nu_t + a\\,u_x = 0\n$$\n其中 $a \\in \\mathbb{R}$ 是恒定的特征速度。特征线是 $(x,t)$ 平面上的线，沿着这些线解 $u$ 是常数。它们由常微分方程 $\\frac{dx}{dt} = a$ 定义。其解为 $x(t) = x(0) + a\\,t$。这意味着在时间 $t=0$ 时位于位置 $x(0)$ 的信号，在时间 $t$ 会传播到位置 $x(t)$。\n\n一个点 $(x_i, t_N)$ 的**连续依赖域**是在时间 $t=0$ 时影响 $(x_i, t_N)$ 处解的点的集合。从 $(x_i, t_N)$ 沿特征线向后追溯时间，我们发现在 $t=0$ 时的影响点位于位置 $x_0 = x_i - a\\,t_N$。在时间间隔 $t_N$ 内，特征信息的传播距离为 $D_{\\text{cont}} = |a\\,t_N|$。\n\n线性显式有限差分格式在间距为 $\\Delta x$、时间步长为 $\\Delta t$ 的网格上近似求解。其更新规则如下：\n$$\nu_i^{n+1} = \\sum_{s \\in \\mathcal{S}} \\alpha_s\\,u_{i+s}^n\n$$\n其中 $\\mathcal{S}$ 是模板。经过一个时间步后，网格点 $i$ 的值取决于前一时间层上集合 $\\{i+s \\mid s \\in \\mathcal{S}\\}$ 中的点。经过 $N$ 步后，值 $u_i^N$ 取决于初始值 $u_j^0$，其中索引 $j$ 的范围是 $[i + N\\min(\\mathcal{S}), i + N\\max(\\mathcal{S})]$。\n\n点 $(x_i, t_N)$ 的**数值依赖域**是在 $t=0$ 时包含所有影响 $u_i^N$ 的网格点的空间区间。相对于 $x_i$，该区间为 $[i_{\\min}(N)\\Delta x, i_{\\max}(N)\\Delta x]$，其中 $i_{\\min}(N) = N\\min(\\mathcal{S})$ 且 $i_{\\max}(N) = N\\max(\\mathcal{S})$。此数值影响包络的宽度为 $W_{\\text{num}}(N) = (i_{\\max}(N) - i_{\\min}(N))\\Delta x$。\n\n基本的 Courant-Friedrichs-Lewy (CFL) 条件规定，对于一个收敛的数值格式，连续依赖域必须被包含在数值依赖域之内。对于点 $(x_i, t_N)$，这意味着物理点 $x_i - a\\,t_N$ 必须位于物理区间 $[x_i + i_{\\min}(N)\\Delta x, x_i + i_{\\max}(N)\\Delta x]$ 内。\n$$\nx_i + N\\min(\\mathcal{S})\\Delta x \\le x_i - a\\,t_N \\le x_i + N\\max(\\mathcal{S})\\Delta x\n$$\n减去 $x_i$ 并代入 $t_N = N\\Delta t$：\n$$\nN\\min(\\mathcal{S})\\Delta x \\le -a\\,N\\Delta t \\le N\\max(\\mathcal{S})\\Delta x\n$$\n对于 $N>0$，我们可以除以 $N\\Delta x$：\n$$\n\\min(\\mathcal{S}) \\le -a\\,\\frac{\\Delta t}{\\Delta x} \\le \\max(\\mathcal{S})\n$$\n令 Courant 数为 $\\nu = a\\frac{\\Delta t}{\\Delta x}$。该条件变为 $\\min(\\mathcal{S}) \\le -\\nu \\le \\max(\\mathcal{S})$，或等价地，$-\\max(\\mathcal{S}) \\le \\nu \\le -\\min(\\mathcal{S})$。\n\n所有测试用例都具有 $a>0$，且问题指定了偏向负索引的“迎风”模板。这意味着 $\\max(\\mathcal{S})=0$。因此，CFL 条件简化为：\n$$\n0 \\le \\nu \\le -\\min(\\mathcal{S})\n$$\n第一个不等式 $0 \\le \\nu$ 在 $a>0$、$\\Delta t>0$ 和 $\\Delta x>0$ 时总是满足的。关键部分是第二个不等式 $\\nu \\le -\\min(\\mathcal{S})$。问题使用参数 $C$ 将 CFL 条件定义为 $\\Delta t \\le C\\,\\Delta x/|a|$，这对于 $a>0$ 等价于 $\\nu \\le C$。因此，当且仅当所选参数 $C$ 满足 $C \\le -\\min(\\mathcal{S})$ 时，几何包含条件才被满足。\n\n**2. 指定格式的分析**\n\n对于两种格式，我们都使用给定参数 $C$ 所允许的最大时间步长，即 $\\Delta t = C\\,\\Delta x/|a|$。对于 $a>0$，这即是 $\\Delta t = C\\,\\Delta x/a$。连续传播距离为 $D_{\\text{cont}}(N) = |a|\\,N\\,\\Delta t = a\\,N(C\\,\\Delta x/a) = NC\\Delta x$。\n\n**格式 1：紧致迎风模板**\n- 模板: $\\mathcal{S}_{\\mathrm{c}} = \\{0, -1\\}$。\n- 模板边界: $\\min(\\mathcal{S}_{\\mathrm{c}}) = -1$, $\\max(\\mathcal{S}_{\\mathrm{c}}) = 0$。\n- $N$ 步后的极端索引: $i_{\\min,c}(N) = -N$, $i_{\\max,c}(N) = 0$。\n- 数值宽度: $W_{\\text{num,c}}(N) = (i_{\\max,c}(N) - i_{\\min,c}(N))\\Delta x = (0 - (-N))\\Delta x = N\\Delta x$。\n- 包含条件: 连续点 $x_i - a\\,t_N$ 必须在数值包络内。对于 $a>0$，我们检查数值格式的左向范围是否足够。左向范围是 $R_{\\text{left,c}}(N) = -i_{\\min,c}(N)\\Delta x = N\\Delta x$。条件是 $R_{\\text{left,c}}(N) \\ge D_{\\text{cont}}(N)$，即 $N\\Delta x \\ge NC\\Delta x$，或 $1 \\ge C$。\n\n**格式 2：宽迎风模板**\n- 模板: $\\mathcal{S}_{\\mathrm{w}} = \\{0, -1, -2, -3\\}$。\n- 模板边界: $\\min(\\mathcal{S}_{\\mathrm{w}}) = -3$, $\\max(\\mathcal{S}_{\\mathrm{w}}) = 0$。\n- $N$ 步后的极端索引: $i_{\\min,w}(N) = -3N$, $i_{\\max,w}(N) = 0$。\n- 数值宽度: $W_{\\text{num,w}}(N) = (i_{\\max,w}(N) - i_{\\min,w}(N))\\Delta x = (0 - (-3N))\\Delta x = 3N\\Delta x$。\n- 包含条件: 左向范围是 $R_{\\text{left,w}}(N) = -i_{\\min,w}(N)\\Delta x = 3N\\Delta x$。条件 $R_{\\text{left,w}}(N) \\ge D_{\\text{cont}}(N)$ 变为 $3N\\Delta x \\ge NC\\Delta x$，或 $3 \\ge C$。\n\n**3. 测试用例的计算**\n\n对于每个测试用例 $(a, \\Delta x, C, N)$，我们计算以下量：\n1.  $W_{\\text{num,c}}(N) = N\\Delta x$\n2.  $W_{\\text{num,w}}(N) = 3N\\Delta x$\n3.  $D_{\\text{cont}}(N) = NC\\Delta x$\n4.  `inside_compact`: 一个布尔标志，如果 $C \\le 1$ 则为 `True`，否则为 `False`。\n5.  `inside_wide`: 一个布尔标志，如果 $C \\le 3$ 则为 `True`，否则为 `False`。\n\n这些公式在提供的 Python 脚本中实现，以生成最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating numerical domain widths and\n    checking CFL inclusion for two finite difference schemes.\n    \"\"\"\n    # Define the test cases from the problem statement:\n    # Each case is a tuple (a, delta_x, C, N).\n    test_cases = [\n        (1.0, 1.0, 0.8, 10),\n        (0.5, 0.5, 1.0, 1),\n        (1.0, 1.0, 1.0, 5),\n        (1.0, 1.0, 1.2, 5),\n        (1.0, 1.0, 0.7, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, delta_x, C, N = case\n\n        # For the compact upwind scheme, S_c = {0, -1}\n        # min(S_c) = -1, max(S_c) = 0\n        # The numerical domain width is (max - min) * N * delta_x\n        # W_num_c = (0 - (-1)) * N * delta_x = N * delta_x\n        w_num_c = float(N * delta_x)\n\n        # For the wide upwind scheme, S_w = {0, -1, -2, -3}\n        # min(S_w) = -3, max(S_w) = 0\n        # The numerical domain width is (max - min) * N * delta_x\n        # W_num_w = (0 - (-3)) * N * delta_x = 3 * N * delta_x\n        w_num_w = float(3 * N * delta_x)\n\n        # The continuum travel distance is D_cont = |a| * N * delta_t.\n        # We use delta_t = C * delta_x / |a|.\n        # So, D_cont = |a| * N * (C * delta_x / |a|) = N * C * delta_x\n        d_cont = float(N * C * delta_x)\n\n        # The CFL inclusion condition is that the continuum domain of dependence\n        # must lie within the numerical domain of dependence.\n        # As derived, this is equivalent to C = -min(S).\n\n        # For the compact scheme, -min(S_c) = 1. The inclusion condition is C = 1.\n        inside_compact = (C = 1.0)\n\n        # For the wide scheme, -min(S_w) = 3. The inclusion condition is C = 3.\n        inside_wide = (C = 3.0)\n\n        # Assemble the results for the current test case.\n        case_result = [w_num_c, w_num_w, d_cont, inside_compact, inside_wide]\n        results.append(case_result)\n\n    # The final output must be a single string representing a list of lists,\n    # with no spaces.\n    final_output_string = str(results).replace(\" \", \"\")\n\n    print(final_output_string)\n\nsolve()\n```", "id": "3369972"}, {"introduction": "虽然满足CFL条件可以保证数值格式的稳定性，但离散化过程往往会引入一些非物理的人为效应 (artifacts)，其中最重要的一种就是数值耗散 (numerical diffusion)。本练习将通过计算并分析一阶迎风格式的离散格林函数 (discrete Green's function)，让您直观地看到一个初始的尖锐信号是如何被数值格式“涂抹”开的。您将定量地分析这种涂抹效应如何导致信息在数值上以比真实特征速度更快的速度传播。[@problem_id:3369903]", "problem": "要求您构建一个程序，用于计算和分析常系数线性平流方程的一阶线性迎风有限差分法 (FDM) 的离散格林函数。请完全在无量纲环境下工作；不需要物理单位。\n\n控制偏微分方程为线性平流方程\n$$\nu_t + c\\,u_x = 0,\n$$\n其中平流速度 $c \\in \\mathbb{R}$ 为常数。考虑一个间距为 $\\Delta x  0$ 的均匀空间网格和一个均匀时间步长 $\\Delta t  0$。令 Courant–Friedrichs–Lewy (CFL) 数为 $\\lambda = \\dfrac{c\\,\\Delta t}{\\Delta x}$。假设采用标准的单调迎风 FDM：\n- 如果 $c  0$，则更新公式为\n$$\nu_j^{n+1} = u_j^n - \\lambda\\left(u_j^n - u_{j-1}^n\\right) = (1-\\lambda)u_j^n + \\lambda u_{j-1}^n.\n$$\n- 如果 $c  0$，则更新公式为\n$$\nu_j^{n+1} = u_j^n - \\lambda\\left(u_{j+1}^n - u_j^n\\right) = (1-|\\lambda|)u_j^n + |\\lambda| u_{j+1}^n.\n$$\n假设 $|\\lambda| \\le 1$ 以确保稳定性和单调性。离散格林函数 $G_j^n$ 定义为从脉冲初始数据 $u_j^0 = \\delta_{j,j_0}$ 得到的数值解，其中 $\\delta_{j,j_0}$ 是克罗内克 δ (Kronecker delta)，$j_0$ 是一个固定的网格索引。\n\n对于连续方程，有限的传播速度产生了一个解析前向锥约束：从初始点 $x_0 = j_0 \\Delta x$ 出发，在时间 $t^n = n\\,\\Delta t$ 可达的点集受 $s\\,(x-x_0) \\le |c|\\,t^n$ 约束，其中 $s = \\mathrm{sign}(c)$ 且 $|\\cdot|$ 表示绝对值。在网格上，这个解析前向锥转化为索引约束\n$$\ns\\,(j - j_0) \\le |\\lambda|\\,n.\n$$\n引入赫维赛德函数 (Heaviside function) $H(z)$，定义为若 $z0$ 则 $H(z)=1$，否则 $H(z)=0$。将时间层 $n$ 的“解析锥边界之外的离散溢出”定义为\n$$\nE(n) \\equiv \\sum_{j \\in \\mathbb{Z}} G_j^n\\, H\\!\\left( s\\,(j - j_0) - |\\lambda|\\,n \\right).\n$$\n这个 $E(n)$ 是一个非负实数，它衡量了离散格林函数对解析传播速度约束的违反程度，其意义在于表示在时间 $t^n$ 时，严格位于解析锥边界之外的质量分数。\n\n您的任务是：\n- 在一个具有 $N$ 个点的足够大的一维网格上，通过给定的迎风格式数值构建 $G_j^n$，并对计算域外的点使用零值。使用 $N = 2048$ 和 $j_0 = N/2$。确保所选的测试用例使演化中的支撑集与边界保持足够远的距离，从而使边界截断不影响离散解。\n- 对于每个测试用例，计算并返回最终时间层 $n$ 的单个标量值 $E(n)$。\n\n程序必须是自包含的，并且无需用户输入即可为以下测试套件生成结果。每个测试用例是一个四元组 $(c,\\Delta x,\\Delta t,n)$：\n- 测试 A (具有非平凡扩散的通用“理想路径”)：$(c,\\Delta x,\\Delta t,n) = (\\,1,\\;1,\\;\\frac{1}{4},\\;40\\,)$。\n- 测试 B (具有精确位移、无数值扩散的边界情况)：$(c,\\Delta x,\\Delta t,n) = (\\,1,\\;1,\\;1,\\;40\\,)$。\n- 测试 C (负平流速度，非平凡扩散)：$(c,\\Delta x,\\Delta t,n) = (\\,-\\frac{1}{2},\\;1,\\;0.6,\\;50\\,)$。\n- 测试 D (中等 CFL 数下的更长演化)：$(c,\\Delta x,\\Delta t,n) = (\\,2,\\;1,\\;0.2,\\;100\\,)$。\n\n您的程序应生成单行输出，按顺序包含测试 A、B、C 和 D 的 $E(n)$ 值，格式为用方括号括起来的逗号分隔列表（例如，$[result\\_A,result\\_B,result\\_C,result\\_D]$）。答案必须是实数。\n\n设计要求和约束：\n- 使用 $G_j^n$ 的定义，即从 $u_j^0 = \\delta_{j,j_0}$ 开始，将离散格式演化 $n$ 步得到的数值脉冲响应。\n- 使用上面给出的 $E(n)$ 的定义，其中 $s = \\mathrm{sign}(c)$ 且 $|\\lambda| = \\left|\\dfrac{c\\,\\Delta t}{\\Delta x}\\right|$。\n- 计算必须是确定性的，不依赖任何外部数据或用户输入。", "solution": "该问题具有科学依据，是适定的，并且其所有参数都已完全指定。控制方程、数值格式以及待计算的度量都是偏微分方程数值分析中的标准概念。稳定性条件 $|\\lambda| \\le 1$ 对所有测试用例都满足。计算域足够大，可以防止边界效应对结果产生影响，符合题目要求。因此，该问题被认为是有效的。\n\n问题的核心是计算一阶迎风格式的离散格林函数 $G_j^n$，然后用它来评估一个特定的度量 $E(n)$，该度量量化了数值扩散。\n\n控制方程是线性平流方程 $u_t + c\\,u_x = 0$，其中 $u(x,t)$ 是一个标量，而 $c \\in \\mathbb{R}$ 是恒定的平流速度。我们在空间步长为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格上对此方程进行离散化。网格点 $j$ 和时间层 $n$ 的数值解记为 $u_j^n$。Courant–Friedrichs–Lewy (CFL) 数是 $\\lambda = \\frac{c\\,\\Delta t}{\\Delta x}$。\n\n迎风有限差分法具体如下：\n如果平流速度为正 ($c  0$)，信息从左向右流动。格式为：\n$$\nu_j^{n+1} = u_j^n - \\lambda\\left(u_j^n - u_{j-1}^n\\right) = (1-\\lambda)u_j^n + \\lambda u_{j-1}^n\n$$\n如果平流速度为负 ($c  0$)，信息从右向左流动。格式为：\n$$\nu_j^{n+1} = u_j^n - \\lambda\\left(u_{j+1}^n - u_j^n\\right)\n$$\n注意到当 $c  0$ 时，$\\lambda  0$，我们可以写成 $\\lambda = -|\\lambda|$，因此格式变为：\n$$\nu_j^{n+1} = (1+\\lambda)u_j^n - \\lambda u_{j+1}^n = (1-|\\lambda|)u_j^n + |\\lambda| u_{j+1}^n\n$$\n在条件 $|\\lambda| \\le 1$ 下，这些格式是稳定且单调的。\n\n离散格林函数 $G_j^n$ 是该数值格式对初始脉冲的响应。我们从初始条件 $u_j^0 = \\delta_{j,j_0}$ 开始，其中克罗内克 δ $\\delta_{j,j_0}$ 在特定索引 $j_0$ 处为 1，在其他所有地方为 0。计算域是一个包含 $N=2048$ 个点的有限网格，索引从 $j=0$ 到 $N-1$。初始脉冲放置在中心，$j_0 = N/2 = 1024$。题目指定对该域外的网格点使用零值，这在实现格式时转化为零-狄利克雷 (zero-Dirichlet) 边界条件。例如，在 $c0$ 的情况下更新 $j=0$ 处的值时，$u_{-1}^n$ 的值取为 0。\n\n求解算法通过从初始脉冲 $u_j^0 = \\delta_{j,1024}$ 开始，迭代应用相应的迎风格式共 $n$ 个时间步来进行。在每一步，新的状态向量 $u^{n+1}$ 由当前状态 $u^n$ 计算得出。使用当前状态的临时副本来确保新时间层的所有更新都基于相同的、完整的旧时间层。经过 $n$ 步后，得到的网格函数 $u_j^n$ 就是所求的离散格林函数 $G_j^n$。\n\n一旦计算出 $G_j^n$，最后一步就是计算溢出度量 $E(n)$。该度量定义为：\n$$\nE(n) \\equiv \\sum_{j=0}^{N-1} G_j^n\\, H\\!\\left( s\\,(j - j_0) - |\\lambda|\\,n \\right)\n$$\n此处，$s = \\mathrm{sign}(c)$ 是平流速度的符号。赫维赛德函数的参数 $z = s\\,(j - j_0) - |\\lambda|\\,n$ 决定了网格点 $j$ 是否严格位于从 $x_0 = j_0 \\Delta x$ 出发的解析特征线之外。解析解以速度 $c$ 传播，因此在时间 $t^n = n\\,\\Delta t$，波前应位于 $x = x_0 + c t^n$，这在网格上对应于索引偏移 $\\frac{c t^n}{\\Delta x} = \\frac{c (n \\Delta t)}{\\Delta x} = \\lambda n = s |\\lambda| n$。因此，溢出条件 $s(j - j_0)  |\\lambda| n$ 识别出所有“领先”于此特征波前的网格点 $j$。\n\n赫维赛德函数 $H(z)$ 定义为当 $z0$ 时为 $1$，否则为 $0$。它起到滤波器的作用，因此 $E(n)$ 的求和仅包括这些溢出网格点上的“质量”（即 $G_j^n$ 的值）。对所提供的四个测试用例中的每一个都执行此过程，并收集所得的 $E(n)$ 值。\n\n在实现上，使用 `numpy` 的向量化方法是高效的。对于 $c0$ 的时间步进，可以通过对数组切片 `u[1:]` 和 `u[:-1]` 进行操作来实现，并对边界点 `u[0]` 进行单独更新。类似的方法也适用于 $c0$ 的情况。$E(n)$ 的最终计算涉及从赫维赛德函数的参数创建一个布尔掩码，并与最终的 $G_j^n$ 向量进行点积运算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_spillover(c, delta_x, delta_t, n_final):\n    \"\"\"\n    Computes the discrete Green's function and the spillover metric E(n).\n\n    Args:\n        c (float): Advection speed.\n        delta_x (float): Spatial grid spacing.\n        delta_t (float): Time step.\n        n_final (int): Number of time steps to evolve.\n\n    Returns:\n        float: The spillover metric E(n) at the final time step.\n    \"\"\"\n    N = 2048\n    j0 = N // 2\n\n    # Initialize the grid with the discrete impulse (Kronecker delta).\n    u = np.zeros(N, dtype=np.float64)\n    u[j0] = 1.0\n\n    # Calculate CFL number and sign of c.\n    lambda_val = c * delta_t / delta_x\n    s = np.sign(c)\n\n    # Time-stepping loop to construct the Green's function G_j^n.\n    for _ in range(n_final):\n        # Use a copy of u to ensure updates are based on the complete state at time n.\n        u_old = u.copy()\n        \n        if c > 0:\n            # Upwind scheme for c > 0: u_j^{n+1} = (1-lambda)u_j^n + lambda*u_{j-1}^n\n            # Update interior points j=1,...,N-1\n            u[1:] = (1.0 - lambda_val) * u_old[1:] + lambda_val * u_old[:-1]\n            # Update boundary point j=0, where u_{-1}^n is 0.\n            u[0] = (1.0 - lambda_val) * u_old[0]\n        elif c  0:\n            abs_lambda = abs(lambda_val)\n            # Upwind scheme for c  0: u_j^{n+1} = (1-|lambda|)u_j^n + |lambda|*u_{j+1}^n\n            # Update interior points j=0,...,N-2\n            u[:-1] = (1.0 - abs_lambda) * u_old[:-1] + abs_lambda * u_old[1:]\n            # Update boundary point j=N-1, where u_{N}^n is 0.\n            u[-1] = (1.0 - abs_lambda) * u_old[-1]\n        # If c = 0, lambda = 0, u remains unchanged, which is the correct behavior.\n\n    # At this point, u contains the values of the discrete Green's function G_j^n\n    # at the final time step n_final.\n\n    # Compute the spillover metric E(n).\n    j_indices = np.arange(N)\n    abs_lambda = abs(lambda_val)\n\n    # Calculate the argument of the Heaviside function for all j.\n    # z = s*(j - j0) - |lambda|*n\n    heaviside_arg = s * (j_indices - j0) - abs_lambda * n_final\n\n    # Create the Heaviside mask. H(z)=1 if z>0, and 0 otherwise.\n    heaviside_mask = (heaviside_arg > 0).astype(np.float64)\n\n    # E(n) is the sum of G_j^n over the indices where the mask is 1.\n    E_n = np.sum(u * heaviside_mask)\n\n    return E_n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (c, delta_x, delta_t, n_final)\n    test_cases = [\n        (1.0, 1.0, 0.25, 40),      # Test A\n        (1.0, 1.0, 1.0, 40),       # Test B\n        (-0.5, 1.0, 0.6, 50),      # Test C\n        (2.0, 1.0, 0.2, 100),      # Test D\n    ]\n\n    results = []\n    for case in test_cases:\n        c, delta_x, delta_t, n_final = case\n        result = compute_spillover(c, delta_x, delta_t, n_final)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3369903"}]}