{"hands_on_practices": [{"introduction": "理论学习之后，我们首先通过一个基础实践来巩固核心概念。这个练习将从最基本的物理定律出发，推导连接两个相邻控制体积的传递率，这是双点通量近似（TPFA）方法的心脏。通过亲手推导并分析其对几何参数的敏感性，你将深刻理解传递率公式的物理意义及其在离散化过程中的核心作用 [@problem_id:3377678]。", "problem": "考虑一个非均匀介质中的稳态扩散方程，其导率为各向同性、分片常数，表示为 $\\nabla \\cdot (k \\nabla u) = 0$，其中 $u$ 是标量势（例如，以开尔文 (K) 为单位的温度），$k$ 是导率（例如，以瓦特每米开尔文 ($\\text{W}/(\\text{m}\\cdot \\text{K})$) 为单位的热导率）。两个相邻的凸控制体（单元），索引为 $i$ 和 $j$，共享一个面积为 $|F|$ 平方米 ($\\text{m}^2$) 的平面界面（面）。设 $d_i$ 和 $d_j$ 分别是单元 $i$ 和 $j$ 的中心沿其法线方向到共享面的垂直距离，单位为米 ($\\text{m}$)。假设两点通量近似适用：势 $u$ 沿着连接两个单元中心的直线线性变化，并且穿过界面的通量可以使用一个耦合两个单元中心未知量的标量导通率来表示。\n\n从基本守恒定律和 Fick/Fourier 型本构关系 $q = -k \\nabla u$ 出发，在上述假设下，推导穿过界面 $F$ 的单元 $i$ 和 $j$ 之间的导通率。将穿过 $F$ 的通量 $q_F$ 表示为 $q_F = -T_{ij}(u_j - u_i)$，并获得 $T_{ij}$ 关于 $|F|$、$d_i$、$d_j$、$k_i$ 和 $k_j$ 的闭式表达式，其中 $k_i$ 和 $k_j$ 分别是单元 $i$ 和 $j$ 中的常数各向同性导率。使用控制方程和界面条件清晰地论证每一步，不要引用任何预设最终结果的简化公式。\n\n接下来，分析导通率相对于 $d_i$ 和 $d_j$ 扰动的灵敏度。定义偏导数 $\\frac{\\partial T_{ij}}{\\partial d_i}$ 和 $\\frac{\\partial T_{ij}}{\\partial d_j}$，以及无量纲相对灵敏度\n$$\nS_{d_i} = \\frac{d_i}{T_{ij}} \\frac{\\partial T_{ij}}{\\partial d_i}, \\quad S_{d_j} = \\frac{d_j}{T_{ij}} \\frac{\\partial T_{ij}}{\\partial d_j}.\n$$\n通过将解析灵敏度与根据 $d_i$ 和 $d_j$ 的小幅相对扰动计算出的中心差分有限差分近似值进行比较，来验证解析灵敏度。\n\n使用以下参数集测试套件来评估 $T_{ij}$、$S_{d_i}$、$S_{d_j}$、解析导数与数值导数之间的相对误差，以及误差是否在容差范围内的布尔指标。对于所有情况，将 $k$ 的单位解释为瓦特每米开尔文 ($\\text{W}/(\\text{m}\\cdot \\text{K})$)，$|F|$ 的单位为平方米 ($\\text{m}^2$)，$d_i$ 和 $d_j$ 的单位为米 ($\\text{m}$)，并以瓦特每开尔文 ($\\text{W}/\\text{K}$) 报告 $T_{ij}$。导数比较的容差应设置为 $10^{-9}$ 的相对误差。对每个导数使用等于标称距离 $10^{-8}$ 倍的中心差分步长。\n\n测试套件：\n- 情况 A (一般非对称): $|F| = 1.2$, $d_i = 0.5$, $d_j = 0.4$, $k_i = 2.0$, $k_j = 4.0$.\n- 情况 B (对称距离和导率): $|F| = 2.0$, $d_i = 0.5$, $d_j = 0.5$, $k_i = 1.0$, $k_j = 1.0$.\n- 情况 C (高对比度导率): $|F| = 1.0$, $d_i = 0.1$, $d_j = 0.1$, $k_i = 10.0$, $k_j = 0.1$.\n- 情况 D (薄-厚对，等导率): $|F| = 0.5$, $d_i = 10^{-3}$, $d_j = 1.0$, $k_i = 5.0$, $k_j = 5.0$.\n\n您的程序必须：\n1. 计算每种情况下的 $T_{ij}$、$S_{d_i}$、$S_{d_j}$。\n2. 使用指定的扰动大小，通过中心差分来近似 $\\frac{\\partial T_{ij}}{\\partial d_i}$ 和 $\\frac{\\partial T_{ij}}{\\partial d_j}$。\n3. 报告数值导数相对于解析导数的相对误差。\n4. 返回布尔标志，指示每个相对误差是否小于或等于 $10^{-9}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。列表中的每个条目对应一个测试用例，并且本身必须是以下格式的列表\n$[T_{ij}, S_{d_i}, S_{d_j}, \\text{err}_{d_i}, \\text{err}_{d_j}, \\text{ok}_{d_i}, \\text{ok}_{d_j}]$,\n其中 $T_{ij}$ 的单位是瓦特每开尔文 ($\\text{W}/\\text{K}$)，$S_{d_i}$ 和 $S_{d_j}$ 是无量纲的，$\\text{err}_{d_i}$ 和 $\\text{err}_{d_j}$ 是无量纲相对误差，布尔值表示是否在容差范围内。例如：$[[\\dots],[\\dots],[\\dots],[\\dots]]$。", "solution": "该问题是适定的、有科学依据的，并为得出唯一解提供了所有必要信息。这是偏微分方程数值分析中的一个标准练习，特别是在有限体积法的框架内。\n\n首要目标是推导稳态扩散过程中两个相邻控制体 $i$ 和 $j$ 之间的导通率 $T_{ij}$，并随后分析其对几何参数 $d_i$ 和 $d_j$ 的灵敏度。\n\n**导通率 $T_{ij}$ 的推导**\n\n控制方程是稳态扩散方程：\n$$\n\\nabla \\cdot (k \\nabla u) = 0\n$$\n其中 $u$ 是标量势，$k$ 是导率。本构关系是 Fick 定律或 Fourier 定律，它指出通量矢量 $\\vec{q}$ 与势的负梯度成正比：\n$$\n\\vec{q} = -k \\nabla u\n$$\n我们考虑两个单元 $i$ 和 $j$，它们分别具有恒定的各向同性导率 $k_i$ 和 $k_j$。它们共享一个面积为 $|F|$ 的平面界面 $F$。单元中心距离该界面的垂直距离分别为 $d_i$ 和 $d_j$。\n\n问题做出了一个关键的简化假设，称为两点通量近似 (TPFA)：势 $u$ 沿着连接两个单元中心的直线线性变化。这个假设将问题简化为沿界面 $F$ 法线方向的一维分析。设沿此法线的坐标为 $x$，界面 $F$ 位于 $x=0$。单元 $i$ 的中心在 $x=-d_i$ 处，单元 $j$ 的中心在 $x=d_j$ 处。这些中心的势分别表示为 $u_i = u(-d_i)$ 和 $u_j = u(d_j)$。\n\n在这种一维稳态设置中，控制方程 $\\nabla \\cdot \\vec{q} = 0$ 简化为 $\\frac{d q_x}{dx} = 0$，其中 $q_x$ 是垂直于界面的通量分量。这意味着 $q_x$ 沿着从 $-d_i$ 到 $d_j$ 的线段是恒定的。设这个恒定的通量密度记为 $f$。\n$$\nf = q_x = -k(x) \\frac{du}{dx} = \\text{常数}\n$$\n我们可以将此关系在对应于单元 $i$ 和单元 $j$ 的两个线段上进行积分。\n\n1.  **线段 1 (单元 $i$ 内): 从 $x=-d_i$ 到 $x=0$**\n    导率为 $k(x) = k_i$。\n    $$\n    f = -k_i \\frac{du}{dx}\n    $$\n    从单元中心 $i$ 积分到界面 $F$：\n    $$\n    \\int_{-d_i}^{0} f \\,dx = \\int_{-d_i}^{0} -k_i \\frac{du}{dx} \\,dx\n    $$\n    $$\n    f \\cdot (0 - (-d_i)) = -k_i (u(0) - u(-d_i))\n    $$\n    设 $u_F = u(0)$ 为界面上的势。则：\n    $$\n    f d_i = -k_i (u_F - u_i) \\implies u_i - u_F = \\frac{f d_i}{k_i}\n    $$\n\n2.  **线段 2 (单元 $j$ 内): 从 $x=0$ 到 $x=d_j$**\n    导率为 $k(x) = k_j$。\n    $$\n    f = -k_j \\frac{du}{dx}\n    $$\n    从界面 $F$ 积分到单元中心 $j$：\n    $$\n    \\int_{0}^{d_j} f \\,dx = \\int_{0}^{d_j} -k_j \\frac{du}{dx} \\,dx\n    $$\n    $$\n    f \\cdot (d_j - 0) = -k_j (u(d_j) - u(0))\n    $$\n    $$\n    f d_j = -k_j (u_j - u_F) \\implies u_F - u_j = \\frac{f d_j}{k_j}\n    $$\n\n3.  **消去界面势 $u_F$**\n    我们得到一个关于势差的二元线性方程组：\n    (1) $u_i - u_F = \\frac{f d_i}{k_i}$\n    (2) $u_F - u_j = \\frac{f d_j}{k_j}$\n    将这两个方程相加，消去未知的界面势 $u_F$：\n    $$\n    (u_i - u_F) + (u_F - u_j) = \\frac{f d_i}{k_i} + \\frac{f d_j}{k_j}\n    $$\n    $$\n    u_i - u_j = f \\left( \\frac{d_i}{k_i} + \\frac{d_j}{k_j} \\right)\n    $$\n    重新整理以求解通量密度 $f$：\n    $$\n    f = \\frac{u_i - u_j}{\\frac{d_i}{k_i} + \\frac{d_j}{k_j}} = - \\frac{u_j - u_i}{\\frac{d_i}{k_i} + \\frac{d_j}{k_j}}\n    $$\n\n4.  **确定导通率 $T_{ij}$**\n    通过界面 $F$ 的总通量 $q_F$ 是通量密度 $f$ 乘以面积 $|F|$。通量从高势流向低势。问题定义 $q_F$ 为：如果 $u_i > u_j$，则从单元 $i$ 到单元 $j$ 的流动为正。\n    $$\n    q_F = f \\cdot |F| = -\\left( \\frac{|F|}{\\frac{d_i}{k_i} + \\frac{d_j}{k_j}} \\right) (u_j - u_i)\n    $$\n    将其与给定定义 $q_F = -T_{ij}(u_j - u_i)$ 进行比较，我们确定导通率 $T_{ij}$ 为：\n    $$\n    T_{ij} = \\frac{|F|}{\\frac{d_i}{k_i} + \\frac{d_j}{k_j}}\n    $$\n    此表达式表示两个单元中心之间的传导能力，即总热阻的倒数。$d_i/k_i$ 和 $d_j/k_j$ 这两项类似于串联的电阻。另一种形式是：\n    $$\n    T_{ij} = \\frac{|F| k_i k_j}{d_i k_j + d_j k_i}\n    $$\n\n**灵敏度分析**\n\n现在我们推导 $T_{ij}$ 关于 $d_i$ 和 $d_j$ 的偏导数以及相应的无量纲相对灵敏度。\n\n1.  **关于 $d_i$ 的偏导数**\n    使用 $T_{ij} = |F| k_i k_j (d_i k_j + d_j k_i)^{-1}$ 的形式并应用链式法则：\n    $$\n    \\frac{\\partial T_{ij}}{\\partial d_i} = |F| k_i k_j \\cdot (-1) (d_i k_j + d_j k_i)^{-2} \\cdot \\frac{\\partial}{\\partial d_i}(d_i k_j + d_j k_i)\n    $$\n    $$\n    \\frac{\\partial T_{ij}}{\\partial d_i} = -|F| k_i k_j (d_i k_j + d_j k_i)^{-2} \\cdot (k_j)\n    $$\n    $$\n    \\frac{\\partial T_{ij}}{\\partial d_i} = - \\frac{|F| k_i k_j^2}{(d_i k_j + d_j k_i)^2}\n    $$\n\n2.  **无量纲灵敏度 $S_{d_i}$**\n    相对灵敏度 $S_{d_i}$ 定义为 $S_{d_i} = \\frac{d_i}{T_{ij}} \\frac{\\partial T_{ij}}{\\partial d_i}$。\n    $$\n    S_{d_i} = \\frac{d_i}{\\frac{|F| k_i k_j}{d_i k_j + d_j k_i}} \\left( - \\frac{|F| k_i k_j^2}{(d_i k_j + d_j k_i)^2} \\right)\n    $$\n    $$\n    S_{d_i} = d_i \\frac{d_i k_j + d_j k_i}{|F| k_i k_j} \\left( - \\frac{|F| k_i k_j^2}{(d_i k_j + d_j k_i)^2} \\right)\n    $$\n    消去项后，我们剩下：\n    $$\n    S_{d_i} = - \\frac{d_i k_j}{d_i k_j + d_j k_i}\n    $$\n\n3.  **关于 $d_j$ 的偏导数**\n    关于交换对 $(d_i, k_i)$ 和 $(d_j, k_j)$，$T_{ij}$ 的表达式是对称的。因此，我们可以通过在 $\\frac{\\partial T_{ij}}{\\partial d_i}$ 的表达式中进行这种交换来获得关于 $d_j$ 的导数：\n    $$\n    \\frac{\\partial T_{ij}}{\\partial d_j} = - \\frac{|F| k_j k_i^2}{(d_j k_i + d_i k_j)^2} = - \\frac{|F| k_i^2 k_j}{(d_i k_j + d_j k_i)^2}\n    $$\n\n4.  **无量纲灵敏度 $S_{d_j}$**\n    同样，应用定义 $S_{d_j} = \\frac{d_j}{T_{ij}} \\frac{\\partial T_{ij}}{\\partial d_j}$：\n    $$\n    S_{d_j} = - \\frac{d_j k_i}{d_i k_j + d_j k_i}\n    $$\n    注意 $S_{d_i} + S_{d_j} = - \\frac{d_i k_j + d_j k_i}{d_i k_j + d_j k_i} = -1$。这与 Euler 齐次函数定理一致，因为对于距离 $d_i$ 和 $d_j$，$T_{ij}$ 是一个 -1 次齐次函数。\n\n**数值验证程序**\n\n为了验证解析导数，我们使用二阶中心差分公式。对于函数 $f(x)$，其导数 $f'(x)$ 可近似为：\n$$\nf'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}\n$$\n步长 $h$ 被选为变量值的一个小分数。问题指定相对步长为 $10^{-8}$。\n对于 $\\frac{\\partial T_{ij}}{\\partial d_i}$，其数值近似 $(\\frac{\\partial T_{ij}}{\\partial d_i})_{\\text{num}}$ 为：\n$$\n(\\frac{\\partial T_{ij}}{\\partial d_i})_{\\text{num}} = \\frac{T_{ij}(d_i + h_i, d_j) - T_{ij}(d_i - h_i, d_j)}{2h_i}, \\quad \\text{其中 } h_i = 10^{-8} d_i\n$$\n对关于 $d_j$ 的导数使用类似的公式。然后计算相对误差 $\\text{err}_{d_i}$：\n$$\n\\text{err}_{d_i} = \\left| \\frac{(\\frac{\\partial T_{ij}}{\\partial d_i})_{\\text{num}} - (\\frac{\\partial T_{ij}}{\\partial d_i})_{\\text{ana}}}{(\\frac{\\partial T_{ij}}{\\partial d_i})_{\\text{ana}}} \\right|\n$$\n其中 'ana' 下标表示上面推导的解析导数。然后将这些结果与指定的 $10^{-9}$ 容差进行比较。\n\n一个程序将实现这些公式来处理给定的测试套件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes transmissibility, sensitivities, and validates derivatives for \n    a set of test cases according to the problem description.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    # Format: (|F|, d_i, d_j, k_i, k_j)\n    # Units:\n    # |F|: m^2\n    # d_i, d_j: m\n    # k_i, k_j: W/(m.K)\n    test_cases = [\n        # Case A (general asymmetric)\n        (1.2, 0.5, 0.4, 2.0, 4.0),\n        # Case B (symmetric distances and conductivities)\n        (2.0, 0.5, 0.5, 1.0, 1.0),\n        # Case C (high contrast conductivities)\n        (1.0, 0.1, 0.1, 10.0, 0.1),\n        # Case D (thin-thick pair, equal conductivities)\n        (0.5, 1e-3, 1.0, 5.0, 5.0),\n    ]\n\n    # Constants for numerical validation\n    DERIV_TOLERANCE = 1e-9\n    CENTRAL_DIFF_REL_STEP = 1e-8\n\n    def compute_t_ij(face_area, d_i, d_j, k_i, k_j):\n        \"\"\"Computes the transmissibility T_ij in W/K.\"\"\"\n        # T_ij = |F| / (d_i/k_i + d_j/k_j)\n        denominator = d_i / k_i + d_j / k_j\n        if denominator == 0:\n            return float('inf')\n        return face_area / denominator\n\n    def compute_dt_di_analytical(face_area, d_i, d_j, k_i, k_j):\n        \"\"\"Computes the analytical partial derivative of T_ij w.r.t. d_i.\"\"\"\n        # d(T_ij)/d(d_i) = -|F| * k_i * k_j^2 / (d_i*k_j + d_j*k_i)^2\n        denominator = d_i * k_j + d_j * k_i\n        if denominator == 0:\n            return float('-inf')\n        return -face_area * k_i * k_j**2 / denominator**2\n\n    def compute_dt_dj_analytical(face_area, d_i, d_j, k_i, k_j):\n        \"\"\"Computes the analytical partial derivative of T_ij w.r.t. d_j.\"\"\"\n        # d(T_ij)/d(d_j) = -|F| * k_j * k_i^2 / (d_i*k_j + d_j*k_i)^2\n        denominator = d_i * k_j + d_j * k_i\n        if denominator == 0:\n            return float('-inf')\n        return -face_area * k_j * k_i**2 / denominator**2\n    \n    def compute_s_di(d_i, d_j, k_i, k_j):\n        \"\"\"Computes the dimensionless relative sensitivity S_di.\"\"\"\n        # S_di = -d_i*k_j / (d_i*k_j + d_j*k_i)\n        denominator = d_i * k_j + d_j * k_i\n        if denominator == 0:\n            # This case implies T is infinite or undefined, sensitivity may also be.\n            return float('nan')\n        return -d_i * k_j / denominator\n\n    def compute_s_dj(d_i, d_j, k_i, k_j):\n        \"\"\"Computes the dimensionless relative sensitivity S_dj.\"\"\"\n        # S_dj = -d_j*k_i / (d_i*k_j + d_j*k_i)\n        denominator = d_i * k_j + d_j * k_i\n        if denominator == 0:\n            return float('nan')\n        return -d_j * k_i / denominator\n\n    results = []\n    for case in test_cases:\n        F_area, di, dj, ki, kj = case\n        \n        # 1. Compute T_ij, S_di, S_dj\n        t_ij = compute_t_ij(F_area, di, dj, ki, kj)\n        s_di = compute_s_di(di, dj, ki, kj)\n        s_dj = compute_s_dj(di, dj, ki, kj)\n        \n        # 2. Approximate derivatives using central differences\n        # For d_i\n        h_i = CENTRAL_DIFF_REL_STEP * di\n        t_plus_i = compute_t_ij(F_area, di + h_i, dj, ki, kj)\n        t_minus_i = compute_t_ij(F_area, di - h_i, dj, ki, kj)\n        dt_di_num = (t_plus_i - t_minus_i) / (2 * h_i)\n\n        # For d_j\n        h_j = CENTRAL_DIFF_REL_STEP * dj\n        t_plus_j = compute_t_ij(F_area, di, dj + h_j, ki, kj)\n        t_minus_j = compute_t_ij(F_area, di, dj - h_j, ki, kj)\n        dt_dj_num = (t_plus_j - t_minus_j) / (2 * h_j)\n\n        # 3. Report relative error of numerical derivatives\n        dt_di_ana = compute_dt_di_analytical(F_area, di, dj, ki, kj)\n        dt_dj_ana = compute_dt_dj_analytical(F_area, di, dj, ki, kj)\n\n        # Relative error for d_i derivative\n        if dt_di_ana != 0:\n            err_di = abs((dt_di_num - dt_di_ana) / dt_di_ana)\n        elif dt_di_num == 0: # 0/0 case\n            err_di = 0.0\n        else: # inf error if analytical is 0 but numerical is not\n            err_di = float('inf')\n\n        # Relative error for d_j derivative\n        if dt_dj_ana != 0:\n            err_dj = abs((dt_dj_num - dt_dj_ana) / dt_dj_ana)\n        elif dt_dj_num == 0:\n            err_dj = 0.0\n        else:\n            err_dj = float('inf')\n\n        # 4. Return boolean flags indicating agreement within tolerance\n        ok_di = err_di = DERIV_TOLERANCE\n        ok_dj = err_dj = DERIV_TOLERANCE\n\n        case_results = [\n            t_ij, \n            s_di, \n            s_dj, \n            err_di, \n            err_dj, \n            ok_di, \n            ok_dj\n        ]\n        results.append(case_results)\n\n    # Format the final output as a string representing a list of lists.\n    # The default str() for a list already uses '[]' and ', ' separators.\n    # str(True) is 'True', which is a valid boolean representation in many contexts.\n    # The prompt's example format is `[[...],[...],...]`, which is achieved by this.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3377678"}, {"introduction": "掌握了单元间的通量计算后，下一个关键步骤是处理计算域的边界。本练习将重点放在一种常见且重要的边界条件——罗宾（Robin）边界条件——的实现上。你将在一维模型中推导并实现相应的边界传递率，并验证当交换系数趋于无穷大时，罗宾边界条件收敛于狄利克雷（Dirichlet）边界条件的理论特性 [@problem_id:3377670]。", "problem": "考虑一个定义在区间 $[0,L]$ 上的一维稳态扩散问题，其标量场为 $u(x)$，热导率为 $k(x)0$，且无体积源。其控制偏微分方程为守恒律 $-\\dfrac{d}{dx}\\!\\left(k(x)\\dfrac{du}{dx}\\right)=0$。采用有限体积法（FVM）和两点通量近似（TPFA）对该问题进行离散化：将每个控制体与一个单元中心关联，通过由相邻单元中心之间的势差驱动的恒定梯度通量来近似穿过每个内表面的扩散通量，并通过将离开一个单元的通量代数和设为零来强制守恒。\n\n在内表面上，通过在相邻单元之间实施一个通量连续性模型来确定传导率，该模型可简化为由局部传导系数加权的距离的调和平均值。在左边界，施加一个混合（Robin）边界条件，该条件使用一个交换系数 $\\alpha0$（在此问题中为无量纲）来模拟与保持在预设值 $u_b$ 的外部环境的热交换。在右边界，施加一个预设值为 $u_R$ 的 Dirichlet 边界条件。对于左边界的 Robin 边界条件，从第一性原理推导出一个与 TPFA 模型以及与对流交换层旁的传导段的串联电阻解释相一致的基于面的传导率。然后，在最终的线性系统中实现此 Robin 表面传导率，使得左边界通量与单元中心值和外部值 $u_b$ 之间的差值成线性比例。证明当 $\\alpha\\to\\infty$ 时，此构造收敛于 Dirichlet 边界。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 使用 TPFA 在 $[0,L]$ 上根据指定的网格和传导系数构建三个离散测试问题，所有问题均具有单位横截面积。\n- 对每个问题，计算一个参考解，其左边界设置为 $u_b$ 的 Dirichlet 条件，右边界设置为 $u_R$。\n- 对每个问题，为一系列递增的交换系数 $\\alpha$ 计算带左 Robin 边界条件的解，并报告 Robin 解与参考 Dirichlet 解之间的均方根（RMS）差异，其定义为\n$$\nE(\\alpha)=\\sqrt{\\dfrac{1}{L}\\sum_{i=1}^{N}\\Delta x_i\\,\\left(u_i^{(\\alpha)}-u_i^{(D)}\\right)^2},\n$$\n其中 $N$ 是单元数，$\\Delta x_i$ 是第 $i$ 个单元的长度，$u_i^{(\\alpha)}$ 是左 Robin 系数为 $\\alpha$ 时的离散解，$u_i^{(D)}$ 是左 Dirichlet 边界为 $u_b$ 且右 Dirichlet 边界为 $u_R$ 时的离散解。\n- 对每个问题，还需报告一个布尔值，指示当 $\\alpha$ 增加时，RMS 差异序列是否在小的数值公差 $\\varepsilon=10^{-12}$ 内单调非增。\n\n将所有量视为无量纲。使用以下配置作为测试套件：\n- 测试 1（均匀网格，均匀传导系数）：\n  - 域长度 $L=1$，单元数 $N=50$，均匀网格，$k(x)\\equiv 1$。\n  - 左侧外部值 $u_b=0$，右侧 Dirichlet 值 $u_R=1$。\n  - 左侧 Robin 交换系数 $\\alpha\\in\\{10^{-3},10^{-1},10^{1},10^{5}\\}$。\n- 测试 2（均匀网格，分段常数传导系数）：\n  - 域长度 $L=1$，单元数 $N=60$，均匀网格，在 $[0,\\tfrac{1}{2}L)$ 上 $k(x)=1$，在 $[\\tfrac{1}{2}L,L]$ 上 $k(x)=5$。\n  - 左侧外部值 $u_b=0$，右侧 Dirichlet 值 $u_R=1$。\n  - 左侧 Robin 交换系数 $\\alpha\\in\\{10^{-2},10^{0},10^{3}\\}$。\n- 测试 3（非均匀网格，平滑变化的传导系数）：\n  - 域长度 $L=1$，单元数 $N=40$，非均匀网格，单元边为 $x_j=L\\left(\\dfrac{j}{N}\\right)^2$（$j=0,1,\\dots,N$），单元中心位于边的中点。\n  - 传导系数 $k(x)=1+x$ 在单元中心处求值。\n  - 左侧外部值 $u_b=0$，右侧 Dirichlet 值 $u_R=1$。\n  - 左侧 Robin 交换系数 $\\alpha\\in\\{10^{-2},10^{2},10^{8}\\}$。\n\n实现要求和约束：\n- 使用两点通量近似（TPFA），通过将从单元中心到表面的距离与局部传导系数以调和方式组合，来定义内表面上的传导率。\n- 在右边界，通过将边界值与最后一个单元用一个与 TPFA 模型一致的适当边界传导率相连接，来施加 Dirichlet 条件。\n- 在左边界，通过将通量建模为第一个单元中心值与 $u_b$ 之差的线性函数来施加 Robin 条件，其传导率源自传导段和交换层的串联组合。\n- 从通量平衡中组装线性系统 $A\\mathbf{u}=\\mathbf{b}$，并求解单元中心值 $\\mathbf{u}$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序包含以下条目：\n  - 对于测试 1：对应于 $\\alpha=10^{-3},10^{-1},10^{1},10^{5}$ 的四个 RMS 差值 $E(\\alpha)$，后跟一个指示单调非增行为的布尔值。\n  - 对于测试 2：对应于 $\\alpha=10^{-2},10^{0},10^{3}$ 的三个 RMS 差值 $E(\\alpha)$，后跟一个指示单调非增行为的布尔值。\n  - 对于测试 3：对应于 $\\alpha=10^{-2},10^{2},10^{8}$ 的三个 RMS 差值 $E(\\alpha)$，后跟一个指示单调非增行为的布尔值。\n- 因此，最后一行必须总共包含 13 个条目：$[E_{1,1},E_{1,2},E_{1,3},E_{1,4},B_1,E_{2,1},E_{2,2},E_{2,3},B_2,E_{3,1},E_{3,2},E_{3,3},B_3]$，其中 $E_{t,s}$ 表示测试 $t$ 的第 $s$ 个 RMS 差值，$B_t$ 是测试 $t$ 对应的单调性布尔值。", "solution": "用户提供的问题被评估为 **有效**。这是一个适定的、具有科学依据的偏微分方程数值方法领域的问题。参数完整，目标明确且可量化。因此，我们可以进行完整解答。\n\n该问题要求数值求解无源一维稳态扩散方程：\n$$\n-\\frac{d}{dx}\\left(k(x)\\frac{du}{dx}\\right) = 0, \\quad x \\in [0, L]\n$$\n其中 $u(x)$ 是一个标量势场，$k(x)  0$ 是扩散系数（例如，热导率）。我们采用以单元为中心的有限体积法（FVM）。\n\n**1. 离散化与通量平衡**\n\n域 $[0, L]$ 被离散化为 $N$ 个连续的控制体（单元）。令第 $i$ 个单元（$i=1, \\dots, N$）表示为 $CV_i = [x_{i-1/2}, x_{i+1/2}]$，其中 $x_{i-1/2}$ 和 $x_{i+1/2}$ 是单元表面的位置。单元中心为 $x_i$，单元宽度为 $\\Delta x_i = x_{i+1/2} - x_{i-1/2}$。\n\n将控制方程在 $CV_i$ 上积分得到：\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} -\\frac{d}{dx}\\left(k(x)\\frac{du}{dx}\\right) dx = 0\n$$\n应用微积分基本定理，我们得到每个单元的通量平衡方程：\n$$\n- \\left[ k(x)\\frac{du}{dx} \\right]_{x_{i-1/2}}^{x_{i+1/2}} = 0 \\implies F_{i-1/2} - F_{i+1/2} = 0\n$$\n其中 $F(x) = -k(x)\\frac{du}{dx}$ 是扩散通量。该方程表明，在稳态下，任何控制体的净流出通量为零。\n\n**2. 两点通量近似（TPFA）**\n\nTPFA 将内部表面 $x_{i+1/2}$（位于单元 $i$ 和 $i+1$ 之间）的通量近似为与相邻单元中心 $u_i$ 和 $u_{i+1}$ 之间的势差成线性比例：\n$$\nF_{i+1/2} \\approx -T_{i+1/2}(u_{i+1} - u_i)\n$$\n项 $T_{i+1/2}$ 是该表面的传导率。为了推导其表达式，我们假设在 $x_i$ 和 $x_{i+1}$ 之间通量是恒定的，并且传导系数是分段常数（单元 $i$ 中为 $k_i$，单元 $i+1$ 中为 $k_{i+1}$）。通过强制通量连续性可以消除表面上的势 $u_{i+1/2}$，这等效于一个串联电阻模型：\n$$\nu_i - u_{i+1} = (u_i - u_{i+1/2}) + (u_{i+1/2} - u_{i+1}) = F_{i+1/2} \\left( \\frac{x_{i+1/2}-x_i}{k_i} \\right) + F_{i+1/2} \\left( \\frac{x_{i+1}-x_{i+1/2}}{k_{i+1}} \\right)\n$$\n求解 $F_{i+1/2}$，得到传导率，即为与该表面相邻的两个半单元上传导系数的调和平均值：\n$$\nT_{i+1/2} = \\left( \\frac{x_{i+1/2}-x_i}{k_i} + \\frac{x_{i+1}-x_{i+1/2}}{k_{i+1}} \\right)^{-1}\n$$\n\n**3. 边界条件**\n\n边界通量 $x_{1/2}=0$ 和 $x_{N+1/2}=L$ 被整合到单元 $1$ 和 $N$ 的通量平衡方程中。\n\n**右边界（Dirichlet）：** 在 $x=L$ 处，给定一个 Dirichlet 条件 $u(L)=u_R$。通过边界表面 $x_{N+1/2}=L$ 的通量使用半单元传导率建模，该传导率连接了单元 $N$ 的中心与边界：\n$$\nF_{N+1/2} = -T_{N+1/2}(u_R - u_N) \\quad \\text{其中} \\quad T_{N+1/2} = \\left( \\frac{x_{N+1/2}-x_N}{k_N} \\right)^{-1} = \\frac{k_N}{L-x_N}\n$$\n单元 $N$ 的通量平衡为 $F_{N-1/2} - F_{N+1/2} = 0$，即：\n$$\n-T_{N-1/2}(u_N-u_{N-1}) - (-T_{N+1/2}(u_R - u_N)) = 0\n$$\n\n**左边界（Robin）：** 在 $x=0$ 处，一个混合（Robin）条件通过交换系数 $\\alpha  0$ 模拟与势为 $u_b$ 的环境的交换。物理通量条件是 $-k \\frac{du}{dx}|_{x=0} = h(u(0)-u_b)$，其中 $h$ 是一个传热系数，我们取其为 $\\alpha$。从外部环境到单元 $1$ 中心的总电阻是表面对流电阻（$R_{conv}=1/\\alpha$）和半单元传导电阻（$R_{cond}=(x_1-x_{1/2})/k_1 = x_1/k_1$）之和。总通量由跨越此总电阻的势差 $u_1-u_b$ 驱动：\n$$\nF_{1/2} = \\frac{u_1-u_b}{R_{conv} + R_{cond}} = \\left( \\frac{1}{\\alpha} + \\frac{x_1}{k_1} \\right)^{-1} (u_1-u_b)\n$$\n我们定义 Robin 边界传导率为 $T_{1/2}^{(\\alpha)} = (1/\\alpha + x_1/k_1)^{-1}$。单元 1 的通量平衡为 $F_{1/2} - F_{3/2} = 0$：\n$$\nT_{1/2}^{(\\alpha)}(u_1-u_b) - (-T_{3/2}(u_2 - u_1)) = 0\n$$\n\n**收敛到 Dirichlet：** 当交换系数 $\\alpha \\to \\infty$ 时，对流电阻 $1/\\alpha \\to 0$。Robin 传导率变为：\n$$\n\\lim_{\\alpha\\to\\infty} T_{1/2}^{(\\alpha)} = \\lim_{\\alpha\\to\\infty} \\left( \\frac{1}{\\alpha} + \\frac{x_1}{k_1} \\right)^{-1} = \\left( \\frac{x_1}{k_1} \\right)^{-1} = \\frac{k_1}{x_1}\n$$\n这恰好是 Dirichlet 边界条件 $u(0)=u_b$ 的传导率 $T_{1/2}^{(D)}$。因此，当 $\\alpha \\to \\infty$ 时，Robin 问题的线性系统收敛于 Dirichlet 问题的系统，其解也同样收敛。\n\n**4. 线性系统 ($A\\mathbf{u}=\\mathbf{b}$)**\n\n将所有 $N$ 个单元的通量平衡方程组合起来，得到一个关于单元中心势向量 $\\mathbf{u}=[u_1, u_2, \\dots, u_N]^T$ 的三对角线性系统 $A\\mathbf{u}=\\mathbf{b}$。\n- 对于内部单元 $i \\in \\{2, \\dots, N-1\\}$：\n  $$ -T_{i-1/2}u_{i-1} + (T_{i-1/2} + T_{i+1/2})u_i - T_{i+1/2}u_{i+1} = 0 $$\n- 对于第一个单元（$i=1$，Robin 边界条件）：\n  $$ (T_{1/2}^{(\\alpha)} + T_{3/2})u_1 - T_{3/2}u_2 = T_{1/2}^{(\\alpha)}u_b $$\n- 对于最后一个单元（$i=N$，Dirichlet 边界条件）：\n  $$ -T_{N-1/2}u_{N-1} + (T_{N-1/2} + T_{N+1/2})u_N = T_{N+1/2}u_R $$\n\n参考解 $u_i^{(D)}$ 是通过求解一个类似的系统计算得出的，但左边界也使用 Dirichlet 条件，其传导率为 $T_{1/2}^{(D)} = k_1/x_1$。然后使用给定的 RMS 公式计算误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D diffusion problem for three test cases using FVM-TPFA,\n    analyzes the convergence of Robin to Dirichlet boundary conditions,\n    and prints the results in the specified format.\n    \"\"\"\n\n    def solve_test_case(L, N, grid_type, k_func, u_b, u_R, alphas, tol):\n        \"\"\"\n        Builds the grid, assembles and solves the linear systems for a single test case.\n        \n        Returns a tuple containing:\n        - A list of RMS errors for the given alpha values.\n        - A boolean indicating if the errors are monotonically non-increasing.\n        \"\"\"\n\n        # 1. Build grid geometry and evaluate conductivity\n        if grid_type == 'uniform':\n            faces = np.linspace(0, L, N + 1)\n        elif grid_type == 'nonuniform_sq':\n            j = np.arange(N + 1)\n            faces = L * (j / N)**2\n        else:\n            raise ValueError(f\"Unknown grid type: {grid_type}\")\n\n        centers = 0.5 * (faces[:-1] + faces[1:])\n        dx = faces[1:] - faces[:-1]\n        k = k_func(centers)\n\n        # 2. Compute internal face transmissibilities\n        # T_internal[i] corresponds to face between cell i and cell i+1\n        T_internal = np.zeros(N - 1)\n        if N > 1:\n            d_i_f = faces[1:-1] - centers[:-1]  # distance from center i to face i+1/2\n            d_f_i1 = centers[1:] - faces[1:-1] # distance from face i+1/2 to center i+1\n            T_internal = 1.0 / (d_i_f / k[:-1] + d_f_i1 / k[1:])\n\n        # --- Helper for system assembly and solution ---\n        def assemble_and_solve(T_left, T_right):\n            A = np.zeros((N, N))\n            b = np.zeros(N)\n\n            # Cell 0 (left boundary)\n            if N > 1:\n                A[0, 0] = T_left + T_internal[0]\n                A[0, 1] = -T_internal[0]\n            else: # Single cell case\n                A[0, 0] = T_left + T_right\n            b[0] = T_left * u_b\n            \n            # Internal cells (1 to N-2)\n            for i in range(1, N - 1):\n                A[i, i - 1] = -T_internal[i - 1]\n                A[i, i] = T_internal[i - 1] + T_internal[i]\n                A[i, i + 1] = -T_internal[i]\n\n            # Cell N-1 (right boundary)\n            if N > 1:\n                A[N - 1, N - 2] = -T_internal[N - 2]\n                A[N - 1, N - 1] = T_internal[N - 2] + T_right\n            b[N - 1] = T_right * u_R\n            \n            return np.linalg.solve(A, b)\n        # --- End of helper ---\n\n        # 3. Compute reference solution (Dirichlet-Dirichlet)\n        T_left_D = k[0] / (centers[0] - faces[0])\n        T_right_D = k[-1] / (faces[-1] - centers[-1])\n        u_D = assemble_and_solve(T_left_D, T_right_D)\n\n        # 4. Compute solutions for Robin BC and RMS errors\n        rms_errors = []\n        for alpha in alphas:\n            # Transmissibility for left Robin boundary\n            # R_cond = (centers[0] - faces[0]) / k[0]\n            # R_conv = 1.0 / alpha\n            # T_left_R = 1.0 / (R_cond + R_conv)\n            T_left_R = 1.0 / ((centers[0] - faces[0]) / k[0] + 1.0 / alpha)\n\n            # Solve for Robin case (right BC is still Dirichlet)\n            u_alpha = assemble_and_solve(T_left_R, T_right_D)\n            \n            # Compute RMS difference\n            error_sq_sum = np.sum(dx * (u_alpha - u_D)**2)\n            rms = np.sqrt(error_sq_sum / L)\n            rms_errors.append(rms)\n\n        # 5. Check for monotonic non-increasing behavior\n        is_monotonic = all(\n            rms_errors[i+1] = rms_errors[i] + tol for i in range(len(rms_errors)-1)\n        )\n        \n        return rms_errors, is_monotonic\n\n    test_configs = [\n        {\n            \"L\": 1.0, \"N\": 50, \"grid_type\": \"uniform\",\n            \"k_func\": lambda x: np.ones_like(x),\n            \"u_b\": 0.0, \"u_R\": 1.0,\n            \"alphas\": [1e-3, 1e-1, 1e1, 1e5]\n        },\n        {\n            \"L\": 1.0, \"N\": 60, \"grid_type\": \"uniform\",\n            \"k_func\": lambda x: np.where(x  0.5, 1.0, 5.0),\n            \"u_b\": 0.0, \"u_R\": 1.0,\n            \"alphas\": [1e-2, 1e0, 1e3]\n        },\n        {\n            \"L\": 1.0, \"N\": 40, \"grid_type\": \"nonuniform_sq\",\n            \"k_func\": lambda x: 1.0 + x,\n            \"u_b\": 0.0, \"u_R\": 1.0,\n            \"alphas\": [1e-2, 1e2, 1e8]\n        },\n    ]\n\n    all_results = []\n    TOLERANCE = 1e-12\n\n    for config in test_configs:\n        errors, monotonic = solve_test_case(**config, tol=TOLERANCE)\n        all_results.extend(errors)\n        all_results.append(monotonic)\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```", "id": "3377670"}, {"introduction": "我们已经学会了如何构建一个TPFA系统，但何时可以信赖这个简单的近似呢？本练习通过将TPFA与更先进的模拟有限差分（MFD）格式进行直接比较，来揭示其核心局限性。通过在TPFA精确和失效的不同网格与各向异性条件下进行测试，你将清晰地看到K-正交性对TPFA精度的决定性影响 [@problem_id:3377674]。", "problem": "考虑二维空间中的稳态扩散方程，\n$$-\\nabla \\cdot (K \\nabla p) = f,$$\n其中 $K \\in \\mathbb{R}^{2 \\times 2}$ 为对称正定扩散张量，$p(x,y)$ 为标量势。物理通量定义为\n$$q = -K \\nabla p.$$\n您需要针对常数 $K$ 和一个构造的线性解，在同一个单元中心网格上，实现并比较穿过内部面的法向通量的两种离散化方法：两点通量近似（TPFA）和模拟有限差分（MFD）。您的实现必须仅基于以下基本原理和定义：通量定义 $q = -K \\nabla p$、散度定理、面的几何度量（面长度和单位外法向量），以及从相邻单元值重构常数梯度以精确表示线性场的概念。\n\n网格构建如下。从单位正方形 $[0,1]^2$ 开始，将其划分为 $N_x \\times N_y$ 个轴对齐的矩形，其顶点坐标为 $(i/N_x, j/N_y)$，其中整数 $i=0,\\dots,N_x$ 且 $j=0,\\dots,N_y$。对所有顶点坐标应用一个给定的固定线性变换 $A \\in \\mathbb{R}^{2 \\times 2}$，以获得物理空间中可能非正交的网格。对于每个单元，将其中心定义为其四个变换后顶点的平均值。对于每个内部面，将其端点定义为相应的变换后顶点，其边向量定义为端点之差，其单位法向量定义为与边向量正交且从“左/下”单元指向“右/上”单元的唯一单位向量，其长度定义为边向量的范数。\n\n设构造解为线性势\n$$p(x,y) = a x + b y,$$\n其梯度为常数 $\\nabla p = (a,b)^\\top$。对于由单元 $i$ 和 $j$ 共享的每个内部面，穿过该面的精确法向通量为\n$$F_{\\mathrm{ex}} = -|f|\\, n^\\top K \\nabla p,$$\n其中 $|f|$ 是面长度，$n$ 是从 $i$ 指向 $j$ 的单位法向量。TPFA 方案仅使用两个相邻的单元中心值和面的余法线来近似法向通量，而 MFD 方案则重构一个对线性场精确的单元梯度，并用它来一致地近似面法向通量。您的程序必须以遵循上述基本定义的方式实现这两种近似，然后将它们与精确的面法向通量进行比较。\n\n您的任务：\n- 为给定的 $N_x$、$N_y$ 和 $A$，使用单位正方形分区上的指定仿射变换来实现网格生成。\n- 对每个内部面，计算：\n  1. 使用 $q = -K \\nabla p$ 和构造的线性场计算精确法向通量 $F_{\\mathrm{ex}}$。\n  2. 仅使用两个单元中心值、几何余法线以及沿面法线方向投影的中心距，根据您解法中建立的通量定义和跨面守恒，推导出 TPFA 法向通量 $F_{\\mathrm{TPFA}}$。\n  3. 在每个单元中，通过对线性多项式精确的最小二乘拟合，从其相邻单元中心值重构一个常数梯度，然后平均相邻单元梯度，通过与 $K$ 和面法线进行缩并形成面法向通量，从而计算 MFD 法向通量 $F_{\\mathrm{MFD}}$。\n- 计算所有内部面上的相对 $L^2$ 通量误差，\n$$E_{\\mathrm{TPFA}} = \\frac{\\left\\|F_{\\mathrm{TPFA}} - F_{\\mathrm{ex}}\\right\\|_2}{\\left\\|F_{\\mathrm{ex}}\\right\\|_2}, \\quad E_{\\mathrm{MFD}} = \\frac{\\left\\|F_{\\mathrm{MFD}} - F_{\\mathrm{ex}}\\right\\|_2}{\\left\\|F_{\\mathrm{ex}}\\right\\|_2}.$$\n- 通过检查差异 $\\left\\|F_{\\mathrm{TPFA}} - F_{\\mathrm{MFD}}\\right\\|_2$ 与 $\\left\\|F_{\\mathrm{ex}}\\right\\|_2$ 相比是否可忽略不计，来确定 TPFA 和 MFD 在给定情况下是否一致。\n\n使用以下参数值测试套件，其涵盖了一致和不一致的条件。所有角度均以度为单位指定，不需要物理单位。\n\n- 测试用例 1（正交网格，各向同性扩散，一般梯度）：\n  - $N_x = 8$，$N_y = 7$\n  - $A = I$ (单位变换)\n  - $K = k I$，其中 $k = 2$\n  - $\\nabla p = (a,b)^\\top$，其中 $a = 1.3$，$b = -0.9$\n\n- 测试用例 2（倾斜网格，旋转的各向异性扩散，一般梯度）：\n  - $N_x = 8$，$N_y = 7$\n  - $A = \\begin{pmatrix}1  s \\\\ 0  1\\end{pmatrix}$，其中 $s = 0.7$\n  - $K = R \\,\\mathrm{diag}(k_x, k_y)\\, R^\\top$，其中 $k_x = 5$，$k_y = 1$，$R$ 为角度 $\\theta = 30$ 度的旋转矩阵\n  - $\\nabla p = (a,b)^\\top$，其中 $a = 1.3$，$b = -0.9$\n\n- 测试用例 3（正交网格，与网格对齐的各向异性扩散，一般梯度）：\n  - $N_x = 8$，$N_y = 7$\n  - $A = I$\n  - $K = \\mathrm{diag}(k_x, k_y)$，其中 $k_x = 5$，$k_y = 1$\n  - $\\nabla p = (a,b)^\\top$，其中 $a = 1.3$，$b = -0.9$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个测试用例的结果本身就是一个形式为 $[E_{\\mathrm{TPFA}}, E_{\\mathrm{MFD}}, \\mathrm{coincide}]$ 的列表。例如：\n$$\\text{[[e1\\_tpfa,e1\\_mfd,true],[e2\\_tpfa,e2\\_mfd,false],[e3\\_tpfa,e3\\_mfd,true]]}$$\n其中 $e\\_*\\_{\\mathrm{tpfa}}$ 和 $e\\_*\\_{\\mathrm{mfd}}$ 是浮点数，$\\mathrm{coincide}$ 是布尔值。", "solution": "该问题要求在通用四边形网格上，针对二维稳态扩散方程，实现并比较两点通量近似（TPFA）和模拟有限差分（MFD）方案。我们将验证问题，推导数值通量的公式，然后实现它们以计算给定测试用例所需的误差度量。\n\n控制方程为稳态扩散方程：\n$$-\\nabla \\cdot (\\mathbf{q}) = f \\quad \\text{with} \\quad \\mathbf{q} = -K \\nabla p$$\n其中 $p$ 是标量势，$K \\in \\mathbb{R}^{2 \\times 2}$ 是对称正定扩散张量，$\\mathbf{q}$ 是物理通量，$f$ 是源项。该问题在域 $\\Omega \\subset \\mathbb{R}^2$ 上进行分析，使用一个构造的线性势 $p(x,y) = ax+by$，由于 $K$ 是常数，源项 $f=0$。\n\n**1. 网格与几何**\n计算网格是通过对单位正方形 $[0,1]^2$ 上的均匀笛卡尔网格的顶点应用线性变换 $A \\in \\mathbb{R}^{2 \\times 2}$ 来构建的。设参考网格的顶点为 $\\mathbf{v}^{\\text{ref}}_{i,j} = (i/N_x, j/N_y)^\\top$，其中整数 $i \\in \\{0, \\dots, N_x\\}$ 和 $j \\in \\{0, \\dots, N_y\\}$。物理网格的顶点为 $\\mathbf{v}_{i,j} = A \\mathbf{v}^{\\text{ref}}_{i,j}$。\n\n一个单元 $C_{i,j}$是由顶点 $\\{\\mathbf{v}_{i,j}, \\mathbf{v}_{i+1,j}, \\mathbf{v}_{i,j+1}, \\mathbf{v}_{i+1,j+1}\\}$ 构成的四边形。对于单元中心方案，其中心定义为顶点的重心（平均值）：\n$$\\mathbf{x}_{i,j} = \\frac{1}{4}(\\mathbf{v}_{i,j} + \\mathbf{v}_{i+1,j} + \\mathbf{v}_{i,j+1} + \\mathbf{v}_{i+1,j+1})$$\n\n一个内部面 $e$ 是由两个相邻单元（例如 $C_L$ 和 $C_R$）共享的线段。设其端点为 $\\mathbf{v}_1$ 和 $\\mathbf{v}_2$。边向量为 $\\mathbf{e} = \\mathbf{v}_2 - \\mathbf{v}_1$，其长度为 $|e| = \\|\\mathbf{e}\\|_2$。单位法向量 $\\mathbf{n}$ 与 $\\mathbf{e}$ 正交（$ \\mathbf{n} \\cdot \\mathbf{e} = 0 $），其方向指向从单元 $C_L$ 到单元 $C_R$。对于一个向量 $\\mathbf{e}=(e_x, e_y)^\\top$，其法向量由 $(-e_y, e_x)^\\top$ 给出。我们选择符号以确保 $\\mathbf{n} \\cdot (\\mathbf{x}_R - \\mathbf{x}_L)  0$。\n\n**2. 构造解与精确通量**\n势场由线性函数 $p(x,y) = ax+by$ 给出。用向量表示法， $p(\\mathbf{x}) = \\mathbf{g} \\cdot \\mathbf{x}$，其中 $\\mathbf{g} = (a, b)^\\top$ 是常数梯度，$\\nabla p = \\mathbf{g}$。在单元中心 $\\mathbf{x}_i$ 处的势为 $p_i = p(\\mathbf{x}_i) = \\mathbf{g} \\cdot \\mathbf{x}_i$。\n\n穿过一个面 $e$ 的法向通量是物理通量 $\\mathbf{q} = -K \\nabla p$ 的法向分量的积分：\n$$F_e = \\int_e \\mathbf{q} \\cdot \\mathbf{n} \\,ds$$\n由于对于我们的构造解，$\\mathbf{q}$ 是常数，积分得以简化。精确的法向通量为：\n$$F^{\\text{ex}}_e = (\\mathbf{q} \\cdot \\mathbf{n}) \\int_e ds = (-K \\mathbf{g} \\cdot \\mathbf{n}) |e| = -|e| \\mathbf{n}^\\top K \\mathbf{g}$$\n\n**3. 两点通量近似 (TPFA)**\nTPFA 方案仅使用两个单元 $C_L$ 和 $C_R$ 的单元中心势 $p_L$ 和 $p_R$ 来近似它们之间的通量。其推导基于沿面法线方向一维流动的假设。通过在面中心强制通量连续性并使用有限差分近似梯度，可以得到通量的表达式。得到的通量近似值为：\n$$F^{\\text{TPFA}}_e = -T_e (p_R - p_L)$$\n其中 $T_e$ 是面的传输率。对于一个通用张量 $K$，传输率是在势沿法线方向线性变化的假设下推导出来的，这得到：\n$$T_e = |e| \\frac{\\mathbf{n}^\\top K \\mathbf{n}}{(\\mathbf{x}_R - \\mathbf{x}_L) \\cdot \\mathbf{n}}$$\n势差为 $p_R - p_L = \\mathbf{g} \\cdot (\\mathbf{x}_R - \\mathbf{x}_L)$。将这些代入通量表达式中，得到：\n$$F^{\\text{TPFA}}_e = -|e| \\frac{\\mathbf{n}^\\top K \\mathbf{n}}{(\\mathbf{x}_R - \\mathbf{x}_L) \\cdot \\mathbf{n}} (\\mathbf{g} \\cdot (\\mathbf{x}_R - \\mathbf{x}_L))$$\n该近似是精确的当且仅当网格是 K-正交的，即对于每个面，向量 $K(\\mathbf{x}_R - \\mathbf{x}_L)$ 平行于面法线 $\\mathbf{n}$。对于具有各向同性（$K=kI$）或轴对齐各向异性（$K=\\text{diag}(k_x, k_y)$）扩散张量的正交网格，此条件得到满足。在倾斜网格或使用旋转的各向异性张量时，TPFA 会引入一致性误差。\n\n**4. 模拟有限差分 (MFD) 通量**\nMFD 方法通过首先在每个单元内重构梯度，然后用它来计算通量，从而提供更精确的通量近似。\n\n**4.1. 梯度重构**\n对于每个单元 $C_i$，通过对其面相邻单元的势进行最小二乘拟合，计算出一个常数梯度向量 $\\nabla p_i$。设 $N(i)$ 为单元 $C_i$ 的面相邻单元的索引集合。我们寻求 $\\mathbf{g}_i \\approx \\nabla p_i$ 以最小化残差平方和：\n$$\\underset{\\mathbf{g}_i \\in \\mathbb{R}^2}{\\text{minimize}} \\sum_{j \\in N(i)} \\left( (p_j - p_i) - \\mathbf{g}_i \\cdot (\\mathbf{x}_j - \\mathbf{x}_i) \\right)^2$$\n这是一个标准的线性最小二乘问题。设 $\\mathbf{d}_{ij} = \\mathbf{x}_j - \\mathbf{x}_i$ 且 $\\Delta p_{ij} = p_j - p_i$。该系统可以写成 $M \\mathbf{g}_i = \\mathbf{b}$，其中 $M$ 的行是 $\\mathbf{d}_{ij}^\\top$，$b$ 的条目是 $\\Delta p_{ij}$。解由以下公式给出：\n$$\\mathbf{g}_i = (M^\\top M)^{-1} M^\\top \\mathbf{b}$$\n其中 $M^\\top M = \\sum_{j \\in N(i)} \\mathbf{d}_{ij} \\mathbf{d}_{ij}^\\top$ 且 $M^\\top \\mathbf{b} = \\sum_{j \\in N(i)} \\mathbf{d}_{ij} \\Delta p_{ij}$。\n这种重构的一个关键特性是它对线性势场是精确的。如果 $p(\\mathbf{x}) = \\mathbf{g}_{\\text{true}} \\cdot \\mathbf{x} + c$，那么 $p_j - p_i = \\mathbf{g}_{\\text{true}} \\cdot (\\mathbf{x}_j - \\mathbf{x}_i)$，因此对于 $\\mathbf{g}_i = \\mathbf{g}_{\\text{true}}$，最小二乘问题中的残差为零。因此，对于我们的构造解，每个单元中重构的梯度 $\\mathbf{g}_i$ 将等于真实梯度 $\\mathbf{g}$，直到机器精度。\n\n**4.2. 通量计算**\n单元 $C_L$ 和 $C_R$ 之间的面 $e$ 上的 MFD 通量是使用重构的梯度计算的。面上的通量向量通过相邻单元通量向量的算术平均值来近似：\n$$\\mathbf{q}_e \\approx \\frac{\\mathbf{q}_L + \\mathbf{q}_R}{2} = -\\frac{K\\nabla p_L + K\\nabla p_R}{2}$$\n由于 $K$ 是常数，且对于线性势，重构是精确的（$\\nabla p_L = \\nabla p_R = \\mathbf{g}$），因此面通量向量就是 $\\mathbf{q}_e = -K\\mathbf{g}$。那么法向通量为：\n$$F^{\\text{MFD}}_e = |e| (\\mathbf{q}_e \\cdot \\mathbf{n}) = -|e| \\mathbf{n}^\\top K \\left(\\frac{\\nabla p_L + \\nabla p_R}{2}\\right)$$\n对于线性构造解，这变成：\n$$F^{\\text{MFD}}_e = -|e| \\mathbf{n}^\\top K \\left(\\frac{\\mathbf{g} + \\mathbf{g}}{2}\\right) = -|e| \\mathbf{n}^\\top K \\mathbf{g} = F^{\\text{ex}}_e$$\n因此，MFD 方案对于任意网格上的线性势是精确的，并且应该产生接近于零的数值误差。\n\n**5. 误差与一致性分析**\n每个方案的精度通过所有 $N_f$ 个内部面上通量近似误差的相对 $L^2$ 范数来衡量：\n$$E = \\frac{\\left\\|F_{\\text{approx}} - F_{\\text{ex}}\\right\\|_2}{\\left\\|F_{\\text{ex}}\\right\\|_2} = \\frac{\\left(\\sum_e (F^{\\text{approx}}_e - F^{\\text{ex}}_e)^2\\right)^{1/2}}{\\left(\\sum_e (F^{\\text{ex}}_e)^2\\right)^{1/2}}$$\n我们必须为 $F_{\\text{approx}} = F_{\\text{TPFA}}$ 和 $F_{\\text{approx}} = F_{\\text{MFD}}$ 两者计算此误差。\n\n如果两种方案通量之差的 $L^2$ 范数与精确通量的范数相比可以忽略不计，则认为这两种方案是一致的。我们使用一个小的容差 $\\epsilon$ 来定义这一点：\n$$\\frac{\\left\\|F_{\\text{TPFA}} - F_{\\mathrm{MFD}}\\right\\|_2}{\\left\\|F_{\\mathrm{ex}}\\right\\|_2}  \\epsilon$$\n对于双精度浮点运算，容差 $\\epsilon=10^{-12}$ 是合适的。当 TPFA 方案也精确时，即在 K-正交网格上，预计会发生一致。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1: Orthogonal mesh, isotropic K\",\n            \"Nx\": 8, \"Ny\": 7,\n            \"A\": np.identity(2),\n            \"K_params\": {\"type\": \"iso\", \"k\": 2.0},\n            \"grad_p\": np.array([1.3, -0.9])\n        },\n        {\n            \"name\": \"Case 2: Skewed mesh, anisotropic K\",\n            \"Nx\": 8, \"Ny\": 7,\n            \"A\": np.array([[1.0, 0.7], [0.0, 1.0]]),\n            \"K_params\": {\"type\": \"aniso_rot\", \"kx\": 5.0, \"ky\": 1.0, \"theta_deg\": 30.0},\n            \"grad_p\": np.array([1.3, -0.9])\n        },\n        {\n            \"name\": \"Case 3: Orthogonal mesh, anisotropic K (aligned)\",\n            \"Nx\": 8, \"Ny\": 7,\n            \"A\": np.identity(2),\n            \"K_params\": {\"type\": \"aniso_aligned\", \"kx\": 5.0, \"ky\": 1.0},\n            \"grad_p\": np.array([1.3, -0.9])\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_flux_errors(case)\n        results.append(result)\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join(\n        f\"[{res[0]},{res[1]},{str(res[2]).lower()}]\" for res in results\n    ) + \"]\"\n    print(output_str)\n\ndef compute_flux_errors(case_params):\n    \"\"\"\n    Computes mesh, fluxes, and errors for a single test case.\n    \"\"\"\n    Nx, Ny = case_params[\"Nx\"], case_params[\"Ny\"]\n    A = case_params[\"A\"]\n    grad_p = case_params[\"grad_p\"]\n\n    # Build diffusion tensor K\n    k_params = case_params[\"K_params\"]\n    if k_params[\"type\"] == \"iso\":\n        K = k_params[\"k\"] * np.identity(2)\n    elif k_params[\"type\"] == \"aniso_aligned\":\n        K = np.diag([k_params[\"kx\"], k_params[\"ky\"]])\n    elif k_params[\"type\"] == \"aniso_rot\":\n        theta = np.deg2rad(k_params[\"theta_deg\"])\n        c, s = np.cos(theta), np.sin(theta)\n        R = np.array([[c, -s], [s, c]])\n        D = np.diag([k_params[\"kx\"], k_params[\"ky\"]])\n        K = R @ D @ R.T\n\n    # 1. Mesh Generation\n    ref_x = np.linspace(0, 1, Nx + 1)\n    ref_y = np.linspace(0, 1, Ny + 1)\n    ref_vx, ref_vy = np.meshgrid(ref_x, ref_y, indexing='ij')\n    ref_vertices = np.stack([ref_vx, ref_vy], axis=-1)\n    \n    vertices = np.einsum('ij,klj->kli', A, ref_vertices)\n\n    cell_centers = np.zeros((Nx, Ny, 2))\n    for i in range(Nx):\n        for j in range(Ny):\n            cell_centers[i, j] = 0.25 * (vertices[i, j] + vertices[i+1, j] +\n                                         vertices[i, j+1] + vertices[i+1, j+1])\n\n    # 2. MFD: Reconstruct gradients in all cells\n    p_cell = np.einsum('ij,j->i', cell_centers.reshape(-1, 2), grad_p).reshape(Nx, Ny)\n    grad_p_mfd = np.zeros((Nx, Ny, 2))\n    for i in range(Nx):\n        for j in range(Ny):\n            neighbors = []\n            if i > 0: neighbors.append((i - 1, j))\n            if i  Nx - 1: neighbors.append((i + 1, j))\n            if j > 0: neighbors.append((i, j - 1))\n            if j  Ny - 1: neighbors.append((i, j + 1))\n            \n            num_neighbors = len(neighbors)\n            M = np.zeros((num_neighbors, 2))\n            b = np.zeros(num_neighbors)\n            \n            for k, (ni, nj) in enumerate(neighbors):\n                M[k, :] = cell_centers[ni, nj] - cell_centers[i, j]\n                b[k] = p_cell[ni, nj] - p_cell[i, j]\n            \n            # Least-squares solve: grad = (M^T M)^-1 M^T b\n            MTM = M.T @ M\n            MTb = M.T @ b\n            grad_p_mfd[i, j] = np.linalg.solve(MTM, MTb)\n\n    # 3. Loop over interior faces to compute fluxes\n    F_ex_list, F_tpfa_list, F_mfd_list = [], [], []\n\n    # Vertical interior faces\n    for i in range(Nx - 1):\n        for j in range(Ny):\n            # Face between C(i,j) and C(i+1,j)\n            L_idx, R_idx = (i, j), (i + 1, j)\n            \n            v1, v2 = vertices[i + 1, j], vertices[i + 1, j + 1]\n            edge = v2 - v1\n            length = np.linalg.norm(edge)\n            \n            normal_cand = np.array([-edge[1], edge[0]])\n            center_vec = cell_centers[R_idx] - cell_centers[L_idx]\n            if np.dot(normal_cand, center_vec)  0:\n                normal_cand = -normal_cand\n            normal = normal_cand / np.linalg.norm(normal_cand)\n\n            xL, xR = cell_centers[L_idx], cell_centers[R_idx]\n            pL, pR = p_cell[L_idx], p_cell[R_idx]\n\n            # Exact flux\n            F_ex = -length * normal.T @ K @ grad_p\n            F_ex_list.append(F_ex)\n\n            # TPFA flux\n            trans = length * (normal.T @ K @ normal) / np.dot(normal, xR - xL)\n            F_tpfa = -trans * (pR - pL)\n            F_tpfa_list.append(F_tpfa)\n\n            # MFD flux\n            grad_L, grad_R = grad_p_mfd[L_idx], grad_p_mfd[R_idx]\n            grad_face = 0.5 * (grad_L + grad_R)\n            F_mfd = -length * normal.T @ K @ grad_face\n            F_mfd_list.append(F_mfd)\n\n    # Horizontal interior faces\n    for i in range(Nx):\n        for j in range(Ny - 1):\n            # Face between C(i,j) and C(i,j+1)\n            L_idx, R_idx = (i, j), (i, j + 1)\n            \n            v1, v2 = vertices[i, j + 1], vertices[i + 1, j + 1]\n            edge = v2 - v1\n            length = np.linalg.norm(edge)\n\n            normal_cand = np.array([-edge[1], edge[0]])\n            center_vec = cell_centers[R_idx] - cell_centers[L_idx]\n            if np.dot(normal_cand, center_vec)  0:\n                normal_cand = -normal_cand\n            normal = normal_cand / np.linalg.norm(normal_cand)\n            \n            xL, xR = cell_centers[L_idx], cell_centers[R_idx]\n            pL, pR = p_cell[L_idx], p_cell[R_idx]\n\n            # Exact flux\n            F_ex = -length * normal.T @ K @ grad_p\n            F_ex_list.append(F_ex)\n\n            # TPFA flux\n            trans = length * (normal.T @ K @ normal) / np.dot(normal, xR - xL)\n            F_tpfa = -trans * (pR - pL)\n            F_tpfa_list.append(F_tpfa)\n\n            # MFD flux\n            grad_L, grad_R = grad_p_mfd[L_idx], grad_p_mfd[R_idx]\n            grad_face = 0.5 * (grad_L + grad_R)\n            F_mfd = -length * normal.T @ K @ grad_face\n            F_mfd_list.append(F_mfd)\n            \n    # 4. Calculate final errors and coincidence\n    F_ex_vec = np.array(F_ex_list)\n    F_tpfa_vec = np.array(F_tpfa_list)\n    F_mfd_vec = np.array(F_mfd_list)\n\n    norm_F_ex = np.linalg.norm(F_ex_vec)\n    if norm_F_ex == 0: # Avoid division by zero\n        E_tpfa = np.linalg.norm(F_tpfa_vec - F_ex_vec)\n        E_mfd = np.linalg.norm(F_mfd_vec - F_ex_vec)\n        coincidence_err = np.linalg.norm(F_tpfa_vec - F_mfd_vec)\n    else:\n        E_tpfa = np.linalg.norm(F_tpfa_vec - F_ex_vec) / norm_F_ex\n        E_mfd = np.linalg.norm(F_mfd_vec - F_ex_vec) / norm_F_ex\n        coincidence_err = np.linalg.norm(F_tpfa_vec - F_mfd_vec) / norm_F_ex\n\n    coincide = coincidence_err  1e-12\n\n    return [E_tpfa, E_mfd, coincide]\n\n# Execute the solver\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3377674"}]}