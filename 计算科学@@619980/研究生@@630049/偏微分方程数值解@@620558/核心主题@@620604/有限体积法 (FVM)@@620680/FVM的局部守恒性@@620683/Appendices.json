{"hands_on_practices": [{"introduction": "理论是抽象的，而数值实验则能提供直观的理解。本实践旨在通过一个简单的一维平流问题，从代码层面直接验证和比较不同数值方法（有限体积法、有限差分法和间断伽辽金法）的局部守恒特性 [@problem_id:3416942]。通过计算和对比每个单元的守恒残差，您将亲眼见证为什么有限体积法（FVM）因其构造方式而天生满足局部守恒，而其他方法则可能不具备此性质，从而深化对FVM核心优势的认识。", "problem": "考虑一个定义在周期性域上的一维线性平流方程的守恒形式，\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0,\\qquad f(u)=a\\,u,\\qquad x\\in[0,L],\n$$\n其中 $u(x,t)$ 是被平流输运的量，$a$ 是一个恒定的平流速度，$L$ 是域的长度。设该域被均匀离散为 $N$ 个网格单元，网格单元大小为 $h=L/N$。对于任何网格单元 $K_i=[x_i,x_{i+1}]$，精确的局部守恒定律可写为\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\int_{x_i}^{x_{i+1}} u(x,t)\\,\\mathrm{d}x + \\big(f(u(x_{i+1}^{-},t)) - f(u(x_i^{+},t))\\big) = 0,\n$$\n该定律表明，网格单元积分的时间变化由穿过网格单元边界的净通量所平衡。本问题要求您在单个时间点 $t=0$ 计算三种离散化方法的离散逐网格单元平衡残差，并比较哪种方法能够逐单元地保持局部守恒性。\n\n您必须实现并比较：\n- 有限体积法 (FVM)，使用分片常数的网格单元平均值和标准的迎风数值通量；将位于网格单元中心的网格单元平均值定义为 $U_i$，面通量定义为 $F_{i+1/2}=a\\,U^{\\text{upwind}}$，并采用周期性边界条件。\n- 有限差分法 (FDM)，在网格节点 $x_j=jh$（$j=0,\\dots,N-1$）上使用中心差分，并采用周期性边界条件；将网格单元 $[x_i,x_{i+1}]$ 的隐含网格单元平均值定义为 $\\bar{u}_i=(u_i+u_{i+1})/2$，并使用节点上的中心差分时间导数来近似 $\\mathrm{d}\\bar{u}_i/\\mathrm{d}t$。\n- 间断 Galerkin 方法 (DG)，在每个网格单元 $[x_i,x_{i+1}]$ 上使用多项式次数 $p=1$（分片线性表示）和迎风数值通量；使用常数检验函数 $v=1$ 来检验网格单元平均值的时间演化，面上的迹取自每个网格单元内部的多项式（在此设置中，构造多项式以匹配 $x_i$ 和 $x_{i+1}$ 处的端点值，因此其迹与端点处的精确初始值重合）。\n\n对于每种方法，在每个网格单元 $i$ 上，计算离散的逐网格单元平衡残差\n$$\nB_i = h\\,\\frac{\\mathrm{d}}{\\mathrm{d}t}\\bar{u}_i + \\big(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\big),\n$$\n其中 $\\bar{u}_i$ 是该方法对应的网格单元平均值，$F_{i\\pm\\frac{1}{2}}$ 是网格单元 $i$ 的右侧和左侧面上的向外数值通量，并假定使用周期性索引。如果对于所有网格单元 $i$，$B_i=0$ 在离散意义上精确成立（在数值舍入误差范围内），则该方法保持局部守恒性。\n\n您不需要进行时间演化；相反，请直接根据初始条件计算 $t=0$ 时的所有量。使用由频率参数 $k$ 定义的以下初始条件，其中 $k\\in\\mathbb{N}$ 被解释为在 $[0,L]$ 上的波长数量：\n$$\nu(x,0) = \\begin{cases}\n\\sin\\big(2\\pi k\\,x/L\\big),  & k>0,\\\\\n1,  & k=0.\n\\end{cases}\n$$\n\n实现以下参数值的测试套件：\n- 测试 1：$L=1$, $N=32$, $a=1$, $k=1$。\n- 测试 2：$L=1$, $N=32$, $a=-1$, $k=1$。\n- 测试 3：$L=1$, $N=8$, $a=1$, $k=0$。\n- 测试 4：$L=1$, $N=16$, $a=1$, $k=2$。\n\n对于每个测试，计算每种方法在所有网格单元上的残差的最大绝对值：\n$$\nR^{\\text{FVM}}=\\max_i|B_i^{\\text{FVM}}|,\\quad R^{\\text{FDM}}=\\max_i|B_i^{\\text{FDM}}|,\\quad R^{\\text{DG}}=\\max_i|B_i^{\\text{DG}}|.\n$$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个条目对应一个测试用例，并且本身是按 $[R^{\\text{FVM}},R^{\\text{FDM}},R^{\\text{DG}}]$ 顺序排列的包含三个浮点数的列表。例如，输出格式必须是\n$$\n\\big[\\,[R^{\\text{FVM}}_1,R^{\\text{FDM}}_1,R^{\\text{DG}}_1],[R^{\\text{FVM}}_2,R^{\\text{FDM}}_2,R^{\\text{DG}}_2],\\ldots\\,\\big].\n$$\n\n不需要报告物理单位；所有量都是无量纲的。打印的数值必须是原始浮点数，不带任何附加文本。", "solution": "该问题要求分析三种数值方法——有限体积法 (FVM)、有限差分法 (FDM) 和间断 Galerkin 方法 (DG)——对于一维线性平流方程 $\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0$ 的局部守恒性质。该分析通过在时间 $t=0$ 时为每种方法计算离散的逐网格单元平衡残差 $B_i$ 来进行。如果对于每个网格单元，该残差都为零，则该方法是局部守恒的。\n\n我们建立一个一致的离散化框架。域 $[0,L]$ 被划分为 $N$ 个网格单元，其中网格单元 $i$ 是区间 $[x_i, x_{i+1}]$（$i=0, \\dots, N-1$）。网格节点为 $x_i = i h$，网格单元宽度为 $h=L/N$。周期性意味着任何索引 $j$ 都被视为 $j \\pmod N$。网格单元 $i$ 的残差定义为 $B_i = h\\,\\frac{\\mathrm{d}}{\\mathrm{d}t}\\bar{u}_i + (F_{\\text{right}} - F_{\\text{left}})$，其中 $\\bar{u}_i$ 是特定于方法的网格单元平均值，$F_{\\text{right}}$ 和 $F_{\\text{left}}$ 分别是该网格单元右侧 ($x_{i+1}$) 和左侧 ($x_i$) 面上的数值通量。\n\n初始条件由 $u(x,0)$ 给出，当 $k>0$ 时为正弦函数，当 $k=0$ 时为常数。所有量都是在 $t=0$ 时使用此初始条件计算的。\n\n**1. 有限体积法 (FVM)**\n\nFVM 直接由守恒定律的积分形式构建。状态变量是网格单元平均值，$U_i(t) = \\frac{1}{h} \\int_{x_i}^{x_{i+1}} u(x,t) dx$。网格单元 $i$ 的 FVM 半离散形式通过平衡网格单元边界上的通量得出：\n$$\n\\frac{\\mathrm{d}U_i}{\\mathrm{d}t} = -\\frac{1}{h} (F_{i+1} - F_i)\n$$\n其中 $F_j$ 是界面 $x_j$ 处的数值通量。问题指定了基于分片常数网格单元平均值的迎风通量。在网格单元 $j-1$ 和网格单元 $j$ 之间的界面上的通量 $F_j$ 是：\n$$\nF_j = \\begin{cases} a\\,U_{j-1} & \\text{if } a > 0 \\\\ a\\,U_j & \\text{if } a \\le 0 \\end{cases}\n$$\nFVM 要计算的残差是 $B_i^{\\text{FVM}} = h\\,\\frac{\\mathrm{d}U_i}{\\mathrm{d}t} + (F_{i+1} - F_i)$。将 $\\frac{\\mathrm{d}U_i}{\\mathrm{d}t}$ 的 FVM 半离散化形式代入：\n$$\nB_i^{\\text{FVM}} = h \\left( -\\frac{1}{h} (F_{i+1} - F_i) \\right) + (F_{i+1} - F_i) = -(F_{i+1} - F_i) + (F_{i+1} - F_i) = 0\n$$\n这个结果是纯粹代数的，并且无论 $U_i$ 的具体值或初始条件的形式如何都成立。FVM 根据其构造就是局部守恒的。因此，我们预期 $R^{\\text{FVM}} = \\max_i|B_i^{\\text{FVM}}|$ 将为零（在机器精度范围内）。\n\n**2. 间断 Galerkin (DG) 方法**\n\n问题描述了一种使用分片线性多项式 ($p=1$) 的 Galerkin 方法。然而，“构造多项式以匹配 $x_i$ 和 $x_{i+1}$ 处的端点值”这一指令定义了一个全局连续的分片线性函数。这更准确地应称为连续 Galerkin (CG) 方法。一个真正的 DG 方法会允许在网格单元边界处出现间断。我们遵循明确的指示进行。\n\n网格单元 $i$ 上的线性多项式为 $u_h(x) = u(x_i,0)\\frac{x_{i+1}-x}{h} + u(x_{i+1},0)\\frac{x-x_i}{h}$。网格单元平均值 $\\bar{u}_i$ 是 $u_h(x)$ 在 $[x_i, x_{i+1}]$ 上的积分除以 $h$：\n$$\n\\bar{u}_i = \\frac{1}{h} \\int_{x_i}^{x_{i+1}} u_h(x) \\mathrm{d}x = \\frac{u(x_i,0) + u(x_{i+1},0)}{2}\n$$\n在 Galerkin 方法中，网格单元平均值的演化是通过在该网格单元上用常数函数 $v(x)=1$ 检验偏微分方程得到的：\n$$\n\\int_{x_i}^{x_{i+1}} \\frac{\\partial u_h}{\\partial t} \\cdot 1 \\mathrm{d}x + F^*_{i+1} - F^*_{i} = 0 \\implies h \\frac{\\mathrm{d}\\bar{u}_i}{\\mathrm{d}t} + (F^*_{i+1} - F^*_i) = 0\n$$\n此处，$F^*_j$ 是面 $x_j$ 处的数值通量，指定为迎风通量。由于解 $u_h$ 是连续的，在任何界面 $x_j$ 处的左极限和右极限都相同：$u_h(x_j^-) = u_h(x_j^+) = u(x_j,0)$。因此，迎风通量简化为解析通量，$F^*_j = f(u(x_j,0)) = a\\,u(x_j,0)$。\n\n残差为 $B_i^{\\text{DG}} = h\\,\\frac{\\mathrm{d}\\bar{u}_i}{\\mathrm{d}t} + (F^*_{i+1} - F^*_i)$。根据用于网格单元平均值的 Galerkin 格式的定义，该残差恒等于零。与 FVM 一样，此方法根据其构造是局部守恒的。我们预期 $R^{\\text{DG}} = \\max_i|B_i^{\\text{DG}}|$ 将为零（在机器精度范围内）。\n\n**3. 有限差分法 (FDM)**\n\nFDM 方法被指定为一种混合构造。我们使用节点值 $u_j = u(x_j,0)$。\n- 网格单元 $[x_i, x_{i+1}]$ 的隐含网格单元平均值为 $\\bar{u}_i = (u_i + u_{i+1})/2$。\n- 该平均值的时间导数使用节点时间导数来近似：$\\frac{\\mathrm{d}\\bar{u}_i}{\\mathrm{d}t} = \\frac{1}{2}(\\frac{\\mathrm{d}u_i}{\\mathrm{d}t} + \\frac{\\mathrm{d}u_{i+1}}{\\mathrm{d}t})$。\n- 节点时间导数通过偏微分方程 $\\frac{\\partial u}{\\partial t} = -a\\frac{\\partial u}{\\partial x}$ 求得，其中空间导数由二阶中心差分近似：$\\frac{\\mathrm{d}u_j}{\\mathrm{d}t} \\approx -a \\frac{u_{j+1}-u_{j-1}}{2h}$。\n- 面 $x_j$ 处的通量取为节点处的解析通量，$F_j = f(u_j) = a u_j$。\n\n结合这些，项 $h \\frac{\\mathrm{d}\\bar{u}_i}{\\mathrm{d}t}$ 变为：\n$$\nh \\frac{\\mathrm{d}\\bar{u}_i}{\\mathrm{d}t} = \\frac{h}{2} \\left[ \\left( -a \\frac{u_{i+1}-u_{i-1}}{2h} \\right) + \\left( -a \\frac{u_{i+2}-u_{i}}{2h} \\right) \\right] = -\\frac{a}{4} (u_{i+2} + u_{i+1} - u_i - u_{i-1})\n$$\n网格单元 $i$ 的残差为 $B_i^{\\text{FDM}} = h\\frac{\\mathrm{d}\\bar{u}_i}{\\mathrm{d}t} + (F_{i+1} - F_i)$:\n$$\nB_i^{\\text{FDM}} = -\\frac{a}{4} (u_{i+2} + u_{i+1} - u_i - u_{i-1}) + a(u_{i+1} - u_i)\n$$\n$$\nB_i^{\\text{FDM}} = a \\left[ -\\frac{1}{4}u_{i+2} + \\left(1-\\frac{1}{4}\\right)u_{i+1} + \\left(\\frac{1}{4}-1\\right)u_i + \\frac{1}{4}u_{i-1} \\right] = \\frac{a}{4}[-u_{i+2} + 3u_{i+1} - 3u_i + u_{i-1}]\n$$\n这个表达式通常不为零。它表示一个三阶有限差分模板，近似于 $-\\frac{a h^3}{4} \\frac{\\partial^3 u}{\\partial x^3}$。该残差是格式各组成部分截断误差的一种表现，并且将不为零，除非 $u(x,0)$ 是一个 2 次或更低次的多项式（使得 $\\frac{\\partial^3 u}{\\partial x^3}=0$）。对于测试用例 $k=0$，$u(x,0)=1$，因此所有导数都为零，残差也将为零。对于 $k>0$，残差将不为零，这表明这种 FDM 构造不是局部守恒的。\n\n**预测总结**：\n- 对于所有测试用例，$R^{\\text{FVM}}$ 和 $R^{\\text{DG}}$ 将近似为零，反映了它们固有的局部守恒性。\n- 对于 $k>0$，$R^{\\text{FDM}}$ 将不为零；对于 $k=0$，其将为零。", "answer": "```python\nimport numpy as np\n\ndef calculate_residuals(L, N, a, k):\n    \"\"\"\n    Computes the maximum absolute cell-wise balance residuals for FVM, FDM, and DG.\n\n    Args:\n        L (float): Domain length.\n        N (int): Number of cells/nodes.\n        a (float): Advection speed.\n        k (int): Wavenumber for the initial condition.\n\n    Returns:\n        tuple: A tuple containing (R_fvm, R_fdm, R_dg).\n    \"\"\"\n    h = L / N\n    # Grid nodes x_j = j*h for j = 0, ..., N-1\n    x_nodes = np.linspace(0, L, N, endpoint=False)\n    \n    if k == 0:\n        u_nodes = np.ones(N)\n    else:\n        u_nodes = np.sin(2 * np.pi * k * x_nodes / L)\n\n    # --- FVM Calculation ---\n    # Cell i is [x_i, x_{i+1}]. Cell averages U_i are computed.\n    if k == 0:\n        U_cell_avg = np.ones(N)\n    else:\n        # U_i = (1/h) * integral of u(x,0) from x_i to x_{i+1}\n        # Integral of sin(c*x) is -cos(c*x)/c. c = 2*pi*k/L\n        # U_i = (1/h) * [-cos(c*x_{i+1})/c + cos(c*x_i)/c]\n        #     = (L / (2*pi*k*h)) * [cos(c*x_i) - cos(c*x_{i+1})]\n        #     = (N / (2*pi*k)) * [cos(2*pi*k*i/N) - cos(2*pi*k*(i+1)/N)]\n        i = np.arange(N)\n        U_cell_avg = (N / (2 * np.pi * k)) * (np.cos(2 * np.pi * k * i / N) - np.cos(2 * np.pi * k * (i + 1) / N))\n\n    # Flux F_j at interface between cell j-1 and j\n    # We use periodic indexing with np.roll\n    # If a > 0, F_j = a * U_{j-1}\n    # If a = 0, F_j = a * U_j\n    if a > 0:\n        # F_fluxes corresponds to F_0, F_1, ..., F_{N-1}\n        F_fluxes = a * np.roll(U_cell_avg, 1)\n    else:\n        F_fluxes = a * U_cell_avg\n    \n    # Residual for cell i: [x_i, x_{i+1}], uses fluxes F_i and F_{i+1}\n    F_left = F_fluxes\n    F_right = np.roll(F_fluxes, -1)\n    \n    h_dUdt = -(F_right - F_left)\n    B_fvm = h_dUdt + (F_right - F_left)\n    R_fvm = np.max(np.abs(B_fvm))\n\n    # --- FDM Calculation ---\n    # Residual for cell i: [x_i, x_{i+1}]\n    # B_i = (a/4)*[-u_{i+2} + 3*u_{i+1} - 3*u_i + u_{i-1}]\n    if k == 0:\n        R_fdm = 0.0\n    else:\n        u_im1 = np.roll(u_nodes, 1)\n        u_ip1 = np.roll(u_nodes, -1)\n        u_ip2 = np.roll(u_nodes, -2)\n        B_fdm = (a / 4.0) * (-u_ip2 + 3 * u_ip1 - 3 * u_nodes + u_im1)\n        R_fdm = np.max(np.abs(B_fdm))\n\n    # --- DG Calculation ---\n    # Described method is Continuous Galerkin (CG), not DG.\n    # Flux at node j is F*_j = a*u_j\n    F_star_fluxes = a * u_nodes\n    \n    # Residual for cell i: [x_i, x_{i+1}], uses fluxes F*_i and F*_{i+1}\n    F_star_left = F_star_fluxes\n    F_star_right = np.roll(F_star_fluxes, -1)\n    \n    # h * d(u_bar)_i/dt is defined by the scheme\n    h_dubar_dt = -(F_star_right - F_star_left)\n    B_dg = h_dubar_dt + (F_star_right - F_star_left)\n    R_dg = np.max(np.abs(B_dg))\n    \n    return [R_fvm, R_fdm, R_dg]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (L, N, a, k)\n        (1.0, 32, 1.0, 1),\n        (1.0, 32, -1.0, 1),\n        (1.0, 8, 1.0, 0),\n        (1.0, 16, 1.0, 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, a, k = case\n        residuals = calculate_residuals(L, N, a, k)\n        results.append(residuals)\n        \n    # Format the output string\n    # e.g., [[val1,val2,val3],[val4,val5,val6]]\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3416942"}, {"introduction": "局部守恒是有限体积法的基石，但这是否意味着任何FVM格式都能产生物理上合理的解？本练习通过一个精心设计的、在非优网格上使用两点通量近似（TPFA）的扩散问题来探讨这一问题 [@problem_id:3416962]。您将通过精确计算发现，即使格式违反了离散极值原理（DMP），产生了非物理的过冲或下冲，其局部守恒性依然可以被严格维持，这揭示了局部守恒是格式构造的内在属性，而解的整体质量还依赖于通量近似的准确性。", "problem": "考虑由偏微分方程 $-\\nabla \\cdot (k \\nabla u) = 0$ 控制的稳态扩散问题，其中扩散率 $k = 1$ 是各向同性且空间均匀的，无体积源，且边界条件为分段常数的狄利克雷边界数据。使用有限体积法 (FVM) 及两点通量近似 (TPFA) 对该方程进行离散化。离散化基于一个特意构造的扭曲、非容许的三单元网格，该网格保持局部守恒，但已知会因扭曲诱导的系数而倾向于违反离散极值原理 (DMP)。设控制体积为 $V_{1}$、$V_{2}$ 和 $V_{3}$，它们以链状排列，具有两个内部面，分别位于 $V_{1}$ 和 $V_{2}$ 之间以及 $V_{2}$ 和 $V_{3}$ 之间。$V_{1}$ 的外边界服从狄利克雷数据 $u = 0$，$V_{3}$ 的外边界服从狄利克雷数据 $u = 1$。$V_{2}$ 没有附带的边界面。假设基于面的 TPFA 通量方向朝向单元外部，具体如下：\n- 对于由 $V_{i}$ 和 $V_{j}$ 共享的内部面，通量为 $F_{i \\to j} = T_{ij}\\,(u_{i} - u_{j})$，其中系数 $T_{ij} = T_{ji}$ 是对称的，由扭曲网格的几何投影构造得出。内部面的传输系数给定为 $T_{12} = -\\frac{1}{2}$ 和 $T_{23} = \\frac{5}{3}$，这种情况可能出现在强扭曲的非容许网格上。\n- 对于附着在 $V_{1}$ 上且狄利克雷值为 $u=0$ 的边界面，将其视为一个传输系数为 $T_{1b} = 1$ 的虚拟邻居，从而得到边界通量 $F_{1 \\to b} = T_{1b}\\,(u_{1} - 0)$。对于附着在 $V_{3}$ 上且狄利克雷值为 $u=1$ 的边界面，使用 $T_{3b} = 1$ 且 $F_{3 \\to b} = T_{3b}\\,(u_{3} - 1)$。\n\n以守恒定律为基本依据，即对于每个控制体积 $V_{i}$，通过其所有面的向外通量的代数和为零，写出关于未知单元中心值 $u_{1}$、$u_{2}$ 和 $u_{3}$ 的三个平衡方程，并精确求解得到的线性系统。然后计算超调量\n$$\\delta \\equiv \\max\\{u_{1}, u_{2}, u_{3}\\} - 1,$$\n它量化了相对于最大狄利克雷边界值 $1$ 的离散极值原理的违反程度。\n\n简要说明为什么即使该格式违反了离散极值原理，它在每个内部面上仍然保持局部守恒。提供 $\\delta$ 的最终数值，并四舍五入到四位有效数字。无需物理单位。", "solution": "问题陈述是有效的。它提出了偏微分方程数值分析中的一个适定问题，特别涉及有限体积法 (FVM) 的性质。该设置虽然使用了一个人为构造的非容许网格以产生特定结果，但其内部是一致的，并且基于关于离散化方法的既定理论。\n\n有限体积法的核心原理是局部守恒。对于每个控制体积 $V_i$，在没有源或汇的稳态下，守恒量穿过其边界的净通量为零。对于一个通用控制体积 $V_i$，这表示为：\n$$\n\\sum_{j \\in N(i)} F_{i \\to j} = 0\n$$\n其中 $N(i)$ 是单元 $i$ 的邻居集合（包括被视为邻居的边界片），$F_{i \\to j}$ 是从单元 $i$ 到单元 $j$ 的通量。问题给出了两点通量近似 (TPFA) 的通量定律。我们将此守恒原理应用于三个控制体积 $V_1$、$V_2$ 和 $V_3$ 中的每一个。\n\n对于控制体积 $V_1$：\n单元 $V_1$ 与其内部邻居 $V_2$ 以及一个给定值为 $u=0$ 的边界面交换通量。平衡方程为：\n$$\nF_{1 \\to 2} + F_{1 \\to b} = 0\n$$\n根据给定的通量定义，$F_{1 \\to 2} = T_{12}(u_1 - u_2)$ 和 $F_{1 \\to b} = T_{1b}(u_1 - 0)$。代入给定的传输系数值 $T_{12} = -\\frac{1}{2}$ 和 $T_{1b} = 1$：\n$$\n\\left(-\\frac{1}{2}\\right)(u_1 - u_2) + (1)(u_1 - 0) = 0\n$$\n$$\n-\\frac{1}{2}u_1 + \\frac{1}{2}u_2 + u_1 = 0\n$$\n$$\n\\frac{1}{2}u_1 + \\frac{1}{2}u_2 = 0 \\implies u_1 + u_2 = 0\n$$\n\n对于控制体积 $V_2$：\n单元 $V_2$ 是一个内部单元，与邻居 $V_1$ 和 $V_3$ 交换通量。平衡方程是：\n$$\nF_{2 \\to 1} + F_{2 \\to 3} = 0\n$$\n通量为 $F_{2 \\to 1} = T_{21}(u_2 - u_1)$ 和 $F_{2 \\to 3} = T_{23}(u_2 - u_3)$。鉴于传输系数是对称的，$T_{21} = T_{12} = -\\frac{1}{2}$。另一个给定的值是 $T_{23} = \\frac{5}{3}$。\n$$\n\\left(-\\frac{1}{2}\\right)(u_2 - u_1) + \\left(\\frac{5}{3}\\right)(u_2 - u_3) = 0\n$$\n乘以 $6$ 以消去分母：\n$$\n-3(u_2 - u_1) + 10(u_2 - u_3) = 0\n$$\n$$\n-3u_2 + 3u_1 + 10u_2 - 10u_3 = 0\n$$\n$$\n3u_1 + 7u_2 - 10u_3 = 0\n$$\n\n对于控制体积 $V_3$：\n单元 $V_3$ 与其内部邻居 $V_2$ 以及一个给定值为 $u=1$ 的边界面交换通量。平衡方程是：\n$$\nF_{3 \\to 2} + F_{3 \\to b} = 0\n$$\n通量为 $F_{3 \\to 2} = T_{32}(u_3 - u_2)$ 和 $F_{3 \\to b} = T_{3b}(u_3 - 1)$。由于传输系数是对称的，$T_{32} = T_{23} = \\frac{5}{3}$，且给定 $T_{3b}=1$：\n$$\n\\left(\\frac{5}{3}\\right)(u_3 - u_2) + (1)(u_3 - 1) = 0\n$$\n乘以 $3$：\n$$\n5(u_3 - u_2) + 3(u_3 - 1) = 0\n$$\n$$\n5u_3 - 5u_2 + 3u_3 - 3 = 0\n$$\n$$\n-5u_2 + 8u_3 = 3\n$$\n\n我们现在得到了一个关于三个未知数 $u_1$、$u_2$ 和 $u_3$ 的三元线性方程组：\n$$\n\\begin{cases}\n\\quad u_1 + u_2 = 0  (1) \\\\\n\\quad 3u_1 + 7u_2 - 10u_3 = 0  (2) \\\\\n\\quad -5u_2 + 8u_3 = 3  (3)\n\\end{cases}\n$$\n从方程 $(1)$，我们得到 $u_1 = -u_2$。将此代入方程 $(2)$：\n$$\n3(-u_2) + 7u_2 - 10u_3 = 0 \\implies 4u_2 - 10u_3 = 0 \\implies 2u_2 = 5u_3\n$$\n根据这个关系，我们可以用 $u_2$ 表示 $u_3$ 为 $u_3 = \\frac{2}{5}u_2$。现在我们将这个 $u_3$ 的表达式代入方程 $(3)$：\n$$\n-5u_2 + 8\\left(\\frac{2}{5}u_2\\right) = 3\n$$\n$$\n-5u_2 + \\frac{16}{5}u_2 = 3\n$$\n$$\n\\left(-\\frac{25}{5} + \\frac{16}{5}\\right)u_2 = 3 \\implies -\\frac{9}{5}u_2 = 3\n$$\n解出 $u_2$：\n$$\nu_2 = 3 \\cdot \\left(-\\frac{5}{9}\\right) = -\\frac{15}{9} = -\\frac{5}{3}\n$$\n现在我们可以求出 $u_1$ 和 $u_3$：\n$$\nu_1 = -u_2 = -\\left(-\\frac{5}{3}\\right) = \\frac{5}{3}\n$$\n$$\nu_3 = \\frac{2}{5}u_2 = \\frac{2}{5}\\left(-\\frac{5}{3}\\right) = -\\frac{2}{3}\n$$\n单元中心值的解是 $(u_1, u_2, u_3) = (\\frac{5}{3}, -\\frac{5}{3}, -\\frac{2}{3})$。边界条件是 $u=0$ 和 $u=1$。离散极值原理 (DMP) 要求所有单元值都位于边界值的范围内，即 $0 \\le u_i \\le 1$。我们的解明显违反了这一原理，其中 $u_1 \\approx 1.667$，$u_2 \\approx -1.667$，$u_3 \\approx -0.667$。这种违反源于负的传输系数 $T_{12}=-\\frac{1}{2}$，这是在非容许（例如，高度扭曲的）网格上应用 TPFA 的已知后果。\n\n接下来，我们计算超调量 $\\delta$：\n$$\n\\delta \\equiv \\max\\{u_1, u_2, u_3\\} - 1\n$$\n$$\n\\delta = \\max\\left\\{\\frac{5}{3}, -\\frac{5}{3}, -\\frac{2}{3}\\right\\} - 1 = \\frac{5}{3} - 1 = \\frac{2}{3}\n$$\n问题要求将此值四舍五入到四位有效数字。\n$$\n\\delta = \\frac{2}{3} \\approx 0.666666... \\approx 0.6667\n$$\n\n最后，我们说明为什么该格式仍然保持局部守恒。在单元 $V_i$ 和 $V_j$ 之间的内部面上，局部守恒要求从 $V_i$ 流入 $V_j$ 的通量恰好是从 $V_j$ 流入 $V_i$ 的通量的负值。在我们的记法中，这意味着 $F_{i \\to j} = - F_{j \\to i}$。\n从 $V_i$ 到 $V_j$ 的通量定义为 $F_{i \\to j} = T_{ij}(u_i - u_j)$。\n从 $V_j$ 到 $V_i$ 的通量定义为 $F_{j \\to i} = T_{ji}(u_j - u_i)$。\n问题陈述指出传输系数是对称的，即 $T_{ij} = T_{ji}$。利用这个性质：\n$$\nF_{j \\to i} = T_{ji}(u_j - u_i) = T_{ij}(u_j - u_i) = -T_{ij}(u_i - u_j) = -F_{i \\to j}\n$$\n这个关系对任何 $T_{ij}$ 的值都成立，无论是正值还是负值。因此，局部守恒性质是单元间通量对称定义的直接结果，并且完全独立于传输系数的符号。因此，即使负的 $T_{ij}$ 导致违反 DMP，FVM 格式在构造上仍然是局部守恒的。", "answer": "$$\n\\boxed{0.6667}\n$$", "id": "3416962"}, {"introduction": "在处理具有复杂几何（如倾斜网格）和各向异性材料属性的实际工程问题时，简单的两点通量近似（TPFA）往往会失效。本实践将引导您设计并实现一种更先进的多点通量近似（MPFA）格式，以应对这些挑战 [@problem_id:3417012]。通过在不同网格和各向异性张量下实施和测试TPFA和MPFA，您不仅将诊断出TPFA失效的根本原因，还将掌握如何通过更精确的梯度重构来构建保持局部守恒的、更鲁棒的通量格式，这是进行高保真物理仿真的关键技能。", "problem": "考虑一个在二维域上定义的各向异性扩散偏微分方程 (PDE) $-\\nabla\\cdot(K\\nabla u)=f$，其中 $K\\in\\mathbb{R}^{2\\times 2}$ 是一个对称正定渗透率张量，$u:\\Omega\\subset\\mathbb{R}^2\\to\\mathbb{R}$ 是标量势，$f:\\Omega\\to\\mathbb{R}$ 是一个源项。你将设计并分析一种单元中心有限体积法中的面通量重构，以确保在扭曲网格上的局部守恒性。本问题的基础是散度定理和有限体积平衡律：对于每个控制体 $V_i$，其边界为 $\\partial V_i$，外单位法向量为 $\\boldsymbol{n}$，精确的平衡关系为\n$$\n\\int_{\\partial V_i} \\boldsymbol{n}\\cdot(K\\nabla u)\\,ds=\\int_{V_i} f\\,dx.\n$$\n此任务分为三个部分：诊断两点通量近似的失效模式，构建一种在扭曲网格上保持局部平衡的多点通量，以及实现定量的单元平衡测试。\n\n使用以下设置以确保科学真实性和可复现性：\n\n- 该域由一个均匀的 $2\\times 2$ 四边形网格（节点为 $(x,y)\\in\\{0,\\tfrac{1}{2},1\\}\\times\\{0,\\tfrac{1}{2},1\\}$）经过一个行列式为正的线性变换 $T\\in\\mathbb{R}^{2\\times 2}$ 的仿射映射离散化。每个单元都是一个平行四边形，其顶点是单位正方形顶点在 $T$ 下的像；单元按逆时针顺序排列。对于每个单元 $V_i$，定义其形心 $\\boldsymbol{c}_i$ 和多边形面积 $|V_i|$。\n- 解析解被规定为一个二次多项式 $u(x,y)=x^2+2xy+3y^2+x+y$，这产生一个常数 Hessian 矩阵 $H=\\begin{bmatrix}2  2\\\\2  6\\end{bmatrix}$ 和一个线性梯度 $\\nabla u(x,y)=(2x+2y+1,2x+6y+1)$。源项通过 $K$ 和 $H$ 的缩并指定：$f=\\sum_{i=1}^2\\sum_{j=1}^2 K_{ij}H_{ij}$，它在整个域上是常数。因此，精确的单元平衡满足 $\\sum_{F\\subset\\partial V_i}\\int_F \\boldsymbol{n}\\cdot(K\\nabla u)\\,ds = f\\,|V_i|$，其中 $F$ 表示单元边界的一个面。\n- 对于每个端点为 $(\\boldsymbol{v}_1,\\boldsymbol{v}_2)$ 且长度为 $|F|=\\|\\boldsymbol{v}_2-\\boldsymbol{v}_1\\|$ 的面 $F$，通过将边向量顺时针旋转 $90^\\circ$ 并归一化来定义单元 $V_i$ 的外单位法向量 $\\boldsymbol{n}_{i,F}$。面中点是 $\\boldsymbol{m}_F=(\\boldsymbol{v}_1+\\boldsymbol{v}_2)/2$。\n\n你必须实现并比较以下两种通量构造方法：\n\n1. 两点通量近似 (TPFA)：对于由单元 $V_i$ 和 $V_j$ 共享的每个内部面 $F$，其形心分别为 $\\boldsymbol{c}_i$ 和 $\\boldsymbol{c}_j$，定义从 $V_i$ 穿过 $F$ 的外向通量为\n$$\nF^{\\mathrm{TP}}_{i,F} = |F|\\,\\frac{\\boldsymbol{n}_{i,F}^\\top K\\,\\boldsymbol{n}_{i,F}}{d_{i,F}}\\,(u(\\boldsymbol{c}_i)-u(\\boldsymbol{c}_j)),\n$$\n其中 $d_{i,F}=\\boldsymbol{n}_{i,F}\\cdot(\\boldsymbol{c}_j-\\boldsymbol{c}_i)$。对于单元 $V_i$ 的一个边界面 $F$，使用 Dirichlet 迹 $u(\\boldsymbol{m}_F)$ 并设置\n$$\nF^{\\mathrm{TP}}_{i,F} = |F|\\,\\frac{\\boldsymbol{n}_{i,F}^\\top K\\,\\boldsymbol{n}_{i,F}}{d_{i,F}}\\,(u(\\boldsymbol{c}_i)-u(\\boldsymbol{m}_F)),\n$$\n其中 $d_{i,F}=\\boldsymbol{n}_{i,F}\\cdot(\\boldsymbol{m}_F-\\boldsymbol{c}_i)$。\n\n2. 多点通量近似 (MPFA，通过最小二乘梯度重构)：对于每个单元 $V_i$，通过求解最小二乘问题来重构一个梯度 $\\boldsymbol{g}_i\\in\\mathbb{R}^2$\n$$\n\\min_{\\boldsymbol{g}_i\\in\\mathbb{R}^2}\\sum_{P\\in\\mathcal{N}_i}\\big(u(P)-u(\\boldsymbol{c}_i)-\\boldsymbol{g}_i\\cdot(P-\\boldsymbol{c}_i)\\big)^2,\n$$\n其中 $\\mathcal{N}_i$ 是由 $V_i$ 的相邻单元（跨面）的形心组成的集合，对于边界面，还包括面中点 $\\boldsymbol{m}_F$。对于由 $V_i$ 和 $V_j$ 共享的每个内部面 $F$，通过 $\\boldsymbol{g}_F=(\\boldsymbol{g}_i+\\boldsymbol{g}_j)/2$ 定义面梯度，并定义从 $V_i$ 的外向通量为\n$$\nF^{\\mathrm{MP}}_{i,F} = |F|\\,\\boldsymbol{n}_{i,F}\\cdot\\big(K\\,\\boldsymbol{g}_F\\big).\n$$\n对于 $V_i$ 的每个边界面 $F$，设置 $\\boldsymbol{g}_F=\\boldsymbol{g}_i$ 并且\n$$\nF^{\\mathrm{MP}}_{i,F} = |F|\\,\\boldsymbol{n}_{i,F}\\cdot\\big(K\\,\\boldsymbol{g}_F\\big).\n$$\n\n你的程序必须：\n\n- 为每个指定的线性变换 $T$ 构建网格。\n- 计算单元面积 $|V_i|$、外单位法向量 $\\boldsymbol{n}_{i,F}$、形心 $\\boldsymbol{c}_i$ 和面中点 $\\boldsymbol{m}_F$。\n- 使用上述公式计算所有面和所有单元的 $F^{\\mathrm{TP}}_{i,F}$ 和 $F^{\\mathrm{MP}}_{i,F}$，并评估局部残差\n$$\nR^{\\mathrm{TP}}_i=\\sum_{F\\subset\\partial V_i}F^{\\mathrm{TP}}_{i,F}-f\\,|V_i|,\\qquad R^{\\mathrm{MP}}_i=\\sum_{F\\subset\\partial V_i}F^{\\mathrm{MP}}_{i,F}-f\\,|V_i|.\n$$\n- 对于每个测试案例，报告所有单元中的最大绝对残差，即 $\\max_i|R^{\\mathrm{TP}}_i|$ 和 $\\max_i|R^{\\mathrm{MP}}_i|$。\n\n你必须包括一小组精心选择的参数值作为测试套件，以探测试错模式和成功案例：\n\n- 测试案例 1 (中等扭曲，非对角各向异性): $T=\\begin{bmatrix}1.0  0.4\\\\0.2  1.1\\end{bmatrix}$, $K=\\begin{bmatrix}5  2\\\\2  1\\end{bmatrix}$。\n- 测试案例 2 (更强扭曲，非对角各向异性): $T=\\begin{bmatrix}1.0  0.8\\\\0.6  1.2\\end{bmatrix}$, $K=\\begin{bmatrix}9  4\\\\4  2\\end{bmatrix}$。\n- 测试案例 3 (正交网格，对角各向异性): $T=\\begin{bmatrix}1  0\\\\0  1\\end{bmatrix}$, $K=\\operatorname{diag}(4,1)$。\n- 测试案例 4 (正交网格，非对角各向异性): $T=\\begin{bmatrix}1  0\\\\0  1\\end{bmatrix}$, $K=\\begin{bmatrix}5  2\\\\2  1.5\\end{bmatrix}$。\n\n你的程序应该产生一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为 $[\\text{案例 1 的 }\\max_i|R^{\\mathrm{TP}}_i|,\\text{案例 1 的 }\\max_i|R^{\\mathrm{MP}}_i|,\\text{案例 2 的 }\\max_i|R^{\\mathrm{TP}}_i|,\\text{案例 2 的 }\\max_i|R^{\\mathrm{MP}}_i|,\\text{案例 3 的 }\\max_i|R^{\\mathrm{TP}}_i|,\\text{案例 3 的 }\\max_i|R^{\\mathrm{MP}}_i|,\\text{案例 4 的 }\\max_i|R^{\\mathrm{TP}}_i|,\\text{案例 4 的 }\\max_i|R^{\\mathrm{MP}}_i|]$。输出必须是浮点数。\n\n你的解答必须从散度定理和有限体积平衡律开始，并且必须解释为什么两点通量近似在具有非对角 $K$ 的扭曲网格上会失效，以及带最小二乘梯度重构的多点通量如何缓解此问题并改善局部守恒性。除了指定的基础理论外，不允许使用任何快捷公式。此问题不涉及物理单位。如果出现角度，必须以弧度为单位，但几何是纯线性的，不需要角度单位。", "solution": "当前问题要求对一个二维各向异性扩散方程 $-\\nabla\\cdot(K\\nabla u)=f$ 的两种有限体积通量近似方法进行分析和实现。我们必须在各种网格（其中一些是扭曲的）上验证两点通量近似 (TPFA) 和多点通量近似 (MPFA) 的局部守恒性质。验证是通过计算一个已知二次解的单元残差来进行的。\n\n让我们从有限体积法 (FVM) 的基本原理——守恒律的积分形式开始。对于域 $\\Omega$ 内的任何控制体（单元）$V_i$，散度定理表明：\n$$\n\\int_{V_i} \\nabla \\cdot \\boldsymbol{J} \\, d\\boldsymbol{x} = \\int_{\\partial V_i} \\boldsymbol{J} \\cdot \\boldsymbol{n} \\, ds\n$$\n其中 $\\boldsymbol{J}$ 是通量向量，$\\boldsymbol{n}$ 是边界 $\\partial V_i$ 的外单位法向量。对于给定的扩散方程，通量为 $\\boldsymbol{J} = -K\\nabla u$。将其代入 PDE，我们得到 $\\nabla \\cdot (K\\nabla u) = -f$。因此，单元 $V_i$ 的积分平衡律为：\n$$\n\\int_{V_i} (-f) \\, d\\boldsymbol{x} = \\int_{\\partial V_i} (-K\\nabla u) \\cdot \\boldsymbol{n} \\, ds\n$$\n重新整理并使用问题陈述中关于外法向量的约定，得到每个单元的精确平衡方程：\n$$\n\\sum_{F \\subset \\partial V_i} \\int_F (K\\nabla u) \\cdot \\boldsymbol{n}_{i,F} \\, ds = \\int_{V_i} f \\, d\\boldsymbol{x}\n$$\n其中 $\\partial V_i$ 被划分为一组面 $F$，$\\boldsymbol{n}_{i,F}$ 是相对于单元 $V_i$ 的面 $F$ 的外单位法向量。\n\nFVM 的核心在于近似这些积分。右侧被近似为 $\\int_{V_i} f \\, d\\boldsymbol{x} \\approx f(\\boldsymbol{c}_i) |V_i|$，其中 $\\boldsymbol{c}_i$ 是单元的形心，而 $|V_i|$ 是单元的面积。由于人为设定的解法提供了一个常数源项 $f$，这个近似是精确的：$\\int_{V_i} f \\, d\\boldsymbol{x} = f |V_i|$。\n\n左侧的通量积分通过对面上的数值通量求和来近似：\n$$\n\\sum_{F \\subset \\partial V_i} \\int_F (K\\nabla u) \\cdot \\boldsymbol{n}_{i,F} \\, ds \\approx \\sum_{F \\subset \\partial V_i} F_{i,F}\n$$\n其中 $F_{i,F}$ 是表示通过面 $F$ 流出单元 $V_i$ 的总流量的数值通量。离散平衡方程变为 $\\sum_{F \\subset \\partial V_i} F_{i,F} = f |V_i|$。我们被要求为两种不同的 $F_{i,F}$ 定义计算单元残差 $R_i = \\sum_{F \\subset \\partial V_i} F_{i,F} - f |V_i|$。较小的残差表示对于给定的解析解有更好的局部守恒性。\n\n**1. 两点通量近似 (TPFA) 及其局限性**\n\nTPFA 方法仅使用相邻两个单元的中心（或一个单元中心和一个边界点）的解值来近似面上的通量。对于单元 $V_i$ 和 $V_j$ 之间的一个内部面 $F$，通量为：\n$$\nF^{\\mathrm{TP}}_{i,F} = |F|\\,\\frac{\\boldsymbol{n}_{i,F}^\\top K\\,\\boldsymbol{n}_{i,F}}{d_{i,F}}\\,(u(\\boldsymbol{c}_i)-u(\\boldsymbol{c}_j))\n$$\n其中 $d_{i,F}=\\boldsymbol{n}_{i,F}\\cdot(\\boldsymbol{c}_j-\\boldsymbol{c}_i)$。\n\nTPFA 的基本假设是，面上的通量是由投影到特定方向上的势差驱动的，并且张量 $K$ 仅通过其在面法线方向上的投影来贡献。让我们分析一下。项 $u(\\boldsymbol{c}_j)-u(\\boldsymbol{c}_i)$ 近似了 $\\nabla u \\cdot (\\boldsymbol{c}_j - \\boldsymbol{c}_i)$。数值通量实际上是 $-|F| (\\boldsymbol{n}_{i,F}^\\top K \\boldsymbol{n}_{i,F}) \\frac{\\nabla u \\cdot (\\boldsymbol{c}_j - \\boldsymbol{c}_i)}{\\boldsymbol{n}_{i,F} \\cdot (\\boldsymbol{c}_j - \\boldsymbol{c}_i)}$ 的一个近似。精确通量（在面中点 $\\boldsymbol{m}_F$ 处近似）是 $|F|\\, \\boldsymbol{n}_{i,F} \\cdot (K \\nabla u)|_{\\boldsymbol{m}_F}$。\n\nTPFA 近似仅在一个严格的条件下才是一致的（即，当网格尺寸趋于零时，它收敛到精确通量），这个条件被称为 K-正交性。该条件要求向量 $K(\\boldsymbol{c}_j - \\boldsymbol{c}_i)$ 平行于面法线 $\\boldsymbol{n}_{i,F}$。\n- 如果 $K$ 是各向同性的 ($K=kI$)，该条件简化为网格是正交的，意味着连接单元中心的线 $\\boldsymbol{c}_j - \\boldsymbol{c}_i$ 平行于法线 $\\boldsymbol{n}_{i,F}$。这对矩形网格成立，但对测试案例 1 和 2 中的扭曲平行四边形网格则不成立。\n- 如果网格是正交的，但张量 $K$ 是具有非对角项的各向异性张量（测试案例 4），则向量 $\\boldsymbol{c}_j - \\boldsymbol{c}_i$ 平行于 $\\boldsymbol{n}_{i,F}$，但 $K(\\boldsymbol{c}_j - \\boldsymbol{c}_i)$ 通常不平行。通量在面上有一个由梯度的法向分量引起的切向分量，而 TPFA 完全忽略了这一点。\n\n这种未能考虑完整张量 $K$ 和几何扭曲的情况导致了显著的一致性误差。因此，即使使用精确解进行评估，TPFA 通量之和也不会与源项平衡，从而导致较大的残差 $R^{\\mathrm{TP}}_i$。\n\n**2. 用于提高精度的多点通量近似 (MPFA)**\n\nMPFA 方法旨在克服 TPFA 的局限性。其关键思想是在每个单元内获得一个更准确、更稳健的解的梯度 $\\nabla u$ 的近似。问题指定了梯度 $\\boldsymbol{g}_i \\approx \\nabla u(\\boldsymbol{c}_i)$ 的最小二乘重构。对于每个单元 $V_i$，我们求解：\n$$\n\\min_{\\boldsymbol{g}_i\\in\\mathbb{R}^2}\\sum_{P\\in\\mathcal{N}_i}\\big(u(P)-u(\\boldsymbol{c}_i)-\\boldsymbol{g}_i\\cdot(P-\\boldsymbol{c}_i)\\big)^2\n$$\n其中 $\\mathcal{N}_i$ 是一个邻近点（单元形心和边界面中点）的模板。该公式找到了平面梯度 $\\boldsymbol{g}_i$，该平面最能拟合邻域 $\\mathcal{N}_i$ 中各点的解值。这是一个关于 $\\boldsymbol{g}_i$ 的两个分量的标准线性最小二乘问题，可以表述为一个 $2 \\times 2$ 线性系统并求解。\n\n这种重构的一个关键性质是它对线性函数是精确的。如果 $u(\\boldsymbol{x})$ 是线性的，那么 $u(P)-u(\\boldsymbol{c}_i) = \\nabla u \\cdot(P-\\boldsymbol{c}_i)$，并且最小化问题的唯一解是 $\\boldsymbol{g}_i = \\nabla u$，前提是模板点 $P$ 不共线。\n\n然后使用这些重构的梯度计算 MPFA 通量。对于 $V_i$ 和 $V_j$ 之间的一个内部面：\n$$\nF^{\\mathrm{MP}}_{i,F} = |F|\\,\\boldsymbol{n}_{i,F}\\cdot\\big(K\\,\\boldsymbol{g}_F\\big), \\quad \\text{其中 } \\boldsymbol{g}_F=\\frac{\\boldsymbol{g}_i+\\boldsymbol{g}_j}{2}\n$$\n面梯度 $\\boldsymbol{g}_F$ 是面上的 $\\nabla u$ 的一个近似。因为这种通量公式使用了完整的张量 $K$ 和一个完整的梯度向量 $\\boldsymbol{g}_F$（它比 TPFA 中隐式使用的梯度近似要好得多），所以它正确地考虑了来自梯度和张量所有分量的通量贡献。它不受 K-正交性约束的影响。\n\n对于线性解，其中 $\\boldsymbol{g}_i = \\boldsymbol{g}_j = \\nabla u$，数值通量变为 $|F|\\,\\boldsymbol{n}_{i,F}\\cdot(K\\nabla u)$，这是精确通量积分的中点法则近似。如果被积函数是常数，则该积分是精确的，而对于线性解正是这种情况。对于给定的二次解 $u(x,y)$，梯度 $\\nabla u$ 是线性的。梯度重构不再是精确的，但它是二阶准确的。通量积分的中点法则也是精确的，因为被积函数 $(K\\nabla u) \\cdot \\boldsymbol{n}_{i,F}$ 沿面是线性函数。MPFA 方案中的主要误差将来自近似 $\\boldsymbol{g}_F \\approx \\nabla u(\\boldsymbol{m}_F)$。尽管如此，这远比 TPFA 准确。\n\n因此，我们预期 MPFA 残差 $R^{\\mathrm{MP}}_i$ 对于所有测试案例都将接近于零，这显示了它在一般网格和各向异性张量上的稳健性和准确性。相比之下，$R^{\\mathrm{TP}}_i$ 对于任何违反 K-正交性条件的案例（案例 1、2 和 4）都会很大，仅在最理想的案例（案例 3）中才会很小。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the anisotropic diffusion problem by comparing TPFA and MPFA\n    flux approximations on a 2x2 grid for four different test cases.\n    \"\"\"\n    \n    # Test case 1: moderate skew, off-diagonal anisotropy\n    T1 = np.array([[1.0, 0.4], [0.2, 1.1]])\n    K1 = np.array([[5.0, 2.0], [2.0, 1.0]])\n\n    # Test case 2: stronger skew, off-diagonal anisotropy\n    T2 = np.array([[1.0, 0.8], [0.6, 1.2]])\n    K2 = np.array([[9.0, 4.0], [4.0, 2.0]])\n\n    # Test case 3: orthogonal grid, diagonal anisotropy\n    T3 = np.array([[1.0, 0.0], [0.0, 1.0]])\n    K3 = np.array([[4.0, 0.0], [0.0, 1.0]])\n\n    # Test case 4: orthogonal grid, off-diagonal anisotropy\n    T4 = np.array([[1.0, 0.0], [0.0, 1.0]])\n    K4 = np.array([[5.0, 2.0], [2.0, 1.5]])\n\n    test_cases = [\n        (T1, K1),\n        (T2, K2),\n        (T3, K3),\n        (T4, K4)\n    ]\n\n    # Analytic solution u(x,y) and its Hessian H\n    # u(x,y) = x^2 + 2xy + 3y^2 + x + y\n    def u_func(p):\n        x, y = p[0], p[1]\n        return x**2 + 2*x*y + 3*y**2 + x + y\n\n    H = np.array([[2.0, 2.0], [2.0, 6.0]])\n\n    results = []\n    \n    # Base grid topology\n    base_nodes = np.array([\n        [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],\n        [0.0, 0.5], [0.5, 0.5], [1.0, 0.5],\n        [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]\n    ])\n    \n    # Cell to node index mapping (counter-clockwise)\n    cell_node_indices = [\n        (0, 1, 4, 3),  # Cell 0: bottom-left\n        (1, 2, 5, 4),  # Cell 1: bottom-right\n        (4, 5, 8, 7),  # Cell 2: top-right\n        (3, 4, 7, 6)   # Cell 3: top-left\n    ]\n    \n    # Cell neighbors: (right, top, left, bottom) neighbor cell index (-1 for boundary)\n    cell_neighbors = [\n        (1, 3, -1, -1), # Cell 0\n        (-1, 2, 0, -1), # Cell 1\n        (-1, -1, 3, 1), # Cell 2\n        (2, -1, -1, 0)  # Cell 3\n    ]\n\n    for T, K in test_cases:\n        # Calculate constant source term f = tr(K*H)\n        f_source = np.trace(K @ H)\n\n        # 1. Construct Mesh and Geometric Properties\n        nodes = (T @ base_nodes.T).T\n        \n        cells = []\n        for i in range(4):\n            v_idx = cell_node_indices[i]\n            vertices = nodes[list(v_idx)]\n            centroid = np.mean(vertices, axis=0)\n            # Area of parallelogram\n            area = np.abs(np.linalg.det([vertices[1]-vertices[0], vertices[3]-vertices[0]]))\n            cells.append({'id': i, 'vertices': vertices, 'centroid': centroid, 'area': area, 'faces':[]})\n\n        faces = []\n        face_map = {}\n        for i in range(4):\n            v_idx = cell_node_indices[i]\n            for j in range(4):\n                v1_idx, v2_idx = v_idx[j], v_idx[(j+1)%4]\n                face_key = tuple(sorted((v1_idx, v2_idx)))\n                if face_key not in face_map:\n                    v1, v2 = nodes[v1_idx], nodes[v2_idx]\n                    edge = v2 - v1\n                    face = {\n                        'id': len(faces),\n                        'nodes': (v1, v2),\n                        'midpoint': (v1 + v2) / 2.0,\n                        'length': np.linalg.norm(edge),\n                        'cells': [i, -1] # [cell1, cell2]\n                    }\n                    face_map[face_key] = face\n                    faces.append(face)\n                else: # This is a shared interior face\n                    face_map[face_key]['cells'][1] = i\n        \n        # 2. Compute TPFA residuals\n        R_tpfa = np.zeros(4)\n        for i in range(4):\n            cell = cells[i]\n            v_idx = cell_node_indices[i]\n            for j in range(4):\n                v1_idx, v2_idx = v_idx[j], v_idx[(j+1)%4]\n                face = face_map[tuple(sorted((v1_idx, v2_idx)))]\n                \n                v1, v2 = face['nodes']\n                edge = v2 - v1\n                normal = np.array([edge[1], -edge[0]]) / face['length']\n                \n                # Ensure normal is outward for cell i\n                if np.dot(normal, face['midpoint'] - cell['centroid'])  0:\n                    normal *= -1.0\n                \n                c_i = cell['centroid']\n                is_boundary = face['cells'][1] == -1 or face['cells'][0] == face['cells'][1]\n                \n                if is_boundary:\n                    u_i = u_func(c_i)\n                    p_j = face['midpoint']\n                    u_j = u_func(p_j)\n                    d_ij = np.dot(normal, p_j - c_i)\n                else: \n                    neighbor_cell_idx = face['cells'][0] if face['cells'][0] != i else face['cells'][1]\n                    c_j = cells[neighbor_cell_idx]['centroid']\n                    u_i = u_func(c_i)\n                    u_j = u_func(c_j)\n                    d_ij = np.dot(normal, c_j - c_i)\n\n                transmissibility = face['length'] * (normal @ K @ normal) / d_ij\n                flux = transmissibility * (u_i - u_j)\n                R_tpfa[i] += flux\n\n        R_tpfa -= f_source * np.array([c['area'] for c in cells])\n        max_R_tpfa = np.max(np.abs(R_tpfa))\n        \n        # 3. Compute MPFA residuals\n        # 3.1. Reconstruct gradients\n        gradients = np.zeros((4, 2))\n        for i in range(4):\n            cell = cells[i]\n            c_i = cell['centroid']\n            u_ci = u_func(c_i)\n\n            A = np.zeros((2, 2))\n            b = np.zeros(2)\n            \n            # Build neighborhood\n            neighborhood_points = []\n            # Neighbors across faces\n            v_idx = cell_node_indices[i]\n            for j in range(4):\n                v1_idx, v2_idx = v_idx[j], v_idx[(j+1)%4]\n                face = face_map[tuple(sorted((v1_idx, v2_idx)))]\n                is_boundary = face['cells'][1] == -1 or face['cells'][0] == face['cells'][1]\n                if is_boundary:\n                    neighborhood_points.append(face['midpoint'])\n                else:\n                    neighbor_cell_idx = face['cells'][0] if face['cells'][0] != i else face['cells'][1]\n                    neighborhood_points.append(cells[neighbor_cell_idx]['centroid'])\n\n            for p_j in neighborhood_points:\n                delta_p = p_j - c_i\n                delta_u = u_func(p_j) - u_ci\n                A[0, 0] += delta_p[0] * delta_p[0]\n                A[0, 1] += delta_p[0] * delta_p[1]\n                A[1, 1] += delta_p[1] * delta_p[1]\n                b[0] += delta_u * delta_p[0]\n                b[1] += delta_u * delta_p[1]\n            A[1, 0] = A[0, 1]\n\n            gradients[i] = np.linalg.solve(A, b)\n\n        # 3.2. Compute fluxes and residuals\n        R_mpfa = np.zeros(4)\n        for i in range(4):\n            cell = cells[i]\n            v_idx = cell_node_indices[i]\n            for j in range(4):\n                v1_idx, v2_idx = v_idx[j], v_idx[(j+1)%4]\n                face = face_map[tuple(sorted((v1_idx, v2_idx)))]\n                \n                v1, v2 = face['nodes']\n                edge = v2 - v1\n                normal = np.array([edge[1], -edge[0]]) / face['length']\n\n                if np.dot(normal, face['midpoint'] - cell['centroid'])  0:\n                    normal *= -1.0\n\n                is_boundary = face['cells'][1] == -1 or face['cells'][0] == face['cells'][1]\n\n                if is_boundary:\n                    g_face = gradients[i]\n                else:\n                    neighbor_cell_idx = face['cells'][0] if face['cells'][0] != i else face['cells'][1]\n                    g_face = (gradients[i] + gradients[neighbor_cell_idx]) / 2.0\n                \n                flux = face['length'] * np.dot(normal, K @ g_face)\n                R_mpfa[i] += flux\n\n        R_mpfa -= f_source * np.array([c['area'] for c in cells])\n        max_R_mpfa = np.max(np.abs(R_mpfa))\n\n        results.extend([max_R_tpfa, max_R_mpfa])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3417012"}]}