{"hands_on_practices": [{"introduction": "理论知识转化为实践能力的第一步是从基本原理出发，亲手构建数值格式。本练习将指导您为带有诺伊曼（Neumann）边界条件的热传导方程构建克兰克-尼科尔森（Crank-Nicolson）格式。通过引入“虚拟点”来处理导数边界条件，您将学习如何将一个连续的偏微分方程（PDE）系统地转化为一个封闭的线性代数方程组 $A\\mathbf{u}^{n+1}=B\\mathbf{u}^{n}$，这是计算科学中的一项基本技能。[@problem_id:3375879]", "problem": "考虑热方程，这是一个偏微分方程 (PDE)，\n$$u_{t}(x,t)=\\kappa\\,u_{xx}(x,t),\\qquad x\\in[0,1],\\ t>0,$$\n其具有齐次诺伊曼边界条件\n$$u_{x}(0,t)=0,\\qquad u_{x}(1,t)=0,$$\n以及给定的初始条件 $u(x,0)=u_{0}(x)$。设空间区间 $[0,1]$ 被均匀划分为 $M$ 个子区间，网格宽度为 $h=\\frac{1}{M}$，网格点为 $x_{j}=j\\,h$，$j=0,1,\\dots,M$。设时间被均匀离散为 $t^{n}=n\\,\\Delta t$，$n=0,1,2,\\dots$。\n\n从二阶空间导数的定义和半离散常微分方程 (ODE) 组时间积分的梯形法则出发，构建 Crank-Nicolson 有限差分格式，用于求解未知量 $u_{j}^{n}\\approx u(x_{j},t^{n})$，在空间上使用中心二阶有限差分。通过引入虚拟点来处理诺伊曼边界条件，并利用二阶中心差分来施加 $u_{x}(0,t)=0$ 和 $u_{x}(1,t)=0$ 的条件，消除虚拟点的值以获得关于 $\\{u_{j}^{n+1}\\}_{j=0}^{M}$ 的封闭线性系统。将时间层 $t^{n+1}$ 上的所得线性系统写成如下形式\n$$A\\,\\mathbf{u}^{n+1}=B\\,\\mathbf{u}^{n},$$\n其中 $\\mathbf{u}^{n}=(u_{0}^{n},u_{1}^{n},\\dots,u_{M}^{n})^{\\top}$，并明确说明与内部点相比，虚拟点条件如何修改第一个和最后一个方程。\n\n最后，从您构建的系统中，提取并报告左侧矩阵 $A$ 中第一个方程（对应于 $j=0$）里乘以 $u_{0}^{n+1}$ 的系数。将您的答案表示为关于 $\\kappa$、$\\Delta t$ 和 $h$ 的单个简化符号表达式。无需进行数值计算。", "solution": "本问题要求为具有齐次诺伊曼边界条件的一维热方程 $u_{t}=\\kappa\\,u_{xx}$ 构建 Crank-Nicolson 有限差分格式，并确定所得线性系统中的一个特定系数。\n\n推导过程包括以下几个步骤：\n1.  PDE 的空间半离散化。\n2.  应用梯形法则（Crank-Nicolson 方法）进行时间积分。\n3.  使用虚拟点实现诺伊曼边界条件。\n4.  组装最终的线性系统并提取所需系数。\n\n首先，我们在空间上进行半离散化。空间域用点 $x_{j}=j\\,h$（$j=0, 1, \\dots, M$，$h=1/M$）进行离散化。令 $u_{j}(t)$ 为 $u(x_{j},t)$ 的数值近似。我们使用二阶中心有限差分来近似内部网格点 $x_j$ 处的二阶空间导数 $u_{xx}$：\n$$ u_{xx}(x_j, t) \\approx \\frac{u(x_{j+1},t) - 2u(x_j, t) + u(x_{j-1},t)}{h^2} $$\n将此代入热方程 $u_{t}=\\kappa\\,u_{xx}$，得到关于未知函数 $u_j(t)$ 的常微分方程 (ODE) 组：\n$$ \\frac{du_{j}}{dt} = \\kappa \\frac{u_{j+1}(t) - 2u_j(t) + u_{j-1}(t)}{h^2}, \\quad \\text{for } j=1, \\dots, M-1 $$\n\n接下来，我们在时间上进行离散化。Crank-Nicolson 方法等效于对半离散系统的时间积分应用梯形法则。对于形式为 $\\frac{d\\mathbf{u}}{dt} = \\mathbf{F}(\\mathbf{u})$ 的方程，从时间 $t^n=n\\,\\Delta t$ 到 $t^{n+1}=(n+1)\\,\\Delta t$ 的梯形法则是：\n$$ \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^{n}}{\\Delta t} = \\frac{1}{2}\\left(\\mathbf{F}(\\mathbf{u}^{n+1}) + \\mathbf{F}(\\mathbf{u}^{n})\\right) $$\n其中 $u_j^n \\approx u_j(t^n)$。将此应用于我们半离散系统的第 $j$ 个分量，得到：\n$$ \\frac{u_{j}^{n+1} - u_{j}^{n}}{\\Delta t} = \\frac{\\kappa}{2} \\left[ \\left( \\frac{u_{j+1}^{n+1} - 2u_{j}^{n+1} + u_{j-1}^{n+1}}{h^2} \\right) + \\left( \\frac{u_{j+1}^{n} - 2u_{j}^{n} + u_{j-1}^{n}}{h^2} \\right) \\right] $$\n我们定义扩散数 $r = \\frac{\\kappa\\,\\Delta t}{h^2}$。方程两边乘以 $\\Delta t$ 并重新整理，将时间层 $n+1$ 的项（左侧）和时间层 $n$ 的项（右侧）分开：\n$$ u_{j}^{n+1} - \\frac{r}{2} \\left( u_{j+1}^{n+1} - 2u_{j}^{n+1} + u_{j-1}^{n+1} \\right) = u_{j}^{n} + \\frac{r}{2} \\left( u_{j+1}^{n} - 2u_{j}^{n} + u_{j-1}^{n} \\right) $$\n对于内部点 $j \\in \\{1, \\dots, M-1\\}$，这简化为以下差分格式：\n$$ -\\frac{r}{2} u_{j-1}^{n+1} + (1+r) u_{j}^{n+1} - \\frac{r}{2} u_{j+1}^{n+1} = \\frac{r}{2} u_{j-1}^{n} + (1-r) u_{j}^{n} + \\frac{r}{2} u_{j+1}^{n} $$\n\n现在，我们必须引入齐次诺伊曼边界条件，$u_x(0,t)=0$ 和 $u_x(1,t)=0$。我们使用二阶中心差分和虚拟点。\n在左边界 $x_0=0$ 处，我们在 $x_{-1}=-h$ 引入一个虚拟点。导数的中心差分近似为：\n$$ u_x(x_0, t) \\approx \\frac{u(x_1, t) - u(x_{-1}, t)}{2h} = 0 $$\n这意味着 $u(x_{-1}, t) = u(x_1, t)$。在任意时间层 $n$，这给出了条件 $u_{-1}^n = u_1^n$。这个关系对所有时间层都成立，因此 $u_{-1}^{n+1} = u_1^{n+1}$。\n\n在右边界 $x_M=1$ 处，我们在 $x_{M+1}=1+h$ 引入一个虚拟点。中心差分为：\n$$ u_x(x_M, t) \\approx \\frac{u(x_{M+1}, t) - u(x_{M-1}, t)}{2h} = 0 $$\n这意味着 $u(x_{M+1}, t) = u(x_{M-1}, t)$，从而对所有 $n$ 都有 $u_{M+1}^n = u_{M-1}^n$ 和 $u_{M+1}^{n+1} = u_{M-1}^{n+1}$。\n\n我们现在构建边界点 $j=0$ 和 $j=M$ 处的方程。\n对于 $j=0$ 处的方程，我们使用通用的内部点差分格式，并代入虚拟点条件 $u_{-1}^{n+1} = u_1^{n+1}$ 和 $u_{-1}^n = u_1^n$：\n$$ -\\frac{r}{2} u_{-1}^{n+1} + (1+r) u_0^{n+1} - \\frac{r}{2} u_1^{n+1} = \\frac{r}{2} u_{-1}^{n} + (1-r) u_0^{n} + \\frac{r}{2} u_1^{n} $$\n在左侧代入 $u_{-1}^{n+1} = u_1^{n+1}$：\n$$ -\\frac{r}{2} u_{1}^{n+1} + (1+r) u_0^{n+1} - \\frac{r}{2} u_1^{n+1} = (1+r) u_0^{n+1} - r u_1^{n+1} $$\n在右侧代入 $u_{-1}^{n} = u_1^{n}$：\n$$ \\frac{r}{2} u_{1}^{n} + (1-r) u_0^{n} + \\frac{r}{2} u_1^{n} = (1-r) u_0^{n} + r u_1^{n} $$\n因此，$j=0$ 的完整方程是：\n$$ (1+r) u_0^{n+1} - r u_1^{n+1} = (1-r) u_0^{n} + r u_1^{n} $$\n这是线性系统 $A\\mathbf{u}^{n+1}=B\\mathbf{u}^{n}$ 的第一行。虚拟点条件通过合并相邻项来修改标准的内部方程：$u_1^{n+1}$ 的系数变为 $-r$，而不是 $-\\frac{r}{2}$。\n\n为了完整起见，对于 $j=M$ 处的方程，我们将 $u_{M+1}^{n+1} = u_{M-1}^{n+1}$ 和 $u_{M+1}^n = u_{M-1}^n$ 代入通用差分格式：\n$$ -r u_{M-1}^{n+1} + (1+r) u_M^{n+1} = r u_{M-1}^{n} + (1-r) u_M^{n} $$\n这是线性系统的最后一行。\n\n问题要求的是系统 $A\\mathbf{u}^{n+1}=B\\mathbf{u}^{n}$ 中第一个方程里乘以 $u_0^{n+1}$ 的系数。这对应于 $j=0$ 的方程。从我们推导出的 $j=0$ 的方程：\n$$ (1+r) u_0^{n+1} - r u_1^{n+1} = \\dots $$\n$u_0^{n+1}$ 的系数是 $(1+r)$。代入 $r=\\frac{\\kappa\\,\\Delta t}{h^2}$ 的定义：\n$$ \\text{系数} = 1 + \\frac{\\kappa\\,\\Delta t}{h^2} $$\n这就是所求的符号表达式。", "answer": "$$\\boxed{1 + \\frac{\\kappa\\,\\Delta t}{h^2}}$$", "id": "3375879"}, {"introduction": "克兰克-尼科尔森方法最显著的优点是其时间上的二阶精度。本练习旨在通过一个精心设计的数值实验来验证这一关键特性。您将使用傅里叶谱方法来精确处理空间导数，从而消除空间离散误差的干扰，使得我们可以专注于量化时间积分的误差。通过执行时间步长加密研究并计算收敛阶，您将获得关于“二阶精度”含义的直观理解，并掌握验证数值方法精度的标准流程。[@problem_id:3220441]", "problem": "要求您通过计算来验证 Crank-Nicolson 方法（Crank-Nicolson (CN) 方法在时间上等效于梯形法则）对于线性常系数偏微分方程 (PDE) 的时间二阶精度，同时确保空间离散误差可以忽略不计。请在一维周期性域 $[0,2\\pi]$ 上进行，并对空间算子使用傅里叶谱表示，这样每个傅里叶模态都能独立演化，并且对于所选的初始数据，空间微分是精确的。\n\n起点和基本依据：在周期性域上，一个足够光滑的函数可以展开为傅里叶级数，并且常系数空间微分算子在傅里叶基下是对角的。对于任何线性时不变系统 $u_t = \\mathcal{L} u$（其中 $\\mathcal{L}$ 是一个具有常系数的线性空间算子），每个傅里叶模态的振幅 $a_k(t)$ 都满足常微分方程 (ODE) $a_k'(t) = \\lambda_k a_k(t)$，其中 $\\lambda_k$ 是算子 $\\mathcal{L}$ 对应于波数 $k$ 的特征值。单个模态的精确解为 $a_k(t) = e^{\\lambda_k t} a_k(0)$。对于右端项连续可微的 ODE，Crank-Nicolson 时间离散的局部截断误差为 $\\mathcal{O}(\\Delta t^3)$ 阶，在标准的平滑性假设下，这导致时间上的全局误差为 $\\mathcal{O}(\\Delta t^2)$ 阶。\n\n您的任务：\n\n1) 空间模型与对角化。考虑在 $[0,2\\pi]$ 上的以下三个 PDE，它们具有周期性边界条件和初始条件 $u(x,0) = e^{\\mathrm{i} k x}$，其中 $k$ 为指定的整数模态：\n   - 扩散方程：$u_t = \\nu u_{xx}$，扩散系数 $\\nu > 0$。\n   - 自由薛定谔方程：$\\mathrm{i} \\psi_t = -\\alpha \\psi_{xx}$，色散系数 $\\alpha > 0$。\n   - 对流扩散方程：$u_t + c u_x = \\nu u_{xx}$，对流速度 $c \\in \\mathbb{R}$ 且扩散系数 $\\nu > 0$。\n\n   在 $[0,2\\pi]$ 上使用傅里叶级数，为每个 PDE 中傅里叶模态 $e^{\\mathrm{i} k x}$ 的振幅 $a_k(t)$ 推导其相关的模态 ODE，并确定 $a_k'(t) = \\lambda_k a_k(t)$ 中的模态增长/衰减率 $\\lambda_k$。\n\n2) 时间离散化。对模态 ODE $a_k'(t) = \\lambda_k a_k(t)$ 应用 Crank-Nicolson 时间离散化。用前一步的 $a_k^n$ 和时间步长 $\\Delta t$ 来表示单步更新，并获得以 $\\lambda_k$ 和 $\\Delta t$ 表示的单步放大因子的封闭形式公式。使用此公式推进 $M$ 步，以在时间 $T$ 处近似 $a_k(T)$。\n\n3) 误差测量与观测阶数。对于每个 PDE，使用时间步长 $\\Delta t = T/M$ 进行时间加密研究，其中加密级别为 $M \\in \\{10,20,40,80,160\\}$。对于每个 $\\Delta t$，计算在时间 $T$ 处的数值振幅，并将其与精确振幅 $e^{\\lambda_k T}$ 进行比较，测量绝对误差 $E(\\Delta t) = \\lvert a_k^{\\text{num}}(T) - e^{\\lambda_k T} \\rvert$。通过对 $(\\log(\\Delta t), \\log(E(\\Delta t)))$ 进行最小二乘法拟合一条直线来估计观测阶数 $p$，并取其斜率。如果该方法是时间二阶的，斜率应接近于 $2$。由于初始条件是网格上精确表示的单个傅里叶模态，并且空间算子在傅里叶空间中是对角的，因此该测试的空间离散误差可以忽略不计。\n\n测试套件规范：\n\n- 域：$[0,2\\pi]$，具有周期性边界条件。\n- 所有情况的初始条件：$u(x,0) = e^{\\mathrm{i} k x}$，其中 $k$ 为下面指定的整数。\n- 加密级别：$M \\in \\{10,20,40,80,160\\}$，因此 $\\Delta t = T/M$。\n- 测试用例：\n  1) 扩散：$\\nu = 0.5$, $k = 3$, $T = 1.0$。\n  2) 自由薛定谔：$\\alpha = 0.7$, $k = 4$, $T = 2.0$。\n  3) 对流扩散：$c = 2.0$, $\\nu = 0.1$, $k = 5$, $T = 1.5$。\n\n答案规范和输出格式：\n\n- 对于每个用例，返回观测阶数 $p$，它是一个浮点数，通过对 $\\log(E(\\Delta t))$ 与 $\\log(\\Delta t)$ 进行最小二乘拟合得到的斜率计算得出。\n- 您的程序应生成一行输出，其中包含按上述顺序列出的三个观测阶数，四舍五入到三位小数，格式为逗号分隔的 Python 风格列表，例如：“[2.000,2.001,1.999]”。\n- 此任务不涉及物理单位。由于域选择为 $[0,2\\pi]$，角度（如果存在）按构造以弧度为单位。\n\n您最终交付的必须是一个完整的、可运行的程序，该程序能够精确地对上述测试套件执行这些计算，并以所需的单行格式打印结果。不允许用户输入或外部文件。仅使用指定的库。", "solution": "这个问题的核心是通过计算验证 Crank-Nicolson 方法对于几种线性偏微分方程 (PDE) 的时间二阶精度。该问题的结构设计旨在消除空间离散误差，从而可以纯粹地评估时间误差。这是通过使用一个单一傅里叶模态作为初始条件来实现的，该模态是所涉及的常系数线性空间算子的特征函数。\n\n**1. 模态分析与特征值推导**\n\n我们考虑在周期性域 $[0, 2\\pi]$ 上，对于一个整数波数 $k$，形式为 $u(x,t) = a_k(t) e^{\\mathrm{i} k x}$ 的解。初始条件 $u(x,0) = e^{\\mathrm{i} k x}$ 意味着第 $k$ 个模态的初始振幅为 $a_k(0) = 1$，所有其他模态的振幅为零。由于控制 PDE 是线性的，各模态独立演化。我们可以通过将解的形式代入每个 PDE 来分析单个非零模态 $a_k(t)$ 的演化。\n\n空间导数为：\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( a_k(t) e^{\\mathrm{i} k x} \\right) = \\mathrm{i} k a_k(t) e^{\\mathrm{i} k x}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial^2}{\\partial x^2} \\left( a_k(t) e^{\\mathrm{i} k x} \\right) = (\\mathrm{i} k)^2 a_k(t) e^{\\mathrm{i} k x} = -k^2 a_k(t) e^{\\mathrm{i} k x}\n$$\n时间导数为 $\\frac{\\partial u}{\\partial t} = a_k'(t) e^{\\mathrm{i} k x}$。\n\n对于每个形式为 $u_t = \\mathcal{L}u$ 的 PDE，代入模态形式得到 $a_k'(t) e^{\\mathrm{i} k x} = \\mathcal{L}(a_k(t) e^{\\mathrm{i} k x}) = a_k(t) \\mathcal{L}(e^{\\mathrm{i} k x})$。由于 $e^{\\mathrm{i} k x}$ 是空间算子 $\\mathcal{L}$ 的特征函数，我们有 $\\mathcal{L}(e^{\\mathrm{i} k x}) = \\lambda_k e^{\\mathrm{i} k x}$，其中 $\\lambda_k$ 是特征值。这将 PDE 简化为关于振幅 $a_k(t)$ 的线性常微分方程 (ODE)：\n$$\na_k'(t) = \\lambda_k a_k(t)\n$$\n该 ODE 在初始条件 $a_k(0)=1$ 下的精确解为 $a_k(t) = e^{\\lambda_k t}$。\n\n我们现在为每个指定的 PDE 确定 $\\lambda_k$。\n\n- **扩散方程**：$u_t = \\nu u_{xx}$\n  $a_k'(t) e^{\\mathrm{i} k x} = \\nu (-k^2 a_k(t) e^{\\mathrm{i} k x})$。两边除以 $e^{\\mathrm{i} k x}$ 得到 $a_k'(t) = (-\\nu k^2) a_k(t)$。\n  因此，特征值为 $\\lambda_k = -\\nu k^2$。\n\n- **自由薛定谔方程**：$\\mathrm{i} \\psi_t = -\\alpha \\psi_{xx}$。设解为 $\\psi(x,t) = a_k(t) e^{\\mathrm{i} k x}$。\n  该方程等价于 $\\psi_t = \\frac{-\\alpha}{\\mathrm{i}} \\psi_{xx} = \\mathrm{i} \\alpha \\psi_{xx}$。\n  $a_k'(t) e^{\\mathrm{i} k x} = \\mathrm{i} \\alpha (-k^2 a_k(t) e^{\\mathrm{i} k x})$。这得到 $a_k'(t) = (-\\mathrm{i} \\alpha k^2) a_k(t)$。\n  因此，特征值为 $\\lambda_k = -\\mathrm{i} \\alpha k^2$。\n  （注意：问题陈述为 $\\mathrm{i} \\psi_t = -\\alpha \\psi_{xx}$。代入得到 $\\mathrm{i} a_k' = -\\alpha (-k^2) a_k = \\alpha k^2 a_k$，所以 $a_k' = \\frac{\\alpha k^2}{\\mathrm{i}} a_k = -\\mathrm{i} \\alpha k^2 a_k$。结果相同）。\n\n- **对流扩散方程**：$u_t + c u_x = \\nu u_{xx}$，或 $u_t = -c u_x + \\nu u_{xx}$。\n  $a_k'(t) e^{\\mathrm{i} k x} = -c (\\mathrm{i} k a_k(t) e^{\\mathrm{i} k x}) + \\nu (-k^2 a_k(t) e^{\\mathrm{i} k x})$。\n  这得到 $a_k'(t) = (-\\mathrm{i} c k - \\nu k^2) a_k(t)$。\n  因此，特征值为 $\\lambda_k = -\\nu k^2 - \\mathrm{i} c k$。\n\n**2. Crank-Nicolson 时间离散化**\n\nCrank-Nicolson 方法是一种用于积分 ODE 的隐式方法，等同于梯形法则。对于 ODE $a' = \\lambda a$，在从 $t_n$ 到 $t_{n+1}$ 的时间步长 $\\Delta t$ 上的离散化为：\n$$\n\\frac{a^{n+1} - a^n}{\\Delta t} = \\frac{1}{2} \\left( \\lambda a^{n+1} + \\lambda a^n \\right)\n$$\n其中 $a^n \\approx a(t_n)$。我们求解 $a^{n+1}$：\n$$\na^{n+1} \\left( 1 - \\frac{\\lambda \\Delta t}{2} \\right) = a^n \\left( 1 + \\frac{\\lambda \\Delta t}{2} \\right)\n$$\n这给出了单步的显式更新公式：\n$$\na^{n+1} = \\left( \\frac{1 + \\lambda \\Delta t / 2}{1 - \\lambda \\Delta t / 2} \\right) a^n\n$$\n项 $G(\\lambda, \\Delta t) = \\frac{1 + \\lambda \\Delta t / 2}{1 - \\lambda \\Delta t / 2}$ 是单步放大因子。要从时间 $t=0$ 到 $T = M \\Delta t$ 推进 $M$ 步，我们将这个因子应用 $M$ 次。在 $a^0 = a_k(0) = 1$ 的情况下，时间 $T$ 处的数值解为：\n$$\na_k^{\\text{num}}(T) = a^M = (G(\\lambda_k, \\Delta t))^M a^0 = \\left( \\frac{1 + \\lambda_k \\Delta t / 2}{1 - \\lambda_k \\Delta t / 2} \\right)^M\n$$\n\n**3. 误差分析与观测精度阶数**\n\n该方法的全局误差预计为时间上的二阶，意味着在固定时间 $T$ 的误差 $E(\\Delta t)$ 的行为类似于 $E(\\Delta t) \\approx C (\\Delta t)^p$，其中 $C$ 是某个常数，阶数 $p \\approx 2$。绝对误差定义为：\n$$\nE(\\Delta t) = \\lvert a_k^{\\text{num}}(T) - a_k(T) \\rvert = \\left| \\left( \\frac{1 + \\lambda_k \\Delta t / 2}{1 - \\lambda_k \\Delta t / 2} \\right)^M - e^{\\lambda_k T} \\right|\n$$\n为了确定观测阶数 $p$，我们对误差关系取对数：\n$$\n\\log(E(\\Delta t)) \\approx \\log(C) + p \\log(\\Delta t)\n$$\n这表明 $\\log(E)$ 和 $\\log(\\Delta t)$ 之间存在线性关系，其斜率即为精度阶数 $p$。我们将为一系列时间步长 $\\Delta t_i = T/M_i$（其中 $M_i \\in \\{10, 20, 40, 80, 160\\}$）计算误差。然后，我们对数据点 $(\\log(\\Delta t_i), \\log(E_i))$ 进行线性最小二乘拟合以求得斜率 $p$。\n\n每个测试用例的计算过程如下：\n1.  使用给定的参数计算特征值 $\\lambda_k$。\n2.  定义加密级别集合 $M_i$。\n3.  对于每个 $M_i$，计算时间步长 $\\Delta t_i = T/M_i$。\n4.  计算数值解 $a_k^{\\text{num}}(T) = \\left( \\frac{1 + \\lambda_k \\Delta t_i / 2}{1 - \\lambda_k \\Delta t_i / 2} \\right)^{M_i}$。\n5.  计算精确解 $a_k(T) = e^{\\lambda_k T}$。\n6.  计算绝对误差 $E_i = |a_k^{\\text{num}}(T) - a_k(T)|$。\n7.  构建两个向量：$x = [\\log(\\Delta t_i)]$ 和 $y = [\\log(E_i)]$。\n8.  计算 $(x, y)$ 的最佳拟合线的斜率 $p$，即为观测阶数。这将使用 `numpy.polyfit` 来完成。\n将对三个指定的用例进行计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_observed_order(lambda_k, T, M_levels):\n    \"\"\"\n    Computes the observed order of accuracy for the Crank-Nicolson method.\n\n    Args:\n        lambda_k (complex): The eigenvalue of the spatial operator for mode k.\n        T (float): The final time for the simulation.\n        M_levels (np.ndarray): An array of integers representing the number of time steps.\n\n    Returns:\n        float: The observed order of accuracy, p.\n    \"\"\"\n    delta_ts = T / M_levels\n    errors = np.zeros_like(delta_ts, dtype=float)\n\n    # Calculate the exact solution at time T\n    exact_solution = np.exp(lambda_k * T)\n\n    for i, M in enumerate(M_levels):\n        dt = delta_ts[i]\n        \n        # Calculate the one-step amplification factor\n        z = lambda_k * dt / 2.0\n        amplification_factor = (1.0 + z) / (1.0 - z)\n        \n        # Compute the numerical solution at time T\n        # Initial condition a_k(0) = 1 is implicit\n        numerical_solution = amplification_factor**M\n        \n        # Compute the absolute error\n        errors[i] = np.abs(numerical_solution - exact_solution)\n\n    # Perform a least-squares fit on the log-log data to find the slope\n    log_delta_ts = np.log(delta_ts)\n    log_errors = np.log(errors)\n    \n    # np.polyfit returns [slope, intercept] for degree 1\n    p, _ = np.polyfit(log_delta_ts, log_errors, 1)\n    \n    return p\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Refinement levels for the temporal grid\n    M_levels = np.array([10, 20, 40, 80, 160])\n    \n    # --- Test Case 1: Diffusion Equation ---\n    # u_t = nu * u_xx\n    # Parameters: nu = 0.5, k = 3, T = 1.0\n    nu1 = 0.5\n    k1 = 3\n    T1 = 1.0\n    # Eigenvalue: lambda_k = -nu * k^2\n    lambda_k1 = -nu1 * k1**2\n    p1 = calculate_observed_order(lambda_k1, T1, M_levels)\n\n    # --- Test Case 2: Free Schrödinger Equation ---\n    # i * psi_t = -alpha * psi_xx  =>  psi_t = -i * alpha * psi_xx\n    # Parameters: alpha = 0.7, k = 4, T = 2.0\n    alpha2 = 0.7\n    k2 = 4\n    T2 = 2.0\n    # Eigenvalue: lambda_k = -i * alpha * k^2\n    lambda_k2 = -1j * alpha2 * k2**2\n    p2 = calculate_observed_order(lambda_k2, T2, M_levels)\n\n    # --- Test Case 3: Advection-Diffusion Equation ---\n    # u_t + c * u_x = nu * u_xx  => u_t = -c * u_x + nu * u_xx\n    # Parameters: c = 2.0, nu = 0.1, k = 5, T = 1.5\n    c3 = 2.0\n    nu3 = 0.1\n    k3 = 5\n    T3 = 1.5\n    # Eigenvalue: lambda_k = -nu * k^2 - i * c * k\n    lambda_k3 = -nu3 * k3**2 - 1j * c3 * k3\n    p3 = calculate_observed_order(lambda_k3, T3, M_levels)\n\n    results = [p1, p2, p3]\n\n    # Format the output as a list of strings with 3 decimal places\n    formatted_results = [f'{p:.3f}' for p in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3220441"}, {"introduction": "尽管克兰克-尼科尔森方法具有二阶精度和无条件稳定的优点（A-稳定性），但在某些情况下它并非最佳选择。本练习将揭示该方法的一个重要局限性：在求解包含快速反应项的“刚性”问题时，它可能会产生非物理的数值振荡。通过将克兰克-尼科尔森方法的表现与更具耗散性的一阶向后欧拉法进行对比，您将深入理解L-稳定性的概念，并学会根据问题的物理特性审慎选择时间积分格式。[@problem_id:3375886]", "problem": "考虑周期域 $[0,1]$ 上的一维线性反应扩散偏微分方程，\n$$\nu_t(x,t) = u_{xx}(x,t) - \\lambda\\,u(x,t),\n$$\n其中空间变量为 $x\\in[0,1]$，时间为 $t\\ge 0$，反应系数为 $\\lambda \\ge 0$。在包含 $N$ 个点的均匀周期网格上，使用二阶中心有限差分对空间进行离散，以获得一个关于时间的常微分方程组（即线方法系统）。从线性常微分方程组的 Crank-Nicolson 方法和后向欧拉法的基本定义出发，设计一个数值实验，以揭示和量化当反应为刚性时，Crank-Nicolson 时间离散化产生的非物理时间振荡。\n\n您的任务是完成以下所有内容：\n\n1) 空间半离散化。在具有 $N$ 个点和周期性边界条件的均匀网格上，使用标准的二阶中心差分算子来近似拉普拉斯算子 $u_{xx}$。将得到的离散拉普拉斯矩阵表示为 $L\\in\\mathbb{R}^{N\\times N}$，将时间层 $n$ 的离散状态向量表示为 $u^n\\in\\mathbb{R}^N$。该半离散系统具有以下形式\n$$\n\\frac{d}{dt} u(t) = A\\,u(t), \\quad \\text{with } A := L - \\lambda I,\n$$\n其中 $I$ 是单位矩阵。\n\n2) 基于第一原理的时间离散化。从线性系统 $y'(t)=A\\,y(t)$ 的 Crank-Nicolson 方法和后向欧拉法的定义出发，写出将 $u^n$ 映射到 $u^{n+1}$ 的全离散单步更新公式：\n- Crank–Nicolson：推导 $u^{n+1}$ 必须满足的隐式线性系统，该系统用 $u^n$、时间步长 $\\Delta t$ 和矩阵 $A$ 表示。\n- 后向欧拉：推导 $u^{n+1}$ 必须满足的隐式线性系统，该系统用 $u^n$、时间步长 $\\Delta t$ 和矩阵 $A$ 表示。\n\n除了上述定义之外，不要假设 $A$ 具有任何特殊性质，也不要使用预先推导的放大因子公式；从每种方法的定义开始。\n\n3) 初始条件和过冲度量。使用空间上恒定的初始条件\n$$\nu(x,0) \\equiv 1,\n$$\n该条件在周期性边界条件下是可接受的，并且处处非负。使用每种方法演化一个时间步长至 $t=\\Delta t$。将一个时间步长后的非物理过冲振幅定义为\n$$\n\\mathcal{O}(u^1) := \\frac{\\max\\{0,\\,-\\min_i u^1_i\\}}{\\max_i u^0_i},\n$$\n即，所产生的最大负值的量级，并按初始最大值进行归一化；这是一个无量纲的量。对于此初始条件下的物理一致衰减，精确解在所有 $t\\ge 0$ 时都是非负的，因此 $u^1$ 中的任何负值都是非物理的。量化此过冲振幅如何依赖于无量纲刚性参数\n$$\nz := \\lambda\\,\\Delta t.\n$$\n\n4) 测试套件和要求的输出。固定 $N=64$ 个网格点，以及在 $[0,1]$ 上带有周期性边界条件的均匀网格。使用大小为 $\\Delta t=0.1$ 的单个时间步长。构建以下四个测试用例，每个用例由目标值 $z=\\lambda\\,\\Delta t$ 指定：\n- 用例 A (非刚性): $z=0.5$。\n- 用例 B (阈值): $z=2.0$。\n- 用例 C (刚性): $z=6.0$。\n- 用例 D (非常刚性): $z=100.0$。\n对于每个用例，选择 $\\lambda = z/\\Delta t$ 以实现指定的 $z$。对于每个用例，计算：\n- 一个时间步长后的 Crank–Nicolson 过冲振幅 $\\mathcal{O}_{\\mathrm{CN}}$。\n- 一个时间步长后的后向欧拉过冲振幅 $\\mathcal{O}_{\\mathrm{BE}}$。\n\n5) 最终输出格式。您的程序应生成单行输出，其中包含按 A, B, C, D 顺序汇总的四个用例的结果，每个用例贡献一对值 $(\\mathcal{O}_{\\mathrm{CN}},\\mathcal{O}_{\\mathrm{BE}})$。该行必须是一个用方括号括起来的、由八个浮点数组成的逗号分隔列表，顺序完全如下：\n$$\n[\\mathcal{O}_{\\mathrm{CN}}(0.5),\\ \\mathcal{O}_{\\mathrm{BE}}(0.5),\\ \\mathcal{O}_{\\mathrm{CN}}(2.0),\\ \\mathcal{O}_{\\mathrm{BE}}(2.0),\\ \\mathcal{O}_{\\mathrm{CN}}(6.0),\\ \\mathcal{O}_{\\mathrm{BE}}(6.0),\\ \\mathcal{O}_{\\mathrm{CN}}(100.0),\\ \\mathcal{O}_{\\mathrm{BE}}(100.0)].\n$$\n\n所有数值都是无量纲的，因此不需要指定物理单位。您的实现必须是通用的，能够为给定矩阵求解每种方法产生的隐式线性系统，并且不得依赖代码中的任何闭式解或模态解耦快捷方式。代码应在没有任何用户输入的情况下运行，并且必须遵守上面指定的最终输出格式。", "solution": "问题的核心是研究将 Crank-Nicolson (CN) 方法应用于刚性反应扩散问题时产生的非物理振荡，并将其行为与后向欧拉 (BE) 方法进行对比。当反应系数 $\\lambda$ 很大时，反应项 $-\\lambda u(x,t)$ 会产生刚性。\n\n**1. 空间半离散化**\n\n我们首先使用一个包含 $N$ 个点的均匀网格来离散化空间域 $x \\in [0,1]$，其中 $x_i = i h$，$i = 0, 1, \\dots, N-1$，网格间距为 $h = 1/N$。在网格点 $x_i$ 和时间 $t$ 处的解的值表示为 $u_i(t) \\approx u(x_i, t)$。周期性边界条件意味着索引是对 $N$ 取模的，即 $u_{i+N}(t) = u_i(t)$。\n\n点 $x_i$ 处的二阶空间导数 $u_{xx}$ 使用二阶中心有限差分公式进行近似：\n$$\nu_{xx}(x_i, t) \\approx \\frac{u(x_{i+1}, t) - 2u(x_i, t) + u(x_{i-1}, t)}{h^2}\n$$\n将此应用于我们的离散解值 $u_i(t)$，我们得到：\n$$\n(L u(t))_i = \\frac{1}{h^2} (u_{i+1}(t) - 2u_i(t) + u_{i-1}(t))\n$$\n其中 $u(t) = [u_0(t), u_1(t), \\dots, u_{N-1}(t)]^T$ 是时间 $t$ 处的解值向量。矩阵 $L \\in \\mathbb{R}^{N\\times N}$ 表示离散拉普拉斯算子。由于周期性边界条件，$L$ 是一个循环矩阵。其元素由下式给出：\n$$\nL_{ij} = \\frac{1}{h^2} \\begin{cases}\n-2  \\text{if } i=j \\\\\n1  \\text{if } |i-j| = 1 \\text{ or } |i-j| = N-1 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n将此空间离散化代入原始 PDE $u_t = u_{xx} - \\lambda u$，得到一个包含 $N$ 个耦合 ODE 的系统，称为线方法系统：\n$$\n\\frac{d}{dt} u(t) = L u(t) - \\lambda I u(t) = (L - \\lambda I) u(t)\n$$\n其形式为 $\\frac{d}{dt}u(t) = A u(t)$，系统矩阵为 $A := L - \\lambda I$，其中 $I$ 是 $N \\times N$ 单位矩阵。\n\n**2. 基于第一原理的时间离散化**\n\n现在我们对时间进行离散化。令 $t_n = n \\Delta t$ 为第 $n$ 步的时间，令 $u^n \\approx u(t_n)$ 为数值解向量。我们应用两种不同的单步方法将解从 $t_n$推进到 $t_{n+1}$。\n\n**后向欧拉 (BE) 方法**：这是一种一阶隐式方法。在 $t_{n+1}$ 处的时间导数由后向差分近似，右侧则在新的时间层 $t_{n+1}$ 进行计算：\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} = A u^{n+1}\n$$\n为了求解 $u^{n+1}$，我们重新整理各项，得到一个线性方程组：\n$$\nu^{n+1} - \\Delta t A u^{n+1} = u^n \\implies (I - \\Delta t A) u^{n+1} = u^n\n$$\n在每个时间步都必须求解这个关于 $u^{n+1}$ 的隐式方程。\n\n**Crank-Nicolson (CN) 方法**：这是一种二阶隐式方法，是前向欧拉和后向欧拉方法的平均。它等效于对 ODE 系统应用梯形法则。时间导数在时间中点 $t_{n+1/2}$ 进行近似，右侧是在 $t_n$ 和 $t_{n+1}$ 处计算值的平均值：\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} = \\frac{1}{2} \\left( A u^n + A u^{n+1} \\right)\n$$\n为了求解 $u^{n+1}$，我们将包含 $u^{n+1}$ 的项归到左侧，将包含 $u^n$ 的项归到右侧：\n$$\nu^{n+1} - \\frac{\\Delta t}{2} A u^{n+1} = u^n + \\frac{\\Delta t}{2} A u^n \\implies \\left(I - \\frac{\\Delta t}{2} A\\right) u^{n+1} = \\left(I + \\frac{\\Delta t}{2} A\\right) u^n\n$$\n这也是一个隐式方程，需要在每个时间步求解一个关于 $u^{n+1}$ 的线性系统。\n\n**3. 初始条件和过冲度量**\n\n初始条件为 $u(x,0) = 1$。在我们的离散设置中，这转化为初始向量 $u^0$ 的所有分量都等于 $1$，即 $u^0 = \\mathbf{1}$。值得注意的是，这个常数向量 $\\mathbf{1}$ 是离散拉普拉斯算子 $L$ 的一个特征向量，其特征值为 $0$，因为对于任意行 $i$，都有 $(L \\mathbf{1})_i = \\frac{1}{h^2}(1 - 2(1) + 1) = 0$。因此，$u^0$ 是 $A=L-\\lambda I$ 的一个特征向量，其特征值为 $-\\lambda$，因为 $A u^0 = L u^0 - \\lambda I u^0 = \\mathbf{0} - \\lambda u^0 = -\\lambda u^0$。\n\n具有此初始条件的 PDE 的精确解是 $u(x,t) = e^{-\\lambda t}$，该解在空间上是均匀的，并单调递减至零，永远不会变为负值。因此，数值解 $u^1$ 中的任何负值都是离散化方法产生的非物理伪影。\n\n过冲振幅度量定义为：\n$$\n\\mathcal{O}(u^1) := \\frac{\\max\\{0,\\,-\\min_i u^1_i\\}}{\\max_i u^0_i}\n$$\n给定 $u^0=\\mathbf{1}$，分母 $\\max_i u^0_i = 1$。该度量简化为 $\\mathcal{O}(u^1) = \\max\\{0, -\\min_i u^1_i\\}$，它就是解向量 $u^1$ 中最大负分量的量级，如果解保持非负，则为零。该度量用于量化作为无量纲刚性参数 $z = \\lambda \\Delta t$ 的函数的非物理振荡。\n\n**4. 数值实验设计**\n\n通过为指定的参数和测试用例实现上述设置来进行实验。每个以 $z$ 值为特征的测试用例的算法如下：\n\n1.  设置固定参数：$N=64$ 和 $\\Delta t = 0.1$。计算网格间距 $h=1/N$。\n2.  对于给定的 $z \\in \\{0.5, 2.0, 6.0, 100.0\\}$，计算反应系数 $\\lambda = z / \\Delta t$。\n3.  为周期域构建 $N \\times N$ 离散拉普拉斯矩阵 $L$。\n4.  构建系统矩阵 $A = L - \\lambda I$。\n5.  初始化解向量 $u^0 = \\mathbf{1} \\in \\mathbb{R}^N$。\n6.  对于 Crank-Nicolson 方法：\n    a.  构建系统矩阵 $M_{CN} = I - \\frac{\\Delta t}{2} A$。\n    b.  构建右侧向量 $b_{CN} = \\left(I + \\frac{\\Delta t}{2} A\\right) u^0$。\n    c.  求解线性系统 $M_{CN} u^1_{CN} = b_{CN}$ 以得到 $u^1_{CN}$。\n    d.  计算过冲 $\\mathcal{O}_{\\mathrm{CN}} = \\max\\{0, -\\min_i (u^1_{CN})_i\\}$。\n7.  对于后向欧拉方法：\n    a.  构建系统矩阵 $M_{BE} = I - \\Delta t A$。\n    b.  右侧向量就是 $b_{BE} = u^0$。\n    c.  求解线性系统 $M_{BE} u^1_{BE} = b_{BE}$ 以得到 $u^1_{BE}$。\n    d.  计算过冲 $\\mathcal{O}_{\\mathrm{BE}} = \\max\\{0, -\\min_i (u^1_{BE})_i\\}$。\n8.  收集并报告数值对 $(\\mathcal{O}_{\\mathrm{CN}}, \\mathcal{O}_{\\mathrm{BE}})$。\n\n对所有四个指定的 $z$ 值重复此过程。根据问题的约束，该实现将使用通用线性求解器，并且不会利用初始条件的特征向量属性。该实验将证明，作为 L-稳定 的 BE 方法不产生振荡，而作为 A-稳定 但非 L-稳定 的 CN 方法，在 $z$ 很大时（即问题为刚性时）会产生显著的非物理振荡。这些振荡的阈值预计在 $z=2$ 处。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import circulant\n\ndef solve():\n    \"\"\"\n    Solves the specified reaction-diffusion problem to quantify\n    overshoot in Crank-Nicolson vs. Backward Euler methods.\n    \"\"\"\n    # Define the problem parameters and test cases from the statement.\n    N = 64\n    dt = 0.1\n    # Test cases are specified by the dimensionless stiffness parameter z.\n    test_cases_z = [0.5, 2.0, 6.0, 100.0]\n\n    results = []\n\n    # Grid spacing for a periodic domain [0,1]\n    h = 1.0 / N\n\n    # Construct the discrete Laplacian matrix L for periodic boundary conditions.\n    # The matrix is circulant. Its first column fully defines it.\n    L_first_col = np.zeros(N)\n    factor = 1.0 / h**2\n    L_first_col[0] = -2.0 * factor\n    L_first_col[1] = 1.0 * factor\n    L_first_col[N - 1] = 1.0 * factor\n    L = circulant(L_first_col)\n\n    # Initial condition u(x,0) = 1\n    u0 = np.ones(N)\n\n    # Loop through each test case\n    for z in test_cases_z:\n        # Determine the reaction coefficient lambda for the target z\n        lambda_val = z / dt\n\n        # Construct the full semi-discrete system matrix A = L - lambda*I\n        I = np.identity(N)\n        A = L - lambda_val * I\n\n        # --- Crank-Nicolson Method ---\n        # The update rule is (I - dt/2 * A) * u1 = (I + dt/2 * A) * u0\n        # Form the matrix for the linear system to be solved.\n        M_cn = I - (dt / 2.0) * A\n        # Form the right-hand side vector.\n        b_cn = (I + (dt / 2.0) * A) @ u0\n        # Solve the linear system for u1.\n        u1_cn = np.linalg.solve(M_cn, b_cn)\n\n        # --- Backward Euler Method ---\n        # The update rule is (I - dt * A) * u1 = u0\n        # Form the matrix for the linear system.\n        M_be = I - dt * A\n        # The right-hand side is just u0.\n        b_be = u0\n        # Solve the linear system for u1.\n        u1_be = np.linalg.solve(M_be, b_be)\n\n        # --- Compute Overshoot Metrics ---\n        # The metric is O(u1) = max{0, -min(u1)} / max(u0).\n        # Since u0 is a vector of ones, max(u0) = 1.\n        \n        # Crank-Nicolson overshoot\n        min_u1_cn = np.min(u1_cn)\n        overshoot_cn = np.maximum(0.0, -min_u1_cn)\n        \n        # Backward Euler overshoot\n        min_u1_be = np.min(u1_be)\n        overshoot_be = np.maximum(0.0, -min_u1_be)\n        \n        # Append results for this case to the list\n        results.extend([overshoot_cn, overshoot_be])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3375886"}]}