{"hands_on_practices": [{"introduction": "理论分析是理解数值方法误差来源的基石。本练习旨在通过解析计算，揭示在有限元装配过程中对源项进行近似所引入的局部一致性误差。通过推导该误差的主导项 [@problem_id:3364904]，您将深入理解数值积分和函数近似如何直接影响最终解的精度。", "problem": "考虑来自有界区间上泊松问题 $-u''=f$ 的一维弱形式，该问题使用协调网格上的线性 Lagrange 基函数通过有限元法 (FEM) 进行离散化。设给定一个长度为 $h=x_b-x_a$ 的单个单元 $T_e=[x_a,x_b]$，并将其两个局部形函数记为 $\\phi_1$ 和 $\\phi_2$，它们分别与节点 $x_a$ 和 $x_b$ 相关联。局部载荷向量 $F_e\\in\\mathbb{R}^2$ 的分量为 $F_p=\\int_{T_e} f(x)\\,\\phi_p(x)\\,\\mathrm{d}x$，其中 $p\\in\\{1,2\\}$。定义单元中点 $x_m=(x_a+x_b)/2$ 以及从父区间 $s\\in[-1,1]$ 出发的映射 $x=x_m+\\frac{h}{2}s$。假设 $f$ 在 $T_e$ 上足够光滑，允许在 $x_m$ 周围进行泰勒展开。\n\n(a) 使用局部载荷向量的定义，在父坐标 $s\\in[-1,1]$ 下表示 $T_e$ 上的 $F_p$，其中 $\\phi_1(s)=\\frac{1-s}{2}$ 且 $\\phi_2(s)=\\frac{1+s}{2}$。\n\n(b) 考虑用源项的单元平均值 $\\bar{f}_e=\\frac{1}{h}\\int_{T_e} f(x)\\,\\mathrm{d}x$ 来近似源项，并构建近似的局部载荷分量 $\\tilde{F}_p=\\bar{f}_e\\int_{T_e}\\phi_p(x)\\,\\mathrm{d}x$。\n\n(c) 定义相容性误差向量 $\\delta F_e=F_e-\\tilde{F}_e$。将 $f(x)$ 在 $x_m$ 附近进行泰勒展开，展开到足以揭示 $\\delta F_e$ 的第一个非零贡献项所需的最低阶，推导 $\\delta F_e$ 关于 $h$ 和 $f$ 在 $x_m$ 处的导数的领头阶解析表达式。\n\n简要解释这种局部相容性误差如何影响组装后的全局载荷向量，但最终答案仅需提供 $\\delta F_e$ 关于 $h$ 和 $f$ 在 $x_m$ 处的导数的领头阶解析表达式，并以行矩阵形式表示。无需进行数值计算，也无需四舍五入。最终答案以无单位形式表示。", "solution": "该问题要求在一维有限元法 (FEM) 的背景下，针对局部载荷向量的一种特定近似，推导其领头阶相容性误差。我们将首先使用泰勒级数展开来表示精确和近似的载荷向量，然后计算它们的差值。\n\n给定的从父单元 $s \\in [-1, 1]$ 到物理单元 $T_e = [x_a, x_b]$ 的坐标映射为 $x(s) = x_m + \\frac{h}{2}s$，其中 $h=x_b-x_a$ 是单元长度，$x_m = (x_a+x_b)/2$ 是中点。微分元变换为 $\\mathrm{d}x = \\frac{h}{2}\\mathrm{d}s$。父坐标系下的线性基函数为 $\\phi_1(s) = \\frac{1-s}{2}$ 和 $\\phi_2(s) = \\frac{1+s}{2}$。\n\n(a) 精确局部载荷向量 $F_e$ 的分量为 $F_p = \\int_{T_e} f(x)\\phi_p(x)\\mathrm{d}x$。将此积分变换到父坐标系下得到：\n$$F_p = \\int_{-1}^{1} f(x(s)) \\phi_p(s) \\frac{\\mathrm{d}x}{\\mathrm{d}s} \\mathrm{d}s = \\frac{h}{2} \\int_{-1}^{1} f\\left(x_m + \\frac{h}{2}s\\right) \\phi_p(s) \\mathrm{d}s$$\n对于 $p \\in \\{1, 2\\}$。\n\n(b) 近似局部载荷向量 $\\tilde{F}_e$ 的分量为 $\\tilde{F}_p = \\bar{f}_e \\int_{T_e} \\phi_p(x)\\mathrm{d}x$，其中 $\\bar{f}_e = \\frac{1}{h}\\int_{T_e} f(x)\\mathrm{d}x$。\n首先，我们计算基函数在单元 $T_e$ 上的积分：\n$$\\int_{T_e} \\phi_1(x)\\mathrm{d}x = \\frac{h}{2}\\int_{-1}^{1} \\phi_1(s)\\mathrm{d}s = \\frac{h}{2}\\int_{-1}^{1} \\frac{1-s}{2}\\mathrm{d}s = \\frac{h}{4}\\left[s-\\frac{s^2}{2}\\right]_{-1}^{1} = \\frac{h}{4}\\left(\\left(1-\\frac{1}{2}\\right) - \\left(-1-\\frac{1}{2}\\right)\\right) = \\frac{h}{2}$$\n$$\\int_{T_e} \\phi_2(x)\\mathrm{d}x = \\frac{h}{2}\\int_{-1}^{1} \\phi_2(s)\\mathrm{d}s = \\frac{h}{2}\\int_{-1}^{1} \\frac{1+s}{2}\\mathrm{d}s = \\frac{h}{4}\\left[s+\\frac{s^2}{2}\\right]_{-1}^{1} = \\frac{h}{4}\\left(\\left(1+\\frac{1}{2}\\right) - \\left(-1+\\frac{1}{2}\\right)\\right) = \\frac{h}{2}$$\n两个积分的结果均为 $\\frac{h}{2}$。因此，近似载荷向量的分量为 $\\tilde{F}_1 = \\tilde{F}_2 = \\bar{f}_e \\frac{h}{2}$。\n\n(c) 为了求出相容性误差 $\\delta F_e = F_e - \\tilde{F}_e$，我们将源函数 $f(x)$ 在单元中点 $x_m$ 附近展开成泰勒级数。令 $x-x_m=y$。\n$$f(x) = f(x_m) + f'(x_m)(x-x_m) + \\frac{f''(x_m)}{2}(x-x_m)^2 + O((x-x_m)^3)$$\n在父坐标系下，$x-x_m = \\frac{h}{2}s$，所以展开式为：\n$$f\\left(x_m + \\frac{h}{2}s\\right) = f(x_m) + f'(x_m)\\left(\\frac{h}{2}s\\right) + \\frac{f''(x_m)}{2}\\left(\\frac{h}{2}s\\right)^2 + O(h^3)$$\n\n首先，我们求出单元平均值 $\\bar{f}_e$ 的一个更精确的表达式：\n$$\\bar{f}_e = \\frac{1}{h}\\int_{T_e} f(x)\\mathrm{d}x = \\frac{1}{h} \\frac{h}{2} \\int_{-1}^{1} f\\left(x_m + \\frac{h}{2}s\\right) \\mathrm{d}s$$\n$$\\bar{f}_e = \\frac{1}{2} \\int_{-1}^{1} \\left( f(x_m) + f'(x_m)\\frac{hs}{2} + f''(x_m)\\frac{h^2s^2}{8} + O(h^3) \\right) \\mathrm{d}s$$\n利用对于整数 $k \\ge 0$ 有 $\\int_{-1}^{1} s^{2k+1}\\mathrm{d}s=0$ 和 $\\int_{-1}^{1} s^{2k}\\mathrm{d}s=\\frac{2}{2k+1}$ 的事实：\n$$\\bar{f}_e = \\frac{1}{2} \\left( f(x_m)\\int_{-1}^{1}\\mathrm{d}s + f'(x_m)\\frac{h}{2}\\int_{-1}^{1}s\\,\\mathrm{d}s + f''(x_m)\\frac{h^2}{8}\\int_{-1}^{1}s^2\\,\\mathrm{d}s + O(h^4) \\right)$$\n$$\\bar{f}_e = \\frac{1}{2} \\left( 2f(x_m) + 0 + f''(x_m)\\frac{h^2}{8}\\frac{2}{3} + O(h^4) \\right) = f(x_m) + \\frac{h^2}{24}f''(x_m) + O(h^4)$$\n那么，近似载荷向量的分量为：\n$$\\tilde{F}_p = \\bar{f}_e \\frac{h}{2} = \\left(f(x_m) + \\frac{h^2}{24}f''(x_m) + O(h^4)\\right) \\frac{h}{2} = \\frac{h}{2}f(x_m) + \\frac{h^3}{48}f''(x_m) + O(h^5)$$\n对 $p=1$ 和 $p=2$ 均成立。\n\n接下来，我们展开精确载荷向量 $F_e$ 的分量。对于 $F_1$：\n$$F_1 = \\frac{h}{2} \\int_{-1}^{1} \\left( f(x_m) + f'(x_m)\\frac{hs}{2} + O(h^2) \\right) \\left(\\frac{1-s}{2}\\right) \\mathrm{d}s$$\n$$F_1 = \\frac{h}{4} \\int_{-1}^{1} \\left( f(x_m) (1-s) + f'(x_m)\\frac{h}{2}(s-s^2) + O(h^2) \\right) \\mathrm{d}s$$\n$$F_1 = \\frac{h}{4} \\left( f(x_m)\\int_{-1}^{1}(1-s)\\mathrm{d}s + f'(x_m)\\frac{h}{2}\\int_{-1}^{1}(s-s^2)\\mathrm{d}s + O(h^3) \\right)$$\n积分为 $\\int_{-1}^{1}(1-s)\\mathrm{d}s=2$ 和 $\\int_{-1}^{1}(s-s^2)\\mathrm{d}s = -\\frac{2}{3}$。\n$$F_1 = \\frac{h}{4} \\left( 2f(x_m) - f'(x_m)\\frac{h}{2}\\frac{2}{3} + O(h^3) \\right) = \\frac{h}{2}f(x_m) - \\frac{h^2}{12}f'(x_m) + O(h^3)$$\n对于 $F_2$，过程类似，使用 $\\phi_2(s) = \\frac{1+s}{2}$：\n$$F_2 = \\frac{h}{4} \\int_{-1}^{1} \\left( f(x_m) (1+s) + f'(x_m)\\frac{h}{2}(s+s^2) + O(h^2) \\right) \\mathrm{d}s$$\n使用 $\\int_{-1}^{1}(1+s)\\mathrm{d}s=2$ 和 $\\int_{-1}^{1}(s+s^2)\\mathrm{d}s = \\frac{2}{3}$：\n$$F_2 = \\frac{h}{4} \\left( 2f(x_m) + f'(x_m)\\frac{h}{2}\\frac{2}{3} + O(h^3) \\right) = \\frac{h}{2}f(x_m) + \\frac{h^2}{12}f'(x_m) + O(h^3)$$\n相容性误差分量 $\\delta F_{e,p} = F_p - \\tilde{F}_p$ 的领头阶可以通过比较前面得到的 $F_p$ 和 $\\tilde{F}_p$ 的展开式来确定。从 $F_p$ 的展开式中减去 $\\tilde{F}_p$ 的展开式，可以发现 $h$ 的常数阶项相互抵消。$\\tilde{F}_p$ 的展开式不含 $h^2$ 阶项，因此误差的领头阶由 $F_p$ 中的 $h^2$ 阶项决定。\n$$\\delta F_{e,1} = F_1 - \\tilde{F}_1 = \\left(\\frac{h}{2}f(x_m) - \\frac{h^2}{12}f'(x_m) + O(h^3)\\right) - \\left(\\frac{h}{2}f(x_m) + O(h^3)\\right) = -\\frac{h^2}{12}f'(x_m) + O(h^3)$$\n$$\\delta F_{e,2} = F_2 - \\tilde{F}_2 = \\left(\\frac{h}{2}f(x_m) + \\frac{h^2}{12}f'(x_m) + O(h^3)\\right) - \\left(\\frac{h}{2}f(x_m) + O(h^3)\\right) = \\frac{h^2}{12}f'(x_m) + O(h^3)$$\n因此，相容性误差向量 $\\delta F_e$ 的领头阶表达式为：\n$$\\delta F_e = \\begin{pmatrix} -\\frac{h^2}{12}f'(x_m) \\\\ \\frac{h^2}{12}f'(x_m) \\end{pmatrix} + O(h^3)$$\n该局部误差是 $O(h^2)$ 阶的。在组装全局载荷向量时，对于由单元 $T_{i-1}$ 和 $T_i$ （尺寸均为 $h$）共享的内部节点 $j$，其误差贡献为 $\\delta F_j = \\delta F_{i-1, 2} + \\delta F_{i, 1}$。根据我们的结果，这大约是 $\\delta F_j \\approx \\frac{h^2}{12}f'(x_{m, i-1}) - \\frac{h^2}{12}f'(x_{m, i}) = \\frac{h^2}{12}(f'(x_{m, i-1}) - f'(x_{m, i})) \\approx \\frac{h^2}{12}(-h f''(x_{m, i})) = -\\frac{h^3}{12}f''(x_{m, i})$。这展示了一种抵消效应，即内部节点处的全局载荷向量误差的阶数 ($O(h^3)$) 高于局部单元误差的阶数。\n\n最终答案是 $\\delta F_e$ 的领头阶表达式。", "answer": "$$\\boxed{\\begin{pmatrix} -\\frac{h^2}{12} f'(x_m) \\\\ \\frac{h^2}{12} f'(x_m) \\end{pmatrix}}$$", "id": "3364904"}, {"introduction": "编写正确的有限元代码是应用该方法解决实际问题的前提，而分片检验 (patch test) 是验证代码正确性的黄金标准。本实践将指导您构建一系列分片检验 [@problem_id:3364930]，通过检查您的程序是否能精确再现已知的简单多项式解，来系统地调试和验证您的全局矩阵和载荷向量的装配过程。这项技能对于确保数值模拟结果的可靠性至关重要。", "problem": "考虑一个多边形域上的二维泊松方程，其弱形式为：在适当的 Sobolev 空间中找到一个标量场 $u$，使得对于所有测试函数 $v$，以下等式成立：$$\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\Omega} r \\, v \\, d\\Omega + \\int_{\\partial \\Omega} g \\, v \\, ds$$ 此处，$\\Omega$ 是域，$\\partial \\Omega$ 是其边界，$r$ 是一个体源项，$g$ 是边界上给定的法向通量。在狄利克雷边界条件下，测试函数空间被限制在 $\\partial \\Omega$ 上为零，因此边界积分被相应地省略。使用基于三角形单元的线性拉格朗日基函数的有限元法 (FEM)，全局线性系统由一个刚度矩阵 $K$ 和一个载荷向量 $b$ 组成，它们是由弱形式推导出的单元贡献组装而成的。\n\n你的任务是通过补丁检验实现原位验证，通过精确检查平衡约束和零空间性质来检测组装中的程序错误。程序必须：\n- 为通过将单位正方形 $\\Omega = [0,1]^2$ 剖分成 $N \\times N$ 个正方形，并将每个正方形分裂成两个三角形，然后应用给定的矩阵 $A$ 和向量 $\\mathbf{t}$ 的仿射映射 $F(\\mathbf{x}) = A \\mathbf{x} + \\mathbf{t}$ 所获得的网格，组装全局刚度矩阵 $K$ 和载荷向量 $b$。\n- 在三角形上使用线性拉格朗日基函数（分段仿射函数）。\n- 在适用时，实现体源项 $r$（域积分）和诺伊曼边界通量 $g$（边界积分）对载荷向量的贡献。\n- 通过将已知的多项式解代入组装好的离散系统中，并计算在组装正确时必须成立的残差和结构性质，来评估补丁检验。\n\n基本原理：\n- 泊松方程的弱形式以及通过与基函数做内积并在单元上积分来构建离散系统是出发点。线性拉格朗日单元在仿射变换下的线性性和相容性必须得到遵守。\n- 纯诺伊曼边界条件的零空间性质要求常数函数位于 $K$ 的核中，这意味着 $K \\mathbf{1} = \\mathbf{0}$。\n- 平衡约束要求在纯诺伊曼情况下，为了保证可解性，必须满足相容性条件 $\\int_{\\Omega} r \\, d\\Omega = \\int_{\\partial \\Omega} g \\, ds$。当 $r = 0$ 且 $u$ 是线性函数时，根据散度定理以及线性多项式的拉普拉斯算子为零，该条件简化为 $\\int_{\\partial \\Omega} \\mathbf{n} \\cdot \\nabla u \\, ds = 0$。\n\n实现以下作为指定参数集的测试套件。对于每种情况，计算指定的性质，并根据给定的容差生成一个布尔值，以指示通过或失败。所有计算都是纯数学的，无量纲的；不涉及物理单位。\n\n- 情况 $1$ (常规路径，狄利克雷线性补丁检验):\n  - 网格参数: $N = 4$。\n  - 仿射映射: $A = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$，$\\mathbf{t} = (0,0)$。\n  - 人造解: $u(\\mathbf{x}) = a + b x + c y$，其中 $a = \\frac{1}{3}$，$b = \\frac{7}{10}$，$c = -\\frac{2}{5}$。\n  - 源项: $r(\\mathbf{x}) = -\\Delta u(\\mathbf{x}) = 0$。\n  - 边界条件: 齐次狄利克雷测试空间（无边界通量项）。\n  - 验证: 计算残差向量 $r_{\\text{vec}} = K u - b$ 并检查限制在内部自由度上的最大绝对残差最多为 $\\epsilon = 10^{-12}$。\n\n- 情况 $2$ (仿射畸变，狄利克雷线性补丁检验):\n  - 网格参数: $N = 3$。\n  - 仿射映射: $A = \\begin{bmatrix}1  \\frac{1}{5} \\\\ \\frac{1}{10}  \\frac{13}{10}\\end{bmatrix}$，$\\mathbf{t} = (0,0)$。\n  - 人造解: $u(\\mathbf{x}) = a + b x + c y$，其中 $a = \\frac{1}{3}$，$b = \\frac{7}{10}$，$c = -\\frac{2}{5}$。\n  - 源项: $r(\\mathbf{x}) = 0$。\n  - 边界条件: 齐次狄利克雷测试空间。\n  - 验证: 与情况 $1$ 相同，检查内部残差 $\\leq \\epsilon$，其中 $\\epsilon = 10^{-12}$。\n\n- 情况 $3$ (零空间性质，纯诺伊曼常数解):\n  - 网格参数: $N = 3$。\n  - 仿射映射: $A = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$，$\\mathbf{t} = (0,0)$。\n  - 人造解: $u(\\mathbf{x}) = a$，其中 $a = \\frac{5}{2}$。\n  - 源项: $r(\\mathbf{x}) = 0$。\n  - 边界通量: $g(\\mathbf{x}) = 0$ 在 $\\partial \\Omega$ 上。\n  - 验证: 通过检验每个向量的最大绝对值分量最多为 $\\epsilon$，来检查 $K \\mathbf{1} = \\mathbf{0}$ 和 $K u = \\mathbf{0}$ 是否在容差 $\\epsilon = 10^{-12}$ 范围内成立。\n\n- 情况 $4$ (平衡约束和补丁检验，纯诺伊曼线性解):\n  - 网格参数: $N = 4$。\n  - 仿射映射: $A = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$，$\\mathbf{t} = (0,0)$。\n  - 人造解: $u(\\mathbf{x}) = a + b x + c y$，其中 $a = 0$，$b = -\\frac{3}{5}$，$c = \\frac{3}{10}$。\n  - 源项: $r(\\mathbf{x}) = 0$。\n  - 边界通量: $g(\\mathbf{x}) = \\mathbf{n} \\cdot \\nabla u(\\mathbf{x})$ 在 $\\partial \\Omega$ 上，其中 $\\mathbf{n}$ 是外单位法向量。对于线性的 $u$，$\\nabla u$ 是常数，诺伊曼载荷在边界边上是分段常数。\n  - 验证:\n    - 残差检查: 计算 $r_{\\text{vec}} = K u - b$ 并检查其最大绝对值分量最多为 $\\epsilon = 10^{-12}$。\n    - 平衡约束: 计算标量 $\\sum_i b_i$ 并检查其绝对值最多为 $\\epsilon = 10^{-12}$，这强制执行了与 $\\int_{\\partial \\Omega} g \\, ds = 0$ 一致的离散相容性。\n\n角度单位不适用。不涉及百分比。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result1,result2,result3,result4]$），其中每个 $resultk$ 是一个布尔值，表示第 $k$ 种情况的通过（$\\text{True}$）或失败（$\\text{False}$）。\n\n你的实现必须是自包含的，并且只使用 Python 语言和指定的库。不允许用户输入或使用外部文件。", "solution": "该问题要求实现二维泊松方程的有限元法 (FEM) 组装过程，并使用一系列补丁检验对其进行验证。补丁检验是计算力学中验证有限元实现正确性的一个基本程序。它基于这样一个原理：离散模型必须能够精确地再现一个常应变状态，对于 P1（线性拉格朗日）单元，这对应于精确再现任何线性多项式解。\n\n泊松方程的弱形式表述为：寻找 $u \\in H^1(\\Omega)$，使得对于所有测试函数 $v \\in V$，\n$$\na(u, v) = L(v)\n$$\n其中双线性形式 $a(u,v)$ 和线性泛函 $L(v)$ 定义为：\n$$\na(u, v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega\n$$\n$$\nL(v) = \\int_{\\Omega} r v \\, d\\Omega + \\int_{\\partial \\Omega} g v \\, ds\n$$\n其中，$\\Omega$ 是域，$r$ 是体源项，$g$ 是诺伊曼边界通量。对于狄利克雷边界条件，测试函数空间 $V$ 通常是 $H^1_0(\\Omega)$，即 $H^1(\\Omega)$ 中在边界 $\\partial \\Omega_D$ 上为零的函数空间，并且在 $\\partial \\Omega_D$ 上的边界积分被省略。\n\n在有限元法中，解 $u$ 被一个来自有限维空间 $V_h \\subset H^1(\\Omega)$ 的函数 $u_h$ 近似，该空间由一组基函数 $\\{\\phi_i\\}_{i=1}^{N_{nodes}}$ 张成：\n$$\nu_h(\\mathbf{x}) = \\sum_{j=1}^{N_{nodes}} u_j \\phi_j(\\mathbf{x})\n$$\n其中 $u_j$ 是未知系数，代表解在网格节点处的值。然后，对一组离散的测试函数（通常是基函数本身，即伽辽金法）强制执行弱形式，即对于 $i=1, \\dots, N_{nodes}$，取 $v = \\phi_i$。这会导出一个线性方程组 $K \\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u}$ 是节点值 $\\{u_j\\}$ 的向量。\n\n全局刚度矩阵 $K$ 和载荷向量 $\\mathbf{b}$ 的各项由下式给出：\n$$\nK_{ij} = a(\\phi_j, \\phi_i) = \\int_{\\Omega} \\nabla \\phi_j \\cdot \\nabla \\phi_i \\, d\\Omega\n$$\n$$\nb_i = L(\\phi_i) = \\int_{\\Omega} r \\phi_i \\, d\\Omega + \\int_{\\partial \\Omega} g \\phi_i \\, ds\n$$\n这些积分通过对网格三角剖分 $\\mathcal{T}_h$ 中每个单元 $T_e$ 的贡献求和来计算：\n$$\nK_{ij} = \\sum_{T_e \\in \\mathcal{T}_h} \\int_{T_e} \\nabla \\phi_j \\cdot \\nabla \\phi_i \\, d\\Omega = \\sum_{T_e \\in \\mathcal{T}_h} K_e^{ij}\n$$\n$$\nb_i = \\sum_{T_e \\in \\mathcal{T}_h} \\int_{T_e} r \\phi_i \\, d\\Omega + \\sum_{E \\in \\mathcal{E}_h, E \\subset \\partial\\Omega} \\int_E g \\phi_i \\, ds\n$$\n其中 $K_e$ 是单元刚度矩阵。将单元贡献求和以构成全局系统的过程称为组装。\n\n对于带有线性拉格朗日基函数（P1 单元）的三角形单元，与节点 $i$ 相关联的基函数 $\\phi_i$ 是一个在节点 $i$ 处为 1、在另外两个节点处为 0 的平面。因此，其梯度 $\\nabla \\phi_i$ 在该单元上是一个常向量。对于面积为 $A_e$、顶点为 $\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3$ 的三角形 $T_e$，其单元刚度矩阵的各项为：\n$$\nK_e^{ij} = A_e (\\nabla \\phi_i \\cdot \\nabla \\phi_j)\n$$\n梯度可以从顶点坐标计算得出。例如，$\\nabla \\phi_1 = \\frac{1}{2A_e} \\begin{pmatrix} y_2 - y_3 \\\\ x_3 - x_2 \\end{pmatrix}$，对于 $\\nabla \\phi_2, \\nabla \\phi_3$ 也可以通过对下标进行循环置换得到类似的结果。\n\n所提供的测试用例验证了 FEM 组装的关键性质：\n\n**情况 1  2 (狄利克雷补丁检验):** 这些测试验证了实现能够精确再现线性解 $u(\\mathbf{x}) = a + bx + cy$。对于这样的 $u$，其拉普拉斯算子为 $\\Delta u = 0$，因此源项 $r=0$。当 $u_h$ 是一个线性多项式时，精确解位于有限元空间 $V_h$ 中。伽辽金正交性意味着对于所有对应于内部节点（测试函数在边界上为零的节点）的方程，组装后系统的残差必须为零。这必须对规则网格（情况1）和经仿射变换畸变的网格（情况2）都成立，从而证明了该公式的几何不变性。\n\n**情况 3 (零空间性质):** 对于一个纯诺伊曼问题（在 $\\partial\\Omega$ 上处处给定 $g$），其解在相差一个加性常数的意义下是唯一的。如果 $u$ 是一个解，那么 $u+C$ 也是一个解。这个性质反映在刚度矩阵 $K$ 上。对于任何常数函数 $u(\\mathbf{x}) = C$，其梯度为零，因此 $\\int_\\Omega \\nabla u \\cdot \\nabla v \\, d\\Omega = 0$ 对于任何 $v$ 都成立。在离散系统中，如果我们将节点值设为一个常数向量 $\\mathbf{u} = C \\mathbf{1}$（其中 $\\mathbf{1}$ 是所有元素都为1的向量），结果必须是 $K(C\\mathbf{1}) = C(K\\mathbf{1}) = \\mathbf{0}$。这意味着向量 $\\mathbf{1}$ 必须在 $K$ 的零空间中，这也就意味着 $K$ 的每一行之和必须为零。该测试验证了这一结构性质。\n\n**情况 4 (诺伊曼补丁检验和平衡):** 该测试考虑了一个线性解 $u(\\mathbf{x}) = bx+cy$ 以及与之相容的诺伊曼边界条件 $g=\\nabla u \\cdot \\mathbf{n}$。右端向量 $\\mathbf{b}$ 是由这个边界通量项组装而成的。与狄利克雷情况一样，线性解必须被精确地恢复，因此残差 $K\\mathbf{u} - \\mathbf{b}$ 必须处处为零。此外，为了使纯诺伊曼问题有解，源项必须满足相容性（或平衡）条件 $\\int_\\Omega r \\, d\\Omega = \\int_{\\partial\\Omega} g \\, ds$。这里，$r=0$，并且 $g$ 的选择使得 $\\int_{\\partial\\Omega} g \\, ds = \\int_{\\partial\\Omega} \\nabla u \\cdot \\mathbf{n} \\, ds = \\int_\\Omega \\Delta u \\, d\\Omega = 0$。其离散等价形式是载荷向量中所有项的总和 $\\sum_i b_i$ 必须为零。这是因为 $\\sum_i b_i = \\sum_i \\int_{\\partial\\Omega} g \\phi_i ds = \\int_{\\partial\\Omega} g (\\sum_i \\phi_i) ds = \\int_{\\partial\\Omega} g \\, ds$，利用了单位分解性质 $\\sum_i \\phi_i = 1$。该测试既验证了诺伊曼边界项的正确组装，也验证了离散平衡条件的满足情况。\n\n实现将遵循这些原则，构建网格，逐单元组装矩阵和向量，然后执行指定的数值检查，容差为 $\\epsilon = 10^{-12}$。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\n\ndef solve():\n    \"\"\"\n    Main function to run the FEM patch tests and print results.\n    \"\"\"\n\n    def create_mesh(N, A, t):\n        \"\"\"\n        Generates a mesh on the affine-transformed unit square.\n        Args:\n            N (int): Number of subdivisions along each axis of the unit square.\n            A (np.ndarray): 2x2 matrix for the affine transformation.\n            t (np.ndarray): 2x1 translation vector for the affine transformation.\n        Returns:\n            tuple: (nodes, elements)\n                - nodes (np.ndarray): Array of node coordinates, shape (num_nodes, 2).\n                - elements (np.ndarray): Array of element connectivities, shape (num_elements, 3).\n        \"\"\"\n        num_nodes = (N + 1) * (N + 1)\n        nodes = np.zeros((num_nodes, 2))\n        for j in range(N + 1):\n            for i in range(N + 1):\n                node_idx = j * (N + 1) + i\n                ref_pos = np.array([i / N, j / N])\n                nodes[node_idx] = A @ ref_pos + t\n\n        num_elements = 2 * N * N\n        elements = np.zeros((num_elements, 3), dtype=int)\n        elem_idx = 0\n        for j in range(N):\n            for i in range(N):\n                n00 = j * (N + 1) + i\n                n10 = j * (N + 1) + (i + 1)\n                n01 = (j + 1) * (N + 1) + i\n                n11 = (j + 1) * (N + 1) + (i + 1)\n                elements[elem_idx] = [n00, n10, n11]\n                elem_idx += 1\n                elements[elem_idx] = [n00, n11, n01]\n                elem_idx += 1\n        return nodes, elements\n\n    def assemble_stiffness_matrix(nodes, elements):\n        \"\"\"\n        Assembles the global stiffness matrix K using P1 elements.\n        \"\"\"\n        num_nodes = len(nodes)\n        K = lil_matrix((num_nodes, num_nodes))\n\n        for el_nodes_idx in elements:\n            p1, p2, p3 = nodes[el_nodes_idx[0]], nodes[el_nodes_idx[1]], nodes[el_nodes_idx[2]]\n            \n            area = 0.5 * np.abs(p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]))\n            if area  1e-15: continue\n\n            b = np.array([p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]])\n            c = np.array([p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]])\n            \n            Ke = np.zeros((3, 3))\n            for i in range(3):\n                for j in range(3):\n                    grad_dot_prod = (b[i] * b[j] + c[i] * c[j]) / (4 * area**2)\n                    Ke[i, j] = grad_dot_prod * area\n            \n            for i in range(3):\n                for j in range(3):\n                    gi, gj = el_nodes_idx[i], el_nodes_idx[j]\n                    K[gi, gj] += Ke[i, j]\n        \n        return K.tocsr()\n\n    def run_case(case_params):\n        \"\"\"\n        Executes a single test case.\n        \"\"\"\n        N = case_params['N']\n        A = np.array(case_params['A'])\n        t = np.array(case_params['t'])\n        u_params = case_params['u_params']\n        tol = case_params['tol']\n        \n        nodes, elements = create_mesh(N, A, t)\n        K = assemble_stiffness_matrix(nodes, elements)\n        num_nodes = len(nodes)\n\n        if case_params['type'] == 'dirichlet_linear':\n            a, b_u, c_u = u_params['a'], u_params['b'], u_params['c']\n            b = np.zeros(num_nodes)\n            u_vec = a + b_u * nodes[:, 0] + c_u * nodes[:, 1]\n            residual = K @ u_vec - b\n            \n            interior_nodes_mask = np.ones(num_nodes, dtype=bool)\n            for j in range(N + 1):\n                for i in range(N + 1):\n                    if i == 0 or i == N or j == 0 or j == N:\n                        node_idx = j * (N + 1) + i\n                        interior_nodes_mask[node_idx] = False\n            \n            max_interior_residual = np.max(np.abs(residual[interior_nodes_mask]))\n            return max_interior_residual = tol\n\n        elif case_params['type'] == 'nullspace':\n            a = u_params['a']\n            ones_vec = np.ones(num_nodes)\n            res_null = K @ ones_vec\n            check1 = np.max(np.abs(res_null)) = tol\n            \n            u_vec = np.full(num_nodes, a)\n            res_const = K @ u_vec\n            check2 = np.max(np.abs(res_const)) = tol\n            return check1 and check2\n\n        elif case_params['type'] == 'neumann_linear':\n            a, b_u, c_u = u_params['a'], u_params['b'], u_params['c']\n            b = np.zeros(num_nodes)\n            \n            g_bottom, g_right, g_top, g_left = -c_u, b_u, c_u, -b_u\n\n            for i in range(N):\n                n1, n2 = i, i + 1\n                edge_len = np.linalg.norm(nodes[n2] - nodes[n1])\n                b[n1] += g_bottom * edge_len / 2.0\n                b[n2] += g_bottom * edge_len / 2.0\n            \n            for j in range(N):\n                n1, n2 = j * (N + 1) + N, (j + 1) * (N + 1) + N\n                edge_len = np.linalg.norm(nodes[n2] - nodes[n1])\n                b[n1] += g_right * edge_len / 2.0\n                b[n2] += g_right * edge_len / 2.0\n\n            for i in range(N):\n                n1, n2 = N * (N + 1) + i, N * (N + 1) + (i + 1)\n                edge_len = np.linalg.norm(nodes[n2] - nodes[n1])\n                b[n1] += g_top * edge_len / 2.0\n                b[n2] += g_top * edge_len / 2.0\n                \n            for j in range(N):\n                n1, n2 = j * (N + 1), (j + 1) * (N + 1)\n                edge_len = np.linalg.norm(nodes[n2] - nodes[n1])\n                b[n1] += g_left * edge_len / 2.0\n                b[n2] += g_left * edge_len / 2.0\n\n            u_vec = a + b_u * nodes[:, 0] + c_u * nodes[:, 1]\n            residual = K @ u_vec - b\n            check1 = np.max(np.abs(residual)) = tol\n            check2 = np.abs(np.sum(b)) = tol\n\n            return check1 and check2\n        \n        return False\n\n    test_cases = [\n        {\n            'type': 'dirichlet_linear', 'N': 4,\n            'A': [[1, 0], [0, 1]], 't': [0, 0],\n            'u_params': {'a': 1/3, 'b': 7/10, 'c': -2/5},\n            'tol': 1e-12\n        },\n        {\n            'type': 'dirichlet_linear', 'N': 3,\n            'A': [[1, 1/5], [1/10, 13/10]], 't': [0, 0],\n            'u_params': {'a': 1/3, 'b': 7/10, 'c': -2/5},\n            'tol': 1e-12\n        },\n        {\n            'type': 'nullspace', 'N': 3,\n            'A': [[1, 0], [0, 1]], 't': [0, 0],\n            'u_params': {'a': 5/2},\n            'tol': 1e-12\n        },\n        {\n            'type': 'neumann_linear', 'N': 4,\n            'A': [[1, 0], [0, 1]], 't': [0, 0],\n            'u_params': {'a': 0, 'b': -3/5, 'c': 3/10},\n            'tol': 1e-12\n        }\n    ]\n\n    results = [run_case(case) for case in test_cases]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3364930"}, {"introduction": "许多物理问题，如热传导和流体力学中的某些情况，天然地由纯诺伊曼 (Neumann) 边界条件描述，这会导致奇异的线性系统。本练习将引导您处理这类问题 [@problem_id:3364950]，您将学习如何识别和验证离散系统的奇异性、检验其解存在的相容性条件，并实现两种常用的施加唯一性约束的方法。通过对比不同方法，您将对守恒定律的离散体现及其在数值求解中的处理方式有更深刻的认识。", "problem": "考虑定义在区域 $[0,1]$ 上的守恒形式纯 Neumann 边界条件下的一维扩散方程，这是一个典型的偏微分方程（PDE）。从通过分部积分推导出的经典 Galerkin 弱形式出发，在一个包含 $N$ 个区间的均匀网格上，使用连续分片线性（一阶拉格朗日）基函数，通过有限元法（FEM）组装全局刚度矩阵和载荷向量。设扩散系数为 $k(x)=1$。设 $n$ 为单位外法线，$q(0)$ 和 $q(1)$ 分别为边界上给定的外通量。用 $f(x)$ 表示源项。纯 Neumann 问题是可解的，当且仅当相容性条件成立，且其解在相差一个加性常数的意义下是唯一的。您的任务是：\n\n- 为 Neumann 问题组装全局刚度矩阵 $K$ 和载荷向量 $b$，确保将边界通量 $q(0)$ 和 $q(1)$ 正确地整合到右侧项中。\n- 识别与常数函数对应的离散零空间向量，并通过计算验证 $K \\mathbf{1} = \\mathbf{0}$，其中 $\\mathbf{1}$ 是全局全一向量，$\\mathbf{0}$ 是大小兼容的零向量。\n- 通过数值验证 $\\mathbf{1}^{\\mathsf{T}} b$ 等于相容性条件的离散模拟，来展示 Neumann 问题的离散守恒性。\n- 用两种不同的方法解决非唯一性问题，并比较结果：\n  1. 通过在一个节点上施加 Dirichlet 条件（例如，$u(0)=0$）来钉住一个自由度，从而获得唯一解 $u_{\\mathrm{pin}}$。\n  2. 通过单个拉格朗日乘子施加零均值约束，以获得唯一解 $u_{\\mathrm{lag}}$。使用精确的积分约束 $\\int_{0}^{1} u(x)\\,dx = 0$，其离散形式由向量 $m$ 表示，其分量为 $m_i = \\int_{0}^{1} \\varphi_i(x)\\,dx$，其中 $\\{\\varphi_i\\}$ 是节点基函数。不要假定 $m_i$ 有简化公式；对于所选的均匀网格上的基函数，应精确计算这些积分。\n- 为了比较 $u_{\\mathrm{pin}}$ 和 $u_{\\mathrm{lag}}$，通过选择一个能最小化由 $m$ 导出的求积下的离散 $L^{2}$ 距离的 $\\alpha$ 来移除 $u_{\\mathrm{pin}}$ 中的任意常数：找出最小化 $\\|u_{\\mathrm{pin}} - \\alpha \\mathbf{1} - u_{\\mathrm{lag}}\\|_{M}$ 的 $\\alpha$，其中 $\\|w\\|_{M}^{2} = \\sum_{i} m_i w_i^{2}$。报告最小化的距离。\n\n您的推导应严格基于：\n- Galerkin 弱形式以及从局部单元贡献组装 FEM 的定义。\n- 基函数的单位分解性质以及自然边界条件下边界通量插入的精确性。\n- 通过用常数函数检验弱形式所隐含的守恒性质。\n\n您需要实现一个单一的自包含程序，为每个测试用例计算以下三个定量诊断指标：\n- 欧几里得范数 $\\|K \\mathbf{1}\\|_{2}$。\n- 绝对值 $|\\mathbf{1}^{\\mathsf{T}} b|$。\n- 通过上述定义的 $\\alpha$ 进行最优对齐后的质量加权距离 $\\|u_{\\mathrm{pin}} - \\alpha \\mathbf{1} - u_{\\mathrm{lag}}\\|_{M}$。\n\n测试套件：\n- 案例 1（正常路径，零通量，振荡零均值源）：$N=32$，$f(x)=\\sin(2\\pi x)$，$q(0)=0$，$q(1)=0$。\n- 案例 2（非零边界通量以满足恒定源的相容性）：$N=9$，$f(x)=1$，$q(0)=0$，$q(1)=-1$。\n- 案例 3（边缘情况，最粗糙网格，零源与平衡的相反通量）：$N=1$，$f(x)=0$，$q(0)=2$，$q(1)=-2$。\n\n您的程序应：\n- 在 $[0,1]$ 上的均匀网格上使用一阶拉格朗日单元组装 $K$ 和 $b$。\n- 对单元载荷向量使用足够精确的数值求积，以确保对守恒性和零空间性质进行有意义的验证。\n- 通过钉住左边界节点 $x=0$ 处的值来计算 $u_{\\mathrm{pin}}$，并通过求解带有如上定义的约束向量 $m$ 的增广鞍点系统来计算 $u_{\\mathrm{lag}}$。\n- 对每个案例，生成上述描述的浮点数三元组。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为 $[\\text{case1\\_k1},\\text{case1\\_b1},\\text{case1\\_d1},\\text{case2\\_k1},\\text{case2\\_b1},\\text{case2\\_d1},\\text{case3\\_k1},\\text{case3\\_b1},\\text{case3\\_d1}]$，其中每个案例的三个条目分别是 $\\|K \\mathbf{1}\\|_{2}$、 $|\\mathbf{1}^{\\mathsf{T}} b|$ 和最小化的质量加权距离。所有数值必须是浮点数。", "solution": "该问题要求使用有限元法（FEM）为具有纯 Neumann 边界条件的一维扩散方程组装全局刚度矩阵和载荷向量，并对得到的线性系统进行后续分析。\n\n### 求解步骤\n\n**1. 弱形式与相容性条件**\nPDE 为 $-u''(x) = f(x)$，定义在 $[0,1]$ 上，扩散系数 $k(x)=1$。Neumann 边界条件规定了边界上的物理通量。物理通量向量为 $\\mathbf{J} = -k \\nabla u$。外通量是通量向量与边界外法向 $\\mathbf{n}_{\\text{out}}$ 的点积：$q_{\\text{out}} = \\mathbf{J} \\cdot \\mathbf{n}_{\\text{out}}$。\n- 在 $x=1$ 处，$\\mathbf{n}_{\\text{out}} = (1)$，因此外通量为 $q_{\\text{out}}(1) = (-u'(1)) \\cdot 1 = -u'(1)$。\n- 在 $x=0$ 处，$\\mathbf{n}_{\\text{out}} = (-1)$，因此外通量为 $q_{\\text{out}}(0) = (-u'(0)) \\cdot (-1) = u'(0)$。\n我们假设问题中给定的参数 $q(0)$ 和 $q(1)$ 分别代表 $q_{\\text{out}}(0)$ 和 $q_{\\text{out}}(1)$。\n\n将 PDE 乘以一个检验函数 $v(x) \\in H^1(0,1)$ 并在定义域上积分，然后进行分部积分：\n$$\n\\int_0^1 u'(x) v'(x) dx - [u'(x)v(x)]_0^1 = \\int_0^1 f(x) v(x) dx\n$$\n整理并用外通量替换边界项：\n$$\n\\int_0^1 u'(x) v'(x) dx = \\int_0^1 f(x) v(x) dx + u'(1)v(1) - u'(0)v(0) = \\int_0^1 f(x) v(x) dx - q_{\\text{out}}(1)v(1) - q_{\\text{out}}(0)v(0)\n$$\n最终的弱形式是找到 $u \\in H^1(0,1)$，使得对于所有 $v \\in H^1(0,1)$：\n$$\na(u,v) = L(v)\n$$\n其中双线性形式为 $a(u,v) = \\int_0^1 u'(x) v'(x) dx$，线性泛函为 $L(v) = \\int_0^1 f(x) v(x) dx - q(1)v(1) - q(0)v(0)$。\n\n要使该问题有解，必须满足相容性（或可解性）条件。对强形式 PDE 在整个域上积分可得：\n$$\n\\int_0^1 f(x) dx = \\int_0^1 -u''(x) dx = -[u'(x)]_0^1 = -u'(1) - (-u'(0)) = q_{\\text{out}}(1) - q_{\\text{out}}(0) = q(1) - q(0)\n$$\n因此，相容性条件为 $\\int_0^1 f(x) dx = q(1) - q(0)$。\n\n**注意**：根据此推导，案例2（$f(x)=1, q(0)=0, q(1)=-1$）不满足此相容性条件，因为 $\\int_0^1 1 dx = 1$ 但 $q(1)-q(0) = -1-0=-1$。这表明该案例在所选的物理模型下是病态的。代码中实现的弱形式与物理的外通量定义不符，而是遵循了 `L(v) = ... + q(0)v(0) + q(1)v(1)` 的形式。这对应于一个不同的边界条件约定，其相容性条件为 $\\int_0^1 f(x) dx = -(q(0)+q(1))$，所有给定的测试用例都满足这个条件。因此，以下推导将遵循代码中实现的数学模型，而非标准的物理定义。\n\n**2. FEM 离散化与组装（基于代码实现的模型）**\n我们将区域 $[0,1]$ 离散化为 $N$ 个长度为 $h=1/N$ 的均匀区间。这创建了 $N+1$ 个节点，$x_i = i h$，$i=0, \\dots, N$。我们使用连续分片线性（P1 拉格朗日）基函数 $\\{\\varphi_i(x)\\}_{i=0}^N$，其中 $\\varphi_i(x_j)=\\delta_{ij}$。FEM 近似为 $u_h(x) = \\sum_{j=0}^N u_j \\varphi_j(x)$。\n\nGalerkin 方法导出了线性系统 $K\\mathbf{u} = \\mathbf{b}$。\n全局刚度矩阵 $K$ 的元素为 $K_{ij} = \\int_0^1 \\varphi_j'(x) \\varphi_i'(x) dx$。对于长度为 $h$ 的单元，单元刚度矩阵为 $K^e = \\frac{1}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。组装后，全局 $(N+1) \\times (N+1)$ 矩阵 $K$ 是三对角的：\n$$\nK = \\frac{1}{h} \\begin{pmatrix}\n1  -1    \\\\\n-1  2  -1   \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  -1  2  -1 \\\\\n   -1  1\n\\end{pmatrix}\n$$\n根据代码，载荷向量的元素为 $b_i = \\int_0^1 f(x) \\varphi_i(x) dx + q(1)\\varphi_i(1) + q(0)\\varphi_i(0)$。积分部分使用数值求积计算。边界通量项仅影响向量的第一个和最后一个元素：\n$$\nb_0 = \\mathbf{b}^{src}_0 + q(0) \\quad , \\quad b_N = \\mathbf{b}^{src}_N + q(1) \\quad , \\quad b_i = \\mathbf{b}^{src}_i \\text{ for } 0  i  N\n$$\n\n**3. 零空间与离散守恒**\n- **零空间：** 向量 $\\mathbf{1}=[1, \\dots, 1]^T$ 表示网格上的一个常数函数。矩阵 $K$ 的每行之和为零。因此，$K\\mathbf{1} = \\mathbf{0}$，这意味着 $K$ 是奇异的，其零空间包含常数向量。第一个诊断指标 $\\|K\\mathbf{1}\\|_2$ 应接近机器精度。\n- **守恒性：** $K\\mathbf{u}=\\mathbf{b}$ 的解仅在 $\\mathbf{b}$ 与 $K^T=K$ 的零空间正交时存在。因此，离散相容性条件是 $\\mathbf{1}^T\\mathbf{b} = 0$。\n$$\n\\mathbf{1}^T\\mathbf{b} = \\sum_{i=0}^N b_i = \\sum_{i=0}^N \\left( \\int_0^1 f(x)\\varphi_i(x)dx + q(1)\\delta_{iN} + q(0)\\delta_{i0} \\right) = \\int_0^1 f(x) \\left( \\sum_{i=0}^N \\varphi_i(x) \\right) dx + q(1) + q(0)\n$$\n使用单位分解性质 $\\sum_{i=0}^N \\varphi_i(x) = 1$，我们得到离散相容性条件 $\\int_0^1 f(x) dx + q(1) + q(0) = 0$。第二个诊断指标 $|\\mathbf{1}^T\\mathbf{b}|$ 验证了这一点。\n\n**4. 解决奇异性**\n- **钉住法 ($u_{\\mathrm{pin}}$)：** 我们通过设置一个值来强制唯一性，例如 $u_0=0$。这消除了第一个未知数。系统被简化为关于剩余未知数 $u_1, \\dots, u_N$ 的一个 $N \\times N$ 系统。子矩阵 $K_{1:,1:}$ 是非奇异的。我们求解 $K_{1:,1:} [u_1, \\dots, u_N]^T = \\mathbf{b}_{1:}$ 并在前面加上 $u_0=0$ 得到 $\\mathbf{u}_{\\mathrm{pin}}$。\n- **拉格朗日乘子法 ($u_{\\mathrm{lag}}$)：** 我们强制执行积分约束 $\\int_0^1 u(x) dx = 0$。在离散形式下，这是 $\\mathbf{m}^T\\mathbf{u}=0$，其中 $m_i = \\int_0^1 \\varphi_i(x) dx$。对于具有 P1 单元的均匀网格，$m_i=h$ 对于内部节点（$i=1,\\dots,N-1$），$m_i=h/2$ 对于边界节点（$i=0,N$）。这导出了一个非奇异的增广 $(N+2)\\times(N+2)$ 鞍点系统：\n$$\n\\begin{pmatrix} K  \\mathbf{m} \\\\ \\mathbf{m}^T  0 \\end{pmatrix} \\begin{pmatrix} \\mathbf{u}_{\\mathrm{lag}} \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} \\mathbf{b} \\\\ 0 \\end{pmatrix}\n$$\n\n**5. 解的比较**\n解 $\\mathbf{u}_{\\mathrm{pin}}$ 和 $\\mathbf{u}_{\\mathrm{lag}}$ 都满足底层的物理规律，但相差一个常数。我们通过找到一个常数 $\\alpha$ 来将 $\\mathbf{u}_{\\mathrm{pin}}$ 与 $\\mathbf{u}_{\\mathrm{lag}}$ 对齐，该常数最小化距离 $\\| \\mathbf{u}_{\\mathrm{pin}} - \\alpha\\mathbf{1} - \\mathbf{u}_{\\mathrm{lag}} \\|_M$，其中范数平方定义为 $\\|w\\|_M^2 = \\sum_i m_i w_i^2$。\n令 $\\mathbf{v} = \\mathbf{u}_{\\mathrm{pin}} - \\mathbf{u}_{\\mathrm{lag}}$。我们最小化 $E(\\alpha) = \\sum_i m_i (v_i-\\alpha)^2$。将其导数设为零得到最优的 $\\alpha$：\n$$\n\\alpha_{\\mathrm{opt}} = \\frac{\\mathbf{m}^T \\mathbf{v}}{\\mathbf{m}^T \\mathbf{1}} = \\frac{\\mathbf{m}^T (\\mathbf{u}_{\\mathrm{pin}} - \\mathbf{u}_{\\mathrm{lag}})}{\\mathbf{m}^T \\mathbf{1}}\n$$\n由于通过构造有 $\\mathbf{m}^T\\mathbf{u}_{\\mathrm{lag}}=0$，且 $\\mathbf{m}^T\\mathbf{1} = \\sum_i m_i = \\int_0^1 (\\sum_i \\varphi_i) dx = 1$，最优位移为 $\\alpha_{\\mathrm{opt}} = \\mathbf{m}^T \\mathbf{u}_{\\mathrm{pin}}$。第三个诊断指标是得到的最小化距离，它衡量了两个解在最优对齐后的差异。这个距离不严格为零，因为钉住程序求解的是一个略微修改过的系统。", "answer": "```python\nimport numpy as np\n\ndef solve_case(N, f, q0, q1):\n    \"\"\"\n    Solves the 1D Neumann problem and computes specified diagnostics.\n\n    Args:\n        N (int): Number of intervals in the uniform mesh.\n        f (callable): Source function f(x).\n        q0 (float): Prescribed flux parameter at x=0.\n        q1 (float): Prescribed flux parameter at x=1.\n\n    Returns:\n        tuple: A tuple containing the three diagnostic values:\n               (norm_k1, abs_one_T_b, dist).\n    \"\"\"\n    h = 1.0 / N\n    nodes = N + 1\n    x_nodes = np.linspace(0, 1, nodes)\n\n    # 1. Assemble Stiffness Matrix K\n    K = np.zeros((nodes, nodes))\n    diag_vals = np.full(nodes, 2.0 / h)\n    diag_vals[0] = 1.0 / h\n    diag_vals[-1] = 1.0 / h\n    np.fill_diagonal(K, diag_vals)\n    off_diag_vals = np.full(nodes - 1, -1.0 / h)\n    np.fill_diagonal(K[1:], off_diag_vals)\n    np.fill_diagonal(K[:, 1:], off_diag_vals)\n\n    # 2. Assemble Load Vector b\n    b = np.zeros(nodes)\n    # Use 2-point Gauss quadrature on a [0,1] reference element\n    gauss_points = 0.5 + np.array([-1.0, 1.0]) / (2.0 * np.sqrt(3.0))\n    gauss_weights = np.array([0.5, 0.5])\n\n    for i in range(N):\n        # Physical coordinates of quadrature points on element [x_i, x_{i+1}]\n        x_phys = x_nodes[i] + h * gauss_points\n        f_vals = f(x_phys)\n        \n        # Contribution to b[i] from local basis function (1-xi)\n        integrand1 = f_vals * (1.0 - gauss_points)\n        b[i] += h * np.dot(gauss_weights, integrand1)\n\n        # Contribution to b[i+1] from local basis function (xi)\n        integrand2 = f_vals * gauss_points\n        b[i + 1] += h * np.dot(gauss_weights, integrand2)\n\n    # Add boundary flux contributions based on the derived weak form\n    b[0] += q0\n    b[-1] += q1\n\n    # Task 1: Compute ||K*1||_2\n    one_vec = np.ones(nodes)\n    norm_k1 = np.linalg.norm(K @ one_vec)\n\n    # Task 2: Compute |1^T * b|\n    abs_one_T_b = np.abs(np.sum(b))\n\n    # 3. Resolve non-uniqueness\n    # Pinning method for u_pin (u(0)=0)\n    K_pin = K[1:, 1:]\n    b_pin = b[1:]\n    u_sub = np.linalg.solve(K_pin, b_pin)\n    u_pin = np.concatenate(([0.0], u_sub))\n\n    # Lagrange multiplier method for u_lag\n    m = h * np.ones(nodes)\n    m[0] = h / 2.0\n    m[-1] = h / 2.0\n    \n    A_aug = np.zeros((nodes + 1, nodes + 1))\n    A_aug[:nodes, :nodes] = K\n    A_aug[:nodes, nodes] = m\n    A_aug[nodes, :nodes] = m\n    \n    b_aug = np.concatenate((b, [0.0]))\n    \n    sol_aug = np.linalg.solve(A_aug, b_aug)\n    u_lag = sol_aug[:-1]\n\n    # Task 3: Compare u_pin and u_lag\n    # Optimal constant alpha to align u_pin with u_lag\n    # alpha = (m.T @ (u_pin - u_lag)) / (m.T @ 1)\n    # Since m.T @ u_lag = 0 and m.T @ 1 = 1, alpha = m.T @ u_pin\n    alpha = np.dot(m, u_pin)\n    \n    # Vector for distance calculation\n    w = u_pin - alpha * one_vec - u_lag\n    \n    # Calculate mass-weighted distance as defined\n    dist_sq = np.sum(m * (w**2))\n    dist = np.sqrt(dist_sq)\n\n    return norm_k1, abs_one_T_b, dist\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: N=32, f(x)=sin(2*pi*x), q(0)=0, q(1)=0\n        (32, lambda x: np.sin(2 * np.pi * x), 0.0, 0.0),\n        # Case 2: N=9, f(x)=1, q(0)=0, q(1)=-1\n        (9, lambda x: np.ones_like(x), 0.0, -1.0),\n        # Case 3: N=1, f(x)=0, q(0)=2, q(1)=-2\n        (1, lambda x: np.zeros_like(x), 2.0, -2.0),\n    ]\n\n    results = []\n    for N, f, q0, q1 in test_cases:\n        norm_k1, abs_one_T_b, dist = solve_case(N, f, q0, q1)\n        results.extend([norm_k1, abs_one_T_b, dist])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3364950"}]}