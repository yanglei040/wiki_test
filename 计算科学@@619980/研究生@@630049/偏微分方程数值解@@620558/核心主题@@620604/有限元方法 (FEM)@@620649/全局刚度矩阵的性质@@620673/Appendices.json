{"hands_on_practices": [{"introduction": "静态凝聚（Static condensation）是有限元分析中的一种强大技术，它允许我们消除单元内部的自由度，从而得到一个只涉及边界或界面节点的简化系统。这个练习将引导你从第一性原理出发，为一个一维扩散问题组装刚度矩阵，然后通过分块矩阵运算推导出其舒尔补（Schur complement）。通过这个过程，你不仅能加深对刚度矩阵组装过程的理解，还能掌握静态凝聚这一在子结构法和区域分解方法中至关重要的基本工具[@problem_id:3437062]。", "problem": "考虑一维空间区间 $[0,1]$ 上的标量扩散边值问题：求解 $u$ 使得 $-(a(x) u^{\\prime}(x))^{\\prime} = 0$ 在 $(0,1)$ 上成立，其中传导系数 $a(x)$ 是分段常数，具体为在 $[0,\\tfrac{1}{3}]$ 上 $a(x) = 2$，在 $[\\tfrac{1}{3},\\tfrac{2}{3}]$ 上 $a(x) = 3$，以及在 $[\\tfrac{2}{3},1]$ 上 $a(x) = 5$。使用标准连续分片线性有限元法 (FEM) 在具有节点 $x_0 = 0$, $x_1 = \\tfrac{1}{3}$, $x_2 = \\tfrac{2}{3}$, $x_3 = 1$ 的均匀剖分上对弱形式进行离散化，并采用相应的节点基函数 $\\{\\varphi_0,\\varphi_1,\\varphi_2,\\varphi_3\\}$。组装全局刚度矩阵 $K \\in \\mathbb{R}^{4 \\times 4}$，其元素为 $K_{ij} = \\int_0^1 a(x) \\varphi_i^{\\prime}(x) \\varphi_j^{\\prime}(x)\\,dx$。将自由度划分为边界索引 $b = \\{0,3\\}$ 和内部索引 $i = \\{1,2\\}$，从而矩阵 $K$ 的分块形式为\n$$\nK = \\begin{pmatrix}\nK_{bb}  & K_{bi} \\\\\nK_{ib}  & K_{ii}\n\\end{pmatrix}.\n$$\n仅使用伽辽金 (Galerkin) 方法和分块高斯消去的基本原理，执行静态凝聚以消去内部未知数，并推导作用于边界自由度上的舒尔补 $S = K_{bb} - K_{bi} K_{ii}^{-1} K_{ib}$。所有量均为无量纲。使用精确算术计算凝聚矩阵中连接末端节点 $x_0$ 和 $x_3$ 的非对角线元素，即当边界索引排序为 $(0,3)$ 时，$S$ 的 $(1,2)$ 元素。以最简分数形式给出最终答案。不要四舍五入。", "solution": "用户希望求解一个通过有限元法 (FEM) 离散化的一维扩散问题的舒尔补矩阵中的一个特定元素。\n\n**步骤 1：问题定义与设置**\n问题是在区间 $[0,1]$ 上求解 $-(a(x) u^{\\prime}(x))^{\\prime} = 0$。\n区域由节点 $x_0=0$、$x_1=\\frac{1}{3}$、$x_2=\\frac{2}{3}$ 和 $x_3=1$ 划分为三个单元。设 $h = \\frac{1}{3}$ 为均匀单元长度。\n这些单元是 $E_1 = [0, \\frac{1}{3}]$、$E_2 = [\\frac{1}{3}, \\frac{2}{3}]$ 和 $E_3 = [\\frac{2}{3}, 1]$。\n传导系数 $a(x)$ 是分段常数：在 $E_1$ 上 $a_1 = 2$，在 $E_2$ 上 $a_2 = 3$，在 $E_3$ 上 $a_3 = 5$。\n离散化使用标准连续分片线性 (P1) 基函数，记作 $\\varphi_i(x)$，其中 $\\varphi_i(x_j) = \\delta_{ij}$。基函数 $\\varphi_i'(x)$ 的导数是分段常数。在一个单元 $[x_{k-1}, x_k]$ 上，仅有的非零基函数导数对应于 $\\varphi_{k-1}$ 和 $\\varphi_k$。具体来说，在 $(x_{k-1}, x_k)$ 上：\n$\\varphi_{k-1}'(x) = -\\frac{1}{h} = -3$\n$\\varphi_k'(x) = \\frac{1}{h} = 3$\n\n**步骤 2：单元刚度矩阵**\n全局刚度矩阵 $K$ 的元素为 $K_{ij} = \\int_0^1 a(x) \\varphi_i^{\\prime}(x) \\varphi_j^{\\prime}(x)\\,dx$。我们可以通过单元刚度矩阵 $K^{(e)}$ 组装 $K$。对于一个长度为 $h_e$、传导系数为常数 $a_e$ 的通用单元，其单元刚度矩阵为\n$$K^{(e)} = \\frac{a_e}{h_e} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix}$$\n\n对于我们的问题，所有单元的长度均为 $h_e = h = \\frac{1}{3}$。\n单元 $1$ ($E_1=[0, \\frac{1}{3}]$, 节点 $0, 1$): $a_1 = 2$。\n$K^{(1)} = \\frac{2}{1/3} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix} = 6 \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix} = \\begin{pmatrix} 6  & -6 \\\\ -6  & 6 \\end{pmatrix}$。\n\n单元 $2$ ($E_2=[\\frac{1}{3}, \\frac{2}{3}]$, 节点 $1, 2$): $a_2 = 3$。\n$K^{(2)} = \\frac{3}{1/3} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix} = 9 \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix} = \\begin{pmatrix} 9  & -9 \\\\ -9  & 9 \\end{pmatrix}$。\n\n单元 $3$ ($E_3=[\\frac{2}{3}, 1]$, 节点 $2, 3$): $a_3 = 5$。\n$K^{(3)} = \\frac{5}{1/3} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix} = 15 \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix} = \\begin{pmatrix} 15  & -15 \\\\ -15  & 15 \\end{pmatrix}$。\n\n**步骤 3：全局刚度矩阵组装**\n$4 \\times 4$ 的全局刚度矩阵 $K$ 是通过将每个单元矩阵的贡献相加来组装的。\n$K_{00} = K^{(1)}_{11} = 6$\n$K_{01} = K^{(1)}_{12} = -6$\n$K_{11} = K^{(1)}_{22} + K^{(2)}_{11} = 6 + 9 = 15$\n$K_{12} = K^{(2)}_{12} = -9$\n$K_{22} = K^{(2)}_{22} + K^{(3)}_{11} = 9 + 15 = 24$\n$K_{23} = K^{(3)}_{12} = -15$\n$K_{33} = K^{(3)}_{22} = 15$\n根据对称性，$K_{ji}=K_{ij}$。所有其他元素均为零。\n该矩阵为：\n$$\nK = \\begin{pmatrix}\n6  & -6  & 0  & 0 \\\\\n-6  & 15  & -9  & 0 \\\\\n0  & -9  & 24  & -15 \\\\\n0  & 0  & -15  & 15\n\\end{pmatrix}\n$$\n\n**步骤 4：矩阵分块**\n自由度被划分为边界索引 $b = \\{0,3\\}$ 和内部索引 $i = \\{1,2\\}$。我们根据索引顺序 $(0,3,1,2)$ 重新排列矩阵，以获得分块形式\n$$\n\\tilde{K} = \\begin{pmatrix}\nK_{bb}  & K_{bi} \\\\\nK_{ib}  & K_{ii}\n\\end{pmatrix}\n$$\n从 $K$ 中提取各分块：\n$K_{bb} = \\begin{pmatrix} K_{00}  & K_{03} \\\\ K_{30}  & K_{33} \\end{pmatrix} = \\begin{pmatrix} 6  & 0 \\\\ 0  & 15 \\end{pmatrix}$\n$K_{bi} = \\begin{pmatrix} K_{01}  & K_{02} \\\\ K_{31}  & K_{32} \\end{pmatrix} = \\begin{pmatrix} -6  & 0 \\\\ 0  & -15 \\end{pmatrix}$\n$K_{ib} = \\begin{pmatrix} K_{10}  & K_{13} \\\\ K_{20}  & K_{23} \\end{pmatrix} = \\begin{pmatrix} -6  & 0 \\\\ 0  & -15 \\end{pmatrix}$\n$K_{ii} = \\begin{pmatrix} K_{11}  & K_{12} \\\\ K_{21}  & K_{22} \\end{pmatrix} = \\begin{pmatrix} 15  & -9 \\\\ -9  & 24 \\end{pmatrix}$\n注意 $K_{ib} = K_{bi}^T$，正如预期的那样。\n\n**步骤 5：舒尔补计算**\n舒尔补由公式 $S = K_{bb} - K_{bi} K_{ii}^{-1} K_{ib}$ 给出。\n首先，我们求 $K_{ii}$ 的逆矩阵。\n$\\det(K_{ii}) = (15)(24) - (-9)(-9) = 360 - 81 = 279$。\n逆矩阵为：\n$$\nK_{ii}^{-1} = \\frac{1}{\\det(K_{ii})} \\begin{pmatrix} 24  & 9 \\\\ 9  & 15 \\end{pmatrix} = \\frac{1}{279} \\begin{pmatrix} 24  & 9 \\\\ 9  & 15 \\end{pmatrix}\n$$\n接下来，我们计算乘积 $K_{bi} K_{ii}^{-1} K_{ib}$。\n$$\nK_{bi} K_{ii}^{-1} = \\begin{pmatrix} -6  & 0 \\\\ 0  & -15 \\end{pmatrix} \\frac{1}{279} \\begin{pmatrix} 24  & 9 \\\\ 9  & 15 \\end{pmatrix} = \\frac{1}{279} \\begin{pmatrix} -144  & -54 \\\\ -135  & -225 \\end{pmatrix}\n$$\n$$\n(K_{bi} K_{ii}^{-1}) K_{ib} = \\frac{1}{279} \\begin{pmatrix} -144  & -54 \\\\ -135  & -225 \\end{pmatrix} \\begin{pmatrix} -6  & 0 \\\\ 0  & -15 \\end{pmatrix} = \\frac{1}{279} \\begin{pmatrix} (-144)(-6)  & (-54)(-15) \\\\ (-135)(-6)  & (-225)(-15) \\end{pmatrix}\n$$\n计算所得矩阵乘积的元素：\n元素 $(1,1)$: $(-144)(-6) = 864$。\n元素 $(1,2)$: $(-54)(-15) = 810$。\n元素 $(2,1)$: $(-135)(-6) = 810$。\n元素 $(2,2)$: $(-225)(-15) = 3375$。\n所以，\n$$\nK_{bi} K_{ii}^{-1} K_{ib} = \\frac{1}{279} \\begin{pmatrix} 864  & 810 \\\\ 810  & 3375 \\end{pmatrix}\n$$\n现在，将此代入舒尔补公式中：\n$$\nS = K_{bb} - K_{bi} K_{ii}^{-1} K_{ib} = \\begin{pmatrix} 6  & 0 \\\\ 0  & 15 \\end{pmatrix} - \\frac{1}{279} \\begin{pmatrix} 864  & 810 \\\\ 810  & 3375 \\end{pmatrix}\n$$\n$$\nS = \\begin{pmatrix} 6 - \\frac{864}{279}  & -\\frac{810}{279} \\\\ -\\frac{810}{279}  & 15 - \\frac{3375}{279} \\end{pmatrix}\n$$\n\n**步骤 6：最终答案提取**\n问题要求的是连接节点 $x_0$ 和 $x_3$ 的非对角线元素。这对应于 $2 \\times 2$ 矩阵 $S$ 的第一行第二列的元素，其中行和列按索引 $(0,3)$ 排序。这是我们矩阵的 $S_{12}$ 元素。\n$$S_{12} = -\\frac{810}{279}$$\n为了化简分数，我们注意到分子和分母的数字之和都能被 $9$ 整除。\n$810 = 9 \\times 90$。\n$279 = 270 + 9 = 9 \\times 30 + 9 = 9 \\times 31$。\n$$S_{12} = -\\frac{9 \\times 90}{9 \\times 31} = -\\frac{90}{31}$$\n由于 $31$ 是一个质数，并且不是 $90$ 的因子，因此该分数为最简形式。\n为了完整起见，我们可以计算整个 $S$ 矩阵：\n$S_{11} = 6 - \\frac{864}{279} = 6 - \\frac{9 \\times 96}{9 \\times 31} = 6 - \\frac{96}{31} = \\frac{186 - 96}{31} = \\frac{90}{31}$。\n$S_{22} = 15 - \\frac{3375}{279} = 15 - \\frac{9 \\times 375}{9 \\times 31} = 15 - \\frac{375}{31} = \\frac{465 - 375}{31} = \\frac{90}{31}$。\n$S_{21} = -\\frac{810}{279} = -\\frac{90}{31}$。\n所以，$S = \\frac{90}{31} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix}$。\n所求的非对角线元素（第 1 行，第 2 列）确实是 $-\\frac{90}{31}$。", "answer": "$$\n\\boxed{-\\frac{90}{31}}\n$$", "id": "3437062"}, {"introduction": "在求解大规模有限元问题时，全局刚度矩阵的稀疏结构是决定计算效率的关键。直接求解器（如Cholesky分解）的性能，包括内存消耗和计算时间，很大程度上取决于矩阵的带宽（bandwidth）和分解过程中的填充（fill-in）。本练习[@problem_id:3437048]是一个编程实践，旨在通过对比不同节点编号策略——自然排序、逆Cuthill-McKee（RCM）排序和随机排序——来直观地展示矩阵重排序对带宽和填充的巨大影响，从而揭示优化稀疏线性系统求解的根本策略。", "problem": "考虑由齐次狄利克雷泊松问题的标准离散化产生的对称正定全局刚度矩阵。设 $\\Omega = (0,1) \\times (0,1)$，并考虑边值问题 $-\\Delta u = f$ in $\\Omega$，其中在 $\\partial \\Omega$ 上 $u=0$。用一个均匀的笛卡尔网格对 $\\Omega$ 进行离散化，该网格由 $m$ 行和 $n$ 列内部点组成，并对拉普拉斯算子使用标准的 $5$ 点模板（此离散化等价于在均匀网格上使用分片常数扩散的经典协调 $\\mathcal{P}_1$ 有限元方法所得到的双线性形式，并且由此产生的代数系统与 $5$ 点有限差分格式相同）。以字典序行主序对未知数进行索引，使得每个内部节点 $(i,j)$（其中 $i \\in \\{0,\\dots,m-1\\}$ 且 $j \\in \\{0,\\dots,n-1\\}$）映射到一个全局索引 $k = i n + j$。由此产生的全局刚度矩阵 $K \\in \\mathbb{R}^{N \\times N}$（其中 $N = m n$）的元素为 $K_{kk} = 4$，当节点 $k$ 和 $l$ 是网格上的直接 $4$-邻居（上、下、左、右）时，$K_{kl} = -1$，否则 $K_{kl} = 0$。该矩阵 $K$ 是对称且正定的。\n\n将索引 $\\{0,1,\\dots,N-1\\}$ 的一个置换（重排序）$\\pi$ 定义为一个双射。设 $P \\in \\mathbb{R}^{N \\times N}$ 是对应的置换矩阵，并考虑重排序后的矩阵 $K^\\pi = P K P^\\top$。$K^\\pi$ 的对称带宽定义为\n$$\nB(K^\\pi) = \\max_{\\substack{i,j \\in \\{0,\\dots,N-1\\} \\\\ K^\\pi_{ij} \\neq 0}} |i - j| + 1.\n$$\n考虑 Cholesky 分解 $K^\\pi = L L^\\top$，其中 $L$ 是一个对角线元素为正的下三角矩阵。将严格下三角填充定义为满足 $i > j$ 且 $L_{ij} \\neq 0$ 但 $K^\\pi_{ij} = 0$ 的位置 $(i,j)$ 的数量。在具体计算中，将绝对值小于一个很小阈值的元素视为数值上的零。\n\n从泊松问题的变分形式和离散双线性形式的协调性出发，推导并实现算法，以：\n- 为给定的整数 $m$ 和 $n$ 构建如上所述的全局刚度矩阵 $K$。\n- 构建 $K$ 的邻接图（忽略对角线上的自环），并利用图结构计算 Reverse Cuthill–McKee (RCM) 置换，记为 $\\pi_{\\mathrm{RCM}}$。\n- 应用给定的置換 $\\pi$ 以形成 $K^\\pi$。\n- 计算如上定义的 $B(K^\\pi)$。\n- 计算由 $K^\\pi$ 的 Cholesky 分解引起的严格下三角填充数。\n\n您的程序必须实现以下重排序选择：\n- \"natural\"：单位置换（不重排序），即 $\\pi(i) = i$。\n- \"rcm\"：从 $K$ 的邻接关系计算出的 Reverse Cuthill–McKee 置换。\n- \"random\"：使用固定种子 $42$ 计算的随机置换，以保证可复现性。\n\n在判断一个实值矩阵元素是否为零时，使用数值零阈值 $\\varepsilon = 10^{-12}$。\n\n测试套件：\n在以下各种情况下，计算重排序后刚度矩阵的完整对称带宽 $B(K^\\pi)$ 和严格下三角填充数：\n- 情况 1：$m=1$，$n=1$，排序 \"natural\"。\n- 情况 2：$m=4$，$n=4$，排序 \"natural\"。\n- 情况 3：$m=4$，$n=4$，排序 \"rcm\"。\n- 情况 4：$m=8$，$n=4$，排序 \"natural\"。\n- 情况 5：$m=8$，$n=4$，排序 \"rcm\"。\n- 情况 6：$m=10$，$n=10$，排序 \"rcm\"。\n- 情况 7：$m=10$，$n=10$，排序 \"random\"，种子为 $42$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，并用方括号括起来。每个测试用例的结果必须是一个二元列表 $[B, F]$，其中 $B$ 是完整对称带宽，$F$ 是严格下三角填充数。因此，最终输出必须如下所示：\n$$\n\\big[\\,[B_1,F_1], [B_2,F_2], \\dots, [B_7,F_7]\\,\\big].\n$$\n不得打印任何额外文本。", "solution": "用户提供的问题定义严谨且科学上合理，涉及求解偏微分方程的数值线性代数中的一个标准课题。所有参数、定义和任务都以足够的清晰度和精确度进行了规定，从而能够得出唯一且可验证的解。因此，该问题被认为是有效的。\n\n解决方案系统地执行了所需的任务：构建全局刚度矩阵、应用指定的置换以及计算结果矩阵的属性（带宽和 Cholesky 分解填充）。\n\n### 1. 全局刚度矩阵 $K$ 的构建\n\n问题考虑的是单位平方 $\\Omega = (0,1) \\times (0,1)$ 上带齐次狄利克雷边界条件的泊松方程 $-\\Delta u = f$。该区域通过一个均匀的笛卡尔网格离散化，该网格包含 $m$ 行和 $n$ 列内部节点。未知数的总数为 $N = mn$。未知数使用行主序的字典序进行索引，其中网格位置 $(i,j)$（对于 $i \\in \\{0, \\dots, m-1\\}$ 和 $j \\in \\{0, \\dots, n-1\\}$）的节点对应于单一全局索引 $k = i n + j$。\n\n负拉普拉斯算子 $-\\Delta u$ 在内部节点 $(x_{i,j}, y_{i,j})$ 处的标准 $5$ 点有限差分模板由下式给出：\n$$\n-\\Delta u \\approx \\frac{4 u_{i,j} - u_{i-1, j} - u_{i+1, j} - u_{i, j-1} - u_{i, j+1}}{h^2}\n$$\n其中 $h$ 是均匀的网格间距。忽略缩放因子 $1/h^2$，全局刚度矩阵 $K$ 中对应于内部节点 $k$ 的行，其对角线上为 $4$，而在对应其四个直接网格邻居的列中为 $-1$。具体来说，对于对应网格点 $(i,j)$ 的节点 $k$：\n- 对角线元素为 $K_{kk} = 4$。\n- 与右邻居 $(i, j+1)$（如果 $j  n-1$）的连接，其全局索引为 $l = i n + (j+1)$，导致 $K_{kl} = -1$。\n- 与下方邻居 $(i+1, j)$（如果 $i  m-1$）的连接，其全局索引为 $l' = (i+1)n + j$，导致 $K_{kl'} = -1$。\n\n由于算子的对称性，矩阵 $K$ 是对称的，即 $K_{lk} = K_{kl}$。所有其他非对角线元素均为 $0$。该矩阵通过遍历所有 $N$ 个节点并设置这些非零元素来构建。\n\n### 2. 矩阵重排序与置换\n\n对于稀疏矩阵 $K$，其诸如带宽和分解过程中的填充等属性取决于其行和列的排序。索引 $\\{0, \\dots, N-1\\}$ 的一个置换 $\\pi$ 定义了一个重排序。如果 $P$ 是与 $\\pi$ 相关联的置换矩阵，则重排序后的矩阵为 $K^\\pi = P K P^\\top$。在实现中，如果 $\\pi$ 是一个包含重排索引的数组，这对应于 Python 中的 `K[pi, :][:, pi]` 操作。\n\n问题要求分析三种排序：\n- **自然排序**：单位置换，$\\pi(i)=i$。这是基准的字典序排序。\n- **Reverse Cuthill–McKee (RCM) 排序**：一种著名的启发式算法，旨在减小稀疏矩阵的剖面或包络。较小的剖面通常会导致 Cholesky 等分解过程中的填充更少。该算法通过从矩阵邻接图的一个外围节点构建水平集，然后反转得到的排序来工作。我们使用 `scipy.sparse.csgraph.reverse_cuthill_mckee` 提供的标准实现。\n- **随机排序**：一种随机置换，此处用作对照，以展示破坏结构的排序的效果。预期它会产生较差的结果（大带宽和多填充）。\n\n### 3. 带宽和填充的计算\n\n为置换后的矩阵 $K^\\pi$ 计算两个度量。\n\n- **对称带宽**：问题将其定义为 $B(K^\\pi) = \\max_{i,j : K^\\pi_{ij} \\neq 0} |i - j| + 1$。这通过找到 $K^\\pi$ 的所有非零元素（超过数值阈值 $\\varepsilon = 10^{-12}$），计算其行和列索引的绝对差，并取这些差值的最大值加一来实现。\n\n- **严格下三角填充**：在 Cholesky 分解 $K^\\pi = LL^\\top$ 过程中，在因子 $L$ 中可能会在 $K^\\pi$ 为零的位置出现新的非零元素，称为“填充”。填充数就是这类位置的数量。它通过使用 `scipy.linalg.cholesky`对 $K^\\pi$ 执行 Cholesky 分解得到 $L$，然后计算满足 $i > j$ 且 $|L_{ij}|> \\varepsilon$ 但 $|K^\\pi_{ij}| \\le \\varepsilon$ 的配对 $(i,j)$ 的数量来计算。\n\n### 4. 算法流程\n\n解决方案包含一个主函数，该函数遍历指定的测试用例。对于每个用例 $(m, n, \\text{ordering})$：\n1. 使用自然排序构建 $mn \\times mn$ 的刚度矩阵 $K$。\n2. 根据指定的排序类型生成置换数组 $\\pi$。\n3. 应用置换得到 $K^\\pi = K[\\pi, :][:, \\pi]$。\n4. 计算带宽 $B(K^\\pi)$。\n5. 计算 $K^\\pi$ 的 Cholesky 因子 $L$。\n6. 通过比较 $K^\\pi$ 和 $L$ 的结构计算填充数 $F$。\n7. 存储配对 $[B, F]$ 并进行下一个用例。\n最后，将收集到的结果格式化为指定的字符串格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import reverse_cuthill_mckee\nfrom scipy.linalg import cholesky\n\ndef construct_stiffness_matrix(m, n):\n    \"\"\"\n    Constructs the global stiffness matrix K for an m x n grid.\n    \n    Args:\n        m (int): Number of rows of interior grid points.\n        n (int): Number of columns of interior grid points.\n        \n    Returns:\n        numpy.ndarray: The NxN global stiffness matrix, where N = m*n.\n    \"\"\"\n    N = m * n\n    if N == 0:\n        return np.array([[]])\n    \n    K = np.zeros((N, N), dtype=np.float64)\n    \n    for i in range(m):\n        for j in range(n):\n            k = i * n + j\n            \n            # Diagonal entry\n            K[k, k] = 4\n            \n            # Off-diagonal entries for 4-neighbors\n            # Right neighbor\n            if j  n - 1:\n                l = i * n + (j + 1)\n                K[k, l] = -1.0\n                K[l, k] = -1.0\n            \n            # Bottom neighbor\n            if i  m - 1:\n                l = (i + 1) * n + j\n                K[k, l] = -1.0\n                K[l, k] = -1.0\n                \n    return K\n\ndef compute_bandwidth(matrix, epsilon=1e-12):\n    \"\"\"\n    Computes the symmetric bandwidth of a matrix as per the problem definition.\n    B(A) = max |i-j| + 1 for A_ij != 0.\n    \n    Args:\n        matrix (numpy.ndarray): The input matrix.\n        epsilon (float): Threshold to consider an entry as non-zero.\n        \n    Returns:\n        int: The symmetric bandwidth.\n    \"\"\"\n    if matrix.shape[0] == 0:\n        return 0\n    if matrix.shape[0] == 1:\n        return 1\n\n    rows, cols = np.nonzero(np.abs(matrix) > epsilon)\n    \n    if rows.size == 0:\n        # This case won't be reached for SPD matrices of size > 0\n        return 1\n        \n    return np.max(np.abs(rows - cols)) + 1\n\ndef compute_fill_in(original_matrix, cholesky_factor, epsilon=1e-12):\n    \"\"\"\n    Computes the strictly lower-triangular fill-in count.\n    \n    Args:\n        original_matrix (numpy.ndarray): The permuted stiffness matrix K_pi.\n        cholesky_factor (numpy.ndarray): The lower triangular Cholesky factor L.\n        epsilon (float): Threshold for non-zero entries.\n        \n    Returns:\n        int: The number of fill-in entries.\n    \"\"\"\n    if original_matrix.shape[0] = 1:\n        return 0\n        \n    # Create masks for the strictly lower triangular part\n    k_pi_lower_is_zero = np.abs(np.tril(original_matrix, k=-1)) = epsilon\n    l_lower_is_nonzero = np.abs(np.tril(cholesky_factor, k=-1)) > epsilon\n    \n    fill_in_count = np.sum(np.logical_and(k_pi_lower_is_zero, l_lower_is_nonzero))\n    \n    return int(fill_in_count)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (m, n, ordering_type)\n        (1, 1, \"natural\"),\n        (4, 4, \"natural\"),\n        (4, 4, \"rcm\"),\n        (8, 4, \"natural\"),\n        (8, 4, \"rcm\"),\n        (10, 10, \"rcm\"),\n        (10, 10, \"random\"),\n    ]\n\n    epsilon = 1e-12\n    results = []\n\n    for m, n, ordering in test_cases:\n        N = m * n\n        K = construct_stiffness_matrix(m, n)\n\n        pi = None\n        if ordering == \"natural\":\n            pi = np.arange(N)\n        elif ordering == \"rcm\":\n            if N > 0:\n                # The CSR graph representation is needed for the RCM algorithm.\n                graph = csr_matrix(K)\n                pi = reverse_cuthill_mckee(graph)\n            else:\n                pi = np.array([], dtype=int)\n        elif ordering == \"random\":\n            rng = np.random.default_rng(seed=42)\n            pi = rng.permutation(N)\n\n        if N > 0:\n            # Apply the permutation to get the reordered matrix K_pi\n            K_pi = K[pi, :][:, pi]\n            \n            # Compute bandwidth\n            B = compute_bandwidth(K_pi, epsilon)\n            \n            # Compute Cholesky factorization and fill-in\n            # The matrix is SPD, so Cholesky factorization will succeed.\n            L = cholesky(K_pi, lower=True)\n            F = compute_fill_in(K_pi, L, epsilon)\n        else: # Should not happen with the given test cases\n            B, F = 0, 0\n            \n        results.append([B, F])\n\n    # Format the final output string exactly as required, without extra spaces.\n    formatted_results = [f\"[{b},{f}]\" for b, f in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3437048"}, {"introduction": "一个精确的数值模型不仅需要计算高效，更要能忠实地反映物理现象。在固体力学中，使用标准有限元方法模拟近不可压缩材料时，常会遇到“体积锁定”（volumetric locking）导致的伪刚度，而使用减缩积分又可能引入非物理的“沙漏模式”（hourglass modes）。这个编程练习[@problem_id:3599220]将带你探索选择性减缩积分（SRI）技术，它通过对材料本构的不同部分采用不同的积分规则，巧妙地解决了这一难题。通过计算和比较不同积分方案下刚度矩阵的最小特征值，你将深刻理解矩阵的谱性质如何直接关联到数值解的物理保真度。", "problem": "考虑一个三维小应变线性弹性固体，其占据了立方体域 $\\Omega = [0,1] \\times [0,1] \\times [0,1]$（单位为 $\\mathrm{m}^3$）。使用一个由 $2 \\times 2 \\times 2$ 个三线性八节点六面体单元（$H_8$）组成的均匀结构化网格对 $\\Omega$ 进行离散化。每个节点具有三个平移自由度。在整个面 $\\{(x,y,z) \\in \\Omega \\mid z = 0\\}$ 上施加齐次狄利克雷边界条件 $u_x = u_y = u_z = 0$，以消除刚体模态。假设材料为各向同性、齐次、线性弹性，其杨氏模量为 $E$（单位为 $\\mathrm{Pa}$），泊松比为 $\\nu$，拉梅参数为 $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$ 和 $\\mu = \\dfrac{E}{2(1+\\nu)}$。设 Voigt 记法下的本构张量为由 $\\lambda$ 和 $\\mu$ 构成的三维各向同性线性弹性的标准 $6 \\times 6$ 矩阵。使用小应变运动学。不施加任何体力或面力。\n\n从静态、无载荷构型的虚功原理出发，\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\mathbf{v}) \\, \\mathrm{d}\\Omega = 0,\n$$\n使用常规的有限元伽辽金离散化方法和 $H_8$ 形函数，组装全局刚度矩阵 $\\mathbf{K}$。选择性减缩积分（SRI, Selective Reduced Integration）策略将本构响应分解为体积部分和偏量部分，并使用不同的求积法则对它们进行积分，以缓解闭锁现象，同时避免伪零能模式（沙漏模式）。具体来说，对于单元刚度 $\\mathbf{K}^e$：\n- 偏量项必须使用每方向 $2$ 个点（$2 \\times 2 \\times 2$ 积分）的张量积高斯法则进行积分。\n- 体积项必须使用位于单元中心的单个积分点（单点积分）进行积分。\n\n作为参考和对比：\n- 完全积分（FI, Full Integration）在 $2 \\times 2 \\times 2$ 个高斯点上对完整的本构响应进行积分。\n- 减缩积分（RI, Reduced Integration）在单元中心的单个点（单点积分）上对完整的本构响应进行积分。\n\n在母单元域 $[-1,1]^3$ 上使用标准的等参 $H_8$ 形函数，并使用精确的等参映射到物理坐标。对于 $2 \\times 2 \\times 2$ 高斯法则，使用一维积分点 $\\{\\pm 1/\\sqrt{3}\\}$ 和权重 $1$，以张量积形式组合。对于单点法则，在每个方向上使用积分点 $0$ 和权重 $2$，以张量积形式组合。将网格视为单位立方体的均匀划分，因此所有单元映射都是矩形且对齐的。\n\n您的任务是编写一个完整的程序，该程序：\n- 构建单位立方体的 $H_8$ 网格，包含 $2 \\times 2 \\times 2$ 个单元，并组装全局刚度矩阵 $\\mathbf{K}$。\n- 通过消除相关行和列，在 $z=0$ 的面上施加齐次狄利克雷边界条件。\n- 针对下述参数集，在三种积分方案（FI、RI 和 SRI）下，计算对称半正定矩阵 $\\mathbf{K}$ 的 $k$ 个最小特征值（按升序排列）。特征值必须是施加边界条件后对降阶矩阵计算得到的，并以 $\\mathrm{N}/\\mathrm{m}$ 为单位报告。\n- 将特征值报告为浮点数。\n\n使用以下测试套件，其中 $k=6$ 且 $E = 10^5$（单位为 $\\mathrm{Pa}$）：\n- 情况 1：方案 FI，$\\nu = 0.3$。\n- 情况 2：方案 RI，$\\nu = 0.3$。\n- 情况 3：方案 SRI，$\\nu = 0.3$。\n- 情况 4：方案 FI，$\\nu = 0.4999$。\n- 情况 5：方案 SRI，$\\nu = 0.4999$。\n\n覆盖性设计：\n- 情况 2 应揭示由 $H_8$ 单元上的单点减缩积分引起的伪零特征值（沙漏模式）。\n- 情况 1 和 3 应没有沙漏模式，在施加边界条件后，其最小特征值应为严格正值。\n- 情况 4 和 5 比较了近不可压缩性时的行为，表明选择性减缩积分在不引入沙漏模式的情况下缓解了体积闭锁。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的 Python 风格的列表的列表。每个内部列表必须包含一个测试用例的 $k$ 个最小特征值（单位为 $\\mathrm{N}/\\mathrm{m}$），按升序排列，并四舍五入到 $6$ 位小数。五个内部列表的顺序必须与上述五个情况的顺序一致。例如，输出必须具有以下形式：\n$[ [e_{1,1}, e_{1,2}, e_{1,3}, e_{1,4}, e_{1,5}, e_{1,6}], [e_{2,1}, \\dots, e_{2,6}], \\dots, [e_{5,1}, \\dots, e_{5,6}] ]$\n所有内容都在单行上，其中 $e_{i,j}$ 表示情况 $i$ 的第 $j$ 个特征值。", "solution": "用户提供的问题被评估为**有效**。这是一个在计算固体力学领域中定义明确、有科学依据的问题，遵循了有限元法（FEM）的既定原则。该问题是自包含的，提供了所有必要的数据、边界条件和材料属性。目标明确，测试用例旨在说明已知的数值现象（体积闭锁和沙漏），这是一个标准的教学练习。\n\n### 基于原理的解决方案设计\n\n该解答基于三维线性弹性问题的有限元法（FEM）。过程始于虚功原理，对于无外部载荷的静态固体，其表述为：\n$$\n\\delta W = \\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\delta\\mathbf{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\mathbf{u}) \\, \\mathrm{d}\\Omega = 0\n$$\n其中 $\\mathbf{u}$ 是位移场，$\\delta\\mathbf{u}$ 是运动学上容许的虚位移场，$\\boldsymbol{\\varepsilon}$ 是小应变张量，$\\mathbb{C}$ 是四阶弹性张量，$\\Omega$ 是材料域。\n\n通过将域 $\\Omega = [0,1]^3 \\ \\mathrm{m}^3$ 划分为一个包含 $2 \\times 2 \\times 2 = 8$ 个三线性六面体单元（$H_8$）的网格，对这个连续弱形式进行离散化。在每个单元 $\\Omega_e$ 内，使用等参形函数 $N_i$ 和节点位移 $\\mathbf{d}^e$ 来近似位移场：\n$$\n\\mathbf{u}(\\boldsymbol{\\xi}) = \\sum_{i=1}^{8} N_i(\\boldsymbol{\\xi}) \\mathbf{u}_i\n$$\n其中 $\\boldsymbol{\\xi} = (\\xi, \\eta, \\zeta)$ 是母单元域 $[-1,1]^3$ 中的坐标。这种近似导出一个离散的应变-位移关系 $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}^e$，其中 $\\mathbf{B}$ 是应变-位移矩阵，它依赖于形函数的空间导数。\n\n将有限元近似代入虚功原理，并考虑任意节点虚位移 $\\delta\\mathbf{d}$，可得到离散线性方程组 $\\mathbf{K}\\mathbf{d} = \\mathbf{f}$。由于没有施加外力，该系统是齐次的，我们分析全局刚度矩阵 $\\mathbf{K}$ 的性质。矩阵 $\\mathbf{K}$ 由单元刚度矩阵 $\\mathbf{K}^e$ 组装而成：\n$$\n\\mathbf{K}^e = \\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{C} \\mathbf{B} \\, \\mathrm{d}\\Omega\n$$\n其中 $\\mathbf{C}$ 是 Voigt 记法下的本构矩阵。对于各向同性线性弹性，它由拉梅参数 $\\lambda$ 和 $\\mu$ 定义。该积分被转换到母单元域，并使用高斯求积进行数值计算：\n$$\n\\mathbf{K}^e = \\int_{-1}^{1}\\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{B}(\\boldsymbol{\\xi})^T \\mathbf{C} \\mathbf{B}(\\boldsymbol{\\xi}) \\det(\\mathbf{J}) \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta \\, \\mathrm{d}\\zeta \\approx \\sum_{g} w_g \\mathbf{B}(\\boldsymbol{\\xi}_g)^T \\mathbf{C} \\mathbf{B}(\\boldsymbol{\\xi}_g) \\det(\\mathbf{J}(\\boldsymbol{\\xi}_g))\n$$\n其中 $\\mathbf{J}$ 是从母单元坐标到物理坐标映射的雅可比矩阵，而 $w_g$ 和 $\\boldsymbol{\\xi}_g$ 分别是求积权重和点。对于给定的均匀网格，所有单元的 $\\det(\\mathbf{J})$ 都是常数。\n\n该问题要求在三种不同的数值积分方案下对刚度矩阵 $\\mathbf{K}$ 进行模态分析（计算特征值）：\n\n1.  **完全积分 (FI)**：$\\mathbf{K}^e$ 的积分使用 $2 \\times 2 \\times 2$ 高斯求积法则进行计算。对于矩形单元，该法则足以精确积分刚度矩阵并且是秩充足的，这意味着它不会引入非物理的零能模式。然而，对于近不可压缩材料（$\\nu \\to 0.5$），它可能导致“体积闭锁”，即单元响应的人为刚化。\n\n2.  **减缩积分 (RI)**：积分在单元中心 $(\\xi, \\eta, \\zeta)=(0,0,0)$ 使用单个高斯点进行计算。已知该方案可以缓解体积闭锁，但对于 $H_8$ 单元是秩亏的，会导致称为“沙漏模式”的伪零能模式。即使在约束了刚体运动后，这些模式在刚度矩阵中仍表现为近零的特征值。\n\n3.  **选择性减缩积分 (SRI)**：这种混合方法旨在结合 FI 和 RI 的优点。本构行为被分解为体积和偏量部分。同样的分解也适用于刚度矩阵：$\\mathbf{K}^e = \\mathbf{K}^e_{vol} + \\mathbf{K}^e_{dev}$。导致闭锁的刚性体积部分使用减缩（单点）法则积分，而偏量部分则使用完全积分（$2 \\times 2 \\times 2$ 法则）。这同时防止了闭锁并控制了沙漏模式。本构矩阵的分解为：\n    $$\n    \\mathbf{C} = \\mathbf{C}_{dev} + \\mathbf{C}_{vol}\n    $$\n    其中 $\\mathbf{C}_{vol} = K \\mathbf{m} \\mathbf{m}^T$，$K=\\lambda + \\frac{2}{3}\\mu$ 是体积模量，$\\mathbf{m} = [1, 1, 1, 0, 0, 0]^T$。单元刚度则为：\n    $$\n    \\mathbf{K}^e_{SRI} = \\left(\\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{C}_{dev} \\mathbf{B} \\, \\mathrm{d}\\Omega\\right)_{\\text{FI}} + \\left(\\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{C}_{vol} \\mathbf{B} \\, \\mathrm{d}\\Omega\\right)_{\\text{RI}}\n    $$\n\n全局刚度矩阵 $\\mathbf{K}$ 是通过对所有 8 个单元矩阵的贡献求和来组装的。齐次狄利克雷边界条件（$u_x = u_y = u_z = 0$）应用于 $z=0$ 的面。这是通过识别该面上的所有自由度（DOF）并从 $\\mathbf{K}$ 中移除相应的行和列以形成一个降阶的正定矩阵 $\\mathbf{K}_{red}$（RI 情况除外）来实现的。\n\n最后，对对称矩阵 $\\mathbf{K}_{red}$ 进行特征值分析。使用 `scipy.linalg.eigh` 计算 $k=6$ 个最小特征值，这些特征值对应于受约束结构的最软变形模式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef get_B_matrix(xi, eta, zeta, J_inv):\n    \"\"\"\n    Computes the strain-displacement matrix B for an H8 element at a given\n    point in parent coordinates.\n    J_inv is the inverse of the Jacobian matrix.\n    \"\"\"\n    # Parent coordinates of the 8 nodes of a standard H8 element\n    node_parent_coords = np.array([\n        [-1, -1, -1], [ 1, -1, -1], [ 1,  1, -1], [-1,  1, -1],\n        [-1, -1,  1], [ 1, -1,  1], [ 1,  1,  1], [-1,  1,  1]\n    ])\n\n    # Derivatives of shape functions w.r.t. parent coordinates (dNdxi)\n    dNdxi_eta_zeta = np.zeros((3, 8))\n    for i in range(8):\n        xi_i, eta_i, zeta_i = node_parent_coords[i]\n        dNdxi_eta_zeta[0, i] = 0.125 * xi_i * (1 + eta_i * eta) * (1 + zeta_i * zeta)\n        dNdxi_eta_zeta[1, i] = 0.125 * eta_i * (1 + xi_i * xi) * (1 + zeta_i * zeta)\n        dNdxi_eta_zeta[2, i] = 0.125 * zeta_i * (1 + xi_i * xi) * (1 + eta_i * eta)\n\n    # Derivatives of shape functions w.r.t. physical coordinates (dNdX)\n    dNdxyz = J_inv @ dNdxi_eta_zeta\n\n    # Assemble the B matrix (6x24)\n    B = np.zeros((6, 24))\n    for i in range(8):\n        dN_dx_i, dN_dy_i, dN_dz_i = dNdxyz[:, i]\n        B[0, 3*i    ] = dN_dx_i\n        B[1, 3*i + 1] = dN_dy_i\n        B[2, 3*i + 2] = dN_dz_i\n        B[3, 3*i    ] = dN_dy_i; B[3, 3*i + 1] = dN_dx_i\n        B[4, 3*i + 1] = dN_dz_i; B[4, 3*i + 2] = dN_dy_i\n        B[5, 3*i    ] = dN_dz_i; B[5, 3*i + 2] = dN_dx_i\n    return B\n\ndef calculate_element_stiffness(scheme, E, nu):\n    \"\"\"\n    Calculates the element stiffness matrix Ke for an H8 element based on the\n    integration scheme. All elements are identical cubes.\n    \"\"\"\n    h = 0.5  # Element side length\n    detJ = (h/2.0)**3\n    J_inv = np.diag([1.0 / (h / 2.0)] * 3)\n\n    # Material properties (Lamé parameters)\n    lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    mu = E / (2 * (1 + nu))\n\n    # Constitutive matrix C in Voigt notation\n    C = np.zeros((6, 6))\n    C[0, 0] = C[1, 1] = C[2, 2] = lmbda + 2 * mu\n    C[0, 1] = C[1, 0] = C[0, 2] = C[2, 0] = C[1, 2] = C[2, 1] = lmbda\n    C[3, 3] = C[4, 4] = C[5, 5] = mu\n    \n    Ke = np.zeros((24, 24))\n\n    if scheme == 'FI':\n        a = 1.0 / np.sqrt(3)\n        gps = [(x, y, z) for x in [-a, a] for y in [-a, a] for z in [-a, a]]\n        for xi, eta, zeta in gps:\n            B = get_B_matrix(xi, eta, zeta, J_inv)\n            Ke += B.T @ C @ B * 1.0 * detJ\n    elif scheme == 'RI':\n        B = get_B_matrix(0.0, 0.0, 0.0, J_inv)\n        Ke += B.T @ C @ B * 8.0 * detJ\n    elif scheme == 'SRI':\n        # Decompose C into deviatoric and volumetric parts\n        K_bulk = lmbda + 2.0/3.0 * mu\n        m = np.array([1, 1, 1, 0, 0, 0]).reshape(6, 1)\n        C_vol = K_bulk * (m @ m.T)\n        C_dev = C - C_vol\n\n        # Deviatoric part integrated with 2x2x2 rule\n        a = 1.0 / np.sqrt(3)\n        gps_dev = [(x, y, z) for x in [-a, a] for y in [-a, a] for z in [-a, a]]\n        for xi, eta, zeta in gps_dev:\n            B_dev = get_B_matrix(xi, eta, zeta, J_inv)\n            Ke += B_dev.T @ C_dev @ B_dev * 1.0 * detJ\n            \n        # Volumetric part integrated with 1-point rule\n        B_vol = get_B_matrix(0.0, 0.0, 0.0, J_inv)\n        Ke += B_vol.T @ C_vol @ B_vol * 8.0 * detJ\n    return Ke\n\ndef run_fem_analysis(scheme, E, nu, k):\n    \"\"\"\n    Runs the full FEM analysis: mesh, assembly, BCs, and eigenvalue solution.\n    \"\"\"\n    # Mesh properties\n    nx, ny, nz = 2, 2, 2\n    num_nodes_x, num_nodes_y, num_nodes_z = nx + 1, ny + 1, nz + 1\n    total_nodes = num_nodes_x * num_nodes_y * num_nodes_z\n    total_dofs = total_nodes * 3\n    \n    K_global = np.zeros((total_dofs, total_dofs))\n\n    # Pre-calculate the element stiffness matrix (all elements are identical)\n    Ke = calculate_element_stiffness(scheme, E, nu)\n\n    # Assemble the global stiffness matrix\n    for k_el in range(nz):\n        for j_el in range(ny):\n            for i_el in range(nx):\n                # Global node indices for this element\n                conn = np.array([\n                    (i_el)   + num_nodes_x*(j_el)   + num_nodes_x*num_nodes_y*(k_el),\n                    (i_el+1) + num_nodes_x*(j_el)   + num_nodes_x*num_nodes_y*(k_el),\n                    (i_el+1) + num_nodes_x*(j_el+1) + num_nodes_x*num_nodes_y*(k_el),\n                    (i_el)   + num_nodes_x*(j_el+1) + num_nodes_x*num_nodes_y*(k_el),\n                    (i_el)   + num_nodes_x*(j_el)   + num_nodes_x*num_nodes_y*(k_el+1),\n                    (i_el+1) + num_nodes_x*(j_el)   + num_nodes_x*num_nodes_y*(k_el+1),\n                    (i_el+1) + num_nodes_x*(j_el+1) + num_nodes_x*num_nodes_y*(k_el+1),\n                    (i_el)   + num_nodes_x*(j_el+1) + num_nodes_x*num_nodes_y*(k_el+1)\n                ], dtype=int)\n                \n                # Map element DOFs to global DOFs\n                dof_map = np.empty(24, dtype=int)\n                for i_node in range(8):\n                    dof_map[i_node*3 : i_node*3+3] = conn[i_node]*3 + np.arange(3)\n                \n                # Add element stiffness to global matrix\n                K_global[np.ix_(dof_map, dof_map)] += Ke\n\n    # Apply homogeneous Dirichlet boundary conditions on z=0 face\n    constrained_nodes = []\n    # k_node = 0 for the z=0 face\n    for j_node in range(num_nodes_y):\n        for i_node in range(num_nodes_x):\n            constrained_nodes.append(i_node + num_nodes_x * j_node)\n    \n    constrained_dofs = []\n    for node_idx in constrained_nodes:\n        constrained_dofs.extend([node_idx * 3, node_idx * 3 + 1, node_idx * 3 + 2])\n    \n    all_dofs = np.arange(total_dofs)\n    free_dofs = np.setdiff1d(all_dofs, constrained_dofs, assume_unique=True)\n    \n    K_reduced = K_global[np.ix_(free_dofs, free_dofs)]\n    \n    # Solve the eigenvalue problem for the k smallest eigenvalues\n    eigenvalues = eigh(K_reduced, eigvals_only=True, subset_by_index=[0, k-1])\n    \n    return eigenvalues\n\ndef solve():\n    test_cases = [\n        {'scheme': 'FI', 'nu': 0.3},\n        {'scheme': 'RI', 'nu': 0.3},\n        {'scheme': 'SRI', 'nu': 0.3},\n        {'scheme': 'FI', 'nu': 0.4999},\n        {'scheme': 'SRI', 'nu': 0.4999},\n    ]\n\n    E = 1e5\n    k = 6\n    \n    all_results = []\n    for case in test_cases:\n        eigenvalues = run_fem_analysis(case['scheme'], E, case['nu'], k)\n        rounded_eigs = [round(eig, 6) for eig in eigenvalues]\n        all_results.append(rounded_eigs)\n\n    # Format the output string to match the required format exactly\n    # repr() will create the string representation, then remove spaces\n    output_str = repr(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3599220"}]}