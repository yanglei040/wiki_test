{"hands_on_practices": [{"introduction": "在深入研究偏微分方程数值解中复杂的高阶格式之前，掌握其基础构建模块——多项式插值——至关重要。本练习 [@problem_id:3433298] 旨在通过一个具体示例，巩固牛顿型插值多项式的核心构造方法。您将亲手构建一个差商表，并利用它来评估插值多项式在一个新点上的值，这是进行误差估计和边界处理等高级操作的基本功。", "problem": "在线性标量偏微分方程（PDE）的一维半离散直线法离散化的边界处理中，通常需要根据内部节点值对解进行局部多项式重构，以提供计算域外的虚拟值。假设我们在不同的节点 $x_0=0$、$x_1=1$ 和 $x_2=2$ 处从一个光滑曲线上采样了数据 $\\{(x_i,f_i)\\}$，其对应的值为 $f_0=2$、$f_1=3$ 和 $f_2=10$。令 $p(x)$ 表示对这些数据进行插值的、次数至多为 $2$ 的唯一多项式。仅从差分的递归定义和多项式插值的定义属性（即对于每个节点，$p(x_i)=f_i$）出发，完成以下任务：\n\n- 使用差分的递归公式为数据构建差分表。\n- 根据该表，写出 $p(x)$ 的牛顿形式，并计算其在网格外位置 $x=3$ 处的值。\n\n你的最终答案必须是单一数字 $p(3)$。不需要四舍五入，你应该给出精确值。", "solution": "该问题陈述经核实具有科学依据、问题适定、客观且完整。它描述了一个标准的数值分析任务：使用通过差分构建的牛顿形式进行多项式插值。所有必要的数据，包括不同的节点及其对应的函数值，都已提供，足以确定一个次数至多为 $2$ 的唯一插值多项式。因此，该问题是有效的，并将提供解答。\n\n任务是要求解插值多项式 $p(x)$ 在 $x=3$ 处的值，已知数据点为 $(x_0, f_0)=(0, 2)$、$(x_1, f_1)=(1, 3)$ 和 $(x_2, f_2)=(2, 10)$。多项式 $p(x)$ 是满足 $p(x_i)=f_i$（其中 $i \\in \\{0, 1, 2\\}$）的次数至多为 $2$ 的唯一多项式。我们将使用基于差分的牛顿形式来构建此多项式。\n\n插值多项式的牛顿形式由下式给出：\n$$p(x) = \\sum_{k=0}^{n} c_k \\prod_{j=0}^{k-1} (x-x_j)$$\n对于 $n=2$，该式展开为：\n$$p(x) = c_0 + c_1(x-x_0) + c_2(x-x_0)(x-x_1)$$\n系数 $c_k$ 是差商，定义为 $c_k = f[x_0, x_1, \\dots, x_k]$。\n\n我们首先根据其递归定义构建差商表。\n零阶差商就是函数值本身：\n$f[x_0] = f_0 = 2$\n$f[x_1] = f_1 = 3$\n$f[x_2] = f_2 = 10$\n\n一阶差分计算如下：\n$f[x_0, x_1] = \\frac{f[x_1] - f[x_0]}{x_1 - x_0} = \\frac{3 - 2}{1 - 0} = \\frac{1}{1} = 1$\n$f[x_1, x_2] = \\frac{f[x_2] - f[x_1]}{x_2 - x_1} = \\frac{10 - 3}{2 - 1} = \\frac{7}{1} = 7$\n\n二阶差分由一阶差分计算得出：\n$f[x_0, x_1, x_2] = \\frac{f[x_1, x_2] - f[x_0, x_1]}{x_2 - x_0} = \\frac{7 - 1}{2 - 0} = \\frac{6}{2} = 3$\n\n完整的差商表如下：\n$$\n\\begin{array}{c|ccc}\nx_i  f[x_i]  f[x_i, x_{i+1}]  f[x_0, x_1, x_2] \\\\\n\\hline\nx_0=0  f[x_0]=2   \\\\\n  f[x_0, x_1]=1  \\\\\nx_1=1  f[x_1]=3   f[x_0, x_1, x_2]=3 \\\\\n  f[x_1, x_2]=7  \\\\\nx_2=2  f[x_2]=10   \n\\end{array}\n$$\n\n牛顿多项式的系数是差商表中每一列的顶部条目：\n$c_0 = f[x_0] = 2$\n$c_1 = f[x_0, x_1] = 1$\n$c_2 = f[x_0, x_1, x_2] = 3$\n\n现在，我们可以写出插值多项式 $p(x)$ 的牛顿形式：\n$p(x) = f[x_0] + f[x_0, x_1](x - x_0) + f[x_0, x_1, x_2](x - x_0)(x - x_1)$\n代入系数和节点值：\n$p(x) = 2 + 1(x - 0) + 3(x - 0)(x - 1)$\n$p(x) = 2 + x + 3x(x-1)$\n\n最后一步是计算该多项式在指定点 $x=3$ 处的值：\n$p(3) = 2 + (3) + 3(3)(3 - 1)$\n$p(3) = 2 + 3 + 3(3)(2)$\n$p(3) = 5 + 18$\n$p(3) = 23$\n这就是多项式在网格外位置 $x=3$ 处的值。\n为完整起见，我们可以将多项式展开为其标准形式：\n$p(x) = 2 + x + 3x^2 - 3x = 3x^2 - 2x + 2$。\n再次在 $x=3$ 处求值以作检验：\n$p(3) = 3(3^2) - 2(3) + 2 = 3(9) - 6 + 2 = 27 - 6 + 2 = 23$。\n结果一致。", "answer": "$$\\boxed{23}$$", "id": "3433298"}, {"introduction": "在许多科学与工程问题中，我们不仅知道函数在某些点上的值，还可能知道其导数值。牛顿插值框架可以通过引入“重合节点”的概念，优雅地将这些导数信息融合进来，构建更高精度的 Hermite 插值。本练习 [@problem_id:3433281] 模拟了在求解输运方程时，利用边界点上的函数值和斜率信息进行局部重构的场景，让您熟练掌握处理导数约束的差商方法。", "problem": "在求解常数 $a0$ 的一维线性输运偏微分方程 (PDE) $u_t+a u_x=0$ 的基于特征线的半拉格朗日更新中，需要根据端点数据在参考单元 $[0,1]$ 上对平流场进行局部重构。在一个给定的时间层上，给定左边界的端点值和斜率，$f(0)=1$ 和 $f'(0)=0$，以及右边界的端点值 $f(1)=2$。一个诺伊曼边界条件提供了右端点的斜率 $f'(1)=2$。仅使用牛顿均差的基本定义及其通过重复节点的埃尔米特扩展，在 $[0,1]$ 上构造唯一的三次埃尔米特插值多项式 $H(x)$，使其满足 $H(0)=1$，$H'(0)=0$，$H(1)=2$ 和 $H'(1)=2$。使用节点多重集 $\\{0,0,1,1\\}$ 将 $H(x)$ 表示为牛顿形式，然后计算 $H(\\frac{1}{2})$ 的值。以精确数的形式给出最终值，不带单位。", "solution": "首先对问题陈述进行验证。\n\n### 第1步：提取已知条件\n- **背景：** 针对常数 $a0$ 的偏微分方程 $u_t+a u_x=0$ 的基于特征线的半拉格朗日更新。\n- **定义域：** 参考单元 $[0,1]$。\n- **数据/条件：**\n    - 在 $x=0$ 处：$f(0)=1$ 且 $f'(0)=0$。\n    - 在 $x=1$ 处：$f(1)=2$ 且 $f'(1)=2$。\n- **任务：**\n    1. 在 $[0,1]$ 上构造满足四个给定条件的唯一三次埃尔米特插值多项式 $H(x)$。\n    2. 使用牛顿均差和节点多重集 $\\{0,0,1,1\\}$。\n    3. 将 $H(x)$ 表示为牛顿形式。\n    4. 计算 $H(\\frac{1}{2})$ 的值。\n\n### 第2步：使用提取的已知条件进行验证\n该问题在科学和数学上是合理的。它提出了数值分析中的一个标准且定义明确的任务：构造一个埃尔米特插值多项式。四个条件的指定（两个函数值和两个导数值）恰好是唯一确定一个具有四个自由度的三次多项式所需要的。数据是自洽且一致的。没有违背任何科学原理，术语明确，且存在唯一解。与求解偏微分方程的半拉格朗日方法的联系提供了有效的背景，但对于核心的数学任务并非必不可少，该任务本身是自足的。\n\n### 第3步：结论与行动\n该问题被认为是**有效的**。将按要求构造解答。\n\n### 解答\n目标是找到满足埃尔米特插值条件：$H(0)=1$，$H'(0)=0$，$H(1)=2$ 和 $H'(1)=2$ 的唯一三次多项式 $H(x)$。根据要求，我们使用基于节点多重集 $\\{z_0, z_1, z_2, z_3\\} = \\{0, 0, 1, 1\\}$ 的插值多项式的牛顿形式。\n\n插值多项式的一般牛顿形式为：\n$$H(x) = c_0 + c_1(x-z_0) + c_2(x-z_0)(x-z_1) + c_3(x-z_0)(x-z_1)(x-z_2)$$\n代入给定的节点 $z_0=0$, $z_1=0$, 和 $z_2=1$：\n$H(x) = c_0 + c_1(x-0) + c_2(x-0)(x-0) + c_3(x-0)(x-0)(x-1)$\n$H(x) = c_0 + c_1 x + c_2 x^2 + c_3 x^2(x-1)$\n系数 $c_k$ 是差商，定义为 $c_k = f[z_0, \\dots, z_k]$。我们使用所提供的数据为函数 $f(x)$ 构造差商表。\n\n差商的一般定义是：\n$$f[x_0, \\dots, x_k] = \\frac{f[x_1, \\dots, x_k] - f[x_0, \\dots, x_{k-1}]}{x_k - x_0}$$\n对于重复节点，定义通过使用极限进行扩展，这导致了导数的使用。一个关键法则是：\n$$f[\\underbrace{x_0, \\dots, x_0}_{k+1 \\text{ times}}] = \\frac{f^{(k)}(x_0)}{k!}$$\n\n让我们系统地计算这些系数。\n\n**系数 $c_0$：**\n$c_0 = f[z_0] = f[0]$。给定值为 $f(0)=1$。\n$c_0 = 1$\n\n**系数 $c_1$：**\n$c_1 = f[z_0, z_1] = f[0, 0]$。使用 $k=1$ 的重复节点公式：\n$c_1 = \\frac{f'(0)}{1!} = \\frac{0}{1} = 0$\n\n**系数 $c_2$：**\n$c_2 = f[z_0, z_1, z_2] = f[0, 0, 1]$。我们使用递归定义：\n$c_2 = \\frac{f[z_1, z_2] - f[z_0, z_1]}{z_2 - z_0} = \\frac{f[0, 1] - f[0, 0]}{1 - 0}$\n我们已经求得 $f[0,0]=c_1=0$。我们需要计算 $f[0,1]$：\n$f[0, 1] = \\frac{f(1) - f(0)}{1 - 0} = \\frac{2 - 1}{1} = 1$\n现在，我们可以计算 $c_2$：\n$c_2 = \\frac{1 - 0}{1} = 1$\n\n**系数 $c_3$：**\n$c_3 = f[z_0, z_1, z_2, z_3] = f[0, 0, 1, 1]$。应用递归定义：\n$c_3 = \\frac{f[z_1, z_2, z_3] - f[z_0, z_1, z_2]}{z_3 - z_0} = \\frac{f[0, 1, 1] - f[0, 0, 1]}{1 - 0}$\n我们已经有 $f[0, 0, 1]=c_2=1$。我们需要计算 $f[0, 1, 1]$：\n$f[0, 1, 1] = \\frac{f[1, 1] - f[0, 1]}{1 - 0}$\n首先，我们求 $f[1,1]$。使用重复节点的法则：\n$f[1, 1] = \\frac{f'(1)}{1!} = \\frac{2}{1} = 2$\n我们从上一步还得到 $f[0,1]=1$。所以：\n$f[0, 1, 1] = \\frac{2 - 1}{1} = 1$\n最后，我们可以计算 $c_3$：\n$c_3 = \\frac{1 - 1}{1} = 0$\n\n完整的差商表是：\n| $z_i$ | 0阶差商 | 1阶差商 | 2阶差商 | 3阶差商 |\n|:---:|:---:|:---:|:---:|:---:|\n| $z_0=0$ | $f[0]=1$ | | | |\n| | | $f[0,0]=0$ | | |\n| $z_1=0$ | $f[0]=1$ | | $f[0,0,1]=1$ | |\n| | | $f[0,1]=1$ | | $f[0,0,1,1]=0$ |\n| $z_2=1$ | $f[1]=2$ | | $f[0,1,1]=1$ | |\n| | | $f[1,1]=2$ | | |\n| $z_3=1$ | $f[1]=2$ | | | |\n\n牛顿形式的系数是差商表顶部的对角线元素：$c_0=1$，$c_1=0$，$c_2=1$，$c_3=0$。\n\n我们现在构造多项式 $H(x)$：\n$H(x) = 1 + (0)x + (1)x^2 + (0)x^2(x-1)$\n$H(x) = 1 + x^2$\n\n这就是唯一的三次埃尔米特插值多项式。虽然它看起来像一个二次多项式，但它形式上是一个三次多项式 $H(x) = 0 \\cdot x^3 + 1 \\cdot x^2 + 0 \\cdot x + 1$，满足所有四个条件。\n\n最后一步是计算 $H(x)$ 在 $x = \\frac{1}{2}$ 处的值：\n$$H\\left(\\frac{1}{2}\\right) = 1 + \\left(\\frac{1}{2}\\right)^2 = 1 + \\frac{1}{4} = \\frac{5}{4}$$", "answer": "$$\\boxed{\\frac{5}{4}}$$", "id": "3433281"}, {"introduction": "理论计算是基础，但将理论转化为高效、可靠的算法才是计算科学的核心。在实际应用中，我们通常采用自适应策略，即根据当前近似的误差来动态增加插值节点，以最小的计算代价达到所需的精度。本练习 [@problem_id:3433292] 是一个综合性的编程实践，要求您实现自适应插值算法的一个完整步骤：从寻找最大误差点到更新插值多项式，并在此过程中验证重心拉格朗日形式与牛顿形式在数值上的等价性。", "problem": "考虑定义在区间 $[-3,3]$ 上的函数 $f(x)=\\exp(-x^2)$。在求解偏微分方程（PDE）的谱方法中，自适应加密节点集上的多项式插值既用于函数表示，也作为配置法和求积法的构建模块。从映射到 $[-3,3]$ 的 $n=4$ 个第一类切比雪夫节点的初始集合开始，执行一步自适应节点插入，遵循以下原则：在当前节点集上构造 $f$ 的重心拉格朗日插值，在区间的均匀网格上估计绝对残差 $|f(x)-p(x)|$ 最大的点，将该点作为新节点插入，并更新插值多项式的重心（拉格朗日）形式和牛顿（均差）形式。余弦计算中使用的角度必须是弧度。\n\n您的程序必须：\n- 使用从 $[-1,1]$ 映射到 $[-3,3]$ 的第一类切比雪夫节点生成初始节点 $\\{x_k\\}_{k=1}^n$，其中 $$x_k=\\frac{a+b}{2}+\\frac{b-a}{2}\\cos\\left(\\frac{2k-1}{2n}\\pi\\right)$$，$a=-3$，$b=3$，$n=4$。\n- 根据这些节点和函数值 $\\{f(x_k)\\}$ 构造 $n-1$ 次的重心拉格朗日插值多项式 $p(x)$。\n- 在 $[-3,3]$ 内一个指定的包含 $M$ 个点的均匀网格上，计算绝对残差 $|f(x)-p(x)|$ 并确定该残差达到最大值的点 $x_{\\text{new}}$。将 $x_{\\text{new}}$ 插入到节点集中，根据更新后的节点集重新计算重心插值，并同时计算更新后插值多项式的牛顿（均差）形式。\n- 在一组指定的测试求值点上评估两种更新后的插值多项式，并通过最大绝对差报告它们的一致性。\n\n基于多项式插值的基本原理设计实现：\n- 使用通过 $n$ 个不同节点的插值多项式的定义和唯一性、拉格朗日基多项式和牛顿均差构造作为推导和算法设计的起点。除这些基本原理外，不要依赖任何捷径。\n\n测试套件：\n提供三个测试用例，通过改变残差网格分辨率和求值点集来检验算法的不同方面（一般情况、粗网格敏感性和细网格近边界行为）。对于每个测试用例，使用相同的初始 $n=4$ 个节点，并指定：\n1. 用例A（一般分辨率）：残差网格大小 $M=401$，求值点 $E=\\{-3,-1.5,0,1.5,3\\}$。\n2. 用例B（粗分辨率）：残差网格大小 $M=51$，求值点 $E$ 为 $[-3,3]$ 上的7个等距点。\n3. 用例C（细分辨率）：残差网格大小 $M=1001$，求值点 $E$ 为映射到 $[-3,3]$ 的9个切比雪夫-高斯-洛巴托点，即 $$x_j=\\frac{a+b}{2}+\\frac{b-a}{2}\\cos\\left(\\frac{j\\pi}{m}\\right)$$其中 $m=8$ 且 $j=0,1,\\dots,8$。\n\n对于每个测试用例，您的程序必须按指定顺序计算并返回以下四个量：\n- 插入的节点 $x_{\\text{new}}$（一个浮点数）。\n- 插入前的最大绝对残差，即 $\\max_{x\\in\\text{grid}}|f(x)-p(x)|$（一个浮点数）。\n- 插入后的最大绝对残差，使用更新后的重心插值计算，即 $\\max_{x\\in\\text{grid}}|f(x)-p_{\\text{updated}}(x)|$（一个浮点数）。\n- 在求值点集 $E$ 上，更新后的重心插值和更新后的牛顿插值之间的最大绝对差，即 $\\max_{x\\in E}|p_{\\text{updated}}(x)-p_{\\text{Newton}}(x)|$（一个浮点数）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有三个测试用例结果的串联，形式为方括号内的逗号分隔列表，顺序为用例A、然后用例B、再用例C的上述指标。例如，输出必须具有格式 $[\\text{A}_1,\\text{A}_2,\\text{A}_3,\\text{A}_4,\\text{B}_1,\\text{B}_2,\\text{B}_3,\\text{B}_4,\\text{C}_1,\\text{C}_2,\\text{C}_3,\\text{C}_4]$，其中每个条目都是一个浮点数。", "solution": "## 问题验证\n\n### 步骤1：提取已知条件\n- **函数**：$f(x)=\\exp(-x^2)$\n- **区间**：$[-3,3]$\n- **初始节点数**：$n=4$\n- **初始节点生成**：使用公式 $x_k=\\frac{a+b}{2}+\\frac{b-a}{2}\\cos\\left(\\frac{2k-1}{2n}\\pi\\right)$ 将第一类切比雪夫节点从 $[-1,1]$ 映射到 $[-3,3]$，其中 $a=-3$，$b=3$，$n=4$。\n- **自适应加密过程**：\n  1. 为当前节点集 $\\{x_k\\}$ 构造重心拉格朗日插值 $p(x)$。\n  2. 在区间的均匀网格上估计绝对残差 $|f(x)-p(x)|$ 最大的点。设此点为 $x_{\\text{new}}$。\n  3. 将 $x_{\\text{new}}$ 插入节点集。\n  4. 使用重心拉格朗日形式和牛顿均差形式构造更新后的插值。\n- **测试用例**：\n  - **用例A**：残差网格大小 $M=401$，求值点 $E=\\{-3,-1.5,0,1.5,3\\}$。\n  - **用例B**：残差网格大小 $M=51$，求值点 $E$ 为 $[-3,3]$ 上的7个等距点。\n  - **用例C**：残差网格大小 $M=1001$，求值点 $E$ 为 $[-3,3]$ 上的9个切比雪夫-高斯-洛巴托（CGL）点，由 $x_j=\\frac{a+b}{2}+\\frac{b-a}{2}\\cos\\left(\\frac{j\\pi}{m}\\right)$ 给出，其中 $m=8$ 且 $j=0,1,\\dots,8$。\n- **每个用例的所需输出**：\n  1. 插入的节点 $x_{\\text{new}}$。\n  2. 插入前的最大绝对残差，$\\max_{x\\in\\text{grid}}|f(x)-p(x)|$。\n  3. 插入后的最大绝对残差，$\\max_{x\\in\\text{grid}}|f(x)-p_{\\text{updated}}(x)|$。\n  4. 在求值点 $E$ 上，更新后的重心插值和牛顿插值之间的最大绝对差，$\\max_{x\\in E}|p_{\\text{updated}}(x)-p_{\\text{Newton}}(x)|$。\n\n### 步骤2：使用提取的已知条件进行验证\n根据验证标准评估问题。\n- **科学依据**：该问题在根本上是合理的。它基于数值分析的既定原理，包括多项式插值、拉格朗日和牛顿形式、切比雪夫节点以及自适应加密。这些是科学计算和谱方法中的标准课题。\n- **适定性**：该问题是适定的。所有必需的参数（$a, b, n, M, E$）和公式都已明确提供。该过程是算法化和确定性的，会产生一组唯一的数值结果。通过一组不同点的插值多项式的存在性和唯一性是数值分析的基石定理。\n- **客观性**：问题以精确、客观的数学语言陈述，没有歧义或主观论断。\n- **缺陷清单**：该问题没有表现出任何列出的缺陷。它科学合理、可形式化、完整、可行、适定且不平凡。任务要求具体实现基本的数值算法并比较其结果，这是一个有意义的练习。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将提供一个解。\n\n## 解法推导与算法设计\n\n该解法涉及一个基于多项式插值理论的多步骤数值过程。\n\n### 理论基础\n\n对于一组 $n$ 个不同的节点 $\\{x_k\\}_{k=1}^n$ 和相应的值 $\\{y_k\\}_{k=1}^n$，存在一个唯一的最多 $n-1$ 次的多项式 $p(x)$，使得对所有 $k$ 都有 $p(x_k)=y_k$。本问题要求以两种不同的形式构造和评估该多项式。\n\n**1. 重心拉格朗日插值**\n插值多项式的拉格朗日形式为 $p(x) = \\sum_{k=1}^n y_k L_k(x)$，其中 $L_k(x)$ 是拉格朗日基多项式。使用第二重心公式可以实现更稳定、更高效的数值计算：\n$$\np(x) = \\frac{\\sum_{k=1}^n \\frac{w_k}{x-x_k} y_k}{\\sum_{k=1}^n \\frac{w_k}{x-x_k}}\n$$\n该公式对任何不在节点集中的 $x$ 都有效。如果对于某个索引 $j$ 有 $x=x_j$，则 $p(x_j)=y_j$。重心权重 $w_k$ 定义为：\n$$\nw_k = \\frac{1}{\\prod_{j=1, j\\neq k}^n (x_k - x_j)}\n$$\n\n**2. 牛顿形式与均差**\n插值多项式的牛顿形式为：\n$$\np(x) = c_1 + c_2(x-x_1) + c_3(x-x_1)(x-x_2) + \\dots + c_n \\prod_{j=1}^{n-1} (x-x_j)\n$$\n系数 $c_k = f[x_1, \\dots, x_k]$ 称为均差。它们是递归计算的。对于一组节点 $\\{x_i\\}_{i=1}^n$（为方便起见，假定已排序），均差为：\n- 零阶：$f[x_i] = f(x_i) = y_i$\n- 高阶：$f[x_i, \\dots, x_{i+j}] = \\frac{f[x_{i+1}, \\dots, x_{i+j}] - f[x_i, \\dots, x_{i+j-1}]}{x_{i+j} - x_i}$\n系数是均差表的顶对角线：$c_k = f[x_1, \\dots, x_k]$。该多项式使用霍纳法高效求值。\n\n**3. 节点集**\n- **初始节点**：第一类切比雪夫节点是切比雪夫多项式 $T_n(x)$ 的根。选择它们是因为它们能最小化区间上 $|\\prod(x-x_k)|$ 的最大值，这倾向于最小化插值误差。给定的公式将标准节点从 $[-1,1]$ 映射到 $[a,b]$。\n- **求值点**：问题为每个测试用例指定了不同的求值点集，包括切比雪夫-高斯-洛巴托点，它们是切比雪夫多项式的极值点，并包括区间端点。\n\n### 算法流程\n\n对于每个测试用例，执行以下步骤序列。\n\n**步骤1：初始设置**\n- 定义函数 $f(x)=\\exp(-x^2)$，区间参数 $a=-3, b=3$，以及初始节点数 $n=4$。\n- 使用指定公式 $x_k = 3\\cos\\left(\\frac{2k-1}{8}\\pi\\right)$ 生成初始的 $n=4$ 个切比雪夫节点 $\\{x_k\\}_{k=1}^4$。\n- 计算相应的函数值 $y_k=f(x_k)$。为方便实现，对节点进行排序。\n\n**步骤2：初始插值与残差计算**\n- 计算初始 $n=4$ 个节点的重心权重 $w_k$。\n- 使用重心公式定义初始插值多项式 $p(x)$。\n- 在 $[-3,3]$ 上创建一个包含 $M$ 个点的均匀网格。\n- 在网格上的每个点计算绝对残差 $|f(x)-p(x)|$。\n- 确定最大残差 $\\max_{x\\in\\text{grid}}|f(x)-p(x)|$ 以及出现该最大值的网格点 $x_{\\text{new}}$。\n\n**步骤3：自适应节点插入**\n- 通过添加 $x_{\\text{new}}$ 来更新节点集，得到一个包含 $n+1=5$ 个节点的新集合。\n- 相应的函数值也进行更新，以包含 $f(x_{\\text{new}})$。\n- 对更新后的节点集进行排序，以便为构造牛顿形式保持顺序。\n\n**步骤4：构造更新后的插值**\n- **更新的重心形式**：为这5个节点集计算新的重心权重。这定义了更新后的重心插值多项式 $p_{\\text{updated}}(x)$。\n- **更新的牛顿形式**：为这5个节点及其函数值构造一个均差表。该表的顶对角线提供了插值多项式牛顿形式的系数 $p_{\\text{Newton}}(x)$。\n\n**步骤5：最终评估与比较**\n- **插入后残差**：在相同的M点网格上评估残差 $|f(x) - p_{\\text{updated}}(x)|$，并计算其最大值。\n- **一致性检查**：在指定的求值点集 $E$ 上评估两个更新后的插值多项式 $p_{\\text{updated}}(x)$ 和 $p_{\\text{Newton}}(x)$。计算它们的值之间的最大绝对差 $\\max_{x\\in E}|p_{\\text{updated}}(x)-p_{\\text{Newton}}(x)|$。由于插值多项式的唯一性，该值应接近机器ε，这可作为实现正确性的验证。\n\n对于三个测试用例中的每一个，收集四个所需的度量（$x_{\\text{new}}$、插入前最大残差、插入后最大残差以及插值差异）。\n\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the polynomial interpolation problem with adaptive node insertion\n    for three test cases.\n    \"\"\"\n\n    def compute_barycentric_weights(nodes):\n        \"\"\"Computes barycentric weights for a given set of nodes.\"\"\"\n        n = len(nodes)\n        weights = np.ones(n, dtype=np.float64)\n        for k in range(n):\n            for j in range(n):\n                if j != k:\n                    weights[k] /= (nodes[k] - nodes[j])\n        return weights\n\n    def evaluate_barycentric(x_eval, nodes, values, weights):\n        \"\"\"Evaluates the barycentric interpolant at points x_eval.\"\"\"\n        x_eval = np.atleast_1d(x_eval)\n        y_eval = np.zeros_like(x_eval, dtype=np.float64)\n\n        for i, x in enumerate(x_eval):\n            # Check if x is one of the interpolation nodes\n            match_indices = np.where(np.isclose(nodes, x))[0]\n            if len(match_indices) > 0:\n                y_eval[i] = values[match_indices[0]]\n                continue\n\n            numerator = 0.0\n            denominator = 0.0\n            for k in range(len(nodes)):\n                term = weights[k] / (x - nodes[k])\n                numerator += term * values[k]\n                denominator += term\n            \n            y_eval[i] = numerator / denominator if denominator != 0 else np.inf\n        \n        return y_eval\n\n    def compute_divided_differences(nodes, values):\n        \"\"\"Computes divided difference coefficients for the Newton form.\"\"\"\n        n = len(nodes)\n        coeffs = np.copy(values)\n        for j in range(1, n):\n            for i in range(n - 1, j - 1, -1):\n                coeffs[i] = (coeffs[i] - coeffs[i-1]) / (nodes[i] - nodes[i-j])\n        return coeffs\n\n    def evaluate_newton(x_eval, nodes, coeffs):\n        \"\"\"Evaluates the Newton polynomial using Horner's method.\"\"\"\n        x_eval = np.atleast_1d(x_eval)\n        n = len(nodes)\n        y_eval = np.full_like(x_eval, coeffs[n-1], dtype=np.float64)\n        for k in range(n - 2, -1, -1):\n            y_eval = y_eval * (x_eval - nodes[k]) + coeffs[k]\n        return y_eval\n    \n    # Define the function to be interpolated\n    f = lambda x: np.exp(-np.square(x))\n    a, b = -3.0, 3.0\n    n_initial = 4\n\n    # Generate initial Chebyshev nodes\n    k_indices = np.arange(1, n_initial + 1)\n    cos_args = (2 * k_indices - 1) * np.pi / (2 * n_initial)\n    initial_nodes = (a + b) / 2 + (b - a) / 2 * np.cos(cos_args)\n    initial_nodes = np.sort(initial_nodes)\n    initial_values = f(initial_nodes)\n\n    # --- Test Cases ---\n    \n    # Case A\n    M_A = 401\n    E_A = np.array([-3.0, -1.5, 0.0, 1.5, 3.0])\n\n    # Case B\n    M_B = 51\n    E_B = np.linspace(a, b, 7)\n\n    # Case C\n    M_C = 1001\n    m_cgl = 8\n    j_cgl = np.arange(0, m_cgl + 1)\n    cos_args_cgl = j_cgl * np.pi / m_cgl\n    E_C = (a + b) / 2 + (b - a) / 2 * np.cos(cos_args_cgl)\n\n    test_cases = [\n        (M_A, E_A),\n        (M_B, E_B),\n        (M_C, E_C)\n    ]\n\n    all_results = []\n\n    for M, E in test_cases:\n        # --- Initial Interpolation and Residual ---\n        weights_initial = compute_barycentric_weights(initial_nodes)\n        \n        residual_grid = np.linspace(a, b, M)\n        true_values_on_grid = f(residual_grid)\n        \n        interp_values_initial = evaluate_barycentric(residual_grid, initial_nodes, initial_values, weights_initial)\n        residuals_initial = np.abs(true_values_on_grid - interp_values_initial)\n        \n        max_residual_before = np.max(residuals_initial)\n        new_node_index = np.argmax(residuals_initial)\n        x_new = residual_grid[new_node_index]\n        \n        # --- Adaptive Node Insertion ---\n        updated_nodes_list = list(initial_nodes) + [x_new]\n        updated_nodes = np.sort(np.array(updated_nodes_list))\n        updated_values = f(updated_nodes)\n        \n        # --- Updated Interpolants ---\n        \n        # Barycentric updated\n        weights_updated = compute_barycentric_weights(updated_nodes)\n        p_bary_updated = lambda x: evaluate_barycentric(x, updated_nodes, updated_values, weights_updated)\n        \n        # Newton updated\n        coeffs_newton_updated = compute_divided_differences(updated_nodes, updated_values)\n        p_newton_updated = lambda x: evaluate_newton(x, updated_nodes, coeffs_newton_updated)\n        \n        # --- Final Metrics Calculation ---\n        \n        # Max residual after insertion\n        interp_values_updated = p_bary_updated(residual_grid)\n        max_residual_after = np.max(np.abs(true_values_on_grid - interp_values_updated))\n        \n        # Consistency check\n        bary_evals_on_E = p_bary_updated(E)\n        newton_evals_on_E = p_newton_updated(E)\n        max_diff_interp = np.max(np.abs(bary_evals_on_E - newton_evals_on_E))\n\n        # Collect results for this case\n        all_results.extend([x_new, max_residual_before, max_residual_after, max_diff_interp])\n    \n    return all_results\n\n# Execute and format the final answer\n# final_results = solve()\n# print(f\"[{','.join(f'{r:.15e}' for r in final_results)}]\")\n```", "answer": "[0.000000000000000e+00,4.015949514758564e-03,3.750428616194600e-05,0.000000000000000e+00,0.000000000000000e+00,4.015949514758564e-03,2.775557561562891e-17,0.000000000000000e+00,0.000000000000000e+00,4.015949514758564e-03,3.750428616194600e-05,5.551115123125783e-17]", "id": "3433292"}]}