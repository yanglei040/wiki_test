{"hands_on_practices": [{"introduction": "在写下哈密顿量之前，我们需要一个明确定义的希尔伯特空间，并有能力在其中表示关键的算符。这项实践聚焦于这个基本步骤，指导你构建一个多玻色子基矢，并构造总角动量算符 $J^2$ [@problem_id:3576636]。掌握这个过程至关重要，因为它让你能够确定模型空间中具有特定角动量（如 $J=0$）的态的数量，这是对核结构进行分类的基础。", "problem": "您正在实现一个用于相互作用玻色子模型 (IBM) 哈密顿量的数值程序，该程序作用于仅由 $d$ 玻色子张成的子空间。每个 $d$ 玻色子携带单玻色子角动量 $l=2$，其磁亚态为 $m \\in \\{-2,-1,0,1,2\\}$。对于固定的玻色子数 $N$，多玻色子希尔伯特空间是单玻色子空间的 $N$ 重张量积的完全对称子空间。您的任务是通过构建二次量子化形式的总角动量算符，来构造该空间的 $J$ 耦合内容，并计算选定 $N$ 值下总角动量 $J=0$ 的简并度（线性无关态的数量）。\n\n从以下基础开始：\n- 玻色子产生和湮灭算符 $b^\\dagger_m$ 和 $b_m$ 满足正则对易关系 $[b_m, b^\\dagger_{m'}] = \\delta_{m m'}$ 和 $[b_m, b_{m'}] = [b^\\dagger_m, b^\\dagger_{m'}] = 0$。\n- 对于 $l=2$，单粒子角动量算符在 $m$ 基矢上的表示为\n  $J_z \\ket{m} = m \\ket{m}$，$J_+ \\ket{m} = \\sqrt{l(l+1) - m(m+1)} \\ket{m+1}$，以及 $J_- \\ket{m} = \\sqrt{l(l+1) - m(m-1)} \\ket{m-1}$，其中 $l=2$ 且 $m \\in \\{-2,-1,0,1,2\\}$。\n- 在二次量子化中，多体总角动量生成元为\n  $$J_z = \\sum_{m=-2}^{2} m \\, b^\\dagger_m b_m, \\quad J_+ = \\sum_{m=-2}^{1} \\sqrt{l(l+1) - m(m+1)} \\, b^\\dagger_{m+1} b_m, \\quad J_- = J_+^\\dagger.$$\n- 卡西米尔算符可构造为\n  $$J^2 = J_- J_+ + J_z(J_z + \\mathbb{1}).$$\n  其本征值为 $J(J+1)$，其中 $J \\ge 0$ 为整数，而 $J=0$ 的简并度等于零本征值的数量。\n\n实现以下步骤：\n1. 在 $m$ 表象下，将固定的 $N$ 玻色子福克基矢构造为整数占据数元组 $(n_{-2}, n_{-1}, n_{0}, n_{1}, n_{2})$，其中 $\\sum_m n_m = N$。这自动保证了完全的玻色子对称性。\n2. 在此基矢上，利用玻色子作用 $b^\\dagger_p b_q \\ket{\\{n_m\\}} = \\sqrt{n_q} \\sqrt{n_p + 1} \\ket{\\{n_m + \\delta_{m p} - \\delta_{m q}\\}}$ 以及上述为 $l=2$ 指定的系数，构建 $J_z$、$J_+$ 和 $J_-$ 的稠密矩阵表示。\n3. 组装 $J^2$ 并将其对角化，以获得固定 $N$ 的希尔伯特空间上的所有本征值。根据这些本征值，计算 $J=0$ 态的数量，即在指定数值容差 $\\varepsilon$ 内等于 $0$ 的本征值个数。\n4. 使用严格的容差 $\\varepsilon = 10^{-8}$ 来判断一个本征值是否对应于 $J=0$；即，统计那些满足 $|\\lambda| < \\varepsilon$ 的 $\\lambda$。\n\n您必须编写一个单一程序，对下文给出的每个测试值 $N$，计算完全对称的 $N$-$d$-玻色子希尔伯特空间中 $J=0$ 的整数简并度。\n\n测试集（涵盖边界、典型和边缘情况）：\n- $N = 0$（边界情况，真空态），\n- $N = 1$（单个 $d$ 玻色子），\n- $N = 2$（对耦合），\n- $N = 3$（奇数个 $d$ 玻色子），\n- $N = 4$（本任务的主要目标），\n- $N = 5$（奇数，更大的空间）。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表顺序与上述测试集相同。例如，打印一行形如 $[r_0,r_1,r_2,r_3,r_4,r_5]$ 的内容，其中每个 $r_i$ 是对应 $N$ 的整数计数。\n- 此问题不涉及单位。\n- 角度（如果存在）已内含在表示论中，不需要明确的单位。\n\n重要约束：\n- 该实现必须是自包含的，不需要用户输入，并且在判断 $J=0$ 简并度时必须遵守指定的数值容差 $\\varepsilon = 10^{-8}$。\n- 程序必须为每个指定的 $N$ 构建并对角化 $J^2$，并将结果汇总为指定的单行输出。", "solution": "该问题要求计算一个由 $N$ 个相互作用的 $d$ 玻色子组成的系统中，总角动量 $J=0$ 态的简并度。每个 $d$ 玻色子具有内禀角动量 $l=2$。计算是针对指定的 $N$ 值进行的。其方法涉及在固定的 $N$ 玻色子希尔伯特空间内，构建并对角化总角动量平方算符 $J^2$ 的矩阵表示。\n\n**1. 希尔伯特空间构建**\n该系统由 $N$ 个全同玻色子组成，每个玻色子可以占据由 $m \\in \\{-2, -1, 0, 1, 2\\}$ 标记的 $2l+1 = 5$ 个磁亚态之一。对于固定的玻色子数 $N$，多体希尔伯特空间由一组福克态张成，这组福克态也称为 $m$ 表象基矢。这些态由占据数矢量 $\\ket{\\psi_i} = \\ket{n_{-2}, n_{-1}, n_0, n_1, n_2}$ 表示，其中 $n_m$ 是亚态 $m$ 中的整数玻色子数。玻色子所要求的完全对称性，已由该表示内在地满足。占据数必须满足约束条件 $\\sum_{m=-2}^{2} n_m = N$。\n\n该希尔伯特空间的维度由将 $N$ 个相同物品放入 $5$ 个可区分的箱子中的方式数给出，即 $\\dim(N) = \\binom{N+5-1}{5-1} = \\binom{N+4}{4}$。对于测试集中的每个 $N$ 值，我们首先生成所有可能的唯一占据数元组。这些基矢态被存储起来，并创建一个从每个元组到唯一整数索引 $i \\in \\{0, 1, \\dots, \\dim(N)-1\\}$ 的映射，以便高效地构建矩阵。\n\n**2. 角动量算符矩阵**\n我们在生成的基矢上构建总角动量算符的矩阵表示。这些算符以二次量子化形式表示。\n\n**2.1. $J_z$ 算符**\n总角动量的 $z$ 分量由 $J_z = \\sum_{m=-2}^{2} m \\, b^\\dagger_m b_m$ 给出，其中 $b^\\dagger_m b_m = \\hat{n}_m$ 是亚态 $m$ 的粒子数算符。作用于基矢态 $\\ket{\\{n_k\\}}$，我们有：\n$$J_z \\ket{\\{n_k\\}} = \\left( \\sum_{m=-2}^{2} m n_m \\right) \\ket{\\{n_k\\}}$$\n这表明 $J_z$ 在 $m$ 表象基矢中是对角的。其矩阵表示 $\\mathbf{J}_z$ 是一个对角矩阵，其中元素 $(\\mathbf{J}_z)_{ii}$ 是对应于第 $i$ 个基矢态 $\\ket{\\psi_i} = \\ket{\\{n_m^{(i)}\\}}$ 的本征值 $\\sum_m m n_m^{(i)}$。\n\n**2.2. $J_+$ 和 $J_-$ 算符**\n升算符 $J_+$ 定义为 $J_+ = \\sum_{m=-2}^{1} \\sqrt{l(l+1) - m(m+1)} \\, b^\\dagger_{m+1} b_m$。当 $l=2$ 时，这变为：\n$$J_+ = \\sum_{m=-2}^{1} \\sqrt{6 - m(m+1)} \\, b^\\dagger_{m+1} b_m$$\n算符 $b^\\dagger_{m+1} b_m$ 在态 $m$ 中湮灭一个玻色子，并在态 $m+1$ 中产生一个玻色子。它作用在基矢态 $\\ket{\\{n_k\\}}$ 上的结果由下式给出：\n$$b^\\dagger_{m+1} b_m \\ket{\\{n_k\\}} = \\sqrt{n_m} \\sqrt{n_{m+1}+1} \\ket{\\{n_k' \\}}$$\n其中 $\\ket{\\{n_k'\\}}$ 是将一个玻色子从亚态 $m$ 移动到 $m+1$ 后的态。一个矩阵元 $(\\mathbf{J}_+)_{ij}$ 非零，当且仅当态 $\\ket{\\psi_i}$ 可以通过 $J_+$ 的求和式中某一项的作用从态 $\\ket{\\psi_j}$ 得到。具体来说，如果 $\\ket{\\psi_i}$ 是将 $\\ket{\\psi_j}$ 中的一个玻色子从亚态 $m$ 移动到 $m+1$ 所得到的态，则矩阵元为：\n$$(\\mathbf{J}_+)_{ij} = \\sqrt{6-m(m+1)} \\sqrt{n_m^{(j)}} \\sqrt{n_{m+1}^{(j)}+1}$$\n降算符是厄米共轭，$J_- = J_+^\\dagger$。因此，其矩阵表示是 $\\mathbf{J}_+$ 的共轭转置。由于所有系数都是实数，所以 $\\mathbf{J}_- = \\mathbf{J}_+^T$。\n\n**3. 卡西米尔算符与对角化**\n总角动量平方算符 $J^2$ 通过关系式 $J^2 = J_- J_+ + J_z(J_z + \\mathbb{1})$ 构建。以矩阵形式，这可转换为：\n$$\\mathbf{J}^2 = \\mathbf{J}_- \\mathbf{J}_+ + \\mathbf{J}_z (\\mathbf{J}_z + \\mathbf{I})$$\n其中 $\\mathbf{I}$ 是单位矩阵。得到的矩阵 $\\mathbf{J}^2$ 是实对称的，因此是厄米的。我们通过数值对角化计算其本征值 $\\{\\lambda_k\\}$。$J^2$ 算符的本征值形式为 $J(J+1)$，其中 $J$ 是一个非负整数，代表总角动量量子数。\n\n**4. $J=0$ 的简并度**\n一个总角动量为 $J=0$ 的态是 $J^2$ 算符的本征态，其本征值为 $0(0+1)=0$。因此，要找到线性无关的 $J=0$ 态的数量，我们需要计算 $\\mathbf{J}^2$ 矩阵的零本征值的简并度。由于浮点数运算的限制，如果一个计算出的本征值 $\\lambda_k$ 落在指定的数值容差 $\\varepsilon$ 内，则认为它为零。根据问题陈述，我们统计满足 $|\\lambda_k| < \\varepsilon$ 的本征值数量，其中 $\\varepsilon = 10^{-8}$。\n\n**5. 算法摘要**\n对每个测试值 $N \\in \\{0, 1, 2, 3, 4, 5\\}$ 执行完整的流程：\n1. 生成 $N$-玻色子态的基矢以及态到索引的映射。\n2. 初始化大小为 $\\dim(N) \\times \\dim(N)$ 的矩阵 $\\mathbf{J}_z$、$\\mathbf{J}_+$ 和 $\\mathbf{J}_-$，并用零填充。\n3. 通过遍历每个基矢态并应用算符定义来填充矩阵 $\\mathbf{J}_z$ 和 $\\mathbf{J}_+$。\n4. 构建 $\\mathbf{J}_- = \\mathbf{J}_+^T$。\n5. 组装卡西米尔矩阵 $\\mathbf{J}^2 = \\mathbf{J}_- \\mathbf{J}_+ + \\mathbf{J}_z^2 + \\mathbf{J}_z$。\n6. 对角化 $\\mathbf{J}^2$ 以找到其本征值。\n7. 统计绝对值小于 $10^{-8}$ 的本征值数量。\n收集最终的计数并以指定的列表格式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigvalsh\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the specified test cases.\n    It computes the multiplicity of J=0 states for N d-bosons and prints the result.\n    \"\"\"\n    test_cases_N = [0, 1, 2, 3, 4, 5]\n    tolerance = 1e-8\n    results = []\n    \n    for n_bosons in test_cases_N:\n        multiplicity = calculate_j0_multiplicity(n_bosons, tolerance)\n        results.append(multiplicity)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_basis(n_bosons, num_levels):\n    \"\"\"\n    Recursively generates the basis of occupation number states.\n    A state is a tuple (n_0, n_1, ..., n_{k-1}) where sum(n_i) = n_bosons.\n    \"\"\"\n    if num_levels == 1:\n        return [(n_bosons,)]\n    \n    basis = []\n    for n_k in range(n_bosons + 1):\n        sub_basis = generate_basis(n_bosons - n_k, num_levels - 1)\n        for sub_state in sub_basis:\n            basis.append((n_k,) + sub_state)\n            \n    return basis\n\ndef calculate_j0_multiplicity(n_bosons, tolerance):\n    \"\"\"\n    Calculates the multiplicity of J=0 states for a system of N d-bosons.\n    \n    Args:\n        n_bosons (int): The number of bosons, N.\n        tolerance (float): The numerical tolerance to identify zero eigenvalues.\n        \n    Returns:\n        int: The number of J=0 states.\n    \"\"\"\n    # For d-bosons, l=2, so there are 2l+1=5 magnetic substates.\n    l_boson = 2\n    num_m_levels = 2 * l_boson + 1\n    m_values = np.arange(-l_boson, l_boson + 1)\n    \n    if n_bosons == 0:\n        # The vacuum state is a single J=0 state.\n        return 1\n        \n    basis = generate_basis(n_bosons, num_m_levels)\n    dim = len(basis)\n    state_to_index = {state: i for i, state in enumerate(basis)}\n    \n    j_z = np.zeros((dim, dim))\n    j_plus = np.zeros((dim, dim))\n    \n    # Coefficients for J_+, sqrt(l(l+1) - m(m+1)) for m = -2, -1, 0, 1\n    j_plus_coeffs = [np.sqrt(l_boson*(l_boson+1) - m*(m+1)) for m in m_values[:-1]]\n    \n    for j, source_state_tuple in enumerate(basis):\n        source_state_occs = np.array(source_state_tuple)\n        \n        # 1. Construct J_z (diagonal)\n        mz = np.sum(m_values * source_state_occs)\n        j_z[j, j] = mz\n        \n        # 2. Construct J_+ (off-diagonal)\n        # J_+ = sum_{m=-2..1} c_m b_{m+1}^+ b_m\n        for m_idx, m in enumerate(m_values[:-1]):\n            # State m is at index m_idx. State m+1 is at m_idx+1.\n            n_m = source_state_occs[m_idx]\n            if n_m == 0:\n                continue\n            \n            n_mp1 = source_state_occs[m_idx + 1]\n            \n            # Action of creation/annihilation operators\n            op_coeff = np.sqrt(n_m) * np.sqrt(n_mp1 + 1)\n            \n            # Full coefficient for the m-th term in J_+\n            total_coeff = j_plus_coeffs[m_idx] * op_coeff\n            \n            # Determine the target state\n            target_state_occs = list(source_state_occs)\n            target_state_occs[m_idx] -= 1\n            target_state_occs[m_idx + 1] += 1\n            target_state_tuple = tuple(target_state_occs)\n            \n            i = state_to_index[target_state_tuple]\n            j_plus[i, j] += total_coeff\n            \n    # 3. Construct J_- and J^2\n    j_minus = j_plus.T\n    j2 = j_minus @ j_plus + j_z @ (j_z + np.identity(dim))\n    \n    # 4. Diagonalize J^2 and get eigenvalues\n    eigenvalues = eigvalsh(j2)\n    \n    # 5. Count eigenvalues close to zero\n    j0_multiplicity = np.sum(np.isclose(eigenvalues, 0.0, atol=tolerance))\n    \n    return int(j0_multiplicity)\n\nsolve()\n```", "id": "3576636"}, {"introduction": "基矢确定后，下一步是构建哈密顿量矩阵。一个常见的错误来源是矩阵元的错误实现，而这项实践介绍了一种超越简单代码检查的强大验证方法。通过将构造出的哈密顿量矩阵的数值迹（对角元素之和）与一个推导出的解析迹公式进行比较，你可以对你的实现进行一次稳健的、整体性的检验 [@problem_id:3576640]。", "problem": "考虑最简单的 $sd$-玻色子空间中的相互作用玻色子模型 (IBM)，该空间包含一个角动量为 $L=0$ 的标量玻色子模 $s$ 和五个 $m \\in \\{-2,-1,0,1,2\\}$ 的四极玻色子模 $d_{m}$。设玻色子总数固定为 $N \\in \\mathbb{Z}_{\\ge 0}$。在粒子数守恒的 $m$-表象占据数基中进行计算，该基的维数为 $D = \\binom{N+K-1}{K-1}$，其中单玻色子模的数量为 $K=6$。一个基矢由非负占据数矢量 $\\mathbf{n}=(n_s,n_{-2},n_{-1},n_0,n_{1},n_2)$ 指定，其中 $\\sum_{\\mu} n_{\\mu} = N$，对应的右矢为 $\\lvert \\mathbf{n} \\rangle = \\lvert n_s; n_{-2},n_{-1},n_0,n_1,n_2\\rangle$。\n\n对于不同的模 $\\mu,\\nu \\in \\{s,-2,-1,0,1,2\\}$，玻色子产生和湮灭算符满足正则对易关系：\n- $[b_{\\mu},b_{\\nu}^{\\dagger}] = \\delta_{\\mu\\nu}$ 且 $[b_{\\mu},b_{\\nu}]=[b_{\\mu}^{\\dagger},b_{\\nu}^{\\dagger}]=0$，\n- 数算符 $n_{\\mu} = b_{\\mu}^{\\dagger} b_{\\mu}$ 的作用为 $n_{\\mu} \\lvert \\dots, n_{\\mu},\\dots \\rangle = n_{\\mu} \\lvert \\dots, n_{\\mu},\\dots \\rangle$，\n- 升降作用为 $b_{\\mu} \\lvert \\dots,n_{\\mu},\\dots \\rangle = \\sqrt{n_{\\mu}} \\lvert \\dots,n_{\\mu}-1,\\dots \\rangle$ 和 $b_{\\mu}^{\\dagger} \\lvert \\dots,n_{\\mu},\\dots \\rangle = \\sqrt{n_{\\mu}+1} \\lvert \\dots,n_{\\mu}+1,\\dots \\rangle$。\n\n将哈密顿量 $H$ 定义为单体项、对角二体密度-密度项以及 $s$ 和 $d_0$ 模之间的非对角对转换项之和：\n$$\nH = e_s\\, n_s + e_d \\sum_{m=-2}^{2} n_{d_m}\n+ \\frac{1}{2} V_{ss}\\, n_s(n_s-1)\n+ \\frac{1}{2} V_{dd} \\sum_{m=-2}^{2} n_{d_m}(n_{d_m}-1)\n+ V_{sd}\\, n_s \\left(\\sum_{m=-2}^{2} n_{d_m}\\right)\n+ w \\left( s^{\\dagger} s^{\\dagger} d_0 d_0 + d_0^{\\dagger} d_0^{\\dagger} s s \\right).\n$$\n\n此处 $e_s,e_d,V_{ss},V_{dd},V_{sd},w \\in \\mathbb{R}$。最后一项是粒子数守恒的，并且在占据数基中是非对角的，其非零矩阵元源于在 $d_0$ 和 $s$ 模之间移动两个玻色子，其振幅由玻色子升降因子确定。\n\n您的任务如下：\n\n1. 在固定的 $N$ 值占据数基中，通过应用玻色子算符代数计算所有非零矩阵元，从而构建 $H$ 的矩阵表示。确保双玻色子转移项 $s^{\\dagger} s^{\\dagger} d_0 d_0$ 和 $d_0^{\\dagger} d_0^{\\dagger} s s$ 按照升降算符决定的正确振幅进行处理。\n\n2. 仅使用基本定义和经过充分检验的组合学事实，推导 $H$ 在固定 $N$ 值的希尔伯特空间上的解析迹的封闭形式表达式。从迹的恒等式\n$$\n\\mathrm{Tr}(H) = \\sum_{i=1}^{D} \\langle i \\lvert H \\rvert i \\rangle\n$$\n以及非对角算符在占据数基中的对角期望值为零这一观察出发。将解析迹简化为对基矢求和的组合，其形式为 $\\sum_{\\mathbf{n}} n_s$、$\\sum_{\\mathbf{n}} \\sum_{m} n_{d_m}$、$\\sum_{\\mathbf{n}} n_s(n_s-1)$、$\\sum_{\\mathbf{n}} \\sum_m n_{d_m}(n_{d_m}-1)$ 和 $\\sum_{\\mathbf{n}} n_s \\sum_m n_{d_m}$，其中求和遍历所有满足 $\\sum_{\\mu} n_{\\mu} = N$ 的占据数矢量 $\\mathbf{n}$。利用对称性和将 $N$ 个全同玻色子分配到 $K$ 个可区分模中的计数论证，从第一性原理出发，为普适的 $N$ 和 $K=6$ 推导这些和。\n\n3. 实现一个程序，该程序构建 $H$，直接从组装好的矩阵计算其数值迹，根据推导出的公式计算您的解析迹，并使用规定的数值容差比较两者。不允许外部输入；请使用下面的测试套件。\n\n所有能量均可采用一致的任意能量单位处理；无需单位转换。不涉及角度。将布尔比较报告为无单位的真值。\n\n用于覆盖正常路径和边界情况的测试套件参数：\n\n- 情况 1：$N=0$, $e_s=1.2$, $e_d=-0.7$, $V_{ss}=0.5$, $V_{dd}=1.3$, $V_{sd}=-0.9$, $w=2.4$。\n- 情况 2：$N=1$, $e_s=0.0$, $e_d=1.0$, $V_{ss}=3.0$, $V_{dd}=-2.0$, $V_{sd}=0.5$, $w=7.5$。\n- 情况 3：$N=3$, $e_s=-0.2$, $e_d=0.8$, $V_{ss}=0.6$, $V_{dd}=-0.4$, $V_{sd}=1.1$, $w=0.7$。\n- 情况 4：$N=4$, $e_s=1.0$, $e_d=-0.3$, $V_{ss}=-0.5$, $V_{dd}=0.9$, $V_{sd}=-1.2$, $w=5.0$。\n- 情况 5：$N=2$, $e_s=0.3$, $e_d=0.4$, $V_{ss}=1.7$, $V_{dd}=-0.2$, $V_{sd}=0.0$, $w=10.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表，顺序与上述情况一致。当且仅当数值迹与您的解析迹之间的绝对差小于 $10^{-9}$ 时，对应的布尔值为真。例如：\"[True,True,True,True,True]\"。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上植根于量子多体物理学的原理，特别是相互作用玻色子模型（IBM），在数学上是适定的且自洽的。所有定义、参数和约束都得到了明确的提供，从而允许直接且可验证的解决方案。\n\n该任务要求将哈密顿矩阵的数值计算迹与为同一量推导出的解析公式进行比较。我们将首先概述哈密顿矩阵的构造方法，然后为其迹推导封闭形式的表达式。\n\n### 哈密顿量的数值构建与求迹\n\n对于固定的玻色子总数 $N$，希尔伯特空间由占据数基矢 $\\lvert \\mathbf{n} \\rangle = \\lvert n_s, n_{d_{-2}}, n_{d_{-1}}, n_{d_0}, n_{d_1}, n_{d_2} \\rangle$ 张成，其中非负整数 $n_{\\mu}$ 满足 $\\sum n_{\\mu} = N$。模的数量为 $K=6$。该空间的维数为 $D = \\binom{N+K-1}{K-1} = \\binom{N+5}{5}$。\n\n构造哈密顿矩阵 $H$ 的步骤如下：\n1.  生成所有唯一的基态矢量 $\\mathbf{n}$。它们对应于矩阵的行和列。\n2.  创建从每个态矢量 $\\mathbf{n}$ 到索引 $i \\in \\{0, 1, \\dots, D-1\\}$ 的映射。\n3.  初始化一个 $D \\times D$ 的零矩阵。\n4.  对于每个基矢 $\\lvert \\mathbf{n}_i \\rangle$，计算矩阵元 $H_{ji} = \\langle \\mathbf{n}_j \\lvert H \\rvert \\mathbf{n}_i \\rangle$。\n\n哈密顿量由下式给出：\n$$\nH = e_s n_s + e_d \\sum_m n_{d_m} + \\frac{1}{2} V_{ss} n_s(n_s-1) + \\frac{1}{2} V_{dd} \\sum_m n_{d_m}(n_{d_m}-1) + V_{sd} n_s \\left(\\sum_m n_{d_m}\\right) + w \\left( s^{\\dagger} s^{\\dagger} d_0 d_0 + d_0^{\\dagger} d_0^{\\dagger} s s \\right)\n$$\n\n**对角矩阵元：** $H$ 的前五项在占据数基中是对角的。对于一个态 $\\lvert \\mathbf{n} \\rangle$，数算符 $n_\\mu$ 的本征值为 $n_\\mu$。因此，对角矩阵元为：\n$$\n\\langle \\mathbf{n} \\lvert H \\rvert \\mathbf{n} \\rangle = e_s n_s + e_d \\sum_m n_{d_m} + \\frac{1}{2} V_{ss} n_s(n_s-1) + \\frac{1}{2} V_{dd} \\sum_m n_{d_m}(n_{d_m}-1) + V_{sd} n_s \\left(\\sum_m n_{d_m}\\right)\n$$\n\n**非对角矩阵元：** 与 $w$ 成正比的项是非对角的。它连接了因两个玻色子在 $s$ 和 $d_0$ 模之间移动而不同的态。使用产生和湮灭算符代数：\n-   $s^{\\dagger} s^{\\dagger} d_0 d_0 \\lvert n_s, \\dots, n_{d_0}, \\dots \\rangle = \\sqrt{n_{d_0}(n_{d_0}-1)} \\sqrt{(n_s+1)(n_s+2)} \\lvert n_s+2, \\dots, n_{d_0}-2, \\dots \\rangle$。此作用仅当 $n_{d_0} \\ge 2$ 时非零。\n-   $d_0^{\\dagger} d_0^{\\dagger} s s \\lvert n_s, \\dots, n_{d_0}, \\dots \\rangle = \\sqrt{n_s(n_s-1)} \\sqrt{(n_{d_0}+1)(n_{d_0}+2)} \\lvert n_s-2, \\dots, n_{d_0}+2, \\dots \\rangle$。此作用仅当 $n_s \\ge 2$ 时非零。\n\n这些作用定义了非零的非对角矩阵元。例如，如果 $\\lvert \\mathbf{n}' \\rangle$ 是 $n'_s = n_s+2$ 和 $n'_{d_0} = n_{d_0}-2$ 的态，则 $\\langle \\mathbf{n}' \\lvert H \\rvert \\mathbf{n} \\rangle = w \\sqrt{n_{d_0}(n_{d_0}-1)(n_s+1)(n_s+2)}$。\n\n数值迹 $\\mathrm{Tr}(H)_{\\text{num}}$ 是完全构造出的矩阵 $H$ 的对角元素之和。\n\n### 迹的解析推导\n\n一个算符的迹是其在完备基上对角矩阵元的总和。对于占据数基 $\\{\\lvert \\mathbf{n} \\rangle\\}$ 中的哈密顿量 $H$，我们有：\n$$\n\\mathrm{Tr}(H) = \\sum_{\\mathbf{n}} \\langle \\mathbf{n} \\lvert H \\rvert \\mathbf{n} \\rangle\n$$\n其中求和遍历所有 $D$ 个基矢。$H$ 的非对角部分（系数为 $w$ 的项）对迹没有贡献。因此，我们只需将对角矩阵元在整个基上求和：\n$$\n\\mathrm{Tr}(H) = \\sum_{\\mathbf{n}} \\left[ e_s n_s + e_d \\sum_m n_{d_m} + \\frac{1}{2} V_{ss} n_s(n_s-1) + \\frac{1}{2} V_{dd} \\sum_m n_{d_m}(n_{d_m}-1) + V_{sd} n_s \\left(\\sum_m n_{d_m}\\right) \\right]\n$$\n根据线性性质，我们可以将其重新排列为各项之和，每一项都涉及占据数在基上的统计矩：\n$$\n\\mathrm{Tr}(H) = e_s\\left(\\sum_{\\mathbf{n}} n_s\\right) + e_d\\left(\\sum_{\\mathbf{n}}\\sum_m n_{d_m}\\right) + \\frac{V_{ss}}{2}\\left(\\sum_{\\mathbf{n}} n_s(n_s-1)\\right) + \\frac{V_{dd}}{2}\\left(\\sum_{\\mathbf{n}}\\sum_m n_{d_m}(n_{d_m}-1)\\right) + V_{sd}\\left(\\sum_{\\mathbf{n}} n_s \\sum_m n_{d_m}\\right)\n$$\n这些和的计算是一个组合问题，即把 $N$ 个全同玻色子分配到 $K=6$ 个可区分模中。可以从组合分析的第一性原理（例如，使用生成函数或基于“隔板法”的直接计数论证）推导出的关键结果如下：\n-   $\\sum_{\\mathbf{n}} \\binom{n_{\\mu_1}}{k_1} \\dots \\binom{n_{\\mu_m}}{k_m} = \\binom{N+K-1}{K-1+p}$ 其中 $\\mu_i$ 是不同的模，且 $p = \\sum_i k_i$。\n\n应用这个主公式：\n1.  单占据数之和：对于任意模 $\\mu$，设 $p=1$ ($k_1=1$)。\n    $\\sum_{\\mathbf{n}} n_\\mu = \\sum_{\\mathbf{n}} \\binom{n_\\mu}{1} = \\binom{N+6-1}{6-1+1} = \\binom{N+5}{6}$。\n2.  对占据数之和（相同模）：对于任意模 $\\mu$，设 $p=2$ ($k_1=2$)。\n    $\\sum_{\\mathbf{n}} \\binom{n_\\mu}{2} = \\binom{N+6-1}{6-1+2} = \\binom{N+5}{7}$。\n    这给出 $\\sum_{\\mathbf{n}} n_\\mu(n_\\mu-1) = 2\\sum_{\\mathbf{n}} \\binom{n_\\mu}{2} = 2\\binom{N+5}{7}$。\n3.  对占据数之和（不同模）：对于模 $\\mu \\neq \\nu$，设 $p=2$ ($k_1=1, k_2=1$)。\n    $\\sum_{\\mathbf{n}} n_\\mu n_\\nu = \\sum_{\\mathbf{n}} \\binom{n_\\mu}{1}\\binom{n_\\nu}{1} = \\binom{N+6-1}{6-1+2} = \\binom{N+5}{7}$。\n\n使用这些恒等式，我们计算所需的和：\n-   $\\sum_{\\mathbf{n}} n_s = \\binom{N+5}{6}$\n-   $\\sum_{\\mathbf{n}} \\sum_m n_{d_m} = \\sum_m \\left(\\sum_{\\mathbf{n}} n_{d_m}\\right) = 5 \\binom{N+5}{6}$\n-   $\\sum_{\\mathbf{n}} n_s(n_s-1) = 2\\binom{N+5}{7}$\n-   $\\sum_{\\mathbf{n}} \\sum_m n_{d_m}(n_{d_m}-1) = \\sum_m \\left(\\sum_{\\mathbf{n}} n_{d_m}(n_{d_m}-1)\\right) = 5 \\times 2\\binom{N+5}{7} = 10\\binom{N+5}{7}$\n-   $\\sum_{\\mathbf{n}} n_s \\sum_m n_{d_m} = \\sum_m \\left(\\sum_{\\mathbf{n}} n_s n_{d_m}\\right) = 5\\binom{N+5}{7}$\n\n将这些结果代回迹的表达式：\n$$\n\\mathrm{Tr}(H) = e_s \\binom{N+5}{6} + e_d \\left(5\\binom{N+5}{6}\\right) + \\frac{V_{ss}}{2} \\left(2\\binom{N+5}{7}\\right) + \\frac{V_{dd}}{2} \\left(10\\binom{N+5}{7}\\right) + V_{sd} \\left(5\\binom{N+5}{7}\\right)\n$$\n合并各项，迹的最终解析公式为：\n$$\n\\mathrm{Tr}(H)_{\\text{analytic}} = (e_s + 5e_d) \\binom{N+5}{6} + (V_{ss} + 5V_{dd} + 5V_{sd}) \\binom{N+5}{7}\n$$\n请注意，如果 $k > n$，组合项 $\\binom{n}{k}$ 为零。\n\n实现部分将通过矩阵构建计算数值迹，并根据此最终公式计算解析迹，然后对给定的测试用例进行比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\nfrom math import sqrt\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It calculates the numerical and analytical traces of the IBM Hamiltonian\n    and compares them for a series of parameter sets.\n    \"\"\"\n    test_cases = [\n        # (N, es, ed, Vss, Vdd, Vsd, w)\n        (0, 1.2, -0.7, 0.5, 1.3, -0.9, 2.4),\n        (1, 0.0, 1.0, 3.0, -2.0, 0.5, 7.5),\n        (3, -0.2, 0.8, 0.6, -0.4, 1.1, 0.7),\n        (4, 1.0, -0.3, -0.5, 0.9, -1.2, 5.0),\n        (2, 0.3, 0.4, 1.7, -0.2, 0.0, 10.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        comparison_result = run_case(*case)\n        results.append(comparison_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_case(N, es, ed, Vss, Vdd, Vsd, w):\n    \"\"\"\n    Computes numerical and analytical traces for a single test case.\n    \n    Returns:\n        bool: True if the absolute difference between traces is within tolerance.\n    \"\"\"\n    \n    # 1. Numerical Trace Calculation\n    \n    if N == 0:\n        # The only state is |0,0,0,0,0,0>, H is a 1x1 zero matrix.\n        tr_num = 0.0\n    else:\n        # Generate basis states: occupancy vectors (ns, n_d-2, ..., n_d+2)\n        # K=6 modes.\n        basis_states = list(_generate_states(N, 6))\n        D = len(basis_states)\n        state_to_idx = {state: i for i, state in enumerate(basis_states)}\n\n        H = np.zeros((D, D), dtype=float)\n\n        for i, state in enumerate(basis_states):\n            # Unpack state occupancies\n            ns, ndm2, ndm1, nd0, nd1, nd2 = state\n            \n            # --- Diagonal elements ---\n            nd_tot = N - ns\n            \n            # Sum of n_dm * (n_dm - 1) for the V_dd term\n            sum_nd_ndm1 = ndm2 * (ndm2 - 1) + \\\n                          ndm1 * (ndm1 - 1) + \\\n                          nd0 * (nd0 - 1) + \\\n                          nd1 * (nd1 - 1) + \\\n                          nd2 * (nd2 - 1)\n            \n            H[i, i] = es * ns + ed * nd_tot + \\\n                      0.5 * Vss * ns * (ns - 1) + \\\n                      0.5 * Vdd * sum_nd_ndm1 + \\\n                      Vsd * ns * nd_tot\n            \n            # --- Off-diagonal elements from pairing term ---\n            # Term w * (s's'd0d0 + d0'd0'ss)\n            # s-mode is index 0, d0-mode is index 3\n            \n            # Action of s's'd0d0 (connects state i to state j)\n            if nd0 >= 2:\n                # Target state has ns+2, nd0-2\n                new_state = (ns + 2, ndm2, ndm1, nd0 - 2, nd1, nd2)\n                j = state_to_idx[new_state]\n                amp = w * sqrt(nd0 * (nd0 - 1) * (ns + 1) * (ns + 2))\n                H[j, i] += amp\n\n            # Action of d0'd0'ss (connects state i to state k)\n            if ns >= 2:\n                # Target state has ns-2, nd0+2\n                new_state = (ns - 2, ndm2, ndm1, nd0 + 2, nd1, nd2)\n                k = state_to_idx[new_state]\n                amp = w * sqrt(ns * (ns - 1) * (nd0 + 1) * (nd0 + 2))\n                H[k, i] += amp\n        \n        tr_num = np.trace(H)\n\n    # 2. Analytic Trace Calculation\n    \n    # Use scipy.special.comb, which returns 0.0 for k > n\n    # K=6 for the sd model.\n    comb_N_6 = comb(N + 5, 6, exact=False)\n    comb_N_7 = comb(N + 5, 7, exact=False)\n    \n    tr_an = (es + 5 * ed) * comb_N_6 + \\\n            (Vss + 5 * Vdd + 5 * Vsd) * comb_N_7\n            \n    # 3. Comparison\n    return abs(tr_num - tr_an)  1e-9\n\ndef _generate_states(n_bosons, n_modes):\n    \"\"\"\n    Recursively generates all partitions of n_bosons into n_modes.\n    This corresponds to the m-scheme basis states.\n    \"\"\"\n    if n_modes == 1:\n        yield (n_bosons,)\n        return\n    for i in range(n_bosons + 1):\n        for rest in _generate_states(n_bosons - i, n_modes - 1):\n            # States are ordered (ns, n_d-2, n_d-1, n_d0, n_d1, n_d2)\n            yield (i,) + rest\n\nsolve()\n```", "id": "3576640"}, {"introduction": "一个完整的数值实现不仅让我们能够找到本征值，还能研究当模型参数变化时这些本征值如何随之改变。这项练习利用了 Hellmann-Feynman 定理，将本征值对耦合常数的导数与一个简单的期望值联系起来。你将通过数值方法验证该定理，将其预测与有限差分计算结果进行比较，从而深入理解模型的物理内涵和数值微分的精妙之处 [@problem_id:3576651]。", "problem": "你需要实现、验证和分析相互作用玻色子模型 (Interacting Boson Model, IBM) 哈密顿量中本征值相对于耦合参数的数值导数，并将其与 Hellmann–Feynman 定理进行比较。在总玻色子数固定的情况下，使用最简单的无对称性限制的相互作用玻色子模型 (IBM) 的二次量子化形式，该模型包含一个标量玻色子模和五个四极玻色子模，并在粒子数表象（m-scheme）基矢下进行计算。\n\n基本定义与约束：\n- 相互作用玻色子模型 (IBM) 使用一个标量玻色子模，其产生算符为 $s^{\\dagger}$，湮灭算符为 $s$；以及五个四极玻色子模，其产生算符为 $d_{m}^{\\dagger}$，湮灭算符为 $d_{m}$，磁投影 $m \\in \\{-2,-1,0,1,2\\}$。这些是理想玻色子，满足正则对易关系 $[a_{i},a_{j}^{\\dagger}] = \\delta_{ij}$，所有其他对易子等于零。\n- 希尔伯特空间是总玻色子数 $N$ 固定的全对称玻色子福克空间，即总粒子数算符 $n_{s} + \\sum_{m} n_{d_{m}}$ 在所有基态上的本征值为 $N$。这里的粒子数算符为 $n_{s} = s^{\\dagger} s$ 和 $n_{d_{m}} = d_{m}^{\\dagger} d_{m}$。\n- 考虑哈密顿量\n$$\nH(\\kappa) \\;=\\; \\epsilon_{s}\\, n_{s} \\;+\\; \\epsilon_{d}\\,\\sum_{m=-2}^{2} n_{d_{m}} \\;+\\; \\kappa \\sum_{m=-2}^{2}\\Big(s^{\\dagger} d_{m} + d_{m}^{\\dagger} s\\Big),\n$$\n其中 $\\epsilon_{s}$ 和 $\\epsilon_{d}$ 是常数，$\\kappa$ 是一个实数耦合参数。所有能量和耦合都应视为无量纲数。\n\n计算表示：\n- 使用粒子数表象基矢，其中状态由 $s$ 玻色子和五个 $d$ 玻色子模的占据数 $(n_{s}, n_{-2}, n_{-1}, n_{0}, n_{1}, n_{2})$ 标记，并满足约束 $n_{s} + \\sum_{m} n_{m} = N$。产生和湮灭算符在各自模上的作用方式为 $a^{\\dagger} \\lvert n \\rangle = \\sqrt{n+1}\\, \\lvert n+1 \\rangle$ 和 $a \\lvert n \\rangle = \\sqrt{n}\\, \\lvert n-1 \\rangle$。\n- 在此基矢下，对角的单体部分为 $H_{0} = \\epsilon_{s} n_{s} + \\epsilon_{d} \\sum_{m} n_{d_{m}}$。非对角耦合为 $V = \\sum_{m}(s^{\\dagger} d_{m} + d_{m}^{\\dagger} s)$；在两个通过在 $s$ 模和一个 $d_{m}$ 模之间移动一个玻色子而连接的基态之间，$V$ 的矩阵元可由玻色子阶梯算符代数得出。\n\n待使用的基本定理：\n- 对于 $H(\\kappa)$ 的一个归一化本征态 $\\lvert \\psi_{k}(\\kappa) \\rangle$ 及其本征值 $E_{k}(\\kappa)$，Hellmann–Feynman 定理指出\n$$\n\\frac{dE_{k}}{d\\kappa} \\;=\\; \\left\\langle \\psi_{k}(\\kappa) \\,\\middle\\lvert\\, \\frac{\\partial H(\\kappa)}{\\partial \\kappa} \\,\\middle\\rvert\\, \\psi_{k}(\\kappa)\\right\\rangle \\;=\\; \\langle \\psi_{k}(\\kappa) \\lvert V \\rvert \\psi_{k}(\\kappa) \\rangle.\n$$\n\n任务：\n1. 使用上述代数，在固定的 $N$ 值下，于粒子数表象基矢中构造有限维哈密顿矩阵 $H(\\kappa)$。取 $N = 3$, $\\epsilon_{s} = 0$, $\\epsilon_{d} = 1$。使用实对称矩阵，并确保所有矩阵元的归一化正确。\n2. 对于每个指定的 $(\\kappa, h)$ 对，以基态 ($k=0$) 为目标：\n   - 通过对 $H(\\kappa)$ 进行精确对角化，计算基态本征值 $E_{0}(\\kappa)$ 和相应的归一化本征矢量 $\\lvert \\psi_{0}(\\kappa)\\rangle$。\n   - 计算 Hellmann–Feynman 导数 $D_{\\mathrm{HF}}(\\kappa) = \\langle \\psi_{0}(\\kappa) \\lvert V \\rvert \\psi_{0}(\\kappa)\\rangle$。\n   - 计算中心有限差分导数\n     $$\n     D_{\\mathrm{FD}}(\\kappa,h) \\;=\\; \\frac{E_{0}(\\kappa+h) - E_{0}(\\kappa-h)}{2h}.\n     $$\n     为避免因可能出现的能级交叉/避免交叉而导致的本征值标记错误，在计算 $E_{0}(\\kappa \\pm h)$ 时，应选择在 $\\kappa \\pm h$ 处其本征矢量与 $\\lvert \\psi_{0}(\\kappa) \\rangle$ 具有最大交叠幅值的那个本征值。\n   - 以浮点数形式返回绝对误差 $|D_{\\mathrm{FD}}(\\kappa,h) - D_{\\mathrm{HF}}(\\kappa)|$。\n3. 在你的解决方案中讨论截断误差和舍入误差如何随着 $h$ 的变化而相互竞争，以及这种现象如何体现在测试输出中。\n\n测试套件：\n- 使用以下参数集 $(\\kappa, h)$，并固定 $N = 3$, $\\epsilon_{s} = 0$, $\\epsilon_{d} = 1$：\n  - 情况 1：$(\\kappa, h) = (0.2, 10^{-3})$。\n  - 情况 2：$(\\kappa, h) = (0.2, 10^{-6})$。\n  - 情况 3：$(\\kappa, h) = (0.2, 10^{-1})$。\n  - 情况 4：$(\\kappa, h) = (0.0, 10^{-3})$。\n  - 情况 5：$(\\kappa, h) = (0.5, 10^{-3})$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含按上述顺序列出的各个情况的绝对误差，形式为方括号内以逗号分隔的列表（例如 $[x_{1},x_{2},x_{3},x_{4},x_{5}]$）。每个 $x_{i}$ 必须是浮点数。所有量都是无量纲的。不应打印任何其他文本。", "solution": "用户提供了一个来自计算核物理领域的有效问题陈述。任务是为一个简化的相互作用玻色子模型 (IBM) 哈密顿量数值验证 Hellmann-Feynman 定理。这涉及在有限维粒子数表象基矢中构建哈密顿矩阵，通过两种不同方法——Hellmann-Feynman (HF) 公式和有限差分 (FD) 近似——计算本征值导数，并分析它们之间的误差。\n\n该问题具有坚实的科学基础，使用了量子力学和数值分析的标准原理。参数和约束定义清晰，使得问题适定且计算上可行。\n\n### 基于原理的解决方案设计\n\n问题的核心是将量子力学哈密顿量 $H(\\kappa)$ 表示为一个数值矩阵并对其进行对角化。解决方案分几个逻辑上独立的步骤进行：基矢生成、哈密顿量构建以及导数的比较计算。\n\n#### 1. 希尔伯特空间和基矢构建\n\n该模型涉及 $d=6$ 种玻色子：一个标量 ($s$) 和五个四极 ($d_{m}$，其中 $m \\in \\{-2, \\ldots, 2\\}$)。希尔伯特空间被限制在总玻色子数固定的状态，即 $N=3$。一个适合数值计算的基矢是粒子数（或福克态）表象基矢。一个基矢态由一组粒子数元组 $\\lvert n_s, n_{-2}, n_{-1}, n_0, n_1, n_2 \\rangle$ 唯一确定，使得这些粒子数是非负整数且其和为 $N$：\n$$\nn_s + \\sum_{m=-2}^{2} n_{d,m} = N\n$$\n对于 $N=3$ 个玻色子和 $d=6$ 个模，该空间的维度由多重组合的“隔板法”公式给出：$\\binom{N+d-1}{d-1} = \\binom{3+6-1}{6-1} = \\binom{8}{5} = 56$。\n\n建立一个计算映射，为 56 个唯一的粒子数元组中的每一个分配一个唯一的整数索引 $i \\in \\{0, 1, \\dots, 55\\}$。这使我们能够将量子态表示为向量，将算符表示为矩阵。\n\n#### 2. 哈密顿矩阵构建\n\n哈密顿量 $H(\\kappa) = H_0 + \\kappa V$ 被构建为一个 $56 \\times 56$ 的实对称矩阵。\n\n第一部分，$H_0 = \\epsilon_s n_s + \\epsilon_d \\sum_m n_{d_m}$，在所选基矢中是对角的。对应于基矢态 $\\lvert i \\rangle \\equiv \\lvert n_s, \\{n_{d,m}\\} \\rangle$ 的对角矩阵元是：\n$$\n\\langle i \\rvert H_0 \\lvert i \\rangle = \\epsilon_s n_s + \\epsilon_d \\sum_m n_{d,m}\n$$\n使用约束 $\\sum_m n_{d,m} = N - n_s$ 以及给定的参数 $N=3$, $\\epsilon_s=0$, $\\epsilon_d=1$，该式简化为：\n$$\n\\langle i \\rvert H_0 \\lvert i \\rangle = 0 \\cdot n_s + 1 \\cdot (3 - n_s) = 3 - n_s\n$$\n\n第二部分，$V = \\sum_{m=-2}^{2} (s^\\dagger d_m + d_m^\\dagger s)$，是相互作用项。它是非对角的，并连接那些因一个玻色子在 $s$ 模和一个 $d_m$ 模之间转移而不同的基矢态。设 $\\lvert i \\rangle = \\lvert n_s, \\dots, n_m, \\dots \\rangle$ 和 $\\lvert j \\rangle = \\lvert n_s+1, \\dots, n_m-1, \\dots \\rangle$。$V$ 相应的非对角矩阵元是：\n$$\n\\langle j \\rvert V \\lvert i \\rangle = \\left\\langle j \\middle\\rvert \\sum_{m'} (s^\\dagger d_{m'} + d_{m'}^\\dagger s) \\middle\\lvert i \\right\\rangle\n$$\n只有 $s^\\dagger d_m$ 项对该矩阵元有贡献。使用玻色子产生和湮灭算符的规则，$a^\\dagger \\lvert n \\rangle = \\sqrt{n+1} \\lvert n+1 \\rangle$ 和 $a \\lvert n \\rangle = \\sqrt{n} \\lvert n-1 \\rangle$：\n$$\n\\langle j \\rvert s^\\dagger d_m \\lvert i \\rangle = \\langle n_s+1, \\dots, n_m-1, \\dots \\rvert s^\\dagger d_m \\lvert n_s, \\dots, n_m, \\dots \\rangle = \\sqrt{n_m} \\sqrt{n_s+1}\n$$\n由于 $V$ 是厄米且实的，我们有 $\\langle i \\rvert V \\lvert j \\rangle = \\langle j \\rvert V \\lvert i \\rangle$。\n完整的哈密顿矩阵则为 $H_{ij}(\\kappa) = (H_0)_{ij} + \\kappa V_{ij}$。此矩阵被数值构建以用于后续步骤。\n\n#### 3. 导数计算与比较\n\n对于每个给定的 $(\\kappa, h)$ 对，我们以基态（标记为 $k=0$）为目标。\n\n1.  **精确对角化**：使用针对厄米矩阵的标准数值算法对矩阵 $H(\\kappa)$ 进行对角化。这将产生一组本征值 $\\{E_k(\\kappa)\\}$ 及其对应的本征矢量 $\\{ \\lvert \\psi_k(\\kappa) \\rangle \\}$。基态能量 $E_0(\\kappa)$ 是最低的本征值，而 $\\lvert \\psi_0(\\kappa) \\rangle$ 是其关联的本征矢量。\n\n2.  **Hellmann-Feynman 导数 ($D_{\\mathrm{HF}}$)**：该定理指出 $\\frac{dE_k}{d\\kappa} = \\langle \\psi_k \\rvert \\frac{\\partial H}{\\partial \\kappa} \\rvert \\psi_k \\rangle$。对于给定的哈密顿量，$\\frac{\\partial H}{\\partial \\kappa} = V$。因此，基态的导数计算为相互作用算符 $V$ 在基态中的期望值：\n    $$\n    D_{\\mathrm{HF}}(\\kappa) = \\langle \\psi_0(\\kappa) \\rvert V \\rvert \\psi_0(\\kappa) \\rangle\n    $$\n    在计算上，这是一个二次型 $\\mathbf{v}_0^T \\mathbf{V} \\mathbf{v}_0$，其中 $\\mathbf{V}$ 是算符 $V$ 的矩阵，$\\mathbf{v}_0$ 是基态本征矢量。\n\n3.  **有限差分导数 ($D_{\\mathrm{FD}}$)**：该导数也使用二阶中心有限差分公式进行近似：\n    $$\n    D_{\\mathrm{FD}}(\\kappa, h) = \\frac{E_0(\\kappa+h) - E_0(\\kappa-h)}{2h}\n    $$\n    为了计算 $E_0(\\kappa \\pm h)$，需要构建并对角化哈密顿量 $H(\\kappa+h)$ 和 $H(\\kappa-h)$。一个关键步骤是在微扰后的 $\\kappa$ 值处正确识别基态 $E_0$ 的延续。由于能级随着 $\\kappa$ 的变化可能会交叉或经历避免交叉，仅仅选择 $\\kappa \\pm h$ 处的最低本征值可能是错误的。问题指定了一种稳健的跟踪方法：正确的本征值 $E_0(\\kappa \\pm h)$ 是其对应本征矢量与原始基态本征矢量 $\\lvert \\psi_0(\\kappa) \\rangle$ 具有最大绝对值交叠（内积）的那个。\n\n最后，计算绝对误差 $|D_{\\mathrm{FD}}(\\kappa,h) - D_{\\mathrm{HF}}(\\kappa)|$ 来量化有限差分近似的准确性。\n\n#### 4. 数值误差分析\n\n有限差分近似中的误差主要来自两个来源：\n\n-   **截断误差**：这是近似方法的一种内在误差，源于截断函数的泰勒级数展开。对于中心差分公式，主导误差项的阶数为 $O(h^2)$：\n    $$\n    D_{\\mathrm{FD}}(\\kappa, h) = \\frac{dE_0}{d\\kappa} + \\frac{h^2}{6}\\frac{d^3 E_0}{d\\kappa^3} + O(h^4)\n    $$\n    当步长 $h$ 减小时，该误差迅速（二次方）减小。\n\n-   **舍入误差**：这种误差源于浮点运算的有限精度。当为一个非常小的 $h$ 计算差值 $E_0(\\kappa+h) - E_0(\\kappa-h)$ 时，两项几乎相同。它们的相减会导致有效数字的损失，这被称为灾难性抵消。此误差与 $h$ 成反比，其尺度为 $O(\\epsilon/h)$，其中 $\\epsilon$ 是机器精度。\n\n总误差是这两部分贡献之和，$Error(h) \\approx C_1 h^2 + C_2/h$。这意味着存在一个最优步长 $h_{opt}$，可以使总误差最小化。提供的测试用例探讨了这种行为：\n-   情况 3 ($h=10^{-1}$): $h$ 较大，因此 $O(h^2)$ 的截断误差预计将占主导地位且较大。\n-   情况 1 ($h=10^{-3}$): $h$ 较小，因此截断误差应显著减小（比情况 3 小 $10^4$ 倍）。\n-   情况 2 ($h=10^{-6}$): $h$ 非常小，接近双精度算术的最优值。此时，误差预计是三者中最小的，因为截断误差变得可以忽略不计，而舍入误差尚未占主导地位。\n-   情况 4 ($\\kappa=0$): 在 $\\kappa=0$ 时，哈密顿量是对角的，基态是非简并的。微扰理论表明，在 $\\kappa=0$ 附近 $E_0(\\kappa)$ 是 $\\kappa$ 的偶函数（即，$E_0(\\kappa) \\approx E_0(0) + C\\kappa^2$）。因此，其在 $\\kappa=0$ 处的导数恰好为零。$D_{\\mathrm{HF}}(0)$ 和 $D_{\\mathrm{FD}}(0, h)$ 的计算结果都应接近于零，导致误差接近机器精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef generate_basis(N, num_modes):\n    \"\"\"\n    Generates all occupation-number basis states for N bosons in num_modes.\n\n    An occupation state is a tuple (n_1, n_2, ..., n_num_modes) such that sum(n_i) = N.\n\n    Returns:\n        A list of state tuples and a dictionary mapping states to indices.\n    \"\"\"\n    if num_modes == 1:\n        if N >= 0:\n            yield (N,)\n        return\n\n    for n in range(N + 1):\n        for rest in generate_basis(N - n, num_modes - 1):\n            yield (n,) + rest\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    \"\"\"\n    # Foundational definitions and constraints\n    N = 3\n    eps_s = 0.0\n    eps_d = 1.0\n    num_d_modes = 5\n    num_total_modes = 1 + num_d_modes\n\n    # 1. Construct the basis and state-to-index mapping\n    basis_generator = generate_basis(N, num_total_modes)\n    # The generator yields s-boson count first, then d-bosons.\n    # To match problem description (ns, n-2, n-1, ...), we re-order.\n    # The generation order is (n_mode_1, n_mode_2, ...).\n    # Let's assign mode 1 to 's', modes 2-6 to 'd-2' through 'd+2'.\n    # My generator produces this naturally.\n    basis = list(basis_generator)\n    state_to_idx = {state: i for i, state in enumerate(basis)}\n    dim = len(basis)\n\n    # 2. Construct the H0 and V matrices\n    h0_diag = np.zeros(dim)\n    v_mat = np.zeros((dim, dim))\n\n    for i, state_i in enumerate(basis):\n        n_s_i = state_i[0]\n        n_d_total_i = sum(state_i[1:])\n        \n        # Diagonal part (H0)\n        h0_diag[i] = eps_s * n_s_i + eps_d * n_d_total_i\n\n        # Off-diagonal part (V)\n        # Considers terms like d_m^dagger * s which connect |state_i>\n        # to a state |state_j> with one less s-boson and one more d_m-boson.\n        if n_s_i > 0:\n            for m_idx in range(num_d_modes):\n                # Target state state_j has n_s_i-1, n_dm+1\n                n_dm_i = state_i[m_idx + 1]\n                \n                new_state_list = list(state_i)\n                new_state_list[0] -= 1\n                new_state_list[m_idx + 1] += 1\n                state_j = tuple(new_state_list)\n                \n                j = state_to_idx[state_j]\n                \n                # Matrix element", "id": "3576651"}]}