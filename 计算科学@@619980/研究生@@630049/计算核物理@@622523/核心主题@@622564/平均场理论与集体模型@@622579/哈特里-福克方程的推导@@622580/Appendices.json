{"hands_on_practices": [{"introduction": "理论学习的最终目的是付诸实践。本节将通过一系列动手练习，将前面推导的Hartree-Fock方程转化为可执行的计算程序。第一个练习将从一个简化的可分离相互作用模型出发，指导你实现核心的自洽场（Self-Consistent Field, SCF）迭代循环。通过引入拉格朗日乘子来施加约束，你还将学习到一种研究原子核形变等结构性质的关键技术，这是核结构计算中的一个基本功。[@problem_id:3555808]", "problem": "考虑一个由全同无自旋费米子组成的系统，该系统被限制在一个维度为 $M$ 的有限正交归一单粒子基中，具有单体哈密顿量 $\\hat{h}_0$ 和一个由强度参数 $\\kappa$ 表征的四极-四极类型的示意性可分离两体相互作用。设 $\\hat{Q}_{20}$ 表示在单粒子基中表示的轴向质量四极算符。多体试探态被限制为由 $N$ 个正交归一轨道 $\\{\\phi_k\\}$（$k = 1,\\dots,N$）构建的斯莱特行列式，这些轨道是一个幺正矩阵的列，该幺正矩阵可将一个自洽平均场算符对角化。你将使用一个拉格朗日乘子 $\\lambda_Q$ 来引入一个四极约束，该约束在带约束的变分原理层面上推导得出。你的任务如下。\n\n任务 A (第一性原理推导): 从能量期望值的里兹变分原理出发，并强制执行：\n- 单粒子轨道的正交归一性，\n- 固定的粒子数 $N$，\n- 通过拉格朗日乘子 $\\lambda_Q$ 对轴向四极矩施加线性约束，\n请展示欧拉-拉格朗日方程如何导出具有一个修正的、与状态无关的单体算符的单粒子方程，该算符自洽地依赖于已占据轨道和拉格朗日乘子。仅使用以下内容作为你的推导基础：\n- 斯莱特行列式和单体密度矩阵 $\\rho$ 的定义，\n- 平均场近似中可分离相互作用能的二次型，\n- 带约束的瑞利-里兹原理及拉格朗日乘子，\n- 轨道的正交归一性条件。\n\n明确指出：\n- 来自可分离相互作用 $-\\frac{\\kappa}{2}\\hat{Q}_{20}\\hat{Q}_{20}$ 的平均场贡献的结构，用平均四极矩 $\\langle \\hat{Q}_{20} \\rangle$ 表示，\n- 四极约束如何修正有效单粒子算符，\n- 使方程封闭的自洽条件。\n\n不要使用任何预先引用的目标公式；请推导它们。\n\n任务 B (计算自洽性): 在固定的单粒子基中，使用以下数据（所有单位均为任意单位），实现一个约束平均场问题的自洽求解器：\n- 基维度 $M = 6$，粒子数 $N = 3$。\n- 单体哈密顿量 $\\hat{h}_0$ 由对角矩阵表示\n$$\nh_0 = \\mathrm{diag}\\left(0.0,\\;0.9,\\;1.7,\\;2.8,\\;4.2,\\;6.0\\right).\n$$\n- 轴向四极算符 $\\hat{Q}_{20}$ 由对称实矩阵表示\n$$\nQ = \\begin{pmatrix}\n-2.0 & 0.20 & 0.05 & 0 & 0 & 0 \\\\\n0.20 & -0.8 & 0.20 & 0.05 & 0 & 0 \\\\\n0.05 & 0.20 & 0.3 & 0.20 & 0.05 & 0 \\\\\n0 & 0.05 & 0.20 & 0.9 & 0.20 & 0.05 \\\\\n0 & 0 & 0.05 & 0.20 & 1.6 & 0.20 \\\\\n0 & 0 & 0 & 0.05 & 0.20 & 2.2\n\\end{pmatrix}.\n$$\n- 相互作用强度 $\\kappa = 0.25$。\n\n你的求解器应该：\n- 通过占据 $\\hat{h}_0$ 的 $N$ 个最低本征态来初始化密度矩阵 $\\rho$，\n- 迭代以下步骤直至收敛：\n  - 构建任务 A 所暗示的有效单体算符，\n  - 将其对角化以获得新的单粒子态和能量，\n  - 占据 $N$ 个能量最低的态来更新 $\\rho$ 和平均四极矩 $\\langle \\hat{Q}_{20} \\rangle = \\mathrm{Tr}(\\rho Q)$，\n  - 在标量 $\\langle \\hat{Q}_{20} \\rangle$ 上使用简单线性混合以稳定收敛，\n- 当 $\\langle \\hat{Q}_{20} \\rangle$ 的变化量低于 $\\tau = 10^{-10}$ 或达到最大迭代次数 $10^4$ 时，宣布收敛。\n\n对于每个收敛解，计算：\n- 哈特里-福克(HF)平均场能量\n$$\nE_{\\mathrm{HF}}[\\rho] = \\mathrm{Tr}(\\rho h_0) - \\frac{\\kappa}{2}\\,\\langle \\hat{Q}_{20} \\rangle^2,\n$$\n- 劳斯函数（约束泛函）\n$$\n\\mathcal{R}(\\lambda_Q) = E_{\\mathrm{HF}}[\\rho(\\lambda_Q)] + \\lambda_Q \\,\\langle \\hat{Q}_{20} \\rangle.\n$$\n\n数值验证（谱的敏感性和变分导数）：对于下方的每个 $\\lambda_Q$ 测试值，在收敛后报告：\n- 收敛后的四极矩 $\\langle \\hat{Q}_{20} \\rangle$，\n- 最低的 $N$ 个自洽单粒子本征值（升序排列），以量化对谱的影响，\n- 一个布尔标志，当在给定的 $\\lambda_Q$ 处，$\\frac{d\\mathcal{R}}{d\\lambda_Q}$ 的中心差分近似与收敛的 $\\langle \\hat{Q}_{20} \\rangle$ 在容差 $\\delta = 5\\times 10^{-5}$ 内相等时为真。使用增量为 $\\Delta \\lambda = 10^{-5}$ 的中心差分，并在 $\\lambda_Q + \\Delta \\lambda$ 和 $\\lambda_Q - \\Delta \\lambda$ 处完全重新收敛自洽解，以评估 $\\mathcal{R}(\\lambda_Q \\pm \\Delta \\lambda)$。\n\n物理和数值单位：将所有能量视为任意能量单位，四极矩视为无量纲。角度不出现。将数值输出表示为四舍五入到 $6$ 位小数的实数，布尔值表示为整数（$1$ 表示真，$0$ 表示假）。\n\n测试套件：对以下拉格朗日乘子值运行你的求解器：\n- 情况 1: $\\lambda_Q = -0.8$,\n- 情况 2: $\\lambda_Q = -0.2$,\n- 情况 3: $\\lambda_Q = 0.0$,\n- 情况 4: $\\lambda_Q = 0.6$。\n\n最终输出格式：你的程序应生成一行输出，其中包含所有情况的结果，形式为方括号括起来的逗号分隔列表。每个情况本身应为以下形式的子列表\n$$\n\\left[\\langle \\hat{Q}_{20} \\rangle,\\; \\epsilon_1,\\; \\epsilon_2,\\; \\epsilon_3,\\; b\\right],\n$$\n其中 $\\epsilon_1,\\epsilon_2,\\epsilon_3$ 是 $N$ 个最低的自洽单粒子能量，$b \\in \\{0,1\\}$ 是上面定义的布尔标志。因此，整体输出应如下所示\n$$\n\\big[\\,[\\cdots],\\,[\\cdots],\\,[\\cdots],\\,[\\cdots]\\,\\big],\n$$\n每个实数四舍五入到 $6$ 位小数，不打印单位。", "solution": "该问题要求推导一个示意性模型的约束哈特里-福克方程并进行数值求解。问题陈述清晰，科学上合理，并包含了所有必要信息。\n\n### 任务 A：第一性原理推导\n\n目标是找到一组 $N$ 个正交归一的单粒子轨道 $|\\phi_k\\rangle$（$k=1, \\dots, N$），使得在平均四极矩受约束的条件下，系统总能量的期望值最小化。总的多体哈密顿量为 $\\hat{H} = \\hat{h}_0 + \\hat{V}$，其中 $\\hat{h}_0$ 是单体部分，$\\hat{V} = -\\frac{\\kappa}{2} \\hat{Q}_{20} \\hat{Q}_{20}$ 是可分离的两体相互作用。多体态 $|\\Psi\\rangle$ 是由轨道 $|\\phi_k\\rangle$ 构建的斯莱特行列式。\n\n在哈特里-福克（对于这种相互作用，可简化为哈特里）近似下，可分离相互作用的期望值由 $E_V = \\langle \\hat{V} \\rangle \\approx -\\frac{\\kappa}{2} \\langle \\hat{Q}_{20} \\rangle^2$ 给出。这里，$\\langle \\hat{Q}_{20} \\rangle$ 是四极算符在多体态 $|\\Psi\\rangle$ 中的期望值，对于斯莱特行列式，它是已占据轨道上单粒子期望值的总和：\n$$\n\\langle \\hat{Q}_{20} \\rangle = \\langle \\Psi | \\hat{Q}_{20} | \\Psi \\rangle = \\sum_{k=1}^N \\langle \\phi_k | \\hat{Q}_{20} | \\phi_k \\rangle = \\mathrm{Tr}(\\rho \\hat{Q}_{20})\n$$\n其中 $\\rho = \\sum_{k=1}^N |\\phi_k\\rangle\\langle\\phi_k|$ 是单体密度矩阵。\n\n因此，需要最小化的总能量泛函为：\n$$\nE_{\\mathrm{HF}}[\\{\\phi_k\\}] = \\langle \\hat{h}_0 \\rangle - \\frac{\\kappa}{2} \\langle \\hat{Q}_{20} \\rangle^2 = \\sum_{k=1}^N \\langle \\phi_k | \\hat{h}_0 | \\phi_k \\rangle - \\frac{\\kappa}{2} \\left( \\sum_{k=1}^N \\langle \\phi_k | \\hat{Q}_{20} | \\phi_k \\rangle \\right)^2\n$$\n\n我们使用带约束的里兹变分原理。我们希望找到能量泛函 $E_{\\mathrm{HF}}$ 在四极矩约束下的一个驻点。这可以通过寻找一个修正泛函（劳斯函数）的驻点来实现，其中约束通过拉格朗日乘子 $\\lambda_Q$ 被引入。需要求驻点的泛函是：\n$$\n\\mathcal{F}[\\{\\phi_k\\}] = E_{\\mathrm{HF}}[\\{\\phi_k\\}] + \\lambda_Q \\langle \\hat{Q}_{20} \\rangle\n$$\n这种形式对应于在平均场近似下，寻找一个使劳斯算符 $\\hat{R} = \\hat{H} + \\lambda_Q \\hat{Q}_{20}$ 最小化的态。$\\lambda_Q$ 的符号约定与问题中数值劳斯函数 $\\mathcal{R}$ 的定义一致。\n\n为了强制轨道的正交归一性，$\\langle \\phi_i | \\phi_j \\rangle = \\delta_{ij}$，我们引入一个拉格朗日乘子矩阵 $\\epsilon_{ij}$ 并构建完整的拉格朗日函数：\n$$\n\\mathcal{L}[\\{\\phi_k\\}] = \\mathcal{F}[\\{\\phi_k\\}] - \\sum_{i,j=1}^N \\epsilon_{ij} (\\langle \\phi_i | \\phi_j \\rangle - \\delta_{ij})\n$$\n代入 $E_{\\mathrm{HF}}$ 和 $\\langle \\hat{Q}_{20} \\rangle$ 的表达式：\n$$\n\\mathcal{L} = \\sum_{k=1}^N \\langle \\phi_k | \\hat{h}_0 | \\phi_k \\rangle - \\frac{\\kappa}{2} \\left( \\sum_{i=1}^N \\langle \\phi_i | \\hat{Q}_{20} | \\phi_i \\rangle \\right)^2 + \\lambda_Q \\sum_{k=1}^N \\langle \\phi_k | \\hat{Q}_{20} | \\phi_k \\rangle - \\sum_{i,j=1}^N \\epsilon_{ij} (\\langle \\phi_i | \\phi_j \\rangle - \\delta_{ij})\n$$\n为了找到最优轨道，我们要求 $\\mathcal{L}$ 对每个 $\\langle\\phi_k|$ 的泛函导数为零。对于一个特定的轨道 $\\langle\\phi_j|$：\n$$\n\\frac{\\delta \\mathcal{L}}{\\delta \\langle \\phi_j|} = \\hat{h}_0 |\\phi_j\\rangle - \\frac{\\kappa}{2} \\cdot 2 \\left( \\sum_{i=1}^N \\langle \\phi_i | \\hat{Q}_{20} | \\phi_i \\rangle \\right) \\hat{Q}_{20}|\\phi_j\\rangle + \\lambda_Q \\hat{Q}_{20}|\\phi_j\\rangle - \\sum_{i=1}^N \\epsilon_{ji}|\\phi_i\\rangle = 0\n$$\n注意到 $\\langle \\hat{Q}_{20} \\rangle = \\sum_i \\langle \\phi_i | \\hat{Q}_{20} | \\phi_i \\rangle$，上式简化为：\n$$\n\\left( \\hat{h}_0 - \\kappa \\langle \\hat{Q}_{20} \\rangle \\hat{Q}_{20} + \\lambda_Q \\hat{Q}_{20} \\right) |\\phi_j\\rangle = \\sum_{i=1}^N \\epsilon_{ji} |\\phi_i\\rangle\n$$\n此方程对每个已占据轨道 $j=1,\\dots,N$ 均成立。左侧的算符是有效单粒子哈密顿量，我们称之为 $\\hat{h}_{\\mathrm{eff}}$：\n$$\n\\hat{h}_{\\mathrm{eff}} = \\hat{h}_0 - \\kappa \\langle \\hat{Q}_{20} \\rangle \\hat{Q}_{20} + \\lambda_Q \\hat{Q}_{20}\n$$\n拉格朗日乘子矩阵 $\\epsilon_{ji}$ 是厄米的。我们总能找到一个在已占据轨道 $|\\phi_k\\rangle$ 间的幺正变换，使该矩阵对角化，从而得到一组满足本征值方程的“正则”轨道 $|\\psi_k\\rangle$：\n$$\n\\hat{h}_{\\mathrm{eff}} |\\psi_k\\rangle = \\epsilon_k |\\psi_k\\rangle\n$$\n其中 $\\epsilon_k$ 是实数本征值，被认作是单粒子能量。系统的基态则通过占据与 $\\hat{h}_{\\mathrm{eff}}$ 的 $N$ 个最低本征值相对应的 $N$ 个单粒子轨道来构成。\n\n明确的要点如下：\n1.  **平均场贡献的结构：** 项 $-\\kappa \\langle \\hat{Q}_{20} \\rangle \\hat{Q}_{20}$ 是由可分离两体相互作用产生的单体势。它依赖于态自身的四极矩，这使得问题成为非线性的。\n2.  **四极约束的修正：** 由于约束的存在，项 $+\\lambda_Q \\hat{Q}_{20}$ 被加到哈密顿量中。该项的作用如同一个外场，驱动系统朝向特定的形变。一个正的 $\\lambda_Q$ 会惩罚具有正 $\\langle \\hat{Q}_{20} \\rangle$ 的态，从而倾向于负值，反之亦然，以使泛函 $\\mathcal{F}$ 最小化。\n3.  **自洽条件：** 有效哈密顿量 $\\hat{h}_{\\mathrm{eff}}$ 依赖于 $\\langle \\hat{Q}_{20} \\rangle$。然而，$\\langle \\hat{Q}_{20} \\rangle$ 是用作为 $\\hat{h}_{\\mathrm{eff}}$ 本征问题的解的轨道计算出来的：$\\langle \\hat{Q}_{20} \\rangle = \\sum_{k=1}^N \\langle \\psi_k | \\hat{Q}_{20} | \\psi_k \\rangle$。这种相互依赖性构成了一个必须通过迭代求解的自洽循环。\n\n### 任务 B：计算自洽性\n\n任务 A 中的推导为数值求解器提供了基础。自洽过程包括迭代地构建和对角化有效哈密顿量 $\\hat{h}_{\\mathrm{eff}}$，直到输入和输出的四极矩收敛。\n\n算法结构如下：\n1.  **初始化**：定义基维度 $M=6$、粒子数 $N=3$、常数 $\\kappa, \\tau$ 以及 $\\hat{h}_0$ 和 $\\hat{Q}_{20}$ 的矩阵表示。通过占据 $\\hat{h}_0$ 的 $N=3$ 个能量最低的本征态来构建初始密度矩阵 $\\rho$。由于 $\\hat{h}_0$ 是对角矩阵，这对应于一个前 $N$ 个对角元为 $1$ 的对角矩阵 $\\rho$。由此，计算出四极矩的初始猜测值 $\\langle Q \\rangle_{\\text{in}} = \\mathrm{Tr}(\\rho Q)$。\n2.  **迭代**：循环运行直到收敛或达到最大迭代次数 $10^4$ 次。在每一步中：\n    a. 构建有效哈密顿矩阵 $h_{\\mathrm{eff}} = h_0 - \\kappa \\langle Q \\rangle_{\\text{in}} Q + \\lambda_Q Q$。\n    b. 对角化 $h_{\\mathrm{eff}}$ 以找到其本征值（单粒子能量）和本征向量（单粒子轨道）。\n    c. 从对应于 $N$ 个最低本征值的 $N$ 个本征向量构建新的密度矩阵。\n    d. 计算新的输出四极矩 $\\langle Q \\rangle_{\\text{out}} = \\mathrm{Tr}(\\rho_{\\text{new}} Q)$。\n    e. 通过比较输入和输出矩来检查收敛性：$|\\langle Q \\rangle_{\\text{out}} - \\langle Q \\rangle_{\\text{in}}| < \\tau$。\n    f. 若未收敛，使用简单线性混合更新下一次迭代的输入：$\\langle Q \\rangle_{\\text{in}} \\leftarrow (1-\\alpha)\\langle Q \\rangle_{\\text{in}} + \\alpha \\langle Q \\rangle_{\\text{out}}$，其中 $\\alpha$ 是一个混合参数（例如 0.5），以稳定收敛过程。\n3.  **后处理**：收敛后，计算所需量：\n    a. 收敛后的四极矩 $\\langle \\hat{Q}_{20} \\rangle$。\n    b. 最低的 $N$ 个单粒子能量（最终 $h_{\\mathrm{eff}}$ 的本征值）。\n    c. HF 能量 $E_{\\mathrm{HF}} = \\mathrm{Tr}(\\rho_{\\text{conv}} h_0) - \\frac{\\kappa}{2} \\langle \\hat{Q}_{20} \\rangle^2$。\n    d. 劳斯函数 $\\mathcal{R}(\\lambda_Q) = E_{\\mathrm{HF}} + \\lambda_Q \\langle \\hat{Q}_{20} \\rangle$。\n4.  **数值验证**：为检验关系式 $\\frac{d\\mathcal{R}}{d\\lambda_Q} \\approx \\langle \\hat{Q}_{20} \\rangle$，对 $\\lambda_Q \\pm \\Delta\\lambda$ 重复整个自洽计算。在这些点上的劳斯函数 $\\mathcal{R}(\\lambda_Q \\pm \\Delta\\lambda)$ 用于计算导数的中心差分近似。然后将此数值导数与中心点 $\\lambda_Q$ 处收敛的 $\\langle \\hat{Q}_{20} \\rangle$ 进行比较。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the constrained Hartree-Fock problem for a schematic model.\n    \"\"\"\n    # --- Problem Data ---\n    M = 6\n    N = 3\n    kappa = 0.25\n\n    h0 = np.diag([0.0, 0.9, 1.7, 2.8, 4.2, 6.0])\n    Q = np.array([\n        [-2.0, 0.20, 0.05, 0.0, 0.0, 0.0],\n        [0.20, -0.8, 0.20, 0.05, 0.0, 0.0],\n        [0.05, 0.20, 0.3, 0.20, 0.05, 0.0],\n        [0.0, 0.05, 0.20, 0.9, 0.20, 0.05],\n        [0.0, 0.0, 0.05, 0.20, 1.6, 0.20],\n        [0.0, 0.0, 0.0, 0.05, 0.20, 2.2]\n    ])\n\n    test_cases = [-0.8, -0.2, 0.0, 0.6]\n\n    # --- Solver Parameters ---\n    max_iterations = 10000\n    convergence_tau = 1.0e-10\n    mixing_alpha = 0.5\n    \n    # --- Derivative Check Parameters ---\n    delta_lambda = 1.0e-5\n    delta_check = 5.0e-5\n\n    def run_scf(lambda_q):\n        \"\"\"\n        Performs the self-consistent field iteration for a given lambda_q.\n        \"\"\"\n        # Initialization\n        rho_initial = np.zeros((M, M))\n        for i in range(N):\n            rho_initial[i, i] = 1.0\n        \n        q_in = np.trace(rho_initial @ Q)\n\n        for i in range(max_iterations):\n            h_eff = h0 - kappa * q_in * Q + lambda_q * Q\n            \n            eigenvalues, eigenvectors = np.linalg.eigh(h_eff)\n            \n            # Form new density matrix from lowest N states\n            occupied_vectors = eigenvectors[:, :N]\n            rho_new = occupied_vectors @ occupied_vectors.T\n            \n            q_out = np.trace(rho_new @ Q)\n            \n            if abs(q_out - q_in)  convergence_tau:\n                # Converged, return final quantities\n                final_q = q_out\n                final_rho = rho_new\n                final_s_p_energies = eigenvalues[:N]\n                return final_q, final_rho, final_s_p_energies\n\n            # Mix for next iteration\n            q_in = (1 - mixing_alpha) * q_in + mixing_alpha * q_out\n\n        # If loop finishes without convergence\n        raise RuntimeError(f\"SCF failed to converge for lambda_q = {lambda_q}\")\n\n    def calculate_routhian(lambda_q):\n        \"\"\"\n        Runs SCF and calculates the Routhian for a given lambda_q.\n        \"\"\"\n        q_conv, rho_conv, _ = run_scf(lambda_q)\n        \n        # Calculate HF energy\n        e_hf = np.trace(rho_conv @ h0) - (kappa / 2.0) * q_conv**2\n        \n        # Calculate Routhian\n        routhian = e_hf + lambda_q * q_conv\n        return routhian\n\n    results = []\n    for lambda_q_val in test_cases:\n        # Main calculation for the central lambda_q\n        q_converged, _, sp_energies = run_scf(lambda_q_val)\n\n        # Numerical derivative check\n        r_plus = calculate_routhian(lambda_q_val + delta_lambda)\n        r_minus = calculate_routhian(lambda_q_val - delta_lambda)\n        \n        dR_dlambda = (r_plus - r_minus) / (2.0 * delta_lambda)\n        \n        is_derivative_ok = 1 if abs(dR_dlambda - q_converged)  delta_check else 0\n        \n        # Format results\n        case_result = [\n            round(q_converged, 6),\n            round(sp_energies[0], 6),\n            round(sp_energies[1], 6),\n            round(sp_energies[2], 6),\n            is_derivative_ok\n        ]\n        results.append(case_result)\n\n    # Final output formatting\n    output_str = \"[\" + \",\".join([str(r) for r in results]) + \"]\"\n    output_str = output_str.replace(\"'\", \"\") # Clean up string representation of lists\n    print(output_str)\n\nsolve()\n```", "id": "3555808"}, {"introduction": "在掌握了基本自洽循环的实现后，我们向更真实的物理模型迈进。实际的核力（如Gogny力）通常是有限力程的，这导致Hartree-Fock方程中的交换项（Fock项）变为非定域的，从而使薛定谔方程变为一个复杂的积分-微分方程。这个练习将引导你处理这种非定域性，并应用高斯积分和低秩近似等关键数值方法，来高效地求解由有限力程相互作用产生的HF方程，这些技术是现代核物理计算的基石。[@problem_id:3555805]", "problem": "考虑一个由单粒子轨道的斯莱特行列式描述，并由一个具有有限程、中心二体相互作用的非相对论多体哈密顿量控制的核子系统。其目标是从第一性原理出发，推导哈特里-福克 (HF) 方程中的非局域交换核，并设计一种高效的计算策略来评估由此产生的积分算子。\n\n从以下基础出发：\n- 在第一量子化中，多体哈密顿量由下式给出\n$$\n\\hat{H}=\\sum_{i=1}^{A}\\hat{t}(i)+\\frac{1}{2}\\sum_{i\\neq j}\\hat{v}(i,j),\n$$\n其中 $A$ 是粒子数，$\\hat{t}(i)$ 是一体动能算子，$\\hat{v}(i,j)$ 是一个只依赖于相对坐标的、平移不变的有限程二体相互作用。\n- 基态由单个斯莱特行列式近似，并在单粒子轨道的正交归一约束下应用里兹变分原理。\n- 单体密度矩阵定义为\n$$\n\\rho(\\mathbf{r},\\mathbf{r}')=\\sum_{\\alpha \\in \\text{occ}} \\varphi_{\\alpha}(\\mathbf{r})\\,\\varphi_{\\alpha}^{*}(\\mathbf{r}'),\n$$\n其中求和遍及所有占据轨道。\n\n假设二体相互作用是有限程的，并且是 Gogny 类型的中心相互作用（此处限定为与自旋-同位旋无关的中心形式），\n$$\nv(\\mathbf{r}_1,\\mathbf{r}_2)=\\sum_{k=1}^{K} A_k \\exp\\!\\left(-\\frac{|\\mathbf{r}_1-\\mathbf{r}_2|^2}{\\mu_k^2}\\right),\n$$\n其中 $K\\in\\mathbb{N}$ 是高斯分量的数量，振幅 $A_k0$，程 $\\mu_k0$。\n\n任务：\n1. 仅使用上述基础，推导闭壳层情况下不含自旋-轨道或自旋-交换项的哈特里-福克方程的交换贡献。证明单粒子方程可以写成如下形式的积分-微分方程\n$$\n\\left[\\hat{t}+U_{\\mathrm{H}}(\\mathbf{r})\\right]\\varphi_i(\\mathbf{r})+\\int d^3\\mathbf{r}'\\,U(\\mathbf{r},\\mathbf{r}')\\,\\varphi_i(\\mathbf{r}')=\\varepsilon_i\\,\\varphi_i(\\mathbf{r}),\n$$\n识别所述有限程中心相互作用的非局域交换核 $U(\\mathbf{r},\\mathbf{r}')$，并用单体密度矩阵和 $v(\\mathbf{r},\\mathbf{r}')$ 明确表示它。不要假设任何已知的 HF 方程公式；从变分原理和斯莱特行列式的反对称性出发进行推导。\n2. 提出一种计算策略，以高效地评估非局域交换算子在给定测试函数上的作用：\n   - 简化为坐标为 $x\\in\\mathbb{R}$ 的一维模拟，为测试和验证保留相同的有限程中心结构 $g(x-x')=\\sum_{k=1}^{K} A_k \\exp\\left(-\\frac{(x-x')^2}{\\mu_k^2}\\right)$。\n   - 在有限区间 $[-X_{\\max},X_{\\max}]$ 上使用具有 $N$ 个节点的高斯求积法（高斯-勒让德）来近似积分。如果 $\\{\\xi_j,w_j^{(\\mathrm{GL})}\\}_{j=1}^{N}$ 是 $[-1,1]$ 上的高斯-勒让德节点和权重，将它们映射到 $x_j=X_{\\max}\\,\\xi_j$，权重为 $w_j=X_{\\max}\\,w_j^{(\\mathrm{GL})}$，以近似\n     $$\n     \\int_{-X_{\\max}}^{X_{\\max}} f(x)\\,dx \\approx \\sum_{j=1}^{N} w_j f(x_j).\n     $$\n   - 将占据轨道定义为归一化的一维谐振子本征函数，振子长度为 $b0$，\n     $$\n     \\phi_n(x)=\\frac{1}{\\sqrt{2^n n!}}\\frac{1}{\\pi^{1/4}\\,b^{1/2}}\\,H_n\\!\\left(\\frac{x}{b}\\right)\\exp\\!\\left(-\\frac{x^2}{2b^2}\\right),\\quad n\\in\\mathbb{N},\n     $$\n     其中 $H_n$ 是物理学家使用的埃尔米特多项式。取占据集为 $n\\in\\{0,1\\}$，并定义单体密度矩阵\n     $$\n     \\rho(x,x')=\\sum_{n\\in\\{0,1\\}} \\phi_n(x)\\,\\phi_n(x').\n     $$\n   - 使用你推导出的交换核表达式，构造一维的非局域交换核 $U(x,x')$，并通过高斯求积法近似交换作用在给定测试函数 $\\psi(x)$ 上的效果。\n   - 提出并实现一种离散化交换算子的低秩近似方法，该方法基于对由核和求积权重构建的对称半正定矩阵进行特征分解并截断。解释截断秩 $r\\in\\mathbb{N}$ 如何控制精度和成本，并提供由此产生的将算子高效应用于向量的公式。\n\n3. 按照下文“最终输出格式”的规定，在单个程序中实现以上内容。所有数值输出均为无量纲。\n\n你的程序要使用的测试套件：\n- 情况 $\\mathrm{A}$ (正常路径)：$N=80$, $X_{\\max}=8.0$, $b=1.2$, $K=2$, 相互作用参数 $\\{(A_1,\\mu_1),(A_2,\\mu_2)\\}=\\{(500.0,0.7),(300.0,1.3)\\}$, 截断秩 $r=6$。测试函数 $\\psi(x)=\\phi_2(x)+0.5\\,\\phi_3(x)$。输出直接求积法应用和低秩近似应用到 $\\psi$ 上的相对 $L^2$ 误差。\n- 情况 $\\mathrm{B}$ (边界：窄程)：$N=120$, $X_{\\max}=8.0$, $b=1.0$, $K=2$, 相互作用参数 $\\{(800.0,0.3),(200.0,0.6)\\}$, 截断秩 $r=10$。使用相同的 $\\psi(x)$。输出相对 $L^2$ 误差。\n- 情况 $\\mathrm{C}$ (极端：极低秩)：与情况 $\\mathrm{A}$ 相同，但截断秩 $r=1$。输出相对 $L^2$ 误差。\n- 情况 $\\mathrm{D}$ (一致性检查：对称性)：$N=60$, $X_{\\max}=6.0$, $b=1.0$, $K=2$, 相互作用参数 $\\{(500.0,0.7),(300.0,1.3)\\}$。计算比率\n  $$\n  \\frac{\\|U-U^{\\mathsf{T}}\\|_{\\mathrm{F}}}{\\|U\\|_{\\mathrm{F}}},\n  $$\n  其中 $U$ 是在求积节点上，其元素为 $U_{ij}=U(x_i,x_j)$ 的离散化核矩阵，$\\|\\cdot\\|_{\\mathrm{F}}$ 表示弗罗贝尼乌斯范数。输出此比率。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含按顺序排列的结果 $[\\text{情况A结果},\\text{情况B结果},\\text{情况C结果},\\text{情况D结果}]$，形式为方括号括起来的逗号分隔列表。所有输出均为无量纲实数。不涉及角度。不需要物理单位。程序不得读取任何输入，也不得打印任何其他内容。", "solution": "本任务旨在从第一性原理推导哈特里-福克 (HF) 方程的非局域交换项，并为其开发一种计算方法。我们首先进行推导，然后阐述数值策略。\n\n**第一部分：哈特里-福克交换核的推导**\n\n出发点是一个由 $A$ 个相同的非相对论费米子（核子）组成的系统，其哈密顿量在第一量子化中表示为：\n$$\n\\hat{H}=\\sum_{i=1}^{A}\\hat{t}(i)+\\frac{1}{2}\\sum_{i\\neq j}^{A}\\hat{v}(i,j)\n$$\n其中 $\\hat{t}(i) = -\\frac{\\hbar^2}{2m}\\nabla_i^2$ 是粒子 $i$ 的动能算子，$\\hat{v}(i,j)$ 是二体相互作用势。问题指定了一个中心、平移不变的相互作用，因此 $\\hat{v}(i,j) = v(|\\mathbf{r}_i - \\mathbf{r}_j|)$。按照指示，我们为简化起见，忽略了自旋和同位旋自由度。\n\n系统的基态由单个斯莱特行列式 $|\\Psi\\rangle$ 近似，该行列式由一组 $A$ 个正交归一的单粒子轨道 $\\{\\varphi_\\alpha(\\mathbf{r})\\}_{\\alpha=1}^A$ 构建：\n$$\n|\\Psi\\rangle = \\frac{1}{\\sqrt{A!}} \\det[\\varphi_{\\alpha_i}(\\mathbf{r}_j)]\n$$\n正交归一条件为 $\\langle\\varphi_\\alpha|\\varphi_\\beta\\rangle = \\int d^3\\mathbf{r}\\,\\varphi_\\alpha^*(\\mathbf{r})\\varphi_\\beta(\\mathbf{r}) = \\delta_{\\alpha\\beta}$。\n\n根据里兹变分原理，对基态能量和轨道的最佳近似是通过最小化能量期望值 $E = \\langle\\Psi|\\hat{H}|\\Psi\\rangle$（相对于轨道）并在正交归一约束下找到的。\n\n使用斯莱特-康登规则，斯莱特行列式的哈密顿量期望值为：\n$$\nE[\\{\\varphi_\\alpha\\}] = \\sum_{\\alpha=1}^{A} \\langle\\varphi_\\alpha|\\hat{t}|\\varphi_\\alpha\\rangle + \\frac{1}{2}\\sum_{\\alpha,\\beta=1}^{A} \\left( \\langle\\varphi_\\alpha\\varphi_\\beta|\\hat{v}|\\varphi_\\alpha\\varphi_\\beta\\rangle - \\langle\\varphi_\\alpha\\varphi_\\beta|\\hat{v}|\\varphi_\\beta\\varphi_\\alpha\\rangle \\right)\n$$\n第一项是总动能。第二项包含直接（哈特里）和交换（福克）相互作用能。以积分形式表示，能量泛函为：\n$$\nE = \\sum_{\\alpha} \\int d^3\\mathbf{r}\\,\\varphi_\\alpha^*(\\mathbf{r})\\hat{t}\\varphi_\\alpha(\\mathbf{r}) + \\frac{1}{2}\\sum_{\\alpha,\\beta} \\iint d^3\\mathbf{r}_1 d^3\\mathbf{r}_2\\, \\varphi_\\alpha^*(\\mathbf{r}_1)\\varphi_\\beta^*(\\mathbf{r}_2)v(\\mathbf{r}_1,\\mathbf{r}_2)[\\varphi_\\alpha(\\mathbf{r}_1)\\varphi_\\beta(\\mathbf{r}_2) - \\varphi_\\beta(\\mathbf{r}_1)\\varphi_\\alpha(\\mathbf{r}_2)]\n$$\n这里，我们利用了 $\\hat{v}$ 在坐标空间中是一个简单的局域乘法算子 $v(\\mathbf{r}_1, \\mathbf{r}_2)$ 的事实。\n\n为了在最小化过程中强制执行正交归一约束，我们引入一个拉格朗日乘子矩阵 $\\varepsilon_{\\alpha\\beta}$，并对泛函进行极值化：\n$$\nL[\\{\\varphi_\\alpha\\}] = E[\\{\\varphi_\\alpha\\}] - \\sum_{\\alpha,\\beta=1}^{A} \\varepsilon_{\\beta\\alpha} \\left( \\langle\\varphi_\\alpha|\\varphi_\\beta\\rangle - \\delta_{\\alpha\\beta} \\right)\n$$\n变分条件是 $L$ 对每个轨道（例如 $\\varphi_k^*$）的泛函导数为零：$\\frac{\\delta L}{\\delta \\varphi_k^*(\\mathbf{r})} = 0$ 对所有 $k \\in \\{1,\\dots,A\\}$ 成立。\n\n让我们计算每一项对 $\\varphi_k^*(\\mathbf{r})$ 的导数：\n1.  动能项：$\\frac{\\delta}{\\delta\\varphi_k^*(\\mathbf{r})} \\sum_{\\alpha} \\int d^3\\mathbf{r}'\\,\\varphi_\\alpha^*(\\mathbf{r}')\\hat{t}\\varphi_\\alpha(\\mathbf{r}') = \\hat{t}\\varphi_k(\\mathbf{r})$。\n2.  直接（哈特里）项：\n    $$\n    \\frac{\\delta}{\\delta\\varphi_k^*(\\mathbf{r})} \\frac{1}{2}\\sum_{\\alpha,\\beta} \\iint d^3\\mathbf{r}_1 d^3\\mathbf{r}_2\\, v(\\mathbf{r}_1,\\mathbf{r}_2)\\varphi_\\alpha^*(\\mathbf{r}_1)\\varphi_\\alpha(\\mathbf{r}_1)\\varphi_\\beta^*(\\mathbf{r}_2)\\varphi_\\beta(\\mathbf{r}_2)\n    $$\n    仅当 $\\alpha=k$ 时导数不为零。因子 $1/2$ 被抵消，因为求和在 $\\alpha, \\beta$ 上是对称的。我们得到：\n    $$\n    \\sum_{\\beta} \\int d^3\\mathbf{r}_2\\, v(\\mathbf{r},\\mathbf{r}_2)\\varphi_\\beta^*(\\mathbf{r}_2)\\varphi_\\beta(\\mathbf{r}_2) \\varphi_k(\\mathbf{r}) = \\left[ \\int d^3\\mathbf{r}'\\, v(\\mathbf{r},\\mathbf{r}') \\sum_{\\beta} |\\varphi_\\beta(\\mathbf{r}')|^2 \\right] \\varphi_k(\\mathbf{r})\n    $$\n    识别出局域密度 $\\rho(\\mathbf{r}') = \\sum_\\beta |\\varphi_\\beta(\\mathbf{r}')|^2$，此项变为 $U_{\\mathrm{H}}(\\mathbf{r})\\varphi_k(\\mathbf{r})$，其中 $U_{\\mathrm{H}}(\\mathbf{r}) = \\int d^3\\mathbf{r}'\\, v(\\mathbf{r},\\mathbf{r}') \\rho(\\mathbf{r}')$ 是局域哈特里势。\n3.  交换（福克）项：\n    $$\n    \\frac{\\delta}{\\delta\\varphi_k^*(\\mathbf{r})} \\left(-\\frac{1}{2}\\right)\\sum_{\\alpha,\\beta} \\iint d^3\\mathbf{r}_1 d^3\\mathbf{r}_2\\, v(\\mathbf{r}_1,\\mathbf{r}_2)\\varphi_\\alpha^*(\\mathbf{r}_1)\\varphi_\\beta(\\mathbf{r}_1)\\varphi_\\beta^*(\\mathbf{r}_2)\\varphi_\\alpha(\\mathbf{r}_2)\n    $$\n    对 $\\varphi_k^*(\\mathbf{r})$ 的导数在 $\\alpha=k$ 或 $\\beta=k$ 时有贡献。我们设 $\\alpha=k$。\n    $$\n    -\\sum_{\\beta} \\int d^3\\mathbf{r}_2\\, v(\\mathbf{r},\\mathbf{r}_2)\\varphi_\\beta(\\mathbf{r})\\varphi_\\beta^*(\\mathbf{r}_2)\\varphi_k(\\mathbf{r}_2) = -\\int d^3\\mathbf{r}'\\, v(\\mathbf{r},\\mathbf{r}') \\left(\\sum_{\\beta} \\varphi_\\beta(\\mathbf{r})\\varphi_\\beta^*(\\mathbf{r}')\\right) \\varphi_k(\\mathbf{r}')\n    $$\n    我们识别出单体密度矩阵 $\\rho(\\mathbf{r},\\mathbf{r}') = \\sum_{\\beta \\in \\text{occ}} \\varphi_\\beta(\\mathbf{r})\\varphi_\\beta^*(\\mathbf{r}')$。因此，交换项为：\n    $$\n    -\\int d^3\\mathbf{r}'\\, v(\\mathbf{r},\\mathbf{r}') \\rho(\\mathbf{r},\\mathbf{r}') \\varphi_k(\\mathbf{r}')\n    $$\n4.  约束项：$\\frac{\\delta}{\\delta\\varphi_k^*(\\mathbf{r})} \\left( -\\sum_{\\alpha,\\beta} \\varepsilon_{\\beta\\alpha} \\langle\\varphi_\\alpha|\\varphi_\\beta\\rangle \\right) = -\\sum_{\\beta} \\varepsilon_{\\beta k} \\varphi_\\beta(\\mathbf{r})$。\n\n将这些项组合起来，我们得到正则哈特里-福克方程：\n$$\n\\hat{t}\\varphi_k(\\mathbf{r}) + U_{\\mathrm{H}}(\\mathbf{r})\\varphi_k(\\mathbf{r}) - \\int d^3\\mathbf{r}'\\, v(\\mathbf{r},\\mathbf{r}') \\rho(\\mathbf{r},\\mathbf{r}') \\varphi_k(\\mathbf{r}') = \\sum_{\\beta} \\varepsilon_{\\beta k} \\varphi_\\beta(\\mathbf{r})\n$$\n拉格朗日乘子矩阵 $\\varepsilon_{\\beta k}$ 可以通过对轨道 $\\{\\varphi_\\alpha\\}$ 进行幺正变换来对角化，这会使总能量 $E$ 和密度矩阵 $\\rho$ 保持不变。在这个对角基中，$\\varepsilon_{\\beta k} = \\varepsilon_k \\delta_{\\beta k}$，并且每个轨道 $i$ 的方程变得独立：\n$$\n\\hat{t}\\varphi_i(\\mathbf{r}) + U_{\\mathrm{H}}(\\mathbf{r})\\varphi_i(\\mathbf{r}) - \\int d^3\\mathbf{r}'\\, v(\\mathbf{r},\\mathbf{r}') \\rho(\\mathbf{r},\\mathbf{r}') \\varphi_i(\\mathbf{r}') = \\varepsilon_i \\varphi_i(\\mathbf{r})\n$$\n通过将非局域交换核 $U(\\mathbf{r},\\mathbf{r}')$ 识别为：\n$$\nU(\\mathbf{r},\\mathbf{r}') = -v(\\mathbf{r},\\mathbf{r}') \\rho(\\mathbf{r},\\mathbf{r}')\n$$\n该方程与所要求的形式 $[\\hat{t}+U_{\\mathrm{H}}(\\mathbf{r})]\\varphi_i(\\mathbf{r})+\\int d^3\\mathbf{r}'\\,U(\\mathbf{r},\\mathbf{r}')\\,\\varphi_i(\\mathbf{r}')=\\varepsilon_i\\,\\varphi_i(\\mathbf{r})$ 相匹配。\n对于指定的中心相互作用 $v(\\mathbf{r},\\mathbf{r}')=v(|\\mathbf{r}-\\mathbf{r}'|)$ 以及实轨道 $\\varphi_\\alpha(\\mathbf{r})$（谐振子本征函数即是如此），密度矩阵 $\\rho(\\mathbf{r},\\mathbf{r}') = \\sum_\\alpha \\varphi_\\alpha(\\mathbf{r})\\varphi_\\alpha(\\mathbf{r}')$ 是对称的，即 $\\rho(\\mathbf{r},\\mathbf{r}')=\\rho(\\mathbf{r}',\\mathbf{r})$。由于 $v$ 也是对称的，交换核 $U(\\mathbf{r},\\mathbf{r}')$ 是对称的。\n\n**第二部分：交换算子的计算策略**\n\n交换算子 $\\hat{U}_X$ 作用于函数 $\\psi(\\mathbf{r})$ 的效果由以下积分给出：\n$$\n(\\hat{U}_X \\psi)(\\mathbf{r}) = \\int d^3\\mathbf{r}'\\, U(\\mathbf{r},\\mathbf{r}') \\psi(\\mathbf{r}')\n$$\n我们现在为其在一维 ($1$D) 模拟中的数值评估制定一个策略。所有量都是其 $3$D 对应物的直接模拟。核为 $U(x,x') = -g(x-x')\\rho(x,x')$，其中 $g(x-x')$ 是一维相互作用，$\\rho(x,x')$ 是一维单体密度矩阵。\n\n**离散化：** 主要的数值挑战是积分的评估。我们使用 $N$ 点高斯-勒让德求积法则对问题域 $[-X_{\\max}, X_{\\max}]$ 进行离散化。设 $\\{x_j, w_j\\}_{j=1}^N$ 是该区间上的求积节点和权重。$\\hat{U}_X$ 作用于测试函数 $\\psi(x)$ 并在节点 $x_i$ 处评估的值，记为 $\\chi(x_i) = (\\hat{U}_X \\psi)(x_i)$，近似为：\n$$\n\\chi(x_i) = \\int_{-X_{\\max}}^{X_{\\max}} U(x_i, x') \\psi(x') dx' \\approx \\sum_{j=1}^{N} w_j U(x_i, x_j) \\psi(x_j)\n$$\n这可以表示为一个矩阵-向量乘积。设 $\\mathbf{\\psi}$ 是元素为 $\\psi_j = \\psi(x_j)$ 的向量，$\\mathbf{\\chi}$ 是结果 $\\chi_i$ 的向量，$\\mathbf{U}$ 是元素为 $U_{ij} = U(x_i, x_j)$ 的矩阵。操作为 $\\mathbf{\\chi} = \\mathbf{U} (\\mathbf{w} \\odot \\mathbf{\\psi})$，其中 $\\mathbf{w}$ 是权重向量，$\\odot$ 表示逐元素乘法。这种“直接”应用的计算成本为 $O(N^2)$。\n\n**低秩近似：** 对于大的 $N$，$O(N^2)$ 的成本可能过高。一种更有效的方法是构建算子的低秩近似。核 $U(x,x')$ 是对称的，但离散化的算子矩阵 $M_{ij} = w_j U(x_i, x_j)$ 不是对称的。一个更好的出发点是对称化矩阵 $\\mathbf{S}$，其元素为：\n$$\nS_{ij} = \\sqrt{w_i} U(x_i, x_j) \\sqrt{w_j}\n$$\n该矩阵 $\\mathbf{S}$ 是实对称的。此外，它是负半定的。与核 $U(x,x')$ 相关的二次型为 $\\iint \\psi(x) U(x,x') \\psi(x') dx dx' = -\\iint \\psi(x) g(x-x') \\rho(x,x') \\psi(x') dx dx'$。由于 $g  0$ 且 $\\rho$ 是一个半正定核，所以 $U$ 是一个负半定核，其离散化 $\\mathbf{S}$ 是一个负半定矩阵。\n\n作为一个对称矩阵，$\\mathbf{S}$ 允许谱分解 $\\mathbf{S} = \\mathbf{V} \\mathbf{\\Lambda} \\mathbf{V}^T$，其中 $\\mathbf{V}$ 是一个由特征向量构成的正交矩阵 $(\\mathbf{V}^T\\mathbf{V} = \\mathbf{I})$，$\\mathbf{\\Lambda}$ 是一个由实数特征值 $\\lambda_k \\le 0$ 构成的对角矩阵。秩-$r$ 近似 $\\mathbf{S}^{(r)}$ 是通过仅保留与最大幅值特征值（即 $r$ 个最负的特征值）相对应的 $r$ 个特征对来构建的：\n$$\n\\mathbf{S}^{(r)} = \\sum_{k=1}^{r} \\lambda_k \\mathbf{v}_k \\mathbf{v}_k^T = \\mathbf{V}_r \\mathbf{\\Lambda}_r \\mathbf{V}_r^T\n$$\n其中 $\\mathbf{V}_r$ 是一个由前导特征向量组成的 $N \\times r$ 矩阵，$\\mathbf{\\Lambda}_r$ 是一个由前导特征值组成的 $r \\times r$ 对角矩阵。\n\n现在可以高效地计算算子的作用。直接作用可以重写为以 $\\mathbf{S}$ 表示的形式：\n$$\n\\chi_i = \\sum_j w_j \\frac{S_{ij}}{\\sqrt{w_i}\\sqrt{w_j}} \\psi_j = \\frac{1}{\\sqrt{w_i}} \\sum_j S_{ij} \\sqrt{w_j} \\psi_j\n$$\n令 $\\tilde{\\psi}_j = \\sqrt{w_j} \\psi_j$，则有 $\\chi_i = \\frac{1}{\\sqrt{w_i}} (\\mathbf{S}\\tilde{\\mathbf{\\psi}})_i$。低秩近似则为：\n$$\n\\chi_i^{(r)} = \\frac{1}{\\sqrt{w_i}} (\\mathbf{S}^{(r)}\\tilde{\\mathbf{\\psi}})_i = \\frac{1}{\\sqrt{w_i}} (\\mathbf{V}_r \\mathbf{\\Lambda}_r \\mathbf{V}_r^T \\tilde{\\mathbf{\\psi}})_i\n$$\n评估过程分步进行：\n1.  计算 $\\mathbf{c} = \\mathbf{V}_r^T \\tilde{\\mathbf{\\psi}}$ (成本 $O(rN)$)。\n2.  计算 $\\mathbf{d} = \\mathbf{\\Lambda}_r \\mathbf{c}$ (成本 $O(r)$)。\n3.  计算 $\\mathbf{f} = \\mathbf{V}_r \\mathbf{d}$ (成本 $O(rN)$)。\n4.  计算 $\\chi_i^{(r)} = f_i / \\sqrt{w_i}$ (成本 $O(N)$)。\n\n应用算子的总成本主要由步骤 1 和 3 决定，从而得到 $O(rN)$ 的总复杂度。只要可以用一个小的秩 $r \\ll N$ 获得良好的近似，这相对于直接的 $O(N^2)$ 方法是一个显著的改进。截断秩 $r$ 作为控制参数，在计算成本和准确性之间取得平衡。更大的 $r$ 会以更高的计算代价产生更准确的结果。寻找 $\\mathbf{V}_r$ 和 $\\mathbf{\\Lambda}_r$ 的初始奇异值分解 (SVD) 或特征分解的成本为 $O(N^3)$，但这是一次性的预计算，在迭代求解 HF 方程之前执行。", "answer": "```python\nimport numpy as np\nfrom scipy import special\n\n# The problem statement requires numpy 1.23.5 and scipy 1.11.4.\n# np.polynomial.hermite.hermval is suitable for this numpy version.\n# math.factorial can be slow, so scipy.special.factorial is preferred.\n\ndef solve():\n    \"\"\"\n    Solves the four test cases for the Hartree-Fock exchange kernel problem.\n    \"\"\"\n\n    def hermite_poly(n, x):\n        \"\"\"\n        Computes the physicists' Hermite polynomial H_n(x).\n        Uses numpy's dedicated function for robust and efficient evaluation.\n        \"\"\"\n        coeffs = [0.0] * n + [1.0]\n        # np.polynomial.hermite.hermval is the modern way, but for older numpy\n        # it might on a different path. This is compatible with 1.23.5.\n        from numpy.polynomial.hermite import hermval\n        if isinstance(x, np.ndarray):\n            return hermval(x, coeffs)\n        return hermval(np.array([x]), coeffs)[0]\n\n    def ho_eigenfunction(n, x, b):\n        \"\"\"\n        Computes the normalized 1D harmonic oscillator eigenfunction phi_n(x).\n        \"\"\"\n        # Normalization constant N_n = 1 / sqrt(2^n * n! * b * sqrt(pi))\n        try:\n            norm_factor = 1.0 / np.sqrt(2**n * special.factorial(n) * b * np.sqrt(np.pi))\n        except (ValueError, OverflowError): # handles large n\n             # Log-gamma for stable factorial calculation\n            log_norm = -0.5 * (n * np.log(2) + special.gammaln(n + 1) + np.log(b) + 0.5 * np.log(np.pi))\n            norm_factor = np.exp(log_norm)\n            \n        x_scaled = x / b\n        return norm_factor * hermite_poly(n, x_scaled) * np.exp(-0.5 * x_scaled**2)\n\n    def calculate_case(N, Xmax, b, interaction_params, r, case_type):\n        \"\"\"\n        Main logic to compute the result for a single test case.\n        \"\"\"\n        # 1. Get Gauss-Legendre quadrature grid and weights\n        xi, w_gl = np.polynomial.legendre.leggauss(N)\n        x_grid = Xmax * xi\n        w_quad = Xmax * w_gl\n\n        # 2. Build the nonlocal kernel matrix U(x_i, x_j)\n        # 2a. Density matrix rho(x_i, x_j)\n        phi0_vec = ho_eigenfunction(0, x_grid, b)\n        phi1_vec = ho_eigenfunction(1, x_grid, b)\n        rho = np.outer(phi0_vec, phi0_vec) + np.outer(phi1_vec, phi1_vec)\n\n        # 2b. Interaction g(x_i - x_j)\n        x_diff_sq = np.subtract.outer(x_grid, x_grid)**2\n        g = np.zeros((N, N), dtype=float)\n        for Ak, muk in interaction_params:\n            g += Ak * np.exp(-x_diff_sq / (muk**2))\n\n        # 2c. Full kernel matrix U(x_i, x_j)\n        U_matrix = -g * rho\n\n        # 3. Handle specific case logic\n        if case_type == 'symmetry':\n            # Case D: Compute Frobenius norm ratio for symmetry check\n            norm_U = np.linalg.norm(U_matrix, 'fro')\n            norm_diff = np.linalg.norm(U_matrix - U_matrix.T, 'fro')\n            return norm_diff / norm_U if norm_U > 0 else 0.0\n\n        # For cases A, B, C (error calculation)\n        # 4. Construct the test function psi(x) on the grid\n        phi2_vec = ho_eigenfunction(2, x_grid, b)\n        phi3_vec = ho_eigenfunction(3, x_grid, b)\n        psi_vec = phi2_vec + 0.5 * phi3_vec\n    \n        # 5. Direct application of the exchange operator\n        # chi_i = sum_j w_j * U_ij * psi_j\n        chi_direct_vec = U_matrix @ (w_quad * psi_vec)\n\n        # 6. Low-rank approximation\n        # 6a. Symmetrize the kernel\n        sqrt_w = np.sqrt(w_quad)\n        S_matrix = np.outer(sqrt_w, sqrt_w) * U_matrix\n        \n        # 6b. Eigendecomposition. eigh returns eigenvalues in ascending order.\n        # Since kernel is negative-semidefinite, the most negative eigenvalues\n        # have the largest magnitude and are at the beginning of the sorted array.\n        eigvals, eigvecs = np.linalg.eigh(S_matrix)\n        \n        # 6c. Truncate to rank r\n        lambda_r = eigvals[:r]\n        V_r = eigvecs[:, :r]\n\n        # 6d. Apply low-rank operator\n        psi_tilde = sqrt_w * psi_vec\n        c_vec = V_r.T @ psi_tilde\n        d_vec = lambda_r * c_vec\n        f_vec = V_r @ d_vec\n        chi_low_rank_vec = f_vec / sqrt_w\n\n        # 7. Compute relative L2 error\n        delta_vec = chi_direct_vec - chi_low_rank_vec\n        norm_sq_delta = np.sum(w_quad * delta_vec**2)\n        norm_sq_chi = np.sum(w_quad * chi_direct_vec**2)\n        \n        if norm_sq_chi == 0:\n            return 0.0\n            \n        rel_error = np.sqrt(norm_sq_delta / norm_sq_chi)\n        return rel_error\n\n    # Define test cases from the problem statement\n    test_cases = [\n        {'N': 80, 'Xmax': 8.0, 'b': 1.2, 'params': [(500.0, 0.7), (300.0, 1.3)], 'r': 6, 'type': 'error'},\n        {'N': 120, 'Xmax': 8.0, 'b': 1.0, 'params': [(800.0, 0.3), (200.0, 0.6)], 'r': 10, 'type': 'error'},\n        {'N': 80, 'Xmax': 8.0, 'b': 1.2, 'params': [(500.0, 0.7), (300.0, 1.3)], 'r': 1, 'type': 'error'},\n        {'N': 60, 'Xmax': 6.0, 'b': 1.0, 'params': [(500.0, 0.7), (300.0, 1.3)], 'r': -1, 'type': 'symmetry'},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_case(case['N'], case['Xmax'], case['b'], case['params'], case['r'], case['type'])\n        results.append(result)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "3555805"}, {"introduction": "最后一个练习将介绍一种极为强大和现代的计算范式：自动微分（Automatic Differentiation, AD）。在传统的Hartree-Fock计算中，对于每一种新的能量密度泛函（EDF），我们都需要手动推导其对应的单粒子势场，这一过程繁琐且容易出错。本练习将向你展示如何构建一个AD框架，以纯计算的方式自动获得能量泛函的导数，即平均场势。掌握这一技术，意味着你将能够高效地测试和开发新的能量密度泛函，极大推动理论模型的发展。[@problem_id:3555825]", "problem": "要求您在用于原子核Hartree-Fock的能量密度泛函（EDF）理论背景下，推导、离散化并自动微分一个一维周期性系统的单粒子场。目标是构建一个计算方案，该方案在给定一个离散化的密度场时，返回总能量关于离散密度的离散梯度，该梯度代表了泛函导数 $h[\\rho] = \\delta E / \\delta \\rho$ 的离散对应物。您的推导和实现必须基于变分法的第一性原理，并采用适合计算的离散表示。\n\n定义与设置：\n- 考虑一个由 $N$ 个网格点表示的一维环（周期性区域），其均匀格点间距为 $\\Delta x$。设离散密度为向量 $\\boldsymbol{\\rho} = (\\rho_0,\\rho_1,\\dots,\\rho_{N-1})$，它在网格点 $x_i = i \\Delta x$ 处近似连续密度 $\\rho(x)$。周期性边界条件强制 $\\rho_{i+N} = \\rho_i$。\n- 考虑具有一般EDF形式 $E[\\rho,\\tau,\\mathbf{J},\\nabla \\rho,\\dots]$ 的能量泛函，但仅限于一个只使用 $\\rho$ 和 $\\nabla \\rho$ 的离散原型，即一个能量泛函，它是一个局域项和一个梯度平方项之和的黎曼和离散化形式：\n$$\nE_D[\\boldsymbol{\\rho}] = \\sum_{i=0}^{N-1} \\Delta x\\,\\Big( a\\,\\rho_i^2 + b\\,\\rho_i^3 \\Big) \\;+\\; \\sum_{i=0}^{N-1} \\Delta x\\, c\\, \\big( D \\rho \\big)_i^2,\n$$\n其中 $(D \\rho)_i$ 是 $\\partial_x \\rho$ 在周期性边界条件下的离散中心差分近似：\n$$\n(D \\rho)_i \\equiv \\frac{\\rho_{i+1} - \\rho_{i-1}}{2\\,\\Delta x}.\n$$\n这里 $a$、$b$ 和 $c$ 是常数。\n\n任务：\n- 根据泛函导数的定义和驻定作用量原理，为上述 $E_D[\\boldsymbol{\\rho}]$ 从第一性原理出发推导离散梯度 $\\partial E_D/\\partial \\rho_i$。也就是说，从变分 $\\delta \\rho_i$ 的定义和离散分部求和法开始，计算在周期性边界条件下局域项和梯度平方项的离散变分导数。不要假设任何“捷径”公式；请推导离散的欧拉-拉格朗日表达式。\n- 设计并实现一个专用于多变量标量泛函的反向模式自动微分方案。您的方案必须：\n  - 将每个标量变量表示为一个携带值和伴随（梯度累加器）的节点。\n  - 跟踪一个由基本运算（加法、减法、乘法、标量幂）和一个求和归约组成的计算图。\n  - 支持一个线性周期性中心差分算子 $D$，该算子逐元素作用于变量向量。\n  - 从标量能量 $E_D$ 调用反向传播过程时，将伴随传播回输入 $\\rho_i$，以产生梯度向量 $g_i = \\partial E_D / \\partial \\rho_i$。\n- 针对下面测试套件中指定的每个示例泛函，您必须推导其解析离散梯度，并用其验证您的自动微分梯度。每个测试用例的验证指标是最大绝对误差\n$$\n\\varepsilon_{\\max} = \\max_{i} \\left| g^{(\\mathrm{AD})}_i - g^{(\\mathrm{analytic})}_i \\right|.\n$$\n\n测试套件：\n提供一个程序，为以下三个测试用例计算自动微分梯度和推导出的解析离散梯度，然后按下述规定，将三个 $\\varepsilon_{\\max}$ 值输出到单行中。\n\n- 测试A（仅局域项泛函）：\n  - $N = 8$，$\\Delta x = 0.5$， $a = 1.1$， $b = -0.7$， $c = 0$。\n  - 密度：$\\rho_i$ 是一个在 $N$ 个点上从 $0.05$ 到 $0.40$（含两端）线性间隔的分布。\n- 测试B（仅梯度项泛函；常数密度边缘情况）：\n  - $N = 10$，$\\Delta x = 0.3$， $a = 0$， $b = 0$， $c = 0.6$。\n  - 密度：对于所有 $i$，$\\rho_i = 0.2$。\n- 测试C（组合泛函；周期性非平凡模式）：\n  - $N = 12$，$\\Delta x = 0.2$， $a = 0.8$， $b = 0.3$， $c = 0.4$。\n  - 密度：对于 $i = 0,1,\\dots,N-1$，$\\rho_i = \\sin( 2\\pi i / N ) + 0.5 \\cos( 4\\pi i / N )$。\n\n输出规范：\n- 您的程序必须按顺序计算测试A、B和C的三个 $\\varepsilon_{\\max}$ 值，每个值都应为具有精确12位有效数字的科学记数法浮点数。\n- 您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如：\n\"[1.234567890123e-12,2.345678901235e-13,3.456789012346e-12]\".\n- 此问题不需要物理单位，并且在出现角度时，必须以弧度为单位进行解释。\n\n约束条件：\n- 您的推导必须从泛函导数的定义和周期性边界条件下的离散分部求和法开始，而不是从任何预先记下的公式开始。\n- 自动微分方案必须由您自己编码，并且不得依赖任何外部自动微分库。\n- 运行环境仅限于带有基础数值库的Python；有关确切的约束，请参阅最终答案规范。\n\n您的程序应实现上述内容，并仅打印指定的单行输出。", "solution": "该问题要求我们针对一个由简单能量密度泛函（EDF）描述的一维周期性系统，推导、离散化并实现一个用于单粒子场 $h[\\rho] = \\delta E / \\delta \\rho$ 的自动微分（AD）方案。我们必须首先推导离散梯度的解析形式，然后开发一个定制的反向模式AD框架来数值计算相同的梯度。最后，我们将AD结果与解析结果进行验证。\n\n### 解析离散梯度的推导\n\n目标是为给定的离散能量泛函 $E_D[\\boldsymbol{\\rho}]$ 计算其离散泛函导数，即梯度 $g_j = \\partial E_D / \\partial \\rho_j$。梯度是通过能量的一阶变分 $\\delta E_D$ 来定义的，该变分是相对于密度的一个小的、任意的微扰 $\\delta \\boldsymbol{\\rho} = (\\delta \\rho_0, \\delta \\rho_1, \\dots, \\delta \\rho_{N-1})$ 而言的：\n$$ \\delta E_D = \\sum_{j=0}^{N-1} \\frac{\\partial E_D}{\\partial \\rho_j} \\delta \\rho_j $$\n所提供的能量泛函是一个局域项 $E_{\\text{loc}}$ 和一个梯度项 $E_{\\text{grad}}$ 的和：\n$$ E_D[\\boldsymbol{\\rho}] = E_{\\text{loc}}[\\boldsymbol{\\rho}] + E_{\\text{grad}}[\\boldsymbol{\\rho}] $$\n其中\n$$ E_{\\text{loc}}[\\boldsymbol{\\rho}] = \\sum_{i=0}^{N-1} \\Delta x\\,\\Big( a\\,\\rho_i^2 + b\\,\\rho_i^3 \\Big) $$\n$$ E_{\\text{grad}}[\\boldsymbol{\\rho}] = \\sum_{i=0}^{N-1} \\Delta x\\, c\\, \\big( D \\rho \\big)_i^2 $$\n根据导数的线性性质，我们可以分别计算每一部分的梯度。\n\n**1. 局域项 $E_{\\text{loc}}$ 的梯度**\n\n局域项 $E_{\\text{loc}}$ 是一个和式，其中每一项仅依赖于单个 $\\rho_i$。对于特定的 $\\rho_j$ 求导时，只有求和中 $i=j$ 的那一项才不为零。\n$$\n\\frac{\\partial E_{\\text{loc}}}{\\partial \\rho_j} = \\frac{\\partial}{\\partial \\rho_j} \\left[ \\sum_{i=0}^{N-1} \\Delta x\\,\\Big( a\\,\\rho_i^2 + b\\,\\rho_i^3 \\Big) \\right] = \\Delta x \\, \\frac{d}{d\\rho_j} \\Big( a\\,\\rho_j^2 + b\\,\\rho_j^3 \\Big)\n$$\n$$\n\\frac{\\partial E_{\\text{loc}}}{\\partial \\rho_j} = \\Delta x \\, \\Big( 2a\\,\\rho_j + 3b\\,\\rho_j^2 \\Big)\n$$\n\n**2. 梯度项 $E_{\\text{grad}}$ 的梯度**\n\n梯度项通过离散微分算子 $(D\\rho)_i$ 引入了最近邻耦合。我们将从变分 $\\delta E_{\\text{grad}}$ 开始，使用离散分部求和法的原理。\n$$\nE_{\\text{grad}} = \\sum_{i=0}^{N-1} \\Delta x\\, c\\, \\left( \\frac{\\rho_{i+1} - \\rho_{i-1}}{2\\,\\Delta x} \\right)^2 = \\frac{c}{4\\,\\Delta x} \\sum_{i=0}^{N-1} (\\rho_{i+1} - \\rho_{i-1})^2\n$$\n一阶变分为：\n$$\n\\delta E_{\\text{grad}} = \\frac{c}{4\\,\\Delta x} \\sum_{i=0}^{N-1} 2\\,(\\rho_{i+1} - \\rho_{i-1}) \\, \\delta(\\rho_{i+1} - \\rho_{i-1}) = \\frac{c}{2\\,\\Delta x} \\sum_{i=0}^{N-1} (\\rho_{i+1} - \\rho_{i-1}) (\\delta\\rho_{i+1} - \\delta\\rho_{i-1})\n$$\n我们展开乘积并拆分求和：\n$$\n\\delta E_{\\text{grad}} = \\frac{c}{2\\,\\Delta x} \\left[ \\sum_{i=0}^{N-1} (\\rho_{i+1} - \\rho_{i-1}) \\delta\\rho_{i+1} - \\sum_{i=0}^{N-1} (\\rho_{i+1} - \\rho_{i-1}) \\delta\\rho_{i-1} \\right]\n$$\n为了分离出通用项 $\\delta\\rho_j$ 的系数，我们通过重新索引求和来进行离散分部求和。由于周期性边界条件，索引被视为模 $N$。\n\n对于第一个和式，令 $j = i+1$。这意味着 $i = j-1$。当 $i$ 从 $0$ 遍历到 $N-1$ 时，$j$ 从 $1$ 遍历到 $N$，在周期性条件下这等价于从 $0$ 遍历到 $N-1$。\n$$\n\\sum_{i=0}^{N-1} (\\rho_{i+1} - \\rho_{i-1}) \\delta\\rho_{i+1} = \\sum_{j=0}^{N-1} (\\rho_{j} - \\rho_{j-2}) \\delta\\rho_{j}\n$$\n对于第二个和式，令 $j = i-1$。这意味着 $i = j+1$。当 $i$ 从 $0$ 遍历到 $N-1$ 时，$j$ 从 $-1$ 遍历到 $N-2$，在周期性条件下这也等价于从 $0$ 遍历到 $N-1$。\n$$\n\\sum_{i=0}^{N-1} (\\rho_{i+1} - \\rho_{i-1}) \\delta\\rho_{i-1} = \\sum_{j=0}^{N-1} (\\rho_{j+2} - \\rho_{j}) \\delta\\rho_{j}\n$$\n将这些重新索引的和式代回到 $\\delta E_{\\text{grad}}$ 的表达式中：\n$$\n\\delta E_{\\text{grad}} = \\frac{c}{2\\,\\Delta x} \\sum_{j=0}^{N-1} \\left[ (\\rho_{j} - \\rho_{j-2}) - (\\rho_{j+2} - \\rho_{j}) \\right] \\delta\\rho_{j}\n$$\n$$\n\\delta E_{\\text{grad}} = \\sum_{j=0}^{N-1} \\left[ \\frac{c}{2\\,\\Delta x} (2\\rho_j - \\rho_{j+2} - \\rho_{j-2}) \\right] \\delta\\rho_j\n$$\n通过将其与定义 $\\delta E_{\\text{grad}} = \\sum_j (\\partial E_{\\text{grad}}/\\partial \\rho_j) \\delta\\rho_j$ 进行比较，我们确定梯度为：\n$$\n\\frac{\\partial E_{\\text{grad}}}{\\partial \\rho_j} = \\frac{c}{2\\,\\Delta x} (2\\rho_j - \\rho_{j+2} - \\rho_{j-2})\n$$\n这可以写成一个在交错网格上的二阶导数算子的五点模板形式：\n$$\n\\frac{\\partial E_{\\text{grad}}}{\\partial \\rho_j} = - \\frac{c}{2\\,\\Delta x} (\\rho_{j+2} - 2\\rho_j + \\rho_{j-2})\n$$\n\n**3. 总解析梯度**\n\n结合局域项和梯度项的贡献，总的离散梯度为：\n$$\ng_j^{(\\text{analytic})} = \\frac{\\partial E_D}{\\partial \\rho_j} = \\Delta x \\, \\Big( 2a\\,\\rho_j + 3b\\,\\rho_j^2 \\Big) - \\frac{c}{2\\,\\Delta x} (\\rho_{j+2} - 2\\rho_j + \\rho_{j-2})\n$$\n索引 $j+2$ 和 $j-2$ 在周期性边界条件下进行计算，即模 $N$。\n\n### 自动微分方案\n\n我们实现一个反向模式自动微分（AD）方案。这涉及两个主要阶段：一个用于构建计算图并计算最终标量值的前向传播过程，以及一个用于将梯度从输出传播回输入的反向传播过程。\n\n**1. 计算图**\n\n计算中的每个标量变量由一个 `Node` 对象表示。一个 `Node` 存储：\n- `value`：运算的标量结果。\n- `grad`：伴随或梯度 $\\partial E_D / \\partial(\\text{value})$，初始化为 $0.0$。\n- `_prev`：一个 `Node` 对象集合，它们是创建此 `Node` 的运算的输入（子节点）。\n- `_backward`：一个为该运算实现链式法则的函数，它将 `Node` 自身的梯度传播到其子节点的梯度。\n\n`Node` 类重载了标准算术运算符（`+`, `*`, `**` 等）。当对 `Node` 对象执行 `c = a + b` 这样的运算时，会创建一个新的 `Node` `c`。它的 `value` 被计算出来，其子节点 `_prev` 被设置为 `{a, b}`，并且其 `_backward` 函数被定义为执行 `a.grad += c.grad` 和 `b.grad += c.grad`。这个过程动态地构建了一个有向无环图（DAG），表示从输入密度 $\\rho_i$ 到最终能量 $E_D$ 的计算过程。\n\n**2. 复合算子**\n\n求和与离散导数 `D` 被作为作用于 `Node` 向量的复合运算来处理。\n- `sum_nodes(nodes)`：接受一个 `Node` 列表，计算它们的和，并返回一个单一的输出 `Node`。它的反向传播过程将输出 `Node` 的梯度加到每个输入 `Node` 的梯度上。\n- `D_op(rho_nodes, delta_x)`：接受一个表示 $\\boldsymbol{\\rho}$ 的 `Node` 列表，并返回一个表示 $(D\\boldsymbol{\\rho})$ 的 `Node` 列表。每个输出节点 $(D\\boldsymbol{\\rho})_i$ 都是使用重载的运算符构建的：`(rho_nodes[i+1] - rho_nodes[i-1]) / (2 * delta_x)`。因此，这个线性变换的图结构是自动构建的。\n\n**3. 反向传播过程**\n\n反向传播过程计算梯度 $\\partial E_D / \\partial \\rho_i$，并由函数调用 `backward(E_D_node)` 触发。\n1.  **拓扑排序**：该函数首先从最终能量 `Node` $E_D$ 开始，对计算图进行拓扑排序。这会生成一个有序列表，其中包含所有对最终结果有贡献的 `Node`。\n2.  **梯度传播**：排序列表中所有节点的梯度都被重置为 $0.0$。最终 `Node` $E_D$ 的梯度被置为种子值 $1.0$（因为 $\\partial E_D / \\partial E_D = 1$）。然后，算法以逆拓扑顺序遍历列表，为每个 `Node` 调用 `_backward` 函数。这确保了当一个 `Node` 的梯度传播到其子节点时，该 `Node` 自身的梯度已经从图中所有其父节点完全累积起来。\n3.  **结果**：传播过程完成后，每个初始输入 `Node` $\\rho_i$ 的 `grad` 属性就包含了所需的梯度 $g_i^{(\\text{AD})} = \\partial E_D / \\partial \\rho_i$。\n\n然后使用这个定制构建的AD机制来计算测试用例的梯度，并将结果与解析公式进行比较以验证其正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A custom, minimalist reverse-mode automatic differentiation engine.\n\nclass Node:\n    \"\"\"\n    A Node in the computational graph. It holds a scalar value, its gradient\n    (adjoint), and the logic to backpropagate gradients to its children.\n    \"\"\"\n    def __init__(self, value, _children=(), _op=''):\n        self.value = float(value)\n        self.grad = 0.0\n        # _prev holds the nodes that this node was computed from.\n        self._prev = set(_children)\n        # _backward is a function to propagate this node's grad to its children.\n        self._backward = lambda: None\n        self._op = _op\n\n    def __repr__(self):\n        return f\"Node(value={self.value:.4f}, grad={self.grad:.4f})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Node) else Node(other)\n        out = Node(self.value + other.value, _children=(self, other), _op='+')\n        def _backward():\n            self.grad += 1.0 * out.grad\n            other.grad += 1.0 * out.grad\n        out._backward = _backward\n        return out\n\n    def __mul__(self, other):\n        other = other if isinstance(other, Node) else Node(other)\n        out = Node(self.value * other.value, _children=(self, other), _op='*')\n        def _backward():\n            self.grad += other.value * out.grad\n            other.grad += self.value * out.grad\n        out._backward = _backward\n        return out\n\n    def __pow__(self, n):\n        assert isinstance(n, (int, float)), \"Power must be a scalar number.\"\n        out = Node(self.value ** n, _children=(self,), _op=f'**{n}')\n        def _backward():\n            # Handle 0^(n-1) where n-1  0\n            self_val_is_zero = abs(self.value)  1e-9 and n-1  0\n            grad_val = (n * self.value**(n-1)) if not self_val_is_zero else 0.0\n            self.grad += grad_val * out.grad\n        out._backward = _backward\n        return out\n\n    def __neg__(self):\n        return self * -1\n\n    def __sub__(self, other):\n        return self + (-other)\n    \n    def __rsub__(self, other):\n        other = other if isinstance(other, Node) else Node(other)\n        return other - self\n\n    __radd__ = __add__\n    __rmul__ = __mul__\n\n\ndef backward(final_node: Node):\n    \"\"\"\n    Performs the backward pass to compute gradients for all nodes\n    in the graph culminating in `final_node`.\n    \"\"\"\n    # 1. Perform topological sort of the graph.\n    topo = []\n    visited = set()\n    def build_topo(v):\n        if v not in visited:\n            visited.add(v)\n            for child in v._prev:\n                build_topo(child)\n            topo.append(v)\n    \n    build_topo(final_node)\n\n    # 2. Reset gradients and initialize the final node's gradient.\n    for n in topo:\n        n.grad = 0.0\n    final_node.grad = 1.0\n\n    # 3. Propagate gradients in reverse topological order.\n    for v in reversed(topo):\n        v._backward()\n\n# --- Helper functions for AD ---\n\ndef sum_nodes(nodes):\n    \"\"\"Creates a Node representing the sum of a list of Nodes.\"\"\"\n    if not nodes:\n        return Node(0.0)\n    total_val = sum(n.value for n in nodes)\n    out = Node(total_val, _children=tuple(nodes), _op='sum')\n    def _backward():\n        for n in nodes:\n            n.grad += out.grad\n    out._backward = _backward\n    return out\n\ndef D_op(rho_nodes, delta_x):\n    \"\"\"Applies the periodic central difference operator D to a list of Nodes.\"\"\"\n    N = len(rho_nodes)\n    d_rho_nodes = []\n    const = 1.0 / (2.0 * delta_x)\n    for i in range(N):\n        rho_p1 = rho_nodes[(i + 1) % N]\n        rho_m1 = rho_nodes[(i - 1 + N) % N]\n        # This reuses overloaded operators, building the graph automatically.\n        d_rho_i = (rho_p1 - rho_m1) * const\n        d_rho_nodes.append(d_rho_i)\n    return d_rho_nodes\n\n\ndef solve():\n    \"\"\"Main function to run test cases and produce the final output.\"\"\"\n    test_cases = [\n        {\n            \"id\": \"A\", \"N\": 8, \"dx\": 0.5, \"a\": 1.1, \"b\": -0.7, \"c\": 0,\n            \"rho_func\": lambda N: np.linspace(0.05, 0.40, N)\n        },\n        {\n            \"id\": \"B\", \"N\": 10, \"dx\": 0.3, \"a\": 0, \"b\": 0, \"c\": 0.6,\n            \"rho_func\": lambda N: np.full(N, 0.2)\n        },\n        {\n            \"id\": \"C\", \"N\": 12, \"dx\": 0.2, \"a\": 0.8, \"b\": 0.3, \"c\": 0.4,\n            \"rho_func\": lambda N: np.sin(2*np.pi*np.arange(N)/N) + 0.5*np.cos(4*np.pi*np.arange(N)/N)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N, dx, a, b, c = case['N'], case['dx'], case['a'], case['b'], case['c']\n        rho_vals = case['rho_func'](N)\n\n        # --- 1. Analytic Gradient Calculation ---\n        grad_analytic = np.zeros(N)\n        # Local part\n        grad_loc = dx * (2 * a * rho_vals + 3 * b * rho_vals**2)\n        # Gradient part\n        if c != 0:\n            rho_p2 = np.roll(rho_vals, -2)\n            rho_m2 = np.roll(rho_vals, 2)\n            grad_grad = (c / (2 * dx)) * (2 * rho_vals - rho_p2 - rho_m2)\n        else:\n            grad_grad = np.zeros(N)\n        grad_analytic = grad_loc + grad_grad\n\n        # --- 2. Automatic Differentiation Gradient Calculation ---\n        # Create input nodes\n        rho_nodes = [Node(val) for val in rho_vals]\n        \n        # Build the graph for E_D\n        E_loc = Node(0.0)\n        if a != 0 or b != 0:\n            terms_loc = [dx * (a * r**2 + b * r**3) for r in rho_nodes]\n            E_loc = sum_nodes(terms_loc)\n\n        E_grad = Node(0.0)\n        if c != 0:\n            d_rho = D_op(rho_nodes, dx)\n            terms_grad = [dx * c * (d**2) for d in d_rho]\n            E_grad = sum_nodes(terms_grad)\n            \n        E_total = E_loc + E_grad\n\n        # Perform backpropagation\n        backward(E_total)\n        \n        grad_ad = np.array([node.grad for node in rho_nodes])\n\n        # --- 3. Validation ---\n        max_error = np.max(np.abs(grad_ad - grad_analytic))\n        # Format to 12 digits of precision in scientific notation\n        results.append(f\"{max_error:.12e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3555825"}]}