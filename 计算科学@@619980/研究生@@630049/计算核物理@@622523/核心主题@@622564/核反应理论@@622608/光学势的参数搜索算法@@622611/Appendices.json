{"hands_on_practices": [{"introduction": "本节的第一个练习将光学势的抽象概念与一个具体的计算任务相结合。我们将计算一个关键的物理观测量——体积积分，然后使用简单的二分法搜索来寻找能够再现目标值的势参数。这项实践旨在构建数值积分的基本技能，并引入通过最小化目标函数来进行参数估计的核心思想。[@problem_id:3578612]", "problem": "你的任务是开发一个完整的程序，用于实现球对称原子核中光学模型势中心实部的数值计算和一个简单的参数搜索算法。从球对称中心实光学势的物理标准定义（由 Woods–Saxon 形式给出）及其体积积分的定义开始。目标是计算体积积分，并在指定情况下，通过搜索过程匹配一个目标体积积分值，从而推断出深度参数。所有物理量都必须以科学上一致的方式处理，并带有明确的单位。\n\n基本原理：\n- 光学模型通过一个等效复势来处理核子-原子核相互作用。对于其中心实部，一种常见的形式是 Woods–Saxon 势，它被定义为径向坐标 $r$ 的函数：\n$$\nV(r) = -\\frac{V_0}{1 + \\exp\\left(\\frac{r - R}{a}\\right)} \\, ,\n$$\n其中，$V_0$ 是以 $\\mathrm{MeV}$ 为单位的正深度参数，$a$ 是以 $\\mathrm{fm}$ 为单位的弥散度参数，$R$ 是核半径参数，由 $R = r_0 A^{1/3}$ 给出，其中 $A$ 是质量数（无量纲），$r_0$ 的单位为 $\\mathrm{fm}$。\n- 中心实部的体积积分 $J_V$ 定义为\n$$\nJ_V = \\int_{\\mathbb{R}^3} V(\\mathbf{r}) \\, d^3\\mathbf{r} = 4\\pi \\int_{0}^{\\infty} V(r) \\, r^2 \\, dr \\, ,\n$$\n其单位为 $\\mathrm{MeV \\, fm^3}$。对于采用常规符号约定的吸引型 Woods–Saxon 势，$J_V$ 为负值。该量是衡量平均场相互作用积分强度的标准度量。\n\n任务：\n1. 在均匀的径向网格上，使用梯形法则实现 $J_V$ 的数值积分。将 $r \\in [0, r_{\\max}]$ 以固定的步长 $\\Delta r$ 进行离散化，计算被积函数 $V(r) r^2$，并将积分近似为：\n$$\n\\int_{0}^{r_{\\max}} V(r) \\, r^2 \\, dr \\approx \\Delta r \\left[\\tfrac{1}{2} f(0) + \\sum_{k=1}^{N-1} f(k \\Delta r) + \\tfrac{1}{2} f(r_{\\max}) \\right], \\quad f(r) \\equiv V(r) r^2 \\, ,\n$$\n然后计算 $J_V = 4\\pi \\times (\\text{梯形法则结果})$。选择足够大的 $r_{\\max}$，以确保超出 $r_{\\max}$ 的尾部贡献相对于指定精度可以忽略不计。以 $\\mathrm{MeV \\, fm^3}$ 为单位表示 $J_V$。\n2. 实现一个一维参数搜索算法来估计 $V_0$，使得计算出的 $J_V$ 与指定的目标值 $J_T$ 相匹配。对以下函数使用稳健的区间限定策略和二分法：\n$$\nF(V_0) = J_V(V_0) - J_T \\, ,\n$$\n其中 $J_V(V_0)$ 是对给定 $V_0$ 进行数值积分得到的体积积分。由于 Woods–Saxon 中心项的 $J_V$ 与 $V_0$ 呈线性关系，因此当 $A$、$r_0$、$a$、$\\Delta r$ 和 $r_{\\max}$ 固定时，$F(V_0)$ 对 $V_0$ 是单调的。当绝对差 $\\lvert J_V(V_0) - J_T \\rvert$ 小于指定的容差时停止搜索。以 $\\mathrm{MeV}$ 为单位表示 $V_0$。\n\n数值细节：\n- 梯形法则应严格按照上述定义使用。\n- 对每个测试用例使用指定的均匀网格间距。\n- 所有半径的单位均为 $\\mathrm{fm}$，所有能量的单位均为 $\\mathrm{MeV}$，最终的体积积分单位为 $\\mathrm{MeV \\, fm^3}$。\n- 没有使用角度；因此不需要指定角度单位。\n- 对于所有测试，将报告的数值输出四舍五入到三位小数。\n\n测试套件：\n计算以下四个测试用例的结果，这些用例旨在覆盖标准理想路径、较重系统的标度变化、粗糙网格边界条件以及参数搜索：\n\n- 测试 1（理想路径数值积分）：给定 $A = 40$，$r_0 = 1.25 \\, \\mathrm{fm}$，$a = 0.65 \\, \\mathrm{fm}$ 和 $V_0 = 50 \\, \\mathrm{MeV}$，使用梯形法则计算 $J_V$，其中 $\\Delta r = 0.05 \\, \\mathrm{fm}$，积分上限 $r_{\\max} = 12 \\, \\mathrm{fm}$。报告以 $\\mathrm{MeV \\, fm^3}$ 为单位的数值，精度要求在 $1 \\, \\mathrm{MeV \\, fm^3}$ 以内。\n- 测试 2（较重系统）：给定 $A = 208$，$r_0 = 1.25 \\, \\mathrm{fm}$，$a = 0.63 \\, \\mathrm{fm}$ 和 $V_0 = 52 \\, \\mathrm{MeV}$，使用梯形法则计算 $J_V$，其中 $\\Delta r = 0.05 \\, \\mathrm{fm}$，积分上限 $r_{\\max} = 15 \\, \\mathrm{fm}$。报告以 $\\mathrm{MeV \\, fm^3}$ 为单位的数值，精度要求在 $1 \\, \\mathrm{MeV \\, fm^3}$ 以内。\n- 测试 3（粗糙网格边界条件）：给定 $A = 40$，$r_0 = 1.25 \\, \\mathrm{fm}$，$a = 0.65 \\, \\mathrm{fm}$ 和 $V_0 = 50 \\, \\mathrm{MeV}$，使用梯形法则计算 $J_V$，其中 $\\Delta r = 0.5 \\, \\mathrm{fm}$，积分上限 $r_{\\max} = 12 \\, \\mathrm{fm}$。报告以 $\\mathrm{MeV \\, fm^3}$ 为单位的数值，精度要求在 $100 \\, \\mathrm{MeV \\, fm^3}$ 以内（较宽松的容差反映了离散化误差）。\n- 测试 4（深度参数搜索）：给定 $A = 40$，$r_0 = 1.25 \\, \\mathrm{fm}$，$a = 0.65 \\, \\mathrm{fm}$，目标值 $J_T = -20000 \\, \\mathrm{MeV \\, fm^3}$，在区间 $V_0 \\in [1 \\, \\mathrm{MeV}, 200 \\, \\mathrm{MeV}]$ 上使用二分法搜索，并结合梯形法则（$\\Delta r = 0.05 \\, \\mathrm{fm}$，积分上限 $r_{\\max} = 12 \\, \\mathrm{fm}$），报告估计的 $V_0$ 值（单位为 $\\mathrm{MeV}$），要求满足 $\\lvert J_V(V_0) - J_T \\rvert \\le 0.1 \\, \\mathrm{MeV \\, fm^3}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按测试 1 到 4 的顺序包含四个浮点数，每个数都四舍五入到三位小数。例如，打印的输出应如下所示：\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4] \\, .\n$$\n所有 $J_V$ 结果的单位必须是 $\\mathrm{MeV \\, fm^3}$，最后一项（参数搜索结果）的单位必须是 $\\mathrm{MeV}$。", "solution": "光学模型通过一个复势建立了核子-原子核相互作用的等效平均场描述；在本问题中，我们关注其中心实部，这部分通常由 Woods–Saxon 形式表示。对于球对称原子核，Woods–Saxon 势定义为：\n$$\nV(r) = -\\frac{V_0}{1 + \\exp\\left(\\frac{r - R}{a}\\right)} \\, ,\n$$\n其中 $R = r_0 A^{1/3}$。此处，$V_0$ 是以 $\\mathrm{MeV}$ 为单位的正势阱深度（势本身是负的），$a$ 是以 $\\mathrm{fm}$ 为单位的弥散度，$r_0$ 是以 $\\mathrm{fm}$ 为单位的半径参数。体积积分 $J_V$ 定义为势在三维空间上的积分，\n$$\nJ_V = \\int_{\\mathbb{R}^3} V(\\mathbf{r}) \\, d^3\\mathbf{r} \\, ,\n$$\n根据球对称性，这可简化为：\n$$\nJ_V = 4\\pi \\int_{0}^{\\infty} V(r) \\, r^2 \\, dr \\, .\n$$\n对于吸引势 $V(r)  0$，积分 $J_V$ 为负值。该值概括了光学模型势中心实部的积分强度，并被广泛用于参数系统学和比较中。\n\n为了数值计算 $J_V$，我们在 $r$ 的均匀网格上采用梯形法则。定义被积函数 $f(r) = V(r) r^2$，对于网格点 $r_k = k \\Delta r$（其中 $k = 0, 1, \\dots, N$ 且 $N \\Delta r = r_{\\max}$），梯形法则给出：\n$$\n\\int_{0}^{r_{\\max}} f(r) \\, dr \\approx \\Delta r \\left[\\tfrac{1}{2} f(0) + \\sum_{k=1}^{N-1} f(r_k) + \\tfrac{1}{2} f(r_{\\max}) \\right] \\, .\n$$\n完整的体积积分随后通过将径向积分结果乘以 $4\\pi$ 计算得出。选择截断半径 $r_{\\max}$ 是为了使超出 $r_{\\max}$ 的贡献相对于指定容差可以忽略，这在物理上是合理的，因为当 $r$ 增加并超过核表面时，Woods–Saxon 势呈指数衰减。对于足够光滑的被积函数，梯形法则会引入一个量级为 $\\mathcal{O}((\\Delta r)^2)$ 的标准离散化误差，我们在粗糙网格测试的容差中反映了这一点。\n\n对于 $V_0$ 的参数搜索，我们对以下函数使用二分法：\n$$\nF(V_0) = J_V(V_0) - J_T \\, ,\n$$\n其中 $J_T$ 是目标体积积分。对于 Woods–Saxon 形式，$J_V(V_0)$ 与 $V_0$ 成线性正比，因为：\n$$\nV(r; V_0) = -V_0 \\, g(r), \\quad g(r) \\equiv \\frac{1}{1 + \\exp\\left(\\frac{r - R}{a}\\right)} \\, ,\n$$\n所以\n$$\nJ_V(V_0) = 4\\pi \\int_{0}^{\\infty} \\left[-V_0 \\, g(r)\\right] r^2 \\, dr = -V_0 \\, K \\, ,\n$$\n其中\n$$\nK = 4\\pi \\int_{0}^{\\infty} g(r) r^2 \\, dr  0 \\, .\n$$\n因此，在几何参数固定的情况下，$F(V_0)$ 对 $V_0$ 是严格单调的，这保证了只要选择的区间 $[V_{\\min}, V_{\\max}]$ 使得 $F(V_{\\min})$ 和 $F(V_{\\max})$ 异号，二分法就会收敛。尽管可以利用线性关系以 $V_0 = -J_T / K$ 的闭合形式计算 $V_0$，但当势包含额外的非线性或能量依赖性时，实现二分法更具普适性，并且这也与练习参数搜索算法的目标相一致。\n\n算法步骤：\n1. 对于每个需要计算 $J_V$ 的测试用例，计算 $R = r_0 A^{1/3}$，构建网格 $r_k$（其中 $k = 0, \\dots, N$ 且 $N = r_{\\max}/\\Delta r$），计算 $V(r_k)$，构造 $f(r_k) = V(r_k) r_k^2$，应用梯形法则，然后乘以 $4\\pi$ 以获得单位为 $\\mathrm{MeV \\, fm^3}$ 的 $J_V$。\n2. 对于参数搜索用例，定义一个区间 $[V_{\\min}, V_{\\max}]$，其中 $V_{\\min} = 1 \\, \\mathrm{MeV}$ 和 $V_{\\max} = 200 \\, \\mathrm{MeV}$，计算 $F(V_{\\min})$ 和 $F(V_{\\max})$，并确保它们异号（如果不是，则扩展该区间）。应用二分法：\n   - 计算 $V_{\\text{mid}} = (V_{\\min} + V_{\\max}) / 2$。\n   - 通过对 $J_V$ 的梯形法则计算来评估 $F(V_{\\text{mid}})$。\n   - 如果 $\\lvert F(V_{\\text{mid}}) \\rvert$ 低于容差（此处为 $0.1 \\, \\mathrm{MeV \\, fm^3}$），则停止并返回 $V_{\\text{mid}}$。\n   - 否则，用 $V_{\\text{mid}}$ 替换与 $F(V_{\\text{mid}})$ 符号相同的区间端点，并重复此过程。\n3. 将每个报告的输出四舍五入到三位小数。\n\n科学真实性与一致性：\n- 考虑到 Woods–Saxon 形式的指数尾部特性，以及其典型的 $a$ 值在 $0.6$–$0.7 \\, \\mathrm{fm}$ 范围内，$r_{\\max} = 12 \\, \\mathrm{fm}$ 和 $r_{\\max} = 15 \\, \\mathrm{fm}$ 的选择是合理的，这确保了在给定的容差下，尾部贡献可以忽略不计。\n- 使用 $\\Delta r = 0.05 \\, \\mathrm{fm}$ 的步长足够精细，对于指定的原子核可以达到 $1 \\, \\mathrm{MeV \\, fm^3}$ 的精度，因为被积函数是光滑的。包含 $\\Delta r = 0.5 \\, \\mathrm{fm}$ 的粗糙网格情况是为了凸显离散化效应，因此采用更宽松的容差是合适的。\n- 所有物理量都以正确的单位表示：半径单位为 $\\mathrm{fm}$，能量单位为 $\\mathrm{MeV}$，体积积分单位为 $\\mathrm{MeV \\, fm^3}$。\n\n最终的程序将实现上述逻辑，并生成单行输出，其中包含四个用方括号括起来的、由逗号分隔的浮点数，按顺序对应测试 1 到 4。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef woods_saxon_potential(r, A, r0, a, V0):\n    \"\"\"\n    Woods-Saxon central real potential:\n    V(r) = -V0 / (1 + exp((r - R)/a)), with R = r0 * A^(1/3).\n    r: numpy array of radii [fm]\n    A: mass number (dimensionless)\n    r0: radius parameter [fm]\n    a: diffuseness [fm]\n    V0: depth parameter [MeV], positive (potential itself is negative)\n    Returns V(r) in MeV as numpy array.\n    \"\"\"\n    R = r0 * (A ** (1.0 / 3.0))\n    return -V0 / (1.0 + np.exp((r - R) / a))\n\ndef volume_integral_JV(A, r0, a, V0, dr, rmax):\n    \"\"\"\n    Compute J_V = 4*pi * integral_0^{rmax} V(r) * r^2 dr via trapezoidal rule.\n    Units: J_V in MeV fm^3.\n    \"\"\"\n    # Ensure inclusion of rmax endpoint\n    # Using arange may omit rmax if rmax/dr not integer; use linspace instead.\n    N = int(np.round(rmax / dr))\n    r = np.linspace(0.0, rmax, N + 1)\n    V = woods_saxon_potential(r, A, r0, a, V0)\n    integrand = V * (r ** 2)\n    radial_integral = np.trapz(integrand, r)\n    JV = 4.0 * np.pi * radial_integral\n    return JV\n\ndef find_V0_for_target_JV(A, r0, a, J_target, dr, rmax, vmin=1.0, vmax=200.0, tol=0.1, max_iter=100):\n    \"\"\"\n    Find V0 such that volume_integral_JV(A, r0, a, V0, dr, rmax) ~= J_target using bisection.\n    vmin, vmax: bracket in MeV\n    tol: tolerance on |J_V - J_target| in MeV fm^3\n    Returns estimated V0 in MeV.\n    \"\"\"\n    def F(V0):\n        return volume_integral_JV(A, r0, a, V0, dr, rmax) - J_target\n\n    # Ensure bracketing condition: F(vmin) and F(vmax) must have opposite signs\n    fmin = F(vmin)\n    fmax = F(vmax)\n    # Expand bracket if necessary (simple strategy)\n    expand_factor = 2.0\n    expansion_count = 0\n    while fmin * fmax > 0 and expansion_count  10:\n        # Expand towards larger vmax to encompass target magnitude\n        vmax *= expand_factor\n        fmax = F(vmax)\n        expansion_count += 1\n\n    # If still not bracketed, try lowering vmin\n    if fmin * fmax > 0:\n        vmin = max(1e-6, vmin / expand_factor)\n        fmin = F(vmin)\n        expansion_count = 0\n        while fmin * fmax > 0 and expansion_count  10:\n            vmin = max(1e-6, vmin / expand_factor)\n            fmin = F(vmin)\n            expansion_count += 1\n\n    # If still not bracketed, fall back to direct linear estimate using K from V0=1 MeV\n    if fmin * fmax > 0:\n        K = -volume_integral_JV(A, r0, a, 1.0, dr, rmax)  # J_V = -V0*K => K = -J_V(V0=1)\n        V0_est = -J_target / K\n        return V0_est\n\n    # Bisection iterations\n    low, high = vmin, vmax\n    for _ in range(max_iter):\n        mid = 0.5 * (low + high)\n        fmid = F(mid)\n        if abs(fmid) = tol:\n            return mid\n        # Decide which subinterval to keep\n        if fmin * fmid  0:\n            high = mid\n            # fmax = fmid # This is not needed and can be removed\n        else:\n            low = mid\n            fmin = fmid\n    # If not converged within max_iter, return midpoint\n    return 0.5 * (low + high)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple:\n    # ('J', {A, r0, a, V0, dr, rmax}) -> compute J_V\n    # ('search', {A, r0, a, J_target, dr, rmax}) -> find V0 matching target J_V\n    test_cases = [\n        ('J', {'A': 40, 'r0': 1.25, 'a': 0.65, 'V0': 50.0, 'dr': 0.05, 'rmax': 12.0}),\n        ('J', {'A': 208, 'r0': 1.25, 'a': 0.63, 'V0': 52.0, 'dr': 0.05, 'rmax': 15.0}),\n        ('J', {'A': 40, 'r0': 1.25, 'a': 0.65, 'V0': 50.0, 'dr': 0.5, 'rmax': 12.0}),\n        ('search', {'A': 40, 'r0': 1.25, 'a': 0.65, 'J_target': -20000.0, 'dr': 0.05, 'rmax': 12.0}),\n    ]\n\n    results = []\n    for kind, params in test_cases:\n        if kind == 'J':\n            JV = volume_integral_JV(\n                A=params['A'], r0=params['r0'], a=params['a'],\n                V0=params['V0'], dr=params['dr'], rmax=params['rmax']\n            )\n            results.append(JV)\n        elif kind == 'search':\n            V0_est = find_V0_for_target_JV(\n                A=params['A'], r0=params['r0'], a=params['a'],\n                J_target=params['J_target'], dr=params['dr'], rmax=params['rmax'],\n                vmin=1.0, vmax=200.0, tol=0.1, max_iter=200\n            )\n            results.append(V0_est)\n        else:\n            # Unknown test case type; append NaN\n            results.append(float('nan'))\n\n    # Round each result to three decimal places and format as strings.\n    formatted = [f\"{x:.3f}\" for x in results]\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3578612"}, {"introduction": "超越简单的搜索方法，本练习剖析了诸如高斯-牛顿（Gauss-Newton）和列文伯格-马夸特（Levenberg-Marquardt）等强大梯度优化算法的“引擎”。通过根据给定的梯度和Hessian矩阵信息计算单步优化，你将直接洞察这些算法如何在参数空间中导航以寻找最小值。这项实践阐明了现代拟合程序背后的数学核心。[@problem_id:3578676]", "problem": "在将一个双参数Woods–Saxon光学模型与弹性散射数据进行拟合时，考虑加权非线性最小二乘目标函数$\\chi^{2}(\\boldsymbol{p}) = \\boldsymbol{r}(\\boldsymbol{p})^{T} W \\boldsymbol{r}(\\boldsymbol{p})$，其中$\\boldsymbol{p} \\in \\mathbb{R}^{2}$表示一个缩放的无量纲参数向量，$\\boldsymbol{r}(\\boldsymbol{p})$是残差向量（数据减去在$\\boldsymbol{p}$处评估的模型预测值），$W$是一个对称正定权重矩阵，$J$是$\\boldsymbol{r}(\\boldsymbol{p})$关于$\\boldsymbol{p}$的雅可比矩阵。在当前迭代点$\\boldsymbol{p}_{k}$，可用的局部敏感度信息汇总如下\n$$\nJ^{T} W J \\;=\\; \\begin{pmatrix} 400  -120 \\\\ -120  50 \\end{pmatrix}, \n\\qquad\nJ^{T} W \\boldsymbol{r} \\;=\\; \\begin{pmatrix} -80 \\\\ 30 \\end{pmatrix}.\n$$\n假设使用加权最小二乘的标准高斯–牛顿线性化以及Levenberg–Marquardt (LM) 阻尼，其中参数$\\lambda = 10$，缩放矩阵$D = \\mathrm{diag}(1,1)$，请确定：\n- 在$\\boldsymbol{p}_{k}$处的高斯–牛顿步长$\\Delta \\boldsymbol{p}_{\\mathrm{GN}}$，以及\n- 在$\\boldsymbol{p}_{k}$处的Levenberg–Marquardt步长$\\Delta \\boldsymbol{p}_{\\mathrm{LM}}$。\n\n在本次计算中将参数视为无量纲。提供精确值（不进行四舍五入）。以$(\\Delta p_{\\mathrm{GN},1}, \\Delta p_{\\mathrm{GN},2}, \\Delta p_{\\mathrm{LM},1}, \\Delta p_{\\mathrm{LM},2})$的顺序将最终结果报告为单个行矩阵。", "solution": "我们从加权非线性最小二乘目标函数$\\chi^{2}(\\boldsymbol{p}) = \\boldsymbol{r}(\\boldsymbol{p})^{T} W \\boldsymbol{r}(\\boldsymbol{p})$的定义开始。在优化算法中，通常考虑最小化 $\\frac{1}{2}\\chi^2$，其梯度为 $\\nabla(\\frac{1}{2}\\chi^2) = J^{T} W \\boldsymbol{r}(\\boldsymbol{p})$。高斯–牛顿法使用对Hessian矩阵的近似 $\\nabla^{2}(\\frac{1}{2}\\chi^{2}) \\approx J^{T} W J$。高斯–牛顿步长$\\Delta \\boldsymbol{p}_{\\mathrm{GN}}$被定义为通过最小化二次模型而得到的线性系统的解，\n$$\n\\left(J^{T} W J\\right) \\, \\Delta \\boldsymbol{p}_{\\mathrm{GN}} \\;=\\; - \\, J^{T} W \\boldsymbol{r}.\n$$\n根据所提供的汇总信息，\n$$\nJ^{T} W J \\;=\\; \\begin{pmatrix} 400  -120 \\\\ -120  50 \\end{pmatrix}, \n\\qquad\nJ^{T} W \\boldsymbol{r} \\;=\\; \\begin{pmatrix} -80 \\\\ 30 \\end{pmatrix},\n$$\n高斯–牛顿步长为\n$$\n\\Delta \\boldsymbol{p}_{\\mathrm{GN}} \\;=\\; - \\left(J^{T} W J\\right)^{-1} \\left(J^{T} W \\boldsymbol{r}\\right).\n$$\n我们计算$\\left(J^{T} W J\\right)^{-1}$。对于\n$$\nM \\;=\\; \\begin{pmatrix} 400  -120 \\\\ -120  50 \\end{pmatrix},\n$$\n行列式为\n$$\n\\det(M) \\;=\\; 400 \\cdot 50 \\;-\\; (-120)\\cdot(-120) \\;=\\; 20000 \\;-\\; 14400 \\;=\\; 5600,\n$$\n其逆矩阵为\n$$\nM^{-1} \\;=\\; \\frac{1}{5600}\\begin{pmatrix} 50  120 \\\\ 120  400 \\end{pmatrix}.\n$$\n因此\n$$\n\\left(J^{T} W J\\right)^{-1} \\left(J^{T} W \\boldsymbol{r}\\right) \\;=\\; \\frac{1}{5600} \n\\begin{pmatrix} 50  120 \\\\ 120  400 \\end{pmatrix}\n\\begin{pmatrix} -80 \\\\ 30 \\end{pmatrix}\n\\;=\\; \\frac{1}{5600} \n\\begin{pmatrix} 50(-80) + 120(30) \\\\ 120(-80) + 400(30) \\end{pmatrix}\n\\;=\\; \\frac{1}{5600} \\begin{pmatrix} -400 \\\\ 2400 \\end{pmatrix}\n\\;=\\; \\begin{pmatrix} -\\frac{1}{14} \\\\ \\frac{3}{7} \\end{pmatrix}.\n$$\n所以，\n$$\n\\Delta \\boldsymbol{p}_{\\mathrm{GN}} \\;=\\; - \\begin{pmatrix} -\\frac{1}{14} \\\\ \\frac{3}{7} \\end{pmatrix}\n\\;=\\; \\begin{pmatrix} \\frac{1}{14} \\\\ -\\frac{3}{7} \\end{pmatrix}.\n$$\n\n接下来，Levenberg–Marquardt (LM) 方法通过一个半正定阻尼项来增广高斯–牛顿系统，以提高鲁棒性。给定阻尼参数$\\lambda  0$和缩放矩阵$D$，LM步长$\\Delta \\boldsymbol{p}_{\\mathrm{LM}}$求解\n$$\n\\left(J^{T} W J + \\lambda D\\right)\\Delta \\boldsymbol{p}_{\\mathrm{LM}} \\;=\\; - \\, J^{T} W \\boldsymbol{r}.\n$$\n给定$\\lambda = 10$和$D = \\mathrm{diag}(1,1)$，我们有\n$$\nJ^{T} W J + \\lambda I \\;=\\; \n\\begin{pmatrix} 400  -120 \\\\ -120  50 \\end{pmatrix}\n\\;+\\; 10 \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}\n\\;=\\; \\begin{pmatrix} 410  -120 \\\\ -120  60 \\end{pmatrix}.\n$$\n令\n$$\n\\widetilde{M} \\;=\\; \\begin{pmatrix} 410  -120 \\\\ -120  60 \\end{pmatrix}.\n$$\n其行列式为\n$$\n\\det(\\widetilde{M}) \\;=\\; 410 \\cdot 60 \\;-\\; (-120)\\cdot(-120) \\;=\\; 24600 \\;-\\; 14400 \\;=\\; 10200,\n$$\n其逆矩阵为\n$$\n\\widetilde{M}^{-1} \\;=\\; \\frac{1}{10200}\\begin{pmatrix} 60  120 \\\\ 120  410 \\end{pmatrix}.\n$$\n因此\n$$\n\\Delta \\boldsymbol{p}_{\\mathrm{LM}} \\;=\\; - \\widetilde{M}^{-1}\\left(J^{T} W \\boldsymbol{r}\\right) \\;=\\; -\\frac{1}{10200}\n\\begin{pmatrix} 60  120 \\\\ 120  410 \\end{pmatrix}\n\\begin{pmatrix} -80 \\\\ 30 \\end{pmatrix}\n\\;=\\; -\\frac{1}{10200} \\begin{pmatrix} 60(-80) + 120(30) \\\\ 120(-80) + 410(30) \\end{pmatrix}\n\\;=\\; -\\frac{1}{10200} \\begin{pmatrix} -1200 \\\\ 2700 \\end{pmatrix}\n\\;=\\; \\begin{pmatrix} \\frac{1200}{10200} \\\\ -\\frac{2700}{10200} \\end{pmatrix}\n\\;=\\; \\begin{pmatrix} \\frac{2}{17} \\\\ -\\frac{9}{34} \\end{pmatrix}.\n$$\n\n作为一致性检查，阻尼参数$\\lambda = 10$产生的步长分量与高斯–牛顿步长相比，其幅度减小了，这与Levenberg–Marquardt的正则化效应是一致的。\n\n最后，将各分量按要求的顺序$(\\Delta p_{\\mathrm{GN},1}, \\Delta p_{\\mathrm{GN},2}, \\Delta p_{\\mathrm{LM},1}, \\Delta p_{\\mathrm{LM},2})$整理得到\n$$\n\\left( \\frac{1}{14}, \\; -\\frac{3}{7}, \\; \\frac{2}{17}, \\; -\\frac{9}{34} \\right).\n$$", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1}{14}  -\\frac{3}{7}  \\frac{2}{17}  -\\frac{9}{34}\\end{pmatrix}}$$", "id": "3578676"}, {"introduction": "基于梯度的优化器的性能取决于其所用梯度的质量。这项高级实践旨在解决为复杂的、由数值定义的目标函数计算精确导数的关键挑战。你将实现优雅的复数步方法，并将其与传统的有限差分方法进行基准比较，从而揭示其在鲁棒参数搜索中的卓越准确性和稳定性。[@problem_id:3578614]", "problem": "您的任务是为一个源自核反应理论中标准复光学模型势的可观测量实现一个鲁棒的梯度评估。目标是展示步长为 $h = i \\epsilon$ 的复步导数如何为参数搜索生成接近机器精度的偏导数，并与实值中心差分法进行定量基准比较。\n\n考虑 Woods–Saxon 光学势几何因子\n$$\nf(r; R, a) = \\frac{1}{1 + \\exp\\!\\left(\\frac{r - R}{a}\\right)},\n$$\n以及复光学势\n$$\nV(r; \\boldsymbol{\\theta}) = -\\left(V_0 + i\\, W_0\\right)\\, f(r; R, a),\n$$\n其中参数向量为 $\\boldsymbol{\\theta} = [V_0, W_0, R, a]$，$V_0$ 和 $W_0$ 的单位是兆电子伏特 (MeV)，$R$ 的单位是飞米 (fm)，$a$ 的单位是飞米 (fm)。定义几何体积积分\n$$\nI(R, a) = 4\\pi \\int_0^{r_{\\max}} f(r; R, a)\\, r^2\\, dr,\n$$\n其中 $r_{\\max} = 20\\,\\mathrm{fm}$，数值积分通过复合辛普森法则在一个包含 $[0, r_{\\max}]$ 上 $N = 20001$ 个点的均匀网格上执行。因为当 $R$ 和 $a$ 为实数时 $f(r; R, a)$ 是实数，所以对于任意 $\\boldsymbol{\\theta}$，我们可以写出\n$$\nJ_R(\\boldsymbol{\\theta}) = -V_0\\, I(R, a), \\qquad J_I(\\boldsymbol{\\theta}) = -W_0\\, I(R, a),\n$$\n这对应于 $V(r;\\boldsymbol{\\theta})$ 的实部和虚部的体积积分。\n\n定义标量目标函数\n$$\nO(\\boldsymbol{\\theta}) = \\left[J_R(\\boldsymbol{\\theta}) - J_R^\\star\\right]^2 + \\left[J_I(\\boldsymbol{\\theta}) - J_I^\\star\\right]^2,\n$$\n其中 $J_R^\\star$ 和 $J_I^\\star$ 是由一个测试套件特定的目标参数向量 $\\boldsymbol{\\theta}^\\star = [V_0^\\star, W_0^\\star, R^\\star, a^\\star]$ 通过以下方式构造的固定目标值：\n$$\nI^\\star = I(R^\\star, a^\\star), \\quad J_R^\\star = -V_0^\\star I^\\star, \\quad J_I^\\star = -W_0^\\star I^\\star.\n$$\n\n您的程序必须：\n1. 精确地按照上述方式实现 $O(\\boldsymbol{\\theta})$，在 $[0, r_{\\max}]$ 上包含 $N=20001$ 个点的均匀网格上，通过复合辛普森法则计算积分 $I(R,a)$，其中 $r_{\\max} = 20\\,\\mathrm{fm}$。所有内部计算必须使用与编程语言默认双精度一致的浮点算术执行。不涉及角度。在模型中，距离必须以飞米为单位处理，能量以兆电子伏特为单位；然而，最终要求的误差度量是无量纲的。\n2. 使用复步法计算梯度分量 $\\partial O/\\partial \\theta_i$：对于每个分量索引 $i$，用 $\\epsilon = 10^{-30}$ 计算 $O(\\boldsymbol{\\theta} + i\\,\\epsilon\\, \\mathbf{e}_i)$ 并提取\n$$\n\\left.\\frac{\\partial O}{\\partial \\theta_i}\\right|_{\\text{CS}} \\approx \\frac{\\operatorname{Im}\\left[ O(\\boldsymbol{\\theta} + i\\,\\epsilon\\, \\mathbf{e}_i) \\right]}{\\epsilon}.\n$$\n实现 $O(\\cdot)$ 的代码必须不包含对其参数的非解析操作；仅使用如上所示的代数运算和指数运算。\n3. 使用两个实数步长尺度 $s \\in \\{10^{-6}, 10^{-8}\\}$ 和按参数的步长 $h_i = s \\cdot \\max(|\\theta_i|, 1)$ 来计算相同梯度分量的中心差分近似：\n$$\n\\left.\\frac{\\partial O}{\\partial \\theta_i}\\right|_{\\text{FD}}(s) \\approx \\frac{O(\\boldsymbol{\\theta} + h_i \\mathbf{e}_i) - O(\\boldsymbol{\\theta} - h_i \\mathbf{e}_i)}{2 h_i}.\n$$\n4. 对于每个 $s$，计算中心差分导数相对于复步导数的相对误差：\n$$\n\\mathrm{rel\\_err}_i(s) = \\frac{\\left| \\left.\\frac{\\partial O}{\\partial \\theta_i}\\right|_{\\text{FD}}(s) - \\left.\\frac{\\partial O}{\\partial \\theta_i}\\right|_{\\text{CS}} \\right|}{\\max\\!\\left(\\left|\\left.\\frac{\\partial O}{\\partial \\theta_i}\\right|_{\\text{CS}}\\right|, \\delta\\right)},\n$$\n其中 $\\delta = 10^{-20}$ 用于避免除以零。对于每个测试用例和每个 $s$，报告所有分量 $i$ 中的最大相对误差：\n$$\nE_{\\max}(s) = \\max_i \\mathrm{rel\\_err}_i(s).\n$$\n报告的误差度量 $E_{\\max}(s)$ 是无量纲的。\n\n测试套件：\n精确使用以下三个测试用例。对于每个用例，$\\boldsymbol{\\theta}$ 表示当前参数向量，$\\boldsymbol{\\theta}^\\star$ 表示定义 $J_R^\\star$ 和 $J_I^\\star$ 的目标参数向量。\n\n- 用例 1：\n  - $\\boldsymbol{\\theta} = [50, 10, 5.0, 0.60]$，单位为 $[\\,\\mathrm{MeV},\\,\\mathrm{MeV},\\,\\mathrm{fm},\\,\\mathrm{fm}\\,]$。\n  - $\\boldsymbol{\\theta}^\\star = [52, 11, 4.9, 0.62]$，单位相同。\n- 用例 2：\n  - $\\boldsymbol{\\theta} = [20, 5, 6.5, 1.20]$。\n  - $\\boldsymbol{\\theta}^\\star = [18, 6, 6.0, 1.00]$。\n- 用例 3：\n  - $\\boldsymbol{\\theta} = [70, 30, 4.0, 0.50]$。\n  - $\\boldsymbol{\\theta}^\\star = [68, 28, 4.2, 0.45]$。\n\n您的程序必须：\n- 使用 $r_{\\max} = 20\\,\\mathrm{fm}$ 和 $N = 20001$ 个等距点来实现积分。\n- 对于复步法使用 $\\epsilon = 10^{-30}$，对于中心差分法使用 $s \\in \\{10^{-6}, 10^{-8}\\}$ 和 $h_i = s \\cdot \\max(|\\theta_i|, 1)$。\n- 对于每个用例，计算并收集 $E_{\\max}(10^{-6})$ 和 $E_{\\max}(10^{-8})$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含六个结果，形式为方括号内的逗号分隔列表，顺序如下：\n$$\n\\left[ E_{\\max}^{(1)}(10^{-6}),\\, E_{\\max}^{(1)}(10^{-8}),\\, E_{\\max}^{(2)}(10^{-6}),\\, E_{\\max}^{(2)}(10^{-8}),\\, E_{\\max}^{(3)}(10^{-6}),\\, E_{\\max}^{(3)}(10^{-8}) \\right],\n$$\n其中上标表示测试用例索引。这些值是无量纲的浮点数。不要打印任何额外文本。数值应由您的代码生成；除了编程语言默认的浮点字符串转换外，不要对它们进行四舍五入或格式化。", "solution": "用户的要求是开发一个 Python 程序，该程序为一个在计算核物理中使用的特定目标函数的数值梯度近似的准确性进行基准测试。该基准测试将中心有限差分 (FD) 方法与复步 (CS) 导数方法进行比较，并将后者视为高精度参考。\n\n### **问题验证**\n\n已根据既定标准对问题陈述进行了仔细审查。\n\n1.  **已知条件提取**：所有定义、常数和计算过程均已逐字提取。这包括 Woods-Saxon 因子 $f(r;R,a)$ 和光学势 $V(r;\\boldsymbol{\\theta})$ 的函数形式，体积积分 $I(R,a)$ 和目标函数 $O(\\boldsymbol{\\theta})$ 的定义，所有数值参数（$r_{\\max}=20$, $N=20001$, $\\epsilon=10^{-30}$, $s \\in \\{10^{-6}, 10^{-8}\\}$, $\\delta=10^{-20}$），数值积分（复合辛普森法则）和导数近似（CS 和 FD）的精确规范，以及包含特定参数向量 $\\boldsymbol{\\theta}$ 和 $\\boldsymbol{\\theta}^\\star$ 的三个测试用例。\n2.  **验证检查**：问题是**有效的**。\n    *   **有科学依据**：该问题使用了计算核物理中的标准模型（Woods-Saxon 光学势）和技术（通过目标函数进行参数拟合、数值积分、数值微分）。它在科学上是合理且现实的。\n    *   **适定的**：提供了所有必需的信息。函数在数学上是适定的，计算序列会导向一组唯一的结果。使用 $\\delta$ 来防止除以零是增强适定性的良好实践。\n    *   **客观的**：问题陈述使用了精确、无歧义的数学和计算语言。\n    *   **一致性和完整性**：设置在内部是一致和完整的。例如，积分点数 $N=20001$ 是奇数，这适用于在 $N-1$ 个偶数区间上使用复合辛普森法则。所涉及的函数（$e^x$ 和代数运算）是解析的，这是复步法的关键要求。\n\n该问题是一个有效且定义明确的科学计算练习。可以继续进行求解过程。\n\n### **方法论与实现**\n\n解决方案的核心是以一种支持实值和复值参数评估的方式实现目标函数 $O(\\boldsymbol{\\theta})$。这使得同一函数可以同时用于有限差分法和复步法。\n\n**1. 数值积分：体积积分 $I(R, a)$**\n\n几何体积积分定义为：\n$$\nI(R, a) = 4\\pi \\int_0^{r_{\\max}} \\frac{r^2}{1 + \\exp\\left(\\frac{r - R}{a}\\right)} dr\n$$\n该积分使用复合辛普森法则计算。我们首先在 $r=0$ 到 $r=r_{\\max}=20\\,\\mathrm{fm}$ 的范围内，用 $N=20001$ 个点建立一个均匀的径向网格 $r_k$（$k=0, 1, \\dots, N-1$）。在每个网格点上计算被积函数 $g(r) = f(r;R,a) r^2$。`scipy.integrate.simpson` 函数非常适合此任务，因为它能根据给定的函数值和网格点高效地实现复合辛普森法则。为了支持复步法，实现必须能处理复数值参数 $R$ 和 $a$。`NumPy` 的数学函数，如 `np.exp`，被重载以正确处理复数，这使得实现变得直接。\n\n**2. 目标函数 $O(\\boldsymbol{\\theta})$**\n\n目标函数为：\n$$\nO(\\boldsymbol{\\theta}) = \\left[J_R(\\boldsymbol{\\theta}) - J_R^\\star\\right]^2 + \\left[J_I(\\boldsymbol{\\theta}) - J_I^\\star\\right]^2\n$$\n其中 $J_R(\\boldsymbol{\\theta}) = -V_0 I(R, a)$ 且 $J_I(\\boldsymbol{\\theta}) = -W_0 I(R, a)$。目标值，用星号 $(\\star)$ 区分，对于给定的测试用例是常数，使用目标参数向量 $\\boldsymbol{\\theta}^\\star = [V_0^\\star, W_0^\\star, R^\\star, a^\\star]$ 计算。\n\n$O(\\boldsymbol{\\theta})$ 的实现包括：\n1.  从 $\\boldsymbol{\\theta}^\\star$ 计算固定的、实数值的目标积分 $J_R^\\star$ 和 $J_I^\\star$。\n2.  使用当前参数向量 $\\boldsymbol{\\theta}$ 计算 $J_R(\\boldsymbol{\\theta})$ 和 $J_I(\\boldsymbol{\\theta})$。如果 $\\boldsymbol{\\theta}$ 是复数（如在复步法中），那么 $I(R,a)$、$J_R$ 和 $J_I$ 将是复数。\n3.  计算 $O(\\boldsymbol{\\theta})$ 的最终表达式。所有算术运算必须能正确处理复数。\n\n**3. 梯度计算：复步 (CS) 法**\n\n复步法提供了一种数值稳定的方法，可以计算出接近机器精度的导数，避免了困扰有限差分法的相减抵消误差。$O$ 对于参数 $\\theta_i$ 的偏导数公式为：\n$$\n\\frac{\\partial O}{\\partial \\theta_i} \\approx \\frac{\\operatorname{Im}\\left[ O(\\boldsymbol{\\theta} + i\\,\\epsilon\\, \\mathbf{e}_i) \\right]}{\\epsilon}\n$$\n这里，$\\mathbf{e}_i$ 是第 $i$ 个参数的标准基向量，$\\epsilon$ 是一个非常小的实数（此处为 $\\epsilon = 10^{-30}$）。对于每个参数 $\\theta_i$，我们添加一个小的虚数扰动 $i\\epsilon$，计算（现在是复数值的）目标函数 $O$，并从其虚部提取导数。这个结果将作为我们评估有限差分法的高精度“基准真相”。\n\n**4. 梯度计算：中心有限差分 (FD) 法**\n\n中心差分近似是一种标准的数值技术：\n$$\n\\frac{\\partial O}{\\partial \\theta_i} \\approx \\frac{O(\\boldsymbol{\\theta} + h_i \\mathbf{e}_i) - O(\\boldsymbol{\\theta} - h_i \\mathbf{e}_i)}{2 h_i}\n$$\n步长 $h_i$ 根据参数的大小进行缩放，$h_i = s \\cdot \\max(|\\theta_i|, 1)$，其中使用了两种不同的尺度因子 $s \\in \\{10^{-6}, 10^{-8}\\}$。此方法每个偏导数需要两次实值函数评估。其精度受限于截断误差（随 $h_i$ 减小而减小）和相减抵消产生的舍入误差（随 $h_i$ 减小而增大）之间的权衡。\n\n**5. 误差分析**\n\n对于每个参数 $\\theta_i$ 和每个尺度因子 $s$，计算 FD 近似相对于 CS 结果的相对误差：\n$$\n\\mathrm{rel\\_err}_i(s) = \\frac{\\left| \\left.\\frac{\\partial O}{\\partial \\theta_i}\\right|_{\\text{FD}}(s) - \\left.\\frac{\\partial O}{\\partial \\theta_i}\\right|_{\\text{CS}} \\right|}{\\max\\!\\left(\\left|\\left.\\frac{\\partial O}{\\partial \\theta_i}\\right|_{\\text{CS}}\\right|, \\delta\\right)}\n$$\n分母的下限为 $\\delta = 10^{-20}$ 以防止除以小数。对于每个测试用例和每个 $s$ 值，最终的度量是所有四个参数中的最大相对误差，$E_{\\max}(s) = \\max_i \\mathrm{rel\\_err}_i(s)$。预期的结果是，较小的有限差分步长 ($s=10^{-8}$) 会因相减抵消的增加而导致更大的误差，这展示了该方法的一个关键局限性。\n\n最终的程序结构会遍历三个测试用例，为每个用例执行这些计算，收集六个所需的 $E_{\\max}$ 值，并以指定的格式打印它们。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import simpson\n\ndef solve():\n    \"\"\"\n    Implements the full calculation pipeline as specified in the problem statement.\n    \"\"\"\n\n    # --- Problem Constants ---\n    R_MAX = 20.0\n    N_POINTS = 20001\n    EPSILON_CS = 1e-30\n    S_VALS = [1e-6, 1e-8]\n    DELTA = 1e-20\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1\n        {'theta': np.array([50.0, 10.0, 5.0, 0.60]), 'theta_star': np.array([52.0, 11.0, 4.9, 0.62])},\n        # Case 2\n        {'theta': np.array([20.0, 5.0, 6.5, 1.20]), 'theta_star': np.array([18.0, 6.0, 6.0, 1.00])},\n        # Case 3\n        {'theta': np.array([70.0, 30.0, 4.0, 0.50]), 'theta_star': np.array([68.0, 28.0, 4.2, 0.45])},\n    ]\n\n    # --- Pre-calculate the radial grid ---\n    r_grid = np.linspace(0, R_MAX, N_POINTS)\n\n    # --- Helper Functions ---\n\n    def f_woods_saxon(r, R, a):\n        \"\"\"\n        Calculates the Woods-Saxon form factor. Handles complex R and a.\n        \"\"\"\n        # np.exp handles complex arguments correctly.\n        return 1.0 / (1.0 + np.exp((r - R) / a))\n\n    def calculate_I(R, a, r_grid_):\n        \"\"\"\n        Calculates the geometric volume integral I(R, a) using Simpson's rule.\n        Handles complex R and a.\n        \"\"\"\n        integrand = f_woods_saxon(r_grid_, R, a) * r_grid_**2\n        integral_val = simpson(integrand, r_grid_)\n        return 4.0 * np.pi * integral_val\n\n    def calculate_O(theta, theta_star, r_grid_):\n        \"\"\"\n        Calculates the objective function O(theta). Handles complex theta.\n        \"\"\"\n        V0, W0, R, a = theta\n        V0_star, W0_star, R_star, a_star = theta_star\n\n        # Calculate target values (always real)\n        I_star = np.real(calculate_I(R_star, a_star, r_grid_))\n        J_R_star = -V0_star * I_star\n        J_I_star = -W0_star * I_star\n\n        # Calculate current values (may be complex)\n        I_val = calculate_I(R, a, r_grid_)\n        J_R = -V0 * I_val\n        J_I = -W0 * I_val\n\n        # Calculate objective function\n        obj_func_val = (J_R - J_R_star)**2 + (J_I - J_I_star)**2\n        return obj_func_val\n\n    # --- Main Calculation Loop ---\n    final_results = []\n    for case in test_cases:\n        theta = case['theta']\n        theta_star = case['theta_star']\n        num_params = len(theta)\n\n        # 1. Compute Complex-Step (CS) gradient (the \"ground truth\")\n        grad_cs = np.zeros(num_params, dtype=np.float64)\n        theta_complex = theta.astype(np.complex128)\n        for i in range(num_params):\n            pert = np.zeros(num_params, dtype=np.complex128)\n            pert[i] = 1j * EPSILON_CS\n            O_perturbed = calculate_O(theta_complex + pert, theta_star, r_grid)\n            grad_cs[i] = np.imag(O_perturbed) / EPSILON_CS\n\n        # Loop over s values for Finite-Difference (FD) method\n        for s in S_VALS:\n            grad_fd = np.zeros(num_params, dtype=np.float64)\n            rel_errs = np.zeros(num_params, dtype=np.float64)\n\n            for i in range(num_params):\n                # 2. Compute Central-Difference gradient\n                h_i = s * max(abs(theta[i]), 1.0)\n                \n                pert_vec = np.zeros(num_params)\n                pert_vec[i] = h_i\n                \n                O_fwd = calculate_O(theta + pert_vec, theta_star, r_grid)\n                O_bwd = calculate_O(theta - pert_vec, theta_star, r_grid)\n                \n                # These results should be real, so take the real part to be safe\n                grad_fd[i] = (np.real(O_fwd) - np.real(O_bwd)) / (2.0 * h_i)\n                \n                # 3. Compute relative error vs CS gradient\n                numerator = abs(grad_fd[i] - grad_cs[i])\n                denominator = max(abs(grad_cs[i]), DELTA)\n                rel_errs[i] = numerator / denominator\n\n            # 4. Find max relative error\n            E_max = np.max(rel_errs)\n            final_results.append(E_max)\n\n    # --- Final Output ---\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3578614"}]}