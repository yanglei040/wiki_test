{"hands_on_practices": [{"introduction": "径向薛定谔方程的数值求解需要在一个有限的区间上进行，但这会从人为设定的边界上引入非物理性的反射。本练习 [@problem_id:3567471] 旨在解决这一根本问题，你将亲手实现并比较两种构建无反射边界的强大技术：复吸收势 (Complex Absorbing Potential, CAP) 和完美匹配层 (Perfectly Matched Layer, PML)。掌握这些方法对于在有限计算区域内获得精确的散射解至关重要。", "problem": "构建一个完整、可运行的程序。在无量纲单位（其中 $\\hbar^{2}/(2\\mu)=1$）下，该程序将含局域复光学模型势的一维 $s$-波径向散射方程在有限格点上离散化，并实现两种吸收边界策略，以减轻在有限半径处截断所引起的伪反射。所求解的约化波函数 $\\psi(r)$ 的稳态径向方程是一个标量边值问题\n$$\n-\\frac{d^{2}\\psi}{dr^{2}} + V(r)\\,\\psi(r) = k^{2}\\,\\psi(r) + S(r), \\quad r \\in [0,R_{\\max}],\n$$\n该问题受限于原点处的正则性条件（出于数值计算的目的，您必须将其施加为狄利克雷边界条件 $\\psi(0)=0$），以及在 $r=R_{\\max}$ 处的截断（在添加吸收层以确保所施加的截断不是反射的主要来源后，您也必须将其施加为狄利克雷边界条件 $\\psi(R_{\\max})=0$）。该光学模型势是局域的、复数的，其实部和虚部均具有中心 Woods–Saxon 形式，\n$$\nV(r) = -\\frac{V_{0}}{1+\\exp\\left(\\frac{r-R_{0}}{a_{0}}\\right)} - i\\,\\frac{W_{0}}{1+\\exp\\left(\\frac{r-R_{w}}{a_{w}}\\right)}.\n$$\n您必须使用一个位于定义域左侧附近的紧致源 $S(r)$ 来驱动该系统，以产生向右传播的波，\n$$\nS(r) = A_{s}\\,\\exp\\!\\left(-\\frac{(r-r_{s})^{2}}{2\\sigma_{s}^{2}}\\right).\n$$\n\n为减少在右侧截断边界处的伪反射，请在右子域 $[R_{\\mathrm{abs}},R_{\\max}]$ 中实现以下两种吸收策略：\n- 复吸收势 (CAP)，通过添加一个仅支撑在 $[R_{\\mathrm{abs}},R_{\\max}]$ 上的额外纯虚势 $-i\\,\\eta(r)$ 来实现，其具有平滑的多项式分布 $\\eta(r) = \\eta_{0}\\left(\\frac{r-R_{\\mathrm{abs}}}{L_{\\mathrm{abs}}}\\right)^{m}$，其中 $L_{\\mathrm{abs}}=R_{\\max}-R_{\\mathrm{abs}}$，$m$ 为正整数。\n- 完美匹配层 (PML)，通过在右子域中进行复坐标伸展 $r \\mapsto s(r)$ 来实现，其特征为一个复伸展因子 $s'(r)=1+i\\,\\sigma(r)$，其中当 $r \\in [R_{\\mathrm{abs}},R_{\\max}]$ 时 $\\sigma(r) = \\sigma_{0}\\left(\\frac{r-R_{\\mathrm{abs}}}{L_{\\mathrm{abs}}}\\right)^{m}$，否则 $\\sigma(r)=0$。在此伸展下，根据频域表述，二阶导数变换为对称微分算符 $-\\frac{d}{dr}\\left(\\frac{1}{s'(r)}\\frac{d\\psi}{dr}\\right)$。\n\n您必须从 $s$-波径向形式的定态薛定谔方程的定义，以及通过在频域中添加虚势（对于 CAP）或进行复坐标伸展（对于 PML）来构造吸收层这两点出发。您不能假定任何预制的离散化方法；相反，您必须为对称算符 $-\\frac{d}{dr}\\!\\left(a(r)\\,\\frac{d\\psi}{dr}\\right)$ 推导一个相容的二阶有限差分格式（对于 CAP 方案，$a(r)=1$；对于 PML 方案，$a(r)=\\frac{1}{1+i\\,\\sigma(r)}$），施加所述的狄利克雷边界条件，并在均匀网格上求解得到的线性系统。\n\n为量化剩余伪反射，请在一个严格位于右侧吸收区域左侧的监测窗口 $[r_{1},r_{2}]$ 中提取反射振幅的估计值。在该窗口中，$V(r)=0$ 且不存在吸收分布，解可以很好地近似为向右和向左传播的平面波的叠加，\n$$\n\\psi(r) \\approx A\\,e^{i\\,k\\,r} + B\\,e^{-i\\,k\\,r},\n$$\n其中 $k=\\sqrt{E}$ 为实数，$E=k^{2}$ 是散射能量。请使用 $[r_{1},r_{2}]$ 内网格点上的最小二乘拟合来估计复振幅 $A$ 和 $B$，并报告标量反射度量 $\\mathcal{R}=\\left|B\\right|/\\left|A\\right|$。\n\n所有量均为无量纲，因此您不能报告任何物理单位。未使用角度。您的数值实现对于以下参数必须是稳定且收敛的。\n\n网格与定义域规格：\n- 总半径 $R_{\\max}=30.0$。\n- 均匀网格间距 $h=0.02$。\n- 长度为 $L_{\\mathrm{left}}=3.0$ 的左侧吸收缓冲层，通过强度参数为 $\\eta_{\\mathrm{left}}=5.0$、多项式指数为 $m_{\\mathrm{left}}=2$ 的左侧 CAP 来抑制来自 $r=0$ 的反射。\n- 源参数 $A_{s}=1.0$，$r_{s}=4.0$，$\\sigma_{s}=0.3$。\n- 光学模型势参数 $V_{0}=50.0$，$W_{0}=5.0$，$R_{0}=6.0$，$a_{0}=0.5$，$R_{w}=6.0$，$a_{w}=0.5$。\n- 散射能量 $E=1.0$，因此 $k=\\sqrt{E}=1.0$。\n\n右层监测窗口位置：\n- 对于每个测试，将右侧吸收区域的起始位置设为 $R_{\\mathrm{abs}}=R_{\\max}-L_{\\mathrm{right}}$，并定义监测窗口 $[r_{1},r_{2}]$，其中 $r_{1}=R_{\\mathrm{abs}}-4.0$ 且 $r_{2}=R_{\\mathrm{abs}}-1.0$。\n\n测试套件：\n实现以下四个测试用例，它们仅在右层类型和参数上有所不同。对于每个用例，计算并返回从监测窗口中的拟合获得的反射度量 $\\mathcal{R}$。\n- 用例 $\\mathbf{1}$ (无右侧吸收体)：右层类型为“none”，$L_{\\mathrm{right}}=6.0$；将右层分布设为零，使得处处 $a(r)=1$ 且右侧不添加额外的虚势。\n- 用例 $\\mathbf{2}$ (弱 CAP)：右层类型为“cap”，$L_{\\mathrm{right}}=6.0$，CAP 强度 $\\eta_{0}=0.5$，多项式指数 $m=2$。\n- 用例 $\\mathbf{3}$ (强 CAP)：右层类型为“cap”，$L_{\\mathrm{right}}=8.0$，CAP 强度 $\\eta_{0}=3.0$，多项式指数 $m=4$。\n- 用例 $\\mathbf{4}$ (PML)：右层类型为“pml”，$L_{\\mathrm{right}}=8.0$，PML 强度 $\\sigma_{0}=2.0$，多项式指数 $m=3$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按用例 $\\mathbf{1}$ 到 $\\mathbf{4}$ 的顺序排列结果。每个条目必须是代表该用例的 $\\mathcal{R}$ 值的浮点数。例如，一个语法正确、使用占位符值的输出将类似于“[0.5,0.1,0.01,0.0001]”，但您必须输出指定测试套件的实际计算值。", "solution": "用户的要求是求解在有限格点上离散化的、含局域复光学势的一维 $s$-波径向薛定谔方程。关键任务是实现并比较两种不同类型的吸收边界条件——复吸收势 (CAP) 和完美匹配层 (PML)——以减轻因在 $r=R_{\\max}$ 处对定义域进行人为截断而产生的伪反射。其性能通过在一个特定监测窗口内进行最小二乘拟合提取的反射度量 $\\mathcal{R}$ 来量化。\n\n控制方程是一个边值问题，由下式给出：\n$$\n-\\frac{d}{dr}\\left(a(r)\\,\\frac{d\\psi}{dr}\\right) + V_{\\mathrm{eff}}(r)\\,\\psi(r) = E\\,\\psi(r) + S(r)\n$$\n定义域为 $r \\in [0, R_{\\max}]$，边界条件为狄利克雷边界条件 $\\psi(0) = 0$ 和 $\\psi(R_{\\max}) = 0$。能量固定为 $E=k^2=1.0$。\n\n首先，我们建立一个均匀的数值网格 $r_j = j \\cdot h$，其中 $j=0, 1, \\dots, N$，$h$ 是网格间距，$N = R_{\\max}/h$。此网格上的波函数记为 $\\psi_j = \\psi(r_j)$。\n\n该问题为项 $a(r)$ 和有效势 $V_{\\mathrm{eff}}(r)$ 指定了两种情景：\n1.  **CAP 策略**：将一个虚势 $-i\\eta(r)$ 添加到物理势中。在这种情况下，处处都有 $a(r)=1$。总有效势为 $V_{\\mathrm{eff}}(r) = V(r) - i\\eta_{\\mathrm{left}}(r) - i\\eta_{\\mathrm{right}}(r)$，其中 $V(r)$ 是 Woods-Saxon 光学势，$\\eta_{\\mathrm{left}}(r)$ 和 $\\eta_{\\mathrm{right}}(r)$ 分别是左、右吸收势。\n2.  **PML 策略**：在吸收区域应用复坐标伸展。这会修改动能算符。函数 $a(r)$ 变为 $a(r) = (1+i\\sigma(r))^{-1}$，其中 $\\sigma(r)$ 仅在 PML 区域内非零。有效势仅由物理光学势和左侧吸收体组成：$V_{\\mathrm{eff}}(r) = V(r) - i\\eta_{\\mathrm{left}}(r)$。\n\n使用二阶有限差分格式对微分算符 $-\\frac{d}{dr}\\left(a(r)\\frac{d\\psi}{dr}\\right)$ 进行离散化。我们在半网格点 $r_{j+1/2} = r_j + h/2$ 处计算 $a(r)$ 的值。在内部网格点 $r_j$（对于 $j=1, \\dots, N-1$）处的离散方程为：\n$$\n-\\frac{1}{h^2} \\left[ a_{j+1/2}(\\psi_{j+1}-\\psi_j) - a_{j-1/2}(\\psi_j - \\psi_{j-1}) \\right] + (V_{\\mathrm{eff},j} - E)\\psi_j = S_j\n$$\n其中 $a_{j\\pm 1/2}=a(r_{j\\pm 1/2})$，$V_{\\mathrm{eff},j}=V_{\\mathrm{eff}}(r_j)$，$S_j=S(r_j)$。整理这些项，我们得到一个关于未知内部波函数值 $\\vec{\\psi}_{\\mathrm{int}} = (\\psi_1, \\psi_2, \\dots, \\psi_{N-1})^T$ 的线性系统：\n$$\n-\\frac{a_{j-1/2}}{h^2} \\psi_{j-1} + \\left(\\frac{a_{j+1/2}+a_{j-1/2}}{h^2} + V_{\\mathrm{eff},j} - E\\right) \\psi_j - \\frac{a_{j+1/2}}{h^2} \\psi_{j+1} = S_j\n$$\n这构成了一个复值三对角线性方程组 $M \\vec{\\psi}_{\\mathrm{int}} = \\vec{S}_{\\mathrm{int}}$。矩阵 $M$ 定义如下：\n-   **对角元素**：$M_{j-1,j-1} = \\frac{a_{j+1/2}+a_{j-1/2}}{h^2} + V_{\\mathrm{eff},j} - E$\n-   **非对角元素**：$M_{j-1,j} = -\\frac{a_{j+1/2}}{h^2}$ 和 $M_{j,j-1} = -\\frac{a_{j-1/2}}{h^2}$。注意，如果 $a(r)$ 是一个缓变函数，则该矩阵近似为复对称矩阵，即 $M_{ij} \\approx M_{ji}$。\n\n这个三对角系统可以使用专门的算法高效求解，例如 `scipy.linalg.solve_banded` 提供的算法。\n\n求解出 $\\vec{\\psi}_{\\mathrm{int}}$ 后，构建完整的数值解 $\\vec{\\psi} = (0, \\psi_1, \\dots, \\psi_{N-1}, 0)^T$。\n\n为量化反射，我们在位于自由空间区域（其中 $V(r) \\approx 0$ 且无吸收体）的“监测窗口” $[r_1, r_2]$ 中分析解。在此区域，解是向右传播的波和反射的向左传播的波的叠加：\n$$\n\\psi(r) \\approx A\\,e^{ikr} + B\\,e^{-ikr}\n$$\n我们对网格点 $r_j \\in [r_1, r_2]$ 上的数值解 $\\psi_j$ 进行线性最小二乘拟合，以确定复振幅 $A$ 和 $B$。此拟合的设计矩阵 $X$ 有两列，$[e^{ikr_j}]$ 和 $[e^{-ikr_j}]$，系数向量为 $\\beta = (A, B)^T$。最小二乘解通过 $\\beta = (X^H X)^{-1} X^H \\vec{\\psi}_{\\mathrm{fit}}$ 求得。最后，反射度量计算为振幅大小之比：$\\mathcal{R} = |B|/|A|$。\n\n实现过程将首先定义一个函数，该函数接收每个测试用例的参数，构造所有势和系数数组，组装并求解线性系统，然后执行反射分析。随后，对四个指定的测试用例分别调用此函数。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Constructs and solves the discretized 1D radial scattering equation\n    with different absorbing boundary conditions, and computes the reflection measure\n    for four test cases.\n    \"\"\"\n\n    def run_simulation(case_params):\n        \"\"\"\n        Solves the radial Schrödinger equation for a single set of parameters.\n\n        Args:\n            case_params (dict): A dictionary containing parameters for the test case.\n\n        Returns:\n            float: The computed reflection measure R = |B|/|A|.\n        \"\"\"\n        # --- Fixed parameters from the problem statement ---\n        R_max = 30.0\n        h = 0.02\n        E = 1.0\n        k = np.sqrt(E)\n\n        # --- Grid setup ---\n        N = int(R_max / h)\n        r = np.linspace(0.0, R_max, N + 1)\n        r_int = r[1:-1]\n        r_half = r[:-1] + h / 2\n\n        # --- Base potential and source definitions ---\n        # Optical model potential (Woods-Saxon form)\n        V0, W0, R0, a0, Rw, aw = 50.0, 5.0, 6.0, 0.5, 6.0, 0.5\n        V_r = -V0 / (1.0 + np.exp((r - R0) / a0))\n        V_i = -W0 / (1.0 + np.exp((r - Rw) / aw))\n        V_optical = V_r + 1j * V_i\n        \n        # Gaussian source term\n        A_s, r_s, sigma_s = 1.0, 4.0, 0.3\n        S = A_s * np.exp(-(r - r_s)**2 / (2.0 * sigma_s**2))\n\n        # --- Absorbing layers setup ---\n        # Left-side Complex Absorbing Potential (CAP)\n        L_left, eta_left_strength, m_left = 3.0, 5.0, 2\n        eta_left = np.zeros_like(r, dtype=np.float64)\n        left_mask = r = L_left\n        eta_left[left_mask] = eta_left_strength * ((L_left - r[left_mask]) / L_left)**m_left\n        V_eff = V_optical - 1j * eta_left\n\n        # Right-side absorber (case-specific)\n        absorber_type = case_params['type']\n        L_right = case_params['L_right']\n        R_abs = R_max - L_right\n\n        # Pre-calculate relative positions for right absorber profiles\n        right_mask = r >= R_abs\n        r_in_absorber = np.zeros_like(r, dtype=np.float64)\n        r_in_absorber[right_mask] = (r[right_mask] - R_abs) / L_right\n\n        right_mask_half = r_half >= R_abs\n        r_half_in_absorber = np.zeros_like(r_half, dtype=np.float64)\n        r_half_in_absorber[right_mask_half] = (r_half[right_mask_half] - R_abs) / L_right\n\n        a_half = np.ones(N, dtype=np.complex128)\n\n        if absorber_type == 'cap':\n            eta_0, m = case_params['strength'], case_params['power']\n            eta_right = np.zeros_like(r, dtype=np.float64)\n            eta_right[right_mask] = eta_0 * (r_in_absorber[right_mask]**m)\n            V_eff -= 1j * eta_right\n        elif absorber_type == 'pml':\n            sigma_0, m = case_params['strength'], case_params['power']\n            sigma_r_half = np.zeros_like(r_half, dtype=np.float64)\n            sigma_r_half[right_mask_half] = sigma_0 * (r_half_in_absorber[right_mask_half]**m)\n            a_half = 1.0 / (1.0 + 1j * sigma_r_half)\n\n        # --- Discretization and Linear System Construction ---\n        V_eff_int = V_eff[1:-1]\n        S_int = S[1:-1]\n        N_mat = N - 1\n\n        # Tridiagonal matrix components for M * psi = S\n        main_diag = (a_half[1:N] + a_half[0:N-1]) / h**2 + V_eff_int - E\n        upper_diag = -a_half[1:N-1] / h**2\n        lower_diag = -a_half[1:N-1] / h**2\n        \n        # Scipy's solve_banded uses a specific banded matrix format (ab)\n        ab = np.zeros((3, N_mat), dtype=np.complex128)\n        ab[0, 1:] = upper_diag\n        ab[1, :] = main_diag\n        ab[2, :-1] = lower_diag\n        \n        # Solve the linear system\n        psi_int = solve_banded((1, 1), ab, S_int)\n        \n        # Reconstruct full wavefunction with boundary conditions\n        psi = np.concatenate(([0j], psi_int, [0j]))\n\n        # --- Reflection Analysis ---\n        r1, r2 = R_abs - 4.0, R_abs - 1.0\n        j1 = int(round(r1 / h))\n        j2 = int(round(r2 / h))\n\n        r_fit = r[j1 : j2 + 1]\n        psi_fit = psi[j1 : j2 + 1]\n\n        # Least squares fit to model: psi(r) = A*exp(ikr) + B*exp(-ikr)\n        phi1 = np.exp(1j * k * r_fit)\n        phi2 = np.exp(-1j * k * r_fit)\n        X = np.stack([phi1, phi2], axis=1)\n        \n        coeffs, _, _, _ = np.linalg.lstsq(X, psi_fit, rcond=None)\n        A, B = coeffs[0], coeffs[1]\n        \n        reflection_measure = np.abs(B) / np.abs(A)\n        return reflection_measure\n        \n    # --- Test Suite Definition ---\n    test_cases = [\n        # Case 1: No right absorber\n        {'type': 'none', 'L_right': 6.0},\n        # Case 2: Weak CAP\n        {'type': 'cap', 'L_right': 6.0, 'strength': 0.5, 'power': 2},\n        # Case 3: Strong CAP\n        {'type': 'cap', 'L_right': 8.0, 'strength': 3.0, 'power': 4},\n        # Case 4: PML\n        {'type': 'pml', 'L_right': 8.0, 'strength': 2.0, 'power': 3},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # --- Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3567471"}, {"introduction": "一个具有预测能力的光学势必须遵循基本的物理原理，其中因果性至关重要。因果性通过克拉默-克若尼格 (Kramers-Kronig) 色散关系将势的实部和虚部联系起来。在本练习 [@problem_id:3567524] 中，你将亲手实现这一关联，从给定的虚部势 $W(E)$ 出发计算色散修正项 $\\Delta V(E)$，从而构建一个物理上自洽的色散光学模型。", "problem": "有限核中自旋平均的核子光学势可以通过 Kramers–Kronig 关系受到因果律的约束，该关系连接了其依赖于能量的实部和虚部。考虑一个单粒子能量变量 $E$（单位为 $\\mathrm{MeV}$），该变量是相对于费米能 $E_F$（单位也为 $\\mathrm{MeV}$）测量的。设虚部由一个围绕 $E_F$ 的光滑、可积的偶函数建模，该函数在 $E=E_F$ 处为零，并在 $|E-E_F|$ 较大时衰减，以保证数值收敛。具体定义如下：\n$$\nW(E) \\equiv W_0 \\left(1 - e^{-\\frac{(E-E_F)^2}{d^2}}\\right) e^{-\\frac{(E-E_F)^2}{s^2}},\n$$\n参数为 $W_0 = 50\\,\\mathrm{MeV}$，$d = 10\\,\\mathrm{MeV}$，$s = 80\\,\\mathrm{MeV}$ 以及 $E_F = -8\\,\\mathrm{MeV}$。根据因果律，实部色散修正 $\\Delta V(E)$ 由减除的 Kramers–Kronig 关系给出，该关系表示为一个减除的柯西核的柯西主值积分。您的任务是使用两种独立的数值策略，对 $\\Delta V(E)$ 的减除主值积分进行数值实现，并根据其中一种策略生成的合成参考数据来验证 Kramers–Kronig 的一致性属性。\n\n在一个完整、可运行的程序中实现以下内容：\n\n- 使用能量积分界限 $[E_{\\min}, E_{\\max}] = [E_F - 400\\,\\mathrm{MeV}, E_F + 400\\,\\mathrm{MeV}]$ 来近似无限域主值积分。将积分在 $E$ 和 $E_F$ 两个奇点处都视为主值。\n- 方法 A（分段主值）：通过将积分域分割成多个子区间，以排除界限内任意奇点 $E$ 和 $E_F$ 的小的对称邻域，从而实现对主值积分的直接数值求积。在每个子区间上使用一个小的排除半宽 $\\varepsilon = 10^{-6}\\,\\mathrm{MeV}$ 和高精度求积。这将为 $\\Delta V(E)$ 生成一个数值结果。\n- 方法 B（参考加权求积）：通过在相同的有限界限上使用柯西加权主值求积，分别计算以 $E$ 和 $E_F$ 为中心的两个带有柯西核的主值积分，然后将它们相减得到 $\\Delta V(E)$，从而实现一个参考计算。这将作为您验证方法 A 所用的合成“数据”。\n\n使用这两种方法，评估以下验证量，所有量均以 $\\mathrm{MeV}$ 表示：\n1. 通过方法 A 计算的绝对值 $|\\Delta V(E_F)|$。\n2. 在关于 $E_F$ 的对称偏移量 $\\Delta = 25\\,\\mathrm{MeV}$ 处的奇性残差，即通过方法 A 计算的 $|\\Delta V(E_F+\\Delta) + \\Delta V(E_F-\\Delta)|$。\n3. 在能量集合 $\\{E_F-60\\,\\mathrm{MeV},\\,E_F-20\\,\\mathrm{MeV},\\,E_F,\\,E_F+20\\,\\mathrm{MeV},\\,E_F+60\\,\\mathrm{MeV}\\}$ 上，方法 A 和方法 B 之间的最大绝对偏差。\n\n此问题不涉及角度单位。所有能量和输出必须以 $\\mathrm{MeV}$ 为单位。您的程序应生成单行输出，其中包含按上述顺序排列的三个结果，格式为方括号括起来的逗号分隔列表（例如，“[x1,x2,x3]”）。\n\n测试套件：\n- 使用能量网格 $\\{E_F-60\\,\\mathrm{MeV},\\,E_F-20\\,\\mathrm{MeV},\\,E_F,\\,E_F+20\\,\\mathrm{MeV},\\,E_F+60\\,\\mathrm{MeV}\\}$ 计算第 3 项中的偏差。\n- 对第 1 项使用费米能 $E_F=-8\\,\\mathrm{MeV}$。\n- 对第 2 项使用 $\\Delta=25\\,\\mathrm{MeV}$。\n三个测试用例的答案必须是三个以 $\\mathrm{MeV}$ 为单位的浮点数，并按规定聚合成单行上的一个列表。", "solution": "该问题要求对核物理中的核子光学势的减除 Kramers–Kronig 关系进行数值实现和验证。问题的核心在于计算势的实部色散修正 $\\Delta V(E)$，该修正由其虚部 $W(E)$ 导出。\n\n势的虚部由以下函数给出：\n$$\nW(E) = W_0 \\left(1 - e^{-\\frac{(E-E_F)^2}{d^2}}\\right) e^{-\\frac{(E-E_F)^2}{s^2}}\n$$\n参数为 $W_0 = 50\\,\\mathrm{MeV}$，$d = 10\\,\\mathrm{MeV}$，$s = 80\\,\\mathrm{MeV}$，费米能 $E_F = -8\\,\\mathrm{MeV}$。此函数关于变量 $(E-E_F)$ 是偶函数，即 $W(E_F + \\delta E) = W(E_F - \\delta E)$。此外，项 $\\left(1 - \\exp\\left(-\\frac{(E-E_F)^2}{d^2}\\right)\\right)$ 确保 $W(E)$ 在费米能处按平方次幂趋于零，即当 $E \\to E_F$ 时，$W(E) \\propto (E-E_F)^2$。\n\n实部色散修正 $\\Delta V(E)$ 通过一次减除的 Kramers–Kronig 关系与 $W(E)$ 相关联。减除在费米能 $E_F$ 处进行，以确保 $\\Delta V(E_F) = 0$。该关系可以表示为两个柯西主值积分之差：\n$$\n\\Delta V(E) = \\frac{1}{\\pi} \\mathcal{P} \\int_{-\\infty}^{\\infty} \\frac{W(E')}{E' - E} dE' - \\frac{1}{\\pi} \\mathcal{P} \\int_{-\\infty}^{\\infty} \\frac{W(E')}{E' - E_F} dE'\n$$\n此形式等价于更常见的单积分表达式：\n$$\n\\Delta V(E) = \\frac{E - E_F}{\\pi} \\mathcal{P} \\int_{-\\infty}^{\\infty} \\frac{W(E')}{(E' - E)(E' - E_F)} dE'\n$$\n问题指定通过在有限的对称域 $[E_{\\min}, E_{\\max}] = [E_F - 400\\,\\mathrm{MeV}, E_F + 400\\,\\mathrm{MeV}]$ 上积分来近似无限积分。\n\n由于 $W(E)$ 是关于 $E_F$ 的偶函数，并且积分域关于 $E_F$ 对称，因此得到的色散修正 $\\Delta V(E)$ 必须是关于 $E_F$ 的奇函数。这意味着需要进行数值验证的两个关键属性：\n1.  $\\Delta V(E_F) = 0$。\n2.  $\\Delta V(E_F + \\delta E) = - \\Delta V(E_F - \\delta E)$，或等价地，$\\Delta V(E_F + \\delta E) + \\Delta V(E_F - \\delta E) = 0$。\n\n为计算 $\\Delta V(E)$，实现了两种数值方法。\n\n**方法 A：分段主值求积**\n此方法直接实现了主值积分的定义。被积函数为：\n$$\nf(E') = \\frac{W(E')}{\\pi} \\left( \\frac{1}{E' - E} - \\frac{1}{E' - E_F} \\right)\n$$\n该被积函数在 $E' = E$ 和 $E' = E_F$ 处有奇点。为计算主值，积分域 $[E_{\\min}, E_{\\max}]$ 被分割成多个子区间，明确排除了奇点周围小的对称邻域 $(E - \\varepsilon, E + \\varepsilon)$ 和 $(E_F - \\varepsilon, E_F + \\varepsilon)$，其中 $\\varepsilon = 10^{-6}\\,\\mathrm{MeV}$。积分即为在剩余子区间上积分的总和。例如，如果 $E  E_F$，积分计算如下：\n$$\n\\int_{E_{\\min}}^{E_F-\\varepsilon} f(E') dE' + \\int_{E_F+\\varepsilon}^{E-\\varepsilon} f(E') dE' + \\int_{E+\\varepsilon}^{E_{\\max}} f(E') dE'\n$$\n每个非奇异子区间上的积分使用高精度数值求积例程（`scipy.integrate.quad`）计算。在 $E = E_F$ 的特殊情况下，括号中的两项相互抵消，对于 $E' \\ne E_F$，被积函数恒等于零。因此，积分结果为零。\n\n**方法 B：参考加权求积**\n该方法作为一个高精度的参考。它使用专门针对柯西加权积分的数值算法，分别计算 $\\Delta V(E)$ 定义中的两个主值积分。\n$$\n\\Delta V(E) = \\frac{1}{\\pi} \\left( I(E) - I(E_F) \\right) \\quad \\text{其中} \\quad I(x) = \\mathcal{P} \\int_{E_{\\min}}^{E_{\\max}} \\frac{W(E')}{E' - x} dE'\n$$\n积分 $I(x)$ 使用 `scipy.integrate.quad` 及其 `weight='cauchy'` 和 `wvar=x` 选项进行计算，该方法专为此类积分设计，通常能提供非常精确的结果。\n\n**验证量**\n待计算的三个量用于将方法 A 的实现与理论预期和参考计算（方法 B）进行比较验证。\n1.  **$|\\Delta V_A(E_F)|$**：此项测试实现中对减除点的处理。理论上，该值为 $0$。在方法 A 的实现中，如果 $E = E_F$，被积函数将恒等于零，从而得出结果 $0.0$。\n2.  **$|\\Delta V_A(E_F+\\Delta) + \\Delta V_A(E_F-\\Delta)|$**：此项测试在 $E_F$ 附近对 $\\Delta V(E)$ 奇函数性质的数值保持情况。由于对称的积分限和 $W(E)$ 的偶函数性质，该和应为零。计算出的值代表数值残差，应非常小。\n3.  **最大绝对偏差**：该量，即 $\\max_{E} |\\Delta V_A(E) - \\Delta V_B(E)|$，量化了在一组测试能量上，“暴力”主值计算（方法 A）与专门的库例程（方法 B）之间的一致性。一个小的偏差证实了两种实现的正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the computational nuclear physics problem as specified.\n    1. Defines the optical potential model and parameters.\n    2. Implements two numerical methods (A and B) for the Kramers-Kronig integral.\n    3. Computes the three specified validation quantities.\n    4. Prints the results in the required format.\n    \"\"\"\n    \n    # --- Define constants and parameters ---\n    W0 = 50.0  # MeV\n    d = 10.0   # MeV\n    s = 80.0   # MeV\n    EF = -8.0  # MeV\n    eps = 1e-6 # MeV, exclusion half-width for Method A\n\n    # Integration bounds\n    E_min = EF - 400.0  # MeV\n    E_max = EF + 400.0  # MeV\n\n    # --- Test case parameters ---\n    delta_oddness = 25.0  # MeV, for validation quantity 2\n    E_grid_relative = np.array([-60.0, -20.0, 0.0, 20.0, 60.0])\n    E_grid_test = EF + E_grid_relative  # MeV, for validation quantity 3\n\n    # --- Imaginary Potential W(E) ---\n    def W_func(E_prime, EF_val, W0_val, d_val, s_val):\n        \"\"\"\n        Calculates the imaginary part of the optical potential W(E').\n        \"\"\"\n        # Using a shifted energy variable to avoid large numbers\n        x = E_prime - EF_val\n        term1 = 1.0 - np.exp(-(x**2) / (d_val**2))\n        term2 = np.exp(-(x**2) / (s_val**2))\n        return W0_val * term1 * term2\n\n    # --- Method A: Piecewise Principal Value Quadrature ---\n    def delta_V_A(E, EF_val, W0_val, d_val, s_val):\n        \"\"\"\n        Computes the dispersive correction Delta_V(E) using Method A.\n        The integral is split to avoid singularities at E and EF.\n        \"\"\"\n        # The integrand for the subtracted dispersion relation\n        def integrand(E_prime, E_val):\n            w_val = W_func(E_prime, EF_val, W0_val, d_val, s_val)\n            # This form can be unstable if E is very close to EF.\n            # However, the problem specifies PV at both E and EF.\n            if abs(E_prime - E_val)  1e-15 or abs(E_prime - EF_val)  1e-15:\n                 return 0.0 # Should be handled by interval exclusion\n            term_E = 1.0 / (E_prime - E_val)\n            term_EF = 1.0 / (E_prime - EF_val)\n            return w_val * (term_E - term_EF)\n\n        # Handle singularities by splitting the integration domain\n        s1 = min(E, EF_val)\n        s2 = max(E, EF_val)\n\n        # If E and EF are identical, the integrand is zero everywhere (numerically).\n        # This correctly reflects Delta_V(EF) = 0.\n        if abs(E - EF_val)  1e-12:\n            return 0.0\n        \n        total_integral = 0.0\n        \n        # Integrate from E_min to the first singularity\n        res1, _ = quad(integrand, E_min, s1 - eps, args=(E,))\n        total_integral += res1\n        \n        # Integrate between the two singularities\n        if (s1 + eps)  (s2 - eps):\n            res2, _ = quad(integrand, s1 + eps, s2 - eps, args=(E,))\n            total_integral += res2\n        \n        # Integrate from the second singularity to E_max\n        res3, _ = quad(integrand, s2 + eps, E_max, args=(E,))\n        total_integral += res3\n        \n        return total_integral / np.pi\n\n    # --- Method B: Reference Weighted Quadrature ---\n    def delta_V_B(E, EF_val, W0_val, d_val, s_val):\n        \"\"\"\n        Computes Delta_V(E) using Method B (Cauchy-weighted quadrature).\n        This serves as the reference \"data\".\n        \"\"\"\n        \n        # Function to integrate is just W(E')\n        def w_integrand(E_prime):\n            return W_func(E_prime, EF_val, W0_val, d_val, s_val)\n\n        # If E and EF are identical, result is 0 by definition\n        if abs(E - EF_val)  1e-12:\n            return 0.0\n\n        # Calculate the two principal value integrals separately\n        # I(E) = P.V. integral of W(E')/(E' - E)\n        integral_E, _ = quad(w_integrand, E_min, E_max, weight='cauchy', wvar=E)\n        \n        # I(EF) = P.V. integral of W(E')/(E' - EF)\n        integral_EF, _ = quad(w_integrand, E_min, E_max, weight='cauchy', wvar=EF_val)\n        \n        return (integral_E - integral_EF) / np.pi\n\n    # --- Compute the three validation quantities ---\n    results = []\n\n    # 1. Absolute value |Delta V(EF)| computed by Method A.\n    # The definition of the subtracted dispersion relation ensures this is 0.\n    # Method A implementation also yields 0 when E=EF.\n    val1 = abs(delta_V_A(EF, EF, W0, d, s))\n    results.append(val1)\n\n    # 2. Oddness residual |Delta V(EF+d) + Delta V(EF-d)| by Method A.\n    # Theoretically, this is 0 due to symmetry. The result is a numerical residual.\n    v_plus_delta = delta_V_A(EF + delta_oddness, EF, W0, d, s)\n    v_minus_delta = delta_V_A(EF - delta_oddness, EF, W0, d, s)\n    val2 = abs(v_plus_delta + v_minus_delta)\n    results.append(val2)\n\n    # 3. Maximum absolute deviation between Method A and Method B.\n    max_deviation = 0.0\n    for E_test in E_grid_test:\n        v_a = delta_V_A(E_test, EF, W0, d, s)\n        v_b = delta_V_B(E_test, EF, W0, d, s)\n        deviation = abs(v_a - v_b)\n        if deviation > max_deviation:\n            max_deviation = deviation\n    val3 = max_deviation\n    results.append(val3)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3567524"}, {"introduction": "核模型研究中的一个关键挑战是，不同的模型参数组往往能同样好地描述现有数据，从而导致严重的模糊性。这个高级练习 [@problem_id:3567510] 旨在解决如何设计新的实验来消除这类简并的问题。通过实现一个贪心算法，你将学习如何选择一个最优化的最小测量组合，以最有效地分辨相互竞争的参数集，这展示了计算如何指导实验策略的设计。", "problem": "考虑在非相对论极限下的弹性核子-原子核散射，该过程由包含一个复数、局域光学模型势的定态薛定谔方程所描述。设光学模型势由一个小的有效强度集合参数化，这些强度收集在一个向量 $\\boldsymbol{\\theta} = (V, W, V_{\\mathrm{so}})$ 中，分别代表有效实中心深度、有效虚部强度和有效自旋轨道强度。在全局光学模型分析中，通过参数化引入显式的能量依赖性，而在局域拟合中，则是在固定的入射粒子能量和靶核下估计 $\\boldsymbol{\\theta}$。本问题考虑一个计算设计任务：给定 $\\boldsymbol{\\theta}$ 上的一个多峰后验分布（参数空间中多个分离良好的岛），选择一个最小的自旋可观测量和入射粒子能量集合，当在指定的实验室散射角下进行测量时，能在所有竞争的岛之间产生足够的统计区分度。\n\n基本出发点如下。\n\n- 复光学模型势进入薛定谔方程，并导出一个 $S$ 矩阵，其矩阵元决定了实验室可观测量，如非极化微分截面、矢量分析能和自旋旋转函数。这些可观测量是势强度的可微泛函。\n- 对于 $\\boldsymbol{\\theta}$ 在一个名义值附近的微小扰动，一阶线性化是合适的：一个标量可观测量 $y$ 满足 $y(\\boldsymbol{\\theta}) \\approx y(\\boldsymbol{\\mu}) + \\boldsymbol{J}(\\boldsymbol{\\mu}) \\cdot (\\boldsymbol{\\theta} - \\boldsymbol{\\mu})$，其中 $\\boldsymbol{\\mu}$ 是一个参考参数，$\\boldsymbol{J}$ 是关于 $\\boldsymbol{\\theta}$ 的梯度。\n- 如果 $\\boldsymbol{\\theta}$ 的协方差为 $\\boldsymbol{\\Sigma}$，且测量具有方差为 $\\sigma_{\\mathrm{meas}}^2$ 的独立高斯噪声，那么线性化可观测量的预测方差为 $s^2 = \\boldsymbol{J}\\,\\boldsymbol{\\Sigma}\\,\\boldsymbol{J}^\\top + \\sigma_{\\mathrm{meas}}^2$。\n- 对于两个竞争的岛 $i$ 和 $j$，它们产生一维高斯预测分布 $\\mathcal{N}(\\mu_i,s_i^2)$ 和 $\\mathcal{N}(\\mu_j,s_j^2)$，一个随可分性增加而增加的可区分性度量是 Bhattacharyya 距离，\n$$\nD_B^{(1\\mathrm{D})}(i,j) = \\frac{1}{4}\\ln\\!\\left(\\frac{1}{4}\\left(\\frac{s_i^2}{s_j^2} + \\frac{s_j^2}{s_i^2} + 2\\right)\\right)\n+ \\frac{1}{4}\\frac{(\\mu_i - \\mu_j)^2}{s_i^2 + s_j^2}.\n$$\n- 对于一组独立测量，在此近似下可加性成立，因此一对 $(i,j)$ 的累积距离是所选测量通道上的总和。\n\n为了使计算自洽，我们通过以下平滑的代理函数来近似从 $(\\boldsymbol{\\theta}, E, \\vartheta_{\\mathrm{lab}})$ 到实验室可观测量的映射。这些函数反映了局域与全局光学模型势的定性灵敏度模式，并且在 $\\boldsymbol{\\theta}$ 上是可微的。设 $E$ 表示以兆电子伏特（MeV）为单位的入射粒子动能，$\\vartheta_{\\mathrm{lab}}$ 表示以度为单位的实验室散射角。定义 $x = \\cos(\\vartheta_{\\mathrm{lab}} \\times \\pi/180)$，$s_v(E) = 1/(1 + E/E_v)$ 其中 $E_v = 80$，以及 $s_w(E) = E/(E + E_w)$ 其中 $E_w = 40$。设 $V_{\\mathrm{eff}} = V\\,s_v(E)$ 和 $W_{\\mathrm{eff}} = W\\,s_w(E)$。对于非极化微分截面（归一化到一个方便的尺度）$\\sigma$、矢量分析能 $A_y$ 和自旋旋转函数 $Q$，使用\n- $\\sigma(\\boldsymbol{\\theta};E,\\vartheta_{\\mathrm{lab}}) = 1 + 10^{-3}\\!\\left(V_{\\mathrm{eff}}^2 + 0.5\\,W_{\\mathrm{eff}}^2\\right) + 5\\cdot 10^{-4}\\,P_2(x)\\,V_{\\mathrm{eff}}W_{\\mathrm{eff}}$，其中 $P_2(x) = (3x^2 - 1)/2$，\n- $A_y(\\boldsymbol{\\theta};E,\\vartheta_{\\mathrm{lab}}) = \\tanh\\!\\left( \\kappa(E)\\,V_{\\mathrm{so}}\\,\\sin(\\vartheta_{\\mathrm{lab}}\\times \\pi/180)\\,\\big(1 + 2\\cdot 10^{-3}V_{\\mathrm{eff}} - 10^{-3}W_{\\mathrm{eff}}\\big) \\right)$，其中 $\\kappa(E) = 0.01 + 0.4\\,E/(E+50)$，\n- $Q(\\boldsymbol{\\theta};E,\\vartheta_{\\mathrm{lab}}) = \\tanh\\!\\left( q_0(E)\\,V_{\\mathrm{so}}\\,x + 10^{-4}\\,q_1(E)\\,V_{\\mathrm{eff}}W_{\\mathrm{eff}}\\,x \\right)$，其中 $q_0(E) = 0.002\\,E$ 且 $q_1(E) = 0.5$。\n\n假设多峰后验由 $K$ 个岛表示，每个岛在 $\\boldsymbol{\\theta}$ 的参数空间中被局域地近似为一个多元正态分布 $\\mathcal{N}(\\boldsymbol{\\mu}_k,\\boldsymbol{\\Sigma}_k)$。对于由一个可观测量、能量和实验室角的选择组成的每个候选测量通道 $m$，您将：\n- 为 $k \\in \\{1,\\dots,K\\}$ 计算代理均值 $\\mu_k^{(m)} = y(\\boldsymbol{\\mu}_k)$，\n- 通过中心有限差分法在 $\\boldsymbol{\\mu}_k$ 处估计雅可比行向量 $\\boldsymbol{J}_k^{(m)}$，\n- 使用一个指定的测量噪声方差 $\\sigma_{\\mathrm{meas}}^2$（该方差依赖于可观测量但独立于 $E$ 和 $\\vartheta_{\\mathrm{lab}}$）计算预测方差 $s_{k}^{2\\,(m)} = \\boldsymbol{J}_k^{(m)}\\,\\boldsymbol{\\Sigma}_k\\,(\\boldsymbol{J}_k^{(m)})^\\top + \\sigma_{\\mathrm{meas}}^2$，\n- 为通道 $m$ 计算所有岛对 $(i,j)$ 之间的 Bhattacharyya 距离 $D_B^{(1\\mathrm{D})}(i,j\\mid m)$。\n\n设 $\\mathcal{M}$ 表示候选通道的集合。设计问题是找到一个基数最小的子集 $S \\subseteq \\mathcal{M}$，使得对于每个 $i \\neq j$ 的无序对 $(i,j)$，累积距离 $\\sum_{m \\in S} D_B^{(1\\mathrm{D})}(i,j\\mid m)$ 至少为一个指定的阈值 $T$。如果不存在这样的子集，则返回一个表示不可能的指示符。\n\n您必须实现一个贪婪选择策略，该策略从空集开始，迭代地添加通道 $m \\in \\mathcal{M}$，该通道能最大化所有岛对的剩余赤字 $\\max\\{0, T - \\sum_{m' \\in S} D_B^{(1\\mathrm{D})}(i,j\\mid m')\\}$ 的总减少量。当所有对都达到或超过阈值 $T$ 时，或者当无法进一步改进时，迭代停止。参数方向上的有限差分步长应为常数，并选择得足够小但数值稳定。\n\n您的程序必须使用以下测试套件。在所有情况下，角度以度为单位，能量以兆电子伏特（MeV）为单位，每个可观测量的测量噪声标准差是恒定的。对通道使用从零开始的索引，其中对于具有能量索引 $e$、可观测量索引 $o$ 和角度索引 $a$ 的三元组 $(e,o,a)$，通道索引 $j$ 由下式给出\n$$\nj = e\\cdot (N_O\\,N_A) + o\\cdot N_A + a,\n$$\n其中 $N_E = 3$, $N_O = 3$, 且 $N_A = 3$。能量、可观测量和角度按以下顺序排列：\n- 能量：$[12.0, 25.0, 45.0]$ MeV,\n- 可观测量：$[\\sigma, A_y, Q]$,\n- 角度：$[30.0, 60.0, 120.0]$ 度。\n\n测量噪声标准差为：\n- $\\sigma_{\\mathrm{meas}}(\\sigma) = 0.05$,\n- $\\sigma_{\\mathrm{meas}}(A_y) = 0.03$,\n- $\\sigma_{\\mathrm{meas}}(Q) = 0.03$.\n\n对于每个测试用例，指定岛和阈值 $T$。\n\n- 测试用例 1（三岛区分）：\n  - $\\boldsymbol{\\mu}_1 = (50.0, 6.0, 5.0)$，$\\boldsymbol{\\Sigma}_1 = \\mathrm{diag}(2.0^2, 0.8^2, 0.5^2)$，\n  - $\\boldsymbol{\\mu}_2 = (56.0, 7.5, 6.0)$，$\\boldsymbol{\\Sigma}_2 = \\mathrm{diag}(2.5^2, 1.0^2, 0.5^2)$，\n  - $\\boldsymbol{\\mu}_3 = (48.0, 9.0, 3.5)$，$\\boldsymbol{\\Sigma}_3 = \\mathrm{diag}(1.5^2, 0.7^2, 0.4^2)$，\n  - 阈值 $T = 2.0$。\n- 测试用例 2（两个远距离分离的岛）：\n  - $\\boldsymbol{\\mu}_1 = (50.0, 7.0, 5.0)$，$\\boldsymbol{\\Sigma}_1 = \\mathrm{diag}(1.5^2, 0.6^2, 0.4^2)$，\n  - $\\boldsymbol{\\mu}_2 = (65.0, 12.0, 8.0)$，$\\boldsymbol{\\Sigma}_2 = \\mathrm{diag}(1.5^2, 0.6^2, 0.4^2)$，\n  - 阈值 $T = 1.0$。\n- 测试用例 3（简并岛，不可能的设计）：\n  - $\\boldsymbol{\\mu}_1 = (55.0, 8.0, 6.0)$，$\\boldsymbol{\\Sigma}_1 = \\mathrm{diag}(1.0^2, 0.5^2, 0.4^2)$，\n  - $\\boldsymbol{\\mu}_2 = (55.0, 8.0, 6.0)$，$\\boldsymbol{\\Sigma}_2 = \\mathrm{diag}(1.0^2, 0.5^2, 0.4^2)$，\n  - 阈值 $T = 0.5$。\n\n实现要求：\n- 对数值雅可比矩阵使用中心有限差分，步长为 $(h_V,h_W,h_{V_{\\mathrm{so}}}) = (0.1, 0.1, 0.05)$。\n- 将每个岛在某个通道的预测分布视为具有上述指定均值和方差的单变量高斯分布。\n- 应用贪婪选择，直到所有无序岛对都满足阈值，或者没有进一步的改进发生。如果是后者，则为该测试用例返回整数 $-1$ 作为结果。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，输出一个严格递增顺序的所选通道索引列表（从零开始），或者如果不存在可行集，则输出整数 $-1$。例如，一个有效的总输出可能看起来像 $[[0,5], [7], -1]$。\n\n所有涉及角度的答案必须使用度，所有能量必须解释为兆电子伏特（MeV），唯一接受的输出单位是指定的索引整数。最终程序必须是完整的、确定性的，并且不需要用户输入。", "solution": "该问题要求设计并实现一个贪婪算法，用于在核光学模型分析中选择一个最小的实验集合，以区分不同的参数集（岛）。该选择基于最大化各种自旋可观测量的预测之间的统计可分性，该可分性由 Bhattacharyya 距离量化。分析过程分为三个主要阶段：定义物理和统计模型，预计算每个可能实验的区分能力，以及使用贪婪策略迭代选择实验。\n\n首先，我们建立数学框架。光学模型势由向量 $\\boldsymbol{\\theta} = (V, W, V_{\\mathrm{so}})$ 参数化。可观测量依赖于 $\\boldsymbol{\\theta}$、入射粒子能量 $E$ 和实验室散射角 $\\vartheta_{\\mathrm{lab}}$。这种依赖关系由代理函数给出。设 $x = \\cos(\\vartheta_{\\mathrm{lab}} \\pi/180)$，$s_v(E) = 1/(1 + E/E_v)$ 其中 $E_v = 80$，以及 $s_w(E) = E/(E + E_w)$ 其中 $E_w = 40$。有效势深度为 $V_{\\mathrm{eff}} = V s_v(E)$ 和 $W_{\\mathrm{eff}} = W s_w(E)$。可观测量——非极化微分截面 $\\sigma$、矢量分析能 $A_y$ 和自旋旋转函数 $Q$——由以下公式给出：\n- $\\sigma(\\boldsymbol{\\theta};E,\\vartheta_{\\mathrm{lab}}) = 1 + 10^{-3}(V_{\\mathrm{eff}}^2 + 0.5 W_{\\mathrm{eff}}^2) + 5 \\cdot 10^{-4} P_2(x) V_{\\mathrm{eff}} W_{\\mathrm{eff}}$，其中 $P_2(x) = (3x^2 - 1)/2$。\n- $A_y(\\boldsymbol{\\theta};E,\\vartheta_{\\mathrm{lab}}) = \\tanh( \\kappa(E) V_{\\mathrm{so}} \\sin(\\vartheta_{\\mathrm{lab}}\\pi/180)(1 + 2 \\cdot 10^{-3}V_{\\mathrm{eff}} - 10^{-3}W_{\\mathrm{eff}}) )$，其中 $\\kappa(E) = 0.01 + 0.4 E/(E+50)$。\n- $Q(\\boldsymbol{\\theta};E,\\vartheta_{\\mathrm{lab}}) = \\tanh( q_0(E) V_{\\mathrm{so}} x + 10^{-4} q_1(E) V_{\\mathrm{eff}} W_{\\mathrm{eff}} x )$，其中 $q_0(E) = 0.002 E$ 且 $q_1(E) = 0.5$。\n\n$\\boldsymbol{\\theta}$ 上的后验分布由 $K$ 个不同的岛描述，每个岛被建模为多元正态分布 $\\mathcal{N}(\\boldsymbol{\\mu}_k, \\boldsymbol{\\Sigma}_k)$，其中 $k \\in \\{1, \\dots, K\\}$。对于给定的测量通道 $m$（在特定能量和角度下的特定可观测量），岛 $k$ 的预测可观测量值也是一个正态分布。其均值 $\\mu_k^{(m)}$ 和方差 $s_k^{2(m)}$ 使用一阶泰勒展开（线性化）找到。均值就是代理函数在岛中心处的值：$\\mu_k^{(m)} = y(\\boldsymbol{\\mu}_k)$。方差是通过将参数协方差 $\\boldsymbol{\\Sigma}_k$ 经过线性化模型传播并加上测量噪声方差 $\\sigma_{\\mathrm{meas}}^2$ 来计算的：\n$$s_k^{2(m)} = \\boldsymbol{J}_k^{(m)} \\boldsymbol{\\Sigma}_k (\\boldsymbol{J}_k^{(m)})^\\top + \\sigma_{\\mathrm{meas}}^{2(m)}$$\n其中 $\\boldsymbol{J}_k^{(m)}$ 是可观测量函数 $y$ 关于 $\\boldsymbol{\\theta}$ 的雅可比行向量，在 $\\boldsymbol{\\mu}_k$ 处求值。该雅可比矩阵使用具有指定步长 $\\boldsymbol{h} = (h_V, h_W, h_{V_{\\mathrm{so}}})$ 的中心有限差分法进行数值估计。例如，第一个分量是 $(\\partial y/\\partial V) \\approx (y(\\boldsymbol{\\mu}_k + (h_V,0,0)) - y(\\boldsymbol{\\mu}_k - (h_V,0,0)))/(2h_V)$。\n\n对于单个通道 $m$，任意两个岛 $i$ 和 $j$ 之间的统计可区分性由一维正态分布 $\\mathcal{N}(\\mu_i^{(m)}, s_i^{2(m)})$ 和 $\\mathcal{N}(\\mu_j^{(m)}, s_j^{2(m)})$ 的 Bhattacharyya 距离来衡量：\n$$D_B^{(1\\mathrm{D})}(i,j \\mid m) = \\frac{1}{4}\\ln\\left(\\frac{1}{4}\\left(\\frac{s_i^{2(m)}}{s_j^{2(m)}} + \\frac{s_j^{2(m)}}{s_i^{2(m)}} + 2\\right)\\right) + \\frac{1}{4}\\frac{(\\mu_i^{(m)} - \\mu_j^{(m)})^2}{s_i^{2(m)} + s_j^{2(m)}}$$\n对于一组独立测量 $S$，总距离是 $\\sum_{m \\in S} D_B^{(1\\mathrm{D})}(i, j \\mid m)$。\n\n问题的核心是使用贪婪算法解决一个集合覆盖类的优化问题。目标是找到最小的测量通道集 $S$，使得每对岛 $(i,j)$（其中 $i \\neq j$）的累积 Bhattacharyya 距离达到或超过指定的阈值 $T$。算法流程如下：\n1.  初始化所选集合 $S = \\emptyset$，并将所有对 $(i,j)$ 的累积距离初始化为 $D_{ij}^{\\text{cumulative}} = 0$。\n2.  为提高效率，预先计算并存储所有无序对 $(i, j)$ 和所有可用测量通道 $m \\in \\mathcal{M}$ 的 Bhattacharyya 距离 $D_B(i,j \\mid m)$。\n3.  在每次迭代中，识别尚未达到阈值的对集合：$\\{(i,j) \\mid D_{ij}^{\\text{cumulative}}  T\\}$。如果该集合为空，则任务完成。\n4.  如果仍有未满足的对，计算每对的当前赤字，$d_{ij} = \\max(0, T - D_{ij}^{\\text{cumulative}})$。\n5.  通过找到能在所有未满足的对中提供最大总赤字减少量的通道，来选择下一个最佳通道 $m^* \\notin S$。一个通道 $m$ 提供的减少量计算为 $\\sum_{(i,j) \\text{ s.t. } d_{ij}>0} \\min(d_{ij}, D_B(i,j \\mid m))$。\n6.  将 $m^*$ 添加到 $S$ 中，并更新所有对的累积距离。\n7.  重复步骤 3-6，直到所有对都满足阈值，或者在一次迭代中没有通道可以提供任何正的赤字减少量（这意味着无法进一步改进）。在后一种情况下，如果仍有未满足的对，则该设计问题无解。\n8.  最终，返回排序后的所选通道索引列表，如果无解则返回 -1。", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to solve the experimental design problem for all test cases.\n    \"\"\"\n    # Problem constants\n    E_v = 80.0\n    E_w = 40.0\n    h_steps = np.array([0.1, 0.1, 0.05])  # (h_V, h_W, h_Vso)\n\n    # Candidate measurement channels\n    energies = np.array([12.0, 25.0, 45.0])\n    angles_deg = np.array([30.0, 60.0, 120.0])\n    observables = ['sigma', 'Ay', 'Q']\n    \n    # Noise variances (sigma^2)\n    noise_variances = {\n        'sigma': 0.05**2,\n        'Ay': 0.03**2,\n        'Q': 0.03**2\n    }\n\n    # Test cases\n    test_cases = [\n        {\n            \"islands\": [\n                {\"mu\": np.array([50.0, 6.0, 5.0]), \"Sigma\": np.diag([2.0**2, 0.8**2, 0.5**2])},\n                {\"mu\": np.array([56.0, 7.5, 6.0]), \"Sigma\": np.diag([2.5**2, 1.0**2, 0.5**2])},\n                {\"mu\": np.array([48.0, 9.0, 3.5]), \"Sigma\": np.diag([1.5**2, 0.7**2, 0.4**2])},\n            ],\n            \"T\": 2.0\n        },\n        {\n            \"islands\": [\n                {\"mu\": np.array([50.0, 7.0, 5.0]), \"Sigma\": np.diag([1.5**2, 0.6**2, 0.4**2])},\n                {\"mu\": np.array([65.0, 12.0, 8.0]), \"Sigma\": np.diag([1.5**2, 0.6**2, 0.4**2])},\n            ],\n            \"T\": 1.0\n        },\n        {\n            \"islands\": [\n                {\"mu\": np.array([55.0, 8.0, 6.0]), \"Sigma\": np.diag([1.0**2, 0.5**2, 0.4**2])},\n                {\"mu\": np.array([55.0, 8.0, 6.0]), \"Sigma\": np.diag([1.0**2, 0.5**2, 0.4**2])},\n            ],\n            \"T\": 0.5\n        }\n    ]\n\n    # --- Surrogate Functions ---\n    def get_surrogate_funcs():\n        def s_v(E): return 1.0 / (1.0 + E / E_v)\n        def s_w(E): return E / (E + E_w)\n        def P2(x): return (3.0 * x**2 - 1.0) / 2.0\n        def kappa(E): return 0.01 + 0.4 * E / (E + 50.0)\n        def q0(E): return 0.002 * E\n        def q1(E): return 0.5\n\n        def sigma_func(theta, E, theta_lab_deg):\n            V, W, _ = theta\n            x = np.cos(np.deg2rad(theta_lab_deg))\n            V_eff = V * s_v(E)\n            W_eff = W * s_w(E)\n            return 1.0 + 1e-3 * (V_eff**2 + 0.5 * W_eff**2) + 5e-4 * P2(x) * V_eff * W_eff\n\n        def Ay_func(theta, E, theta_lab_deg):\n            V, W, V_so = theta\n            theta_lab_rad = np.deg2rad(theta_lab_deg)\n            V_eff = V * s_v(E)\n            W_eff = W * s_w(E)\n            arg = kappa(E) * V_so * np.sin(theta_lab_rad) * (1.0 + 2e-3 * V_eff - 1e-3 * W_eff)\n            return np.tanh(arg)\n\n        def Q_func(theta, E, theta_lab_deg):\n            V, W, V_so = theta\n            x = np.cos(np.deg2rad(theta_lab_deg))\n            V_eff = V * s_v(E)\n            W_eff = W * s_w(E)\n            arg = q0(E) * V_so * x + 1e-4 * q1(E) * V_eff * W_eff * x\n            return np.tanh(arg)\n            \n        return {'sigma': sigma_func, 'Ay': Ay_func, 'Q': Q_func}\n\n    surrogate_funcs = get_surrogate_funcs()\n\n    def calculate_jacobian(func, theta, E, theta_lab_deg):\n        J = np.zeros(3)\n        for i in range(3):\n            h_vec = np.zeros(3)\n            h_vec[i] = h_steps[i]\n            y_plus = func(theta + h_vec, E, theta_lab_deg)\n            y_minus = func(theta - h_vec, E, theta_lab_deg)\n            J[i] = (y_plus - y_minus) / (2 * h_steps[i])\n        return J\n\n    def bhattacharyya_dist(mu1, s1_sq, mu2, s2_sq):\n        if s1_sq = 0 or s2_sq = 0: return 0.0\n        term1_inner = 0.25 * (s1_sq / s2_sq + s2_sq / s1_sq + 2.0)\n        term1 = 0.25 * np.log(term1_inner)\n        term2 = 0.25 * (mu1 - mu2)**2 / (s1_sq + s2_sq)\n        return term1 + term2\n\n    results = []\n    \n    N_E, N_O, N_A = len(energies), len(observables), len(angles_deg)\n    num_channels = N_E * N_O * N_A\n    \n    for case in test_cases:\n        islands = case[\"islands\"]\n        T = case[\"T\"]\n        K = len(islands)\n        island_pairs = list(itertools.combinations(range(K), 2))\n        num_pairs = len(island_pairs)\n\n        if num_pairs == 0:\n            results.append([])\n            continue\n\n        # Pre-compute Bhattacharyya distances for all channels and pairs\n        db_distances = np.zeros((num_pairs, num_channels))\n\n        for e_idx, E in enumerate(energies):\n            for o_idx, obs_name in enumerate(observables):\n                for a_idx, angle in enumerate(angles_deg):\n                    channel_idx = e_idx * (N_O * N_A) + o_idx * N_A + a_idx\n                    \n                    obs_func = surrogate_funcs[obs_name]\n                    noise_var = noise_variances[obs_name]\n                    \n                    # Calculate predicted means and variances for this channel for all islands\n                    means = np.zeros(K)\n                    variances = np.zeros(K)\n                    for k in range(K):\n                        mu_k = islands[k][\"mu\"]\n                        Sigma_k = islands[k][\"Sigma\"]\n                        \n                        means[k] = obs_func(mu_k, E, angle)\n                        J_k = calculate_jacobian(obs_func, mu_k, E, angle)\n                        variances[k] = J_k @ Sigma_k @ J_k.T + noise_var\n                        \n                    # Calculate DB for all pairs for this channel\n                    for p_idx, (i, j) in enumerate(island_pairs):\n                        db = bhattacharyya_dist(means[i], variances[i], means[j], variances[j])\n                        db_distances[p_idx, channel_idx] = db\n        \n        # Greedy selection\n        selected_channels = []\n        available_channels = list(range(num_channels))\n        cumulative_distances = np.zeros(num_pairs)\n        \n        while True:\n            deficits = T - cumulative_distances\n            unsatisfied_mask = deficits > 1e-9 # Use a small epsilon for float comparison\n            \n            if not np.any(unsatisfied_mask):\n                break\n\n            best_channel = -1\n            max_reduction = -1.0\n            \n            for channel_idx in available_channels:\n                current_reduction = 0.0\n                for p_idx in range(num_pairs):\n                    if unsatisfied_mask[p_idx]:\n                        contribution = db_distances[p_idx, channel_idx]\n                        current_reduction += min(contribution, deficits[p_idx])\n                \n                if current_reduction > max_reduction:\n                    max_reduction = current_reduction\n                    best_channel = channel_idx\n\n            if max_reduction = 1e-9: # No improvement possible\n                break\n            \n            selected_channels.append(best_channel)\n            available_channels.remove(best_channel)\n            \n            for p_idx in range(num_pairs):\n                cumulative_distances[p_idx] += db_distances[p_idx, best_channel]\n\n        final_deficits = T - cumulative_distances\n        if np.any(final_deficits > 1e-9):\n            results.append(-1)\n        else:\n            results.append(sorted(selected_channels))\n\n    # Format output\n    final_results_str = []\n    for res in results:\n        if res == -1:\n            final_results_str.append(\"-1\")\n        else:\n            # Format list without spaces, e.g., [1,11,20]\n            res_str = f\"[{','.join(map(str, res))}]\"\n            final_results_str.append(res_str)\n            \n    print(f\"[{','.join(final_results_str)}]\")\n\nsolve()\n```", "id": "3567510"}]}