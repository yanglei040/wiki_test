{"hands_on_practices": [{"introduction": "Bethe-Goldstone方程是Brueckner-Hartree-Fock理论的基石，它描述了两个核子如何在核介质中相互作用。本练习将指导您完成将此积分方程转化为可解的矩阵问题的核心数值任务，为计算核理论研究者提供一项基础技能。通过将矩阵解与可分离势的已知解析结果进行比较，您将建立对底层物理实现的信心。[@problem_id:3545576]", "problem": "要求您实现一个完全独立的程序，为总对动量为零的对称核物质构建介质内相互作用（介质内 $G$ 矩阵）的 Bethe-Goldstone 方程的离散化矩阵表示。您的任务是从适用于计算核物理的第一性原理出发，推导由求积近似产生的离散线性系统，然后进行数值实现和评估。您必须使用一个物理上合理的单粒子谱和一个简单但非平凡的可分离相互作用，以进行内部一致性检验。所有动量必须以 $\\mathrm{fm}^{-1}$ 表示，所有能量以 $\\mathrm{MeV}$ 表示，所有角度以弧度表示。\n\n从 Brueckner-Hartree-Fock (BHF) 理论的标准物理出发点开始：介质内两体反应矩阵 $G$ 的 Bethe-Goldstone 方程。在 $S$ 波、总动量为零的近似下，该方程可以写成关于相对动量 $k$ 的一维积分方程。采用分波的常规归一化，其中三维积分变为一个因子乘以一个在 $q \\in [0,\\Lambda]$ 上对 $q^{2}\\,\\mathrm{d}q$ 的积分，$\\Lambda$ 是有限动量截断。中间态泡利算符必须取角度平均，并且在总动量为零时简化为一个阶跃函数 $Q(q,k_{F})=\\Theta(q-k_{F})$，其中 $k_{F}$ 是费米动量。单粒子能量必须取自由动能谱 $\\epsilon(q)=\\frac{\\hbar^{2}}{2m_{N}}\\,q^{2}$，其中 $\\frac{\\hbar^{2}}{2m_{N}}=20.735\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^{2}$。起始能量是一个形式为 $\\omega + i\\,\\eta$ 的复数量，其中 $\\omega$ 是实数，$\\eta$ 是一个小的正调节子（单位为 $\\mathrm{MeV}$），它实现了因果性规定并正则化能量分母。\n\n在动量空间中使用秩-1 可分离 Yamaguchi 势，\n$$\nV(k,k')=-\\lambda\\,g(k)\\,g(k')\\,,\\qquad g(k)=\\frac{1}{k^{2}+\\beta^{2}}\\,,\n$$\n其中 $\\lambda>0$，力程参数 $\\beta>0$。在 $S$ 波和零质心动量下，介质内 Bethe-Goldstone 方程对于每一对 $(k,k')$ 变成一个关于 $q$ 的一维积分方程，涉及核 $V(k,q)$、泡利因子 $Q(q,k_{F})$ 和传播子分母 $\\left[\\omega-\\epsilon(q)-\\epsilon(q)\\right]^{-1}=\\left[\\omega-2\\,\\epsilon(q)\\right]^{-1}$。您的代码必须使用具有 $N$ 个节点和权重 $\\{(q_{i},w_{i})\\}_{i=1}^{N}$ 的高斯求积，在有限动量区间 $[0,\\Lambda]$ 上对 $q$ 积分进行离散化。为了在特定的在壳动量 $k_{0}$ 处计算 $G$ 矩阵，您必须通过将 $k_{0}$ 作为一个额外的、求积权重为零的配置点来扩展求积网格，这样它不会改变积分值，但能通过相同的线性系统产生 $G(k_{0},k')$。在所有表达式中，显式地写出常规的 $S$ 波因子\n$$\n\\frac{2}{\\pi}\\int_{0}^{\\Lambda} q^{2}\\,\\mathrm{d}q \\,\\cdots \\, .\n$$\n\n在数值上，您必须处理能量分母\n$$\n\\omega-\\epsilon_{p_{1}}-\\epsilon_{p_{2}}=\\omega-2\\,\\epsilon(q)=\\omega - 2 \\times 20.735\\,q^{2}\\,,\n$$\n通过添加小的虚部调节子，使分母为 $\\omega-2\\,\\epsilon(q)+i\\,\\eta$，其中 $\\eta \\ge 0$。泡利算符 $Q(q,k_{F})$ 必须实现为一个陡峭的阶跃函数：如果 $q>k_{F}$，则 $Q(q,k_{F})=1$，否则 $Q(q,k_{F})=0$。您必须在组合网格 $\\{k_{0}\\}\\cup\\{q_{i}\\}_{i=1}^{N}$ 上将离散化方程形式化为一个线性代数问题，并求解在这些网格点上的完整矩阵 $G(k_{a},k_{b};\\omega)$。然后提取在壳元 $G(k_{0},k_{0};\\omega)$。\n\n为了验证正确性并评估能量分母的数值处理，请并行计算秩-1 可分离势存在的闭式解。这需要将 Bethe-Goldstone 方程简化为一个关于强度参数的标量方程，然后重构在壳 $G$ 矩阵元。在标量方程中使用相同的求积法则和泡利算符，这样任何差异都将仅反映您的离散化和线性代数方法的一致性。\n\n测试套件和参数。对于以下每种情况，输入参数为 $(k_{F},k_{0},\\Lambda,N,\\beta,\\lambda,\\omega,\\eta)$，单位如前所述。请严格按此顺序使用这四种情况：\n- 情况 A (自由空间，在壳): $k_{F}=0.0\\,\\mathrm{fm}^{-1}$, $k_{0}=1.0\\,\\mathrm{fm}^{-1}$, $\\Lambda=8.0\\,\\mathrm{fm}^{-1}$, $N=120$, $\\beta=1.4\\,\\mathrm{fm}^{-1}$, $\\lambda=200.0\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^{3}$, $\\omega=2\\times 20.735\\times k_{0}^{2}\\,\\mathrm{MeV}$, $\\eta=1.0\\,\\mathrm{MeV}$。\n- 情况 B (正常密度，在壳且动量高于 $k_{F}$): $k_{F}=1.3\\,\\mathrm{fm}^{-1}$, $k_{0}=1.6\\,\\mathrm{fm}^{-1}$, $\\Lambda=8.0\\,\\mathrm{fm}^{-1}$, $N=120$, $\\beta=1.4\\,\\mathrm{fm}^{-1}$, $\\lambda=200.0\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^{3}$, $\\omega=2\\times 20.735\\times k_{0}^{2}\\,\\mathrm{MeV}$, $\\eta=1.0\\,\\mathrm{MeV}$。\n- 情况 C (靠近费米面，在壳且动量略高于 $k_{F}$): $k_{F}=1.3\\,\\mathrm{fm}^{-1}$, $k_{0}=1.31\\,\\mathrm{fm}^{-1}$, $\\Lambda=8.0\\,\\mathrm{fm}^{-1}$, $N=120$, $\\beta=1.4\\,\\mathrm{fm}^{-1}$, $\\lambda=200.0\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^{3}$, $\\omega=2\\times 20.735\\times k_{0}^{2}\\,\\mathrm{MeV}$, $\\eta=0.5\\,\\mathrm{MeV}$。\n- 情况 D (离壳，低于阈值，自由空间): $k_{F}=0.0\\,\\mathrm{fm}^{-1}$, $k_{0}=0.5\\,\\mathrm{fm}^{-1}$, $\\Lambda=8.0\\,\\mathrm{fm}^{-1}$, $N=120$, $\\beta=1.4\\,\\mathrm{fm}^{-1}$, $\\lambda=200.0\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^{3}$, $\\omega=-20.0\\,\\mathrm{MeV}$, $\\eta=0.0\\,\\mathrm{MeV}$。\n\n您的程序必须为每种情况执行以下操作：\n- 在以 $k_{0}$ 作为零求积权重的额外配置点的组合网格上，组装离散化矩阵方程并求解完整的 $G$ 矩阵。\n- 提取在壳元 $G(k_{0},k_{0};\\omega)$。\n- 使用相同的求积方法和泡利算符，通过闭式可分离简化方法独立计算相应的在壳元。\n- 返回两个复数的实部和虚部之间的绝对差异，即 $|\\Re G_{\\mathrm{matrix}}-\\Re G_{\\mathrm{sep}}|$ 和 $|\\Im G_{\\mathrm{matrix}}-\\Im G_{\\mathrm{sep}}|$，以 $\\mathrm{MeV}\\cdot\\mathrm{fm}^{3}$ 为单位表示。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$\\big[$情况 A 实部的差异, 情况 A 虚部的差异, 情况 B 实部的差异, 情况 B 虚部的差异, 情况 C 实部的差异, 情况 C 虚部的差异, 情况 D 实部的差异, 情况 D 虚部的差异$\\big]$。", "solution": "用户要求在核物质的 Brueckner-Hartree-Fock 理论背景下，对 Bethe-Goldstone 方程进行数值求解和验证。该问题被验证为有科学依据、适定且内部一致。它代表了计算核物理中的一个标准问题，尽管有所简化。\n\n### 1. 问题形式化\n\n出发点是针对在总动量为零的对称核物质中相互作用的两个核子的介质内反应矩阵 $G$ 的 Bethe-Goldstone 方程。在 $S$ 波道中，这是一个一维积分方程：\n$$\nG(k, k'; \\omega) = V(k, k') + \\frac{2}{\\pi} \\int_{0}^{\\Lambda} q^2 dq \\, V(k, q) \\frac{Q(q, k_F)}{\\omega + i\\eta - 2\\epsilon(q)} G(q, k'; \\omega)\n$$\n其中：\n- $k$ 和 $k'$ 是初始和最终相对动量。\n- $V(k, k')$ 是 $S$ 波道中的核子-核子相互作用。\n- 积分是对中间相对动量 $q$ 进行的，上限为截断值 $\\Lambda$。因子 $\\frac{2}{\\pi}$ 是一个指定的归一化约定。\n- $Q(q, k_F) = \\Theta(q - k_F)$ 是角度平均的泡利不相容算符，它将中间态限制在费米动量 $k_F$ 之上。当 $q > k_F$ 时为 $1$，否则为 $0$。\n- $\\epsilon(q) = \\frac{\\hbar^2 q^2}{2m_N}$ 是质量为 $m_N$ 的自由核子的单粒子能量。常数给定为 $\\frac{\\hbar^2}{2m_N} = 20.735\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^2$。\n- $\\omega + i\\eta$ 是复起始能量，其中 $\\omega$ 是实能量，$\\eta > 0$ 是一个小的正调节子，确保正确的因果边界条件并防止能量分母中出现奇点。\n\n相互作用是秩-1 可分离 Yamaguchi 势：\n$$\nV(k, k') = -\\lambda g(k) g(k') \\quad \\text{其中} \\quad g(k) = \\frac{1}{k^2 + \\beta^2}\n$$\n其中 $\\lambda$ 是强度，$\\beta$ 与相互作用的力程有关。\n\n### 2. 数值离散化与矩阵形式化\n\n为数值求解该积分方程，我们使用 N 点高斯求积法则对 $q \\in [0, \\Lambda]$ 上的积分进行离散化。设求积节点为 $\\{q_i\\}_{i=1}^N$，相应权重为 $\\{w_i\\}_{i=1}^N$。积分近似为：\n$$\n\\int_{0}^{\\Lambda} f(q) dq \\approx \\sum_{i=1}^{N} w_i f(q_i)\n$$\n问题要求我们在特定动量 $k_0$ 处计算 $G$ 矩阵。我们将求积节点集与 $k_0$ 合并，形成一个组合的配置点网格 $P = \\{p_a\\}_{a=0}^N$，其中 $p_0 = k_0$，对于 $a=1, \\dots, N$ 有 $p_a = q_a$。点 $k_0$ 被赋予零求积权重。\n\n离散化的 Bethe-Goldstone 方程变为一个关于 $G$ 矩阵在网格点上的值 $G_{ab} = G(p_a, p_b)$ 的线性方程组：\n$$\nG(p_a, p_b) = V(p_a, p_b) + \\frac{2}{\\pi} \\sum_{i=1}^{N} w_i q_i^2 V(p_a, q_i) \\frac{Q(q_i, k_F)}{\\omega + i\\eta - 2\\epsilon(q_i)} G(q_i, p_b)\n$$\n认识到 $q_i=p_i$ 且 $G(q_i, p_b)=G_{ib}$，我们可以将其写成一个矩阵方程。我们定义一个大小为 $(N+1) \\times (N+1)$ 的矩阵 $\\mathbf{C}$：\n$$\nC_{ai} = \n\\begin{cases}\n    \\frac{2}{\\pi} w_i q_i^2 V(p_a, q_i) \\frac{Q(q_i, k_F)}{\\omega + i\\eta - 2\\epsilon(q_i)}  \\text{对于 } i \\in \\{1, \\dots, N\\} \\\\\n    0  \\text{对于 } i = 0\n\\end{cases}\n$$\n矩阵 $\\mathbf{G}$（元素为 $G_{ab}$）用矩阵 $\\mathbf{V}$（元素为 $V_{ab}$）表示的方程为：\n$$\n\\mathbf{G} = \\mathbf{V} + \\mathbf{C} \\mathbf{G} \\implies (\\mathbf{I} - \\mathbf{C})\\mathbf{G} = \\mathbf{V}\n$$\n其中 $\\mathbf{I}$ 是单位矩阵。形式解为 $\\mathbf{G} = (\\mathbf{I} - \\mathbf{C})^{-1} \\mathbf{V}$。\n\n由于势是可分离的，$\\mathbf{V}$ 是一个秩-1 矩阵：$V_{ab} = -\\lambda g(p_a) g(p_b)$，可以写成 $\\mathbf{V} = -\\lambda \\vec{g} \\vec{g}^T$，其中 $\\vec{g}$ 是一个元素为 $g_a = g(p_a)$ 的列向量。\n$\\mathbf{G}$ 的解则为 $\\mathbf{G} = -\\lambda (\\mathbf{I} - \\mathbf{C})^{-1} (\\vec{g} \\vec{g}^T)$。\n为了找到所需的元素 $G_{00} = G(k_0, k_0)$，我们可以求解线性系统 $(\\mathbf{I} - \\mathbf{C})\\vec{y} = \\vec{g}$ 以得到向量 $\\vec{y}$。解向量为 $\\vec{y} = (\\mathbf{I} - \\mathbf{C})^{-1}\\vec{g}$，完整的 $G$ 矩阵则为 $\\mathbf{G} = -\\lambda \\vec{y} \\vec{g}^T$。\n我们需要的特定元素是 $G_{00} = -\\lambda y_0 g_0$，其中 $y_0$ 是 $\\vec{y}$ 的第一个分量，$g_0 = g(p_0) = g(k_0)$。这种方法避免了构造完整的逆矩阵，在计算上更有效率。\n\n### 3. 闭式可分离简化\n\n秩-1 可分离势的一个关键特性是，该积分方程可以被解析求解，从而简化为一个标量代数方程。我们将 $V(k, k') = -\\lambda g(k) g(k')$ 代入 Bethe-Goldstone 方程。该方程的结构表明 $G(k, k')$ 也必须是可分离的，因此我们做出拟设 $G(k, k') = \\tau(\\omega) g(k) g(k')$。代入此式并消去 $g(k)$ 和 $g(k')$，可以得到一个关于函数 $\\tau(\\omega)$ 的标量方程：\n$$\n\\tau(\\omega) = -\\lambda + \\frac{2}{\\pi} \\int_0^\\Lambda q^2 dq \\, [-\\lambda g(q)] \\frac{Q(q, k_F)}{\\omega' - 2\\epsilon(q)} [\\tau(\\omega) g(q)]\n$$\n$$\n\\tau(\\omega) = -\\lambda - \\lambda \\tau(\\omega) \\left[ \\frac{2}{\\pi} \\int_0^\\Lambda q^2 dq \\frac{g(q)^2 Q(q, k_F)}{\\omega' - 2\\epsilon(q)} \\right]\n$$\n我们定义圈积分 $I(\\omega')$：\n$$\nI(\\omega') = \\frac{2}{\\pi} \\int_0^\\Lambda q^2 dq \\frac{g(q)^2 Q(q, k_F)}{\\omega' - 2\\epsilon(q)}\n$$\n于是有 $\\tau(\\omega) = -\\lambda / (1 + \\lambda I(\\omega'))$。因此，$G$ 矩阵为：\n$$\nG(k, k'; \\omega) = \\frac{-\\lambda g(k) g(k')}{1 + \\lambda I(\\omega')}\n$$\n为了验证，我们使用与矩阵方法中相同的高斯求积法则来计算积分 $I(\\omega')$：\n$$\nI(\\omega') \\approx \\frac{2}{\\pi} \\sum_{i=1}^{N} w_i q_i^2 \\frac{g(q_i)^2 Q(q_i, k_F)}{\\omega' - 2\\epsilon(q_i)}\n$$\n然后，在壳元 $G(k_0, k_0; \\omega)$ 就可以直接通过此公式计算。\n\n### 4. 一致性检验\n\n该问题的设计使得矩阵法和可分离简化法是通向同一个底层解析解的两条不同数值路径。正如在思考过程中解析推导的那样，两种方法都得到相同的表达式：$G(k_0, k_0) = \\frac{-\\lambda g(k_0)^2}{1+\\lambda I(\\omega')}$。因此，当使用相同的求积方案进行数值实现时，两种方法的结果在浮点精度范围内应完全相同。所要求的差异 $|\\Re G_{\\mathrm{matrix}}-\\Re G_{\\mathrm{sep}}|$ 和 $|\\Im G_{\\mathrm{matrix}}-\\Im G_{\\mathrm{sep}}|$，是对离散化线性代数问题实现的正确性和一致性的严格测试。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main driver function to solve the problem for all specified test cases.\n    \"\"\"\n    # Test suite parameters:\n    # (k_F, k_0, Lambda, N, beta, lambda, omega, eta)\n    HBARC2_2M = 20.735  # MeV*fm^2\n\n    test_cases = [\n        # Case A (free-space, on-shell)\n        (0.0, 1.0, 8.0, 120, 1.4, 200.0, 2 * HBARC2_2M * 1.0**2, 1.0),\n        # Case B (normal density, on-shell above k_F)\n        (1.3, 1.6, 8.0, 120, 1.4, 200.0, 2 * HBARC2_2M * 1.6**2, 1.0),\n        # Case C (near Fermi surface, on-shell just above k_F)\n        (1.3, 1.31, 8.0, 120, 1.4, 200.0, 2 * HBARC2_2M * 1.31**2, 0.5),\n        # Case D (off-shell below threshold, free-space)\n        (0.0, 0.5, 8.0, 120, 1.4, 200.0, -20.0, 0.0),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        d_real, d_imag = solve_case(*case_params)\n        results.append(f\"{d_real:.15e}\")\n        results.append(f\"{d_imag:.15e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_case(kF, k0, Lambda, N, beta, lam, omega, eta):\n    \"\"\"\n    Solves the Bethe-Goldstone equation for a single set of parameters\n    using both the matrix inversion method and the separable reduction,\n    and returns the discrepancies between them.\n    \"\"\"\n    # Physical constant\n    HBARC2_2M = 20.735  # MeV*fm^2\n\n    # 1. Setup Grid and Quadrature\n    # Get N Gauss-Legendre quadrature points (x) and weights (w_prime) for [-1, 1]\n    x_nodes, w_prime = roots_legendre(N)\n    \n    # Map nodes and weights to the integration interval [0, Lambda]\n    q_nodes = Lambda * (x_nodes + 1.0) / 2.0\n    w_nodes = Lambda * w_prime / 2.0\n\n    # The full momentum grid consists of k0 and the quadrature nodes.\n    # p_grid[0] = k0, p_grid[1:] = q_nodes\n    p_grid = np.concatenate(([k0], q_nodes))\n    \n    # 2. Define Physical Quantities\n    def g_form_factor(k_val):\n        return 1.0 / (k_val**2 + beta**2)\n\n    def energy_spectrum(k_val):\n        return HBARC2_2M * k_val**2\n    \n    # Evaluate quantities on the grids\n    epsilon_q = energy_spectrum(q_nodes)\n    g_p = g_form_factor(p_grid)\n    g_q = g_form_factor(q_nodes)\n    \n    # Pauli operator Q(q, kF) = 1 if q > kF, else 0\n    Q_q = (q_nodes > kF).astype(np.float64)\n\n    # Complex starting energy\n    omega_c = complex(omega, eta)\n    \n    # Propagator denominator for all quadrature points\n    propagator_denom = omega_c - 2.0 * epsilon_q\n\n    # 3. Matrix Method for G(k0, k0)\n    # The discretized B-G equation is (I - C)G = V.\n    # For a separable potential, this leads to solving (I - C)y = g_vec,\n    # and then G_00 = -lam * y_0 * g_0.\n\n    # Construct the matrix C of size (N+1) x (N+1)\n    C = np.zeros((N + 1, N + 1), dtype=np.complex128)\n    \n    # Common part of the kernel for all quadrature points\n    kernel_integrand_base = (2.0 / np.pi) * w_nodes * q_nodes**2 * Q_q / propagator_denom\n    \n    # The matrix C's columns for i=1..N are constructed. C's first column (i=0) is zero.\n    for a in range(N + 1):  # Loop over rows of C (momentum p_a)\n        # V(p_a, q_i) = -lam * g(p_a) * g(q_i)\n        # C_{a,i} for i=1..N involves V(p_a, q_{i-1}) in 0-based indexing\n        V_pa_qi = -lam * g_p[a] * g_q\n        C[a, 1:] = kernel_integrand_base * V_pa_qi\n\n    # Form the matrix M = I - C for the linear system M*y = g_vec\n    M = np.identity(N + 1, dtype=np.complex128) - C\n    \n    # The vector g_vec has components g(p_a)\n    g_vec = g_p.astype(np.complex128)\n    \n    # Solve the linear system M*y = g_vec\n    y = np.linalg.solve(M, g_vec)\n    \n    # Calculate G_matrix(k0, k0) which corresponds to G_00\n    G_matrix = -lam * g_p[0] * y[0]\n\n    # 4. Separable Reduction Method for G(k0, k0)\n    # G(k,k') = V(k,k') / (1 + lam*I)\n    # where I = (2/pi) * integral_q [ q^2 * g(q)^2 * Q(q) / (omega' - 2*eps(q)) ]\n    \n    # Evaluate the loop integral I using the same quadrature rule\n    integrand_I = (2.0 / np.pi) * q_nodes**2 * g_q**2 * Q_q / propagator_denom\n    I_val = np.sum(w_nodes * integrand_I)\n    \n    # Calculate G_sep(k0, k0)\n    G_sep = (-lam * g_p[0]**2) / (1.0 + lam * I_val)\n\n    # 5. Compute and return the absolute discrepancies\n    d_real = np.abs(G_matrix.real - G_sep.real)\n    d_imag = np.abs(G_matrix.imag - G_sep.imag)\n\n    return d_real, d_imag\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3545576"}, {"introduction": "理解了介质中的$G$矩阵后，下一步便是计算核物质的宏观性质，例如单位核子的总能量（$\\frac{E}{A}$）。本练习使用一个简化但功能强大的山口可分离势，从$G$矩阵推导能量，完整地展示了从两体力到关键宏观可观测量$\\frac{E}{A}$的计算链条。此练习旨在通过极限情况来验证您的理解，这是代码验证中的一项关键技术。[@problem_id:3545472]", "problem": "考虑在 Brueckner-Hartree-Fock (BHF) 理论框架下处理的均匀对称核物质。Brueckner 反应矩阵（通常称为 $G$ 矩阵）求解 Bethe–Goldstone 方程：\n$$\nG(\\mathbf{k},\\mathbf{k}';\\omega) \\;=\\; V(\\mathbf{k},\\mathbf{k}') \\;+\\; \\int \\frac{d^3\\mathbf{q}}{(2\\pi)^3}\\, V(\\mathbf{k},\\mathbf{q}) \\, \\frac{Q(\\mathbf{q},k_F)}{\\omega - 2 e(\\mathbf{q}) + i\\eta} \\, G(\\mathbf{q},\\mathbf{k}';\\omega),\n$$\n其中，$V(\\mathbf{k},\\mathbf{k}')$ 是动量空间中的核子-核子相互作用，$Q(\\mathbf{q},k_F)$ 是泡利阻塞算符，$e(\\mathbf{q})$ 是单粒子能量，$\\omega$ 是起始能量，$k_F$ 是费米动量，$\\eta$ 是一个确保因果边界条件的正无穷小量。在均匀核物质中，通常采用角平均泡利算符和自由单粒子谱，即 $e(\\mathbf{q})$ 仅依赖于 $|\\mathbf{q}|$，并由 $e(q) = \\frac{q^2}{2m}$ 给出。\n\n对于此问题，请采用以下适用于计算验证任务的简化和标准近似：\n- 使用形式如下的可分离 Yamaguchi $S$ 波势\n$$\nV(k,k') \\;=\\; -\\lambda\\, g(k)\\, g(k'), \\qquad g(k) \\;=\\; \\frac{1}{k^2 + \\beta^2},\n$$\n其中耦合强度 $\\lambda$ 为正，力程参数 $\\beta > 0$。\n- 使用各向同性自由单粒子能量 $e(q)=\\frac{q^2}{2m}$，其中 $m$ 为核子质量。\n- 使用在费米面上计算的角平均起始能量 $\\omega$，\n$$\n\\omega \\;=\\; 2 e(k_F),\n$$\n以及角平均泡利算符 $Q(\\mathbf{q},k_F) = \\Theta(q - k_F)$，其中 $\\Theta$ 是亥维赛德阶跃函数。\n- 在自然单位制中进行计算，取 $\\hbar = 1$ 和 $m = 1$，因此 $e(q)=\\frac{q^2}{2}$；在此单位制中，所有能量和动量都是无量纲的。请用这些自然单位表示所有最终的单粒子能量。\n\n在这些假设下，可分离结构意味着可以采用以下拟设\n$$\nG(k,k';\\omega) \\;=\\; g(k)\\, g(k')\\, \\tau(\\omega;k_F),\n$$\n其中介质中的 $\\tau$ 函数满足\n$$\n\\tau(\\omega;k_F) \\;=\\; \\frac{-\\lambda}{1 + \\lambda\\, J(\\omega;k_F)}, \\qquad\nJ(\\omega;k_F) \\;=\\; \\frac{1}{2\\pi^2} \\int_{k_F}^{\\infty} dq\\, \\frac{q^2\\, g(q)^2}{\\omega - 2 e(q) + i\\eta}.\n$$\n使用自由谱 $e(q)=\\frac{q^2}{2}$ 和指定的 $\\omega=2 e(k_F)=k_F^2$，$J(\\omega;k_F)$ 的实部是主值积分\n$$\n\\operatorname{Re}\\, J(k_F^2;k_F) \\;=\\; \\frac{1}{2\\pi^2} \\int_{k_F}^{\\infty} dq\\, q^2\\, g(q)^2 \\, \\frac{k_F^2 - q^2}{(k_F^2 - q^2)^2 + \\eta^2},\n$$\n其中 $\\eta>0$ 对 $q=k_F$ 处的可积奇点进行正则化，并在数值上模拟主值。$g(k)^2$ 在已占据费米球上的平均值通过以下方式出现：\n$$\nI_F(k_F) \\;=\\; \\frac{1}{2\\pi^2} \\int_0^{k_F} dk\\, k^2\\, g(k)^2.\n$$\n\n在这个简化的角平均可分离模型中，通过对费米海内核子对的在壳 $G$ 矩阵进行平均，可以获得每个粒子相互作用能的半解析表达式。将 $\\tau$ 函数近似为其在 $\\omega=2e(k_F)$ 处的值，可得\n$$\n\\frac{E_{\\text{pot}}}{A}(k_F) \\;\\approx\\; \\frac{d\\, \\tau(k_F^2;k_F)}{2\\, \\rho(k_F)} \\; \\left[I_F(k_F)\\right]^2,\n$$\n其中 $d$ 是一个有效道权重因子，对于单个 $S$ 波道，我们设定 $d=1$，而对称核物质的密度（自旋-同位旋简并度等于 $4$）为\n$$\n\\rho(k_F) \\;=\\; \\frac{4\\, k_F^3}{6\\pi^2} \\;=\\; \\frac{2\\, k_F^3}{3\\pi^2}.\n$$\n在这些单位中，自由费米气体每个粒子的动能是\n$$\n\\frac{E_{\\text{kin}}}{A}(k_F) \\;=\\; \\frac{3}{5}\\, e(k_F) \\;=\\; \\frac{3}{10}\\, k_F^2,\n$$\n因此每个粒子的总能量是\n$$\n\\frac{E}{A}(k_F) \\;=\\; \\frac{E_{\\text{kin}}}{A}(k_F) \\;+\\; \\frac{E_{\\text{pot}}}{A}(k_F).\n$$\n\n任务：\n- 编写一个完整的程序，对于给定的参数集 $(k_F,\\beta,\\lambda)$，计算 $\\operatorname{Re}\\, J(k_F^2;k_F)$，然后使用 $J$ 的实部计算 $\\tau(k_F^2;k_F)$，求出 $I_F(k_F)$ 的值，最后以指定的自然单位返回每个粒子的总能量 $\\frac{E}{A}(k_F)$。\n- 在对 $\\operatorname{Re}\\, J$ 进行数值积分时，使用一个小的正正则化子 $\\eta$（例如，$\\eta=10^{-6}$）。\n- 为半无限域实现精确的数值积分，以计算 $J$ 和 $I_F$ 的积分。\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3]\"），每个结果四舍五入到六位小数。\n\n测试套件：\n为以下四种情况计算每个粒子的总能量 $\\frac{E}{A}(k_F)$，这些情况旨在验证极限情况和覆盖范围：\n1. 正常路径类核物质情况：$k_F = 1.33$，$\\beta = 1.0$，$\\lambda = 2.0$。\n2. 零耦合极限：$k_F = 1.33$，$\\beta = 1.0$，$\\lambda = 0.0$。在此极限下，输出必须等于自由费米气体的单粒子动能 $\\frac{3}{10}k_F^2$。\n3. 低密度边界：$k_F = 0.1$，$\\beta = 1.0$，$\\lambda = 2.0$。相互作用的贡献应可忽略不计，输出应接近 $\\frac{3}{10}k_F^2$。\n4. 短程（大 $\\beta$）边界情况：$k_F = 1.33$，$\\beta = 10.0$，$\\lambda = 2.0$。Yamaguchi 形状因子抑制了相互作用，结果应接近动能项。\n\n您的程序应生成单行输出，其中包含按上面列出的确切顺序排列的四种情况的能量，格式为用方括号括起来的逗号分隔列表，并四舍五入到六位小数，例如，“[E1,E2,E3,E4]”。", "solution": "该问题要求在一个简化的 Brueckner-Hartree-Fock (BHF) 框架内计算对称核物质中每个粒子的总能量 $\\frac{E}{A}$。该计算基于一组特定的近似：可分离的 Yamaguchi 势、自由粒子动能谱以及角平均的泡利算符和起始能量。任务是针对给定的参数集 $(k_F, \\beta, \\lambda)$ 数值实现所提供的公式，其中 $k_F$ 是费米动量，$\\beta$ 和 $\\lambda$ 是势的参数。我们在自然单位制中进行计算，其中 $\\hbar=1$ 且核子质量 $m=1$。\n\n每个粒子的总能量是动能和势能贡献的总和：\n$$\n\\frac{E}{A}(k_F) = \\frac{E_{\\text{kin}}}{A}(k_F) + \\frac{E_{\\text{pot}}}{A}(k_F)\n$$\n\n计算过程如下，逐一评估每个分量。\n\n**1. 每个粒子的动能**\n在指定的单位制中，对于自由费米气体中的核子，每个粒子的平均动能由下式给出：\n$$\n\\frac{E_{\\text{kin}}}{A}(k_F) = \\frac{3}{5} e(k_F) = \\frac{3}{5} \\frac{k_F^2}{2m} = \\frac{3}{10} k_F^2\n$$\n该项仅依赖于费米动量 $k_F$。\n\n**2. 每个粒子的势能**\n在指定的近似范围内，每个粒子的势能由下式给出：\n$$\n\\frac{E_{\\text{pot}}}{A}(k_F) \\approx \\frac{d \\cdot \\tau(k_F^2;k_F)}{2 \\rho(k_F)} [I_F(k_F)]^2\n$$\n此处，有效道权重因子为 $d=1$。需要计算的三个关键分量是密度 $\\rho(k_F)$、积分 $I_F(k_F)$ 和介质中函数 $\\tau(k_F^2;k_F)$。\n\n**2.1. 核物质密度, $\\rho(k_F)$**\n考虑到自旋-同位旋简并度为 $4$，对称核物质的密度由下式给出：\n$$\n\\rho(k_F) = \\frac{4 \\cdot (\\frac{4}{3}\\pi k_F^3)}{(2\\pi)^3} = \\frac{2k_F^3}{3\\pi^2}\n$$\n\n**2.2. 费米球平均积分, $I_F(k_F)$**\n该项表示势的形状因子 $g(k)$ 的平方在费米球内已占据态上的平均值。Yamaguchi 势的形状因子为 $g(k) = \\frac{1}{k^2 + \\beta^2}$。该积分定义为：\n$$\nI_F(k_F) = \\frac{1}{2\\pi^2} \\int_0^{k_F} dk\\, k^2\\, g(k)^2 = \\frac{1}{2\\pi^2} \\int_0^{k_F} dk\\, \\frac{k^2}{(k^2 + \\beta^2)^2}\n$$\n这是一个在有限区间 $[0, k_F]$ 上的正常积分，将使用数值求积法进行计算。\n\n**2.3. 介质中函数, $\\tau(k_F^2; k_F)$**\n函数 $\\tau$ 捕捉了核介质对双核子相互作用的影响。对于可分离势，它由下式给出：\n$$\n\\tau(\\omega;k_F) = \\frac{-\\lambda}{1 + \\lambda J(\\omega;k_F)}\n$$\n问题指定使用起始能量 $\\omega = 2e(k_F) = k_F^2$，并指示仅使用圈图积分 $J(\\omega;k_F)$ 的实部。因此，我们计算：\n$$\n\\tau(k_F^2;k_F) = \\frac{-\\lambda}{1 + \\lambda \\operatorname{Re}J(k_F^2;k_F)}\n$$\n\n**2.4. 圈图积分, $\\operatorname{Re}J(k_F^2; k_F)$**\n$J$ 积分的实部解释了一对粒子在费米海之上的传播。要计算的表达式是：\n$$\n\\operatorname{Re}J(k_F^2;k_F) = \\frac{1}{2\\pi^2} \\int_{k_F}^{\\infty} dq\\, q^2\\, g(q)^2 \\, \\frac{k_F^2 - q^2}{(k_F^2 - q^2)^2 + \\eta^2}\n$$\n代入形状因子 $g(q) = \\frac{1}{q^2 + \\beta^2}$，被积函数变为：\n$$\n\\frac{1}{2\\pi^2} \\frac{q^2}{(q^2 + \\beta^2)^2} \\frac{k_F^2 - q^2}{(k_F^2 - q^2)^2 + \\eta^2}\n$$\n该积分是在半无限域 $[k_F, \\infty)$ 上进行的。涉及 $\\eta$ 的项是在 $\\eta \\to 0^+$ 极限下获得的主值积分中出现的 $q=k_F$ 处极点的正则化。对于一个小的有限值 $\\eta = 10^{-6}$，被积函数是良态的，尽管它在 $q=k_F$ 附近可能有一个尖锐的特征，这需要一个稳健的数值积分方法。\n\n**计算算法**\n为给定参数集 $(k_F, \\beta, \\lambda)$ 计算总能量的算法如下：\n1.  计算每个粒子的动能：$\\frac{E_{\\text{kin}}}{A} = \\frac{3}{10}k_F^2$。\n2.  如果 $\\lambda=0$，势能为 $0$，总能量就是动能。\n3.  如果 $\\lambda \\neq 0$：\n    a. 定义 $I_F(k_F)$ 的被积函数，并从 $0$ 到 $k_F$ 进行数值积分。乘以预因子 $\\frac{1}{2\\pi^2}$ 得到 $I_F(k_F)$。\n    b. 使用正则化子 $\\eta=10^{-6}$ 定义 $\\operatorname{Re}J(k_F^2;k_F)$ 的被积函数。从 $k_F$ 到 $\\infty$ 进行数值积分。乘以预因子 $\\frac{1}{2\\pi^2}$ 得到 $\\operatorname{Re}J(k_F^2;k_F)$。\n    c. 计算 $\\tau(k_F^2;k_F) = \\frac{-\\lambda}{1 + \\lambda \\operatorname{Re}J(k_F^2;k_F)}$。\n    d. 计算核密度 $\\rho(k_F) = \\frac{2k_F^3}{3\\pi^2}$。\n    e. 组合得到每个粒子的势能：$\\frac{E_{\\text{pot}}}{A} = \\frac{\\tau(k_F^2;k_F)}{2\\rho(k_F)} [I_F(k_F)]^2$。\n    f. 将动能和势能相加，得到每个粒子的总能量 $\\frac{E}{A}(k_F)$。\n\n对问题陈述中提供的四个测试用例均实施此程序。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the BHF problem for the given test cases and prints the results.\n    \"\"\"\n\n    # Test cases: (k_F, beta, lambda)\n    test_cases = [\n        (1.33, 1.0, 2.0),\n        (1.33, 1.0, 0.0),\n        (0.1, 1.0, 2.0),\n        (1.33, 10.0, 2.0),\n    ]\n\n    results = []\n    for kF, beta, lam in test_cases:\n        energy = calculate_total_energy_per_particle(kF, beta, lam)\n        results.append(f\"{energy:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_total_energy_per_particle(kF, beta, lam, eta=1e-6):\n    \"\"\"\n    Calculates the total energy per particle for given BHF model parameters.\n\n    Args:\n        kF (float): Fermi momentum.\n        beta (float): Range parameter of the Yamaguchi potential.\n        lam (float): Coupling strength of the Yamaguchi potential.\n        eta (float): Regulator for the principal value integral.\n\n    Returns:\n        float: The total energy per particle E/A.\n    \"\"\"\n    # Kinetic energy per particle for a free Fermi gas in natural units (m=1)\n    E_kin_per_A = (3.0 / 10.0) * kF**2\n\n    # If coupling is zero, potential energy is zero.\n    if lam == 0.0:\n        return E_kin_per_A\n\n    # --- Potential Energy Calculation ---\n\n    # 1. Calculate the integral I_F(kF)\n    # Integrand for I_F\n    def integrand_IF(k):\n        return (k**2) / ((k**2 + beta**2)**2)\n\n    # Numerical integration from 0 to kF\n    integral_val_IF, _ = quad(integrand_IF, 0, kF)\n    I_F_kF = (1.0 / (2.0 * np.pi**2)) * integral_val_IF\n\n    # 2. Calculate the real part of the loop integral, Re[J(omega, kF)]\n    # Integrand for Re[J]\n    def integrand_ReJ(q):\n        # Using kF**2 for omega\n        omega = kF**2\n        g_q_sq = 1.0 / ((q**2 + beta**2)**2)\n        propagator_real_part = (omega - q**2) / ((omega - q**2)**2 + eta**2)\n        return q**2 * g_q_sq * propagator_real_part\n\n    # Numerical integration from kF to infinity\n    integral_val_ReJ, _ = quad(integrand_ReJ, kF, np.inf)\n    ReJ_kF = (1.0 / (2.0 * np.pi**2)) * integral_val_ReJ\n\n    # 3. Calculate the in-medium tau-function\n    tau_kF = -lam / (1.0 + lam * ReJ_kF)\n\n    # 4. Calculate the density rho(kF)\n    rho_kF = (2.0 * kF**3) / (3.0 * np.pi**2)\n\n    # 5. Calculate the potential energy per particle\n    # Effective channel weight d=1\n    E_pot_per_A = (tau_kF / (2.0 * rho_kF)) * (I_F_kF**2)\n\n    # Total energy is the sum of kinetic and potential energies\n    E_total_per_A = E_kin_per_A + E_pot_per_A\n\n    return E_total_per_A\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3545472"}, {"introduction": "微观核理论的一个核心成就是它能够解释核物质的饱和现象——即原子核为何具有近似恒定的中心密度和结合能。核子-核子相互作用的一个独特特征——张量力，在这一现象中起着至关重要的作用，但其效应在简单的Hartree-Fock层次上无法体现。本练习采用一个分离了中心力和张量力贡献的模型，让您能够通过计算来分离并量化张量关联在实现真实核饱和中所扮演的关键角色。[@problem_id:3545468]", "problem": "您的任务是编写一个完整、可运行的程序，在一个简化但有原则的 Brueckner-Hartree-Fock 框架内，量化在 ${}^3S_1$–${}^3D_1$ 道中关闭张量力诱导的 $S$–$D$ 耦合如何改变对称核物质的饱和点。您的模型必须基于以下基本要素和经过充分检验的近似，并且您必须以兆电子伏特每核子（MeV per nucleon）计算所有能量，以逆立方费米（fm$^{-3}$）计算所有密度，以逆费米（fm$^{-1}$）计算所有波数，以费米（fm）计算所有力程。所需的输出是单行文本，包含一个浮点数列表，该列表汇总了如下指定的多个测试参数集的结果。\n\n从以下基础开始：\n\n1.  均匀的对称核物质，自旋-同位旋简并度 $\\nu = 4$。数密度 $\\rho$ 和费米动量 $k_F$ 的关系为\n$$\n\\rho = \\frac{\\nu k_F^3}{6\\pi^2} = \\frac{2 k_F^3}{3\\pi^2}.\n$$\n\n2.  非相对论费米气体中每核子的动能为\n$$\n\\frac{T}{A} = \\frac{3}{5} \\frac{\\hbar^2 k_F^2}{2m},\n$$\n其中 $\\hbar^2/(2m) = 20.735 \\ \\mathrm{MeV\\,fm^2}$。\n\n3.  在 Hartree-Fock 近似下，由有限程中心力产生的每核子势能由坐标空间表达式给出\n$$\n\\frac{E_{\\text{central}}}{A} = \\frac{\\rho}{2} \\int d^3 r \\, V_c(r) \\left[ 1 - \\frac{1}{\\nu} \\, \\ell^2(k_F r) \\right],\n$$\n其中 $\\ell(x) = \\dfrac{3 j_1(x)}{x}$ 是 Slater 函数，$j_1(x)$ 为 1 阶球贝塞尔函数。使用双高斯中心势，\n$$\nV_c(r) = V_R \\, e^{-r^2/\\alpha_R^2} + V_A \\, e^{-r^2/\\alpha_A^2},\n$$\n其中 $V_R > 0$ 代表短程排斥，$V_A  0$ 代表中程吸引。执行角度积分以将该积分简化为\n$$\n\\frac{E_{\\text{central}}}{A} = \\frac{\\rho}{2} \\int_{0}^{\\infty} 4\\pi r^2 \\, V_c(r) \\left[ 1 - \\frac{1}{\\nu} \\, \\ell^2(k_F r) \\right] \\, dr.\n$$\n\n4.  张量力诱导的 ${}^3S_1$–${}^3D_1$ 耦合在自旋饱和物质的 Hartree-Fock 阶没有贡献。为了包含它，我们用一个具有高斯形状因子的可分离 $S$–$D$ 核来近似二阶 Brueckner 关联能。将每核子的张量贡献建模为\n$$\n\\frac{E_{\\text{tensor}}}{A} = - c_0 \\, \\frac{\\hbar^2}{2m} \\, \\frac{1}{\\Lambda} \\, \\frac{J_h(k_F;\\Lambda) \\, J_p(k_F;\\Lambda,\\kappa)}{\\rho},\n$$\n其中 $c_0$ 是一个无量纲的强度参数，$\\Lambda$ 是一个动量标度截断，$\\kappa$ 用于正则化平均粒子-空穴能量分母。使用分解的、角平均的积分\n$$\nJ_h(k_F;\\Lambda) = \\int_0^{k_F} h^2 \\, e^{-2h^2/\\Lambda^2} \\, dh, \\quad\nJ_p(k_F;\\Lambda,\\kappa) = \\int_{k_F}^{\\infty} \\frac{p^2 \\, e^{-2p^2/\\Lambda^2}}{p^2 + \\kappa^2} \\, dp.\n$$\n这种分解是通过将能量分母近似为仅依赖于粒子动量的函数 $p^2 + \\kappa^2$ 得到的，其合理性在于粒子-空穴激发中粒子动量通常大于空穴动量，并且使用了可分离高斯形状因子 $g(k) = e^{-k^2/\\Lambda^2}$ 来描述 ${}^3S_1$–${}^3D_1$ 耦合。\n\n5.  因此，每核子的总能量为\n$$\n\\frac{E}{A}(k_F; s) = \\frac{T}{A}(k_F) + \\frac{E_{\\text{central}}}{A}(k_F) + s \\, \\frac{E_{\\text{tensor}}}{A}(k_F),\n$$\n其中开关参数 $s \\in \\{0,1\\}$ 代表关闭（$s=0$）或开启（$s=1$）$S$–$D$ 耦合。\n\n您的任务：\n\n-   对于下面测试套件中的每个参数集，在两种情况下计算饱和点：有张量耦合（$s=1$）和关闭张量耦合（$s=0$）。饱和点定义为在指定网格上使 $\\frac{E}{A}$ 最小化的 $k_F$ 值。如果 $\\frac{E}{A}$ 在网格上是单调的，则将饱和点定义为 $\\frac{E}{A}$ 取得最小值的网格端点。\n-   使用 $\\rho = \\dfrac{2 k_F^3}{3\\pi^2}$ 将每个饱和费米动量转换为饱和密度。\n-   通过计算差值来量化张量力引起的位移\n$$\n\\Delta \\rho_{\\text{sat}} = \\rho_{\\text{sat}}^{(s=1)} - \\rho_{\\text{sat}}^{(s=0)}, \\qquad\n\\Delta (E/A)_{\\text{sat}} = \\left.\\frac{E}{A}\\right|_{\\text{sat}, s=1} - \\left.\\frac{E}{A}\\right|_{\\text{sat}, s=0}.\n$$\n\n数值说明和约定：\n\n-   精确使用 $\\nu = 4$。\n-   精确使用 $\\hbar^2/(2m) = 20.735 \\ \\mathrm{MeV\\,fm^2}$。\n-   对于 Slater 函数，使用 $\\ell(x) = \\dfrac{3 j_1(x)}{x}$，其中 $j_1(x) = \\dfrac{\\sin x}{x^2} - \\dfrac{\\cos x}{x}$，并通过连续性定义 $\\ell(0)=1$。\n-   通过在一个大但有限的上限处截断，在 $[0, +\\infty)$ 上执行中心能的 $r$-积分。一个科学上合理的选择是使用等于最大力程参数 8 倍的上限，即 $r_{\\max} = 8 \\, \\max(\\alpha_R,\\alpha_A)$，这对于高斯力程是足够的。\n-   对于张量积分，在 $[0,k_F]$ 上计算 $J_h$，在 $[k_F,+\\infty)$ 上计算 $J_p$，指数形式的形状因子确保了收敛性。\n-   在一个均匀网格 $k_F \\in [0.4, 1.8] \\ \\mathrm{fm^{-1}}$ 上扫描费米动量，网格点数恰好为 $121$ 个。\n-   对于每个参数集，按以下顺序返回六个量，并注明单位和舍入要求：\n    1.  $\\rho_{\\text{sat}}^{(s=1)}$，单位为 fm$^{-3}$，保留三位小数。\n    2.  $\\left.\\dfrac{E}{A}\\right|_{\\text{sat}, s=1}$，单位为 MeV/nucleon，保留两位小数。\n    3.  $\\rho_{\\text{sat}}^{(s=0)}$，单位为 fm$^{-3}$，保留三位小数。\n    4.  $\\left.\\dfrac{E}{A}\\right|_{\\text{sat}, s=0}$，单位为 MeV/nucleon，保留两位小数。\n    5.  $\\Delta \\rho_{\\text{sat}}$，单位为 fm$^{-3}$，保留三位小数。\n    6.  $\\Delta (E/A)_{\\text{sat}}$，单位为 MeV/nucleon，保留两位小数。\n\n测试套件（每个元组指定 $(V_R,\\alpha_R,V_A,\\alpha_A,c_0,\\Lambda,\\kappa)$，其中 $V_R$ 和 $V_A$ 单位为 MeV，$\\alpha_R$ 和 $\\alpha_A$ 单位为 fm，$\\Lambda$ 和 $\\kappa$ 单位为 fm$^{-1}$）：\n\n-   情况 1（理想情况）：$(650.0, \\ 0.5, \\ -35.0, \\ 1.2, \\ 3.0, \\ 2.0, \\ 1.0)$。\n-   情况 2（弱张量边界情况）：$(650.0, \\ 0.5, \\ -35.0, \\ 1.2, \\ 0.8, \\ 1.8, \\ 1.0)$。\n-   情况 3（更强的短程排斥）：$(800.0, \\ 0.5, \\ -30.0, \\ 1.2, \\ 3.5, \\ 2.2, \\ 1.3)$。\n\n最终输出格式：\n\n-   您的程序应产生单行输出，其中包含三个情况的结果，形式为方括号括起来的逗号分隔列表。首先是情况 1 的六个舍入数字，然后是情况 2 的六个舍入数字，最后是情况 3 的六个舍入数字。例如，一个语法正确的输出结构是\n$[\\rho^{(1)}_{\\text{sat}, s=1},E^{(1)}_{\\text{sat}, s=1},\\rho^{(1)}_{\\text{sat}, s=0},E^{(1)}_{\\text{sat}, s=0},\\Delta\\rho^{(1)}_{\\text{sat}},\\Delta E^{(1)}_{\\text{sat}},\\rho^{(2)}_{\\text{sat}, s=1},\\dots,\\Delta E^{(3)}_{\\text{sat}}]$。", "solution": "所述问题具有科学依据，提法明确且客观。它提出了一个来自计算核物理的简化但标准的模型，具体来说是一个受 Brueckner-Hartree-Fock 启发的对称核物质框架。模型的所有组成部分，包括费米气体的动能、具有高斯相互作用的 Hartree-Fock 势能，以及用于二阶张量关联的可分离模型，都基于既定原理。参数、常数和数值说明是完整和一致的。因此，可以推导出一个有意义且唯一的解。我们着手求解。\n\n目标是确定饱和点——系统最稳定时的密度 $\\rho_{\\text{sat}}$ 和每核子能量 $(E/A)_{\\text{sat}}$。我们将针对两种情况进行计算：包含张量力贡献（$s=1$）和不包含（$s=0$）。然后将量化饱和点的位移。\n\n每核子总能量 $\\frac{E}{A}$ 是费米动量 $k_F$ 和一个开关参数 $s$ 的函数：\n$$\n\\frac{E}{A}(k_F; s) = \\frac{T}{A}(k_F) + \\frac{E_{\\text{central}}}{A}(k_F) + s \\, \\frac{E_{\\text{tensor}}}{A}(k_F)\n$$\n对于自旋-同位旋对称物质（简并度 $\\nu=4$），费米动量 $k_F$ 与核子数密度 $\\rho$ 的关系为 $\\rho = \\frac{2 k_F^3}{3\\pi^2}$。我们将详细分析能量表达式的每一项。\n\n**1. 每核子动能**\n对于非相对论费米气体，平均每核子动能 $\\frac{T}{A}$ 由下式给出：\n$$\n\\frac{T}{A}(k_F) = \\frac{3}{5} \\frac{\\hbar^2 k_F^2}{2m}\n$$\n这一项代表了由泡利不相容原理决定的、被限制在有限体积内核子量子力学运动所产生的能量。我们使用给定的常数 $\\frac{\\hbar^2}{2m} = 20.735 \\ \\mathrm{MeV\\,fm^2}$。\n\n**2. 每核子中心势能**\n中心力的贡献 $\\frac{E_{\\text{central}}}{A}$ 在 Hartree-Fock 近似下计算。该项考虑了核子之间的直接（Hartree）和交换（Fock）相互作用。给出的公式是：\n$$\n\\frac{E_{\\text{central}}}{A}(k_F) = \\frac{\\rho}{2} \\int_{0}^{\\infty} 4\\pi r^2 \\, V_c(r) \\left[ 1 - \\frac{1}{\\nu} \\, \\ell^2(k_F r) \\right] \\, dr\n$$\n该表达式的组成部分是：\n-   $V_c(r) = V_R \\, e^{-r^2/\\alpha_R^2} + V_A \\, e^{-r^2/\\alpha_A^2}$：一个双程高斯势，一种常见的唯象形式，代表短程排斥（$V_R  0$）和中程吸引（$V_A  0$）。\n-   $\\ell(x) = \\frac{3 j_1(x)}{x}$：Slater 函数，其中 $j_1(x)$ 是一阶第一类球贝塞尔函数。$\\ell^2(k_F r)$ 项源于对单体密度矩阵平方的角平均，代表了泡利阻塞对介质中两核子相互作用的影响。根据连续性，$\\ell(0)=1$。对于每个 $k_F$，该积分都进行数值计算。根据说明，积分范围被截断在一个足够大的半径 $r_{\\max} = 8 \\, \\max(\\alpha_R, \\alpha_A)$ 处，以确保由于势的高斯特性而收敛。\n\n**3. 每核子张量关联能**\n对于自旋饱和物质的 Hartree-Fock 近似没有捕捉到强张量力的效应，而张量力是核结合和饱和的关键驱动因素。$\\frac{E_{\\text{tensor}}}{A}$ 项将此贡献建模为 Brueckner G-矩阵形式下的二阶微扰。给出的公式是：\n$$\n\\frac{E_{\\text{tensor}}}{A}(k_F) = - c_0 \\, \\frac{\\hbar^2}{2m} \\, \\frac{1}{\\Lambda} \\, \\frac{J_h(k_F;\\Lambda) \\, J_p(k_F;\\Lambda,\\kappa)}{\\rho}\n$$\n该表达式近似了由张量力耦合 ${}^3S_1$ 和 ${}^3D_1$ 分波所诱导的虚粒子-空穴激发所带来的能量增益。其组成部分是：\n-   $J_h(k_F;\\Lambda) = \\int_0^{k_F} h^2 \\, e^{-2h^2/\\Lambda^2} \\, dh$：一个对费米动量 $k_F$ 以下的已占据“空穴”态的积分。\n-   $J_p(k_F;\\Lambda,\\kappa) = \\int_{k_F}^{\\infty} \\frac{p^2 \\, e^{-2p^2/\\Lambda^2}}{p^2 + \\kappa^2} \\, dp$：一个对 $k_F$ 以上的未占据“粒子”态的积分。\n-   高斯形状因子 $e^{-k^2/\\Lambda^2}$ 反映了相互作用在动量空间中的有限力程。项 $\\frac{1}{p^2+\\kappa^2}$ 是一个简化的角平均能量分母，其中 $\\kappa$ 代表一个平均激发能标。负号表示这个二阶项是吸引的。这些积分将进行数值计算。\n\n**计算流程**\n任务的核心是实现一个计算 $\\frac{E}{A}$ 作为 $k_F$ 函数并找到其最小值的过程。\n1.  在区间 $[0.4, 1.8] \\ \\mathrm{fm^{-1}}$ 上建立一个包含 121 个点的 $k_F$ 均匀网格。\n2.  对于测试套件中提供的每个参数集：\n    a. 我们在网格上计算 $s=1$（张量力开启）和 $s=0$（张量力关闭）两种情况下的每核子能量曲线 $\\frac{E}{A}(k_F)$。这涉及到为每个 $k_F$ 值计算三个能量分量，对中心势和张量势项使用数值积分（`scipy.integrate.quad`）。\n    b. 通过在网格上找到使 $\\frac{E}{A}$ 最小化的 $k_F$ 值来确定每种情况的饱和点。如果函数在网格上是单调的，则饱和点取为能量较低的网格端点。\n    c. 饱和费米动量 $k_{F, \\text{sat}}$ 用于计算饱和密度 $\\rho_{\\text{sat}} = \\frac{2 k_{F, \\text{sat}}^3}{3\\pi^2}$。相应的最小能量是 $(E/A)_{\\text{sat}}$。\n    d. 最后，计算差值 $\\Delta \\rho_{\\text{sat}} = \\rho_{\\text{sat}}^{(s=1)} - \\rho_{\\text{sat}}^{(s=0)}$ 和 $\\Delta (E/A)_{\\text{sat}} = (E/A)_{\\text{sat}}^{(s=1)} - (E/A)_{\\text{sat}}^{(s=0)}$ 以量化张量力的影响。\n3.  将每个测试案例的六个结果量按规定进行舍入，并汇总成一个单一的输出列表。\n\n该实现将被封装在一个 Python 程序中，利用 `numpy` 和 `scipy` 库进行数值计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import spherical_jn\n\ndef solve():\n    \"\"\"\n    Computes the saturation point of symmetric nuclear matter using a\n    simplified Brueckner-Hartree-Fock framework and quantifies the shift\n    due to the tensor force.\n    \"\"\"\n\n    # --- Fixed Physical and Model Constants ---\n    HBAR2_OVER_2M = 20.735  # MeV*fm^2\n    NU = 4.0  # Spin-isospin degeneracy\n\n    # --- Test Cases ---\n    # Each tuple: (V_R, alpha_R, V_A, alpha_A, c0, Lambda, kappa)\n    test_cases = [\n        (650.0, 0.5, -35.0, 1.2, 3.0, 2.0, 1.0),\n        (650.0, 0.5, -35.0, 1.2, 0.8, 1.8, 1.0),\n        (800.0, 0.5, -30.0, 1.2, 3.5, 2.2, 1.3),\n    ]\n\n    # --- Numerical Grid ---\n    kF_grid = np.linspace(0.4, 1.8, 121)\n\n    # --- Helper Functions for Energy Calculation ---\n\n    def _density(kF):\n        \"\"\"Calculates nucleon number density from Fermi momentum.\"\"\"\n        return 2.0 * kF**3 / (3.0 * np.pi**2)\n\n    def _kinetic_energy_per_nucleon(kF):\n        \"\"\"Calculates kinetic energy per nucleon.\"\"\"\n        return (3.0 / 5.0) * HBAR2_OVER_2M * kF**2\n\n    def _slater_l(x):\n        \"\"\"\n        Calculates the Slater function l(x) = 3*j1(x)/x.\n        Handles the x=0 case by using the known limit l(0)=1.\n        \"\"\"\n        if np.isclose(x, 0.0):\n            return 1.0\n        # For precision, use spherical_jn(1,x) which computes j_1(x)\n        return 3.0 * spherical_jn(1, x) / x\n\n    def _central_energy_per_nucleon(kF, params):\n        \"\"\"Calculates the central potential energy per nucleon.\"\"\"\n        V_R, alpha_R, V_A, alpha_A, _, _, _ = params\n        rho = _density(kF)\n\n        def Vc(r):\n            return V_R * np.exp(-r**2 / alpha_R**2) + V_A * np.exp(-r**2 / alpha_A**2)\n\n        def integrand(r):\n            slater_term = _slater_l(kF * r)\n            return 4.0 * np.pi * r**2 * Vc(r) * (1.0 - (1.0 / NU) * slater_term**2)\n\n        r_max = 8.0 * max(alpha_R, alpha_A)\n        # The integral from 0 to r_max\n        integral_val, _ = quad(integrand, 0, r_max, epsabs=1e-9, limit=100)\n\n        return (rho / 2.0) * integral_val\n\n    def _tensor_energy_per_nucleon(kF, params):\n        \"\"\"Calculates the tensor correlation energy per nucleon.\"\"\"\n        _, _, _, _, c0, Lambda, kappa = params\n        \n        if np.isclose(kF, 0.0):\n            return 0.0\n\n        rho = _density(kF)\n\n        # J_h integral\n        def jh_integrand(h):\n            return h**2 * np.exp(-2.0 * h**2 / Lambda**2)\n\n        Jh, _ = quad(jh_integrand, 0, kF, epsabs=1e-9, limit=100)\n\n        # J_p integral\n        def jp_integrand(p):\n            return (p**2 * np.exp(-2.0 * p**2 / Lambda**2)) / (p**2 + kappa**2)\n\n        Jp, _ = quad(jp_integrand, kF, np.inf, epsabs=1e-9, limit=100)\n\n        return -c0 * HBAR2_OVER_2M * (1.0 / Lambda) * (Jh * Jp / rho)\n\n    def _get_saturation_properties(params, s, kF_grid):\n        \"\"\"\n        Calculates the energy-density curve and finds the saturation point.\n        s=1 for tensor ON, s=0 for tensor OFF.\n        \"\"\"\n        energies = []\n        # Pre-calculate central energies as they are independent of 's'\n        central_energies = {kF: _central_energy_per_nucleon(kF, params) for kF in kF_grid}\n\n        for kF in kF_grid:\n            e_kin = _kinetic_energy_per_nucleon(kF)\n            e_cen = central_energies[kF]\n            e_ten = 0.0\n            if s == 1:\n                e_ten = _tensor_energy_per_nucleon(kF, params)\n            \n            total_energy = e_kin + e_cen + e_ten\n            energies.append(total_energy)\n        \n        energies = np.array(energies)\n        idx_min = np.argmin(energies)\n        \n        e_sat = energies[idx_min]\n        kF_sat = kF_grid[idx_min]\n        rho_sat = _density(kF_sat)\n        \n        return rho_sat, e_sat\n\n    # --- Main Loop to Process Test Cases ---\n    final_results = []\n    for params in test_cases:\n        # Scenario s=1 (Tensor ON)\n        rho_sat_s1, e_sat_s1 = _get_saturation_properties(params, 1, kF_grid)\n\n        # Scenario s=0 (Tensor OFF)\n        rho_sat_s0, e_sat_s0 = _get_saturation_properties(params, 0, kF_grid)\n\n        # Differences\n        delta_rho = rho_sat_s1 - rho_sat_s0\n        delta_e = e_sat_s1 - e_sat_s0\n\n        # Store rounded results in the required order\n        final_results.extend([\n            round(rho_sat_s1, 3), round(e_sat_s1, 2),\n            round(rho_sat_s0, 3), round(e_sat_s0, 2),\n            round(delta_rho, 3), round(delta_e, 2)\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```", "id": "3545468"}]}