{"hands_on_practices": [{"introduction": "本练习是理解伽莫夫峰的分析基础。通过从第一性原理出发，您将推导伽莫夫峰能量的经典表达式，即通过最大化麦克斯韦-玻尔兹曼能量分布与量子隧穿概率的乘积来找到最可能发生核聚变的能量。这项实践将加深您对形成伽莫夫峰的两个关键物理因素——高温下的粒子能量分布和克服库仑势垒的量子隧穿效应——之间相互竞争的理解。[@problem_id:3725090]", "problem": "考虑在温度为 $T$ 的热核等离子体中，有两个电荷分别为 $Z_1 e$ 和 $Z_2 e$、折合质量为 $\\mu$ 的完全电离原子核。在非共振条件下，每对原子核的聚变反应率可以写成一个能量积分，其主要的能量依赖性源于两个基本因素：\n\n- 麦克斯韦-玻尔兹曼能量权重，对于能量 $E$，其贡献的因子与 $\\exp(-E/(k_{B}T))$ 成正比，其中 $k_{B}$ 是玻尔兹曼常数。\n- 穿过库仑势垒的量子力学隧穿概率，在半经典的 Wentzel-Kramers-Brillouin (WKB) 近似下，其贡献的因子为 $\\exp(-\\sqrt{E_{G}/E})$，其中 $E_{G}$ 是一个由库仑势垒参数和 $\\mu$ 决定的正常数（伽莫夫能量）。\n\n假设 $E$ 的所有代数前置因子以及任何微弱的能量依赖性（例如来自截面结构函数）在峰值附近变化缓慢，并且在定位最大值时可以被视为常数，那么需要对 $E$ 进行最大化的被积函数与上述两个指数因子的乘积成正比。该乘积达到最大值时的能量称为伽莫夫峰能量 $E_{0}$。\n\n从这些基本输入（麦克斯韦-玻尔兹曼统计和 WKB 隧穿因子）出发，推导最大值的条件，并获得伽莫夫峰能量 $E_{0}$ 关于 $T$ 和 $E_{G}$ 的封闭形式表达式。请用包含 $k_{B}$、$T$ 和 $E_{G}$ 的符号表达式来表示你的最终答案。最终表达式中不要包含单位。", "solution": "问题陈述清晰，具有科学依据，并包含足够的信息以获得唯一解。它描述了核天体物理学中的一个经典问题：确定热核聚变反应的最概然能量，即所谓的伽莫夫峰。该物理模型基于两种相互竞争的效应：等离子体中粒子能量的麦克斯韦-玻尔兹曼分布和穿过库仑势垒的量子力学隧穿概率。问题给出了这两个因素的正确函数形式，并要求在其他能量依赖项变化缓慢这一简化但标准的假设下，找到使其乘积最大化的能量。因此，该问题是有效的。\n\n我们的任务是找到能量 $E_{0}$，使得一个与麦克斯韦-玻尔兹曼因子和 WKB 隧穿因子之积成正比的函数最大化。设此函数为 $f(E)$。根据问题描述，我们有：\n$$\nf(E) \\propto \\exp\\left(-\\frac{E}{k_{B}T}\\right) \\exp\\left(-\\sqrt{\\frac{E_{G}}{E}}\\right)\n$$\n其中 $E$ 是质心能量，$k_{B}$ 是玻尔兹曼常数，$T$ 是温度，$E_{G}$ 是伽莫夫能量，一个常数。我们可以将此关系写为：\n$$\nf(E) = C \\exp\\left(-\\frac{E}{k_{B}T} - \\sqrt{\\frac{E_{G}}{E}}\\right)\n$$\n其中 $C$ 是一个比例常数，它包含了所有能量的缓变因子，根据问题陈述，在本分析中这些因子被视为常数。\n\n为了找到 $f(E)$ 的最大值，从数学上讲，更方便的是找到其自然对数 $\\ln(f(E))$ 的最大值，因为对数函数是一个单调递增函数。最大化 $\\ln(f(E))$ 等价于最大化 $f(E)$ 本身。我们定义一个新函数 $g(E) = \\ln(f(E))$：\n$$\ng(E) = \\ln(C) - \\frac{E}{k_{B}T} - \\sqrt{\\frac{E_{G}}{E}}\n$$\n我们可以重写最后一项以便于求导：\n$$\ng(E) = \\ln(C) - \\frac{E}{k_{B}T} - \\sqrt{E_{G}} E^{-1/2}\n$$\n为了找到使 $g(E)$ 最大化的能量 $E_{0}$，我们必须求 $g(E)$ 对 $E$ 的导数，并令其为零。\n$$\n\\frac{dg}{dE} = \\frac{d}{dE}\\left(\\ln(C) - \\frac{E}{k_{B}T} - \\sqrt{E_{G}} E^{-1/2}\\right)\n$$\n常数项 $\\ln(C)$ 的导数为零。剩余项的导数为：\n$$\n\\frac{dg}{dE} = -\\frac{1}{k_{B}T} - \\sqrt{E_{G}} \\left(-\\frac{1}{2} E^{-3/2}\\right) = -\\frac{1}{k_{B}T} + \\frac{\\sqrt{E_{G}}}{2} E^{-3/2}\n$$\n在峰值能量 $E=E_{0}$ 处将导数设为零：\n$$\n\\frac{dg}{dE}\\bigg|_{E=E_{0}} = -\\frac{1}{k_{B}T} + \\frac{\\sqrt{E_{G}}}{2} E_{0}^{-3/2} = 0\n$$\n现在，我们求解这个方程以得到 $E_{0}$：\n$$\n\\frac{\\sqrt{E_{G}}}{2 E_{0}^{3/2}} = \\frac{1}{k_{B}T}\n$$\n整理各项以分离出 $E_{0}^{3/2}$：\n$$\nE_{0}^{3/2} = \\frac{\\sqrt{E_{G}} k_{B} T}{2}\n$$\n为了解出 $E_{0}$，我们将方程两边同时取 $2/3$ 次方：\n$$\nE_{0} = \\left(\\frac{\\sqrt{E_{G}} k_{B} T}{2}\\right)^{2/3}\n$$\n我们来简化这个表达式：\n$$\nE_{0} = \\frac{(E_{G}^{1/2})^{2/3} (k_{B}T)^{2/3}}{2^{2/3}} = \\frac{E_{G}^{1/3} (k_{B}T)^{2/3}}{2^{2/3}}\n$$\n这个表达式可以通过将所有项置于一个共同的根号下，写成更紧凑的形式：\n$$\nE_{0} = \\left(\\frac{E_{G} (k_{B}T)^{2}}{4}\\right)^{1/3}\n$$\n为了确认这个能量对应于一个最大值，我们考察 $g(E)$ 的二阶导数：\n$$\n\\frac{d^{2}g}{dE^{2}} = \\frac{d}{dE}\\left(-\\frac{1}{k_{B}T} + \\frac{\\sqrt{E_{G}}}{2} E^{-3/2}\\right) = \\frac{\\sqrt{E_{G}}}{2} \\left(-\\frac{3}{2} E^{-5/2}\\right) = -\\frac{3\\sqrt{E_{G}}}{4 E^{5/2}}\n$$\n由于能量 $E$ 必须为正，且伽莫夫能量 $E_{G}$ 是一个给定的正常数，所以对于所有 $E>0$，二阶导数 $\\frac{d^{2}g}{dE^{2}}$ 恒为负。这证实了我们在 $E=E_{0}$ 处找到的极值确实是一个最大值。\n\n因此，伽莫夫峰能量 $E_{0}$ 由所推导出的、以温度 $T$、玻尔兹曼常数 $k_{B}$ 和伽莫夫能量 $E_{G}$ 表示的表达式给出。", "answer": "$$\n\\boxed{\\left(\\frac{E_{G} (k_{B} T)^2}{4}\\right)^{1/3}}\n$$", "id": "3725090"}, {"introduction": "在理论推导的基础上，本练习将您带入一个更真实的计算场景，其中天体物理S因子$S(E)$不再是常数，而是具有能量依赖性，甚至可能包含共振。您的任务是实现一个稳健的数值算法来精确定位伽莫夫峰，这将训练您处理复杂的函数形态并确保数值解的可靠性。这项实践对于处理实验数据和进行精确的反应率计算至关重要。[@problem_id:3600134]", "problem": "考虑热核反应速率对数被积函数 $\\phi(E)$ 最大化时的伽莫夫峰能量 $E_0$ 的数值定位问题。请在计算核物理的背景下，从第一性原理出发推导您的方法。以下定义和要求精确地描述了该问题。\n\n从热分布和库仑势垒隧穿的基本原理开始。使用带有玻尔兹曼常数 $k_{\\mathrm{B}}$ 的麦克斯韦-玻尔兹曼能量分布，以及由伽莫夫因子表示的隧穿概率。定义待最大化的函数为\n$$\n\\phi(E) = \\ln S(E) - \\frac{E}{k_{\\mathrm{B}} T} - \\sqrt{\\frac{E_{\\mathrm{G}}}{E}},\n$$\n其中 $E$ 是能量，$T$ 是温度，$S(E)$ 是天体物理 $S$ 因子，$E_{\\mathrm{G}}$ 是伽莫夫能量。伽莫夫能量由库仑物理学和运动学定义为\n$$\nE_{\\mathrm{G}} = 2 \\pi^2 (Z_1 Z_2 \\alpha)^2 \\mu c^2,\n$$\n其中 $Z_1$ 和 $Z_2$ 是反应物的整数核电荷数，$\\alpha$ 是精细结构常数，$\\mu$ 是约化质量，$c$ 是光速。约化质量为\n$$\n\\mu = \\frac{m_1 m_2}{m_1 + m_2},\n$$\n其中 $m_1$ 和 $m_2$ 是粒子质量。所有能量必须以 $\\mathrm{keV}$ 表示，所有质量以 $\\mathrm{keV}/c^2$ 表示，温度以 $\\mathrm{K}$ 表示。\n\n通过一个缓慢变化的基线乘以一个局域共振来对能量依赖的 $S$ 因子进行建模：\n$$\nS(E) = S_0 \\left(1 + a E\\right)\\left(1 + A\\,L(E)\\right),\n$$\n其中 $S_0$ 是一个无量纲的标度，$a$ 是一个量纲为 $\\mathrm{keV}^{-1}$ 的小斜率参数，$A$ 是一个无量纲的共振振幅，$L(E)$ 是一个类洛伦兹共振线型\n$$\nL(E) = \\frac{(\\Gamma/2)^2}{(E - E_r)^2 + (\\Gamma/2)^2},\n$$\n其中共振能量 $E_r$ 和半高全宽 $\\Gamma$ 均以 $\\mathrm{keV}$ 为单位。\n\n您的任务是实现一个稳健的牛顿-拉夫逊算法来定位 $\\phi(E)$ 的最大值点 $E_0$，并遵循以下算法约束以确保在共振点附近的稳健性：\n- 仅基于第一性原理实现一个初始猜测（在初始估计中忽略 $S(E)$，并使用热-隧穿平衡）。\n- 使用牛顿-拉夫逊步长法，利用曲率信息 $\\phi''(E)$ 求解 $\\phi'(E) = 0$。\n- 包含回溯线搜索，以保证每次迭代时 $\\phi(E)$ 单调增加，并遵守定义域约束 $E > 0$。\n- 包含曲率检查，以确保收敛点是局部最大值，即强制 $\\phi''(E_0)  0$，并通过将 $\\phi(E_0)$ 与邻近点进行比较来验证局部优势。\n- 如果牛顿-拉夫逊方法失败，则回退到对 $\\phi'(E)$ 的有界求根搜索，以防止在共振点附近定位错误，并通过拒绝 $\\phi''(E) \\ge 0$ 的伪驻点来加以防范。\n- 确保对于非常小的 $E$ 值的数值稳定性（例如，通过将 $E$ 的下界设定为远离 $0$ 的值并保护所有除法运算）。\n\n要使用的常数是光速 $c$、玻尔兹曼常数 $k_{\\mathrm{B}}$ 和精细结构常数 $\\alpha$。初始猜测必须是一个具有物理动机的值，仅基于 $T$ 和 $E_{\\mathrm{G}}$ 从热抑制和库仑隧穿的平衡中推导出来。\n\n实现一个完整的、可运行的程序，为以下测试套件计算 $E_0$。对于每种情况，以浮点数形式输出最终的 $E_0$（单位为 $\\mathrm{keV}$）。\n\n测试套件参数集（每种情况是一个元组 $(Z_1, Z_2, m_1, m_2, T, S_0, a, A, E_r, \\Gamma)$）：\n- 情况 1（基线，无共振）：$(1, 1, 938272.0813, 938272.0813, 1.5\\times 10^7, 1.0, 0.0, 0.0, 0.0, 1.0)$。\n- 情况 2（经典峰附近的适度共振）：$(1, 6, 938272.0813, 11177412.0, 2.0\\times 10^8, 1.0, 1.0\\times 10^{-4}, 1.0, 450.0, 30.0)$。\n- 情况 3（强烈的离峰共振）：$(1, 6, 938272.0813, 11177412.0, 2.0\\times 10^8, 1.0, 2.0\\times 10^{-4}, 5.0, 800.0, 20.0)$。\n- 情况 4（低温下的邻近窄共振）：$(1, 1, 938272.0813, 938272.0813, 1.0\\times 10^6, 1.0, 0.0, 2.0, 5.0, 1.0)$。\n\n在所有情况下，常数必须为 $c = 2.99792458\\times 10^8\\,\\mathrm{m/s}$，$k_{\\mathrm{B}} = 8.617333262145\\times 10^{-8}\\,\\mathrm{keV/K}$ 和 $\\alpha = 7.2973525693\\times 10^{-3}$。\n\n您的程序必须生成单行输出，其中包含四个结果，以逗号分隔并用方括号括起来，例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$，其中每个 $\\text{result}_i$ 是计算出的 $E_0$（以 $\\mathrm{keV}$ 为单位的浮点数）。不允许有任何额外输出。", "solution": "该问题已经过验证并被确定为有效。这是一个计算核天体物理学中定义明确的问题，基于已建立的物理原理。问题陈述是自洽的，为唯一的数值解提供了所有必要的定义、常数和参数。语言客观，要求可形式化。\n\n任务是找到使函数 $\\phi(E)$ 最大化的能量 $E_0$，该函数是热核反应速率被积函数中关键项的对数。最大值点 $E_0$ 被称为伽莫夫峰能量。\n$$\n\\phi(E) = \\ln S(E) - \\frac{E}{k_{\\mathrm{B}} T} - \\sqrt{\\frac{E_{\\mathrm{G}}}{E}}\n$$\n$\\phi(E)$ 的最大值出现在能量 $E_0  0$ 处，该点的一阶导数为零，即 $\\phi'(E_0) = 0$，二阶导数为负，即 $\\phi''(E_0)  0$。\n\n解决方案的核心是牛顿-拉夫逊方法的稳健实现，用于找到 $\\phi'(E)=0$ 的根。该方法需要 $\\phi(E)$ 的解析导数。\n\n$\\phi(E)$ 对 $E$ 的一阶导数为：\n$$\n\\phi'(E) = \\frac{d}{dE} \\left( \\ln S(E) - \\frac{E}{k_{\\mathrm{B}} T} - \\sqrt{E_{\\mathrm{G}}} E^{-1/2} \\right) = \\frac{S'(E)}{S(E)} - \\frac{1}{k_{\\mathrm{B}} T} + \\frac{1}{2}\\sqrt{E_{\\mathrm{G}}}E^{-3/2}\n$$\n二阶导数 $\\phi''(E)$ 为：\n$$\n\\phi''(E) = \\frac{d}{dE} \\left( \\frac{S'(E)}{S(E)} \\right) - \\frac{d}{dE} \\left( \\frac{1}{k_{\\mathrm{B}} T} \\right) + \\frac{d}{dE} \\left( \\frac{1}{2}\\sqrt{E_{\\mathrm{G}}}E^{-3/2} \\right) = \\frac{S''(E)S(E) - (S'(E))^2}{S(E)^2} - \\frac{3}{4} \\sqrt{E_{\\mathrm{G}}} E^{-5/2}\n$$\n为了计算这些导数，我们需要天体物理 $S$ 因子 $S(E)$ 的导数，其模型为：\n$$\nS(E) = S_0 \\left(1 + a E\\right)\\left(1 + A\\,L(E)\\right)\n$$\n为了计算方便，展开此式会很有帮助：\n$$\nS(E) = S_0 (1 + aE + A L(E) + aA E L(E))\n$$\n一阶和二阶导数 $S'(E)$ 和 $S''(E)$ 分别为：\n$$\nS'(E) = S_0 \\left[ a + a A L(E) + A(1 + aE)L'(E) \\right]\n$$\n$$\nS''(E) = S_0 \\left[ 2a A L'(E) + A(1+aE)L''(E) \\right]\n$$\n这些导数依赖于类洛伦兹函数 $L(E)$ 及其导数。设 $W = \\Gamma/2$。那么：\n$$\nL(E) = \\frac{W^2}{(E - E_r)^2 + W^2}\n$$\n$$\nL'(E) = \\frac{-2W^2(E - E_r)}{((E - E_r)^2 + W^2)^2}\n$$\n$$\nL''(E) = \\frac{2W^2 \\left( 3(E - E_r)^2 - W^2 \\right)}{((E - E_r)^2 + W^2)^3}\n$$\n\n根据问题中的规定，数值算法被设计为具有稳健性。\n1.  **初始猜测**：迭代的主要初始猜测是通过在忽略 S 因子贡献（即假设 $S(E)$ 为常数）的情况下找到 $\\phi(E)$ 的最大值来推导的。这平衡了麦克斯韦-玻尔兹曼分布的指数衰减和库仑势垒隧穿概率的指数上升。令 $\\frac{d}{dE}(-\\frac{E}{k_{\\mathrm{B}}T} - \\sqrt{\\frac{E_G}{E}}) = 0$ 可得出经典的伽莫夫峰能量：\n    $$\n    E_{\\text{guess}} = \\left( \\frac{(k_{\\mathrm{B}}T)^2 E_{\\mathrm{G}}}{4} \\right)^{1/3}\n    $$\n2.  **牛顿-拉夫逊方法**：求解器的核心是迭代方案：\n    $$\n    E_{k+1} = E_k - \\frac{\\phi'(E_k)}{\\phi''(E_k)}\n    $$\n3.  **稳健性增强**：\n    -   **曲率检查**：在每一步，我们都验证 $\\phi''(E_k)  0$。如果曲率非负，则该点不是局部最大值，牛顿-拉夫逊步长将无效。在这种情况下，算法必须进行调整。\n    -   **回溯线搜索**：为保证收敛和目标函数的单调递增，我们实现了一个回溯线搜索。将完整的牛顿-拉夫逊步长 $\\Delta E = -\\phi'/\\phi''$ 乘以一个因子 $\\lambda \\in (0, 1]$。我们从 $\\lambda=1$ 开始，并相继将其减半，直到满足条件 $E_{k+1} = E_k + \\lambda \\Delta E  0$ 和 $\\phi(E_{k+1})  \\phi(E_k)$。这可以防止超调，并确保解保持在物理定义域 $E0$ 内。\n    -   **处理共振**：共振的存在可以在共振能量 $E_r$ 附近产生 $\\phi(E)$ 的第二个局部最大值。仅从 $E_{\\text{guess}}$ 开始的搜索可能会收敛到非共振峰，即使共振峰是全局主导的。为了找到全局最大值，我们执行两次独立的搜索：一次从 $E_{\\text{guess}}$ 开始，另一次从共振能量 $E_r$ 开始（如果存在共振，即 $A0$）。然后，我们比较在找到的任何有效最大值点处的 $\\phi(E)$ 值，并选择对应最高值的能量。\n    -   **回退机制**：问题要求如果牛顿-拉夫逊方法失败，则回退到对 $\\phi'(E)$ 的有界求根搜索。虽然上述稳健的实现旨在不失败，但如果未找到最大值（例如，由于线搜索失败或持续的坏曲率），可以使用像 `scipy.optimize.brentq` 这样的求根算法在宽能量区间内寻找 $\\phi'(E)$ 的根。然后必须通过曲率测试 $\\phi''(E_0)  0$ 来验证所得的根确实是最大值点。然而，该策略是次于主要的双重搜索牛顿-拉夫逊方法的。提供的解决方案优先使用 N-R 方法，因为它收敛更快且能有效利用曲率信息。\n    -   **数值稳定性**：所有计算均以浮点算术执行。代码编写时需防止除以零，并通过确保 $E$ 的下界远离零来处理 $E^{-3/2}$ 和 $E^{-5/2}$ 项。使用一个小的最小能量值 `E_MIN`。\n\n该实现将这些原理封装到一个类结构中，该结构首先计算给定反应所需的物理常数（例如，约化质量 $\\mu$ 和伽莫夫能量 $E_G$），然后应用双重搜索最大化算法来定位主导的伽莫夫峰能量 $E_0$。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\n# Per the problem specification, no other libraries are used.\n\ndef solve():\n    \"\"\"\n    Main solver function to compute Gamow peak energies for the given test cases.\n    \"\"\"\n    \n    # Constants as specified in the problem\n    C_LIGHT = 2.99792458e8  # m/s (not used as masses are in keV/c^2)\n    K_B = 8.617333262145e-8  # keV/K\n    ALPHA = 7.2973525693e-3  # Fine-structure constant\n    \n    # Small number to prevent division by zero and keep energy positive\n    E_MIN = 1e-9\n\n    class GamowPeakFinder:\n        \"\"\"\n        A class to find the Gamow peak energy E0 for a given set of nuclear\n        reaction parameters.\n        \"\"\"\n        def __init__(self, Z1, Z2, m1, m2, T, S0, a, A, Er, Gamma):\n            self.Z1 = Z1\n            self.Z2 = Z2\n            self.m1 = m1  # in keV/c^2\n            self.m2 = m2  # in keV/c^2\n            self.T = T    # in K\n            self.S0 = S0\n            self.a = a\n            self.A = A\n            self.Er = Er\n            self.Gamma = Gamma\n            \n            # Derived constants\n            self.W = self.Gamma / 2.0\n            \n            # Calculate reduced mass energy (mu * c^2) in keV\n            # m1 and m2 are given in keV/c^2, so they are effectively M1 and M2\n            if (self.m1 + self.m2) == 0:\n                self.mu_c2 = 0\n            else:\n                self.mu_c2 = (self.m1 * self.m2) / (self.m1 + self.m2)\n            \n            # Calculate Gamow Energy in keV\n            self.Eg = 2.0 * (np.pi**2) * ((self.Z1 * self.Z2 * ALPHA)**2) * self.mu_c2\n            \n            self.kBT = K_B * self.T\n\n        # --- Lorentzian and its derivatives ---\n        def _L(self, E):\n            if self.W == 0: return 0.0\n            denom = (E - self.Er)**2 + self.W**2\n            return self.W**2 / denom if denom > 0 else 0.0\n\n        def _L_prime(self, E):\n            if self.W == 0: return 0.0\n            denom = (E - self.Er)**2 + self.W**2\n            return -2.0 * self.W**2 * (E - self.Er) / (denom**2) if denom > 0 else 0.0\n\n        def _L_double_prime(self, E):\n            if self.W == 0: return 0.0\n            denom = (E - self.Er)**2 + self.W**2\n            num = 2.0 * self.W**2 * (3.0 * (E - self.Er)**2 - self.W**2)\n            return num / (denom**3) if denom > 0 else 0.0\n\n        # --- S-factor and its derivatives ---\n        def _S(self, E):\n            return self.S0 * (1.0 + self.a * E) * (1.0 + self.A * self._L(E))\n\n        def _S_prime(self, E):\n            L_val = self._L(E)\n            L_p_val = self._L_prime(E)\n            term1 = self.a\n            term2 = self.a * self.A * L_val\n            term3 = self.A * (1.0 + self.a * E) * L_p_val\n            return self.S0 * (term1 + term2 + term3)\n\n        def _S_double_prime(self, E):\n            L_p_val = self._L_prime(E)\n            L_pp_val = self._L_double_prime(E)\n            term1 = 2.0 * self.a * self.A * L_p_val\n            term2 = self.A * (1.0 + self.a * E) * L_pp_val\n            return self.S0 * (term1 + term2)\n        \n        # --- Objective function phi and its derivatives ---\n        def phi(self, E):\n            E = max(E, E_MIN)\n            S_val = self._S(E)\n            if S_val = 0 or self.Eg  0: return -np.inf\n            log_S = np.log(S_val)\n            boltzmann = E / self.kBT\n            gamow = np.sqrt(self.Eg / E)\n            return log_S - boltzmann - gamow\n\n        def phi_prime(self, E):\n            E = max(E, E_MIN)\n            S_val = self._S(E)\n            Sp_val = self._S_prime(E)\n            if S_val = 0 or self.kBT = 0 or self.Eg  0: return 0.0\n            d_log_S = Sp_val / S_val\n            d_boltzmann = 1.0 / self.kBT\n            d_gamow = -0.5 * np.sqrt(self.Eg) * E**(-1.5)\n            return d_log_S - d_boltzmann - d_gamow\n\n        def phi_double_prime(self, E):\n            E = max(E, E_MIN)\n            S_val = self._S(E)\n            Sp_val = self._S_prime(E)\n            Spp_val = self._S_double_prime(E)\n            \n            if S_val = 0 or self.Eg  0: return -np.inf\n            d2_log_S = (Spp_val * S_val - Sp_val**2) / S_val**2\n            d2_gamow = 0.75 * np.sqrt(self.Eg) * E**(-2.5)\n            return d2_log_S - d2_gamow\n\n        def _get_initial_guess(self):\n            if self.kBT = 0 or self.Eg = 0: return 1.0\n            return (self.Eg * (self.kBT)**2 / 4.0)**(1.0/3.0)\n\n        def _newton_raphson(self, E_guess, max_iter=100, tol=1e-8):\n            E = E_guess\n            for _ in range(max_iter):\n                phi_p = self.phi_prime(E)\n                phi_pp = self.phi_double_prime(E)\n\n                if phi_pp >= 0:\n                    return None # Invalid curvature for a maximum\n\n                delta_E = -phi_p / phi_pp\n\n                # Backtracking line search\n                lambda_k = 1.0\n                phi_E = self.phi(E)\n                for _ in range(10): # Max 10 backtracking steps\n                    E_new = E + lambda_k * delta_E\n                    if E_new > E_MIN and self.phi(E_new) > phi_E:\n                        break\n                    lambda_k /= 2.0\n                else:\n                    return None # Line search failed\n\n                E = E_new\n                \n                if abs(lambda_k * delta_E)  tol:\n                    # Final curvature check\n                    if self.phi_double_prime(E) >= 0:\n                        return None\n                    return E\n            return None # Did not converge\n\n        def find_peak(self):\n            candidates = []\n            \n            # --- Search from classical Gamow peak guess ---\n            E_c_guess = self._get_initial_guess()\n            if E_c_guess > E_MIN:\n                peak1 = self._newton_raphson(E_c_guess)\n                if peak1 is not None:\n                    candidates.append(peak1)\n\n            # --- Search from resonance energy, if present ---\n            if self.A > 0 and self.Er > E_MIN:\n                peak2 = self._newton_raphson(self.Er)\n                if peak2 is not None:\n                    candidates.append(peak2)\n            \n            if not candidates:\n                # Fallback to bracketed search for phi_prime root if N-R fails\n                # This could happen in complex cases.\n                # Find a bracket [a,b] where phi'(a) and phi'(b) have opposite signs\n                # phi'(E->0) -> +inf, phi'(E->inf) -> -1/kBT\n                try:\n                    # Define a search range for the bracket\n                    low_E = E_c_guess * 0.1\n                    high_E = E_c_guess * 10\n                    if self.A > 0 and self.Er > 0:\n                        high_E = max(high_E, self.Er * 2)\n\n                    # Brent's method to find a root of phi_prime\n                    fallback_peak = brentq(self.phi_prime, low_E, high_E, xtol=1e-9, maxiter=100)\n                    # Check if it's a maximum\n                    if self.phi_double_prime(fallback_peak)  0:\n                        candidates.append(fallback_peak)\n\n                except ValueError:\n                    # Brentq fails if no bracket is found or other issues\n                    return float('nan') # Could not find a peak\n            \n            if not candidates:\n                return float('nan') # No peak found\n\n            # Determine the best peak (global maximum among candidates)\n            best_E = -1\n            max_phi = -np.inf\n            for E_cand in set(candidates): # Use set to remove duplicate peaks\n                phi_val = self.phi(E_cand)\n                if phi_val > max_phi:\n                    max_phi = phi_val\n                    best_E = E_cand\n\n            return best_E\n\n    test_cases = [\n        # (Z1, Z2, m1, m2, T, S0, a, A, Er, Gamma)\n        (1, 1, 938272.0813, 938272.0813, 1.5e7, 1.0, 0.0, 0.0, 0.0, 1.0),\n        (1, 6, 938272.0813, 11177412.0, 2.0e8, 1.0, 1.0e-4, 1.0, 450.0, 30.0),\n        (1, 6, 938272.0813, 11177412.0, 2.0e8, 1.0, 2.0e-4, 5.0, 800.0, 20.0),\n        (1, 1, 938272.0813, 938272.0813, 1.0e6, 1.0, 0.0, 2.0, 5.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        finder = GamowPeakFinder(*case)\n        result = finder.find_peak()\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3600134"}, {"introduction": "确定伽莫夫峰的位置只是计算反应率的第一步，要获得总反应率，我们必须对伽莫夫窗口内的积分进行求值。本练习聚焦于此过程中的一个关键数值挑战：如何在有限精度的浮点运算中处理具有巨大动态范围的被积函数。您将学习并应用“对数-求和-指数”（log-sum-exp）技巧，这是一种避免数值下溢和上溢、确保积分结果稳定可靠的重要计算方法。[@problem_id:3600092]", "problem": "考虑与伽莫夫峰相关的热核反应率被积函数，它由能量 $E$ 和温度 $T$ 的无量纲函数 $I(E,T) = \\exp\\!\\big(-g(E,T)\\big)$ 定义，其中 $g(E,T)$ 是两个经过充分检验的贡献之和：来自经典统计力学的麦克斯韦-玻尔兹曼因子和从半经典 Wentzel–Kramers–Brillouin (WKB) 近似中获得的量子隧穿伽莫夫因子。具体而言，令 $g(E,T) = \\dfrac{E}{k_{\\mathrm{B}} T} + \\sqrt{\\dfrac{E_{\\mathrm{G}}}{E}}$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$E_{\\mathrm{G}}$ 是伽莫夫能量。伽莫夫能量由 $E_{\\mathrm{G}} = 2 \\,\\mu c^{2} \\,(\\pi \\alpha Z_{1} Z_{2})^{2}$ 给出，其中 $\\mu$ 是两个反应核的约化质量，$c$ 是光速，$\\alpha$ 是精细结构常数，$Z_{1}$ 和 $Z_{2}$ 是原子核的整数电荷。使用 $\\alpha \\approx 1/137.035999$ 并以原子质量单位表示 $\\mu$，以便通过质能等价关系使用 $1 \\,\\mathrm{amu} \\approx 931.49410242 \\,\\mathrm{MeV}$ 来计算 $\\mu c^{2}$。\n\n定义无量纲天体物理 $S$ 因子 $S(E)$ 为常数 $S(E) = 1$，因此依赖于温度的积分\n$$\n\\mathcal{I}(T) = \\int_{0}^{\\infty} S(E)\\,\\exp\\!\\left(-\\frac{E}{k_{\\mathrm{B}} T} - \\sqrt{\\frac{E_{\\mathrm{G}}}{E}}\\right)\\, \\mathrm{d}E\n= \\int_{0}^{\\infty} \\exp\\!\\left(-\\frac{E}{k_{\\mathrm{B}} T} - \\sqrt{\\frac{E_{\\mathrm{G}}}{E}}\\right)\\, \\mathrm{d}E\n$$\n具有能量的单位。积分 $\\mathcal{I}(T)$ 由伽莫夫峰区域主导，在数值计算时必须注意在 $T$ 较小或 $Z_{1}Z_{2}$ 较大时可能出现的浮点下溢和上溢问题。\n\n你的任务是：\n1. 从上述基本定义出发，推导出一个数值稳定的变换，该变换允许使用浮点运算在固定网格 $\\{E_{i}\\}$ 上通过求积法计算 $\\mathcal{I}(T)$。该变换在计算指数级小的项之和时应避免下溢和上溢。证明如果用带有求积权重 $w_{i}  0$ 的黎曼和 $\\mathcal{I}(T) \\approx \\sum_{i} w_{i}\\,\\exp\\!\\big(-g(E_{i},T)\\big)$ 来近似积分，那么可以使用对数-求和-指数变换来稳定地计算 $\\log \\mathcal{I}(T)$，从而计算出 $\\mathcal{I}(T)$ 本身。\n2. 设计一个简单的算法来选择能量网格，该网格能够解析伽莫夫峰，而无需事先知道峰值的确切位置。你的设计必须有原则：基于对 $g(E,T)$ 及其导数的分析，并确保网格集中在峰值区域周围，同时覆盖其重要的尾部。不要在没有第一性原理依据的情况下使用临时或手动调整的常数。\n3. 将该算法实现为一个完整、可运行的程序，该程序使用朴素求积（直接求和）和对数-求和-指数稳定化求和两种方法计算 $\\mathcal{I}(T)$，并报告计算值以及朴素求积在浮点运算中是否下溢为零。\n\n物理单位和常数：\n- 使用的单位：$E$ 为 $\\mathrm{keV}$，$T$ 为 $\\mathrm{K}$，$k_{\\mathrm{B}}$ 为 $\\mathrm{keV}/\\mathrm{K}$（其中 $k_{\\mathrm{B}} \\approx 8.617333262\\times 10^{-8} \\,\\mathrm{keV}/\\mathrm{K}$），$E_{\\mathrm{G}}$ 为 $\\mathrm{keV}$。\n- 最终积分值 $\\mathcal{I}(T)$ 以 $\\mathrm{keV}$ 表示。\n\n测试套件：\n对以下参数集 $(Z_{1}, Z_{2}, \\mu, T)$ 进行程序评估，其中 $\\mu$ 的单位是原子质量单位，$T$ 的单位是开尔文：\n- 案例 A（理想情况，轻原子核，恒星核心）：$(1, 1, 0.5, 1.5\\times 10^{7})$。\n- 案例 B（较重原子核，中等温度）：$(6, 6, 6.0, 5.0\\times 10^{8})$。\n- 案例 C（边界情况，高势垒，低温）：$(8, 8, 8.0, 5.0\\times 10^{6})$。\n- 案例 D（高温，轻原子核）：$(2, 2, 1.0, 1.0\\times 10^{9})$。\n\n最终输出格式：\n你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每个测试用例，输出一个包含三个条目的列表：以 $\\mathrm{keV}$ 为单位的稳定化积分值（浮点数），以 $\\mathrm{keV}$ 为单位的朴素积分值（浮点数），以及一个指示朴素计算是否下溢为零的布尔值。因此，最终输出必须是列表的列表，例如 $[[x_{A},y_{A},b_{A}], [x_{B},y_{B},b_{B}], [x_{C},y_{C},b_{C}], [x_{D},y_{D},b_{D}]]$，其中所有的 $x$ 和 $y$ 都以 $\\mathrm{keV}$ 为单位。", "solution": "该问题要求对热核反应率积分进行数值计算，并特别关注数值稳定性以及用于求积的网格生成的有原则方法。该问题科学基础扎实、自成体系且定义明确。所呈现的物理模型涉及由麦克斯韦-玻尔兹曼分布和量子隧穿概率的乘积产生的伽莫夫峰，这是核天体物理学中的一个标准和基本概念。所有必要的参数和常数都已提供。因此，该问题是有效的，下面提供了解决方案。\n\n解决方案分为三个部分，对应于问题陈述中列出的任务。\n\n### 1. 数值稳定变换的推导\n\n待计算的积分为：\n$$\n\\mathcal{I}(T) = \\int_{0}^{\\infty} \\exp\\big(-g(E,T)\\big)\\, \\mathrm{d}E\n$$\n其中指数为 $g(E,T) = \\frac{E}{k_{\\mathrm{B}} T} + \\sqrt{\\frac{E_{\\mathrm{G}}}{E}}$。对于某些物理参数（$Z_{1}, Z_{2}, T$），函数 $g(E,T)$ 可以达到很大的正值，导致被积函数 $\\exp(-g(E,T))$ 变得比可表示的最小正浮点数还要小（下溢）。\n\n数值求积将积分近似为离散能量网格 $\\{E_i\\}_{i=0}^N$ 上的加权和：\n$$\n\\mathcal{I}(T) \\approx \\sum_{i=0}^{N} w_i \\exp\\big(-g(E_i,T)\\big)\n$$\n其中 $w_i  0$ 是求积权重。例如，在间距为 $\\Delta E$ 的均匀网格上使用梯形法则，权重为 $w_0 = w_N = \\Delta E/2$ 以及当 $0  i  N$ 时 $w_i = \\Delta E$。\n\n对此求和的朴素计算涉及计算每一项 $w_i \\exp(-g(E_i,T))$ 并将它们相加。如果所有 $\\exp(-g(E_i,T))$ 项都下溢为 $0$，则总和将被错误地计算为 $0$。在低温 $T$ 或高核电荷 $Z_1, Z_2$ 的情况下，即 $g(E,T)$ 的最小值很大的情况下，这种情况尤其可能发生。\n\n为避免这种情况，我们采用一种基于对数-求和-指数恒等式的稳定化技术。目标是首先计算 $\\log \\mathcal{I}(T)$，并以避免中间过程下溢的方式进行。令 $g_{\\min}$ 为 $g(E,T)$ 在网格的相关能量范围内的最小值：\n$$\ng_{\\min} = \\min_{i} \\{g(E_i, T)\\}\n$$\n我们可以从和式中提出公因子 $\\exp(-g_{\\min})$：\n$$\n\\mathcal{I}(T) \\approx \\sum_{i=0}^{N} w_i \\exp(-g_{\\min}) \\exp\\big(-(g(E_i,T) - g_{\\min})\\big)\n$$\n$$\n\\mathcal{I}(T) \\approx \\exp(-g_{\\min}) \\left[ \\sum_{i=0}^{N} w_i \\exp\\big(-(g(E_i,T) - g_{\\min})\\big) \\right]\n$$\n对两边取自然对数，得到：\n$$\n\\log \\mathcal{I}(T) \\approx -g_{\\min} + \\log\\left( \\sum_{i=0}^{N} w_i \\exp\\big(-(g(E_i,T) - g_{\\min})\\big) \\right)\n$$\n这种形式是数值稳定的。指数的宗量 $-(g(E_i,T) - g_{\\min})$ 始终小于或等于 $0$。对于 $g(E_i,T)$ 取最小值的项，其指数为 $0$，得到 $\\exp(0)=1$。所有其他项都将更小。因此，对数内的求和是在对量级合理（$w_i$ 量级）的数进行求和，这可以防止上溢并最大限度地减少因单个项下溢而造成的精度损失。和本身将是一个正数，可以安全地传递给对数函数。\n\n最后，通过对结果取指数来恢复积分值：\n$$\n\\mathcal{I}(T) = \\exp\\big(\\log \\mathcal{I}(T)\\big)\n$$\n如果 $\\log \\mathcal{I}(T)$ 是一个非常大的负数，这最后的指数运算仍可能导致结果为 $0$，但这现在将正确地反映出积分的真实值小于机器精度，而不是求和过程中过早下溢的人为结果。\n\n### 2. 能量网格的有原则设计\n\n被积函数由伽莫夫峰主导，该峰出现在使指数 $g(E,T)$ 最小化的能量 $E_0$ 处。一个有原则的网格必须以 $E_0$ 为中心，并且足够宽以覆盖峰的重要部分。我们通过将 $g(E,T)$ 对 $E$ 的导数设为零来找到 $E_0$：\n$$\n\\frac{\\mathrm{d}g}{\\mathrm{d}E} = \\frac{\\mathrm{d}}{\\mathrm{d}E} \\left( \\frac{E}{k_{\\mathrm{B}} T} + E_{\\mathrm{G}}^{1/2} E^{-1/2} \\right) = \\frac{1}{k_{\\mathrm{B}} T} - \\frac{1}{2} E_{\\mathrm{G}}^{1/2} E^{-3/2} = 0\n$$\n解出峰值能量 $E_0$：\n$$\nE_0^{3/2} = \\frac{k_{\\mathrm{B}} T \\sqrt{E_{\\mathrm{G}}}}{2} \\implies E_0 = \\left( \\frac{(k_{\\mathrm{B}} T)^2 E_{\\mathrm{G}}}{4} \\right)^{1/3}\n$$\n峰的宽度可以通过在 $E_0$ 附近对 $g(E,T)$ 进行二阶泰勒展开来估计，这会用一个高斯函数来近似该峰：\n$$\ng(E,T) \\approx g(E_0,T) + \\frac{1}{2} g''(E_0,T) (E-E_0)^2\n$$\n于是被积函数近似为 $\\exp(-g(E_0,T)) \\exp\\left(-\\frac{(E-E_0)^2}{2\\sigma_E^2}\\right)$，其中标准差 $\\sigma_E$ 由 $\\sigma_E = \\left(g''(E_0,T)\\right)^{-1/2}$ 给出。\n\n二阶导数为：\n$$\ng''(E,T) = \\frac{\\mathrm{d}}{\\mathrm{d}E} \\left( \\frac{1}{k_{\\mathrm{B}} T} - \\frac{1}{2} E_{\\mathrm{G}}^{1/2} E^{-3/2} \\right) = \\frac{3}{4} E_{\\mathrm{G}}^{1/2} E^{-5/2}\n$$\n在 $E=E_0$ 处求值并代入 $\\sqrt{E_{\\mathrm{G}}} = 2 E_0^{3/2} / (k_{\\mathrm{B}} T)$：\n$$\ng''(E_0,T) = \\frac{3}{4} \\left(\\frac{2 E_0^{3/2}}{k_{\\mathrm{B}} T}\\right) E_0^{-5/2} = \\frac{3}{2 E_0 k_{\\mathrm{B}} T}\n$$\n这给出了峰的一个特征宽度：\n$$\n\\sigma_E = \\sqrt{\\frac{2 E_0 k_{\\mathrm{B}} T}{3}}\n$$\n因此，一个有原则的网格算法如下：\n1.  根据给定的物理参数 $Z_1, Z_2, \\mu, T$ 计算 $E_0$ 和 $\\sigma_E$。这确保了网格能适应具体问题，而不依赖于临时的范围。\n2.  将积分区间定义为 $[E_{\\min}, E_{\\max}]$，以 $E_0$ 为中心，并向两边延伸几个宽度（$\\sigma_E$）。$[E_0 - N_{\\sigma} \\sigma_E, E_0 + N_{\\sigma} \\sigma_E]$ 的范围是合适的。选择 $N_{\\sigma}=20$ 可确保峰的尾部（被积函数在此处变得可忽略不计）被包含在内。下限必须被截断为一个小的正值，以避免 $E=0$ 处的奇点。\n3.  将此区间离散化为大量的点 $N_{\\text{points}}$，以确保梯形法则是准确的。$N_{\\text{points}}=20000$ 为遇到的尖峰提供了足够的分辨率。这是一个数值精度参数，而不是一个任意的物理常数。\n\n### 3. 算法实现\n\n该算法使用 Python 的 `numpy` 库实现。\n1.  **常数**：使用指定的值和单位定义物理常数。\n2.  **伽莫夫能量计算**：对于每个测试用例 $(Z_1, Z_2, \\mu, T)$，计算以 $\\mathrm{keV}$ 为单位的伽莫夫能量 $E_{\\mathrm{G}}$。\n3.  **网格生成**：遵循第 2 部分的有原则设计来构建能量网格。计算 $E_0$ 和 $\\sigma_E$，并在范围 $[\\max(0.1, E_0 - 20\\sigma_E), E_0 + 20\\sigma_E]$ 上创建一个包含 $20000$ 个点的均匀网格 `E_grid`。能量单位为 $\\mathrm{keV}$。\n4.  **指数计算**：对 `E_grid` 上的每个点计算指数 $g(E,T)$。\n5.  **朴素积分**：直接计算被积函数 $\\exp(-g(E,T))$，并通过 `numpy.trapz` 使用梯形法则进行积分。如果此结果下溢为 $0.0$，则设置一个布尔标志。\n6.  **稳定化积分**：实现第 1 部分中的稳定化对数-求和-指数方法。\n    -   找到指数数组的最小值 $g_{\\min}$。\n    -   计算稳定化的被加数 $\\exp(-(g(E,T) - g_{\\min}))$。\n    -   使用 `numpy.trapz` 对这个数值稳定的数组进行积分。\n    -   对该中间积分取对数，并加上 $-g_{\\min}$ 以获得最终的 $\\log\\mathcal{I}(T)$。\n    -   通过 `numpy.exp()` 恢复结果 $\\mathcal{I}(T)$。\n7.  **输出**：对于每个测试用例，生成一个包含稳定化积分值、朴素积分值和下溢标志的列表，并以要求的格式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the thermonuclear reaction-rate integral for a series of test cases\n    using both a naive and a numerically stabilized method.\n    \"\"\"\n    # Physical and mathematical constants\n    FINE_STRUCTURE_CONST = 1.0 / 137.035999\n    AMU_TO_MEV = 931.49410242\n    MEV_TO_KEV = 1000.0\n    AMU_C2_KEV = AMU_TO_MEV * MEV_TO_KEV  # Mass-energy equivalence for 1 amu in keV\n    KB_KEV_K = 8.617333262e-8  # Boltzmann constant in keV/K\n\n    # Define the test cases as per the problem statement.\n    # Format: (Z1, Z2, mu_amu, T_K)\n    test_cases = [\n        (1, 1, 0.5, 1.5e7),\n        (6, 6, 6.0, 5.0e8),\n        (8, 8, 8.0, 5.0e6),\n        (2, 2, 1.0, 1.0e9),\n    ]\n\n    results = []\n\n    def compute_integral(Z1, Z2, mu_amu, T_K):\n        \"\"\"\n        Calculates the integral I(T) for a given set of physical parameters.\n\n        Args:\n            Z1 (int): Charge number of the first nucleus.\n            Z2 (int): Charge number of the second nucleus.\n            mu_amu (float): Reduced mass in atomic mass units (amu).\n            T_K (float): Temperature in Kelvin (K).\n\n        Returns:\n            tuple: A tuple containing:\n                - integral_stable (float): The integral value from the stabilized method.\n                - integral_naive (float): The integral value from the naive method.\n                - underflowed (bool): True if the naive method resulted in a zero value.\n        \"\"\"\n        # --- 1. Calculate parameters from givens ---\n        mu_c2_kev = mu_amu * AMU_C2_KEV\n        # Gamow Energy in keV\n        E_G_kev = 2.0 * mu_c2_kev * (np.pi * FINE_STRUCTURE_CONST * Z1 * Z2)**2\n        # Thermal energy in keV\n        k_B_T_kev = KB_KEV_K * T_K\n\n        # --- 2. Principled grid generation ---\n        # Peak energy (E0) in keV\n        E0 = ((k_B_T_kev**2 * E_G_kev) / 4.0)**(1.0 / 3.0)\n        \n        # Characteristic peak width (sigma_E) in keV\n        # g''(E0) = 3 / (2 * E0 * k_B_T)\n        # sigma_E = 1 / sqrt(g''(E0))\n        sigma_E = np.sqrt((2.0 * E0 * k_B_T_kev) / 3.0)\n\n        # Set up grid based on E0 and sigma_E\n        # N_sigma controls the width of integration range in multiples of sigma_E.\n        # This value is chosen to be large to ensure the full peak is captured.\n        N_sigma = 20.0\n        # N_points determines the resolution of the grid for numerical accuracy.\n        N_points = 20000\n\n        E_min = max(0.1, E0 - N_sigma * sigma_E)  # Clip to small positive energy\n        E_max = E0 + N_sigma * sigma_E\n        \n        E_grid = np.linspace(E_min, E_max, N_points)\n        \n        # --- 3. Evaluate the exponent on the grid ---\n        # The exponent g(E,T) = E/(k_B*T) + sqrt(E_G/E)\n        with np.errstate(divide='ignore'): # E=0 is avoided by E_min\n            g_vals = (E_grid / k_B_T_kev) + np.sqrt(E_G_kev / E_grid)\n\n        # --- 4. Naive quadrature ---\n        # This can underflow if g_vals are large.\n        integrand_naive = np.exp(-g_vals)\n        integral_naive = np.trapz(integrand_naive, E_grid)\n        \n        # Check if the naive sum underflowed to exactly zero\n        underflowed = (integral_naive == 0.0)\n\n        # --- 5. Stabilized (log-sum-exp) quadrature ---\n        g_min = np.min(g_vals)\n        \n        # This integrand is well-behaved: values are between exp(-C) and 1.\n        integrand_stable = np.exp(-(g_vals - g_min))\n        \n        # The integral of the stabilized integrand\n        sum_part = np.trapz(integrand_stable, E_grid)\n        \n        # Log of the integral, calculated stably\n        # Handle case where sum_part is zero (extreme underflow)\n        if sum_part > 0:\n            log_integral = -g_min + np.log(sum_part)\n            integral_stable = np.exp(log_integral)\n        else: # Should not happen unless even the stabilized form underflows\n            integral_stable = 0.0\n\n        return integral_stable, integral_naive, underflowed\n\n    for case in test_cases:\n        Z1, Z2, mu, T = case\n        stable_val, naive_val, underflow_flag = compute_integral(Z1, Z2, mu, T)\n        results.append([stable_val, naive_val, underflow_flag])\n\n    # Final print statement in the exact required format.\n    # Manually construct the list-of-lists string representation.\n    # Using str() for bools gives 'True'/'False' which is valid Python syntax.\n    result_strings = []\n    for res in results:\n        # repr() is used for floats to maintain precision in the output string\n        result_strings.append(f\"[{repr(res[0])}, {repr(res[1])}, {str(res[2])}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3600092"}]}