{"hands_on_practices": [{"introduction": "隐式方法是求解刚性反应网络的关键工具，但其内部工作原理可能显得晦涩难懂。本练习旨在揭开其神秘面纱，引导您手动完成二阶向后差分公式（BDF2）的单个时间步计算。通过为一个简单的线性系统手动构建残差和雅可比矩阵，并执行一次牛顿更新，您将对这些强大的求解器如何随时间推进解获得具体的理解。这项动手计算是在编写功能完备的隐式求解器之前至关重要的第一步 [@problem_id:3576963]。", "problem": "考虑一个双物种核反应子网络，其中物种 $Y_{P}$ 和 $Y_{D}$ 的丰度（每重子的数量分数，无量纲）通过一个转换和衰变方案演化。母物种 $Y_{P}$ 以恒定速率 $k$ 转换为子物种 $Y_{D}$，并独立地以恒定速率 $\\lambda_{P}$ 衰变到一个汇。子物种 $Y_{D}$ 独立地以恒定速率 $\\lambda_{D}$ 衰变到一个汇。其确定性演化遵循常微分方程（ODE）组\n$$\n\\frac{d}{dt}\\begin{pmatrix}Y_{P} \\\\ Y_{D}\\end{pmatrix} \\;=\\; \\begin{pmatrix} -(\\lambda_{P}+k)  0 \\\\ k  -\\lambda_{D} \\end{pmatrix}\\begin{pmatrix}Y_{P} \\\\ Y_{D}\\end{pmatrix},\n$$\n这是一个刚性线性反应网络。取速率常数为 $k=900\\,\\mathrm{s}^{-1}$，$\\lambda_{P}=40\\,\\mathrm{s}^{-1}$ 和 $\\lambda_{D}=5\\,\\mathrm{s}^{-1}$。\n\n假设时间步长是均匀的 $\\Delta t = 1.0\\times 10^{-3}\\,\\mathrm{s}$，在 $t_{n-1}$ 和 $t_{n}$ 时刻已计算出的两个状态由下式给出\n$$\n\\mathbf{Y}_{n-1}=\\begin{pmatrix}0.500 \\\\ 0.300\\end{pmatrix}, \\qquad \\mathbf{Y}_{n}=\\begin{pmatrix}0.195 \\\\ 0.700\\end{pmatrix}.\n$$\n\n使用全隐式的二阶向后差分公式（BDF2），将计算向前推进一个步长至 $t_{n+1}$，步骤如下：\n- 从该方法的定义出发，该方法是通过在 $t_{n+1}$ 处评估的 $\\mathbf{Y}_{n-1}$、$\\mathbf{Y}_{n}$ 和 $\\mathbf{Y}$ 的二次插值多项式，构造出对 $t_{n+1}$ 处时间导数的两步隐式线性多步近似。\n- 在 $t_{n+1}$ 处构建非线性离散残差 $\\mathbf{R}(\\mathbf{Y})$ 及其关于 $\\mathbf{Y}$ 的雅可比矩阵。\n- 将所得系统线性化，并通过一次牛顿迭代求解，初始猜测为 $\\mathbf{Y}^{(0)}=\\mathbf{Y}_{n}$，从而得到更新后的 $\\mathbf{Y}_{n+1}$。\n\n对给定的数据明确执行这些步骤，并报告丰度向量 $\\mathbf{Y}_{n+1}=(Y_{P,n+1},\\,Y_{D,n+1})$，结果四舍五入到六位有效数字。最终答案以无量纲丰度表示。", "solution": "控制系统是线性和刚性的：\n$$\n\\frac{d}{dt}\\mathbf{Y} \\;=\\; \\mathbf{f}(\\mathbf{Y}) \\;=\\; \\mathbf{M}\\,\\mathbf{Y}, \\qquad \\mathbf{M} \\;=\\; \\begin{pmatrix}-(\\lambda_{P}+k)  0 \\\\ k  -\\lambda_{D}\\end{pmatrix}.\n$$\n当 $k=900\\,\\mathrm{s}^{-1}$，$\\lambda_{P}=40\\,\\mathrm{s}^{-1}$ 和 $\\lambda_{D}=5\\,\\mathrm{s}^{-1}$ 时，我们有\n$$\n\\mathbf{M} \\;=\\; \\begin{pmatrix}-940  0 \\\\ 900  -5\\end{pmatrix}.\n$$\n\n我们使用二阶向后差分公式（BDF2），这是一种两步隐式线性多步法。为了从第一性原理推导其在 $t_{n+1}$ 处的离散时间导数，我们将 $[t_{n-1},t_{n+1}]$ 上的 $\\mathbf{Y}(t)$ 用一个唯一的二次多项式 $\\mathbf{p}(t)$ 来近似，该多项式在 $t_{n-1}=t_{n}-\\Delta t$ 处插值 $\\mathbf{Y}_{n-1}$，在 $t_{n}$ 处插值 $\\mathbf{Y}_{n}$，在 $t_{n+1}=t_{n}+\\Delta t$ 处插值一个待定的 $\\mathbf{Y}$。拉格朗日插值多项式在 $t_{n+1}$ 处的导数给出了时间导数的标准BDF2向后差分：\n$$\n\\left.\\frac{d\\mathbf{Y}}{dt}\\right|_{t_{n+1}} \\;\\approx\\; \\frac{3\\,\\mathbf{Y}_{n+1} - 4\\,\\mathbf{Y}_{n} + \\mathbf{Y}_{n-1}}{2\\,\\Delta t}.\n$$\n全隐式BDF2格式要求这个离散导数等于在 $t_{n+1}$ 处计算的右侧项：\n$$\n\\frac{3\\,\\mathbf{Y}_{n+1} - 4\\,\\mathbf{Y}_{n} + \\mathbf{Y}_{n-1}}{2\\,\\Delta t} \\;=\\; \\mathbf{f}(\\mathbf{Y}_{n+1}).\n$$\n\n将 $t_{n+1}$ 处的非线性残差定义为\n$$\n\\mathbf{R}(\\mathbf{Y}) \\;=\\; \\frac{3\\,\\mathbf{Y} - 4\\,\\mathbf{Y}_{n} + \\mathbf{Y}_{n-1}}{2\\,\\Delta t} \\;-\\; \\mathbf{f}(\\mathbf{Y}).\n$$\n从初始猜测 $\\mathbf{Y}^{(0)}$ 开始的一次牛顿迭代满足\n$$\n\\left[\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{Y}}(\\mathbf{Y}^{(0)})\\right]\\delta \\;=\\; -\\,\\mathbf{R}(\\mathbf{Y}^{(0)}), \\qquad \\mathbf{Y}^{(1)} \\;=\\; \\mathbf{Y}^{(0)} + \\delta.\n$$\n因为 $\\mathbf{f}(\\mathbf{Y})=\\mathbf{M}\\mathbf{Y}$ 是线性的，所以雅可比矩阵 $\\mathbf{J}=\\partial \\mathbf{f}/\\partial \\mathbf{Y}$ 是常数且等于 $\\mathbf{M}$。因此\n$$\n\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{Y}} \\;=\\; \\frac{3}{2\\Delta t}\\,\\mathbf{I} \\;-\\; \\mathbf{J} \\;=\\; \\frac{3}{2\\Delta t}\\,\\mathbf{I} \\;-\\; \\mathbf{M}.\n$$\n当 $\\Delta t = 1.0\\times 10^{-3}\\,\\mathrm{s}$ 时，我们有\n$$\n\\alpha \\;=\\; \\frac{3}{2\\Delta t} \\;=\\; \\frac{3}{2\\times 10^{-3}} \\;=\\; 1500,\n$$\n因此\n$$\n\\mathbf{A} \\;=\\; \\alpha\\,\\mathbf{I} - \\mathbf{M} \\;=\\; \\begin{pmatrix}1500 - (-940)  0 - 0 \\\\ 0 - 900  1500 - (-5)\\end{pmatrix} \\;=\\; \\begin{pmatrix}2440  0 \\\\ -900  1505\\end{pmatrix}.\n$$\n\n选择牛顿法的初始猜测为 $\\mathbf{Y}^{(0)}=\\mathbf{Y}_{n}$。计算残差：\n$$\n\\mathbf{R}(\\mathbf{Y}_{n}) \\;=\\; \\frac{\\mathbf{Y}_{n-1} - \\mathbf{Y}_{n}}{2\\Delta t} \\;-\\; \\mathbf{f}(\\mathbf{Y}_{n}).\n$$\n计算每一项。首先，\n$$\n\\frac{\\mathbf{Y}_{n-1} - \\mathbf{Y}_{n}}{2\\Delta t} \\;=\\; \\frac{1}{2\\times 10^{-3}}\\begin{pmatrix}0.500 - 0.195 \\\\ 0.300 - 0.700\\end{pmatrix} \\;=\\; \\frac{1}{0.002}\\begin{pmatrix}0.305 \\\\ -0.400\\end{pmatrix} \\;=\\; \\begin{pmatrix}152.5 \\\\ -200.0\\end{pmatrix}.\n$$\n接下来，\n$$\n\\mathbf{f}(\\mathbf{Y}_{n}) \\;=\\; \\mathbf{M}\\,\\mathbf{Y}_{n} \\;=\\; \\begin{pmatrix}-940  0 \\\\ 900  -5\\end{pmatrix}\\begin{pmatrix}0.195 \\\\ 0.700\\end{pmatrix}.\n$$\n显式计算：\n$$\n\\mathbf{f}(\\mathbf{Y}_{n}) \\;=\\; \\begin{pmatrix}-940\\cdot 0.195 + 0\\cdot 0.700 \\\\ 900\\cdot 0.195 - 5\\cdot 0.700\\end{pmatrix} \\;=\\; \\begin{pmatrix}-183.3 \\\\ 175.5 - 3.5\\end{pmatrix} \\;=\\; \\begin{pmatrix}-183.3 \\\\ 172.0\\end{pmatrix}.\n$$\n因此，在初始猜测处的离散残差为\n$$\n\\mathbf{R}(\\mathbf{Y}_{n}) \\;=\\; \\begin{pmatrix}152.5 \\\\ -200.0\\end{pmatrix} \\;-\\; \\begin{pmatrix}-183.3 \\\\ 172.0\\end{pmatrix} \\;=\\; \\begin{pmatrix}335.8 \\\\ -372.0\\end{pmatrix}.\n$$\n\n求解牛顿系统\n$$\n\\mathbf{A}\\,\\delta \\;=\\; -\\,\\mathbf{R}(\\mathbf{Y}_{n}) \\;=\\; \\begin{pmatrix}-335.8 \\\\ 372.0\\end{pmatrix}.\n$$\n因为在这种情况下 $\\mathbf{A}$ 是下三角矩阵，所以逐分量求解。第一行给出\n$$\n2440\\,\\delta_{1} \\;=\\; -335.8 \\;\\;\\Rightarrow\\;\\; \\delta_{1} \\;=\\; -\\frac{335.8}{2440} \\;\\approx\\; -0.13762295.\n$$\n第二行给出\n$$\n-900\\,\\delta_{1} + 1505\\,\\delta_{2} \\;=\\; 372.0 \\;\\;\\Rightarrow\\;\\; 1505\\,\\delta_{2} \\;=\\; 372.0 + 900\\,\\delta_{1}.\n$$\n代入 $\\delta_{1}$，\n$$\n900\\,\\delta_{1} \\;\\approx\\; -123.860655 \\;\\;\\Rightarrow\\;\\; 1505\\,\\delta_{2} \\;\\approx\\; 248.139345 \\;\\;\\Rightarrow\\;\\; \\delta_{2} \\;\\approx\\; 0.16487664.\n$$\n更新以获得新状态：\n$$\n\\mathbf{Y}_{n+1} \\;=\\; \\mathbf{Y}_{n} + \\delta \\;=\\; \\begin{pmatrix}0.195 \\\\ 0.700\\end{pmatrix} + \\begin{pmatrix}-0.13762295 \\\\ 0.16487664\\end{pmatrix} \\;=\\; \\begin{pmatrix}0.05737705 \\\\ 0.86487664\\end{pmatrix}.\n$$\n\n对于线性系统 $\\mathbf{f}(\\mathbf{Y})=\\mathbf{M}\\mathbf{Y}$，这次单步牛顿迭代就是精确的BDF2解，因为雅可比矩阵是常数，残差是仿射的。等价地，可以将BDF2步骤写成线性系统\n$$\n\\left(\\frac{3}{2\\Delta t}\\mathbf{I} - \\mathbf{M}\\right)\\mathbf{Y}_{n+1} \\;=\\; \\frac{4\\,\\mathbf{Y}_{n} - \\mathbf{Y}_{n-1}}{2\\Delta t},\n$$\n其中，$\\mathbf{A}$ 如上所述，右侧项为\n$$\n\\frac{4\\,\\mathbf{Y}_{n} - \\mathbf{Y}_{n-1}}{2\\Delta t} \\;=\\; \\frac{1}{0.002}\\begin{pmatrix}4\\cdot 0.195 - 0.500 \\\\ 4\\cdot 0.700 - 0.300\\end{pmatrix} \\;=\\; \\frac{1}{0.002}\\begin{pmatrix}0.280 \\\\ 2.500\\end{pmatrix} \\;=\\; \\begin{pmatrix}140 \\\\ 1250\\end{pmatrix},\n$$\n得到相同的解。求解\n$$\n\\begin{pmatrix}2440  0 \\\\ -900  1505\\end{pmatrix}\\begin{pmatrix}Y_{P,n+1} \\\\ Y_{D,n+1}\\end{pmatrix} \\;=\\; \\begin{pmatrix}140 \\\\ 1250\\end{pmatrix}\n$$\n得到 $Y_{P,n+1} = 140/2440 = 7/122 \\approx 0.05737705$ 且\n$$\nY_{D,n+1} \\;=\\; \\frac{1250 + 900\\,Y_{P,n+1}}{1505} \\;=\\; \\frac{1250 + 900\\cdot (7/122)}{1505} \\;=\\; \\frac{79400}{91805} \\;\\approx\\; 0.86487683,\n$$\n与牛顿迭代的结果一致。将每个分量四舍五入到六位有效数字，得到所要求的结果：\n$$\n\\mathbf{Y}_{n+1} \\;\\approx\\; \\begin{pmatrix}0.0573770 \\\\ 0.864877\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix} 0.0573770 \\\\ 0.864877 \\end{pmatrix}}$$", "id": "3576963"}, {"introduction": "数值积分器在处理刚性系统时，一个常见的失败模式是产生非物理的负丰度值，尤其是在采用较大时间步长时。本练习介绍了一种强有力的技术来严格保证解的正定性：将丰度变量 $Y_i$ 变换到对数空间，$z_i = \\ln Y_i$。然后求解关于 $z_i$ 的隐式方程，通过逆变换 $Y_i = \\exp(z_i)$ 得到的丰度便天然具有正定性。您将实现一个采用此变换的完整向后欧拉求解器，这要求您为变换后的系统推导雅可比矩阵并应用牛顿法求解。此练习 [@problem_id:3576947] 展示了如何将鲁棒性和物理一致性直接构建到您的求解器中。", "problem": "构建一个程序，该程序能在单个（可能很大）时间步长上对小型核反应网络进行积分，同时保证物种丰度为非负值。丰度是每个重子的核丰度，用 $Y_i$ 表示，是无量纲的。时间以秒为单位。您必须在程序中完成以下操作。\n\n- 将网络建模为一个源于质量作用动力学的常微分方程组 (ODEs)。如果有 $n$ 个物种和 $m$ 个反应，设化学计量变化矩阵为 $N \\in \\mathbb{R}^{n \\times m}$，其元素为 $N_{i r} = \\nu^{\\mathrm{prod}}_{i r} - \\nu^{\\mathrm{reac}}_{i r}$，其中 $\\nu^{\\mathrm{prod}}_{i r}$ 和 $\\nu^{\\mathrm{reac}}_{i r}$ 分别是反应 $r$ 中物种 $i$ 的产物和反应物化学计量系数。对于质量作用动力学，反应 $r$ 的反应速率为 $R_r(\\mathbf{Y}) = k_r \\prod_{i=1}^{n} Y_i^{\\nu^{\\mathrm{reac}}_{i r}}$，其中速率常数 $k_r$ 是给定的，且 $\\mathbf{Y} = (Y_1,\\dots,Y_n)^{\\top}$。该 ODE 系统为 $d\\mathbf{Y}/dt = \\mathbf{f}(\\mathbf{Y}) = N \\,\\mathbf{R}(\\mathbf{Y})$，其中 $\\mathbf{R} = (R_1,\\dots,R_m)^{\\top}$。\n\n- 实现两种单步法，将状态从时间 $t^{n}$ 的 $\\mathbf{Y}^{n}$ 推进到时间 $t^{n+1} = t^{n} + \\Delta t$ 的 $\\mathbf{Y}^{n+1}$：\n  1. 一个基准的前向（显式）欧拉步，$\\mathbf{Y}^{n+1}_{\\mathrm{FE}} = \\mathbf{Y}^{n} + \\Delta t \\,\\mathbf{f}(\\mathbf{Y}^{n})$，不进行任何裁剪或后处理。\n  2. 一个在对数变量中求解的、保证正定性的隐式后向欧拉步。引入变换后的变量 $\\mathbf{z} \\in \\mathbb{R}^{n}$，其中 $z_i = \\log Y_i$。求解 $\\mathbf{z}^{n+1}$ 使得 $\\exp(\\mathbf{z}^{n+1}) = \\mathbf{Y}^{n} + \\Delta t \\,\\mathbf{f}(\\exp(\\mathbf{z}^{n+1}))$。求解器必须使用牛顿法和合适的全局化策略，以确保从一个物理上有意义的初始猜测收敛。映射回丰度的操作为 $\\mathbf{Y}^{n+1}_{\\mathrm{BE}} = \\exp(\\mathbf{z}^{n+1})$，根据构造，这保证了 $Y^{n+1}_i > 0$。\n\n- 对于变换后残差的牛顿法，从 $\\mathbf{f}(\\mathbf{Y})$ 的定义和质量作用动力学的性质出发，使用链式法则从第一性原理推导并实现雅可比矩阵。您的实现必须对所提供的测试套件是鲁棒的。\n\n- 对于任何给定的网络，使用每个物种的整数质量数 $A_i$ 定义守恒的类重子数量。对于任何物理上封闭的反应集，守恒量为 $B(\\mathbf{Y}) = \\sum_{i=1}^{n} A_i Y_i$。您的程序必须通过比较 $B(\\mathbf{Y}^{n+1}_{\\mathrm{BE}})$ 和 $B(\\mathbf{Y}^{n})$ 来检查守恒性。\n\n- 数值细节：\n  - 使用基于残差范数的牛顿法终止准则。当 $\\lVert \\mathbf{G}(\\mathbf{z}) \\rVert_2 \\le \\varepsilon_{\\mathrm{abs}} + \\varepsilon_{\\mathrm{rel}} \\lVert \\exp(\\mathbf{z}) \\rVert_2$ 时终止，其中 $\\mathbf{G}(\\mathbf{z}) = \\exp(\\mathbf{z}) - \\mathbf{Y}^{n} - \\Delta t\\,\\mathbf{f}(\\exp(\\mathbf{z}))$，容差为 $\\varepsilon_{\\mathrm{abs}} = 10^{-12}$ 和 $\\varepsilon_{\\mathrm{rel}} = 10^{-10}$。最多使用 100 次牛顿迭代，并使用带有标准 Armijo 下降的回溯线搜索来确保收敛。\n  - 所有丰度都是无量纲的。时间以秒为单位。速率常数 $k_r$ 应被视为与这些单位一致；您无需在输出中报告 $k_r$ 的单位。\n  - 对于任何对数运算，通过使用当前的正迭代值来确保其参数为严格正数。对于隐式求解的初始猜测，使用 $\\mathbf{z}^{0} = \\log(\\mathbf{Y}^{n})$，如果需要避免 $\\log 0$，则按分量添加一个微小的正偏移量。\n\n- 测试套件：\n  提供四个测试用例，每个用例由其物种、反应、速率常数、质量数 $A_i$、初始丰度 $\\mathbf{Y}^{n}$ 和时间步长 $\\Delta t$ 定义。\n  - 用例 1（在较大 $\\Delta t$ 下易于出现负值的两体聚变）：物种 $\\{A,B,C\\}$，质量数为 $(1,1,2)$，反应 $A + B \\rightarrow C$ 的速率常数 $k = 50$。初始丰度 $\\mathbf{Y}^{n} = (0.6, 0.6, 0.0)$，$\\Delta t = 0.2$。\n  - 用例 2（刚性可逆相互转换）：物种 $\\{A,B\\}$，质量数为 $(1,1)$，反应 $A \\rightarrow B$ 的速率常数 $k_{f} = 100$，$B \\rightarrow A$ 的速率常数 $k_{r} = 40$。初始丰度 $\\mathbf{Y}^{n} = (0.99, 0.01)$，$\\Delta t = 0.5$。\n  - 用例 3（刚性链式反应）：物种 $\\{A,B,C\\}$，质量数为 $(1,1,1)$，反应 $A \\rightarrow B$ 的速率常数 $k_{1} = 20$，$B \\rightarrow C$ 的速率常数 $k_{2} = 30$。初始丰度 $\\mathbf{Y}^{n} = (0.8, 0.2, 0.0)$，$\\Delta t = 0.2$。\n  - 用例 4（小 $\\Delta t$ 基准）：与用例 3 相同，但 $\\Delta t = 0.001$。\n\n- 所需检查和最终输出规范：\n  对于每个用例 $j \\in \\{1,2,3,4\\}$，计算以下三个谓词：\n  1. $P^{(j)}_{\\mathrm{FE\\_neg}}$：$\\mathbf{Y}^{n+1}_{\\mathrm{FE}}$ 的任意分量是否为负。\n  2. $P^{(j)}_{\\mathrm{BE\\_pos}}$：$\\mathbf{Y}^{n+1}_{\\mathrm{BE}}$ 的每个分量是否在 $10^{-14}$ 的容差范围内严格为正。\n  3. $P^{(j)}_{\\mathrm{cons}}$：$| B(\\mathbf{Y}^{n+1}_{\\mathrm{BE}}) - B(\\mathbf{Y}^{n}) | \\le 10^{-10}$ 是否成立。\n  您的程序必须生成单行输出，其中包含一个含四个布尔值 $Q^{(j)}$ 的列表，每个用例一个值。当且仅当 $P^{(j)}_{\\mathrm{FE\\_neg}}$ 为真、$P^{(j)}_{\\mathrm{BE\\_pos}}$ 为真且 $P^{(j)}_{\\mathrm{cons}}$ 为真时，$Q^{(j)}$ 为真。要求的最终输出格式为精确的单行：\n  \"[Q1,Q2,Q3,Q4]\"", "solution": "该问题要求实现并比较两种数值积分方法，用于求解在质量作用动力学假设下描述核反应网络的常微分方程组 (ODEs)。主要目标是展示显式前向欧拉法在大时间步长下会破坏正定性的本质，并使用对数变量变换实现一个保证正定性的隐式后向欧拉求解器。\n\n一个包含 $n$ 个物种和 $m$ 个反应的反应网络，其物种丰度 $\\mathbf{Y} = (Y_1, \\dots, Y_n)^\\top$ 的时间演化由以下 ODE 系统描述：\n$$\n\\frac{d\\mathbf{Y}}{dt} = \\mathbf{f}(\\mathbf{Y}) = N \\mathbf{R}(\\mathbf{Y})\n$$\n其中 $N \\in \\mathbb{R}^{n \\times m}$ 是化学计量变化矩阵，其元素 $N_{ir} = \\nu^{\\mathrm{prod}}_{ir} - \\nu^{\\mathrm{reac}}_{ir}$ 表示物种 $i$ 因反应 $r$ 引起的净变化。向量 $\\mathbf{R}(\\mathbf{Y}) = (R_1, \\dots, R_m)^\\top$ 包含 $m$ 个反应的速率。对于质量作用动力学，反应 $r$ 的速率为：\n$$\nR_r(\\mathbf{Y}) = k_r \\prod_{i=1}^{n} Y_i^{\\nu^{\\mathrm{reac}}_{ir}}\n$$\n其中 $k_r$ 是速率常数，$\\nu^{\\mathrm{reac}}_{ir}$ 是物种 $i$ 作为反应物在反应 $r$ 中的化学计量系数。\n\n任务是将系统从时间 $t^n$ 的状态 $\\mathbf{Y}^n$ 推进到 $t^{n+1} = t^n + \\Delta t$ 的新状态 $\\mathbf{Y}^{n+1}$。\n\n首先，我们考虑基准的前向（显式）欧拉法。这是最简单的显式单步法，定义为：\n$$\n\\mathbf{Y}^{n+1}_{\\mathrm{FE}} = \\mathbf{Y}^{n} + \\Delta t \\, \\mathbf{f}(\\mathbf{Y}^{n})\n$$\n该方法计算成本低，因为它只需要对右端函数 $\\mathbf{f}$ 进行一次求值。然而，众所周知其稳定域有限。对于在反应网络中常见的刚性系统，时间步长 $\\Delta t$ 必须小到不切实际才能维持稳定性，并且（与本问题相关）防止丰度变为负值——这是一个物理上无意义的结果。\n\n其次，我们实现一个后向（隐式）欧拉法。该方法是 A-稳定的，因此非常适合刚性系统。其更新公式为：\n$$\n\\mathbf{Y}^{n+1} = \\mathbf{Y}^{n} + \\Delta t \\, \\mathbf{f}(\\mathbf{Y}^{n+1})\n$$\n这是一个关于未知状态 $\\mathbf{Y}^{n+1}$ 的隐式方程。为了保证解的分量保持为正，我们引入变量替换：$Y_i = e^{z_i}$，或写为向量形式 $\\mathbf{Y} = \\exp(\\mathbf{z})$。由于指数函数将任何实数映射为正数，因此 $\\mathbf{z}$ 的任何解都将产生一个严格为正的丰度向量 $\\mathbf{Y}$。将此代入后向欧拉方程，我们得到一个关于 $\\mathbf{z}^{n+1}$ 的方程：\n$$\n\\exp(\\mathbf{z}^{n+1}) = \\mathbf{Y}^{n} + \\Delta t \\, \\mathbf{f}(\\exp(\\mathbf{z}^{n+1}))\n$$\n这是一个关于 $\\mathbf{z}^{n+1}$ 的非线性代数方程组。我们可以使用牛顿法求解它。令我们要求解的变量为 $\\mathbf{z} \\equiv \\mathbf{z}^{n+1}$。我们定义一个残差函数 $\\mathbf{G}(\\mathbf{z})$，并寻求其根：\n$$\n\\mathbf{G}(\\mathbf{z}) = \\exp(\\mathbf{z}) - \\mathbf{Y}^{n} - \\Delta t \\, \\mathbf{f}(\\exp(\\mathbf{z})) = \\mathbf{0}\n$$\n牛顿法迭代地求解根。从一个初始猜测 $\\mathbf{z}_0$ 开始，每次迭代通过以下方式更新解：\n$$\n\\mathbf{z}_{k+1} = \\mathbf{z}_k + \\Delta \\mathbf{z}_k\n$$\n其中更新步 $\\Delta \\mathbf{z}_k$ 是以下线性系统的解：\n$$\n\\mathbf{J}_{\\mathbf{G}}(\\mathbf{z}_k) \\Delta \\mathbf{z}_k = -\\mathbf{G}(\\mathbf{z}_k)\n$$\n这里 $\\mathbf{J}_{\\mathbf{G}}(\\mathbf{z}_k)$ 是残差函数 $\\mathbf{G}$ 在 $\\mathbf{z}_k$ 处求值的雅可比矩阵。我们必须推导这个雅可比矩阵。根据链式法则，$\\mathbf{J}_{\\mathbf{G}} = \\frac{d\\mathbf{G}}{d\\mathbf{z}} = \\frac{d\\mathbf{G}}{d\\mathbf{Y}} \\frac{d\\mathbf{Y}}{d\\mathbf{z}}$。\n\n让我们计算这两部分。首先，$\\frac{d\\mathbf{Y}}{d\\mathbf{z}}$：\n由于 $Y_i = e^{z_i}$，导数 $\\frac{\\partial Y_i}{\\partial z_j} = \\delta_{ij} e^{z_i} = \\delta_{ij} Y_i$。这意味着 $\\frac{d\\mathbf{Y}}{d\\mathbf{z}}$ 是一个对角矩阵：\n$$\n\\frac{d\\mathbf{Y}}{d\\mathbf{z}} = \\mathrm{diag}(e^{z_1}, \\dots, e^{z_n}) = \\mathrm{diag}(\\mathbf{Y})\n$$\n\n接下来，$\\frac{d\\mathbf{G}}{d\\mathbf{Y}}$，其中 $\\mathbf{G}(\\mathbf{Y}) = \\mathbf{Y} - \\mathbf{Y}^n - \\Delta t \\, \\mathbf{f}(\\mathbf{Y})$：\n$$\n\\frac{d\\mathbf{G}}{d\\mathbf{Y}} = \\mathbf{I} - \\Delta t \\, \\frac{d\\mathbf{f}}{d\\mathbf{Y}} = \\mathbf{I} - \\Delta t \\, \\mathbf{J}_{\\mathbf{f}}(\\mathbf{Y})\n$$\n其中 $\\mathbf{I}$ 是单位矩阵，$\\mathbf{J}_{\\mathbf{f}}$ 是 ODE 右端函数 $\\mathbf{f}$ 的雅可比矩阵。\n\n$\\mathbf{J}_{\\mathbf{f}}$ 的元素为 $(J_{\\mathbf{f}})_{ij} = \\frac{\\partial f_i}{\\partial Y_j}$。我们有 $f_i = \\sum_{r=1}^m N_{ir} R_r$，所以：\n$$\n(J_{\\mathbf{f}})_{ij} = \\frac{\\partial f_i}{\\partial Y_j} = \\sum_{r=1}^m N_{ir} \\frac{\\partial R_r}{\\partial Y_j}\n$$\n反应速率 $R_r = k_r \\prod_{l=1}^n Y_l^{\\nu^{\\mathrm{reac}}_{lr}}$ 对 $Y_j$ 的导数为：\n$$\n\\frac{\\partial R_r}{\\partial Y_j} = k_r \\nu^{\\mathrm{reac}}_{jr} Y_j^{\\nu^{\\mathrm{reac}}_{jr}-1} \\prod_{l \\neq j} Y_l^{\\nu^{\\mathrm{reac}}_{lr}} = \\frac{\\nu^{\\mathrm{reac}}_{jr}}{Y_j} R_r(\\mathbf{Y})\n$$\n这个表达式在 $Y_j > 0$ 时有效，这是有保证的，因为我们是在 $\\mathbf{Y} = \\exp(\\mathbf{z})$ 处求值。\n因此，我们有 $(J_{\\mathbf{f}})_{ij} = \\sum_{r=1}^m N_{ir} \\frac{\\nu^{\\mathrm{reac}}_{jr}}{Y_j} R_r(\\mathbf{Y})$。\n\n综合这些部分，牛顿系统的雅可比矩阵为：\n$$\n\\mathbf{J}_{\\mathbf{G}}(\\mathbf{z}) = \\left( \\mathbf{I} - \\Delta t \\, \\mathbf{J}_{\\mathbf{f}}(\\exp(\\mathbf{z})) \\right) \\mathrm{diag}(\\exp(\\mathbf{z}))\n$$\n\n为了确保牛顿法从一个可能远离解的初始猜测收敛，需要采用一种全局化策略。我们对更新步使用回溯线搜索：$\\mathbf{z}_{k+1} = \\mathbf{z}_k + \\alpha \\Delta \\mathbf{z}_k$，其中 $\\alpha \\in (0, 1]$ 是步长。我们从 $\\alpha=1$ 开始，并减小它，直到满足 Armijo-Goldstein 条件。该条件确保评价函数（通常为 $F(\\mathbf{z}) = \\frac{1}{2}\\lVert \\mathbf{G}(\\mathbf{z}) \\rVert_2^2$）有充分下降。该条件为 $F(\\mathbf{z}_k + \\alpha \\Delta \\mathbf{z}_k) \\le F(\\mathbf{z}_k) + c \\alpha \\nabla F(\\mathbf{z}_k)^T \\Delta \\mathbf{z}_k$，对于一个小的常数 $c \\in (0,1)$。鉴于 $\\nabla F^T\\Delta\\mathbf{z}_k = -\\lVert \\mathbf{G}(\\mathbf{z}_k) \\rVert_2^2$，这可以简化为：\n$$\n\\frac{1}{2}\\lVert \\mathbf{G}(\\mathbf{z}_k + \\alpha \\Delta \\mathbf{z}_k) \\rVert_2^2 \\le \\frac{1}{2}(1 - 2c\\alpha)\\lVert \\mathbf{G}(\\mathbf{z}_k) \\rVert_2^2\n$$\n一个更简单实用的变体是直接确保残差范数有充分下降：$\\lVert \\mathbf{G}(\\mathbf{z}_k + \\alpha \\Delta \\mathbf{z}_k) \\rVert_2 \\le (1-c\\alpha)\\lVert \\mathbf{G}(\\mathbf{z}_k) \\rVert_2$。我们将在实现中使用这种方法。\n\n最后，我们必须检查类重子数量 $B(\\mathbf{Y})=\\sum_{i=1}^n A_i Y_i$ 的守恒性，其中 $A_i$ 是整数质量数。其时间导数为 $\\frac{dB}{dt} = \\sum_i A_i \\frac{dY_i}{dt} = \\sum_i A_i f_i(\\mathbf{Y})$。代入 $\\mathbf{f}$ 的定义：\n$$\n\\frac{dB}{dt} = \\sum_{i=1}^n A_i \\left( \\sum_{r=1}^m N_{ir} R_r(\\mathbf{Y}) \\right) = \\sum_{r=1}^m \\left( \\sum_{i=1}^n A_i N_{ir} \\right) R_r(\\mathbf{Y})\n$$\n对于任何有效的核反应，总质量数是守恒的，这意味着对于每个反应 $r$，$\\sum_i A_i N_{ir} = \\sum_i A_i (\\nu^{\\mathrm{prod}}_{ir} - \\nu^{\\mathrm{reac}}_{ir}) = 0$。因此，$\\frac{dB}{dt}=0$ 在解析上成立。如果一个数值格式能保持这个性质，则称其是“守恒的”。后向欧拉法确实如此。我们通过检查 $|B(\\mathbf{Y}^{n+1}_{\\mathrm{BE}}) - B(\\mathbf{Y}^n)|$ 是否小于给定的容差来验证这一点，该容差考虑了浮点和求解器误差。\n\n解决方案的流程是实现这些方法，并将它们应用于指定的四个测试用例。对于每个用例，我们确定组合谓词 $Q^{(j)} = P^{(j)}_{\\mathrm{FE\\_neg}} \\land P^{(j)}_{\\mathrm{BE\\_pos}} \\land P^{(j)}_{\\mathrm{cons}}$ 的真值，该谓词测试前向欧拉法是否产生不符合物理的负丰度，而后向欧拉法是否提供物理上有效（正值）且守恒的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# The problem statement specifies scipy in the environment, but the solver\n# is implemented from first principles using only numpy as required.\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    class ReactionNetwork:\n        \"\"\"\n        Represents a nuclear reaction network.\n        \"\"\"\n        def __init__(self, species, mass_numbers, reactions, rate_constants):\n            self.species = list(species)\n            self.n_species = len(self.species)\n            self.mass_numbers = np.array(mass_numbers, dtype=float)\n            self.rate_constants = np.array(rate_constants, dtype=float)\n            \n            self.n_reactions = len(reactions)\n            self.stoich_reac = np.zeros((self.n_species, self.n_reactions))\n            self.stoich_prod = np.zeros((self.n_species, self.n_reactions))\n            \n            species_map = {name: i for i, name in enumerate(self.species)}\n            \n            for r_idx, reaction in enumerate(reactions):\n                reac_str, prod_str = reaction.split('-')\n                \n                for part in reac_str.strip().split('+'):\n                    part = part.strip()\n                    if not part: continue\n                    # Assuming coefficients are 1 if not specified\n                    coeff = 1\n                    name = part\n                    if ' ' in part:\n                        coeff_str, name = part.split(' ', 1)\n                        coeff = int(coeff_str)\n                    s_idx = species_map[name]\n                    self.stoich_reac[s_idx, r_idx] += coeff\n                \n                for part in prod_str.strip().split('+'):\n                    part = part.strip()\n                    if not part: continue\n                    coeff = 1\n                    name = part\n                    if ' ' in part:\n                        coeff_str, name = part.split(' ', 1)\n                        coeff = int(coeff_str)\n                    s_idx = species_map[name]\n                    self.stoich_prod[s_idx, r_idx] += coeff\n\n            self.N = self.stoich_prod - self.stoich_reac\n\n        def get_rates(self, Y):\n            \"\"\"Computes the reaction rates R(Y).\"\"\"\n            # Add a small floor to Y to handle Y=0 in reactants for np.power\n            Y_floored = np.maximum(Y, 1e-100)\n            # Y[:, np.newaxis] broadcasts species abundances across reactions\n            rates = self.rate_constants * np.prod(Y_floored[:, np.newaxis]**self.stoich_reac, axis=0)\n            return rates\n\n        def f(self, Y):\n            \"\"\"Computes the ODE right-hand side f(Y) = N * R(Y).\"\"\"\n            return self.N @ self.get_rates(Y)\n\n        def jacobian_f(self, Y):\n            \"\"\"Computes the Jacobian of the ODE RHS, J_f.\"\"\"\n            Jf = np.zeros((self.n_species, self.n_species))\n            rates = self.get_rates(Y)\n            \n            # Use a small value to avoid division by zero, but since Y comes from\n            # exp(z) in the BE solver, it will be strictly positive.\n            Y_safe = np.maximum(Y, 1e-100)\n\n            for j in range(self.n_species):\n                # dR_r/dY_j = (nu_reac_jr / Y_j) * R_r\n                dRdYj = (self.stoich_reac[j, :] / Y_safe[j]) * rates\n                Jf[:, j] = self.N @ dRdYj\n            return Jf\n\n    def forward_euler_step(network, Y_n, dt):\n        \"\"\"Performs a single forward Euler step.\"\"\"\n        f_n = network.f(Y_n)\n        Y_fe = Y_n + dt * f_n\n        return Y_fe\n\n    def backward_euler_step(network, Y_n, dt):\n        \"\"\"\n        Solves for Y_{n+1} using backward Euler with a logarithmic transformation\n        and Newton's method.\n        \"\"\"\n        n_species = network.n_species\n        \n        # Numerical parameters for Newton's method\n        eps_abs = 1e-12\n        eps_rel = 1e-10\n        max_iter = 100\n        armijo_c = 1e-4\n        min_alpha = 1e-8\n        \n        # Initial guess in log-space, handle Y_n[i] = 0\n        z_k = np.log(np.maximum(Y_n, 1e-40))\n\n        for _ in range(max_iter):\n            Y_k = np.exp(z_k)\n            \n            # Calculate residual G(z_k)\n            G_k = Y_k - Y_n - dt * network.f(Y_k)\n            G_norm = np.linalg.norm(G_k)\n            \n            # Check for convergence\n            Y_norm = np.linalg.norm(Y_k)\n            if G_norm = eps_abs + eps_rel * Y_norm:\n                return Y_k\n\n            # Calculate Jacobian of the Newton system J_G(z_k)\n            J_f_k = network.jacobian_f(Y_k)\n            I = np.identity(n_species)\n            J_G = (I - dt * J_f_k) @ np.diag(Y_k)\n            \n            # Solve linear system for Newton step: J_G * dz = -G\n            try:\n                delta_z = np.linalg.solve(J_G, -G_k)\n            except np.linalg.LinAlgError:\n                # Fallback to pseudo-inverse if Jacobian is singular\n                delta_z = np.linalg.pinv(J_G) @ -G_k\n\n            # Backtracking line search\n            alpha = 1.0\n            G_norm_sq = G_norm**2\n            \n            while True:\n                z_trial = z_k + alpha * delta_z\n                Y_trial = np.exp(z_trial)\n                G_trial = Y_trial - Y_n - dt * network.f(Y_trial)\n                \n                # Armijo condition check on residual norm\n                if np.linalg.norm(G_trial) = (1 - armijo_c * alpha) * G_norm:\n                    z_k = z_trial\n                    break\n                \n                alpha /= 2.0\n                if alpha  min_alpha:\n                    # Line search failed, should not happen for these problems\n                    return None \n            \n        return None # Max iterations reached\n\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"species\": [\"A\", \"B\", \"C\"],\n            \"mass_numbers\": [1, 1, 2],\n            \"reactions\": [\"A + B - C\"],\n            \"k\": [50.0],\n            \"Y0\": np.array([0.6, 0.6, 0.0]),\n            \"dt\": 0.2\n        },\n        {\n            \"name\": \"Case 2\",\n            \"species\": [\"A\", \"B\"],\n            \"mass_numbers\": [1, 1],\n            \"reactions\": [\"A - B\", \"B - A\"],\n            \"k\": [100.0, 40.0],\n            \"Y0\": np.array([0.99, 0.01]),\n            \"dt\": 0.5\n        },\n        {\n            \"name\": \"Case 3\",\n            \"species\": [\"A\", \"B\", \"C\"],\n            \"mass_numbers\": [1, 1, 1],\n            \"reactions\": [\"A - B\", \"B - C\"],\n            \"k\": [20.0, 30.0],\n            \"Y0\": np.array([0.8, 0.2, 0.0]),\n            \"dt\": 0.2\n        },\n        {\n            \"name\": \"Case 4\",\n            \"species\": [\"A\", \"B\", \"C\"],\n            \"mass_numbers\": [1, 1, 1],\n            \"reactions\": [\"A - B\", \"B - C\"],\n            \"k\": [20.0, 30.0],\n            \"Y0\": np.array([0.8, 0.2, 0.0]),\n            \"dt\": 0.001\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        net = ReactionNetwork(case[\"species\"], case[\"mass_numbers\"], case[\"reactions\"], case[\"k\"])\n        Y0 = case[\"Y0\"]\n        dt = case[\"dt\"]\n        \n        # 1. Forward Euler\n        Y_fe = forward_euler_step(net, Y0, dt)\n        P_fe_neg = np.any(Y_fe  0)\n        \n        # 2. Backward Euler\n        Y_be = backward_euler_step(net, Y0, dt)\n        \n        P_be_pos = False\n        P_cons = False\n        \n        if Y_be is not None:\n            # Check for positivity\n            P_be_pos = np.all(Y_be > 1e-14)\n            \n            # Check for conservation\n            B0 = np.dot(net.mass_numbers, Y0)\n            B_be = np.dot(net.mass_numbers, Y_be)\n            P_cons = np.abs(B_be - B0) = 1e-10\n\n        # 3. Final Predicate Q\n        Q = P_fe_neg and P_be_pos and P_cons\n        results.append(Q)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3576947"}, {"introduction": "在编写完一个求解器后，如何能确信它是正确的并且其性能符合预期？人造解方法（Method of Manufactured Solutions, MMS）是一种用于代码验证的严谨技术。该方法通过预先定义一个“人造”的解析解，将其代入控制方程以推导出必需的源项，然后用您的数值求解器求解这个带源项的问题，并检查其是否能重现理论收敛阶。本练习 [@problem_id:3577003] 将引导您对一个显式方法（RK4）和一个隐式方法（梯形法则）进行MMS收敛性研究。这将使您能够凭经验测量它们的精度阶数，并诊断在刚性问题中常见的“降阶”等重要现象。", "problem": "考虑一个简化的核反应网络，该网络包含三种物质和序贯衰变，它捕捉了计算核物理中典型的关键刚性和多时间尺度效应。设丰度向量为 $\\mathbf{y}(t) = [y_1(t), y_2(t), y_3(t)]^\\top$，其中 $y_i(t) \\ge 0$ 表示物质 $i$ 的每重子丰度，网络由以下形式的线性常微分方程（ODE）建模：\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{M}\\,\\mathbf{y}(t) + \\mathbf{g}(t),\n$$\n其中 $\\mathbf{M}$ 是编码衰变反应的化学计量速率矩阵，$\\mathbf{g}(t)$ 是一个随时间变化的强迫项。对于衰变速率分别为 $\\lambda_1$ 和 $\\lambda_2$（单位为 $\\mathrm{s}^{-1}$）的序贯单体衰变，使用\n$$\n\\mathbf{M} = \\begin{bmatrix}\n-\\lambda_1  0  0 \\\\\n\\lambda_1  -\\lambda_2  0 \\\\\n0  \\lambda_2  0\n\\end{bmatrix}.\n$$\n强迫项 $\\mathbf{g}(t)$ 的构造应确保一个具有多时间尺度的构造解能够被精确满足。构造丰度定义为\n$$\ny_1(t) = 0.4\\,e^{-\\alpha t} + 0.2\\,e^{-\\beta t} + 0.1\\,e^{-\\gamma t},\n$$\n$$\ny_2(t) = 0.3\\left(1 - e^{-\\alpha t}\\right)e^{-\\beta t} + 0.1\\,e^{-\\gamma t} + 0.1\\,e^{-\\delta t},\n$$\n$$\ny_3(t) = 1 - y_1(t) - y_2(t),\n$$\n其中 $\\alpha = 800\\,\\mathrm{s}^{-1}$，$\\beta = 80\\,\\mathrm{s}^{-1}$，$\\gamma = 8\\,\\mathrm{s}^{-1}$，以及 $\\delta = 0.8\\,\\mathrm{s}^{-1}$。使用基本定义 $\\frac{d}{dt}e^{-\\kappa t} = -\\kappa e^{-\\kappa t}$ 以及上述线性网络模型，从恒等式\n$$\n\\mathbf{g}(t) = \\frac{d\\mathbf{y}}{dt} - \\mathbf{M}\\,\\mathbf{y}(t),\n$$\n中显式推导出 $\\mathbf{g}(t)$，以使构造解 $\\mathbf{y}(t)$ 对所有 $t$ 都满足该常微分方程。\n\n您的任务是为常微分方程 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{M}\\,\\mathbf{y}(t) + \\mathbf{g}(t)$ 实现两种时间积分方法：\n- 经典四阶 Runge–Kutta 方法（RK），定义为一种标称阶为 $4$ 的单步显式方法。\n- 梯形法则（也称为 Crank–Nicolson 方法），定义为一种标称阶为 $2$ 的单步隐式方法，其更新公式为\n$$\n\\mathbf{y}^{n+1} = \\mathbf{y}^{n} + \\frac{\\Delta t}{2}\\left(\\mathbf{M}\\,\\mathbf{y}^{n} + \\mathbf{g}(t^{n}) + \\mathbf{M}\\,\\mathbf{y}^{n+1} + \\mathbf{g}(t^{n+1})\\right),\n$$\n该公式可以写成一个线性求解问题\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{M}\\right)\\mathbf{y}^{n+1} = \\left(\\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{M}\\right)\\mathbf{y}^{n} + \\frac{\\Delta t}{2}\\left(\\mathbf{g}(t^{n}) + \\mathbf{g}(t^{n+1})\\right),\n$$\n其中 $\\mathbf{I}$ 是单位矩阵。\n\n使用构造解和强迫项，对每种方法进行基于网格的最终时刻误差收敛性研究。对于每个测试，使用均匀时间步长 $\\Delta t$ 从 $t_0 = 0\\,\\mathrm{s}$ 积分到最终时刻 $t_f$，使得 $t_f/\\Delta t$ 为一个整数。初始条件必须设置为 $t_0$ 时刻的精确构造丰度，即 $\\mathbf{y}(0) = \\mathbf{y}_{\\mathrm{exact}}(0)$。\n\n计算一系列 $\\Delta t$ 值对应的最终时刻误差的欧几里得范数\n$$\nE(\\Delta t) = \\left\\lVert \\mathbf{y}_{\\mathrm{num}}(t_f;\\Delta t) - \\mathbf{y}_{\\mathrm{exact}}(t_f) \\right\\rVert_2,\n$$\n通过最小二乘法将直线拟合到 $\\log_{10}(E(\\Delta t))$ 对 $\\log_{10}(\\Delta t)$ 的数据点，估算每种方法的观测阶 $p$，并将斜率报告为观测阶。如果观测阶 $p$ 比方法的标称阶 $p_{\\mathrm{nom}}$ 低至少 $0.5$，即 $p  p_{\\mathrm{nom}} - 0.5$，则声明检测到“阶数退化”。\n\n时间以秒为单位；数值输出（阶数和标志）是无量纲的。为以下参数集 $(\\lambda_1, \\lambda_2, t_f, \\{\\Delta t\\})$ 的测试套件设计研究：\n- 案例 1：$(\\lambda_1, \\lambda_2, t_f, \\{\\Delta t\\}) = (10^2, 10, 2\\times 10^{-2}, \\{2\\times 10^{-3}, 10^{-3}, 5\\times 10^{-4}, 2.5\\times 10^{-4}\\})$。\n- 案例 2：$(\\lambda_1, \\lambda_2, t_f, \\{\\Delta t\\}) = (10^4, 10^3, 2\\times 10^{-3}, \\{2\\times 10^{-4}, 10^{-4}, 5\\times 10^{-5}, 2.5\\times 10^{-5}\\})$。\n- 案例 3：$(\\lambda_1, \\lambda_2, t_f, \\{\\Delta t\\}) = (2\\times 10^4, 5\\times 10^3, 10^{-3}, \\{2\\times 10^{-4}, 10^{-4}, 5\\times 10^{-5}, 2.5\\times 10^{-5}\\})$。\n\n对每个案例，计算：\n- 四阶 Runge–Kutta 方法的观测阶 $p_{\\mathrm{RK4}}$。\n- 梯形法则的观测阶 $p_{\\mathrm{TR}}$。\n- 四阶 Runge–Kutta 方法的阶数退化标志 $r_{\\mathrm{RK4}}$，如果检测到阶数退化则必须为 $1$，否则为 $0$。\n- 梯形法则的阶数退化标志 $r_{\\mathrm{TR}}$，定义与前者类似。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表，顺序如下\n$$\n[p_{\\mathrm{RK4}}^{(1)}, p_{\\mathrm{TR}}^{(1)}, r_{\\mathrm{RK4}}^{(1)}, r_{\\mathrm{TR}}^{(1)}, p_{\\mathrm{RK4}}^{(2)}, p_{\\mathrm{TR}}^{(2)}, r_{\\mathrm{RK4}}^{(2)}, r_{\\mathrm{TR}}^{(2)}, p_{\\mathrm{RK4}}^{(3)}, p_{\\mathrm{TR}}^{(3)}, r_{\\mathrm{RK4}}^{(3)}, r_{\\mathrm{TR}}^{(3)}],\n$$\n其中上标表示案例编号。阶数的条目必须是实数，标志的条目必须是整数（$0$ 或 $1$）。不应打印任何额外文本。", "solution": "用户提供的问题经评估有效。它构成了一个适定的数值分析问题，使用构造解法（MMS）来研究数值积分器在刚性常微分方程（ODE）系统上的收敛性质。该问题具有科学依据、自成体系且客观。\n\n求解过程包括三个主要阶段：\n1.  推导构造解精确满足给定常微分方程系统所需的强迫项 $\\mathbf{g}(t)$。\n2.  实现两种指定的数值积分方案：显式四阶 Runge-Kutta（RK4）方法和隐式梯形法则（TR）。\n3.  执行数值收敛性研究，以确定每种方法的观测精度阶，并检测在测试案例中指定的刚性条件下是否存在任何“阶数退化”。\n\n**1. 强迫项 $\\mathbf{g}(t)$ 的推导**\n\n常微分方程系统由 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{M}\\,\\mathbf{y}(t) + \\mathbf{g}(t)$ 给出。为确保构造解 $\\mathbf{y}(t)$ 是一个精确解，强迫项 $\\mathbf{g}(t)$ 必须定义为：\n$$\n\\mathbf{g}(t) = \\frac{d\\mathbf{y}}{dt} - \\mathbf{M}\\,\\mathbf{y}(t)\n$$\n构造解 $\\mathbf{y}(t) = [y_1(t), y_2(t), y_3(t)]^\\top$ 的分量是：\n$$\ny_1(t) = 0.4\\,e^{-\\alpha t} + 0.2\\,e^{-\\beta t} + 0.1\\,e^{-\\gamma t}\n$$\n$$\ny_2(t) = 0.3\\left(1 - e^{-\\alpha t}\\right)e^{-\\beta t} + 0.1\\,e^{-\\gamma t} + 0.1\\,e^{-\\delta t} = 0.3 e^{-\\beta t} - 0.3 e^{-(\\alpha+\\beta)t} + 0.1 e^{-\\gamma t} + 0.1 e^{-\\delta t}\n$$\n$$\ny_3(t) = 1 - y_1(t) - y_2(t)\n$$\n常数为 $\\alpha = 800\\,\\mathrm{s}^{-1}$，$\\beta = 80\\,\\mathrm{s}^{-1}$，$\\gamma = 8\\,\\mathrm{s}^{-1}$，以及 $\\delta = 0.8\\,\\mathrm{s}^{-1}$。\n\n首先，我们求出时间导数 $\\frac{dy_1}{dt}$ 和 $\\frac{dy_2}{dt}$：\n$$\n\\frac{dy_1}{dt} = -0.4\\alpha e^{-\\alpha t} - 0.2\\beta e^{-\\beta t} - 0.1\\gamma e^{-\\gamma t}\n$$\n$$\n\\frac{dy_2}{dt} = -0.3\\beta e^{-\\beta t} + 0.3(\\alpha+\\beta) e^{-(\\alpha+\\beta)t} - 0.1\\gamma e^{-\\gamma t} - 0.1\\delta e^{-\\delta t}\n$$\n接下来，我们使用给定的矩阵 $\\mathbf{M}$ 计算乘积 $\\mathbf{M}\\,\\mathbf{y}(t)$：\n$$\n\\mathbf{M}\\,\\mathbf{y}(t) = \\begin{bmatrix}\n-\\lambda_1  0  0 \\\\\n\\lambda_1  -\\lambda_2  0 \\\\\n0  \\lambda_2  0\n\\end{bmatrix} \\begin{bmatrix} y_1(t) \\\\ y_2(t) \\\\ y_3(t) \\end{bmatrix} = \\begin{bmatrix} -\\lambda_1 y_1(t) \\\\ \\lambda_1 y_1(t) - \\lambda_2 y_2(t) \\\\ \\lambda_2 y_2(t) \\end{bmatrix}\n$$\n$\\mathbf{g}(t)$ 的分量则为：\n$$\ng_1(t) = \\frac{dy_1}{dt} - (-\\lambda_1 y_1(t)) = 0.4(\\lambda_1 - \\alpha)e^{-\\alpha t} + 0.2(\\lambda_1 - \\beta)e^{-\\beta t} + 0.1(\\lambda_1 - \\gamma)e^{-\\gamma t}\n$$\n$$\ng_2(t) = \\frac{dy_2}{dt} - (\\lambda_1 y_1(t) - \\lambda_2 y_2(t))\n$$\n代入导数和丰度的表达式可得：\n$$\n\\begin{align*}\ng_2(t) = (-0.3\\beta e^{-\\beta t} + 0.3(\\alpha+\\beta) e^{-(\\alpha+\\beta)t} - 0.1\\gamma e^{-\\gamma t} - 0.1\\delta e^{-\\delta t}) \\\\\n- \\lambda_1(0.4 e^{-\\alpha t} + 0.2 e^{-\\beta t} + 0.1 e^{-\\gamma t}) \\\\\n+ \\lambda_2(0.3 e^{-\\beta t} - 0.3 e^{-(\\alpha+\\beta)t} + 0.1 e^{-\\gamma t} + 0.1 e^{-\\delta t})\n\\end{align*}\n$$\n合并具有共同指数项的项：\n$$\n\\begin{align*}\ng_2(t) = -0.4\\lambda_1 e^{-\\alpha t} + (-0.3\\beta - 0.2\\lambda_1 + 0.3\\lambda_2) e^{-\\beta t} \\\\\n+ (-0.1\\gamma - 0.1\\lambda_1 + 0.1\\lambda_2) e^{-\\gamma t} + (-0.1\\delta + 0.1\\lambda_2) e^{-\\delta t} \\\\\n+ (0.3(\\alpha+\\beta) - 0.3\\lambda_2) e^{-(\\alpha+\\beta)t}\n\\end{align*}\n$$\n对于 $g_3(t)$，我们注意到丰度之和是恒定的：$\\sum_{i=1}^3 y_i(t) = 1$。对时间求导得到 $\\sum \\frac{dy_i}{dt} = 0$。对常微分方程系统的各行求和得到 $\\sum \\frac{dy_i}{dt} = \\sum (\\mathbf{M}\\mathbf{y})_i + \\sum g_i(t)$。$\\mathbf{M}\\mathbf{y}$ 的分量之和为 $(-\\lambda_1 y_1) + (\\lambda_1 y_1 - \\lambda_2 y_2) + (\\lambda_2 y_2) = 0$。因此，必然有 $\\sum g_i(t) = 0$，这意味着 $g_3(t) = -g_1(t) - g_2(t)$。这为计算 $g_3(t)$ 提供了一种简单的方法，并可作为一致性检验。\n\n**2. 数值积分方法**\n\n将常微分方程写为 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y})$，其中 $\\mathbf{f}(t, \\mathbf{y}) = \\mathbf{M}\\,\\mathbf{y} + \\mathbf{g}(t)$。\n\n**四阶 Runge-Kutta (RK4)：** 这是一种显式单步法。在时间 $t^{n+1} = t^n + \\Delta t$ 的解由在 $t^n$ 的解通过以下方式计算得出：\n$$\n\\mathbf{y}^{n+1} = \\mathbf{y}^{n} + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中各阶段 $\\mathbf{k}_i$ 为：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{f}(t^n, \\mathbf{y}^n) \\\\\n\\mathbf{k}_2 = \\mathbf{f}(t^n + \\frac{\\Delta t}{2}, \\mathbf{y}^n + \\frac{\\Delta t}{2}\\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = \\mathbf{f}(t^n + \\frac{\\Delta t}{2}, \\mathbf{y}^n + \\frac{\\Delta t}{2}\\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = \\mathbf{f}(t^n + \\Delta t, \\mathbf{y}^n + \\Delta t\\mathbf{k}_3)\n\\end{aligned}\n$$\n其标称精度阶为 $p_{\\mathrm{nom}} = 4$。\n\n**梯形法则 (TR)：** 这是一种隐式单步法，也称为 Crank-Nicolson 方法。其更新规则为：\n$$\n\\mathbf{y}^{n+1} = \\mathbf{y}^{n} + \\frac{\\Delta t}{2}\\left(\\mathbf{f}(t^n, \\mathbf{y}^n) + \\mathbf{f}(t^{n+1}, \\mathbf{y}^{n+1})\\right)\n$$\n代入 $\\mathbf{f}(t, \\mathbf{y}) = \\mathbf{M}\\mathbf{y} + \\mathbf{g}(t)$ 并整理以求解 $\\mathbf{y}^{n+1}$：\n$$\n\\mathbf{y}^{n+1} - \\frac{\\Delta t}{2}\\mathbf{M}\\mathbf{y}^{n+1} = \\mathbf{y}^{n} + \\frac{\\Delta t}{2}\\mathbf{M}\\mathbf{y}^{n} + \\frac{\\Delta t}{2}\\left(\\mathbf{g}(t^n) + \\mathbf{g}(t^{n+1})\\right)\n$$\n这就是问题陈述中提供的线性系统，在每个时间步长求解 $\\mathbf{y}^{n+1}$：\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{M}\\right)\\mathbf{y}^{n+1} = \\left(\\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{M}\\right)\\mathbf{y}^{n} + \\frac{\\Delta t}{2}\\left(\\mathbf{g}(t^{n}) + \\mathbf{g}(t^{n+1})\\right)\n$$\n其中 $\\mathbf{I}$ 是单位矩阵。其标称精度阶为 $p_{\\mathrm{nom}} = 2$。\n\n**3. 收敛性研究与阶数估计**\n\n对于每个参数集，系统使用递减的时间步长 $\\Delta t$ 网格从 $t_0=0$ 积分到 $t_f$。初始条件设为精确值 $\\mathbf{y}(0) = \\mathbf{y}_{\\mathrm{exact}}(0)$。计算最终时刻误差的欧几里得范数：\n$$\nE(\\Delta t) = \\left\\lVert \\mathbf{y}_{\\mathrm{num}}(t_f; \\Delta t) - \\mathbf{y}_{\\mathrm{exact}}(t_f) \\right\\rVert_2\n$$\n对于一个 $p$ 阶方法，当 $\\Delta t$ 足够小时，误差预计将按 $E(\\Delta t) \\approx C(\\Delta t)^p$ 的规律缩放，其中 $C$ 为某个常数。取以 10 为底的对数，得到一个线性关系：\n$$\n\\log_{10}(E(\\Delta t)) \\approx \\log_{10}(C) + p \\log_{10}(\\Delta t)\n$$\n收敛的观测阶 $p$ 是通过线性最小二乘回归拟合数据点 $(\\log_{10}(\\Delta t), \\log_{10}(E))$ 的直线斜率来估计的。\n\n阶数退化是一种现象，尤其是在刚性系统中，其中观测阶 $p$ 低于方法的标称阶 $p_{\\mathrm{nom}}$。根据问题定义，如果 $p  p_{\\mathrm{nom}} - 0.5$，则检测到阶数退化。对于 RK4，这意味着 $p  3.5$，对于 TR，这意味着 $p  1.5$。对三个测试案例中的每一个都进行分析。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the specified ODE convergence study problem.\n    \"\"\"\n    \n    # Global constants for the manufactured solution\n    ALPHA = 800.0\n    BETA = 80.0\n    GAMMA = 8.0\n    DELTA = 0.8\n    T0 = 0.0\n\n    def y_exact(t):\n        \"\"\"Computes the exact manufactured solution vector y(t).\"\"\"\n        t = np.asarray(t)\n        exp_at = np.exp(-ALPHA * t)\n        exp_bt = np.exp(-BETA * t)\n        exp_gt = np.exp(-GAMMA * t)\n        exp_dt = np.exp(-DELTA * t)\n\n        y1 = 0.4 * exp_at + 0.2 * exp_bt + 0.1 * exp_gt\n        y2 = 0.3 * (1.0 - exp_at) * exp_bt + 0.1 * exp_gt + 0.1 * exp_dt\n        y3 = 1.0 - y1 - y2\n        \n        # Ensure output is (N, 3) for N time points or (1, 3) for a scalar t\n        return np.array([y1, y2, y3]).T.reshape(-1, 3)\n\n    def g_forcing(t, lam1, lam2):\n        \"\"\"Computes the forcing term vector g(t).\"\"\"\n        t = np.asarray(t)\n\n        exp_at = np.exp(-ALPHA * t)\n        exp_bt = np.exp(-BETA * t)\n        exp_gt = np.exp(-GAMMA * t)\n        exp_dt = np.exp(-DELTA * t)\n        exp_abt = np.exp(-(ALPHA + BETA) * t)\n\n        y1_exact = 0.4 * exp_at + 0.2 * exp_bt + 0.1 * exp_gt\n        y2_exact = 0.3 * exp_bt - 0.3 * exp_abt + 0.1 * exp_gt + 0.1 * exp_dt\n        \n        dy1_dt = -0.4 * ALPHA * exp_at - 0.2 * BETA * exp_bt - 0.1 * GAMMA * exp_gt\n        dy2_dt = -0.3 * BETA * exp_bt + 0.3 * (ALPHA + BETA) * exp_abt - 0.1 * GAMMA * exp_gt - 0.1 * DELTA * exp_dt\n        \n        # g = dy/dt - M*y\n        g1 = dy1_dt - (-lam1 * y1_exact)\n        g2 = dy2_dt - (lam1 * y1_exact - lam2 * y2_exact)\n        g3 = -g1 - g2\n        \n        return np.array([g1, g2, g3]).T.reshape(-1, 3)\n\n    def f_ode(t, y, M, lam1, lam2):\n        \"\"\"RHS of the ODE: f(t, y) = M*y + g(t)\"\"\"\n        return M @ y + g_forcing(t, lam1, lam2).flatten()\n\n    def solve_rk4(M, lam1, lam2, y0, tf, dt):\n        \"\"\"Integrates the ODE system using the classical RK4 method.\"\"\"\n        t = T0\n        y = y0.copy()\n        num_steps = int(round((tf - T0) / dt))\n        \n        for _ in range(num_steps):\n            k1 = f_ode(t, y, M, lam1, lam2)\n            k2 = f_ode(t + 0.5 * dt, y + 0.5 * dt * k1, M, lam1, lam2)\n            k3 = f_ode(t + 0.5 * dt, y + 0.5 * dt * k2, M, lam1, lam2)\n            k4 = f_ode(t + dt, y + dt * k3, M, lam1, lam2)\n            y += (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n            t += dt\n        \n        return y\n\n    def solve_tr(M, lam1, lam2, y0, tf, dt):\n        \"\"\"Integrates the ODE system using the Trapezoidal Rule.\"\"\"\n        t = T0\n        y = y0.copy()\n        num_steps = int(round((tf - T0) / dt))\n        \n        I = np.identity(3)\n        A = I - (dt / 2.0) * M\n        B = I + (dt / 2.0) * M\n        \n        for _ in range(num_steps):\n            t_n = t\n            t_np1 = t + dt\n            \n            g_n = g_forcing(t_n, lam1, lam2).flatten()\n            g_np1 = g_forcing(t_np1, lam1, lam2).flatten()\n            \n            rhs = B @ y + (dt / 2.0) * (g_n + g_np1)\n            y = np.linalg.solve(A, rhs)\n            t = t_np1\n            \n        return y\n\n    test_cases = [\n        # Case 1: (lambda1, lambda2, t_f, {Delta t})\n        (10**2, 10, 2*10**-2, np.array([2e-3, 1e-3, 5e-4, 2.5e-4])),\n        # Case 2\n        (10**4, 10**3, 2*10**-3, np.array([2e-4, 1e-4, 5e-5, 2.5e-5])),\n        # Case 3\n        (2*10**4, 5*10**3, 10**-3, np.array([2e-4, 1e-4, 5e-5, 2.5e-5])),\n    ]\n\n    results = []\n    \n    for lam1, lam2, tf, dt_list in test_cases:\n        M = np.array([[-lam1, 0, 0], [lam1, -lam2, 0], [0, lam2, 0]], dtype=float)\n        y0 = y_exact(T0).flatten()\n        y_final_exact = y_exact(tf).flatten()\n        \n        errors_rk4 = []\n        errors_tr = []\n        \n        for dt in dt_list:\n            y_final_rk4 = solve_rk4(M, lam1, lam2, y0, tf, dt)\n            error_rk4 = np.linalg.norm(y_final_rk4 - y_final_exact)\n            errors_rk4.append(error_rk4)\n            \n            y_final_tr = solve_tr(M, lam1, lam2, y0, tf, dt)\n            error_tr = np.linalg.norm(y_final_tr - y_final_exact)\n            errors_tr.append(error_tr)\n\n        log_dt = np.log10(dt_list)\n        \n        log_err_rk4 = np.log10(np.array(errors_rk4, dtype=float))\n        if np.any(np.isinf(log_err_rk4)) or np.any(np.isnan(log_err_rk4)):\n            p_rk4 = 0.0\n        else:\n            p_rk4 = np.polyfit(log_dt, log_err_rk4, 1)[0]\n        \n        log_err_tr = np.log10(np.array(errors_tr, dtype=float))\n        if np.any(np.isinf(log_err_tr)) or np.any(np.isnan(log_err_tr)):\n            p_tr = 0.0\n        else:\n            p_tr = np.polyfit(log_dt, log_err_tr, 1)[0]\n        \n        r_rk4 = 1 if p_rk4  (4.0 - 0.5) else 0\n        r_tr = 1 if p_tr  (2.0 - 0.5) else 0\n        \n        results.extend([p_rk4, p_tr, r_rk4, r_tr])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3577003"}]}