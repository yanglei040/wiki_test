{"hands_on_practices": [{"introduction": "在计算核物理中，将复杂的理论模型转化为可用的数值形式是至关重要的一步。这个练习将指导您完成这一基本流程，从一个简化的对称核物质能量密度泛函出发，根据实验观测值（如饱和密度和结合能）来确定模型参数。然后，您将学习如何生成状态方程 (EoS) 的数值表格，并利用数值方法检验其热力学自洽性和因果性等基本物理属性，这是构建任何可靠 EoS 的基石 [@problem_id:3605352]。", "problem": "必须对冷对称核物质状态方程进行数值制表、插值，并检查其热力学一致性和物理因果性。请在以下框架内完成工作，该框架基于零温热力学和标准的动能加相互作用模型。\n\n使用以下基本定义和事实作为起点：\n- 在零温度下，单位体积的能量密度为 $\\,\\varepsilon(n)\\,$，重子数密度为 $\\,n\\,$，重子化学势为 $\\,\\mu(n) = \\partial \\varepsilon / \\partial n\\,$，压强为 $\\,P(n) = n\\,\\mu(n) - \\varepsilon(n)\\,$。\n- 在光速 $\\,c=1\\,$ 的单位制中，声速的平方为 $\\,c_s^2 = dP/d\\varepsilon\\,$，为确保稳定性和因果性，该值必须满足 $0 \\le c_s^2 \\le 1$。\n- 在密度 $\\,n\\,$ 下的核物质不可压缩性为 $\\,K(n) = 9\\,\\frac{dP}{dn}\\,$。\n\n将每个重子的能量建模为非相对论费米气体动能项和两项相互作用之和，\n$$\ne(n) = e_{\\mathrm{kin}}(n) + \\alpha\\,\\left(\\frac{n}{n_0}\\right) + \\beta\\,\\left(\\frac{n}{n_0}\\right)^{\\sigma},\n$$\n并包含核子静止质量，以构成每个重子的总能量 $\\,e_{\\mathrm{tot}}(n) = m_N + e(n)\\,$，因此能量密度为 $\\,\\varepsilon(n) = n\\,e_{\\mathrm{tot}}(n)\\,$。此处，$\\,n_0 = 0.16\\,\\mathrm{fm}^{-3}\\,$ 是对称核物质的饱和密度，$\\,m_N = 939\\,\\mathrm{MeV}\\,$ 是核子质量，$\\,\\hbar c = 197.3269804\\,\\mathrm{MeV\\,fm}\\,$。对于自旋-同位旋简并度 $\\,g=4\\,$ 的对称核物质，费米动量为 $\\,k_F(n) = \\left(\\frac{3\\pi^2 n}{2}\\right)^{1/3}\\,$，每个重子的非相对论费米气体动能为\n$$\ne_{\\mathrm{kin}}(n) = \\frac{3}{5}\\,\\frac{(\\hbar c)^2\\,k_F(n)^2}{2\\,m_N}.\n$$\n对于给定的刚度指数 $\\,\\sigma > 1\\,$，通过在 $\\,n=n_0\\,$ 处施加两个基于物理的约束来确定相互作用参数 $\\,\\alpha\\,$ 和 $\\,\\beta\\,$：\n- 每个重子的能量为 $\\,e(n_0) = -16\\,\\mathrm{MeV}\\,$（饱和结合能）。\n- 压强满足 $\\,P(n_0) = 0\\,\\mathrm{MeV\\,fm}^{-3}\\,$（饱和条件）。\n\n为选定的 $\\,\\sigma\\,$ 确定 $\\,\\alpha\\,$ 和 $\\,\\beta\\,$ 后，使用 $\\,N\\,$ 个均匀分布的点，在密度区间 $\\,n \\in [n_{\\min}, n_{\\max}]\\,$（其中 $\\,n_{\\min} = 0.02\\,\\mathrm{fm}^{-3}\\,$）上构建 $\\,\\varepsilon(n)\\,$ 和 $\\,P(n)\\,$ 的数值表。使用分段三次埃尔米特插值多项式 (PCHIP) 构建两个独立的保形插值函数：一个用于 $\\,\\varepsilon(n)\\,$，另一个用于 $\\,P(n)\\,$。利用这些插值函数：\n- 通过 $\\,\\varepsilon(n)\\,$ 插值函数的导数计算 $\\,\\mu(n)\\,$，然后构建恒等压强 $\\,P_{\\mathrm{id}}(n) = n\\,\\mu(n) - \\varepsilon(n)\\,$。\n- 通过在一组跨越制表区间的探测密度上计算最大相对不一致性 $\\,\\max_n \\frac{|P_{\\mathrm{id}}(n) - P_{\\mathrm{tab}}(n)|}{|P_{\\mathrm{tab}}(n)| + \\delta}\\,$ 来量化独立插值的压强与恒等压强之间的热力学一致性，其中 $\\,P_{\\mathrm{tab}}(n)\\,$ 是来自压强插值函数的压强，$\\,\\delta = 10^{-12}\\,$ 是一个用于正则化分母的微小正数。\n- 使用两个插值函数的导数计算声速平方 $\\,c_s^2(n) = \\frac{dP/dn}{d\\varepsilon/dn}\\,$，并报告其在探测集上的最大值，以及一个布尔标志，指示在所有探测点上是否都满足 $0 \\le c_s^2(n) \\le 1$（稳定性和因果性）。\n- 使用在 $\\,n_0\\,$ 处求值的压强插值函数的导数，计算不可压缩性 $\\,K_0 = 9\\,\\frac{dP}{dn}\\big|_{n=n_0}\\,$，单位为 $\\mathrm{MeV}$。\n\n压强单位为 $\\mathrm{MeV\\,fm}^{-3}$，化学势单位为 $\\mathrm{MeV}$，能量密度单位为 $\\mathrm{MeV\\,fm}^{-3}$，不可压缩性单位为 $\\mathrm{MeV}$。本问题不使用角度。请勿使用百分比。\n\n实现程序以评估以下测试套件，该套件探讨了典型和边界情况下的行为：\n- 测试 $\\,1\\,$ (正常路径): $\\,\\sigma = 1.3\\,$, $\\,n_{\\max} = 0.8\\,\\mathrm{fm}^{-3}\\,$, $\\,N = 64\\,$.\n- 测试 $\\,2\\,$ (刚性边界情况): $\\,\\sigma = 2.0\\,$, $\\,n_{\\max} = 0.8\\,\\mathrm{fm}^{-3}\\,$, $\\,N = 32\\,$.\n- 测试 $\\,3\\,$ (软且粗糙的网格): $\\,\\sigma = 1.1\\,$, $\\,n_{\\max} = 0.4\\,\\mathrm{fm}^{-3}\\,$, $\\,N = 16\\,$.\n\n对于每个测试，使用相同的 $\\,n_{\\min} = 0.02\\,\\mathrm{fm}^{-3}\\,$，并在 $\\,[n_{\\min}, n_{\\max}]\\,$ 区间内的 $\\,32\\,$ 个均匀间隔的点上评估探测密度。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试的结果必须是一个四元列表 $[r_{\\max},\\,\\mathrm{causal},\\,K_0,\\,c_{s,\\max}^2]$，其中 $\\,r_{\\max}\\,$ 是最大相对不一致性（无量纲浮点数），$\\,\\mathrm{causal}\\,$ 是一个布尔值，$\\,K_0\\,$ 是以 $\\mathrm{MeV}$ 为单位的不可压缩性，$\\,c_{s,\\max}^2\\,$ 是最大声速平方（无量纲浮点数）。将三个测试结果汇总到一个列表中，例如 $[[r_1,\\mathrm{c}_1,K_{0,1},c_{s,1}^2],[r_2,\\mathrm{c}_2,K_{0,2},c_{s,2}^2],[r_3,\\mathrm{c}_3,K_{0,3},c_{s,3}^2]]$。", "solution": "该问题要求对冷对称核物质的简化状态方程（EOS）进行数值分析。这涉及从物理约束中确定模型参数，对EOS进行制表，创建插值函数，并验证热力学一致性和物理因果性。\n\n首先，我们建立相关物理量的解析形式。每个重子的能量 $e(n)$ 由非相对论动能项和两项唯象相互作用之和给出：\n$$\ne(n) = e_{\\mathrm{kin}}(n) + \\alpha\\,\\left(\\frac{n}{n_0}\\right) + \\beta\\,\\left(\\frac{n}{n_0}\\right)^{\\sigma}\n$$\n其中 $n$ 是重子数密度，$n_0 = 0.16\\,\\mathrm{fm}^{-3}$ 是饱和密度。对于自旋-同位旋简并度 $g=4$ 的简并费米气体，每个重子的动能为：\n$$\ne_{\\mathrm{kin}}(n) = \\frac{3}{5}\\,\\frac{(\\hbar c)^2\\,k_F(n)^2}{2\\,m_N} = \\frac{3}{10\\,m_N}(\\hbar c)^2 \\left(\\frac{3\\pi^2 n}{2}\\right)^{2/3}\n$$\n这里，$k_F(n)$ 是费米动量，$m_N = 939\\,\\mathrm{MeV}$ 是核子质量，$\\hbar c = 197.3269804\\,\\mathrm{MeV\\,fm}$。我们可以将 $e_{\\mathrm{kin}}(n)$ 写为 $e_{\\mathrm{kin}}(n) = C_{\\mathrm{kin}} n^{2/3}$，其中 $C_{\\mathrm{kin}}$ 是一个常数。\n\n总能量密度 $\\varepsilon(n)$ 包括核子静止质量：\n$$\n\\varepsilon(n) = n \\cdot (m_N + e(n)) = n\\,m_N + n\\,e(n)\n$$\n根据零温下的基本热力学，压强 $P(n)$ 通过吉布斯-杜亥姆关系与每个重子的能量相关联，可表示为 $P(n) = n^2 \\frac{\\partial e(n)}{\\partial n}$。化学势为 $\\mu(n) = \\frac{\\partial\\varepsilon(n)}{\\partial n}$。对 $e(n)$ 求导：\n$$\n\\frac{\\partial e(n)}{\\partial n} = \\frac{2}{3}C_{\\mathrm{kin}}n^{-1/3} + \\frac{\\alpha}{n_0} + \\frac{\\beta\\sigma}{n_0^\\sigma}n^{\\sigma-1}\n$$\n因此，压强为：\n$$\nP(n) = n^2 \\left( \\frac{2}{3}C_{\\mathrm{kin}}n^{-1/3} + \\frac{\\alpha}{n_0} + \\frac{\\beta\\sigma}{n_0^\\sigma}n^{\\sigma-1} \\right) = \\frac{2}{3} n \\,e_{\\mathrm{kin}}(n) + \\frac{\\alpha}{n_0}n^2 + \\frac{\\beta\\sigma}{n_0^\\sigma}n^{\\sigma+1}\n$$\n\n模型参数 $\\alpha$ 和 $\\beta$ 是为给定的刚度指数 $\\sigma$ 通过在饱和密度 $n_0$ 处施加两个条件来确定的：\n1.  每个重子的结合能为 $e(n_0) = -16\\,\\mathrm{MeV}$。\n2.  冷核物质的压强为零，$P(n_0) = 0\\,\\mathrm{MeV\\,fm}^{-3}$。\n\n将第一个条件应用于 $e(n)$ 的表达式：\n$$\ne_{\\mathrm{kin}}(n_0) + \\alpha + \\beta = -16\\,\\mathrm{MeV} \\implies \\alpha + \\beta = -16 - e_{\\mathrm{kin}}(n_0)\n$$\n将第二个条件应用于 $P(n)$ 的表达式：\n$$\n\\frac{2}{3} n_0 e_{\\mathrm{kin}}(n_0) + \\alpha n_0 + \\beta\\sigma n_0 = 0\n$$\n由于 $n_0 \\neq 0$，我们可以用它来除，得到：\n$$\n\\frac{2}{3} e_{\\mathrm{kin}}(n_0) + \\alpha + \\sigma\\beta = 0 \\implies \\alpha + \\sigma\\beta = -\\frac{2}{3}e_{\\mathrm{kin}}(n_0)\n$$\n这构成了关于 $\\alpha$ 和 $\\beta$ 的二元线性方程组。用第二个方程减去第一个方程得到：\n$$\n(\\sigma - 1)\\beta = \\left(-\\frac{2}{3}e_{\\mathrm{kin}}(n_0)\\right) - \\left(-16 - e_{\\mathrm{kin}}(n_0)\\right) = 16 + \\frac{1}{3}e_{\\mathrm{kin}}(n_0)\n$$\n对于 $\\sigma > 1$，我们可以解出 $\\beta$：\n$$\n\\beta = \\frac{16 + \\frac{1}{3}e_{\\mathrm{kin}}(n_0)}{\\sigma - 1}\n$$\n然后，通过代入法求得 $\\alpha$：\n$$\n\\alpha = -16 - e_{\\mathrm{kin}}(n_0) - \\beta\n$$\n\n确定 $\\alpha$ 和 $\\beta$ 后，$\\varepsilon(n)$ 和 $P(n)$ 的解析函数就完全确定了。数值步骤如下：\n1.  对于给定的测试用例 $(\\sigma, n_{\\max}, N)$，我们首先计算 $e_{\\mathrm{kin}}(n_0)$ 并求解 $\\alpha$ 和 $\\beta$。\n2.  我们生成一个从 $n_{\\min}=0.02\\,\\mathrm{fm}^{-3}$ 到 $n_{\\max}$ 的包含 $N$ 个密度点的均匀网格 $n_i$。\n3.  我们在此网格上评估 $\\varepsilon(n_i)$ 和 $P(n_i)$，创建两个数据表。\n4.  使用分段三次埃尔米特插值多项式 (PCHIP) 方法从这些数据表构造两个独立的保形插值函数 $\\varepsilon_{\\mathrm{interp}}(n)$ 和 $P_{\\mathrm{interp}}(n)$。选择此方法是因为它能保持原始数据的单调性，这对状态方程来说是一个关键的物理性质。\n\n分析在一个更精细的、跨越 $[n_{\\min}, n_{\\max}]$ 的包含 $32$ 个探测密度的网格上进行：\n-   **热力学一致性**：我们检查基本关系 $P(n) = n\\,\\mu(n) - \\varepsilon(n)$。我们计算“恒等压强” $P_{\\mathrm{id}}(n) = n\\,\\mu_{\\mathrm{interp}}(n) - \\varepsilon_{\\mathrm{interp}}(n)$，其中 $\\mu_{\\mathrm{interp}}(n) = \\frac{d\\varepsilon_{\\mathrm{interp}}}{dn}$ 是通过对能量密度插值函数求导得到的。将其与独立压强插值函数得到的压强 $P_{\\mathrm{tab}}(n) = P_{\\mathrm{interp}}(n)$ 进行比较。最大相对不一致性 $r_{\\max} = \\max_n \\frac{|P_{\\mathrm{id}}(n) - P_{\\mathrm{tab}}(n)|}{|P_{\\mathrm{tab}}(n)| + \\delta}$ 量化了由独立插值引入的数值误差。小常数 $\\delta=10^{-12}$ 防止除以零。\n-   **因果性**：声速平方由 $c_s^2 = \\frac{dP}{d\\varepsilon} = \\frac{dP/dn}{d\\varepsilon/dn}$ 给出。我们通过对 $P(n)$ 和 $\\varepsilon(n)$ 的 PCHIP 插值函数求导来计算此量。然后我们找到 $c_s^2$ 在所有探测密度上的最大值，并验证稳定性和因果性条件 $0 \\le c_s^2 \\le 1$ 对所有探测点都成立。\n-   **不可压缩性**：饱和密度下的核不可压缩性 $K_0$ 是一个关键的物理可观测量。其定义为 $K(n) = 9\\frac{dP}{dn}$。我们将其计算为 $K_0 = 9 \\frac{dP_{\\mathrm{interp}}}{dn}\\big|_{n=n_0}$。导数是在 $n=n_0$ 处从压强插值函数数值计算得出的。$dP/dn$ 的单位是 $\\mathrm{MeV/fm^3} / \\mathrm{fm^{-3}} = \\mathrm{MeV}$，因此 $K_0$ 的单位正确地报告为 $\\mathrm{MeV}$。\n\n这种结构化方法使我们能够严格测试所建模型的EOS属性以及所用数值方法的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the nuclear equation of state problem for a given set of test cases.\n    \"\"\"\n    \n    # Define physical constants\n    N0 = 0.16  # Saturation density in fm^-3\n    MN = 939.0  # Nucleon mass in MeV\n    HBARC = 197.3269804  # h-bar * c in MeV fm\n    E_SAT = -16.0  # Saturation binding energy in MeV\n    DELTA = 1.0e-12 # Regularization parameter\n\n    # Define test cases: (sigma, n_max, N_grid_points)\n    test_cases = [\n        (1.3, 0.8, 64),\n        (2.0, 0.8, 32),\n        (1.1, 0.4, 16),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        sigma, n_max, N_grid = case\n        n_min = 0.02\n        \n        # --- Helper functions for analytical expressions ---\n        def e_kin(n):\n            \"\"\"Non-relativistic kinetic energy per baryon.\"\"\"\n            kF_sq = (1.5 * np.pi**2 * n)**(2.0/3.0)\n            return (3.0/5.0) * (HBARC**2 * kF_sq) / (2.0 * MN)\n\n        # --- Parameter determination ---\n        e_kin_n0 = e_kin(N0)\n        \n        # From constraint equations:\n        # (I)  alpha + beta = E_SAT - e_kin_n0\n        # (II) alpha + sigma * beta = -2/3 * e_kin_n0\n        beta = (E_SAT + (1.0/3.0) * e_kin_n0) / (1.0 - sigma) # Simplified from (- (E_SAT-e_kin_n0) - 2/3*e_kin_n0)/(sigma-1)\n        beta = (16.0 + (1.0/3.0) * e_kin_n0) / (sigma - 1.0) # Derivation in solution text match\n        \n        alpha = E_SAT - e_kin_n0 - beta\n\n        # --- Full analytical expressions for tabulation ---\n        def e_baryon(n, alpha, beta, sigma):\n            \"\"\"Total energy per baryon (excluding rest mass).\"\"\"\n            return e_kin(n) + alpha * (n / N0) + beta * (n / N0)**sigma\n\n        def energy_density(n, alpha, beta, sigma):\n            \"\"\"Energy density (including rest mass).\"\"\"\n            return n * (MN + e_baryon(n, alpha, beta, sigma))\n\n        def pressure(n, alpha, beta, sigma):\n            \"\"\"Pressure.\"\"\"\n            # From P(n) = n^2 * d(e(n))/dn\n            term_kin = (2.0/3.0) * n * e_kin(n)\n            term_alpha = alpha * n**2 / N0\n            term_beta = beta * sigma * n**(sigma + 1) / (N0**sigma)\n            return term_kin + term_alpha + term_beta\n\n        # --- Tabulation and Interpolation ---\n        n_grid = np.linspace(n_min, n_max, N_grid)\n        eps_grid = energy_density(n_grid, alpha, beta, sigma)\n        p_grid = pressure(n_grid, alpha, beta, sigma)\n        \n        eps_interp = PchipInterpolator(n_grid, eps_grid)\n        p_interp = PchipInterpolator(n_grid, p_grid)\n\n        # --- Analysis on probe grid ---\n        n_probe = np.linspace(n_min, n_max, 32)\n\n        # 1. Thermodynamic consistency\n        eps_probe = eps_interp(n_probe)\n        mu_probe = eps_interp(n_probe, 1) # Derivative d(eps)/dn\n        p_id_probe = n_probe * mu_probe - eps_probe\n        p_tab_probe = p_interp(n_probe)\n        \n        rel_incon_probe = np.abs(p_id_probe - p_tab_probe) / (np.abs(p_tab_probe) + DELTA)\n        r_max = np.max(rel_incon_probe)\n\n        # 2. Causality and speed of sound\n        dPdN_probe = p_interp(n_probe, 1)\n        dEpsdN_probe = mu_probe # d(eps)/dn\n        # To avoid division by zero or negative if d(eps)/dn is ill-behaved\n        # a safe division is appropriate. For this problem, d(eps)/dn > 0 expected.\n        cs2_probe = np.divide(dPdN_probe, dEpsdN_probe, \n                              out=np.full_like(dPdN_probe, -1.0), \n                              where=dEpsdN_probe>0)\n        \n        cs2_max = np.max(cs2_probe)\n        is_causal = bool(np.all((cs2_probe >= 0)  (cs2_probe = 1)))\n\n        # 3. Incompressibility at saturation\n        dPdN_at_n0 = p_interp(N0, 1)\n        K0 = 9.0 * dPdN_at_n0\n\n        all_results.append([r_max, is_causal, K0, cs2_max])\n\n    # --- Final Output Formatting ---\n    # Convert list of lists to the required string format\n    outer_parts = []\n    for inner_list in all_results:\n        # Manually format each item to string, bool becomes 'True'/'False'\n        inner_parts = [\n            f\"{inner_list[0]:.10e}\", \n            str(inner_list[1]),\n            f\"{inner_list[2]:.10e}\",\n            f\"{inner_list[3]:.10e}\"\n        ]\n        # It's better to use a high-precision float format to avoid ambiguity\n        # but for this problem, default str is probably fine too.\n        # Let's revert to simple str() for all but boolean as problem doesn't specify precision.\n        # However, boolean has to be capitalised True/False.\n        inner_parts_str = [str(item) for item in inner_list]\n        outer_parts.append(f\"[{','.join(inner_parts_str)}]\")\n    \n    print(f\"[{','.join(outer_parts)}]\")\n\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3605352"}, {"introduction": "在建立了基本的 EoS 模型并生成数值表格后，确保我们的计算框架严格遵守物理学基本定律是至关重要的一步。本练习将引导您通过数值方法，去验证一系列深刻的热力学恒等式，例如 Hugenholtz-Van Hove 定理和 Maxwell 关系。通过这项实践，您不仅能加深对核物质多体理论的理解，还能掌握验证代码正确性和数值稳定性的关键技能，从而对您的计算结果建立信心 [@problem_id:3605373]。", "problem": "要求你编写一个完整的独立程序，使用求和规则和恒等式检验列表，来验证参数化核物质状态方程的热力学自洽性。该系统是零温下的均匀、对称核物质。请在一个单位制中进行计算，其中能量以兆电子伏特（MeV）度量，长度以费米（fm）度量，即所有能量单位为 MeV，所有密度单位为 $\\mathrm{fm}^{-3}$；你计算的任何中间量都应使用这些单位表示。最终输出是布尔值，无单位。\n\n从以下关于零温均匀物质的基本定义和经过充分检验的事实出发。令 $n$ 表示重子数密度，$e(n)$ 表示除静止质量外的每重子能量，$\\epsilon(n)$ 表示包括静止质量在内的能量密度，$\\mu(n)$ 表示重子化学势，$P(n)$ 表示压强。热力学微分恒等式是 $d\\epsilon = \\mu \\, dn$，压强的定义是 $P = n \\, \\mu - \\epsilon$，声速平方是 $c_s^2 = \\partial P / \\partial \\epsilon$。对于对称核物质，两种核子（质子和中子）的密度均为 $n/2$，费米动量为 $k_F(n) = (3\\pi^2 n / 2)^{1/3}$。零温费米气体每重子动能为 $e_{\\mathrm{kin}}(n) = \\frac{3}{5}\\frac{\\hbar^2 k_F(n)^2}{2m}$，计算时应使用 $\\hbar^2/(2m) = 20.735 \\, \\mathrm{MeV}\\,\\mathrm{fm}^2$ 和核子静止质量 $m = 939 \\, \\mathrm{MeV}$。相互作用由一个最小的类Skyrme参数化形式建模\n$$\ne(n) = e_{\\mathrm{kin}}(n) + A \\, n + B \\, n^{\\sigma},\n$$\n其中 $A$ 和 $B$ 是常数，其单位的选择使得 $A\\,n$ 和 $B\\,n^{\\sigma}$ 的单位均为 $\\mathrm{MeV}$，而 $\\sigma$ 是无量纲的。\n\n你的程序必须根据上述定义实现以下计算，所有关于密度的导数均使用对称中心差分法进行数值计算，固定步长为 $h = 1.0\\times 10^{-5} \\, \\mathrm{fm}^{-3}$：\n- 计算 $\\epsilon(n) = n \\, \\big(e(n) + m\\big)$。\n- 通过对 $\\epsilon(n)$ 关于 $n$ 进行数值微分，直接从 $\\mu(n) = \\partial \\epsilon / \\partial n$ 计算 $\\mu(n)$。\n- 根据定义 $P(n) = n \\, \\mu(n) - \\epsilon(n)$ 计算 $P(n)$，并独立地通过 $P(n) = n^2 \\, \\partial e/\\partial n$（使用 $e(n)$ 的数值微分）计算；在对 $P(n)$ 关于 $n$ 微分时，请使用后一个定义。\n- 计算 $c_s^2(n) = \\big(\\partial P/\\partial n\\big) \\big/ \\big(\\partial \\epsilon/\\partial n\\big)$。\n\n使用这些定义，你的程序必须在数值上验证以下恒等式和条件，每个等式的相对容差为 $1.0\\times 10^{-5}$，绝对容差为 $1.0\\times 10^{-6}$：\n1. 均匀物质的Hugenholtz–Van Hove (HVH) 定理等式：对于测试套件中的每个密度，验证从 $\\mu(n) = \\partial \\epsilon/\\partial n$ 计算出的化学势等于组合 $\\mu_{\\mathrm{HVH}}(n) \\equiv e(n) + P(n)/n + m$。\n2. 在此背景下的类麦克斯韦自洽关系：对于测试套件中的每个密度，验证 $\\partial P/\\partial n$ 等于 $n \\, \\partial \\mu/\\partial n$，其中 $\\partial \\mu/\\partial n$ 是通过对你数值计算出的 $\\mu(n)$ 进行微分得到的。\n3. 饱和密度 $n_0$ 处的不可压缩性恒等式：首先在区间 $[0.08, 0.20] \\, \\mathrm{fm}^{-3}$ 内最小化 $e(n)$ 来找到 $n_0$；然后验证 $K_1 \\equiv 9 \\, n_0^2 \\, \\partial^2 e / \\partial n^2 \\big|_{n_0}$ 等于 $K_2 \\equiv 9 \\, \\partial P/\\partial n \\big|_{n_0}$。\n4. 因果性条件：对于测试套件中的每个密度，验证 $c_s^2(n) \\le 1$，其中在自然单位制（光速 $c = 1$）下 $c_s^2$ 是无量纲的。\n\n你的测试套件包含以下三个参数集 $(A,B,\\sigma)$以及执行检查的密度集：\n- 参数集 $\\mathrm{S1}$（物理上典型，中等硬度）：$A = -620.0 \\, \\mathrm{MeV}\\,\\mathrm{fm}^3$，$B = 480.0 \\, \\mathrm{MeV}\\,\\mathrm{fm}^{3\\sigma}$，$\\sigma = 7/6 \\approx 1.1666666667$。\n- 参数集 $\\mathrm{S2}$（软）：$A = -680.0 \\, \\mathrm{MeV}\\,\\mathrm{fm}^3$，$B = 420.0 \\, \\mathrm{MeV}\\,\\mathrm{fm}^{3\\sigma}$，$\\sigma = 1.0$。\n- 参数集 $\\mathrm{S3}$（高密度下硬）：$A = -770.0 \\, \\mathrm{MeV}\\,\\mathrm{fm}^3$，$B = 1300.0 \\, \\mathrm{MeV}\\,\\mathrm{fm}^{3\\sigma}$，$\\sigma = 1.5$。\n- 待检查的密度：$n \\in \\{0.08, 0.16, 0.32, 1.00\\} \\, \\mathrm{fm}^{-3}$。\n\n对于每个参数集，生成四个布尔值：\n- 第一个布尔值，如果Hugenholtz–Van Hove定理等式在所有指定密度下都成立，则为真，否则为假。\n- 第二个布尔值，如果不可压缩性恒等式在给定区间内找到的饱和密度处成立，则为真，否则为假。\n- 第三个布尔值，如果类麦克斯韦自洽关系在所有指定密度下都成立，则为真，否则为假。\n- 第四个布尔值，如果因果性条件在所有指定密度下都成立，则为真，否则为假。\n\n你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个元素是对应一个参数集的四个布尔值的列表，顺序为 $\\mathrm{S1}$、$\\mathrm{S2}$、$\\mathrm{S3}$；例如，一个有效的输出格式是 $[[\\mathrm{True},\\mathrm{True},\\mathrm{True},\\mathrm{True}],[\\dots],[\\dots]]$。", "solution": "此问题是有效的，因为它在科学上基于标准的核多体理论，问题陈述清晰完备，提供了所有必要信息，并构成了计算物理学中一个有意义的练习。拟议的任务是通过一系列基于基本恒等式的检验，来验证参数化核物质状态方程（EoS）的热力学自洽性。\n\n模型的核心是零温下均匀对称核物质的每重子能量 $e(n)$。它由动能项和势能项组成。对于双组分费米气体，每重子动能由 $e_{\\mathrm{kin}}(n) = \\frac{3}{5}\\frac{\\hbar^2 k_F(n)^2}{2m}$ 给出，其中 $k_F(n) = (3\\pi^2 n / 2)^{1/3}$ 是重子数密度为 $n$ 时的费米动量。使用提供的常数 $\\hbar^2/(2m) = 20.735 \\, \\mathrm{MeV}\\,\\mathrm{fm}^2$，这可以写成 $e_{\\mathrm{kin}}(n) = C_{kin} n^{2/3}$，其中 $C_{kin} = \\frac{3}{5} (20.735 \\, \\mathrm{MeV}\\,\\mathrm{fm}^2) (\\frac{3\\pi^2}{2})^{2/3}$。势能由一个类Skyrme形式建模，$e_{\\mathrm{pot}}(n) = A \\, n + B \\, n^{\\sigma}$。因此，总的每重子能量（不包括静止质量）是 $e(n) = C_{kin} n^{2/3} + A \\, n + B \\, n^{\\sigma}$。\n\n从这个基本量，可以导出所有其他热力学性质。能量密度 $\\epsilon(n)$ 包括每个重子的静止质量能量 $m = 939 \\, \\mathrm{MeV}$：$\\epsilon(n) = n \\big(e(n) + m\\big)$。重子化学势 $\\mu(n)$ 是能量密度对数密度的导数，$\\mu(n) = \\partial \\epsilon / \\partial n$。压强 $P(n)$ 可以通过两种等效的热力学方式定义：首先，通过欧拉关系 $P(n) = n\\mu(n) - \\epsilon(n)$；其次，作为 $P(n) = n^2 \\partial e/\\partial n$。问题要求我们从 $\\epsilon(n)$ 数值计算 $\\mu(n)$，然后在需要 $P(n)$ 的值时使用第一种定义。然而，对于任何涉及压强导数 $\\partial P/\\partial n$ 的计算，我们被指示使用第二种形式，$P(n) = n^2 \\partial e/\\partial n$。这对于实现来说是一个至关重要的区别。所有关于密度 $n$ 的导数都应使用对称中心差分方案进行数值计算，步长为 $h = 1.0\\times 10^{-5} \\, \\mathrm{fm}^{-3}$。函数 $f(n)$ 的一阶导数近似为 $(f(n+h) - f(n-h))/(2h)$，二阶导数近似为 $(f(n+h) - 2f(n) + f(n-h))/h^2$。\n\n有了这些定义，我们对每个给定的参数集 $(A, B, \\sigma)$ 进行四项验证检查。\n\n1.  **Hugenholtz–Van Hove (HVH) 定理**：该定理指出，对于一个处于饱和压强（$P=0$）的系统，每粒子能量等于化学势。更一般地，它意味着关系式 $\\mu(n) = e(n) + P(n)/n + m$。检查是为了验证通过数值微分直接计算的化学势 $\\mu(n) = \\partial\\epsilon/\\partial n$ 是否等于表达式 $\\mu_{\\mathrm{HVH}}(n) \\equiv e(n) + P(n)/n + m$。由于问题指定使用 $P(n) = n\\mu(n) - \\epsilon(n)$ 并且我们知道 $\\epsilon(n) = n(e(n)+m)$，此检查简化为一个代数恒等式：$\\mu_{\\mathrm{HVH}}(n) = e(n) + (n\\mu(n) - n(e(n)+m))/n + m = e(n) + \\mu(n) - (e(n)+m) + m = \\mu(n)$。因此，此测试可用于验证实现的数值自洽性。该检查在每个指定密度下执行，如果等式在所有密度下都在给定的容差（$rtol = 1.0\\times 10^{-5}$，$atol = 1.0\\times 10^{-6}$）内成立，则总体结果为真。\n\n2.  **不可压缩性恒等式**：饱和密度 $n_0$ 处的核不可压缩性也可以用两种等效的方式表示。饱和密度 $n_0$ 是 $e(n)$ 取最小值的密度，即 $\\partial e/\\partial n \\big|_{n_0} = 0$。我们首先通过在区间 $[0.08, 0.20] \\, \\mathrm{fm}^{-3}$ 上数值最小化 $e(n)$ 来找到 $n_0$。然后我们验证 $K_1 \\equiv 9 \\, n_0^2 \\, \\partial^2 e / \\partial n^2 \\big|_{n_0}$ 和 $K_2 \\equiv 9 \\, \\partial P/\\partial n \\big|_{n_0}$ 的相等性。为了计算 $K_2$，我们使用 $P(n) = n^2 \\partial e/\\partial n$ 的形式。解析上，$\\partial P/\\partial n = 2n(\\partial e/\\partial n) + n^2(\\partial^2 e/\\partial n^2)$。在 $n=n_0$ 处，第一项消失，因此 $\\partial P/\\partial n \\big|_{n_0} = n_0^2 \\partial^2 e/\\partial n^2 \\big|_{n_0}$，这证实了 $K_1=K_2$ 是一个恒等式。因此，此检验测试了一阶和二阶数值导数的正确性。\n\n3.  **类麦克斯韦自洽关系**：此检验验证恒等式 $\\partial P/\\partial n = n \\, \\partial \\mu/\\partial n$。此关系直接源于热力学定义 $P = n\\mu - \\epsilon$ 和 $\\mu = \\partial\\epsilon/\\partial n$。对 $P$ 微分得到 $\\partial P/\\partial n = (\\partial/\\partial n)(n\\mu - \\epsilon) = \\mu + n(\\partial\\mu/\\partial n) - \\partial\\epsilon/\\partial n$。代入 $\\mu = \\partial\\epsilon/\\partial n$ 得到 $\\partial P/\\partial n = n \\, \\partial \\mu/\\partial n$。对于数值测试，$\\partial P/\\partial n$ 是通过对 $P(n) = n^2 \\partial e/\\partial n$ 微分来计算的，而 $\\partial \\mu/\\partial n$ 是通过对数值获得的 $\\mu(n) = \\partial\\epsilon/\\partial n$ 微分来计算的。此检验探究了嵌套数值微分的自洽性。它在所有指定密度下执行。\n\n4.  **因果性条件**：物理信号的传播速度不能超过光速 $c$。这施加了声速 $c_s$ 必须小于或等于 $c$ 的条件。在 $c=1$ 的单位中，这意味着 $c_s^2 \\le 1$。声速平方由 $c_s^2(n) = \\partial P / \\partial \\epsilon = (\\partial P/\\partial n) / (\\partial \\epsilon/\\partial n)$ 给出。这是对EoS参数的物理约束，而不是数学恒等式。违反该条件表明参数集导致了非物理的状态方程，至少在发生违规的密度下是如此。此检查在所有指定密度下执行。\n\n该算法遍历三个参数集（S1、S2、S3），构建相应的函数 $e(n)$ 和 $\\epsilon(n)$，然后执行这四项检查，为每项检查生成一个布尔结果。最终输出是一个列表，其中包含每个参数集的四元素布尔值列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef solve():\n    \"\"\"\n    Validates thermodynamic consistency of parameterized nuclear matter equations\n    of state using sum rules and identity checklists.\n    \"\"\"\n    # Define physical and numerical constants\n    HBAR2_OVER_2M = 20.735  # MeV fm^2\n    M_NUCLEON = 939.0      # MeV\n    H_STEP = 1.0e-5        # fm^-3\n    RTOL = 1.0e-5\n    ATOL = 1.0e-6\n\n    # Test suite from the problem statement\n    test_params = [\n        # (A, B, sigma)\n        (-620.0, 480.0, 7.0/6.0), # S1\n        (-680.0, 420.0, 1.0),     # S2\n        (-770.0, 1300.0, 1.5),    # S3\n    ]\n    test_densities = [0.08, 0.16, 0.32, 1.00]\n\n    # --- Numerical derivative helpers ---\n    def df_dn(f, n, h=H_STEP):\n        \"\"\"Symmetric central difference for the first derivative.\"\"\"\n        if n = h: # Use forward difference at boundary\n             return (f(n + h) - f(n)) / h\n        return (f(n + h) - f(n - h)) / (2 * h)\n\n    def d2f_dn2(f, n, h=H_STEP):\n        \"\"\"Symmetric central difference for the second derivative.\"\"\"\n        return (f(n + h) - 2 * f(n) + f(n - h)) / (h * h)\n\n    # --- Main checking logic for a given parameter set ---\n    def perform_checks(params):\n        A, B, sigma = params\n\n        # --- Define core physics functions for this parameter set ---\n        c_kin = (3./5.) * HBAR2_OVER_2M * (3. * np.pi**2 / 2.)**(2./3.)\n        \n        def e_func(n):\n            if n = 0: return np.inf\n            return c_kin * n**(2./3.) + A * n + B * n**sigma\n\n        def epsilon_func(n):\n            if n = 0: return 0\n            return n * (e_func(n) + M_NUCLEON)\n\n        # --- 1. Hugenholtz-Van Hove (HVH) Theorem Check ---\n        def check_hvh():\n            for n in test_densities:\n                mu_from_deriv = df_dn(epsilon_func, n)\n                p_from_mu = n * mu_from_deriv - epsilon_func(n)\n                mu_from_hvh = e_func(n) + p_from_mu / n + M_NUCLEON\n                if not np.isclose(mu_from_deriv, mu_from_hvh, rtol=RTOL, atol=ATOL):\n                    return False\n            return True\n\n        # --- 2. Incompressibility Identity Check ---\n        def check_incompressibility():\n            res = minimize_scalar(e_func, bounds=(0.08, 0.20), method='bounded')\n            n0 = res.x\n            \n            k1 = 9 * n0**2 * d2f_dn2(e_func, n0)\n            \n            # Define P(n) = n^2 * de/dn for differentiation\n            de_dn = lambda n_val: df_dn(e_func, n_val)\n            p_from_e_deriv = lambda n_val: n_val**2 * de_dn(n_val)\n            dp_dn_at_n0 = df_dn(p_from_e_deriv, n0)\n            \n            k2 = 9 * dp_dn_at_n0\n            \n            return np.isclose(k1, k2, rtol=RTOL, atol=ATOL)\n\n        # --- 3. Maxwell-type Consistency Relation Check ---\n        def check_maxwell():\n            # Define mu(n) = depsilon/dn\n            mu_func = lambda n_val: df_dn(epsilon_func, n_val)\n            # Define P(n) = n^2 * de/dn\n            de_dn = lambda n_val: df_dn(e_func, n_val)\n            p_from_e_deriv = lambda n_val: n_val**2 * de_dn(n_val)\n\n            for n in test_densities:\n                dp_dn_val = df_dn(p_from_e_deriv, n)\n                dmu_dn_val = df_dn(mu_func, n)\n                if not np.isclose(dp_dn_val, n * dmu_dn_val, rtol=RTOL, atol=ATOL):\n                    return False\n            return True\n\n        # --- 4. Causality Condition Check ---\n        def check_causality():\n            # Define P(n) = n^2 * de/dn\n            de_dn = lambda n_val: df_dn(e_func, n_val)\n            p_from_e_deriv = lambda n_val: n_val**2 * de_dn(n_val)\n\n            for n in test_densities:\n                dp_dn_val = df_dn(p_from_e_deriv, n)\n                depsilon_dn_val = df_dn(epsilon_func, n)\n                \n                if depsilon_dn_val = 0: # Should not happen physically\n                    return False\n                \n                cs2 = dp_dn_val / depsilon_dn_val\n                if cs2 > 1.0:\n                    return False\n            return True\n\n        # --- Execute all checks and return results ---\n        return [check_hvh(), check_incompressibility(), check_maxwell(), check_causality()]\n\n    # --- Main loop over parameter sets ---\n    final_results = []\n    for params in test_params:\n        final_results.append(perform_checks(params))\n        \n    # Final print statement in the exact required format.\n    # Convert Python boolean to lowercase string 'true'/'false' for JS-like format\n    str_results = [[str(b).lower() for b in res] for res in final_results]\n    output_str = '[' + ','.join(['[' + ','.join(res) + ']' for res in str_results]) + ']'\n    # The problem description shows \"True\" not \"true\". Let's stick to Python standard str().\n    output_str = str(final_results).replace(\" \", \"\")\n\n    print(output_str)\n\nsolve()\n```", "id": "3605373"}, {"introduction": "为了将我们的模型应用于中子星等真实的天体物理环境，我们必须超越理想化的对称核物质，考虑由中子、质子和电子组成的贝塔平衡物质。这个练习将带您迈出关键一步：求解在给定重子数密度下，由化学势平衡决定的质子浓度。您将通过构建并求解一个非线性方程组来掌握这一核心技能，并为牛顿法求解器推导和实现解析雅可比矩阵，这对于确保数值求解的效率和鲁棒性至关重要 [@problem_id:3605364]。", "problem": "您将使用一个简化但科学上标准的核物质状态方程模型，为处于 β 平衡和电荷中性下的冷催化核物质实现一个算法组分求解器。物质的组分由质子分数描述，质子分数是质子数密度与重子数密度之比。目标是通过一个使用解析雅可比矩阵的稳健的牛顿型方法，在给定的重子密度下计算质子分数。\n\n物理设置如下。考虑由中子、质子和电子组成的均匀、冷的核物质。假设在零温下，核子和电子为简并费米气体，其中核子作非相对论性处理，电子作超相对论性处理。核相互作用通过抛物线近似中的对称能贡献来描述。模型为：\n\n- 重子数密度：$n_b$，其中 $n_b = n_n + n_p$，$n_n$ 和 $n_p$ 分别是中子和质子的数密度。\n- 质子分数：$Y_p = n_p/n_b$。\n- 电荷中性：$n_e = n_p$。\n- β 平衡：$\\mu_n - \\mu_p = \\mu_e$，其中 $\\mu_n$、$\\mu_p$、$\\mu_e$ 分别是中子、质子和电子的化学势。\n- 核子动能密度（非相对论性简并费米气体）：对于 $i \\in \\{n,p\\}$，$\\epsilon_i^{\\mathrm{FG}}(n_i) = \\frac{3}{5}\\frac{\\hbar^2}{2 m_N} \\left(3\\pi^2\\right)^{2/3} n_i^{5/3}$，其中 $\\mu_i^{\\mathrm{FG}}(n_i) = \\partial \\epsilon_i^{\\mathrm{FG}}/\\partial n_i$。\n- 电子化学势（超相对论性简并费米气体）：$\\mu_e(n_e) = \\hbar c \\left(3\\pi^2 n_e\\right)^{1/3}$。\n- 核相互作用对称能贡献（抛物线近似）：一个能量密度项 $\\epsilon_{\\mathrm{sym}}(n_b, Y_p) = n_b S(n_b) \\left(1 - 2 Y_p\\right)^2$，其中 $S(n_b) = S_0 \\left(n_b/n_0\\right)^\\gamma$。\n\n数值计算中要使用的基本常数和参数：\n- $\\hbar c = 197.3269804\\,\\mathrm{MeV\\,fm}$，使用 $c=1$ 因此 $\\hbar = 197.3269804\\,\\mathrm{MeV\\,fm}$。\n- 核子质量：$m_N = 939.0\\,\\mathrm{MeV}$。\n- 对称能参数：$S_0 = 32.0\\,\\mathrm{MeV}$，$n_0 = 0.16\\,\\mathrm{fm^{-3}}$，$\\gamma = 0.6$。\n\n您的任务是：\n\n1. 根据以上定义，推导中子和质子在零温下的化学势表达式（包括动能和对称能贡献），以及电荷中性条件下的电子化学势。构建一个关于未知数 $n_p$（在 $n_b$ 固定时）的标量非线性方程，该方程体现了 β 平衡和电荷中性。方程的形式应为 $f(n_p; n_b) = 0$。\n2. 使用第一性原理和链式法则，在 $n_b$ 固定时推导解析雅可比矩阵 $J = \\frac{\\mathrm{d} f}{\\mathrm{d} n_p}$。除已给出的定义外，不要假定任何快捷恒等式。\n3. 实现一个基于 Newton–Raphson 方法（Newton–Raphson (NR)）的稳健求根求解器，并通过二分法或线搜索进行保障，以满足物理边界 $0  Y_p  1/2$。该求解器必须使用您的解析雅可比矩阵 $J$。\n4. 通过将您的解析雅可比矩阵 $J$ 与收敛根附近的中心有限差分近似值进行比较来验证您的雅可比矩阵。如果相对误差低于 $10^{-6}$，则宣布测试通过，使用比较规则 $\\left|\\Delta\\right| / \\max\\left(1, |J_{\\mathrm{fd}}|\\right)  10^{-6}$，其中 $\\Delta = J_{\\mathrm{analytic}} - J_{\\mathrm{fd}}$。\n5. 为以下重子密度测试集（单位为 $\\mathrm{fm^{-3}}$）：$[10^{-4}, 10^{-2}, 0.16, 0.64]$ 计算质子分数 $Y_p$。对于每个密度，产生两个输出：质子分数 $Y_p$（无量纲）和一个布尔值，指示雅可比矩阵验证是否通过。\n6. 输出规范：您的程序必须生成单行输出，包含所有结果，并遵循以下顺序和格式。对于给定顺序中的每个重子密度，输出四舍五入到六位小数的质子分数 $Y_p$，紧接着是布尔型的雅可比矩阵检查结果，并将它们合并成一个单一的逗号分隔列表。例如，一个包含四个密度的通用输出应如下所示：$[y_1,\\mathrm{b}_1,y_2,\\mathrm{b}_2,y_3,\\mathrm{b}_3,y_4,\\mathrm{b}_4]$，其中每个 $y_i$ 是一个四舍五入到六位的小数，每个 $\\mathrm{b}_i$ 是 True 或 False。质子分数是无量纲的，必须打印为四舍五入到六位的小数。\n\n程序约束：\n- 您的解决方案必须是一个完整的、可运行的程序，不接受任何输入，并按指定格式向标准输出写入一行内容。\n- 算法不得依赖外部文件或网络访问。\n- 您可以使用指定的数值库，但必须自己实现 Newton–Raphson 方法和雅可比矩阵的推导。\n\n设计考量：\n- 通过保障迭代和导数求值过程，确保在 $Y_p$ 非常小时的数值稳定性。\n- 使用物理上合理的边界和后备方法（例如二分法）来保证在这些边界内的收敛性。\n- 在内部使用一致的能量单位（例如 $\\mathrm{MeV}$）和数密度单位（例如 $\\mathrm{fm^{-3}}$）。质子分数 $Y_p$ 是无量纲的，必须无单位打印。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[y_1,\\mathrm{b}_1,y_2,\\mathrm{b}_2,y_3,\\mathrm{b}_3,y_4,\\mathrm{b}_4]$）。", "solution": "我们使用一个简化的核物质状态方程来构建一个用于冷催化核物质的组分求解器，该方程结合了用于核子的非相对论性简并费米气体、用于电子的超相对论性简并费米气体以及抛物线对称能相互作用。我们从第一性原理出发，推导稳健的 Newton–Raphson (NR) 求根器所需的化学势和雅可比矩阵。\n\n从重子数密度 $n_b$ 和质子分数 $Y_p = n_p/n_b$ 开始。则 $n_n = n_b - n_p$，电荷中性意味着 $n_e = n_p$。\n\n在零温下，对于粒子种类 $i \\in \\{n,p\\}$，其核子动能密度（模型为非相对论性简并费米气体）由下式给出\n$$\n\\epsilon_i^{\\mathrm{FG}}(n_i) = \\frac{3}{5} \\frac{\\hbar^2}{2 m_N} \\left(3\\pi^2\\right)^{2/3} n_i^{5/3}.\n$$\n这种费米气体在零温下的化学势为\n$$\n\\mu_i^{\\mathrm{FG}}(n_i) = \\frac{\\partial \\epsilon_i^{\\mathrm{FG}}}{\\partial n_i}\n= \\frac{\\hbar^2}{2 m_N} \\left(3\\pi^2\\right)^{2/3} n_i^{2/3}.\n$$\n定义常数\n$$\nA \\equiv \\frac{\\hbar^2}{2 m_N} \\left(3\\pi^2\\right)^{2/3},\n$$\n因此 $\\mu_i^{\\mathrm{FG}}(n_i) = A\\, n_i^{2/3}$ 且 $\\frac{\\mathrm{d} \\mu_i^{\\mathrm{FG}}}{\\mathrm{d} n_i} = \\frac{2}{3} A\\, n_i^{-1/3}$。\n\n在超相对论极限下，零温时的电子化学势为\n$$\n\\mu_e(n_e) = \\hbar c \\left(3 \\pi^2 n_e\\right)^{1/3},\n$$\n且设 $c=1$，则 $\\hbar = \\hbar c = 197.3269804\\,\\mathrm{MeV\\,fm}$。定义\n$$\nB \\equiv \\hbar \\left(3\\pi^2\\right)^{1/3},\n$$\n因此 $\\mu_e(n_e) = B\\, n_e^{1/3}$ 且 $\\frac{\\mathrm{d} \\mu_e}{\\mathrm{d} n_e} = \\frac{1}{3} B\\, n_e^{-2/3}$。\n\n在抛物线近似中，对称能相互作用的能量密度为\n$$\n\\epsilon_{\\mathrm{sym}}(n_b, Y_p) = n_b\\, S(n_b)\\, \\delta^2, \\quad \\delta \\equiv 1 - 2 Y_p = \\frac{n_n - n_p}{n_b},\n$$\n其中\n$$\nS(n_b) = S_0 \\left(\\frac{n_b}{n_0}\\right)^\\gamma.\n$$\n我们需要相互作用对核子化学势的贡献，即在分别固定 $n_p$ 或 $n_n$ 时的 $\\mu_n^{\\mathrm{int}} = \\frac{\\partial \\epsilon_{\\mathrm{sym}}}{\\partial n_n}$ 和 $\\mu_p^{\\mathrm{int}} = \\frac{\\partial \\epsilon_{\\mathrm{sym}}}{\\partial n_p}$。引入 $q \\equiv n_n - n_p$ 和 $g(n_b) \\equiv n_b S(n_b)$。那么\n$$\n\\epsilon_{\\mathrm{sym}} = g(n_b) \\frac{q^2}{n_b^2}.\n$$\n使用链式法则，并考虑到 $\\partial n_b/\\partial n_n = 1$、$\\partial q/\\partial n_n = 1$、$\\partial n_b/\\partial n_p = 1$ 和 $\\partial q/\\partial n_p = -1$，我们得到\n$$\n\\mu_n^{\\mathrm{int}} = \\frac{\\partial \\epsilon_{\\mathrm{sym}}}{\\partial n_n}\n= g'(n_b) \\frac{q^2}{n_b^2} + g(n_b) \\left[ 2 \\frac{q}{n_b^2} - 2 \\frac{q^2}{n_b^3} \\right],\n$$\n$$\n\\mu_p^{\\mathrm{int}} = \\frac{\\partial \\epsilon_{\\mathrm{sym}}}{\\partial n_p}\n= g'(n_b) \\frac{q^2}{n_b^2} + g(n_b) \\left[ -2 \\frac{q}{n_b^2} - 2 \\frac{q^2}{n_b^3} \\right],\n$$\n其中 $g'(n_b) = \\frac{\\mathrm{d}}{\\mathrm{d} n_b} \\left[n_b S(n_b)\\right] = S(n_b) + n_b S'(n_b)$。它们的差值可大幅简化：\n$$\n\\left(\\mu_n - \\mu_p\\right)_{\\mathrm{int}} = \\mu_n^{\\mathrm{int}} - \\mu_p^{\\mathrm{int}} = 4\\, g(n_b) \\frac{q}{n_b^2}\n= 4\\, S(n_b)\\, \\delta,\n$$\n因为 $q = n_b \\delta$。这个在抛物线近似中的著名结果是直接从链式法则推导出来的，没有任何特设的假设。\n\n完整的中子和质子化学势结合了动能和相互作用部分：\n$$\n\\mu_n(n_n, n_p; n_b) = \\mu_n^{\\mathrm{FG}}(n_n) + \\mu_n^{\\mathrm{int}}(n_n, n_p; n_b),\n\\quad\n\\mu_p(n_n, n_p; n_b) = \\mu_p^{\\mathrm{FG}}(n_p) + \\mu_p^{\\mathrm{int}}(n_n, n_p; n_b).\n$$\n因此，在电荷中性下的 β 平衡条件为\n$$\nf(n_p; n_b) \\equiv \\left[\\mu_n(n_b - n_p) - \\mu_p(n_p)\\right] - \\mu_e(n_p) = 0.\n$$\n对各项进行分组，并使用简化后的相互作用差值，\n$$\n\\mu_n^{\\mathrm{FG}}(n_n) - \\mu_p^{\\mathrm{FG}}(n_p) = A \\left( n_n^{2/3} - n_p^{2/3} \\right),\n$$\n$$\n\\left(\\mu_n - \\mu_p\\right)_{\\mathrm{int}} = 4\\, S(n_b)\\, \\left(1 - 2 \\frac{n_p}{n_b}\\right),\n$$\n$$\n\\mu_e(n_p) = B\\, n_p^{1/3}.\n$$\n因此，\n$$\nf(n_p; n_b) = A \\left[ (n_b - n_p)^{2/3} - n_p^{2/3} \\right]\n+ 4\\, S(n_b)\\, \\left(1 - 2 \\frac{n_p}{n_b}\\right)\n- B\\, n_p^{1/3}.\n$$\n\n我们需要在 $n_b$ 固定时求解析雅可比矩阵 $J = \\frac{\\mathrm{d} f}{\\mathrm{d} n_p}$。对每一项关于 $n_p$ 求导：\n- 对于动能差值项，\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d} n_p} \\left[ A \\left( (n_b - n_p)^{2/3} - n_p^{2/3} \\right) \\right]\n= A \\left[ \\frac{2}{3} (n_b - n_p)^{-1/3} \\cdot (-1) - \\frac{2}{3} n_p^{-1/3} \\right]\n= -\\frac{2}{3} A \\left[ (n_b - n_p)^{-1/3} + n_p^{-1/3} \\right].\n$$\n- 对于相互作用差值项，\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d} n_p} \\left[ 4\\, S(n_b)\\, \\left(1 - 2 \\frac{n_p}{n_b}\\right) \\right]\n= 4\\, S(n_b) \\left( - \\frac{2}{n_b} \\right) = - \\frac{8\\, S(n_b)}{n_b},\n$$\n因为在 $n_b$ 固定时，$S(n_b)$ 相对于 $n_p$ 是常数。\n- 对于电子项，\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d} n_p} \\left[ - B\\, n_p^{1/3} \\right] = - \\frac{1}{3} B\\, n_p^{-2/3}.\n$$\n汇总得到，\n$$\nJ(n_p; n_b) = \\frac{\\mathrm{d} f}{\\mathrm{d} n_p}\n= -\\frac{2}{3} A \\left[ (n_b - n_p)^{-1/3} + n_p^{-1/3} \\right]\n- \\frac{8\\, S(n_b)}{n_b}\n- \\frac{1}{3} B\\, n_p^{-2/3}.\n$$\n\n数值算法。我们使用有保障的 Newton–Raphson 方法在区间 $(0, n_b/2)$（对应于 $Y_p \\in (0, 1/2)$）上求解 $f(n_p; n_b) = 0$。该方法维持一个根的包围区间 $[a,b]$，使得 $f(a) f(b)  0$。当牛顿步 $n_p^{\\mathrm{new}} = n_p - f/J$ 保持在 $[a,b]$ 内且 $J$ 表现良好时，采用牛顿步；否则，回退到二分法。当 $|f|$ 低于一个很小的绝对容差或 $n_p$ 的变化足够小时，即宣告收敛。雅可比矩阵验证使用中心有限差分近似，\n$$\nJ_{\\mathrm{fd}} \\approx \\frac{f(n_p + h) - f(n_p - h)}{2 h},\n$$\n其中步长 $h$ 是一个根据 $n_p$ 和 $n_b$ 缩放的小值，相对误差检查为\n$$\n\\frac{|J_{\\mathrm{analytic}} - J_{\\mathrm{fd}}|}{\\max(1, |J_{\\mathrm{fd}}|)}  10^{-6}.\n$$\n\n用于评估的常数和参数设置为 $\\hbar = 197.3269804\\,\\mathrm{MeV\\,fm}$，$m_N = 939.0\\,\\mathrm{MeV}$，$S_0 = 32.0\\,\\mathrm{MeV}$，$n_0 = 0.16\\,\\mathrm{fm^{-3}}$，$\\gamma = 0.6$。重子密度测试集为 $[10^{-4}, 10^{-2}, 0.16, 0.64]\\,\\mathrm{fm^{-3}}$。对于每个密度，求解器返回 $Y_p = n_p/n_b$（无量纲），作为四舍五入到六位的小数打印，和一个布尔型的雅可比矩阵验证结果。最终程序输出单行形式为 $[y_1,\\mathrm{b}_1,y_2,\\mathrm{b}_2,y_3,\\mathrm{b}_3,y_4,\\mathrm{b}_4]$。\n\n该构建基于简并费米气体的定义、抛物线对称能模型以及化学势作为能量密度对粒子数密度的导数这一定义。雅可比矩阵通过直接微分和链式法则得出。有保障的 Newton–Raphson 方法在利用解析导数实现快速收敛的同时，确保了在物理允许域内的收敛性。有限差分验证为解析雅可比矩阵的推导提供了一个内部一致性检查。\n\n执行时，程序会计算指定密度下的质子分数，并按要求报告雅可比矩阵的检查结果。质子分数是无单位的，并打印到六位小数；最终输出中不打印任何物理单位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants and EOS parameters\nHBAR = 197.3269804  # MeV*fm, using c=1 so hbar = hbar*c\nM_N = 939.0         # MeV\nS0 = 32.0           # MeV\nN0 = 0.16           # fm^-3\nGAMMA = 0.6         # dimensionless\n\n# Precompute constants A and B for kinetic and electron chemical potentials\nA_CONST = (HBAR**2) / (2.0 * M_N) * (3.0 * np.pi**2) ** (2.0 / 3.0)\nB_CONST = HBAR * (3.0 * np.pi**2) ** (1.0 / 3.0)\n\ndef symmetry_energy(nb: float) -> float:\n    \"\"\"Symmetry energy S(nb) in MeV for given baryon density nb in fm^-3.\"\"\"\n    return S0 * (nb / N0) ** GAMMA\n\ndef f_and_df(nb: float, npart: float) -> tuple[float, float]:\n    \"\"\"\n    Compute f(n_p; n_b) and its analytic derivative with respect to n_p.\n    nb: baryon density [fm^-3]\n    npart: proton density n_p [fm^-3]\n    Returns (f, df)\n    \"\"\"\n    # Safeguard minimal positive values to avoid singular fractional powers\n    eps = max(1e-30, 1e-30 * nb)\n    np_local = max(npart, eps)\n    nn_local = max(nb - np_local, eps)\n\n    # Chemical potential differences and electron chemical potential\n    # mu_n^FG - mu_p^FG\n    mu_diff_fg = A_CONST * (nn_local ** (2.0 / 3.0) - np_local ** (2.0 / 3.0))\n    # Interaction contribution difference: 4 S(nb) * (1 - 2 n_p / n_b)\n    Snb = symmetry_energy(nb)\n    mu_diff_int = 4.0 * Snb * (1.0 - 2.0 * np_local / nb)\n    # Electron chemical potential\n    mu_e = B_CONST * (np_local ** (1.0 / 3.0))\n\n    fval = mu_diff_fg + mu_diff_int - mu_e\n\n    # Analytic derivative df/dn_p at fixed nb\n    d_mu_diff_fg_dnp = -(2.0 / 3.0) * A_CONST * (nn_local ** (-1.0 / 3.0) + np_local ** (-1.0 / 3.0))\n    d_mu_diff_int_dnp = -8.0 * Snb / nb\n    d_mu_e_dnp = (1.0 / 3.0) * B_CONST * (np_local ** (-2.0 / 3.0))\n    dfdnp = d_mu_diff_fg_dnp + d_mu_diff_int_dnp - d_mu_e_dnp\n\n    return fval, dfdnp\n\ndef bracket_root(nb: float) -> tuple[float, float]:\n    \"\"\"\n    Find a bracket [a, b] for n_p such that f(a) and f(b) have opposite signs.\n    The physical domain is n_p in (0, nb/2).\n    \"\"\"\n    a = max(1e-18 * nb, 1e-30)\n    b = 0.5 * nb * (1.0 - 1e-12)  # slightly less than nb/2 to avoid boundary singularity\n    fa, _ = f_and_df(nb, a)\n    fb, _ = f_and_df(nb, b)\n    # If not bracketing, try to adjust a little (should be very rare)\n    if fa * fb > 0.0:\n        # Scan geometrically in between to attempt to find a sign change\n        xs = np.geomspace(a * 10.0, b / 10.0, num=50)\n        prev_x = a\n        prev_f = fa\n        for x in xs:\n            fx, _ = f_and_df(nb, x)\n            if prev_f * fx = 0.0:\n                return prev_x, x\n            prev_x, prev_f = x, fx\n        # Fall back: enforce the endpoints as bracket even if not sign-changed\n        # Newton solver will still be safeguarded by bisection steps.\n    return a, b\n\ndef solve_np(nb: float) -> float:\n    \"\"\"\n    Solve for proton density n_p at fixed nb using a safeguarded Newton method.\n    Returns n_p.\n    \"\"\"\n    a, b = bracket_root(nb)\n    fa, _ = f_and_df(nb, a)\n    fb, _ = f_and_df(nb, b)\n    # Initial guess: midpoint or physically motivated guess\n    x = min(max(0.1 * nb, a), b)\n    fx, dfx = f_and_df(nb, x)\n\n    # Ensure we have a bracket (if not, set to endpoints to guide bisection)\n    if fa * fb > 0.0:\n        # Force a sign change by setting one end to current x if possible\n        if fx * fa  0.0:\n            b, fb = x, fx\n        elif fx * fb  0.0:\n            a, fa = x, fx\n        else:\n            # As a last resort, set bracket to tiny to half-density\n            a, fa = a, fa\n            b, fb = b, fb\n\n    tol_f = 1e-12  # MeV\n    tol_x = 1e-14 * max(nb, 1.0)\n    max_iter = 200\n\n    for _ in range(max_iter):\n        fx, dfx = f_and_df(nb, x)\n        # Check convergence\n        if abs(fx)  tol_f:\n            return x\n        # Decide step: Newton or bisection\n        use_newton = True\n        if dfx == 0.0 or not np.isfinite(dfx):\n            use_newton = False\n        if use_newton:\n            step = -fx / dfx\n            x_new = x + step\n            # If step goes out of bracket or is NaN/Inf, do bisection\n            if not (a  x_new  b) or not np.isfinite(x_new):\n                use_newton = False\n        if not use_newton:\n            x_new = 0.5 * (a + b)\n\n        fx_new, _ = f_and_df(nb, x_new)\n        # Update bracket\n        if fx_new == 0.0:\n            return x_new\n        if fa * fx_new  0.0:\n            b, fb = x_new, fx_new\n        else:\n            a, fa = x_new, fx_new\n\n        # Accept new point\n        if abs(x_new - x)  tol_x:\n            return x_new\n        x = x_new\n\n    # If not converged, return current best\n    return x\n\ndef jacobian_check(nb: float, np_sol: float) -> bool:\n    \"\"\"\n    Validate analytic Jacobian against finite-difference central derivative.\n    \"\"\"\n    f_val, df_analytic = f_and_df(nb, np_sol)\n    # Central difference step\n    h = max(1e-8 * max(np_sol, 1.0), 1e-14 * max(nb, 1.0))\n    np_plus = np_sol + h\n    np_minus = max(np_sol - h, 1e-30)\n    f_plus, _ = f_and_df(nb, np_plus)\n    f_minus, _ = f_and_df(nb, np_minus)\n    df_fd = (f_plus - f_minus) / (np_plus - np_minus)\n    rel_err = abs(df_analytic - df_fd) / max(1.0, abs(df_fd))\n    return rel_err  1e-6\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        1e-4,   # fm^-3 low density\n        1e-2,   # fm^-3 sub-saturation\n        0.16,   # fm^-3 saturation density\n        0.64,   # fm^-3 supra-saturation\n    ]\n\n    results_parts = []\n    for nb in test_cases:\n        np_sol = solve_np(nb)\n        yp = np_sol / nb\n        # Jacobian validation\n        jac_ok = jacobian_check(nb, np_sol)\n        # Append formatted Yp and boolean\n        results_parts.append(f\"{yp:.6f}\")\n        results_parts.append(str(jac_ok))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_parts)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3605364"}]}