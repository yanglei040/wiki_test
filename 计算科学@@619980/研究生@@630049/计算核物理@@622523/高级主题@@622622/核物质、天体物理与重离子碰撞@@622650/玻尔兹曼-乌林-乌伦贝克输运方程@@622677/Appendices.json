{"hands_on_practices": [{"introduction": "构建输运模型的第一步是正确描述粒子在没有碰撞时，如何在集体平均场势的作用下运动。这个练习将引导您实现玻尔兹曼-乌林-乌伦贝克 (BUU) 方程的无碰撞极限，即弗拉索夫 (Vlasov) 方程。通过在一个简化的谐振子势中求解，您将掌握在相空间网格上应用半拉格朗日方法的核心技术，并学会执行守恒量审计——这是验证任何输运代码可靠性的关键步骤 [@problem_id:3544900]。", "problem": "请在一维空间和一维动量维度上，实现一个无碰撞玻尔兹曼-乌林-乌伦贝克 (BUU) 输运求解器，该求解器在不同时间步长 $\\Delta t$ 和网格分辨率 $\\Delta x$ 的扫描下进行守恒量审计。您的任务是推导并实现一个针对谐振子平均场势下BUU方程Vlasov极限的半拉格朗日求解器，并在长时间积分过程中监测总能量、总动量和粒子数的守恒性。全程使用无量纲单位。\n\n从以下基础出发：\n- 单体相空间密度 $f(x,p,t)$ 的玻尔兹曼-乌林-乌伦贝克 (BUU) 输运方程为\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{p}{m}\\frac{\\partial f}{\\partial x} - \\frac{\\partial U}{\\partial x}\\frac{\\partial f}{\\partial p} = I_{\\mathrm{coll}}[f] ,\n$$\n其中 $m$ 是质量，$U(x)$ 是平均场势，$I_{\\mathrm{coll}}[f]$ 是包含泡利阻塞的碰撞积分。在无碰撞（Vlasov）极限下，令 $I_{\\mathrm{coll}}[f]=0$。\n- 对于谐振子平均场，\n$$\nU(x) = \\tfrac{1}{2} k x^2 , \\quad \\omega \\equiv \\sqrt{k/m} .\n$$\n- 无碰撞流的特征线遵循哈密顿方程，\n$$\n\\dot{x} = \\frac{p}{m}, \\qquad \\dot{p} = -\\frac{\\partial U}{\\partial x} = -k x = -m \\omega^2 x.\n$$\n- 以下积分在连续动力学下被精确守恒：\n  - 粒子数 $N = \\iint f(x,p,t)\\, dx\\, dp$。\n  - 总动量 $P = \\iint p\\, f(x,p,t)\\, dx\\, dp$。\n  - 总能量 $E = \\iint \\left( \\frac{p^2}{2m} + \\tfrac{1}{2} k x^2 \\right) f(x,p,t)\\, dx\\, dp$。\n\n您的数值模型必须遵循以下设计：\n- 使用谐振子的精确特征映射进行时间步进。在一个时间步长 $\\Delta t$ 内，从 $t^{n+1}$ 到 $t^n$ 的精确回溯映射为\n$$\n\\begin{pmatrix} x^{\\star} \\\\ p^{\\star} \\end{pmatrix}\n= \\begin{pmatrix}\n\\cos(\\omega \\Delta t)  & -\\frac{1}{m \\omega}\\sin(\\omega \\Delta t) \\\\\nm \\omega \\sin(\\omega \\Delta t)  & \\cos(\\omega \\Delta t)\n\\end{pmatrix}\n\\begin{pmatrix} x \\\\ p \\end{pmatrix} ,\n$$\n然后使用均匀相空间网格上的双线性插值设置 $f^{n+1}(x,p) = f^n(x^{\\star},p^{\\star})$。\n- 使用均匀网格 $x \\in [x_{\\min}, x_{\\max}]$ 和 $p \\in [p_{\\min}, p_{\\max}]$，分别有 $N_x$ 和 $N_p$ 个单元格，$f$ 的值位于单元格中心。选择 $x_{\\min}=-L_x$, $x_{\\max}=+L_x$, $p_{\\min}=-L_p$, $p_{\\max}=+L_p$，其中 $L_x=L_p$ 足够大，以便对于所选的初始条件和模拟时间，边界效应可以忽略不计。\n- 将 $f(x,p,0)$ 初始化为相空间中的归一化高斯分布，\n$$\nf(x,p,0) = \\frac{1}{2\\pi \\sigma_x \\sigma_p} \\exp\\!\\left( -\\frac{x^2}{2\\sigma_x^2} - \\frac{p^2}{2\\sigma_p^2} \\right),\n$$\n其中 $\\sigma_x = 1$ 且 $\\sigma_p = 1$。\n- 设置 $m=1$, $k=1$，使得 $\\omega=1$。 演化到最终时间 $T_{\\mathrm{end}} = T_{\\mathrm{per}}\\times 2\\pi$，对应 $T_{\\mathrm{per}}$ 个振荡周期。使用 $T_{\\mathrm{per}}=8$。 使用 $L_x=L_p=6$，以便边界截断误差对于高斯初始数据呈指数级小。\n\n守恒量审计：\n- 在每个时间步 $t_n$，计算\n$$\nN(t_n) = \\sum_{i,j} f_{ij}(t_n)\\, \\Delta x\\, \\Delta p,\\quad\nP(t_n) = \\sum_{i,j} p_j\\, f_{ij}(t_n)\\, \\Delta x\\, \\Delta p,\\quad\nE(t_n) = \\sum_{i,j} \\left( \\frac{p_j^2}{2m} + \\frac{1}{2} k x_i^2 \\right) f_{ij}(t_n)\\, \\Delta x\\, \\Delta p .\n$$\n- 设 $N_0, P_0, E_0$ 为初始值。定义运行偏差\n$$\n\\delta N(t_n) = |N(t_n)-N_0|,\\quad\n\\delta P(t_n) = |P(t_n)-P_0|,\\quad\n\\delta E(t_n) = |E(t_n)-E_0|.\n$$\n- 报告运行期间的最大值：\n$$\n\\delta N_{\\max} = \\max_n \\delta N(t_n),\\quad\n\\delta P_{\\max} = \\max_n \\delta P(t_n),\\quad\n\\delta E_{\\max} = \\max_n \\delta E(t_n).\n$$\n- 对于无量纲相对审计，计算\n$$\nr_N = \\frac{\\delta N_{\\max}}{\\max(|N_0|,\\varepsilon)},\\quad\nr_P = \\frac{\\delta P_{\\max}}{\\max(|P_0|,\\varepsilon)},\\quad\nr_E = \\frac{\\delta E_{\\max}}{\\max(|E_0|,\\varepsilon)},\n$$\n其中 $\\varepsilon = 10^{-12}$ 以避免除以零。我们关注的稳定性判据是 $r_E < 10^{-3}$。\n\n物理和数值单位：\n- 使用一个完全无量纲的系统，其中 $m=1$, $k=1$, $\\omega=1$, $\\sigma_x=1$, $\\sigma_p=1$, $L_x=L_p=6$, 并且 $T_{\\mathrm{per}}=8$。 所有输出必须是纯小数（无单位）。\n\n测试套件和要求输出：\n- 对于下面的每个参数三元组 $(N_x, N_p, \\Delta t)$，运行模拟并评估能量审计是否通过 $r_E < 10^{-3}$：\n  1. $(N_x=32, N_p=32, \\Delta t=0.10)$\n  2. $(N_x=32, N_p=32, \\Delta t=0.05)$\n  3. $(N_x=24, N_p=24, \\Delta t=0.10)$\n  4. $(N_x=64, N_p=64, \\Delta t=0.10)$\n  5. $(N_x=24, N_p=24, \\Delta t=0.20)$\n  6. $(N_x=48, N_p=48, \\Delta t=0.15)$\n- 您的程序应产生单行输出，包含一个用方括号括起来的逗号分隔的结果列表，顺序与测试套件相同，其中每个条目是一个布尔值，表示是否满足 $r_E < 10^{-3}$。例如，输出类似 $[\\mathrm{True},\\mathrm{False},\\dots]$。\n\n您的程序必须是自包含的，不需要用户输入，并严格遵守给定的执行环境和库约束。数值设计应具有科学合理性，并且必须按规定实现审计。所有角度均以弧度为单位。所有报告的量都必须是无单位的小数。", "solution": "该问题要求在一维空间和一维动量维度上，实现一个用于求解无碰撞玻尔兹曼-乌林-乌伦贝克(BUU)方程（也称为Vlasov方程）的半拉格朗日求解器。该系统处于一个谐振子平均场势中。核心任务是在长时间模拟过程中监测粒子数、动量和能量的守恒性，并在不同网格分辨率和时间步长下审计数值精度。\n\n单体相空间分布函数 $f(x, p, t)$ 的控制方程是Vlasov方程：\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{p}{m}\\frac{\\partial f}{\\partial x} - \\frac{\\partial U(x)}{\\partial x}\\frac{\\partial f}{\\partial p} = 0\n$$\n其中 $m$ 是粒子质量，$x$ 是位置，$p$ 是动量，$U(x)$ 是平均场势。对于本问题，势是简谐振子的势，$U(x) = \\frac{1}{2} k x^2$，其中 $k$ 是弹簧常数。粒子受到的力是 $F_x = -\\frac{\\partial U}{\\partial x} = -k x$。这个偏微分方程的特征曲线是粒子在相空间中的经典轨迹，由哈密顿方程控制：\n$$\n\\dot{x} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m}, \\qquad \\dot{p} = -\\frac{\\partial H}{\\partial x} = -k x\n$$\n其中哈密顿量为 $H(x,p) = \\frac{p^2}{2m} + U(x)$。刘维尔定理是Vlasov方程的直接推论，它指出分布函数 $f$ 沿着这些特征线是恒定的。也就是说，如果 $(x(t), p(t))$ 是一个粒子轨迹，那么 $f(x(t), p(t), t)$ 是恒定的。\n\n数值解是使用一种半拉格朗日方法构建的，该方法利用了刘维尔定理。为了在时间 $t^{n+1} = t^n + \\Delta t$ 找到网格点 $(x, p)$ 上的分布函数值 $f^{n+1}(x, p)$，我们将特征线向后追溯一个时间步长 $\\Delta t$，来找到它在时间 $t^n$ 的出发点 $(x^\\star, p^\\star)$。然后分布函数的值更新为 $f^{n+1}(x, p) = f^n(x^\\star, p^\\star)$。\n\n对于谐振子，哈密顿方程的解为特征线提供了精确的映射。在时间 $t^{n+1}$ 位于相空间坐标 $(x, p)$ 的粒子，起源于时间 $t^n$ 的 $(x^\\star, p^\\star)$，其中 $(x^\\star, p^\\star)$ 是通过将 $(x, p)$ 向后演化时间 $\\Delta t$ 得到的。这个操作是一个线性变换（在缩放的相空间中的旋转），由问题中指定的矩阵给出：\n$$\n\\begin{pmatrix} x^{\\star} \\\\ p^{\\star} \\end{pmatrix}\n= \\begin{pmatrix}\n\\cos(\\omega \\Delta t)  & -\\frac{1}{m \\omega}\\sin(\\omega \\Delta t) \\\\\nm \\omega \\sin(\\omega \\Delta t)  & \\cos(\\omega \\Delta t)\n\\end{pmatrix}\n\\begin{pmatrix} x \\\\ p \\end{pmatrix}\n$$\n其中 $\\omega = \\sqrt{k/m}$ 是振荡器的固有频率。\n\n出发点 $(x^\\star, p^\\star)$ 通常不会与时间 $t^n$ 的离散相空间网格上的点重合。因此，值 $f^n(x^\\star, p^\\star)$ 必须通过对网格点上的已知 $f^n$ 值进行插值来估计。问题指定使用双线性插值来完成此任务。这个插值步骤是该方案中数值误差和耗散的主要来源，导致数值计算出的守恒量偏离其真实的恒定值。\n\n实现遵循以下步骤。首先，我们定义一个均匀的、以单元格为中心的相空间网格，具有 $N_x \\times N_p$ 个点，覆盖区域 $[-L_x, L_x] \\times [-L_p, L_p]$。网格间距为 $\\Delta x = 2L_x/N_x$ 和 $\\Delta p = 2L_p/N_p$。初始分布函数 $f(x, p, 0)$ 在此网格上被设置为归一化高斯分布。我们将物理参数设置为无量纲值 $m=1, k=1$，这意味着 $\\omega=1$。\n\n主循环迭代多个时间步，足以覆盖总模拟时间 $T_{\\mathrm{end}} = T_{\\mathrm{per}} \\times 2\\pi = 16\\pi$。在每个步骤中：\n1. 考虑新时间步 $t^{n+1}$ 的整个目标点网格 $(x_{i}, p_{j})$。\n2. 对于每个点，使用矢量化的回溯矩阵变换计算其在时间 $t^n$ 的相应出发点 $(x^\\star_{ij}, p^\\star_{ij})$。\n3. 从 $f^n$ 的网格值构造一个二维插值器 `scipy.interpolate.RegularGridInterpolator`。它被配置为执行双线性插值，并对于任何从模拟域外追溯到的点返回 $0$，这对于局部化的初始分布是一个合理的物理假设。\n4. 在所有出发点 $(x^\\star_{ij}, p^\\star_{ij})$ 查询此插值器，以获得新的分布 $f^{n+1}$。\n\n在每个时间步，都会执行一次守恒审计。总粒子数 $N$、总动量 $P$ 和总能量 $E$ 通过在相空间网格上进行数值积分（离散求和）来计算：\n$$\nN(t_n) = \\sum_{i,j} f_{ij}(t_n)\\, \\Delta x\\, \\Delta p\n$$\n$$\nP(t_n) = \\sum_{i,j} p_j\\, f_{ij}(t_n)\\, \\Delta x\\, \\Delta p\n$$\n$$\nE(t_n) = \\sum_{i,j} \\left( \\frac{p_j^2}{2m} + \\frac{1}{2} k x_i^2 \\right) f_{ij}(t_n)\\, \\Delta x\\, \\Delta p\n$$\n初始值 $N_0$, $P_0$ 和 $E_0$ 由初始分布 $f(x, p, 0)$ 计算得出。对于给定的对称高斯分布，解析值为 $N_0=1$, $P_0=0$ 和 $E_0 = \\frac{\\sigma_p^2}{2m} + \\frac{k\\sigma_x^2}{2} = 1$。在整个模拟过程中跟踪最大绝对偏差 $\\delta N_{\\max}$, $\\delta P_{\\max}$ 和 $\\delta E_{\\max}$。最后，计算能量的相对误差 $r_E = \\delta E_{\\max} / \\max(|E_0|, \\varepsilon)$，并与 $10^{-3}$ 的容差进行比较，以确定模拟是否通过守恒审计。对测试套件中的每个参数集重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef run_simulation(Nx, Np, dt):\n    \"\"\"\n    Runs a single Vlasov simulation for a given set of numerical parameters.\n\n    Args:\n        Nx (int): Number of grid points in the x-dimension.\n        Np (int): Number of grid points in the p-dimension.\n        dt (float): Time step size.\n\n    Returns:\n        bool: True if the relative energy error is less than 1e-3, False otherwise.\n    \"\"\"\n    # 1. Define physical and numerical constants\n    m, k = 1.0, 1.0\n    omega = np.sqrt(k / m)\n    sigma_x, sigma_p = 1.0, 1.0\n    Lx, Lp = 6.0, 6.0\n    T_per = 8.0\n    T_end = T_per * 2.0 * np.pi\n    eps = 1e-12\n\n    # 2. Set up the phase-space grid\n    dx = (2.0 * Lx) / Nx\n    dp = (2.0 * Lp) / Np\n    x_coords = np.linspace(-Lx + dx / 2.0, Lx - dx / 2.0, Nx)\n    p_coords = np.linspace(-Lp + dp / 2.0, Lp - dp / 2.0, Np)\n    XX, PP = np.meshgrid(x_coords, p_coords, indexing='ij')\n\n    # 3. Initialize the phase-space distribution function\n    f = (1.0 / (2.0 * np.pi * sigma_x * sigma_p)) * \\\n        np.exp(-XX**2 / (2.0 * sigma_x**2) - PP**2 / (2.0 * sigma_p**2))\n\n    # 4. Compute initial conserved quantities for the audit\n    dV = dx * dp\n    N0 = np.sum(f) * dV\n    P0 = np.sum(PP * f) * dV\n    E_grid = (PP**2 / (2.0 * m)) + (k * XX**2 / 2.0)\n    E0 = np.sum(E_grid * f) * dV\n\n    dev_N_list, dev_P_list, dev_E_list = [], [], []\n\n    # 5. Set up the time evolution loop\n    num_steps = int(np.ceil(T_end / dt))\n    \n    # Pre-calculate trigonometric factors for the backtracing map\n    c = np.cos(omega * dt)\n    s = np.sin(omega * dt)\n\n    f_current = f.copy()\n\n    for _ in range(num_steps):\n        # a. Create an interpolator for the current distribution f^n\n        interpolator = RegularGridInterpolator((x_coords, p_coords), f_current,\n                                               method='linear',\n                                               bounds_error=False,\n                                               fill_value=0.0)\n\n        # b. Calculate backtraced coordinates for the entire grid\n        #    (x*, p*) = R(-dt) * (x, p), where R is the rotation matrix\n        XX_star = c * XX - (s / (m * omega)) * PP\n        PP_star = (m * omega * s) * XX + c * PP\n\n        # c. Query the interpolator at all backtraced points to get f^(n+1)\n        points_to_query = np.stack([XX_star.ravel(), PP_star.ravel()], axis=-1)\n        f_new_flat = interpolator(points_to_query)\n        f_current = f_new_flat.reshape((Nx, Np))\n\n        # d. Perform conservation audit for the new time step\n        N_n = np.sum(f_current) * dV\n        P_n = np.sum(PP * f_current) * dV\n        E_n = np.sum(E_grid * f_current) * dV\n\n        dev_N_list.append(np.abs(N_n - N0))\n        dev_P_list.append(np.abs(P_n - P0))\n        dev_E_list.append(np.abs(E_n - E0))\n\n    # 6. Finalize the audit by calculating relative error\n    if dev_E_list:\n        delta_E_max = np.max(dev_E_list)\n    else:  # Handles the case where num_steps might be 0\n        delta_E_max = 0.0\n\n    r_E = delta_E_max / np.max([np.abs(E0), eps])\n\n    # 7. Return the boolean result based on the energy conservation criterion\n    return r_E < 1e-3\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 32, 0.10),\n        (32, 32, 0.05),\n        (24, 24, 0.10),\n        (64, 64, 0.10),\n        (24, 24, 0.20),\n        (48, 48, 0.15),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Np, dt = case\n        result = run_simulation(Nx, Np, dt)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a Python bool is 'True' or 'False'.\n    output_str = ','.join(map(str, results))\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "3544900"}, {"introduction": "掌握了粒子的平均场漂移之后，下一步是引入驱动系统趋向平衡的双体碰撞过程。这项实践将指导您从动力学理论的第一性原理出发，构建一个随机碰撞模块，这是 BUU 方程的核心引擎。您将学习如何将在输运模拟中广泛使用的关键物理要素——例如保持平均自由程不变的测试粒子标度，以及费米子所必须遵守的乌林-乌伦贝克泡利阻塞因子——融入到您的算法中 [@problem_id:3544841]。", "problem": "设计并实现一个独立的程序，该程序使用离散时间单元，实现一个与 Boltzmann-Uehling-Uhlenbeck (BUU) 输运框架一致的随机二体碰撞模块。请从动力学理论的基本陈述出发：在稀薄的准粒子气体中，一个微小时空元内的二体碰撞次数由入射通量、微观截面积和作用时间三者之积给出。通过 Uehling-Uhlenbeck 占据因子来包含费米子效应，并引入数值实现中使用的标准检验粒子标度。\n\n你的推导和算法必须从动力学理论和量子统计的第一性原理出发，不得预设任何目标公式。具体来说，仅能使用以下内容作为基本依据：\n- 动力学理论中的二体碰撞图像：碰撞源于两个物体在时间间隔内遭遇有效相互作用区域时产生的相对通量。\n- 截面作为有效面积，在给定相对通量下控制反应频率。\n- 费米子的 Pauli 不相容原理，通过散射末态的占据限制因子来实现。\n- 输运理论中的检验粒子方法，其中微观截面被缩放以保持平均自由程相对于检验粒子数量不变。\n\n你必须编写一个程序，对于一系列给定的测试单元和粒子集，计算单个时间步内所有粒子对的碰撞接受概率之和。对于单元内的每一个无序对，接受概率必须根据该粒子对的相对速度、包含检验粒子标度的有效截面、时间步长、单元体积以及末态占据因子计算得出。你的实现必须确保在一个时间步内，给定的一对粒子最多只能发生一次碰撞，具体方法是在应用占据抑制之前，将任意粒子对的几何接受概率上限设为 $1$。\n\n所有测试用例需统一使用的模型假设：\n- 使用由速度差的欧几里得范数定义的非相对论性相对速度。对于两个速度矢量 $\\mathbf{v}_1$ 和 $\\mathbf{v}_2$，相对速度为 $v_{\\text{rel}} = \\lVert \\mathbf{v}_1 - \\mathbf{v}_2 \\rVert$。\n- 使用检验粒子标度 $\\sigma_{\\text{eff}} = \\sigma / N_{\\text{test}}$，其中 $\\sigma$ 是微观截面，$N_{\\text{test}}$ 是每个物理核子的检验粒子数。\n- 将费米子占据抑制作为一个乘法因子 $(1 - f_3)(1 - f_4)$ 应用于粒子对的、有上限的几何接受概率，其中 $f_3$ 和 $f_4$ 是散射后粒子投影到其可能的碰撞后状态的末态相空间占据概率。将测试套件中为每对粒子提供的 $f_3$ 和 $f_4$ 值视为给定输入。\n- 将测试用例中所有给定粒子视为处于同一空间单元中，并且在时间步内同时有资格发生碰撞；考虑单元内所有无序的不同粒子对。\n\n物理和数值单位：\n- 使用自然单位制，光速设为 1。距离以费米（$\\text{fm}$）表示，时间以 $\\text{fm}$ 表示，截面以 $\\text{fm}^2$ 表示，体积以 $\\text{fm}^3$ 表示，速度以 $c$ 为单位，表示为无量纲数。\n- 程序的数值答案必须以无量纲浮点数的形式提供。\n\n程序任务：\n1. 对于每个测试用例，生成单元中所有无序的粒子对。\n2. 对于每对粒子 $(i,j)$，计算有上限的几何接受概率，然后应用占据抑制，以获得该时间步内该粒子对的接受概率 $P_{ij}$。\n3. 将所有无序对的 $P_{ij}$ 相加，得到该测试用例的总和 $S$。\n4. 以单行形式输出列表 $[S_1,S_2,S_3,S_4,S_5]$，其中 $S_k$ 是测试用例 $k$ 的总和，格式化为小数点后六位。\n\n测试套件（每个测试用例都是独立且自包含的；所有速度单位为 $c$，截面单位为 $\\text{fm}^2$，时间单位为 $\\text{fm}$，体积单位为 $\\text{fm}^3$）：\n- 测试用例 1 (理想情况，无 Pauli 抑制):\n  - 单元: $\\Delta V = 125$。\n  - 时间步长: $\\Delta t = 0.5$。\n  - 截面: $\\sigma = 4.0$。\n  - 每个核子的检验粒子数: $N_{\\text{test}} = 1$。\n  - 速度: 粒子 1: $(0.2, 0, 0)$, 粒子 2: $(-0.1, 0, 0)$。\n  - 粒子对 (1,2) 的末态占据: $(f_3, f_4) = (0.0, 0.0)$。\n- 测试用例 2 (有 Pauli 抑制):\n  - 单元: $\\Delta V = 125$。\n  - 时间步长: $\\Delta t = 0.5$。\n  - 截面: $\\sigma = 4.0$。\n  - 每个核子的检验粒子数: $N_{\\text{test}} = 1$。\n  - 速度: 粒子 1: $(0.2, 0, 0)$, 粒子 2: $(-0.1, 0, 0)$。\n  - 粒子对 (1,2) 的末态占据: $(f_3, f_4) = (0.7, 0.6)$。\n- 测试用例 3 (多个粒子对，检验粒子标度，混合 Pauli 因子):\n  - 单元: $\\Delta V = 64$。\n  - 时间步长: $\\Delta t = 1.0$。\n  - 截面: $\\sigma = 2.0$。\n  - 每个核子的检验粒子数: $N_{\\text{test}} = 50$。\n  - 速度: 粒子 1: $(0.2, 0, 0)$, 粒子 2: $(0, 0.3, 0)$, 粒子 3: $(-0.1, 0, 0.1)$。\n  - 末态占据，按无序对 $(1,2)$, $(1,3)$, $(2,3)$ 的顺序列出:\n    - $(f_3, f_4) = (0.2, 0.1)$ for $(1,2)$,\n    - $(f_3, f_4) = (0.5, 0.6)$ for $(1,3)$,\n    - $(f_3, f_4) = (0.0, 0.0)$ for $(2,3)$。\n- 测试用例 4 (几何概率在设置上限前超过 1；检查上限行为):\n  - 单元: $\\Delta V = 10$。\n  - 时间步长: $\\Delta t = 5.0$。\n  - 截面: $\\sigma = 4.0$。\n  - 每个核子的检验粒子数: $N_{\\text{test}} = 1$。\n  - 速度: 粒子 1: $(0.8, 0, 0)$, 粒子 2: $(0, 0.6, 0)$。\n  - 粒子对 (1,2) 的末态占据: $(f_3, f_4) = (0.0, 0.0)$。\n- 测试用例 5 (相对速度为零；概率必须为零):\n  - 单元: $\\Delta V = 125$。\n  - 时间步长: $\\Delta t = 0.5$。\n  - 截面: $\\sigma = 4.0$。\n  - 每个核子的检验粒子数: $N_{\\text{test}} = 1$。\n  - 速度: 粒子 1: $(0.2, 0.1, 0.1)$, 粒子 2: $(0.2, 0.1, 0.1)$。\n  - 粒子对 (1,2) 的末态占据: $(f_3, f_4) = (0.0, 0.0)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[S_1,S_2,S_3,S_4,S_5]$，每个 $S_k$ 的格式需精确到小数点后六位，例如 $[0.123456,0.000000,0.314159,1.000000,0.271828]$。", "solution": "该问题要求为Boltzmann-Uehling-Uhlenbeck (BUU)输运模型设计并实现一个随机二体碰撞模块。核心是基于动力学理论和量子统计的基本原理，推导在单个时间步内，一个空间单元中任意一对粒子的碰撞概率。\n\n1.  **基本碰撞率**: 在动力学理论中，两组粒子之间的碰撞率取决于它们的密度、相对速度和相互作用截面。对于位于体积为 $\\Delta V$ 的空间单元中的两个粒子（粒子 $i$ 和粒子 $j$），我们可以将它们视为两个相互作用的粒子束。在时间间隔 $\\Delta t$ 内，粒子 $j$ 扫过的体积相对于粒子 $i$ 为 $V_{swept} = \\sigma_{eff} v_{rel} \\Delta t$，其中 $v_{rel} = \\lVert \\mathbf{v}_i - \\mathbf{v}_j \\rVert$ 是它们的相对速度，$\\sigma_{eff}$ 是有效碰撞截面。\n\n2.  **检验粒子方法与有效截面**: 在检验粒子方法中，每个物理核子由 $N_{test}$ 个检验粒子表示。为保持总碰撞率不变（即保持物理上的平均自由程），每个检验粒子对之间的微观截面 $\\sigma$ 必须按 $\\sigma_{eff} = \\sigma / N_{test}$ 进行缩放。\n\n3.  **碰撞概率推导**: 粒子 $i$ 与粒子 $j$ 发生碰撞的概率，可以理解为粒子 $i$ 位于由粒子 $j$ 在时间 $\\Delta t$ 内扫过的体积 $V_{swept}$ 中的概率。由于粒子 $i$ 被假设为均匀分布在单元体积 $\\Delta V$ 中，这个概率（即几何碰撞概率 $P_{geom}$）就是两个体积之比：\n    $$ P_{geom} = \\frac{V_{swept}}{\\Delta V} = \\frac{v_{rel} \\sigma_{eff} \\Delta t}{\\Delta V} $$\n\n4.  **概率上限**: 由于 $P_{geom}$ 是一个概率，其值不能超过1。在 $\\Delta t$ 很大或 $\\Delta V$ 很小的情况下，该表达式的值可能大于1。因此，我们必须将其上限设为1，即 $P_{capped} = \\min(1, P_{geom})$。这确保了在一对粒子之间，一个时间步内最多只发生一次碰撞。\n\n5.  **泡利阻塞**: 由于核子是费米子，它们必须遵守泡利不相容原理。一次碰撞只有在末态量子态是空闲的情况下才能发生。这被称为泡利阻塞（或乌林-乌伦贝克效应）。它通过一个抑制因子 $(1 - f_3)(1 - f_4)$ 来实现，其中 $f_3$ 和 $f_4$ 是碰撞后两个粒子将要占据的相空间单元的占据数。因此，最终的碰撞接受概率 $P_{ij}$ 是：\n    $$ P_{ij} = P_{capped} \\times (1 - f_3)(1 - f_4) = \\min\\left(1, \\frac{v_{rel} \\sigma_{eff} \\Delta t}{\\Delta V}\\right) (1 - f_3)(1 - f_4) $$\n\n6.  **总和计算**: 程序需要计算单元内所有无序粒子对 $(i,j)$（即 $i < j$）的接受概率 $P_{ij}$ 的总和 $S = \\sum_{i<j} P_{ij}$。\n\n此方法将微观的动力学原理转化为可在输运模拟中高效实现的随机算法。所提供的Python代码正是实现了这一逻辑，通过迭代所有粒子对，计算各自的 $P_{ij}$，并累加得到最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the BUU collision probability problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each test case is a dictionary containing all necessary parameters.\n    test_cases = [\n        # Test case 1 (happy path, no Pauli suppression)\n        {\n            \"delta_V\": 125.0,\n            \"delta_t\": 0.5,\n            \"sigma\": 4.0,\n            \"N_test\": 1,\n            \"particles\": {\n                0: {\"v\": np.array([0.2, 0.0, 0.0])},\n                1: {\"v\": np.array([-0.1, 0.0, 0.0])},\n            },\n            \"pauli_factors\": {\n                (0, 1): {\"f3\": 0.0, \"f4\": 0.0},\n            },\n        },\n        # Test case 2 (with Pauli suppression)\n        {\n            \"delta_V\": 125.0,\n            \"delta_t\": 0.5,\n            \"sigma\": 4.0,\n            \"N_test\": 1,\n            \"particles\": {\n                0: {\"v\": np.array([0.2, 0.0, 0.0])},\n                1: {\"v\": np.array([-0.1, 0.0, 0.0])},\n            },\n            \"pauli_factors\": {\n                (0, 1): {\"f3\": 0.7, \"f4\": 0.6},\n            },\n        },\n        # Test case 3 (multiple pairs, test-particle scaling, mixed Pauli factors)\n        {\n            \"delta_V\": 64.0,\n            \"delta_t\": 1.0,\n            \"sigma\": 2.0,\n            \"N_test\": 50,\n            \"particles\": {\n                0: {\"v\": np.array([0.2, 0.0, 0.0])},\n                1: {\"v\": np.array([0.0, 0.3, 0.0])},\n                2: {\"v\": np.array([-0.1, 0.0, 0.1])},\n            },\n            \"pauli_factors\": {\n                (0, 1): {\"f3\": 0.2, \"f4\": 0.1},\n                (0, 2): {\"f3\": 0.5, \"f4\": 0.6},\n                (1, 2): {\"f3\": 0.0, \"f4\": 0.0},\n            },\n        },\n        # Test case 4 (geometric probability exceeds one before capping)\n        {\n            \"delta_V\": 10.0,\n            \"delta_t\": 5.0,\n            \"sigma\": 4.0,\n            \"N_test\": 1,\n            \"particles\": {\n                0: {\"v\": np.array([0.8, 0.0, 0.0])},\n                1: {\"v\": np.array([0.0, 0.6, 0.0])},\n            },\n            \"pauli_factors\": {\n                (0, 1): {\"f3\": 0.0, \"f4\": 0.0},\n            },\n        },\n        # Test case 5 (zero relative speed)\n        {\n            \"delta_V\": 125.0,\n            \"delta_t\": 0.5,\n            \"sigma\": 4.0,\n            \"N_test\": 1,\n            \"particles\": {\n                0: {\"v\": np.array([0.2, 0.1, 0.1])},\n                1: {\"v\": np.array([0.2, 0.1, 0.1])},\n            },\n            \"pauli_factors\": {\n                (0, 1): {\"f3\": 0.0, \"f4\": 0.0},\n            },\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_V = case[\"delta_V\"]\n        delta_t = case[\"delta_t\"]\n        sigma = case[\"sigma\"]\n        N_test = case[\"N_test\"]\n        particles = case[\"particles\"]\n        pauli_factors_map = case[\"pauli_factors\"]\n\n        # Calculate effective cross section\n        sigma_eff = sigma / N_test\n        \n        # Initialize the sum of probabilities for the current test case\n        s_total = 0.0\n\n        # Generate all unique, unordered pairs of particle indices\n        particle_indices = list(particles.keys())\n        for i, j in combinations(particle_indices, 2):\n            # Fetch particle velocities\n            v_i = particles[i][\"v\"]\n            v_j = particles[j][\"v\"]\n\n            # 1. Calculate relative speed\n            v_rel = np.linalg.norm(v_i - v_j)\n\n            # If relative speed is zero, collision probability is zero\n            if v_rel == 0.0:\n                p_ij = 0.0\n            else:\n                # 2. Calculate the geometric probability\n                p_geom = (sigma_eff * v_rel * delta_t) / delta_V\n\n                # 3. Cap the geometric probability at 1.0\n                p_capped = min(1.0, p_geom)\n\n                # 4. Fetch the final-state occupation factors for the pair\n                # The pair (i,j) is always ordered (i  j) by itertools.combinations\n                f3 = pauli_factors_map[(i, j)][\"f3\"]\n                f4 = pauli_factors_map[(i, j)][\"f4\"]\n                \n                # 5. Calculate the Pauli blocking (Uehling-Uhlenbeck) factor\n                pauli_suppression = (1.0 - f3) * (1.0 - f4)\n                \n                # 6. Calculate the final acceptance probability for the pair\n                p_ij = p_capped * pauli_suppression\n\n            # 7. Add the pair's probability to the total sum for the cell\n            s_total += p_ij\n        \n        results.append(s_total)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3544841"}, {"introduction": "一个完整的 BUU 模拟需要将连续的平均场漂移和离散的随机碰撞过程耦合在一起进行时间演化。算子分裂法，特别是斯特朗 (Strang) 分裂，是组合这两种不同物理过程的强大而精确的技术。本练习使用一个简化的平流-弛豫模型，让您能够深入分析该数值格式的精度、稳定性和处理刚性问题的能力，这些都是构建可靠模拟程序时必须考虑的关键特性 [@problem_id:3544851]。", "problem": "考虑单粒子相空间占据数 $f(x,p,t)$ 的玻尔兹曼-乌林-乌伦贝克 (BUU) 输运方程，假设为一维空间和单一固定动量模式 $p$，因此漂移速度 $v$ 在时间和空间上是恒定的。在这种无平均场力的简化设定下，BUU 方程简化为线性平流-弛豫方程\n$$\n\\frac{\\partial f}{\\partial t} + v \\frac{\\partial f}{\\partial x} = -\\frac{1}{\\tau}\\left(f - f_{\\mathrm{eq}}\\right),\n$$\n其中 $v = p/m$，$m$ 是粒子质量，$\\tau$ 是弛豫时间，$f_{\\mathrm{eq}}$ 是一个恒定的费米-狄拉克平衡占据数（在此被视为在 $[0,1]$ 范围内的固定数值）。单位必须统一使用如下：位置 $x$ 的单位是飞米 (fm)，动量 $p$ 的单位是兆电子伏特每光速 (MeV$/c$)，质量 $m$ 的单位是兆电子伏特每光速平方 (MeV$/c^2$)，时间 $t$ 的单位是飞米每光速 (fm$/c$)。在这些单位下，速度 $v = p/m$ 是以光速 $c$ 为单位的无量纲量，平流项也是自洽的。\n\n你需要设计并实现一个 Strang 分裂（以 Gilbert Strang 的名字命名）格式，来对该方程进行时间积分。令碰撞算子表示为 $\\mathcal{C}[f] = -\\frac{1}{\\tau}(f - f_{\\mathrm{eq}})$，漂移算子表示为 $\\mathcal{D}[f] = -v \\frac{\\partial f}{\\partial x}$。在 $[t^n, t^{n+1}]$ 上，大小为 $\\Delta t$ 的 Strang 分裂时间步定义为以下组合\n$$\nf^{n+1} = \\exp\\left(\\frac{\\Delta t}{2}\\mathcal{C}\\right)\\,\\exp\\left(\\Delta t\\,\\mathcal{D}\\right)\\,\\exp\\left(\\frac{\\Delta t}{2}\\mathcal{C}\\right)\\,f^n,\n$$\n应用于一个长度为 $L$、由均匀网格离散化的周期性空间域上。精确地（通过解析弛豫）实现碰撞子步，使得对于大小为 $\\Delta t/2$ 的半步，\n$$\nf \\leftarrow f_{\\mathrm{eq}} + \\left(f - f_{\\mathrm{eq}}\\right)\\exp\\left(-\\frac{\\Delta t}{2\\tau}\\right),\n$$\n并使用针对带周期性边界条件的线性平流问题的 Lax-Wendroff 格式，实现一个大小为 $\\Delta t$ 的全步漂移子步，\n$$\nf_i^{*} = f_i^n - \\frac{\\alpha}{2}\\left(f_{i+1}^n - f_{i-1}^n\\right) + \\frac{\\alpha^2}{2}\\left(f_{i+1}^n - 2 f_i^n + f_{i-1}^n\\right),\n$$\n其中 $\\alpha = v\\,\\Delta t/\\Delta x$ 是库朗数，$\\Delta x = L/N$，$N$ 为网格点数。\n\n你必须从第一性原理出发，推导和分析以下内容：\n- Strang 分裂所近似的数学对象是什么（算子指数），为什么这种组合能达到时间上的二阶精度，以及为使 Lax-Wendroff 步稳定，Courant-Friedrichs-Lewy (CFL) 条件所要求的约束。\n- 为什么对碰撞子步的精确积分可以消除来自 $\\tau$ 的刚性约束，以及对于给定的初始数据，对 $f$ 有哪些正定性约束是预期的。\n\n用于验证的解析参考解：对于给定模型，在周期性边界条件以及 $v$ 和 $f_{\\mathrm{eq}}$ 为常数的情况下，其精确解为\n$$\nf(x,t) = f_{\\mathrm{eq}} + \\left(f_0\\big((x - v t)\\bmod L\\big) - f_{\\mathrm{eq}}\\right)\\exp\\left(-\\frac{t}{\\tau}\\right),\n$$\n其中 $f_0(x)$ 是初始条件。使用以下光滑初始条件\n$$\nf_0(x) = f_{\\mathrm{eq}} + A \\sin\\left(\\frac{2\\pi x}{L}\\right),\n$$\n其中振幅 $A$ 满足 $0  A  1$，以在连续模型中保持 $f \\in [0,1]$。\n\n你的程序必须按上述规定实现 Strang 分裂格式，并在以下测试套件上评估其经验精度阶和稳定性。对每个案例，在固定的库朗数 $\\alpha$ 下，使用粗网格和细网格（将 $N$ 加倍并将 $\\Delta x$ 减半）运行两次模拟，并为每个分辨率选择合适的 $\\Delta t$ 以保持目标 $\\alpha$。在最终时间 $T$ 时，计算与精确解之间的空间均方根 (RMS) 误差。然后计算观测精度阶，其定义为\n$$\np_{\\mathrm{obs}} = \\frac{\\log\\left(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}}\\right)}{\\log\\left(\\Delta t_{\\mathrm{coarse}}/\\Delta t_{\\mathrm{fine}}\\right)},\n$$\n其中 $E_{\\mathrm{coarse}}$ 和 $E_{\\mathrm{fine}}$ 分别是粗网格和细网格运行在时间 $T$ 时的 RMS 误差。同时，为每个案例报告两个布尔诊断量：在时间 $T$ 时，正定性约束 $0 \\le f \\le 1$ 是否被逐点满足，以及实际使用的库朗数是否满足稳定性约束 $\\alpha \\le 1$。\n\n使用以下测试套件，其中每个参数都给出了其物理单位：\n\n- 案例 1（理想路径，中等库朗数）：$L = 20\\,\\mathrm{fm}$，$N_{\\mathrm{coarse}} = 256$，$N_{\\mathrm{fine}} = 512$，$m = 938\\,\\mathrm{MeV}/c^2$，$p = 300\\,\\mathrm{MeV}/c$，$\\tau = 5\\,\\mathrm{fm}/c$，$f_{\\mathrm{eq}} = 0.5$，$A = 0.1$，目标 $\\alpha = 0.5$，最终时间 $T = 10\\,\\mathrm{fm}/c$。\n- 案例 2（接近 CFL 边界）：$L = 20\\,\\mathrm{fm}$，$N_{\\mathrm{coarse}} = 256$，$N_{\\mathrm{fine}} = 512$，$m = 938\\,\\mathrm{MeV}/c^2$，$p = 300\\,\\mathrm{MeV}/c$，$\\tau = 5\\,\\mathrm{fm}/c$，$f_{\\mathrm{eq}} = 0.5$，$A = 0.1$，目标 $\\alpha = 0.99$，最终时间 $T = 10\\,\\mathrm{fm}/c$。\n- 案例 3（刚性碰撞，精确弛豫）：$L = 20\\,\\mathrm{fm}$，$N_{\\mathrm{coarse}} = 256$，$N_{\\mathrm{fine}} = 512$，$m = 938\\,\\mathrm{MeV}/c^2$，$p = 300\\,\\mathrm{MeV}/c$，$\\tau = 0.2\\,\\mathrm{fm}/c$，$f_{\\mathrm{eq}} = 0.5$，$A = 0.1$，目标 $\\alpha = 0.5$，最终时间 $T = 4\\,\\mathrm{fm}/c$。\n\n数值细节：\n- 计算 $v = p/m$。\n- 对每个分辨率，设置 $\\Delta x = L/N$ 并选择 $\\Delta t$ 使得 $\\alpha = v\\,\\Delta t/\\Delta x$ 等于目标值。在 $x$ 方向使用周期性边界条件。\n- 为确保最终时间 $T$ 能通过整数个时间步达到，将 $\\Delta t$ 调整为 $\\Delta t^{\\star} = T/\\lfloor T/\\Delta t \\rceil$（最近整数取整），并在 Strang 格式和诊断计算中都使用这个调整后的 $\\Delta t^{\\star}$。报告实际的库朗数 $\\alpha^{\\star} = v\\,\\Delta t^{\\star}/\\Delta x$ 并与约束 $\\alpha^{\\star} \\le 1$ 对比。\n\n输出规范：\n- 对每个案例，计算并输出 5 个值 [$E_{\\mathrm{coarse}}$, $E_{\\mathrm{fine}}$, $p_{\\mathrm{obs}}$, positivity\\_ok, cfl\\_ok]，其中误差是无量纲的（占据数），$p_{\\mathrm{obs}}$ 是一个浮点数，两个诊断量是布尔值。\n- 你的程序应生成单行输出，其中包含所有三个案例的结果，按案例 1、2、3 的顺序连接成一个用方括号括起来的逗号分隔列表，即\n$$\n\\big[\\;E^{(1)}_{\\mathrm{coarse}}, E^{(1)}_{\\mathrm{fine}}, p^{(1)}_{\\mathrm{obs}}, \\text{positivity\\_ok}^{(1)}, \\text{cfl\\_ok}^{(1)}, E^{(2)}_{\\mathrm{coarse}}, E^{(2)}_{\\mathrm{fine}}, p^{(2)}_{\\mathrm{obs}}, \\text{positivity\\_ok}^{(2)}, \\text{cfl\\_ok}^{(2)}, E^{(3)}_{\\mathrm{coarse}}, E^{(3)}_{\\mathrm{fine}}, p^{(3)}_{\\mathrm{obs}}, \\text{positivity\\_ok}^{(3)}, \\text{cfl\\_ok}^{(3)}\\;\\big].\n$$\n不应打印任何额外文本。", "solution": "所述问题具有科学依据、是适定的，并且为其求解提供了所有必要的参数和条件。它代表了计算物理学中一个有效且可形式化的问题。\n\n### 解析推导与分析\n\n该问题要求对所提出的数值格式的几个方面进行推导和分析。\n\n**1. Strang 分裂：近似与精度**\n\n控制方程是一个非齐次偏微分方程，形式为 $\\frac{\\partial f}{\\partial t} = \\mathcal{D}[f] + \\mathcal{C}[f]$，其中 $\\mathcal{D}[f] = -v \\frac{\\partial f}{\\partial x}$ 是漂移算子，$\\mathcal{C}[f] = -\\frac{1}{\\tau}(f - f_{\\mathrm{eq}})$ 是碰撞算子。在一个时间步 $\\Delta t$ 上的形式解可以用演化算子 $\\Phi_{\\Delta t}^{\\text{exact}}$ 写出，使得 $f(t+\\Delta t) = \\Phi_{\\Delta t}^{\\text{exact}}[f(t)]$。\n\n算子分裂法通过组合各个子问题（$\\frac{\\partial f}{\\partial t} = \\mathcal{D}[f]$ 和 $\\frac{\\partial f}{\\partial t} = \\mathcal{C}[f]$）的演化来近似这种组合演化。令 $\\Phi_{\\Delta t}^{\\mathcal{D}}$ 和 $\\Phi_{\\Delta t}^{\\mathcal{C}}$ 分别为漂移部分和碰撞部分的精确流算子。\n\nStrang 分裂通过一个对称组合提供了对真实演化的二阶精度近似：\n$$\n\\Phi_{\\Delta t}^{\\text{Strang}} = \\Phi_{\\Delta t/2}^{\\mathcal{C}} \\circ \\Phi_{\\Delta t}^{\\mathcal{D}} \\circ \\Phi_{\\Delta t/2}^{\\mathcal{C}}\n$$\n尽管完整的证明涉及到针对非对易算子的 Baker-Campbell-Hausdorff (BCH) 公式，但通过分析算子的泰勒级数展开可以直观地理解其二阶精度。一个简单的一阶分裂，例如 Godunov 分裂 $\\Phi_{\\Delta t}^{\\mathcal{D}} \\circ \\Phi_{\\Delta t}^{\\mathcal{C}}$，其局部截断误差为 $O(\\Delta t^2)$ 阶。Strang 分裂中的对称组合使得 $O(\\Delta t^2)$ 阶的误差项相互抵消，从而得到 $O(\\Delta t^3)$ 阶的局部截断误差。当在固定时间区间 $T = N \\Delta t$ 上积分时，局部误差的累积导致全局误差为 $O(\\Delta t^2)$ 阶，从而使该格式在时间上达到二阶精度。即使算子 $\\mathcal{C}$ 是仿射的，这一结论也成立，因为分裂是应用于流（子问题的解），而不仅仅是算子本身。数值实现用一个数值近似（Lax-Wendroff 格式）替代了精确流 $\\Phi_{\\Delta t}^{\\mathcal{D}}$，该格式本身对于平流方程在空间和时间上是二阶的。只要空间误差不占主导地位，整个格式的时间精度就由分裂方法决定。\n\n**2. Lax-Wendroff 稳定性的 CFL 条件**\n\n针对线性平流方程 $\\frac{\\partial f}{\\partial t} + v \\frac{\\partial f}{\\partial x} = 0$ 的 Lax-Wendroff 步的稳定性，我们使用 von Neumann 稳定性分析法进行分析。我们寻找形式为 $f_j^n = g(k)^n e^{i k j \\Delta x}$ 的解，其中 $f_j^n$ 是在网格点 $j$ 和时间步 $n$ 的数值解，$k$ 是波数，$g(k)$ 是放大因子。稳定性要求对所有 $k$ 都有 $|g(k)| \\le 1$。\n\n将此形式代入 Lax-Wendroff 更新公式：\n$$\nf_j^{n+1} = f_j^n - \\frac{\\alpha}{2}\\left(f_{j+1}^n - f_{j-1}^n\\right) + \\frac{\\alpha^2}{2}\\left(f_{j+1}^n - 2 f_j^n + f_{j-1}^n\\right)\n$$\n其中 $\\alpha = v \\Delta t / \\Delta x$，可以得到放大因子 $g$ 作为无量纲波数 $\\theta = k \\Delta x$ 的函数：\n$$\ng(\\theta) = 1 - \\frac{\\alpha}{2}(e^{i\\theta} - e^{-i\\theta}) + \\frac{\\alpha^2}{2}(e^{i\\theta} - 2 + e^{-i\\theta})\n$$\n使用欧拉公式，上式可简化为：\n$$\ng(\\theta) = 1 - i\\alpha\\sin\\theta + \\alpha^2(\\cos\\theta - 1)\n$$\n放大因子的模的平方为：\n$$\n|g(\\theta)|^2 = (1 + \\alpha^2(\\cos\\theta - 1))^2 + (-\\alpha\\sin\\theta)^2 = 1 - 4\\alpha^2(1-\\alpha^2)\\sin^4(\\theta/2)\n$$\n为了稳定性，我们要求 $|g(\\theta)|^2 \\le 1$。由于 $\\sin^4(\\theta/2) \\ge 0$ 且 $\\alpha^2 \\ge 0$，该条件当且仅当 $1 - \\alpha^2 \\ge 0$ 时满足。这导出了 Lax-Wendroff 格式的 Courant-Friedrichs-Lewy (CFL) 条件：\n$$\n|\\alpha| = \\left| \\frac{v \\Delta t}{\\Delta x} \\right| \\le 1\n$$\n\n**3. 碰撞项的刚性**\n\n碰撞项通过常微分方程 $\\frac{df}{dt} = -\\frac{1}{\\tau}(f - f_{\\mathrm{eq}})$ 使占据数弛豫到平衡态。如果使用简单的显式方法（如前向欧拉法）来离散化该方程，更新式将是 $f^{n+1} = f^n - \\frac{\\Delta t}{\\tau}(f^n - f_{\\mathrm{eq}})$。这种显式格式的稳定性要求 $|1 - \\Delta t/\\tau| \\le 1$，这施加了严苛的时间步长约束 $\\Delta t \\le 2\\tau$。\n\n当弛豫时间 $\\tau$ 非常小（即“刚性”系统）时，这个约束将迫使 $\\Delta t$ 变得不切实际地小，可能远小于平流部分 CFL 条件所要求的时间步长。该问题通过强制要求对碰撞子步使用精确解析解，巧妙地规避了这个问题：\n$$\nf(t+\\Delta t/2) = f_{\\mathrm{eq}} + \\left(f(t) - f_{\\mathrm{eq}}\\right)\\exp\\left(-\\frac{\\Delta t}{2\\tau}\\right)\n$$\n由于对于任何 $\\Delta t > 0$ 和 $\\tau > 0$，$\\exp(-\\Delta t/(2\\tau))$ 都是一个小于 1 的正值，因此这个更新是无条件稳定的。无论比值 $\\Delta t/\\tau$ 的大小如何，该更新都能正确且稳定地将 $f$ 推向 $f_{\\mathrm{eq}}$。这完全消除了刚性约束，允许时间步长 $\\Delta t$ 仅根据精度要求和非刚性平流求解器的 CFL 稳定性条件来选择。\n\n**4. 正定性约束**\n\n对于费米子，单粒子占据数 $f$ 根据泡利不相容原理在物理上被限制在区间 $[0, 1]$ 内。所提供的初始条件 $f_0(x) = f_{\\mathrm{eq}} + A \\sin(2\\pi x/L)$，其中 $f_{\\mathrm{eq}}=0.5$ 和 $A=0.1$，满足此条件，因为 $f_0(x) \\in [0.4, 0.6]$。由于正弦振幅会衰减，解析解在所有时间都保持在这些界限内。\n\n在数值格式中：\n- **碰撞步**：更新式 $f_{\\text{new}} = f_{\\mathrm{eq}} + (f_{\\text{old}} - f_{\\mathrm{eq}}) e^{-\\Delta t/(2\\tau)}$ 是一个朝向 $f_{\\mathrm{eq}}$ 的压缩映射。如果 $f_{\\text{old}} \\in [0, 1]$，那么 $f_{\\text{new}}$ 也将在 $[0, 1]$ 内，并且实际上会比 $f_{\\text{old}}$ 更接近 $f_{\\mathrm{eq}}$。因此，这一步是保正定性和保界的。\n- **漂移步 (Lax-Wendroff)**：该格式是线性的，不保证保正定性。众所周知，它在陡峭梯度附近或当库朗数接近稳定性极限时会产生伪振荡（过冲和下冲）。尽管初始条件是光滑的，但这些色散误差仍可能导致 $f$ 的值超出物理范围 $[0, 1]$。这是高阶线性平流格式的一个已知局限，需要更复杂的方法（例如配备通量限制器的方法）来严格强制执行此类界限。该问题要求诊断这种潜在的失效。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lax_wendroff_step(f, alpha):\n    \"\"\"\n    Applies a single Lax-Wendroff step for linear advection with periodic boundaries.\n    The update formula is:\n    f_i* = f_i - (alpha/2)(f_{i+1}-f_{i-1}) + (alpha^2/2)(f_{i+1}-2f_i+f_{i-1})\n    \"\"\"\n    f_p1 = np.roll(f, -1)  # f_{i+1}\n    f_m1 = np.roll(f, 1)   # f_{i-1}\n    \n    term1 = (alpha / 2.0) * (f_p1 - f_m1)\n    term2 = (alpha**2 / 2.0) * (f_p1 - 2.0 * f + f_m1)\n    \n    return f - term1 + term2\n\ndef collision_step(f, dt_half, tau, feq):\n    \"\"\"\n    Applies the exact solution of the collision term for a half time step dt_half.\n    This corresponds to the operator exp(dt_half * C).\n    \"\"\"\n    return feq + (f - feq) * np.exp(-dt_half / tau)\n\ndef analytical_solution(x, t, L, v, tau, feq, A):\n    \"\"\"\n    Computes the exact analytical solution for verification.\n    \"\"\"\n    # Advect the initial profile backwards in time by x - v*t\n    # The modulo operator handles periodic boundary conditions correctly\n    x_shifted = (x - v * t) % L\n    f0_shifted = feq + A * np.sin(2.0 * np.pi * x_shifted / L)\n    \n    # Apply the exponential decay from the relaxation term\n    return feq + (f0_shifted - feq) * np.exp(-t / tau)\n\ndef run_simulation(N, L, v, tau, feq, A, target_alpha, T):\n    \"\"\"\n    Runs a single simulation for a given grid resolution and parameters.\n    Returns the RMS error, final state f, adjusted time step, and adjusted Courant number.\n    \"\"\"\n    dx = L / N\n    x = np.arange(N) * dx\n    \n    # Determine the ideal time step for the target Courant number\n    dt_target = target_alpha * dx / v\n    if dt_target == 0:\n        raise ValueError(\"Target time step must be positive.\")\n\n    # Adjust dt to hit the final time T exactly, using an integer number of steps\n    num_steps = int(np.rint(T / dt_target))\n    if num_steps == 0:\n        num_steps = 1 # Ensure at least one step for very small T or large dt_target\n    dt_star = T / num_steps\n    alpha_star = v * dt_star / dx\n\n    # Set initial condition\n    f = feq + A * np.sin(2.0 * np.pi * x / L)\n\n    # Time evolution using the Strang splitting scheme\n    for _ in range(num_steps):\n        # 1. Half collision step\n        f = collision_step(f, dt_star / 2.0, tau, feq)\n        # 2. Full drift step using Lax-Wendroff\n        f = lax_wendroff_step(f, alpha_star)\n        # 3. Half collision step\n        f = collision_step(f, dt_star / 2.0, tau, feq)\n    \n    f_numerical_final = f\n    f_exact_final = analytical_solution(x, T, L, v, tau, feq, A)\n    \n    # Compute the spatial Root-Mean-Square (RMS) error\n    rms_error = np.sqrt(np.mean((f_numerical_final - f_exact_final)**2))\n\n    return rms_error, f_numerical_final, dt_star, alpha_star\n\ndef process_case(case_params):\n    \"\"\"\n    Processes a single test case, running simulations on coarse and fine grids\n    and computing the required output metrics.\n    \"\"\"\n    L = case_params['L']\n    N_coarse = case_params['N_coarse']\n    N_fine = case_params['N_fine']\n    m = case_params['m']\n    p = case_params['p']\n    tau = case_params['tau']\n    feq = case_params['f_eq']\n    A = case_params['A']\n    target_alpha = case_params['target_alpha']\n    T = case_params['T']\n    \n    # Calculate drift velocity (dimensionless in units of c)\n    v = p / m\n\n    # Coarse grid simulation\n    E_coarse, f_final_coarse, dt_coarse, alpha_coarse = run_simulation(\n        N_coarse, L, v, tau, feq, A, target_alpha, T)\n\n    # Fine grid simulation\n    E_fine, f_final_fine, dt_fine, alpha_fine = run_simulation(\n        N_fine, L, v, tau, feq, A, target_alpha, T)\n        \n    # Calculate observed order of accuracy\n    # p_obs = log(E_coarse/E_fine) / log(dt_coarse/dt_fine)\n    # Since dt is proportional to dx, this is approximately log(E_c/E_f)/log(2)\n    # Using the actual adjusted time steps is more precise.\n    ratio_dt = dt_coarse / dt_fine\n    if E_coarse == 0 or E_fine == 0 or ratio_dt == 1:\n        p_obs = np.nan # Avoid division by zero or log of non-positive\n    else:\n        p_obs = np.log(E_coarse / E_fine) / np.log(ratio_dt)\n    \n    # Check physical and numerical constraints for the case\n    # Positivity: 0 = f = 1 must hold for all grid points at final time T\n    positivity_ok_coarse = np.all((f_final_coarse = 0.0)  (f_final_coarse = 1.0))\n    positivity_ok_fine = np.all((f_final_fine = 0.0)  (f_final_fine = 1.0))\n    positivity_ok = positivity_ok_coarse and positivity_ok_fine\n    \n    # CFL stability: actual Courant number alpha* = 1\n    cfl_ok_coarse = alpha_coarse = 1.0\n    cfl_ok_fine = alpha_fine = 1.0\n    cfl_ok = cfl_ok_coarse and cfl_ok_fine\n    \n    return [E_coarse, E_fine, p_obs, positivity_ok, cfl_ok]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run them, and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: Happy path, moderate Courant number\n        {'L': 20.0, 'N_coarse': 256, 'N_fine': 512, 'm': 938.0, 'p': 300.0,\n         'tau': 5.0, 'f_eq': 0.5, 'A': 0.1, 'target_alpha': 0.5, 'T': 10.0},\n        # Case 2: Near CFL boundary\n        {'L': 20.0, 'N_coarse': 256, 'N_fine': 512, 'm': 938.0, 'p': 300.0,\n         'tau': 5.0, 'f_eq': 0.5, 'A': 0.1, 'target_alpha': 0.99, 'T': 10.0},\n        # Case 3: Stiff collision term\n        {'L': 20.0, 'N_coarse': 256, 'N_fine': 512, 'm': 938.0, 'p': 300.0,\n         'tau': 0.2, 'f_eq': 0.5, 'A': 0.1, 'target_alpha': 0.5, 'T': 4.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = process_case(case)\n        results.extend(case_results)\n\n    # Format the final output string as specified\n    # map(str, ...) handles conversion of floats and booleans to strings\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3544851"}]}