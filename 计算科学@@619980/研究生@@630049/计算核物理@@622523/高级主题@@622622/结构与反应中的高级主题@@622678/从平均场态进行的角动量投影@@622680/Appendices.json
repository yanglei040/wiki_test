{"hands_on_practices": [{"introduction": "任何可靠的数值计算代码都必须建立在可验证的组件之上。对于角动量投影而言，其核心数学对象是维格纳D-矩阵，其性质从群论中可以精确得知。这项练习将指导您实现一个关键的单元测试：数值验证维格纳D-矩阵的正交关系[@problem_id:3542272]。成功完成此练习可确保您在将代码应用于更复杂的物理态之前，所实现的D-矩阵以及对欧拉角的积分是正确的。", "problem": "考虑在计算核物理中从平均场态进行角动量投影的背景下，数值验证维格纳旋转矩阵元正交性的问题。维格纳旋转矩阵元定义为 $D^{J}_{M K}(\\alpha,\\beta,\\gamma) = \\langle J M \\vert \\hat{R}(\\alpha,\\beta,\\gamma) \\vert J K \\rangle$，其中 $\\hat{R}(\\alpha,\\beta,\\gamma) = e^{-i \\alpha \\hat{J}_{z}} e^{-i \\beta \\hat{J}_{y}} e^{-i \\gamma \\hat{J}_{z}}$，且 $\\alpha,\\beta,\\gamma$ 是以弧度为单位的欧拉角。旋转群上的积分测度是哈尔测度，$d\\Omega = d\\alpha\\,\\sin\\beta\\,d\\beta\\,d\\gamma$，其中 $\\alpha \\in [0,2\\pi)$，$\\beta \\in [0,\\pi]$，$\\gamma \\in [0,2\\pi)$。\n\n根据三阶特殊正交群（SO(3)）的幺正不可约表示的基本性质及其与二阶特殊幺正群（SU(2)）的关系，矩阵元 $D^{J}_{M K}(\\alpha,\\beta,\\gamma)$ 在群流形上相对于哈尔测度满足一个正交关系。这一恒等式对于构建和验证用于将平均场态投影到具有良好总角动量态的角动量投影算符至关重要。\n\n您的任务是编写一个完整的程序，该程序：\n- 通过因子分解 $D^{J}_{M K}(\\alpha,\\beta,\\gamma) = e^{-i M \\alpha}\\, d^{J}_{M K}(\\beta)\\, e^{-i K \\gamma}$ 实现 $D^{J}_{M K}(\\alpha,\\beta,\\gamma)$，其中 $d^{J}_{M K}(\\beta)$ 是通过计算给定 $J$ 值下 $e^{-i \\beta \\hat{J}_{y}}$ 在 $\\hat{J}_{z}$ 本征基中的矩阵元得到的。\n- 使用以下求积方法和角度单位，数值计算三重积分\n$$\nI(J,J',M,M',K,K') = \\int_{0}^{2\\pi} d\\alpha \\int_{0}^{\\pi} \\sin\\beta\\, d\\beta \\int_{0}^{2\\pi} d\\gamma \\; D^{J}_{M K}(\\alpha,\\beta,\\gamma)\\, \\left[D^{J'}_{M' K'}(\\alpha,\\beta,\\gamma)\\right]^{*}\n$$\n  - 角度以弧度为单位。\n  - $\\alpha$ 和 $\\gamma$ 积分必须使用等距梯形法则，在 $[0,2\\pi)$ 上取 $N_{\\alpha} = N_{\\gamma} = 128$ 个节点。\n  - $\\beta$ 积分必须使用高斯-勒让德求积，在 $[-1,1]$ 上取 $N_{\\beta} = 64$ 个节点，并应用于变量代换 $x = \\cos\\beta$，从而 $\\int_{0}^{\\pi} \\sin\\beta f(\\beta)\\, d\\beta = \\int_{-1}^{1} f(\\arccos x)\\, dx$。\n- 将数值积分 $I(J,J',M,M',K,K')$ 与解析值\n$$\nI_{\\text{analytic}}(J,J',M,M',K,K') = \\frac{8\\pi^{2}}{2J+1}\\, \\delta_{J J'}\\, \\delta_{M M'}\\, \\delta_{K K'}\n$$\n进行比较，并使用以下判据为每个测试用例返回一个布尔值的“通过/失败”结果\n$$\n\\left| I - I_{\\text{analytic}} \\right| \\le \\varepsilon \\times \\max\\!\\left(1, \\left| I_{\\text{analytic}} \\right| \\right),\n$$\n其中容差 $\\varepsilon = 10^{-6}$。\n\n实现细节和约束：\n- 在标准的 $\\hat{J}_{z}$ 本征基 $\\{ \\vert J m \\rangle \\}_{m=-J,\\dots,+J}$ 中，使用升降算符 $\\hat{J}_{\\pm}$ 和 $\\hat{J}_{z}$ 构建 $\\hat{J}_{y}$。使用 $\\hat{J}_{+} \\vert J m \\rangle = \\sqrt{J(J+1) - m(m+1)} \\vert J (m+1) \\rangle$，$\\hat{J}_{-} = \\hat{J}_{+}^{\\dagger}$，$\\hat{J}_{x} = (\\hat{J}_{+} + \\hat{J}_{-})/2$，以及 $\\hat{J}_{y} = (\\hat{J}_{+} - \\hat{J}_{-})/(2i)$。设 $\\hbar = 1$。\n- 将 $d^{J}_{M K}(\\beta)$ 计算为 $e^{-i \\beta \\hat{J}_{y}}$ 的 $(M,K)$ 矩阵元。您不能使用 $d^{J}_{M K}(\\beta)$ 的闭合级数形式；必须通过计算 $\\hat{J}_{y}$ 的矩阵指数来得到它。\n- 所有角度必须以弧度为单位处理。\n- 积分必须按照上述指定的数值求积方法计算，而不是通过解析简化。\n\n测试套件：\n评估以下六个案例的布尔“通过/失败”结果，每个案例指定为元组 $(J,J',M,M',K,K')$，其中所有量子数均为整数，满足 $-J \\le M,K \\le J$ 和 $-J' \\le M',K' \\le J'$：\n- 案例 1：$(0,0,0,0,0,0)$。\n- 案例 2：$(1,1,1,1,-1,-1)$。\n- 案例 3：$(2,2,0,1,2,2)$。\n- 案例 4：$(2,3,0,0,-1,-1)$。\n- 案例 5：$(3,3,-2,-2,1,-1)$。\n- 案例 6：$(4,4,0,0,0,0)$。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表，其顺序与上述案例的顺序完全一致。例如，一个有效的输出应如下所示：\"[True,False,True,True,True,True]\"。", "solution": "该问题要求对维格纳D-矩阵元的正交关系进行数值验证，这是从旋转群 $SO(3)$ 的表示论中导出的一个基本性质。该关系由以下积分给出：\n$$\nI(J,J',M,M',K,K') = \\int d\\Omega \\; D^{J}_{M K}(\\Omega)\\, \\left[D^{J'}_{M' K'}(\\Omega)\\right]^{*} = \\frac{8\\pi^{2}}{2J+1}\\, \\delta_{J J'}\\, \\delta_{M M'}\\, \\delta_{K K'}\n$$\n其中 $\\Omega = (\\alpha, \\beta, \\gamma)$ 表示欧拉角，$d\\Omega = d\\alpha\\,\\sin\\beta\\,d\\beta\\,d\\gamma$ 是哈尔测度。我们的任务是实现一个数值程序，为给定的量子数组 $(J,J',M,M',K,K')$ 计算这个积分，并验证结果在指定的容差 $\\varepsilon = 10^{-6}$ 内与解析公式相符。\n\n算法解决方案包括四个主要阶段：\n1.  构建角动量算符 $\\hat{J}_y$ 的矩阵表示。\n2.  通过矩阵指数计算维格纳d-矩阵 $d^J(\\beta)$。\n3.  使用规定的数值求积方法计算关于 $(\\alpha, \\beta, \\gamma)$ 的三维积分。\n4.  将数值结果与解析值进行比较，以确定“通过/失败”的结果。\n\n**1. 角动量算符的矩阵表示**\n\n对于一个给定总角动量量子数 $J$ 的系统，其状态空间由 $2J+1$ 个正交归一的基矢 $|\\,J, M\\rangle$ 张成，其中磁量子数 $M$ 的取值为 $M = -J, -J+1, \\dots, J$。我们可以将这些基态表示为 $(2J+1)$ 维复向量空间中的列向量。一个标准的约定是通过关系 $i=M+J$ 将量子数 $M$ 映射到从零开始的矩阵索引 $i$。\n\n角动量算符 $\\hat{J}_{\\pm}$ 和 $\\hat{J}_z$ 作用于这些基态。问题要求从升降算符构建 $\\hat{J}_y$，其作用定义如下：\n$$\n\\hat{J}_{+} |\\,J, M\\rangle = \\sqrt{J(J+1) - M(M+1)} \\,|\\,J, M+1\\rangle\n$$\n$$\n\\hat{J}_{-} |\\,J, M\\rangle = \\sqrt{J(J+1) - M(M-1)} \\,|\\,J, M-1\\rangle\n$$\n在所选基中，矩阵元 $\\langle J, M'| \\hat{J}_+ | J, M \\rangle$ 仅在 $M' = M+1$ 时非零。这意味着 $\\hat{J}_+$ 是一个仅在上对角线有非零元素的矩阵。其厄米共轭 $\\hat{J}_- = \\hat{J}_+^{\\dagger}$ 在下对角线有非零元素。设 $\\hbar=1$，则 $\\hat{J}_y$ 的矩阵表示计算如下：\n$$\n\\hat{J}_y = \\frac{\\hat{J}_+ - \\hat{J}_-}{2i}\n$$\n这会得到一个纯虚、反对称的 $(2J+1) \\times (2J+1)$ 矩阵。\n\n**2. 维格纳d-矩阵和D-矩阵的计算**\n\n问题指定了维格纳D-矩阵的因子分解形式：\n$$\nD^{J}_{M K}(\\alpha,\\beta,\\gamma) = e^{-i M \\alpha}\\, d^{J}_{M K}(\\beta)\\, e^{-i K \\gamma}\n$$\n其核心部分，维格纳（小）d-矩阵元 $d^{J}_{M K}(\\beta)$，是围绕y轴旋转算符的矩阵元：\n$$\nd^{J}_{M K}(\\beta) = \\langle J, M | e^{-i \\beta \\hat{J}_{y}} | J, K \\rangle\n$$\n按照要求，这不是通过解析公式计算的，而是首先计算矩阵指数 $d^J(\\beta) = \\exp(-i\\beta \\hat{J}_y)$，其中 $\\hat{J}_y$ 是上一步中构建的矩阵。然后从这个得到的 $(2J+1) \\times (2J+1)$ 矩阵的第 $i=M+J$ 行和第 $j=K+J$ 列提取所需的元素 $d^{J}_{M K}(\\beta)$。\n\n**3. 正交性积分的数值计算**\n\n需要计算的积分是：\n$$\nI = \\int_{0}^{2\\pi} d\\alpha \\int_{0}^{\\pi} \\sin\\beta\\, d\\beta \\int_{0}^{2\\pi} d\\gamma \\; D^{J}_{M K}(\\alpha,\\beta,\\gamma)\\, \\left[D^{J'}_{M' K'}(\\alpha,\\beta,\\gamma)\\right]^{*}\n$$\n代入 $D$ 及其复共轭的因子分解形式得到：\n$$\nI = \\int_{0}^{2\\pi} e^{-i(M-M')\\alpha}d\\alpha \\int_{0}^{\\pi} d^{J}_{M K}(\\beta)\\left[d^{J'}_{M' K'}(\\beta)\\right]^{*} \\sin\\beta d\\beta \\int_{0}^{2\\pi} e^{-i(K-K')\\gamma}d\\gamma\n$$\n问题严格要求这个三重积分必须使用不同的数值方法对每个维度进行计算。\n\n**$\\alpha$ 和 $\\gamma$ 积分：** 这两个积分使用梯形法则，在区间 $[0, 2\\pi)$ 上分别取 $N_\\alpha=128$ 和 $N_\\gamma=128$ 个点进行计算。对于形如 $\\int_0^{2\\pi} e^{-i\\Delta n \\theta} d\\theta$ 的积分，梯形近似为 $\\frac{2\\pi}{N} \\sum_{j=0}^{N-1} e^{-i\\Delta n \\theta_j}$，其中 $\\theta_j = 2\\pi j / N$。这个和是一个等比级数，当 $\\Delta n$ 是 $N$ 的倍数（包括 $0$）时，其值为 $N$；否则为 $0$。对于测试用例中的整数值 $M, M', K, K'$，$|M-M'| \\ll N_\\alpha$ 且 $|K-K'| \\ll N_\\gamma$。因此，数值积分将是精确的，得到 $2\\pi \\delta_{MM'}$ 和 $2\\pi \\delta_{KK'}$。\n\n**$\\beta$ 积分：** $\\beta$ 积分是 $I_\\beta = \\int_0^\\pi f(\\beta) \\sin\\beta d\\beta$，其中 $f(\\beta) = d^{J}_{M K}(\\beta)\\left[d^{J'}_{M' K'}(\\beta)\\right]^{*}$。应用变量代换 $x = \\cos\\beta$，使得 $dx = -\\sin\\beta d\\beta$，积分变为 $I_\\beta = \\int_{-1}^1 f(\\arccos x) dx$。这使用 $N_\\beta=64$ 点的高斯-勒让德求积进行计算。我们得到一组节点 $x_k$ 和权重 $w_k$，积分通过以下求和来近似：\n$$\nI_\\beta \\approx \\sum_{k=0}^{N_\\beta-1} w_k \\, d^{J}_{M K}(\\arccos x_k)\\left[d^{J'}_{M' K'}(\\arccos x_k)\\right]^{*}\n$$\n\n总的数值积分 $I_{\\text{numeric}}$ 是这三个一维求积结果的乘积。\n\n**4. 比较与验证**\n\n对于每个测试用例，将数值计算的积分 $I_{\\text{numeric}}$ 与解析值 $I_{\\text{analytic}} = \\frac{8\\pi^{2}}{2J+1}\\, \\delta_{J J'}\\, \\delta_{M M'}\\, \\delta_{K K'}$ 进行比较。验证标准是一个混合的绝对-相对误差测试：\n$$\n\\left| I_{\\text{numeric}} - I_{\\text{analytic}} \\right| \\le \\varepsilon \\times \\max\\!\\left(1, \\left| I_{\\text{analytic}} \\right| \\right)\n$$\n其中 $\\varepsilon = 10^{-6}$。这确保了当 $I_{\\text{analytic}}=0$ 时，测试变为对绝对容差 $\\varepsilon$ 的检查；而当 $I_{\\text{analytic}}$ 非零时，则为相对容差检查。根据此比较返回一个布尔值结果（`True`/`False`）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for validating the orthogonality of Wigner D-matrices.\n    \"\"\"\n    \n    # Test suite: each tuple is (J, J', M, M', K, K')\n    test_cases = [\n        (0, 0, 0, 0, 0, 0),    # Case 1\n        (1, 1, 1, 1, -1, -1), # Case 2\n        (2, 2, 0, 1, 2, 2),    # Case 3\n        (2, 3, 0, 0, -1, -1), # Case 4\n        (3, 3, -2, -2, 1, -1), # Case 5\n        (4, 4, 0, 0, 0, 0),    # Case 6\n    ]\n\n    # Memoization caches for angular momentum and d-matrices\n    jy_matrices_cache = {}\n    d_matrices_cache = {}\n    \n    def get_jy(j_val):\n        \"\"\"\n        Constructs the matrix representation of the J_y angular momentum operator.\n        Uses memoization to avoid redundant calculations.\n        \"\"\"\n        if j_val in jy_matrices_cache:\n            return jy_matrices_cache[j_val]\n\n        if not isinstance(j_val, int) or j_val  0:\n            raise ValueError(\"J must be a non-negative integer.\")\n        \n        dim = 2 * j_val + 1\n        m_values = np.arange(-j_val, j_val + 1)\n        \n        jp_matrix = np.zeros((dim, dim), dtype=np.complex128)\n        jm_matrix = np.zeros((dim, dim), dtype=np.complex128)\n        \n        for i in range(dim):\n            m = m_values[i]\n            if m  j_val:\n                jp_matrix[i + 1, i] = np.sqrt(j_val * (j_val + 1) - m * (m + 1))\n            if m > -j_val:\n                jm_matrix[i - 1, i] = np.sqrt(j_val * (j_val + 1) - m * (m - 1))\n        \n        jy_matrix = (jp_matrix - jm_matrix) / (2j)\n        jy_matrices_cache[j_val] = jy_matrix\n        return jy_matrix\n\n    def get_d_matrix(j_val, beta):\n        \"\"\"Calculates the Wigner d-matrix by matrix exponentiation.\"\"\"\n        key = (j_val, float(beta))\n        if key in d_matrices_cache:\n            return d_matrices_cache[key]\n        \n        jy = get_jy(j_val)\n        d_mat = expm(-1j * beta * jy)\n        d_matrices_cache[key] = d_mat\n        return d_mat\n\n    # Quadrature setup\n    N_alpha = 128\n    N_gamma = 128\n    N_beta = 64\n    x_nodes, w_nodes = leggauss(N_beta)\n    beta_nodes = np.arccos(x_nodes)\n\n    results = []\n    for case in test_cases:\n        J, J_prime, M, M_prime, K, K_prime = case\n\n        # Alpha and Gamma integrals\n        # Numerically evaluating using trapezoid rule\n        alpha_pts = np.linspace(0, 2 * np.pi, N_alpha, endpoint=False)\n        gamma_pts = np.linspace(0, 2 * np.pi, N_gamma, endpoint=False)\n        \n        integral_alpha = (2 * np.pi / N_alpha) * np.sum(np.exp(-1j * (M - M_prime) * alpha_pts))\n        integral_gamma = (2 * np.pi / N_gamma) * np.sum(np.exp(-1j * (K - K_prime) * gamma_pts))\n\n        # Beta integral\n        integral_beta_sum = 0.0j\n        for i in range(N_beta):\n            beta = beta_nodes[i]\n            \n            d_J_matrix = get_d_matrix(J, beta)\n            d_J_MK = d_J_matrix[M + J, K + J]\n            \n            d_J_prime_matrix = get_d_matrix(J_prime, beta)\n            d_J_prime_val = d_J_prime_matrix[M_prime + J_prime, K_prime + J_prime]\n\n            integrand_val = d_J_MK * np.conj(d_J_prime_val)\n            integral_beta_sum += w_nodes[i] * integrand_val\n        \n        numerical_I = integral_alpha * integral_gamma * integral_beta_sum\n\n        # Analytical value\n        if J == J_prime and M == M_prime and K == K_prime:\n            analytical_I = (8 * np.pi**2) / (2 * J + 1)\n        else:\n            analytical_I = 0.0\n\n        # Comparison\n        epsilon = 1e-6\n        tolerance_check = epsilon * max(1, abs(analytical_I))\n        \n        pass_test = abs(numerical_I - analytical_I) = tolerance_check\n        results.append(pass_test)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3542272"}, {"introduction": "在核心积分工具得到验证之后，下一步是在一个简单且易于理解的物理系统上测试投影算符。一个具有旋转不变性（即球形）的平均场态提供了完美的测试案例，因为它理论上只应包含$J=0$的分量。这项练习要求您对一个球形核态进行投影，并数值验证其投影后得到的振幅仅在总角动量为$J=0$时非零[@problem_id:3542237]。这个实践是整个投影框架的一个重要的“健全性检查”，用以确认代码能够正确处理旋转对称性的物理内涵。", "problem": "考虑一个在核多体理论中表示偶偶核、旋转不变的Hartree-Fock (HF) 态的平均场Slater行列式。这样的一个态在三维转动群的作用下是不变的，因此对于以弧度为单位的任何欧拉角 $\\Omega = (\\alpha,\\beta,\\gamma)$，都有 $\\,\\hat{R}(\\Omega)\\,|\\Phi\\rangle = |\\Phi\\rangle\\,$，其中 $\\hat{R}(\\Omega)$ 是由欧拉角参数化的旋转复合所定义的幺正旋转算符。将态投影到总角动量 $J$ 及其在实验室坐标系和内禀坐标系中的投影 $M$ 和 $K$ 上的角动量投影算符 $\\hat{P}^J_{MK}$，由一个包含Wigner $D$-函数的、在旋转群上的群积分定义，\n$$\n\\hat{P}^{J}_{MK} \\equiv \\frac{2J+1}{8\\pi^2} \\int_{0}^{2\\pi}\\!\\!d\\alpha\\int_{0}^{\\pi}\\!\\!d\\beta\\,\\sin\\beta\\int_{0}^{2\\pi}\\!\\!d\\gamma\\; D^{J}_{MK}(\\alpha,\\beta,\\gamma)^{*}\\,\\hat{R}(\\alpha,\\beta,\\gamma).\n$$\n对于一个旋转不变的态 $|\\Phi\\rangle$，投影到 $M=K=0$ 上的振幅 $a_J$ 由下式给出\n$$\na_J \\equiv \\langle \\Phi | \\hat{P}^{J}_{00} | \\Phi\\rangle = \\frac{2J+1}{8\\pi^2}\\int_{0}^{2\\pi}\\!\\!d\\alpha\\int_{0}^{\\pi}\\!\\!d\\beta\\,\\sin\\beta\\int_{0}^{2\\pi}\\!\\!d\\gamma\\; D^{J}_{00}(\\alpha,\\beta,\\gamma)^{*}\\,\\langle \\Phi | \\hat{R}(\\alpha,\\beta,\\gamma) | \\Phi\\rangle.\n$$\n因为 $|\\Phi\\rangle$ 是旋转不变的，所以有 $\\langle \\Phi | \\hat{R}(\\alpha,\\beta,\\gamma) | \\Phi\\rangle = 1$。此外，对于 $M=K=0$ 的特殊情况，Wigner $D$-函数简化为Legendre多项式 $P_J(\\cos\\beta)$，即 $D^{J}_{00}(\\alpha,\\beta,\\gamma) = P_J(\\cos\\beta)$。\n\n你的任务是编写一个完整的程序，通过对欧拉角进行求积来数值计算旋转不变HF态的 $a_J$。该计算必须通过将三重积分分解为以下部分来完成：\n- 对 $\\alpha \\in [0,2\\pi)$（以弧度为单位）的均匀求积，使用 $N_{\\alpha}$ 个等距点和相应的权重 $w_{\\alpha} = 2\\pi/N_{\\alpha}$。\n- 对 $\\beta \\in [0,\\pi]$（以弧度为单位）的Gaussian-Legendre求积。使用变量代换 $x=\\cos\\beta$，从而 $\\sin\\beta\\,d\\beta = -dx$，并使用 $N_{\\beta}$ 个Gaussian-Legendre节点和权重在 $x\\in[-1,1]$ 上对 $P_J(x)$ 进行积分。\n- 对 $\\gamma \\in [0,2\\pi)$（以弧度为单位）的均匀求积，使用 $N_{\\gamma}$ 个等距点和相应的权重 $w_{\\gamma} = 2\\pi/N_{\\gamma}$。\n\n鉴于 $\\langle \\Phi | \\hat{R}(\\alpha,\\beta,\\gamma) | \\Phi\\rangle = 1$，程序必须计算\n$$\na_J = \\frac{2J+1}{8\\pi^2}\\left(\\sum_{i=1}^{N_{\\alpha}} w_{\\alpha}\\right)\\left(\\sum_{k=1}^{N_{\\gamma}} w_{\\gamma}\\right)\\left(\\sum_{j=1}^{N_{\\beta}} w_j\\,P_J(x_j)\\right),\n$$\n其中 $x_j$ 和 $w_j$ 是变量代换后 $\\beta$ 积分在 $[-1,1]$ 上的Gaussian-Legendre节点和权重。此计算的数学基础是 $|\\Phi\\rangle$ 的旋转不变性、投影算符 $\\hat{P}^{J}_{MK}$ 的定义以及恒等式 $D^J_{00}(\\alpha,\\beta,\\gamma) = P_J(\\cos\\beta)$。\n\n你必须接着验证球形HF态仅在 $J=0$ 时具有非零振幅的论断。为了进行数值验证，定义一个容差 $\\epsilon$ 并检查是否对于所有 $J \\ge 1$ 都有 $|a_0 - 1| \\le \\epsilon$ 和 $|a_J| \\le \\epsilon$。程序必须实现以下测试套件，每个测试由参数 $(J_{\\text{max}}, N_{\\beta}, N_{\\alpha}, N_{\\gamma}, \\epsilon)$ 定义：\n- 测试用例 1（一般情况）：$(J_{\\text{max}}=8,\\, N_{\\beta}=5,\\, N_{\\alpha}=8,\\, N_{\\gamma}=8,\\, \\epsilon=10^{-12})$。\n- 测试用例 2（对于J=0，β求积为最小的边界情况）：$(J_{\\text{max}}=0,\\, N_{\\beta}=1,\\, N_{\\alpha}=1,\\, N_{\\gamma}=1,\\, \\epsilon=10^{-14})$。\n- 测试用例 3（网格较小但对于J=2以下精确的边缘情况）：$(J_{\\text{max}}=2,\\, N_{\\beta}=2,\\, N_{\\alpha}=1,\\, N_{\\gamma}=1,\\, \\epsilon=10^{-14})$。\n\n对于每个测试用例，你的程序必须：\n- 计算列表 $\\{a_J\\}_{J=0}^{J_{\\text{max}}}$。\n- 生成一个布尔值，指示验证是否在指定的容差 $\\epsilon$ 下通过。\n\n最终输出格式：你的程序应生成单行输出，其中包含测试套件的通过/失败结果，格式为方括号括起来的逗号分隔列表，例如 $[{\\tt True},{\\tt False},{\\tt True}]$。所有角度都必须以弧度处理。此计算不涉及物理单位，但所有角度都指定为弧度。给定所述测试，你的布尔结果必须是确定性的。", "solution": "该问题要求数值计算通过将一个旋转不变的Hartree-Fock态 $|\\Phi\\rangle$ 投影到一个具有好角动量 $J$（投影为 $M=K=0$）的态上所获得的振幅 $a_J$。然后我们必须验证这样一个球形态完全由角动量 $J=0$ 分量构成的基本性质。\n\n振幅 $a_J$ 定义为投影算符 $\\hat{P}^J_{00}$ 在态 $|\\Phi\\rangle$ 中的期望值：\n$$\na_J \\equiv \\langle \\Phi | \\hat{P}^{J}_{00} | \\Phi\\rangle\n$$\n投影算符 $\\hat{P}^J_{MK}$ 由一个在旋转群 $SO(3)$ 上的积分定义，该旋转群由欧拉角 $\\Omega = (\\alpha, \\beta, \\gamma)$ 参数化：\n$$\n\\hat{P}^{J}_{MK} \\equiv \\frac{2J+1}{8\\pi^2} \\int d\\Omega\\; D^{J}_{MK}(\\Omega)^{*}\\,\\hat{R}(\\Omega)\n$$\n其中 $d\\Omega = d\\alpha \\sin\\beta d\\beta d\\gamma$，积分范围是 $\\alpha \\in [0, 2\\pi]$，$\\beta \\in [0, \\pi]$ 和 $\\gamma \\in [0, 2\\pi]$。$\\hat{R}(\\Omega)$ 是旋转算符，$D^{J}_{MK}(\\Omega)$ 是Wigner D-函数。\n\n将投影算符代入振幅表达式可得：\n$$\na_J = \\frac{2J+1}{8\\pi^2} \\int d\\Omega\\; D^{J}_{00}(\\Omega)^{*}\\,\\langle \\Phi | \\hat{R}(\\Omega) | \\Phi\\rangle\n$$\n对于此特定情况，问题陈述了两个关键的简化：\n$1$. 态 $|\\Phi\\rangle$ 是旋转不变的，意味着 $\\hat{R}(\\Omega)|\\Phi\\rangle = |\\Phi\\rangle$。假设 $|\\Phi\\rangle$ 是归一化的，$\\langle \\Phi | \\Phi \\rangle = 1$，则矩阵元变为 $\\langle \\Phi | \\hat{R}(\\Omega) | \\Phi\\rangle = \\langle \\Phi | \\Phi \\rangle = 1$。\n$2$. 对于 $M=K=0$ 的情况，Wigner D-函数简化为Legendre多项式，$D^{J}_{00}(\\alpha, \\beta, \\gamma) = P_J(\\cos\\beta)$。由于Legendre多项式是实数，复共轭是多余的。\n\n经过这些简化，$a_J$ 的表达式变为：\n$$\na_J = \\frac{2J+1}{8\\pi^2} \\int_{0}^{2\\pi} d\\alpha \\int_{0}^{2\\pi} d\\gamma \\int_{0}^{\\pi} d\\beta \\sin\\beta\\; P_J(\\cos\\beta)\n$$\n被积函数与 $\\alpha$ 和 $\\gamma$ 无关，因此这些积分可以直接求值：$\\int_{0}^{2\\pi}d\\alpha = 2\\pi$ 和 $\\int_{0}^{2\\pi}d\\gamma = 2\\pi$。这导致：\n$$\na_J = \\frac{2J+1}{8\\pi^2} (2\\pi)(2\\pi) \\int_{0}^{\\pi} P_J(\\cos\\beta) \\sin\\beta \\, d\\beta = \\frac{2J+1}{2} \\int_{0}^{\\pi} P_J(\\cos\\beta) \\sin\\beta \\, d\\beta\n$$\n使用变量代换 $x = \\cos\\beta$，此时 $dx = -\\sin\\beta \\, d\\beta$，在 $\\beta \\in [0, \\pi]$ 上的积分变换为在 $x \\in [1, -1]$ 上的积分：\n$$\na_J = \\frac{2J+1}{2} \\int_{1}^{-1} P_J(x) (-dx) = \\frac{2J+1}{2} \\int_{-1}^{1} P_J(x) \\, dx\n$$\n这个积分可以使用Legendre多项式的正交关系 $\\int_{-1}^{1} P_J(x) P_L(x) dx = \\frac{2}{2L+1}\\delta_{JL}$ 进行解析求解。通过设置 $L=0$，由于 $P_0(x) = 1$，我们得到：\n$$\n\\int_{-1}^{1} P_J(x) P_0(x) \\, dx = \\frac{2}{2(0)+1}\\delta_{J0} = 2\\delta_{J0}\n$$\n其中 $\\delta_{J0}$ 是Kronecker delta。因此，精确的解析结果是：\n$$\na_J = \\frac{2J+1}{2} (2\\delta_{J0}) = (2J+1)\\delta_{J0}\n$$\n这证实了对于所有 $J \\ge 1$，$a_0 = 1$ 且 $a_J = 0$，这是球形态预期的物理结果。\n\n任务是使用指定的求积方案来数值验证此结果。问题提供了数值公式：\n$$\na_J = \\frac{2J+1}{8\\pi^2}\\left(\\sum_{i=1}^{N_{\\alpha}} w_{\\alpha}\\right)\\left(\\sum_{k=1}^{N_{\\gamma}} w_{\\gamma}\\right)\\left(\\sum_{j=1}^{N_{\\beta}} w_j\\,P_J(x_j)\\right)\n$$\n对于 $\\alpha$ 和 $\\gamma$ 的均匀求积，其权重为 $w_{\\alpha} = 2\\pi/N_{\\alpha}$ 和 $w_{\\gamma} = 2\\pi/N_{\\gamma}$，产生的求和结果与点数无关：\n$$\n\\sum_{i=1}^{N_{\\alpha}} w_{\\alpha} = N_{\\alpha} \\left(\\frac{2\\pi}{N_{\\alpha}}\\right) = 2\\pi \\quad \\text{和} \\quad \\sum_{k=1}^{N_{\\gamma}} w_{\\gamma} = N_{\\gamma} \\left(\\frac{2\\pi}{N_{\\gamma}}\\right) = 2\\pi\n$$\n因此，测试用例中的数值 $N_\\alpha$ 和 $N_\\gamma$ 对于计算不是必需的，因为这些和总是等于 $2\\pi$。数值公式简化为：\n$$\na_J \\approx \\frac{2J+1}{2} \\sum_{j=1}^{N_{\\beta}} w_j\\,P_J(x_j)\n$$\n这是积分 $\\frac{2J+1}{2} \\int_{-1}^{1} P_J(x) \\, dx$ 的数值近似。为了进行数值计算，我们需要区间 $[-1, 1]$ 上的Gaussian-Legendre求积节点 $x_j$ 和权重 $w_j$，这些可以通过标准数值库获得。一个 $N_{\\beta}$ 点的Gaussian-Legendre求积可以精确地积分最高 $2N_{\\beta}-1$ 次的多项式。被积函数是 $J$ 次多项式 $P_J(x)$。因此，如果 $J \\le 2N_{\\beta}-1$，$a_J$ 的数值结果将是精确的。\n\n对于每个测试用例 $(J_{\\text{max}}, N_{\\beta}, N_{\\alpha}, N_{\\gamma}, \\epsilon)$ 的算法如下：\n$1$. 对于给定的点数 $N_{\\beta}$，获取 $[-1, 1]$ 上的Gaussian-Legendre节点 $x_j$ 和权重 $w_j$。\n$2$. 对于从 $0$ 到 $J_{\\text{max}}$ 的每个角动量 $J$：\n    a. 构造Legendre多项式 $P_J(x)$。\n    b. 在每个节点上计算 $P_J(x_j)$。\n    c. 计算求积和 $S_J = \\sum_{j=1}^{N_{\\beta}} w_j P_J(x_j)$。\n    d. 计算振幅 $a_J = \\frac{2J+1}{2} S_J$。\n$3$. 收集计算出的振幅 $\\{a_J\\}_{J=0}^{J_{\\text{max}}}$。\n$4$. 根据容差 $\\epsilon$ 验证结果：检查是否对于所有 $J \\in [1, J_{\\text{max}}]$ 都有 $|a_0 - 1| \\le \\epsilon$ 和 $|a_J| \\le \\epsilon$。如果所有条件都满足，则测试通过。\n\n对于所提供的测试用例，条件 $J_{\\text{max}} \\le 2N_{\\beta}-1$ 总是满足的，这确保了数值积分在机器精度内是精确的。因此，预计所有测试用例都将通过。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre, roots_legendre\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for angular momentum projection.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (J_max, N_beta, N_alpha, N_gamma, epsilon)\n    test_cases = [\n        (8, 5, 8, 8, 1e-12),\n        (0, 1, 1, 1, 1e-14),\n        (2, 2, 1, 1, 1e-14),\n    ]\n\n    results = []\n    for case in test_cases:\n        J_max, N_beta, N_alpha, N_gamma, epsilon = case\n        \n        # As shown in the solution, the sums over alpha and gamma quadrature points\n        # always evaluate to 2*pi, regardless of N_alpha and N_gamma.\n        # Thus, these parameters are not needed for the numerical calculation.\n        \n        # Get Gaussian-Legendre nodes (x_j) and weights (w_j) for the beta integral\n        # The integral is over x = cos(beta) from -1 to 1.\n        # scipy.special.roots_legendre provides these for the interval [-1, 1].\n        nodes, weights = roots_legendre(N_beta)\n\n        # Compute amplitudes a_J for J from 0 to J_max\n        amplitudes = []\n        for J in range(J_max + 1):\n            # Get the Legendre polynomial of degree J\n            P_J = legendre(J)\n            \n            # Evaluate P_J at each quadrature node\n            P_J_at_nodes = P_J(nodes)\n            \n            # Compute the integral over beta using Gaussian quadrature\n            # integral(P_J(x) dx) from -1 to 1 is approx. sum(w_j * P_J(x_j))\n            beta_integral_sum = np.sum(weights * P_J_at_nodes)\n            \n            # Calculate the amplitude a_J\n            # a_J = (2J+1)/2 * integral(P_J(x) dx)\n            a_J = (2 * J + 1) / 2.0 * beta_integral_sum\n            amplitudes.append(a_J)\n\n        # Verify the results against the theoretical expectation\n        # a_0 should be 1, and a_J for J>0 should be 0.\n        \n        # Check a_0\n        pass_a0 = abs(amplitudes[0] - 1.0) = epsilon\n        \n        # Check a_J for J > 0\n        pass_aJ_gt_0 = True\n        if J_max > 0:\n            # np.all checks if all elements in the slice are True\n            pass_aJ_gt_0 = np.all(np.abs(amplitudes[1:]) = epsilon)\n            \n        test_passes = pass_a0 and pass_aJ_gt_0\n        results.append(test_passes)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3542237"}, {"introduction": "角动量投影的实际应用通常涉及形变的平均场态，这会导致其交叠核函数随转动角发生非平凡的变化。与简单的测试案例不同，投影后范数的精确值是未知的，这使得数值收敛成为一个至关重要的问题。这项练习通过一个能够捕捉形变核特征的模型交叠核函数来模拟一个真实的研究场景[@problem_id:3542290]。您将设计并实现一个自适应积分方案，以确保计算出的可观测量收敛到指定的精度，这是获得可靠科学结果的一项关键技能。", "problem": "您的任务是设计、实现并验证一个收敛性测试策略，用于通过对三个欧拉角进行数值积分来计算角动量投影可观测量。考虑将平均场态投影到具有确定总角动量的态上。从投影算符的算符级定义开始\n$$\n\\hat{P}^{J}_{MK} = \\frac{2J+1}{8\\pi^2} \\int d\\Omega \\, \\mathcal{D}^{J}_{MK}(\\Omega)^{\\ast} \\, \\hat{R}(\\Omega),\n$$\n其中 $J$ 是总角动量，$M$ 和 $K$ 是其投影，$\\hat{R}(\\Omega)$ 是由欧拉角 $\\Omega \\equiv (\\alpha,\\beta,\\gamma)$ 定义的旋转算符，其不变测度为\n$$\nd\\Omega = d\\alpha \\; \\sin\\beta \\; d\\beta \\; d\\gamma,\n$$\n$\\mathcal{D}^{J}_{MK}(\\Omega)$ 是维格纳 (Wigner) 旋转矩阵。对于一个普通的平均场态 $\\lvert \\Phi \\rangle$，其投影范数核为\n$$\n\\mathcal{N}^{J}_{MK} = \\langle \\Phi \\lvert \\hat{P}^{J}_{MK} \\rvert \\Phi \\rangle = \\frac{2J+1}{8\\pi^2} \\int d\\Omega \\, \\mathcal{D}^{J}_{MK}(\\Omega)^{\\ast} \\, \\langle \\Phi \\lvert \\hat{R}(\\Omega) \\rvert \\Phi \\rangle.\n$$\n在本任务中，特化为 $M=K=0$ 的情况，并将重叠核建模为一个平滑的可分解函数\n$$\nn(\\Omega) \\equiv \\langle \\Phi \\lvert \\hat{R}(\\Omega) \\rvert \\Phi \\rangle = \\exp\\big(\\kappa \\cos\\beta\\big)\\, \\exp\\big(\\rho \\cos\\alpha\\big)\\, \\exp\\big(\\sigma \\cos\\gamma\\big),\n$$\n其中 $\\kappa \\ge 0$、$\\rho \\ge 0$ 和 $\\sigma \\ge 0$ 是实数参数。利用当 $M=K=0$ 时有 $\\mathcal{D}^{J}_{00}(\\alpha,\\beta,\\gamma) = P_{J}(\\cos\\beta)$ 这一事实，其中 $P_J$ 是 $J$ 阶勒让德 (Legendre) 多项式。\n\n您的目标是：\n- 推导投影范数的精确闭式表达式（用众所周知的特殊函数表示）\n$$\n\\mathcal{N}^{J} \\equiv \\mathcal{N}^{J}_{00} = \\frac{2J+1}{8\\pi^2} \\int_{0}^{2\\pi} d\\alpha \\int_{0}^{\\pi} \\sin\\beta \\, d\\beta \\int_{0}^{2\\pi} d\\gamma \\; P_{J}(\\cos\\beta)\\, \\exp(\\kappa \\cos\\beta)\\, \\exp(\\rho \\cos\\alpha)\\, \\exp(\\sigma \\cos\\gamma).\n$$\n- 使用欧拉角上的离散网格和以下求积法则，为 $\\mathcal{N}^{J}$ 构建一个数值积分器：\n  1. 对于 $\\alpha \\in [0,2\\pi)$ 和 $\\gamma \\in [0,2\\pi)$，分别使用具有 $N_{\\alpha}$ 和 $N_{\\gamma}$ 个等距节点和恒定权重的均匀梯形法则。角度单位必须是弧度。\n  2. 对于 $\\beta \\in [0,\\pi]$，在变换后的变量 $x = \\cos\\beta \\in [-1,1]$ 上使用高斯-勒让德 (Gauss–Legendre) 求积，使得\n     $$\n     \\int_{0}^{\\pi} \\sin\\beta \\, g(\\cos\\beta) \\, d\\beta = \\int_{-1}^{1} g(x) \\, dx,\n     $$\n     其中，使用高斯-勒让德节点和权重以及 $N_{\\beta}$ 个节点来近似 $x$ 上的积分。\n- 设计一个收敛性测试程序，通过将当前对投影可观测量产生最大变化的维度中的 $N_{\\alpha}$、$N_{\\beta}$ 或 $N_{\\gamma}$ 加倍来自适应地细化欧拉角网格。使用一个基于当前估计值与在每个维度上单独加倍所获得的估计值之间的最大相对变化的实用停止准则。具体来说，当这三个单步相对变化中的最大值严格小于用户指定的容差 $\\varepsilon$ 时，终止细化。\n- 为了验证，将最终的数值估计值与精确表达式进行比较，以计算后验误差。当精确值的量级大于 $10^{-14}$ 时，报告相对误差；否则，报告绝对误差。\n\n实现细节和约束：\n- 数值积分必须以弧度为单位进行。\n- 程序必须是自包含的，并且不得要求用户输入。\n- 您必须实现上述自适应细化。从 $N_{\\alpha}=N_{\\beta}=N_{\\gamma}=4$ 开始细化，并在每一步中仅将对应于最大单步相对变化的那个维度的点数加倍。当满足停止准则或任何维度达到指定的最大值 $N$ 时停止。\n- 仅使用上述详述的标准科学函数和求积法则；不要使用任何预打包的角动量投影例程。\n\n根据需要使用众所周知的特殊函数提供精确表达式。您的推导应基于给定的基本定义以及经过充分检验的正交多项式和特殊函数的恒等式，但不要在没有论证的情况下直接跳到最终表达式。\n\n测试套件：\n实现您的程序以运行以下五个测试用例。对于每个用例，使用给定的参数 $(J,\\kappa,\\rho,\\sigma)$、停止容差 $\\varepsilon$ 和最大网格尺寸 $(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max})$。在所有情况下，角度均以弧度为单位。\n\n- 用例 1 (基准平滑): $(J,\\kappa,\\rho,\\sigma) = (0, 0.5, 0.5, 0.5)$, $\\varepsilon = 10^{-9}$, $(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max}) = (256,256,256)$。\n- 用例 2 (在 $\\beta$ 中有大的 $J$ 振荡): $(J,\\kappa,\\rho,\\sigma) = (6, 8.0, 1.0, 1.5)$, $\\varepsilon = 10^{-8}$, $(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max}) = (256,512,256)$。\n- 用例 3 (在 $\\alpha$ 中有尖锐结构): $(J,\\kappa,\\rho,\\sigma) = (4, 1.0, 6.0, 0.0)$, $\\varepsilon = 10^{-8}$, $(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max}) = (512,256,256)$。\n- 用例 4 (在所有角度上同时尖锐): $(J,\\kappa,\\rho,\\sigma) = (10, 12.0, 3.0, 3.0)$, $\\varepsilon = 10^{-7}$, $(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max}) = (512,512,512)$。\n- 用例 5 (在 $\\beta$ 中近乎平坦，在 $\\alpha$ 和 $\\gamma$ 中非常尖锐): $(J,\\kappa,\\rho,\\sigma) = (2, 0.01, 10.0, 10.0)$, $\\varepsilon = 10^{-9}$, $(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max}) = (1024,512,1024)$。\n\n最终输出规范：\n- 对于每个测试用例，使用自适应程序计算最终的数值估计值，然后根据上述规定计算与精确表达式的误差。\n- 您的程序应产生单行输出，其中包含一个 Python 风格的列表，内有五个浮点数，每个数分别对应于按上述顺序列出的测试用例的误差。该行必须精确格式化为用方括号括起来的逗号分隔列表，例如：“[e1,e2,e3,e4,e5]”。", "solution": "所提出的问题是为一个特定的角动量投影范数推导精确表达式，为其构建一个自适应数值积分器，并针对一系列测试用例将数值结果与精确结果进行验证。该问题定义明确、科学上合理且计算上可行。我们按要求进行推导和实现。\n\n### 1. 投影范数的解析推导\n\n待计算的投影范数由以下积分给出：\n$$\n\\mathcal{N}^{J} = \\frac{2J+1}{8\\pi^2} \\int_{0}^{2\\pi} d\\alpha \\int_{0}^{\\pi} \\sin\\beta \\, d\\beta \\int_{0}^{2\\pi} d\\gamma \\; P_{J}(\\cos\\beta)\\, \\exp(\\kappa \\cos\\beta)\\, \\exp(\\rho \\cos\\alpha)\\, \\exp(\\sigma \\cos\\gamma)\n$$\n其中 $J$、$\\kappa$、$\\rho$ 和 $\\sigma$ 是非负实参数，$P_J(x)$ 是 $J$ 阶勒让德多项式。被积函数对于三个欧拉角 $\\alpha$、$\\beta$ 和 $\\gamma$ 是可分离的。因此，三重积分可以分解为三个一维积分的乘积：\n$$\n\\mathcal{N}^{J} = \\frac{2J+1}{8\\pi^2} \\left[ \\int_{0}^{2\\pi} \\exp(\\rho \\cos\\alpha) \\, d\\alpha \\right] \\left[ \\int_{0}^{\\pi} P_{J}(\\cos\\beta) \\exp(\\kappa \\cos\\beta) \\sin\\beta \\, d\\beta \\right] \\left[ \\int_{0}^{2\\pi} \\exp(\\sigma \\cos\\gamma) \\, d\\gamma \\right]\n$$\n我们分别计算这些积分。\n\n**关于 $\\alpha$ 和 $\\gamma$ 的积分**\n\n关于 $\\alpha$ 和 $\\gamma$ 的积分形式相同。考虑关于 $\\alpha$ 的积分：\n$$\nI_\\alpha = \\int_{0}^{2\\pi} \\exp(\\rho \\cos\\alpha) \\, d\\alpha\n$$\n该积分是零阶第一类修正贝塞尔函数 $I_0(z)$ 的标准表示，由以下恒等式给出：\n$$\nI_0(z) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp(z \\cos\\theta) \\, d\\theta\n$$\n因此，我们有：\n$$\nI_\\alpha = 2\\pi I_0(\\rho)\n$$\n通过相同的推理，关于 $\\gamma$ 的积分为：\n$$\nI_\\gamma = \\int_{0}^{2\\pi} \\exp(\\sigma \\cos\\gamma) \\, d\\gamma = 2\\pi I_0(\\sigma)\n$$\n\n**关于 $\\beta$ 的积分**\n\n关于 $\\beta$ 的积分为：\n$$\nI_\\beta = \\int_{0}^{\\pi} P_{J}(\\cos\\beta) \\exp(\\kappa \\cos\\beta) \\sin\\beta \\, d\\beta\n$$\n我们进行变量替换 $x = \\cos\\beta$，这意味着 $dx = -\\sin\\beta \\, d\\beta$。积分限 $\\beta \\in [0, \\pi]$ 变为 $x \\in [1, -1]$。\n$$\nI_\\beta = \\int_{1}^{-1} P_{J}(x) \\exp(\\kappa x) (-dx) = \\int_{-1}^{1} P_{J}(x) \\exp(\\kappa x) \\, dx\n$$\n可以利用指数函数在勒让德多项式基底下的展开来计算该积分：\n$$\ne^{zx} = \\sum_{l=0}^{\\infty} (2l+1) i_l(z) P_l(x)\n$$\n其中 $i_l(z)$ 是 $l$ 阶第一类修正球贝塞尔函数。利用勒让德多项式的正交性，\n$$\n\\int_{-1}^{1} P_J(x) P_l(x) dx = \\frac{2}{2l+1} \\delta_{Jl}\n$$\n我们将该展开式乘以 $P_J(x)$ 并在 $x \\in [-1, 1]$ 上积分：\n$$\n\\int_{-1}^{1} P_J(x) e^{\\kappa x} dx = \\sum_{l=0}^{\\infty} (2l+1) i_l(\\kappa) \\int_{-1}^{1} P_J(x) P_l(x) dx = \\sum_{l=0}^{\\infty} (2l+1) i_l(\\kappa) \\left( \\frac{2}{2l+1} \\delta_{Jl} \\right)\n$$\n当 $l=J$ 时，该和式收缩为单项：\n$$\nI_\\beta = 2 i_J(\\kappa)\n$$\n\n**最终表达式**\n\n将 $I_\\alpha$、$I_\\beta$ 和 $I_\\gamma$ 的结果代回 $\\mathcal{N}^{J}$ 的表达式中：\n$$\n\\mathcal{N}^{J} = \\frac{2J+1}{8\\pi^2} (2\\pi I_0(\\rho)) (2 i_J(\\kappa)) (2\\pi I_0(\\sigma))\n$$\n$$\n\\mathcal{N}^{J} = \\frac{2J+1}{8\\pi^2} (8\\pi^2) I_0(\\rho) I_0(\\sigma) i_J(\\kappa)\n$$\n因此，投影范数的精确闭式表达式为：\n$$\n\\mathcal{N}^{J} = (2J+1) \\, I_0(\\rho) \\, I_0(\\sigma) \\, i_J(\\kappa)\n$$\n该表达式依赖于标准科学库中众所周知的特殊函数。\n\n### 2. 数值积分方案\n\n$\\mathcal{N}^{J}$ 的数值积分是通过对欧拉角上的三维积分进行离散化来执行的。由于被积函数是可分离的，我们可以分别对每个一维积分进行数值计算，然后将结果相乘。\n\n- **对于 $\\alpha$ 和 $\\gamma$**：积分区间为 $[0, 2\\pi)$。我们使用周期函数的梯形法则，即在 $N$ 个等距点上对函数值求和，然后乘以步长 $h=2\\pi/N$。对于一组节点 $\\{\\theta_i = i \\frac{2\\pi}{N}\\}_{i=0}^{N-1}$，积分近似为：\n$$\n\\int_0^{2\\pi} f(\\theta) d\\theta \\approx \\frac{2\\pi}{N} \\sum_{i=0}^{N-1} f(\\theta_i)\n$$\n对于平滑的周期函数，该法则具有谱精度。\n\n- **对于 $\\beta$**：关于 $\\beta$ 的积分被转换为在 $[-1, 1]$ 上关于 $x = \\cos\\beta$ 的积分。这种形式非常适合高斯-勒让德求积。使用 $N_\\beta$ 个节点 $x_j$ 和权重 $w_j$，积分近似为：\n$$\n\\int_{-1}^{1} g(x) dx \\approx \\sum_{j=0}^{N_\\beta-1} w_j g(x_j)\n$$\n对于平滑的被积函数，此方法效率很高，用相对较少的节点就能达到高精度。\n\n完整的数值估计是这三个数值积分的乘积，并乘以原始定义中的相应前置因子：\n$$\n\\mathcal{N}^{J}_{\\text{num}} = \\frac{2J+1}{8\\pi^2} \\left[ \\frac{2\\pi}{N_\\alpha} \\sum_{i=0}^{N_\\alpha-1} e^{\\rho\\cos\\alpha_i} \\right] \\left[ \\sum_{j=0}^{N_\\beta-1} w_j P_J(x_j) e^{\\kappa x_j} \\right] \\left[ \\frac{2\\pi}{N_\\gamma} \\sum_{k=0}^{N_\\gamma-1} e^{\\sigma\\cos\\gamma_k} \\right]\n$$\n这可以简化为：\n$$\n\\mathcal{N}^{J}_{\\text{num}} = \\frac{2J+1}{2} \\left[ \\frac{1}{N_\\alpha} \\sum_{i=0}^{N_\\alpha-1} e^{\\rho\\cos\\alpha_i} \\right] \\left[ \\sum_{j=0}^{N_\\beta-1} w_j P_J(x_j) e^{\\kappa x_j} \\right] \\left[ \\frac{1}{N_\\gamma} \\sum_{k=0}^{N_\\gamma-1} e^{\\sigma\\cos\\gamma_k} \\right]\n$$\n\n### 3. 自适应细化策略\n\n稳健的数值计算需要进行收敛性测试。我们实现一个自适应网格细化程序，以自动确定达到所需容差 $\\varepsilon$ 所需的求积点数 ($N_\\alpha, N_\\beta, N_\\gamma$) 。\n\n该程序从一个粗糙网格开始，例如 $N_\\alpha=N_\\beta=N_\\gamma=4$。然后，它在对结果影响最显著的单个维度上迭代地细化网格。\n在使用网格 $(N_\\alpha, N_\\beta, N_\\gamma)_k$ 的第 $k$ 步：\n1.  计算范数的当前值，$V_k = \\mathcal{N}^{J}_{\\text{num}}((N_\\alpha, N_\\beta, N_gamma)_k)$。\n2.  通过将点数加倍来单独细化每个维度，并计算三个测试值：\n    - $V_{\\alpha} = \\mathcal{N}^{J}_{\\text{num}}((2N_\\alpha, N_\\beta, N_\\gamma)_k)$\n    - $V_{\\beta} = \\mathcal{N}^{J}_{\\text{num}}((N_\\alpha, 2N_\\beta, N_\\gamma)_k)$\n    - $V_{\\gamma} = \\mathcal{N}^{J}_{\\text{num}}((N_\\alpha, N_\\beta, 2N_\\gamma)_k)$\n3.  计算每个维度的单步相对变化：\n    - $\\delta_\\alpha = |V_\\alpha - V_k| / |V_k|$\n    - $\\delta_\\beta = |V_\\beta - V_k| / |V_k|$\n    - $\\delta_\\gamma = |V_\\gamma - V_k| / |V_k|$\n    （分母 $|V_k|$ 使用一个小的阈值以防止除以零，必要时回退到绝对变化）。\n4.  找到最大变化，$\\delta_{\\max} = \\max(\\delta_\\alpha, \\delta_\\beta, \\delta_\\gamma)$。\n5.  如果 $\\delta_{\\max}  \\varepsilon$，则程序已收敛，$V_k$ 被作为最终的数值估计值。\n6.  否则，通过将产生 $\\delta_{\\max}$ 的维度中的点数加倍来创建下一次迭代的网格 $(N_\\alpha, N_\\beta, N_\\gamma)_{k+1}$。例如，如果 $\\delta_\\alpha = \\delta_{\\max}$，则 $(N_\\alpha, N_\\beta, N_\\gamma)_{k+1} = (2N_\\alpha, N_\\beta, N_\\gamma)_k$。这将计算工作优先分配给被积函数变化最剧烈的区域，从而实现资源的有效分配。\n7.  如果任何网格尺寸超过其指定的最大值，循环也会终止。\n\n这种自适应方法确保了数值积分的准确性和效率，它会根据每个测试用例中被积函数的特性自动调整网格密度。然后将最终收敛的数值与精确的解析表达式进行比较，以计算后验误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0, spherical_in, legendre\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for adaptive angular momentum projection.\n    \"\"\"\n    \n    # (Parameter set), tolerance, max_mesh_sizes\n    test_cases = [\n        # Case 1 (baseline smooth)\n        ((0, 0.5, 0.5, 0.5), 1e-9, (256, 256, 256)),\n        # Case 2 (large J-oscillations in beta)\n        ((6, 8.0, 1.0, 1.5), 1e-8, (256, 512, 256)),\n        # Case 3 (sharp structure in alpha)\n        ((4, 1.0, 6.0, 0.0), 1e-8, (512, 256, 256)),\n        # Case 4 (simultaneously sharp in all angles)\n        ((10, 12.0, 3.0, 3.0), 1e-7, (512, 512, 512)),\n        # Case 5 (nearly flat in beta, very sharp in alpha and gamma)\n        ((2, 0.01, 10.0, 10.0), 1e-9, (1024, 512, 1024)),\n    ]\n\n    # Caches for memoizing quadrature results to improve performance\n    alpha_integral_cache = {}\n    beta_integral_cache = {}\n    gamma_integral_cache = {}\n\n    def integrate_alpha(rho, n_alpha):\n        \"\"\"Computes the integral over the Euler angle alpha.\"\"\"\n        if (rho, n_alpha) in alpha_integral_cache:\n            return alpha_integral_cache[(rho, n_alpha)]\n        \n        alpha_nodes = np.linspace(0, 2 * np.pi, n_alpha, endpoint=False)\n        integrand_values = np.exp(rho * np.cos(alpha_nodes))\n        integral = (2 * np.pi / n_alpha) * np.sum(integrand_values)\n        \n        alpha_integral_cache[(rho, n_alpha)] = integral\n        return integral\n\n    def integrate_gamma(sigma, n_gamma):\n        \"\"\"Computes the integral over the Euler angle gamma.\"\"\"\n        if (sigma, n_gamma) in gamma_integral_cache:\n            return gamma_integral_cache[(sigma, n_gamma)]\n\n        gamma_nodes = np.linspace(0, 2 * np.pi, n_gamma, endpoint=False)\n        integrand_values = np.exp(sigma * np.cos(gamma_nodes))\n        integral = (2 * np.pi / n_gamma) * np.sum(integrand_values)\n        \n        gamma_integral_cache[(sigma, n_gamma)] = integral\n        return integral\n\n    gauss_legendre_cache = {}\n    def get_gauss_legendre_points(n_beta):\n        if n_beta in gauss_legendre_cache:\n            return gauss_legendre_cache[n_beta]\n        nodes, weights = np.polynomial.legendre.leggauss(n_beta)\n        gauss_legendre_cache[n_beta] = (nodes, weights)\n        return nodes, weights\n\n    def integrate_beta(J, kappa, n_beta):\n        \"\"\"Computes the integral over the Euler angle beta.\"\"\"\n        if (J, kappa, n_beta) in beta_integral_cache:\n            return beta_integral_cache[(J, kappa, n_beta)]\n\n        x_nodes, weights = get_gauss_legendre_points(n_beta)\n        P_J = legendre(J)\n        integrand_values = P_J(x_nodes) * np.exp(kappa * x_nodes)\n        integral = np.sum(weights * integrand_values)\n        \n        beta_integral_cache[(J, kappa, n_beta)] = integral\n        return integral\n\n    def calculate_norm(params, n_alpha, n_beta, n_gamma):\n        \"\"\"Calculates the projected norm for a given mesh.\"\"\"\n        J, kappa, rho, sigma = params\n        \n        integral_alpha = integrate_alpha(rho, n_alpha)\n        integral_beta = integrate_beta(J, kappa, n_beta)\n        integral_gamma = integrate_gamma(sigma, n_gamma)\n        \n        prefactor = (2 * J + 1) / (8 * np.pi**2)\n        \n        return prefactor * integral_alpha * integral_beta * integral_gamma\n\n    def calculate_exact_norm(params):\n        \"\"\"Calculates the exact projected norm using special functions.\"\"\"\n        J, kappa, rho, sigma = params\n        \n        if kappa == 0:\n            i_j_kappa = 1.0 if J == 0 else 0.0\n        else:\n            i_j_kappa = spherical_in(J, kappa)\n\n        return (2 * J + 1) * i0(rho) * i0(sigma) * i_j_kappa\n\n    results = []\n    for params, epsilon, max_Ns in test_cases:\n        alpha_integral_cache.clear()\n        beta_integral_cache.clear()\n        gamma_integral_cache.clear()\n        gauss_legendre_cache.clear()\n\n        J, kappa, rho, sigma = params\n        n_alpha_max, n_beta_max, n_gamma_max = max_Ns\n\n        n_alpha, n_beta, n_gamma = 4, 4, 4\n        \n        while True:\n            current_norm = calculate_norm(params, n_alpha, n_beta, n_gamma)\n\n            # Test refinement in alpha\n            if 2 * n_alpha = n_alpha_max:\n                norm_alpha = calculate_norm(params, 2 * n_alpha, n_beta, n_gamma)\n                if abs(current_norm) > 1e-20:\n                    change_alpha = abs(norm_alpha - current_norm) / abs(current_norm)\n                else:\n                    change_alpha = abs(norm_alpha - current_norm)\n            else:\n                change_alpha = 0.0\n\n            # Test refinement in beta\n            if 2 * n_beta = n_beta_max:\n                norm_beta = calculate_norm(params, n_alpha, 2 * n_beta, n_gamma)\n                if abs(current_norm) > 1e-20:\n                    change_beta = abs(norm_beta - current_norm) / abs(current_norm)\n                else:\n                    change_beta = abs(norm_beta - current_norm)\n            else:\n                change_beta = 0.0\n            \n            # Test refinement in gamma\n            if 2 * n_gamma = n_gamma_max:\n                norm_gamma = calculate_norm(params, n_alpha, n_beta, 2 * n_gamma)\n                if abs(current_norm) > 1e-20:\n                    change_gamma = abs(norm_gamma - current_norm) / abs(current_norm)\n                else:\n                    change_gamma = abs(norm_gamma - current_norm)\n            else:\n                change_gamma = 0.0\n\n            max_change = max(change_alpha, change_beta, change_gamma)\n\n            if max_change  epsilon or max_change == 0.0:\n                final_numerical_norm = current_norm\n                break\n            \n            # Refine the dimension with the largest change\n            changes = [change_alpha, change_beta, change_gamma]\n            if np.argmax(changes) == 0:\n                n_alpha *= 2\n            elif np.argmax(changes) == 1:\n                n_beta *= 2\n            else:\n                n_gamma *= 2\n\n        exact_norm = calculate_exact_norm(params)\n        \n        if abs(exact_norm) > 1e-14:\n            error = abs(final_numerical_norm - exact_norm) / abs(exact_norm)\n        else:\n            error = abs(final_numerical_norm - exact_norm)\n        \n        results.append(error)\n\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3542290"}]}