{"hands_on_practices": [{"introduction": "在任何大规模科学计算中，第一步都是明确内存需求。在耦合簇理论中，这意味着需要精确知道要存储多少个双激发振幅 $t_{ij}^{ab}$。这个练习 [@problem_id:3553374] 让你亲身体验如何利用费米子反对称性这一基本原理来显著减少需要存储的独立振幅数量，这是设计高效、正确的耦合簇代码的关键一步。", "problem": "考虑将耦合簇（CC）方法应用于单粒子基中的闭壳层原子核，其中簇算符仅包含双激发分量。双激发簇算符在二次量子化形式下写为\n$$\nT_{2} = \\frac{1}{4} \\sum_{i j a b} t_{i j}^{a b}\\, a_{a}^{\\dagger} a_{b}^{\\dagger} a_{j} a_{i},\n$$\n其中 $a_{p}^{\\dagger}$ 和 $a_{p}$ 是费米子产生和湮灭算符，遵循正则反对易关系，而 $t_{i j}^{a b}$ 是连接已占据单粒子态 $(i,j)$ 与未占据（虚）单粒子态 $(a,b)$ 的双激发振幅。这些指标同时带有自旋和同位旋量子数，其中 $i,j$ 来自参考斯莱特行列式的已占据轨形，而 $a,b$ 来自虚轨形。原子核的哈密顿量守恒同位旋和宇称，并且粒子种类标签（中子或质子）用于将振幅张量分块为三个不重叠的通道：中子-中子、质子-质子和中子-质子。由于费米子反对称性，同种粒子通道中的振幅在交换已占据指标或虚指标时满足反对称性。相比之下，对于混合种类通道，跨物种交换不会产生冗余，因为被交换的对象属于不同的块。\n\n一种实现通过利用这些反对称性和粒子种类块结构，仅存储独立的双激发振幅。具体来说：\n- 在中子-中子块中，仅存储已占据中子指标的无序对和虚中子指标的无序对。\n- 在质子-质子块中，仅存储已占据质子指标的无序对和虚中子指标的无序对。\n- 在中子-质子块中，存储一个已占据中子与一个已占据质子、一个虚中子与一个虚质子的所有组合，不进行进一步简化。\n\n从费米子反对易关系和 $T_{2}$ 的算符结构出发，推导每个块中存储的独立双激发振幅数量的计数规则。然后，对于一个模型空间，其中有 $n_{o}^{n} = 10$ 个已占据中子，$n_{v}^{n} = 30$ 个虚中子，$n_{o}^{p} = 8$ 个已占据质子，以及 $n_{v}^{p} = 24$ 个虚质子，计算所有三个块中存储的双激发振幅的总确切数量。\n\n将最终计数表示为一个没有单位的精确整数。", "solution": "这个问题是有效的，因为它科学地基于多体量子力学和耦合簇形式主义的原理，问题提出得很好，有明确的目标和足够的数据，并且没有任何科学或逻辑上的矛盾。因此，我们可以进行推导和计算。\n\n问题要求计算在一个原子核的耦合簇计算中存储的独立双激发振幅 $t_{i j}^{a b}$ 的总数。存储方案利用了由费米子反对称性和基于粒子类型（中子或质子）的块结构产生的对称性。振幅总数是三个不同通道中独立振幅数量的总和：中子-中子（$nn$）、质子-质子（$pp$）和中子-质子（$np$）。\n\n双激发的簇算符 $T_2$ 由下式给出\n$$\nT_{2} = \\frac{1}{4} \\sum_{i j a b} t_{i j}^{a b}\\, a_{a}^{\\dagger} a_{b}^{\\dagger} a_{j} a_{i}\n$$\n其中指标 $i, j$ 遍历已占据的单粒子态，而 $a, b$ 遍历虚（未占据）的单粒子态。算符 $a^{\\dagger}$ 和 $a$ 是费米子产生和湮灭算符。由于反对易关系 $\\{a_p, a_q\\} = 0$ 和 $\\{a_p^{\\dagger}, a_q^{\\dagger}\\} = 0$，算符乘积 $a_{a}^{\\dagger} a_{b}^{\\dagger} a_{j} a_{i}$ 在交换 $i \\leftrightarrow j$ 和 $a \\leftrightarrow b$ 时是反对称的。为了确保求和中每个不同的物理激发只被计算一次，振幅必须具有相同的反对称性：\n$$\nt_{ij}^{ab} = -t_{ji}^{ab} \\quad \\text{and} \\quad t_{ij}^{ab} = -t_{ij}^{ba}\n$$\n这意味着 $t_{ij}^{ab} = t_{ji}^{ba}$。这些关系是确定唯一振幅数量的基础。\n\n我们分别分析每个通道。\n\n**1. 中子-中子（$nn$）通道**\n在此通道中，所有四个指标（$i, j, a, b$）都对应于中子态。设已占据中子态的数量为 $n_{o}^{n}$，虚中子态的数量为 $n_{v}^{n}$。振幅的形式为 $t_{i_n j_n}^{a_n b_n}$。\n由于反对称性 $t_{i_n j_n}^{a_n b_n} = -t_{j_n i_n}^{a_n b_n}$，我们必须有 $i_n \\neq j_n$。为了计算独立振幅的数量，我们可以采用一个约定，例如，只存储那些 $i_n  j_n$ 的振幅。选择两个不同已占据中子指标且不考虑顺序的方法数由二项式系数 $\\binom{n_{o}^{n}}{2}$ 给出。\n类似地，由于反对称性 $t_{i_n j_n}^{a_n b_n} = -t_{i_n j_n}^{b_n a_n}$，我们必须有 $a_n \\neq b_n$。我们按照约定，只存储 $a_n  b_n$ 的振幅。选择两个不同虚中子指标且不考虑顺序的方法数是 $\\binom{n_{v}^{n}}{2}$。\n独立的中子-中子振幅总数 $N_{nn}$ 是唯一的空穴对数和唯一的粒子对数的乘积。\n$$\nN_{nn} = \\binom{n_{o}^{n}}{2} \\binom{n_{v}^{n}}{2}\n$$\n\n**2. 质子-质子（$pp$）通道**\n此通道的逻辑与中子-中子通道相同。所有四个指标都对应于质子态。设已占据质子态的数量为 $n_{o}^{p}$，虚质子态的数量为 $n_{v}^{p}$。振幅的形式为 $t_{i_p j_p}^{a_p b_p}$。\n独立的质子-质子振幅数量 $N_{pp}$ 是：\n$$\nN_{pp} = \\binom{n_{o}^{p}}{2} \\binom{n_{v}^{p}}{2}\n$$\n\n**3. 中子-质子（$np$）通道**\n在此通道中，激发涉及一个中子和一个质子。振幅对应于将一个已占据的中子-质子对移动到一个虚的中子-质子对，例如 $t_{i_n j_p}^{a_n b_p}$。指标 $i_n, a_n$ 是中子态，而 $j_p, b_p$ 是质子态。\n因为中子和质子是可区分的粒子，交换一个中子指标和一个质子指标时没有反对称性约束。例如，$t_{i_n j_p}^{a_n b_p}$ 和 $t_{j_p i_n}^{a_n b_p}$ 是完全不同的振幅，因为后者将代表从一个已占据的质子-中子态对的激发。问题陈述正确地指出，“跨物种交换不会产生冗余”。\n因此，要计算独立振幅的数量，我们只需计算来自以下四类中每类一个态的所有可能组合：\n- 已占据中子态 $i_n$ 的选择数：$n_{o}^{n}$\n- 已占据质子态 $j_p$ 的选择数：$n_{o}^{p}$\n- 虚中子态 $a_n$ 的选择数：$n_{v}^{n}$\n- 虚质子态 $b_p$ 的选择数：$n_{v}^{p}$\n独立的中子-质子振幅总数 $N_{np}$ 是这些计数的乘积：\n$$\nN_{np} = n_{o}^{n} \\cdot n_{o}^{p} \\cdot n_{v}^{n} \\cdot n_{v}^{p}\n$$\n\n**振幅总数**\n存储的双激发振幅总数 $N_{\\text{total}}$ 是这三个互斥块的计数之和：\n$$\nN_{\\text{total}} = N_{nn} + N_{pp} + N_{np}\n$$\n\n**计算**\n我们被给予了模型空间的以下参数：\n- $n_{o}^{n} = 10$\n- $n_{v}^{n} = 30$\n- $n_{o}^{p} = 8$\n- $n_{v}^{p} = 24$\n\n现在，我们计算每个块的振幅数量。\n\n对于 $nn$ 块：\n$$\nN_{nn} = \\binom{10}{2} \\binom{30}{2} = \\left(\\frac{10 \\times 9}{2 \\times 1}\\right) \\left(\\frac{30 \\times 29}{2 \\times 1}\\right) = 45 \\times 435 = 19575\n$$\n\n对于 $pp$ 块：\n$$\nN_{pp} = \\binom{8}{2} \\binom{24}{2} = \\left(\\frac{8 \\times 7}{2 \\times 1}\\right) \\left(\\frac{24 \\times 23}{2 \\times 1}\\right) = 28 \\times 276 = 7728\n$$\n\n对于 $np$ 块：\n$$\nN_{np} = 10 \\times 8 \\times 30 \\times 24 = 80 \\times 720 = 57600\n$$\n\n最后，存储的振幅总数是这些值的总和：\n$$\nN_{\\text{total}} = N_{nn} + N_{pp} + N_{np} = 19575 + 7728 + 57600 = 84903\n$$\n存储的双激发振幅总数为 $84903$。", "answer": "$$\\boxed{84903}$$", "id": "3553374"}, {"introduction": "确定了需要计算的振幅之后，下一个核心挑战是求解高度非线性的耦合簇方程。这项任务 [@problem_id:3553383] 让你深入探究这些方程的迭代求解过程，通过分析其不动点映射的雅可比矩阵的谱特性，来指导和优化如安德森加速（Anderson acceleration）这类现代收敛算法的参数选择。这项练习将抽象的数值分析理论与实际的物理计算问题联系起来，是开发高效多体方法求解器的基础。", "problem": "给定一个耦合簇双激发 (CCD) 幅值方程的简化、自洽不动点公式，该公式适用于一个小的模型空间中的闭壳层体系，它捕捉了基本的非线性结构，同时在计算上是可行的。未知量是一个双激发幅值向量 $\\mathbf{t} \\in \\mathbb{R}^{n}$，在此 $n$ 很小。该映射按分量定义为\n$$\nF_i(\\mathbf{t}) \\equiv \\frac{g_i + \\sum_{j=1}^{n} A_{ij}\\, t_j + \\sum_{j=1}^{n}\\sum_{k=1}^{n} Q_{ijk}\\, t_j t_k}{\\Delta_i}, \\quad i = 1, \\dots, n,\n$$\n其中 $\\boldsymbol{\\Delta} \\in \\mathbb{R}^n$ 是正能量分母，$\\mathbf{g} \\in \\mathbb{R}^n$ 是驱动向量，$\\mathbf{A} \\in \\mathbb{R}^{n \\times n}$ 是一个对称有效耦合矩阵，编码了（环形和梯形）线性化贡献，而 $\\mathbf{Q} \\in \\mathbb{R}^{n \\times n \\times n}$ 是一个对称的 3 阶张量，编码了二次贡献。CCD 不动点满足 $\\mathbf{t} = \\mathbf{F}(\\mathbf{t})$。关于点 $\\mathbf{t}_0$ 的局域线性化由 $\\mathbf{F}$ 的雅可比矩阵描述，即矩阵 $\\mathbf{J}(\\mathbf{t}_0)$，其项为 $J_{i\\ell}(\\mathbf{t}_0) = \\partial F_i/\\partial t_\\ell$ 在 $\\mathbf{t}_0$ 处的值。在雅可比矩阵谱半径严格小于 $1$ 的不动点附近，不动点迭代收敛。诸如 Anderson 加速等实用加速器可以根据这种局域线性化的特征信息进行调整。\n\n您的任务是：\n\n- 根据 $\\mathbf{F}$ 的定义，推导雅可比矩阵项 $J_{i\\ell}(\\mathbf{t})$ 关于 $\\boldsymbol{\\Delta}$、$\\mathbf{A}$、$\\mathbf{Q}$ 和 $\\mathbf{t}$ 的一般形式，然后在展开点 $\\mathbf{t}_0 = \\mathbf{0}$ 处应用该形式以获得 $\\mathbf{J}(\\mathbf{0})$。除了所述定义和标准微分法则外，不要假定任何特殊恒等式。\n\n- 计算 $\\mathbf{J}(\\mathbf{0})$ 的主特征对（特征值和相应的归一化特征向量），其中“主”指具有最大模的特征值。令谱半径为 $\\rho \\equiv \\max_i |\\lambda_i|$，谱隙为 $\\delta \\equiv \\rho - \\max_{i \\neq i_\\star} |\\lambda_i|$，其中 $i_\\star$ 是达到 $\\rho$ 的特征值的索引。\n\n- 根据估计的 $\\rho$ 和 $\\delta$，选择两个 Anderson 加速参数：\n  - 历史长度 $m \\in \\mathbb{Z}$，其界限为 $m_{\\min} \\le m \\le m_{\\max}$，使用以下规则\n    $$\n    m_{\\mathrm{raw}} \\equiv 1 + \\alpha \\,\\frac{\\rho}{\\delta + \\varepsilon}, \\quad m \\equiv \\mathrm{round}\\!\\left(\\min\\!\\left(\\max\\!\\left(m_{\\mathrm{raw}}, m_{\\min}\\right), m_{\\max}\\right)\\right),\n    $$\n    其中调整常数为 $\\alpha  0$ 和 $\\varepsilon  0$。\n  - 阻尼因子 $\\beta \\in \\mathbb{R}$，其界限为 $\\beta_{\\min} \\le \\beta \\le \\beta_{\\max}$，使用以下规则\n    $$\n    \\beta_{\\mathrm{raw}} \\equiv\n    \\begin{cases}\n      1 - \\frac{1}{2}\\,\\rho - \\frac{1}{4}\\,\\delta,  \\text{若 } \\rho  1,\\\\[4pt]\n      \\dfrac{1}{1+\\rho},  \\text{若 } \\rho \\ge 1,\n    \\end{cases}\n    \\quad \\beta \\equiv \\min\\!\\left(\\max\\!\\left(\\beta_{\\mathrm{raw}}, \\beta_{\\min}\\right), \\beta_{\\max}\\right).\n    $$\n\n- 实现一个程序，对于每个提供的测试用例，构造 $\\mathbf{J}(\\mathbf{0})$，计算主特征对，估计 $\\rho$ 和 $\\delta$，使用给定的规则和界限计算 $m$ 和 $\\beta$，并为每个用例返回列表 $[\\rho, \\delta, m, \\beta]$。\n\n使用以下测试套件。在每种情况下，令 $n = 4$。令正交矩阵 $\\mathbf{U} \\in \\mathbb{R}^{4 \\times 4}$ 为按 $1/2$ 缩放的 Walsh–Hadamard 矩阵：\n$$\n\\mathbf{U} \\equiv \\frac{1}{2}\n\\begin{bmatrix}\n1   1   1   1\\\\\n1   1   -1  -1\\\\\n1   -1  1   -1\\\\\n1   -1  -1  1\n\\end{bmatrix}.\n$$\n令分母为 $\\boldsymbol{\\Delta} = [2.0, 2.5, 3.0, 3.5]$，单位为 $\\mathrm{MeV}$，并对所有情况设置 $\\mathbf{Q} = \\mathbf{0}$ 和 $\\mathbf{g} = \\mathbf{0}$（因此在 $\\mathbf{t}_0 = \\mathbf{0}$ 时，雅可比矩阵仅取决于 $\\boldsymbol{\\Delta}$ 和 $\\mathbf{A}$）。对于每种情况，定义目标特征值谱 $\\boldsymbol{\\lambda}$ 并通过以下方式构造 $\\mathbf{A}$\n$$\n\\mathbf{A} \\equiv \\mathrm{diag}(\\boldsymbol{\\Delta}) \\, \\mathbf{U} \\, \\mathrm{diag}(\\boldsymbol{\\lambda}) \\, \\mathbf{U}^{\\top}.\n$$\n这确保了 $\\mathbf{J}(\\mathbf{0})$ 的特征值等于 $\\boldsymbol{\\lambda}$，特征向量由 $\\mathbf{U}$ 的列给出。\n\n- 情况 1：\n  - $\\boldsymbol{\\lambda}^{(1)} = [0.2, 0.1, 0.05, 0.01]$。\n- 情况 2：\n  - $\\boldsymbol{\\lambda}^{(2)} = [0.92, 0.90, 0.3, 0.1]$。\n- 情况 3：\n  - $\\boldsymbol{\\lambda}^{(3)} = [1.05, 0.95, 0.4, 0.1]$。\n\n使用 Anderson 调整常数和界限：\n- $\\alpha = 2.0$,\n- $\\varepsilon = 10^{-9}$,\n- $m_{\\min} = 2$, $m_{\\max} = 6$,\n- $\\beta_{\\min} = 0.05$, $\\beta_{\\max} = 1.0$.\n\n角度单位不适用。所有输出均为无量纲实数。您的程序应生成单行输出，其中包含一个逗号分隔的列表的列表形式的结果，不含空格，形式如下\n$$\n[\\,[\\rho_1,\\delta_1,m_1,\\beta_1],[\\rho_2,\\delta_2,m_2,\\beta_2],\\ldots\\,],\n$$\n其中索引按顺序对应于测试用例。每个 $\\rho_k$ 和 $\\delta_k$ 必须精确打印小数点后 $6$ 位数字。每个 $\\beta_k$ 必须精确打印小数点后 $6$ 位数字。每个 $m_k$ 必须打印为不带小数点的整数。输出必须是单行，且不包含其他字符或空格。", "solution": "该问题要求根据简化的耦合簇双激发 (CCD) 不动点映射的雅可比矩阵的谱特性来确定 Anderson 加速的参数。该过程包括三个主要步骤：首先，推导雅可比矩阵在原点的解析形式；其次，根据问题的特定构造确定其特征值；第三，为给定的三个测试用例计算谱半径 $\\rho$、谱隙 $\\delta$以及相关的加速参数 $m$ 和 $\\beta$。\n\n### 步骤 1：雅可比矩阵的推导\n\n不动点映射 $\\mathbf{F}(\\mathbf{t})$ 对 $i=1, \\dots, n$ 按分量给出：\n$$\nF_i(\\mathbf{t}) = \\frac{g_i + \\sum_{j=1}^{n} A_{ij}\\, t_j + \\sum_{j=1}^{n}\\sum_{k=1}^{n} Q_{ijk}\\, t_j t_k}{\\Delta_i}\n$$\n雅可比矩阵 $\\mathbf{J}(\\mathbf{t})$ 由其项 $J_{i\\ell}(\\mathbf{t}) = \\frac{\\partial F_i}{\\partial t_\\ell}$ 定义。我们计算这个偏导数：\n$$\nJ_{i\\ell}(\\mathbf{t}) = \\frac{\\partial}{\\partial t_\\ell} \\left[ \\frac{1}{\\Delta_i} \\left( g_i + \\sum_{j=1}^{n} A_{ij}\\, t_j + \\sum_{j,k=1}^{n} Q_{ijk}\\, t_j t_k \\right) \\right]\n$$\n项 $g_i$ 和 $\\Delta_i$ 相对于 $\\mathbf{t}$ 的分量是常数。应用微分法则，我们得到：\n$$\nJ_{i\\ell}(\\mathbf{t}) = \\frac{1}{\\Delta_i} \\left[ \\frac{\\partial}{\\partial t_\\ell}\\left(\\sum_{j=1}^{n} A_{ij}\\, t_j\\right) + \\frac{\\partial}{\\partial t_\\ell}\\left(\\sum_{j,k=1}^{n} Q_{ijk}\\, t_j t_k\\right) \\right]\n$$\n线性项的导数是：\n$$\n\\frac{\\partial}{\\partial t_\\ell}\\left(\\sum_{j=1}^{n} A_{ij}\\, t_j\\right) = \\sum_{j=1}^{n} A_{ij} \\frac{\\partial t_j}{\\partial t_\\ell} = \\sum_{j=1}^{n} A_{ij} \\delta_{j\\ell} = A_{i\\ell}\n$$\n其中 $\\delta_{j\\ell}$ 是克罗内克 δ。\n\n对于二次项，我们使用乘积法则，并注意到张量 $\\mathbf{Q}$ 关于其索引的交换是对称的：\n$$\n\\frac{\\partial}{\\partial t_\\ell}\\left(\\sum_{j,k=1}^{n} Q_{ijk}\\, t_j t_k\\right) = \\sum_{j,k=1}^{n} Q_{ijk} \\left( \\frac{\\partial t_j}{\\partial t_\\ell} t_k + t_j \\frac{\\partial t_k}{\\partial t_\\ell} \\right) = \\sum_{j,k=1}^{n} Q_{ijk} (\\delta_{j\\ell} t_k + t_j \\delta_{k\\ell})\n$$\n这可以简化为：\n$$\n\\sum_{k=1}^{n} Q_{i\\ell k} t_k + \\sum_{j=1}^{n} Q_{ij\\ell} t_j\n$$\n利用 $\\mathbf{Q}$ 的对称性（即 $Q_{i\\ell k} = Q_{ik\\ell}$）并重命名第二项中的求和索引从 $j$ 到 $k$，我们合并各项：\n$$\n\\sum_{k=1}^{n} Q_{i\\ell k} t_k + \\sum_{k=1}^{n} Q_{ik\\ell} t_k = \\sum_{k=1}^{n} (Q_{i\\ell k} + Q_{ik\\ell}) t_k = 2 \\sum_{k=1}^{n} Q_{i\\ell k} t_k\n$$\n结合线性和二次部分，雅可比矩阵项的一般表达式为：\n$$\nJ_{i\\ell}(\\mathbf{t}) = \\frac{1}{\\Delta_i} \\left( A_{i\\ell} + 2 \\sum_{k=1}^{n} Q_{i\\ell k} t_k \\right)\n$$\n问题指定分析应在展开点 $\\mathbf{t}_0 = \\mathbf{0}$ 处进行。我们还得知，对于所有测试用例，$\\mathbf{Q} = \\mathbf{0}$。即使 $\\mathbf{Q}$ 不为零，二次项在 $\\mathbf{t}=\\mathbf{0}$ 处也会消失。在 $\\mathbf{t}_0 = \\mathbf{0}$ 处求值：\n$$\nJ_{i\\ell}(\\mathbf{0}) = \\frac{A_{i\\ell}}{\\Delta_i}\n$$\n用矩阵表示法，原点处的雅可比矩阵为：\n$$\n\\mathbf{J}(\\mathbf{0}) = \\mathrm{diag}(\\boldsymbol{\\Delta})^{-1} \\mathbf{A}\n$$\n其中 $\\mathrm{diag}(\\boldsymbol{\\Delta})^{-1}$ 是对角矩阵，其对角线上的项为 $1/\\Delta_i$。\n\n### 步骤 2：特征值和特征向量的确定\n\n问题为矩阵 $\\mathbf{A}$ 提供了一个特定的构造方法：\n$$\n\\mathbf{A} \\equiv \\mathrm{diag}(\\boldsymbol{\\Delta}) \\, \\mathbf{U} \\, \\mathrm{diag}(\\boldsymbol{\\lambda}) \\, \\mathbf{U}^{\\top}\n$$\n将此代入 $\\mathbf{J}(\\mathbf{0})$ 的表达式中：\n$$\n\\mathbf{J}(\\mathbf{0}) = \\mathrm{diag}(\\boldsymbol{\\Delta})^{-1} \\left( \\mathrm{diag}(\\boldsymbol{\\Delta}) \\, \\mathbf{U} \\, \\mathrm{diag}(\\boldsymbol{\\lambda}) \\, \\mathbf{U}^{\\top} \\right)\n$$\n矩阵乘法是可结合的，并且 $\\mathrm{diag}(\\boldsymbol{\\Delta})^{-1} \\mathrm{diag}(\\boldsymbol{\\Delta}) = \\mathbf{I}$，即单位矩阵。因此，表达式简化为：\n$$\n\\mathbf{J}(\\mathbf{0}) = \\mathbf{U} \\, \\mathrm{diag}(\\boldsymbol{\\lambda}) \\, \\mathbf{U}^{\\top}\n$$\n这是可对角化矩阵的特征分解的标准形式。$\\mathbf{J}(\\mathbf{0})$ 的特征值是 $\\mathrm{diag}(\\boldsymbol{\\lambda})$ 的对角元素，这正是向量 $\\boldsymbol{\\lambda}$ 的分量。相应的归一化特征向量是正交矩阵 $\\mathbf{U}$ 的列。\n\n### 步骤 3：测试用例的参数计算\n\n对于每种情况，我们计算谱半径 $\\rho = \\max_i |\\lambda_i|$ 和谱隙 $\\delta = \\rho - \\max_{i \\neq i_\\star} |\\lambda_i|$，其中 $|\\lambda_{i_\\star}|=\\rho$。然后我们使用提供的公式和常数计算参数 $m$ 和 $\\beta$：$\\alpha = 2.0$, $\\varepsilon = 10^{-9}$, $m_{\\min} = 2$, $m_{\\max} = 6$, $\\beta_{\\min} = 0.05$, $\\beta_{\\max} = 1.0$。\n\n**情况 1：**\n- 特征值：$\\boldsymbol{\\lambda}^{(1)} = [0.2, 0.1, 0.05, 0.01]$。\n- 模：$[0.2, 0.1, 0.05, 0.01]$。\n- 谱半径：$\\rho_1 = 0.2$。\n- 谱隙：$\\delta_1 = 0.2 - 0.1 = 0.1$。\n- 历史长度 $m_1$：\n  $m_{\\mathrm{raw},1} = 1 + \\alpha \\frac{\\rho_1}{\\delta_1 + \\varepsilon} = 1 + 2.0 \\frac{0.2}{0.1 + 10^{-9}} \\approx 5.0$。\n  $m_1 = \\mathrm{round}(\\min(\\max(5.0, 2), 6)) = \\mathrm{round}(5.0) = 5$。\n- 阻尼因子 $\\beta_1$：由于 $\\rho_1 = 0.2  1$：\n  $\\beta_{\\mathrm{raw},1} = 1 - 0.5\\rho_1 - 0.25\\delta_1 = 1 - 0.5(0.2) - 0.25(0.1) = 1 - 0.1 - 0.025 = 0.875$。\n  $\\beta_1 = \\min(\\max(0.875, 0.05), 1.0) = 0.875$。\n- 结果 1：$[\\rho_1, \\delta_1, m_1, \\beta_1] = [0.200000, 0.100000, 5, 0.875000]$。\n\n**情况 2：**\n- 特征值：$\\boldsymbol{\\lambda}^{(2)} = [0.92, 0.90, 0.3, 0.1]$。\n- 模：$[0.92, 0.90, 0.3, 0.1]$。\n- 谱半径：$\\rho_2 = 0.92$。\n- 谱隙：$\\delta_2 = 0.92 - 0.90 = 0.02$。\n- 历史长度 $m_2$：\n  $m_{\\mathrm{raw},2} = 1 + \\alpha \\frac{\\rho_2}{\\delta_2 + \\varepsilon} = 1 + 2.0 \\frac{0.92}{0.02 + 10^{-9}} \\approx 93.0$。\n  $m_2 = \\mathrm{round}(\\min(\\max(93.0, 2), 6)) = \\mathrm{round}(6.0) = 6$。\n- 阻尼因子 $\\beta_2$：由于 $\\rho_2 = 0.92  1$：\n  $\\beta_{\\mathrm{raw},2} = 1 - 0.5\\rho_2 - 0.25\\delta_2 = 1 - 0.5(0.92) - 0.25(0.02) = 1 - 0.46 - 0.005 = 0.535$。\n  $\\beta_2 = \\min(\\max(0.535, 0.05), 1.0) = 0.535$。\n- 结果 2：$[\\rho_2, \\delta_2, m_2, \\beta_2] = [0.920000, 0.020000, 6, 0.535000]$。\n\n**情况 3：**\n- 特征值：$\\boldsymbol{\\lambda}^{(3)} = [1.05, 0.95, 0.4, 0.1]$。\n- 模：$[1.05, 0.95, 0.4, 0.1]$。\n- 谱半径：$\\rho_3 = 1.05$。\n- 谱隙：$\\delta_3 = 1.05 - 0.95 = 0.1$。\n- 历史长度 $m_3$：\n  $m_{\\mathrm{raw},3} = 1 + \\alpha \\frac{\\rho_3}{\\delta_3 + \\varepsilon} = 1 + 2.0 \\frac{1.05}{0.1 + 10^{-9}} \\approx 22.0$。\n  $m_3 = \\mathrm{round}(\\min(\\max(22.0, 2), 6)) = \\mathrm{round}(6.0) = 6$。\n- 阻尼因子 $\\beta_3$：由于 $\\rho_3 = 1.05 \\ge 1$：\n  $\\beta_{\\mathrm{raw},3} = \\frac{1}{1+\\rho_3} = \\frac{1}{1+1.05} = \\frac{1}{2.05} \\approx 0.487804878$。\n  $\\beta_3 = \\min(\\max(0.487804878, 0.05), 1.0) \\approx 0.487805$。\n- 结果 3：$[\\rho_3, \\delta_3, m_3, \\beta_3] = [1.050000, 0.100000, 6, 0.487805]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Anderson acceleration parameters based on spectral properties of\n    a simplified Coupled-Cluster Doubles Jacobian.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Eigenvalue spectrum lambda^(1)\n        np.array([0.2, 0.1, 0.05, 0.01]),\n        # Case 2: Eigenvalue spectrum lambda^(2)\n        np.array([0.92, 0.90, 0.3, 0.1]),\n        # Case 3: Eigenvalue spectrum lambda^(3)\n        np.array([1.05, 0.95, 0.4, 0.1]),\n    ]\n\n    # Define Anderson tuning constants and bounds.\n    alpha = 2.0\n    epsilon = 1e-9\n    m_min = 2\n    m_max = 6\n    beta_min = 0.05\n    beta_max = 1.0\n\n    all_results = []\n    for case_lambdas in test_cases:\n        # Main logic to calculate the result for one case goes here.\n\n        # Step 1: Compute spectral radius (rho) and spectral gap (delta).\n        # The eigenvalues of J(0) are given directly by the case_lambdas vector.\n        abs_lambdas = np.abs(case_lambdas)\n        sorted_abs_lambdas = np.sort(abs_lambdas)[::-1]  # Sort in descending order\n\n        rho = sorted_abs_lambdas[0]\n        # The problem definition of delta assumes a unique maximum magnitude,\n        # which holds for all test cases.\n        delta = rho - sorted_abs_lambdas[1]\n\n        # Step 2: Compute the history length 'm'.\n        m_raw = 1 + alpha * rho / (delta + epsilon)\n        # Apply bounds [m_min, m_max].\n        m_bounded = np.minimum(np.maximum(m_raw, m_min), m_max)\n        # Round to the nearest integer.\n        m = int(np.round(m_bounded))\n\n        # Step 3: Compute the damping factor 'beta'.\n        if rho  1:\n            beta_raw = 1 - 0.5 * rho - 0.25 * delta\n        else:  # rho >= 1\n            beta_raw = 1 / (1 + rho)\n        # Apply bounds [beta_min, beta_max].\n        beta = np.minimum(np.maximum(beta_raw, beta_min), beta_max)\n\n        # Store the results for the current case.\n        result = [rho, delta, m, beta]\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    # The output must be a single line containing a comma-separated list of lists.\n    # rho, delta, and beta must have exactly 6 digits after the decimal point.\n    # m must be an integer.\n    # No spaces are allowed in the final output string.\n    output_parts = []\n    for res in all_results:\n        rho_val, delta_val, m_val, beta_val = res\n        part = f\"[{rho_val:.6f},{delta_val:.6f},{m_val},{beta_val:.6f}]\"\n        output_parts.append(part)\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3553383"}, {"introduction": "求解耦合簇方程涉及计算量巨大的张量缩并，这往往是大型系统计算的性能瓶颈。这项练习 [@problem_id:3553409] 聚焦于其中一个关键的缩并项，指导你使用“屋顶线”（roofline）模型这一强大的分析工具。你将通过计算该操作的算术强度，来预测其在不同硬件（如CPU和GPU）上的性能极限，从而理解计算任务是受计算能力限制还是受内存带宽限制，这是进行高性能计算代码优化的必备技能。", "problem": "您需要实现一个完整的程序，该程序模拟计算核物理中使用的耦合簇双激发 (CCD) 近似中出现的收缩项的计算性能。重点是收缩项 $W_{ab}^{ef} t_{ij}^{ef}$，它对双激发残差有贡献。当此收缩项被映射为稠密矩阵乘法时，请推导并计算其算术强度和屋顶线性能预测，并预测图形处理单元 (GPU) 相对于中央处理器 (CPU) 的加速比。\n\n从以下基本原理出发：\n- 不含时 Schrödinger 方程 $H|\\Psi\\rangle = E|\\Psi\\rangle$ 和耦合簇参数化 $|\\Psi\\rangle = e^{T}|\\Phi_0\\rangle$，在双激发级别截断，使得 $T = T_2$。\n- 收缩项 $W_{ab}^{ef} t_{ij}^{ef}$ 对索引 $e$ 和 $f$ 求和；$a$、$b$ 标记虚轨道，$i$、$j$ 标记占据轨道。通过将 $(a,b)$ 组合成一个复合行索引，将 $(e,f)$ 组合成一个复合内维度索引，将 $(i,j)$ 组合成一个复合列索引，从而将此收缩项建模为稠密矩阵乘法。这样一个形状为 $(M,K)$ 的矩阵 $A$ 乘以一个形状为 $(K,N)$ 的矩阵 $B$，生成一个形状为 $(M,N)$ 的矩阵 $C$，其中 $M = n_v^2$，$K = n_v^2$，$N = n_o^2$，$n_v$ 是虚轨道数，$n_o$ 是占据轨道数。\n- 假设使用双精度浮点数，每个数占用 $8$ 字节。\n\n您必须为每个测试用例执行以下操作：\n1. 使用一个经过充分测试的稠密通用矩阵乘法算术模型，计算该收缩项的稠密矩阵乘法映射所需的总浮点运算次数 (FLOPs)。\n2. 在理想的分块和复用假设下，使用一个经过充分测试的带宽模型，计算主内存和处理器之间数据移动的下界。该模型考虑了读取两个输入矩阵一次和写入输出矩阵一次的情况。\n3. 推导算术强度 $I$，其定义为每移动一个字节所执行的浮点运算次数。\n4. 使用屋顶线模型，预测中央处理器 (CPU) 和图形处理单元 (GPU) 的持续性能（单位：每秒十亿次浮点运算 GFLOP/s）：$P = \\min(P_{\\text{peak}}, I B)$，其中 $P_{\\text{peak}}$ 是峰值浮点性能，$B$ 是内存带宽，$I$ 是算术强度。通过比较 $I B$ 和 $P_{\\text{peak}}$，阐明该计算是内存受限还是计算受限。\n5. 计算加速比 $S$（无量纲），即预测的 GPU 性能与预测的 CPU 性能之比。\n\n所有测试用例使用的硬件参数：\n- CPU 峰值双精度性能 $P_{\\text{CPU,peak}} = 500$ GFLOP/s。\n- CPU 内存带宽 $B_{\\text{CPU}} = 100$ GB/s。\n- GPU 峰值双精度性能 $P_{\\text{GPU,peak}} = 5000$ GFLOP/s。\n- GPU 内存带宽 $B_{\\text{GPU}} = 800$ GB/s。\n\n所有涉及性能的数值答案必须以每秒十亿次浮点运算 (GFLOP/s) 表示。所有带宽单位为每秒千兆字节 (GB/s)。加速比必须表示为无单位的小数比率。算术强度必须以 FLOPs/byte 为单位的浮点数表示。不涉及角度。使用双精度（每个数 8 字节）。\n\n测试套件：\n- 用例 1：$n_o = 2$, $n_v = 2$。\n- 用例 2：$n_o = 8$, $n_v = 8$。\n- 用例 3：$n_o = 8$, $n_v = 20$。\n- 用例 4：$n_o = 64$, $n_v = 64$。\n- 用例 5：$n_o = 1$, $n_v = 64$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。对于每个测试用例，按以下顺序附加四个浮点数：算术强度 $I$、预测的 CPU 性能 (GFLOP/s)、预测的 GPU 性能 (GFLOP/s) 和预测的加速比 $S$。因此，总输出是一个包含 $4 \\times 5 = 20$ 个浮点数的扁平列表。每个浮点数必须四舍五入到 6 位小数。例如，输出应具有以下形式：$[I_1,P_{\\text{CPU},1},P_{\\text{GPU},1},S_1,\\dots,I_5,P_{\\text{CPU},5},P_{\\text{GPU},5},S_5]$。", "solution": "耦合簇方法从不含时 Schrödinger 方程 $H|\\Psi\\rangle = E|\\Psi\\rangle$ 和耦合簇拟设 $|\\Psi\\rangle = e^{T}|\\Phi_0\\rangle$ 出发，其中 $|\\Phi_0\\rangle$ 是一个参考 Slater 行列式，$T$ 是簇算符。在耦合簇双激发 (CCD) 近似中，截断 $T = T_2$ 仅保留双激发，这在许多核结构应用中占据了主要的计算成本。\n\n在 CCD 框架内，双激发振幅方程包含涉及中间量 $W$ 和双激发振幅 $t$ 的收缩项。一个代表性项是 $W_{ab}^{ef} t_{ij}^{ef}$，它对 $(a,b,i,j)$ 的每个组合的虚轨道索引 $e$ 和 $f$ 进行求和。为了分析计算复杂度和性能，我们将此收缩项映射到稠密通用矩阵乘法（通常称为 GEMM）。我们构成复合索引：\n- $(a,b)$ 成为矩阵 $A$ 的单个行索引，大小为 $M = n_v^2$。\n- $(e,f)$ 成为内维度索引，大小为 $K = n_v^2$。\n- $(i,j)$ 成为矩阵 $B$ 的单个列索引，大小为 $N = n_o^2$。\n\n收缩项 $W_{ab}^{ef} t_{ij}^{ef}$ 因而等效于计算 $C = A \\times B$，其中 $A \\in \\mathbb{R}^{M \\times K}$，$B \\in \\mathbb{R}^{K \\times N}$，$C \\in \\mathbb{R}^{M \\times N}$，$C_{ab}^{ij}$ 是映射回复合索引的输出。\n\n我们现在使用成熟的稠密矩阵乘法和内存流量性能模型来推导算术强度：\n- 一个 $(M \\times K)$ 矩阵乘以一个 $(K \\times N)$ 矩阵的总浮点运算次数为\n$$\n\\text{FLOPs} = 2 M N K,\n$$\n每个输出元素的每个内维度贡献计为一次乘法和一次加法。\n- 在理想的分块和复用条件下，主内存和处理器之间数据移动的下界由读取 $A$ 和 $B$ 各一次并写入 $C$ 一次给出。对于双精度，每个元素占用 $8$ 字节。因此，传输字节数的下界是\n$$\n\\text{Bytes}_{\\min} = 8 \\left(MK + KN + MN\\right).\n$$\n这个下界假设了优化的分块策略，使得每个输入元素在缓存或片上内存中得到最大程度的复用，并且输出元素在寄存器中累积然后只写回一次。\n\n因此，定义为每移动一个字节所执行的浮点运算次数的算术强度为\n$$\nI = \\frac{\\text{FLOPs}}{\\text{Bytes}_{\\min}} = \\frac{2 M N K}{8 \\left(MK + KN + MN\\right)} = \\frac{M N K}{4 \\left(MK + KN + MN\\right)}.\n$$\n\n屋顶线模型将算术强度与持续性能联系起来。对于一个具有峰值双精度浮点性能 $P_{\\text{peak}}$（单位 GFLOP/s）和内存带宽 $B$（单位 GB/s）的处理器，预测的持续性能 $P$（单位 GFLOP/s）为\n$$\nP = \\min\\left(P_{\\text{peak}}, I \\, B\\right).\n$$\n如果 $I B  P_{\\text{peak}}$，则计算是内存受限的；否则，它是计算受限的。\n\n我们考虑两种设备：中央处理器 (CPU) 和图形处理单元 (GPU)。给定 $P_{\\text{CPU,peak}}$、$B_{\\text{CPU}}$、$P_{\\text{GPU,peak}}$ 和 $B_{\\text{GPU}}$，预测的性能为\n$$\nP_{\\text{CPU}} = \\min\\left(P_{\\text{CPU,peak}}, I \\, B_{\\text{CPU}}\\right), \\quad\nP_{\\text{GPU}} = \\min\\left(P_{\\text{GPU,peak}}, I \\, B_{\\text{GPU}}\\right).\n$$\n加速比是无量纲的比率\n$$\nS = \\frac{P_{\\text{GPU}}}{P_{\\text{CPU}}}.\n$$\n\n对于每个测试用例，我们计算 $M = n_v^2$，$K = n_v^2$，$N = n_o^2$，然后应用上述公式获得 $I$、$P_{\\text{CPU}}$、$P_{\\text{GPU}}$ 和 $S$。单位如下：\n- 算术强度 $I$ 的单位是 FLOPs/byte。\n- 预测性能 $P_{\\text{CPU}}$ 和 $P_{\\text{GPU}}$ 的单位是 GFLOP/s。\n- 加速比 $S$ 是无量纲的。\n\n我们对所有情况使用以下硬件参数：$P_{\\text{CPU,peak}} = 500$ GFLOP/s, $B_{\\text{CPU}} = 100$ GB/s, $P_{\\text{GPU,peak}} = 5000$ GFLOP/s, $B_{\\text{GPU}} = 800$ GB/s。每个数值结果都四舍五入到 6 位小数，并且所有测试用例的输出按每个用例 $[I, P_{\\text{CPU}}, P_{\\text{GPU}}, S]$ 的顺序连接成一个单一的扁平列表。\n\n这种方法为映射到稠密矩阵乘法的主要 CCD 收缩项提供了有原则的屋顶线分析，阐明了对于不同问题规模，该收缩项是内存受限还是计算受限，并预测了 GPU 相对于 CPU 的加速比。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef roofline_predictions(n_o, n_v, cpu_peak_gflops, cpu_bw_gbs, gpu_peak_gflops, gpu_bw_gbs, dtype_bytes=8):\n    # Map CCD contraction W_ab^{ef} t_ij^{ef} to GEMM with composite indices:\n    # M = n_v^2 (rows A and C), K = n_v^2 (inner dimension), N = n_o^2 (cols B and C)\n    M = n_v * n_v\n    K = n_v * n_v\n    N = n_o * n_o\n\n    # FLOPs for dense GEMM: 2 * M * N * K\n    flops = 2.0 * M * N * K\n\n    # Minimal bytes moved under ideal tiling: read A and B once, write C once\n    bytes_min = dtype_bytes * (M * K + K * N + M * N)\n\n    # Arithmetic intensity: FLOPs per byte\n    intensity = flops / bytes_min if bytes_min > 0 else 0.0\n\n    # Roofline predicted performance\n    cpu_perf = min(cpu_peak_gflops, intensity * cpu_bw_gbs)\n    gpu_perf = min(gpu_peak_gflops, intensity * gpu_bw_gbs)\n\n    # Speedup GPU vs CPU\n    speedup = gpu_perf / cpu_perf if cpu_perf > 0 else float('inf')\n\n    return intensity, cpu_perf, gpu_perf, speedup\n\ndef solve():\n    # Hardware parameters (double precision)\n    cpu_peak_gflops = 500.0   # GFLOP/s\n    cpu_bw_gbs = 100.0        # GB/s\n    gpu_peak_gflops = 5000.0  # GFLOP/s\n    gpu_bw_gbs = 800.0        # GB/s\n    dtype_bytes = 8           # bytes per double\n\n    # Define the test cases from the problem statement.\n    # Each case is (n_o, n_v)\n    test_cases = [\n        (2, 2),    # Case 1: small, likely memory-bound\n        (8, 8),    # Case 2: moderate, mixed-bound behavior possible\n        (8, 20),   # Case 3: typical nuclear sizes, likely compute-bound\n        (64, 64),  # Case 4: large, compute-bound\n        (1, 64),   # Case 5: boundary case with N=1, likely memory-bound\n    ]\n\n    results = []\n    for n_o, n_v in test_cases:\n        intensity, cpu_perf, gpu_perf, speedup = roofline_predictions(\n            n_o, n_v, cpu_peak_gflops, cpu_bw_gbs, gpu_peak_gflops, gpu_bw_gbs, dtype_bytes\n        )\n        # Round to 6 decimal places as required and append in the specified order\n        results.extend([\n            f\"{intensity:.6f}\",\n            f\"{cpu_perf:.6f}\",\n            f\"{gpu_perf:.6f}\",\n            f\"{speedup:.6f}\",\n        ])\n\n    # Final print statement in the exact required format (single line, comma-separated list in brackets).\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3553409"}]}