{"hands_on_practices": [{"introduction": "任何处理全同费米子的多体计算，其首要步骤都是通过反对称化来正确地施加泡利不相容原理。本练习将提供构造反对称化投影算符的直接实践，这是一个基本的算符。你将在两种关键的表象中进行构建：一种是简单的粒子乘积基，另一种是物理上更有用的雅可比坐标基 [@problem_id:3563419]。", "problem": "针对一维谐振子 (HO) 基和雅可比坐标谐振子基中的全同无自旋费米子，实现三体反对称化子的数值验证。考虑三个等质量粒子。使用三对象上的置换群（对称群 $S_3$）及相应的投影算符来定义反对称化子。反对称化子定义为\n$$\nA \\equiv \\frac{1}{6}\\sum_{\\pi \\in S_3} \\mathrm{sgn}(\\pi)\\, P_\\pi,\n$$\n其中 $P_\\pi$ 是根据置换 $\\pi$ 重排粒子标签的置换算符，$\\mathrm{sgn}(\\pi)$ 对偶置换为 $+1$，对奇置换为 $-1$。投影算符的定义性质是幂等性，即\n$$\nA^2 = A.\n$$\n你将在由单粒子谐振子数本征态构成的截断谐振子基中进行操作。构建一个固定总量子数的三体基\n$$\n\\mathcal{B}_{\\mathrm{sp}}(N_{\\mathrm{tot}}) = \\{\\,|n_1,n_2,n_3\\rangle \\,:\\, n_i \\in \\mathbb{N}_0,\\; n_1+n_2+n_3 = N_{\\mathrm{tot}}\\,\\}.\n$$\n置换算符 $P_\\pi$ 对基矢量的作用通过重标记粒子坐标来定义，等效地映射元组为\n$$\nP_\\pi\\,|n_1,n_2,n_3\\rangle \\;=\\; |n_{\\pi^{-1}(1)},n_{\\pi^{-1}(2)},n_{\\pi^{-1}(3)}\\rangle.\n$$\n第一部分（粒子序基）：为所有六个 $\\pi \\in S_3$ 构建 $|\\,\\mathcal{B}_{\\mathrm{sp}}(N_{\\mathrm{tot}})\\,| \\times |\\,\\mathcal{B}_{\\mathrm{sp}}(N_{\\mathrm{tot}})\\,|$ 矩阵 $P_\\pi$，组装 $A$，并通过计算弗罗贝尼乌斯范数来数值验证其投影算符性质\n$$\n\\|A^2 - A\\|_F \\equiv \\sqrt{\\mathrm{Tr}\\big((A^2-A)^\\top (A^2-A)\\big)}.\n$$\n第二部分（质心解耦的雅可比坐标基）：通过将粒子坐标映射到雅可比坐标的标准正交变换来定义雅可比模式。在谐振子升降算符的层面上，这是一个实正交模式混合\n$$\n\\begin{pmatrix}\nb_\\rho \\\\\nb_\\lambda \\\\\nb_{\\mathrm{CM}}\n\\end{pmatrix}\n=\nO\n\\begin{pmatrix}\na_1 \\\\\na_2 \\\\\na_3\n\\end{pmatrix},\n\\quad\nO \\equiv\n\\begin{pmatrix}\n\\frac{1}{\\sqrt{2}}  -\\frac{1}{\\sqrt{2}}  0 \\\\\n\\frac{1}{\\sqrt{6}}  \\frac{1}{\\sqrt{6}}  -\\frac{2}{\\sqrt{6}} \\\\\n\\frac{1}{\\sqrt{3}}  \\frac{1}{\\sqrt{3}}  \\frac{1}{\\sqrt{3}}\n\\end{pmatrix}.\n$$\n这里，$a_i$ 是粒子模式的湮灭算符，$(b_\\rho,b_\\lambda,b_{\\mathrm{CM}})$ 是与相对坐标 $(\\rho,\\lambda)$ 和质心 (CM) 相关联的雅可比湮灭算符。使用此正交变换来构建从固定总量子数 $N_{\\mathrm{tot}}$ 的粒子福克基 $\\{|n_1,n_2,n_3\\rangle\\}$ 到 $n_\\rho+n_\\lambda+N_{\\mathrm{CM}}=N_{\\mathrm{tot}}$ 的雅可比福克基 $\\{|n_\\rho,n_\\lambda,N_{\\mathrm{CM}}\\rangle\\}$ 的幺正基变换矩阵 $U$。然后通过以下方式变换反对称化子\n$$\nA_{\\mathrm{Jac}} \\;=\\; U\\, A\\, U^\\top,\n$$\n并通过选择 $N_{\\mathrm{CM}}=0$ 的行和列，将其限制在质心基态子空间 $N_{\\mathrm{CM}}=0$ 上。通过计算以下范数在此子空间中验证幂等性\n$$\n\\big\\|A_{\\mathrm{Jac}}^{(N_{\\mathrm{CM}}=0)\\,2} - A_{\\mathrm{Jac}}^{(N_{\\mathrm{CM}}=0)}\\big\\|_F.\n$$\n无需进一步论证即可使用的基本原理：(i) 置换算符及其复合的定义，(ii) 群性质 $\\mathrm{sgn}(\\pi)\\mathrm{sgn}(\\sigma)=\\mathrm{sgn}(\\pi\\sigma)$，(iii) 上文定义的三体反对称化子，(iv) 对于等质量和相等谐振子频率，雅可比变换 $O$ 的标准正交性，以及 (v) 谐振子模式的升降算符代数。\n\n算法实现要求：\n- 在固定的 $N_{\\mathrm{tot}}$ 下构建粒子序基。\n- 根据 $\\pi^{-1}$ 置换基矢元组，为所有 $P_\\pi$ 构建矩阵。\n- 组装 $A$ 并通过弗罗贝尼乌斯范数数值验证幂等性。\n- 通过将表示为雅可比模式产生算符线性组合的粒子模式产生算符作用于真空态，精确构建幺正基变换矩阵 $U$。使用升降算符作用 $b_k^\\dagger|m_k\\rangle=\\sqrt{m_k+1}\\,|m_k+1\\rangle$ 以及构建归一化数态所需的顺序归一化因子来追踪归一化。\n- 将 $A$ 变换到雅可比基，并限制在 $N_{\\mathrm{CM}}=0$ 子空间中，以验证其在该处的幂等性。\n\n数值测试套件与要求输出：\n- 使用以下五个测试用例，由总谐振子量子数 $N_{\\mathrm{tot}}$ 和检查幂等性时所用的表示指定：\n    1. $(N_{\\mathrm{tot}}=0,\\ \\mathrm{particle})$\n    2. $(N_{\\mathrm{tot}}=1,\\ \\mathrm{particle})$\n    3. $(N_{\\mathrm{tot}}=2,\\ \\mathrm{particle})$\n    4. $(N_{\\mathrm{tot}}=3,\\ \\mathrm{Jacobi\\ with\\ }N_{\\mathrm{CM}}=0)$\n    5. $(N_{\\mathrm{tot}}=4,\\ \\mathrm{Jacobi\\ with\\ }N_{\\mathrm{CM}}=0)$\n- 对于每种情况，计算一个等于指定表示中幂等性缺陷的弗罗贝尼乌斯范数的实数。不要使用任何物理单位。\n- 最终输出格式：你的程序应生成单行输出，其中包含一个逗号分隔的浮点数列表，结果四舍五入到十二位小数，并用方括号括起来（例如，\"[0.0,0.0,0.0,0.0,0.0]\"）。\n\n你的提交必须是一个完整的、可运行的程序，该程序执行上述所有步骤，并以上述五个测试用例的精确要求格式打印结果。", "solution": "用户提供的问题是一个在计算量子力学领域中表述良好且科学合理练习，具体涉及在不同基组中对称算符的表示。该问题是有效的，并且提供了解决方案所需的所有必要组件。我们将遵循指定的算法步骤来构建解决方案。\n\n问题的核心是数值验证三体反对称化投影算符 $A$ 的幂等性属性 $A^2 = A$。此验证在一个一维谐振子势中三个全同无自旋费米子系统的两个不同但幺正相关的基组中进行。\n\n### 第一部分：在粒子序基中的验证\n\n首先，我们在单粒子乘积基中解决这个问题。\n\n**1. 基的构建**\n对于一个固定的谐振子量子总数 $N_{\\mathrm{tot}}$，基由态矢量 $|n_1, n_2, n_3\\rangle$ 构成，其中 $n_i \\in \\mathbb{N}_0$ 分别是粒子 $1, 2, 3$ 的量子数，并且它们满足约束 $n_1 + n_2 + n_3 = N_{\\mathrm{tot}}$。\n我们生成这些状态元组 $(n_1, n_2, n_3)$ 的一个规范的、按字典序排序的列表，我们将其表示为 $\\mathcal{B}_{\\mathrm{sp}}(N_{\\mathrm{tot}})$。这个基的维度是 $d = \\binom{N_{\\mathrm{tot}}+3-1}{3-1} = \\binom{N_{\\mathrm{tot}}+2}{2}$。列表中的每个状态都被分配一个唯一的索引，从而创建一个从状态元组到其矩阵索引的映射。\n\n**2. 置换算符**\n反对称化子 $A$ 是对称群 $S_3$ 中六个置换 $\\pi$ 的置换算符 $P_\\pi$ 的线性组合。\n$$\nA = \\frac{1}{6}\\sum_{\\pi \\in S_3} \\mathrm{sgn}(\\pi)\\, P_\\pi\n$$\n$P_\\pi$ 对基矢量的作用由 $P_\\pi\\,|n_1,n_2,n_3\\rangle = |n_{\\pi^{-1}(1)},n_{\\pi^{-1}(2)},n_{\\pi^{-1}(3)}\\rangle$ 给出。这意味着量子数根据逆置换 $\\pi^{-1}$ 进行重排。\n为了构建 $P_\\pi$ 的 $d \\times d$ 矩阵表示，我们考虑其元素 $(P_\\pi)_{ij} = \\langle i | P_\\pi | j \\rangle$，其中 $|i\\rangle$ 和 $|j\\rangle$ 是基矢量。对于每个基矢量 $|j\\rangle = |n_{j1}, n_{j2}, n_{j3}\\rangle$，我们计算置换后的态矢量 $|k\\rangle = P_\\pi |j\\rangle$。然后我们找到索引 $i$ 使得 $|i\\rangle = |k\\rangle$。矩阵元素 $(P_\\pi)_{ij}$ 于是为 $1$，而第 $j$ 列中的所有其他元素均为 $0$。我们对所有 $\\pi \\in S_3$ 重复此过程。符号 $\\mathrm{sgn}(\\pi)$ 对于偶置换（单位元、3-循环）为 $+1$，对于奇置换（对换）为 $-1$。\n\n**3. 幂等性验证**\n在为所有六个 $P_\\pi$ 构建矩阵表示后，我们通过它们的带符号求和并除以 $6$ 来组装 $A$ 的矩阵。最后一步是计算幂等性缺陷矩阵 $A^2 - A$，并计算其弗罗贝尼乌斯范数 $\\|A^2 - A\\|_F$。对于一个精确的投影算符，此范数必须为零。对于无自旋费米子，任何具有两个或多个粒子具有相同量子数的状态（例如 $|1,1,0\\rangle$ 或 $|2,0,0\\rangle$）都必须被反对称化子湮灭。对于 $N_{\\mathrm{tot}}  3$，任何状态 $|n_1,n_2,n_3\\rangle$ 都必须至少有两个相同的量子数。因此，对于 $N_{\\mathrm{tot}}=0, 1, 2$，算符 $A$ 将每个基态投影到零，使得 $A$ 成为零矩阵。因此，$A^2-A=0$，范数恰好为 $0$。\n\n### 第二部分：在雅可比坐标基中的验证\n\n接下来，我们变换到一个将质心 (CM) 运动与内部相对运动解耦的基。\n\n**1. 基变换**\n从粒子模式升降算符 $(a_1, a_2, a_3)$ 到雅可比模式算符 $(b_\\rho, b_\\lambda, b_{\\mathrm{CM}})$ 的变换由正交矩阵 $O$ 给出。相应的产生算符变换为 $a_i^\\dagger = \\sum_k (O^\\top)_{ik} b_k^\\dagger$。一个粒子基矢量 $|n_1, n_2, n_3\\rangle$ 可以通过将粒子产生算符作用于真空态来构建：\n$$\n|n_1, n_2, n_3\\rangle = \\frac{(a_1^\\dagger)^{n_1}}{\\sqrt{n_1!}} \\frac{(a_2^\\dagger)^{n_2}}{\\sqrt{n_2!}} \\frac{(a_3^\\dagger)^{n_3}}{\\sqrt{n_3!}} |0\\rangle\n$$\n通过用 $b_k^\\dagger$ 替换 $a_i^\\dagger$ 的表达式，我们可以将任何粒子态矢量表示为雅可比态矢量 $|n_\\rho, n_\\lambda, N_{\\mathrm{CM}}\\rangle$ 的线性组合。这个展开的系数是基变换矩阵 $U$ 的元素。这些系数，被称为 Talmi-Moshinsky 括号，可以通过带记忆化的递归算法系统地计算。递归通过将 $|n_1, ..., n_i, ...\\rangle$ 表示为 $a_i^\\dagger |n_1, ..., n_i-1, ...\\rangle$ 并使用后者的已知展开来进行。\n\n**2. 变换后的反对称化子**\n构建了幺正矩阵 $U$ 之后，雅可比基中的反对称化子通过相似变换获得：$A_{\\mathrm{Jac}} = U A U^\\top$。由于 $U$ 是实数，所以 $U^\\dagger = U^\\top$。\n\n**3. 子空间限制与验证**\n我们关心的是内部子系统的物理学，这对应于质心处于其基态的子空间，即 $N_{\\mathrm{CM}}=0$。我们识别出 $A_{\\mathrm{Jac}}$ 中对应于基态 $|n_\\rho, n_\\lambda, 0\\rangle$（其中 $n_\\rho+n_\\lambda=N_{\\mathrm{tot}}$）的行和列。这将产生一个更小的矩阵，$A_{\\mathrm{Jac}}^{(N_{\\mathrm{CM}}=0)}$。然后，我们通过计算其缺陷矩阵的弗罗贝尼乌斯范数 $\\| (A_{\\mathrm{Jac}}^{(N_{\\mathrm{CM}}=0)})^2 - A_{\\mathrm{Jac}}^{(N_{\\mathrm{CM}}=0)} \\|_F$ 来验证此子空间中的幂等性。由于所实现变换的精确性，此范数应为数值上的零（即，在机器浮点精度的量级上）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import sqrt\nfrom itertools import permutations\nfrom collections import defaultdict\n\n# Memoization cache for the recursive Jacobi expansion function.\n# A global variable is used for simplicity across calls for a single test case.\n_memo_U_calc = {}\n\n# Pre-calculate permutation information for the symmetric group S3.\n# The permutation action on a state |n1,n2,n3> is defined by reordering\n# the quantum numbers according to pi^{-1}. We compute the inverse for each\n# permutation pi in S3 and its sign.\n_S3_PERMS = []\nfor p in permutations(range(3)):\n    # Create the permutation matrix for 'p' to compute its sign (determinant).\n    mat = np.zeros((3, 3))\n    for i, j in enumerate(p):\n        mat[i, j] = 1\n    sign = int(round(np.linalg.det(mat)))\n    \n    # The permutation 'p' maps index i to p[i]. Its inverse maps p[i] back to i.\n    p_inv = [0, 0, 0]\n    for i, j in enumerate(p):\n        p_inv[j] = i\n    _S3_PERMS.append({'pi_inv': tuple(p_inv), 'sign': sign})\n\n# The problem defines the transformation from particle to Jacobi annihilation\n# operators via an orthogonal matrix O. For creation operators, the transformation\n# involves O transpose. This matrix stores the coefficients for expressing particle\n# creation operators (a_i^\\dagger) as linear combinations of Jacobi creation\n# operators (b_k^\\dagger).\n_O_T = np.array([\n    [1 / sqrt(2),  1 / sqrt(6), 1 / sqrt(3)],\n    [-1 / sqrt(2), 1 / sqrt(6), 1 / sqrt(3)],\n    [0,           -2 / sqrt(6), 1 / sqrt(3)]\n])\n\ndef _generate_basis(n_tot, num_particles):\n    \"\"\"\n    Generates all state tuples (n1, n2, ...) for a given total number of quanta\n    n_tot and number of particles. This is a recursive generator for integer partitions.\n    \"\"\"\n    if num_particles == 1:\n        yield (n_tot,)\n        return\n    for i in range(n_tot + 1):\n        for p in _generate_basis(n_tot - i, num_particles - 1):\n            yield (i,) + p\n\ndef _get_jacobi_expansion(n_tuple):\n    \"\"\"\n    Recursively computes the expansion of a particle state in the Jacobi basis\n    using memoization to store results of subproblems.\n    \"\"\"\n    if n_tuple in _memo_U_calc:\n        return _memo_U_calc[n_tuple]\n    \n    if sum(n_tuple) == 0:\n        # The vacuum state is the same in both bases.\n        return {(0, 0, 0): 1.0}\n\n    # For a canonical recursion path, always decrement the last non-zero quantum number.\n    idx_to_decr = -1\n    for i in range(len(n_tuple) - 1, -1, -1):\n        if n_tuple[i] > 0:\n            idx_to_decr = i\n            break\n    \n    prev_n_list = list(n_tuple)\n    prev_n_list[idx_to_decr] -= 1\n    prev_n_tuple = tuple(prev_n_list)\n\n    prev_coeffs = _get_jacobi_expansion(prev_n_tuple)\n    \n    new_coeffs = defaultdict(float)\n    \n    # Coefficients for a_i^\\dagger = sum_k (O^T)_ik b_k^\\dagger\n    a_op_coeffs = _O_T[idx_to_decr]\n\n    for jacobi_state, old_coeff in prev_coeffs.items():\n        # Action of b_rho^dagger\n        state_rho = (jacobi_state[0] + 1, jacobi_state[1], jacobi_state[2])\n        new_coeffs[state_rho] += old_coeff * a_op_coeffs[0] * sqrt(jacobi_state[0] + 1)\n        \n        # Action of b_lambda^dagger\n        state_lambda = (jacobi_state[0], jacobi_state[1] + 1, jacobi_state[2])\n        new_coeffs[state_lambda] += old_coeff * a_op_coeffs[1] * sqrt(jacobi_state[1] + 1)\n\n        # Action of b_cm^dagger\n        state_cm = (jacobi_state[0], jacobi_state[1], jacobi_state[2] + 1)\n        new_coeffs[state_cm] += old_coeff * a_op_coeffs[2] * sqrt(jacobi_state[2] + 1)\n        \n    # Final normalization factor sqrt(n_i) from a_i^dagger |...n_i-1...>\n    norm_factor = sqrt(n_tuple[idx_to_decr])\n    final_coeffs = {state: val / norm_factor for state, val in new_coeffs.items()}\n        \n    _memo_U_calc[n_tuple] = final_coeffs\n    return final_coeffs\n\ndef solve():\n    \"\"\"\n    Main function to execute the verification for all specified test cases.\n    \"\"\"\n    test_cases = [\n        (0, 'particle'),\n        (1, 'particle'),\n        (2, 'particle'),\n        (3, 'Jacobi'),\n        (4, 'Jacobi')\n    ]\n\n    results = []\n\n    for N_tot, basis_type in test_cases:\n        # Generate and order the basis states for a fixed N_tot. This structure\n        # is used for both the particle and Jacobi bases.\n        temp_basis = _generate_basis(N_tot, 3)\n        # The generator produces tuples in (n3,n2,n1) order; reverse and sort for canonical order.\n        basis = sorted([s[::-1] for s in temp_basis])\n        dim = len(basis)\n        state_map = {state: i for i, state in enumerate(basis)}\n\n        # Construct the antisymmetrizer matrix A in the particle basis.\n        A = np.zeros((dim, dim), dtype=np.float64)\n        for perm_info in _S3_PERMS:\n            pi_inv = perm_info['pi_inv']\n            sign = perm_info['sign']\n            P = np.zeros((dim, dim), dtype=np.float64)\n            for j, state_j in enumerate(basis):\n                permuted_state = (state_j[pi_inv[0]], state_j[pi_inv[1]], state_j[pi_inv[2]])\n                i = state_map[permuted_state]\n                P[i, j] = 1.0\n            A += sign * P\n        A /= 6.0\n\n        if basis_type == 'particle':\n            # Verify idempotency directly in the particle basis.\n            defect = A @ A - A\n            norm = np.linalg.norm(defect, 'fro')\n            results.append(norm)\n        else: # basis_type == 'Jacobi'\n            global _memo_U_calc\n            _memo_U_calc.clear() # Reset memoization for each new N_tot.\n\n            # Construct the unitary change-of-basis matrix U.\n            U = np.zeros((dim, dim), dtype=np.float64)\n            for j, sp_state in enumerate(basis):\n                expansion = _get_jacobi_expansion(sp_state)\n                for jac_state, coeff in expansion.items():\n                    if jac_state in state_map:\n                        i = state_map[jac_state]\n                        U[i, j] = coeff\n\n            # Transform A to the Jacobi basis.\n            A_jac = U @ A @ U.T\n\n            # Restrict to the N_CM = 0 subspace.\n            ncm0_indices = [i for i, state in enumerate(basis) if state[2] == 0]\n            A_jac_ncm0 = A_jac[np.ix_(ncm0_indices, ncm0_indices)]\n\n            # Verify idempotency in the restricted subspace.\n            defect = A_jac_ncm0 @ A_jac_ncm0 - A_jac_ncm0\n            norm = np.linalg.norm(defect, 'fro')\n            results.append(norm)\n            \n    print(f\"[{','.join([f'{r:.12f}' for r in results])}]\")\n\nsolve()\n```", "id": "3563419"}, {"introduction": "虽然雅可比坐标在理论上有助于分离质心（Center-of-Mass, CM）运动，但实际计算中不可避免的基截断会重新引入非物理的“赝”质心激发。本练习将探索广泛使用的劳森方法（Lawson method），这是一种惩罚这些赝态并恢复系统平移不变性的计算技术。通过这种方式，我们可以确保计算出的可观测量是真正的内禀物理量 [@problem_id:3563429]。", "problem": "考虑一个由两个可区分的、等质量的粒子组成的系统，该系统被限制在一维空间中，并在谐振子（HO）势中运动。在谐振子单位制下进行计算，其中 $\\hbar = 1$，$m = 1$，$\\omega = 1$，因此所有能量和长度都是无量纲的。总的双体实验室坐标系哈密顿量为\n$$\nH_{\\text{tot}} = \\sum_{i=1}^{2} \\left( \\frac{p_i^2}{2} + \\frac{x_i^2}{2} \\right),\n$$\n质心哈密顿量为\n$$\nH_{\\text{cm}} = \\frac{(p_1 + p_2)^2}{4} + \\frac{(x_1 + x_2)^2}{4}.\n$$\n定义内禀哈密顿量为\n$$\nH_{\\text{intr}} = H_{\\text{tot}} - H_{\\text{cm}}.\n$$\n通过一个非负标量 $\\beta$ 参数化的 `Lawson` 项引入\n$$\nH(\\beta) = H_{\\text{intr}} + \\beta \\left( H_{\\text{cm}} - \\frac{1}{2} \\right),\n$$\n该项会移动具有非零质心激发的态，而保持 $0\\hbar\\omega$ 质心部分不发生移动。\n\n你将在一个大小为 $N_{\\text{sp}} + 1$ 的截断单粒子谐振子基中表示算符（单粒子量子数为 $n = 0, 1, \\dots, N_{\\text{sp}}$），并将双体乘积基限制在总量子数 $n_1 + n_2 \\le N_{\\text{cut}}$ 的子空间内。使用标准的谐振子阶梯算符 $a$ 和 $a^\\dagger$ 来构建单粒子位置和动量矩阵，\n$$\nx = \\frac{1}{\\sqrt{2}} \\left( a + a^\\dagger \\right), \\quad p = \\frac{i}{\\sqrt{2}} \\left( a^\\dagger - a \\right),\n$$\n然后通过克罗内克和与积来构造双体算符。定义内禀可观测量\n$$\nO_{\\text{rel}} = (x_1 - x_2)^2,\n$$\n该量仅依赖于相对坐标，因此是一个内禀算符。\n\n使用的基本出发点：\n- 谐振子的正则阶梯算符关系，用 $a$ 和 $a^\\dagger$ 表示的 $x$ 和 $p$ 的定义，以及谐振子单粒子哈密顿量 $h_{\\text{sp}} = \\frac{p^2}{2} + \\frac{x^2}{2}$。\n- 质心坐标 $X_{\\text{cm}} = (x_1 + x_2)/2$ 和动量 $P_{\\text{cm}} = p_1 + p_2$ 的定义，得到 $H_{\\text{cm}} = \\frac{P_{\\text{cm}}^2}{2M} + \\frac{1}{2} M \\omega^2 X_{\\text{cm}}^2$，其中 $M = 2$ 且 $\\omega = 1$，这可以简化为给定的 $H_{\\text{cm}}$ 表达式。\n- 在完整的无限维希尔伯特空间中，内禀可观测量与质心算符对易。这一概念意味着，一旦去除了伪质心激发，内禀可观测量应不受 `Lawson` 参数 $\\beta$ 的影响。\n\n任务：\n- 对于下面测试套件中的每个参数集，以及该集中指定的每个 $\\beta$ 值，在截断的双体空间中对角化 $H(\\beta)$。在所有本征向量中，找出其 $H_{\\text{cm}}$ 期望值最接近 $1/2$ 的态，该态在截断空间中作为 $0\\hbar\\omega$ 质心部分的数值代理。对于所选的态，计算内禀能量 $E_{\\text{intr}} = \\langle H_{\\text{intr}} \\rangle$ 和内禀可观测量的值 $\\langle O_{\\text{rel}} \\rangle$。\n- 对于每个参数集，将 $\\beta = 0$ 时的结果作为基准，并计算该集内其他 $\\beta$ 值下 $E_{\\text{intr}}$ 和 $\\langle O_{\\text{rel}} \\rangle$ 的最大绝对偏差。如果两个最大值都小于或等于容差 $\\varepsilon = 10^{-6}$，则为该参数集返回布尔值 $\\text{True}$；否则，返回 $\\text{False}$。\n\n所有量在谐振子单位制下都是无量纲的。不涉及角度或百分比。\n\n测试套件：\n- 情况 1：$N_{\\text{sp}} = 6$，$N_{\\text{cut}} = 6$，$\\beta \\in \\{ 0.0, 1.0, 10.0, 50.0 \\}$。\n- 情况 2：$N_{\\text{sp}} = 2$，$N_{\\text{cut}} = 2$，$\\beta \\in \\{ 0.0, 2.0, 20.0 \\}$。\n- 情况 3：$N_{\\text{sp}} = 5$，$N_{\\text{cut}} = 3$，$\\beta \\in \\{ 0.0, 100.0 \\}$。\n- 情况 4（仅边界空间）：$N_{\\text{sp}} = 4$，$N_{\\text{cut}} = 0$，$\\beta \\in \\{ 0.0, 20.0, 200.0 \\}$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含每个案例的结果，形式为方括号内以逗号分隔的布尔值列表（例如，$[True,False,True,True]$）。", "solution": "该问题是有效的。它提出了一个适定且有科学依据的计算量子力学练习，具体涉及在截断基中分离多体系统中的质心运动和内禀运动。这是核结构理论中的一个典型问题。其步骤是构造一个特定哈密顿量的矩阵表示，将其对角化，并分析所得基态的性质，以验证所谓的 `Lawson` 方法的有效性。\n\n理论框架是双粒子一维谐振子（HO）。我们在无量纲的谐振子单位制下工作，其中 $\\hbar = m = \\omega = 1$。\n\n**1. 单粒子基和算符**\n\n计算的基础是单粒子谐振子基，它由单粒子哈密顿量 $h_{\\text{sp}} = \\frac{p^2}{2} + \\frac{x^2}{2}$ 的本征态 $|n\\rangle$ 组成。相应的本征值为 $E_n = n + \\frac{1}{2}$，其中 $n = 0, 1, 2, \\dots$。为了计算的可行性，该基被截断到一个有限维度 $N_{\\text{sp}} + 1$，包含 $n=0, 1, \\dots, N_{\\text{sp}}$ 的态 $|n\\rangle$。\n\n在这个基中，基本算符是产生 ($a^\\dagger$) 和湮灭 ($a$) 算符，其矩阵元由下式给出：\n$$\n\\langle n' | a | n \\rangle = \\sqrt{n} \\, \\delta_{n', n-1}\n$$\n$$\n\\langle n' | a^\\dagger | n \\rangle = \\sqrt{n+1} \\, \\delta_{n', n+1}\n$$\n然后根据指定，由这些阶梯算符构造位置 ($x$) 和动量 ($p$) 算符：\n$$\nx = \\frac{1}{\\sqrt{2}} (a + a^\\dagger)\n$$\n$$\np = \\frac{i}{\\sqrt{2}} (a^\\dagger - a)\n$$\n这些定义产生了 $x$ 和 $p$ 的 $(N_{\\text{sp}}+1) \\times (N_{\\text{sp}}+1)$ 矩阵，它们是所有后续双体算符的构建块。\n\n**2. 双体基和算符**\n\n对于一个由两个可区分粒子组成的系统，其基是单粒子空间的张量积。一个基矢表示为 $|n_1\\rangle \\otimes |n_2\\rangle$ 或简写为 $|n_1, n_2\\rangle$。一个只作用于粒子 $i$ 的算符 $O$ 在双体空间中表示为 $O_1 = O \\otimes I$ 和 $O_2 = I \\otimes O$，其中 $I$ 是单粒子空间中的单位矩阵。\n\n问题对双体模型空间施加了一个关键的截断：只保留总量子数 $n_1 + n_2 \\le N_{\\text{cut}}$ 的态 $|n_1, n_2\\rangle$。这定义了进行所有计算的有限维希尔伯特空间。算符必须投影到这个截断的子空间上。实现方法是首先在完整的乘积空间（维度为 $(N_{\\text{sp}}+1)^2$）中构造算符，然后选择与满足 $N_{\\text{cut}}$ 条件的基态相对应的子矩阵。\n\n使用这个方法，我们构造所需双体算符的矩阵表示：\n- **总哈密顿量**：$H_{\\text{tot}} = h_{\\text{sp},1} + h_{\\text{sp},2} = (h_{\\text{sp}} \\otimes I) + (I \\otimes h_{\\text{sp}})$。由于 $h_{\\text{sp}}$ 在 $|n\\rangle$ 基中是对角的，因此 $H_{\\text{tot}}$ 在 $|n_1, n_2\\rangle$ 乘积基中是对角的，其本征值为 $(n_1 + \\frac{1}{2}) + (n_2 + \\frac{1}{2}) = n_1 + n_2 + 1$。\n- **质心哈密顿量**：$H_{\\text{cm}} = \\frac{1}{4}(p_1 + p_2)^2 + \\frac{1}{4}(x_1 + x_2)^2$。这是通过先用克罗内克积形成 $x_1, x_2, p_1, p_2$，然后按指定方式组合它们来构造的。\n- **内禀哈密顿量**：$H_{\\text{intr}} = H_{\\text{tot}} - H_{\\text{cm}}$。这代表了相对坐标中的动力学。\n- **相对可观测量**：$O_{\\text{rel}} = (x_1 - x_2)^2$。\n\n**3. Lawson 方法和态的识别**\n\n在无限维希尔伯特空间中，总哈密顿量可以完美地分离，$H_{\\text{tot}} = H_{\\text{cm}} + H_{\\text{intr}}$，其本征态是内禀本征态和质心本征态的简单乘积。因此，与 $H_{\\text{cm}}$ 对易的内禀可观测量（如 $O_{\\text{rel}}$）的期望值与质心状态无关。\n\n然而，将基截断到 $n_1+n_2 \\le N_{\\text{cut}}$ 会破坏这种可分离性。在截断空间中，$H_{\\text{tot}}$（或 $H_{\\text{intr}}$）的本征态变成了不同质心激发的混合态。这是一个常见的问题，被称为“质心污染”。\n\n`Lawson` 方法旨在缓解这个问题。我们引入修正后的哈密顿量：\n$$\nH(\\beta) = H_{\\text{intr}} + \\beta \\left( H_{\\text{cm}} - E_{\\text{cm},0} \\right)\n$$\n这里，$E_{\\text{cm},0} = \\frac{1}{2}$ 是质心基态的能量（一个质量为 $M=2$、频率为 $\\omega=1$ 的谐振子）。对于一个大的正参数 $\\beta$，该项会对任何不处于质心基态的态增加一个巨大的能量惩罚。因此，对角化 $H(\\beta)$ 会产生一个低能本征态，该态主要由真实的内禀基态构成，而伪质心激发则被抑制。\n\n计算任务是针对不同的 $\\beta$ 值对角化 $H(\\beta)$ 的矩阵。所期望的“物理”态被识别为那个本征向量 $|\\psi\\rangle$，其期望值 $\\langle\\psi|H_{\\text{cm}}|\\psi\\rangle$ 最接近目标质心基态能量 $\\frac{1}{2}$。\n\n**4. 计算与验证**\n\n对于已识别的态 $|\\psi\\rangle$，我们计算内禀能量的期望值 $E_{\\text{intr}} = \\langle\\psi|H_{\\text{intr}}|\\psi\\rangle$ 和内禀可观测量的期望值 $\\langle O_{\\text{rel}} \\rangle = \\langle\\psi|O_{\\text{rel}}|\\psi\\rangle$。\n\n中心假设是，随着 $\\beta$ 的增加，这些内禀量应收敛到其真实的、未受污染的值。$\\beta=0$ 的情况代表未经校正的结果。任务要求计算当 $\\beta > 0$ 时，$E_{\\text{intr}}$ 和 $\\langle O_{\\text{rel}} \\rangle$ 相对于 $\\beta=0$ 基准的最大绝对偏差。如果这些偏差低于指定的容差 $\\varepsilon = 10^{-6}$，则证实 `Lawson` 方法对于给定的截断是有效的，并且计算出的内禀性质对于投影参数是稳定的。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main driver function to execute the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'N_sp': 6, 'N_cut': 6, 'betas': [0.0, 1.0, 10.0, 50.0]},\n        # Case 2\n        {'N_sp': 2, 'N_cut': 2, 'betas': [0.0, 2.0, 20.0]},\n        # Case 3\n        {'N_sp': 5, 'N_cut': 3, 'betas': [0.0, 100.0]},\n        # Case 4\n        {'N_sp': 4, 'N_cut': 0, 'betas': [0.0, 20.0, 200.0]}\n    ]\n    tolerance = 1e-6\n    final_results = []\n\n    for case in test_cases:\n        N_sp = case['N_sp']\n        N_cut = case['N_cut']\n        betas = case['betas']\n        \n        obs_results = []\n        for beta in betas:\n            # For each beta, calculate the intrinsic energy and observable expectation value.\n            E_intr, O_rel_val = calculate_observables(N_sp, N_cut, beta)\n            obs_results.append((E_intr, O_rel_val))\n            \n        # Use beta=0 as the baseline for comparison.\n        baseline_E_intr, baseline_O_rel = obs_results[0]\n        \n        max_dev_E = 0.0\n        max_dev_O = 0.0\n        \n        if len(obs_results) > 1:\n            for E, O in obs_results[1:]:\n                max_dev_E = max(max_dev_E, abs(E - baseline_E_intr))\n                max_dev_O = max(max_dev_O, abs(O - baseline_O_rel))\n        \n        # Check if both deviations are within the specified tolerance.\n        is_stable = (max_dev_E = tolerance) and (max_dev_O = tolerance)\n        final_results.append(is_stable)\n\n    # Format and print the final output as a single-line string.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\ndef calculate_observables(N_sp, N_cut, beta):\n    \"\"\"\n    Constructs and solves the quantum system for a given set of parameters.\n\n    Args:\n        N_sp (int): Maximum single-particle quantum number.\n        N_cut (int): Maximum total quanta for the two-body basis.\n        beta (float): The Lawson parameter.\n\n    Returns:\n        tuple[float, float]: A tuple containing the calculated expectation values\n                             for the intrinsic energy and the relative observable.\n    \"\"\"\n    sp_dim = N_sp + 1\n\n    # 1. Construct single-particle ladder operators, position, and momentum.\n    n_range = np.arange(sp_dim)\n    # Annihilation operator a\n    a_op = np.diag(np.sqrt(n_range[1:]), k=1)\n    # Creation operator a^dagger\n    ad_op = np.diag(np.sqrt(n_range[1:]), k=-1)\n    \n    x_mat = (a_op + ad_op) / np.sqrt(2)\n    p_mat = 1j * (ad_op - a_op) / np.sqrt(2)\n\n    # 2. Build two-body basis and map.\n    basis = []\n    for n1 in range(sp_dim):\n        for n2 in range(sp_dim):\n            if n1 + n2 = N_cut:\n                basis.append((n1, n2))\n    \n    dim = len(basis)\n    if dim == 0:\n        return 0.0, 0.0\n        \n    state_to_idx = {s: i for i, s in enumerate(basis)}\n\n    # 3. Construct two-body operators in the full tensor product space\n    #    and then truncate.\n    I_sp = np.identity(sp_dim)\n    x1_full = np.kron(x_mat, I_sp)\n    x2_full = np.kron(I_sp, x_mat)\n    p1_full = np.kron(p_mat, I_sp)\n    p2_full = np.kron(I_sp, p_mat)\n    \n    # Generate full basis map\n    full_basis = []\n    for n1 in range(sp_dim):\n        for n2 in range(sp_dim):\n            full_basis.append((n1, n2))\n    full_state_to_idx = {s: i for i, s in enumerate(full_basis)}\n    \n    # Get indices for truncation\n    trunc_indices = [full_state_to_idx[s] for s in basis]\n    \n    # Truncate operators\n    x1 = x1_full[np.ix_(trunc_indices, trunc_indices)]\n    x2 = x2_full[np.ix_(trunc_indices, trunc_indices)]\n    p1 = p1_full[np.ix_(trunc_indices, trunc_indices)]\n    p2 = p2_full[np.ix_(trunc_indices, trunc_indices)]\n\n    # 4. Construct Hamiltonian components.\n    h_sp_mat = (p_mat @ p_mat + x_mat @ x_mat) / 2\n    H_tot = np.zeros((dim, dim), dtype=np.complex128)\n    for i, (n1, n2) in enumerate(basis):\n        H_tot[i, i] = h_sp_mat[n1, n1] + h_sp_mat[n2, n2]\n\n    H_cm = 0.25 * ((p1 + p2) @ (p1 + p2) + (x1 + x2) @ (x1 + x2))\n    H_intr = H_tot - H_cm\n    \n    O_rel = (x1 - x2) @ (x1 - x2)\n    \n    # 5. Construct and diagonalize Lawson Hamiltonian.\n    H_beta = H_intr + beta * (H_cm - 0.5 * np.identity(dim))\n    \n    evals, evecs = np.linalg.eigh(H_beta)\n\n    # 6. Find the state with CM expectation value closest to 0.5.\n    cm_exp_vals = np.einsum('ji,jk,ki->i', evecs.conj(), H_cm, evecs)\n    \n    best_state_idx = np.argmin(np.abs(cm_exp_vals - 0.5))\n    phys_state = evecs[:, best_state_idx]\n\n    # 7. Calculate expectation values for the physical state.\n    E_intr_val = phys_state.conj().T @ H_intr @ phys_state\n    O_rel_val = phys_state.conj().T @ O_rel @ phys_state\n\n    return np.real(E_intr_val), np.real(O_rel_val)\n\nsolve()\n```", "id": "3563429"}, {"introduction": "最后，我们来探讨另一个关键的离散对称性：宇称。本练习将演示如何构建具有确定宇称的基组，以及如何诊断宇称破坏相互作用所带来的影响。在截断的计算基中理解如何控制和分析诸如宇称这样的对称性，对于验证计算的正确性和研究基本物理都至关重要 [@problem_id:3563387]。", "problem": "考虑一个由 $A$ 个相同的、无自旋的核子组成的系统，该系统在一个平移不变的谐振子基中描述，此基底由 Jacobi 相对坐标构建。在每个相对坐标一个空间维度的情况下，独立相对振子的数量为 $d = A - 1$。一个基态由非负整数向量 $\\mathbf{n} = (n_1,\\ldots,n_d)$ 标记，其中 $n_i \\in \\mathbb{N}_0$，总振子量子数为 $N = \\sum_{i=1}^d n_i$。这样一个乘积态的总空间宇称为 $\\pi(\\mathbf{n}) = (-1)^N$。施加一个由 $N \\le N_{\\max}$ 定义的截断。\n\n您将通过对角化一个形式为\n$$\n\\hat{H} = \\hat{H}_0 + \\varepsilon \\hat{V},\n$$\n的哈密顿量来模拟由一个显式破坏宇称的微扰引起的宇称混合，计算在自然单位制中进行，其中 $\\hbar = m = \\omega = 1$（无量纲）。这里 $\\hat{H}_0$ 是 $d$ 个独立的一维谐振子之和，\n$$\n\\hat{H}_0 = \\sum_{i=1}^d \\left(\\hat{a}_i^\\dagger \\hat{a}_i + \\frac{1}{2}\\right),\n$$\n而微扰是坐标算符之和，\n$$\n\\hat{V} = \\sum_{i=1}^d \\hat{x}_i, \\quad \\hat{x}_i = \\frac{1}{\\sqrt{2}}\\left(\\hat{a}_i + \\hat{a}_i^\\dagger\\right),\n$$\n它通过在第 $i$ 个模式中改变一个量子来翻转宇称。一维谐振子代数满足 $[\\hat{a}_i, \\hat{a}_j^\\dagger] = \\delta_{ij}$，在数基中的矩阵元为\n$$\n\\langle n_i' | \\hat{x}_i | n_i \\rangle = \\frac{1}{\\sqrt{2}}\\left(\\sqrt{n_i+1}\\,\\delta_{n_i', n_i+1} + \\sqrt{n_i}\\,\\delta_{n_i', n_i-1}\\right),\n$$\n以及\n$$\n\\langle n_i' | \\hat{H}_{0,i} | n_i \\rangle = \\left(n_i + \\frac{1}{2}\\right)\\delta_{n_i', n_i}.\n$$\n在 $d$ 模式乘积基中，哈密顿矩阵通过张量积结构获得，其中 $\\hat{x}_i$ 仅在第 $i$ 个坐标上非平凡地作用。\n\n定义目标宇称 $\\pi_{\\mathrm{target}} \\in \\{+1,-1\\}$，对应于“偶”（$+1$）或“奇”（$-1$）。在 $N \\le N_{\\max}$ 的截断基中，考虑两种情况：\n\n1. 全宇称基：包含所有 $N \\le N_{\\max}$ 的基态，即包括偶数和奇数 $N$。\n2. 宇称强制基：仅包含那些 $N \\le N_{\\max}$ 且 $\\pi(\\mathbf{n}) = \\pi_{\\mathrm{target}}$ 的基态。\n\n在任一情况下构建哈密顿矩阵后，通过精确对角化获得归一化的基态本征向量 $\\mathbf{c}$。相对于目标宇称的宇称污染定义为 $\\mathbf{c}$ 中相反宇称分量的权重：\n$$\nw_{\\mathrm{opp}} = \\sum_{\\mathbf{n} \\in \\mathcal{B}_{\\mathrm{opp}}} |c(\\mathbf{n})|^2,\n$$\n其中 $\\mathcal{B}_{\\mathrm{opp}}$ 是工作基中宇称为 $-\\pi_{\\mathrm{target}}$ 的基态子集。根据构造，在宇称强制基中 $w_{\\mathrm{opp}} = 0$。\n\n您的任务是编写一个完整的程序，对于下面指定的每个测试用例，在每个相对坐标一维的情况下构建截断的 Jacobi 坐标谐振子基，用指定的 $\\varepsilon$ 构建哈密顿矩阵 $\\hat{H}$，对其进行对角化以找到基态，并计算如上定义的污染 $w_{\\mathrm{opp}}$。始终使用自然单位制 $\\hbar = m = \\omega = 1$（无量纲）。不涉及角度。所有输出必须是实数。\n\n测试套件：\n每个测试用例是一个元组 $(A, N_{\\max}, \\varepsilon, \\text{target\\_parity}, \\text{parity\\_enforced})$，其中 $\\text{target\\_parity}$ 是字符串“even”或“odd”，而 $\\text{parity\\_enforced}$ 是一个布尔值。\n\n- 案例 1（正常路径，精确对称性）：(A=3, N_{\\max}=6, \\varepsilon=0.0, target_parity=\"even\", parity_enforced=False)。\n- 案例 2（小宇称破缺，混合基）：(A=3, N_{\\max}=6, \\varepsilon=0.05, target_parity=\"even\", parity_enforced=False)。\n- 案例 3（小宇称破缺，强制偶宇称）：(A=3, N_{\\max}=6, \\varepsilon=0.05, target_parity=\"even\", parity_enforced=True)。\n- 案例 4（边界截断 $N_{\\max}=0$）：(A=4, N_{\\max}=0, \\varepsilon=1.0, target_parity=\"even\", parity_enforced=False)。\n- 案例 5（诊断奇宇称目标的宇称跟踪）：(A=3, N_{\\max}=6, \\varepsilon=0.05, target_parity=\"odd\", parity_enforced=False)。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个测试用例的污染值 $w_{\\mathrm{opp}}$，形式为方括号内以逗号分隔的列表。将每个值表示为精确到 $10$ 位小数的十进制浮点数（例如，$[0.0000000000,0.0123456789,\\ldots]$）。不应打印任何额外文本。", "solution": "该问题要求我们计算在一个截断的谐振子基中描述的多粒子系统基态中的宇称混合程度。这种混合是由一个破坏宇称的微扰引起的。整个分析在自然单位制中进行，其中 $\\hbar = m = \\omega = 1$。解决方案分四个阶段进行：基的生成、哈密顿矩阵的构建、矩阵对角化以及宇称污染的计算。\n\n**1. 基的构建**\n\n该系统由 $A$ 个相同的、无自旋的核子组成。其相对运动由 $d = A - 1$ 个独立的一维谐振子描述，对应于一组 Jacobi 坐标。在此表示中，一个基态是每个振子的数态的直积，由量子数向量 $\\mathbf{n} = (n_1, n_2, \\ldots, n_d)$ 表示，其中 $n_i \\in \\{0, 1, 2, \\ldots\\}$。在没有微扰的情况下，这样一个态的能量由总振子量子数 $N = \\sum_{i=1}^d n_i$ 决定。该态的空间宇称由 $\\pi(\\mathbf{n}) = (-1)^N$ 给出。\n\n模型空间通过对总量子数施加上限进行截断：$N \\le N_{\\max}$。这定义了一个有限维的基。第一步是枚举所有满足此条件的唯一状态向量 $\\mathbf{n}$。这是一个组合问题，即找到从 $0$ 到 $N_{\\max}$ 的整数划分为 $d$ 个部分的所有方式。递归算法非常适合此任务。从 $d$ 个振子和最多 $N_{\\max}$ 个量子开始，我们可以为第一个振子分配 $k$ 个量子，其中 $k \\in [0, N_{\\max}]$，然后为剩下的 $d-1$ 个振子和最多 $N_{\\max}-k$ 个量子递归地解决问题。\n\n问题指定了两种基的情况：\n1.  **全宇称基**：基包含所有满足 $\\sum_i n_i \\le N_{\\max}$ 的态 $\\mathbf{n}$，无论其宇称如何。\n2.  **宇称强制基**：基被限制为仅包含全宇称集合中同时满足条件 $\\pi(\\mathbf{n}) = \\pi_{\\mathrm{target}}$ 的那些态，其中 $\\pi_{\\mathrm{target}}$ 是指定的宇称（“偶”为 $+1$，“奇”为 $-1$）。\n\n一旦生成了基向量集合 $\\{\\mathbf{n}\\}$，我们建立一个固定的排序，并创建一个从每个状态向量 $\\mathbf{n}$ 到唯一整数索引 $k \\in \\{0, 1, \\ldots, M-1\\}$ 的映射，其中 $M$ 是基中状态的总数。\n\n**2. 哈密顿矩阵的构建**\n\n总哈密顿量为 $\\hat{H} = \\hat{H}_0 + \\varepsilon \\hat{V}$。我们需要在生成的基中计算其矩阵表示 $H_{k'k} = \\langle \\mathbf{n}_{k'} | \\hat{H} | \\mathbf{n}_k \\rangle$。\n\n未受扰动的哈密顿量为 $\\hat{H}_0 = \\sum_{i=1}^d \\hat{H}_{0,i}$，其中 $\\hat{H}_{0,i} = \\hat{a}_i^\\dagger \\hat{a}_i + 1/2$。在数态基中，$\\hat{H}_0$ 是对角的。其矩阵元为：\n$$\n\\langle \\mathbf{n}_{k'} | \\hat{H}_0 | \\mathbf{n}_k \\rangle = \\left( \\sum_{i=1}^d \\left(n_i^{(k)} + \\frac{1}{2}\\right) \\right) \\delta_{k'k} = \\left(N_k + \\frac{d}{2}\\right) \\delta_{k'k}\n$$\n其中 $N_k$ 是态 $\\mathbf{n}_k$ 的总量子数。因此，哈密顿矩阵的对角线元素是未受扰动的能量 $E_k = N_k + d/2$。\n\n破坏宇称的微扰是 $\\hat{V} = \\sum_{i=1}^d \\hat{x}_i$，其中 $\\hat{x}_i = (\\hat{a}_i + \\hat{a}_i^\\dagger) / \\sqrt{2}$。算符 $\\hat{x}_i$ 仅作用于第 $i$ 个自由度，升高或降低一个量子。矩阵元 $\\langle \\mathbf{n}_{k'} | \\hat{V} | \\mathbf{n}_k \\rangle$ 仅在态 $\\mathbf{n}_{k'}$ 与 $\\mathbf{n}_k$ 在单个振子模式上恰好相差一个量子时才非零。\n设 $\\mathbf{n}_k = (n_1, \\ldots, n_i, \\ldots, n_d)$ 和 $\\mathbf{n}_{k'} = (n_1, \\ldots, n_i+1, \\ldots, n_d)$。这两个态之间的 $\\hat{V}$ 的矩阵元是：\n$$\n\\langle \\mathbf{n}_{k'} | \\hat{V} | \\mathbf{n}_k \\rangle = \\langle n_i+1 | \\hat{x}_i | n_i \\rangle = \\frac{1}{\\sqrt{2}}\\sqrt{n_i+1}\n$$\n由于 $\\hat{V}$ 是厄米（Hermitian）的，我们也有 $\\langle \\mathbf{n}_k | \\hat{V} | \\mathbf{n}_{k'} \\rangle = \\langle \\mathbf{n}_{k'} | \\hat{V} | \\mathbf{n}_k \\rangle$。\n\n构建完整哈密顿矩阵 $H$ 的算法如下：\n- 初始化一个 $M \\times M$ 的零矩阵。\n- 对于每个基态 $\\mathbf{n}_k$（索引为 $k$）：\n    - 设置对角元素 $H_{kk} = N_k + d/2$。\n    - 对于每个振子模式 $i \\in \\{1, \\ldots, d\\}$：\n        - 通过增加量子数形成一个新的状态向量 $\\mathbf{n'}$：$n'_j = n_j^{(k)} + \\delta_{ij}$。\n        - 如果 $\\mathbf{n'}$ 存在于我们的基集合中（即其总量子数 $\\sum_j n'_j \\le N_{\\max}$ 并且满足任何宇称强制条件），找到其索引 $k'$。\n        - 计算非对角元素 $V_{k'k} = \\frac{1}{\\sqrt{2}}\\sqrt{n_i^{(k)}+1}$。\n        - 将其贡献加到总哈密顿矩阵中：$H_{k'k} = H_{k'k} + \\varepsilon V_{k'k}$ 和 $H_{kk'} = H_{kk'} + \\varepsilon V_{k'k}$。\n\n得到的矩阵 $H$ 是实对称的。\n\n**3. 对角化与基态识别**\n\n我们求解矩阵本征值问题 $H\\mathbf{c} = E\\mathbf{c}$ 来找到本征值（能量）和本征向量（状态构成）。由于 $H$ 是实对称的，其本征值是实数，其本征向量构成一个标准正交基。我们使用一个标准的数值库函数，例如 `scipy.linalg.eigh`，它对此类矩阵进行了优化。此函数按升序返回本征值。最低的本征值是基态能量，其对应的本征向量是基态向量 $\\mathbf{c}$。该向量的每个分量 $c_k$ 是基态波函数中基态 $|\\mathbf{n}_k\\rangle$ 的振幅。\n\n**4. 宇称污染计算**\n\n最后一步是量化所获得的基态本征向量 $\\mathbf{c}$ 中的宇称混合。目标宇称 $\\pi_{\\mathrm{target}}$ 是给定的。“相反”宇称是 $-\\pi_{\\mathrm{target}}$。宇称污染 $w_{\\mathrm{opp}}$ 定义为在该相反宇称的态中找到系统的总概率。这通过对所有具有相反宇称的基态的振幅平方模进行求和来计算：\n$$\nw_{\\mathrm{opp}} = \\sum_{k \\text{ s.t. } \\pi(\\mathbf{n}_k) = -\\pi_{\\mathrm{target}}} |c_k|^2\n$$\n每个基态 $\\mathbf{n}_k$ 的宇称由其总量子数 $N_k$ 决定：$\\pi(\\mathbf{n}_k) = (-1)^{N_k}$。该算法遍历基态本征向量 $\\mathbf{c}$ 的分量，检查相应基态 $|\\mathbf{n}_k\\rangle$ 的宇称，如果宇称与 $\\pi_{\\mathrm{target}}$ 相反，则将 $|c_k|^2$ 加入总和。\n\n在宇称强制基的特殊情况下，根据构造，具有相反宇称的基态集合是空的。因此，对 $w_{\\mathrm{opp}}$ 的求和是在一个空集上进行的，结果必须为 $0$。我们的一般计算正确地简化到了这个极限。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef calculate_contamination(A, N_max, epsilon, target_parity_str, parity_enforced):\n    \"\"\"\n    Calculates the parity contamination of the ground state.\n\n    Args:\n        A (int): Number of nucleons.\n        N_max (int): Maximum total oscillator quanta.\n        epsilon (float): Strength of the parity-violating perturbation.\n        target_parity_str (str): \"even\" or \"odd\".\n        parity_enforced (bool): If True, only basis states with target_parity are included.\n\n    Returns:\n        float: The calculated parity contamination w_opp.\n    \"\"\"\n    d = A - 1\n    if d == 0:\n        # Trivial case: A=1 means d=0, no relative coordinates. The only state is n=() with N=0.\n        # It's an even parity state.\n        if target_parity_str == \"even\":\n            return 0.0 # No opposite parity states exist.\n        else:\n            return 1.0 # The only state has the opposite parity of \"odd\".\n\n    target_parity_val = 1 if target_parity_str == \"even\" else -1\n\n    # Step 1: Generate basis states\n    basis_states = []\n    \n    def generate_states_recursive(dim_idx, current_quanta, current_state):\n        if dim_idx == d - 1:\n            # Last oscillator\n            remaining_quanta_max = N_max - current_quanta\n            for n_last in range(remaining_quanta_max + 1):\n                state = current_state + (n_last,)\n                total_quanta = current_quanta + n_last\n                \n                # Apply parity enforcement filter if needed\n                parity = 1 if total_quanta % 2 == 0 else -1\n                if not parity_enforced or parity == target_parity_val:\n                    basis_states.append(state)\n        else:\n            remaining_quanta_max = N_max - current_quanta\n            for n_curr in range(remaining_quanta_max + 1):\n                generate_states_recursive(\n                    dim_idx + 1,\n                    current_quanta + n_curr,\n                    current_state + (n_curr,)\n                )\n\n    generate_states_recursive(0, 0, ())\n\n    if not basis_states:\n        return 0.0\n\n    # Create mappings for quick lookups\n    state_to_idx = {state: i for i, state in enumerate(basis_states)}\n    M = len(basis_states)\n\n    # Step 2: Construct Hamiltonian matrix\n    H = np.zeros((M, M), dtype=np.float64)\n\n    for idx, state in enumerate(basis_states):\n        # Diagonal part (H_0)\n        N_k = sum(state)\n        H[idx, idx] = N_k + d / 2.0\n\n        # Off-diagonal part (V)\n        if epsilon != 0.0:\n            for i in range(d):\n                # Raising operator part: a_i^\\dagger\n                # State |k> -> State |k'> by n_i -> n_i + 1\n                new_state_list = list(state)\n                new_state_list[i] += 1\n                new_state = tuple(new_state_list)\n\n                if sum(new_state) = N_max and new_state in state_to_idx:\n                    other_idx = state_to_idx[new_state]\n                    # Matrix element for x_i is sqrt((n_i+1)/2)\n                    me = np.sqrt((state[i] + 1) / 2.0)\n                    H[idx, other_idx] += epsilon * me\n                    H[other_idx, idx] += epsilon * me\n    \n    # Step 3: Diagonalize and find ground state eigenvector\n    if M == 0:\n        return 0.0\n    if M == 1:\n        # Trivial diagonalization\n        eigenvector_gs = np.array([1.0])\n    else:\n        # For real symmetric matrices, eigh is preferred.\n        # It returns eigenvalues in ascending order.\n        eigenvalues, eigenvectors = linalg.eigh(H)\n        eigenvector_gs = eigenvectors[:, 0]\n\n    # Step 4: Calculate parity contamination\n    w_opp = 0.0\n    for idx, state in enumerate(basis_states):\n        N_k = sum(state)\n        parity = 1 if N_k % 2 == 0 else -1\n        if parity == -target_parity_val:\n            w_opp += eigenvector_gs[idx]**2\n\n    return w_opp\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (A, N_max, epsilon, target_parity, parity_enforced)\n        (3, 6, 0.0, \"even\", False),\n        (3, 6, 0.05, \"even\", False),\n        (3, 6, 0.05, \"even\", True),\n        (4, 0, 1.0, \"even\", False),\n        (3, 6, 0.05, \"odd\", False)\n    ]\n\n    results = []\n    for case in test_cases:\n        w_opp = calculate_contamination(*case)\n        results.append(f\"{w_opp:.10f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3563387"}]}