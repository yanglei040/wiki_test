{"hands_on_practices": [{"introduction": "为了从实践上掌握介质内相似性重整化群（IM-SRG）方法，最有效的第一步是构建并求解一个简化的“玩具模型”。这个练习将引导您在一个包含单粒子-单空穴（$1p1h$）和双粒子-双空穴（$2p2h$）激发的有限维空间中，实现IM-SRG的核心流方程。通过这个练习，您将具体地理解相似性变换如何通过连续演化将哈密顿量对角化，这是IM-SRG方法的基础。[@problem_id:3564791]", "problem": "你需要构建并分析一个有限维、块结构的玩具哈密顿量，该哈密顿量在一个介质内表述中，相对于一个固定的参考斯莱特行列式，表示单粒子-单空穴 ($1p1h$) 和双粒子-双空穴 ($2p2h$) 的激发扇区。此问题的基本原理如下：\n\n- 一个由幺正算符 $U(s)$ 作用于哈密顿量 $H(0)$ 生成的相似性变换定义为 $H(s) = U(s)\\,H(0)\\,U^{\\dagger}(s)$，其中 $s$ 是一个实数、无量纲的流参数，$U^{\\dagger}(s)$ 是 $U(s)$ 的厄米共轭。\n- 一个可微的幺正算符 $U(s)$ 满足 $U^{\\dagger}(s)\\,U(s) = I$，其生成元 $\\eta(s)$ 可通过 $\\frac{dU(s)}{ds} = \\eta(s)U(s)$ 定义，且有 $\\eta^{\\dagger}(s) = -\\eta(s)$（反厄米）。\n- 哈密顿量 $H(s)$ 的流方程为 $\\frac{dH(s)}{ds} = [\\eta(s),\\,H(s)]$，其中 $[A,\\,B] = A\\,B - B\\,A$ 表示对易子。\n\n从这些原理出发，为一个玩具哈密顿量推导并实现一个介质内相似性重整化群截断至二体算符（IM-SRG(2)）的计算演示。哈密顿量 $H(s)$ 以对应于两个激发扇区的块矩阵形式表示：\n$$\nH(s) =\n\\begin{pmatrix}\nH_{11}(s)  H_{12}(s) \\\\\nH_{21}(s)  H_{22}(s)\n\\end{pmatrix},\n$$\n其中 $H_{11}(s)$ 作用于维度为 $n_1$ 的 $1p1h$ 扇区内，$H_{22}(s)$ 作用于维度为 $n_2$ 的 $2p2h$ 扇区内，$H_{12}(s)$ 及其厄米转置 $H_{21}(s) = H_{12}^{\\dagger}(s)$ 耦合这两个扇区。这些扇区是相对于一个固定的、归一化的参考斯莱特行列式定义的，并且正规序是相对于此参考系来理解的。IM-SRG(2) 截断通过在这些扇区内工作以及通过有限矩阵模型的构造省略高于二体的导出算符来体现。\n\n你的任务是：\n1. 使用具有指定能量的对角块 $H_{11}(0)$ 和 $H_{22}(0)$，以及指定的实数值非对角耦合 $H_{12}(0)$ 来设计初始哈密顿量 $H(0)$。假设 $H(0)$ 是厄米的。块对角元表示限制在各自扇区内的正规序零体、单体和二体贡献。单位是任意能量单位，流参数 $s$ 是无量纲的。\n2. 从所述基本原理出发，通过要求反厄米性并使用从对角块推断出的瞬时能量分母，推导在 IM-SRG(2) 截断下，当 $s \\to \\infty$ 时能将非对角块 $H_{12}(s)$ 驱动至零的合适的 White 生成元。通过一个不破坏反厄米性的调节项来解决潜在的简并问题。\n3. 数值上实现流方程 $\\frac{dH(s)}{ds} = [\\eta(s),\\,H(s)]$，并通过积分到一个足够大的最终流参数 $s_{\\text{end}}$ 并计算弗罗贝尼乌斯范数 $\\|H_{12}(s_{\\text{end}})\\|_{\\mathrm{F}}$，来演示当 $s \\to \\infty$ 时非对角块的解耦。\n4. 使用以下初始哈密顿量规格的测试套件（每个案例定义了 $n_1$、$n_2$、对角能量、非对角耦合、正则化参数和最终流参数）：\n   - 案例 1（理想路径）：$n_1 = 2$，$n_2 = 2$。$H_{11}(0)$ 中的对角能量为 $[\\,0.5,\\,0.9\\,]$，$H_{22}(0)$ 中的对角能量为 $[\\,1.4,\\,2.1\\,]$。非对角块 $H_{12}(0)$ 是\n     $$\n     \\begin{pmatrix}\n     0.2  -0.1 \\\\\n     0.05  0.3\n     \\end{pmatrix}.\n     $$\n     使用调节项 $\\delta = 10^{-3}$ 和最终流参数 $s_{\\text{end}} = 40$。\n   - 案例 2（近简并）：$n_1 = 1$，$n_2 = 1$。对角能量 $H_{11}(0) = [\\,1.0\\,]$，$H_{22}(0) = [\\,1.0001\\,]$，以及 $H_{12}(0) = [\\,0.05\\,]$（一个 $1\\times 1$ 的块）。使用调节项 $\\delta = 10^{-4}$ 和最终流参数 $s_{\\text{end}} = 80$。\n   - 案例 3（零耦合边界）：$n_1 = 3$，$n_2 = 2$。$H_{11}(0)$ 中的对角能量为 $[\\,0.3,\\,0.7,\\,1.1\\,]$，$H_{22}(0)$ 中的对角能量为 $[\\,1.6,\\,2.5\\,]$。非对角块 $H_{12}(0)$ 是 $3\\times 2$ 的零矩阵。使用调节项 $\\delta = 10^{-3}$ 和最终流参数 $s_{\\text{end}} = 20$。\n\n你的程序必须：\n- 从指定的块构建每个初始 $H(0)$。\n- 对每种情况，使用一种在数值容差范围内保持厄米性的刚性、稳定的方法，对流方程 $\\frac{dH}{ds}(s) = [\\eta(H),\\,H]$ 从 $s = 0$ 积分到 $s = s_{\\text{end}}$。\n- 在 $s = s_{\\text{end}}$ 时，计算每种情况的弗罗贝尼乌斯范数 $\\|H_{12}(s_{\\text{end}})\\|_{\\mathrm{F}}$。\n- 生成单行输出，其中包含三个结果，形式为方括号内由逗号分隔的列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是表示为浮点数的弗罗贝尼乌斯范数。无需单位，因为 $s$ 是无量纲的，且玩具能量使用任意单位。\n\n最终程序必须是完整的，无需任何用户输入即可运行，并且必须遵守指定的执行环境。输出应为浮点数，捕捉每种测试情况下非对角解耦的量级。", "solution": "我们从幺正相似性变换的原理出发。设 $U(s)$ 是一个由实数、无量纲流参数 $s$ 参数化的幺正算符，作用于初始哈密顿量 $H(0)$。定义 $H(s) = U(s)\\,H(0)\\,U^{\\dagger}(s)$，且有 $U^{\\dagger}(s)\\,U(s) = I$。如果我们通过 $\\frac{dU(s)}{ds} = \\eta(s)U(s)$ 定义生成元 $\\eta(s)$，则幺正性条件意味着 $\\eta^{\\dagger}(s) = -\\eta(s)$，即 $\\eta(s)$ 是反厄米的。通过对 $H(s)$ 求导，并使用乘法法则和 $\\eta(s)$ 的定义，我们得到\n$$\n\\frac{dH(s)}{ds} = \\frac{dU(s)}{ds}\\,H(0)\\,U^{\\dagger}(s) + U(s)\\,H(0)\\,\\frac{dU^{\\dagger}(s)}{ds}.\n$$\n使用 $\\frac{dU(s)}{ds} = \\eta(s)U(s)$ 和 $\\frac{dU^{\\dagger}(s)}{ds} = U^{\\dagger}(s)\\eta^{\\dagger}(s)$，并代入 $H(s) = U(s)H(0)U^{\\dagger}(s)$，我们得到\n$$\n\\frac{dH(s)}{ds} = \\eta(s)H(s) + H(s)\\eta^{\\dagger}(s) = [\\eta(s), H(s)],\n$$\n因为 $\\eta^{\\dagger}(s) = -\\eta(s)$。这就是构成相似性重整化群基础的流方程。\n\n在介质内设定中，正规序是相对于一个固定的参考斯莱特行列式进行的。在二体水平截断的介质内相似性重整化群 (IM-SRG(2)) 保留了正规序的零体、单体和二体贡献，同时丢弃了更高阶的导出项。一种演示解耦的常见算法途径是，将算符表示限制在一个跨越选定激发扇区的有限块矩阵上；在我们的玩具模型中，我们考虑两个扇区：维度为 $n_1$ 的单粒子-单空穴 ($1p1h$) 扇区和维度为 $n_2$ 的双粒子-双空穴 ($2p2h$) 扇区。哈密顿量随后表示为\n$$\nH(s) =\n\\begin{pmatrix}\nH_{11}(s)  H_{12}(s) \\\\\nH_{21}(s)  H_{22}(s)\n\\end{pmatrix},\n$$\n为确保厄米性，有 $H_{21}(s) = H_{12}^{\\dagger}(s)$。\n\n为了推导一个驱动解耦的 White 生成元，我们从两个要求开始：\n- $\\eta(s)$ 必须是反厄米的，即 $\\eta^{\\dagger}(s) = -\\eta(s)$。\n- 生成元的构造必须使得随着 $s$ 的增加，非对角块 $H_{12}(s)$ 受到抑制。\n\n考虑瞬时对角块 $H_{11}(s)$ 和 $H_{22}(s)$，并将其对角元定义为能量向量 $\\mathbf{e}_1(s) = \\mathrm{diag}\\left(H_{11}(s)\\right)$ 和 $\\mathbf{e}_2(s) = \\mathrm{diag}\\left(H_{22}(s)\\right)$。对于每一对 $(i,\\alpha)$，其中 $i \\in \\{1,\\dots,n_1\\}$ 且 $\\alpha \\in \\{1,\\dots,n_2\\}$，定义能量分母\n$$\n\\Delta_{i\\alpha}(s) = e_{2,\\alpha}(s) - e_{1,i}(s).\n$$\n为了处理近简并情况，我们引入一个调节项 $\\delta > 0$ 并定义一个正则化分母\n$$\n\\Delta^{\\mathrm{reg}}_{i\\alpha}(s) = \\mathrm{sign}\\!\\left(\\Delta_{i\\alpha}(s)\\right)\\,\\max\\!\\left(\\left|\\Delta_{i\\alpha}(s)\\right|,\\,\\delta\\right),\n$$\n这在一致使用时能保持符号结构并避免除以零，同时保持反厄米性。非对角块 $H_{12}(s)$ 是一个元素为 $H_{12}(s)_{i\\alpha}$ 的 $n_1 \\times n_2$ 矩阵。我们将 White 生成元构建为一个块反厄米矩阵\n$$\n\\eta(s) =\n\\begin{pmatrix}\n0  W(s) \\\\\n- W^{\\dagger}(s)  0\n\\end{pmatrix},\n\\quad\nW(s)_{i\\alpha} = -\\frac{H_{12}(s)_{i\\alpha}}{\\Delta^{\\mathrm{reg}}_{i\\alpha}(s)}.\n$$\n选择负号是为了在最简单的 $2\\times 2$ 情况下，即 $H(s) = \\begin{pmatrix} e_1(s)  v(s) \\\\ v(s)  e_2(s) \\end{pmatrix}$，非对角元的流满足\n$$\n\\frac{dv}{ds}(s) = \\left[e_2(s) - e_1(s)\\right]\\,\\eta_{12}(s) = \\Delta(s)\\,\\left(-\\frac{v(s)}{\\Delta^{\\mathrm{reg}}(s)}\\right) \\approx -v(s)\n$$\n只要 $\\Delta^{\\mathrm{reg}}(s)$ 接近 $\\Delta(s)$（即远离简并）或在近简并时等于 $\\delta\\,\\mathrm{sign}(\\Delta)$，从而确保 $v(s)$ 随 $s$ 指数级抑制。这表明，在 IM-SRG 流下，当 $s \\to \\infty$ 时 $H_{12}(s)$ 被驱动至零，因此扇区解耦。一般的块情况逐元素地继承了这种行为，但会受到所有矩阵元素之间对易代数的修正。\n\n在数值上，我们对常微分方程\n$$\n\\frac{dH}{ds}(s) = [\\,\\eta(H(s)),\\,H(s)\\,]\n$$\n进行积分，其中 $\\eta(H)$ 如上所述。因为流可能是刚性的——尤其是在能量分离大或耦合强的情况下——我们使用具有严格容差的刚性求解器，以在数值精度内保持厄米性。在每一步中，我们：\n- 将状态向量重塑为矩阵 $H(s)$。\n- 提取 $H_{11}(s)$、$H_{22}(s)$ 和 $H_{12}(s)$。\n- 计算瞬时对角线 $\\mathbf{e}_1(s)$ 和 $\\mathbf{e}_2(s)$。\n- 逐元素地构建正则化分母 $\\Delta^{\\mathrm{reg}}_{i\\alpha}(s)$。\n- 构建 $W(s)$，从而得到反厄米矩阵 $\\eta(s)$。\n- 计算对易子 $[\\,\\eta(s),\\,H(s)\\,]$。\n\n然后我们积分到最终的 $s_{\\text{end}}$。在 $s = s_{\\text{end}}$ 时，我们计算弗罗贝尼乌斯范数\n$$\n\\|H_{12}(s_{\\text{end}})\\|_{\\mathrm{F}} = \\sqrt{\\sum_{i=1}^{n_1} \\sum_{\\alpha=1}^{n_2} \\left|H_{12}(s_{\\text{end}})_{i\\alpha}\\right|^2},\n$$\n该范数量化了扇区之间的残余耦合。对于指定的测试套件：\n- 案例 1 使用 $n_1 = 2$，$n_2 = 2$，$H_{11}(0)$ 的对角元为 $[\\,0.5,\\,0.9\\,]$，$H_{22}(0)$ 的对角元为 $[\\,1.4,\\,2.1\\,]$，$H_{12}(0)$ 为\n  $$\n  \\begin{pmatrix}\n  0.2  -0.1 \\\\\n  0.05  0.3\n  \\end{pmatrix},\n  $$\n  调节项 $\\delta = 10^{-3}$，以及 $s_{\\text{end}} = 40$。\n- 案例 2 使用 $n_1 = 1$，$n_2 = 1$，对角元为 $[\\,1.0\\,]$ 和 $[\\,1.0001\\,]$，$H_{12}(0) = [\\,0.05\\,]$，$\\delta = 10^{-4}$，以及 $s_{\\text{end}} = 80$。\n- 案例 3 使用 $n_1 = 3$，$n_2 = 2$，对角元为 $[\\,0.3,\\,0.7,\\,1.1\\,]$ 和 $[\\,1.6,\\,2.5\\,]$，$H_{12}(0)$ 为零矩阵，$\\delta = 10^{-3}$，以及 $s_{\\text{end}} = 20$。\n\n我们预期，在案例 1 和 2 中，由于成功解耦，弗罗贝尼乌斯范数 $\\|H_{12}(s_{\\text{end}})\\|_{\\mathrm{F}}$ 会非常小（案例 2 由于近简并可能解耦较慢，但由于 $\\delta$ 仍会受到抑制），而在案例 3 中，由于构造上不存在耦合且流使零非对角块保持不变，范数将精确为零。\n\n程序将实现此逻辑，使用刚性求解器对每种情况积分流方程，并打印单行 $[r_1,r_2,r_3]$，其中 $r_i$ 分别是案例 1、2 和 3 的弗罗贝尼乌斯范数，以浮点数表示。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef white_generator_eta(H, n1, n2, delta):\n    \"\"\"\n    Construct the anti-Hermitian White generator eta for a block Hamiltonian H.\n    Blocks:\n      H11: top-left (n1 x n1)\n      H12: top-right (n1 x n2)\n      H21: bottom-left (n2 x n1)\n      H22: bottom-right (n2 x n2)\n    White generator (real case):\n      eta = [[0, W], [-W^T, 0]]\n    with W_ij = - H12_ij / Delta_reg_ij, Delta_reg_ij = sign(Delta_ij) * max(|Delta_ij|, delta),\n    and Delta_ij = e2_j - e1_i using instantaneous diagonals e1, e2.\n    \"\"\"\n    # Extract blocks\n    H11 = H[:n1, :n1]\n    H12 = H[:n1, n1:]\n    H22 = H[n1:, n1:]\n\n    # Instantaneous diagonals\n    e1 = np.diag(H11)\n    e2 = np.diag(H22)\n\n    # Build denominators for each element of H12: Delta_{i,alpha} = e2_alpha - e1_i\n    # Shape: (n1, n2)\n    Delta = e2[np.newaxis, :] - e1[:, np.newaxis]\n    # Regularize denominators to avoid division by zero\n    sign = np.sign(Delta)\n    # For exactly zero, set sign to +1 to preserve anti-Hermitian structure\n    sign[sign == 0.0] = 1.0\n    Delta_reg = sign * np.maximum(np.abs(Delta), delta)\n\n    # Construct W with element-wise division\n    W = - H12 / Delta_reg\n\n    # Assemble eta\n    eta = np.zeros_like(H)\n    eta[:n1, n1:] = W\n    eta[n1:, :n1] = -W.T  # real case; for complex, use -W.conj().T\n\n    return eta\n\ndef imsrg_flow_rhs(s, y, n1, n2, delta):\n    \"\"\"\n    Right-hand side of the IM-SRG flow: dH/ds = [eta(H), H].\n    y is the flattened H matrix.\n    \"\"\"\n    dim = n1 + n2\n    H = y.reshape((dim, dim))\n\n    # Construct White generator\n    eta = white_generator_eta(H, n1, n2, delta)\n\n    # Compute commutator\n    dHds = eta @ H - H @ eta\n\n    return dHds.reshape(-1)\n\ndef integrate_flow(n1, n2, H11_diag, H22_diag, H12_init, s_end, delta):\n    \"\"\"\n    Integrate the IM-SRG flow for the specified toy Hamiltonian.\n    Returns the Frobenius norm of the off-diagonal block H12 at s_end.\n    \"\"\"\n    # Build initial H(0)\n    H11 = np.diag(np.array(H11_diag, dtype=float))\n    H22 = np.diag(np.array(H22_diag, dtype=float))\n    H12 = np.array(H12_init, dtype=float)\n\n    # Validate dimensions\n    assert H11.shape == (n1, n1)\n    assert H22.shape == (n2, n2)\n    assert H12.shape == (n1, n2)\n\n    # Assemble full H\n    dim = n1 + n2\n    H0 = np.zeros((dim, dim), dtype=float)\n    H0[:n1, :n1] = H11\n    H0[n1:, n1:] = H22\n    H0[:n1, n1:] = H12\n    H0[n1:, :n1] = H12.T\n\n    # Flatten\n    y0 = H0.reshape(-1)\n\n    # Integrate using a stiff solver\n    sol = solve_ivp(\n        fun=lambda s, y: imsrg_flow_rhs(s, y, n1, n2, delta),\n        t_span=(0.0, s_end),\n        y0=y0,\n        method='BDF',\n        rtol=1e-9,\n        atol=1e-12,\n        max_step=np.inf,\n    )\n\n    # Retrieve final H and re-symmetrize to mitigate numerical drift\n    Hf = sol.y[:, -1].reshape((dim, dim))\n    Hf = 0.5 * (Hf + Hf.T)  # enforce Hermiticity in real case\n\n    # Extract final off-diagonal block H12\n    H12_f = Hf[:n1, n1:]\n\n    # Frobenius norm\n    frob = np.linalg.norm(H12_f, ord='fro')\n    return frob\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: n1=2, n2=2\n        {\n            \"n1\": 2,\n            \"n2\": 2,\n            \"H11_diag\": [0.5, 0.9],\n            \"H22_diag\": [1.4, 2.1],\n            \"H12_init\": [[0.2, -0.1],\n                         [0.05, 0.3]],\n            \"s_end\": 40.0,\n            \"delta\": 1e-3,\n        },\n        # Case 2: near degeneracy, n1=1, n2=1\n        {\n            \"n1\": 1,\n            \"n2\": 1,\n            \"H11_diag\": [1.0],\n            \"H22_diag\": [1.0001],\n            \"H12_init\": [[0.05]],\n            \"s_end\": 80.0,\n            \"delta\": 1e-4,\n        },\n        # Case 3: zero coupling boundary, n1=3, n2=2\n        {\n            \"n1\": 3,\n            \"n2\": 2,\n            \"H11_diag\": [0.3, 0.7, 1.1],\n            \"H22_diag\": [1.6, 2.5],\n            \"H12_init\": [[0.0, 0.0],\n                         [0.0, 0.0],\n                         [0.0, 0.0]],\n            \"s_end\": 20.0,\n            \"delta\": 1e-3,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        frob = integrate_flow(\n            n1=case[\"n1\"],\n            n2=case[\"n2\"],\n            H11_diag=case[\"H11_diag\"],\n            H22_diag=case[\"H22_diag\"],\n            H12_init=case[\"H12_init\"],\n            s_end=case[\"s_end\"],\n            delta=case[\"delta\"],\n        )\n        # Append float result; format with full precision of Python's default str\n        results.append(frob)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3564791"}, {"introduction": "在掌握了IM-SRG的基本流程之后，一个关键的进阶问题是评估截断所带来的误差，因为实际计算几乎总是需要在某个算符阶数上进行截断。这个练习通过一个包含零、二和三粒子-三空穴组态的简化模型，让您亲手估算忽略三体项（即从IM-SRG(3)截断至IM-SRG(2)）所导致的能量误差。通过比较不同截断水平下的计算结果，您可以直观地理解截断近似的物理后果以及其对计算精度的影响。[@problem_id:3564801]", "problem": "考虑一个闭壳参考斯莱特行列式 $|\\Phi\\rangle$，它由 $A$ 个无相互作用的费米子在有限单粒子基中占据能量最低的单粒子轨道构成。在介质内相似性重整化群（In-Medium Similarity Renormalization Group, IM-SRG）方法中，我们从相对于 $|\\Phi\\rangle$ 正则排序的二次量子化哈密顿量开始，\n$$\n\\hat{H} \\equiv E_0 + \\sum_{ij} f_{ij} \\{ a_i^\\dagger a_j \\} + \\frac{1}{4} \\sum_{ijkl} \\Gamma_{ijkl} \\{ a_i^\\dagger a_j^\\dagger a_l a_k \\} + \\frac{1}{36} \\sum_{ijklmn} W_{ijklmn} \\{ a_i^\\dagger a_j^\\dagger a_k^\\dagger a_n a_m a_l \\},\n$$\n其中花括号表示相对于 $|\\Phi\\rangle$ 的正则序，$E_0$ 是零体（标量）贡献，$f_{ij}$ 是单体张量，$\\Gamma_{ijkl}$ 是正则序双体张量，$W_{ijklmn}$ 是剩余正则序三体张量。IM-SRG(2) 截断保留 $E_0$、$f$ 和 $\\Gamma$，并忽略剩余三体张量 $W$，而 IM-SRG(3) 截断则也保留 $W$。\n\n在一个能够捕捉闭壳系统主要关联的约化模型空间中，考虑由三个多体基矢张成的子空间：参考态 $|\\Phi\\rangle$、一个代表性的双粒子-双空穴激发 $|2p2h\\rangle \\equiv a_{p_1}^\\dagger a_{p_2}^\\dagger a_{h_2} a_{h_1} |\\Phi\\rangle$，以及一个代表性的三粒子-三空穴激发 $|3p3h\\rangle \\equiv a_{p_1}^\\dagger a_{p_2}^\\dagger a_{p_3}^\\dagger a_{h_3} a_{h_2} a_{h_1} |\\Phi\\rangle$，其中 $\\{h_1,h_2,h_3\\}$ 标记 $|\\Phi\\rangle$ 中已占据的空穴轨道，$\\{p_1,p_2,p_3\\}$ 标记未占据的粒子轨道。假设：\n- 对角能量由以下公式近似：\n$$\nE_0 = \\sum_{i \\in \\text{holes}} \\varepsilon_i + E_{\\text{hh}} + E_{\\text{occ}}^{(3)},\n$$\n$$\nE_{2} = E_0 + \\left( \\varepsilon_{p_1} + \\varepsilon_{p_2} - \\varepsilon_{h_1} - \\varepsilon_{h_2} \\right) + \\Delta_{2},\n$$\n$$\nE_{3} = E_0 + \\left( \\varepsilon_{p_1} + \\varepsilon_{p_2} + \\varepsilon_{p_3} - \\varepsilon_{h_1} - \\varepsilon_{h_2} - \\varepsilon_{h_3} \\right) + \\Delta_{3},\n$$\n其中 $\\varepsilon_i$ 是单粒子能量，$E_{\\text{hh}}$ 汇集了空穴间的净双体贡献，$E_{\\text{occ}}^{(3)}$ 汇集了来自已占据空穴间三体相互作用的正则序零体收缩项，而 $\\Delta_{2}$、$\\Delta_{3}$ 分别是相应激发扇区内的对角相互作用移动。\n- 非对角耦合被限制为：\n$$\n\\langle \\Phi | \\hat{H} | 2p2h \\rangle = g_{2}^{\\text{eff}} \\equiv g_{2}^{(0)} + c_{W},\n$$\n$$\n\\langle \\Phi | \\hat{H} | 3p3h \\rangle = g_{3},\n$$\n且此子空间内的所有其他耦合均设为零。这里，$g_{2}^{(0)}$ 是直接双体耦合振幅，$c_{W}$ 是由三体相互作用的正则序导出的有效双体贡献（将 $W$ 的一部分映射到 $\\Gamma$），而 $g_{3}$ 则参数化了在 IM-SRG(2) 中被忽略但在 IM-SRG(3) 中被保留的剩余正则序三体耦合。\n\n在这个三态子空间内，将 IM-SRG(2) 哈密顿矩阵定义为\n$$\nH^{(2)} =\n\\begin{pmatrix}\nE_0  g_{2}^{\\text{eff}} \\\\\ng_{2}^{\\text{eff}}  E_{2}\n\\end{pmatrix},\n$$\n以及将 IM-SRG(3) 哈密顿矩阵定义为\n$$\nH^{(3)} =\n\\begin{pmatrix}\nE_0  g_{2}^{\\text{eff}}  g_{3} \\\\\ng_{2}^{\\text{eff}}  E_{2}  0 \\\\\ng_{3}  0  E_{3}\n\\end{pmatrix}.\n$$\n对 $H^{(2)}$ 和 $H^{(3)}$ 进行对角化，分别得到基态能量 $E_{\\text{gs}}^{(2)}$ 和 $E_{\\text{gs}}^{(3)}$。因为相似性重整化群解耦是幺正的，所以在完全解耦的基中，基态能量等于所选子空间中哈密顿量的最小本征值。因此，因忽略剩余正则序三体项而引入的误差的一个实际估计是\n$$\n\\delta E \\equiv E_{\\text{gs}}^{(2)} - E_{\\text{gs}}^{(3)}.\n$$\n\n你的任务是编写一个程序，对下面给出的每一组参数，构建 $H^{(2)}$ 和 $H^{(3)}$，对它们进行对角化，并以百万电子伏特（MeV）为单位，输出一个四舍五入到六位小数的浮点数 $\\delta E$。\n\n使用以下测试套件（每个案例指定了 $\\{\\varepsilon_{h_1},\\varepsilon_{h_2},\\varepsilon_{h_3}\\}$、$\\{\\varepsilon_{p_1},\\varepsilon_{p_2},\\varepsilon_{p_3}\\}$、$E_{\\text{hh}}$、$E_{\\text{occ}}^{(3)}$、$g_{2}^{(0)}$、$c_{W}$、$g_{3}$、$\\Delta_{2}$、$\\Delta_{3}$），所有能量单位均为 MeV：\n- 案例 1：空穴 $\\{-15.5,-14.2,-13.7\\}$，粒子 $\\{-1.8,0.7,2.2\\}$，$E_{\\text{hh}}=-12.0$，$E_{\\text{occ}}^{(3)}=-1.5$，$g_{2}^{(0)}=-2.0$，$c_{W}=-0.3$，$g_{3}=-0.5$，$\\Delta_{2}=0.9$，$\\Delta_{3}=0.4$。\n- 案例 2：空穴 $\\{-12.0,-11.5,-10.8\\}$，粒子 $\\{-2.0,0.0,1.0\\}$，$E_{\\text{hh}}=-10.0$，$E_{\\text{occ}}^{(3)}=-0.8$，$g_{2}^{(0)}=-1.5$，$c_{W}=-0.2$，$g_{3}=0.0$，$\\Delta_{2}=0.5$，$\\Delta_{3}=0.3$。\n- 案例 3：空穴 $\\{-16.0,-15.2,-14.1\\}$，粒子 $\\{-3.0,-1.0,0.5\\}$，$E_{\\text{hh}}=-13.0$，$E_{\\text{occ}}^{(3)}=-2.2$，$g_{2}^{(0)}=-1.0$，$c_{W}=-0.4$，$g_{3}=-4.0$，$\\Delta_{2}=0.7$，$\\Delta_{3}=0.9$。\n- 案例 4：空穴 $\\{-10.0,-9.5,-9.0\\}$，粒子 $\\{-9.0,-8.8,-8.5\\}$，$E_{\\text{hh}}=-8.0$，$E_{\\text{occ}}^{(3)}=-0.5$，$g_{2}^{(0)}=-3.0$，$c_{W}=-0.5$，$g_{3}=-1.0$，$\\Delta_{2}=-0.2$，$\\Delta_{3}=0.1$。\n\n你的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，例如 $[\\delta E_1,\\delta E_2,\\delta E_3,\\delta E_4]$，其中每个 $\\delta E$ 都四舍五入到六位小数，并以 MeV 表示。", "solution": "该问题已经过审查并被确定是有效的。它在科学上基于量子多体理论的原理，具体而言，是计算核物理中使用的介质内相似性重整化群（IM-SRG）方法。该问题提法明确、自洽，并提供了构建和对角化相关哈密顿矩阵所需的所有必要参数和定义。任务是计算一个特定量 $\\delta E$，它代表了将 IM-SRG 展开在双体水平（IM-SRG(2)）上截断相对于三体水平（IM-SRG(3)）所引入的误差估计。这是物理学中评估理论模型截断误差的标准程序。\n\n针对每个给定的参数集，解决此问题的步骤如下：\n首先，我们构建哈密顿矩阵 $H^{(2)}$ 和 $H^{(3)}$ 的对角和非对角元。\n参考能量 $E_0$ 是已占据空穴态的单粒子能量之和，加上这些空穴间的双体（$E_{\\text{hh}}$）和三体（$E_{\\text{occ}}^{(3)}$）相互作用的贡献。\n$$\nE_0 = \\sum_{i \\in \\text{holes}} \\varepsilon_i + E_{\\text{hh}} + E_{\\text{occ}}^{(3)}\n$$\n双粒子-双空穴（$2p2h$）态的能量 $E_2$ 是参考能量加上产生两个粒子和两个空穴的未受扰激发能，再由一个对角相互作用移动 $\\Delta_2$ 进行修正。\n$$\nE_{2} = E_0 + \\left( \\varepsilon_{p_1} + \\varepsilon_{p_2} - \\varepsilon_{h_1} - \\varepsilon_{h_2} \\right) + \\Delta_{2}\n$$\n类似地，三粒子-三空穴（$3p3h$）态的能量 $E_3$ 由下式给出：\n$$\nE_{3} = E_0 + \\left( \\varepsilon_{p_1} + \\varepsilon_{p_2} + \\varepsilon_{p_3} - \\varepsilon_{h_1} - \\varepsilon_{h_2} - \\varepsilon_{h_3} \\right) + \\Delta_{3}\n$$\n参考态 $|\\Phi\\rangle$ 和 $|2p2h\\rangle$ 态之间的非对角耦合是有效双体矩阵元 $g_{2}^{\\text{eff}}$，它包括裸耦合 $g_{2}^{(0)}$ 和一个由三体力正则序产生的导出项 $c_W$。\n$$\ng_{2}^{\\text{eff}} = g_{2}^{(0)} + c_{W}\n$$\n$|\\Phi\\rangle$ 和 $|3p3h\\rangle$ 态之间的耦合由剩余正则序三体振幅 $g_3$ 给出。\n\n有了这些矩阵元，IM-SRG(2) 哈密顿矩阵在 $\\{|\\Phi\\rangle, |2p2h\\rangle\\}$ 基中构建如下：\n$$\nH^{(2)} =\n\\begin{pmatrix}\nE_0  g_{2}^{\\text{eff}} \\\\\ng_{2}^{\\text{eff}}  E_{2}\n\\end{pmatrix}\n$$\nIM-SRG(3) 哈密顿矩阵在 $\\{|\\Phi\\rangle, |2p2h\\rangle, |3p3h\\rangle\\}$ 基中构建。问题陈述除指定的耦合外，其他耦合均为零，这意味着 $\\langle 2p2h|\\hat{H}|3p3h \\rangle = 0$。\n$$\nH^{(3)} =\n\\begin{pmatrix}\nE_0  g_{2}^{\\text{eff}}  g_{3} \\\\\ng_{2}^{\\text{eff}}  E_{2}  0 \\\\\ng_{3}  0  E_{3}\n\\end{pmatrix}\n$$\n每个截断内的基态能量 $E_{\\text{gs}}^{(2)}$ 和 $E_{\\text{gs}}^{(3)}$ 是各自哈密顿矩阵的最小本征值。对于 $2 \\times 2$ 矩阵 $H^{(2)}$，其本征值由特征方程的解给出：\n$$\n\\lambda_{\\pm}^{(2)} = \\frac{1}{2} \\left( (E_0 + E_2) \\pm \\sqrt{(E_0 - E_2)^2 + 4 (g_{2}^{\\text{eff}})^2} \\right)\n$$\n基态能量是较小的本征值，$E_{\\text{gs}}^{(2)} = \\lambda_{-}^{(2)}$。\n对于 $3 \\times 3$ 矩阵 $H^{(3)}$，其本征值是三次特征多项式的根。最直接的方法是数值求解。由于 $H^{(2)}$ 和 $H^{(3)}$ 是实对称（厄米）的，它们的本征值是实数。我们寻求最小本征值 $E_{\\text{gs}}^{(3)}$。\n最后，由于忽略剩余三体项而产生的估计误差计算如下：\n$$\n\\delta E = E_{\\text{gs}}^{(2)} - E_{\\text{gs}}^{(3)}\n$$\n对提供的四个参数集中的每一个都执行此计算。然后将结果四舍五入到六位小数，并以要求的格式呈现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the error estimate δE by constructing and diagonalizing\n    IM-SRG(2) and IM-SRG(3) Hamiltonian matrices for a simplified 3-state system.\n    \"\"\"\n    \n    # Each tuple contains:\n    # (holes_eps, particles_eps, E_hh, E_occ3, g2_0, c_W, g3, Delta2, Delta3)\n    test_cases = [\n        # Case 1\n        (\n            np.array([-15.5, -14.2, -13.7]),\n            np.array([-1.8, 0.7, 2.2]),\n            -12.0, -1.5, -2.0, -0.3, -0.5, 0.9, 0.4\n        ),\n        # Case 2\n        (\n            np.array([-12.0, -11.5, -10.8]),\n            np.array([-2.0, 0.0, 1.0]),\n            -10.0, -0.8, -1.5, -0.2, 0.0, 0.5, 0.3\n        ),\n        # Case 3\n        (\n            np.array([-16.0, -15.2, -14.1]),\n            np.array([-3.0, -1.0, 0.5]),\n            -13.0, -2.2, -1.0, -0.4, -4.0, 0.7, 0.9\n        ),\n        # Case 4\n        (\n            np.array([-10.0, -9.5, -9.0]),\n            np.array([-9.0, -8.8, -8.5]),\n            -8.0, -0.5, -3.0, -0.5, -1.0, -0.2, 0.1\n        )\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        holes_eps, particles_eps, E_hh, E_occ3, g2_0, c_W, g3, Delta2, Delta3 = case\n        \n        # Unpack single-particle energies for clarity in formulas\n        eps_h1, eps_h2, eps_h3 = holes_eps\n        eps_p1, eps_p2, eps_p3 = particles_eps\n        \n        # Calculate matrix elements\n        # E_0: Reference state energy\n        E0 = np.sum(holes_eps) + E_hh + E_occ3\n        \n        # E_2: 2p2h state energy\n        E2 = E0 + (eps_p1 + eps_p2 - eps_h1 - eps_h2) + Delta2\n        \n        # E_3: 3p3h state energy\n        E3 = E0 + (eps_p1 + eps_p2 + eps_p3 - eps_h1 - eps_h2 - eps_h3) + Delta3\n        \n        # g2_eff: Effective 2-body coupling\n        g2_eff = g2_0 + c_W\n        \n        # Construct H(2) matrix (2x2)\n        H2 = np.array([\n            [E0, g2_eff],\n            [g2_eff, E2]\n        ])\n        \n        # Construct H(3) matrix (3x3)\n        H3 = np.array([\n            [E0, g2_eff, g3],\n            [g2_eff, E2, 0.0],\n            [g3, 0.0, E3]\n        ])\n        \n        # Diagonalize matrices to find the lowest eigenvalue (ground state energy)\n        # eigvalsh is used for Hermitian (real-symmetric) matrices.\n        E_gs_2 = np.min(np.linalg.eigvalsh(H2))\n        E_gs_3 = np.min(np.linalg.eigvalsh(H3))\n        \n        # Calculate the error estimate delta_E\n        delta_E = E_gs_2 - E_gs_3\n        \n        # Round to 6 decimal places and append to results\n        results.append(round(delta_E, 6))\n\n    # Format the final output string as specified\n    output_str = f\"[{','.join(f'{r:.6f}' for r in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3564801"}, {"introduction": "真实的IM-SRG计算在计算上是极为苛刻的，其可行性通常取决于算法的效率。本练习聚焦于IM-SRG(2)计算中的核心瓶颈——算符对易子中的张量收缩，并分析其计算复杂度。您将比较一个直接的“稠密”张量收缩算法和一个利用低秩分解的先进算法，后者是现代大规模核结构计算中的关键优化技术。[@problem_id:3564754]", "problem": "您的任务是实现并分析一个关键的张量收缩构建块的计算成本，该构建块出现在截断至正规序双体水平的 In-Medium Similarity Renormalization Group (IM-SRG) 中，即 IM-SRG(2)。目标对象是两个正规序双体算符的对易子，其采用一种简化形式，其中相关贡献可以由以下类型的张量收缩捕获：\n$$\n\\mathcal{K}_{ijab} = \\sum_{cd} \\mathcal{A}_{ijcd} \\,\\mathcal{B}_{cdab} \\;-\\; \\sum_{cd} \\mathcal{B}_{ijcd} \\,\\mathcal{A}_{cdab},\n$$\n其中，$i,j$ 表示单粒子基中的空穴指标，$a,b,c,d$ 表示粒子指标。基的维度是 $N$，您可以假设 $N$ 是偶数，具有 $n_h = N/2$ 个空穴和 $n_p = N/2$ 个粒子。这个收缩代表了 IM-SRG(2) 中对易子的双体部分，并且已知在稠密表示中其标度行为为 $\\mathcal{O}(N^6)$。\n\n您的程序必须实现两种计算 $\\mathcal{K}_{ijab}$ 的算法：\n\n1. 一种使用显式四指标张量的稠密收缩方法，该方法直接执行两个收缩。对于 $n_h \\approx n_p \\approx N/2$，这应该实现朴素的 $\\mathcal{O}(N^6)$ 标度行为。\n\n2. 一种低秩分解方法，该方法利用了四指标张量的分解。构建一系列秩为 $R$ 的因子，其中 $R = \\lfloor N/2 \\rfloor$，并定义：\n$$\n\\mathcal{A}_{ijcd} = \\sum_{r=1}^{R} S^{(r)}_{ij} \\, U^{(r)}_{cd}, \\qquad\n\\mathcal{A}_{cdab} = \\sum_{r=1}^{R} U^{(r)}_{cd} \\, T^{(r)}_{ab},\n$$\n$$\n\\mathcal{B}_{ijcd} = \\sum_{r=1}^{R} \\tilde{S}^{(r)}_{ij} \\, U^{(r)}_{cd}, \\qquad\n\\mathcal{B}_{cdab} = \\sum_{r=1}^{R} U^{(r)}_{cd} \\, \\tilde{T}^{(r)}_{ab},\n$$\n在 $(ijcd)$ 和 $(cdab)$ 形式之间共享粒子空间因子 $U^{(r)}_{cd}$。证明（对于这些由低秩构造的张量）对易子贡献可以使用辅助的 $R \\times R$ Gram 矩阵被精确地计算出来：\n$$\nM_{rs} = \\sum_{cd} U^{(r)}_{cd} \\, U^{(s)}_{cd},\n$$\n以及通过对重塑后的因子进行矩阵乘法。当 $R \\propto N$ 时，使用这种方法将标度行为降低到 $\\mathcal{O}(N^5)$。\n\n从以下基本基础开始：\n- 对易子定义 $[ \\hat{A}, \\hat{B} ] \\equiv \\hat{A}\\hat{B} - \\hat{B}\\hat{A}$。\n- 如上所述，将双线性双体算符收缩与指标求和等同起来。\n- 一个 $m \\times k$ 矩阵乘以一个 $k \\times n$ 矩阵的浮点运算 (FLOP) 次数为 $2 mkn$，两个长度为 $k$ 的向量的点积为 $2k$ FLOPs。\n\n任务：\n- 对偶数 $N$ 实现两种计算 $\\mathcal{K}_{ijab}$ 的方法，使用随机但可复现的因子。使用固定的种子以保证确定性。通过计算相对 Frobenius 范数误差来验证数值等效性：\n$$\n\\epsilon_{\\mathrm{rel}} = \\frac{\\| \\mathcal{K}^{\\mathrm{dense}} - \\mathcal{K}^{\\mathrm{fact}} \\|_F}{\\| \\mathcal{K}^{\\mathrm{dense}} \\|_F}.\n$$\n- 推导并实现两种方法的解析 FLOP 计数，作为 $N$、$n_h$、$n_p$ 和 $R$ 的函数：\n  - 稠密方法：将成本建模为两次收缩，每次成本为 $2 \\, n_h^2 \\, n_p^4$ FLOPs；总计 $4 \\, n_h^2 \\, n_p^4$ FLOPs。\n  - 分解方法：计算 Gram 矩阵和两个矩阵链乘积。当 $H = n_h^2$ 和 $P = n_p^2$ 时，总成本为\n    $$\n    6 R^2 P + 4 H R P \\;\\; \\text{FLOPs}.\n    $$\n- 对于一组递增的基大小 $N \\in \\{4,6,8,10\\}$（这是测试套件），设置 $n_h = n_p = N/2$ 和 $R = N/2$，并计算两种方法的 FLOP 计数。通过分别对每种方法的 $\\log F(N)$ 与 $\\log N$ 进行线性最小二乘法，将标度指数 $\\alpha$ 拟合到模型 $F(N) \\propto N^\\alpha$；报告稠密方法和分解方法的指数。您必须一致地使用自然对数或以 10 为底的对数。\n- 您的程序应产生单行输出，其中包含一个带有三个浮点数的 Python 风格列表：\n  - 稠密方法的拟合指数，\n  - 分解方法的拟合指数，\n  - 测试套件中的最大相对误差 $\\epsilon_{\\mathrm{rel}}$。\n不涉及物理单位；所有输出都是无量纲实数。角度（如果有的话）不适用。\n\n最终输出格式：\n- 您的程序必须严格产生一行，格式如下：\n$$\n[\\alpha_{\\mathrm{dense}},\\alpha_{\\mathrm{fact}},\\epsilon_{\\max}]\n$$\n指数四舍五入到三位小数，误差以浮点数形式报告。例如，一个语法正确的输出看起来像：\n$$\n[6.000,5.000,1.2e-15].\n$$", "solution": "用户提供了一个有效且定义明确的问题。\n\n## 第 1 步：提取已知信息\n- **目标张量**：双体对易子贡献 $\\mathcal{K}_{ijab}$，定义为：\n$$\n\\mathcal{K}_{ijab} = \\sum_{cd} \\mathcal{A}_{ijcd} \\,\\mathcal{B}_{cdab} \\;-\\; \\sum_{cd} \\mathcal{B}_{ijcd} \\,\\mathcal{A}_{cdab}\n$$\n- **指标**：$i,j$ 是空穴指标，$a,b,c,d$ 是粒子指标。\n- **基维度**：总维度为 $N$（偶数）。空穴数为 $n_h = N/2$。粒子数为 $n_p = N/2$。\n- **方法 1 (稠密)**：四指标张量的直接收缩。\n- **方法 2 (分解)**：张量由秩为 $R = \\lfloor N/2 \\rfloor = N/2$ 的低秩因子构造。\n$$\n\\mathcal{A}_{ijcd} = \\sum_{r=1}^{R} S^{(r)}_{ij} \\, U^{(r)}_{cd}, \\qquad\n\\mathcal{A}_{cdab} = \\sum_{r=1}^{R} U^{(r)}_{cd} \\, T^{(r)}_{ab}\n$$\n$$\n\\mathcal{B}_{ijcd} = \\sum_{r=1}^{R} \\tilde{S}^{(r)}_{ij} \\, U^{(r)}_{cd}, \\qquad\n\\mathcal{B}_{cdab} = \\sum_{r=1}^{R} U^{(r)}_{cd} \\, \\tilde{T}^{(r)}_{ab}\n$$\n- **辅助矩阵**：Gram 矩阵 $M_{rs} = \\sum_{cd} U^{(r)}_{cd} \\, U^{(s)}_{cd}$。\n- **FLOP 计数模型**：\n  - 稠密：$F_{\\text{dense}} = 4 \\, n_h^2 \\, n_p^4$。\n  - 分解：$F_{\\text{fact}} = 6 R^2 P + 4 H R P$，其中 $H = n_h^2$ 且 $P = n_p^2$。\n- **任务**：\n  1. 实现两种计算 $\\mathcal{K}_{ijab}$ 的方法。\n  2. 使用相对 Frobenius 范数误差 $\\epsilon_{\\mathrm{rel}}$ 验证数值等效性。\n  3. 实现给定的解析 FLOP 计数公式。\n  4. 对 $N \\in \\{4, 6, 8, 10\\}$ 执行计算。\n  5. 使用对数-对数线性拟合为每种方法拟合标度指数 $\\alpha$。\n- **输出格式**：单行列表 $[\\alpha_{\\mathrm{dense}},\\alpha_{\\mathrm{fact}},\\epsilon_{\\max}]$。\n\n## 第 2 步：使用提取的已知信息进行验证\n- **科学依据**：该问题设置在 In-Medium Similarity Renormalization Group (IM-SRG) 的背景下，这是计算核物理中的一种标准方法。张量收缩、低秩分解和标度分析都是多体理论和科学计算中的标准、严谨概念。\n- **定义明确**：该问题提供了所有必要的定义、约束（$n_h = n_p = R = N/2$）和具体的计算任务。输入（$N \\in \\{4, 6, 8, 10\\}$）已定义，并且精确指定了所需的输出格式。使用固定的随机种子确保了唯一且可复现的解。\n- **客观性**：问题以精确的数学和计算术语陈述，没有主观性或歧义。\n\n该问题是有效的，因为其科学上合理、内容自洽且算法上已指定。\n\n## 第 3 步：行动\n问题是有效的。将提供一个完整的解决方案。\n\n### 基于原理的解决方案设计\n\n核心任务是使用两种不同的算法计算表示对易子 $[\\hat{A}, \\hat{B}]$ 的一个分量的张量 $\\mathcal{K}_{ijab}$，并分析它们的计算成本。\n\n#### 方法 1：稠密收缩\n\n该方法涉及构造完整的四指标张量 $\\mathcal{A}$ 和 $\\mathcal{B}$，然后按规定执行张量收缩。\n$\\mathcal{A}$ 的两种所需形式是 $\\mathcal{A}_{ijcd}$ 和 $\\mathcal{A}_{cdab}$。根据分解定义，它们的构造如下：\n$$\n\\mathcal{A}_{ijcd} = \\sum_{r=1}^{R} S^{(r)}_{ij} U^{(r)}_{cd} \\quad ; \\quad \\mathcal{A}_{cdab} = \\sum_{r=1}^{R} U^{(r)}_{cd} T^{(r)}_{ab}\n$$\n类似的表达式也适用于 $\\mathcal{B}$。这些求和可以使用张量运算（例如爱因斯坦求和）高效实现。一旦形成了四个张量 $\\mathcal{A}_{ijcd}$、$\\mathcal{B}_{cdab}$、$\\mathcal{B}_{ijcd}$ 和 $\\mathcal{A}_{cdab}$，最终的张量 $\\mathcal{K}_{ijab}$ 就通过直接收缩计算得出：\n$$\n\\mathcal{K}_{ijab} = \\underbrace{\\sum_{c,d} \\mathcal{A}_{ijcd} \\mathcal{B}_{cdab}}_{\\text{Term 1}} - \\underbrace{\\sum_{c,d} \\mathcal{B}_{ijcd} \\mathcal{A}_{cdab}}_{\\text{Term 2}}\n$$\n每次收缩都涉及对 $n_p^2$ 对指标 $(c,d)$ 求和。对于结果中的每个 $n_h^2 n_p^2$ 元素，这需要大约 $2n_p^2$ 次浮点运算 (FLOPs)。因此，两次收缩的总成本为 $2 \\times (n_h^2 n_p^2 \\times 2n_p^2) = 4n_h^2 n_p^4$ FLOPs，与提供的公式相符。当 $n_h = n_p = N/2$ 时，成本为 $F_{\\text{dense}} = 4(N/2)^2(N/2)^4 = N^6/16$，表现出 $\\mathcal{O}(N^6)$ 的标度行为。\n\n#### 方法 2：低秩分解收缩\n\n该方法通过利用其低秩结构来避免形成大型的四指标张量。考虑对易子中的第一项 $\\sum_{cd} \\mathcal{A}_{ijcd} \\mathcal{B}_{cdab}$。代入分解形式：\n$$\n\\sum_{c,d} \\left( \\sum_{r=1}^{R} S^{(r)}_{ij} U^{(r)}_{cd} \\right) \\left( \\sum_{s=1}^{R} U^{(s)}_{cd} \\tilde{T}^{(s)}_{ab} \\right)\n$$\n通过重新排列求和，这变为：\n$$\n\\sum_{r,s=1}^{R} S^{(r)}_{ij} \\tilde{T}^{(s)}_{ab} \\left( \\sum_{c,d} U^{(r)}_{cd} U^{(s)}_{cd} \\right)\n$$\n内部求和正是 Gram 矩阵 $M_{rs}$ 的定义。表达式简化为：\n$$\n\\sum_{r,s=1}^{R} S^{(r)}_{ij} M_{rs} \\tilde{T}^{(s)}_{ab}\n$$\n这种结构表明可以通过矩阵乘法进行计算。我们可以将因子张量重塑为矩阵。设 $H=n_h^2$ 和 $P=n_p^2$。这些因子可以排列为：\n- $\\mathbf{S}$：一个由 $S^{(r)}_{ij}$ 构成的 $H \\times R$ 矩阵。\n- $\\tilde{\\mathbf{S}}$：一个由 $\\tilde{S}^{(r)}_{ij}$ 构成的 $H \\times R$ 矩阵。\n- $\\mathbf{T}$：一个由 $T^{(r)}_{ab}$ 构成的 $R \\times P$ 矩阵。\n- $\\tilde{\\mathbf{T}}$：一个由 $\\tilde{T}^{(s)}_{ab}$ 构成的 $R \\times P$ 矩阵。\n- $\\mathbf{U}$：一个由 $U^{(r)}_{cd}$ 构成的 $R \\times P$ 矩阵。\n\nGram 矩阵 $\\mathbf{M}$ 计算为 $\\mathbf{M} = \\mathbf{U} \\mathbf{U}^T$，这是一个 $(R \\times P)$ 矩阵和一个 $(P \\times R)$ 矩阵的乘积，产生一个 $(R \\times R)$ 的结果。这需要 $2 R^2 P$ FLOPs。对易子的两项，现在以矩阵形式表示为 $\\mathbf{S} \\mathbf{M} \\tilde{\\mathbf{T}}$ 和 $\\tilde{\\mathbf{S}} \\mathbf{M} \\mathbf{T}$。为了与提供的 FLOP 计数相匹配，我们必须使用导致 $F_{\\text{fact}} = 6 R^2 P + 4 H R P$ 的矩阵结合顺序。这源于以下计算顺序：\n1. 计算 $\\mathbf{M} = \\mathbf{U} \\mathbf{U}^T$。成本：$2 R^2 P$。\n2. 对于第一项，计算 $\\mathbf{Y}_{\\tilde{T}} = \\mathbf{M} \\tilde{\\mathbf{T}}$。这是 $(R \\times R) \\times (R \\times P)$，成本为 $2 R^2 P$。然后计算 $\\mathbf{S} \\mathbf{Y}_{\\tilde{T}}$，这是 $(H \\times R) \\times (R \\times P)$，成本为 $2 H R P$。\n3. 对于第二项，计算 $\\mathbf{Y}_{T} = \\mathbf{M} \\mathbf{T}$。成本：$2 R^2 P$。然后计算 $\\tilde{\\mathbf{S}} \\mathbf{Y}_{T}$。成本：$2 H R P$。\n\n总 FLOP 计数是这些步骤的总和：$F_{\\text{fact}} = \\underbrace{2R^2P}_{\\mathbf{M}} + (\\underbrace{2R^2P}_{\\mathbf{M}\\tilde{\\mathbf{T}}} + \\underbrace{2HRP}_{\\mathbf{S}(\\dots)}) + (\\underbrace{2R^2P}_{\\mathbf{M}\\mathbf{T}} + \\underbrace{2HRP}_{\\tilde{\\mathbf{S}}(\\dots)})$。这总计为 $6 R^2 P + 4 H R P$，与问题陈述相符。当 $n_h = n_p = R = N/2$ 时，这变为 $F_{\\text{fact}} = 6(N/2)^2(N^2/4) + 4(N^2/4)(N/2)(N^2/4) = \\frac{3}{8}N^4 + \\frac{1}{8}N^5$。主导项的标度行为为 $\\mathcal{O}(N^5)$，与稠密方法相比是显著的降低。\n\n#### 标度分析\n\n为了在数值上验证理论标度指数，我们将 FLOP 计数 $F$ 建模为基大小 $N$ 的函数，遵循幂律 $F(N) = c N^\\alpha$。对两边取对数得到一个线性方程：\n$$\n\\log(F(N)) = \\alpha \\log(N) + \\log(c)\n$$\n这是 $y = m x + b$ 的形式，其中 $y = \\log(F(N))$，$x = \\log(N)$，斜率 $m$ 是所需的标度指数 $\\alpha$。我们为测试套件 $N \\in \\{4, 6, 8, 10\\}$ 计算 FLOP 计数，并对 $(\\log N, \\log F(N))$ 数据点执行线性最小二乘回归，以提取每种方法的斜率 $\\alpha$。\n\n最后，通过计算两种方法输出 $\\mathcal{K}^{\\mathrm{dense}}$ 和 $\\mathcal{K}^{\\mathrm{fact}}$ 之间差值的相对 Frobenius 范数来确定它们的数值等效性，该值应接近机器精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Implements and analyzes two algorithms for a tensor contraction in IM-SRG(2),\n    verifies their numerical equivalence, and fits their computational scaling.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [4, 6, 8, 10]\n    \n    # Use a fixed seed for reproducible random factors.\n    np.random.seed(42)\n\n    all_relative_errors = []\n    flop_data = []\n\n    for N in test_cases:\n        # Define dimensions based on the problem statement\n        n_h = N // 2\n        n_p = N // 2\n        R = N // 2\n\n        # Generate random, reproducible tensors (factors)\n        # S_factors will have shape (R, n_h, n_h)\n        S_factors = np.random.randn(R, n_h, n_h)\n        S_tilde_factors = np.random.randn(R, n_h, n_h)\n        \n        # T_factors will have shape (R, n_p, n_p)\n        T_factors = np.random.randn(R, n_p, n_p)\n        T_tilde_factors = np.random.randn(R, n_p, n_p)\n\n        # U_factors are shared and have shape (R, n_p, n_p)\n        U_factors = np.random.randn(R, n_p, n_p)\n\n        # --- Method 1: Dense Contraction ---\n        # Construct full 4-index tensors from factors\n        # A_ijcd = sum_r S_rij * U_rcd\n        A_ijcd = np.einsum('rij,rcd->ijcd', S_factors, U_factors)\n        # A_cdab = sum_r U_rcd * T_rab\n        A_cdab = np.einsum('rcd,rab->cdab', U_factors, T_factors)\n        # B_ijcd = sum_r S_tilde_rij * U_rcd\n        B_ijcd = np.einsum('rij,rcd->ijcd', S_tilde_factors, U_factors)\n        # B_cdab = sum_r U_rcd * T_tilde_rab\n        B_cdab = np.einsum('rcd,rab->cdab', U_factors, T_tilde_factors)\n\n        # Perform the commutator contractions\n        # term1 = sum_cd A_ijcd * B_cdab\n        term1 = np.einsum('ijcd,cdab->ijab', A_ijcd, B_cdab)\n        # term2 = sum_cd B_ijcd * A_cdab\n        term2 = np.einsum('ijcd,cdab->ijab', B_ijcd, A_cdab)\n\n        K_dense = term1 - term2\n\n        # --- Method 2: Low-Rank Factorized Contraction ---\n        H = n_h**2\n        P = n_p**2\n\n        # Reshape factors into 2D matrices\n        # (R, n_h, n_h) -> (R, H) -> (H, R)\n        S_mat = S_factors.reshape(R, H).T\n        S_tilde_mat = S_tilde_factors.reshape(R, H).T\n        \n        # (R, n_p, n_p) -> (R, P)\n        T_mat = T_factors.reshape(R, P)\n        T_tilde_mat = T_tilde_factors.reshape(R, P)\n        U_mat = U_factors.reshape(R, P)\n\n        # 1. Compute the Gram matrix M = U U^T\n        # (R, P) @ (P, R) -> (R, R)\n        M = U_mat @ U_mat.T\n        \n        # 2. Compute first term: S (M T_tilde)\n        Y_tilde = M @ T_tilde_mat # (R, R) @ (R, P) -> (R, P)\n        term1_mat = S_mat @ Y_tilde # (H, R) @ (R, P) -> (H, P)\n\n        # 3. Compute second term: S_tilde (M T)\n        Y = M @ T_mat # (R, R) @ (R, P) -> (R, P)\n        term2_mat = S_tilde_mat @ Y # (H, R) @ (R, P) -> (H, P)\n\n        # 4. Combine and reshape back to a 4-index tensor\n        K_fact_mat = term1_mat - term2_mat\n        K_fact = K_fact_mat.reshape(n_h, n_h, n_p, n_p)\n\n        # --- Verification ---\n        norm_diff = np.linalg.norm(K_dense - K_fact)\n        norm_K_dense = np.linalg.norm(K_dense)\n        relative_error = norm_diff / norm_K_dense if norm_K_dense > 0 else 0.0\n        all_relative_errors.append(relative_error)\n\n        # --- FLOP Count Calculation ---\n        # Using formulas from the problem statement\n        flops_dense = 4 * (n_h**2) * (n_p**4)\n        flops_fact = 6 * (R**2) * P + 4 * H * R * P\n        flop_data.append((N, flops_dense, flops_fact))\n\n    # --- Scaling Analysis ---\n    log_N_vals = np.log([item[0] for item in flop_data])\n    log_flops_dense = np.log([item[1] for item in flop_data])\n    log_flops_fact = np.log([item[2] for item in flop_data])\n    \n    # Perform linear regression to find the slope (scaling exponent)\n    alpha_dense = linregress(log_N_vals, log_flops_dense).slope\n    alpha_fact = linregress(log_N_vals, log_flops_fact).slope\n    \n    # Find the maximum relative error across the test suite\n    epsilon_max = max(all_relative_errors)\n\n    # Final print statement in the exact required format.\n    print(f\"[{alpha_dense:.3f},{alpha_fact:.3f},{epsilon_max}]\")\n\nsolve()\n```", "id": "3564754"}]}