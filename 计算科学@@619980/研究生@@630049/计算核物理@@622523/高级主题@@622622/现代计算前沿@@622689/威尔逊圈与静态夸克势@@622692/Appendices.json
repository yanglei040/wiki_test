{"hands_on_practices": [{"introduction": "进入夸克禁闭数值研究的旅程始于对威尔逊圈的直接计算。第一个动手实践将指导你根据格点上的基本定义，实现计算矩形威尔逊圈期望值 $\\langle W(R,T) \\rangle$ 的算法 [@problem_id:3611747]。通过对格点对称性进行平均，你将学到一项减少统计误差、从而获得静态势精确信号的关键技术。", "problem": "考虑量子色动力学（QCD）的四维欧几里得格点表述，其规范群为三阶特殊酉群（$SU(3)$）。一个规范组态为每个从格点 $x$ 出发、沿方向 $\\mu \\in \\{0,1,2,3\\}$ 的有向连接（link）分配一个矩阵 $U_{\\mu}(x) \\in SU(3)$，该矩阵表示沿此连接的平行输运算符。时间方向为 $\\mu=3$，空间方向为 $\\mu \\in \\{0,1,2\\}$，分别对应于 $x$、$y$ 和 $z$ 坐标轴。与固定空间方向上空间范围为 $R$、时间范围为 $T$ 的矩形相关的 Wilson 圈 $W(R,T)$，由沿相应时空平面内矩形轮廓的连接变量的路径有序乘积定义。对色指数的迹由颜色数 $N_c=3$ 进行归一化，而物理上相关的可观测量是该归一化迹的实部。所有方向均施加周期性边界条件。\n\n从格点规范理论的基本定义出发，设计并实现一个算法，该算法针对给定的规范组态系综，计算系综平均的 Wilson 圈 $W(R,T)$，并通过对以下各项进行平均来实现方差缩减：\n- 圈的空间角点的所有空间平移，\n- 所有时间原点，\n- 所有立方旋转，限制为沿三个笛卡尔轴（$x$、$y$、$z$）中的每一个选择空间边。\n\n您的算法必须明确地实现闭合圈的乘积，方法是：沿选定的空间方向前进 $R$ 个连接，沿时间方向前进 $T$ 个连接，沿选定的空间方向后退 $R$ 个连接（这必须通过在适当平移的格点上乘以厄米共轭 $U_{\\mu}^{\\dagger}$ 来实现），以及沿时间方向后退 $T$ 个连接（也通过 $U_{\\mu}^{\\dagger}$ 实现）。所有格点索引都应使用周期性边界条件执行。最终的单圈可观测量必须计算为 $\\frac{1}{N_c}\\operatorname{Re}\\operatorname{Tr}(\\mathcal{U}_{\\square})$，其中 $\\mathcal{U}_{\\square}$ 是沿矩形进行有序乘积得到的 $SU(3)$ 矩阵。\n\n您必须使用的基本假设：\n- $U_{\\mu}(x)$ 是 $SU(3)$ 的元素，因此 $U_{\\mu}^{\\dagger}(x)=U_{\\mu}^{-1}(x)$ 且 $\\det U_{\\mu}(x)=1$。\n- 在固定的 $R$ 和 $T$ 下，Wilson 圈可观测量在空间平移、时间平移和空间轴的立方旋转下保持不变；因此，对这些对称性进行平均可以在不引入估计偏差的情况下减少统计误差。\n- 周期性边界条件意味着坐标更新是在每个维度上对格点尺寸取模完成的。\n\n您的程序必须构建三个确定性系综，并对指定的 $(R,T)$ 值评估可观测量。请使用以下测试套件，其中每个系综由其明确的连接分配规则和格点维度定义：\n\n- 测试用例 1（基线单位场）：\n  - 格点维度：$L_x=L_y=L_z=L_t=4$（即 $4\\times 4 \\times 4 \\times 4$）。\n  - 系综：单个组态，其中对于所有 $x$ 和所有 $\\mu$，$U_{\\mu}(x)=\\mathbb{I}_{3}$。\n  - 参数：$R=2, T=3$。\n\n- 测试用例 2（单轴结构化时间连接）：\n  - 格点维度：$L_x=8, L_y=8, L_z=8, L_t=6$。\n  - 系综：单个组态，其中对于所有沿 x 轴具有空间坐标 x 的格点 x，$U_{3}(x)=\\mathrm{diag}\\left(e^{i\\alpha x}, e^{-i\\alpha x}, 1\\right)$，而对于 $\\mu \\in \\{0,1,2\\}$，$U_{\\mu}(x)=\\mathbb{I}_{3}$。此处 $\\alpha=\\frac{2\\pi}{L_x}$，且相位中使用的整数 x 坐标应理解为对 $L_x$ 取模。\n  - 参数：$R=3, T=2$。\n\n- 测试用例 3（对称坐标和时间连接）：\n  - 格点维度：$L_x=6, L_y=6, L_z=6, L_t=4$。\n  - 系综：单个组态，其中 $U_{3}(x)=\\mathrm{diag}\\left(e^{i\\alpha s}, e^{-i\\alpha s}, 1\\right)$，此处 $s=(x+y+z)\\bmod L_x$，而对于 $\\mu \\in \\{0,1,2\\}$，$U_{\\mu}(x)=\\mathbb{I}_{3}$。此处 $\\alpha=\\frac{2\\pi}{L_x}$，$x$、$y$、$z$ 是空间坐标。\n  - 参数：$R=1, T=2$。\n\n- 测试用例 4（退化空间范围）：\n  - 格点维度：$L_x=L_y=L_z=L_t=4$（即 $4\\times 4 \\times 4 \\times 4$）。\n  - 系综：单个组态，其中对于所有 $x$ 和所有 $\\mu$，$U_{\\mu}(x)=\\mathbb{I}_{3}$。\n  - 参数：$R=0, T=4$。\n\n对于每个测试用例，您的算法必须：\n- 遍历所有空间起始点 $(x,y,z)$ 和所有时间原点 $t$，\n- 遍历三个空间方向，\n- 按所述方式构建闭合圈乘积，\n- 在每个实例中计算归一化的实部迹，\n- 对所有此类实例以及系综中的所有组态进行平均，以获得单个浮点数 $W(R,T)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[w_1,w_2,w_3,w_4]$），其中 $w_k$ 是为测试用例 $k$ 计算的 $W(R,T)$，以无单位十进制形式表示。", "solution": "用户提供的问题陈述已根据所需标准进行了仔细审查和验证。这是一个来自计算格点规范理论的、定义良好且具有科学依据的问题。其定义、参数和目标都足够清晰和严谨，可以得出一个唯一的、可验证的解。因此，我们可以着手进行推导和实现。\n\n### 理论框架\n\n格点量子色动力学（QCD）是一种通过将时空离散化为四维超立方格点来求解 QCD 的非微扰方法。在这种表述中，夸克定义在格点上，而强力的介质——胶子，则由连接变量表示。\n\n连接变量 $U_{\\mu}(x)$ 是规范群（在此为 $SU(3)$）中的一个元素，表示将一个色矢量从格点 $x$ 平行输运到方向 $\\mu$ 上的相邻格点 $x+\\hat{\\mu}$。它通过 $U_{\\mu}(x) \\approx \\exp(iga A_{\\mu}(x))$ 与连续规范场 $A_\\mu$ 相关，其中 $g$ 是强耦合常数，$a$ 是格点间距。\n\nWilson 圈 $W(R,T)$ 是一个基本的规范不变可观测量。它由沿空间范围为 $R$、时间范围为 $T$ 的闭合矩形圈 $\\mathcal{C}$ 的连接变量的路径有序乘积构成。圈矩阵 $\\mathcal{U}_{\\square}$ 由下式给出：\n$$\n\\mathcal{U}_{\\square} = P \\prod_{l \\in \\mathcal{C}} U_l\n$$\n其中 $P$ 表示路径排序，$U_l$ 是沿圈的连接变量。Wilson 圈可观测量是此矩阵归一化迹的实部，并在系综 $\\langle \\dots \\rangle$ 中的所有规范组态上进行平均：\n$$\nW(R,T) = \\left\\langle \\frac{1}{N_c} \\operatorname{Re} \\operatorname{Tr}(\\mathcal{U}_{\\square}) \\right\\rangle\n$$\n对于大的时间范围 $T$，Wilson 圈期望值与相距空间距离 $R$ 的夸克和反夸克之间的静态势 $V(R)$ 相关：$\\langle W(R,T) \\rangle \\propto e^{-V(R)T}$。\n\n### 算法设计\n\n算法的核心是为给定的确定性系综计算平均 Wilson 圈值 $\\langle W(R,T) \\rangle$。为减少统计方差（尽管所提供的系综是确定性的，但原理得到了展示），我们将可观测量在所有可能的平移和离散旋转上进行平均，因为这些是基础理论的对称性。\n\n算法流程如下：\n1.  **对称性平均：** 一组嵌套循环遍历 Wilson 圈所有可能的起始位置及其空间取向。\n    - 一个外部循环遍历三个空间方向 $\\mu \\in \\{0,1,2\\}$，这些方向定义了圈所在的平面（例如，$x-t$ 平面、$y-t$ 平面或 $z-t$ 平面）。\n    - 内部循环遍历 $L_x \\times L_y \\times L_z \\times L_t$ 格点上所有可能的起始格点 $(x_0, x_1, x_2, x_3)$。\n\n2.  **圈的构建：** 对于每个特定的圈实例（由其起始格点和取向定义），通过沿指定路径乘以连接矩阵来构建 $SU(3)$ 矩阵 $\\mathcal{U}_{\\square}$。该路径包含四个部分：\n    1.  沿选定的空间方向 $s_{\\text{dir}}$ 前进 $R$ 步。\n    2.  沿时间方向 $t_{\\text{dir}}=3$ 前进 $T$ 步。\n    3.  沿空间方向后退 $R$ 步。从格点 $x$ 到 $x-\\hat{\\mu}$ 的后退一步是通过乘以正向连接的厄米共轭 $U_{\\mu}^{\\dagger}(x-\\hat{\\mu})$ 来完成的。\n    4.  沿时间方向后退 $T$ 步。\n    \n    路径有序乘积是通过从单位矩阵 $\\mathbb{I}_3$ 开始的顺序左乘来累积的。设 $U_i$ 为路径第 $i$ 步的连接矩阵。经过 $N=2R+2T$ 步后的最终圈矩阵为 $\\mathcal{U}_{\\square} = U_N \\dots U_2 U_1$。所有坐标计算都包含周期性边界条件，通过取模运算符实现。\n\n3.  **可观测量计算：** 对于每个计算出的 $\\mathcal{U}_{\\square}$，计算可观测量 $\\frac{1}{N_c} \\operatorname{Re}\\operatorname{Tr}(\\mathcal{U}_{\\square})$，其中 $N_c=3$。\n\n4.  **求平均：** 将所有圈实例的可观测量值相加，然后除以实例总数，以获得最终的平均值。\n\n### 测试用例的解析验证\n\n所提供的测试用例使用确定性系综，这允许通过解析计算来验证算法的正确性。\n\n-   **测试用例 1 ($U_{\\mu}(x)=\\mathbb{I}_3, R=2, T=3$)：** 任意数量单位矩阵的乘积仍是单位矩阵，因此 $\\mathcal{U}_{\\square} = \\mathbb{I}_3$。迹为 $\\operatorname{Tr}(\\mathbb{I}_3) = 3$。可观测量为 $\\frac{1}{3}\\operatorname{Re}(3) = 1.0$。这对所有圈都成立，所以平均值为 $1.0$。\n\n-   **测试用例 4 ($U_{\\mu}(x)=\\mathbb{I}_3, R=0, T=4$)：** 这是一个空间范围为零的退化圈。路径包括沿时间方向前进 $T=4$ 步，然后再后退 $T=4$ 步。由于所有连接都是 $\\mathbb{I}_3$，圈乘积再次为 $\\mathbb{I}_3$，最终结果是 $1.0$。\n\n-   **测试用例 2 ($L_x=8, R=3, T=2$)：** 空间连接为 $\\mathbb{I}_3$。时间连接 $U_3$ 取决于 $x$ 坐标 $c_0$。\n    -   如果圈在 $y-t$ 或 $z-t$ 平面（$s_{\\text{dir}}=1$ 或 $2$），则整个路径上的 $x$ 坐标是恒定的。前进的时间乘积 $(U_3(c_0))^T$ 会被后退的时间乘积 $(U_3(c_0)^\\dagger)^T$ 完全抵消，得到 $\\mathcal{U}_{\\square} = \\mathbb{I}_3$ 和可观测量 $1.0$。\n    -   如果圈在 $x-t$ 平面（$s_{\\text{dir}}=0$），前进的时间路径位于 $c_0'=(c_0+R)\\%L_x$，而后退的时间路径位于 $c_0$。圈矩阵为 $\\mathcal{U}_{\\square} = \\text{diag}(e^{i\\alpha T (c_0' - c_0)}, e^{-i\\alpha T (c_0' - c_0)}, 1)$，其中 $\\alpha T = (\\frac{2\\pi}{8}) \\cdot 2 = \\frac{\\pi}{2}$。相位参数 $\\alpha T (c_0' - c_0)$ 的值根据 $c_0$ 的不同，计算为 $\\frac{3\\pi}{2}$ 或 $-\\frac{5\\pi}{2}$。在这两种情况下，余弦值均为 $0$。可观测量为 $\\frac{1}{3}(2\\cos(\\dots)+1) = \\frac{1}{3}$。\n    -   对三个取向进行平均得到 $\\frac{1.0 + 1.0 + 1/3}{3} = \\frac{7/3}{3} = 7/9$。\n\n-   **测试用例 3 ($L_x=6, R=1, T=2$)：** 空间连接为 $\\mathbb{I}_3$。时间连接 $U_3$ 取决于 $s=(c_0+c_1+c_2)\\%L_x$。对于任何空间取向，沿该方向移动 $R=1$ 会使 $s$ 改变 $\\Delta s = 1$ 或 $\\Delta s=1-L_x=-5$。圈矩阵中的相位差为 $\\alpha T \\Delta s = (\\frac{2\\pi}{6}) \\cdot 2 \\cdot \\Delta s = \\frac{2\\pi}{3}\\Delta s$。当 $\\Delta s=1$ 时，相位为 $2\\pi/3$。当 $\\Delta s=-5$ 时，相位为 $-10\\pi/3 \\equiv 2\\pi/3 \\pmod{2\\pi}$。余弦值为 $\\cos(2\\pi/3)=-1/2$。可观测量总是 $\\frac{1}{3}(2(-\\frac{1}{2})+1) = 0.0$。因此，平均值为 $0.0$。\n\n实现将直接反映这一逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    It iterates through the test cases, computes the averaged Wilson loop for each,\n    and prints the results in the required format.\n    \"\"\"\n\n    def get_link_matrix(case_id, params, coords, mu):\n        \"\"\"\n        Generates the SU(3) link matrix U_mu(x) on-the-fly.\n        \n        Args:\n            case_id (int): The test case number (1-4).\n            params (dict): A dictionary containing case-specific parameters.\n            coords (tuple): A 4-tuple of integer coordinates (x, y, z, t).\n            mu (int): The direction index (0 for x, 1 for y, 2 for z, 3 for t).\n\n        Returns:\n            numpy.ndarray: The 3x3 SU(3) link matrix.\n        \"\"\"\n        if case_id in [1, 4]:\n            return np.identity(3, dtype=np.complex128)\n        \n        # For cases 2 and 3, spatial links are identity matrices.\n        if mu in [0, 1, 2]:\n            return np.identity(3, dtype=np.complex128)\n\n        # Temporal links (mu=3) for cases 2 and 3.\n        if case_id == 2:\n            x_coord = coords[0]\n            alpha = params['alpha']\n            phase = alpha * x_coord\n            return np.diag([np.exp(1j * phase), np.exp(-1j * phase), 1.0 + 0.0j])\n        \n        elif case_id == 3:\n            x, y, z = coords[0], coords[1], coords[2]\n            L_x = params['L'][0]\n            s = (x + y + z) % L_x\n            alpha = params['alpha']\n            phase = alpha * s\n            return np.diag([np.exp(1j * phase), np.exp(-1j * phase), 1.0 + 0.0j])\n        \n        # Fallback, should not be reached with valid inputs.\n        return np.identity(3, dtype=np.complex128)\n\n    def compute_average_wilson_loop(case_id, L, R, T):\n        \"\"\"\n        Computes the ensemble-averaged Wilson loop for a given deterministic ensemble.\n        \n        The averaging is performed over all spatial and temporal translations of the loop,\n        and over the three possible spatial orientations of the loop plane.\n        \n        Args:\n            case_id (int): The test case number.\n            L (tuple): Lattice dimensions (Lx, Ly, Lz, Lt).\n            R (int): Spatial extent of the Wilson loop.\n            T (int): Temporal extent of the Wilson loop.\n\n        Returns:\n            float: The computed average Wilson loop value W(R, T).\n        \"\"\"\n        params = {'L': L}\n        if case_id in [2, 3]:\n            params['alpha'] = 2 * np.pi / L[0]\n            \n        Nc = 3.0\n        total_observable_sum = 0.0\n        total_loop_count = 0\n\n        L_x, L_y, L_z, L_t = L\n        \n        # 1. Average over cubic rotations (orienting the spatial side of the loop)\n        for s_dir in range(3):\n            # 2. Average over all temporal origins\n            for t_start in range(L_t):\n                # 3. Average over all spatial origins\n                for z_start in range(L_z):\n                    for y_start in range(L_y):\n                        for x_start in range(L_x):\n                            start_coords = [x_start, y_start, z_start, t_start]\n                            current_coords = list(start_coords)\n                            \n                            loop_product = np.identity(3, dtype=np.complex128)\n\n                            # Path 1: Forward in spatial direction `s_dir` for R steps\n                            for _ in range(R):\n                                link = get_link_matrix(case_id, params, tuple(current_coords), s_dir)\n                                loop_product = link @ loop_product\n                                current_coords[s_dir] = (current_coords[s_dir] + 1) % L[s_dir]\n\n                            # Path 2: Forward in temporal direction `t_dir=3` for T steps\n                            t_dir = 3\n                            for _ in range(T):\n                                link = get_link_matrix(case_id, params, tuple(current_coords), t_dir)\n                                loop_product = link @ loop_product\n                                current_coords[t_dir] = (current_coords[t_dir] + 1) % L[t_dir]\n\n                            # Path 3: Backward in spatial direction `s_dir` for R steps\n                            for _ in range(R):\n                                current_coords[s_dir] = (current_coords[s_dir] - 1 + L[s_dir]) % L[s_dir]\n                                link = get_link_matrix(case_id, params, tuple(current_coords), s_dir)\n                                link_dagger = link.conj().T\n                                loop_product = link_dagger @ loop_product\n\n                            # Path 4: Backward in temporal direction `t_dir=3` for T steps\n                            for _ in range(T):\n                                current_coords[t_dir] = (current_coords[t_dir] - 1 + L[t_dir]) % L[t_dir]\n                                link = get_link_matrix(case_id, params, tuple(current_coords), t_dir)\n                                link_dagger = link.conj().T\n                                loop_product = link_dagger @ loop_product\n\n                            observable = (1.0 / Nc) * np.trace(loop_product).real\n                            total_observable_sum += observable\n                            total_loop_count += 1\n        \n        if total_loop_count == 0:\n            # This case occurs if the lattice volume is zero, not expected here.\n            return 0.0\n        \n        return total_observable_sum / total_loop_count\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'case_id': 1, 'L': (4, 4, 4, 4), 'R': 2, 'T': 3},\n        {'case_id': 2, 'L': (8, 8, 8, 6), 'R': 3, 'T': 2},\n        {'case_id': 3, 'L': (6, 6, 6, 4), 'R': 1, 'T': 2},\n        {'case_id': 4, 'L': (4, 4, 4, 4), 'R': 0, 'T': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_average_wilson_loop(case['case_id'], case['L'], case['R'], case['T'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3611747"}, {"introduction": "单个威尔逊圈关联函数虽然包含了静态势的信息，但它也混杂了来自高能激发态的贡献。本实践介绍了一种强大的变分方法，以克服这一挑战，该方法通过构建和求解一个广义本征值问题 (generalized eigenvalue problem, GEVP) [@problem_id:3611706]。通过使用一组具有不同涂抹水平的算符基，你将学会如何系统地分离出基态能量，从而更可靠、更精确地确定静态夸克势。", "problem": "你的任务是设计并实现一个完整的程序，该程序为 Wilson 圈 $W(R,T)$ 中的一组不同弥散程度的空间线算符构建并求解一个变分问题，以提取格点单位下的静态夸克势 $V_0(R)$。该问题必须从第一性原理出发进行构建，并通过广义本征值方法求解，该方法源于在欧几里得时间演化的传输矩阵诠释下对一个合适的 Rayleigh 商进行最小化。其潜在的物理背景是格点量子色动力学（LQCD），但该问题完全以可被普遍实现的数学术语进行规定。\n\n从以下基本基础开始：\n- Wilson 圈 $W(R,T)$ 探测一个空间距离为 $R$、欧几里得时间范围为 $T$ 的静态夸克-反夸克对之间的相互作用。\n- 传输矩阵形式体系意味着欧几里得关联函数可以根据能量本征态进行谱分解。\n- 对于一个由 $N$ 个独立算符 $\\{\\mathcal{O}_i\\}$ 构成的基，这些算符由 Wilson 圈在分离距离 $R$ 处的不同弥散程度的空间线构造而成，其在欧几里得时间 $T$ 的关联矩阵是一个实对称正定矩阵，其矩阵元编码了这些算符与能量本征态的交叠以及它们的欧几里得时间传播。\n\n基于这些原理，按以下步骤进行：\n1. 为选定的算符基构建一个模型关联矩阵 $C_{ij}(T)$，该矩阵通过具有有限数量能量本征态和固定交叠的谱表示来表达。具体来说，假设在分离距离 $R$ 处存在 $M$ 个能量本征态，其能量在格点单位下为 $E_n(R)$（无量纲），并且算符 $\\mathcal{O}_i$ 到态 $n$ 上的交叠为 $Z_i^{(n)}$。关联矩阵元通过对能量本征态求和定义，并带有欧几里得时间依赖性。你的程序必须对每个欧几里得时间 $T$，根据给定的 $E_n$ 和 $Z_i^{(n)}$ 构建矩阵 $C(T)$。\n2. 从欧几里得时间演化下的变分原理出发，推导为在固定 $R$ 处优化地提取基态所需的广义本征值问题。你必须建立并求解在两个欧几里得时间 $T$ 和 $T_0$ 处的关联矩阵（使用相同的算符基）之间的广义本征值问题，并确定主广义本征值 $\\lambda_0(T,T_0)$。\n3. 使用主广义本征值，通过在连续时间上的比值来估计格点单位下的静态势 $V_0(R)$。具体来说，当格点间距设为 $a = 1$（无量纲格点单位）时，定义估计量\n$$\nV_0^{\\text{eff}}(R;T_{\\text{eval}},T_0) \\equiv -\\ln\\left(\\frac{\\lambda_0(T_{\\text{eval}},T_0)}{\\lambda_0(T_{\\text{eval}}-1,T_0)}\\right).\n$$\n你的程序必须为每个提供的测试用例计算此估计量。\n\n所有量均使用无量纲格点单位。能量必须以浮点数形式报告。不涉及任何角度。最终输出必须是单行，形式为一个包含在方括号内的逗号分隔列表。每个条目必须是 $V_0^{\\text{eff}}(R;T_{\\text{eval}},T_0)$ 的值，按以下测试用例的顺序排列，并四舍五入到六位小数。\n\n测试套件和参数说明：\n对于每个测试用例，你将获得算符基维度 $N$、态的数量 $M$、能量 $\\{E_n\\}$ 以及形状为 $N \\times M$ 的交叠矩阵 $Z$，同时还有 $T_0$ 和 $T_{\\text{eval}}$（均以格点单位计）。按照步骤 1 中的说明，为非负整数 $T$ 构建 $C(T)$，然后执行步骤 2 和 3。\n\n- 测试用例 1 (理想路径):\n  - $R = 3$\n  - $N = 3$, $M = 3$\n  - 能量: $\\{E_n\\} = \\{0.5, 0.8, 1.4\\}$\n  - 交叠:\n    $$\n    Z = \\begin{pmatrix}\n    1.0  0.3  0.1 \\\\\n    0.9  0.5  0.2 \\\\\n    0.7  0.2  0.4\n    \\end{pmatrix}\n    $$\n  - $T_0 = 1$, $T_{\\text{eval}} = 5$\n\n- 测试用例 2 (低能谱中的近简并):\n  - $R = 5$\n  - $N = 3$, $M = 3$\n  - 能量: $\\{E_n\\} = \\{0.7, 0.71, 1.3\\}$\n  - 交叠:\n    $$\n    Z = \\begin{pmatrix}\n    1.0  0.2  0.1 \\\\\n    0.8  0.5  0.3 \\\\\n    0.6  0.4  0.2\n    \\end{pmatrix}\n    $$\n  - $T_0 = 2$, $T_{\\text{eval}} = 6$\n\n- 测试用例 3 (算符基小于态的数量):\n  - $R = 2$\n  - $N = 2$, $M = 3$\n  - 能量: $\\{E_n\\} = \\{0.4, 0.9, 1.5\\}$\n  - 交叠:\n    $$\n    Z = \\begin{pmatrix}\n    1.0  0.4  0.2 \\\\\n    0.7  0.3  0.1\n    \\end{pmatrix}\n    $$\n  - $T_0 = 0$, $T_{\\text{eval}} = 7$\n\n程序要求：\n- 根据提供的 $\\{E_n\\}$ 和 $Z$ 为整数 $T \\ge 0$ 实现 $C(T)$ 的构建。\n- 推导并求解 $C(T)$ 和 $C(T_0)$ 之间相应的广义本征值问题，以获得 $\\lambda_0(T,T_0)$。\n- 使用上面定义的比值计算 $V_0^{\\text{eff}}(R;T_{\\text{eval}},T_0)$。\n- 输出单行结果，其中包含三个测试用例的结果，格式为方括号内的逗号分隔浮点数列表，每个浮点数四舍五入到六位小数，例如 $[0.123456,0.234567,0.345678]$。\n\n不允许外部输入；必须完全按照规定对测试套件参数进行硬编码。代码必须是完全自包含的，并能用现代编程语言运行。提取的最终能量必须以无量纲格点单位的浮点数表示，并四舍五入到六位小数。", "solution": "该问题要求实现一种变分方法，用以提取静态夸克势，该势对应于静态夸克-反夸克系统的基态能量 $V_0(R) = E_0(R)$。该方法基于欧几里得时间中关联矩阵的谱性质，这是格点场论计算的基石。\n\n解决方案主要包括三个步骤：\n1.  构建关联矩阵 $C(T)$。\n2.  广义本征值问题 (GEVP) 的构建与求解。\n3.  从主本征值计算有效势 $V_0^{\\text{eff}}$。\n\n让我们首先建立理论基础。\n\n**1. 关联矩阵**\n\n在欧几里得时空中表述的量子场论中，算符 $\\mathcal{O}$ 的两点关联函数可以通过谱分解来表示。通过插入哈密顿量 $\\hat{H}$ 的一组完备能量本征态 $|n\\rangle$（满足 $\\hat{H}|n\\rangle = E_n |n\\rangle$），关联函数变为：\n$$\n\\langle \\mathcal{O}(T) \\mathcal{O}(0) \\rangle = \\langle \\text{vac} | \\mathcal{O} e^{-\\hat{H}T} \\mathcal{O} | \\text{vac} \\rangle = \\sum_n \\langle \\text{vac} | \\mathcal{O} e^{-\\hat{H}T} | n \\rangle \\langle n | \\mathcal{O} | \\text{vac} \\rangle = \\sum_n |\\langle n | \\mathcal{O} | \\text{vac} \\rangle|^2 e^{-E_n T}\n$$\n其中 $T$ 是欧几里得时间间隔，能量 $E_n$ 是相对于真空能测量的，真空能被设为零。\n\n问题指定了一个由 $N$ 个算符构成的基 $\\{\\mathcal{O}_i\\}_{i=1...N}$，这些算符由 Wilson 圈的弥散空间线构造。互关联矩阵元 $C_{ij}(T)$ 由下式给出：\n$$\nC_{ij}(T) = \\langle \\mathcal{O}_i(T) \\mathcal{O}_j(0) \\rangle = \\sum_{n=0}^{M-1} \\langle \\text{vac} | \\mathcal{O}_i | n \\rangle \\langle n | \\mathcal{O}_j | \\text{vac} \\rangle e^{-E_n(R) T}\n$$\n其中 $M$ 是中间态的数量。问题提供了实数交叠系数 $Z_i^{(n)} = \\langle n | \\mathcal{O}_i | \\text{vac} \\rangle$。因此，关联矩阵为：\n$$\nC_{ij}(T) = \\sum_{n=0}^{M-1} Z_i^{(n)} Z_j^{(n)} e^{-E_n(R) T}\n$$\n在矩阵表示法中，设 $Z$ 是一个 $N \\times M$ 的交叠矩阵，其元素为 $Z_{in} = Z_i^{(n)}$， $D(T)$ 是一个 $M \\times M$ 的对角矩阵，其元素为 $D_{nn}(T) = e^{-E_n T}$，则 $N \\times N$ 的关联矩阵为：\n$$\nC(T) = Z D(T) Z^T\n$$\n该矩阵是实对称的。对于 $T \\ge 0$，由于 $e^{-E_n T} > 0$，它也是半正定的。如果 $Z$ 的列向量线性无关且 $N \\le M$，则 $C(T)$ 是正定的。\n\n**2. 广义本征值问题 (GEVP)**\n\n变分法旨在寻找基算符的一个最优线性组合 $\\Phi = \\sum_i v_i \\mathcal{O}_i$，使其与特定的能量本征态（主要是基态 $|0\\rangle$）具有最佳交叠。系数向量为 $\\mathbf{v} = (v_1, v_2, \\dots, v_N)^T$。\n\n这个优化算符的关联函数期望值为 $\\langle \\Phi(T) \\Phi(0) \\rangle = \\mathbf{v}^T C(T) \\mathbf{v}$。为了提取基态能量，我们考虑在两个不同时间 $T$ 和一个参考时间 $T_0  T$ 的关联函数之比：\n$$\n\\lambda(\\mathbf{v}) = \\frac{\\langle \\Phi(T) \\Phi(0) \\rangle}{\\langle \\Phi(T_0) \\Phi(0) \\rangle} = \\frac{\\mathbf{v}^T C(T) \\mathbf{v}}{\\mathbf{v}^T C(T_0) \\mathbf{v}}\n$$\n这是一个 Rayleigh 商。当时间间隔很大时，基态项在谱求和中占主导地位，该比值趋近于 $e^{-E_0 (T-T_0)}$。\n\n为了找到能够分离出单个能级的最优向量 $\\mathbf{v}$，我们通过将其关于 $\\mathbf{v}$ 的梯度设为零来寻找 $\\lambda(\\mathbf{v})$ 的驻点。这个过程导出了广义本征值问题：\n$$\nC(T) \\mathbf{v}_n = \\lambda_n(T, T_0) C(T_0) \\mathbf{v}_n\n$$\n这 $N$ 个实数本征值 $\\lambda_n(T, T_0)$ 近似了与算符基有非零交叠的 $N$ 个最低能量态的指数衰减：\n$$\n\\lambda_n(T, T_0) \\approx e^{-E_n (T-T_0)}\n$$\n主本征值 $\\lambda_0(T, T_0)$ 是最大的本征值，对应于基态能量 $E_0$。\n\n**3. 有效势估计量**\n\n从主本征值出发，我们可以构建基态能量 $E_0(R)$（即静态势 $V_0(R)$）的估计量。可以提取出一个有效能量，在此即为有效势。问题指定了一个由连续时间步的主本征值之比构造的特定估计量：\n$$\nV_0^{\\text{eff}}(R; T_{\\text{eval}}, T_0) \\equiv -\\ln\\left(\\frac{\\lambda_0(T_{\\text{eval}}, T_0)}{\\lambda_0(T_{\\text{eval}}-1, T_0)}\\right)\n$$\n代入本征值的长时间行为，我们可以看到其原理：\n$$\n\\frac{\\lambda_0(T_{\\text{eval}}, T_0)}{\\lambda_0(T_{\\text{eval}}-1, T_0)} \\approx \\frac{e^{-E_0 (T_{\\text{eval}}-T_0)}}{e^{-E_0 (T_{\\text{eval}}-1-T_0)}} = e^{-E_0 (T_{\\text{eval}}-T_0 - (T_{\\text{eval}}-1-T_0))} = e^{-E_0}\n$$\n因此，$V_0^{\\text{eff}} \\approx - \\ln(e^{-E_0}) = E_0$。这种基于比值的估计量旨在消除来自高能态污染的领头阶系统误差，从而提供对基态能量更稳定的估计。\n\n计算步骤如下：\n对于每个具有参数 $N$、$M$、$\\{E_n\\}$、$Z$、$T_0$ 和 $T_{\\text{eval}}$ 的测试用例：\n1.  构建三个 $N \\times N$ 关联矩阵：$C(T_{\\text{eval}})$、$C(T_{\\text{eval}}-1)$ 和 $C(T_0)$。格点间距为 $a=1$。\n2.  求解两个独立的广义本征值问题 (GEVP)：\n    a. $C(T_{\\text{eval}}) \\mathbf{v} = \\lambda C(T_0) \\mathbf{v}$\n    b. $C(T_{\\text{eval}}-1) \\mathbf{v} = \\lambda' C(T_0) \\mathbf{v}$\n3.  从每个解中提取主（最大）本征值，我们分别记为 $\\lambda_0(T_{\\text{eval}}, T_0)$ 和 $\\lambda_0(T_{\\text{eval}}-1, T_0)$。由于针对对称 GEVP 的标准数值求解器返回按升序排列的本征值，主本征值将是返回数组中的最后一个元素。\n4.  使用提供的公式计算有效势。\n5.  将最终结果四舍五入到六位小数。\n\n此过程构成了对所述问题的完整而严谨的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solving process for all test cases.\n    It hard-codes the test cases, iterates through them, computes the\n    static potential for each, and prints the formatted results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"R\": 3,\n            \"N\": 3, \"M\": 3,\n            \"energies\": np.array([0.5, 0.8, 1.4]),\n            \"overlaps\": np.array([\n                [1.0, 0.3, 0.1],\n                [0.9, 0.5, 0.2],\n                [0.7, 0.2, 0.4]\n            ]),\n            \"T0\": 1,\n            \"T_eval\": 5\n        },\n        {\n            \"R\": 5,\n            \"N\": 3, \"M\": 3,\n            \"energies\": np.array([0.7, 0.71, 1.3]),\n            \"overlaps\": np.array([\n                [1.0, 0.2, 0.1],\n                [0.8, 0.5, 0.3],\n                [0.6, 0.4, 0.2]\n            ]),\n            \"T0\": 2,\n            \"T_eval\": 6\n        },\n        {\n            \"R\": 2,\n            \"N\": 2, \"M\": 3,\n            \"energies\": np.array([0.4, 0.9, 1.5]),\n            \"overlaps\": np.array([\n                [1.0, 0.4, 0.2],\n                [0.7, 0.3, 0.1]\n            ]),\n            \"T0\": 0,\n            \"T_eval\": 7\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_static_potential(case)\n        results.append(result)\n\n    # Format and print the final results as specified.\n    # The rounding to 6 decimal places is done by the formatting string.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef build_correlation_matrix(T, energies, overlaps):\n    \"\"\"\n    Constructs the correlation matrix C(T) for a given Euclidean time T.\n    \n    The formula is C(T) = Z * D(T) * Z^T, where Z is the NxM overlap matrix\n    and D(T) is an MxM diagonal matrix with elements D_nn = exp(-E_n * T).\n\n    Args:\n        T (int): The Euclidean time separation.\n        energies (np.ndarray): A 1D array of M energy eigenvalues.\n        overlaps (np.ndarray): An NxM matrix of overlap coefficients Z.\n\n    Returns:\n        np.ndarray: The NxN correlation matrix C(T).\n    \"\"\"\n    # Create the diagonal matrix D(T)\n    diag_elements = np.exp(-energies * T)\n    D_T = np.diag(diag_elements)\n    \n    # Calculate C(T) = Z @ D(T) @ Z.T\n    C_T = overlaps @ D_T @ overlaps.T\n    return C_T\n\ndef get_principal_eigenvalue(C_T, C_T0):\n    \"\"\"\n    Solves the generalized eigenvalue problem C(T)v = lambda * C(T0)v and\n    returns the principal (largest) eigenvalue.\n\n    Args:\n        C_T (np.ndarray): The correlation matrix at time T.\n        C_T0 (np.ndarray): The correlation matrix at reference time T0.\n\n    Returns:\n        float: The principal generalized eigenvalue.\n    \"\"\"\n    # The matrices are real and symmetric, C_T0 is positive definite.\n    # scipy.linalg.eigh solves the GEVP for Hermitian matrices,\n    # returning eigenvalues sorted in ascending order.\n    eigenvalues = linalg.eigh(C_T, C_T0, eigvals_only=True)\n    \n    # The principal eigenvalue corresponds to the ground state and is the largest.\n    principal_eigenvalue = eigenvalues[-1]\n    return principal_eigenvalue\n\ndef calculate_static_potential(params):\n    \"\"\"\n    Calculates the effective static potential V_0^eff for a single test case.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the case.\n\n    Returns:\n        float: The calculated effective static potential.\n    \"\"\"\n    energies = params[\"energies\"]\n    overlaps = params[\"overlaps\"]\n    T0 = params[\"T0\"]\n    T_eval = params[\"T_eval\"]\n    \n    # 1. Construct the required correlation matrices\n    C_T_eval = build_correlation_matrix(T_eval, energies, overlaps)\n    C_T_eval_minus_1 = build_correlation_matrix(T_eval - 1, energies, overlaps)\n    C_T0 = build_correlation_matrix(T0, energies, overlaps)\n    \n    # 2. Solve the two GEVPs to find the principal eigenvalues\n    lambda_0_eval = get_principal_eigenvalue(C_T_eval, C_T0)\n    lambda_0_eval_minus_1 = get_principal_eigenvalue(C_T_eval_minus_1, C_T0)\n    \n    # 3. Compute the effective static potential estimator\n    # The formula is V_eff = -ln(lambda_0(T_eval) / lambda_0(T_eval - 1))\n    ratio = lambda_0_eval / lambda_0_eval_minus_1\n    V_eff = -np.log(ratio)\n    \n    return V_eff\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3611706"}, {"introduction": "格点 QCD 计算产生的是无量纲的格点单位结果，要将其与物理世界联系起来，必须“设定标度”。最后的这个练习聚焦于这一关键步骤，指导你直接从学到的如何提取的离散静态势数据 $V(R)$ 中，确定强子物理学中的一个标准参考标度——索末标度 (Sommer scale) $r_0$ [@problem_id:3611702]。你将实现稳健的数值方法来计算夸克间力并求解 $r_0$ 的定义方程，从而完成从原始格点可观测量到物理量的整个过程。", "problem": "考虑在格点量子色动力学 (QCD) 中从矩形威尔逊圈提取静态夸克势，其中格点单位下的静态夸克势是从大时间尺度的矩形圈中获得的。在此设定中，静态势是空间间隔的函数，记为 $V(R)$，其中 $R$ 以格点间距为单位进行测量。Sommer 标度 $r_0$ 由条件 $r_0^2 F(r_0) = c$ 隐式定义，其中 $F(r) = \\frac{dV}{dr}$ 是夸克间力，而 $c = 1.65$。任务是根据 $V(R)$ 在整数 $R$ 值上的离散测量值，直接在格点单位下计算 $r_0/a$，其中 $a$ 是格点间距。\n\n仅从以下核心定义出发：\n- 在大时间尺度极限下，威尔逊圈与静态夸克势之间的关系，\n- 力的定义为空间导数 $F(r) = \\frac{dV}{dr}$，\n- 以及隐式 Sommer 标度条件 $r_0^2 F(r_0) = c$（其中 $c = 1.65$），\n设计并实现一个稳定的数值程序，从离散数据 $\\{(R_i, V_i)\\}$ 估算 $r_0/a$。\n\n您的实现必须：\n1. 将 $R$ 和 $V(R)$ 视为无量纲的格点量，并计算 $r_0/a$ 作为一个无量纲数。\n2. 对离散的 $V(R)$ 数据构建一个保形插值，该插值需足够光滑以允许稳定的数值微分。使用一种能够避免伪振荡并在 $V(R)$ 存在单调性时保持其单调性的插值方法。然后，对插值函数求导，以获得在最小和最大观测间隔之间的开区间上对 $F(r)$ 的连续近似。\n3. 在定义域 $(R_{\\min}, R_{\\max})$ 内求解非线性方程 $r^2 F(r) - c = 0$ 以得到 $r$，其中 $R_{\\min}$ 和 $R_{\\max}$ 是最小和最大的采样间隔。使用区间法策略以确保一个稳健的求根过程。如果由于轻微的数据不规则性而在插值域内无法找到符号变化，则使用一个基于物理动机的势的光滑拟合来对导数进行正则化，并在该拟合模型上重复求根。\n4. 返回四舍五入到六位小数的结果。\n\n测试套件：\n对于以下五个测试用例，输入包括一个间隔列表 $R$ 和一个相应的势列表 $V(R)$，所有数值均以格点单位给出。对于每个案例，计算一个等于 $r_0/a$ 的浮点数，满足 $r_0^2 F(r_0) = 1.65$。下面提供的所有数字均以格点单位给出，并应被视为程序的精确输入。\n\n- 案例 A：\n  - $R = [1, 2, 3, 4, 5, 6, 7, 8]$\n  - $V = [0.38, 0.71, 0.94, 1.145, 1.34, 1.53, 1.7171428571, 1.9025]$\n- 案例 B：\n  - $R = [1, 2, 3, 4, 5, 6, 7, 8]$\n  - $V = [0.3785, 0.713, 0.9355, 1.151, 1.3325, 1.539, 1.7066428571, 1.9145]$\n- 案例 C：\n  - $R = [2, 3, 4, 5, 6]$\n  - $V = [0.715, 0.9766666667, 1.2175, 1.45, 1.6783333333]$\n- 案例 D：\n  - $R = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]$\n  - $V = [0.51, 0.72, 0.8966666667, 1.065, 1.23, 1.3933333333, 1.5557142857, 1.7175, 1.8788888889, 2.04]$\n- 案例 E：\n  - $R = [1, 2, 3, 4, 5, 6, 7]$\n  - $V = [0.54, 0.87, 1.1133333333, 1.345, 1.548, 1.7566666667, 1.9628571429]$\n\n对数值方法和输出的要求：\n- 使用适用于单调数据的保形方案对 $V(R)$ 进行插值，然后求导以近似 $F(r)$，其中 $r \\in (R_{\\min}, R_{\\max})$。\n- 对 $g(r) = r^2 F(r) - 1.65$ 使用区间求根器。\n- 如果由于轻微的不规则性而找不到区间，则通过与短程吸引和长程线性增长一致的光滑三参数拟合对 $V(R)$ 进行正则化，并再次求解 $r$。\n- 输出单行，包含一个用逗号分隔、方括号括起且无空格的列表，该列表按 A, B, C, D, E 的顺序汇集了五个案例的 $r_0/a$ 值。每个值必须四舍五入到六位小数。例如，格式必须为“[x_A,x_B,x_C,x_D,x_E]”，其中每个 $x$ 是一个四舍五入到六位小数的浮点数。", "solution": "该问题要求根据格点量子色动力学 (QCD) 中静态夸克势 $V(R)$ 的离散数据计算 Sommer 标度，记为 $r_0$。这些量均以格点单位给出，因此空间间隔 $R$ 是格点间距 $a$ 的整数倍，而势 $V(R)$ 是无量纲的。目标是计算无量纲比值 $r_0/a$。\n\n### 步骤 1：问题形式化\nSommer 标度 $r_0$ 由以下方程隐式定义：\n$$\nr_0^2 F(r_0) = c\n$$\n其中 $F(r) = \\frac{dV}{dr}$ 是静态夸克之间的力，$c$ 是一个常数，设定为 $1.65$。由于所有量都以格点单位提供，我们实际上是在求解 $r = r_0/a$。因此，问题简化为求解非线性函数 $g(r)$ 的根：\n$$\ng(r) = r^2 F(r) - c = 0\n$$\n输入是一组离散数据点 $\\{(R_i, V_i)\\}$，其中 $R_i$ 是间隔，$V_i = V(R_i)$ 是对应的势值。为了解这个方程，我们首先需要从离散的势数据 $V_i$ 中获得力的连续表示 $F(r)$。这必须在观测到的间隔的开区间 $(R_{\\min}, R_{\\max})$ 内完成。\n\n### 步骤 2：数值策略\n为了确保得到一个稳健的解，我们设计了一种双管齐下的数值策略，正如问题所规定的。首先尝试一种基于插值的主要方法。如果该方法因数据不规则而失败，则采用一种基于物理模型拟合的后备方法。\n\n#### 主要方法：插值与求根\n此方法包括两个阶段：\n1.  **插值与微分**：对离散的势数据 $(R_i, V_i)$ 进行插值，以获得一个连续函数 $V_{\\text{interp}}(r)$。问题指定了一种保形插值方案，以避免伪振荡并尊重数据的单调性。分段三次埃尔米特插值多项式 (PCHIP) 是实现此目的的绝佳选择。它确保插值函数在数据单调的任何区间上也是单调的。`scipy.interpolate.PchipInterpolator` 提供了这样的功能。一旦构建了插值函数 $V_{\\text{interp}}(r)$，其导数 $F_{\\text{interp}}(r) = \\frac{dV_{\\text{interp}}}{dr}$ 就可以通过解析或数值方法计算。`PchipInterpolator` 对象方便地提供了一个方法来获取其导数的可调用函数，该导数是一个连续的分段二次多项式。\n\n2.  **求根**：有了连续的力函数 $F_{\\text{interp}}(r)$，我们可以定义 $g(r) = r^2 F_{\\text{interp}}(r) - c$。问题要求使用一种区间求根算法。我们将使用 Brent-Dekker 方法，其实现为 `scipy.optimize.brentq`。该方法需要一个区间 $[r_a, r_b]$，使得 $g(r_a)$ 和 $g(r_b)$ 异号。通过遍历输入数据点定义的区间 $[R_i, R_{i+1}]$ 并检查是否存在符号变化（即 $g(R_i) \\cdot g(R_{i+1})  0$）来搜索这样的区间。如果找到一个区间，就使用 `brentq` 来高精度地找到根 $r = r_0/a$。\n\n#### 后备方法：通过函数拟合进行正则化\n如果主要方法在任何区间 $[R_i, R_{i+1}]$ 上都未能定位到一个符号变化的区间，这表明数据中轻微的不规则性或噪声产生的数值导数 $F_{\\text{interp}}(r)$ 使得函数 $g(r)$ 在通过网格点 $R_i$ 采样时无法检测到零点穿越。在这种情况下，我们采用一种正则化程序。\n\n1.  **物理模型拟合**：静态夸克势可以很好地由 Cornell 势模型描述，该模型包含了预期的短程吸引（类库仑）和长程线性禁闭的特征。其函数形式为：\n    $$\n    V_{\\text{fit}}(r) = -\\frac{\\alpha}{r} + \\sigma r + V_0\n    $$\n    参数 $(\\alpha, \\sigma, V_0)$ 通过对离散数据 $(R_i, V_i)$ 进行非线性最小二乘拟合来确定。这可以通过 `scipy.optimize.curve_fit` 实现。这种拟合提供了一种光滑的、有物理动机的势的表示，它对数据中的微小局部波动不那么敏感。\n\n2.  **解析解**：对于 Cornell 势，力由其导数给出：\n    $$\n    F_{\\text{fit}}(r) = \\frac{dV_{\\text{fit}}}{dr} = \\frac{\\alpha}{r^2} + \\sigma\n    $$\n    将此代入 Sommer 标度方程得到：\n    $$\n    r^2 \\left( \\frac{\\alpha}{r^2} + \\sigma \\right) - c = 0\n    $$\n    这简化为 $\\alpha + \\sigma r^2 - c = 0$，可以解析地解出 $r = r_0/a$：\n    $$\n    r = \\sqrt{\\frac{c - \\alpha}{\\sigma}}\n    $$\n    只要拟合参数是物理的（即 $\\sigma > 0$ 且 $c > \\alpha$），这就为 Sommer 标度提供了一个稳定、正则化的估计。\n\n### 步骤 3：算法实现\n整个算法在一个 Python 函数中实现。对于每个测试用例：\n1.  一个 `try` 代码块尝试主要方法。它初始化 PCHIP 插值器及其导数。然后，它遍历数据区间 $[R_i, R_{i+1}]$，尝试使用 `brentq` 求解根。如果找到根，函数返回该值，四舍五入到六位小数。\n2.  如果所有 `brentq` 调用都失败，则会引发一个 `ValueError`，从而触发 `except` 代码块。\n3.  `except` 代码块实现后备方法。它使用 `curve_fit` 将 Cornell 势拟合到数据，提取参数 $\\alpha$ 和 $\\sigma$，并使用解析公式计算 $r_0/a$。然后返回结果，四舍五入到六位小数。\n这种结构化方法能够稳健地处理干净的数据（插值法更优）和带有微小不规则性的数据（拟合法提供了必要的正则化）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\nfrom scipy.optimize import brentq, curve_fit\n\ndef solve():\n    \"\"\"\n    Main function to solve for the Sommer scale for all test cases.\n    \"\"\"\n    # The constant c in the Sommer scale definition r_0^2 F(r_0) = c.\n    C_SOMMER = 1.65\n\n    def solve_case(R, V):\n        \"\"\"\n        Computes the Sommer scale r_0/a for a single set of potential data.\n\n        This function implements a two-stage process:\n        1. Primary Method: Uses PCHIP interpolation to get a continuous Force F(r)\n           and finds the root of r^2*F(r) - c = 0 using a bracketing solver.\n        2. Fallback Method: If the primary method fails (due to data irregularities\n           preventing a bracket from being found), it fits the data to a Cornell\n           potential V(r) = -alpha/r + sigma*r + V0 and solves for r_0/a analytically.\n        \"\"\"\n        R_np = np.array(R, dtype=np.float64)\n        V_np = np.array(V, dtype=np.float64)\n\n        # === Primary Method: Interpolation and Root Finding ===\n        try:\n            # 1. Create a shape-preserving interpolator and its derivative (the force)\n            v_interp = PchipInterpolator(R_np, V_np)\n            f_interp = v_interp.derivative(nu=1)\n\n            # 2. Define the function g(r) whose root we need to find\n            def g(r):\n                # The Sommer scale equation: r^2 * F(r) - c = 0\n                return r**2 * f_interp(r) - C_SOMMER\n\n            # 3. Search for a bracket and solve using brentq\n            # Iterate over intervals defined by the data points.\n            for i in range(len(R_np) - 1):\n                r_a, r_b = R_np[i], R_np[i+1]\n                # Brentq will raise a ValueError if g(r_a) and g(r_b) do not have\n                # opposite signs. We catch this and continue to the next interval.\n                try:\n                    root = brentq(g, r_a, r_b)\n                    return round(root, 6)\n                except ValueError:\n                    continue\n            \n            # If the loop completes without finding a root, it means no bracket\n            # was found between adjacent data points. This triggers the fallback.\n            raise ValueError(\"No bracket found for root finding via interpolation.\")\n\n        # === Fallback Method: Regularization via Fit ===\n        except (ValueError, RuntimeError):\n            # 1. Define the Cornell potential model for fitting\n            def cornell_potential(r, alpha, sigma, v0):\n                return -alpha / r + sigma * r + v0\n\n            # 2. Fit the model to the data to get the parameters\n            # Initial guess for [alpha, sigma, v0] based on typical lattice QCD values.\n            p0 = [0.3, 0.2, 0.6]\n            \n            popt, _ = curve_fit(cornell_potential, R_np, V_np, p0=p0, maxfev=10000)\n            alpha, sigma = popt[0], popt[1]\n\n            # 3. Calculate r_0/a using the analytical formula for the Cornell potential\n            # Check for physical parameters to ensure the argument of sqrt is positive.\n            if sigma = 0 or C_SOMMER - alpha  0:\n                # Should not happen with the provided data, but is a necessary check.\n                raise RuntimeError(\"Fit resulted in unphysical parameters.\")\n            \n            r0_lat_sq = (C_SOMMER - alpha) / sigma\n            root = np.sqrt(r0_lat_sq)\n            \n            return round(root, 6)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        ([1, 2, 3, 4, 5, 6, 7, 8], [0.38, 0.71, 0.94, 1.145, 1.34, 1.53, 1.7171428571, 1.9025]),\n        # Case B\n        ([1, 2, 3, 4, 5, 6, 7, 8], [0.3785, 0.713, 0.9355, 1.151, 1.3325, 1.539, 1.7066428571, 1.9145]),\n        # Case C\n        ([2, 3, 4, 5, 6], [0.715, 0.9766666667, 1.2175, 1.45, 1.6783333333]),\n        # Case D\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [0.51, 0.72, 0.8966666667, 1.065, 1.23, 1.3933333333, 1.5557142857, 1.7175, 1.8788888889, 2.04]),\n        # Case E\n        ([1, 2, 3, 4, 5, 6, 7], [0.54, 0.87, 1.1133333333, 1.345, 1.548, 1.7566666667, 1.9628571429])\n    ]\n\n    results = []\n    for R_data, V_data in test_cases:\n        result = solve_case(R_data, V_data)\n        # Format to exactly six decimal places for the output string.\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3611702"}]}