{"hands_on_practices": [{"introduction": "为了将理论知识转化为实践能力，我们首先从一个基本而强大的方法——传输矩阵法——开始。这个练习将指导你从薛定谔方程的第一性原理出发，推导并实现计算粒子穿过多层分段常数势垒的透射概率。通过这个实践 [@problem_id:3575889]，你不仅能掌握一种精确的数值技术，还能深化对量子力学中波函数连续性条件和矩阵形式主义的理解。", "problem": "考虑一个质量为 $m$ 的非相对论性粒子从左侧入射到一个一维分段常数势 $V(x)$ 上。该势场由一系列有限层构成，每层都具有恒定的势值和有限的宽度，并嵌入在左右两侧的半无限常数势引线之间。你的目标是从定态薛定谔方程出发，使用传输矩阵法计算粒子穿过该结构的透射概率。你必须推导、实现并使用该方法，而不能依赖任何预先给出的公式。\n\n从一个质量为 $m$、能量为 $E$ 的粒子在一维空间中的定态薛定谔方程出发，\n$$\n-\\frac{\\hbar^2}{2m}\\frac{d^2\\psi(x)}{dx^2} + V(x)\\psi(x) = E \\psi(x),\n$$\n以及波函数 $\\psi(x)$ 及其空间导数 $d\\psi(x)/dx$ 在分段常数势的每个界面处都必须是连续的这一要求。在每个势为常数的区域，当能量 $E$ 高于局部势时，通解是右行和左行平面波的叠加；当 $E$ 低于局部势时，通解是衰减或增长的指数函数。仅从这些事实出发，推导一个逐层的线性表示，该表示将左引线中的右行/左行振幅与右引线中的相应振幅联系起来。使用该表示来获得从左侧入射波的透射振幅，进而得到透射概率。假设粒子质量 $m$ 在所有区域都是恒定的。你必须仅根据上述基本原理来论证你推导过程中的每一步。\n\n采用计算核物理中常用的以下物理上一致的单位约定：\n- 能量单位必须是兆电子伏（MeV）。\n- 长度单位必须是飞米（fm）。\n- 质量单位必须是兆电子伏每光速平方（MeV/c$^2$）。\n- 使用常数 $\\hbar c = 197.3269804$ MeV·fm。\n- 在每个势为常数 $V$ 的均匀区域中，定义复波数\n$$\nk = \\frac{\\sqrt{2m\\,(E - V)}}{\\hbar c},\n$$\n其中平方根在复平面上取值，因此当 $E  V$ 时，波数变为纯虚数。", "solution": "该问题要求计算一个量子粒子穿过一维分段常数势垒结构的透射概率。所使用的方法是传输矩阵形式，它源自量子力学的第一性原理，即定态薛定谔方程以及波函数及其一阶导数的连续性。\n\n让我们从分析一个势为常数 $V_j$ 的单一均匀区域 $j$ 开始。一维定态薛定谔方程为\n$$\n-\\frac{\\hbar^2}{2m}\\frac{d^2\\psi(x)}{dx^2} + V_j\\psi(x) = E \\psi(x)\n$$\n这可以被改写为\n$$\n\\frac{d^2\\psi(x)}{dx^2} + k_j^2\\psi(x) = 0\n$$\n其中 $k_j$ 是复波数，定义为\n$$\nk_j = \\frac{\\sqrt{2m(E - V_j)}}{\\hbar c}\n$$\n使用复数平方根可确保，在能量 $E$ 小于势 $V_j$ 的势垒情况下，波数变为纯虚数 $k_j = i\\kappa_j$，其中 $\\kappa_j = \\frac{\\sqrt{2m(V_j - E)}}{\\hbar c}$ 是一个实的正衰减常数。\n\n粒子在任意点 $x$ 的状态可以由一个包含波函数 $\\psi(x)$ 及其空间导数 $\\psi'(x)$ 的二分量矢量完全描述：\n$$\n\\vec{\\Psi}(x) = \\begin{pmatrix} \\psi(x) \\\\ \\psi'(x) \\end{pmatrix}\n$$\n区域 $j$ 中薛定谔方程的通解可以表示为两个独立解的线性组合。一组方便的基是 $\\{\\cos(k_j(x-x_{\\text{ref}})), \\sin(k_j(x-x_{\\text{ref}}))\\}$。让我们将参考位置 $x_{\\text{ref}}$ 设为该区域的左边界，例如 $x_{j-1}$。\n$$\n\\psi(x) = C_1 \\cos(k_j(x-x_{j-1})) + C_2 \\sin(k_j(x-x_{j-1}))\n$$\n导数为\n$$\n\\psi'(x) = k_j(-C_1 \\sin(k_j(x-x_{j-1})) + C_2 \\cos(k_j(x-x_{j-1})))\n$$\n在左边界 $x=x_{j-1}$ 处，我们有 $\\psi(x_{j-1}) = C_1$ 和 $\\psi'(x_{j-1}) = k_j C_2$。这使我们能够用 $x_{j-1}$ 处的态矢量来表示系数 $C_1$ 和 $C_2$。将它们代回，我们可以用 $x_{j-1}$ 处的态矢量来表示区域内任何其他点 $x$ 处的态矢量。对于一个宽度为 $L_j = x_j - x_{j-1}$ 的层，右边界 $x_j$ 处的态矢量通过一个线性变换与左边界 $x_{j-1}$ 处的态矢量相关联：\n$$\n\\vec{\\Psi}(x_j) = P_j(L_j) \\vec{\\Psi}(x_{j-1})\n$$\n矩阵 $P_j(L_j)$ 是该层的传播矩阵：\n$$\nP_j(L_j) = \\begin{pmatrix} \\cos(k_j L_j)  \\frac{1}{k_j}\\sin(k_j L_j) \\\\ -k_j\\sin(k_j L_j)  \\cos(k_j L_j) \\end{pmatrix}\n$$\n通过复三角函数的性质，例如 $\\cos(i\\kappa_j L_j) = \\cosh(\\kappa_j L_j)$ 和 $\\sin(i\\kappa_j L_j)/ (i\\kappa_j) = \\sinh(\\kappa_j L_j)/\\kappa_j$，该形式对于行波（$E  V_j$，实数 $k_j$）和隐失波（$E  V_j$，虚数 $k_j$）都保持有效。\n\n值得注意的是，在 $E=V_j$ 的特殊情况下，波数 $k_j$ 为零。传播矩阵必须在 $k_j \\to 0$ 的极限下求值：\n$$\n\\lim_{k_j \\to 0} P_j(L_j) = \\begin{pmatrix} 1  L_j \\\\ 0  1 \\end{pmatrix}\n$$\n这避免了任何除以零的运算，并正确描述了动能为零时的自由粒子传播。\n\n完整的势结构由位于半无限左引线（区域 0）和半无限右引线（区域 N+1）之间的 $N$ 个层（从 $j=1$ 到 $j=N$）组成。设界面位于位置 $x_0, x_1, \\dots, x_N$。结构的总宽度为 $x_N - x_0 = \\sum_{j=1}^N L_j$。\n在两个相邻区域之间的每个界面 $x_j$ 处，边界条件要求 $\\psi(x)$ 和 $\\psi'(x)$ 都是连续的。这意味着态矢量 $\\vec{\\Psi}(x)$ 在所有界面上都是连续的。\n因此，通过逐次应用每一层的传播矩阵，可以将最终边界 $x_N$ 处的态矢量与初始边界 $x_0$ 处的态矢量联系起来：\n$$\n\\vec{\\Psi}(x_N) = P_N(L_N) \\vec{\\Psi}(x_{N-1}) = P_N(L_N) P_{N-1}(L_{N-1}) \\vec{\\Psi}(x_{N-2}) = \\dots\n$$\n$$\n\\vec{\\Psi}(x_N) = \\left( \\prod_{j=N}^{1} P_j(L_j) \\right) \\vec{\\Psi}(x_0)\n$$\n让我们将整个结构的总传播矩阵定义为 $M_{total} = P_N(L_N) P_{N-1}(L_{N-1}) \\cdots P_1(L_1)$。那么，\n$$\n\\vec{\\Psi}(x_N) = M_{total} \\vec{\\Psi}(x_0)\n$$\n如果没有内部层（$N=0$），$M_{total}$ 是 $2 \\times 2$ 的单位矩阵。\n\n接下来，我们将边界处的态矢量 $\\vec{\\Psi}(x)$ 与引线中的入射、反射和透射平面波的振幅联系起来。在波数为 $k_L$ 的引线区域（例如，左引线，区域 0）中，波函数是右行（入射）波和左行（反射）波的叠加：\n$$\n\\psi_L(x) = A_L e^{ik_L(x - x_0)} + B_L e^{-ik_L(x - x_0)}\n$$\n在边界 $x=x_0$ 处，态矢量为：\n$$\n\\vec{\\Psi}(x_0) = \\begin{pmatrix} \\psi_L(x_0) \\\\ \\psi'_L(x_0) \\end{pmatrix} = \\begin{pmatrix} A_L + B_L \\\\ ik_L(A_L - B_L) \\end{pmatrix} = \\begin{pmatrix} 1  1 \\\\ ik_L  -ik_L \\end{pmatrix} \\begin{pmatrix} A_L \\\\ B_L \\end{pmatrix} = S_{k_L} \\begin{pmatrix} A_L \\\\ B_L \\end{pmatrix}\n$$\n类似地，在波数为 $k_R$ 的右引线（区域 N+1）中，波函数为：\n$$\n\\psi_R(x) = A_R e^{ik_R(x - x_N)} + B_R e^{-ik_R(x - x_N)}\n$$\n在边界 $x=x_N$ 处，态矢量为：\n$$\n\\vec{\\Psi}(x_N) = S_{k_R} \\begin{pmatrix} A_R \\\\ B_R \\end{pmatrix}\n$$\n矩阵 $S_k$ 有一个逆矩阵 $S_k^{-1} = \\frac{1}{2}\\begin{pmatrix} 1  1/(ik) \\\\ 1  -1/(ik) \\end{pmatrix}$。\n\n结合这些关系，我们可以在左右引线中的振幅系数之间建立联系：\n$$\nS_{k_R} \\begin{pmatrix} A_R \\\\ B_R \\end{pmatrix} = \\vec{\\Psi}(x_N) = M_{total} \\vec{\\Psi}(x_0) = M_{total} S_{k_L} \\begin{pmatrix} A_L \\\\ B_L \\end{pmatrix}\n$$\n这就得到了散射矩阵关系。然而，传输矩阵形式是将一侧的振幅与另一侧的振幅联系起来。为了得到满足 $\\begin{pmatrix} A_L \\\\ B_L \\end{pmatrix} = \\mathcal{M} \\begin{pmatrix} A_R \\\\ B_R \\end{pmatrix}$ 的传输矩阵 $\\mathcal{M}$，我们重新排列方程：\n$$\n\\begin{pmatrix} A_L \\\\ B_L \\end{pmatrix} = S_{k_L}^{-1} M_{total}^{-1} S_{k_R} \\begin{pmatrix} A_R \\\\ B_R \\end{pmatrix}\n$$\n因此，振幅传输矩阵为 $\\mathcal{M} = S_{k_L}^{-1} M_{total}^{-1} S_{k_R}$。\n每个传播矩阵 $P_j$ 的行列式为 $\\det(P_j) = \\cos^2(k_jL_j) - (-k_j\\sin(k_jL_j))(\\frac{1}{k_j}\\sin(k_jL_j)) = 1$。因此，$\\det(M_{total})=1$，其逆矩阵很简单：如果 $M_{total} = \\begin{pmatrix} m_{11}  m_{12} \\\\ m_{21}  m_{22} \\end{pmatrix}$，那么 $M_{total}^{-1} = \\begin{pmatrix} m_{22}  -m_{12} \\\\ -m_{21}  m_{11} \\end{pmatrix}$。\n\n为了求出透射概率，我们考虑一个从左侧入射的粒子。这种情况对应于将来自右引线的入射波振幅设为零，即 $B_R=0$。不失一般性，我们可以将来自左侧的入射波振幅设为 1，即 $A_L=1$。\n传输矩阵方程变为：\n$$\n\\begin{pmatrix} 1 \\\\ B_L \\end{pmatrix} = \\mathcal{M} \\begin{pmatrix} A_R \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} \\mathcal{M}_{11} A_R \\\\ \\mathcal{M}_{21} A_R \\end{pmatrix}\n$$\n从第一行，我们得到透射振幅 $t \\equiv A_R = 1/\\mathcal{M}_{11}$。\n透射概率 $T$ 是透射概率流密度与入射概率流密度的比值。概率流密度为 $J = \\frac{\\hbar}{2mi}(\\psi^*\\psi' - \\psi(\\psi')^*)$。对于一个实数 $k$ 的平面波 $\\psi(x)=Ae^{ikx}$，有 $J = |A|^2 \\frac{\\hbar k}{m}$。\n$$\nT = \\frac{J_{trans}}{J_{inc}} = \\frac{|A_R|^2 (\\hbar k_R/m)}{|A_L|^2 (\\hbar k_L/m)} = \\frac{k_R}{k_L}|t|^2\n$$\n代入 $t = 1/\\mathcal{M}_{11}$ 得到透射概率的最终表达式：\n$$\nT = \\frac{k_R}{k_L} \\frac{1}{|\\mathcal{M}_{11}|^2}\n$$\n问题陈述中说明了 $EV_L$ 和 $EV_R$，因此 $k_L$ 和 $k_R$ 总是实数且为正。$\\mathcal{M}_{11}$ 项可以通过执行矩阵乘法 $\\mathcal{M} = S_{k_L}^{-1} M_{total}^{-1} S_{k_R}$ 来计算，结果为：\n$$\n\\mathcal{M}_{11} = \\frac{1}{2} \\left( m_{22} - i k_R m_{12} + i \\frac{m_{21}}{k_L} + \\frac{k_R}{k_L} m_{11} \\right)\n$$\n推导至此完成。算法是首先通过乘以每一层的矩阵来计算总传播矩阵 $M_{total}$，然后使用其元素计算 $\\mathcal{M}_{11}$，最后计算透射概率 $T$。", "answer": "```python\nimport numpy as np\nimport cmath\n\ndef solve():\n    \"\"\"\n    Solves for the transmission probability using the transfer matrix method.\n    \"\"\"\n    # Physical constants\n    HBARC = 197.3269804  # MeV·fm\n    M_PARTICLE = 938.2720813  # MeV/c^2\n    \n    # Pre-calculated constant for wave number calculation\n    K_SQR_COEFF = 2 * M_PARTICLE / (HBARC**2)\n\n    # Test cases from the problem statement\n    test_cases = [\n        # Test case A\n        {\n            \"E\": 10.0, \"V_L\": 0.0, \"V_R\": 0.0,\n            \"layers\": [(20.0, 5.0)]\n        },\n        # Test case B\n        {\n            \"E\": 30.0, \"V_L\": 0.0, \"V_R\": 0.0,\n            \"layers\": [(20.0, 5.0)]\n        },\n        # Test case C\n        {\n            \"E\": 5.0, \"V_L\": 0.0, \"V_R\": 0.0,\n            \"layers\": [(25.0, 2.0), (0.0, 6.4), (25.0, 2.0)]\n        },\n        # Test case D\n        {\n            \"E\": 10.0, \"V_L\": 0.0, \"V_R\": 0.0,\n            \"layers\": []\n        }\n    ]\n\n    results = []\n\n    def get_transmission(E, V_L, layers, V_R):\n        \"\"\"\n        Calculates the transmission probability for a single potential configuration.\n        \"\"\"\n        # Threshold for handling k=0 case\n        k_epsilon = 1e-9\n\n        # Calculate wave numbers for leads\n        k_L = cmath.sqrt(K_SQR_COEFF * (E - V_L))\n        k_R = cmath.sqrt(K_SQR_COEFF * (E - V_R))\n\n        # Initialize total propagation matrix as identity\n        M_total = np.identity(2, dtype=complex)\n\n        # The structure is V_L | layer_1 | ... | layer_N | V_R\n        # The total propagation matrix M_total is P_N * P_{N-1} * ... * P_1\n        # We build it by iterating through layers and right-multiplying.\n        \n        # We build the product M_total = P_N * ... * P_1.\n        # This can be done by iterating from j=1 to N and M_new = P_j * M_old.\n        # However, the standard definition is M_total relates psi(x_N) to psi(x_0).\n        # psi(x_N) = P_N * ... * P_1 * psi(x_0).\n        # We can compute this product by iterating from N down to 1.\n        # M = I; for j=N..1: M = M @ P_j\n        # Or, M = I; for j=1..N: M = P_j @ M. This yield P_N @ ... @ P_1.\n        \n        # Let's iterate layers from left to right as given.\n        # Total matrix M = P_N * P_{N-1} * ... * P_1\n        # Loop j=1...N: compute P_j, then M_total = P_j @ M_total\n        for V_j, L_j in layers:\n            # Calculate wave number k_j in the layer\n            k_j = cmath.sqrt(K_SQR_COEFF * (E - V_j))\n\n            # Form the propagation matrix P_j for the layer\n            if abs(k_j)  k_epsilon:\n                # Limit case for k - 0\n                P_j = np.array([[1.0, L_j],\n                                [0.0, 1.0]], dtype=complex)\n            else:\n                cos_kl = cmath.cos(k_j * L_j)\n                sin_kl = cmath.sin(k_j * L_j)\n                P_j = np.array([[cos_kl, sin_kl / k_j],\n                                [-k_j * sin_kl, cos_kl]], dtype=complex)\n            \n            # The total matrix relates the final state to the initial state\n            # Psi(x_N) = M_total * Psi(x_0)\n            # M_total = P_N * ... * P_1\n            # If M starts as I, then M = P_1, then M = P_2 * M = P_2 * P_1, etc.\n            M_total = P_j @ M_total\n\n        # Extract elements of the total propagation matrix M_total\n        m11, m12 = M_total[0, 0], M_total[0, 1]\n        m21, m22 = M_total[1, 0], M_total[1, 1]\n\n        # Calculate the 1,1 element of the amplitude transfer matrix M_script\n        # M_script_11 = 0.5 * (m22 - 1j*k_R*m12 + 1j*m21/k_L + (k_R/k_L)*m11)\n        # Note that det(M_total) = 1, so M_total_inv has elements (m22, -m12, -m21, m11).\n        # The derivation in the solution uses M_total_inv.\n        # So we use m22, -m12, -m21, m11 from an M_total to compute M_script.\n        # M_script_11 = 0.5 * ( (m22) + (m21)/(1j*k_L) + (-m12)*1j*k_R + (-m11/ (1j*k_L))*1j*k_R)\n        # Let's use the simplified expression from the text which is correct:\n        # M_script_11 = 0.5 * ( m_inv_11 + m_inv_21/(1j*k_L) + m_inv_12*1j*k_R + (m_inv_22/(1j*k_L))*1j*k_R)\n        # where m_inv are elements of M^-1.\n        # m_inv_11 = m22, m_inv_12 = -m12, m_inv_21 = -m21, m_inv_22 = m11.\n        # M_script_11 = 0.5 * ( m22 + (-m21)/(1j*k_L) + (-m12)*1j*k_R + (m11/(1j*k_L))*1j*k_R )\n        # M_script_11 = 0.5 * ( m22 + 1j*m21/k_L - 1j*k_R*m12 + m11*k_R/k_L )\n        # This matches the solution text.\n        \n        M_script_11 = 0.5 * (m22 + 1j * m21 / k_L - 1j * k_R * m12 + m11 * k_R / k_L)\n\n        # Transmission probability T = (k_R/k_L) / |M_script_11|^2\n        # Since k_L, k_R are real as per problem statement EV_L, EV_R\n        T = (k_R.real / k_L.real) / abs(M_script_11)**2\n        return T\n\n    for case in test_cases:\n        T = get_transmission(case[\"E\"], case[\"V_L\"], case[\"layers\"], case[\"V_R\"])\n        results.append(T)\n\n    # Format the final output string\n    output_str = f\"[{','.join([f'{r:.8f}' for r in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3575889"}, {"introduction": "在处理了理想化的分段势垒后，我们转向更贴近物理现实的光滑势垒。对于这类问题，WKB (Wentzel–Kramers–Brillouin) 近似是一种核心的半经典工具。这个练习 [@problem_id:3575931] 的目标不仅仅是应用WKB公式，更关键的是通过将其结果与数值精确解进行比较，来批判性地评估其准确性和适用范围。掌握何时以及为何一个近似方法有效或失效，是计算物理学家的一个关键素养。", "problem": "考虑一个由不含时薛定谔方程描述的一维核散射问题，\n$$\n-\\frac{\\hbar^2}{2 m}\\,\\frac{d^2\\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\n其势垒为一个由类 Pöschl–Teller 势描述的局域势垒，\n$$\nV(x) = \\frac{V_0}{\\cosh^2\\!\\left(\\frac{x}{a}\\right)} = V_0\\,\\operatorname{sech}^2\\!\\left(\\frac{x}{a}\\right),\n$$\n其中 $V_0$ 是势垒高度，$a$ 是势垒宽度参数，且 $\\operatorname{sech}(u) = 1/\\cosh(u)$。假设能量 $E$ 严格低于势垒顶，即 $0  E  V_0$，从而发生量子隧穿。使用自然单位制，其中光速 $c=1$，转换常数 $\\hbar c = 197.3269804\\,\\text{MeV}\\,\\text{fm}$。设质量为核子质量 $m = 939.565\\,\\text{MeV}$（即以能量单位表示的 $m c^2$）。\n\n你的任务是针对给定的参数集 $(V_0, a, E)$，用两种方法计算穿过势垒的透射概率 $T(E)$：\n\n1. 通过求解薛定谔方程得到的数值精确透射概率 $T_{\\text{exact}}(E)$。该求解过程需满足散射边界条件，即与一个从 $x\\to -\\infty$ 入射的平面波和一个朝向 $x\\to +\\infty$ 的出射透射波相一致。使用一个足够大但有限的区间 $[-L, L]$（其中 $L = 12 a$）来近似 $V(x) \\approx 0$ 的渐近区域，并在此区间上施加渐近平​​面波边界条件。使用一种严格从薛定谔方程及其渐近解推导出的方法来计算透射概率，该方法不依赖于拟合参数或经验公式。\n\n2. 基于经典转折点 $x_1  0  x_2$（由 $V(x_i) = E$ 定义）之间的势垒下作用量积分的半经典 Wentzel–Kramers–Brillouin (WKB) 近似 $T_{\\text{WKB}}(E)$。对于上述势，转折点满足 $\\cosh^2\\!\\left(\\frac{x_i}{a}\\right) = \\frac{V_0}{E}$，因此可以用反双曲余弦函数表示。数值实现作用量积分，并用它来仅估计经典禁区内的隧穿概率。\n\n所有量都必须使用指定的单位处理：能量单位为 $\\text{MeV}$，长度单位为 $\\text{fm}$。透射概率是无量纲的，必须以小数形式返回。\n\n从第一性原理出发设计你的算法。从薛定谔方程和散射态的定义开始，构建获得 $T_{\\text{exact}}(E)$ 和 $T_{\\text{WKB}}(E)$ 所需的数值步骤，不要在问题陈述中引入任何捷径公式。通过检查 $E  V_0$ 并选择使 $V(\\pm L)$ 相对于 $V_0$ 可以忽略不计的 $L$ 值，来确保科学上的真实性。\n\n将你的解决方案实现为一个完整的、可运行的程序，为以下参数值测试集生成结果。这些测试集的选择旨在探测不同情况，包括“理想路径”、接近势垒顶部的行为（半经典近似可能在此失效）以及薄势垒的边缘情况：\n\n- 测试用例 1：$V_0 = 25\\,\\text{MeV}$，$a = 5\\,\\text{fm}$，$E = 5\\,\\text{MeV}$。\n- 测试用例 2：$V_0 = 25\\,\\text{MeV}$，$a = 1\\,\\text{fm}$，$E = 24.75\\,\\text{MeV}$。\n- 测试用例 3：$V_0 = 25\\,\\text{MeV}$，$a = 0.8\\,\\text{fm}$，$E = 12.5\\,\\text{MeV}$。\n- 测试用例 4：$V_0 = 25\\,\\text{MeV}$，$a = 0.5\\,\\text{fm}$，$E = 20\\,\\text{MeV}$。\n\n对于每个测试用例，计算并返回列表 $[T_{\\text{exact}}(E), T_{\\text{WKB}}(E), \\Delta(E)]$，其中 $\\Delta(E)$ 是由下式定义的相对误差：\n$$\n\\Delta(E) = \\frac{\\left|T_{\\text{WKB}}(E) - T_{\\text{exact}}(E)\\right|}{T_{\\text{exact}}(E)}.\n$$\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个逗号分隔列表，包含一个测试用例的三个浮点数，例如，\n$$\n\\text{[ [}T_{\\text{exact},1}\\text{,}T_{\\text{WKB},1}\\text{,}\\Delta_1\\text{], [}T_{\\text{exact},2}\\text{,}T_{\\text{WKB},2}\\text{,}\\Delta_2\\text{], \\ldots ]}\n$$\n所有数值条目必须以 Python 浮点数形式返回。最终输出中不应打印任何单位，因为透射概率和相对误差是无量纲的小数。", "solution": "该问题要求计算一个粒子遇到一维 Pöschl–Teller 势垒时的透射概率 $T(E)$。我们必须使用两种不同的方法来计算这个量：一种是数值精确求解不含时薛定谔方程 (TISE)，另一种是半经典的 Wentzel–Kramers–Brillouin (WKB) 近似。\n\n控制方程是 TISE：\n$$\n-\\frac{\\hbar^2}{2 m}\\,\\frac{d^2\\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x)\n$$\n势垒由以下公式给出：\n$$\nV(x) = V_0\\,\\operatorname{sech}^2\\!\\left(\\frac{x}{a}\\right)\n$$\n给定的常数为 $\\hbar c = 197.3269804\\,\\text{MeV}\\,\\text{fm}$ 和核子质能 $mc^2 = 939.565\\,\\text{MeV}$。TISE 可以重排为：\n$$\n\\frac{d^2\\psi(x)}{dx^2} = -\\frac{2m(E - V(x))}{\\hbar^2}\\,\\psi(x) = -\\frac{2(mc^2)(E - V(x))}{(\\hbar c)^2}\\,\\psi(x)\n$$\n项 $\\frac{(\\hbar c)^2}{2(mc^2)}$ 是一个单位为 $\\text{MeV}\\,\\text{fm}^2$ 的常数，我们将其表示为 $\\mathcal{C} = \\frac{(\\hbar c)^2}{2(mc^2)} \\approx 20.7212\\,\\text{MeV}\\,\\text{fm}^2$。方程变为：\n$$\n\\frac{d^2\\psi(x)}{dx^2} = -\\frac{E - V(x)}{\\mathcal{C}}\\,\\psi(x)\n$$\n在 $x \\to \\pm\\infty$ 的渐近区域，势 $V(x) \\to 0$。TISE 的解是平面波 $\\psi(x) \\propto e^{\\pm i k_0 x}$，其中 $k_0 = \\sqrt{E/\\mathcal{C}}$ 是波数。\n\n对于一个粒子从左侧 ($x \\to -\\infty$) 入射的散射问题，波函数的渐近形式为：\n$$\n\\psi(x) = \\begin{cases} A e^{i k_0 x} + B e^{-i k_0 x}  x \\to -\\infty \\\\ C e^{i k_0 x}  x \\to +\\infty \\end{cases}\n$$\n此处，$A$ 是入射波的振幅，$B$ 是反射波的振幅，$C$ 是透射波的振幅。根据定义，透射概率是 $T = \\frac{|C|^2}{|A|^2}$。\n\n### 1. 数值精确透射概率 $T_{\\text{exact}}(E)$\n\n为了求得 $T_{\\text{exact}}(E)$，我们数值求解 TISE。问题指定了一个有限区间 $[-L, L]$，其中 $L=12a$，这个区间足够大以至于 $V(\\pm L) \\approx 0$。因此我们可以在 $x = \\pm L$ 处应用渐近边界条件。\n\n我们采用一种数值积分方法，这可以看作是“打靶法”的一种形式。我们从右边界 $x=L$ 开始，将 TISE 向后积分到 $x=-L$。\n在右边界 $x=L$ 处，我们假设只有纯粹的透射波。不失一般性，我们可以将其振幅设为 $C=1$。因此，在 $x=L$ 处的边界条件是：\n$$\n\\psi(L) = e^{i k_0 L} \\quad \\text{and} \\quad \\psi'(L) = i k_0 e^{i k_0 L}\n$$\n为了进行数值积分，我们将二阶 TISE 转换为一个由两个一阶常微分方程 (ODE) 组成的系统。设状态向量为 $\\mathbf{y}(x) = [\\psi(x), \\psi'(x)]^T$。该系统为：\n$$\n\\frac{d\\mathbf{y}}{dx} = \\frac{d}{dx} \\begin{pmatrix} \\psi(x) \\\\ \\psi'(x) \\end{pmatrix} = \\begin{pmatrix} \\psi'(x) \\\\ -\\frac{E - V(x)}{\\mathcal{C}}\\,\\psi(x) \\end{pmatrix}\n$$\n我们将该系统从初始点 $x=L$ 开始，以初始条件 $\\mathbf{y}(L) = [e^{i k_0 L}, i k_0 e^{i k_0 L}]^T$ 向后积分到 $x=-L$。这会得到数值解 $\\mathbf{y}_{num}(-L) = [\\psi_{num}(-L), \\psi'_{num}(-L)]^T$。\n\n在 $x=-L$ 处，波函数必须匹配左侧区域的一般渐近形式：\n$$\n\\psi_{num}(-L) = A e^{-i k_0 L} + B e^{i k_0 L}\n$$\n$$\n\\psi'_{num}(-L) = i k_0 ( A e^{-i k_0 L} - B e^{i k_0 L} )\n$$\n这是一个关于两个未知复振幅 $A$ 和 $B$ 的线性方程组。我们关心的是 $A$。我们可以通过将第一个方程加上第二个方程乘以 $\\frac{1}{ik_0}$ 来求解 $A$：\n$$\n\\psi_{num}(-L) + \\frac{\\psi'_{num}(-L)}{i k_0} = 2A e^{-i k_0 L}\n$$\n这就给出了入射波的振幅：\n$$\nA = \\frac{1}{2} \\left( \\psi_{num}(-L) - \\frac{i}{k_0} \\psi'_{num}(-L) \\right) e^{i k_0 L}\n$$\n由于我们开始时假设透射振幅 $C=1$，因此透射概率为：\n$$\nT_{\\text{exact}}(E) = \\frac{|C|^2}{|A|^2} = \\frac{1}{|A|^2}\n$$\n这个过程将使用一个数值 ODE 求解器来实现。\n\n### 2. 半经典 WKB 近似 $T_{\\text{WKB}}(E)$\n\nWKB 近似为隧穿概率提供了一个半经典的估计。对于能量 $E  V_0$，势垒下的区域是经典禁区。在此近似下，透射概率由下式给出：\n$$\nT_{\\text{WKB}}(E) \\approx e^{-2\\gamma}\n$$\n其中 $\\gamma$ 是 Gamow 因子，定义为（虚）波数的模在经典禁区 $[x_1, x_2]$ 上的积分：\n$$\n\\gamma = \\int_{x_1}^{x_2} \\sqrt{\\frac{2m(V(x) - E)}{\\hbar^2}}\\,dx = \\int_{x_1}^{x_2} \\sqrt{\\frac{V(x) - E}{\\mathcal{C}}}\\,dx\n$$\n经典转折点 $x_1$ 和 $x_2$ 是粒子动能为零的位置，即 $V(x) = E$。对于 Pöschl–Teller 势：\n$$\nV_0\\,\\operatorname{sech}^2\\!\\left(\\frac{x_i}{a}\\right) = E \\implies \\cosh^2\\!\\left(\\frac{x_i}{a}\\right) = \\frac{V_0}{E}\n$$\n求解 $x_i$ 得到对称的转折点：\n$$\nx_{1,2} = \\mp a\\,\\operatorname{arccosh}\\left(\\sqrt{\\frac{V_0}{E}}\\right)\n$$\n问题要求对 $\\gamma$ 的作用量积分进行数值计算。我们将定义被积函数 $f(x) = \\sqrt{(V(x) - E)/\\mathcal{C}}$，并使用数值积分程序来计算 $\\gamma = \\int_{x_1}^{x_2} f(x) dx$。然后根据 $T_{\\text{WKB}} = e^{-2\\gamma}$ 计算 WKB 透射概率。\n\n### 3. 相对误差\n\n最后，对于每个参数集，WKB 近似相对于数值精确结果的相对误差 $\\Delta(E)$ 计算如下：\n$$\n\\Delta(E) = \\frac{\\left|T_{\\text{WKB}}(E) - T_{\\text{exact}}(E)\\right|}{T_{\\text{exact}}(E)}\n$$\n\n这些步骤构成了一个完整的、基于第一性原理的数值框架，用于解决所述问题。这些算法将使用 `numpy` 和 `scipy` 库在 Python 中实现，以进行数值计算。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp, quad\nfrom typing import List, Tuple\n\ndef solve():\n    \"\"\"\n    Computes the transmission probability through a Pöschl-Teller barrier\n    using a numerically exact method and the WKB approximation.\n    \"\"\"\n    # Physical constants and parameters\n    HBARC = 197.3269804  # MeV fm\n    M_NUCLEON_C2 = 939.565  # MeV\n    # Pre-calculated constant hbar^2 / (2m) = (hbar*c)^2 / (2*m*c^2)\n    HBARC2_OVER_2M = HBARC**2 / (2 * M_NUCLEON_C2)\n\n    # Test cases: (V0 in MeV, a in fm, E in MeV)\n    test_cases = [\n        (25.0, 5.0, 5.0),\n        (25.0, 1.0, 24.75),\n        (25.0, 0.8, 12.5),\n        (25.0, 0.5, 20.0),\n    ]\n\n    # Helper function for the potential\n    def V_pt(x: float, V0: float, a: float) -> float:\n        \"\"\"Pöschl-Teller potential.\"\"\"\n        return V0 / np.cosh(x / a)**2\n\n    results = []\n    for V0, a, E in test_cases:\n        # --- 1. Numerically Exact Transmission Probability T_exact ---\n        \n        # Wave number in the asymptotic region (x -> +/- infinity)\n        k0 = np.sqrt(E / HBARC2_OVER_2M)\n        \n        # Integration domain [-L, L]\n        L = 12.0 * a\n        \n        # Define the system of 1st order ODEs for the Schrödinger equation\n        # y = [psi, d(psi)/dx]\n        def schrodinger_ode(t: float, y: np.ndarray) -> np.ndarray:\n            psi, dpsi_dx = y\n            d2psi_dx2 = -(E - V_pt(t, V0, a)) * psi / HBARC2_OVER_2M\n            return np.array([dpsi_dx, d2psi_dx2], dtype=np.complex128)\n            \n        # Initial conditions at x = L (right boundary), assuming purely transmitted wave C*exp(i*k0*x) with C=1\n        psi_L = np.exp(1j * k0 * L)\n        dpsi_dx_L = 1j * k0 * np.exp(1j * k0 * L)\n        y_L = np.array([psi_L, dpsi_dx_L], dtype=np.complex128)\n        \n        # Numerically integrate backwards from L to -L\n        # Using a high-precision solver (DOP853) is beneficial for oscillatory solutions.\n        # Set dense_output=True to get solution at specific points if needed, here just the end is fine.\n        sol = solve_ivp(\n            schrodinger_ode,\n            [L, -L],\n            y_L,\n            method='DOP853',\n            atol=1e-12, # Absolute tolerance\n            rtol=1e-12) # Relative tolerance\n            \n        # Extract solution at x = -L\n        psi_minus_L, dpsi_dx_minus_L = sol.y[:, -1]\n        \n        # At x = -L, the solution is a superposition of incoming (A) and reflected (B) waves:\n        # psi(-L) = A*exp(-i*k0*L) + B*exp(i*k0*L)\n        # psi'(-L) = i*k0*(A*exp(-i*k0*L) - B*exp(i*k0*L))\n        # From these, solve for the incoming amplitude A\n        A_inv_term1 = psi_minus_L\n        A_inv_term2 = dpsi_dx_minus_L / (1j * k0)\n        A = 0.5 * (A_inv_term1 + A_inv_term2) * np.exp(1j * k0 * L)\n        \n        # Transmission probability T = |C|^2 / |A|^2. Since we set C=1, T = 1/|A|^2.\n        T_exact = 1.0 / np.abs(A)**2 if np.abs(A) > 1e-15 else 0.0\n\n        # --- 2. WKB Approximation T_wkb ---\n        \n        T_wkb = 0.0\n        # WKB approximation is valid for E  V0\n        if E  V0:\n            # Classical turning points V(x) = E\n            x2 = a * np.arccosh(np.sqrt(V0 / E))\n            x1 = -x2\n            \n            # Integrand for the Gamow factor gamma\n            def wkb_integrand(x: float) -> float:\n                return np.sqrt((V_pt(x, V0, a) - E) / HBARC2_OVER_2M)\n                \n            # Numerically integrate to find gamma\n            gamma, _ = quad(wkb_integrand, x1, x2, epsabs=1e-12, epsrel=1e-12)\n            \n            # WKB transmission probability\n            T_wkb = np.exp(-2.0 * gamma)\n        \n        # --- 3. Relative Error ---\n        \n        delta = np.abs(T_wkb - T_exact) / T_exact if T_exact > 0 else 0.0\n        \n        results.append([T_exact, T_wkb, delta])\n\n    # Format the final output as a string representing a list of lists.\n    # e.g., [[val1, val2, val3], [val4, val5, val6]]\n    output_str = \"[\" + \", \".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n\n```", "id": "3575931"}, {"introduction": "最后的这个综合性练习将我们之前学习的数值方法应用于一个真实的核物理问题：阿尔法衰变。你将构建一个包含预形成因子和WKB隧穿概率的半唯象模型，来预测原子核的衰变半衰期。此练习 [@problem_id:3575895] 的核心挑战在于引入了不确定性量化（UQ）的概念，通过蒙特卡洛抽样来研究核势参数的不确定性如何传播到最终的可观测量上。这使得我们的计算模型从一个确定性的计算，迈向了更符合真实物理实验的概率性预测。", "problem": "您将实现一个alpha衰变的计算模型，该模型通过一个内禀预形成因子和一个量子力学势垒穿透因子的乘积来计算衰变半衰期，其中有效相互作用中的不确定度通过蒙特卡罗抽样传播到观测量。建模假设和数值任务基于不含时薛定谔方程和半经典的Wentzel–Kramers–Brillouin (WKB)近似。\n\n起始点和建模假设：\n- 以约化质量为 $\\mu$ 的alpha粒子在子核场中径向运动的不含时薛定谔方程是基本基础。在半经典的Wentzel–Brillouin–Kramers (WKB)近似中，穿过一维有效势垒的势垒隧穿概率由作用量在经典禁戒区的积分得到，该区域由势能等于动能的转折点定义。\n- 将总势建模为 $V(r) = V_{\\mathrm{N}}(r) + V_{\\mathrm{C}}(r)$，并设轨道角动量为零。核势项为伍兹-撒克逊形式 $V_{\\mathrm{N}}(r) = -V_{0}/\\left(1+\\exp\\!\\left(\\frac{r-R}{a}\\right)\\right)$，其中半径 $R = r_{0} A_{\\mathrm{d}}^{1/3}$；库仑项为半径 $R_{\\mathrm{C}} = r_{0\\mathrm{C}} A_{\\mathrm{d}}^{1/3}$ 的均匀带电球体的势，即当 $r \\ge R_{\\mathrm{C}}$ 时为 $V_{\\mathrm{C}}(r)= Z_{\\mathrm{d}} Z_{\\alpha} e^{2}/r$，当 $r  R_{\\mathrm{C}}$ 时为 $V_{\\mathrm{C}}(r)=\\frac{Z_{\\mathrm{d}} Z_{\\alpha} e^2}{2 R_{\\mathrm{C}}} \\left(3 - \\frac{r^2}{R_{\\mathrm{C}}^2}\\right)$。\n- 衰变常数 $\\lambda$ 由隧穿概率 $P$、alpha粒子在母核内的预形成因子 $P_{\\alpha}$ 以及它在核内部撞击势垒的频率 $\\nu$ 决定。半衰期 $T_{1/2} = (\\ln 2)/\\lambda$。\n- 模型中的不确定性来源于对核势参数（$V_0, a, r_0, r_{0\\mathrm{C}}$）的知识不精确。将每个参数视为从具有给定均值和标准差的正态分布中抽取的独立随机变量。通过蒙特卡罗方法传播这些不确定度。\n\n数值任务：\n对于每个给定的测试案例，执行以下步骤：\n1.  **蒙特卡罗模拟**：执行 $N=400$ 次抽样。在每次抽样中，通过从指定的正态分布中抽取模型参数 $(V_0, a, r_0, r_{0\\mathrm{C}})$ 的值来生成一个势。如果任何抽样参数值为非正数，则丢弃并重新抽样。\n2.  **转折点**：对于每次抽样生成的势，数值求解方程 $V(r) = Q$，其中 $Q$ 是给定的衰变能量。找到两个正的经典转折点 $r_1, r_2$。如果未找到恰好两个转折点，则丢弃该蒙特卡罗样本。\n3.  **WKB积分**：通过在 $r_1$ 和 $r_2$ 之间数值积分 $\\frac{1}{\\hbar c} \\sqrt{2 \\mu c^2 (V(r) - Q)}$，计算WKB作用量（伽莫夫因子）。\n4.  **半衰期**：使用WKB作用量、给定的预形成因子和估算的撞击频率来计算衰变半衰期 $T_{1/2}$。在对数空间中进行计算，以避免数值下溢，最终目标是 $\\log_{10}(T_{1/2}/\\mathrm{s})$。\n5.  **统计分析**：收集每次有效蒙特卡罗抽样的 $\\log_{10}(T_{1/2}/\\mathrm{s})$ 值。在完成所有抽样后，计算该目标量的样本均值和样本标准差。\n\n输出应为一个包含六个浮点数的列表，分别对应三个测试案例的均值和标准差：$[\\text{mean}_1, \\text{std}_1, \\text{mean}_2, \\text{std}_2, \\text{mean}_3, \\text{std}_3]$。使用固定的随机种子以保证可复现性。", "solution": "该问题要求实现一个计算模型，用以计算alpha衰变半衰期 $T_{1/2}$ 及其不确定度。该模型基于用于量子隧穿的半经典Wentzel–Kramers–Brillouin (WKB)近似。核势参数的不确定度通过蒙特卡罗模拟传播到最终观测量 $\\log_{10}(T_{1/2}/\\mathrm{s})$。\n\n解决方案结构如下：首先，我们定义物理模型，包括势、衰变率和半衰期；其次，我们详细说明实现此模型的数值方法，包括用于寻找转折点的求根法和用于计算WKB作用量的数值积分；最后，我们描述用于不确定度量化的蒙特卡罗程序。\n\n**1. 物理模型**\n\nalpha衰变过程被建模为预形成的alpha粒子量子隧穿通过由子核产生的势垒。\n\n**1.1. 势垒**\nalpha粒子在距子核中心距离为 $r$ 处的势能 $V(r)$ 是吸引性核势 $V_{\\mathrm{N}}(r)$ 和排斥性静电库仑势 $V_{\\mathrm{C}}(r)$ 的和。我们只考虑球对称势（轨道角动量为零）。\n$$V(r) = V_{\\mathrm{N}}(r) + V_{\\mathrm{C}}(r)$$\n核势由Woods-Saxon形式建模：\n$$V_{\\mathrm{N}}(r) = -\\frac{V_0}{1 + \\exp\\left(\\frac{r - R}{a}\\right)}$$\n其中 $V_0$ 是势深，$a$ 是弥散度参数，$R$ 是核半径，由 $R = r_0 A_{\\mathrm{d}}^{1/3}$ 给出，其中 $r_0$ 是半径参数，$A_{\\mathrm{d}}$ 是子核的质量数。\n\n库仑势是半径为 $R_{\\mathrm{C}} = r_{0\\mathrm{C}} A_{\\mathrm{d}}^{1/3}$ 的均匀带电球体的势。它有两种形式，取决于alpha粒子是在子核电荷分布的内部还是外部：\n$$V_{\\mathrm{C}}(r) = \\begin{cases} \\frac{Z_{\\mathrm{d}} Z_{\\alpha} e^2}{2 R_{\\mathrm{C}}} \\left(3 - \\frac{r^2}{R_{\\mathrm{C}}^2}\\right)  \\text{for } r  R_{\\mathrm{C}} \\\\ \\frac{Z_{\\mathrm{d}} Z_{\\alpha} e^2}{r}  \\text{for } r \\ge R_{\\mathrm{C}} \\end{cases}$$\n此处，$Z_{\\mathrm{d}}$ 和 $Z_{\\alpha}=2$ 分别是子核和alpha粒子的原子序数，$e^2$ 是以 $\\mathrm{MeV}\\cdot\\mathrm{fm}$ 为单位的元电荷平方。\n\n**1.2. 势垒穿透与WKB近似**\n假设alpha粒子具有一个明确的能量，即衰变$Q$值。经典禁戒区是势能 $V(r)$ 超过总能量 $Q$ 的区域。该区域由两个转折点 $r_1$ 和 $r_2$ 界定，这两个点由方程 $V(r) = Q$ 定义。\n\n根据WKB近似，穿过此势垒的概率 $P$ 由下式给出：\n$$P = \\exp(-2K)$$\n其中 $K$ 是伽莫夫因子，即在经典禁戒区上的作用量积分：\n$$K = \\frac{1}{\\hbar c} \\int_{r_1}^{r_2} \\sqrt{2\\mu c^2 \\left(V(r) - Q\\right)} \\, dr$$\n在此表达式中，$\\mu$ 是alpha-子核系统的约化质量，$\\hbar c$ 是约化普朗克常数乘以光速，而项 $\\mu c^2$ 代表以能量单位（$\\mathrm{MeV}$）表示的约化质量。约化质量计算如下：\n$$\\mu c^2 = \\frac{(m_{\\alpha}c^2)(m_{\\mathrm{d}}c^2)}{m_{\\alpha}c^2 + m_{\\mathrm{d}}c^2}$$\n其中 $m_{\\alpha}c^2$ 是alpha粒子的静止能量，$m_{\\mathrm{d}}c^2 \\approx A_{\\mathrm{d}} m_u c^2$ 是子核的近似静止能量，$m_u c^2$ 是原子质量单位的能量当量。\n\n**1.3. 衰变常数与半衰期**\n衰变常数 $\\lambda$ 被建模为三个因子的乘积：\n$$\\lambda = P_{\\alpha} \\nu P$$\n其中 $P_{\\alpha}$ 是预形成因子（在母核内形成alpha粒子的概率），$\\nu$ 是撞击频率（alpha粒子撞击势垒的速率），$P$ 是隧穿概率。\n\n撞击频率 $\\nu$ 是从一个简单的经典图像中估算的，即alpha粒子在核内运动：\n$$\\nu = \\frac{v_{\\text{ratio}}}{2R} c$$\n其中 $c$ 是光速，$R = r_0 A_{\\mathrm{d}}^{1/3}$ 是核半径，$v_{\\text{ratio}} = v_{\\text{internal}}/c$ 是alpha粒子内部速度与光速之比。该速度是根据其动能估算的，假设在势阱内部动能为 $Q$：\n$$v_{\\text{ratio}} = \\sqrt{\\frac{2Q}{\\mu c^2}}$$\n半衰期 $T_{1/2}$ 与衰变常数的关系为：\n$$T_{1/2} = \\frac{\\ln 2}{\\lambda} = \\frac{\\ln 2}{P_{\\alpha} \\nu \\exp(-2K)}$$\n为避免处理极小的 $P$ 值时出现数值下溢，我们使用半衰期的对数。目标量为 $y = \\log_{10}(T_{1/2}/\\mathrm{s})$，可计算如下：\n$$y = \\log_{10}(T_{1/2}) = \\frac{\\ln(T_{1/2})}{\\ln 10} = \\frac{1}{\\ln 10} \\left[ \\ln(\\ln 2) - \\ln(P_{\\alpha}) - \\ln(\\nu) + 2K \\right]$$\n根据输入常数，$\\nu$ 的单位计算为 $\\mathrm{s}^{-1}$，因此 $T_{1/2}$ 自然以秒为单位获得。\n\n**2. 数值实现与蒙特卡罗模拟**\n\n势的模型参数（$V_0, a, r_0, r_{0\\mathrm{C}}$）并非精确已知。通过将它们视为独立的高斯随机变量来对其不确定度进行建模。使用蒙特卡罗模拟将这些不确定度传播到最终的半衰期。\n\n对于每个测试案例的 $N=400$ 个蒙特卡罗样本中的每一个：\n1.  **参数抽样**：从指定的正态分布 $\\mathcal{N}(\\bar{x}, \\sigma_x)$ 中抽取 $V_0$、$a$、$r_0$ 和 $r_{0\\mathrm{C}}$ 的值。任何非正抽样值都将被丢弃并重新抽样，以确保物理上的合理性。\n2.  **转折点计算**：对于抽样得到的势，在区间 $[10^{-3}, 200]\\,\\mathrm{fm}$ 内数值求解方程 $f(r) = V(r) - Q = 0$ 的根。这通过首先扫描区间以找到函数变号的括号，然后使用稳健的求根算法（Brent方法）来精确定位根 $r_1$ 和 $r_2$ 来完成。如果未找到恰好两个转折点，则该样本无效并被丢弃。\n3.  **WKB积分评估**：在找到的转折点 $r_1$ 和 $r_2$ 之间，数值计算伽莫夫因子 $K$ 的积分。为此使用高质量的自适应求积程序以确保精度。\n4.  **半衰期计算**：使用计算出的 $K$ 和抽样参数，计算撞击频率 $\\nu$，然后使用对数公式计算 $y = \\log_{10}(T_{1/2}/\\mathrm{s})$ 的值。\n5.  **数据聚合**：存储有效样本产生的 $y$ 值。\n\n在处理完所有 $N$ 个样本后，计算收集到的 $y$ 值的样本均值和样本标准差（使用贝塞尔校正）。这两个统计量总结了半衰期对数的预测值和传播的不确定度。对指定的三个测试案例中的每一个都重复此整个过程。固定的随机种子确保了结果的可复现性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to run the alpha decay simulation for the specified test cases.\n    \"\"\"\n    # Define physical constants as per the problem statement\n    HBARC = 197.3269804  # MeV*fm\n    E2 = 1.439964        # MeV*fm\n    C_LIGHT = 2.99792458e23  # fm/s\n    M_U_C2 = 931.49410242 # MeV\n    M_ALPHA_C2 = 3727.379378 # MeV\n    Z_ALPHA = 2.0\n    LN2 = np.log(2.0)\n    LN10 = np.log(10.0)\n\n    # Monte Carlo simulation parameters\n    N_SAMPLES = 400\n    RANDOM_SEED = 12345\n    \n    # Root finding parameters\n    R_MIN, R_MAX = 1e-3, 200.0\n    GRID_POINTS = 2000\n\n    # Define the test cases from the problem statement.\n    # (Zd, Ad, Q, Pa, r0_mean, r0_std, a_mean, a_std, V0_mean, V0_std, r0C_mean, r0C_std)\n    test_cases = [\n        (90.0, 234.0, 4.270, 0.20, 1.20, 0.05, 0.62, 0.05, 120.0, 5.0, 1.20, 0.02),\n        (82.0, 208.0, 8.954, 0.30, 1.20, 0.05, 0.62, 0.05, 120.0, 5.0, 1.20, 0.02),\n        (88.0, 228.0, 4.082, 0.15, 1.20, 0.05, 0.62, 0.05, 120.0, 5.0, 1.20, 0.02),\n    ]\n\n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(RANDOM_SEED)\n\n    def draw_positive_normal(mean, std):\n        \"\"\"Draws from a normal distribution, ensuring the result is positive.\"\"\"\n        while True:\n            val = rng.normal(mean, std)\n            if val > 0:\n                return val\n\n    def potential_V(r, V0, a, Ad, Zd, r0, r0C):\n        \"\"\"Calculates the total potential V(r) = V_N(r) + V_C(r).\"\"\"\n        # Nuclear potential (Woods-Saxon)\n        R = r0 * Ad**(1/3.0)\n        Vn = -V0 / (1.0 + np.exp((r - R) / a))\n\n        # Coulomb potential (uniformly charged sphere)\n        Rc = r0C * Ad**(1/3.0)\n        Vc = np.where(r >= Rc,\n                      (Zd * Z_ALPHA * E2) / r,\n                      (Zd * Z_ALPHA * E2) / (2.0 * Rc) * (3.0 - (r/Rc)**2))\n        \n        return Vn + Vc\n\n    def run_case(case_params):\n        \"\"\"Runs the Monte Carlo simulation for a single case.\"\"\"\n        Zd, Ad, Q, Pa, r0_m, r0_s, a_m, a_s, V0_m, V0_s, r0C_m, r0C_s = case_params\n\n        m_d_c2 = Ad * M_U_C2\n        mu_c2 = (M_ALPHA_C2 * m_d_c2) / (M_ALPHA_C2 + m_d_c2)\n\n        y_values = []\n        r_grid = np.linspace(R_MIN, R_MAX, GRID_POINTS)\n\n        for _ in range(N_SAMPLES):\n            # 1. Sample parameters\n            r0_sample = draw_positive_normal(r0_m, r0_s)\n            a_sample = draw_positive_normal(a_m, a_s)\n            V0_sample = draw_positive_normal(V0_m, V0_s)\n            r0C_sample = draw_positive_normal(r0C_m, r0C_s)\n\n            # 2. Find turning points\n            def root_func(r):\n                return potential_V(r, V0_sample, a_sample, Ad, Zd, r0_sample, r0C_sample) - Q\n\n            y_grid = root_func(r_grid)\n            \n            brackets = []\n            for i in range(len(y_grid) - 1):\n                if np.sign(y_grid[i]) != np.sign(y_grid[i+1]):\n                    brackets.append((r_grid[i], r_grid[i+1]))\n\n            if len(brackets) != 2:\n                continue # Discard sample as per requirement\n\n            try:\n                r1 = brentq(root_func, brackets[0][0], brackets[0][1])\n                r2 = brentq(root_func, brackets[1][0], brackets[1][1])\n            except (RuntimeError, ValueError):\n                continue # brentq failed, discard sample\n\n            # 3. WKB integral\n            def wkb_integrand(r):\n                val = 2.0 * mu_c2 * (potential_V(r, V0_sample, a_sample, Ad, Zd, r0_sample, r0C_sample) - Q)\n                # Handle potential floating point inaccuracies near roots\n                return np.sqrt(val) if val > 0 else 0.0\n\n            K, _ = quad(wkb_integrand, r1, r2)\n            K /= HBARC\n\n            # 4. Calculate half-life\n            v_ratio = np.sqrt(2.0 * Q / mu_c2)\n            R_sample = r0_sample * Ad**(1/3.0)\n            nu = (v_ratio * C_LIGHT) / (2.0 * R_sample)\n\n            # Calculate log10(T_1/2) using the logarithmic form to avoid underflow\n            log_T_half_life = (np.log(LN2) - np.log(Pa) - np.log(nu) + 2.0 * K) / LN10\n            y_values.append(log_T_half_life)\n        \n        # 5. Aggregate results\n        if not y_values:\n            # This should not happen with the given parameters but is a safeguard.\n            return 0.0, 0.0\n\n        mean_y = np.mean(y_values)\n        std_y = np.std(y_values, ddof=1) if len(y_values) > 1 else 0.0\n        \n        return mean_y, std_y\n\n    all_results = []\n    for case in test_cases:\n        mean_y, std_y = run_case(case)\n        all_results.extend([mean_y, std_y])\n    \n    # Format the final output string as required.\n    formatted_results = [f\"{x:.3f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3575895"}]}