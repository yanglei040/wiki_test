{"hands_on_practices": [{"introduction": "在理想的同位旋对称性极限下，费米矩阵元的值完全由 $SU(2)$ 李代数确定。然而，实际的计算通常在截断的模型空间中进行，这可能会破坏这种基本的对称性。本练习 [@problem_id:3546702] 提供了一种动手实践的方法，将同位旋算符构建为矩阵，并将其投影到更小的子空间中，从而数值化地量化对易关系被违背的程度。这是对任何多体计算都至关重要的一种诊断方法。", "problem": "考虑作用于一个同位旋空间中的二阶特殊酉群 ($SU(2)$)，该空间由总同位旋 $T$ 表征，基态为 $\\lvert T,m\\rangle$，其中 $m \\in \\{-T,-T+1,\\dots,T\\}$。与费米 $\\beta$ 衰变相关的费米跃迁算符是同位旋升降算符 $ \\hat{T}_\\pm $，而同量异位旋类比态之间的费米矩阵元 $M_F$ 是跃迁振幅 $ \\langle T,m_f \\lvert \\hat{T}_\\pm \\rvert T,m_i \\rangle $，其中 $m_f = m_i \\pm 1$。在具有截断模型空间的计算环境中，会引入有效算符在截断空间内作用；然而，截断会改变算符代数。\n\n从以下基本基础出发：在 $\\lvert T,m\\rangle$ 基中，$SU(2)$ 李代数表示由升降作用 $ \\hat{T}_\\pm \\lvert T,m\\rangle = \\sqrt{T(T+1)-m(m\\pm 1)} \\, \\lvert T,m\\pm 1\\rangle $ 和对角作用 $ \\hat{T}_z \\lvert T,m\\rangle = m \\lvert T,m\\rangle $ 定义。两个算符 $ \\hat{A} $ 和 $ \\hat{B} $ 的对易子是 $ [\\hat{A},\\hat{B}] = \\hat{A}\\hat{B} - \\hat{B}\\hat{A} $。一个矩阵 $ \\hat{X} $ 的弗罗贝尼乌斯范数是 $ \\lVert \\hat{X} \\rVert_F = \\sqrt{\\sum_{i,j} \\lvert X_{ij} \\rvert^2} $。\n\n您必须实现一个程序，该程序为给定的 $T$ 构建精确的 $SU(2)$ 算符 $ \\hat{T}_+ $、$ \\hat{T}_- $ 和 $ \\hat{T}_z $，然后将它们投影到由 $m$ 值的一个子集所张成的指定截断子空间中。在截断空间内定义两组算符：\n\n1. 投影算符：$ \\hat{T}_\\pm^{(P)} = P \\hat{T}_\\pm P $ 和 $ \\hat{T}_z^{(P)} = P \\hat{T}_z P $，其中 $P$ 是到截断子空间的投影算子。\n2. 代数恢复的有效算符：$ \\hat{T}_\\pm^{(\\mathrm{eff})} = \\hat{T}_\\pm^{(P)} $ 和 $ \\hat{T}_z^{(\\mathrm{eff})} = \\tfrac{1}{2} \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] $。\n\n对于下方的每个测试用例，计算三个量：\n\n- 投影算符集中的代数破坏：$ D_P = \\left\\lVert \\left[ \\hat{T}_+^{(P)}, \\hat{T}_-^{(P)} \\right] - 2 \\hat{T}_z^{(P)} \\right\\rVert_F $。\n- 代数恢复的有效算符集中的代数破坏：$ D_{\\mathrm{eff}} = \\left\\lVert \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] - 2 \\hat{T}_z^{(\\mathrm{eff})} \\right\\rVert_F $。\n- 对于指定的跃迁 $ m_i \\to m_f $，使用 $ \\hat{T}_\\pm^{(\\mathrm{eff})} $ 在截断空间内的费米矩阵元相对于使用 $ \\hat{T}_\\pm $ 的精确全空间矩阵元的绝对误差：$ E_F = \\left\\lvert \\langle T,m_f \\lvert \\hat{T}_\\pm^{(\\mathrm{eff})} \\rvert T,m_i \\rangle_{\\text{trunc}} - \\langle T,m_f \\lvert \\hat{T}_\\pm \\rvert T,m_i \\rangle_{\\text{full}} \\right\\rvert $。如果 $m_i$ 或 $m_f$ 不在截断子空间中，则将截断矩阵元定义为 $0$。\n\n使用以下测试套件，它涵盖了完整空间、连续截断、非连续截断以及允许和禁戒的跃迁：\n\n- 测试用例 1：$ T = 2 $，截断的 $ m $ 集合 $ \\{-2,-1,0,1,2\\} $，算符 $ \\hat{T}_+ $，初始 $ m_i = 0 $ (因此 $ m_f = 1 $)。\n- 测试用例 2：$ T = 2 $，截断的 $ m $ 集合 $ \\{-2,-1,0,1\\} $，算符 $ \\hat{T}_+ $，初始 $ m_i = 1 $ (因此 $ m_f = 2 $)。\n- 测试用例 3：$ T = \\tfrac{3}{2} $，截断的 $ m $ 集合 $ \\{-\\tfrac{3}{2},-\\tfrac{1}{2},\\tfrac{1}{2}\\} $，算符 $ \\hat{T}_+ $，初始 $ m_i = -\\tfrac{1}{2} $ (因此 $ m_f = \\tfrac{1}{2} $)。\n- 测试用例 4：$ T = \\tfrac{3}{2} $，截断的 $ m $ 集合 $ \\{-\\tfrac{3}{2},\\tfrac{1}{2},\\tfrac{3}{2}\\} $，算符 $ \\hat{T}_- $，初始 $ m_i = \\tfrac{1}{2} $ (因此 $ m_f = -\\tfrac{1}{2} $)。\n- 测试用例 5：$ T = \\tfrac{5}{2} $，截断的 $ m $ 集合 $ \\{-\\tfrac{5}{2},-\\tfrac{3}{2},-\\tfrac{1}{2},\\tfrac{1}{2},\\tfrac{3}{2}\\} $，算符 $ \\hat{T}_+ $，初始 $ m_i = \\tfrac{3}{2} $ (因此 $ m_f = \\tfrac{5}{2} $)。\n\n您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表的列表，每个内部列表按测试用例的相同顺序排列为 $[D_P, D_{\\mathrm{eff}}, E_F]$，并用方括号括起来。例如，输出格式必须与 $[[d_1,d_2,e_1],[d_3,d_4,e_2],\\dots]$ 完全一样，其中包含数值。", "solution": "该问题具有科学依据、提法明确且客观。它提出了一个清晰定义的计算任务，该任务植根于量子力学的标准原理，特别是应用于原子核同位旋的 $SU(2)$ 李群表示论。模型空间截断、有效算符以及对由此产生的算符代数破坏的定量分析，是计算多体物理学中的标准课题。所有必要的定义、常数和测试用例均已提供，不存在内部矛盾或歧义。因此，该问题是有效的，可以构建一个解决方案。\n\n解决方案将通过以下主要步骤进行开发：\n1.  对于给定的总同位旋 $T$，将同位旋算符 $\\hat{T}_+、\\hat{T}_-$ 和 $\\hat{T}_z$ 表示为全希尔伯特空间中的矩阵。\n2.  定义截断的模型空间并构建投影算子 $P$。\n3.  应用投影算子以获得在截断空间内作用的投影算符 $\\hat{T}_\\pm^{(P)}$ 和 $\\hat{T}_z^{(P)}$。\n4.  根据其定义构建代数恢复的有效算符 $\\hat{T}_\\pm^{(\\mathrm{eff})}$ 和 $\\hat{T}_z^{(\\mathrm{eff})}$。\n5.  计算所需的量：投影算符的代数破坏 $D_P$、有效算符的代数破坏 $D_\\mathrm{eff}$ 以及费米矩阵元的误差 $E_F$。\n\n**步骤 1：全空间矩阵表示**\n\n对于给定的总同位旋 $T$，希尔伯特空间由 $d = 2T+1$ 个基态 $\\lvert T, m \\rangle$ 张成，其中 $m \\in \\{T, T-1, \\dots, -T\\}$。我们通过按磁量子数 $m$ 的降序对这些态进行排序来建立一个有序基。在此基中，一个态 $\\lvert T, m \\rangle$ 是一个列向量，在其 $m$ 值对应的位置上为 1，其余位置为零。基矢量的索引 $j$（从 $0$ 到 $d-1$）对应于量子数 $m_j = T-j$。\n\n在此基中，算符 $\\hat{T}_z$、$\\hat{T}_+$ 和 $\\hat{T}_-$ 的矩阵元由以下公式给出：\n-   $\\langle T, m' \\lvert \\hat{T}_z \\rvert T, m \\rangle = m \\, \\delta_{m',m}$。这产生一个对角矩阵 $(\\hat{T}_z)_{ij} = (T-i) \\delta_{ij}$。\n-   $\\langle T, m' \\lvert \\hat{T}_+ \\rvert T, m \\rangle = \\sqrt{T(T+1)-m(m+1)} \\, \\delta_{m',m+1}$。这是一个上对角矩阵。\n-   $\\langle T, m' \\lvert \\hat{T}_- \\rvert T, m \\rangle = \\sqrt{T(T+1)-m(m-1)} \\, \\delta_{m',m-1}$。这是一个下对角矩阵，且 $\\hat{T}_- = (\\hat{T}_+)^\\dagger$。\n\n**步骤 2：投影到截断空间**\n\n截断的模型空间由全套 $m$ 值的一个子集定义。投影算子 $P$ 隔离出这个子空间。如果截断基的维度为 $d_{\\text{trunc}}$，则投影算符是 $d_{\\text{trunc}} \\times d_{\\text{trunc}}$ 的矩阵。\n在算法上，这是通过首先识别全空间中属于截断空间的基态的索引来实现的。然后，通过从全空间算符矩阵中仅选择与这些索引相对应的行和列来构建投影算符矩阵。\n\n**步骤 3：投影算符和代数恢复的有效算符**\n\n按照问题定义，我们在截断空间中构建两组算符。\n\n1.  **投影算符**：这些是通过直接投影全空间算符获得的。\n    $$ \\hat{T}_\\pm^{(P)} = P \\hat{T}_\\pm P $$\n    $$ \\hat{T}_z^{(P)} = P \\hat{T}_z P $$\n    在我们的矩阵实现中，这些对应于步骤 2 中描述的子矩阵。\n\n2.  **代数恢复的有效算符**：构建此集合是为了通过定义强制执行 $SU(2)$ 对易关系之一。\n    $$ \\hat{T}_\\pm^{(\\mathrm{eff})} = \\hat{T}_\\pm^{(P)} $$\n    $$ \\hat{T}_z^{(\\mathrm{eff})} = \\frac{1}{2} \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] = \\frac{1}{2} \\left( \\hat{T}_+^{(P)} \\hat{T}_-^{(P)} - \\hat{T}_-^{(P)} \\hat{T}_+^{(P)} \\right) $$\n\n**步骤 4：可观测量计算**\n\n在定义了算符矩阵之后，我们可以计算所要求的三个量。\n\n-   **投影代数破坏, $D_P$**：基本的 $SU(2)$ 对易关系是 $[\\hat{T}_+, \\hat{T}_-] = 2\\hat{T}_z$。截断通常会破坏这个关系。破坏程度通过残差矩阵的弗罗贝尼乌斯范数量化：\n    $$ D_P = \\left\\lVert \\left[ \\hat{T}_+^{(P)}, \\hat{T}_-^{(P)} \\right] - 2 \\hat{T}_z^{(P)} \\right\\rVert_F $$\n    其中弗罗贝尼乌斯范数是 $\\lVert \\hat{X} \\rVert_F = \\sqrt{\\sum_{i,j} |X_{ij}|^2}$。这是通过矩阵乘法和减法，然后进行范数计算来得到的。\n\n-   **有效代数破坏, $D_{\\mathrm{eff}}$**：我们为代数恢复的集合计算相同的量。\n    $$ D_{\\mathrm{eff}} = \\left\\lVert \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] - 2 \\hat{T}_z^{(\\mathrm{eff})} \\right\\rVert_F $$\n    通过代入 $\\hat{T}_z^{(\\mathrm{eff})}$ 的定义，我们看到：\n    $$ D_{\\mathrm{eff}} = \\left\\lVert \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] - 2 \\left( \\frac{1}{2} \\left[ \\hat{T}_+^{(\\mathrm{eff})}, \\hat{T}_-^{(\\mathrm{eff})} \\right] \\right) \\right\\rVert_F = \\lVert 0 \\rVert_F = 0 $$\n    根据构造，该量恒等于零，这可作为对逻辑的验证。\n\n-   **费米矩阵元误差, $E_F$**：这衡量了因使用有效算符而导致的特定跃迁振幅的误差。\n    $$ E_F = \\left\\lvert M_F^{(\\mathrm{eff})} - M_F^{(\\mathrm{exact})} \\right\\rvert $$\n    精确矩阵元 $M_F^{(\\mathrm{exact})} = \\langle T, m_f \\lvert \\hat{T}_\\pm \\rvert T, m_i \\rangle$ 就是值 $\\sqrt{T(T+1)-m_i(m_i \\pm 1)}$。有效矩阵元 $M_F^{(\\mathrm{eff})} = \\langle T, m_f \\lvert \\hat{T}_\\pm^{(\\mathrm{eff})} \\rvert T, m_i \\rangle_{\\text{trunc}}$ 是从矩阵 $\\hat{T}_\\pm^{(\\mathrm{eff})}$ 中提取的。如果初态 $\\lvert T, m_i \\rangle$ 或末态 $\\lvert T, m_f \\rangle$ 不在截断子空间中，则 $M_F^{(\\mathrm{eff})}$ 定义为 $0$。否则，它是 $\\hat{T}_\\pm^{(\\mathrm{eff})}$ 矩阵中连接对应于 $m_i$ 和 $m_f$ 的基矢量的元素。绝对差值即为误差 $E_F$。\n\n将此过程系统地应用于每个测试用例以生成最终结果。", "answer": "```python\nimport numpy as np\n\ndef solve_case(T, truncated_m_set, op_str, m_i):\n    \"\"\"\n    Solves a single test case for the SU(2) operator truncation problem.\n\n    Args:\n        T (float): Total isospin.\n        truncated_m_set (set): A set of m-values defining the truncated subspace.\n        op_str (str): The operator to use for E_F, either 'T+' or 'T-'.\n        m_i (float): The initial m-value for the transition.\n\n    Returns:\n        list: A list containing [D_p, D_eff, E_f].\n    \"\"\"\n    # 1. Define full space\n    # The dimension of the full SU(2) representation for isospin T\n    dim_full = int(2 * T + 1)\n    # Create the list of m-values, sorted in descending order, for the basis\n    full_m_list = np.arange(T, -T - 1, -1)\n    m_to_full_idx = {m: i for i, m in enumerate(full_m_list)}\n\n    # 2. Construct full-space operators\n    T_plus_full = np.zeros((dim_full, dim_full), dtype=float)\n    T_minus_full = np.zeros((dim_full, dim_full), dtype=float)\n    T_z_full = np.diag(full_m_list)\n\n    for i, m in enumerate(full_m_list):\n        # T+ acting on |T, m> gives ...|T, m+1>\n        if m  T:\n            # Map state |T, m> (col i) to state |T, m+1> (row i-1)\n            val = np.sqrt(T * (T + 1) - m * (m + 1))\n            T_plus_full[i - 1, i] = val\n        # T- acting on |T, m> gives ...|T, m-1>\n        if m > -T:\n            # Map state |T, m> (col i) to state |T, m-1> (row i+1)\n            val = np.sqrt(T * (T + 1) - m * (m - 1))\n            T_minus_full[i + 1, i] = val\n\n    # 3. Define truncated space and build projected operators\n    # Sort the truncated m-set descendingly to match the full basis ordering\n    trunc_m_list = sorted(list(truncated_m_set), reverse=True)\n    m_to_trunc_idx = {m: i for i, m in enumerate(trunc_m_list)}\n\n    # Get the indices in the full space that correspond to the truncated space\n    trunc_full_indices = [m_to_full_idx[m] for m in trunc_m_list]\n\n    # Build projected operators by taking submatrices\n    T_plus_p = T_plus_full[np.ix_(trunc_full_indices, trunc_full_indices)]\n    T_minus_p = T_minus_full[np.ix_(trunc_full_indices, trunc_full_indices)]\n    T_z_p = T_z_full[np.ix_(trunc_full_indices, trunc_full_indices)]\n\n    # 4. Calculate D_P (algebra violation in projected set)\n    commutator_p = T_plus_p @ T_minus_p - T_minus_p @ T_plus_p\n    violation_matrix_p = commutator_p - 2 * T_z_p\n    D_p = np.linalg.norm(violation_matrix_p, 'fro')\n\n    # 5. Calculate D_eff (algebra violation in algebra-restored set)\n    T_plus_eff = T_plus_p\n    T_minus_eff = T_minus_p\n    # T_z_eff is defined to restore the algebra\n    commutator_eff = T_plus_eff @ T_minus_eff - T_minus_eff @ T_plus_eff\n    T_z_eff = 0.5 * commutator_eff\n    \n    violation_matrix_eff = commutator_eff - 2 * T_z_eff\n    D_eff = np.linalg.norm(violation_matrix_eff, 'fro') # This will be zero by construction\n\n    # 6. Calculate E_F (error in Fermi matrix element)\n    if op_str == 'T+':\n        op_eff = T_plus_eff\n        m_f = m_i + 1\n        exact_me = np.sqrt(T*(T+1) - m_i*(m_i+1)) if m_i  T else 0\n    else:  # op_str == 'T-'\n        op_eff = T_minus_eff\n        m_f = m_i - 1\n        exact_me = np.sqrt(T*(T+1) - m_i*(m_i-1)) if m_i > -T else 0\n    \n    # Check if the transition occurs within the truncated space\n    if m_i in truncated_m_set and m_f in truncated_m_set:\n        idx_i_trunc = m_to_trunc_idx[m_i]\n        idx_f_trunc = m_to_trunc_idx[m_f]\n        trunc_me = op_eff[idx_f_trunc, idx_i_trunc]\n    else:\n        # If initial or final state is outside the truncated space, the matrix element is 0\n        trunc_me = 0.0\n\n    E_f = np.abs(trunc_me - exact_me)\n    \n    # Return results rounded to high precision to avoid floating point noise\n    return [round(D_p, 8), round(D_eff, 8), round(E_f, 8)]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (T, truncated_m_set, operator_str, m_i)\n        (2.0, {-2.0, -1.0, 0.0, 1.0, 2.0}, 'T+', 0.0),\n        (2.0, {-2.0, -1.0, 0.0, 1.0}, 'T+', 1.0),\n        (1.5, {-1.5, -0.5, 0.5}, 'T+', -0.5),\n        (1.5, {-1.5, 0.5, 1.5}, 'T-', 0.5),\n        (2.5, {-2.5, -1.5, -0.5, 0.5, 1.5}, 'T+', 1.5),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        T, truncated_m_set, op_str, m_i = case\n        result = solve_case(T, truncated_m_set, op_str, m_i)\n        all_results.append(result)\n\n    # Format the final output string to match the problem specification\n    # e.g., [[d_1,d_2,e_1],[d_3,d_4,e_2],...] with no spaces\n    results_str_list = []\n    for res in all_results:\n        # res is a list like [1.0, 2.0, 3.0]\n        # format it to \"[1.0,2.0,3.0]\"\n        formatted_res_str = f\"[{res[0]},{res[1]},{res[2]}]\"\n        results_str_list.append(formatted_res_str)\n    \n    final_output = f\"[{','.join(results_str_list)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3546702"}, {"introduction": "除了基矢截断效应外，物理相互作用本身也可能破坏同位旋对称性，从而修正费米矩阵元。本练习 [@problem_id:3546691] 通过一个具体而强大的二能级模型来探讨这一问题，其中一个破坏同位旋对称性的势将同位旋类似态与附近不同同位旋的态混合起来。你将通过实现该模型，探索从简单的微扰论所描述的线性响应区到强混合的非线性区的转变，从而对同位旋杂质的产生建立起直观的理解。", "problem": "您的任务是开发一个计算模型，在一个最小且物理上自洽的多体同位旋框架中，量化一个同位旋破缺的单体势如何修正费米矩阵元。考虑一个具有同位旋对称动力学的原子核，在没有同位旋破缺的情况下，它具有一个总同位旋为 $T = 1$ 且投影为 $T_z$ 的明确的同位旋类比态 (IAS)。设费米跃迁算符为 $\\hat{T}^+ = \\sum_i \\tau_i^+$，其中 $\\tau_i^+$ 升高核子 $i$ 的同位旋。引入一个形式为 $\\Delta V = \\sum_{i=1}^N v_i \\tau_i^z$ 的同位旋破缺的单体势，其中 $v_i$ 是具有能量量纲的强度。假设哈密顿量的强相互作用部分是同位旋对称的，并在 $T_z=0$ 子空间中产生两个相关态：一个能量为 $E_1$ 的 $T=1, T_z=0$ 态和一个能量为 $E_0$ 的邻近的 $T=0, T_z=0$ 态。势 $\\Delta V$ 通过同位旋矢量耦合连接这两个态。\n\n从标准同位旋代数和多体量子力学出发，在 $\\{\\,|T=1,T_z=0\\rangle,\\,|T=0,T_z=0\\rangle\\,\\}$ 基中推导一个简化的二能级哈密顿量描述。该描述具有一个非对角耦合项，此项与组合强度 $G = \\sum_i w_i v_i$ 呈线性关系，其中 $w_i$ 是已知的无量纲结构系数，编码了与同位旋矢量耦合相关的单粒子密度交叠。设非对角耦合与 $G$ 成正比，比例常数为无量纲的 $\\kappa$，并定义能级间距 $\\Delta E = E_0 - E_1  0$。通过对角化这个二能级哈密顿量，推导混合角 $\\theta(G)$，该角量化了对于 $T_z=0$ 的情况，在物理末态 $|f\\rangle$ 中 $|T=0,T_z=0\\rangle$ 的混合成分。然后，使用费米跃迁算符的定义，并利用标准的同位旋角动量耦合规则，将从初始纯 IAS 态 $|i\\rangle = |T = 1, T_z = -1\\rangle$ 到混合末态 $|f\\rangle$ 的跃迁的费米矩阵元 $M_F(G) = \\langle f|\\hat{T}^+|i\\rangle$ 用混合角表示。\n\n定义混合角的线性响应近似 $\\theta_{\\mathrm{lin}}(G)$，它是通过对同位旋破缺耦合进行一级微扰理论得到的。您的计算任务是实现一个程序，对于一族由无量纲方向矢量 $u_i$ 定义的标度化同位旋破缺强度 $v_i(s) = s\\,u_i$，该程序扫描振幅 $s$ 并找出边界振幅 $s_c$（单位为 $\\mathrm{MeV}$）。在此边界振幅下，精确混合角与其线性近似的偏差根据以下判据首次超过指定的相对容差 $\\varepsilon$：\n$$\n\\left|\\frac{\\theta\\big(G(s)\\big)}{\\theta_{\\mathrm{lin}}\\big(G(s)\\big)} - 1\\right| \\ge \\varepsilon,\n$$\n需要明确的是，如果对所有 $s$ 都有 $G(s) = 0$，则不会发生混合，边界振幅应报告为 $0.0\\,\\mathrm{MeV}$。角度必须以弧度为单位处理。\n\n将上述要求实现为一个完整的、可运行的程序，该程序：\n- 不接受任何输入，并使用下面的测试套件。\n- 对于每个测试用例，计算 $G(s) = \\sum_i w_i v_i(s) = s \\sum_i w_i u_i$，然后通过在区间 $[0, s_{\\max}]$ 内扫描 $s$ 来确定 $s_c$，找出满足判据的最小 $s$。如果在 $[0, s_{\\max}]$ 内任何地方都不满足该判据，则报告 $s_c = s_{\\max}$。如果 $G(s)$ 恒为零，则报告 $s_c = 0.0$。\n- 生成单行输出，其中包含所有测试用例的边界振幅，格式为方括号内的逗号分隔列表。每个振幅以 $\\mathrm{MeV}$ 为单位表示，并四舍五入到六位小数。\n\n使用以下测试套件：\n- 情况 A (一般情况): $N=4$, $\\Delta E = 2.0\\,\\mathrm{MeV}$, $\\kappa = 0.8$, $w_i = [1.0, 0.8, 1.2, 0.9]$, $u_i = [1.0, 1.0, 1.0, 1.0]$, $s_{\\max} = 2.0\\,\\mathrm{MeV}$, $\\varepsilon = 0.05$。\n- 情况 B (近简并态): $N=4$, $\\Delta E = 0.2\\,\\mathrm{MeV}$, $\\kappa = 0.5$, $w_i = [1.0, 0.8, 1.2, 0.9]$, $u_i = [1.0, 1.0, 1.0, 1.0]$, $s_{\\max} = 2.0\\,\\mathrm{MeV}$, $\\varepsilon = 0.05$。\n- 情况 C (平衡耦合，净同位旋矢量强度为零): $N=4$, $\\Delta E = 3.0\\,\\mathrm{MeV}$, $\\kappa = 0.6$, $w_i = [1.0, 1.0, -1.0, -1.0]$, $u_i = [1.0, 1.0, 1.0, 1.0]$, $s_{\\max} = 2.0\\,\\mathrm{MeV}$, $\\varepsilon = 0.05$。\n- 情况 D (混合符号结构): $N=4$, $\\Delta E = 5.0\\,\\mathrm{MeV}$, $\\kappa = 1.0$, $w_i = [1.0, -0.4, 0.3, 0.1]$, $u_i = [2.0, 0.5, -1.0, 1.5]$, $s_{\\max} = 5.0\\,\\mathrm{MeV}$, $\\varepsilon = 0.05$。\n\n您的程序应生成单行输出，其中包含结果，格式为方括号内的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_k$ 是相应测试用例的边界振幅 $s_c$，单位为 $\\mathrm{MeV}$，并四舍五入到六位小数。", "solution": "用户提供的问题已经过分析并被确定为 **有效**。这是一个自洽的、有科学依据的、计算核物理领域的适定问题，可以使用量子力学的标准原理来解决。\n\n### 理论推导\n\n该问题要求我们分析一个受到混合相互作用影响的二能级量子系统。该系统在 $T_z=0$ 子空间中由两个同位旋态构成的基中描述：$|1\\rangle \\equiv |T=1, T_z=0\\rangle$ 和 $|0\\rangle \\equiv |T=0, T_z=0\\rangle$。\n\n**1. 二能级哈密顿量**\n\n总哈密顿量为 $H = H_0 + \\Delta V$。同位旋对称部分 $H_0$ 在所选基中是对角的，其对于 $|1\\rangle$ 的本征值为 $E_1$，对于 $|0\\rangle$ 的本征值为 $E_0$。同位旋破缺势为 $\\Delta V = \\sum_i v_i \\tau_i^z$。根据 $\\tau^z$ 算符的性质（特别是关于1阶张量算符的 Wigner-Eckart 定理），其在 $T_z=0$ 子空间中的对角矩阵元为零：$\\langle 1|\\Delta V|1\\rangle = \\langle 0|\\Delta V|0\\rangle = 0$。\n\n非对角矩阵元由 $\\langle 0|\\Delta V|1\\rangle = \\kappa G$ 给出，其中 $G = \\sum_i w_i v_i$ 是同位旋破缺势的组合强度。由于 $\\Delta V$ 是厄米的，所以 $\\langle 1|\\Delta V|0\\rangle = (\\kappa G)^*$。假设所有参数都是实数，则此项也为 $\\kappa G$。\n\n在 $\\{|1\\rangle, |0\\rangle\\}$ 基中的哈密顿量为：\n$$\nH = \\begin{pmatrix} E_1  \\kappa G \\\\ \\kappa G  E_0 \\end{pmatrix}\n$$\n为方便起见，将能量零点移至平均能量 $(E_1+E_0)/2$，并使用能级间距 $\\Delta E = E_0 - E_1  0$。有效哈密顿量变为：\n$$\nH = \\begin{pmatrix} -\\Delta E/2  \\kappa G \\\\ \\kappa G  \\Delta E/2 \\end{pmatrix}\n$$\n\n**2. 精确混合角 $\\theta(G)$**\n\n我们对角化这个哈密顿量以找到混合本征态。物理末态 $|f\\rangle$ 是从未受微扰的态 $|1\\rangle$ 演化而来的态，$|1\\rangle$ 是这对态中能量较低的那个。$H$ 的能量较低的本征态可以写为：\n$$\n|f\\rangle = \\cos\\theta |1\\rangle + \\sin\\theta |0\\rangle\n$$\n混合角 $\\theta$ 的正切是系数之比，可以从本征矢量方程中求得。对于二能级系统，一个标准结果给出：\n$$\n\\tan(\\theta) = \\frac{\\lambda_- - H_{11}}{H_{12}} = \\frac{-\\sqrt{(\\Delta E/2)^2 + (\\kappa G)^2} - (-\\Delta E/2)}{\\kappa G} = \\frac{\\Delta E/2 - \\sqrt{(\\Delta E/2)^2 + (\\kappa G)^2}}{\\kappa G}\n$$\n对于小的 $G$，该表达式在数值上是不稳定的。将分子和分母同乘以分子的共轭，得到一个稳定形式：\n$$\n\\tan(\\theta) = \\frac{(\\kappa G)^2}{(\\kappa G) \\left( \\Delta E/2 + \\sqrt{(\\Delta E/2)^2 + (\\kappa G)^2} \\right)} = \\frac{\\kappa G}{\\Delta E/2 + \\sqrt{(\\Delta E/2)^2 + (\\kappa G)^2}}\n$$\n混合角 $\\theta$ 以弧度为单位明确地由下式给出：\n$$\n\\theta(G) = \\arctan\\left( \\frac{\\kappa G}{\\Delta E/2 + \\sqrt{(\\Delta E/2)^2 + (\\kappa G)^2}} \\right)\n$$\n\n**3. 线性响应近似 $\\theta_{\\mathrm{lin}}(G)$**\n\n线性响应近似由一级微扰理论得到。微扰后的态为：\n$$\n|f\\rangle \\approx |1\\rangle + \\frac{\\langle 0 | \\Delta V | 1 \\rangle}{E_1 - E_0} |0\\rangle = |1\\rangle + \\frac{\\kappa G}{-\\Delta E} |0\\rangle\n$$\n在小角度近似下， $|f\\rangle \\approx |1\\rangle + \\theta |0\\rangle$。比较这两种形式，我们将混合角的线性近似辨识为混合系数：\n$$\n\\theta_{\\mathrm{lin}}(G) = -\\frac{\\kappa G}{\\Delta E}\n$$\n问题寻求的是一个基于比值的偏差，因此精确角度和线性近似角度定义之间的符号差异并不重要，因为判据使用的是绝对值。然而，为了保持一致性，我们将我们的角度定义为同号。从 $\\tan(\\theta)$ 的表达式可以看出，对于小的 $G$，$\\tan(\\theta) \\approx \\frac{\\kappa G}{\\Delta E/2 + \\Delta E/2} = \\frac{\\kappa G}{\\Delta E}$。由于对于小角度有 $\\theta \\approx \\tan(\\theta)$，这自然地导向 $\\theta_{\\mathrm{lin}}(G) = \\frac{\\kappa G}{\\Delta E}$。我们将采用这种形式。\n\n**4. 计算任务**\n\n目标是找到对于标度化的势 $v_i(s) = s u_i$ 的最小振幅 $s_c  0$，在该振幅下满足判据\n$$\n\\left|\\frac{\\theta\\big(G(s)\\big)}{\\theta_{\\mathrm{lin}}\\big(G(s)\\big)} - 1\\right| \\ge \\varepsilon\n$$\n这里，$G(s) = s \\sum_i w_i u_i$。令 $C_G = \\sum_i w_i u_i$。\n\n描述相对偏差的函数是：\n$$\nD(s) = \\left| \\frac{\\arctan\\left( \\frac{\\kappa s C_G}{\\Delta E/2 + \\sqrt{(\\Delta E/2)^2 + (\\kappa s C_G)^2}} \\right)}{\\kappa s C_G / \\Delta E} - 1 \\right|\n$$\n对于 $s \\ge 0$，该函数 $D(s)$ 是单调递增的。我们必须找到值 $s_c \\in [0, s_{\\max}]$ 使得 $D(s_c) = \\varepsilon$。这是一个关于函数 $f(s) = D(s) - \\varepsilon = 0$ 的求根问题。\n\n**5. 数值算法**\n\n鉴于 $D(s)$ 的单调性，二分法是寻找 $s_c$ 的一种高效且稳健的算法。\n1.  对于每个测试用例，计算结构常数 $C_G = \\sum_i w_i u_i$。\n2.  如果 $C_G = 0$，则对所有 $s$ 都有 $G(s)=0$。不发生混合。偏差始终为 $0$。根据规定，$s_c=0.0$。\n3.  在最大振幅处评估偏差 $D(s_{\\max})$。如果 $D(s_{\\max})  \\varepsilon$，则在区间内永远不会满足判据，因此我们报告 $s_c = s_{\\max}$。\n4.  否则，在 $(0, s_{\\max})$ 中存在一个唯一的根 $s_c$。我们在区间 $[0, s_{\\max}]$ 上使用二分搜索来找到使 $D(s)=\\varepsilon$ 的 $s$ 值。搜索过程通过重复缩小区间 $[L, R]$ 来进行，直到其宽度低于所需精度，从而得出 $s_c$ 的值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the boundary amplitude s_c for a set of test cases based on a \n    two-level quantum mechanical model of isospin mixing.\n    \"\"\"\n\n    class TestCase:\n        \"\"\"A helper class to hold test case parameters for clarity.\"\"\"\n        def __init__(self, N, Delta_E, kappa, w, u, s_max, epsilon):\n            self.N = N\n            self.Delta_E = Delta_E  # MeV\n            self.kappa = kappa\n            self.w = np.array(w)\n            self.u = np.array(u)\n            self.s_max = s_max      # MeV\n            self.epsilon = epsilon\n            # C_G is the combined dimensionless structure factor\n            self.C_G = np.sum(self.w * self.u)\n\n    def calculate_deviation(s, case):\n        \"\"\"\n        Calculates the relative deviation of the exact mixing angle from its\n        linear approximation for a given amplitude s.\n        \n        The deviation is defined as |theta_exact/theta_lin - 1|.\n        \"\"\"\n        # If amplitude is zero, G is zero, and there is no mixing/deviation.\n        if s == 0.0:\n            return 0.0\n\n        # The combined isospin-breaking strength G(s)\n        G = s * case.C_G\n        \n        # If G is zero (due to C_G being zero), there is no mixing.\n        if G == 0.0:\n            return 0.0\n\n        # Linear-response approximation for the mixing angle (in radians)\n        theta_lin = case.kappa * G / case.Delta_E\n\n        # Exact mixing angle (in radians) derived from diagonalizing the 2x2 Hamiltonian.\n        # tan(theta) = (kappa*G) / (sqrt((DeltaE/2)^2 + (kappa*G)^2) + DeltaE/2)\n        # This form is numerically stable for small G.\n        kappa_G = case.kappa * G\n        arg_tan = kappa_G / (np.sqrt((case.Delta_E / 2.0)**2 + kappa_G**2) + case.Delta_E / 2.0)\n        theta_exact = np.arctan(arg_tan)\n\n        # For G != 0, theta_lin is also non-zero, so the division is safe.\n        deviation = np.abs(theta_exact / theta_lin - 1.0)\n        \n        return deviation\n\n    def find_boundary_amplitude(case):\n        \"\"\"\n        Finds the boundary amplitude s_c for a given test case using bisection search.\n        \"\"\"\n        # Special case: If the net isovector strength G(s) is identically zero,\n        # there is no isospin mixing, and s_c is defined as 0.0.\n        if case.C_G == 0.0:\n            return 0.0\n\n        # Check if the criterion is met at the maximum amplitude s_max.\n        # If not, the boundary is s_max itself.\n        dev_at_s_max = calculate_deviation(case.s_max, case)\n        if dev_at_s_max  case.epsilon:\n            return case.s_max\n\n        # Use bisection method to find s_c where deviation(s_c) = epsilon.\n        # We are finding the root of f(s) = calculate_deviation(s) - epsilon.\n        low = 0.0\n        high = case.s_max\n        \n        # 100 iterations are more than sufficient for double precision convergence.\n        for _ in range(100):\n            mid = (low + high) / 2.0\n            # If the interval is too small to bisect further, stop.\n            if mid == low or mid == high:\n                break\n            \n            # The deviation function is monotonic, so we can guide the search.\n            if calculate_deviation(mid, case)  case.epsilon:\n                # The deviation is still too small, so s_c must be larger.\n                low = mid\n            else:\n                # The deviation has exceeded epsilon, s_c is at or below mid.\n                high = mid\n                \n        # The root is at `high` (or `low`, they are very close).\n        return high\n\n    # Define the test cases from the problem statement.\n    test_cases_data = [\n        # Case A: General regime\n        {'N': 4, 'Delta_E': 2.0, 'kappa': 0.8, 'w': [1.0, 0.8, 1.2, 0.9], 'u': [1.0, 1.0, 1.0, 1.0], 's_max': 2.0, 'epsilon': 0.05},\n        # Case B: Near-degenerate states\n        {'N': 4, 'Delta_E': 0.2, 'kappa': 0.5, 'w': [1.0, 0.8, 1.2, 0.9], 'u': [1.0, 1.0, 1.0, 1.0], 's_max': 2.0, 'epsilon': 0.05},\n        # Case C: Balanced couplings, zero net isovector strength\n        {'N': 4, 'Delta_E': 3.0, 'kappa': 0.6, 'w': [1.0, 1.0, -1.0, -1.0], 'u': [1.0, 1.0, 1.0, 1.0], 's_max': 2.0, 'epsilon': 0.05},\n        # Case D: Mixed-sign structure\n        {'N': 4, 'Delta_E': 5.0, 'kappa': 1.0, 'w': [1.0, -0.4, 0.3, 0.1], 'u': [2.0, 0.5, -1.0, 1.5], 's_max': 5.0, 'epsilon': 0.05},\n    ]\n\n    test_cases = [TestCase(**data) for data in test_cases_data]\n    \n    results = []\n    for case in test_cases:\n        s_c = find_boundary_amplitude(case)\n        # Format the result to six decimal places.\n        results.append(f\"{s_c:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3546691"}, {"introduction": "虽然计算单个费米矩阵元很重要，但跃迁强度随能量的完整分布能提供更全面的物理图像。本练习 [@problem_id:3546731] 介绍了 Lanczos 强度函数方法，这是一种强大的数值技术，广泛用于大规模计算中，以高效地计算此分布及其关键特征（如质心和宽度）。通过实现核心的 Lanczos 算法，你将亲身体验计算谱学的一块基石，并验证像费米求和规则这样的基本原理。", "problem": "您需要实现一个完整的数值计算程序，在一个简化的、计算上可行的模型中，使用 Lanczos 强度函数方法计算费米跃迁强度矩，并检验一个与模型无关的求和规则。我们感兴趣的物理可观测量是在费米算符作用下，从原子核多体基态出发的电荷交换跃迁的费米强度函数，以及其能量加权矩。您的任务是在一个有限维基中进行计算，其中激发子空间由以单粒子能量差标记的正交归一基态表示，并使用 Lanczos 三对角化来近似强度分布及其低阶矩。所有能量都必须以百万电子伏特（MeV）为单位进行处理和报告。\n\n基本原理：\n- 用于电荷交换跃迁的费米算符可以写为 $F_{-} = \\sum_{i=1}^{A} \\tau_{i}^{-}$，其中 $A$ 是核子数，$\\tau_{i}^{-}$ 是作用在核子 $i$ 上的同位旋降算符。在仅限于中子到质子跃迁的独立粒子描述中，$F_{-}$ 作用在基态 $|0\\rangle$ 上会产生单粒子-单空穴激发的叠加态，其振幅由占据数决定，我们将其编码为每个可及激发的非负权重。\n- 在此受限通道中，费米跃迁的非能量加权求和规则由 $F_{-}|0\\rangle$ 的模方给出，当模型空间中不允许质子到中子跃迁时，该值等于中子剩余 $N - Z$，其中 $N$ 是中子数，$Z$ 是质子数。在我们的离散计算模型中，此模方通过对与每个可及跃迁相关的非负整数权重求和来计算。\n- 算符 $F$ 的强度函数为 $S(\\omega) = \\sum_{n} \\left|\\langle n|F|0\\rangle\\right|^{2} \\delta\\!\\left(\\omega - (E_{n}-E_{0})\\right)$，其中 $\\{|n\\rangle\\}$ 是哈密顿量 $H$ 的一组完备的激发本征态，其激发能 $E_{n}-E_{0} \\ge 0$。其矩为 $m_{k} = \\int \\omega^{k} S(\\omega)\\, d\\omega$。在具有离散激发能的有限维表示中，这些矩简化为有限求和。\n- Lanczos 强度函数方法通过从归一化枢轴向量 $|v_{0}\\rangle = \\frac{F|0\\rangle}{\\|F|0\\rangle\\|}$ 开始对哈密顿量 $H$ 进行 Lanczos 三对角化来构造一个正交归一基，经过 $L$ 次迭代（如果提前收敛则次数更少）后，产生一个维度为 $L \\times L$ 的对称三对角矩阵 $T_{L}$。$T_{L}$ 的特征值和归一化特征向量的第一个分量定义了一个高斯求积近似，用于逼近与 $H$ 和 $|v_{0}\\rangle$ 相关的谱分布，从而提供能量加权矩 $m_{k}$ 的近似值。\n\n计算设置：\n- 在受限跃迁子空间中，将激发哈密顿量表示为一个对角矩阵 $H = \\mathrm{diag}(\\Delta_{1}, \\Delta_{2}, \\ldots, \\Delta_{K})$，其中 $\\Delta_{j} \\ge 0$ 是以 MeV 为单位的激发能。向量 $|b\\rangle \\equiv F_{-}|0\\rangle$ 在相同基中的分量为 $b_{j} = \\sqrt{w_{j}}$，其中 $w_{j} \\in \\mathbb{N}_{0}$ 是非负整数权重，编码了在能量 $\\Delta_{j}$ 处有多少个不可区分的中子到质子跃迁。非能量加权和（零阶矩）为 $m_{0} = \\langle b|b\\rangle = \\sum_{j=1}^{K} w_{j}$。\n- 当 $m_{0}  0$ 时，从 $|v_{0}\\rangle = \\frac{|b\\rangle}{\\sqrt{m_{0}}}$ 开始执行 $L$ 次 Lanczos 三对角化迭代；如果 $m_{0} = 0$，则跳过 Lanczos 过程，并按下文规定将质心和宽度定义为零。在通常的三项递推关系中，形成具有对角元素 $\\alpha_{\\ell}$ 和非对角元素 $\\beta_{\\ell}$（$\\ell = 0, 1, \\ldots$）的三对角矩阵 $T_{L}$，如果新 Lanczos 向量的模低于一个小阈值，则提前终止。使用 $T_{L}$ 的特征值和归一化特征向量的第一个分量来构造一个高斯求积近似，从而得到前两个能量加权矩 $m_{1}$ 和 $m_{2}$ 的近似值，并由此得到强度分布的质心和宽度。\n- 当 $m_{0}  0$ 时，定义质心为 $E_{\\mathrm{c}} = \\frac{m_{1}}{m_{0}}$（单位 MeV），标准差（宽度）为 $\\sigma = \\sqrt{\\frac{m_{2}}{m_{0}} - \\left(\\frac{m_{1}}{m_{0}}\\right)^{2}}$（单位 MeV）。当 $m_{0} = 0$ 时，按约定设置 $E_{\\mathrm{c}} = 0$ 和 $\\sigma = 0$。\n\n任务：\n- 对于下方的每个测试用例，根据所提供的 $\\{\\Delta_{j}\\}$ 和 $\\{w_{j}\\}$ 构造 $H$ 和 $|b\\rangle$，计算精确的零阶矩 $m_{0} = \\sum_{j=1}^{K} w_{j}$，并在数值容差 $|\\cdot|  10^{-12}$ 内验证受限通道的费米求和规则 $m_{0} = N - Z$。然后，使用案例中指定的 $L$ 次 Lanczos 迭代，通过 Lanczos 三对角化所隐含的高斯求积计算质心 $E_{\\mathrm{c}}$ 和宽度 $\\sigma$（单位 MeV）。如果 $m_{0} = 0$，则将 $E_{\\mathrm{c}}$ 和 $\\sigma$ 都设置为零，而不运行 Lanczos 过程。\n- 所有能量都必须以百万电子伏特（MeV）表示。$E_{\\mathrm{c}}$ 和 $\\sigma$ 的最终输出必须是 MeV 单位的实值浮点数。\n\n测试套件：\n为以下参数集提供结果。对于每个案例，数字以其自然单位给出，能量单位为 MeV。\n- 情况 1：$\\Delta = [1.0, 3.0, 7.0]$, $w = [1, 1, 1]$, $N = 7, Z = 4, L = 3$.\n- 情况 2：$\\Delta = [2.0, 5.0]$, $w = [1, 1]$, $N = 8, Z = 6, L = 2$.\n- 情况 3：$\\Delta = [10.0]$, $w = [4]$, $N = 12, Z = 8, L = 5$.\n- 情况 4：$\\Delta = [1.0, 2.0]$, $w = [0, 0]$, $N = 5, Z = 5, L = 2$.\n- 情况 5：$\\Delta = [1.0, 4.0, 9.0, 16.0]$, $w = [2, 1, 3, 2]$, $N = 13, Z = 5, L = 1$.\n\n要求的最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个按案例划分的结果列表，每个结果本身是一个包含三个条目的列表：第一个是布尔值，指示等式 $m_{0} = N - Z$ 是否在规定容差内成立；第二个是以 MeV 为单位的质心 $E_{\\mathrm{c}}$，为浮点数；第三个是以 MeV 为单位的宽度 $\\sigma$，为浮点数。该行应为用方括号括起来的逗号分隔列表，例如 $[case_1, case_2, \\ldots]$，其中每个 $case_i$ 的格式为 $[boolean, E_c, \\sigma]$。", "solution": "我们从作用于原子核基态 $|0\\rangle$ 的费米电荷交换算符 $F_{-} = \\sum_{i=1}^{A} \\tau_{i}^{-}$ 开始。在给定模型空间内，一个仅限于中子到质子（$n \\rightarrow p$）跃迁的独立粒子图像中，$F_{-}$ 的作用会产生单粒子-单空穴激发的相干叠加。相关的强度函数为 $S(\\omega) = \\sum_{n} \\left|\\langle n|F_{-}|0\\rangle\\right|^{2} \\delta\\!\\left(\\omega - (E_{n}-E_{0})\\right)$，其能量矩为 $m_{k} = \\int \\omega^{k} S(\\omega)\\, d\\omega$。零阶矩 $m_{0}$ 是 $F_{-}|0\\rangle$ 的模方，即 $m_{0} = \\langle 0|F_{+} F_{-}|0\\rangle$。在不允许 $p \\rightarrow n$ 跃迁的所述限制下，根据一个著名的与模型无关的费米求和规则，该值等于中子剩余 $N - Z$。\n\n为了从一般的多体处理过渡到计算上可管理的表示，我们在一个可及激发的正交归一基 $\\{|j\\rangle\\}_{j=1}^{K}$ 中编码强度分布，其中哈密顿量 $H$ 是对角的，$H = \\mathrm{diag}(\\Delta_{1}, \\ldots, \\Delta_{K})$，$\\Delta_{j} \\ge 0$ 是以百万电子伏特（MeV）为单位的激发能。向量 $|b\\rangle \\equiv F_{-}|0\\rangle$ 的分量为 $b_{j} = \\sqrt{w_{j}}$，其中非负整数权重 $w_{j} \\in \\mathbb{N}_{0}$。在此表示中，强度函数为 $S(\\omega) = \\sum_{j=1}^{K} w_{j} \\, \\delta(\\omega - \\Delta_{j})$，低阶矩为有限求和：$m_{0} = \\sum_{j=1}^{K} w_{j}$，$m_{1} = \\sum_{j=1}^{K} w_{j} \\Delta_{j}$，以及 $m_{2} = \\sum_{j=1}^{K} w_{j} \\Delta_{j}^{2}$。当 $m_{0}  0$ 时，质心和宽度由 $E_{\\mathrm{c}} = \\frac{m_{1}}{m_{0}}$ 和 $\\sigma = \\sqrt{\\frac{m_{2}}{m_{0}} - \\left(\\frac{m_{1}}{m_{0}}\\right)^{2}}$ 定义，而按约定，当 $m_{0} = 0$ 时，$E_{\\mathrm{c}} = 0$ 且 $\\sigma = 0$。\n\nLanczos 强度函数方法提供了一种有效的方式来近似与 $(H, |b\\rangle)$ 相关的谱分布，而无需对整个哈密顿量进行对角化。首先构造归一化枢轴向量 $|v_{0}\\rangle = \\frac{|b\\rangle}{\\|b\\|}$，其中 $\\|b\\| = \\sqrt{m_{0}}$，并应用三项 Lanczos 递推关系\n$|w_{\\ell}\\rangle = H|v_{\\ell}\\rangle - \\beta_{\\ell} |v_{\\ell-1}\\rangle$，$\\alpha_{\\ell} = \\langle v_{\\ell}|w_{\\ell}\\rangle$， $|w_{\\ell}\\rangle \\leftarrow |w_{\\ell}\\rangle - \\alpha_{\\ell} |v_{\\ell}\\rangle$，$\\beta_{\\ell+1} = \\|\\,|w_{\\ell}\\rangle\\,\\|$，以及 $|v_{\\ell+1}\\rangle = \\frac{|w_{\\ell}\\rangle}{\\beta_{\\ell+1}}$，\n初始化为 $|v_{-1}\\rangle \\equiv 0$，$\\beta_{0} \\equiv 0$。经过 $L$ 次迭代后（如果 $\\beta_{\\ell+1}$ 在一个小容差内消失，则会提前终止），可以得到一个对称三对角矩阵 $T_{L}$，其对角项为 $\\alpha_{0}, \\ldots, \\alpha_{L-1}$，非对角项为 $\\beta_{1}, \\ldots, \\beta_{L-1}$。谱定理保证了对 $(H, |v_{0}\\rangle)$ 在实线上导出一个正测度（$H$ 相对于 $|v_{0}\\rangle$ 的谱测度）。高斯求积理论接着指出，$T_{L}$ 的特征值 $\\{\\lambda_{j}\\}_{j=1}^{L}$ 与 $T_{L}$ 的归一化特征向量的第一个分量的平方 $\\{w_{j}^{(\\mathrm{GQ})}\\}_{j=1}^{L}$ 一起定义了一个求积规则，在理想算术和精确 Krylov 子空间设置下，该规则对于谱测度的前 $2L$ 个矩是精确的。因此，近似矩可表示为 $m_{k} \\approx m_{0} \\sum_{j=1}^{L} w_{j}^{(\\mathrm{GQ})} \\lambda_{j}^{k}$（对于 $k = 1, 2$），并由此计算出质心和宽度。\n\n算法设计：\n- 输入：激发能列表 $\\{\\Delta_{j}\\}_{j=1}^{K}$（单位 MeV），权重列表 $\\{w_{j}\\}_{j=1}^{K}$，数对 $(N, Z)$，以及 Lanczos 迭代次数 $L$。\n- 计算 $m_{0} = \\sum_{j=1}^{K} w_{j}$ 并通过检查 $|m_{0} - (N - Z)|  10^{-12}$ 来验证费米求和规则，这是一个严格的容差，因为我们的 $m_0$ 是从整数权重精确计算的。\n- 如果 $m_{0} = 0$，则返回 $(\\mathrm{True}, 0.0, 0.0)$，因为受限通道的求和规则不言自明地成立，且强度分布为空。\n- 否则，形成归一化枢轴 $|v_{0}\\rangle = \\frac{|b\\rangle}{\\sqrt{m_{0}}}$，其中 $b_{j} = \\sqrt{w_{j}}$，并执行最多 $L$ 次 Lanczos 迭代，如果新 Lanczos 向量的模低于一个小阈值（例如 $10^{-14}$），则提前终止。在我们的对角 $H$ 表示中，矩阵-向量乘积为 $H|x\\rangle$，其中 $(H x)_{j} = \\Delta_{j} x_{j}$。\n- 组装三对角矩阵 $T_{L}$ 并求解其对称本征问题以获得 $\\{\\lambda_{j}\\}$ 和 $\\{u_{j}\\}$，其中 $u_{j}$ 是第 $j$ 个归一化特征向量。高斯求积权重为 $w_{j}^{(\\mathrm{GQ})} = \\left(u_{j}\\right)_{1}^{2}$，其中 $\\left(u_{j}\\right)_{1}$ 表示 $u_{j}$ 在 Lanczos 基中的第一个分量。计算 $m_{1} \\approx m_{0} \\sum_{j} w_{j}^{(\\mathrm{GQ})} \\lambda_{j}$ 和 $m_{2} \\approx m_{0} \\sum_{j} w_{j}^{(\\mathrm{GQ})} \\lambda_{j}^{2}$，然后如上计算 $E_{\\mathrm{c}}$ 和 $\\sigma$。值得注意的是，对于 $L=1$，质心 $E_{\\mathrm{c}}$ 已经是精确的，因为 $\\alpha_{0} = \\langle v_{0}|H|v_{0}\\rangle = \\frac{\\langle b|H|b\\rangle}{\\langle b|b\\rangle} = \\frac{m_{1}}{m_{0}}$，而宽度通常被低估。\n- 数值稳定性：我们对新的 Lanczos 向量与所有先前的 Lanczos 向量进行完全再正交化，以减轻在有限精度下正交性的损失，尽管在我们的对角表示中，三项递推关系通常已足够。\n\n应用于测试套件：\n- 情况 $1$，参数为 $\\Delta = [1.0, 3.0, 7.0]$，$w = [1, 1, 1]$，$N - Z = 3$，$L = 3$，将得到精确的质心和宽度，因为 Krylov 子空间跨越了整个空间；输出为布尔值 $\\mathrm{True}$、以 MeV 为单位的质心和以 MeV 为单位的宽度。\n- 情况 $2$，参数为 $\\Delta = [2.0, 5.0]$，$w = [1, 1]$，$N - Z = 2$，$L = 2$，同样跨越了整个空间；将得到精确的质心和宽度。\n- 情况 $3$，参数为 $\\Delta = [10.0]$，$w = [4]$，$N - Z = 4$，$L = 5$，会立即截断到一维；质心为 $10.0$ MeV，宽度为 $0.0$ MeV。\n- 情况 $4$，参数为 $\\Delta = [1.0, 2.0]$，$w = [0, 0]$，$N - Z = 0$，没有强度；按约定，质心和宽度均为 $0.0$ MeV，求和规则检查为 $\\mathrm{True}$。\n- 情况 $5$，参数为 $\\Delta = [1.0, 4.0, 9.0, 16.0]$，$w = [2, 1, 3, 2]$，$N - Z = 8$，$L = 1$，演示了单次 Lanczos 迭代可得到精确的质心，但宽度塌缩为 $0.0$ MeV，这说明了高斯求积的截断效应。\n\n程序实现了这些步骤，并打印一行包含每个案例结果 $[boolean, E_c, \\sigma]$ 的列表，其中 $E_c$ 和 $\\sigma$ 的单位是百万电子伏特（MeV）。", "answer": "```python\nimport numpy as np\n\ndef lanczos_tridiagonal(diag_energies, v0, max_iters, tol=1e-14, reorth=True):\n    \"\"\"\n    Perform Lanczos tridiagonalization for a diagonal Hamiltonian H=diag(diag_energies).\n    Args:\n        diag_energies: numpy array of shape (K,), energies Δ_j (MeV).\n        v0: initial normalized vector of shape (K,).\n        max_iters: maximum Lanczos iterations L.\n        tol: threshold for early termination if beta becomes too small.\n        reorth: if True, perform full reorthogonalization against previous vectors.\n    Returns:\n        alphas: list of diagonal entries of T\n        betas: list of off-diagonal entries of T (length len(alphas)-1)\n        V: list of Lanczos vectors (each numpy array)\n    \"\"\"\n    K = diag_energies.shape[0]\n    assert v0.shape == (K,)\n    # Normalize v0 just in case\n    nrm = np.linalg.norm(v0)\n    if nrm == 0.0:\n        return [], [], []\n    v0 = v0 / nrm\n\n    V = []\n    alphas = []\n    betas = []\n\n    v_prev = np.zeros_like(v0)\n    v = v0.copy()\n\n    for it in range(max_iters):\n        # w = H v\n        w = diag_energies * v\n        alpha = float(np.dot(v, w))\n        w = w - alpha * v\n        if it > 0:\n            w = w - betas[-1] * v_prev\n\n        if reorth and len(V) > 0:\n            # Full reorthogonalization against all previous Lanczos vectors\n            for vk in V:\n                coeff = float(np.dot(vk, w))\n                w -= coeff * vk\n\n        beta = float(np.linalg.norm(w))\n        V.append(v.copy())\n        alphas.append(alpha)\n        if beta  tol:\n            break\n        betas.append(beta)\n        v_prev = v\n        v = w / beta\n\n    return alphas, betas, V\n\ndef gauss_quadrature_moments_from_tridiagonal(alphas, betas, m0):\n    \"\"\"\n    Given tridiagonal parameters, compute approximate moments m1 and m2 using Gauss quadrature.\n    Args:\n        alphas: list of diagonal entries of T\n        betas: list of off-diagonal entries of T\n        m0: zeroth moment (norm squared of b)\n    Returns:\n        m1_approx, m2_approx\n    \"\"\"\n    n = len(alphas)\n    if n == 0 or m0 == 0.0:\n        return 0.0, 0.0\n    # Build symmetric tridiagonal T\n    T = np.zeros((n, n), dtype=float)\n    for i in range(n):\n        T[i, i] = alphas[i]\n    for i in range(n - 1):\n        T[i, i + 1] = betas[i]\n        T[i + 1, i] = betas[i]\n    # Eigen-decomposition\n    evals, evecs = np.linalg.eigh(T)\n    # Weights are squares of first row components of eigenvectors (component index 0)\n    weights = (evecs[0, :] ** 2).astype(float)\n    # Approximate moments\n    m1 = m0 * float(np.dot(weights, evals))\n    m2 = m0 * float(np.dot(weights, evals**2))\n    return m1, m2\n\ndef compute_case(energies, weights, N, Z, L):\n    \"\"\"\n    Compute sum-rule verification, centroid, and width for one case.\n    Args:\n        energies: list or array of Δ_j (MeV)\n        weights: list or array of w_j (nonnegative integers)\n        N, Z: neutron and proton numbers (integers)\n        L: number of Lanczos iterations (integer)\n    Returns:\n        (bool_sumrule_ok, centroid_MeV, width_MeV)\n    \"\"\"\n    energies = np.array(energies, dtype=float)\n    weights = np.array(weights, dtype=float)\n    # Build b vector with components sqrt(w_j)\n    b = np.sqrt(weights)\n    m0 = float(np.dot(b, b))  # sum of weights\n    sumrule_target = float(N - Z)\n    sumrule_ok = abs(m0 - sumrule_target)  1e-12\n\n    if m0 == 0.0:\n        # No strength in the restricted channel\n        return [sumrule_ok, 0.0, 0.0]\n\n    # Normalized pivot\n    v0 = b / np.sqrt(m0)\n    # Lanczos\n    alphas, betas, _ = lanczos_tridiagonal(energies, v0, max_iters=int(L), tol=1e-14, reorth=True)\n    # If no steps returned (should not happen with m0>0), fall back to exact moments\n    if len(alphas) == 0:\n        m1 = float(np.dot(weights, energies))\n        m2 = float(np.dot(weights, energies**2))\n    else:\n        m1, m2 = gauss_quadrature_moments_from_tridiagonal(alphas, betas, m0)\n\n    # Centroid and width\n    centroid = m1 / m0\n    variance = m2 / m0 - centroid**2\n    # Numerical safeguard for tiny negative due to roundoff\n    if variance  0 and variance > -1e-12:\n        variance = 0.0\n    width = float(np.sqrt(variance)) if variance >= 0 else float('nan')\n\n    return [sumrule_ok, float(centroid), float(width)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (energies Δ_j in MeV, weights w_j, N, Z, L)\n    test_cases = [\n        ([1.0, 3.0, 7.0], [1, 1, 1], 7, 4, 3),\n        ([2.0, 5.0], [1, 1], 8, 6, 2),\n        ([10.0], [4], 12, 8, 5),\n        ([1.0, 2.0], [0, 0], 5, 5, 2),\n        ([1.0, 4.0, 9.0, 16.0], [2, 1, 3, 2], 13, 5, 1),\n    ]\n\n    results = []\n    for energies, weights, N, Z, L in test_cases:\n        result = compute_case(energies, weights, N, Z, L)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3546731"}]}