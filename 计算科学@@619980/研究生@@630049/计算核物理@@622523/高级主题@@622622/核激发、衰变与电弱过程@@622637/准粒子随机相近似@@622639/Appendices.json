{"hands_on_practices": [{"introduction": "准粒子随机相近似 (QRPA) 是建立在相关基态之上的激发理论。因此，任何 QRPA 计算的第一步都是正确地描述这个基态。这个练习 ([@problem_id:3606041]) 将通过为一个简化的两能级模型实现 Bardeen-Cooper-Schrieffer (BCS) 理论，来提供寻找准粒子真空的实践经验。掌握这一基础技能，对于构建更复杂的核结构模型至关重要。", "problem": "实现一个完整的程序，为简化的常数配对双能级模型构建 Bardeen-Cooper-Schrieffer (BCS) 准粒子真空，并验证作为准粒子随机相位近似 (Quasiparticle Random-Phase Approximation, QRPA) 基础的两个基本恒等式。考虑一个全同费米子系统，这些费米子处于两个单粒子能级上，索引为 $i \\in \\{1,2\\}$，其单粒子能量为 $\\epsilon_i$，对简并度为 $\\Omega_i$（即每个能级上时间反演对的数量）。简化的常数配对哈密顿量为\n$$\nH = \\sum_{i=1}^{2} 2\\,\\epsilon_i\\,\\hat{N}_i \\;-\\; G \\sum_{i,j=1}^{2} \\hat{P}_i^\\dagger \\hat{P}_j,\n$$\n其中 $G \\gt 0$ 是配对强度，$\\hat{N}_i$ 计算能级 $i$ 上的对数，$\\hat{P}_i^\\dagger$ 在能级 $i$ 上创建一个关联对。在零温下，Bardeen-Cooper-Schrieffer (BCS) 方法引入了一个到准粒子的 Bogoliubov-Valatin 变换，其振幅为 $u_i$ 和 $v_i$，并定义了准粒子能量 $E_i$。BCS 态由配对能隙 $\\Delta$ 和化学势 $\\lambda$ 决定，它们在固定粒子数 $N$ 的约束下使基态能量最小化。\n\n对于每个测试用例，你的程序必须通过求解双能级简化常数配对哈密顿量的 BCS 方程，自洽地计算 $u_i$、$v_i$ 和 $E_i$：\n- 准粒子能量定义为\n$$\nE_i \\equiv \\sqrt{(\\epsilon_i - \\lambda)^2 + \\Delta^2}.\n$$\n- 占据数振幅满足\n$$\nv_i^2 \\equiv \\tfrac{1}{2}\\left(1 - \\frac{\\epsilon_i - \\lambda}{E_i}\\right),\\qquad u_i^2 \\equiv 1 - v_i^2.\n$$\n- 能隙方程为\n$$\n\\Delta \\equiv \\frac{G}{2}\\sum_{i=1}^{2}\\Omega_i \\frac{\\Delta}{E_i},\n$$\n这等价于条件\n$$\n\\Delta = 0 \\quad \\text{or} \\quad 1 = \\frac{G}{2}\\sum_{i=1}^{2}\\frac{\\Omega_i}{E_i}.\n$$\n- 粒子数方程为\n$$\nN \\equiv 2\\sum_{i=1}^{2}\\Omega_i\\,v_i^2.\n$$\n\n你的程序必须能稳健地处理 $\\Delta \\gt 0$ 的配对相和 $\\Delta = 0$ 的正常相。在正常相中，$v_i^2$ 的极限值 $\\in \\{0, \\tfrac{1}{2}, 1\\}$ 由 $\\epsilon_i - \\lambda$ 的符号决定，其中 $\\lambda$ 的位置应尽可能满足所要求的粒子数 $N$。\n\n对于每个测试用例，在计算出 $\\{u_i,v_i,E_i\\}_{i=1,2}$ 后，数值上验证以下内容：\n- 对所有时间反演对求和的 Bogoliubov 归一化：\n$$\n\\sum_{i=1}^{2} \\Omega_i \\left(u_i^2 + v_i^2\\right) \\stackrel{?}{=} \\Omega_{\\text{tot}},\n$$\n其中 $\\Omega_{\\text{tot}} \\equiv \\Omega_1 + \\Omega_2$。\n- 粒子数期望值：\n$$\n\\langle N \\rangle \\equiv 2\\sum_{i=1}^{2}\\Omega_i\\,v_i^2 \\stackrel{?}{=} N.\n$$\n\n数值细节和约定：\n- 能量 $\\epsilon_i$、$G$ 和 $E_i$ 以及能隙 $\\Delta$ 必须以兆电子伏（MeV）为单位处理。程序输出中不需要单位，因为输出是布尔值。\n- 在两个验证中，使用 $10^{-10}$ 的数值容差来评估相等性。\n- 不使用角度。不需要百分比输出。\n- 你可以使用任何确定性的数值求根策略来求解 $\\Delta$ 和 $\\lambda$，包括尝试多个初始猜测值。如果找不到 $\\Delta \\gt 0$ 的解，你必须退回到 $\\Delta = 0$ 的正常相，并选择一个与所要求的 $N$ 一致的 $\\lambda$（如果可能）。\n\n测试套件：\n- 案例 $1$（配对，对称，半满）：$\\epsilon = [-0.5, +0.5]$ MeV，$\\Omega = [4, 4]$，$G = 0.2$ MeV，$N = 8$。\n- 案例 $2$（正常相，低于临界耦合）：$\\epsilon = [-0.5, +0.5]$ MeV，$\\Omega = [4, 4]$，$G = 0.1$ MeV，$N = 8$。\n- 案例 $3$（不对称一般情况，配对）：$\\epsilon = [0.0, 1.5]$ MeV，$\\Omega = [3, 5]$，$G = 0.3$ MeV，$N = 10$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个按以下顺序排列的布尔值扁平列表：\n$$\n[\\text{case1\\_norm\\_ok},\\ \\text{case1\\_N\\_ok},\\ \\text{case2\\_norm\\_ok},\\ \\text{case2\\_N\\_ok},\\ \\text{case3\\_norm\\_ok},\\ \\text{case3\\_N\\_ok}],\n$$\n其中，当且仅当相应的验证在 $10^{-10}$ 的容差内成立时，每个条目才为 true。例如，如果所有检查都通过，一个有效的输出可能看起来像 $[True,True,True,True,True,True]$。\n\n实现要求：\n- 最终答案必须是一个完整、可运行的 Python 程序。它不得需要任何用户输入、文件或网络访问。它必须按照上述描述计算测试套件的结果，并以指定的确切格式打印单行输出。", "solution": "该问题要求实现一个程序，用以求解一个双能级原子核模型的 Bardeen-Cooper-Schrieffer (BCS) 方程，并随后验证两个基本恒等式。对问题陈述的验证证实了它是科学上合理的、适定的，并且包含了得出唯一且有意义解所需的所有必要信息。该模型及其相关方程在理论核物理领域是标准的。\n\n解决策略涉及寻找配对能隙 $\\Delta$ 和化学势 $\\lambda$，使其自洽地满足 BCS 方程，对于一组给定的参数：单粒子能量 $\\{\\epsilon_1, \\epsilon_2\\}$、对简并度 $\\{\\Omega_1, \\Omega_2\\}$、配对强度 $G$ 和总粒子数 $N$。解必须考虑到两种可能的相：$\\Delta > 0$ 的配对（超流）相，以及 $\\Delta = 0$ 的正常相。\n\n问题的核心是求解一个关于两个未知数 $\\Delta$ 和 $\\lambda$ 的耦合非线性方程组。该方法分为两部分，分别处理配对相和正常相。\n\n首先，尝试在以 $\\Delta > 0$ 为特征的配对相中寻找解。在此相中，两个控制方程是能隙方程和粒子数方程。\n\n能隙方程由下式给出：\n$$\n1 = \\frac{G}{2}\\sum_{i=1}^{2}\\frac{\\Omega_i}{E_i}\n$$\n其中 $E_i$ 是能级 $i$ 的准粒子能量：\n$$\nE_i = \\sqrt{(\\epsilon_i - \\lambda)^2 + \\Delta^2}\n$$\n粒子数方程为：\n$$\nN = 2\\sum_{i=1}^{2}\\Omega_i\\,v_i^2\n$$\n其中 $v_i^2$ 是能级 $i$ 中对态的占据概率：\n$$\nv_i^2 = \\frac{1}{2}\\left(1 - \\frac{\\epsilon_i - \\lambda}{E_i}\\right)\n$$\n将 $v_i^2$ 和 $E_i$ 的表达式代入，可将能隙和粒子数方程转换为一个仅依赖于 $\\Delta$ 和 $\\lambda$ 的方程组：\n$$\nf_1(\\Delta, \\lambda) = 1 - \\frac{G}{2}\\sum_{i=1}^{2}\\frac{\\Omega_i}{\\sqrt{(\\epsilon_i - \\lambda)^2 + \\Delta^2}} = 0\n$$\n$$\nf_2(\\Delta, \\lambda) = N - \\sum_{i=1}^{2}\\Omega_i \\left(1 - \\frac{\\epsilon_i - \\lambda}{\\sqrt{(\\epsilon_i - \\lambda)^2 + \\Delta^2}}\\right) = 0\n$$\n该方程组通过数值方法求解对 $(\\Delta, \\lambda)$。我们采用一种数值求根算法，具体为 `scipy.optimize.root`，该算法寻找一个向量 $(\\Delta, \\lambda)$，使得残差 $(f_1, f_2)$ 趋于零。为确保得到物理上有意义的解，我们只接受在小的数值容差内 $\\Delta > 0$ 的结果。选择一个合理的初始猜测值，其中 $\\lambda$ 接近单粒子能量的平均值，$\\Delta$ 为一个小的正值。\n\n如果数值求解器未能找到收敛解，或者得到的 $\\Delta$ 不为正，我们则断定系统处于正常相。在此相中，$\\Delta=0$。准粒子能量简化为 $E_i = |\\epsilon_i - \\lambda|$。对于固定粒子数 $N$，基态对应于一个无相互作用的构型，其中单粒子能级按能量递增的顺序填充。化学势 $\\lambda$ 由粒子数条件确定。具体来说，$\\lambda$ 被设定为等于最高已占据（或部分占据）能级的单粒子能量。然后计算占据概率 $v_i^2$，以满足粒子数约束 $N = 2\\sum_i \\Omega_i v_i^2$。对于低于 $\\lambda$ 的能级，$v_i^2=1$；对于高于 $\\lambda$ 的能级，$v_i^2=0$；对于位于 $\\lambda$ 的能级，$v_i^2$ 取一个 $[0,1]$ 内的值以满足粒子数方程。\n\n一旦确定了 $\\Delta$、$\\lambda$ 和相应的 $v_i^2$ 的值，我们计算 $u_i^2 = 1 - v_i^2$。利用这些量，进行两项验证。\n1. Bogoliubov 归一化：计算总和 $\\sum_{i=1}^{2} \\Omega_i (u_i^2 + v_i^2)$，并与总对简并度 $\\Omega_{\\text{tot}} = \\Omega_1 + \\Omega_2$ 进行比较。由于 $u_i^2+v_i^2=1$，这是一个恒等式，可作为对实现方式的合理性检查。\n2. 粒子数期望值：计算粒子数的期望值 $\\langle N \\rangle = 2\\sum_{i=1}^{2}\\Omega_i\\,v_i^2$，并与目标粒子数 $N$ 进行比较。这证实了解正确地满足了约束条件。\n\n两项比较都使用 $10^{-10}$ 的数值容差。每个测试用例得到的布尔结果被编译成一个最终列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\n\n# language: Python\n# version: 3.12\n# libraries:\n#   - name: numpy\n#     version: 1.23.5\n#   - name: scipy\n#     version: 1.11.4\n\ndef solve():\n    \"\"\"\n    Main function to run the BCS calculations for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (paired, symmetric, half-filled)\n        {'eps': np.array([-0.5, 0.5]), 'Omega': np.array([4, 4]), 'G': 0.2, 'N': 8},\n        # Case 2 (normal phase, below critical coupling)\n        {'eps': np.array([-0.5, 0.5]), 'Omega': np.array([4, 4]), 'G': 0.1, 'N': 8},\n        # Case 3 (asymmetric general case, paired)\n        {'eps': np.array([0.0, 1.5]), 'Omega': np.array([3, 5]), 'G': 0.3, 'N': 10},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        norm_ok, n_ok = compute_and_verify(\n            case['eps'], case['Omega'], case['G'], case['N']\n        )\n        all_results.extend([norm_ok, n_ok])\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef compute_and_verify(eps, Omega, G, N):\n    \"\"\"\n    Solves the BCS equations and verifies the identities for a single test case.\n    \n    Returns:\n        tuple[bool, bool]: A tuple containing the boolean results for the\n                           normalization check and the particle number check.\n    \"\"\"\n    tolerance = 1e-10\n\n    def solve_paired_phase(eps, Omega, G, N):\n        \"\"\"Attempts to find a paired solution (Delta > 0).\"\"\"\n        def equations(variables):\n            Delta, lam = variables\n            \n            # Penalize unphysical Delta=0 region to guide the solver\n            if Delta = 0:\n                return [1e10, 1e10]\n\n            # Quasiparticle energies\n            E = np.sqrt((eps - lam)**2 + Delta**2)\n\n            # Avoid division by zero, although Delta > 0 should prevent this.\n            if np.any(E  tolerance):\n                return [1e10, 1e10]\n\n            # Gap equation residual\n            res_gap = (G / 2.0) * np.sum(Omega / E) - 1.0\n            \n            # Number equation residual\n            res_num = np.sum(Omega * (1.0 - (eps - lam) / E)) - N\n            \n            return [res_gap, res_num]\n\n        # Initial guess\n        lam_guess = np.mean(eps)\n        delta_guess = 0.1  # Small positive guess for Delta\n        \n        sol = root(equations, [delta_guess, lam_guess], method='hybr', tol=tolerance)\n        \n        if sol.success and sol.x[0] > tolerance:\n            return sol.x # Returns (Delta, lambda)\n        return None\n\n    solution = solve_paired_phase(eps, Omega, G, N)\n    \n    if solution is not None:\n        # Paired solution found\n        Delta, lam = solution\n        E = np.sqrt((eps - lam)**2 + Delta**2)\n        v_sq = 0.5 * (1.0 - (eps - lam) / E)\n    else:\n        # Fallback to normal phase (Delta = 0)\n        Delta = 0.0\n        \n        # Sort levels by energy to handle filling sequence\n        sort_indices = np.argsort(eps)\n        eps_sorted = eps[sort_indices]\n        Omega_sorted = Omega[sort_indices]\n\n        N_level1_capacity = 2 * Omega_sorted[0]\n        \n        v_sq_sorted = np.zeros(2)\n        \n        # Determine lambda and occupations based on N\n        if N = N_level1_capacity:\n            lam = eps_sorted[0]\n            if N_level1_capacity > 0:\n                v_sq_sorted[0] = N / N_level1_capacity\n            # v_sq_sorted[1] is already 0\n        else:\n            lam = eps_sorted[1]\n            v_sq_sorted[0] = 1.0\n            N_remaining = N - N_level1_capacity\n            N_level2_capacity = 2 * Omega_sorted[1]\n            if N_level2_capacity > 0:\n                v_sq_sorted[1] = N_remaining / N_level2_capacity\n        \n        # Revert sorting to match original order of eps/Omega\n        v_sq = v_sq_sorted[np.argsort(sort_indices)]\n\n    u_sq = 1.0 - v_sq\n\n    # --- Verifications ---\n    \n    # 1. Bogoliubov normalization check\n    Omega_tot = np.sum(Omega)\n    norm_check_val = np.sum(Omega * (u_sq + v_sq))\n    norm_ok = np.isclose(norm_check_val, Omega_tot, atol=tolerance, rtol=0)\n\n    # 2. Particle number expectation check\n    number_check_val = 2.0 * np.sum(Omega * v_sq)\n    n_ok = np.isclose(number_check_val, N, atol=tolerance, rtol=0)\n\n    return bool(norm_ok), bool(n_ok)\n\nsolve()\n```", "id": "3606041"}, {"introduction": "在建立了基态之后，我们就可以描述它的激发。这个练习 ([@problem_id:3606102]) 深入探讨了 QRPA 的核心，通过为一个具有可分离相互作用的示意性模型构建并对角化 QRPA 矩阵，来计算集体激发态的能量。通过这个练习，你将获得关于剩余相互作用如何混合简单的二准粒子组态以形成集体运动的宝贵经验，并了解抽象的 QRPA 方程如何在计算中得以实现。", "problem": "通过对一个示意性的、由可分离的粒子-空穴剩余相互作用增强的自洽配对平均场的随时间演化的Hartree-Fock-Bogoliubov (TDHFB) 方程进行线性化，实现一个数值小振幅线性响应计算。目标是使用准粒子随机相近似 (QRPA) 计算最低集体激发能，并验证其对于双准粒子基截断的收敛性。\n\n从以下符合背景的基准出发：\n- 广义密度矩阵的 TDHFB 方程为 $i \\hbar \\, d\\mathcal{R}/dt = [\\mathcal{H}[\\mathcal{R}], \\mathcal{R}]$，在原子核结构应用中，以兆电子伏特 (MeV) 为能量单位时，通常设 $\\hbar = 1$。\n- 对于一个常数配对哈密顿量，其 Hartree-Fock-Bogoliubov (HFB) 基态可通过 Bardeen-Cooper-Schrieffer (BCS) 能隙方程和粒子数条件共同求得。考虑一个由 $\\Omega$ 个双重简并单粒子能级组成的对称“栅栏”谱，其能量 $\\{\\epsilon_k\\}$ 是相对于在对称点选择的参考化学势来度量的。在恰好半满且谱对称的情况下，可取化学势 $\\lambda = 0$，并求解能隙方程 $1 = G \\sum_k \\left(2 \\sqrt{\\epsilon_k^2 + \\Delta^2}\\right)^{-1}$ 以求得配对能隙 $\\Delta$。准粒子能量为 $E_k = \\sqrt{\\epsilon_k^2 + \\Delta^2}$，占据数振幅为 $u_k^2 = \\frac{1}{2}\\left(1 + \\frac{\\epsilon_k}{E_k}\\right)$ 和 $v_k^2 = 1 - u_k^2$。\n- 剩余粒子-空穴相互作用采用可分离算符的形式 $V_{\\mathrm{res}} = -\\kappa \\, \\hat{Q} \\, \\hat{Q}$，其中 $\\hat{Q} = \\sum_k f_k \\left(\\hat{n}_k + \\hat{n}_{\\bar{k}}\\right)$ 且 $\\hat{n}_k = a_k^\\dagger a_k$。这个单体算符通过其 Bogoliubov 展开中的反常项与双准粒子激发耦合。\n\n任务要求：\n1. 从线性化的 TDHFB 方程出发，在基于 HFB 基态构建的双准粒子基中推导 QRPA 本征值问题。使用准玻色子近似和 QRPA 矩阵的对易子-对易子定义，得到以 HFB 准粒子能量和由 $\\hat{Q}$ 诱导的耦合形状因子表示的矩阵的显式表达式。\n2. 对于上述示意性模型，将双准粒子基限制在时间反演配对态 $\\{|k \\, \\bar{k}\\rangle\\}$ 上，其未受扰动的双准粒子能量为 $2 E_k$。通过仅保留此基中能量最低的 $N_{\\mathrm{trunc}}$ 个双准粒子组态来实现截断。\n3. 计算求解所推导的本征值问题的最低 QRPA 正本征频率 $\\omega_{\\min}$。该量是 QRPA 矩阵的最小正本征值，代表了以 MeV 为单位的最低集体激发能。\n4. 通过计算多个 $N_{\\mathrm{trunc}}$ 值对应的 $\\omega_{\\min}$，来验证其对于双准粒子截断的收敛性。\n\n需实现的数值和物理细节：\n- 使用具有 $\\Omega$ 个双重简并能级的“栅栏”谱：$\\epsilon_k = \\left(k - \\frac{\\Omega + 1}{2}\\right) d$，其中 $k \\in \\{1,2,\\dots,\\Omega\\}$，使得在半满时谱关于零点对称。根据对称性取 $\\lambda = 0$。\n- 使用稳健的求根方法求解 Bardeen-Cooper-Schrieffer (BCS) 能隙方程以得到 $\\Delta$，并计算 $\\{E_k, u_k, v_k\\}$。\n- 在算符 $\\hat{Q}$ 中选择结构因子 $f_k = \\epsilon_k$，这将导致与双准粒子空间的非平凡耦合。\n- 在截断的 $\\{|k \\, \\bar{k}\\rangle\\}$ 基中构建 QRPA 矩阵并求解其本征值；选择最小的正本征值作为 $\\omega_{\\min}$。\n- 所有能量以 MeV 表示。您的程序必须将报告的每个 $\\omega_{\\min}$ 四舍五入到 MeV 的三位小数。\n\n测试套件和要求的最终输出格式：\n- 使用以下五组测试用例，每组由 $(\\Omega, d, G, \\kappa, N_{\\mathrm{trunc}})$ 指定，所有耦合常数和能量单位均为 MeV：\n    - 测试 1 (正常路径)：$(20, 0.5, 0.55, 0.04, 4)$\n    - 测试 2 (收敛性增加)：$(20, 0.5, 0.55, 0.04, 8)$\n    - 测试 3 (边界情况，无剩余耦合)：$(20, 0.5, 0.55, 0.00, 8)$\n    - 测试 4 (边缘情况，最小截断)：$(10, 0.5, 0.60, 0.06, 1)$\n    - 测试 5 (覆盖性，更密集的谱)：$(30, 0.25, 0.40, 0.03, 10)$\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[\\omega_1,\\omega_2,\\dots,\\omega_5]$，其中每个 $\\omega_i$ 是对应测试用例的最低集体激发能，单位为 MeV，四舍五入到三位小数。\n\n所有计算必须是纯数值和自包含的，仅使用指定的运行时环境。不允许用户输入。答案必须按规定以 MeV 为单位，四舍五入到三位小数，并采用上述确切的输出格式。此问题不涉及角度。此问题不涉及百分比。", "solution": "该问题要求为一个示意性的原子核模型实现一个准粒子随机相近似 (QRPA) 计算，以找到最低的集体激发能。这涉及到在小振幅极限下求解随时间演化的Hartree-Fock-Bogoliubov (TDHFB) 方程。步骤如下：首先，在Hartree-Fock-Bogoliubov (HFB) 框架内，使用 Bardeen-Cooper-Schrieffer (BCS) 理论确定基态。其次，推导并求解描述围绕此基态的线性响应的 QRPA 方程，以计入指定的剩余相互作用。\n\n原子核由 $\\Omega$ 个双重简并的单粒子能级建模，其能量为 $\\epsilon_k = (k - (\\Omega + 1)/2)d$（其中 $k \\in \\{1, 2, \\dots, \\Omega\\}$），围绕化学势 $\\lambda=0$ 对称。粒子通过强度为 $G$ 的常数配对力相互作用。\n\n**1. 基态：HFB/BCS 解**\n\nHFB 基态通过求解 BCS 方程得到。配对能隙 $\\Delta$ 由能隙方程确定：\n$$\n1 = G \\sum_{k=1}^{\\Omega} \\frac{1}{2 \\sqrt{\\epsilon_k^2 + \\Delta^2}}\n$$\n这是一个关于 $\\Delta$ 的非线性方程，必须使用求根算法进行数值求解。给定 $\\Delta$，每个能级 $k$ 的准粒子能量 $E_k$ 和占据数振幅 $u_k, v_k$ 由下式给出：\n$$\nE_k = \\sqrt{\\epsilon_k^2 + \\Delta^2}\n$$\n$$\nu_k^2 = \\frac{1}{2} \\left(1 + \\frac{\\epsilon_k}{E_k}\\right), \\quad v_k^2 = \\frac{1}{2} \\left(1 - \\frac{\\epsilon_k}{E_k}\\right)\n$$\nHFB 基态是这些准粒子的真空态。激发是在这个态的基础上构建的。\n\n**2. 集体激发的 QRPA 方程**\n\n围绕 HFB 基态的小振幅振荡由 QRPA 描述。对于能量为 $\\omega$ 的激发，QRPA 运动方程可以表示为一个矩阵本征值问题：\n$$\n\\begin{pmatrix} A   B \\\\ -B^*   -A^* \\end{pmatrix} \\begin{pmatrix} X \\\\ Y \\end{pmatrix} = \\omega \\begin{pmatrix} X \\\\ Y \\end{pmatrix}\n$$\n在这里，$X$ 和 $Y$ 分别是激发的前向和后向振幅，基由双准粒子 (2QP) 态组成。对于指定的问题，我们考虑形式为 $|k\\bar{k}\\rangle = \\beta_k^\\dagger \\beta_{\\bar{k}}^\\dagger |\\text{HFB}\\rangle$ 的 2QP 态，其中 $\\beta^\\dagger$ 产生一个准粒子，而 $|\\text{HFB}\\rangle$ 是 HFB 基态。态 $|k\\bar{k}\\rangle$ 的未受扰动能量为 $2E_k$。对于给定的相互作用，矩阵 $A$ 和 $B$ 是实对称的。\n\nQRPA 矩阵 $A$ 和 $B$ 由涉及完整哈密顿量 $H = H_{HFB} + V_{\\mathrm{res}}$ 的对易子-对易子（双对易子）定义：\n$$\nA_{ij} = \\langle \\text{HFB} | [\\beta_{\\bar{i}}\\beta_i, [H, \\beta_j^\\dagger\\beta_{\\bar{j}}^\\dagger]] | \\text{HFB} \\rangle\n$$\n$$\nB_{ij} = -\\langle \\text{HFB} | [\\beta_{\\bar{i}}\\beta_i, [H, \\beta_{\\bar{j}}\\beta_j]] | \\text{HFB} \\rangle\n$$\n哈密顿量的 HFB 部分 $H_{HFB}$ 对矩阵 $A$ 贡献一个对角项 $2E_i \\delta_{ij}$，对 $B$ 的贡献为零。剩余相互作用 $V_{\\mathrm{res}} = -\\kappa \\hat{Q}\\hat{Q}$（其中 $\\hat{Q} = \\sum_k \\epsilon_k (\\hat{n}_k+\\hat{n}_{\\bar k})$）提供了描述集体响应的非对角耦合。\n\n算符 $\\hat{Q}$ 是粒子数算符之和，并且是时间偶的。它与 2QP 空间的耦合来自于它在基态和 2QP 态之间的矩阵元，即所谓的“反常”项。对于指定的算符 $\\hat{Q}$，该矩阵元为：\n$$\nq_k \\equiv \\langle k\\bar{k} | \\hat{Q} | \\text{HFB} \\rangle = 2 f_k u_k v_k = 2 \\epsilon_k \\frac{\\Delta}{2E_k} = \\frac{\\epsilon_k \\Delta}{E_k}\n$$\n对于形式为 $V_{\\mathrm{res}} = -\\kappa \\hat{Q}\\hat{Q}$ 的可分离粒子-空穴相互作用，其对 QRPA 矩阵的贡献是一个标准结果：\n$$\nA'_{ij} = -2\\kappa q_i q_j\n$$\n$$\nB'_{ij} = -2\\kappa q_i q_j\n$$\n因此，完整的 QRPA 矩阵为：\n$$\nA_{ij} = 2E_i \\delta_{ij} - 2\\kappa q_i q_j\n$$\n$$\nB_{ij} = -2\\kappa q_i q_j\n$$\n指标 $i$ 和 $j$ 遍历截断基中包含的 2QP 态集合。\n\n**3. 数值实现**\n\n寻找最低集体激发能 $\\omega_{\\min}$ 的算法步骤如下：\n1.  对于给定的参数 $(\\Omega, d, G, \\kappa, N_{\\mathrm{trunc}})$，首先计算单粒子能量 $\\epsilon_k$。\n2.  对 $\\Delta  0$ 数值求解 BCS 能隙方程。我们使用 Brent-Dekker 方法，因其稳健性。\n3.  计算所有 $k \\in \\{1, \\dots, \\Omega\\}$ 的准粒子能量 $E_k$。\n4.  2QP 基由具有未受扰动能量 $2E_k$ 的态构成。我们通过选择能量 $2E_k$ 最低的 $N_{\\mathrm{trunc}}$ 个态来截断此基。设这些选定能级的指标为 $I_{\\mathrm{trunc}}$。\n5.  对于每个 $k \\in I_{\\mathrm{trunc}}$，计算耦合因子 $q_k = \\epsilon_k \\Delta / E_k$。\n6.  使用推导出的表达式构建 $N_{\\mathrm{trunc}} \\times N_{\\mathrm{trunc}}$ 矩阵 $A$ 和 $B$。\n7.  构成完整的 $2N_{\\mathrm{trunc}} \\times 2N_{\\mathrm{trunc}}$ QRPA 矩阵 $\\mathcal{M} = \\begin{pmatrix} A   B \\\\ -B   -A \\end{pmatrix}$。\n8.  计算 $\\mathcal{M}$ 的本征值。本征值为实数，并以 $\\pm \\omega$ 对的形式出现。\n9.  最低的正数本征值对应于最低的集体激发能 $\\omega_{\\min}$。\n10. 对每个测试用例重复此过程，可以观察到 $\\omega_{\\min}$ 相对于 $N_{\\mathrm{trunc}}$ 的收敛性。$\\kappa=0$ 的值对应于未受扰动的情况，此时 QRPA 本征值就是 2QP 能量 $2E_k$。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Implements a QRPA calculation for a schematic nuclear model to find the\n    lowest collective excitation energy.\n    \"\"\"\n    test_cases = [\n        (20, 0.5, 0.55, 0.04, 4),   # Test 1\n        (20, 0.5, 0.55, 0.04, 8),   # Test 2\n        (20, 0.5, 0.55, 0.00, 8),   # Test 3\n        (10, 0.5, 0.60, 0.06, 1),   # Test 4\n        (30, 0.25, 0.40, 0.03, 10), # Test 5\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        Omega, d, G, kappa, N_trunc = case\n        \n        # 1. Single-particle spectrum\n        k_vals = np.arange(1, Omega + 1)\n        epsilons = (k_vals - (Omega + 1) / 2) * d\n        \n        # 2. Solve BCS gap equation for Delta\n        def gap_equation_func(delta, G_val, eps_vals):\n            if delta = 1e-9: # The gap must be positive\n                return -1.0 # Return a value that indicates failure or wrong side\n            \n            # Avoid division by zero if delta is very small and an epsilon is zero\n            energies = np.sqrt(eps_vals**2 + delta**2)\n            if np.any(energies  1e-12):\n                return np.inf\n\n            return 1.0 - G_val * np.sum(1.0 / (2.0 * energies))\n\n        try:\n            # A non-zero gap exists only if G > G_crit. If not, brentq fails.\n            # In that case, Delta = 0 is the solution.\n            Delta = brentq(gap_equation_func, 1e-6, 20.0, args=(G, epsilons))\n        except ValueError:\n            Delta = 0.0\n\n        # Handle the non-interacting case (G=0) or sub-critical G\n        if Delta == 0.0:\n            if G > 0: # Check if brentq failed for another reason\n                # Sum at Delta=0, check if starting point is valid\n                # If sum > 1/G, a solution exists.\n                test_sum = G * np.sum(1.0 / (2.0 * np.abs(epsilons[epsilons != 0])))\n                if test_sum = 1.0: # No gap solution, physics is correct\n                    pass\n                else: # Numerical failure\n                    raise RuntimeError(\"BCS solver failed to find a valid gap.\")\n            E_k = np.abs(epsilons)\n        else:\n            E_k = np.sqrt(epsilons**2 + Delta**2)\n\n        # 3. Truncate the two-quasiparticle (2QP) basis\n        # Sort by 2QP energy 2*E_k and select the N_trunc lowest\n        sorted_indices = np.argsort(E_k)\n        trunc_indices = sorted_indices[:N_trunc]\n        \n        E_trunc = E_k[trunc_indices]\n        eps_trunc = epsilons[trunc_indices]\n        \n        # If kappa is zero, the answer is the lowest unperturbed 2QP energy\n        if kappa == 0.0:\n            omega_min = 2.0 * E_trunc[0]\n            results.append(f\"{omega_min:.3f}\")\n            continue\n\n        # 4. Construct QRPA matrices A and B\n        if Delta == 0.0: # No pairing, q_k factors are zero\n            q_k_trunc = np.zeros_like(E_trunc)\n        else:\n            q_k_trunc = eps_trunc * Delta / E_trunc\n        \n        A = np.diag(2.0 * E_trunc) - 2.0 * kappa * np.outer(q_k_trunc, q_k_trunc)\n        B = -2.0 * kappa * np.outer(q_k_trunc, q_k_trunc)\n        \n        # 5. Form the full QRPA matrix M and solve the eigenvalue problem\n        M = np.block([\n            [A, B],\n            [-B, -A]\n        ])\n        \n        eigenvalues = np.linalg.eigvals(M)\n        \n        # 6. Find the lowest positive eigenvalue\n        positive_eigenvalues = eigenvalues.real[eigenvalues.real > 1e-9]\n        if len(positive_eigenvalues) == 0:\n            # This can happen if the QRPA collapses (imaginary eigenvalues)\n            # or if all eigenvalues are zero.\n            omega_min = 0.0\n        else:\n            omega_min = np.min(positive_eigenvalues)\n            \n        results.append(f\"{omega_min:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3606102"}, {"introduction": "QRPA 不仅可以计算激发谱，它还是一个检验 HFB 基态稳定性的强大诊断工具。当 QRPA 本征值出现虚数时，表明存在动力学不稳定性。这个最后的练习 ([@problem_id:3606057]) 展示了 QRPA 的这一重要应用。你将通过计算模拟一个过强的剩余相互作用如何导致动力学不稳定性，这在 QRPA 谱中表现为虚数本征值的出现，从而在抽象的 QRPA 形式与核系统中的相变物理概念之间建立了切实的联系。", "problem": "要求您实现一个计算实验，用于检测一个由简化能量密度泛函（EDF）描述的有限系统中，配对通道的准粒子随机相近似（QRPA）不稳定性的发生。其目标是通过改变剩余配对强度，识别QRPA谱何时出现虚数本征值。这表明所选的EDF参数违反了配对通道中的局域稳定性（Thouless稳定性）。本问题聚焦于建立在Hartree-Fock-Bogoliubov（HFB）基态上的配对振动模式，并使用Bardeen-Cooper-Schrieffer（BCS）近似来获得准粒子谱。\n\n定义和设置：\n- 该EDF在一组正则基中由相对于化学势 $ \\mu $ 的一组单粒子能量 $ \\{\\epsilon_k\\}_{k=1}^N $ 和一个基线强度为 $ G_0 $（单位为MeV）的吸引配对相互作用来表示。在QRPA中，EDF的剩余配对顶点由一个无量纲控制因子 $ \\alpha $ 进行缩放，因此进入QRPA $ B $ 矩阵的剩余配对强度为 $ \\alpha G_0 $。\n- 从单粒子谱出发，通过求解配对能隙 $ \\Delta $ 的配对能隙方程，可以得到Bardeen-Cooper-Schrieffer（BCS）近似下的HFB基态，\n$$\n1 = G_0 \\sum_{k=1}^N \\frac{1}{2 E_k},\n$$\n其中准粒子能量 $ E_k $ 满足\n$$\nE_k = \\sqrt{(\\epsilon_k - \\mu)^2 + \\Delta^2}.\n$$\n如果对于给定的 $ G_0 $ 不存在正解 $ \\Delta  0 $，则设 $ \\Delta = 0 $，系统保持在正常相。\n- Bogoliubov振幅 $ u_k $ 和 $ v_k $ 定义为\n$$\nu_k^2 = \\frac{1}{2}\\left(1 + \\frac{\\epsilon_k - \\mu}{E_k}\\right), \\quad v_k^2 = \\frac{1}{2}\\left(1 - \\frac{\\epsilon_k - \\mu}{E_k}\\right), \\quad u_k v_k = \\frac{\\Delta}{2 E_k}.\n$$\n- 在正则双准粒子基中，QRPA矩阵具有如下的分块结构\n$$\n\\mathcal{H} = \\begin{pmatrix} A   B \\\\ -B   -A \\end{pmatrix},\n$$\n其中各分块定义为\n$$\nA_{kk'} = 2 E_k \\, \\delta_{kk'}, \\qquad B_{kk'} = \\alpha G_0 \\, F_k F_{k'},\n$$\n其中 $ F_k = u_k v_k = \\dfrac{\\Delta}{2 E_k} $。QRPA本征值问题可写为\n$$\n\\mathcal{H} \\begin{pmatrix} X \\\\ Y \\end{pmatrix} = \\omega \\begin{pmatrix} X \\\\ Y \\end{pmatrix}.\n$$\n在稳定条件下，本征频率 $ \\omega $ 是实数（存在一个与破缺的规范对称性相关的赝零频模式），而当 $ \\omega $ 出现虚部时，则表示基态相对于配对振动存在动力学不稳定性。\n\n您的任务：\n1. 对于给定的 $ \\{\\epsilon_k\\} $、$ \\mu $ 和 $ G_0 $，通过求解BCS能隙方程来实现对 $ \\Delta $ 的计算。如果方程没有 $ \\Delta  0 $ 的解，则设 $ \\Delta = 0 $。\n2. 计算 $ E_k $、$ u_k $、$ v_k $ 和 $ F_k $。\n3. 构建QRPA矩阵 $ \\mathcal{H} $ 并计算其本征值 $ \\omega $。\n4. 确定所有QRPA本征值中虚部的最大绝对值，\n$$\nI_{\\max} = \\max_i \\left| \\operatorname{Im}(\\omega_i) \\right|.\n$$\n不稳定的发生由 $ I_{\\max}  0 $ 指示。\n5. 对于每个测试用例，您的程序必须以浮点数形式输出 $ I_{\\max} $ 的值（单位为MeV），并四舍五入到六位小数。\n\n物理单位：\n- 所有能量（包括 $ \\epsilon_k $、$ \\mu $、$ G_0 $、$ \\Delta $、$ E_k $ 和本征值 $ \\omega $）都必须以MeV为单位处理。\n- 您的程序的输出 $ I_{\\max} $ 必须以MeV表示。\n\n角度单位：\n- 本问题中不使用角度单位。\n\n输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，例如，“[$r_1$,$r_2$,$r_3$]”。每个 $ r_i $ 是对应测试用例的 $ I_{\\max} $ 值，四舍五入到六位小数。\n\n测试套件：\n对所有测试用例使用以下正则基、基线配对和化学势：\n- $ \\{\\epsilon_k\\} = [-3.0, -1.5, -0.5, 0.5, 1.5, 3.0] $ MeV，\n- $ \\mu = 0.0 $ MeV，\n- $ G_0 = 0.9 $ MeV。\n\n改变剩余配对缩放因子 $ \\alpha $ 的值，以形成六个测试用例：\n- 情况1：$ \\alpha = 0.5 $（减小的剩余配对；预期稳定），\n- 情况2：$ \\alpha = 1.0 $（自洽剩余配对；预期稳定），\n- 情况3：$ \\alpha = 1.5 $（中度增加；预期稳定），\n- 情况4：$ \\alpha = 2.0 $（接近稳定性边界；可能出现软化），\n- 情况5：$ \\alpha = 2.5 $（超出稳定性边界；预期不稳定），\n- 情况6：$ \\alpha = 3.0 $（远超稳定性边界；预期出现更显著的不稳定性）。\n\n您的程序必须实现上述步骤，并为六个测试用例中的每一个，精确地生成指定的单行输出，其中 $ I_{\\max} $ 以MeV为单位，四舍五入到六位小数。", "solution": "问题陈述已经过仔细审查，并被确定为 **有效**。它提出了一个在计算核物理领域中自洽、有科学依据且定义明确的问题。其定义、参数和目标都足够清晰和精确，可以得出一个唯一且可验证的解。\n\n任务是通过分析准粒子随机相近似（QRPA）矩阵的本征值，来确定一个简化核系统中配对不稳定性的起始点。不稳定性由出现具有非零虚部的本征值来标识。计算QRPA本征值最大绝对虚部 $I_{\\max}$ 的过程包括三个主要步骤。\n\n首先，我们必须在Bardeen-Cooper-Schrieffer（BCS）近似下确定系统的基态性质。核心量是配对能隙 $\\Delta$，它是通过求解BCS能隙方程得到的。给定相对于化学势 $\\mu$ 的单粒子能量集 $\\{ \\epsilon_k \\}_{k=1}^N$ 和基线配对强度 $G_0$，能隙方程为：\n$$\n1 = G_0 \\sum_{k=1}^N \\frac{1}{2 E_k}\n$$\n其中准粒子能量 $E_k$ 依赖于 $\\Delta$：\n$$\nE_k = \\sqrt{(\\epsilon_k - \\mu)^2 + \\Delta^2}\n$$\n这是一个关于 $\\Delta$ 的非线性方程。我们可以定义一个函数 $f(\\Delta^2) = G_0 \\sum_{k=1}^N \\frac{1}{2\\sqrt{(\\epsilon_k - \\mu)^2 + \\Delta^2}} - 1$ 并找到使 $f(\\Delta^2)=0$ 的根 $\\Delta^2  0$。对于给定的参数 $\\epsilon_k = [-3.0, -1.5, -0.5, 0.5, 1.5, 3.0]$ MeV, $\\mu=0.0$ MeV, 以及 $G_0=0.9$ MeV，存在一个唯一的 $\\Delta$ 正解。这一点可以通过观察函数 $f(\\Delta^2)$ 在 $\\Delta^2  0$ 时是连续且单调的，并且 $f(0)  0$ 以及 $\\lim_{\\Delta^2 \\to \\infty} f(\\Delta^2) = -1$ 来证实。该根通过数值方法找到。如果不存在 $\\Delta  0$ 的解，我们将设置 $\\Delta=0$。\n\n其次，在确定了 $\\Delta$ 的值之后，我们计算构建QRPA矩阵所需的必要分量。这些分量是准粒子能量 $E_k$ 和量 $F_k$，定义如下：\n$$\nF_k = u_k v_k = \\frac{\\Delta}{2 E_k}\n$$\n其中 $u_k$ 和 $v_k$ 是Bogoliubov变换振幅。\n\n第三，对于缩放因子 $\\alpha$ 的每个指定值，我们构建并对角化QRPA矩阵 $\\mathcal{H}$。矩阵 $\\mathcal{H}$ 在双准粒子基中定义，并具有 $2 \\times 2$ 的分块结构：\n$$\n\\mathcal{H} = \\begin{pmatrix} A   B \\\\ -B   -A \\end{pmatrix}\n$$\n分块 $A$ 和 $B$ 是 $N \\times N$ 矩阵（这里 $N=6$）。矩阵 $A$ 代表未微扰的双准粒子能量，并且是对角的：\n$$\nA_{kk'} = 2 E_k \\, \\delta_{kk'}\n$$\n矩阵 $B$ 代表由因子 $\\alpha$ 缩放的剩余配对相互作用：\n$$\nB_{kk'} = \\alpha G_0 \\, F_k F_{k'}\n$$\n这种形式表明 $B$ 是一个秩为1的矩阵，由向量 $\\mathbf{F} = (F_1, \\dots, F_N)^T$ 的外积构成。对于测试套件中提供的每个 $\\alpha$ 值，我们构建 $12 \\times 12$ 的矩阵 $\\mathcal{H}$，并使用标准的数值线性代数库计算其本征值 $\\omega_i$。\n\n最后，评估系统的稳定性。QRPA矩阵 $\\mathcal{H}$ 的本征值 $\\omega_i$通常是复数。如果所有本征值都是实数，则系统相对于所考虑的振动是稳定的。如果任何本征值获得了非零虚部，则系统是不稳定的。这种不稳定性的度量由 $I_{\\max}$ 给出：\n$$\nI_{\\max} = \\max_i \\left| \\operatorname{Im}(\\omega_i) \\right|\n$$\n一个 $I_{\\max}  0$ 的值表示动力学不稳定性的开始。计算过程包括为每个测试用例计算该值，并以指定的精度报告。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the QRPA instability problem for a simplified EDF.\n    \n    This function performs the following steps for each test case:\n    1. Solves the BCS gap equation for the pairing gap Delta.\n    2. Computes quasiparticle energies E_k and pairing tensor components F_k.\n    3. For each value of alpha, constructs the QRPA matrix H.\n    4. Computes the eigenvalues of H.\n    5. Determines the maximum absolute value of the imaginary parts of the eigenvalues.\n    6. Formats and prints the results.\n    \"\"\"\n    \n    # --- Givens from the problem statement ---\n    \n    # Canonical basis single-particle energies (MeV)\n    epsilons = np.array([-3.0, -1.5, -0.5, 0.5, 1.5, 3.0])\n    # Chemical potential (MeV)\n    mu = 0.0\n    # Baseline pairing strength (MeV)\n    G0 = 0.9\n    \n    # Test cases for the residual pairing scaling factor alpha\n    test_cases = [0.5, 1.0, 1.5, 2.0, 2.5, 3.0]\n\n    # --- Step 1: Solve the BCS Gap Equation for Delta ---\n    \n    def bcs_equation_func(delta_sq, eps, mu_val, g0_val):\n        \"\"\"\n        Defines the function whose root gives the solution to the BCS gap equation.\n        The function is f(x) = G0 * sum(1 / (2*E_k)) - 1, where x = Delta^2.\n        \"\"\"\n        if delta_sq  0:\n            # Delta^2 must be non-negative. Return a large value to guide solver.\n            return 1.0e6\n        \n        # Quasiparticle energies\n        E_k = np.sqrt((eps - mu_val)**2 + delta_sq)\n        \n        # The sum in the gap equation. Avoid division by zero if any E_k is zero.\n        # Although for this problem, E_k is always > 0 if delta_sq >= 0.\n        sum_val = np.sum(1.0 / (2.0 * E_k))\n        \n        return g0_val * sum_val - 1.0\n\n    # Check if a non-trivial solution (Delta > 0) exists\n    if bcs_equation_func(0, epsilons, mu, G0) = 0:\n        Delta = 0.0\n    else:\n        # Find the root for Delta^2 using Brent's method.\n        # Bracket [0, 100] is a safe range for Delta^2 in MeV^2.\n        # A small positive lower bound is used to ensure Delta > 0.\n        try:\n            delta_squared = brentq(bcs_equation_func, 1e-9, 100.0, args=(epsilons, mu, G0))\n            Delta = np.sqrt(delta_squared)\n        except ValueError:\n            # This case should not be reached with the given parameters\n            Delta = 0.0\n\n    # --- Step 2: Compute QRPA matrix components ---\n    \n    # Quasiparticle energies E_k\n    E_k = np.sqrt((epsilons - mu)**2 + Delta**2)\n    \n    # F_k = u_k * v_k\n    F_k_vec = Delta / (2.0 * E_k)\n    \n    results = []\n    \n    # --- Steps 3  4: Loop through test cases, compute eigenvalues and I_max ---\n    \n    for alpha in test_cases:\n        # The A matrix of the QRPA Hamiltonian\n        N = len(epsilons)\n        A_mat = np.diag(2.0 * E_k)\n        \n        # The B matrix of the QRPA Hamiltonian\n        B_mat = alpha * G0 * np.outer(F_k_vec, F_k_vec)\n        \n        # The full QRPA Hamiltonian H\n        H_mat = np.block([\n            [A_mat, B_mat],\n            [-B_mat, -A_mat]\n        ])\n        \n        # Compute eigenvalues of H\n        eigenvalues = np.linalg.eigvals(H_mat)\n        \n        # Find the maximum absolute imaginary part\n        I_max = np.max(np.abs(np.imag(eigenvalues)))\n        \n        # Append the rounded result\n        results.append(f\"{I_max:.6f}\")\n\n    # --- Final Output ---\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solution\nsolve()\n\n```", "id": "3606057"}]}