{"hands_on_practices": [{"introduction": "在处理球对称系统（如原子核平均场）时，许多物理量（如径向波函数或势）在原点 $r=0$ 处必须是“正则”的。这一物理要求意味着函数在原点的一阶导数必须为零。本练习将引导你推导出一个施加在样条插值上的边界条件，从而将这一重要的物理正则性约束直接融入到数值模型中 [@problem_id:3566068]，确保插值结果的物理真实性。", "problem": "在计算核物理的球形平均场计算中，许多径向可观测量（例如，核子密度的$s$波分量或中心平均场势）在原点处是正则的。对于一个径向函数$f(r)$，物理正则性要求$f(r)$在$r=0$处是有限且光滑的，并且在原点附近的领头阶行为是$r$的偶函数。一个被广泛观察和充分检验的事实是，这类正则径向函数在小的$r$值下允许一个泰勒展开，其形式为$f(r)=f_{0}+a_{2}r^{2}+a_{4}r^{4}+\\cdots$，其中$f_{0}$以及系数$a_{2},a_{4},\\dots$是有限的。\n\n假设$f(r)$在一个均匀的径向网格$r_{0}=0$，$r_{1}=h$，$r_{2}=2h$，$\\dots$（其中$h>0$）上被制成表格，并令$f_{i}=f(r_{i})$。你希望在$[0,R]$上构造一个二次连续可微的三次样条插值函数$s(r)$，该函数穿过表格中的值，并在原点处强制满足物理正则性约束。令$M_{i}=s''(r_{i})$表示样条函数在节点处的（未知）二阶导数。\n\n在第一个区间$[r_{0},r_{1}]$上，通过标准的三次样条构造来定义三次多项式段$s_{0}(r)$：\n$$\ns_{0}(r)=\\frac{M_{0}}{6h}(r_{1}-r)^{3}+\\frac{M_{1}}{6h}(r-r_{0})^{3}+\\left(\\frac{f_{0}}{h}-\\frac{M_{0}h}{6}\\right)(r_{1}-r)+\\left(\\frac{f_{1}}{h}-\\frac{M_{1}h}{6}\\right)(r-r_{0}) .\n$$\n\n从物理正则性基础$f(r)=f_{0}+O(r^{2})$和上述三次样条定义出发，推导在$r=0$处的钳位边界条件，该条件强制插值函数满足正则性，并将其简化为$M_{0}$关于$h$、$f_{0}$、$f_{1}$和$M_{1}$的单一解析表达式。\n\n答案规格：\n- 以$M_{0}$关于$h$、$f_{0}$、$f_{1}$和$M_{1}$的单一闭式解析表达式的形式提供你的最终答案。\n- 最终表达式中不要包含单位。\n- 无需进行数值四舍五入。", "solution": "该问题要求推导三次样条插值函数在原点$r=0$处强制满足物理正则性的边界条件。\n\n首先，我将形式化物理正则性条件。问题指出，在原点附近的正则径向函数$f(r)$允许一个泰勒展开，形式为$f(r) = f_0 + a_2 r^2 + a_4 r^4 + \\cdots$。这意味着该函数在原点附近是$r$的偶函数。这种偶性的一个直接推论是，$f(r)$在$r=0$处的所有奇数阶导数必须为零。最低阶条件是关于一阶导数的。对级数逐项求导得到$f'(r) = 2a_2 r + 4a_4 r^3 + \\cdots$。在$r=0$处求值得到$f'(0) = 0$。\n\n任务指定从基础条件$f(r) = f_0 + O(r^2)$开始。这等价于陈述$\\lim_{r\\to 0} \\frac{f(r)-f_0}{r} = 0$，在假设$f(0)=f_0$的情况下，这正是$f'(0)=0$的定义。\n\n三次样条插值函数$s(r)$旨在近似$f(r)$，同时尊重其基本属性。因此，为了强制正则性，样条函数必须在原点处对其一阶导数满足相同的条件。这给出了钳位边界条件：\n$$\ns'(0) = 0\n$$\n由于样条函数至少是$C^1$的，其在节点$r_0=0$处的导数由第一个样条段$s_0(r)$的导数给出。因此，我们必须强制$s_0'(0)=0$。\n\n问题提供了在区间$[r_0, r_1]$（其中$r_0=0$，$r_1=h$）上的样条段$s_0(r)$的公式：\n$$\ns_{0}(r)=\\frac{M_{0}}{6h}(r_{1}-r)^{3}+\\frac{M_{1}}{6h}(r-r_{0})^{3}+\\left(\\frac{f_{0}}{h}-\\frac{M_{0}h}{6}\\right)(r_{1}-r)+\\left(\\frac{f_{1}}{h}-\\frac{M_{1}h}{6}\\right)(r-r_{0})\n$$\n代入$r_0=0$和$r_1=h$：\n$$\ns_{0}(r)=\\frac{M_{0}}{6h}(h-r)^{3}+\\frac{M_{1}}{6h}r^{3}+\\left(\\frac{f_{0}}{h}-\\frac{M_{0}h}{6}\\right)(h-r)+\\left(\\frac{f_{1}}{h}-\\frac{M_{1}h}{6}\\right)r\n$$\n为了应用边界条件，我们首先计算$s_0(r)$关于$r$的导数：\n$$\ns_{0}'(r) = \\frac{d}{dr} \\left[ \\frac{M_{0}}{6h}(h-r)^{3}+\\frac{M_{1}}{6h}r^{3}+\\left(\\frac{f_{0}}{h}-\\frac{M_{0}h}{6}\\right)(h-r)+\\left(\\frac{f_{1}}{h}-\\frac{M_{1}h}{6}\\right)r \\right]\n$$\n使用幂法则和链式法则进行微分：\n$$\ns_{0}'(r) = \\frac{M_{0}}{6h} \\cdot 3(h-r)^{2}(-1) + \\frac{M_{1}}{6h} \\cdot 3r^{2}(1) + \\left(\\frac{f_{0}}{h}-\\frac{M_{0}h}{6}\\right)(-1) + \\left(\\frac{f_{1}}{h}-\\frac{M_{1}h}{6}\\right)(1)\n$$\n简化表达式：\n$$\ns_{0}'(r) = -\\frac{M_{0}}{2h}(h-r)^{2} + \\frac{M_{1}}{2h}r^{2} - \\frac{f_{0}}{h} + \\frac{M_{0}h}{6} + \\frac{f_{1}}{h} - \\frac{M_{1}h}{6}\n$$\n这可以重新排列为：\n$$\ns_{0}'(r) = -\\frac{M_{0}}{2h}(h-r)^{2} + \\frac{M_{1}}{2h}r^{2} + \\frac{f_{1}-f_{0}}{h} + \\frac{h}{6}(M_{0}-M_{1})\n$$\n现在，我们在原点$r=0$处计算这个导数：\n$$\ns_{0}'(0) = -\\frac{M_{0}}{2h}(h-0)^{2} + \\frac{M_{1}}{2h}(0)^{2} + \\frac{f_{1}-f_{0}}{h} + \\frac{h}{6}(M_{0}-M_{1})\n$$\n$$\ns_{0}'(0) = -\\frac{M_{0}h^2}{2h} + 0 + \\frac{f_{1}-f_{0}}{h} + \\frac{M_{0}h}{6} - \\frac{M_{1}h}{6}\n$$\n$$\ns_{0}'(0) = -\\frac{M_{0}h}{2} + \\frac{f_{1}-f_{0}}{h} + \\frac{M_{0}h}{6} - \\frac{M_{1}h}{6}\n$$\n合并含有$M_0$的项：\n$$\ns_{0}'(0) = M_{0}\\left(\\frac{h}{6} - \\frac{h}{2}\\right) + \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\n$$\ns_{0}'(0) = M_{0}\\left(\\frac{h-3h}{6}\\right) + \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\n$$\ns_{0}'(0) = -M_{0}\\frac{2h}{6} + \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\n$$\ns_{0}'(0) = -M_{0}\\frac{h}{3} + \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\n应用正则性条件$s'(0) = s_0'(0) = 0$：\n$$\n0 = -M_{0}\\frac{h}{3} + \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\n最后一步是解这个方程得到$M_0$，以获得所需的解析表达式。\n$$\nM_{0}\\frac{h}{3} = \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\n两边同乘以$\\frac{3}{h}$：\n$$\nM_{0} = \\frac{3}{h}\\left(\\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\\right)\n$$\n$$\nM_{0} = \\frac{3(f_{1}-f_{0})}{h^{2}} - \\frac{3M_{1}h}{6h}\n$$\n$$\nM_{0} = \\frac{3(f_{1}-f_{0})}{h^{2}} - \\frac{M_{1}}{2}\n$$\n这就是样条函数在原点处的二阶导数$M_0$的解析表达式，用网格间距$h$、函数值$f_0$和$f_1$以及下一个网格点处的二阶导数$M_1$来表示。这个关系式作为在$r=0$处强制物理正则性的钳位边界条件。", "answer": "$$\\boxed{\\frac{3(f_{1}-f_{0})}{h^{2}} - \\frac{M_{1}}{2}}$$", "id": "3566068"}, {"introduction": "核反应数据，如分波宽度 $\\Gamma_c(E)$，在反应阈值能量 $E_{\\mathrm{th},c}$ 附近表现出由Wigner阈值定律决定的非解析行为。直接对这类函数使用多项式样条插值会引入巨大误差。本实践将指导你实现一种更为精妙的方案：首先分离出已知的非解析因子（穿透几率），然后对剩余的光滑“折合宽度”函数进行插值 [@problem_id:3566057]。这种方法是处理具有已知奇异性函数的标准技巧，能显著提升插值精度。", "problem": "你的任务是为一个核反应模型设计并实现一个基于三次样条的插值函数，用于能量相关的部分衰变宽度，该插值函数需遵循维格纳 (Wigner) 阈值定律所要求的阈值行为。考虑一组由 $c$ 索引的衰变道，每个衰变道都由一个轨道角动量量子数 $\\ell_c$ 和一个道阈值能量 $E_{\\mathrm{th},c}$ 来表征。对于中性出射粒子和短程相互作用，维格纳 (Wigner) 阈值定律断言，在阈值附近，衰变宽度与穿透率成比例，即 $\\Gamma_c(E) \\propto P_{\\ell_c}(E)$，其中 $P_{\\ell}(E) \\propto k^{2\\ell+1}$，$k$ 是波数。在 $2\\mu/\\hbar^2 = 1$ 的单位制下，对于 $E \\ge E_{\\mathrm{th},c}$，有 $k = \\sqrt{E - E_{\\mathrm{th},c}}$，因此 $P_{\\ell}(E) \\propto (E - E_{\\mathrm{th},c})^{\\ell + 1/2}$。在本问题中，采用以下具体的中性粒子穿透率模型\n$$\nP_{\\ell}(E;E_{\\mathrm{th}}) = \\left[\\max\\left(E - E_{\\mathrm{th}},\\,0\\right)\\right]^{\\ell + \\tfrac{1}{2}},\n$$\n其中所有能量以 $\\mathrm{MeV}$ 为单位，且比例常数设为 $1$。\n\n你的目标是为每个道 $c$ 构建一个用于 $\\Gamma_c(E)$ 的三次样条插值函数 $S_c(E)$，该函数能强制执行正确的低能标度行为，具体如下：\n- 对于 $E \\le E_{\\mathrm{th},c}$，设置 $S_c(E) = 0$ (闭合道)。\n- 对于 $E > E_{\\mathrm{th},c}$，要求比率 $W_c(E) \\equiv S_c(E)/P_{\\ell_c}(E;E_{\\mathrm{th},c})$ 是一个在区间 $[E_{\\mathrm{th},c}+\\Delta,\\,E_{\\max,c}]$ 上关于 $E$ 的自然三次样条，其中 $\\Delta = 10^{-4}\\,\\mathrm{MeV}$，并拟合训练数据。等价地，通过给定的节点 $\\{E_i\\}$ 上的训练数据纵坐标 $W_c(E_i) = \\Gamma_c(E_i)/P_{\\ell_c}(E_i;E_{\\mathrm{th},c})$ 为约化宽度函数 $W_c(E)$ 构建一个自然三次样条，然后对于 $E > E_{\\mathrm{th},c}$ 定义 $S_c(E) = P_{\\ell_c}(E;E_{\\mathrm{th},c})\\,W_c(E)$。\n\n为使任务完全指定且可测试，请对每个道 $c$ 使用以下人工合成但物理上合理的基准真相模型：\n- 令真实的约化宽度函数为\n$$\nH_c(E) = a_c + b_c\\,(E - E_{\\mathrm{th},c}) + c_c \\cos\\!\\big(d_c\\,(E - E_{\\mathrm{th},c})\\big),\n$$\n并将真实的部分宽度定义为\n$$\n\\Gamma_c^{\\mathrm{true}}(E) = \n\\begin{cases}\n0,  E \\le E_{\\mathrm{th},c},\\\\\nP_{\\ell_c}(E;E_{\\mathrm{th},c})\\,H_c(E),  E > E_{\\mathrm{th},c}.\n\\end{cases}\n$$\n\n使用以下道定义和参数（所有能量单位为 $\\mathrm{MeV}$，角度无量纲，且 $E_{\\max,c}$ 指定训练和评估区间的上界）：\n- 道 $c=1$：$\\ell_1 = 0$, $E_{\\mathrm{th},1} = 0.1\\,\\mathrm{MeV}$, $E_{\\max,1} = 3.0\\,\\mathrm{MeV}$, $a_1 = 0.3$, $b_1 = 0.2$, $c_1 = 0.05$, $d_1 = 3.0$。\n- 道 $c=2$：$\\ell_2 = 1$, $E_{\\mathrm{th},2} = 1.0\\,\\mathrm{MeV}$, $E_{\\max,2} = 5.0\\,\\mathrm{MeV}$, $a_2 = 0.1$, $b_2 = 0.05$, $c_2 = 0.02$, $d_2 = 5.0$。\n- 道 $c=3$：$\\ell_3 = 2$, $E_{\\mathrm{th},3} = 0.0\\,\\mathrm{MeV}$, $E_{\\max,3} = 4.0\\,\\mathrm{MeV}$, $a_3 = 0.5$, $b_3 = 0.0$, $c_3 = 0.1$, $d_3 = 2.0$。\n\n所有道的训练数据规范：\n- 使用 $N_c = 8$ 个在能量区间 $[E_{\\mathrm{th},c} + \\Delta,\\,E_{\\max,c}]$ 上均匀分布的训练节点，其中 $\\Delta = 10^{-4}\\,\\mathrm{MeV}$。将这些节点表示为 $\\{E_{i,c}\\}_{i=1}^{N_c}$。\n- 训练数据的纵坐标是这些节点上的 $\\Gamma_c^{\\mathrm{true}}(E_{i,c})$。\n\n程序要求：\n1. 对每个道 $c$，通过将自然三次样条拟合到训练数据点 $\\{(E_{i,c},\\,\\Gamma_c^{\\mathrm{true}}(E_{i,c})/P_{\\ell_c}(E_{i,c};E_{\\mathrm{th},c}))\\}$，来构建如上所述的样条约束插值函数 $S_c(E)$。\n2. 对每个道 $c$，在一个在 $[E_{\\mathrm{th},c} + \\Delta,\\,E_{\\max,c}]$ 上均匀分布的 $N_{\\mathrm{test}} = 200$ 个点的密集测试网格上，评估插值函数和基准真相。定义最大相对误差\n$$\n\\varepsilon_c = \\max_{E \\in \\mathrm{grid}} \\frac{\\left|S_c(E) - \\Gamma_c^{\\mathrm{true}}(E)\\right|}{\\max\\!\\left(\\Gamma_c^{\\mathrm{true}}(E),\\,\\epsilon\\right)},\n$$\n其中 $\\epsilon = 10^{-14}$ 用于在 $E \\downarrow E_{\\mathrm{th},c}$ 附近进行正则化。\n3. 对每个道 $c$，还需评估阈下值 $B_c = S_c(E_{\\mathrm{th},c} - \\delta)$，其中 $\\delta = 10^{-6}\\,\\mathrm{MeV}$，根据构造，该值应精确为 $0$。\n4. 你的程序必须按照下述确切格式，将六个数字 $[\\varepsilon_1,\\,\\varepsilon_2,\\,\\varepsilon_3,\\,B_1,\\,B_2,\\,B_3]$ 作为单行输出。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含用逗号分隔并用方括号括起来的结果，例如 $[x_1,x_2,x_3,x_4,x_5,x_6]$。\n- 每个数值条目必须打印为四舍五入到8位小数的浮点值。\n- 在适用的情况下，能量单位必须是 $\\mathrm{MeV}$，但打印的输出中 $\\varepsilon_c$ 是无量纲的，而 $B_c$ 的单位是 $\\mathrm{MeV}$（由于构造方式，后者应为 $0.00000000$）。\n\n解决方案必须是一个无需读取任何输入的、完整的、可运行的程序，并且必须精确地实现上述构造。基准真相函数 $H_c(E)$ 和 $\\Gamma_c^{\\mathrm{true}}(E)$ 的内部定义必须与此处给出的规范相匹配。最终输出必须严格遵循所要求的单行格式。", "solution": "本问题要求构建并验证一个用于核部分衰变宽度 $\\Gamma_c(E)$ 的三次样条插值函数，该函数能正确地包含由维格纳 (Wigner) 阈值定律决定的道能量阈值 $E_{\\mathrm{th},c}$ 附近的物理行为。\n\n该指定方法的核心原理是将待插值的函数 $\\Gamma_c(E)$ 分解为两个因子：一个是在阈值附近具有已知的非解析行为的部分，另一个是预计光滑且表现良好的剩余部分。对于具有轨道角动量 $\\ell_c$ 的中性出射粒子，维格纳 (Wigner) 阈值定律指出，衰变宽度与穿透率因子成正比，即 $\\Gamma_c(E) \\propto P_{\\ell_c}(E)$。对于给定的 $2\\mu/\\hbar^2=1$ 的模型，当 $E > E_{\\mathrm{th},c}$ 时，该穿透率为 $P_{\\ell_c}(E;E_{\\mathrm{th},c}) = (E - E_{\\mathrm{th},c})^{\\ell_c + 1/2}$。问题为该因子定义了一个完整的模型：\n$$\nP_{\\ell}(E;E_{\\mathrm{th}}) = \\left[\\max\\left(E - E_{\\mathrm{th}},\\,0\\right)\\right]^{\\ell + \\tfrac{1}{2}}\n$$\n该函数捕捉了在 $E=E_{\\mathrm{th},c}$ 处的急剧开启行为，并且对于 $\\ell=0$，其导数在阈值处是奇异的。由于这种非解析行为，直接对 $\\Gamma_c(E)$ 进行样条插值会不准确。\n\n策略是转而对由以下比率定义的“约化宽度”函数 $W_c(E)$ 进行插值：\n$$\nW_c(E) \\equiv \\frac{\\Gamma_c(E)}{P_{\\ell_c}(E;E_{\\mathrm{th},c})}\n$$\n预计该函数 $W_c(E)$ 会比 $\\Gamma_c(E)$ 光滑得多，因此更适合像三次样条这样基于多项式的插值方法。我们通过一组训练点为 $W_c(E)$ 构建一个自然三次样条，并将其表示为 $W_c(E)$ 的插值函数。然后，通过将约化宽度的样条插值乘以已知的穿透率因子，来重构完整衰变宽度的最终插值函数 $S_c(E)$：\n$$\nS_c(E) = P_{\\ell_c}(E;E_{\\mathrm{th},c}) W_c(E) \\quad \\text{for } E > E_{\\mathrm{th},c}\n$$\n根据构造，对于 $E \\le E_{\\mathrm{th},c}$，我们有 $P_{\\ell_c}(E;E_{\\mathrm{th},c}) = 0$，因此我们定义 $S_c(E) = 0$，这正确地强制了阈值以下的道关闭。\n\n每个道 $c$ 的完整步骤如下：\n\n1.  **定义基准真相函数**：问题提供了一个人工合成的“真实”衰变宽度模型，用于生成训练数据和评估我们的插值函数的准确性。真实的约化宽度函数给出如下：\n    $$\n    H_c(E) = a_c + b_c\\,(E - E_{\\mathrm{th},c}) + c_c \\cos\\!\\big(d_c\\,(E - E_{\\mathrm{th},c})\\big)\n    $$\n    则真实的部分宽度为：\n    $$\n    \\Gamma_c^{\\mathrm{true}}(E) = \n    \\begin{cases}\n    0,  E \\le E_{\\mathrm{th},c}\\\\\n    P_{\\ell_c}(E;E_{\\mathrm{th},c})\\,H_c(E),  E > E_{\\mathrm{th},c}\n    \\end{cases}\n    $$\n    为三个不同的道提供了参数 $\\{a_c, b_c, c_c, d_c, \\ell_c, E_{\\mathrm{th},c}, E_{\\max,c}\\}$。\n\n2.  **生成训练数据**：对每个道 $c$，我们在能量区间 $[E_{\\mathrm{th},c} + \\Delta, E_{\\max,c}]$（其中 $\\Delta = 10^{-4}\\,\\mathrm{MeV}$）内生成 $N_c = 8$ 个均匀分布的训练节点 $\\{E_{i,c}\\}_{i=1}^{N_c}$。小偏移量 $\\Delta$ 对于避免 $P_{\\ell=0}(E)$ 导数无穷大的点 $E=E_{\\mathrm{th},c}$至关重要。约化宽度样条对应的纵坐标是：\n    $$\n    y_{i,c} = \\frac{\\Gamma_c^{\\mathrm{true}}(E_{i,c})}{P_{\\ell_c}(E_{i,c};E_{\\mathrm{th},c})} = \\frac{P_{\\ell_c}(E_{i,c};E_{\\mathrm{th},c}) H_c(E_{i,c})}{P_{\\ell_c}(E_{i,c};E_{\\mathrm{th},c})} = H_c(E_{i,c})\n    $$\n    因此，我们将样条拟合到点集 $\\{(E_{i,c}, H_c(E_{i,c}))\\}$。\n\n3.  **构建自然三次样条**：使用上一步的训练点，我们为 $W_c(E)$ 构建一个自然三次样条插值函数。自然样条有一个额外的约束，即其二阶导数在区间端点为零，当没有关于函数在边界处行为的其他信息时，这是一个常见的选择。\n\n4.  **定义完整插值函数 $S_c(E)$**：衰变宽度的最终插值函数由下式给出：\n    $$\n    S_c(E) = \n    \\begin{cases}\n    0,  E \\le E_{\\mathrm{th},c}\\\\\n    P_{\\ell_c}(E;E_{\\mathrm{th},c})\\,W_c(E),  E > E_{\\mathrm{th},c}\n    \\end{cases}\n    $$\n    其中 $W_c(E)$ 是在能量 $E$ 处求值的自然三次样条的值。\n\n5.  **评估性能**：\n    - 最大相对误差 $\\varepsilon_c$ 是在 $[E_{\\mathrm{th},c} + \\Delta, E_{\\max,c}]$ 上的一个包含 $N_{\\mathrm{test}}=200$ 个点的密集网格上计算的。误差定义为：\n      $$\n      \\varepsilon_c = \\max_{E \\in \\mathrm{grid}} \\frac{\\left|S_c(E) - \\Gamma_c^{\\mathrm{true}}(E)\\right|}{\\max\\!\\left(\\Gamma_c^{\\mathrm{true}}(E),\\,\\epsilon\\right)}\n      $$\n      其中 $\\epsilon = 10^{-14}$ 是一个正则化常数，用于防止在 $\\Gamma_c^{\\mathrm{true}}(E)$ 非常小的区域出现除以零的情况。\n    - 评估阈下值 $B_c = S_c(E_{\\mathrm{th},c} - \\delta)$（其中 $\\delta = 10^{-6}\\,\\mathrm{MeV}$），以确认插值方案正确地将闭合道的宽度设置为零。根据我们对 $S_c(E)$ 的构造，该值必须精确为 $0$。\n\n实现将对三个指定的道中的每一个执行这些步骤，并报告得到的六个值 $[\\varepsilon_1, \\varepsilon_2, \\varepsilon_3, B_1, B_2, B_3]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Solves the problem of constructing and evaluating a cubic-spline-based\n    interpolant for nuclear decay widths that respects Wigner threshold laws.\n    \"\"\"\n    \n    # Define the problem parameters for each channel\n    channels = {\n        1: {'ell': 0, 'E_th': 0.1, 'E_max': 3.0, 'a': 0.3, 'b': 0.2, 'c': 0.05, 'd': 3.0},\n        2: {'ell': 1, 'E_th': 1.0, 'E_max': 5.0, 'a': 0.1, 'b': 0.05, 'c': 0.02, 'd': 5.0},\n        3: {'ell': 2, 'E_th': 0.0, 'E_max': 4.0, 'a': 0.5, 'b': 0.0, 'c': 0.1, 'd': 2.0}\n    }\n    \n    # Global constants from the problem statement\n    DELTA = 1e-4      # MeV, offset for training and evaluation domain\n    EPSILON = 1e-14   # Regularization for relative error\n    DELTA_B = 1e-6    # MeV, offset for below-threshold evaluation\n    N_TRAIN = 8       # Number of training knots\n    N_TEST = 200      # Number of test grid points\n\n    results = []\n\n    for c in sorted(channels.keys()):\n        p = channels[c]\n        ell, E_th, E_max = p['ell'], p['E_th'], p['E_max']\n        a, b, c_param, d = p['a'], p['b'], p['c'], p['d']\n\n        # 1. Define the model functions\n        \n        # Penetrability function P_l(E)\n        def P_ell(E, ell_val, E_th_val):\n            # Use np.maximum for element-wise operation\n            E_diff = np.maximum(E - E_th_val, 0)\n            return E_diff**(ell_val + 0.5)\n\n        # True reduced-width function H_c(E)\n        def H_c(E, E_th_val, a_val, b_val, c_val, d_val):\n            return a_val + b_val * (E - E_th_val) + c_val * np.cos(d_val * (E - E_th_val))\n\n        # True partial width function Gamma_true(E)\n        def Gamma_true(E, ell_val, E_th_val, a_val, b_val, c_val, d_val):\n            E_above_thresh = E > E_th_val\n            width = np.zeros_like(E, dtype=float)\n            if np.any(E_above_thresh):\n                P_vals = P_ell(E[E_above_thresh], ell_val, E_th_val)\n                H_vals = H_c(E[E_above_thresh], E_th_val, a_val, b_val, c_val, d_val)\n                width[E_above_thresh] = P_vals * H_vals\n            return width\n\n        # 2. Generate Training Data\n        train_knots = np.linspace(E_th + DELTA, E_max, N_TRAIN)\n        \n        # The ordinates for the spline are the values of the reduced-width function H_c\n        train_ordinates_W = H_c(train_knots, E_th, a, b, c_param, d)\n\n        # 3. Construct Natural Cubic Spline for W_c(E)\n        W_c_spline = CubicSpline(train_knots, train_ordinates_W, bc_type='natural')\n        \n        # 4. Define the Full Interpolant S_c(E)\n        def S_c(E):\n            y = np.zeros_like(E, dtype=float)\n            # Find energies above threshold\n            mask_above = E > E_th\n            \n            if np.any(mask_above):\n                E_above = E[mask_above]\n                # Evaluate spline and penetrability for E > E_th\n                W_vals = W_c_spline(E_above)\n                P_vals = P_ell(E_above, ell, E_th)\n                y[mask_above] = P_vals * W_vals\n\n            return y\n\n        # 5. Evaluate Performance\n        \n        # a. Calculate maximum relative error epsilon_c\n        test_grid = np.linspace(E_th + DELTA, E_max, N_TEST)\n        \n        S_c_on_grid = S_c(test_grid)\n        Gamma_true_on_grid = Gamma_true(test_grid, ell, E_th, a, b, c_param, d)\n        \n        # To avoid division by zero or near-zero\n        denominator = np.maximum(Gamma_true_on_grid, EPSILON)\n        \n        relative_errors = np.abs(S_c_on_grid - Gamma_true_on_grid) / denominator\n        epsilon_c = np.max(relative_errors)\n        results.append(epsilon_c)\n        \n        # b. Calculate below-threshold value B_c\n        B_c = S_c(np.array([E_th - DELTA_B]))[0]\n        # This is handled as an append for the final list, but is a separate calculation conceptually.\n\n    # Calculate B values for all channels\n    B_values = []\n    for c in sorted(channels.keys()):\n        p = channels[c]\n        E_th = p['E_th']\n        # The function S_c as defined will return 0 for any E = E_th.\n        # We can directly assign 0.0, as per the construction.\n        B_c = 0.0\n        B_values.append(B_c)\n        \n    final_results = results + B_values\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{x:.8f}' for x in final_results])}]\")\n\nsolve()\n```", "id": "3566057"}, {"introduction": "在多体物理中，基本相互作用通过线性组合和对称性（如泡利不相容原理）约束了不同观测通道中的有效相互作用。然而，插值这一数值操作与这些线性变换通常是不可交换的，直接对末端物理量进行插值可能会破坏底层的物理规律。本练习通过一个简化的核力模型，让你对比两种插值方案，并量化“天真”方案对角动量耦合关系和反对称选择定则的破坏程度 [@problem_id:3566060]，从而深刻理解在构建数值模型时保持物理一致性的重要性。", "problem": "考虑一个简化的、物理上自洽的相对坐标下的核子-核子相互作用模型，该模型仅限于中心分量和自旋交换分量。设两体势写为 $V(r) = V_{\\mathrm{c}}(r) + V_{\\sigma}(r)\\,\\boldsymbol{\\sigma}_1 \\cdot \\boldsymbol{\\sigma}_2$，其中 $V_{\\mathrm{c}}(r)$ 是中心部分，$V_{\\sigma}(r)$ 乘以自旋标量积算符 $\\boldsymbol{\\sigma}_1 \\cdot \\boldsymbol{\\sigma}_2$。对于两个自旋为 $\\tfrac{1}{2}$ 的粒子，算符 $\\boldsymbol{\\sigma}_1 \\cdot \\boldsymbol{\\sigma}_2$ 在自旋单态 $S=0$ 中的本征值为 $-3$，在自旋三重态 $S=1$ 中的本征值为 $+1$。对于全同核子，泡利不相容原理施加了反对称性选择定则，即对于轨道角动量 $L=0$，必须有 $S+T$ 为奇数，其中 $T$ 是总同位旋。由于当 $L=0$ 时 $J=L+S$，因此物理上允许的道只有 $(J=0,T=1)$（自旋单态）和 $(J=1,T=0)$（自旋三重态）。在这些条件下，耦合道有效径向相互作用为 $V_{J=0,T=1}(r) = V_{\\mathrm{c}}(r) - 3\\,V_{\\sigma}(r)$ 和 $V_{J=1,T=0}(r) = V_{\\mathrm{c}}(r) + V_{\\sigma}(r)$，而所有其他 $(J,T)$ 道由于反对称性而恒等于零。\n\n给定 $V_{\\mathrm{c}}(r)$ 和 $V_{\\sigma}(r)$ 在有限径向网格上的离散采样点，你必须构建三次B样条（B-spline）插值。总体的数值要求是，插值必须保持 $V_{\\mathrm{c}}(r)$、$V_{\\sigma}(r)$ 和 $V_{JT}(r)$ 之间的线性角动量耦合恒等式，并在 $L=0$ 扇区强制执行反对称性选择定则。应比较两种插值方案：\n1. 一种“守恒”方案，该方案从 $V_{\\mathrm{c}}(r)$ 和 $V_{\\sigma}(r)$ 的采样点构建三次B样条插值 $\\mathcal{S}[V_{\\mathrm{c}}](r)$ 和 $\\mathcal{S}[V_{\\sigma}](r)$，然后定义 $V_{J=0,T=1}^{\\mathrm{pres}}(r) = \\mathcal{S}[V_{\\mathrm{c}}](r) - 3\\,\\mathcal{S}[V_{\\sigma}](r)$ 和 $V_{J=1,T=0}^{\\mathrm{pres}}(r) = \\mathcal{S}[V_{\\mathrm{c}}](r) + \\mathcal{S}[V_{\\sigma}](r)$，对于禁戒道 $(J,T)\\in\\{(0,0),(1,1)\\}$ 则有 $V_{JT}^{\\mathrm{pres}}(r) = 0$。\n2. 一种“朴素”方案，该方案直接为耦合道采样点 $V_{J=0,T=1}(r)$ 和 $V_{J=1,T=0}(r)$ 构建三次B样条插值，即 $\\mathcal{S}[V_{J=0,T=1}](r)$ 和 $\\mathcal{S}[V_{J=1,T=0}](r)$，并将这些用于允许道，同时由于将相同的函数形式赋给了禁戒道而未能强制执行反对称性选择定则，即 $V_{J=0,T=0}^{\\mathrm{naive}}(r)=\\mathcal{S}[V_{J=0,T=1}](r)$ 和 $V_{J=1,T=1}^{\\mathrm{naive}}(r)=\\mathcal{S}[V_{J=1,T=0}](r)$。\n\n为测试其对一个简单壳模型能谱的影响，使用归一化的谐振子 (HO) 基态相对波函数来近似相对 $S$ 波中的两体相互作用能。设谐振子长度为 $b$，归一化的三维基态波函数为 $\\psi_{0}(r) = \\left(\\pi^{-\\tfrac{3}{4}} b^{-\\tfrac{3}{2}}\\right)\\exp\\!\\left(-\\tfrac{r^{2}}{2 b^{2}}\\right)$，因此 $|\\psi_{0}(r)|^{2} = \\left(\\pi^{-\\tfrac{3}{2}} b^{-3}\\right)\\exp\\!\\left(-\\tfrac{r^{2}}{b^{2}}\\right)$。给定道 $(J,T)$ 中的相互作用期望值为\n$$\nE_{JT} = \\int_{0}^{R_{\\max}} 4\\pi\\,r^{2}\\,|\\psi_{0}(r)|^{2}\\,V_{JT}(r)\\,\\mathrm{d}r,\n$$\n该值应以兆电子伏特 (MeV) 为单位表示。当插值未能保持角动量耦合恒等式时，“朴素”方案和“守恒”方案将产生两组不同的能量值。\n\n为保证真实性和数值稳定性，采用平滑且短程的采样势函数：\n$V_{\\mathrm{c}}(r) = V_{0}\\,\\frac{e^{-\\mu r}}{r + a},\\quad V_{\\sigma}(r) = V_{s}\\,r\\,e^{-\\mu_{s} r},$\n其中 $r$ 的单位是飞米 (fm)，$V_{0}$ 和 $V_{s}$ 的单位是兆电子伏特 (MeV)，$\\mu$ 和 $\\mu_{s}$ 的单位是反飞米 ($\\mathrm{fm}^{-1}$)。使用三次B样条进行插值。\n\n你的程序必须实现这两种插值方案，通过在精细径向网格上进行稳定的数值求积来计算谐振子期望值积分，并针对每个测试案例产生以下输出：\n- “守恒”方案与“朴素”方案在允许道中的壳模型相互作用能之差，即 $\\Delta E_{J=0,T=1} = E_{J=0,T=1}^{\\mathrm{pres}} - E_{J=0,T=1}^{\\mathrm{naive}}$ 和 $\\Delta E_{J=1,T=0} = E_{J=1,T=0}^{\\mathrm{pres}} - E_{J=1,T=0}^{\\mathrm{naive}}$，每个均为浮点数，单位为 MeV。\n- 将朴素 $V_{JT}$ 样条与分量样条的线性组合进行比较时，角动量耦合恒等式的均方根偏差，该偏差在一组横跨采样域的 $200$ 个评估点上计算，即\n$$\n\\mathrm{RMS}_{J=0,T=1} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\left[\\mathcal{S}\\!\\left(V_{J=0,T=1}\\right)(r_{i}) - \\left(\\mathcal{S}\\!\\left(V_{\\mathrm{c}}\\right)(r_{i}) - 3\\,\\mathcal{S}\\!\\left(V_{\\sigma}\\right)(r_{i})\\right)\\right]^{2}},\n$$\n和\n$$\n\\mathrm{RMS}_{J=1,T=0} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\left[\\mathcal{S}\\!\\left(V_{J=1,T=0}\\right)(r_{i}) - \\left(\\mathcal{S}\\!\\left(V_{\\mathrm{c}}\\right)(r_{i}) + \\mathcal{S}\\!\\left(V_{\\sigma}\\right)(r_{i})\\right)\\right]^{2}},\n$$\n为浮点数，单位为 MeV。\n- 两个布尔标志，分别指示反对称性定则在 $L=0$ 扇区是否被强制执行，具体地，$E_{J=0,T=0}^{\\mathrm{pres}}$ 和 $E_{J=1,T=1}^{\\mathrm{pres}}$ 是否在 $10^{-10}$ MeV 的容差范围内为数值零，以及 $E_{J=0,T=0}^{\\mathrm{naive}}$ 和 $E_{J=1,T=1}^{\\mathrm{naive}}$ 是否在相同容差范围内为数值零。\n\n设计并评估以下三个测试案例，它们共同测试了一般情况、粗糙采样和近原点行为：\n- 测试案例 1：$V_{0}=-60.0$ MeV, $V_{s}=15.0$ MeV, $\\mu=1.5\\,\\mathrm{fm}^{-1}$, $\\mu_{s}=1.0\\,\\mathrm{fm}^{-1}$, $a=0.2$ fm, $r_{\\min}=10^{-3}$ fm, $r_{\\max}=8.0$ fm, $N_{\\mathrm{data}}=25$, $b=1.8$ fm, $R_{\\max}=8.0$ fm, 以及 $N_{\\mathrm{int}}=4000$ 个积分点。\n- 测试案例 2：$V_{0}=-45.0$ MeV, $V_{s}=18.0$ MeV, $\\mu=1.3\\,\\mathrm{fm}^{-1}$, $\\mu_{s}=0.8\\,\\mathrm{fm}^{-1}$, $a=0.3$ fm, $r_{\\min}=10^{-3}$ fm, $r_{\\max}=8.0$ fm, $N_{\\mathrm{data}}=8$ (粗糙网格), $b=2.2$ fm, $R_{\\max}=8.0$ fm, 以及 $N_{\\mathrm{int}}=4000$ 个积分点。\n- 测试案例 3：$V_{0}=-75.0$ MeV, $V_{s}=10.0$ MeV, $\\mu=1.7\\,\\mathrm{fm}^{-1}$, $\\mu_{s}=1.2\\,\\mathrm{fm}^{-1}$, $a=0.05$ fm, $r_{\\min}=10^{-3}$ fm, $r_{\\max}=6.0$ fm, $N_{\\mathrm{data}}=30$ (近原点精细网格), $b=1.4$ fm, $R_{\\max}=6.0$ fm, 以及 $N_{\\mathrm{int}}=3000$ 个积分点。\n\n你的程序应生成单行输出，其中包含三个测试案例的结果，结果为逗号分隔的列表，并用方括号括起来，顺序如下：$[\\Delta E_{J=0,T=1}^{(1)},\\Delta E_{J=1,T=0}^{(1)},\\mathrm{RMS}_{J=0,T=1}^{(1)},\\mathrm{RMS}_{J=1,T=0}^{(1)},\\mathrm{AntiPres}^{(1)},\\mathrm{AntiNaive}^{(1)},\\Delta E_{J=0,T=1}^{(2)},\\Delta E_{J=1,T=0}^{(2)},\\mathrm{RMS}_{J=0,T=1}^{(2)},\\mathrm{RMS}_{J=1,T=0}^{(2)},\\mathrm{AntiPres}^{(2)},\\mathrm{AntiNaive}^{(2)},\\Delta E_{J=0,T=1}^{(3)},\\Delta E_{J=1,T=0}^{(3)},\\mathrm{RMS}_{J=0,T=1}^{(3)},\\mathrm{RMS}_{J=1,T=0}^{(3)},\\mathrm{AntiPres}^{(3)},\\mathrm{AntiNaive}^{(3)}]$，其中每个能量值单位为 MeV (浮点数)，每个均方根偏差单位为 MeV (浮点数)，反对称性标志为布尔值。", "solution": "用户要求在简化的核子-核子相互作用模型的背景下，比较两种三次B样条插值方案。核心任务是评估“朴素”插值方案在多大程度上违反了“守恒”方案通过构造所保持的线性关系和物理对称性。这种比较通过计算物理可观测量（相互作用能）的差异以及势模型之间的均方根偏差来量化。\n\n### 问题阐述与物理原理\n\n核子-核子相互作用势以相对坐标 $r$ 的简化算符形式给出：\n$$V(r) = V_{\\mathrm{c}}(r) + V_{\\sigma}(r)\\,\\boldsymbol{\\sigma}_1 \\cdot \\boldsymbol{\\sigma}_2$$\n这里，$V_{\\mathrm{c}}(r)$ 是中心势，$V_{\\sigma}(r)$ 是自旋相关部分。算符 $\\boldsymbol{\\sigma}_1 \\cdot \\boldsymbol{\\sigma}_2$ 作用于双核子系统的自旋态。对于两个自旋为 $\\frac{1}{2}$ 的粒子，它具有取决于总自旋 $S$ 的不同本征值：对于自旋单态（$S=0$）为 $-3$，对于自旋三重态（$S=1$）为 $+1$。\n\n泡利不相容原理对全同核子的允许量子态施加了严格约束。对于相对S波态（轨道角动量 $L=0$），总自旋 $S$ 和总同位旋 $T$ 之和必须为奇数（$S+T$ 为奇数）。该选择定则仅允许 $L=0$ 的两个道：\n1.  自旋单态（$S=0$，总角动量 $J=L+S=0$）：要求 $T=1$。有效势为 $V_{J=0,T=1}(r) = V_{\\mathrm{c}}(r) - 3V_{\\sigma}(r)$。\n2.  自旋三重态（$S=1$，总角动量 $J=L+S=1$）：要求 $T=0$。有效势为 $V_{J=1,T=0}(r) = V_{\\mathrm{c}}(r) + V_{\\sigma}(r)$。\n\n$(J=0, T=0)$ 和 $(J=1, T=1)$ 道被泡利原理禁止（对于 $L=0$），意味着它们的相互作用势恒等于零：$V_{J=0,T=0}(r)=0$ 和 $V_{J=1,T=1}(r)=0$。\n\n### 插值方案与线性保持\n\n该问题研究了对离散势数据进行插值的数值后果。\n势的解析形式为：\n$$\nV_{\\mathrm{c}}(r) = V_{0}\\,\\frac{e^{-\\mu r}}{r + a},\\quad V_{\\sigma}(r) = V_{s}\\,r\\,e^{-\\mu_{s} r}\n$$\n这些势在离散的径向网格 $\\{r_i\\}$ 上进行采样。\n\n1.  **“守恒”方案：** 此方法尊重模型的底层线性结构。首先，根据分量势各自的样本构建它们的三次B样条插值 $\\mathcal{S}[V_{\\mathrm{c}}](r)$ 和 $\\mathcal{S}[V_{\\sigma}](r)$。然后，将道势定义为这些样条的线性组合：\n    $$V_{J=0,T=1}^{\\mathrm{pres}}(r) = \\mathcal{S}[V_{\\mathrm{c}}](r) - 3\\,\\mathcal{S}[V_{\\sigma}](r)$$\n    $$V_{J=1,T=0}^{\\mathrm{pres}}(r) = \\mathcal{S}[V_{\\mathrm{c}}](r) + \\mathcal{S}[V_{\\sigma}](r)$$\n    该方案通过将禁戒道的势设置为零来明确执行泡利原理：$V_{J=0,T=0}^{\\mathrm{pres}}(r)=0$ 和 $V_{J=1,T=1}^{\\mathrm{pres}}(r)=0$。\n\n2.  **“朴素”方案：** 此方法直接对最终的道势进行插值。首先，计算允许道势的样本 $V_{J=0,T=1}(r_i)$ 和 $V_{J=1,T=0}(r_i)$。然后，为每个道构建独立的三次B样条插值：$\\mathcal{S}[V_{J=0,T=1}](r)$ 和 $\\mathcal{S}[V_{J=1,T=0}](r)$。\n    这种方法未能保持线性关系，因为通常情况下，当从离散数据构建时，样条算符 $\\mathcal{S}$ 与线性组合不可交换：\n    $$\\mathcal{S}[V_{\\mathrm{c}} - 3V_{\\sigma}] \\neq \\mathcal{S}[V_{\\mathrm{c}}] - 3\\mathcal{S}[V_{\\sigma}]$$\n    此外，该方案通过将允许道的功能形式赋给禁戒道而违反了反对称性规则：$V_{J=0,T=0}^{\\mathrm{naive}}(r)=\\mathcal{S}[V_{J=0,T=1}](r)$ 和 $V_{J=1,T=1}^{\\mathrm{naive}}(r)=\\mathcal{S}[V_{J=1,T=0}](r)$。\n\n### 可观测量与差异度量的计算\n\n为了评估插值方案的影响，我们计算了由归一化谐振子基态波函数 $\\psi_0(r)$ 描述的相对S波态的相互作用能期望值 $E_{JT}$：\n$$E_{JT} = \\int_{0}^{R_{\\max}} 4\\pi\\,r^{2}\\,|\\psi_{0}(r)|^{2}\\,V_{JT}(r)\\,\\mathrm{d}r$$\n其中 $|\\psi_{0}(r)|^{2} = (\\pi^{-\\frac{3}{2}} b^{-3})\\exp(-\\frac{r^{2}}{b^{2}})$。该积分使用辛普森法则在精细网格上进行数值计算。\n\n为每个测试案例计算以下量：\n-   **能量差 ($\\Delta E_{JT}$):** 对两个允许道计算的差值 $E_{JT}^{\\mathrm{pres}} - E_{JT}^{\\mathrm{naive}}$。这衡量了数值不一致性对计算出的物理可观测量的影响。\n-   **均方根偏差 ($\\mathrm{RMS}_{JT}$):** 两种方案在采样域上生成的势函数之间的均方根差。这直接量化了朴素方案未能保持线性耦合恒等式的程度。例如，对于 $(J=0,T=1)$ 道：\n    $$\\mathrm{RMS}_{J=0,T=1} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\left[\\mathcal{S}[V_{J=0,T=1}](r_{i}) - \\left(\\mathcal{S}[V_{\\mathrm{c}}](r_{i}) - 3\\,\\mathcal{S}[V_{\\sigma}](r_{i})\\right)\\right]^{2}}$$\n    这在 $N=200$ 个点的网格上进行评估。\n-   **反对称性标志：** 两个布尔标志，检查禁戒道的能量是否在数值上为零（在 $10^{-10}\\,\\mathrm{MeV}$ 的容差范围内）。根据定义，禁戒道的 $E_{JT}^{\\mathrm{pres}}$ 将为零。$E_{JT}^{\\mathrm{naive}}$ 将不为零，表明对泡利原理的违反。\n\n### 算法实现\n\n该解决方案实现为一个利用 `numpy` 和 `scipy` 库的 Python 程序。对于每个测试案例：\n1.  定义解析势 $V_{\\mathrm{c}}(r)$ 和 $V_{\\sigma}(r)$。\n2.  在一个从 $r_{\\min}$到 $r_{\\max}$ 的 $N_{\\mathrm{data}}$ 个点的均匀径向网格上，为 $V_{\\mathrm{c}}$、$V_{\\sigma}$ 以及组合道势 $V_{J=0,T=1}$ 和 $V_{J=1,T=0}$ 生成数据点。\n3.  使用 `scipy.interpolate.make_interp_spline`（参数 `k=3`）创建三次B样条插值。\n4.  使用适当的插值势和HO波函数权重因子构建能量期望值的被积函数。\n5.  通过在 $N_{\\mathrm{int}}$ 个点的密集网格上使用 `scipy.integrate.simpson` 进行数值求积，计算所有道和两种方案的能量 $E_{JT}$。\n6.  根据积分得到的能量和样条评估值，计算最终的输出量——$\\Delta E_{JT}$、$\\mathrm{RMS}_{JT}$ 和反对称性标志。然后将所有测试案例的结果整合并格式化为指定的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import make_interp_spline\nfrom scipy.integrate import simpson\n\ndef solve():\n    \"\"\"\n    Solves the computational nuclear physics problem by comparing two B-spline\n    interpolation schemes for a simplified nucleon-nucleon interaction.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General case\n        {'V0': -60.0, 'Vs': 15.0, 'mu': 1.5, 'mus': 1.0, 'a': 0.2, 'r_min': 1e-3, 'r_max_data': 8.0, 'N_data': 25, 'b': 1.8, 'R_max_int': 8.0, 'N_int': 4000},\n        # Case 2: Coarse sampling grid\n        {'V0': -45.0, 'Vs': 18.0, 'mu': 1.3, 'mus': 0.8, 'a': 0.3, 'r_min': 1e-3, 'r_max_data': 8.0, 'N_data': 8, 'b': 2.2, 'R_max_int': 8.0, 'N_int': 4000},\n        # Case 3: Fine grid near origin, smaller range\n        {'V0': -75.0, 'Vs': 10.0, 'mu': 1.7, 'mus': 1.2, 'a': 0.05, 'r_min': 1e-3, 'r_max_data': 6.0, 'N_data': 30, 'b': 1.4, 'R_max_int': 6.0, 'N_int': 3000},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Extract parameters for the current test case\n        V0, Vs, mu, mus, a = case['V0'], case['Vs'], case['mu'], case['mus'], case['a']\n        r_min, r_max_data, N_data = case['r_min'], case['r_max_data'], case['N_data']\n        b, R_max_int, N_int = case['b'], case['R_max_int'], case['N_int']\n        \n        # 1. Define analytic potential functions\n        def Vc_func(r):\n            return V0 * np.exp(-mu * r) / (r + a)\n\n        def Vsigma_func(r):\n            return Vs * r * np.exp(-mus * r)\n\n        # 2. Generate sample data on a linear grid\n        r_data = np.linspace(r_min, r_max_data, N_data)\n        Vc_data = Vc_func(r_data)\n        Vsigma_data = Vsigma_func(r_data)\n        \n        # Data for coupled-channel potentials\n        V01_data = Vc_data - 3 * Vsigma_data\n        V10_data = Vc_data + Vsigma_data\n\n        # 3. Construct cubic B-spline interpolants (k=3)\n        k = 3\n        # Splines for the 'preserving' scheme components\n        spline_Vc = make_interp_spline(r_data, Vc_data, k=k)\n        spline_Vsigma = make_interp_spline(r_data, Vsigma_data, k=k)\n        \n        # Splines for the 'naive' scheme\n        spline_V01_naive = make_interp_spline(r_data, V01_data, k=k)\n        spline_V10_naive = make_interp_spline(r_data, V10_data, k=k)\n\n        # 4. Set up for numerical integration\n        r_int = np.linspace(0.0, R_max_int, N_int)\n        # Integrand weight: 4*pi*r^2 * |psi_0(r)|^2\n        integrand_weight = 4 * np.pi**(-0.5) * b**(-3) * r_int**2 * np.exp(-r_int**2 / b**2)\n\n        # 5. Evaluate potentials and calculate energies for both schemes\n        \n        # Preserving scheme\n        V01_pres_vals = spline_Vc(r_int) - 3 * spline_Vsigma(r_int)\n        V10_pres_vals = spline_Vc(r_int) + spline_Vsigma(r_int)\n        \n        E_01_pres = simpson(integrand_weight * V01_pres_vals, r_int)\n        E_10_pres = simpson(integrand_weight * V10_pres_vals, r_int)\n        E_00_pres = 0.0  # By definition for forbidden channel\n        E_11_pres = 0.0  # By definition for forbidden channel\n\n        # Naive scheme\n        V01_naive_vals = spline_V01_naive(r_int)\n        V10_naive_vals = spline_V10_naive(r_int)\n\n        E_01_naive = simpson(integrand_weight * V01_naive_vals, r_int)\n        E_10_naive = simpson(integrand_weight * V10_naive_vals, r_int)\n        # For forbidden channels, naive scheme uses the same functional forms\n        E_00_naive = E_01_naive\n        E_11_naive = E_10_naive\n\n        # 6. Calculate required output metrics\n        \n        # Energy differences\n        delta_E_01 = E_01_pres - E_01_naive\n        delta_E_10 = E_10_pres - E_10_naive\n\n        # RMS deviation calculation\n        N_eval = 200\n        r_eval = np.linspace(r_min, r_max_data, N_eval)\n\n        # For channel (J=0, T=1)\n        V_01_pres_eval = spline_Vc(r_eval) - 3 * spline_Vsigma(r_eval)\n        V_01_naive_eval = spline_V01_naive(r_eval)\n        rms_01 = np.sqrt(np.mean((V_01_naive_eval - V_01_pres_eval)**2))\n        \n        # For channel (J=1, T=0)\n        V_10_pres_eval = spline_Vc(r_eval) + spline_Vsigma(r_eval)\n        V_10_naive_eval = spline_V10_naive(r_eval)\n        rms_10 = np.sqrt(np.mean((V_10_naive_eval - V_10_pres_eval)**2))\n\n        # Antisymmetry flags\n        tolerance = 1e-10\n        anti_pres = (abs(E_00_pres) < tolerance) and (abs(E_11_pres) < tolerance)\n        anti_naive = (abs(E_00_naive) < tolerance) and (abs(E_11_naive) < tolerance)\n\n        # Append results for this case in the specified order\n        all_results.extend([delta_E_01, delta_E_10, rms_01, rms_10, anti_pres, anti_naive])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3566060"}]}