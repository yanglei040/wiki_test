{"hands_on_practices": [{"introduction": "在核物理中，许多径向积分的范围是从 $0$ 到 $\\infty$。广义高斯-拉盖尔求积是解决这类问题的有力工具，但其效率高度依赖于参数 $\\alpha$ 的选择。这个练习 [@problem_id:3561541] 将引导你思考如何选择最佳的 $\\alpha$ 值，以精确处理由离心势垒（如 $r^\\ell$ 项）引起的原点附近的非多项式行为，从而将积分方法的核心优势发挥到极致。", "problem": "在计算核物理中，径向矩阵元通常涉及对径向坐标 $r \\in [0,\\infty)$ 的积分，其近原点行为受到离心势垒的影响，通常会贡献一个因子 $r^{\\ell}$，其中 $\\ell$ 是轨道角动量量子数。考虑以下形式的积分\n$$\nI_{\\ell}[F] \\equiv \\int_{0}^{\\infty} r^{\\ell}\\, e^{-b r}\\, F(r)\\, dr,\n$$\n其中 $b>0$ 设定了一个指数程标（例如，与核势的程或逆振子长度有关），$F(r)$ 是一个在 $r=0$ 处正则且当 $r\\to\\infty$ 时衰减速度不慢于多项式的足够光滑的函数。在许多实际的矩阵元中，球体积元会贡献一个额外的因子 $r^{2}$，从而得到\n$$\n\\widetilde{I}_{\\ell}[F] \\equiv \\int_{0}^{\\infty} r^{\\ell+2}\\, e^{-b r}\\, F(r)\\, dr.\n$$\n一种标准的数值计算方法是进行标度变换 $x = b r$，然后应用广义高斯-拉盖尔（Gauss–Laguerre）求积，该方法用于近似以下形式的积分\n$$\n\\int_{0}^{\\infty} x^{\\alpha} e^{-x} f(x)\\, dx\n$$\n使用参数为 $\\alpha>-1$ 的广义拉盖尔（Laguerre）多项式的零点。该求积方法的一个核心性质是，对于 $n$ 个节点，它可以精确地计算任何形如 $x^{\\alpha} e^{-x} p(x)$ 的被积函数，其中 $p(x)$ 是次数至多为 $2n-1$ 的多项式。\n\n仅使用这些基本事实和标度变换 $x = b r$，论证当被积函数表现出离心势垒 $r^{\\ell}$（或包含球体积元时的 $r^{\\ell+2}$）时，拉盖尔参数 $\\alpha$ 的选择如何影响精度。下列哪个陈述是正确的？\n\nA. 经过标度变换 $x=b r$ 后，选择 $\\alpha=\\ell$ 使得对于 $F(r)\\equiv 1$ 的模型积分，求积是精确的；并且更一般地，当 $F(r)$ 在 $r=0$ 处光滑时，可以提高精度，因为原点处的非多项式行为被吸收到权重中。\n\nB. 选择 $\\alpha=0$ 对所有 $\\ell$ 都是普遍最优的，因为它最大化了 $r=0$ 附近的求积节点密度，从而可以最好地分辨离心势垒，而与 $\\ell$ 无关。\n\nC. 对于任何固定的 $n$，选择 $\\alpha>\\ell$ 会随着 $\\alpha$ 的增加而严格提高精度，因为增加的权重 $x^{\\alpha}$ 会将节点移向更大的 $x$ 值，并强调指数 $e^{-x}$ 很小的尾部区域。\n\nD. 当存在球体积元时，即对于形式为 $\\widetilde{I}_{\\ell}[F]$ 的积分，在进行相同的标度变换 $x=b r$ 后，设置 $\\alpha=\\ell+2$ 可以捕获复合的近原点幂次，并产生与选项A中相同类型的精度增益。\n\nE. 设置 $\\alpha=-\\ell$ 会抵消离心因子，因此对任何光滑的 $F(r)$ 都能产生更高的精度，因为剩余的因子更接近多项式；这对所有 $\\ell\\ge 1$ 都成立。", "solution": "用户提供了一个关于广义高斯-拉盖尔求积在计算核物理常见积分中应用的问题。我将首先验证问题陈述，然后进行完整解答并评估给出的选项。\n\n### 问题验证\n\n**第1步：提取已知条件**\n- 类型1的积分：$I_{\\ell}[F] \\equiv \\int_{0}^{\\infty} r^{\\ell}\\, e^{-b r}\\, F(r)\\, dr$\n- 类型2的积分：$\\widetilde{I}_{\\ell}[F] \\equiv \\int_{0}^{\\infty} r^{\\ell+2}\\, e^{-b r}\\, F(r)\\, dr$\n- 定义域和参数：$r \\in [0,\\infty)$，$\\ell$ 是轨道角动量量子数（一个非负整数），$b>0$。\n- 函数性质：$F(r)$ 足够光滑，在 $r=0$ 处正则，且当 $r\\to\\infty$ 时衰减速度不慢于多项式。\n- 数值方法：进行标度变换 $x = b r$ 并应用广义高斯-拉盖尔求积。\n- 广义高斯-拉盖尔求积：近似形如 $\\int_{0}^{\\infty} x^{\\alpha} e^{-x} f(x)\\, dx$ 的积分。\n- 求积参数约束：$\\alpha>-1$。\n- 精确性：使用 $n$ 个节点，求积对于任何被积函数 $x^{\\alpha} e^{-x} p(x)$ 都是精确的，其中 $p(x)$ 是次数至多为 $2n-1$ 的多项式。\n\n**第2步：使用已知条件进行验证**\n问题陈述具有科学依据。这些积分是量子力学中标准的径向矩阵元，包含了源于波函数在原点附近径向解的项 $r^\\ell$（离心势垒），有时还包含来自球体积元的因子 $r^2$。对于 $[0,\\infty)$ 上权重形式为 $x^\\alpha e^{-x}$ 的积分，使用广义高斯-拉盖尔求积是数值分析和计算物理中的一种标准技术。\n\n问题是适定的。它要求基于求积方法一个明确陈述的性质，对选择求积参数 $\\alpha$ 的不同策略进行合乎逻辑的分析。所有必要信息均已提供。\n\n问题是客观的，并使用了精确的术语。在此背景下，术语“光滑”和“在 r=0 处正则”具有明确的数学含义，意味着 $F(r)$ 在 $r=0$ 附近有良定义的泰勒级数展开。\n\n该问题没有违反任何无效性标准。它不是科学上不合理的、无法形式化的、不完整的、不切实际的或不适定的。这是一个数值方法中的标准概念性问题。\n\n**第3步：结论与行动**\n问题陈述有效。我现在开始进行解答。\n\n### 推导与选项分析\n\n广义高斯求积的基本原理是选择权重函数（在本例中为 $w(x) = x^{\\alpha} e^{-x}$）来捕捉被积函数中“最困难”或“非多项式”的部分。然后，该求积方法在对函数的剩余相对光滑部分进行积分时就非常高效，它隐式地用一个高次多项式来近似这部分。\n\n我们首先分析积分 $I_{\\ell}[F]$。给定\n$$\nI_{\\ell}[F] \\equiv \\int_{0}^{\\infty} r^{\\ell}\\, e^{-b r}\\, F(r)\\, dr\n$$\n我们应用指定的变量代换，$x = b r$。这意味着 $r = x/b$ 且 $dr = dx/b$。将这些代入积分中得到：\n$$\nI_{\\ell}[F] = \\int_{0}^{\\infty} \\left(\\frac{x}{b}\\right)^{\\ell}\\, e^{-x}\\, F\\left(\\frac{x}{b}\\right)\\, \\frac{dx}{b}\n$$\n$$\nI_{\\ell}[F] = \\frac{1}{b^{\\ell+1}} \\int_{0}^{\\infty} x^{\\ell}\\, e^{-x}\\, F\\left(\\frac{x}{b}\\right)\\, dx\n$$\n这个变换后的积分形式适用于广义高斯-拉盖尔求积。我们要近似一个形式为 $\\int_{0}^{\\infty} g(x)\\,dx$ 的积分，其中 $g(x) = x^{\\ell}\\, e^{-x}\\, F(x/b)$。为了应用参数为 $\\alpha$ 的求积法则，我们必须将被积函数识别为权重 $x^{\\alpha}e^{-x}$ 和一个函数 $f(x)$ 的乘积。\n$$\n\\int_{0}^{\\infty} x^{\\ell}\\, e^{-x}\\, F\\left(\\frac{x}{b}\\right)\\, dx = \\int_{0}^{\\infty} x^{\\alpha}e^{-x} f(x) dx\n$$\n最有效的策略是选择 $\\alpha$ 来匹配被积函数的幂律行为，从而将其吸收到权重函数中。函数 $F(r)$ 被假定在 $r=0$ 处是光滑和正则的，这意味着它有一个泰勒展开 $F(r) = c_0 + c_1 r + \\dots$。因此，$F(x/b) = c_0 + c_1 (x/b) + \\dots$ 是一个行为良好且易于被多项式近似的函数。$x^{\\ell}$ 这一项是难以用多项式近似的部分，特别是当 $\\ell$ 较大时。\n\n通过选择 $\\alpha = \\ell$，我们将权重函数设为 $w(x) = x^{\\ell} e^{-x}$。剩下的函数是 $f(x) = F(x/b)$。由于 $F(r)$ 是光滑的，$f(x)$ 也是光滑的，并且是通过求积法则进行多项式近似的理想候选者。这个选择最优化地利用了求积方法的强大功能。\n\n现在，我们基于这一原理评估每个选项。\n\n**A. 经过标度变换 $x=b r$ 后，选择 $\\alpha=\\ell$ 使得对于 $F(r)\\equiv 1$ 的模型积分，求积是精确的；并且更一般地，当 $F(r)$ 在 $r=0$ 处光滑时，可以提高精度，因为原点处的非多项式行为被吸收到权重中。**\n\n应用上述逻辑，选择 $\\alpha=\\ell$ 是正确的通用策略。这个选择使得被求积方法近似的函数为 $f(x) = F(x/b)$。由于 $F(r)$ 是光滑的，这个 $f(x)$ 可以很好地被多项式近似，从而获得高精度。该陈述正确地指出非多项式行为 $x^\\ell$ 被吸收到权重中。\n我们来检验一下对 $F(r) \\equiv 1$ 的具体声明。在这种情况下，$f(x) = F(x/b) = 1$。要被近似的函数是 $p(x) = 1$，这是一个0次多项式。求积法则对次数最高为 $2n-1$ 的多项式是精确的。因为对于任何节点数 $n \\ge 1$ 都有 $0 \\le 2n-1$，所以该求积将是精确的。这个陈述完全正确。\n**结论：正确**\n\n**B. 选择 $\\alpha=0$ 对所有 $\\ell$ 都是普遍最优的，因为它最大化了 $r=0$ 附近的求积节点密度，从而可以最好地分辨离心势垒，而与 $\\ell$ 无关。**\n\n如果我们设置 $\\alpha=0$，我们使用的是标准的（非广义的）高斯-拉盖尔求积。权重是 $e^{-x}$。对于我们变换后的积分，我们必须将被近似的函数识别为 $f(x) = x^{\\ell} F(x/b)$。求积法则将尝试用一个多项式来近似这整个函数。$x^{\\ell}$ 这一项不是“类多项式”的，因为它需要一个高次多项式才能很好地近似，特别是当 $\\ell$ 很大时。这是对求积点的低效使用。$\\alpha$ 的最优选择使得剩余函数 $f(x)$ 尽可能接近一个多项式。选择 $\\alpha=0$ 实际上与此目标背道而驰。关于节点密度的论证具有误导性；虽然 $\\alpha=0$ 的节点比 $\\alpha=\\ell>0$ 的节点更靠近原点，但它们的位置是针对权重 $e^{-x}$ 优化的，而不是针对行为像 $x^\\ell e^{-x}$ 的被积函数。这个选择远非普遍最优。\n**结论：不正确**\n\n**C. 对于任何固定的 $n$，选择 $\\alpha>\\ell$ 会随着 $\\alpha$ 的增加而严格提高精度，因为增加的权重 $x^{\\alpha}$ 会将节点移向更大的 $x$ 值，并强调指数 $e^{-x}$ 很小的尾部区域。**\n\n如果我们选择 $\\alpha > \\ell$，我们的积分必须重写为 $\\int_{0}^{\\infty} x^{\\alpha}e^{-x} \\left[ x^{\\ell-\\alpha} F\\left(\\frac{x}{b}\\right) \\right] dx$。被求积方法近似的函数是 $f(x) = x^{\\ell-\\alpha} F(x/b)$。由于 $\\alpha > \\ell$，指数 $\\ell-\\alpha$ 是负的。由于 $F(r)$ 在 $r=0$ 处是正则的，通常有 $F(0) = c_0 \\neq 0$。因此，当 $x \\to 0$ 时，$f(x) \\approx c_0 x^{\\ell-\\alpha}$。这个函数在 $x=0$ 处有一个奇点。使用多项式来近似一个带有奇点的函数是数值积分中造成灾难性误差的一个已知原因。精度会极差，而不是提高。\n**结论：不正确**\n\n**D. 当存在球体积元时，即对于形式为 $\\widetilde{I}_{\\ell}[F]$ 的积分，在进行相同的标度变换 $x=b r$ 后，设置 $\\alpha=\\ell+2$ 可以捕获复合的近原点幂次，并产生与选项A中相同类型的精度增益。**\n\n我们来分析积分 $\\widetilde{I}_{\\ell}[F] = \\int_{0}^{\\infty} r^{\\ell+2}\\, e^{-b r}\\, F(r)\\, dr$。像之前一样应用标度变换 $x = br$：\n$$\n\\widetilde{I}_{\\ell}[F] = \\int_{0}^{\\infty} \\left(\\frac{x}{b}\\right)^{\\ell+2}\\, e^{-x}\\, F\\left(\\frac{x}{b}\\right)\\, \\frac{dx}{b} = \\frac{1}{b^{\\ell+3}} \\int_{0}^{\\infty} x^{\\ell+2}\\, e^{-x}\\, F\\left(\\frac{x}{b}\\right)\\, dx\n$$\n被积函数在原点附近的主要幂律行为是 $x^{\\ell+2}$。遵循与 $I_\\ell[F]$ 相同的逻辑，最优策略是将这整个因子吸收到权重函数中。这可以通过选择求积参数 $\\alpha = \\ell+2$ 来实现。权重变为 $w(x) = x^{\\ell+2}e^{-x}$，而被近似的函数变为 $f(x) = F(x/b)$。和之前一样，这个 $f(x)$ 是光滑且行为良好的，从而带来高精度。这个陈述正确地指出 $\\alpha=\\ell+2$ 捕获了复合幂 $r^{\\ell} \\cdot r^2 = r^{\\ell+2}$，并且这提供了与为第一个积分选择 $\\alpha=\\ell$ 相同的好处。\n**结论：正确**\n\n**E. 设置 $\\alpha=-\\ell$ 会抵消离心因子，因此对任何光滑的 $F(r)$ 都能产生更高的精度，因为剩余的因子更接近多项式；这对所有 $\\ell\\ge 1$ 都成立。**\n\n这个陈述有两个主要缺陷。首先，广义高斯-拉盖尔求积的定义域是 $\\alpha > -1$。对于任何轨道角动量量子数 $\\ell \\ge 1$，选择 $\\alpha = -\\ell$ 会导致 $\\alpha \\le -1$。对于 $\\alpha \\le -1$，权重函数 $w(x) = x^{\\alpha}e^{-x}$ 在 $[0, \\infty)$ 上不可积，并且定义正交多项式所需的矩不存在。因此，所提议的求积方法不是良定义的。\n其次，即使我们忽略 $\\alpha$ 的无效性，其推理也是不正确的。其想法是近似 $\\int x^{\\ell} e^{-x} F(x/b) dx$。如果我们使用权重 $w(x) = x^{-\\ell}e^{-x}$，那么剩余的函数将是 $f(x) = (x^{\\ell} e^{-x} F(x/b)) / (x^{-\\ell}e^{-x}) = x^{2\\ell} F(x/b)$。这并不能“抵消”因子；它使幂次加倍，导致得到的函数*更不像*多项式，也更难近似，而不是更容易。\n**结论：不正确**", "answer": "$$\\boxed{AD}$$", "id": "3561541"}, {"introduction": "计算物理中的许多问题，例如有效场论中的动量空间积分，涉及跨越多个数量级的动态范围。在这种情况下，标准的线性积分网格效率低下。这个练习 [@problem_id:3561470] 将教你一个强大的技巧：通过对数变量变换，将标准的高斯-勒让德求积网格转化为对数网格，从而在每个动量十年（decade）内实现均匀的分辨率，并有效处理刚性（stiff）被积函数。", "problem": "考虑计算核物理中出现的动量空间积分，其中一个典型的三维(3D)径向动量积分可简化为在动量的大动态范围上形如 $\\int f(p)\\,dp$ 的一维积分。为了解决跨越数个数量级的刚性问题，使用对数映射 $x=\\log p$，从而在变量 $x$ 上进行求积。从换元定理和高斯求积的核心定义出发（除了在 $[-1,1]$ 上的高斯求积的映射和线性区间变换外，不假设任何专门的公式），推导在使用映射 $x=\\log p$ 从 $p$-域 ($p\\in[10^{-3}\\Lambda,10^{3}\\Lambda]$) 转换到 $x$-域 ($x\\in[\\log(10^{-3}\\Lambda),\\log(10^{3}\\Lambda)]$) 时，高斯节点和权重的变换。对数的参数必须是无量纲的；因此，在动量由固定参考尺度 $\\Lambda$ 缩放的单位下进行计算，并定义无量纲动量 $q=p/\\Lambda$，从而使得 $q\\in[10^{-3},10^{3}]$ 且 $x=\\log q$。\n\n你的任务是为一组代表动量核的刚性测试被积函数，实现带和不带对数映射的高斯求积，并评估其稳定性。使用以下基础依据：\n- 积分的换元定理：如果 $q=\\phi(x)$ 是在 $[a,b]$ 上的一个可微双射，那么 $\\int_{q(a)}^{q(b)} f(q)\\,dq=\\int_{a}^{b} f(\\phi(x))\\,\\phi'(x)\\,dx$。\n- 在 $[-1,1]$ 上的 Gauss-Legendre 求积的定义：对于一个足够光滑的函数 $g(x)$，$\\int_{-1}^{1} g(x)\\,dx\\approx\\sum_{i=1}^{N} w_i\\,g(t_i)$，其中 $t_i$ 和 $w_i$ 是 Gauss-Legendre 节点和权重，并且线性映射将此求积方法转移到任何有限区间。\n\n为形如 $\\int_{10^{-3}}^{10^{3}} f(q)\\,dq$ 的积分，在使用映射 $x=\\log q$ 后构建求积公式，并讨论变换后的权重如何依赖于 $x$。将给定求积计算的数值稳定性度量定义为比率\n$$\nR=\\frac{\\max_i \\left|c_i\\right|}{\\sum_{j} \\left|c_j\\right|},\n$$\n其中 $c_i$ 是每个节点对求积和的加权贡献。解释 $R$ 如何反映少数节点的支配地位，以及这与刚性问题有何关联。设计并实现一个数值稳定的求和策略。\n\n实现两种求积方案：\n- 在 $q\\in[10^{-3},10^{3}]$ 上直接使用 Gauss-Legendre。\n- 通过 $x=\\log q$ 在 $x\\in[\\log 10^{-3},\\log 10^{3}]$ 上使用对数映射的 Gauss-Legendre。\n\n两种方案均使用 $N=64$ 个节点。为了得到高精度的参考值，使用自适应积分器以严格的容差计算 $\\int_{10^{-3}}^{10^{3}} f(q)\\,dq$。\n\n测试套件：\n处理以下在 $q\\in[10^{-3},10^{3}]$ 上的无量纲被积函数 $f(q)$，它们被选择用来检验各种刚性特征。所有结果都是无量纲的，因此不需要物理单位。\n1. 理想情况（正则化的主体）：$f_1(q)=q^2\\,e^{-q^2}$。\n2. 在 $q=1$ 附近的窄局部峰：其中 $\\gamma=10^{-3}$，$f_2(q)=\\dfrac{q^2\\,e^{-q^2}}{(q-1)^2+\\gamma^2}$。\n3. 重尾抑制：$f_3(q)=\\dfrac{q^2}{1+q^8}$。\n4. 在下边界附近边缘局域化：其中 $\\gamma=10^{-4}$，$f_4(q)=\\dfrac{q^2}{(q-10^{-3})^2+\\gamma^2}$。\n5. 在上边界附近边缘局域化：其中 $\\gamma=1$，$f_5(q)=\\dfrac{q^2}{(q-10^{3})^2+\\gamma^2}$。\n\n对于每个 $f_k$，计算：\n- 对数映射求积的相对误差，$E^{\\mathrm{log}}_k=\\left|\\dfrac{I^{\\mathrm{log}}_k-I^{\\mathrm{ref}}_k}{I^{\\mathrm{ref}}_k}\\right|$，其中 $I^{\\mathrm{log}}_k$ 是 $N=64$ 对数映射 Gauss-Legendre 估计值，$I^{\\mathrm{ref}}_k$ 是高精度参考值。\n- 在 $q$ 上直接求积的相对误差，$E^{\\mathrm{dir}}_k=\\left|\\dfrac{I^{\\mathrm{dir}}_k-I^{\\mathrm{ref}}_k}{I^{\\mathrm{ref}}_k}\\right|$。\n- 使用对数映射贡献项的稳定性度量 $R^{\\mathrm{log}}_k$。\n- 使用直接求积贡献项的稳定性度量 $R^{\\mathrm{dir}}_k$。\n\n数值求和必须采用补偿方法来减少舍入误差。如果出现任何角度，均以弧度表示；所有测试函数均不涉及角度。所有输出均为无量纲实数。你的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，按以下顺序排列\n$$\n\\left[ E^{\\mathrm{log}}_1,E^{\\mathrm{dir}}_1,R^{\\mathrm{log}}_1,R^{\\mathrm{dir}}_1,\\;E^{\\mathrm{log}}_2,E^{\\mathrm{dir}}_2,R^{\\mathrm{log}}_2,R^{\\mathrm{dir}}_2,\\;\\dots,\\;E^{\\mathrm{log}}_5,E^{\\mathrm{dir}}_5,R^{\\mathrm{log}}_5,R^{\\mathrm{dir}}_5\\right].\n$$\n每个条目必须打印为十进制浮点数。两种求积方案都至少使用 $N=64$ 个 Gauss-Legendre 节点，并为参考积分使用严格的绝对和相对容差。\n\n你的推导和实现必须基于换元定理和高斯求积的定义。不要提供快捷公式；展示变换后的权重和节点如何从第一性原理中得出，并分析稳定性度量如何捕捉求积和中的刚性。", "solution": "该问题要求针对在宽对数尺度上的动量空间积分，推导并实现两种高斯求积方案，并分析其数值稳定性。我们按照要求，从第一性原理开始推导求积公式。\n\n设所求积分为 $I = \\int_{q_a}^{q_b} f(q) dq$，其中对于无量纲动量 $q$，积分域为 $[q_a, q_b] = [10^{-3}, 10^{3}]$。两种方案的基础是在标准区间 $[-1, 1]$ 上的 $N$ 点 Gauss-Legendre 求积法则：\n$$\n\\int_{-1}^{1} g(t)\\,dt \\approx \\sum_{i=1}^{N} w_i^{\\text{std}} g(t_i^{\\text{std}})\n$$\n其中 $t_i^{\\text{std}}$ 是节点（第 $N$ 阶 Legendre 多项式的零点），$w_i^{\\text{std}}$ 是相应的权重。\n\n**1. 在 $q \\in [q_a, q_b]$ 上的直接 Gauss-Legendre 求积**\n\n为了将高斯求积应用于区间 $[q_a, q_b]$，我们引入一个线性变换，将标准变量 $t \\in [-1, 1]$ 映射到物理变量 $q \\in [q_a, q_b]$。设此映射为 $q(t) = c_1 t + c_0$。边界条件 $q(-1) = q_a$ 和 $q(1) = q_b$ 确定了常数：\n$$\n-c_1 + c_0 = q_a \\quad \\text{和} \\quad c_1 + c_0 = q_b\n$$\n解此方程组可得 $c_1 = \\frac{q_b - q_a}{2}$ 和 $c_0 = \\frac{q_b + q_a}{2}$。变换为：\n$$\nq(t) = \\frac{q_b - q_a}{2}t + \\frac{q_b + q_a}{2}\n$$\n微分元变换为 $dq = \\frac{dq}{dt}dt = \\frac{q_b - q_a}{2}dt$。将此代入原积分，我们得到在标准区间 $[-1, 1]$ 上的一个积分：\n$$\nI = \\int_{q_a}^{q_b} f(q)\\,dq = \\int_{-1}^{1} f(q(t)) \\frac{dq}{dt}\\,dt = \\int_{-1}^{1} f\\left(\\frac{q_b - q_a}{2}t + \\frac{q_b + q_a}{2}\\right) \\frac{q_b - q_a}{2}\\,dt\n$$\n应用 Gauss-Legendre 法则，该积分可由以下求和近似：\n$$\nI^{\\text{dir}} \\approx \\sum_{i=1}^{N} w_i^{\\text{std}} \\left[ f\\left(\\frac{q_b - q_a}{2}t_i^{\\text{std}} + \\frac{q_b + q_a}{2}\\right) \\right] \\left( \\frac{q_b - q_a}{2} \\right)\n$$\n这可以表示为一个标准的求积和 $I^{\\text{dir}} = \\sum_{i=1}^{N} w_i^{\\text{dir}}f(q_i)$，其中 $q$-域中的节点 $q_i$ 和权重 $w_i^{\\text{dir}}$ 为：\n$$\nq_i = \\frac{q_b - q_a}{2}t_i^{\\text{std}} + \\frac{q_b + q_a}{2}\n$$\n$$\nw_i^{\\text{dir}} = w_i^{\\text{std}} \\left( \\frac{q_b - q_a}{2} \\right)\n$$\n对求和的单个贡献项为 $c_i^{\\text{dir}} = w_i^{\\text{dir}}f(q_i)$。\n\n**2. 对数映射的 Gauss-Legendre 求积**\n\n对于在大动态范围上的积分，对数换元通常是有利的。我们应用映射 $x = \\log q$，这意味着 $q = e^x$。微分变换为 $dq = e^x dx$。新变量 $x$ 的积分上下限变为 $x_a = \\log q_a$ 和 $x_b = \\log q_b$。根据换元定理，积分变换为：\n$$\nI = \\int_{q_a}^{q_b} f(q)\\,dq = \\int_{x_a}^{x_b} f(e^x)e^x\\,dx\n$$\n让我们定义变换后的被积函数为 $G(x) = f(e^x)e^x$。问题现在变为计算 $I = \\int_{x_a}^{x_b} G(x)\\,dx$。我们再次使用从标准区间 $t \\in [-1, 1]$ 到 $x$-域区间 $[x_a, x_b]$ 的线性映射：\n$$\nx(t) = \\frac{x_b - x_a}{2}t + \\frac{x_b + x_a}{2}\n$$\n微分为 $dx = \\frac{x_b - x_a}{2}dt$。积分变为：\n$$\nI = \\int_{-1}^{1} G(x(t)) \\frac{dx}{dt}\\,dt = \\int_{-1}^{1} G\\left(\\frac{x_b - x_a}{2}t + \\frac{x_b + x_a}{2}\\right) \\frac{x_b - x_a}{2}\\,dt\n$$\n应用 Gauss-Legendre 法则得到近似值：\n$$\nI^{\\text{log}} \\approx \\sum_{i=1}^{N} w_i^{\\text{std}} \\left[ G\\left(\\frac{x_b - x_a}{2}t_i^{\\text{std}} + \\frac{x_b + x_a}{2}\\right) \\right] \\left( \\frac{x_b - x_a}{2} \\right)\n$$\n为了用原始被积函数 $f(q)$ 来解释这一点，我们代回 $G(x) = f(e^x)e^x$。$x$-域中的节点是 $x_i = \\frac{x_b - x_a}{2}t_i^{\\text{std}} + \\frac{x_b + x_a}{2}$。原始 $q$-域中相应的节点是 $q_i = e^{x_i}$。求积和为：\n$$\nI^{\\text{log}} = \\sum_{i=1}^{N} w_i^{\\text{std}} \\left[ f(e^{x_i})e^{x_i} \\right] \\left( \\frac{x_b - x_a}{2} \\right) = \\sum_{i=1}^{N} w_i^{\\text{std}} \\left[ f(q_i) q_i \\right] \\left( \\frac{\\log q_b - \\log q_a}{2} \\right)\n$$\n这可以写成 $I^{\\text{log}} = \\sum_{i=1}^{N} w_i^{\\text{log}}f(q_i)$ 的形式，其中 $q$-域中的有效权重 $w_i^{\\text{log}}$ 为：\n$$\nw_i^{\\text{log}} = w_i^{\\text{std}} \\cdot q_i \\cdot \\left( \\frac{\\log q_b - \\log q_a}{2} \\right)\n$$\n单个贡献项为 $c_i^{\\text{log}} = w_i^{\\log}f(q_i)$。与直接法不同，这些有效权重不是恒定的；它们与节点位置 $q_i$ 成正比。这意味着动量较大的节点被赋予更大的权重，这抵消了节点 $q_i=e^{x_i}$ 分布的 $1/q$ 密度。\n\n**3. 数值稳定性度量与刚性**\n\n稳定性度量定义为 $R = \\frac{\\max_i |c_i|}{\\sum_j |c_j|}$，其中 $c_i$ 是来自每个节点的加权贡献 $w_i f(q_i)$。该度量量化了各贡献项对积分总值的均匀性。\n- 较小的 $R$ 值（趋近于理想值 $1/N$）表示许多节点都对求和有显著贡献。求积是稳定的，因为结果是许多点的平均值，使其对函数求值或节点放置中的小误差具有鲁棒性。\n- 较大的 $R$ 值（趋近于 1）意味着求和被单个贡献项主导。积分实际上由一个点近似，即 $I \\approx c_k = w_k f(q_k)$。这标志着所选求积方案遇到了一个“刚性”问题。结果是数值不稳定的：它对主导节点 $q_k$ 的精确位置高度敏感，并且由于求积网格未能解析被积函数的结构而容易产生大的截断误差。当被积函数有一个被大多数节点错过的尖锐窄峰时，通常会发生这种主导情况。\n\n直接求积法分布的节点密度在 $[q_a, q_b]$ 中心附近近似均匀，并向端点处增加。如果被积函数具有在对数尺度上局域化的特征（例如，在小 $q$ 处的尖峰或跨越数个数量级的重尾），这种线性节点放置是低效的。它可能在感兴趣的区域分配过少的节点，导致较大的稳定性度量 $R^{\\text{dir}}$ 和较差的精度。\n\n对数映射求积分布的节点 $q_i=e^{x_i}$ 使得每个动量数量级内的节点数是恒定的。这对于具有多尺度行为、低动量区域的尖锐特征或幂律尾的被积函数非常有效。通过变量替换，被积函数在新坐标 $x$ 中通常被转换为一个更平滑的函数，对此标准 Gauss-Legendre 求积非常高效。这导致更均匀分布的贡献项 $|c_i^{\\text{log}}|$，从而得到一个更小、更理想的稳定性度量 $R^{\\text{log}}$。\n\n为了确保求和的准确性，特别是当贡献项 $c_i$ 跨越多个数量级时，需要使用补偿求和算法（如 Kahan 求和）来减轻由浮点舍入误差引起的精度损失。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Derives, implements, and compares direct and log-mapped Gaussian quadrature\n    for stiff integrands in computational physics.\n    \"\"\"\n\n    def kahan_sum(arr):\n        \"\"\"Numerically stable summation using the Kahan algorithm.\"\"\"\n        s = 0.0\n        c = 0.0\n        for x in arr:\n            y = x - c\n            t = s + y\n            c = (t - s) - y\n            s = t\n        return s\n\n    # Problem Parameters\n    N = 64\n    q_min, q_max = 1e-3, 1e3\n    \n    # Test suite of integrands\n    gamma2 = 1e-3\n    gamma4 = 1e-4\n    gamma5 = 1.0\n\n    functions = [\n        (\"f1\", lambda q: q**2 * np.exp(-q**2)),\n        (\"f2\", lambda q: (q**2 * np.exp(-q**2)) / ((q - 1.0)**2 + gamma2**2)),\n        (\"f3\", lambda q: q**2 / (1.0 + q**8)),\n        (\"f4\", lambda q: q**2 / ((q - q_min)**2 + gamma4**2)),\n        (\"f5\", lambda q: q**2 / ((q - q_max)**2 + gamma5**2)),\n    ]\n\n    # Standard Gauss-Legendre nodes and weights on [-1, 1]\n    t_std, w_std = np.polynomial.legendre.leggauss(N)\n\n    # --- Direct Gauss-Legendre Quadrature Setup ---\n    # Linear mapping t -> q\n    # q(t) = a*t + b, where a = (q_max-q_min)/2, b = (q_max+q_min)/2\n    a_q = 0.5 * (q_max - q_min)\n    b_q = 0.5 * (q_max + q_min)\n    q_nodes_dir = a_q * t_std + b_q\n    w_dir = a_q * w_std\n\n    # --- Log-Mapped Gauss-Legendre Quadrature Setup ---\n    x_min, x_max = np.log(q_min), np.log(q_max)\n    # Linear mapping t -> x\n    # x(t) = a*t + b, where a = (x_max-x_min)/2, b = (x_max+x_min)/2\n    a_x = 0.5 * (x_max - x_min)\n    b_x = 0.5 * (x_max + x_min)\n    x_nodes = a_x * t_std + b_x\n    q_nodes_log = np.exp(x_nodes)\n    \n    # Effective weights in q-space for log mapping\n    # w_log_i = w_std_i * q_i * (x_max - x_min) / 2\n    w_log_factor = a_x\n    w_log = w_std * q_nodes_log * w_log_factor\n\n    results = []\n\n    for name, f in functions:\n        # 1. High-accuracy reference integral\n        i_ref, _ = quad(f, q_min, q_max, epsabs=1e-15, epsrel=1e-15, limit=200)\n\n        # 2. Direct Quadrature\n        f_vals_dir = f(q_nodes_dir)\n        contributions_dir = w_dir * f_vals_dir\n        i_dir = kahan_sum(contributions_dir)\n        \n        abs_contributions_dir = np.abs(contributions_dir)\n        r_dir = np.max(abs_contributions_dir) / kahan_sum(abs_contributions_dir)\n        e_dir = np.abs((i_dir - i_ref) / i_ref) if i_ref != 0 else 0.0\n\n        # 3. Log-Mapped Quadrature\n        f_vals_log = f(q_nodes_log)\n        contributions_log = w_log * f_vals_log\n        i_log = kahan_sum(contributions_log)\n\n        abs_contributions_log = np.abs(contributions_log)\n        r_log = np.max(abs_contributions_log) / kahan_sum(abs_contributions_log)\n        e_log = np.abs((i_log - i_ref) / i_ref) if i_ref != 0 else 0.0\n\n        results.extend([e_log, e_dir, r_log, r_dir])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3561470"}, {"introduction": "即使在高斯求积方法的大家族中，也存在具有不同特性的变体，它们在特定应用中各有优劣。这个练习 [@problem_id:3561526] 比较了高斯-勒让德（节点在区间内部）和高斯-洛巴托（节点包含端点）求积方法在计算一个典型的核物理配对矩阵元时的收敛行为。这种比较对于离散变量表示（DVR）等应用尤其重要，因为在这些应用中，网格点的选择直接决定了基组的性质和计算的准确性。", "problem": "考虑在球对称场下，Hartree–Fock–Bogoliubov (HFB) 对关联矩阵元积分的计算，其径向表达式为\n$$\nI \\equiv \\int_{0}^{\\infty} r^{2} \\, dr \\, u(r) \\, v(r) \\, \\Delta(r),\n$$\n其中 $u(r)$ 和 $v(r)$ 是准粒子径向振幅，$\\Delta(r)$ 是对力场。在许多基于离散变量表示 (DVR) 的计算核物理算法中，高斯求积方法被用于在有限域上近似此类积分。你的任务是实现一个程序，在一个解析可解且物理上合理的模型下，比较 Gauss–Legendre 和 Gauss–Lobatto DVR 网格对此积分的收敛性。\n\n使用以下模型函数：\n- 准粒子振幅和对力场定义如下：\n$$\nu(r) = r \\, \\exp\\!\\left(-\\frac{r^{2}}{2 b_{u}^{2}}\\right), \\quad\nv(r) = \\exp\\!\\left(-\\frac{r^{2}}{2 b_{v}^{2}}\\right), \\quad\n\\Delta(r) = \\Delta_{0} \\, \\exp\\!\\left(-\\frac{r^{2}}{2 a^{2}}\\right),\n$$\n其中参数 $a$、$b_{u}$、$b_{v}$ 的单位为飞米，$\\Delta_{0}$ 的单位为兆电子伏特。这一选择得到的被积函数随 $r$ 快速衰减，并在 $r=0$ 处光滑。\n\n你将通过截断到有限区间 $[0,R]$ 来近似这个半无限积分，并通过仿射映射 $r(x) = \\frac{R}{2} (x+1)$ 以及雅可比式 $dr = \\frac{R}{2} dx$ 在参考区间 $[-1,1]$ 上应用高斯求积。必须实现两种求积族：\n- Gauss–Legendre（在 $(-1,1)$ 内有 $N$ 个节点），对于 $[-1,1]$ 上次数最高为 $2N-1$ 的多项式，在单位权重下是精确的。\n- Gauss–Lobatto（有 $N$ 个节点，包括端点 $\\{-1,1\\}$ 以及由 $N-1$ 次勒让德多项式 $P_{N-1}(x)$ 的导数 $P_{N-1}'(x)$ 的零点给出的 $N-2$ 个内部节点），对于 $[-1,1]$ 上次数最高为 $2N-3$ 的多项式，在单位权重下是精确的。\n\n从基础且经过充分检验的根据出发：\n- 勒让德多项式的性质，高斯求积对单位权重下多项式的精确性，以及求积法则在不同区间之间的仿射映射。\n- 拉普拉斯型高斯积分的积分恒等式，\n$$\n\\int_{0}^{\\infty} r^{2n+1} e^{-\\alpha r^{2}} \\, dr = \\frac{n!}{2 \\alpha^{n+1}} \\quad \\text{for} \\quad \\alpha > 0 \\quad \\text{and integer} \\quad n \\ge 0,\n$$\n该恒等式可由伽马函数的定义和变量代换推导得出。\n\n任务：\n1. 从第一性原理出发，推导 $I$ 关于 $a$、$b_{u}$、$b_{v}$ 和 $\\Delta_{0}$ 的精确解析表达式，过程中不引用任何专门的核结构公式。\n2. 在 $[-1,1]$ 上实现两个单位权重的求积程序：Gauss–Legendre 和 Gauss–Lobatto。对于有 $N$ 个节点的 Gauss–Lobatto，使用由 $P_{N-1}'(x)$ 的零点给出的 $N-2$ 个内部节点以及以下权重：\n$$\nw_{i} = \\frac{2}{N(N-1)\\left[P_{N-1}(x_{i})\\right]^{2}} \\quad \\text{for interior nodes}, \\quad\nw_{\\text{end}} = \\frac{2}{N(N-1)} \\quad \\text{for} \\quad x=\\pm 1.\n$$\n3. 使用映射 $r = \\frac{R}{2}(x+1)$ 和 $dr = \\frac{R}{2} dx$，近似计算\n$$\nI \\approx \\sum_{i=1}^{N} w_{i} \\, \\frac{R}{2} \\, \\left[r(x_{i})\\right]^{2} \\, u\\!\\left(r(x_{i})\\right) \\, v\\!\\left(r(x_{i})\\right) \\, \\Delta\\!\\left(r(x_{i})\\right).\n$$\n选择足够大的 $R$，使得对于所提供的测试套件，相对于精确的半无限积分的截断误差可以忽略不计。\n\n测试套件和参数：\n- 程序必须计算两种求积族的绝对相对误差，其定义为\n$$\n\\varepsilon_{\\mathrm{GL}}(N) = \\frac{\\left| I_{\\mathrm{GL}}^{(N)} - I_{\\text{exact}} \\right|}{\\left| I_{\\text{exact}} \\right|}, \\quad\n\\varepsilon_{\\mathrm{GLL}}(N) = \\frac{\\left| I_{\\mathrm{GLL}}^{(N)} - I_{\\text{exact}} \\right|}{\\left| I_{\\text{exact}} \\right|}.\n$$\n- 使用以下三组参数 $(a, b_{u}, b_{v}, \\Delta_{0}, R)$，其中 $a$、$b_{u}$、$b_{v}$、$R$ 的单位为飞米，$\\Delta_{0}$ 的单位为兆电子伏特：\n  1. $(a, b_{u}, b_{v}, \\Delta_{0}, R) = (2.5, 2.0, 2.0, 1.2, 12.0)$。\n  2. $(a, b_{u}, b_{v}, \\Delta_{0}, R) = (1.8, 1.2, 2.8, 0.8, 12.0)$。\n  3. $(a, b_{u}, b_{v}, \\Delta_{0}, R) = (0.8, 0.8, 0.8, 2.0, 8.0)$。\n- 对每组参数，计算 $N \\in \\{8, 16, 24, 32\\}$ 时的误差。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个由方括号括起来的、扁平的、逗号分隔的浮点数列表。顺序必须是：对于按所列顺序的每组参数，以及对于每个按升序排列的 $N$，首先是 Gauss–Legendre 误差，然后是 Gauss–Lobatto 误差：\n$$\n\\left[ \\varepsilon_{\\mathrm{GL}}^{(1)}(8), \\varepsilon_{\\mathrm{GLL}}^{(1)}(8), \\varepsilon_{\\mathrm{GL}}^{(1)}(16), \\varepsilon_{\\mathrm{GLL}}^{(1)}(16), \\ldots, \\varepsilon_{\\mathrm{GL}}^{(1)}(32), \\varepsilon_{\\mathrm{GLL}}^{(1)}(32), \\varepsilon_{\\mathrm{GL}}^{(2)}(8), \\ldots, \\varepsilon_{\\mathrm{GLL}}^{(3)}(32) \\right].\n$$\n- 每个条目都是一个无量纲的小数。该列表必须包含恰好 24 个数字。\n\n科学真实性和约束条件：\n- 对于给定的 $R$，所有情况都是光滑、快速衰减且数值稳定的。请使用双精度浮点运算。\n- 计算中不出现角度，因此不需要角度单位。由于要求的输出是相对误差，最终输出中不出现物理单位。", "solution": "我们从模型函数的定义\n$$\nu(r) = r \\, \\exp\\!\\left(-\\frac{r^{2}}{2 b_{u}^{2}}\\right), \\quad\nv(r) = \\exp\\!\\left(-\\frac{r^{2}}{2 b_{v}^{2}}\\right), \\quad\n\\Delta(r) = \\Delta_{0} \\, \\exp\\!\\left(-\\frac{r^{2}}{2 a^{2}}\\right),\n$$\n以及 HFB 对关联矩阵元积分开始\n$$\nI = \\int_{0}^{\\infty} r^{2} \\, dr \\, u(r) \\, v(r) \\, \\Delta(r).\n$$\n代入 $u(r)$、$v(r)$ 和 $\\Delta(r)$ 可得\n$$\nI = \\int_{0}^{\\infty} r^{2} \\, dr \\, \\left[r \\, e^{-r^{2}/(2 b_{u}^{2})}\\right] \\, \\left[e^{-r^{2}/(2 b_{v}^{2})}\\right] \\, \\left[\\Delta_{0} \\, e^{-r^{2}/(2 a^{2})}\\right]\n= \\Delta_{0} \\int_{0}^{\\infty} r^{3} \\, \\exp\\!\\left[-\\left(\\frac{1}{2 b_{u}^{2}} + \\frac{1}{2 b_{v}^{2}} + \\frac{1}{2 a^{2}}\\right) r^{2}\\right] dr.\n$$\n定义\n$$\n\\alpha \\equiv \\frac{1}{2} \\left( \\frac{1}{b_{u}^{2}} + \\frac{1}{b_{v}^{2}} + \\frac{1}{a^{2}} \\right),\n$$\n对于正的 $a$、$b_{u}$、$b_{v}$，有 $\\alpha > 0$。则\n$$\nI = \\Delta_{0} \\int_{0}^{\\infty} r^{3} e^{-\\alpha r^{2}} dr.\n$$\n为了精确计算该积分，我们从经过充分检验的高斯矩恒等式出发，\n$$\n\\int_{0}^{\\infty} r^{2n+1} e^{-\\alpha r^{2}} dr = \\frac{n!}{2 \\alpha^{n+1}}, \\quad \\alpha > 0, \\quad n \\in \\mathbb{Z}_{\\ge 0}.\n$$\n该恒等式可通过代入 $t = \\alpha r^{2}$，$dt = 2 \\alpha r \\, dr$ 推导得出，使得 $r^{2n+1} dr = \\frac{1}{2 \\alpha^{n+1}} t^{n} dt$，因此\n$$\n\\int_{0}^{\\infty} r^{2n+1} e^{-\\alpha r^{2}} dr = \\frac{1}{2 \\alpha^{n+1}} \\int_{0}^{\\infty} t^{n} e^{-t} dt = \\frac{\\Gamma(n+1)}{2 \\alpha^{n+1}} = \\frac{n!}{2 \\alpha^{n+1}}.\n$$\n当 $n=1$ 时，我们得到\n$$\n\\int_{0}^{\\infty} r^{3} e^{-\\alpha r^{2}} dr = \\frac{1}{2 \\alpha^{2}}.\n$$\n因此，精确的解析值为\n$$\nI_{\\text{exact}} = \\Delta_{0} \\cdot \\frac{1}{2 \\alpha^{2}} = \\frac{\\Delta_{0}}{2} \\left[ \\frac{2}{\\left(\\frac{1}{b_{u}^{2}} + \\frac{1}{b_{v}^{2}} + \\frac{1}{a^{2}}\\right)} \\right]^{2} = \\frac{\\Delta_{0}}{2 \\alpha^{2}}.\n$$\n\n接下来，我们设计求积算法。在 $[-1,1]$ 上带单位权重的高斯求积可近似为\n$$\n\\int_{-1}^{1} g(x) \\, dx \\approx \\sum_{i=1}^{N} w_{i} \\, g(x_{i}).\n$$\n- 对于 Gauss–Legendre，节点 $\\{x_{i}\\}$ 是 $P_{N}(x)$ 的 $N$ 个零点，权重 $\\{w_{i}\\}$ 的选择使其对次数最高为 $2N-1$ 的多项式达到精确。\n- 对于 Gauss–Lobatto，节点包括端点 $x=\\pm 1$，以及作为 $P_{N-1}'(x)$ 零点的 $N-2$ 个内部节点。权重为\n$$\nw_{\\text{end}} = \\frac{2}{N(N-1)}, \\quad\nw_{i} = \\frac{2}{N(N-1)\\left[P_{N-1}(x_{i})\\right]^{2}} \\quad \\text{for interior nodes}.\n$$\n该规则对次数最高为 $2N-3$ 的多项式是精确的。\n\n我们希望近似\n$$\nI = \\int_{0}^{\\infty} r^{2} dr \\, u(r) v(r) \\Delta(r).\n$$\n我们将其截断到 $[0,R]$ 并使用仿射映射 $r(x) = \\frac{R}{2}(x+1)$，$dr = \\frac{R}{2} dx$，从而得到\n$$\nI \\approx \\int_{-1}^{1} \\left[ \\left( r(x) \\right)^{2} u(r(x)) v(r(x)) \\Delta(r(x)) \\right] \\left( \\frac{R}{2} \\right) dx.\n$$\n因此，求积近似式为\n$$\nI^{(N)} \\approx \\sum_{i=1}^{N} w_{i} \\left( \\frac{R}{2} \\right) \\left[ r(x_{i}) \\right]^{2} u\\!\\left(r(x_{i})\\right) v\\!\\left(r(x_{i})\\right) \\Delta\\!\\left(r(x_{i})\\right).\n$$\n在我们的高斯模型中，选择 $R$ 使得 $R \\gg a, b_{u}, b_{v}$，可以确保截断误差可忽略不计，因为被积函数的行为类似于 $r^{3} e^{-\\alpha r^{2}}$（其中 $\\alpha > 0$），这使得尾部积分 $\\int_{R}^{\\infty}$ 呈指数级小。\n\n算法步骤：\n1. 对于给定的 $(a, b_{u}, b_{v}, \\Delta_{0})$，计算 $\\alpha = \\frac{1}{2}\\left( b_{u}^{-2} + b_{v}^{-2} + a^{-2} \\right)$，然后计算 $I_{\\text{exact}} = \\Delta_{0}/(2 \\alpha^{2})$。\n2. 对于每个 $N$ 和每种求积族，计算在 $[-1,1]$ 上的节点 $\\{x_{i}\\}$ 和权重 $\\{w_{i}\\}$。对于 Gauss–Legendre，使用标准程序构造 $P_{N}$ 的零点和权重。对于 Gauss–Lobatto，构造 $P_{N-1}(x)$，找到 $P_{N-1}'(x)$ 的根作为内部节点，并使用给定的公式计算包括端点 $x=\\pm 1$ 在内的所有权重。\n3. 映射到 $r_{i} = \\frac{R}{2}(x_{i}+1)$ 并计算被积函数\n$$\nf(r) = r^{2} \\, u(r) \\, v(r) \\, \\Delta(r) = \\Delta_{0} \\, r^{3} \\, \\exp\\!\\left[-\\left(\\frac{1}{2 b_{u}^{2}} + \\frac{1}{2 b_{v}^{2}} + \\frac{1}{2 a^{2}}\\right) r^{2}\\right].\n$$\n4. 构造求积和\n$$\nI_{\\mathrm{GL}}^{(N)} = \\sum_{i=1}^{N} w_{i}^{\\mathrm{GL}} \\left( \\frac{R}{2} \\right) f\\!\\left( r(x_{i}^{\\mathrm{GL}}) \\right), \\quad\nI_{\\mathrm{GLL}}^{(N)} = \\sum_{i=1}^{N} w_{i}^{\\mathrm{GLL}} \\left( \\frac{R}{2} \\right) f\\!\\left( r(x_{i}^{\\mathrm{GLL}}) \\right).\n$$\n5. 计算绝对相对误差\n$$\n\\varepsilon_{\\mathrm{GL}}(N) = \\frac{| I_{\\mathrm{GL}}^{(N)} - I_{\\text{exact}} |}{| I_{\\text{exact}} |}, \\quad\n\\varepsilon_{\\mathrm{GLL}}(N) = \\frac{| I_{\\mathrm{GLL}}^{(N)} - I_{\\text{exact}} |}{| I_{\\text{exact}} |}.\n$$\n\n收敛性讨论：\n- 对于 $[-1,1]$ 上的解析被积函数，Gauss–Legendre 和 Gauss–Lobatto 都具有谱精度，这意味着误差随 $N$ 的减小速度快于 $N$ 的任何次幂。然而，对于多项式，Gauss–Legendre 达到的精确度 ($2N-1$) 高于 Gauss–Lobatto ($2N-3$)，并且其内部节点避开了端点，这通常导致对于没有端点奇点的光滑被积函数，其渐近误差中的常数更小。在这个模型中，经过映射的被积函数是光滑的，并且由于当 $r \\to 0$ 时 $f(r) \\sim r^{3}$，它在左端点处为零，在 $r=R$ 处则呈指数级小。因此，在固定的 $N$ 值下，预计 Gauss–Legendre 的收敛速度会稍快一些，尽管 Gauss–Lobatto 仍然保持高精度。整个测试套件的数值结果通过报告的 $\\varepsilon_{\\mathrm{GL}}(N)$ 和 $\\varepsilon_{\\mathrm{GLL}}(N)$ 值来量化这种影响。\n\n测试套件实现细节：\n- 参数集：\n  1. $(a, b_{u}, b_{v}, \\Delta_{0}, R) = (2.5, 2.0, 2.0, 1.2, 12.0)$。\n  2. $(a, b_{u}, b_{v}, \\Delta_{0}, R) = (1.8, 1.2, 2.8, 0.8, 12.0)$。\n  3. $(a, b_{u}, b_{v}, \\Delta_{0}, R) = (0.8, 0.8, 0.8, 2.0, 8.0)$。\n- 每种情况的节点数： $N \\in \\{8, 16, 24, 32\\}$。\n- 输出：一个包含 24 个浮点数的扁平列表，按每种情况及每个 $N$ 的顺序排列，先是 $\\varepsilon_{\\mathrm{GL}}(N)$，然后是 $\\varepsilon_{\\mathrm{GLL}}(N)$。\n\n这种方法完全分离了 Gauss–Lobatto 与 Gauss–Legendre DVR 网格对一个光滑的、受核物理启发的对关联矩阵元收敛行为的影响，同时为定量误差评估保留了一个解析参考。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gauss_legendre(n: int):\n    \"\"\"\n    Return nodes and weights for Gauss–Legendre quadrature on [-1, 1].\n    \"\"\"\n    x, w = np.polynomial.legendre.leggauss(n)\n    return x, w\n\ndef gauss_lobatto(n: int):\n    \"\"\"\n    Return nodes and weights for Gauss–Lobatto quadrature on [-1, 1] with unit weight.\n    Nodes include endpoints -1 and 1; interior nodes are roots of P_{n-1}'(x).\n    Weights:\n        w_end = 2/(n*(n-1)),\n        w_i = 2/(n*(n-1)*[P_{n-1}(x_i)]^2) for interior nodes.\n    \"\"\"\n    if n  2:\n        raise ValueError(\"Gauss–Lobatto requires n >= 2.\")\n    # Construct Legendre polynomial P_{n-1}\n    P = np.polynomial.legendre.Legendre.basis(n - 1)\n    dP = P.deriv()\n    # Interior nodes are roots of derivative\n    if n == 2:\n        interior = np.array([], dtype=float)\n    else:\n        interior = dP.roots()\n        interior.sort()\n    nodes = np.concatenate((np.array([-1.0]), interior, np.array([1.0])))\n    weights = np.empty_like(nodes)\n    w_end = 2.0 / (n * (n - 1))\n    weights[0] = w_end\n    weights[-1] = w_end\n    # Interior weights\n    for i in range(1, len(nodes) - 1):\n        xi = nodes[i]\n        Pi = P(xi)\n        weights[i] = 2.0 / (n * (n - 1) * (Pi * Pi))\n    return nodes, weights\n\ndef map_to_radius(x, R):\n    \"\"\"\n    Affine map from x in [-1,1] to r in [0, R].\n    r = (R/2)*(x + 1)\n    \"\"\"\n    return 0.5 * R * (x + 1.0)\n\ndef integrand_r(r, a, bu, bv, Delta0):\n    \"\"\"\n    f(r) = r^2 * u(r) * v(r) * Delta(r)\n         = Delta0 * r^3 * exp(-r^2/2 * (1/bu^2 + 1/bv^2 + 1/a^2))\n    \"\"\"\n    inv_bu2 = 1.0 / (bu * bu)\n    inv_bv2 = 1.0 / (bv * bv)\n    inv_a2 = 1.0 / (a * a)\n    expo = -0.5 * (inv_bu2 + inv_bv2 + inv_a2) * (r * r)\n    return Delta0 * (r ** 3) * np.exp(expo)\n\ndef exact_integral(a, bu, bv, Delta0):\n    \"\"\"\n    I_exact = Delta0 * integral_0^inf r^3 exp(-alpha * r^2) dr\n            = Delta0 * (1 / (2 * alpha^2))\n    where alpha = 0.5 * (1/bu^2 + 1/bv^2 + 1/a^2).\n    \"\"\"\n    inv_bu2 = 1.0 / (bu * bu)\n    inv_bv2 = 1.0 / (bv * bv)\n    inv_a2 = 1.0 / (a * a)\n    alpha = 0.5 * (inv_bu2 + inv_bv2 + inv_a2)\n    return Delta0 / (2.0 * alpha * alpha)\n\ndef quadrature_integral(method, N, a, bu, bv, Delta0, R):\n    \"\"\"\n    Compute the quadrature approximation on [0, R] via mapping from [-1,1].\n    method: 'GL' or 'GLL'\n    \"\"\"\n    if method == 'GL':\n        x, w = gauss_legendre(N)\n    elif method == 'GLL':\n        x, w = gauss_lobatto(N)\n    else:\n        raise ValueError(\"Unknown method\")\n    r = map_to_radius(x, R)\n    drdx = 0.5 * R\n    f = integrand_r(r, a, bu, bv, Delta0)\n    return np.sum(w * drdx * f)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (a, bu, bv, Delta0, R)\n    test_cases = [\n        (2.5, 2.0, 2.0, 1.2, 12.0),\n        (1.8, 1.2, 2.8, 0.8, 12.0),\n        (0.8, 0.8, 0.8, 2.0, 8.0),\n    ]\n    Ns = [8, 16, 24, 32]\n\n    results = []\n    for (a, bu, bv, Delta0, R) in test_cases:\n        I_exact = exact_integral(a, bu, bv, Delta0)\n        for N in Ns:\n            I_GL = quadrature_integral('GL', N, a, bu, bv, Delta0, R)\n            I_GLL = quadrature_integral('GLL', N, a, bu, bv, Delta0, R)\n            err_GL = abs(I_GL - I_exact) / abs(I_exact)\n            err_GLL = abs(I_GLL - I_exact) / abs(I_exact)\n            results.append(err_GL)\n            results.append(err_GLL)\n\n    # Final print statement in the exact required format.\n    # Format with scientific notation for clarity and reproducibility.\n    formatted = \",\".join(f\"{x:.12e}\" for x in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3561526"}]}