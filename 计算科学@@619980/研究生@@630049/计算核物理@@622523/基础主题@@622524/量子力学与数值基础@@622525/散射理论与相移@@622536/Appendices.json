{"hands_on_practices": [{"introduction": "有效程展开 (Effective Range Expansion, ERE) 是连接低能散射实验数据与核力理论参数的基石。本练习将指导您如何从给定的s波相移数据中，通过加权最小二乘法拟合，精确提取散射长度 $a$ 和有效程 $r_e$ 这两个描述核力在低能下基本性质的物理量。通过这个实践，您将掌握一项在分析实验数据和约束理论模型时至关重要的计算技能。[@problem_id:3589013]", "problem": "你的任务是设计并实现一个完整的、可运行的程序，在计算核物理的背景下，从低能 $s$ 波相移数据中，通过符合原理的加权最小二乘法提取散射长度和有效力程。该程序必须基于成熟的散射理论，并且必须量化参数的不确定性及其相关性。\n\n从弹性双体散射的以下基本原理开始：\n- 包含短程相互作用的径向薛定谔方程产生相移，对于低能 $s$ 波散射，有效力程展开是连接可观测量和参数的一种广泛使用的表示方法。\n- 相移 $\\delta_0(k)$（其中 $k$ 是相对波数）是一个物理可观测量，对于 $s$ 波散射，有效力程展开通过一个级数将 $k \\cot \\delta_0(k)$ 与散射长度 $a$ 和有效力程 $r_e$ 联系起来，该级数的主导项在低 $k$ 时有效。\n\n你的任务是：\n1. 从有效力程展开的基础出发，推导一个适用于加权最小二乘（Weighted Least Squares, WLS）回归的参数线性模型，该模型使用带有已知不确定度的测量值 $\\delta_0(k)$。明确论证如何变换可观测量及其不确定度，以使模型在拟合参数上呈线性，并根据测量不确定度正确定义权重。\n2. 为你得到的线性模型设计并实现 WLS 估计量，包括构建设计矩阵、根据测量不确定度计算权重以及求解正规方程组。\n3. 从拟合的线性参数中获得参数点估计 $(a,r_e)$，并推导一个基于 WLS 估计量协方差矩阵的线性误差传播的不确定性量化过程。推导并计算参数的标准差及其相关系数。同时，提出一种补充方法来评估参数不确定性和相关性，该方法对轻微的非线性和噪声异方差性具有鲁棒性。\n4. 将你的方法应用于以下合成数据集测试套件。对每个数据集，首先通过有效力程展开计算无噪声的 $\\delta_0(k)$，然后添加具有指定标准差 $\\sigma_\\delta$ 和固定随机种子的高斯测量噪声以确保可复现性，从而构建测量的相移。角度必须以弧度为单位，$k$ 必须以 $\\mathrm{fm}^{-1}$ 为单位。散射长度 $a$ 和有效力程 $r_e$ 必须以 $\\mathrm{fm}$ 为单位报告。\n\n用于建模的基本原理：\n- 低能下的有效力程展开：\n$$\nk \\cot \\delta_0(k) = -\\frac{1}{a} + \\frac{1}{2} r_e k^2 + \\mathcal{O}(k^4).\n$$\n- 由此，定义一个参数线性的可观测量 $y(k)$，对 $k^2$ 的多项式进行回归，并提供从 $\\delta_0(k)$ 到 $y(k)$ 及其不确定度的变换。\n\n每个测试用例的合成数据生成协议：\n- 对于每个列出的波数 $k_i$，使用以下公式计算无噪声相移 $\\delta_0(k_i)$：\n$$\n\\tan \\delta_0(k_i) = \\frac{k_i}{-\\frac{1}{a_{\\text{true}}} + \\frac{1}{2} r_{e,\\text{true}} k_i^2}.\n$$\n- 然后，使用指定的 $\\sigma_\\delta$ 和随机种子，添加独立的高斯噪声 $\\epsilon_i \\sim \\mathcal{N}(0,\\sigma_\\delta^2)$，以获得测量值 $\\delta_{0,\\text{meas}}(k_i) = \\delta_0(k_i) + \\epsilon_i$。\n\n测试套件规格：\n- 案例 1（通用“理想路径”案例）：\n  - 真实参数：$a_{\\text{true}} = 5.0\\,\\mathrm{fm}$，$r_{e,\\text{true}} = 1.8\\,\\mathrm{fm}$。\n  - 波数 $k$（单位 $\\mathrm{fm}^{-1}$）：$[0.05,0.075,0.10,0.125,0.15,0.175,0.20,0.225,0.25,0.275,0.30]$。\n  - 噪声标准差：$\\sigma_\\delta = 0.01$ 弧度。\n  - 随机种子：$42$。\n- 案例 2（近幺正性，大散射长度）：\n  - 真实参数：$a_{\\text{true}} = 100.0\\,\\mathrm{fm}$，$r_{e,\\text{true}} = 2.0\\,\\mathrm{fm}$。\n  - 波数 $k$（单位 $\\mathrm{fm}^{-1}$）：$[0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.10,0.11,0.12]$。\n  - 噪声标准差：$\\sigma_\\delta = 0.005$ 弧度。\n  - 随机种子：$123$。\n- 案例 3（边缘案例：极低 $k$ 范围，参数分离具有挑战性）：\n  - 真实参数：$a_{\\text{true}} = 5.0\\,\\mathrm{fm}$，$r_{e,\\text{true}} = 1.8\\,\\mathrm{fm}$。\n  - 波数 $k$（单位 $\\mathrm{fm}^{-1}$）：$[0.005,0.008,0.011,0.014,0.017,0.020]$。\n  - 噪声标准差：$\\sigma_\\delta = 0.005$ 弧度。\n  - 随机种子：$2021$。\n- 案例 4（负散射长度，类虚态情景）：\n  - 真实参数：$a_{\\text{true}} = -20.0\\,\\mathrm{fm}$，$r_{e,\\text{true}} = 2.7\\,\\mathrm{fm}$。\n  - 波数 $k$（单位 $\\mathrm{fm}^{-1}$）：$[0.05,0.075,0.10,0.125,0.15,0.175,0.20,0.225,0.25,0.275,0.30,0.325,0.35,0.375,0.40,0.425,0.45,0.475,0.50]$。\n  - 噪声标准差：$\\sigma_\\delta = 0.02$ 弧度。\n  - 随机种子：$7$。\n\n程序要求：\n- 从线性化模型中实现 WLS 拟合，以获得以 $\\mathrm{fm}$ 为单位的参数估计值 $(a,r_e)$。\n- 使用线性参数的 WLS 协方差，通过线性误差传播来量化参数不确定性（标准差）和相关系数。\n- 你的程序必须生成单行输出，其中包含一个逗号分隔的 Python 列表之列表形式的结果，每个测试用例对应一个子列表，每个子列表包含 $[a_{\\text{fit}}, r_{e,\\text{fit}}, \\sigma_a, \\sigma_{r_e}, \\rho]$。所有角度均以弧度为单位，$k$ 以 $\\mathrm{fm}^{-1}$ 为单位。$a_{\\text{fit}}$、$r_{e,\\text{fit}}$、$\\sigma_a$ 和 $\\sigma_{r_e}$ 的单位是 $\\mathrm{fm}$，$\\rho$ 是无量纲的。\n\n最终打印的行必须具有确切的格式：单行，结果为方括号括起来的列表，例如 `[[x_1,y_1,...],[x_2,y_2,...],...]`，不含任何附加文本。", "solution": "该问题是有效的。它是一个在计算核物理领域中定义明确、有科学依据的问题，要求推导和实现一个标准的数据分析程序。所有必要的信息都已提供，任务也已明确定义。\n\n目标是使用加权最小二乘（WLS）拟合，从合成的相移数据 $\\delta_0(k)$ 中提取 $s$ 波散射长度 $a$ 和有效力程 $r_e$。这包括将有效力程展开（ERE）提供的模型线性化，执行拟合，并将不确定性传播到最终的物理参数。\n\n**1. 线性模型和权重的推导**\n\n分析始于低能 $s$ 波（$l=0$）散射的有效力程展开，它将给定相对波数 $k$ 下的相移 $\\delta_0$ 与散射参数 $a$ 和 $r_e$ 联系起来：\n$$\nk \\cot \\delta_0(k) = -\\frac{1}{a} + \\frac{1}{2} r_e k^2 + \\mathcal{O}(k^4)\n$$\n在低能情况下，$\\mathcal{O}(k^4)$ 及更高阶项可以忽略。如果我们恰当地定义变量，截断级数会得到一个参数线性的模型。我们定义：\n- 自变量 $x_i = k_i^2$。\n- 因变量（可观测量）$y_i = k_i \\cot \\delta_{0,\\text{meas}}(k_i)$，其中 $\\delta_{0,\\text{meas}}(k_i)$ 是在波数 $k_i$ 处测量的相移。\n- 拟合参数 $c_0 = -1/a$ 和 $c_1 = r_e/2$。\n\n根据这些定义，ERE 变为一个线性方程：\n$$\ny_i = c_0 + c_1 x_i\n$$\n这是一个简单的线性回归模型。我们可以通过拟合变换后的数据点 $(x_i, y_i)$ 来确定系数 $c_0$ 和 $c_1$。\n\n为了执行*加权*最小二乘拟合，我们需要将不确定度从测量的相移 $\\delta_{0,i}$ 传播到变换后的可观测量 $y_i$。问题指出，每个测量的相移 $\\delta_{0,i}$ 都有一个相关的不确定度 $\\sigma_{\\delta,i}$。使用一阶误差传播，$y_i = k_i \\cot \\delta_{0,i}$ 的方差 $\\sigma_{y,i}^2$ 为：\n$$\n\\sigma_{y,i}^2 = \\left( \\frac{\\partial y_i}{\\partial \\delta_{0,i}} \\right)^2 \\sigma_{\\delta,i}^2\n$$\n导数为：\n$$\n\\frac{\\partial y_i}{\\partial \\delta_{0,i}} = \\frac{\\partial}{\\partial \\delta_{0,i}} (k_i \\cot \\delta_{0,i}) = k_i (-\\csc^2 \\delta_{0,i}) = -k_i (1 + \\cot^2 \\delta_{0,i})\n$$\n因此，方差为：\n$$\n\\sigma_{y,i}^2 = \\left( -k_i (1 + \\cot^2 \\delta_{0,i}) \\right)^2 \\sigma_{\\delta,i}^2 = k_i^2 (1 + \\cot^2 \\delta_{0,i})^2 \\sigma_{\\delta,i}^2\n$$\n在实践中，我们使用测量的相移 $\\delta_{0,\\text{meas}}(k_i)$ 来估计此表达式中 $\\cot \\delta_{0,i}$ 的值。WLS 拟合中每个数据点 $(x_i, y_i)$ 的权重是该方差的倒数：\n$$\nw_i = \\frac{1}{\\sigma_{y,i}^2} = \\frac{1}{k_i^2 (1 + \\cot^2 \\delta_{0,\\text{meas}}(k_i))^2 \\sigma_{\\delta,i}^2}\n$$\n\n**2. 加权最小二乘（WLS）形式体系**\n\nWLS 方法寻找参数矢量 $\\mathbf{p} = [c_0, c_1]^T$，以最小化卡方函数 $\\chi^2$：\n$$\n\\chi^2(\\mathbf{p}) = \\sum_{i=1}^{N} w_i (y_i - (c_0 + c_1 x_i))^2\n$$\n其中 $N$ 是数据点的数量。这可以用矩阵形式表示。令 $\\mathbf{y}$ 为 $N \\times 1$ 的观测向量 $[y_1, \\dots, y_N]^T$，$\\mathbf{X}$ 为 $N \\times 2$ 的设计矩阵，$\\mathbf{W}$ 为 $N \\times N$ 的对角权重矩阵。\n$$\n\\mathbf{X} = \\begin{pmatrix} 1  x_1 \\\\ 1  x_2 \\\\ \\vdots  \\vdots \\\\ 1  x_N \\end{pmatrix} = \\begin{pmatrix} 1  k_1^2 \\\\ 1  k_2^2 \\\\ \\vdots  \\vdots \\\\ 1  k_N^2 \\end{pmatrix}, \\quad \\mathbf{W} = \\begin{pmatrix} w_1  0  \\dots \\\\ 0  w_2  \\dots \\\\ \\vdots  \\vdots  \\ddots \\end{pmatrix}\n$$\n于是 $\\chi^2$ 函数为 $\\chi^2 = (\\mathbf{y} - \\mathbf{Xp})^T \\mathbf{W} (\\mathbf{y} - \\mathbf{Xp})$。通过求解正规方程组可以找到最小值：\n$$\n(\\mathbf{X}^T \\mathbf{W} \\mathbf{X}) \\hat{\\mathbf{p}} = \\mathbf{X}^T \\mathbf{W} \\mathbf{y}\n$$\n估计参数矢量 $\\hat{\\mathbf{p}}$ 的解为：\n$$\n\\hat{\\mathbf{p}} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{W} \\mathbf{y}\n$$\n这提供了最佳拟合估计值 $\\hat{c}_0$ 和 $\\hat{c}_1$。\n\n**3. 不确定性量化**\n\n拟合参数 $\\hat{\\mathbf{p}}$ 的协方差矩阵由 $\\chi^2$ 函数的 Hessian 矩阵的逆给出：\n$$\n\\mathbf{C}_p = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} = \\begin{pmatrix} \\sigma_{c_0}^2  \\operatorname{cov}(c_0, c_1) \\\\ \\operatorname{cov}(c_0, c_1)  \\sigma_{c_1}^2 \\end{pmatrix}\n$$\n从拟合参数 $\\hat{c}_0$ 和 $\\hat{c}_1$，我们获得物理参数 $\\hat{a}$ 和 $\\hat{r}_e$：\n$$\n\\hat{a} = -\\frac{1}{\\hat{c}_0}, \\quad \\hat{r}_e = 2 \\hat{c}_1\n$$\n$\\hat{a}$ 和 $\\hat{r}_e$ 的不确定性通过使用协方差矩阵 $\\mathbf{C}_p$ 从 $\\hat{\\mathbf{p}}$ 的不确定性传播得到。对于 $\\hat{a}$：\n$$\n\\sigma_a^2 \\approx \\left( \\frac{\\partial a}{\\partial c_0} \\right)^2 \\sigma_{c_0}^2 = \\left( \\frac{1}{c_0^2} \\right)^2 \\sigma_{c_0}^2 = a^4 \\sigma_{c_0}^2 \\implies \\sigma_a = |\\hat{a}^2| \\sigma_{c_0}\n$$\n对于 $\\hat{r}_e$：\n$$\n\\sigma_{r_e}^2 \\approx \\left( \\frac{\\partial r_e}{\\partial c_1} \\right)^2 \\sigma_{c_1}^2 = (2)^2 \\sigma_{c_1}^2 \\implies \\sigma_{r_e} = 2 \\sigma_{c_1}\n$$\n$\\hat{a}$ 和 $\\hat{r}_e$ 之间的协方差主要由 $\\hat{c}_0$ 和 $\\hat{c}_1$ 之间的协方差驱动，因为变换是独立的：\n$$\n\\operatorname{cov}(a, r_e) \\approx \\frac{\\partial a}{\\partial c_0} \\frac{\\partial r_e}{\\partial c_1} \\operatorname{cov}(c_0, c_1) = \\left(\\frac{1}{c_0^2}\\right) (2) \\operatorname{cov}(c_0, c_1) = 2 a^2 \\operatorname{cov}(c_0, c_1)\n$$\n相关系数 $\\rho$ 定义为 $\\rho = \\frac{\\operatorname{cov}(a, r_e)}{\\sigma_a \\sigma_{r_e}}$。代入推导的表达式：\n$$\n\\rho = \\frac{2 a^2 \\operatorname{cov}(c_0, c_1)}{( |a^2| \\sigma_{c_0} ) (2 \\sigma_{c_1})} = \\frac{\\operatorname{cov}(c_0, c_1)}{\\sigma_{c_0} \\sigma_{c_1}} = \\rho_{c_0, c_1}\n$$\n物理参数 $(a, r_e)$ 的相关系数与线性拟合参数 $(c_0, c_1)$ 的相关系数相同，可以直接从协方差矩阵 $\\mathbf{C}_p$ 计算得出。\n\n一种评估不确定性的补充方法，对模型非线性和其他假设违规情况具有鲁棒性，是非参数自助法（non-parametric bootstrap）。该过程包括：\n1. 通过从原始测量对 $(k_i, \\delta_{0,i})$ 集合中有放回地抽取 $N$ 个数据点，创建大量重采样数据集。\n2. 对每个重采样数据集执行整个 WLS 分析，以获得一对估计值 $(\\hat{a}^*, \\hat{r}_e^*)$。\n3. 这些估计值的集合构成了 $(\\hat{a}, \\hat{r}_e)$ 的经验分布。\n4. 这些分布的标准差可作为 $\\sigma_a$ 和 $\\sigma_{r_e}$ 的鲁棒估计，它们的样本相关系数提供了 $\\rho$ 的估计。\n根据主要要求，这里没有实现此方法，但它代表了一种标准且功能强大的验证技术。\n\n**4. 实现策略**\n\nPython 程序将针对每个测试用例遵循以下步骤：\n1.  使用指定的种子初始化随机数生成器以保证可复现性。\n2.  对于给定的真实参数 $(a_{\\text{true}}, r_{e,\\text{true}})$ 和波数 $\\{k_i\\}$，生成无噪声相移 $\\delta_0(k_i) = \\arctan( k_i / (-1/a_{\\text{true}} + 0.5 r_{e,\\text{true}} k_i^2) )$。\n3.  添加均值为 $0$、标准差为 $\\sigma_\\delta$ 的高斯噪声，以创建“测量的”相移 $\\delta_{0,\\text{meas}}(k_i)$。\n4.  变换数据：构建元素为 $y_i = k_i \\cot(\\delta_{0,\\text{meas}}(k_i))$ 的向量 $\\mathbf{y}$ 和行为 $[1, k_i^2]$ 的设计矩阵 $\\mathbf{X}$。\n5.  使用上述推导的公式计算权重 $w_i = 1/\\sigma_{y,i}^2$，并构建对角权重矩阵 $\\mathbf{W}$。\n6.  求解正规方程组 $\\hat{\\mathbf{p}} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} (\\mathbf{X}^T \\mathbf{W} \\mathbf{y})$ 以找到 $\\hat{\\mathbf{p}} = [\\hat{c}_0, \\hat{c}_1]^T$。这可以通过先计算 $\\mathbf{A} = \\mathbf{X}^T \\mathbf{W} \\mathbf{X}$ 和 $\\mathbf{b} = \\mathbf{X}^T \\mathbf{W} \\mathbf{y}$，然后求解系统 $\\mathbf{A}\\hat{\\mathbf{p}} = \\mathbf{b}$ 来高效完成。\n7.  计算参数协方差矩阵 $\\mathbf{C}_p = \\mathbf{A}^{-1}$。\n8.  将拟合参数转换为物理参数：$\\hat{a} = -1/\\hat{c}_0$ 和 $\\hat{r}_e = 2\\hat{c}_1$。\n9.  使用 $\\mathbf{C}_p$ 的元素传播不确定性，以找到 $\\sigma_a$、$\\sigma_{r_e}$ 和相关系数 $\\rho$。\n10. 存储结果元组 $(\\hat{a}, \\hat{r}_e, \\sigma_a, \\sigma_{r_e}, \\rho)$ 以供最终输出。\n此过程将对问题陈述中提供的所有四个测试用例重复执行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for scattering length and effective range from synthetic phase-shift data\n    using a weighted least-squares fit on the linearized effective range expansion.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"a_true\": 5.0,\n            \"r_e_true\": 1.8,\n            \"k_values\": np.array([0.05, 0.075, 0.10, 0.125, 0.15, 0.175, 0.20, 0.225, 0.25, 0.275, 0.30]),\n            \"sigma_delta\": 0.01,\n            \"seed\": 42,\n        },\n        {\n            \"a_true\": 100.0,\n            \"r_e_true\": 2.0,\n            \"k_values\": np.array([0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.10, 0.11, 0.12]),\n            \"sigma_delta\": 0.005,\n            \"seed\": 123,\n        },\n        {\n            \"a_true\": 5.0,\n            \"r_e_true\": 1.8,\n            \"k_values\": np.array([0.005, 0.008, 0.011, 0.014, 0.017, 0.020]),\n            \"sigma_delta\": 0.005,\n            \"seed\": 2021,\n        },\n        {\n            \"a_true\": -20.0,\n            \"r_e_true\": 2.7,\n            \"k_values\": np.array([0.05, 0.075, 0.10, 0.125, 0.15, 0.175, 0.20, 0.225, 0.25, 0.275, 0.30, 0.325, 0.35, 0.375, 0.40, 0.425, 0.45, 0.475, 0.50]),\n            \"sigma_delta\": 0.02,\n            \"seed\": 7,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        a_true = case[\"a_true\"]\n        r_e_true = case[\"r_e_true\"]\n        k_values = case[\"k_values\"]\n        sigma_delta = case[\"sigma_delta\"]\n        seed = case[\"seed\"]\n\n        # Set random seed for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # 1. Generate synthetic data\n        # Theoretical k*cot(delta)\n        k_cot_delta_true = -1.0 / a_true + 0.5 * r_e_true * k_values**2\n        # Noiseless phase shifts\n        delta_true = np.arctan(k_values / k_cot_delta_true)\n        # Add Gaussian noise to create measured phase shifts\n        noise = rng.normal(0.0, sigma_delta, size=k_values.shape)\n        delta_meas = delta_true + noise\n\n        # 2. Linearize the model for WLS\n        # The model is y = c0 + c1*x, where y = k*cot(delta), x = k^2\n        x = k_values**2\n        cot_delta_meas = 1.0 / np.tan(delta_meas)\n        y = k_values * cot_delta_meas\n\n        # 3. Calculate weights for WLS\n        # sigma_y^2 = (d(k*cot(delta))/d(delta))^2 * sigma_delta^2\n        # d(k*cot(delta))/d(delta) = -k * csc^2(delta) = -k * (1 + cot^2(delta))\n        # We use the measured delta to estimate this.\n        sigma_y_sq = (k_values * (1 + cot_delta_meas**2))**2 * sigma_delta**2\n        weights = 1.0 / sigma_y_sq\n\n        # 4. Perform Weighted Least Squares fit\n        # We solve the normal equations: (X^T W X) p = X^T W y\n        # where p = [c0, c1]^T\n        \n        # Construct the design matrix X\n        X = np.vstack([np.ones_like(x), x]).T\n        \n        # Construct the diagonal weight matrix W\n        W = np.diag(weights)\n\n        # Form the matrices for the normal equations\n        XT_W_X = X.T @ W @ X\n        XT_W_y = X.T @ W @ y\n\n        # Solve for the parameter vector p_hat = [c0, c1]\n        try:\n            p_hat = np.linalg.solve(XT_W_X, XT_W_y)\n        except np.linalg.LinAlgError:\n            # Handle singular matrix case if it ever occurs\n            results.append([np.nan, np.nan, np.nan, np.nan, np.nan])\n            continue\n            \n        c0_fit, c1_fit = p_hat\n\n        # 5. Calculate physical parameters\n        a_fit = -1.0 / c0_fit\n        r_e_fit = 2.0 * c1_fit\n\n        # 6. Quantify uncertainties\n        # Covariance matrix of the fitted parameters p_hat is (X^T W X)^-1\n        cov_p = np.linalg.inv(XT_W_X)\n        sigma_c0_sq, sigma_c1_sq = cov_p[0, 0], cov_p[1, 1]\n        cov_c0_c1 = cov_p[0, 1]\n\n        # Propagate uncertainties to a and r_e\n        # sigma_a^2 = (da/dc0)^2 * sigma_c0^2 = (1/c0^2)^2 * sigma_c0^2 = a^4 * sigma_c0^2\n        sigma_a = np.abs(a_fit**2) * np.sqrt(sigma_c0_sq)\n        \n        # sigma_re^2 = (dre/dc1)^2 * sigma_c1^2 = 2^2 * sigma_c1^2\n        sigma_r_e = 2.0 * np.sqrt(sigma_c1_sq)\n\n        # Correlation coefficient rho(a, r_e) = rho(c0, c1)\n        rho = cov_c0_c1 / np.sqrt(sigma_c0_sq * sigma_c1_sq)\n\n        results.append([a_fit, r_e_fit, sigma_a, sigma_r_e, rho])\n\n    # Final print statement in the exact required format.\n    # The format required is a Python list literal string representation.\n    print(results)\n\nsolve()\n```", "id": "3589013"}, {"introduction": "在现实的核散射问题中，例如质子-质子散射，带电粒子间的长程库仑力不可忽略，它显著改变了散射行为。本练习在前一个实践的基础上，将探讨如何修正有效程展开理论以精确描述库仑力与短程核力的共同作用。您将亲手实现库仑修正的有效程展开，并以此为工具比较质子-质子与中子-质子散射的差异，从而深入理解电磁相互作用对核散射现象的影响。[@problem_id:3588976]", "problem": "您需要推导、实现并验证一个用于低能核子-核子散射中库仑修正有效力程展开的计算程序。重点是包含和不包含库仑相互作用的 $S$ 波 ($l=0$) 散射。从非相对论性薛定谔方程出发，该方程包含一个短程核势 $V_N(r)$，对于带电粒子，还包含一个库仑势 $V_C(r)=\\alpha Z_1 Z_2 / r$，其中 $\\alpha$ 是精细结构常数，$Z_1,Z_2$ 是以质子电荷为单位的电荷量。使用分波散射理论和 $S$ 矩阵在阈值附近的解析行为，构建一个在足够低的能量下与 $k^2$ 呈线性关系的有效力程函数。对于中性粒子散射，这就是通常的有效力程展开。对于带电粒子，核相移是相对于库仑畸变波定义的，并且有效力程函数必须通过明确定义的库仑函数进行修正。\n\n您的任务是：\n- 从散射相移的基本定义和 $S$ 矩阵在阈值附近的解析结构出发，推导出 $S$ 波的库仑修正有效力程展开，并指明修正中出现的特定库仑函数。仔细定义索末菲参数 $\\eta$ 和库仑穿透因子，并陈述必须从 $k\\cot\\delta_0^C$ 中分离出短程物理所需操作的函数形式。\n- 实现一个程序，该程序：\n  1. 使用推导出的领头阶库仑修正有效力程展开，为质子-质子 ($pp$) 散射构建合成的 $S$ 波相移 $\\delta_0^C(k)$。使用物理上一致的约化质量和一组指定的质心能量，以生成科学上可信的 $\\delta_0^C(k)$ 值。\n  2. 通过构建库仑修正的有效力程函数并对 $k^2$ 进行线性回归，从合成的 $\\delta_0^C(k)$ 中拟合出库仑修正的散射长度 $a_C$ 和有效力程 $r_C$。\n  3. 使用中性粒子的领头阶有效力程展开，为中子-质子 ($np$) 散射构建合成的 $S$ 波相移 $\\delta_0(k)$，并以相同的方式拟合散射长度 $a$ 和有效力程 $r$。\n  4. 通过计算差值 $a_C-a$ 和 $r_C-r$，比较 $pp$ 散射拟合出的 $(a_C,r_C)$ 和 $np$ 散射拟合出的 $(a,r)$。\n\n实现所需的定义和单位：\n- 设 $E_{\\mathrm{cm}}$ 是质心能量，单位为 $\\mathrm{MeV}$。波数为 $k=\\sqrt{2\\mu E_{\\mathrm{cm}}}/(\\hbar c)$，单位为 $\\mathrm{fm}^{-1}$，其中 $\\mu$ 是约化质量，单位为 $\\mathrm{MeV}$，$\\hbar c$ 是约化普朗克常数与光速的乘积，单位为 $\\mathrm{MeV\\,fm}$。使用 $m_p c^2=938.2720813\\,\\mathrm{MeV}$，$m_n c^2=939.5654133\\,\\mathrm{MeV}$，$\\mu_{pp}=m_p/2$ 和 $\\mu_{np}=m_p m_n/(m_p+m_n)$。\n- 对于 $pp$ 散射，索末菲参数为 $\\eta=\\alpha \\mu /(\\hbar c\\,k)$，其中 $\\alpha=1/137.035999084$。\n- 所有相移 $\\delta$ 的角度单位为弧度。\n- 输出的散射长度和有效力程必须以飞米 ($\\mathrm{fm}$) 表示。\n\n测试套件规范：\n- 案例1（正常路径，$pp$ 带库仑相互作用）：$E_{\\mathrm{cm}}$ 值为 $[0.25,0.5,1.0,2.0]$ $\\mathrm{MeV}$。使用基准的库仑修正参数 $a_C^{\\mathrm{true}}=-7.82\\,\\mathrm{fm}$ 和 $r_C^{\\mathrm{true}}=2.79\\,\\mathrm{fm}$ 来生成 $\\delta_0^C(k)$。\n- 案例2（近阈值稳定性，$pp$ 带库仑相互作用）：$E_{\\mathrm{cm}}$ 值为 $[0.05,0.10,0.20]$ $\\mathrm{MeV}$，使用相同的 $a_C^{\\mathrm{true}}$ 和 $r_C^{\\mathrm{true}}$。\n- 案例3（中性粒子比较，$np$ 不带库仑相互作用）：$E_{\\mathrm{cm}}$ 值为 $[0.25,0.5,1.0,2.0]$ $\\mathrm{MeV}$。使用基准的中性粒子参数 $a^{\\mathrm{true}}=-23.75\\,\\mathrm{fm}$ 和 $r^{\\mathrm{true}}=2.70\\,\\mathrm{fm}$ 来生成 $\\delta_0(k)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n- 案例1拟合的 $a_C$ 和 $r_C$，\n- 案例2拟合的 $a_C$ 和 $r_C$，\n- 案例3拟合的 $a$ 和 $r$，\n- 比较案例1 ($pp$) 与案例3 ($np$) 的差值 $a_C-a$ 和 $r_C-r$。\n\n因此，输出格式应严格为：\n\"[$a_C^{(1)},r_C^{(1)},a_C^{(2)},r_C^{(2)},a^{(3)},r^{(3)},a_C^{(1)}-a^{(3)},r_C^{(1)}-r^{(3)}]\"\n\n所有八个数字都必须是浮点数，且 $a_C$、$r_C$、$a$、$r$ 及其差值都必须以 $\\mathrm{fm}$ 为单位。", "solution": "该问题要求推导并实现用于 $S$ 波 ($l=0$) 核子-核子散射的有效力程展开 (ERE)，包括中性粒子 ($np$) 和带电粒子 ($pp$) 的情况。解决方案在逻辑上分为两部分：首先，对必要公式进行理论推导；其次，描述实现该理论的计算过程。\n\n**第一部分：有效力程展开的理论推导**\n\n有效力程展开是低能弹性散射截面的一种模型无关的参数化表示。它将散射相移与表征相互作用势的基本长度尺度——散射长度和有效力程——联系起来。其推导依赖于散射振幅在零能阈值 ($k \\to 0$) 附近的解析性质。\n\n**1.A. 中性粒子散射 (例如 $np$)**\n\n对于两个通过短程核势 $V_N(r)$ 相互作用的中性粒子的散射，其约化质量粒子的 $S$ 波 ($l=0$) 径向薛定谔方程为：\n$$\n\\frac{d^2u_0(r)}{dr^2} + \\left(k^2 - U_N(r)\\right)u_0(r) = 0\n$$\n其中 $u_0(r)$ 是径向波函数，$k^2 = 2\\mu E_{\\mathrm{cm}}/\\hbar^2$ 是质心波数的平方，$E_{\\mathrm{cm}}$ 是质心能量，$\\mu$ 是约化质量，$U_N(r) = 2\\mu V_N(r)/\\hbar^2$ 是约化势。边界条件为 $u_0(0)=0$。\n\n对于一个有限力程为 $R$ 的势（即当 $r  R$ 时 $V_N(r)=0$），在势作用区域外的波函数具有以下形式：\n$$\nu_0(r) \\propto \\sin(kr + \\delta_0(k)), \\quad r  R\n$$\n其中 $\\delta_0(k)$ 是 $S$ 波核相移。关于散射过程的信息完全包含在 $\\delta_0(k)$ 中。\n\n由 Schwinger 和 Bethe 发展的有效力程理论指出，对于短程势，函数 $k \\cot\\delta_0(k)$ 在低能下是 $k^2$ 的解析函数。因此，它可以在 $k^2=0$ 附近展开为泰勒级数：\n$$\nk \\cot\\delta_0(k) = -\\frac{1}{a} + \\frac{1}{2} r k^2 + O(k^4)\n$$\n这就是标准的**有效力程展开**。参数 $a$ 和 $r$ 分别是散射长度和有效力程。\n- **散射长度 $a$** 定义为零能极限：$a = -\\lim_{k\\to 0} \\frac{\\tan\\delta_0(k)}{k}$。它表征了在能量趋于零时相互作用的强度。\n- **有效力程 $r$** 表征了散射的能量依赖性，并与势的空间范围有关。\n\n**1.B. 带电粒子散射 (例如 $pp$)**\n\n当散射粒子带电时，例如在质子-质子 ($pp$) 散射中，必须包含长程库仑势 $V_C(r) = \\alpha \\hbar c Z_1 Z_2 / r$。对于 $pp$ 散射，$Z_1=Z_2=1$。$S$ 波径向薛定谔方程变为：\n$$\n\\frac{d^2u_0^C(r)}{dr^2} + \\left(k^2 - \\frac{2\\eta k}{r} - U_N(r)\\right)u_0^C(r) = 0\n$$\n这里，我们引入了无量纲的**索末菲参数 $\\eta$**，它量化了库仑相互作用相对于动能的强度：\n$$\n\\eta = \\frac{\\alpha \\mu c^2}{\\hbar c k}\n$$\n其中 $\\alpha$ 是精细结构常数。\n\n库仑势的长程性质 ($1/r$) 从根本上改变了波函数的渐进行为。简单的形式 $\\sin(kr + \\delta_0)$ 不再适用。取而代之的是，在 $V_N(r)$ 的力程之外的解必须表示为正则 ($F_0$) 和非正则 ($G_0$) $S$ 波库仑函数的线性组合：\n$$\nu_0^C(r) \\propto \\cos\\delta_0^C F_0(\\eta, kr) + \\sin\\delta_0^C G_0(\\eta, kr)\n$$\n相移 $\\delta_0^C$ 是相对于纯库仑散射波测量的核相移。\n\n由于库仑相互作用，函数 $k \\cot\\delta_0^C$ 在 $k^2=0$ 处不解析。它包含了与长程尾部相关的奇点。然而，可以构造一个在 $k^2$ 中解析的修正函数。这个由 Jackson 和 Blatt 得出的结果就是**库仑修正的有效力程展开**：\n$$\nC_0^2(\\eta) k \\cot\\delta_0^C + 2k\\eta h(\\eta) = -\\frac{1}{a_C} + \\frac{1}{2} r_C k^2 + O(k^4)\n$$\n新的量是库仑穿透因子 $C_0^2(\\eta)$ 和库仑函数 $h(\\eta)$。$a_C$ 和 $r_C$ 是库仑修正的散射长度和有效力程。\n\n此展开所需的函数是：\n- **$l=0$ 的库仑穿透因子** $C_0^2(\\eta)$，解释了排斥性库仑势垒对原点处波函数的抑制作用。它由下式给出：\n  $$\n  C_0^2(\\eta) = \\frac{2\\pi\\eta}{e^{2\\pi\\eta} - 1}\n  $$\n- 函数 $h(\\eta)$ 的定义是为了抵消由库仑相互作用引起的剩余非解析项。它由下式给出：\n  $$\n  h(\\eta) = \\mathrm{Re}\\left[\\psi(i\\eta)\\right] - \\ln\\eta\n  $$\n  其中 $\\psi(z) = \\frac{d}{dz}\\ln\\Gamma(z)$ 是双伽玛函数。\n\n问题要求指出必须从 $k\\cot\\delta_0^C$ 中分离出短程物理所需操作的函数形式。该公式不是一个简单的减法。项 $k\\cot\\delta_0^C$ 首先乘以 $C_0^2(\\eta)$，然后加上函数 $2k\\eta h(\\eta)$。这种组合分离出了短程物理，产生一个在低能下近似与 $k^2$ 呈线性的函数：\n$$\nf(k^2) = C_0^2(\\eta) k \\cot\\delta_0^C + 2k\\eta h(\\eta)\n$$\n\n**第二部分：计算过程**\n\n实现过程包括两个主要步骤：(1) 使用 ERE 公式和给定的“真实”参数生成合成相移数据；(2) 从合成数据中反向拟合这些参数，以验证该过程的正确性。\n\n**2.A. 数据生成**\n对于一组给定的质心能量 $E_{\\mathrm{cm},i}$，我们首先计算相应的波数 $k_i = \\sqrt{2\\mu E_{\\mathrm{cm},i}} / (\\hbar c)$。然后，使用提供的真实参数 ($a^{\\mathrm{true}}, r^{\\mathrm{true}}$)，我们生成相移 $\\delta_{0,i}$。\n\n- **对于中性粒子散射 ($np$)**：\n  1. 计算 ERE 函数的值：$Y_i = -1/a^{\\mathrm{true}} + \\frac{1}{2}r^{\\mathrm{true}} k_i^2$。\n  2. 根据定义 $Y_i = k_i \\cot\\delta_{0,i}$，解出相移：$\\delta_{0,i} = \\mathrm{arccot}(Y_i / k_i)$。\n\n- **对于带电粒子散射 ($pp$)**：\n  1. 对于每个 $k_i$，计算相应的索末菲参数 $\\eta_i = \\alpha \\mu_{pp} / (\\hbar c k_i)$。\n  2. 计算库仑函数 $C_0^2(\\eta_i)$ 和 $h(\\eta_i)$ 的值。\n  3. 计算库仑修正的 ERE 函数的值：$Y_i = -1/a_C^{\\mathrm{true}} + \\frac{1}{2}r_C^{\\mathrm{true}} k_i^2$。\n  4. 根据定义 $Y_i = C_0^2(\\eta_i) k_i \\cot\\delta_{0,i}^C + 2k_i\\eta_i h(\\eta_i)$，解出相移：\n     $$\n     \\cot\\delta_{0,i}^C = \\frac{Y_i - 2k_i\\eta_i h(\\eta_i)}{C_0^2(\\eta_i) k_i}\n     $$\n     因此，$\\delta_{0,i}^C = \\mathrm{arccot}\\left(\\frac{Y_i - 2k_i\\eta_i h(\\eta_i)}{C_0^2(\\eta_i) k_i}\\right)$。\n\n在数值计算上，$\\mathrm{arccot}(x)$ 可以稳健地计算为 $\\arctan(1/x)$，或者更好的方法是使用像 `numpy.arctan2` 这样的双参数反正切函数来正确处理不同的象限和符号。\n\n**2.B. 参数拟合**\n利用合成数据集 $\\{ (k_i, \\delta_{0,i}) \\}$ 和 $\\{ (k_i, \\delta_{0,i}^C) \\}$，我们可以执行线性回归来提取散射参数。模型为 $y = A + Bx$，其中 $x=k^2$，$A = -1/a$，$B = r/2$。\n\n- **对于中性粒子散射 ($np$)**：\n  1. 为拟合构建数据点：$(x_i, y_i) = (k_i^2, k_i \\cot\\delta_{0,i})$。\n  2. 对这些点进行线性拟合 $y = A + Bx$。确定斜率 $B$ 和截距 $A$。\n  3. 拟合参数为 $a_{\\mathrm{fit}} = -1/A$ 和 $r_{\\mathrm{fit}} = 2B$。\n\n- **对于带电粒子散射 ($pp$)**：\n  1. 为拟合构建数据点：$(x_i, y_i) = (k_i^2, C_0^2(\\eta_i) k_i \\cot\\delta_{0,i}^C + 2k_i\\eta_i h(\\eta_i))$。\n  2. 执行线性拟合 $y = A + Bx$。\n  3. 拟合参数为 $a_{C, \\mathrm{fit}} = -1/A$ 和 $r_{C, \\mathrm{fit}} = 2B$。\n\n这种生成数据并用相同模型进行拟合的过程，是验证理论公式的数值实现是否正确的一个关键测试。一个成功的实现应该能高精度地恢复输入的真实参数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import psi\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates the Coulomb-modified effective-range expansion\n    for low-energy nucleon-nucleon scattering.\n    \"\"\"\n\n    # Physical constants and definitions\n    m_p_c2 = 938.2720813  # MeV\n    m_n_c2 = 939.5654133  # MeV\n    hbar_c = 197.3269804  # MeV fm\n    alpha = 1.0 / 137.035999084\n\n    # Reduced masses in MeV\n    mu_pp = m_p_c2 / 2.0\n    mu_np = (m_p_c2 * m_n_c2) / (m_p_c2 + m_n_c2)\n\n    # Test suite specification\n    test_cases = [\n        {\n            \"name\": \"Case 1 (pp)\",\n            \"type\": \"pp\",\n            \"mu\": mu_pp,\n            \"E_cm_MeV\": np.array([0.25, 0.5, 1.0, 2.0]),\n            \"a_true\": -7.82,  # fm\n            \"r_true\": 2.79,   # fm\n        },\n        {\n            \"name\": \"Case 2 (pp)\",\n            \"type\": \"pp\",\n            \"mu\": mu_pp,\n            \"E_cm_MeV\": np.array([0.05, 0.10, 0.20]),\n            \"a_true\": -7.82,  # fm\n            \"r_true\": 2.79,   # fm\n        },\n        {\n            \"name\": \"Case 3 (np)\",\n            \"type\": \"np\",\n            \"mu\": mu_np,\n            \"E_cm_MeV\": np.array([0.25, 0.5, 1.0, 2.0]),\n            \"a_true\": -23.75,  # fm\n            \"r_true\": 2.70,   # fm\n        },\n    ]\n\n    results = {}\n\n    for case in test_cases:\n        E_cm = case[\"E_cm_MeV\"]\n        mu = case[\"mu\"]\n        a_true = case[\"a_true\"]\n        r_true = case[\"r_true\"]\n        case_type = case[\"type\"]\n        case_name = case[\"name\"]\n\n        # Calculate wave number k in fm^-1\n        k = np.sqrt(2.0 * mu * E_cm) / hbar_c\n\n        # --- 1. Generate synthetic phase shifts ---\n        delta = None\n        if case_type == \"np\":\n            # Neutral particle ERE: k * cot(delta) = -1/a + 0.5 * r * k^2\n            Y_true = -1.0 / a_true + 0.5 * r_true * k**2\n            # delta = arccot(Y_true / k)\n            delta = np.arctan2(k, Y_true)\n        \n        elif case_type == \"pp\":\n            # Coulomb-modified ERE\n            eta = alpha * mu / (hbar_c * k)\n            \n            # C_0^2(eta) = 2*pi*eta / (exp(2*pi*eta) - 1)\n            C0_squared = 2.0 * np.pi * eta / np.expm1(2.0 * np.pi * eta)\n            \n            # h(eta) = Re[psi(i*eta)] - ln(eta)\n            h_eta = np.real(psi(1j * eta)) - np.log(eta)\n            \n            # Y_true = -1/a_C + 0.5 * r_C * k^2\n            Y_true = -1.0 / a_true + 0.5 * r_true * k**2\n            \n            # Y_true = C0_squared * k * cot(delta) + 2*k*eta*h(eta)\n            # -- cot(delta) = (Y_true - 2*k*eta*h(eta)) / (C0_squared * k)\n            cot_delta_numerator = Y_true - 2.0 * k * eta * h_eta\n            cot_delta_denominator = C0_squared * k\n            delta = np.arctan2(cot_delta_denominator, cot_delta_numerator)\n\n        # --- 2. Fit parameters from synthetic data ---\n        \n        # Construct the linear system y = A + B*x for fitting\n        # x = k^2, y = ERE function\n        x_fit = k**2\n        y_fit = None\n        \n        if case_type == \"np\":\n            y_fit = k * (1.0 / np.tan(delta))\n        \n        elif case_type == \"pp\":\n            eta = alpha * mu / (hbar_c * k)\n            C0_squared = 2.0 * np.pi * eta / np.expm1(2.0 * np.pi * eta)\n            h_eta = np.real(psi(1j * eta)) - np.log(eta)\n            y_fit = C0_squared * k * (1.0 / np.tan(delta)) + 2.0 * k * eta * h_eta\n            \n        # Perform linear regression: y_fit = slope * x_fit + intercept\n        # slope = B = r/2, intercept = A = -1/a\n        # np.polyfit returns [slope, intercept]\n        p = np.polyfit(x_fit, y_fit, 1)\n        slope, intercept = p[0], p[1]\n        \n        a_fit = -1.0 / intercept\n        r_fit = 2.0 * slope\n        \n        results[case_name] = (a_fit, r_fit)\n\n    # --- 3. Compile final output list ---\n    aC1, rC1 = results[\"Case 1 (pp)\"]\n    aC2, rC2 = results[\"Case 2 (pp)\"]\n    a3, r3 = results[\"Case 3 (np)\"]\n\n    diff_a = aC1 - a3\n    diff_r = rC1 - r3\n    \n    final_output = [aC1, rC1, aC2, rC2, a3, r3, diff_a, diff_r]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_output))}]\")\n\nsolve()\n```", "id": "3588976"}, {"introduction": "除了从实验数据中提取参数，另一个核心任务是从给定的相互作用势出发，第一性地计算散射观测量。本练习将带您进入动量空间，使用散射理论的积分方程形式——Lippmann-Schwinger方程来解决散射问题。通过求解一个可分离势的Lippmann-Schwinger方程，您将学习如何直接从核力模型计算相移，并在此过程中掌握处理主值积分和无限区间数值积分等关键的计算物理技巧。[@problem_id:3589031]", "problem": "考虑在动量空间中，无自旋粒子在球对称短程相互作用下的非相对论双体弹性散射。含有中心势的非相对论不含时薛定谔方程是基本出发点。通过投影到分波上并使用自由预解式（能量格林函数），可以得到分波跃迁矩阵的动量空间Lippmann-Schwinger方程，在当前的归一化下其形式为\n$$\nt_l(p',p;E)= v_l(p',p) + \\int_0^\\infty dq\\, q^2\\, \\frac{v_l(p',q)\\, t_l(q,p;E)}{E - \\hbar^2 q^2/(2\\mu) + i0},\n$$\n其中，$l$ 是轨道角动量，$p$ 和 $p'$ 分别是入射和出射动量的大小，$E$ 是质心系能量，$\\mu$ 是约化质量，$\\hbar$ 是约化普朗克常数。项 $+i0$ 表示选择出射波边界条件的极限过程。\n\n你的任务是，在无量纲单位下，对使用可分离Yamaguchi型势的 $l=0$（s波）情况，推导、离散化并实现一个求解器，并计算s波相移。你必须从第一性原理和定义（薛定谔方程和Lippmann-Schwinger方程）出发，不使用快捷公式，并采用带有理性的红外-紫外映射的Gauss-Legendre求积法来设计离散化方案。该离散化方案必须得到精确的描述和实现。\n\n为确保普遍适用性和数学上的清晰性，请采用以下无量纲设定：\n- 令 $\\hbar^2/(2\\mu)=1$，使得能量和动量的平方具有相同的单位。\n- 使用可分离s波势\n$$\nv_0(p',p) = -\\lambda \\frac{1}{(p'^2+1)}\\frac{1}{(p^2+1)},\n$$\n其中 $\\lambda0$ 是一个无量纲耦合强度，通过定义无量纲动量 $p\\to p/\\beta$ 并选择 $\\beta$ 使分母为 $p^2+1$，从而将力程参数标度为1。\n\n在这些单位中，将在壳动量 $k$ 定义为 $k=\\sqrt{E}$。为避免能量分母在 $q=k$ 处引入的奇点，你必须通过将预解式替换为其Cauchy主值来计算实主值$K$矩阵，\n$$\nK_0(p',p;E)= v_0(p',p) + \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{v_0(p',q)\\, K_0(q,p;E)}{E - q^2}.\n$$\n对于可分离势，s波在壳$K$矩阵可简化为该主值积分的一个标量有理函数。请从第一性原理出发展示此简化过程并加以实现。\n\n你必须为半无限积分设计一种求积法，该方法在有限区间上使用Gauss-Legendre求积（基于Legendre多项式的高斯求积），并通过一个有理映射同时处理红外（$q\\to 0$）和紫外（$q\\to\\infty$）区域。具体来说，通过以下方式将 $x\\in[-1,1]$ 映射到 $q\\in[0,\\infty)$：\n$$\nq(x) = \\alpha\\,\\frac{1+x}{1-x},\\quad \\frac{dq}{dx} = \\frac{2\\alpha}{(1-x)^2},\n$$\n其中 $\\alpha0$ 是一个无量纲标度，用于平衡红外和紫外区域的分辨率。使用在 $[-1,1]$ 上的Gauss-Legendre节点 $x_i$ 和权重 $w_i$，近似计算\n$$\n\\int_0^\\infty dq\\, F(q) \\approx \\sum_{i=1}^N w_i\\,F(q(x_i))\\,\\frac{dq}{dx}\\Big|_{x=x_i}.\n$$\n为了在 $q=k$ 处执行主值计算，使用一种减法来显式地移除奇点：\n$$\n\\operatorname{P}\\!\\int_0^\\infty dq\\, \\frac{f(q)}{k^2 - q^2} = \\int_0^\\infty dq\\, \\frac{f(q)-f(k)}{k^2 - q^2},\n$$\n如果 $f$ 是光滑的，那么这个表达式是有限的且数值上表现良好。在当前问题中，令 $f(q)=q^2\\,g^2(q)$，其中 $g(q)=(q^2+1)^{-1}$。\n\n根据基本散射理论，通过匹配所选归一化下实势的渐近边界条件，将s波相移 $\\delta_0(E)$ 与在壳实$K$矩阵联系起来。在指定的无量纲单位中，相移由以下公式导出：\n$$\n\\delta_0(E) = \\arctan\\!\\big(-k\\,K_0(k,k;E)\\big),\n$$\n其中 $k=\\sqrt{E}$，角度以弧度为单位。\n\n实现一个完整、可运行的程序，该程序：\n- 为选定的 $N$ 构建Gauss-Legendre节点和权重。\n- 应用带有雅可比行列式的映射 $q(x)$ 来近似计算可分离s波$K$矩阵所需的主值积分。\n- 对每个测试用例，计算以弧度为单位的s波相移 $\\delta_0(E)$。\n\n物理和数值单位及输出：\n- 所有计算均在由 $\\hbar^2/(2\\mu)=1$ 定义的无量纲单位中执行，且力程参数被标度为1。\n- 角度必须以弧度表示。\n- 你的程序必须生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，例如 $[\\delta_1,\\delta_2,\\delta_3,\\delta_4]$。\n\n测试套件：\n使用以下测试用例集来评估实现的不同方面：\n- 用例1（近阈值，典型耦合）：$E=0.01$，$\\lambda=1.0$，$\\alpha=1.0$。\n- 用例2（中等能量，典型耦合）：$E=0.5$，$\\lambda=1.0$，$\\alpha=1.0$。\n- 用例3（较高能量，典型耦合）：$E=2.0$，$\\lambda=1.0$，$\\alpha=1.0$。\n- 用例4（弱耦合，中等能量）：$E=0.5$，$\\lambda=0.1$，$\\alpha=1.0$。\n\n算法和科学要求：\n- 从薛定谔方程和Lippmann-Schwinger积分方程作为基本基础开始；推导可分离简化和主值处理方法。\n- 使用带有指定映射的Gauss-Legendre求积法来近似半无限积分。\n- 通过你选择的 $N$（你可以选择任何合理的整数 $N\\ge 100$）来检查数值稳定性、光滑性和收敛行为，以确保科学上的真实性。\n- 最终输出必须是前面描述的精确格式的单行文本，包含四个以弧度为单位的浮点数相移。", "solution": "该问题要求在一个无量纲框架内，计算非相对论双体弹性散射的s波相移。这通过求解具有特定可分离势的动量空间Lippmann-Schwinger方程以获得反应矩阵（$K$矩阵）来完成。解决方案涉及将积分方程解析地简化为代数方程，然后使用带有坐标映射的Gauss-Legendre求积法对一个主值积分进行数值评估。\n\n出发点是分波$K$矩阵的Lippmann-Schwinger方程。在指定的无量纲单位中，$\\hbar^2/(2\\mu)=1$ 且能量 $E=k^2$（$k$ 为在壳动量），对于轨道角动量 $l=0$（s波），方程为：\n$$\nK_0(p',p;E)= v_0(p',p) + \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{v_0(p',q)\\, K_0(q,p;E)}{E - q^2}\n$$\n这里，$\\operatorname{P}$ 表示Cauchy主值，这对于处理 $q=\\sqrt{E}=k$ 处的奇点是必需的。势 $v_0(p',p)$ 是一个可分离的Yamaguchi型势，由下式给出：\n$$\nv_0(p',p) = -\\lambda g(p') g(p)\n$$\n其中 $\\lambda  0$ 是耦合强度，形函数 $g(p)$ 由 $g(p) = (p^2+1)^{-1}$ 给出。\n\n关键的简化来自于势的可分离性质。我们将 $v_0(p',p)$ 的形式代入 $K_0$ 的方程中：\n$$\nK_0(p',p;E) = -\\lambda g(p')g(p) + \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{[-\\lambda g(p')g(q)]\\, K_0(q,p;E)}{E - q^2}\n$$\n项 $g(p')$ 可以从积分中提出来：\n$$\nK_0(p',p;E) = -\\lambda g(p') \\left[ g(p) + \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{g(q) K_0(q,p;E)}{E - q^2} \\right]\n$$\n这个方程表明，$K_0(p',p;E)$ 对动量 $p'$ 的全部依赖性都是通过乘法因子 $g(p')$ 实现的。这为 $K_0$ 本身的结构提供了一个拟设：\n$$\nK_0(p',p;E) = g(p') C(p,E)\n$$\n其中 $C(p,E)$ 是一个未知函数。将此拟设代入Lippmann-Schwinger方程得到：\n$$\ng(p') C(p,E) = -\\lambda g(p')g(p) + \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{[-\\lambda g(p')g(q)]\\, [g(q)C(p,E)]}{E - q^2}\n$$\n项 $g(p')$ 和 $C(p,E)$ 可以分别从方程两边和积分中提出来。假设 $g(p') \\neq 0$，我们可以用它来除：\n$$\nC(p,E) = -\\lambda g(p) - \\lambda C(p,E) \\left[ \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{g(q)^2}{E - q^2} \\right]\n$$\n该积分表达式仅依赖于能量 $E$。我们将这个标量积分定义为：\n$$\nI(E) = \\operatorname{P}\\!\\int_0^\\infty dq\\, q^2\\, \\frac{g(q)^2}{E - q^2}\n$$\n$C(p,E)$ 的方程现在是一个简单的代数方程：\n$$\nC(p,E) = -\\lambda g(p) - \\lambda C(p,E) I(E)\n$$\n解出 $C(p,E)$：\n$$\nC(p,E) (1 + \\lambda I(E)) = -\\lambda g(p) \\implies C(p,E) = \\frac{-\\lambda g(p)}{1 + \\lambda I(E)}\n$$\n将此结果代回到我们对 $K_0$ 的拟设中，我们得到 $K$ 矩阵的闭式解：\n$$\nK_0(p',p;E) = \\frac{-\\lambda g(p')g(p)}{1 + \\lambda I(E)}\n$$\n因此，问题被简化为对主值积分 $I(E)$ 的数值评估。\n\n为了计算 $I(E)$，我们使用指定的减法。令 $k = \\sqrt{E}$ 并定义 $f(q) = q^2 g(q)^2 = q^2 / (q^2+1)^2$。该积分变为：\n$$\nI(E) = \\operatorname{P}\\!\\int_0^\\infty dq\\, \\frac{f(q)}{k^2 - q^2} = \\int_0^\\infty dq\\, \\frac{f(q) - f(k)}{k^2-q^2}\n$$\n新的被积函数，我们称之为 $F(q) = \\frac{f(q) - f(k)}{k^2-q^2}$，现在在 $q=k$ 处数值上表现良好。当 $q\\to k$ 时，该表达式的极限为 $f'(k)/(2k)$，从而避免了任何奇点。\n\n接下来，我们通过使用有理映射将半无限积分域 $[0, \\infty)$ 映射到有限区间 $[-1,1]$ 来处理它：\n$$\nq(x) = \\alpha\\,\\frac{1+x}{1-x}, \\quad \\text{其雅可比行列式为} \\quad \\frac{dq}{dx} = \\frac{2\\alpha}{(1-x)^2}\n$$\n积分 $I(E)$ 变换为：\n$$\nI(E) = \\int_{-1}^{1} F(q(x)) \\frac{dq}{dx} dx = \\int_{-1}^{1} \\frac{f(q(x)) - f(k)}{k^2 - q(x)^2} \\frac{2\\alpha}{(1-x)^2} dx\n$$\n这个定积分现在适合进行 $N$ 点Gauss-Legendre求积。使用区间 $[-1,1]$ 上的节点 $x_i$ 和权重 $w_i$，该积分可由以下求和近似：\n$$\nI(E) \\approx \\sum_{i=1}^N w_i \\left( \\frac{f(q(x_i)) - f(k)}{k^2 - q(x_i)^2} \\right) \\left( \\frac{2\\alpha}{(1-x_i)^2} \\right)\n$$\n其中 $q(x_i) = \\alpha(1+x_i)/(1-x_i)$。\n\n最后，我们将s波相移 $\\delta_0(E)$ 与在壳$K$矩阵联系起来。在壳$K$矩阵在 $p=p'=k=\\sqrt{E}$ 处求值：\n$$\nK_0(k,k;E) = \\frac{-\\lambda g(k)^2}{1 + \\lambda I(E)}\n$$\n问题在给定的归一化下提供了在壳$K$矩阵和相移之间的关系：\n$$\n\\delta_0(E) = \\arctan(-k K_0(k,k;E))\n$$\n代入我们对 $K_0(k,k;E)$ 的表达式：\n$$\n\\delta_0(E) = \\arctan\\left(-k \\left[ \\frac{-\\lambda g(k)^2}{1 + \\lambda I(E)} \\right]\\right) = \\arctan\\left(\\frac{k \\lambda g(k)^2}{1 + \\lambda I(E)}\\right)\n$$\n其中 $g(k) = (k^2+1)^{-1} = (E+1)^{-1}$。这个表达式现在是完全确定的，可以进行数值实现。\n\n对于每个测试用例 $(E, \\lambda, \\alpha)$，算法如下：\n1.  设置 $k=\\sqrt{E}$ 并选择一个足够大的求积点数 $N$（例如，$N=128$）。\n2.  在 $[-1,1]$ 上生成 $N$ 个Gauss-Legendre节点 $x_i$ 和权重 $w_i$。\n3.  计算 $f(k) = k^2/(k^2+1)^2$ 的值。\n4.  对于每个节点 $x_i$，计算相应的动量点 $q_i=q(x_i)$、函数值 $f(q_i)$ 和雅可比行列式 $dq/dx|_{x_i}$。\n5.  评估求和以近似 $I(E)$。\n6.  使用计算出的 $I(E)$ 值，根据最终推导的公式计算以弧度为单位的 $\\delta_0(E)$。\n此过程系统地实现了基于散射理论原理的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# The following import for Gauss-Legendre quadrature is standard and necessary.\n# numpy.polynomial.legendre.leggauss is the canonical source for this in numpy.\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Solves the Lippmann-Schwinger equation for the s-wave K-matrix with a\n    separable potential and computes the phase shift.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (E, lambda, alpha)\n        (0.01, 1.0, 1.0),  # Case 1\n        (0.5, 1.0, 1.0),   # Case 2\n        (2.0, 1.0, 1.0),   # Case 3\n        (0.5, 0.1, 1.0),   # Case 4\n    ]\n\n    # Set the number of quadrature points as required (N = 100).\n    # A choice of N=128 is a power of 2, often good for numerical algorithms,\n    # and safely above the minimum requirement.\n    N = 128\n\n    results = []\n    \n    # Generate Gauss-Legendre nodes and weights for the interval [-1, 1]\n    x_nodes, w_weights = leggauss(N)\n\n    for E, lam, alpha in test_cases:\n        # On-shell momentum k\n        k = np.sqrt(E)\n\n        # Define the form factor g(p) and the function f(p) = p^2 * g(p)^2\n        def g(p):\n            return 1.0 / (p**2 + 1.0)\n\n        def f(p):\n            return p**2 / (p**2 + 1.0)**2\n\n        # Value of f at the on-shell momentum k for the subtraction method\n        f_k = f(k)\n\n        # --- Numerical Integration for I(E) ---\n        # 1. Map Gauss-Legendre nodes x_i in [-1, 1] to momentum points q_i in [0, inf)\n        # The mapping is q(x) = alpha * (1 + x) / (1 - x)\n        q_nodes = alpha * (1.0 + x_nodes) / (1.0 - x_nodes)\n        \n        # 2. Calculate the Jacobian of the transformation\n        # dq/dx = 2 * alpha / (1 - x)^2\n        jacobian = 2.0 * alpha / (1.0 - x_nodes)**2\n        \n        # 3. Evaluate the integrand for the principal value integral\n        # The integrand is (f(q) - f(k)) / (k^2 - q^2)\n        # which is numerically stable due to the subtraction.\n        f_q_nodes = f(q_nodes)\n        \n        # We must handle the case where a quadrature node q_i might numerically\n        # equal k. While unlikely, it can lead to 0/0 - NaN.\n        # The limit of the integrand as q-k is f'(k)/(2k).\n        # f'(p) = (2p * (1 - p^2)) / (p^2 + 1)^3\n        # limit_val = f'(k) / (2k) = (1 - k^2) / (k^2 + 1)^3\n        # However, numpy's float arithmetic typically handles this subtraction\n        # correctly without explicit NaN, so direct evaluation is robust enough.\n        pv_integrand_values = (f_q_nodes - f_k) / (k**2 - q_nodes**2)\n        \n        # 4. Compute the integral I(E) by summing over the quadrature points\n        I_E = np.sum(w_weights * pv_integrand_values * jacobian)\n        \n        # --- Phase Shift Calculation ---\n        # Calculate the on-shell K-matrix K_0(k,k;E)\n        # K_0(k,k;E) = -lambda * g(k)^2 / (1 + lambda * I(E))\n        g_k_squared = g(k)**2\n        K_on_shell = (-lam * g_k_squared) / (1.0 + lam * I_E)\n        \n        # Calculate the s-wave phase shift delta_0(E) in radians\n        # delta_0(E) = arctan(-k * K_0(k,k;E))\n        delta_0 = np.arctan(-k * K_on_shell)\n        \n        results.append(delta_0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.8f}' for res in results)}]\")\n\nsolve()\n```", "id": "3589031"}]}