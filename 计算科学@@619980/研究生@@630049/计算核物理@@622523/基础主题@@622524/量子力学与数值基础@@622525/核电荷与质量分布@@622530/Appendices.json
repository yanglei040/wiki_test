{"hands_on_practices": [{"introduction": "费米（或伍兹-撒克逊）分布是描述重原子核径向密度的标准唯象模型。本练习的核心任务是核物理学中的一项基本工作：通过将模型参数（如半密度半径 $c$ 和表面弥散度 $a$）与已知的宏观性质（如均方根半径和表面厚度）进行拟合来确定它们。这项实践将帮助你建立在数值积分和求根方面的基本技能，从而将理论模型与实验数据联系起来 [@problem_id:3574012]。", "problem": "给定一个用于重核（此处为 $^{208}\\mathrm{Pb}$）的球对称双参数费米（也称伍兹-撒克逊）密度模型。质量密度模型为 $\\rho(r) = \\dfrac{\\rho_0}{1 + \\exp\\!\\left( \\dfrac{r - c}{a} \\right)}$，其中 $r$ 是径向坐标（单位：飞米），$c$ 是半密度半径（单位：飞米），$a$ 是弥散度（单位：飞米），$\\rho_0$ 是中心密度标度（单位：逆立方飞米）。参数 $c$ 和 $a$ 需要在以下具有物理动机的约束条件下确定：归一化到核子数 $A = 208$ 和给定的均方根半径，以及由费米函数的 10%–90% 表面厚度定义的弥散度约束。\n\n从以下基本依据和核心定义出发：\n\n- 球对称性意味着总核子数 $A$ 由归一化条件给出 $A = \\displaystyle \\int_{\\mathbb{R}^3} \\rho(\\mathbf{r})\\, d^3\\mathbf{r} = 4\\pi \\displaystyle \\int_{0}^{\\infty} r^2 \\rho(r)\\, dr$。\n\n- 均方根（RMS）半径定义为 $\\sqrt{\\langle r^2 \\rangle} = \\left( \\dfrac{ \\displaystyle \\int_{\\mathbb{R}^3} r^2 \\rho(\\mathbf{r})\\, d^3\\mathbf{r} }{ \\displaystyle \\int_{\\mathbb{R}^3} \\rho(\\mathbf{r})\\, d^3\\mathbf{r} } \\right)^{1/2} = \\left( \\dfrac{ \\displaystyle 4\\pi \\int_{0}^{\\infty} r^4 \\rho(r)\\, dr }{ \\displaystyle 4\\pi \\int_{0}^{\\infty} r^2 \\rho(r)\\, dr } \\right)^{1/2}$。\n\n- 弥散度约束定义如下：设 $r_{0.9}$ 和 $r_{0.1}$ 分别为费米函数 $\\rho(r)$ 的密度等于 $0.9\\,\\rho_0$ 和 $0.1\\,\\rho_0$ 时的半径。表面厚度 $t$ 定义为 $t = r_{0.1} - r_{0.9}$。通过求解所得到的方程来强制执行此约束，以确定 $a$ 与 $t$ 的关系。\n\n您的任务是编写一个完整的、可运行的程序，该程序：\n\n1. 在 $r \\in [0,\\infty)$ 上实现数值积分，以评估费米模型的归一化积分和二阶矩积分。使用这些积分计算给定 $(c,a)$ 的 RMS 半径 $\\sqrt{\\langle r^2 \\rangle}$，并确保所有积分都以足够的数值精度进行评估。\n\n2. 使用弥散度约束，通过求解由 $r_{0.9}$ 和 $r_{0.1}$ 的费米函数定义所蕴含的方程，从给定的表面厚度 $t$ 计算参数 $a$。\n\n3. 确定参数 $c$（对于已计算出的 $a$），使得计算出的 RMS 半径等于一个指定的目标值。这必须通过使用一个稳健的求根方法求解 $c$ 来完成，该方法依赖于在固定 $a$ 的情况下 $\\sqrt{\\langle r^2 \\rangle}$ 对 $c$ 的单调依赖关系。\n\n4. 通过数值计算 $\\rho_0$ 来确保密度被正确归一化到 $A = 208$，即 $4\\pi \\int_{0}^{\\infty} r^2 \\rho(r)\\, dr = 208$。尽管费米模型的 RMS 半径消除了对 $\\rho_0$ 的依赖性，但您仍必须计算 $\\rho_0$ 以证明正确的归一化。\n\n5. 为包含三种情况的测试套件生成输出。在每种情况下，返回以飞米为单位的数对 $(c,a)$，四舍五入到六位小数。$c$ 和 $a$ 的单位必须是飞米 (fm)。\n\n使用以下测试套件：\n\n- 案例 1（正常路径）：目标 RMS 半径 $\\sqrt{\\langle r^2 \\rangle} = 5.5 \\text{ fm}$，表面厚度 $t = 2.4 \\text{ fm}$。\n- 案例 2（薄表面）：目标 RMS 半径 $\\sqrt{\\langle r^2 \\rangle} = 5.5 \\text{ fm}$，表面厚度 $t = 1.0 \\text{ fm}$。\n- 案例 3（厚表面，不同目标）：目标 RMS 半径 $\\sqrt{\\langle r^2 \\rangle} = 5.3 \\text{ fm}$，表面厚度 $t = 4.0 \\text{ fm}$。\n\n所有三种情况都使用 $A = 208$。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身是一个双元素列表 $[c,a]$，两个数字都以飞米为单位并四舍五入到六位小数。例如，最后一行应类似于“[[c1,a1],[c2,a2],[c3,a3]]”，不带任何附加文本。", "solution": "该问题是有效的。这是一个在计算核物理领域中提法明确、有科学依据的问题，没有歧义，并包含了获得唯一解所需的所有信息。核心任务是通过对 $^{208}\\mathrm{Pb}$ 的均方根（RMS）半径和表面厚度施加具有物理动机的约束，来确定其伍兹-撒克逊核密度分布的参数。这是该领域的标准步骤。\n\n求解过程包括一系列解析和数值步骤。目标是为费米密度函数找到半密度半径 $c$ 和弥散参数 $a$，\n$$\n\\rho(r) = \\frac{\\rho_0}{1 + \\exp\\left(\\frac{r - c}{a}\\right)}\n$$\n其中 $r$ 是径向坐标，$\\rho_0$ 是一个归一化常数。核子数固定为 $A = 208$。\n\n### 步骤 1：从表面厚度 t 确定弥散度 a\n\n表面厚度 $t$ 定义为 $t = r_{0.1} - r_{0.9}$，其中 $r_{0.1}$ 和 $r_{0.9}$ 分别是密度 $\\rho(r)$ 为其中心值 $\\rho_0$ 的 $10\\%$ 和 $90\\%$ 时的半径。我们可以解析地求解这些半径。\n\n对于 $r_{0.9}$，我们有 $\\rho(r_{0.9}) = 0.9\\,\\rho_0$:\n$$\n\\frac{\\rho_0}{1 + \\exp\\left(\\frac{r_{0.9} - c}{a}\\right)} = 0.9\\,\\rho_0\n$$\n$$\n1 + \\exp\\left(\\frac{r_{0.9} - c}{a}\\right) = \\frac{1}{0.9} = \\frac{10}{9}\n$$\n$$\n\\exp\\left(\\frac{r_{0.9} - c}{a}\\right) = \\frac{1}{9}\n$$\n对两边取自然对数，得到：\n$$\n\\frac{r_{0.9} - c}{a} = \\ln\\left(\\frac{1}{9}\\right) = -\\ln(9) \\implies r_{0.9} = c - a\\ln(9)\n$$\n\n对于 $r_{0.1}$，我们有 $\\rho(r_{0.1}) = 0.1\\,\\rho_0$:\n$$\n\\frac{\\rho_0}{1 + \\exp\\left(\\frac{r_{0.1} - c}{a}\\right)} = 0.1\\,\\rho_0\n$$\n$$\n1 + \\exp\\left(\\frac{r_{0.1} - c}{a}\\right) = \\frac{1}{0.1} = 10\n$$\n$$\n\\exp\\left(\\frac{r_{0.1} - c}{a}\\right) = 9\n$$\n取自然对数，得到：\n$$\n\\frac{r_{0.1} - c}{a} = \\ln(9) \\implies r_{0.1} = c + a\\ln(9)\n$$\n\n于是，表面厚度 $t$ 为：\n$$\nt = r_{0.1} - r_{0.9} = (c + a\\ln(9)) - (c - a\\ln(9)) = 2a\\ln(9)\n$$\n由于 $\\ln(9) = \\ln(3^2) = 2\\ln(3)$，这可以简化为 $t = 4a\\ln(3)$。因此，弥散参数 $a$ 直接由表面厚度 $t$ 决定：\n$$\na = \\frac{t}{4\\ln(3)}\n$$\n此方程用于为每个测试用例计算 $a$。\n\n### 步骤 2：从 RMS 半径约束确定半密度半径 c\n\n均方根（RMS）半径 $\\sqrt{\\langle r^2 \\rangle}$ 定义为：\n$$\n\\sqrt{\\langle r^2 \\rangle} = \\left( \\frac{4\\pi \\int_0^{\\infty} r^4 \\rho(r) dr}{4\\pi \\int_0^{\\infty} r^2 \\rho(r) dr} \\right)^{1/2}\n$$\n代入 $\\rho(r)$ 并消去分子和分母中的常数 $4\\pi\\rho_0$，我们得到：\n$$\n\\sqrt{\\langle r^2 \\rangle}(c, a) = \\left( \\frac{\\int_0^{\\infty} \\frac{r^4}{1 + \\exp\\left(\\frac{r-c}{a}\\right)} dr}{\\int_0^{\\infty} \\frac{r^2}{1 + \\exp\\left(\\frac{r-c}{a}\\right)} dr} \\right)^{1/2}\n$$\n对于一个固定的 $a$ 值（由步骤 1 中的 $t$ 确定），RMS 半径是 $c$ 的一个单调递增函数。这使我们能够找到一个唯一的 $c$ 值，满足目标 RMS 半径约束 $\\sqrt{\\langle r^2 \\rangle}_{\\text{target}}$。我们定义一个目标函数 $F(c)$，并使其为零：\n$$\nF(c) = \\sqrt{\\langle r^2 \\rangle}(c, a) - \\sqrt{\\langle r^2 \\rangle}_{\\text{target}} = 0\n$$\n这是一个求根问题。这些积分没有简单的解析闭式解，必须进行数值计算。我们采用一个稳健的积分方法，如 `scipy.integrate.quad`，来评估在半无限域 $r \\in [0, \\infty)$ 上的积分。被积函数分母的指数衰减确保了快速收敛。\n\n一个区间求根算法，如布伦特方法（`scipy.optimize.brentq`），是求解 $F(c) = 0$ 的理想选择。我们为 $c$ 建立一个搜索区间，例如 $[1, 15]$ fm，这在物理上肯定能包含像 $^{208}\\mathrm{Pb}$ 这样的重核的真实值。该算法迭代地缩小这个区间，以高精度找到根 $c$。\n\n### 步骤 3：归一化到核子数 A\n\n尽管 RMS 半径的计算与中心密度 $\\rho_0$ 无关，但一个完整的物理模型需要正确的归一化。总核子数 $A$ 由下式给出：\n$$\nA = 4\\pi \\int_0^{\\infty} r^2 \\rho(r) dr = 4\\pi \\rho_0 \\int_0^{\\infty} \\frac{r^2}{1 + \\exp\\left(\\frac{r-c}{a}\\right)} dr\n$$\n一旦参数 $c$ 和 $a$ 被确定，该积分就可以进行数值计算。然后通过下式找到归一化常数 $\\rho_0$：\n$$\n\\rho_0 = \\frac{A}{4\\pi \\int_0^{\\infty} \\frac{r^2}{1 + \\exp\\left(\\frac{r-c}{a}\\right)} dr}\n$$\n使用 $A=208$ 进行此计算，以验证模型的完整性，尽管 $\\rho_0$ 不是要求输出的一部分。\n\n### 算法总结\n\n对于由一对 $(\\sqrt{\\langle r^2 \\rangle}_{\\text{target}}, t)$ 定义的每个测试用例：\n1.  使用公式 $a = t / (4\\ln(3))$ 计算弥散度 $a$ 的值。\n2.  定义一个目标函数 $F(c)$，它计算给定 $c$（以及现已固定的 $a$）下计算出的 RMS 半径与目标 RMS 半径之间的差值。该函数涉及两个积分的数值评估。\n3.  使用布伦特方法在一个安全的区间内找到 $F(c) = 0$ 的根，从而得出半密度半径 $c$。\n4.  得到的数对 $(c, a)$ 是该测试用例的解。按要求将数值四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for the Fermi density parameters (c, a) for given RMS radius and surface thickness.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is (target_rms_radius_fm, surface_thickness_fm)\n    test_cases = [\n        (5.5, 2.4),\n        (5.5, 1.0),\n        (5.3, 4.0),\n    ]\n    \n    A = 208.0 # Nucleon number for 208Pb\n    \n    results = []\n    \n    for target_rms, t in test_cases:\n        # Step 1: Analytically determine diffuseness 'a' from surface thickness 't'.\n        # The surface thickness t is defined as r_0.1 - r_0.9.\n        # This leads to the relation t = 2*a*ln(9) = 4*a*ln(3).\n        a = t / (4.0 * np.log(3.0))\n\n        # The shape of the Fermi distribution, f(r), without the rho_0 factor.\n        def fermi_shape(r, c_val, a_val):\n            return 1.0 / (1.0 + np.exp((r - c_val) / a_val))\n            \n        def calculate_rms(c_val, a_val):\n            \"\"\"Computes the RMS radius for given c and a.\"\"\"\n            # The integrand for the second moment of the radius,", "id": "3574012"}, {"introduction": "在为核密度建立模型之后，下一步是计算可与实验直接比较的可观测量。本练习旨在计算核电荷形状因子，即电荷密度的傅里叶变换，该因子可通过电子散射实验进行测量。该练习强调了点状核子分布与实际电荷分布之间的关键区别，后者需要通过“折叠”操作将核子自身的内禀大小考虑在内 [@problem_id:3573943]。", "problem": "考虑一个球对称的中等质量原子核，其中质子中心和中子中心的空间分布由双参数费米 (2pF) 函数建模。设径向坐标为 $r$，单位为飞米 (fm)，定义 2pF 形状函数为 $f(r;c,a) = \\left(1 + \\exp\\left(\\frac{r - c}{a}\\right)\\right)^{-1}$，其中半密度半径 $c$（单位 fm）和表面弥散度 $a$（单位 fm）。归一化的点核子坐标密度构建为 $\\rho_{p}(r) = \\rho_{0,p} f(r;c_p,a_p)$ 和 $\\rho_{n}(r) = \\rho_{0,n} f(r;c_n,a_n)$，其中归一化常数 $\\rho_{0,p}$ 和 $\\rho_{0,n}$ 的选择需满足 $4\\pi \\int_{0}^{\\infty} r^{2} \\rho_{p}(r)\\,dr = 1$ 和 $4\\pi \\int_{0}^{\\infty} r^{2} \\rho_{n}(r)\\,dr = 1$。该原子核有 $Z$ 个质子和 $N$ 个中子。\n\n定义点核子质子电荷形状因子 $F_{\\mathrm{point}}(q)$ 为 $\\rho_{p}(r)$ 的三维傅里叶变换，利用球对称性，针对动量转移大小 $q$（单位为逆飞米 fm$^{-1}$）进行求值。为包含内在核子结构，通过在傅里叶变换前将坐标空间密度与内在核子电荷分布进行卷积，来定义一个折叠（物理）电荷形状因子 $F_{\\mathrm{fold}}(q)$，这等效于在动量空间中将点核子坐标空间形状因子乘以内在核子电形状因子。使用以下具有物理动机的参数化来表示作为 $q$ 函数的内在核子电形状因子：\n- 内在质子电形状因子建模为三维高斯函数，质子均方根半径为 $r_{p} = 0.84\\,\\mathrm{fm}$，给出与小 $q$ 展开一致的动量空间因子 $G_{E}^{p}(q)$。\n- 内在中子电形状因子在小 $q$ 时需再现中子均方电荷半径 $\\langle r_{n}^{2} \\rangle = -0.1161\\,\\mathrm{fm}^{2}$，同时以与质子情况相当的高斯尺度衰减。\n\n仅从归一化密度的定义、球对称函数的三维傅里叶变换以及卷积定理出发，完成以下任务：\n1. 推导在给定 $q$、$Z$、$N$ 以及数组 $(c_p,a_p)$ 和 $(c_n,a_n)$ 的情况下计算 $F_{\\mathrm{point}}(q)$ 和 $F_{\\mathrm{fold}}(q)$ 的表达式，确保 $F_{\\mathrm{point}}(0) = 1$ 和 $F_{\\mathrm{fold}}(0) = 1$。\n2. 实现一个数值算法，利用零阶球贝塞尔函数 $j_{0}(x)$ 为傅里叶变换精确计算所需的径向积分。使用一个延伸到足够大截断半径的径向网格和稳定的求积方案以确保收敛。\n3. 通过计算绝对差 $\\Delta(q) = F_{\\mathrm{fold}}(q) - F_{\\mathrm{point}}(q)$，定量比较这两个形状因子。\n\n你的程序必须为以下测试案例集计算 $\\Delta(q)$，每个案例由 $(\\text{名称}, Z, N, c_p, a_p, c_n, a_n, q)$ 指定，其中 $q$ 的单位为 fm$^{-1}$，所有半径单位为 fm：\n- 案例 1 (边界情况，零动量): $(\"^{40}\\mathrm{Ca}\", 20, 20, 3.5, 0.5, 3.5, 0.5, 0.0)$\n- 案例 2 (低 $q$，对称核): $(\"^{40}\\mathrm{Ca}\", 20, 20, 3.5, 0.5, 3.5, 0.5, 0.5)$\n- 案例 3 (高 $q$，对称核): $(\"^{40}\\mathrm{Ca}\", 20, 20, 3.5, 0.5, 3.5, 0.5, 3.0)$\n- 案例 4 (低 $q$，富中子核带中子皮): $(\"^{48}\\mathrm{Ca}\", 20, 28, 3.55, 0.52, 3.60, 0.55, 0.5)$\n- 案例 5 (高 $q$，富中子核带中子皮): $(\"^{48}\\mathrm{Ca}\", 20, 28, 3.55, 0.52, 3.60, 0.55, 3.0)$\n- 案例 6 (中等 $q$，较重的中等质量核): $(\"^{56}\\mathrm{Ni}\", 28, 28, 4.20, 0.52, 4.25, 0.52, 1.0)$\n\n所有物理量必须按上述指定单位处理。形状因子是无量纲的。你的程序应生成单行输出，包含六个案例的 $\\Delta(q)$ 值，顺序与列表相同，形式为用方括号括起来的逗号分隔列表。每个值必须是四舍五入到六位小数的浮点数。例如，正确格式的输出行看起来像 $[x_1,x_2,x_3,x_4,x_5,x_6]$，其中每个 $x_i$ 是一个十进制浮点数。", "solution": "该问题要求计算一个球对称原子核的折叠电荷形状因子与点质子电荷形状因子之间的差值 $\\Delta(q) = F_{\\mathrm{fold}}(q) - F_{\\mathrm{point}}(q)$。这将通过首先根据所提供的定义推导所有量的解析表达式，然后实现一个数值方案来计算所得积分来完成。\n\n**1. 密度归一化**\n质子和中子中心的空间分布由双参数费米 (2pF) 函数给出，$f(r;c,a) = \\left(1 + \\exp\\left(\\frac{r - c}{a}\\right)\\right)^{-1}$。归一化的点核子密度为 $\\rho_{p}(r) = \\rho_{0,p} f(r;c_p,a_p)$ 和 $\\rho_{n}(r) = \\rho_{0,n} f(r;c_n,a_n)$。归一化常数 $\\rho_{0,p}$ 和 $\\rho_{0,n}$ 由密度在整个空间上的积分等于一的条件确定。对于质子密度 $\\rho_p(r)$：\n$$4\\pi \\int_{0}^{\\infty} r^{2} \\rho_{p}(r)\\,dr = 1$$\n代入 $\\rho_p(r)$ 的表达式：\n$$4\\pi \\rho_{0,p} \\int_{0}^{\\infty} r^{2} f(r;c_p,a_p)\\,dr = 1$$\n这给出了归一化常数 $\\rho_{0,p}$ 为：\n$$\\rho_{0,p} = \\left( 4\\pi \\int_{0}^{\\infty} r^{2} f(r;c_p,a_p)\\,dr \\right)^{-1}$$\n对于中子归一化常数 $\\rho_{0,n}$，使用参数 $(c_n, a_n)$ 也有一个相同的表达式：\n$$\\rho_{0,n} = \\left( 4\\pi \\int_{0}^{\\infty} r^{2} f(r;c_n,a_n)\\,dr \\right)^{-1}$$\n这些积分必须进行数值计算。\n\n**2. 点核子形状因子, $F_{\\mathrm{point}}(q)$**\n点核子质子电荷形状因子 $F_{\\mathrm{point}}(q)$ 是归一化点质子密度 $\\rho_p(r)$ 的三维傅里叶变换。对于一个普遍的球对称密度 $\\rho(r)$，傅里叶变换 $F(q)$（其中 $q = |\\vec{q}|$）推导如下：\n$$F(q) = \\int \\rho(r) e^{-i \\vec{q} \\cdot \\vec{r}} d^3r$$\n使用球坐标，其中 $\\vec{q}$ 与 z 轴对齐，$\\vec{q} \\cdot \\vec{r} = qr \\cos\\theta$，并且 $d^3r = r^2 \\sin\\theta dr d\\theta d\\phi$：\n$$F(q) = \\int_0^{2\\pi} d\\phi \\int_0^{\\pi} d\\theta \\sin\\theta \\int_0^{\\infty} dr \\, r^2 \\rho(r) e^{-iqr\\cos\\theta}$$\n对 $\\phi$ 的积分得到 $2\\pi$。对 $\\theta$ 的积分是：\n$$\\int_0^{\\pi} \\sin\\theta e^{-iqr\\cos\\theta} d\\theta = \\frac{2\\sin(qr)}{qr} = 2j_0(qr)$$\n其中 $j_0(x)$ 是零阶球贝塞尔函数。结合这些结果得到：\n$$F(q) = 4\\pi \\int_{0}^{\\infty} r^2 \\rho(r) j_0(qr) dr$$\n将此应用于归一化的质子密度 $\\rho_p(r)$，我们获得点形状因子的表达式：\n$$F_{\\mathrm{point}}(q) = 4\\pi \\int_{0}^{\\infty} r^2 \\rho_p(r) j_0(qr) dr = 4\\pi \\rho_{0,p} \\int_0^{\\infty} r^2 f(r;c_p, a_p) j_0(qr) dr$$\n在 $q=0$ 时，我们有 $j_0(0) = 1$。表达式变为 $F_{\\mathrm{point}}(0) = 4\\pi \\rho_{0,p} \\int_0^{\\infty} r^2 f(r;c_p, a_p) dr$。利用 $\\rho_{0,p}$ 的定义，我们确认 $F_{\\mathrm{point}}(0)=1$，符合要求。一个类似的表达式定义了点中子形状因子 $F_n(q)$。\n\n**3. 内在核子形状因子**\n折叠形状因子考虑了核子的内在电荷分布。\n对于质子，其均方根电荷半径为 $r_p = 0.84\\,\\mathrm{fm}$，一个三维高斯电荷分布导致一个高斯形状因子。在小 $q$ 时，形状因子 $F(q)$ 和均方半径 $\\langle r^2 \\rangle$ 之间的关系是 $F(q) \\approx 1 - \\frac{1}{6}q^2 \\langle r^2 \\rangle$。满足此条件的高斯形状因子是：\n$$G_E^p(q) = \\exp\\left(-\\frac{q^2 r_p^2}{6}\\right)$$\n对于中子，问题规定其内在形状因子 $G_E^n(q)$ 在小 $q$ 时必须再现均方电荷半径 $\\langle r_n^2 \\rangle = -0.1161\\,\\mathrm{fm}^2$，并以与质子相似的尺度衰减。中子的总电荷为零，所以 $G_E^n(0)=0$。小 $q$ 行为是 $G_E^n(q) \\approx - \\frac{1}{6}q^2 \\langle r_n^2 \\rangle$。一个满足所有条件的、简单的、具有物理动机的参数化是，将这个小 $q$ 项乘以一个与质子具有相同尺度的高斯衰减因子：\n$$G_E^n(q) = -\\frac{\\langle r_n^2 \\rangle}{6} q^2 \\exp\\left(-\\frac{q^2 r_p^2}{6}\\right)$$\n该函数正确地满足 $G_E^n(0)=0$ 并再现了所需的均方半径，因为 $\\langle r_n^2 \\rangle = -6 \\frac{dG_E^n}{dq^2}\\Big|_{q^2=0}$。\n\n**4. 折叠电荷形状因子, $F_{\\mathrm{fold}}(q)$**\n核电荷形状因子是总核电荷密度的傅里叶变换，总核电荷密度是核子中心分布与内在核子电荷分布的卷积。根据卷积定理，在动量空间中，这对应于形状因子的乘积。由质子数 $Z$ 归一化的总形状因子为：\n$$F_{\\mathrm{fold}}(q) = \\frac{1}{Z} \\left[ Z \\cdot F_p(q) G_E^p(q) + N \\cdot F_n(q) G_E^n(q) \\right]$$\n这里，$F_p(q)$ 是我们之前称为 $F_{\\mathrm{point}}(q)$ 的点质子形状因子的记法，$F_n(q)$ 是点中子形状因子。表达式简化为：\n$$F_{\\mathrm{fold}}(q) = F_{\\mathrm{point}}(q) G_E^p(q) + \\frac{N}{Z} F_n(q) G_E^n(q)$$\n我们可以检查 $F_{\\mathrm{fold}}(0) = F_{\\mathrm{point}}(0)G_E^p(0) + \\frac{N}{Z}F_n(0)G_E^n(0) = (1)(1) + \\frac{N}{Z}(1)(0) = 1$，满足问题条件。\n\n**5. $\\Delta(q)$ 的最终表达式**\n要计算的量是 $\\Delta(q) = F_{\\mathrm{fold}}(q) - F_{\\mathrm{point}}(q)$。代入推导的表达式：\n$$\\Delta(q) = \\left( F_{\\mathrm{point}}(q) G_E^p(q) + \\frac{N}{Z} F_n(q) G_E^n(q) \\right) - F_{\\mathrm{point}}(q)$$\n$$\\Delta(q) = F_{\\mathrm{point}}(q) (G_E^p(q) - 1) + \\frac{N}{Z} F_n(q) G_E^n(q)$$\n这是需要进行数值实现的最终表达式。对于 $q=0$ 的特殊情况，我们有 $G_E^p(0)=1$ 和 $G_E^n(0)=0$，这立即得出 $\\Delta(0)=0$。\n\n**6. 数值实现**\n算法流程如下：\n- 对于给定的参数集 $(Z, N, c_p, a_p, c_n, a_n, q)$，首先检查是否 $q=0$。如果是，则结果为 $0$。\n- 如果 $q \\neq 0$，则使用数值求积程序计算 $\\rho_{0,p}$、$\\rho_{0,n}$、$F_{\\mathrm{point}}(q)$ 和 $F_n(q)$ 所需的积分。`scipy.integrate.quad` 函数适合此任务。\n- 积分在从 $r=0$ 到一个截断半径 $r_{\\text{max}}$ 的有限径向网格上执行。由于费米函数呈指数衰减，对于给定的参数，截断半径 $r_{\\text{max}} = 25\\,\\mathrm{fm}$ 足以确保收敛。\n- 零阶球贝塞尔函数 $j_0(qr)$ 使用 `scipy.special.spherical_jn` 计算。\n- 在计算出所有分量后，使用上面推导的最终表达式计算 $\\Delta(q)$。对所有测试案例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import spherical_jn\n\ndef solve():\n    \"\"\"\n    Computes the difference between folded and point-proton charge form factors\n    for a set of test cases.\n    \"\"\"\n    \n    # Define physical constants from the problem. All units are in fm.\n    # Proton root-mean-square radius squared (fm^2)\n    R_P_SQ = 0.84**2\n    # Neutron mean-square charge radius (fm^2)\n    R_N_SQ = -0.1161\n\n    # Define the test cases from the problem statement.\n    # Format: (name, Z, N, c_p, a_p, c_n, a_n, q)\n    test_cases = [\n        (\"40Ca\", 20, 20, 3.5, 0.5, 3.5, 0.5, 0.0),\n        (\"40Ca\", 20, 20, 3.5, 0.5, 3.5, 0.5, 0.5),\n        (\"40Ca\", 20, 20, 3.5, 0.5, 3.5, 0.5, 3.0),\n        (\"48Ca\", 20, 28, 3.55, 0.52, 3.60, 0.55, 0.5),\n        (\"48Ca\", 20, 28, 3.55, 0.52, 3.60, 0.55, 3.0),\n        (\"56Ni\", 28, 28, 4.20, 0.52, 4.25, 0.52, 1.0)\n    ]\n\n    def fermi_dist(r, c, a):\n        \"\"\"Calculates the two-parameter Fermi (2pF) distribution value.\"\"\"\n        # Safeguard against potential overflow in np.exp for large arguments.\n        # If (r-c)/a is large and positive, the exponential dominates and f -> 0.\n        arg = (r - c) / a\n        if arg > 700:\n            return 0.0\n        return 1.0 / (1.0 + np.exp(arg))\n\n    def calculate_delta(params):\n        \"\"\"\n        Calculates Delta(q) for a single case.\n        Delta(q) = F_fold(q) - F_point(q)\n        \"\"\"\n        _, Z, N, c_p, a_p, c_n, a_n, q = params\n        \n        # Analytic result for q=0 edge case.\n        # G_E^p(0)=1 and G_E^n(0)=0, so Delta(0) = F_point(0)(1-1) + ... = 0.\n        if q == 0.0:\n            return 0.0\n\n        # Set a sufficiently large radial cutoff for integration (in fm).\n        r_max = 25.0\n\n        # 1. Calculate normalization constants rho_0,p and rho_0,n\n        # The integral is I = integral(r^2 * f(r) dr) from 0 to infinity.\n        # rho_0 = 1 / (4 * pi * I)\n        integrand_norm_p = lambda r: r**2 * fermi_dist(r, c_p, a_p)\n        I_p, _ = quad(integrand_norm_p, 0, r_max)\n        rho_0_p = 1.0 / (4.0 * np.pi * I_p)\n\n        integrand_norm_n = lambda r: r**2 * fermi_dist(r, c_n, a_n)\n        I_n, _ = quad(integrand_norm_n, 0, r_max)\n        rho_0_n = 1.0 / (4.0 * np.pi * I_n)\n\n        # 2. Calculate point-proton form factor F_point(q)\n        # F_point(q) = 4*pi*rho_0_p * integral(r^2 * f_p(r) * j0(qr) dr)\n        integrand_Fp = lambda r: r**2 * fermi_dist(r, c_p, a_p) * spherical_jn(0, q * r)\n        I_Fp, _ = quad(integrand_Fp, 0, r_max)\n        F_point_q = 4.0 * np.pi * rho_0_p * I_Fp\n\n        # 3. Calculate point-neutron form factor F_n(q)\n        # F_n(q) = 4*pi*rho_0_n * integral(r^2 * f_n(r) * j0(qr) dr)\n        integrand_Fn = lambda r: r**2 * fermi_dist(r, c_n, a_n) * spherical_jn(0, q * r)\n        I_Fn, _ = quad(integrand_Fn, 0, r_max)\n        F_n_q = 4.0 * np.pi * rho_0_n * I_Fn\n\n        # 4. Calculate intrinsic nucleon form factors G_E^p(q) and G_E^n(q)\n        q_sq = q**2\n        G_E_p_q = np.exp(-q_sq * R_P_SQ / 6.0)\n        G_E_n_q = -(R_N_SQ / 6.0) * q_sq * np.exp(-q_sq * R_P_SQ / 6.0)\n\n        # 5. Calculate Delta(q) = F_point(q)*(G_E^p(q)-1) + (N/Z)*F_n(q)*G_E^n(q)\n        delta_q = F_point_q * (G_E_p_q - 1.0) + (N / Z) * F_n_q * G_E_n_q\n        \n        return delta_q\n\n    results = []\n    for case in test_cases:\n        result = calculate_delta(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3573943"}, {"introduction": "现代核理论常常依赖于大规模数值计算，例如在离散时空格子上进行的计算。最后一个练习旨在解决计算科学中的一个关键问题：理解并控制由数值方法本身引起的系统误差。通过分析一个简单的格点高斯密度，你将学会如何识别、量化和外推消除离散化（有限格点间距）和有限体积（有限盒子尺寸）误差，这是获得可靠科学结果的一项至关重要的技能 [@problem_id:3574008]。", "problem": "考虑一个由三维高斯函数模拟的球对称核电荷密度，\n$$\\rho(\\mathbf{r}) = \\frac{1}{\\pi^{3/2} R^3} \\exp\\!\\left(-\\frac{x^2+y^2+z^2}{R^2}\\right),$$\n其特征长度标度为 $R$。该密度在无限空间中归一化，使得总电荷为 $1$（无量纲），且精确的无限体积均方半径为\n$$\\langle r^2 \\rangle_\\infty = \\int_{\\mathbb{R}^3} r^2 \\rho(\\mathbf{r}) \\, d^3r = \\frac{3 R^2}{2}.$$\n\n假设您在一个边长为 $L$、间距为 $a$ 的周期性立方晶格上，使用均匀网格上的中点法则来计算 $\\rho(\\mathbf{r})$ 和 $\\langle r^2 \\rangle$。令 $N = L/a$（假设 $N$ 是整数），并定义一维中点为\n$$x_i = -\\frac{L}{2} + \\left(i + \\frac{1}{2}\\right) a, \\quad i \\in \\{0,1,\\dots,N-1\\}.$$\n定义晶格估计量\n$$S_0(a,L) = a^3 \\sum_{i,j,k=0}^{N-1} \\rho(x_i, x_j, x_k), \\qquad S_2(a,L) = a^3 \\sum_{i,j,k=0}^{N-1} \\rho(x_i, x_j, x_k) \\, (x_i^2 + x_j^2 + x_k^2),$$\n以及晶格均方半径\n$$\\langle r^2 \\rangle_{\\text{lat}}(a,L) = \\frac{S_2(a,L)}{S_0(a,L)}.$$\n由于 $\\rho(\\mathbf{r})$ 在笛卡尔坐标方向上是可分解的，您可以在算法上利用这一结构。\n\n通过与连续立方体（无离散化，有限 $L$）的参考值进行比较，可以分离出有限体积效应。该参考值是通过在立方体 $[-L/2,L/2]^3$ 上进行精确积分得到的。令\n$$I_0(L) = \\int_{-L/2}^{L/2} \\frac{1}{\\sqrt{\\pi} R} e^{-x^2/R^2} \\, dx = \\operatorname{erf}\\!\\left(\\frac{L}{2R}\\right),$$\n$$I_2(L) = \\int_{-L/2}^{L/2} \\frac{x^2}{\\sqrt{\\pi} R} e^{-x^2/R^2} \\, dx = R^2 \\left[\\frac{1}{2} \\operatorname{erf}\\!\\left(\\frac{L}{2R}\\right) - \\frac{L}{2 R \\sqrt{\\pi}} e^{-(L/2R)^2}\\right],$$\n以及\n$$\\langle r^2 \\rangle_{\\text{cube}}(L) = 3 \\, \\frac{I_2(L)}{I_0(L)}.$$\n这里 $\\operatorname{erf}$ 是误差函数，$\\operatorname{erfc}$ 是互补误差函数 (erfc)，定义为 $\\operatorname{erfc}(x)=1-\\operatorname{erf}(x)$。\n\n任务。仅从黎曼和的基本定义以及关于误差函数的经过充分检验的事实出发，您必须：\n- 在固定 $L$ 的情况下，推导应用于 $\\langle r^2 \\rangle_{\\text{lat}}(a,L)$ 的中点法则的前导阶离散化误差标度，并用 $a$ 的幂次表示该标度。\n- 对于高斯模型，推导当 $L \\to \\infty$ 时 $\\langle r^2 \\rangle_{\\text{cube}}(L)$ 的有限体积依赖性，并明确地将其与 $\\operatorname{erf}$ 或 $\\operatorname{erfc}$ 联系起来，同时确定有限体积误差的渐近衰减。\n- 提出一个形式为\n$$\\langle r^2 \\rangle_{\\text{lat}}(a,L) = \\langle r^2 \\rangle_\\infty + c_a \\, a^2 + c_L \\, f(L; R),$$\n的同步外推拟设，其中 $f(L;R)$ 是一个已知函数，用于捕捉您推导出的前导有限体积标度，$c_a$ 和 $c_L$ 是拟合系数。您必须选择一个 $f(L;R)$，使其随 $L$ 的衰减与您的推导一致。\n\n然后实现一个程序，该程序：\n- 通过分解的一维求和计算 $\\langle r^2 \\rangle_{\\text{lat}}(a,L)$，并通过上述精确公式计算 $\\langle r^2 \\rangle_{\\text{cube}}(L)$。\n- 使用该程序量化观察到的标度律并执行外推拟合。\n\n使用以下固定的模型和测试套件。所有长度单位必须是费米 (fm)，所有均方半径单位必须是平方费米 (fm$^2$)。使用 $R = 1.0$ fm。\n\n测试套件：\n- 测试 1（离散化标度指数）：使用 $L = 12.0$ fm，以及两个间距 $a_1 = 0.6$ fm 和 $a_2 = 0.3$ fm。计算离散化误差\n$$E_{\\text{disc}}(a;L) = \\left| \\langle r^2 \\rangle_{\\text{lat}}(a,L) - \\langle r^2 \\rangle_{\\text{cube}}(L) \\right|,$$\n并估计观察到的标度指数\n$$p = \\frac{\\ln\\!\\left(E_{\\text{disc}}(a_1;L)/E_{\\text{disc}}(a_2;L)\\right)}{\\ln\\!\\left(a_1/a_2\\right)}.$$\n- 测试 2（连续立方体中的有限体积误差大小）：使用精确的连续立方体值（无离散化），计算绝对有限体积误差\n$$E_{\\text{vol}}(L) = \\left| \\langle r^2 \\rangle_{\\text{cube}}(L) - \\langle r^2 \\rangle_\\infty \\right|,$$\n其中 $L \\in \\{6.0 \\text{ fm}, 10.0 \\text{ fm}\\}$。\n- 测试 3（同步外推）：为以下参数建立一个晶格测量值 $\\langle r^2 \\rangle_{\\text{lat}}(a,L)$ 的数据集\n$$a \\in \\{0.6 \\text{ fm},\\, 0.4 \\text{ fm},\\, 0.3 \\text{ fm}\\}, \\quad L \\in \\{9.6 \\text{ fm},\\, 12.0 \\text{ fm}\\},$$\n这确保了对于每对参数，$N=L/a$ 都是整数。通过对所有六个点进行最小二乘拟合，拟合线性模型\n$$\\langle r^2 \\rangle_{\\text{lat}}(a,L) = \\langle r^2 \\rangle_\\infty + c_a \\, a^2 + c_L \\, \\operatorname{erfc}\\!\\left(\\frac{L}{2R}\\right),$$\n并报告拟合得到的 $\\langle r^2 \\rangle_\\infty$ 与精确值 $\\frac{3 R^2}{2}$ 之间的绝对偏差。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序如下\n$$[p,\\; E_{\\text{vol}}(6.0\\ \\text{fm}),\\; E_{\\text{vol}}(10.0\\ \\text{fm}),\\; |\\langle r^2 \\rangle_{\\infty,\\text{fit}} - \\tfrac{3 R^2}{2}|],$$\n每个浮点数四舍五入到六位小数，第二、三、四项的单位被理解为 $\\text{fm}^2$，而第一项 $p$ 是无量纲的。此问题中不使用角度。不得使用百分比；所有比率均以小数表示。", "solution": "问题陈述经严格审查后被认定为有效。它提出了一个计算核物理学中的适定问题，该问题具有科学依据且内部一致，尽管在推导出的和指定的有限体积误差函数形式之间存在微妙的矛盾，但这将在推导部分加以解决。为获得唯一解提供了所有必要的参数和定义。\n\n**理论推导**\n\n需要进行完整的理论分析来为计算方法提供依据。这包括推导两个主要误差来源的标度行为：来自晶格间距 $a$ 的离散化误差，以及来自箱体尺寸 $L$ 的有限体积误差。\n\n**离散化误差标度**\n晶格估计量 $S_0(a,L)$ 和 $S_2(a,L)$ 分别是积分 $\\int_{[-L/2,L/2]^3} \\rho(\\mathbf{r})\\,d^3r$ 和 $\\int_{[-L/2,L/2]^3} r^2 \\rho(\\mathbf{r})\\,d^3r$ 使用中点法则的三维黎曼和。高斯电荷密度 $\\rho(\\mathbf{r})$ 是可分离的，即 $\\rho(x,y,z) = \\rho_1(x)\\rho_1(y)\\rho_1(z)$，其中 $\\rho_1(x) = (\\pi R^2)^{-1/2} e^{-x^2/R^2}$。这使得三维求和可以分解为一维求和的乘积。\n我们定义一维求和：\n$$J_0(a,L) = a \\sum_{i=0}^{N-1} \\rho_1(x_i), \\qquad J_2(a,L) = a \\sum_{i=0}^{N-1} x_i^2 \\rho_1(x_i)$$\n三维估计量可以表示为：\n$$S_0(a,L) = J_0^3(a,L), \\qquad S_2(a,L) = 3 J_2(a,L) J_0^2(a,L)$$\n晶格均方半径是其比值：\n$$\\langle r^2 \\rangle_{\\text{lat}}(a,L) = \\frac{S_2(a,L)}{S_0(a,L)} = \\frac{3 J_2(a,L) J_0^2(a,L)}{J_0^3(a,L)} = 3\\frac{J_2(a,L)}{J_0(a,L)}$$\n该量的误差源于一维中点和 $J_0$ 和 $J_2$ 的误差。对于中点法则，Euler-Maclaurin 公式指出，对于一个在 $[c,d]$ 上积分的足够光滑的函数 $f(x)$：\n$$a \\sum_{i=0}^{N-1} f(x_i) = \\int_c^d f(x) dx + \\frac{a^2}{24}\\left[f'(d)-f'(c)\\right] + O(a^4)$$\n$J_0$ 和 $J_2$ 的被积函数，即 $\\rho_1(x)$ 和 $x^2\\rho_1(x)$，是无限可微的。对于有限区间 $[-L/2, L/2]$，它们在边界处的导数非零。因此，$J_0(a,L)$ 和 $J_2(a,L)$ 的前导阶误差都与 $a^2$ 成正比。\n$$J_0(a,L) = I_0(L) + C_0(L) a^2 + O(a^4)$$\n$$J_2(a,L) = I_2(L) + C_2(L) a^2 + O(a^4)$$\n然后通过泰勒展开求得比值的误差：\n$$\\langle r^2 \\rangle_{\\text{lat}}(a,L) = 3 \\frac{I_2(L) + C_2 a^2 \\dots}{I_0(L) + C_0 a^2 \\dots} = 3\\frac{I_2}{I_0} \\left(1 + \\left(\\frac{C_2}{I_2}-\\frac{C_0}{I_0}\\right)a^2 + \\dots \\right) = \\langle r^2 \\rangle_{\\text{cube}}(L) + c_a(L) a^2 + O(a^4)$$\n因此，离散化误差 $E_{\\text{disc}}(a;L) = |\\langle r^2 \\rangle_{\\text{lat}}(a,L) - \\langle r^2 \\rangle_{\\text{cube}}(L)|$ 按 $a^2$ 标度，指数 $p$ 预期为 $2$。\n\n**有限体积误差标度**\n连续谱中的有限体积误差是 $E_{\\text{vol}}(L) = \\langle r^2 \\rangle_{\\text{cube}}(L) - \\langle r^2 \\rangle_\\infty$。我们已知：\n$$\\langle r^2 \\rangle_{\\text{cube}}(L) = 3 \\frac{I_2(L)}{I_0(L)}, \\quad \\langle r^2 \\rangle_\\infty = \\frac{3R^2}{2}$$\n代入所给的 $I_0(L)$ 和 $I_2(L)$ 表达式：\n$$E_{\\text{vol}}(L) = 3 \\frac{R^2 \\left[\\frac{1}{2} \\operatorname{erf}\\left(\\frac{L}{2R}\\right) - \\frac{L}{2R\\sqrt{\\pi}} e^{-(L/2R)^2}\\right]}{\\operatorname{erf}\\left(\\frac{L}{2R}\\right)} - \\frac{3R^2}{2}$$\n$$E_{\\text{vol}}(L) = \\frac{3R^2}{2} - \\frac{3R^2 \\cdot \\frac{L}{2R\\sqrt{\\pi}} e^{-(L/2R)^2}}{\\operatorname{erf}\\left(\\frac{L}{2R}\\right)} - \\frac{3R^2}{2} = -\\frac{3RL}{2\\sqrt{\\pi}} \\frac{e^{-(L/2R)^2}}{\\operatorname{erf}\\left(\\frac{L}{2R}\\right)}$$\n当 $L \\to \\infty$ 时，$z = L/(2R) \\to \\infty$ 且 $\\operatorname{erf}(z) \\to 1$。误差的前导渐近行为是：\n$$E_{\\text{vol}}(L) \\sim -\\frac{3RL}{2\\sqrt{\\pi}} e^{-(L/2R)^2}$$\n此误差按 $L \\exp(-(L/2R)^2)$ 标度。\n然而，问题指定的外推函数与 $\\operatorname{erfc}(z)$ 成正比。对于大的 $z$，渐近展开 $\\operatorname{erfc}(z) \\sim \\frac{e^{-z^2}}{z\\sqrt{\\pi}}$ 表明 $\\operatorname{erfc}(L/2R)$ 按 $L^{-1}\\exp(-(L/2R)^2)$ 标度。此函数形式与我们从给定积分公式的严格推导并不完全一致。然而，从有限体积积分中遗漏的总电荷 $1 - (\\operatorname{erf}(L/2R))^3$ 确实与 $\\operatorname{erfc}(L/2R)$ 渐近标度。使用 $\\operatorname{erfc}(L/2R)$ 作为有限体积误差的基函数是一种常见（尽管非严格推导）的做法。鉴于问题中的明确指令，我们将使用 $f(L;R) = \\operatorname{erfc}(L/2R)$ 进行外推拟合。\n\n**外推拟设**\n结合两个前导误差项，对 $a \\to 0$（连续极限）和 $L \\to \\infty$（无限体积极限）进行同步外推的建议模型是：\n$$\\langle r^2 \\rangle_{\\text{lat}}(a,L) = \\langle r^2 \\rangle_\\infty + c_a a^2 + c_L f(L;R)$$\n其中 $\\langle r^2 \\rangle_\\infty$、$c_a$ 和 $c_L$ 是拟合参数。根据问题陈述，我们采用 $f(L;R) = \\operatorname{erfc}(L/2R)$，从而得到待拟合的线性模型：\n$$\\langle r^2 \\rangle_{\\text{lat}}(a,L) = \\langle r^2 \\rangle_{\\infty, \\text{fit}} + c_a a^2 + c_L \\operatorname{erfc}\\left(\\frac{L}{2R}\\right)$$\n\n**计算策略**\n\n数值实现按测试套件指定分三个阶段进行。\n\n**测试 1：离散化标度指数**\n我们对固定的箱体尺寸 $L=12.0$ fm 和两个晶格间距 $a_1=0.6$ fm 及 $a_2=0.3$ fm，计算 $\\langle r^2 \\rangle_{\\text{lat}}(a,L)$。我们还使用所给的涉及误差函数的公式计算精确的连续谱值 $\\langle r^2 \\rangle_{\\text{cube}}(12.0 \\text{ fm})$。计算离散化误差 $E_{\\text{disc}}(a_1;L)$ 和 $E_{\\text{disc}}(a_2;L)$，然后根据它们的比值确定标度指数 $p$，即 $p = \\ln(E_{\\text{disc}}(a_1)/E_{\\text{disc}}(a_2)) / \\ln(a_1/a_2)$。\n\n**测试 2：有限体积误差的大小**\n我们对两个箱体尺寸 $L=6.0$ fm 和 $L=10.0$ fm，计算绝对有限体积误差 $E_{\\text{vol}}(L) = |\\langle r^2 \\rangle_{\\text{cube}}(L) - \\langle r^2 \\rangle_\\infty|$。这需要实现 $\\langle r^2 \\rangle_{\\text{cube}}(L)$ 的公式，并使用精确的无限体积值 $\\langle r^2 \\rangle_\\infty = 3R^2/2 = 1.5 \\text{ fm}^2$。\n\n**测试 3：同步外推**\n为参数对 $a \\in \\{0.6, 0.4, 0.3\\}$ fm 和 $L \\in \\{9.6, 12.0\\}$ fm，生成一个包含六个 $\\langle r^2 \\rangle_{\\text{lat}}(a,L)$ 值的数据集。然后，我们对上述推导出的模型进行线性最小二乘拟合。这对应于求解超定线性系统 $\\mathbf{y} = A\\mathbf{c}$ 以获得系数向量 $\\mathbf{c} = [\\langle r^2 \\rangle_{\\infty, \\text{fit}}, c_a, c_L]^T$，其中：\n- $\\mathbf{y}$ 是六个计算出的 $\\langle r^2 \\rangle_{\\text{lat}}(a_i,L_i)$ 值的向量。\n- $A$ 是一个 $6 \\times 3$ 的设计矩阵，其行为 $[1, a_i^2, \\operatorname{erfc}(L_i/2R)]$。\n使用 `numpy.linalg.lstsq` 函数找到最佳拟合系数。最终结果是拟合截距 $\\langle r^2 \\rangle_{\\infty, \\text{fit}}$ 与精确值 $\\langle r^2 \\rangle_\\infty$ 之间的绝对偏差。所有计算均使用 $R=1.0$ fm。利用求和的分解来提高计算效率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf, erfc\n\ndef solve():\n    \"\"\"\n    Computes discretization and finite-volume errors for the mean-square radius\n    of a Gaussian charge distribution, and performs a simultaneous extrapolation.\n    \"\"\"\n\n    # Fixed model parameter\n    R = 1.0  # fm\n\n    # Exact infinite-volume mean-square radius\n    r2_inf_exact = 1.5 * R**2  # fm^2\n\n    def rho_1d(x: np.ndarray, R_val: float) -> np.ndarray:\n        \"\"\"Computes the 1D Gaussian density.\"\"\"\n        return np.exp(-x**2 / R_val**2) / (np.sqrt(np.pi) * R_val)\n\n    def calc_r2_lat(a: float, L: float, R_val: float) -> float:\n        \"\"\"\n        Computes the lattice estimator for the mean-square radius using\n        factorized 1D sums.\n        \"\"\"\n        N = int(round(L / a))\n        if N == 0:\n            return 0.0\n        \n        # Grid points based on the midpoint rule\n        x_i = -L / 2.0 + (np.arange(N) + 0.5) * a\n        rho_vals = rho_1d(x_i, R_val)\n        \n        # 1D midpoint sums\n        j0 = a * np.sum(rho_vals)\n        j2 = a * np.sum(x_i**2 * rho_vals)\n        \n        if j0 == 0.0:\n            return np.inf  # Avoid division by zero\n        \n        return 3.0 * j2 / j0\n\n    def calc_r2_cube(L: float, R_val: float) -> float:\n        \"\"\"\n        Computes the mean-square radius in the continuum cube using the\n        exact integral formulas.\n        \"\"\"\n        z = L / (2.0 * R_val)\n        erf_z = erf(z)\n        \n        if erf_z == 0.0:\n            return np.inf\n\n        i0 = erf_z\n        i2 = R_val**2 * (0.5 * erf_z - (z / np.sqrt(np.pi)) * np.exp(-z**2))\n        \n        return 3.0 * i2 / i0\n\n    # --- Test 1: Discretization scaling exponent ---\n    L_test1 = 12.0\n    a1, a2 = 0.6, 0.3\n    \n    r2_lat_a1 = calc_r2_lat(a1, L_test1, R)\n    r2_lat_a2 = calc_r2_lat(a2, L_test1, R)\n    r2_cube_val = calc_r2_cube(L_test1, R)\n    \n    E_disc_a1 = abs(r2_lat_a1 - r2_cube_val)\n    E_disc_a2 = abs(r2_lat_a2 - r2_cube_val)\n    \n    # The exponent p = log(E1/E2) / log(a1/a2)\n    p = np.log(E_disc_a1 / E_disc_a2) / np.log(a1 / a2)\n\n    # --- Test 2: Finite-volume error magnitudes ---\n    L_vals_test2 = [6.0, 10.0]\n    E_vol_results = []\n    for L_val in L_vals_test2:\n        r2_cube_L = calc_r2_cube(L_val, R)\n        E_vol = abs(r2_cube_L - r2_inf_exact)\n        E_vol_results.append(E_vol)\n\n    # --- Test 3: Simultaneous extrapolation ---\n    fit_points = [\n        (0.6, 9.6), (0.6, 12.0),\n        (0.4, 9.6), (0.4, 12.0),\n        (0.3, 9.6), (0.3, 12.0),\n    ]\n    \n    # Set up the linear system A*c = y for least-squares fitting\n    num_points = len(fit_points)\n    A = np.zeros((num_points, 3))\n    y = np.zeros(num_points)\n    \n    for i, (a_fit, L_fit) in enumerate(fit_points):\n        # The vector y contains the measured values\n        y[i] = calc_r2_lat(a_fit, L_fit, R)\n        \n        # The design matrix A contains the basis functions\n        A[i, 0] = 1.0  # Intercept term for", "id": "3574008"}]}