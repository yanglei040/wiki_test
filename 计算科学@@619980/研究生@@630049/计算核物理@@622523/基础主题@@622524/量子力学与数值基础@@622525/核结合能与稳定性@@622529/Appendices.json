{"hands_on_practices": [{"introduction": "核物理学的一个核心挑战是理解原子核的结合能如何随质子数和中子数而变化。液滴模型通过将原子核类比为带电液滴，为这一问题提供了富有洞察力的半经验质量公式（SEMF）。这个实践练习 [@problem_id:3573765] 将理论与实际数据分析相结合，指导你从第一性原理出发构建一个线性回归模型，并使用实验原子质量数据来拟合SEMF的关键参数。通过这个过程，你将亲身体验如何从实验观测中提取出支配原子核稳定性的基本物理规律。", "problem": "要求您设计并实现一个完整的数值计算流程，以在高级研究生水平上，使用基于基本原理的推导和可复现的线性回归方法，从原子质量数据中估算原子核结合能模型的系数。待确定的系数是在选定的对能规定下的体积项系数 $a_v$、表面项系数 $a_s$、库仑项系数 $a_c$、不对称项系数 $a_a$ 和对能项振幅 $a_p$。推导必须从适用于液滴模型描述的基本原理和标度律出发，并且必须明确构建一个线性模型，其参数通过普通最小二乘法进行拟合。\n\n您必须使用的基本依据包括：\n- 质能等效关系 $E = m c^2$。\n- 对于一个质子数为 $Z$、中子数为 $N$ 的原子核，其核结合能 $B$ 的定义为：$B = Z m_p c^2 + N m_n c^2 - M_{\\text{nuc}} c^2$，其中 $m_p$ 和 $m_n$ 分别是自由质子和中子的质量，$M_{\\text{nuc}}$ 是原子核的质量。\n- 通过去除 $Z$ 个电子的静止质量并加上总电子结合能 $E_e(Z)$，从原子质量 $M_{\\text{atom}}$（包含 $Z$ 个束缚电子的中性原子）转换为原子核质量 $M_{\\text{nuc}}$：$M_{\\text{nuc}} = M_{\\text{atom}} - Z m_e + E_e(Z)/c^2$，其中 $m_e$ 是电子质量。使用一个随 $Z$ 合理标度的一致的、平滑的中性原子电子结合能修正模型 $E_e(Z)$；采用 $E_e(Z) = \\alpha Z^2$，其中 $\\alpha$ 在下面指定。\n\n您必须根据有物理动机的标度律导出的特征，构建一个关于 $B$ 的线性回归模型。这些特征应从以下考虑中得出，而不是使用问题陈述中提供的简化公式：\n- 一个与 $A = Z + N$ 成比例的类体积贡献。\n- 一个与近乎不可压缩的液滴表面积成比例的类表面贡献，因此与 $A$ 的某个幂成正比。\n- 一个有限尺寸电荷分布的库仑自能贡献，依赖于 $Z$ 和原子核半径的标度关系。\n- 一个与中子-质子不平衡和费米统计相关的不对称性贡献。\n- 一个取决于 $Z$ 和 $N$ 奇偶性的对能贡献，其大小标度函数依赖于 $A$，并为偶偶核、奇奇核和奇A核规定了符号。\n\n您必须实现以下对能规定：定义带符号的对能特征 $g(A,Z,N) = s(A,Z,N) A^{-1/2}$，其中对于偶偶核（$Z$ 和 $N$ 均为偶数），$s(A,Z,N) = +1$；对于奇奇核（$Z$ 和 $N$ 均为奇数），$s(A,Z,N) = -1$；对于奇A核（$A$ 为奇数），$s(A,Z,N) = 0$。未知系数 $a_p$ 乘以 $g(A,Z,N)$。\n\n单位与常数：\n- 所有能量均以兆电子伏特（MeV）表示。\n- 使用原子质量单位到能量的转换关系，$u c^2$ 等于 $931.49410242$ MeV 每原子质量单位 $u$。\n- 使用 $m_p = 1.007276466621$ $u$，$m_n = 1.00866491588$ $u$，以及 $m_e = 0.000548579909065$ $u$。\n- 使用电子结合能修正模型 $E_e(Z) = \\alpha Z^2$，其中 $\\alpha = 14.4381$ 电子伏特。使用 $1$ 电子伏特 $= 10^{-6}$ MeV 将 $E_e(Z)$ 转换为 MeV。因此，$E_e(Z) = (1.44381 \\times 10^{-5}) Z^2$ MeV。\n\n数据：\n使用以下同位素的中性原子质量 $M_{\\text{atom}}$（单位为原子质量单位 $u$）数据集，其中包含 $(Z,N,A)$，$A = Z + N$ 以及所指示的原子质量。下面的每个数字都是以 $u$ 为单位的十进制量。\n- 氘: $(Z,N,A) = (1,1,2)$, $M_{\\text{atom}} = 2.01410177812$.\n- 氦-3: $(Z,N,A) = (2,1,3)$, $M_{\\text{atom}} = 3.01602932265$.\n- 氦-4: $(Z,N,A) = (2,2,4)$, $M_{\\text{atom}} = 4.00260325413$.\n- 碳-12: $(Z,N,A) = (6,6,12)$, $M_{\\text{atom}} = 12.0$.\n- 氮-14: $(Z,N,A) = (7,7,14)$, $M_{\\text{atom}} = 14.00307400443$.\n- 氧-16: $(Z,N,A) = (8,8,16)$, $M_{\\text{atom}} = 15.99491461957$.\n- 钙-40: $(Z,N,A) = (20,20,40)$, $M_{\\text{atom}} = 39.96259098$.\n- 钙-48: $(Z,N,A) = (20,28,48)$, $M_{\\text{atom}} = 47.95252276$.\n- 铁-56: $(Z,N,A) = (26,30,56)$, $M_{\\text{atom}} = 55.93493633$.\n- 镍-58: $(Z,N,A) = (28,30,58)$, $M_{\\text{atom}} = 57.9353429$.\n- 锆-90: $(Z,N,A) = (40,50,90)$, $M_{\\text{atom}} = 89.9047037$.\n- 铅-208: $(Z,N,A) = (82,126,208)$, $M_{\\text{atom}} = 207.9766521$.\n\n任务：\n1. 从上述基本依据出发，推导出一个关于 $B$ 的线性模型，其特征向量能够产生一个适用于普通最小二乘法的设计矩阵，未知参数 $(a_v,a_s,a_c,a_a,a_p)$ 均以 MeV 表示。\n2. 使用电子结合能修正 $E_e(Z)$ 将每个 $M_{\\text{atom}}$ 转换为 $M_{\\text{nuc}}$，并计算所有同位素的实验结合能 $B$（单位为 MeV）。\n3. 实现普通最小二乘法来拟合 $(a_v,a_s,a_c,a_a,a_p)$。\n\n测试套件：\n在三种配置下运行拟合以测试该流程：\n- 情况 1：使用上面列出的完整数据集，并包括电子结合能修正 $E_e(Z)$。\n- 情况 2：仅使用数据集中的偶偶核子集（$Z$ 和 $N$ 均为偶数），并包括电子结合能修正 $E_e(Z)$。\n- 情况 3：使用完整数据集，但忽略电子结合能修正（等效于设置 $E_e(Z) = 0$），但在将 $M_{\\text{atom}}$ 转换为 $M_{\\text{nuc}}$ 时仍然减去 $Z m_e$。\n\n对于每种情况，返回拟合的系数 $(a_v,a_s,a_c,a_a,a_p)$（以 MeV 为单位的浮点值）以及残差的均方根误差 (RMSE)（以 MeV 为单位），计算公式为 $\\sqrt{\\frac{1}{n}\\sum_i (B_i - \\hat{B}_i)^2}$，其中 $n$ 是该情况下的同位素数量，$B_i$ 是实验结合能，$\\hat{B}_i$ 是模型预测值。RMSE 必须以 MeV 表示。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的嵌套列表，该列表用方括号括起来，每个内部列表对应一种情况，并按情况 1、情况 2、情况 3 的顺序排列。每个内部列表必须包含六个浮点数结果（单位为 MeV），小数点后保留六位，顺序为 $[a_v,a_s,a_c,a_a,a_p,\\text{RMSE}]$。例如，打印的结构必须是以下形式：\n$[[a_v^{(1)},a_s^{(1)},a_c^{(1)},a_a^{(1)},a_p^{(1)},\\text{RMSE}^{(1)}],[a_v^{(2)},a_s^{(2)},a_c^{(2)},a_a^{(2)},a_p^{(2)},\\text{RMSE}^{(2)}],[a_v^{(3)},a_s^{(3)},a_c^{(3)},a_a^{(3)},a_p^{(3)},\\text{RMSE}^{(3)}]]$。", "solution": "该问题要求设计并实现一个数值计算流程，用于从给定的原子质量数据中确定半经验质量公式（SEMF）的系数。该过程涉及三个主要阶段：基于液滴模型为核结合能推导线性模型的理论基础，处理原始原子质量数据以计算实验结合能，以及应用普通最小二乘（OLS）回归来拟合模型系数。\n\n首先，我们为线性模型建立理论基础。质量数为 $A$、质子数为 $Z$、中子数为 $N = A - Z$ 的原子核，其结合能 $B$ 定义为将其分解为其组成的自由核子所需的能量。根据质能等效原理 $E=mc^2$，这由下式给出：\n$$B = Z m_p c^2 + N m_n c^2 - M_{\\text{nuc}} c^2$$\n其中 $m_p$ 是质子静止质量，$m_n$ 是中子静止质量，$M_{\\text{nuc}}$ 是原子核的质量。所提供的数据是中性原子质量 $M_{\\text{atom}}$，其包含了 $Z$ 个电子。原子核质量 $M_{\\text{nuc}}$ 是通过减去这 $Z$ 个电子的质量并加回它们的总结合能 $E_e(Z)$ 得到的：\n$$M_{\\text{nuc}} = M_{\\text{atom}} - Z m_e + \\frac{E_e(Z)}{c^2}$$\n这里，$m_e$ 是电子静止质量。问题指定了总电子结合能的模型为 $E_e(Z) = \\alpha Z^2$，其中 $\\alpha = 1.44381 \\times 10^{-5}$ MeV。综合这些，实验结合能（单位为 MeV）计算如下：\n$$B_{exp} = \\left( Z m_p + N m_n - \\left( M_{\\text{atom}} - Z m_e + \\frac{E_e(Z)}{u c^2} \\right) \\right) u c^2$$\n其中所有质量都以原子质量单位（$u$）表示，而 $u c^2 = 931.49410242$ MeV 是一个原子质量单位的能量等效值。\n\n源自原子核液滴模型的半经验质量公式，将结合能 $B$ 表示为包含五个项的总和，其系数 $(a_v, a_s, a_c, a_a, a_p)$ 是我们旨在确定的：\n$$B(A, Z) = a_v f_v - a_s f_s - a_c f_c - a_a f_a + a_p f_p$$\n特征 ($f_v, f_s, f_c, f_a, f_p$) 的函数形式源于以下物理论证：\n1.  体积项 ($f_v$)：强核力是短程且饱和的。因此，每个核子主要与其最近邻的核子相互作用。总结合能因此近似正比于核子总数 $A$。该项代表了核“液体”的体结合能。\n    $$f_v(A, Z) = A$$\n2.  表面项 ($f_s$)：位于原子核表面的核子比内部的核子邻居少，这降低了总结合能。此效应与原子核的表面积成正比。假设原子核是密度恒定的球体，其体积 $V \\propto A$。由于 $V \\propto R^3$，半径 $R \\propto A^{1/3}$。表面积与 $R^2$ 成正比。\n    $$f_s(A, Z) = A^{2/3}$$\n3.  库仑项 ($f_c$)：质子间的静电排斥也会降低结合能。一个半径为 $R$ 的球体内 $Z$ 个质子的分布所产生的势能，正比于质子对的数量 $Z(Z-1)/2$，反比于半径 $R$。对于小的 $Z$，$Z(Z-1)$ 比近似的 $Z^2$ 更准确。\n    $$f_c(A, Z) = \\frac{Z(Z-1)}{A^{1/3}}$$\n4.  不对称项 ($f_a$)：泡利不相容原理倾向于形成 $N=Z$ 的对称原子核。对于固定的质量数 $A$，偏离这种对称性（即中子过剩 $N-Z \\neq 0$）需要将核子置于更高的能级，这会消耗能量并减少结合能。这种能量惩罚与中子-质子不平衡的平方成正比，与总体积成反比。\n    $$f_a(A, Z) = \\frac{(N-Z)^2}{A} = \\frac{(A-2Z)^2}{A}$$\n5.  对能项 ($f_p$)：核子表现出形成自旋相反的相同粒子对的倾向，这会增加结合能。这导致一个修正项，其取决于 $Z$ 和 $N$ 的奇偶特性。问题指定了该特征的函数形式：\n    $$f_p(A, Z, N) = s(A,Z,N) A^{-1/2}$$\n    其中对于偶偶核，$s(A,Z,N) = +1$；对于奇奇核，$s(A,Z,N) = -1$；对于奇A核，$s(A,Z,N) = 0$。\n\n该模型对于系数 $(a_v, a_s, a_c, a_a, a_p)$ 是线性的。对于一组 $n$ 个原子核，我们可以将方程组写成矩阵形式 $\\boldsymbol{Y} = \\mathbf{X}\\boldsymbol{\\beta}$，其中：\n-   $\\boldsymbol{Y}$ 是一个 $n \\times 1$ 的列向量，其元素为实验结合能 $B_{exp,i}$。\n-   $\\boldsymbol{\\beta}$ 是一个 $5 \\times 1$ 的列向量，其元素为待拟合的未知系数：$[a_v, a_s, a_c, a_a, a_p]^T$。\n-   $\\mathbf{X}$ 是 $n \\times 5$ 的设计矩阵，其中第 $i$ 行对应第 $i$ 个原子核，由模型项构建，并已吸收其常规符号：\n    $$\\mathbf{X}_i = \\left[ A_i, \\quad -A_i^{2/3}, \\quad -\\frac{Z_i(Z_i-1)}{A_i^{1/3}}, \\quad -\\frac{(A_i-2Z_i)^2}{A_i}, \\quad s(A_i,Z_i,N_i)A_i^{-1/2} \\right]$$\n系数的普通最小二乘（OLS）估计 $\\hat{\\boldsymbol{\\beta}}$ 是使残差平方和最小化的解，由正规方程的解给出：\n$$\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\boldsymbol{Y}$$\n该解将使用稳定的线性最小二乘求解器进行数值计算。\n\n对于三个测试用例中的每一个，流程如下：\n1.  选择同位素数据的适当子集。\n2.  对于每个同位素，计算实验结合能 $B_{exp}$ 以构成向量 $\\boldsymbol{Y}$。这涉及应用电子质量修正，以及在指定情况下应用电子结合能修正。\n3.  对于每个同位素，计算五个特征值以构成设计矩阵 $\\mathbf{X}$。\n4.  使用 OLS 求解线性系统 $\\boldsymbol{Y} = \\mathbf{X}\\boldsymbol{\\beta}$ 以得到 $\\boldsymbol{\\beta}$。\n5.  使用拟合的系数 $\\hat{\\boldsymbol{\\beta}}$，计算预测的结合能 $\\hat{\\boldsymbol{Y}} = \\mathbf{X}\\hat{\\boldsymbol{\\beta}}$。\n6.  计算拟合的均方根误差（RMSE），定义为 $\\text{RMSE} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n} (Y_i - \\hat{Y}_i)^2}$。\n最终，对于每种情况，得到的系数 $(a_v,a_s,a_c,a_a,a_p)$ 和 RMSE（均以 MeV 为单位）构成了最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Constants are defined at the module level for clarity and reuse.\nUC2_MEV = 931.49410242\nM_P_U = 1.007276466621\nM_N_U = 1.00866491588\nM_E_U = 0.000548579909065\nALPHA_MEV = 1.44381e-5\n\ndef get_pairing_s(Z, N):\n    \"\"\"\n    Determines the sign coefficient for the pairing term based on proton and neutron numbers.\n    s = +1 for even-even, -1 for odd-odd, 0 for odd-A nuclei.\n    \"\"\"\n    if Z % 2 == 0 and N % 2 == 0:\n        return 1.0\n    elif Z % 2 != 0 and N % 2 != 0:\n        return -1.0\n    else:  # Odd-A nuclei\n        return 0.0\n\ndef run_semf_fit(dataset, use_electron_binding):\n    \"\"\"\n    Constructs the design matrix and target vector, then performs OLS regression.\n\n    Args:\n        dataset (list): A list of tuples, where each tuple contains\n                        (Z, N, A, M_atom_u) for a nucleus.\n        use_electron_binding (bool): Flag to include electron binding\n                                     energy correction.\n\n    Returns:\n        list: A list containing the fitted coefficients [a_v, a_s, a_c, a_a, a_p]\n              and the RMSE of the fit, all in MeV.\n    \"\"\"\n    num_isotopes = len(dataset)\n    # Design matrix X (n_samples, n_features) and target vector Y (n_samples,)\n    X = np.zeros((num_isotopes, 5))\n    Y = np.zeros(num_isotopes)\n\n    for i, datum in enumerate(dataset):\n        Z_f, N_f, A_f, M_atom_u = datum\n        Z, N, A = int(Z_f), int(N_f), int(A_f)\n\n        # 1. Calculate experimental binding energy (target vector Y)\n        E_e_mev = ALPHA_MEV * Z**2 if use_electron_binding else 0.0\n        M_nuc_u = M_atom_u - Z * M_E_U + E_e_mev / UC2_MEV\n        B_mev = (Z * M_P_U + N * M_N_U - M_nuc_u) * UC2_MEV\n        Y[i] = B_mev\n        \n        # 2. Construct features for the design matrix X\n        # The model is B = a_v*f_v + a_s*(-f_s) + a_c*(-f_c) + a_a*(-f_a) + a_p*f_p\n        # where f_v=A, f_s=A^(2/3), etc.\n        # We absorb the signs into the design matrix.\n        f_v = float(A)\n        f_s = -A**(2/3)\n        # Use Z*(Z-1) for Coulomb term, more accurate for small Z\n        f_c = -Z * (Z - 1) / A**(1/3) if A > 0 else 0.0\n        # Asymmetry term (N-Z)^2/A = (A-2Z)^2/A\n        f_a = -(A - 2*Z)**2 / A if A > 0 else 0.0\n        \n        s = get_pairing_s(Z, N)\n        f_p = s * A**(-1/2) if A > 0 else 0.0\n        \n        X[i, :] = [f_v, f_s, f_c, f_a, f_p]\n\n    # 3. Perform Ordinary Least Squares (OLS) regression\n    # np.linalg.lstsq solves Y = X*beta for beta\n    coeffs, residuals, _, _ = np.linalg.lstsq(X, Y, rcond=None)\n    \n    # 4. Calculate Root-Mean-Square Error (RMSE)\n    if residuals.size == 0:\n        # If n_samples = n_features, lstsq may return empty residuals.\n        # In this case, residuals must be computed manually.\n        Y_pred = X @ coeffs\n        res_sum_sq = np.sum((Y - Y_pred)**2)\n        rmse = np.sqrt(res_sum_sq / num_isotopes) if num_isotopes > 0 else 0.0\n    else:\n        # residuals[0] contains the sum of squared residuals\n        rmse = np.sqrt(residuals[0] / num_isotopes) if num_isotopes > 0 else 0.0\n        \n    return list(coeffs) + [rmse]\n\n\ndef solve():\n    \"\"\"\n    Main orchestrator for the problem. Defines data and test cases,\n    runs the analysis, and prints the final formatted output.\n    \"\"\"\n    # Dataset: (Z, N, A, M_atom_u)\n    # Z, N, A are integers; M_atom_u is float.\n    DATA = [\n        (1, 1, 2, 2.01410177812),   # Deuterium\n        (2, 1, 3, 3.01602932265),   # Helium-3\n        (2, 2, 4, 4.00260325413),   # Helium-4\n        (6, 6, 12, 12.0),           # Carbon-12\n        (7, 7, 14, 14.00307400443), # Nitrogen-14\n        (8, 8, 16, 15.99491461957), # Oxygen-16\n        (20, 20, 40, 39.96259098),  # Calcium-40\n        (20, 28, 48, 47.95252276),  # Calcium-48\n        (26, 30, 56, 55.93493633),  # Iron-56\n        (28, 30, 58, 57.9353429),   # Nickel-58\n        (40, 50, 90, 89.9047037),   # Zirconium-90\n        (82, 126, 208, 207.9766521) # Lead-208\n    ]\n\n    all_results = []\n\n    # Case 1: Full dataset, with electron binding energy correction\n    results_1 = run_semf_fit(DATA, use_electron_binding=True)\n    all_results.append(results_1)\n    \n    # Case 2: Even-even subset, with electron binding energy correction\n    even_even_data = [d for d in DATA if d[0] % 2 == 0 and d[1] % 2 == 0]\n    results_2 = run_semf_fit(even_even_data, use_electron_binding=True)\n    all_results.append(results_2)\n    \n    # Case 3: Full dataset, without electron binding energy correction\n    results_3 = run_semf_fit(DATA, use_electron_binding=False)\n    all_results.append(results_3)\n    \n    # Format the final output string exactly as required.\n    output_parts = []\n    for res_list in all_results:\n        formatted_list = [f\"{val:.6f}\" for val in res_list]\n        output_parts.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output_str = f\"[{','.join(output_parts)}]\"\n    print(final_output_str)\n\nsolve()\n\n```", "id": "3573765"}, {"introduction": "在更微观的理论如密度泛函理论（DFT）中，总能量是核心计算目标，但理论中的单粒子能级也并非纯粹的数学构建，它们蕴含着重要的物理信息。Koopmans 定理在原子和分子物理中将最高占据轨道的能量与电离能联系起来，然而这个简单的图像在原子核中由于强的关联和平均场重排效应而变得复杂。这项练习 [@problem_id:3573744] 旨在通过一个简化的DFT模型，让你动手检验Koopmans式的近似在核子分离能计算中的有效性，并定量分析其偏差的来源，从而深化对平均场重排和对关联等超出单粒子图像的关键物理概念的理解。", "problem": "要求您设计并实现一个数值实验，使用简化的密度泛函理论 (DFT) 类似方法，以完全自洽的有限差分结果为基准，测试用于核子分离能的 Koopmans 型估计量。您的任务是从基本原理和广泛测试过的结果出发，构建此问题，然后实现一个程序，为一小组测试核计算并比较中子和质子分离能。\n\n从以下基本依据出发：\n\n- 零温下的非相对论性简并费米气体：对于数密度为 $\\rho_q$ 的均匀费米子，其费米动量为 $k_{F,q} = \\left(3\\pi^2 \\rho_q\\right)^{1/3}$，费米动能为 $T_{F,q} = \\frac{\\hbar^2 k_{F,q}^2}{2m}$，每个粒子的动能等于 $\\frac{3}{5} T_{F,q}$。\n\n- 带双重计数校正的 Hartree 平均场：在使用单体平均场 $U_q$ 的 Hartree 描述中，在自洽条件下计算的总势能为 $\\frac{1}{2} \\sum_q N_q U_q$。\n\n- 冻结平均场中的 Koopmans 型移去能估计量：在独立粒子图像中，当忽略平均场的重排和导数不连续性时，移去种类为 $q$ 的最后一个被占据粒子的能量可以近似为费米面上单粒子能量的负值，即 $-\\varepsilon_{F,q}$。\n\n计算中使用的模型假设：\n\n- 考虑一个处于饱和密度的均匀有限核，它包含两种费米子 $q \\in \\{n,p\\}$（中子 $n$ 和质子 $p$）。设总核子数为 $A = N + Z$，各种类分数为 $x_n = N/A$ 和 $x_p = Z/A$。假设饱和密度为常数 $\\rho_0 = 0.16\\,\\text{fm}^{-3}$，因此各种类的密度为 $\\rho_n = x_n \\rho_0$ 和 $\\rho_p = x_p \\rho_0$。\n\n- 使用非相对论性核子，其中 $\\hbar^2/(2m) = 20.735\\,\\text{MeV}\\,\\text{fm}^2$。则费米动能为 $T_{F,q} = \\frac{\\hbar^2}{2m} \\left(3\\pi^2 \\rho_q\\right)^{2/3}$。\n\n- 采用与种类相关的局域平均场势，形式如下\n  $$\n  U_n(N,Z) = u_0 + u_{\\text{sym}} \\,\\delta, \\quad U_p(N,Z) = u_0 - u_{\\text{sym}} \\,\\delta + u_c \\frac{Z}{A^{1/3}},\n  $$\n  其中 $\\delta = \\frac{N-Z}{A}$ 是不对称参数。使用参数 $u_0 = -60\\,\\text{MeV}$、$u_{\\text{sym}} = 50\\,\\text{MeV}$ 和 $u_c = 1.44\\,\\text{MeV}$。\n\n- 包含一个示意性的对关联能\n  $$\n  E_{\\text{pair}}(N,Z) = -\\frac{p_0}{\\sqrt{A}} \\left(\\delta_{N \\text{ even}} + \\delta_{Z \\text{ even}}\\right),\n  $$\n  其中 $p_0 = 12\\,\\text{MeV}$，如果 $N$ 是偶数，则 $\\delta_{N \\text{ even}}$ 等于 $1$，否则为 $0$（$\\delta_{Z \\text{ even}}$ 同理）。\n\n根据上述基础，推导下列量的算法表达式：\n\n1) 在此均匀 Thomas-Fermi Hartree 模型中，给定 $(N,Z)$ 的总基态能量\n   $$\n   E(N,Z) = \\sum_{q \\in \\{n,p\\}} \\frac{3}{5} N_q T_{F,q} + \\frac{1}{2}\\left(N U_n + Z U_p\\right) + E_{\\text{pair}}(N,Z),\n   $$\n   以及相应的结合能 $B(N,Z) = -E(N,Z)$，单位为 $\\text{MeV}$。\n\n2) 完全自洽的单核子分离能，通过结合能的离散差分计算\n   $$\n   S_n(N,Z) = B(N,Z) - B(N-1,Z), \\quad S_p(N,Z) = B(N,Z) - B(N,Z-1),\n   $$\n   单位为 $\\text{MeV}$，其中 $N \\ge 1$ 且 $Z \\ge 1$。\n\n3) 通过在 $(N,Z)$ 处冻结平均场并计算费米单粒子能量得到的 Koopmans 型估计\n   $$\n   \\varepsilon_{F,q}(N,Z) = T_{F,q}(N,Z) + U_q(N,Z), \\quad S_n^{K}(N,Z) \\approx -\\varepsilon_{F,n}(N,Z), \\quad S_p^{K}(N,Z) \\approx -\\varepsilon_{F,p}(N,Z),\n   $$\n   单位为 $\\text{MeV}$。\n\n您必须实现一个程序，对下列原子核 $(N,Z)$ 测试集，计算 $S_n$、$S_n^{K}$、$S_p$ 和 $S_p^{K}$：\n\n- $(8,8)$, $(20,20)$, $(28,20)$, $(28,28)$, $(82,50)$, $(126,82)$, $(21,20)$, $(83,50)$, $(20,21)$。\n\n然后，对此测试集，还需计算以下诊断指标，以量化和解释由关联和重排效应引起的偏差：\n\n- 中子和质子的 Koopmans 误差的均方根偏差，\n  $$\n  \\text{RMS}_n = \\sqrt{\\langle \\left(S_n^{K} - S_n\\right)^2 \\rangle}, \\quad \\text{RMS}_p = \\sqrt{\\langle \\left(S_p^{K} - S_p\\right)^2 \\rangle},\n  $$\n  单位为 $\\text{MeV}$，其中 $\\langle \\cdot \\rangle$ 表示对测试集的平均。\n\n- 中子和质子的奇偶蹒跚诊断，定义为偶数和奇数粒子数的平均 Koopmans 误差之差，\n  $$\n  \\text{OES}_n = \\langle S_n^{K} - S_n \\rangle_{N \\text{ even}} - \\langle S_n^{K} - S_n \\rangle_{N \\text{ odd}},\n  $$\n  $$\n  \\text{OES}_p = \\langle S_p^{K} - S_p \\rangle_{Z \\text{ even}} - \\langle S_p^{K} - S_p \\rangle_{Z \\text{ odd}},\n  $$\n  单位为 $\\text{MeV}$。\n\n所有能量必须以 $\\text{MeV}$ 为单位表示，并四舍五入到三位小数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。各项必须按以下顺序出现：\n\n- 对于上面列出的每个测试案例，按顺序输出四个数字：$S_n$、$S_n^{K}$、$S_p$、$S_p^{K}$（每个都四舍五入到三位小数，单位为 $\\text{MeV}$）。\n- 在所有案例之后，附加 $\\text{RMS}_n$、$\\text{RMS}_p$、$\\text{OES}_n$、$\\text{OES}_p$（每个都四舍五入到三位小数，单位为 $\\text{MeV}$）。\n\n因此，最终输出格式是一个扁平的浮点数列表：\n$[S_{n,1},S_{n,1}^{K},S_{p,1},S_{p,1}^{K},\\dots,S_{n,9},S_{n,9}^{K},S_{p,9},S_{p,9}^{K},\\text{RMS}_n,\\text{RMS}_p,\\text{OES}_n,\\text{OES}_p]$。", "solution": "我们从非相对论性简并费米气体和 Hartree 平均场描述的成熟原理出发。对于每种粒子 $q \\in \\{n,p\\}$，其数量为 $N_q$，数密度为 $\\rho_q$，费米动量为 $k_{F,q} = \\left(3\\pi^2 \\rho_q\\right)^{1/3}$，费米动能为 $T_{F,q} = \\frac{\\hbar^2 k_{F,q}^2}{2m}$。每个粒子的动能等于 $\\frac{3}{5} T_{F,q}$；因此，种类 $q$ 的总动能为 $E_{\\text{kin},q} = \\frac{3}{5} N_q T_{F,q}$。对所有种类求和可得\n$$\nE_{\\text{kin}}(N,Z) = \\frac{3}{5} \\left(N T_{F,n} + Z T_{F,p}\\right),\n$$\n其中 $T_{F,q}$ 依赖于 $\\rho_q$。\n\n我们假设一个处于饱和密度 $\\rho_0 = 0.16\\,\\text{fm}^{-3}$ 的均匀有限核，其总核子数为 $A = N+Z$，各种类分数为 $x_n = \\frac{N}{A}$ 和 $x_p = \\frac{Z}{A}$。对于每种粒子，$\\rho_q = x_q \\rho_0$。那么费米动能为\n$$\nT_{F,q}(N,Z) = \\frac{\\hbar^2}{2m} \\left(3\\pi^2 x_q \\rho_0\\right)^{2/3}, \\quad \\frac{\\hbar^2}{2m} = 20.735\\,\\text{MeV}\\,\\text{fm}^2.\n$$\n\n在 Hartree 平均场模型中，总势能由在自洽密度下计算的、对所有占据粒子平均场的求和的一半给出，\n$$\nE_{\\text{mf}}(N,Z) = \\frac{1}{2}\\left(N U_n(N,Z) + Z U_p(N,Z)\\right).\n$$\n我们假设一个平均场，它由一个同位旋标量深度 $u_0$、一个与不对称参数 $\\delta = \\frac{N-Z}{A}$ 成正比（强度为 $u_{\\text{sym}}$）的同位旋矢量项，以及一个与 $Z/A^{1/3}$ 成比例（强度为 $u_c$）的质子库仑项组成：\n$$\nU_n(N,Z) = u_0 + u_{\\text{sym}} \\,\\delta, \\quad U_p(N,Z) = u_0 - u_{\\text{sym}} \\,\\delta + u_c \\frac{Z}{A^{1/3}}.\n$$\n我们设定 $u_0 = -60\\,\\text{MeV}$、$u_{\\text{sym}} = 50\\,\\text{MeV}$ 和 $u_c = 1.44\\,\\text{MeV}$。\n\n为了在示意性层面上引入对关联，我们添加一个唯象项\n$$\nE_{\\text{pair}}(N,Z) = -\\frac{p_0}{\\sqrt{A}} \\left(\\delta_{N \\text{ even}} + \\delta_{Z \\text{ even}}\\right),\n$$\n其中 $p_0 = 12\\,\\text{MeV}$，如果 $N$ 是偶数，则 $\\delta_{N \\text{ even}}$ 等于 $1$，否则为 $0$（$\\delta_{Z \\text{ even}}$ 同理）。该项为偶数粒子数提供额外结合能，而对奇数粒子数则为零，从而模拟奇偶蹒跚效应。\n\n总能量和结合能则如下\n$$\nE(N,Z) = E_{\\text{kin}}(N,Z) + E_{\\text{mf}}(N,Z) + E_{\\text{pair}}(N,Z), \\quad B(N,Z) = -E(N,Z),\n$$\n单位为 $\\text{MeV}$。\n\n完全自洽的分离能通过结合能的有限差分计算：\n$$\nS_n(N,Z) = B(N,Z) - B(N-1,Z), \\quad S_p(N,Z) = B(N,Z) - B(N,Z-1),\n$$\n单位为 $\\text{MeV}$，其中 $N \\ge 1$ 且 $Z \\ge 1$。此过程对应于为 $(N-1,Z)$ 和 $(N,Z-1)$ 系统重新计算密度、费米动能和平均场，从而包含了由于 $A$ 的变化、不对称参数 $\\delta$ 的变化以及库仑项贡献所引起的重排效应。\n\nKoopmans 型估计量基于冻结平均场近似：移去一个粒子而不允许平均场弛豫。在这种情况下，移去能近似为费米面上单粒子能量的负值。费米面上的类 Kohn-Sham 单粒子能量等于该种类费米动能与平均场势之和，\n$$\n\\varepsilon_{F,q}(N,Z) = T_{F,q}(N,Z) + U_q(N,Z).\n$$\n因此，\n$$\nS_n^{K}(N,Z) \\approx -\\varepsilon_{F,n}(N,Z) = -\\left[T_{F,n}(N,Z) + U_n(N,Z)\\right], \\quad\nS_p^{K}(N,Z) \\approx -\\varepsilon_{F,p}(N,Z) = -\\left[T_{F,p}(N,Z) + U_p(N,Z)\\right].\n$$\n该估计量忽略了两个物理上重要的偏差来源：(i) 平均场重排（$(N,Z)$ 与 $(N-1,Z)$ 或 $(N,Z-1)$ 之间的密度和场的改变）和 (ii) 显式关联能（如对关联 $E_{\\text{pair}}$），这些并未在单粒子本征值中体现。\n\n为量化该估计量在一组原子核上的性能，我们计算每种情况下的 Koopmans 误差 $S_n^{K} - S_n$ 和 $S_p^{K} - S_p$，然后报告\n$$\n\\text{RMS}_n = \\sqrt{\\left\\langle \\left(S_n^{K} - S_n\\right)^2 \\right\\rangle}, \\quad\n\\text{RMS}_p = \\sqrt{\\left\\langle \\left(S_p^{K} - S_p\\right)^2 \\right\\rangle},\n$$\n作为均方根偏差，单位均为 $\\text{MeV}$。为诊断由对关联驱动的奇偶效应，我们还计算\n$$\n\\text{OES}_n = \\langle S_n^{K} - S_n \\rangle_{N \\text{ even}} - \\langle S_n^{K} - S_n \\rangle_{N \\text{ odd}}, \\quad\n\\text{OES}_p = \\langle S_p^{K} - S_p \\rangle_{Z \\text{ even}} - \\langle S_p^{K} - S_p \\rangle_{Z \\text{ odd}},\n$$\n如果 Koopmans 倾向于对偶数系统更强地高估分离能（因为 $E_{\\text{pair}}$ 贡献了冻结场估计量所遗漏的额外结合能），则该值应为正。\n\n算法实现细节：\n\n- 计算 $x_n = N/A$、$x_p = Z/A$，然后计算 $\\rho_n = x_n \\rho_0$ 和 $\\rho_p = x_p \\rho_0$。\n- 对 $q \\in \\{n,p\\}$ 计算 $T_{F,q} = \\frac{\\hbar^2}{2m} \\left(3\\pi^2 \\rho_q\\right)^{2/3}$。\n- 计算 $\\delta = \\frac{N-Z}{A}$，然后计算 $U_n$ 和 $U_p$。\n- 计算 $E_{\\text{kin}} = \\frac{3}{5} \\left(N T_{F,n} + Z T_{F,p}\\right)$。\n- 计算 $E_{\\text{mf}} = \\frac{1}{2} \\left(N U_n + Z U_p\\right)$。\n- 计算 $E_{\\text{pair}} = -\\frac{p_0}{\\sqrt{A}} \\left(\\delta_{N \\text{ even}} + \\delta_{Z \\text{ even}}\\right)$。\n- 计算 $E(N,Z)$ 和 $B(N,Z) = -E(N,Z)$。\n- 通过 $B$ 的有限差分计算 $S_n$ 和 $S_p$。\n- 根据 $(N,Z)$ 处的负费米单粒子能量计算 $S_n^{K}$ 和 $S_p^{K}$。\n- 对于测试集 $(N,Z) = (8,8), (20,20), (28,20), (28,28), (82,50), (126,82), (21,20), (83,50), (20,21)$，计算并收集每种情况下的 $S_n$、$S_n^{K}$、$S_p$、$S_p^{K}$。\n- 在整个测试集上计算 $\\text{RMS}_n$、$\\text{RMS}_p$、$\\text{OES}_n$ 和 $\\text{OES}_p$。\n- 所有能量以 $\\text{MeV}$ 表示，四舍五入到三位小数，并按指定的扁平列表格式打印单行输出。\n\n这种构造在物理上和数值上是自洽的：在这个均匀的 Thomas-Fermi 图像中，动能与 $A$ 成比例，平均场部分提供了带有同位旋矢量对称性和库仑贡献的同位旋标量结合深度，而对关联则引入了 Koopmans 估计量无法捕捉的奇偶蹒跚效应。因此，这些偏差可以诊断平均场重排和关联效应。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants and model parameters\nHBAR2_OVER_2M = 20.735  # MeV fm^2\nRHO0 = 0.16             # fm^-3\nU0 = -60.0              # MeV (isoscalar mean-field depth)\nU_SYM = 50.0            # MeV (isovector strength)\nU_C = 1.44              # MeV (Coulomb strength)\nP0 = 12.0               # MeV (pairing parameter)\n\ndef fermi_kinetic_energy(x_fraction: float) -> float:\n    \"\"\"\n    Compute the Fermi kinetic energy T_F for a species with fraction x = N_q / A\n    in a uniform system at saturation density RHO0.\n    T_F = (hbar^2 / 2m) * (3*pi^2 * rho_q)^(2/3), rho_q = x * RHO0\n    \"\"\"\n    rho_q = x_fraction * RHO0\n    # Guard against numerical issues for x=0 (though not relevant for provided test cases)\n    if rho_q == 0.0:\n        return 0.0\n    return HBAR2_OVER_2M * (3.0 * np.pi**2 * rho_q) ** (2.0 / 3.0)\n\ndef mean_fields(N: int, Z: int) -> tuple[float, float]:\n    \"\"\"\n    Compute neutron and proton mean fields U_n and U_p at (N,Z):\n      U_n = U0 + U_SYM * delta\n      U_p = U0 - U_SYM * delta + U_C * Z / A^(1/3)\n    where delta = (N - Z) / A\n    \"\"\"\n    A = N + Z\n    if A == 0:\n        return 0.0, 0.0\n    delta = (N - Z) / A\n    Un = U0 + U_SYM * delta\n    Up = U0 - U_SYM * delta + U_C * Z / (A ** (1.0 / 3.0))\n    return Un, Up\n\ndef pairing_energy(N: int, Z: int) -> float:\n    \"\"\"\n    Schematic pairing correlation energy:\n      E_pair = - P0 / sqrt(A) * (delta_N_even + delta_Z_even)\n    \"\"\"\n    A = N + Z\n    if A == 0:\n        return 0.0\n    delta_N_even = 1 if (N % 2 == 0) else 0\n    delta_Z_even = 1 if (Z % 2 == 0) else 0\n    return -P0 / np.sqrt(A) * (delta_N_even + delta_Z_even)\n\ndef total_energy(N: int, Z: int) -> float:\n    \"\"\"\n    Total energy E(N,Z) = E_kin + E_mf + E_pair.\n    \"\"\"\n    A = N + Z\n    if A == 0:\n        return 0.0\n    xn = N / A\n    xp = Z / A\n    TFn = fermi_kinetic_energy(xn)\n    TFp = fermi_kinetic_energy(xp)\n    Un, Up = mean_fields(N, Z)\n    Ekin = (3.0 / 5.0) * (N * TFn + Z * TFp)\n    Emf = 0.5 * (N * Un + Z * Up)\n    Epair = pairing_energy(N, Z)\n    return Ekin + Emf + Epair\n\ndef binding_energy(N: int, Z: int) -> float:\n    \"\"\"\n    Binding energy B = -E.\n    \"\"\"\n    return -total_energy(N, Z)\n\ndef separation_neutron(N: int, Z: int) -> float:\n    \"\"\"\n    Neutron separation energy S_n = B(N,Z) - B(N-1,Z), for N >= 1.\n    \"\"\"\n    if N == 0:\n        raise ValueError(\"N must be >= 1 for neutron separation energy.\")\n    return binding_energy(N, Z) - binding_energy(N - 1, Z)\n\ndef separation_proton(N: int, Z: int) -> float:\n    \"\"\"\n    Proton separation energy S_p = B(N,Z) - B(N,Z-1), for Z >= 1.\n    \"\"\"\n    if Z == 0:\n        raise ValueError(\"Z must be >= 1 for proton separation energy.\")\n    return binding_energy(N, Z) - binding_energy(N, Z - 1)\n\ndef koopmans_estimates(N: int, Z: int) -> tuple[float, float]:\n    \"\"\"\n    Koopmans-style estimates:\n      S_n^K = -[ T_Fn(N,Z) + U_n(N,Z) ]\n      S_p^K = -[ T_Fp(N,Z) + U_p(N,Z) ]\n    \"\"\"\n    A = N + Z\n    xn = N / A\n    xp = Z / A\n    TFn = fermi_kinetic_energy(xn)\n    TFp = fermi_kinetic_energy(xp)\n    Un, Up = mean_fields(N, Z)\n    SnK = -(TFn + Un)\n    SpK = -(TFp + Up)\n    return SnK, SpK\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (8, 8),\n        (20, 20),\n        (28, 20),\n        (28, 28),\n        (82, 50),\n        (126, 82),\n        (21, 20),\n        (83, 50),\n        (20, 21),\n    ]\n\n    results = []\n    errors_n = []\n    errors_p = []\n    parity_n_even = []\n    parity_z_even = []\n\n    for (N, Z) in test_cases:\n        # Compute fully self-consistent separation energies\n        Sn = separation_neutron(N, Z)\n        Sp = separation_proton(N, Z)\n        # Koopmans estimates\n        SnK, SpK = koopmans_estimates(N, Z)\n\n        # Round to three decimals for output\n        results.extend([round(Sn, 3), round(SnK, 3), round(Sp, 3), round(SpK, 3)])\n\n        # Accumulate errors for diagnostics (use unrounded values)\n        err_n = SnK - Sn\n        err_p = SpK - Sp\n        errors_n.append(err_n)\n        errors_p.append(err_p)\n        parity_n_even.append(1 if (N % 2 == 0) else 0)\n        parity_z_even.append(1 if (Z % 2 == 0) else 0)\n\n    # Diagnostics: RMS errors\n    errors_n_arr = np.array(errors_n, dtype=float)\n    errors_p_arr = np.array(errors_p, dtype=float)\n    rms_n = float(np.sqrt(np.mean(errors_n_arr ** 2)))\n    rms_p = float(np.sqrt(np.mean(errors_p_arr ** 2)))\n\n    # Odd-even staggering diagnostics: difference between mean error for even and odd\n    parity_n_even_arr = np.array(parity_n_even, dtype=int)\n    parity_z_even_arr = np.array(parity_z_even, dtype=int)\n\n    # For neutrons\n    even_idx_n = parity_n_even_arr == 1\n    odd_idx_n = parity_n_even_arr == 0\n    mean_err_n_even = float(np.mean(errors_n_arr[even_idx_n])) if np.any(even_idx_n) else 0.0\n    mean_err_n_odd = float(np.mean(errors_n_arr[odd_idx_n])) if np.any(odd_idx_n) else 0.0\n    oes_n = mean_err_n_even - mean_err_n_odd\n\n    # For protons\n    even_idx_p = parity_z_even_arr == 1\n    odd_idx_p = parity_z_even_arr == 0\n    mean_err_p_even = float(np.mean(errors_p_arr[even_idx_p])) if np.any(even_idx_p) else 0.0\n    mean_err_p_odd = float(np.mean(errors_p_arr[odd_idx_p])) if np.any(odd_idx_p) else 0.0\n    oes_p = mean_err_p_even - mean_err_p_odd\n\n    # Append diagnostics to results, rounded to three decimals\n    results.extend([round(rms_n, 3), round(rms_p, 3), round(oes_n, 3), round(oes_p, 3)])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3573744"}]}