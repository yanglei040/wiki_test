{"hands_on_practices": [{"introduction": "在构建复杂的等变模型之前，理解其必要性至关重要。本练习将通过一个反例，清晰地揭示标准神经网络在物理建模中的一个根本缺陷。我们将看到，一个直接使用笛卡尔坐标的“朴素”网络所预测的力矢量 $\\mathbf{F}$，在坐标系旋转后并不遵循正确的协变关系，从而违背了基础物理原理。通过亲手计算并量化这种旋转协变性误差，您将深刻体会到为何等变架构是解决此类问题的关键 [@problem_id:3449440]。", "problem": "考虑一个计算材料科学的场景，其中原子间作用力由一个学习型能量模型预测。在一个物理上有效的模型中，力必须满足旋转协变性：如果一个构型绕单位轴 $\\hat{\\mathbf{a}}$ 旋转一个角度 $\\theta$，那么力矢量也必须经过相同的刚体旋转。一个将原始笛卡尔坐标直接映射到标量能量而没有构建旋转不变特征的学习型能量模型可能是非等变的，并产生违反旋转协变性的力，即使在底层物理需要协变性的情况下也是如此。目标是构建一个最小的、明确的反例，并在指定的测试旋转下量化协变误差。\n\n从以下基本基础出发：\n- 经典力学中的旋转对称性：描述一个没有外场的孤立系统的标量能量 $E$ 必须在刚体旋转下保持不变；由 $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} E$ 定义的力在旋转下必须像协变矢量一样变换。\n- 多变量微积分的链式法则：如果 $\\mathbf{y} = \\mathbf{R}\\mathbf{x}$，其中 $\\mathbf{R}$ 是三维空间特殊正交群中的一个正交旋转矩阵，那么梯度将以由雅可比矩阵决定的方式进行变换。\n\n定义一个直接依赖于原始笛卡尔坐标的非等变人工神经网络（ANN）能量模型。对于一个由 $N$ 个原子组成的系统，其位置为 $\\mathbf{r}_i \\in \\mathbb{R}^3$，通过拼接将坐标堆叠成一个单一向量 $\\mathbf{x} \\in \\mathbb{R}^{3N}$。设能量定义为\n$$\nE(\\mathbf{x}) = \\sum_{h=1}^{H} \\alpha_h \\tanh\\!\\big( \\mathbf{w}_h^\\top \\mathbf{x} + b_h \\big) + c,\n$$\n其中 $H$ 是隐藏单元的数量，$\\mathbf{w}_h \\in \\mathbb{R}^{3N}$ 是权重矩阵 $W_1 \\in \\mathbb{R}^{H \\times 3N}$ 的行， $b_h \\in \\mathbb{R}$ 是偏置，$\\alpha_h \\in \\mathbb{R}$ 是输出权重， $c \\in \\mathbb{R}$ 是一个标量偏移。这个 ANN 被刻意构造成非等变的：它在原始笛卡尔坐标上使用各向异性权重，没有任何保持对称性的架构。\n\n力被定义为能量相对于堆叠坐标的负梯度：\n$$\n\\mathbf{F}(\\mathbf{x}) = -\\nabla_{\\mathbf{x}} E(\\mathbf{x}) \\in \\mathbb{R}^{3N}.\n$$\n当一个构型绕轴 $\\hat{\\mathbf{a}}$ 旋转角度 $\\theta$ 时，令 $\\mathbf{R}(\\theta,\\hat{\\mathbf{a}}) \\in \\mathbb{R}^{3 \\times 3}$ 为相应的旋转矩阵。旋转后的构型是 $\\mathbf{x}_{\\mathrm{rot}} = (\\mathrm{I}_N \\otimes \\mathbf{R}(\\theta,\\hat{\\mathbf{a}})) \\mathbf{x}$，其中 $\\mathrm{I}_N$ 是 $N \\times N$ 的单位矩阵，$\\otimes$ 表示克罗内克积。一个旋转协变模型应满足\n$$\n\\mathbf{F}_{\\mathrm{cov}}(\\mathbf{x}_{\\mathrm{rot}}) = (\\mathrm{I}_N \\otimes \\mathbf{R}(\\theta,\\hat{\\mathbf{a}})) \\mathbf{F}(\\mathbf{x}),\n$$\n但这个非等变的 ANN 通常不会满足此条件。\n\n通过相对误差来量化旋转协变性的违反程度\n$$\n\\varepsilon(\\theta,\\hat{\\mathbf{a}}) = \\frac{\\left\\| (\\mathrm{I}_N \\otimes \\mathbf{R}(\\theta,\\hat{\\mathbf{a}})) \\mathbf{F}(\\mathbf{x}) - \\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}}) \\right\\|_2}{\\max\\!\\big(\\left\\| (\\mathrm{I}_N \\otimes \\mathbf{R}(\\theta,\\hat{\\mathbf{a}})) \\mathbf{F}(\\mathbf{x}) \\right\\|_2, \\epsilon\\big)},\n$$\n其中 $\\|\\cdot\\|_2$ 是欧几里得范数，$\\epsilon$ 是一个小的正常数，以避免除以零。在本练习中，所有量都是无量纲的。\n\n使用以下具有 $N=3$ 个原子的显式、固定的分子构型：\n$$\n\\mathbf{r}_1 = \\begin{bmatrix}0.0\\\\0.0\\\\0.0\\end{bmatrix},\\quad\n\\mathbf{r}_2 = \\begin{bmatrix}1.2\\\\0.5\\\\-0.3\\end{bmatrix},\\quad\n\\mathbf{r}_3 = \\begin{bmatrix}-0.8\\\\-1.0\\\\0.7\\end{bmatrix}.\n$$\n按 $\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3$ 的顺序将它们拼接堆叠成 $\\mathbf{x} \\in \\mathbb{R}^{9}$。\n\n使用以下 ANN 参数，其中 $H=3$ 且 $3N=9$：\n$$\nW_1 = \\begin{bmatrix}\n0.8  -0.4  0.2  0.1  0.6  -0.3  -0.5  0.7  -0.2 \\\\\n-0.3  0.9  -0.6  0.4  -0.1  0.5  0.2  -0.8  0.3 \\\\\n0.5  0.2  0.7  -0.9  0.3  -0.4  0.6  -0.1  0.8\n\\end{bmatrix},\\quad\n\\mathbf{b}_1=\\begin{bmatrix}0.1\\\\-0.2\\\\0.05\\end{bmatrix},\\quad\n\\boldsymbol{\\alpha}=\\begin{bmatrix}1.2\\\\-0.7\\\\0.9\\end{bmatrix},\\quad\nc=0.1.\n$$\n\n使用单位轴 $\\hat{\\mathbf{a}}$ 和角度 $\\theta$（以弧度为单位），通过罗德里格斯旋转公式实现 $\\mathbf{R}(\\theta,\\hat{\\mathbf{a}})$。\n\n测试套件：\n为以下五个情况计算 $\\varepsilon(\\theta,\\hat{\\mathbf{a}})$，这些情况共同探测了正常路径、边界条件和一般轴向：\n- 情况 1：$\\theta = 0$，$\\hat{\\mathbf{a}} = \\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}$。\n- 情况 2：$\\theta = \\pi/6$，$\\hat{\\mathbf{a}} = \\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}$。\n- 情况 3：$\\theta = \\pi/2$，$\\hat{\\mathbf{a}} = \\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}$。\n- 情况 4：$\\theta = \\pi$，$\\hat{\\mathbf{a}} = \\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}$。\n- 情况 5：$\\theta = \\pi/3$，$\\hat{\\mathbf{a}} = \\dfrac{1}{\\sqrt{3}}\\begin{bmatrix}1\\\\1\\\\1\\end{bmatrix}$。\n\n答案规格和输出格式：\n- 对于每个测试用例，返回一个等于 $\\varepsilon(\\theta,\\hat{\\mathbf{a}})$ 的浮点数。\n- 你的程序应该生成单行输出，包含一个用方括号括起来的逗号分隔列表，例如 $\\big[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4,\\varepsilon_5\\big]$。\n- 角度必须以弧度为单位解释。不使用物理单位；所有量都是无量纲的。", "solution": "该问题要求计算一个非等变神经网络势的旋转协变误差。解决方案首先从给定的能量模型中推导出原子间作用力的解析表达式，然后实现旋转操作，最后为一组测试用例计算指定的误差度量。\n\n### 步骤 1：系统和模型定义\n\n该系统由 $N=3$ 个原子组成，其初始笛卡尔坐标为 $\\mathbf{r}_i \\in \\mathbb{R}^3$：\n$$\n\\mathbf{r}_1 = \\begin{bmatrix}0.0\\\\0.0\\\\0.0\\end{bmatrix},\\quad\n\\mathbf{r}_2 = \\begin{bmatrix}1.2\\\\0.5\\\\-0.3\\end{bmatrix},\\quad\n\\mathbf{r}_3 = \\begin{bmatrix}-0.8\\\\-1.0\\\\0.7\\end{bmatrix}\n$$\n这些被拼接成一个单一的状态向量 $\\mathbf{x} \\in \\mathbb{R}^{3N} = \\mathbb{R}^9$：\n$$\n\\mathbf{x} = \\begin{bmatrix} \\mathbf{r}_1 \\\\ \\mathbf{r}_2 \\\\ \\mathbf{r}_3 \\end{bmatrix} = \\begin{bmatrix} 0.0, 0.0, 0.0, 1.2, 0.5, -0.3, -0.8, -1.0, 0.7 \\end{bmatrix}^\\top\n$$\n能量 $E(\\mathbf{x})$ 由一个具有 $H=3$ 个隐藏单元的单隐藏层人工神经网络（ANN）定义：\n$$\nE(\\mathbf{x}) = \\sum_{h=1}^{H} \\alpha_h \\tanh\\!\\big( \\mathbf{w}_h^\\top \\mathbf{x} + b_h \\big) + c\n$$\n这里，$\\mathbf{w}_h^\\top$ 代表权重矩阵 $W_1 \\in \\mathbb{R}^{H \\times 3N}$ 的第 $h$ 行。给定的参数是：\n$$\nW_1 = \\begin{bmatrix}\n0.8  -0.4  0.2  0.1  0.6  -0.3  -0.5  0.7  -0.2 \\\\\n-0.3  0.9  -0.6  0.4  -0.1  0.5  0.2  -0.8  0.3 \\\\\n0.5  0.2  0.7  -0.9  0.3  -0.4  0.6  -0.1  0.8\n\\end{bmatrix},\\quad\n\\mathbf{b}_1=\\begin{bmatrix}0.1\\\\-0.2\\\\0.05\\end{bmatrix},\\quad\n\\boldsymbol{\\alpha}=\\begin{bmatrix}1.2\\\\-0.7\\\\0.9\\end{bmatrix},\\quad\nc=0.1\n$$\n\n### 步骤 2：力矢量的推导\n\n力矢量 $\\mathbf{F}(\\mathbf{x}) \\in \\mathbb{R}^{3N}$ 是标量能量 $E(\\mathbf{x})$ 相对于坐标 $\\mathbf{x}$ 的负梯度：\n$$\n\\mathbf{F}(\\mathbf{x}) = -\\nabla_{\\mathbf{x}} E(\\mathbf{x})\n$$\n我们使用链式法则计算梯度。令第 $h$ 个隐藏单元的激活前值为 $u_h(\\mathbf{x}) = \\mathbf{w}_h^\\top \\mathbf{x} + b_h$。能量的梯度是：\n$$\n\\nabla_{\\mathbf{x}} E(\\mathbf{x}) = \\nabla_{\\mathbf{x}} \\left( \\sum_{h=1}^{H} \\alpha_h \\tanh(u_h(\\mathbf{x})) + c \\right) = \\sum_{h=1}^{H} \\alpha_h \\nabla_{\\mathbf{x}} (\\tanh(u_h(\\mathbf{x})))\n$$\n对每一项应用链式法则：\n$$\n\\nabla_{\\mathbf{x}} (\\tanh(u_h(\\mathbf{x}))) = \\frac{d}{du_h}(\\tanh(u_h)) \\cdot \\nabla_{\\mathbf{x}} u_h\n$$\n$\\tanh$ 的导数是 $\\text{sech}^2(u_h)$，可以表示为 $1 - \\tanh^2(u_h)$。$u_h$ 的梯度是 $\\nabla_{\\mathbf{x}} (\\mathbf{w}_h^\\top \\mathbf{x} + b_h) = \\mathbf{w}_h$。将这些代回得到：\n$$\n\\nabla_{\\mathbf{x}} E(\\mathbf{x}) = \\sum_{h=1}^{H} \\alpha_h \\left( 1 - \\tanh^2(\\mathbf{w}_h^\\top \\mathbf{x} + b_h) \\right) \\mathbf{w}_h\n$$\n因此，力矢量是：\n$$\n\\mathbf{F}(\\mathbf{x}) = - \\sum_{h=1}^{H} \\alpha_h \\left( 1 - \\tanh^2(\\mathbf{w}_h^\\top \\mathbf{x} + b_h) \\right) \\mathbf{w}_h\n$$\n在矩阵表示法中，这可以更紧凑地写为：\n$$\n\\mathbf{F}(\\mathbf{x}) = -W_1^\\top \\big( \\boldsymbol{\\alpha} \\odot \\text{sech}^2(W_1 \\mathbf{x} + \\mathbf{b}_1) \\big)\n$$\n其中 $\\odot$ 表示逐元素（哈达玛）积。该表达式为计算任何给定构型 $\\mathbf{x}$ 的力矢量提供了一个直接的方法。\n\n### 步骤 3：旋转算子\n\n在 $\\mathbb{R}^3$ 中绕单位轴 $\\hat{\\mathbf{a}}$ 旋转角度 $\\theta$ 的操作由一个 $3 \\times 3$ 矩阵 $\\mathbf{R}(\\theta, \\hat{\\mathbf{a}})$ 表示，该矩阵使用 Rodrigues' 旋转公式构建：\n$$\n\\mathbf{R}(\\theta, \\hat{\\mathbf{a}}) = \\mathbf{I}_3 + \\sin(\\theta)\\mathbf{K} + (1 - \\cos(\\theta))\\mathbf{K}^2\n$$\n其中 $\\mathbf{I}_3$ 是 $3 \\times 3$ 单位矩阵，$\\mathbf{K}$ 是 $\\hat{\\mathbf{a}} = [a_x, a_y, a_z]^\\top$ 的叉积矩阵：\n$$\n\\mathbf{K} = \\begin{bmatrix} 0  -a_z  a_y \\\\ a_z  0  -a_x \\\\ -a_y  a_x  0 \\end{bmatrix}\n$$\n为了旋转整个 $N$ 原子系统，我们将此旋转应用于每个原子的坐标矢量。这是通过使用克罗内克积形成的块对角矩阵来实现的：\n$$\n\\mathbf{R}_{\\text{block}} = \\mathbf{I}_N \\otimes \\mathbf{R}(\\theta,\\hat{\\mathbf{a}})\n$$\n对于 $N=3$，这将得到一个 $9 \\times 9$ 矩阵。\n\n### 步骤 4：协变误差的公式化\n\n问题的核心是量化旋转协变性的违反程度。旋转后的构型是 $\\mathbf{x}_{\\mathrm{rot}} = \\mathbf{R}_{\\text{block}} \\mathbf{x}$。在此新构型上计算出的力是 $\\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}})$。\n\n对于一个真正的协变模型，力矢量会随系统进行刚性旋转。正确变换后的力矢量，记为 $\\mathbf{F}_{\\mathrm{cov}}$，是通过将相同的旋转应用于原始力矢量得到的：\n$$\n\\mathbf{F}_{\\mathrm{cov}} = \\mathbf{R}_{\\text{block}} \\mathbf{F}(\\mathbf{x})\n$$\n旋转协变误差 $\\varepsilon$ 是在旋转系统上计算的力 $\\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}})$ 与旋转后的原始力 $\\mathbf{F}_{\\mathrm{cov}}$ 之间的相对差异：\n$$\n\\varepsilon(\\theta,\\hat{\\mathbf{a}}) = \\frac{\\left\\| \\mathbf{F}_{\\mathrm{cov}} - \\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}}) \\right\\|_2}{\\max\\!\\big(\\left\\| \\mathbf{F}_{\\mathrm{cov}} \\right\\|_2, \\epsilon\\big)}\n$$\n其中 $\\|\\cdot\\|_2$ 是欧几里得范数，$\\epsilon$ 是一个小的正常数（例如 $10^{-9}$），用于防止除以零或接近零的数。\n\n### 步骤 5：计算算法\n\n对于每个测试用例 $(\\theta, \\hat{\\mathbf{a}})$：\n1.  使用步骤 2 中推导的解析公式计算原始力矢量 $\\mathbf{F}(\\mathbf{x})$。\n2.  使用 Rodrigues' 公式构建 $3 \\times 3$ 旋转矩阵 $\\mathbf{R}(\\theta, \\hat{\\mathbf{a}})$。\n3.  构建 $9 \\times 9$ 块旋转矩阵 $\\mathbf{R}_{\\text{block}} = \\mathbf{I}_3 \\otimes \\mathbf{R}(\\theta, \\hat{\\mathbf{a}})$。\n4.  计算正确变换后的力矢量：$\\mathbf{F}_{\\mathrm{cov}} = \\mathbf{R}_{\\text{block}} \\mathbf{F}(\\mathbf{x})$。\n5.  计算旋转后的坐标矢量：$\\mathbf{x}_{\\mathrm{rot}} = \\mathbf{R}_{\\text{block}} \\mathbf{x}$。\n6.  计算旋转构型上的力矢量：$\\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}})$。\n7.  计算差异的 L2 范数：$\\|\\mathbf{F}_{\\mathrm{cov}} - \\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}})\\|_2$。\n8.  计算参考力的 L2 范数：$\\|\\mathbf{F}_{\\mathrm{cov}}\\|_2$。\n9.  使用步骤 4 中的公式计算最终误差 $\\varepsilon$。\n\n此过程将对五个指定的测试用例执行。$\\theta=0$ 的情况用作合理性检查，因为它对应于单位旋转，必须产生 $0$ 的误差。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the rotational covariance error for a non-equivariant ANN potential.\n    \"\"\"\n    \n    # --- Step 1: Define Givens (System and Model Parameters) ---\n    N = 3\n    \n    r1 = np.array([0.0, 0.0, 0.0])\n    r2 = np.array([1.2, 0.5, -0.3])\n    r3 = np.array([-0.8, -1.0, 0.7])\n    x = np.concatenate((r1, r2, r3))\n\n    W1 = np.array([\n        [0.8, -0.4, 0.2, 0.1, 0.6, -0.3, -0.5, 0.7, -0.2],\n        [-0.3, 0.9, -0.6, 0.4, -0.1, 0.5, 0.2, -0.8, 0.3],\n        [0.5, 0.2, 0.7, -0.9, 0.3, -0.4, 0.6, -0.1, 0.8]\n    ])\n\n    b1 = np.array([0.1, -0.2, 0.05])\n    alpha = np.array([1.2, -0.7, 0.9])\n    \n    # Small constant for denominator stabilization, as per the problem statement\n    epsilon_small = 1e-9\n\n    # --- Step 2: Define Helper Functions ---\n    \n    def calculate_force(pos_vec):\n        \"\"\"\n        Calculates the force F(x) = -nabla_x E(x) based on the derived formula.\n        \"\"\"\n        # u = W1 @ x + b1\n        u = W1 @ pos_vec + b1\n        \n        # sech^2(u) = 1 - tanh^2(u)\n        tanh_u = np.tanh(u)\n        sech_sq_u = 1.0 - tanh_u**2\n        \n        # v = alpha .* sech^2(u)\n        v = alpha * sech_sq_u\n        \n        # gradient = W1^T @ v\n        gradient = W1.T @ v\n        \n        force = -gradient\n        return force\n\n    def rodrigues_rotation(theta, axis):\n        \"\"\"\n        Computes the 3x3 rotation matrix R(theta, a_hat) via Rodrigues' formula.\n        \"\"\"\n        # Ensure the axis is a unit vector\n        axis = axis / np.linalg.norm(axis)\n        ax, ay, az = axis\n        \n        K = np.array([\n            [0, -az, ay],\n            [az, 0, -ax],\n            [-ay, ax, 0]\n        ])\n        \n        I = np.eye(3)\n        R = I + np.sin(theta) * K + (1 - np.cos(theta)) * (K @ K)\n        return R\n\n    # --- Step 3: Define Test Suite ---\n    test_cases = [\n        # Case 1: theta = 0, a_hat = [0, 0, 1]\n        (0.0, np.array([0.0, 0.0, 1.0])),\n        # Case 2: theta = pi/6, a_hat = [0, 0, 1]\n        (np.pi / 6, np.array([0.0, 0.0, 1.0])),\n        # Case 3: theta = pi/2, a_hat = [0, 0, 1]\n        (np.pi / 2, np.array([0.0, 0.0, 1.0])),\n        # Case 4: theta = pi, a_hat = [0, 0, 1]\n        (np.pi, np.array([0.0, 0.0, 1.0])),\n        # Case 5: theta = pi/3, a_hat = [1, 1, 1] / sqrt(3)\n        (np.pi / 3, np.array([1.0, 1.0, 1.0]) / np.sqrt(3))\n    ]\n\n    results = []\n\n    # --- Step 4: Execute Test Cases and Calculate Error ---\n    for theta, a_hat in test_cases:\n        # Calculate force on the original configuration\n        F_x = calculate_force(x)\n\n        # Construct the rotation matrices\n        R_3x3 = rodrigues_rotation(theta, a_hat)\n        R_block = np.kron(np.eye(N), R_3x3)\n\n        # Calculate the covariantly transformed force\n        F_cov = R_block @ F_x\n\n        # Calculate the rotated configuration\n        x_rot = R_block @ x\n\n        # Calculate the force on the rotated configuration\n        F_x_rot = calculate_force(x_rot)\n\n        # Calculate the error numerator and denominator\n        numerator = np.linalg.norm(F_cov - F_x_rot)\n        denominator = np.linalg.norm(F_cov)\n        \n        # Calculate the relative error\n        error = numerator / max(denominator, epsilon_small)\n        results.append(error)\n        \n    # --- Step 5: Format and Print Final Answer ---\n    print(f\"[{','.join(f'{res:.6f}' for res in results)}]\")\n\nsolve()\n```", "id": "3449440"}, {"introduction": "认识到传统方法的局限性后，我们自然会探寻解决方案的核心：使用在旋转下具有明确变换性质的特征。本练习将带您深入等变网络的基本构建模块，即由球谐函数（$Y_{\\ell m}$）构成的特征。您将亲自构建一个矢量型特征（秩为1，即 $\\ell=1$），并用数值方法验证它在旋转下的变换行为是否严格遵循相应的维格纳D矩阵（$D^{(1)}$）的预测。这个实践将抽象的群论与具体的计算联系起来，让您掌握构造等变特征的实用技能 [@problem_id:3449495]。", "problem": "要求您通过直接数值计算，验证一个由复球谐函数构建的秩-1（向量）特征在刚性旋转下的等变变换。在三维特殊正交群（SO(3)）中，使用 $Z\\text{-}Y\\text{-}Z$ 欧拉角约定进行计算。\n\n定义与基本依据：\n- 令 $\\hat{\\mathbf{r}} = (x,y,z)/\\|\\,(x,y,z)\\,\\|$ 为 $\\mathbb{R}^3$ 中的一个单位方向。球坐标角度 $\\theta \\in [0,\\pi]$ 和 $\\phi \\in [0,2\\pi)$ 定义为 $\\theta = \\arccos(z)$ 和 $\\phi = \\operatorname{atan2}(y,x)$。\n- 令 $Y_{\\ell m}(\\theta,\\phi)$ 为复球谐函数，采用 Condon–Shortley 相位约定和物理学惯例（磁量子数 $m$ 作为第一个参数），其中 $\\ell \\in \\mathbb{N}_0$ 且 $m \\in \\{-\\ell,\\ldots,\\ell\\}$。\n- 对于一个具有实数权重 $\\{w_i\\}_{i=1}^{N}$ 的有限邻域方向集合 $\\{\\hat{\\mathbf{r}}_i\\}_{i=1}^{N}$，定义 $\\ell=1$ 的特征向量，其分量为\n$$\nF_m \\;=\\; \\sum_{i=1}^{N} w_i \\, Y_{1m}(\\theta_i,\\phi_i),\n\\quad m \\in \\{1,0,-1\\},\n$$\n其中 $(\\theta_i,\\phi_i)$ 是 $\\hat{\\mathbf{r}}_i$ 的球坐标角度。\n- 令旋转 $R \\in \\mathrm{SO}(3)$ 由 $Z\\text{-}Y\\text{-}Z$ 欧拉角 $(\\alpha,\\beta,\\gamma)$（以弧度为单位）参数化。在 $\\ell=1$ 不可约表示中，相关的 Wigner D-矩阵 $D^{(1)}(R)\\in \\mathbb{C}^{3\\times 3}$（其行和列按 $m=1,0,-1$ 排序）为\n$$\nD^{(1)}_{m m'}(\\alpha,\\beta,\\gamma) \\;=\\; e^{-i m \\alpha}\\, d^{(1)}_{m m'}(\\beta)\\, e^{-i m' \\gamma},\n$$\n其中 $\\ell=1$ 的 Wigner 小-d 矩阵元为\n$$\n\\begin{aligned}\nd^{(1)}_{1,1}(\\beta) = \\tfrac{1+\\cos\\beta}{2}, \\quad \nd^{(1)}_{1,0}(\\beta) = -\\tfrac{\\sin\\beta}{\\sqrt{2}}, \\quad \nd^{(1)}_{1,-1}(\\beta) = \\tfrac{1-\\cos\\beta}{2}, \\\\\nd^{(1)}_{0,1}(\\beta) = \\tfrac{\\sin\\beta}{\\sqrt{2}}, \\quad \nd^{(1)}_{0,0}(\\beta) = \\cos\\beta, \\quad \nd^{(1)}_{0,-1}(\\beta) = -\\tfrac{\\sin\\beta}{\\sqrt{2}}, \\\\\nd^{(1)}_{-1,1}(\\beta) = \\tfrac{1-\\cos\\beta}{2}, \\quad \nd^{(1)}_{-1,0}(\\beta) = \\tfrac{\\sin\\beta}{\\sqrt{2}}, \\quad \nd^{(1)}_{-1,-1}(\\beta) = \\tfrac{1+\\cos\\beta}{2}.\n\\end{aligned}\n$$\n- 基本变换定律：对于方向的主动旋转 $\\hat{\\mathbf{r}}_i \\mapsto R\\,\\hat{\\mathbf{r}}_i$，球谐函数满足\n$$\nY_{1m}(\\widehat{R\\,\\mathbf{r}}) \\;=\\; \\sum_{m'=-1}^{1} D^{(1)}_{m m'}(R^{-1}) \\, Y_{1m'}(\\hat{\\mathbf{r}}),\n$$\n这表明等变特征的变换方式为\n$$\nF^{\\mathrm{rot}}_m \\;=\\; \\sum_{m'=-1}^{1} D^{(1)}_{m m'}(R^{-1})\\, F_{m'},\n$$\n其中 $F^{\\mathrm{rot}}_m$ 是由旋转后的邻域方向构建的。角度必须以弧度为单位。\n\n您的任务：\n- 实现一个程序，对于下方的每个测试用例，该程序需要：从提供的邻域向量和权重构建 $F$，通过指定的旋转 $R$（使用 $Z\\text{-}Y\\text{-}Z$ 约定）旋转所有邻域方向，从旋转后的方向构建 $F^{\\mathrm{rot}}$，计算 $D^{(1)}(R)$，然后形成 $D^{(1)}(R^{-1}) = \\left(D^{(1)}(R)\\right)^{\\dagger}$，最后报告最大绝对分量差异\n$$\n\\varepsilon \\;=\\; \\max_{m \\in \\{1,0,-1\\}} \\left|\\, F^{\\mathrm{rot}}_m \\;-\\; \\sum_{m'=-1}^{1} D^{(1)}_{m m'}(R^{-1})\\,F_{m'} \\,\\right|.\n$$\n- 所有计算必须使用上述定义。在提取 $(\\theta,\\phi)$ 之前，邻域方向向量必须归一化为单位长度。三角函数和球谐函数必须使用弧度。差异 $\\varepsilon$ 是一个非负实数浮点数。\n\n测试套件（请严格使用这三个用例）：\n- 用例 1（一般旋转）：\n  - 邻域向量（每个格式为 $(x,y,z)$）：$(1,0,0)$, $(0,1,0)$, $(0,0,1)$, $(-1,-1,1)$。\n  - 权重：$[1.0,\\,0.5,\\,-0.7,\\,1.2]$。\n  - 欧拉角 $(\\alpha,\\beta,\\gamma)$（以弧度为单位）：$(0.7,\\,1.1,\\,-0.4)$。\n- 用例 2（单位旋转边界）：\n  - 邻域向量：$(2,1,0)$, $(0,-3,1)$, $(-1,0,2)$, $(1,-1,-1)$。\n  - 权重：$[1.0,\\,-0.3,\\,2.0,\\,-1.0]$。\n  - 欧拉角：$(0.0,\\,0.0,\\,0.0)$。\n- 用例 3（绕 z 轴旋转 $\\pi$ 的纯旋转）：\n  - 邻域向量：$(1.0,\\,0.0,\\,0.2)$, $(0.3,\\,0.953939,\\,-0.4)$, $(-0.588,\\,-0.809,\\,0.7)$。\n  - 权重：$[0.8,\\,-1.1,\\,0.6]$。\n  - 欧拉角：$(\\pi,\\,0.0,\\,0.0)$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的结果。结果应为一个用方括号括起来的逗号分隔列表，按用例 1、2、3 的顺序排列，例如 $[x_1,x_2,x_3]$，其中每个 $x_k$ 是用例 $k$ 的浮点数 $\\varepsilon$。", "solution": "用户要求对一个由复球谐函数构建的秩-1特征向量的旋转等变性进行数值验证。这个问题定义明确，其科学基础在于旋转群 $\\mathrm{SO}(3)$ 的表示论，并为获得唯一解提供了所有必要的定义和数据。\n\n核心任务是为三个测试用例计算差异 $\\varepsilon$，其中 $\\varepsilon$ 定义为：\n$$\n\\varepsilon \\;=\\; \\max_{m \\in \\{1,0,-1\\}} \\left|\\, F^{\\mathrm{rot}}_m \\;-\\; \\sum_{m'=-1}^{1} D^{(1)}_{m m'}(R^{-1})\\,F_{m'} \\,\\right|\n$$\n这涉及到对变换后的特征向量进行两次独立的计算：\n1. “直接”变换 $F^{\\mathrm{rot}}$：首先在 $\\mathbb{R}^3$ 中旋转输入坐标，然后对这些新坐标执行特征向量的构建流程。\n2. “等变”变换 $F^{\\mathrm{equiv}}$：通过将相应的 Wigner D-矩阵 $D^{(1)}(R^{-1})$ 应用于原始特征向量 $F$ 来计算。\n\n验证过程在于证明 $F^{\\mathrm{rot}}$ 和 $F^{\\mathrm{equiv}}$ 在浮点精度范围内数值上是相同的。值 $\\varepsilon$ 量化了它们之间的差异。\n\n每个测试用例的计算步骤如下：\n\n**步骤 1：球谐函数的实现**\n特征向量依赖于角动量 $\\ell=1$ 的复球谐函数。根据 Condon–Shortley 相位约定，所需的函数为：\n$$\n\\begin{aligned}\nY_{1,1}(\\theta, \\phi) = -\\sqrt{\\frac{3}{8\\pi}} \\sin\\theta \\, e^{i\\phi} \\\\\nY_{1,0}(\\theta, \\phi) = \\sqrt{\\frac{3}{4\\pi}} \\cos\\theta \\\\\nY_{1,-1}(\\theta, \\phi) = \\sqrt{\\frac{3}{8\\pi}} \\sin\\theta \\, e^{-i\\phi}\n\\end{aligned}\n$$\n这些函数以弧度为单位的球坐标角度 $(\\theta, \\phi)$ 作为输入。\n\n**步骤 2：坐标与特征向量计算（旋转前）**\n对于给定的一组邻域向量 $\\{\\mathbf{r}_i\\}_{i=1}^{N}$ 和权重 $\\{w_i\\}_{i=1}^{N}$：\n1. 归一化每个邻域向量：$\\hat{\\mathbf{r}}_i = \\mathbf{r}_i / \\|\\mathbf{r}_i\\|$。\n2. 将每个 $\\hat{\\mathbf{r}}_i$ 的笛卡尔坐标 $(x_i, y_i, z_i)$ 转换为球坐标 $(\\theta_i, \\phi_i)$。给定 $\\hat{\\mathbf{r}}_i=(x_i,y_i,z_i)$，转换公式为 $\\theta_i = \\arccos(z_i)$ 和 $\\phi_i = \\operatorname{atan2}(y_i, x_i)$。\n3. 构建原始特征向量 $F$，它是一个由 $m \\in \\{1, 0, -1\\}$ 索引的 3 分量复数向量。其分量为：\n$$\nF_m \\;=\\; \\sum_{i=1}^{N} w_i \\, Y_{1m}(\\theta_i,\\phi_i)\n$$\n\n**步骤 3：直接变换（在 $\\mathbb{R}^3$ 中旋转）**\n1. 根据给定的 $Z\\text{-}Y\\text{-}Z$ 欧拉角 $(\\alpha, \\beta, \\gamma)$ 构建笛卡尔旋转矩阵 $R(\\alpha, \\beta, \\gamma) \\in \\mathrm{SO}(3)$。该矩阵是 $R = R_z(\\alpha) R_y(\\beta) R_z(\\gamma)$ 的乘积，其中 $R_z$ 和 $R_y$ 是绕相应轴的标准旋转矩阵。\n2. 将此旋转应用于每个原始单位向量：$\\hat{\\mathbf{r}}_i^{\\mathrm{rot}} = R\\,\\hat{\\mathbf{r}}_i$。\n3. 将每个 $\\hat{\\mathbf{r}}_i^{\\mathrm{rot}}$ 的所得笛卡尔坐标转换为一组新的球坐标 $(\\theta_i^{\\mathrm{rot}}, \\phi_i^{\\mathrm{rot}})$。\n4. 使用这些新的球坐标和原始权重构建旋转后的特征向量 $F^{\\mathrm{rot}}$：\n$$\nF^{\\mathrm{rot}}_m \\;=\\; \\sum_{i=1}^{N} w_i \\, Y_{1m}(\\theta_i^{\\mathrm{rot}},\\phi_i^{\\mathrm{rot}})\n$$\n\n**步骤 4：等变变换（在表示空间中旋转）**\n1. 使用欧拉角 $(\\alpha, \\beta, \\gamma)$ 构建 $\\ell=1$ 的 Wigner D-矩阵 $D^{(1)}(R) \\in \\mathbb{C}^{3\\times 3}$。其矩阵元由下式给出：\n$$\nD^{(1)}_{m m'}(\\alpha,\\beta,\\gamma) \\;=\\; e^{-i m \\alpha}\\, d^{(1)}_{m m'}(\\beta)\\, e^{-i m' \\gamma}\n$$\n矩阵的行和列按 $m, m' \\in \\{1, 0, -1\\}$ 排序。小-d 矩阵元 $d^{(1)}_{mm'}(\\beta)$ 在问题描述中已提供。\n2. 变换定律需要逆旋转 $R^{-1}$ 的矩阵。对于 $\\mathrm{SO}(3)$ 的幺正表示，这是正向旋转矩阵的共轭转置：$D^{(1)}(R^{-1}) = (D^{(1)}(R))^{\\dagger}$。\n3. 通过矩阵-向量乘法将此变换应用于原始特征向量 $F$，以获得等变变换后的向量 $F^{\\mathrm{equiv}}$：\n$$\nF^{\\mathrm{equiv}}_m \\;=\\; \\sum_{m'=-1}^{1} D^{(1)}_{m m'}(R^{-1})\\,F_{m'}\n$$\n\n**步骤 5：差异计算**\n最后，计算两个结果向量 $F^{\\mathrm{rot}}$ 和 $F^{\\mathrm{equiv}}$ 各分量之间差的绝对值的最大值：\n$$\n\\varepsilon \\;=\\; \\max_{m \\in \\{1,0,-1\\}} \\left|\\, F^{\\mathrm{rot}}_m - F^{\\mathrm{equiv}}_m \\,\\right|\n$$\n如果实现正确，该值应接近机器精度（例如，$\\approx 10^{-15}$），从而证实等变性质。以下程序为三个指定的测试用例实现了此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Verifies the equivariant transformation of a rank-1 spherical harmonic feature.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"neighbors\": np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, -1.0, 1.0]]),\n            \"weights\": np.array([1.0, 0.5, -0.7, 1.2]),\n            \"euler_angles\": np.array([0.7, 1.1, -0.4]),\n        },\n        {\n            \"neighbors\": np.array([[2.0, 1.0, 0.0], [0.0, -3.0, 1.0], [-1.0, 0.0, 2.0], [1.0, -1.0, -1.0]]),\n            \"weights\": np.array([1.0, -0.3, 2.0, -1.0]),\n            \"euler_angles\": np.array([0.0, 0.0, 0.0]),\n        },\n        {\n            \"neighbors\": np.array([[1.0, 0.0, 0.2], [0.3, 0.953939, -0.4], [-0.588, -0.809, 0.7]]),\n            \"weights\": np.array([0.8, -1.1, 0.6]),\n            \"euler_angles\": np.array([np.pi, 0.0, 0.0]),\n        },\n    ]\n\n    results = []\n    \n    # m-values ordering for feature vectors and Wigner matrices\n    m_vals = np.array([1, 0, -1])\n\n    def get_spherical_harmonics_l1(theta, phi):\n        \"\"\"\n        Computes Y_1m(theta, phi) for m=1,0,-1.\n        Vectorized over theta and phi.\n        \"\"\"\n        c1 = np.sqrt(3 / (8 * np.pi))\n        c0 = np.sqrt(3 / (4 * np.pi))\n        \n        sin_theta = np.sin(theta)\n        cos_theta = np.cos(theta)\n        \n        y11 = -c1 * sin_theta * np.exp(1j * phi)\n        y10 =  c0 * cos_theta\n        y1m1 = c1 * sin_theta * np.exp(-1j * phi)\n        \n        # Return in order m=1, 0, -1\n        return np.array([y11, y10, y1m1])\n\n    def get_feature_vector(neighbors, weights):\n        \"\"\"\n        Computes the feature vector F_m from neighbors and weights.\n        \"\"\"\n        norms = np.linalg.norm(neighbors, axis=1)\n        unit_vectors = neighbors / norms[:, np.newaxis]\n        \n        x, y, z = unit_vectors.T\n        \n        theta = np.arccos(z)\n        phi = np.arctan2(y, x)\n        \n        y1m_vals = get_spherical_harmonics_l1(theta, phi) # Shape (3, N)\n        \n        # F_m = sum_i w_i Y_1m(theta_i, phi_i)\n        # weights are (N,), y1m_vals are (3, N), broadcasting does the trick\n        F = np.sum(weights * y1m_vals, axis=1) # Shape (3,)\n        return F, unit_vectors\n\n    def get_rotation_matrix(alpha, beta, gamma):\n        \"\"\"\n        Computes the Z-Y-Z Euler rotation matrix.\n        \"\"\"\n        ca, sa = np.cos(alpha), np.sin(alpha)\n        cb, sb = np.cos(beta), np.sin(beta)\n        cg, sg = np.cos(gamma), np.sin(gamma)\n        \n        Rz_a = np.array([[ca, -sa, 0], [sa, ca, 0], [0, 0, 1]])\n        Ry_b = np.array([[cb, 0, sb], [0, 1, 0], [-sb, 0, cb]])\n        Rz_g = np.array([[cg, -sg, 0], [sg, cg, 0], [0, 0, 1]])\n        \n        return Rz_a @ Ry_b @ Rz_g\n\n    def get_wigner_d1_matrix(alpha, beta, gamma):\n        \"\"\"\n        Computes the Wigner D-matrix for l=1.\n        Rows/cols are ordered by m=1, 0, -1.\n        \"\"\"\n        cb, sb = np.cos(beta), np.sin(beta)\n        sqrt2 = np.sqrt(2)\n        \n        # Wigner small-d matrix for l=1\n        d1 = np.array([\n            [(1 + cb) / 2, -sb / sqrt2, (1 - cb) / 2],\n            [sb / sqrt2,        cb,    -sb / sqrt2],\n            [(1 - cb) / 2,  sb / sqrt2, (1 + cb) / 2]\n        ])\n        \n        exp_a = np.exp(-1j * m_vals * alpha)\n        exp_g = np.exp(-1j * m_vals * gamma)\n        \n        # D(R) = diag(exp(-im*alpha)) * d(beta) * diag(exp(-im'*gamma))\n        D1 = np.diag(exp_a) @ d1 @ np.diag(exp_g)\n        return D1\n\n    for case in test_cases:\n        neighbors = case[\"neighbors\"]\n        weights = case[\"weights\"]\n        alpha, beta, gamma = case[\"euler_angles\"]\n\n        # 1. Compute original feature vector F\n        F, unit_vectors = get_feature_vector(neighbors, weights)\n        \n        # 2. Compute rotated feature vector F_rot by rotating coordinates\n        R_cartesian = get_rotation_matrix(alpha, beta, gamma)\n        rotated_unit_vectors = (R_cartesian @ unit_vectors.T).T\n        F_rot, _ = get_feature_vector(rotated_unit_vectors, weights)\n        \n        # 3. Compute transformed vector F_equiv using Wigner D-matrix\n        D1_R = get_wigner_d1_matrix(alpha, beta, gamma)\n        # D(R^-1) = D(R)^dagger for unitary representations\n        D1_R_inv = D1_R.conj().T\n        F_equiv = D1_R_inv @ F\n        \n        # 4. Calculate the discrepancy\n        discrepancy = np.max(np.abs(F_rot - F_equiv))\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    # Use a format specifier for consistent scientific notation.\n    print(f\"[{','.join(f'{r:.17e}' for r in results)}]\")\n\nsolve()\n```", "id": "3449495"}, {"introduction": "在理解了问题的根源和解决方案的基石之后，是时候将所有部件组装成一个完整的、可工作的模型了。这个综合性练习将指导您从零开始构建一个双层的E(3)等变消息传递网络。您将实现等变张量积来组合原子特征，并通过消息传递机制在原子间传播信息，最终输出一个旋转不变的能量（$E$）。通过这个顶点实践，您能将前面学到的所有核心概念融会贯通，亲身体验构建一个小型但功能完备的ENNP并验证其端到端的对称性 [@problem_id:3449494]。", "problem": "你需要从第一性原理出发，为一个小型分子构建一个最小但非平凡的二维欧几里得群（E(3)）等变消息传递神经网络。该网络必须处理分解为三维特殊正交群（SO(3)）不可约表示的节点特征，特别是度为 $l=0$ 的标量特征和度为 $l=1$ 的向量特征。你将仅使用等变耦合的数学规则以及一组指定的标量权重和径向函数，对一组固定的测试配置执行显式的前向传播。最终输出必须是单行文本，其中包含为所提供的测试套件计算出的一组浮点数结果。\n\n基本原理和约束：\n- 三维欧几里得群（E(3)）的对称性通过旋转和平移作用于点的坐标。旋转等变性定义为向量特征根据 $l=1$ 不可约表示进行变换，而标量特征保持不变。平移仅影响相对位置，因此使用相对位移可以确保平移不变性。\n- 对于每个从节点 $j$ 指向节点 $i$ 的有向边，设位移为 $\\mathbf{r}_{ij} = \\mathbf{x}_{j} - \\mathbf{x}_{i}$，距离为 $r_{ij} = \\|\\mathbf{r}_{ij}\\|$，单位方向为 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / r_{ij}$。在由矩阵 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 表示的旋转下，诸如 $\\mathbf{r}$ 的向量和 $l=1$ 特征变换为 $\\mathbf{v} \\mapsto \\mathbf{R} \\mathbf{v}$，标量保持不变，而诸如 $\\mathbf{u} \\cdot \\mathbf{v}$ 的内积也保持不变。\n- 在 $l \\in \\{0, 1\\}$ 级别上的等变张量积可以通过以下耦合实现：\n  - 标量-标量到标量：$0 \\otimes 0 \\rightarrow 0$，通过乘以一个标量径向包络。\n  - 向量-向量到标量：$1 \\otimes 1 \\rightarrow 0$，通过点积。\n  - 标量-向量和向量-标量到向量：$0 \\otimes 1 \\rightarrow 1$ 和 $1 \\otimes 0 \\rightarrow 1$，通过用标量缩放向量。\n  - 向量-向量到向量：$1 \\otimes 1 \\rightarrow 1$，通过将一个向量投影到另一个向量的方向上，例如 $(\\mathbf{v} \\cdot \\hat{\\mathbf{r}})\\,\\hat{\\mathbf{r}}$。\n- 使用平滑的径向包络以确保局部性和连续性：对于截断半径 $R_{c}$ 和径向衰减常数 $\\alpha$，定义\n  $$\\phi(r) = \\exp(-\\alpha r), \\quad f_{\\mathrm{cut}}(r) = \\begin{cases} \\tfrac{1}{2}\\left(\\cos\\left(\\pi r / R_{c}\\right)+1\\right),  r \\le R_{c} \\\\ 0,  r > R_{c} \\end{cases}, \\quad s(r) = \\phi(r)\\, f_{\\mathrm{cut}}(r).$$\n\n架构和前向传播规范：\n- 在第 $l \\in \\{0, 1, 2\\}$ 层，节点带有标量特征 $s^{(l)}_{i} \\in \\mathbb{R}$ 和向量特征 $\\mathbf{v}^{(l)}_{i} \\in \\mathbb{R}^{3}$。\n- 初始化使用一个嵌入，将原子序数 $Z$ 映射到一个初始标量和向量：\n  - 对于 $Z=1$ （氢），$s^{(0)} = 0.7$，$\\mathbf{v}^{(0)} = (0, 0, 0)$。\n  - 对于 $Z=6$ （碳），$s^{(0)} = 0.4$，$\\mathbf{v}^{(0)} = (0, 0, 0)$。\n  - 对于 $Z=8$ （氧），$s^{(0)} = -0.2$，$\\mathbf{v}^{(0)} = (0, 0, 0)$。\n- 不存在自环。节点 $i$ 在第 $l$ 层的消息通过对所有 $j \\neq i$ 求和进行聚合：\n  - 标量消息：\n    $$m^{(l)}_{0,i} = \\sum_{j \\ne i} \\left( w^{(l)}_{00}\\, s(r_{ij})\\, s^{(l)}_{j} + w^{(l)}_{11\\rightarrow 0}\\, s(r_{ij})\\, \\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij} \\right).$$\n  - 向量消息：\n    $$\\mathbf{m}^{(l)}_{1,i} = \\sum_{j \\ne i} \\left( w^{(l)}_{01}\\, s(r_{ij})\\, s^{(l)}_{j}\\, \\hat{\\mathbf{r}}_{ij} + w^{(l)}_{10}\\, s(r_{ij})\\, \\mathbf{v}^{(l)}_{j} + w^{(l)}_{11\\rightarrow 1}\\, s(r_{ij})\\, (\\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij})\\, \\hat{\\mathbf{r}}_{ij} \\right).$$\n- 特征更新对于标量是仿射的，对于向量是线性的：\n  $$s^{(l+1)}_{i} = a^{(l)}_{0}\\, s^{(l)}_{i} + b^{(l)}_{0}\\, m^{(l)}_{0,i} + \\mathrm{bias}^{(l)}_{0}, \\quad \\mathbf{v}^{(l+1)}_{i} = a^{(l)}_{1}\\, \\mathbf{v}^{(l)}_{i} + b^{(l)}_{1}\\, \\mathbf{m}^{(l)}_{1,i}.$$\n- 读出过程为每个节点生成一个不变的能量贡献，该贡献结合了标量和向量的平方范数：\n  $$e_{i} = c_{0}\\, s^{(2)}_{i} + c_{1}\\, \\|\\mathbf{v}^{(2)}_{i}\\|^{2}, \\quad E = \\sum_{i} e_{i}.$$\n\n超参数和权重：\n- 截断半径 $R_{c} = 2.5$，径向衰减 $\\alpha = 1.0$，在各层之间共享。\n- 第 $l=0$ 层权重：\n  - $w^{(0)}_{00} = 0.8$, $w^{(0)}_{11\\rightarrow 0} = 0.3$, $w^{(0)}_{01} = 1.1$, $w^{(0)}_{10} = 0.5$, $w^{(0)}_{11\\rightarrow 1} = 0.7$。\n  - $a^{(0)}_{0} = 0.9$, $b^{(0)}_{0} = 1.2$, $\\mathrm{bias}^{(0)}_{0} = 0.05$。\n  - $a^{(0)}_{1} = 0.8$, $b^{(0)}_{1} = 1.0$。\n- 第 $l=1$ 层权重：\n  - $w^{(1)}_{00} = -0.4$, $w^{(1)}_{11\\rightarrow 0} = 0.2$, $w^{(1)}_{01} = 0.6$, $w^{(1)}_{10} = 0.9$, $w^{(1)}_{11\\rightarrow 1} = -0.3$。\n  - $a^{(1)}_{0} = 1.1$, $b^{(1)}_{0} = 0.7$, $\\mathrm{bias}^{(1)}_{0} = -0.02$。\n  - $a^{(1)}_{1} = 0.95$, $b^{(1)}_{1} = 0.85$。\n- 读出权重：$c_{0} = 1.3$, $c_{1} = 0.2$。\n\n分子构型的测试套件和所需输出：\n- 所有坐标单位为埃，最终能量单位为任意能量单位。角度单位必须为弧度。\n- 情况1（类水几何结构）：三个原子及其原子序数和位置\n  - $Z = 8$ 位于 $(0.0, 0.0, 0.0)$，\n  - $Z = 1$ 位于 $(0.9572, 0.0, 0.0)$，\n  - $Z = 1$ 位于 $(-0.2390, 0.9270, 0.0)$。\n  计算 $E_{1}$。\n- 情况2（旋转后的情况1）：将情况1的所有位置绕z轴旋转角度 $\\theta = 0.61$ 以获得新构型。计算 $E_{2}$，然后计算绝对差 $\\Delta = |E_{1} - E_{2}|$ 作为此情况的结果。\n- 情况3（超出截断半径）：两个原子\n  - $Z = 6$ 位于 $(0.0, 0.0, 0.0)$，\n  - $Z = 1$ 位于 $(3.0, 0.0, 0.0)$。\n  计算 $E_{3}$。\n- 情况4（具有截断边界的共线三原子）：三个原子\n  - $Z = 6$ 位于 $(0.0, 0.0, 0.0)$，\n  - $Z = 6$ 位于 $(1.25, 0.0, 0.0)$，\n  - $Z = 6$ 位于 $(2.5, 0.0, 0.0)$。\n  计算 $E_{4}$。\n\n对你的程序的要求：\n- 严格按照规定，使用给定的权重、特征和径向函数，实现指定的两层等变消息传递网络。使用成对的有向边，不含自环。向量耦合使用单位方向 $\\hat{\\mathbf{r}}_{ij}$。\n- 通过避免除以零来确保数值稳定性；在此设置中，由于没有自环，$r_{ij} = 0$ 不会发生。\n- 按如下方式计算四个案例的结果：第一个元素是 $E_{1}$，第二个是情况2的 $\\Delta$，第三个是 $E_{3}$，第四个是 $E_{4}$。\n- 输出格式：你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如，`[result1,result2,result3,result4]`）。每个浮点数结果必须四舍五入到6位小数。", "solution": "该问题要求构建并实现一个两层、三维欧几里得群（E(3)）等变的消息传递神经网络，以计算小分子构型的势能。该解决方案遵循了指定的架构、权重和数学原理。\n\nE(3)等变网络的基本原理是其操作必须尊重三维空间的对称性：平移、旋转和反演。对于一个原子系统，势能 $E$ 必须在整个系统的任何刚性平移或旋转下保持不变。\n\n1.  **对称性考量**：\n    - **平移不变性**：通过让网络操作于相对位置向量 $\\mathbf{r}_{ij} = \\mathbf{x}_{j} - \\mathbf{x}_{i}$ 而非绝对坐标 $\\mathbf{x}_i$ 来实现。由于 $\\mathbf{r}_{ij}$ 在全局平移 $\\mathbf{x}_k \\mapsto \\mathbf{x}_k + \\mathbf{t}$（对所有 $k$）下是不变的，所有基于这些位移的后续计算也将是平移不变的。\n    - **旋转等变性**：通过根据特征在特殊正交群 SO(3) 下的变换性质来表征它们，从而实现旋转等变性。特征被分解为不可约表示（irreps），由一个度 $l \\in \\{0, 1, 2, \\dots\\}$ 索引。在此问题中，我们只考虑标量特征（度 $l=0$，在旋转下不变）和向量特征（度 $l=1$，像坐标向量一样旋转）。如果对输入进行旋转然后执行操作，其结果与先执行操作然后旋转其输出相同，则该操作是等变的。对于像能量这样的最终不变物理量，网络必须在中间层是等变的，并以一个不变的读出层结束。\n\n2.  **网络架构**：该网络由三个阶段组成：初始化、两层消息传递和最终的能量读出。\n\n    - **特征初始化（第 $l=0$ 层）**：每个原子 $i$ 根据其原子序数 $Z_i$ 被初始化一个标量特征 $s^{(0)}_{i}$ 和一个向量特征 $\\mathbf{v}^{(0)}_{i}$。按照规定，初始向量特征 $\\mathbf{v}^{(0)}_{i}$ 均为零向量，即 $\\mathbf{v}^{(0)}_{i} = (0, 0, 0)$，这是平凡等变的。初始标量特征是每种元素类型的常数：对于 $Z=1$，$s^{(0)} = 0.7$；对于 $Z=6$，$s^{(0)} = 0.4$；对于 $Z=8$，$s^{(0)} = -0.2$。\n\n    - **消息传递（第 $l=0, 1$ 层）**：在每一层 $l$，每个原子 $i$ 从所有其他原子 $j \\neq i$ 接收消息。这些消息是使用原子 $j$ 的特征与来自相对位置向量 $\\mathbf{r}_{ij}$ 的几何信息的等变张量积构建的。\n      - 几何信息被编码在距离 $r_{ij} = \\|\\mathbf{r}_{ij}\\|$ 和方向向量 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / r_{ij}$ 中。\n      - 一个径向函数 $s(r) = \\exp(-\\alpha r) \\cdot \\frac{1}{2}(\\cos(\\pi r / R_{c})+1)$（对于 $r \\le R_c$）和 $s(r)=0$（对于 $r > R_c$）被用于为所有相互作用提供一个可学习的、平滑的、局域的（在截断半径 $R_c$ 内）权重。给定的参数为 $R_c=2.5$ 和 $\\alpha=1.0$。\n      - **标量消息 $m^{(l)}_{0,i}$**：标量消息是一个不变量（度 $l=0$）。它通过对邻居 $j$ 的两种不变项求和形成：\n        1.  $s^{(l)}_j \\cdot s(r_{ij})$：两个标量的乘积（类型 $0 \\otimes 0 \\to 0$），由 $w^{(l)}_{00}$ 加权。\n        2.  $(\\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij}) \\cdot s(r_{ij})$：两个向量的点积（类型 $1 \\otimes 1 \\to 0$），由 $w^{(l)}_{11\\rightarrow 0}$ 加权。\n        原子 $i$ 的总标量消息为：\n        $$m^{(l)}_{0,i} = \\sum_{j \\ne i} s(r_{ij}) \\left( w^{(l)}_{00} s^{(l)}_{j} + w^{(l)}_{11\\rightarrow 0} \\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij} \\right)$$\n      - **向量消息 $\\mathbf{m}^{(l)}_{1,i}$**：向量消息是一个等变向量（度 $l=1$）。它是三个等变向量项的和：\n        1.  $s^{(l)}_{j} \\hat{\\mathbf{r}}_{ij} \\cdot s(r_{ij})$：一个标量乘以一个向量（类型 $0 \\otimes 1 \\to 1$），由 $w^{(l)}_{01}$ 加权。\n        2.  $\\mathbf{v}^{(l)}_{j} \\cdot s(r_{ij})$：一个类标量的径向函数乘以一个向量（类型 $1 \\otimes 0 \\to 1$），由 $w^{(l)}_{10}$ 加权。\n        3.  $(\\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij}) \\hat{\\mathbf{r}}_{ij} \\cdot s(r_{ij})$：一个向量到另一个向量的投影（类型 $1 \\otimes 1 \\to 1$），由 $w^{(l)}_{11\\rightarrow 1}$ 加权。\n        原子 $i$ 的总向量消息为：\n        $$\\mathbf{m}^{(l)}_{1,i} = \\sum_{j \\ne i} s(r_{ij}) \\left( w^{(l)}_{01} s^{(l)}_{j} \\hat{\\mathbf{r}}_{ij} + w^{(l)}_{10} \\mathbf{v}^{(l)}_{j} + w^{(l)}_{11\\rightarrow 1} (\\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij}) \\hat{\\mathbf{r}}_{ij} \\right)$$\n\n    - **特征更新**：下一层的特征 $s^{(l+1)}_{i}$ 和 $\\mathbf{v}^{(l+1)}_{i}$ 是根据当前特征和聚合的消息计算的。更新规则必须保持特征的变换性质。\n      - 标量更新是一个仿射变换，它保持了标量性质：\n        $$s^{(l+1)}_{i} = a^{(l)}_{0}\\, s^{(l)}_{i} + b^{(l)}_{0}\\, m^{(l)}_{0,i} + \\mathrm{bias}^{(l)}_{0}$$\n      - 向量更新是两个向量（上一层的向量 $\\mathbf{v}^{(l)}_{i}$ 和消息向量 $\\mathbf{m}^{(l)}_{1,i}$）的线性组合，其结果是一个等变变换的向量：\n        $$\\mathbf{v}^{(l+1)}_{i} = a^{(l)}_{1}\\, \\mathbf{v}^{(l)}_{i} + b^{(l)}_{1}\\, \\mathbf{m}^{(l)}_{1,i}$$\n      这个过程对层 $l=0$ 执行以产生特征 $(s^{(1)}, \\mathbf{v}^{(1)})$，然后对层 $l=1$ 执行以产生特征 $(s^{(2)}, \\mathbf{v}^{(2)})$。每一层和更新的具体权重在问题陈述中已提供。\n\n    - **能量读出**：最后一步是从最后一层的特征中计算出单个、旋转和平移不变的总能量 $E$。这是通过首先计算每个原子的不变能量贡献 $e_i$，然后对所有原子求和来完成的。\n      - 每个原子的能量 $e_i$ 是从第2层特征导出的两个不变量的线性组合：标量特征 $s^{(2)}_{i}$（已经是不变量）和向量特征的平方范数 $\\|\\mathbf{v}^{(2)}_{i}\\|^2$（它是不变的，因为向量的范数在旋转下不会改变）。\n        $$e_{i} = c_{0}\\, s^{(2)}_{i} + c_{1}\\, \\|\\mathbf{v}^{(2)}_{i}\\|^{2}$$\n      - 总能量是所有原子的能量之和：\n        $$E = \\sum_{i} e_{i}$$\n      读出权重给定为 $c_{0} = 1.3$ 和 $c_{1} = 0.2$。\n\n3.  **测试案例的实现**：该算法应用于四个指定的测试案例。对于每个案例，使用原子序数和位置来初始化网络。顺序执行两个消息传递层，然后进行能量读出。\n    - **情况1**：对一个类水分子进行直接计算以找到 $E_1$。\n    - **情况2**：旋转情况1的坐标。网络旋转不变性的一个关键测试是，旋转后系统的能量 $E_2$ 必须等于 $E_1$。此情况的结果是绝对差 $\\Delta = |E_1 - E_2|$，预期接近于零。\n    - **情况3**：涉及两个原子，其间距大于截断半径 $R_c$。这测试了相互作用的局域性；由于 $s(r_{ij})=0$，所有消息项都为零，特征仅根据其先前的值进行更新（更新规则的“自相互作用”部分）。\n    - **情况4**：一个共线系统，其中一个原子间距离恰好等于截断半径。这测试了截断函数 $f_{\\mathrm{cut}}(R_c)=0$ 的边界条件，该条件应使该特定原子对之间的相互作用无效。\n\n最终的 Python 实现封装了这整个过程，精确地遵循公式并使用提供的参数来计算测试套件所需的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the equivariant network model.\n    \"\"\"\n\n    def radial_s(r, R_c, alpha):\n        \"\"\"Computes the radial basis function s(r).\"\"\"\n        if r > R_c or r == 0:\n            return 0.0\n        phi_r = np.exp(-alpha * r)\n        f_cut = 0.5 * (np.cos(np.pi * r / R_c) + 1.0)\n        return phi_r * f_cut\n\n    def run_forward_pass(atomic_numbers, positions):\n        \"\"\"\n        Executes the full forward pass of the 2-layer E(3)-equivariant network.\n        \"\"\"\n        # Hyperparameters and weights\n        R_c = 2.5\n        alpha = 1.0\n\n        weights = [\n            {  # Layer l=0\n                'w00': 0.8, 'w11_0': 0.3, 'w01': 1.1, 'w10': 0.5, 'w11_1': 0.7,\n                'a0': 0.9, 'b0': 1.2, 'bias0': 0.05,\n                'a1': 0.8, 'b1': 1.0\n            },\n            {  # Layer l=1\n                'w00': -0.4, 'w11_0': 0.2, 'w01': 0.6, 'w10': 0.9, 'w11_1': -0.3,\n                'a0': 1.1, 'b0': 0.7, 'bias0': -0.02,\n                'a1': 0.95, 'b1': 0.85\n            }\n        ]\n        readout_weights = {'c0': 1.3, 'c1': 0.2}\n\n        # Initial feature embeddings\n        embeddings = {\n            1: {'s': 0.7, 'v': np.array([0.0, 0.0, 0.0])},  # H\n            6: {'s': 0.4, 'v': np.array([0.0, 0.0, 0.0])},  # C\n            8: {'s': -0.2, 'v': np.array([0.0, 0.0, 0.0])}, # O\n        }\n\n        num_atoms = len(atomic_numbers)\n        s_features = np.array([embeddings[z]['s'] for z in atomic_numbers])\n        v_features = np.array([embeddings[z]['v'] for z in atomic_numbers])\n        \n        # Two message passing layers\n        for l in range(2):\n            w = weights[l]\n            s_next = np.zeros(num_atoms)\n            v_next = np.zeros((num_atoms, 3))\n\n            for i in range(num_atoms):\n                m0_i = 0.0\n                m1_i = np.zeros(3)\n                \n                for j in range(num_atoms):\n                    if i == j:\n                        continue\n                    \n                    r_ij_vec = positions[j] - positions[i]\n                    r_ij_norm = np.linalg.norm(r_ij_vec)\n                    \n                    if r_ij_norm > R_c:\n                        continue\n                    \n                    r_ij_hat = r_ij_vec / r_ij_norm\n                    s_r = radial_s(r_ij_norm, R_c, alpha)\n                    \n                    s_j = s_features[j]\n                    v_j = v_features[j]\n                    \n                    v_j_dot_r_hat = np.dot(v_j, r_ij_hat)\n                    \n                    # Scalar message aggregation\n                    m0_i += s_r * (w['w00'] * s_j + w['w11_0'] * v_j_dot_r_hat)\n                    \n                    # Vector message aggregation\n                    term1 = w['w01'] * s_j * r_ij_hat\n                    term2 = w['w10'] * v_j\n                    term3 = w['w11_1'] * v_j_dot_r_hat * r_ij_hat\n                    m1_i += s_r * (term1 + term2 + term3)\n                \n                # Feature updates\n                s_next[i] = w['a0'] * s_features[i] + w['b0'] * m0_i + w['bias0']\n                v_next[i, :] = w['a1'] * v_features[i] + w['b1'] * m1_i\n            \n            s_features = s_next\n            v_features = v_next\n        \n        # Energy Readout\n        total_energy = 0.0\n        for i in range(num_atoms):\n            s2_i = s_features[i]\n            v2_i_norm_sq = np.linalg.norm(v_features[i])**2\n            e_i = readout_weights['c0'] * s2_i + readout_weights['c1'] * v2_i_norm_sq\n            total_energy += e_i\n            \n        return total_energy\n\n    # --- Test Suite ---\n    \n    # Case 1: Water-like geometry\n    z1 = [8, 1, 1]\n    pos1 = np.array([\n        [0.0, 0.0, 0.0],\n        [0.9572, 0.0, 0.0],\n        [-0.2390, 0.9270, 0.0]\n    ])\n    E1 = run_forward_pass(z1, pos1)\n\n    # Case 2: Rotated Case 1\n    theta = 0.61\n    c, s = np.cos(theta), np.sin(theta)\n    R_z = np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n    pos2 = pos1 @ R_z.T \n    E2 = run_forward_pass(z1, pos2)\n    Delta = abs(E1 - E2)\n\n    # Case 3: Beyond cutoff\n    z3 = [6, 1]\n    pos3 = np.array([\n        [0.0, 0.0, 0.0],\n        [3.0, 0.0, 0.0]\n    ])\n    E3 = run_forward_pass(z3, pos3)\n\n    # Case 4: Collinear triatomic with cutoff boundary\n    z4 = [6, 6, 6]\n    pos4 = np.array([\n        [0.0, 0.0, 0.0],\n        [1.25, 0.0, 0.0],\n        [2.5, 0.0, 0.0]\n    ])\n    E4 = run_forward_pass(z4, pos4)\n\n    results = [E1, Delta, E3, E4]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3449494"}]}