{"hands_on_practices": [{"introduction": "在任何表面模拟中，第一步都是构建一个精确的原子尺度的板坯（slab）模型。本练习将指导你如何基于晶体学信息，为一个给定的晶面（例如钙钛矿结构的(001)面）构建一个既满足化学计量比又具有对称性的模型。掌握这项基本技能，是确保后续表面性质计算具有物理意义和准确性的前提 [@problem_id:3487610]。", "problem": "一个化学式为 $ABO_3$ 的立方钙钛矿晶体，其常规晶格常数为 $a$，其原子基矢在常规立方晶胞中定义为：$A$ 阳离子位于立方体角点，$B$ 阳离子位于体心，$O$ 阴离子位于面心。考虑沿 $(001)$ 方向构建一个表面平板模型，其横向平移取自常规立方晶格，平板法线方向沿 $[001]$。该平板模型将用于在带有真空层的周期性边界条件下对表面进行第一性原理模拟。为防止产生人为的静电场，并使两侧的静电势能实现明确的真空对齐，请选择一个相对于平板中面对称的终端。使用 $ABO_3$ 堆叠所隐含的沿 $[001]$ 方向的最小化学计量重复单元，并假设理想解理、无重构或弛豫，请推导构建一个厚度为 $N$ 个原子层、横向面积为 $A$ 的平板所需的总原子数，其中使用原始 $(001)$ 表面晶胞作为横向重复单元。假设 $N$ 为一个正奇数，从而使得顶部和底部表面具有相同的终端。将最终答案表示为一个关于 $N$、$A$ 和 $a$ 的封闭形式符号表达式。无需四舍五入。最终答案必须是方框中的单个不带单位的解析表达式。", "solution": "用户希望确定一个立方钙钛矿晶体对称平板模型中的总原子数。\n\n### 第 1 步：问题验证\n\n**1.1. 提取已知条件**\n- 晶体结构：化学式为 $ABO_3$ 的立方钙钛矿。\n- 常规晶格常数：$a$。\n- 常规晶胞中的原子基矢：$A$ 位于角点，$B$ 位于体心，$O$ 位于面心。\n- 平板取向：法线沿 $[001]$ 方向。\n- 横向周期性：基于常规立方晶格。\n- 模拟约束：周期性边界条件并带有真空层。平板必须相对于其中面呈对称，以防止人为静电场。\n- 平板构建：\n    - 基于沿 $[001]$ 方向的最小化学计量重复单元。\n    - 假设理想解理，无重构或弛豫。\n    - 厚度为 $N$ 个原子层，其中 $N$ 是一个正奇数。\n    - 横向重复单元是原始 $(001)$ 表面晶胞。\n- 平板总横向面积：$A$。\n- 要求输出：关于 $N$、$A$ 和 $a$ 的总原子数封闭形式符号表达式。\n\n**1.2. 使用提取的已知条件进行验证**\n该问题具有科学依据，提法明确且客观。它描述了计算材料科学中创建表面模型的标准流程。钙钛矿结构定义明确，约束条件（理想解理、奇数 $N$、对称性）是针对特定几何构造的清晰指令。该问题隐含地依赖于所选结构的非极性性质，这对于像 $SrTiO_3$ ($A^{2+}B^{4+}O_3$) 这样的常见钙钛矿是成立的，其中构成的 $AO$ 和 $BO_2$ 层是电中性的。对于极性情况（如 $LaAlO_3$, $A^{3+}B^{3+}O_3$），这种“理想解理”模型在物理上是不稳定的，但问题要求基于这种几何结构进行形式上的原子计数，这是一个有效且定义明确的数学问题。构建对称平板以对齐真空势的指令是合理的。奇数层数 $N$ 允许构建具有相同顶部和底部终端的对称平板。该问题是自洽的，没有矛盾。\n\n**1.3. 结论与行动**\n该问题被判定为**有效**。我们可以继续进行求解。\n\n### 第 2 步：求解推导\n\n求解过程需要分析 $ABO_3$ 钙钛矿结构沿 $[001]$ 方向的原子堆叠，然后计算指定平板几何结构中的原子数。\n\n**2.1. 沿 [001] 方向的原子堆叠**\n设常规立方晶胞由沿笛卡尔坐标轴的晶格矢量定义，原点位于一个 $A$ 阳离子处。基矢原子的分数坐标为：\n- $A$：$(0, 0, 0)$\n- $B$：$(\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2})$\n- $O$：$(\\frac{1}{2}, \\frac{1}{2}, 0)$、$(\\frac{1}{2}, 0, \\frac{1}{2})$、$(0, \\frac{1}{2}, \\frac{1}{2})$\n\n我们考察垂直于 $[001]$ 方向的原子平面（即 $z$ 坐标恒定的平面）。\n- 在 $z=0$ 处，有一个平面包含 $A$ 阳离子（来自晶胞角点）和一个位于面心 $(\\frac{1}{2}, \\frac{1}{2}, 0)$ 的 $O$ 阴离子。该层的化学计量为 $AO$。\n- 在 $z=\\frac{a}{2}$ 处，有一个平面包含位于体心 $(\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2})$ 的 $B$ 阳离子和两个位于面心 $(\\frac{1}{2}, 0, \\frac{1}{2})$ 和 $(0, \\frac{1}{2}, \\frac{1}{2})$ 的 $O$ 阴离子。该层的化学计量为 $BO_2$。\n- 在 $z=a$ 处，结构重复，出现另一个 $AO$ 层。\n\n沿 $[001]$ 方向的堆叠顺序是 $AO$ 和 $BO_2$ 平面交替出现，间距为 $\\frac{a}{2}$。沿 $[001]$ 方向的最小化学计量重复单元由一个 $AO$ 层和一个 $BO_2$ 层组成，它们共同构成了 $ABO_3$ 的化学式。\n\n**2.2. 每个原始表面晶胞中的原子数**\n问题指定使用原始 $(001)$ 表面晶胞作为横向单元。对于简单立方晶格，这是一个面积为 $a \\times a = a^2$ 的正方形。我们计算每种类型的层在此单元内的原子数。\n\n- **对于 $AO$ 层：**\n    - 每个单元有一个 $A$ 原子。（$a \\times a$ 正方形角上的 4 个 $A$ 原子每个都被 4 个相邻单元共享，因此 $4 \\times \\frac{1}{4} = 1$）。\n    - 每个单元有一个 $O$ 原子（位于 $a \\times a$ 正方形的中心）。\n    - 每 $a^2$ 面积的一个 $AO$ 层中的总原子数：$1+1 = 2$。\n\n- **对于 $BO_2$ 层：**\n    - 每个单元有一个 $B$ 原子（位于 $a \\times a$ 单元的中心，对应于体心位置的投影）。\n    - 每个单元有两个 $O$ 原子。（两个相关的氧原子位于分数坐标 $(\\frac{1}{2}, 0, \\frac{1}{2})$ 和 $(0, \\frac{1}{2}, \\frac{1}{2})$。每个原子都位于 $a \\times a$ 单元的边上，并被 2 个单元共享。因此，单元周围有 4 个这样的边位，每个贡献 $\\frac{1}{2}$，但在该平面的基矢中只有 2 种独特的原子类型。总数为 $2 \\times (\\frac{1}{2}) + 2 \\times (\\frac{1}{2}) = 2$ 个原子来自投影到边上的基矢原子，或者更简单地说，晶胞内有一个 B 原子和与之相关的两个 O 原子，得到 2 个 O 原子）。\n    - 每 $a^2$ 面积的一个 $BO_2$ 层中的总原子数：$1+2 = 3$。\n\n**2.3. 平板构建与原子计数**\n平板必须对称，并且有奇数层 $N$。这意味着平板顶部和底部的终止平面必须相同。我们有两种终止选择：$AO$ 或 $BO_2$。标准的晶体学惯例将原点置于高对称性位置，即 $A$ 阳离子处。这使得 $AO$ 层成为 $z=0$ 处的自然起始平面，因此我们选择以 $AO$ 为终端的平板。\n\n一个以 $AO$ 为终端、包含 $N$ 层的对称平板（其中 $N=2k+1$，对于某个整数 $k \\ge 0$）将在其中心和两个表面上都有一个 $AO$ 层。其结构为 $AO - BO_2 - AO - \\dots - AO - BO_2 - AO$。\n- 位于奇数位置（$1, 3, \\dots, N$）的层是 $AO$ 层。\n- 位于偶数位置（$2, 4, \\dots, N-1$）的层是 $BO_2$ 层。\n\n对于奇数 $N$，从 $1$ 到 $N$ 的奇数个数为 $\\frac{N+1}{2}$。这是 $AO$ 层的数量。\n从 $1$ 到 $N$ 的偶数个数为 $\\frac{N-1}{2}$。这是 $BO_2$ 层的数量。\n\n每个原始单元面积（$a^2$）的总原子数为：\n$$ N_{\\text{单元}} = (AO \\text{ 层数}) \\times (\\text{每个 } AO \\text{ 层的原子数}) + (BO_2 \\text{ 层数}) \\times (\\text{每个 } BO_2 \\text{ 层的原子数}) $$\n$$ N_{\\text{单元}} = \\left(\\frac{N+1}{2}\\right) \\times 2 + \\left(\\frac{N-1}{2}\\right) \\times 3 $$\n$$ N_{\\text{单元}} = (N+1) + \\frac{3(N-1)}{2} $$\n$$ N_{\\text{单元}} = \\frac{2(N+1) + 3(N-1)}{2} $$\n$$ N_{\\text{单元}} = \\frac{2N+2+3N-3}{2} $$\n$$ N_{\\text{单元}} = \\frac{5N-1}{2} $$\n\n这是一个横向面积为 $a^2$ 的平板的总原子数。问题指出总横向面积为 $A$。形成此面积所需的原始单元数量为 $\\frac{A}{a^2}$。\n\n整个平板的总原子数 $N_{\\text{总数}}$ 是每个单元的原子数乘以单元的数量：\n$$ N_{\\text{总数}} = N_{\\text{单元}} \\times \\left(\\frac{A}{a^2}\\right) $$\n$$ N_{\\text{总数}} = \\left(\\frac{5N-1}{2}\\right) \\times \\left(\\frac{A}{a^2}\\right) $$\n$$ N_{\\text{总数}} = \\frac{A(5N-1)}{2a^2} $$\n\n这就是总原子数的最终封闭形式符号表达式。", "answer": "$$\n\\boxed{\\frac{A(5N-1)}{2a^{2}}}\n$$", "id": "3487610"}, {"introduction": "在板坯模型计算完成后，为了计算功函数等关键物理量，我们必须从沿表面法线方向的平面平均静电势分布中精确地确定真空能级 $V_{\\text{vac}}$。本练习将引导你设计并实现一个稳健的数值方法，该方法基于物理原理——即真空中电荷密度为零，因此势的曲率应趋于零——来自动识别势能曲线中的“平坦区域”。通过这个练习，你将学会如何从含噪声的连续数据中提取出带有不确定性估计的、可靠的物理量 [@problem_id:3487620]。", "problem": "给定四种不同板层几何构型的平面平均静电势 $V_{planar}(z)$ 沿板层法向 $z$ 的一维表示，这些势函数具有明确的、物理上合理的合成形式。您的任务是通过在指定的真空窗口内识别一个真实的平台区，设计并实现一个用于计算真空能级 $V_{vac}$ 及其相关不确定度的定量估计器。该估计器必须基于基本静电学原理，并使用在滑动窗口内计算的 $V_{planar}(z)$ 的局部方差和离散二阶导数 $\\partial^2 V_{planar}/\\partial z^2$ 来选择结构最少的子窗口，然后将此选定子窗口内的平均电势报告为 $V_{vac}$，并附上一个基于物理动机的不确定度。所有电势必须以电子伏特 (eV) 表示，所有长度以埃 (Å) 表示，最终的数值答案必须是浮点数。\n\n基本和建模假设：\n- 高斯单位制或国际单位制中的静电学表明，静电势 $V$ 满足 $\\nabla^2 V = -\\rho/\\varepsilon_0$。在真空中，电荷密度 $\\rho \\approx 0$，因此拉普拉斯算子 $\\nabla^2 V \\approx 0$。对于经过平面平均的板层，真空中沿 $z$ 方向的曲率 $\\partial^2 V_{planar}/\\partial z^2$ 相对于板层内部应较小。一个真实的真空平台的特征是 $V_{planar}(z)$ 的局部方差小且局部曲率小。\n- 您必须在提供的候选真空区间内使用长度为 $L_w$ 的滑动窗口来搜索平台。在每个窗口中，计算电势变化的局部度量和曲率的局部度量。将所有候选窗口的每个度量值分别通过它们的中值进行归一化，并形成一个当变化和曲率都减小时其值也减小的组合目标函数。选择使该组合目标函数最小化的窗口作为平台。然后，将所选窗口内 $V_{planar}(z)$ 的算术平均值估计为 $V_{vac}$。\n- 您必须使用两个贡献来估计不确定度：由局部方差产生的均值统计不确定度，以及通过窗口内泰勒展开估计的曲率引起的偏差。将这两项正交相加（即平方和的平方根）以报告单一的不确定度。\n\n离散定义和要求：\n- 设网格是均匀的，间距为 $\\Delta z$，网格点为 $z_i$。使用中心有限差分来近似离散二阶导数：\n$$\nV''(z_i) \\approx \\frac{V_{planar}(z_{i+1}) - 2 V_{planar}(z_i) + V_{planar}(z_{i-1})}{\\Delta z^2}.\n$$\n在无法定义中心差分的端点处，您可以将二阶导数设置为零，因为窗口将位于候选真空区间的内部，这是一种无害的边界选择。\n- 在包含 $N_w$ 个点的窗口中，将局部方差定义为无偏样本方差\n$$\n\\mathrm{Var}_w = \\frac{1}{N_w-1}\\sum_{j=1}^{N_w}\\left(V_{planar}(z_j) - \\overline{V}_w\\right)^2,\n$$\n其中 $\\overline{V}_w$ 是该窗口中的样本均值。将窗口内的均方根曲率定义为\n$$\n\\mathrm{RMS}_w = \\sqrt{\\frac{1}{N_w}\\sum_{j=1}^{N_w} \\left(V''(z_j)\\right)^2}.\n$$\n- 将所有候选窗口的方差平方根和均方根曲率分别通过它们的中值进行归一化，以形成无量纲分数：\n$$\nS_{\\mathrm{var},w} = \\frac{\\sqrt{\\mathrm{Var}_w}}{\\mathrm{median}\\left(\\sqrt{\\mathrm{Var}_w}\\right)}, \\quad\nS_{\\mathrm{curv},w} = \\frac{\\mathrm{RMS}_w}{\\mathrm{median}\\left(\\mathrm{RMS}_w\\right)}.\n$$\n如果中值为零，则用相应分数的平均值或一个小的正数 $\\epsilon$ 替换分母，以避免除以零。\n- 将用于窗口选择的组合目标函数定义为\n$$\nQ_w = S_{\\mathrm{var},w} + S_{\\mathrm{curv},w}.\n$$\n选择使 $Q_w$ 最小化的窗口。如果在数值精度范围内多个窗口具有相同的 $Q_w$，则通过选择具有最大 $N_w$ 的窗口来打破平局，如有必要，再通过选择其中心离其候选区间边界最远的窗口来打破平局。\n- 对于选定的窗口，将真空能级报告为 $V_{vac} = \\overline{V}_w$。通过组合两项来估计不确定度：\n1. 统计项（均值标准误）：$\\sigma_{\\mathrm{mean}} = \\sqrt{\\mathrm{Var}_w}/\\sqrt{N_w}$。\n2. 曲率诱导项（来自二次泰勒余项）：$\\sigma_{\\mathrm{curv}} = \\frac{L_w^2}{24}\\cdot \\overline{|V''|}_w$，其中 $\\overline{|V''|}_w$ 是窗口内二阶导数绝对值的平均值，$L_w$ 是以埃为单位的物理窗口长度。\n将它们正交相加：\n$$\n\\sigma_{vac} = \\sqrt{\\sigma_{\\mathrm{mean}}^2 + \\sigma_{\\mathrm{curv}}^2}.\n$$\n\n测试套件规范：\n对于每个测试用例，完全按照下文规定构建 $z_i$ 和 $V_{planar}(z_i)$。Heaviside 阶跃函数 $\\Theta(x)$ 定义为：当 $x\\ge 0$ 时 $\\Theta(x)=1$，当 $x0$ 时 $\\Theta(x)=0$。随机项 $\\eta(z)$ 是具有给定标准差的零均值高斯噪声，并且为保证可复现性，每个案例使用固定的随机种子。所有长度以埃为单位，所有电势以电子伏特为单位。\n\n- 测试用例 A（理想情况，平缓指数尾部）：\n    - 网格：$z_i$ 在 $0$ 到 $30\\,\\mathrm{\\AA}$ 之间均匀分布，$\\Delta z = 0.2\\,\\mathrm{\\AA}$。\n    - 电势：\n    $$\n    V_{planar}(z) = -0.20 + 0.02\\,\\Theta(z-20)\\exp\\left(-\\frac{z-20}{3}\\right) + 1.0\\,\\exp\\left(-\\left(\\frac{z-15}{2}\\right)^2\\right)\\cos\\left(\\frac{2\\pi(z-15)}{3}\\right) + \\eta(z),\n    $$\n    其中 $\\eta(z)$ 的标准差为 $0.005$，随机种子为 $123$。\n    - 候选区间：$[22\\,\\mathrm{\\AA}, 30\\,\\mathrm{\\AA}]$。\n    - 窗口长度：$L_w = 5\\,\\mathrm{\\AA}$。\n\n- 测试用例 B（窄真空窗口，更多噪声）：\n    - 网格：$z_i$ 在 $0$ 到 $30\\,\\mathrm{\\AA}$ 之间均匀分布，$\\Delta z = 0.1\\,\\mathrm{\\AA}$。\n    - 电势：\n    $$\n    V_{planar}(z) = -0.15 + 0.015\\,\\Theta(z-23)\\exp\\left(-\\frac{z-23}{2.5}\\right) + 0.6\\,\\exp\\left(-\\left(\\frac{z-15}{1.8}\\right)^2\\right)\\sin\\left(\\frac{2\\pi(z-15)}{2.2}\\right) + \\eta(z),\n    $$\n    其中 $\\eta(z)$ 的标准差为 $0.010$，随机种子为 $456$。\n    - 候选区间：$[24\\,\\mathrm{\\AA}, 27\\,\\mathrm{\\AA}]$。\n    - 窗口长度：$L_w = 2\\,\\mathrm{\\AA}$。\n\n- 测试用例 C（贯穿真空的持续场，线性趋势）：\n    - 网格：$z_i$ 在 $0$ 到 $40\\,\\mathrm{\\AA}$ 之间均匀分布，$\\Delta z = 0.25\\,\\mathrm{\\AA}$。\n    - 电势：\n    $$\n    V_{planar}(z) = -0.25 + 0.02\\,\\Theta(z-25)\\,(z-25) + 0.8\\,\\exp\\left(-\\left(\\frac{z-20}{3.0}\\right)^2\\right)\\cos\\left(\\frac{2\\pi(z-20)}{3.5}\\right) + \\eta(z),\n    $$\n    其中 $\\eta(z)$ 的标准差为 $0.003$，随机种子为 $789$。\n    - 候选区间：$[25\\,\\mathrm{\\AA}, 40\\,\\mathrm{\\AA}]$。\n    - 窗口长度：$L_w = 5\\,\\mathrm{\\AA}$。\n\n- 测试用例 D（两个具有小斜率的不相交真空区间）：\n    - 网格：$z_i$ 在 $0$ 到 $50\\,\\mathrm{\\AA}$ 之间均匀分布，$\\Delta z = 0.2\\,\\mathrm{\\AA}$。\n    - 电势：\n    $$\n    V_{planar}(z) = -0.30 + 0.01\\,\\Theta(8 - z)\\,(8 - z) + 0.012\\,\\Theta(z-42)\\,(z-42) + 1.2\\,\\exp\\left(-\\left(\\frac{z-25}{4.0}\\right)^2\\right)\\sin\\left(\\frac{2\\pi(z-25)}{4.5}\\right) + \\eta(z),\n    $$\n    其中 $\\eta(z)$ 的标准差为 $0.004$，随机种子为 $2468$。\n    - 候选区间：$[0\\,\\mathrm{\\AA}, 8\\,\\mathrm{\\AA}]$ 和 $[42\\,\\mathrm{\\AA}, 50\\,\\mathrm{\\AA}]$。\n    - 窗口长度：$L_w = 4\\,\\mathrm{\\AA}$。\n\n实现与输出：\n- 您的程序必须实现上述估计器，根据给定的公式精确构建四个测试电势，并为每个测试用例计算 $V_{vac}$ 和 $\\sigma_{vac}$。\n- 所有的 $V_{vac}$ 和 $\\sigma_{vac}$ 值都必须以 $\\mathrm{eV}$ 表示。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素都是一个双元素列表 $[V_{vac}, \\sigma_{vac}]$，按 A、B、C、D 的顺序对应于相应的测试用例。例如：“[[V_A,sigma_A],[V_B,sigma_B],[V_C,sigma_C],[V_D,sigma_D]]”。数字必须打印为不带单位的普通十进制浮点数。", "solution": "用户提供了一个**有效**的问题。它在科学上基于应用于计算材料科学的静电学原理，特别是板层模型计算的分析。该问题是适定的，所有数学函数、参数、算法和数据集都得到了明确无误的定义。其目标是从一维电势剖面中实现一个用于计算真空能级的鲁棒数值估计器，这是一项既有现实意义又具挑战性的任务。所提供的方法论是合理的，它结合了变化的统计度量和曲率来识别最佳的“平台”区域。不确定度量化具有物理动机，既包含了统计误差，也包含了对残余曲率系统偏差的估计。该问题是可形式化的，其解决方案在算法上是确定性的且可验证的。\n\n解决方案首先通过实现一个函数来为每个测试用例生成一维势能面 $V_{planar}(z)$。这包括指定的确定性函数和为了可复现性而使用固定种子生成的伪随机高斯噪声。电势定义在间距为 $\\Delta z$ 的均匀网格上。\n\n算法的核心包括以下步骤：\n\n1.  **数值微分**：使用三点中心有限差分格式计算整个网格的离散二阶导数 $V''(z_i) \\approx \\partial^2 V_{planar}/\\partial z^2$：\n    $$\n    V''(z_i) = \\frac{V(z_{i+1}) - 2 V(z_i) + V(z_{i-1})}{\\Delta z^2}\n    $$\n    按照规定，在中心差分未定义的网格的两个全局端点处，二阶导数被设置为 $0$。\n\n2.  **滑动窗口分析**：一个固定物理长度为 $L_w$ 的滑动窗口在指定的候选真空区间上移动。窗口长度 $L_w$ 被转换为固定数量的网格点，$N_w = \\text{int}(L_w/\\Delta z) + 1$。对于每个窗口，计算两个关键指标：\n    - 电势的无偏样本方差 $\\mathrm{Var}_w$，它量化了局部电势的波动。\n    - 离散二阶导数的均方根 (RMS) $\\mathrm{RMS}_w$，它量化了电势的局部曲率或“非平坦度”。\n\n3.  **目标函数与优化**：为了找到最优的平台区域，计算出的指标必须放在一个共同的标度上。这通过归一化来实现。收集所有可能窗口的方差平方根 $\\sqrt{\\mathrm{Var}_w}$ 和均方根曲率 $\\mathrm{RMS}_w$。然后将每组值通过其各自的中值进行归一化，创建无量纲分数 $S_{\\mathrm{var},w}$ 和 $S_{\\mathrm{curv},w}$。在极少数中值为零的情况下，使用平均值作为归一化常数的鲁棒备用方案。定义一个目标函数 $Q_w = S_{\\mathrm{var},w} + S_{\\mathrm{curv},w}$。使这个复合分数 $Q_w$ 最小化的窗口被选为真空平台的最佳代表，因为低的 $Q_w$ 表示低的电势方差和低的曲率。为确保唯一选择，实现了指定的平局打破规则——首先按窗口大小（在此实现中为常量），然后按窗口与区间边界的距离。\n\n4.  **真空能级与不确定度估计**：一旦确定了最优窗口：\n    - 真空能级 $V_{vac}$ 被估计为该窗口内电势值的算术平均值。\n    - 总不确定度 $\\sigma_{vac}$ 通过正交组合两个贡献项来计算：\n        a.  一个统计项 $\\sigma_{\\mathrm{mean}}$，对应于均值标准误，它随着窗口中点数 $N_w$ 的增加而减小。\n        b.  一个系统项 $\\sigma_{\\mathrm{curv}}$，它估计了来自窗口中残余曲率的不确定度贡献。这是从泰勒展开论证中导出的，并与平均绝对二阶导数和窗口长度的平方 $L_w^2$ 成正比。\n    最终的不确定度是 $\\sigma_{vac} = \\sqrt{\\sigma_{\\mathrm{mean}}^2 + \\sigma_{\\mathrm{curv}}^2}$。\n\n整个过程被封装在一个 Python 函数中。该脚本定义了指定的四个测试用例，为每个用例调用估计函数，并严格按照要求的输出格式将最终输出格式化为 $[V_{vac}, \\sigma_{vac}]$ 对的列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It orchestrates the analysis for each case and prints the final result.\n    \"\"\"\n\n    def estimate_vacuum_level(z_range, dz, potential_func, noise_std, seed, candidate_intervals, L_w):\n        \"\"\"\n        Estimates the vacuum level and its uncertainty for a single test case based on the provided methodology.\n\n        Args:\n            z_range (tuple): The (min, max) of the z-coordinate.\n            dz (float): The grid spacing.\n            potential_func (callable): A function that computes the deterministic part of the potential.\n            noise_std (float): Standard deviation of the Gaussian noise.\n            seed (int): The random seed for reproducibility.\n            candidate_intervals (list of tuples): List of (min, max) z-ranges to search for the vacuum plateau.\n            L_w (float): The physical length of the sliding window in angstroms.\n\n        Returns:\n            list: A list containing the estimated vacuum level [V_vac, sigma_vac].\n        \"\"\"\n        # Step 1: Grid and Potential Generation\n        z_min, z_max = z_range\n        # Add a small tolerance to ensure np.arange includes the endpoint\n        z = np.arange(z_min, z_max + dz / 2.0, dz)\n        \n        rng = np.random.default_rng(seed)\n        noise = rng.normal(loc=0.0, scale=noise_std, size=z.shape)\n        \n        V = potential_func(z) + noise\n\n        # Step 2: Second Derivative Calculation (V_pp for V double prime)\n        V_pp = np.zeros_like(V)\n        # Central difference for interior points\n        V_pp[1:-1] = (V[2:] - 2 * V[1:-1] + V[:-2]) / (dz**2)\n        # Endpoints remain zero as specified.\n\n        # Step 3: Sliding Window Analysis\n        # Convert physical window length to number of grid points\n        N_w = int(round(L_w / dz)) + 1\n        \n        windows = []\n        \n        for interval_min, interval_max in candidate_intervals:\n            # Find grid indices corresponding to the current candidate interval\n            interval_indices = np.where((z >= interval_min)  (z = interval_max))[0]\n            if not interval_indices.any():\n                continue\n            \n            start_idx_cand = interval_indices[0]\n            end_idx_cand = interval_indices[-1]\n            \n            # Ensure the interval is wide enough for at least one window\n            if (end_idx_cand - start_idx_cand + 1)  N_w:\n                continue\n                \n            # Iterate through all possible start positions for the sliding window\n            for i in range(start_idx_cand, end_idx_cand - N_w + 2):\n                win_start_idx = i\n                win_end_idx = i + N_w - 1\n                \n                V_w = V[win_start_idx : win_end_idx + 1]\n                V_pp_w = V_pp[win_start_idx : win_end_idx + 1]\n                \n                if len(V_w)  2:  # Variance (with ddof=1) requires at least 2 points\n                    continue\n                \n                var_w = np.var(V_w, ddof=1)\n                rms_w = np.sqrt(np.mean(V_pp_w**2))\n                \n                # Calculate distance of window center to interval boundary for tie-breaking\n                center_coord = (z[win_start_idx] + z[win_end_idx]) / 2.0\n                center_dist = min(center_coord - z[start_idx_cand], z[end_idx_cand] - center_coord)\n                \n                windows.append({\n                    'start_idx': win_start_idx,\n                    'end_idx': win_end_idx,\n                    'N_w_actual': len(V_w),\n                    'var_w': var_w,\n                    'rms_w': rms_w,\n                    'center_dist': center_dist\n                })\n\n        if not windows:\n            return [float('nan'), float('nan')]\n\n        # Step 4: Score Calculation and Window Selection\n        sqrt_vars = np.array([np.sqrt(w['var_w']) for w in windows])\n        rms_curvs = np.array([w['rms_w'] for w in windows])\n        \n        median_sqrt_var = np.median(sqrt_vars)\n        if np.isclose(median_sqrt_var, 0):\n            median_sqrt_var = np.mean(sqrt_vars)\n            if np.isclose(median_sqrt_var, 0): median_sqrt_var = 1e-9 # Failsafe\n\n        median_rms_curv = np.median(rms_curvs)\n        if np.isclose(median_rms_curv, 0):\n            median_rms_curv = np.mean(rms_curvs)\n            if np.isclose(median_rms_curv, 0): median_rms_curv = 1e-9 # Failsafe\n            \n        min_Q = np.inf\n        for w in windows:\n            s_var = np.sqrt(w['var_w']) / median_sqrt_var\n            s_curv = w['rms_w'] / median_rms_curv\n            w['Q_w'] = s_var + s_curv\n            if w['Q_w']  min_Q:\n                min_Q = w['Q_w']\n        \n        # Filter for all windows at minimum Q (within a small tolerance for float comparison)\n        potential_best_windows = [w for w in windows if np.isclose(w['Q_w'], min_Q)]\n        \n        # Tie-breaking logic\n        if len(potential_best_windows) > 1:\n            max_Nw = max(w['N_w_actual'] for w in potential_best_windows)\n            potential_best_windows = [w for w in potential_best_windows if w['N_w_actual'] == max_Nw]\n\n        if len(potential_best_windows) > 1:\n            max_dist = max(w['center_dist'] for w in potential_best_windows)\n            potential_best_windows = [w for w in potential_best_windows if np.isclose(w['center_dist'], max_dist)]\n        \n        best_window = potential_best_windows[0]\n\n        # Step 5: Final Calculation for the selected best window\n        win_start = best_window['start_idx']\n        win_end = best_window['end_idx']\n        \n        V_w_best = V[win_start:win_end + 1]\n        V_pp_w_best = V_pp[win_start:win_end + 1]\n        \n        V_vac = np.mean(V_w_best)\n        \n        var_w_best = best_window['var_w']\n        N_w_best = best_window['N_w_actual']\n        \n        sigma_mean = np.sqrt(var_w_best) / np.sqrt(N_w_best)\n        \n        mean_abs_vpp = np.mean(np.abs(V_pp_w_best))\n        sigma_curv = (L_w**2 / 24.0) * mean_abs_vpp\n        \n        sigma_vac = np.sqrt(sigma_mean**2 + sigma_curv**2)\n\n        return [V_vac, sigma_vac]\n\n    # Define the four test cases as per the problem statement\n    test_cases = [\n        {'z_range': (0.0, 30.0), 'dz': 0.2, 'potential_func': lambda z: -0.20 + 0.02 * (z >= 20.0) * np.exp(-(z - 20.0) / 3.0) + 1.0 * np.exp(-((z - 15.0) / 2.0)**2) * np.cos(2.0 * np.pi * (z - 15.0) / 3.0), 'noise_std': 0.005, 'seed': 123, 'candidate_intervals': [(22.0, 30.0)], 'L_w': 5.0},\n        {'z_range': (0.0, 30.0), 'dz': 0.1, 'potential_func': lambda z: -0.15 + 0.015 * (z >= 23.0) * np.exp(-(z - 23.0) / 2.5) + 0.6 * np.exp(-((z - 15.0) / 1.8)**2) * np.sin(2.0 * np.pi * (z - 15.0) / 2.2), 'noise_std': 0.010, 'seed': 456, 'candidate_intervals': [(24.0, 27.0)], 'L_w': 2.0},\n        {'z_range': (0.0, 40.0), 'dz': 0.25, 'potential_func': lambda z: -0.25 + 0.02 * (z >= 25.0) * (z - 25.0) + 0.8 * np.exp(-((z - 20.0) / 3.0)**2) * np.cos(2.0 * np.pi * (z - 20.0) / 3.5), 'noise_std': 0.003, 'seed': 789, 'candidate_intervals': [(25.0, 40.0)], 'L_w': 5.0},\n        {'z_range': (0.0, 50.0), 'dz': 0.2, 'potential_func': lambda z: -0.30 + 0.01 * (z = 8.0) * (8.0 - z) + 0.012 * (z >= 42.0) * (z - 42.0) + 1.2 * np.exp(-((z - 25.0) / 4.0)**2) * np.sin(2.0 * np.pi * (z - 25.0) / 4.5), 'noise_std': 0.004, 'seed': 2468, 'candidate_intervals': [(0.0, 8.0), (42.0, 50.0)], 'L_w': 4.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = estimate_vacuum_level(**case)\n        results.append(result)\n\n    # Format the output exactly as required, without extra spaces\n    formatted_results = [f\"[{v},{s}]\" for v, s in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3487620"}, {"introduction": "由于计算资源的限制，板坯模型模拟在有限尺寸的超胞中进行，这不可避免地会引入因周期性边界条件和有限尺寸效应产生的误差。本练习将探讨功函数 $\\Phi$ 的计算值如何依赖于板坯厚度 $N$ 和真空层厚度 $L_{\\text{vac}}$。你将学习使用一个物理上合理的渐近模型来拟合一系列计算数据，从而建立一套系统的收敛性测试方案，用以确定达到目标精度所需的最小模拟参数 [@problem_id:3487626]。", "problem": "您正在使用周期性边界条件下的板坯模型和一个有限的真空区来模拟晶体表面的功函数。该板坯具有可变数量的原子层，真空区具有可变的厚度。由于有限尺寸效应和周期性镜像效应，计算出的功函数同时取决于板坯厚度和真空厚度。您将实现一个收敛方案，以确定达到目标功函数容差所需的最小板坯厚度和最小真空厚度，并且您将推导并拟合一个关于板坯厚度倒数和真空厚度倒数的外推定律，以估计在无限厚板坯和无限厚真空极限下的功函数。\n\n使用以下与上下文相符的基础知识：\n- 功函数定义为真空能级与费米能级之差。在周期性边界条件下，真空能级通过真空区域中的静电势对齐获得。\n- 板坯及其周期性镜像的静电学行为由泊松方程控制，这意味着在三维周期性边界条件下，分离的偶极子之间的相互作用能随距离的增加成反比衰减。因此，由于真空中的板坯-镜像相互作用，对功函数的主要有限尺寸修正项因跨越真空的偶极-偶极耦合而与真空厚度的倒数成正比。有限的板坯厚度引入了量子限制效应和板坯两个表面之间的残余相互作用，这些效应与板坯厚度的倒数成正比。当两种效应共存时，会出现一个混合修正项，其大小与板坯厚度和真空厚度乘积的倒数成正比。这些陈述在密度泛函理论计算中被广泛观察到，并且与渐近区域中的线性响应一致。\n\n任务：\n1. 假设计算出的功函数（以电子伏特表示）作为板坯层数和真空厚度的函数，具有以下渐近展开式：\n   $$\\Phi(N,L_{\\text{vac}}) = \\Phi_{\\infty} + \\frac{A_N}{N} + \\frac{A_L}{L_{\\text{vac}}} + \\frac{A_{NL}}{N\\,L_{\\text{vac}}},$$\n   其中 $N$ 是以原子层为单位的板坯厚度（一个整数），$L_{\\text{vac}}$ 是以埃为单位的真空厚度，$\\Phi_{\\infty}$ 是以电子伏特为单位的无限厚板坯-无限真空功函数，而 $A_N$、$A_L$、$A_{NL}$ 是未知系数，其单位使得每一项的单位都是电子伏特。\n\n2. 对每个测试用例，执行线性最小二乘拟合，从所提供的数据点 $\\{(N_i, L_{\\text{vac},i}, \\Phi_i)\\}$ 中确定 $\\Phi_{\\infty}$、$A_N$、$A_L$、$A_{NL}$。\n\n3. 设计一个收敛方案，以推荐最小整数 $N$ 和最小整数 $L_{\\text{vac}}$，使得估计的总残余有限尺寸修正\n   $$E_{\\text{res}}(N,L_{\\text{vac}}) = \\left|\\frac{A_N}{N}\\right| + \\left|\\frac{A_L}{L_{\\text{vac}}}\\right| + \\left|\\frac{A_{NL}}{N\\,L_{\\text{vac}}}\\right|$$\n   小于或等于指定的目标容差 $\\tau$（以电子伏特为单位）。为避免将误差过度分配给任何单个项，请使用相等的分配权重，即分配部分目标\n   $$\\left|\\frac{A_N}{N}\\right| \\leq \\frac{\\tau}{3}, \\quad \\left|\\frac{A_L}{L_{\\text{vac}}}\\right| \\leq \\frac{\\tau}{3}, \\quad \\left|\\frac{A_{NL}}{N\\,L_{\\text{vac}}}\\right| \\leq \\frac{\\tau}{3}.$$\n   从满足前两个不等式的最小整数开始，对 $N$ 和 $L_{\\text{vac}}$ 进行最小调整以同样满足第三个不等式，然后，如有必要，进一步增加其中一个或两个值以确保 $E_{\\text{res}}(N,L_{\\text{vac}}) \\leq \\tau$。\n\n4. 对每个测试用例，报告：\n   - 拟合得到的 $\\Phi_{\\infty}$，以电子伏特为单位，四舍五入到3位小数。\n   - 推荐的最小整数 $N$，以原子层为单位。\n   - 推荐的最小整数 $L_{\\text{vac}}$，以埃为单位。\n   - 一个布尔值，指示初始构型 $(N_0, L_{\\text{vac},0})$ 是否满足容差，即 $E_{\\text{res}}(N_0, L_{\\text{vac},0}) \\leq \\tau$ 是否成立。\n\n物理和数值单位：\n- 所有功函数必须以电子伏特为单位。\n- 真空厚度必须以埃为单位。\n- 板坯厚度必须是原子层的整数倍。\n\n角度单位不相关，不得出现。将布尔输出表示为 $True$ 或 $False$，不含任何其他文本。将浮点数表示为十进制数。\n\n您的程序应生成一行输出，其中包含一个逗号分隔的列表，列表内是每个测试用例的结果列表，每个测试用例列表包含 $[\\Phi_{\\infty}, N, L_{\\text{vac}}, \\text{boolean}]$，所有内容都用方括号括起来，如下所示：\n“您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，`[[\\phi_1,N_1,L_1,True],[\\phi_2,N_2,L_2,False]]`）”。\n\n测试套件：\n- 测试用例 1（具有非零交叉项的一般情况）：\n  - 数据点 $(N, L_{\\text{vac}}, \\Phi)$：\n    - $(6, 12, 5.3573611)$,\n    - $(8, 12, 5.3521875)$,\n    - $(10, 12, 5.3490833)$,\n    - $(6, 16, 5.3530208)$,\n    - $(8, 16, 5.3478906)$,\n    - $(10, 16, 5.3448125)$,\n    - $(6, 20, 5.3504167)$,\n    - $(8, 20, 5.3453125)$,\n    - $(10, 20, 5.34225)$.\n  - 目标容差 $\\tau = 0.02$ 电子伏特。\n  - 初始构型 $(N_0, L_{\\text{vac},0}) = (10, 16)$。\n\n- 测试用例 2（交叉项为零的边界情况）：\n  - 数据点 $(N, L_{\\text{vac}}, \\Phi)$：\n    - $(3, 8, 4.9708333)$,\n    - $(3, 10, 4.9633333)$,\n    - $(3, 12, 4.958333)$,\n    - $(4, 8, 4.9375)$,\n    - $(4, 10, 4.93)$,\n    - $(4, 12, 4.925)$,\n    - $(5, 8, 4.9175)$,\n    - $(5, 10, 4.91)$,\n    - $(5, 12, 4.905)$.\n  - 目标容差 $\\tau = 0.05$ 电子伏特。\n  - 初始构型 $(N_0, L_{\\text{vac},0}) = (5, 10)$。\n\n- 测试用例 3（具有强交叉项和中等真空效应的边缘情况）：\n  - 数据点 $(N, L_{\\text{vac}}, \\Phi)$：\n    - $(5, 10, 5.165)$,\n    - $(5, 20, 5.1525)$,\n    - $(5, 30, 5.1483333)$,\n    - $(7, 10, 5.1507143)$,\n    - $(7, 20, 5.1396429)$,\n    - $(7, 30, 5.1359524)$,\n    - $(9, 10, 5.1427778)$,\n    - $(9, 20, 5.1325)$,\n    - $(9, 30, 5.1290741)$.\n  - 目标容差 $\\tau = 0.03$ 电子伏特。\n  - 初始构型 $(N_0, L_{\\text{vac},0}) = (7, 20)$。\n\n您的程序应计算拟合参数，根据指定的收敛方案确定推荐的最小 $N$ 和 $L_{\\text{vac}}$，并根据容差评估初始构型。最终的单行输出必须是：\n- 一个包含三个测试用例结果列表 $[\\Phi_{\\infty}, N, L_{\\text{vac}}, \\text{boolean}]$ 的单一列表，以嵌套方括号和逗号分隔值的形式精确打印为一行，其中 $\\Phi_{\\infty}$ 四舍五入到3位小数。", "solution": "该问题要求分析板坯模型中功函数计算的有限尺寸效应，并实现一个收敛方案。解决方案包括两个主要阶段：首先，通过对所提供的数据进行线性最小二乘拟合，确定给定渐近模型的参数；其次，应用指定的收敛方案，找到满足给定误差容差的最小板坯厚度和真空厚度。\n\n所提供的功函数 $\\Phi$ 作为原子层数 $N$ 和真空厚度 $L_{\\text{vac}}$ 的函数的渐近展开式为：\n$$ \\Phi(N,L_{\\text{vac}}) = \\Phi_{\\infty} + \\frac{A_N}{N} + \\frac{A_L}{L_{\\text{vac}}} + \\frac{A_{NL}}{N\\,L_{\\text{vac}}} $$\n该方程对于未知系数 $\\mathbf{c} = [\\Phi_{\\infty}, A_N, A_L, A_{NL}]^T$ 是线性的。给定一组 $M$ 个数据点 $\\{(N_i, L_{\\text{vac},i}, \\Phi_i)\\}_{i=1}^M$，我们可以建立一个线性方程组。对于每个数据点 $i$，我们定义一个特征向量 $\\mathbf{x}_i = [1, 1/N_i, 1/L_{\\text{vac},i}, 1/(N_i L_{\\text{vac},i})]$。然后，该模型可以表示为矩阵形式 $\\mathbf{y} \\approx \\mathbf{X}\\mathbf{c}$，其中 $\\mathbf{y}$ 是观测到的功函数 $\\Phi_i$ 的向量，$\\mathbf{X}$ 是一个 $M \\times 4$ 的设计矩阵，其行是特征向量 $\\mathbf{x}_i$。\n\n最佳拟合系数 $\\mathbf{c}$ 通过最小化残差平方和 $\\|\\mathbf{y} - \\mathbf{X}\\mathbf{c}\\|^2$ 来找到。这是一个标准的线性最小二乘问题。其解的正式形式为 $\\mathbf{c} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}$，为了稳健性，我们对其进行数值求解，例如，使用在 `numpy.linalg.lstsq` 中实现的奇异值分解。\n\n一旦确定了系数 $\\Phi_{\\infty}$、$A_N$、$A_L$ 和 $A_{NL}$，我们就进行收敛方案，以找到最小整数板坯厚度 $N$ 和真空厚度 $L_{\\text{vac}}$，确保总残余有限尺寸修正 $E_{\\text{res}}$ 低于目标容差 $\\tau$。残余误差定义为：\n$$ E_{\\text{res}}(N,L_{\\text{vac}}) = \\left|\\frac{A_N}{N}\\right| + \\left|\\frac{A_L}{L_{\\text{vac}}}\\right| + \\left|\\frac{A_{NL}}{N\\,L_{\\text{vac}}}\\right| $$\n该方案指定使用相等误差分配，这意味着要满足三个部分目标：\n$$ \\left|\\frac{A_N}{N}\\right| \\leq \\frac{\\tau}{3}, \\quad \\left|\\frac{A_L}{L_{\\text{vac}}}\\right| \\leq \\frac{\\tau}{3}, \\quad \\left|\\frac{A_{NL}}{N\\,L_{\\text{vac}}}\\right| \\leq \\frac{\\tau}{3} $$\n确定最小 $N$ 和 $L_{\\text{vac}}$ 的方案执行如下：\n1. 根据第一个不等式确定最小整数 $N$。由于 $N$ 必须至少为 1，我们有：\n$$ N_{\\text{rec}} = \\max\\left(1, \\left\\lceil \\frac{3|A_N|}{\\tau} \\right\\rceil\\right) $$\n2. 确定满足第二个不等式的最小整数 $L_{\\text{vac}}$。由于 $L_{\\text{vac}}$ 必须至少为 1，我们有一个初始候选值：\n$$ L_{\\text{vac},1} = \\max\\left(1, \\left\\lceil \\frac{3|A_L|}{\\tau} \\right\\rceil\\right) $$\n3. 在给定步骤1中得到的 $N_{\\text{rec}}$ 值的情况下，调整 $L_{\\text{vac}}$ 以同时满足第三个不等式。措辞“最小调整”根据计算材料科学中的常规做法，被解释为保持 $N$ 固定（因为它对计算成本影响更大）并根据需要增加 $L_{\\text{vac}}$。这引出了 $L_{\\text{vac}}$ 的第二个候选值：\n$$ L_{\\text{vac},2} = \\left\\lceil \\frac{3|A_{NL}|}{N_{\\text{rec}}\\,\\tau} \\right\\rceil $$\n最小所需 $L_{\\text{vac}}$ 必须满足两个约束条件，因此我们取两个候选值中的最大值：\n$$ L_{\\text{vac,rec}} = \\max(L_{\\text{vac},1}, L_{\\text{vac},2}) $$\n4. 根据构造，数对 $(N_{\\text{rec}}, L_{\\text{vac,rec}})$ 现在满足所有三个部分目标不等式。将这些不等式相加可保证总残余误差 $E_{\\text{res}}(N_{\\text{rec}}, L_{\\text{vac,rec}}) \\leq \\tau/3 + \\tau/3 + \\tau/3 = \\tau$。因此，“如有必要，进一步增加其中一个或两个值”这一条款不需要额外的步骤，因为条件已经满足。数对 $(N_{\\text{rec}}, L_{\\text{vac,rec}})$ 是推荐的最小构型。\n\n最后，对于每个测试用例，我们通过计算 $E_{\\text{res}}(N_0, L_{\\text{vac},0})$ 并将其与 $\\tau$ 比较，来评估所提供的初始构型 $(N_0, L_{\\text{vac},0})$ 是否满足容差。拟合得到的 $\\Phi_{\\infty}$ 值报告时四舍五入到3位小数。\n\n对所提供的每个测试用例都实现了这整个过程。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"data\": [\n                (6, 12, 5.3573611), (8, 12, 5.3521875), (10, 12, 5.3490833),\n                (6, 16, 5.3530208), (8, 16, 5.3478906), (10, 16, 5.3448125),\n                (6, 20, 5.3504167), (8, 20, 5.3453125), (10, 20, 5.34225),\n            ],\n            \"tau\": 0.02,\n            \"start_config\": (10, 16)\n        },\n        {\n            \"data\": [\n                (3, 8, 4.9708333), (3, 10, 4.9633333), (3, 12, 4.958333),\n                (4, 8, 4.9375), (4, 10, 4.93), (4, 12, 4.925),\n                (5, 8, 4.9175), (5, 10, 4.91), (5, 12, 4.905),\n            ],\n            \"tau\": 0.05,\n            \"start_config\": (5, 10)\n        },\n        {\n            \"data\": [\n                (5, 10, 5.165), (5, 20, 5.1525), (5, 30, 5.1483333),\n                (7, 10, 5.1507143), (7, 20, 5.1396429), (7, 30, 5.1359524),\n                (9, 10, 5.1427778), (9, 20, 5.1325), (9, 30, 5.1290741),\n            ],\n            \"tau\": 0.03,\n            \"start_config\": (7, 20)\n        }\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        result = _solve_single_case(case[\"data\"], case[\"tau\"], case[\"start_config\"])\n        \n        phi_inf, N_rec, Lvac_rec, is_converged_0 = result\n        \n        # Format the sublist string to match the required output format exactly.\n        sub_result_str = f\"[{phi_inf:.3f},{N_rec},{Lvac_rec},{is_converged_0}]\"\n        results_as_strings.append(sub_result_str)\n\n    # Print the final combined string.\n    print(f\"[{','.join(results_as_strings)}]\")\n\ndef _solve_single_case(data, tau, start_config):\n    \"\"\"\n    Solves a single test case according to the problem description.\n    \"\"\"\n    points = np.array(data)\n    N_vals = points[:, 0]\n    Lvac_vals = points[:, 1]\n    Phi_vals = points[:, 2]\n\n    # 1. Linear Least Squares Fit\n    # Construct the design matrix X\n    X = np.zeros((len(points), 4))\n    X[:, 0] = 1.0\n    X[:, 1] = 1.0 / N_vals\n    X[:, 2] = 1.0 / Lvac_vals\n    X[:, 3] = 1.0 / (N_vals * Lvac_vals)\n    \n    # Solve the linear system Xc = y for the coefficients c\n    coeffs, _, _, _ = np.linalg.lstsq(X, Phi_vals, rcond=None)\n    Phi_inf, A_N, A_L, A_NL = coeffs\n\n    # 2. Convergence Protocol\n    # Minimal N from the first partial target\n    # N is an integer number of layers, so it must be at least 1.\n    N_rec = math.ceil(3 * abs(A_N) / tau) if tau > 0 else float('inf')\n    N_rec = max(1, N_rec)\n\n    # Minimal L_vac from the second partial target\n    # L_vac must be at least 1 Angstrom.\n    Lvac_rec_1 = math.ceil(3 * abs(A_L) / tau) if tau > 0 else float('inf')\n    Lvac_rec_1 = max(1, Lvac_rec_1)\n    \n    # L_vac required by the third partial target, given N_rec\n    if abs(A_NL) > 1e-12 and N_rec > 0 and tau > 0:\n        Lvac_rec_2 = math.ceil(3 * abs(A_NL) / (N_rec * tau))\n    else:\n        Lvac_rec_2 = 1 # Minimal Lvac is 1\n\n    # The final L_vac must satisfy both constraints.\n    Lvac_rec = max(Lvac_rec_1, Lvac_rec_2)\n    \n    # The condition E_res = tau is guaranteed by construction. The \"further increase\"\n    # step is not necessary as explained in the solution.\n    \n    # 3. Check Starting Configuration\n    N0, Lvac0 = start_config\n    \n    def calculate_residual(N, Lvac):\n        if N = 0 or Lvac = 0:\n            return float('inf')\n        return abs(A_N)/N + abs(A_L)/Lvac + abs(A_NL)/(N * Lvac)\n\n    err0 = calculate_residual(N0, Lvac0)\n    is_converged_0 = err0 = tau\n\n    return [Phi_inf, int(N_rec), int(Lvac_rec), is_converged_0]\n\nsolve()\n```", "id": "3487626"}]}