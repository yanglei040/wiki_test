{"hands_on_practices": [{"introduction": "簇展开方法的核心在于拟合有效簇相互作用（ECI）参数。这个过程的本质是将构型能量与一组预定义的簇关联函数之间建立线性关系。本练习将通过一个简化的理想模型，引导您手动完成这一关键步骤，从而为理解更复杂的自动化拟合程序奠定坚实的基础。通过为几个原子构型显式计算关联函数并求解线性方程组，您将亲身体验如何从第一性原理数据中提取出描述合金热力学行为的ECI参数。[@problem_id:3437949]", "problem": "考虑一个二元合金模型，该模型建立在一个具有$N=6$个晶格点的一维周期性环上，并使用类伊辛（Ising）占据变量$\\sigma_{i}\\in\\{+1,-1\\}$，其中$\\sigma_{i}=+1$表示A组分，$\\sigma_{i}=-1$表示B组分。每个晶格点的构型能由一个截断的团簇展开表示，该展开只保留到次近邻的对团簇。对于一个给定的构型，定义壳层$\\alpha$的对相关性$\\Pi_{\\alpha}$为\n$$\n\\Pi_{\\alpha} \\equiv \\frac{1}{M_{\\alpha}}\\sum_{\\langle i,j\\rangle_{\\alpha}} \\sigma_{i}\\sigma_{j},\n$$\n其中$M_{\\alpha}$是壳层$\\alpha$中不同对的数量，求和遍及所有以第$\\alpha$近邻距离分隔的对称等价对。在$N=6$的环上，每个格点有$z_{1}=2$个最近邻和$z_{2}=2$个次近邻，因此$M_{1}=M_{2}=6$。假设组分为等原子比，并且形成能的设定使得空团簇和单点贡献为常数，这些常数被吸收到参考能量中（设为零），因此每个格点的能量$E$与对相关性呈线性关系，其中包含两个未知的有效团簇相互作用（ECI）$J_{1}$和$J_{2}$：\n$$\nE = J_{1}\\,\\Pi_{1} + J_{2}\\,\\Pi_{2}.\n$$\n考虑环上以下三种不同的等原子比构型，由环上$\\sigma_{i}$的序列指定：\n- 构型 $\\mathcal{A}$：$+1,-1,+1,-1,+1,-1$（A和B交替排列），\n- 构型 $\\mathcal{B}$：$+1,+1,+1,-1,-1,-1$（三个A后跟三个B），\n- 构型 $\\mathcal{C}$：$+1,-1,-1,+1,+1,-1$。\n\n对于这三种构型，假设每个格点测得的形成能（来自一个假设的第一性原理数据集）为\n$$\nE_{\\mathcal{A}}=1\\ \\text{eV},\\quad E_{\\mathcal{B}}=-\\frac{1}{3}\\ \\text{eV},\\quad E_{\\mathcal{C}}=-1\\ \\text{eV}.\n$$\n从上述定义出发，并且不使用任何未引入的简化公式，显式计算每种构型的对相关性$\\Pi_{1}$和$\\Pi_{2}$，建立关联$\\{E_{\\mathcal{A}},E_{\\mathcal{B}},E_{\\mathcal{C}}\\}$与$\\{J_{1},J_{2}\\}$的线性方程组，并精确求解两个对有效团簇相互作用$J_{1}$和$J_{2}$。以电子伏特（electronvolts）为单位表示$J_{1}$和$J_{2}$的最终值。无需四舍五入；请提供精确值。", "solution": "该问题要求计算在一个具有$N=6$个晶格点的一维周期性环上的二元合金的两个有效团簇相互作用（ECI），即$J_{1}$和$J_{2}$。每个格点的构型能$E$由一个截断的团簇展开建模：\n$$\nE = J_{1}\\,\\Pi_{1} + J_{2}\\,\\Pi_{2}\n$$\n其中$\\Pi_{\\alpha}$是第$\\alpha$近邻壳层的对相关性。格点$i$的占据由变量$\\sigma_{i} \\in \\{+1, -1\\}$描述。对相关性定义为：\n$$\n\\Pi_{\\alpha} \\equiv \\frac{1}{M_{\\alpha}}\\sum_{\\langle i,j\\rangle_{\\alpha}} \\sigma_{i}\\sigma_{j}\n$$\n其中求和遍及$M_{\\alpha}$个不同的第$\\alpha$近邻对。对于一个具有$N=6$个格点的一维周期性环，格点$i$的最近邻是格点$i+1$和$i-1$，次近邻是$i+2$和$i-2$（索引以$6$为模）。不同的最近邻对的总数为$M_1=6$，不同的次近邻对的总数为$M_2=6$。对于周期性环，对所有不同对$\\langle i,j\\rangle_{\\alpha}$的求和可以通过对所有格点$i$（从$1$到$N$）求和$\\sigma_i \\sigma_{i+\\delta}$来计算，其中$\\delta$是近邻距离（对于最近邻$\\delta=1$，对于次近邻$\\delta=2$），并应用周期性边界条件（$\\sigma_{N+k} = \\sigma_k$）。\n\n解题步骤是：首先计算三种给定构型各自的对相关性$\\Pi_{1}$和$\\Pi_{2}$，然后使用给定的能量$\\{E_{\\mathcal{A}}, E_{\\mathcal{B}}, E_{\\mathcal{C}}\\}$建立一个关于$J_{1}$和$J_{2}$的线性方程组，最后求解该方程组。\n\n**1. 对相关性的计算**\n\n**构型 $\\mathcal{A}$：$(\\sigma_{1}, \\sigma_{2}, \\sigma_{3}, \\sigma_{4}, \\sigma_{5}, \\sigma_{6}) = (+1, -1, +1, -1, +1, -1)$**\n对于最近邻（$\\delta=1$）：\n乘积之和为 $\\sum_{i=1}^{6} \\sigma_{i}\\sigma_{i+1} = \\sigma_1\\sigma_2 + \\sigma_2\\sigma_3 + \\sigma_3\\sigma_4 + \\sigma_4\\sigma_5 + \\sigma_5\\sigma_6 + \\sigma_6\\sigma_1$。\n代入数值：$(+1)(-1) + (-1)(+1) + (+1)(-1) + (-1)(+1) + (+1)(-1) + (-1)(+1) = -1 -1 -1 -1 -1 -1 = -6$。\n最近邻相关性为 $\\Pi_{1,\\mathcal{A}} = \\frac{1}{M_1}\\sum \\sigma_i\\sigma_{i+1} = \\frac{1}{6}(-6) = -1$。\n\n对于次近邻（$\\delta=2$）：\n乘积之和为 $\\sum_{i=1}^{6} \\sigma_{i}\\sigma_{i+2} = \\sigma_1\\sigma_3 + \\sigma_2\\sigma_4 + \\sigma_3\\sigma_5 + \\sigma_4\\sigma_6 + \\sigma_5\\sigma_1 + \\sigma_6\\sigma_2$。\n代入数值：$(+1)(+1) + (-1)(-1) + (+1)(+1) + (-1)(-1) + (+1)(+1) + (-1)(-1) = 1 + 1 + 1 + 1 + 1 + 1 = 6$。\n次近邻相关性为 $\\Pi_{2,\\mathcal{A}} = \\frac{1}{M_2}\\sum \\sigma_i\\sigma_{i+2} = \\frac{1}{6}(6) = 1$。\n\n**构型 $\\mathcal{B}$：$(\\sigma_{1}, \\sigma_{2}, \\sigma_{3}, \\sigma_{4}, \\sigma_{5}, \\sigma_{6}) = (+1, +1, +1, -1, -1, -1)$**\n对于最近邻：\n$\\sum \\sigma_i\\sigma_{i+1} = (+1)(+1) + (+1)(+1) + (+1)(-1) + (-1)(-1) + (-1)(-1) + (-1)(+1) = 1 + 1 - 1 + 1 + 1 - 1 = 2$。\n$\\Pi_{1,\\mathcal{B}} = \\frac{1}{6}(2) = \\frac{1}{3}$。\n\n对于次近邻：\n$\\sum \\sigma_i\\sigma_{i+2} = (+1)(+1) + (+1)(-1) + (+1)(-1) + (-1)(-1) + (-1)(+1) + (-1)(+1) = 1 - 1 - 1 + 1 - 1 - 1 = -2$。\n$\\Pi_{2,\\mathcal{B}} = \\frac{1}{6}(-2) = -\\frac{1}{3}$。\n\n**构型 $\\mathcal{C}$：$(\\sigma_{1}, \\sigma_{2}, \\sigma_{3}, \\sigma_{4}, \\sigma_{5}, \\sigma_{6}) = (+1, -1, -1, +1, +1, -1)$**\n对于最近邻：\n$\\sum \\sigma_i\\sigma_{i+1} = (+1)(-1) + (-1)(-1) + (-1)(+1) + (+1)(+1) + (+1)(-1) + (-1)(+1) = -1 + 1 - 1 + 1 - 1 - 1 = -2$。\n$\\Pi_{1,\\mathcal{C}} = \\frac{1}{6}(-2) = -\\frac{1}{3}$。\n\n对于次近邻：\n$\\sum \\sigma_i\\sigma_{i+2} = (+1)(-1) + (-1)(+1) + (-1)(+1) + (+1)(-1) + (+1)(+1) + (-1)(-1) = -1 - 1 - 1 - 1 + 1 + 1 = -2$。\n$\\Pi_{2,\\mathcal{C}} = \\frac{1}{6}(-2) = -\\frac{1}{3}$。\n\n**2. 建立并求解线性方程组**\n\n现在我们对每种构型使用能量表达式 $E = J_{1}\\Pi_{1} + J_{2}\\Pi_{2}$ 及其给定的能量：$E_{\\mathcal{A}}=1$ eV, $E_{\\mathcal{B}}=-\\frac{1}{3}$ eV, 和 $E_{\\mathcal{C}}=-1$ eV。\n\n对于 $\\mathcal{A}$：$1 = J_{1}(-1) + J_{2}(1) \\implies -J_{1} + J_{2} = 1$。（方程 1）\n对于 $\\mathcal{B}$：$-\\frac{1}{3} = J_{1}(\\frac{1}{3}) + J_{2}(-\\frac{1}{3}) \\implies J_{1} - J_{2} = -1$。（方程 2）\n对于 $\\mathcal{C}$：$-1 = J_{1}(-\\frac{1}{3}) + J_{2}(-\\frac{1}{3}) \\implies J_{1} + J_{2} = 3$。（方程 3）\n\n得到的线性方程组为：\n$$\n\\begin{cases}\n-J_{1} + J_{2} = 1 \\\\\nJ_{1} - J_{2} = -1 \\\\\nJ_{1} + J_{2} = 3\n\\end{cases}\n$$\n方程（2）在数学上与方程（1）是相同的，因为将方程（2）乘以-1即可得到方程（1）。这证实了构型$\\mathcal{A}$和$\\mathcal{B}$的数据是一致的，并且在相关性空间中是共线的，但这也意味着我们必须使用来自构型$\\mathcal{C}$的独立信息来找到唯一解。我们求解由方程（1）和方程（3）组成的方程组：\n$$\n\\begin{cases}\n-J_{1} + J_{2} = 1 \\\\\nJ_{1} + J_{2} = 3\n\\end{cases}\n$$\n将两个方程相加：\n$(-J_{1} + J_{2}) + (J_{1} + J_{2}) = 1 + 3$\n$2J_{2} = 4$\n$J_{2} = 2$。\n\n将$J_{2}$的值代入方程（3）：\n$J_{1} + 2 = 3$\n$J_{1} = 1$。\n\n解为 $J_{1} = 1$ eV 和 $J_{2} = 2$ eV。我们可以使用方程（2）（来自构型 $\\mathcal{B}$）来验证此解：$(1) - (2) = -1$，这是正确的。这些值与所有三个数据点都一致。", "answer": "$$\n\\boxed{\\begin{pmatrix} 1  2 \\end{pmatrix}}\n$$", "id": "3437949"}, {"introduction": "构建一个簇展开模型不仅仅是拟合有效簇相互作用（ECI）参数；更重要的是评估其预测能力。一个模型的真正价值在于它对未见数据的预测准确性，而交叉验证是评估这种泛化能力的标准统计学工具。本练习将指导您实现K折交叉验证，并探讨在处理实际数据中常见的共线性问题（例如冗余或冲突的训练结构）时，如何利用广义逆矩阵来确保模型的稳健性。通过这项实践，您将学会量化模型的预测误差，这是构建可靠预测模型的关键一步。[@problem_id:3437890]", "problem": "您将处理一个用于二元合金的最小线性簇展开（CE）设置，其中每个结构的构型能量被建模为预先计算的簇关联函数的线性组合。具体来说，对于一个由 $i \\in \\{0,1,\\dots,N-1\\}$ 索引的结构数据集，每个结构都有一个关联向量 $\\boldsymbol{\\phi}_i \\in \\mathbb{R}^p$（作为设计矩阵 $X \\in \\mathbb{R}^{N \\times p}$ 的行收集起来），以及一个能量值 $y_i \\in \\mathbb{R}$（收集成向量 $\\mathbf{y} \\in \\mathbb{R}^N$）。该模型假设\n$$\nE_i \\equiv y_i \\approx \\sum_{\\alpha=0}^{p-1} J_{\\alpha} \\, \\phi_{i,\\alpha} \\quad \\text{或以矩阵形式表示} \\quad \\mathbf{y} \\approx X \\mathbf{J},\n$$\n其中 $\\mathbf{J} \\in \\mathbb{R}^p$ 是未知的有效簇相互作用（ECIs）。ECIs 通过普通最小二乘法（OLS）获得，定义为残差平方和的最小化子。当 $X$ 由于行向量共线性而秩亏或病态时，解被取为通过 Moore–Penrose 伪逆（MPP）（记为 $X^{+}$）计算的最小范数 OLS 解，因此\n$$\n\\widehat{\\mathbf{J}} = X^{+} \\mathbf{y}.\n$$\n\n为了评估预测性能，您将实现 $K$ 折交叉验证（K-FCV）。在 $K$ 折交叉验证（K-FCV）中，索引集 $\\{0,1,\\dots,N-1\\}$ 根据规则被确定性地划分为 $K$ 个折：如果 $i \\bmod K = f$，则索引 $i$ 被分配到折 $f$，其中 $f \\in \\{0,1,\\dots,K-1\\}$。对于每个折 $f$，模型在折 $f$ 的补集上进行训练，并在折 $f$ 上进行评估。交叉验证分数（CVS）定义为在所有折的全部留出预测上聚合的均方根误差（RMSE）：\n$$\n\\mathrm{CVS}_K(X,\\mathbf{y}) = \\sqrt{ \\frac{1}{N} \\sum_{f=0}^{K-1} \\ \\sum_{i \\in \\mathcal{I}_f} \\left( y_i - \\widehat{y}_i^{(f)} \\right)^2 },\n$$\n其中 $\\mathcal{I}_f$ 是折 $f$ 中的索引集，且 $\\widehat{y}_i^{(f)} = \\boldsymbol{\\phi}_i^{\\mathsf{T}} \\, \\widehat{\\mathbf{J}}^{(f)}$，其中\n$$\n\\widehat{\\mathbf{J}}^{(f)} = X_{-f}^{+} \\, \\mathbf{y}_{-f},\n$$\n并且 $(X_{-f}, \\mathbf{y}_{-f})$ 表示排除了折 $f$ 的训练数据。\n\n您的任务是数值上展示当一个共线性训练结构（一个现有关联向量的精确副本）被添加到数据集中时，$K$ 折交叉验证分数（CVS）如何变化。您将计算添加前后的 CVS，并报告其变化。所有计算都必须使用通过 Moore–Penrose 伪逆计算的 OLS 估计量。\n\n使用以下具有 $N = 6$ 个结构和 $p = 4$ 个特征的基础数据集（第一个特征是等于 $1$ 的截距项）。设计矩阵 $X_0 \\in \\mathbb{R}^{6 \\times 4}$ 和能量向量 $\\mathbf{y}_0 \\in \\mathbb{R}^6$ 如下：\n$$\nX_0 = \\begin{bmatrix}\n1  -1.0  -0.2  0.5 \\\\\n1  -0.5  \\phantom{-}0.1  -0.3 \\\\\n1  \\phantom{-}0.0  -0.4  \\phantom{-}0.2 \\\\\n1  \\phantom{-}0.5  \\phantom{-}0.2  -0.1 \\\\\n1  -0.3  \\phantom{-}0.4  -0.5 \\\\\n1  \\phantom{-}0.8  -0.1  \\phantom{-}0.4\n\\end{bmatrix},\n\\quad\n\\mathbf{y}_0 = \\begin{bmatrix}\n1.05 \\\\ 0.56 \\\\ 0.06 \\\\ -0.13 \\\\ 0.49 \\\\ -0.37\n\\end{bmatrix}.\n$$\n\n在下面的每个测试用例中，您将：\n- 对指定的 $K$ 计算 $\\mathrm{CVS}_K(X_0,\\mathbf{y}_0)$。\n- 通过追加一个与 $X_0$ 的行索引 $d = 1$（从零开始的索引）共线的额外行来构建增广数据集 $(X', \\mathbf{y}')$；也就是说，将相同的特征向量 $\\boldsymbol{\\phi}_{1}$ 作为新的第 $(N+1)$ 行追加。追加的能量是该测试用例中指定的标量 $y_{\\mathrm{dup}}$。明确地，$X' = \\begin{bmatrix} X_0 \\\\ \\boldsymbol{\\phi}_1^{\\mathsf{T}} \\end{bmatrix}$ 且 $\\mathbf{y}' = \\begin{bmatrix} \\mathbf{y}_0 \\\\ y_{\\mathrm{dup}} \\end{bmatrix}$。\n- 对相同的 $K$ 计算 $\\mathrm{CVS}_K(X',\\mathbf{y}')$。\n- 报告这两个值以及它们的差值 $\\Delta \\mathrm{CVS} = \\mathrm{CVS}_K(X',\\mathbf{y}') - \\mathrm{CVS}_K(X_0,\\mathbf{y}_0)$。\n\n使用无随机性的确定性操作来实现上述过程，并对折分配和重复索引 $d = 1$ 使用从零开始的索引。\n\n测试套件：\n- 测试用例 1：$K = 3$，$y_{\\mathrm{dup}} = 0.56$（一致的重复项）。\n- 测试用例 2：$K = 3$，$y_{\\mathrm{dup}} = 0.62$（轻微不一致的重复项）。\n- 测试用例 3：$K = 6$，$y_{\\mathrm{dup}} = 0.86$（强烈不一致的重复项）。\n- 测试用例 4：$K = 2$，$y_{\\mathrm{dup}} = 0.56$（边界折数下的一致重复项）。\n\n输出规格：\n- 对于每个测试用例 $t \\in \\{1,2,3,4\\}$，计算三元组\n$$\n\\big( \\mathrm{CVS}^{\\mathrm{before}}_t, \\ \\mathrm{CVS}^{\\mathrm{after}}_t, \\ \\Delta \\mathrm{CVS}_t \\big).\n$$\n- 将报告的 12 个标量值中的每一个都四舍五入到小数点后 6 位。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$$\n\\big[ \\mathrm{CVS}^{\\mathrm{before}}_1, \\ \\mathrm{CVS}^{\\mathrm{after}}_1, \\ \\Delta \\mathrm{CVS}_1, \\ \\mathrm{CVS}^{\\mathrm{before}}_2, \\ \\mathrm{CVS}^{\\mathrm{after}}_2, \\ \\Delta \\mathrm{CVS}_2, \\ \\mathrm{CVS}^{\\mathrm{before}}_3, \\ \\mathrm{CVS}^{\\mathrm{after}}_3, \\ \\Delta \\mathrm{CVS}_3, \\ \\mathrm{CVS}^{\\mathrm{before}}_4, \\ \\mathrm{CVS}^{\\mathrm{after}}_4, \\ \\Delta \\mathrm{CVS}_4 \\big].\n$$\n\n注意事项：\n- 通过 $i \\bmod K$ 明确实现 $K$ 折分配。\n- 使用 Moore–Penrose 伪逆进行 OLS 以确保共线性下的数值稳定性。\n- 此计算不涉及物理单位。", "solution": "问题陈述是有效的。它在科学上基于应用于计算材料科学（特别是簇展开方法）的线性回归和交叉验证原理。该问题是适定的，所有必要的数据、参数和确定性过程都有明确的定义。使用 Moore-Penrose 伪逆是处理实验设置中引入的共线性的一种合适且标准的技术。该问题是客观且可形式化的，没有模糊或矛盾之处。\n\n任务是计算一个线性模型在向数据集中添加一个共线数据点之前和之后的 $K$ 折交叉验证分数（CVS）。模型的参数，称为有效簇相互作用（ECIs），是使用通过 Moore-Penrose 伪逆（MPP）计算的普通最小二乘法（OLS）估计量来确定的。\n\n整体算法设计基于对所述 $K$ 折交叉验证过程的直接实现。CVS 定义为在所有留出预测上聚合的均方根误差（RMSE）：\n$$\n\\mathrm{CVS}_K(X,\\mathbf{y}) = \\sqrt{ \\frac{1}{N} \\sum_{f=0}^{K-1} \\ \\sum_{i \\in \\mathcal{I}_f} \\left( y_i - \\widehat{y}_i^{(f)} \\right)^2 }\n$$\n其中 $N$ 是结构的总数，$\\mathcal{I}_f$ 是折 $f$ 中的索引集，$\\widehat{y}_i^{(f)}$ 是结构 $i$ 作为折 $f$ 的留出集一部分时的预测能量。\n\n该过程可以分解为以下步骤：\n\n1.  数据划分：数据索引集 $\\{0, 1, \\dots, N-1\\}$ 被确定性地划分为 $K$ 个折。根据问题的规则，索引为 $i$ 的结构被分配到折 $f$，其中 $f = i \\bmod K$。\n\n2.  迭代训练和测试：该过程从 $0$ 到 $K-1$ 遍历每个折 $f$。在每次迭代中，与折 $f$ 对应的数据作为测试集，而来自所有其他 $K-1$ 个折的数据构成训练集。\n    - 令 $(X_{-f}, \\mathbf{y}_{-f})$ 为训练数据（设计矩阵和能量向量），$(X_f, \\mathbf{y}_f)$ 为折 $f$ 的测试数据。\n    - 该折的 ECI 向量 $\\widehat{\\mathbf{J}}^{(f)}$ 是使用基于 MPP 的 OLS 估计量从训练数据中计算出来的：\n    $$\n    \\widehat{\\mathbf{J}}^{(f)} = X_{-f}^{+} \\, \\mathbf{y}_{-f}\n    $$\n    Moore-Penrose 伪逆 $X_{-f}^{+}$ 是必不可少的。当使用增广数据集时，某些折的训练集 $X_{-f}$ 将包含两个相同的行，导致矩阵秩亏。在这种情况下，标准矩阵逆 $(X_{-f}^{\\mathsf{T}}X_{-f})^{-1}$ 将是未定义的。MPP 提供了一个唯一的最小范数解，确保了数值稳定性。这是使用 `numpy.linalg.pinv` 实现的。\n\n3.  预测和误差累积：使用拟合模型 $\\widehat{\\mathbf{J}}^{(f)}$ 对留出测试集 $X_f$ 进行预测：\n    $$\n    \\widehat{\\mathbf{y}}_f = X_f \\, \\widehat{\\mathbf{J}}^{(f)}\n    $$\n    将预测能量 $\\widehat{\\mathbf{y}}_f$（包含对 $i \\in \\mathcal{I}_f$ 的元素 $\\widehat{y}_i^{(f)}$）与真实能量 $\\mathbf{y}_f$（包含元素 $y_i$）进行比较。计算当前折的误差平方和（SSE），即 $\\sum_{i \\in \\mathcal{I}_f} (y_i - \\widehat{y}_i^{(f)})^2$，并将其加到累计总和中。\n\n4.  CVS 计算：在遍历完所有 $K$ 个折之后，每个数据点都恰好被用于测试一次。将总 SSE 除以数据点总数 $N$，然后取该值的平方根，即可得到最终的 CVS。\n\n这整个过程被封装在一个函数中。对于每个测试用例，首先使用初始数据集 $(X_0, \\mathbf{y}_0)$ 和指定的 $K$ 调用此函数以找到 $\\mathrm{CVS}^{\\mathrm{before}}$。然后，通过追加 $X_0$ 中索引为 $d=1$ 的行的副本及其对应的能量 $y_{\\mathrm{dup}}$ 来创建增广数据集 $(X', \\mathbf{y}')$，使样本总数增加到 $N'=N+1$。再次使用 $(X', \\mathbf{y}')$ 调用 CVS 函数以找到 $\\mathrm{CVS}^{\\mathrm{after}}$。然后计算差值 $\\Delta \\mathrm{CVS} = \\mathrm{CVS}^{\\mathrm{after}} - \\mathrm{CVS}^{\\mathrm{before}}$。最终输出整理了所有测试用例的这三个值，每个值都四舍五入到小数点后六位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_cvs(X: np.ndarray, y: np.ndarray, K: int) -> float:\n    \"\"\"\n    Computes the K-fold Cross-Validation Score (CVS) for a linear model.\n    The model is trained using the Moore-Penrose Pseudoinverse.\n    \"\"\"\n    N = X.shape[0]\n    total_sse = 0.0\n\n    for f in range(K):\n        # Create boolean masks for the train/test split for the current fold.\n        # An index i belongs to fold f if i mod K == f.\n        test_mask = np.array([i % K == f for i in range(N)])\n        \n        # Guard against empty test folds, though not expected with the problem's parameters.\n        if not np.any(test_mask):\n            continue\n            \n        train_mask = ~test_mask\n\n        # Guard against empty training folds.\n        if not np.any(train_mask):\n            # If the training set is empty, no model can be fit.\n            # Predictions are undefined, so we can't calculate error.\n            # For this problem's constraints (K = N), this case will not occur.\n            continue\n            \n        X_train, y_train = X[train_mask], y[train_mask]\n        X_test, y_test = X[test_mask], y[test_mask]\n\n        # Compute the Effective Cluster Interactions (ECIs) using the Moore-Penrose Pseudoinverse.\n        # This is robust to collinearity/rank-deficiency in X_train.\n        X_train_pinv = np.linalg.pinv(X_train)\n        J_hat_f = X_train_pinv @ y_train\n\n        # Predict energies for the held-out test set.\n        y_pred_f = X_test @ J_hat_f\n\n        # Calculate and accumulate the sum of squared errors for this fold.\n        fold_sse = np.sum((y_test - y_pred_f)**2)\n        total_sse += fold_sse\n    \n    # The CVS is the root mean square error over all N out-of-sample predictions.\n    cvs = np.sqrt(total_sse / N)\n    return cvs\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating CVS before and after adding a collinear row.\n    \"\"\"\n    # Define the base dataset from the problem statement.\n    X0 = np.array([\n        [1.0, -1.0, -0.2,  0.5],\n        [1.0, -0.5,  0.1, -0.3],\n        [1.0,  0.0, -0.4,  0.2],\n        [1.0,  0.5,  0.2, -0.1],\n        [1.0, -0.3,  0.4, -0.5],\n        [1.0,  0.8, -0.1,  0.4]\n    ])\n    y0 = np.array([1.05, 0.56, 0.06, -0.13, 0.49, -0.37])\n\n    # Define the test cases.\n    test_cases = [\n        # (K, y_dup)\n        (3, 0.56),\n        (3, 0.62),\n        (6, 0.86),\n        (2, 0.56)\n    ]\n\n    # The row to be duplicated is at index d=1 (zero-based).\n    row_to_dup = X0[1:2, :]  # Slicing keeps it as a 2D array for vstack.\n    \n    results = []\n    for K, y_dup in test_cases:\n        # 1. Compute CVS for the original base dataset.\n        cvs_before = calculate_cvs(X0, y0, K)\n\n        # 2. Construct the augmented dataset by appending the duplicate row.\n        X_prime = np.vstack([X0, row_to_dup])\n        y_prime = np.append(y0, y_dup)\n        \n        # 3. Compute CVS for the augmented dataset.\n        cvs_after = calculate_cvs(X_prime, y_prime, K)\n        \n        # 4. Calculate the change in CVS.\n        delta_cvs = cvs_after - cvs_before\n        \n        # 5. Store the triplet of results.\n        results.extend([cvs_before, cvs_after, delta_cvs])\n    \n    # Format the final list of results for printing.\n    # Each value is rounded to 6 decimal places as specified.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n\n    # Print the final output in the required single-line format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3437890"}, {"introduction": "簇展开模型的主要应用之一是预测合金的基态结构，即能量最低的原子构型。一旦模型被成功拟合，它就成为了一个高效的能量代理模型，使我们能够在庞大的构型空间中进行搜索。本练习将向您展示如何将寻找基态这一物理问题转化为一个混合整数线性规划（MILP）问题，这是一种强大的组合优化方法。通过构建并求解这个MILP，您将能够利用之前获得的ECI来预测特定组分下的稳定相，从而完成从模型构建到物理预测的完整工作流程。[@problem_id:3437877]", "problem": "考虑一个二维方形布拉维晶格上的二元合金，该晶格具有周期性边界条件，并通过仅保留对相互作用的最小集团展开 (CE) 进行建模。设方形超胞包含 $L_x \\times L_y$ 个晶格位点，用 $i = 1, \\dots, N$ （其中 $N = L_x L_y$）为位点索引，并用二元变量 $x_i \\in \\{0,1\\}$ 表示位点 $i$ 上 A 物种的占据情况。定义一个伊辛自旋变量 $s_i = 2 x_i - 1 \\in \\{-1, +1\\}$。在无量纲约化单位下，仅包含对相互作用的 CE 能量由下式给出：\n$$\nE = \\sum_{\\langle i,j \\rangle_{1}} J_1 \\, s_i s_j + \\sum_{\\langle i,j \\rangle_{2}} J_2 \\, s_i s_j + h \\sum_{i=1}^{N} s_i,\n$$\n其中 $\\langle i,j \\rangle_{1}$ 和 $\\langle i,j \\rangle_{2}$ 分别表示在周期性边界条件下的最近邻和次近邻（对角线）对，$J_1$ 和 $J_2$ 是对的有效集团相互作用系数，$h$ 是一个偏置占据情况的均匀在位场。物理单位的设置使得能量是无量纲的。最近邻由偏移量 $(\\Delta x, \\Delta y) \\in \\{(1,0), (0,1), (-1,0), (0,-1)\\}$ 定义，次近邻（对角线）由偏移量 $(\\Delta x, \\Delta y) \\in \\{(1,1), (1,-1), (-1,1), (-1,-1)\\}$ 定义，所有位移都对 $(L_x, L_y)$ 取模以强制施加周期性。\n\n从上述定义出发，仅使用关于二元合金的伊辛表示和周期性晶格上仅包含对相互作用的 CE 结构的一般事实，推导出一个混合整数线性规划 (MILP) 公式，该公式能精确表示此 CE 的基态搜索问题。您的公式必须：\n- 使用 $x_i$ 和辅助变量表示能量，且仅使用线性项和线性约束。\n- 强制 $x_i \\in \\{0,1\\}$。\n- 在给定的有限超胞上精确表示周期性的最近邻和次近邻相互作用。\n- 允许施加可选的固定组分约束 $\\sum_{i=1}^{N} x_i = f N$，其中 $f \\in [0,1]$ 为指定分数且 $f N$ 为整数。\n\n实现一个分支定界求解器，该求解器使用线性规划 (LP) 松弛来求解 MILP，以找到给定小超胞的全局最优解。LP 松弛问题必须由标准 LP 求解器求解。分支定界算法必须：\n- 使用 LP 松弛解作为下界。\n- 对分数值的 $x_i$ 变量进行分支，直到达到整数性。\n- 剪除那些 LP 下界超过当前最佳整数能量的节点。\n\n您的程序必须在周期性边界条件下构建晶格邻居对，构造 MILP，并计算以下每个测试用例的基态能量。能量必须以无量纲单位报告，并四舍五入到六位小数。\n\n测试套件：\n- 案例 1 (理想路径)：$L_x = 2$, $L_y = 2$, $J_1 = -1.0$, $J_2 = 0.0$, $h = 0.0$，无组分约束（$f$ 缺省）。\n- 案例 2 (固定组分的反铁磁性)：$L_x = 2$, $L_y = 2$, $J_1 = +1.0$, $J_2 = 0.0$, $h = 0.0$，固定组分 $f = 0.5$。\n- 案例 3 (阻挫边缘案例)：$L_x = 2$, $L_y = 2$, $J_1 = +1.0$, $J_2 = -0.4$, $h = 0.0$，无组分约束。\n- 案例 4 (边界组分)：$L_x = 2$, $L_y = 2$, $J_1 = +1.0$, $J_2 = 0.0$, $h = 0.0$，固定组分 $f = 0.0$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含按上述测试用例顺序排列的四个基态能量，格式为方括号内以逗号分隔的列表，例如 $[e_1,e_2,e_3,e_4]$，其中每个 $e_k$ 是一个浮点数，四舍五入到六位小数，以无量纲单位表示。\n- 不允许有任何其他输出。", "solution": "用户希望使用集团展开 (CE) 模型，找到二维方形晶格上二元合金的基态能量。该能量表达式等效于一个具有最近邻和次近邻相互作用、并受周期性边界条件约束的伊辛哈密顿量。任务是将其构建为一个混合整数线性规划 (MILP) 问题，并使用一个自定义的分支定界 (B) 算法来求解，该算法利用一个标准的线性规划 (LP) 求解器。\n\n### 步骤 1：MILP 公式的推导\n\n系统的能量由伊辛自旋变量 $s_i \\in \\{-1, +1\\}$ 给出：\n$$\nE = \\sum_{\\langle i,j \\rangle_{1}} J_1 \\, s_i s_j + \\sum_{\\langle i,j \\rangle_{2}} J_2 \\, s_i s_j + h \\sum_{i=1}^{N} s_i\n$$\n该问题要求用二元占据变量 $x_i \\in \\{0,1\\}$ 来构建公式，这些变量通过 $s_i = 2x_i - 1$ 与自旋变量相关联。\n\n首先，将 $s_i = 2x_i - 1$ 代入能量方程。在位项变为：\n$$\nh \\sum_{i=1}^{N} s_i = h \\sum_{i=1}^{N} (2x_i - 1) = 2h \\sum_{i=1}^{N} x_i - hN\n$$\n该项关于 $x_i$ 是线性的，并带有一个常数偏移量 $-hN$。\n\n对相互作用项 $s_i s_j$ 是二次的：\n$$\ns_i s_j = (2x_i - 1)(2x_j - 1) = 4x_i x_j - 2x_i - 2x_j + 1\n$$\n这个表达式包含一个二次项 $x_i x_j$，对于 MILP 公式必须将其线性化。我们为每个相互作用对 $\\langle i,j \\rangle$ 引入一个辅助连续变量 $z_{ij}$，并定义它等于乘积 $z_{ij} = x_i x_j$。由于 $x_i$ 和 $x_j$ 是二元变量，它们的乘积 $z_{ij}$ 也是二元的。这个等式可以被一组对于二元变量是精确的线性不等式所替代（称为 McCormick 线性化）：\n1. $z_{ij} \\le x_i$\n2. $z_{ij} \\le x_j$\n3. $z_{ij} \\ge x_i + x_j - 1$\n\n通过这个代换，单个对相互作用的能量贡献变为关于 $x_i, x_j$ 和 $z_{ij}$ 的线性表达式：\n$$\nJ_{\\langle i,j \\rangle} s_i s_j = J_{\\langle i,j \\rangle} (4z_{ij} - 2x_i - 2x_j + 1)\n$$\n对所有对求和并包含在位项，总能量为：\n$$\nE = \\sum_{\\langle i,j \\rangle} J_{\\langle i,j \\rangle} \\left(4z_{ij} - 2x_i - 2x_j + 1\\right) + 2h \\sum_i x_i - hN\n$$\n其中 $J_{\\langle i,j \\rangle}$ 是 $J_1$ 或 $J_2$。为了得到 MILP 的最终线性目标函数，我们按变量重新整理各项：\n$$\nE = \\sum_{\\langle i,j \\rangle} (4 J_{\\langle i,j \\rangle}) z_{ij} + \\sum_i \\left( 2h - 2 \\sum_{j \\in \\text{N}(i)} J_{\\langle i,j \\rangle} \\right) x_i + \\left( \\sum_{\\langle i,j \\rangle} J_{\\langle i,j \\rangle} - hN \\right)\n$$\n这里，$\\text{N}(i)$ 表示位点 $i$ 的所有邻居的集合。最后一项是一个常数偏移量 $E_{\\text{const}}$，可以加到 MILP 求解器找到的目标值上。\n\n完整的 MILP 公式为：\n**最小化：**\n$$\nE_{\\text{MILP}} = \\sum_{\\langle i,j \\rangle} c_{ij} z_{ij} + \\sum_i d_i x_i\n$$\n其中 $c_{ij} = 4 J_{\\langle i,j \\rangle}$ 且 $d_i = 2h - 2 \\sum_{j \\in \\text{N}(i)} J_{\\langle i,j \\rangle}$。基态能量为 $E_{GS} = E_{\\text{MILP}}^* + E_{\\text{const}}$。\n\n**约束条件：**\n- 对于每个相互作用对 $\\langle i,j \\rangle$：\n    - $z_{ij} - x_i \\le 0$\n    - $z_{ij} - x_j \\le 0$\n    - $x_i + x_j - z_{ij} \\le 1$\n- 对于每个位点 $i$：\n    - $x_i \\in \\{0, 1\\}$（由分支定界过程强制执行）\n- 可选的组分约束：\n    - $\\sum_{i=1}^N x_i = fN$（对于给定的分数 $f$）\n\n### 步骤 2：分支定界求解器的算法设计\n\n该 MILP 将使用分支定界 (B) 算法求解。\n1.  **晶格和 MILP 构建**：首先，一个函数为给定的具有周期性边界条件的 $L_x \\times L_y$ 晶格构建最近邻和次近邻对的列表。然后，它组装 MILP 矩阵：目标向量 $c$、不等式约束矩阵 $A_{ub}$ 和向量 $b_{ub}$、等式约束矩阵 $A_{eq}$ 和向量 $b_{eq}$（如果组分是固定的），以及常数能量偏移量 $E_{\\text{const}}$。\n\n2.  **分支定界核心逻辑**：\n    - **节点表示**：B 树中的一个节点代表一个 LP 子问题，它由原始的 MILP 松弛问题加上将某些 $x_i$ 变量固定为 $0$ 或 $1$ 的附加约束定义。这些约束通过调整变量的 `bounds` 来管理。\n    - **初始化**：算法从代表原始问题 LP 松弛（所有 $x_i \\in [0, 1]$）的单个节点（根节点）开始。最小能量的上界初始化为无穷大。使用一个栈来管理待探索的节点（深度优先搜索）。\n    - **迭代**：算法按以下步骤进行：\n        a. 从栈中弹出一个节点（子问题）。\n        b. 使用 `scipy.optimize.linprog` 求解相应的 LP 松弛问题。\n        c. **剪枝**：\n            i. 如果 LP 不可行，则剪掉这个分支。\n            ii. 如果 LP 的目标值（该分支的下界）大于当前最佳全局上界，则剪掉这个分支。\n        d. **解分析**：\n            i. 如果所有 $x_i$ 变量的 LP 解都是整数（在小容差范围内），则找到了一个有效的整数解。计算其总能量，如果更优，则用它来更新全局上界。该分支被剪除，因为它是整数解树的一个叶子节点。\n            ii. 如果至少有一个 $x_k$ 是分数值，则这是一个**分支**点。创建两个新的子节点并推入栈中：一个添加了约束 $x_k=0$，另一个添加了约束 $x_k=1$。\n\n3.  **终止**：当节点栈为空时，算法终止。最终存储的上界即为全局最优的基态能量。\n\n这个过程保证能找到指定 CE 模型的精确基态能量。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    def _build_milp(Lx, Ly, J1, J2, h):\n        \"\"\"\n        Builds the MILP formulation for the given cluster expansion problem.\n        Returns the components needed for the LP solver and B algorithm.\n        \"\"\"\n        N = Lx * Ly\n        \n        # 1. Generate neighbor lists and counts\n        sites_coords = {i: (i % Lx, i // Ly) for i in range(N)}\n        coords_sites = {(c, r): i for i, (c, r) in sites_coords.items()}\n\n        first_neighbor_offsets = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        second_neighbor_offsets = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\n\n        adj = [set() for _ in range(N)]\n        adj_type = {} # To store pair type (1 or 2)\n\n        for i in range(N):\n            c, r = sites_coords[i]\n            # First neighbors\n            for dc, dr in first_neighbor_offsets:\n                nc, nr = (c + dc) % Lx, (r + dr) % Ly\n                j = coords_sites[(nc, nr)]\n                if i != j:\n                    adj[i].add(j)\n                    pair = tuple(sorted((i, j)))\n                    if pair not in adj_type:\n                        adj_type[pair] = 1\n            # Second neighbors\n            for dc, dr in second_neighbor_offsets:\n                nc, nr = (c + dc) % Lx, (r + dr) % Ly\n                j = coords_sites[(nc, nr)]\n                if i != j:\n                    adj[i].add(j)\n                    pair = tuple(sorted((i, j)))\n                    # J1 dominates if a pair is both 1st and 2nd nbr\n                    if pair not in adj_type:\n                        adj_type[pair] = 2\n\n        all_pairs = sorted(list(adj_type.keys()))\n        pairs1 = [p for p in all_pairs if adj_type[p] == 1]\n        pairs2 = [p for p in all_pairs if adj_type[p] == 2]\n        \n        # 2. Construct MILP matrices\n        num_x_vars = N\n        num_z_vars = len(all_pairs)\n        num_total_vars = num_x_vars + num_z_vars\n        \n        pair_to_z_idx = {pair: i + num_x_vars for i, pair in enumerate(all_pairs)}\n\n        # Objective function vector `c`\n        c = np.zeros(num_total_vars)\n        for i in range(N):\n            c_i = 2 * h\n            for j in adj[i]:\n                pair = tuple(sorted((i, j)))\n                pair_type = adj_type[pair]\n                J = J1 if pair_type == 1 else J2\n                c_i -= 2 * J\n            c[i] = c_i\n        \n        for pair in all_pairs:\n            z_idx = pair_to_z_idx[pair]\n            pair_type = adj_type[pair]\n            J = J1 if pair_type == 1 else J2\n            c[z_idx] = 4 * J\n            \n        # Constant energy term\n        E_const = len(pairs1) * J1 + len(pairs2) * J2 - h * N\n        \n        # Inequality constraints A_ub * x = b_ub\n        num_ineq_constraints = 3 * num_z_vars\n        A_ub = np.zeros((num_ineq_constraints, num_total_vars))\n        b_ub = np.zeros(num_ineq_constraints)\n\n        row_idx = 0\n        for i, j in all_pairs:\n            z_idx = pair_to_z_idx[(i, j)]\n            # z_ij - x_i = 0\n            A_ub[row_idx, z_idx] = 1\n            A_ub[row_idx, i] = -1\n            row_idx += 1\n            # z_ij - x_j = 0\n            A_ub[row_idx, z_idx] = 1\n            A_ub[row_idx, j] = -1\n            row_idx += 1\n            # x_i + x_j - z_ij = 1\n            A_ub[row_idx, i] = 1\n            A_ub[row_idx, j] = 1\n            A_ub[row_idx, z_idx] = -1\n            b_ub[row_idx] = 1\n            row_idx += 1\n            \n        return c, A_ub, b_ub, E_const, N, num_total_vars\n\n    def _solve_milp_with_bb(c, A_ub, b_ub, A_eq, b_eq, E_const, N, num_total_vars):\n        \"\"\"\n        Solves the MILP using a branch-and-bound algorithm.\n        \"\"\"\n        initial_bounds = [(0, 1)] * num_total_vars\n        stack = [initial_bounds]\n        \n        upper_bound = float('inf')\n\n        while stack:\n            current_bounds = stack.pop()\n            \n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=current_bounds, method='highs-ds')\n            \n            if not res.success:\n                continue\n                \n            lp_min_val = res.fun\n            \n            if lp_min_val + E_const >= upper_bound:\n                continue\n                \n            x_vars = res.x[:N]\n            \n            # Find a fractional variable to branch on\n            frac_idx = -1\n            for i in range(N):\n                if not np.isclose(x_vars[i], round(x_vars[i]), atol=1e-8):\n                    frac_idx = i\n                    break\n                    \n            if frac_idx == -1: # All integer solution\n                current_energy = lp_min_val + E_const\n                if current_energy < upper_bound:\n                    upper_bound = current_energy\n            else: # Branch\n                # Create two new subproblems by copying bounds and adding constraints\n                bounds_0 = list(current_bounds)\n                bounds_0[frac_idx] = (0, 0)\n                stack.append(bounds_0)\n\n                bounds_1 = list(current_bounds)\n                bounds_1[frac_idx] = (1, 1)\n                stack.append(bounds_1)\n\n        return upper_bound\n\n    def run_case(Lx, Ly, J1, J2, h, f=None):\n        \"\"\"\n        Sets up and solves one test case configuration.\n        \"\"\"\n        c, A_ub, b_ub, E_const, N, num_total_vars = _build_milp(Lx, Ly, J1, J2, h)\n        \n        A_eq = None\n        b_eq = None\n        \n        if f is not None:\n            target_sum = f * N\n            A_eq = np.zeros((1, num_total_vars))\n            A_eq[0, :N] = 1\n            b_eq = np.array([target_sum])\n\n        min_energy = _solve_milp_with_bb(c, A_ub, b_ub, A_eq, b_eq, E_const, N, num_total_vars)\n        \n        if min_energy == float('inf'):\n            return np.nan # Should not happen for these test cases\n            \n        return min_energy\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'Lx': 2, 'Ly': 2, 'J1': -1.0, 'J2': 0.0, 'h': 0.0, 'f': None},\n        {'Lx': 2, 'Ly': 2, 'J1': +1.0, 'J2': 0.0, 'h': 0.0, 'f': 0.5},\n        {'Lx': 2, 'Ly': 2, 'J1': +1.0, 'J2': -0.4, 'h': 0.0, 'f': None},\n        {'Lx': 2, 'Ly': 2, 'J1': +1.0, 'J2': 0.0, 'h': 0.0, 'f': 0.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        energy = run_case(**case)\n        results.append(f\"{energy:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3437877"}]}