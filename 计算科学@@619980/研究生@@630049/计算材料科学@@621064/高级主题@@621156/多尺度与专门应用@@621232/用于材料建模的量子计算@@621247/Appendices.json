{"hands_on_practices": [{"introduction": "在着手进行任何量子模拟之前，首要步骤是评估问题的规模。本练习引导我们从第一性原理出发，估算在量子计算机上表示一个晶体材料所需的资源，包括量子比特数和哈密顿量项的数量。通过这个实践[@problem_id:3481650]，你将亲身体会到电子结构问题的复杂性如何随系统尺寸的增大而急剧增长，从而理解开发高效算法和问题映射方法的必要性。", "problem": "考虑为一个晶体固体的相互作用电子模型设置一个变分量子本征求解器（VQE, Variational Quantum Eigensolver）计算，该模型在一个适合二次量子化的局域轨道基中表示。该晶体有 $N$ 个相同的晶胞，每个晶胞有 $M$ 个局域空间轨道。假设存在自旋简并且没有自旋极化，因此每个空间轨道允许两种自旋态。您使用标准的二次量子化电子哈密顿量对电子进行建模，该哈密顿量包括了所有自旋轨道上的所有单电子项和双电子项。假设长程库仑相互作用是未屏蔽的，因此没有双电子积分因距离截断而消失，并且不利用任何点群或平移对称性来消除项。您打算使用一种费米子到量子比特的映射，其中每个自旋轨道映射到一个量子比特。\n\n在这些假设下，从第一性原理出发进行以下操作：\n- 确定作为 $N$ 和 $M$ 函数的自旋轨道总数。\n- 将哈密顿量的“大小”定义为在任何映射之前，出现在二次量子化哈密顿量中的不同算符单项式的总数（即，单体和双体求和中指标组合的总数）。通过只保留 $N$ 和 $M$ 的最高次多项式项，计算此数量对 $N$ 和 $M$ 的领头阶依赖关系。\n\n将您的最终结果表示为一个包含两个条目的行矩阵 $\\big[$自旋轨道总数, 哈密顿量项数关于 $N$ 和 $M$ 的领头阶$\\big]$。不需要单位。提供精确表达式；无需四舍五入。", "solution": "问题陈述已经过评估并被确定为有效。它具有科学依据、良定、客观且自洽。为了进行理论标度分析，明确陈述了诸如忽略对称性和考虑所有潜在相互作用项等假设。因此，我们可以继续进行推导。\n\n问题要求从晶体固体的相互作用电子模型的二次量子化描述中推导出两个量：自旋轨道的总数和电子哈密顿量中项数的领头阶标度。\n\n**1. 自旋轨道总数**\n\n该系统是一个由 $N$ 个相同晶胞组成的晶体固体。每个晶胞包含 $M$ 个局域空间轨道。\n晶体中空间轨道的总数是晶胞数量与每个晶胞中空间轨道数量的乘积。\n设 $N_{orb}$ 为空间轨道的总数。\n$$N_{orb} = N \\times M$$\n问题陈述假设存在自旋简并，意味着每个空间轨道可以被一个自旋向上（$\\sigma = +\\frac{1}{2}$，记为 $\\alpha$）或自旋向下（$\\sigma = -\\frac{1}{2}$，记为 $\\beta$）的电子占据。因此，每个空间轨道产生两个不同的自旋轨道。\n设 $N_{so}$ 为自旋轨道的总数。这是单粒子福克空间的基组大小。\n$$N_{so} = N_{orb} \\times 2 = 2NM$$\n这是第一个所求的量。\n\n**2. 哈密顿量项数的领头阶**\n\n相互作用电子系统的一般二次量子化电子哈密顿量由一个单体项和一个双体项之和给出：\n$$H = H_1 + H_2 = \\sum_{p,q=1}^{N_{so}} h_{pq} a_p^\\dagger a_q + \\frac{1}{2} \\sum_{p,q,r,s=1}^{N_{so}} v_{pqrs} a_p^\\dagger a_q^\\dagger a_r a_s$$\n其中，指标 $p, q, r, s$ 遍历所有 $N_{so}$ 个自旋轨道。项 $a_p^\\dagger$ 是在自旋轨道 $p$ 中产生一个电子的产生算符，而 $a_q$ 是在自旋轨道 $q$ 中湮灭一个电子的湮灭算符。系数 $h_{pq}$ 是单电子积分，$v_{pqrs}$ 是双电子积分。\n\n问题将“哈密顿量大小”明确定义为“在任何映射之前，出现在二次量子化哈密顿量中的不同算符单项式的总数（即，单体和双体求和中指标组合的总数）”。我们必须严格遵守这个定义。问题还指示不要利用任何对称性来消除项。这意味着我们应该按照求和的书写方式计算项的数量，而不考虑通常用于减少唯一项数量的系数之间（例如，$h_{pq} = h_{qp}^*$）或算符串之间（例如，$a_p^\\dagger a_q^\\dagger = -a_q^\\dagger a_p^\\dagger$）的关系。\n\n**单体项计数：**\n哈密顿量的单体部分是 $H_1 = \\sum_{p,q=1}^{N_{so}} h_{pq} a_p^\\dagger a_q$。\n根据问题的定义，我们必须计算对 $(p, q)$ 的指数组合数。由于指标 $p$ 和 $q$ 都独立地从 $1$ 到 $N_{so}$ 取值，组合的总数是：\n$$ \\text{Count}_1 = N_{so} \\times N_{so} = N_{so}^2 $$\n\n**双体项计数：**\n哈密顿量的双体部分是 $H_2 = \\frac{1}{2} \\sum_{p,q,r,s=1}^{N_{so}} v_{pqrs} a_p^\\dagger a_q^\\dagger a_r a_s$。\n我们计算四元组 $(p, q, r, s)$ 的指数组合数。四个指标中的每一个都独立地从 $1$ 到 $N_{so}$ 取值。组合的总数是：\n$$ \\text{Count}_2 = N_{so} \\times N_{so} \\times N_{so} \\times N_{so} = N_{so}^4 $$\n哈密顿量表达式中的前置因子 $\\frac{1}{2}$ 是一个惯例，不影响执行求和的指数组合的计数。\n\n**总计数和领头阶依赖关系：**\n根据定义，哈密顿量项的总数是单体项和双体项计数之和：\n$$ \\text{Total Count} = \\text{Count}_1 + \\text{Count}_2 = N_{so}^2 + N_{so}^4 $$\n问题要求此计数对 $N$ 和 $M$ 的领头阶依赖关系。这对应于 $N$ 和 $M$ 的总幂次最高的项。我们代入 $N_{so} = 2NM$：\n$$ \\text{Total Count} = (2NM)^2 + (2NM)^4 = 4N^2M^2 + 16N^4M^4 $$\n项 $4N^2M^2$ 的总次数为 $2+2=4$。项 $16N^4M^4$ 的总次数为 $4+4=8$。因此，领头阶项是次数最高的项，即 $16N^4M^4$。\n\n因此，哈密顿量项数对 $N$ 和 $M$ 的领头阶依赖关系是 $16N^4M^4$。\n\n**最终结果表达式：**\n问题要求将最终结果表示为一个包含两个条目的行矩阵：[自旋轨道总数，哈密顿量项数关于 $N$ 和 $M$ 的领头阶]。\n这两个条目是 $2NM$ 和 $16N^4M^4$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 2NM  & 16N^{4}M^{4} \\end{pmatrix}}\n$$", "id": "3481650"}, {"introduction": "建立哈密顿量之后，变分量子本征求解器（VQE）的核心任务是优化试探波函数的参数，这需要计算能量梯度。本练习[@problem_id:3481700]在一个最小模型上深入探讨了两种计算梯度的基本方法——对易子方法和参数偏移规则。通过对它们的分析，你将揭示在算法设计中，不同梯度计算策略在电路深度和测量代价之间的权衡。", "problem": "考虑一个与计算材料科学相关的双电子激发的最小活性空间模型。经过 Jordan–Wigner 映射和适当的对称性锥化后，单激发子空间可以用两个量子比特表示，其计算基态 $\\{|10\\rangle, |01\\rangle\\}$ 对应于一个电子定域在两个自旋轨道中的一个。设此子空间中的有效电子哈密顿量为 $H = \\frac{\\Delta}{2}\\,(Z_{0} - Z_{1})$，其中 $\\Delta > 0$ 是一个轨道能量分裂，$Z_{k}$ 是作用在量子比特 $k$ 上的泡利 $Z$ 算符。设参考态为 $|\\psi_{0}\\rangle = |10\\rangle$。考虑一个酉耦合簇单双激发 (UCCSD) 的单激发生成元，其映射到量子比特算符为\n$$\nP \\;=\\; \\frac{1}{2}\\bigl(X_{0} Y_{1} - Y_{0} X_{1}\\bigr),\n$$\n该算符是厄米的。定义单参数拟设 $U(\\theta) = \\exp\\!\\bigl(- i\\,\\theta\\,P\\bigr)$。沿着此拟设的变分能量为 $E(\\theta) = \\langle \\psi_{0} | U(\\theta)^{\\dagger} H\\, U(\\theta) | \\psi_{0} \\rangle$。\n\n您的任务是：\n\n1. 从变分能量的定义和期望值微分的乘积法则出发，使用对易子展开从第一性原理推导能量梯度 $\\frac{dE}{d\\theta}$ 的解析表达式。将您的最终梯度以 $\\theta$ 和 $\\Delta$ 的函数闭合形式表示。\n\n2. 利用厄米生成元 $P$ 的谱性质和标准门微分的第一性原理，确定一个有效的参数平移值 $s$，使得 $\\frac{dE}{d\\theta}$ 可以精确地写成能量 $E(\\theta \\pm s)$ 的线性组合，并给出该表达式。然后，比较以下两种方法每次梯度评估所需的线路深度：\n   - 基于对易子的梯度测量（通过在态 $U(\\theta)|\\psi_{0}\\rangle$ 上测量所需的泡利串可观测量），\n   - 与参数平移法（通过在平移后的参数处评估能量）进行比较。\n   对于基于对易子的方法，只计算在计算 $Z$ 基中测量所需的泡利串 $X_{0}X_{1}$ 和 $Y_{0}Y_{1}$ 所需的额外单量子比特基变换旋转；对于参数平移法，假设 $H$ 直接在计算基中测量，无需基变换。报告在这种双量子比特情况下，基于对易子的评估相对于参数平移评估所需的额外单量子比特旋转的整数数量。\n\n3. 在独立次采样和假设投影测量的情况下，通过无偏估计量的方差来建模测量次数复杂度。利用以下事实：对于任何本征值为 $\\pm 1$ 的泡利串 $O$，在纯态上 $\\mathrm{Var}(O) = 1 - \\langle O \\rangle^{2}$；对于此子空间中的哈密顿量 $H$，$H^{2} = \\Delta^{2}\\,I$，因此 $\\mathrm{Var}(H) = \\Delta^{2} - \\langle H \\rangle^{2}$。假设在每种方法的两次所需测量中进行最优均等分配，计算每种方法为达到梯度估计量方差 $\\sigma_{g}^{2}$ 所需的总测量次数。然后，给出参数平移法与基于对易子的方法所需的总测量次数之比 $R_{\\mathrm{shots}}(\\theta)$ 的闭合形式表达式，并将其简化为 $\\theta$ 和 $\\Delta$ 的函数。\n\n答案格式：使用 LaTeX 的 $\\mathrm{pmatrix}$ 环境返回一个包含三个条目的单行矩阵，按顺序为：(i) 解析梯度 $\\frac{dE}{d\\theta}$，(ii) 测量次数复杂度比率 $R_{\\mathrm{shots}}(\\theta)$，以及 (iii) 在此设置下，基于对易子的方法相对于参数平移法所需的额外单量子比特旋转的整数数量。无需四舍五入，最终方框内不应报告单位。", "solution": "该问题经核实具有科学依据、问题明确、客观且自成体系。它是变分量子算法研究中的一个标准练习。我现在将给出完整解答。\n\n该问题要求求解与一个双量子比特系统变分能量梯度相关的三个量。让我们系统地解决每个部分。\n\n系统定义如下：\n- 哈密顿量：$H = \\frac{\\Delta}{2}\\,(Z_{0} - Z_{1})$\n- 参考态：$|\\psi_{0}\\rangle = |10\\rangle$\n- 拟设生成元：$P = \\frac{1}{2}\\bigl(X_{0} Y_{1} - Y_{0} X_{1}\\bigr)$\n- 变分态：$|\\psi(\\theta)\\rangle = U(\\theta)|\\psi_0\\rangle = \\exp(-i\\theta P)|\\psi_0\\rangle$\n- 变分能量：$E(\\theta) = \\langle \\psi(\\theta) | H | \\psi(\\theta) \\rangle$\n\n首先，我们分析生成元 $P$ 在相关计算基态 $|10\\rangle$ 和 $|01\\rangle$ 上的作用：\n$P|10\\rangle = \\frac{1}{2}\\bigl(X_{0} Y_{1} - Y_{0} X_{1}\\bigr)|10\\rangle = \\frac{1}{2}\\bigl(X_{0}(i|11\\rangle) - Y_{0}(|11\\rangle)\\bigr) = \\frac{1}{2}\\bigl(i|01\\rangle - (-i|01\\rangle)\\bigr) = i|01\\rangle$。\n$P|01\\rangle = \\frac{1}{2}\\bigl(X_{0} Y_{1} - Y_{0} X_{1}\\bigr)|01\\rangle = \\frac{1}{2}\\bigl(X_{0}(-i|00\\rangle) - Y_{0}(|00\\rangle)\\bigr) = \\frac{1}{2}\\bigl(-i|10\\rangle - (i|10\\rangle)\\bigr) = -i|10\\rangle$。\n由 $\\{|10\\rangle, |01\\rangle\\}$ 张成的子空间在 $P$ 的作用下是不变的。在这个子空间中，若基向量排序为 $(|10\\rangle, |01\\rangle)$，$P$ 的矩阵表示为 $\\begin{pmatrix} 0  -i \\\\ i  0 \\end{pmatrix}$，即泡利矩阵 $\\sigma_y$。\n由于 $P^2$ 在此子空间中作用如单位算符，我们可以使用恒等式 $U(\\theta) = \\exp(-i\\theta P) = \\cos(\\theta)I - i\\sin(\\theta)P$。\n演化后的态是 $|\\psi(\\theta)\\rangle = (\\cos(\\theta)I - i\\sin(\\theta)P)|10\\rangle = \\cos(\\theta)|10\\rangle - i\\sin(\\theta)(i|01\\rangle) = \\cos(\\theta)|10\\rangle + \\sin(\\theta)|01\\rangle$。\n\n### 第 1 部分：基于对易子的解析梯度\n\n变分能量为 $E(\\theta) = \\langle \\psi_{0} | U(\\theta)^{\\dagger} H U(\\theta) | \\psi_{0} \\rangle$。其关于 $\\theta$ 的导数是：\n$$\n\\frac{dE}{d\\theta} = \\langle \\psi_{0} | \\left(\\frac{dU^{\\dagger}}{d\\theta}\\right) H U(\\theta) + U(\\theta)^{\\dagger} H \\left(\\frac{dU}{d\\theta}\\right) | \\psi_{0} \\rangle\n$$\n由于 $U(\\theta) = \\exp(-i\\theta P)$，我们有 $\\frac{dU}{d\\theta} = -iP U(\\theta)$ 和 $\\frac{dU^{\\dagger}}{d\\theta} = iU(\\theta)^{\\dagger}P$。代入可得：\n$$\n\\frac{dE}{d\\theta} = \\langle \\psi_{0} | iU(\\theta)^{\\dagger}P H U(\\theta) - iU(\\theta)^{\\dagger} H P U(\\theta) | \\psi_{0} \\rangle = i \\langle \\psi_{0} | U(\\theta)^{\\dagger} [P, H] U(\\theta) | \\psi_{0} \\rangle = i \\langle \\psi(\\theta) | [P, H] | \\psi(\\theta) \\rangle\n$$\n接下来，我们必须计算对易子 $[P, H]$：\n$$\n[P, H] = \\left[ \\frac{1}{2}(X_0 Y_1 - Y_0 X_1), \\frac{\\Delta}{2}(Z_0 - Z_1) \\right] = \\frac{\\Delta}{4} \\left( [X_0 Y_1, Z_0 - Z_1] - [Y_0 X_1, Z_0 - Z_1] \\right)\n$$\n使用恒等式 $[AB, C] = A[B,C] + [A,C]B$ 和泡利代数关系 $[X,Z]=-2iY$ 及 $[Y,Z]=2iX$：\n$$\n[X_0 Y_1, Z_0 - Z_1] = [X_0, Z_0]Y_1 + X_0[Y_1, -Z_1] = (-2iY_0)Y_1 + X_0(-2iX_1) = -2i(Y_0 Y_1 + X_0 X_1)\n$$\n$$\n[Y_0 X_1, Z_0 - Z_1] = [Y_0, Z_0]X_1 + Y_0[X_1, -Z_1] = (2iX_0)X_1 + Y_0(2iY_1) = 2i(X_0 X_1 + Y_0 Y_1)\n$$\n将这些代入 $[P,H]$ 的表达式中：\n$$\n[P, H] = \\frac{\\Delta}{4} \\left( -2i(Y_0 Y_1 + X_0 X_1) - 2i(X_0 X_1 + Y_0 Y_1) \\right) = \\frac{\\Delta}{4} \\left( -4i(X_0 X_1 + Y_0 Y_1) \\right) = -i\\Delta(X_0 X_1 + Y_0 Y_1)\n$$\n现在，将此结果代回梯度的表达式中：\n$$\n\\frac{dE}{d\\theta} = i \\langle \\psi(\\theta) | (-i\\Delta(X_0 X_1 + Y_0 Y_1)) | \\psi(\\theta) \\rangle = \\Delta \\langle \\psi(\\theta) | (X_0 X_1 + Y_0 Y_1) | \\psi(\\theta) \\rangle\n$$\n为了计算期望值，我们计算算符 $(X_0 X_1 + Y_0 Y_1)$ 在我们的态 $|\\psi(\\theta)\\rangle$ 上的作用：\n$X_0 X_1 (\\cos\\theta|10\\rangle + \\sin\\theta|01\\rangle) = \\cos\\theta|01\\rangle + \\sin\\theta|10\\rangle$。\n$Y_0 Y_1 (\\cos\\theta|10\\rangle + \\sin\\theta|01\\rangle) = Y_0(i\\cos\\theta|11\\rangle -i\\sin\\theta|00\\rangle) = i(-i\\cos\\theta|01\\rangle) -i(i\\sin\\theta|10\\rangle) = \\cos\\theta|01\\rangle + \\sin\\theta|10\\rangle$。\n所以，$(X_0 X_1 + Y_0 Y_1)|\\psi(\\theta)\\rangle = 2(\\cos\\theta|01\\rangle + \\sin\\theta|10\\rangle)$。\n期望值为：\n$$\n\\langle \\psi(\\theta) | (X_0 X_1 + Y_0 Y_1) | \\psi(\\theta) \\rangle = (\\cos\\theta\\langle 10| + \\sin\\theta\\langle 01|) \\cdot 2(\\cos\\theta|01\\rangle + \\sin\\theta|10\\rangle) = 2(\\cos\\theta\\sin\\theta + \\sin\\theta\\cos\\theta) = 4\\sin\\theta\\cos\\theta = 2\\sin(2\\theta)\n$$\n因此，解析梯度为：\n$$\n\\frac{dE}{d\\theta} = \\Delta (2\\sin(2\\theta)) = 2\\Delta\\sin(2\\theta)\n$$\n\n### 第 2 部分：参数平移法则和线路深度\n\n生成元 $P$ 在活性子空间中作用如 $\\sigma_y$，因此其本征值为 $\\pm 1$。具有两个唯一本征值 $\\pm \\lambda$ 的生成元会产生一个参数平移法则。对于 $U(\\theta)=\\exp(-i\\theta P)$，梯度为 $\\frac{dE}{d\\theta} = i\\langle [P,H] \\rangle_\\theta$。能量差为 $E(\\theta+s) - E(\\theta-s) = -i\\sin(2s\\lambda)\\langle [P,H]\\rangle_\\theta/\\lambda$。这里 $\\lambda=1$。所以 $E(\\theta+s) - E(\\theta-s) = -i\\sin(2s)\\langle [P,H]\\rangle_\\theta$。选择平移量 $s=\\pi/4$ 可得 $\\sin(2s)=1$，从而得到 $E(\\theta+\\pi/4) - E(\\theta-\\pi/4) = -i\\langle [P,H]\\rangle_\\theta$。\n与梯度 $\\frac{dE}{d\\theta} = i \\langle [P, H] \\rangle_\\theta$ 比较，我们发现：\n$$\n\\frac{dE}{d\\theta} = E(\\theta+\\pi/4) - E(\\theta-\\pi/4)\n$$\n因此，一个有效的参数平移值为 $s = \\pi/4$。\n\n现在，我们比较由额外单量子比特旋转测量的线路深度。\n- **对易子方法**：梯度为 $\\Delta(\\langle X_0X_1 \\rangle_\\theta + \\langle Y_0Y_1 \\rangle_\\theta)$。为了测量 $\\langle X_0X_1 \\rangle$，必须对两个量子比特应用基变换旋转，将 $X$ 基映射到 $Z$ 基（例如，在每个量子比特上应用 $R_y(-\\pi/2)$），这需要 $2$ 个单量子比特旋转。为了测量 $\\langle Y_0Y_1 \\rangle$，必须将 $Y$ 基映射到 $Z$ 基（例如，在每个量子比特上应用 $R_x(\\pi/2)$），这需要另外 $2$ 个旋转。总共是 $2+2=4$ 个旋转。\n- **参数平移方法**：梯度需要测量 $E(\\theta \\pm s)$。这涉及到测量哈密顿量 $H=\\frac{\\Delta}{2}(Z_0-Z_1)$，它仅由泡利 $Z$ 算符组成。测量可以直接在计算基中进行，无需任何基变换旋转。总共是 $0$ 个旋转。\n\n基于对易子的方法相对于参数平移方法所需的额外单量子比特旋转的整数数量是 $4 - 0 = 4$。\n\n### 第 3 部分：测量次数复杂度比率\n\n梯度估计量的方差决定了达到目标精度 $\\sigma_g^2$ 所需的测量次数。我们假设在每种方法中，两次测量之间的测量次数都是最优均等分配的。\n\n- **对易子方法**：$\\hat{g}_C = \\Delta(\\widehat{\\langle X_0X_1 \\rangle} + \\widehat{\\langle Y_0Y_1 \\rangle})$。设 $N_C$ 为总测量次数，每个期望值分配 $N_C/2$ 次。\n$$\n\\mathrm{Var}(\\hat{g}_C) = \\Delta^2 \\mathrm{Var}(\\widehat{\\langle X_0X_1 \\rangle}) + \\Delta^2 \\mathrm{Var}(\\widehat{\\langle Y_0Y_1 \\rangle}) = \\Delta^2 \\frac{1-\\langle X_0X_1 \\rangle_\\theta^2}{N_C/2} + \\Delta^2 \\frac{1-\\langle Y_0Y_1 \\rangle_\\theta^2}{N_C/2}\n$$\n我们已经发现 $\\langle X_0X_1 \\rangle_\\theta = \\langle Y_0Y_1 \\rangle_\\theta = \\sin(2\\theta)$。\n$$\n\\mathrm{Var}(\\hat{g}_C) = \\frac{2\\Delta^2}{N_C}(1-\\sin^2(2\\theta)) + \\frac{2\\Delta^2}{N_C}(1-\\sin^2(2\\theta)) = \\frac{4\\Delta^2}{N_C}\\cos^2(2\\theta)\n$$\n设 $\\mathrm{Var}(\\hat{g}_C) = \\sigma_g^2$，所需的测量次数为 $N_C = \\frac{4\\Delta^2\\cos^2(2\\theta)}{\\sigma_g^2}$。\n\n- **参数平移方法**：$\\hat{g}_{PS} = \\widehat{E(\\theta+s)} - \\widehat{E(\\theta-s)}$，其中 $s=\\pi/4$。设 $N_{PS}$ 为总测量次数。\n$$\n\\mathrm{Var}(\\hat{g}_{PS}) = \\mathrm{Var}(\\widehat{E(\\theta+s)}) + \\mathrm{Var}(\\widehat{E(\\theta-s)}) = \\frac{\\mathrm{Var}(H)_{\\theta+s}}{N_{PS}/2} + \\frac{\\mathrm{Var}(H)_{\\theta-s}}{N_{PS}/2}\n$$\n使用 $\\mathrm{Var}(H)_\\phi = \\Delta^2 - E(\\phi)^2$：\n$E(\\theta) = -\\Delta\\cos(2\\theta)$。\n$E(\\theta+s) = -\\Delta\\cos(2(\\theta+s)) = -\\Delta\\cos(2\\theta+\\pi/2) = \\Delta\\sin(2\\theta)$。\n$E(\\theta-s) = -\\Delta\\cos(2(\\theta-s)) = -\\Delta\\cos(2\\theta-\\pi/2) = -\\Delta\\sin(2\\theta)$。\n哈密顿量测量的方差为：\n$\\mathrm{Var}(H)_{\\theta+s} = \\Delta^2 - (\\Delta\\sin(2\\theta))^2 = \\Delta^2\\cos^2(2\\theta)$。\n$\\mathrm{Var}(H)_{\\theta-s} = \\Delta^2 - (-\\Delta\\sin(2\\theta))^2 = \\Delta^2\\cos^2(2\\theta)$。\n$$\n\\mathrm{Var}(\\hat{g}_{PS}) = \\frac{\\Delta^2\\cos^2(2\\theta)}{N_{PS}/2} + \\frac{\\Delta^2\\cos^2(2\\theta)}{N_{PS}/2} = \\frac{4\\Delta^2\\cos^2(2\\theta)}{N_{PS}}\n$$\n设 $\\mathrm{Var}(\\hat{g}_{PS}) = \\sigma_g^2$，所需的测量次数为 $N_{PS} = \\frac{4\\Delta^2\\cos^2(2\\theta)}{\\sigma_g^2}$。\n\n总测量次数的比率 $R_{\\mathrm{shots}}(\\theta)$ 为：\n$$\nR_{\\mathrm{shots}}(\\theta) = \\frac{N_{PS}}{N_C} = \\frac{4\\Delta^2\\cos^2(2\\theta)/\\sigma_g^2}{4\\Delta^2\\cos^2(2\\theta)/\\sigma_g^2} = 1\n$$\n该比率在 $\\cos(2\\theta) \\ne 0$ 时有效。当 $\\cos(2\\theta)=0$ 时，梯度达到最大值，但两个估计量的方差均为零，这意味着需要零次测量，这是纯态、无噪声分析的人为结果。\n\n### 结果总结\n1.  解析梯度 $\\frac{dE}{d\\theta} = 2\\Delta\\sin(2\\theta)$。\n2.  测量次数复杂度比率 $R_{\\mathrm{shots}}(\\theta) = 1$。\n3.  对易子方法的额外旋转次数：$4$。\n\n将这些结果组合成最终的答案矩阵。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2\\Delta\\sin(2\\theta)  & 1 & 4\n\\end{pmatrix}\n}\n$$", "id": "3481700"}, {"introduction": "对于一个现实材料模型的复杂哈密顿量，能量的测量会成为一个主要的性能瓶颈。这个最后的实践将让你直面这一挑战，实现一个完整的测量优化流程[@problem_id:3481711]。你将把一个扩展哈伯德模型的哈密顿量转换为泡利算符串，并利用图论对可交换的项进行分组，这是使 VQE 实验在近期量子硬件上变得可行的关键技术。", "problem": "您的任务是设计并分析一种测量策略，用于在变分量子本征求解器 (VQE) 的框架内，通过使用基于图着色的逐量子比特对易测量分组方法，估算扩展哈伯德哈密顿量的基态能量期望值。您必须实现一种算法方法，该方法从标准的二次量子化费米子定义和 Jordan-Wigner 变换开始，根据逐量子比特对易准则构建泡利串的冲突图，对着色该图以形成测量分组，然后推导出这些分组间的最佳测量分配，以达到指定的能量精度目标。您的最终程序必须计算并输出多个测试用例的总测量代价。\n\n基本原理：\n考虑一个长度为 $L$ 且包含自旋电子的一维链。设 $t$ 表示跃迁振幅，$U$ 表示在位相互作用强度，$V$ 表示最近邻密度-密度相互作用强度。二次量子化形式的扩展哈伯德哈密顿量为\n$$\nH = -t \\sum_{i=0}^{L-2} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\left( a_{i,\\sigma}^{\\dagger} a_{i+1,\\sigma} + a_{i+1,\\sigma}^{\\dagger} a_{i,\\sigma} \\right)\n+ U \\sum_{i=0}^{L-1} n_{i,\\uparrow} n_{i,\\downarrow}\n+ V \\sum_{i=0}^{L-2} \\sum_{\\sigma,\\sigma' \\in \\{\\uparrow,\\downarrow\\}} n_{i,\\sigma} n_{i+1,\\sigma'} ,\n$$\n其中 $a_{i,\\sigma}^{\\dagger}$ 和 $a_{i,\\sigma}$ 是费米子产生和湮灭算符，$n_{i,\\sigma} = a_{i,\\sigma}^{\\dagger} a_{i,\\sigma}$ 是粒子数算符。\n\n到量子比特的映射：\n采用 Jordan-Wigner 变换，并按照位置和自旋固定轨道排序，其中每个位置 $i \\in \\{0,\\dots,L-1\\}$ 有两个轨道：自旋向上和自旋向下。量子比特总数为 $N_q = 2L$，轨道到量子比特的索引映射为\n$$\np(i,\\sigma) = \\begin{cases}\n2i  \\text{当 } \\sigma = \\uparrow,\\\\\n2i+1  \\text{当 } \\sigma = \\downarrow.\n\\end{cases}\n$$\nJordan-Wigner 变换使用以下经过充分检验的恒等式：\n$$\na_p = \\left( \\prod_{q=0}^{p-1} Z_q \\right) \\frac{X_p + i Y_p}{2}, \\quad\na_p^{\\dagger} = \\left( \\prod_{q=0}^{p-1} Z_q \\right) \\frac{X_p - i Y_p}{2}, \\quad\nn_p = a_p^{\\dagger} a_p = \\frac{1 - Z_p}{2}.\n$$\n您需要将这些恒等式应用于哈密顿量中的每一项，以将其转换为泡利算符之和。\n\n测量分组和代价计算：\n您将实现一个基于图着色的分组算法，用于对哈密顿量中的泡利串进行分组。如果两个泡利串不是“逐量子比特对易”(QWC) 的，则它们是冲突的。使用贪心着色算法（按度数降序排列顶点）对冲突图进行着色，以创建测量组。对于每个组 $G_k$，使用保守的方差上界 $V_k = \\sum_{j \\in G_k} c_j^2$，其中 $c_j$ 是泡利串的系数。为了在总方差 $\\epsilon^2$ 的约束下最小化总测量次数（shots），最优测量次数分配为 $N_k \\propto \\sqrt{V_k}$。这导致总测量代价为\n$$\nS_{\\min} = \\left\\lceil \\frac{1}{\\epsilon^2} \\left( \\sum_k \\sqrt{V_k} \\right)^2 \\right\\rceil.\n$$\n\n您必须为以下五个测试用例计算 $S_{\\min}$：\n1. $L=2, t=1.0, U=4.0, V=1.0, \\epsilon=0.01$\n2. $L=3, t=1.0, U=0.0, V=0.0, \\epsilon=0.02$\n3. $L=1, t=0.0, U=3.0, V=0.0, \\epsilon=0.001$\n4. $L=4, t=0.5, U=2.0, V=0.5, \\epsilon=0.005$\n5. $L=2, t=0.0, U=0.0, V=0.0, \\epsilon=0.01$\n\n最终输出应为一个包含五个整数的列表，表示每个测试用例计算出的总测量代价。将此列表格式化为 `[result1,result2,result3,result4,result5]`。", "solution": "用户提供的问题是计算量子物理领域中一个明确定义的任务，具体涉及在扩展哈伯德模型上运行变分量子本征求解器（VQE）算法的资源估算。问题陈述在科学上是合理的、内部一致的，并提供了构建唯一算法解决方案所需的所有信息。因此，它被认为是一个有效的问题。\n\n解决方案系统地通过以下步骤进行：\n1.  **通过 Jordan-Wigner 变换构建哈密顿量**：将二次量子化的扩展哈伯德哈密顿量转换为量子比特哈密顿量，即带有实系数的多量子比特泡利算符（泡利串）之和。\n2.  **生成冲突图**：基于逐量子比特对易性（QWC）准则构建冲突图。该图的顶点是哈密顿量中的非单位泡利串。如果两个顶点对应的泡利串不是 QWC，则在它们之间添加一条边。\n3.  **贪心图着色**：使用贪心算法对冲突图进行着色。顶点按度数降序排列，以优先为约束最强的泡利串着色。每个颜色类形成一个测量组，因为其中的所有泡利串都是相互 QWC 的。\n4.  **最优测量分配和代价计算**：为每个测量组计算一个方差上界。利用这些方差和目标能量精度 $\\epsilon$，确定最优测量分布以最小化总测量次数（shots）。然后计算总测量代价并向上取整到最近的整数。\n\n我们在下面详细说明这些步骤。\n\n### 1. 量子比特哈密顿量公式化\n\n扩展哈伯德哈密顿量由下式给出：\n$$\nH = -t \\sum_{i=0}^{L-2} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\left( a_{i,\\sigma}^{\\dagger} a_{i+1,\\sigma} + a_{i+1,\\sigma}^{\\dagger} a_{i,\\sigma} \\right)\n+ U \\sum_{i=0}^{L-1} n_{i,\\uparrow} n_{i,\\downarrow}\n+ V \\sum_{i=0}^{L-2} \\sum_{\\sigma,\\sigma' \\in \\{\\uparrow,\\downarrow\\}} n_{i,\\sigma} n_{i+1,\\sigma'}\n$$\n该系统有 $L$ 个格点，考虑自旋后，对应于 $2L$ 个自旋轨道。使用指定的 Jordan-Wigner (JW) 变换，我们将这 $2L$ 个轨道映射到 $N_q = 2L$ 个量子比特。对于位置 $i$ 和自旋 $\\sigma$ 的自旋轨道，其量子比特索引 $p$ 为 $p(i,\\sigma) = 2i$（对于 $\\sigma=\\uparrow$）和 $p(i,\\sigma) = 2i+1$（对于 $\\sigma=\\downarrow$）。\n\n将提供的 JW 变换规则应用于 $H$ 的每一项：\n\n- **跃迁项 ($t$)**：对于每个位置 $i \\in [0, L-2]$ 和自旋 $\\sigma$，我们有项 $-t(a_{i,\\sigma}^{\\dagger} a_{i+1,\\sigma} + h.c.)$。令 $p = p(i,\\sigma)$ 和 $q = p(i+1,\\sigma)$。JW 变换得到：\n$$\na_p^{\\dagger} a_q + a_q^{\\dagger} a_p = \\frac{1}{2}\\left( X_p \\left( \\prod_{r=p+1}^{q-1} Z_r \\right) X_q + Y_p \\left( \\prod_{r=p+1}^{q-1} Z_r \\right) Y_q \\right)\n$$\n这两个泡利串中的每一个都获得一个 $-t/2$ 的系数。\n\n- **在位相互作用项 ($U$)**：对于每个位置 $i \\in [0, L-1]$，我们有 $U n_{i,\\uparrow} n_{i,\\downarrow}$。令 $p = p(i,\\uparrow)=2i$ 和 $q = p(i,\\downarrow)=2i+1$。粒子数算符为 $n_k = (1-Z_k)/2$。该乘积变为：\n$$\nU n_p n_q = U \\frac{1 - Z_p}{2} \\frac{1 - Z_q}{2} = \\frac{U}{4} (I - Z_p - Z_q + Z_p Z_q)\n$$\n这贡献了三个非单位泡利串：系数为 $-U/4$ 的 $Z_p$，系数为 $-U/4$ 的 $Z_q$，以及系数为 $U/4$ 的 $Z_p Z_q$。单位项 $I$ 被排除在测量分析之外，因为它的期望值是精确已知的，并且方差为零。\n\n- **最近邻相互作用项 ($V$)**：对于每个位置 $i \\in [0, L-2]$，我们有 $V \\sum_{\\sigma,\\sigma'} n_{i,\\sigma} n_{i+1,\\sigma'}$。这一项可以重写为 $V(n_{i,\\uparrow}+n_{i,\\downarrow})(n_{i+1,\\uparrow}+n_{i+1,\\downarrow})$。令 $p_0=2i, p_1=2i+1, q_0=2(i+1), q_1=2(i+1)+1$。该项为 $V(n_{p_0}+n_{p_1})(n_{q_0}+n_{q_1})$。使用 $n_k=(1-Z_k)/2$ 展开此项会导致大量的泡利-Z项。系统地展开会得到：\n    - 对于 $k \\in \\{p_0, p_1, q_0, q_1\\}$ 的单量子比特项 $Z_k$，每个系数为 $-V/2$。\n    - 对于 $\\alpha,\\beta \\in \\{0,1\\}$ 的双量子比特项 $Z_{p_\\alpha}Z_{q_\\beta}$，每个系数为 $V/4$。\n这些项是为每个 $i$ 生成并汇总的。由不同物理项产生的相同泡利串，其系数相加。\n\n### 2. 通过图着色进行测量分组\n\n得到的量子比特哈密顿量为 $H = \\sum_j c_j P_j$。为了估计 $\\langle H \\rangle$，我们需要测量每个 $\\langle P_j \\rangle$。我们将泡利串 $P_j$ 分组以减少不同测量设置的数量。\n\n- **逐量子比特对易性 (QWC)**：如果对于每个量子比特位置 $k$，两个泡利串 $P_A$ 和 $P_B$ 各自的单量子比特算符 $P_{A,k}$ 和 $P_{B,k}$ 对易，则称它们是 QWC 的。如果其中至少一个是单位算符 $I$，或者它们是相同的算符 ($P_{A,k} = P_{B,k}$)，则此条件满足。对于不同的非单位算符 $\\{X,Y,Z\\}$，任何一对都不可对易。因此，条件简化为：如果不存在位置 $k$ 使得 $P_{A,k} \\neq I$，$P_{B,k} \\neq I$ 且 $P_{A,k} \\neq P_{B,k}$，则 $P_A$ 和 $P_B$ 是 QWC 的。\n\n- **冲突图**：我们构建一个图，其中每个顶点代表一个非单位泡利串 $P_j$。如果两个顶点对应的泡利串*不是* QWC 的，则在它们之间放置一条边。\n\n- **贪心着色**：应用贪心着色算法来找到冲突图的一个有效顶点着色。\n    1. 将顶点（泡利串）按其在冲突图中的度数降序排序。平局由泡利串的初始索引打破。\n    2. 我们遍历排序后的顶点。对于每个顶点 $v$，我们为其分配尚未被任何已着色邻居使用的最小非负整数颜色。\n    3. 所有被赋予相同颜色的顶点形成一个测量组。根据构造，一个组中的所有泡利串都是相互 QWC 的。\n\n### 3. 测量代价估算\n\n能量估计的总方差是每个组方差的总和：$\\mathrm{Var}(\\langle H \\rangle) = \\sum_k \\mathrm{Var}(\\hat{E}_k)$，其中 $\\hat{E}_k$ 是从组 $G_k$ 得到的能量估计。对于 $N_k$ 次测量，$\\mathrm{Var}(\\hat{E}_k) = \\sigma_k^2/N_k$，其中 $\\sigma_k^2$ 是该组的单次测量方差。问题提供了一个保守的界：\n$$\n\\sigma_k^2 \\le V_k = \\sum_{j \\in G_k} c_j^2\n$$\n总方差必须小于或等于目标精度 $\\epsilon$ 的平方：\n$$\n\\sum_k \\frac{V_k}{N_k} \\le \\epsilon^2\n$$\n为了在该约束下最小化总测量代价 $S = \\sum_k N_k$，我们使用拉格朗日乘数法，得出最优分配：\n$$\nN_k = \\frac{\\sqrt{V_k} \\sum_j \\sqrt{V_j}}{\\epsilon^2}\n$$\n最小总测量代价 $S_{\\min}$ 则为：\n$$\nS_{\\min} = \\sum_k N_k = \\frac{\\left( \\sum_j \\sqrt{V_j} \\right) \\left( \\sum_k \\sqrt{V_k} \\right)}{\\epsilon^2} = \\frac{\\left( \\sum_k \\sqrt{V_k} \\right)^2}{\\epsilon^2}\n$$\n最终的测量次数是大于或等于 $S_{\\min}$ 的最小整数，即 $\\lceil S_{\\min} \\rceil$。如果哈密顿量不包含非单位项（即它是一个常数），则测量代价为 $0$。\n\n这整个过程的实现已在最终答案的代码块中提供。", "answer": "```python\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    # Pauli operators are represented by integers: 0:I, 1:X, 2:Y, 3:Z\n    PAULI_I, PAULI_X, PAULI_Y, PAULI_Z = 0, 1, 2, 3\n\n    def build_hamiltonian(L, t, U, V):\n        \"\"\"\n        Constructs the qubit Hamiltonian as a dictionary of {Pauli_tuple: coefficient}.\n        \"\"\"\n        if L == 0:\n            return {}\n            \n        num_qubits = 2 * L\n        hamiltonian = defaultdict(float)\n\n        def add_pauli(p_str, coeff):\n            hamiltonian[p_str] += coeff\n        \n        # Helper to create a Pauli string from a dict of {qubit_idx: operator}\n        def create_pauli(op_dict):\n            p_list = [PAULI_I] * num_qubits\n            for q_idx, op in op_dict.items():\n                p_list[q_idx] = op\n            return tuple(p_list)\n\n        # 1. Hopping term (-t)\n        if t != 0.0:\n            for i in range(L - 1):\n                for sigma in range(2):  # 0 for up, 1 for down\n                    p = 2 * i + sigma\n                    q = 2 * (i + 1) + sigma\n                    \n                    z_chain = {r: PAULI_Z for r in range(p + 1, q)}\n                    \n                    # X_p ... Z ... X_q term\n                    op_dict_x = z_chain.copy()\n                    op_dict_x[p] = PAULI_X\n                    op_dict_x[q] = PAULI_X\n                    add_pauli(create_pauli(op_dict_x), -t / 2.0)\n                    \n                    # Y_p ... Z ... Y_q term\n                    op_dict_y = z_chain.copy()\n                    op_dict_y[p] = PAULI_Y\n                    op_dict_y[q] = PAULI_Y\n                    add_pauli(create_pauli(op_dict_y), -t / 2.0)\n\n        # 2. On-site interaction term (U)\n        if U != 0.0:\n            for i in range(L):\n                p_up = 2 * i\n                p_down = 2 * i + 1\n                \n                # -U/4 * Z_p\n                add_pauli(create_pauli({p_up: PAULI_Z}), -U / 4.0)\n                # -U/4 * Z_q\n                add_pauli(create_pauli({p_down: PAULI_Z}), -U / 4.0)\n                # +U/4 * Z_p * Z_q\n                add_pauli(create_pauli({p_up: PAULI_Z, p_down: PAULI_Z}), U / 4.0)\n\n        # 3. Nearest-neighbor interaction term (V)\n        if V != 0.0:\n            for i in range(L - 1):\n                # (n_i,up + n_i,down) * (n_i+1,up + n_i+1,down)\n                # n_i,s = (1 - Z_p(i,s))/2\n                # Sum over sigma, sigma' of n_i,s * n_i+1,s'\n                qubits_i = [2 * i, 2 * i + 1]\n                qubits_i1 = [2 * (i + 1), 2 * (i + 1) + 1]\n                \n                for p in qubits_i:\n                    for q in qubits_i1:\n                        # V * n_p * n_q = V/4 * (1 - Zp - Zq + ZpZq)\n                        add_pauli(create_pauli({p: PAULI_Z}), -V / 4.0)\n                        add_pauli(create_pauli({q: PAULI_Z}), -V / 4.0)\n                        add_pauli(create_pauli({p: PAULI_Z, q: PAULI_Z}), V / 4.0)\n        \n        # Clean up terms with coefficients close to zero\n        final_hamiltonian = {p: c for p, c in hamiltonian.items() if not np.isclose(c, 0)}\n        return final_hamiltonian\n\n    def are_qwc(p1, p2):\n        \"\"\"Checks if two Pauli strings are qubit-wise commuting.\"\"\"\n        for op1, op2 in zip(p1, p2):\n            if op1 != PAULI_I and op2 != PAULI_I and op1 != op2:\n                return False\n        return True\n\n    def calculate_shot_cost(L, t, U, V, epsilon):\n        \"\"\"\n        Performs the full calculation pipeline for a single test case.\n        \"\"\"\n        hamiltonian = build_hamiltonian(L, t, U, V)\n        \n        if not hamiltonian:\n            return 0\n        \n        pauli_list = list(hamiltonian.keys())\n        coeffs = list(hamiltonian.values())\n        num_paulis = len(pauli_list)\n\n        # Build conflict graph\n        adj = [[] for _ in range(num_paulis)]\n        degrees = [0] * num_paulis\n        for i in range(num_paulis):\n            for j in range(i + 1, num_paulis):\n                if not are_qwc(pauli_list[i], pauli_list[j]):\n                    adj[i].append(j)\n                    adj[j].append(i)\n                    degrees[i] += 1\n                    degrees[j] += 1\n        \n        # Greedy coloring\n        # Order vertices by decreasing degree (stable sort breaks ties by original index)\n        sorted_vertices = sorted(range(num_paulis), key=lambda i: degrees[i], reverse=True)\n        \n        colors = [-1] * num_paulis\n        num_colors = 0\n        \n        for i in sorted_vertices:\n            neighbor_colors = {colors[j] for j in adj[i] if colors[j] != -1}\n            \n            c = 0\n            while True:\n                if c not in neighbor_colors:\n                    # Check if this vertex is QWC with all other vertices of this color\n                    is_compatible = True\n                    for j in range(num_paulis):\n                        if colors[j] == c:\n                            if not are_qwc(pauli_list[i], pauli_list[j]):\n                                is_compatible = False\n                                break\n                    if is_compatible:\n                        colors[i] = c\n                        if c + 1 > num_colors:\n                            num_colors = c + 1\n                        break\n                c += 1\n\n        # Calculate group variances (V_k)\n        group_variances = [0.0] * num_colors\n        for i in range(num_paulis):\n            color = colors[i]\n            group_variances[color] += coeffs[i]**2\n        \n        # Calculate total shot cost\n        sum_sqrt_V = sum(np.sqrt(v) for v in group_variances if v > 0)\n        s_min = (sum_sqrt_V**2) / (epsilon**2)\n        \n        return int(np.ceil(s_min))\n\n    test_cases = [\n        (2, 1.0, 4.0, 1.0, 0.01),\n        (3, 1.0, 0.0, 0.0, 0.02),\n        (1, 0.0, 3.0, 0.0, 0.001),\n        (4, 0.5, 2.0, 0.5, 0.005),\n        (2, 0.0, 0.0, 0.0, 0.01),\n    ]\n\n    results = []\n    for L, t, U, V, epsilon in test_cases:\n        result = calculate_shot_cost(L, t, U, V, epsilon)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3481711"}]}