{"hands_on_practices": [{"introduction": "为了通过力匹配（Force Matching）等方法参数化一个粗粒化势函数，首要任务是选择一个灵活且数学上稳健的函数形式来表示该势。B样条（B-splines）因其出色的局部控制性和可调节的光滑性，成为了一种强大的标准工具。本练习将引导你亲手构建三次B样条基函数及其导数，并组装力匹配方法中的核心部分——设计矩阵，从而为你掌握复杂势函数的数值表示打下坚实基础[@problem_id:3438346]。", "problem": "在计算材料科学中，考虑一个粗粒化对相互作用模型，其中粒子系统由一个仅依赖于两个粗粒化位点之间标量距离 $r$ 的对势 $u(r)$ 建模。粒子上的力由势的负梯度给出，与牛顿第二定律一致。具体来说，对于由索引 $i$ 和 $j$ 标记的粒子，作用在粒子 $i$ 上的成对力贡献为 $-\\dfrac{d u(r_{ij})}{d r} \\hat{\\boldsymbol{r}}_{ij}$，其中 $\\boldsymbol{r}_{ij} = \\boldsymbol{x}_{j} - \\boldsymbol{x}_{i}$，$r_{ij} = \\|\\boldsymbol{r}_{ij}\\|$，以及 $\\hat{\\boldsymbol{r}}_{ij} = \\boldsymbol{r}_{ij} / r_{ij}$。力匹配（Force Matching, FM）是一种用于粗粒化参数化的线性回归方法，它将 $u(r)$ 在一个固定基中展开，并求解一个线性系统来匹配采样的微观力。\n\n你的任务是为一个指定的节点矢量构造一个用于对势 $u(r)$ 的三次B样条基，并具有适当的端点重数以达到所需的连续性，然后构建用于力匹配的线性设计矩阵。你必须从基本原理和经过充分检验的公式出发，以一种在物理和数学上都有根据的方式来解决这个问题。不要假设任何启发式的捷径。\n\n使用以下基本依据：\n\n- 由中心势产生的粒子上的力为 $-\\nabla u(r)$，对于粗粒化模型中的对相互作用，粒子 $i$ 上的净力为 $\\boldsymbol{F}_{i} = \\sum_{j \\neq i} -\\dfrac{d u(r_{ij})}{d r} \\hat{\\boldsymbol{r}}_{ij}$。\n- 将对势表示为基函数的线性组合：$u(r) = \\sum_{k=0}^{K-1} c_{k} B_{k}(r)$，其中 $B_{k}(r)$ 是定义在开放、钳位节点矢量上的三次B样条基函数，$c_{k}$ 是待通过力匹配确定的系数。\n- 三次B样条基函数 $B_{k}(r)$ 必须在内部节点处满足 $C^{2}$ 连续性。这通过使用一个次数 $p=3$ 的样条和一个开放节点矢量（即端点重复 $p+1$ 次）来实现。\n- Cox–de Boor 递推是用于在给定节点矢量上构造任意次数B样条基函数的经过充分检验的公式。在你的推导和实现中，使用此公式来定义 $B_{k}(r)$ 及其导数 $\\dfrac{d B_{k}(r)}{d r}$。\n\n按如下方式定义样条的节点矢量（单位为纳米）。设定义域为 $[r_{\\min}, r_{\\max}]$，其中 $r_{\\min} = 0.3$，$r_{\\max} = 1.1$。设内部节点位于 $0.5$、$0.7$ 和 $0.9$。通过将端点重复 $p+1=4$ 次来构造一个开放、钳位的节点矢量：\n$$\n\\{t_{i}\\} = \\{0.3, 0.3, 0.3, 0.3, 0.5, 0.7, 0.9, 1.1, 1.1, 1.1, 1.1\\}。\n$$\n根据这个节点矢量和次数 $p = 3$，确定基函数的数量 $K$，并构造满足内部节点连续性约束的 $B_{k}(r)$ 和 $\\dfrac{d B_{k}(r)}{d r}$。然后，用这些导数和几何矢量来表示FM设计矩阵 $\\boldsymbol{A}$。对于一个在三维空间中有 $N$ 个粒子的系统，线性系统形式如下：\n$$\n\\boldsymbol{A} \\boldsymbol{c} = \\boldsymbol{y},\n$$\n其中 $\\boldsymbol{c} \\in \\mathbb{R}^{K}$ 是未知系数，$\\boldsymbol{A}$ 的每一行对应于一个粒子上净力的一个笛卡尔分量。具体来说，对于粒子 $i$ 和分量 $\\alpha \\in \\{x,y,z\\}$，\n$$\nA_{(3i+\\alpha),\\,k} = \\sum_{j \\neq i} \\left( - \\frac{d B_{k}(r_{ij})}{d r} \\right) \\hat{r}_{ij, \\alpha}。\n$$\n\n你的程序必须实现：\n\n1. 基于指定的节点矢量，通过 Cox–de Boor 递推构造三次B样条基函数 $B_{k}(r)$ 及其导数 $\\dfrac{d B_{k}(r)}{d r}$，确保在内部节点处具有 $C^{2}$ 连续性以及开放钳位的端点条件。\n2. 对于指定的粒子构型，使用上述公式组装FM设计矩阵 $\\boldsymbol{A}$。\n\n使用以下测试套件，所有距离单位为纳米，所有涉及导数或范数的输出单位为反纳米（$\\text{nm}^{-1}$）。不使用角度。对于每种情况，计算所要求的标量结果：\n\n- 测试用例1（一般情况）：使用 $N=3$ 个粒子，位置如下：\n$$\n\\boldsymbol{x}_{0} = (0.0, 0.0, 0.0),\\quad \\boldsymbol{x}_{1} = (0.6, 0.0, 0.0),\\quad \\boldsymbol{x}_{2} = (0.0, 0.8, 0.0)。\n$$\n构造 $\\boldsymbol{A}$ 并报告 $\\boldsymbol{A}$ 的弗罗贝尼乌斯范数，即 $\\|\\boldsymbol{A}\\|_{F}$，作为一个浮点数，单位为 $\\text{nm}^{-1}$。\n\n- 测试用例2（内部节点的连续性）：令 $r_{k} = 0.7$ 且 $\\varepsilon = 10^{-8}$。计算导数基在节点上的最大绝对跳跃：\n$$\nJ = \\max_{k} \\left| \\left.\\frac{d B_{k}(r)}{d r}\\right|_{r = r_{k} - \\varepsilon} - \\left.\\frac{d B_{k}(r)}{d r}\\right|_{r = r_{k} + \\varepsilon} \\right|。\n$$\n报告 $J$ 作为一个浮点数，单位为 $\\text{nm}^{-1}$。\n\n- 测试用例3（支撑域外的边界情况）：使用 $N=2$ 个粒子，位置如下：\n$$\n\\boldsymbol{x}_{0} = (0.0, 0.0, 0.0),\\quad \\boldsymbol{x}_{1} = (1.3, 0.0, 0.0)。\n$$\n构造 $\\boldsymbol{A}$ 并报告 $\\boldsymbol{A}$ 的最大绝对值元素，即 $\\max_{i,k} |A_{i,k}|$，作为一个浮点数，单位为 $\\text{nm}^{-1}$。\n\n你的程序应该产生单行输出，包含一个方括号内以逗号分隔的结果列表（例如，$[r_{1}, r_{2}, r_{3}]$），其中 $r_{1}$、$r_{2}$ 和 $r_{3}$ 分别是对应于测试用例1、2和3的浮点数，单位为 $\\text{nm}^{-1}$。不应打印任何其他文本。所有计算都应是自包含且数值稳健的。", "solution": "用户要求解决一个计算材料科学问题，该问题涉及使用力匹配（FM）方法对粗粒化势进行参数化。势在三次B样条基中展开。任务的核心是使用 Cox-de Boor 递推实现B样条基函数及其导数，然后为几个测试用例组装FM设计矩阵。\n\n### 问题验证\n\n根据指定标准对问题陈述进行审视。\n\n-   **已知条件提取**：\n    -   模型：粗粒化系统的对势 $u(r)$。\n    -   力定律：$\\boldsymbol{F}_{i} = \\sum_{j \\neq i} -\\dfrac{d u(r_{ij})}{d r} \\hat{\\boldsymbol{r}}_{ij}$，其中 $\\boldsymbol{r}_{ij} = \\boldsymbol{x}_{j} - \\boldsymbol{x}_{i}$，$r_{ij} = \\|\\boldsymbol{r}_{ij}\\|$，以及 $\\hat{\\boldsymbol{r}}_{ij} = \\boldsymbol{r}_{ij} / r_{ij}$。\n    -   势基：$u(r) = \\sum_{k=0}^{K-1} c_{k} B_{k}(r)$，其中 $B_{k}(r)$ 是三次（$p=3$）B样条基函数。\n    -   样条属性：内部节点处具有 $C^{2}$ 连续性，通过使用开放、钳位的节点矢量实现，端点重数为 $p+1=4$。\n    -   节点矢量 $\\{t_i\\}$：$\\{0.3, 0.3, 0.3, 0.3, 0.5, 0.7, 0.9, 1.1, 1.1, 1.1, 1.1\\}$ nm。\n    -   B样条构造：使用 Cox-de Boor 递推计算值 $B_{k}(r)$ 和导数 $d B_{k}(r)/dr$。\n    -   FM设计矩阵：$\\boldsymbol{A} \\boldsymbol{c} = \\boldsymbol{y}$，其元素为 $A_{(3i+\\alpha),\\,k} = \\sum_{j \\neq i} \\left( - \\frac{d B_{k}(r_{ij})}{d r} \\right) \\hat{r}_{ij, \\alpha}$。\n    -   测试用例：特定的粒子构型以及关于基和矩阵 $\\boldsymbol{A}$ 属性的查询。\n\n-   **验证结论**：\n    -   **科学基础**：该问题在计算统计力学和数值方法的原理上有坚实的基础。力匹配、B样条表示和 Cox-de Boor 算法都是该领域中标准且成熟的技术。\n    -   **良构性**：问题是自包含的，并提供了所有必要信息：物理模型、数学公式、特定的节点矢量、样条次数、粒子构型以及要计算的精确量。基函数的数量 $K$ 可以从节点矢量长度（$m+1=11$）和次数（$p=3$）唯一确定为 $K = m-p = (11-1)-3 = 7$。\n    -   **客观性**：问题以精确、客观和数学化的语言陈述，没有歧义或主观元素。\n\n问题被判定为**有效**，因为它是科学合理、良构且客观的。可以构建一个解决方案。\n\n### 基于原理的解决方案\n\n解决方案首先为B样条及其在力匹配方法中的应用建立理论和算法基础，然后对测试用例进行具体计算。\n\n**1. 力匹配框架**\n\n力匹配的目标是通过最小化由 $u(r)$ 预测的力与参考力（通常从更详细的模拟，如全原子模拟中获得）之间的差异，来确定粗粒化势 $u(r)$ 的最优系数 $c_k$。势表示为基函数的线性组合：\n$$\nu(r) = \\sum_{k=0}^{K-1} c_{k} B_{k}(r)\n$$\n粒子 $i$ 上的力是总势能的负梯度，$\\boldsymbol{F}_{i} = -\\nabla_{\\boldsymbol{x}_i} U$。对于由对势描述的系统，这变为：\n$$\n\\boldsymbol{F}_{i} = \\sum_{j \\neq i} -\\frac{d u(r_{ij})}{d r} \\hat{\\boldsymbol{r}}_{ij}\n$$\n代入 $u(r)$ 的基展开，我们得到力的线性关系：\n$$\n\\boldsymbol{F}_{i} = \\sum_{j \\neq i} -\\frac{d}{d r} \\left( \\sum_{k=0}^{K-1} c_{k} B_{k}(r_{ij}) \\right) \\hat{\\boldsymbol{r}}_{ij} = \\sum_{k=0}^{K-1} c_{k} \\left( \\sum_{j \\neq i} - \\frac{d B_{k}(r_{ij})}{d r} \\hat{\\boldsymbol{r}}_{ij} \\right)\n$$\n这可以写成一个线性方程组 $\\boldsymbol{A} \\boldsymbol{c} = \\boldsymbol{y}$，其中 $\\boldsymbol{y}$ 是参考力矢量，$\\boldsymbol{c}$ 是未知系数矢量 $[c_0, \\dots, c_{K-1}]^T$，$\\boldsymbol{A}$ 是设计矩阵。$\\boldsymbol{A}$ 中对应于粒子 $i$ 上的力的第 $\\alpha$ 个笛卡尔分量且与基函数 $B_k$ 相关的元素是：\n$$\nA_{(3i+\\alpha),\\,k} = \\sum_{j \\neq i} \\left( - \\frac{d B_{k}(r_{ij})}{d r} \\right) \\hat{r}_{ij, \\alpha}\n$$\n\n**2. 三次B样条基函数**\n\n基函数 $B_{k}(r)$ 被选为在给定节点矢量 $T = \\{t_0, t_1, \\dots, t_m\\}$ 上定义的三次B样条（$p=3$）。基函数的数量为 $K=m-p=7$。样条基的定义域是 $[t_p, t_{m-p}] = [t_3, t_7] = [0.3, 1.1]$。\n\n**Cox-de Boor 递推：**\n次数为 $p$ 的B样条基函数 $B_{k,p}(r)$ 通过 Cox-de Boor 公式构造：\n-   基本情况（$p=0$）：\n    $$\n    B_{k,0}(r) = \\begin{cases} 1  \\text{if } t_k \\le r  t_{k+1} \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n    在定义域的右边界 $r=t_{m-p}$ 处需要一个特殊约定，在该处区间的严格定义导致值为0。数学上，样条由其左极限定义。在数值上，这可以通过在 $r_{max} - \\epsilon$ （对于一个小的 $\\epsilon>0$）处求值来处理。\n-   递推步骤（$p > 0$）：\n    $$\n    B_{k,p}(r) = \\frac{r - t_k}{t_{k+p} - t_k} B_{k,p-1}(r) + \\frac{t_{k+p+1} - r}{t_{k+p+1} - t_{k+1}} B_{k+1,p-1}(r)\n    $$\n    约定是，如果分母为零（由于重复节点），则相应项为零。\n\n**B样条的导数：**\nB样条的导数也以递推方式定义：\n$$\n\\frac{d}{dr} B_{k,p}(r) = p \\left( \\frac{B_{k,p-1}(r)}{t_{k+p} - t_k} - \\frac{B_{k+1,p-1}(r)}{t_{k+p+1} - t_{k+1}} \\right)\n$$\n关于零分母的相同约定适用。使用具有单内部节点的钳位节点矢量可确保样条具有 $C^{p-1} = C^2$ 连续性，其一阶导数在内部节点处具有 $C^1$ 连续性。\n\n**3. 实现与测试用例**\n\n解决方案需要实现这些递推公式，并将其应用于给定的测试用例。对递推函数采用记忆化以避免对相同的输入 `(k, p, r)` 重复计算值。\n\n-   **测试用例1**：一个包含 $N=3$ 个粒子的系统，其位置给定。对间距离为 $r_{01} = 0.6$ nm，$r_{02} = 0.8$ nm 和 $r_{12} = 1.0$ nm。通过在这些距离处计算B样条导数并对每个粒子和力分量求和贡献，构造 $9 \\times 7$ 的设计矩阵 $\\boldsymbol{A}$。最终结果是弗罗贝尼乌斯范数 $\\|\\boldsymbol{A}\\|_{F} = \\sqrt{\\sum_{i,j} |A_{ij}|^2}$。\n\n-   **测试用例2**：此案例验证B样条导数的连续性。节点矢量在 $r_k=0.7$ 处有一个单内部节点。对于在此类矢量上定义的三次样条基，每个基函数的导数必须是连续的。该测试计算导数值在节点上的跳跃，即 $\\left| \\frac{d B_{k}}{dr}(r_k - \\varepsilon) - \\frac{d B_{k}}{dr}(r_k + \\varepsilon) \\right|$，其中 $\\varepsilon=10^{-8}$ 是一个小数。正如样条理论所预期的，这个跳跃应该在机器精度范围内为零。\n\n-   **测试用例3**：一个包含 $N=2$ 个粒子的系统，其间距为 $r_{01} = 1.3$ nm。该距离位于样条基的支撑域 $[0.3, 1.1]$ nm 之外。根据定义，任何B样条基函数 $B_k(r)$ 及其导数在它们的支撑域之外的 $r$ 处均为零。因此，所有 $\\frac{d B_k(1.3)}{dr}$ 项均为零。这导致设计矩阵 $\\boldsymbol{A}$ 的所有元素都为零。因此，最大绝对值元素为 $0.0$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the B-spline Force Matching problem.\n    \"\"\"\n    \n    # Global parameters\n    KNOTS = np.array([0.3, 0.3, 0.3, 0.3, 0.5, 0.7, 0.9, 1.1, 1.1, 1.1, 1.1])\n    DEGREE = 3 # p\n    \n    # Memoization caches\n    memo_B = {}\n    memo_dB = {}\n\n    def get_B_spline(k, p, r, knots):\n        \"\"\"\n        Computes the value of the k-th B-spline of degree p at r.\n        Uses the Cox-de Boor recursion with memoization.\n        \"\"\"\n        if (k, p, r) in memo_B:\n            return memo_B[(k, p, r)]\n        \n        # Handle evaluation at the right boundary of the domain\n        # The limit from the left is used, emulated by a small perturbation.\n        if r == knots[-1]:\n            r = r - 1e-12\n\n        if p == 0:\n            val = 1.0 if knots[k] = r  knots[k+1] else 0.0\n            memo_B[(k, p, r)] = val\n            return val\n\n        # First term of the recursion\n        term1 = 0.0\n        den1 = knots[k + p] - knots[k]\n        if den1 != 0.0:\n            term1 = ((r - knots[k]) / den1) * get_B_spline(k, p - 1, r, knots)\n        \n        # Second term of the recursion\n        term2 = 0.0\n        den2 = knots[k + p + 1] - knots[k + 1]\n        if den2 != 0.0:\n            term2 = ((knots[k + p + 1] - r) / den2) * get_B_spline(k + 1, p - 1, r, knots)\n\n        val = term1 + term2\n        memo_B[(k, p, r)] = val\n        return val\n\n    def get_dB_spline(k, p, r, knots):\n        \"\"\"\n        Computes the derivative of the k-th B-spline of degree p at r.\n        Uses the standard formula with memoization.\n        \"\"\"\n        if (k, p, r) in memo_dB:\n            return memo_dB[(k, p, r)]\n\n        # Derivative is zero outside the support [t_k, t_{k+p+1}]\n        if r  knots[k] or r > knots[k+p+1]:\n             memo_dB[(k, p, r)] = 0.0\n             return 0.0\n\n        # Term 1 of the derivative formula\n        term1 = 0.0\n        den1 = knots[k + p] - knots[k]\n        if den1 != 0.0:\n            term1 = get_B_spline(k, p - 1, r, knots) / den1\n\n        # Term 2 of the derivative formula\n        term2 = 0.0\n        den2 = knots[k + p + 1] - knots[k + 1]\n        if den2 != 0.0:\n            term2 = get_B_spline(k + 1, p - 1, r, knots) / den2\n        \n        val = p * (term1 - term2)\n        memo_dB[(k, p, r)] = val\n        return val\n\n    def assemble_A(positions, knots, p):\n        \"\"\"\n        Assembles the Force Matching design matrix A.\n        \"\"\"\n        n_particles = positions.shape[0]\n        m = len(knots) - 1\n        n_basis = m - p\n\n        A = np.zeros((3 * n_particles, n_basis))\n\n        # Clear memoization caches for new assembly\n        memo_B.clear()\n        memo_dB.clear()\n\n        for i in range(n_particles):\n            for k in range(n_basis):\n                sum_vec = np.zeros(3)\n                for j in range(n_particles):\n                    if i == j:\n                        continue\n                    \n                    r_vec = positions[j] - positions[i]\n                    r_norm = np.linalg.norm(r_vec)\n                    \n                    # Handle case where r_norm is 0, though not in test cases\n                    if r_norm == 0:\n                        continue\n                    \n                    r_hat = r_vec / r_norm\n                    \n                    db_dr = get_dB_spline(k, p, r_norm, knots)\n                    \n                    sum_vec += -db_dr * r_hat\n\n                A[3 * i : 3 * i + 3, k] = sum_vec\n        return A\n\n    results = []\n\n    # Test Case 1\n    positions_1 = np.array([\n        [0.0, 0.0, 0.0],\n        [0.6, 0.0, 0.0],\n        [0.0, 0.8, 0.0]\n    ])\n    A1 = assemble_A(positions_1, KNOTS, DEGREE)\n    result_1 = np.linalg.norm(A1, 'fro')\n    results.append(result_1)\n\n    # Test Case 2\n    r_knot = 0.7\n    epsilon = 1e-8\n    m = len(KNOTS) - 1\n    n_basis = m - DEGREE\n    max_jump = 0.0\n    memo_B.clear()\n    memo_dB.clear()\n    for k in range(n_basis):\n        d_left = get_dB_spline(k, DEGREE, r_knot - epsilon, KNOTS)\n        d_right = get_dB_spline(k, DEGREE, r_knot + epsilon, KNOTS)\n        jump = abs(d_left - d_right)\n        if jump > max_jump:\n            max_jump = jump\n    result_2 = max_jump\n    results.append(result_2)\n\n    # Test Case 3\n    positions_3 = np.array([\n        [0.0, 0.0, 0.0],\n        [1.3, 0.0, 0.0]\n    ])\n    A3 = assemble_A(positions_3, KNOTS, DEGREE)\n    result_3 = np.max(np.abs(A3))\n    results.append(result_3)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3438346"}, {"introduction": "与基于力的力匹配方法不同，基于结构的粗粒化方法旨在复现系统的微观结构特征，其中迭代玻尔兹曼反演（Iterative Boltzmann Inversion, IBI）是最经典的方法之一。该方法通过迭代修正势函数，使得模拟得到的径向分布函数 $g(r)$ 逐渐逼近目标函数。然而，本练习将揭示一个深刻的挑战：精确复现结构并不保证能复现所有热力学性质（即可表征性问题），例如压强。你将通过一个巧妙设计的思想实验理解IBI的核心机制，并学习如何通过引入一个基于物理的压强修正项来解决这一关键问题[@problem_id:3438347]。", "problem": "你需要实现一个完整的数值研究，该研究针对一个二元Lennard-Jones混合物，使用迭代玻尔兹曼反演（IBI）方法进行粗粒化参数化，并随后进行基于物理的压力修正。目标是再现目标径向分布函数，并诊断该方法为何无法再现压力，然后提出并计算一个势函数的修正振幅，以匹配指定的压力偏差。\n\n基本原理：\n- 物种 $i$ 和 $j$ 之间的Lennard-Jones对势定义为\n$$\nU_{ij}(r) = 4 \\varepsilon_{ij} \\left[\\left(\\frac{\\sigma_{ij}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{ij}}{r}\\right)^6 \\right].\n$$\n- 在低密度极限下，径向分布函数与对势的关系为\n$$\ng_{ij}(r) \\approx \\exp\\left(-\\beta U_{ij}(r)\\right), \\quad \\beta = \\frac{1}{k_B T}.\n$$\n- 对势的迭代玻尔兹曼反演（IBI）更新公式为\n$$\nU^{(n+1)}_{ij}(r) = U^{(n)}_{ij}(r) + \\Delta U^{(n)}_{ij}(r), \\quad \\Delta U^{(n)}_{ij}(r) = k_B T \\ln\\left(\\frac{g^{(n)}_{ij}(r)}{g_{\\mathrm{target},ij}(r)}\\right),\n$$\n初始猜测为\n$$\nU^{(0)}_{ij}(r) = -k_B T \\ln g_{\\mathrm{target},ij}(r).\n$$\n- 均匀二元混合物的维里路径压力近似为\n$$\nP = \\rho k_B T - \\frac{2\\pi}{3} \\rho^2 \\sum_{i,j \\in \\{A,B\\}} x_i x_j \\int_0^{r_c} r^3 \\frac{dU_{ij}(r)}{dr} g_{ij}(r) \\, dr,\n$$\n其中 $\\rho$ 是数密度，$x_i$ 是摩尔分数，$r_c$ 是截断半径。\n\n研究设置：\n1. 使用约化单位，其中能量单位为 $\\varepsilon_{AA}$，长度单位为 $\\sigma_{AA}$，温度采用传统约化形式 $T^\\star = k_B T / \\varepsilon_{AA}$。对于所有计算，压力以 $\\varepsilon_{AA}/\\sigma_{AA}^3$ 表示，最终修正振幅以 $\\varepsilon_{AA}$ 表示。\n2. 二元混合物参数为\n   - $\\varepsilon_{AA} = 1.0$, $\\sigma_{AA} = 1.0$,\n   - $\\varepsilon_{BB} = 0.5$, $\\sigma_{BB} = 0.8$,\n   - $\\varepsilon_{AB} = \\sqrt{\\varepsilon_{AA}\\varepsilon_{BB}}$, $\\sigma_{AB} = (\\sigma_{AA} + \\sigma_{BB})/2$.\n3. 目标结构数据由低密度映射定义\n$$\ng_{\\mathrm{target},ij}(r) = \\exp\\left(-\\beta U_{ij}(r)\\right).\n$$\n4. 在IBI过程中，使用相同的低密度闭合关系来模拟结构响应\n$$\ng^{(n)}_{ij}(r) = \\exp\\left(-\\beta U^{(n)}_{ij}(r)\\right),\n$$\n并使用一个混合参数 $0  \\lambda \\leq 1$ 来稳定更新过程\n$$\nU^{(n+1)}_{ij}(r) = U^{(n)}_{ij}(r) + \\lambda \\, k_B T \\ln\\left(\\frac{g^{(n)}_{ij}(r)}{g_{\\mathrm{target},ij}(r)}\\right).\n$$\n使用 $\\lambda = 0.2$，进行迭代，直到 $U^{(n)}_{ij}(r)$ 在整个网格上的最大绝对变化量小于 $10^{-9}$，或达到最多 $50$ 次迭代。将 $r \\in [r_{\\min}, r_c]$ 均匀离散化，其中 $r_{\\min} = 0.7 \\, \\sigma_{AA}$ 且 $r_c = 3.0 \\, \\sigma_{AA}$，使用至少 $1000$ 个网格点。\n\n诊断与压力修正：\n- IBI收敛后，使用上述公式和 $g_{ij}(r) = g_{\\mathrm{target},ij}(r)$ 计算维里路径压力 $P_{\\mathrm{calc}}$。在粗粒化中，由于忽略了多体贡献，通过维里路径得到的压力通常会偏离同一状态点下原子级别的参考压力。\n- 通过在截断半径内向对势中添加一个平滑、最小扰动的斜坡项来提出压力修正：\n$$\n\\delta U_{ij}(r) = a \\, s(r), \\quad s(r) = \\frac{r}{r_c}, \\quad 0 \\le r \\le r_c.\n$$\n这会产生一个恒定的导数贡献 $d\\,\\delta U_{ij}/dr = a/r_c$，它可以在不严重扭曲短程结构的情况下修正维里压力。由 $a$ 引起的压力偏移为\n$$\n\\Delta P(a) = -\\frac{2\\pi}{3} \\rho^2 \\sum_{i,j} x_i x_j \\int_0^{r_c} r^3 \\frac{d\\,\\delta U_{ij}(r)}{dr} g_{ij}(r) \\, dr\n= -\\frac{a}{r_c} \\frac{2\\pi}{3} \\rho^2 \\sum_{i,j} x_i x_j \\int_0^{r_c} r^3 g_{ij}(r) \\, dr.\n$$\n给定每个测试案例所需的目标压力偏移量 $\\Delta P_{\\mathrm{ref}}$，选择 $a$ 使得 $\\Delta P(a) = \\Delta P_{\\mathrm{ref}}$，即\n$$\na^\\star = - \\frac{r_c \\, \\Delta P_{\\mathrm{ref}}}{\\frac{2\\pi}{3} \\rho^2 \\displaystyle \\sum_{i,j} x_i x_j \\int_0^{r_c} r^3 g_{ij}(r) \\, dr }.\n$$\n\n测试套件：\n为以下测试案例实现上述过程，每个案例由 $(\\rho, T^\\star, x_A, \\Delta P_{\\mathrm{ref}})$ 指定，其中 $x_B = 1 - x_A$。参考压力偏移量 $\\Delta P_{\\mathrm{ref}}$ 是IBI收敛后计算出的维里路径压力所需增加的修正值，单位为 $\\varepsilon_{AA}/\\sigma_{AA}^3$。\n\n- 案例1（理想情况）：$(\\rho = 0.6, T^\\star = 1.0, x_A = 0.5, \\Delta P_{\\mathrm{ref}} = 0.4)$。\n- 案例2（边界：极低密度）：$(\\rho = 0.05, T^\\star = 0.7, x_A = 0.2, \\Delta P_{\\mathrm{ref}} = -0.05)$。\n- 案例3（边缘：高度不对称组分，零修正）：$(\\rho = 0.85, T^\\star = 1.5, x_A = 0.9, \\Delta P_{\\mathrm{ref}} = 0.0)$。\n\n输出规范：\n- 你的程序必须为每个测试案例计算修正振幅 $a^\\star$，并生成一行包含三个浮点数值的逗号分隔的Python列表，单位为 $\\varepsilon_{AA}$，其顺序与所列测试案例的顺序相对应。例如：\"[a1,a2,a3]\"。", "solution": "该问题要求实现一项数值研究，以确定二元Lennard-Jones (LJ)混合物的压力修正。该过程涉及分析迭代玻尔兹曼反演（IBI）方案，理解其在问题简化假设下的结果，然后计算修正振幅 $a^\\star$ 以匹配目标压力偏移 $\\Delta P_{\\mathrm{ref}}$。所有计算均在约化单位下进行，其中 $\\varepsilon_{AA}=1$，$\\sigma_{AA}=1$，温度为 $T^\\star = k_B T / \\varepsilon_{AA}$。\n\n首先，我们定义基本物理模型。物种 $i$ 和 $j$ 的粒子间的对相互作用由Lennard-Jones势描述：\n$$\nU_{ij}(r) = 4 \\varepsilon_{ij} \\left[\\left(\\frac{\\sigma_{ij}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{ij}}{r}\\right)^6 \\right]\n$$\n二元混合物的参数为 $\\varepsilon_{AA} = 1.0$，$\\sigma_{AA} = 1.0$，$\\varepsilon_{BB} = 0.5$ 和 $\\sigma_{BB} = 0.8$。交叉相互作用参数由Lorentz-Berthelot混合规则确定：$\\varepsilon_{AB} = \\sqrt{\\varepsilon_{AA}\\varepsilon_{BB}}$ 和 $\\sigma_{AB} = (\\sigma_{AA} + \\sigma_{BB})/2$。\n\n问题引入了迭代玻尔兹曼反演（IBI）过程来确定粗粒化势。IBI更新规则如下：\n$$\nU^{(n+1)}_{ij}(r) = U^{(n)}_{ij}(r) + \\lambda \\, k_B T \\ln\\left(\\frac{g^{(n)}_{ij}(r)}{g_{\\mathrm{target},ij}(r)}\\right)\n$$\n此问题的关键之处在于目标径向分布函数 $g_{\\mathrm{target},ij}(r)$ 和模拟的结构响应 $g^{(n)}_{ij}(r)$ 的具体选择。两者都使用关联RDF和对势的低密度近似来定义：\n$$\ng_{\\mathrm{target},ij}(r) = \\exp\\left(-\\beta U_{ij}(r)\\right)\n$$\n$$\ng^{(n)}_{ij}(r) = \\exp\\left(-\\beta U^{(n)}_{ij}(r)\\right)\n$$\n其中 $U_{ij}(r)$ 是基本的LJ势，$\\beta = 1/(k_B T)$，而 $U^{(n)}_{ij}(r)$ 是第 $n$ 次迭代时的势。\n\n让我们在这些假设下分析IBI过程。势的初始猜测是 $U^{(0)}_{ij}(r) = -k_B T \\ln g_{\\mathrm{target},ij}(r)$。代入 $g_{\\mathrm{target},ij}(r)$ 的定义：\n$$\nU^{(0)}_{ij}(r) = -k_B T \\ln\\left(\\exp\\left(-\\beta U_{ij}(r)\\right)\\right) = -k_B T \\left(-\\frac{1}{k_B T} U_{ij}(r)\\right) = U_{ij}(r)\n$$\n初始猜测与作为目标RDF基础的基本LJ势相同。现在，我们将 $g^{(n)}_{ij}(r)$ 和 $g_{\\mathrm{target},ij}(r)$ 的关系代入IBI更新规则：\n$$\nU^{(n+1)}_{ij}(r) = U^{(n)}_{ij}(r) + \\lambda k_B T \\ln\\left(\\frac{\\exp(-\\beta U^{(n)}_{ij}(r))}{\\exp(-\\beta U_{ij}(r))}\\right) = U^{(n)}_{ij}(r) + \\lambda k_B T \\beta \\left(U_{ij}(r) - U^{(n)}_{ij}(r)\\right)\n$$\n由于 $k_B T \\beta = 1$，这简化为一个线性递推关系：\n$$\nU^{(n+1)}_{ij}(r) = U^{(n)}_{ij}(r) + \\lambda \\left(U_{ij}(r) - U^{(n)}_{ij}(r)\\right) = (1-\\lambda)U^{(n)}_{ij}(r) + \\lambda U_{ij}(r)\n$$\n由于起始势 $U^{(0)}_{ij}(r)$ 已经是 $U_{ij}(r)$，迭代立即收敛：\n$$\nU^{(1)}_{ij}(r) = (1-\\lambda)U_{ij}(r) + \\lambda U_{ij}(r) = U_{ij}(r)\n$$\n因此，在此背景下，IBI过程是平凡的；“收敛”的粗粒化势就是原始的原子级LJ势 $U_{ij}(r)$。问题设置虽然看起来需要复杂的迭代解，但实际上简化了过程，无需进行迭代。这凸显了一个关键概念：如果系统的结构响应（从 $U(r)$ 得到的 $g(r)$）遵循用于定义目标的相同函数形式，那么像IBI这样基于结构的粗粒化方法可以完美地再现目标势。\n\n主要任务是计算压力修正振幅 $a^\\star$。之所以需要这个修正，是因为一个能再现对结构（RDF）的势并不能保证再现其他热力学性质（如压力），这是粗粒化中一个众所周知的“可表征性”（representability）问题。压力 $P$ 通过维里路径计算，对于二元混合物，其公式为：\n$$\nP = \\rho k_B T - \\frac{2\\pi}{3} \\rho^2 \\sum_{i,j \\in \\{A,B\\}} x_i x_j \\int_0^{r_c} r^3 \\frac{dU_{ij}(r)}{dr} g_{ij}(r) \\, dr\n$$\n问题规定压力计算使用目标RDF，即 $g_{ij}(r) = g_{\\mathrm{target},ij}(r)$。\n\n提出的压力修正方案是在 $r \\in [0, r_c]$ 范围内向势函数中添加一个简单的线性斜坡项 $\\delta U_{ij}(r) = a (r/r_c)$。该修正项的导数是一个常数，$d(\\delta U_{ij})/dr = a/r_c$。由此产生的压力偏移 $\\Delta P(a)$ 为：\n$$\n\\Delta P(a) = -\\frac{2\\pi}{3} \\rho^2 \\sum_{i,j} x_i x_j \\int_0^{r_c} r^3 \\frac{d(\\delta U_{ij}(r))}{dr} g_{ij}(r) \\, dr = -\\frac{a}{r_c} \\frac{2\\pi}{3} \\rho^2 \\sum_{i,j} x_i x_j \\int_0^{r_c} r^3 g_{ij}(r) \\, dr\n$$\n我们需要找到能产生目标压力偏移 $\\Delta P_{\\mathrm{ref}}$ 的振幅 $a^\\star$，使得 $\\Delta P(a^\\star) = \\Delta P_{\\mathrm{ref}}$。求解 $a^\\star$ 得到问题中提供的公式：\n$$\na^\\star = - \\frac{r_c \\, \\Delta P_{\\mathrm{ref}}}{\\frac{2\\pi}{3} \\rho^2 \\displaystyle \\sum_{i,j \\in \\{A,B\\}} x_i x_j \\int_0^{r_c} r^3 g_{ij}(r) \\, dr }\n$$\n计算步骤如下：\n1. 对于每个测试案例 $(\\rho, T^\\star, x_A, \\Delta P_{\\mathrm{ref}})$，确定计算所需的参数。\n2. 如果 $\\Delta P_{\\mathrm{ref}}=0$，那么 $a^\\star=0$ 是不言而喻的。\n3. 定义一个从 $r_{\\min} = 0.7$ 到 $r_c = 3.0$ 的 $r$ 的数值网格。\n4. 在此网格上计算LJ势 $U_{AA}(r)$、$U_{BB}(r)$ 和 $U_{AB}(r)$。\n5. 计算相应的目标RDF，$g_{\\mathrm{target},ij}(r) = \\exp(-U_{ij}(r)/T^\\star)$。\n6. 对每种对类型，数值计算积分 $I_{ij} = \\int_{r_{\\min}}^{r_c} r^3 g_{\\mathrm{target},ij}(r) \\, dr$。积分在定义的网格 $[r_{\\min}, r_c]$ 上进行，这是一个有效的近似，因为由于强排斥作用，当 $r  r_{\\min}$ 时，$g_{ij}(r) \\approx 0$。\n7. 计算这些积分的加权和：$\\mathcal{I}_{\\Sigma} = x_A^2 I_{AA} + 2x_A x_B I_{AB} + x_B^2 I_{BB}$，其中 $x_B = 1-x_A$。\n8. 计算分母 $D = \\frac{2\\pi}{3} \\rho^2 \\mathcal{I}_{\\Sigma}$。\n9. 最后，计算 $a^\\star = - (r_c \\Delta P_{\\mathrm{ref}}) / D$。\n\n该过程将应用于所提供的三个测试案例，以找到相应的修正振幅。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the pressure correction amplitude for a binary Lennard-Jones mixture.\n    The implementation follows the analysis that the IBI procedure is trivialized\n    by the problem setup, and directly computes the correction amplitude a_star\n    based on the provided formula.\n    \"\"\"\n\n    def lj_potential(r, epsilon, sigma):\n        \"\"\"\n        Calculates the Lennard-Jones potential.\n        Args:\n            r (np.ndarray): Array of distances.\n            epsilon (float): LJ energy parameter.\n            sigma (float): LJ length parameter.\n        Returns:\n            np.ndarray: Potential values.\n        \"\"\"\n        # To avoid overflow with small r, we use a cutoff, though the grid r_min prevents this.\n        # r is guaranteed to be >= 0.7.\n        sig_over_r = sigma / r\n        sig_over_r_6 = sig_over_r**6\n        sig_over_r_12 = sig_over_r_6**2\n        return 4.0 * epsilon * (sig_over_r_12 - sig_over_r_6)\n\n    # Define the test cases from the problem statement.\n    # Format: (rho, T_star, x_A, delta_P_ref)\n    test_cases = [\n        (0.6, 1.0, 0.5, 0.4),   # Case 1\n        (0.05, 0.7, 0.2, -0.05), # Case 2\n        (0.85, 1.5, 0.9, 0.0),  # Case 3\n    ]\n\n    # Global parameters in reduced units\n    eps_AA = 1.0\n    sig_AA = 1.0\n    eps_BB = 0.5\n    sig_BB = 0.8\n\n    # Apply Lorentz-Berthelot mixing rules\n    eps_AB = math.sqrt(eps_AA * eps_BB)\n    sig_AB = (sig_AA + sig_BB) / 2.0\n\n    # Grid parameters\n    r_min = 0.7 * sig_AA\n    r_c = 3.0 * sig_AA\n    num_points = 2000\n    r_grid = np.linspace(r_min, r_c, num_points)\n\n    # Pre-calculate potentials on the grid as they are constant for all tests\n    U_AA = lj_potential(r_grid, eps_AA, sig_AA)\n    U_BB = lj_potential(r_grid, eps_BB, sig_BB)\n    U_AB = lj_potential(r_grid, eps_AB, sig_AB)\n\n    results = []\n    for case in test_cases:\n        rho, T_star, x_A, delta_P_ref = case\n        x_B = 1.0 - x_A\n\n        # Trivial case: if desired pressure correction is zero, amplitude is zero.\n        if delta_P_ref == 0.0:\n            results.append(0.0)\n            continue\n\n        # Calculate target RDFs for the current state point (T_star)\n        # g_target(r) = exp(-beta * U(r)) = exp(-U(r) / (k_B*T)) = exp(-U(r) / T_star)\n        g_target_AA = np.exp(-U_AA / T_star)\n        g_target_BB = np.exp(-U_BB / T_star)\n        g_target_AB = np.exp(-U_AB / T_star)\n\n        # Calculate the integrands for the denominator of a_star\n        integrand_AA = r_grid**3 * g_target_AA\n        integrand_BB = r_grid**3 * g_target_BB\n        integrand_AB = r_grid**3 * g_target_AB\n\n        # Perform numerical integration using the trapezoidal rule\n        I_AA = np.trapz(integrand_AA, r_grid)\n        I_BB = np.trapz(integrand_BB, r_grid)\n        I_AB = np.trapz(integrand_AB, r_grid)\n\n        # Calculate the weighted sum of integrals\n        # Sum = x_A^2 * I_AA + x_A*x_B*I_AB + x_B*x_A*I_BA + x_B^2*I_BB\n        # Since I_AB = I_BA, this simplifies to:\n        integral_sum = x_A**2 * I_AA + 2.0 * x_A * x_B * I_AB + x_B**2 * I_BB\n        \n        # Calculate the denominator of the a_star formula\n        denominator = (2.0 * np.pi / 3.0) * rho**2 * integral_sum\n\n        # Calculate a_star. The denominator should be non-zero for any physical system.\n        if denominator == 0:\n            # This case is highly unlikely given the integrand is positive\n            a_star = float('inf') if delta_P_ref != 0 else 0.0\n        else:\n            numerator = -r_c * delta_P_ref\n            a_star = numerator / denominator\n        \n        results.append(a_star)\n\n    # Format and print the final results as specified\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3438347"}, {"introduction": "实际的粗粒化建模任务往往比参数化单个势函数要复杂得多，尤其是在处理如聚合物或蛋白质等大分子体系时。这些模型通常包含多种相互作用，例如键合（如键角）和非键合（如对势）相互作用，它们共同决定了体系的整体构象和性质。本综合练习将作为一个顶峰项目，指导你设计一个混合工作流，交替使用迭代玻尔兹曼反演（IBI）和力匹配（FM）来协同优化一个包含对势和键角势的聚合物模型。此过程不仅旨在匹配局部结构，更重要的是确保如链的均方末端距等宏观统计量的准确性，从而构建一个在多个尺度上都具有高保真度的模型[@problem_id:3438326]。", "problem": "考虑一个采用约化无量纲单位的粗粒化单链聚合物模型，其中热能满足 $k_{\\mathrm{B}} T = 1$。该粗粒化表示使用两种相互作用分量：一个是在标量距离 $r$ 处的非键合粗粒化珠子之间的中心对势 $U(r)$，另一个是谐振弯曲角势 $V(\\theta) = \\tfrac{1}{2} k_{\\theta} (\\theta - \\theta_{0})^{2}$，用于控制链上连续的键角 $\\theta$。假设 $\\theta_{0} = 0$（偏好伸直构象）。\n\n该聚合物处于正则系综中，您的推导和实现必须从玻尔兹曼分布开始。对于径向分离，假设在低数密度下观测到的约化径向分布函数 $g(r)$ 可由玻尔兹曼权重和三维雅可比在有限区间 $r \\in [r_{\\min}, r_{\\max}]$ 上导出的归一化概率密度 $p_{r}(r)$ 很好地近似，即 $p_{r}(r) \\propto r^{2} \\exp\\!\\left(- U(r)\\right)$。对于弯曲角，归一化的角度分布 $p_{\\theta}(\\theta)$ 必须包含三维角度雅可比，在 $\\theta \\in [0,\\pi]$ 上满足 $p_{\\theta}(\\theta) \\propto \\sin(\\theta)\\, \\exp\\!\\left(- V(\\theta)\\right)$。\n\n您必须设计并实现一个混合参数化工作流，在每次迭代中交替进行两个更新：\n- 使用迭代玻尔兹曼反演 (Iterative Boltzmann Inversion, IBI) 更新对势 $U(r)$，该更新由 $U(r)$ 与目标径向分布函数之间的玻尔兹曼关系推导得出。使用一个标量步长 $0  \\lambda \\leq 1$ 来正则化更新。\n- 使用力匹配 (Force Matching, FM) 更新弯曲刚度 $k_{\\theta}$，该更新是作为最小二乘最优参数推导得出的，该参数能在期望上匹配目标参考弯曲力。使用一个标量混合因子 $0  \\alpha \\leq 1$ 来正则化更新。\n\n为监测聚合物链的统计特性，在每次迭代中，根据当前的 $p_{\\theta}(\\theta)$ 计算最近邻键相关性 $c = \\langle \\cos(\\theta) \\rangle$，并由此计算由 $N$ 个长度为 $b$ 的键组成的离散链的均方末端距：\n$$\n\\langle R^{2} \\rangle = b^{2} \\left[ N + 2 \\sum_{s=1}^{N-1} (N-s) c^{s} \\right].\n$$\n使用此表达式构建一个联合收敛度量，该度量聚合了径向分布、角度分布和链末端距统计的结构偏差。具体来说，定义以下三个分量：\n- 径向偏差 $D_{r} = \\left( \\int_{r_{\\min}}^{r_{\\max}} \\left[ g_{\\mathrm{model}}(r) - g_{\\mathrm{target}}(r) \\right]^{2}\\, \\mathrm{d}r \\right)^{1/2}$。\n- 角度偏差 $D_{\\theta} = \\left( \\int_{0}^{\\pi} \\left[ p_{\\theta,\\mathrm{model}}(\\theta) - p_{\\theta,\\mathrm{target}}(\\theta) \\right]^{2}\\, \\mathrm{d}\\theta \\right)^{1/2}$。\n- 相对末端距误差 $E_{R} = \\left| \\langle R^{2} \\rangle_{\\mathrm{model}} - \\langle R^{2} \\rangle_{\\mathrm{target}} \\right| / \\langle R^{2} \\rangle_{\\mathrm{target}}$。\n\n用权重 $w_{r} = w_{\\theta} = w_{R} = 1$ 形成一个联合度量 $M = w_{r} D_{r} + w_{\\theta} D_{\\theta} + w_{R} E_{R}$。提出并实现一个基于联合结构度量的停止准则：当 $D_{r}  \\varepsilon_{r}$、$D_{\\theta}  \\varepsilon_{\\theta}$ 和 $E_{R}  \\varepsilon_{R}$，并且在一个 $m$ 次迭代的滚动窗口内 $M$ 的绝对变化量低于 $\\delta_{\\min}$ 时终止；或者当达到最大迭代次数 $n_{\\max}$ 时终止。\n\n您的程序必须在 $r$ 和 $\\theta$ 的离散化网格上实现此工作流，并使用以下约化单位测试套件。对于每个测试用例，计算满足停止准则所需的迭代次数。所有物理量都是无量纲的；将迭代次数报告为整数。\n\n使用球形兰纳-琼斯 (Lennard-Jones) 目标对势\n$$\nU_{\\mathrm{LJ}}(r; \\varepsilon, \\sigma) = 4 \\varepsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6} \\right],\n$$\n其中 $\\sigma = 1$。通过归一化的 $r^{2} \\exp\\!\\left( - U_{\\mathrm{LJ}}(r; \\varepsilon_{\\mathrm{target}}, 1) \\right)$ 在 $[r_{\\min}, r_{\\max}]$ 上定义 $g_{\\mathrm{target}}(r)$，并通过归一化的 $\\sin(\\theta) \\exp\\!\\left( - \\tfrac{1}{2} k_{\\theta,\\mathrm{target}} \\theta^{2} \\right)$ 在 $[0,\\pi]$ 上定义 $p_{\\theta,\\mathrm{target}}(\\theta)$。\n\n在所有情况下，设置 $r_{\\min} = 0.8$，$r_{\\max} = 3.0$，均匀间距 $\\Delta r = 0.005$，$\\Delta \\theta = 0.001$，$b = 1$ 以及 $k_{\\mathrm{B}} T = 1$。在每次迭代中，应用IBI更新\n$$\nU_{n+1}(r) = U_{n}(r) + \\lambda \\ln\\!\\left( \\frac{g_{n}(r)}{g_{\\mathrm{target}}(r)} \\right),\n$$\n并通过对参考力 $F_{\\mathrm{target}}(\\theta) = - \\partial_{\\theta} V_{\\mathrm{target}}(\\theta) = - k_{\\theta,\\mathrm{target}} (\\theta - \\theta_{0})$ 进行最小二乘来应用 $k_{\\theta}$ 的FM更新：\n$$\nk_{\\theta}^{\\ast} = - \\frac{ \\int_{0}^{\\pi} (\\theta - \\theta_{0}) F_{\\mathrm{target}}(\\theta)\\, p_{\\theta,\\mathrm{target}}(\\theta)\\, \\mathrm{d}\\theta }{ \\int_{0}^{\\pi} (\\theta - \\theta_{0})^{2}\\, p_{\\theta,\\mathrm{target}}(\\theta)\\, \\mathrm{d}\\theta },\n\\quad\nk_{\\theta, n+1} = (1-\\alpha)\\, k_{\\theta, n} + \\alpha\\, k_{\\theta}^{\\ast}.\n$$\n在计算概率密度的比率或对数时，通过添加一个小数 $\\eta = 10^{-12}$ 来进行正则化，以避免除以零。\n\n测试套件：\n- 案例1（一般情况）：$(\\varepsilon_{\\mathrm{target}} = 1.0,\\; k_{\\theta,\\mathrm{target}} = 5.0,\\; N = 20,\\; \\lambda = 0.5,\\; \\alpha = 0.5,\\; \\varepsilon_{r} = 10^{-3},\\; \\varepsilon_{\\theta} = 10^{-3},\\; \\varepsilon_{R} = 5\\times 10^{-3},\\; m = 5,\\; \\delta_{\\min} = 10^{-4},\\; n_{\\max} = 100)$，初始猜测值为 $U_{0}(r) = 0$ 和 $k_{\\theta,0} = 0.5$。\n- 案例2（对相互作用消失的边界情况）：$(\\varepsilon_{\\mathrm{target}} = 0.0,\\; k_{\\theta,\\mathrm{target}} = 2.0,\\; N = 10,\\; \\lambda = 0.7,\\; \\alpha = 0.7,\\; \\varepsilon_{r} = 10^{-4},\\; \\varepsilon_{\\theta} = 10^{-3},\\; \\varepsilon_{R} = 10^{-3},\\; m = 5,\\; \\delta_{\\min} = 10^{-5},\\; n_{\\max} = 100)$，初始猜测值为 $U_{0}(r) = 4 \\times 2.0 \\left[ (1/r)^{12} - (1/r)^{6} \\right]$（即 $\\varepsilon = 2.0$）和 $k_{\\theta,0} = 0.2$。\n- 案例3（角度非常刚硬的边缘情况）：$(\\varepsilon_{\\mathrm{target}} = 0.5,\\; k_{\\theta,\\mathrm{target}} = 20.0,\\; N = 30,\\; \\lambda = 0.4,\\; \\alpha = 0.3,\\; \\varepsilon_{r} = 10^{-3},\\; \\varepsilon_{\\theta} = 10^{-4},\\; \\varepsilon_{R} = 10^{-3},\\; m = 5,\\; \\delta_{\\min} = 10^{-4},\\; n_{\\max} = 150)$，初始猜测值为 $U_{0}(r) = 4 \\times 1.5 \\left[ (1/r)^{12} - (1/r)^{6} \\right]$（即 $\\varepsilon = 1.5$）和 $k_{\\theta,0} = 1.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[n_{1},n_{2},n_{3}]$），其中每个 $n_{i}$ 是相应测试用例执行直到终止的整数迭代次数。不允许有其他输出。", "solution": "该问题要求设计并实现一个用于粗粒化聚合物模型的混合迭代参数化方案。目标是优化对势 $U(r)$ 和弯曲刚度常数 $k_{\\theta}$，以再现从参考系统派生的目标结构特性。该工作流结合了用于对势的迭代玻尔兹曼反演 (IBI) 和用于弯曲刚度的力匹配 (FM)。整个过程在约化无量纲单位中进行，其中热能 $k_{\\mathrm{B}} T = 1$。\n\n该方法的基础是统计力学原理，特别是玻尔兹曼分布，它将微观相互作用势与宏观可观测的概率分布联系起来。\n\n1.  **目标系统与性质定义**\n\n参考系统或“目标”系统由一组特定的势定义：兰纳-琼斯对势 $U_{\\mathrm{LJ}}(r; \\varepsilon_{\\mathrm{target}}, \\sigma)$ 和谐振角势 $V_{\\mathrm{target}}(\\theta) = \\frac{1}{2} k_{\\theta,\\mathrm{target}} (\\theta - \\theta_{0})^2$。在给定条件 $\\theta_{0}=0$ 下，这简化为 $V_{\\mathrm{target}}(\\theta) = \\frac{1}{2} k_{\\theta,\\mathrm{target}} \\theta^2$。\n\n从这些势中，我们推导出目标结构特性。目标径向分布函数 $g_{\\mathrm{target}}(r)$ 是找到两个非键合珠子相距为 $r$ 的归一化概率密度。它是从玻尔兹曼权重推导出来的，并包含了球坐标系的三维雅可比 ($4\\pi r^2$)。\n$$\ng_{\\mathrm{target}}(r) = \\frac{r^2 \\exp(-U_{\\mathrm{LJ}}(r; \\varepsilon_{\\mathrm{target}}, \\sigma=1) / (k_{\\mathrm{B}}T))}{\\int_{r_{\\min}}^{r_{\\max}} r'^2 \\exp(-U_{\\mathrm{LJ}}(r'; \\varepsilon_{\\mathrm{target}}, \\sigma=1) / (k_{\\mathrm{B}}T)) \\, \\mathrm{d}r'}\n$$\n类似地，目标键角分布 $p_{\\theta,\\mathrm{target}}(\\theta)$ 是连续三个珠子之间夹角为 $\\theta$ 的归一化概率密度。它包含了三维空间的角度雅可比 ($\\sin(\\theta)$)。\n$$\np_{\\theta,\\mathrm{target}}(\\theta) = \\frac{\\sin(\\theta) \\exp(-V_{\\mathrm{target}}(\\theta) / (k_{\\mathrm{B}}T))}{\\int_{0}^{\\pi} \\sin(\\theta') \\exp(-V_{\\mathrm{target}}(\\theta') / (k_{\\mathrm{B}}T)) \\, \\mathrm{d}\\theta'}\n$$\n根据 $p_{\\theta,\\mathrm{target}}(\\theta)$，我们计算目标键相关性 $c_{\\mathrm{target}} = \\langle \\cos(\\theta) \\rangle_{\\mathrm{target}} = \\int_0^\\pi \\cos(\\theta) p_{\\theta,\\mathrm{target}}(\\theta) \\mathrm{d}\\theta$。这反过来决定了由 $N$ 个长度为 $b$ 的键组成的链的目标均方末端距 $\\langle R^2 \\rangle_{\\mathrm{target}}$。\n$$\n\\langle R^{2} \\rangle_{\\mathrm{target}} = b^{2} \\left[ N + 2 \\sum_{s=1}^{N-1} (N-s) c_{\\mathrm{target}}^{s} \\right]\n$$\n这三个量——$g_{\\mathrm{target}}(r)$、$p_{\\theta,\\mathrm{target}}(\\theta)$ 和 $\\langle R^2 \\rangle_{\\mathrm{target}}$——构成了我们的模型必须再现的参考数据。\n\n2.  **迭代优化算法**\n\n解决方案的核心是一个迭代循环，它逐步优化模型参数 $U(r)$ 和 $k_{\\theta}$。\n从初始猜测值 $U_0(r)$ 和 $k_{\\theta,0}$ 开始，算法通过由 $n$ 索引的迭代进行。在每次迭代 $n$ 中，我们有一个由 $(U_n, k_{\\theta,n})$ 定义的模型。\n\n**用于 $U(r)$ 的迭代玻尔兹曼反演 (IBI) 更新**：\nIBI 方法根据当前模型的径向分布函数 $g_n(r)$ 与目标 $g_{\\mathrm{target}}(r)$ 之间的差异来优化势。更新规则是通过反转玻尔兹曼关系 $g(r) \\propto \\exp(-U(r))$ 并向势中添加一个校正项得出的。在 $k_{\\mathrm{B}} T = 1$ 的条件下，下一迭代势 $U_{n+1}(r)$ 的更新为：\n$$\nU_{n+1}(r) = U_{n}(r) + \\lambda \\ln\\left( \\frac{g_{n}(r)}{g_{\\mathrm{target}}(r)} \\right)\n$$\n这里，$g_n(r)$ 是从 $U_n(r)$ 生成的径向分布函数。参数 $0  \\lambda \\le 1$ 是一个步长或阻尼因子，它控制更新的幅度，提高稳定性并防止过度校正。为避免分布接近零时出现数值问题，该比率被正则化为 $\\ln\\left( (g_{n}(r) + \\eta) / (g_{\\mathrm{target}}(r) + \\eta) \\right)$，其中 $\\eta$ 是一个小常数。\n\n**用于 $k_{\\theta}$ 的力匹配 (FM) 更新**：\n力匹配旨在以最小二乘的方式找到能最好地再现一组参考力的参数。对于谐振势 $V(\\theta) = \\frac{1}{2} k_{\\theta} (\\theta - \\theta_0)^2$，相应的力（广义力矩）是 $F(\\theta) = - \\partial V / \\partial \\theta = -k_{\\theta}(\\theta - \\theta_0)$。问题给出了最小二乘最优刚度 $k_{\\theta}^{\\ast}$：\n$$\nk_{\\theta}^{\\ast} = - \\frac{ \\int_{0}^{\\pi} (\\theta - \\theta_{0}) F_{\\mathrm{target}}(\\theta)\\, p_{\\theta,\\mathrm{target}}(\\theta)\\, \\mathrm{d}\\theta }{ \\int_{0}^{\\pi} (\\theta - \\theta_{0})^{2}\\, p_{\\theta,\\mathrm{target}}(\\theta)\\, \\mathrm{d}\\theta }\n$$\n关键在于，将目标力 $F_{\\mathrm{target}}(\\theta) = -k_{\\theta,\\mathrm{target}}(\\theta-\\theta_0)$ 代入此表达式会导致显著简化：\n$$\nk_{\\theta}^{\\ast} = - \\frac{ \\int (\\theta - \\theta_{0}) [-k_{\\theta,\\mathrm{target}}(\\theta-\\theta_0)]\\, p_{\\theta,\\mathrm{target}}(\\theta)\\, \\mathrm{d}\\theta }{ \\int (\\theta - \\theta_{0})^{2}\\, p_{\\theta,\\mathrm{target}}(\\theta)\\, \\mathrm{d}\\theta } = k_{\\theta,\\mathrm{target}} \\frac{ \\int (\\theta - \\theta_{0})^{2}\\, p_{\\theta,\\mathrm{target}}(\\theta)\\, \\mathrm{d}\\theta }{ \\int (\\theta - \\theta_{0})^{2}\\, p_{\\theta,\\mathrm{target}}(\\theta)\\, \\mathrm{d}\\theta } = k_{\\theta,\\mathrm{target}}\n$$\n这种简化之所以发生，是因为期望值是相对于目标分布本身计算的。因此，最优参数就是目标参数本身。$k_{\\theta}$ 的更新规则变成向此已知目标值的指数松弛：\n$$\nk_{\\theta, n+1} = (1-\\alpha)\\, k_{\\theta, n} + \\alpha\\, k_{\\theta}^{\\ast} = (1-\\alpha)\\, k_{\\theta, n} + \\alpha\\, k_{\\theta, \\mathrm{target}}\n$$\n混合因子 $0  \\alpha \\le 1$ 控制此松弛的速率。\n\n3.  **收敛监测与终止**\n\n在每次迭代 $n$ 中，我们使用三个定量指标来评估当前模型 $(U_n, k_{\\theta,n})$ 的质量：\n- 径向偏差：$D_{r} = \\left( \\int_{r_{\\min}}^{r_{\\max}} \\left[ g_{n}(r) - g_{\\mathrm{target}}(r) \\right]^{2}\\, \\mathrm{d}r \\right)^{1/2}$\n- 角度偏差：$D_{\\theta} = \\left( \\int_{0}^{\\pi} \\left[ p_{\\theta,n}(\\theta) - p_{\\theta,\\mathrm{target}}(\\theta) \\right]^{2}\\, \\mathrm{d}\\theta \\right)^{1/2}$\n- 相对末端距误差：$E_{R} = \\left| \\langle R^{2} \\rangle_{n} - \\langle R^{2} \\rangle_{\\mathrm{target}} \\right| / \\langle R^{2} \\rangle_{\\mathrm{target}}$\n\n这些指标被组合成一个单一的联合度量 $M = D_r + D_\\theta + E_R$（使用单位权重）。迭代过程基于一个复合准则终止：如果 (1) 所有三个单独的指标都低于各自的阈值（$D_r  \\varepsilon_r$，$D_\\theta  \\varepsilon_\\theta$，$E_R  \\varepsilon_R$），并且 (2) 优化过程已停滞，即在 $m$ 次迭代的滚动窗口内联合度量 $M$ 的绝对变化小于一个最小值 $\\delta_{\\min}$，则宣布收敛。如果达到最大迭代次数 $n_{\\max}$，过程也会停止。\n\n4.  **数值策略**\n\n连续函数和积分通过数值方法处理。$r \\in [r_{\\min}, r_{\\max}]$ 和 $\\theta \\in [0, \\pi]$ 的域被离散化为均匀网格。所有积分随后使用数值积分（特别是梯形法则）来计算，这适用于精细间隔的网格。$\\langle R^2 \\rangle$ 的表达式通过直接求和计算。整个算法以循环形式实现，对每个测试用例，它都迭代地优化势并检查收敛，最后报告所需的迭代次数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import trapezoid\n\ndef U_lj(r, eps, sigma=1.0):\n    \"\"\"Calculates the Lennard-Jones potential.\"\"\"\n    # The grid starts at r_min > 0, so r=0 is not a concern.\n    inv_r = sigma / r\n    inv_r6 = inv_r**6\n    inv_r12 = inv_r6**2\n    return 4.0 * eps * (inv_r12 - inv_r6)\n\ndef V_harmonic(theta, k, theta0=0.0):\n    \"\"\"Calculates the harmonic angle potential.\"\"\"\n    return 0.5 * k * (theta - theta0)**2\n\ndef calculate_R2(N, b, c):\n    \"\"\"\n    Calculates the mean-squared end-to-end distance for a discrete chain.", "id": "3438326"}]}