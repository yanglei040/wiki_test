{"hands_on_practices": [{"introduction": "在应用内聚区模型（CZM）时，一个至关重要的初始步骤是为特定的材料界面确定其牵引力-分离本构关系（TSL）的参数。本练习 [@problem_id:3439023] 演示了一个常见的工作流程：将一个解析的TSL模型与从更底层的模拟（例如原子模拟）中获得的力-位移数据进行拟合。这项实践将帮助你掌握连接不同尺度、并建立一个具有预测能力的连续介质模型的关键技能。", "problem": "给定一个界面的原子尺度计算牵引力-分离位移数据，该界面被假设遵循指数形式的牵引力-分离位移法则 (TSL)。该 TSL 的形式为 $T(\\delta)=\\sigma_{\\max}(\\delta/\\delta_0)\\exp(1-\\delta/\\delta_0)$，其中 $T(\\delta)$ 是分离位移为 $\\delta$ 时的牵引力，$\\sigma_{\\max}$ 是峰值牵引力，$\\delta_0$ 是牵引力达到最大值时的分离位移。从分离功（断裂能）$G_c$ 是牵引力-分离位移曲线下的面积这一定义出发，您的任务是通过最小化测量牵引力与 TSL 预测值之间的残差平方和，确定最能拟合所提供数据的 $G_c$ 和 $\\delta_0$。\n\n使用以下基本原则：\n- 分离功（断裂能）定义为 $G_c=\\int_0^{\\infty}T(\\delta)\\,\\mathrm{d}\\delta$。\n- 最佳拟合参数使目标函数 $\\sum_i\\left(T_i - T(\\delta_i;\\sigma_{\\max},\\delta_0)\\right)^2$ 最小化，其中 $T_i$ 是测量的牵引力，$\\delta_i$ 是测量的分离位移。\n\n为保证数值一致性，分离位移必须以纳米（nanometers）表示，牵引力必须以吉帕（gigapascals）表示。计算 $G_c$ 时，单位应为焦耳/平方米（joules per square meter）。在根据拟合参数计算 $G_c$ 时，通过将 $\\sigma_{\\max}$ 从吉帕转换为帕斯卡（pascals），并将 $\\delta_0$ 从纳米转换为米（meters），确保单位一致性。\n\n您必须实现一个程序，对每个测试用例执行以下步骤：\n1. 通过带约束（$\\sigma_{\\max}>0$ 和 $\\delta_0>0$）的非线性最小二乘法，将参数 $\\sigma_{\\max}$ 和 $\\delta_0$ 拟合到给定的牵引力-分离位移数据集。\n2. 使用拟合得到的参数，通过对 $T(\\delta)$ 在 $\\delta$ 从零到无穷大的区间上进行积分来计算 $G_c$。\n3. 输出拟合得到的 $\\delta_0$（单位：纳米）和计算出的 $G_c$（单位：焦耳/平方米）。\n\n测试套件：\n您必须使用下面定义的合成数据集。在每种情况下，测量数据 $\\{(\\delta_i, T_i)\\}$都是通过一个具有已知底层参数集的模型和一个模拟原子尺度噪声的确定性非随机扰动来确定性地生成的。对于每种情况，分离点 $\\delta_i$ 均按规定给出，真实牵引力为 $T_{\\text{true}}(\\delta_i)=\\sigma_{\\max}(\\delta_i/\\delta_0)\\exp(1-\\delta_i/\\delta_0)$（使用给定的真实 $\\sigma_{\\max}$ 和真实 $\\delta_0$），测量牵引力为 $T_i=T_{\\text{true}}(\\delta_i)+\\Delta T(\\delta_i)$，其中确定性扰动为\n$$\\Delta T(\\delta)=\\alpha\\,\\sigma_{\\max}\\left(\\frac{\\delta}{\\delta_0}\\right)\\exp\\!\\left(-\\frac{\\delta}{\\delta_0}\\right)\\sin\\!\\left(\\beta\\,\\frac{\\delta}{\\delta_0}\\right),$$\n其中 $\\alpha$ 和 $\\beta$ 是特定于案例的常数。所有牵引力的单位均为吉帕，分离位移的单位均为纳米。\n\n- 案例 1 (一般情况):\n  - 真实参数：$\\sigma_{\\max}=4.0$ 吉帕，$\\delta_0=0.20$ 纳米。\n  - 采样：$\\delta_i=i\\times 0.05$ 纳米，其中 $i=0,1,2,\\dots,24$ (即范围 $0$ 至 $1.20$ 纳米)。\n  - 扰动常数：$\\alpha=0.05$，$\\beta=3.0$。\n\n- 案例 2 (尖锐黏聚响应, 小 $\\delta_0$):\n  - 真实参数：$\\sigma_{\\max}=9.0$ 吉帕，$\\delta_0=0.05$ 纳米。\n  - 采样：$\\delta_i=i\\times 0.01$ 纳米，其中 $i=0,1,2,\\dots,50$ (即范围 $0$ 至 $0.50$ 纳米)。\n  - 扰动常数：$\\alpha=0.03$，$\\beta=4.0$。\n\n- 案例 3 (宽缓黏聚响应, 大 $\\delta_0$):\n  - 真实参数：$\\sigma_{\\max}=1.8$ 吉帕，$\\delta_0=0.60$ 纳米。\n  - 采样：$\\delta_i=i\\times 0.10$ 纳米，其中 $i=0,1,2,\\dots,30$ (即范围 $0$ 至 $3.00$ 纳米)。\n  - 扰动常数：$\\alpha=0.04$，$\\beta=2.5$。\n\n算法要求：\n- 使用带有边界 $\\sigma_{\\max}>0$ 和 $\\delta_0>0$ 的约束非线性最小二乘法来拟合每个数据集的模型参数。\n- 通过使用 $\\sigma_{\\max}^{(0)}=\\max_i T_i$ 和 $\\delta_0^{(0)}=\\delta_{k}$（其中索引 $k$ 满足 $T_k=\\max_i T_i$）来估计初始猜测值。\n- 使用拟合参数，通过对 $T(\\delta)$ 在 $\\delta\\in[0,\\infty)$ 上积分来计算 $G_c$。\n\n单位与最终输出：\n- 返回 $\\delta_0$（单位：纳米）和 $G_c$（单位：焦耳/平方米）。\n- 角度（如有）以弧度表示（本问题不涉及角度）。\n- 您的程序的最终输出必须是单行文本，包含一个逗号分隔的 Python 风格列表，其中扁平化了所有案例的结果，顺序为案例 1、案例 2、案例 3。每个案例贡献其拟合的 $\\delta_0$（纳米）和其后的 $G_c$（焦耳/平方米）。例如，输出格式为 $[\\delta_{0,1},G_{c,1},\\delta_{0,2},G_{c,2},\\delta_{0,3},G_{c,3}]$。列表中的每一项都必须是浮点数。为了便于阅读，您可以四舍五入到合理的小數位數，但数值必须与拟合参数和单位转换保持一致。", "solution": "该问题被认为是有效的，因为它科学地基于断裂力学中的黏性区模型原理，问题陈述清晰且定义明确 (well-posed)，并且为获得唯一解提供了所有必要的数据和约束。\n\n解答过程分三个阶段：首先，对给定的牵引力-分离位移法则 (TSL)进行解析处理；其次，推导断裂能 $G_c$；第三，设计用于拟合参数和计算所需量的数值算法。\n\n1.  **牵引力-分离位移法则 (TSL) 的解析处理**\n\n假设的指数 TSL 由以下函数给出：\n$$T(\\delta) = \\sigma_{\\max} \\left(\\frac{\\delta}{\\delta_0}\\right) \\exp\\left(1 - \\frac{\\delta}{\\delta_0}\\right)$$\n其中，$T(\\delta)$ 是给定分离位移 $\\delta$ 时的牵引力，$\\sigma_{\\max}$ 是峰值牵引力（黏聚强度），$\\delta_0$ 是分离位移的特征长度尺度。问题陈述指出 $\\delta_0$ 是牵引力达到最大值时的分离位移。这可以通过找到 $T(\\delta)$ 关于 $\\delta$ 的极值来验证。我们计算导数 $\\frac{\\mathrm{d}T}{\\mathrm{d}\\delta}$ 并将其设为零：\n$$ \\frac{\\mathrm{d}T}{\\mathrm{d}\\delta} = \\frac{\\mathrm{d}}{\\mathrm{d}\\delta} \\left[ \\sigma_{\\max} \\frac{\\delta}{\\delta_0} e^{1} e^{-\\delta/\\delta_0} \\right] $$\n使用微分乘法法则 $(uv)' = u'v + uv'$，其中 $u = \\delta$ 且 $v = e^{-\\delta/\\delta_0}$：\n$$ \\frac{\\mathrm{d}T}{\\mathrm{d}\\delta} = \\frac{\\sigma_{\\max} e}{\\delta_0} \\left[ (1) \\cdot e^{-\\delta/\\delta_0} + \\delta \\cdot \\left(-\\frac{1}{\\delta_0}\\right) e^{-\\delta/\\delta_0} \\right] $$\n$$ \\frac{\\mathrm{d}T}{\\mathrm{d}\\delta} = \\frac{\\sigma_{\\max} e}{\\delta_0} e^{-\\delta/\\delta_0} \\left( 1 - \\frac{\\delta}{\\delta_0} \\right) $$\n将导数设为零以找到临界点，需要 $1 - \\frac{\\delta}{\\delta_0} = 0$，因为对于有限且为正的 $\\delta_0$ 和 $\\sigma_{\\max}$，其他项不为零。这得出：\n$$ \\delta = \\delta_0 $$\n将 $\\delta = \\delta_0$ 代回原始 TSL 方程，验证了在该分离位移处的牵引力确实是 $\\sigma_{\\max}$：\n$$ T(\\delta_0) = \\sigma_{\\max} \\left(\\frac{\\delta_0}{\\delta_0}\\right) \\exp\\left(1 - \\frac{\\delta_0}{\\delta_0}\\right) = \\sigma_{\\max}(1)\\exp(0) = \\sigma_{\\max} $$\n这证实了问题中定义的参数 $\\sigma_{\\max}$ 和 $\\delta_0$ 的物理诠釋。\n\n2.  **断裂能 $G_c$ 的推导**\n\n分离功，或称断裂能 $G_c$，定义为分离界面所需的单位面积总能量，即牵引力-分离位移曲线下从零到无穷大分离位移的面积。用数学表示为：\n$$ G_c = \\int_0^{\\infty} T(\\delta) \\, \\mathrm{d}\\delta $$\n代入 $T(\\delta)$ 的表达式：\n$$ G_c = \\int_0^{\\infty} \\sigma_{\\max} \\left(\\frac{\\delta}{\\delta_0}\\right) \\exp\\left(1 - \\frac{\\delta}{\\delta_0}\\right) \\, \\mathrm{d}\\delta $$\n我们可以通过提取常数来简化这个积分：\n$$ G_c = \\frac{\\sigma_{\\max} e}{\\delta_0} \\int_0^{\\infty} \\delta \\exp\\left(-\\frac{\\delta}{\\delta_0}\\right) \\, \\mathrm{d}\\delta $$\n我们使用无量纲变量 $u = \\delta / \\delta_0$ 进行代换。这意味着 $\\delta = u \\delta_0$ 且 $\\mathrm{d}\\delta = \\delta_0 \\, \\mathrm{d}u$。积分的上下限保持不变，从 $u=0$ 到 $u=\\infty$。\n$$ G_c = \\frac{\\sigma_{\\max} e}{\\delta_0} \\int_0^{\\infty} (u \\delta_0) \\exp(-u) \\, (\\delta_0 \\, \\mathrm{d}u) $$\n$$ G_c = \\sigma_{\\max} e \\delta_0 \\int_0^{\\infty} u \\exp(-u) \\, \\mathrm{d}u $$\n积分 $\\int_0^{\\infty} u \\exp(-u) \\, \\mathrm{d}u$ 是与伽马函数 $\\Gamma(z) = \\int_0^{\\infty} t^{z-1} e^{-t} \\, \\mathrm{d}t$ 相关的标准形式。对于我们的情况，$z-1=1$，所以 $z=2$。因此，积分的计算结果为 $\\Gamma(2) = 1! = 1$。或者，使用分部积分法：\n$$ \\int u e^{-u} \\, \\mathrm{d}u = u(-e^{-u}) - \\int (-e^{-u}) \\, \\mathrm{d}u = -u e^{-u} - e^{-u} $$\n$$ \\int_0^{\\infty} u e^{-u} \\, \\mathrm{d}u = \\left[ -e^{-u}(u+1) \\right]_0^{\\infty} = \\lim_{u\\to\\infty}(-e^{-u}(u+1)) - (-e^0(0+1)) = 0 - (-1) = 1 $$\n因此，断裂能由一个非常简单的表达式给出：\n$$ G_c = e \\sigma_{\\max} \\delta_0 $$\n其中 $e$ 是欧拉数，约等于 $2.71828$。\n\n单位一致性至关重要。问题指定 $\\sigma_{\\max}$ 将以吉帕（$ \\text{GPa} $）为单位进行拟合，$\\delta_0$ 以纳米（$ \\text{nm} $）为单位，并要求 $G_c$ 以焦耳/平方米（$ \\text{J/m}^2 $）为单位。我们来检查一下单位：\n$$ 1 \\, \\text{J/m}^2 = 1 \\, \\text{N/m} = 1 \\, \\text{Pa} \\cdot \\text{m} $$\n将拟合参数转换为国际单位制基本单位：\n$$ \\sigma_{\\max} [\\text{Pa}] = \\sigma_{\\max, \\text{fit}}[\\text{GPa}] \\times 10^9 $$\n$$ \\delta_0 [\\text{m}] = \\delta_{0, \\text{fit}}[\\text{nm}] \\times 10^{-9} $$\n得到的 $G_c$ 是：\n$$ G_c [\\text{J/m}^2] = e \\cdot (\\sigma_{\\max, \\text{fit}}[\\text{GPa}] \\times 10^9) \\cdot (\\delta_{0, \\text{fit}}[\\text{nm}] \\times 10^{-9}) $$\n$$ G_c [\\text{J/m}^2] = e \\cdot \\sigma_{\\max, \\text{fit}}[\\text{GPa}] \\cdot \\delta_{0, \\text{fit}}[\\text{nm}] $$\n方便的是，转换因子 $10^9$ 和 $10^{-9}$ 相互抵消。因此，我们可以直接将以 GPa 为单位的 $\\sigma_{\\max}$ 拟合值乘以以 nm 为单位的 $\\delta_0$ 拟合值，再乘以 $e$，从而得到以 J/m² 为单位的 $G_c$。\n\n3.  **数值实现设计**\n\n每个测试用例的算法流程如下：\na. **数据生成**：首先，我们必须为每个测试用例合成“测量”的牵引力-分离位移数据 $\\{(\\delta_i, T_i)\\}$。分离点 $\\delta_i$ 是给定的。牵引力值 $T_i$ 使用提供的公式计算，该公式结合了真实的 TSL 和一个确定性扰动：\n$$ T_i = \\sigma_{\\max, \\text{true}}\\left(\\frac{\\delta_i}{\\delta_{0, \\text{true}}}\\right)e^{1-\\frac{\\delta_i}{\\delta_{0, \\text{true}}}} + \\alpha\\,\\sigma_{\\max, \\text{true}}\\left(\\frac{\\delta_i}{\\delta_{0, \\text{true}}}\\right)e^{-\\frac{\\delta_i}{\\delta_{0, \\text{true}}}}\\sin\\left(\\beta\\,\\frac{\\delta_i}{\\delta_{0, \\text{true}}}\\right) $$\n\nb. **初始猜测值估计**：按照要求，为优化程序制定一个初始猜测值。我们找到测量牵引力数据的最大值 $T_{\\max} = \\max_i T_i$。黏聚强度的初始猜测值为 $\\sigma_{\\max}^{(0)} = T_{\\max}$。特征分离位移的初始猜测值 $\\delta_0^{(0)}$ 是该最大牵引力出现时的分离位移值 $\\delta_k$，即 $T_k = T_{\\max}$。\n\nc. **约束非线性最小二乘拟合**：任务的核心是找到使残差平方和 $S$ 最小化的参数 $(\\sigma_{\\max}, \\delta_0)$：\n$$ S(\\sigma_{\\max}, \\delta_0) = \\sum_i \\left(T_i - T(\\delta_i; \\sigma_{\\max}, \\delta_0)\\right)^2 $$\n这是一个非线性最小二乘问题。我们将使用 `scipy.optimize` 库中的 `curve_fit` 函数，该函数专为此目的设计。调用该函数时，将传入 TSL 模型函数、数据 $(\\delta_i, T_i)$、初始猜测值 $(\\sigma_{\\max}^{(0)}, \\delta_0^{(0)})$以及约束 $\\sigma_{\\max} > 0$ 和 $\\delta_0 > 0$。这些约束通过 `bounds` 参数施加，将下界设置为 $[0, 0]$，上界设置为 $[\\infty, \\infty]$。\n\nd. **最终计算与输出**：一旦优化过程收敛并返回最佳拟合参数 $(\\sigma_{\\max, \\text{fit}}, \\delta_{0, \\text{fit}})$，我们使用第 2 步推导出的解析公式来计算断裂能 $G_{c, \\text{fit}} = e \\cdot \\sigma_{\\max, \\text{fit}} \\cdot \\delta_{0, \\text{fit}}$。每个案例的最终输出将是值对 $(\\delta_{0, \\text{fit}}, G_{c, \\text{fit}})$，并按规定格式输出。\n\n此过程将黏性区模型的基本理论与标准数值优化技术相结合，以解决所述问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Fits an exponential TSL to synthetic data and calculates fracture energy.\n    \"\"\"\n    # Euler's number, np.e is an alias for np.exp(1)\n    E_CONST = np.e\n\n    # Define the Traction-Separation Law (TSL) model function\n    def tsl_model(delta, sigma_max, delta_0):\n        \"\"\"\n        Exponential Traction-Separation Law.\n        T(delta) = sigma_max * (delta/delta_0) * exp(1 - delta/delta_0)\n        \"\"\"\n        # Use np.errstate to prevent warnings for delta=0 or delta_0 near zero during iteration\n        with np.errstate(divide='ignore', invalid='ignore'):\n            ratio = delta / delta_0\n            traction = sigma_max * ratio * np.exp(1.0 - ratio)\n        # For delta=0, ratio is 0, so traction is 0.\n        # np.nan_to_num handles any NaNs that might arise if delta_0 is zero.\n        return np.nan_to_num(traction)\n\n    # Define the function to generate synthetic data for each test case\n    def generate_data(true_sigma_max, true_delta_0, delta_points, alpha, beta):\n        \"\"\"\n        Generates synthetic traction-separation data with a deterministic perturbation.\n        \"\"\"\n        # Calculate the true traction based on the TSL model\n        t_true = tsl_model(delta_points, true_sigma_max, true_delta_0)\n        \n        # Calculate the deterministic perturbation\n        with np.errstate(divide='ignore', invalid='ignore'):\n            ratio = delta_points / true_delta_0\n            delta_T = alpha * true_sigma_max * ratio * np.exp(-ratio) * np.sin(beta * ratio)\n        delta_T = np.nan_to_num(delta_T)\n\n        # Measured traction is the sum of true traction and perturbation\n        t_measured = t_true + delta_T\n        \n        # Ensure traction at zero separation is exactly zero\n        if delta_points.size > 0 and delta_points[0] == 0.0:\n            t_measured[0] = 0.0\n            \n        return delta_points, t_measured\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            # Case 1: General case\n            'true_params': {'sigma_max': 4.0, 'delta_0': 0.20},\n            'sampling': {'points': np.arange(0, 25) * 0.05},\n            'perturbation': {'alpha': 0.05, 'beta': 3.0}\n        },\n        {\n            # Case 2: Sharp cohesive response\n            'true_params': {'sigma_max': 9.0, 'delta_0': 0.05},\n            'sampling': {'points': np.arange(0, 51) * 0.01},\n            'perturbation': {'alpha': 0.03, 'beta': 4.0}\n        },\n        {\n            # Case 3: Broad cohesive response\n            'true_params': {'sigma_max': 1.8, 'delta_0': 0.60},\n            'sampling': {'points': np.arange(0, 31) * 0.10},\n            'perturbation': {'alpha': 0.04, 'beta': 2.5}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Generate the synthetic dataset for the current case\n        delta_data, traction_data = generate_data(\n            case['true_params']['sigma_max'],\n            case['true_params']['delta_0'],\n            case['sampling']['points'],\n            case['perturbation']['alpha'],\n            case['perturbation']['beta']\n        )\n\n        # Step 2: Estimate an initial guess for the parameters\n        if len(traction_data) > 0 and np.max(traction_data) > 0:\n            sigma_max_guess = np.max(traction_data)\n            delta_0_guess_index = np.argmax(traction_data)\n            delta_0_guess = delta_data[delta_0_guess_index]\n            # Ensure the initial guess for delta_0 is not zero\n            if delta_0_guess == 0.0:\n                delta_0_guess = 1e-6 # A small positive number\n        else:\n            # Fallback in case of empty or all-zero data\n            sigma_max_guess = 1.0\n            delta_0_guess = 0.1\n        \n        p0 = [sigma_max_guess, delta_0_guess]\n\n        # Step 3: Fit the TSL model to the data via constrained nonlinear least squares\n        # Constraints: sigma_max > 0 and delta_0 > 0\n        bounds = ([0, 0], [np.inf, np.inf])\n        \n        try:\n            p_opt, _ = curve_fit(tsl_model, delta_data, traction_data, p0=p0, bounds=bounds)\n            sigma_max_fit, delta_0_fit = p_opt\n        except RuntimeError:\n            # This should not happen with the provided data, but is good practice\n            sigma_max_fit, delta_0_fit = np.nan, np.nan\n\n        # Step 4: Compute the work of separation (fracture energy) Gc\n        # Gc [J/m^2] = e * sigma_max [GPa] * delta_0 [nm]\n        gc_fit = E_CONST * sigma_max_fit * delta_0_fit\n\n        # Append the fitted delta_0 (in nm) and computed Gc (in J/m^2) to the results list\n        results.append(delta_0_fit)\n        results.append(gc_fit)\n\n    # Final print statement in the exact required format\n    # Using a fixed number of decimal places for consistent output\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n```", "id": "3439023"}, {"introduction": "当我们拥有一个参数化的TSL后，下一步便是在数值模拟框架（如有限元法）中实现它。本实践练习 [@problem_id:3439060] 深入探讨了内聚力单元的核心机制，展示了如何根据节点位移计算内聚区的牵引力，并组装相应的单元内力向量。掌握这一过程对于开发或理解CZM模拟代码至关重要。", "problem": "给定一个二维界面单元，其包含四个节点，节点 $1$ 和 $2$ 位于底面，节点 $3$ 和 $4$ 位于顶面。每个节点在全局坐标系中有两个位移分量。该单元用于通过内聚区方法模拟断裂，其中采用非耦合的双线性牵引-分离法则。每个积分点（高斯点）处的局部界面坐标系由一个单位切向向量和一个单位法向向量定义。使用虚功原理和标准的等参插值，从第一性原理推导如何从位移跳跃计算高斯点处的法向和切向牵引力，并组装作用于节点自由度上的单元内力向量。\n\n假设和建模背景：\n- 内聚响应在法向和切向之间是非耦合的。\n- 在法向方向，只有拉伸分离会产生内聚牵引力；压缩分离不产生内聚牵引力。\n- 切向响应相对于方向是对称的，遵循切向分离的符号。\n- 牵引-分离法则是双线性的：一个初始线性弹性段，直至达到由初始刚度和阈值分离定义的峰值，随后是线性软化，在临界分离处牵引力减为零。\n- 平面外维度的厚度通过一个显式的厚度参数进行单位缩放。\n\n推导中使用的基本原理：\n- 界面的虚功原理，该原理使用形函数将牵引力向量分布到节点自由度上。\n- 沿界面的双节点线段的线性形函数，独立应用于顶面和底面。\n- 沿界面单元自然坐标的标准两点高斯积分。\n- 高斯点处局部切向和法向向量的正交性和归一化。\n\n编程任务：\n实现一个完整的程序，对以下每个测试用例执行以下步骤：\n1. 沿界面坐标 $s \\in [-1,1]$ 使用线性形函数在每个高斯点插值底面和顶面的位移。\n2. 计算每个高斯点处的位移跳跃，即插值后的顶面和底面位移之差。\n3. 将位移跳跃投影到该高斯点的局部坐标系上，以获得法向和切向分离。\n4. 使用给定的参数（初始刚度、峰值牵引力的阈值分离以及牵引力减为零时的临界分离）和非耦合的双线性牵引-分离法则，计算每个高斯点处的法向和切向牵引力。在法向方向，当分离为非正值时，将牵引力设为零。\n5. 通过将局部法向和切向牵引力与局部坐标系向量相结合，在每个高斯点处构成全局牵引力向量。\n6. 通过将高斯点牵引力贡献分配到四个节点上来组装单元内力向量，并使用适当的符号：底面节点为负，顶面节点为正，并由形函数、高斯权重、映射的雅可比行列式和厚度加权。\n7. 生成最终的单元力向量，其形式为按顺序 $[f_{x1}, f_{y1}, f_{x2}, f_{y2}, f_{x3}, f_{y3}, f_{x4}, f_{y4}]$ 排列的扁平化列表。\n\n使用以下数值积分方案：\n- 两个高斯点，横坐标为 $s_1 = -1/\\sqrt{3}$ 和 $s_2 = +1/\\sqrt{3}$，权重为 $w_1 = w_2 = 1$。\n- 线性形函数 $N_1(s) = (1 - s)/2$ 和 $N_2(s) = (1 + s)/2$。\n- 沿界面的线性映射的雅可比矩阵为 $J = L/2$，其中 $L$ 是单元的物理长度。\n\n单位：\n- 位移单位为米。\n- 初始刚度单位为帕斯卡/米。\n- 分离单位为米。\n- 牵引力单位为帕斯卡。\n- 力必须以牛顿表示。在数值积分中，使用平面外厚度参数 $b$（单位：米）和界面长度 $L$（单位：米），通过面积等于 $b \\times L$ 来将牵引力缩放为力。\n\n测试套件：\n对于所有测试用例，均使用上述积分方案。最终输出必须是以牛顿表示的单元力向量，除了自然的浮点数表示外，指令不施加任何舍入。程序必须硬编码以下四个测试用例：\n\n- 测试用例 1（弹性范围内的中等拉伸和剪切）：\n  - $u_1 = [0.0, 0.0]$, $u_2 = [0.0, 0.0]$, $u_3 = [1.0\\times 10^{-6}, 2.0\\times 10^{-6}]$, $u_4 = [1.5\\times 10^{-6}, 2.5\\times 10^{-6}]$。\n  - 两个高斯点的局部坐标系：切向向量 $t^{(1)} = [1.0, 0.0]$, $t^{(2)} = [1.0, 0.0]$；法向向量 $n^{(1)} = [0.0, 1.0]$, $n^{(2)} = [0.0, 1.0]$。\n  - 参数：$K_n = 1.0\\times 10^{9}$, $K_t = 5.0\\times 10^{8}$, $\\delta_{0n} = 2.0\\times 10^{-5}$, $\\delta_{fn} = 6.0\\times 10^{-5}$, $\\delta_{0t} = 2.5\\times 10^{-5}$, $\\delta_{ft} = 7.0\\times 10^{-5}$。\n  - 几何：$L = 1.0\\times 10^{-1}$, $b = 1.0\\times 10^{-2}$。\n\n- 测试用例 2（法向压缩伴随小剪切）：\n  - $u_1 = [0.0, 0.0]$, $u_2 = [0.0, 0.0]$, $u_3 = [1.0\\times 10^{-6}, -3.0\\times 10^{-5}]$, $u_4 = [2.0\\times 10^{-6}, -4.0\\times 10^{-5}]$。\n  - 两个高斯点的局部坐标系：$t^{(1)} = [1.0, 0.0]$, $t^{(2)} = [1.0, 0.0]$；$n^{(1)} = [0.0, 1.0]$, $n^{(2)} = [0.0, 1.0]$。\n  - 参数：$K_n = 1.0\\times 10^{9}$, $K_t = 5.0\\times 10^{8}$, $\\delta_{0n} = 2.0\\times 10^{-5}$, $\\delta_{fn} = 6.0\\times 10^{-5}$, $\\delta_{0t} = 2.5\\times 10^{-5}$, $\\delta_{ft} = 7.0\\times 10^{-5}$。\n  - 几何：$L = 1.0\\times 10^{-1}$, $b = 1.0\\times 10^{-2}$。\n\n- 测试用例 3（切向软化伴随小法向张开）：\n  - $u_1 = [0.0, 0.0]$, $u_2 = [0.0, 0.0]$, $u_3 = [3.0\\times 10^{-5}, 1.0\\times 10^{-6}]$, $u_4 = [4.0\\times 10^{-5}, 1.0\\times 10^{-6}]$。\n  - 两个高斯点的局部坐标系：$t^{(1)} = [1.0, 0.0]$, $t^{(2)} = [1.0, 0.0]$；$n^{(1)} = [0.0, 1.0]$, $n^{(2)} = [0.0, 1.0]$。\n  - 参数：$K_n = 1.0\\times 10^{9}$, $K_t = 5.0\\times 10^{8}$, $\\delta_{0n} = 2.0\\times 10^{-5}$, $\\delta_{fn} = 6.0\\times 10^{-5}$, $\\delta_{0t} = 2.5\\times 10^{-5}$, $\\delta_{ft} = 7.0\\times 10^{-5}$。\n  - 几何：$L = 1.0\\times 10^{-1}$, $b = 1.0\\times 10^{-2}$。\n\n- 测试用例 4（旋转坐标系，法向超出破坏，切向处于软化阶段）：\n  - 局部坐标系旋转角度为 $\\theta = \\pi/6$ 弧度，因此 $t = [\\cos(\\theta), \\sin(\\theta)]$ 且 $n = [-\\sin(\\theta), \\cos(\\theta)]$；在两个高斯点使用相同的 $t$ 和 $n$。\n  - 数值上，$t = [0.8660254037844386, 0.5]$ 且 $n = [-0.5, 0.8660254037844386]$。\n  - 顶部节点位移经过对齐以产生较大的法向张开和中等剪切：$u_3 = 8.0\\times 10^{-5}\\,n + 3.0\\times 10^{-5}\\,t = [-1.4019237962155611\\times 10^{-5}, 8.428203230275509\\times 10^{-5}]$, $u_4 = 9.0\\times 10^{-5}\\,n + 3.5\\times 10^{-5}\\,t = [-1.4689111140456177\\times 10^{-5}, 9.544228654700208\\times 10^{-5}]$, 且 $u_1 = [0.0, 0.0]$, $u_2 = [0.0, 0.0]$。\n  - 参数：$K_n = 1.0\\times 10^{9}$, $K_t = 5.0\\times 10^{8}$, $\\delta_{0n} = 2.0\\times 10^{-5}$, $\\delta_{fn} = 6.0\\times 10^{-5}$, $\\delta_{0t} = 2.5\\times 10^{-5}$, $\\delta_{ft} = 7.0\\times 10^{-5}$。\n  - 几何：$L = 1.0\\times 10^{-1}$, $b = 1.0\\times 10^{-2}$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果是如上所述的扁平化单元内力向量，以牛顿表示。最终输出格式必须严格为 $[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$ 的形式，其中每个内部列表包含八个浮点数，不带任何附加文本。", "solution": "该问题是有效的，因为它提法明确，在计算固体力学中有科学依据，并提供了一套完整且一致的数据和定义。任务是基于虚功原理和双线性牵引-分离法则，推导并实现一个四节点内聚界面单元的内力向量计算。\n\n### 1. 理论公式\n\n**1.1. 单元运动学和插值**\n四节点内聚单元模拟两个表面之间的分离。节点 $1$ 和 $2$ 在底面上，节点 $3$ 和 $4$ 在顶面上。几何形状由自然坐标 $s \\in [-1, 1]$ 参数化。我们将 $s = -1$ 与节点 $1$ 和 $3$ 关联，将 $s = 1$ 与节点 $2$ 和 $4$ 关联。\n\n底面任意点上的位移向量 $\\mathbf{u}^b(s)$ 和顶面上的位移向量 $\\mathbf{u}^t(s)$ 是使用线性形函数 $N_1(s)$ 和 $N_2(s)$ 从节点位移插值得到的：\n$$ N_1(s) = \\frac{1-s}{2}, \\quad N_2(s) = \\frac{1+s}{2} $$\n插值位移为：\n$$ \\mathbf{u}^b(s) = N_1(s)\\mathbf{u}_1 + N_2(s)\\mathbf{u}_2 $$\n$$ \\mathbf{u}^t(s) = N_1(s)\\mathbf{u}_3 + N_2(s)\\mathbf{u}_4 $$\n其中 $\\mathbf{u}_i = [u_{ix}, u_{iy}]^T$ 是节点 $i$ 的位移向量。\n\n界面上的位移跳跃（或分离向量） $\\boldsymbol{\\delta}(s)$ 是顶面和底面位移之差：\n$$ \\boldsymbol{\\delta}(s) = \\mathbf{u}^t(s) - \\mathbf{u}^b(s) = N_1(s)(\\mathbf{u}_3 - \\mathbf{u}_1) + N_2(s)(\\mathbf{u}_4 - \\mathbf{u}_2) $$\n\n**1.2. 局部分离**\n在每个积分点（高斯点） $s_i$ 处，由一个切向向量 $\\mathbf{t}$ 和一个法向向量 $\\mathbf{n}$ 组成的正交基定义了一个局部坐标系。位于全局坐标系中的位移跳跃向量 $\\boldsymbol{\\delta}(s_i)$ 被投影到这个局部基上，以获得法向分离 $\\delta_n$ 和切向分离 $\\delta_t$：\n$$ \\delta_n(s_i) = \\boldsymbol{\\delta}(s_i) \\cdot \\mathbf{n}(s_i) = \\mathbf{n}(s_i)^T \\boldsymbol{\\delta}(s_i) $$\n$$ \\delta_t(s_i) = \\boldsymbol{\\delta}(s_i) \\cdot \\mathbf{t}(s_i) = \\mathbf{t}(s_i)^T \\boldsymbol{\\delta}(s_i) $$\n\n**1.3. 非耦合双线性牵引-分离法则 (TSL)**\n内聚牵引力是根据局部分离计算的。法向和切向响应是非耦合的。\n\n*   **法向牵引力 ($T_n$)**：仅在正（拉伸）分离时产生牵引力。\n    $$ T_n(\\delta_n) = \\begin{cases}\n    0 & \\text{if } \\delta_n \\le 0 \\\\\n    K_n \\delta_n & \\text{if } 0  \\delta_n \\le \\delta_{0n} \\\\\n    K_n \\delta_{0n} \\left( \\frac{\\delta_{fn} - \\delta_n}{\\delta_{fn} - \\delta_{0n}} \\right)  \\text{if } \\delta_{0n}  \\delta_n  \\delta_{fn} \\\\\n    0  \\text{if } \\delta_n \\ge \\delta_{fn}\n    \\end{cases} $$\n    其中 $K_n$ 是初始法向刚度，$\\delta_{0n}$ 是峰值牵引力时的分离，$\\delta_{fn}$ 是破坏时的临界分离。\n\n*   **切向牵引力 ($T_t$)**：该法则相对于剪切方向是对称的。\n    $$ T_t(\\delta_t) = \\begin{cases}\n    K_t \\delta_t  \\text{if } |\\delta_t| \\le \\delta_{0t} \\\\\n    K_t \\delta_{0t} \\left( \\frac{\\delta_{ft} - |\\delta_t|}{\\delta_{ft} - \\delta_{0t}} \\right) \\text{sign}(\\delta_t)  \\text{if } \\delta_{0t}  |\\delta_t|  \\delta_{ft} \\\\\n    0  \\text{if } |\\delta_t| \\ge \\delta_{ft}\n    \\end{cases} $$\n    其中 $K_t$ 是初始切向刚度，$\\delta_{0t}$ 是峰值牵引力时的分离，$\\delta_{ft}$ 是破坏时的临界分离。项 $\\text{sign}(\\delta_t) = \\delta_t/|\\delta_t|$ 对于 $\\delta_t \\neq 0$ 成立，对于 $\\delta_t = 0$ 则为 $0$。\n\n**1.4. 单元内力向量的组装**\n虚功原理将牵引力与节点力联系起来。内聚牵引力 $\\mathbf{T}$ 在虚位移跳跃 $\\delta\\boldsymbol{\\delta}$ 上所做的内虚功 $\\delta W_{int}$ 为：\n$$ \\delta W_{int} = \\int_A \\mathbf{T}^T \\delta\\boldsymbol{\\delta} \\,dA $$\n积分是在内聚表面积 $A$ 上进行的。全局系统中的牵引力向量 $\\mathbf{T}$ 从其局部分量 $T_n$ 和 $T_t$ 中恢复：\n$$ \\mathbf{T}(s) = T_n(s) \\mathbf{n}(s) + T_t(s) \\mathbf{t}(s) $$\n虚位移跳跃通过形函数与虚节点位移 $\\delta\\mathbf{u}^e$ 相关。由此得到的单元内力向量 $\\mathbf{f}_{int}$ 的表达式为：\n$$ \\mathbf{f}_{int} = \\int_{L} \\mathbf{B}(s)^T \\mathbf{T}(s) b \\,dx $$\n其中 $b$ 是平面外厚度，$L$ 是单元长度，$\\mathbf{B}(s)$ 是将节点位移与跳跃关联起来的应变-位移矩阵。对于此单元，力向量分量为：\n$$ \\mathbf{f}_{1,2} = -\\int_L \\begin{pmatrix} N_1(s) \\\\ N_2(s) \\end{pmatrix} \\mathbf{T}(s) b \\,dx, \\quad \\mathbf{f}_{3,4} = \\int_L \\begin{pmatrix} N_1(s) \\\\ N_2(s) \\end{pmatrix} \\mathbf{T}(s) b \\,dx $$\n这对应于将节点力收集为：\n$$ \\mathbf{f}_1 = -\\int, \\quad \\mathbf{f}_2 = -\\int, \\quad \\mathbf{f}_3 = +\\int, \\quad \\mathbf{f}_4 = +\\int $$\n积分使用高斯求积法进行数值计算。对于线性单元，微分长度 $dx$ 通过 $dx = J\\,ds$ 与自然坐标相关，其中雅可比矩阵 $J=L/2$。采用两点方案（$s_i = \\pm 1/\\sqrt{3}$, $w_i=1$）：\n$$ \\mathbf{f}_{int} = \\sum_{i=1}^{2} w_i \\begin{bmatrix}\n-N_1(s_i)\\mathbf{T}(s_i) \\\\ -N_2(s_i)\\mathbf{T}(s_i) \\\\ N_1(s_i)\\mathbf{T}(s_i) \\\\ N_2(s_i)\\mathbf{T}(s_i)\n\\end{bmatrix} b J $$\n得到的 $8 \\times 1$ 向量随后被扁平化为 $[f_{x1}, f_{y1}, f_{x2}, f_{y2}, f_{x3}, f_{y3}, f_{x4}, f_{y4}]$。\n\n### 2. 实现算法\n每个测试用例的实现过程如下：\n1.  为单元内力 $\\mathbf{f}_{int}$ 初始化一个 $8 \\times 1$ 的零向量。\n2.  定义两点求积的高斯点 $s_i$ 和权重 $w_i$。\n3.  计算雅可比矩阵 $J = L/2$。\n4.  遍历每个高斯点 $s_i$：\n    a. 计算形函数 $N_1(s_i)$ 和 $N_2(s_i)$。\n    b. 插值位移 $\\mathbf{u}^b(s_i)$ 和 $\\mathbf{u}^t(s_i)$ 以找到全局位移跳跃向量 $\\boldsymbol{\\delta}(s_i)$。\n    c. 将 $\\boldsymbol{\\delta}(s_i)$ 投影到局部坐标系向量 $(\\mathbf{t}_i, \\mathbf{n}_i)$ 上，以找到标量分离 $\\delta_n$ 和 $\\delta_t$。\n    d. 应用双线性牵引-分离法则计算牵引力 $T_n$ 和 $T_t$。\n    e. 重构全局牵引力向量 $\\mathbf{T}(s_i) = T_n \\mathbf{n}_i + T_t \\mathbf{t}_i$。\n    f. 使用第 1.4 节中的公式计算此高斯点的力贡献，并将其加到 $\\mathbf{f}_{int}$ 中，由 $w_i$、$b$ 和 $J$ 加权。\n5. 循环结束后，向量 $\\mathbf{f}_{int}$ 包含所有八个自由度的总内力。此向量将转换为列表以供输出。", "answer": "```python\nimport numpy as np\n\ndef compute_tractions(delta_n, delta_t, params):\n    \"\"\"\n    Computes normal and tangential tractions based on a bilinear traction-separation law.\n\n    Args:\n        delta_n (float): Normal separation.\n        delta_t (float): Tangential separation.\n        params (dict): Dictionary of cohesive material parameters.\n\n    Returns:\n        tuple: A tuple containing the normal traction (Tn) and tangential traction (Tt).\n    \"\"\"\n    Kn, Kt = params['Kn'], params['Kt']\n    d0n, dfn = params['delta_0n'], params['delta_fn']\n    d0t, dft = params['delta_0t'], params['delta_ft']\n\n    # Normal traction (Tn) calculation\n    Tn = 0.0\n    if delta_n  0:\n        if delta_n = d0n:\n            Tn = Kn * delta_n\n        elif delta_n  dfn:\n            Tn_max = Kn * d0n\n            Tn = Tn_max * (dfn - delta_n) / (dfn - d0n)\n    # For delta_n = 0 (compression) or delta_n >= dfn (failure), Tn is 0.\n\n    # Tangential traction (Tt) calculation\n    Tt = 0.0\n    abs_delta_t = abs(delta_t)\n    if abs_delta_t  1e-15: # Avoid division by zero, floating point safe check for non-zero\n        if abs_delta_t = d0t:\n            Tt = Kt * delta_t\n        elif abs_delta_t  dft:\n            Tt_max = Kt * d0t\n            Tt = Tt_max * (dft - abs_delta_t) / (dft - d0t) * np.sign(delta_t)\n    # For abs_delta_t = 0 or abs_delta_t >= dft (failure), Tt is 0.\n\n    return Tn, Tt\n\ndef compute_internal_force(case):\n    \"\"\"\n    Computes the element internal force vector for a 4-node cohesive element.\n\n    Args:\n        case (dict): A dictionary containing all data for a single test case.\n\n    Returns:\n        list: The flattened 8-component element internal force vector.\n    \"\"\"\n    u1 = np.array(case['u1'], dtype=float)\n    u2 = np.array(case['u2'], dtype=float)\n    u3 = np.array(case['u3'], dtype=float)\n    u4 = np.array(case['u4'], dtype=float)\n    local_frames = case['local_frames']\n    params = case['params']\n    L, b = case['geometry']['L'], case['geometry']['b']\n\n    # Gauss quadrature: 2-point scheme for a line element\n    gauss_points = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    gauss_weights = [1.0, 1.0]\n\n    # Jacobian of the mapping from natural to physical coordinates\n    J = L / 2.0\n\n    # Initialize the element internal force vector [fx1, fy1, fx2, fy2, ...]\n    f_int = np.zeros(8)\n\n    for i, s in enumerate(gauss_points):\n        w = gauss_weights[i]\n\n        # Linear shape functions N1(s) and N2(s)\n        N1 = 0.5 * (1.0 - s)\n        N2 = 0.5 * (1.0 + s)\n\n        # Interpolate displacements on bottom and top surfaces\n        u_bottom = N1 * u1 + N2 * u2\n        u_top = N1 * u3 + N2 * u4\n\n        # Compute displacement jump vector in global coordinates\n        delta_global = u_top - u_bottom\n\n        # Get local frame vectors at the current Gauss point\n        t_vec = np.array(local_frames[i]['t'], dtype=float)\n        n_vec = np.array(local_frames[i]['n'], dtype=float)\n\n        # Project jump to get local normal and tangential separations\n        delta_n = np.dot(delta_global, n_vec)\n        delta_t = np.dot(delta_global, t_vec)\n\n        # Compute tractions using the bilinear constitutive law\n        Tn, Tt = compute_tractions(delta_n, delta_t, params)\n\n        # Form the global traction vector\n        T_global = Tn * n_vec + Tt * t_vec\n\n        # Assemble contribution to the internal force vector\n        factor = w * b * J\n\n        # Force contribution to node 1 (bottom, s=-1 side)\n        f_int[0:2] -= N1 * T_global * factor\n        # Force contribution to node 2 (bottom, s=+1 side)\n        f_int[2:4] -= N2 * T_global * factor\n        # Force contribution to node 3 (top, s=-1 side)\n        f_int[4:6] += N1 * T_global * factor\n        # Force contribution to node 4 (top, s=+1 side)\n        f_int[6:8] += N2 * T_global * factor\n\n    return f_int.tolist()\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            'u1': [0.0, 0.0], 'u2': [0.0, 0.0],\n            'u3': [1.0e-6, 2.0e-6], 'u4': [1.5e-6, 2.5e-6],\n            'local_frames': [{'t': [1.0, 0.0], 'n': [0.0, 1.0]}, {'t': [1.0, 0.0], 'n': [0.0, 1.0]}],\n            'params': {'Kn': 1.0e9, 'Kt': 5.0e8, 'delta_0n': 2.0e-5, 'delta_fn': 6.0e-5, 'delta_0t': 2.5e-5, 'delta_ft': 7.0e-5},\n            'geometry': {'L': 1.0e-1, 'b': 1.0e-2}\n        },\n        # Test case 2\n        {\n            'u1': [0.0, 0.0], 'u2': [0.0, 0.0],\n            'u3': [1.0e-6, -3.0e-5], 'u4': [2.0e-6, -4.0e-5],\n            'local_frames': [{'t': [1.0, 0.0], 'n': [0.0, 1.0]}, {'t': [1.0, 0.0], 'n': [0.0, 1.0]}],\n            'params': {'Kn': 1.0e9, 'Kt': 5.0e8, 'delta_0n': 2.0e-5, 'delta_fn': 6.0e-5, 'delta_0t': 2.5e-5, 'delta_ft': 7.0e-5},\n            'geometry': {'L': 1.0e-1, 'b': 1.0e-2}\n        },\n        # Test case 3\n        {\n            'u1': [0.0, 0.0], 'u2': [0.0, 0.0],\n            'u3': [3.0e-5, 1.0e-6], 'u4': [4.0e-5, 1.0e-6],\n            'local_frames': [{'t': [1.0, 0.0], 'n': [0.0, 1.0]}, {'t': [1.0, 0.0], 'n': [0.0, 1.0]}],\n            'params': {'Kn': 1.0e9, 'Kt': 5.0e8, 'delta_0n': 2.0e-5, 'delta_fn': 6.0e-5, 'delta_0t': 2.5e-5, 'delta_ft': 7.0e-5},\n            'geometry': {'L': 1.0e-1, 'b': 1.0e-2}\n        },\n        # Test case 4\n        {\n            'u1': [0.0, 0.0], 'u2': [0.0, 0.0],\n            'u3': [-1.4019237962155611e-5, 8.428203230275509e-5],\n            'u4': [-1.4689111140456177e-5, 9.544228654700208e-5],\n            'local_frames': [\n                {'t': [0.8660254037844386, 0.5], 'n': [-0.5, 0.8660254037844386]},\n                {'t': [0.8660254037844386, 0.5], 'n': [-0.5, 0.8660254037844386]}\n            ],\n            'params': {'Kn': 1.0e9, 'Kt': 5.0e8, 'delta_0n': 2.0e-5, 'delta_fn': 6.0e-5, 'delta_0t': 2.5e-5, 'delta_ft': 7.0e-5},\n            'geometry': {'L': 1.0e-1, 'b': 1.0e-2}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        f_int_vector = compute_internal_force(case)\n        results.append(f_int_vector)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3439060"}, {"introduction": "CZM的一个强大应用是模拟任意裂纹的扩展，这通常需要在模拟过程中动态地向网格中插入内聚力单元。这个高级练习 [@problem_id:3439069] 介绍了一种实现这种“外插式”方法的算法。你将学习如何基于局部应力状态和网格几何形状，设计一个准则来决定在模拟过程中何时何处应引入新的断裂路径。", "problem": "您被要求基于内聚区模型（CZM），为二维准静态断裂模拟中的外插式内聚单元插入制定并实现一个判定准则。其基本依据必须从以下原理出发。\n\n- 二维柯西应力张量是一个对称矩阵，记为 $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{2 \\times 2}$，其主应力是其特征值，主方向是相应的标准正交特征向量。对于对称的 $\\boldsymbol{\\sigma}$，存在标准正交特征向量 $\\{\\boldsymbol{p}_1,\\boldsymbol{p}_2\\}$ 和实特征值 $\\{\\sigma_1,\\sigma_2\\}$，其中 $\\sigma_1 \\ge \\sigma_2$，使得 $\\boldsymbol{\\sigma}\\boldsymbol{p}_i = \\sigma_i \\boldsymbol{p}_i$。\n- 在给定的准静态载荷增量下，裂纹扩展由局部拉应力驱动。一个简单的插入准则是，如果局部最大主应力 $\\sigma_1$ 超过材料阈值 $\\sigma_c$，并且网格边与最大主方向 $\\boldsymbol{p}_1$ 充分对齐，则可以沿该网格边插入一个内聚界面。\n- 给定一条由 $\\mathbb{R}^2$ 中坐标为 $\\boldsymbol{x}_i$ 和 $\\boldsymbol{x}_j$ 的两个节点定义的网格边，其单位切向量为 $\\boldsymbol{t} = (\\boldsymbol{x}_j - \\boldsymbol{x}_i)/\\|\\boldsymbol{x}_j - \\boldsymbol{x}_i\\|$，一个相容的单位法向量为 $\\boldsymbol{n} = (-t_y, t_x)$。由于物理界面是一条没有优选法向的线，因此通过计算 $\\boldsymbol{n}$ 和 $\\boldsymbol{p}_1$ 之间的无符号角来检验对齐度，该角度可通过点积的绝对值计算。\n\n您的任务是实现以下算法准则。\n\n- 对于每条网格边 $e$ 及其相邻单元索引 $\\mathcal{A}(e)$，根据每个相邻单元 $k \\in \\mathcal{A}(e)$ 的单元应力张量 $\\boldsymbol{\\sigma}^{(k)}$，计算其最大主应力 $\\sigma_1^{(k)}$ 和相应的单位特征向量 $\\boldsymbol{p}_1^{(k)}$。\n- 选择使 $\\sigma_1^{(k)}$ 最大化的相邻单元索引 $k^\\star \\in \\mathcal{A}(e)$。如果出现平局，则通过选择 $\\mathcal{A}(e)$ 中的第一个索引来确定性地打破平局。\n- 令 $\\sigma_1^\\star = \\sigma_1^{(k^\\star)}$ 和 $\\boldsymbol{p}_1^\\star = \\boldsymbol{p}_1^{(k^\\star)}$。计算如上定义的单位边法向量 $\\boldsymbol{n}$。定义无符号对齐角 $\\theta = \\arccos\\left(|\\boldsymbol{n} \\cdot \\boldsymbol{p}_1^\\star|\\right)$。\n- 外插式内聚单元插入准则被满足当且仅当以下所有条件同时成立：(i) $\\sigma_1^\\star \\ge \\sigma_c$，(ii) $\\theta \\le \\gamma_{\\mathrm{tol}}$，以及 (iii) 该边在任何之前的增量步中都未曾被插入过。计算中角度必须以弧度处理，但输入时以度为单位指定。所有应力和阈值都以兆帕（MPa）为单位指定，您必须同样处理它们。\n\n您必须实现一个程序，将此准则应用于一组具体的测试用例，并为每个用例返回必须插入外插式内聚单元的、从零开始的已排序边索引列表。\n\n测试套件的所有输入如下所述。所有坐标单位为米（m），所有应力和阈值单位为兆帕（MPa），所有提供的角度单位为度。您的实现必须将度转换为弧度以用于三角函数计算。输出是无单位的整数索引。\n\n测试套件：\n\n- 测试用例 $1$（包含内部边和边界边的正常路径）：\n  - 节点（索引 $\\to$ 坐标）：$0 \\to (0,0)$, $1 \\to (1,0)$, $2 \\to (1,1)$, $3 \\to (0,1)$。\n  - 单元（三角形，表示为节点三元组）：单元 $0$：$(0,1,2)$，单元 $1$：$(0,2,3)$。\n  - 唯一边（索引 $\\to$ 节点对）：$0 \\to (0,1)$, $1 \\to (1,2)$, $2 \\to (2,3)$, $3 \\to (3,0)$, $4 \\to (0,2)$。\n  - 边邻接关系 $\\mathcal{A}(e)$（边索引 $\\to$ 相邻单元索引列表）：$0 \\to [0]$, $1 \\to [0]$, $2 \\to [1]$, $3 \\to [1]$, $4 \\to [0,1]$。\n  - 单元应力 $\\boldsymbol{\\sigma}^{(k)}$（单位：MPa）：单元 $0$：$\\begin{bmatrix}130  0\\\\ 0  70\\end{bmatrix}$，单元 $1$：$\\begin{bmatrix}50  0\\\\ 0  150\\end{bmatrix}$。\n  - 阈值 $\\sigma_c = 120$ MPa。对齐容差 $\\gamma_{\\mathrm{tol}} = 15$ 度。先前已插入的边：无。\n  - 预期行为：在边界边和内部邻接选择上，都应选择与局部最大主方向对齐且超过阈值的边。\n\n- 测试用例 $2$（低于阈值被拒绝）：\n  - 节点、单元、唯一边和邻接关系与测试用例 1 相同。\n  - 单元应力 $\\boldsymbol{\\sigma}^{(k)}$（单位：MPa）：单元 $0$：$\\begin{bmatrix}80  0\\\\ 0  10\\end{bmatrix}$，单元 $1$：$\\begin{bmatrix}50  0\\\\ 0  90\\end{bmatrix}$。\n  - 阈值 $\\sigma_c = 120$ MPa。对齐容差 $\\gamma_{\\mathrm{tol}} = 15$ 度。先前已插入的边：无。\n  - 预期行为：由于任何地方都未满足阈值，因此不选择任何边。\n\n- 测试用例 $3$（等式边界情况和按历史记录排除）：\n  - 节点（索引 $\\to$ 坐标）：$0 \\to (0,0)$, $1 \\to (1,0)$, $2 \\to (0,1)$。\n  - 单元：单个三角形，单元 $0$：$(0,1,2)$。\n  - 唯一边（索引 $\\to$ 节点对）：$0 \\to (0,1)$, $1 \\to (1,2)$, $2 \\to (2,0)$。\n  - 边邻接关系：$0 \\to [0]$, $1 \\to [0]$, $2 \\to [0]$。\n  - 单元应力 $\\boldsymbol{\\sigma}^{(0)}$（单位：MPa）：$\\begin{bmatrix}100  0\\\\ 0  20\\end{bmatrix}$。\n  - 阈值 $\\sigma_c = 100$ MPa。对齐容差 $\\gamma_{\\mathrm{tol}} = 45$ 度。先前已插入的边：$\\{2\\}$。\n  - 预期行为：满足等式情况 $\\sigma_1^\\star = \\sigma_c$ 和 $\\theta = \\gamma_{\\mathrm{tol}}$ 的边按准则是允许的，但边索引 2 必须因先前已插入而被排除。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个条目是对应测试用例要插入的、从零开始的已排序边索引列表，例如 $[ [\\,\\cdot\\,], [\\,\\cdot\\,], [\\,\\cdot\\,] ]$。输出不得包含任何空格。对于给定的测试套件，您的程序应打印单行，格式如 \"[[e_list_for_case_1],[e_list_for_case_2],[e_list_for_case_3]]\"，其中每个 e_list 是一个整数列表。\n\n将该算法实现为一个完整的、可运行的程序，该程序不读取任何输入，并以指定格式精确写入一行输出。所有几何计算必须在欧几里得平面中执行，所有角度在接口处以度为单位处理，但在内部进行三角函数求值时需转换为弧度。所有应力和阈值必须解释为 MPa。最终输出是无单位的整数列表。", "solution": "我们从柯西应力张量 $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{2 \\times 2}$ 开始，它是对称的，因此存在一个具有实特征值的标准正交特征基。主应力是特征值 $\\sigma_1 \\ge \\sigma_2$，相应的主方向是单位特征向量 $\\boldsymbol{p}_1$ 和 $\\boldsymbol{p}_2$。二维中的对齐度可以通过单位向量之间的夹角来表示，该夹角可通过点积计算。\n\n给定一条具有节点坐标 $\\boldsymbol{x}_i, \\boldsymbol{x}_j \\in \\mathbb{R}^2$ 的网格边，定义单位切向量 $\\boldsymbol{t} = (\\boldsymbol{x}_j - \\boldsymbol{x}_i)/\\|\\boldsymbol{x}_j - \\boldsymbol{x}_i\\|$。一个相容的单位法向量是 $\\boldsymbol{n} = (-t_y, t_x)$。因为一条直线没有唯一的定向法向量，所以与主方向的点积的绝对值给出了边法线与主方向线之间最小夹角的余弦值：\n$$\n\\theta = \\arccos\\left( \\left| \\boldsymbol{n} \\cdot \\boldsymbol{p}_1 \\right| \\right).\n$$\n根据构造，此 $\\theta \\in [0,\\pi/2]$。使用角度容差 $\\gamma_{\\mathrm{tol}}$（以度为单位给出），对齐条件为 $\\theta \\le \\gamma_{\\mathrm{tol}}$。由于数值计算以弧度进行，我们通过以下方式将 $\\gamma_{\\mathrm{tol}}$ 从度转换：\n$$\n\\gamma_{\\mathrm{rad}} = \\gamma_{\\mathrm{tol}} \\times \\frac{\\pi}{180}.\n$$\n那么对齐不等式等价于\n$$\n\\left| \\boldsymbol{n} \\cdot \\boldsymbol{p}_1 \\right| \\ge \\cos(\\gamma_{\\mathrm{rad}}).\n$$\n\n接下来，对于每条边 $e$ 及其相邻单元索引 $\\mathcal{A}(e)$，我们通过对称张量 $\\boldsymbol{\\sigma}^{(k)}$ 的特征分解，为每个 $k \\in \\mathcal{A}(e)$ 计算最大主应力 $\\sigma_1^{(k)}$ 及其方向 $\\boldsymbol{p}_1^{(k)}$。然后我们选择 $k^\\star = \\arg\\max_{k \\in \\mathcal{A}(e)} \\sigma_1^{(k)}$，确定性地打破平局，并记为 $\\sigma_1^\\star = \\sigma_1^{(k^\\star)}$ 和 $\\boldsymbol{p}_1^\\star = \\boldsymbol{p}_1^{(k^\\star)}$。外插式内聚单元插入准则要求满足以下所有条件：\n- 应力阈值：$\\sigma_1^\\star \\ge \\sigma_c$。\n- 对齐：$\\left| \\boldsymbol{n} \\cdot \\boldsymbol{p}_1^\\star \\right| \\ge \\cos(\\gamma_{\\mathrm{rad}})$。\n- 历史排除：该边未列在先前已插入的边之中。\n\n每个测试用例的算法步骤：\n1. 对每个单元，使用对称求解器计算 $\\boldsymbol{\\sigma}^{(k)}$ 的特征分解，得到 $(\\sigma_1^{(k)}, \\boldsymbol{p}_1^{(k)})$，其中 $\\sigma_1^{(k)}$ 是最大特征值，$\\boldsymbol{p}_1^{(k)}$ 是相应的归一化特征向量。\n2. 对每条边，从节点坐标计算单位切向量 $\\boldsymbol{t}$ 和单位法向量 $\\boldsymbol{n}$。检索列表 $\\mathcal{A}(e)$ 并选择具有最大 $\\sigma_1^{(k)}$ 的 $k^\\star$。形成 $\\sigma_1^\\star$ 和 $\\boldsymbol{p}_1^\\star$。\n3. 计算 $c = \\left| \\boldsymbol{n} \\cdot \\boldsymbol{p}_1^\\star \\right|$ 和阈值 $c_{\\min} = \\cos(\\gamma_{\\mathrm{rad}})$。\n4. 如果边索引不在历史集合中，且 $\\sigma_1^\\star \\ge \\sigma_c$ 以及 $c \\ge c_{\\min}$，则标记该边为待插入。\n5. 返回排序后的索引列表。\n\n健全性与边界情况：\n- 在点积中使用绝对值确保了在 $\\boldsymbol{n} \\mapsto -\\boldsymbol{n}$ 和 $\\boldsymbol{p}_1 \\mapsto -\\boldsymbol{p}_1$ 变换下的不变性，这适用于无向直线。因为 $\\boldsymbol{n}$ 和 $\\boldsymbol{p}_1^\\star$ 都是单位向量，所以 $c = \\cos(\\theta)$，其中 $\\theta \\in [0,\\pi/2]$。\n- 使用相邻单元中最大的 $\\sigma_1$ 来模拟从最临界的相邻状态中选择的局部驱动力，而打破平局的规则确保了确定性。\n- 只有一个相邻单元的边界边可以通过 $|\\mathcal{A}(e)| = 1$ 自然处理。\n\n应用于指定的测试套件：\n\n测试用例 1：\n- 单元 $0$ 的应力为 $\\boldsymbol{\\sigma} = \\begin{bmatrix}130  0\\\\ 0  70\\end{bmatrix}$，得出 $\\sigma_1^{(0)} = 130$ 及其主方向 $\\boldsymbol{p}_1^{(0)} = (1,0)^\\top$。\n- 单元 $1$ 的应力为 $\\boldsymbol{\\sigma} = \\begin{bmatrix}50  0\\\\ 0  150\\end{bmatrix}$，得出 $\\sigma_1^{(1)} = 150$ 及其主方向 $\\boldsymbol{p}_1^{(1)} = (0,1)^\\top$。\n- 当 $\\sigma_c = 120$ 且 $\\gamma_{\\mathrm{tol}} = 15^\\circ$ 时，$c_{\\min} = \\cos(15^\\circ)$。\n  - 边 1 是垂直的，其单位法向量与 $(\\pm 1,0)^\\top$ 对齐；相邻单元是 0，其 $\\boldsymbol{p}_1^{(0)} = (1,0)^\\top$ 且 $\\sigma_1^{(0)} = 130 \\ge 120$。点积的绝对值为 $1 \\ge \\cos(15^\\circ)$，因此选择边 1。\n  - 边 2 是水平的，其单位法向量与 $(0,\\pm 1)^\\top$ 对齐；相邻单元是 1，其 $\\boldsymbol{p}_1^{(1)} = (0,1)^\\top$ 且 $\\sigma_1^{(1)} = 150 \\ge 120$。点积的绝对值为 $1 \\ge \\cos(15^\\circ)$，因此选择边 2。\n  - 其他边未能满足对齐或阈值条件。对角线边 4 的对齐角为 $45^\\circ$，超过了 $15^\\circ$。\n- 结果：$[1,2]$。\n\n测试用例 2：\n- 最大主应力低于 $\\sigma_c = 120$ MPa。没有边满足应力条件。结果：$[]$。\n\n测试用例 3：\n- 单个单元的应力为 $\\boldsymbol{\\sigma} = \\begin{bmatrix}100  0\\\\ 0  20\\end{bmatrix}$，其 $\\sigma_1^{(0)} = 100$ 且主方向为 $\\boldsymbol{p}_1^{(0)} = (1,0)^\\top$。当 $\\sigma_c = 100$ MPa 且 $\\gamma_{\\mathrm{tol}} = 45^\\circ$ 时，等式情况 $\\sigma_1^\\star = \\sigma_c$ 和 $\\theta = \\gamma_{\\mathrm{tol}}$ 都是允许的。边 1 和 2 满足对齐条件（分别为 $45^\\circ$ 和 $0^\\circ$）和应力阈值。然而，边 2 因先前已插入而被排除。结果：$[1]$。\n\n因此，预期的程序输出是单行\n$$\n[[1,2],[],[1]]\n$$\n且无空格，它汇总了三个测试用例的结果。该算法通过使用对称特征分解来保证鲁棒性，显式构造单位法向量和主方向，并为三角函数进行度到弧度的转换来实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef max_principal(stress: np.ndarray):\n    \"\"\"\n    Compute the maximum principal stress and corresponding unit eigenvector\n    for a 2x2 symmetric Cauchy stress tensor.\n    \"\"\"\n    # Use eigh for symmetric matrices: returns ascending eigenvalues\n    vals, vecs = np.linalg.eigh(stress)\n    idx = int(np.argmax(vals))\n    sigma1 = float(vals[idx])\n    p1 = vecs[:, idx]\n    # Normalize to unit length (robustness)\n    nrm = np.linalg.norm(p1)\n    if nrm == 0.0:\n        # Fallback: default direction if degenerate (should not occur for SPD or typical stresses)\n        p1 = np.array([1.0, 0.0], dtype=float)\n    else:\n        p1 = p1 / nrm\n    return sigma1, p1\n\ndef unit_normal(node_i: np.ndarray, node_j: np.ndarray):\n    \"\"\"\n    Compute one unit normal to the edge from node_i to node_j.\n    Orientation is irrelevant because we use absolute dot products.\n    \"\"\"\n    v = node_j - node_i\n    lv = np.linalg.norm(v)\n    if lv == 0.0:\n        # Degenerate edge; return a default unit normal\n        return np.array([1.0, 0.0], dtype=float)\n    t = v / lv\n    n = np.array([-t[1], t[0]], dtype=float)\n    # Already unit because t is unit\n    return n\n\ndef select_edges(nodes, elements, edges, edge2elems, stresses, sigma_c, gamma_deg, already_inserted):\n    \"\"\"\n    Apply the extrinsic cohesive insertion criterion and return sorted list of edge indices.\n    \"\"\"\n    # Precompute principal data per element\n    elem_principal = [max_principal(st) for st in stresses]\n    # Precompute cosine threshold\n    gamma_rad = np.deg2rad(gamma_deg)\n    cos_min = float(np.cos(gamma_rad))\n\n    selected = []\n    node_array = np.asarray(nodes, dtype=float)\n\n    already_set = set(already_inserted)\n\n    for e_idx, (i, j) in enumerate(edges):\n        if e_idx in already_set:\n            continue\n        # Build unit normal\n        n = unit_normal(node_array[i], node_array[j])\n\n        # Adjacent elements\n        adj = edge2elems[e_idx]\n        if not adj:\n            # No adjacent elements: cannot decide\n            continue\n\n        # Choose element with max principal stress\n        sigmas = [elem_principal[k][0] for k in adj]\n        max_index_local = int(np.argmax(sigmas))\n        k_star = adj[max_index_local]\n        sigma1_star, p1_star = elem_principal[k_star]\n\n        # Apply criteria\n        if sigma1_star >= sigma_c:\n            c = float(abs(np.dot(n, p1_star)))  # both unit vectors\n            if c >= cos_min:\n                selected.append(e_idx)\n\n    selected.sort()\n    return selected\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Test case 1\n    nodes1 = np.array([\n        [0.0, 0.0],  # 0\n        [1.0, 0.0],  # 1\n        [1.0, 1.0],  # 2\n        [0.0, 1.0],  # 3\n    ], dtype=float)\n    elements1 = [(0, 1, 2), (0, 2, 3)]\n    edges1 = [(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)]\n    edge2elems1 = [[0], [0], [1], [1], [0, 1]]\n    stresses1 = [\n        np.array([[130.0, 0.0], [0.0, 70.0]], dtype=float),   # element 0\n        np.array([[50.0, 0.0], [0.0, 150.0]], dtype=float),   # element 1\n    ]\n    sigma_c1 = 120.0\n    gamma_deg1 = 15.0\n    already1 = []\n\n    # Test case 2\n    nodes2 = nodes1.copy()\n    elements2 = elements1.copy()\n    edges2 = edges1.copy()\n    edge2elems2 = [lst.copy() for lst in edge2elems1]\n    stresses2 = [\n        np.array([[80.0, 0.0], [0.0, 10.0]], dtype=float),   # element 0\n        np.array([[50.0, 0.0], [0.0, 90.0]], dtype=float),   # element 1\n    ]\n    sigma_c2 = 120.0\n    gamma_deg2 = 15.0\n    already2 = []\n\n    # Test case 3\n    nodes3 = np.array([\n        [0.0, 0.0],  # 0\n        [1.0, 0.0],  # 1\n        [0.0, 1.0],  # 2\n    ], dtype=float)\n    elements3 = [(0, 1, 2)]\n    edges3 = [(0, 1), (1, 2), (2, 0)]\n    edge2elems3 = [[0], [0], [0]]\n    stresses3 = [\n        np.array([[100.0, 0.0], [0.0, 20.0]], dtype=float),\n    ]\n    sigma_c3 = 100.0\n    gamma_deg3 = 45.0\n    already3 = [2]\n\n    test_cases = [\n        (nodes1, elements1, edges1, edge2elems1, stresses1, sigma_c1, gamma_deg1, already1),\n        (nodes2, elements2, edges2, edge2elems2, stresses2, sigma_c2, gamma_deg2, already2),\n        (nodes3, elements3, edges3, edge2elems3, stresses3, sigma_c3, gamma_deg3, already3),\n    ]\n\n    results = []\n    for case in test_cases:\n        nodes, elements, edges, edge2elems, stresses, sigma_c, gamma_deg, already = case\n        sel = select_edges(nodes, elements, edges, edge2elems, stresses, sigma_c, gamma_deg, already)\n        results.append(sel)\n\n    # Format without spaces: e.g., [[1,2],[],[1]]\n    def format_list(lst):\n        return \"[\" + \",\".join(str(int(x)) for x in lst) + \"]\"\n    out = \"[\" + \",\".join(format_list(r) for r in results) + \"]\"\n    print(out)\n\nsolve()\n```", "id": "3439069"}]}