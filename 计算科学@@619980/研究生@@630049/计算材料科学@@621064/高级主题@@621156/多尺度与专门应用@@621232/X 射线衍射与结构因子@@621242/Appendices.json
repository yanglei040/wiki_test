{"hands_on_practices": [{"introduction": "X射线衍射分析的基础是将晶体的实空间晶格与其倒易空间对应起来。本练习[@problem_id:3504299]旨在通过计算实践，加深对倒易晶格矢量定义以及劳厄衍射条件的理解。通过从第一性原理出发编写程序，您将具体地掌握晶体几何结构和入射X射线波长如何共同决定可观测的衍射图样。", "problem": "给定一个实空间中的三斜 Bravais 晶格，它由三个线性无关的基矢 $\\mathbf{a}_1$、$\\mathbf{a}_2$ 和 $\\mathbf{a}_3$ 指定，其分量以埃（angstrom）为单位。倒易晶格由倒易基矢 $\\mathbf{b}_1$、$\\mathbf{b}_2$ 和 $\\mathbf{b}_3$ 定义，满足 $\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi \\delta_{ij}$，其中 $\\delta_{ij}$ 是 Kronecker delta，$\\cdot$ 表示欧几里得点积。实空间晶胞体积为 $V = \\mathbf{a}_1 \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_3)$，其中 $\\times$ 表示欧几里得叉积。倒易空间晶胞体积是由 $\\mathbf{b}_1$、$\\mathbf{b}_2$ 和 $\\mathbf{b}_3$ 张成的平行六面体的有向体积。对于X射线衍射（XRD），衍射条件（Laue 条件）指出，存在一个散射波矢 $\\mathbf{k}_{\\mathrm{out}}$，其满足 $|\\mathbf{k}_{\\mathrm{out}}| = |\\mathbf{k}_{\\mathrm{in}}|$ 且 $\\mathbf{k}_{\\mathrm{out}} - \\mathbf{k}_{\\mathrm{in}} = \\mathbf{G}$，其中 $\\mathbf{G}$ 是一个倒易晶格矢量。入射波矢的大小为 $|\\mathbf{k}_{\\mathrm{in}}| = 2\\pi / \\lambda$，其中 $\\lambda$ 是以埃为单位的X射线波长，入射方向以单位矢量的形式给出。\n\n从这些定义和物理事实出发，实现一个程序，该程序能够：\n- 从 $\\mathbf{a}_1$、$\\mathbf{a}_2$ 和 $\\mathbf{a}_3$ 计算倒易基矢 $\\mathbf{b}_1$、$\\mathbf{b}_2$ 和 $\\mathbf{b}_3$。\n- 以 $\\mathrm{\\AA}^{-3}$（立方埃的倒数）为单位计算倒易晶胞体积，并与上述定义保持一致。\n- 枚举所有非零的倒易晶格矢量 $\\mathbf{G} = h \\mathbf{b}_1 + k \\mathbf{b}_2 + \\ell \\mathbf{b}_3$（其中 $(h,k,\\ell)$ 为整数 Miller 指数），这些矢量需同时满足 $|\\mathbf{G}| \\le Q_{\\max}$ 和给定入射束的衍射条件（Laue 条件）。衍射条件通过对 $|\\mathbf{k}_{\\mathrm{in}} + \\mathbf{G}| = |\\mathbf{k}_{\\mathrm{in}}|$ 所隐含的标量方程使用容差 $\\varepsilon$ 进行数值检验。排除平凡解 $\\mathbf{G} = \\mathbf{0}$。所有 $\\mathbf{b}_i$ 的矢量分量以 $\\mathrm{\\AA}^{-1}$ 表示，倒易晶胞体积以 $\\mathrm{\\AA}^{-3}$ 表示。在衍射条件的相等性检查中，使用指定的容差 $\\varepsilon$ 作为无量纲界限。\n\n除了上述给定的定义和基本事实外，您不得假定任何预先推导的简化公式。您的推导和实现必须仅依赖于这些基础元素。\n\n关于数值输出：\n- 将所有浮点输出（倒易基矢分量和倒易晶胞体积）四舍五入至六位小数。\n- 角度不直接使用；方向以单位矢量给出，因此不需要指定角度单位。\n- 最终输出必须是单行文本，包含所有测试用例的结果，形式为方括号内由逗号分隔的列表。每个测试用例的结果必须是 $[\\text{b\\_flat\\_list}, \\text{reciprocal\\_volume}, \\text{hkls\\_list}]$ 形式的列表，其中 $\\text{b\\_flat\\_list}$ 是分量的展平列表 $[b_{1x}, b_{1y}, b_{1z}, b_{2x}, b_{2y}, b_{2z}, b_{3x}, b_{3y}, b_{3z}]$（全部以 $\\mathrm{\\AA}^{-1}$ 为单位），$\\text{reciprocal\\_volume}$ 是一个以 $\\mathrm{\\AA}^{-3}$ 为单位的浮点数，$\\text{hkls\\_list}$ 是满足条件的整数三元组 $[h,k,\\ell]$ 的列表。\n\n使用以下测试套件。每个用例由 $(\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3, \\lambda, \\hat{\\mathbf{k}}_{\\mathrm{in}}, Q_{\\max}, \\varepsilon)$ 定义：\n1. 通用三斜晶系情况（正常路径）：\n   - $\\mathbf{a}_1 = (\\,4.0,\\,0.2,\\,0.1\\,)\\,\\mathrm{\\AA}$，$\\mathbf{a}_2 = (\\,0.1,\\,5.0,\\,0.4\\,)\\,\\mathrm{\\AA}$，$\\mathbf{a}_3 = (\\,0.2,\\,0.3,\\,6.1\\,)\\,\\mathrm{\\AA}$。\n   - $\\lambda = 1.0\\,\\mathrm{\\AA}$，$\\hat{\\mathbf{k}}_{\\mathrm{in}} = (\\,0.0,\\,0.0,\\,1.0\\,)$。\n   - $Q_{\\max} = 4.0\\,\\mathrm{\\AA}^{-1}$，$\\varepsilon = 1\\times 10^{-6}$。\n2. 倾斜入射及典型波长：\n   - $\\mathbf{a}_1 = (\\,3.5,\\,0.0,\\,0.0\\,)\\,\\mathrm{\\AA}$，$\\mathbf{a}_2 = (\\,0.2,\\,4.7,\\,0.1\\,)\\,\\mathrm{\\AA}$，$\\mathbf{a}_3 = (\\,0.1,\\,0.4,\\,5.5\\,)\\,\\mathrm{\\AA}$。\n   - $\\lambda = 1.5406\\,\\mathrm{\\AA}$，$\\hat{\\mathbf{k}}_{\\mathrm{in}} = (\\,0.3,\\,0.4,\\,0.866025403784\\,)$。\n   - $Q_{\\max} = 3.0\\,\\mathrm{\\AA}^{-1}$，$\\varepsilon = 1\\times 10^{-6}$。\n3. 边界情况及较小的 $Q_{\\max}$：\n   - $\\mathbf{a}_1 = (\\,5.2,\\,0.1,\\,0.0\\,)\\,\\mathrm{\\AA}$，$\\mathbf{a}_2 = (\\,0.0,\\,5.3,\\,0.2\\,)\\,\\mathrm{\\AA}$，$\\mathbf{a}_3 = (\\,0.1,\\,0.0,\\,5.4\\,)\\,\\mathrm{\\AA}$。\n   - $\\lambda = 0.5\\,\\mathrm{\\AA}$，$\\hat{\\mathbf{k}}_{\\mathrm{in}} = (\\,1.0,\\,0.0,\\,0.0\\,)$。\n   - $Q_{\\max} = 0.8\\,\\mathrm{\\AA}^{-1}$，$\\varepsilon = 1\\times 10^{-6}$。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果，每个元素对应一个如上所述结构的测试用例结果。例如，输出格式必须严格为 $[\\text{case1},\\text{case2},\\text{case3}]$，不含任何无关文本，并使用指定的单位和四舍五入规则。", "solution": "根据指定标准，用户提供的问题被评估为有效。它在科学上基于固态物理和X射线衍射的原理，问题设定良好，具有完整且一致的给定条件，并且表述客观。该问题要求实现基本定义，而不依赖于预先推导的简化公式，构成了一项实质性的计算任务。\n\n解决方案分三个主要阶段进行开发：\n1.  计算倒易基矢和倒易晶胞体积。\n2.  推导用于识别衍射倒易晶格矢量的条件。\n3.  建立枚举这些矢量的算法。\n\n### 1. 倒易基矢和体积的计算\n\n问题将实空间基矢定义为 $\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3$，并将倒易基矢定义为 $\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3$，它们之间通过以下关系联系：\n$$\n\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi \\delta_{ij}\n$$\n其中 $\\delta_{ij}$ 是 Kronecker delta。实空间晶胞体积由标量三重积 $V = \\mathbf{a}_1 \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_3)$ 给出。\n\n为了找到 $\\mathbf{b}_1$ 的表达式，我们使用其定义。条件 $\\mathbf{a}_2 \\cdot \\mathbf{b}_1 = 0$ 和 $\\mathbf{a}_3 \\cdot \\mathbf{b}_1 = 0$ 意味着 $\\mathbf{b}_1$ 必须同时与 $\\mathbf{a}_2$ 和 $\\mathbf{a}_3$ 正交。因此，$\\mathbf{b}_1$ 必须平行于叉积 $\\mathbf{a}_2 \\times \\mathbf{a}_3$。我们可以将其写为：\n$$\n\\mathbf{b}_1 = C (\\mathbf{a}_2 \\times \\mathbf{a}_3)\n$$\n其中 $C$ 为某个标量常数。为了求出 $C$，我们使用剩下的条件 $\\mathbf{a}_1 \\cdot \\mathbf{b}_1 = 2\\pi$：\n$$\n\\mathbf{a}_1 \\cdot [C (\\mathbf{a}_2 \\times \\mathbf{a}_3)] = 2\\pi\n$$\n$$\nC [\\mathbf{a}_1 \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_3)] = 2\\pi\n$$\n使用实空间体积 $V$ 的定义，我们得到 $C V = 2\\pi$，从而得出 $C = 2\\pi/V$。因此，$\\mathbf{b}_1$ 的表达式为：\n$$\n\\mathbf{b}_1 = \\frac{2\\pi}{V} (\\mathbf{a}_2 \\times \\mathbf{a}_3)\n$$\n通过对下标进行循环置换，我们得到 $\\mathbf{b}_2$ 和 $\\mathbf{b}_3$ 的表达式：\n$$\n\\mathbf{b}_2 = \\frac{2\\pi}{V} (\\mathbf{a}_3 \\times \\mathbf{a}_1)\n$$\n$$\n\\mathbf{b}_3 = \\frac{2\\pi}{V} (\\mathbf{a}_1 \\times \\mathbf{a}_2)\n$$\n\n倒易晶胞体积定义为由倒易基矢张成的平行六面体的有向体积，由它们的标量三重积给出：\n$$\nV_{\\text{recip}} = \\mathbf{b}_1 \\cdot (\\mathbf{b}_2 \\times \\mathbf{b}_3)\n$$\n我们将不使用常见的简化关系式 $V_{\\text{recip}} = (2\\pi)^3/V$，而是直接根据计算出的 $\\mathbf{b}_i$ 矢量来计算此值，以严格遵守问题的约束。\n\n### 2. 衍射条件\n\n倒易晶格矢量由 $\\mathbf{G} = h \\mathbf{b}_1 + k \\mathbf{b}_2 + \\ell \\mathbf{b}_3$ 给出，其中 $(h,k,\\ell)$ 为整数 Miller 指数。我们需要找到所有满足两个条件的非零矢量 $\\mathbf{G}$。\n\n**条件1：模长约束**\n倒易晶格矢量的模长必须小于或等于给定的最大值 $Q_{\\max}$：\n$$\n|\\mathbf{G}| \\le Q_{\\max}\n$$\n等价地，$|\\mathbf{G}|^2 \\le Q_{\\max}^2$。\n\n**条件2：Laue 条件**\n衍射（Laue）条件是 $\\mathbf{k}_{\\mathrm{out}} - \\mathbf{k}_{\\mathrm{in}} = \\mathbf{G}$，其中 $\\mathbf{k}_{\\mathrm{in}}$ 是入射波矢，$\\mathbf{k}_{\\mathrm{out}}$ 是散射波矢。对于弹性散射（如XRD中），$|\\mathbf{k}_{\\mathrm{out}}| = |\\mathbf{k}_{\\mathrm{in}}|$。将 $\\mathbf{k}_{\\mathrm{out}} = \\mathbf{k}_{\\mathrm{in}} + \\mathbf{G}$ 代入弹性散射条件，得到：\n$$\n|\\mathbf{k}_{\\mathrm{in}} + \\mathbf{G}| = |\\mathbf{k}_{\\mathrm{in}}|\n$$\n两边平方，得到：\n$$\n(\\mathbf{k}_{\\mathrm{in}} + \\mathbf{G}) \\cdot (\\mathbf{k}_{\\mathrm{in}} + \\mathbf{G}) = \\mathbf{k}_{\\mathrm{in}} \\cdot \\mathbf{k}_{\\mathrm{in}}\n$$\n$$\n|\\mathbf{k}_{\\mathrm{in}}|^2 + 2\\mathbf{k}_{\\mathrm{in}} \\cdot \\mathbf{G} + |\\mathbf{G}|^2 = |\\mathbf{k}_{\\mathrm{in}}|^2\n$$\n这可简化为衍射矢量 $\\mathbf{G}$ 必须满足的最终方程：\n$$\n2\\mathbf{k}_{\\mathrm{in}} \\cdot \\mathbf{G} + |\\mathbf{G}|^2 = 0\n$$\n问题指定了使用无量纲容差 $\\varepsilon$ 对此条件进行数值检验。通过除以 $|\\mathbf{k}_{\\mathrm{in}}|^2$ 可以获得一个合适的无量纲量来表示与此条件的偏差：\n$$\n\\left| \\frac{2\\mathbf{k}_{\\mathrm{in}} \\cdot \\mathbf{G} + |\\mathbf{G}|^2}{|\\mathbf{k}_{\\mathrm{in}}|^2} \\right| \\le \\varepsilon\n$$\n入射波矢由其大小 $|\\mathbf{k}_{\\mathrm{in}}| = 2\\pi/\\lambda$ 和给定的方向单位矢量 $\\hat{\\mathbf{k}}_{\\mathrm{in}}$ 构建而成：$\\mathbf{k}_{\\mathrm{in}} = (2\\pi/\\lambda)\\hat{\\mathbf{k}}_{\\mathrm{in}}$。\n\n### 3. 枚举算法\n\n为找到所有满足条件的整数三元组 $(h,k,\\ell)$，我们必须在整数格点的一个有限区域内进行搜索。条件 $|\\mathbf{G}| \\le Q_{\\max}$ 在 $(h,k,\\ell)$ 空间中定义了一个椭球体。为了建立一个简单的搜索边界，我们可以找到一个包含该椭球体的长方体。\n\n矢量 $\\mathbf{G}$ 可以写成矩阵形式 $\\mathbf{G} = B \\mathbf{m}$，其中 $B$ 是以 $\\{\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3\\}$ 为列的矩阵，且 $\\mathbf{m} = [h, k, \\ell]^T$。因此，$\\mathbf{m} = B^{-1} \\mathbf{G}$。\n设实空间基矢矩阵的行是 $A_{mat} = [\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3]^T$。定义 $\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi \\delta_{ij}$ 意味着 $A_{mat} B = 2\\pi I$，因此 $B^{-1} = \\frac{1}{2\\pi} A_{mat}$。$B^{-1}$ 的行是 $\\frac{1}{2\\pi}\\mathbf{a}_1$、$\\frac{1}{2\\pi}\\mathbf{a}_2$ 和 $\\frac{1}{2\\pi}\\mathbf{a}_3$。\n\n$\\mathbf{m}$ 的分量可以被界定。例如，对于 $h$：\n$$\nh = (\\frac{1}{2\\pi}\\mathbf{a}_1) \\cdot \\mathbf{G}\n$$\n根据 Cauchy-Schwarz 不等式， $|h| \\le \\frac{1}{2\\pi}|\\mathbf{a}_1| |\\mathbf{G}|$。由于 $|\\mathbf{G}| \\le Q_{\\max}$，我们有：\n$$\n|h| \\le \\frac{|\\mathbf{a}_1| Q_{\\max}}{2\\pi}\n$$\n这给出了 $h$ 的最大搜索范围，对 $k$ 和 $\\ell$ 也类似：\n$$\nh_{\\max} = \\lceil \\frac{|\\mathbf{a}_1| Q_{\\max}}{2\\pi} \\rceil, \\quad k_{\\max} = \\lceil \\frac{|\\mathbf{a}_2| Q_{\\max}}{2\\pi} \\rceil, \\quad \\ell_{\\max} = \\lceil \\frac{|\\mathbf{a}_3| Q_{\\max}}{2\\pi} \\rceil\n$$\n其中 $\\lceil \\cdot \\rceil$ 是上取整函数。该算法将遍历这些范围内的所有整数 $h, k, \\ell$（从 $-h_{\\max}$ 到 $h_{\\max}$ 等），构建相应的 $\\mathbf{G}$，并根据两个条件对其进行检验。为得到确定性的输出，生成的 $(h,k,\\ell)$ 三元组列表将按字典序排序。\n\n每个测试用例的最终结果需要特定的格式：倒易基矢的分量和倒易晶胞体积必须四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1: General triclinic\n        (np.array([4.0, 0.2, 0.1]), np.array([0.1, 5.0, 0.4]), np.array([0.2, 0.3, 6.1]),\n         1.0, np.array([0.0, 0.0, 1.0]), 4.0, 1e-6),\n        # Case 2: Oblique incidence\n        (np.array([3.5, 0.0, 0.0]), np.array([0.2, 4.7, 0.1]), np.array([0.1, 0.4, 5.5]),\n         1.5406, np.array([0.3, 0.4, 0.866025403784]), 3.0, 1e-6),\n        # Case 3: Boundary case\n        (np.array([5.2, 0.1, 0.0]), np.array([0.0, 5.3, 0.2]), np.array([0.1, 0.0, 5.4]),\n         0.5, np.array([1.0, 0.0, 0.0]), 0.8, 1e-6),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(*case)\n        results.append(result)\n\n    # The problem asks for the standard python string representation of lists\n    # which includes spaces after commas. The f-string joins these string\n    # representations with a comma but doesn't alter the inner representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef process_case(a1, a2, a3, lambda_xray, k_in_hat, Q_max, epsilon):\n    \"\"\"\n    Processes a single test case for X-ray diffraction analysis.\n    \n    Args:\n        a1, a2, a3 (np.ndarray): Real-space basis vectors in Angstroms.\n        lambda_xray (float): Wavelength of the X-ray in Angstroms.\n        k_in_hat (np.ndarray): Unit vector of the incident wavevector.\n        Q_max (float): Maximum magnitude of reciprocal lattice vectors to consider.\n        epsilon (float): Tolerance for the diffraction condition check.\n\n    Returns:\n        list: A list containing [b_flat_list, reciprocal_volume, hkls_list].\n    \"\"\"\n    \n    # 1. Compute real-space volume\n    # V = a1 . (a2 x a3)\n    V_real = np.dot(a1, np.cross(a2, a3))\n    \n    # 2. Compute reciprocal basis vectors\n    factor = 2 * np.pi / V_real\n    b1 = factor * np.cross(a2, a3)\n    b2 = factor * np.cross(a3, a1)\n    b3 = factor * np.cross(a1, a2)\n    \n    # 3. Compute reciprocal cell volume\n    # V_recip = b1 . (b2 x b3)\n    V_recip = np.dot(b1, np.cross(b2, b3))\n    \n    # 4. Enumerate reciprocal lattice vectors G = h*b1 + k*b2 + l*b3\n    k_in_mag = 2 * np.pi / lambda_xray\n    k_in = k_in_mag * k_in_hat\n    k_in_mag_sq = k_in_mag**2\n\n    # Determine search bounds for Miller indices h, k, l\n    h_max = int(np.ceil(np.linalg.norm(a1) * Q_max / (2 * np.pi)))\n    k_max = int(np.ceil(np.linalg.norm(a2) * Q_max / (2 * np.pi)))\n    l_max = int(np.ceil(np.linalg.norm(a3) * Q_max / (2 * np.pi)))\n    \n    hkls_list = []\n    \n    for h in range(-h_max, h_max + 1):\n        for k in range(-k_max, k_max + 1):\n            for l in range(-l_max, l_max + 1):\n                if h == 0 and k == 0 and l == 0:\n                    continue\n                \n                G = h * b1 + k * b2 + l * b3\n                G_mag = np.linalg.norm(G)\n                \n                # Condition 1: |G| = Q_max\n                if G_mag > Q_max:\n                    continue\n                \n                # Condition 2: Diffraction condition (Laue)\n                # Test |(2*k_in.G + |G|^2) / |k_in|^2| = epsilon\n                G_mag_sq = G_mag**2\n                laue_check_numerator = 2 * np.dot(k_in, G) + G_mag_sq\n                \n                # Handle case where k_in_mag_sq is zero, though physically unlikely\n                if k_in_mag_sq == 0:\n                    continue\n                \n                dimensionless_test_val = laue_check_numerator / k_in_mag_sq\n                \n                if abs(dimensionless_test_val) = epsilon:\n                    hkls_list.append([h, k, l])\n\n    # Sort the list for deterministic output\n    hkls_list.sort()\n    \n    # 5. Format the output\n    b_flat = np.concatenate((b1, b2, b3))\n    b_flat_list = [round(comp, 6) for comp in b_flat]\n    reciprocal_volume = round(V_recip, 6)\n    \n    return [b_flat_list, reciprocal_volume, hkls_list]\n\n# Execute the solver\nsolve()\n```", "id": "3504299"}, {"introduction": "衍射实验可以测量散射X射线的强度，但损失了相位信息，这导致了晶体学中著名的“相位问题”。帕特森函数是测量强度的傅里叶变换，它提供了一张包含晶体结构中所有原子间矢量的图谱，从而绕过了对相位信息的需求。本练习[@problem_id:3504298]将指导您使用快速傅里叶变换 (FFT) 计算帕特森函数，并设计一个算法来解码这张图谱，这是确定重原子位置和解析晶体结构的经典方法。", "problem": "给定一个在均匀离散网格上建模的晶胞中的周期性电子密度，以及一组具有实数、正散射强度的离散散射中心（原子）。目标是推导并实现帕特森函数的计算，并设计一个自动化程序，用于从二维合成数据集的帕特森图中恢复重原子亚结构。整个过程在晶胞的分数坐标中进行，使用离散格点上的周期性边界条件。\n\n定义和基本依据：\n- 设晶胞由一个 $N \\times N$ 的网格表示，索引为 $(x,y)$，其中 $x,y \\in \\{0,1,\\dots,N-1\\}$，对应于分数坐标 $(x/N,y/N)$。\n- 离散化的电子密度为 $\\rho[x,y] \\in \\mathbb{R}_{\\ge 0}$，通过将原子放置为网格点上的加权离散脉冲（克罗内克δ函数）来构建：如果有 $M$ 个原子，其网格索引为 $(x_j,y_j)$，散射强度为 $f_j  0$，则对于 $j=1,\\dots,M$，有 $\\rho[x_j,y_j] \\leftarrow \\rho[x_j,y_j] + f_j$。\n- 离散结构因子是 $\\rho[x,y]$ 的离散傅里叶变换，记为 $F[h,k]$，其中 $h,k \\in \\{0,1,\\dots,N-1\\}$。使用离散傅里叶变换约定 $F[h,k] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(-2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right)$，且其逆变换包含因子 $1/N^2$。\n- 帕特森函数是 $\\rho[x,y]$ 的循环自相关，定义为 $P[u,v] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\rho[(x+u) \\bmod N,(y+v) \\bmod N]$，其中整数位移 $(u,v)$ 满足 $u,v \\in \\{0,1,\\dots,N-1\\}$。\n\n任务：\n1) 仅从离散傅里叶变换、其逆变换以及上述循环自相关的定义出发，推导帕特森函数可以计算为结构因子振幅平方的离散傅里叶逆变换，即 $P[u,v]$ 等于 $|F[h,k]|^2$ 的离散傅里叶逆变换（在所选离散变换约定的标准归一化下）。提供一个清晰的推导过程，以证明使用快速傅里叶变换（FFT）的计算路径是合理的。\n\n2) 设计并实现一个算法，在给定帕特森图 $P[u,v]$ 的情况下，自动重建一个与 $P[u,v]$ 中最强峰相符的重原子亚结构。使用以下建模假设和要求：\n- 原子精确地放置在网格点上，即其分数坐标是 $1/N$ 的倍数。\n- 帕特森图在所有原子间差分向量处都包含峰，即在对应于所有有序对 $(i,j)$ 的位移 $(x_j-x_i \\bmod N, y_j-y_i \\bmod N)$ 处，包括原点，其峰高为自积和 $f_j^2$。\n- 由于帕特森函数对于原子构型的整体平移和反演是不变的，定义一个规范标度来报告重建的亚结构，具体如下：\n  - 将第一个重建的原子固定在网格坐标的原点 $(0,0)$。\n  - 仅使用峰集合和成对差分的一致性来选择后续的原子位置，然后通过除以 $N$ 将其转换为 $[0,1)$ 内的分数坐标。\n  - 按字典序对重建的分数坐标进行排序。\n- 为最多 $M=3$ 个原子实现一个确定性的贪婪嵌入过程：\n  - 通过搜索局部最大值并丢弃原点 $(u,v)=(0,0)$，从 $P[u,v]$ 中提取一组强的、唯一的非原点峰。保留足够的峰以覆盖最多 $M=3$ 个原子的所有原子间向量。\n  - 按照惯例，将第一个原子放置在 $(0,0)$。\n  - 使用固定的规则（例如，在对称等效位置中选择字典序最小的索引）从峰集合中确定性地选择一个振幅最高的非原点峰索引 $(u_1,v_1)$，并将第二个原子放置在该处。\n  - 如果存在第三个原子，将其放置在候选峰 $(u_2,v_2)$ 处，使得该位置与第二个原子的差分在模运算下与观测到的峰集合一致，即 $(u_2-u_1 \\bmod N, v_2-v_1 \\bmod N)$ 或 $(u_2+u_1 \\bmod N, v_2+v_1 \\bmod N)$ 存在于观测峰中。使用确定性的选择规则，按峰值振幅降序、然后按索引的字典序来解决平局问题。\n\n3) 实现完整的流程：\n- 给定 $N$ 和一个由整数索引 $(x_j,y_j)$ 及强度 $f_j$ 指定的原子列表，构建 $\\rho[x,y]$，通过离散傅里叶变换计算 $F[h,k]$，构建强度 $I[h,k] = |F[h,k]|^2$，并通过对 $I[h,k]$ 进行离散傅里叶逆变换来计算帕特森图 $P[u,v]$。\n- 实现上述重原子亚结构搜索算法，以重建一组最多 $M=3$ 个原子的位置，坐标为 $[0,1)$ 内的分数坐标，并四舍五入到三位小数。\n- 在规范标度下输出重建的位置。\n\n测试套件：\n为以下三个合成数据集提供结果。所有数据集均为二维，具有周期性边界条件，并且严格在网格上（网格坐标为整数；分数坐标为整数除以 $N$）：\n- 测试用例 A（边界情况，单个原子）：\n  - $N=32$。\n  - 原子：一个原子位于 $(x_1,y_1)=(8,5)$，强度 $f_1=74$。\n- 测试用例 B（两个原子，强度相等）：\n  - $N=32$。\n  - 原子：两个原子位于 $(x_1,y_1)=(5,9)$ 和 $(x_2,y_2)=(21,15)$，强度 $f_1=f_2=74$。\n- 测试用例 C（三个原子，强度不等，最重的一对占主导）：\n  - $N=32$。\n  - 原子：三个原子位于 $(x_1,y_1)=(6,10)$，强度 $f_1=74$；$(x_2,y_2)=(25,22)$，强度 $f_2=50$；以及 $(x_3,y_3)=(12,27)$，强度 $f_3=40$。\n\n答案规格：\n- 对于每个测试用例，程序必须返回一个浮点数列表，表示在规范标度下展平的重建分数坐标，四舍五入到三位小数，第一个原子固定在 $(0.000,0.000)$，其余部分按字典序排序。例如，对于二维中的两个原子，返回四个数字 $[x_1,y_1,x_2,y_2]$，其中 $(x_1,y_1)=(0.000,0.000)$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的列表形式的结果，每个元素对应一个测试用例，本身也是一个浮点数列表。例如：$[[\\dots],[\\dots],[\\dots]]$。\n\n角度单位和物理单位：\n- 不使用物理单位。角度隐含在复指数中，是无量纲的；在这种离散设置中不需要单独的角度单位。\n\n您的最终交付成果是一个完整、可运行的程序，该程序通过离散傅里叶变换计算帕特森函数，执行所述的亚结构搜索，并以上述确切格式打印三个测试用例的结果。不需要用户输入；程序应能直接运行。", "solution": "用户提供了一个材料科学领域的计算问题，具体涉及X射线晶体学中的帕特森函数。该问题将在一个代表二维晶胞的离散网格上求解。\n\n根据既定协议，首先对问题陈述进行验证。\n\n### 步骤1：提取给定信息\n\n-   **网格**：一个离散的 $N \\times N$ 网格，索引为 $(x,y)$，其中 $x,y \\in \\{0, 1, \\dots, N-1\\}$。\n-   **电子密度 ($\\rho$)**：$\\rho[x,y] \\in \\mathbb{R}_{\\ge 0}$ 是由 $M$ 个位于网格点 $(x_j, y_j)$、散射强度为 $f_j  0$ 的原子构建的。每个原子的值 $\\rho[x_j, y_j]$ 会增加 $f_j$。\n-   **离散傅里叶变换 (DFT)**：结构因子 $F[h,k]$ 是 $\\rho[x,y]$ 的DFT：\n    $$F[h,k] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(-2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right)$$\n-   **逆DFT**：规定逆变换包含一个归一化因子 $1/N^2$。\n-   **帕特森函数 ($P$)**：电子密度的循环自相关：\n    $$P[u,v] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\rho[(x+u) \\bmod N,(y+v) \\bmod N]$$\n-   **任务1**：推导 $P[u,v]$ 可通过计算 $|F[h,k]|^2$ 的逆DFT得到。\n-   **任务2**：设计并实现一个确定性的贪婪算法，用于从帕特森图 $P[u,v]$ 中重建一个最多包含 $M=3$ 个重原子的原子亚结构。这包括：\n    -   提取强的非原点峰（局部最大值）。\n    -   定义一个规范标度：原子1位于 $(0,0)$，后续的分数坐标按字典序排序。\n    -   贪婪放置：原子2位于振幅最高峰中字典序最小的索引处。原子3位于候选峰 $(u_2,v_2)$，使得 $(u_2-u_1 \\bmod N, v_2-v_1 \\bmod N)$ 或 $(u_2+u_1 \\bmod N, v_2+v_1 \\bmod N)$ 也是一个观测到的峰，并使用确定性规则解决平局问题。\n-   **任务3**：实现完整的流程并为三个测试用例提供结果。\n-   **测试用例**：\n    -   A: $N=32$，1个原子：$((8,5), f=74)$。\n    -   B: $N=32$，2个原子：$((5,9), f=74)$，$((21,15), f=74)$。\n    -   C: $N=32$，3个原子：$((6,10), f=74)$，$((25,22), f=50)$，$((12,27), f=40)$。\n-   **答案格式**：单行JSON风格的列表之列表 `[[...],[...],[...]]`，包含每个测试用例的展平、四舍五入（3位小数）的分数坐标。\n\n### 步骤2：使用提取的给定信息进行验证\n\n1.  **科学依据**：该问题在傅里叶分析和X射线晶体学原理方面有坚实的基础。结构因子和帕特森函数的定义是标准的。帕特森函数与结构因子振幅平方之间的关系是傅里叶变换卷积定理的直接推论，这是一个基本结果。将帕特森峰解释为原子间向量是帕特森方法的核心原理。所有前提在科学上都是合理的。\n2.  **良构性**：该问题是良构的。DFT及其逆变换给出了一个一致的归一化约定。亚结构重建的算法要求，包括规范标度和解决平局的规则，都足够详细，以确保每个测试用例都有一个唯一的、确定性的解。\n3.  **客观性**：问题是用精确、客观的数学语言陈述的。\n4.  **完整性**：为每个测试用例提供的所有数据（$N$、原子位置和强度）是完整且足以执行所有要求计算的。所有必要的定义都已提供。\n5.  **可行性**：网格大小（$N=32$）和原子数量（$M\\le3$）很小，使得使用标准库的快速傅里叶变换（FFT）函数进行计算是完全可行的。\n\n### 步骤3：结论与行动\n\n问题陈述是**有效的**。它是一个自洽的、科学上合理且良构的计算问题。可以继续进行求解过程。\n\n---\n\n### 解法\n\n解法分为两部分：任务1要求的理论推导，以及为任务2和3设计的计算算法。\n\n**第1部分：通过FFT计算帕特森函数的推导**\n\n这部分为高效计算帕特森函数奠定了理论基础。\n\n**1. 定义**\n\n设在 $N \\times N$ 网格上的离散电子密度为 $\\rho[x,y]$，其中 $x,y \\in \\{0, 1, \\dots, N-1\\}$。该函数是实数且非负。结构因子 $F[h,k]$ 是 $\\rho[x,y]$ 的二维离散傅里叶变换（DFT），记为 $F = \\mathcal{F}\\{\\rho\\}$：\n$$F[h,k] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(-2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right)$$\n帕特森函数 $P[u,v]$ 是 $\\rho[x,y]$ 的循环自相关：\n$$P[u,v] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\rho[(x+u) \\bmod N,(y+v) \\bmod N]$$\n逆DFT记为 $\\mathcal{F}^{-1}$，其中 $\\rho = \\mathcal{F}^{-1}\\{F\\}$。\n\n**2. 使用互相关定理进行推导**\n\nDFT互相关定理指出，两个信号互相关的DFT是第一个信号的DFT与第二个信号DFT的复共轭的乘积。由于我们是对实函数 $\\rho$ 进行自相关，这个关系得以简化。\n\n我们计算帕特森函数的DFT，$\\mathcal{F}\\{P\\}[h,k]$：\n$$ \\mathcal{F}\\{P\\}[h,k] = \\sum_{u=0}^{N-1} \\sum_{v=0}^{N-1} P[u,v] \\exp\\left(-2\\pi i \\left(\\frac{hu}{N}+\\frac{kv}{N}\\right)\\right) $$\n将 $P[u,v]$ 的定义代入方程：\n$$ \\mathcal{F}\\{P\\}[h,k] = \\sum_{u=0}^{N-1} \\sum_{v=0}^{N-1} \\left( \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\rho[(x+u) \\bmod N,(y+v) \\bmod N] \\right) \\exp\\left(-2\\pi i \\left(\\frac{hu}{N}+\\frac{kv}{N}\\right)\\right) $$\n重新排列求和顺序：\n$$ \\mathcal{F}\\{P\\}[h,k] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\left( \\sum_{u=0}^{N-1} \\sum_{v=0}^{N-1} \\rho[(x+u) \\bmod N,(y+v) \\bmod N] \\exp\\left(-2\\pi i \\left(\\frac{hu}{N}+\\frac{kv}{N}\\right)\\right) \\right) $$\n令 $x' = (x+u) \\bmod N$ 和 $y' = (y+v) \\bmod N$。这意味着 $u = (x' - x) \\bmod N$ 和 $v = (y' - y) \\bmod N$。对 $u,v$ 的内层求和可以重写为对 $x',y'$ 的求和：\n$$ \\mathcal{F}\\{P\\}[h,k] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\left( \\sum_{x'=0}^{N-1} \\sum_{y'=0}^{N-1} \\rho[x',y'] \\exp\\left(-2\\pi i \\left(\\frac{h(x'-x)}{N}+\\frac{k(y'-y)}{N}\\right)\\right) \\right) $$\n分离指数项：\n$$ \\mathcal{F}\\{P\\}[h,k] = \\left( \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right) \\right) \\left( \\sum_{x'=0}^{N-1} \\sum_{y'=0}^{N-1} \\rho[x',y'] \\exp\\left(-2\\pi i \\left(\\frac{hx'}{N}+\\frac{ky'}{N}\\right)\\right) \\right) $$\n第二项是结构因子 $F[h,k]$ 的定义。第一项是 $F[h,k]$ 的复共轭，因为 $\\rho$ 是实数（$\\rho^* = \\rho$）且 $\\exp(i\\theta)^* = \\exp(-i\\theta)$：\n$$ \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right) = \\left( \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(-2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right) \\right)^* = (F[h,k])^* $$\n因此，我们得到中心关系：\n$$ \\mathcal{F}\\{P\\}[h,k] = (F[h,k])^* F[h,k] = |F[h,k]|^2 $$\n为了得到帕特森函数 $P[u,v]$，我们对两边应用逆DFT：\n$$ P[u,v] = \\mathcal{F}^{-1} \\{ |F[h,k]|^2 \\} $$\n该推导证实了帕特森图可以通过对密度进行傅里叶变换，计算所得结构因子的振幅平方（即强度 $I[h,k]$），然后对强度进行逆傅里叶变换来计算。这种基于FFT的方法，其复杂度为 $O(N^2 \\log N)$，远比直接求和的 $O(N^4)$ 方法高效。\n\n**第2部分：算法设计与实现**\n\n完整的流程在一个Python脚本中实现。逻辑遵循问题陈述中指定的任务。\n\n1.  **电子密度构建**：初始化一个大小为 $N \\times N$ 的NumPy零数组。对于输入列表中的每个原子，将其散射强度 $f_j$ 添加到网格位置 $(x_j, y_j)$。\n\n2.  **帕特森图计算**：使用 `numpy.fft.fft2` 和 `numpy.fft.ifft2` 函数。`np.fft.fft2` 计算 $F[h,k]$。然后计算其绝对值的平方 $|F[h,k]|^2$。接着对这个强度图应用 `np.fft.ifft2`。`numpy` 的 `ifft2` 函数包含了 $1/N^2$ 的归一化因子，与问题的约定相符。取结果的实部得到 $P[u,v]$。\n\n3.  **重原子亚结构搜索**：\n    a.  **峰提取**：使用 `scipy.ndimage.maximum_filter` 和一个 $3 \\times 3$ 的窗口以及 `'wrap'` 模式（用于周期性边界）来识别帕特森图 $P[u,v]$ 中的局部最大值。对峰进行过滤，只包括那些振幅显著（大于原点峰高的 $1\\%$）的峰，以避免数值噪声。丢弃位于 $(0,0)$ 的原点峰。将得到的峰存储为元组 `(amplitude, u, v)`，并按振幅降序、然后按坐标的字典序排序。\n    b.  **贪婪嵌入**：根据规范标度，初始化一个重建原子网格坐标的列表，将第一个原子置于 $(0,0)$。\n        -   **原子2**：如果结构中不止一个原子（即存在非原点峰），则选择振幅最高的非原点峰。如果振幅有平局，则选择网格坐标字典序最小的那个。这决定了第二个原子的位置。\n        -   **原子3**：如果要寻找第三个原子，算法会遍历剩余的已排序峰。对于每个候选峰 $(u_2, v_2)$，进行一致性检查。如果候选峰与第二个原子的向量差 $(u_2-u_1 \\pmod N, v_2-v_1 \\pmod N)$ 或向量和 $(u_2+u_1 \\pmod N, v_2+v_1 \\pmod N)$ 对应于先前识别的峰集合中的一个位置，则接受该候选峰。由于峰列表是排序的，第一个满足此条件的候选峰被选中，这是确定性的。\n\n4.  **规范标度与输出格式化**：\n    -   将最终的整数网格坐标列表通过除以 $N$ 转换为分数坐标。\n    -   对这个分数坐标对的列表按字典序排序。\n    -   将排序后的坐标展平为单个浮点数列表。\n    -   将最终列表中的每个数字格式化为三位小数。\n    -   将所有测试用例的结果汇编成一个列表的列表，并打印为单个无空格的字符串，以匹配指定的输出格式 `[[...],[...],[...]]`。\n\n这种结构化的方法确保了所有问题要求都得到满足，为给定的测试用例生成了确定性和正确的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import maximum_filter\n\ndef solve():\n    \"\"\"\n    Main function to run the Patterson reconstruction pipeline for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 32, 'atoms': [((8, 5), 74)]},\n        {'N': 32, 'atoms': [((5, 9), 74), ((21, 15), 74)]},\n        {'N': 32, 'atoms': [((6, 10), 74), ((25, 22), 50), ((12, 27), 40)]}\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        atoms_data = case['atoms']\n\n        # Task 3, Step 1: Construct electron density rho[x,y]\n        rho = np.zeros((N, N), dtype=float)\n        for (x, y), f in atoms_data:\n            rho[x, y] += f\n\n        # Task 3, Step 2: Compute structure factors, intensities, and Patterson map\n        # numpy's fft/ifft conventions match the problem's requirements:\n        # - fft2: no normalization\n        # - ifft2: 1/N^2 normalization\n        F = np.fft.fft2(rho)\n        I = np.abs(F)**2\n        P = np.fft.ifft2(I).real\n\n        # Task 2  3: Implement heavy-atom substructure search\n        TOL = 1e-6 # Tolerance for floating point comparisons\n\n        # Find local maxima in the Patterson map using a maximum filter\n        p_max_filter = maximum_filter(P, size=3, mode='wrap')\n        maxima_mask = np.abs(P - p_max_filter)  TOL\n        \n        # Filter for significant peaks to avoid numerical artifacts\n        origin_peak_val = P[0, 0]\n        # A low threshold is sufficient for this clean synthetic data.\n        significant_mask = P > origin_peak_val * 0.01 \n\n        peak_coords = np.argwhere(maxima_mask  significant_mask)\n\n        # Create a list of (amplitude, u, v) for unique non-origin peaks\n        non_origin_peaks = []\n        for u, v in peak_coords:\n            if u == 0 and v == 0:\n                continue\n            non_origin_peaks.append((P[u, v], u, v))\n\n        # Sort peaks by amplitude (desc), then u (asc), then v (asc)\n        non_origin_peaks.sort(key=lambda p: (-p[0], p[1], p[2]))\n        \n        # Create a set of peak locations for efficient O(1) average-case lookup\n        peak_locations = {(u, v) for amp, u, v in non_origin_peaks}\n\n        # --- GREEDY EMBEDDING PROCEDURE ---\n        \n        reconstructed_atoms_grid = [(0, 0)] # Atom 1 at origin by convention\n\n        num_atoms_in_case = len(atoms_data)\n\n        if num_atoms_in_case > 1 and len(non_origin_peaks) > 0:\n            # Place Atom 2\n            # Find all peaks with the max amplitude\n            max_amp = non_origin_peaks[0][0]\n            top_peaks = [p for p in non_origin_peaks if abs(p[0] - max_amp)  TOL]\n            \n            # Choose the one with the lexicographically smallest index.\n            # a_priori sorting ensures top_peaks[0] is the correct choice.\n            _, u1, v1 = top_peaks[0]\n            \n            reconstructed_atoms_grid.append((u1, v1))\n\n            if num_atoms_in_case > 2 and len(non_origin_peaks) > 1:\n                # Place Atom 3\n                # Create a list of candidate peaks, excluding the one already chosen\n                candidate_peaks = [p for p in non_origin_peaks if (p[1], p[2]) != (u1, v1)]\n                \n                for _, u2, v2 in candidate_peaks:\n                    # Consistency check as per the specific problem instruction\n                    # Check 1: Difference vector\n                    diff_vec = ((u2 - u1) % N, (v2 - v1) % N)\n                    # Check 2: Sum vector\n                    sum_vec = ((u2 + u1) % N, (v2 + v1) % N)\n                    \n                    if diff_vec in peak_locations or sum_vec in peak_locations:\n                        reconstructed_atoms_grid.append((u2, v2))\n                        break\n\n        # --- CANONICAL GAUGE AND FORMATTING ---\n        \n        # Convert integer grid coordinates to fractional coordinates\n        frac_coords = [ (p[0] / N, p[1] / N) for p in reconstructed_atoms_grid ]\n        \n        # Sort the reconstructed atoms' fractional coordinates lexicographically\n        frac_coords.sort()\n\n        # Flatten the list of coordinate pairs\n        final_coords_flat = [coord for pos in frac_coords for coord in pos]\n        \n        results.append(final_coords_flat)\n\n    # Final print statement in the exact required format:\n    # A single string representing a list of lists, e.g., [[...],[...]],\n    # with no spaces and with numbers formatted to three decimal places.\n    final_output_parts = []\n    for res_list in results:\n        formatted_list_str = '[' + ','.join([f'{x:.3f}' for x in res_list]) + ']'\n        final_output_parts.append(formatted_list_str)\n    \n    print('[' + ','.join(final_output_parts) + ']')\n\nsolve()\n```", "id": "3504298"}, {"introduction": "获得初始晶体结构模型只是第一步；精确化该模型以最佳地拟合实验数据，是结构测定过程中的关键环节。现代结构精修方法采用基于梯度的优化算法，通过最小化一个描述观测与计算衍射强度差异的成本函数来实现。在此高级练习[@problem_id:3504329]中，您将推导最小二乘成本函数$C(\\{\\mathbf{r}_j\\})$相对于原子位置$\\mathbf{r}_j$的解析梯度，通过编程实现这一计算，您将深入理解驱动自动化晶体结构精修软件背后的数学引擎。", "problem": "给定一个具有有限原子集的晶体的X射线衍射（XRD）运动学散射模型。倒易空间散射振幅（也称为结构因子）是针对每个倒易空间矢量 $\\mathbf{q}$ 定义的，其值为各个原子复散射贡献的总和。原子位置矢量用 $\\mathbf{r}_j$ 表示，单位为埃（angstroms）；倒易空间矢量 $\\mathbf{q}$ 的单位为埃的倒数（inverse angstroms）；原子散射因子 $f_j(\\mathbf{q})$ 可能因反常色散而是复数值。点积 $\\mathbf{q}\\cdot\\mathbf{r}_j$ 是无量纲的，其相位单位为弧度。该模型的假设是：原子相互独立，运动学散射（无多重散射），强度是结构因子的模平方。\n\n从基本定义和标准复变函数微积分出发，推导最小二乘成本函数相对于原子位置的梯度。具体来说，仅使用以下基本定义：\n\n- 结构因子：$F(\\mathbf{q})$ 定义为\n$$\nF(\\mathbf{q}) = \\sum_{j=1}^{N_\\text{atoms}} f_j(\\mathbf{q})\\, e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j}.\n$$\n\n- 强度：$I(\\mathbf{q})$ 由下式给出\n$$\nI(\\mathbf{q}) = |F(\\mathbf{q})|^2 = F(\\mathbf{q})\\, F(\\mathbf{q})^\\ast,\n$$\n其中上标 $\\ast$ 表示复共轭。\n\n- 对于一个包含 $K$ 个倒易空间点 $\\{\\mathbf{q}_k\\}_{k=1}^K$ 的有限集合，其加权最小二乘成本函数定义为（其中观测强度为 $I_{\\text{obs}}(\\mathbf{q}_k)$，非负权重为 $w_k$）：\n$$\nC(\\{\\mathbf{r}_j\\}) = \\frac{1}{2}\\sum_{k=1}^K w_k \\left( I(\\mathbf{q}_k) - I_{\\text{obs}}(\\mathbf{q}_k) \\right)^2.\n$$\n\n你的任务：\n\n1. 从上述基本定义出发，推导梯度 $\\partial C / \\partial \\mathbf{r}_j$。你的推导过程应展示每个主要步骤，包括对 $I(\\mathbf{q})$ 应用链式法则，以及对 $F(\\mathbf{q})$ 关于 $\\mathbf{r}_j$ 进行复微分。除这些定义外，不得假设任何未经证明的导数表达式。\n\n2. 实现一个程序，为下面描述的每个测试用例计算聚合了所有原子的完整梯度矢量 $\\nabla_{\\mathbf{r}} C$ 的欧几里得范数。梯度矢量集合了所有 $j$ 的 $\\partial C / \\partial \\mathbf{r}_j$。欧几里得范数必须以浮点数形式报告，单位为“任意成本单位每埃”。\n\n3. 对所有相位 $\\mathbf{q}\\cdot\\mathbf{r}_j$ 使用弧度作为角度单位。确保所有计算都遵循以下单位：$\\mathbf{q}$ 的单位为埃的倒数，$\\mathbf{r}_j$ 的单位为埃，强度 $I(\\mathbf{q})$ 和 $I_{\\text{obs}}(\\mathbf{q})$ 的单位为任意的振幅平方单位。\n\n4. 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$。每个结果都必须是一个浮点数，对应于相应测试用例的梯度欧几里得范数。\n\n测试套件规范：\n\n- 测试用例1（一般情况，两个原子，三个$\\mathbf{q}$矢量）：\n  - 原子位置（单位：埃）：$\\mathbf{r}_1 = (0.0, 0.0, 0.0)$，$\\mathbf{r}_2 = (1.0, 0.0, 0.0)$。\n  - 倒易空间矢量（单位：埃的倒数）：$\\mathbf{q}_1 = (0.5, 0.0, 0.0)$，$\\mathbf{q}_2 = (1.0, 0.0, 0.0)$，$\\mathbf{q}_3 = (0.7, 0.3, 0.1)$。\n  - 每个$\\mathbf{q}_k$的原子散射因子：\n    - $f_1(\\mathbf{q}_1) = 10.0$, $f_1(\\mathbf{q}_2) = 9.5$, $f_1(\\mathbf{q}_3) = 9.0$。\n    - $f_2(\\mathbf{q}_1) = 7.0$, $f_2(\\mathbf{q}_2) = 6.5$, $f_2(\\mathbf{q}_3) = 6.0$。\n    在此测试用例中，所有 $f_j(\\mathbf{q}_k)$ 均为实数。\n  - 观测强度：$I_{\\text{obs}}(\\mathbf{q}_1) = 320.0$, $I_{\\text{obs}}(\\mathbf{q}_2) = 250.0$, $I_{\\text{obs}}(\\mathbf{q}_3) = 200.0$。\n  - 权重：$w_1 = 1.0$, $w_2 = 1.0$, $w_3 = 1.0$。\n\n- 测试用例2（边界条件 $\\mathbf{q}=\\mathbf{0}$）：\n  - 原子位置（单位：埃）：$\\mathbf{r}_1 = (0.3, -0.2, 0.1)$。\n  - 倒易空间矢量（单位：埃的倒数）：$\\mathbf{q}_1 = (0.0, 0.0, 0.0)$。\n  - 原子散射因子：$f_1(\\mathbf{q}_1) = 12.0$。\n  - 观测强度：$I_{\\text{obs}}(\\mathbf{q}_1) = 100.0$。\n  - 权重：$w_1 = 1.0$。\n\n- 测试用例3（零残差，梯度应为零）：\n  - 原子位置（单位：埃）：$\\mathbf{r}_1 = (0.25, 0.0, 0.0)$, $\\mathbf{r}_2 = (0.0, 0.4, 0.0)$。\n  - 倒易空间矢量（单位：埃的倒数）：$\\mathbf{q}_1 = (1.1, 0.0, 0.0)$, $\\mathbf{q}_2 = (0.0, 1.2, 0.0)$。\n  - 每个$\\mathbf{q}_k$的原子散射因子：\n    - $f_1(\\mathbf{q}_1) = 11.0$, $f_1(\\mathbf{q}_2) = 10.0$。\n    - $f_2(\\mathbf{q}_1) = 6.0$, $f_2(\\mathbf{q}_2) = 5.0$。\n  - 观测强度被定义为等于在这些位置和散射因子下模型预测的强度，即使用基本定义计算出的 $I_{\\text{obs}}(\\mathbf{q}_k) = |F(\\mathbf{q}_k)|^2$（对于$k\\in\\{1,2\\}$）。\n  - 权重：$w_1 = 1.0$, $w_2 = 1.0$。\n\n- 测试用例4（反常色散，复散射因子）：\n  - 原子位置（单位：埃）：$\\mathbf{r}_1 = (0.2, 0.1, 0.0)$。\n  - 倒易空间矢量（单位：埃的倒数）：$\\mathbf{q}_1 = (0.8, 0.1, 0.0)$, $\\mathbf{q}_2 = (0.5, 0.2, 0.3)$。\n  - 每个$\\mathbf{q}_k$的原子散射因子：\n    - $f_1(\\mathbf{q}_1) = 4.0 + 0.5\\,i$, $f_1(\\mathbf{q}_2) = 3.0 - 0.2\\,i$。\n  - 观测强度：$I_{\\text{obs}}(\\mathbf{q}_1) = 50.0$, $I_{\\text{obs}}(\\mathbf{q}_2) = 60.0$。\n  - 权重：$w_1 = 1.0$, $w_2 = 1.0$。\n\n你的程序必须为以上四个测试用例中的每一个计算梯度矢量 $\\nabla_{\\mathbf{r}} C$ 的欧几里得范数，并以 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$ 的格式打印单行结果，其中每个 $\\text{result}_k$ 都是一个浮点数。不允许有其他输出。", "solution": "目标是基于X射线衍射的运动学模型，推导最小二乘成本函数相对于晶体中原子位置的解析梯度，然后实现一个程序来计算该梯度在几个测试用例中的范数。\n\n推导将从所提供的基本定义开始。设 $\\mathbf{r}_j$ 为第 $j$ 个原子的位置矢量，$\\mathbf{q}_k$ 为一个倒易空间矢量。\n\n成本函数 $C$ 由下式给出：\n$$\nC(\\{\\mathbf{r}_j\\}) = \\frac{1}{2}\\sum_{k=1}^K w_k \\left( I(\\mathbf{q}_k) - I_{\\text{obs}}(\\mathbf{q}_k) \\right)^2\n$$\n其中 $I(\\mathbf{q}_k)$ 是计算出的强度，$I_{\\text{obs}}(\\mathbf{q}_k)$ 是倒易空间矢量 $\\mathbf{q}_k$ 的观测强度。\n\n我们寻求 $C$ 相对于第 $j$ 个原子的位置矢量 $\\mathbf{r}_j$ 的梯度。该梯度是一个矢量，记为 $\\frac{\\partial C}{\\partial \\mathbf{r}_j}$。对成本函数应用链式求导法则，我们得到：\n$$\n\\frac{\\partial C}{\\partial \\mathbf{r}_j} = \\sum_{k=1}^K w_k \\left( I(\\mathbf{q}_k) - I_{\\text{obs}}(\\mathbf{q}_k) \\right) \\frac{\\partial I(\\mathbf{q}_k)}{\\partial \\mathbf{r}_j}\n$$\n此表达式需要计算强度的梯度，即 $\\frac{\\partial I(\\mathbf{q}_k)}{\\partial \\mathbf{r}_j}$。强度 $I(\\mathbf{q})$ 定义为结构因子 $F(\\mathbf{q})$ 的模平方：\n$$\nI(\\mathbf{q}) = |F(\\mathbf{q})|^2 = F(\\mathbf{q}) F(\\mathbf{q})^\\ast\n$$\n其中 $F(\\mathbf{q})^\\ast$ 是 $F(\\mathbf{q})$ 的复共轭。为对 $I(\\mathbf{q})$ 求导，我们使用乘积法则。为清晰起见，我们暂时省略下标 $k$：\n$$\n\\frac{\\partial I(\\mathbf{q})}{\\partial \\mathbf{r}_j} = \\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} F(\\mathbf{q})^\\ast + F(\\mathbf{q}) \\frac{\\partial F(\\mathbf{q})^\\ast}{\\partial \\mathbf{r}_j}\n$$\n由于原子位置 $\\mathbf{r}_j$ 是实值矢量，因此关于 $\\mathbf{r}_j$ 的微分与复共轭运算是可交换的：\n$$\n\\frac{\\partial F(\\mathbf{q})^\\ast}{\\partial \\mathbf{r}_j} = \\left( \\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} \\right)^\\ast\n$$\n将此代入强度梯度的表达式中，得到：\n$$\n\\frac{\\partial I(\\mathbf{q})}{\\partial \\mathbf{r}_j} = \\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} F(\\mathbf{q})^\\ast + F(\\mathbf{q}) \\left( \\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} \\right)^\\ast\n$$\n此表达式的形式为 $z + z^\\ast$，其中 $z = F(\\mathbf{q}) \\left( \\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} \\right)^\\ast$ 或其共轭。对于任意复数 $z$，有 $z+z^\\ast = 2\\,\\text{Re}(z)$。因此，我们可以写成：\n$$\n\\frac{\\partial I(\\mathbf{q})}{\\partial \\mathbf{r}_j} = 2\\,\\text{Re} \\left[ F(\\mathbf{q})^\\ast \\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} \\right]\n$$\n下一步是求结构因子的梯度 $\\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j}$。结构因子定义为：\n$$\nF(\\mathbf{q}) = \\sum_{l=1}^{N_\\text{atoms}} f_l(\\mathbf{q})\\, e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_l}\n$$\n对 $\\mathbf{r}_j$ 求导（为避免混淆，使用不同的求和索引 $l$）：\n$$\n\\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} = \\frac{\\partial}{\\partial \\mathbf{r}_j} \\sum_{l=1}^{N_\\text{atoms}} f_l(\\mathbf{q})\\, e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_l}\n$$\n微分算子可以穿过求和符号。只有当 $l=j$ 时，导数才非零：\n$$\n\\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} = f_j(\\mathbf{q}) \\frac{\\partial}{\\partial \\mathbf{r}_j} \\left( e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j} \\right)\n$$\n使用矢量微积分的链式法则 $\\nabla_{\\mathbf{x}} e^{u(\\mathbf{x})} = e^{u(\\mathbf{x})} \\nabla_{\\mathbf{x}} u(\\mathbf{x})$，其中 $u(\\mathbf{r}_j) = i\\,\\mathbf{q}\\cdot \\mathbf{r}_j$。标量场 $\\mathbf{q}\\cdot \\mathbf{r}_j$ 相对于 $\\mathbf{r}_j$ 的梯度就是 $\\mathbf{q}$。因此：\n$$\n\\frac{\\partial}{\\partial \\mathbf{r}_j} \\left( e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j} \\right) = e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j} (i\\,\\mathbf{q}) = i\\,\\mathbf{q}\\,e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j}\n$$\n这产生一个复矢量（一个实矢量 $\\mathbf{q}$ 乘以一个复标量）。结构因子的梯度是：\n$$\n\\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} = i\\,\\mathbf{q}\\,f_j(\\mathbf{q})\\,e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j}\n$$\n现在，我们将其代回强度梯度的表达式：\n$$\n\\frac{\\partial I(\\mathbf{q})}{\\partial \\mathbf{r}_j} = 2\\,\\text{Re} \\left[ F(\\mathbf{q})^\\ast \\left( i\\,\\mathbf{q}\\,f_j(\\mathbf{q})\\,e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j} \\right) \\right]\n$$\n实矢量 $\\mathbf{q}$ 和标量 $2$ 可以从实部算子中提取出来：\n$$\n\\frac{\\partial I(\\mathbf{q})}{\\partial \\mathbf{r}_j} = 2\\,\\mathbf{q}\\,\\text{Re} \\left[ i\\,F(\\mathbf{q})^\\ast f_j(\\mathbf{q})\\,e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j} \\right]\n$$\n对于任意复数 $z$，使用恒等式 $\\text{Re}(iz) = -\\text{Im}(z)$，我们发现：\n$$\n\\frac{\\partial I(\\mathbf{q})}{\\partial \\mathbf{r}_j} = -2\\,\\mathbf{q}\\,\\text{Im} \\left[ F(\\mathbf{q})^\\ast f_j(\\mathbf{q})\\,e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j} \\right]\n$$\n最后，我们将此结果代回成本函数梯度的表达式中，并重新引入用于对倒易空间点求和的索引 $k$：\n$$\n\\frac{\\partial C}{\\partial \\mathbf{r}_j} = \\sum_{k=1}^K w_k \\left( I(\\mathbf{q}_k) - I_{\\text{obs}}(\\mathbf{q}_k) \\right) \\left( -2\\,\\mathbf{q}_k\\,\\text{Im} \\left[ F(\\mathbf{q}_k)^\\ast f_j(\\mathbf{q}_k)\\,e^{i\\,\\mathbf{q}_k\\cdot \\mathbf{r}_j} \\right] \\right)\n$$\n整理各项，得到成本函数相对于原子 $j$ 位置的梯度的最终表达式：\n$$\n\\frac{\\partial C}{\\partial \\mathbf{r}_j} = -2 \\sum_{k=1}^K w_k \\left( I(\\mathbf{q}_k) - I_{\\text{obs}}(\\mathbf{q}_k) \\right) \\mathbf{q}_k \\text{Im} \\left[ F(\\mathbf{q}_k)^\\ast f_j(\\mathbf{q}_k)\\,e^{i\\,\\mathbf{q}_k\\cdot \\mathbf{r}_j} \\right]\n$$\n这是一个矢量和。总梯度 $\\nabla_{\\mathbf{r}}C$ 是所有这些矢量梯度 $\\{\\frac{\\partial C}{\\partial \\mathbf{r}_j}\\}_{j=1}^{N_\\text{atoms}}$ 的集合。问题要求计算这个总梯度的欧几里得范数，它是一个 $3N_\\text{atoms}$ 维空间中的矢量。\n\n数值实现的算法如下：\n1. 对于每个测试用例，初始化一个列表以存储每个原子的梯度矢量。\n2. 对于从 $1$ 到 $N_\\text{atoms}$ 的每个原子 $j$：\n   a. 将其梯度矢量 $\\mathbf{g}_j = \\frac{\\partial C}{\\partial \\mathbf{r}_j}$ 初始化为零。\n   b. 对于从 $1$ 到 $K$ 的每个倒易空间点 $k$：\n      i. 计算结构因子 $F(\\mathbf{q}_k) = \\sum_{l=1}^{N_\\text{atoms}} f_l(\\mathbf{q}_k)\\,e^{i\\,\\mathbf{q}_k\\cdot \\mathbf{r}_l}$。\n      ii. 计算模型强度 $I(\\mathbf{q}_k) = |F(\\mathbf{q}_k)|^2$。\n      iii. 计算差值 $\\Delta I_k = I(\\mathbf{q}_k) - I_{\\text{obs}}(\\mathbf{q}_k)$。\n      iv. 计算虚部算子内的复数值：$Z_{jk} = F(\\mathbf{q}_k)^\\ast f_j(\\mathbf{q}_k)\\,e^{i\\,\\mathbf{q}_k\\cdot \\mathbf{r}_j}$。\n      v. 计算梯度贡献的标量因子：$S_{jk} = -2\\,w_k\\,\\Delta I_k\\,\\text{Im}(Z_{jk})$。\n      vi. 将矢量贡献加到梯度上：$\\mathbf{g}_j \\leftarrow \\mathbf{g}_j + S_{jk}\\,\\mathbf{q}_k$。\n   c. 存储原子 $j$ 的最终梯度矢量 $\\mathbf{g}_j$。\n3. 将所有单个梯度矢量 $\\{\\mathbf{g}_j\\}$ 拼接成一个代表 $\\nabla_{\\mathbf{r}}C$ 的单一扁平矢量。\n4. 计算并存储此合并梯度矢量的欧几里得范数。\n5. 对所有测试用例重复此过程，并按要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Euclidean norm of the gradient of a least-squares cost function \n    with respect to atomic positions for several X-ray diffraction scenarios.\n    \"\"\"\n    \n    # Test Case 1: General case, two atoms, three q-vectors.\n    test_case_1 = {\n        'r': np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0]]), # angstroms\n        'q': np.array([[0.5, 0.0, 0.0], [1.0, 0.0, 0.0], [0.7, 0.3, 0.1]]), # 1/angstroms\n        'f': np.array([[10.0, 9.5, 9.0], [7.0, 6.5, 6.0]], dtype=complex), # atomic scattering factors\n        'I_obs': np.array([320.0, 250.0, 200.0]), # arbitrary units\n        'w': np.array([1.0, 1.0, 1.0]) # weights\n    }\n\n    # Test Case 2: Boundary condition q=0. Gradient should be zero.\n    test_case_2 = {\n        'r': np.array([[0.3, -0.2, 0.1]]),\n        'q': np.array([[0.0, 0.0, 0.0]]),\n        'f': np.array([[12.0]], dtype=complex),\n        'I_obs': np.array([100.0]),\n        'w': np.array([1.0])\n    }\n\n    # Test Case 3: Zero residuals. Gradient should be zero.\n    # First, calculate I_obs for this case.\n    r3 = np.array([[0.25, 0.0, 0.0], [0.0, 0.4, 0.0]])\n    q3 = np.array([[1.1, 0.0, 0.0], [0.0, 1.2, 0.0]])\n    f3 = np.array([[11.0, 10.0], [6.0, 5.0]], dtype=complex)\n    I_obs3 = []\n    for k in range(q3.shape[0]):\n        F_k = 0.0\n        for l in range(r3.shape[0]):\n            phase = np.dot(q3[k], r3[l])\n            F_k += f3[l, k] * np.exp(1j * phase)\n        I_obs3.append(np.abs(F_k)**2)\n    \n    test_case_3 = {\n        'r': r3,\n        'q': q3,\n        'f': f3,\n        'I_obs': np.array(I_obs3),\n        'w': np.array([1.0, 1.0])\n    }\n\n    # Test Case 4: Anomalous dispersion (complex f).\n    test_case_4 = {\n        'r': np.array([[0.2, 0.1, 0.0]]),\n        'q': np.array([[0.8, 0.1, 0.0], [0.5, 0.2, 0.3]]),\n        'f': np.array([[4.0 + 0.5j, 3.0 - 0.2j]], dtype=complex),\n        'I_obs': np.array([50.0, 60.0]),\n        'w': np.array([1.0, 1.0])\n    }\n\n    test_cases = [test_case_1, test_case_2, test_case_3, test_case_4]\n    results = []\n\n    for case in test_cases:\n        r = case['r']\n        q = case['q']\n        f = case['f']\n        I_obs = case['I_obs']\n        w = case['w']\n\n        n_atoms = r.shape[0]\n        n_q_pts = q.shape[0]\n        \n        all_grad_components = []\n\n        for j in range(n_atoms):\n            grad_j = np.zeros(3)\n            for k in range(n_q_pts):\n                # Calculate structure factor F(q_k)\n                F_k = 0.0 + 0.0j\n                for l in range(n_atoms):\n                    phase = np.dot(q[k], r[l])\n                    F_k += f[l, k] * np.exp(1j * phase)\n                \n                # Calculate model intensity I(q_k) and residual\n                I_k = np.abs(F_k)**2\n                delta_I_k = I_k - I_obs[k]\n                \n                # If residual is zero, contribution is zero.\n                if np.isclose(delta_I_k, 0):\n                    continue\n\n                # Calculate the complex term and its imaginary part\n                phase_j = np.dot(q[k], r[j])\n                term_in_imag = F_k.conj() * f[j, k] * np.exp(1j * phase_j)\n                imag_part = term_in_imag.imag\n                \n                # Add contribution to gradient for atom j\n                grad_j += -2.0 * w[k] * delta_I_k * q[k] * imag_part\n            \n            all_grad_components.append(grad_j)\n\n        # Concatenate all gradient vectors into one large vector\n        if all_grad_components:\n            full_gradient_vector = np.concatenate(all_grad_components)\n        else:\n            full_gradient_vector = np.array([])\n            \n        # Compute the Euclidean norm of the full gradient vector\n        norm = np.linalg.norm(full_gradient_vector)\n        results.append(norm)\n\n    # Print results in the specified format\n    print(f\"[{','.join(f'{res:.10f}' for res in results)}]\")\n\nsolve()\n```", "id": "3504329"}]}