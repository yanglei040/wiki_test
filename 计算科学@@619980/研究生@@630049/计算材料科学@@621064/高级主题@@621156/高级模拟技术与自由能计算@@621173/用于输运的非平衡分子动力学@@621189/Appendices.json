{"hands_on_practices": [{"introduction": "在投入计算成本高昂的非平衡分子动力学 (NEMD) 模拟之前，制定一个清晰而严谨的验证计划至关重要。本练习强调了多方面验证过程的重要性，涵盖了积分器稳定性、恒温器功效、线性响应确认和统计可复现性等方面。通过掌握这些概念，您可以避免常见的陷阱，并确保最终计算出的输运系数具有物理意义且值得信赖 [@problem_id:3469000]。", "problem": "一位研究人员使用非平衡分子动力学 (NEMD) 来计算晶体的输运系数，方法是在模拟盒子两端的两个恒温热源板之间施加一个稳态通量，中间夹着一个非恒温的体区。该系统使用速度Verlet算法进行积分，时间步长为 $\\Delta t$，并在与施加梯度垂直的方向上应用周期性边界条件。目标测量是在线性响应区内由受控的热力学力驱动的稳态通量 $J$（例如，服从傅里叶定律的温度梯度 $\\nabla T$ 或服从欧姆定律的电场 $E$）。在报告输运系数之前，研究人员必须验证四个方面：能量守恒（在适用情况下）、恒温器效能、体区内的梯度线性度以及跨独立运行的可复现性。\n\n仅从经典力学（牛顿定律）和统计力学（系综定义和能量均分）的基本原理出发，为所述的NEMD设置选择一个能够以科学上合理且自洽的方式正确处理所有四个方面的验证方案。\n\nA. 在整个系统上施加外场的同时，在微正则系综（粒子数、体积和能量恒定）中执行一次长的生产运行，通过检查总能量 $E$ 在数值容差范围内保持恒定来验证能量守恒。通过确保整个模拟盒子中的瞬时动能温度 $T(t)$ 在任何时候都等于目标温度 $T_{0}$ 来确认恒温器效能。通过将稳态温度分布 $T(x)$ 拟合到二次多项式并确认存在非零曲率来评估梯度线性度。从这次单次运行中报告输运系数。\n\nB. 在等温等压系综（粒子数、压力和温度恒定）中使系统平衡，然后切换到NEMD，在边界板上使用Nosé–Hoover恒温器，体区内无恒温器。通过确认尽管施加了外场，体区的总能量 $E_{\\text{bulk}}$ 在稳态期间保持恒定来验证能量守恒。通过检查体区内的平均动能温度 $\\langle T \\rangle$ 等于热源设定点 $T_{0}$ 来确认恒温器效能。通过仅在热源附近将 $T(x)$ 与线性拟合进行比较来评估梯度线性度。如果单次运行的估计值在先前文献值的 $5\\%$ 以内，则报告输运系数。\n\nC. 在NEMD期间对所有原子应用朗之万恒温器，以在各处维持目标温度 $T_{0}$。通过确保瞬时动能 $K(t)$ 恒定来验证能量守恒。通过施加一个大的温差 $\\Delta T$ 以最大化 $|\\nabla T|$ 来评估梯度线性度，并确认 $T(x)$ 中指示强驱动的曲率。跳过可复现性检查，因为随机恒温器可确保在一次运行中进行遍历采样。\n\nD. 通过运行零场微正则测试（无外部驱动，任何地方都无恒温器）来验证积分器，并确认总能量 $E$ 在严格的容差范围内守恒，能量漂移的标度为 $\\mathcal{O}(\\Delta t^{2})$。对于NEMD，仅对热源板应用恒温器；体区不使用恒温器。通过确认热源板维持目标温度 $T_{0}$，恒温板中的速度分布是麦克斯韦-玻尔兹曼分布 $P(v)\\propto \\exp\\!\\left(-m v^{2}/(2 k_{B} T_{0})\\right)$，并且能量均分成立，即对于 $f$ 个二次自由度有 $\\langle K\\rangle = (f/2)\\,k_{B} T_{0}$，来验证恒温器效能。通过 (i) 测量稳态分布 $T(x)$ 并确认其在体区内（排除Kapitza跳变区域）是线性的，以及 (ii) 使用不同的小 $\\Delta T$ 或场强进行至少两次驱动，并证明通量 $J$ 在不确定度范围内与驱动力呈线性关系（例如 $J\\propto \\nabla T$），来验证梯度线性度。通过执行多个具有不同初始条件或随机种子的统计独立运行，为每次运行计算输运系数，通过使用考虑自相关的块长度进行分块平均来估计不确定度，并确认各次运行之间的一致性（例如，置信区间重叠和在重新分块下均值稳定），来建立可复现性。\n\nE. 在NEMD期间使用周期性动能重标来在各处维持 $T_{0}$。通过确保扩展能量（系统加上重标功）恒定来验证能量守恒。通过将 $T(x)$ 拟合为二次函数并将小曲率接受为数值噪声来评估梯度线性度。通过使用相同的初始构型重复分析并报告两次相同运行的平均值来建立可复现性。\n\n选择一个能够为所述NEMD协议提出科学上正确且完整的验证方案，以解决能量守恒（如适用）、恒温器效能、梯度线性和可复现性问题的选项。", "solution": "问题描述了一种标准的边界驱动非平衡分子动力学（NEMD）模拟，旨在计算晶体在线性响应区内的输运系数。该设置涉及恒温热源和一个非恒温的体区，稳态通量穿过该体区。问题要求确定正确的验证方案，该方案能解决四个关键方面：能量守恒、恒温器效能、梯度线性度和可复现性。该问题具有科学依据，提法恰当且客观。它描述了计算材料科学中一种常用且有效的技术。因此，问题陈述是有效的，可以从统计力学和数值模拟的基本原理推导出解决方案。\n\n一个正确的验证方案必须遵循以下原则：\n\n1.  **能量守恒**：在带有恒温器的NEMD模拟中，能量与外部热源持续交换以维持非平衡稳态。因此，模拟盒子的总能量**不是**一个守恒量。能量守恒原理反而用于验证数值积分器（例如速度Verlet算法）本身。正确的做法是，在微正则（$NVE$）系综中进行一次初步模拟——没有恒温器，没有外部驱动力——并验证系统总能量在很长一段时间内以高精度守恒。对于像速度Verlet这样的辛积分器，任何残余的能量漂移都应与时间步长的平方成比例，即 $\\mathcal{O}(\\Delta t^{2})$。\n\n2.  **恒温器效能**：恒温器仅应用于热源板，作为输运量（如热量）的源和汇。必须*在那些特定区域*检查其效能。一个有效的检查涉及多个标准：\n    *   每个热源板内粒子的时间平均动能温度必须与其目标设定点温度 $T_{0}$ 相匹配。\n    *   由于温度是一个统计量，需要更严格的检查以确保恒温器能生成正确的正则系综统计数据。恒温板中粒子的速度分布应符合麦克斯韦-玻尔兹曼分布 $P(v) \\propto \\exp(-m v^{2} / (2 k_B T_{0}))$。\n    *   因此，能量均分定理必须成立，即每个二次自由度 $f$ 的平均动能为 $\\langle K \\rangle = (f/2) k_B T_{0}$。\n    期望非恒温体区的温度与热源温度相匹配是错误的，因为模拟的目的是在该区域建立梯度。\n\n3.  **梯度线性度与线性响应**：问题指明测量是在线性响应区内进行的。对于热输运，这意味着傅里叶定律 $J = -\\kappa \\nabla T$。对于稳态通量 $J$ 和在该温度范围内热导率 $\\kappa$ 近似恒定的材料，温度梯度 $\\nabla T$ 必须是恒定的。这意味着沿输运方向的温度分布 $T(x)$ 在材料体区内部必须是线性的。由于界面（Kapitza）热阻，温度分布通常在热源和体区之间的界面处表现出急剧的跳变或非线性。在拟合梯度时必须排除这些区域。此外，为了确认在线性响应区内操作，必须证明通量 $J$ 与驱动力（例如 $\\nabla T$）成正比。这需要对至少两个不同的小驱动力幅度进行模拟，并验证所得通量呈线性标度。单次模拟无法确认线性响应。\n\n4.  **可复现性与不确定度量化**：分子动力学模拟是确定性的但也是混沌的，这意味着初始条件的微小变化会导致轨迹发散。一个科学上有效的结果必须是可复现的，并附有对其统计不确定度的稳健估计。仅依赖单次模拟运行是不够的。标准方案是执行多次（>2）统计独立的模拟，通常通过使用不同的初始随机速度来实现。为每次运行计算输运系数。最终报告的值是这些独立结果的平均值，而不确定度根据它们的方差来估计。在每次运行内部，可以使用分块平均等技术来估计该单次轨迹均值的不确定度，但这必须考虑数据中的时间相关性。跨独立运行比较结果是检验可复现性的最严格方法。\n\n基于这些原则，我们评估每个选项：\n\n**选项A**：该选项存在根本性缺陷。它错误地建议在微正则系综中运行NEMD模拟并检查总能量守恒，这在边界驱动的NEMD设置中是不可能的，因为能量在不断地加入和移除。它错误地指出瞬时温度应在任何地方都保持恒定，这与创建梯度的目标相矛盾。它还错误地暗示温度分布中的*非零曲率*是可取的，而在线性响应区中，线性才是恒定热导率的预期特征。它通过依赖单次运行而未能解决可复现性问题。**不正确**。\n\n**选项B**：该选项包含多个错误。它错误地建议通过检查体区能量（$E_{\\text{bulk}}$）来验证能量守恒；净能量通量穿过体区，因此其能量不守恒。它错误地识别了恒温器效能的检查，将其应用于体区而非恒温热源。它错误地建议仅在热源附近拟合温度分布的线性度，而这恰恰是预期出现非线性Kapitza效应的地方。最后，它提出了一个不科学的验证标准，即与文献值进行比较，并且未能为可复现性执行独立运行。**不正确**。\n\n**选项C**：该选项描述了一种设置——将所有原子恒温至单一温度——这与用于创建梯度的直接NEMD方法不兼容。它会导致一个不存在稳态通量的平衡系统。其验证步骤也是错误的：在朗之万恒温器下，瞬时动能不是恒定的，当需要小驱动力以实现线性响应时，却使用了大驱动力，并且当预期为线性时却寻求曲率。它错误地忽略了可复现性检查。**不正确**。\n\n**选项D**：该选项提出了一个完全正确和全面的验证方案。\n1.  **能量守恒**：它正确地指出应在初步的微正则（$NVE$）运行中检查能量守恒以验证积分器，并指出了预期的误差标度 $\\mathcal{O}(\\Delta t^2)$。\n2.  **恒温器效能**：它正确地指定恒温器仅位于热源上，并提出了一个严格的检查，包括维持平均温度、确认麦克斯韦-玻尔兹曼分布以及验证*在热源板中*的能量均分。\n3.  **梯度线性度**：它正确地描述了检查*体区内*的线性温度分布，排除了界面区域。至关重要的是，它包括了在多个小驱动力下进行模拟以确认通量和梯度之间的线性关系的必要步骤，这正是线性响应区的定义。\n4.  **可复现性**：它正确地要求执行多个具有不同初始条件的独立运行，并概述了一个合理的不确定度估计和确认一致性的程序。\n该方案符合该领域的既定最佳实践。**正确**。\n\n**选项E**：该选项建议在各处使用粗糙的速度重标恒温器，这与选项C一样，是生成输运梯度的不正确设置。它误用了扩展能量的概念。它建议将温度分布中的曲率接受为噪声，这是不良的科学实践。最严重的是，其可复现性测试——对两次相同运行取平均值——在科学上是无意义的，并显示出对统计独立性的根本误解。**不正确**。\n\n综上所述，选项D是唯一一个为所述NEMD模拟的验证提供了科学上合理、严谨且完整方案的选项。", "answer": "$$\\boxed{D}$$", "id": "3469000"}, {"introduction": "标准的 NEMD 输运性质模拟会生成温度、速度或其他场的空间分布剖面。本练习模拟了后处理这些数据的基本任务，以提取有意义的物理量。该实践植根于局部平衡假设，即在弱梯度下，系统的体区 (bulk region) 会表现出与宏观输运定律（如傅里叶定律或牛顿粘性定律）一致的线性剖面。通过实施一个能够识别线性体区并量化边界效应的数据分析流程，您将掌握从原始模拟输出中准确确定输运梯度的核心技能 [@problem_id:3469013]。", "problem": "给定一个一维稳态边界驱动非平衡分子动力学 (NEMD) 的构型，该构型为一个长度为 $L$ 的平板，沿 $x$ 轴被划分为 $N$ 个空间箱。每个空间箱具有中心坐标 $x_i$ 和测得的稳态箱平均场：温度 $T_i$ (单位为开尔文) 和流向速度 $u_i$ (单位为米/秒)。恒温区域在左边界占据 $W_L$ 个空间箱，在右边界占据 $W_R$ 个空间箱。目标是通过拟合线性区域来提取体梯度，并量化靠近恒温区域的边界层偏差。\n\n基本原理和假设：\n- 对于具有恒定输运系数的简单流体，在一维均匀驱动下，热量和动量的稳态输运意味着温度和速度的体分布呈线性，前提是体区域没有受到直接的恒温控制。当结合稳态平衡和体相中无源项的条件时，这一结论可从 Fourier 定律和 Newtonian 本构关系推导得出。\n- 恒温区域会在边界附近引入非体相行为；为防止对体拟合的污染，除了恒温箱本身，还必须排除与每个恒温区域相邻的 $g$ 个空间箱作为保护层。\n\n对于每个测试用例，你的程序必须执行以下操作：\n1. 构建 $i \\in \\{0,\\dots,N-1\\}$ 的 $x_i$ 作为空间箱中心 $x_i = \\left(i + \\frac{1}{2}\\right)\\Delta x$，其中 $\\Delta x = L/N$。\n2. 通过排除左恒温区域 $\\{0,\\dots,W_L-1\\}$ 和右恒温区域 $\\{N-W_R,\\dots,N-1\\}$ 中的索引，然后再排除每个区域旁边 $g=1$ 个空间箱的额外保护层，来确定体拟合区域。也就是说，仅对索引 $i \\in \\{W_L+g,\\dots,N-W_R-g-1\\}$ 进行拟合。\n3. 使用普通最小二乘法，在体区域上拟合线性模型 $T(x) \\approx a_T x + b_T$ 和 $u(x) \\approx a_u x + b_u$，以提取体梯度 $a_T = dT/dx$ 和 $a_u = du/dx$。报告 $a_T$ (单位为 $\\mathrm{K}/\\mathrm{m}$) 和 $a_u$ (单位为 $\\mathrm{s}^{-1}$)。\n4. 通过分别为每一侧计算以下值，来量化恒温区域中的偏差：\n   - 每个恒温区域旁第一个体区域空间箱处的界面跳跃，定义为该位置的测量值减去体拟合的预测值。在左侧，使用第一个体区域索引 $i_L = W_L + g$ 并计算 $J_T^{(L)} = T_{i_L} - (a_T x_{i_L} + b_T)$ 和 $J_u^{(L)} = u_{i_L} - (a_u x_{i_L} + b_u)$；在右侧，使用 $i_R = N - W_R - g - 1$ 并类似地计算 $J_T^{(R)}$ 和 $J_u^{(R)}$。报告 $J_T^{(L)}$ 和 $J_T^{(R)}$ (单位为 $\\mathrm{K}$)，以及 $J_u^{(L)}$ 和 $J_u^{(R)}$ (单位为 $\\mathrm{m}/\\mathrm{s}$)。\n   - 每个恒温区域内相对于体拟合的均方根 (RMS) 偏差，并用相应场在整个区域上的体总降进行归一化。对于左侧恒温区域索引 $\\{0,\\dots,W_L-1\\}$ 和右侧恒温区域索引 $\\{N-W_R,\\dots,N-1\\}$，计算残差 $T_i - (a_T x_i + b_T)$ 和 $u_i - (a_u x_i + b_u)$ 的 RMS。将温度 RMS 用 $\\left|a_T\\right| L$ 归一化，速度 RMS 用 $\\left|a_u\\right| L$ 归一化。以小数形式报告无量纲值 $D_T^{(L)}$、$D_T^{(R)}$、$D_u^{(L)}$ 和 $D_u^{(R)}$。所有提供的测试用例都具有非零的体梯度，因此归一化是良定义的。\n5. 对于每个测试用例，按以下固定顺序输出结果列表：\n   - $a_T$ (单位为 $\\mathrm{K}/\\mathrm{m}$)，\n   - $a_u$ (单位为 $\\mathrm{s}^{-1}$)，\n   - $J_T^{(L)}$ (单位为 $\\mathrm{K}$)，\n   - $J_T^{(R)}$ (单位为 $\\mathrm{K}$)，\n   - $J_u^{(L)}$ (单位为 $\\mathrm{m}/\\mathrm{s}$)，\n   - $J_u^{(R)}$ (单位为 $\\mathrm{m}/\\mathrm{s}$)，\n   - $D_T^{(L)}$ (无量纲)，\n   - $D_T^{(R)}$ (无量纲)，\n   - $D_u^{(L)}$ (无量纲)，\n   - $D_u^{(R)}$ (无量纲)。\n\n测试套件构建：\n- 对于每个测试用例，你必须根据指定的参数按如下方式合成 $T_i$ 和 $u_i$。对于 $i \\in \\{0,\\dots,N-1\\}$：\n  - $x_i = \\left(i + \\frac{1}{2}\\right)\\Delta x$，其中 $\\Delta x = L/N$。\n  - 基准线性场：\n    - $T_i^{\\mathrm{lin}} = T_0 + a_T^{\\mathrm{true}} x_i$，\n    - $u_i^{\\mathrm{lin}} = u_0 + a_u^{\\mathrm{true}} x_i$。\n  - 仅在恒温箱内部施加的恒温器局部偏差：\n    - 左侧恒温区域索引 $i \\in \\{0,\\dots,W_L-1\\}$：\n      - $T_i \\leftarrow T_i^{\\mathrm{lin}} + A_T^{(L)} \\exp\\left(-\\frac{x_i}{\\ell_T^{(L)}}\\right)$,\n      - $u_i \\leftarrow u_i^{\\mathrm{lin}} + A_u^{(L)} \\exp\\left(-\\frac{x_i}{\\ell_u^{(L)}}\\right)$.\n    - 右侧恒温区域索引 $i \\in \\{N-W_R,\\dots,N-1\\}$：\n      - $T_i \\leftarrow T_i^{\\mathrm{lin}} + A_T^{(R)} \\exp\\left(-\\frac{L - x_i}{\\ell_T^{(R)}}\\right)$,\n      - $u_i \\leftarrow u_i^{\\mathrm{lin}} + A_u^{(R)} \\exp\\left(-\\frac{L - x_i}{\\ell_u^{(R)}}\\right)$.\n    - 在添加噪声之前，所有其他索引（体区域）的值为 $T_i \\leftarrow T_i^{\\mathrm{lin}}$ 和 $u_i \\leftarrow u_i^{\\mathrm{lin}}$。\n  - 施加于所有空间箱的微小空间平滑噪声：\n    - $T_i \\leftarrow T_i + A_T^{\\mathrm{noise}} \\sin\\!\\left(2\\pi k_T \\frac{x_i}{L}\\right)$,\n    - $u_i \\leftarrow u_i + A_u^{\\mathrm{noise}} \\sin\\!\\left(2\\pi k_u \\frac{x_i}{L}\\right)$.\n- 使用以下三个测试用例，全部采用国际单位制（SI units）：\n  - 测试用例 1 (理想情况):\n    - $L = 50 \\times 10^{-9} \\,\\mathrm{m}$, $N = 50$, $W_L = 6$, $W_R = 6$, $g = 1$,\n    - $T_0 = 400 \\,\\mathrm{K}$, $a_T^{\\mathrm{true}} = -2.0 \\times 10^{9} \\,\\mathrm{K}/\\mathrm{m}$,\n    - $u_0 = 0 \\,\\mathrm{m}/\\mathrm{s}$, $a_u^{\\mathrm{true}} = 1.0 \\times 10^{7} \\,\\mathrm{s}^{-1}$,\n    - $A_T^{(L)} = 10 \\,\\mathrm{K}$, $\\ell_T^{(L)} = 2 \\Delta x$; $A_T^{(R)} = -8 \\,\\mathrm{K}$, $\\ell_T^{(R)} = 2 \\Delta x$,\n    - $A_u^{(L)} = 0.02 \\,\\mathrm{m}/\\mathrm{s}$, $\\ell_u^{(L)} = 2 \\Delta x$; $A_u^{(R)} = -0.015 \\,\\mathrm{m}/\\mathrm{s}$, $\\ell_u^{(R)} = 2 \\Delta x$,\n    - $A_T^{\\mathrm{noise}} = 0.5 \\,\\mathrm{K}$ with $k_T = 7$, $A_u^{\\mathrm{noise}} = 0.002 \\,\\mathrm{m}/\\mathrm{s}$ with $k_u = 5$.\n  - 测试用例 2 (不对称区域和相反梯度):\n    - $L = 100 \\times 10^{-9} \\,\\mathrm{m}$, $N = 80$, $W_L = 4$, $W_R = 10$, $g = 1$,\n    - $T_0 = 300 \\,\\mathrm{K}$, $a_T^{\\mathrm{true}} = 1.2 \\times 10^{9} \\,\\mathrm{K}/\\mathrm{m}$,\n    - $u_0 = 0.1 \\,\\mathrm{m}/\\mathrm{s}$, $a_u^{\\mathrm{true}} = -5.0 \\times 10^{6} \\,\\mathrm{s}^{-1}$,\n    - $A_T^{(L)} = -12 \\,\\mathrm{K}$, $\\ell_T^{(L)} = 1.5 \\Delta x$; $A_T^{(R)} = 6 \\,\\mathrm{K}$, $\\ell_T^{(R)} = 1.5 \\Delta x$,\n    - $A_u^{(L)} = 0.01 \\,\\mathrm{m}/\\mathrm{s}$, $\\ell_u^{(L)} = 1.5 \\Delta x$; $A_u^{(R)} = -0.01 \\,\\mathrm{m}/\\mathrm{s}$, $\\ell_u^{(R)} = 1.5 \\Delta x$,\n    - $A_T^{\\mathrm{noise}} = 1.0 \\,\\mathrm{K}$ with $k_T = 9$, $A_u^{\\mathrm{noise}} = 0.001 \\,\\mathrm{m}/\\mathrm{s}$ with $k_u = 4$.\n  - 测试用例 3 (最小区域和更强的边界层振幅):\n    - $L = 40 \\times 10^{-9} \\,\\mathrm{m}$, $N = 40$, $W_L = 1$, $W_R = 1$, $g = 1$,\n    - $T_0 = 350 \\,\\mathrm{K}$, $a_T^{\\mathrm{true}} = -1.0 \\times 10^{9} \\,\\mathrm{K}/\\mathrm{m}$,\n    - $u_0 = 0 \\,\\mathrm{m}/\\mathrm{s}$, $a_u^{\\mathrm{true}} = 2.0 \\times 10^{6} \\,\\mathrm{s}^{-1}$,\n    - $A_T^{(L)} = 20 \\,\\mathrm{K}$, $\\ell_T^{(L)} = 1 \\Delta x$; $A_T^{(R)} = -15 \\,\\mathrm{K}$, $\\ell_T^{(R)} = 1 \\Delta x$,\n    - $A_u^{(L)} = 0.03 \\,\\mathrm{m}/\\mathrm{s}$, $\\ell_u^{(L)} = 1 \\Delta x$; $A_u^{(R)} = -0.02 \\,\\mathrm{m}/\\mathrm{s}$, $\\ell_u^{(R)} = 1 \\Delta x$,\n    - $A_T^{\\mathrm{noise}} = 0.2 \\,\\mathrm{K}$ with $k_T = 6$, $A_u^{\\mathrm{noise}} = 0.0005 \\,\\mathrm{m}/\\mathrm{s}$ with $k_u = 3$.\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含所有三个测试用例的结果，格式为列表的列表，每个内部列表按上述指定顺序排列。对所有数字使用科学记数法，小数点后保留六位数字。例如，一个有效的输出形状是\n  - $[[a_T^{(1)},a_u^{(1)},J_T^{(L,1)},J_T^{(R,1)},J_u^{(L,1)},J_u^{(R,1)},D_T^{(L,1)},D_T^{(R,1)},D_u^{(L,1)},D_u^{(R,1)}],[\\dots],[\\dots]]$.\n所有梯度必须以指定的单位（$\\mathrm{K}/\\mathrm{m}$ 和 $\\mathrm{s}^{-1}$）表示，跳跃以（$\\mathrm{K}$ 和 $\\mathrm{m}/\\mathrm{s}$）表示，偏差以无量纲小数形式表示。程序必须且只能打印一行：即所描述的单个聚合列表，不得包含任何额外文本。", "solution": "所提出的问题在科学上是合理的、适定的，并且在计算上是可行的。它涉及分析合成数据，这些数据模拟了在热梯度和速度梯度下流体平板的非平衡分子动力学 (NEMD) 模拟结果。对于每个测试用例，解决方案需要一个两阶段过程：首先，生成指定的数据剖面；其次，分析这些剖面以提取物理量。\n\n解决该问题的系统方法如下：\n\n首先，对于每个测试用例，将长度为 $L$ 的一维空间域离散为 $N$ 个空间箱。每个空间箱 $i$（对于 $i \\in \\{0, \\dots, N-1\\}$）的中心坐标计算为 $x_i = (i + \\frac{1}{2})\\Delta x$，其中箱宽为 $\\Delta x = L/N$。\n\n其次，合成真实的温度 $T_i$ 和速度 $u_i$ 剖面。此过程首先根据提供的真实梯度 ($a_T^{\\mathrm{true}}$, $a_u^{\\mathrm{true}}$) 和截距 ($T_0$, $u_0$) 创建理想的线性体剖面：\n$$T_i^{\\mathrm{lin}} = T_0 + a_T^{\\mathrm{true}} x_i$$\n$$u_i^{\\mathrm{lin}} = u_0 + a_u^{\\mathrm{true}} x_i$$\n为了模拟边界处恒温器的局部非线性效应，在恒温区域内向这些线性剖面添加指数偏差项。对于左侧恒温区域，包含索引 $i \\in \\{0, \\dots, W_L-1\\}$，场被修改为：\n$$T_i \\leftarrow T_i^{\\mathrm{lin}} + A_T^{(L)} \\exp\\left(-\\frac{x_i}{\\ell_T^{(L)}}\\right)$$\n$$u_i \\leftarrow u_i^{\\mathrm{lin}} + A_u^{(L)} \\exp\\left(-\\frac{x_i}{\\ell_u^{(L)}}\\right)$$\n对右侧恒温区域，覆盖索引 $i \\in \\{N-W_R, \\dots, N-1\\}$，使用相应的右侧参数进行类似的修改。最后，为了表示分子动力学中固有的统计涨落，对整个区域的所有空间箱的温度场和速度场都添加了一个小的、空间平滑的正弦噪声项。\n\n第三，分析阶段从识别平板的体区域开始。该区域的定义是排除两端的恒温区域（左侧 $W_L$ 个空间箱，右侧 $W_R$ 个空间箱）以及每个恒温区域旁边 $g=1$ 个空间箱的额外保护区域。最终的体拟合区域由空间箱索引 $i \\in \\{W_L+g, \\dots, N-W_R-g-1\\}$ 组成。\n\n第四，在此已识别的体区域内，采用普通最小二乘 (OLS) 回归来拟合线性模型 $T(x) \\approx a_T x + b_T$ 和 $u(x) \\approx a_u x + b_u$。这是通过使用 `numpy.polyfit` 函数并设置阶数为1来完成的。这些拟合的斜率 $a_T$ 和 $a_u$ 分别代表了数值提取的体热梯度 ($dT/dx$) 和速度梯度 ($du/dx$)。\n\n第五，量化边界附近对这种理想体行为的偏差。计算两个指标：\n1.  界面跳跃，它衡量保护区域和体区域之间界面处的局部偏差。这是通过计算两侧第一个体区域空间箱处测量数据与线性拟合预测值之间的残差得到的。对于左侧索引 $i_L = W_L + g$ 处，跳跃为 $J_T^{(L)} = T_{i_L} - (a_T x_{i_L} + b_T)$ 和 $J_u^{(L)} = u_{i_L} - (a_u x_{i_L} + b_u)$。在右侧索引 $i_R = N-W_R-g-1$ 处进行类似的计算。\n2.  归一化的均方根 (RMS) 偏差，它量化了恒温区域内的整体非线性。对于每个恒温区域（左侧：$i \\in \\{0,\\dots,W_L-1\\}$；右侧：$i \\in \\{N-W_R,\\dots,N-1\\}$），计算测量数据 ($T_i, u_i$) 与外推的体拟合 ($a_T x_i + b_T, a_u x_i + b_u$) 之间的残差的 RMS。然后将此 RMS 值用整个区域上体场变化的总幅度（温度为 $|a_T|L$，速度为 $|a_u|L$）进行归一化，从而得到无量纲的偏差指标 $D_T^{(L)}$、$D_T^{(R)}$、$D_u^{(L)}$ 和 $D_u^{(R)}$。\n\n将这整个过程系统地应用于三个测试用例中的每一个，并收集每个案例的十个指定输出量，并按要求进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the processing of all test cases and print the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"L\": 50e-9, \"N\": 50, \"W_L\": 6, \"W_R\": 6, \"g\": 1,\n            \"T0\": 400.0, \"a_T_true\": -2.0e9,\n            \"u0\": 0.0, \"a_u_true\": 1.0e7,\n            \"A_T_L\": 10.0, \"l_T_L_factor\": 2.0,\n            \"A_T_R\": -8.0, \"l_T_R_factor\": 2.0,\n            \"A_u_L\": 0.02, \"l_u_L_factor\": 2.0,\n            \"A_u_R\": -0.015, \"l_u_R_factor\": 2.0,\n            \"A_T_noise\": 0.5, \"k_T\": 7.0,\n            \"A_u_noise\": 0.002, \"k_u\": 5.0,\n        },\n        # Test case 2\n        {\n            \"L\": 100e-9, \"N\": 80, \"W_L\": 4, \"W_R\": 10, \"g\": 1,\n            \"T0\": 300.0, \"a_T_true\": 1.2e9,\n            \"u0\": 0.1, \"a_u_true\": -5.0e6,\n            \"A_T_L\": -12.0, \"l_T_L_factor\": 1.5,\n            \"A_T_R\": 6.0, \"l_T_R_factor\": 1.5,\n            \"A_u_L\": 0.01, \"l_u_L_factor\": 1.5,\n            \"A_u_R\": -0.01, \"l_u_R_factor\": 1.5,\n            \"A_T_noise\": 1.0, \"k_T\": 9.0,\n            \"A_u_noise\": 0.001, \"k_u\": 4.0,\n        },\n        # Test case 3\n        {\n            \"L\": 40e-9, \"N\": 40, \"W_L\": 1, \"W_R\": 1, \"g\": 1,\n            \"T0\": 350.0, \"a_T_true\": -1.0e9,\n            \"u0\": 0.0, \"a_u_true\": 2.0e6,\n            \"A_T_L\": 20.0, \"l_T_L_factor\": 1.0,\n            \"A_T_R\": -15.0, \"l_T_R_factor\": 1.0,\n            \"A_u_L\": 0.03, \"l_u_L_factor\": 1.0,\n            \"A_u_R\": -0.02, \"l_u_R_factor\": 1.0,\n            \"A_T_noise\": 0.2, \"k_T\": 6.0,\n            \"A_u_noise\": 0.0005, \"k_u\": 3.0,\n        },\n    ]\n\n    all_results = []\n    for params in test_cases:\n        case_results = process_case(params)\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    inner_lists_str = []\n    for res_list in all_results:\n        formatted_nums = [f\"{num:.6e}\" for num in res_list]\n        inner_lists_str.append(f\"[{','.join(formatted_nums)}]\")\n    \n    print(f\"[{','.join(inner_lists_str)}]\")\n\ndef process_case(params: dict) -> list:\n    \"\"\"\n    Generates synthetic data and performs analysis for a single test case.\n    \"\"\"\n    L = params[\"L\"]\n    N = params[\"N\"]\n    W_L = params[\"W_L\"]\n    W_R = params[\"W_R\"]\n    g = params[\"g\"]\n    \n    # Step 1: Construct coordinates and generate data profiles\n    delta_x = L / N\n    i_coords = np.arange(N)\n    x = (i_coords + 0.5) * delta_x\n\n    # Baseline linear fields\n    T = params[\"T0\"] + params[\"a_T_true\"] * x\n    u = params[\"u0\"] + params[\"a_u_true\"] * x\n\n    # Add thermostat-localized deviations\n    # Left slab\n    if W_L > 0:\n      l_slab_indices = np.arange(W_L)\n      x_l_slab = x[l_slab_indices]\n      l_T_L = params[\"l_T_L_factor\"] * delta_x\n      l_u_L = params[\"l_u_L_factor\"] * delta_x\n      T[l_slab_indices] += params[\"A_T_L\"] * np.exp(-x_l_slab / l_T_L)\n      u[l_slab_indices] += params[\"A_u_L\"] * np.exp(-x_l_slab / l_u_L)\n\n    # Right slab\n    if W_R > 0:\n      r_slab_indices = np.arange(N - W_R, N)\n      x_r_slab = x[r_slab_indices]\n      l_T_R = params[\"l_T_R_factor\"] * delta_x\n      l_u_R = params[\"l_u_R_factor\"] * delta_x\n      T[r_slab_indices] += params[\"A_T_R\"] * np.exp(-(L - x_r_slab) / l_T_R)\n      u[r_slab_indices] += params[\"A_u_R\"] * np.exp(-(L - x_r_slab) / l_u_R)\n\n    # Add spatially smooth noise to all bins\n    T += params[\"A_T_noise\"] * np.sin(2 * np.pi * params[\"k_T\"] * x / L)\n    u += params[\"A_u_noise\"] * np.sin(2 * np.pi * params[\"k_u\"] * x / L)\n\n    # Step 2  3: Identify bulk region and perform OLS fit\n    bulk_start_idx = W_L + g\n    bulk_end_idx = N - W_R - g - 1\n    bulk_indices = np.arange(bulk_start_idx, bulk_end_idx + 1)\n    \n    x_bulk = x[bulk_indices]\n    T_bulk = T[bulk_indices]\n    u_bulk = u[bulk_indices]\n\n    a_T, b_T = np.polyfit(x_bulk, T_bulk, 1)\n    a_u, b_u = np.polyfit(x_bulk, u_bulk, 1)\n\n    # Step 4: Quantify deviations from the bulk fit\n    # Interfacial jumps at the first/last bulk bin\n    i_L = W_L + g\n    T_fit_L = a_T * x[i_L] + b_T\n    J_T_L = T[i_L] - T_fit_L\n    u_fit_L = a_u * x[i_L] + b_u\n    J_u_L = u[i_L] - u_fit_L\n\n    i_R = N - W_R - g - 1\n    T_fit_R = a_T * x[i_R] + b_T\n    J_T_R = T[i_R] - T_fit_R\n    u_fit_R = a_u * x[i_R] + b_u\n    J_u_R = u[i_R] - u_fit_R\n\n    # RMS of residuals in thermostatted slabs, normalized\n    def rms(v):\n        return np.sqrt(np.mean(np.square(v)))\n\n    # Left slab RMSD\n    if W_L > 0:\n        x_slab_L = x[l_slab_indices]\n        T_res_L = T[l_slab_indices] - (a_T * x_slab_L + b_T)\n        u_res_L = u[l_slab_indices] - (a_u * x_slab_L + b_u)\n        D_T_L = rms(T_res_L) / (np.abs(a_T) * L)\n        D_u_L = rms(u_res_L) / (np.abs(a_u) * L)\n    else:\n        D_T_L, D_u_L = 0.0, 0.0\n\n    # Right slab RMSD\n    if W_R > 0:\n        x_slab_R = x[r_slab_indices]\n        T_res_R = T[r_slab_indices] - (a_T * x_slab_R + b_T)\n        u_res_R = u[r_slab_indices] - (a_u * x_slab_R + b_u)\n        D_T_R = rms(T_res_R) / (np.abs(a_T) * L)\n        D_u_R = rms(u_res_R) / (np.abs(a_u) * L)\n    else:\n        D_T_R, D_u_R = 0.0, 0.0\n\n    # Step 5: Return results in the specified order\n    return [a_T, a_u, J_T_L, J_T_R, J_u_L, J_u_R, D_T_L, D_T_R, D_u_L, D_u_R]\n\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3469013"}, {"introduction": "分子动力学模拟本质上是在有限尺寸的系统上进行的，但其目标通常是预测体材料 (bulk material) 的性质。本练习旨在解决有限尺寸效应对热导率计算这一关键问题。该实践基于这样一种思想：对于由声子介导的热输运，有限系统中的边界散射会抑制热导率，这种效应可以被建模并用于将模拟结果外推到无限尺寸（体）极限。通过执行有限尺寸标度分析，您将学到一种强大且广泛使用的技术，以克服模拟中的人为因素，从而获得可与实验测量相媲美的体输运系数 [@problem_id:3468983]。", "problem": "您正在使用非平衡分子动力学 (NEMD) 方法分析一维纳米线中的非平衡稳态热输运。目标是通过对不同线长的有限尺寸标度分析，推断出体相热导率和特征声子平均自由程。从以下原理出发：在线性响应范围内，热流 $q$ 通过傅里叶定律及其非局域推广与温度梯度相关联。在均匀介质中，其局域极限为 $q(z) = -\\kappa_\\infty \\frac{dT}{dz}$，其中 $\\kappa_\\infty$ 是体相（无限长）热导率。在长度为 $L$ 的有限纳米尺度系统中，非局域性和边界散射会改变有效热导率。在线性响应和单一主导非局域性长度尺度的假设下，有限尺寸修正的主导项与 $L^{-1}$ 成比例。具体而言，有效热导率具有形式 $\\kappa(L) = \\kappa_\\infty \\left(1 + \\frac{a}{L}\\right)$，其中 $a$ 是一个长度，在所述假设下，其物理意义可解释为有效声子平均自由程的尺度。\n\n您的任务是编写一个程序，对每个测试用例，通过拟合关于变量 $x = 1/L$ 的线性模型 $\\kappa(L) = b + m x$（其中 $b = \\kappa_\\infty$ 且 $m = \\kappa_\\infty a$）来估计 $\\kappa_\\infty$ 和 $a$。然后通过令 $\\lambda = a$ 来计算推断出的声子平均自由程 $\\lambda$。使用普通最小二乘法，并假设所提供的数据具有均匀不确定性。\n\n要求：\n- 使用线性回归公式 $y_i = b + m x_i$（其中 $x_i = 1/L_i$ 和 $y_i = \\kappa(L_i)$）根据每个测试用例的数据确定 $b$ 和 $m$，然后令 $\\kappa_\\infty = b$，$a = \\frac{m}{b}$ 以及 $\\lambda = a$。\n- 将 $\\kappa_\\infty$ 以瓦特每米开尔文 (W/(m·K)) 为单位表示，$\\lambda$ 以纳米 (nm) 为单位表示。将每个报告的浮点数四舍五入到六位小数。\n- 自变量 $L$ 以纳米 (nm) 为单位提供，所有报告的长度也必须以纳米 (nm) 为单位。热导率以 W/(m·K) 为单位提供。\n\n测试套件：\n- 案例 $1$（理想情况，中等长度）：$L = [\\,100,\\,200,\\,400,\\,800\\,]$ nm, $\\kappa(L) = [\\,300,\\,200,\\,150,\\,125\\,]$ W/(m·K)。\n- 案例 $2$（大 $L$ 区间）：$L = [\\,1000,\\,2000,\\,4000,\\,8000\\,]$ nm, $\\kappa(L) = [\\,375,\\,312.5,\\,281.25,\\,265.625\\,]$ W/(m·K)。\n- 案例 $3$（短 $L$ 偏弹道输运区间）：$L = [\\,50,\\,75,\\,100,\\,150\\,]$ nm, $\\kappa(L) = [\\,90,\\,70,\\,60,\\,50\\,]$ W/(m·K)。\n- 案例 $4$（最少数据，两点）：$L = [\\,200,\\,400\\,]$ nm, $\\kappa(L) = [\\,120,\\,100\\,]$ W/(m·K)。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个案例，按案例顺序输出 $(\\kappa_\\infty, \\lambda)$ 对，并将其平铺成一个列表。例如，输出必须类似于 $[r_1,r_2,\\dots]$，其中对于案例 $k$，$r_{2k-1} = \\kappa_\\infty$（单位 W/(m·K)），$r_{2k} = \\lambda$（单位 nm），每个浮点数均四舍五入到六位小数。", "solution": "该问题已经过评估并被认为是有效的。它在计算物理学中分析模拟数据的背景下具有科学依据，提供了一个定义明确的数学模型和清晰、客观的参数估计程序。该问题是自洽的，所提供的数据与指定模型内部一致，从而能够得出唯一且有意义的解。\n\n目标是通过分析一维系统中有效热导率 $\\kappa(L)$ 的有限尺寸依赖性，来确定体相热导率 $\\kappa_\\infty$ 和特征声子平均自由程 $\\lambda$。该分析基于所提供的模型，该模型将有限长度 $L$ 下的有效热导率与体相热导率 $\\kappa_\\infty$ 联系起来：\n$$ \\kappa(L) = \\kappa_\\infty \\left(1 + \\frac{a}{L}\\right) $$\n在此，$a$ 是一个具有长度单位的参数，将被视为声子平均自由程 $\\lambda$。该模型描述了一个系统中，热导率的有限尺寸修正主导项与 $L^{-1}$ 成比例。\n\n为了估计参数 $\\kappa_\\infty$ 和 $a$，我们将模型线性化。通过定义自变量 $x = 1/L$ 和因变量 $y = \\kappa(L)$，该方程可以重写为标准线性方程形式 $y = mx + b$：\n$$ \\kappa(L) = \\kappa_\\infty + (\\kappa_\\infty a) \\frac{1}{L} $$\n通过将其与通用线性形式 $y = b + mx$ 进行比较，我们可以在物理参数和回归系数之间建立以下对应关系：\n- 截距 $b$ 对应于体相热导率：$\\kappa_\\infty = b$。\n- 斜率 $m$ 与两个参数都有关：$m = \\kappa_\\infty a$。\n\n问题要求使用普通最小二乘法 (OLS) 为给定的数据集 $(x_i, y_i)$（其中 $x_i = 1/L_i$ 且 $y_i = \\kappa(L_i)$）找到斜率 $m$ 和截距 $b$ 的最佳拟合值。对于一个包含 $n$ 个数据点的样本，$m$ 和 $b$ 的 OLS 估计量由以下公式给出：\n$$ m = \\frac{n \\sum_{i=1}^{n} x_i y_i - (\\sum_{i=1}^{n} x_i)(\\sum_{i=1}^{n} y_i)}{n \\sum_{i=1}^{n} x_i^2 - (\\sum_{i=1}^{n} x_i)^2} $$\n$$ b = \\bar{y} - m\\bar{x} = \\frac{1}{n} \\left( \\sum_{i=1}^{n} y_i - m \\sum_{i=1}^{n} x_i \\right) $$\n一旦确定了 $m$ 和 $b$，我们就可以求解物理参数。从截距，我们直接得到 $\\kappa_\\infty$：\n$$ \\kappa_\\infty = b $$\n然后，使用斜率的表达式，我们可以求解参数 $a$，假设 $\\kappa_\\infty \\neq 0$：\n$$ a = \\frac{m}{\\kappa_\\infty} = \\frac{m}{b} $$\n问题指出，声子平均自由程 $\\lambda$ 应被视为此参数 $a$，因此：\n$$ \\lambda = a = \\frac{m}{b} $$\n每个测试用例中提供的数据集都经过构造，能够完美满足线性模型。因此，OLS 回归将产生精确拟合，我们可以通过求解任意两个数据点的线性方程组，代数地确定参数 $m$ 和 $b$。\n\n我们现在将此程序应用于每个测试用例。\n\n案例 $1$：$L = [\\,100,\\,200,\\,400,\\,800\\,]$ nm 且 $\\kappa(L) = [\\,300,\\,200,\\,150,\\,125\\,]$ W/(m·K)。\n我们选择前两个数据点。令 $x_1 = 1/100$ nm$^{-1}$ 和 $y_1 = 300$ W/(m·K)，以及 $x_2 = 1/200$ nm$^{-1}$ 和 $y_2 = 200$ W/(m·K)。\n我们求解该方程组：\n$$ 300 = b + m \\cdot \\frac{1}{100} $$\n$$ 200 = b + m \\cdot \\frac{1}{200} $$\n第一个方程减去第二个方程得到 $100 = m(1/100 - 1/200) = m(1/200)$，解得 $m = 20000$ W·nm/(m·K)。\n将 $m$ 代入第一个方程：$300 = b + 20000/100 = b + 200$，解得 $b = 100$ W/(m·K)。\n因此，$\\kappa_\\infty = b = 100$ W/(m·K)。平均自由程为 $\\lambda = m/b = 20000/100 = 200$ nm。\n\n案例 $2$：$L = [\\,1000,\\,2000,\\,4000,\\,8000\\,]$ nm 且 $\\kappa(L) = [\\,375,\\,312.5,\\,281.25,\\,265.625\\,]$ W/(m·K)。\n使用前两个点，($x_1=1/1000$, $y_1=375$) 和 ($x_2=1/2000$, $y_2=312.5$)：\n$$ 375 = b + m \\cdot \\frac{1}{1000} $$\n$$ 312.5 = b + m \\cdot \\frac{1}{2000} $$\n第一个方程减去第二个方程得到 $62.5 = m(1/2000)$，所以 $m = 125000$ W·nm/(m·K)。\n代回：$375 = b + 125000/1000 = b + 125$，解得 $b = 250$ W/(m·K)。\n因此，$\\kappa_\\infty = b = 250$ W/(m·K)。平均自由程为 $\\lambda = m/b = 125000/250 = 500$ nm。\n\n案例 $3$：$L = [\\,50,\\,75,\\,100,\\,150\\,]$ nm 且 $\\kappa(L) = [\\,90,\\,70,\\,60,\\,50\\,]$ W/(m·K)。\n使用前两个点，($x_1=1/50$, $y_1=90$) 和 ($x_2=1/75$, $y_2=70$)：\n$$ 90 = b + m \\cdot \\frac{1}{50} $$\n$$ 70 = b + m \\cdot \\frac{1}{75} $$\n从第一个方程，我们得到 $m = 50(90 - b)$。从第二个方程，我们得到 $m = 75(70 - b)$。\n令二者相等：$50(90 - b) = 75(70 - b) \\implies 4500 - 50b = 5250 - 75b \\implies 25b = 750$，所以 $b = 30$ W/(m·K)。\n那么 $m = 50(90 - 30) = 3000$ W·nm/(m·K)。\n因此，$\\kappa_\\infty = b = 30$ W/(m·K)。平均自由程为 $\\lambda = m/b = 3000/30 = 100$ nm。\n\n案例 $4$：$L = [\\,200,\\,400\\,]$ nm 且 $\\kappa(L) = [\\,120,\\,100\\,]$ W/(m·K)。\n只有两个点，直线被精确确定。令 ($x_1=1/200$, $y_1=120$) 和 ($x_2=1/400$, $y_2=100$)：\n$$ 120 = b + m \\cdot \\frac{1}{200} $$\n$$ 100 = b + m \\cdot \\frac{1}{400} $$\n第一个方程减去第二个方程：$20 = m(1/200 - 1/400) = m(1/400)$，所以 $m = 8000$ W·nm/(m·K)。\n代回：$100 = b + 8000/400 = b + 20$，解得 $b = 80$ W/(m·K)。\n因此，$\\kappa_\\infty = b = 80$ W/(m·K)。平均自由程为 $\\lambda = m/b = 8000/80 = 100$ nm。\n\n每个案例计算出的参数如下：\n- 案例 $1$：$\\kappa_\\infty = 100$ W/(m·K)，$\\lambda = 200$ nm。\n- 案例 $2$：$\\kappa_\\infty = 250$ W/(m·K)，$\\lambda = 500$ nm。\n- 案例 $3$：$\\kappa_\\infty = 30$ W/(m·K)，$\\lambda = 100$ nm。\n- 案例 $4$：$\\kappa_\\infty = 80$ W/(m·K)，$\\lambda = 100$ nm。\n\n这些结果将按程序要求进行格式化和打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes finite-size scaling of thermal conductivity to infer bulk\n    conductivity and phonon mean free path using linear regression.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, moderate lengths)\n        ([100, 200, 400, 800], [300, 200, 150, 125]),\n        # Case 2 (large-L regime)\n        ([1000, 2000, 4000, 8000], [375, 312.5, 281.25, 265.625]),\n        # Case 3 (short-L ballistic-leaning regime)\n        ([50, 75, 100, 150], [90, 70, 60, 50]),\n        # Case 4 (minimal data, two points)\n        ([200, 400], [120, 100]),\n    ]\n\n    results = []\n    for L_vals, kappa_vals in test_cases:\n        # Convert input lists to NumPy arrays for vectorized operations.\n        # The data types are explicitly float to ensure floating point division.\n        L_np = np.array(L_vals, dtype=float)\n        kappa_np = np.array(kappa_vals, dtype=float)\n\n        # The model is kappa(L) = kappa_inf * (1 + a/L).\n        # This linearizes to kappa(L) = kappa_inf + (kappa_inf * a) * (1/L).\n        # We fit a line y = m*x + b, where:\n        # y = kappa(L)\n        # x = 1/L\n        # The regression coefficients are then identified as:\n        # b = kappa_inf\n        # m = kappa_inf * a\n        \n        x = 1.0 / L_np\n        y = kappa_np\n\n        # Perform ordinary least squares for a first-degree polynomial (a line)\n        # using numpy.polyfit. It returns the coefficients [m, b] for y = mx + b.\n        m, b = np.polyfit(x, y, 1)\n\n        # From the relationships derived above, calculate the physical parameters.\n        # kappa_inf is the y-intercept of the fit.\n        kappa_inf = b\n        \n        # The phonon mean free path lambda is identified with parameter 'a'.\n        # a = m / kappa_inf.\n        # A check for kappa_inf being close to zero is good practice, though not\n        # necessary for the provided test cases.\n        if np.isclose(kappa_inf, 0):\n            # This case implies zero bulk conductivity, which is physically\n            # unusual and would make 'a' and 'lambda' indeterminate.\n            lambda_mfp = np.nan\n        else:\n            a = m / kappa_inf\n            lambda_mfp = a\n            \n        results.append(kappa_inf)\n        results.append(lambda_mfp)\n\n    # Final print statement in the exact required format.\n    # The output is a single flattened list of [kappa_inf_1, lambda_1, kappa_inf_2, lambda_2, ...].\n    # Each float is rounded to six decimal places.\n    print(f\"[{','.join(f'{val:.6f}' for val in results)}]\")\n\nsolve()\n```", "id": "3468983"}]}