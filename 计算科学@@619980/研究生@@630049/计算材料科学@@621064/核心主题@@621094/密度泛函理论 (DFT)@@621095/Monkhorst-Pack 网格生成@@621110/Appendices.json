{"hands_on_practices": [{"introduction": "在任何涉及布里渊区积分的计算中，第一步都是定义一个离散的采样点集，即 $k$ 点网格。本练习将指导你完成以编程方式生成 Monkhorst-Pack 网格的基本过程，并实现将这些点映射到第一布里渊区的关键步骤，从而为后续计算奠定正确的基础。", "problem": "您需要从第一性原理出发，推导并实现一个算法，该算法在晶体的倒易空间中构建一套均匀的采样点，并将其映射到第一布里渊区（FBZ）。该算法必须生成能带结构计算中常用的三维网格的所有点，并确保这些点位于 FBZ 内部。FBZ 被定义为倒易晶格的 Wigner–Seitz（WS）原胞。该网格必须以相对于倒易基矢的分数坐标表示。\n\n使用的基本基矢和定义如下：\n\n- 设三个实空间原胞基矢是矩阵 $\\mathbf{A} \\in \\mathbb{R}^{3 \\times 3}$ 的列向量，单位为埃（Angstroms）。倒易晶格基矢由 $\\mathbf{B} = 2\\pi \\left( \\mathbf{A}^{-1} \\right)^{\\top}$ 定义，单位为逆埃（inverse Angstroms）。任意倒易晶格矢量可以写成 $\\mathbf{G} = n_1 \\mathbf{b}_1 + n_2 \\mathbf{b}_2 + n_3 \\mathbf{b}_3 = \\mathbf{B}\\mathbf{n}$，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$。\n\n- 倒易空间中的一个点 $\\mathbf{k}$ 可以用分数坐标 $\\mathbf{f} \\in \\mathbb{R}^3$ 参数化为 $\\mathbf{k} = \\mathbf{B}\\mathbf{f}$。\n\n- 第一布里渊区（FBZ）是倒易晶格的 Wigner–Seitz（WS）原胞，它是所有到原点 $\\mathbf{0}$ 的距离比到任何其他倒易晶格点都更近的点 $\\mathbf{k}$ 的集合。等价地，如果对于所有非零的 $\\mathbf{n} \\in \\mathbb{Z}^3$ 都满足 $\\lVert \\mathbf{k} \\rVert \\le \\lVert \\mathbf{k} - \\mathbf{B}\\mathbf{n} \\rVert$，则 $\\mathbf{k}$ 位于 FBZ 内。\n\n您的目标：\n\n1. 从沿每个倒易基矢方向具有均匀采样密度以及关于 $\\Gamma$ 点（原点）对称的要求出发，以分数坐标构建一个包含 $N_1 \\times N_2 \\times N_3$ 个点的三维网格，使得在每个方向上 $N_i$ 个样本都是均匀间隔且相对于原点居中。将分数坐标记为 $\\mathbf{f}_{m_1,m_2,m_3}$，其中索引 $m_i \\in \\{1,2,\\dots,N_i\\}$。\n\n2. 通过减去一个合适的倒易晶格矢量 $\\mathbf{G} = \\mathbf{B}\\mathbf{n}$，为每个 $\\mathbf{k} = \\mathbf{B}\\mathbf{f}$ 实现到 FBZ 的映射，其中选择 $\\mathbf{n} \\in \\mathbb{Z}^3$ 以最小化欧几里得范数 $\\lVert \\mathbf{B}(\\mathbf{f} + \\mathbf{n}) \\rVert$。所有距离和范数均以逆埃（inverse Angstroms）表示。\n\n3. 为了测试您映射的稳健性，请包含一个可选的均匀分数坐标偏移（或“平移”）$\\mathbf{s} \\in \\mathbb{R}^3$，使得在映射之前，用于构成 $\\mathbf{k}$ 的初始分数坐标为 $\\mathbf{f}_{m_1,m_2,m_3} + \\mathbf{s}$。该映射必须将点带回到 FBZ 内。\n\n4. FBZ 成员资格的验证标准必须使用 WS 定义：对于一个已映射的 $\\mathbf{k}$，验证对于原点在 $\\mathbb{Z}^3$ 中的对称有界邻域内的所有非零整数矢量 $\\mathbf{n}$，是否都满足 $\\lVert \\mathbf{k} \\rVert \\le \\lVert \\mathbf{k} - \\mathbf{B}\\mathbf{n} \\rVert$。请使用一个足以判断您的测试套件所生成点的 FBZ 成员资格的有界邻域。\n\n单位和输出要求：\n\n- 所有实空间晶格输入 $\\mathbf{A}$ 均以埃（Angstroms）为单位。所有倒易空间量（包括 $\\mathbf{k}$ 的范数）必须以逆埃（inverse Angstroms）计算和报告。\n\n- 角度单位不适用于本问题。\n\n- 您的程序必须生成单行输出，其中包含一个针对每个测试用例的列表，该列表包含三个值：\n    1. 一个整数，等于映射前在 FBZ 外部的点数，\n    2. 一个整数，等于映射后仍在 FBZ 外部的点数（如果映射正确，此值应为 $0$），\n    3. 一个浮点数，等于所有映射后点中的最大欧几里得范数 $\\max \\lVert \\mathbf{k} \\rVert$，单位为逆埃（inverse Angstroms），四舍五入到六位小数。\n  将所有测试用例的列表聚合到一个顶层的、用方括号括起来的、以逗号分隔的列表中（例如，\"[[a,b,c],[d,e,f],...]\"）。\n\n测试套件：\n\n实现该算法并对以下四种情况运行。在每种情况下，构建 $\\mathbf{B} = 2\\pi \\left( \\mathbf{A}^{-1} \\right)^{\\top}$，生成 $N_1 \\times N_2 \\times N_3$ 网格，应用平移 $\\mathbf{s}$，映射到 FBZ，并报告所要求的三个值。\n\n- 情况 1 (理想情况，正交晶格):\n  $$ \\mathbf{A} = \\begin{bmatrix} 1.0 & 0.0 & 0.0 \\\\ 0.0 & 1.0 & 0.0 \\\\ 0.0 & 0.0 & 1.0 \\end{bmatrix} $$\n  Angstroms, $(N_1,N_2,N_3) = (2,2,2)$, \n  $$ \\mathbf{s} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix} $$\n\n- 情况 2 (正交晶系晶格，有显著平移):\n  $$ \\mathbf{A} = \\begin{bmatrix} 3.0 & 0.0 & 0.0 \\\\ 0.0 & 2.0 & 0.0 \\\\ 0.0 & 0.0 & 1.0 \\end{bmatrix} $$\n  Angstroms, $(N_1,N_2,N_3) = (3,3,3)$,\n  $$ \\mathbf{s} = \\begin{bmatrix} 0.6 \\\\ 0.2 \\\\ -0.4 \\end{bmatrix} $$\n\n- 情况 3 (斜晶格):\n  $$ \\mathbf{A} = \\begin{bmatrix} 2.0 & 0.1 & 0.0 \\\\ 0.0 & 2.2 & 0.3 \\\\ 0.0 & 0.0 & 1.8 \\end{bmatrix} $$\n  Angstroms, $(N_1,N_2,N_3) = (4,2,3)$,\n  $$ \\mathbf{s} = \\begin{bmatrix} 0.3 \\\\ 0.3 \\\\ 0.3 \\end{bmatrix} $$\n\n- 情况 4 (类六方晶格，大平移和最小网格):\n  $$ \\mathbf{A} = \\begin{bmatrix} 1.0 & 0.5 & 0.0 \\\\ 0.0 & 0.866 & 0.0 \\\\ 0.0 & 0.0 & 2.5 \\end{bmatrix} $$\n  Angstroms, $(N_1,N_2,N_3) = (1,1,1)$,\n  $$ \\mathbf{s} = \\begin{bmatrix} 1.2 \\\\ -1.2 \\\\ 0.8 \\end{bmatrix} $$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的列表形式的结果，每个测试用例贡献其自己的如上所述的三元素列表。", "solution": "该问题要求推导并实现一个算法，用于在倒易空间中生成一个均匀的采样点网格（称为 Monkhorst-Pack 网格），并将这些点映射到第一布里渊区（FBZ）。\n\n### 1. 倒易晶格与坐标系\n\n晶体结构由一组实空间原胞基矢定义，这些基矢作为矩阵 $\\mathbf{A}$ 的列向量给出。相应的倒易晶格基矢构成了倒易空间的基，它们是如下定义的矩阵 $\\mathbf{B}$ 的列向量：\n$$\n\\mathbf{B} = 2\\pi (\\mathbf{A}^{-1})^\\top\n$$\n倒易空间中的任意点 $\\mathbf{k}$ 既可以用笛卡尔坐标（单位为 $\\AA^{-1}$）表示，也可以用相对于基 $\\mathbf{B}$ 的分数坐标 $\\mathbf{f}$ 表示：\n$$\n\\mathbf{k} = \\mathbf{Bf} = f_1 \\mathbf{b}_1 + f_2 \\mathbf{b}_2 + f_3 \\mathbf{b}_3\n$$\n一个倒易晶格矢量 $\\mathbf{G}$ 对应于一个分数坐标为整数的点，即，对于某个整数矢量 $\\mathbf{n} \\in \\mathbb{Z}^3$，有 $\\mathbf{G} = \\mathbf{B}\\mathbf{n}$。\n\n### 2. Monkhorst-Pack 网格生成\n\n目标是在倒易空间中创建一个以原点（$\\Gamma$ 点）为中心的 $N_1 \\times N_2 \\times N_3$ 的均匀点网格。这可以通过在分数坐标空间中生成一个均匀网格来实现。为确保网格相对于原点对称，沿每个方向 $i$ 的分数坐标 $f_i$ 选择如下：\n$$\nf_i = \\frac{m_i - \\frac{N_i+1}{2}}{N_i} \\quad \\text{for } m_i = 1, 2, \\dots, N_i\n$$\n对于奇数 $N_i$，此序列包含 $0$；对于偶数 $N_i$，此序列关于 $0$ 对称。例如，对于 $N_i=3$，分数坐标为 $\\{-\\frac{1}{3}, 0, \\frac{1}{3}\\}$；对于 $N_i=4$，分数坐标为 $\\{-\\frac{3}{8}, -\\frac{1}{8}, \\frac{1}{8}, \\frac{3}{8}\\}$。所有生成的坐标都位于区间 $(-0.5, 0.5)$ 内。\n\n问题指定了一个要应用于网格的额外均匀平移 $\\mathbf{s}$。因此，最终的未映射分数坐标集合 $\\mathbf{f'}$ 为：\n$$\n\\mathbf{f'}_{m_1,m_2,m_3} = \\mathbf{f}_{m_1,m_2,m_3} + \\mathbf{s}\n$$\n初始 k 点集则由 $\\mathbf{k}_{init} = \\mathbf{Bf'}$ 给出。这些点不保证位于第一布里渊区内。\n\n### 3. 映射到第一布里渊区\n\n第一布里渊区（FBZ）是倒易晶格以原点为中心的 Wigner-Seitz 原胞。它被定义为所有到原点（$\\mathbf{G} = \\mathbf{0}$）的距离比到任何其他倒易晶格点 $\\mathbf{G} = \\mathbf{B}\\mathbf{n}$（$\\mathbf{n} \\neq \\mathbf{0}$）的距离都更近的点 $\\mathbf{k}$ 的集合：\n$$\n\\text{FBZ} = \\{ \\mathbf{k} \\in \\mathbb{R}^3 \\mid \\lVert \\mathbf{k} \\rVert \\le \\lVert \\mathbf{k} - \\mathbf{B}\\mathbf{n} \\rVert \\quad \\forall \\mathbf{n} \\in \\mathbb{Z}^3, \\mathbf{n} \\neq \\mathbf{0} \\}\n$$\n要将任意点 $\\mathbf{k}_{init}$ 映射到 FBZ 内，我们必须减去距离 $\\mathbf{k}_{init}$ 最近的那个特定倒易晶格矢量 $\\mathbf{G}^* = \\mathbf{B}\\mathbf{n}^*$。映射后的点 $\\mathbf{k}_{mapped} = \\mathbf{k}_{init} - \\mathbf{G}^*$ 随后将比任何其他倒易晶格点更靠近原点，从而满足 FBZ 的定义。\n\n这个任务等价于为每个 $\\mathbf{k}_{init}$ 解决最近向量问题（Closest Vector Problem, CVP）：找到一个整数矢量 $\\mathbf{n}^* \\in \\mathbb{Z}^3$，使得欧几里得距离 $\\lVert \\mathbf{k}_{init} - \\mathbf{B}\\mathbf{n} \\rVert$ 最小。\n$$\n\\mathbf{n}^* = \\arg\\min_{\\mathbf{n} \\in \\mathbb{Z}^3} \\lVert \\mathbf{k}_{init} - \\mathbf{B}\\mathbf{n} \\rVert^2\n$$\n尽管 CVP 在一般情况下是 NP-难问题，但对于像 $\\mathbb{R}^3$ 这样的低维空间，我们可以使用基于搜索的方法有效解决它。一个稳健的策略是首先为 $\\mathbf{n}$ 找到一个好的初始猜测，然后在它的局部邻域内进行搜索。\n$\\mathbf{k}_{init}$ 的分数坐标提供了一个极佳的猜测。我们首先计算 $\\mathbf{f'} = \\mathbf{B}^{-1}\\mathbf{k}_{init}$，其中 $\\mathbf{B}^{-1} = \\frac{1}{2\\pi}\\mathbf{A}^\\top$。分数空间中最近的整数矢量就是 $\\mathbf{n}_{guess} = \\text{round}(\\mathbf{f'})$。这对应于用于 CVP 的 Babai 舍入算法。\n\n为改进这一点，我们在以 $\\mathbf{n}_{guess}$ 为中心的一个小整数盒子内对 $\\mathbf{n}^*$ 进行暴力搜索。我们搜索所有的候选矢量 $\\mathbf{n} = \\mathbf{n}_{guess} + \\Delta\\mathbf{n}$，其中 $\\Delta\\mathbf{n}$ 是一个分量很小（例如 $\\Delta n_i \\in \\{-1, 0, 1\\}$）的整数矢量。这将检查 $3^3=27$ 个 $\\mathbf{n}$ 的候选者，并保证如果解位于此局部邻域内就能找到它，这对于典型的物理系统来说是一个非常安全的假设。\n\n映射一个点 $\\mathbf{k}_{init}$ 的算法如下：\n1.  计算分数坐标 $\\mathbf{f'} = \\mathbf{B}^{-1}\\mathbf{k}_{init}$。\n2.  确定初始猜测的整数矢量 $\\mathbf{n}_{guess} = \\text{round}(\\mathbf{f'})$。\n3.  在以 $\\mathbf{n}_{guess}$ 为中心的 $3 \\times 3 \\times 3$ 立方体内搜索所有整数矢量 $\\mathbf{n}$。对于每个候选 $\\mathbf{n}$，计算距离的平方 $d^2 = \\lVert \\mathbf{k}_{init} - \\mathbf{B}\\mathbf{n} \\rVert^2$。\n4.  确定产生最小 $d^2$ 的矢量 $\\mathbf{n}^*$。\n5.  最终映射的点为 $\\mathbf{k}_{mapped} = \\mathbf{k}_{init} - \\mathbf{B}\\mathbf{n}^*$。\n\n### 4. FBZ 成员资格的验证\n\n为验证一个点 $\\mathbf{k}$ 是否在 FBZ 内，我们直接应用其定义。我们必须检查对于原点的一个足够大邻域内的所有非零整数矢量 $\\mathbf{n}$，是否都满足 $\\lVert \\mathbf{k} \\rVert^2 \\le \\lVert \\mathbf{k} - \\mathbf{B}\\mathbf{n} \\rVert^2$。对于这些测试用例，一个 $n_i \\in \\{-1, 0, 1\\}$（26 个非零矢量）的搜索框是足够的。使用一个小的数值容差 $\\epsilon$ 来处理浮点比较，即，我们检查 $\\lVert \\mathbf{k} \\rVert^2 > \\lVert \\mathbf{k} - \\mathbf{B}\\mathbf{n} \\rVert^2 + \\epsilon$ 是否成立，以宣告一个点在 FBZ 之外。\n\n### 5. 流程总结\n对于每个测试用例，总体算法流程如下：\n1.  给定 $\\mathbf{A}$，计算 $\\mathbf{B} = 2\\pi (\\mathbf{A}^{-1})^\\top$ 和 $\\mathbf{B}^{-1} = \\frac{1}{2\\pi} \\mathbf{A}^\\top$。\n2.  生成分数坐标 $\\mathbf{f}$ 的基本 Monkhorst-Pack 网格。\n3.  应用平移 $\\mathbf{s}$ 得到初始坐标 $\\mathbf{f'} = \\mathbf{f} + \\mathbf{s}$。\n4.  对每个 $\\mathbf{f'}$，计算初始 k 点 $\\mathbf{k}_{init} = \\mathbf{Bf'}$。\n5.  使用验证程序计算 FBZ 之外的初始点数量。\n6.  使用基于 CVP 的搜索算法将每个 $\\mathbf{k}_{init}$ 映射到其在 FBZ 内的等效点 $\\mathbf{k}_{mapped}$。\n7.  计算映射后仍在 FBZ 之外的点数（此值应为零）。\n8.  确定所有 $\\mathbf{k}_{mapped}$ 点中的最大欧几里得范数。\n9.  报告这三个计算出的值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements an algorithm for Monkhorst-Pack grid generation\n    and mapping to the First Brillouin Zone for a series of test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"A\": np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]),\n            \"N\": (2, 2, 2),\n            \"s\": np.array([0.0, 0.0, 0.0])\n        },\n        {\n            \"A\": np.array([[3.0, 0.0, 0.0], [0.0, 2.0, 0.0], [0.0, 0.0, 1.0]]),\n            \"N\": (3, 3, 3),\n            \"s\": np.array([0.6, 0.2, -0.4])\n        },\n        {\n            \"A\": np.array([[2.0, 0.1, 0.0], [0.0, 2.2, 0.3], [0.0, 0.0, 1.8]]),\n            \"N\": (4, 2, 3),\n            \"s\": np.array([0.3, 0.3, 0.3])\n        },\n        {\n            \"A\": np.array([[1.0, 0.5, 0.0], [0.0, 0.866, 0.0], [0.0, 0.0, 2.5]]),\n            \"N\": (1, 1, 1),\n            \"s\": np.array([1.2, -1.2, 0.8])\n        }\n    ]\n\n    results = []\n    \n    # Define the search box for integer vectors n for FBZ verification.\n    # A 3x3x3 cube around the origin is sufficient for these test cases.\n    verify_n_coords = [-1, 0, 1]\n    verify_n_vectors = []\n    for i in verify_n_coords:\n        for j in verify_n_coords:\n            for k in verify_n_coords:\n                if i == 0 and j == 0 and k == 0:\n                    continue\n                verify_n_vectors.append(np.array([i, j, k]))\n\n    def is_in_fbz(k_vec, B_mat, n_vectors, tol=1e-12):\n        \"\"\"\n        Verifies if a k-point is inside the First Brillouin Zone.\n        A point k is in the FBZ if ||k|| <= ||k - G|| for all G = B@n.\n        \"\"\"\n        k_norm_sq = np.dot(k_vec, k_vec)\n        for n in n_vectors:\n            G = B_mat @ n\n            k_shifted_norm_sq = np.dot(k_vec - G, k_vec - G)\n            if k_norm_sq > k_shifted_norm_sq + tol:\n                return False\n        return True\n\n    def map_to_fbz(k_vec, B_mat, B_inv_mat):\n        \"\"\"\n        Maps a k-point into the First Brillouin Zone by solving the\n        Closest Vector Problem over a local search grid.\n        \"\"\"\n        # Get fractional coordinates to find a good guess for integer vector n\n        f_prime = B_inv_mat @ k_vec\n        n_guess = np.round(f_prime)\n        \n        min_dist_sq = np.inf\n        best_n = np.zeros(3)\n\n        # Search in a 3x3x3 cube around the initial guess n_guess\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                for l in range(-1, 2):\n                    n_cand = n_guess + np.array([i, j, l])\n                    G_cand = B_mat @ n_cand\n                    dist_sq = np.dot(k_vec-G_cand, k_vec-G_cand)\n                    if dist_sq < min_dist_sq:\n                        min_dist_sq = dist_sq\n                        best_n = n_cand\n        \n        G_final = B_mat @ best_n\n        return k_vec - G_final\n\n    for case in test_cases:\n        A = case[\"A\"]\n        N = case[\"N\"]\n        s = case[\"s\"]\n        \n        B = 2 * np.pi * np.linalg.inv(A).T\n        B_inv = (1 / (2 * np.pi)) * A.T\n\n        # Generate Monkhorst-Pack grid points\n        N1, N2, N3 = N\n        m1_vals = np.arange(1, N1 + 1)\n        m2_vals = np.arange(1, N2 + 1)\n        m3_vals = np.arange(1, N3 + 1)\n\n        f1 = (m1_vals - (N1 + 1) / 2) / N1\n        f2 = (m2_vals - (N2 + 1) / 2) / N2\n        f3 = (m3_vals - (N3 + 1) / 2) / N3\n        \n        initial_k_points = []\n        for i in range(N1):\n            for j in range(N2):\n                for k in range(N3):\n                    f = np.array([f1[i], f2[j], f3[k]])\n                    f_shifted = f + s\n                    k_point = B @ f_shifted\n                    initial_k_points.append(k_point)\n\n        outside_before = 0\n        outside_after = 0\n        max_norm_after = 0.0\n\n        for k_init in initial_k_points:\n            if not is_in_fbz(k_init, B, verify_n_vectors):\n                outside_before += 1\n            \n            k_mapped = map_to_fbz(k_init, B, B_inv)\n            \n            if not is_in_fbz(k_mapped, B, verify_n_vectors):\n                outside_after += 1\n            \n            norm_val = np.linalg.norm(k_mapped)\n            if norm_val > max_norm_after:\n                max_norm_after = norm_val\n\n        results.append([outside_before, outside_after, round(max_norm_after, 6)])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3467044"}, {"introduction": "生成完整的 $k$ 点网格后，下一步自然是利用晶体的对称性来大幅减少计算量。本练习 [@problem_id:3467044] 建立在全网格生成的基础上，将教你如何实现一个算法来识别对称等价的 $k$ 点，构建最小的不可约点集，并计算它们相应的权重以确保积分的准确性。", "problem": "给定一个周期性的倒易点阵，其倒易基矢定义了倒易空间中的分数坐标。一个分数坐标 $\\mathbf{k}$ 代表一个波矢，该波矢在加上整数值的倒易点阵矢量后被认为是等价的，这意味着等价关系 $\\mathbf{k} \\sim \\mathbf{k} + \\mathbf{G}$ 对任意整数矢量 $\\mathbf{G} \\in \\mathbb{Z}^3$ 成立。考虑一组点操作 $\\{ \\mathbf{R} \\}$，通过 $\\mathbf{k} \\mapsto \\mathbf{R}\\mathbf{k}$ 作用于分数坐标。假设每个 $\\mathbf{R}$ 是一个行列式为 $\\det(\\mathbf{R}) = \\pm 1$ 的整数值 $3 \\times 3$ 矩阵，其作用保持倒易点阵不变，并且集合 $\\{ \\mathbf{R} \\}$ 在复合运算下是封闭的且包含单位操作。这些操作代表空间群的点群部分；它们对分数坐标的作用是在模倒易点阵平移下考虑的，即在应用 $\\mathbf{R}$ 之后，通过 $\\mathbf{k}' \\mapsto \\mathbf{k}' + \\mathbf{G}$（对于某个整数 $\\mathbf{G}$）将得到的 $\\mathbf{k}'$ 约化回一个正则晶胞，以将其置于一个选定的代表性区域内，例如正则超立方体 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$。\n\n你的任务是设计并实现一个程序，在给定：\n- 由整数 $\\mathbf{N} = (N_1, N_2, N_3)$ 指定的均匀 Monkhorst–Pack (MP) 采样网格，\n- 一组在分数倒易坐标下的封闭点操作 $\\{ \\mathbf{R} \\}$ 的情况下，\n\n构建不可约采样点集（相对于 $\\{ \\mathbf{R} \\}$ 的不可约布里渊区 (IBZ)），并为每个不可约代表点 $\\mathbf{k}_\\alpha$ 计算权重 $w_\\alpha$，使得每个对称等价类对总网格点数的贡献是成比例的。\n\n从基本定义和经过充分检验的事实开始：\n- 对于一个在所有点操作下保持不变的函数 $f(\\mathbf{k})$（即对所有 $\\mathbf{R} \\in \\{ \\mathbf{R} \\}$ 都有 $f(\\mathbf{R}\\mathbf{k}) = f(\\mathbf{k})$），其布里渊区积分可以通过在一个离散网格上的均匀求和来近似。当正确计算多重性时，约化到对称不等价点是有效的。\n- 在 $\\{ \\mathbf{R} \\}$ 的作用下，一个点 $\\mathbf{k}$ 的等价类（轨道）是集合 $\\mathcal{O}(\\mathbf{k}) = \\left\\{ \\mathrm{wrap}\\!\\left(\\mathbf{R}\\mathbf{k}\\right) \\mid \\mathbf{R} \\in \\{ \\mathbf{R} \\} \\right\\}$，其中 $\\mathrm{wrap}(\\cdot)$ 通过加上一个适当的整数矢量将分数坐标映射回一个正则晶胞。位于同一轨道上的不同网格点是对称等价的。\n\n对你的程序的要求：\n- 生成一个关于原点对称的 Monkhorst–Pack 网格，并以 $N_i$ 个点均匀采样每个倒易方向。该构造必须遵守周期性，即相差整数矢量的点在模倒易点阵下被视为相同。除了原点对称性和均匀间距（这是 Monkhorst–Pack 网格的标准要求）外，不要假设任何特定的中心化。\n- 在给定的 $\\{ \\mathbf{R} \\}$ 作用下，将整个网格划分为不相交的对称轨道。对每个轨道 $\\alpha$，选择一个正则代表点 $\\mathbf{k}_\\alpha$（例如，在 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$ 中字典序最小的分数坐标），并分配一个权重 $w_\\alpha = \\dfrac{|\\mathcal{O}(\\mathbf{k}_\\alpha)|}{N_1 N_2 N_3}$，其中 $|\\cdot|$ 表示轨道的大小。这个选择确保了总权重之和为 1，即 $\\sum_\\alpha w_\\alpha = 1$。\n- 使用一个数值上鲁棒的方法将坐标约化到 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$，并使用一个容差来识别通过对称操作映射的网格点。\n\n你的程序必须实现以上功能，并为每个测试用例产生以下结果元组：\n- 不可约点的整数数量 $M$。\n- 所有权重的浮点数总和 $S$。\n- 所有不可约点中的浮点数最小权重 $\\min w_\\alpha$。\n- 所有不可约点中的浮点数最大权重 $\\max w_\\alpha$。\n- 一个布尔值 $b$，指示 $|S - 1|$ 是否小于一个小的容差（例如 $10^{-12}$）。\n\n测试套件：\n- 案例 A（通用“理想路径”）：$\\mathbf{N} = (N_1, N_2, N_3) = (4, 4, 4)$，点操作为绕 z 轴的四重循环旋转，\n  $$\\mathbf{R}_0 = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix},\\quad\n    \\mathbf{R}_{90} = \\begin{pmatrix} 0 & -1 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix},\\quad\n    \\mathbf{R}_{180} = \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & -1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix},\\quad\n    \\mathbf{R}_{270} = \\begin{pmatrix} 0 & 1 & 0 \\\\ -1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}.$$\n- 案例 B（无对称性约化的边界条件）：$\\mathbf{N} = (N_1, N_2, N_3) = (3, 3, 3)$，仅有单位操作，\n  $$\\mathbf{R}_0 = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}.$$\n- 案例 C（带反演配对的边缘案例）：$\\mathbf{N} = (N_1, N_2, N_3) = (2, 2, 2)$，具有反演对称性，\n  $$\\mathbf{R}_0 = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix},\\quad\n    \\mathbf{R}_{\\mathrm{inv}} = \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & -1 & 0 \\\\ 0 & 0 & -1 \\end{pmatrix}.$$\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个格式为 $[M,S,\\min w_\\alpha,\\max w_\\alpha,b]$ 的列表。因此，整体输出必须看起来像\n  $$\\big[ [M_A,S_A,\\min w_A,\\max w_A,b_A], [M_B,S_B,\\min w_B,\\max w_B,b_B], [M_C,S_C,\\min w_C,\\max w_C,b_C] \\big],$$\n所有数字都以普通十进制形式打印，布尔值以普通逻辑值形式打印。此问题不涉及任何物理单位或角度单位；所有量都是无量纲的实数或整数。", "solution": "所提出的问题是，在给定一组点对称操作的情况下，开发一个程序，将布里渊区的均匀 Monkhorst-Pack (MP) k 点采样网格约化为其不可约集。我们还必须为每个不可约 k 点计算相应的权重。这项任务是现代电子结构计算的基石，因为它通过利用晶体对称性极大地降低了计算成本。该问题是适定的、科学上合理的，并为唯一的算法解提供了足够的信息。\n\n我们首先建立基本定义和原理。\n\n倒易空间中的一个点 $\\mathbf{k}$ 由相对于倒易基矢的分数坐标表示。周期性意味着，如果任意两点 $\\mathbf{k}$ 和 $\\mathbf{k}'$ 相差一个整数矢量 $\\mathbf{G} \\in \\mathbb{Z}^3$（即 $\\mathbf{k}' = \\mathbf{k} + \\mathbf{G}$），则它们被认为是等价的。为了使用唯一的表示，我们将所有 k 点映射到一个正则原胞中，此处选择为超立方体 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$。这个映射表示为 $\\mathrm{wrap}(\\mathbf{k})$，通过操作 $\\mathbf{k} \\mapsto \\mathbf{k} - \\lfloor \\mathbf{k} + \\tfrac{1}{2} \\rfloor$ 实现，其中操作是逐分量执行的。\n\nMonkhorst-Pack (MP) 网格是对倒易空间的均匀采样。对于由整数 $\\mathbf{N} = (N_1, N_2, N_3)$ 指定的网格，总共生成 $N_{tot} = N_1 N_2 N_3$ 个点。为确保网格相对于原点（$\\Gamma$ 点）对称，我们构造网格点 $\\mathbf{k}=(k_1, k_2, k_3)$，其中每个分量 $k_j$ 由下式给出：\n$$k_j = \\frac{2i_j - N_j - 1}{2N_j} \\quad \\text{for } i_j = 1, 2, \\dots, N_j$$\n这种构造生成了一组在反演操作 $\\mathbf{k} \\mapsto -\\mathbf{k}$（模倒易点阵矢量）下不变的 k 点。\n\n晶体的点群由一组对称操作 $\\{ \\mathbf{R} \\}$ 给出，这些操作是行列式为 $\\det(\\mathbf{R}) = \\pm 1$ 的 $3 \\times 3$ 整数矩阵。一个操作 $\\mathbf{R}$ 对 k 点 $\\mathbf{k}$ 的作用是一个线性变换 $\\mathbf{k}' = \\mathbf{R}\\mathbf{k}$，然后将结果约化回正则晶胞。\n\n如果存在一个操作 $\\mathbf{R} \\in \\{ \\mathbf{R} \\}$ 使得 $\\mathrm{wrap}(\\mathbf{R}\\mathbf{k}_a) = \\mathbf{k}_b$，那么两个 k 点 $\\mathbf{k}_a$ 和 $\\mathbf{k}_b$ 是对称等价的。与给定点 $\\mathbf{k}$ 等价的所有点的集合构成了它的轨道，$\\mathcal{O}(\\mathbf{k}) = \\{ \\mathrm{wrap}(\\mathbf{R}\\mathbf{k}) \\mid \\mathbf{R} \\in \\{ \\mathbf{R} \\} \\}$。这些轨道的基本性质是它们将整个 k 点网格划分为不相交的集合。\n\n目标是为每个轨道找到一个代表性 k 点。这组代表点构成了给定网格和对称性下的不可约布里渊区 (IBZ) k 点。代表点的选择必须是正则的以确保唯一性。一个标准的选择是每个轨道内字典序最小的 k 点。\n\n一个不可约 k 点 $\\mathbf{k}_\\alpha$ 的权重 $w_\\alpha$ 定义为其轨道大小 $|\\mathcal{O}(\\mathbf{k}_\\alpha)|$ 与完整网格中 k 点总数 $N_{tot}$ 的比率：\n$$w_\\alpha = \\frac{|\\mathcal{O}(\\mathbf{k}_\\alpha)|}{N_1 N_2 N_3}$$\n根据构造，所有不相交轨道的​​大小之和等于网格点的总数，$\\sum_\\alpha |\\mathcal{O}(\\mathbf{k}_\\alpha)| = N_{tot}$。因此，所有权重之和必须等于 1：\n$$\\sum_\\alpha w_\\alpha = \\sum_\\alpha \\frac{|\\mathcal{O}(\\mathbf{k}_\\alpha)|}{N_{tot}} = \\frac{1}{N_{tot}} \\sum_\\alpha |\\mathcal{O}(\\mathbf{k}_\\alpha)| = \\frac{N_{tot}}{N_{tot}} = 1$$\n\n实现此过程的算法如下：\n1.  网格生成：给定 $\\mathbf{N}=(N_1, N_2, N_3)$，使用上述原点对称构造方法生成包含 $N_{tot}$ 个 k 点的完整网格。\n2.  划分：遍历完整网格中的每个 k 点 $\\mathbf{k}_i$。为避免冗余计算，维护一个 `visited_points` 集合。\n    a. 如果 $\\mathbf{k}_i$ 已在 `visited_points` 中，则跳过它，因为它属于一个已被处理过的轨道。\n    b. 如果 $\\mathbf{k}_i$ 尚未被访问，则它是待发现的新轨道的第一个成员。\n3.  轨道构建：对于新点 $\\mathbf{k}_i$，通过应用每个对称操作 $\\mathbf{R} \\in \\{ \\mathbf{R} \\}$ 来计算其完整轨道：\n    a. 计算 $\\mathbf{k}' = \\mathrm{wrap}(\\mathbf{R}\\mathbf{k}_i)$。\n    b. 将得到的唯一 k 点 $\\mathbf{k}'$ 添加到一个代表当前轨道的临时集合中。此处的数值容差至关重要；如果浮点 k 矢量的分量差小于某个阈值（例如 $10^{-8}$），则认为它们是相同的。对四舍五入后的坐标元组进行哈希处理是管理唯一性的有效技术。\n4.  不可约点和权重：\n    a. 轨道大小 $|\\mathcal{O}(\\mathbf{k}_i)|$ 是上一步中找到的唯一 k 点的数量。\n    b. 权重计算为 $w_i = |\\mathcal{O}(\\mathbf{k}_i)| / N_{tot}$。\n    c. 该轨道的正则代表点选择为轨道中所有点里字典序最小的矢量。\n    d. 存储正则代表点及其权重。\n5.  更新已访问集合：将新计算出的轨道中的所有点添加到 `visited_points` 集合中。\n6.  重复：继续此过程，直到完整网格中的所有点都已被访问。\n7.  最终结果：迭代完成后，正则代表点列表即为不可约 k 点集。根据权重列表，计算不可约点的总数 $M$、权重总和 $S$、最小权重 $\\min w_\\alpha$ 和最大权重 $\\max w_\\alpha$。验证 $|S - 1|$ 是否低于某个数值容差。\n\n该算法系统地划分了整个网格，并正确地识别出不可约集及其权重，遵循了应用于晶格的群论原理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def wrap_to_canonical_cell(k_vector):\n        \"\"\"\n        Wraps a fractional coordinate vector into the canonical cell [-0.5, 0.5).\n        This is equivalent to k -> k - floor(k + 0.5).\n        \"\"\"\n        return k_vector - np.floor(k_vector + 0.5)\n\n    def get_k_point_hash(k_vector, precision=8):\n        \"\"\"\n        Creates a hashable representation of a k-vector by rounding to a\n        fixed precision to handle floating point inaccuracies.\n        \"\"\"\n        return tuple(np.round(k_vector, precision))\n\n    def generate_mp_grid(n_dims):\n        \"\"\"\n        Generates a Gamma-centered (origin-symmetric) Monkhorst-Pack grid.\n        Args:\n            n_dims (tuple): A tuple (N1, N2, N3) of grid dimensions.\n        Returns:\n            np.ndarray: A (N1*N2*N3, 3) array of k-point coordinates.\n        \"\"\"\n        k_coords = []\n        for n in n_dims:\n            # Formula for Gamma-centered grid: (2*i - N - 1) / (2*N) for i=1..N\n            k_coords.append((2 * np.arange(1, n + 1) - n - 1) / (2 * n))\n        \n        # Use meshgrid with 'ij' indexing to get Cartesian product in a standard order\n        kx, ky, kz = np.meshgrid(k_coords[0], k_coords[1], k_coords[2], indexing='ij')\n        \n        # Stack and reshape to get a list of (kx, ky, kz) vectors\n        grid = np.stack([kx, ky, kz], axis=-1).reshape(-1, 3)\n        return grid\n\n    def compute_ibz(n_dims, r_ops, tol=1e-12, hash_precision=8):\n        \"\"\"\n        Computes the irreducible Brillouin zone (IBZ) for a given MP grid\n        and a set of point group symmetry operations.\n\n        Args:\n            n_dims (tuple): Grid dimensions (N1, N2, N3).\n            r_ops (list): List of 3x3 numpy arrays for symmetry operations.\n            tol (float): Tolerance for checking if the sum of weights is 1.\n            hash_precision (int): Decimal precision for hashing k-points.\n\n        Returns:\n            tuple: (M, S, min_w, max_w, b) where\n                M: Number of irreducible points.\n                S: Sum of weights.\n                min_w: Minimum weight.\n                max_w: Maximum weight.\n                b: Boolean, True if |S-1| < tol.\n        \"\"\"\n        n_total = np.prod(n_dims)\n        full_grid = generate_mp_grid(n_dims)\n        \n        visited_k_hashes = set()\n        ir_k_points = []\n        ir_weights = []\n        \n        for k_point in full_grid:\n            # Check if point has been visited (is part of a previously found orbit)\n            # We must wrap the point first to get its canonical representation\n            # before checking the visited set.\n            canonical_k_point = wrap_to_canonical_cell(k_point)\n            k_hash = get_k_point_hash(canonical_k_point, hash_precision)\n\n            if k_hash in visited_k_hashes:\n                continue\n            \n            # If not visited, this k-point starts a new orbit.\n            # Generate the orbit by applying all symmetry operations.\n            orbit_hashes = set()\n            for r_mat in r_ops:\n                k_rotated = r_mat @ k_point\n                k_wrapped = wrap_to_canonical_cell(k_rotated)\n                orbit_hashes.add(get_k_point_hash(k_wrapped, hash_precision))\n            \n            # Calculate orbit properties\n            orbit_size = len(orbit_hashes)\n            weight = orbit_size / n_total\n            \n            # Determine canonical representative (lexicographically smallest)\n            canonical_rep_tuple = min(orbit_hashes)\n            \n            ir_k_points.append(np.array(canonical_rep_tuple))\n            ir_weights.append(weight)\n            \n            # Mark all points in the newly found orbit as visited\n            visited_k_hashes.update(orbit_hashes)\n            \n        m = len(ir_k_points)\n        s = np.sum(ir_weights)\n        min_w = np.min(ir_weights) if ir_weights else 0.0\n        max_w = np.max(ir_weights) if ir_weights else 0.0\n        b = np.abs(s - 1.0) < tol\n        \n        return m, s, min_w, max_w, b\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": (4, 4, 4),\n            \"R\": [\n                np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n                np.array([[0, -1, 0], [1, 0, 0], [0, 0, 1]]),\n                np.array([[-1, 0, 0], [0, -1, 0], [0, 0, 1]]),\n                np.array([[0, 1, 0], [-1, 0, 0], [0, 0, 1]]),\n            ]\n        },\n        {\n            \"N\": (3, 3, 3),\n            \"R\": [\n                np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n            ]\n        },\n        {\n            \"N\": (2, 2, 2),\n            \"R\": [\n                np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n                np.array([[-1, 0, 0], [0, -1, 0], [0, 0, -1]]),\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m, s, min_w, max_w, b_val = compute_ibz(case[\"N\"], case[\"R\"])\n        results.append(f\"[{m},{s},{min_w},{max_w},{str(b_val).lower()}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3467067"}, {"introduction": "在数值计算中，一个核心挑战是如何确定使用有限 $k$ 点网格所得结果的准确性。本练习介绍了一种评估收敛性的实用方法。你将学习如何利用两个不同网格的计算结果来构造后验误差估计，并应用理查森外推法获得更精确的结果，这项技术被广泛用于确保实际计算的可靠性。", "problem": "你需要实现一个完整的、可运行的程序，该程序生成 Monkhorst–Pack 网格，并用其为合成的能量密度和力密度的布里渊区积分构建后验误差估计和 Richardson 外推。背景是计算材料科学中布里渊区的数值积分。所有角度都以弧度处理，所有报告的量均为无量纲量。\n\n出发点是以下一组基本定义。\n\n- 布里渊区被视为由倒易晶格矢量 $\\mathbf{b}_1$、$\\mathbf{b}_2$ 和 $\\mathbf{b}_3$ 张成的平行六面体。对于晶格参数归一化的简单立方晶格，假设 $\\mathbf{b}_1 = 2\\pi \\,\\hat{\\mathbf{e}}_x$、$\\mathbf{b}_2 = 2\\pi \\,\\hat{\\mathbf{e}}_y$ 和 $\\mathbf{b}_3 = 2\\pi \\,\\hat{\\mathbf{e}}_z$，因此布里淵区在笛卡尔分量下是立方体 $[-\\pi,\\pi]^3$。布里渊区的体积为 $V_{\\mathrm{BZ}} = (2\\pi)^3$。\n\n- Monkhorst–Pack (MP) 网格由三个正整数 $(N_1,N_2,N_3)$ 和一个位移矢量 $\\mathbf{s} = (s_1,s_2,s_3)$ 定义，其中每个 $s_i \\in [0,1)$。在约化坐标中，采样点为\n$$\nt_i(n_i) = \\frac{n_i + s_i}{N_i}, \\quad n_i \\in \\{0,1,\\dots,N_i-1\\}, \\quad i\\in\\{1,2,3\\}。\n$$\n通过\n$$\n\\mathbf{k}(\\mathbf{n}) = \\sum_{i=1}^3 \\left( t_i(n_i) - \\frac{1}{2} \\right) \\mathbf{b}_i,\n$$\n映射到笛卡尔倒易空间，使得对于所有的 $\\mathbf{n}=(n_1,n_2,n_3)$，都有 $\\mathbf{k}(\\mathbf{n}) \\in [-\\pi,\\pi]^3$。\n\n- 标量被积函数 $f(\\mathbf{k})$ 的布里渊区平均值为\n$$\n\\bar{f} = \\frac{1}{V_{\\mathrm{BZ}}} \\int_{\\mathrm{BZ}} f(\\mathbf{k}) \\, d^3 k。\n$$\n均匀的 MP 网格求积法通过 $f$ 在网格点上的简单平均来近似 $\\bar{f}$，因为所有 MP 网格的权重都相等。对于矢量值被积函数 $\\mathbf{g}(\\mathbf{k})$，平均值是逐分量应用的。\n\n你将使用以下模拟金属费米面的、物理上合理的合成被积函数：\n\n- 总能量密度是半径为 $k_F$ 的费米球的指示函数，\n$$\ne(\\mathbf{k}) = \\mathbf{1}_{\\{\\|\\mathbf{k}\\|\\le k_F\\}},\n$$\n因此其精确的布里渊区平均值为\n$$\n\\bar{E}_{\\mathrm{exact}} = \\frac{1}{V_{\\mathrm{BZ}}} \\int_{\\mathrm{BZ}} \\mathbf{1}_{\\{\\|\\mathbf{k}\\|\\le k_F\\}} \\, d^3k = \\frac{\\frac{4}{3}\\pi k_F^3}{(2\\pi)^3} = \\frac{k_F^3}{6\\pi^2}。\n$$\n\n- 力密度是在同一费米球内部与 $\\mathbf{k}$ 成正比的矢量场，\n$$\n\\mathbf{f}(\\mathbf{k}) = \\mathbf{k} \\, \\mathbf{1}_{\\{\\|\\mathbf{k}\\|\\le k_F\\}},\n$$\n其精确的布里渊区平均值是零矢量，\n$$\n\\bar{\\mathbf{F}}_{\\mathrm{exact}} = \\frac{1}{V_{\\mathrm{BZ}}} \\int_{\\mathrm{BZ}} \\mathbf{k}\\, \\mathbf{1}_{\\{\\|\\mathbf{k}\\|\\le k_F\\}} \\, d^3k = \\mathbf{0},\n$$\n这是由对称性决定的。\n\n在具有位移 $\\mathbf{s}^{(N)}$ 的网格 $(N,N,N)$ 上，定义离散平均值\n$$\nE^{(N)} = \\frac{1}{N^3} \\sum_{\\mathbf{n}} e\\!\\left(\\mathbf{k}(\\mathbf{n})\\right), \\quad \\mathbf{F}^{(N)} = \\frac{1}{N^3} \\sum_{\\mathbf{n}} \\mathbf{f}\\!\\left(\\mathbf{k}(\\mathbf{n})\\right),\n$$\n同样地，在具有位移 $\\mathbf{s}^{(N+1)}$ 的 $(N+1,N+1,N+1)$ 网格上定义 $E^{(N+1)}$ 和 $\\mathbf{F}^{(N+1)}$。由于指示函数被积函数在费米面上不光滑，当使用均匀采样时，对于足够大的 $N$，形式为\n$$\nE^{(N)} = \\bar{E}_{\\infty} + \\frac{C_E}{N} + \\mathcal{O}\\!\\left(\\frac{1}{N^2}\\right), \\quad \\mathbf{F}^{(N)} = \\bar{\\mathbf{F}}_{\\infty} + \\frac{\\mathbf{C}_F}{N} + \\mathcal{O}\\!\\left(\\frac{1}{N^2}\\right),\n$$\n的主导误差模型是合适的。在此模型下，可以利用关于 $1/N$ 的 Richardson 外推法，从两个连续的网格中消除主导的 $\\mathcal{O}(1/N)$ 误差，并近似无限分辨率极限 $\\bar{E}_{\\infty}$ 和 $\\bar{\\mathbf{F}}_{\\infty}$。你必须从这个渐近模型中推导出标量和矢量情况下的外推公式，不得使用任何预先给定的简化公式。\n\n使用两个互补网格 $(N,N,N)$（位移为 $\\mathbf{s}^{(N)}$）和 $(N+1,N+1,N+1)$（位移为 $\\mathbf{s}^{(N+1)}$），构建后验误差估计，这里定义为不同的位移。标量能量的估计器应为一个非负标量，仅依赖于两个计算出的离散值；力的估计器应为一个非負标量，仅依赖于两个计算出的离散矢量，例如它们在某个合适范数下的差值。这些估计器不得使用任何关于精确积分的知识。\n\n程序中要实现的任务：\n\n- 根据上述定义，为给定的 $(N_1,N_2,N_3)$ 和位移 $\\mathbf{s}$ 生成 Monkhorst–Pack 网格。\n\n- 对每个测试用例，计算 $E^{(N)}$、 $E^{(N+1)}$、 $\\mathbf{F}^{(N)}$ 和 $\\mathbf{F}^{(N+1)}$。\n\n- 推导并应用关于 $1/N$ 的 Richardson 外推法，从 $E^{(N)}$、$E^{(N+1)}$ 和 $\\mathbf{F}^{(N)}$、$\\mathbf{F}^{(N+1)}$ 获得 $E^{\\mathrm{R}}$ 和 $\\mathbf{F}^{\\mathrm{R}}$。\n\n- 仅使用两个互补网格构建后验误差估计器 $\\eta_E$ 和 $\\eta_F$。\n\n- 仅为验证目的，通过将 $E^{\\mathrm{R}}$ 与 $\\bar{E}_{\\mathrm{exact}}$ 以及 $\\mathbf{F}^{\\mathrm{R}}$ 与 $\\bar{\\mathbf{F}}_{\\mathrm{exact}}$ 进行比较，来计算真实误差。\n\n测试套件，覆盖一个典型案例、一个具有不同位移的案例以及一个小网格的边界案例：\n\n- 案例 1: $N = 6$, $\\mathbf{s}^{(N)} = (0,0,0)$, $\\mathbf{s}^{(N+1)} = (0.5,0.5,0.5)$, $k_F = 1.2$.\n\n- 案例 2: $N = 3$, $\\mathbf{s}^{(N)} = (0.25,0.25,0.25)$, $\\mathbf{s}^{(N+1)} = (0.75,0.75,0.75)$, $k_F = 1.8$.\n\n- 案例 3: $N = 2$, $\\mathbf{s}^{(N)} = (0,0,0)$, $\\mathbf{s}^{(N+1)} = (0.5,0.5,0.5)$, $k_F = 0.3$.\n\n要求的最终输出格式：\n\n- 对每个案例，按以下顺序输出一个包含六个浮点数的列表：\n    1. $E^{\\mathrm{R}}$.\n    2. $\\eta_E$.\n    3. $\\left| E^{\\mathrm{R}} - \\bar{E}_{\\mathrm{exact}} \\right|$.\n    4. $\\left\\| \\mathbf{F}^{\\mathrm{R}} \\right\\|_2$.\n    5. $\\eta_F$.\n    6. $\\left\\| \\mathbf{F}^{\\mathrm{R}} - \\bar{\\mathbf{F}}_{\\mathrm{exact}} \\right\\|_2$.\n\n- 将三个案例的结果汇总到单行中，形成一个扁平的、逗号分隔的 Python 风格列表，不含额外文本，例如\n$$\n[\\text{案例 1 的六个数字}, \\text{案例 2 的六个数字}, \\text{案例 3 的六个数字}]。\n$$\n\n程序必须严格按照此格式生成一行输出。所有计算都以弧度进行，所有输出都是通过标准浮点表示法取整的无量纲实数。不允许使用外部输入或文件；所有数据都包含在程序中。", "solution": "用户提供的问题是计算材料科学领域一个明确定义的计算任务，具体涉及物理量在第一布里渊区上的数值积分。该问题在科学上是合理的，数学上是一致的，并且包含了进行求解所需的所有必要信息。\n\n问题的核心在于实现用于布里淵区采样的 Monkhorst-Pack (MP) 方法，然后应用 Richardson 外推法来提高计算积分的精度。我们将首先形式化所需的推导，然后概述计算过程。\n\n### Monkhorst-Pack 网格生成\n\n指定简单立方晶胞的倒易晶格由矢量 $\\mathbf{b}_1 = 2\\pi \\,\\hat{\\mathbf{e}}_x$、$\\mathbf{b}_2 = 2\\pi \\,\\hat{\\mathbf{e}}_y$ 和 $\\mathbf{b}_3 = 2\\pi \\,\\hat{\\mathbf{e}}_z$ 给出。第一布里渊区 (BZ) 对应于倒易晶格的 Wigner-Seitz 原胞，对于这个简单情况，它是一个由 $\\mathbf{k} = (k_x, k_y, k_z)$（其中 $k_i \\in [-\\pi, \\pi]$）定义的立方体。此 BZ 的体积为 $V_{\\mathrm{BZ}} = (2\\pi)^3$。\n\nMonkhorst-Pack 网格由一组正整数 $(N_1, N_2, N_3)$ 和一个位移矢量 $\\mathbf{s} = (s_1, s_2, s_3)$ 定义，其中每个分量 $s_i \\in [0, 1)$。网格点在约化坐标中为：\n$$\nt_i(n_i) = \\frac{n_i + s_i}{N_i}, \\quad \\text{for } n_i \\in \\{0, 1, \\dots, N_i-1\\}, \\quad i \\in \\{1, 2, 3\\}.\n$$\n这些约化坐标使用提供的公式映射到倒易空间中的笛卡尔坐标：\n$$\n\\mathbf{k}(\\mathbf{n}) = \\sum_{i=1}^3 \\left( t_i(n_i) - \\frac{1}{2} \\right) \\mathbf{b}_i\n$$\n对于简单立方晶格的特定 $\\mathbf{b}_i$ 矢量，$\\mathbf{k}$ 点的分量为：\n$$\nk_i(\\mathbf{n}) = k_i(n_i) = 2\\pi \\left( \\frac{n_i + s_i}{N_i} - \\frac{1}{2} \\right)\n$$\n该公式生成一个 $N_1 \\times N_2 \\times N_3$ 个点的均匀网格，用于对布里渊区进行采样。\n\n### 布里渊区积分的数值求積\n\n函数 $f(\\mathbf{k})$ 的布里渊区平均值定义为：\n$$\n\\bar{f} = \\frac{1}{V_{\\mathrm{BZ}}} \\int_{\\mathrm{BZ}} f(\\mathbf{k}) \\, d^3 k\n$$\nMonkhorst-Pack 方案通过在网格点上求值的函数值的简单算术平均来近似该积分。对于大小为 $N \\times N \\times N$ 的均匀网格，平均值 $\\bar{q}$ 的离散近似 $Q^{(N)}$ 为：\n$$\nQ^{(N)} = \\frac{1}{N^3} \\sum_{n_1=0}^{N-1} \\sum_{n_2=0}^{N-1} \\sum_{n_3=0}^{N-1} q(\\mathbf{k}(\\mathbf{n}))\n$$\n其中 $q$ 可以是标量能量密度 $e(\\mathbf{k})$ 或矢量力密度 $\\mathbf{f}(\\mathbf{k})$。问题指定了以下合成被积函数：\n-   能量密度：$e(\\mathbf{k}) = \\mathbf{1}_{\\{\\|\\mathbf{k}\\|\\le k_F\\}}$，其中 $\\mathbf{1}$ 是指示函数。精确平均值为 $\\bar{E}_{\\mathrm{exact}} = k_F^3 / (6\\pi^2)$。\n-   力密度：$\\mathbf{f}(\\mathbf{k}) = \\mathbf{k} \\, \\mathbf{1}_{\\{\\|\\mathbf{k}\\| \\le k_F\\}}$。由于被积函数在对称域上的奇对称性，精确平均值为 $\\bar{\\mathbf{F}}_{\\mathrm{exact}} = \\mathbf{0}$。\n\n### Richardson 外推法的推導\n\n问题指出，对于所使用的非光滑被积函数，离散平均值 $Q^{(N)}$ 收敛到真值 $\\bar{Q}_{\\infty}$ 的过程遵循以下渐近误差模型：\n$$\nQ^{(N)} = \\bar{Q}_{\\infty} + \\frac{C_Q}{N} + \\mathcal{O}\\left(\\frac{1}{N^2}\\right)\n$$\n其中 $C_Q$ 是一个常数。我们可以使用在不同网格上的两次计算来消除领先阶误差项 $\\mathcal{O}(1/N)$。考虑大小为 $N$ 和 $N+1$ 的网格。我们有：\n$$\nE^{(N)} = \\bar{E}_{\\infty} + \\frac{C_E}{N} + \\mathcal{O}\\left(\\frac{1}{N^2}\\right)\n$$\n$$\nE^{(N+1)} = \\bar{E}_{\\infty} + \\frac{C_E}{N+1} + \\mathcal{O}\\left(\\frac{1}{(N+1)^2}\\right)\n$$\n忽略高阶项，我们将其视为关于未知数 $\\bar{E}_{\\infty}$ 和 $C_E$ 的两个线性方程组：\n$$\nE^{(N)} \\approx \\bar{E}_{\\infty} + \\frac{C_E}{N} \\quad (1)\n$$\n$$\nE^{(N+1)} \\approx \\bar{E}_{\\infty} + \\frac{C_E}{N+1} \\quad (2)\n$$\n从 (1) 式，我们将 $C_E$ 表示为 $C_E \\approx N(E^{(N)} - \\bar{E}_{\\infty})$。将其代入 (2) 式得到：\n$$\nE^{(N+1)} \\approx \\bar{E}_{\\infty} + \\frac{N(E^{(N)} - \\bar{E}_{\\infty})}{N+1}\n$$\n乘以 $(N+1)$ 并重新排列以求解 $\\bar{E}_{\\infty}$：\n$$\n(N+1)E^{(N+1)} \\approx (N+1)\\bar{E}_{\\infty} + N(E^{(N)} - \\bar{E}_{\\infty})\n$$\n$$\n(N+1)E^{(N+1)} - NE^{(N)} \\approx (N+1)\\bar{E}_{\\infty} - N\\bar{E}_{\\infty} = \\bar{E}_{\\infty}\n$$\n这就得到了 Richardson 外推估计值 $E^{\\mathrm{R}}$，其误差为 $\\mathcal{O}(1/N^2)$：\n$$\nE^{\\mathrm{R}} = (N+1)E^{(N+1)} - N E^{(N)}\n$$\n同样的推导逐分量地应用于矢量 $\\mathbf{F}^{(N)}$，得出外推力矢量 $\\mathbf{F}^{\\mathrm{R}}$ 的类似公式：\n$$\n\\mathbf{F}^{\\mathrm{R}} = (N+1)\\mathbf{F}^{(N+1)} - N \\mathbf{F}^{(N)}\n$$\n\n### 后验误差估计\n\n后验误差估计器仅使用计算结果来衡量数值误差，而无需知道精确解。一个简单而有效的选择是两个网格结果之间差值的幅度。对于标量能量，我们将估计器 $\\eta_E$ 定义为：\n$$\n\\eta_E = |E^{(N+1)} - E^{(N)}|\n$$\n这个量与领先阶误差系数直接相关，因为 $\\eta_E \\approx |C_E|/(N(N+1))$。对于矢量力，我们将估计器 $\\eta_F$ 定义为差矢量的标准欧几里得范数：\n$$\n\\eta_F = \\|\\mathbf{F}^{(N+1)} - \\mathbf{F}^{(N)}\\|_2\n$$\n$\\eta_E$ 和 $\\eta_F$ 都是非负标量，用于衡量两个网格上计算结果的一致性，作为真实误差的代理。\n\n### 计算步骤总结\n\n对于由 $N$、$\\mathbf{s}^{(N)}$、$\\mathbf{s}^{(N+1)}$ 和 $k_F$ 指定的每个测试用例：\n1.  在具有位移 $\\mathbf{s}^{(N)}$ 的 $N \\times N \\times N$ 网格上计算离散平均值 $E^{(N)}$ 和 $\\mathbf{F}^{(N)}$。\n2.  在具有位移 $\\mathbf{s}^{(N+1)}$ 的 $(N+1) \\times (N+1) \\times (N+1)$ 网格上计算离散平均值 $E^{(N+1)}$ 和 $\\mathbf{F}^{(N+1)}$。\n3.  计算 Richardson 外推值 $E^{\\mathrm{R}} = (N+1)E^{(N+1)} - N E^{(N)}$ 和 $\\mathbf{F}^{\\mathrm{R}} = (N+1)\\mathbf{F}^{(N+1)} - N \\mathbf{F}^{(N)}$。\n4.  计算后验误差估计器 $\\eta_E = |E^{(N+1)} - E^{(N)}|$ 和 $\\eta_F = \\|\\mathbf{F}^{(N+1)} - \\mathbf{F}^{(N)}\\|_2$。\n5.  计算精确的能量平均值 $\\bar{E}_{\\mathrm{exact}} = k_F^3 / (6\\pi^2)$。精确的力平均值 $\\bar{\\mathbf{F}}_{\\mathrm{exact}}$ 是零矢量。\n6.  确定外推结果的真实误差：$|E^{\\mathrm{R}} - \\bar{E}_{\\mathrm{exact}}|$ 和 $\\|\\mathbf{F}^{\\mathrm{R}} - \\bar{\\mathbf{F}}_{\\mathrm{exact}}\\|_2 = \\|\\mathbf{F}^{\\mathrm{R}}\\|_2$。\n7.  按指定顺序收集六个所需的浮点数：$E^{\\mathrm{R}}$、$\\eta_E$、$|E^{\\mathrm{R}} - \\bar{E}_{\\mathrm{exact}}|$、$\\|\\mathbf{F}^{\\mathrm{R}}\\|_2$、$\\eta_F$ 和 $\\|\\mathbf{F}^{\\mathrm{R}} - \\bar{\\mathbf{F}}_{\\mathrm{exact}}\\|_2$。\n\n这些步骤在提供的 Python 程序中实现，以生成最终的数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_averages(grid_size: int, shift: np.ndarray, kF: float) -> tuple[float, np.ndarray]:\n    \"\"\"\n    Computes the discrete Brillouin zone averages for energy and force densities.\n\n    Args:\n        grid_size: The number of k-points along one dimension (N).\n        shift: The Monkhorst-Pack grid shift vector (s_1, s_2, s_3).\n        kF: The Fermi radius for the synthetic integrands.\n\n    Returns:\n        A tuple containing the average energy (scalar) and average force (3D vector).\n    \"\"\"\n    # Create 1D coordinate arrays for k_x, k_y, k_z\n    n_vals = np.arange(grid_size)\n    k_coords_1d = []\n    for i in range(3):\n        # Reduced coordinates\n        t_i = (n_vals + shift[i]) / grid_size\n        # Cartesian reciprocal coordinates\n        k_coord_i = 2 * np.pi * (t_i - 0.5)\n        k_coords_1d.append(k_coord_i)\n\n    # Create a 3D grid of k-vectors using meshgrid.\n    # 'ij' indexing ensures the output array axes correspond to kx, ky, kz.\n    kx_grid, ky_grid, kz_grid = np.meshgrid(\n        k_coords_1d[0], k_coords_1d[1], k_coords_1d[2], indexing='ij'\n    )\n    # Stack the coordinate grids to get a grid of 3D vectors.\n    # Shape: (grid_size, grid_size, grid_size, 3)\n    k_points = np.stack([kx_grid, ky_grid, kz_grid], axis=-1)\n\n    # Calculate the Euclidean norm of each k-vector in the grid.\n    k_norms = np.linalg.norm(k_points, axis=3)\n\n    # Evaluate the indicator function for the Fermi sphere.\n    # This represents the energy density e(k).\n    indicator = (k_norms <= kF).astype(float)\n\n    # The BZ average of e(k) is the simple mean over the grid.\n    E_avg = np.mean(indicator)\n\n    # Evaluate the force density f(k) = k * indicator.\n    # Use broadcasting to multiply the (N, N, N, 3) k_points grid\n    # by the (N, N, N) indicator grid.\n    f_k = k_points * indicator[..., np.newaxis]\n    \n    # The BZ average of f(k) is the mean over grid dimensions (0, 1, 2).\n    F_avg = np.mean(f_k, axis=(0, 1, 2))\n\n    return E_avg, F_avg\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 6, 's_N': (0.0, 0.0, 0.0), 's_Np1': (0.5, 0.5, 0.5), 'kF': 1.2},\n        {'N': 3, 's_N': (0.25, 0.25, 0.25), 's_Np1': (0.75, 0.75, 0.75), 'kF': 1.8},\n        {'N': 2, 's_N': (0.0, 0.0, 0.0), 's_Np1': (0.5, 0.5, 0.5), 'kF': 0.3},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N = case['N']\n        kF = case['kF']\n        s_N = np.array(case['s_N'])\n        s_Np1 = np.array(case['s_Np1'])\n\n        # Compute discrete averages for grid N and grid N+1\n        E_N, F_N = compute_averages(N, s_N, kF)\n        E_Np1, F_Np1 = compute_averages(N + 1, s_Np1, kF)\n\n        # Apply Richardson extrapolation\n        E_R = (N + 1) * E_Np1 - N * E_N\n        F_R = (N + 1) * F_Np1 - N * F_N\n\n        # Construct a posteriori error estimators\n        eta_E = np.abs(E_Np1 - E_N)\n        eta_F = np.linalg.norm(F_Np1 - F_N)\n\n        # Compute exact values for comparison\n        E_exact = kF**3 / (6 * np.pi**2)\n        F_exact_vec = np.array([0.0, 0.0, 0.0])\n\n        # Compute true errors of the extrapolated results\n        true_err_E = np.abs(E_R - E_exact)\n        norm_F_R = np.linalg.norm(F_R)\n        # The 6th required output is ||F^R - F_exact||_2, which is ||F^R - 0||_2 = ||F^R||_2\n        true_err_F = np.linalg.norm(F_R - F_exact_vec)\n\n        # Assemble the six required quantities for this test case\n        case_results = [\n            E_R,\n            eta_E,\n            true_err_E,\n            norm_F_R,\n            eta_F,\n            true_err_F,\n        ]\n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3467022"}]}