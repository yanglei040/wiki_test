{"hands_on_practices": [{"introduction": "朗之万动力学是在与热浴接触的系统中进行模拟的一种重要方法。该方法的核心是随机力项 $F_s(t)$，它模拟了由环境引起的热涨落。本练习旨在弥合连续时间物理模型（白噪声）与计算机模拟所需的离散时间数值实现之间的差距。理解如何从连续的涨落-耗散定理中推导出离散时间步中随机力的正确统计特性，是构建精确恒温器的关键第一步。[@problem_id:3484301]", "problem": "在质量为 $m$ 的单个原子的笛卡尔自由度的朗之万分子动力学中，通过涨落-耗散定理来模拟在温度 $T$ 下、线性摩擦系数为 $\\gamma$ 的恒温控制。设随机力 $\\eta(t)$ 是一个平稳零均值高斯白噪声，满足\n$$\n\\langle \\eta(t) \\rangle = 0, \\qquad \\langle \\eta(t)\\,\\eta(t') \\rangle = 2\\,\\gamma\\,k_{B}\\,T\\,\\delta(t-t'),\n$$\n其中 $k_{B}$ 是玻尔兹曼常数，$\\delta(\\cdot)$ 是狄拉克δ分布。考虑一个时间离散积分器，在从 $t_{n}$ 到 $t_{n+1}=t_{n}+\\Delta t$ 的每个宽度为 $\\Delta t>0$ 的时间步长内，该积分器用随机力 $\\eta(t)$ 在该区间上的时间平均值（一个恒定值）来近似它，\n$$\n\\eta_{n} \\equiv \\frac{1}{\\Delta t}\\int_{t_{n}}^{t_{n+1}} \\eta(t)\\,dt.\n$$\n根据上述定义以及高斯过程和狄拉克δ分布的标准性质，完成以下任务：\n\n- 在此平均规则下，推导离散时间序列 $\\{\\eta_{n}\\}$ 的均值和协方差，并论证 $\\eta_{n}$ 是否为高斯分布。\n- 证明每个 $\\eta_{n}$ 在实践中可以通过抽取一个标准正态变量，并用一个依赖于 $\\gamma$、$k_{B}$、$T$ 和 $\\Delta t$ 的确定性标准差 $\\sigma$ 进行缩放来采样得到。\n- 提供此标准差 $\\sigma$ 的闭式符号表达式。\n\n假设使用理想的伪随机数，除了模型所隐含的相关性外，没有其他相关性。将你的最终答案表示为 $\\sigma$ 关于 $\\gamma$、$k_{B}$、$T$ 和 $\\Delta t$ 的单个闭式解析表达式。最终答案中不要包含单位。如果进行了任何近似，请在推导中说明并证明其合理性；最终答案必须在上述白噪声模型下是精确的。", "solution": "该问题表述清晰，其科学基础是统计力学原理，特别是布朗运动和朗之万动力学理论。所有给定的定义和条件都是标准且自洽的。我们可以开始推导。\n\n目标是确定离散时间随机力 $\\eta_n$ 的统计性质，$\\eta_n$ 定义为连续时间随机力 $\\eta(t)$ 在宽度为 $\\Delta t$ 的时间区间上的时间平均。连续时间力 $\\eta(t)$ 是一个平稳高斯白噪声过程，具有以下性质：\n$$\n\\langle \\eta(t) \\rangle = 0\n$$\n$$\n\\langle \\eta(t)\\,\\eta(t') \\rangle = 2\\,\\gamma\\,k_{B}\\,T\\,\\delta(t-t')\n$$\n在区间 $[t_n, t_{n+1}]$（其中 $t_{n+1} = t_n + \\Delta t$）上的离散时间力 $\\eta_n$ 定义为：\n$$\n\\eta_{n} \\equiv \\frac{1}{\\Delta t}\\int_{t_{n}}^{t_{n+1}} \\eta(t)\\,dt\n$$\n\n首先，我们推导随机变量 $\\eta_n$ 的均值。根据期望算子和积分的线性性质，我们可以写出：\n$$\n\\langle \\eta_n \\rangle = \\left\\langle \\frac{1}{\\Delta t}\\int_{t_{n}}^{t_{n+1}} \\eta(t)\\,dt \\right\\rangle = \\frac{1}{\\Delta t}\\int_{t_{n}}^{t_{n+1}} \\langle \\eta(t) \\rangle\\,dt\n$$\n利用给定的性质 $\\langle \\eta(t) \\rangle = 0$ 对所有 $t$ 成立，该积分的计算结果为零：\n$$\n\\langle \\eta_n \\rangle = \\frac{1}{\\Delta t}\\int_{t_{n}}^{t_{n+1}} 0\\,dt = 0\n$$\n因此，离散时间力序列 $\\{\\eta_n\\}$ 是一个零均值过程。\n\n接下来，我们确定 $\\eta_n$ 是一个高斯随机变量。根据规定，连续时间过程 $\\eta(t)$ 是一个高斯过程。离散时间变量 $\\eta_n$ 是通过对 $\\eta(t)$ 进行线性运算（积分）得到的。高斯过程的一个基本性质是，过程的任何线性泛函都会产生一个高斯分布的随机变量。因此，序列中的每个 $\\eta_n$ 都是一个高斯随机变量。\n\n现在，我们推导该序列的协方差 $\\langle \\eta_n \\eta_m \\rangle$。使用 $\\eta_n$ 的定义：\n$$\n\\langle \\eta_n \\eta_m \\rangle = \\left\\langle \\left( \\frac{1}{\\Delta t}\\int_{t_{n}}^{t_{n+1}} \\eta(t)\\,dt \\right) \\left( \\frac{1}{\\Delta t}\\int_{t_{m}}^{t_{m+1}} \\eta(t')\\,dt' \\right) \\right\\rangle\n$$\n我们可以重排各项，并交换期望和积分算子：\n$$\n\\langle \\eta_n \\eta_m \\rangle = \\frac{1}{(\\Delta t)^2} \\int_{t_{n}}^{t_{n+1}} dt \\int_{t_{m}}^{t_{m+1}} dt' \\langle \\eta(t)\\,\\eta(t') \\rangle\n$$\n代入给定的 $\\eta(t)$ 的自相关函数：\n$$\n\\langle \\eta_n \\eta_m \\rangle = \\frac{1}{(\\Delta t)^2} \\int_{t_{n}}^{t_{n+1}} dt \\int_{t_{m}}^{t_{m+1}} dt' \\, (2\\,\\gamma\\,k_{B}\\,T\\,\\delta(t-t'))\n$$\n常数前因子可以移到积分之外：\n$$\n\\langle \\eta_n \\eta_m \\rangle = \\frac{2\\,\\gamma\\,k_{B}\\,T}{(\\Delta t)^2} \\int_{t_{n}}^{t_{n+1}} dt \\int_{t_{m}}^{t_{m+1}} dt' \\,\\delta(t-t')\n$$\n我们先计算关于 $t'$ 的内层积分。狄拉克δ分布的筛选性质表明 $\\int f(x)\\delta(x-a)dx = f(a)$。在这里，$\\delta(t-t')$ 在区间 $[t_m, t_{m+1}]$ 上的积分，如果 $t$ 在此区间内则结果为 $1$，否则为 $0$。所以，\n$$\n\\int_{t_{m}}^{t_{m+1}} \\delta(t-t')\\,dt' = \n\\begin{cases}\n1  \\text{if } t \\in [t_m, t_{m+1}] \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n协方差的表达式变为：\n$$\n\\langle \\eta_n \\eta_m \\rangle = \\frac{2\\,\\gamma\\,k_{B}\\,T}{(\\Delta t)^2} \\int_{t_{n}}^{t_{n+1}} dt \\, \\left( \\int_{t_{m}}^{t_{m+1}} \\delta(t-t')\\,dt' \\right)\n$$\n现在我们必须考虑关于 $t$ 的剩余积分的两种情况。\n情况1：$n \\neq m$。积分区间 $[t_n, t_{n+1}]$ 和 $[t_m, t_{m+1}]$ 不相交（它们仅在测度为零的边界点接触）。因此，对于 $[t_n, t_{n+1}]$ 中的任何 $t$，$t$ 都不在 $[t_m, t_{m+1}]$ 中。对于外层积分定义域中的所有 $t$，内层积分为零。因此：\n$$\n\\langle \\eta_n \\eta_m \\rangle = 0 \\quad \\text{for } n \\neq m\n$$\n情况2：$n = m$。积分区间相同，即 $[t_n, t_{n+1}]$。对于此区间内的任何 $t$，内层积分的结果为 $1$。表达式变为：\n$$\n\\langle \\eta_n^2 \\rangle = \\frac{2\\,\\gamma\\,k_{B}\\,T}{(\\Delta t)^2} \\int_{t_{n}}^{t_{n+1}} 1\\,dt = \\frac{2\\,\\gamma\\,k_{B}\\,T}{(\\Delta t)^2} (t_{n+1} - t_n)\n$$\n由于 $t_{n+1} - t_n = \\Delta t$，我们有：\n$$\n\\langle \\eta_n^2 \\rangle = \\frac{2\\,\\gamma\\,k_{B}\\,T}{(\\Delta t)^2} \\Delta t = \\frac{2\\,\\gamma\\,k_{B}\\,T}{\\Delta t}\n$$\n使用克罗内克δ函数 $\\delta_{nm}$ 结合这两种情况，序列的协方差为：\n$$\n\\langle \\eta_n \\eta_m \\rangle = \\frac{2\\,\\gamma\\,k_{B}\\,T}{\\Delta t} \\delta_{nm}\n$$\n这表明离散时间力在不同时间步之间是不相关的。由于它们也是高斯分布的，它们构成了一个独立同分布（i.i.d.）的随机变量序列。\n\n$\\eta_n$ 的方差由 $\\text{Var}(\\eta_n) = \\langle \\eta_n^2 \\rangle - \\langle \\eta_n \\rangle^2$ 给出。由于 $\\langle \\eta_n \\rangle = 0$，方差就是：\n$$\n\\text{Var}(\\eta_n) = \\langle \\eta_n^2 \\rangle = \\frac{2\\,\\gamma\\,k_{B}\\,T}{\\Delta t}\n$$\n一个均值为 $\\mu$、方差为 $\\sigma^2$ 的高斯随机变量 $X$（记作 $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$），可以通过一个标准正态变量 $Z \\sim \\mathcal{N}(0, 1)$ 使用变换 $X = \\mu + \\sigma Z$ 生成。\n在我们的例子中，$\\eta_n$ 是一个均值为 $\\mu=0$、方差如上所述的高斯随机变量。因此，可以通过抽取一个标准正态变量 $Z_n$ 并将其通过标准差 $\\sigma = \\sqrt{\\text{Var}(\\eta_n)}$ 进行缩放来对 $\\eta_n$ 进行采样。\n$$\n\\eta_n = \\sigma Z_n, \\quad \\text{where } Z_n \\sim \\mathcal{N}(0, 1)\n$$\n因此，所需的确定性标准差 $\\sigma$ 为：\n$$\n\\sigma = \\sqrt{\\frac{2\\,\\gamma\\,k_{B}\\,T}{\\Delta t}}\n$$\n如题目所要求，该表达式仅依赖于物理参数 $\\gamma$、$k_B$、$T$ 和积分器时间步长 $\\Delta t$。除了初始的白噪声模型外，没有做任何近似。", "answer": "$$\n\\boxed{\\sqrt{\\frac{2 \\gamma k_{B} T}{\\Delta t}}}\n$$", "id": "3484301"}, {"introduction": "在上一个练习中，我们确定了在离散时间步中模拟随机力需要从具有特定方差的高斯分布中抽样。然而，大多数标准随机数库仅提供均匀分布的随机数。本练习将解决如何从均匀分布的随机数生成高斯分布随机数的实际问题。我们将实现经典的 Box-Muller 变换，并从分析层面比较其与另一种方法（Ziggurat 算法）的计算成本，这对于在高性能计算中选择高效算法至关重要。[@problem_id:3484341]", "problem": "您的任务是实现一个基于变换的高斯随机数生成器，并对计算材料科学中高通量模拟常用的两种不同策略的计算成本进行解析比较。具体来说，您将实现一个基于 Box–Muller 变换的生成器，并将其操作计数与 Ziggurat 式接受-拒绝方案在参数化模型下的操作计数进行比较。所有问题都必须纯粹用数学和算法术语来回答，所有结果都必须由一个单一、完整的程序产生。\n\n从变换法生成随机变量的基本原理和基本概率定义出发，您必须：\n\n1. 实现一个生成器，该生成器将开区间 $(0,1)$ 上的两个独立均匀分布变量（记为 $U_1$ 和 $U_2$）映射到两个独立标准正态随机变量 $Z_1$ 和 $Z_2$。您的生成器必须使用独立同分布的均匀变量和变换法，从标准正态分布 $\\mathcal{N}(0,1)$ 中产生 $n$ 个独立样本。使用一个伪随机数生成器和一个提供的整数种子来确保确定性。在计算统计数据时，使用除数为 $n-1$ 的无偏样本方差。所有数值没有物理单位。\n\n2. 从期望值和独立性的第一性原理出发，不依赖任何计时测量，推导出以下几类操作的预期单位样本操作计数的表达式：均匀分布抽样、对数、平方根和三角函数求值。将 Box–Muller 变换视为每次应用该变换使用两个均匀分布变量产生两个正态分布变量，并伴随一次对数运算、一次平方根运算和两次三角函数求值。对于 Ziggurat 方案，假设一个参数化模型，其中每次生成样本的“尝试”以概率 $p \\in (0,1)$ 独立成功，并且：\n   - 每次尝试使用一次均匀分布抽样。\n   - 在被拒绝的情况下（以概率 $1-p$ 发生），会进入一个尾部路径，该路径会产生 $c_{\\log}$ 次对数运算，$c_{\\sqrt}$ 次平方根运算和 $c_{\\mathrm{trig}}$ 次三角函数求值。您可以假设在接受的尝试中，除了这个尾部路径之外，不使用任何超越运算。\n   仅使用上述定义和期望的线性性质，计算两种策略生成 $M$ 个样本时每种操作的预期总计数。\n\n3. 对于每个测试用例，您的程序必须按如下规定产生确定性的数值输出。所有答案都必须是无量纲的。如果需要四舍五入，请按每个测试用例的说明进行。\n\n测试套件：\n- 测试用例 A (正常路径): 使用 Box–Muller 变换生成 $n = 100000$ 个样本，种子为 $2025$。输出样本均值 $\\bar{Z}$ 和无偏样本方差 $s^2$，均四舍五入到 $6$ 位小数。\n- 测试用例 B (边界条件): 使用相同的生成器生成 $n = 2$ 个样本，种子为 $1$。按生成器产生的顺序输出这两个值，均四舍五入到 $6$ 位小数。\n- 测试用例 C (权衡，高接受率): 对于 $M = 1000000$, $p = 0.9973$, $c_{\\log} = 1.0$, $c_{\\sqrt}} = 1.0$, $c_{\\mathrm{trig}} = 0.0$，计算两种策略的预期总操作计数。对于 Box–Muller 变换，以 $[N_{\\mathrm{uni}}, N_{\\log}, N_{\\sqrt}}, N_{\\mathrm{trig}}]$ 的形式报告计数。对于 Ziggurat 模型，以相同的顺序报告计数。将这些值按 Box–Muller 然后 Ziggurat 的顺序连接成一个包含八个值的列表。将每个计数四舍五入到 $1$ 位小数。\n- 测试用例 D (临界接受率): 对于 $M = 1000000$, $p = 0.9$, $c_{\\log} = 1.0$, $c_{\\sqrt}} = 1.0$, $c_{\\mathrm{trig}} = 0.0$，重复与测试用例 C 相同的计算和输出，同样将每个计数四舍五入到 $1$ 位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，按顺序汇总四个测试用例的输出。元素应为：\n- 对于测试用例 A：一个二元素列表 $[\\bar{Z}, s^2]$（每个值四舍五入到 $6$ 位小数）。\n- 对于测试用例 B：一个二元素列表，包含两个生成的值（每个值四舍五入到 $6$ 位小数）。\n- 对于测试用例 C：一个八元素列表，包含指定的四舍五入后的计数。\n- 对于测试用例 D：一个八元素列表，包含指定的四舍五入后的计数。\n例如，其结构应为 $[[\\cdot,\\cdot],[\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]]$。输出必须是单行，且仅包含此列表表示。", "solution": "问题陈述经评估有效。它在科学上是合理的，问题定义清晰，客观，并且包含唯一解所需的所有必要信息。该任务涉及实现用于生成标准正态随机变量的 Box–Muller 变换，并将其计算成本与 Ziggurat 式拒绝抽样方法的参数化模型进行解析比较。我将继续提供完整的解决方案。\n\n解决方案分为两个主要部分：抽样算法和解析成本模型的推导，以及针对所提供测试用例的具体计算。\n\n**第一部分：Box–Muller 变换生成器**\n\n目标是从标准正态分布 $\\mathcal{N}(0,1)$ 中生成随机变量，其概率密度函数 (PDF) 为 $f(z) = \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2}$。变换法利用了这样一个事实：如果我们可以将目标随机变量表示为一个或多个“基础”随机变量（我们有其生成器）的函数，我们就可以从目标分布中生成样本。\n\nBox–Muller 变换将从区间 $(0,1)$ 上的均匀分布中抽取的两个独立随机变量 $U_1$ 和 $U_2$ 映射到两个独立标准正态随机变量 $Z_1$ 和 $Z_2$。该变换由以下方程定义：\n$$Z_1 = \\sqrt{-2 \\ln U_1} \\cos(2\\pi U_2)$$\n$$Z_2 = \\sqrt{-2 \\ln U_1} \\sin(2\\pi U_2)$$\n这是通过从二维笛卡尔坐标系 $(Z_1, Z_2)$ 到极坐标系的变量变换推导出来的。两个独立标准正态变量的联合概率密度函数是 $f(z_1, z_2) = f(z_1)f(z_2) = \\frac{1}{2\\pi} e^{-(z_1^2+z_2^2)/2}$。在极坐标中，其中 $z_1 = r \\cos\\theta$ 和 $z_2 = r \\sin\\theta$，我们有 $r^2 = z_1^2 + z_2^2$ 和 $\\theta = \\arctan(z_2/z_1)$。联合概率密度函数变为 $g(r, \\theta) = \\frac{1}{2\\pi} e^{-r^2/2} r$，其中 $r \\in [0, \\infty)$ 和 $\\theta \\in [0, 2\\pi)$。这个概率密度函数可以分离为 $g(r, \\theta) = \\left(r e^{-r^2/2}\\right) \\left(\\frac{1}{2\\pi}\\right)$，这表明径向分量 $R$ 和角向分量 $\\Theta$ 是独立的。$\\Theta$ 的分布是 Uniform$(0, 2\\pi)$，而 $R$ 的分布的概率密度函数为 $h(r) = r e^{-r^2/2}$（瑞利分布）。\n\n我们可以通过 $\\Theta = 2\\pi U_2$ 从 $U_2$ 生成 $\\Theta$。我们可以通过将 $R^2$ 的累积分布函数 (CDF) 等于 $U_1$ 来从 $U_1$ 生成 $R$。$R^2$ 的累积分布函数是 $P(R^2 \\le x) = P(R \\le \\sqrt{x}) = \\int_0^{\\sqrt{x}} r' e^{-(r')^2/2} dr' = 1 - e^{-x/2}$。令 $U_1 = 1 - e^{-R^2/2}$ 并求解 $R^2$ 得到 $R^2 = -2 \\ln(1-U_1)$。由于 $U_1$ 和 $1-U_1$ 是同分布的，我们可以将其简化为 $R^2 = -2 \\ln U_1$，这给出 $R = \\sqrt{-2 \\ln U_1}$。将这些 $R$ 和 $\\Theta$ 的表达式代入笛卡尔坐标转换公式 $Z_1 = R\\cos\\Theta$ 和 $Z_2 = R\\sin\\Theta$ 即得到 Box–Muller 方程。\n\n要生成 $n$ 个样本，我们执行 $\\lceil n/2 \\rceil$ 次此变换。每次应用消耗两个均匀分布变量并产生两个正态分布变量。如果 $n$ 是奇数，最后一次变换将产生比所需多一个的样本，这个多余的样本将被丢弃。\n\n**第二部分：解析操作计数比较**\n\n我们将推导使用两种策略生成 $M$ 个样本的预期总操作数。我们感兴趣的操作是均匀随机数抽样 ($N_{\\mathrm{uni}}$)、对数 ($N_{\\log}$)、平方根 ($N_{\\sqrt}}$) 和三角函数求值 ($N_{\\mathrm{trig}}$)。\n\n**策略 1：Box–Muller 变换**\n成本模型是明确给出的：一次变换产生 $2$ 个正态样本，成本为 $2$ 次均匀分布抽样、$1$ 次对数运算、$1$ 次平方根运算和 $2$ 次三角函数求值。要精确生成 $M$ 个样本，我们需要执行 $\\lceil M/2 \\rceil$ 次变换。对于测试用例中的偶数值 $M=1000000$，这简化为 $M/2$。\n总操作计数是确定性的：\n-   $N_{\\mathrm{uni}} = 2 \\times (M/2) = M$\n-   $N_{\\log} = 1 \\times (M/2) = M/2$\n-   $N_{\\sqrt}} = 1 \\times (M/2) = M/2$\n-   $N_{\\mathrm{trig}} = 2 \\times (M/2) = M$\n\n**策略 2：参数化 Ziggurat 模型**\n该模型描述了一种接受-拒绝方案，其中单个样本的生成是一系列伯努利试验。每次生成样本的尝试以概率 $p$ 成功。设 $K$ 是表示生成一个成功样本所需尝试次数的随机变量。$K$ 服从成功概率为 $p$ 的几何分布，因此其概率质量函数为 $P(K=k) = (1-p)^{k-1}p$，对于 $k=1, 2, \\dots$。\n生成一个样本的预期尝试次数是 $E[K] = 1/p$。\n\n要生成 $M$ 个样本，我们需要 $M$ 个独立的成功生成过程。根据期望的线性性质，总的预期尝试次数是：\n$$E[N_{\\mathrm{attempts}}] = M \\cdot E[K] = \\frac{M}{p}$$\n根据模型，每次尝试使用一次均匀分布抽样。因此，均匀分布抽样的预期总计数是：\n$$E[N_{\\mathrm{uni}}] = E[N_{\\mathrm{attempts}}] = \\frac{M}{p}$$\n超越运算（对数、平方根、三角函数）仅在被拒绝的尝试中产生。单次尝试被拒绝的概率是 $1-p$。获得一个成功样本的拒绝次数是 $K-1$。每个样本的预期拒绝次数是 $E[K-1] = E[K]-1 = (1/p) - 1 = (1-p)/p$。\n生成 $M$ 个样本的总预期拒绝次数是 $M \\cdot (1-p)/p$。\n给定每次拒绝的成本 $c_{\\log}$、$c_{\\sqrt}}$ 和 $c_{\\mathrm{trig}}$，这些操作的总预期计数为：\n-   $E[N_{\\log}] = M \\frac{1-p}{p} c_{\\log}$\n-   $E[N_{\\sqrt}}] = M \\frac{1-p}{p} c_{\\sqrt}}$\n-   $E[N_{\\mathrm{trig}}] = M \\frac{1-p}{p} c_{\\mathrm{trig}}$\n\n**第三部分：测试用例的数值评估**\n\n**测试用例 A 和 B**：这些需要直接实现 Box–Muller 生成器并计算样本统计量。实现将遵循第一部分中的方程。对于测试用例 A，使用种子 $2025$ 生成 $n=100000$ 个样本。计算样本均值 $\\bar{Z} = \\frac{1}{n}\\sum_{i=1}^n Z_i$ 和无偏样本方差 $s^2 = \\frac{1}{n-1}\\sum_{i=1}^n (Z_i-\\bar{Z})^2$。对于测试用例 B，使用种子 $1$ 生成 $n=2$ 个样本。\n\n**测试用例 C**：$M = 1000000$, $p = 0.9973$, $c_{\\log} = 1.0$, $c_{\\sqrt}} = 1.0$, $c_{\\mathrm{trig}} = 0.0$。\n-   **Box–Muller 计数**：\n    -   $N_{\\mathrm{uni}} = 1000000$\n    -   $N_{\\log} = 1000000 / 2 = 500000$\n    -   $N_{\\sqrt}} = 1000000 / 2 = 500000$\n    -   $N_{\\mathrm{trig}} = 1000000$\n-   **Ziggurat 预期计数**：\n    -   $E[N_{\\mathrm{uni}}] = 1000000 / 0.9973 \\approx 1002707.31$\n    -   $E[N_{\\log}}] = 1000000 \\times \\frac{1-0.9973}{0.9973} \\times 1.0 \\approx 2707.31$\n    -   $E[N_{\\sqrt}}] = 1000000 \\times \\frac{1-0.9973}{0.9973} \\times 1.0 \\approx 2707.31$\n    -   $E[N_{\\mathrm{trig}}] = 1000000 \\times \\frac{1-0.9973}{0.9973} \\times 0.0 = 0.0$\n-   四舍五入到 $1$ 位小数后，最终列表为 $[1000000.0, 500000.0, 500000.0, 1000000.0, 1002707.3, 2707.3, 2707.3, 0.0]$。\n\n**测试用例 D**：$M = 1000000$, $p = 0.9$, $c_{\\log} = 1.0$, $c_{\\sqrt}} = 1.0$, $c_{\\mathrm{trig}} = 0.0$。\n-   **Box–Muller 计数**：与测试用例 C 相同。\n    -   $N_{\\mathrm{uni}} = 1000000$\n    -   $N_{\\log} = 500000$\n    -   $N_{\\sqrt}} = 500000$\n    -   $N_{\\mathrm{trig}} = 1000000$\n-   **Ziggurat 预期计数**：\n    -   $E[N_{\\mathrm{uni}}] = 1000000 / 0.9 \\approx 1111111.11$\n    -   $E[N_{\\log}}] = 1000000 \\times \\frac{1-0.9}{0.9} \\times 1.0 \\approx 111111.11$\n    -   $E[N_{\\sqrt}}] = 1000000 \\times \\frac{1-0.9}{0.9} \\times 1.0 \\approx 111111.11$\n    -   $E[N_{\\mathrm{trig}}] = 1000000 \\times \\frac{1-0.9}{0.9} \\times 0.0 = 0.0$\n-   四舍五入到 $1$ 位小数后，最终列表为 $[1000000.0, 500000.0, 500000.0, 1000000.0, 1111111.1, 111111.1, 111111.1, 0.0]$。\n这完成了分析解。实现将产生最终的数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef box_muller_generator(n, seed):\n    \"\"\"\n    Generates n samples from the standard normal distribution using the Box-Muller transform.\n\n    Args:\n        n (int): The number of samples to generate.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        np.ndarray: An array of n standard normal random variates.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # We generate pairs of normals, so we need ceil(n/2) pairs.\n    num_pairs = (n + 1) // 2\n    \n    # Generate all uniform random numbers at once for efficiency.\n    # U1 and U2 must be in (0, 1). rng.random gives [0, 1). The probability of\n    # getting 0 is negligible and can be ignored for this problem's scope.\n    u1 = rng.random(size=num_pairs)\n    u2 = rng.random(size=num_pairs)\n    \n    R = np.sqrt(-2.0 * np.log(u1))\n    theta = 2.0 * np.pi * u2\n    \n    z1 = R * np.cos(theta)\n    z2 = R * np.sin(theta)\n    \n    # Interleave z1 and z2 to form the full sample array\n    samples = np.empty(num_pairs * 2, dtype=np.float64)\n    samples[0::2] = z1\n    samples[1::2] = z2\n    \n    # If n is odd, we will have generated n+1 samples, so truncate.\n    return samples[:n]\n\ndef calculate_operation_counts(M, p, c_log, c_sqrt, c_trig):\n    \"\"\"\n    Calculates expected operation counts for Box-Muller and Ziggurat model.\n\n    Args:\n        M (int): Number of samples to generate.\n        p (float): Success probability for Ziggurat model.\n        c_log (float): Logarithm cost per rejection in Ziggurat.\n        c_sqrt (float): Square root cost per rejection in Ziggurat.\n        c_trig (float): Trig cost per rejection in Ziggurat.\n    \n    Returns:\n        list: A list of 8 floats representing the operation counts for\n              [BM_uni, BM_log, BM_sqrt, BM_trig, ZIG_uni, ZIG_log, ZIG_sqrt, ZIG_trig]\n    \"\"\"\n    # Box-Muller counts\n    # M is even, so ceil(M/2) is M/2.\n    bm_uni = float(M)\n    bm_log = float(M / 2)\n    bm_sqrt = float(M / 2)\n    bm_trig = float(M)\n    \n    # Ziggurat expected counts\n    exp_rej_factor = M * (1.0 - p) / p\n    \n    zig_uni = M / p\n    zig_log = exp_rej_factor * c_log\n    zig_sqrt = exp_rej_factor * c_sqrt\n    zig_trig = exp_rej_factor * c_trig\n    \n    counts = [\n        bm_uni, bm_log, bm_sqrt, bm_trig,\n        zig_uni, zig_log, zig_sqrt, zig_trig\n    ]\n    \n    return [round(c, 1) for c in counts]\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the final result.\n    \"\"\"\n    # --- Test Case A ---\n    n_A = 100000\n    seed_A = 2025\n    samples_A = box_muller_generator(n_A, seed_A)\n    mean_A = round(np.mean(samples_A), 6)\n    var_A = round(np.var(samples_A, ddof=1), 6)\n    result_A = [mean_A, var_A]\n\n    # --- Test Case B ---\n    n_B = 2\n    seed_B = 1\n    samples_B = box_muller_generator(n_B, seed_B)\n    result_B = [round(s, 6) for s in samples_B]\n    \n    # --- Test Case C ---\n    M_C = 1000000\n    p_C = 0.9973\n    clog_C, csqrt_C, ctri_C = 1.0, 1.0, 0.0\n    result_C = calculate_operation_counts(M_C, p_C, clog_C, csqrt_C, ctri_C)\n\n    # --- Test Case D ---\n    M_D = 1000000\n    p_D = 0.9\n    clog_D, csqrt_D, ctri_D = 1.0, 1.0, 0.0\n    result_D = calculate_operation_counts(M_D, p_D, clog_D, csqrt_D, ctri_D)\n\n    # Aggregate all results\n    final_results = [result_A, result_B, result_C, result_D]\n\n    # Format the final output string exactly as required, without spaces.\n    # Using str() and replace() is a reliable way to get the format.\n    output_str = str(final_results).replace(' ', '')\n    \n    print(output_str)\n\nsolve()\n```", "id": "3484341"}, {"introduction": "现代材料模拟通常在并行计算机上进行，计算任务被分解到多个处理单元上。这带来了一个严峻的挑战：如何确保每个子域中使用的随机数在统计上是独立的。本练习将探讨一种应对此挑战的现代解决方案，即使用基于计数器的生成器和“跳跃”（skip-ahead）技术。本练习不仅指导您实现这一高级策略，还要求您通过量化流间相关性来验证其有效性，这是确保大规模并行模拟结果可靠性的关键技能。[@problem_id:3484374]", "problem": "考虑在区域分解的分子动力学（MD）中生成独立的随机力，其中计算域被分割成 $P$ 个不重叠的子域，每个子域由一个单独的任务推进。假设随机恒温器需要每个子域 $i \\in \\{0,1,\\dots,P-1\\}$ 有一个离散时间的、零均值、单位方差的白噪声力序列 $\\{\\eta_i(t)\\}_{t=0}^{N-1}$。跨子域的独立性至关重要，以避免伪相关。\n\n您的任务是设计一个程序，使用基于计数器的伪随机数生成器（PRNG）上的跳跃（skip-ahead）方法来构建 $P$ 个独立的随机流，并通过计算互协方差 $\\langle \\eta_i(t)\\eta_j(t+\\Delta t)\\rangle$（其中 $i \\neq j$）来量化流间的相关性。该构建和量化过程必须实现为一个完整的、可运行的程序。\n\n基本原理：\n- 基于计数器的PRNG输出一个值，该值是一个整数计数器和固定种子的确定性函数。独立流之间通过确保不同流的计数器不重叠来实现独立性。\n- 对于理想的白噪声，对于所有 $i \\neq j$ 和所有整数延迟 $\\Delta t \\geq 0$，$\\mathbb{E}[\\eta_i(t)] = 0$，$\\mathrm{Var}[\\eta_i(t)]=1$，且 $\\mathbb{E}[\\eta_i(t)\\eta_j(t+\\Delta t)] = 0$。在经验上，互协方差是根据有限样本估算的。\n- 序列 $x(t)$ 的样本均值为 $\\bar{x} = \\frac{1}{N} \\sum_{t=0}^{N-1} x(t)$。序列 $x(t)$ 和 $y(t)$ 在延迟 $\\Delta t$ 时的样本互协方差定义为\n$$\n\\hat{C}_{xy}(\\Delta t) = \\frac{1}{N-\\Delta t} \\sum_{t=0}^{N-\\Delta t - 1} \\big(x(t) - \\bar{x}\\big)\\big(y(t+\\Delta t)-\\bar{y}\\big),\n$$\n对于整数 $0 \\leq \\Delta t  N$。\n\n要求：\n1. 使用 SplitMix64 混合函数实现一个固定的基于计数器的 PRNG，其使用一个 $64$ 位无符号整数计数器 $c$ 和一个 $64$ 位无符号整数种子 $s$，定义如下\n$$\n\\begin{aligned}\nx = (c + s) \\bmod 2^{64}, \\\\\nx = \\left(x \\oplus (x \\gg 30)\\right) \\times 0x\\mathrm{BF58476D1CE4E5B9} \\bmod 2^{64}, \\\\\nx = \\left(x \\oplus (x \\gg 27)\\right) \\times 0x\\mathrm{94D049BB133111EB} \\bmod 2^{64}, \\\\\nx = x \\oplus (x \\gg 31),\n\\end{aligned}\n$$\n其中 $\\oplus$ 表示按位异或，$\\gg$ 表示按位右移。通过提取高 $53$ 位并除以 $2^{53}$，将 $64$ 位输出转换为 $[0,1)$ 上的浮点均匀分布变量。\n\n2. 使用跳跃（skip-ahead）方法构建 $P$ 个流。对于流索引 $i$，定义一个基础计数器偏移量 $C_i = i \\times M$，其中 $M$ 是一个正整数步长。对于时间索引 $t$，计数器为 $c = C_i + t$。只要 $M$ 相对于 $N$ 足够大，这就能确保跨流的计数器不重叠。\n\n3. 使用 Box–Muller 变换将均匀分布变量映射为标准正态分布变量，以产生 $\\eta_i(t)$。对于每对均匀变量 $u_1,u_2 \\in (0,1)$，计算\n$$\nr = \\sqrt{-2 \\ln(u_1)}, \\quad \\theta = 2\\pi u_2, \\quad z_0 = r \\cos(\\theta), \\quad z_1 = r \\sin(\\theta),\n$$\n并使用 $\\{z_0,z_1\\}$ 作为连续的样本。角度必须是弧度制。\n\n4. 对于每个测试用例，计算所有不同流对 $(i,j)$（$i \\neq j$）在每个指定的延迟 $\\Delta t$ 下的互协方差。使用样本互协方差定义，并为每个流使用其完整序列的样本均值 $\\bar{\\eta}_i$ 和 $\\bar{\\eta}_j$。\n\n5. 对于每个测试用例和每个指定的 $\\Delta t$，报告单个浮点数\n$$\nm(\\Delta t) = \\max_{i \\neq j} \\left| \\hat{C}_{\\eta_i,\\eta_j}(\\Delta t) \\right|.\n$$\n\n6. 如果 $P  2$（即没有不同的流对），则对于所有指定的 $\\Delta t$，定义 $m(\\Delta t) = 0.0$。\n\n7. 数值是无量纲的。角度以弧度为单位。不需要物理单位。\n\n测试套件：\n- 案例 A（正常情况，流不重叠）：$P = 4$, $N = 200000$, $M = 2^{40}$, $s = 1469598103934665603$, 延迟 $\\Delta t \\in \\{0,1,2\\}$。\n- 案例 B（边界条件，单个流）：$P = 1$, $N = 100000$, $M = 2^{20}$, $s = 1099511628211$, 延迟 $\\Delta t \\in \\{0,1,2\\}$。\n- 案例 C（边缘情况，故意使流重叠）：$P = 3$, $N = 150000$, $M = 10000$, $s = 16045690984833335023$, 延迟 $\\Delta t \\in \\{0, 10000, 20000\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个内部列表对应一个测试用例，并按该用例指定延迟的顺序包含浮点数 $[m(\\Delta t_1), m(\\Delta t_2), \\dots]$，不含空格。例如，一个有效的输出格式是 $[[a_1,a_2,a_3],[b_1,b_2,b_3],[c_1,c_2,c_3]]$。", "solution": "该问题要求设计并实现一个程序，用于为并行分子动力学模拟生成多个独立的随机数流。任务的核心是使用一个基于计数器的伪随机数生成器（PRNG）并结合跳跃（skip-ahead）策略来确保流的独立性，然后使用样本互协方差度量来量化任何残留的流间相关性。解决方案涉及几个不同的算法步骤：实现PRNG，将其输出转换为标准正态分布变量，生成并行流，最后计算其独立性的统计度量。\n\n**1. 基于计数器的PRNG和均匀分布变量生成**\n\n该方法的基础是一个确定性的、基于计数器的PRNG。问题指定了 SplitMix64 算法。其输出是一个64位整数状态的函数，该状态由一个64位种子 $s$ 和一个64位计数器 $c$ 的和构成。混合函数定义如下：\n$$\n\\begin{aligned}\nx = (c + s) \\pmod{2^{64}} \\\\\nx = \\left(x \\oplus (x \\gg 30)\\right) \\times C_1 \\pmod{2^{64}} \\\\\nx = \\left(x \\oplus (x \\gg 27)\\right) \\times C_2 \\pmod{2^{64}} \\\\\nx = x \\oplus (x \\gg 31)\n\\end{aligned}\n$$\n其中 $C_1 = 0x\\mathrm{BF58476D1CE4E5B9}$ 和 $C_2 = 0x\\mathrm{94D049BB133111EB}$ 是64位常数。这些操作包括按位右移（$\\gg$）、按位异或（$\\oplus$）和无符号64位乘法。为了在Python中模拟无符号64位算术（Python中的整数具有任意精度），在每个可能导致值超过此限制的步骤后，都使用与 $2^{64}-1$ 的掩码进行按位与操作。\n\n生成的 $64$ 位整数 $x$ 随后被转换为一个在 $[0,1)$ 区间内均匀分布的双精度浮点数。这是通过提取 $x$ 的最高有效 $53$ 位（标准双精度浮点数的尾数精度）并进行缩放来实现的。具体操作是 `(x >> 11) / 2**53`。这将整数范围 $[0, 2^{53}-1]$ 映射到浮点数范围 $[0, 1 - 2^{-53}]$。\n\n**2. 并行流生成：跳跃法与 Box-Muller 变换**\n\n为了生成 $P$ 个独立的流，我们采用跳跃策略。每个流 $i \\in \\{0, \\dots, P-1\\}$ 被分配一个唯一的、不重叠的PRNG计数器序列块。这通过定义一个基础计数器偏移量 $C_i = i \\times M$ 来实现，其中 $M$ 是一个大的整数步长。对于给定的流 $i$ 和时间步 $t$，随机变量使用从 $C_i$ 开始的计数器生成。\n\n均匀分布变量通过 Box-Muller 变换被转换为标准正态分布变量 $\\eta_i(t)$。此方法取一对独立的均匀变量 $u_1, u_2 \\in (0,1)$，并生成一对独立标准正态变量 $z_0, z_1$：\n$$\nr = \\sqrt{-2 \\ln(u_1)}, \\quad \\theta = 2\\pi u_2, \\quad z_0 = r \\cos(\\theta), \\quad z_1 = r \\sin(\\theta)\n$$\n一个关键的实现细节是，如果 $u_1=0$，则 $\\ln(u_1)$ 未定义。尽管生成 $u_1=0$ 的概率非常低，但一个稳健的实现必须处理这种情况。如果 $u_1=0$，它将被替换为一个很小的正值，例如 $2^{-53}$，这是此生成器能产生的最小非零值。\n\n要为流 $i$ 生成完整的序列 $\\{\\eta_i(t)\\}_{t=0}^{N-1}$，我们从 $C_i$ 开始，使用连续的计数器重复生成成对的均匀变量。第 $k$ 对正态变量 $(\\eta_i(2k), \\eta_i(2k+1))$ 是从由计数器 $C_i+2k$ 和 $C_i+2k+1$ 导出的均匀变量生成的。此过程重复 $\\lceil N/2 \\rceil$ 次，以填充包含 $N$ 个正态变量的数组。如果 $N$ 是奇数，最后一个生成的正态变量将被丢弃。\n\n**3. 流间相关性量化**\n\n所生成流的独立性通过计算样本互协方差来评估。对于两个流 $\\eta_i(t)$ 和 $\\eta_j(t)$，在时间延迟 $\\Delta t$ 时的互协方差估计为：\n$$\n\\hat{C}_{\\eta_i,\\eta_j}(\\Delta t) = \\frac{1}{N-\\Delta t} \\sum_{t=0}^{N-\\Delta t - 1} \\big(\\eta_i(t) - \\bar{\\eta}_i\\big)\\big(\\eta_j(t+\\Delta t)-\\bar{\\eta}_j\\big)\n$$\n其中 $\\bar{\\eta}_i$ 和 $\\bar{\\eta}_j$ 是整个序列的样本均值。对于真正独立的流，对于所有 $i \\neq j$ 和所有延迟 $\\Delta t$，该值应接近于零。此计算对所有 $i \\neq j$ 的不同有序流对 $(i,j)$ 执行。\n\n每个延迟 $\\Delta t$ 的最终报告指标是在所有这些流对中找到的最大绝对互协方差：\n$$\nm(\\Delta t) = \\max_{i \\neq j} \\left| \\hat{C}_{\\eta_i,\\eta_j}(\\Delta t) \\right|\n$$\n该指标提供了一个单一的数字，总结了在给定延迟下的最坏情况伪相关。如果 $P  2$，则不存在不同的流对，此时 $m(\\Delta t)$ 定义为 $0.0$。\n\n**4. 测试用例分析**\n\n测试套件旨在验证实现并展示其原理。\n- **案例 A ($M \\gg N$)**：步长 $M$ 非常大，确保了不同流的计数器范围被广泛地分离开。这代表了跳跃法的正确用法，我们预计由此产生的互协方verse会非常小，处于统计噪声的量级（$1/\\sqrt{N}$）。\n- **案例 B ($P=1$)**：这是一个边界情况。只有一个流时，流间相关性的概念不适用，结果被正确地定义为 $0.0$。\n- **案例 C ($M  N$)**：步长小于流的长度，导致计数器范围重叠。这是一种故意的错误配置。具体来说，流 $j$ 的均匀序列是流 $i$ 序列的时移版本，即 $u_j(t) = u_i(t + (j-i)M)$。因此，正态变量序列也是平移的，$\\eta_j(t) = \\eta_i(t + (j-i)M)$。当延迟 $\\Delta t$ 补偿了该位移时，即当 $\\Delta t = (j-i)M$ 时，这种引入的依赖性将导致一个很大的互协方差，接近于 $1$。对于延迟 $\\Delta t = 10000 = M$ 和 $\\Delta t = 20000 = 2M$，我们预计会观察到约 $1.0$ 的相关性峰值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\n# --- PRNG Implementation ---\n\n# 64-bit mask for unsigned integer arithmetic\nMASK64 = (1  64) - 1\n\n# Constants for SplitMix64\nC1 = 0xBF58476D1CE4E5B9\nC2 = 0x94D049BB133111EB\n\ndef splitmix64_func(state):\n    \"\"\"The mixing function of the SplitMix64 PRNG.\"\"\"\n    x = state\n    x = (x ^ (x >> 30)) * C1\n    x = MASK64\n    x = (x ^ (x  27)) * C2\n    x = MASK64\n    x = x ^ (x  31)\n    return x  MASK64\n\ndef to_uniform_float(x):\n    \"\"\"Converts a 64-bit integer to a float in [0,1) using the upper 53 bits.\"\"\"\n    return (x  11) * (1.0 / (1  53))\n\n# --- Stream Generation ---\n\ndef generate_stream(stream_idx, N, M, seed):\n    \"\"\"Generates a stream of N standard normal variates.\"\"\"\n    normals = np.empty(N, dtype=np.float64)\n    base_counter = stream_idx * M\n    \n    num_pairs = (N + 1) // 2\n    \n    for i in range(num_pairs):\n        # Generate two uniform variates from consecutive counters\n        counter1 = base_counter + 2 * i\n        state1 = (counter1 + seed)  MASK64\n        u_raw1 = splitmix64_func(state1)\n        u1 = to_uniform_float(u_raw1)\n        \n        counter2 = base_counter + 2 * i + 1\n        state2 = (counter2 + seed)  MASK64\n        u_raw2 = splitmix64_func(state2)\n        u2 = to_uniform_float(u_raw2)\n        \n        # Box-Muller transform\n        # Handle u1 == 0.0 to avoid log(0)\n        if u1 == 0.0:\n            # Use the smallest representable positive value from this generator\n            u1 = 1.0 / (1  53)\n            \n        r = math.sqrt(-2.0 * math.log(u1))\n        theta = 2.0 * math.pi * u2\n        \n        z0 = r * math.cos(theta)\n        z1 = r * math.sin(theta)\n        \n        # Store the generated pair, handling odd N\n        if 2 * i  N:\n            normals[2 * i] = z0\n        if 2 * i + 1  N:\n            normals[2 * i + 1] = z1\n            \n    return normals\n\n# --- Correlation Calculation ---\n\ndef calculate_cross_covariance(s1, s2, lag):\n    \"\"\"Computes the sample cross-covariance between two streams at a given lag.\"\"\"\n    N = len(s1)\n    \n    if lag = N:\n        return 0.0\n\n    num_terms = N - lag\n    if num_terms = 0:\n        return 0.0\n        \n    s1_mean = np.mean(s1)\n    s2_mean = np.mean(s2)\n    \n    s1_demeaned = s1 - s1_mean\n    s2_demeaned = s2 - s2_mean\n    \n    # Sum of products: (s1[t]-mean1) * (s2[t+lag]-mean2) for t from 0 to N-lag-1\n    covariance_sum = np.dot(s1_demeaned[:num_terms], s2_demeaned[lag:N])\n    \n    return covariance_sum / num_terms\n\n# --- Main Solver ---\n\ndef solve():\n    \"\"\"Main function to run test cases and produce the final output.\"\"\"\n    test_cases = [\n        # Case A: happy path, non-overlapping streams\n        {'P': 4, 'N': 200000, 'M': 2**40, 's': 1469598103934665603, 'lags': [0, 1, 2]},\n        # Case B: boundary condition, single stream\n        {'P': 1, 'N': 100000, 'M': 2**20, 's': 1099511628211, 'lags': [0, 1, 2]},\n        # Case C: edge case, deliberately overlapping streams\n        {'P': 3, 'N': 150000, 'M': 10000, 's': 16045690984833335023, 'lags': [0, 10000, 20000]}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        P, N, M, s, lags = case['P'], case['N'], case['M'], case['s'], case['lags']\n        \n        case_results = []\n        \n        # Per requirement 6, if P  2, result is 0.0\n        if P  2:\n            case_results = [0.0] * len(lags)\n            all_results.append(case_results)\n            continue\n            \n        # Generate all P streams\n        streams = [generate_stream(i, N, M, s) for i in range(P)]\n        \n        for lag in lags:\n            max_abs_cov = 0.0\n            \n            # Iterate over all distinct ordered pairs (i, j)\n            for i in range(P):\n                for j in range(P):\n                    if i == j:\n                        continue\n                    \n                    cov = calculate_cross_covariance(streams[i], streams[j], lag)\n                    max_abs_cov = max(max_abs_cov, abs(cov))\n            \n            case_results.append(max_abs_cov)\n            \n        all_results.append(case_results)\n\n    # Format the final output string as specified\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n\n```", "id": "3484374"}]}