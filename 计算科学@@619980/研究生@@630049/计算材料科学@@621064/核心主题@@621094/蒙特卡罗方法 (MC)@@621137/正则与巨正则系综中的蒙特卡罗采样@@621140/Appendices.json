{"hands_on_practices": [{"introduction": "要真正掌握不同统计系综之间的深刻联系与区别，从一个简单的、可以精确求解的模型入手至关重要。本练习使用一个仅包含两个格点的格子气模型，通过穷举所有可能的状态，让您亲手验证正则系综和巨正则系综在处理粒子数上的根本差异。通过这个过程，您将清晰地看到巨正则系综中的粒子数涨落如何与系统的热力学响应函数（如压缩性）直接关联，从而深刻理解涨落-响应定理的物理内涵。[@problem_id:3467666]", "problem": "考虑一个一维格点上的格点气体，该格点由 $2$ 个标记为 $i \\in \\{1,2\\}$ 的位点组成，具有硬核占据变量 $n_i \\in \\{0,1\\}$。相互作用能为 $E(n_1,n_2) = -\\epsilon\\, n_1 n_2$，其中 $\\epsilon  0$，除了与粒子数相关的化学功外，没有其他外场。系统处于温度 $T$，逆温度为 $\\beta \\equiv 1/(k_\\mathrm{B} T)$，其中 $k_\\mathrm{B}$ 是玻尔兹曼常数。\n\n你将比较这个有限系统的正则系综和巨正则系综，并将粒子数涨落与计算材料科学采样相关的响应函数联系起来。\n\n从基本的统计力学定义和 Metropolis-Hastings (MH) 动力学的细致平衡出发，完成以下任务：\n\n1) 粒子数 $N$ 固定的正则系综：对于 $N=1$，通过枚举微观态及其能量，使用 $Z_{N}(T) = \\sum_{\\{\\mathbf{n}: \\sum_i n_i = N\\}} \\exp(-\\beta E)$ 构建正则配分函数 $Z_{N=1}(T)$。解释为什么在粒子数 $N$ 固定的正则系综中粒子数涨落会消失，并讨论当 $\\mu$ 不是正则系综的控制变量时，这对定义为 $\\chi_N \\equiv \\left(\\partial \\langle N \\rangle / \\partial \\mu\\right)_{T,V}$ 的粒子数感受率有何影响。\n\n2) 巨正则系综和 Metropolis-Hastings 接受概率：在巨正则系综中，组态的权重由 $\\exp[-\\beta (E - \\mu N)]$ 给出，其中 $\\mu$ 是化学势， $N = n_1 + n_2$。考虑一个巨正则蒙特卡洛 (GCMC) 方案，该方案均匀随机地选择一个位点并提议翻转其占据数 $n_i \\to 1 - n_i$。从细致平衡出发，为这些对称提议推导出 MH 接受概率 $p_{\\text{acc}} = \\min\\{1, \\exp[-\\beta (\\Delta E - \\mu \\Delta N)]\\}$，其中 $\\Delta E$ 和 $\\Delta N$ 分别是能量和粒子数的变化量。\n\n3) 通过枚举进行精确的巨正则计算：枚举 $4$ 个微观态以构建巨配分函数 $\\Xi(\\mu,T) = \\sum_{\\{n_1,n_2\\}} \\exp[-\\beta (E - \\mu N)]$。从第一性原理出发，计算巨正则系综平均值 $\\langle N \\rangle$ 和 $\\langle N^2 \\rangle$，并证明涨落-响应关系成立，即 $\\operatorname{Var}(N) = \\langle N^2 \\rangle - \\langle N \\rangle^2 = k_\\mathrm{B} T \\left(\\partial \\langle N \\rangle / \\partial \\mu\\right)_{T,V}$。\n\n4) 有限尺寸的压缩率和感受率：将有限尺寸的粒子数感受率定义为 $\\chi_N \\equiv \\left(\\partial \\langle N \\rangle / \\partial \\mu\\right)_{T,V}$，并将单位体积 $V$ 的格点气体等温压缩率定义为 $\\kappa_T^{(\\text{lat})} \\equiv \\beta\\, \\operatorname{Var}(N)/V$。解释这些量如何将粒子数涨落与有限格点巨正则采样中的可测量响应联系起来。\n\n最终答案请提供该 $2$ 位点格点气体的巨正则粒子数方差 $\\operatorname{Var}(N)$ 作为 $\\beta$、$\\mu$ 和 $\\epsilon$ 的函数的精确闭合形式解析表达式。不需要进行数值计算，也不需要四舍五入。最终答案必须是无单位的单一闭合形式解析表达式。", "solution": "问题陈述经过审查并被确定为有效。它在科学上基于统计力学原理，提法恰当，定义清晰完整，并且表述客观。该问题是统计物理学中一个标准但简单的练习，利用所提供的信息完全可以解决。\n\n1) 粒子数 $N=1$ 固定的正则系综：\n\n在正则系综中，粒子数 $N$、体积（或位点数）$V$ 和温度 $T$ 是固定的。对于给定的 $2$ 位点格点， $V=2$。问题指定了固定的粒子数 $N=1$。位点 $i$ 的占据数为 $n_i \\in \\{0,1\\}$，约束条件是 $\\sum_{i=1}^2 n_i = N = 1$。因此，可能的微观态 $(n_1, n_2)$ 是 $(1,0)$ 和 $(0,1)$。\n\n每个微观态的相互作用能使用 $E(n_1,n_2) = -\\epsilon n_1 n_2$ 计算：\n- 对于状态 $(1,0)$，能量为 $E_{1,0} = -\\epsilon (1)(0) = 0$。\n- 对于状态 $(0,1)$，能量为 $E_{0,1} = -\\epsilon (0)(1) = 0$。\n\n对于固定粒子数 $N$ 的正则配分函数 $Z_N(T)$ 是对所有允许的微观态的玻尔兹曼因子 $\\exp(-\\beta E)$ 求和，其中 $\\beta = 1/(k_\\mathrm{B} T)$。对于 $N=1$：\n$$Z_{N=1}(T) = \\sum_{\\{\\mathbf{n}: \\sum_i n_i = 1\\}} \\exp(-\\beta E) = \\exp(-\\beta E_{1,0}) + \\exp(-\\beta E_{0,1}) = \\exp(-\\beta \\cdot 0) + \\exp(-\\beta \\cdot 0) = 1 + 1 = 2$$\n在正则系综中，粒子数 $N$ 根据定义是固定的。它是系综的一个参数，而不是一个涨落量。因此，粒子数的期望值就是 $\\langle N \\rangle = N=1$，其平方的期望值是 $\\langle N^2 \\rangle = N^2=1^2=1$。用来衡量粒子数涨落的粒子数方差因此恒等于零：\n$$\\operatorname{Var}(N) = \\langle N^2 \\rangle - \\langle N \\rangle^2 = 1 - 1^2 = 0$$\n粒子数感受率定义为 $\\chi_N \\equiv \\left(\\partial \\langle N \\rangle / \\partial \\mu\\right)_{T,V}$。在正则系综中，化学势 $\\mu$ 不是控制系统状态的独立热力学变量；相反，它是由固定的 $N, V, T$ 决定的。由于 $\\langle N \\rangle = N$ 是一个常数，它对任何变量（包括派生的化学势）的导数都为零。因此，粒子数感受率作为对外部 $\\mu$ 的响应这一概念在正则系综中不适用，该量形式上为零。\n\n2) 巨正则系综和 Metropolis-Hastings 接受概率：\n\n在巨正则系综 (GCE) 中，一个微观态 $\\nu = \\{n_1, n_2, \\dots\\}$ 的概率 $P(\\nu)$ 由下式给出：\n$$P(\\nu) = \\frac{1}{\\Xi} \\exp[-\\beta (E_\\nu - \\mu N_\\nu)]$$\n其中 $\\Xi$ 是巨配分函数， $E_\\nu$ 是能量， $N_\\nu$ 是粒子数， $\\mu$ 是化学势。\n\nMetropolis-Hastings 算法满足细致平衡条件，这确保了马尔可夫链收敛到所需的目标平衡分布：\n$$P(\\nu) T(\\nu \\to \\nu') = P(\\nu') T(\\nu' \\to \\nu)$$\n此处， $T(\\nu \\to \\nu')$ 是从状态 $\\nu$ 到状态 $\\nu'$ 的转移概率。它由提议概率 $g(\\nu \\to \\nu')$ 和接受概率 $p_{\\text{acc}}(\\nu \\to \\nu')$ 组成：$T(\\nu \\to \\nu') = g(\\nu \\to \\nu') p_{\\text{acc}}(\\nu \\to \\nu')$。\n\n提议的移动是，以 $1/2$ 的等概率选择两个位点之一 $i \\in \\{1,2\\}$ 并翻转其占据数 $n_i \\to 1-n_i$。这个提议是对称的：从 $\\nu$ 到 $\\nu'$ 提议移动的概率（例如，将位点 $i$ 从 $0$ 翻转到 $1$）与从 $\\nu'$ 到 $\\nu$ 提议逆向移动的概率（将位点 $i$ 从 $1$ 翻转到 $0$）相同。因此， $g(\\nu \\to \\nu') = g(\\nu' \\to \\nu)$。\n\n将此代入细致平衡方程，得到：\n$$P(\\nu) g(\\nu \\to \\nu') p_{\\text{acc}}(\\nu \\to \\nu') = P(\\nu') g(\\nu \\to \\nu') p_{\\text{acc}}(\\nu' \\to \\nu)$$\n$$\\frac{p_{\\text{acc}}(\\nu \\to \\nu')}{p_{\\text{acc}}(\\nu' \\to \\nu)} = \\frac{P(\\nu')}{P(\\nu)} = \\frac{\\exp[-\\beta (E' - \\mu N')]}{\\exp[-\\beta (E - \\mu N)]} = \\exp[-\\beta ((E'-E) - \\mu(N'-N))]$$\n定义 $\\Delta E = E' - E$ 和 $\\Delta N = N' - N$，我们有：\n$$\\frac{p_{\\text{acc}}(\\nu \\to \\nu')}{p_{\\text{acc}}(\\nu' \\to \\nu)} = \\exp[-\\beta (\\Delta E - \\mu \\Delta N)]$$\nMetropolis-Hastings 对接受概率的选择是 $p_{\\text{acc}}(\\nu \\to \\nu') = \\min\\{1, \\frac{P(\\nu')}{P(\\nu)}\\}$（对于对称提议）。因此，GCMC 移动的接受概率为：\n$$p_{\\text{acc}} = \\min\\{1, \\exp[-\\beta (\\Delta E - \\mu \\Delta N)]\\}$$\n\n3) 通过枚举进行精确的巨正则计算：\n\n我们枚举系统的 $2^2=4$ 个可能的微观态 $(n_1, n_2)$：\n- 状态 1： $(0,0)$。$N=0$，$E=0$。巨正则权重为 $\\exp[-\\beta(0-\\mu \\cdot 0)] = 1$。\n- 状态 2： $(1,0)$。$N=1$，$E=0$。权重为 $\\exp[-\\beta(0-\\mu \\cdot 1)] = \\exp(\\beta\\mu)$。\n- 状态 3： $(0,1)$。$N=1$，$E=0$。权重为 $\\exp[-\\beta(0-\\mu \\cdot 1)] = \\exp(\\beta\\mu)$。\n- 状态 4： $(1,1)$。$N=2$，$E=-\\epsilon$。权重为 $\\exp[-\\beta(-\\epsilon-\\mu \\cdot 2)] = \\exp(\\beta(\\epsilon+2\\mu))$。\n\n巨配分函数 $\\Xi(\\mu, T)$ 是这些权重的总和：\n$$\\Xi = 1 + 2\\exp(\\beta\\mu) + \\exp(\\beta(\\epsilon+2\\mu))$$\n平均粒子数 $\\langle N \\rangle$ 由 $\\langle N \\rangle = \\frac{1}{\\beta} \\frac{\\partial \\ln \\Xi}{\\partial \\mu}$ 给出：\n$$\\frac{\\partial \\Xi}{\\partial \\mu} = 2\\beta\\exp(\\beta\\mu) + 2\\beta\\exp(\\beta(\\epsilon+2\\mu))$$\n$$\\langle N \\rangle = \\frac{1}{\\beta \\Xi} \\frac{\\partial \\Xi}{\\partial \\mu} = \\frac{2\\exp(\\beta\\mu) + 2\\exp(\\beta(\\epsilon+2\\mu))}{1 + 2\\exp(\\beta\\mu) + \\exp(\\beta(\\epsilon+2\\mu))}$$\n粒子数平方的平均值 $\\langle N^2 \\rangle$ 由 $\\langle N^2 \\rangle = \\frac{1}{\\Xi} \\sum_i N_i^2 \\frac{\\exp[-\\beta (E_i - \\mu N_i)]}{1}$ 或通过导数 $\\langle N^2 \\rangle = \\frac{1}{\\beta^2 \\Xi} \\frac{\\partial^2 \\Xi}{\\partial \\mu^2} + \\langle N \\rangle^2$ 计算。更直接地，通过对 $\\Xi$ 求二阶导数：\n$$\\frac{\\partial^2 \\Xi}{\\partial \\mu^2} = 2\\beta^2\\exp(\\beta\\mu) + 4\\beta^2\\exp(\\beta(\\epsilon+2\\mu))$$\n$$\\langle N^2 \\rangle_{\\text{direct}} = \\frac{1}{\\Xi} \\sum N^2 \\text{weight} = \\frac{0^2 \\cdot 1 + 1^2 \\cdot 2\\exp(\\beta\\mu) + 2^2 \\cdot \\exp(\\beta(\\epsilon+2\\mu))}{\\Xi} = \\frac{2\\exp(\\beta\\mu) + 4\\exp(\\beta(\\epsilon+2\\mu))}{1 + 2\\exp(\\beta\\mu) + \\exp(\\beta(\\epsilon+2\\mu))}$$\n为了验证涨落-响应关系，我们计算恒等式 $\\operatorname{Var}(N) = k_\\mathrm{B} T (\\partial \\langle N \\rangle / \\partial \\mu)_{T,V}$ 的两边。\n左边是方差：$\\operatorname{Var}(N) = \\langle N^2 \\rangle - \\langle N \\rangle^2$。\n右边是 $k_\\mathrm{B} T \\frac{\\partial \\langle N \\rangle}{\\partial \\mu} = \\frac{1}{\\beta} \\frac{\\partial \\langle N \\rangle}{\\partial \\mu}$。使用 $\\langle N \\rangle = \\frac{1}{\\beta}\\frac{\\partial \\ln\\Xi}{\\partial\\mu}$，我们有：\n$$\\frac{1}{\\beta} \\frac{\\partial \\langle N \\rangle}{\\partial \\mu} = \\frac{1}{\\beta^2} \\frac{\\partial^2 \\ln\\Xi}{\\partial\\mu^2} = \\frac{1}{\\beta^2} \\frac{\\partial}{\\partial\\mu} \\left( \\frac{1}{\\Xi}\\frac{\\partial\\Xi}{\\partial\\mu} \\right) = \\frac{1}{\\beta^2} \\left( \\frac{1}{\\Xi}\\frac{\\partial^2\\Xi}{\\partial\\mu^2} - \\frac{1}{\\Xi^2}\\left(\\frac{\\partial\\Xi}{\\partial\\mu}\\right)^2 \\right)$$\n$$= \\left(\\frac{1}{\\beta^2\\Xi}\\frac{\\partial^2\\Xi}{\\partial\\mu^2} + \\frac{1}{\\Xi}\\left(\\frac{1}{\\beta}\\frac{\\partial\\Xi}{\\partial\\mu}\\right)^2\\right) - \\left(\\frac{1}{\\beta\\Xi}\\frac{\\partial\\Xi}{\\partial\\mu}\\right)^2$$\n这恰好是 $\\langle N^2 \\rangle - \\langle N \\rangle^2$ 的定义。因此，涨落-响应关系对该系统被证明成立。\n\n4) 有限尺寸的压缩率和感受率：\n\n粒子数感受率 $\\chi_N$ 和格点气体压缩率 $\\kappa_T^{(\\text{lat})}$ 定义为：\n$$\\chi_N \\equiv \\left(\\frac{\\partial \\langle N \\rangle}{\\partial \\mu}\\right)_{T,V} \\quad \\text{和} \\quad \\kappa_T^{(\\text{lat})} \\equiv \\frac{\\beta}{V} \\operatorname{Var}(N)$$\n从第 3 部分推导出的涨落-响应关系，我们有 $\\operatorname{Var}(N) = k_\\mathrm{B} T \\chi_N = \\frac{1}{\\beta} \\chi_N$。\n这直接意味着感受率和方差之间的联系：$\\chi_N = \\beta \\operatorname{Var}(N)$。\n将此代入压缩率的定义，得到：\n$$\\kappa_T^{(\\text{lat})} = \\frac{\\beta}{V} \\left( \\frac{1}{\\beta} \\chi_N \\right) = \\frac{\\chi_N}{V}$$\n这些关系表明，通过 GCMC 模拟中测量的粒子数涨落 $\\operatorname{Var}(N)$ 并非随机噪声，而是包含深刻的物理信息。方差与粒子数感受率（一种热力学响应函数）成正比。而粒子数感受率又与等温压缩率相关。因此，通过在固定的 $(\\mu, V, T)$ 下的单次巨正则模拟中观察和量化粒子数的自然涨落，人们可以计算系统的宏观响应性质，而无需在不同的 $\\mu$ 值下进行多次模拟并数值近似求导。\n\n最后，我们推导粒子数方差 $\\operatorname{Var}(N) = \\langle N^2 \\rangle - \\langle N \\rangle^2$ 的显式解析表达式。\n设 $x = \\exp(\\beta\\mu)$ 和 $y = \\exp(\\beta\\epsilon)$。配分函数是 $\\Xi = 1 + 2x + yx^2$。\n$$\\langle N \\rangle = \\frac{2x + 2yx^2}{\\Xi} \\quad \\text{和} \\quad \\langle N^2 \\rangle = \\frac{2x + 4yx^2}{\\Xi}$$\n$$\\operatorname{Var}(N) = \\frac{2x + 4yx^2}{\\Xi} - \\left(\\frac{2x + 2yx^2}{\\Xi}\\right)^2 = \\frac{(2x + 4yx^2)\\Xi - (2x + 2yx^2)^2}{\\Xi^2}$$\n分子是：\n$$(2x + 4yx^2)(1+2x+yx^2) - (4x^2 + 8yx^3 + 4y^2x^4)$$\n$$= (2x + 4x^2 + 2yx^3 + 4yx^2 + 8yx^3 + 4y^2x^4) - (4x^2 + 8yx^3 + 4y^2x^4)$$\n$$= 2x + (4x^2 - 4x^2) + 4yx^2 + (2yx^3 + 8yx^3 - 8yx^3) + (4y^2x^4 - 4y^2x^4)$$\n$$= 2x + 4yx^2 + 2yx^3$$\n代回原始变量：\n$$\\operatorname{Var}(N) = \\frac{2\\exp(\\beta\\mu) + 4\\exp(\\beta\\epsilon)\\exp(2\\beta\\mu) + 2\\exp(\\beta\\epsilon)\\exp(3\\beta\\mu)}{(1 + 2\\exp(\\beta\\mu) + \\exp(\\beta\\epsilon)\\exp(2\\beta\\mu))^2}$$\n这可以写成：\n$$\\operatorname{Var}(N) = \\frac{2\\exp(\\beta\\mu) + 4\\exp(\\beta\\epsilon + 2\\beta\\mu) + 2\\exp(\\beta\\epsilon + 3\\beta\\mu)}{\\left(1 + 2\\exp(\\beta\\mu) + \\exp(\\beta\\epsilon + 2\\beta\\mu)\\right)^2}$$\n这是粒子数方差的最终表达式。", "answer": "$$\\boxed{\\frac{2\\exp(\\beta\\mu) + 4\\exp(\\beta\\epsilon + 2\\beta\\mu) + 2\\exp(\\beta\\epsilon + 3\\beta\\mu)}{\\left(1 + 2\\exp(\\beta\\mu) + \\exp(\\beta\\epsilon + 2\\beta\\mu)\\right)^2}}$$", "id": "3467666"}, {"introduction": "巨正则系综蒙特卡洛（GCMC）模拟的核心优势在于它允许系统与一个假想的粒子浴交换粒子，从而使粒子数$N$动态涨落。实现这一点的关键在于两种基本操作：粒子插入和粒子删除。本练习是一个基础但至关重要的理论推导，旨在引导您从细致平衡原理这一蒙特卡洛方法的基石出发，严格推导出粒子插入和删除操作的Metropolis接受率。掌握此推导过程，是理解和开发GCMC算法的必备技能。[@problem_id:3467672]", "problem": "考虑一种由无差别的点粒子组成的均匀三维流体，它被限制在固定体积 $V$ 内，处于绝对温度 $T$ 和化学势 $\\mu$ 的条件下。该系统在巨正则系综下使用马尔可夫链蒙特卡洛 (MCMC; Markov chain Monte Carlo) 方法进行模拟，其中粒子数 $N$ 可以发生涨落。一个具有 $N$ 个粒子和坐标 $\\mathbf{r}^{N} = (\\mathbf{r}_{1}, \\dots, \\mathbf{r}_{N})$ 的微观态的位形能为 $U_{N}(\\mathbf{r}^{N})$，其值为有限，并且平滑地依赖于粒子间的距离。在包含带标记的粒子坐标和粒子数的增广态空间上，目标概率密度正比于巨正则权重\n$$\n\\pi(N, \\mathbf{r}^{N}) \\propto z^{N} \\exp(-\\beta U_{N}(\\mathbf{r}^{N})),\n$$\n其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 为玻尔兹曼常数，$z$ 是与化学势 $\\mu$ 和热波长相关的活度，其选择使得 $\\pi$ 在带标记坐标的态空间上被正确归一化。MCMC 转移核采用两种以相等频率选择的互补移动类型：粒子插入和粒子删除。对于从状态 $(N, \\mathbf{r}^{N})$ 到 $(N+1, \\mathbf{r}^{N+1})$ 的粒子插入，在体积 $V$ 内均匀地提出了一个试验位置 $\\mathbf{r}_{\\star}$。对于从状态 $(N, \\mathbf{r}^{N})$ 到 $(N-1, \\mathbf{r}^{N-1})$ 的粒子删除，从现有的 $N$ 个粒子中均匀随机地选择一个移除。设插入的 Metropolis 接受概率记为 $\\alpha_{\\text{ins}}$，删除的记为 $\\alpha_{\\text{del}}$，能量变化定义为 $\\Delta E = U_{\\text{new}} - U_{\\text{old}}$，其中能量变化是针对所考虑的正向移动。仅使用巨正则系综的原理、上述 $\\pi(N, \\mathbf{r}^{N})$ 的定义以及 MCMC 中转移概率的细致平衡条件，推导 $\\alpha_{\\text{ins}}$ 和 $\\alpha_{\\text{del}}$ 关于 $z$、$V$、$N$、$\\beta$ 和 $\\Delta E$ 的闭合形式表达式。将最终答案表示为解析表达式，并且不要引入除已说明参数之外的任何新参数。不需要进行数值计算，也不需要四舍五入。", "solution": "所述问题在科学上是合理的、良定的，并包含了进行严格推导所需的所有信息。它描述了一个标准的巨正则蒙特卡洛 (GCMC) 模拟过程，因此是计算统计力学中的一个有效问题。\n\n控制马尔可夫链蒙特卡洛 (MCMC) 模拟中接受概率的核心原理是细致平衡条件。该条件确保马尔可夫链在平衡时，能够根据期望的目标概率分布（在本例中为巨正则系综分布 $\\pi(N, \\mathbf{r}^{N})$）对状态进行抽样。对于任意两个状态，比如状态 $A$ 和状态 $B$，细致平衡条件表明从 $A$ 到 $B$ 的转移速率必须等于从 $B$ 到 $A$ 的转移速率：\n$$\n\\pi(A) P(A \\to B) = \\pi(B) P(B \\to A)\n$$\n其中 $\\pi(X)$ 是状态 $X$ 的平衡概率（或概率密度），$P(X \\to Y)$ 是从状态 $X$ 移动到状态 $Y$ 的转移概率。转移概率是建议概率 $g(X \\to Y)$ 和接受概率 $\\alpha(X \\to Y)$ 的乘积。因此，该条件变为：\n$$\n\\pi(A) g(A \\to B) \\alpha(A \\to B) = \\pi(B) g(B \\to A) \\alpha(B \\to A)\n$$\nMetropolis-Hastings 算法为接受概率提供了一个有效的选择：\n$$\n\\alpha(A \\to B) = \\min \\left(1, \\frac{\\pi(B) g(B \\to A)}{\\pi(A) g(A \\to B)}\\right)\n$$\n我们将应用此形式体系来推导粒子插入（$\\alpha_{\\text{ins}}$）和粒子删除（$\\alpha_{\\text{del}}$）的接受概率。\n\n首先，我们推导粒子插入的接受概率 $\\alpha_{\\text{ins}}$。\n正向移动是一次插入尝试。初始状态 $A$ 有 $N$ 个粒子，位形为 $\\mathbf{r}^{N}$。其位形能为 $U_{\\text{old}} = U_{N}(\\mathbf{r}^{N})$。一个新粒子被建议放置在从体积 $V$ 中均匀选择的随机位置 $\\mathbf{r}_{\\star}$ 处。新状态 $B$ 有 $N+1$ 个粒子，位形为 $\\mathbf{r}^{N+1} = (\\mathbf{r}^{N}, \\mathbf{r}_{\\star})$，能量为 $U_{\\text{new}} = U_{N+1}(\\mathbf{r}^{N+1})$。能量变化为 $\\Delta E = U_{\\text{new}} - U_{\\text{old}}$。\n\n平衡概率密度由 $\\pi(N, \\mathbf{r}^{N}) \\propto z^{N} \\exp(-\\beta U_{N}(\\mathbf{r}^{N}))$ 给出。我们来为 Metropolis-Hastings 公式建立比率，需要特别注意建议概率和态空间的维度。对于带标记的粒子，态空间是增广的，即 $\\cup_{N=0}^{\\infty} V^{N}$，因此从 $N$ 个粒子到 $N+1$ 个粒子的转变是在不同维度的空间之间移动。\n\n让我们考虑在状态 $A$ 附近的无穷小体积元 $d\\mathbf{r}^{N}$ 与状态 $B$ 附近的无穷小体积元 $d\\mathbf{r}^{N+1}$ 之间的转变。\n从状态 $A$ 建议新状态 $B$ 的概率涉及到选择一个粒子位置。由于新位置 $\\mathbf{r}_{\\star}$ 是从体积 $V$ 中均匀选择的，因此建议概率*密度*为 $g(A \\to B) = 1/V$。建议移动到特定无穷小体积元 $d\\mathbf{r}_{\\star}$ 内的概率是 $(1/V)d\\mathbf{r}_{\\star}$。\n逆向移动是从状态 $B$ 删除新添加的粒子以返回状态 $A$。状态 $B$ 有 $N+1$ 个粒子。均匀随机地选择一个粒子进行删除。选择位于 $\\mathbf{r}_{\\star}$ 的特定粒子的概率是 $g(B \\to A) = 1/(N+1)$。\n\n细致平衡必须对相应无穷小相空间体积元之间的转变成立：\n$$\n[\\pi(A) d\\mathbf{r}^{N}] \\cdot [g(A \\to B) d\\mathbf{r}_{\\star}] \\cdot \\alpha_{\\text{ins}} = [\\pi(B) d\\mathbf{r}^{N+1}] \\cdot [g(B \\to A)] \\cdot \\alpha_{\\text{del, reverse}}\n$$\n代入问题中对 $\\pi$ 的定义和我们找到的建议概率：\n$$\n[C z^{N} \\exp(-\\beta U_{N}) d\\mathbf{r}^{N}] \\cdot [\\frac{1}{V} d\\mathbf{r}_{\\star}] \\cdot \\alpha_{\\text{ins}} = [C z^{N+1} \\exp(-\\beta U_{N+1}) d\\mathbf{r}^{N+1}] \\cdot [\\frac{1}{N+1}] \\cdot \\alpha_{\\text{del, reverse}}\n$$\n其中 $C$ 是一个归一化常数。由于 $d\\mathbf{r}^{N+1} = d\\mathbf{r}^{N}d\\mathbf{r}_{\\star}$，微分体积元和常数 $C$ 从两侧消去，得到：\n$$\nz^{N} \\exp(-\\beta U_{N}) \\frac{1}{V} \\alpha_{\\text{ins}} = z^{N+1} \\exp(-\\beta U_{N+1}) \\frac{1}{N+1} \\alpha_{\\text{del, reverse}}\n$$\nMetropolis-Hastings 接受概率 $\\alpha_{\\text{ins}}$ 所需的比率为：\n$$\n\\text{Ratio}_{\\text{ins}} = \\frac{\\pi(B) g(B \\to A)}{\\pi(A) g(A \\to B)} = \\frac{z^{N+1} \\exp(-\\beta U_{N+1})}{z^{N} \\exp(-\\beta U_{N})} \\cdot \\frac{1/(N+1)}{1/V}\n$$\n$$\n\\text{Ratio}_{\\text{ins}} = z \\exp(-\\beta(U_{N+1} - U_{N})) \\frac{V}{N+1} = \\frac{zV}{N+1} \\exp(-\\beta \\Delta E)\n$$\n因此，插入的接受概率为：\n$$\n\\alpha_{\\text{ins}} = \\min\\left(1, \\frac{zV}{N+1} \\exp(-\\beta \\Delta E)\\right)\n$$\n此处，$N$ 是插入前的粒子数，且 $\\Delta E = U_{N+1} - U_N$。\n\n接下来，我们推导粒子删除的接受概率 $\\alpha_{\\text{del}}$。\n正向移动是一次删除尝试。初始状态 $A$ 有 $N$ 个粒子，位形为 $\\mathbf{r}^{N}$，能量为 $U_{\\text{old}} = U_{N}(\\mathbf{r}^{N})$。从 $N$ 个粒子中均匀随机地选择一个并移除。新状态 $B$ 有 $N-1$ 个粒子，位形为 $\\mathbf{r}^{N-1}$，能量为 $U_{\\text{new}} = U_{N-1}(\\mathbf{r}^{N-1})$。能量变化为 $\\Delta E = U_{\\text{new}} - U_{\\text{old}}$。\n\n对于这个正向移动（删除），建议概率 $g(A \\to B)$ 是从 $N$ 个粒子中选择一个特定粒子的概率，即 $1/N$。\n逆向移动是从状态 $B$（有 $N-1$ 个粒子）到状态 $A$（有 $N$ 个粒子）的插入。这涉及到将被移除的粒子在其原始位置重新插入。这次插入的建议概率密度是 $g(B \\to A) = 1/V$。\n\n遵循同样的细致平衡过程：\n$$\n\\text{Ratio}_{\\text{del}} = \\frac{\\pi(B) g(B \\to A)}{\\pi(A) g(A \\to B)} = \\frac{z^{N-1} \\exp(-\\beta U_{N-1})}{z^{N} \\exp(-\\beta U_{N})} \\cdot \\frac{1/V}{1/N}\n$$\n$$\n\\text{Ratio}_{\\text{del}} = z^{-1} \\exp(-\\beta(U_{N-1} - U_{N})) \\frac{N}{V} = \\frac{N}{zV} \\exp(-\\beta \\Delta E)\n$$\n因此，删除的接受概率为：\n$$\n\\alpha_{\\text{del}} = \\min\\left(1, \\frac{N}{zV} \\exp(-\\beta \\Delta E)\\right)\n$$\n此处，$N$ 是删除前的粒子数，且 $\\Delta E = U_{N-1} - U_N$。\n\n这两个表达式提供了所要求的完整答案。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\min\\left(1, \\frac{zV}{N+1} \\exp(-\\beta \\Delta E)\\right)  \\min\\left(1, \\frac{N}{zV} \\exp(-\\beta \\Delta E)\\right) \\end{pmatrix}}\n$$", "id": "3467672"}, {"introduction": "从理论算法到高效的计算实践，一个关键的跨越在于如何处理粒子间的相互作用。对于包含大量粒子的系统，在每次移动后天真地重新计算总能量是极其低效的。本练习将理论与高性能计算实践相结合，首先引导您推导单粒子移动时系统能量变化的精确表达式，然后要求您设计并实现如邻居列表和格子列表这类关键数据结构，以将能量计算的复杂度从$O(N)$优化到$O(k)$，其中$k$是局部邻居粒子数。这项实践是编写任何严肃分子模拟程序的基础。[@problem_id:3467668]", "problem": "给定一个边长为 $L$ 的三维周期性立方模拟单元，其中包含 $N$ 个通过对加势相互作用的经典点粒子。所有物理量均采用约化的 Lennard-Jones（无量纲）单位，其中玻尔兹曼常数 $k_{\\mathrm{B}}=1$，Lennard-Jones 势阱深度 $\\epsilon=1$，Lennard-Jones 直径 $\\sigma=1$，热德布罗意波长 $\\Lambda=1$。周期性边界条件使用最小镜像约定。对势在截断距离 $r_c$ 处被截断和移动，因此对相互作用能 $u(r)$ 为\n$$\nu(r) = \\begin{cases}\n4\\left[\\left(\\dfrac{1}{r}\\right)^{12} - \\left(\\dfrac{1}{r}\\right)^{6}\\right] - 4\\left[\\left(\\dfrac{1}{r_c}\\right)^{12} - \\left(\\dfrac{1}{r_c}\\right)^{6}\\right],  r  r_c,\\\\\n0,  r \\ge r_c.\n\\end{cases}\n$$\n总势能为 $U = \\sum_{1 \\le i  j \\le N} u(r_{ij})$。\n\n1. 推导当单个粒子 $k$ 从位置 $\\mathbf{r}_k$ 移动到 $\\mathbf{r}_k'$ 时，系统总势能变化 $\\Delta E = U_{\\text{new}} - U_{\\text{old}}$ 的表达式。证明 $\\Delta E$ 可以仅通过计算与移动粒子相关的相互作用能变化来获得，而无需重新计算整个系统的能量。\n\n2. 编写一个 Python 脚本，该脚本实现并测试以下蒙特卡洛移动的能量计算和/或接受概率：\n   a) **粒子位移（正则系综）**：对于给定的粒子位移，计算势能变化 $\\Delta E$。为了提高效率，应使用邻居列表（皮肤半径 $r_s$），仅计算移动粒子与其在 $r_c + r_s$ 范围内的邻居之间的相互作用能变化。\n   b) **粒子插入（巨正则系综）**：对于给定的粒子插入，计算 Metropolis 接受概率 $\\alpha_{\\text{ins}}$。化学势 $\\mu$ 和温度 $T$ 将被提供。为了有效地找到插入位置附近的粒子，应使用基于元胞（cell）的邻居查找方法（元胞列表），其中元胞边长 $l_{\\text{cell}} \\ge r_c + r_s$。\n   c) **粒子删除（巨正则系综）**：对于给定的粒子删除，计算 Metropolis 接受概率 $\\alpha_{\\text{del}}$。\n\n你的脚本应处理一系列预定义的测试用例，并以特定格式打印出结果。", "solution": "该问题被评估为有效，因为它在统计力学和计算物理学方面有科学依据，定义了所有必要参数，问题阐述清晰，并且其表述是客观的。它代表了实现蒙特卡洛模拟组件的一个标准的、非平凡的练习。\n\n### 任务1：粒子位移能量变化的推导\n\n包含 $N$ 个粒子的系统的总势能由所有唯一粒子对的加和给出：\n$$\nU = \\sum_{1 \\le i  j \\le N} u(r_{ij})\n$$\n其中 $u(r_{ij})$ 是粒子 $i$ 和 $j$ 之间的对势。\n\n当单个粒子（例如粒子 $k$）从初始位置 $\\mathbf{r}_k$ 移动到新位置 $\\mathbf{r}_k'$ 时，所有其他粒子 $\\{\\mathbf{r}_j\\}_{j \\neq k}$ 的位置保持不变。我们可以将总能量和拆分为包含粒子 $k$ 的项和不包含粒子 $k$ 的项。\n\n初始总能量 $U_{\\text{old}}$ 为：\n$$\nU_{\\text{old}} = \\sum_{j \\neq k} u(r_{kj}) + \\sum_{1 \\le i  j \\le N, i,j \\neq k} u(r_{ij})\n$$\n第一项表示粒子 $k$ 与所有其他粒子的相互作用能。第二项是所有其他粒子彼此之间的相互作用能。注意，求和 $\\sum_{j \\neq k}$ 隐式地覆盖了所有涉及 $k$ 的粒子对。\n\n将粒子 $k$ 移动到 $\\mathbf{r}_k'$ 后的新总能量 $U_{\\text{new}}$ 为：\n$$\nU_{\\text{new}} = \\sum_{j \\neq k} u(r'_{kj}) + \\sum_{1 \\le i  j \\le N, i,j \\neq k} u(r_{ij})\n$$\n这里，$r_{kj}$ 是 $\\mathbf{r}_k$ 和 $\\mathbf{r}_j$ 之间的距离，而 $r'_{kj}$ 是新位置 $\\mathbf{r}_k'$ 和 $\\mathbf{r}_j$ 之间的距离。\n\n势能的变化 $\\Delta E$ 定义为 $U_{\\text{new}} - U_{\\text{old}}$。从 $U_{\\text{new}}$ 的表达式中减去 $U_{\\text{old}}$ 的表达式，与粒子 $k$ 位置无关的第二项被抵消：\n$$\n\\Delta E = \\left( \\sum_{j \\neq k} u(r'_{kj}) + \\sum_{1 \\le i  j \\le N, i,j \\neq k} u(r_{ij}) \\right) - \\left( \\sum_{j \\neq k} u(r_{kj}) + \\sum_{1 \\le i  j \\le N, i,j \\neq k} u(r_{ij}) \\right)\n$$\n$$\n\\Delta E = \\sum_{j \\neq k} u(r'_{kj}) - \\sum_{j \\neq k} u(r_{kj}) = \\sum_{j \\neq k} \\left[ u(r'_{kj}) - u(r_{kj}) \\right]\n$$\n这个结果表明，能量变化仅取决于移动粒子 $k$ 与系统中所有其他粒子 $j$ 的相互作用能的变化。这避免了对 $O(N^2)$ 对相互作用的重新计算，将单次移动的计算成本降低到 $O(N)$。\n\n### 任务2：Python 脚本实现逻辑\n\n提供的 Python 代码实现了计算能量变化和接受概率的逻辑，并应用了高效的邻居查找技术。\n\n**a) 粒子位移**\n对于粒子位移，为了将计算复杂度从 $O(N)$ 进一步优化到 $O(1)$（对于固定密度），使用了邻居列表。\n1.  **邻居列表构建**：在计算 $\\Delta E$ 之前，首先为被移动的粒子 `i_move` 构建一个邻居列表。遍历所有其他粒子 `j`，如果它们之间的距离的平方小于邻居列表截断半径的平方 `r_neighbor_sq = (rc + rs)^2`，则将粒子 `j` 添加到列表中。\n2.  **能量变化计算**：然后，仅遍历这个（通常小得多的）邻居列表。对于每个邻居 `j`，计算移动前后的对相互作用能 `u_old` 和 `u_new`，并将差值 `u_new - u_old` 累加到 `delta_E`。\n\n**b) 粒子插入**\n对于粒子插入，为了快速确定在插入位置 `r_ins` 附近的粒子，使用了元胞列表（或称格子列表）数据结构。\n1.  **元胞列表构建**：首先，将模拟盒子划分为一个 `M x M x M` 的元胞网格，其中元胞边长 `l_cell` 至少为 `rc + rs`。然后，遍历所有 `N` 个粒子，根据它们的位置将它们分配到相应的元胞中。这是通过 `head` 和 `llist` 两个数组实现的，它们共同构成了一个链表结构。`head[cx,cy,cz]` 存储位于元胞 `(cx,cy,cz)` 的第一个粒子的索引，而 `llist[i]` 存储同一元胞中粒子 `i` 之后的下一个粒子的索引。\n2.  **邻居搜索与能量计算**：确定插入位置 `r_ins` 所在的元胞 `(cx,cy,cz)`。然后，遍历该元胞及其相邻的 26 个元胞。对于这些元胞中的每一个粒子，计算其与 `r_ins` 的距离，如果距离小于 `rc`，则计算它们之间的 LJ 势并累加到 `delta_E_ins`。\n3.  **接受概率**：利用推导出的 GCMC 插入公式计算接受概率 `p_ins = min(1, (V/(N+1)) * exp(beta*mu - beta*delta_E_ins))`。其中活度 $z$ 被替换为 $\\exp(\\beta\\mu)$ （因为 $\\Lambda=1$）。\n\n**c) 粒子删除**\n对于粒子删除，情况稍微简单一些。\n1.  **能量计算**：需要计算被删除粒子 `i_del` 与系统中所有其他粒子的总相互作用能 `energy_of_idel`。这可以通过遍历所有其他粒子 `j` 并累加对势 `u(r_{ij})` 来实现。\n2.  **能量变化**：删除该粒子所引起的系统总能量变化就是这个能量的负值，即 `delta_E_del = -energy_of_idel`。\n3.  **接受概率**：利用 GCMC 删除公式计算接受概率 `p_del = min(1, (N/V) * exp(-beta*mu - beta*delta_E_del))`。\n\n该脚本精确地实现了这些算法，并通过一系列测试用例验证了其正确性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational materials science problem by calculating energy changes\n    and acceptance probabilities for Monte Carlo moves in canonical and grand\n    canonical ensembles.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    L = 8.0\n    rc = 2.5\n    rs = 0.6\n    \n    # --- Helper Functions ---\n\n    def mic_vector(vec, box_length):\n        \"\"\"Applies the minimum image convention to a displacement vector.\"\"\"\n        return vec - box_length * np.round(vec / box_length)\n\n    # Pre-calculate the potential shift at the cutoff distance\n    rc_inv6 = rc**-6\n    rc_inv12 = rc_inv6**2\n    U_SHIFT = 4.0 * (rc_inv12 - rc_inv6)\n\n    def potential(r_sq, rc_sq):\n        \"\"\"\n        Calculates the truncated and shifted Lennard-Jones potential.\n        Takes squared distances to avoid unnecessary sqrt operations.\n        \"\"\"\n        if r_sq = rc_sq:\n            return 0.0\n        \n        r_inv2 = 1.0 / r_sq\n        r_inv6 = r_inv2 * r_inv2 * r_inv2\n        r_inv12 = r_inv6 * r_inv6\n        \n        return 4.0 * (r_inv12 - r_inv6) - U_SHIFT\n\n    # --- Test Suite Definition ---\n    test_cases = [\n        # Test 1: Canonical displacement, general case\n        {\n            \"type\": \"displacement\",\n            \"N\": 4,\n            \"pos\": np.array([\n                [1.0, 1.0, 1.0], [3.1, 1.0, 1.0], \n                [1.0, 3.1, 1.0], [1.0, 1.0, 3.1]\n            ]),\n            \"i_move\": 0,\n            \"dr\": np.array([0.2, 0.0, 0.0])\n        },\n        # Test 2: Canonical displacement, anisotropic\n        {\n            \"type\": \"displacement\",\n            \"N\": 4,\n            \"pos\": np.array([\n                [1.0, 1.0, 1.0], [3.1, 1.0, 1.0], \n                [1.0, 3.1, 1.0], [1.0, 1.0, 3.1]\n            ]),\n            \"i_move\": 0,\n            \"dr\": np.array([-0.25, 0.1, 0.0])\n        },\n        # Test 3: Grand canonical insertion\n        {\n            \"type\": \"insertion\",\n            \"N\": 4,\n            \"pos\": np.array([\n                [1.0, 1.0, 1.0], [3.1, 1.0, 1.0], \n                [1.0, 3.1, 1.0], [1.0, 1.0, 3.1]\n            ]),\n            \"r_ins\": np.array([2.0, 2.0, 2.0]),\n            \"T\": 1.2,\n            \"mu\": -2.0\n        },\n        # Test 4: Grand canonical deletion\n        {\n            \"type\": \"deletion\",\n            \"N\": 4,\n            \"pos\": np.array([\n                [1.0, 1.0, 1.0], [3.1, 1.0, 1.0], \n                [1.0, 3.1, 1.0], [1.0, 1.0, 3.1]\n            ]),\n            \"i_del\": 1,\n            \"T\": 1.2,\n            \"mu\": -2.0\n        },\n        # Test 5: Canonical displacement, no neighbors\n        {\n            \"type\": \"displacement\",\n            \"N\": 2,\n            \"pos\": np.array([[1.0, 1.0, 1.0], [5.0, 1.0, 1.0]]),\n            \"i_move\": 0,\n            \"dr\": np.array([0.2, 0.0, 0.0])\n        },\n        # Test 6: Canonical displacement, pair at cutoff\n        {\n            \"type\": \"displacement\",\n            \"N\": 2,\n            \"pos\": np.array([[1.0, 1.0, 1.0], [3.5, 1.0, 1.0]]),\n            \"i_move\": 0,\n            \"dr\": np.array([0.0, 0.1, 0.0])\n        }\n    ]\n\n    results = []\n    rc_sq = rc**2\n    r_neighbor_sq = (rc + rs)**2\n\n    for case in test_cases:\n        move_type = case[\"type\"]\n        pos = case[\"pos\"]\n        N = case[\"N\"]\n\n        if move_type == \"displacement\":\n            i_move = case[\"i_move\"]\n            dr = case[\"dr\"]\n            \n            r_i_old = pos[i_move]\n            r_i_new = r_i_old + dr\n            \n            delta_E = 0.0\n            \n            # Per prompt, build neighbor list for particle i, then compute delta_E\n            neighbors = []\n            for j in range(N):\n                if i_move == j:\n                    continue\n                dist_vec = mic_vector(r_i_old - pos[j], L)\n                dist_sq = np.dot(dist_vec, dist_vec)\n                if dist_sq  r_neighbor_sq:\n                    neighbors.append(j)\n\n            for j in neighbors:\n                r_j = pos[j]\n                \n                dist_vec_old = mic_vector(r_i_old - r_j, L)\n                dist_sq_old = np.dot(dist_vec_old, dist_vec_old)\n\n                dist_vec_new = mic_vector(r_i_new - r_j, L)\n                dist_sq_new = np.dot(dist_vec_new, dist_vec_new)\n\n                u_old = potential(dist_sq_old, rc_sq)\n                u_new = potential(dist_sq_new, rc_sq)\n                delta_E += u_new - u_old\n\n            results.append(delta_E)\n\n        elif move_type == \"insertion\":\n            r_ins = case[\"r_ins\"]\n            T = case[\"T\"]\n            mu = case[\"mu\"]\n            V = L**3\n            beta = 1.0 / T\n\n            # Build cell-linked list for neighbor search\n            l_cell = rc + rs\n            M = int(L / l_cell)\n            inv_l_cell = 1.0 / l_cell\n            head = -np.ones((M, M, M), dtype=int)\n            llist = -np.ones(N, dtype=int)\n\n            for i in range(N):\n                c = (pos[i] * inv_l_cell).astype(int)\n                cx, cy, cz = c[0] % M, c[1] % M, c[2] % M\n                llist[i] = head[cx, cy, cz]\n                head[cx, cy, cz] = i\n\n            delta_E_ins = 0.0\n            c_ins = (r_ins * inv_l_cell).astype(int)\n            cx, cy, cz = c_ins[0], c_ins[1], c_ins[2]\n\n            # Search neighbor cells\n            for dcx in [-1, 0, 1]:\n                for dcy in [-1, 0, 1]:\n                    for dcz in [-1, 0, 1]:\n                        ncx = (cx + dcx + M) % M\n                        ncy = (cy + dcy + M) % M\n                        ncz = (cz + dcz + M) % M\n\n                        p_idx = head[ncx, ncy, ncz]\n                        while p_idx != -1:\n                            dist_vec = mic_vector(r_ins - pos[p_idx], L)\n                            dist_sq = np.dot(dist_vec, dist_vec)\n                            if dist_sq  rc_sq:\n                                delta_E_ins += potential(dist_sq, rc_sq)\n                            p_idx = llist[p_idx]\n            \n            # Using z = exp(beta*mu) since Lambda=1\n            prob_arg = (V / (N + 1.0)) * np.exp(beta * mu - beta * delta_E_ins)\n            p_ins = min(1.0, prob_arg)\n            results.append(p_ins)\n\n        elif move_type == \"deletion\":\n            i_del = case[\"i_del\"]\n            T = case[\"T\"]\n            mu = case[\"mu\"]\n            V = L**3\n            beta = 1.0 / T\n\n            energy_of_idel = 0.0\n            r_i_del = pos[i_del]\n            \n            for j in range(N):\n                if i_del == j:\n                    continue\n                dist_vec = mic_vector(r_i_del - pos[j], L)\n                dist_sq = np.dot(dist_vec, dist_vec)\n                energy_of_idel += potential(dist_sq, rc_sq)\n\n            delta_E_del = -energy_of_idel\n            \n            # Using z = exp(beta*mu) since Lambda=1\n            prob_arg = (N / V) / np.exp(beta * mu) * np.exp(-beta * delta_E_del)\n            p_del = min(1.0, prob_arg)\n            results.append(p_del)\n\n    # Final printing in the required format\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n```", "id": "3467668"}]}