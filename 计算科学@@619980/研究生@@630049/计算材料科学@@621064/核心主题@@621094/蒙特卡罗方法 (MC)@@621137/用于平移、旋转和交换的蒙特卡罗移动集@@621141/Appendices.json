{"hands_on_practices": [{"introduction": "为了确保蒙特卡洛模拟能够正确地抽样玻尔兹曼分布，细致平衡条件（detailed balance condition）的满足是至关重要的。尽管Metropolis-Hastings算法提供了一个通用的框架，但在实践中，特别是当涉及到多种移动类型（例如平移、旋转和交换）的混合以及依赖于当前状态的移动选择方案时，其实现细节往往暗藏陷阱。本练习 [@problem_id:3467384] 提供了一个具体的计算平台，旨在通过数值方法检验细致平衡，并深入理解不同的移动提议方案（与状态无关的均衡选择与与状态相关的偏向选择）如何影响转移概率。", "problem": "您必须实现一个完整、可运行的程序，用于评估在两种不同的移动类型选择方案下，一个在平移、旋转和交换移动之间进行选择的混合移动马尔可夫链蒙特卡洛步骤是否满足细致平衡条件。该程序必须为每个指定的测试用例计算用于验证细致平衡的比率，并以浮点数形式输出这些比率。\n\n基本原理是，为了使马尔可夫链收敛到玻尔兹曼分布，必须满足细致平衡条件。设系统有一个状态 $s$，其能量为 $E(s)$，玻尔兹曼平衡概率为 $P_{\\mathrm{eq}}(s) \\propto \\exp(-\\beta E(s))$，其中 $\\beta$ 是逆温度。从 $s$ 到 $s'$ 的转移概率为 $T(s \\to s') = q(s \\to s') \\, a(s \\to s')$，其中 $q(s \\to s')$ 是提议分布，$a(s \\to s')$ 是接受概率。当提议是对称的时，经典的 Metropolis 接受准则是 $a(s \\to s') = \\min\\!\\left(1, \\exp\\!\\left(-\\beta (E(s') - E(s))\\right)\\right)$。细致平衡要求\n$$\nP_{\\mathrm{eq}}(s)\\,T(s \\to s') \\;=\\; P_{\\mathrm{eq}}(s')\\,T(s' \\to s).\n$$\n为了对单个提议移动 $s \\to s'$ 进行细致平衡的数值检验，定义比率\n$$\nR(s,s') \\;=\\; \\frac{P_{\\mathrm{eq}}(s)\\,q(s \\to s')\\,a(s \\to s')}{P_{\\mathrm{eq}}(s')\\,q(s' \\to s)\\,a(s' \\to s)}.\n$$\n如果细致平衡完全成立，则 $R(s,s') = 1$。\n\n系统模型。考虑一个由 $N$ 个格点组成的一维环，具有周期性边界条件。每个格点 $i$ 有一个类型 $t_i \\in \\{\\text{A}, \\text{B}, \\text{E}\\}$（A 和 B 分别被 A 型和 B 型分子占据，E 表示空）。取向角仅为 A 型分子定义；如果 $t_i=\\text{A}$，则设 $\\theta_i$ 为格点 $i$ 的取向，否则未定义。角度必须以弧度处理。\n\n能量模型。使用最近邻相互作用和单体取向场：\n- 定义如果 $t_i=\\text{A}$ 则 $s_i = +1$，如果 $t_i=\\text{B}$ 则 $s_i = -1$，如果 $t_i=\\text{E}$ 则 $s_i = 0$。\n- 最近邻能量为\n$$\nE_{\\mathrm{nn}}(s) \\;=\\; J \\sum_{i=0}^{N-1} s_i\\,s_{(i+1)\\bmod N}.\n$$\n- A 型分子的旋转能量为\n$$\nE_{\\mathrm{rot}}(s) \\;=\\; k \\sum_{i: t_i=\\text{A}} \\left(1 - \\cos(\\theta_i)\\right).\n$$\n- 总能量为 $E(s) = E_{\\mathrm{nn}}(s) + E_{\\mathrm{rot}}(s)$。\n\n蒙特卡洛移动集。实现三种移动类型：\n1. 平移：从所有被占据的格点中均匀选择一个格点 $i$。均匀选择一个方向（左或右）。如果相邻格点为空，则提议将格点 $i$ 上的粒子移动到该相邻格点，并携带其取向 $\\theta_i$。如果相邻格点不为空，则提议不改变状态（后一种情况在测试套件中不使用；仅测试改变状态的移动）。\n2. 旋转：从所有 A 型格点中均匀选择一个 $t_i=\\text{A}$ 的格点 $i$。提议 $\\theta_i' = \\theta_i + \\delta$，其中 $\\delta \\sim \\mathcal{N}(0,\\sigma^2)$；$\\sigma$ 是标准差，提议密度为 $q_{\\mathrm{rot}}(\\delta) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{\\delta^2}{2\\sigma^2}\\right)$。\n3. 局部交换：从 $N$ 个键中均匀选择一个最近邻键 $(i,i+1)$。如果两个格点都被占据且类型不同（一个 A 和一个 B），则提议交换键两端的类型；如果类型相同或一个格点为空，则提议不改变状态（测试套件仅使用改变状态的交换）。\n\n混合移动的选择方案：\n- 平衡选择：以固定的概率 $c_{\\mathrm{T}} = c_{\\mathrm{R}} = c_{\\mathrm{S}} = 1/3$ 选择平移、旋转和交换，该概率与当前状态无关。在每种移动类型内部，如上所述均匀选择目标。所产生的提议在经典 Metropolis 接受准则所要求的意义上是对称的。\n- 有偏（状态依赖）选择：计算当前状态 $s$ 下每种移动类型的合格提议数量：\n    - 设 $m_{\\mathrm{T}}(s)$ 为将改变状态的有序平移提议的数量（每个被占据的格点为其每个空的相邻方向贡献一个计数）。\n    - 设 $m_{\\mathrm{R}}(s)$ 为 A 型格点的数量。\n    - 设 $m_{\\mathrm{S}}(s)$ 为被不同类型（A–B 或 B–A）占据的最近邻键的数量。\n  定义移动类型的选择概率为 $p_{\\mathrm{T}}(s) = \\frac{m_{\\mathrm{T}}(s)}{m_{\\Sigma}(s)}$，$p_{\\mathrm{R}}(s) = \\frac{m_{\\mathrm{R}}(s)}{m_{\\Sigma}(s)}$，$p_{\\mathrm{S}}(s) = \\frac{m_{\\mathrm{S}}(s)}{m_{\\Sigma}(s)}$，其中 $m_{\\Sigma}(s) = m_{\\mathrm{T}}(s) + m_{\\mathrm{R}}(s) + m_{\\mathrm{S}}(s)$。在选定的移动类型内，从合格提议中均匀选择。对于旋转，连续提议密度 $q_{\\mathrm{rot}}(\\delta)$ 乘以离散选择因子。请注意，此方案使得 $q(s \\to s')$ 与 $1/m_{\\Sigma}(s)$ 乘以任何特定移动类型的连续密度成正比，并且 $m_{\\Sigma}$ 在 $s$ 和 $s'$ 之间可能发生变化。\n\n接受准则。在所有情况下均使用经典 Metropolis 接受准则 $a(s \\to s') = \\min\\!\\left(1, \\exp\\!\\left(-\\beta (E(s') - E(s))\\right)\\right)$。角度必须以弧度处理。\n\n任务。对于下面的每个测试用例，使用指定的选择方案和移动计算上面定义的比率 $R(s,s')$。您的程序必须生成一行输出，其中包含所有测试用例的比率，格式为方括号内的逗号分隔列表。\n\n所有测试的常数：$N=4$，$\\beta=1.0$，$J=0.5$，$k=0.3$，$\\sigma=0.1$（弧度）。角度必须解释为弧度。\n\n测试套件：\n- 测试 1（平衡平移）：\n    - 初始类型：$[\\text{A}, \\text{B}, \\text{E}, \\text{A}]$。\n    - 初始角度：$[\\theta_0=0.0, \\text{None}, \\text{None}, \\theta_3=1.0]$。\n    - 移动：将格点 $i=1$ 上的粒子向右平移（到格点 $2$）。\n    - 选择方案：平衡选择，概率为 $c_{\\mathrm{T}} = c_{\\mathrm{R}} = c_{\\mathrm{S}} = 1/3$。\n- 测试 2（改变移动计数的有偏局部交换）：\n    - 初始类型：$[\\text{A}, \\text{B}, \\text{A}, \\text{E}]$。\n    - 初始角度：$[\\theta_0=0.0, \\text{None}, \\theta_2=0.0, \\text{None}]$。\n    - 移动：交换键 $(0,1)$ 两端的类型。\n    - 选择方案：有偏选择，使用定义的 $p_{\\mathrm{T}}(s)$，$p_{\\mathrm{R}}(s)$，$p_{\\mathrm{S}}(s)$。\n- 测试 3（保持移动计数的有偏旋转）：\n    - 初始类型：$[\\text{A}, \\text{B}, \\text{A}, \\text{B}]$。\n    - 初始角度：$[\\theta_0=0.0, \\text{None}, \\theta_2=0.0, \\text{None}]$。\n    - 移动：在格点 $i=0$ 处旋转，$\\delta = 0.5$ 弧度。\n    - 选择方案：有偏选择，使用定义的 $p_{\\mathrm{T}}(s)$，$p_{\\mathrm{R}}(s)$，$p_{\\mathrm{S}}(s)$。\n\n最终输出格式。您的程序应生成一行输出，其中包含方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3]”），其中每个结果是相应测试用例的 $R(s,s')$ 的浮点值，根据上述定义精确计算。角度单位为弧度；不需要其他物理单位。确保数值计算精确且自洽。程序必须是自包含的，并且无需任何用户输入即可产生输出。", "solution": "该问题要求在两种不同的移动选择方案下，为混合移动蒙特卡洛模拟计算细致平衡验证比率 $R(s,s')$。该比率定义为：\n$$\nR(s,s') = \\frac{P_{\\mathrm{eq}}(s)\\,T(s \\to s')}{P_{\\mathrm{eq}}(s')\\,T(s' \\to s)}\n$$\n其中 $s$ 和 $s'$ 是初始和最终状态，$P_{\\mathrm{eq}}(x) \\propto \\exp(-\\beta E(x))$ 是平衡概率，$T(x \\to y) = q(x \\to y)\\,a(x \\to y)$ 是转移概率。提议概率为 $q(x \\to y)$，接受概率为 $a(x \\to y)$。\n\n问题指定在所有情况下都使用经典的 Metropolis 接受准则：\n$$\na(s \\to s') = \\min\\left(1, \\exp\\left(-\\beta (E(s') - E(s))\\right)\\right)\n$$\n我们来分析比率 $R(s,s')$。代入定义，我们得到：\n$$\nR(s,s') = \\frac{\\exp(-\\beta E(s))}{\\exp(-\\beta E(s'))} \\cdot \\frac{q(s \\to s')}{q(s' \\to s)} \\cdot \\frac{a(s \\to s')}{a(s' \\to s)}\n$$\n设 $\\Delta E = E(s') - E(s)$。平衡概率之比为 $\\exp(-\\beta(E(s)-E(s'))) = \\exp(\\beta\\Delta E)$。\n接受概率之比为：\n$$\n\\frac{a(s \\to s')}{a(s' \\to s)} = \\frac{\\min(1, \\exp(-\\beta\\Delta E))}{\\min(1, \\exp(-(-\\beta\\Delta E)))} = \\frac{\\min(1, \\exp(-\\beta\\Delta E))}{\\min(1, \\exp(\\beta\\Delta E))}\n$$\n设 $X = \\exp(-\\beta\\Delta E)$。接受比率变为 $\\frac{\\min(1, X)}{\\min(1, 1/X)}$。可以证明，对于任何 $X > 0$，此表达式恒等于 $X$。因此，接受概率之比简化为 $\\exp(-\\beta\\Delta E)$。\n\n将这些简化项代回 $R(s,s')$ 的表达式中，得到：\n$$\nR(s,s') = \\exp(\\beta\\Delta E) \\cdot \\frac{q(s \\to s')}{q(s' \\to s)} \\cdot \\exp(-\\beta\\Delta E) = \\frac{q(s \\to s')}{q(s' \\to s)}\n$$\n这是一个显著的简化。验证比率 $R(s,s')$ 简化为正向和反向提议概率之比。因此，即使问题陈述中提供了状态的能量、温度 $\\beta$ 以及特定的能量参数 $J$ 和 $k$，计算中也无需使用它们。任务简化为为每个测试用例正确计算 $q(s \\to s')$ 和 $q(s' \\to s)$。\n\n总提议概率 $q(s \\to s')$ 是选择一种移动类型的概率与在该类型内选择特定基本移动的概率的乘积。\n\n以下是使用常数 $N=4, \\beta=1, J=0.5, k=0.3, \\sigma=0.1$ 对每个测试用例进行的分步计算。\n\n**测试 1：平衡平移**\n- 初始状态 $s$：类型为 $[\\text{A}, \\text{B}, \\text{E}, \\text{A}]$。有 $3$ 个被占据的格点。\n- 最终状态 $s'$：类型为 $[\\text{A}, \\text{E}, \\text{B}, \\text{A}]$。有 $3$ 个被占据的格点。\n- 移动：将格点 $i=1$ 上的粒子平移到格点 $i=2$。\n- 选择方案：平衡选择，概率为 $c_{\\mathrm{T}} = c_{\\mathrm{R}} = c_{\\mathrm{S}} = 1/3$。\n\n正向提议概率 $q(s \\to s')$ 是：\n$q(s \\to s') = P(\\text{选择平移}) \\times P(\\text{选择位于 } i=1 \\text{ 的粒子}) \\times P(\\text{选择向右的方向})$\n在状态 $s$ 中，被占据的格点数量为 $3$。\n$$\nq(s \\to s') = c_{\\mathrm{T}} \\times \\frac{1}{\\text{被占据格点数}} \\times \\frac{1}{2} = \\frac{1}{3} \\times \\frac{1}{3} \\times \\frac{1}{2} = \\frac{1}{18}\n$$\n逆向移动是在状态 $s'$ 中将格点 $i=2$ 上的粒子平移回格点 $i=1$。\n在状态 $s'$ 中，被占据的格点数量为 $3$。\n$$\nq(s' \\to s) = c_{\\mathrm{T}} \\times \\frac{1}{\\text{被占据格点数}} \\times \\frac{1}{2} = \\frac{1}{3} \\times \\frac{1}{3} \\times \\frac{1}{2} = \\frac{1}{18}\n$$\n比率为 $R(s,s') = \\frac{1/18}{1/18} = 1.0$。\n\n**测试 2：有偏局部交换**\n- 初始状态 $s$：格点 $[0, 1, 2, 3]$ 上的类型为 $[\\text{A}, \\text{B}, \\text{A}, \\text{E}]$。\n- 最终状态 $s'$：类型为 $[\\text{B}, \\text{A}, \\text{A}, \\text{E}]$。\n- 移动：交换键 $(0,1)$ 两端的类型。\n- 选择方案：有偏选择，概率依赖于计数 $m_{\\mathrm{T}}(s)$，$m_{\\mathrm{R}}(s)$ 和 $m_{\\mathrm{S}}(s)$。\n\n对于初始状态 $s = [\\text{A}, \\text{B}, \\text{A}, \\text{E}]$：\n- $m_{\\mathrm{T}}(s)$：向空格点的平移。格点 $0$ 可以向左移动到 $3(\\text{E})$；格点 $2$ 可以向右移动到 $3(\\text{E})$。所以，$m_{\\mathrm{T}}(s)=2$。\n- $m_{\\mathrm{R}}(s)$：A 型格点的数量。格点 $0$ 和 $2$ 是 A 型。所以，$m_{\\mathrm{R}}(s)=2$。\n- $m_{\\mathrm{S}}(s)$：A-B 键的数量。键 $(0,1)$ 和 $(1,2)$ 是 A-B/B-A。所以，$m_{\\mathrm{S}}(s)=2$。\n- 总提议数：$m_{\\Sigma}(s) = m_{\\mathrm{T}}(s)+m_{\\mathrm{R}}(s)+m_{\\mathrm{S}}(s) = 2+2+2=6$。\n\n正向提议概率 $q(s \\to s')$ 是：\n$q(s \\to s') = P(\\text{选择交换}) \\times P(\\text{选择键 } (0,1) \\text{ | 给定交换移动})$\n$$\nq(s \\to s') = \\frac{m_{\\mathrm{S}}(s)}{m_{\\Sigma}(s)} \\times \\frac{1}{m_{\\mathrm{S}}(s)} = \\frac{2}{6} \\times \\frac{1}{2} = \\frac{1}{6}\n$$\n对于最终状态 $s' = [\\text{B}, \\text{A}, \\text{A}, \\text{E}]$：\n- $m_{\\mathrm{T}}(s')$：格点 $0$ 可以向左移动到 $3(\\text{E})$；格点 $2$ 可以向右移动到 $3(\\text{E})$。所以，$m_{\\mathrm{T}}(s')=2$。\n- $m_{\\mathrm{R}}(s')$：格点 $1$ 和 $2$ 是 A 型。所以，$m_{\\mathrm{R}}(s')=2$。\n- $m_{\\mathrm{S}}(s')$：只有键 $(0,1)$ 是 B-A。所以，$m_{\\mathrm{S}}(s')=1$。\n- 总提议数：$m_{\\Sigma}(s') = 2+2+1=5$。\n\n逆向提议概率 $q(s' \\to s)$ 对应于在状态 $s'$ 中交换键 $(0,1)$：\n$$\nq(s' \\to s) = \\frac{m_{\\mathrm{S}}(s')}{m_{\\Sigma}(s')} \\times \\frac{1}{m_{\\mathrm{S}}(s')} = \\frac{1}{5} \\times \\frac{1}{1} = \\frac{1}{5}\n$$\n比率为 $R(s,s') = \\frac{1/6}{1/5} = \\frac{5}{6}$。\n\n**测试 3：有偏旋转**\n- 初始状态 $s$：类型为 $[\\text{A}, \\text{B}, \\text{A}, \\text{B}]$。\n- 最终状态 $s'$：类型为 $[\\text{A}, \\text{B}, \\text{A}, \\text{B}]$。\n- 移动：将格点 $i=0$ 旋转 $\\delta = 0.5$ 弧度。\n- 选择方案：有偏选择。\n\n对于状态 $s = [\\text{A}, \\text{B}, \\text{A}, \\text{B}]$（$s'$ 也一样，因为类型不变）：\n- $m_{\\mathrm{T}}(s)$：没有空格点。所以，$m_{\\mathrm{T}}(s)=0$。\n- $m_{\\mathrm{R}}(s)$：格点 $0$ 和 $2$ 是 A 型。所以，$m_{\\mathrm{R}}(s)=2$。\n- $m_{\\mathrm{S}}(s)$：所有四个键都是 A-B 或 B-A。所以，$m_{\\mathrm{S}}(s)=4$。\n- 总提议数：$m_{\\Sigma}(s) = 0+2+4=6$。\n\n正向提议是格点 $0$ 旋转 $\\delta=0.5$。这是一个连续移动，所以我们使用概率密度。\n$q(s \\to s') = P(\\text{选择旋转}) \\times P(\\text{选择格点 } 0 \\text{ | 给定旋转移动}) \\times q_{\\mathrm{rot}}(\\delta)$\n$$\nq(s \\to s') = \\frac{m_{\\mathrm{R}}(s)}{m_{\\Sigma}(s)} \\times \\frac{1}{m_{\\mathrm{R}}(s)} \\times q_{\\mathrm{rot}}(0.5) = \\frac{2}{6} \\times \\frac{1}{2} \\times q_{\\mathrm{rot}}(0.5) = \\frac{1}{6} q_{\\mathrm{rot}}(0.5)\n$$\n其中 $q_{\\mathrm{rot}}(\\delta) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp(-\\frac{\\delta^2}{2\\sigma^2})$。\n逆向移动是格点 $0$ 旋转 $-\\delta=-0.5$。由于 $s'$ 的类型构型相同，离散选择概率是相同的。\n$$\nq(s' \\to s) = \\frac{m_{\\mathrm{R}}(s')}{m_{\\Sigma}(s')} \\times \\frac{1}{m_{\\mathrm{R}}(s')} \\times q_{\\mathrm{rot}}(-\\delta) = \\frac{2}{6} \\times \\frac{1}{2} \\times q_{\\mathrm{rot}}(-0.5) = \\frac{1}{6} q_{\\mathrm{rot}}(-0.5)\n$$\n高斯提议密度是对称的，$q_{\\mathrm{rot}}(\\delta) = q_{\\mathrm{rot}}(-\\delta)$。因此，密度项相互抵消。\n比率为 $R(s,s') = \\frac{(1/6) q_{\\mathrm{rot}}(0.5)}{(1/6) q_{\\mathrm{rot}}(-0.5)} = 1.0$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the detailed balance certification ratio R(s, s') for three\n    Monte Carlo move test cases.\n\n    As derived in the solution, the ratio R simplifies to q(s->s') / q(s'->s),\n    where q is the proposal probability. This calculation does not require\n    the energy, temperature, or related physical constants.\n    \"\"\"\n    N = 4\n\n    def get_m_counts(types):\n        \"\"\"\n        Calculates the number of eligible proposals for each move type.\n        m_T: Translation moves (occupied site next to empty site).\n        m_R: Rotation moves (number of 'A' type molecules).\n        m_S: Swap moves (number of A-B or B-A nearest-neighbor bonds).\n        \"\"\"\n        # m_T: Count valid translation moves\n        m_T = 0\n        occupied_indices = [i for i, site_type in enumerate(types) if site_type != 'E']\n        for i in occupied_indices:\n            left_neighbor_idx = (i - 1 + N) % N\n            right_neighbor_idx = (i + 1) % N\n            if types[left_neighbor_idx] == 'E':\n                m_T += 1\n            if types[right_neighbor_idx] == 'E':\n                m_T += 1\n\n        # m_R: Count type-A sites\n        m_R = types.count('A')\n\n        # m_S: Count A-B/B-A bonds\n        m_S = 0\n        for i in range(N):\n            neighbor_idx = (i + 1) % N\n            type_i = types[i]\n            type_j = types[neighbor_idx]\n            if type_i != 'E' and type_j != 'E' and type_i != type_j:\n                m_S += 1\n        \n        return m_T, m_R, m_S\n\n    results = []\n\n    # Test 1: Balanced translation\n    # Initial state s: ['A', 'B', 'E', 'A']. Final state s': ['A', 'E', 'B', 'A']\n    num_occupied_s = 3\n    num_occupied_sp = 3\n    c_T = 1.0 / 3.0\n    \n    q_fwd_1 = c_T * (1.0 / num_occupied_s) * (1.0 / 2.0)\n    q_rev_1 = c_T * (1.0 / num_occupied_sp) * (1.0 / 2.0)\n    ratio_1 = q_fwd_1 / q_rev_1\n    results.append(ratio_1)\n\n    # Test 2: Biased local swap\n    s_types_2 = ['A', 'B', 'A', 'E']\n    sp_types_2 = ['B', 'A', 'A', 'E']\n\n    # Forward move from s to s'\n    mt_s, mr_s, ms_s = get_m_counts(s_types_2)\n    msum_s = mt_s + mr_s + ms_s\n    q_fwd_2 = (ms_s / msum_s) * (1.0 / ms_s)\n\n    # Reverse move from s' to s\n    mt_sp, mr_sp, ms_sp = get_m_counts(sp_types_2)\n    msum_sp = mt_sp + mr_sp + ms_sp\n    q_rev_2 = (ms_sp / msum_sp) * (1.0 / ms_sp)\n\n    ratio_2 = q_fwd_2 / q_rev_2\n    results.append(ratio_2)\n\n    # Test 3: Biased rotation\n    # For a rotation move, the type configuration does not change.\n    # The proposal probability for the angle change, q_rot(delta), is\n    # symmetric for delta and -delta, so it cancels out in the ratio.\n    s_types_3 = ['A', 'B', 'A', 'B']\n\n    # Forward move\n    mt_s3, mr_s3, ms_s3 = get_m_counts(s_types_3)\n    msum_s3 = mt_s3 + mr_s3 + ms_s3\n    # The term for q_rot(delta) is omitted as it will be 1.0 after cancellation.\n    q_fwd_3 = (mr_s3 / msum_s3) * (1.0 / mr_s3)\n\n    # Reverse move (state types are the same)\n    q_rev_3 = q_fwd_3 # Since m_counts are the same and q_rot(-delta) = q_rot(delta)\n    \n    ratio_3 = q_fwd_3 / q_rev_3\n    results.append(ratio_3)\n\n    print(f\"[{','.join(f'{r:.15f}'.rstrip('0').rstrip('.') for r in results)}]\")\n\nsolve()\n```", "id": "3467384"}, {"introduction": "从抽象的格点模型过渡到更符合物理实际的离线格模型，我们经常需要处理各向异性的粒子，例如液晶和聚合物体系中常见的球棍状体（spherocylinders）。模拟这类粒子不仅需要考虑平移运动，还必须引入旋转运动。本练习 [@problem_id:3467426] 聚焦于其中的一个关键几何挑战：实现一个精确的旋转移动，并开发一个稳健的算法来检测粒子间的重叠。这对于硬核粒子系统而言是计算能量变化的基础，也是许多软物质模拟的基石。", "problem": "考虑一个由相同的、具有硬核相互作用的球棍体组成的正则系综。每个球棍体由中心位置矢量 $\\mathbf{c} \\in \\mathbb{R}^3$、单位取向矢量 $\\mathbf{u} \\in \\mathbb{R}^3$（满足 $\\lVert \\mathbf{u} \\rVert = 1$）、柱体半径 $r > 0$（单位为 $\\mathrm{nm}$）以及总端到端轴向长度 $L > 0$（单位为 $\\mathrm{nm}$）参数化。与球棍体关联的轴向线段定义为有限集合 $\\mathcal{S} = \\{ \\mathbf{c} + s \\mathbf{u} \\mid s \\in [-L/2, L/2] \\}$。\n\n任意一对球棍体之间的硬核势 $U$ 在球棍体发生几何重叠时为 $U = +\\infty$，否则为 $U = 0$。在逆温度为 $\\beta$ 的正则系综的 Metropolis Monte Carlo (MMC) 框架中，从状态 $X$ 到状态 $Y$ 的提议移动的接受概率由 $A(X \\to Y) = \\min(1, \\exp(-\\beta [U(Y) - U(X)]))$ 给出，对于硬核相互作用，该概率简化为二元接受。\n\n一个球棍体可以视为其轴向线段与一个半径为 $r$ 的实心球的 Minkowski 和。当且仅当两个球棍体的有限轴向线段之间的最小欧几里得距离 $\\delta$ 严格小于它们的半径之和时，这两个球棍体发生重叠。在半径相同的情况下，重叠条件是 $\\delta  2r$，非重叠条件是 $\\delta \\ge 2r$。\n\n设计一个绕指定轴的旋转移动，该移动作用于单个球棍体的取向 $\\mathbf{u}$，同时保持其中心 $\\mathbf{c}$ 固定。旋转轴是一个单位矢量 $\\mathbf{k} \\in \\mathbb{R}^3$，旋转角为 $\\theta$（单位为弧度）。旋转后的取向 $\\mathbf{u}'$ 必须通过绕轴 $\\mathbf{k}$ 旋转角度 $\\theta$ 的标准三维旋转得到。提议的旋转移动的接受是二元的：如果旋转后，移动的球棍体与系统中的任何其他球棍体都不发生重叠，则接受概率为 $1$，否则为 $0$。\n\n您必须仅根据两个球棍体的有限轴向线段之间的最小距离来表达重叠检测，即通过求解 $\\mathbb{R}^3$ 中两个有限线段之间的最近接近点来解决。形式上，给定通过重新参数化端点构建的两个线段 $\\mathcal{S}_1 = \\{ \\mathbf{a}_0 + s \\mathbf{u}_1 \\mid s \\in [0,1] \\}$ 和 $\\mathcal{S}_2 = \\{ \\mathbf{b}_0 + t \\mathbf{v}_2 \\mid t \\in [0,1] \\}$，通过在参数的区间约束下最小化距离平方来计算这些线段上点之间的最小距离 $\\delta$，然后使用阈值 $2r$ 来判断是否重叠。\n\n实现一个完整的程序，该程序：\n- 构建一个待旋转的球棍体，其参数为 $(\\mathbf{c}_\\mathrm{A}, \\mathbf{u}_\\mathrm{A}, L, r)$。\n- 为每个测试用例在环境中构建另一个球棍体，其参数为 $(\\mathbf{c}_\\mathrm{B}, \\mathbf{u}_\\mathrm{B}, L, r)$。\n- 将指定的旋转移動应用于第一个球棍体的取向 $\\mathbf{u}_\\mathrm{A}$，使其绕轴 $\\mathbf{k}$ 旋转角度 $\\theta$（以弧度为单位）。\n- 计算旋转后的球棍体与另一个球棍体的有限轴向线段之间的最小距离 $\\delta$，单位为 $\\mathrm{nm}$。\n- 根据规则返回一个布尔类型的接受值，其中 $1$ 表示为 $\\mathrm{True}$，$0$ 表示为 $\\mathrm{False}$：当且仅当 $\\delta \\ge 2 r$ 时接受。\n\n在测试套件的所有测试用例中，使用以下固定参数：\n- 半径 $r = 0.5$ $\\mathrm{nm}$。\n- 长度 $L = 4.0$ $\\mathrm{nm}$。\n- 待旋转的球棍体中心为 $\\mathbf{c}_\\mathrm{A} = (0.0, 0.0, 0.0)$ $\\mathrm{nm}$，初始取向为 $\\mathbf{u}_\\mathrm{A} = (1.0, 0.0, 0.0)$。\n\n角度必须以弧度为单位进行解释。距离必须以 $\\mathrm{nm}$ 为单位进行计算。最终程序必须生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的 $\\mathrm{True}/\\mathrm{False}$ 值列表，且无空格。\n\n测试套件：\n- 案例 1 (正常路径，旋转后远距离分离): 旋转轴 $\\mathbf{k} = (0.0, 0.0, 1.0)$，角度 $\\theta = \\pi/2$，另一个球棍体的中心 $\\mathbf{c}_\\mathrm{B} = (0.0, 10.0, 0.0)$，取向 $\\mathbf{u}_\\mathrm{B} = (0.0, 1.0, 0.0)$。预期接受为 $\\mathrm{True}$。\n- 案例 2 (旋转后重叠，共线线段内部重叠): 旋转轴 $\\mathbf{k} = (0.0, 0.0, 1.0)$，角度 $\\theta = \\pi/2$，另一个球棍体的中心 $\\mathbf{c}_\\mathrm{B} = (0.0, 1.2, 0.0)$，取向 $\\mathbf{u}_\\mathrm{B} = (0.0, 1.0, 0.0)$。预期接受为 $\\mathrm{False}$。\n- 案例 3 (边界相切，最小距离等于阈值): 旋转轴 $\\mathbf{k} = (0.0, 0.0, 1.0)$，角度 $\\theta = \\pi/2$，另一个球棍体的中心 $\\mathbf{c}_\\mathrm{B} = (0.0, 5.0, 0.0)$，取向 $\\mathbf{u}_\\mathrm{B} = (0.0, 1.0, 0.0)$。预期接受为 $\\mathrm{True}$。\n- 案例 4 (异面线段，最近点位于内部): 旋转轴 $\\mathbf{k} = (0.0, 1.0, 0.0)$，角度 $\\theta = \\pi/4$，另一个球棍体的中心 $\\mathbf{c}_\\mathrm{B} = (0.0, 0.0, 1.0)$，取向 $\\mathbf{u}_\\mathrm{B} = (1.0, 0.0, 0.0)$。预期接受为 $\\mathrm{False}$。\n- 案例 5 (平行线段，横向分离等于阈值): 旋转轴 $\\mathbf{k} = (0.0, 0.0, 1.0)$，角度 $\\theta = 0.0$，另一个球棍体的中心 $\\mathbf{c}_\\mathrm{B} = (0.0, 1.0, 0.0)$，取向 $\\mathbf{u}_\\mathrm{B} = (1.0, 0.0, 0.0)$。预期接受为 $\\mathrm{True}$。\n- 案例 6 (平行线段，横向分离低于阈值): 旋转轴 $\\mathbf{k} = (0.0, 0.0, 1.0)$，角度 $\\theta = 0.0$，另一个球棍体的中心 $\\mathbf{c}_\\mathrm{B} = (0.0, 0.6, 0.0)$，取向 $\\mathbf{u}_\\mathrm{B} = (1.0, 0.0, 0.0)$。预期接受为 $\\mathrm{False}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，例如 $[\\mathrm{True},\\mathrm{False}]$，但应按顺序包含六个测试用例的结果且无空格。", "solution": "我们从正则系综和硬核相互作用的第一性原理开始。状态 $X$ 和 $Y$ 之间的 Metropolis Monte Carlo (MMC) 接受概率为 $A(X \\to Y) = \\min(1, \\exp(-\\beta [U(Y) - U(X)]))$。对于硬核相互作用，如果存在任何重叠，势 $U$ 为 $U = +\\infty$，否则为 $U = 0$。因此，如果提议的移动产生重叠，则 $U(Y) - U(X) = +\\infty$ 且 $A(X \\to Y) = 0$；如果移动保持了非重叠构型，则 $U(Y) - U(X) = 0$ 且 $A(X \\to Y) = 1$。这就确定了硬核系统的接受是二元的。\n\n一个半径为 $r$、轴向长度为 $L$ 的球棍体可以表示为其轴向线段 $\\mathcal{S}$ 与一个半径为 $r$ 的实心球的 Minkowski 和，即所有与 $\\mathcal{S}$ 上某点的欧几里得距离至多为 $r$ 的点的集合。两个相同的球棍体重叠，当且仅当它们轴向线段之间的最小欧几里得距离严格小于它们的半径之和。对于相同的半径，重叠条件简化为 $\\delta  2r$。反之，$\\delta \\ge 2r$ 表示没有重叠。这种简化是严谨的，因为 Minkowski 和原理意味着表面之间的最小距离等于中心线段之间的最小距离减去半径之和，而非重叠对应于最小表面间距为非负值。\n\n因此，核心计算任务是计算 $\\mathbb{R}^3$ 中两个有限线段之间的最小距離 $\\delta$。设第一个线段由端点 $\\mathbf{a}_0$ 和 $\\mathbf{a}_1$ 定义，第二个线段由端点 $\\mathbf{b}_0$ 和 $\\mathbf{b}_1$ 定义。将线段上的点参数化为\n$$\n\\mathbf{p}(s) = \\mathbf{a}_0 + s \\,\\mathbf{u}, \\quad s \\in [0,1], \\quad \\mathbf{u} = \\mathbf{a}_1 - \\mathbf{a}_0,\n$$\n$$\n\\mathbf{q}(t) = \\mathbf{b}_0 + t \\,\\mathbf{v}, \\quad t \\in [0,1], \\quad \\mathbf{v} = \\mathbf{b}_1 - \\mathbf{b}_0.\n$$\n距离平方函数为\n$$\nf(s,t) = \\lVert \\mathbf{p}(s) - \\mathbf{q}(t) \\rVert^2 = \\lVert \\mathbf{w}_0 + s \\mathbf{u} - t \\mathbf{v} \\rVert^2,\n$$\n其中 $\\mathbf{w}_0 = \\mathbf{a}_0 - \\mathbf{b}_0$。展开并对 $s$ 和 $t$求导，将梯度置零，通过一个线性系统可得到无约束最小化子：\n$$\n\\frac{\\partial f}{\\partial s} = 2 \\left( \\mathbf{u} \\cdot \\mathbf{u} \\, s - \\mathbf{u} \\cdot \\mathbf{v} \\, t + \\mathbf{u} \\cdot \\mathbf{w}_0 \\right) = 0,\n$$\n$$\n\\frac{\\partial f}{\\partial t} = 2 \\left( -\\mathbf{u} \\cdot \\mathbf{v} \\, s + \\mathbf{v} \\cdot \\mathbf{v} \\, t - \\mathbf{v} \\cdot \\mathbf{w}_0 \\right) = 0.\n$$\n令 $A = \\mathbf{u} \\cdot \\mathbf{u}$，$B = \\mathbf{u} \\cdot \\mathbf{v}$，$C = \\mathbf{v} \\cdot \\mathbf{v}$，$D = \\mathbf{u} \\cdot \\mathbf{w}_0$，$E = \\mathbf{v} \\cdot \\mathbf{w}_0$。无约束最小化子为\n$$\n\\begin{pmatrix} s^* \\\\ t^* \\end{pmatrix} =\n\\frac{1}{AC - B^2}\n\\begin{pmatrix}\nC  -B \\\\\n-B  A\n\\end{pmatrix}\n\\begin{pmatrix} -D \\\\ E \\end{pmatrix}\n=\n\\left( \\frac{B E - C D}{A C - B^2}, \\; \\frac{A E - B D}{A C - B^2} \\right),\n$$\n条件是 $A C - B^2  0$（非平行情况）。在 $A C - B^2 \\approx 0$ 的平行或近平行情况下，需要特殊处理；可以设置一个参数（例如 $s$）在边界上，然后对另一个参数进行最小化，或者使用为平行线段推导的鲁棒公式。\n\n因为真正的最小化子受到区间约束 $s \\in [0,1]$ 和 $t \\in [0,1]$ 的限制，无约束解必须投影到可行集上。一个鲁棒的方法是：\n- 计算非平行情况下的 $(s^*, t^*)$；否则，为一个参数选择一个初始值。\n- 将 $s$ 限定在 $[0,1]$ 内；根据限定后的 $s$ 重新计算最优的 $t$。\n- 将 $t$ 限定在 $[0,1]$ 内；根据限定后的 $t$ 重新计算最优的 $s$。\n- 通过一系列简短的情况区分来重复限定过程，以使最终的 $(s, t)$ 对是可行的，并得出有限线段间的最小距离。\n\n得到最小化的 $(s, t)$ 后，最小距离为 $\\delta = \\lVert \\mathbf{p}(s) - \\mathbf{q}(t) \\rVert$。当且仅当 $\\delta  2r$ 时存在重叠；等效地，$\\delta \\ge 2r$ 证实了没有重叠。\n\n对于旋转移动，我们将所选球棍体的取向矢量 $\\mathbf{u}$ 绕指定的单位轴 $\\mathbf{k}$ 旋转角度 $\\theta$（以弧度为单位），形成 $\\mathbf{u}'$。中心 $\\mathbf{c}$ 保持不变，因此旋转后的轴向线段为 $\\mathcal{S}' = \\{ \\mathbf{c} + s \\mathbf{u}' \\mid s \\in [-L/2, L/2] \\}$。为了以有原则的方式计算 $\\mathbf{u}'$，需要使用一个与轴 $\\mathbf{k}$ 的右手定则一致的三维标准旋转算子。一种数值上稳定且广泛使用的方法是利用李代数 $\\mathfrak{so}(3)$ 上的指数映射，这会得到用于将矢量绕指定轴旋转给定角度的 Rodrigues 旋转公式。\n\n算法设计：\n- 用端点 $\\mathbf{a}_0 = \\mathbf{c}_\\mathrm{A} - (L/2) \\mathbf{u}_\\mathrm{A}'$ 和 $\\mathbf{a}_1 = \\mathbf{c}_\\mathrm{A} + (L/2) \\mathbf{u}_\\mathrm{A}'$ 表示球棍体的轴向线段，其中 $\\mathbf{u}_\\mathrm{A}'$ 是通过将 $\\mathbf{u}_\\mathrm{A}$ 绕 $\\mathbf{k}$ 旋转 $\\theta$ 得到的。\n- 对另一个球棍体，计算端点 $\\mathbf{b}_0 = \\mathbf{c}_\\mathrm{B} - (L/2) \\mathbf{u}_\\mathrm{B}$ 和 $\\mathbf{b}_1 = \\mathbf{c}_\\mathrm{B} + (L/2) \\mathbf{u}_\\mathrm{B}$。\n- 使用上述带约束的线段间最近接近方法计算 $\\delta$。\n- 当且仅当 $\\delta \\ge 2r$ 时接受移动。由于浮点运算的存在，实际实现中使用一个小的容差 $\\varepsilon$，并在 $\\delta + \\varepsilon \\ge 2r$ 时接受，以避免在相切时发生伪拒绝。\n\n该测试套件探讨了：\n- 旋转后大距离分离的正常路径，确认接受（$\\mathrm{True}$）。\n- 旋转后线段共线，中心距离足够近以致产生内部重叠，确认拒绝（$\\mathrm{False}$）。\n- 最小距离恰好等于阈值 $2r$ 的边界情况，确认相切非重叠被接受（$\\mathrm{True}$）。\n- 异面线段，其最近点位于两线段内部，导致重叠和拒绝（$\\mathrm{False}$）。\n- 横向分离等于阈值的平行线段（接受，$\\mathrm{True}$）和低于阈值的平行线段（拒绝，$\\mathrm{False}$）。\n\n最终程序使用 $r = 0.5$ $\\mathrm{nm}$ 和 $L = 4.0$ $\\mathrm{nm}$ 实例化这些场景，应用指定的旋转（角度以弧度为单位），为每种情况计算 $\\delta$，并打印出单行 $[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{False}]$ 样式且无空格的输出，反映每个测试用例的二元接受决策。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rodrigues_rotate(v: np.ndarray, k: np.ndarray, theta: float) -> np.ndarray:\n    \"\"\"\n    Rotate vector v about axis k (unit vector) by angle theta (radians)\n    using the Rodrigues rotation formula.\n    \"\"\"\n    k = np.asarray(k, dtype=float)\n    v = np.asarray(v, dtype=float)\n    knorm = np.linalg.norm(k)\n    if knorm == 0.0:\n        # No rotation if axis is zero; return original vector\n        return v.copy()\n    k = k / knorm\n    ct = np.cos(theta)\n    st = np.sin(theta)\n    return v * ct + np.cross(k, v) * st + k * np.dot(k, v) * (1.0 - ct)\n\ndef segment_distance(a0: np.ndarray, a1: np.ndarray, b0: np.ndarray, b1: np.ndarray) -> float:\n    \"\"\"\n    Compute the minimal distance between two segments [a0,a1] and [b0,b1] in R^3.\n    Robust handling of parallel and degenerate (zero-length) segments.\n    Implementation follows case distinctions similar to those in\n    \"Real-Time Collision Detection\" by Christer Ericson.\n    \"\"\"\n    a0 = np.asarray(a0, dtype=float)\n    a1 = np.asarray(a1, dtype=float)\n    b0 = np.asarray(b0, dtype=float)\n    b1 = np.asarray(b1, dtype=float)\n\n    u = a1 - a0\n    v = b1 - b0\n    w0 = a0 - b0\n\n    A = np.dot(u, u)\n    B = np.dot(u, v)\n    C = np.dot(v, v)\n    D = np.dot(u, w0)\n    E = np.dot(v, w0)\n    SMALL = 1e-12\n\n    sN = 0.0\n    tN = 0.0\n    sD = A\n    tD = C\n    denom = A * C - B * B\n\n    # Handle degenerate segments\n    if A = SMALL and C = SMALL:\n        # Both segments are points\n        return float(np.linalg.norm(a0 - b0))\n    if A = SMALL:\n        # First segment is a point; project onto second\n        sN = 0.0\n        sD = 1.0\n        tN = E\n        tD = C\n    elif C = SMALL:\n        # Second segment is a point; project onto first\n        tN = 0.0\n        tD = 1.0\n        sN = -D\n        sD = A\n    else:\n        # General case\n        if denom != 0.0:\n            sN = (B * E - C * D)\n            tN = (A * E - B * D)\n            sD = denom\n            tD = denom\n        else:\n            # Parallel segments: choose s to minimize distance to b0\n            sN = 0.0  # arbitrary\n            sD = 1.0\n            tN = E\n            tD = C\n\n    # Clamp s to [0,1]\n    s = sN / sD if sD > SMALL else 0.0\n    if s  0.0:\n        s = 0.0\n        tN = E\n        tD = C\n    elif s > 1.0:\n        s = 1.0\n        tN = E + B\n        tD = C\n\n    # Clamp t to [0,1]\n    t = tN / tD if tD > SMALL else 0.0\n    if t  0.0:\n        t = 0.0\n        # Recompute s for t=0\n        sN = -D\n        sD = A\n        s = sN / sD if sD > SMALL else 0.0\n        s = min(max(s, 0.0), 1.0)\n    elif t > 1.0:\n        t = 1.0\n        # Recompute s for t=1\n        sN = B - D\n        sD = A\n        s = sN / sD if sD > SMALL else 0.0\n        s = min(max(s, 0.0), 1.0)\n\n    # Compute closest points\n    pa = a0 + s * u\n    pb = b0 + t * v\n    return float(np.linalg.norm(pa - pb))\n\ndef spherocylinder_endpoints(center: np.ndarray, orientation: np.ndarray, length: float):\n    \"\"\"\n    Given center, unit orientation, and axial length, return segment endpoints.\n    \"\"\"\n    u = np.asarray(orientation, dtype=float)\n    nu = np.linalg.norm(u)\n    if nu == 0.0:\n        raise ValueError(\"Orientation vector must be non-zero.\")\n    u = u / nu\n    half = 0.5 * float(length)\n    a0 = np.asarray(center, dtype=float) - half * u\n    a1 = np.asarray(center, dtype=float) + half * u\n    return a0, a1\n\ndef rotational_move_acceptance(cA, uA, L, r, axis, angle, others):\n    \"\"\"\n    Perform rotational move on spherocylinder A and test overlap against others.\n    cA: center of A (3,)\n    uA: initial orientation of A (3,)\n    L: length\n    r: radius\n    axis: rotation axis (3,)\n    angle: rotation angle in radians\n    others: list of tuples [(cB, uB), ...]\n    Return: True if accepted (no overlaps), False otherwise.\n    \"\"\"\n    uA_rot = rodrigues_rotate(np.asarray(uA, dtype=float), np.asarray(axis, dtype=float), float(angle))\n    a0, a1 = spherocylinder_endpoints(cA, uA_rot, L)\n    threshold = 2.0 * float(r)\n    eps = 1e-12\n    for (cB, uB) in others:\n        b0, b1 = spherocylinder_endpoints(cB, uB, L)\n        d = segment_distance(a0, a1, b0, b1)\n        if d + eps  threshold:\n            return False\n    return True\n\ndef solve():\n    # Fixed parameters\n    L = 4.0  # nm\n    r = 0.5  # nm\n    cA = np.array([0.0, 0.0, 0.0], dtype=float)\n    uA = np.array([1.0, 0.0, 0.0], dtype=float)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Far separation after rotation (should accept)\n        {\n            \"axis\": (0.0, 0.0, 1.0),\n            \"angle\": np.pi / 2.0,\n            \"others\": [ (np.array([0.0, 10.0, 0.0], dtype=float), np.array([0.0, 1.0, 0.0], dtype=float)) ]\n        },\n        # Case 2: Overlap after rotation (should reject)\n        {\n            \"axis\": (0.0, 0.0, 1.0),\n            \"angle\": np.pi / 2.0,\n            \"others\": [ (np.array([0.0, 1.2, 0.0], dtype=float), np.array([0.0, 1.0, 0.0], dtype=float)) ]\n        },\n        # Case 3: Boundary tangency equals threshold (should accept)\n        {\n            \"axis\": (0.0, 0.0, 1.0),\n            \"angle\": np.pi / 2.0,\n            \"others\": [ (np.array([0.0, 5.0, 0.0], dtype=float), np.array([0.0, 1.0, 0.0], dtype=float)) ]\n        },\n        # Case 4: Skew segments interior closest points (should reject)\n        {\n            \"axis\": (0.0, 1.0, 0.0),\n            \"angle\": np.pi / 4.0,\n            \"others\": [ (np.array([0.0, 0.0, 1.0], dtype=float), np.array([1.0, 0.0, 0.0], dtype=float)) ]\n        },\n        # Case 5: Parallel segments, separation equals threshold (should accept)\n        {\n            \"axis\": (0.0, 0.0, 1.0),\n            \"angle\": 0.0,\n            \"others\": [ (np.array([0.0, 1.0, 0.0], dtype=float), np.array([1.0, 0.0, 0.0], dtype=float)) ]\n        },\n        # Case 6: Parallel segments, separation below threshold (should reject)\n        {\n            \"axis\": (0.0, 0.0, 1.0),\n            \"angle\": 0.0,\n            \"others\": [ (np.array([0.0, 0.6, 0.0], dtype=float), np.array([1.0, 0.0, 0.0], dtype=float)) ]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        axis = case[\"axis\"]\n        angle = case[\"angle\"]\n        others = case[\"others\"]\n        result = rotational_move_acceptance(cA, uA, L, r, axis, angle, others)\n        results.append(result)\n\n    # Final print statement in the exact required format: no spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3467426"}, {"introduction": "在前述练习的基础上，我们将模拟置于一个周期性边界条件（Periodic Boundary Conditions, PBC）的盒子中，这是模拟块状材料的标准设置。然而，PBC的引入会带来一些微妙的复杂性，特别是对于可能跨越边界的刚性体。本练习 [@problem_id:3467366] 旨在解决一个关键的技术任务：在使用最小镜像约定（minimum image convention）的前提下，正确地实现刚体的旋转等操作。通过对比正确实现与一种常见但幼稚的错误实现，本练习将揭示后者可能导致的能量计算和接受率的严重偏差。", "problem": "要求您实现一个独立的程序，用于在一个三维周期性模拟盒子中为刚体执行蒙特卡洛 (MC) 移动提议，其中需注意考虑最小镜像的旋转和包裹，并量化周期性如何改变与取向相关的能量和接受概率。该系统包含一个或多个刚性二聚体（双位点刚体），它们被周期性边界条件 (PBC) 约束在一个边长为 $L$ 的立方盒子中。移动集包括平移、旋转和粒子类型交换移动。能量是取向依赖的，并与一个空间周期性的外场线性耦合，这使得最小镜像约定在边界附近至关重要。\n\n该问题的基础是正则系综。在正则系综中，一个能量为 $E$ 的微观态的概率密度与 $\\exp(-\\beta E)$ 成正比，其中 $\\beta$ 是逆热能 $1/(k_{\\mathrm{B}} T)$。对于一个将能量从 $E_{\\mathrm{old}}$ 改变为 $E_{\\mathrm{new}}$ 的提议移动，其 Metropolis 接受准则为 $p_{\\mathrm{acc}} = \\min \\{ 1, \\exp(-\\beta (E_{\\mathrm{new}} - E_{\\mathrm{old}})) \\}$。对于刚体旋转，体固定坐标系下的位移通过一个由轴-角参数化导出的特殊正交矩阵进行旋转，然后使用 PBC 将位置包裹回盒子中。在 PBC 下，使用最小镜像约定来计算取向向量：对于位移 $\\Delta \\mathbf{r} = \\mathbf{r}_2 - \\mathbf{r}_1$，最小镜像位移是逐分量计算的 $\\Delta \\mathbf{r}_{\\mathrm{MI}} = \\Delta \\mathbf{r} - L \\,\\mathrm{round}(\\Delta \\mathbf{r} / L)$，取向向量是 $\\mathbf{n} = \\Delta \\mathbf{r}_{\\mathrm{MI}} / \\|\\Delta \\mathbf{r}_{\\mathrm{MI}}\\|$。包裹位置的操作为逐分量应用 $\\mathbf{r} \\mapsto \\mathbf{r} \\bmod L$。\n\n定义单个粒子类型耦合强度为 $\\varepsilon$ 的二聚体的能量为 $E = - \\varepsilon \\sum_{i=1}^{2} \\mathbf{n} \\cdot \\hat{\\mathbf{e}}(\\mathbf{r}_i)$，其中 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$ 是位点位置，$\\mathbf{n}$ 是使用最小镜像约定计算的二聚体取向，$\\hat{\\mathbf{e}}(\\mathbf{r})$ 是一个空间周期性外场的单位向量，该外场由 $\\mathbf{e}(\\mathbf{r}) = [\\cos(2 \\pi x / L), \\cos(2 \\pi y / L), \\cos(2 \\pi z / L)]$ 定义，且当 $\\|\\mathbf{e}(\\mathbf{r})\\| \\neq 0$ 时 $\\hat{\\mathbf{e}}(\\mathbf{r}) = \\mathbf{e}(\\mathbf{r}) / \\|\\mathbf{e}(\\mathbf{r})\\|$，否则 $\\hat{\\mathbf{e}}(\\mathbf{r}) = \\mathbf{0}$。该能量（在 $\\mathbf{n}$ 上是线性的）破坏了头尾对称性，使得在边界附近正确计算取向至关重要。对于一个由多个二聚体组成的系统，总能量是所有二聚体能量的总和。对于粒子类型交换移动，位置保持固定，而两个二聚体之间的粒子类型耦合参数 $\\varepsilon$ 被交换。\n\n实现两种能量和接受概率的评估方法：一种是使用最小镜像取向的正确方法，另一种是错误地直接使用包裹后位置之差 $\\Delta \\mathbf{r}_{\\mathrm{naive}} = (\\mathbf{r}_2 \\bmod L) - (\\mathbf{r}_1 \\bmod L)$ 并进行归一化的朴素方法。计算 $p_{\\mathrm{acc}}^{\\mathrm{correct}}$ 和 $p_{\\mathrm{acc}}^{\\mathrm{naive}} = \\min \\{ 1, \\exp(-\\beta (E_{\\mathrm{new,naive}} - E_{\\mathrm{old,naive}})) \\}$，以展示周期性如何影响取向依赖的能量和接受概率。\n\n角度单位必须是弧度。所有能量都是无量纲的，并以任意一致的单位进行度量。程序必须实现：\n- 平移移动：对选定的一个二聚体的两个位点 $i=1,2$ 进行 $\\mathbf{r}_i \\mapsto \\mathbf{r}_i + \\Delta \\mathbf{t}$ 操作，然后进行包裹。\n- 旋转移动：计算二聚体中心为 $\\mathbf{r}_{\\mathrm{c}} = \\mathbf{r}_1 + \\tfrac{1}{2} \\Delta \\mathbf{r}_{\\mathrm{MI}}$，计算体坐标系位移 $\\mathbf{d}_1 = -\\tfrac{1}{2} \\mathbf{n} a$ 和 $\\mathbf{d}_2 = +\\tfrac{1}{2} \\mathbf{n} a$（其中 $a = \\|\\Delta \\mathbf{r}_{\\mathrm{MI}}\\|$ 是键长），通过轴-角旋转矩阵旋转 $\\mathbf{d}_1, \\mathbf{d}_2$，将位点放置在 $\\mathbf{r}_{\\mathrm{c}} + \\mathbf{d}_1^{\\prime}$ 和 $\\mathbf{r}_{\\mathrm{c}} + \\mathbf{d}_2^{\\prime}$，然后进行包裹。\n- 交换移动：在不改变位置的情况下，交换两个二聚体之间的 $\\varepsilon$ 值。\n\n测试套件和最终输出规范：\n实现以下四个测试用例。对于每个用例，计算并返回一个包含 $p_{\\mathrm{acc}}^{\\mathrm{correct}}$ 和 $p_{\\mathrm{acc}}^{\\mathrm{naive}}$（浮点数）的列表。\n\n1. 边界附近的旋转（边界敏感情况）：盒子中有一个二聚体，参数为 $L = 10.0$，键长 $a = 4.0$，逆温度 $\\beta = 2.0$，粒子类型耦合 $\\varepsilon = 1.0$，初始中心位于 $(9.2, 5.0, 5.0)$，初始取向沿 $+\\hat{\\mathbf{x}}$ 方向（因此位点位置为 $(7.2, 5.0, 5.0)$ 和 $(11.2, 5.0, 5.0)$，后者包裹后为 $(1.2, 5.0, 5.0)$），提议的旋转是绕轴 $(0, 0, 1)$ 旋转 $0.9$ 弧度。\n\n2. 远离边界的旋转（理想情况）：一个二聚体，参数为 $L = 10.0$，$a = 4.0$，$\\beta = 2.0$，$\\varepsilon = 1.0$，初始中心位于 $(5.0, 5.0, 5.0)$，初始取向沿 $+\\hat{\\mathbf{x}}$ 方向（位点为 $(3.0, 5.0, 5.0)$ 和 $(7.0, 5.0, 5.0)$），提议的旋转是绕轴 $(0, 0, 1)$ 旋转 $0.9$ 弧度。\n\n3. 边界附近的平移（包裹引起的取向模糊性）：一个二聚体，参数为 $L = 10.0$，$a = 4.0$，$\\beta = 2.0$，$\\varepsilon = 1.0$，初始中心位于 $(9.8, 5.0, 5.0)$，初始取向沿 $+\\hat{\\mathbf{x}}$ 方向（位点为 $(7.8, 5.0, 5.0)$ 和 $(11.8, 5.0, 5.0)$，后者包裹后为 $(1.8, 5.0, 5.0)$），提议的平移向量为 $(0.6, 0.0, 0.0)$。\n\n4. 粒子类型交换（涉及两个二聚体的交换移动，其中一个靠近边界）：盒子中有两个二聚体，参数为 $L = 10.0$，$a = 4.0$，$\\beta = 1.5$，初始粒子类型耦合为 $\\varepsilon_{\\mathrm{A}} = 1.2$ 和 $\\varepsilon_{\\mathrm{B}} = 0.6$。二聚体 A：中心位于 $(9.2, 5.0, 5.0)$，取向沿 $+\\hat{\\mathbf{x}}$ 方向（位点为 $(7.2, 5.0, 5.0)$ 和 $(11.2, 5.0, 5.0)$，后者包裹后为 $(1.2, 5.0, 5.0)$）。二聚体 B：中心位于 $(2.0, 5.0, 5.0)$，取向沿 $+\\hat{\\mathbf{y}}$ 方向（位点为 $(2.0, 3.0, 5.0)$ 和 $(2.0, 7.0, 5.0)$）。提议的移动是交换两个二聚体之间的粒子类型耦合。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。此列表的每个元素对应一个测试用例，并且本身必须是一个包含 $p_{\\mathrm{acc}}^{\\mathrm{correct}}$ 和 $p_{\\mathrm{acc}}^{\\mathrm{naive}}$ 的双元素列表。例如，最终格式必须与此完全一样：[[p1_correct,p1_naive],[p2_correct,p2_naive],[p3_correct,p3_naive],[p4_correct,p4_naive]]。", "solution": "用户提供了一个来自计算材料科学领域的问题，具体聚焦于在周期性边界条件 (PBC) 下刚体的蒙特卡洛 (MC) 移动集的实现和验证。\n\n### 问题验证\n\n**步骤 1：提取给定条件**\n\n- **系综与接受准则**：正则系综，其概率密度为 $p(E) \\propto \\exp(-\\beta E)$，Metropolis 接受概率为 $p_{\\mathrm{acc}} = \\min \\{ 1, \\exp(-\\beta \\Delta E) \\}$。\n- **系统**：在边长为 $L$ 的三维立方盒子中的刚性二聚体。\n- **PBC 与 MIC**：位置包裹为 $\\mathbf{r} \\mapsto \\mathbf{r} \\bmod L$。对于位移 $\\Delta \\mathbf{r} = \\mathbf{r}_2 - \\mathbf{r}_1$，最小镜像位移为 $\\Delta \\mathbf{r}_{\\mathrm{MI}} = \\Delta \\mathbf{r} - L \\,\\mathrm{round}(\\Delta \\mathbf{r} / L)$。\n- **取向向量**：\n    - 正确方法：$\\mathbf{n}_{\\mathrm{correct}} = \\Delta \\mathbf{r}_{\\mathrm{MI}} / \\|\\Delta \\mathbf{r}_{\\mathrm{MI}}\\|$。\n    - 朴素方法：$\\mathbf{n}_{\\mathrm{naive}} = \\Delta \\mathbf{r}_{\\mathrm{naive}} / \\|\\Delta \\mathbf{r}_{\\mathrm{naive}}|$, 其中 $\\Delta \\mathbf{r}_{\\mathrm{naive}} = (\\mathbf{r}_2 \\bmod L) - (\\mathbf{r}_1 \\bmod L)$。\n- **能量函数**：一个二聚体的能量为 $E = - \\varepsilon \\sum_{i=1}^{2} \\mathbf{n} \\cdot \\hat{\\mathbf{e}}(\\mathbf{r}_i)$，其中 $\\mathbf{r}_i$ 是位点位置（在包裹后进行评估），$\\varepsilon$ 是特定于粒子类型的耦合强度，$\\hat{\\mathbf{e}}(\\mathbf{r})$ 是一个周期性外场。\n- **外场**：$\\mathbf{e}(\\mathbf{r}) = [\\cos(2 \\pi x / L), \\cos(2 \\pi y / L), \\cos(2 \\pi z / L)]$，其单位向量为 $\\hat{\\mathbf{e}}(\\mathbf{r}) = \\mathbf{e}(\\mathbf{r}) / \\|\\mathbf{e}(\\mathbf{r})\\|$（如果范数为零，则为 $\\mathbf{0}$）。\n- **MC 移动**：\n    - 平移：对 $i=1,2$ 进行 $\\mathbf{r}_i \\mapsto \\mathbf{r}_i + \\Delta \\mathbf{t}$，然后进行包裹。\n    - 旋转：二聚体围绕其中心 $\\mathbf{r}_{\\mathrm{c}} = \\mathbf{r}_1 + \\tfrac{1}{2} \\Delta \\mathbf{r}_{\\mathrm{MI}}$ 的刚性旋转。\n    - 交换：交换两个二聚体之间的 $\\varepsilon$ 值。\n- **测试用例**：提供了四个具体场景，测试旋转（靠近和远离边界）、平移和粒子类型交换，并明确定义了所有必要参数（$L$、$a$、$\\beta$、$\\varepsilon$、初始位置、取向和移动参数）。\n\n**步骤 2：使用提取的给定条件进行验证**\n\n- **科学依据**：该问题基于统计力学和计算物理的既定原理。MC 方法、PBC、MIC 和刚体动力学都是标准的，并且描述正确。\n- **良定性**：所有定义、参数和初始条件都已提供，使得问题明确且可解。“正确”方法和“朴素”方法之间的区别在模拟实践中是一个明确定义且重要的概念。\n- **客观性**：该问题以精确、定量的术语陈述，没有任何主观性。\n\n**步骤 3：结论与行动**\n\n该问题具有科学合理性、良定性和客观性。它包含了获得唯一解所需的所有信息。因此，该问题是**有效的**。将开发一个完整的解决方案。\n\n### 求解设计与原理\n\n该解决方案涉及实现一个模拟框架，用于计算三种蒙特卡洛移动的能量变化，并由此计算接受概率。问题的核心在于在周期性边界条件 (PBC) 下正确处理粒子坐标和相互作用。\n\n**1. 周期性边界条件与最小镜像约定 (MIC)**\n\n在一个边长为 $L$ 的模拟盒子中，PBC 意味着系统在所有方向上被无限复制。当一个粒子从一个面离开盒子时，它会从对面重新进入。这通过包裹坐标来处理，$\\mathbf{r}_{\\text{wrapped}} = \\mathbf{r} \\bmod L$。\n\n在计算两个粒子之间的相互作用时，我们必须考虑它们最近的周期性镜像之间的相互作用。这通过最小镜像约定 (MIC) 实现。首先计算位于（未包裹）位置 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$ 的粒子之间的位移向量 $\\Delta \\mathbf{r} = \\mathbf{r}_2 - \\mathbf{r}_1$。然后通过确保向量的每个分量在量级上小于 $L/2$ 来找到 MIC 位移：\n$$ \\Delta \\mathbf{r}_{\\mathrm{MI}} = \\Delta \\mathbf{r} - L \\cdot \\mathrm{round}(\\Delta \\mathbf{r} / L) $$\n此计算正确地找到了跨越周期性边界连接粒子（或其镜像）的最短向量。对于可能跨越边界的刚体（如二聚体），其取向必须使用 $\\Delta \\mathbf{r}_{\\mathrm{MI}}$ 来计算。\n\n**2. 朴素取向与正确取向**\n\n该问题着重指出了一个常见的实现错误。\n- **正确取向**：取向向量 $\\mathbf{n}$ 源自 MIC 位移：$\\mathbf{n}_{\\mathrm{correct}} = \\Delta \\mathbf{r}_{\\mathrm{MI}} / \\|\\Delta \\mathbf{r}_{\\mathrm{MI}}\\|$。这反映了刚性键的真实物理取向。\n- **朴素取向**：一种朴素的方法可能只是简单地取包裹后粒子位置的差：$\\Delta \\mathbf{r}_{\\mathrm{naive}} = (\\mathbf{r}_2 \\bmod L) - (\\mathbf{r}_1 \\bmod L)$。如果二聚体跨越边界，该向量将不代表短键，而是代表一个横跨整个模拟盒子的长向量。这会导致物理上不正确的取向向量 $\\mathbf{n}_{\\mathrm{naive}}$，并因此导致错误的能量计算。\n\n**3. 能量计算**\n\n一个二聚体的能量由 $E = - \\varepsilon \\sum_{i=1}^{2} \\mathbf{n} \\cdot \\hat{\\mathbf{e}}(\\mathbf{r}_i)$ 给出。计算过程如下：\n- 使用正确或朴素方法计算取向向量 $\\mathbf{n}$。\n- 由于外场本身是周期性的，因此在两个位点的*包裹后*位置 $\\mathbf{r}_1^{\\mathrm{w}}$ 和 $\\mathbf{r}_2^{\\mathrm{w}}$ 处评估外场 $\\hat{\\mathbf{e}}(\\mathbf{r})$。\n- 计算点积并求和，然后乘以 $-\\varepsilon$。\n\n**4. 蒙特卡洛移动**\n\n为保持物理一致性，所有移动（平移和旋转）都应用于“未包裹”的粒子坐标。移动后，使用新位置计算能量，并确定接受概率。对于这个问题，我们将维护每个二聚体的未包裹坐标。\n\n- **平移**：二聚体的两个位点都通过向量 $\\Delta \\mathbf{t}$ 进行位移：$\\mathbf{r}_i' = \\mathbf{r}_i + \\Delta \\mathbf{t}$。取向向量 $\\mathbf{n}$ 保持不变，但由于位点在外场中的新位置，能量会发生变化。\n\n- **旋转**：围绕二聚体的质心进行旋转。为正确处理跨边界的二聚体，此中心定义为 $\\mathbf{r}_{\\mathrm{c}} = \\mathbf{r}_1 + \\frac{1}{2} \\Delta \\mathbf{r}_{\\mathrm{MI}}$，使用一个位点的未包裹位置和 MIC 位移。从中心到每个位点的体固定坐标系向量 $\\mathbf{d}_i$ 由一个旋转矩阵 $\\mathbf{R}$ 进行旋转。新的未包裹位置为 $\\mathbf{r}_i' = \\mathbf{r}_{\\mathrm{c}} + \\mathbf{R} \\mathbf{d}_i$。\n\n- **交换移动**：位置保持固定，但两个二聚体的粒子类型参数 $\\varepsilon$ 被交换。如果它们的取向和位置导致与场的相互作用能量不同，这将改变两个二聚体的能量。\n\n**5. 接受概率**\n\n对于任何提议的移动，都会计算能量变化 $\\Delta E = E_{\\mathrm{new}} - E_{\\mathrm{old}}$。该移动以概率 $p_{\\mathrm{acc}} = \\min \\{ 1, \\exp(-\\beta \\Delta E) \\}$ 被接受。此计算对正确和朴素的能量模型独立进行，以展示其差异。\n\n实现将遵循这些原则，并使用辅助函数进行包裹、MIC、场计算和能量评估，以确保清晰正确的程序结构。测试用例将按顺序处理，以生成最终所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\n\ndef solve():\n    \"\"\"\n    Solves the Monte Carlo move set problem for all test cases.\n    \"\"\"\n\n    def wrap_positions(positions, box_length):\n        \"\"\"Wraps a single or multiple position vectors into the periodic box.\"\"\"\n        return positions % box_length\n\n    def minimum_image_displacement(r1, r2, box_length):\n        \"\"\"Computes the minimum image displacement vector from r1 to r2.\"\"\"\n        # Assumes r1 and r2 are unwrapped coordinates\n        delta_r = r2 - r1\n        return delta_r - box_length * np.around(delta_r / box_length)\n\n    def field_vector(r_wrapped, box_length):\n        \"\"\"Computes the unit vector of the external field at a wrapped position.\"\"\"\n        if box_length == 0: return np.zeros(3)\n        e = np.cos(2 * np.pi * r_wrapped / box_length)\n        norm_e = np.linalg.norm(e)\n        if norm_e == 0:\n            return np.zeros(3)\n        return e / norm_e\n\n    def calculate_dimer_energy(r1, r2, eps, box_length, method):\n        \"\"\"\n        Calculates the energy of a single dimer.\n        r1, r2 are unwrapped positions.\n        method can be 'correct' or 'naive'.\n        \"\"\"\n        r1_w = wrap_positions(r1, box_length)\n        r2_w = wrap_positions(r2, box_length)\n\n        if method == 'correct':\n            delta_r_mic = minimum_image_displacement(r1, r2, box_length)\n            norm_delta_r = np.linalg.norm(delta_r_mic)\n            n_hat = delta_r_mic / norm_delta_r if norm_delta_r > 0 else np.zeros(3)\n        elif method == 'naive':\n            delta_r_naive = r2_w - r1_w\n            norm_delta_r = np.linalg.norm(delta_r_naive)\n            n_hat = delta_r_naive / norm_delta_r if norm_delta_r > 0 else np.zeros(3)\n        else:\n            raise ValueError(\"Method must be 'correct' or 'naive'\")\n\n        e_field1 = field_vector(r1_w, box_length)\n        e_field2 = field_vector(r2_w, box_length)\n        \n        energy = -eps * (np.dot(n_hat, e_field1) + np.dot(n_hat, e_field2))\n        return energy\n        \n    def calculate_total_energy(dimers, box_length, method):\n        \"\"\"Calculates total energy for a list of dimers.\"\"\"\n        total_e = 0.0\n        for dimer in dimers:\n            r1, r2, eps = dimer\n            total_e += calculate_dimer_energy(r1, r2, eps, box_length, method)\n        return total_e\n\n    def get_acc_prob(delta_e, beta):\n        \"\"\"Computes Metropolis acceptance probability.\"\"\"\n        if delta_e = 0:\n            return 1.0\n        return np.exp(-beta * delta_e)\n\n    # --- Test Cases ---\n\n    results = []\n\n    # Case 1: Rotation near boundary\n    def run_case_1():\n        L, a, beta, eps = 10.0, 4.0, 2.0, 1.0\n        # This setup gives r1=(7.2, 5, 5), r2=(11.2, 5, 5) from center\n        # However, the problem specifies r1, r2 from center and orientation. Let's stick to that.\n        r_c_init = np.array([9.2, 5.0, 5.0])\n        n_init = np.array([1.0, 0.0, 0.0])\n        r1_old = r_c_init - n_init * a / 2.0\n        r2_old = r_c_init + n_init * a / 2.0\n\n        dimers_old = [(r1_old, r2_old, eps)]\n        e_old_correct = calculate_total_energy(dimers_old, L, 'correct')\n        e_old_naive = calculate_total_energy(dimers_old, L, 'naive')\n\n        # Rotation move\n        rot_axis = np.array([0.0, 0.0, 1.0])\n        rot_angle = 0.9\n        rot_vec = rot_axis * rot_angle\n        rot = Rotation.from_rotvec(rot_vec)\n        \n        delta_r_mic = minimum_image_displacement(r1_old, r2_old, L)\n        r_c = r1_old + 0.5 * delta_r_mic\n        d1 = r1_old - r_c\n        d2 = r2_old - r_c\n        \n        r1_new = r_c + rot.apply(d1)\n        r2_new = r_c + rot.apply(d2)\n        \n        dimers_new = [(r1_new, r2_new, eps)]\n        e_new_correct = calculate_total_energy(dimers_new, L, 'correct')\n        e_new_naive = calculate_total_energy(dimers_new, L, 'naive')\n\n        p_acc_correct = get_acc_prob(e_new_correct - e_old_correct, beta)\n        p_acc_naive = get_acc_prob(e_new_naive - e_old_naive, beta)\n        \n        return [p_acc_correct, p_acc_naive]\n\n    results.append(run_case_1())\n\n    # Case 2: Rotation away from boundary\n    def run_case_2():\n        L, a, beta, eps = 10.0, 4.0, 2.0, 1.0\n        r_c_init = np.array([5.0, 5.0, 5.0])\n        n_init = np.array([1.0, 0.0, 0.0])\n        r1_old = r_c_init - n_init * a / 2.0\n        r2_old = r_c_init + n_init * a / 2.0\n\n        dimers_old = [(r1_old, r2_old, eps)]\n        e_old_correct = calculate_total_energy(dimers_old, L, 'correct')\n        e_old_naive = calculate_total_energy(dimers_old, L, 'naive')\n\n        rot_axis = np.array([0.0, 0.0, 1.0])\n        rot_angle = 0.9\n        rot = Rotation.from_rotvec(rot_axis * rot_angle)\n        \n        delta_r_mic = minimum_image_displacement(r1_old, r2_old, L)\n        r_c = r1_old + 0.5 * delta_r_mic\n        d1 = r1_old - r_c\n        d2 = r2_old - r_c\n        \n        r1_new = r_c + rot.apply(d1)\n        r2_new = r_c + rot.apply(d2)\n\n        dimers_new = [(r1_new, r2_new, eps)]\n        e_new_correct = calculate_total_energy(dimers_new, L, 'correct')\n        e_new_naive = calculate_total_energy(dimers_new, L, 'naive')\n\n        p_acc_correct = get_acc_prob(e_new_correct - e_old_correct, beta)\n        p_acc_naive = get_acc_prob(e_new_naive - e_old_naive, beta)\n        \n        return [p_acc_correct, p_acc_naive]\n\n    results.append(run_case_2())\n\n    # Case 3: Translation near boundary\n    def run_case_3():\n        L, a, beta, eps = 10.0, 4.0, 2.0, 1.0\n        r_c_init = np.array([9.8, 5.0, 5.0])\n        n_init = np.array([1.0, 0.0, 0.0])\n        r1_old = r_c_init - n_init * a / 2.0\n        r2_old = r_c_init + n_init * a / 2.0\n\n        dimers_old = [(r1_old, r2_old, eps)]\n        e_old_correct = calculate_total_energy(dimers_old, L, 'correct')\n        e_old_naive = calculate_total_energy(dimers_old, L, 'naive')\n        \n        # Translation move\n        trans_vec = np.array([0.6, 0.0, 0.0])\n        r1_new = r1_old + trans_vec\n        r2_new = r2_old + trans_vec\n\n        dimers_new = [(r1_new, r2_new, eps)]\n        e_new_correct = calculate_total_energy(dimers_new, L, 'correct')\n        e_new_naive = calculate_total_energy(dimers_new, L, 'naive')\n        \n        p_acc_correct = get_acc_prob(e_new_correct - e_old_correct, beta)\n        p_acc_naive = get_acc_prob(e_new_naive - e_old_naive, beta)\n        \n        return [p_acc_correct, p_acc_naive]\n\n    results.append(run_case_3())\n\n    # Case 4: Species swap\n    def run_case_4():\n        L, a, beta = 10.0, 4.0, 1.5\n        eps_A, eps_B = 1.2, 0.6\n        \n        # Dimer A\n        r_c_A = np.array([9.2, 5.0, 5.0])\n        n_A = np.array([1.0, 0.0, 0.0])\n        r1_A = r_c_A - n_A * a / 2.0\n        r2_A = r_c_A + n_A * a / 2.0\n        \n        # Dimer B\n        r_c_B = np.array([2.0, 5.0, 5.0])\n        n_B = np.array([0.0, 1.0, 0.0])\n        r1_B = r_c_B - n_B * a / 2.0\n        r2_B = r_c_B + n_B * a / 2.0\n\n        dimers_old = [(r1_A, r2_A, eps_A), (r1_B, r2_B, eps_B)]\n        e_old_correct = calculate_total_energy(dimers_old, L, 'correct')\n        e_old_naive = calculate_total_energy(dimers_old, L, 'naive')\n\n        # Swap move\n        dimers_new = [(r1_A, r2_A, eps_B), (r1_B, r2_B, eps_A)] # eps swapped\n        e_new_correct = calculate_total_energy(dimers_new, L, 'correct')\n        e_new_naive = calculate_total_energy(dimers_new, L, 'naive')\n        \n        p_acc_correct = get_acc_prob(e_new_correct - e_old_correct, beta)\n        p_acc_naive = get_acc_prob(e_new_naive - e_old_naive, beta)\n\n        return [p_acc_correct, p_acc_naive]\n        \n    results.append(run_case_4())\n    \n    # Format the final output string\n    result_str = \",\".join([str(res).replace(\" \", \"\") for res in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "3467366"}]}