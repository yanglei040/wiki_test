{"hands_on_practices": [{"introduction": "理解粒子网格埃瓦尔德（PME）方法的计算成本是高效利用高性能计算资源的关键。本练习将指导你从第一性原理出发，为并行PME计算构建一个性能模型。通过将总执行时间分解为与粒子数、网格大小和通信开销相关的项，你将学习如何量化算法的不同组成部分，并利用微基准数据校准模型，从而能够预测和优化大规模模拟的性能[@problem_id:3473535]。", "problem": "您的任务是为粒子网格埃瓦尔德（Particle Mesh Ewald, PME）方法推导、实现并校准一个参数化性能模型。该方法在分布式内存并行计算机上使用基于Pencil分解的三维快速傅里叶变换（FFT）。目标是从关于PME流程中算法工作量和通信的第一性原理出发，构建一个包含三个基项的模型，分别代表短程粒子操作、网格空间计算以及由全局转置引起的跨进程通信。然后，您必须使用提供的微基准测试测量值来估计未知的标量系数，并使用校准后的模型预测新参数集的执行时间。\n\n假设粒子网格埃瓦尔德（PME）具有以下科学基础：\n\n- 在固定的截断半径和插值阶数下，由于每个粒子的工作量恒定，短程和电荷分配操作的计算量与粒子数 $N$ 呈线性关系。这启发我们使用一个与 $N$ 成正比的基项。\n- 在线性尺寸为 $m$ 的立方网格上，三维快速傅里叶变换（FFT）执行大约 $\\mathcal{O}(m^3 \\log m)$ 次算术运算，这启发我们使用一个与 $m^3 \\log m$ 成正比的基项，其中 $\\log$ 表示自然对数。\n- 在 $P$ 个进程（MPI ranks）上进行Pencil分解时，需要两次全局转置。每次转置的通信伙伴数量增长趋势如同 $\\sqrt{P}$，而每个进程交换的总数据量与 $m^3/P$ 成正比。受此启发，定义一个无量纲的归一化通信函数\n$$\n\\mathrm{comm}(P,m) =\n\\begin{cases}\n0, & P = 1, \\\\\n2\\left(\\sqrt{P}-1 + \\dfrac{m^3}{P}\\right), & P > 1,\n\\end{cases}\n$$\n该函数将类延迟和类带宽的贡献捆绑成一个单一的无单位量，捕捉了在 $P$ 和 $m$ 上的主要尺度变化。此项作为一个通信基项，将通过一个未知的标量系数转换为秒。\n\n您的任务是：\n1. 基于上述基础，将总PME时间表示为对应于 $N$、$m^3 \\log m$ 和 $\\mathrm{comm}(P,m)$ 的三个基项的线性组合，其中有三个必须由数据确定的未知标量系数。\n2. 使用提供的微基准测试测量值和线性最小二乘法来拟合这些系数。\n3. 使用拟合后的模型，为给定的 $(N,m,P)$ 值测试套件预测执行时间。\n\n所有时间都必须以秒为单位表示。此问题不涉及角度。\n\n您将获得由元组 $(N,m,P,T_{\\mathrm{meas}})$ 组成的微基准测试测量值，其中 $T_{\\mathrm{meas}}$ 是测得的总墙上时钟时间（秒）：\n- $(200000, 64, 1, 0.114523)$\n- $(200000, 96, 1, 0.409523)$\n- $(500000, 64, 1, 0.122000)$\n- $(1000000, 128, 1, 1.044748)$\n- $(200000, 64, 16, 0.154130)$\n- $(500000, 96, 16, 0.550020)$\n- $(1000000, 128, 16, 1.358830)$\n- $(200000, 128, 64, 1.103410)$\n- $(1000000, 64, 64, 0.144448)$\n- $(500000, 128, 4, 2.291540)$\n- $(0, 96, 16, 0.537020)$\n- $(800000, 96, 4, 0.955767)$\n\n使用这些测量值校准模型系数，然后为以下参数值的测试套件生成预测：$(N,m,P)$:\n- $(700000, 96, 16)$\n- $(1000000, 128, 64)$\n- $(200000, 64, 1)$\n- $(500000, 128, 4)$\n- $(1000000, 64, 64)$\n\n您的程序应生成单行输出，其中包含上述五个测试用例的预测时间，形式为一个用方括号括起来的逗号分隔列表，每个数字四舍五入到六位小数，例如 $[t_1,t_2,t_3,t_4,t_5]$，其中每个 $t_i$ 的单位是秒。\n\n澄清和约束：\n- 使用自然对数作为 $\\log$。\n- 将 $N$ 和 $m$ 视为正整数，$P$ 视为表示并行进程数的正整数。\n- 通信基项 $\\mathrm{comm}(P,m)$ 在构造上是无量纲的，必须通过拟合的标量系数转换为秒。\n- 必须使用输入的微基准测试测量值通过线性最小二乘法进行拟合。\n- 对测试套件的运行时间预测必须以秒为单位，并四舍五入到六位小数。", "solution": "该问题要求构建和校准一个粒子网格埃瓦尔德（PME）方法的参数化性能模型。总执行时间 $T$ 被建模为代表不同计算核心的三个基函数的线性组合：基于粒子的工作、基于网格的工作和进程间通信。\n\n该模型由以下线性方程给出：\n$$\nT_{\\text{pred}}(N, m, P) = c_N f_N(N) + c_m f_m(m) + c_P f_P(P, m)\n$$\n其中 $N$ 是粒子数，$m$ 是FFT网格的线性尺寸，$P$ 是并行进程数。系数 $c_N$、$c_m$ 和 $c_P$ 是未知的标量常数，分别代表每个基函数单位工作的时耗。\n\n根据问题陈述，基函数定义如下：\n$1$. **粒子项**：短程相互作用和电荷分配的工作量与粒子数 $N$ 呈线性关系。因此，第一个基函数是 $f_N(N) = N$。\n$2$. **网格项**：在 $m \\times m \\times m$ 网格上进行三维快速傅里叶变换（FFT）的工作量与 $m^3 \\log m$ 成正比。因此，第二个基函数是 $f_m(m) = m^3 \\log m$，其中 $\\log$ 是自然对数。\n$3$. **通信项**：并行FFT的通信开销由提供的无量纲函数 $\\mathrm{comm}(P, m)$ 建模。因此，第三个基函数是 $f_P(P, m) = \\mathrm{comm}(P, m)$，定义为：\n$$\n\\mathrm{comm}(P,m) =\n\\begin{cases}\n0, & \\text{if } P = 1, \\\\\n2\\left(\\sqrt{P}-1 + \\dfrac{m^3}{P}\\right), & \\text{if } P > 1.\n\\end{cases}\n$$\n\n因此，完整的性能模型是：\n$$\nT_{\\text{pred}}(N, m, P) = c_N N + c_m (m^3 \\log m) + c_P \\mathrm{comm}(P, m)\n$$\n我们的目标是使用一组实验测量值来确定系数 $c_N$、$c_m$ 和 $c_P$。给定 $k=12$ 组微基准测试测量值，每组是一个元组 $(N_i, m_i, P_i, T_{\\text{meas},i})$，其中 $i=1, \\dots, 12$。对于每次测量，我们可以写出模型方程的一个实例：\n$$\nT_{\\text{meas},i} \\approx c_N N_i + c_m (m_i^3 \\log m_i) + c_P \\mathrm{comm}(P_i, m_i)\n$$\n这构成了一个线性方程组，可以表示为矩阵形式 $\\mathbf{y} \\approx \\mathbf{A}\\mathbf{c}$，其中：\n- $\\mathbf{y}$ 是一个 $12 \\times 1$ 的列向量，包含测量时间 $T_{\\text{meas},i}$。\n- $\\mathbf{c}$ 是我们寻求的 $3 \\times 1$ 的未知系数列向量：$\\mathbf{c} = [c_N, c_m, c_P]^T$。\n- $\\mathbf{A}$ 是 $12 \\times 3$ 的设计矩阵，其中第 $i$ 行由第 $i$ 次测量的基函数值组成：\n$$\n\\mathbf{A}_{i,:} = \\begin{bmatrix} N_i & m_i^3 \\log m_i & \\mathrm{comm}(P_i, m_i) \\end{bmatrix}\n$$\n由于我们的测量次数（$12$）多于未知系数的数量（$3$），该系统是超定的。$\\mathbf{c}$ 的最佳拟合解通过最小化残差平方和 $r_i = T_{\\text{meas},i} - T_{\\text{pred},i}$ 来找到。这是一个标准的线性最小二乘问题。最小化残差向量欧几里得范数 $\\|\\mathbf{y} - \\mathbf{A}\\mathbf{c}\\|_2$ 的解 $\\mathbf{c}$ 由正规方程的解给出：\n$$\n\\mathbf{A}^T \\mathbf{A} \\mathbf{c} = \\mathbf{A}^T \\mathbf{y}\n$$\n假设 $\\mathbf{A}^T \\mathbf{A}$ 可逆，解为 $\\mathbf{c} = (\\mathbf{A}^T \\mathbf{A})^{-1} \\mathbf{A}^T \\mathbf{y}$。在计算上，这可以通过QR分解等方法高效且稳健地求解，例如在NumPy等库中已实现。\n\n步骤如下：\n$1$. 从提供的微基准测试数据构建 $12 \\times 3$ 的设计矩阵 $\\mathbf{A}$ 和 $12 \\times 1$ 的测量向量 $\\mathbf{y}$。\n$2$. 求解线性最小二乘系统 $\\mathbf{A}\\mathbf{c} \\approx \\mathbf{y}$，得到系数向量 $\\mathbf{c} = [c_N, c_m, c_P]^T$。\n$3$. 有了校准后的系数，性能模型就完全确定了。\n$4$. 对于测试套件中的 $5$ 个参数集中的每一个 $(N_j, m_j, P_j)$，计算一个预测向量 $\\mathbf{a}_j = [N_j, m_j^3 \\log m_j, \\mathrm{comm}(P_j, m_j)]$。\n$5$. 预测时间是点积 $T_{\\text{pred}, j} = \\mathbf{a}_j \\cdot \\mathbf{c}$。然后收集这些预测值并格式化为最终结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, calibrates, and applies a parametric performance model for PME.\n    \n    The model is T_pred = c_N*N + c_m*(m^3*log(m)) + c_P*comm(P,m).\n    The coefficients [c_N, c_m, c_P] are found by a linear least squares fit\n    to the provided microbenchmark data. The calibrated model is then used to\n    predict execution times for a new set of test cases.\n    \"\"\"\n    \n    # Define the custom communication basis function.\n    def comm_func(P, m):\n        \"\"\"\n        Calculates the dimensionless communication cost.\n        \"\"\"\n        if P == 1:\n            return 0.0\n        # The problem statement defines P as a positive integer.\n        # So P > 1 is the only other case.\n        return 2.0 * (np.sqrt(P) - 1.0 + float(m**3) / P)\n\n    # Microbenchmark measurements: (N, m, P, T_meas)\n    benchmarks = [\n        (200000, 64, 1, 0.114523),\n        (200000, 96, 1, 0.409523),\n        (500000, 64, 1, 0.122000),\n        (1000000, 128, 1, 1.044748),\n        (200000, 64, 16, 0.154130),\n        (500000, 96, 16, 0.550020),\n        (1000000, 128, 16, 1.358830),\n        (200000, 128, 64, 1.103410),\n        (1000000, 64, 64, 0.144448),\n        (500000, 128, 4, 2.291540),\n        (0, 96, 16, 0.537020),\n        (800000, 96, 4, 0.955767),\n    ]\n\n    num_benchmarks = len(benchmarks)\n    # The model has 3 basis functions, so the design matrix has 3 columns.\n    num_coeffs = 3\n    \n    # A is the design matrix, y is the vector of measured times.\n    A = np.zeros((num_benchmarks, num_coeffs))\n    y = np.zeros(num_benchmarks)\n\n    for i, (N, m, P, T_meas) in enumerate(benchmarks):\n        # Basis function 1: N\n        f_N = float(N)\n        # Basis function 2: m^3 * log(m)\n        f_m = float(m**3) * np.log(m) if m > 0 else 0.0\n        # Basis function 3: comm(P, m)\n        f_P = comm_func(P, m)\n        \n        A[i, :] = [f_N, f_m, f_P]\n        y[i] = T_meas\n\n    # Solve the linear least squares problem A*c = y for coefficients c.\n    coeffs, residuals, rank, s = np.linalg.lstsq(A, y, rcond=None)\n    c_N, c_m, c_P = coeffs\n\n    # Test suite for predictions: (N, m, P)\n    test_cases = [\n        (700000, 96, 16),\n        (1000000, 128, 64),\n        (200000, 64, 1),\n        (500000, 128, 4),\n        (1000000, 64, 64),\n    ]\n\n    predictions = []\n    for N_test, m_test, P_test in test_cases:\n        # Construct the feature vector for the test case.\n        f_N_test = float(N_test)\n        f_m_test = float(m_test**3) * np.log(m_test) if m_test > 0 else 0.0\n        f_P_test = comm_func(P_test, m_test)\n        \n        feature_vector = np.array([f_N_test, f_m_test, f_P_test])\n        \n        # Predict the time using the calibrated model.\n        T_pred = np.dot(feature_vector, coeffs)\n        predictions.append(T_pred)\n\n    # Format the final output string as specified.\n    # Each number must be rounded to six decimal places.\n    # Using \"{:.6f}\".format() handles this requirement correctly.\n    formatted_results = [f\"{t:.6f}\" for t in predictions]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3473535"}, {"introduction": "埃瓦尔德方法的核心在于通过引入筛选参数 $\\alpha$ 来实现实空间和倒易空间计算的平衡。这个参数的选择直接影响计算的准确性和效率。本练习将带你深入探究力的计算对 $\\alpha$ 的敏感性，通过推导力对 $\\alpha$ 的解析导数，并设计一种自适应策略来动态优化此参数，从而加深对PME方法物理基础的理解[@problem_id:3473558]。", "problem": "给定一个边长为 $L$、体积为 $V = L^3$ 的三维周期性模拟单元，以及一组 $M$ 个点电荷，其电荷量为 $\\{q_i\\}_{i=1}^M$，位置为 $\\{\\mathbf{r}_i\\}_{i=1}^M$，所有单位均为约化无量纲单位。考虑使用高斯屏蔽参数 $\\alpha > 0$ 的静电场 Ewald 分解的倒易空间部分。设倒易格矢为 $\\mathbf{k} = \\frac{2\\pi}{L} \\mathbf{n}$，其中 $\\mathbf{n} \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$ 为整数三元组。傅里叶空间电荷密度记为 $\\rho(\\mathbf{k})$，并假设其满足 $\\rho(-\\mathbf{k}) = \\rho(\\mathbf{k})$，以确保场为实数。假设由模式振幅 $\\rho(\\mathbf{k})$ 产生的、在位置 $\\mathbf{r}$ 处的倒易空间电场由标准的 Ewald 屏蔽傅里叶表示给出，该表示对截断的模式集合 $\\{\\mathbf{k} : 0 < \\lVert \\mathbf{k} \\rVert \\le k_c\\}$ 进行求和，其中 $k_c > 0$ 是一个倒易空间截断值。粒子所受的力为 $\\mathbf{F}_i = q_i \\mathbf{E}(\\mathbf{r}_i)$。\n\n从这些定义以及 Ewald 分裂为每个倒易模式引入一个高斯因子 $\\exp\\!\\left(-\\lVert \\mathbf{k} \\rVert^2 / (4 \\alpha^2)\\right)$ 的核心原理出发，完成以下任务：\n\n1. 从第一性原理出发，推导倒易空间电场 $\\mathbf{E}(\\mathbf{r})$ 的表达式，然后推导力相对于屏蔽参数的灵敏度 $\\partial \\mathbf{F}_i / \\partial \\alpha$，并用 $\\rho(\\mathbf{k})$、$\\alpha$ 和 $\\mathbf{k} \\cdot \\mathbf{r}_i$ 的三角函数表示。您的推导必须从屏蔽势的傅里叶表示开始，通过求空间梯度和对 $\\alpha$ 求导来进行。\n\n2. 提出一种基于 $\\rho(\\mathbf{k})$ 瞬时谱来选择 $\\alpha(t)$ 的自适应策略。您的策略必须平衡实空间截断误差和倒易空间截断误差的模型。使用一个离散标量目标函数 $J(\\alpha)$，该函数随任一截断误差的增加而增加，并指明如何选择使 $J(\\alpha)$ 最小化的 $\\alpha$。\n\n3. 实现一个程序，该程序：\n   - 构建一个边长 $L = 6.0$、体积 $V = L^3$ 的立方盒子。\n   - 使用倒易格矢 $\\mathbf{k} = \\frac{2\\pi}{L} \\mathbf{n}$，其中整数分量 $n_x, n_y, n_z$ 在范围 $-N_{\\text{outer}} \\le n_\\mu \\le N_{\\text{outer}}$ 内，并排除 $\\mathbf{n} = \\mathbf{0}$，其中 $N_{\\text{outer}} = 6$。通过 $N_c = 3$ 定义倒易截断值，使得 $k_c = \\frac{2\\pi}{L} N_c$，并定义外部评估极限 $k_{\\text{outer}} = \\frac{2\\pi}{L} N_{\\text{outer}}$。\n   - 定义四个粒子的位置和电荷：\n     - $\\mathbf{r}_1 = (0.7, 1.3, 2.9)$, $q_1 = 1.0$。\n     - $\\mathbf{r}_2 = (2.2, 4.5, 1.1)$, $q_2 = -1.5$。\n     - $\\mathbf{r}_3 = (5.1, 0.4, 3.8)$, $q_3 = 0.7$。\n     - $\\mathbf{r}_4 = (1.9, 3.3, 5.5)$, $q_4 = -0.6$。\n   - 将以下四种谱用作 $\\rho(\\mathbf{k})$（作为 $\\lVert \\mathbf{k} \\rVert$ 的函数），每种谱都为满足 $0 < \\lVert \\mathbf{k} \\rVert \\le k_{\\text{outer}}$ 的所有模式定义，并且满足 $\\rho(-\\mathbf{k}) = \\rho(\\mathbf{k})$：\n     1. 白谱：$\\rho(\\mathbf{k}) = 1$。\n     2. 低 $k$ 主导：$\\rho(\\mathbf{k}) = \\exp\\!\\left(-(\\lVert \\mathbf{k} \\rVert / k_0)^2\\right)$，其中 $k_0 = 0.5\\, k_c$。\n     3. 高 $k$ 主导：$\\rho(\\mathbf{k}) = \\left(\\lVert \\mathbf{k} \\rVert / k_c\\right)^2 \\exp\\!\\left(-\\left(\\lVert \\mathbf{k} \\rVert - 1.5\\, k_c\\right)^2 / \\sigma^2\\right)$，其中 $\\sigma = 0.3\\, k_c$。\n     4. 单模：如果 $\\lVert \\mathbf{k} \\rVert$ 等于最小的非零模长（容差为 $10^{-8}$），则 $\\rho(\\mathbf{k}) = 1$，否则 $\\rho(\\mathbf{k}) = 0$。\n   - 对于固定的 $\\alpha_0 = 1.0$ 和对称有限差分步长 $\\delta\\alpha = 10^{-4}$，为每种谱计算：\n     - 对所有粒子，仅使用满足 $0 < \\lVert \\mathbf{k} \\rVert \\le k_c$ 的模式计算解析的 $\\partial \\mathbf{F}_i / \\partial \\alpha$。\n     - 对于相同的力定义，计算中心差分近似 $\\left(\\mathbf{F}_i(\\alpha_0 + \\delta\\alpha) - \\mathbf{F}_i(\\alpha_0 - \\delta\\alpha)\\right) / (2 \\delta\\alpha)$。\n     - 解析灵敏度与有限差分灵敏度之间的均方根误差（一个标量），该误差汇总了所有粒子和笛卡尔分量。\n   - 通过最小化标量目标函数来执行您的自适应 $\\alpha$ 选择\n     $$J(\\alpha) = \\left[\\operatorname{erfc}(\\alpha r_c)\\right]^2 + \\sum_{\\lVert \\mathbf{k} \\rVert > k_c}^{\\lVert \\mathbf{k} \\rVert \\le k_{\\text{outer}}} \\left[\\rho(\\mathbf{k}) \\exp\\!\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{2 \\alpha^2}\\right)\\right]^2,$$\n     其中 $r_c = 2.0$ 且 $\\operatorname{erfc}$ 是互补误差函数。对每种谱分别使用在 $\\alpha \\in [0.4, 2.0]$ 上至少有 $200$ 个点的均匀网格搜索，以找到最小化 $J(\\alpha)$ 的 $\\alpha^\\star$。\n   - 输出单行结果，形式为方括号内以逗号分隔的列表。该列表必须按以下顺序包含8个浮点数：对于按给定顺序（白谱、低 $k$、高 $k$、单模）的每种谱，先是均方根误差，然后是推荐的 $\\alpha^\\star$。例如，输出格式为 $[e_1,\\alpha^\\star_1,e_2,\\alpha^\\star_2,e_3,\\alpha^\\star_3,e_4,\\alpha^\\star_4]$。\n\n科学和数值要求：\n- 所有量均为无量纲。\n- 三角函数必须使用弧度制。\n- 实现必须是自包含的，且不要求任何输入。\n\n您的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[0.001,1.234,0.002,1.111,0.003,0.987,0.0001,1.543]$）。", "solution": "经严格审查，该问题陈述是有效的。它在科学上基于计算物理学的原理，特别是用于周期性静电相互作用的 Ewald 求和方法。该问题是适定的、客观的，并为得出唯一且有意义的解提供了所有必要的数据和约束。虽然它包含一个用于误差优化目标函数的非标准公式，但这被解释为一种给定的建模选择，不构成根本性缺陷。\n\n按照要求，解决方案分为三个部分：理论推导、自适应策略的制定以及数值实现。\n\n### 1. 倒易空间场和力灵敏度的推导\n\n推导从静电势的傅里叶表示开始，然后推导至电场及其对 Ewald 屏蔽参数 $\\alpha$ 的灵敏度。\n\n**1.1. 倒易空间电场 $\\mathbf{E}(\\mathbf{r})$**\n\n周期性系统中的静电势 $\\phi(\\mathbf{r})$ 可以用傅里叶级数表示。倒易空间分量 $\\phi_{\\text{rec}}(\\mathbf{r})$ 负责势的长程部分，该部分被高斯电荷分布所屏蔽。对于体积为 $V = L^3$ 的系统，其势由下式给出：\n$$\n\\phi_{\\text{rec}}(\\mathbf{r}) = \\frac{1}{V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}} \\hat{\\phi}_{\\text{rec}}(\\mathbf{k}) e^{i \\mathbf{k} \\cdot \\mathbf{r}}\n$$\n其中 $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{n}$ 是倒易格矢，$\\mathbf{n}$ 为整数三元组。\n\n傅里叶系数 $\\hat{\\phi}_{\\text{rec}}(\\mathbf{k})$ 是通过在傅里叶空间中求解屏蔽泊松方程得到的。解中包含标准的 Ewald 屏蔽因子 $\\exp(-\\lVert \\mathbf{k} \\rVert^2 / (4\\alpha^2))$。对于傅里叶空间电荷密度 $\\rho(\\mathbf{k})$，系数为：\n$$\n\\hat{\\phi}_{\\text{rec}}(\\mathbf{k}) = C \\frac{\\rho(\\mathbf{k})}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right)\n$$\n在无量纲单位中，通常设置前置因子常数 $C=1$。（在高斯单位制中，$C=4\\pi$。）问题指定 $\\rho(\\mathbf{k})$ 为实数且满足 $\\rho(-\\mathbf{k}) = \\rho(\\mathbf{k})$。这意味着当对对称的 $(\\mathbf{k}, -\\mathbf{k})$ 对求和时，$e^{i\\mathbf{k}\\cdot\\mathbf{r}}$ 的虚部（正弦）分量将相互抵消，只留下一个由余弦级数表示的纯实数势。\n$$\n\\phi_{\\text{rec}}(\\mathbf{r}) = \\frac{1}{V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}} \\frac{\\rho(\\mathbf{k})}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\cos(\\mathbf{k} \\cdot \\mathbf{r})\n$$\n电场 $\\mathbf{E}(\\mathbf{r})$ 是势的负梯度，即 $\\mathbf{E}(\\mathbf{r}) = -\\nabla \\phi_{\\text{rec}}(\\mathbf{r})$。应用梯度算子：\n$$\n\\mathbf{E}(\\mathbf{r}) = -\\nabla \\left[ \\frac{1}{V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}} \\frac{\\rho(\\mathbf{k})}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\cos(\\mathbf{k} \\cdot \\mathbf{r}) \\right]\n$$\n余弦项的梯度为 $\\nabla \\cos(\\mathbf{k} \\cdot \\mathbf{r}) = -\\mathbf{k} \\sin(\\mathbf{k} \\cdot \\mathbf{r})$。这给出了电场的表达式，该表达式对截断的模式集 $0 < \\lVert \\mathbf{k} \\rVert \\le k_c$ 进行求和：\n$$\n\\mathbf{E}(\\mathbf{r}) = \\frac{1}{V} \\sum_{0 < \\lVert \\mathbf{k} \\rVert \\le k_c} \\frac{\\rho(\\mathbf{k}) \\mathbf{k}}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\sin(\\mathbf{k} \\cdot \\mathbf{r})\n$$\n\n**1.2. 力灵敏度 $\\partial \\mathbf{F}_i / \\partial \\alpha$**\n\n粒子 $i$ 所受的静电力为 $\\mathbf{F}_i = q_i \\mathbf{E}(\\mathbf{r}_i)$。此力相对于屏蔽参数 $\\alpha$ 的灵敏度可通过求偏导数 $\\partial \\mathbf{F}_i / \\partial \\alpha$ 得到：\n$$\n\\frac{\\partial \\mathbf{F}_i}{\\partial \\alpha} = q_i \\frac{\\partial \\mathbf{E}(\\mathbf{r}_i; \\alpha)}{\\partial \\alpha}\n$$\n我们对 $\\mathbf{E}(\\mathbf{r})$ 的表达式关于 $\\alpha$ 求导。唯一依赖于 $\\alpha$ 的项是指数因子。使用链式法则：\n$$\n\\frac{\\partial}{\\partial \\alpha} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) = \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\cdot \\frac{\\partial}{\\partial \\alpha}\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4} \\alpha^{-2}\\right) = \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\cdot \\left(\\frac{\\lVert \\mathbf{k} \\rVert^2}{2 \\alpha^3}\\right)\n$$\n将此代入 $\\partial \\mathbf{E} / \\partial \\alpha$ 的表达式中：\n$$\n\\frac{\\partial \\mathbf{E}(\\mathbf{r}; \\alpha)}{\\partial \\alpha} = \\frac{1}{V} \\sum_{0 < \\lVert \\mathbf{k} \\rVert \\le k_c} \\frac{\\rho(\\mathbf{k}) \\mathbf{k}}{\\lVert \\mathbf{k} \\rVert^2} \\left[ \\frac{\\lVert \\mathbf{k} \\rVert^2}{2 \\alpha^3} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\right] \\sin(\\mathbf{k} \\cdot \\mathbf{r})\n$$\n分子和分母中的 $\\lVert \\mathbf{k} \\rVert^2$ 项相互抵消，得到场灵敏度的简化表达式：\n$$\n\\frac{\\partial \\mathbf{E}(\\mathbf{r}; \\alpha)}{\\partial \\alpha} = \\frac{1}{2V\\alpha^3} \\sum_{0 < \\lVert \\mathbf{k} \\rVert \\le k_c} \\rho(\\mathbf{k}) \\mathbf{k} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\sin(\\mathbf{k} \\cdot \\mathbf{r})\n$$\n最后，粒子 $i$ 的力灵敏度为：\n$$\n\\frac{\\partial \\mathbf{F}_i}{\\partial \\alpha} = \\frac{q_i}{2V\\alpha^3} \\sum_{0 < \\lVert \\mathbf{k} \\rVert \\le k_c} \\rho(\\mathbf{k}) \\mathbf{k} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\sin(\\mathbf{k} \\cdot \\mathbf{r}_i)\n$$\n\n### 2. 选择 $\\alpha$ 的自适应策略\n\n$\\alpha$ 的选择代表了一种权衡：大的 $\\alpha$ 使屏蔽电荷窄范围集中，导致实空间部分快速衰减（低实空间误差），但倒易空间部分衰减缓慢（高倒易空间误差）。相反，小的 $\\alpha$ 产生低的倒易空间误差，但实空间误差较高。一个最优的 $\\alpha$ 能平衡这两个相互竞争的误差来源。\n\n问题提供了一个特定的目标函数 $J(\\alpha)$ 来对此权衡进行建模：\n$$\nJ(\\alpha) = \\underbrace{\\left[\\operatorname{erfc}(\\alpha r_c)\\right]^2}_{J_{\\text{real}}(\\alpha)} + \\underbrace{\\sum_{\\lVert \\mathbf{k} \\rVert > k_c}^{\\lVert \\mathbf{k} \\rVert \\le k_{\\text{outer}}} \\left[\\rho(\\mathbf{k}) \\exp\\!\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{2 \\alpha^2}\\right)\\right]^2}_{J_{\\text{rec}}(\\alpha)}\n$$\n-   第一项 $J_{\\text{real}}(\\alpha)$ 对实空间截断误差进行建模。互补误差函数 $\\operatorname{erfc}(x)$ 是一个单调递减函数。因此，$J_{\\text{real}}(\\alpha)$ 随 $\\alpha$ 的增加而减小，从而对较小的 $\\alpha$ 值进行惩罚。\n-   第二项 $J_{\\text{rec}}(\\alpha)$ 通过对最先被忽略项的平方模长求和来对倒易空间截断误差进行建模。指数因子 $\\exp(-\\lVert \\mathbf{k} \\rVert^2 / (2 \\alpha^2))$ 随 $\\alpha$ 的增加而增加（对于固定的 $\\mathbf{k}$），这意味着 $J_{\\text{rec}}(\\alpha)$ 是 $\\alpha$ 的单调递增函数。它对较大的 $\\alpha$ 值进行惩罚。\n\n自适应策略是找到使总误差模型 $J(\\alpha)$ 最小化的 $\\alpha$ 值，记为 $\\alpha^\\star$。由于 $J(\\alpha)$ 是一个递减函数和一个递增函数之和，预期它会有一个唯一的最小值。所提出的策略是进行数值网格搜索：\n1.  在指定区间 $\\alpha \\in [0.4, 2.0]$ 上定义一个候选 $\\alpha$ 值的离散网格。\n2.  对于网格上的每个 $\\alpha$，使用给定的系统参数（$r_c$、$k_c$、$k_{\\text{outer}}$）和瞬时电荷谱 $\\rho(\\mathbf{k})$ 来计算 $J(\\alpha)$。\n3.  从网格中找出能得到 $J(\\alpha)$ 最小值的 $\\alpha^\\star$。\n\n这个 $\\alpha^\\star$ 代表了对于给定电荷构型的最优选择，它根据所提供的模型平衡了估算的实空间和倒易空间误差。\n\n### 3. 实现\n\n以下部分提供了实现所述计算的 Python 代码。它计算了解析推导的力灵敏度与有限差分近似之间的均方根误差。它还执行网格搜索，为四种不同的电荷密度谱找到最优的 $\\alpha^\\star$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef solve():\n    \"\"\"\n    Solves the particle mesh Ewald-related problem, including force sensitivity\n    analysis and adaptive alpha parameter selection.\n    \"\"\"\n    # Define system parameters and constants as per the problem statement\n    L = 6.0\n    V = L**3\n    N_outer = 6\n    N_c = 3\n    k_c = 2 * np.pi / L * N_c\n    k_outer = 2 * np.pi / L * N_outer\n    \n    # Define particle properties: positions and charges\n    positions = np.array([\n        [0.7, 1.3, 2.9],\n        [2.2, 4.5, 1.1],\n        [5.1, 0.4, 3.8],\n        [1.9, 3.3, 5.5]\n    ])\n    charges = np.array([1.0, -1.5, 0.7, -0.6])\n    \n    # Generate reciprocal lattice vectors\n    n_range = np.arange(-N_outer, N_outer + 1)\n    nx, ny, nz = np.meshgrid(n_range, n_range, n_range, indexing='ij')\n    n_vecs = np.stack((nx.ravel(), ny.ravel(), nz.ravel()), axis=1)\n    \n    # Exclude the n=(0,0,0) vector\n    mask_zero = np.all(n_vecs == 0, axis=1)\n    n_vecs = n_vecs[~mask_zero]\n    \n    k_vecs = (2 * np.pi / L) * n_vecs\n    k_mags = np.linalg.norm(k_vecs, axis=1)\n\n    # Define the charge density spectra\n    spectra_names = ['white', 'low-k', 'high-k', 'single-mode']\n    k0 = 0.5 * k_c\n    sigma = 0.3 * k_c\n    \n    # Smallest nonzero k-magnitude for the single-mode spectrum\n    k_min = np.min(k_mags[k_mags > 1e-9])\n\n    def get_rho(k_magnitudes, spectrum_name):\n        if spectrum_name == 'white':\n            return np.ones_like(k_magnitudes)\n        elif spectrum_name == 'low-k':\n            return np.exp(-(k_magnitudes / k0)**2)\n        elif spectrum_name == 'high-k':\n            return (k_magnitudes / k_c)**2 * np.exp(-((k_magnitudes - 1.5 * k_c) / sigma)**2)\n        elif spectrum_name == 'single-mode':\n            return np.isclose(k_magnitudes, k_min, atol=1e-8).astype(float)\n        else:\n            raise ValueError(f\"Unknown spectrum name: {spectrum_name}\")\n\n    results = []\n    \n    # Iterate through each spectrum to perform calculations\n    for name in spectra_names:\n        # Generate the full spectrum of rho(k) up to k_outer\n        rho_k_full = get_rho(k_mags, name)\n        \n        # --- Task 1: Sensitivity Calculation and RMSE ---\n        alpha0 = 1.0\n        delta_alpha = 1e-4\n\n        # Filter k-vectors for force calculation (0  ||k|| = k_c)\n        mask_force = k_mags = k_c\n        k_vecs_force = k_vecs[mask_force]\n        k_mags_force = k_mags[mask_force]\n        rho_k_force = rho_k_full[mask_force]\n\n        def calculate_forces(alpha, k_v, k_m, rho_k, pos, chg, vol):\n            forces = np.zeros_like(pos)\n            prefactor = 1.0 / vol\n            for i in range(len(chg)):\n                dotprods = k_v @ pos[i]\n                sins = np.sin(dotprods)\n                \n                k_m_sq_inv = np.zeros_like(k_m)\n                valid_k = k_m > 1e-9\n                k_m_sq_inv[valid_k] = 1.0 / k_m[valid_k]**2\n\n                exp_term = np.exp(-k_m**2 / (4 * alpha**2))\n                common_factor = rho_k * k_m_sq_inv * exp_term * sins\n                force_sum = np.sum(common_factor[:, np.newaxis] * k_v, axis=0)\n                forces[i, :] = chg[i] * prefactor * force_sum\n            return forces\n\n        def calculate_force_deriv_analytic(alpha, k_v, k_m, rho_k, pos, chg, vol):\n            derivs = np.zeros_like(pos)\n            prefactor = 1.0 / (2 * vol * alpha**3)\n            for i in range(len(chg)):\n                dotprods = k_v @ pos[i]\n                sins = np.sin(dotprods)\n                exp_term = np.exp(-k_m**2 / (4 * alpha**2))\n                common_factor = rho_k * exp_term * sins\n                deriv_sum = np.sum(common_factor[:, np.newaxis] * k_v, axis=0)\n                derivs[i, :] = chg[i] * prefactor * deriv_sum\n            return derivs\n        \n        F_analytic = calculate_force_deriv_analytic(alpha0, k_vecs_force, k_mags_force, rho_k_force, positions, charges, V)\n        \n        F_plus = calculate_forces(alpha0 + delta_alpha, k_vecs_force, k_mags_force, rho_k_force, positions, charges, V)\n        F_minus = calculate_forces(alpha0 - delta_alpha, k_vecs_force, k_mags_force, rho_k_force, positions, charges, V)\n        F_numeric = (F_plus - F_minus) / (2 * delta_alpha)\n        \n        rmse = np.sqrt(np.mean((F_analytic - F_numeric)**2))\n        results.append(rmse)\n\n        # --- Task 2: Adaptive alpha selection ---\n        r_c = 2.0\n        alpha_grid = np.linspace(0.4, 2.0, 201)\n\n        # Filter k-vectors for J_rec calculation (k_c  ||k|| = k_outer)\n        mask_J = (k_mags > k_c)  (k_mags = k_outer)\n        k_mags_J = k_mags[mask_J]\n        rho_k_J = rho_k_full[mask_J]\n        \n        J_values = np.zeros_like(alpha_grid)\n        for j, alpha_val in enumerate(alpha_grid):\n            J_real = erfc(alpha_val * r_c)**2\n            exp_term = np.exp(-k_mags_J**2 / (2 * alpha_val**2))\n            terms = rho_k_J * exp_term\n            J_rec = np.sum(terms**2)\n            J_values[j] = J_real + J_rec\n        \n        alpha_star = alpha_grid[np.argmin(J_values)]\n        results.append(alpha_star)\n\n    # Format and print the final output as a single-line comma-separated list\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n```", "id": "3473558"}, {"introduction": "在掌握标准PME方法后，探索更高级的算法是提升计算效率的前沿方向。本练习将引导你设计和评估一种双网格PME方案，它使用一个粗网格和一个细网格来分别处理不同波长的静电相互作用。你需要构建谱滤波器来划分计算任务，并定量分析该设计的谱重叠、力稳定性和其他关键性能指标，体验静电相互作用快速算法的研发过程[@problem_id:3473525]。", "problem": "您的任务是在一个三维周期性立方晶胞中，为粒子网格埃瓦尔德（Particle Mesh Ewald, PME）方法设计并评估一种双网格谱分裂方案。双网格设计使用一个粗网格来捕捉长波长内容，一个细网格来捕捉中等波长，而短波长则由埃瓦尔德分解的实空间部分处理。您的程序必须在倒易空间中为粗网格和细网格构建平滑的径向滤波器，分别表示为 $F_c(\\mathbf{k})$ 和 $F_f(\\mathbf{k})$，并定量分析两个属性：最小谱重叠和稳定的力响应。\n\n基本原理：\n- 在边长为 $L$ 的周期性立方盒子中，静电势 $\\phi(\\mathbf{r})$ 遵循泊松方程 $\\nabla^2 \\phi(\\mathbf{r}) = - \\rho(\\mathbf{r}) / \\varepsilon_0$，其中 $\\rho(\\mathbf{r})$ 是电荷密度。在埃瓦尔德分解下，阻尼库仑相互作用的倒易空间格林函数由 $G(\\mathbf{k}) = \\dfrac{4\\pi}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\!\\left(-\\dfrac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right)$ 给出，其中 $\\alpha$ 是埃瓦尔德屏蔽参数，$\\mathbf{k}$ 是倒易矢量。PME方法通过使用一个紧凑的分配核将电荷插值到网格上，从而用离散电荷替代连续的 $\\rho(\\mathbf{r})$，该核的傅里叶变换会抑制高频模式。\n- 对于间距为 $\\Delta x$ 的均匀网格，逐维的 $m$ 阶基本B样条分配给出了一个可分离的傅里叶衰减因子。在倒易空间中，每个笛卡尔分量 $k_d$ 的衰减为 $\\operatorname{sinc}\\!\\left(\\dfrac{k_d \\Delta x}{2}\\right)^m$，其中 $\\operatorname{sinc}(x) = \\dfrac{\\sin(x)}{x}$，三维因子是 $d \\in \\{x,y,z\\}$ 各分量的乘积。\n\n设计任务：\n- 考虑一个边长为 $L = 1$ 的立方盒子，采用任意长度单位（无量纲）。设粗网格每边有 $N_c$ 个点，间距为 $\\Delta x_c = \\dfrac{L}{N_c}$；细网格每边有 $N_f$ 个点，间距为 $\\Delta x_f = \\dfrac{L}{N_f}$。定义细网格分量的奈奎斯特波数 $k_{\\text{Ny},f} = \\pi N_f / L$。您将使用升余弦窗来构造 $F_c(\\mathbf{k})$ 和 $F_f(\\mathbf{k})$ 作为 $\\lVert \\mathbf{k} \\rVert$ 的平滑径向函数，形成一个低通（$F_c$）和一个带通（$F_f$）滤波器：\n    - 粗滤波器 $F_c$ 是一个径向低通滤波器，其过渡中心位于 $k_c$，半宽为 $\\delta_c$，由一个升余弦过渡函数 $W(x)$ 定义，该函数在 $x \\le -1$ 时等于 $1$，在 $x \\ge +1$ 时等于 $0$，并通过 $W(x) = \\dfrac{1}{2}\\left(1 + \\cos(\\pi x)\\right)$ 在 $x \\in [-1,1]$ 之间平滑插值。使用 $F_c(\\mathbf{k}) = W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_c}{\\delta_c}\\right)$。\n    - 细滤波器 $F_f$ 是粗过渡的高通补与一个中心位于 $k_f$、半宽为 $\\delta_f$ 的高频滚降低通滤波器的乘积：$F_f(\\mathbf{k}) = \\left(1 - W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_c}{\\delta_c}\\right)\\right) \\cdot W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_f}{\\delta_f}\\right)$。这里，$k_c = \\gamma_c\\, k_{\\text{Ny},f}$ 和 $k_f = \\gamma_f\\, k_{\\text{Ny},f}$，其中 $\\gamma_c$ 和 $\\gamma_f$ 是给定的无量纲分数；$\\delta_c = \\eta_c\\, k_{\\text{Ny},f}$，$\\delta_f = \\eta_f\\, k_{\\text{Ny},f}$。\n- 每个网格上的电荷分配使用阶数为 $m_c$ 的基本B样条（用于粗网格）和阶数为 $m_f$ 的基本B样条（用于细网格）。对应的三维衰减因子是 $S_c(\\mathbf{k}) = \\prod_{d\\in\\{x,y,z\\}} \\operatorname{sinc}\\!\\left(\\dfrac{k_d \\Delta x_c}{2}\\right)^{m_c}$ 和 $S_f(\\mathbf{k}) = \\prod_{d\\in\\{x,y,z\\}} \\operatorname{sinc}\\!\\left(\\dfrac{k_d \\Delta x_f}{2}\\right)^{m_f}$。\n- 双网格PME的组合倒易空间传递函数（单位电荷的势）是 $T(\\mathbf{k}) = G(\\mathbf{k}) \\left(F_c(\\mathbf{k}) S_c(\\mathbf{k}) + F_f(\\mathbf{k}) S_f(\\mathbf{k})\\right)$。每个模式的力振幅与 $\\lVert \\mathbf{k} \\rVert \\, T(\\mathbf{k})$ 成比例。\n\n程序要求：\n- 在由细网格诱导的离散倒易晶格上工作：令每个分量 $k_d = \\dfrac{2\\pi n_d}{L}$，其中 $n_d \\in \\{-\\lfloor \\dfrac{N_f}{2}\\rfloor, \\ldots, \\lfloor \\dfrac{N_f}{2}\\rfloor\\}$。在任何分母或最大值计算中排除 $\\mathbf{k} = \\mathbf{0}$ 模式，以避免奇异点。\n- 计算以下定量指标：\n    $1.$ 最小重叠：$O = \\text{mean}_{\\mathbf{k}} \\left(F_c(\\mathbf{k})^2 F_f(\\mathbf{k})^2\\right)$，在离散晶格上求平均。\n    $2.$ 可用频带内的单位分解偏差：$E_{\\text{PU}} = \\max_{\\mathbf{k}} \\left|F_c(\\mathbf{k}) + F_f(\\mathbf{k}) - 1\\right|$，仅对满足 $\\lVert \\mathbf{k} \\rVert \\le k_f - \\delta_f$ 且 $\\mathbf{k} \\ne \\mathbf{0}$ 的模式进行评估。\n    $3.$ 力稳定性比率：$R = \\dfrac{\\max_{\\mathbf{k}} \\left(\\lVert \\mathbf{k} \\rVert \\, T(\\mathbf{k})\\right)}{\\max_{\\mathbf{k}} \\left(\\lVert \\mathbf{k} \\rVert \\, G(\\mathbf{k})\\right)}$，同样在 $\\mathbf{k} \\ne \\mathbf{0}$ 上计算，为保证稳定性，该值不应显著超过1。\n- 全程使用无量纲单位，其中 $L = 1$，并将所有输出表示为无量纲浮点数。如果使用角度，则必须以弧度为单位。\n\n测试套件：\n为以下三组参数集提供结果，其中 $\\alpha$ 的单位是逆长度，但由于 $L=1$ 而是无量纲的：\n- 情况1（一般情况）：$\\alpha = 3.5$, $N_c = 16$, $N_f = 64$, $m_c = 4$, $m_f = 6$, $\\gamma_c = 0.30$, $\\eta_c = 0.05$, $\\gamma_f = 0.85$, $\\eta_f = 0.05$。\n- 情况2（高重叠边界）：$\\alpha = 3.5$, $N_c = 16$, $N_f = 64$, $m_c = 4$, $m_f = 6$, $\\gamma_c = 0.30$, $\\eta_c = 0.20$, $\\gamma_f = 0.85$, $\\eta_f = 0.05$。\n- 情况3（极粗的粗网格边缘情况）：$\\alpha = 3.0$, $N_c = 8$, $N_f = 64$, $m_c = 3$, $m_f = 6$, $\\gamma_c = 0.15$, $\\eta_c = 0.05$, $\\gamma_f = 0.90$, $\\eta_f = 0.05$。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中三个指标按三个情况的顺序展平。例如，它应打印 $[O_1,E_{\\text{PU},1},R_1,O_2,E_{\\text{PU},2},R_2,O_3,E_{\\text{PU},3},R_3]$ 作为无量纲浮点数。", "solution": "所提出的问题是计算材料科学领域中一个有效且定义明确的任务，具体涉及分析用于粒子网格埃瓦尔德（PME）方法的双网格谱分裂方案。所有必需的物理常数、数学定义和数值参数都已提供，该问题具有科学依据、客观且内部一致。因此，我们可以进行完整的求解。\n\n目标是设计并评估一个双网格PME谱分裂方案，通过为粗网格和细网格构建平滑的径向滤波器，然后根据谱重叠、单位分解偏差和力响应稳定性来量化其性能。分析将在一个离散的倒易晶格上对三组特定的参数集进行。\n\nPME方法的基础是库仑相互作用的埃瓦尔德分解，它将问题分解为一个短程的实空间部分和一个长程的倒易空间部分。倒易空间的贡献通过在网格上求解泊松方程来计算。势 $\\phi(\\mathbf{r})$ 与电荷密度 $\\rho(\\mathbf{r})$ 通过 $\\nabla^2 \\phi(\\mathbf{r}) = - \\rho(\\mathbf{r}) / \\varepsilon_0$ 相关联。在倒易空间中，这变为 $\\lVert \\mathbf{k} \\rVert^2 \\hat{\\phi}(\\mathbf{k}) = \\hat{\\rho}(\\mathbf{k}) / \\varepsilon_0$。埃瓦尔德技巧引入了一个屏蔽电荷分布，从而产生了一个阻尼的实空间势和一个修正的倒易空间势。该阻尼相互作用的倒易空间格林函数表示为：\n$$\nG(\\mathbf{k}) = \\dfrac{4\\pi}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\!\\left(-\\dfrac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right)\n$$\n其中 $\\mathbf{k}$ 是倒易空间矢量，$\\alpha$ 是埃瓦尔德屏蔽参数。\n\n我们的分析在一个边长为 $L=1$ 的无量纲立方周期性盒子中进行。倒易晶格矢量定义在一个与 $N_f \\times N_f \\times N_f$ 点的细网格相对应的格点上。倒易矢量 $\\mathbf{k}$ 的分量由 $k_d = \\frac{2\\pi n_d}{L}$ 给出，其中 $d \\in \\{x,y,z\\}$，整数 $n_d$ 的范围是从 $-\\lfloor N_f/2 \\rfloor$ 到 $\\lfloor N_f/2 \\rfloor$。其大小为 $\\lVert \\mathbf{k} \\rVert = \\sqrt{k_x^2 + k_y^2 + k_z^2}$。特殊情况 $\\mathbf{k}=\\mathbf{0}$ 对应于系统的整体电荷中性，在涉及除以 $\\lVert \\mathbf{k} \\rVert$ 的计算或奇异量的最大值计算中被排除。\n\n双网格方法使用两个谱滤波器，$F_c(\\mathbf{k})$ 用于粗网格，$F_f(\\mathbf{k})$ 用于细网格，以划分倒易空间计算。这些滤波器使用一个升余弦窗函数 $W(x)$ 构建，定义如下：\n$$\nW(x) =\n\\begin{cases}\n1  x \\le -1 \\\\\n\\frac{1}{2} (1 + \\cos(\\pi x))  -1  x  1 \\\\\n0  x \\ge 1\n\\end{cases}\n$$\n粗滤波器 $F_c(\\mathbf{k})$ 是一个低通滤波器，细滤波器 $F_f(\\mathbf{k})$ 是一个带通滤波器。它们的定义是：\n$$\nF_c(\\mathbf{k}) = W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_c}{\\delta_c}\\right)\n$$\n$$\nF_f(\\mathbf{k}) = \\left(1 - W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_c}{\\delta_c}\\right)\\right) \\cdot W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_f}{\\delta_f}\\right)\n$$\n过渡中心 $k_c, k_f$ 和半宽 $\\delta_c, \\delta_f$ 是相对于细网格奈奎斯特频率 $k_{\\text{Ny},f} = \\pi N_f/L$ 定义的：\n$k_c = \\gamma_c k_{\\text{Ny},f}$，$\\delta_c = \\eta_c k_{\\text{Ny},f}$，$k_f = \\gamma_f k_{\\text{Ny},f}$，以及 $\\delta_f = \\eta_f k_{\\text{Ny},f}$。\n\nPME方法使用一个分配函数（通常是阶数为 $m$ 的基本B样条）将粒子电荷插值到网格上。这个过程引入了一个傅里叶空间衰减因子 $S(\\mathbf{k})$。对于间距为 $\\Delta x_c = L/N_c$ 的粗网格和 $\\Delta x_f = L/N_f$ 的细网格，以及样条阶数 $m_c$ 和 $m_f$，这些因子是：\n$$\nS_c(\\mathbf{k}) = \\prod_{d\\in\\{x,y,z\\}} \\left( \\operatorname{sinc}\\!\\left(\\dfrac{k_d \\Delta x_c}{2}\\right) \\right)^{m_c}\n$$\n$$\nS_f(\\mathbf{k}) = \\prod_{d\\in\\{x,y,z\\}} \\left( \\operatorname{sinc}\\!\\left(\\dfrac{k_d \\Delta x_f}{2}\\right) \\right)^{m_f}\n$$\n其中问题指定 $\\operatorname{sinc}(x) = \\sin(x)/x$。\n\n双网格方案的总倒易空间传递函数 $T(\\mathbf{k})$ 结合了这些元素：\n$$\nT(\\mathbf{k}) = G(\\mathbf{k}) \\left( F_c(\\mathbf{k}) S_c(\\mathbf{k}) + F_f(\\mathbf{k}) S_f(\\mathbf{k}) \\right)\n$$\n现在我们将为每个参数集计算三个指定的指标。\n\n1.  **最小重叠， $O$**：该指标量化了两个滤波器同时非零的程度，这可能导致冗余计算。它被计算为在整个离散倒易晶格上滤波器函数的均方乘积。\n    $$\n    O = \\text{mean}_{\\mathbf{k}} \\left(F_c(\\mathbf{k})^2 F_f(\\mathbf{k})^2\\right)\n    $$\n2.  **单位分解偏差， $E_{\\text{PU}}$**：在预期的工作波数带内，滤波器之和理想情况下应为1，即 $F_c(\\mathbf{k}) + F_f(\\mathbf{k}) = 1$，以确保所有频谱内容都被精确捕获一次。我们评估在由 $\\lVert \\mathbf{k} \\rVert \\le k_f - \\delta_f$ 定义的频带内与此理想情况的最大偏差。\n    $$\n    E_{\\text{PU}} = \\max_{\\mathbf{k}, \\lVert \\mathbf{k} \\rVert \\le k_f - \\delta_f, \\mathbf{k} \\ne \\mathbf{0}} \\left| F_c(\\mathbf{k}) + F_f(\\mathbf{k}) - 1 \\right|\n    $$\n    根据构造，在这个频带内，项 $W((\\lVert \\mathbf{k} \\rVert - k_f)/\\delta_f)$ 精确为 $1$，这使得 $F_f(\\mathbf{k}) = 1 - F_c(\\mathbf{k})$。因此，$F_c(\\mathbf{k})+F_f(\\mathbf{k})=1$ 在解析上成立，所以 $E_{\\text{PU}}$ 应该在浮点精度范围内为零。\n\n3.  **力稳定性比率， $R$**：粒子上的力与势的梯度有关，这在倒易空间中对应于乘以 $i\\mathbf{k}$。来自模式 $\\mathbf{k}$ 的力贡献的大小与 $\\lVert \\mathbf{k} \\rVert T(\\mathbf{k})$ 成比例。一个稳定的数值方案不应与基准阻尼相互作用 $G(\\mathbf{k})$ 相比过度放大高频模式。比率 $R$ 比较了PME方案的最大力振幅与纯阻尼相互作用的最大力振幅。\n    $$\n    R = \\dfrac{\\max_{\\mathbf{k} \\ne \\mathbf{0}} \\left(\\lVert \\mathbf{k} \\rVert \\, T(\\mathbf{k})\\right)}{\\max_{\\mathbf{k} \\ne \\mathbf{0}} \\left(\\lVert \\mathbf{k} \\rVert \\, G(\\mathbf{k})\\right)}\n    $$\n    一个接近 $1$ 的 $R$ 值是理想的。\n\n下面的程序为三个指定的测试用例实现了这些计算，将倒易晶格和所有中间函数构建为多维数组以进行高效计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the PME two-grid spectral splitting problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, Nc, Nf, mc, mf, gamma_c, eta_c, gamma_f, eta_f)\n        (3.5, 16, 64, 4, 6, 0.30, 0.05, 0.85, 0.05), # Case 1\n        (3.5, 16, 64, 4, 6, 0.30, 0.20, 0.85, 0.05), # Case 2\n        (3.0, 8, 64, 3, 6, 0.15, 0.05, 0.90, 0.05),  # Case 3\n    ]\n\n    results = []\n\n    def my_sinc(x):\n        \"\"\"Custom sinc(x) = sin(x)/x, as defined in the problem.\"\"\"\n        x = np.asanyarray(x)\n        y = np.ones_like(x, dtype=float)\n        # Numerically stable for x -> 0, where sinc(x) -> 1\n        nonzero_mask = x != 0\n        y[nonzero_mask] = np.sin(x[nonzero_mask]) / x[nonzero_mask]\n        return y\n\n    def raised_cosine_window(x):\n        \"\"\"Raised-cosine window function W(x).\"\"\"\n        x = np.asanyarray(x)\n        y = np.zeros_like(x, dtype=float)\n        \n        cond1 = x = -1\n        cond3 = x >= 1\n        cond2 = ~cond1  ~cond3 # -1  x  1\n        \n        y[cond1] = 1.0\n        y[cond2] = 0.5 * (1.0 + np.cos(np.pi * x[cond2]))\n        # y[cond3] is already 0.0\n        \n        return y\n\n    for case in test_cases:\n        alpha, N_c, N_f, m_c, m_f, gamma_c, eta_c, gamma_f, eta_f = case\n        \n        L = 1.0\n        \n        # Grid spacings\n        delta_xc = L / N_c\n        delta_xf = L / N_f\n        \n        # Reciprocal space parameters\n        k_ny_f = np.pi * N_f / L\n        k_c = gamma_c * k_ny_f\n        delta_c = eta_c * k_ny_f\n        k_f = gamma_f * k_ny_f\n        delta_f = eta_f * k_ny_f\n        \n        # Create reciprocal lattice\n        n_range = np.arange(-np.floor(N_f / 2), np.floor(N_f / 2) + 1)\n        nx, ny, nz = np.meshgrid(n_range, n_range, n_range, indexing='ij')\n        \n        kx = 2.0 * np.pi * nx / L\n        ky = 2.0 * np.pi * ny / L\n        kz = 2.0 * np.pi * nz / L\n        \n        k_norm = np.sqrt(kx**2 + ky**2 + kz**2)\n        k_norm_sq = k_norm**2\n        \n        # Mask for k=0 mode\n        k_is_not_zero = k_norm != 0\n        \n        # --- Component Functions ---\n        \n        # Green's function G(k)\n        G_k = np.zeros_like(k_norm)\n        G_k[k_is_not_zero] = (4.0 * np.pi / k_norm_sq[k_is_not_zero]) * \\\n                           np.exp(-k_norm_sq[k_is_not_zero] / (4.0 * alpha**2))\n        \n        # Filters Fc(k) and Ff(k)\n        arg_c = np.zeros_like(k_norm)\n        arg_c[delta_c != 0] = (k_norm[delta_c != 0] - k_c) / delta_c\n        F_c = raised_cosine_window(arg_c)\n        \n        arg_f = np.zeros_like(k_norm)\n        arg_f[delta_f != 0] = (k_norm[delta_f != 0] - k_f) / delta_f\n        F_f = (1.0 - F_c) * raised_cosine_window(arg_f)\n        \n        # Spline attenuation factors Sc(k) and Sf(k)\n        Sc_kx = my_sinc(kx * delta_xc / 2.0)**m_c\n        Sc_ky = my_sinc(ky * delta_xc / 2.0)**m_c\n        Sc_kz = my_sinc(kz * delta_xc / 2.0)**m_c\n        S_c = Sc_kx * Sc_ky * Sc_kz\n        \n        Sf_kx = my_sinc(kx * delta_xf / 2.0)**m_f\n        Sf_ky = my_sinc(ky * delta_xf / 2.0)**m_f\n        Sf_kz = my_sinc(kz * delta_xf / 2.0)**m_f\n        S_f = Sf_kx * Sf_ky * Sf_kz\n        \n        # --- Metrics Calculation ---\n        \n        # 1. Minimal overlap O\n        overlap = np.mean(F_c**2 * F_f**2)\n        results.append(overlap)\n        \n        # 2. Partition-of-unity deviation E_PU\n        pu_mask = (k_norm = (k_f - delta_f))  k_is_not_zero\n        if np.any(pu_mask):\n            pu_dev = np.max(np.abs(F_c[pu_mask] + F_f[pu_mask] - 1.0))\n        else:\n            pu_dev = 0.0 # No points in the evaluation domain\n        results.append(pu_dev)\n        \n        # 3. Force stability ratio R\n        T_k = G_k * (F_c * S_c + F_f * S_f)\n        \n        force_T = k_norm * T_k\n        force_G = k_norm * G_k\n        \n        max_force_T = np.max(force_T[k_is_not_zero])\n        max_force_G = np.max(force_G[k_is_not_zero])\n        \n        force_ratio = max_force_T / max_force_G if max_force_G != 0 else 0.0\n        results.append(force_ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3473525"}]}