{"hands_on_practices": [{"introduction": "径向分布函数 $g(r)$ 提供了一幅原子位置的统计地图。其一个基本应用是确定配位数，它量化了一个典型原子周围有多少个近邻。本练习将引导您从第一性原理出发推导该物理量，并针对一个模拟的液态水体系进行计算，同时突显在实践中定义配位壳层边界的重要性。[@problem_id:3483596]", "problem": "给定一个人工合成的、物理上合理的液态水氧-氧径向分布函数 (RDF)，要求您计算截至截断距离 $r$ 的累积配位数 $n(r)$，也称为水合数。在均匀各向同性液体中，配位数 $n(r)$ 是指距离一个参考氧原子 $r$ 范围内的氧邻居的平均数量。您的任务是：使用 RDF 的定义从第一性原理推导 $n(r)$ 的计算方法，实现一个算法在均匀空间网格上对其进行数值计算，并量化水合数如何依赖于在 $g(r)$ 第一个极小值处选择的截断距离。\n\n基本原理和物理背景：\n- 考虑一个均匀各向同性流体，其氧数密度 $\\rho$ 以 $\\mathrm{nm}^{-3}$ 为单位。\n- 在统计力学中，氧-氧 (O-O) 相关的径向分布函数 (RDF) $g(r)$ 定义为距离一个标记氧原子 $r$ 处的局部数密度与体相数密度的比值，此处不提供任何计算捷径。\n- 在均匀各向同性流体中，围绕一个标记氧原子、位于 $r$ 和 $r + dr$ 之间的球壳内的氧原子期望数量，可以利用球壳体积和 RDF 从第一性原理得到。累积配位数 $n(r)$ 则是通过将这些球壳的贡献从 $0$ 到 $r$ 求和（积分）得到的。\n\n科学和数值设定：\n- 使用接近环境温度、质量密度为 $1\\,\\mathrm{g/cm^3}$ 的液态水，每个分子视为含有一个氧原子。\n- 使用水的摩尔质量 $M = 0.018\\,\\mathrm{kg/mol}$、质量密度 $\\rho_{\\mathrm{mass}} = 1000\\,\\mathrm{kg/m^3}$ 以及阿伏伽德罗常数 $N_{\\mathrm{A}} = 6.02214076\\times 10^{23}\\,\\mathrm{mol^{-1}}$ 从第一性原理计算氧数密度 $\\rho$（单位为 $\\mathrm{nm}^{-3}$）。使用 $1\\,\\mathrm{m^3} = 10^{27}\\,\\mathrm{nm^3}$ 将 $\\mathrm{m^3}$ 转换为 $\\mathrm{nm^3}$。$\\rho$ 的数值必须由您的程序计算，不得硬编码。\n- 定义一个从 $0$ 到 $r_{\\max}$ 的均匀径向网格 $r$，间距为 $\\Delta r$（单位为纳米），其中 $r_{\\max} = 1.0\\,\\mathrm{nm}$ 且 $\\Delta r = 0.0005\\,\\mathrm{nm}$。此问题不涉及角度，因此不需要角度单位。\n- 定义一个人工合成的 O-O RDF $g_{\\mathrm{OO}}(r)$，它应表现出真实的液态水结构：在 $r \\approx 0.275\\,\\mathrm{nm}$ 附近有一个强的第一峰，在 $r \\approx 0.33\\,\\mathrm{nm}$ 附近有第一个极小值且 $g(r) < 1$，在 $r \\approx 0.45\\,\\mathrm{nm}$ 附近有一个较弱的第二峰，并且随着 $r$ 的增大 $g(r) \\to 1$。对 $g_{\\mathrm{OO}}(r)$ 使用以下解析形式，所有距离单位均为纳米：\n$$\ng_{\\mathrm{OO}}(r) = s(r)\\left(1 + A_1 \\exp\\!\\left(-\\frac{(r - r_1)^2}{2\\sigma_1^2}\\right) - B_1 \\exp\\!\\left(-\\frac{(r - r_{\\min})^2}{2\\sigma_{\\min}^2}\\right) + A_2 \\exp\\!\\left(-\\frac{(r - r_2)^2}{2\\sigma_2^2}\\right)\\right),\n$$\n$$\ns(r) = 1 - \\exp\\!\\left(-\\left(\\frac{r}{r_0}\\right)^6\\right),\n$$\n参数如下\n$$\nr_0 = 0.23,\\quad A_1 = 2.8,\\quad r_1 = 0.275,\\quad \\sigma_1 = 0.010,\\quad B_1 = 0.15,\\quad r_{\\min} = 0.33,\\quad \\sigma_{\\min} = 0.012,\\quad A_2 = 0.20,\\quad r_2 = 0.45,\\quad \\sigma_2 = 0.020.\n$$\n- 如果在数值计算中出现负值，需将其裁剪为零以确保 $g_{\\mathrm{OO}}(r) \\ge 0$。\n\n推导要求：\n- 从 $g(r)$ 的定义和三维球壳的概念出发，推导如何计算距离 $r$ 内的氧邻居期望数量，记为 $n(r)$，推导过程不应在问题陈述中直接给出目标公式。推导必须从球壳体积以及 $g(r)$ 作为局部数密度与体相数密度之比的含义开始。\n\n算法任务：\n1. 生成均匀网格 $r$ 并在此网格上计算 $g_{\\mathrm{OO}}(r)$。\n2. 在区间 $r \\in [0.24, 0.35]$ 内识别 $g_{\\mathrm{OO}}(r)$ 的第一个局部极大值（第一个峰）；然后在截至 $0.50\\,\\mathrm{nm}$ 的区间内找到该峰之后的第一个局部极小值。设第一个极小值的位置为 $r_{\\mathrm{min,found}}$（单位为纳米）。\n3. 计算四个截断距离 $R$（单位均为纳米）下的水合数 $n(R)$：\n   - $R_1 = 0.000$ (边界情况),\n   - $R_2 = r_{\\mathrm{min,found}} - \\Delta$ (极小值下方的边缘情况),\n   - $R_3 = r_{\\mathrm{min,found}}$ (极小值本身),\n   - $R_4 = r_{\\mathrm{min,found}} + \\Delta$ (极小值上方的边缘情况),\n   其中 $\\Delta = 0.005\\,\\mathrm{nm}$。\n4. 使用一致的求积法则在网格上执行数值积分，以获得每个截断距离下的 $n(R)$。\n5. 将每个 $n(R)$ 表示为四舍五入到三位小数的浮点数。水合数是无量纲的，报告时无需单位。\n\n测试套件和最终输出格式：\n- 使用指定的四个截断距离 $R_1$, $R_2$, $R_3$, 和 $R_4$ 作为测试套件。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[n(R_1), n(R_2), n(R_3), n(R_4)]$，例如格式为 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 都四舍五入到三位小数。", "solution": "从第一性原理推导累积配位数 $n(r)$ 是液体统计力学中的一个基础练习。\n\n**配位数的推导**\n\n我们首先考虑一个均匀各向同性的流体，其特征是体相数密度为 $\\rho$。该密度表示每单位体积内粒子的平均数量（在此案例中为氧原子）。\n\n径向分布函数 $g(r)$ 衡量了在距离一个任意参考粒子 $r$ 处，局部密度如何偏离体相密度。根据定义，距离 $r$ 处的局部数密度（我们可记为 $\\rho(r)$）与体相密度 $\\rho$ 的关系如下：\n$$\n\\rho(r) = \\rho g(r)\n$$\n为了找到参考粒子某一半径范围内的总粒子数，必须在感兴趣的体积上对局部密度进行积分。执行此积分最方便的方法是考虑以参考粒子为中心的无穷薄球壳。一个位于半径 $r'$、微分厚度为 $dr'$ 的球壳，其体积 $dV$ 由下式给出：\n$$\ndV = 4\\pi (r')^2 dr'\n$$\n这个微元球壳内的粒子数 $dN$ 是该半径处的局部数密度 $\\rho(r')$ 与球壳体积 $dV$ 的乘积：\n$$\ndN = \\rho(r') dV = \\rho g(r') \\left( 4\\pi (r')^2 dr' \\right)\n$$\n重新整理各项，我们得到球壳中粒子数的微分，作为半径的函数：\n$$\ndN(r') = 4\\pi \\rho (r')^2 g(r') dr'\n$$\n累积配位数 $n(r)$ 定义为以参考粒子为中心、半径为 $r$ 的球体内的平均总粒子数。为了得到 $n(r)$，我们必须将从半径 $0$ 到截断半径 $r$ 的所有同心球壳中的粒子数 $dN(r')$ 进行求和（积分）。\n$$\nn(r) = \\int_0^r dN(r') = \\int_0^r 4\\pi \\rho (r')^2 g(r') dr'\n$$\n该积分是连接径向分布函数 $g(r)$ 和配位数 $n(r)$ 的基本关系。为了数值计算 $n(r)$，我们将计算这个定积分。\n\n**算法实现**\n\n解决方案通过以下计算步骤进行。\n\n1.  **系统参数计算**：液态水中氧原子的数密度 $\\rho$ 是根据给定的宏观性质计算的。质量密度为 $\\rho_{\\mathrm{mass}} = 1000\\,\\mathrm{kg/m^3}$，水的摩尔质量为 $M = 0.018\\,\\mathrm{kg/mol}$，阿伏伽德罗常数为 $N_{\\mathrm{A}} = 6.02214076\\times 10^{23}\\,\\mathrm{mol^{-1}}$。每立方米的分子数由 $(\\rho_{\\mathrm{mass}}/M) \\times N_{\\mathrm{A}}$ 给出。由于每个水分子含有一个氧原子，这也是氧的数密度。为了将其单位转换为 $\\mathrm{nm}^{-3}$，我们使用换算因子 $1\\,\\mathrm{m^3} = 10^{27}\\,\\mathrm{nm^3}$。\n    $$\n    \\rho = \\frac{\\rho_{\\mathrm{mass}}}{M} N_{\\mathrm{A}} \\frac{1\\,\\mathrm{m^3}}{10^{27}\\,\\mathrm{nm^3}} = \\frac{1000\\,\\mathrm{kg/m^3}}{0.018\\,\\mathrm{kg/mol}} \\times (6.02214076\\times 10^{23}\\,\\mathrm{mol^{-1}}) \\times 10^{-27}\\,\\mathrm{m^3/nm^3}\n    $$\n    此计算在实现中以数值方式执行。\n\n2.  **网格和函数生成**：为变量 $r$ 建立一个均匀的径向网格，范围从 $r = 0\\,\\mathrm{nm}$ 到 $r_{\\max} = 1.0\\,\\mathrm{nm}$，步长为 $\\Delta r = 0.0005\\,\\mathrm{nm}$。在此网格上，我们使用提供的解析公式和参数来计算人工合成的氧-氧径向分布函数 $g_{\\mathrm{OO}}(r)$：\n    $$\n    g_{\\mathrm{OO}}(r) = s(r)\\left(1 + A_1 \\exp\\!\\left(-\\frac{(r - r_1)^2}{2\\sigma_1^2}\\right) - B_1 \\exp\\!\\left(-\\frac{(r - r_{\\min})^2}{2\\sigma_{\\min}^2}\\right) + A_2 \\exp\\!\\left(-\\frac{(r - r_2)^2}{2\\sigma_2^2}\\right)\\right)\n    $$\n    其中 $s(r) = 1 - \\exp\\!\\left(-\\left(\\frac{r}{r_0}\\right)^6\\right)$。参数为 $r_0 = 0.23$，$A_1 = 2.8$，$r_1 = 0.275$，$\\sigma_1 = 0.010$，$B_1 = 0.15$，$r_{\\min} = 0.33$，$\\sigma_{\\min} = 0.012$，$A_2 = 0.20$，$r_2 = 0.45$ 和 $\\sigma_2 = 0.020$，所有距离单位均为纳米。任何数值计算产生的 $g_{\\mathrm{OO}}(r)$ 负值都将被裁剪为 $0$。\n\n3.  **第一个极小值的位置**：为了确定第一个水合层的标准截断距离，我们必须定位 $g_{\\mathrm{OO}}(r)$ 的第一个极小值。该算法首先在指定的径向区间 $r \\in [0.24, 0.35]\\,\\mathrm{nm}$ 内通过寻找 $g_{\\mathrm{OO}}(r)$ 的最大值来确定第一个峰的位置。随后，它在从第一个峰位置开始到 $r = 0.50\\,\\mathrm{nm}$ 的范围内搜索 $g_{\\mathrm{OO}}(r)$ 的最小值。这个极小值的径向位置表示为 $r_{\\mathrm{min,found}}$。由于网格的离散性，该位置将对应于其中一个网格点。\n\n4.  **数值积分**：对于给定的截断半径 $R$，配位数 $n(R)$ 是通过对上面推导的积分进行数值计算得出的。被积函数为 $f(r) = 4\\pi \\rho r^2 g_{\\mathrm{OO}}(r)$。我们使用梯形法则进行数值求积，该方法非常适用于在精细、均匀网格上求值的函数。积分计算如下：\n    $$\n    n(R) = \\int_0^R 4\\pi \\rho r^2 g_{\\mathrm{OO}}(r) dr \\approx \\sum_{i=1}^{N_R} \\frac{f(r_i) + f(r_{i-1})}{2} (r_i - r_{i-1})\n    $$\n    其中网格点 $r_i$ 从 $r_0=0$ 运行到 $r_{N_R} = R$。这一步通过使用库函数进行梯形积分来高效实现。\n\n5.  **在指定截断距离处求值**：最后的任务是计算四个特定截断距离下的 $n(R)$：\n    *   $R_1 = 0.000\\,\\mathrm{nm}$。\n    *   $R_2 = r_{\\mathrm{min,found}} - \\Delta$，其中 $\\Delta = 0.005\\,\\mathrm{nm}$。\n    *   $R_3 = r_{\\mathrm{min,found}}$。\n    *   $R_4 = r_{\\mathrm{min,found}} + \\Delta$。\n    对于 $R_1=0$，配位数解析地为 $0$。对于其他截断距离，数值积分执行到与每个 $R_k$ 对应的网格索引处。然后将所得值四舍五入到三位小数。参数 $\\Delta = 0.005\\,\\mathrm{nm}$ 恰好对应 10 个网格步长（$10 \\times 0.0005\\,\\mathrm{nm}$），确保 $R_2$ 和 $R_4$ 也完美地落在网格点上，从而简化了积分过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import trapezoid\n\ndef solve():\n    \"\"\"\n    Computes the cumulative coordination number for a synthetic O-O RDF of liquid water\n    at four specified cutoff distances.\n    \"\"\"\n    #\n    # Define physical constants and problem parameters\n    #\n    M_WATER = 0.018  # Molar mass of water in kg/mol\n    RHO_MASS = 1000.0  # Mass density of water in kg/m^3\n    N_A = 6.02214076e23  # Avogadro constant in mol^-1\n    M3_TO_NM3 = 1e27  # Conversion factor for m^3 to nm^3\n\n    # Parameters for the synthetic g_OO(r) function (all distances in nm)\n    R0 = 0.23\n    A1 = 2.8\n    R1 = 0.275\n    SIGMA1 = 0.010\n    B1 = 0.15\n    R_MIN_PARAM = 0.33\n    SIGMA_MIN = 0.012\n    A2 = 0.20\n    R2 = 0.45\n    SIGMA2 = 0.020\n\n    # Numerical grid parameters (in nm)\n    R_MAX = 1.0\n    DR = 0.0005\n\n    # Test case parameters (in nm)\n    DELTA = 0.005\n    R1_cutoff = 0.000\n\n    #\n    # Step 1: Calculate oxygen number density rho in nm^-3\n    #\n    # Number of molecules per cubic meter\n    n_per_m3 = (RHO_MASS / M_WATER) * N_A\n    # Convert to number of molecules per cubic nanometer\n    rho = n_per_m3 / M3_TO_NM3\n\n    #\n    # Step 2: Generate the radial grid and evaluate g_OO(r)\n    #\n    r_grid = np.arange(0, R_MAX + DR / 2, DR)\n\n    def g_oo(r):\n        \"\"\"Calculates the synthetic O-O radial distribution function.\"\"\"\n        s_r = 1.0 - np.exp(-((r / R0)**6))\n        \n        term1 = A1 * np.exp(-((r - R1)**2) / (2.0 * SIGMA1**2))\n        term2 = -B1 * np.exp(-((r - R_MIN_PARAM)**2) / (2.0 * SIGMA_MIN**2))\n        term3 = A2 * np.exp(-((r - R2)**2) / (2.0 * SIGMA2**2))\n        \n        g = s_r * (1.0 + term1 + term2 + term3)\n        \n        return np.maximum(g, 0.0)  # Clip negative values to zero\n\n    g_values = g_oo(r_grid)\n\n    #\n    # Step 3: Find the first minimum of g_OO(r) after the first peak\n    #\n    # Find the index of the first peak in the interval [0.24, 0.35] nm\n    peak_search_start_idx = int(round(0.24 / DR))\n    peak_search_end_idx = int(round(0.35 / DR))\n    peak_idx_relative = np.argmax(\n        g_values[peak_search_start_idx:peak_search_end_idx + 1]\n    )\n    peak_idx = peak_search_start_idx + peak_idx_relative\n    \n    # Find the first minimum in the interval [r_peak, 0.50] nm\n    min_search_start_idx = peak_idx\n    min_search_end_idx = int(round(0.50 / DR))\n    min_idx_relative = np.argmin(\n        g_values[min_search_start_idx:min_search_end_idx + 1]\n    )\n    min_idx = min_search_start_idx + min_idx_relative\n    r_min_found = r_grid[min_idx]\n\n    #\n    # Step 4  5: Define cutoffs and compute coordination numbers via numerical integration\n    #\n    R2_cutoff = r_min_found - DELTA\n    R3_cutoff = r_min_found\n    R4_cutoff = r_min_found + DELTA\n\n    cutoffs = [R1_cutoff, R2_cutoff, R3_cutoff, R4_cutoff]\n    \n    # Pre-calculate the integrand for the coordination number\n    integrand = 4.0 * np.pi * rho * r_grid**2 * g_values\n    \n    coordination_numbers = []\n    \n    for R_c in cutoffs:\n        if R_c == 0.0:\n            n_r = 0.0\n        else:\n            # Find the grid index corresponding to the cutoff radius.\n            # `round` handles potential float precision issues, ensuring an exact integer index\n            # as all cutoffs are designed to fall on grid points.\n            cutoff_idx = int(round(R_c / DR))\n            \n            # Integrate from r=0 up to the cutoff index using the trapezoidal rule\n            n_r = trapezoid(\n                integrand[:cutoff_idx + 1],\n                r_grid[:cutoff_idx + 1]\n            )\n        \n        # Round the result to three decimal places as required\n        coordination_numbers.append(round(n_r, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, coordination_numbers))}]\")\n\nsolve()\n```", "id": "3483596"}, {"introduction": "除了简单的结构统计，径向分布函数更是连接微观相互作用与宏观热力学的有力桥梁。通过维里定理，我们可以直接从流体的 $g(r)$ 和其底层的对势 $U(r)$ 来计算压强。本实践将演示这一关键联系，并探讨压强计算对短程结构数据质量的数值敏感性。[@problem_id:3483653]", "problem": "您将使用统计力学维里路径，推导并实现一个经典、均匀、各向同性流体的状态方程，该流体具有成对相加的相互作用。从经典力学中的维里定理和径向分布函数的定义开始。根据数密度、温度、径向分布函数和对势的径向导数，推导均匀流体的压力。然后，实现一个数值程序，使用一个人造但物理上合理的径向分布函数来评估压力，并评估压力对径向分布函数中短程采样质量的敏感性。\n\n推导的基本依据：使用经典维里定理和径向分布函数的定义。具体使用：适用于具有成对中心力系统的维里定理、数密度 $\\rho = N/V$、玻尔兹曼常数 $k_B$、温度 $T$、中心力 $\\mathbf{F}(r) = -U'(r)\\,\\hat{\\mathbf{r}}$、利用各向同性将张量维里简化为标量积分，以及由径向分布函数 $g(r)$ 编码的对关联。\n\n模型系统和单位：使用 Lennard-Jones 对势和约化单位。在约化的 Lennard-Jones 单位中，设置能量标度 $\\varepsilon = 1$，长度标度 $\\sigma = 1$，以及玻尔兹曼常数 $k_B = 1$。压力必须以约化的 Lennard-Jones 单位（能量/体积）报告，即 $\\varepsilon/\\sigma^3$。物理参数：使用数密度 $\\rho = 0.85$ 和温度 $T = 1.10$。\n\n人造径向分布函数：为评估对采样的敏感性，从一个平滑、物理上合理的解析形式生成 $g(r)$，该形式抑制了硬核区域并表现出趋近于1的阻尼振荡。使用\n$$\nS(r) = \\tfrac{1}{2}\\left[1 + \\tanh\\!\\left(\\frac{r - r_c}{w}\\right)\\right],\\quad r_c = 0.95,\\quad w = 0.02,\n$$\n和\n$$\ng_{\\text{raw}}(r) = 1 + A\\,e^{-\\alpha\\,(r - r_1)}\\sin\\!\\big(\\beta\\,(r - r_1)\\big),\\quad A = 1.50,\\ \\alpha = 1.80,\\ \\beta = 7.00,\\ r_1 = 1.10,\n$$\n然后定义\n$$\ng(r) = S(r)\\,\\max\\!\\big(0,\\,g_{\\text{raw}}(r)\\big).\n$$\n这个 $g(r)$ 是非负的，在核心区域为零，在 $r \\approx r_1$ 附近表现出第一个峰值，并以阻尼振荡的方式衰减至1，这与简单流体的行为一致。\n\n对势及其导数：在约化单位中，Lennard-Jones 势为\n$$\nU(r) = 4\\left[\\left(\\frac{1}{r}\\right)^{12} - \\left(\\frac{1}{r}\\right)^{6}\\right],\n$$\n其径向导数为\n$$\nU'(r) = 4\\left[-12\\,r^{-13} + 6\\,r^{-7}\\right].\n$$\n\n数值评估策略：在径向网格 $\\{r_i\\}$ 上使用数值积分来近似维里积分。由于下面的网格可能不均匀，因此在离散点集上使用复合梯形法则来近似 $\\int g(r)\\,r^3\\,U'(r)\\,dr$。通过假设对于大的 $r$ 有 $g(r)\\to 1$，并将 $r^3 U'(r)$ 从最大网格半径 $r_{\\max}$ 到无穷大进行解析积分，来应用一个具有物理动机的长程尾部校正。在约化的 Lennard-Jones 单位中，精确的尾部积分是\n$$\n\\int_{r_{\\max}}^{\\infty} r^3 U'(r)\\,dr = \\frac{16}{3}\\,r_{\\max}^{-9} - 8\\,r_{\\max}^{-3}.\n$$\n\n参考压力：通过在一个均匀的细密网格上（$r_{\\min} = 0.30$，$r_{\\max} = 6.00$，$\\Delta r_{\\text{ref}} = 0.001$）评估压力来构建一个高质量的参考值，并包含相同的长程尾部校正。使用此参考压力计算下面测试用例的绝对误差。\n\n敏感性度量：对于每个测试用例，计算在测试网格上获得的压力与参考压力之间的绝对差值。报告压力和这个绝对误差。\n\n测试套件：为以下五种采样场景评估压力，以评估对短程采样质量的敏感性：\n- 情况1（均匀细密）：$r_{\\min} = 0.30$，$r_{\\max} = 5.00$，$\\Delta r = 0.002$。\n- 情况2（均匀粗糙）：$r_{\\min} = 0.30$，$r_{\\max} = 5.00$，$\\Delta r = 0.020$。\n- 情况3（短程粗糙、长程细密）：粗糙段 $[0.30, 1.20)$，$\\Delta r = 0.050$；细密段 $[1.20, 5.00]$，$\\Delta r = 0.005$。\n- 情况4（截断核心区域）：网格从 $r_{\\min} = 1.00$ 开始，$\\Delta r = 0.005$，直到 $r_{\\max} = 5.00$；假设对于 $r  r_{\\min}$ 时 $g(r) = 0$，这突显了对缺失短程结构的敏感性。\n- 情况5（短程细密、长程粗糙）：细密段 $[0.30, 2.00)$，$\\Delta r = 0.002$；粗糙段 $[2.00, 5.00]$，$\\Delta r = 0.050$。\n\n算法要求：\n- 从维里定理和径向分布函数定义出发，推导各向同性流体在成对相加力作用下的压力表达式，而不是一开始就假设最终的目标积分形式。\n- 对于每个网格，使用复合梯形法则在 $\\{r_i\\}$ 上计算离散积分：用 $\\sum_i w_i\\,g(r_i)\\,r_i^3\\,U'(r_i)$ 来近似 $\\int_{r_{\\min}}^{r_{\\max}} g(r)\\,r^3\\,U'(r)\\,dr$，其中梯形权重 $w_i$ 基于相邻点间距。\n- 应用如上所述的长程尾部校正 $\\int_{r_{\\max}}^{\\infty} r^3 U'(r)\\,dr$，其中 $g(r)\\to 1$。\n- 计算每种情况下相对于参考值的压力和绝对误差。\n- 所有压力均以 $\\varepsilon/\\sigma^3$ 表示，并在最终输出中四舍五入到6位小数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表形式的结果。每个内部列表包含一个测试用例的压力和绝对误差，两者均为浮点数并四舍五入到六位小数，按情况1到5的顺序排列。例如，格式必须是\n$$\n\\big[ [p_1,e_1], [p_2,e_2], [p_3,e_3], [p_4,e_4], [p_5,e_5] \\big].\n$$", "solution": "该问题要求推导经典各向同性流体的维里状态方程以计算压力，并针对一个模型系统进行数值实现。推导必须从经典维里定理和径向分布函数的定义开始。\n\n### 维里压力方程的推导\n\n经典维里定理将系统动能的时间平均值与作用在粒子上的总力的维里的时间平均值联系起来。对于一个包含 $N$ 个粒子、位置为 $\\mathbf{r}_i$、动量为 $\\mathbf{p}_i$ 的系统，该定理表述为：\n$$\n\\left\\langle \\sum_{i=1}^N \\frac{\\mathbf{p}_i^2}{m_i} \\right\\rangle = - \\left\\langle \\sum_{i=1}^N \\mathbf{r}_i \\cdot \\mathbf{F}_i^{\\text{tot}} \\right\\rangle\n$$\n其中 $\\langle \\cdot \\rangle$ 表示时间平均（对于处于平衡状态的遍历系统，这等同于系综平均），$\\mathbf{F}_i^{\\text{tot}}$ 是作用在粒子 $i$ 上的总力。\n\n左侧是平均总动能 $\\langle 2K \\rangle$ 的两倍。根据处于温度 $T$ 的热平衡系统中的能量均分原理，平均动能为 $\\langle K \\rangle = \\frac{3}{2}N k_B T$，其中 $k_B$ 是玻尔兹曼常数。因此，维里定理的左侧为 $3N k_B T$。\n\n作用在粒子 $i$ 上的总力 $\\mathbf{F}_i^{\\text{tot}}$ 是由容器壁施加的外力 $\\mathbf{F}_i^{\\text{ext}}$ 和系统中其他粒子施加的内力 $\\mathbf{F}_i^{\\text{int}}$ 的总和。力的维里可以相应地分开：\n$$\n\\sum_{i=1}^N \\mathbf{r}_i \\cdot \\mathbf{F}_i^{\\text{tot}} = \\sum_{i=1}^N \\mathbf{r}_i \\cdot \\mathbf{F}_i^{\\text{ext}} + \\sum_{i=1}^N \\mathbf{r}_i \\cdot \\mathbf{F}_i^{\\text{int}}\n$$\n外力项与宏观压力 $P$ 相关。由壁施加在流体上的力为 $-P \\oint_S d\\mathbf{S}$，其中积分遍及容器表面 $S$。此力的维里为 $\\sum_i \\mathbf{r}_i \\cdot \\mathbf{F}_i^{\\text{ext}} = -P \\oint_S \\mathbf{r} \\cdot d\\mathbf{S}$。使用散度定理，$\\oint_S \\mathbf{r} \\cdot d\\mathbf{S} = \\int_V (\\nabla \\cdot \\mathbf{r}) dV = \\int_V 3 dV = 3V$。因此，外力维里为 $-3PV$。\n\n内力项源于成对相互作用。假设存在成对相加的中心力，粒子 $i$ 上的力为 $\\mathbf{F}_i^{\\text{int}} = \\sum_{j \\neq i} \\mathbf{F}_{ij}$，其中 $\\mathbf{F}_{ij}$ 是粒子 $j$ 对粒子 $i$ 的作用力。内力维里为：\n$$\n\\mathcal{W}_{\\text{int}} = \\sum_{i=1}^N \\mathbf{r}_i \\cdot \\left( \\sum_{j \\neq i} \\mathbf{F}_{ij} \\right) = \\sum_{i \\neq j} \\mathbf{r}_i \\cdot \\mathbf{F}_{ij}\n$$\n这个和可以通过对粒子对 $(i, j)$ 进行分组来重写：\n$$\n\\mathcal{W}_{\\text{int}} = \\sum_{i  j} (\\mathbf{r}_i \\cdot \\mathbf{F}_{ij} + \\mathbf{r}_j \\cdot \\mathbf{F}_{ji})\n$$\n根据牛顿第三定律，$\\mathbf{F}_{ji} = -\\mathbf{F}_{ij}$。令 $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$。\n$$\n\\mathcal{W}_{\\text{int}} = \\sum_{i  j} (\\mathbf{r}_i - \\mathbf{r}_j) \\cdot \\mathbf{F}_{ij} = \\sum_{i  j} \\mathbf{r}_{ij} \\cdot \\mathbf{F}_{ij}\n$$\n由于力是中心力，由对势 $U(r)$ 导出，即 $\\mathbf{F}_{ij} = -U'(r_{ij}) \\hat{\\mathbf{r}}_{ij}$，其中 $r_{ij} = |\\mathbf{r}_{ij}|$。因此，点积变为 $\\mathbf{r}_{ij} \\cdot \\mathbf{F}_{ij} = -r_{ij} U'(r_{ij})$。\n\n现在，我们将维里的系综平均值 $\\langle \\mathcal{W}_{\\text{int}} \\rangle$ 与径向分布函数 $g(r)$ 联系起来。$g(r)$ 给出了在距离一个粒子 $r$ 处找到另一个粒子的相对概率。以任意一个粒子为参考，在距离它 $r$ 到 $r+dr$ 的球壳中，找到其他粒子的平均数量是 $\\rho g(r) 4\\pi r^2 dr$。由于系统中有 $N$ 个粒子，并且每个粒子对只计算一次，因此对所有粒子对求和等效于：\n$$\n\\langle \\mathcal{W}_{\\text{int}} \\rangle = \\frac{N}{2} \\int_0^\\infty (-r U'(r)) \\rho g(r) 4\\pi r^2 dr = -2\\pi N \\rho \\int_0^\\infty r^3 U'(r) g(r) dr\n$$\n将所有项代入维里定理 $3N k_B T = -\\langle \\sum_i \\mathbf{r}_i \\cdot \\mathbf{F}_i^{\\text{tot}} \\rangle = -(-3PV + \\langle\\mathcal{W}_{\\text{int}}\\rangle) = 3PV - \\langle\\mathcal{W}_{\\text{int}}\\rangle$：\n$$\n3N k_B T = 3PV + 2\\pi N \\rho \\int_0^\\infty r^3 U'(r) g(r) dr\n$$\n两边同时除以 $3V$ 并用 $\\rho=N/V$ 替换，得到压力的最终表达式：\n$$\nP = \\rho k_B T - \\frac{2\\pi \\rho^2}{3} \\int_0^\\infty r^3 U'(r) g(r) dr\n$$\n这个方程是连接微观结构 ($g(r)$)、相互作用 ($U'(r)$) 和宏观热力学性质 (压力 $P$) 的核心。数值实现将包括计算动能项（理想气体压力）和对考虑了粒子间力的修正项进行数值积分。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements the virial equation of state to calculate the pressure\n    of a Lennard-Jones fluid and assesses its sensitivity to the quality of\n    radial distribution function sampling.\n    \"\"\"\n    \n    # Physical parameters in reduced Lennard-Jones units\n    RHO = 0.85  # Number density\n    T_ = 1.10   # Temperature\n\n    # Parameters for the synthetic radial distribution function g(r)\n    G_R_PARAMS = {\n        'rc': 0.95, 'w': 0.02,\n        'A': 1.50, 'alpha': 1.80, 'beta': 7.00, 'r1': 1.10\n    }\n\n    def g_r(r: np.ndarray) - np.ndarray:\n        \"\"\"\n        Computes the synthetic, physically plausible radial distribution function g(r).\n        \n        Args:\n            r: A NumPy array of radial distances.\n            \n        Returns:\n            A NumPy array of g(r) values.\n        \"\"\"\n        p = G_R_PARAMS\n        s_r = 0.5 * (1.0 + np.tanh((r - p['rc']) / p['w']))\n        g_raw = 1.0 + p['A'] * np.exp(-p['alpha'] * (r - p['r1'])) * np.sin(p['beta'] * (r - p['r1']))\n        g_raw_non_negative = np.maximum(0.0, g_raw)\n        return s_r * g_raw_non_negative\n\n    def dU_lj_dr(r: np.ndarray) - np.ndarray:\n        \"\"\"\n        Computes the radial derivative of the Lennard-Jones potential, U'(r).\n        \n        Args:\n            r: A NumPy array of radial distances.\n            \n        Returns:\n            A NumPy array of dU/dr values.\n        \"\"\"\n        r_inv = 1.0 / r\n        r_inv7 = r_inv**7\n        r_inv13 = r_inv**13\n        return 4.0 * (-12.0 * r_inv13 + 6.0 * r_inv7)\n\n    def tail_correction(r_max: float) - float:\n        \"\"\"\n        Computes the analytical tail correction for the virial integral, assuming g(r)=1.\n        \n        Args:\n            r_max: The cutoff radius of the numerical integration.\n            \n        Returns:\n            The value of the integral from r_max to infinity.\n        \"\"\"\n        r_max_inv3 = r_max**-3\n        r_max_inv9 = r_max**-9\n        return (16.0 / 3.0) * r_max_inv9 - 8.0 * r_max_inv3\n\n    def calculate_pressure(r_grid: np.ndarray, rho: float, T: float) - float:\n        \"\"\"\n        Calculates the pressure using the virial equation for a given radial grid.\n        \n        Args:\n            r_grid: The NumPy array of radial grid points.\n            rho: The number density.\n            T: The temperature.\n            \n        Returns:\n            The calculated pressure.\n        \"\"\"\n        if r_grid.size == 0:\n            # Handle empty grid case (e.g., truncated region with r_min  r_max)\n            # The numerical part of the integral is zero.\n            # But we need a valid r_max for tail correction. This case shouldn't happen with given inputs.\n            # For Case 4, grid starts at 1.0, so this is not empty.\n            numerical_integral = 0.0\n            tail_integral = 0.0 # Or based on r_min, depends on problem def.\n        else:\n            g_vals = g_r(r_grid)\n            dU_vals = dU_lj_dr(r_grid)\n            \n            integrand = g_vals * dU_vals * (r_grid**3)\n            \n            # Use composite trapezoidal rule for (potentially) non-uniform grids\n            numerical_integral = np.trapz(integrand, x=r_grid)\n            \n            r_max = r_grid[-1]\n            tail_integral = tail_correction(r_max)\n        \n        total_integral = numerical_integral + tail_integral\n        \n        # Virial pressure equation\n        pressure = rho * T - (2.0 * np.pi * rho**2 / 3.0) * total_integral\n        return pressure\n\n    # --- Reference Calculation ---\n    r_ref = np.arange(0.30, 6.00 + 0.001 / 2, 0.001)\n    p_ref = calculate_pressure(r_ref, RHO, T_)\n    \n    # --- Test Suite ---\n    # Case 1: Uniform fine grid\n    case1_grid = np.arange(0.30, 5.00 + 0.002 / 2, 0.002)\n    \n    # Case 2: Uniform coarse grid\n    case2_grid = np.arange(0.30, 5.00 + 0.020 / 2, 0.020)\n\n    # Case 3: Mixed coarse short-range, fine long-range\n    case3_grid_p1 = np.arange(0.30, 1.20, 0.050)\n    case3_grid_p2 = np.arange(1.20, 5.00 + 0.005 / 2, 0.005)\n    case3_grid = np.concatenate((case3_grid_p1, case3_grid_p2))\n\n    # Case 4: Truncated core region\n    case4_grid = np.arange(1.00, 5.00 + 0.005 / 2, 0.005)\n\n    # Case 5: Mixed fine short-range, coarse long-range\n    case5_grid_p1 = np.arange(0.30, 2.00, 0.002)\n    case5_grid_p2 = np.arange(2.00, 5.00 + 0.050 / 2, 0.050)\n    case5_grid = np.concatenate((case5_grid_p1, case5_grid_p2))\n\n    test_grids = [case1_grid, case2_grid, case3_grid, case4_grid, case5_grid]\n    \n    results = []\n    for grid in test_grids:\n        p_case = calculate_pressure(grid, RHO, T_)\n        error = abs(p_case - p_ref)\n        results.append([round(p_case, 6), round(error, 6)])\n\n    # Format output as a string representation of a list of lists.\n    # The str() of a list adds spaces, matching the visual style of the example output.\n    # Joining these string representations with a comma produces the final format.\n    # Example: str([1.23, 4.56]) - '[1.23, 4.56]'\n    # ','.join(['[1.23, 4.56]', '[7.89, 0.12]']) - '[1.23, 4.56],[7.89, 0.12]'\n    # Final output: '[[1.23, 4.56],[7.89, 0.12]]'\n    final_output_str = f\"[{','.join(map(str, results))}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "3483653"}, {"introduction": "虽然 $g(r)$ 在实空间中描述结构，但许多实验技术（如X射线或中子散射）通过静态结构因子 $S(k)$ 在倒易空间中探测结构。本练习聚焦于连接 $g(r)$ 和 $S(k)$ 的傅里叶变换，并处理因有限模拟数据截断而产生的实际挑战——截断伪影。您将应用窗函数来减轻这些伪影，并分析实空间精度与倒易空间保真度之间的权衡。[@problem_id:3483631]", "problem": "要求您仅使用已确立的定义，实现并分析有限范围截断和加窗对径向分布函数与静态结构因子之间傅里叶变换关系的影响。考虑一个三维各向同性流体，其数密度为 $\\rho$，径向分布函数为 $g(r)$，其中 $r$ 是标量粒子间距离。静态结构因子 $S(k)$ 作为波数 $k$ 的函数，由总相关函数 $h(r) \\equiv g(r) - 1$ 的各向同性傅里叶变换定义：\n$$\nS(k) \\equiv 1 + 4\\pi \\rho \\int_{0}^{\\infty} r^{2} h(r) \\frac{\\sin(kr)}{kr} \\, dr.\n$$\n在实践中，数值计算使用间距为 $\\Delta r$ 的均匀网格，在 $r \\in [0, R_{\\max}]$ 的有限域上进行近似，以替代无限积分。在 $R_{\\max}$ 处的急剧截断会在 $S(k)$ 中引入混叠和吉布斯状振荡，这是由于在实空间中与矩形窗函数相乘的等效效应。一种常见的缓解方法是在变换前对 $h(r)$ 应用一个锥化（窗）函数 $W(r)$，以减少截断涟波，但代价是会产生实空间畸变。需要考虑的两个此类窗函数是：\n- Lorch窗: $W_{\\mathrm{L}}(r) = \\dfrac{\\sin\\left(\\pi r / R_{\\max}\\right)}{\\pi r / R_{\\max}}$ 对于 $0 \\le r \\le R_{\\max}$，其他情况为 $0$。\n- Hann（升余弦）窗: $W_{\\mathrm{H}}(r) = \\dfrac{1 + \\cos\\left(\\pi r / R_{\\max}\\right)}{2}$ 对于 $0 \\le r \\le R_{\\max}$，其他情况为 $0$。\n\n您的任务是：\n1. 使用上述 $S(k)$ 的定义作为起点。\n2. 在均匀网格 $r_n = n \\Delta r$（其中 $n = 0, 1, \\dots, N$ 且 $N \\Delta r = R_{\\max}$）上对 $r$ 的积分进行离散化，使用适合平滑被积函数的数值稳定法则。\n3. 实现 $r$ 空间变换被积函数的三种加窗选择 $W(r)$：无窗（在 $[0,R_{\\max}]$ 上 $W(r) = 1$，其他情况为 $0$）、Lorch窗 $W_{\\mathrm{L}}(r)$ 和 Hann窗 $W_{\\mathrm{H}}(r)$，如上定义。\n4. 通过在更大的域 $[0, R_{\\mathrm{ref}}]$ 上使用精细间距 $\\Delta r_{\\mathrm{ref}}$ 计算相同的积分（使用无窗情况）来定义一个参考 $S_{\\mathrm{ref}}(k)$，以近似无限域变换。\n5. 使用均方根误差 (RMSE) 在指定的 $k$ 网格上量化倒易空间混叠：\n$$\n\\mathrm{RMSE}[S] \\equiv \\sqrt{ \\frac{1}{M} \\sum_{m=1}^{M} \\left(S(k_m) - S_{\\mathrm{ref}}(k_m)\\right)^2 }.\n$$\n6. 通过在 $[0,R_{\\max}]$ 上由加窗在 $h(r)$ 中引起的归一化 $L^2$ 变化来量化实空间畸变：\n$$\nD_{\\mathrm{real}}[W] \\equiv \\sqrt{ \\frac{\\int_{0}^{R_{\\max}} \\left( W(r) h(r) - h(r) \\right)^2 dr}{\\int_{0}^{R_{\\max}} h(r)^2 dr} }.\n$$\n注意，根据构造，对于无窗情况，$D_{\\mathrm{real}}[W] = 0$。\n\n为了科学真实性，请使用以下物理上合理的模型和参数（所有量都必须使用指定的单位来实现）：\n- 数密度: $\\rho = 0.033 \\,\\mathrm{\\AA}^{-3}$。\n- 径向分布函数的模型: $g(r) = 1 + A \\exp\\!\\left(-\\dfrac{(r - r_0)^2}{2\\sigma^2}\\right) + B \\exp\\!\\left(-\\dfrac{(r - r_1)^2}{2\\sigma_1^2}\\right)$，参数为 $A = 2.5$，$r_0 = 2.8\\,\\mathrm{\\AA}$，$\\sigma = 0.15\\,\\mathrm{\\AA}$，$B = 0.8$，$r_1 = 4.5\\,\\mathrm{\\AA}$，$\\sigma_1 = 0.25\\,\\mathrm{\\AA}$，因此 $h(r) = g(r) - 1$。\n- 参考变换参数: $R_{\\mathrm{ref}} = 30\\,\\mathrm{\\AA}$，$\\Delta r_{\\mathrm{ref}} = 0.005\\,\\mathrm{\\AA}$。\n- 用于误差评估的波数网格: $k_m = m \\Delta k$ 对于 $m = 0, 1, \\dots, 300$，其中 $\\Delta k = 0.05\\,\\mathrm{\\AA}^{-1}$，因此 $k \\in [0, 15]\\,\\mathrm{\\AA}^{-1}$。\n\n测试套件。评估以下三个有限域案例，每个案例都使用其自身的 $(R_{\\max}, \\Delta r)$ 进行截断变换，并在每个案例中比较三种加窗选择：\n- 案例1（强截断）: $R_{\\max} = 6.0\\,\\mathrm{\\AA}$，$\\Delta r = 0.01\\,\\mathrm{\\AA}$。\n- 案例2（中等截断）: $R_{\\max} = 10.0\\,\\mathrm{\\AA}$，$\\Delta r = 0.01\\,\\mathrm{\\AA}$。\n- 案例3（中等截断，粗采样）: $R_{\\max} = 10.0\\,\\mathrm{\\AA}$，$\\Delta r = 0.05\\,\\mathrm{\\AA}$。\n\n对于每个案例，计算：\n- 无窗、Lorch窗和Hann窗的 $\\mathrm{RMSE}[S]$，每个都与指定 $k$ 网格上的 $S_{\\mathrm{ref}}(k)$ 进行比较。\n- Lorch窗和Hann窗的 $D_{\\mathrm{real}}[W]$。\n\n所有积分和变换都必须以规定的单位进行：$r$ 的单位是 $\\mathrm{\\AA}$，$k$ 的单位是 $\\mathrm{\\AA}^{-1}$。结构因子 $S(k)$ 和畸变是无量纲的。没有出现角度，因此不需要角度单位。\n\n您的程序必须生成单行输出，其中包含三个案例的连接结果，按以下顺序以逗号分隔的列表形式，并用方括号括起来：\n- 案例1：无窗、Lorch、Hann的 $\\mathrm{RMSE}[S]$，然后是Lorch、Hann的 $D_{\\mathrm{real}}$。\n- 案例2：按相同顺序排列的五个量。\n- 案例3：按相同顺序排列的五个量。\n\n示例格式（数字为占位符）：\n[rmse_none_case1,rmse_lorch_case1,rmse_hann_case1,dist_lorch_case1,dist_hann_case1,rmse_none_case2,rmse_lorch_case2,rmse_hann_case2,dist_lorch_case2,dist_hann_case2,rmse_none_case3,rmse_lorch_case3,rmse_hann_case3,dist_lorch_case3,dist_hann_case3]\n\n您的实现必须是一个完整、可运行的程序，不需要输入也不需要外部文件。它必须通过数值计算上述积分来计算所有请求的量，并以确切指定的输出格式打印结果。没有强制要求四舍五入到特定的有效数字；使用您语言的默认或一致的浮点数格式化选择输出实数。", "solution": "我们从三维均匀各向同性系统中，各向同性静态结构因子与径向分布函数之间经过充分检验的关系开始：\n$$\nS(k) = 1 + 4\\pi \\rho \\int_{0}^{\\infty} r^{2} \\, h(r) \\, \\frac{\\sin(kr)}{kr} \\, dr,\n$$\n其中 $h(r) \\equiv g(r) - 1$，$\\rho$ 是数密度。这个恒等式源于静态结构因子的定义，即均匀介质中对相关函数的傅里叶变换，以及对平面波因子进行角度平均，从而得到球贝塞尔函数 $j_0(kr) = \\sin(kr)/(kr)$。\n\n当无限域积分被在 $r \\in [0,R_{\\max}]$ 上的有限域近似所替代，并带有急剧截断（矩形窗）$W_{\\mathrm{rect}}(r) = 1$（对于 $0 \\le r \\le R_{\\max}$，其他情况为 $0$）时，就会产生截断混叠。在实空间中将 $h(r)$ 与 $W_{\\mathrm{rect}}(r)$ 相乘，在倒易空间中对应于将真实的变换与矩形窗的傅里叶变换进行卷积，后者与一个类sinc函数成正比。由于sinc函数具有缓慢衰减的旁瓣，这种卷积会在 $S(k)$ 中产生特征性的振荡涟波（吉布斯现象），尤其是在尖锐特征附近。为了减轻这种涟波，可以应用一个更平滑的窗函数 $W(r)$，它在 $R_{\\max}$ 处逐渐衰减至零，并且其傅里叶变换在大 $k$ 值处衰减得更快，从而减少旁瓣，但代价是展宽了卷积核。Lorch窗和Hann窗是常用的选择：\n- Lorch窗: $W_{\\mathrm{L}}(r) = \\dfrac{\\sin(\\pi r / R_{\\max})}{\\pi r / R_{\\max}}$，它消除了 $R_{\\max}$ 处的不连续性，并用一个具有类三角变换的核取代了矩形窗，从而抑制高频分量。\n- Hann（升余弦）窗: $W_{\\mathrm{H}}(r) = \\dfrac{1 + \\cos(\\pi r / R_{\\max})}{2}$ 对于 $r \\in [0,R_{\\max}]$，确保了在边界处函数及其导数的光滑性，这进一步抑制了高 $k$ 值的泄漏。\n\n数值变换设计。我们在均匀网格 $r_n = n \\Delta r$（其中 $n = 0, \\dots, N$ 且 $N \\Delta r = R_{\\max}$）上对 $r$ 进行离散化。对于指定的 $k$ 网格 $k_m = m \\Delta k$（其中 $m = 0, \\dots, M$），我们使用复合梯形法则来近似积分，该法则适用于平滑的被积函数。令 $h_n = h(r_n)$ 并定义加窗序列 $h^{(W)}_n = W(r_n) h_n$。对于每个 $k_m$，定义 $j_{0,mn} = \\sin(k_m r_n)/(k_m r_n)$，并在 $k_0 = 0$ 处取极限值 $j_{0,0n} = 1$。然后我们近似\n$$\nS^{(W)}(k_m) \\approx 1 + 4\\pi \\rho \\sum_{n=0}^{N} w_n \\, r_n^2 \\, h^{(W)}_n \\, j_{0,mn},\n$$\n其中 $w_n$ 是梯形权重，$w_0 = w_N = \\tfrac{1}{2} \\Delta r$，其他情况下 $w_n = \\Delta r$。对于无窗情况，$W(r) = 1$ 在 $[0,R_{\\max}]$ 上，其他情况为零。\n\n参考变换。为了近似真实的无限域积分，我们通过采用更大的截断半径 $R_{\\mathrm{ref}}$ 和更精细的间距 $\\Delta r_{\\mathrm{ref}}$，并使用相同的梯形法则且不加锥化，来计算一个高质量的数值参考 $S_{\\mathrm{ref}}(k)$。对于我们的模型，即一对正高斯峰，总相关函数 $h(r)$ 衰减迅速，因此 $R_{\\mathrm{ref}} = 30\\,\\mathrm{\\AA}$ 和 $\\Delta r_{\\mathrm{ref}} = 0.005\\,\\mathrm{\\AA}$ 足以产生收敛的结果，用于对有限域变换进行基准测试。\n\n误差度量。为量化倒易空间混叠，我们计算均方根误差\n$$\n\\mathrm{RMSE}[S] = \\sqrt{\\frac{1}{M+1} \\sum_{m=0}^{M} \\left(S^{(W)}(k_m) - S_{\\mathrm{ref}}(k_m)\\right)^2}\n$$\n在指定的 $k$ 网格 $k_m = m \\Delta k$ 上，其中 $m=0,\\dots,M$，$\\Delta k = 0.05\\,\\mathrm{\\AA}^{-1}$ 且 $M = 300$。为量化由窗函数引起的实空间形变，我们评估\n$$\nD_{\\mathrm{real}}[W] = \\sqrt{ \\frac{\\int_{0}^{R_{\\max}} \\left( W(r) h(r) - h(r) \\right)^2 dr}{\\int_{0}^{R_{\\max}} h(r)^2 dr} } \\approx \\sqrt{ \\frac{\\sum_{n=0}^{N} w_n \\left( (W(r_n) - 1) h_n \\right)^2 }{\\sum_{n=0}^{N} w_n h_n^2} }.\n$$\n根据定义，对于无窗情况，$D_{\\mathrm{real}}[W] = 0$。\n\n模型和参数。我们选择 $\\rho = 0.033\\,\\mathrm{\\AA}^{-3}$ 和\n$$\ng(r) = 1 + A \\exp\\left(-\\frac{(r - r_0)^2}{2\\sigma^2}\\right) + B \\exp\\left(-\\frac{(r - r_1)^2}{2\\sigma_1^2}\\right),\n$$\n其中 $A = 2.5$，$r_0 = 2.8\\,\\mathrm{\\AA}$，$\\sigma = 0.15\\,\\mathrm{\\AA}$，$B = 0.8$，$r_1 = 4.5\\,\\mathrm{\\AA}$，$\\sigma_1 = 0.25\\,\\mathrm{\\AA}$，因此 $h(r) = g(r) - 1$ 是两个快速衰减的高斯峰的叠加，使其非常适合进行变换分析。\n\n实现的算法步骤：\n1. 如上定义 $h(r)$，并为三种窗函数实现函数：无窗、Lorch窗 $W_{\\mathrm{L}}(r)$ 和 Hann窗 $W_{\\mathrm{H}}(r)$。对于Lorch窗，使用归一化sinc函数在数值上是稳健的：$\\mathrm{sinc}(x) \\equiv \\sin(\\pi x)/(\\pi x)$，所以 $W_{\\mathrm{L}}(r) = \\mathrm{sinc}(r/R_{\\max})$；通过极限 $W_{\\mathrm{L}}(0) = 1$ 来处理 $r=0$ 的情况。对于Hann窗，使用 $W_{\\mathrm{H}}(r) = \\tfrac{1 + \\cos(\\pi r / R_{\\max})}{2}$ 对于 $r \\in [0,R_{\\max}]$。\n2. 使用 $\\Delta r_{\\mathrm{ref}}$ 构建精细的参考网格 $r \\in [0,R_{\\mathrm{ref}}]$，并通过对 $j_0(kr)$ 进行向量化计算，在指定的 $k$ 网格上计算 $S_{\\mathrm{ref}}(k)$，同时小心处理 $k=0$ 的极限情况。\n3. 对于每个测试案例 $(R_{\\max}, \\Delta r)$，构建其 $r$ 网格并计算 $W \\in \\{\\text{无窗}, \\text{Lorch}, \\text{Hann}\\}$ 的 $S^{(W)}(k)$，然后计算相对于 $S_{\\mathrm{ref}}(k)$ 的 $\\mathrm{RMSE}[S]$，并在相同的 $r$ 网格上计算Lorch窗和Hann窗的 $D_{\\mathrm{real}}[W]$。\n4. 按指定顺序汇总结果，并将其作为单个逗号分隔的列表打印在方括号中。\n\n科学解释。由于急剧截断引起的sinc振铃效应，无窗情况在 $R_{\\max}$ 较小时表现出较大的 $\\mathrm{RMSE}[S]$。Lorch窗和Hann窗通过在 $[0,R_{\\max}]$ 上修改 $h(r)$ 来减少这种混叠，其代价由 $D_{\\mathrm{real}}[W]$ 捕捉。通常，与Lorch窗相比，Hann窗能更强地抑制高频涟波（较低的 $\\mathrm{RMSE}[S]$），但会产生稍大的实空间畸变（较高的 $D_{\\mathrm{real}}[W]$）；随着 $R_{\\max}$ 增大或采样变得更精细，所有方法都趋近于参考值，$\\mathrm{RMSE}[S]$ 和 $D_{\\mathrm{real}}[W]$ 都会减小，这说明了截断、窗函数平滑度和倒易空间精度之间的权衡。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef g_model(r):\n    # Parameters for the model RDF g(r) = 1 + sum of Gaussians\n    A, r0, sigma = 2.5, 2.8, 0.15\n    B, r1, sigma1 = 0.8, 4.5, 0.25\n    return 1.0 + A * np.exp(-0.5 * ((r - r0) / sigma) ** 2) + B * np.exp(-0.5 * ((r - r1) / sigma1) ** 2)\n\ndef h_model(r):\n    return g_model(r) - 1.0\n\ndef window_none(r, Rmax):\n    # 1 on [0, Rmax], 0 otherwise (handled by truncating the r grid)\n    return np.ones_like(r)\n\ndef window_lorch(r, Rmax):\n    # W_L(r) = sinc(r / Rmax) with numpy's normalized sinc: sinc(x) = sin(pi x)/(pi x)\n    x = r / Rmax\n    return np.sinc(x)\n\ndef window_hann(r, Rmax):\n    # Raised-cosine (Hann) window: W_H(r) = 0.5*(1 + cos(pi r / Rmax)) for r in [0,Rmax]\n    return 0.5 * (1.0 + np.cos(np.pi * r / Rmax))\n\ndef j0_kernel(k, r):\n    # Compute j0(kr) = sin(kr)/(kr), handling kr=0\n    kr = k[:, None] * r[None, :]\n    j0 = np.ones_like(kr)\n    mask = kr != 0.0\n    j0[mask] = np.sin(kr[mask]) / kr[mask]\n    return j0\n\ndef structure_factor_from_h(r, h, rho, k_grid, window_func, Rmax):\n    # Apply window and compute S(k) via trapezoidal rule\n    W = window_func(r, Rmax)\n    hw = h * W\n    r2_hw = (r ** 2) * hw  # shape (Nr,)\n    # Kernel matrix j0(kr)\n    j0 = j0_kernel(k_grid, r)  # shape (Nk, Nr)\n    integrand = j0 * r2_hw[None, :]  # broadcast to (Nk, Nr)\n    # Trapezoidal integration over r axis\n    S = 1.0 + 4.0 * np.pi * rho * np.trapz(integrand, r, axis=1)\n    return S\n\ndef real_space_distortion(r, h, window_func, Rmax):\n    W = window_func(r, Rmax)\n    num = np.trapz(((W - 1.0) * h) ** 2, r)\n    denom = np.trapz(h ** 2, r)\n    # Avoid division by zero in pathological cases\n    if denom == 0.0:\n        return 0.0\n    return float(np.sqrt(num / denom))\n\ndef compute_reference_S(rho, k_grid):\n    # Reference parameters\n    Rref = 30.0  # Angstrom\n    dr_ref = 0.005  # Angstrom\n    r_ref = np.arange(0.0, Rref + dr_ref / 2, dr_ref)\n    h_ref = h_model(r_ref)\n    S_ref = structure_factor_from_h(r_ref, h_ref, rho, k_grid, window_none, Rref)\n    return S_ref\n\ndef rmse(a, b):\n    diff = a - b\n    return float(np.sqrt(np.mean(diff * diff)))\n\ndef solve():\n    rho = 0.033  # 1/Angstrom^3\n    # k-grid for evaluation\n    dk = 0.05  # 1/Angstrom\n    k_max = 15.0\n    k_grid = np.arange(0.0, k_max + dk / 2, dk)\n\n    # Compute high-quality reference S(k)\n    S_ref = compute_reference_S(rho, k_grid)\n\n    # Test cases: (Rmax, dr)\n    test_cases = [\n        (6.0, 0.01),   # Case 1: strong truncation\n        (10.0, 0.01),  # Case 2: moderate truncation\n        (10.0, 0.05),  # Case 3: moderate truncation, coarse sampling\n    ]\n\n    results = []\n    for Rmax, dr in test_cases:\n        # r-grid for this truncated case\n        r = np.arange(0.0, Rmax + dr / 2, dr)\n        h = h_model(r)\n\n        # Compute S(k) for each window\n        S_none = structure_factor_from_h(r, h, rho, k_grid, window_none, Rmax)\n        S_lorch = structure_factor_from_h(r, h, rho, k_grid, window_lorch, Rmax)\n        S_hann = structure_factor_from_h(r, h, rho, k_grid, window_hann, Rmax)\n\n        # RMSEs relative to reference\n        rmse_none = rmse(S_none, S_ref)\n        rmse_lorch = rmse(S_lorch, S_ref)\n        rmse_hann = rmse(S_hann, S_ref)\n\n        # Real-space distortions\n        d_lorch = real_space_distortion(r, h, window_lorch, Rmax)\n        d_hann = real_space_distortion(r, h, window_hann, Rmax)\n\n        results.extend([\n            f\"{rmse_none:.8f}\",\n            f\"{rmse_lorch:.8f}\",\n            f\"{rmse_hann:.8f}\",\n            f\"{d_lorch:.8f}\",\n            f\"{d_hann:.8f}\",\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3483631"}]}