{"hands_on_practices": [{"introduction": "计算马德隆常数是检验任何埃瓦尔德求和方法实现的经典测试。它为我们提供了一个已知且精确的目标值，从而可以验证代码的正确性，并深入理解计算精度如何依赖于关键参数：分裂参数 $\\alpha$、实空间截断半径 $r_{\\mathrm{cut}}$ 和倒易空间截断 $m_{\\max}$。本练习将引导你从零开始构建埃瓦尔德求和机制的基础。[@problem_id:3462178]", "problem": "您需要设计并实现一个三维 (3D) 周期性数值实验，该实验在周期性边界条件 (PBC) 下使用艾瓦尔德求和法计算二元离子晶体的无量纲马德隆常数。该实验必须验证，在选择合适的参数后，艾瓦尔德求和的实现能够在指定的容差范围内复现已知的参考马德隆常数值，并且必须量化由实空间截断、倒易空间截断和分裂参数选择所引起的残余误差。程序必须是自包含的，并能针对固定的测试套件产生结果，无需读取外部输入。必须遵循以下基本原理：点电荷的库仑定律、电中性晶胞的周期性复制，以及通过将条件收敛的晶格和分解为在实空间和倒易空间中快速衰减的互补部分来处理其收敛性质。模拟晶胞中的所有距离都必须以立方晶格参数为单位表示，您必须将其设置为 $a = 1$，以使结果无量纲。最终答案不需要物理单位或角度单位。\n\n二元离子晶体的无量纲马德隆常数 $M$ 定义如下：在一个边长为 $a=1$ 的电中性周期性晶胞中，取位于位置 $\\mathbf{r}_j$ 的电荷 $q_j \\in \\{+1,-1\\}$，使用艾瓦尔德求和计算每个离子的总相互作用能，并用最近邻距离 $r_0$ 对其进行归一化，使得每个离子的能量为 $E_{\\text{ion}} = -M \\, (q^2 / r_0)$，其中 $q=1$。因此，当 $a=1$ 时，通过艾瓦尔德计算得到的无量纲估计值为 $M_{\\text{calc}} = - E_{\\text{ion}} \\, r_0$。\n\n您的实现必须：\n- 将每个晶体构建为一个边长为 $a=1$ 的周期性立方晶胞，并指定分数坐标基 $\\{ \\mathbf{s}_j \\}$ 和电荷 $\\{ q_j \\}$，其中真实位置为 $\\mathbf{r}_j = a \\, \\mathbf{s}_j$。\n- 使用艾瓦尔德分裂参数 $\\alpha > 0$、球形实空间截断半径 $r_{\\mathrm{cut}}$ 以及球形倒易空间指数截断 $m_{\\max}$，该截断通过 $\\sqrt{h^2+k^2+\\ell^2} \\le m_{\\max}$ 来限制倒易空间求和中的整数三元组 $(h,k,\\ell)$。程序必须能够针对每个测试用例改变 $(\\alpha, r_{\\mathrm{cut}}, m_{\\max})$。\n- 在实空间求和中排除零距离处的自相互作用，并包含适用于点电荷的标准自能修正。\n- 对于每个测试用例，返回相对于已知参考值 $M_{\\text{ref}}$ 的绝对误差 $\\left| M_{\\text{calc}} - M_{\\text{ref}} \\right|$。\n\n测试套件。实现以下四个测试用例，它们共同探测了“理想路径”、实空间分辨率不足、倒易空间分辨率不足以及边界情况截断。\n\n- 测试用例 1 (岩盐结构，良好平衡)：\n  - 晶体：氯化钠 (NaCl)，位于传统的立方面心晶胞中，每个晶胞含 8 个离子。\n  - 基（分数坐标 $\\mathbf{s}_j$）和电荷 $q_j$：\n    - 阳离子亚晶格 (Na+, $q=+1$)：$(0,0,0)$, $(0,\\tfrac{1}{2},\\tfrac{1}{2})$, $(\\tfrac{1}{2},0,\\tfrac{1}{2})$, $(\\tfrac{1}{2},\\tfrac{1}{2},0)$。\n    - 阴离子亚晶格 (Cl-, $q=-1$)：$(\\tfrac{1}{2},\\tfrac{1}{2},\\tfrac{1}{2})$, $(\\tfrac{1}{2},0,0)$, $(0,\\tfrac{1}{2},0)$, $(0,0,\\tfrac{1}{2})$。\n  - 最近邻距离 $r_0 = \\tfrac{1}{2}$。\n  - 参考马德隆常数 $M_{\\text{ref}} = 1.747564594$。\n  - 参数：$\\alpha = 6$, $r_{\\mathrm{cut}} = 6$, $m_{\\max} = 8$。\n\n- 测试用例 2 (氯化铯结构，实空间分辨率不足)：\n  - 晶体：氯化铯 (CsCl)，位于简单立方晶胞中，每个晶胞含 2 个离子。\n  - 基和电荷：\n    - $q=+1$ 位于 $(0,0,0)$，\n    - $q=-1$ 位于 $(\\tfrac{1}{2},\\tfrac{1}{2},\\tfrac{1}{2})$。\n  - 最近邻距离 $r_0 = \\tfrac{\\sqrt{3}}{2}$。\n  - 参考马德隆常数 $M_{\\text{ref}} = 1.762675$。\n  - 参数：$\\alpha = 1.5$, $r_{\\mathrm{cut}} = 3$, $m_{\\max} = 4$。\n\n- 测试用例 3 (闪锌矿结构，良好平衡)：\n  - 晶体：硫化锌 (ZnS，闪锌矿)，位于传统的立方面心晶胞中，每个晶胞含 8 个离子。\n  - 基和电荷：\n    - 阳离子亚晶格 (e.g., Zn, $q=+1$)：$(0,0,0)$, $(0,\\tfrac{1}{2},\\tfrac{1}{2})$, $(\\tfrac{1}{2},0,\\tfrac{1}{2})$, $(\\tfrac{1}{2},\\tfrac{1}{2},0)$。\n    - 阴离子亚晶格 (e.g., S, $q=-1$)，位移 $(\\tfrac{1}{4},\\tfrac{1}{4},\\tfrac{1}{4})$：$(\\tfrac{1}{4},\\tfrac{1}{4},\\tfrac{1}{4})$, $(\\tfrac{1}{4},\\tfrac{3}{4},\\tfrac{3}{4})$, $(\\tfrac{3}{4},\\tfrac{1}{4},\\tfrac{3}{4})$, $(\\tfrac{3}{4},\\tfrac{3}{4},\\tfrac{1}{4})$。\n  - 最近邻距离 $r_0 = \\tfrac{\\sqrt{3}}{4}$。\n  - 参考马德隆常数 $M_{\\text{ref}} = 1.638055$。\n  - 参数：$\\alpha = 5$, $r_{\\mathrm{cut}} = 6$, $m_{\\max} = 8$。\n\n- 测试用例 4 (岩盐结构边界情况，紧凑截断)：\n  - 晶体：氯化钠 (NaCl)，基和电荷与测试用例 1 相同。\n  - 最近邻距离 $r_0 = \\tfrac{1}{2}$。\n  - 参考马德隆常数 $M_{\\text{ref}} = 1.747564594$。\n  - 参数：$\\alpha = 3$, $r_{\\mathrm{cut}} = 2$, $m_{\\max} = 2$。\n\n验证容差。在评估计算出的 $M_{\\text{calc}}$ 是否复现 $M_{\\text{ref}}$ 时，使用单一容差 $\\tau = 10^{-3}$。尽管您的程序必须计算并返回所有测试用例的绝对误差，但残余误差应能通过 $(\\alpha, r_{\\mathrm{cut}}, m_{\\max})$ 的选择来解释。\n\n最终输出格式。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，具体为绝对误差列表 $[\\,|M_{\\text{calc}}^{(1)}-M_{\\text{ref}}^{(1)}|,\\;|M_{\\text{calc}}^{(2)}-M_{\\text{ref}}^{(2)}|,\\;|M_{\\text{calc}}^{(3)}-M_{\\text{ref}}^{(3)}|,\\;|M_{\\text{calc}}^{(4)}-M_{\\text{ref}}^{(4)}|\\,]$。", "solution": "用户提供了一个有效的问题陈述。该问题要求实现艾瓦尔德求和方法，以计算几种二元离子晶体的无量纲马德隆常数。该问题在科学上基于静电学和固态物理学的原理，问题陈述清晰，具有明确的输入和定义的输出，是客观且自包含的。因此，将提供一个解决方案。\n\n问题的核心是计算一个电中性、周期性的三维点电荷晶格的总静电势能 $E_{\\text{total}}$。马德隆常数 $M$ 将此能量与单对最近邻离子的特征能量联系起来。对于电荷为 $\\pm q$、最近邻距离为 $r_0$ 的二元晶体，每个离子的能量由 $E_{\\text{ion}} = -M \\frac{q^2}{r_0}$ 给出。问题设定基本电荷大小 $q=1$ 和立方晶格参数 $a=1$。因此，计算出的马德隆常数 $M_{\\text{calc}}$ 是通过计算出的每个离子的能量 $E_{\\text{ion}}$ 得到的，即 $M_{\\text{calc}} = -E_{\\text{ion}} r_0$。\n\n库仑势具有长程性质，其以 $1/r$ 的形式衰减，这导致在无限周期晶格上计算时，求和是条件收敛的。艾瓦尔德求和法是克服此问题的标准技术，它将求和分解为两个快速收敛的部分：一个在实空间中计算的短程部分和一个在倒易（傅里叶）空间中计算的长程部分。\n\n晶胞中 $N$ 个离子的总能量 $E_{\\text{total}}$ 是三个分量的总和：\n$$E_{\\text{total}} = E_{\\text{real}} + E_{\\text{recip}} + E_{\\text{self}}$$\n\n下面详细介绍每个分量，假设是一个体积为 $V=a^3$ 且 $a=1$ 的立方晶胞。离子位置由分数坐标 $\\mathbf{s}_j$ 给出，因此它们的实空间位置是 $\\mathbf{r}_j = a \\mathbf{s}_j = \\mathbf{s}_j$。\n\n1.  **实空间能量 ($E_{\\text{real}}$)**\n    该项说明了短程相互作用。通过在点电荷周围放置符号相反的高斯电荷分布来屏蔽点电荷，这使得它们的相互作用势能快速衰减。两个相距为 $r$ 的点电荷 $q_i$ 和 $q_j$ 之间的相互作用被替换为 $\\frac{q_i q_j \\text{erfc}(\\alpha r)}{r}$，其中 $\\text{erfc}$ 是互补误差函数，$\\alpha$ 是控制高斯分布宽度的艾瓦尔德分裂参数。较大的 $\\alpha$ 会导致在实空间中更快的衰减。\n\n    实空间能量是对晶胞中所有离子对 $(i,j)$ 及其所有周期性映像的求和，这些映像由晶格矢量 $\\mathbf{L}_{\\mathbf{n}} = n_x \\hat{\\mathbf{x}} + n_y \\hat{\\mathbf{y}} + n_z \\hat{\\mathbf{z}}$ 标识，其中 $\\mathbf{n}=(n_x, n_y, n_z)$ 是整数三元组。求和排除了中心晶胞内（$\\mathbf{n}=\\mathbf{0}$）$i=j$ 的自相互作用项。\n    $$E_{\\text{real}} = \\frac{1}{2} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\sum_{\\mathbf{n}}' \\frac{q_i q_j \\text{erfc}(\\alpha |\\mathbf{s}_{ij} + \\mathbf{n}|)}{|\\mathbf{s}_{ij} + \\mathbf{n}|}$$\n    其中 $\\mathbf{s}_{ij} = \\mathbf{s}_i - \\mathbf{s}_j$，求和符号上的撇号表示排除了 $i=j, \\mathbf{n}=\\mathbf{0}$ 项。求和被截断，只包括 $|\\mathbf{s}_{ij} + \\mathbf{n}| \\le r_{\\mathrm{cut}}$ 的项。因子 $1/2$ 用于校正每对相互作用被重复计算的问题。\n\n2.  **倒易空间能量 ($E_{\\text{recip}}$)**\n    该项用于校正实空间求和中引入的屏蔽效应。它是一个高斯电荷晶格的能量，该晶格抵消了屏蔽高斯分布。由于这种电荷分布是平滑且周期性的，其能量可以在倒易空间中高效计算。求和遍及所有倒易晶格矢量 $\\mathbf{k}_{\\mathbf{m}} = 2\\pi (h \\hat{\\mathbf{x}}^* + k \\hat{\\mathbf{y}}^* + \\ell \\hat{\\mathbf{z}}^*)$，对于边长为 $a=1$ 的立方晶胞，这些矢量是 $\\mathbf{k}_{\\mathbf{m}} = 2\\pi \\mathbf{m}$，其中 $\\mathbf{m}=(h,k,\\ell)$ 是一个整数三元组。\n\n    倒易空间能量由下式给出：\n    $$E_{\\text{recip}} = \\frac{1}{2V} \\sum_{\\mathbf{m} \\neq \\mathbf{0}} \\frac{4\\pi}{k_{\\mathbf{m}}^2} \\exp\\left(-\\frac{k_{\\mathbf{m}}^2}{4\\alpha^2}\\right) |S(\\mathbf{k}_{\\mathbf{m}})|^2$$\n    此处，$S(\\mathbf{k}_{\\mathbf{m}})$ 是结构因子：\n    $$S(\\mathbf{k}_{\\mathbf{m}}) = \\sum_{j=1}^{N} q_j \\exp(-i \\mathbf{k}_{\\mathbf{m}} \\cdot \\mathbf{s}_j)$$\n    代入 $V=1$ 和 $\\mathbf{k}_{\\mathbf{m}} = 2\\pi \\mathbf{m}$，能量表达式简化为：\n    $$E_{\\text{recip}} = \\frac{1}{2\\pi} \\sum_{\\mathbf{m} \\neq \\mathbf{0}, |\\mathbf{m}| \\le m_{\\max}} \\frac{\\exp(-\\pi^2 |\\mathbf{m}|^2 / \\alpha^2)}{|\\mathbf{m}|^2} \\left| \\sum_{j=1}^{N} q_j \\exp(-i 2\\pi \\mathbf{m} \\cdot \\mathbf{s}_j) \\right|^2$$\n    求和排除了 $\\mathbf{m}=\\mathbf{0}$ 项（对于电中性晶胞，该项为零），并被截断以包含球形截断 $|\\mathbf{m}| \\le m_{\\max}$ 内的整数三元组 $\\mathbf{m}$。较小的 $\\alpha$ 会导致在倒易空间中更快的收敛。\n\n3.  **自能修正 ($E_{\\text{self}}$)**\n    此项移除了每个高斯电荷分布与其自身的虚假相互作用，该相互作用已隐含在倒易空间求和中。对于点电荷，此修正为：\n    $$E_{\\text{self}} = - \\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{j=1}^{N} q_j^2$$\n    由于所有电荷均为 $q_j \\in \\{+1, -1\\}$，我们有 $q_j^2=1$，表达式变为 $E_{\\text{self}} = - N \\alpha / \\sqrt{\\pi}$。\n\n算法的流程是为每个指定的测试用例实现这三个求和。计算总能量 $E_{\\text{total}}$，然后进行归一化以求得每个离子的能量 $E_{\\text{ion}} = E_{\\text{total}} / N$。接着计算马德隆常数 $M_{\\text{calc}} = -E_{\\text{ion}} r_0$。最后，计算并报告绝对误差 $|M_{\\text{calc}} - M_{\\text{ref}}|$。$(\\alpha, r_{\\mathrm{cut}}, m_{\\max})$ 的选择通过控制实空间和倒易空间求和中的截断误差来决定结果的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\nimport math\n\ndef compute_madelung(s, q, alpha, r_cut, m_max, r0, m_ref):\n    \"\"\"\n    Computes the Madelung constant using Ewald summation and returns the absolute error.\n\n    Args:\n        s (np.ndarray): Fractional coordinates of ions, shape (N, 3).\n        q (np.ndarray): Charges of ions, shape (N,).\n        alpha (float): Ewald splitting parameter.\n        r_cut (float): Real-space cutoff radius.\n        m_max (int): Reciprocal-space index cutoff.\n        r0 (float): Nearest-neighbor separation.\n        m_ref (float): Reference Madelung constant.\n\n    Returns:\n        float: The absolute error |M_calc - M_ref|.\n    \"\"\"\n    N = len(q)\n    V = 1.0  # a=1, so V=a^3=1\n\n    # Real-space term\n    E_real = 0.0\n    n_max_ceil = math.ceil(r_cut)\n    for i in range(N):\n        for j in range(N):\n            s_ij = s[i] - s[j]\n            for nx in range(-n_max_ceil, n_max_ceil + 1):\n                for ny in range(-n_max_ceil, n_max_ceil + 1):\n                    for nz in range(-n_max_ceil, n_max_ceil + 1):\n                        # Exclude self-interaction in the primary cell\n                        if i == j and nx == 0 and ny == 0 and nz == 0:\n                            continue\n\n                        n_vec = np.array([nx, ny, nz])\n                        dist_vec = s_ij + n_vec\n                        dist = np.linalg.norm(dist_vec)\n\n                        if dist = r_cut:\n                            E_real += q[i] * q[j] * erfc(alpha * dist) / dist\n\n    E_real *= 0.5\n\n    # Reciprocal-space term\n    E_recip = 0.0\n    m_max_sq = m_max**2\n    m_max_floor = math.floor(m_max)\n    for h in range(-m_max_floor, m_max_floor + 1):\n        for k in range(-m_max_floor, m_max_floor + 1):\n            for l in range(-m_max_floor, m_max_floor + 1):\n                m_sq = h**2 + k**2 + l**2\n                if m_sq == 0 or m_sq > m_max_sq:\n                    continue\n                \n                m_vec = np.array([h, k, l])\n                \n                # Structure factor S(k)\n                # With k = 2*pi*m and r = a*s = s (since a=1)\n                # k.r = 2*pi*m.s\n                s_dot_m = np.dot(s, m_vec)\n                S_k = np.sum(q * np.exp(-1j * 2 * np.pi * s_dot_m))\n                S_k_sq = np.abs(S_k)**2\n\n                term = (S_k_sq / m_sq) * np.exp(-np.pi**2 * m_sq / alpha**2)\n                E_recip += term\n\n    E_recip *= 1.0 / (2.0 * np.pi * V)\n\n    # Self-energy term\n    E_self = - (alpha / np.sqrt(np.pi)) * np.sum(q**2)\n\n    # Total energy and Madelung constant\n    E_total = E_real + E_recip + E_self\n    E_ion = E_total / N\n    M_calc = - E_ion * r0\n\n    # Absolute error\n    abs_error = abs(M_calc - m_ref)\n    \n    return abs_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define test cases\n    # Test case 1: NaCl, good balance\n    s_nacl_cation = np.array([[0,0,0], [0,0.5,0.5], [0.5,0,0.5], [0.5,0.5,0]])\n    s_nacl_anion = np.array([[0.5,0.5,0.5], [0.5,0,0], [0,0.5,0], [0,0,0.5]])\n    s_nacl = np.vstack((s_nacl_cation, s_nacl_anion))\n    q_nacl = np.array([1,1,1,1,-1,-1,-1,-1])\n    \n    # Test case 3: ZnS (sphalerite)\n    s_zns_cation_base = np.array([[0,0,0], [0,0.5,0.5], [0.5,0,0.5], [0.5,0.5,0]])\n    s_zns_anion = s_zns_cation_base + 0.25\n    s_zns = np.vstack((s_zns_cation_base, s_zns_anion))\n    q_zns = np.array([1,1,1,1,-1,-1,-1,-1])\n    \n    test_cases = [\n        # Case 1: NaCl, good balance\n        {\n            \"s\": s_nacl, \"q\": q_nacl, \"alpha\": 6.0, \"r_cut\": 6.0, \n            \"m_max\": 8.0, \"r0\": 0.5, \"m_ref\": 1.747564594\n        },\n        # Case 2: CsCl, under-resolved real space\n        {\n            \"s\": np.array([[0,0,0], [0.5,0.5,0.5]]), \"q\": np.array([1,-1]), \n            \"alpha\": 1.5, \"r_cut\": 3.0, \"m_max\": 4.0, \n            \"r0\": np.sqrt(3)/2, \"m_ref\": 1.762675\n        },\n        # Case 3: ZnS, good balance\n        {\n            \"s\": s_zns, \"q\": q_zns, \"alpha\": 5.0, \"r_cut\": 6.0, \n            \"m_max\": 8.0, \"r0\": np.sqrt(3)/4, \"m_ref\": 1.638055\n        },\n        # Case 4: NaCl, tight truncations\n        {\n            \"s\": s_nacl, \"q\": q_nacl, \"alpha\": 3.0, \"r_cut\": 2.0, \n            \"m_max\": 2.0, \"r0\": 0.5, \"m_ref\": 1.747564594\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = compute_madelung(\n            case[\"s\"], case[\"q\"], case[\"alpha\"], case[\"r_cut\"], \n            case[\"m_max\"], case[\"r0\"], case[\"m_ref\"]\n        )\n        results.append(error)\n\n    # Format output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3462178"}, {"introduction": "掌握了周期性体系能量的精确计算后，我们必须考虑其物理意义。本练习将探讨分子模拟中一个常见的赝像：有限尺寸效应对带电溶质的影响。你将推导并应用一个基于埃瓦尔德理论的一阶校正项，将模拟结果外推至热力学极限，这是获得如溶剂化自由能等具有物理意义结果的关键步骤。[@problem_id:3462165]", "problem": "在分子模拟中，有一个对周期性边界条件（PBC）下的长程静电作用特别敏感的可观测量，那就是净电荷溶质的溶剂化自由能。考虑一个电荷量为 $q$ 的单点电荷，嵌入在电介质中，并在边长为 $L$ 的立方晶胞内进行模拟，采用导体（锡箔）边界条件，并使用 Ewald 求和法进行计算。通过均匀的中和背景电荷密度使系统保持净电中性。原始模拟的溶剂化自由能 $G(L)$ 因溶质与其周期性镜像以及中和背景之间的相互作用而受到有限晶胞尺寸的偏差影响。已知这种偏差的晶胞尺寸依赖性由一个与形状相关的晶格常数控制，即对于简单立方几何结构的所谓马德隆常数 $\\xi$，它是一个无量纲数。\n\n从 PBC 下均匀中和背景中点电荷的泊松方程 $\\nabla^{2} \\phi(\\mathbf{r}) = -\\rho(\\mathbf{r})/\\epsilon_{0}$ 出发，并使用 Ewald 分裂法将库仑相互作用分离为短程和长程贡献，推导在导体边界条件下，净电荷溶质的领头阶有限尺寸偏差，该偏差是 $q$、$L$ 和 $\\xi$ 的函数。然后利用此结果，通过从原始模拟值中减去推导出的偏差，将溶剂化自由能外推到热力学极限。\n\n您将获得以下数据和定义：\n- 元电荷电荷量 $q = e$。\n- 库仑常数 $k_{e} = 1/(4\\pi \\epsilon_{0})$。\n- 当能量以千焦每摩尔（$\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$）表示，距离以纳米（$\\mathrm{nm}$）表示时，库仑常数 $k_{e}$ 的数值为 $138.935456$，即 $k_{e}$ 的单位为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}\\,e^{-2}$。\n- 对于处理单个净电荷加中和背景的 Ewald 方法中出现的晶格和，简单立方马德隆常数 $\\xi = -2.837297$。\n- 进行了两次模拟：\n  - $L_{1} = 3.20\\,\\mathrm{nm}$，原始溶剂化自由能 $G(L_{1}) = -373.9389300785\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n  - $L_{2} = 4.65\\,\\mathrm{nm}$，原始溶剂化自由能 $G(L_{2}) = -354.7322206993\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n\n使用您推导出的有限尺寸偏差表达式，通过校正 $G(L_{1})$ 或 $G(L_{2})$ 来计算热力学极限溶剂化自由能 $G(\\infty)$，并报告一个单一值。最终能量以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 表示，并将您的答案四舍五入到四位有效数字。", "solution": "该问题要求推导周期性系统中点电荷溶剂化自由能的领头阶有限尺寸偏差，并随后利用该偏差，根据从有限模拟晶胞获得的数据来计算热力学极限下的自由能 $G(\\infty)$。\n\n对问题陈述的验证证实了其具有科学依据、提法恰当，并包含充分、一致的信息以得出唯一解。因此，我们可以继续进行。\n\n该系统由一个电荷量为 $q$ 的单点电荷组成，放置在边长为 $L$ 的立方模拟晶胞的原点。该晶胞被周期性地复制以填充整个空间。为保持整体电中性，系统中加入了均匀的背景电荷密度 $\\rho_{\\text{bg}} = -q/L^{3}$。该系统内的静电势 $\\phi(\\mathbf{r})$ 由泊松方程决定：\n$$ \\nabla^{2} \\phi(\\mathbf{r}) = -\\frac{\\rho(\\mathbf{r})}{\\epsilon_{0}} $$\n其中 $\\rho(\\mathbf{r})$ 是点电荷晶格和背景的总电荷密度，$\\epsilon_{0}$ 是真空介电常数。\n\n从大小为 $L$ 的有限晶胞模拟中计算出的溶剂化自由能 $G(L)$ 会因人为的周期性而受到伪影的污染。对于带电溶质，领头阶误差（或偏差）源于溶质与其自身的周期性镜像以及中和背景电荷之间的静电相互作用。这种相互作用能是周期性边界条件的人为产物，在热力学极限（$L \\to \\infty$）下会消失。\n\nEwald 求和法提供了一种计算这种静电能的方法。对于立方晶格中的单个电荷 $q$，其所有周期性镜像和中和背景在该电荷位置（原点，$\\mathbf{r}=\\mathbf{0}$）产生的电势记为 $\\phi_{\\text{other}}(\\mathbf{0})$。这个电势正是该晶格位置的马德隆电势。它可以利用给定晶格几何结构（本例中为简单立方）和边界条件（导体，或“锡箔”）的无量纲马德隆常数 $\\xi$ 来表示。该电势的表达式为：\n$$ \\phi_{\\text{other}}(\\mathbf{0}) = \\frac{q \\xi}{4 \\pi \\epsilon_{0} L} = \\frac{k_{e} q \\xi}{L} $$\n其中 $k_{e} = 1/(4\\pi\\epsilon_{0})$ 是库仑常数。\n\n由于这些长程相互作用，模拟晶胞的总静电能（即偏差）是将电荷 $q$ 置于此电势中所需的功。包含一个因子 $1/2$ 是为了避免在计算晶胞总能量时重复计算相互作用能：\n$$ G_{\\text{bias}}(L) = \\frac{1}{2} q \\phi_{\\text{other}}(\\mathbf{0}) = \\frac{1}{2} q \\left( \\frac{k_{e} q \\xi}{L} \\right) = \\frac{k_{e} q^{2} \\xi}{2L} $$\n这就是在指定条件下，点电荷溶剂化自由能的领头阶有限尺寸偏差。\n\n原始模拟的自由能 $G(L)$ 是真实的热力学极限自由能 $G(\\infty)$ 与此偏差项（以及我们忽略的其他高阶项）之和：\n$$ G(L) \\approx G(\\infty) + G_{\\text{bias}}(L) $$\n为求得热力学极限下的值，我们从模拟值中减去偏差：\n$$ G(\\infty) = G(L) - G_{\\text{bias}}(L) = G(L) - \\frac{k_{e} q^{2} \\xi}{2L} $$\n\n我们已知以下数据：\n- 电荷量 $q = e$。\n- 库仑常数 $k_{e} = 138.935456\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}\\,e^{-2}$。\n- 简单立方马德隆常数 $\\xi = -2.837297$。\n- 数据点 1：$L_{1} = 3.20\\,\\mathrm{nm}$，$G(L_{1}) = -373.9389300785\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n- 数据点 2：$L_{2} = 4.65\\,\\mathrm{nm}$，$G(L_{2}) = -354.7322206993\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n\n我们可以使用任一数据点来计算 $G(\\infty)$。使用较大模拟晶胞（$L_{2}$）的数据更为可取，因为被忽略的高阶校正项（例如，与 $1/L^{3}$ 成正比的项）会更小。首先，我们计算 $L_{2}$ 的偏差项。由于 $q=e$，项 $k_{e}q^{2}$ 简化为 $k_{e}e^{2}$，并且所提供的 $k_{e}$ 的数值单位已经考虑了这一点。\n$$ G_{\\text{bias}}(L_{2}) = \\frac{k_{e} e^{2} \\xi}{2L_{2}} = \\frac{(138.935456\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}) \\times (-2.837297)}{2 \\times (4.65\\,\\mathrm{nm})} $$\n$$ G_{\\text{bias}}(L_{2}) = \\frac{-394.2400949...}{9.30}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} = -42.39140805...\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n\n现在，我们计算外推的自由能 $G(\\infty)$：\n$$ G(\\infty) = G(L_{2}) - G_{\\text{bias}}(L_{2}) $$\n$$ G(\\infty) = -354.7322206993\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} - (-42.39140805...\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}) $$\n$$ G(\\infty) = -354.7322206993 + 42.39140805...\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n$$ G(\\infty) = -312.3408126...\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n\n作为一致性检验，我们可以使用 $L_{1}$ 的数据进行相同的计算：\n$$ G_{\\text{bias}}(L_{1}) = \\frac{k_{e} e^{2} \\xi}{2L_{1}} = \\frac{(138.935456\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}) \\times (-2.837297)}{2 \\times (3.20\\,\\mathrm{nm})} $$\n$$ G_{\\text{bias}}(L_{1}) = \\frac{-394.2400949...}{6.40}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} = -61.59991639...\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n$$ G(\\infty) = G(L_{1}) - G_{\\text{bias}}(L_{1}) = -373.9389300785 - (-61.59991639...) = -312.3390136...\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n两个计算出的 $G(\\infty)$ 值非常吻合（相差小于 $0.002\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$），这验证了领头阶偏差的 $1/L$ 标度关系。\n\n问题要求给出一个四舍五入到四位有效数字的单一值。使用较大模拟盒子（$L_{2}$）得到的更准确的结果：\n$G(\\infty) = -312.3408126...\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n四舍五入到四位有效数字得到 $-312.3\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。", "answer": "$$\n\\boxed{-312.3}\n$$", "id": "3462165"}, {"introduction": "标准埃瓦尔德求和的计算成本很高，因此在现代模拟中常使用更高效的算法。本练习将深入探讨粒子网格埃瓦尔德（PME）方法，这是一种在现代模拟软件中广泛应用的强大技术。你将开发一套诊断工具，用于检测PME方法中因使用网格近似而产生的误差，从而深入理解计算精度与速度之间的权衡，并学会如何调节PME参数以获得可靠的模拟结果。[@problem_id:3462216]", "problem": "考虑一个边长为 $L$ 的立方晶胞中的周期性点电荷系统，使用粒子网格 Ewald (PME) 方法处理长程静电相互作用。目标是通过监测结构因子平方模 $|S(\\mathbf{k})|^2$ 的高 $k$ 谱以及当插值阶数 $p$ 变化时的力噪声，来设计并实现用于检测 PME 中混叠和分配误差的诊断方法。从以下基本原理开始。Ewald 求和将库仑相互作用分解为实空间和倒易空间两部分。在倒易空间中，能量贡献由结构因子 $S(\\mathbf{k}) = \\sum_{j=1}^{N} q_j e^{i \\mathbf{k} \\cdot \\mathbf{r}_j}$ 计算得出，其中 $q_j$ 是位于位置 $\\mathbf{r}_j$ 的粒子 $j$ 的电荷，而 $\\mathbf{k}$ 位于由周期性晶胞定义的倒易晶格上。在 PME 中，结构因子通过将电荷分配到网格上并执行快速傅里叶变换 (FFT) 来近似计算，这个过程由于有限的插值阶数和离散化而固有地引入了一个窗函数，并且由于在有限网格上采样而可能产生混叠。\n\n您必须基于采样定理和 PME 分配的傅里叶分析，推导、论证并实现诊断方法。使用以下原则：\n\n- 结构因子 $S(\\mathbf{k})$ 可以根据粒子位置和电荷精确计算，也可以通过对网格化电荷进行 FFT 并随后对分配窗进行反卷积来近似计算。对于 $p$ 阶基数 B-样条，一维的分配窗可以近似为函数 $\\mathrm{sinc}(k h / 2)^p$，其中 $\\mathrm{sinc}(x) = \\sin(x)/x$，当每个维度使用 $M$ 个网格点时，$h=L/M$ 是网格间距。三维窗是沿 $k_x$、$k_y$ 和 $k_z$ 的一维窗的乘积。\n- 粒子 $i$ 上的倒易空间力由倒易能量对 $\\mathbf{r}_i$ 求导得出，得到一个对 $\\mathbf{k}$ 的求和，其贡献项与 $\\mathrm{Im}\\left(e^{-i \\mathbf{k} \\cdot \\mathbf{r}_i} S(\\mathbf{k})\\right)$ 成正比，并带有 Ewald 求和中的高斯屏蔽因子和 $1/k^2$ 标度。具体来说，使用约化单位下且库仑常数设为1的纯倒易空间力：$$\\mathbf{F}_i^{(k)} = -\\frac{4 \\pi q_i}{V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\frac{e^{-k^2/(4 \\alpha^2)}}{k^2} \\, \\mathrm{Im}\\left(e^{-i \\mathbf{k} \\cdot \\mathbf{r}_i} S(\\mathbf{k})\\right) \\, \\mathbf{k},$$ 其中 $V=L^3$，$\\alpha$ 是 Ewald 分离参数，$k = \\|\\mathbf{k}\\|$。\n- 在 PME 中，近似结构因子 $S_{\\mathrm{est}}(\\mathbf{k})$ 是通过对网格化电荷分配 $G(\\mathbf{k})$ 进行 FFT 并与分配窗 $W(\\mathbf{k})$ 进行反卷积得到的，即 $S_{\\mathrm{est}}(\\mathbf{k}) \\approx G(\\mathbf{k})/W(\\mathbf{k})$，当 $W(\\mathbf{k})$ 接近零时需采取数值保护措施。\n\n定义以下两种诊断方法：\n\n- 一种高 $k$ 谱诊断 $R(p)$，用于量化大波矢处的混叠和分配误差影响：$$R(p) := \\frac{\\sum_{\\mathbf{k} \\in \\mathcal{K}_{\\mathrm{high}}} |S_{\\mathrm{est}}(\\mathbf{k})|^2}{\\sum_{\\mathbf{k} \\neq \\mathbf{0}} |S_{\\mathrm{est}}(\\mathbf{k})|^2},$$ 其中 $\\mathcal{K}_{\\mathrm{high}}$ 包含满足其模 $k \\ge k_{\\mathrm{thresh}}$ 的波矢 $\\mathbf{k}$，其中 $k_{\\mathrm{thresh}} := r_{\\mathrm{frac}} \\, k_{\\mathrm{max}}$ 且 $k_{\\mathrm{max}}$ 选择为网格的径向奈奎斯特模。使用 $r_{\\mathrm{frac}} = 0.7$。较大的 $R(p)$ 表示与混叠和分配误差假象一致的更强的高 $k$ 成分。\n- 一种力噪声诊断 $E(p)$，它将使用 $S_{\\mathrm{est}}(\\mathbf{k})$ 计算的 PME 倒易力与使用精确结构因子 $S(\\mathbf{k})$ 计算的参考值进行比较：$$E(p) := \\sqrt{\\frac{\\sum_{i=1}^{N} \\|\\mathbf{F}_i^{(k)}[S_{\\mathrm{est}}] - \\mathbf{F}_i^{(k)}[S]\\|^2}{\\sum_{i=1}^{N} \\|\\mathbf{F}_i^{(k)}[S]\\|^2}},$$ 在约化单位约定下，该值是无量纲的。较大的 $E(p)$ 表示由于 PME 分配和混叠导致的更大的力噪声。\n\n您的实现必须：\n\n- 在所有方向上使用具有周期性边界条件的均匀网格，每个维度有 $M$ 个点。倒易矢量 $\\mathbf{k}$ 对应于采样间距 $h=L/M$ 的离散 FFT 频率；具体来说，使用 $\\mathbf{k} = 2\\pi \\mathbf{n}/L$，其中整数三元组 $\\mathbf{n}$ 来自 FFT 频率集。直接从粒子位置和电荷计算精确的 $S(\\mathbf{k})$。使用插值阶数 $p$ 从电荷分配网格的 FFT 计算 $S_{\\mathrm{est}}(\\mathbf{k})$，并用 $W(\\mathbf{k}) = \\prod_{\\mu \\in \\{x,y,z\\}} \\mathrm{sinc}(k_\\mu h/2)^p$ 进行反卷积。\n- 使用一维的 $p$ 阶基数 B-样条权重实现电荷分配，其中 $p \\in \\{2,4\\}$：$p=2$ (Cloud-In-Cell) 和 $p=4$ (分段三次样条)。对于一维 $p=2$ 的情况，如果 $u \\in [0,1)$ 是相对于左侧网格点索引 $i$ 的局部分数坐标，则使用权重 $w_i = 1-u$ 和 $w_{i+1} = u$。对于一维 $p=4$ 的情况，当 $u \\in [0,1)$ 是相对于中心索引 $i$ 的分数坐标时，在索引 $(i-1,i,i+1,i+2)$ 上使用的权重由 $w_{i-1} = \\frac{1}{6}(1-u)^3$，$w_{i} = \\frac{1}{6}(4 - 6u^2 + 3u^3)$，$w_{i+1} = \\frac{1}{6}(1 + 3u + 3u^2 - 3u^3)$ 和 $w_{i+2} = \\frac{1}{6}u^3$ 给出。通过一维权重的乘积扩展到三维，并对索引应用周期性环绕处理。\n- 使用 Ewald 分离参数 $\\alpha = 3.5 / L$ 和如上所述的倒易空间力，对所有 FFT 支持的非零 $\\mathbf{k}$ 矢量求和。完全在约化单位下操作，库仑常数设为1，长度单位与 $L$ 相同，因此所有输出均为无量纲浮点数。\n- 为避免反卷积中的数值不稳定性，如果对于一个小的阈值 $\\varepsilon$ 有 $|W(\\mathbf{k})|  \\varepsilon$，则将 $S_{\\mathrm{est}}(\\mathbf{k})$ 设为 $0$。使用 $\\varepsilon = 10^{-12}$。\n\n测试套件：\n评估三种情况下的诊断方法，这三种情况使用相同的粒子集和箱长 $L$，但具有不同的网格和粒子构型，以探测“理想路径”、易混叠和公度性边缘情况。使用以下参数值和粒子数据：\n\n- 情况 1 (理想路径): $L = 2.0$, $M = 16$, $N = 12$, 电荷 $q = [1,1,1,1,1,1,-1,-1,-1,-1,-1,-1]$, 晶胞中的位置 (单位与 $L$ 相同):\n  $\\mathbf{r}_1 = (0.147, 1.835, 0.410)$,\n  $\\mathbf{r}_2 = (1.120, 0.221, 0.903)$,\n  $\\mathbf{r}_3 = (0.702, 1.401, 1.520)$,\n  $\\mathbf{r}_4 = (1.690, 0.950, 0.250)$,\n  $\\mathbf{r}_5 = (0.330, 0.780, 1.730)$,\n  $\\mathbf{r}_6 = (1.870, 1.620, 1.110)$,\n  $\\mathbf{r}_7 = (0.520, 1.420, 0.310)$,\n  $\\mathbf{r}_8 = (1.300, 0.070, 1.800)$,\n  $\\mathbf{r}_9 = (0.990, 1.910, 0.990)$,\n  $\\mathbf{r}_{10} = (0.240, 0.400, 0.120)$,\n  $\\mathbf{r}_{11} = (1.560, 1.250, 0.780)$,\n  $\\mathbf{r}_{12} = (0.050, 0.950, 1.450)$.\n- 情况 2 (由于网格粗糙而易于混叠): 与情况 1 相同的 $L$、电荷和位置，但 $M = 8$。\n- 情况 3 (公度性位置): $L = 2.0$, $M = 16$, $N = 12$, 电荷 $q = [1,1,1,1,1,1,-1,-1,-1,-1,-1,-1]$, 位置:\n  $\\mathbf{r}_1 = (0.5, 0.5, 0.5)$,\n  $\\mathbf{r}_2 = (1.5, 0.5, 0.5)$,\n  $\\mathbf{r}_3 = (0.5, 1.5, 0.5)$,\n  $\\mathbf{r}_4 = (0.5, 0.5, 1.5)$,\n  $\\mathbf{r}_5 = (1.5, 1.5, 0.5)$,\n  $\\mathbf{r}_6 = (1.5, 0.5, 1.5)$,\n  $\\mathbf{r}_7 = (0.5, 1.5, 1.5)$,\n  $\\mathbf{r}_8 = (1.5, 1.5, 1.5)$,\n  $\\mathbf{r}_9 = (1.0, 0.5, 0.5)$,\n  $\\mathbf{r}_{10} = (0.5, 1.0, 0.5)$,\n  $\\mathbf{r}_{11} = (0.5, 0.5, 1.0)$,\n  $\\mathbf{r}_{12} = (1.0, 1.0, 1.0)$.\n\n对于每种情况，评估插值阶数 $p \\in \\{2,4\\}$ 的诊断方法，为每个 $p$ 和情况生成对 $(R(p), E(p))$。最终输出格式必须将所有情况和阶数的结果聚合为一行文本，包含一个用方括号括起来的逗号分隔列表，顺序为：\n$[R_{1,2}, R_{1,4}, E_{1,2}, E_{1,4}, R_{2,2}, R_{2,4}, E_{2,2}, E_{2,4}, R_{3,2}, R_{3,4}, E_{3,2}, E_{3,4}]$。\n所有数值输出必须按照上述约化单位约定报告为无量纲浮点数。", "solution": "该问题要求实现并评估两种诊断方法，用于评估长程静电作用的粒子网格 Ewald (PME) 方法中的混叠和分配误差。所采用的方法是计算一个精确的参考结构因子和力，并将其与从网格化电荷导出的 PME 近似对应物进行比较。\n\n### 理论框架与算法设计\n\n一个体积为 $V=L^3$ 的晶胞中包含 $N$ 个位于位置 $\\{\\mathbf{r}_j\\}$ 的点电荷 $\\{q_j\\}$ 的周期性系统的静电能可以使用 Ewald 求和计算。该方法将相互作用划分为短程的实空间求和与长程的倒易空间求和。倒易空间能量由结构因子决定，定义为：\n$$S(\\mathbf{k}) = \\sum_{j=1}^{N} q_j e^{i \\mathbf{k} \\cdot \\mathbf{r}_j}$$\n其中，对于整数矢量 $\\mathbf{n}$，$\\mathbf{k} = 2\\pi \\mathbf{n}/L$ 是倒易晶格矢量。\n\nPME 方法通过首先将电荷分配到 $M^3$ 个点的均匀网格上来近似 $S(\\mathbf{k})$。这会产生一个网格化的电荷密度 $\\rho(\\mathbf{x})$。然后使用快速傅里叶变换 (FFT) 计算 $G(\\mathbf{k}) = \\mathcal{F}[\\rho(\\mathbf{x})]$。在数学上，分配过程对应于将真实的电荷分布与一个插值核（一个 $p$ 阶 B-样条）进行卷积。在傅里叶空间中，此卷积变为与一个窗函数 $W(\\mathbf{k})$ 的乘法。为了恢复结构因子，必须执行反卷积：\n$$S_{\\mathrm{est}}(\\mathbf{k}) = \\frac{G(\\mathbf{k})}{W(\\mathbf{k})}$$\n问题指定了 $p$ 阶基数 B-样条的窗函数近似为：\n$$W(\\mathbf{k}) = \\prod_{\\mu \\in \\{x,y,z\\}} \\left( \\frac{\\sin(k_\\mu h/2)}{k_\\mu h/2} \\right)^p = \\prod_{\\mu \\in \\{x,y,z\\}} \\mathrm{sinc}(k_\\mu h/2)^p$$\n其中 $h=L/M$ 是网格间距。为了防止在 $W(\\mathbf{k})$ 接近零时出现数值不稳定性，如果 $|W(\\mathbf{k})|  \\varepsilon = 10^{-12}$，则将 $S_{\\mathrm{est}}(\\mathbf{k})$ 设为 0。\n\n电荷分配使用问题陈述中指定的 $p=2$（线性插值，Cloud-In-Cell）和 $p=4$（分段三次样条）阶的基数 B-样条执行。对于一个标度化坐标为 $(s_x, s_y, s_z) = (\\mathbf{r}/L) M$ 的粒子，我们找到其基础整数网格索引 $\\mathbf{i} = \\lfloor \\mathbf{s} \\rfloor$ 和分数坐标 $\\mathbf{u} = \\mathbf{s} - \\mathbf{i}$。然后根据一维样条权重的乘积将电荷 $q_j$ 分布到 $p^3$ 个相邻的网格点上，这些权重是 $\\mathbf{u}$ 的函数。\n\n粒子 $i$ 上的倒易空间力由能量导出，并由以下公式给出：\n$$\\mathbf{F}_i^{(k)} = -\\frac{4 \\pi q_i}{V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\frac{e^{-k^2/(4 \\alpha^2)}}{k^2} \\, \\mathrm{Im}\\left(e^{-i \\mathbf{k} \\cdot \\mathbf{r}_i} S(\\mathbf{k})\\right) \\, \\mathbf{k}$$\n其中 $\\alpha$ 是 Ewald 分离参数，此处设为 $\\alpha = 3.5 / L$。参考力 $\\mathbf{F}_i^{(k)}[S]$ 使用精确的 $S(\\mathbf{k})$ 计算，而 PME 力 $\\mathbf{F}_i^{(k)}[S_{\\mathrm{est}}]$ 使用近似的 $S_{\\mathrm{est}}(\\mathbf{k})$。求和是对 $M \\times M \\times M$ FFT 网格支持的所有非零倒易矢量 $\\mathbf{k}$ 进行的。\n\n### 诊断指标\n\n计算了两个诊断指标，以量化由 PME 近似引入的误差。\n\n1.  **高 $k$ 谱诊断, $R(p)$**：\n    $$R(p) := \\frac{\\sum_{\\mathbf{k} \\in \\mathcal{K}_{\\mathrm{high}}} |S_{\\mathrm{est}}(\\mathbf{k})|^2}{\\sum_{\\mathbf{k} \\neq \\mathbf{0}} |S_{\\mathrm{est}}(\\mathbf{k})|^2}$$\n    来自电荷分配和混叠（真实电荷密度的高频分量折叠到网格频率范围上）的误差主要表现为大波矢处的噪声。该指标量化了估计结构因子谱高频部分的相对功率。集合 $\\mathcal{K}_{\\mathrm{high}}$ 包括模 $k = \\|\\mathbf{k}\\| \\ge k_{\\mathrm{thresh}}$ 的波矢，其中 $k_{\\mathrm{thresh}} = r_{\\mathrm{frac}} \\, k_{\\mathrm{max}}$。我们使用 $r_{\\mathrm{frac}}=0.7$ 并将径向奈奎斯特模定义为 $k_{\\mathrm{max}} = \\sqrt{3}\\pi/h$，对应于网格第一布里渊区的角落。较大的 $R(p)$ 表示更显著的高频假象。\n\n2.  **力噪声诊断, $E(p)$**：\n    $$E(p) := \\sqrt{\\frac{\\sum_{i=1}^{N} \\|\\mathbf{F}_i^{(k)}[S_{\\mathrm{est}}] - \\mathbf{F}_i^{(k)}[S]\\|^2}{\\sum_{i=1}^{N} \\|\\mathbf{F}_i^{(k)}[S]\\|^2}}$$\n    这是倒易空间力的归一化均方根误差。它直接衡量了 PME 近似对物理上至关重要的粒子间力这一量的影响。较大的 $E(p)$ 表示力计算的准确性较低。\n\n### 实现摘要\n\n对于每个测试用例和插值阶数 $p$，算法按以下步骤进行：\n\n1.  **网格设置**：基于箱长 $L$ 和网格大小 $M$ 构建一个 $M \\times M \\times M$ 的倒易矢量 $\\mathbf{k}$ 网格。预先计算其模 $k$ 和模的平方 $k^2$。\n2.  **精确结构因子 $S(\\mathbf{k})$**：对于网格上所有的 $\\mathbf{k}$，直接使用其定义从粒子位置和电荷计算 $S(\\mathbf{k})$。\n3.  **估计结构因子 $S_{\\mathrm{est}}(\\mathbf{k})$**：\n    a. **电荷分配**：创建一个空的 $M^3$ 网格 $\\rho$。使用指定的 B-样条权重将每个粒子的电荷分布到其 $p^3$ 个相邻的网格点上。对网格索引应用周期性边界条件。\n    b. **FFT**：计算电荷网格的 FFT，$G(\\mathbf{k}) = \\mathcal{F}[\\rho]$。\n    c. **反卷积**：计算窗函数 $W(\\mathbf{k})$。然后通过将 $G(\\mathbf{k})$ 除以 $W(\\mathbf{k})$ 得到 $S_{\\mathrm{est}}(\\mathbf{k})$，并应用数值保护措施。\n4.  **诊断计算**：\n    a. **$R(p)$**：对平方模 $|S_{\\mathrm{est}}(\\mathbf{k})|^2$ 在高 $k$ 区域和整个非零谱上求和，以计算该比率。\n    b. **$E(p)$**：通过在倒易晶格上求和，为所有粒子计算参考力 $\\mathbf{F}_i^{(k)}[S]$ 和 PME 力 $\\mathbf{F}_i^{(k)}[S_{\\mathrm{est}}]$。然后计算归一化的 RMS 误差 $E(p)$。\n\n针对三个指定的测试用例进行计算，改变网格大小 $M$ 和粒子构型，并使用插值阶数 $p=2$ 和 $p=4$。然后将结果汇总成指定的输出格式。", "answer": "```python\nimport numpy as np\nfrom scipy import special\n\ndef solve():\n    \"\"\"\n    Main function to run the PME diagnostics for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"L\": 2.0, \"M\": 16, \"N\": 12,\n            \"charges\": np.array([1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1]),\n            \"positions\": np.array([\n                [0.147, 1.835, 0.410], [1.120, 0.221, 0.903], [0.702, 1.401, 1.520],\n                [1.690, 0.950, 0.250], [0.330, 0.780, 1.730], [1.870, 1.620, 1.110],\n                [0.520, 1.420, 0.310], [1.300, 0.070, 1.800], [0.990, 1.910, 0.990],\n                [0.240, 0.400, 0.120], [1.560, 1.250, 0.780], [0.050, 0.950, 1.450]\n            ])\n        },\n        {\n            \"L\": 2.0, \"M\": 8, \"N\": 12,\n            \"charges\": np.array([1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1]),\n            \"positions\": np.array([\n                [0.147, 1.835, 0.410], [1.120, 0.221, 0.903], [0.702, 1.401, 1.520],\n                [1.690, 0.950, 0.250], [0.330, 0.780, 1.730], [1.870, 1.620, 1.110],\n                [0.520, 1.420, 0.310], [1.300, 0.070, 1.800], [0.990, 1.910, 0.990],\n                [0.240, 0.400, 0.120], [1.560, 1.250, 0.780], [0.050, 0.950, 1.450]\n            ])\n        },\n        {\n            \"L\": 2.0, \"M\": 16, \"N\": 12,\n            \"charges\": np.array([1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1]),\n            \"positions\": np.array([\n                [0.5, 0.5, 0.5], [1.5, 0.5, 0.5], [0.5, 1.5, 0.5], [0.5, 0.5, 1.5],\n                [1.5, 1.5, 0.5], [1.5, 0.5, 1.5], [0.5, 1.5, 1.5], [1.5, 1.5, 1.5],\n                [1.0, 0.5, 0.5], [0.5, 1.0, 0.5], [0.5, 0.5, 1.0], [1.0, 1.0, 1.0]\n            ])\n        }\n    ]\n\n    orders = [2, 4]\n    results = []\n\n    for case in test_cases:\n        case_results = {}\n        for p in orders:\n            R_p, E_p = calculate_diagnostics(case[\"L\"], case[\"M\"], case[\"charges\"], case[\"positions\"], p)\n            case_results[f\"R_{p}\"] = R_p\n            case_results[f\"E_{p}\"] = E_p\n        results.extend([case_results[\"R_2\"], case_results[\"R_4\"], case_results[\"E_2\"], case_results[\"E_4\"]])\n    \n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\ndef calculate_diagnostics(L, M, charges, positions, p, alpha_factor=3.5, deconv_eps=1e-12, r_frac=0.7):\n    \"\"\"Calculates R(p) and E(p) for a given system and interpolation order.\"\"\"\n    N = len(charges)\n    V = L**3\n    h = L / M\n    alpha = alpha_factor / L\n\n    # 1. Setup k-space grid\n    n = np.fft.fftfreq(M, d=1.0/M)\n    kx_v = 2 * np.pi * n / L\n    kx, ky, kz = np.meshgrid(kx_v, kx_v, kx_v, indexing='ij')\n    k2 = kx**2 + ky**2 + kz**2\n    k_mag = np.sqrt(k2)\n\n    # 2. Calculate exact S(k)\n    Sk_exact = np.zeros((M, M, M), dtype=np.complex128)\n    for q_j, r_j in zip(charges, positions):\n        k_dot_r = kx * r_j[0] + ky * r_j[1] + kz * r_j[2]\n        Sk_exact += q_j * np.exp(1j * k_dot_r)\n\n    # 3. Calculate estimated S(k) via PME\n    # 3a. Charge assignment\n    rho = np.zeros((M, M, M))\n    for q_j, r_j in zip(charges, positions):\n        scaled_pos = r_j * M / L\n        base_indices = np.floor(scaled_pos).astype(int)\n        frac_coords = scaled_pos - base_indices\n\n        if p == 2:\n            offsets = range(p)\n            stencil_shift = 0\n            u_vals = frac_coords\n            weights_1d = [\n                1 - u_vals,\n                u_vals\n            ]\n        elif p == 4:\n            offsets = range(p)\n            stencil_shift = -1\n            u = frac_coords\n            u2 = u**2\n            u3 = u**3\n            weights_1d = [\n                (1/6) * (1 - u)**3,\n                (1/6) * (4 - 6*u2 + 3*u3),\n                (1/6) * (1 + 3*u + 3*u2 - 3*u3),\n                (1/6) * u3\n            ]\n        else:\n            raise ValueError(\"Only p=2 and p=4 are supported.\")\n\n        wx = np.array([w[0] for w in weights_1d])\n        wy = np.array([w[1] for w in weights_1d])\n        wz = np.array([w[2] for w in weights_1d])\n\n        for i_off in offsets:\n            ix = (base_indices[0] + i_off + stencil_shift) % M\n            for j_off in offsets:\n                iy = (base_indices[1] + j_off + stencil_shift) % M\n                for k_off in offsets:\n                    iz = (base_indices[2] + k_off + stencil_shift) % M\n                    weight = wx[i_off] * wy[j_off] * wz[k_off]\n                    rho[ix, iy, iz] += q_j * weight\n\n    # 3b. FFT\n    Gk = np.fft.fftn(rho)\n\n    # 3c. Deconvolution\n    def my_sinc(x):\n        return np.divide(np.sin(x), x, out=np.ones_like(x, dtype=float), where=x != 0)\n\n    arg_x, arg_y, arg_z = kx * h / 2, ky * h / 2, kz * h / 2\n    Wk = (my_sinc(arg_x) * my_sinc(arg_y) * my_sinc(arg_z))**p\n    \n    Sk_est = np.zeros_like(Gk)\n    safe_indices = np.abs(Wk) >= deconv_eps\n    Sk_est[safe_indices] = Gk[safe_indices] / Wk[safe_indices]\n    \n    # 4. Calculate R(p)\n    is_k_not_zero = (k2 != 0)\n    Sk_est_sq_mag = np.abs(Sk_est)**2\n    \n    k_max = np.sqrt(3) * np.pi / h\n    k_thresh = r_frac * k_max\n    \n    high_k_mask = (k_mag >= k_thresh)  is_k_not_zero\n    \n    numerator_R = np.sum(Sk_est_sq_mag[high_k_mask])\n    denominator_R = np.sum(Sk_est_sq_mag[is_k_not_zero])\n    R_p = numerator_R / denominator_R if denominator_R != 0 else 0\n\n    # 5. Calculate E(p)\n    Ck = -4 * np.pi / V * np.exp(-k2 / (4 * alpha**2))\n    Ck = np.divide(Ck, k2, out=np.zeros_like(Ck), where=is_k_not_zero)\n\n    sum_sq_diff_F = 0.0\n    sum_sq_F_ref = 0.0\n    for i in range(N):\n        q_i, r_i = charges[i], positions[i]\n        \n        k_dot_r = kx*r_i[0] + ky*r_i[1] + kz*r_i[2]\n        exp_minus_ik_dot_r = np.exp(-1j * k_dot_r)\n        \n        term_ref = np.imag(exp_minus_ik_dot_r * Sk_exact)\n        term_est = np.imag(exp_minus_ik_dot_r * Sk_est)\n        \n        F_ref_vec = q_i * Ck * term_ref\n        F_est_vec = q_i * Ck * term_est\n\n        F_ref = np.array([np.sum(F_ref_vec * kx), np.sum(F_ref_vec * ky), np.sum(F_ref_vec * kz)])\n        F_est = np.array([np.sum(F_est_vec * kx), np.sum(F_est_vec * ky), np.sum(F_est_vec * kz)])\n\n        sum_sq_diff_F += np.sum((F_est - F_ref)**2)\n        sum_sq_F_ref += np.sum(F_ref**2)\n        \n    E_p = np.sqrt(sum_sq_diff_F / sum_sq_F_ref) if sum_sq_F_ref != 0 else 0\n    \n    return R_p, E_p\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3462216"}]}