{"hands_on_practices": [{"introduction": "多尺度建模的核心在于如何将不同精度的理论无缝结合。本练习将通过一个基础的量子力学/分子力学 ($QM/MM$) 计算，向您介绍其中最经典的“减法方案”[@problem_id:3439662]。此方案旨在用高精度的量子力学方法处理系统中的关键区域，同时用计算成本较低的分子力学方法模拟周围环境，并通过能量校正来确保整体描述的自洽性。通过完成这个练习，您将掌握能量组合的基本逻辑，并理解如何避免重复计算相互作用，这是构建任何多尺度模型时都必须面对的核心问题。", "problem": "一个三原子分子体系被划分为两个区域以进行量子力学/分子力学 (QM/MM) 处理：一个量子力学 (QM) 区域和一个分子力学 (MM) 环境。目标是获得一个一致的总能量，该能量用 QM 描述取代 QM 区域的 MM 描述，同时保留对整个体系的 MM 描述，并避免对 QM 区域的双重计算。考虑以下在不同模型下计算得到的能量：\n\n- $E_{\\mathrm{QM}}(\\mathrm{QM})=-100.0\\,\\mathrm{kcal/mol}$，在量子力学水平上计算的 QM 区域的能量。\n- $E_{\\mathrm{MM}}(\\mathrm{QM}+\\mathrm{MM})=-250.0\\,\\mathrm{kcal/mol}$，在分子力学水平上计算的整个体系的能量。\n- $E_{\\mathrm{MM}}(\\mathrm{QM})=-120.0\\,\\mathrm{kcal/mol}$，在分子力学水平上计算的 QM 区域的能量。\n\n从“所期望的复合能量应反映整个体系的 MM 描述，其中 QM 区域的 MM 能量被其 QM 能量所取代”这一概念性原理出发，推导一个合适的减法机械嵌入表达式来表示复合能量 $E_{\\mathrm{sub}}$，并对其进行数值计算。然后，在减法 QM/MM 嵌入的背景下，解释 $E_{\\mathrm{sub}}$ 在物理上代表什么，以及它的值对于 QM 描述与 MM 描述下 QM 区域的相对稳定性意味着什么。最终能量以 $\\mathrm{kcal/mol}$ 为单位表示。无需四舍五入。", "solution": "首先对问题进行严格的验证过程。\n\n### 第 1 步：提取已知条件\n提供了以下数据和定义：\n- 在 QM 理论水平下计算的量子力学 (QM) 区域的能量：$E_{\\mathrm{QM}}(\\mathrm{QM}) = -100.0\\,\\mathrm{kcal/mol}$。\n- 在 MM 理论水平下计算的整个体系（QM 区域 + 分子力学 (MM) 区域）的能量：$E_{\\mathrm{MM}}(\\mathrm{QM}+\\mathrm{MM}) = -250.0\\,\\mathrm{kcal/mol}$。\n- 在 MM 理论水平下计算的 QM 区域的能量：$E_{\\mathrm{MM}}(\\mathrm{QM}) = -120.0\\,\\mathrm{kcal/mol}$。\n- 任务是推导复合能量 $E_{\\mathrm{sub}}$ 的减法机械嵌入表达式，对其进行求值，并解释其物理意义。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据所需标准对问题陈述进行评估。\n- **有科学依据**：该问题描述了 QM/MM 计算的减法方案，这是计算化学中多尺度建模的基石。其公式和避免双重计算的概念是标准的且科学合理的。\n- **适定性**：该问题提供了构建和评估标准双层减法 QM/MM 能量所需的所有能量项。目标是计算一个唯一的、明确定义的值 $E_{\\mathrm{sub}}$，并提供一个标准的物理解释。存在一个唯一的、稳定的、有意义的解。\n- **客观性**：该问题使用了计算化学领域的精确、标准术语（$E_{\\mathrm{QM}}$, $E_{\\mathrm{MM}}$, QM/MM 等），并且没有主观或模糊的语言。\n\n### 第 3 步：结论与行动\n该问题是科学合理的、适定的和客观的。它被认为是**有效的**。因此，将提供完整的解答。\n\n### 解答推导\nQM/MM 计算的目标是用高水平的量子力学理论来描述化学活性区域（QM 区域），同时用计算成本更低的分子力学力场来处理系统的其余部分（MM 环境）。减法方案是组合这些描述的最简单和最常见的方法之一。\n\n正如问题中所述，核心原理是从在低水平（MM）上计算的整个体系的能量开始，然后应用一个校正。这个校正用其准确的高水平描述替换了 QM 区域的不准确的低水平描述。\n\n设整个体系表示为 $\\mathrm{S} = \\mathrm{QM} + \\mathrm{MM}$。\n由 MM 力场计算的完整体系的能量记为 $E_{\\mathrm{MM}}(\\mathrm{S})$，这等同于 $E_{\\mathrm{MM}}(\\mathrm{QM}+\\mathrm{MM})$。这一项不正确地描述了 QM 区域。\n\n为了校正这一点，我们必须首先减去在 MM 水平上计算的 QM 区域的贡献。这个贡献记为 $E_{\\mathrm{MM}}(\\mathrm{QM})$。从总 MM 能量中移除这一项，就消除了对 QM 部分的不正确描述。\n\n接下来，我们必须加上在 QM 理论水平上正确计算的 QM 区域的能量。这一项记为 $E_{\\mathrm{QM}}(\\mathrm{QM})$。\n\n结合这些步骤，得到减法 QM/MM 能量 $E_{\\mathrm{sub}}$ 的通用表达式：\n$$E_{\\mathrm{sub}} = E_{\\mathrm{MM}}(\\mathrm{QM}+\\mathrm{MM}) - E_{\\mathrm{MM}}(\\mathrm{QM}) + E_{\\mathrm{QM}}(\\mathrm{QM})$$\n这个表达式避免了对 QM 区域能量的双重计算。它代表了一个模型，其中 QM 区域的内能是通过量子力学确定的，而其与 MM 环境的相互作用以及 MM 环境的内能则是通过经典力学确定的。这种特定的表述对应于一种机械嵌入方案，因为 QM 和 MM 区域之间的耦合完全包含在 $E_{\\mathrm{MM}}(\\mathrm{QM}+\\mathrm{MM})$ 项中，因此仅在 MM 水平上进行描述。\n\n现在，我们将给定的数值代入这个表达式中：\n- $E_{\\mathrm{QM}}(\\mathrm{QM}) = -100.0\\,\\mathrm{kcal/mol}$\n- $E_{\\mathrm{MM}}(\\mathrm{QM}+\\mathrm{MM}) = -250.0\\,\\mathrm{kcal/mol}$\n- $E_{\\mathrm{MM}}(\\mathrm{QM}) = -120.0\\,\\mathrm{kcal/mol}$\n\n$$E_{\\mathrm{sub}} = (-250.0\\,\\mathrm{kcal/mol}) - (-120.0\\,\\mathrm{kcal/mol}) + (-100.0\\,\\mathrm{kcal/mol})$$\n$$E_{\\mathrm{sub}} = -250.0 + 120.0 - 100.0\\,\\mathrm{kcal/mol}$$\n$$E_{\\mathrm{sub}} = -130.0 - 100.0\\,\\mathrm{kcal/mol}$$\n$$E_{\\mathrm{sub}} = -230.0\\,\\mathrm{kcal/mol}$$\n\n### 物理解释\n计算出的能量 $E_{\\mathrm{sub}} = -230.0\\,\\mathrm{kcal/mol}$ 是减法 QM/MM 框架内体系的总能量估算值。它代表了体系能量的一个近似值，其中 QM 区域通过量子力学进行描述，而 MM 区域和 QM-MM 相互作用则通过经典力场进行描述。\n\n$E_{\\mathrm{sub}}$ 的公式可以重新排列以突出校正项：\n$$E_{\\mathrm{sub}} = E_{\\mathrm{MM}}(\\mathrm{QM}+\\mathrm{MM}) + \\left[ E_{\\mathrm{QM}}(\\mathrm{QM}) - E_{\\mathrm{MM}}(\\mathrm{QM}) \\right]$$\n括号中的项 $E_{\\mathrm{QM}}(\\mathrm{QM}) - E_{\\mathrm{MM}}(\\mathrm{QM})$ 代表了从对 QM 区域的 MM 描述切换到 QM 描述所产生的能量校正。\n在本例中，校正值为：\n$$\\Delta E_{\\mathrm{correction}} = (-100.0\\,\\mathrm{kcal/mol}) - (-120.0\\,\\mathrm{kcal/mol}) = +20.0\\,\\mathrm{kcal/mol}$$\n这个正值意味着，与更准确的 QM 计算相比，MM 力场对孤立 QM 区域的稳定性高估了 $20.0\\,\\mathrm{kcal/mol}$。QM 水平的计算发现，QM 区域的内在稳定性比 MM 力场预测的要低（能量更高）。减法 QM/MM 能量 $E_{\\mathrm{sub}}$ 包含了这个校正，得到的总能量（$-230.0\\,\\mathrm{kcal/mol}$）比整个体系的纯经典计算（$E_{\\mathrm{MM}}(\\mathrm{QM}+\\mathrm{MM}) = -250.0\\,\\mathrm{kcal/mol}$）更高（更不稳定）。这种调整对于获得复合体系更符合物理实际的能量至关重要。", "answer": "$$\n\\boxed{-230.0}\n$$", "id": "3439662"}, {"introduction": "在将原子尺度模型与连续介质模型进行空间耦合时，一个核心挑战是如何确保两者在界面区域的无缝衔接。本练习引入了“斑块测试” (patch test) 的概念，这是一种检验耦合方法一致性的标准程序[@problem_id:3467957]。您将亲自推导并计算由于不完美耦合而在界面处产生的伪力，即“鬼力” (ghost forces)，并实践一种简单的能量修正方案来消除它们。掌握鬼力的来源、诊断和校正方法，是开发和验证任何并行多尺度耦合方法的关键实践技能。", "problem": "考虑一个一维周期性晶格，它有 $N$ 个节点，参考间距为 $a_0$，位置为 $\\{x_i\\}_{i=0}^{N-1}$，索引以 $N$ 为模。该晶格具有谐波对相互作用，直至二阶最近邻，其刚度分别为 $k_1$ 和 $k_2$。定义均匀变形梯度 $F$，使得对所有 $i$ 都有 $x_i = F a_0 i$。节点 $i$ 处的原子点能量是通过在相邻位点间平均分配键能来构建的：\n$$\nE_i^{\\text{a}}(x) = \\frac{k_1}{4} \\left[(x_i - x_{i-1} - a_0)^2 + (x_{i+1} - x_i - a_0)^2\\right] + \\frac{k_2}{4} \\left[(x_i - x_{i-2} - 2 a_0)^2 + (x_{i+2} - x_i - 2 a_0)^2\\right].\n$$\n连续介质点能量 $E_i^{\\text{cb}}(F)$ 通过柯西-玻恩定则（CB）定义为代表性晶胞在均匀变形 $F$ 下的原子能量：\n$$\nE_i^{\\text{cb}}(F) = \\frac{k_1}{2} a_0^2 (F - 1)^2 + \\frac{k_2}{2} (2 a_0)^2 (F - 1)^2.\n$$\n考虑一个并发的原子-连续介质耦合，其混合权重 $w_i \\in [0,1]$ 在空间上变化，其中 $w_i = 1$ 表示纯原子模拟，而 $w_i = 0$ 表示纯连续介质模拟。混合能量为\n$$\nE^{\\text{blend}}(x;F,w) = \\sum_{i=0}^{N-1} \\left[ w_i E_i^{\\text{a}}(x) + (1 - w_i) E_i^{\\text{cb}}(F) \\right].\n$$\n在均匀变形 $F = \\text{const}$ 下，斑图测试（patch test）要求内力为零。通过以下方式定义离散内力向量：\n$$\nf_i^{\\text{ghost}}(F,w) = - \\frac{\\partial E^{\\text{blend}}(x;F,w)}{\\partial x_i} \\bigg|_{x_i = F a_0 i}.\n$$\n在均匀 $F$ 下，这些非零力被称为鬼力（ghost forces）。在一维中，将残余应力向量定义为与单位横截面积下的力向量相同。残余应力范数为\n$$\n\\|\\boldsymbol{\\sigma}_{\\text{ghost}}\\| = \\left( \\sum_{i=0}^{N-1} \\left( f_i^{\\text{ghost}} \\right)^2 \\right)^{1/2}.\n$$\n你的任务是：\n1. 从给定的定义和经典力学（力是势能的负梯度）出发，计算在均匀变形 $F$ 下，一组耦合权重 $\\{w_i\\}$ 对应的 $f_i^{\\text{ghost}}(F,w)$。\n2. 提出一种混合能量修正方法，以消除均匀变形下的鬼力。通过添加一个修正项 $E^{\\text{corr}}(x)$ 来实现最简单的线性鬼力修正，使得\n$$\n- \\frac{\\partial}{\\partial x_i} \\left( E^{\\text{blend}}(x;F,w) + E^{\\text{corr}}(x) \\right) \\bigg|_{x_i = F a_0 i} = 0 \\quad \\text{for all } i,\n$$\n并量化修正后的残余应力范数。\n3. 对每个测试用例，返回以下列表：$[G_{\\text{naive}}, G_{\\text{corrected}}, S_{\\text{naive}}, S_{\\text{corrected}}]$，其中 $G_{\\text{naive}}$ 是未经修正的鬼力向量的欧几里得范数，$G_{\\text{corrected}}$ 是应用所提出的修正后的相同范数，$S_{\\text{naive}} = \\|\\boldsymbol{\\sigma}_{\\text{ghost}}\\|$ 是未经修正的残余应力范数，而 $S_{\\text{corrected}} = \\|\\boldsymbol{\\sigma}_{\\text{ghost}}\\|$ 是修正后的残余应力范数。在整个计算中使用无量纲单位。\n\n使用以下测试套件，其中权重在索引 $i \\in \\{0,1,\\dots,N-1\\}$ 上定义，以 $N$ 为模：\n- 用例 A（平滑混合，小应变）：$N = 64$，$a_0 = 1.0$，$k_1 = 1.0$，$k_2 = 0.25$，$F = 1.02$，以及线性斜坡 $w_i$，$w_i = 1$ 对于 $i \\leq 16$，$w_i = 0$ 对于 $i \\geq 48$，对于 $i \\in (16,48)$，$w_i = 1 - \\frac{i - 16}{48 - 16}$。\n- 用例 B（平滑混合，较大应变）：$N = 64$，$a_0 = 1.0$，$k_1 = 1.0$，$k_2 = 0.25$，$F = 1.10$，以及与用例 A 相同的线性斜坡 $w_i$。\n- 用例 C（尖锐界面）：$N = 64$，$a_0 = 1.0$，$k_1 = 1.0$，$k_2 = 0.25$，$F = 1.05$，以及阶跃混合 $w_i = 1$ 对于 $i  32$，$w_i = 0$ 对于 $i \\geq 32$。\n- 用例 D（小系统，混合相互作用）：$N = 8$，$a_0 = 1.0$，$k_1 = 1.0$，$k_2 = 0.5$，$F = 1.03$，以及线性斜坡 $w_i = 1$ 对于 $i \\leq 2$，$w_i = 0$ 对于 $i \\geq 6$，对于 $i \\in (2,6)$，$w_i = 1 - \\frac{i - 2}{6 - 2}$。\n\n你的程序应生成单行输出，其中包含结果，格式为以逗号分隔的各用例列表的列表，不含空格，并用方括号括起来。例如：\"[[rA1,rA2,rA3,rA4],[rB1,rB2,rB3,rB4],...]\"。每个 $r$ 必须是无量纲单位的浮点数。", "solution": "该问题要求分析一维并发原子-连续介质耦合系统中的鬼力。首先，我们必须推导鬼力的解析表达式。鬼力是在耦合方案不保持能量一致性时，在均匀变形下产生的伪内力。其次，我们必须提出并实施一种修正方法来消除这些力。最后，我们针对几个测试用例，量化修正前后这些力的大小。\n\n### 1. 鬼力向量的推导\n\n系统的总混合能量由下式给出：\n$$\nE^{\\text{blend}}(x;F,w) = \\sum_{i=0}^{N-1} \\left[ w_i E_i^{\\text{a}}(x) + (1 - w_i) E_i^{\\text{cb}}(F) \\right]\n$$\n原子 $i$ 上的内力定义为势能相对于其位置 $x_i$ 的负梯度。鬼力 $f_i^{\\text{ghost}}$ 是在所有原子都根据均匀变形梯度 $F$（即对所有 $k$ 都有 $x_k = F a_0 k$）进行位移的构型下计算得到的该力。\n$$\nf_i^{\\text{ghost}}(F,w) = - \\frac{\\partial E^{\\text{blend}}(x;F,w)}{\\partial x_i} \\bigg|_{x_k = F a_0 k}\n$$\n连续介质点能量 $E_i^{\\text{cb}}(F)$ 仅取决于全局变形参数 $F$，而不取决于单个原子位置 $x_k$。因此，它对任何 $x_i$ 的偏导数都为零。计算简化为仅对能量的原子部分进行微分：\n$$\nf_i^{\\text{ghost}}(F,w) = - \\frac{\\partial}{\\partial x_i} \\left( \\sum_{j=0}^{N-1} w_j E_j^{\\text{a}}(x) \\right) \\bigg|_{x_k = F a_0 k}\n$$\n所提供的原子点能量 $E_j^{\\text{a}}(x)$ 是通过平均分配键能来构建的。总原子势能 $U^{\\text{a}}(x) = \\sum_j w_j E_j^{\\text{a}}(x)$ 可以重新表示为对键的求和。原子 $j$ 和 $j+m$（其中 $m=1$ 或 $m=2$）之间的键能被分配到点 $j$ 和 $j+m$。对应于最近邻键的项 $(x_{j+1}-x_j-a_0)^2$ 出现在 $E_j^{\\text{a}}$ 和 $E_{j+1}^{\\text{a}}$ 中。它对 $U^{\\text{a}}(x)$ 的总贡献由其端点权重的平均值 $(w_j+w_{j+1})/2$ 进行调制。类似的论证也适用于二阶最近邻。这使我们能够更方便地写出总原子能量：\n$$\nU^{\\text{a}}(x) = \\sum_{j=0}^{N-1} \\left[ \\frac{k_1}{4}(w_j + w_{j+1})(x_{j+1} - x_j - a_0)^2 + \\frac{k_2}{4}(w_j + w_{j+2})(x_{j+2} - x_j - 2a_0)^2 \\right]\n$$\n现在，我们对 $U^{\\text{a}}(x)$ 关于 $x_i$ 求导。变量 $x_i$ 出现在涉及其邻居的项中。对于一阶近邻相互作用：\n$$\n\\frac{\\partial}{\\partial x_i} \\left[ \\frac{k_1}{4}(w_{i-1}+w_i)(x_i-x_{i-1}-a_0)^2 + \\frac{k_1}{4}(w_i+w_{i+1})(x_{i+1}-x_i-a_0)^2 \\right] \\\\\n= \\frac{k_1}{2}(w_{i-1}+w_i)(x_i-x_{i-1}-a_0) - \\frac{k_1}{2}(w_i+w_{i+1})(x_{i+1}-x_i-a_0)\n$$\n对于二阶近邻相互作用：\n$$\n\\frac{\\partial}{\\partial x_i} \\left[ \\frac{k_2}{4}(w_{i-2}+w_i)(x_i-x_{i-2}-2a_0)^2 + \\frac{k_2}{4}(w_i+w_{i+2})(x_{i+2}-x_i-2a_0)^2 \\right] \\\\\n= \\frac{k_2}{2}(w_{i-2}+w_i)(x_i-x_{i-2}-2a_0) - \\frac{k_2}{2}(w_i+w_{i+2})(x_{i+2}-x_i-2a_0)\n$$\n我们现在在均匀变形状态 $x_k = F a_0 k$ 下评估这些导数。键的伸长量变为：\n$x_{i+m} - x_i - m a_0 = F a_0 (i+m) - F a_0 i - m a_0 = m a_0 (F-1)$。\n将此代入导数中：\n$$\n\\frac{\\partial U^{\\text{a}}}{\\partial x_i}\\bigg|_{x_k=Fa_0k} = \\frac{k_1}{2}(w_{i-1}+w_i)(a_0(F-1)) - \\frac{k_1}{2}(w_i+w_{i+1})(a_0(F-1)) \\\\\n+ \\frac{k_2}{2}(w_{i-2}+w_i)(2a_0(F-1)) - \\frac{k_2}{2}(w_i+w_{i+2})(2a_0(F-1))\n$$\n提出公因式后得到：\n$$\n\\frac{\\partial U^{\\text{a}}}{\\partial x_i}\\bigg|_{x_k=Fa_0k} = \\frac{k_1 a_0(F-1)}{2} (w_{i-1} - w_{i+1}) + k_2 a_0(F-1) (w_{i-2} - w_{i+2})\n$$\n鬼力是此表达式的负值：\n$$\nf_i^{\\text{ghost}} = - \\frac{\\partial U^{\\text{a}}}{\\partial x_i}\\bigg|_{x_k=Fa_0k} = a_0(F-1) \\left[ \\frac{k_1}{2}(w_{i+1} - w_{i-1}) + k_2(w_{i+2} - w_{i-2}) \\right]\n$$\n此公式表明，鬼力仅在权重函数 $w_i$ 变化的区域非零，因为力的表达式类似于 $w$ 导数的有限差分近似。在 $w_i$ 为常数的区域（完全原子模拟或完全连续介质模拟），力按要求消失为零。\n\n### 2. 鬼力修正\n\n如果在均匀变形下内力为零，则通过斑图测试。我们推导出的 $f_i^{\\text{ghost}}$ 在界面区域通常不为零。为了修正这一点，我们引入一个修正能量 $E^{\\text{corr}}(x)$，使得总力为零：\n$$\nf_i^{\\text{total}} = - \\frac{\\partial}{\\partial x_i} \\left( E^{\\text{blend}}(x;F,w) + E^{\\text{corr}}(x) \\right) \\bigg|_{x_k = F a_0 k} = 0\n$$\n这意味着修正项产生的力必须恰好抵消鬼力：\n$$\nf_i^{\\text{corr}} = - \\frac{\\partial E^{\\text{corr}}(x)}{\\partial x_i} \\bigg|_{x_k=Fa_0k} = -f_i^{\\text{ghost}}\n$$\n问题要求最简单的线性鬼力修正。对于给定的一组参数 $\\{F, w_i, k_1, k_2, a_0\\}$，量 $f_i^{\\text{ghost}}$ 是常数，因为它们不依赖于动态位置 $x_i$。一个相对于位置恒定的力是由一个在位置上呈线性的势能产生的。我们将修正能量定义为：\n$$\nE^{\\text{corr}}(x) = \\sum_{j=0}^{N-1} f_j^{\\text{ghost}} x_j\n$$\n那么，在位点 $i$ 的修正力为：\n$$\nf_i^{\\text{corr}} = - \\frac{\\partial E^{\\text{corr}}}{\\partial x_i} = -f_i^{\\text{ghost}}\n$$\n在修正系统中，在均匀变形状态下评估的原子 $i$ 上的总力为：\n$$\nf_i^{\\text{total}} = f_i^{\\text{ghost}} + f_i^{\\text{corr}} = f_i^{\\text{ghost}} - f_i^{\\text{ghost}} = 0\n$$\n因此，修正后的系统通过构造的方式通过了斑图测试。对于所有原子，鬼力恒为零。\n\n### 3. 范数的量化\n\n我们被要求为每个测试用例计算四个量：\n- $G_{\\text{naive}}$：未经修正的鬼力向量 $\\|\\boldsymbol{f}^{\\text{ghost}}\\|$ 的欧几里得范数。\n- $G_{\\text{corrected}}$：修正后的鬼力向量的欧几里得范数。\n- $S_{\\text{naive}}$：未经修正的残余应力范数 $\\|\\boldsymbol{\\sigma}_{\\text{ghost}}\\|$。\n- $S_{\\text{corrected}}$：修正后的残余应力范数。\n\n基于推导：\n未经修正的鬼力范数为：\n$$\nG_{\\text{naive}} = \\left( \\sum_{i=0}^{N-1} (f_i^{\\text{ghost}})^2 \\right)^{1/2}\n$$\n修正后的鬼力向量是零向量，所以其范数为：\n$$\nG_{\\text{corrected}} = 0\n$$\n问题陈述，残余应力向量与力向量相同（假设单位横截面积）。因此，应力范数在数值上与力范数相同：\n$$\nS_{\\text{naive}} = G_{\\text{naive}}\n$$\n$$\nS_{\\text{corrected}} = G_{\\text{corrected}} = 0\n$$\n每个用例的最终输出是列表 $[G_{\\text{naive}}, 0.0, G_{\\text{naive}}, 0.0]$。我们现在将为指定的测试用例实现 $G_{\\text{naive}}$ 的计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the ghost force norms for several atomistic-continuum coupling scenarios.\n    \"\"\"\n\n    test_cases = [\n        # Case A: Smooth blending, small strain\n        {\n            \"N\": 64, \"a0\": 1.0, \"k1\": 1.0, \"k2\": 0.25, \"F\": 1.02,\n            \"w_type\": \"linear\", \"w_params\": {\"i1\": 16, \"i2\": 48}\n        },\n        # Case B: Smooth blending, larger strain\n        {\n            \"N\": 64, \"a0\": 1.0, \"k1\": 1.0, \"k2\": 0.25, \"F\": 1.10,\n            \"w_type\": \"linear\", \"w_params\": {\"i1\": 16, \"i2\": 48}\n        },\n        # Case C: Sharp interface\n        {\n            \"N\": 64, \"a0\": 1.0, \"k1\": 1.0, \"k2\": 0.25, \"F\": 1.05,\n            \"w_type\": \"step\", \"w_params\": {\"isplit\": 32}\n        },\n        # Case D: Small system, mixed interactions\n        {\n            \"N\": 8, \"a0\": 1.0, \"k1\": 1.0, \"k2\": 0.5, \"F\": 1.03,\n            \"w_type\": \"linear\", \"w_params\": {\"i1\": 2, \"i2\": 6}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N, a0, k1, k2, F = case[\"N\"], case[\"a0\"], case[\"k1\"], case[\"k2\"], case[\"F\"]\n        \n        # Construct the weight vector w\n        w = np.zeros(N)\n        if case[\"w_type\"] == \"linear\":\n            i1, i2 = case[\"w_params\"][\"i1\"], case[\"w_params\"][\"i2\"]\n            # w_i = 1 for i = i1\n            w[0:i1 + 1] = 1.0\n            # Linear ramp for i in (i1, i2)\n            ramp_indices = np.arange(i1 + 1, i2)\n            w[ramp_indices] = 1.0 - (ramp_indices - i1) / (i2 - i1)\n            # w_i = 0 for i >= i2 is already set by np.zeros initialization\n            \n        elif case[\"w_type\"] == \"step\":\n            isplit = case[\"w_params\"][\"isplit\"]\n            w[0:isplit] = 1.0\n            # The rest are already zero\n            \n        # Calculate ghost forces using a vectorized approach for periodic boundaries\n        # w_{i+1} corresponds to rolling the array left by 1\n        w_ip1 = np.roll(w, -1)\n        w_im1 = np.roll(w, 1)\n        w_ip2 = np.roll(w, -2)\n        w_im2 = np.roll(w, 2)\n        \n        # Formula for ghost force:\n        # f_i^ghost = a0*(F-1) * [ k1/2 * (w_{i+1} - w_{i-1}) + k2 * (w_{i+2} - w_{i-2}) ]\n        f_ghost = a0 * (F - 1) * (0.5 * k1 * (w_ip1 - w_im1) + k2 * (w_ip2 - w_im2))\n        \n        # Task 3: Calculate norms\n        # G_naive is the Euclidean norm of the uncorrected ghost force vector\n        g_naive = np.linalg.norm(f_ghost)\n        \n        # G_corrected is 0 by construction of the linear force correction\n        g_corrected = 0.0\n        \n        # S_naive and S_corrected are numerically identical to G_naive and G_corrected\n        # as per the problem statement (unit cross-sectional area)\n        s_naive = g_naive\n        s_corrected = 0.0\n        \n        results.append([g_naive, g_corrected, s_naive, s_corrected])\n\n    # Format the final output string exactly as required\n    case_strings = []\n    for res_list in results:\n        # Using str() for default floating point representation\n        case_strings.append(f\"[{','.join(map(str, res_list))}]\")\n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3467957"}, {"introduction": "多尺度建模不仅限于将不同模型在空间上同时耦合，还可以采用“层级” (hierarchical) 的方式，即利用精细尺度的计算结果来构建或校准粗尺度模型。本练习将引导您构建一个层级模型，将微观尺度下离散位错源的统计行为与宏观尺度下连续介质的硬化规律联系起来[@problem_id:3468017]。您的任务是运用该模型来预测一个真实存在的物理现象：微柱压缩实验中的“越小越强”尺寸效应。通过这个实践，您将体验到多尺度思想如何将微观物理机制融入宏观本构关系，从而解释单一尺度模型无法捕捉的复杂材料行为。", "problem": "考虑一个直径为 $D$ 的面心立方 (FCC) 微柱，在轴向载荷下被压缩，其晶体取向固定，使得分解剪应力通过 Schmid 定律与轴向应力相关联。目标是构建一个从离散位错源统计出发，到连续介质硬化定律结束的跨层次到连续介质的桥梁模型，然后用它来预测流动应力对微柱直径 $D$ 的依赖关系，并证明在塑性剪切应变固定的情况下，流动应力近似地与 $1/\\sqrt{D}$ 成标度关系。所有应力都必须以兆帕 (MPa) 为单位表示。\n\n从以下基本原理和定义出发，您必须使用它们来建立和求解模型：\n\n1. Frank–Read 源的激活和环的产生：一个特征长度为 $L$ 的源产生一个位错环，并为微观结构贡献位错线长度。在小体积中，源的长度受到微柱直径 $D$ 的几何截断。\n\n2. 位错的储存和回复由关于位错密度 $\\rho$ 随塑性剪切应变 $\\gamma$ 变化的 Kocks–Mecking 型演化定律描述：\n$$\n\\frac{d \\rho}{d \\gamma} = \\frac{k_s(D)}{b\\, \\ell(D)} - k_a \\rho,\n$$\n其中 $b$ 是 Burgers 矢量的模，$\\ell(D)$ 是微柱中位错的有效平均自由程，$k_s(D)$ 是由离散源统计信息决定的无量纲储存系数，$k_a$ 是单位剪切应变的回复系数。\n\n3. Taylor 关系式将流动分解剪应力 $\\tau$ 与位错密度联系起来：\n$$\n\\tau = \\alpha\\, G\\, b\\, \\sqrt{\\rho},\n$$\n其中 $\\alpha$ 是一个无量纲硬化因子，$G$ 是剪切模量。轴向流动应力 $\\sigma$ 通过 Schmid 定律与分解剪应力相关：\n$$\n\\sigma = \\frac{\\tau}{m},\n$$\n其中 $m$ 是给定晶体取向的 Schmid 因子。\n\n将离散源长度 $L$ 建模为服从 Weibull 分布并受微柱几何形状截断。设原始 Weibull 概率密度为\n$$\nf_{\\text{raw}}(L; \\lambda, k) = \\frac{k}{\\lambda} \\left(\\frac{L}{\\lambda}\\right)^{k-1} \\exp\\left( - \\left(\\frac{L}{\\lambda}\\right)^k \\right),\n$$\n其尺度参数为 $\\lambda$，形状参数为 $k$，并且只考虑区间 $[L_{\\min}, D]$ 内的源长度。定义截断平均源长度为\n$$\n\\mathbb{E}[L \\mid L_{\\min} \\le L \\le D] = \\frac{\\int_{L_{\\min}}^{D} L\\, f_{\\text{raw}}(L; \\lambda, k)\\, dL}{F(D;\\lambda,k) - F(L_{\\min};\\lambda,k)},\n$$\n其中 $F(x;\\lambda,k) = 1 - \\exp\\left( - (x/\\lambda)^k \\right)$ 是原始 Weibull 分布的累积分布函数。\n\n为了将离散源统计与连续介质储存系数联系起来，定义\n$$\nR(D) = \\frac{\\mathbb{E}[L \\mid L_{\\min} \\le L \\le D]}{D},\n$$\n并选择一个固定的参考直径 $D_{\\text{ref}}$ 来归一化储存系数，使得\n$$\nk_s(D) = k_{s0}\\, \\frac{R(D)}{R(D_{\\text{ref}})},\n$$\n其中 $k_{s0}$ 是一个常数。假设有效平均自由程为 $\\ell(D) = c_\\ell D$，其中 $c_\\ell$ 是一个捕捉几何约束和内部障碍的常数。\n\n使用以上信息，您必须：\n- 基于给定的 $d\\rho/d\\gamma$ 定律，从第一性原理推导出位错密度 $\\rho(\\gamma, D)$，展示对 $D$ 的依赖性是如何引入的，然后通过 Taylor 关系式和 Schmid 定律计算轴向流动应力 $\\sigma(\\gamma, D)$。\n- 通过使用直径对计算经验标度指数 $n$ 来证明近似标度关系 $\\sigma \\propto 1/\\sqrt{D}$：\n$$\nn = -\\frac{\\ln\\left(\\sigma(D_2)/\\sigma(D_1)\\right)}{\\ln\\left(D_2/D_1\\right)}.\n$$\n\n使用的材料和模型参数（除非另有说明，所有常数在各测试案例中均相同）：\n- 剪切模量 $G = 48 \\times 10^9$ (帕斯卡),\n- Burgers 矢量模 $b = 0.256 \\times 10^{-9}$ (米),\n- 硬化因子 $\\alpha = 0.3$ (无量纲),\n- 回复系数 $k_a = 4.0$ (每单位剪切应变),\n- 平均自由程系数 $c_\\ell = 0.5$ (无量纲),\n- 初始位错密度 $\\rho_0 = 1.0 \\times 10^{12}$ (米$^{-2}$),\n- 储存归一化常数 $k_{s0} = 1.0$ (无量纲),\n- 参考直径 $D_{\\text{ref}} = 2.0$ (微米)。\n\n单位和转换：\n- 直径 $D$、$D_1$、$D_2$，Weibull 尺度参数 $\\lambda$ 和最小源长度 $L_{\\min}$ 以微米为单位指定，在计算中必须转换为米。\n- 塑性剪切应变 $\\gamma$ 和 Schmid 因子 $m$ 是无量纲的。\n- 最终的轴向流动应力必须以兆帕 (MPa) 为单位返回。\n\n测试套件：\n计算以下参数集的输出。对于类型为“stress”的案例，返回以 MPa 为单位的轴向流动应力 $\\sigma$。对于类型为“exponent”的案例，返回指数 $n$ 作为浮点数。每个案例都是独立的。\n- 案例 1 (stress, 正常路径): $D = 2.0$ (微米), $\\gamma = 0.2$, $m = 0.5$, $\\lambda = 1.0$ (微米), $k = 2.0$, $L_{\\min} = 0.1$ (微米)。\n- 案例 2 (stress, 小直径边界): $D = 0.5$ (微米), $\\gamma = 0.2$, $m = 0.5$, $\\lambda = 1.0$ (微米), $k = 2.0$, $L_{\\min} = 0.1$ (微米)。\n- 案例 3 (stress, 大直径边界): $D = 10.0$ (微米), $\\gamma = 0.2$, $m = 0.5$, $\\lambda = 1.0$ (微米), $k = 2.0$, $L_{\\min} = 0.1$ (微米)。\n- 案例 4 (stress, 取向变化): $D = 2.0$ (微米), $\\gamma = 0.2$, $m = 0.3$, $\\lambda = 1.0$ (微米), $k = 2.0$, $L_{\\min} = 0.1$ (微米)。\n- 案例 5 (stress, 源统计变化): $D = 2.0$ (微米), $\\gamma = 0.2$, $m = 0.5$, $\\lambda = 0.5$ (微米), $k = 1.0$, $L_{\\min} = 0.1$ (微米)。\n- 案例 6 (exponent, 标度关系演示): $(D_1, D_2) = (1.0, 4.0)$ (微米), $\\gamma = 0.5$, $m = 0.5$, $\\lambda = 1.0$ (微米), $k = 2.0$, $L_{\\min} = 0.1$ (微米)。使用上述定义为这两个直径计算 $n$，并保持所有其他参数不变。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如\n$[r_1,r_2,\\dots]$,\n其中 $r_i$ 是上述列表中第 $i$ 个案例的浮点数结果。所有轴向应力均以 MPa 表示。不得打印任何其他文本。", "solution": "该问题要求构建一个跨层次多尺度模型，以预测微柱的流动应力 $\\sigma$ 作为其直径 $D$ 的函数。该模型充当了连接微观尺度上的离散位错源统计与宏观尺度上塑性流动的连续介质描述之间的桥梁。推导和计算求解过程分为四个主要步骤。\n\n**1. 位错密度的演化**\n\n连续介质模型的基础是描述总位错密度 $\\rho$ 作为塑性剪切应变 $\\gamma$ 函数的 Kocks–Mecking 演化定律：\n$$ \\frac{d \\rho}{d \\gamma} = \\frac{k_s(D)}{b\\, \\ell(D)} - k_a \\rho $$\n这是一个关于 $\\rho(\\gamma)$ 的一阶线性常微分方程。重新排列各项，我们得到标准形式：\n$$ \\frac{d \\rho}{d \\gamma} + k_a \\rho = \\frac{k_s(D)}{b\\, \\ell(D)} $$\n右边的项相对于应变 $\\gamma$ 是一个常数。为简单起见，我们可以将其表示为 $C(D) = k_s(D) / (b\\, \\ell(D))$。该方程使用积分因子 $I(\\gamma) = \\exp(\\int k_a d\\gamma) = \\exp(k_a \\gamma)$ 求解。其通解形式为：\n$$ \\rho(\\gamma) = \\frac{C(D)}{k_a} + K e^{-k_a \\gamma} $$\n其中 $K$ 是积分常数。我们通过应用初始条件 $\\rho(\\gamma=0) = \\rho_0$ 来确定 $K$。这得到 $K = \\rho_0 - C(D)/k_a$。将其代回通解，得到位错密度的特解：\n$$ \\rho(\\gamma, D) = \\frac{k_s(D)}{k_a b\\, \\ell(D)} + \\left(\\rho_0 - \\frac{k_s(D)}{k_a b\\, \\ell(D)}\\right) e^{-k_a \\gamma} $$\n该方程描述了随着塑性应变的累积，位错密度如何从初始状态 $\\rho_0$ 演化到饱和密度 $\\rho_{\\text{sat}}(D) = k_s(D) / (k_a b\\, \\ell(D))$。\n\n**2. 从离散源到连续介质储存系数**\n\n模型的尺寸敏感性是通过依赖于微柱直径 $D$ 的参数引入的：储存系数 $k_s(D)$ 和位错平均自由程 $\\ell(D)$。\n平均自由程被假设为与微柱直径成正比，$\\ell(D) = c_\\ell D$，反映了几何约束。\n储存系数 $k_s(D)$ 是从离散的 Frank-Read 位错源的统计数据中推导出来的。这些源的长度 $L$ 通过 Weibull 分布建模，但被微柱边界几何截断在区间 $[L_{\\min}, D]$ 内。连接不同尺度的关键量是截断平均源长度 $\\mathbb{E}[L \\mid L_{\\min} \\le L \\le D]$，其定义为：\n$$ \\mathbb{E}[L \\mid L_{\\min} \\le L \\le D] = \\frac{\\int_{L_{\\min}}^{D} L\\, f_{\\text{raw}}(L; \\lambda, k)\\, dL}{\\int_{L_{\\min}}^{D} f_{\\text{raw}}(L; \\lambda, k)\\, dL} $$\n分子中的积分是 Weibull 分布的一阶不完全矩，分母表示截断区间 $[L_{\\min}, D]$ 内的概率质量。通过使用下不完全伽玛函数 $\\gamma(s,x) = \\int_0^x t^{s-1} e^{-t} dt$ 可以方便地计算该表达式。其均值的解析表达式为：\n$$ \\mathbb{E}[L_D] = \\lambda \\frac{\\gamma\\left(1+\\frac{1}{k}, \\left(\\frac{D}{\\lambda}\\right)^k\\right) - \\gamma\\left(1+\\frac{1}{k}, \\left(\\frac{L_{\\min}}{\\lambda}\\right)^k\\right)}{\\exp\\left(-\\left(\\frac{L_{\\min}}{\\lambda}\\right)^k\\right) - \\exp\\left(-\\left(\\frac{D}{\\lambda}\\right)^k\\right)} $$\n这里我们使用简写 $\\mathbb{E}[L_D]$ 来表示 $\\mathbb{E}[L \\mid L_{\\min} \\le L \\le D]$。\n然后通过定义一个无量纲比率 $R(D) = \\mathbb{E}[L_D] / D$ 来建立与连续介质储存项的联系。该比率捕捉了平均源长度与微柱直径的偏差。$R(D)$ 用于对在参考直径 $D_{\\text{ref}}$ 处定义的参考储存系数 $k_{s0}$ 进行标度：\n$$ k_s(D) = k_{s0}\\, \\frac{R(D)}{R(D_{\\text{ref}})} = k_{s0}\\, \\frac{\\mathbb{E}[L_D]/D}{\\mathbb{E}[L_{D_{\\text{ref}}}]/D_{\\text{ref}}} $$\n这种表述确保了随着微柱尺寸 $D$ 的减小，源长度分布的截断效应变得更加显著，从而改变了平均源长度，并因此改变了位错的储存速率。\n\n**3. 轴向流动应力的计算**\n\n一旦确定了给定应变和直径下的位错密度 $\\rho(\\gamma, D)$，就可以使用 Taylor 关系式计算分解剪应力 $\\tau$。该关系式将微观位错结构与宏观流动应力联系起来：\n$$ \\tau(\\gamma, D) = \\alpha\\, G\\, b\\, \\sqrt{\\rho(\\gamma, D)} $$\n最后，通过 Schmid 定律获得驱动压缩所需的轴向流动应力 $\\sigma$。该定律利用 Schmid 因子 $m$ 将活动滑移系上的分解剪应力投影到加载轴上：\n$$ \\sigma(\\gamma, D) = \\frac{\\tau(\\gamma, D)}{m} = \\frac{\\alpha\\, G\\, b}{m} \\sqrt{\\rho(\\gamma, D)} $$\n为了进行数值计算，所有参数都必须以一致的单位制表示，通常是国际单位制 SI (米、帕斯卡等)。然后将轴向应力的最终结果从帕斯卡 (Pa) 转换为兆帕 (MPa)，即除以 $10^6$。\n\n**4. 尺寸依赖性标度分析**\n\n该问题假设应力与直径之间存在近似的幂律标度关系 $\\sigma \\propto D^{-n}$，预期指数为 $n \\approx 0.5$。为了在模型内部验证这一预测，根据在两个不同直径 $D_1$ 和 $D_2$ 下的两个应力预测值 $\\sigma_1 = \\sigma(\\gamma, D_1)$ 和 $\\sigma_2 = \\sigma(\\gamma, D_2)$ 计算经验标度指数 $n$。假设该幂律成立：\n$$ \\sigma_1 = C D_1^{-n} \\quad \\text{and} \\quad \\sigma_2 = C D_2^{-n} $$\n将这两个方程相除可以消去常数 $C$：$\\sigma_2/\\sigma_1 = (D_2/D_1)^{-n}$。对两边取自然对数并求解 $n$，得到所提供的公式：\n$$ n = -\\frac{\\ln\\left(\\sigma_2/\\sigma_1\\right)}{\\ln\\left(D_2/D_1\\right)} $$\n该计算为层次模型在指定的微柱直径范围内所预测的“越小越强”尺寸效应提供了定量度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammainc, gamma\n\n# --- Model Parameters and Constants ---\n# All values are in base SI units (meters, Pascals, etc.) unless specified otherwise.\nG = 48.0e9  # Shear modulus (Pa)\nb = 0.256e-9  # Burgers vector magnitude (m)\nalpha = 0.3  # Hardening factor (dimensionless)\nka = 4.0  # Recovery coefficient (per unit shear strain)\ncl = 0.5  # Mean free path coefficient (dimensionless)\nrho0 = 1.0e12  # Initial dislocation density (m^-2)\nks0 = 1.0  # Storage normalization constant (dimensionless)\nD_ref = 2.0e-6  # Reference diameter (m)\n\ndef calculate_truncated_mean_L(D_val, L_min_val, lambda_val, k_val):\n    \"\"\"\n    Calculates the truncated mean source length E[L | L_min = L = D].\n    All length inputs must be in meters.\n    \"\"\"\n    if np.isclose(D_val, L_min_val):\n        return L_min_val\n    \n    if D_val  L_min_val:\n        # Physical case of an empty set of possible source lengths.\n        return np.nan\n\n    u_min = (L_min_val / lambda_val)**k_val\n    u_max = (D_val / lambda_val)**k_val\n    s = 1.0 + 1.0 / k_val\n\n    # Numerator is related to the incomplete gamma function.\n    # scipy.special.gammainc is the regularized lower incomplete gamma function P(s, x)\n    # where P(s, x) = gamma(s, x) / Gamma(s).\n    # So, gamma(s, x) = gammainc(s, x) * Gamma(s).\n    gamma_s = gamma(s)\n    gamma_lower_max = gammainc(s, u_max) * gamma_s\n    gamma_lower_min = gammainc(s, u_min) * gamma_s\n    numerator = lambda_val * (gamma_lower_max - gamma_lower_min)\n\n    # Denominator is the probability mass in the truncated interval.\n    denominator = np.exp(-u_min) - np.exp(-u_max)\n    \n    if np.isclose(denominator, 0.0):\n        # This case can occur if u_min and u_max are very large, making both\n        # exponentials numerically zero. This implies L_min >> lambda.\n        # This is not expected for the given test cases but is a possible edge case.\n        # Alternatively, if D is very close to L_min, but np.isclose failed.\n        return np.nan\n\n    return numerator / denominator\n\ndef calculate_stress_mpa(D_um, gamma_strain, m, lambda_um, k, L_min_um):\n    \"\"\"\n    Calculates the axial flow stress in MPa for a given set of parameters.\n    \"\"\"\n    # Convert inputs from micrometers to meters\n    D = D_um * 1e-6\n    lambda_val = lambda_um * 1e-6\n    L_min = L_min_um * 1e-6\n\n    # 1. Calculate truncated mean lengths for the given D and the reference D_ref\n    #    The source statistics (lambda, k, L_min) are the same for both calculations.\n    E_L_D = calculate_truncated_mean_L(D, L_min, lambda_val, k)\n    E_L_D_ref = calculate_truncated_mean_L(D_ref, L_min, lambda_val, k)\n    \n    # 2. Calculate the normalized ratios R(D) and R(D_ref)\n    R_D = E_L_D / D\n    R_D_ref = E_L_D_ref / D_ref\n    \n    # 3. Calculate the diameter-dependent storage coefficient ks(D)\n    ks_D = ks0 * (R_D / R_D_ref)\n    \n    # 4. Solve for dislocation density rho\n    ell_D = cl * D\n    rho_sat = ks_D / (ka * b * ell_D)\n    rho = rho_sat + (rho0 - rho_sat) * np.exp(-ka * gamma_strain)\n    \n    # 5. Calculate stresses\n    # Taylor relation for resolved shear stress\n    tau = alpha * G * b * np.sqrt(rho)\n    # Schmid law for axial stress in Pa\n    sigma_pa = tau / m\n    \n    # 6. Convert final axial stress to MPa\n    sigma_mpa = sigma_pa / 1e6\n    \n    return sigma_mpa\n\ndef calculate_exponent(D1_um, D2_um, gamma_strain, m, lambda_um, k, L_min_um):\n    \"\"\"\n    Calculates the empirical scaling exponent n.\n    \"\"\"\n    # Calculate stresses at diameters D1 and D2.\n    # The units of stress (Pa or MPa) do not matter for the ratio.\n    sigma1 = calculate_stress_mpa(D1_um, gamma_strain, m, lambda_um, k, L_min_um)\n    sigma2 = calculate_stress_mpa(D2_um, gamma_strain, m, lambda_um, k, L_min_um)\n    \n    # The units of diameter (um or m) do not matter for the ratio.\n    n = -np.log(sigma2 / sigma1) / np.log(D2_um / D1_um)\n    \n    return n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (stress): D=2.0, γ=0.2, m=0.5, λ=1.0, k=2.0, Lmin=0.1\n        {'type': 'stress', 'params': {'D_um': 2.0, 'gamma_strain': 0.2, 'm': 0.5, 'lambda_um': 1.0, 'k': 2.0, 'L_min_um': 0.1}},\n        # Case 2 (stress): D=0.5, γ=0.2, m=0.5, λ=1.0, k=2.0, Lmin=0.1\n        {'type': 'stress', 'params': {'D_um': 0.5, 'gamma_strain': 0.2, 'm': 0.5, 'lambda_um': 1.0, 'k': 2.0, 'L_min_um': 0.1}},\n        # Case 3 (stress): D=10.0, γ=0.2, m=0.5, λ=1.0, k=2.0, Lmin=0.1\n        {'type': 'stress', 'params': {'D_um': 10.0, 'gamma_strain': 0.2, 'm': 0.5, 'lambda_um': 1.0, 'k': 2.0, 'L_min_um': 0.1}},\n        # Case 4 (stress): D=2.0, γ=0.2, m=0.3, λ=1.0, k=2.0, Lmin=0.1\n        {'type': 'stress', 'params': {'D_um': 2.0, 'gamma_strain': 0.2, 'm': 0.3, 'lambda_um': 1.0, 'k': 2.0, 'L_min_um': 0.1}},\n        # Case 5 (stress): D=2.0, γ=0.2, m=0.5, λ=0.5, k=1.0, Lmin=0.1\n        {'type': 'stress', 'params': {'D_um': 2.0, 'gamma_strain': 0.2, 'm': 0.5, 'lambda_um': 0.5, 'k': 1.0, 'L_min_um': 0.1}},\n        # Case 6 (exponent): (D1,D2)=(1.0,4.0), γ=0.5, m=0.5, λ=1.0, k=2.0, Lmin=0.1\n        {'type': 'exponent', 'params': {'D1_um': 1.0, 'D2_um': 4.0, 'gamma_strain': 0.5, 'm': 0.5, 'lambda_um': 1.0, 'k': 2.0, 'L_min_um': 0.1}},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'stress':\n            result = calculate_stress_mpa(**case['params'])\n        elif case['type'] == 'exponent':\n            result = calculate_exponent(**case['params'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3468017"}]}