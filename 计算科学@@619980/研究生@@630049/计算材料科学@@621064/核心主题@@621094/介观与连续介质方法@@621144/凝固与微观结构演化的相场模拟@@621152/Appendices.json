{"hands_on_practices": [{"introduction": "在微观结构演化中，由界面曲率驱动的晶界迁移是一个关键机制，例如在晶粒粗化过程中。然而，第二相粒子的存在会产生一种名为“Zener钉扎”的阻力，阻碍晶界运动。本练习 [@problem_id:3476640] 采用一个简化的常微分方程（ODE）模型来捕捉这种驱动力与钉扎力之间的平衡。在深入研究复杂的、空间分辨的相场模型之前，这个练习为您提供了一个清晰直观的物理基础，帮助您理解决定微观结构稳定性的核心原理。", "problem": "要求您为嵌入惰性、不可移动的第二相粒子基体中的单个圆形晶粒的极限（钉扎）半径，建立并模拟一个最小连续介质模型。其控制原理是由曲率驱动的界面运动，该运动受到粒子-边界相互作用引起的钉扎阻力压力的阻碍。目标是对得到的半径演化方程进行数值积分，直到几个参数集达到稳定的钉扎状态，然后对不同情况进行无量纲比较汇总。\n\n请使用以下建模基础，这是计算材料科学中的标准方法，并且与二维晶界运动的相场曲率驱动极限一致：法向界面速度是正的迁移率-能量系数与净驱动曲率的乘积。在存在惰性粒子的情况下，驱动收缩的曲率受到一个阻力项的阻碍，该阻力项取决于粒子尺寸及其体积分数。在半径为 $R(t)$ 的圆形几何结构中，这会产生一个常微分方程，其形式为\n$$\n\\frac{dR}{dt} \\;=\\; - M \\, \\gamma \\left( \\frac{1}{R} \\;-\\; \\kappa_{\\mathrm{pin}} \\right),\n$$\n其中 $M$ 是正的晶界迁移率，$\\gamma$ 是正的比晶界能，$\\kappa_{\\mathrm{pin}}$ 是由粒子产生的有效钉扎曲率。对于半径为 $r$、体积分数为 $f$ 的惰性球形粒子，一个广泛使用且经过充分检验的表示方法是有效钉扎压力与 $\\gamma \\, f / r$ 成正比，这可以重新表示为有效曲率 $\\kappa_{\\mathrm{pin}} = C_{\\mathrm{Z}} \\, f / r$，其中 $C_{\\mathrm{Z}}$ 是一个量级为1的无量纲常数，取决于几何形状和接触条件。在本问题中，采用 $C_{\\mathrm{Z}} = 3/4$，并进行无量纲化，使得 $M \\gamma = 1$。\n\n您的任务是：\n- 实现一个时间积分器，以在以下条件下演化 $R(t)$\n$$\n\\frac{dR}{dt} \\;=\\; \\frac{1}{R} \\;-\\; C_{\\mathrm{Z}} \\, \\frac{f}{r},\n$$\n其中 $C_{\\mathrm{Z}} = 3/4$，初始半径 $R(0) = R_0 > 0$。使用一个稳定的显式格式，并配备足够的时间步长控制，以高精度收敛到稳定钉扎半径。确保在积分过程中 $R(t)$ 保持为正。全程使用无量纲单位，因此无需报告物理单位。\n- 对于测试套件中的每个参数集，进行积分，直到对于稳态的某个运行估计值 $R_\\infty$ 满足相对变化准则 $\\lvert R(t) - R_\\infty \\rvert / R_\\infty  \\varepsilon$（公差 $\\varepsilon = 10^{-9}$），或者直到达到一个较大但有限的迭代上限，并使用可获得的最佳 $R(t)$。一个实用且充分的停止条件是监测残差 $\\left| \\frac{1}{R(t)} - C_{\\mathrm{Z}} \\frac{f}{r} \\right|$，并在其降至与 $\\varepsilon$ 一致选择的公差以下时终止。\n- 对于每种情况，报告无量纲缩放比 $S = R_\\infty / (r/f)$，四舍五入到六位小数。\n\n测试套件：\n- 情况1：$(r, f, R_0) = (0.01, 0.05, 0.40)$。\n- 情况2：$(r, f, R_0) = (0.02, 0.05, 0.20)$。\n- 情况3：$(r, f, R_0) = (0.005, 0.02, 0.25)$。\n- 情况4：$(r, f, R_0) = (0.01, 0.20, 0.20)$。\n- 情况5：$(r, f, R_0) = (0.01, 0.005, 2.00)$。\n\n覆盖性设计：\n- 情况1和4的初始值 $R_0$ 大于预期的稳态值，因此 $R(t)$ 应减小至钉扎半径。\n- 情况2、3和5的初始值 $R_0$ 小于预期的稳态值，因此 $R(t)$ 应增大至钉扎半径。\n- 该集合涵盖了较小和较大的粒子半径 $r$ 和体积分数 $f$，以探究对这两个参数的敏感性。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含列表 $[S_1,S_2,S_3,S_4,S_5]$，每个 $S_i$ 四舍五入到六位小数，以逗号分隔并用方括号括起来，例如 `[1.234000,1.234000,1.234000,1.234000,1.234000]`。", "solution": "用户提供了一个问题陈述，在尝试解决之前需要对其进行验证。\n\n### 第1步：提取已知条件\n\n-   **控制性常微分方程（ODE）**：对于半径为 $R(t)$ 的圆形晶粒，其变化率由以下公式给出：\n    $$\n    \\frac{dR}{dt} \\;=\\; - M \\, \\gamma \\left( \\frac{1}{R} \\;-\\; \\kappa_{\\mathrm{pin}} \\right)\n    $$\n-   **参数**：\n    -   $M$：正的晶界迁移率。\n    -   $\\gamma$：正的比晶界能。\n    -   $\\kappa_{\\mathrm{pin}}$：有效钉扎曲率。\n-   **钉扎曲率模型**：\n    $$\n    \\kappa_{\\mathrm{pin}} = C_{\\mathrm{Z}} \\, \\frac{f}{r}\n    $$\n    -   $r$：惰性球形粒子的半径。\n    -   $f$：惰性球形粒子的体积分数。\n    -   $C_{\\mathrm{Z}}$：无量纲常数，指定为 $C_{\\mathrm{Z}} = 3/4$。\n-   **无量纲化**：迁移率-能量乘积设为1：$M \\gamma = 1$。\n-   **用于模拟的简化ODE**：\n    $$\n    \\frac{dR}{dt} \\;=\\; \\frac{1}{R} \\;-\\; C_{\\mathrm{Z}} \\, \\frac{f}{r}\n    $$\n-   **初始条件**：$R(0) = R_0 > 0$。\n-   **数值任务**：\n    -   实现一个带有时间步长控制的稳定显式时间积分方案。\n    -   确保 $R(t)$ 保持为正。\n-   **收敛准则**：当系统达到稳定的钉扎状态时，积分应停止。该状态由半径的相对变化公差 $\\varepsilon = 10^{-9}$ 定义，或通过监测残差 $\\left| \\frac{1}{R(t)} - C_{\\mathrm{Z}} \\frac{f}{r} \\right|$ 直至其降至一个一致的公差以下来判断。还应设置一个有限的迭代上限。\n-   **输出量**：对于每种情况，报告无量纲缩放比 $S = R_\\infty / (r/f)$，其中 $R_\\infty$ 是稳态（钉扎）半径，四舍五入到六位小数。\n-   **测试套件**：\n    -   情况1：$(r, f, R_0) = (0.01, 0.05, 0.40)$\n    -   情况2：$(r, f, R_0) = (0.02, 0.05, 0.20)$\n    -   情况3：$(r, f, R_0) = (0.005, 0.02, 0.25)$\n    -   情况4：$(r, f, R_0) = (0.01, 0.20, 0.20)$\n    -   情况5：$(r, f, R_0) = (0.01, 0.005, 2.00)$\n-   **最终输出格式**：一个表示计算出的 $S$ 值列表的字符串：`[S_1,S_2,S_3,S_4,S_5]`。\n\n### 第2步：使用提取的已知条件进行验证\n\n1.  **科学依据**：该模型是带有 Zener 钉扎的曲率驱动晶粒长大的经典表示。方程 $\\frac{dR}{dt} \\propto (\\kappa - \\kappa_{\\mathrm{pin}})$，其中 $\\kappa=1/R$ 是曲率，是材料科学中的标准公式。Zener 钉扎项 $\\kappa_{\\mathrm{pin}} \\propto f/r$ 是一个公认的结果。指定值 $C_{\\mathrm{Z}} = 3/4$ 是简化二维几何的标准理论值。该问题在科学上是合理的。\n2.  **适定性**：该问题是求解一个具有给定初始条件 $R(0)=R_0$ 的一阶常微分方程 $\\frac{dR}{dt} = F(R)$。函数 $F(R) = \\frac{1}{R} - K$，其中 $K = C_{\\mathrm{Z}} f/r$ 是一个正常数，在 $(0, \\infty)$ 中的任何闭区间上都是 Lipschitz 连续的。因此，存在唯一且稳定的解。稳态是明确定义的。\n3.  **客观性**：问题使用精确的数学和科学语言陈述。所有参数和条件都已定量定义。没有主观性。\n4.  **完整性和一致性**：问题提供了所有必要信息：控制方程、所有常数、每个测试用例的初始条件，以及对所需输出的明确定义。整个设置是内部一致的。\n\n### 第3步：结论与行动\n\n问题陈述是**有效的**。它有科学依据，是适定的、客观的且自洽的。任务是基于计算材料科学中的一个标准模型进行数值模拟。我现在将着手解决。\n\n### 解决方案\n\n该问题要求对半径演化方程进行数值积分，以找到稳态钉扎半径 $R_\\infty$，然后计算一个特定的无量纲比值 $S$。\n\n首先，我们分析控制方程以确定解析的稳态解。晶粒半径 $R(t)$ 的演化由以下常微分方程给出：\n$$\n\\frac{dR}{dt} = \\frac{1}{R(t)} - C_{\\mathrm{Z}} \\frac{f}{r}\n$$\n为方便起见，让常数钉扎项表示为 $K_{\\mathrm{pin}} = C_{\\mathrm{Z}} \\frac{f}{r}$。方程变为：\n$$\n\\frac{dR}{dt} = \\frac{1}{R} - K_{\\mathrm{pin}}\n$$\n当半径不再随时间变化时，即当 $\\frac{dR}{dt} = 0$ 时，系统达到稳态或钉扎状态。设 $R_\\infty$ 为此状态下的半径。\n$$\n0 = \\frac{1}{R_\\infty} - K_{\\mathrm{pin}}\n$$\n求解 $R_\\infty$，我们得到：\n$$\nR_\\infty = \\frac{1}{K_{\\mathrm{pin}}} = \\frac{1}{C_{\\mathrm{Z}} \\frac{f}{r}} = \\frac{r}{C_{\\mathrm{Z}} f}\n$$\n问题要求计算无量纲缩放比 $S$，其定义为：\n$$\nS = \\frac{R_\\infty}{r/f}\n$$\n代入我们对 $R_\\infty$ 的解析表达式：\n$$\nS = \\frac{r/(C_{\\mathrm{Z}} f)}{r/f} = \\frac{1}{C_{\\mathrm{Z}}}\n$$\n给定常数 $C_{\\mathrm{Z}} = 3/4$，缩放比的理论值为：\n$$\nS = \\frac{1}{3/4} = \\frac{4}{3} \\approx 1.333333...\n$$\n对于给定模型，这是一个普适常数，与具体的粒子半径 $r$、体积分数 $f$ 或初始晶粒半径 $R_0$ 无关。每个测试用例的数值模拟应该收敛到一个状态，在该状态下，计算出的缩放比 $S$ 等于此值，直至达到指定的数值精度。不同的初始条件和参数用于测试数值积分方案的鲁棒性和正确性。\n\n为了执行数值积分，我们将使用显式 Forward Euler 方法，对于足够小的时间步长，这是一个简单且稳定的选择。基于第 $n$ 步的值更新第 $n+1$ 步半径的规则是：\n$$\nR_{n+1} = R_n + \\Delta t \\cdot \\left( \\frac{1}{R_n} - K_{\\mathrm{pin}} \\right)\n$$\n其中 $\\Delta t$ 是时间步长。为使此方案稳定，必须仔细选择 $\\Delta t$。围绕不动点 $R_\\infty$ 的线性稳定性分析表明，稳定性要求 $\\Delta t \\le 2/K_{\\mathrm{pin}}^2$。为确保所有测试用例的稳定性，我们为每个用例计算 $K_{\\mathrm{pin}}$ 并找出最严格的条件。情况4（$r=0.01, f=0.20$）产生最大的 $K_{\\mathrm{pin}} = (3/4) \\cdot 0.20 / 0.01 = 15$，给出的稳定性极限为 $\\Delta t \\le 2/15^2 \\approx 0.0089$。固定的时间步长 $\\Delta t = 0.001$ 安全地低于此极限，并将用于所有模拟。\n\n当系统足够接近稳态时，模拟将终止。根据建议，我们将监测常微分方程的残差，也就是速度项本身：\n$$\n\\text{residual} = \\left| \\frac{1}{R_n} - K_{\\mathrm{pin}} \\right|\n$$\n当该残差降至一个小的公差 $\\text{tol}_{\\text{res}}$ 以下时，模拟停止。为了满足半径相对误差的最终精度要求 $\\varepsilon = 10^{-9}$，我们选择一个保守的公差 $\\text{tol}_{\\text{res}} = 10^{-12}$。同时使用迭代上限作为保障措施。\n\n每个测试用例的算法如下：\n1.  用给定的 $R_0$ 初始化 $R$。\n2.  计算常数钉扎项 $K_{\\mathrm{pin}} = (3/4) \\cdot f/r$。\n3.  使用固定 $\\Delta t = 0.001$ 的 Forward Euler 方法迭代更新 $R$。\n4.  在每一步，检查变化率的绝对值 $|1/R - K_{\\mathrm{pin}}|$ 是否小于公差 $10^{-12}$。\n5.  如果满足条件，循环终止，并将当前的 $R$ 值作为 $R_\\infty$。\n6.  计算缩放比 $S = R_\\infty / (r/f)$。\n7.  将计算出的 $S$ 值格式化为六位小数。\n\n此过程将对所有五个测试用例重复，以生成最终的结果列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates the evolution of a circular grain radius under curvature-driven\n    motion with Zener pinning and computes a nondimensional scaling ratio.\n    \"\"\"\n    # Define constants from the problem statement.\n    C_Z = 3.0 / 4.0\n\n    # Numerical integration parameters.\n    # The time step DT is chosen to be smaller than the most restrictive stability\n    # limit calculated across all test cases to ensure the Forward Euler scheme is stable.\n    DT = 1e-3\n    # The residual tolerance is set to a small value to ensure the final radius\n    # converges to the steady state with high accuracy.\n    TOLERANCE_RESIDUAL = 1e-12\n    # A maximum number of iterations acts as a safeguard against non-convergence.\n    MAX_ITERATIONS = 5 * 10**7\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (particle_radius r, volume_fraction f, initial_grain_radius R0)\n    test_cases = [\n        (0.01, 0.05, 0.40),   # Case 1\n        (0.02, 0.05, 0.20),   # Case 2\n        (0.005, 0.02, 0.25),  # Case 3\n        (0.01, 0.20, 0.20),   # Case 4\n        (0.01, 0.005, 2.00),  # Case 5\n    ]\n\n    results = []\n    # Process each test case.\n    for r, f, R0 in test_cases:\n        # Calculate the constant effective pinning curvature.\n        pinning_kappa = C_Z * f / r\n\n        # Initialize the grain radius for the current simulation.\n        R_current = R0\n        \n        # Perform time-stepping integration until steady state is reached.\n        for _ in range(MAX_ITERATIONS):\n            # The rate of change of the radius is the residual of the ODE at steady state.\n            velocity = 1.0 / R_current - pinning_kappa\n\n            # Check for convergence: if velocity is close to zero, we are at steady state.\n            if abs(velocity)  TOLERANCE_RESIDUAL:\n                break\n            \n            # Update the radius using the explicit Forward Euler method.\n            R_new = R_current + DT * velocity\n            \n            # A check to ensure the radius remains physically meaningful (positive).\n            # With a stable DT and R0 > 0, R_new should not become non-positive.\n            if R_new = 0:\n                # This state indicates a potential numerical instability and should not be reached.\n                # If it occurs, we assign a very small positive number and stop.\n                R_current = 1e-12 \n                break\n\n            R_current = R_new\n        \n        # The final radius is the numerical approximation of the steady-state radius R_infinity.\n        R_infinity = R_current\n        \n        # Calculate the nondimensional scaling ratio S as requested.\n        # Analytically, S = R_infinity / (r/f) should be 1/C_Z = 4/3.\n        scaling_ratio = R_infinity / (r / f)\n        \n        # Append the formatted result to the list.\n        results.append(f\"{scaling_ratio:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3476640"}, {"introduction": "在理解了物理驱动力之后，我们现在转向相场模拟的数值计算方面。这些模型依赖于求解偏微分方程，而保证数值格式的稳定性是其中至关重要的一步。本练习 [@problem_id:3476642] 将指导您对Cahn-Hilliard方程进行冯·诺依曼稳定性分析，这是许多合金体系相场模型的基石。通过这个练习，您将掌握一项开发稳健可靠求解器的基本技能。", "problem": "考虑一个长度为 $L$ 的一维周期性区域，该区域被 $N$ 个均匀间隔的节点离散化，网格间距为 $h = L / N$。令 $c(x,t)$ 表示一个守恒序参量（组分），它根据从在均匀参考态下具有正曲率的自由能密度得到的线性化 Cahn–Hilliard (CH) 方程演化。从自由能泛函 $F[c] = \\int \\left( f(c) + \\frac{\\kappa}{2} |\\nabla c|^2 \\right) \\, dx$（其中 $\\kappa \\ge 0$）和化学势 $\\mu = \\frac{\\delta F}{\\delta c}$ 出发，CH 演化定律为 $\\partial_t c = \\nabla \\cdot \\left( M \\nabla \\mu \\right)$，其中 $M \\ge 0$ 是迁移率。在均匀组分 $c_0$ 附近进行线性化，并设 $f''(c_0) = A \\ge 0$（常数），可得\n$$\n\\frac{\\partial c}{\\partial t} = M \\left( A \\nabla^2 c - \\kappa \\nabla^4 c \\right).\n$$\n使用具有周期性边界条件的二阶精度中心有限差分对空间进行离散化，并使用时间步长为 $\\Delta t$ 的前向欧拉（FE）格式对时间进行离散化。周期性网格上的离散拉普拉斯算子可被傅里叶模对角化，而 von Neumann 分析将全离散格式简化为每个离散傅里叶模振幅 $C_m^n$ 的标量线性更新：\n$$\nC_m^{n+1} = G_m(\\Delta t) \\, C_m^n, \\quad G_m(\\Delta t) = 1 + \\Delta t \\, \\lambda_m,\n$$\n其中 $\\lambda_m$ 是与模态指数 $m \\in \\{0,1,\\dots,N-1\\}$ 相关的线性算子 $M \\left( A \\nabla_h^2 - \\kappa \\nabla_h^4 \\right)$ 的离散特征值，$\\nabla_h^2$ 表示离散拉普拉斯算子。对于给定的 $\\Delta t$，仅当对每个模态指数 $m$ 都有 $|G_m(\\Delta t)| \\le 1$ 时，前向欧拉格式才是稳定的。\n\n您的任务是：\n\n- 使用基本定义（自由能泛函、化学势、线性化和 von Neumann 模态分析），推导确定最大允许时间步长 $\\Delta t_{\\max}$ 的稳定性条件，使得前向欧拉格式对周期性网格上的所有离散傅里叶模都是稳定的。用算子 $M \\left( A \\nabla_h^2 - \\kappa \\nabla_h^4 \\right)$ 的离散谱以及基本常数 $M$、$A$、$\\kappa$、$L$ 和 $N$ 来表示 $\\Delta t_{\\max}$。不要假设任何连续极限的简化公式；从周期性网格上的离散算子开始。\n\n- 设计一个算法，在给定 $L$、$N$、$M$、$A$ 和 $\\kappa$ 的情况下，通过扫描所有离散傅里叶模并对所有 $m$ 强制执行 von Neumann 准则 $|G_m(\\Delta t)| \\le 1$ 来计算 $\\Delta t_{\\max}$，并理解 $A \\ge 0$ 和 $\\kappa \\ge 0$。您的算法应使用周期性二阶差分算子及其平方的精确离散特征值。\n\n- 实现一个程序，该程序：\n  1) 通过扫描所有离散傅里叶模，为下面测试套件中的每个参数集计算 $\\Delta t_{\\max}$（以秒为单位）。\n  2) 对于指定的参数集和三个给定的乘数 $\\gamma$，通过检查所有模态的 von Neumann 准则，评估选择 $\\Delta t = \\gamma \\, \\Delta t_{\\max}$ 是否稳定（布尔结果）。\n\n物理和数值细节：\n\n- 空间单位必须是米，时间单位必须是秒。迁移率 $M$以及系数 $A$ 和 $\\kappa$ 应被视为与线性化 CH 模型一致的给定正常数；报告计算出的每个 $\\Delta t_{\\max}$（以秒为单位）。不涉及任何角度量。\n\n测试套件：\n\n- 为以下每个参数集计算 $\\Delta t_{\\max}$（以秒为单位）：\n  - 情况 T$1$：$L = 1.0\\times 10^{-6}$ m, $N = 64$, $M = 1.0\\times 10^{-14}$, $A = 1.0\\times 10^{9}$, $\\kappa = 1.0\\times 10^{-14}$。\n  - 情况 T$2$：$L = 1.0\\times 10^{-6}$ m, $N = 64$, $M = 1.0\\times 10^{-14}$, $A = 1.0\\times 10^{9}$, $\\kappa = 0.0$。\n  - 情况 T$3$：$L = 1.0\\times 10^{-6}$ m, $N = 63$, $M = 1.0\\times 10^{-14}$, $A = 1.0\\times 10^{9}$, $\\kappa = 1.0\\times 10^{-14}$。\n  - 情况 T$4$：$L = 1.0\\times 10^{-6}$ m, $N = 64$, $M = 1.0\\times 10^{-14}$, $A = 1.0$, $\\kappa = 1.0\\times 10^{-14}$。\n\n- 对于稳定性检查，使用情况 T$1$ 的参数和以下乘数：\n  - $\\gamma_1 = 0.5$，\n  - $\\gamma_2 = 1.0$，\n  - $\\gamma_3 = 1.01$，\n  并通过检查所有离散模态的 von Neumann 条件，确定对于 $\\Delta t = \\gamma_i \\, \\Delta t_{\\max}$（$i \\in \\{1,2,3\\}$），前向欧拉方法是否稳定。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个扁平列表，其值为\n  $[\\Delta t_{\\max}(\\text{T}1), \\Delta t_{\\max}(\\text{T}2), \\Delta t_{\\max}(\\text{T}3), \\Delta t_{\\max}(\\text{T}4), \\text{stable}(\\gamma_1), \\text{stable}(\\gamma_2), \\text{stable}(\\gamma_3)]$，\n  其中前四项是浮点数（以秒为单位），后三项是布尔值，所有值都用逗号分隔并用方括号括起来，例如 $[x_1, x_2, x_3, x_4, \\text{True}, \\text{True}, \\text{False}]$。", "solution": "我们从自由能泛函 $F[c] = \\int \\left( f(c) + \\frac{\\kappa}{2} |\\nabla c|^2 \\right) \\, dx$ 开始，其化学势为 $\\mu = \\frac{\\delta F}{\\delta c} = f'(c) - \\kappa \\nabla^2 c$。Cahn–Hilliard (CH) 方程是一个守恒律\n$$\n\\frac{\\partial c}{\\partial t} = \\nabla \\cdot \\left( M \\nabla \\mu \\right).\n$$\n在均匀态 $c_0$ 附近进行线性化，并设 $A = f''(c_0) \\ge 0$，可得\n$$\n\\frac{\\partial c}{\\partial t} = M \\left( A \\nabla^2 c - \\kappa \\nabla^4 c \\right).\n$$\n\n我们考虑一个具有 $N$ 个均匀点和间距 $h = L/N$ 的周期性一维区域 $[0,L]$。令 $c_j^n$ 表示在网格索引 $j \\in \\{0,1,\\dots,N-1\\}$ 和时间层 $n$ 的离散解。具有周期性边界条件的标准二阶中心离散拉普拉斯算子为\n$$\n(\\nabla_h^2 c)_j = \\frac{c_{j+1} - 2 c_j + c_{j-1}}{h^2},\n$$\n其中索引是周期性的。线性化 CH 方程的前向欧拉（FE）离散格式为\n$$\nc^{n+1} = c^n + \\Delta t \\; M \\left( A \\nabla_h^2 c^n - \\kappa \\nabla_h^4 c^n \\right),\n$$\n其中 $\\nabla_h^4 = \\nabla_h^2 \\circ \\nabla_h^2$。\n\n为分析稳定性，我们通过投影到离散傅里叶基上，使用 von Neumann 模态分析。周期性网格上的离散拉普拉斯算子可被波数为 $k_m = \\frac{2\\pi m}{L}$（对于 $m \\in \\{0,1,\\dots,N-1\\}$）的离散傅里叶模 $e^{\\mathrm{i} k_m x}$ 对角化。等价地，以网格索引表示，模态为 $\\varphi_m(j) = e^{\\mathrm{i} 2\\pi m j / N}$。模态指数 $m$ 的离散拉普拉斯算子特征值为\n$$\n\\lambda_{\\Delta}(m) = \\frac{e^{\\mathrm{i} 2\\pi m / N} - 2 + e^{-\\mathrm{i} 2\\pi m / N}}{h^2} = \\frac{-2 + 2 \\cos(2\\pi m / N)}{h^2} = - \\frac{4}{h^2} \\sin^2\\!\\left( \\frac{\\pi m}{N} \\right).\n$$\n因此，离散双调和算子的特征值为 $\\lambda_{\\Delta^2}(m) = \\left( \\lambda_{\\Delta}(m) \\right)^2$。线性算子 $M \\left( A \\nabla_h^2 - \\kappa \\nabla_h^4 \\right)$ 的特征值为\n$$\n\\lambda_m = M \\left( A \\lambda_{\\Delta}(m) - \\kappa \\left( \\lambda_{\\Delta}(m) \\right)^2 \\right).\n$$\n对于 $A \\ge 0$、$\\kappa \\ge 0$ 和 $m \\ne 0$，我们有 $\\lambda_{\\Delta}(m) \\le 0$ 和 $\\left( \\lambda_{\\Delta}(m) \\right)^2 \\ge 0$，因此 $\\lambda_m \\le 0$。零模 $m=0$ 产生 $\\lambda_{\\Delta}(0) = 0$ 因而 $\\lambda_0 = 0$，这反映了守恒性。\n\n模态振幅 $C_m^n$ 的 FE 更新为\n$$\nC_m^{n+1} = \\left( 1 + \\Delta t \\, \\lambda_m \\right) C_m^n,\n$$\n其放大因子为 $G_m(\\Delta t) = 1 + \\Delta t \\lambda_m$。对于实数负特征值 $\\lambda_m$，FE 的稳定性要求 $-2 \\le \\Delta t \\lambda_m \\le 0$，或等价地，对于每个 $\\lambda_m  0$ 的 $m$，要求 $0 \\le \\Delta t \\le \\frac{2}{|\\lambda_m|}$。最紧的界限由最负（绝对值最大）的 $\\lambda_m$ 控制，即，使非负量\n$$\ns_m \\equiv -\\lambda_{\\Delta}(m) = \\frac{4}{h^2} \\sin^2\\!\\left( \\frac{\\pi m}{N} \\right)\n$$\n最大化的模态。\n其中 $s_m \\in [0, s_{\\max}]$，且\n$$\ns_{\\max} = \\max_{m \\in \\{0,1,\\dots,N-1\\}} s_m = \\frac{4}{h^2} \\sin^2\\!\\left( \\frac{\\pi \\lfloor N/2 \\rfloor}{N} \\right),\n$$\n最负特征值的绝对值为\n$$\n|\\lambda|_{\\max} = \\max_{m} \\left( -\\lambda_m \\right) = M \\left( A s_{\\max} + \\kappa s_{\\max}^2 \\right),\n$$\nFE 稳定的最大时间步长为\n$$\n\\Delta t_{\\max} = \\frac{2}{|\\lambda|_{\\max}} = \\frac{2}{M \\left( A s_{\\max} + \\kappa s_{\\max}^2 \\right)}.\n$$\n这个结果也可以通过算法得到，即扫描所有模态指数 $m$，并对 $\\lambda_m  0$ 的模态计算 $\\frac{2}{-\\lambda_m}$ 的最小值。\n\n算法设计：\n\n- 输入 $L$、$N$、$M$、$A$、$\\kappa$。计算 $h = L / N$。\n- 对每个整数 $m \\in \\{0,1,\\dots,N-1\\}$，计算离散拉普拉斯特征值 $\\lambda_{\\Delta}(m) = -\\frac{4}{h^2} \\sin^2\\!\\left( \\frac{\\pi m}{N} \\right)$。\n- 计算 $\\lambda_m = M \\left( A \\lambda_{\\Delta}(m) - \\kappa \\left( \\lambda_{\\Delta}(m) \\right)^2 \\right)$。\n- 对于所有 $\\lambda_m  0$ 的模态（即 $m \\ne 0$），计算候选界限 $\\Delta t_m = \\frac{2}{-\\lambda_m}$，并取这些模态中 $\\Delta t_m$ 的最小值为 $\\Delta t_{\\max}$。以秒为单位报告 $\\Delta t_{\\max}$。\n- 为了测试给定乘数 $\\gamma$ 的稳定性，设 $\\Delta t = \\gamma \\, \\Delta t_{\\max}$ 并检查所有 $m$ 的 von Neumann 条件 $|1 + \\Delta t \\lambda_m| \\le 1$。由于对于 $A \\ge 0, \\kappa \\ge 0$，所有 $\\lambda_m$ 都是实数且非正，这简化为验证对于每个 $\\lambda_m  0$ 的模态，$\\Delta t \\le \\frac{2}{-\\lambda_m}$。等价地，可以计算 $\\max_m |1 + \\Delta t \\lambda_m|$ 并与 $1$ 在一个小的数值容差内进行比较。\n\n测试套件覆盖 rationale：\n\n- 情况 T$1$ 是一个通用设置，其中二阶项和四阶项都有贡献。\n- 情况 T$2$ 将 $\\kappa = 0$ 设置为恢复一个二阶算子；这简化为类似扩散的约束，并检验了 $\\Delta t_{\\max} \\sim h^2$ 的极限情况。\n- 情况 T$3$ 使用奇数 $N$ 来检验离散谱中最高模态相对于偶数 $N$ 的轻微偏移。\n- 情况 T$4$ 使用一个非常小的 $A$ 使四阶项占主导，检验了 $\\Delta t_{\\max} \\sim h^4$ 的极限情况。\n- 乘数 $\\gamma_1 = 0.5$、$\\gamma_2 = 1.0$ 和 $\\gamma_3 = 1.01$ 分别测试了一个严格稳定的选择、稳定性的边界以及一个预期对最严格模态不稳定的略微超临界的选择。\n\n该实现通过使用精确的离散特征值扫描所有离散模态来计算 $\\Delta t_{\\max}$，并报告四个 $\\Delta t_{\\max}$ 值（以秒为单位），然后是针对指定乘数的三个稳定性布尔值，将它们聚合成所需输出格式的单个扁平列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef discrete_laplacian_eigs_periodic(N, h):\n    \"\"\"\n    Compute the eigenvalues of the 1D periodic second-difference Laplacian\n    with grid spacing h and N points.\n    lambda_D(m) = -4/h^2 * sin^2(pi*m/N), for m=0,...,N-1\n    \"\"\"\n    m = np.arange(N, dtype=np.float64)\n    angles = np.pi * m / N\n    lam = -4.0 / (h * h) * (np.sin(angles) ** 2)\n    return lam\n\ndef max_stable_dt(L, N, M, A, kappa):\n    \"\"\"\n    Compute the maximum stable forward Euler time step for the linearized\n    Cahn-Hilliard operator M*(A*Δ - κ*Δ^2) on a periodic 1D grid.\n    Returns dt_max (float).\n    \"\"\"\n    h = L / N\n    lam_delta = discrete_laplacian_eigs_periodic(N, h)\n    # Operator eigenvalues: lambda_m = M*(A*lam_delta - kappa*lam_delta^2)\n    lam_op = M * (A * lam_delta - kappa * (lam_delta ** 2))\n    # Exclude modes with non-negative lambda (m=0 has lambda=0), consider only lambda  0\n    negative = lam_op  0.0\n    if not np.any(negative):\n        # No restrictive modes; dt can be arbitrarily large for FE (degenerate case).\n        return np.inf\n    # For each negative eigenvalue, FE stability requires dt = 2/(-lambda)\n    dt_candidates = 2.0 / (-lam_op[negative])\n    dt_max = np.min(dt_candidates)\n    return dt_max\n\ndef is_stable_dt(L, N, M, A, kappa, dt, tol=1e-12):\n    \"\"\"\n    Check von Neumann stability for a given dt by verifying |1 + dt*lambda_m| = 1\n    for all discrete modes (within a small tolerance to account for floating error).\n    \"\"\"\n    h = L / N\n    lam_delta = discrete_laplacian_eigs_periodic(N, h)\n    lam_op = M * (A * lam_delta - kappa * (lam_delta ** 2))\n    amp = 1.0 + dt * lam_op  # real quantities\n    # For modes with lambda=0 (m=0), amp=1 exactly; include tolerance.\n    return np.all(np.abs(amp) = 1.0 + tol)\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # dt_max test cases (T1..T4)\n    dt_cases = [\n        # (L, N, M, A, kappa) for T1\n        (1.0e-6, 64, 1.0e-14, 1.0e9, 1.0e-14),\n        # T2: kappa=0\n        (1.0e-6, 64, 1.0e-14, 1.0e9, 0.0),\n        # T3: odd N\n        (1.0e-6, 63, 1.0e-14, 1.0e9, 1.0e-14),\n        # T4: small A, fourth-order dominated\n        (1.0e-6, 64, 1.0e-14, 1.0, 1.0e-14),\n    ]\n\n    dt_max_values = []\n    for (L, N, M, A, kappa) in dt_cases:\n        dt_max = max_stable_dt(L, N, M, A, kappa)\n        dt_max_values.append(dt_max)\n\n    # Stability tests use parameters of T1 with gamma multipliers\n    L, N, M, A, kappa = dt_cases[0]\n    dt_max_T1 = dt_max_values[0]\n    gammas = [0.5, 1.0, 1.01]\n    stability_results = []\n    for g in gammas:\n        dt_test = g * dt_max_T1\n        stable = is_stable_dt(L, N, M, A, kappa, dt_test, tol=1e-12)\n        stability_results.append(stable)\n\n    # Aggregate final results: [dt_max_T1, dt_max_T2, dt_max_T3, dt_max_T4, stable(g1), stable(g2), stable(g3)]\n    results = dt_max_values + stability_results\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3476642"}, {"introduction": "在掌握了物理原理和数值稳定性的基础上，您现在已准备好应对一个全面的模拟挑战。本练习 [@problem_id:3476675] 要求您构建一个用于包晶凝固的多相场模型，这是一种在许多金属合金中至关重要的复杂相变过程。您将实现一个耦合方程组，以模拟多固相之间的竞争、溶质的重新分配以及定向凝固的影响，这是一个真实且高级的相场方法应用。", "problem": "要求您设计并实现一个最小的、自洽的一维多相场求解器，用于研究包晶系统中发生包晶反应 $L+\\alpha\\to\\beta$ 的定向凝固过程。该公式使用三个序参量来表示各相：$\\phi_{\\alpha}$、$\\phi_{\\beta}$ 和 $\\phi_{L}$，并约束 $\\phi_{\\alpha}+\\phi_{\\beta}+\\phi_{L}=1$，其中每个 $\\phi$ 的取值范围为 $[0,1]$。成分场为 $c(x,t)\\in[0,1]$。所有量均为无量纲。\n\n从以下基本和核心定义开始：\n- 非守恒（Allen–Cahn）序参量的变分动力学：$\\partial \\phi_i/\\partial t = -L\\,\\delta \\mathcal{F}/\\delta \\phi_i$，其中 $L0$ 是迁移率，$\\mathcal{F}$ 是自由能泛函。\n- 守恒成分场的守恒定律，包含扩散和平流：$\\partial c/\\partial t = \\nabla\\cdot\\left(D(\\phi_L)\\nabla c\\right) - V_p \\,\\partial c/\\partial x + S$，其中 $D(\\phi_L)$ 是与相相关的扩散系数，$V_p\\ge 0$ 是提拉速度，$S$ 是考虑相变过程中溶质交换的源项。\n- 具有恒定梯度的定向凝固温度场：$T(x,t)=T_0+G\\,(x - V_p\\,t)$，其中 $T_0$ 和 $G0$ 是常数。\n\n为序参量定义一个易于处理的单位体积自由能密度 $\\psi$，其包括双势阱、阻止相重叠的混合惩罚项、界面的梯度惩罚项，以及编码每相局部热力学驱动力的倾斜项：\n- 每个固相序参量的双势阱：$W\\,\\phi_i^2(1-\\phi_i)^2$，其中 $W0$ 且 $i\\in\\{\\alpha,\\beta\\}$。\n- 多相惩罚项，用 $\\phi_{\\alpha}$ 和 $\\phi_{\\beta}$ 表示，并满足 $\\phi_{L}=1-\\phi_{\\alpha}-\\phi_{\\beta}$：$\\eta\\left(\\phi_{\\alpha}+\\phi_{\\beta}-\\phi_{\\alpha}^2-\\phi_{\\beta}^2-\\phi_{\\alpha}\\phi_{\\beta}\\right)$，其中 $\\eta0$。\n- 梯度惩罚项：$(\\varepsilon^2/2)\\left(|\\nabla \\phi_{\\alpha}|^2+|\\nabla \\phi_{\\beta}|^2\\right)$，其中 $\\varepsilon0$。\n- 每个固相的热力学倾斜项：$-\\lambda_i f_i(T,c)\\,h(\\phi_i)$，其中 $i\\in\\{\\alpha,\\beta\\}$，$\\lambda_i0$，$h(\\phi)=\\phi^2(3-2\\phi)$，以及局部驱动力 $f_i(T,c)=T_{\\ell,i}(c)-T$。假设液相线关系是线性的 $T_{\\ell,i}(c)=T_i^0+m_i\\,c$，其中 $T_i^0$ 和 $m_i$ 是常数。\n\n由此，一维相场方程为：\n- 对于 $i\\in\\{\\alpha,\\beta\\}$，\n$$\n\\frac{\\partial \\phi_i}{\\partial t} = -L\\left(\\frac{\\partial \\psi}{\\partial \\phi_i} - \\varepsilon^2 \\frac{\\partial^2 \\phi_i}{\\partial x^2}\\right),\n$$\n其中\n$$\n\\frac{\\partial \\psi}{\\partial \\phi_{\\alpha}} = 2W\\,\\phi_{\\alpha}(1-\\phi_{\\alpha})(1-2\\phi_{\\alpha}) + \\eta\\,(1-2\\phi_{\\alpha}-\\phi_{\\beta}) - \\lambda_{\\alpha} f_{\\alpha}(T,c)\\,h'(\\phi_{\\alpha}),\n$$\n$$\n\\frac{\\partial \\psi}{\\partial \\phi_{\\beta}} = 2W\\,\\phi_{\\beta}(1-\\phi_{\\beta})(1-2\\phi_{\\beta}) + \\eta\\,(1-2\\phi_{\\beta}-\\phi_{\\alpha}) - \\lambda_{\\beta} f_{\\beta}(T,c)\\,h'(\\phi_{\\beta}),\n$$\n且 $h'(\\phi)=6\\phi(1-\\phi)$。强制 $\\phi_L=1-\\phi_{\\alpha}-\\phi_{\\beta}$，并在每个时间步后将 $\\phi_{\\alpha}、\\phi_{\\beta}、\\phi_{L}$ 投影到 $[0,1]$ 区间以维持约束。\n\n- 对于成分场，\n$$\n\\frac{\\partial c}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(D(\\phi_L)\\frac{\\partial c}{\\partial x}\\right) - V_p \\frac{\\partial c}{\\partial x} + S,\n$$\n其中 $D(\\phi_L)=D_L\\,\\phi_L + D_s\\,(1-\\phi_L)$，并使用一个小的 $D_s0$ 进行数值正则化。使用一个简化的由分配驱动的源项\n$$\nS = B_{\\alpha}\\,\\frac{\\partial \\phi_{\\alpha}}{\\partial t} + B_{\\beta}\\,\\frac{\\partial \\phi_{\\beta}}{\\partial t},\n$$\n其中 $B_i=(1-k_i)\\,c_{\\mathrm{ref}}$，$k_i\\in(0,1)$ 是有效分配系数，$c_{\\mathrm{ref}}$ 是参考浓度。\n\n在长度为 $L_x$、包含 $N_x$ 个点的均匀网格上进行空间离散化，并对所有场使用无通量（Neumann）边界条件。使用：\n- 中心差分法处理空间导数和带有 Neumann 边界条件的离散拉普拉斯算子。\n- 对 $\\phi_{\\alpha}$ 和 $\\phi_{\\beta}$ 使用显式时间步进（前向欧拉法）。\n- 对 $c$ 使用显式时间步进，并对平流项 $-V_p\\,\\partial c/\\partial x$ 使用迎风离散化。\n\n$t=0$ 时的初始条件：\n- 对于 $x\\in[0,w_{\\alpha}]$，$\\phi_{\\alpha}(x,0)\\approx 1$，并在一个量级为 $\\varepsilon$ 的界面宽度上平滑过渡到 $0$，在其他地方为 $0$。\n- $\\phi_{\\beta}(x,0)=0$，除非在选定的测试案例中指定了小的晶核。\n- $c(x,0)=c_0$ 均匀分布。\n\n参数值均为无量纲。数值求解器应运行至一个固定的最终时间 $t_f$。\n\n您的程序必须实现上述模型，并为下面定义的每个测试案例计算三个诊断量：\n1. 在最终时间 $t_f$ 的前沿领先指标 $I_{\\mathrm{lead}}\\in\\{0,1\\}$，其中 $0$ 表示 $\\alpha$ 前沿领先，$1$ 表示 $\\beta$ 前沿领先。将相 $i$ 的前沿位置定义为 $x_i=\\max\\{x: \\phi_i(x,t_f)\\ge 0.5\\}$（如果不存在这样的 $x$，则取 $x_i=-\\infty$）。具有较大 $x_i$ 的相为领先相。\n2. 在整个模拟时间窗口 $[0,t_f]$ 内观察到的最大溶质堆积 $\\Delta c_{\\max}=\\max_x c(x,t)-c_0$，以浮点数形式返回，并四舍五入到三位小数。\n3. 瞬态包晶岛指标 $I_{\\mathrm{isl}}\\in\\{0,1\\}$，如果在任何时间 $t\\in(0,t_f)$，$\\phi_{\\beta}(x,t)0.6$ 的不相交连续簇的数量超过了 $t=t_f$ 时的最终簇数量，并且在某个时刻至少为 $2$，则该指标等于 $1$；否则为 $0$。\n\n需要实现的仿真和数值细节：\n- 域和网格：$L_x=1$，$N_x=128$，网格间距 $\\Delta x=L_x/N_x$。\n- 时间步长和持续时间：$\\Delta t=5\\times 10^{-4}$，$t_f=N_t\\,\\Delta t$，其中 $N_t=800$。\n- 边界条件：对于所有场，在 $x=0$ 和 $x=L_x$ 处为齐次 Neumann 条件。\n- 所有案例的通用参数：$W=2$, $\\eta=2$, $\\varepsilon=0.02$, $L=1$, $D_s=10^{-4}$, $T_0=0.35$, $G=0.5$, $T_{\\alpha}^0=0.50$, $m_{\\alpha}=-0.30$, $T_{\\beta}^0=0.55$, $m_{\\beta}=-0.60$, $\\lambda_{\\alpha}=1.0$, $k_{\\alpha}=0.7$, $k_{\\beta}=0.6$, $c_{\\mathrm{ref}}=c_0$, $w_{\\alpha}=0.10$, 初始 $c_0=0.30$。\n- 初始 $\\phi_{\\alpha}(x,0)$ 分布：$\\phi_{\\alpha}(x,0)=\\frac{1}{2}\\left[1-\\tanh\\left(\\frac{x-w_{\\alpha}}{\\sqrt{2}\\,\\varepsilon}\\right)\\right]$ 并截断到 $[0,1]$。\n- 初始 $\\phi_{\\beta}(x,0)$：除非另有说明，否则为零；晶核是高斯分布 $\\phi_{\\beta}(x,0)=A_{\\beta}\\exp\\left(-\\frac{(x-x_{\\beta})^2}{2\\sigma_{\\beta}^2}\\right)$，截断到 $[0,1]$，宽度为 $\\sigma_{\\beta}=0.01$。\n\n三个测试案例的套件（均为无量纲）：\n- 案例 1：$(V_p,D_L,\\lambda_{\\beta},A_{\\beta})=(0.4,5\\times 10^{-4},0.8,0.0)$。\n- 案例 2：$(V_p,D_L,\\lambda_{\\beta},A_{\\beta})=(0.8,7.5\\times 10^{-4},1.2,0.0)$。\n- 案例 3：$(V_p,D_L,\\lambda_{\\beta},A_{\\beta})=(1.0,5\\times 10^{-4},1.1,0.20)$，其中 $x_{\\beta}=0.35$。\n\n角度单位不适用。所有输出均为无量纲。您的程序应生成单行输出，其中包含所有三个测试案例的结果，格式为一个由方括号括起来的、包含九个条目的逗号分隔列表，顺序为\n$[I_{\\mathrm{lead}}^{(1)},\\Delta c_{\\max}^{(1)},I_{\\mathrm{isl}}^{(1)},I_{\\mathrm{lead}}^{(2)},\\Delta c_{\\max}^{(2)},I_{\\mathrm{isl}}^{(2)},I_{\\mathrm{lead}}^{(3)},\\Delta c_{\\max}^{(3)},I_{\\mathrm{isl}}^{(3)}]$\n其中每个 $\\Delta c_{\\max}^{(i)}$ 四舍五入到三位小数，指标为整数 $0$ 或 $1$。", "solution": "用户提供的问题陈述已经过严格验证，并被认为是**有效的**。它在科学上基于计算材料科学的原理，特别是使用了多相场模型来研究凝固过程。该问题是适定的，提供了一套完整且一致的控制偏微分方程、参数、初始/边界条件以及数值离散化方案。它是客观且可形式化的，允许得到唯一的数值解。\n\n该问题要求实现一个一维、三相包晶凝固求解器。该模型将两个用于固相序参量 $\\phi_{\\alpha}$ 和 $\\phi_{\\beta}$ 的非守恒 Allen-Cahn 方程，与一个用于守恒成分场 $c$ 的类 Cahn-Hilliard 平流-扩散-反应方程耦合起来。系统在移动的温度梯度下演化，以模拟定向凝固。\n\n解决方案的实现方式是，按照规定，在均匀空间网格上离散化控制方程，并使用显式欧拉方案进行时间上的前向积分。数值实现包括以下关键步骤：\n\n1.  **网格和场初始化**：为长度为 $L_x=1$ 的域建立一个包含 $N_x=128$ 个点的一维网格。根据问题的初始条件，将场 $\\phi_{\\alpha}$、$\\phi_{\\beta}$ 和 $c$ 初始化为 NumPy 数组。具体来说，$\\phi_{\\alpha}(x,0)$ 是一个平滑的阶梯状分布，$c(x,0)$ 在 $c_0$ 处是均匀的，而 $\\phi_{\\beta}(x,0)$ 为零，除非在测试案例3中引入了高斯晶核。\n\n2.  **空间算子的离散化**：\n    *   出现在 $\\phi_{\\alpha}$ 和 $\\phi_{\\beta}$ 的 Allen-Cahn 方程中的拉普拉斯算子 $\\partial^2/\\partial x^2$，使用二阶中心差分格式进行离散化。在域边界 $x=0$ 和 $x=L_x$ 处强制施加齐次 Neumann 边界条件（$\\partial \\phi_i/\\partial x = 0$）。\n    *   成分方程中的平流项 $-V_p \\partial c/\\partial x$ 使用一阶迎风格式进行离散化，该格式适用于输运主导的现象并能增强数值稳定性。边界条件通过假设在迎风边界处的平流贡献为零来处理。\n    *   变系数扩散项 $\\partial/\\partial x (D(\\phi_L) \\partial c/\\partial x)$ 使用交错网格上的类有限体积方法进行离散化，以确保局部守恒。与相相关的扩散系数 $D(\\phi_L)$ 在单元界面处进行评估。成分场的齐次 Neumann 边界条件 $\\partial c/\\partial x=0$ 在边界处转化为扩散部分的零通量条件。\n\n3.  **时间积分**：按照要求，对所有三个场使用显式前向欧拉方法进行时间步进。时间步长为 $\\Delta t = 5 \\times 10^{-4}$。在主时间循环内部，该循环运行 $N_t=800$ 步：\n    *   移动温度场 $T(x,t)$ 在每个步骤中更新。\n    *   每个控制偏微分方程的右侧项（RHS）使用前一时间步的场值计算。这包括从自由能泛函中评估化学势导数以及成分方程的源项 $S$。\n    *   场值更新：$\\mathbf{u}^{n+1} = \\mathbf{u}^{n} + \\Delta t \\cdot \\text{RHS}(\\mathbf{u}^n)$，其中 $\\mathbf{u} = (\\phi_{\\alpha}, \\phi_{\\beta}, c)$。\n    *   每次更新后，一个投影步骤强制施加序参量的物理约束。首先将 $\\phi_{\\alpha}$ 和 $\\phi_{\\beta}$ 的值裁剪到区间 $[0,1]$。然后，在它们的和超过 $1$ 的网格单元中，对它们进行归一化以确保 $\\phi_{\\alpha} + \\phi_{\\beta} \\le 1$，从而保证 $\\phi_L = 1 - \\phi_{\\alpha} - \\phi_{\\beta} \\ge 0$。\n\n4.  **诊断量计算**：在整个模拟过程及其结束时，为每个测试案例计算指定的三个诊断量：\n    *   **前沿领先指标 ($I_{\\mathrm{lead}}$)**：在最终时间 $t_f$，通过找到 $\\phi_i(x,t_f) \\ge 0.5$ 的最大坐标 $x$ 来确定 $\\alpha$ 和 $\\beta$ 凝固前沿的位置。具有较大前沿位置的相为领先相。\n    *   **最大溶质堆积 ($\\Delta c_{\\max}$)**：在整个模拟过程中，跟踪所有网格点和所有时间步上 $c(x,t) - c_0$ 的最大值。最终结果四舍五入到三位小数。\n    *   **瞬态包晶岛指标 ($I_{\\mathrm{isl}}$)**：在每个时间步，使用 `scipy.ndimage.label` 函数计算 $\\phi_{\\beta}  0.6$ 的不同空间簇的数量。如果在模拟期间（对于 $t \\in (0, t_f)$）观察到的最大簇数大于在 $t=t_f$ 时的最终簇数，并且在某个时刻至少存在两个簇，则该指标设置为 $1$。否则为 $0$。\n\n以下代码为三个指定的测试案例实现了此数值解，并按要求格式化输出。", "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n\n    def run_simulation(case_params):\n        \"\"\"\n        Executes a single phase-field simulation run for a given set of parameters.\n        \"\"\"\n        # Unpack case-specific parameters\n        Vp, DL, lambda_beta, A_beta, x_beta = case_params\n\n        # --- Simulation and numerical parameters ---\n        Lx = 1.0\n        Nx = 128\n        dx = Lx / Nx\n        x = np.arange(Nx) * dx\n\n        Nt = 800\n        dt = 5.0e-4\n\n        # --- Common physical parameters ---\n        W = 2.0\n        eta = 2.0\n        epsilon = 0.02\n        L_mob = 1.0  # Mobility L from the problem statement\n        Ds = 1.0e-4\n        T0 = 0.35\n        G = 0.5\n        T_alpha_0 = 0.50\n        m_alpha = -0.30\n        T_beta_0 = 0.55\n        m_beta = -0.60\n        lambda_alpha = 1.0\n        k_alpha = 0.7\n        k_beta = 0.6\n        c0 = 0.30\n        c_ref = c0\n        w_alpha = 0.10\n        sigma_beta = 0.01\n\n        B_alpha = (1.0 - k_alpha) * c_ref\n        B_beta = (1.0 - k_beta) * c_ref\n\n        # --- Initial conditions ---\n        phi_a = 0.5 * (1.0 - np.tanh((x - w_alpha) / (np.sqrt(2.0) * epsilon)))\n        phi_a = np.clip(phi_a, 0.0, 1.0)\n\n        phi_b = np.zeros_like(x)\n        if A_beta > 0.0 and x_beta is not None:\n            phi_b = A_beta * np.exp(-((x - x_beta)**2) / (2.0 * sigma_beta**2))\n            phi_b = np.clip(phi_b, 0.0, 1.0)\n        \n        c = np.full_like(x, c0)\n\n        # --- Diagnostics trackers ---\n        max_delta_c = 0.0\n        num_beta_clusters_history = []\n        \n        def count_clusters(phi_field, threshold):\n            binary_field = phi_field > threshold\n            if not np.any(binary_field):\n                return 0\n            _, num_features = label(binary_field)\n            return num_features\n\n        # --- Main time integration loop ---\n        for n in range(Nt):\n            t_current = (n + 1.0) * dt\n            T = T0 + G * (x - Vp * t_current)\n            \n            phi_L = 1.0 - phi_a - phi_b\n            phi_L = np.clip(phi_L, 0.0, 1.0)\n\n            # --- RHS for phi_a and phi_b ---\n            lap_phi_a = np.zeros(Nx)\n            lap_phi_a[1:-1] = (phi_a[2:] - 2.0*phi_a[1:-1] + phi_a[:-2]) / dx**2\n            lap_phi_a[0] = 2.0 * (phi_a[1] - phi_a[0]) / dx**2\n            lap_phi_a[-1] = 2.0 * (phi_a[-2] - phi_a[-1]) / dx**2\n\n            lap_phi_b = np.zeros(Nx)\n            lap_phi_b[1:-1] = (phi_b[2:] - 2.0*phi_b[1:-1] + phi_b[:-2]) / dx**2\n            lap_phi_b[0] = 2.0 * (phi_b[1] - phi_b[0]) / dx**2\n            lap_phi_b[-1] = 2.0 * (phi_b[-2] - phi_b[-1]) / dx**2\n\n            f_alpha = (T_alpha_0 + m_alpha * c) - T\n            f_beta = (T_beta_0 + m_beta * c) - T\n            \n            h_prime_a = 6.0 * phi_a * (1.0 - phi_a)\n            h_prime_b = 6.0 * phi_b * (1.0 - phi_b)\n\n            d_psi_d_phi_a = 2.0*W*phi_a*(1.0-phi_a)*(1.0-2.0*phi_a) + eta*(1.0 - 2.0*phi_a - phi_b) - lambda_alpha * f_alpha * h_prime_a\n            d_psi_d_phi_b = 2.0*W*phi_b*(1.0-phi_b)*(1.0-2.0*phi_b) + eta*(1.0 - 2.0*phi_b - phi_a) - lambda_beta * f_beta * h_prime_b\n\n            phi_a_rhs = -L_mob * (d_psi_d_phi_a - epsilon**2 * lap_phi_a)\n            phi_b_rhs = -L_mob * (d_psi_d_phi_b - epsilon**2 * lap_phi_b)\n\n            # --- RHS for c ---\n            S = B_alpha * phi_a_rhs + B_beta * phi_b_rhs\n\n            D = DL * phi_L + Ds * (1.0 - phi_L)\n            D_plus_half = (D[1:] + D[:-1]) / 2.0\n            flux = D_plus_half * (c[1:] - c[:-1]) / dx\n            \n            diff_c_term = np.zeros(Nx)\n            diff_c_term[1:-1] = (flux[1:] - flux[:-1]) / dx\n            diff_c_term[0] = flux[0] / dx\n            diff_c_term[-1] = -flux[-1] / dx\n\n            adv_c_term = np.zeros(Nx)\n            if Vp > 0:\n                adv_c_term[1:] = -Vp * (c[1:] - c[:-1]) / dx\n                # adv_c_term[0] = 0 as per Neumann BC interpretation\n\n            c_rhs = diff_c_term + adv_c_term + S\n\n            # --- Explicit Euler update ---\n            phi_a_new = phi_a + dt * phi_a_rhs\n            phi_b_new = phi_b + dt * phi_b_rhs\n            c = c + dt * c_rhs\n\n            # --- Projection step for phi ---\n            phi_a = np.clip(phi_a_new, 0.0, 1.0)\n            phi_b = np.clip(phi_b_new, 0.0, 1.0)\n            \n            sum_ab = phi_a + phi_b\n            mask = sum_ab > 1.0\n            sum_ab_masked = sum_ab[mask]\n            \n            # Guard against division by zero although mask > 1 prevents it.\n            # Adding a small epsilon would be more robust but is not needed here.\n            phi_a[mask] /= sum_ab_masked\n            phi_b[mask] /= sum_ab_masked\n\n            # --- Update diagnostics ---\n            max_delta_c = max(max_delta_c, np.max(c) - c0)\n            num_clusters = count_clusters(phi_b, 0.6)\n            num_beta_clusters_history.append(num_clusters)\n\n        # --- Final diagnostics calculation ---\n        # 1. Front leader indicator I_lead\n        alpha_indices = np.where(phi_a >= 0.5)[0]\n        x_alpha_front = x[alpha_indices.max()] if alpha_indices.size > 0 else -np.inf\n        beta_indices = np.where(phi_b >= 0.5)[0]\n        x_beta_front = x[beta_indices.max()] if beta_indices.size > 0 else -np.inf\n        I_lead = 1 if x_beta_front > x_alpha_front else 0\n\n        # 2. Maximum solute pile-up Delta_c_max\n        delta_c_max_rounded = round(max_delta_c, 3)\n        \n        # 3. Transient peritectic island indicator I_isl\n        I_isl = 0\n        if num_beta_clusters_history:\n            max_overall_clusters = np.max(num_beta_clusters_history)\n            if len(num_beta_clusters_history) > 1:\n                final_clusters = num_beta_clusters_history[-1]\n                max_interim_clusters = np.max(num_beta_clusters_history[:-1])\n                if max_interim_clusters > final_clusters and max_overall_clusters >= 2:\n                    I_isl = 1\n        \n        return I_lead, delta_c_max_rounded, I_isl\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (V_p, D_L, lambda_beta, A_beta, x_beta)\n        (0.4, 5.0e-4, 0.8, 0.0, None),\n        (0.8, 7.5e-4, 1.2, 0.0, None),\n        (1.0, 5.0e-4, 1.1, 0.20, 0.35),\n    ]\n\n    results = []\n    for case in test_cases:\n        res = run_simulation(case)\n        results.extend(res)\n\n    # Format each float to three decimal places before joining.\n    formatted_results = [f\"{r:.3f}\" if isinstance(r, float) else str(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3476675"}]}