{"hands_on_practices": [{"introduction": "在计算材料科学中，利用系统的对称性是简化复杂问题并降低计算成本的基石。如果一个哈密顿量 $H$ 与一个对称操作群 $G$ 的所有元素对易，那么通过变换到对称适应基矢，可以将 $H$ 块对角化。本练习将指导您完成这一过程，从第一性原理出发构建投影算符和对称适应基矢，并量化由此带来的计算效率提升[@problem_id:3446824]。", "problem": "给定一个有限点群、一个在该群下变换的函数基，以及在该群作用下不变的哈密顿矩阵。你的任务是构造对称匹配基函数，以将每个哈密顿矩阵块对角化，并量化对角化过程中的计算节省。背景是纯数学的：哈密顿矩阵是一个作用在有限维向量空间上的实对称矩阵，点群通过置换矩阵作用于基函数。\n\n基本原理：基于以下事实：如果一个矩阵 $H$ 与有限群 $G$ 的所有表示矩阵 $D(g)$ 对易，即对于所有 $g \\in G$，都有 $[H, D(g)] = HD(g) - D(g)H = 0$，那么存在一个基变换，可以同时将 $H$ 块对角化为与 $G$ 的不可约表示相关联的块。构造这种基变换的方法是，通过形成原始基函数的对称匹配线性组合，使其根据不可约表示进行变换，从而产生 $H$ 在其上独立作用的不变子空间。\n\n使用以下有限群和基：\n\n- 基函数 $\\{\\phi_0, \\phi_1, \\phi_2, \\phi_3\\}$ 位于坐标为 $(0,+1)$, $(+1,0)$, $(0,-1)$, $(-1,0)$ 的四个位置上，分别按索引 $0,1,2,3$ 排序。\n- 点群为 $C_{2v}$，其操作包括：恒等操作 $E$、绕原点旋转 $\\pi$ 的 $C_2$ 操作、关于 $x$ 轴的镜面反射 $\\sigma_x$ 以及关于 $y$ 轴的镜面反射 $\\sigma_y$。每个操作通过置换索引来作用：\n  - $E$: $0 \\mapsto 0$, $1 \\mapsto 1$, $2 \\mapsto 2$, $3 \\mapsto 3$。\n  - $C_2$: $0 \\mapsto 2$, $1 \\mapsto 3$, $2 \\mapsto 0$, $3 \\mapsto 1$。\n  - $\\sigma_x$: $0 \\mapsto 2$, $1 \\mapsto 1$, $2 \\mapsto 0$, $3 \\mapsto 3$。\n  - $\\sigma_y$: $0 \\mapsto 0$, $1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 1$。\n  这些操作定义了作用于一般基函数组合系数的列向量的 $4 \\times 4$ 置换矩阵 $D(g)$。\n\n构造一个程序，在给定群作用矩阵 $D(g)$ 和满足对所有 $g \\in G$ 都有 $[H, D(g)] = 0$ 的哈密顿矩阵 $H$ 的情况下，执行以下操作：\n- 通过将原始基投影到在 $G$ 下不可约变换的子空间上，构造对称匹配基函数。\n- 将这些基函数组合成一个标准正交的基变换矩阵，该矩阵能将 $H$ 块对角化。\n- 对每个块进行对角化，并拼接其特征值。\n- 将拼接后的块特征值与完整哈密顿矩阵的特征值进行比较。\n- 通过比率 $r = \\left(\\sum_{i} n_i^3\\right) / N^3$ 来量化块对角化的计算节省，其中 $N$ 是完整维度，$n_i$ 是块的大小。\n\n你的程序必须为以下哈密顿矩阵测试套件实现并测试上述过程，所有这些矩阵都是大小为 $N = 4$ 的实对称矩阵：\n\n1. 理想情况（完全 $C_{2v}$ 不变性）：\n   $$H_1 = \\begin{bmatrix}\n   0  1  0  1 \\\\\n   1  0  1  0 \\\\\n   0  1  0  1 \\\\\n   1  0  1  0\n   \\end{bmatrix}.$$\n   这对应于正方形四条边上相等的最近邻耦合 $t = 1$ 和零在位能，并且它与所有 $g \\in C_{2v}$ 的 $D(g)$ 对易。\n\n2. 保持 $C_{2v}$ 不变性的不同相互作用类型：\n   $$H_2 = \\begin{bmatrix}\n   0  1  0.5  1 \\\\\n   1  0  1  0.5 \\\\\n   0.5  1  0  1 \\\\\n   1  0.5  1  0\n   \\end{bmatrix}.$$\n   这在相对位置 $\\{0,2\\}$ 和 $\\{1,3\\}$ 之间增加了对角耦合 $t_d = 0.5$，同时保持群不变性。\n\n3. 保持 $C_{2v}$ 不变性的各向异性在位能：\n   $$H_3 = \\begin{bmatrix}\n   2  1  0  1 \\\\\n   1  0  1  0 \\\\\n   0  1  2  1 \\\\\n   1  0  1  0\n   \\end{bmatrix}.$$\n   这在索引 $0$ 和 $2$ 处具有在位能 $a = 2$，在索引 $1$ 和 $3$ 处具有在位能 $b = 0$，同时最近邻耦合相等，为 $t = 1$。\n\n4. 边界情况：平凡群（无对称性约化）：与情况1中相同的 $H_1$，但群仅包含恒等操作 $E$。\n\n对于每个测试用例，你的程序应：\n- 为所选群构造对称匹配基函数。\n- 将哈密顿矩阵块对角化，并对每个块进行对角化。\n- 计算立方运算计数的比率 $r$ 和来自块对角化的排序特征值与来自完全对角化的排序特征值之间的最大绝对差 $d$：\n  $$r = \\frac{\\sum_i n_i^3}{N^3}, \\quad d = \\max_j \\left| \\lambda^{(\\mathrm{full})}_j - \\lambda^{(\\mathrm{block})}_j \\right|.$$\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。按顺序报告每个测试用例的对 $(r, d)$，并展平为一个列表。例如，四个测试用例的输出形式应为\n$[r_1, d_1, r_2, d_2, r_3, d_3, r_4, d_4]$,\n其中每个 $r_i$ 和 $d_i$ 都表示为浮点数。不涉及物理单位，也不使用角度。所有值必须由你的程序进行数值计算。", "solution": "用户的请求是验证并解决一个问题，该问题围绕在计算材料科学背景下应用群论来块对角化哈密顿矩阵。\n\n### 步骤 1：问题验证\n\n已根据指定标准对问题陈述进行了仔细分析。\n\n- **提取已知条件**：\n  - 基函数：$\\{\\phi_0, \\phi_1, \\phi_2, \\phi_3\\}$，位于特定的笛卡尔坐标，映射到索引 $0, 1, 2, 3$。\n  - 点群：$C_{2v} = \\{E, C_2, \\sigma_x, \\sigma_y\\}$。\n  - 群作用：定义为基索引的置换，由此推导出 $4 \\times 4$ 的表示矩阵 $D(g)$。\n  - 不变性条件：哈密顿矩阵 $H$ 被说明满足对所有群操作 $g$ 都有 $[H, D(g)] = 0$。\n  - 任务：通过投影构造对称匹配基函数（SAFs），形成基变换矩阵 $U$ 以将 $H$ 块对角化，对角化各个块，并量化计算节省（$r$）和准确性（$d$）。\n  - 计算节省度量：$r = (\\sum_i n_i^3) / N^3$，其中 $n_i$ 是块的大小，$N$ 是完整矩阵的维度。\n  - 准确性度量：$d = \\max_j | \\lambda^{(\\mathrm{full})}_j - \\lambda^{(\\mathrm{block})}_j |$。\n  - 测试用例：四个指定的哈密顿矩阵和对称群对。\n    1. 具有 $C_{2v}$ 对称性的 $H_1$。\n    2. 具有 $C_{2v}$ 对称性的 $H_2$。\n    3. 具有 $C_{2v}$ 对称性的 $H_3$。\n    4. 具有平凡群 $\\{E\\}$ 的 $H_1$。\n\n- **使用提取的已知条件进行验证**：\n  1.  **科学依据**：该问题是有限群表示论在简化量子力学和凝聚态物理中特征值问题方面的经典应用。Schur's lemma和Great Orthogonality Theorem为块对角化与对称群对易的算符提供了理论基础。$C_{2v}$ 群、所选的基位置以及哈密顿矩阵的结构都是标准模型。经检查确认，所提供的哈密顿矩阵 $H_1, H_2, H_3$ 确实如所述与 $C_{2v}$ 的表示矩阵对易。该问题在科学上和数学上都是合理的。\n  2.  **适定性**：该问题是适定的。表示空间分解为不可约子空间是唯一的，这导致唯一的块大小集合 $\\{n_i\\}$ 和唯一的特征值。寻找对称匹配基的过程是确定性的。所需的输出 $r$ 和 $d$ 是唯一定量的。\n  3.  **客观性**：问题的所有组成部分都以数学精度定义。没有歧义、主观性或依赖于观点。\n  4.  **完整性**：问题是自洽的，并提供了求解所需的所有数据和定义。\n  5.  **可行性**：计算涉及对小型（$4 \\times 4$）矩阵的标准线性代数运算，计算上是微不足道的。\n\n- **结论**：\n  该问题是 **有效的**。它是一个定义明确、有科学依据的计算物理学问题，可以通过算法解决。\n\n### 步骤 2：求解推导\n\n求解需要实现用于块对角化的群论机制。\n\n**1. 群表示和特征标理论**\n点群是 $C_{2v}$，一个阶为 $|G|=4$ 的阿贝尔群。其操作和特征标表是基础。群操作以基索引 $\\{0, 1, 2, 3\\}$ 上的置换形式给出。这些置换定义了 $4 \\times 4$ 的表示矩阵 $D(g)$。\n\n- $E: (0)(1)(2)(3) \\implies D(E) = I_4$.\n- $C_2: (0 \\leftrightarrow 2, 1 \\leftrightarrow 3) \\implies D(C_2)_{ij} = \\delta_{i,C_2(j)}$.\n- $\\sigma_x: (0 \\leftrightarrow 2) \\implies D(\\sigma_x)_{ij} = \\delta_{i,\\sigma_x(j)}$.\n- $\\sigma_y: (1 \\leftrightarrow 3) \\implies D(\\sigma_y)_{ij} = \\delta_{i,\\sigma_y(j)}$.\n\n$C_{2v}$ 的特征标表包含其四个一维不可约表示（irreps）：$A_1, A_2, B_1, B_2$。\n| Irrep | $\\chi(E)$ | $\\chi(C_2)$ | $\\chi(\\sigma_x)$ | $\\chi(\\sigma_y)$ |\n|:---:|:---:|:---:|:---:|:---:|\n| $A_1$ | $1$ | $1$ | $1$ | $1$ |\n| $A_2$ | $1$ | $1$ | $-1$ | $-1$ |\n| $B_1$ | $1$ | $-1$ | $1$ | $-1$ |\n| $B_2$ | $1$ | $-1$ | $-1$ | $1$ |\n\n**2. 可约表示的分解**\n由基 $\\{\\phi_0, \\phi_1, \\phi_2, \\phi_3\\}$ 提供的表示 $\\Gamma$ 是可约的。其特征标为 $\\chi(g) = \\mathrm{Tr}(D(g))$，它计算在操作 $g$ 下保持不变的基函数数量。\n- $\\chi(E) = \\mathrm{Tr}(I_4) = 4$。\n- $\\chi(C_2) = 0$（无不动点）。\n- $\\chi(\\sigma_x) = 2$（索引 $1, 3$ 固定）。\n- $\\chi(\\sigma_y) = 2$（索引 $0, 2$ 固定）。\n\n不可约表示 $\\alpha$ 在 $\\Gamma$ 中出现的次数由约化公式给出：$a_\\alpha = \\frac{1}{|G|} \\sum_{g \\in G} \\chi^{(\\alpha)*}(g) \\chi(g)$。\n- $a_{A_1} = \\frac{1}{4}[1(4) + 1(0) + 1(2) + 1(2)] = 2$。\n- $a_{A_2} = \\frac{1}{4}[1(4) + 1(0) - 1(2) - 1(2)] = 0$。\n- $a_{B_1} = \\frac{1}{4}[1(4) - 1(0) + 1(2) - 1(2)] = 1$。\n- $a_{B_2} = \\frac{1}{4}[1(4) - 1(0) - 1(2) + 1(2)] = 1$。\n\n因此，可约表示分解为 $\\Gamma = 2A_1 \\oplus B_1 \\oplus B_2$。这意味着任何具有 $C_{2v}$ 对称性的哈密顿矩阵都将被块对角化为一个 $2 \\times 2$ 的块（对应于 $A_1$ 子空间）和两个 $1 \\times 1$ 的块（分别对应于 $B_1$ 和 $B_2$）。因此，块的大小为 $n_1=2, n_2=1, n_3=1$。\n\n**3. 对称匹配基函数（SAFs）的构造**\nSAFs 是使用投影算符构造的，$P^{(\\alpha)} = \\frac{l_\\alpha}{|G|} \\sum_{g \\in G} \\chi^{(\\alpha)*}(g) D(g)$。由于这里所有的不可约表示都是一维的（$l_\\alpha=1$），我们将原始基向量（标准基向量 $e_0, ..., e_3$）投影到每个不可约子空间上。\n- **$A_1$ 子空间**：投影 $e_0$ 和 $e_1$ 产生两个线性无关的向量：$e_0+e_2$ 和 $e_1+e_3$。将它们标准正交化得到前两个 SAFs：$\\psi_1 = \\frac{1}{\\sqrt{2}}(e_0+e_2)$ 和 $\\psi_2 = \\frac{1}{\\sqrt{2}}(e_1+e_3)$。\n- **$B_1$ 子空间**：投影基向量产生一个独立的向量，与 $e_1-e_3$ 成正比。归一化的 SAF 是 $\\psi_3 = \\frac{1}{\\sqrt{2}}(e_1-e_3)$。\n- **$B_2$ 子空间**：投影产生一个独立的向量，与 $e_0-e_2$ 成正比。归一化的 SAF 是 $\\psi_4 = \\frac{1}{\\sqrt{2}}(e_0-e_2)$。\n\n**4. 基变换与块对角化**\nSAFs $\\{\\psi_1, \\psi_2, \\psi_3, \\psi_4\\}$ 构成了酉变换矩阵 $U$ 的列。\n$$ U = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1  0  0  1 \\\\ 0  1  1  0 \\\\ 1  0  0  -1 \\\\ 0  1  -1  0 \\end{pmatrix} $$\n然后通过 $H' = U^T H U$ 计算块对角化后的哈密顿矩阵。根据分解从 $H'$ 中提取块：一个用于 $A_1$ 的 $2 \\times 2$ 块，一个用于 $B_1$ 的 $1 \\times 1$ 块，以及一个用于 $B_2$ 的 $1 \\times 1$ 块。\n\n**5. 算法实现**\n- 对于涉及 $C_{2v}$ 群的每个测试用例：\n  1. 如上所述构造矩阵 $U$。\n  2. 计算块对角矩阵 $H' = U^T H U$。\n  3. 提取块（$2 \\times 2, 1 \\times 1, 1 \\times 1$）。\n  4. 对每个块进行对角化。对于一个 $1 \\times 1$ 的块 $[b]$，特征值为 $b$。使用标准的数值程序对 $2 \\times 2$ 的块进行对角化。\n  5. 收集并排序得到的特征值。\n  6. 直接对角化完整的哈密顿矩阵 $H$ 以进行比较。\n  7. 计算度量 $r = (2^3+1^3+1^3)/4^3 = 10/64 = 0.15625$ 和 $d$（排序后特征值的最大绝对差）。\n- 对于使用平凡群 $\\{E\\}$ 的测试用例：\n  1. 该群只有一个不可约表示，对应于整个 $4$ 维空间。无法进行约化。\n  2. “块”是完整的 $4 \\times 4$ 矩阵。块的大小为 $n_1=4$。\n  3. 计算节省比为 $r = 4^3/4^3 = 1$。\n  4. 从完整矩阵计算特征值。差值 $d$ 必然为零。\n程序将为提供的测试用例自动执行这整个过程，并按规定格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the symmetry-based block diagonalization problem for a series of Hamiltonians.\n    \"\"\"\n\n    # Define the permutation matrices for the C2v group generators.\n    # D(g) acts on a coefficient vector c as c' = D(g) c.\n    # This corresponds to transforming the basis as g(phi_i) = phi_{g(i)}.\n    # The matrix D(g) has D_ij = 1 if i=g(j), 0 otherwise.\n    \n    # E: (0)(1)(2)(3)\n    D_E = np.identity(4)\n    # C2: 0-2, 1-3, 2-0, 3-1\n    D_C2 = np.array([[0,0,1,0],[0,0,0,1],[1,0,0,0],[0,1,0,0]])\n    # sigma_x (reflection across xz-plane): 0-2, 1-1, 2-0, 3-3\n    D_sigmax = np.array([[0,0,1,0],[0,1,0,0],[1,0,0,0],[0,0,0,1]])\n    # sigma_y (reflection across yz-plane): 0-0, 1-3, 2-2, 3-1\n    D_sigmay = np.array([[1,0,0,0],[0,0,0,1],[0,0,1,0],[0,1,0,0]])\n\n    C2v_group_reps = {'E': D_E, 'C2': D_C2, 'sigmax': D_sigmax, 'sigmay': D_sigmay}\n    \n    # Character table for C2v group\n    # Rows are irreps, columns correspond to E, C2, sigmax, sigmay\n    char_table_C2v = {\n        'A1': {'E': 1, 'C2': 1, 'sigmax': 1, 'sigmay': 1},\n        'A2': {'E': 1, 'C2': 1, 'sigmax':-1, 'sigmay':-1},\n        'B1': {'E': 1, 'C2':-1, 'sigmax': 1, 'sigmay':-1},\n        'B2': {'E': 1, 'C2':-1, 'sigmax':-1, 'sigmay': 1},\n    }\n    \n    # Define test case Hamiltonians\n    H1 = np.array([\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ], dtype=float)\n\n    H2 = np.array([\n        [0,   1, 0.5, 1],\n        [1,   0, 1,   0.5],\n        [0.5, 1, 0,   1],\n        [1, 0.5, 1,   0]\n    ], dtype=float)\n\n    H3 = np.array([\n        [2, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 2, 1],\n        [1, 0, 1, 0]\n    ], dtype=float)\n\n    test_cases = [\n        (H1, 'C2v'),\n        (H2, 'C2v'),\n        (H3, 'C2v'),\n        (H1, 'trivial')\n    ]\n\n    results = []\n    \n    def get_saf_basis(group_name, group_reps, char_table):\n        \"\"\"\n        Constructs the symmetry-adapted basis (SAF) transformation matrix U and block sizes.\n        \"\"\"\n        if group_name == 'trivial':\n            return np.identity(4), [4]\n\n        U_cols = []\n        block_sizes = []\n        \n        N = 4  # Dimension of the basis\n        group_order = len(group_reps)\n        basis_vectors = [np.eye(N)[i] for i in range(N)]\n        \n        # Order of irreps for deterministic U matrix construction\n        irrep_names = ['A1', 'A2', 'B1', 'B2']\n\n        for irrep_name in irrep_names:\n            irrep_chars = char_table[irrep_name]\n            # Projection operator for this irrep\n            # P_alpha = (l_alpha / |G|) * sum_g chi_alpha(g)* D(g)\n            # l_alpha = 1 for all C2v irreps\n            P_alpha = np.zeros((N, N))\n            for g_name, D_g in group_reps.items():\n                P_alpha += irrep_chars[g_name] * D_g\n            P_alpha *= (1.0 / group_order)\n\n            # Project original basis vectors to find vectors spanning the irrep subspace\n            projected_vectors = []\n            for v in basis_vectors:\n                pv = P_alpha @ v\n                # Check if the projected vector is non-zero\n                if not np.allclose(pv, 0):\n                    projected_vectors.append(pv)\n            \n            if not projected_vectors:\n                continue\n\n            # Orthonormalize the collected vectors for this irrep's subspace\n            # Using QR decomposition on matrix of column vectors\n            # This is robust against linear dependencies\n            Q, R = np.linalg.qr(np.array(projected_vectors).T)\n            \n            # The columns of Q form an orthonormal basis for the subspace.\n            # The rank of R tells us the dimension of the subspace.\n            rank = np.sum(np.abs(np.diag(R))  1e-9)\n            if rank  0:\n                U_cols.extend([Q[:, i] for i in range(rank)])\n                block_sizes.append(rank)\n\n        return np.array(U_cols).T, block_sizes\n\n    for H, group_name in test_cases:\n        N = H.shape[0]\n\n        # 1. Construct symmetry-adapted basis functions (SAFs)\n        if group_name == 'C2v':\n            U, block_sizes = get_saf_basis(group_name, C2v_group_reps, char_table_C2v)\n        else: # Trivial group\n             U, block_sizes = get_saf_basis(group_name, None, None)\n\n        # 2. Block-diagonalize the Hamiltonian\n        H_prime = U.T @ H @ U\n        \n        # 3. Diagonalize each block and concatenate eigenvalues\n        block_eigenvalues = []\n        current_idx = 0\n        for size in block_sizes:\n            block = H_prime[current_idx:current_idx+size, current_idx:current_idx+size]\n            if size  0:\n                # Use eigh for symmetric matrices\n                eigvals = np.linalg.eigh(block)[0]\n                block_eigenvalues.extend(eigvals)\n            current_idx += size\n\n        block_eigenvalues.sort()\n\n        # 4. Compare with eigenvalues of the full Hamiltonian\n        full_eigenvalues = np.linalg.eigh(H)[0]\n        full_eigenvalues.sort()\n        \n        # 5. Quantify computational savings (r) and accuracy (d)\n        r = sum([n**3 for n in block_sizes]) / (N**3)\n        d = np.max(np.abs(np.array(full_eigenvalues) - np.array(block_eigenvalues)))\n\n        results.extend([r, d])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n```", "id": "3446824"}, {"introduction": "求解本征值问题后，关键的下一步是解读本征值和本征向量所蕴含的物理意义。本练习以著名的Aubry-André模型为例，展示如何通过分析本征态的性质来理解深刻的物理现象——准周期系统中的局域化转变。您将学习计算参与率和能级间距比等关键指标，以量化波函数的空间扩展性，并将这些量与理论预测的扩展-局域相变联系起来[@problem_id:3446844]。", "problem": "考虑一维紧束缚哈密顿量，其具有准周期性的在位调制，该模型被称为 Aubry–André（也称作 almost Mathieu）模型。在计算材料科学中，该模型是研究准周期晶格中局域化转变的标准设定，通常使用矩阵对角化和特征值分析等方法。该模型定义在长度为 $N$ 的链上，具有开放边界条件、最近邻之间的跃迁振幅 $t$，以及强度为 $\\lambda$ 的在位调制，其非公度频率由一个有理数近似。在格点基 $\\{|i\\rangle\\}_{i=0}^{N-1}$ 下，哈密顿量矩阵 $\\mathbf{H} \\in \\mathbb{R}^{N \\times N}$ 由以下公式指定：\n$$\nH_{i,j} = t \\, (\\delta_{i,j+1} + \\delta_{i,j-1}) + \\lambda \\cos\\!\\big(2\\pi \\alpha \\, i + \\phi \\big) \\, \\delta_{i,j},\n$$\n其中 $i \\in \\{0,1,\\dots,N-1\\}$，$t \\in \\mathbb{R}$，$\\lambda \\in \\mathbb{R}$，$\\alpha \\in \\mathbb{R}$ 是一个无理数，由有理数 $p/q$ 近似，$\\phi \\in \\mathbb{R}$ 是一个相位。开放边界条件通过 $H_{-1,0}=H_{N,N-1}=0$ 来施加，这在实践中意味着只有链内部的最近邻非对角元素不为零。计算的基础是矩阵特征值问题：\n$$\n\\mathbf{H} \\, \\psi_n = E_n \\, \\psi_n,\n$$\n其中 $E_n \\in \\mathbb{R}$ 是特征值，$\\psi_n \\in \\mathbb{R}^N$ 是对应的归一化特征向量，满足 $\\sum_{i=0}^{N-1} |\\psi_n(i)|^2 = 1$。为了量化本征态的空间延展性与局域性，使用为归一化特征向量定义的参与率：\n$$\nP_n = \\frac{\\Big(\\sum_{i=0}^{N-1} |\\psi_n(i)|^2 \\Big)^2}{\\sum_{i=0}^{N-1} |\\psi_n(i)|^4} = \\frac{1}{\\sum_{i=0}^{N-1} |\\psi_n(i)|^4},\n$$\n以及归一化参与率 $p_n = P_n/N \\in (0,1]$。为了在不进行谱展开（unfolding）的情况下量化特征值统计特性，使用为有序能谱 $E_0 \\le E_1 \\le \\dots \\le E_{N-1}$ 定义的相邻能级间距之比。将间距记为 $\\delta_k = E_{k+1} - E_k$（$k \\in \\{0,1,\\dots,N-2\\}$），为 $k \\in \\{0,1,\\dots,N-3\\}$ 定义比值：\n$$\nr_k = \\frac{\\min(\\delta_k,\\delta_{k+1})}{\\max(\\delta_k,\\delta_{k+1})},\n$$\n及其平均值 $r = \\frac{1}{N-2} \\sum_{k=0}^{N-3} r_k$，计算时需排除任何分母为零的未定义情况。\n\n你的任务是实现一个程序，对下面的每个测试用例，构建 $\\mathbf{H}$，对其进行数值对角化以获得 $\\{E_n,\\psi_n\\}$，计算平均归一化参与率：\n$$\n\\overline{p} = \\frac{1}{N} \\sum_{n=0}^{N-1} \\frac{1}{N \\sum_{i=0}^{N-1} |\\psi_n(i)|^4},\n$$\n以及如上定义的相邻能级间距比的均值 $r$。在所有情况下均使用 $t=1$。角度是无量纲的，以弧度为单位。本问题中没有物理单位；所有量都是无量纲的。\n\n测试套件参数以元组 $(N,\\alpha,\\lambda,\\phi)$ 的形式指定，固定 $t=1$：\n\n- 用例 A（延展区候选）：$(N,\\alpha,\\lambda,\\phi) = (144,\\, 89/144,\\, 1.5,\\, 0.0)$。\n- 用例 B（临界区候选）：$(N,\\alpha,\\lambda,\\phi) = (144,\\, 89/144,\\, 2.0,\\, 0.0)$。\n- 用例 C（局域区候选）：$(N,\\alpha,\\lambda,\\phi) = (144,\\, 89/144,\\, 3.0,\\, 0.0)$。\n- 用例 D（无调制基线）：$(N,\\alpha,\\lambda,\\phi) = (144,\\, 89/144,\\, 0.0,\\, 0.0)$。\n- 用例 E（不同近似值和相位，局域化）：$(N,\\alpha,\\lambda,\\phi) = (89,\\, 55/89,\\, 3.0,\\, 0.3)$。\n\n你的程序必须输出一行，其中包含一个结果列表，每个测试用例一个结果，并按所列顺序排列。每个结果必须是列表 $[\\lambda, \\overline{p}, r]$，其中所有三个条目都以小数形式给出，并四舍五入到小数点后六位。整个输出必须是如下形式的单行：\n$\\big[\\,[\\lambda_1,\\overline{p}_1,r_1],\\,[\\lambda_2,\\overline{p}_2,r_2],\\,\\dots\\,\\big]$。\n不应打印任何额外文本。", "solution": "我们从实对称哈密顿量 $\\mathbf{H} \\in \\mathbb{R}^{N \\times N}$ 的矩阵特征值问题开始，该哈密顿量保证了存在一组完备的正交归一特征向量和实数特征值。具有开放边界条件的一维链上的 Aubry–André 哈密顿量由最近邻之间的跃迁振幅 $t$ 和在位调制 $\\lambda \\cos(2\\pi \\alpha i + \\phi)$ 定义，其频率 $\\alpha$ 在无限大尺寸极限下是无理数，在有限系统中则用有理数近似。指标 $i$ 的取值范围为 $0$ 到 $N-1$，$\\delta_{i,j}$ 表示克罗内克（Kronecker）$\\delta$ 函数。\n\n计算工作流程如下：\n\n1. 矩阵构建。对于每个测试用例 $(N,\\alpha,\\lambda,\\phi)$（固定 $t=1$），通过设置以下元素来构建 $\\mathbf{H}$：\n   - 对于 $i \\in \\{0,1,\\dots,N-1\\}$，对角元素为\n     $$\n     H_{i,i} = \\lambda \\cos(2\\pi \\alpha i + \\phi).\n     $$\n   - 对于 $i \\in \\{0,1,\\dots,N-2\\}$，非对角的最近邻元素为\n     $$\n     H_{i,i+1} = H_{i+1,i} = t = 1.\n     $$\n   所有其他元素均为零，这施加了开放边界条件。\n\n2. 对角化。求解\n   $$\n   \\mathbf{H}\\,\\psi_n = E_n \\,\\psi_n,\n   $$\n   使用实对称矩阵的求解程序，得到非递减排序的特征值 $\\{E_n\\}_{n=0}^{N-1}$ 和满足\n   $$\n   \\sum_{i=0}^{N-1} |\\psi_n(i)|^2 = 1.\n   $$\n   的正交归一特征向量 $\\{\\psi_n\\}_{n=0}^{N-1}$。正交归一性确保了数值稳定性，并允许直接使用参与率的定义。\n\n3. 参与率。对每个归一化特征向量 $\\psi_n$，使用定义\n   $$\n   P_n = \\frac{\\left(\\sum_{i=0}^{N-1} |\\psi_n(i)|^2\\right)^2}{\\sum_{i=0}^{N-1} |\\psi_n(i)|^4} = \\frac{1}{\\sum_{i=0}^{N-1} |\\psi_n(i)|^4}.\n   $$\n   计算参与率。右边的等式由归一化条件 $\\sum_i |\\psi_n(i)|^2 = 1$ 得出。归一化参与率 $p_n = P_n/N \\in (0,1]$ 衡量了本征态有效占据系统的比例，其中 $p_n \\approx 1$ 表示空间延展态，而 $p_n \\ll 1$ 表示局域在少数格点上的状态。计算平均归一化参与率：\n   $$\n   \\overline{p} = \\frac{1}{N} \\sum_{n=0}^{N-1} \\frac{1}{N \\sum_{i=0}^{N-1} |\\psi_n(i)|^4 }.\n   $$\n\n4. 特征值间距统计。将特征值按升序排序（对称矩阵的对角化程序已经提供了排序好的结果）。计算间距 $\\delta_k = E_{k+1} - E_k$（$k \\in \\{0,1,\\dots,N-2\\}$）。然后计算相邻间距的比值：\n   $$\n   r_k = \\frac{\\min(\\delta_k, \\delta_{k+1})}{\\max(\\delta_k, \\delta_{k+1})}\n   $$\n   对于 $k \\in \\{0,1,\\dots,N-3\\}$，排除任何分母为零的项以避免除以零。平均比值\n   $$\n   r = \\frac{1}{M} \\sum_{k} r_k,\n   $$\n   （其中 $M$ 是有效 $r_k$ 的数量）是能级排斥的无量纲度量：对于类似于不相关能级的强局域谱，$r$ 趋向于泊松（Poisson）统计的特征值；而对于具有能级排斥的延展态，$r$ 通常更大。使用比值避免了谱展开（spectral unfolding）的需要。\n\n5. 测试套件与输出。对每个提供的测试用例，执行步骤 1-4 以获得 $(\\lambda, \\overline{p}, r)$。将结果按指定顺序组合成列表的列表 $[\\,[\\lambda_1,\\overline{p}_1,r_1],\\dots]$，并以单行形式打印。将每个浮点数四舍五入到小数点后六位，以生成简洁、可测试的输出。\n\n算法设计细节和数值考量：\n- 哈密顿量是三对角矩阵，对角线上是余弦函数；测试套件中的维度 $N$ 足够小，使用对称求解器进行密集对角化在计算上是微不足道的。\n- 由于 $\\mathbf{H}$ 是实对称矩阵，$\\psi_n$ 可以取为实数，这将绝对值运算简化为实数项的平方。\n- 求解器提供的特征向量的归一化保证了 $P_n$ 可以稳健地计算为 $1/\\sum_i |\\psi_n(i)|^4$。但为了数值安全，可以计算分子 $(\\sum_i |\\psi_n(i)|^2)^2$ 再除以 $\\sum_i |\\psi_n(i)|^4$。在浮点误差范围内，两者会得到相同的值。\n- 比值 $r_k$ 的范围在 $[0,1]$ 内，提供了一个无需重缩放的良态统计量。\n- 准周期频率 $\\alpha$ 由斐波那契比率 $89/144$ 和 $55/89$ 近似，它们是黄金分割率倒数的标准有理近似值，并为有限链提供了高质量的非公度性。\n\n最终的程序确定性地实现了这一流程，并以所要求的精确单行格式打印结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_hamiltonian(N: int, alpha: float, lam: float, phi: float, t: float = 1.0) - np.ndarray:\n    \"\"\"\n    Construct the Aubry–André Hamiltonian matrix for a 1D chain with open boundary conditions.\n\n    H_{i,i}   = lam * cos(2*pi*alpha*i + phi)\n    H_{i,i+1} = H_{i+1,i} = t\n\n    Parameters\n    ----------\n    N : int\n        System size (number of lattice sites).\n    alpha : float\n        Quasiperiodic frequency (rational approximant of an irrational).\n    lam : float\n        Modulation strength lambda.\n    phi : float\n        Phase offset in radians.\n    t : float\n        Nearest-neighbor hopping amplitude (default 1.0).\n\n    Returns\n    -------\n    H : np.ndarray\n        Real symmetric Hamiltonian matrix of shape (N, N).\n    \"\"\"\n    H = np.zeros((N, N), dtype=np.float64)\n    i = np.arange(N, dtype=np.float64)\n    H[np.arange(N), np.arange(N)] = lam * np.cos(2.0 * np.pi * alpha * i + phi)\n    offdiag_indices = np.arange(N - 1)\n    H[offdiag_indices, offdiag_indices + 1] = t\n    H[offdiag_indices + 1, offdiag_indices] = t\n    return H\n\ndef participation_ratio(evecs: np.ndarray) - float:\n    \"\"\"\n    Compute the mean normalized participation ratio over all eigenvectors.\n\n    Parameters\n    ----------\n    evecs : np.ndarray\n        Eigenvectors as columns, shape (N, N), assumed normalized.\n\n    Returns\n    -------\n    pbar : float\n        Mean of P_n / N over n, where P_n = 1 / sum_i |psi_n(i)|^4.\n    \"\"\"\n    # evecs are real for a real symmetric matrix, but compute generically\n    psi2 = evecs**2  # since real; otherwise use np.abs(evecs)**2\n    denom = np.sum(psi2**2, axis=0)  # sum_i |psi_n(i)|^4 for each n\n    # Avoid division by zero (should not happen for normalized, nonzero vectors)\n    denom = np.where(denom == 0.0, np.finfo(np.float64).tiny, denom)\n    Pn = 1.0 / denom  # since sum_i |psi|^2 = 1 by normalization\n    N = evecs.shape[0]\n    pn_norm = Pn / N\n    return float(np.mean(pn_norm))\n\ndef mean_spacing_ratio(evals: np.ndarray) - float:\n    \"\"\"\n    Compute the mean ratio of consecutive level spacings, r =", "id": "3446844"}, {"introduction": "在材料科学的许多应用中，例如计算电子能带结构，我们需要求解一系列随参数（如晶体动量 $k$）连续变化的哈密顿量的本征值问题。然而，标准的本征求解器按数值大小对本征值排序，这在能带交叉或回避交叉处会导致不符合物理现实的“能带跳跃”。本练习旨在解决这一关键的实际问题，通过实现一个基于最大化本征向量交叠的稳健算法，确保能带标签的物理连续性[@problem_id:3446748]。", "problem": "考虑一族源于晶体固体及其形变模型哈密顿量的有限维厄米特征值问题：对于标量参数 $t \\in \\mathbb{R}$ 的每一個值（例如，布里渊区内的晶体动量分量 $k$，或一个标量应变），给定一个厄米矩阵 $H(t) \\in \\mathbb{C}^{n \\times n}$，需求解由 $H(t)\\,\\mathbf{u}_a(t) = \\lambda_a(t)\\,\\mathbf{u}_a(t)$ 定义的特征对 $\\{(\\lambda_a(t), \\mathbf{u}_a(t))\\}_{a=1}^n$，其中 $\\{\\mathbf{u}_a(t)\\}_{a=1}^n$ 构成 $\\mathbb{C}^n$ 的一个标准正交基。在计算材料科学中，当 $t$ 变化时，能带索引必须保持连续，即使穿越近简并和交叉点。这样，第 $a$ 个被追踪的能带才能代表一个连续的能带函数，而不是一个局部按值排序的标签。\n\n基本原理：\n- 对于一个厄米矩阵 $H(t)$，存在一个酉矩阵 $U(t)$ 使得 $U(t)^\\dagger H(t) U(t) = \\Lambda(t)$，其中 $\\Lambda(t)$ 是对角矩阵，且 $U(t)$ 的列是标准正交的特征向量 $\\mathbf{u}_a(t)$。这些列向量的定义可以相差一个复相位因子，并且简并特征子空间的任何一组标准正交基都是有效的。\n- 当特征值是孤立的（无简并）时，特征向量可以选择为随 $t$ 连续变化（允许相差一个相位因子）。当特征值简并时，只有简并子空间是连续的；该子空间内的任何标准正交基都代表同一个物理子空间。\n\n任务：\n- 基于这些原理，推导一个参数连续的方案，用于在离散参数值 $t_0,\\dots,t_m$ 处，为特征对 $\\{(\\lambda_a(t_i), \\mathbf{u}_a(t_i))\\}_{a=1}^n$ 分配一个一致的排序，使得能带标签 $a$ 以优化连续性的方式从 $t_i$ 传输到 $t_{i+1}$。你的方案必须基于厄米特征问题和标准正交性的第一性原理来构建，而不是依赖于基于特征值大小的特定启发式方法。它必须在 $t_i$ 和 $t_{i+1}$ 的特征向量之间产生一个一一对应的分配，并且该分配在近简并和精确简并情况下是稳定的。\n- 将你的方案实现为一个程序，对下面的每个测试用例计算一个标量连续性分数，定义如下。对于每个连续对 $(t_i,t_{i+1})$，使用你的方案在 $t_i$ 和 $t_{i+1}$ 的 $n$ 个特征向量之间建立一一匹配。对于每个匹配对 $(\\mathbf{u}_a(t_i), \\mathbf{u}_a(t_{i+1}))$，使用标准复欧几里得内积计算其内积的平方 $|\\langle \\mathbf{u}_a(t_i), \\mathbf{u}_a(t_{i+1}) \\rangle|^2$。定义在 $(t_i,t_{i+1})$ 处的单步归一化连续性为\n$$\nC(t_i,t_{i+1}) \\equiv \\frac{1}{n} \\sum_{a=1}^n \\left|\\langle \\mathbf{u}_a(t_i), \\mathbf{u}_a(t_{i+1}) \\rangle\\right|^2.\n$$\n将一个测试的总体连续性分数定义为 $C(t_i,t_{i+1})$ 对所有 $i$ 从 $0$ 到 $m-1$ 的算术平均值：\n$$\n\\overline{C} \\equiv \\frac{1}{m}\\sum_{i=0}^{m-1} C(t_i,t_{i+1}).\n$$\n- 你的实现应该使用针对厄米矩阵的数值稳定方法对每个 $H(t_i)$ 进行对角化，并鲁棒地执行匹配步骤。\n\n测试套件：\n- 测试用例1（精确交叉，双能带）：$n=2$, $H(k) = \\begin{pmatrix} k  0 \\\\ 0  -k \\end{pmatrix}$，其中 $k \\in \\{-1.0,-0.5,0.0,0.5,1.0\\}$。\n- 测试用例2（避免交叉，双能带）：$n=2$, $H(k) = \\begin{pmatrix} k  \\delta \\\\ \\delta  -k \\end{pmatrix}$，其中 $\\delta = 0.05$，$k \\in \\{-1.0,-0.5,0.0,0.5,1.0\\}$。\n- 测试用例3（三能带，其非平凡耦合让人联想到一个简单的紧束缚模型）：$n=3$, $H(k) = \\begin{pmatrix} 2\\cos k  1  0 \\\\ 1  -\\cos k  1 \\\\ 0  1  0.5 \\cos k \\end{pmatrix}$，其中 $k \\in \\{-\\pi, -\\tfrac{3\\pi}{4}, -\\tfrac{\\pi}{2}, -\\tfrac{\\pi}{4}, 0, \\tfrac{\\pi}{4}, \\tfrac{\\pi}{2}, \\tfrac{3\\pi}{4}, \\pi\\}$。\n- 测试用例4（旋转子空间中的精确简并）：$n=3$, $H(k) = R(\\theta(k)) \\,\\mathrm{diag}(0,0,\\sin k)\\, R(\\theta(k))^\\top$，其中 $R(\\theta) = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta  0 \\\\ \\sin\\theta  \\cos\\theta  0 \\\\ 0  0  1 \\end{pmatrix}$ 且 $\\theta(k) = 0.2\\,k$，$k \\in \\{-0.8,-0.4,0.0,0.4,0.8\\}$。请注意，对于所有 $k$，前两个特征值都是精确简并的，而相应的特征向量随着 $k$ 的变化在简并子空间内旋转。\n\n凡是使用三角函数的地方，角度单位均为弧度。矩阵或结果不涉及任何物理单位。\n\n输出规范：\n- 对于4个测试用例中的每一个，计算如上定义的标量 $\\overline{C}$。\n- 你的程序应生成单行输出，其中包含四个结果，形式为方括号括起来的逗号分隔列表，每个值四舍五入到六位小数。例如，输出可能看起来像 $[0.999999,0.987654,0.954321,1.000000]$。", "solution": "所提出的问题要求开发并实现一个严谨的方案，以维持一个参数依赖的厄米哈密頓量 $H(t)$ 的本征态（能带）的连续性。标准的数值对角化程序通常返回按大小排序的特征值，这在发生特征值交叉或避免交叉时，会导致能带索引不连续且物理上不正确。一个鲁棒的方案必须建立在量子力学和线性代数的第一性原理之上，而不是基于特征值排序这一惯例。\n\n指导我们推导的基本原理是：对于参数 $t$ 的一个足够小的变化（从 $t_i$ 到 $t_{i+1}$），物理本征态本身必须是连续演化的。与能带 $a$ 相关联的特征向量 $\\mathbf{u}_a(t_{i+1})$ 必须是与前一步的特征向量 $\\mathbf{u}_a(t_i)$ “最接近”的那一个。在态的希尔伯特空间中，两个归一化态矢量 $\\mathbf{u}$ 和 $\\mathbf{v}$ 之间的“接近度”或对齐度的度量由它们内积的模 $|\\langle \\mathbf{u}, \\mathbf{v} \\rangle|$ 给出。因此，我们方案的核心将是通过最大化这种重叠来匹配连续步骤之间的特征向量。\n\n让我们将该方案形式化。假设在步骤 $t_i$ 处，我们有一组有序的标准正交特征向量 $\\{\\mathbf{u}_a(t_i)\\}_{a=1}^n$。对于初始步骤 $t_0$，这个顺序可以任意选择，例如，通过对相应的特征值进行排序。在下一步 $t_{i+1}$，我们使用标准的数值特征求解器计算 $H(t_{i+1})$ 的特征对。这将产生一组特征值和一组相应的标准正交特征向量，我们将其表示为 $\\{\\mathbf{v}_b(t_{i+1})\\}_{b=1}^n$。这组新向量相对于我们希望保留的連續能带索引是无序的。\n\n为了在参考集 $\\{\\mathbf{u}_a(t_i)\\}$ 和新集合 $\\{\\mathbf{v}_b(t_{i+1})\\}$ 之间建立正确的一一对应关系，我们构建一个 $n \\times n$ 的重叠矩阵 $S$，其元素定义为两个步骤中特征向量之间内积模的平方：\n$$\nS_{ab} = \\left|\\langle \\mathbf{u}_a(t_i), \\mathbf{v}_b(t_{i+1}) \\rangle\\right|^2 = \\left|\\mathbf{u}_a(t_i)^\\dagger \\mathbf{v}_b(t_{i+1})\\right|^2\n$$\n$S_{ab}$ 的值量化了新特征向量 $\\mathbf{v}_b(t_{i+1})$ 在旧特征向量 $\\mathbf{u}_a(t_i)$ 上的投影。我们的目标是找到索引 $\\{1, 2, \\dots, n\\}$ 的一个排列 $\\pi$，使得匹配对的总重叠最大化。数学上，我们寻求找到一个排列 $\\pi \\in S_n$ 来最大化以下总和：\n$$\n\\sum_{a=1}^n S_{a, \\pi(a)}\n$$\n这是组合优化中的一个经典问题，称为分配问题或最大权二分图匹配。它可以使用匈牙利算法或其他线性规划技术高效求解。通过解决这个问题，我们找到一个最优映射，将每个参考特征向量 $\\mathbf{u}_a(t_i)$ 与一个唯一的新特征向量 $\\mathbf{v}_{\\pi(a)}(t_{i+1})$ 关联起来。\n\n这个过程在所有情况下都是鲁棒的，包括简并情况。如果两个或多个特征值简并，数值求解器会为相应的特征空间返回一个任意的标准正交基。分配方案通过寻找新特征空间的基，使其与旧特征空间的基具有最大可能的重叠，从而自然地处理了这种情况，确保了被追踪的子空间作为一个整体的连续性。使用模的平方 $|\\cdot|^2$ 使得该过程与特征向量的任意复相位无关。\n\n一旦确定了最优排列 $\\pi$，步骤 $t_{i+1}$ 的正确排序的特征向量由 $\\mathbf{u}_a(t_{i+1}) = \\mathbf{v}_{\\pi(a)}(t_{i+1})$（其中 $a=1, \\dots, n$）给出。相应的特征值也随之重新排序。这组新的有序集合 $\\{\\mathbf{u}_a(t_{i+1})\\}$ 将作为后续步骤 $t_{i+2}$ 的参考。\n\n接着，问题要求计算一个连续性分数。单步归一化连续性 $C(t_i, t_{i+1})$ 定义为最大化平方重叠的平均值：\n$$\nC(t_i,t_{i+1}) = \\frac{1}{n} \\sum_{a=1}^n \\left|\\langle \\mathbf{u}_a(t_i), \\mathbf{u}_a(t_{i+1}) \\rangle\\right|^2 = \\frac{1}{n} \\sum_{a=1}^n S_{a, \\pi(a)}\n$$\n其中 $\\mathbf{u}_a(t_{i+1})$ 现在指的是正确重排后的特征向量。$C=1$ 的值表示完美的连续性，即 $t_i$ 处的每个特征向量都演化为 $t_{i+1}$ 处的对应向量，而没有投影到其他正交态上。总体连续性分数 $\\overline{C}$ 是在所有区间 $(t_i, t_{i+1})$ 上这些单步分数的算术平均值。\n\n实现将按以下步骤进行：\n1. 对于每个测试用例，生成矩阵序列 $\\{H(t_i)\\}_{i=0}^m$。\n2. 对角化 $H(t_0)$ 以获得初始参考特征向量 $U_0 = [\\mathbf{u}_1(t_0), \\dots, \\mathbf{u}_n(t_0)]$。\n3. 从 $i=0$ 迭代到 $m-1$：\n    a. 令参考特征向量为 $U_{prev} = U_i$。\n    b. 对角化 $H(t_{i+1})$ 以获得原始的新特征向量 $U_{curr,raw}$。\n    c. 计算重叠矩阵 $S_{ab} = |\\left(U_{prev}^\\dagger U_{curr,raw}\\right)_{ab}|^2$。\n    d. 对成本矩阵 $-S$ 求解分配问题，以找到使重叠和最大化的列索引 `col_ind`。\n    e. 计算单步连续性 $C(t_i,t_{i+1}) = \\frac{1}{n} \\sum_a S_{a, \\text{col\\_ind}[a]}$。\n    f. 使用 `col_ind` 重新排序 $U_{curr,raw}$ 的列，以获得新的参考特征向量 $U_{i+1}$。\n4. 计算存储的单步连续性分数的平均值以获得 $\\overline{C}$。\n此过程将应用于四个指定的测试用例中的每一个。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef get_case1_matrices():\n    \"\"\"Generates matrices for Test Case 1.\"\"\"\n    ks = np.array([-1.0, -0.5, 0.0, 0.5, 1.0])\n    matrices = []\n    for k in ks:\n        H = np.array([[k, 0.0], [0.0, -k]], dtype=complex)\n        matrices.append(H)\n    return matrices\n\ndef get_case2_matrices():\n    \"\"\"Generates matrices for Test Case 2.\"\"\"\n    ks = np.array([-1.0, -0.5, 0.0, 0.5, 1.0])\n    delta = 0.05\n    matrices = []\n    for k in ks:\n        H = np.array([[k, delta], [delta, -k]], dtype=complex)\n        matrices.append(H)\n    return matrices\n\ndef get_case3_matrices():\n    \"\"\"Generates matrices for Test Case 3.\"\"\"\n    ks = np.array([-np.pi, -3*np.pi/4, -np.pi/2, -np.pi/4, 0,\n                   np.pi/4, np.pi/2, 3*np.pi/4, np.pi])\n    matrices = []\n    for k in ks:\n        cos_k = np.cos(k)\n        H = np.array([[2 * cos_k, 1.0, 0.0],\n                      [1.0, -cos_k, 1.0],\n                      [0.0, 1.0, 0.5 * cos_k]], dtype=complex)\n        matrices.append(H)\n    return matrices\n\ndef get_case4_matrices():\n    \"\"\"Generates matrices for Test Case 4.\"\"\"\n    ks = np.array([-0.8, -0.4, 0.0, 0.4, 0.8])\n    matrices = []\n    for k in ks:\n        theta = 0.2 * k\n        cos_t, sin_t = np.cos(theta), np.sin(theta)\n        R = np.array([[cos_t, -sin_t, 0.0],\n                      [sin_t,  cos_t, 0.0],\n                      [0.0,    0.0,   1.0]])\n        D = np.diag([0.0, 0.0, np.sin(k)])\n        H = R @ D @ R.T\n        matrices.append(H.astype(complex))\n    return matrices\n\ndef calculate_continuity_score(matrices):\n    \"\"\"\n    Calculates the overall continuity score for a sequence of Hermitian matrices.\n    \"\"\"\n    if not matrices:\n        return 0.0\n\n    n = matrices[0].shape[0]\n    num_steps = len(matrices) - 1\n    if num_steps == 0:\n        return 1.0\n\n    # Initial step: diagonalize H(t_0)\n    # eigh returns eigenvalues in ascending order, and eigenvectors as columns.\n    _, u_prev = np.linalg.eigh(matrices[0])\n\n    step_continuities = []\n\n    for i in range(num_steps):\n        # Current step: diagonalize H(t_{i+1})\n        _, u_curr_raw = np.linalg.eigh(matrices[i+1])\n\n        # Construct the overlap matrix S_{ab} = |", "id": "3446748"}]}