{"hands_on_practices": [{"introduction": "我们的实践始于一个基石性的问题：运用拉格朗日形式主义来理解晶格振动。这个练习将分析力学的核心原理直接应用于凝聚态物理中的一个关键现象。通过这个过程，你将学会如何将一个具体的物理模型——一个一维双原子链——转化为拉格朗日量，并利用欧拉-拉格朗日方程推导出其动力学行为。\n\n      这个实践的价值在于，它不仅能巩固你对拉格朗日力学的理解，还能揭示材料的基本属性，例如声学和光学声子色散关系[@problem_id:3432860]。掌握这个经典的推导过程，是运用分析力学解决更复杂的材料科学问题的关键第一步。", "problem": "考虑一个一维中心对称双原子链，该模型用于模拟计算材料科学中相关的离子晶体中的纵向晶格振动。该链由两种原子周期性交替排列组成，其质量分别为 $m_{1}$ 和 $m_{2}$。最近邻原子通过劲度系数为 $K$ 的相同谐振子弹簧耦合。相邻原子间的平衡间距为 $a/2$，因此长度为 $a$ 的原胞包含两个原子。设 $u_{n}(t)$ 表示第 $n$ 个原胞中质量为 $m_{1}$ 的原子偏离其平衡位置的微小纵向位移，设 $v_{n}(t)$ 表示同一原胞中质量为 $m_{2}$ 的原子的相应位移。\n\n利用小振动的拉格朗日形式，并假设仅存在最近邻谐波相互作用，推导 $u_{n}(t)$ 和 $v_{n}(t)$ 的线性运动方程，并通过求解第一布里渊区 $[-\\pi/a,\\pi/a]$ 中以波数 $k$ 为特征的布洛赫形式的简正模解来获得色散关系。从第一性原理出发，识别声学支和光学支。在你的推理中，从该链的拉格朗日量 $L = T - V$ 的基本定义开始，写出以 $\\{u_{n},v_{n}\\}$ 表示的动能和势能，并应用欧拉-拉格朗日方程得到产生色散关系的本征值问题。通过考察长波极限，简要论证哪个符号对应声学支和光学支，并评论在布里渊区中心 $k=0$ 和边界 $k=\\pi/a$ 处的行为。\n\n请提供两个解析色散关系 $\\omega_{\\mathrm{ac}}(k)$ 和 $\\omega_{\\mathrm{op}}(k)$，以 $k$、$a$、$m_{1}$、$m_{2}$ 和 $K$ 的显式闭合形式表达式给出。将最终结果表示为两个关于 $k$ 的无单位函数。无需进行数值计算。", "solution": "用户希望我解决一个经典的固态物理问题：推导一维双原子晶格的色散关系。\n\n我的计划如下：\n1.  **验证问题：**\n    *   **步骤 1：提取已知条件：** 我将列出所有提供的参数和定义：\n        *   一维中心对称双原子链。\n        *   质量：$m_1$ 和 $m_2$。\n        *   最近邻耦合：劲度系数为 $K$ 的谐振子弹簧。\n        *   平衡间距：$a/2$。\n        *   原胞长度：$a$。\n        *   第 $n$ 个原胞中质量为 $m_1$ 的位移：$u_n(t)$。\n        *   第 $n$ 个原胞中质量为 $m_2$ 的位移：$v_n(t)$。\n        *   任务：使用拉格朗日形式 ($L=T-V$) 求运动方程。\n        *   任务：求解第一布里渊区 $[-\\pi/a, \\pi/a]$ 中波数为 $k$ 的简正模解（布洛赫形式）。\n        *   任务：推导色散关系 $\\omega(k)$。\n        *   任务：识别声学支和光学支。\n        *   任务：通过考察长波极限 ($k \\to 0$) 以及在 $k=0$ 和 $k=\\pi/a$ 处的行为来证明。\n        *   最终答案：$\\omega_{\\mathrm{ac}}(k)$ 和 $\\omega_{\\mathrm{op}}(k)$ 的显式闭合形式表达式。\n\n    *   **步骤 2：验证：** 我需要根据我的验证标准检查问题。\n        *   **科学上成立：** 是的，这是固态物理和材料科学中的一个标准的、基本的问题。它是晶格动力学的教科书级例子。\n        *   **良态的：** 是的，问题定义清晰。它指定了模型、方法（拉格朗日）和期望的输出。存在唯一解。\n        *   **客观的：** 是的，语言精确且技术性强。没有主观因素。\n        *   **其他缺陷：**\n            *   **科学上不健全：** 无。该模型是一个公认的物理近似。\n            *   **无法形式化/不相关：** 该问题高度可形式化，并与所述的计算材料科学中的分析力学主题直接相关。\n            *   **不完整/矛盾：** 设置是完整的。所有必要的参数（$m_1, m_2, K, a$）和变量（$u_n, v_n$）都已定义。\n            *   **不切实际/不可行：** 该模型是一种理想化，但它是一个标准的、有物理意义的模型。\n            *   **问题不适定/结构不良：** 结构清晰，能够导向唯一解。\n            *   **伪深刻/琐碎：** 这是一个非琐碎的、典型的问题，需要对力学和波物理有扎实的理解。\n            *   **无法验证：** 结果是标准的，可以验证。\n\n    *   **步骤 3：结论：** 问题是**有效的**。我将继续进行解答。\n\n2.  **解决问题：**\n    *   **步骤 1：定义系统和坐标。**\n        *   原子位于平衡位置。\n        *   在第 $n$ 个原胞中，质量 $m_1$ 位于 $x_{n,1}^{(0)} = na$。\n        *   在第 $n$ 个原胞中，质量 $m_2$ 位于 $x_{n,2}^{(0)} = na + a/2$。\n        *   位移分别是第 $n$ 个原胞中 $m_1$ 的 $u_n(t)$ 和 $m_2$ 的 $v_n(t)$。\n        *   实际位置是：\n            *   $x_{n,1}(t) = na + u_n(t)$\n            *   $x_{n,2}(t) = na + a/2 + v_n(t)$\n\n    *   **步骤 2：写出拉格朗日量 $L = T - V$。**\n        *   **动能 (T)：** 链中所有原子动能的总和。我们可以考虑每个原胞的动能，然后对所有 $n$ 求和。\n            *   $T = \\sum_n \\left( \\frac{1}{2} m_1 \\dot{u}_n^2 + \\frac{1}{2} m_2 \\dot{v}_n^2 \\right)$\n        *   **势能 (V)：** 储存在弹簧中的势能的总和。每个弹簧连接两个相邻的原子。我们需要小心处理索引。\n            *   让我们考虑原胞*内部*和*之间*的弹簧。\n            *   第 $n-1$ 个原胞的质量 $m_2$ 与第 $n$ 个原胞的质量 $m_1$ 之间的弹簧。\n                *   第 $n-1$ 个原胞中 $m_2$ 的平衡位置：$(n-1)a + a/2$。\n                *   第 $n$ 个原胞中 $m_1$ 的平衡位置：$na$。\n                *   平衡间距：$na - ((n-1)a + a/2) = a/2$。\n                *   第 $n-1$ 个原胞中 $m_2$ 的实际位置：$(n-1)a + a/2 + v_{n-1}$。\n                *   第 $n$ 个原胞中 $m_1$ 的实际位置：$na + u_n$。\n                *   该弹簧的伸长量：$(na + u_n) - ((n-1)a + a/2 + v_{n-1}) - a/2 = u_n - v_{n-1}$。\n                *   势能：$\\frac{1}{2} K (u_n - v_{n-1})^2$。\n            *   第 $n$ 个原胞的质量 $m_1$ 与第 $n$ 个原胞的质量 $m_2$ 之间的弹簧。\n                *   平衡间距：$a/2$。\n                *   实际位置：$na + u_n$ 和 $na + a/2 + v_n$。\n                *   该弹簧的伸长量：$(na + a/2 + v_n) - (na + u_n) - a/2 = v_n - u_n$。\n                *   势能：$\\frac{1}{2} K (v_n - u_n)^2$。\n            *   总势能是所有这些弹簧的能量之和。让我们对所有弹簧求和。\n            *   一个更好的写法是：$V = \\sum_n \\left( \\frac{1}{2} K (v_n - u_n)^2 + \\frac{1}{2} K (u_{n+1} - v_n)^2 \\right)$。这是链中所有弹簧的势能总和。\n\n        *   **拉格朗日量 (L)：**\n            *   $L = T - V = \\sum_n \\left[ \\frac{1}{2} m_1 \\dot{u}_n^2 + \\frac{1}{2} m_2 \\dot{v}_n^2 - \\frac{1}{2} K (v_n - u_n)^2 - \\frac{1}{2} K (u_{n+1} - v_n)^2 \\right]$。\n\n    *   **步骤 3：应用欧拉-拉格朗日方程。**\n        *   方程为：\n            *   $\\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial \\dot{u}_n} \\right) - \\frac{\\partial L}{\\partial u_n} = 0$\n            *   $\\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial \\dot{v}_n} \\right) - \\frac{\\partial L}{\\partial v_n} = 0$\n\n        *   **对于 $u_n$：**\n            *   $\\frac{\\partial L}{\\partial \\dot{u}_n} = m_1 \\dot{u}_n$\n            *   $\\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial \\dot{u}_n} \\right) = m_1 \\ddot{u}_n$\n            *   $\\frac{\\partial L}{\\partial u_n}$ 来自 $V$ 求和中的三个项。包含 $(v_n - u_n)^2$ 的项和包含 $(u_n - v_{n-1})^2$ 的项。\n            *   $\\frac{\\partial L}{\\partial u_n} = - \\frac{1}{2} K \\frac{\\partial}{\\partial u_n} (v_n - u_n)^2 - \\frac{1}{2} K \\frac{\\partial}{\\partial u_n} (u_n - v_{n-1})^2$\n            *   $\\frac{\\partial L}{\\partial u_n} = -K(v_n - u_n)(-1) - K(u_n - v_{n-1})(1) = K(v_n - u_n) - K(u_n - v_{n-1}) = K(v_n + v_{n-1} - 2u_n)$。\n            *   所以，第一个运动方程是：$m_1 \\ddot{u}_n = K (v_n + v_{n-1} - 2u_n)$。\n\n        *   **对于 $v_n$：**\n            *   $\\frac{\\partial L}{\\partial \\dot{v}_n} = m_2 \\dot{v}_n$\n            *   $\\frac{d}{dt} \\left( \\frac{\\partial L}{\\partial \\dot{v}_n} \\right) = m_2 \\ddot{v}_n$\n            *   $L$ 中包含 $v_n$ 的项是：$-\\frac{1}{2}K(v_n-u_n)^2$ 和 $-\\frac{1}{2}K(u_{n+1} - v_n)^2$。\n            *   $\\frac{\\partial L}{\\partial v_n} = - \\frac{1}{2} K \\frac{\\partial}{\\partial v_n} (v_n - u_n)^2 - \\frac{1}{2} K \\frac{\\partial}{\\partial v_n} (u_{n+1} - v_n)^2$\n            *   $\\frac{\\partial L}{\\partial v_n} = -K(v_n - u_n)(1) - K(u_{n+1} - v_n)(-1) = -K(v_n - u_n) + K(u_{n+1} - v_n) = K(u_n + u_{n+1} - 2v_n)$。\n            *   所以，第二个运动方程是：$m_2 \\ddot{v}_n = K (u_{n+1} + u_n - 2v_n)$。\n\n        *   运动方程：\n            *   $m_1 \\ddot{u}_n = K(v_n + v_{n-1} - 2u_n)$\n            *   $m_2 \\ddot{v}_n = K(u_{n+1} + u_n - 2v_n)$\n        *   这似乎是正确的。这是一个耦合的微分-差分方程组。\n\n    *   **步骤 4：求解简正模解。**\n        *   由于晶格的周期性，我们假设一个平面波解（布洛赫形式）。第 $n$ 个原胞中的位移通过一个相位因子与第 $0$ 个原胞中的位移相关。第 $n$ 个原胞的平衡位置是 $na$。\n        *   正确的试探解形式：\n            *   $u_n(t) = U \\exp[i(kna - \\omega t)]$\n            *   $v_n(t) = V \\exp[i(kna - \\omega t)]$\n            *   $U$ 和 $V$ 是原胞中两个原子的复振幅。位置依赖性由原胞指数 $n$ 正确捕捉。\n\n        *   让我们计算时间导数和位移项：\n            *   $\\ddot{u}_n = -\\omega^2 u_n = -\\omega^2 U \\exp[i(kna - \\omega t)]$\n            *   $\\ddot{v}_n = -\\omega^2 v_n = -\\omega^2 V \\exp[i(kna - \\omega t)]$\n            *   $v_{n-1} = V \\exp[i(k(n-1)a - \\omega t)] = v_n \\exp[-ika]$。\n            *   $u_{n+1} = U \\exp[i(k(n+1)a - \\omega t)] = u_n \\exp[ika]$。\n\n        *   将这些代入运动方程：\n            *   $-m_1 \\omega^2 U \\exp[i(kna - \\omega t)] = K(V \\exp[i(kna - \\omega t)] + V \\exp[i(kna - \\omega t)]\\exp[-ika] - 2U \\exp[i(kna - \\omega t)])$\n            *   $-m_2 \\omega^2 V \\exp[i(kna - \\omega t)] = K(U \\exp[i(kna - \\omega t)]\\exp[ika] + U \\exp[i(kna - \\omega t)] - 2V \\exp[i(kna - \\omega t)])$\n\n        *   消去两边的公因子 $\\exp[i(kna - \\omega t)]$：\n            *   $-m_1 \\omega^2 U = K(V (1 + \\exp[-ika]) - 2U)$\n            *   $-m_2 \\omega^2 V = K(U (1 + \\exp[ika]) - 2V)$\n\n        *   重新整理为关于振幅 $(U, V)$ 的矩阵方程：\n            *   $(2K - m_1 \\omega^2) U - K(1 + \\exp[-ika]) V = 0$\n            *   $-K(1 + \\exp[ika]) U + (2K - m_2 \\omega^2) V = 0$\n\n        *   这是一个形式为 $M \\begin{pmatrix} U \\\\ V \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$ 的齐次线性方程组。为了得到非平凡解 $(U, V) \\neq (0, 0)$，系数矩阵的行列式必须为零。\n        *   $\\det \\begin{pmatrix} 2K - m_1 \\omega^2  -K(1 + \\exp[-ika]) \\\\ -K(1 + \\exp[ika])  2K - m_2 \\omega^2 \\end{pmatrix} = 0$\n\n    *   **步骤 5：求解行列式方程（久期方程）。**\n        *   $(2K - m_1 \\omega^2)(2K - m_2 \\omega^2) - K^2(1 + \\exp[-ika])(1 + \\exp[ika]) = 0$\n        *   让我们展开这些项：\n            *   第二项是 $K^2 (1 + \\exp[ika] + \\exp[-ika] + 1) = K^2(2 + 2\\cos(ka)) = 4K^2\\cos^2(ka/2)$。\n\n        *   久期方程是：\n            *   $(2K - m_1 \\omega^2)(2K - m_2 \\omega^2) - 4K^2 \\cos^2(ka/2) = 0$\n\n        *   展开第一部分：\n            *   $4K^2 - 2K(m_1+m_2)\\omega^2 + m_1 m_2 \\omega^4 - 4K^2 \\cos^2(ka/2) = 0$\n\n        *   重新整理为关于 $\\omega^2$ 的二次方程：\n            *   $m_1 m_2 (\\omega^2)^2 - 2K(m_1+m_2)\\omega^2 + 4K^2 (1 - \\cos^2(ka/2)) = 0$\n            *   使用 $1 - \\cos^2(x) = \\sin^2(x)$：\n            *   $m_1 m_2 (\\omega^2)^2 - 2K(m_1+m_2)\\omega^2 + 4K^2 \\sin^2(ka/2) = 0$\n\n        *   解这个关于 $\\omega^2$ 的二次方程，得到：\n            *   $\\omega^2 = \\frac{2K(m_1+m_2) \\pm \\sqrt{(-2K(m_1+m_2))^2 - 4(m_1 m_2)(4K^2 \\sin^2(ka/2))}}{2 m_1 m_2}$\n            *   $\\omega^2 = \\frac{K(m_1+m_2) \\pm K \\sqrt{(m_1+m_2)^2 - 4 m_1 m_2 \\sin^2(ka/2)}}{m_1 m_2}$\n            *   这可以写成标准形式：\n            *   $\\omega^2 = K(\\frac{1}{m_1} + \\frac{1}{m_2}) \\pm K \\sqrt{(\\frac{1}{m_1} + \\frac{1}{m_2})^2 - \\frac{4 \\sin^2(ka/2)}{m_1 m_2}}$\n            *   推导是正确的。\n\n    *   **步骤 6：识别声学支和光学支。**\n        *   这两个解对应于 $\\omega^2$ 表达式中的正负号。\n        *   我们分析长波极限，即 $k \\to 0$。在此极限下，$\\sin(ka/2) \\approx ka/2$。\n        *   \n        *   **情况 1：正号（光学支）**\n            *   在 $k=0$ 时，$\\sin(ka/2) = 0$。\n            *   $\\omega^2(k=0) = K(\\frac{1}{m_1} + \\frac{1}{m_2}) \\pm K \\sqrt{(\\frac{1}{m_1} + \\frac{1}{m_2})^2} = K(\\frac{1}{m_1} + \\frac{1}{m_2}) \\pm K(\\frac{1}{m_1} + \\frac{1}{m_2})$。\n            *   取正号：$\\omega^2_{\\mathrm{op}}(k=0) = 2K(\\frac{1}{m_1} + \\frac{1}{m_2}) = 2K \\frac{m_1+m_2}{m_1 m_2}$。这是一个非零频率。这对应于**光学支**。\n                *   在 $k=0$ 时，对于光学支，运动方程给出 $m_1 U = -m_2 V$。这意味着原胞中的两个原子反向运动。原胞的质心 $m_1 U + m_2 V$ 是静止的。这是光学模的特征。如果原子带电（如问题所述的离子晶体），它可被电场（光）激发。\n\n        *   **情况 2：负号（声学支）**\n            *   在 $k=0$ 时取负号：$\\omega^2_{\\mathrm{ac}}(k=0) = K(\\frac{1}{m_1} + \\frac{1}{m_2}) - K(\\frac{1}{m_1} + \\frac{1}{m_2}) = 0$。所以 $\\omega_{\\mathrm{ac}}(0)=0$。这是**声学支**的特征。\n            *   对于小的 $k$，可以证明 $\\omega_{\\mathrm{ac}}(k) \\approx v_s |k|$，其中 $v_s$ 是声速。这确认了它是声学支。在长波极限下，原胞中的原子同相运动 ($U \\approx V$)。这对应于晶体的整体平移或声波。\n\n    *   **理由总结：**\n        *   当 $k \\to 0$ 时 $\\omega \\to 0$ 的分支是声学支。它描述了类似于声波的长波振动，其中原胞中的原子同相运动。这对应于 $\\omega^2$ 解中的负号。\n        *   在 $k=0$ 时 $\\omega$ 为有限非零值的分支是光学支。它描述了两个子晶格（$m_1$ 和 $m_2$ 型原子）彼此反向振动的模式。这对应于正号。\n\n    *   **步骤 7：在布里渊区边界（$k = \\pi/a$）的行为。**\n        *   在 $k = \\pi/a$ 时，$ka/2 = \\pi/2$，因此 $\\sin(ka/2) = 1$。\n        *   运动方程解耦为：\n            *   $(2K - m_1 \\omega^2) U = 0$\n            *   $(2K - m_2 \\omega^2) V = 0$\n        *   这给出了两个独立的解：\n            *   解 1：$U \\ne 0, V = 0$，此时 $\\omega^2 = 2K/m_1$。\n            *   解 2：$U = 0, V \\ne 0$，此时 $\\omega^2 = 2K/m_2$。\n        *   这表明在布里渊区边界，一个子晶格振动，而另一个子晶格静止。\n        *   假设 $m_1 > m_2$。那么 $2K/m_1  2K/m_2$。\n        *   $\\omega^2_{\\text{ac}}(\\pi/a) = 2K/m_1$（较重的原子振动）。\n        *   $\\omega^2_{\\text{op}}(\\pi/a) = 2K/m_2$（较轻的原子振动）。\n        *   较高频率属于光学支，较低频率属于声学支。这与物理直觉相符。\n\n    *   **最终答案的构建：**\n        *   问题要求提供 $\\omega_{\\mathrm{ac}}(k)$ 和 $\\omega_{\\mathrm{op}}(k)$。\n        *   我对 $\\omega^2$ 的表达式取平方根。\n        *   光学支对应正号：\n            *   $\\omega_{\\mathrm{op}}(k) = \\sqrt{K\\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right) + K\\sqrt{\\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)^2 - \\frac{4\\sin^2(ka/2)}{m_1 m_2}}}$\n        *   声学支对应负号：\n            *   $\\omega_{\\mathrm{ac}}(k) = \\sqrt{K\\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right) - K\\sqrt{\\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)^2 - \\frac{4\\sin^2(ka/2)}{m_1 m_2}}}$\n        *   这是最终的解析表达式。\n\n    *   **推理和步骤回顾：**\n        1.  **拉格朗日量：** 正确。\n        2.  **欧拉-拉格朗日方程：** 与牛顿第二定律直接推导的力方程一致。正确。\n        3.  **平面波试探解：** 标准且正确。\n        4.  **特征方程：** 推导过程正确。\n        5.  **二次方程求解：** 正确。\n        6.  **分支识别：** 在 $k \\to 0$ 时的分析正确识别了声学支和光学支。\n        7.  **最终表达式：** 最终的 $\\omega_{\\mathrm{ac}}(k)$ 和 $\\omega_{\\mathrm{op}}(k)$ 表达式是正确的。\n\n一切似乎都井然有序。我现在将按照所有格式规则写出解答。", "answer": "$$\n\\boxed{\n\\begin{align*}\n\\omega_{\\mathrm{ac}}(k) = \\sqrt{K\\left(\\frac{1}{m_{1}} + \\frac{1}{m_{2}}\\right) - K\\sqrt{\\left(\\frac{1}{m_{1}} + \\frac{1}{m_{2}}\\right)^{2} - \\frac{4}{m_{1}m_{2}}\\sin^{2}\\left(\\frac{ka}{2}\\right)}} \\\\\n\\omega_{\\mathrm{op}}(k) = \\sqrt{K\\left(\\frac{1}{m_{1}} + \\frac{1}{m_{2}}\\right) + K\\sqrt{\\left(\\frac{1}{m_{1}} + \\frac{1}{m_{2}}\\right)^{2} - \\frac{4}{m_{1}m_{2}}\\sin^{2}\\left(\\frac{ka}{2}\\right)}}\n\\end{align*}\n}\n$$", "id": "3432860"}, {"introduction": "在掌握了晶格振动的解析推导之后，我们现在转向一个更具计算性的视角，即哈密顿形式主义。这个练习将理论与实践相结合，要求你编写代码，通过正则变换来对角化一个耦合振子系统的哈密顿量。这本质上是从计算角度解决了与前一个练习[@problem_id:3432860]相同类型的问题。\n\n      本实践的核心是展示正则变换这一看似抽象的概念如何转化为一个强大的计算工具，用于数值求解任意质量-弹簧系统的正规模频率（声子）[@problem_id:3432798]。你将亲手实现这一理论，并通过验证其辛性质等步骤来确保计算的正确性，这是计算科学家必备的一项核心技能。", "problem": "考虑一个一维合金晶格，其模型为一个有限的点质量链，通过线性弹簧连接，且仅存在最近邻相互作用。设广义坐标为位移组成的向量 $\\boldsymbol{x} \\in \\mathbb{R}^N$，其中 $N$ 是质量点的数量，其共轭动量为 $\\boldsymbol{p} \\in \\mathbb{R}^N$。质量矩阵为对角矩阵 $\\mathbf{M} = \\mathrm{diag}(m_1, \\dots, m_N)$，其中 $m_i \\gt 0$ 单位为千克；刚度矩阵 $\\mathbf{K} \\in \\mathbb{R}^{N \\times N}$ 为对称矩阵，由刚度为 $k$（单位为牛顿/米）的最近邻弹簧构成。拉格朗日量为 $L = T - V$，其中动能为 $T = \\tfrac{1}{2} \\dot{\\boldsymbol{x}}^\\top \\mathbf{M} \\dot{\\boldsymbol{x}}$，势能为 $V = \\tfrac{1}{2} \\boldsymbol{x}^\\top \\mathbf{K} \\boldsymbol{x}$。共轭动量为 $\\boldsymbol{p} = \\partial L / \\partial \\dot{\\boldsymbol{x}} = \\mathbf{M} \\dot{\\boldsymbol{x}}$，哈密顿量为 $H(\\boldsymbol{x}, \\boldsymbol{p}) = \\tfrac{1}{2} \\boldsymbol{p}^\\top \\mathbf{M}^{-1} \\boldsymbol{p} + \\tfrac{1}{2} \\boldsymbol{x}^\\top \\mathbf{K} \\boldsymbol{x}$。\n\n任务：从这些基本定义出发，推导并实现一个实线性正则变换（相空间上的一个辛映射），将哈密顿量解耦为一系列具有非负角频率的独立谐振子之和。此方法需适用于计算材料科学中的声子计算。您的实现必须：\n- 根据给定的链规格，构造矩阵 $\\mathbf{M}$ 和 $\\mathbf{K}$，可选择自由或固定边界条件。自由端不与墙壁相连，固定端通过刚度为 $k$ 的弹簧与墙壁相连。\n- 生成一个辛变换矩阵 $\\mathbf{S}$，将 $(\\boldsymbol{x}, \\boldsymbol{p})$ 映射到新的正则坐标 $(\\boldsymbol{Q}, \\boldsymbol{P})$。在新坐标系中，哈密顿量呈现解耦的二次型 $H = \\tfrac{1}{2} \\sum_i \\left(P_i^2 + \\omega_i^2 Q_i^2\\right)$，其中 $\\omega_i \\ge 0$ 是角频率，单位为弧度/秒。\n- 通过计算与辛条件的偏差的弗罗贝尼乌斯范数 $\\left\\| \\mathbf{S}^\\top \\mathbf{J} \\mathbf{S} - \\mathbf{J} \\right\\|_F$ 来验证辛性，其中 $\\mathbf{J} = \\begin{bmatrix} \\mathbf{0}  \\mathbf{I} \\\\ -\\mathbf{I}  \\mathbf{0} \\end{bmatrix}$，$\\mathbf{I}$ 是 $N \\times N$ 单位矩阵。\n- 通过在变换后的坐标系中计算变换后的势能度规和动能度规的非对角元绝对值的最大值来量化解耦质量。具体来说，如果变换为 $(\\boldsymbol{Q}, \\boldsymbol{P}) = \\mathbf{S} (\\boldsymbol{x}, \\boldsymbol{p})$，则二次型哈密顿矩阵变换为 $\\mathbf{H}' = \\mathbf{S}^{-\\top} \\,\\mathrm{diag}(\\mathbf{K}, \\mathbf{M}^{-1})\\, \\mathbf{S}^{-1}$；从 $\\mathbf{H}'$ 中提取左上 $N \\times N$ 分块（$\\boldsymbol{Q}$ 中的势能度规）和右下 $N \\times N$ 分块（$\\boldsymbol{P}$ 中的动能度规），并报告其非对角元绝对值的最大值。\n\n物理和数值单位：\n- 质量 $m_i$ 必须以千克为单位。\n- 弹簧常数 $k$ 必须以牛顿/米为单位。\n- 角频率 $\\omega_i$ 必须以弧度/秒为单位，表示为实值浮点数。\n\n角度单位：\n- 任何角度量必须使用弧度。\n\n您的程序必须实现上述要求，并将其应用于以下测试套件。对于每种情况，按所述构造 $\\mathbf{M}$ 和 $\\mathbf{K}$，计算正则解耦，并返回指定的输出。\n\n测试套件：\n- 情况 A（包含声学零模的正常情况）：$N = 3$，质量为 $[1.0, 2.0, 1.5]$ 千克，弹簧刚度 $k = 100.0$ 牛顿/米，两端均为自由边界条件。\n- 情况 B（固定端，无零模）：$N = 3$，质量为 $[1.0, 2.0, 1.5]$ 千克，弹簧刚度 $k = 100.0$ 牛顿/米，两端均为固定边界条件（每端通过刚度为 $k$ 的弹簧与墙壁相连）。\n- 情况 C（近简并合金）：$N = 4$，质量为 $[1.0, 1.01, 0.99, 1.0]$ 千克，弹簧刚度 $k = 50.0$ 牛顿/米，两端均为固定边界条件。\n\n每个测试用例的必需输出：\n- 一个包含 $N$ 个角频率 $\\omega_i$ 的列表，按升序排列，单位为弧度/秒。\n- 一个浮点数，等于弗罗贝尼乌斯范数 $\\left\\| \\mathbf{S}^\\top \\mathbf{J} \\mathbf{S} - \\mathbf{J} \\right\\|_F$。\n- 一个浮点数，等于变换后势能度规（$\\mathbf{H}'$ 的左上分块）的非对角元绝对值的最大值。\n- 一个浮点数，等于变换后动能度规（$\\mathbf{H}'$ 的右下分块）的非对角元绝对值的最大值。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个由逗号分隔的列表，该列表用方括号括起。其中每个测试用例的结果构成一个子列表，形式为 $[\\text{角频率}, \\text{辛误差}, \\text{最大非对角势能项}, \\text{最大非对角动能项}]$。例如，一个包含三个测试用例的输出应具有 $[[\\cdots], [\\cdots], [\\cdots]]$ 的形式，其中每个内部列表都符合指定结构。", "solution": "我们从应用于耦合质点-弹簧系统的分析力学基本定义出发。广义坐标 $\\boldsymbol{x} \\in \\mathbb{R}^N$ 汇集了 $N$ 个质点的位移，其质量矩阵为对角矩阵 $\\mathbf{M} = \\mathrm{diag}(m_1, \\dots, m_N)$，刚度矩阵 $\\mathbf{K}$ 为对称矩阵。拉格朗日量为 $L = T - V$，其中动能 $T = \\tfrac{1}{2} \\dot{\\boldsymbol{x}}^\\top \\mathbf{M} \\dot{\\boldsymbol{x}}$，势能 $V = \\tfrac{1}{2} \\boldsymbol{x}^\\top \\mathbf{K} \\boldsymbol{x}$。共轭动量为 $\\boldsymbol{p} = \\partial L / \\partial \\dot{\\boldsymbol{x}} = \\mathbf{M} \\dot{\\boldsymbol{x}}$，哈密顿量为 $H(\\boldsymbol{x}, \\boldsymbol{p}) = \\tfrac{1}{2} \\boldsymbol{p}^\\top \\mathbf{M}^{-1} \\boldsymbol{p} + \\tfrac{1}{2} \\boldsymbol{x}^\\top \\mathbf{K} \\boldsymbol{x}$。\n\n我们的目标是找到一个实线性正则变换，将哈密顿量解耦为一系列非耦合谐振子之和。相空间 $\\mathbb{R}^{2N}$ 上的一个实线性正则变换由一个辛矩阵 $\\mathbf{S} \\in \\mathbb{R}^{2N \\times 2N}$ 表示，该矩阵满足 $\\mathbf{S}^\\top \\mathbf{J} \\mathbf{S} = \\mathbf{J}$，其中 $\\mathbf{J} = \\begin{bmatrix} \\mathbf{0}  \\mathbf{I} \\\\ -\\mathbf{I}  \\mathbf{0} \\end{bmatrix}$。我们寻求一个 $\\mathbf{S}$，使得在新的正则坐标 $(\\boldsymbol{Q}, \\boldsymbol{P}) = \\mathbf{S} (\\boldsymbol{x}, \\boldsymbol{p})$ 下，哈密顿量变为\n$$\nH = \\tfrac{1}{2} \\sum_{i=1}^N \\left( P_i^2 + \\omega_i^2 Q_i^2 \\right),\n$$\n其中 $\\omega_i$ 为非负角频率。\n\n基于第一性原理的构造方法：\n- 第一步（质量归一化）：通过一个正则的、分块对角缩放来定义质量加权坐标。考虑变换 $(\\boldsymbol{y}, \\boldsymbol{\\pi}_y) = (\\mathbf{M}^{1/2} \\boldsymbol{x}, \\mathbf{M}^{-1/2} \\boldsymbol{p})$。该变换由分块对角矩阵 $\\mathbf{S}_1 = \\mathrm{diag}(\\mathbf{M}^{1/2}, \\mathbf{M}^{-1/2})$ 生成。为了验证其辛性，对于一个分块对角变换 $\\mathrm{diag}(\\mathbf{A}, \\mathbf{B})$，条件 $\\mathbf{S}_1^\\top \\mathbf{J} \\mathbf{S}_1 = \\mathbf{J}$ 成立当且仅当 $\\mathbf{A}^\\top \\mathbf{B} = \\mathbf{I}$。此处 $\\mathbf{A} = \\mathbf{M}^{1/2}$ 和 $\\mathbf{B} = \\mathbf{M}^{-1/2}$ 满足 $\\mathbf{A}^\\top \\mathbf{B} = \\mathbf{M}^{1/2} \\mathbf{M}^{-1/2} = \\mathbf{I}$。在这些坐标下，哈密顿量变为\n$$\nH = \\tfrac{1}{2} \\boldsymbol{\\pi}_y^\\top \\boldsymbol{\\pi}_y + \\tfrac{1}{2} \\boldsymbol{y}^\\top \\mathbf{C} \\boldsymbol{y},\n$$\n其中 $\\mathbf{C} = \\mathbf{M}^{-1/2} \\mathbf{K} \\mathbf{M}^{-1/2}$ 是对称且对于稳定系统是半正定的。\n\n- 第二步（正交解耦）：用一个正交矩阵 $\\mathbf{O}$ 对角化 $\\mathbf{C}$，即 $\\mathbf{O}^\\top \\mathbf{C} \\mathbf{O} = \\boldsymbol{\\Omega}^2 = \\mathrm{diag}(\\omega_1^2, \\dots, \\omega_N^2)$，其中 $\\omega_i \\ge 0$。执行旋转 $(\\boldsymbol{Q}, \\boldsymbol{P}) = (\\mathbf{O}^\\top \\boldsymbol{y}, \\mathbf{O}^\\top \\boldsymbol{\\pi}_y)$。这第二个变换 $\\mathbf{S}_2 = \\mathrm{diag}(\\mathbf{O}^\\top, \\mathbf{O}^\\top)$ 是辛变换，因为 $\\mathbf{O}$ 是正交的，并且再次满足 $\\mathbf{A}^\\top \\mathbf{B} = \\mathbf{I}$。因此，复合变换 $\\mathbf{S} = \\mathbf{S}_2 \\mathbf{S}_1$ 是辛的，并得到解耦的哈密顿量\n$$\nH = \\tfrac{1}{2} \\boldsymbol{P}^\\top \\boldsymbol{P} + \\tfrac{1}{2} \\boldsymbol{Q}^\\top \\boldsymbol{\\Omega}^2 \\boldsymbol{Q} = \\tfrac{1}{2} \\sum_{i=1}^N \\left( P_i^2 + \\omega_i^2 Q_i^2 \\right).\n$$\n\n明确地说，将 $(\\boldsymbol{x}, \\boldsymbol{p})$ 映射到 $(\\boldsymbol{Q}, \\boldsymbol{P})$ 的完整辛映射 $\\mathbf{S}$ 是\n$$\n\\mathbf{S} = \\begin{bmatrix}\n\\mathbf{O}^\\top \\mathbf{M}^{1/2}  \\mathbf{0} \\\\\n\\mathbf{0}  \\mathbf{O}^\\top \\mathbf{M}^{-1/2}\n\\end{bmatrix},\n$$\n该变换满足 $\\mathbf{S}^\\top \\mathbf{J} \\mathbf{S} = \\mathbf{J}$，因为 $(\\mathbf{O}^\\top \\mathbf{M}^{1/2})^\\top (\\mathbf{O}^\\top \\mathbf{M}^{-1/2}) = \\mathbf{M}^{1/2} \\mathbf{O} \\mathbf{O}^\\top \\mathbf{M}^{-1/2} = \\mathbf{I}$。\n\n算法实现：\n- 通过组合最近邻的贡献来为具有弹簧常数 $k$ 的一维链构造 $\\mathbf{K}$。对于每一对相邻的质点 $(i, i+1)$，将 $k$ 加到对角元 $(i,i)$ 和 $(i+1,i+1)$ 上，并将 $-k$ 加到非对角元 $(i,i+1)$ 和 $(i+1,i)$ 上。对于固定边界条件，在 $(1,1)$ 和 $(N,N)$ 元上额外加上 $k$，以表示连接到刚性墙壁的末端弹簧。对于自由边界条件，不添加墙壁弹簧。\n- 设 $\\mathbf{M} = \\mathrm{diag}(m_1, \\dots, m_N)$，其中质量单位为千克。\n- 利用质量的对角平方根构建 $\\mathbf{C} = \\mathbf{M}^{-1/2} \\mathbf{K} \\mathbf{M}^{-1/2}$。使用对称特征值求解器对角化 $\\mathbf{C}$，得到特征对 $(\\omega_i^2, \\boldsymbol{v}_i)$ 和正交特征向量矩阵 $\\mathbf{O} = [\\boldsymbol{v}_1, \\dots, \\boldsymbol{v}_N]$。将特征值按升序排序，并计算 $\\omega_i = \\sqrt{\\max(0, \\omega_i^2)}$ 以确保非负性。\n- 如上构建辛矩阵 $\\mathbf{S}$，并通过计算弗罗贝尼乌斯范数 $\\left\\| \\mathbf{S}^\\top \\mathbf{J} \\mathbf{S} - \\mathbf{J} \\right\\|_F$ 来验证其辛性。\n- 通过将二次型哈密顿矩阵 $\\mathrm{diag}(\\mathbf{K}, \\mathbf{M}^{-1})$ 变换为 $\\mathbf{H}' = \\mathbf{S}^{-\\top} \\,\\mathrm{diag}(\\mathbf{K}, \\mathbf{M}^{-1})\\, \\mathbf{S}^{-1}$ 来量化解耦效果；然后提取左上分块 $\\mathbf{H}'_{QQ}$ 和右下分块 $\\mathbf{H}'_{PP}$。在精确计算中，$\\mathbf{H}'_{QQ} = \\boldsymbol{\\Omega}^2$ 且 $\\mathbf{H}'_{PP} = \\mathbf{I}$。计算这些分块的非对角元绝对值的最大值，以评估数值解耦的效果。\n- 单位：质量单位为千克，弹簧常数单位为牛顿/米，角频率单位为弧度/秒。\n\n测试套件覆盖范围：\n- 情况 A 考察具有声学零模（$\\omega = 0$）的自由边界链，这是平移不变性的典型特征，旨在确保实现能够正确处理半正定刚度矩阵。\n- 情况 B 使用固定边界条件以消除零模，产生严格为正的频率，并在正定设置下测试变换。\n- 情况 C 使用近似相等的质量来引发近简并，以探测正交对角化和辛构造的数值稳定性。\n\n该代码实现了上述推导，按规定构造了 $\\mathbf{M}$ 和 $\\mathbf{K}$，计算了 $\\boldsymbol{\\omega}$、辛偏差范数以及变换后势能和动能度规的最大非对角元大小，并以所需的单行列表嵌套列表格式打印结果。", "answer": "```python\nimport numpy as np\n\ndef build_chain_matrices(N, masses, k, boundary):\n    \"\"\"\n    Build mass matrix M (diagonal) and stiffness matrix K for a 1D chain.\n    boundary: 'free' or 'fixed'\n    \"\"\"\n    M = np.diag(masses)\n    K = np.zeros((N, N), dtype=float)\n    # Nearest-neighbor springs\n    for i in range(N - 1):\n        K[i, i] += k\n        K[i + 1, i + 1] += k\n        K[i, i + 1] -= k\n        K[i + 1, i] -= k\n    # Boundary springs to walls if fixed\n    if boundary == 'fixed':\n        K[0, 0] += k\n        K[-1, -1] += k\n    elif boundary == 'free':\n        pass\n    else:\n        raise ValueError(\"boundary must be 'free' or 'fixed'\")\n    return M, K\n\ndef symplectic_decouple(M, K, atol_clip=1e-12):\n    \"\"\"\n    Compute symplectic transformation S that decouples the Hamiltonian:\n    H = 1/2 p^T M^{-1} p + 1/2 x^T K x\n    Returns frequencies (ascending), symplectic error, max offdiag of transformed\n    potential metric, max offdiag of transformed kinetic metric.\n    \"\"\"\n    N = M.shape[0]\n    # Mass square roots\n    masses = np.diag(M)\n    Msqrt = np.diag(np.sqrt(masses))\n    Minv = np.diag(1.0 / masses)\n    Minv_sqrt = np.diag(1.0 / np.sqrt(masses))\n\n    # Mass-weighted stiffness\n    C = Minv_sqrt @ K @ Minv_sqrt\n    # Symmetric eigen-decomposition\n    w2, O = np.linalg.eigh(C)  # ascending eigenvalues\n    # Clip small negative eigenvalues from numerical noise\n    w2_clipped = np.maximum(w2, 0.0)\n    w = np.sqrt(w2_clipped)\n\n    # Build symplectic matrix S = diag(O^T Msqrt, O^T Minv_sqrt)\n    A = O.T @ Msqrt\n    B = O.T @ Minv_sqrt\n    zero = np.zeros_like(A)\n    S = np.block([[A, np.zeros((N, N))],\n                  [np.zeros((N, N)), B]])\n\n    # Symplectic check: || S^T J S - J ||_F\n    I = np.eye(N)\n    J = np.block([[np.zeros((N, N)), I],\n                  [-I, np.zeros((N, N))]])\n    symp_err = np.linalg.norm(S.T @ J @ S - J, ord='fro')\n\n    # Transform Hamiltonian quadratic form Hmat = diag(K, M^{-1})\n    Hmat = np.block([[K, np.zeros((N, N))],\n                     [np.zeros((N, N)), Minv]])\n    # Compute S^{-1} via block diagonal inverse\n    # Since S is block diagonal with invertible blocks A and B:\n    # S^{-1} = diag(A^{-1}, B^{-1})\n    A_inv = np.linalg.inv(A)\n    B_inv = np.linalg.inv(B)\n    S_inv = np.block([[A_inv, np.zeros((N, N))],\n                      [np.zeros((N, N)), B_inv]])\n    S_inv_T = S_inv.T\n    Hprime = S_inv_T @ Hmat @ S_inv\n\n    # Extract transformed potential and kinetic metric blocks\n    Hqq = Hprime[:N, :N]\n    Hpp = Hprime[N:, N:]\n\n    # Compute maximum absolute off-diagonal entries\n    def max_offdiag_abs(Mblock):\n        Moff = Mblock - np.diag(np.diag(Mblock))\n        if Moff.size == 0:\n            return 0.0\n        return float(np.max(np.abs(Moff)))\n\n    pot_off = max_offdiag_abs(Hqq)\n    kin_off = max_offdiag_abs(Hpp)\n\n    return w.tolist(), float(symp_err), float(pot_off), float(kin_off)\n\ndef solve():\n    # Define test cases as per the problem statement\n    test_cases = [\n        # Case A: N=3, masses [1.0, 2.0, 1.5], k=100.0, boundary='free'\n        {\"N\": 3, \"masses\": [1.0, 2.0, 1.5], \"k\": 100.0, \"boundary\": \"free\"},\n        # Case B: N=3, masses [1.0, 2.0, 1.5], k=100.0, boundary='fixed'\n        {\"N\": 3, \"masses\": [1.0, 2.0, 1.5], \"k\": 100.0, \"boundary\": \"fixed\"},\n        # Case C: N=4, masses [1.0, 1.01, 0.99, 1.0], k=50.0, boundary='fixed'\n        {\"N\": 4, \"masses\": [1.0, 1.01, 0.99, 1.0], \"k\": 50.0, \"boundary\": \"fixed\"},\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        masses = np.array(case[\"masses\"], dtype=float)\n        k = float(case[\"k\"])\n        boundary = case[\"boundary\"]\n        M, K = build_chain_matrices(N, masses, k, boundary)\n        freqs, symp_err, pot_off, kin_off = symplectic_decouple(M, K)\n        results.append([freqs, symp_err, pot_off, kin_off])\n\n    # Final print statement in the exact required format.\n    # Ensure deterministic float formatting via default repr; lists-of-lists printed as requested.\n    print(str(results).replace(' ', ''))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3432798"}, {"introduction": "最后，我们来应对一个在分子模拟中普遍存在的更复杂场景：包含刚性键约束的系统。处理此类系统需要更高级的哈密顿力学技术，即狄拉克约束理论。这个练习将带你进入分析力学在现代计算模拟中的前沿应用。\n\n      通过编程实现狄拉克的约束哈密顿系统理论，你将深入理解约束是如何修正系统的运动方程，甚至通过改变相空间测度来影响其统计力学性质[@problem_id:3432820]。这个高阶实践不仅让你掌握处理约束动力学的强大形式，也为你理解如SHAKE和RATTLE等现代分子动力学算法的理论基础提供了深刻的洞见。", "problem": "实现一个完整、可运行的程序。对于具有刚性键约束的小分子模型，该程序使用狄拉克（Dirac）针对第二类约束的理论构建约束哈密顿动力学，并定量比较修正前后的相空间测度。您的实现必须仅从第一性原理和定义出发，不得使用作为推导目标的、预先推导出的快捷公式。\n\n您必须遵守以下定义和要求。\n\n1) 基本建模定义。\n\n- 考虑一个在$d$维空间中包含$N$个点状粒子的系统，其广义坐标为$\\mathbf{q} \\in \\mathbb{R}^{n_q}$，正则动量为$\\mathbf{p} \\in \\mathbb{R}^{n_q}$，其中$n_q = dN$，且$\\mathbf{q} = (q_1,\\ldots,q_{n_q})$，$\\mathbf{p} = (p_1,\\ldots,p_{n_q})$。\n- 设哈密顿量为$H(\\mathbf{q},\\mathbf{p}) = \\frac{1}{2}\\mathbf{p}^\\mathsf{T} M^{-1} \\mathbf{p} + V(\\mathbf{q})$，其中$M$是一个常数、对角、正定的$n_q \\times n_q$质量矩阵，$V(\\mathbf{q})$是一个光滑势。\n- 两个光滑函数$f(\\mathbf{q},\\mathbf{p})$和$g(\\mathbf{q},\\mathbf{p})$的正则泊松括号为$\\{f,g\\} = \\sum_{i=1}^{n_q} \\left( \\frac{\\partial f}{\\partial q_i}\\frac{\\partial g}{\\partial p_i} - \\frac{\\partial f}{\\partial p_i}\\frac{\\partial g}{\\partial q_i} \\right)$。\n- 一组$m$个完整键约束由$g_j(\\mathbf{q})=0$（$j=1,\\ldots,m$）给出，当它们与其时间导数结合时，构成第二类约束。定义主约束$\\phi^{(1)}_j(\\mathbf{q},\\mathbf{p}) = g_j(\\mathbf{q})$和通过沿哈密顿流对$g_j(\\mathbf{q})$求导得到的次级约束$\\phi^{(2)}_j(\\mathbf{q},\\mathbf{p}) = \\dot g_j(\\mathbf{q},\\mathbf{p})$。\n- 对于粒子$a$和$b$之间目标长度为$\\ell_j$的刚性键，定义$g_j(\\mathbf{q}) = \\frac{1}{2}\\left\\|\\mathbf{r}_b - \\mathbf{r}_a\\right\\|^2 - \\frac{1}{2}\\ell_j^2$，其中$\\mathbf{r}_k \\in \\mathbb{R}^d$是粒子$k$的位置。设$J(\\mathbf{q}) \\in \\mathbb{R}^{m \\times n_q}$为约束雅可比矩阵，其行为$J_j(\\mathbf{q}) = \\nabla_{\\mathbf{q}} g_j(\\mathbf{q})$，并设$H_j(\\mathbf{q}) \\in \\mathbb{R}^{n_q \\times n_q}$为$g_j$的黑塞矩阵。\n\n2) 狄拉克理论。\n\n- 将$2m$个约束收集到向量$\\boldsymbol{\\phi} = (\\phi^{(1)}_1,\\ldots,\\phi^{(1)}_m,\\phi^{(2)}_1,\\ldots,\\phi^{(2)}_m)^\\mathsf{T}$中。约束矩阵$C(\\mathbf{q},\\mathbf{p}) \\in \\mathbb{R}^{2m \\times 2m}$的元素为$C_{ab}(\\mathbf{q},\\mathbf{p}) = \\{\\phi_a,\\phi_b\\}$。\n- $f$和$g$的狄拉克括号为$\\{f,g\\}_D = \\{f,g\\} - \\sum_{a,b=1}^{2m} \\{f,\\phi_a\\} \\left(C^{-1}\\right)_{ab} \\{\\phi_b,g\\}$。\n- 约束下的时间演化由$\\frac{d}{dt} f = \\{f,H\\}_D$生成，它保持所有约束$\\phi_a=0$。\n\n3) 相空间测度的修正。\n\n- 约束流形上的不变相空间测度为$\\delta(\\boldsymbol{\\phi}) \\sqrt{\\left|\\det C\\right|}\\, d\\mathbf{q}\\, d\\mathbf{p}$，其中$\\delta(\\boldsymbol{\\phi})$是强制所有$2m$个约束的狄拉克δ函数的乘积。\n- 在次级约束下对动量进行积分后，导出的构型空间边际分布包含一个称为Fixman修正的因子，该因子通过格拉姆矩阵$G(\\mathbf{q}) = J(\\mathbf{q}) M^{-1} J(\\mathbf{q})^\\mathsf{T} \\in \\mathbb{R}^{m \\times m}$依赖于约束的几何形状。\n\n4) 代码中要执行的任务。\n\n对于每个测试用例，您的程序必须：\n\n- 为指定的刚性键构建$J(\\mathbf{q})$和黑塞矩阵集合$\\{H_j(\\mathbf{q})\\}_{j=1}^m$。在本问题中，始终使用$d=2$和无量纲单位。\n- 通过计算所有主约束和次级约束之间的泊松括号，仅使用上述定义，构建$2m \\times 2m$的狄拉克矩阵$C(\\mathbf{q},\\mathbf{p})$。\n- 计算$G(\\mathbf{q}) = J(\\mathbf{q}) M^{-1} J(\\mathbf{q})^\\mathsf{T}$、行列式$\\det G(\\mathbf{q})$和$\\sqrt{|\\det C(\\mathbf{q},\\mathbf{p})|}$。通过报告比率$R = \\sqrt{|\\det C|}/\\det G$和Fixman因子$F = \\sqrt{\\det G}$，来量化相空间测度的修正及其与约束几何的关系。\n- 以等效的拉格朗日乘子形式实现狄拉克括号所蕴含的约束运动方程。使用$J(\\mathbf{q})$、$H_j(\\mathbf{q})$、$M^{-1}$和$\\nabla V(\\mathbf{q})$，计算强制执行约束的乘子，并评估瞬时主约束和次级约束的导数，报告一个违背度量$V_{\\max}$，其定义为在给定状态下、在约束动力学作用下$\\dot{\\mathbf{g}}$和$\\ddot{\\mathbf{g}}$所有分量绝对值的最大值。\n- 所有计算必须以双精度进行。所有输出必须是实值标量。\n\n5) 测试套件。\n\n使用以下三个测试用例。所有量都是无量纲的，并且必须如此处理。\n\n- 测试A（两个粒子，一个键，谐振子陷阱）：\n  - $N=2$, $d=2$, $m_1 = 1$, $m_2 = 2$。\n  - $\\mathbf{r}_1 = (0,0)$, $\\mathbf{r}_2 = (1,0)$, $\\ell_1 = 1$。\n  - $\\mathbf{p}_1 = (0,0.3)$, $\\mathbf{p}_2 = (0,-0.4)$。\n  - $V(\\mathbf{q}) = \\frac{1}{2}k\\left(\\left\\|\\mathbf{r}_1\\right\\|^2 + \\left\\|\\mathbf{r}_2\\right\\|^2\\right)$，其中$k=0.7$。\n\n- 测试B（三个粒子，两个键，自由）：\n  - $N=3$, $d=2$, $m_1 = 1$, $m_2 = 1$, $m_3 = 1$。\n  - $\\mathbf{r}_1 = (0,0)$, $\\mathbf{r}_2 = (1,0.5)$, $\\mathbf{r}_3 = (2.1,0.1)$。\n  - $\\ell_1 = \\left\\|\\mathbf{r}_2 - \\mathbf{r}_1\\right\\|$, $\\ell_2 = \\left\\|\\mathbf{r}_3 - \\mathbf{r}_2\\right\\|$。\n  - $\\mathbf{p}_1 = (0,1)$, $\\mathbf{p}_2 = (0,1)$, $\\mathbf{p}_3 = (0,1)$。\n  - $V(\\mathbf{q}) \\equiv 0$。\n\n- 测试C（两个粒子，一个键，极端质量比，自由）：\n  - $N=2$, $d=2$, $m_1 = 1$, $m_2 = 10^6$。\n  - $\\mathbf{r}_1 = (0,0)$, $\\mathbf{r}_2 = (1,0)$, $\\ell_1 = 1$。\n  - $\\mathbf{p}_1 = (0,0.2)$, $\\mathbf{p}_2 = (0,-0.2)$。\n  - $V(\\mathbf{q}) \\equiv 0$。\n\n6) 必需输出和最终输出格式。\n\n对于每个测试用例，计算并返回三个标量：\n- $R = \\sqrt{|\\det C|}/\\det G$,\n- $F = \\sqrt{\\det G}$,\n- $V_{\\max}$，在给定状态下，约束动力学作用下主约束和次级约束时间导数的最大绝对违背值。\n\n您的程序应生成单行输出，其中包含三个测试用例的所有九个结果，格式为逗号分隔的Python浮点数列表，顺序为$[R_A,F_A,V_{\\max,A}, R_B,F_B,V_{\\max,B}, R_C,F_C,V_{\\max,C}]$，例如$[1.0,0.5,0.0, \\ldots]$。\n\n仅使用无量纲量。如果出现任何角度，必须以弧度为单位。不允许用户输入，所有数据必须从上述测试套件中硬编码。", "solution": "该问题陈述经评估是有效的。它在科学上基于分析力学的原理，特别是针对约束哈密顿系统的狄拉克-伯格曼（Dirac-Bergmann）理论。该问题定义良好，为获得唯一的、可计算的解提供了所有必要的数据和定义。其语言是客观的，要求可以形式化为一个具体的算法。\n\n### 理论表述\n\n所考虑的系统由$d$维空间中的$N$个粒子组成，由广义坐标$\\mathbf{q} \\in \\mathbb{R}^{n_q}$和动量$\\mathbf{p} \\in \\mathbb{R}^{n_q}$描述，其中$n_q=dN$。动力学由哈密顿量$H(\\mathbf{q},\\mathbf{p}) = \\frac{1}{2}\\mathbf{p}^\\mathsf{T} M^{-1} \\mathbf{p} + V(\\mathbf{q})$控制，其中$M$是一个常数对角质量矩阵。\n\n系统受到$m$个形式为$g_j(\\mathbf{q})=0$的完整约束。对于刚性键，这些约束是$g_j(\\mathbf{q}) = \\frac{1}{2}(\\|\\mathbf{r}_b - \\mathbf{r}_a\\|^2 - \\ell_j^2) = 0$。这些约束导致相空间中一组$2m$个第二类约束：\n1.  **主约束**：$\\phi^{(1)}_j \\equiv g_j(\\mathbf{q}) = 0$。\n2.  **次级约束**：$\\phi^{(2)}_j \\equiv \\dot{g}_j = \\{g_j, H\\} = (\\nabla_{\\mathbf{q}} g_j)^\\mathsf{T} M^{-1} \\mathbf{p} = J_j(\\mathbf{q}) M^{-1} \\mathbf{p} = 0$，其中$J_j(\\mathbf{q})$是约束雅可比矩阵$J(\\mathbf{q})$的第$j$行。\n\n全套约束由向量$\\boldsymbol{\\phi} = (\\phi^{(1)}_1, \\dots, \\phi^{(1)}_m, \\phi^{(2)}_1, \\dots, \\phi^{(2)}_m)^\\mathsf{T}$表示。\n\n**1. 狄拉克矩阵和相空间测度**\n\n狄拉克理论的核心是约束矩阵$C$，其元素为$C_{ab} = \\{\\phi_a, \\phi_b\\}$，其中$\\{\\cdot,\\cdot\\}$是正则泊松括号：$\\{f,g\\} = (\\nabla_{\\mathbf{q}} f)^\\mathsf{T} (\\nabla_{\\mathbf{p}} g) - (\\nabla_{\\mathbf{p}} f)^\\mathsf{T} (\\nabla_{\\mathbf{q}} g)$。要构建$C$，我们需要约束的相空间梯度：\n-   对于主约束$\\phi^{(1)}_j = g_j$：\n    $$ \\nabla_{\\mathbf{q}} \\phi^{(1)}_j = J_j^\\mathsf{T}, \\quad \\nabla_{\\mathbf{p}} \\phi^{(1)}_j = \\mathbf{0} $$\n-   对于次级约束$\\phi^{(2)}_j = J_j M^{-1} \\mathbf{p}$：\n    $$ \\nabla_{\\mathbf{q}} \\phi^{(2)}_j = H_j M^{-1} \\mathbf{p}, \\quad \\nabla_{\\mathbf{p}} \\phi^{(2)}_j = M^{-1} J_j^\\mathsf{T} $$\n    其中$H_j = \\nabla_{\\mathbf{q}} \\nabla_{\\mathbf{q}}^\\mathsf{T} g_j$是$g_j$的黑塞矩阵。\n\n约束曲面上的不变相空间测度被一个因子$\\sqrt{|\\det C|}$修正。该因子与构型空间中的约束几何有关，后者由格拉姆矩阵$G(\\mathbf{q}) = J(\\mathbf{q}) M^{-1} J(\\mathbf{q})^\\mathsf{T}$表征。一个关键的理论结果是，对于这类约束，$\\det C = (\\det G)^2$，本问题要求我们用数值方法验证这一点。这意味着比率$R = \\sqrt{|\\det C|} / \\det G$应等于$1$。Fixman修正因子定义为$F = \\sqrt{\\det G}$。\n\n**2. 约束运动方程**\n\n约束下的时间演化可以等效地使用拉格朗日乘子来描述。运动方程为：\n$$ \\dot{\\mathbf{q}} = M^{-1}\\mathbf{p} $$\n$$ \\dot{\\mathbf{p}} = -\\nabla_{\\mathbf{q}} V - J^\\mathsf{T} \\boldsymbol{\\lambda} $$\n乘子$\\boldsymbol{\\lambda} \\in \\mathbb{R}^m$通过要求约束随时间保持不变来确定，具体来说是$\\ddot{g}_j = 0$对所有$j=1,\\ldots,m$成立。对$\\dot{g}_j = J_j \\dot{\\mathbf{q}}$关于时间求导得到：\n$$ \\ddot{g}_j = \\dot{J}_j \\dot{\\mathbf{q}} + J_j \\ddot{\\mathbf{q}} = \\dot{\\mathbf{q}}^\\mathsf{T} H_j \\dot{\\mathbf{q}} + J_j M^{-1} \\dot{\\mathbf{p}} = 0 $$\n代入$\\dot{\\mathbf{p}}$的表达式，得到一个关于$\\boldsymbol{\\lambda}$的线性系统：\n$$ \\dot{\\mathbf{q}}^\\mathsf{T} H_j \\dot{\\mathbf{q}} + J_j M^{-1} (-\\nabla_{\\mathbf{q}} V - J^\\mathsf{T} \\boldsymbol{\\lambda}) = 0 $$\n这可以写成矩阵形式$G \\boldsymbol{\\lambda} = \\mathbf{b}$，其中向量$\\mathbf{b}$的分量为$b_j = \\dot{\\mathbf{q}}^\\mathsf{T} H_j \\dot{\\mathbf{q}} - J_j M^{-1} \\nabla_{\\mathbf{q}} V$。求解该系统可得到强制执行约束的唯一乘子$\\boldsymbol{\\lambda}$。违背度量$V_{\\max}$是在给定状态下计算出的约束时间导数$\\dot{g}_j$和$\\ddot{g}_j$的最大绝对值。根据构造，这些值应在数值精度范围内为零。\n\n### 算法设计\n\n该解法通过一个Python函数实现，该函数按以下步骤处理每个测试用例：\n\n1.  **初始化**：对于给定的测试用例（$N, d,$ 质量、位置$\\mathbf{r}_i$、动量$\\mathbf{p}_i$、约束），构造全局相空间向量$\\mathbf{q}, \\mathbf{p}$和逆质量矩阵$M^{-1}$。\n\n2.  **几何对象构造**：\n    -   对于粒子$a$和$b$之间的每个刚性键约束$g_j$，从$J_j = \\nabla_{\\mathbf{q}} g_j$计算雅可比矩阵的相应行$J_j$。特定于粒子的梯度为$\\nabla_{\\mathbf{r}_a} g_j = -(\\mathbf{r}_b - \\mathbf{r}_a)$和$\\nabla_{\\mathbf{r}_b} g_j = (\\mathbf{r}_b - \\mathbf{r}_a)$。\n    -   构造黑塞矩阵$H_j = \\nabla_{\\mathbf{q}}\\nabla_{\\mathbf{q}}^\\mathsf{T} g_j$。它由对应于粒子$a$和$b$的块中的$d \\times d$单位块$I_d$和$-I_d$组成。\n    -   通过堆叠行$J_j$来组装完整的雅可比矩阵$J$。\n\n3.  **相空间因子计算($R, F$)**：\n    -   计算格拉姆矩阵$G = J M^{-1} J^\\mathsf{T}$。\n    -   计算其行列式$\\det G$，并求得Fixman因子$F = \\sqrt{\\det G}$。\n    -   从第一性原理构建$2m \\times 2m$的狄拉克矩阵$C$。解析计算所有$2m$个主约束和次级约束的梯度。使用嵌套循环遍历所有对$(\\phi_a, \\phi_b)$，并使用泊松括号的定义计算$C_{ab} = \\{\\phi_a, \\phi_b\\}$。\n    -   计算行列式$\\det C$，并确定比率$R = \\sqrt{|\\det C|} / \\det G$。该值预期为$1.0$。\n\n4.  **约束违背计算($V_{\\max}$)**：\n    -   在给定的构型$\\mathbf{q}$处，计算势的梯度$\\nabla_{\\mathbf{q}} V$。\n    -   计算拉格朗日乘子系统的向量$\\mathbf{b}$，其元素为$b_j = (M^{-1}\\mathbf{p})^\\mathsf{T} H_j (M^{-1}\\mathbf{p}) - J_j M^{-1} \\nabla_{\\mathbf{q}} V$。\n    -   求解线性系统$G \\boldsymbol{\\lambda} = \\mathbf{b}$以得到拉格朗日乘子$\\boldsymbol{\\lambda}$。\n    -   计算主约束的时间导数$\\dot{\\mathbf{g}} = J M^{-1} \\mathbf{p}$和次级约束的时间导数$\\ddot{\\mathbf{g}} = \\mathbf{b} - G \\boldsymbol{\\lambda}$。\n    -   违背度量$V_{\\max}$是在$\\dot{\\mathbf{g}}$和$\\ddot{\\mathbf{g}}$的所有分量中找到的最大绝对值。\n\n此过程应用于三个测试用例中的每一个，并将得到的九个标量值（每个案例的$R, F, V_{\\max}$）收集并格式化为最终输出。使用双精度浮点算术和`numpy`进行线性代数运算，确保了数值稳定性和准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_case_outputs(N, d, masses, r_coords, p_coords, constraints_info, potential_grad_func):\n    \"\"\"\n    Computes R, F, and V_max for a single test case.\n    \"\"\"\n    n_q = N * d\n    m = len(constraints_info)\n\n    # 1. Setup q, p, M_inv\n    q = np.array(r_coords, dtype=float).flatten()\n    p = np.array(p_coords, dtype=float).flatten()\n    \n    mass_vec = np.repeat(np.array(masses, dtype=float), d)\n    M_inv = np.diag(1.0 / mass_vec)\n\n    # 2. Build J and Hessians\n    J = np.zeros((m, n_q))\n    Hessians = []\n    \n    Id = np.eye(d)\n\n    for i, (p_a_idx, p_b_idx) in enumerate(constraints_info):\n        # Jacobian row for constraint i\n        r_a = q[d*p_a_idx : d*(p_a_idx+1)]\n        r_b = q[d*p_b_idx : d*(p_b_idx+1)]\n        r_ba = r_b - r_a\n        J[i, d*p_a_idx : d*(p_a_idx+1)] = -r_ba\n        J[i, d*p_b_idx : d*(p_b_idx+1)] = r_ba\n\n        # Hessian for constraint i\n        H = np.zeros((n_q, n_q))\n        H[d*p_a_idx:d*(p_a_idx+1), d*p_a_idx:d*(p_a_idx+1)] = Id\n        H[d*p_b_idx:d*(p_b_idx+1), d*p_b_idx:d*(p_b_idx+1)] = Id\n        H[d*p_a_idx:d*(p_a_idx+1), d*p_b_idx:d*(p_b_idx+1)] = -Id\n        H[d*p_b_idx:d*(p_b_idx+1), d*p_a_idx:d*(p_a_idx+1)] = -Id\n        Hessians.append(H)\n    \n    # 3. Calculate G, det_G, F\n    if m == 0:\n        det_G = 1.0\n    else:\n        G = J @ M_inv @ J.T\n        det_G = np.linalg.det(G)\n    \n    F = np.sqrt(det_G)\n    \n    # 4. Build Dirac Matrix C\n    C = np.zeros((2*m, 2*m))\n    \n    if m  0:\n        grad_q_list = []\n        grad_p_list = []\n        \n        # Primary constraints (g_j)\n        for i in range(m):\n            grad_q_list.append(J[i].reshape(-1, 1))\n            grad_p_list.append(np.zeros((n_q, 1)))\n\n        # Secondary constraints (dg_j/dt)\n        for i in range(m):\n            grad_q_list.append(Hessians[i] @ M_inv @ p.reshape(-1, 1))\n            grad_p_list.append(M_inv @ J[i].reshape(-1, 1))\n            \n        for i in range(2*m):\n            for j in range(2*m):\n                grad_q_i = grad_q_list[i]\n                grad_p_i = grad_p_list[i]\n                grad_q_j = grad_q_list[j]\n                grad_p_j = grad_p_list[j]\n                \n                # C_ij = {phi_i, phi_j}\n                C[i, j] = (grad_q_i.T @ grad_p_j - grad_p_i.T @ grad_q_j)[0, 0]\n            \n    # 5. Calculate det_C and R\n    if m == 0:\n        det_C = 1.0\n        R = 1.0\n    else:\n        det_C = np.linalg.det(C)\n        if np.abs(det_G)  1e-15: # Avoid division by zero\n             R = np.inf if np.abs(det_C)  1e-15 else 1.0\n        else:\n             R = np.sqrt(np.abs(det_C)) / det_G\n\n    # 6. Calculate V_max\n    if m == 0:\n        V_max = 0.0\n        return R, F, V_max\n\n    grad_V = potential_grad_func(q)\n    \n    b = np.zeros(m)\n    vel = M_inv @ p\n    for i in range(m):\n        term1 = vel.T @ Hessians[i] @ vel\n        term2 = J[i] @ M_inv @ grad_V\n        b[i] = term1 - term2\n    \n    lambdas = np.linalg.solve(G, b)\n    \n    # 7. Compute violations\n    g_dot = J @ M_inv @ p\n    g_ddot = b - G @ lambdas\n    \n    V_max = np.max(np.abs(np.concatenate((g_dot, g_ddot))))\n\n    return R, F, V_max\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the required outputs for each.\n    \"\"\"\n    d = 2\n\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"N\": 2,\n            \"masses\": [1.0, 2.0],\n            \"r_coords\": [[0.0, 0.0], [1.0, 0.0]],\n            \"p_coords\": [[0.0, 0.3], [0.0, -0.4]],\n            \"constraints_info\": [(0, 1)], # particle indices\n            \"potential_grad_func\": lambda q: 0.7 * q\n        },\n        {\n            \"name\": \"B\",\n            \"N\": 3,\n            \"masses\": [1.0, 1.0, 1.0],\n            \"r_coords\": [[0.0, 0.0], [1.0, 0.5], [2.1, 0.1]],\n            \"p_coords\": [[0.0, 1.0], [0.0, 1.0], [0.0, 1.0]],\n            \"constraints_info\": [(0, 1), (1, 2)],\n            \"potential_grad_func\": lambda q: np.zeros_like(q)\n        },\n        {\n            \"name\": \"C\",\n            \"N\": 2,\n            \"masses\": [1.0, 1e6],\n            \"r_coords\": [[0.0, 0.0], [1.0, 0.0]],\n            \"p_coords\": [[0.0, 0.2], [0.0, -0.2]],\n            \"constraints_info\": [(0, 1)],\n            \"potential_grad_func\": lambda q: np.zeros_like(q)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        R, F, V_max = compute_case_outputs(\n            case[\"N\"],\n            d,\n            case[\"masses\"],\n            case[\"r_coords\"],\n            case[\"p_coords\"],\n            case[\"constraints_info\"],\n            case[\"potential_grad_func\"]\n        )\n        results.extend([R, F, V_max])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.16e}' for x in results)}]\")\n\nsolve()\n```", "id": "3432820"}]}