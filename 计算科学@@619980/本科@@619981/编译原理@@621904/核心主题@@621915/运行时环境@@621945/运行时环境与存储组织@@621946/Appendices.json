{"hands_on_practices": [{"introduction": "数据在内存中如何排列是运行时环境设计中的一个基本问题。这个练习将带你探讨数据对齐的核心概念，这是一个在性能和内存使用之间进行权衡的关键领域。通过为一个假设的记录数组计算在紧凑布局策略下的未对齐访问惩罚，你将亲身体验到不遵循硬件对齐要求所带来的具体性能成本，从而深刻理解编译器和系统程序员为何如此关注数据结构的内存布局。[@problem_id:3668688]", "problem": "一个系统遵循一种应用二进制接口 (ABI)，其中中央处理器 (CPU) 字的自然对齐为 $A$ 字节。一条记录 (record) 是从其基地址开始，置于连续地址上的一系列字段。数组中每条记录的基地址被限制为 $A$ 的倍数。对于任何大小为 $s$ 字节的字段，其理想对齐要求为 $\\min(s, A)$ 字节。如果一个大小为 $s$ 的字段被放置在地址 $x$ 处，而该地址不满足 $x \\equiv 0 \\pmod{\\min(s, A)}$，则访问该字段会产生固定的 $p_{s}$ 个周期的未对齐惩罚；否则惩罚为 $0$ 个周期。\n\n考虑一个平台，其 $A = 8$ 字节，未对齐惩罚模型为 $p_{2} = 1$ 个周期，$p_{4} = 2$ 个周期，以及 $p_{8} = 4$ 个周期。考虑一个包含 $N$ 条记录的数组，其中每条记录按顺序包含以下字段（大小以字节为单位）：$8, 2, 4, 8, 2, 4, 8$。\n\n定义两种记录布局策略如下：\n\n- 策略 $\\mathcal{A}$ （对齐并填充）：在放置一个大小为 $s$ 的字段之前，插入最少数量的填充字节（可能为零），以使该字段相对于记录基地址的偏移量是 $\\min(s, A)$ 的倍数。在最后一个字段之后，插入尾部填充，以使记录总大小是 $A$ 的倍数。\n- 策略 $\\mathcal{P}$ （紧凑，不填充）：将字段紧密相连地放置，不进行任何填充。不添加尾部填充；记录大小是所有字段大小的总和。\n\n假设每条记录都被访问一次，即每个字段都被精确读取一次，并且第一条记录的基地址是 $A$ 的倍数。\n\n仅从上述定义出发，确定在策略 $\\mathcal{P}$ 下访问所有 $N$ 条记录时所产生的总未对齐惩罚（以周期为单位）。请用一个关于 $N$ 的封闭形式表达式表示您的最终答案。不要对答案进行四舍五入。请在最终答案框中以数字或解析表达式的形式陈述您的答案，不带单位。", "solution": "用户希望确定在紧凑内存布局策略下访问一个包含 $N$ 条记录的数组时，所产生的总未对齐惩罚。分析过程如下。\n\n首先，我们必须确定在策略 $\\mathcal{P}$（紧凑，不填充）下单条记录的大小和布局。题目指出，记录由一系列字段组成，其大小（以字节为单位）为：$s_1=8, s_2=2, s_3=4, s_4=8, s_5=2, s_6=4, s_7=8$。在策略 $\\mathcal{P}$ 下，字段是紧密相连地放置的。一条记录的大小，记为 $S_{\\mathcal{P}}$，是其所有字段大小的总和：\n$$S_{\\mathcal{P}} = s_1 + s_2 + s_3 + s_4 + s_5 + s_6 + s_7 = 8 + 2 + 4 + 8 + 2 + 4 + 8 = 36 \\text{ 字节}$$\n\n接下来，我们确定每个字段相对于记录基地址的偏移量。设一条记录的基地址为 $B$。第一个字段的偏移量为 $0$。每个后续字段的偏移量是其前面所有字段大小的总和。\n- 字段 1 ($s_1=8$)：偏移量 $\\text{off}_1 = 0$\n- 字段 2 ($s_2=2$)：偏移量 $\\text{off}_2 = 8$\n- 字段 3 ($s_3=4$)：偏移量 $\\text{off}_3 = 8+2 = 10$\n- 字段 4 ($s_4=8$)：偏移量 $\\text{off}_4 = 10+4 = 14$\n- 字段 5 ($s_5=2$)：偏移量 $\\text{off}_5 = 14+8 = 22$\n- 字段 6 ($s_6=4$)：偏移量 $\\text{off}_6 = 22+2 = 24$\n- 字段 7 ($s_7=8$)：偏移量 $\\text{off}_7 = 24+4 = 28$\n\n题目指定了一个包含 $N$ 条此类记录的数组。第一条记录（索引 $i=0$）的基地址是自然对齐值 $A=8$ 的倍数。设第 $i$ 条记录（其中 $i \\in \\{0, 1, \\dots, N-1\\}$）的基地址为 $B_i$。我们有 $B_0 \\equiv 0 \\pmod 8$。\n任何后续记录的基地址由 $B_i = B_0 + i \\cdot S_{\\mathcal{P}} = B_0 + 36i$ 给出。\n记录 $i$ 中字段 $j$ 的绝对内存地址是 $X_{i,j} = B_i + \\text{off}_j = B_0 + 36i + \\text{off}_j$。\n\n如果一个大小为 $s$ 的字段位于地址 $X$ 且 $X \\not\\equiv 0 \\pmod{\\min(s, A)}$，则会产生 $p_s$ 的未对齐惩罚。我们必须计算每条记录中每个字段的惩罚。由于 $B_0 \\equiv 0 \\pmod 8$，并且所有对齐要求都是 $8$ 的因子，因此 $B_0$ 是每个对齐要求的倍数。因此，在检查条件 $X_{i,j} \\pmod{\\min(s_j, A)}$ 时，我们可以分析 $(36i + \\text{off}_j) \\pmod{\\min(s_j, A)}$，因为 $B_0$ 不影响余数。\n\n给定的惩罚值为 $p_2=1, p_4=2, p_8=4$。\n\n让我们计算第 $i$ 条记录中每个字段的惩罚：\n- **字段 1 ($s_1=8$)**：对齐要求为 $\\min(8, 8) = 8$。地址为 $X_{i,1} = B_0 + 36i$。我们检查 $(36i) \\pmod 8$。由于 $36 \\equiv 4 \\pmod 8$，这变为 $4i \\pmod 8$。当 $i$ 为偶数时，此表达式为 $0$；当 $i$ 为奇数时，为 $4$。当且仅当 $i$ 为奇数时，产生 $p_8=4$ 的惩罚。\n\n- **字段 2 ($s_2=2$)**：对齐要求为 $\\min(2, 8) = 2$。地址为 $X_{i,2} = B_0 + 36i + 8$。我们检查 $(36i+8) \\pmod 2$。由于 $36i$ 和 $8$ 都是偶数，它们的和也是偶数。因此，对所有 $i$ 都有 $36i+8 \\equiv 0 \\pmod 2$。不产生惩罚。\n\n- **字段 3 ($s_3=4$)**：对齐要求为 $\\min(4, 8) = 4$。地址为 $X_{i,3} = B_0 + 36i + 10$。我们检查 $(36i+10) \\pmod 4$。由于 $36 \\equiv 0 \\pmod 4$ 且 $10 \\equiv 2 \\pmod 4$，我们对所有 $i$ 都有 $36i+10 \\equiv 2 \\pmod 4$。地址永远不会对齐。总是产生 $p_4=2$ 的惩罚。\n\n- **字段 4 ($s_4=8$)**：对齐要求为 $\\min(8, 8) = 8$。地址为 $X_{i,4} = B_0 + 36i + 14$。我们检查 $(36i+14) \\pmod 8$。由于 $36 \\equiv 4 \\pmod 8$ 且 $14 \\equiv 6 \\pmod 8$，这变为 $(4i+6) \\pmod 8$。对于任何整数 $i$，$4i+6$ 都不能是 $8$ 的倍数。如果 $i$ 是偶数 ($i=2k$)，$4(2k)+6 = 8k+6 \\equiv 6 \\pmod 8$。如果 $i$ 是奇数 ($i=2k+1$)，$4(2k+1)+6 = 8k+10 \\equiv 2 \\pmod 8$。地址永远不会对齐。总是产生 $p_8=4$ 的惩罚。\n\n- **字段 5 ($s_5=2$)**：对齐要求为 $\\min(2, 8) = 2$。地址为 $X_{i,5} = B_0 + 36i + 22$。我们检查 $(36i+22) \\pmod 2$。$36i$ 和 $22$ 都是偶数，所以对所有 $i$ 都有 $36i+22 \\equiv 0 \\pmod 2$。不产生惩罚。\n\n- **字段 6 ($s_6=4$)**：对齐要求为 $\\min(4, 8) = 4$。地址为 $X_{i,6} = B_0 + 36i + 24$。我们检查 $(36i+24) \\pmod 4$。$36i$ 和 $24$ 都是 $4$ 的倍数。因此，对所有 $i$ 都有 $36i+24 \\equiv 0 \\pmod 4$。不产生惩罚。\n\n- **字段 7 ($s_7=8$)**：对齐要求为 $\\min(8, 8) = 8$。地址为 $X_{i,7} = B_0 + 36i + 28$。我们检查 $(36i+28) \\pmod 8$。由于 $36 \\equiv 4 \\pmod 8$ 且 $28 \\equiv 4 \\pmod 8$，这变为 $(4i+4) \\pmod 8$，即 $4(i+1) \\pmod 8$。如果 $i+1$ 是偶数（即 $i$ 是奇数），此表达式为 $0$；如果 $i+1$ 是奇数（即 $i$ 是偶数），则为 $4$。当且仅当 $i$ 为偶数时，产生 $p_8=4$ 的惩罚。\n\n现在，我们对单条记录 $i$ 的惩罚求和，记为 $P_i$。\n- 如果 $i$ 是偶数：\n  惩罚来自字段 3（$2$ 个周期）、字段 4（$4$ 个周期）和字段 7（$4$ 个周期）。\n  $P_{\\text{even}} = 0 + 0 + 2 + 4 + 0 + 0 + 4 = 10$ 个周期。\n- 如果 $i$ 是奇数：\n  惩罚来自字段 1（$4$ 个周期）、字段 3（$2$ 个周期）和字段 4（$4$ 个周期）。\n  $P_{\\text{odd}} = 4 + 0 + 2 + 4 + 0 + 0 + 0 = 10$ 个周期。\n\n访问任何单条记录的惩罚，无论其索引 $i$ 是多少，都是一个恒定值，等于 $10$ 个周期。\n\n访问所有 $N$ 条记录的总未对齐惩罚是每条记录惩罚的总和：\n$$P_{\\text{total}} = \\sum_{i=0}^{N-1} P_i = \\sum_{i=0}^{N-1} 10 = 10N$$\n\n因此，总未对齐惩罚为 $10N$ 个周期。", "answer": "$$\\boxed{10N}$$", "id": "3668688"}, {"introduction": "在理解了基本数据结构的内存布局后，我们进入一个更复杂的领域：托管语言（如 Java 或 C#）中对象的运行时管理。这些语言的运行时需要在每个对象上附加额外信息（元数据），以便支持垃圾回收、线程锁和类型识别等高级功能。这个设计挑战要求你在满足一系列复杂约束（如原子性、对齐和容量）的同时，为一个假设的 $64$ 位架构设计一个尽可能紧凑的对象头，这能让你深入了解现代语言运行时内部的精巧设计。[@problem_id:3668653]", "problem": "您正在为 $64$ 位架构上的托管语言运行时设计对象头布局。该运行时必须支持跟踪式垃圾回收和偏向/轻量/重量级锁，同时最小化对象头的大小。分配器返回的对象地址按 $A=16$ 字节对齐。对象有效负载的第一个字节紧跟在对象头之后，并且必须至少 $8$ 字节对齐。\n\n对象头必须包含三个逻辑组件：\n- 用于垃圾回收的标记和生命周期元数据，包含以下子字段：颜色（$2$ 位）、年龄（$3$ 位）、记忆集卡片标记（$1$ 位）和哈希安装标志（$1$ 位）。\n- 类型描述符引用。运行时维护一个连续的、全局已知的“类型表”基地址 $B_t$，该基地址按 $16$ 字节对齐，每个类型描述符占用恰好 $16$ 字节。最多可以存在 $N_t=2^{34}$ 个类型描述符。对象头可以存储一个完整的 $64$ 位指针，或者一个索引 $i$，该索引解码为指针 $B_t + 16 \\times i$。\n- 一个锁字，表示一个带有 $2$ 位标签的可辨识联合体，包含三种状态：\n  1. 未锁定：存储一个 $31$ 位的对象标识哈希值以及 $2$ 位的标签。\n  2. 轻量级锁定：存储一个 $T=20$ 位的线程标识符、一个 $R=9$ 位的递归计数，以及 $2$ 位的标签。\n  3. 重量级锁定：存储一个指向独立“监视器区域”中监视器结构的指针，该区域的基地址为 $B_m$，按 $16$ 字节对齐，最多包含 $N_m=2^{30}$ 个监视器，每个大小为 $16$ 字节。您可以存储一个完整的 $64$ 位指针，或者一个索引 $j$，该索引解码为 $B_m + 16 \\times j$；$2$ 位的标签必须将此状态与其他两种状态区分开。\n\n原子性和更新约束：\n- 任何可能并发更改的字段（锁字和标记位）都必须能通过对自然对齐的机器字执行单次原子比较并交换（CAS）操作来更新。自然字长为 $W=64$ 位。您不得将任何此类可变字段拆分到多个机器字中。\n\n您可以：\n- 如上所述，为类型描述符和监视器指针使用压缩索引而非完整指针。\n- 将标记位放置在您选择的任何头字段中，并在逻辑上兼容的情况下，重用对齐指针或索引的低位对齐位。\n- 为所有变体组件选择与给定最大值一致的位宽。\n\n确定字段的位宽和布局，以最小化总头大小 $H$（以字节为单位），同时满足所有约束。将最终的最小头大小 $H$ 表示为一个以字节为单位的数字。无需四舍五入；报告确切的最小大小（以字节为单位）。", "solution": "用户希望在一系列针对 $64$ 位架构的指定约束下，确定对象头的最小可能大小 $H$（以字节为单位）。\n\n首先，我们分析一下对头大小 $H$ 的约束。问题指出，对象的基地址按 $A=16$ 字节对齐。设此地址为 $addr_{\\text{obj}}$。对象有效负载紧跟在头之后。因此，有效负载的地址是 $addr_{\\text{payload}} = addr_{\\text{obj}} + H$。问题要求有效负载至少是 $8$ 字节对齐的。这意味着 $addr_{\\text{payload}}$ 必须是 $8$ 的倍数。\n由于 $addr_{\\text{obj}}$ 是 $16$ 的倍数，所以它也是 $8$ 的倍数。因此，要使 $addr_{\\text{obj}} + H$ 成为 $8$ 的倍数，头大小 $H$ 必须是 $8$ 字节的倍数。$H$ 的可能值为 $8$、$16$、$24$ 等字节。我们的目标是找到这些可能值中的最小值。\n\n接下来，我们必须确定需要存储在头中的总信息量。对象头有三个逻辑组件。\n\n1.  **垃圾回收（GC）和生命周期元数据：**\n    - 颜色：$2$ 位\n    - 年龄：$3$ 位\n    - 记忆集卡片标记：$1$ 位\n    - 哈希安装标志：$1$ 位\n    GC 元数据总位数：$2 + 3 + 1 + 1 = 7$ 位。\n\n2.  **类型描述符引用：**\n    - 系统最多可以有 $N_t = 2^{34}$ 个类型描述符。要用索引 $i$ 唯一标识每一个，我们需要 $\\lceil \\log_2(N_t) \\rceil = \\lceil \\log_2(2^{34}) \\rceil = 34$ 位。存储这个压缩索引比存储一个完整的 $64$ 位指针更节省空间。\n\n3.  **锁字：**\n    这是一个带有 $2$ 位标签的可辨识联合体，用于区分三种状态。锁字所需的总空间必须足以容纳其最大的变体。\n    -   **未锁定状态：** 存储一个 $31$ 位的对象标识哈希值。所需空间为哈希数据的 $31$ 位。\n    -   **轻量级锁定状态：** 存储一个 $T=20$ 位的线程标识符和一个 $R=9$ 位的递归计数。所需空间为数据的 $20 + 9 = 29$ 位。\n    -   **重量级锁定状态：** 存储对监视器结构的引用。最多有 $N_m = 2^{30}$ 个监视器。一个压缩索引 $j$ 需要 $\\lceil \\log_2(N_m) \\rceil = \\lceil \\log_2(2^{30}) \\rceil = 30$ 位。存储这个索引是满足下面讨论的原子性约束的唯一方法。所需空间为索引数据的 $30$ 位。\n\n    锁字的数据部分必须足够大，以容纳这三个变体中最大的一个。所需大小为 $\\max(31, 29, 30) = 31$ 位。\n    包括 $2$ 位的标签，锁字在逻辑上需要 $31 + 2 = 33$ 位的存储空间。\n\n现在，我们必须考虑原子性约束。问题指出，任何可能并发更改的字段都必须能通过对自然对齐的机器字执行单次原子比较并交换（CAS）操作来更新。指定的并发字段是“锁字和标记位”。在 $64$ 位架构上，自然字长为 $W=64$ 位。\n这个关键约束意味着所有可变字段必须一起驻留在单个 $64$ 位字内。\n\n可变字段是：\n- GC 标记位：$7$ 位。\n- 锁字：$33$ 位（包括标签和数据有效负载）。\n\n所有可变状态的总位数为 $7 + 33 = 40$ 位。这 $40$ 位信息必须被打包到一个单一的、自然对齐的 $64$ 位字中，我们可以称之为“标记和锁字”。这是可行的，因为 $40  64$。\n\n类型描述符引用（需要 $34$ 位作为索引）在对象创建时建立，并且不会并发更改。因此，它不需要与标记和锁位位于同一个可原子更新的字中。\n\n让我们总结一下必须存储在头中的总信息：\n- 可变状态（标记和锁）：$40$ 位。\n- 不可变状态（类型索引）：$34$ 位。\n所需的总位数为 $40 + 34 = 74$ 位。\n\n一个机器字是 $64$ 位。由于 $74 > 64$，整个头无法容纳在单个 $64$ 位字中，这意味着 $8$ 字节的头是不可能的。\n\n如前所述，头大小 $H$ 必须是 $8$ 字节的倍数。大于 $8$ 字节的最小 $8$ 字节倍数是 $16$ 字节。一个 $16$ 字节（$128$ 位）的头提供了两个 $64$ 位字。这足以存储所需的 $74$ 位信息，同时遵守所有约束：\n- **字 1（例如，在偏移量 $0$ 处）：**一个 $64$ 位的字，用作标记和锁字。它存储了 $40$ 位的可变状态。这满足了原子性约束。\n- **字 2（例如，在偏移量 $8$ 处）：**一个 $64$ 位的字，用于存储 $34$ 位的类型描述符索引。\n\n由于 $8$ 字节的头太小，而 $16$ 字节的头足够，因此最小可能的头大小是 $16$ 字节。重用对齐指针低位比特的选项不会改变这个结论，因为它无法解决需要存储 $74$ 位信息这个根本问题，这超出了单字头的 $64$ 位容量。\n\n因此，最小头大小 $H$ 是 $16$ 字节。", "answer": "$$\n\\boxed{16}\n$$", "id": "3668653"}, {"introduction": "本章的最终实践是一个综合性的编程任务，它将理论付诸实践。你将不再仅仅是分析或设计数据布局，而是要从头开始为一个类似 C 的语言实现一个支持闭包（closure）的完整手动内存管理系统。这个练习不仅要求你实现引用计数（Reference Counting），还迫使你直面其固有的局限性——循环引用，并实现一个循环检测器来解决这个问题。完成这个练习会让你对高级语言特性的运行时支持和复杂的内存管理策略有深刻而具体的认识。[@problem_id:3668730]", "problem": "要求您从基本原理出发，为一种不带自动垃圾回收的类 C 语言运行时设计并实现一个闭包存储模型。目标是为闭包、环境和引用建模，然后使用引用计数 (RC) 实现一种手动回收策略，并辅以一个能够回收循环垃圾的循环检测程序。最终交付物必须是一个完整且可运行的程序，它综合了这些思想并产生一个明确指定的数值输出。\n\n该问题的基本基础是：\n- 词法闭包表示为序对 $\\langle f, \\rho \\rangle$，其中 $f$ 是一个代码指针，$\\rho$ 是一个捕获自由变量绑定的环境，这些绑定可以包括指向其他闭包的指针。该模型在支持一等函数和词法作用域的高阶语言的运行时环境中是标准的。\n- 运行时必须将闭包及其环境存储在堆上，这样它们的生命周期就可以超过创建它们的活动记录（栈帧）。\n- 手动引用计数 (RC) 为每个堆对象 $o$ 维护一个非负整数 $\\mathrm{rc}(o)$，用于跟踪指向 $o$ 的有效引用的数量。操作 $\\mathrm{retain}(o)$ 和 $\\mathrm{release}(o)$ 分别递增和递减 $\\mathrm{rc}(o)$，当 $\\mathrm{rc}(o)$ 变为 $0$ 时，$o$ 就可以被回收，并对其持有的每个引用递归地应用 $\\mathrm{release}$ 操作。\n- 有向图和可达性：闭包堆可以建模为一个有向图 $G=(V,E)$，其中 $V$ 是闭包的集合，如果 $u$ 的环境持有对 $v$ 的引用，则 $(u,v)\\in E$。一个选定的根集合 $R \\subseteq V$ 表示外部持有的引用（例如，栈根、全局绑定）。\n\n该问题要求您：\n1. 定义一个能反映 $\\langle f, \\rho \\rangle$ 语义的闭包表示和手动引用计数机制：每条边 $(u,v)\\in E$ 必须为 $\\mathrm{rc}(v)$ 贡献一个单位，每个根 $r\\in R$ 必须为 $\\mathrm{rc}(r)$ 贡献一个单位。\n2. 通过“丢弃”根集合来实现朴素的 RC 回收：对每个 $r\\in R$ 调用 $\\mathrm{release}(r)$；$\\mathrm{rc}$ 值达到 $0$ 的对象必须被回收，并且其出向引用必须被递归地释放。\n3. 展示朴素 RC 无法回收循环垃圾的失败情况：在丢弃根之后，任何仍未被释放的对象集合都必须是循环的一部分。\n4. 在剩余对象上实现一个循环检测和回收程序。令 $U\\subseteq V$ 为丢弃 $R$ 后仍被分配的节点集合。对每个 $v\\in U$，定义\n$$\nc(v) = \\mathrm{rc}(v) - \\sum_{\\text{edges }(u,v)\\in E \\text{ with } u\\in U} 1.\n$$\n此处 $c(v)$ 计算的是来自 $U$ 外部对 $v$ 的引用数量。在典型的不可达循环场景中，对所有 $v\\in U$，都有 $c(v)=0$。循环回收器必须：\n- 识别子集 $C=\\{v\\in U \\mid c(v)=0\\}$。\n- 通过递减 $\\mathrm{rc}(v)$ 并将该边从考虑中移除，来断开每一条 $u\\in C$ 且 $v\\in C$ 的内部边 $(u,v)$。\n- 回收所有 $v\\in C$，确保不发生双重递减。\n\n您的程序必须构建图来为闭包到闭包的引用建模。对于每个图，它必须：\n- 初始化与 $E$ 和 $R$ 一致的 $\\mathrm{rc}$ 值。\n- 通过朴素 RC ($\\mathrm{release}$) 丢弃根。\n- 使用上述基于 $c(v)$ 的检测方法来计数和回收循环垃圾。\n\n每个测试用例的最终输出是一个整数：循环检测器在朴素 RC 已回收的基础上额外回收的闭包数量。将所有测试用例的结果汇总到一行，格式如下所述。\n\n测试套件和覆盖范围：\n- 测试用例 1 (正常路径，无循环): $n=5$，边形成一个链 $0\\to 1\\to 2\\to 3\\to 4$，根为 $R=\\{0\\}$。预期朴素 RC 会回收所有对象，因此循环检测器回收 $0$ 个。\n- 测试用例 2 (自循环边界情况): $n=1$，边为 $0\\to 0$，根为 $R=\\varnothing$。朴素 RC 不执行任何操作，循环检测器必须回收 $1$ 个。\n- 测试用例 3 (双节点循环): $n=2$，边为 $0\\to 1$，$1\\to 0$，根为 $R=\\varnothing$。循环检测器必须回收 $2$ 个。\n- 测试用例 4 (混合图，包含可达的无环部分和不可达的循环): $n=7$，边为 $0\\to 1$，$1\\to 2$，$2\\to 3$，以及循环 $4\\to 5$，$5\\to 6$，$6\\to 4$，根为 $R=\\{0,2\\}$。朴素 RC 将回收无环部分，循环检测器必须回收 $3$ 个。\n- 测试用例 5 (空图边界情况): $n=0$，边集 $E=\\varnothing$，根集 $R=\\varnothing$。循环检测器回收 $0$ 个。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots]$）。对于上述测试套件，预期的结构是 $[a_1,a_2,a_3,a_4,a_5]$，其中每个 $a_i$ 是一个整数。\n\n注意：\n- 不涉及物理单位或角度；所有输出均为纯整数。\n- 程序必须是完全自包含的，不需要任何输入，并严格遵守指定的执行环境。", "solution": "所给问题要求为一个假设的语言运行时设计并实现一个用于闭包的内存管理系统。该系统必须利用手动引用计数 (RC) 进行回收，并包含一个用于检测和回收循环垃圾的特定算法，这是朴素 RC 的一个众所周知局限性。解决方案涉及将闭包堆建模为一个有向图，并通过几个不同的阶段来模拟回收过程。\n\n### 基于原理的设计\n\n解决方案的基础在于将堆的状态表示为一个有向图 $G=(V, E)$，其中 $V$ 是已分配的闭包对象集合，而一条边 $(u,v) \\in E$ 表示闭包 $u$ 持有对闭包 $v$ 的引用。闭包被建模为序对 $\\langle f, \\rho \\rangle$，其中 $f$ 是函数指针，$\\rho$ 是环境。环境 $\\rho$ 包含了构成我们图中边 $E$ 的引用。一个称为根集合 $R \\subseteq V$ 的外部引用集合，代表由运行时系统自身持有的指向闭包的指针（例如，在执行栈上或在全局变量中）。\n\n**1. 数据结构与初始化**\n\n为了在 C 语言中对该系统建模，我们定义一个 `Closure` 结构体。每个 `Closure` 实例代表图中的一个节点，并包含其引用计数 $\\mathrm{rc}$、一个出向引用（邻居）列表，以及一个用于跟踪其回收状态的标志。\n\n每个测试用例的模拟都从一个初始化阶段开始：\n-   创建一个 `Closure` 对象数组来表示顶点集合 $V$。\n-   根据问题定义，通过对两个引用来源求和来初始化每个闭包 $v \\in V$ 的引用计数 $\\mathrm{rc}(v)$：\n    1.  **内部引用**：对于每条边 $(u, v) \\in E$，$\\mathrm{rc}(v)$ 递增。这对应于来自另一个闭包环境的引用。\n    2.  **根引用**：对于每个根 $r \\in R$，$\\mathrm{rc}(r)$ 递增。这对应于来自运行时的外部引用。\n\n这个初始化过程在进行任何回收之前，正确地建立了堆图的初始状态。\n\n**2. 阶段 1：朴素引用计数回收**\n\n第一个回收阶段模拟丢弃根集合，这反映了从一个作用域（如栈帧）中移除外部引用的情景。对于每个根 $r \\in R$，我们调用 `release(r)` 操作。此函数会递减引用计数 $\\mathrm{rc}(r)$。\n\nRC 逻辑的核心在于 `release` 函数：如果一个闭包的引用计数在递减后达到 $0$，则该闭包被认为是不可达的，可以被回收。回收时，该闭包本身被标记为已释放，并且 `release` 操作会递归地应用于它所引用的所有闭包（其在图中的邻居）。当根引用被丢弃时，这个递归过程能正确回收所有变得不可达的无环垃圾。然而，如果一组对象以循环方式相互引用，即使整个循环从根集合来看是不可达的，它们的引用计数仍将保持正数。这些对象构成了循环垃圾，并且不会被这种朴素的方法释放。\n\n**3. 阶段 2：循环检测与回收**\n\n在朴素 RC 阶段之后，存活的对象集合（我们称之为 $U \\subseteq V$）包含了所有未被释放的闭包。这个集合 $U$ 包含任何存活的、可达的对象，以及任何孤立的垃圾循环。下一步是识别并回收这些循环。\n\n问题指定了一种基于将引用划分为相对于集合 $U$ 的内部引用和外部引用的循环检测算法。对于每个存活的闭包 $v \\in U$，我们计算：\n$$\nc(v) = \\mathrm{rc}(v) - \\sum_{\\substack{(u, v) \\in E \\\\ u \\in U}} 1\n$$\n此处，$\\mathrm{rc}(v)$ 是在朴素 RC 阶段后 $v$ 的当前引用计数。求和项计算的是源自存活集合 $U$ *内部* 其他闭包对 $v$ 的引用数量。因此，$c(v)$ 表示来自 $U$ *外部* 对 $v$ 的引用数量。由于 $U$ 之外的任何对象要么是根（已被丢弃），要么已被释放，所以在丢弃根后，此模型中非零的 $c(v)$ 是不可能出现的。然而，这个公式是通用的。对于一个孤立的垃圾循环，循环中的每个成员 $v$ 都只被该循环的其他成员（它们也都在 $U$ 中）所引用。因此，所有对 $v$ 的引用都来自 $U$ 内部，其外部引用计数 $c(v)$ 将为 $0$。\n\n该算法按以下步骤进行：\n1.  **识别循环候选者**：我们构成集合 $C = \\{v \\in U \\mid c(v) = 0\\}$。这个集合 $C$ 包含了所有属于孤立垃圾结构一部分的闭包。\n2.  **断开内部引用**：为了确认可回收性，我们模拟移除所有在集合 $C$ 内部的引用。对于每一条边 $(u, v)$，其中 $u \\in C$ 且 $v \\in C$，我们递减 $\\mathrm{rc}(v)$。因为 $C$ 由没有外部引用的对象组成，此操作将导致 $C$ 中每个对象的引用计数降至 $0$。\n3.  **回收循环垃圾**：集合 $C$ 中的所有闭包现在被识别为循环垃圾，可以被回收。集合 $C$ 中的闭包数量就是该测试用例的结果，代表了由循环检测器释放的对象计数。\n\n这种两阶段方法——朴素 RC 后跟一个循环回收器——是一种经典的策略。实现过程为每个测试用例仔细遵循了这些步骤，构建指定的图，模拟回收过程，并统计由循环检测逻辑释放的对象数量，以产生最终所需的输出。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include", "id": "3668730"}]}