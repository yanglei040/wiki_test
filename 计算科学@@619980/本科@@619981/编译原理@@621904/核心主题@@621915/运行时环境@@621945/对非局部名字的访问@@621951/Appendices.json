{"hands_on_practices": [{"introduction": "让我们深入探讨编译器如何将对非局部名称的访问转换为具体的内存地址计算。本练习将引导你使用“display”数据结构，这是一种加速查找任何词法外层作用域活动记录的有效机制。通过从第一性原理出发计算精确的内存偏移量，你将对运行时内存布局和非局部变量访问的底层原理建立一个坚实的模型 [@problem_id:3620063]。", "problem": "您正在为一种具有词法作用域和 display 机制的块结构语言设计代码生成。该实现使用 display 机制，使得在访问一个在词法深度 $l$（最外层块的深度为 $0$，更深嵌套的块具有更大的深度）声明的非局部变量时，首先从 display 条目 $\\text{display}[l]$ 加载帧基地址，然后加上一个相对寻址偏移量 $\\delta$ 以形成有效地址。\n\n假设遵循以下机器和运行时约定：\n- 机器字长为 $w$ 字节，其中 $w = 8$。\n- display 条目 $\\text{display}[l]$ 指向词法深度为 $l$ 的当前活动过程的活动记录的基地址。\n- 对于一个词法深度为 $l$ 的过程，其活动记录以一个控制前缀开始，该前缀的大小（以字为单位）等于 $2 + (l+1)$。这些字包括一个保存的返回地址（$1$ 个字）、一个动态链接或调用者状态字（$1$ 个字），以及一个用于保存在进入时将被覆盖的 display 条目的区域（$l+1$ 个字）。局部变量区紧跟在该控制前缀之后。\n- 每个标量局部变量恰好占用 $1$ 个字，并被分配一个从零开始的槽索引 $s \\in \\{0,1,2,\\dots\\}$，该索引是相对于其活动记录内局部变量区的起始位置。\n\n一个当前正在执行、词法深度为 $4$ 的过程 $Q$ 需要访问以下非局部标量变量，每个变量都由其声明时的词法深度 $l$ 和在其自身活动记录的局部变量区内的槽索引 $s$ 标识：\n- 变量 $a$：$l=0$，$s=5$。\n- 变量 $b$：$l=1$，$s=3$。\n- 变量 $c$：$l=2$，$s=9$。\n- 变量 $d$：$l=0$，$s=2$。\n- 变量 $e$：$l=3$，$s=1$。\n\n您的任务：\n1. 根据 display 机制的基本原理和给定的活动记录布局，推导出一个通用表达式，用于计算在词法深度 $l$ 声明、槽索引为 $s$ 的变量的相对寻址偏移量 $\\delta$（以字节为单位），该表达式应以 $w$、$l$ 和 $s$ 表示。\n2. 使用推导出的表达式和给定的 $w$，计算 $a$、$b$、$c$、$d$ 和 $e$ 各自的 $\\delta$。\n3. 设 $S$ 为这五个偏移量的总和（即 $S = \\delta_a + \\delta_b + \\delta_c + \\delta_d + \\delta_e$）。计算 $S$，并以字节为单位，将您的最终答案表示为一个精确的整数。无需四舍五入。", "solution": "该问题要求推导一个用于在具有 display 机制的块结构语言中访问非局部变量的相对寻址偏移量 $\\delta$ 的通用公式，然后使用该公式计算一组特定变量的此类偏移量的总和。问题提法清晰，并包含了所有必要的信息。\n\n首先，我们推导在词法深度 $l$ 声明、槽索引为 $s$ 的变量的相对寻址偏移量 $\\delta$（以字节为单位）的通用表达式。访问方法是将偏移量 $\\delta$ 添加到活动记录的基地址上，该基地址由 display 条目 $\\text{display}[l]$ 提供。因此，$\\delta$ 表示变量的存储位置相对于其声明所在的活动记录起始位置的偏移量。\n\n一个词法深度为 $l$ 的过程的活动记录依次由两部分组成：一个控制前缀和一个局部变量区。总偏移量 $\\delta$ 是控制前缀的大小与变量在局部变量区内的偏移量之和。\n\n词法深度为 $l$ 的过程的控制前缀大小被指定为 $2 + (l+1)$ 个字。我们将其大小表示为字节。给定机器字长 $w$，控制前缀的大小 $P_{size}$ 为：\n$$ P_{size} = (2 + (l+1)) \\times w = (l+3)w $$\n\n局部变量区紧跟在控制前缀之后。一个标量局部变量被分配一个相对于局部变量区起始位置的、从零开始的槽索引 $s$。每个此类变量恰好占用 $1$ 个字。因此，具有槽索引 $s$ 的变量相对于局部变量区起始位置的偏移量 $L_{offset}$ 为：\n$$ L_{offset} = s \\times w $$\n\n从活动记录起始位置算起的总相对寻址偏移量 $\\delta$ 是前缀大小和局部偏移量之和：\n$$ \\delta(l, s) = P_{size} + L_{offset} = (l+3)w + sw $$\n提出因子 $w$，我们得到 $\\delta$ 的通用表达式：\n$$ \\delta(l, s) = (l + s + 3)w $$\n这个表达式用变量的声明词法深度 $l$、其槽索引 $s$ 和机器字长 $w$ 来表示。\n\n接下来，我们使用这个表达式计算每个指定变量的 $\\delta$。问题给出字长为 $w = 8$ 字节。将此值代入我们推导出的公式中，得到：\n$$ \\delta(l, s) = (l + s + 3) \\times 8 $$\n\n我们现在计算每个变量的偏移量：\n- 变量 $a$：$l=0$，$s=5$。\n  $$ \\delta_a = (0 + 5 + 3) \\times 8 = 8 \\times 8 = 64 \\text{ 字节} $$\n- 变量 $b$：$l=1$，$s=3$。\n  $$ \\delta_b = (1 + 3 + 3) \\times 8 = 7 \\times 8 = 56 \\text{ 字节} $$\n- 变量 $c$：$l=2$，$s=9$。\n  $$ \\delta_c = (2 + 9 + 3) \\times 8 = 14 \\times 8 = 112 \\text{ 字节} $$\n- 变量 $d$：$l=0$，$s=2$。\n  $$ \\delta_d = (0 + 2 + 3) \\times 8 = 5 \\times 8 = 40 \\text{ 字节} $$\n- 变量 $e$：$l=3$，$s=1$。\n  $$ \\delta_e = (3 + 1 + 3) \\times 8 = 7 \\times 8 = 56 \\text{ 字节} $$\n\n最后，我们计算这五个偏移量的总和 $S$：\n$$ S = \\delta_a + \\delta_b + \\delta_c + \\delta_d + \\delta_e $$\n代入计算出的值：\n$$ S = 64 + 56 + 112 + 40 + 56 $$\n进行求和：\n$$ S = 328 \\text{ 字节} $$\n偏移量的总和为 $328$ 字节。", "answer": "$$\\boxed{328}$$", "id": "3620063"}, {"introduction": "既然我们了解了如何访问非局部变量，下一个合乎逻辑的问题是：一个闭包应该捕获其环境中的哪些数据才最高效？本练习探讨了“环境切片”（environment slicing），这是一种旨在最小化闭包内存足迹的关键优化技术。通过对比“完全捕获”和“切片”这两种策略，你将学会量化智能捕获策略所带来的内存节省，并理解其在编译器设计中的重要性 [@problem_id:3620073]。", "problem": "一个编译器在词法作用域下实现了一等闭包，其中闭包由代码和一个环境记录组成，该环境记录包含了代码所需的非局部名称的绑定。考虑了两种环境捕获策略：完全捕获和环境切片。在完全捕获中，函数激活期间创建的每个逃逸闭包都会捕获该函数的整个词法帧。在环境切片中，一个闭包仅捕获评估其主体及其产生的任何逃逸的嵌套闭包所需的最小绑定集。\n\n使用以下基本原理来形式化环境切片：设 $FV(C)$ 表示在词法作用域下闭包 $C$ 的自由变量集合。当闭包 $C$ 不创建任何逃逸闭包时，其最小绑定集定义为 $B(C) = FV(C)$；更一般地，如果 $C$ 创建了逃逸闭包 $D_{1}, \\dots, D_{k}$，则 $B(C) = FV(C) \\cup \\bigcup_{i=1}^{k} B(D_{i})$。假设采用按值调用求值，并且下面列出的所有变量都是按值捕获的不可变标量或聚合体，其大小以字节为单位给出。假设每个逃逸闭包都分配自己的环境记录；不执行共享或闭包间分解。\n\n考虑一个程序，其中函数 $F$ 的单次激活定义了以下局部变量及其字节大小：$x$ ($8$)、$y$ ($4$)、$z$ ($24$)、$u$ ($8$)、$v$ ($4$)、$w$ ($40$) 和 $t$ ($12$)。在此激活中，创建了三个逃逸闭包 $C_{1}$、$C_{2}$ 和 $C_{3}$，其自由变量集为：\n- $FV(C_{1}) = \\{x, z, t\\}$，\n- $FV(C_{2}) = \\{y, w\\}$，\n- $FV(C_{3}) = \\{x, u, v, w\\}$。\n\n除了 $C_{1}$、$C_{2}$ 和 $C_{3}$ 之外，没有其他嵌套的逃逸闭包，并且这些闭包自身也不创建新的逃逸闭包。在完全捕获下，每个闭包的环境都包含 $F$ 的所有局部变量。在环境切片下，每个闭包的环境只精确包含其最小集 $B(C_{i})$ 中的绑定。\n\n计算在完全捕获下为这三个闭包分配的总环境内存，以及在环境切片下分配的总内存，然后以字节为单位报告这两个总和之间的差值，即大小减少量 $\\Delta S$。最终答案以字节为单位表示为精确整数。无需四舍五入。", "solution": "该问题的目标是计算并比较“完全捕获”和“环境切片”两种策略下的闭包环境总内存开销，并求出其差值。\n\n设 $S_{var}(v)$ 表示变量 $v$ 的大小（以字节为单位）。给定的变量大小如下：\n$S_{var}(x) = 8$\n$S_{var}(y) = 4$\n$S_{var}(z) = 24$\n$S_{var}(u) = 8$\n$S_{var}(v) = 4$\n$S_{var}(w) = 40$\n$S_{var}(t) = 12$\n\n**1. 完全捕获下的总内存 ($S_{full}$)**\n\n在完全捕获策略下，三个闭包（$C_1$、$C_2$ 和 $C_3$）中的每一个都捕获函数 $F$ 的整个词法帧。$F$ 的词法帧包含其所有局部变量：$\\{x, y, z, u, v, w, t\\}$。\n这个完整帧的大小，记为 $S_{frame}$，是其所有变量大小的总和：\n$$S_{frame} = S_{var}(x) + S_{var}(y) + S_{var}(z) + S_{var}(u) + S_{var}(v) + S_{var}(w) + S_{var}(t)$$\n$$S_{frame} = 8 + 4 + 24 + 8 + 4 + 40 + 12 = 100 \\text{ 字节}$$\n由于创建了三个独立的闭包，并且每个闭包都分配了如此大小的自己的环境，因此在完全捕获下分配的总内存 $S_{full}$ 为：\n$$S_{full} = 3 \\times S_{frame} = 3 \\times 100 = 300 \\text{ 字节}$$\n\n**2. 环境切片下的总内存 ($S_{slice}$)**\n\n在环境切片策略下，每个闭包仅捕获其最小绑定集 $B(C_i)$。问题陈述指出，闭包 $C_1$、$C_2$ 和 $C_3$ 不会创建任何进一步的逃逸闭包。这简化了最小绑定集的一般定义。对于任何此类闭包 $C_i$，其最小绑定集都与其自由变量集相同：\n$$B(C_i) = FV(C_i)$$\n每个闭包的环境大小 $S_{env}(C_i)$ 是其最小绑定集中变量大小的总和。\n\n对于闭包 $C_1$：\n$B(C_1) = FV(C_1) = \\{x, z, t\\}$\n$$S_{env}(C_1) = S_{var}(x) + S_{var}(z) + S_{var}(t) = 8 + 24 + 12 = 44 \\text{ 字节}$$\n\n对于闭包 $C_2$：\n$B(C_2) = FV(C_2) = \\{y, w\\}$\n$$S_{env}(C_2) = S_{var}(y) + S_{var}(w) = 4 + 40 = 44 \\text{ 字节}$$\n\n对于闭包 $C_3$：\n$B(C_3) = FV(C_3) = \\{x, u, v, w\\}$\n$$S_{env}(C_3) = S_{var}(x) + S_{var}(u) + S_{var}(v) + S_{var}(w) = 8 + 8 + 4 + 40 = 60 \\text{ 字节}$$\n\n在环境切片下分配的总内存 $S_{slice}$ 是各个环境大小的总和：\n$$S_{slice} = S_{env}(C_1) + S_{env}(C_2) + S_{env}(C_3)$$\n$$S_{slice} = 44 + 44 + 60 = 148 \\text{ 字节}$$\n\n**3. 内存大小减少量 ($\\Delta S$)**\n\n大小减少量 $\\Delta S$ 是完全捕获下分配的总内存与环境切片下分配的总内存之间的差值。\n$$\\Delta S = S_{full} - S_{slice}$$\n$$\\Delta S = 300 - 148 = 152 \\text{ 字节}$$\n对于这三个闭包，使用环境切片代替完全捕获所实现的内存使用量减少了 $152$ 字节。", "answer": "$$\\boxed{152}$$", "id": "3620073"}, {"introduction": "访问非局部名称不仅影响性能，更会深刻地影响程序的行为和正确性。本练习提出了一个经典的编程难题，它涉及到在循环内部创建的闭包。通过分析在不同“捕获”规则下的程序输出，你将深入理解捕获变量的“值”与捕获其“内存位置”（即引用）之间的本质区别——这是在现代语言中编写正确代码必须掌握的一个关键概念 [@problem_id:3620080]。", "problem": "给定一种小型的、词法作用域的、支持头等函数的语言，该语言有两种可选的闭包捕获语义。该语言采用传值调用（call-by-value），且由 let 绑定的名称表示可变位置。在标准的 for 循环中，循环变量名表示一个在每次迭代中都会被更新的单一可变位置。运行时实现了真正的闭包，因此被闭包捕获的任何位置在定义该闭包的函数返回后仍然存在。\n\n考虑下面的函数，它构建并返回一个 thunk（无参闭包）列表，这些 thunk 读取一个非局部名称；然后是一个应用点，在循环和一次中间赋值之后调用返回的闭包：\n\nfunction makeF(n):\n    res = []\n    for i = 1 to n:\n        res.push( fun() { return i } )\n    i = 99\n    return res\n\nlet fs = makeF(3)\nprint fs[0](), fs[1](), fs[2]()\n\n假设有以下精确的语义和约束：\n- 词法作用域：每个 thunk 中的自由变量 $i$ 指向创建该 thunk 的 makeF 激活记录中 $i$ 的绑定（而不是任何调用者的环境）。\n- 循环绑定模型：名称 $i$ 在循环入口处被绑定到一个单一的可变位置，每次迭代都将一个新的数值赋给同一个位置；循环后的语句 i = 99 会写入同一个位置。\n- 每个 thunk 中自由变量 $i$ 的两种闭包捕获变体：\n  1) 引用捕获（Capture-by-reference）：闭包记录了定义环境中 $i$ 所表示位置的引用；求值该 thunk 时会读取该位置当时的内容。\n  2) 值捕获（Capture-by-value）：闭包在创建时记录了 $i$ 当前数值的副本；该 thunk 求值的结果就是那个被复制的值。\n- 运行时对被捕获的位置执行逃逸安全的分配，以便当闭包的生命周期超过其定义激活记录时，不会出现悬空引用。\n\n现在再考虑以下重构，该重构在每次迭代中引入了一个新的内部绑定：\n\nfunction makeF_refactored(n):\n    res = []\n    for i = 1 to n:\n        let j = i\n        res.push( fun() { return j } )\n    i = 99\n    return res\n\nlet gs = makeF_refactored(3)\nprint gs[0](), gs[1](), gs[2]()\n\n问题：哪个选项正确地描述了这两个程序在两种捕获语义下的可观察输出，并解释了原因？请选择唯一最佳答案。\n\n选项：\n- A) 在引用捕获下，makeF 打印 $\\left(3, 3, 3\\right)$；在值捕获下，makeF 打印 $\\left(1, 2, 3\\right)$。在引用捕获下，makeF_refactored 打印 $\\left(1, 2, 3\\right)$。原因：引用捕获读取的是循环计数器的最终值，而赋值语句 $i = 99$ 发生在闭包创建之后，不会影响它们。\n\n- B) 在引用捕获下，makeF 打印 $\\left(99, 99, 99\\right)$；在值捕获下，makeF 打印 $\\left(1, 2, 3\\right)$。在引用捕获下，makeF_refactored 打印 $\\left(1, 2, 3\\right)$。原因：引用捕获共享了 $i$ 的单一位置（最后更新为 $99$），值捕获在 thunk 创建时复制了 $1$、$2$ 和 $3$，而引入 $j$ 则为每次迭代创建了一个新的位置，每个 thunk 都引用该新位置。\n\n- C) 在引用捕获下，makeF 打印 $\\left(1, 2, 3\\right)$；在值捕获下，makeF 打印 $\\left(1, 1, 1\\right)$。在引用捕获下，makeF_refactored 打印 $\\left(1, 2, 3\\right)$。原因：引用捕获在每次迭代创建闭包时冻结了值，而值捕获在调用时根据第一次迭代计算值。\n\n- D) 在引用捕获下，makeF 打印 $\\left(99, 99, 99\\right)$；在值捕获下，makeF 打印 $\\left(3, 3, 3\\right)$。在引用捕获下，makeF_refactored 打印 $\\left(99, 99, 99\\right)$。原因：值捕获在循环结束时记录循环的最终值，而引入 $j$ 不会改变所引用的位置。\n\n- E) 在引用捕获下，makeF 会导致悬空引用，因为 $i$ 是一个局部变量；在值捕获下，makeF 和 makeF_refactored 都打印 $\\left(1, 2, 3\\right)$。原因：循环变量 $i$ 位于栈上，除非被复制，否则无法被安全捕获。", "solution": "要确定正确答案，我们需要根据给定的捕获语义，分步推导每个程序片段的输出。\n\n**1. 分析 `makeF` 函数**\n\n-   **引用捕获 (Capture-by-reference)**:\n    1.  `for` 循环中的变量 `i` 表示一个**单一的可变位置**。\n    2.  在循环的每次迭代中（`i` 的值分别为 1, 2, 3），都会创建一个闭包。所有这些闭包都捕获了对**同一个**内存位置 `i` 的引用。\n    3.  循环结束后，`i` 的值为 3。\n    4.  然后，语句 `i = 99` 执行，将这个共享内存位置的值更新为 99。\n    5.  最后，当调用列表 `fs` 中的三个闭包时，它们都从这个共享位置读取当前值，因此都返回 99。\n    6.  输出: `(99, 99, 99)`。\n\n-   **值捕获 (Capture-by-value)**:\n    1.  在循环的每次迭代中，闭包被创建时，会捕获变量 `i` **当时的数值**并将其作为副本存储。\n    2.  第一个闭包捕获值 1，第二个捕获值 2，第三个捕获值 3。\n    3.  后续的 `i = 99` 语句不会影响这些已经存储在闭包内部的副本。\n    4.  当调用列表 `fs` 中的闭包时，它们分别返回各自存储的值。\n    5.  输出: `(1, 2, 3)`。\n\n**2. 分析 `makeF_refactored` 函数 (仅考虑引用捕获)**\n\n-   **引用捕获 (Capture-by-reference)**:\n    1.  在 `for` 循环的**每次迭代**中，语句 `let j = i` 都会创建一个**全新的、独立的可变位置** `j`，并将 `i` 的当前值赋给它。\n    2.  第 1 次迭代：创建一个新位置 `j` 并存入 1，然后创建一个闭包捕获对这个 `j` 的引用。\n    3.  第 2 次迭代：创建另一个新位置 `j` 并存入 2，然后创建第二个闭包捕获对这个新 `j` 的引用。\n    4.  第 3 次迭代：同理，创建第三个位置 `j` 并存入 3，第三个闭包捕获对它的引用。\n    5.  因此，`makeF_refactored` 创建了三个闭包，每个闭包都引用一个**不同**的、在循环迭代中创建的内存位置。\n    6.  循环后的 `i = 99` 语句只影响变量 `i`，与这三个独立的 `j` 位置无关。\n    7.  当调用列表 `gs` 中的闭包时，它们分别从各自引用的独立位置中读取值。\n    8.  输出: `(1, 2, 3)`。\n\n**3. 结论**\n\n综合以上分析：\n-   `makeF` (引用捕获) -> `(99, 99, 99)`\n-   `makeF` (值捕获) -> `(1, 2, 3)`\n-   `makeF_refactored` (引用捕获) -> `(1, 2, 3)`\n\n选项 B 完美地总结了这些结果及其背后的原因。", "answer": "$$\\boxed{B}$$", "id": "3620080"}]}