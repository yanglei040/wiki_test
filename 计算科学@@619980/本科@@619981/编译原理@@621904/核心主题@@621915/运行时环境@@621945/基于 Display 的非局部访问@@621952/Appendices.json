{"hands_on_practices": [{"introduction": "在程序运行时使用 Display 机制之前，编译器必须首先分析源代码的静态嵌套结构。此练习 [@problem_id:3638316] 让你扮演编译器的角色，通过遍历抽象语法树（AST）来为每次变量访问确定正确的 Display 索引。这有助于你理解编译器如何将代码的词法结构映射到运行时的寻址方案。", "problem": "一种静态作用域语言支持嵌套过程声明和词法块。编译器使用抽象语法树 (AST) 来表示程序，并使用一种基于 display 的机制进行非局部访问，其中 display $D$ 是一个指向当前活动记录 (AR) 的指针数组，通过相应作用域的静态嵌套层级进行索引。一个作用域的静态嵌套层级是指从根环境到该作用域的词法嵌套步数。编译器必须为每个标识符的出现确定一个词法深度 $h$，该深度量化了从使用点到其声明点需要在静态嵌套结构中向外移动多远。目标是通过遍历 AST 来计算 $h$，然后生成在编译时使用 $D$ 来定位标识符基地址的代码。\n\n考虑以下带有嵌套过程的程序（假设有一个单一的全局环境包含了所有顶层声明）。该程序的词法结构是：\n\n- 一个顶层过程 P，声明了一个变量 a。\n- 在 P 内部，一个嵌套过程 Q，声明了一个变量 b。\n- 在 Q 内部，一个嵌套过程 R，包含两个使用：a 和 b。\n- 在 Q 内部（但在 R 外部），一个对 a 的使用。\n- 在 P 内部（在 Q 外部），一个对 a 的使用。\n\n假设全局环境的静态嵌套层级为 $0$，过程 P 的静态嵌套层级为 $1$，过程 Q 的静态嵌套层级为 $2$，过程 R 的静态嵌套层级为 $3$。对于上述每个标识符的使用，编译器应计算出相应的词法深度 $h$ 和用于该标识符地址计算的 display $D$ 的索引（基地址 $=$ $D[\\text{index}]$ 加上标识符在其 AR 内的偏移量）。\n\n哪个选项正确地指定了一种 AST 遍历算法，用于为示例程序计算每个标识符使用的 $h$ 值，以及到 $D$ 索引的相应编译时映射？\n\nA. 遍历 AST，同时维护一个当前静态层级 $L$，从全局环境的 $0$ 开始，每进入一个新的词法作用域就加 $1$。首次遇到每个声明时，记录其层级 $L_d$。对于在一个层级为 $L_u$ 的作用域中的使用，找到最近的词法外围声明，并将 $h$ 设置为 $L_u - L_d$。生成使用 $D[L_u - h]$ 作为标识符基地址的代码。应用于该程序：在 R 中，使用 a 得到 $h = 3 - 1 = 2$，基地址为 $D[1]$；在 R 中，使用 b 得到 $h = 3 - 2 = 1$，基地址为 $D[2]$；在 Q 中，使用 a 得到 $h = 2 - 1 = 1$，基地址为 $D[1]$；在 P 中，使用 a 得到 $h = 1 - 1 = 0$，基地址为 $D[1]$。\n\nB. 遍历 AST，同时维护一个从 $1$ 开始的当前静态层级 $L$，每进入一个新作用域就加 $1$。对于一个层级为 $L_u$ 的使用，将 $h$ 设置为 $L_u - L_d$，并使用 $D[L_d + 1]$ 作为基地址。应用于该程序：在 R 中，使用 a 得到 $h = 3 - 1 = 2$，基地址为 $D[2]$；在 R 中，使用 b 得到 $h = 3 - 2 = 1$，基地址为 $D[3]$；在 Q 中，使用 a 得到 $h = 2 - 1 = 1$，基地址为 $D[2]$；在 P 中，使用 a 得到 $h = 1 - 1 = 0$，基地址为 $D[2]$。\n\nC. 遍历 AST，并为每个声明记录其层级 $L_d$。对于一个层级为 $L_u$ 的使用，计算 $h$ 为 $L_d - L_u$，并使用 $D[h]$ 作为基地址。应用于该程序：在 R 中，使用 a 得到 $h = 1 - 3 = -2$，基地址为 $D[-2]$；在 R 中，使用 b 得到 $h = 2 - 3 = -1$，基地址为 $D[-1]$；在 Q 中，使用 a 得到 $h = 1 - 2 = -1$，基地址为 $D[-1]$；在 P 中，使用 a 得到 $h = 1 - 1 = 0$，基地址为 $D[0]$。\n\nD. 不为静态层级遍历 AST；而是根据每次使用点的动态调用栈深度计算 $h$。对所有在层级 $L_u$ 使用的标识符，使用 $D[L_u]$ 作为基地址。应用于该程序：在 R 中，对 a 和 b 的使用都有基地址 $D[3]$；在 Q 中，使用 a 的基地址为 $D[2]$；在 P 中，使用 a 的基地址为 $D[1]$。\n\nE. 遍历 AST，并计算 $h$ 为 AST 中从使用节点到声明节点的唯一路径上的边数。使用 $D[h]$ 作为基地址。应用于该程序：在 R 中，使用 a 得到 $h = 2$，基地址为 $D[2]$；在 R 中，使用 b 得到 $h = 1$，基地址为 $D[1]$；在 Q 中，使用 a 得到 $h = 1$，基地址为 $D[1]$；在 P 中，使用 a 得到 $h = 0$，基地址为 $D[0]$。", "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n\n-   **语言模型**：静态作用域，支持嵌套过程声明和词法块。\n-   **编译器数据结构**：抽象语法树 (AST)，Display `D` (指向活动记录 AR 的指针数组)。\n-   **Display 索引**：`D` 通过作用域的静态嵌套层级进行索引。\n-   **静态嵌套层级定义**：从根环境到某个作用域的词法嵌套步数。\n-   **词法深度 `h` 定义**：从使用点到声明点在静态嵌套结构中向外移动的步数。\n-   **目标**：找到一个算法来计算 `h` 以及用于地址计算的相应 display 索引 (`基地址 = D[索引] + 偏移量`)。\n-   **程序结构和层级**：\n    -   全局环境：静态嵌套层级 $0$。\n    -   过程 P：静态嵌套层级 $1$，声明变量 `a`。\n    -   过程 Q (嵌套在 P 中)：静态嵌套层级 $2$，声明变量 `b`。\n    -   过程 R (嵌套在 Q 中)：静态嵌套层级 $3$。\n-   **待分析的标识符使用**：\n    1.  在 R 中使用 `a`。\n    2.  在 R 中使用 `b`。\n    3.  在 Q 中 (R 之外) 使用 `a`。\n    4.  在 P 中 (Q 之外) 使用 `a`。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题牢固地植根于为块结构、静态作用域语言进行编译器设计的既定原则。静态嵌套、活动记录以及用于处理非局部变量访问的 display 机制是计算机科学中的经典主题。该问题在科学上是合理的。\n-   **适定性**：该问题是适定的。它为所有术语（静态层级、词法深度）提供了清晰的定义，一个具体的程序结构，以及一个需要回答的特定问题。存在一个基于标准编译器算法的唯一且稳定的解决方案。\n-   **客观性**：该问题使用编译器构造领域中常见、精确、客观的技术术语进行陈述。它没有歧义或主观论断。\n-   **完整性和一致性**：该问题是自包含的。提供了有关语言语义、编译器数据结构和示例程序的所有必要信息。没有内部矛盾。\n\n### 步骤 3：结论和行动\n\n问题陈述是有效的。它提出了一个编译器理论中的标准、定义明确的问题。可以继续进行求解过程。\n\n### 基于原则的推导\n\n在具有嵌套过程的静态作用域语言中，编译器必须根据程序的词法结构来解析标识符引用。display 机制是为此进行的一种运行时优化。\n\n1.  **静态嵌套层级**：设 $L(\\text{scope})$ 表示给定作用域的静态嵌套层级。根据问题描述：\n    -   $L(\\text{global}) = 0$\n    -   $L(P) = 1$\n    -   $L(Q) = 2$\n    -   $L(R) = 3$\n\n2.  **符号表和 AST 遍历**：编译器通常对 AST 执行深度优先遍历。它维护一个符号表栈，对应于词法外围作用域链。当进入层级为 $L(S)$ 的作用域 `S` 时，会为 `S` 创建一个新的符号表。当声明变量 `x` 时，它被录入当前作用域的符号表中，其声明层级 $L_d$ 被记录为当前层级。\n\n3.  **解析标识符使用**：当在层级为 $L_u = L(U)$ 的作用域 `U` 中遇到标识符 `x` 的使用时，编译器会搜索其声明。静态作用域规则规定，搜索从 `U` 的符号表开始，如果未找到，则继续到其词法外围作用域的符号表，依此类推，直到在某个作用域 `S_d` 中找到声明。设声明层级为 $L_d = L(S_d)$。\n\n4.  **计算词法深度 `h`**：问题将 `h` 定义为从使用点到声明点向外移动的步数。这恰好是使用作用域和声明作用域的静态嵌套层级之差。\n    $$h = L_u - L_d$$\n    局部变量的 $h=0$，因为 $L_u = L_d$。非局部变量的 $h > 0$。\n\n5.  **使用 Display `D`**：display `$D$` 是一个指针数组。在运行时，当作用域 `U` 内的代码执行时，`$D[i]$` 持有指向静态嵌套层级为 $i$ 的最近调用的过程的活动记录 (AR) 的指针。要访问在层级 $L_d$ 声明的变量 `x`，程序必须找到 `x` 所在作用域的 AR 的基地址。这个 AR 对应于静态层级 $L_d$。因此，正确的指针存储在 `$D[L_d]$` 中。display 的索引就是声明层级 $L_d$。\n\n6.  **将 Display 索引与 `h` 关联**：我们有两个关键方程：\n    -   $h = L_u - L_d$\n    -   $\\text{index} = L_d$\n    我们可以用 $L_u$ 和 $h$ 来表示索引。根据第一个方程，$L_d = L_u - h$。将此代入第二个方程可得：\n    $$\\text{index} = L_u - h$$\n    所以，对于一个在层级 $L_u$ 使用、词法深度为 $h$ 的变量，其地址计算为 `基地址 = D[L_u - h] + 偏移量`。\n\n### 应用于示例程序\n\n让我们将这些原则应用于给定的使用情况。\n\n-   `a` 的声明在 P 中，所以 $L_d(a) = 1$。\n-   `b` 的声明在 Q 中，所以 $L_d(b) = 2$。\n\n1.  **在 R 中使用 `a`**：\n    -   使用层级 $L_u = 3$。声明层级 $L_d = 1$。\n    -   词法深度 $h = L_u - L_d = 3 - 1 = 2$。\n    -   Display 索引 = $L_d = 1$。（验证：$L_u - h = 3 - 2 = 1$）。\n    -   基地址访问：`$D[1]$`。\n\n2.  **在 R 中使用 `b`**：\n    -   使用层级 $L_u = 3$。声明层级 $L_d = 2$。\n    -   词法深度 $h = L_u - L_d = 3 - 2 = 1$。\n    -   Display 索引 = $L_d = 2$。（验证：$L_u - h = 3 - 1 = 2$）。\n    -   基地址访问：`$D[2]$`。\n\n3.  **在 Q 中使用 `a`**：\n    -   使用层级 $L_u = 2$。声明层级 $L_d = 1$。\n    -   词法深度 $h = L_u - L_d = 2 - 1 = 1$。\n    -   Display 索引 = $L_d = 1$。（验证：$L_u - h = 2 - 1 = 1$）。\n    -   基地址访问：`$D[1]$`。\n\n4.  **在 P 中使用 `a`**：\n    -   使用层级 $L_u = 1$。声明层级 $L_d = 1$。\n    -   词法深度 $h = L_u - L_d = 1 - 1 = 0$。\n    -   Display 索引 = $L_d = 1$。（验证：$L_u - h = 1 - 0 = 1$）。\n    -   基地址访问：`$D[1]$`。\n\n### 逐个选项分析\n\n**A. 遍历 AST，同时维护一个当前静态层级 $L$，从全局环境的 $0$ 开始，每进入一个新的词法作用域就加 $1$。首次遇到每个声明时，记录其层级 $L_d$。对于在一个层级为 $L_u$ 的作用域中的使用，找到最近的词法外围声明，并将 $h$ 设置为 $L_u - L_d$。生成使用 $D[L_u - h]$ 作为标识符基地址的代码。应用于该程序：在 R 中，使用 a 得到 $h = 3 - 1 = 2$，基地址为 $D[1]$；在 R 中，使用 b 得到 $h = 3 - 2 = 1$，基地址为 $D[2]$；在 Q 中，使用 a 得到 $h = 2 - 1 = 1$，基地址为 $D[1]$；在 P 中，使用 a 得到 $h = 1 - 1 = 0$，基地址为 $D[1]$。**\n\n-   **算法**：所描述的计算 $h$ 为 $L_u - L_d$ 并使用 display 索引 $L_u - h$ 的算法与我们的推导完全一致。\n-   **应用**：\n    -   在 R 中使用 `a`：$h=3-1=2$，索引=$3-2=1$。基地址 `$D[1]$`。与我们的计算相符。\n    -   在 R 中使用 `b`：$h=3-2=1$，索引=$3-1=2$。基地址 `$D[2]$`。与我们的计算相符。\n    -   在 Q 中使用 `a`：$h=2-1=1$，索引=$2-1=1$。基地址 `$D[1]$`。与我们的计算相符。\n    -   在 P 中使用 `a`：$h=1-1=0$，索引=$1-0=1$。基地址 `$D[1]$`。与我们的计算相符。\n-   **结论**：**正确**。\n\n**B. 遍历 AST，同时维护一个从 $1$ 开始的当前静态层级 $L$，每进入一个新作用域就加 $1$。对于一个层级为 $L_u$ 的使用，将 $h$ 设置为 $L_u - L_d$，并使用 $D[L_d + 1]$ 作为基地址。应用于该程序：在 R 中，使用 a 得到 $h = 3 - 1 = 2$，基地址为 $D[2]$；在 R 中，使用 b 得到 $h = 3 - 2 = 1$，基地址为 $D[3]$；在 Q 中，使用 a 得到 $h = 2 - 1 = 1$，基地址为 $D[2]$；在 P 中，使用 a 得到 $h = 1 - 1 = 0$，基地址为 $D[2]$。**\n\n-   **算法**：display 索引的公式 `$D[L_d + 1]$` 是不正确的。display 是直接按声明的静态嵌套层级 $L_d$ 索引的。`$+\\ 1$` 项没有根据。\n-   **应用**：对于在 R 中使用 `a`，$L_d=1$。基地址将是 `$D[1+1] = D[2]$`。我们正确的计算结果是 `$D[1]$`。因此应用是错误的。\n-   **结论**：**错误**。\n\n**C. 遍历 AST，并为每个声明记录其层级 $L_d$。对于一个层级为 $L_u$ 的使用，计算 $h$ 为 $L_d - L_u$，并使用 $D[h]$ 作为基地址。应用于该程序：在 R 中，使用 a 得到 $h = 1 - 3 = -2$，基地址为 $D[-2]$；在 R 中，使用 b 得到 $h = 2 - 3 = -1$，基地址为 $D[-1]$；在 Q 中，使用 a 得到 $h = 1 - 2 = -1$，基地址为 $D[-1]$；在 P 中，使用 a 得到 $h = 1 - 1 = 0$，基地址为 $D[0]$。**\n\n-   **算法**：`h` 定义为 $L_d - L_u$ 是颠倒的。词法深度是外围作用域的非负计数。该公式对于非局部访问会产生负值。使用负值 `h` 作为数组索引，例如 `$D[-2]$`，是无效的。\n-   **应用**：示例计算证实了这个缺陷，得出了负数索引。\n-   **结论**：**错误**。\n\n**D. 不为静态层级遍历 AST；而是根据每次使用点的动态调用栈深度计算 $h$。对所有在层级 $L_u$ 使用的标识符，使用 $D[L_u]$ 作为基地址。应用于该程序：在 R 中，对 a 和 b 的使用都有基地址 $D[3]$；在 Q 中，使用 a 的基地址为 $D[2]$；在 P 中，使用 a 的基地址为 $D[1]$。**\n\n-   **算法**：这描述的是动态作用域（“根据动态调用栈深度计算 h”），这与问题的前提（静态作用域语言）直接矛盾。此外，对所有变量使用 `$D[L_u]$` 作为基地址意味着所有变量都局限于当前作用域，这违背了非局部访问的目的。\n-   **应用**：对于静态作用域语言，所提议的逻辑从根本上是有缺陷的。\n-   **结论**：**错误**。\n\n**E. 遍历 AST，并计算 $h$ 为 AST 中从使用节点到声明节点的唯一路径上的边数。使用 $D[h]$ 作为基地址。应用于该程序：在 R 中，使用 a 得到 $h = 2$，基地址为 $D[2]$；在 R 中，使用 b 得到 $h = 1$，基地址为 $D[1]$；在 Q 中，使用 a 得到 $h = 1$，基地址为 $D[1]$；在 P 中，使用 a 得到 $h = 0$，基地址为 $D[0]$。**\n\n-   **算法**：display `$D$` 是按绝对静态嵌套层级索引的，而不是按相对词法深度 `h`。使用 `$D[h]$` 是一个根本性的误解。对于一个局部变量，$h=0$，该算法将使用 `$D[0]$`（全局 AR），这是不正确的。局部变量位于当前的 AR 中，由 `$D[L_u]$` 指向。\n-   **应用**：让我们检查在 P 中使用 `a` 的情况。这是一个局部变量，所以 $h=0$。该选项声称基地址是 `$D[0]``$。这是错误的。变量 `a` 在 P (层级 $1$) 中声明，所以它的数据在 P 的 AR 中，该 AR 由 `$D[1]$` 指向。\n-   **结论**：**错误**。", "answer": "$$\\boxed{A}$$", "id": "3638316"}, {"introduction": "编译器的每一个设计决策都会带来性能上的影响。本练习 [@problem_id:3638318] 将带你从“如何实现”深入到“成本多高”，通过构建一个简洁而有效的成本模型来量化开销。你将计算 Display 操作所消耗的总 CPU 周期，从而揭示访问频率和更新开销之间的权衡关系。", "problem": "一个用于块结构语言的编译器使用 display 来实现非局部变量访问。display 是一个按静态词法层级索引的数组，用于存储每个层级最新的活动记录（AR）指针。在进入静态层级为 $h$ 的过程时，运行时系统会保存在索引 $h$ 处的旧 display 条目并安装新的 AR 指针，在过程退出时则恢复已保存的条目。假设每次这样的 display 更新写入操作成本为 $c_{\\text{update}}$ 中央处理器（CPU）周期。从当前活动记录发起的、目标为层级 $h$ 声明的非局部变量访问，会读取索引 $h$ 处的 display 条目以获取寻址的基地址；假设此 display 读取操作成本为 $c_{\\text{load}}$ CPU 周期。忽略所有其他成本（如算术和数据内存访问），仅关注 display 的读取和写入操作。\n\n假设一个特定程序运行一次，动态插桩在整个运行过程中得出以下聚合计数：\n- 对于每个层级 $h \\in \\{0,1,\\dots,H\\}$，目标为层级 $h$ 声明的非局部访问总次数为 $A_h$。\n- 对于每个层级 $h \\in \\{0,1,\\dots,H\\}$，在索引 $h$ 处执行的 display 更新操作总次数（计算了过程进入和退出）为 $U_h$。\n\n从“一个机制的总成本等于所有不同事件类型的单位事件成本与事件频率乘积之和”这一基本成本核算原则出发，推导出一个符号表达式，用 $\\{A_h\\}$、$\\{U_h\\}$、$c_{\\text{load}}$、$c_{\\text{update}}$ 和 $H$ 来表示整个执行过程中与 display 相关的总成本。然后，使用以下具体数据计算这个总成本：\n- $H = 4$,\n- $c_{\\text{load}} = 3$ 周期,\n- $c_{\\text{update}} = 7$ 周期,\n- $\\{A_h\\}_{h=0}^{4} = \\{1500, 600, 240, 90, 20\\}$,\n- $\\{U_h\\}_{h=0}^{4} = \\{2, 400, 260, 120, 40\\}$。\n\n将最终总成本表示为以周期为单位的单个数字。无需四舍五入。", "solution": "用户希望我解决以下问题。\n\n### 第一步：提取已知条件\n- 编译器使用 display（一个按静态词法层级索引的数组）来进行非局部变量访问。\n- 一次 display 更新操作（写入）的成本是 $c_{\\text{update}}$ CPU 周期。\n- 一次用于非局部访问的 display 读取操作的成本是 $c_{\\text{load}}$ CPU 周期。\n- 对于每个静态词法层级 $h \\in \\{0, 1, \\dots, H\\}$，目标为层级 $h$ 声明的非局部访问总次数是 $A_h$。\n- 对于每个静态词法层级 $h \\in \\{0, 1, \\dots, H\\}$，在索引 $h$ 处执行的 display 更新操作总次数是 $U_h$。\n- 成本核算原则指出，总成本是所有不同事件类型的“单位事件成本”与“事件频率”乘积之和。\n- 任务是推导与 display 相关的总成本的符号表达式，然后为以下具体数据计算其值：\n- $H = 4$\n- $c_{\\text{load}} = 3$ 周期\n- $c_{\\text{update}} = 7$ 周期\n- $\\{A_h\\}_{h=0}^{4} = \\{1500, 600, 240, 90, 20\\}$\n- $\\{U_h\\}_{h=0}^{4} = \\{2, 400, 260, 120, 40\\}$\n\n### 第二步：使用提取的已知条件进行验证\n该问题具有科学依据，因为它描述了编译器运行时系统中用于管理块结构语言作用域的标准 display 机制。其成本模型是为性能分析而设的一个简化但有效的抽象。问题提法清晰，提供了计算唯一解所需的所有数据和定义。术语精确客观，属于编译器设计领域。数值是合理的。该问题不违反任何无效性标准。\n\n### 第三步：结论与行动\n问题有效。我将继续进行解答。\n\n问题要求计算与 display 操作相关的总成本，这可以分解为两种不同的事件类型：用于非局部变量访问的 display 读取操作和用于过程进入与退出的 display 写入操作。我们将遵循所提供的成本核算原则，计算每种事件类型的总成本并将它们相加。\n\n设 $C_{\\text{total}}$ 为与 display 相关的总成本。它等于所有 display 读取的总成本 $C_{\\text{load}}$ 和所有 display 写入（更新）的总成本 $C_{\\text{update}}$ 之和。\n$$\nC_{\\text{total}} = C_{\\text{load}} + C_{\\text{update}}\n$$\n\n首先，我们计算 display 读取的总成本 $C_{\\text{load}}$。\n单次 display 读取操作的成本为 $c_{\\text{load}}$。问题指出，对于从 $0$ 到 $H$ 的每个词法层级 $h$，有 $A_h$ 次非局部访问以该层级为目标。每次这样的访问都需要一次 display 读取。因此，display 读取的总次数是所有层级上 $A_h$ 的总和。\n目标为层级 $h$ 的访问总成本为 $A_h \\cdot c_{\\text{load}}$。\n对从 $h=0$ 到 $h=H$ 的所有层级求和，得到 display 读取的总成本：\n$$\nC_{\\text{load}} = \\sum_{h=0}^{H} A_h \\cdot c_{\\text{load}}\n$$\n由于 $c_{\\text{load}}$ 是一个常数，可以将其从求和中提取出来：\n$$\nC_{\\text{load}} = c_{\\text{load}} \\left( \\sum_{h=0}^{H} A_h \\right)\n$$\n\n接下来，我们计算 display 更新的总成本 $C_{\\text{update}}$。\n单次 display 更新操作的成本为 $c_{\\text{update}}$。问题提供了 $U_h$ 作为在 display 索引 $h$ 处执行的更新操作总次数。\n在层级 $h$ 更新的总成本为 $U_h \\cdot c_{\\text{update}}$。\n对从 $h=0$ 到 $h=H$ 的所有层级求和，得到 display 更新的总成本：\n$$\nC_{\\text{update}} = \\sum_{h=0}^{H} U_h \\cdot c_{\\text{update}}\n$$\n同样地，$c_{\\text{update}}$ 可以被提取出来：\n$$\nC_{\\text{update}} = c_{\\text{update}} \\left( \\sum_{h=0}^{H} U_h \\right)\n$$\n\n将这两个部分组合起来，得到总成本的符号表达式：\n$$\nC_{\\text{total}} = c_{\\text{load}} \\left( \\sum_{h=0}^{H} A_h \\right) + c_{\\text{update}} \\left( \\sum_{h=0}^{H} U_h \\right)\n$$\n这就是所要求的符号表达式。\n\n现在，我们使用提供的具体数据来评估这个表达式。\n给定的值为：\n- $H = 4$\n- $c_{\\text{load}} = 3$\n- $c_{\\text{update}} = 7$\n- $\\{A_h\\}_{h=0}^{4} = \\{1500, 600, 240, 90, 20\\}$\n- $\\{U_h\\}_{h=0}^{4} = \\{2, 400, 260, 120, 40\\}$\n\n首先，我们计算非局部访问的总次数，即总和 $\\sum_{h=0}^{4} A_h$：\n$$\n\\sum_{h=0}^{4} A_h = A_0 + A_1 + A_2 + A_3 + A_4 = 1500 + 600 + 240 + 90 + 20\n$$\n$$\n\\sum_{h=0}^{4} A_h = 2450\n$$\n\n接下来，我们计算 display 更新的总次数，即总和 $\\sum_{h=0}^{4} U_h$：\n$$\n\\sum_{h=0}^{4} U_h = U_0 + U_1 + U_2 + U_3 + U_4 = 2 + 400 + 260 + 120 + 40\n$$\n$$\n\\sum_{h=0}^{4} U_h = 822\n$$\n\n现在，我们将这些总和以及成本常数代入总成本公式中：\n$$\nC_{\\text{total}} = c_{\\text{load}} \\cdot (2450) + c_{\\text{update}} \\cdot (822)\n$$\n$$\nC_{\\text{total}} = 3 \\cdot 2450 + 7 \\cdot 822\n$$\n让我们分别计算每一项：\n$$\n3 \\cdot 2450 = 7350\n$$\n$$\n7 \\cdot 822 = 5754\n$$\n最后，我们将两项相加，得到以 CPU 周期为单位的总成本：\n$$\nC_{\\text{total}} = 7350 + 5754 = 13104\n$$\n在整个执行过程中，与 display 相关的总成本为 $13104$ CPU 周期。", "answer": "$$\n\\boxed{13104}\n$$", "id": "3638318"}, {"introduction": "为了实现最佳性能，编译器必须根据目标机器的体系结构做出明智的权衡。这最后一个练习 [@problem_id:3638307] 将你置于性能工程师的角色，去决定为 Display 保留多少硬件寄存器。这个任务要求你在寄存器访问的速度与通用寄存器所增加的压力之间取得平衡，这是一个经典的优化挑战。", "problem": "在静态作用域语言中，非局部变量通过活动记录的display来访问。display是一个指向词法外层过程的帧指针数组，其中词法深度为 $\\ell$ 的条目允许以常数时间访问该深度的变量。一个面向具有 $R$ 个架构寄存器的机器的编译器可以选择性地保留一些寄存器来存放display条目，以减少非局部访问延迟，但代价是增加了通用值的寄存器压力。当同时活跃的通用值的平均数量超过可用于存放它们的寄存器数量时，就会发生溢出（spilling）；每单位溢出会为每条指令带来预期的惩罚。\n\n考虑一个display深度较小（$d = 3$）的程序。您可以为display条目保留整数个寄存器 $k$，其中 $0 \\leq k \\leq d$，这些寄存器始终存放 $k$ 个最常需要的display条目（假设是 $k$ 个最顶层的词法层级）。机器有 $R = 16$ 个寄存器。程序每条指令的平均通用活跃值需求为 $W = 14$ 个寄存器。每条指令每单位寄存器短缺会产生 $c_s = 3$ 个周期的预期溢出惩罚。非局部变量访问以每条指令 $f = 0.2$ 的频率发生，并且非局部访问的词法深度在 $d$ 个可能的层级上均匀分布。如果所需的display条目位于保留寄存器中，其成本可以忽略不计；否则，从内存加载display条目的成本为 $M = 25$ 个周期。\n\n假设以下简单模型：\n- 每条指令的预期非局部访问成本是 $f$ 乘以在均匀深度下、给定 $k$ 个保留display条目时单次非局部访问的预期成本。\n- 每条指令的溢出惩罚是 $c_s$ 乘以短缺量，其中短缺量为 $\\max\\{0,\\, W - (R - k)\\}$。\n- 在稳态下，所有事件在指令间是独立的。\n\n从第一性原理出发，推导一个表示每条指令预期周期数作为 $k$ 的函数的表达式，并确定整数 $k \\in \\{0,1,2,3\\}$ 中使此预期成本最小化的值。仅报告最优的 $k$ 作为您的最终答案。无需四舍五入。", "solution": "用户希望我解决这个问题。我必须先验证它。\n\n### 第1步：提取已知条件\n- display深度: $d = 3$\n- 为display条目保留的寄存器数量: $k$，一个整数，满足 $0 \\leq k \\leq d$\n- 总架构寄存器数: $R = 16$\n- 每条指令的平均通用活跃值需求: $W = 14$\n- 每条指令每单位寄存器短缺的溢出惩罚: $c_s = 3$ 个周期\n- 每条指令的非局部变量访问频率: $f = 0.2$\n- 从内存加载display条目的成本: $M = 25$ 个周期\n- 非局部访问的词法深度在 $d$ 个可能的层级上均匀分布。\n- $k$ 个保留寄存器存放 $k$ 个最顶层词法层级的条目。\n- 每条指令的预期非局部访问成本是 $f$ 乘以单次非局部访问的预期成本。\n- 每条指令的溢出惩罚是 $c_s$ 乘以短缺量，其中短缺量为 $\\max\\{0, W - (R - k)\\}$。\n\n### 第2步：使用提取的已知条件进行验证\n1.  **科学依据**：该问题描述了编译器设计中一个经典的权衡问题，即为特殊用途数据结构（如display）分配寄存器与为通用值分配寄存器之间的权衡。该模型虽然简化，但基于静态作用域、活动记录和寄存器压力的既定原则。溢出成本和内存访问延迟的概念是编译代码性能分析的基础。该问题在科学上是合理的。\n2.  **良构性**：该问题要求在有限集合 $\\{0, 1, 2, 3\\}$ 中找到整数 $k$ 的值，以最小化一个明确定义的成本函数。由于定义域是有限的，最小值的存在得到保证。构建和评估成本函数所需的所有参数都已提供，确保可以确定唯一的解。\n3.  **客观性**：问题使用精确、定量的语言陈述。所有计算成本的模型都已明确给出，没有主观解释的余地。\n4.  **不完整或矛盾的设定**：问题是自洽的，提供了所有必要的数据和定义，没有矛盾之处。\n5.  **不切实际或不可行**：所提供的数值（$R=16$, $W=14$ 等）对于一个真实处理器和程序的简化模型来说，处于一个合理的范围内。\n6.  **病态或结构不良**：问题结构清晰，要求进行特定的优化。逻辑简单明了。\n7.  **伪深刻、琐碎或同义反复**：该问题需要仔细推导和比较成本，代表一个真正的优化问题，而非简单的练习。\n8.  **无法科学验证**：结果可通过数学计算推导得出，因此是可验证的。\n\n### 第3步：结论与行动\n问题有效。我将继续进行解答。\n\n目标是找到整数 $k \\in \\{0, 1, 2, 3\\}$，以最小化每条指令的总预期成本 $C(k)$。该总成本是每条指令的预期溢出惩罚 $C_{\\text{spill}}(k)$ 与每条指令的预期非局部访问成本 $C_{\\text{nonlocal}}(k)$ 之和。\n$$C(k) = C_{\\text{spill}}(k) + C_{\\text{nonlocal}}(k)$$\n\n首先，我们推导溢出惩罚的表达式 $C_{\\text{spill}}(k)$。\n架构寄存器的总数是 $R = 16$。如果为display保留了 $k$ 个寄存器，则可用于通用值的寄存器数量为 $R - k$。\n通用寄存器的平均需求为 $W = 14$。如果此需求超过可用供给，则会发生寄存器短缺。\n短缺量 $S(k)$ 定义为：\n$$S(k) = \\max\\{0, W - (R - k)\\}$$\n代入给定值 $W = 14$ 和 $R = 16$：\n$$S(k) = \\max\\{0, 14 - (16 - k)\\} = \\max\\{0, 14 - 16 + k\\} = \\max\\{0, k - 2\\}$$\n每条指令的溢出惩罚是短缺量乘以每单位短缺的成本 $c_s = 3$。\n$$C_{\\text{spill}}(k) = c_s \\cdot S(k) = 3 \\cdot \\max\\{0, k - 2\\}$$\n\n接下来，我们推导非局部访问成本的表达式 $C_{\\text{nonlocal}}(k)$。\n非局部访问以每条指令 $f = 0.2$ 的频率发生。此类访问的成本取决于所需的display条目是在寄存器中还是在内存中。\ndisplay深度为 $d = 3$。非局部访问的词法深度在 $d$ 个层级上均匀分布。访问任何特定层级的概率为 $\\frac{1}{d} = \\frac{1}{3}$。\n$k$ 个保留寄存器存放 $k$ 个最顶层词法层级（层级 $1, 2, \\dots, k$）的display条目。访问这些层级之一的成本为 $0$。\n剩下的 $d-k$ 个层级不在寄存器中。访问这些层级之一（层级 $k+1, \\dots, d$）需要从内存加载display条目，成本为 $M = 25$ 个周期。\n给定一次非局部访问是访问其条目在寄存器中的层级的概率是 $\\frac{k}{d}$。\n给定一次非局部访问是访问其条目在内存中的层级的概率是 $\\frac{d-k}{d}$。\n单次非局部访问的预期成本 $E_{\\text{access}}(k)$ 是：\n$$E_{\\text{access}}(k) = \\left(\\frac{k}{d}\\right) \\cdot 0 + \\left(\\frac{d-k}{d}\\right) \\cdot M = \\frac{d-k}{d} M$$\n每条指令的预期非局部访问成本是该值乘以非局部访问的频率 $f$。\n$$C_{\\text{nonlocal}}(k) = f \\cdot E_{\\text{access}}(k) = f \\cdot M \\cdot \\frac{d-k}{d}$$\n代入给定值 $f = 0.2$、$M = 25$ 和 $d = 3$：\n$$C_{\\text{nonlocal}}(k) = 0.2 \\cdot 25 \\cdot \\frac{3-k}{3} = 5 \\cdot \\frac{3-k}{3}$$\n\n现在我们可以写出总成本函数 $C(k)$：\n$$C(k) = 3 \\cdot \\max\\{0, k - 2\\} + 5 \\cdot \\frac{3-k}{3}$$\n我们必须对定义域 $\\{0, 1, 2, 3\\}$ 中的每个可能的整数 $k$ 值评估此函数。\n\n对于 $k = 0$：\n$$C(0) = 3 \\cdot \\max\\{0, 0 - 2\\} + 5 \\cdot \\frac{3-0}{3} = 3 \\cdot 0 + 5 \\cdot \\frac{3}{3} = 0 + 5 = 5$$\n\n对于 $k = 1$：\n$$C(1) = 3 \\cdot \\max\\{0, 1 - 2\\} + 5 \\cdot \\frac{3-1}{3} = 3 \\cdot 0 + 5 \\cdot \\frac{2}{3} = 0 + \\frac{10}{3} \\approx 3.33$$\n\n对于 $k = 2$：\n$$C(2) = 3 \\cdot \\max\\{0, 2 - 2\\} + 5 \\cdot \\frac{3-2}{3} = 3 \\cdot 0 + 5 \\cdot \\frac{1}{3} = 0 + \\frac{5}{3} \\approx 1.67$$\n\n对于 $k = 3$：\n$$C(3) = 3 \\cdot \\max\\{0, 3 - 2\\} + 5 \\cdot \\frac{3-3}{3} = 3 \\cdot 1 + 5 \\cdot \\frac{0}{3} = 3 + 0 = 3$$\n\n我们比较每个 $k$ 值的总成本：\n$C(0) = 5 = \\frac{15}{3}$\n$C(1) = \\frac{10}{3}$\n$C(2) = \\frac{5}{3}$\n$C(3) = 3 = \\frac{9}{3}$\n\n最小成本是 $\\frac{5}{3}$，出现在 $k=2$ 时。因此，为display保留 $k=2$ 个寄存器可以最小化每条指令的总预期周期数。", "answer": "$$\\boxed{2}$$", "id": "3638307"}]}