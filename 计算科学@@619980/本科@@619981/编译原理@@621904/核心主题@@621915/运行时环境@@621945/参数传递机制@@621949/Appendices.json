{"hands_on_practices": [{"introduction": "为了真正掌握不同的参数传递机制，我们必须通过具体的例子来追踪它们的行为。这个练习 [@problem_id:3661405] 将探讨一个核心问题：当同一个变量作为多个参数传递给一个函数时会发生什么？通过细致地追踪传值、传引用、传结果以及复制-传入/复制-传出这四种机制下的内存状态变化，你将深入理解别名（aliasing）和副作用的微妙之处，为后续更复杂的场景打下坚实的基础。", "problem": "考虑一个微小、确定性的、采用过程调用（call-by-procedure）的语言，该语言具有整型变量和以下语义。函数调用根据指定的参数传递机制将实际参数绑定到形式参数。语句按程序顺序执行。在赋值语句 $x := E$ 中，表达式 $E$ 使用其变量的当前值进行求值，然后将结果写入由 $x$ 命名的位置。除了参数传递机制提供的绑定之外，没有别名分析。四种参数传递机制定义如下，并应作为您推理的基础：\n\n- 按值传递（Pass-by-value）：在调用入口处，每个形式参数接收相应实际参数值的副本；形式参数是独立的局部变量；对形式参数的修改不影响调用者的变量。\n- 按引用传递（Pass-by-reference）：每个形式参数成为相应实际参数存储位置的别名；如果为多个形式参数提供了相同的实际变量，则这些形式参数会别名到同一位置；所有的读写操作都直接反映并修改调用者的变量。\n- 按结果传递（Pass-by-result）：在调用入口处，每个形式参数是一个独立的未初始化局部变量；在整个调用过程中，形式参数是独立的局部变量；在调用出口处，形式参数的最终值按从左到右的顺序复制回相应实际参数的存储位置。\n- 复制传入/复制传出（Copy-in/copy-out，也称按值-结果传递）：在调用入口处，每个形式参数接收其相应实际参数值的副本；在调用期间，形式参数是独立的局部变量；在调用出口处，形式参数的最终值按从左到右的顺序复制回相应实际参数的存储位置。\n\n假设表达式使用标准整数算术，并且上面提到的从左到右的顺序是在调用出口处执行复制返回的实际顺序。\n\n程序片段如下：\n- 调用者中的初始状态：变量 $a$ 的值为 $a = 5$。\n- 函数定义：$f(u,v)$ 的函数体由按顺序执行的三个语句组成：\n  $u := 3$;\n  $v := u + 4$;\n  $u := v + 5$。\n- 调用点：调用者执行 $f(a,a)$。\n\n设 $V_{\\mathrm{val}}$ 为在按值传递下调用后 $a$ 的最终值；设 $V_{\\mathrm{ref}}$ 为在按引用传递下调用后 $a$ 的最终值；设 $V_{\\mathrm{res}}$ 为在按结果传递（从左到右复制返回）下调用后 $a$ 的最终值；设 $V_{\\mathrm{cio}}$ 为在复制传入/复制传出（从左到右复制返回）下调用后 $a$ 的最终值。\n\n计算单个量\n$$S \\;=\\; V_{\\mathrm{val}} \\;+\\; V_{\\mathrm{ref}} \\;+\\; V_{\\mathrm{res}} \\;+\\; V_{\\mathrm{cio}}.$$\n提供 $S$ 的精确整数值。不需要四舍五入。", "solution": "问题陈述已经过严格验证，并被认为是有效的。这是一个在计算机科学领域内，特别是在编程语言语义和编译器原理方面，定义良好的问题。参数传递机制的定义清晰、自洽且一致。初始条件和程序片段的规定没有歧义。因此，可以构建一个合理的解决方案。\n\n该问题要求我们在四种不同的参数传递机制下跟踪函数调用 $f(a,a)$ 的执行，并确定在每种情况下调用者作用域中变量 $a$ 的最终值。给定 $a$ 的初始值为 $a=5$。函数 $f(u,v)$ 的函数体为：\n1. $u := 3$;\n2. $v := u + 4$;\n3. $u := v + 5$;\n\n让我们依次分析每种机制。\n\n### 按值传递 ($V_{\\mathrm{val}}$)\n根据定义，形式参数接收实际参数值的副本。形式参数是函数作用域内的局部变量，对它们的任何修改都不会影响调用者的变量。\n\n1.  **调用入口：** 创建局部变量 $u$ 和 $v$。实际参数 $a$ 的值（为 $5$）被复制到 $u$ 和 $v$ 中。因此，函数内部的初始状态为 $u=5$ 和 $v=5$。调用者的变量 $a$ 在其位置上保持值 $5$，与 $u$ 和 $v$ 完全分离。\n2.  **$f(u,v)$ 的执行：**\n    - 语句 1：$u := 3$。局部变量 $u$ 更新为 $3$。状态：$u=3$, $v=5$。调用者的 $a$ 不受影响，仍为 $5$。\n    - 语句 2：$v := u + 4$。表达式 $u+4$ 求值为 $3+4=7$。此结果赋给局部变量 $v$。状态：$u=3, v=7$。调用者的 $a$ 不受影响。\n    - 语句 3：$u := v + 5$。表达式 $v+5$ 求值为 $7+5=12$。此结果赋给局部变量 $u$。状态：$u=12, v=7$。调用者的 $a$ 不受影响。\n3.  **调用出口：** 函数返回。局部变量 $u$ 和 $v$ 被销毁。没有值被复制回调用者。\n4.  **最终值：** 在整个调用过程中，调用者的变量 $a$ 从未被修改。其值保持为 $5$。\n因此，$V_{\\mathrm{val}} = 5$。\n\n### 按引用传递 ($V_{\\mathrm{ref}}$)\n根据定义，形式参数成为相应实际参数存储位置的别名。由于调用是 $f(a,a)$，形式参数 $u$ 和 $v$ 都成为同一存储位置（即变量 $a$ 的存储位置）的别名。对 $u$ 或 $v$ 的任何读写都直接影响变量 $a$。\n\n1.  **调用入口：** $u$ 和 $v$ 都引用 $a$ 的位置。最初，该位置的值为 $5$。\n2.  **$f(u,v)$ 的执行：**\n    - 语句 1：$u := 3$。此赋值修改了由 $u$ 别名的位置，也就是 $a$ 的位置。$a$ 的值变为 $3$。\n    - 语句 2：$v := u + 4$。表达式读取 $u$ 的值并加 $4$。由于 $u$ 和 $v$ 都别名到 $a$，这等同于 $a := a + 4$。$a$ 的当前值为 $3$，所以表达式求值为 $3+4=7$。此结果被写入由 $v$ 别名的位置，也就是 $a$ 的位置。$a$ 的值变为 $7$。\n    - 语句 3：$u := v + 5$。这等同于 $a := a + 5$。$a$ 的当前值为 $7$，所以表达式求值为 $7+5=12$。此结果被写入由 $u$ 别名的位置，也就是 $a$ 的位置。$a$ 的值变为 $12$。\n3.  **调用出口：** 别名 $u$ 和 $v$ 不再存在。\n4.  **最终值：** 调用者变量 $a$ 的最终值为 $12$。\n因此，$V_{\\mathrm{ref}} = 12$。\n\n### 按结果传递 ($V_{\\mathrm{res}}$)\n根据定义，形式参数是独立的、未初始化的局部变量。在调用出口处，它们的最终值按从左到右的顺序复制回实际参数的位置。\n\n1.  **调用入口：** 创建了两个新的、未初始化的局部变量 $u$ 和 $v$。它们彼此独立，也与调用者的变量 $a$ 独立。调用者的 $a$ 保持为 $5$。\n2.  **$f(u,v)$ 的执行：**\n    - 语句 1：$u := 3$。局部变量 $u$ 被赋值为 $3$。状态：$u=3$。\n    - 语句 2：$v := u + 4$。表达式求值为 $3+4=7$。局部变量 $v$ 被赋值为 $7$。状态：$u=3, v=7$。\n    - 语句 3：$u := v + 5$。表达式求值为 $7+5=12$。局部变量 $u$ 更新为 $12$。状态：$u=12, v=7$。\n3.  **调用出口（复制返回）：** 形式参数的最终值被复制回实际参数。实际参数是 $(a, a)$，形式参数是 $(u, v)$。复制返回按形式参数从左到右的顺序执行。\n    - 首先（对于 $u$）：$u$ 的最终值 $12$ 被复制到第一个实际参数 $a$ 的位置。$a$ 的值变为 $12$。\n    - 其次（对于 $v$）：$v$ 的最终值 $7$ 被复制到第二个实际参数 $a$ 的位置。$a$ 的值变为 $7$。之前的值 $12$ 被覆盖。\n4.  **最终值：** $a$ 的最终值是最后一次复制返回操作的结果，即 $7$。\n因此，$V_{\\mathrm{res}} = 7$。\n\n### 复制传入/复制传出（按值-结果传递）($V_{\\mathrm{cio}}$)\n该机制结合了入口时的按值传递和出口时的按结果传递。\n\n1.  **调用入口（复制传入）：** 创建了两个新的、独立的局部变量 $u$ 和 $v$。它们用相应实际参数的值进行初始化。\n    - $u$ 接收第一个实际参数 $a$ 的值，所以 $u=5$。\n    - $v$ 接收第二个实际参数 $a$ 的值，所以 $v=5$。\n    - 在函数执行期间，调用者的 $a$ 保持为 $5$。\n2.  **$f(u,v)$ 的执行：**\n    - 语句 1：$u := 3$。局部变量 $u$ 更新为 $3$。状态：$u=3, v=5$。\n    - 语句 2：$v := u + 4$。表达式求值为 $3+4=7$。局部变量 $v$ 更新为 $7$。状态：$u=3, v=7$。\n    - 语句 3：$u := v + 5$。表达式求值为 $7+5=12$。局部变量 $u$ 更新为 $12$。状态：$u=12, v=7$。\n3.  **调用出口（复制传出）：** 形式参数的最终值按从左到右的顺序复制回实际参数的位置。这一步与按结果传递的情况完全相同。\n    - 首先（对于 $u$）：$u$ 的值（$12$）被复制到 $a$。$a$ 的值变为 $12$。\n    - 其次（对于 $v$）：$v$ 的值（$7$）被复制到 $a$。$a$ 的值变为 $7$。\n4.  **最终值：** $a$ 的最终值是 $7$。\n因此，$V_{\\mathrm{cio}} = 7$。\n\n请注意，对于这个特定的函数体，由于形式参数的初始值在被读取之前立即被覆盖，因此按结果传递和复制传入/复制传出的行为是相同的。\n\n### 最终计算\n问题要求计算总和 $S = V_{\\mathrm{val}} + V_{\\mathrm{ref}} + V_{\\mathrm{res}} + V_{\\mathrm{cio}}$。\n代入计算出的值：\n$S = 5 + 12 + 7 + 7$\n$S = 17 + 14$\n$S = 31$\n$S$ 的最终整数值为 $31$。", "answer": "$$\n\\boxed{31}\n$$", "id": "3661405"}, {"introduction": "在掌握了基本变量的别名问题后，我们将挑战一个更贴近实际的场景：数组切片（array slices）的重叠。当函数的参数是共享同一底层内存的重叠数据区域时，不同的参数传递机制会产生截然不同的结果。这个练习 [@problem_id:3661407] 让你通过追踪内存的实时变化，直观地比较传引用机制下的即时效应和复制-传入/复制-传出机制中“复制-传出”顺序的重要性，从而深化对指针和引用操作的理解。", "problem": "考虑一个简单的命令式语言，其中数组和连续切片被建模为对单一底层内存数组的视图。一个基址索引为 $s$、长度为 $L$ 的切片，将其元素访问 $x[i]$ 映射到底层内存位置 $M[s+i]$，其中 $i \\in \\{0,\\dots,L-1\\}$。索引从 0 开始，所有算术运算均为整数算术。\n\n设底层内存为长度为 7 的数组 $M$，其初始状态为\n$$\nM = [7,1,4,2,6,3,5].\n$$\n定义过程 $h(a,b)$，它对两个等长（长度均为 $L$）的切片 $a$ 和 $b$ 进行如下操作。对于从 $0$ 到 $L-1$ 递增的 $i$，过程体执行单个赋值语句\n$$\na[i] := b[i] + b\\big((i+1) \\bmod L\\big),\n$$\n其中 $b((i+1) \\bmod L)$ 表示切片 $b$ 中索引为 $(i+1) \\bmod L$ 的元素（环绕索引）。\n\n一个调用者使用以下重叠的切片作为实际参数来调用 $h$：\n- $a$ 是 $M$ 的一个切片，基址 $s_a = 1$，长度 $L = 4$，因此对于 $i \\in \\{0,1,2,3\\}$，$a[i]$ 是 $M[1+i]$ 的别名；\n- $b$ 是 $M$ 的一个切片，基址 $s_b = 2$，长度 $L = 4$，因此对于 $i \\in \\{0,1,2,3\\}$，$b[i]$ 是 $M[2+i]$ 的别名。\n\n进行三个独立的实验，每个实验都从上面给出的相同初始 $M$ 开始，唯一的区别在于两个参数所使用的参数传递机制：\n1. 对 $a$ 和 $b$ 均使用引用传递。\n2. 对 $a$ 和 $b$ 均使用值传递（调用后结果不写回 $M$）。\n3. 对 $a$ 和 $b$ 均使用复制-传入/复制-传出（也称为传值结果调用）：在调用入口，每个形式参数接收其实际参数切片的一个新副本（复制-传入）；在返回时，每个形式参数的最终切片内容按照形式参数列表从左到右的顺序（先 $a$，后 $b$）写回到相应的实际参数切片（复制-传出）。\n\n设 $M_{\\mathrm{ref}}$、$M_{\\mathrm{val}}$ 和 $M_{\\mathrm{cio}}$ 分别表示实验 1、2 和 3 中调用结束后的最终底层内存数组。计算单个标量值\n$$\nS \\;=\\; M_{\\mathrm{ref}}[3] \\;+\\; M_{\\mathrm{val}}[3] \\;+\\; M_{\\mathrm{cio}}[3].\n$$\n请以单个整数形式给出你的答案。无需四舍五入，也没有单位。", "solution": "该问题是有效的，因为它科学地基于程序设计语言语义学的原理，特别是参数传递机制。问题提法恰当，提供了所有必要的数据和定义，从而导出一个唯一的、可计算的解。语言客观且无歧义。我们开始解题。\n\n长度为 7 的底层内存数组 $M$ 的初始状态为：\n$$ M = [7, 1, 4, 2, 6, 3, 5] $$\n过程 $h(a,b)$ 被调用，其参数是 $M$ 的两个重叠切片，每个切片长度为 $L=4$：\n- 实际参数 $a$ 是基址为 $s_a=1$ 的切片，对应于内存位置 $M[1], M[2], M[3], M[4]$ 上的视图。最初，该切片包含 $[1, 4, 2, 6]$。\n- 实际参数 $b$ 是基址为 $s_b=2$ 的切片，对应于内存位置 $M[2], M[3], M[4], M[5]$ 上的视图。最初，该切片包含 $[4, 2, 6, 3]$。\n\n过程体对从 $0$ 到 $L-1=3$ 的 $i$ 执行一个循环：\n$$ a[i] := b[i] + b\\big((i+1) \\bmod L\\big) $$\n我们分析这三个独立的实验。\n\n### 实验 1：引用传递\n\n在引用传递中，形式参数 $a$ 和 $b$ 是实际参数切片的别名。对形式参数的任何修改都会直接且立即影响底层内存数组 $M$。赋值语句 $a[i] := \\dots$ 修改 $M[1+i]$，而从 $b[\\cdot]$ 读取数据则访问 $M[2+\\cdot]$ 中的当前值。\n\n让我们从 $M_0 = [7, 1, 4, 2, 6, 3, 5]$ 开始，逐步跟踪执行过程。\n\n- **对于 $i=0$**：\n  赋值语句是 $a[0] := b[0] + b[1]$。\n  这等价于 $M[1+0] := M[2+0] + M[2+1]$，即 $M[1] := M[2] + M[3]$。\n  使用 $M$ 中的当前值：$M[1] := 4 + 2 = 6$。\n  $M$ 的状态变为 $[7, 6, 4, 2, 6, 3, 5]$。\n\n- **对于 $i=1$**：\n  赋值语句是 $a[1] := b[1] + b[2]$。\n  这等价于 $M[1+1] := M[2+1] + M[2+2]$，即 $M[2] := M[3] + M[4]$。\n  使用 $M$ 中的当前值：$M[2] := 2 + 6 = 8$。\n  $M$ 的状态变为 $[7, 6, 8, 2, 6, 3, 5]$。\n\n- **对于 $i=2$**：\n  赋值语句是 $a[2] := b[2] + b[3]$。\n  这等价于 $M[1+2] := M[2+2] + M[2+3]$，即 $M[3] := M[4] + M[5]$。\n  使用 $M$ 中的当前值：$M[3] := 6 + 3 = 9$。\n  $M$ 的状态变为 $[7, 6, 8, 9, 6, 3, 5]$。\n\n- **对于 $i=3$**：\n  赋值语句是 $a[3] := b[3] + b((3+1) \\bmod 4)$，可简化为 $a[3] := b[3] + b[0]$。\n  这等价于 $M[1+3] := M[2+3] + M[2+0]$，即 $M[4] := M[5] + M[2]$。\n  关键是，我们必须使用 $M[2]$ 的**更新后**的值，即 $8$。\n  使用 $M$ 中的当前值：$M[4] := 3 + 8 = 11$。\n  $M$ 的状态变为 $[7, 6, 8, 9, 11, 3, 5]$。\n\n此实验的最终内存数组是 $M_{\\mathrm{ref}} = [7, 6, 8, 9, 11, 3, 5]$。\n因此，$M_{\\mathrm{ref}}[3] = 9$。\n\n### 实验 2：值传递\n\n在值传递中，过程接收实际参数的副本。过程 $h$ 在这些本地副本上操作。问题规定，对于此机制，结果不会写回 $M$。\n- 在入口处，创建了切片 $a$ 的一个本地副本：$a_{\\mathrm{local}} = [1, 4, 2, 6]$。\n- 创建了切片 $b$ 的一个本地副本：$b_{\\mathrm{local}} = [4, 2, 6, 3]$。\n过程操作这些本地副本，但由于结果不会被复制回去，原始数组 $M$ 保持不变。\n最终的内存数组与初始数组相同：$M_{\\mathrm{val}} = [7, 1, 4, 2, 6, 3, 5]$。\n因此，$M_{\\mathrm{val}}[3] = 2$。\n\n### 实验 3：复制-传入/复制-传出 (传值结果调用)\n\n该机制包括三个阶段：复制-传入、执行和复制-传出。\n\n- **复制-传入**：在调用入口处，创建实际参数切片的本地副本。\n  - $a_{\\mathrm{local}}$ 是从 $M[1]$ 开始的切片的一个副本：$a_{\\mathrm{local}} = [1, 4, 2, 6]$。\n  - $b_{\\mathrm{local}}$ 是从 $M[2]$ 开始的切片的一个副本：$b_{\\mathrm{local}} = [4, 2, 6, 3]$。\n\n- **执行**：过程使用这些本地副本运行。循环根据从 $b_{\\mathrm{local}}$ 读取的值来修改 $a_{\\mathrm{local}}$。由于 $b_{\\mathrm{local}}$ 从未被写入，它在整个执行过程中保持其初始复制的值。\n  - 让我们跟踪 $a_{\\mathrm{local}}$ 的更新：\n    - **$i=0$**: $a_{\\mathrm{local}}[0] := b_{\\mathrm{local}}[0] + b_{\\mathrm{local}}[1] = 4 + 2 = 6$。\n    - **$i=1$**: $a_{\\mathrm{local}}[1] := b_{\\mathrm{local}}[1] + b_{\\mathrm{local}}[2] = 2 + 6 = 8$。\n    - **$i=2$**: $a_{\\mathrm{local}}[2] := b_{\\mathrm{local}}[2] + b_{\\mathrm{local}}[3] = 6 + 3 = 9$。\n    - **$i=3$**: $a_{\\mathrm{local}}[3] := b_{\\mathrm{local}}[3] + b_{\\mathrm{local}}[0] = 3 + 4 = 7$。\n  - 在过程结束时，本地切片的最终状态是：\n    - $a_{\\mathrm{local, final}} = [6, 8, 9, 7]$。\n    - $b_{\\mathrm{local, final}} = [4, 2, 6, 3]$ (未改变)。\n\n- **复制-传出**：返回时，最终本地切片的内容被复制回原始实际参数的内存位置。问题规定了复制-传出的顺序是从左到右：先 $a$，后 $b$。\n  - 我们从初始内存数组开始：$M = [7, 1, 4, 2, 6, 3, 5]$。\n  - **复制传出 $a$**：$a_{\\mathrm{local, final}}$ 的内容被写入 $a$ 的切片位置，即 $M[1], M[2], M[3], M[4]$。\n    - $M[1] := 6$, $M[2] := 8$, $M[3] := 9$, $M[4] := 7$。\n    - 此步骤后，$M$ 变为 $[7, 6, 8, 9, 7, 3, 5]$。\n  - **复制传出 $b$**：$b_{\\mathrm{local, final}}$ 的内容被写入 $b$ 的切片位置，即 $M[2], M[3], M[4], M[5]$。这发生在 $a$ 的复制-传出*之后*。\n    - $M[2] := 4$ (覆盖了来自 $a$ 的复制-传出的值 $8$)。\n    - $M[3] := 2$ (覆盖了来自 $a$ 的复制-传出的值 $9$)。\n    - $M[4] := 6$ (覆盖了来自 $a$ 的复制-传出的值 $7$)。\n    - $M[5] := 3$ (覆盖了原来的值 $3$)。\n  - $M$ 的最终状态是 $[7, 6, 4, 2, 6, 3, 5]$。\n\n此实验的最终内存数组是 $M_{\\mathrm{cio}} = [7, 6, 4, 2, 6, 3, 5]$。\n因此，$M_{\\mathrm{cio}}[3] = 2$。\n\n### 最终计算\n\n我们被要求计算标量值 $S = M_{\\mathrm{ref}}[3] + M_{\\mathrm{val}}[3] + M_{\\mathrm{cio}}[3]$。\n代入我们找到的值：\n- $M_{\\mathrm{ref}}[3] = 9$\n- $M_{\\mathrm{val}}[3] = 2$\n- $M_{\\mathrm{cio}}[3] = 2$\n\n$$ S = 9 + 2 + 2 = 13 $$\n最终答案是 $13$。", "answer": "$$\n\\boxed{13}\n$$", "id": "3661407"}, {"introduction": "参数传递不仅是程序语言的抽象语义，它还直接影响程序的运行效率。这个练习 [@problem_id:3661409] 将视角从程序的语义正确性转向了执行性能，探讨了参数传递与底层硬件架构之间的相互作用。你将扮演编译器的角色，面对有限的寄存器资源，设计一个优化策略来最小化因参数压栈而产生的内存访问开销，这让你能体会到编译器后端设计中充满挑战的权衡与优化过程。", "problem": "一个用于内部领域特定语言的编译器后端，其目标机器使用固定数量的通用参数寄存器来传递按值传递的参数，超出部分则溢出到栈上。该接口为内部接口，编译器被允许在调用点和被调用者处一致地重排参数列表，而不会改变程序语义。每个参数都是一个单独的机器字。目标机器提供恰好 $R$ 个单字参数寄存器；任何额外的参数都通过栈传递。假设每次调用的动态内存流量遵循以下成本模型：\n- 每个通过栈传递的参数，会由调用者产生恰好 $1$ 次动态字存储。\n- 如果这样一个参数在调用执行期间被被调用者使用了 $u_i$ 次，则每次使用都会由被调用者产生一次从栈进行的动态字加载（寄存器压力阻止了跨次使用的重用）。因此，其每次调用的动态栈流量为 $1 + u_i$ 个字。\n- 通过参数寄存器传递的参数产生的动态栈流量为零。\n在重排后的列表中，参数从左到右分配给寄存器，直到 $R$ 个寄存器用尽；所有剩余的参数都溢出到栈上。\n\n仅从按值传递和调用约定的核心定义，以及所述的机器模型出发，完成以下任务：\n1) 针对任意固定的参数顺序，推导溢出参数的数量，以及每次调用的总动态栈字流量的表达式，该表达式是关于参数总数 $N$、寄存器数量 $R$以及每个参数的动态使用次数多重集 $\\{u_i\\}_{i=1}^{N}$ 的函数。然后，使用基本原理推导，在可用寄存器数量的约束下，通过重排参数可实现的最小可能动态栈流量。描述一种在该模型下能达到此最小值的确定性启发式排序规则。\n2) 考虑一个具体的调用，其中有 $N = 10$ 个按值传递的参数和 $R = 3$ 个参数寄存器。在原始源代码顺序中，动态使用次数为\n$\\{u_1,u_2,\\dots,u_{10}\\} = \\{5, 1, 8, 0, 3, 1, 13, 2, 0, 1\\}$。\n计算在上述模型下，通过重排参数可实现的每次调用的最小总动态栈字流量。仅报告这个最小数值作为你的最终答案。无需四舍五入。", "solution": "问题陈述经过审视，被认为是有效的。这是一个定义明确的优化问题，基于编译器设计和计算机体系结构的标准（尽管简化了）概念，特别是调用约定和寄存器分配。所有必要的数据和定义都已提供，不存在内部矛盾、歧义或违反科学原理之处。该问题可以被严格地形式化和解决。\n\n设 $N$ 为按值传递参数的总数，$R$ 为可用的通用参数寄存器数量，$\\{u_i\\}_{i=1}^{N}$ 为这些参数的动态使用次数的多重集。\n\n**第1部分：一般性推导**\n\n问题指定了一种调用约定，其中列表中的前 $R$ 个参数通过寄存器传递，任何后续参数都通过栈传递。编译器可以自由地重排参数。\n\n首先，我们确定在给定顺序下溢出参数的数量。如果参数总数 $N$ 小于或等于寄存器数量 $R$（即 $N \\le R$），所有参数都可以通过寄存器传递，没有参数溢出。如果 $N > R$，前 $R$ 个参数通过寄存器传递，剩下的 $N - R$ 个参数溢出到栈上。因此，对于任意顺序，溢出参数的数量为 $\\max(0, N - R)$。\n\n接下来，我们推导每次调用的总动态栈字流量的表达式。根据成本模型：\n- 通过寄存器传递的参数产生 $0$ 栈流量。\n- 通过栈传递的参数 $i$ 会产生调用者 $1$ 次字存储和被调用者 $u_i$ 次字加载的成本，总计为 $1 + u_i$ 个动态栈字。\n\n设所选列表顺序中的参数为 $\\{p_1, p_2, \\dots, p_N\\}$，其对应的使用次数为 $\\{v_1, v_2, \\dots, v_N\\}$。注意 $\\{v_i\\}$ 是原始 $\\{u_i\\}$ 的一个排列。对于此顺序，参数 $p_{R+1}, \\dots, p_N$ 会溢出。总动态栈流量 $T$ 是这些溢出参数的成本之和。\n如果 $N \\le R$, 则 $T = 0$。\n如果 $N > R$, 总流量为：\n$$ T = \\sum_{k=R+1}^{N} (1 + v_k) $$\n该表达式可以展开为：\n$$ T = \\sum_{k=R+1}^{N} 1 + \\sum_{k=R+1}^{N} v_k = (N-R) + \\sum_{k=R+1}^{N} v_k $$\n项 $(N-R)$ 表示调用者存储每个溢出参数的固定成本。该项是常数，不依赖于参数顺序。因此，为了最小化总流量 $T$，我们必须最小化第二项 $\\sum_{k=R+1}^{N} v_k$，即溢出到栈上的参数的使用次数之和。\n\n为实现此最小化，我们应选择使用次数最低的参数进行溢出。这在逻辑上等同于选择使用次数最高的参数放入 $R$ 个可用的寄存器中，因为这样可以避免产生形式为 $(1+u_i)$ 的最大成本。\n\n这引出了以下实现最小栈流量的确定性排序规则：\n1. 按参数的动态使用次数 $u_i$ 的**降序**进行排序。\n2. 编译器应按此排序顺序安排参数列表。\n\n设原始的使用次数多重集为 $\\{u_i\\}_{i=1}^{N}$。我们将这些次数按非递减（升序）顺序排序，得到有序集合 $\\{u_{(1)}, u_{(2)}, \\dots, u_{(N)}\\}$，其中 $u_{(1)} \\le u_{(2)} \\le \\dots \\le u_{(N)}$。\n\n最优策略是将具有最高使用次数的 $R$ 个参数 $\\{u_{(N-R+1)}, \\dots, u_{(N)}\\}$ 分配给寄存器。剩下的 $N-R$ 个具有最低使用次数的参数 $\\{u_{(1)}, \\dots, u_{(N-R)}\\}$ 则溢出到栈上。\n\n最小可能动态栈流量 $T_{min}$ 是这 $N-R$ 个溢出参数的成本之和。\n如果 $N \\le R$, 则 $T_{min} = 0$。\n如果 $N > R$, 最小流量为：\n$$ T_{min} = \\sum_{i=1}^{N-R} (1 + u_{(i)}) = (N-R) + \\sum_{i=1}^{N-R} u_{(i)} $$\n\n该策略是可证明为最优的。假设存在一个最优分配，其中一个使用次数为 $u_a$ 的参数 $p_a$ 在寄存器中，而另一个使用次数为 $u_b$ 的参数 $p_b$ 在栈上，且 $u_a  u_b$。总成本包含项 $(1+u_b)$。如果我们交换它们，将 $p_b$ 放入寄存器，将 $p_a$ 放到栈上，则新成本将包含项 $(1+u_a)$。因为 $u_a  u_b$，所以 $(1+u_a)  (1+u_b)$，总成本减少了。这与最初该分配为最优的假设相矛盾。因此，在任何最优分配中，寄存器中的每个参数的使用次数必须大于或等于栈上任何参数的使用次数。所规定的排序规则满足此条件。\n\n**第2部分：具体计算**\n\n我们给定一个具体的调用：\n- 参数总数：$N = 10$\n- 参数寄存器数量：$R = 3$\n- 动态使用次数多重集：$\\{u_i\\} = \\{5, 1, 8, 0, 3, 1, 13, 2, 0, 1\\}$\n\n首先，我们确定溢出参数的数量。由于 $N  R$，将有 $N - R = 10 - 3 = 7$ 个参数溢出到栈上。剩下的 $R=3$ 个参数将通过寄存器传递。\n\n为了最小化总动态栈流量，我们必须将使用次数最低的 $7$ 个参数溢出。我们首先将使用次数的多重集按非递减顺序排序：\n$$ \\{0, 0, 1, 1, 1, 2, 3, 5, 8, 13\\} $$\n使用次数最高的 $R = 3$ 个参数，即 $\\{13, 8, 5\\}$，被放入寄存器。它们对栈流量的贡献为 $0$。\n\n使用次数最低的 $N-R = 7$ 个参数，即 $\\{0, 0, 1, 1, 1, 2, 3\\}$，被溢出到栈上。\n\n最小总动态栈流量 $T_{min}$ 是这 $7$ 个溢出参数的成本之和。我们使用第1部分推导出的公式：\n$$ T_{min} = \\sum_{i=1}^{7} (1 + u_{(i)}) $$\n其中 $\\{u_{(i)}\\}_{i=1}^7$ 是 $7$ 个最低的使用次数。\n$$ T_{min} = (1 + 0) + (1 + 0) + (1 + 1) + (1 + 1) + (1 + 1) + (1 + 2) + (1 + 3) $$\n$$ T_{min} = 1 + 1 + 2 + 2 + 2 + 3 + 4 $$\n$$ T_{min} = 15 $$\n或者，使用另一种形式的方程：\n$$ T_{min} = (N-R) + \\sum_{i=1}^{N-R} u_{(i)} $$\n$$ T_{min} = 7 + (0 + 0 + 1 + 1 + 1 + 2 + 3) $$\n$$ T_{min} = 7 + 8 $$\n$$ T_{min} = 15 $$\n每次调用的最小总动态栈字流量为 $15$。", "answer": "$$\n\\boxed{15}\n$$", "id": "3661409"}]}