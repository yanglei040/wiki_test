{"hands_on_practices": [{"introduction": "编译器常常面临数据分配位置的决策。对于那些直到运行时才能确定大小的数据（例如变长数组），这一决策尤为关键。本练习探讨了栈分配与堆分配之间的权衡。你需要基于底层系统行为（如页错误和系统调用）建立一个成本模型，从而证明最优的编译器决策依赖于对整个系统栈的深刻理解。[@problem_id:3658117]", "problem": "一个支持可变长数组的语言的编译器，必须在运行时决定，是将一个包含 $n$ 个元素、每个元素大小为 $s$ 字节的数组放置在调用栈上，还是在堆上分配它。编译器被允许使用一个简单的阈值策略：在运行时计算数组总大小 $b = n s$，如果 $b > T$，则将数组放置在堆上；否则，将其放置在栈上。你需要从虚拟内存和保护页探测的基本原理出发，推导出一个阈值 $T$（以字节为单位），该阈值能够最小化期望页面错误成本。\n\n假设有以下经过充分检验的事实和策略：\n1. 操作系统 (OS) 使用带有按需零填充的请求分页机制。当首次访问任何大小为 $P$ 字节的虚拟内存页时，会发生一次页面错误，并且该页面会被分配并以零填充。\n2. 栈具有保护页机制来检测溢出。为确保在有限步骤内能触及保护页，编译器对大的栈分配使用栈探测技术：在进入一个在栈上分配 $b$ 字节的函数时，它会触摸每个新跨越的页面中的一个字（word）来触发栈的增长。在此策略下，一个跨越 $m = \\lceil b / P \\rceil$ 个页面的栈分配所引发的页面错误数量恰好为 $m$，这与函数体后续实际使用多少数组无关。\n3. 堆分配通过一个系统调用来执行，该调用具有固定的成本 $h$（其单位与页面错误的抽象成本单位相同）。堆分配器惰性地映射页面，因此只有程序实际触摸到的页面才会引发错误。堆上没有额外的保护页探测。\n4. 程序对数组的使用是随机的：代码有 $p \\in [0,1)$ 的概率扫描并写入整个数组（从而触摸每个元素及分配的每个页面），有 $1-p$ 的概率仅检查第一个元素后立即返回，从而只触摸分配的第一个页面。编译器知道 $p$、$P$、$h$ 和页面错误成本 $c$，但不知道 $n$。\n\n仅使用这些假设和定义 $m = \\lceil b / P \\rceil$，推导出一个最小阈值 $T$（以字节为单位）的闭式解析表达式，使得“若 $b > T$ 则使用堆”这一策略能最小化仅以页面错误成本和堆系统调用成本为单位度量的期望总成本。你的答案必须是关于 $P$、$c$、$h$ 和 $p$ 的单个解析表达式。最终的 $T$ 必须以字节表示。不需要进行数值计算。", "solution": "我们从给定的虚拟内存模型以及所述的编译器和运行时策略出发。其基本依据是请求分页的事实：每个大小为 $P$ 的页面在首次被访问时，会产生一次成本为 $c$ 的页面错误。我们还使用由字节大小 $b$ 跨越的页面数量的定义 $m = \\lceil b / P \\rceil$。\n\n我们对两种放置策略下的期望成本进行建模。\n\n栈放置。根据假设，为保证保护页的安全性，编译器执行栈探测，触摸每个新跨越页面中的一个字。因此，无论后续使用情况如何，页面错误的数量都等于跨越的页面数，即 $m = \\lceil b / P \\rceil$。因此总成本为\n$$\nC_{\\text{stack}}(b) = c \\, m = c \\, \\left\\lceil \\frac{b}{P} \\right\\rceil.\n$$\n\n堆放置。分配器产生一个固定的系统调用开销 $h$，并且页面仅在被程序触摸时才惰性地产生错误。程序有 $p$ 的概率触摸所有 $m$ 个页面，有 $1-p$ 的概率只触摸第一个页面。因此，期望的页面错误数量为\n$$\n\\mathbb{E}[\\text{faults} \\mid \\text{heap}, b] = p \\, m + (1-p)\\cdot 1,\n$$\n总的期望成本为\n$$\nC_{\\text{heap}}(b) = h + c \\left( p \\, m + (1-p)\\cdot 1 \\right) = h + c \\left( p \\left\\lceil \\frac{b}{P} \\right\\rceil + 1 - p \\right).\n$$\n\n决策规则。对于给定的 $b$，当 $C_{\\text{heap}}(b)  C_{\\text{stack}}(b)$ 时，堆放置更优。使用 $m = \\lceil b / P \\rceil$，该不等式变为\n$$\nh + c \\left( p m + 1 - p \\right)  c m.\n$$\n整理各项：\n$$\nh + c (1 - p)  c m - c p m = c (1 - p) m.\n$$\n因为 $p \\in [0,1)$，所以有 $1-p > 0$，我们可以用 $c (1-p)$ 去除，得到\n$$\n\\frac{h}{c (1-p)} + 1  m.\n$$\n等价地，\n$$\nm > 1 + \\frac{h}{c (1-p)}.\n$$\n\n定义实数阈值\n$$\nr \\equiv 1 + \\frac{h}{c (1-p)}.\n$$\n由于 $m$ 是一个整数且 $m = \\left\\lceil \\frac{b}{P} \\right\\rceil$，选择堆的条件变为\n$$\n\\left\\lceil \\frac{b}{P} \\right\\rceil > r \\quad \\Longleftrightarrow \\quad \\left\\lceil \\frac{b}{P} \\right\\rceil \\ge \\left\\lfloor r \\right\\rfloor + 1.\n$$\n使此式成立的最小 $b$（以字节为单位）满足\n$$\n\\frac{b}{P} > \\left\\lfloor r \\right\\rfloor \\quad \\Longleftrightarrow \\quad b > P \\left\\lfloor r \\right\\rfloor.\n$$\n因此，一个形式为“若 $b  T$ 则使用堆”且恰好匹配此决策边界的阈值策略，可以通过选择如下 $T$ 来获得\n$$\nT = P \\left\\lfloor 1 + \\frac{h}{c (1-p)} \\right\\rfloor.\n$$\n\n这个 $T$ 是最小的字节阈值，使得对于所有 $b  T$，堆放置的期望成本严格小于栈放置的期望成本，而对于 $b \\le T$，在给定模型下栈放置是最优的。该表达式是关于 $P$、$c$、$h$ 和 $p$ 的完全解析式，并已按要求以字节表示。", "answer": "$$\\boxed{P \\left\\lfloor 1 + \\frac{h}{c \\left(1 - p\\right)} \\right\\rfloor}$$", "id": "3658117"}, {"introduction": "对于由运行时系统管理的语言（如Java或C#），大多数数据作为对象存在于堆上。堆分配的效率至关重要，特别是对于创建大量小对象的程序。本练习将挑战你分析和优化堆对象的内存足迹。通过探索指针标记技术及其与内存对齐的相互作用，你将量化对象头压缩所带来的潜在内存节省，这是现代虚拟机中的一项关键优化技术。[@problem_id:3658034]", "problem": "一个用于编译型语言的托管运行时系统分配堆对象，每个对象都带有一个固定大小的对象头和载荷。考虑一个$64$位架构，其中所有堆对象都按字节倍数 $a \\in \\{8,16\\}$ 对齐，并且指向类型描述符的指针是自然对齐的。基线实现使用一个大小为 $h = 16$ 字节的头，用于存储一个类型指针和状态标志。提出了一种指针标记方案，该方案在类型指针的低位中编码最多 $b$ 个状态位，其中 $b = \\log_{2}(a)$。当一个对象所需的标记位不超过 $b$ 时，其对象头可以被压缩为单个字，大小为 $8$ 字节（仅包含带标记的类型指针）。否则，对象头大小仍为 $16$ 字节。所有对象的总分配大小是经过对齐取整的量 $$\\text{alloc}(h,s,a) = \\left\\lceil \\frac{h + s}{a} \\right\\rceil \\cdot a,$$ 其中 $s$ 是以字节为单位的载荷大小。\n\n假设一个对象所需的状态位数 $K$ 服从分布 $P(K=0) = 0.50$, $P(K=1) = 0.20$, $P(K=2) = 0.15$, $P(K=3) = 0.10$, $P(K=4) = 0.05$，并且 $K$ 与载荷大小无关。小对象的载荷大小分布为 $s \\in \\{5,9,14,22\\}$，其各自的概率为 $0.25$, $0.35$, $0.25$, $0.15$。\n\n您必须选择一种由对齐方式 $a$ 和上述压缩头行为所表征的指针标记方案。基线方案使用 $a=8$ 且不进行指针标记，因此所有对象的头大小均为 $16$ 字节。对于一个对齐方式为 $a$ 的标记方案，对于比例为 $P(K \\leq b)$ 的对象，其压缩后的头大小为 $8$ 字节，否则为 $16$ 字节。\n\n从基于对齐的取整和期望值的基本定义出发，当您选择使预期分配大小最小化的标记方案时，确定每个对象相对于基线方案的预期分配内存分数减少量。将最终的节省量表示为比率 $$\\frac{\\mathbb{E}[\\text{alloc}_{\\text{baseline}}] - \\min\\{\\mathbb{E}[\\text{alloc}_{a=8,\\text{tag}}], \\mathbb{E}[\\text{alloc}_{a=16,\\text{tag}}]\\}}{\\mathbb{E}[\\text{alloc}_{\\text{baseline}}]}.$$ 将您的答案四舍五入到四位有效数字，并以无单位的小数形式表示。", "solution": "该问题要求我们从两个由对齐值 $a=8$ 和 $a=16$ 表征的选项中确定最优的指针标记方案，然后计算相对于基线方案，每个对象的预期分配内存的分数减少量。最优方案是使预期分配大小最小化的方案。\n\n该问题涉及两个独立的离散随机变量：我们用 $S$ 表示的载荷大小，以及我们用 $K$ 表示的所需状态位数。我们用 $H$ 表示的头大小是 $K$ 和所选对齐方式 $a$ 的函数。对于一个头大小为 $h$、载荷大小为 $s$ 且对齐方式为 $a$ 的对象，其总分配大小由以下确定性函数给出：\n$$ \\text{alloc}(h,s,a) = \\left\\lceil \\frac{h + s}{a} \\right\\rceil \\cdot a $$\n对于给定的方案，预期分配大小是该函数在随机变量 $H$ 和 $S$ 上的期望。由于它们的独立性，期望值计算如下：\n$$ \\mathbb{E}[\\text{alloc}(H,S,a)] = \\sum_{s} \\sum_{h} \\text{alloc}(h,s,a) P(H=h, S=s) = \\sum_{s} \\sum_{h} \\text{alloc}(h,s,a) P(H=h) P(S=s) $$\n这可以通过首先计算在给定头大小的条件下每个可能头大小的预期分配大小，然后对头大小取期望来计算。\n$$ \\mathbb{E}[\\text{alloc}(H,S,a)] = \\sum_{h} P(H=h) \\left( \\sum_{s} \\text{alloc}(h,s,a) P(S=s) \\right) = \\sum_{h} P(H=h) \\mathbb{E}_{S}[\\text{alloc}(h,S,a)] $$\n分布如下：\n$P(S=5) = 0.25$, $P(S=9) = 0.35$, $P(S=14) = 0.25$, $P(S=22) = 0.15$。\n$P(K=0) = 0.50$, $P(K=1) = 0.20$, $P(K=2) = 0.15$, $P(K=3) = 0.10$, $P(K=4) = 0.05$。\n\n我们将计算三种情况下的预期分配大小：基线方案、采用 $a=8$ 的标记方案，以及采用 $a=16$ 的标记方案。\n\n1.  基线方案的预期分配大小 ($\\mathbb{E}[\\text{alloc}_{\\text{baseline}}]$)\n对于基线方案，对齐方式为 $a=8$ 并且没有指针标记。所有对象的头大小是恒定的，为 $h=16$ 字节。\n对于给定的载荷 $s$，分配的大小为 $\\text{alloc}_{\\text{baseline}}(s) = \\text{alloc}(16, s, 8) = \\left\\lceil \\frac{16 + s}{8} \\right\\rceil \\cdot 8$。\n我们为每种可能的载荷大小计算这个值：\n- 对于 $s=5$：$\\text{alloc}(16, 5, 8) = \\left\\lceil \\frac{16+5}{8} \\right\\rceil \\cdot 8 = \\left\\lceil \\frac{21}{8} \\right\\rceil \\cdot 8 = 3 \\cdot 8 = 24$。\n- 对于 $s=9$：$\\text{alloc}(16, 9, 8) = \\left\\lceil \\frac{16+9}{8} \\right\\rceil \\cdot 8 = \\left\\lceil \\frac{25}{8} \\right\\rceil \\cdot 8 = 4 \\cdot 8 = 32$。\n- 对于 $s=14$：$\\text{alloc}(16, 14, 8) = \\left\\lceil \\frac{16+14}{8} \\right\\rceil \\cdot 8 = \\left\\lceil \\frac{30}{8} \\right\\rceil \\cdot 8 = 4 \\cdot 8 = 32$。\n- 对于 $s=22$：$\\text{alloc}(16, 22, 8) = \\left\\lceil \\frac{16+22}{8} \\right\\rceil \\cdot 8 = \\left\\lceil \\frac{38}{8} \\right\\rceil \\cdot 8 = 5 \\cdot 8 = 40$。\n预期分配大小是根据载荷大小分布计算的加权平均值：\n$$ \\mathbb{E}[\\text{alloc}_{\\text{baseline}}] = (24 \\cdot 0.25) + (32 \\cdot 0.35) + (32 \\cdot 0.25) + (40 \\cdot 0.15) $$\n$$ \\mathbb{E}[\\text{alloc}_{\\text{baseline}}] = 6.0 + 11.2 + 8.0 + 6.0 = 31.2 $$\n\n2.  采用 $a=8$ 的标记方案的预期分配大小 ($\\mathbb{E}[\\text{alloc}_{a=8,\\text{tag}}]$)\n对于此方案，对齐方式为 $a=8$。可用的标记位数为 $b = \\log_{2}(a) = \\log_{2}(8) = 3$。\n如果 $K \\leq b$ (即 $K \\leq 3$)，则头被压缩为 $h=8$ 字节。否则，头大小为 $h=16$ 字节。\n设 $H_8$ 为 $a=8$ 时头大小的随机变量。我们求其分布：\n- $P(H_8=8) = P(K \\leq 3) = P(K=0) + P(K=1) + P(K=2) + P(K=3) = 0.50 + 0.20 + 0.15 + 0.10 = 0.95$。\n- $P(H_8=16) = P(K  3) = P(K=4) = 0.05$。\n预期分配大小为：\n$$ \\mathbb{E}[\\text{alloc}_{a=8,\\text{tag}}] = P(H_8=8) \\cdot \\mathbb{E}_{S}[\\text{alloc}(8,S,8)] + P(H_8=16) \\cdot \\mathbb{E}_{S}[\\text{alloc}(16,S,8)] $$\n我们已经计算出 $\\mathbb{E}_{S}[\\text{alloc}(16,S,8)] = \\mathbb{E}[\\text{alloc}_{\\text{baseline}}] = 31.2$。\n现在我们计算 $\\mathbb{E}_{S}[\\text{alloc}(8,S,8)]$。首先，对于 $h=8, a=8$ 的分配大小：\n- 对于 $s=5$：$\\text{alloc}(8, 5, 8) = \\left\\lceil \\frac{8+5}{8} \\right\\rceil \\cdot 8 = \\lceil \\frac{13}{8} \\rceil \\cdot 8 = 2 \\cdot 8 = 16$。\n- 对于 $s=9$：$\\text{alloc}(8, 9, 8) = \\left\\lceil \\frac{8+9}{8} \\right\\rceil \\cdot 8 = \\lceil \\frac{17}{8} \\rceil \\cdot 8 = 3 \\cdot 8 = 24$。\n- 对于 $s=14$：$\\text{alloc}(8, 14, 8) = \\left\\lceil \\frac{8+14}{8} \\rceil \\cdot 8 = \\lceil \\frac{22}{8} \\rceil \\cdot 8 = 3 \\cdot 8 = 24$。\n- 对于 $s=22$：$\\text{alloc}(8, 22, 8) = \\left\\lceil \\frac{8+22}{8} \\right\\rceil \\cdot 8 = \\lceil \\frac{30}{8} \\rceil \\cdot 8 = 4 \\cdot 8 = 32$。\n期望值为：\n$$ \\mathbb{E}_{S}[\\text{alloc}(8,S,8)] = (16 \\cdot 0.25) + (24 \\cdot 0.35) + (24 \\cdot 0.25) + (32 \\cdot 0.15) $$\n$$ \\mathbb{E}_{S}[\\text{alloc}(8,S,8)] = 4.0 + 8.4 + 6.0 + 4.8 = 23.2 $$\n现在我们可以计算此方案的总预期大小：\n$$ \\mathbb{E}[\\text{alloc}_{a=8,\\text{tag}}] = (0.95 \\cdot 23.2) + (0.05 \\cdot 31.2) = 22.04 + 1.56 = 23.60 $$\n\n3.  采用 $a=16$ 的标记方案的预期分配大小 ($\\mathbb{E}[\\text{alloc}_{a=16,\\text{tag}}]$)\n对于此方案，对齐方式为 $a=16$。可用的标记位数为 $b = \\log_{2}(a) = \\log_{2}(16) = 4$。\n如果 $K \\leq b$ (即 $K \\leq 4$)，则头被压缩为 $h=8$ 字节。\n设 $H_{16}$ 为 $a=16$ 时头大小的随机变量。\n- $P(H_{16}=8) = P(K \\leq 4) = P(K=0) + ... + P(K=4) = 0.50 + 0.20 + 0.15 + 0.10 + 0.05 = 1.00$。\n- $P(H_{16}=16) = P(K  4) = 0$。\n在此方案中，所有对象的头都被压缩为 $h=8$ 字节。预期分配大小就是 $\\mathbb{E}_{S}[\\text{alloc}(8,S,16)]$。\n首先，对于 $h=8, a=16$ 的分配大小：\n- 对于 $s=5$：$\\text{alloc}(8, 5, 16) = \\left\\lceil \\frac{8+5}{16} \\right\\rceil \\cdot 16 = \\lceil \\frac{13}{16} \\rceil \\cdot 16 = 1 \\cdot 16 = 16$。\n- 对于 $s=9$：$\\text{alloc}(8, 9, 16) = \\left\\lceil \\frac{8+9}{16} \\right\\rceil \\cdot 16 = \\lceil \\frac{17}{16} \\rceil \\cdot 16 = 2 \\cdot 16 = 32$。\n- 对于 $s=14$：$\\text{alloc}(8, 14, 16) = \\left\\lceil \\frac{8+14}{16} \\right\\rceil \\cdot 16 = \\lceil \\frac{22}{16} \\rceil \\cdot 16 = 2 \\cdot 16 = 32$。\n- 对于 $s=22$：$\\text{alloc}(8, 22, 16) = \\left\\lceil \\frac{8+22}{16} \\right\\rceil \\cdot 16 = \\lceil \\frac{30}{16} \\rceil \\cdot 16 = 2 \\cdot 16 = 32$。\n期望值为：\n$$ \\mathbb{E}[\\text{alloc}_{a=16,\\text{tag}}] = (16 \\cdot 0.25) + (32 \\cdot 0.35) + (32 \\cdot 0.25) + (32 \\cdot 0.15) $$\n$$ \\mathbb{E}[\\text{alloc}_{a=16,\\text{tag}}] = 4.0 + 11.2 + 8.0 + 4.8 = 28.0 $$\n\n4.  比较与最终计算\n我们得到了三个期望值：\n- $\\mathbb{E}[\\text{alloc}_{\\text{baseline}}] = 31.2$\n- $\\mathbb{E}[\\text{alloc}_{a=8,\\text{tag}}] = 23.6$\n- $\\mathbb{E}[\\text{alloc}_{a=16,\\text{tag}}] = 28.0$\n\n问题要求我们选择使预期分配大小最小化的标记方案。我们比较这两个标记方案：\n$$ \\min\\{\\mathbb{E}[\\text{alloc}_{a=8,\\text{tag}}], \\mathbb{E}[\\text{alloc}_{a=16,\\text{tag}}]\\} = \\min\\{23.6, 28.0\\} = 23.6 $$\n最优方案是采用 $a=8$ 对齐的方案。它比 $a=16$ 方案产生更低的预期分配大小。\n\n最后一步是使用这个最优方案计算相对于基线方案的分配内存的分数减少量。公式为：\n$$ \\text{Savings} = \\frac{\\mathbb{E}[\\text{alloc}_{\\text{baseline}}] - \\min\\{\\mathbb{E}[\\text{alloc}_{a=8,\\text{tag}}], \\mathbb{E}[\\text{alloc}_{a=16,\\text{tag}}]\\}}{\\mathbb{E}[\\text{alloc}_{\\text{baseline}}]} $$\n代入计算出的值：\n$$ \\text{Savings} = \\frac{31.2 - 23.6}{31.2} = \\frac{7.6}{31.2} $$\n现在，我们计算小数值：\n$$ \\frac{7.6}{31.2} \\approx 0.2435897435... $$\n四舍五入到四位有效数字，我们得到 $0.2436$。\n这表示每个对象在已分配内存上预期节省了约 $24.36\\%$。", "answer": "$$\\boxed{0.2436}$$", "id": "3658034"}, {"introduction": "除了堆和栈，最快的可用内存是CPU的寄存器文件。高效使用寄存器或许是编译器执行的最关键的内存管理任务。当寄存器不足时，一些变量必须被“溢出”到栈内存中。本问题揭示了图论中的一个理论概念——着色数（chromatic number）——与寄存器分配这一实际任务之间的优美联系。你将推导出可用寄存器数量、变量冲突结构以及溢出所需的最少栈槽数量之间的精确关系。[@problem_id:3658122]", "problem": "一个编译器后端通过对一个干涉图进行图着色来执行寄存器分配。考虑一个程序点集，其中临时变量的活跃性产生一个无向干涉图 $G = (V,E)$，其顶点是临时变量，其边连接同时活跃因此不能共享存储位置的临时变量对。$G$ 的一个正常着色是一个映射 $\\kappa : V \\to \\{1,2,\\dots,c\\}$，使得相邻顶点接收不同的颜色。色数 $\\chi(G)$ 是使得存在一个使用 $c$ 种颜色的正常着色的最小 $c \\in \\mathbb{N}$。\n\n给定正好 $R \\in \\mathbb{N}$ 个机器寄存器。溢出被建模为将一个临时变量分配到一个栈槽。假设有以下存储模型和约束：\n\n- 每个存储位置（无论是寄存器还是栈槽）对应一种不同的颜色；两个相互干涉的临时变量（即在 $G$ 中有一条边相连）不能被分配到同一个存储位置。\n- 每个临时变量在其整个活跃范围内被精确分配到一个存储位置（没有活跃范围分裂）。\n- 栈槽可以在活跃范围不重叠的临时变量之间重用，这与图着色中的情况完全相同。\n- 就本问题而言，插入加载/存储指令不会改变 $G$ 中原始临时变量之间的干涉关系。\n\n令 $S^{\\star}(G,R)$ 表示所需的最小栈槽数，使得所有临时变量都能被分配到 $R$ 个寄存器之一或栈槽之一，而不违反干涉约束。\n\n从图着色和色数的核心定义以及上述存储模型出发，推导出一个必要且充分的关系，该关系以 $\\chi(G)$ 和 $R$ 的函数形式，用封闭形式表示 $S^{\\star}(G,R)$。你的最终答案必须是仅含 $\\chi(G)$ 和 $R$ 的单个封闭形式解析表达式。不要提供不等式或方程式作为最终答案；请提供表达式本身。不需要进行数值舍入。", "solution": "问题要求推导 $S^{\\star}(G,R)$ 的封闭形式表达式，$S^{\\star}(G,R)$ 是在给定一个色数为 $\\chi(G)$ 的干涉图 $G$ 和一组 $R$ 个机器寄存器的情况下，对临时变量进行有效分配所需的最小栈槽数。\n\n首先，让我们将所提供的存储模型形式化。问题陈述，每个存储位置对应一种不同的颜色。我们有 $R$ 个机器寄存器。这些寄存器可以被看作是可用于分配的 $R$ 种不同的颜色。除了寄存器，我们还可以使用栈槽。问题陈述，栈槽可以在活跃范围不重叠的临时变量之间重用，这正是图着色所建模的约束。因此，如果我们决定使用 $S$ 个栈槽，这些栈槽将提供 $S$ 种额外的、不同的颜色。可用于分配的唯一颜色总数是来自寄存器的颜色和来自栈槽的颜色之和。令 $C_{\\text{total}}$ 为可用颜色的总数。如果我们使用 $S$ 个栈槽，则：\n$$C_{\\text{total}} = R + S$$\n\n图着色的基本约束是，要使图 $G$ 的正常着色存在，可用颜色的数量必须至少为色数 $\\chi(G)$。色数 $\\chi(G)$ 定义为对 $G$ 进行正常着色所需的最小颜色数。在我们的上下文中，“正常着色”对应于将临时变量有效分配到存储位置，使得没有两个相互干涉的临时变量（即 $G$ 中的相邻顶点）被分配到相同的位置。\n\n因此，为了使有效分配成为可能，可用颜色的总数 $C_{\\text{total}}$ 必须大于或等于干涉图的色数 $\\chi(G)$。这给了我们必要条件：\n$$C_{\\text{total}} \\ge \\chi(G)$$\n\n代入 $C_{\\text{total}}$ 的表达式，我们得到：\n$$R + S \\ge \\chi(G)$$\n\n我们被要求找到 $S^{\\star}(G,R)$，即所需的*最小*栈槽数。因此，我们正在寻找满足此不等式的最小非负整数 $S$。我们可以重新整理不等式以求解 $S$：\n$$S \\ge \\chi(G) - R$$\n\n栈槽数 $S$ 必须是一个非负整数，因为我们不能有负数个物理存储位置。所以，我们对 $S$ 有两个约束：\n1. $S \\ge \\chi(G) - R$\n2. $S \\ge 0$\n\n为了找到满足这两个条件的最小整数 $S$，我们可以将它们结合起来。$S$ 的值必须大于或等于 $0$ 和 $\\chi(G) - R$。这等价于说 $S$ 必须大于或等于这两个值的最大值：\n$$S \\ge \\max(0, \\chi(G) - R)$$\n\n因为我们寻求最小栈槽数 $S^{\\star}(G,R)$，我们必须选择满足此条件的最小整数值 $S$。由于 $\\chi(G)$ 和 $R$ 是整数，量 $\\chi(G) - R$ 也是一个整数。因此，$S$ 的最小整数值恰好是 $\\max(0, \\chi(G) - R)$。\n\n让我们通过考虑两种情况来检验这个结果：\n\n情况1：可用寄存器的数量足以对图进行着色，即 $R \\ge \\chi(G)$。\n在这种情况下，$\\chi(G) - R \\le 0$。表达式变为：\n$$S^{\\star}(G,R) = \\max(0, \\chi(G) - R) = 0$$\n这是正确的，因为如果足够多的寄存器可以为图着色，则无需将任何临时变量溢出到栈中，因此所需的最小栈槽数为 $0$。\n\n情况2：可用寄存器的数量不足以为图着色，即 $R  \\chi(G)$。\n在这种情况下，$\\chi(G) - R > 0$。表达式变为：\n$$S^{\\star}(G,R) = \\max(0, \\chi(G) - R) = \\chi(G) - R$$\n这也是正确的。所需的颜色总数是 $\\chi(G)$。我们有来自寄存器的 $R$ 种颜色，因此我们缺少 $\\chi(G) - R$ 种颜色。每个栈槽提供一种额外的颜色，因此我们正好需要 $\\chi(G) - R$ 个栈槽来满足着色要求。颜色总数变为 $R + (\\chi(G) - R) = \\chi(G)$，这是所需的最小值。\n\n这证实了推导出的表达式是必要且充分的。它是必要的，因为任何更少的栈槽都会导致颜色总数小于 $\\chi(G)$，从而使正常着色变得不可能。它是充分的，因为有了这个数量的栈槽，颜色总数 $\\ge \\chi(G)$，这保证了正常着色的存在。该表达式是按要求以 $\\chi(G)$ 和 $R$ 表示的封闭形式函数。", "answer": "$$\\boxed{\\max(0, \\chi(G) - R)}$$", "id": "3658122"}]}