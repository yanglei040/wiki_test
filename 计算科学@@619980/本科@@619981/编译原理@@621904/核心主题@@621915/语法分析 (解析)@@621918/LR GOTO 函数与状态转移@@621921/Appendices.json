{"hands_on_practices": [{"introduction": "要真正掌握LR分析中状态机构建的核心，没有什么比亲手追踪`goto`函数的执行过程更有效了。这个练习将带你深入`goto`函数的内部工作原理，通过一个包含重复非终结符的简单文法，你将看到分析器如何为同一个非终结符在不同上下文中的出现创建出不同的状态。这个练习旨在夯实你对状态转移确定性过程的理解，这是构建任何LR分析器的基石([@problem_id:3655315])。", "problem": "考虑上下文无关文法 $G$，其开始符号为 $S$，产生式为 $S \\to A A$ 和 $A \\to a A \\mid b$。将该文法增广为 $S' \\to S$。使用 $\\mathrm{LR}(0)$（从左到右，最右逆向推导）项目的定义、项目集上的 $\\operatorname{closure}$ 算子以及项目集上的 $\\operatorname{goto}$ 转移函数，从 $I_0 = \\operatorname{closure}(\\{S' \\to \\cdot S\\})$ 开始，构造 $\\mathrm{LR}(0)$ 项目集的规范族。令 $K_1$ 表示项目集 $\\operatorname{goto}(I_0, A)$ 的核心，这对应于在产生式 $S \\to A A$ 中越过第一个 $A$。令 $I^\\star = \\operatorname{goto}(I_0, A)$，此时点位于 $S \\to A A$ 中两个 $A$ 之间，并令 $K_2$ 表示项目集 $\\operatorname{goto}(I^\\star, A)$ 的核心，这对应于在同一产生式中越过第二个 $A$。仅使用 $\\mathrm{LR}(0)$ 项目、$\\operatorname{closure}$ 和 $\\operatorname{goto}$ 的核心定义，推导出这些状态，并确定集合基数 $\\lvert K_1 \\cup K_2 \\rvert$ 的确切值。请以单个整数形式提供最终答案，不带单位。无需四舍五入。", "solution": "问题要求计算两个核心集 $K_1$ 和 $K_2$ 的并集的基数，这两个核心集是由给定文法的 $\\mathrm{LR}(0)$ 项目集规范族的构造过程派生出来的。\n\n首先，我们通过正式定义文法和所需的操作来建立问题背景。\n\n给定的上下文无关文法 $G$ 具有以下产生式：\n$S \\to A A$\n$A \\to a A$\n$A \\to b$\n其中 $S$ 是开始符号，$A$ 是非终结符，$a, b$ 是终结符。\n\n该文法通过一个新的开始符号 $S'$ 和一个新的产生式 $S' \\to S$ 进行增广。增广文法 $G'$ 为：\n$S' \\to S$\n$S \\to A A$\n$A \\to a A$\n$A \\to b$\n\n规范 $\\mathrm{LR}(0)$ 项目集的构造依赖于两个函数：$\\operatorname{closure}$ 和 $\\operatorname{goto}$。\n\n一个 $\\mathrm{LR}(0)$ 项目是一个在其产生式右部（RHS）的某个位置带有点“.”的产生式。一个项目集的核心由初始项目 $S' \\to \\cdot S$ 和所有点不在产生式右部开头的项目组成。\n\n项目集 $I$ 的 $\\operatorname{closure}$ 计算如下：\n1. $I$ 中的每个项目都在 $\\operatorname{closure}(I)$ 中。\n2. 如果项目 $[B \\to \\alpha \\cdot C \\beta]$ 在 $\\operatorname{closure}(I)$ 中，并且 $C \\to \\gamma$ 是文法中的一个产生式，那么项目 $[C \\to \\cdot\\gamma]$ 也在 $\\operatorname{closure}(I)$ 中。\n3. 重复此过程，直到没有新项目可以添加到 $\\operatorname{closure}(I)$ 中。\n\n对于项目集 $I$ 和文法符号 $X$，$\\operatorname{goto}$ 函数 $\\operatorname{goto}(I, X)$ 定义为 $\\operatorname{closure}(\\{[B \\to \\alpha X \\cdot \\beta] \\mid [B \\to \\alpha \\cdot X \\beta] \\in I\\})$。\n\n我们按照问题中概述的步骤逐一进行。\n\n步骤 1：计算初始项目集 $I_0 = \\operatorname{closure}(\\{S' \\to \\cdot S\\})$。\n我们从核心项目 $\\{S' \\to \\cdot S\\}$ 开始。\n- 点位于非终结符 $S$ 之前。我们必须添加所有 $S$ 的产生式，并将点置于开头。$S$ 的唯一产生式是 $S \\to A A$。因此我们添加项目 $S \\to \\cdot A A$。集合变为 $\\{S' \\to \\cdot S, S \\to \\cdot A A\\}$。\n- 现在，项目 $S \\to \\cdot A A$ 的点在非终结符 $A$ 之前。我们必须添加所有 $A$ 的产生式，并将点置于开头。这些是 $A \\to a A$ 和 $A \\to b$。因此我们添加项目 $A \\to \\cdot a A$ 和 $A \\to \\cdot b$。\n- 集合现在是 $\\{S' \\to \\cdot S, S \\to \\cdot A A, A \\to \\cdot a A, A \\to \\cdot b\\}$。\n- 新添加的项目在终结符（$a$ 和 $b$）之前有点，所以闭包过程终止。\n因此，初始项目集为：\n$$I_0 = \\{ S' \\to \\cdot S, S \\to \\cdot A A, A \\to \\cdot a A, A \\to \\cdot b \\}$$\n\n步骤 2：计算 $I^\\star = \\operatorname{goto}(I_0, A)$。\n为了计算 $\\operatorname{goto}(I_0, A)$，我们首先找到 $I_0$ 中所有点在 $A$ 之前的项目。唯一的此类项目是 $S \\to \\cdot A A$。\n我们将此项目中的点越过 $A$ 得到 $S \\to A \\cdot A$。这构成了新状态的核心。\n现在我们计算这个新核心的闭包：$I^\\star = \\operatorname{closure}(\\{S \\to A \\cdot A\\})$。\n- 项目 $S \\to A \\cdot A$ 的点在非终结符 $A$ 之前。我们必须添加所有 $A$ 的产生式，并将点置于开头。这些是 $A \\to \\cdot a A$ 和 $A \\to \\cdot b$。\n- 集合现在是 $\\{S \\to A \\cdot A, A \\to \\cdot a A, A \\to \\cdot b\\}$。\n- 新项目的点在终结符之前，所以闭包过程终止。\n因此，项目集 $I^\\star$ 是：\n$$I^\\star = \\{ S \\to A \\cdot A, A \\to \\cdot a A, A \\to \\cdot b \\}$$\n\n步骤 3：确定核心 $K_1$。\n问题将 $K_1$ 定义为项目集 $I^\\star = \\operatorname{goto}(I_0, A)$ 的核心。一个项目集的核心是其中点不在产生式右部开头的项目的子集（如果存在，则加上初始项目 $S' \\to \\cdot S$）。\n在 $I^\\star$ 中，项目为 $\\{ S \\to A \\cdot A, A \\to \\cdot a A, A \\to \\cdot b \\}$。\n- 项目 $S \\to A \\cdot A$ 的点在第一个 $A$ 之后，所以它是一个核心项目。\n- 项目 $A \\to \\cdot a A$ 和 $A \\to \\cdot b$ 的点在产生式右部的开头，所以它们不是核心项目。\n因此，$I^\\star$ 的核心是：\n$$K_1 = \\{ S \\to A \\cdot A \\}$$\n\n步骤 4：计算 $\\operatorname{goto}(I^\\star, A)$。\n我们在 $I^\\star$ 中找到所有点在 $A$ 之前的项目。唯一的此类项目是 $S \\to A \\cdot A$。\n我们将点越过 $A$ 得到 $S \\to A A \\cdot$。这构成了新状态的核心。\n令这个新状态为 $I_{new} = \\operatorname{closure}(\\{S \\to A A \\cdot \\})$。\n- 在项目 $S \\to A A \\cdot$ 中，点位于产生式的末尾。这是一个归约项目。闭包操作无法添加新项目。\n因此，该项目集是：\n$$\\operatorname{goto}(I^\\star, A) = \\{ S \\to A A \\cdot \\}$$\n\n步骤 5：确定核心 $K_2$。\n问题将 $K_2$ 定义为项目集 $\\operatorname{goto}(I^\\star, A)$ 的核心。\n这个项目集是 $\\{ S \\to A A \\cdot \\}$。\n- 唯一的项目 $S \\to A A \\cdot$ 的点不在产生式右部的开头。因此，它是一个核心项目。\n核心 $K_2$ 是：\n$$K_2 = \\{ S \\to A A \\cdot \\}$$\n\n步骤 6：计算基数 $| K_1 \\cup K_2 |$。\n我们已经确定了两个核心集：\n$K_1 = \\{ S \\to A \\cdot A \\}$\n$K_2 = \\{ S \\to A A \\cdot \\}$\n\n这两个集合的并集是：\n$$K_1 \\cup K_2 = \\{ S \\to A \\cdot A, S \\to A A \\cdot \\}$$\n此集合中的两个项目 $S \\to A \\cdot A$ 和 $S \\to A A \\cdot$ 是不同的，因为点的位置不同。该集合包含两个唯一元素。\n因此，该集合的基数为 $2$。\n$$\\lvert K_1 \\cup K_2 \\rvert = 2$$", "answer": "$$\\boxed{2}$$", "id": "3655315"}, {"introduction": "文法的内在属性会直接体现在其LR自动机的状态特征上。这个练习聚焦于一个特殊但重要的场景：当一个文法允许从起始符号推导出空串（$\\epsilon$）时，初始状态本身就可能包含一个完整的项，从而成为一个“可归约”状态。通过分析这种情况下的`goto`函数行为，你将深入理解可空非终结符如何引入归约操作，这是理解和解决LR分析中移入-归约（shift-reduce）冲突的关键一步([@problem_id:3655312])。", "problem": "考虑一个上下文无关文法 $G$，其终结符字母表为 $\\{a\\}$，非终结符为 $\\{S,A\\}$，开始符号为 $S$，由以下产生式定义\n- $S \\to A$\n- $A \\to \\varepsilon$\n- $A \\to a$\n- $A \\to A\\,a$\n并考虑其增广形式，其中加入了新的开始产生式 $S' \\to S$。使用 LR(0)（从左到右扫描，最右推导，零前瞻）项目的基本定义、闭包操作 $\\operatorname{closure}(\\cdot)$ 和转移函数 $\\operatorname{goto}(\\cdot,\\cdot)$，从基本原理出发推导出规范初始项目集 $I_0 = \\operatorname{closure}(\\{\\,S' \\to \\cdot S\\,\\})$。证明 $I_0$ 包含至少一个完整项目（形式为 $A \\to \\alpha \\cdot$ 的项目），并解释为何这使得初始状态在 LR(0) 的意义下是可规约的。\n\n然后，对于每个使得 $\\operatorname{goto}(I_0,X)$ 非空的文法符号 $X$，显式地构造 $\\operatorname{goto}(I_0,X)$ 并确定其基数。最后，计算量\n$$\nN \\;=\\; \\sum_{X \\in \\{S,A,a\\}} \\bigl|\\operatorname{goto}(I_0,X)\\bigr|,\n$$\n其中求和范围是所有使得 $\\operatorname{goto}(I_0,X)$ 非空的 $X$。将你的最终答案以单个整数的形式给出。无需四舍五入。", "solution": "该问题要求我们使用 LR(0) 分析框架来分析给定的上下文无关文法 $G$。文法 $G$ 由终结符字母表 $\\{\\text{a}\\}$、非终结符字母表 $\\{S, A\\}$、开始符号 $S$ 和以下产生式定义：\n$P_1: S \\to A$\n$P_2: A \\to \\varepsilon$\n$P_3: A \\to a$\n$P_4: A \\to A\\,a$\n\n对于 LR(0) 分析，我们首先用一个新的开始符号 $S'$ 和一个新的产生式 $P_0: S' \\to S$ 来增广文法。文法符号为 $S, A, a$。\n\n第一步是计算规范初始项目集 $I_0$，它被定义为从增广产生式派生出的初始 LR(0) 项目的闭包。一个 LR(0) 项目是一个在其产生式右侧某处带有一个点 $\\cdot$ 的产生式。项目集 $I$ 的闭包计算如下：\n1. $I$ 中的每个项目都在 $\\operatorname{closure}(I)$ 中。\n2. 如果一个形式为 $B \\to \\alpha \\cdot C \\beta$ 的项目在 $\\operatorname{closure}(I)$ 中，并且 $C \\to \\gamma$ 是一个产生式，那么项目 $C \\to \\cdot \\gamma$ 也在 $\\operatorname{closure}(I)$ 中。\n重复应用这些规则，直到没有新的项目可以添加到 $\\operatorname{closure}(I)$ 中为止。\n\n我们来计算 $I_0 = \\operatorname{closure}(\\{S' \\to \\cdot S\\})$。\n1. 我们从集合 $J = \\{S' \\to \\cdot S\\}$ 开始。\n2. 项目 $S' \\to \\cdot S$ 在非终结符 $S$ 前面有一个点。因此，我们必须添加所有对应于 $S$ 的产生式的项目。$S$ 的唯一产生式是 $S \\to A$。这会向我们的集合中添加项目 $S \\to \\cdot A$。现在，$J = \\{S' \\to \\cdot S, S \\to \\cdot A\\}$。\n3. 新添加的项目 $S \\to \\cdot A$ 在非终结符 $A$ 前面有一个点。我们必须添加所有 $A$ 的产生式的项目。$A$ 的产生式是 $A \\to \\varepsilon$，$A \\to a$ 和 $A \\to A\\,a$。这会向我们的集合中添加项目 $A \\to \\cdot$，$A \\to \\cdot a$ 和 $A \\to \\cdot A\\,a$。现在，$J = \\{S' \\to \\cdot S, S \\to \\cdot A, A \\to \\cdot, A \\to \\cdot a, A \\to \\cdot A\\,a\\}$。\n4. 我们有另一个新项目 $A \\to \\cdot A\\,a$，在非终结符 $A$ 前面有一个点。我们必须再次添加所有 $A$ 的产生式的项目。然而，项目 $A \\to \\cdot$，$A \\to \\cdot a$ 和 $A \\to \\cdot A\\,a$ 已经在我们的集合 $J$ 中了。\n5. 当前集合中没有其他项目在非终结符前有点，可以导致新的项目添加。过程终止。\n\n规范初始项目集是：\n$$\nI_0 = \\{ S' \\to \\cdot S, S \\to \\cdot A, A \\to \\cdot, A \\to \\cdot a, A \\to \\cdot A\\,a \\}\n$$\n\n接下来，我们证明 $I_0$ 包含一个完整项目，并解释为什么这使得该状态是可规约的。一个完整项目是指点位于产生式右侧最末端的项目，例如 $B \\to \\gamma \\cdot$。检查项目集 $I_0$，我们可以看到项目 $A \\to \\cdot$。由于产生式 $A \\to \\varepsilon$ 的右侧是空字符串 $\\varepsilon$，所以点位于末端。因此，$A \\to \\cdot$ 是一个完整项目。\n\n在 LR 分析中，如果一个项目集对应的状态包含一个或多个完整项目，则称该状态是可规约的。当分析器处于这样一个状态时，它可以选择执行“规约”操作。对于状态 $I_0$，完整项目 $A \\to \\cdot$ 的存在意味着分析器可以使用产生式 $A \\to \\varepsilon$ 将栈顶的空字符串规约为非终结符 $A$。\n\n现在，我们必须为每个文法符号 $X \\in \\{S, A, a\\}$ 计算非空的 $\\operatorname{goto}(I_0, X)$。函数 $\\operatorname{goto}(I, X)$ 被定义为所有满足 $[B \\to \\alpha \\cdot X \\beta]$ 在 $I$ 中的项目 $[B \\to \\alpha X \\cdot \\beta]$ 的集合的闭包。\n\n1.  **计算 $\\operatorname{goto}(I_0, S)$**：\n    - 我们在 $I_0$ 中寻找形式为 $[B \\to \\alpha \\cdot S \\beta]$ 的项目。唯一的此类项目是 $S' \\to \\cdot S$。\n    - 我们将点移动过 $S$，得到项目 $S' \\to S \\cdot$。\n    - 我们计算这个新集合的闭包：$\\operatorname{goto}(I_0, S) = \\operatorname{closure}(\\{S' \\to S \\cdot\\})$。\n    - 项目 $S' \\to S \\cdot$ 是一个完整项目。点不在任何非终结符之前。因此，闭包操作不添加新项目。\n    - 所以，$\\operatorname{goto}(I_0, S) = \\{S' \\to S \\cdot\\}$。\n    - 基数为 $|\\operatorname{goto}(I_0, S)| = 1$。\n\n2.  **计算 $\\operatorname{goto}(I_0, A)$**：\n    - 我们在 $I_0$ 中寻找形式为 $[B \\to \\alpha \\cdot A \\beta]$ 的项目。有两个这样的项目：$S \\to \\cdot A$ 和 $A \\to \\cdot A\\,a$。\n    - 我们将点在两个项目中都移动过 $A$，得到集合 $\\{S \\to A \\cdot, A \\to A \\cdot a\\}$。\n    - 我们计算这个集合的闭包：$\\operatorname{goto}(I_0, A) = \\operatorname{closure}(\\{S \\to A \\cdot, A \\to A \\cdot a\\})$。\n    - 项目 $S \\to A \\cdot$ 是完整的。项目 $A \\to A \\cdot a$ 的点在一个终结符 $a$ 前面。这两种情况都不会导致闭包操作添加新项目。\n    - 所以，$\\operatorname{goto}(I_0, A) = \\{S \\to A \\cdot, A \\to A \\cdot a\\}$。\n    - 基数为 $|\\operatorname{goto}(I_0, A)| = 2$。\n\n3.  **计算 $\\operatorname{goto}(I_0, a)$**：\n    - 我们在 $I_0$ 中寻找形式为 $[B \\to \\alpha \\cdot a \\beta]$ 的项目。唯一的此类项目是 $A \\to \\cdot a$。\n    - 我们将点移动过 $a$，得到项目 $A \\to a \\cdot$。\n    - 我们计算这个新集合的闭包：$\\operatorname{goto}(I_0, a) = \\operatorname{closure}(\\{A \\to a \\cdot\\})$。\n    - 项目 $A \\to a \\cdot$ 是一个完整项目。闭包操作不添加新项目。\n    - 所以，$\\operatorname{goto}(I_0, a) = \\{A \\to a \\cdot\\}$。\n    - 基数为 $|\\operatorname{goto}(I_0, a)| = 1$。\n\n问题要求计算量 $N$，它是从 $I_0$ 出发的非空 $\\operatorname{goto}$ 集的基数之和。我们已经发现对于 $X \\in \\{S,A,a\\}$，$\\operatorname{goto}(I_0,X)$ 是非空的。\n和的计算如下：\n$$\nN \\;=\\; \\sum_{X \\in \\{S,A,a\\}} \\bigl|\\operatorname{goto}(I_0,X)\\bigr| \\;=\\; |\\operatorname{goto}(I_0, S)| + |\\operatorname{goto}(I_0, A)| + |\\operatorname{goto}(I_0, a)|\n$$\n代入计算出的基数：\n$$\nN \\;=\\; 1 + 2 + 1 \\;=\\; 4\n$$\n$N$ 的值为 $4$。", "answer": "$$\n\\boxed{4}\n$$", "id": "3655312"}, {"introduction": "理论的价值最终体现在实践中。这个练习将LR状态机构建与一个非常实际的编译器工程问题——文法转换——联系起来。你将为一个含有左递归的文法和其消除左递归后的等价文法分别构建LR(0)自动机，并比较它们的状态转移数量。通过这个对比，你将直观地感受到文法结构的选择如何直接影响最终分析器的复杂性，从而理解为何某些文法形式（如消除左递归）在解析器设计中更受青睐([@problem_id:3655358])。", "problem": "给定上下文无关文法 $G$，其产生式为 $E \\to T \\mid E + T$ 和 $T \\to n$。考虑增广文法 $S' \\to E$。仅使用从左到右扫描、反向最右推导（LR）且向前看符号数为0的核心定义，即 LR(0) 项目、$\\operatorname{closure}$ 函数和关于项目集的 $\\operatorname{goto}$ 函数的定义，为 $G$ 构建 LR(0) 项目集的规范族，并枚举这些集合之间针对每个文法符号 $X$（包括终结符和非终结符）的所有不同的非空 $\\operatorname{goto}(I, X)$ 转换。令 $N_{\\text{unfactored}}$ 表示这些不同转换的总数。\n\n接下来，通过使用标准的分解方法将其分解为一个尾非终结符来消除直接左递归，从而转换 $G$：$E \\to T E'$, $E' \\to + T E' \\mid \\epsilon$ 以及 $T \\to n$。再次用 $S' \\to E$ 进行增广，仅使用相同的核心定义构建 LR(0) 项目集的规范族，并枚举所有不同的非空 $\\operatorname{goto}(I, X)$ 转换。令 $N_{\\text{factored}}$ 表示这个总数。\n\n计算比率 $r = \\dfrac{N_{\\text{unfactored}}}{N_{\\text{factored}}}$ 并将你的最终答案表示为一个最简分数。不需要四舍五入。", "solution": "### 解答\n\n解答需要应用标准算法来为两个不同的文法构建 LR(0) 项目集的规范族。核心定义如下：\n\n- 一个文法 $G$ 的 **LR(0) 项目** 是 $G$ 的一个产生式，其右侧的某个位置有一个点。\n- **$\\operatorname{closure}$ 函数**：如果 $I$ 是一个项目集，$\\operatorname{closure}(I)$ 是满足以下条件的最小项目集：\n    1. $I$ 中的每个项目都在 $\\operatorname{closure}(I)$ 中。\n    2. 如果一个项目 $A \\to \\alpha \\cdot B \\beta$ 在 $\\operatorname{closure}(I)$ 中，且 $B \\to \\gamma$ 是一个产生式，那么项目 $B \\to \\cdot \\gamma$ 也在 $\\operatorname{closure}(I)$ 中。重复此过程，直到没有新项目可以添加。\n- **$\\operatorname{goto}$ 函数**：如果 $I$ 是一个项目集，而 $X$ 是一个文法符号，$\\operatorname{goto}(I, X)$ 被定义为所有项目 $A \\to \\alpha X \\cdot \\beta$ 的闭包，其中 $A \\to \\alpha \\cdot X \\beta$ 在 $I$ 中。\n\n我们将对每个文法应用这些定义。\n\n#### 第1部分：未分解文法 ($G_1$) 的分析\n\n第一个文法，用 $S' \\to E$ 增广后为：\n1. $S' \\to E$\n2. $E \\to E + T$\n3. $E \\to T$\n4. $T \\to n$\n\n文法符号为：非终结符 $\\{S', E, T\\}$ 和终结符 $\\{+, n\\}$。\n\n我们构建 LR(0) 项目集的规范族：\n\n- **集合 $I_0$**: $\\operatorname{closure}(\\{S' \\to \\cdot E\\})$\n    $I_0 = \\{ S' \\to \\cdot E, E \\to \\cdot E+T, E \\to \\cdot T, T \\to \\cdot n \\}$\n\n- **从 $I_0$ 的转换**:\n    - $\\operatorname{goto}(I_0, E) = \\operatorname{closure}(\\{ S' \\to E\\cdot, E \\to E\\cdot+T \\}) =: I_1$\n        $I_1 = \\{ S' \\to E\\cdot, E \\to E\\cdot+T \\}$\n    - $\\operatorname{goto}(I_0, T) = \\operatorname{closure}(\\{ E \\to T\\cdot \\}) =: I_2$\n        $I_2 = \\{ E \\to T\\cdot \\}$\n    - $\\operatorname{goto}(I_0, n) = \\operatorname{closure}(\\{ T \\to n\\cdot \\}) =: I_3$\n        $I_3 = \\{ T \\to n\\cdot \\}$\n\n- **从 $I_1$ 的转换**:\n    - $\\operatorname{goto}(I_1, +) = \\operatorname{closure}(\\{ E \\to E+\\cdot T \\}) =: I_4$\n        由于点在非终结符 $T$ 之前，我们为 $T$ 添加项目。\n        $I_4 = \\{ E \\to E+\\cdot T, T \\to \\cdot n \\}$\n\n- **从 $I_2$ 和 $I_3$ 的转换**:\n    这些集合只包含归约项目，因此没有出向转换。\n\n- **从 $I_4$ 的转换**:\n    - $\\operatorname{goto}(I_4, T) = \\operatorname{closure}(\\{ E \\to E+T\\cdot \\}) =: I_5$\n        $I_5 = \\{ E \\to E+T\\cdot \\}$\n    - $\\operatorname{goto}(I_4, n) = \\operatorname{closure}(\\{ T \\to n\\cdot \\}) = I_3$\n\n- **从 $I_5$ 的转换**:\n    此集合只包含一个归约项目。\n\n不同的非空 $\\operatorname{goto}$ 转换是：\n1. $\\operatorname{goto}(I_0, E) = I_1$\n2. $\\operatorname{goto}(I_0, T) = I_2$\n3. $\\operatorname{goto}(I_0, n) = I_3$\n4. $\\operatorname{goto}(I_1, +) = I_4$\n5. $\\operatorname{goto}(I_4, T) = I_5$\n6. $\\operatorname{goto}(I_4, n) = I_3$\n\n这些转换的总数是 $N_{\\text{unfactored}} = 6$。\n\n#### 第2部分：分解后文法 ($G_2$) 的分析\n\n第二个文法，通过消除 $G_1$ 的左递归然后增广得到：\n1. $S' \\to E$\n2. $E \\to T E'$\n3. $E' \\to + T E'$\n4. $E' \\to \\epsilon$\n5. $T \\to n$\n\n文法符号为：非终结符 $\\{S', E, E', T\\}$ 和终结符 $\\{+, n\\}$。\n\n我们构建 LR(0) 项目集的规范族（用 $J_i$ 表示以区别于前一个集合）：\n\n- **集合 $J_0$**: $\\operatorname{closure}(\\{S' \\to \\cdot E\\})$\n    $J_0 = \\{ S' \\to \\cdot E, E \\to \\cdot TE', T \\to \\cdot n \\}$\n\n- **从 $J_0$ 的转换**:\n    - $\\operatorname{goto}(J_0, E) = \\operatorname{closure}(\\{ S' \\to E\\cdot \\}) =: J_1$\n        $J_1 = \\{ S' \\to E\\cdot \\}$\n    - $\\operatorname{goto}(J_0, T) = \\operatorname{closure}(\\{ E \\to T\\cdot E' \\}) =: J_2$\n        由于点在非终结符 $E'$ 之前，我们为 $E'$ 添加项目。注意 $E' \\to \\epsilon$ 被写成项目 $E' \\to \\cdot$。\n        $J_2 = \\{ E \\to T\\cdot E', E' \\to \\cdot +TE', E' \\to \\cdot \\}$\n    - $\\operatorname{goto}(J_0, n) = \\operatorname{closure}(\\{ T \\to n\\cdot \\}) =: J_3$\n        $J_3 = \\{ T \\to n\\cdot \\}$\n\n- **从 $J_1$ 和 $J_3$ 的转换**:\n    这些集合只包含归约项目，没有出向转换。\n\n- **从 $J_2$ 的转换**:\n    - $\\operatorname{goto}(J_2, E') = \\operatorname{closure}(\\{ E \\to TE'\\cdot \\}) =: J_4$\n        $J_4 = \\{ E \\to TE'\\cdot \\}$\n    - $\\operatorname{goto}(J_2, +) = \\operatorname{closure}(\\{ E' \\to +\\cdot TE' \\}) =: J_5$\n        由于点在非终结符 $T$ 之前，我们为 $T$ 添加项目。\n        $J_5 = \\{ E' \\to +\\cdot TE', T \\to \\cdot n \\}$\n\n- **从 $J_4$ 的转换**:\n    此集合只包含一个归约项目。\n\n- **从 $J_5$ 的转换**:\n    - $\\operatorname{goto}(J_5, T) = \\operatorname{closure}(\\{ E' \\to +T\\cdot E' \\}) =: J_6$\n        由于点在非终结符 $E'$ 之前，我们为 $E'$ 添加项目。\n        $J_6 = \\{ E' \\to +T\\cdot E', E' \\to \\cdot +TE', E' \\to \\cdot \\}$\n    - $\\operatorname{goto}(J_5, n) = \\operatorname{closure}(\\{ T \\to n\\cdot \\}) = J_3$\n\n- **从 $J_6$ 的转换**:\n    - $\\operatorname{goto}(J_6, E') = \\operatorname{closure}(\\{ E' \\to +TE'\\cdot \\}) =: J_7$\n        $J_7 = \\{ E' \\to +TE'\\cdot \\}$\n    - $\\operatorname{goto}(J_6, +) = \\operatorname{closure}(\\{ E' \\to \\cdot +TE' \\}) = J_5$\n\n- **从 $J_7$ 的转换**:\n    此集合只包含一个归约项目。\n\n不同的非空 $\\operatorname{goto}$ 转换是：\n1. $\\operatorname{goto}(J_0, E) = J_1$\n2. $\\operatorname{goto}(J_0, T) = J_2$\n3. $\\operatorname{goto}(J_0, n) = J_3$\n4. $\\operatorname{goto}(J_2, E') = J_4$\n5. $\\operatorname{goto}(J_2, +) = J_5$\n6. $\\operatorname{goto}(J_5, T) = J_6$\n7. $\\operatorname{goto}(J_5, n) = J_3$\n8. $\\operatorname{goto}(J_6, E') = J_7$\n9. $\\operatorname{goto}(J_6, +) = J_5$\n\n这些转换的总数是 $N_{\\text{factored}} = 9$。\n\n#### 第3部分：计算比率\n\n我们需要计算比率 $r = \\dfrac{N_{\\text{unfactored}}}{N_{\\text{factored}}}$。\n使用前面部分的结果：\n$N_{\\text{unfactored}} = 6$\n$N_{\\text{factored}} = 9$\n\n比率为：\n$$r = \\frac{6}{9}$$\n将此分数化为最简形式，我们将分子和分母同时除以它们的最大公约数，即 $3$。\n$$r = \\frac{6 \\div 3}{9 \\div 3} = \\frac{2}{3}$$\n最终答案是 $\\frac{2}{3}$。", "answer": "$$\\boxed{\\frac{2}{3}}$$", "id": "3655358"}]}