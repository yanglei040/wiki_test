{"hands_on_practices": [{"introduction": "一个 LR 自动机的结构并非随意的，它直接反映了其底层文法的特性。本练习将引导你亲手比较两个文法——一个左递归，一个右递归，它们都能生成相同的语言。通过为每个文法构建初始状态，你将具体地看到不同的递归形式如何导致自动机在结构特性上的差异，这是文法设计中的一个关键洞见。[@problem_id:3655045]", "problem": "考虑字母表 $\\{a,b\\}$ 上的语言，该语言由所有非空字符串组成，记作 $L = \\{a,b\\}^{+}$。为 $L$ 构建两个上下文无关文法：一个左递归文法 $G_{L}$ 和一个右递归文法 $G_{R}$，每个文法都用一个新的起始符号 $S'$ 和产生式 $S' \\to S$ 进行增广。使用以下明确的产生式：\n- 左递归文法 $G_{L}$：$S' \\to S$, $S \\to S a$, $S \\to S b$, $S \\to a$, $S \\to b$。\n- 右递归文法 $G_{R}$：$S' \\to S$, $S \\to a S$, $S \\to b S$, $S \\to a$, $S \\to b$。\n\n对于每个文法，使用标准的 $LR(0)$ 定义，从规范的初始项目集 $I_{0} = \\operatorname{closure}(\\{S' \\to \\cdot S\\})$ 开始，构建 $LR(0)$ 自动机状态：\n- 一个 $LR(0)$ 项目的形式为 $A \\to \\alpha \\cdot \\beta$。\n- 闭包操作 $\\operatorname{closure}(I)$ 对每个形如 $A \\to \\alpha \\cdot B \\beta$ 的项目（其中非终结符 $B$ 紧跟在点后），添加 $B$ 的所有产生式对应的项目 $B \\to \\cdot \\gamma$，重复此过程直到达到不动点。\n- 对于文法符号 $X$，转移 $\\operatorname{goto}(I,X)$ 将 $I$ 中所有 $X$ 紧跟在点后的项目中的点越过 $X$，然后对结果集取闭包。\n\n通过广度优先搜索（BFS）遍历自动机，其中 BFS 代表广度优先搜索。定义状态的深度为从 $I_{0}$ 到该状态在 BFS 树中最短路径的长度（边的数量）。定义状态的广度为该状态中 $LR(0)$ 项目的数量（其项目集的基数）。BFS 队列规则如下：\n- 从深度为 $0$ 的 $I_{0}$ 开始。\n- 当扩展一个状态时，按照固定的顺序 $a$、$b$、$S$ 为文法符号生成出向转移。\n- 仅将新发现的状态入队（如果一个等价的项目集已经被发现，则不入队）。\n- “前五个状态”指的是由该 BFS 发现的前 $5$ 个不同的状态，包括 $I_{0}$。\n\n对于每个文法 $G_{L}$ 和 $G_{R}$，令 $M$ 为前 $5$ 个发现的状态的 $\\text{depth(state)} \\times \\text{breadth(state)}$ 之和。计算差值\n$$\\Delta \\;=\\; M(G_{R}) \\;-\\; M(G_{L}).$$\n以单个精确整数形式提供 $\\Delta$。不需要四舍五入，最终答案中不应包含任何单位。", "solution": "问题陈述被验证为具有科学依据、定义明确且客观。这是一个关于构建 $LR(0)$ 自动机的编译器理论中的标准问题。所有的定义、文法和步骤都明确且正确地陈述，从而可以得出一个唯一且有意义的解。\n\n我们将遵循指定的广度优先搜索（BFS）程序，为每个文法 $G_L$ 和 $G_R$ 构建前五个 $LR(0)$ 自动机状态。对于每个状态，我们将确定其深度（从初始状态 $I_0$ 出发的最短路径长度）和广度（状态中 $LR(0)$ 项目的数量）。然后我们将为每个文法计算所需的度量 $M$，并求出它们的差值 $\\Delta$。\n\n**第一部分：左递归文法 $G_{L}$ 的分析**\n\n增广左递归文法 $G_L$ 由以下产生式给出：\n$S' \\to S$\n$S \\to S a$\n$S \\to S b$\n$S \\to a$\n$S \\to b$\n\n我们通过构建初始状态 $I_0$ 来开始 BFS。\n状态 $I_0$：该状态是初始项目 $\\{S' \\to \\cdot S\\}$ 的闭包。闭包操作要求我们添加所有非终结符 $S$ 的产生式，并将点放在开头。\n$I_0 = \\operatorname{closure}(\\{S' \\to \\cdot S\\}) = \\{S' \\to \\cdot S, S \\to \\cdot S a, S \\to \\cdot S b, S \\to \\cdot a, S \\to \\cdot b\\}$。\n对于此状态，$\\operatorname{depth}(I_0) = 0$ 且 $\\operatorname{breadth}(I_0) = 5$。\n对 $M(G_L)$ 的贡献是 $\\operatorname{depth}(I_0) \\times \\operatorname{breadth}(I_0) = 0 \\times 5 = 0$。\nBFS 队列现在是 $[I_0]$。我们已经发现了 $1$ 个状态。\n\n接下来，我们按照 $a, b, S$ 的顺序为文法符号计算转移来扩展 $I_0$。\n- $\\operatorname{goto}(I_0, a)$：$I_0$ 中的相关项目是 $S \\to \\cdot a$。移动点之后，我们得到 $\\{S \\to a \\cdot\\}$。由于点后没有非终结符，该集合的闭包就是它本身。\n令 $I_1 = \\{S \\to a \\cdot\\}$。这是一个新状态。\n$\\operatorname{depth}(I_1) = \\operatorname{depth}(I_0) + 1 = 1$。$\\operatorname{breadth}(I_1) = 1$。\n对 $M(G_L)$ 的贡献：$1 \\times 1 = 1$。我们将 $I_1$ 入队。我们已经发现了 $2$ 个状态。\n\n- $\\operatorname{goto}(I_0, b)$：相关项目是 $S \\to \\cdot b$。移动点之后，我们得到 $\\{S \\to b \\cdot\\}$。其闭包是集合本身。\n令 $I_2 = \\{S \\to b \\cdot\\}$。这是一个新状态。\n$\\operatorname{depth}(I_2) = \\operatorname{depth}(I_0) + 1 = 1$。$\\operatorname{breadth}(I_2) = 1$。\n对 $M(G_L)$ 的贡献：$1 \\times 1 = 1$。我们将 $I_2$ 入队。我们已经发现了 $3$ 个状态。\n\n- $\\operatorname{goto}(I_0, S)$：相关项目是 $S' \\to \\cdot S$、$S \\to \\cdot S a$ 和 $S \\to \\cdot S b$。移动点之后，我们得到 $\\{S' \\to S \\cdot, S \\to S \\cdot a, S \\to S \\cdot b\\}$。其闭包是集合本身。\n令 $I_3 = \\{S' \\to S \\cdot, S \\to S \\cdot a, S \\to S \\cdot b\\}$。这是一个新状态。\n$\\operatorname{depth}(I_3) = \\operatorname{depth}(I_0) + 1 = 1$。$\\operatorname{breadth}(I_3) = 3$。\n对 $M(G_L)$ 的贡献：$1 \\times 3 = 3$。我们将 $I_3$ 入队。我们已经发现了 $4$ 个状态。\n\nBFS 队列现在是 $[I_1, I_2, I_3]$。我们已经发现了 $4$ 个状态，还需要一个。我们按顺序出队并扩展状态。$I_1$ 和 $I_2$ 是没有出向转移的规约状态。我们扩展 $I_3$。\n- 扩展 $I_3$：我们为 $a, b, S$ 计算转移。\n$\\operatorname{goto}(I_3, a)$：相关项目是 $S \\to S \\cdot a$。移动点之后，我们得到 $\\{S \\to S a \\cdot\\}$。其闭包是集合本身。\n令 $I_4 = \\{S \\to S a \\cdot\\}$。这是一个新状态。\n$\\operatorname{depth}(I_4) = \\operatorname{depth}(I_3) + 1 = 2$。$\\operatorname{breadth}(I_4) = 1$。\n对 $M(G_L)$ 的贡献：$2 \\times 1 = 2$。我们已经发现了 $5$ 个状态。\n\n我们已经找到了前 $5$ 个状态：$I_0, I_1, I_2, I_3, I_4$。现在我们可以计算 $M(G_L)$。\n$M(G_L) = (\\operatorname{depth}(I_0) \\times \\operatorname{breadth}(I_0)) + (\\operatorname{depth}(I_1) \\times \\operatorname{breadth}(I_1)) + (\\operatorname{depth}(I_2) \\times \\operatorname{breadth}(I_2)) + (\\operatorname{depth}(I_3) \\times \\operatorname{breadth}(I_3)) + (\\operatorname{depth}(I_4) \\times \\operatorname{breadth}(I_4))$\n$M(G_L) = (0 \\times 5) + (1 \\times 1) + (1 \\times 1) + (1 \\times 3) + (2 \\times 1) = 0 + 1 + 1 + 3 + 2 = 7$。\n\n**第二部分：右递归文法 $G_{R}$ 的分析**\n\n增广右递归文法 $G_R$ 由以下产生式给出：\n$S' \\to S$\n$S \\to a S$\n$S \\to b S$\n$S \\to a$\n$S \\to b$\n\n我们从状态 $I_0$ 开始构建。\n状态 $I_0$：该状态是 $\\{S' \\to \\cdot S\\}$ 的闭包。这会添加 $S$ 的所有产生式。\n$I_0 = \\operatorname{closure}(\\{S' \\to \\cdot S\\}) = \\{S' \\to \\cdot S, S \\to \\cdot a S, S \\to \\cdot b S, S \\to \\cdot a, S \\to \\cdot b\\}$。\n$\\operatorname{depth}(I_0) = 0$ 且 $\\operatorname{breadth}(I_0) = 5$。\n对 $M(G_R)$ 的贡献：$0 \\times 5 = 0$。\nBFS 队列是 $[I_0]$。我们已经发现了 $1$ 个状态。\n\n接下来，我们用 $a, b, S$ 的转移来扩展 $I_0$。\n- $\\operatorname{goto}(I_0, a)$：相关项目是 $S \\to \\cdot a S$ 和 $S \\to \\cdot a$。移动点之后，我们得到集合 $\\{S \\to a \\cdot S, S \\to a \\cdot\\}$。我们必须计算这个集合的闭包。项目 $S \\to a \\cdot S$ 的点后有一个非终结符 $S$，所以我们添加 $S$ 的所有产生式。\n令 $I_1 = \\{S \\to a \\cdot S, S \\to a \\cdot, S \\to \\cdot a S, S \\to \\cdot b S, S \\to \\cdot a, S \\to \\cdot b\\}$。这是一个新状态。\n$\\operatorname{depth}(I_1) = 1$。$\\operatorname{breadth}(I_1) = 6$。\n对 $M(G_R)$ 的贡献：$1 \\times 6 = 6$。我们将 $I_1$ 入队。我们已经发现了 $2$ 个状态。\n\n- $\\operatorname{goto}(I_0, b)$：相关项目是 $S \\to \\cdot b S$ 和 $S \\to \\cdot b$。移动点并取闭包后（由于项目 $S \\to b \\cdot S$），我们得到：\n令 $I_2 = \\{S \\to b \\cdot S, S \\to b \\cdot, S \\to \\cdot a S, S \\to \\cdot b S, S \\to \\cdot a, S \\to \\cdot b\\}$。这是一个新状态。\n$\\operatorname{depth}(I_2) = 1$。$\\operatorname{breadth}(I_2) = 6$。\n对 $M(G_R)$ 的贡献：$1 \\times 6 = 6$。我们将 $I_2$ 入队。我们已经发现了 $3$ 个状态。\n\n- $\\operatorname{goto}(I_0, S)$：相关项目是 $S' \\to \\cdot S$。移动点之后，我们得到 $\\{S' \\to S \\cdot\\}$。其闭包是集合本身。\n令 $I_3 = \\{S' \\to S \\cdot\\}$。这是一个新状态。\n$\\operatorname{depth}(I_3) = 1$。$\\operatorname{breadth}(I_3) = 1$。\n对 $M(G_R)$ 的贡献：$1 \\times 1 = 1$。我们将 $I_3$ 入队。我们已经发现了 $4$ 个状态。\n\nBFS 队列现在是 $[I_1, I_2, I_3]$。我们还需要一个状态。我们出队并扩展 $I_1$。\n- 扩展 $I_1$：我们为 $a, b, S$ 计算转移。\n$\\operatorname{goto}(I_1, a)$：$I_1$ 中的相关项目是 $S \\to \\cdot a S$ 和 $S \\to \\cdot a$。移动点并取闭包后，我们得到一个与 $I_1$ 相同的状态。这不是一个新状态。\n$\\operatorname{goto}(I_1, b)$：相关项目是 $S \\to \\cdot b S$ 和 $S \\to \\cdot b$。这个转移导致状态 $I_2$，它也不是新状态。\n$\\operatorname{goto}(I_1, S)$：相关项目是 $S \\to a \\cdot S$。移动点之后，我们得到 $\\{S \\to a S \\cdot\\}$。其闭包是集合本身。\n令 $I_4 = \\{S \\to a S \\cdot\\}$。这是一个新状态。\n$\\operatorname{depth}(I_4) = \\operatorname{depth}(I_1) + 1 = 2$。$\\operatorname{breadth}(I_4) = 1$。\n对 $M(G_R)$ 的贡献：$2 \\times 1 = 2$。我们已经发现了 $5$ 个状态。\n\n我们已经找到了 $G_R$ 的前 $5$ 个状态：$I_0, I_1, I_2, I_3, I_4$。现在我们可以计算 $M(G_R)$。\n$M(G_R) = (\\operatorname{depth}(I_0) \\times \\operatorname{breadth}(I_0)) + (\\operatorname{depth}(I_1) \\times \\operatorname{breadth}(I_1)) + (\\operatorname{depth}(I_2) \\times \\operatorname{breadth}(I_2)) + (\\operatorname{depth}(I_3) \\times \\operatorname{breadth}(I_3)) + (\\operatorname{depth}(I_4) \\times \\operatorname{breadth}(I_4))$\n$M(G_R) = (0 \\times 5) + (1 \\times 6) + (1 \\times 6) + (1 \\times 1) + (2 \\times 1) = 0 + 6 + 6 + 1 + 2 = 15$。\n\n**第三部分：最终计算**\n\n我们需要计算差值 $\\Delta = M(G_R) - M(G_L)$。\n使用上面计算的值：\n$M(G_L) = 7$\n$M(G_R) = 15$\n$\\Delta = 15 - 7 = 8$。", "answer": "$$\\boxed{8}$$", "id": "3655045"}, {"introduction": "`CLOSURE` 闭包运算是 LR 自动机构造的核心，其精确执行至关重要。本练习设定了一个假设场景：在计算初始状态的闭包时，一个项目被错误地遗漏了。你的任务是扮演一名侦探，追踪这个错误引发的连锁反应，从而理解一个看似微小的疏忽如何导致一个根本上不完整且不正确的自动机。[@problem_id:3655043]", "problem": "考虑为增广文法构建具有零前瞻的从左到右、反向最右推导（LR(0)）项目的规范自动机。该文法的开始符号为 $S'$，产生式如下：\n$$\nS' \\to S,\\quad S \\to T\\ U,\\quad T \\to x\\ T\\ \\mid\\ y,\\quad U \\to z\\ U\\ \\mid\\ W,\\quad W \\to w,\n$$\n其中 $x$、$y$、$z$、$w$ 是终结符，$S$、$T$、$U$、$W$ 是非终结符。LR(0) 闭包函数 $\\operatorname{closure}(I)$ 对一个项目集 $I$ 的定义如下：从 $I$ 中的所有项目开始，对于当前集合中的任何形如 $A \\to \\alpha \\cdot B \\beta$ 的项目（其中 $B$ 是一个非终结符），将每个产生式 $B \\to \\gamma$ 作为项目 $B \\to \\cdot \\gamma$ 加入集合，重复此过程直到达到不动点。LR(0) goto 函数 $\\operatorname{goto}(I, X)$ 对文法符号 $X$ 的定义为：收集 $I$ 中所有形如 $A \\to \\alpha \\cdot X \\beta$ 的项目，构成集合 $\\{A \\to \\alpha X \\cdot \\beta\\}$，然后对其应用 $\\operatorname{closure}$ 函数求闭包。\n\n假设一位实践者错误地执行了初始闭包计算：从核心 $\\{S' \\to \\cdot S\\}$ 开始，他们加入了 $S \\to \\cdot T U$，然后在对非终结符 $T$ 求闭包时，他们只添加了 $T \\to \\cdot y$，错误地遗漏了 $T \\to \\cdot x T$。结果，他们的初始状态是\n$$\nI_{0}^{\\text{err}}=\\{S' \\to \\cdot S,\\ S \\to \\cdot T U,\\ T \\to \\cdot y\\},\n$$\n而不是正确的初始状态\n$$\nI_{0}^{\\text{true}}=\\{S' \\to \\cdot S,\\ S \\to \\cdot T U,\\ T \\to \\cdot x T,\\ T \\to \\cdot y\\}.\n$$\n\n仅使用上面给出的 LR(0) 闭包和 goto 的基本定义，并且不依赖任何预先制表的自动机，确定由于这一个遗漏，在错误构建的自动机中将总共缺少多少个 goto 转换（LR(0) 项目集构成的确定有限自动机（DFA）中的边）。对于这个问题，将“下游错误的 goto 边”定义为：存在于正确构建的 LR(0) 自动机中，但在错误构建的自动机中缺失的每一条 goto 边，这些缺失的边要么直接源于 $I_{0}^{\\text{err}}$ 的错误，要么源于任何仅因 $T \\to \\cdot x T$ 存在于初始闭包中才会存在的状态。\n\n给出你的最终答案，一个整数。无需四舍五入，无需单位。", "solution": "问题要求我们确定与正确的 LR(0) 自动机相比，错误构建的自动机中缺失的 `goto` 转换的总数。这个错误是在初始闭包计算过程中特定地遗漏了一个项目。\n\n给定的增广文法有以下产生式，其中终结符为 $\\{x, y, z, w\\}$，非终结符为 $\\{S', S, T, U, W\\}$：\n$$\n\\begin{aligned}\nS' \\to S \\\\\nS  \\to T\\ U \\\\\nT  \\to x\\ T \\\\\nT  \\to y \\\\\nU  \\to z\\ U \\\\\nU  \\to W \\\\\nW  \\to w\n\\end{aligned}\n$$\n\n分析过程首先是构建正确的 LR(0) 自动机 $M_{\\text{true}}$ 的相关部分，然后将其与根据指定错误构建的自动机 $M_{\\text{err}}$进行比较。缺失的转换是那些存在于 $M_{\\text{true}}$ 中，但由于初始遗漏的直接或间接后果而未在 $M_{\\text{err}}$ 中出现的转换。\n\n**1. 正确自动机的构建 ($M_{\\text{true}}$)**\n\n自动机的构建始于对初始项目 $\\{S' \\to \\cdot S\\}$ 求闭包。正确的初始状态 $I_{0}^{\\text{true}}$ 计算如下：\n$I_0 = \\operatorname{closure}(\\{S' \\to \\cdot S\\})$\n- 初始集合是 $\\{S' \\to \\cdot S\\}$。\n- 项目 $S' \\to \\cdot S$ 的点号后有一个非终结符 $S$，所以我们添加所有 $S$ 的产生式。这会加入 $S \\to \\cdot T U$。\n- 新项目 $S \\to \\cdot T U$ 的点号后有一个非终结符 $T$，所以我们添加所有 $T$ 的产生式。这会加入 $T \\to \\cdot x T$ 和 $T \\to \\cdot y$。\n- 没有更多项目可以添加。\n因此，正确的初始状态是：\n$$I_0 = \\{S' \\to \\cdot S,\\ S \\to \\cdot T U,\\ T \\to \\cdot x T,\\ T \\to \\cdot y\\}$$\n\n问题关注的是遗漏项目 $T \\to \\cdot x T$ 的后果。我们必须追踪所有依赖于此项目存在的转换。\n\n首先，考虑从 $I_0$ 出发的转换。项目 $T \\to \\cdot x T$ 的点号后是终结符 $x$。这使得在 $x$ 上有一个 `goto` 转换。\n$$ \\operatorname{goto}(I_0, x) = \\operatorname{closure}(\\{T \\to x \\cdot T\\}) $$\n新状态的核心是 $\\{T \\to x \\cdot T\\}$。为计算其闭包，我们检查点号后的文法符号，即非终结符 $T$。我们必须添加所有形如 $T \\to \\cdot \\gamma$ 的 $T$ 的产生式。这会加入 $T \\to \\cdot x T$ 和 $T \\to \\cdot y$。\n这样得到一个新状态，我们将其标记为 $I_3$：\n$$ I_3 = \\{T \\to x \\cdot T,\\ T \\to \\cdot x T,\\ T \\to \\cdot y\\} $$\n所以，在正确的自动机中，存在一个转换：\n$$ I_0 \\xrightarrow{x} I_3 $$\n\n现在，我们必须找出所有仅因状态 $I_3$ 存在而存在于 $M_{\\text{true}}$ 中的转换。这些是从 $I_3$ 出发的转换。我们使用 `goto` 函数对 $I_3$ 进行计算：\n- 对于符号 $T$：根据项目 $T \\to x \\cdot T$，我们有 $\\operatorname{goto}(I_3, T) = \\operatorname{closure}(\\{T \\to x T \\cdot\\})$。由于点号后没有符号，闭包就是核心本身。这创建了一个新状态 $I_9 = \\{T \\to x T \\cdot\\}$。该转换为：\n  $$ I_3 \\xrightarrow{T} I_9 $$\n- 对于符号 $x$：根据项目 $T \\to \\cdot x T$，我们有 $\\operatorname{goto}(I_3, x) = \\operatorname{closure}(\\{T \\to x \\cdot T\\})$。这与导致状态 $I_3$ 自身的计算完全相同。因此，我们有一个自环：\n  $$ I_3 \\xrightarrow{x} I_3 $$\n- 对于符号 $y$：根据项目 $T \\to \\cdot y$，我们有 $\\operatorname{goto}(I_3, y) = \\operatorname{closure}(\\{T \\to y \\cdot\\})$。这创建了一个状态 $I_4 = \\{T \\to y \\cdot\\}$。该转换为：\n  $$ I_3 \\xrightarrow{y} I_4 $$\n  （注意：状态 $I_4$ 也可以通过 $\\operatorname{goto}(I_0, y)$ 从 $I_0$ 到达，所以该状态本身并非完全依赖于 $I_3$，但这条到达它的特定转换是依赖的。）\n\n总而言之，$I_0$ 中项目 $T \\to \\cdot x T$ 的存在直接导致了转换 $I_0 \\xrightarrow{x} I_3$ 和状态 $I_3$ 的创建。而状态 $I_3$ 的存在又导致了三个转换 $I_3 \\xrightarrow{T} I_9$、$I_3 \\xrightarrow{x} I_3$ 和 $I_3 \\xrightarrow{y} I_4$ 的创建。\n\n**2. 错误自动机的构建 ($M_{\\text{err}}$)**\n\n实践者从一个错误的初始状态开始，该状态遗漏了一个项目：\n$$ I_{0}^{\\text{err}} = \\{S' \\to \\cdot S,\\ S \\to \\cdot T U,\\ T \\to \\cdot y\\} $$\n\n我们现在分析从 $I_{0}^{\\text{err}}$ 开始的自动机构建过程。为了找到“直接源于 $I_{0}^{\\text{err}}$”的缺失转换，我们计算其 `goto` 转换，并与正确的 $I_0$ 的转换进行比较。\n在 $I_{0}^{\\text{err}}$ 中，没有项目的点号后紧跟着符号 $x$。因此，集合 $\\{A \\to \\alpha \\cdot x \\beta \\mid A \\to \\alpha \\cdot x \\beta \\in I_{0}^{\\text{err}}\\}$ 是空的。\n这意味着 $\\operatorname{goto}(I_{0}^{\\text{err}}, x)$ 是未定义的。因此，存在于 $M_{\\text{true}}$ 中的转换 $I_0 \\xrightarrow{x} I_3$ 在 $M_{\\text{err}}$ 中不存在。这是第一个缺失的转换。\n\n根据问题描述，我们还必须计算“源于任何仅因 $T \\to \\cdot x T$ 存在而存在的状态的下游错误的 goto 边”。由于转换 $I_0 \\xrightarrow{x} I_3$ 缺失，状态 $I_3$ 在错误的自动机中永远不会被创建。它是一个从 $I_{0}^{\\text{err}}$ 不可达的状态。状态 $I_3$ 正是这样一个“仅因 $T \\to \\cdot x T$ 存在而存在的状态”。\n由于状态 $I_3$ 在 $M_{\\text{err}}$ 中不存在，其所有的出向 `goto` 转换也都不存在。这些就是下游缺失的边。根据前一节的确定，它们是：\n- $I_3 \\xrightarrow{T} I_9$\n- $I_3 \\xrightarrow{x} I_3$\n- $I_3 \\xrightarrow{y} I_4$\n\n在正确的自动机中，所有其他状态和转换都可以从 $I_0$ 通过不涉及从 $I_0$ 出发的 $x$ 转换的路径到达。例如，$\\operatorname{goto}(I_0, T)$ 产生状态 $I_2 = \\{S \\to T \\cdot U, U \\to \\cdot z U, U \\to \\cdot W, W \\to \\cdot w\\}$。此计算仅依赖于项目 $S \\to T \\cdot U$ 以及 $U$ 和 $W$ 的产生式，这些都不受初始错误的影响。因此，$\\operatorname{goto}(I_{0}^{\\text{err}}, T)$ 会正确地产生相同的状态 $I_2$，并且从 $I_2$ 可达的自动机部分也会被正确构建。\n\n**3. 结论**\n\n从初始状态中遗漏项目 $T \\to \\cdot x T$ 这一个错误，导致在错误构建的自动机中出现以下缺失的转换：\n1.  直接后果：从初始状态出发的关于 $x$ 的转换，$I_0 \\xrightarrow{x} I_3$。\n2.  下游后果：所有源于不存在的状态 $I_3$ 的转换。它们是 $I_3 \\xrightarrow{T} I_9$、$I_3 \\xrightarrow{x} I_3$ 和 $I_3 \\xrightarrow{y} I_4$。\n\n缺失的 `goto` 转换总数是这些转换之和，即 $1 + 3 = 4$。", "answer": "$$\n\\boxed{4}\n$$", "id": "3655043"}, {"introduction": "除了正确性，算法的效率同样重要。这个问题将我们的关注点从自动机构造的“是什么”转向“怎么做”，要求你分析 `CLOSURE` 闭包算法的两种不同实现的性能：一种基于工作列表，另一种基于递归。通过为一个通用文法推导这些方法的复杂度，你将对编译器工具背后的算法分析有更深刻的理解。[@problem_id:3655060]", "problem": "给定一个上下文无关文法 $G$，其终结符集为 $\\{a,b\\}$，非终结符集为 $\\{S,A\\}$，产生式为 $S \\to aA$ 和 $A \\to aA \\mid b$。在从左到右 (LR) 分析中，一个 $\\text{LR}(0)$ 项目是一个带有由点号表示的特殊位置的产生式。对一个项目集 $I$ 的 $\\operatorname{CLOSURE}$ 操作定义为：对于集合中的每个项目 $[X \\to \\alpha . Y \\beta]$ 和每个产生式 $Y \\to \\gamma$，重复添加项目 $[Y \\to . \\gamma]$，直到没有更多项目可以添加为止，所得到的最小不动点。考虑从初始集合 $I_0 = \\{[S \\to a . A]\\}$ 开始的两种数学上等价的 $\\operatorname{CLOSURE}$ 实现：\n- 一种工作列表队列实现，它维护一个累积项目集 $C$ 和一个先进先出队列 $W$，队列中存放的是当前点号位于非终结符之前的项目。初始时，$C := I_0$ 且 $W := I_0$。当 $W$ 非空时，它从队列中取出一个项目，如果该项目形式为 $[X \\to \\alpha . Y \\beta]$，则对于每个产生式 $Y \\to \\gamma$，若 $[Y \\to . \\gamma] \\notin C$，则将 $[Y \\to . \\gamma]$ 同时添加到 $C$ 和 $W$ 中。新项目按照文法中产生式的书写顺序入队。\n- 一种递归展开实现，它维护一个累积项目集 $C$，当遇到一个项目 $[X \\to \\alpha . Y \\beta]$ 时，递归地处理每个产生式 $Y \\to \\gamma$，如果 $[Y \\to . \\gamma]$ 不在 $C$ 中，则添加它，并且当添加的项目中的点号位于非终结符之前时，进行递归。递归访问产生式的顺序与它们在文法中的书写顺序相同。\n\n任务：\n1. 仅使用上述定义，计算文法 $G$ 的闭包 $C = \\operatorname{CLOSURE}(I_0)$，并确定其基数 $c = |C|$。\n2. 对于所描述的工作列表队列实现，确定在文法 $G$ 上从 $I_0$ 开始执行期间观察到的最大队列长度 $Q_{\\max}$，假设没有重复的项目入队。\n3. 对于所描述的递归展开实现，确定在文法 $G$ 上从 $I_0$ 开始的最大递归深度 $R_{\\max}$（度量为在最外层 $\\operatorname{CLOSURE}$ 调用之外，任何时刻活动的最大嵌套递归调用次数）。\n4. 现在推广到一个文法族 $G_n$，其非终结符为 $\\{S,A_1,\\dots,A_n\\}$，产生式为 $S \\to a A_1$，$A_i \\to a A_i \\mid A_{i+1}$ (对于 $i = 1,\\dots,n-1$)，以及 $A_n \\to a A_n \\mid b$。考虑 $I_0^{(n)} = \\{[S \\to a . A_1]\\}$。使用相同的两种实现和相同的产生式排序约定，以封闭形式推导以下三个关于 $n$ 的函数：闭包基数 $c(n) = |\\operatorname{CLOSURE}(I_0^{(n)})|$，最大工作列表队列长度 $Q_{\\max}(n)$，以及最大递归深度 $R_{\\max}(n)$。\n5. 最后，报告组合复杂度统计量\n$$\nF(n) \\;=\\; c(n) \\;+\\; Q_{\\max}(n) \\;+\\; R_{\\max}(n)\n$$\n的单一封闭形式解析表达式。你的最终答案必须是这个 $F(n)$，并以其最简封闭形式表示。不需要进行数值计算或四舍五入。", "solution": "该问题要求分析 LR 分析中的 $\\operatorname{CLOSURE}$ 操作，首先应用于一个特定文法 $G$，然后推广到一个文法族 $G_n$。我们将首先计算特定文法 $G$ 所需的量，然后推广结果以推导 $F(n)$ 的封闭形式表达式。\n\n文法 $G$ 由终结符集 $\\{a,b\\}$、非终结符集 $\\{S,A\\}$ 和以下产生式定义：\n1. $S \\to aA$\n2. $A \\to aA$\n3. $A \\to b$\n\n初始项目集是 $I_0 = \\{[S \\to a . A]\\}$。\n\n**第1部分：文法 $G$ 的闭包**\n\n我们计算 $C = \\operatorname{CLOSURE}(I_0) = \\operatorname{CLOSURE}(\\{[S \\to a . A]\\})$.\n1.  从初始集合开始: $C_0 = \\{[S \\to a . A]\\}$。\n2.  项目 $[S \\to a . A]$ 的点号位于非终结符 $A$ 之前。根据 $\\operatorname{CLOSURE}$ 的定义，我们必须为所有产生式 $A \\to \\gamma$ 添加形式为 $[A \\to . \\gamma]$ 的项目。\n3.  $A$ 的产生式是 $A \\to aA$ 和 $A \\to b$。这需要添加项目 $[A \\to . aA]$ 和 $[A \\to . b]$。\n4.  令新集合为 $C_1 = C_0 \\cup \\{[A \\to . aA], [A \\to . b]\\} = \\{[S \\to a . A], [A \\to . aA], [A \\to . b]\\}$。\n5.  现在我们必须检查新添加的项目是否需要进一步添加。新项目是 $[A \\to . aA]$ 和 $[A \\to . b]$。在这两种情况下，点号都位于终结符（$a$ 或 $b$）之前，而不是非终结符。因此，不能再添加更多项目。\n6.  过程终止，最终的闭包集是 $C = \\{[S \\to a . A], [A \\to . aA], [A \\to . b]\\}$。\n\n这个集合的基数是 $c = |C| = 3$。\n\n**第2部分：文法 $G$ 的工作列表队列实现**\n\n我们跟踪算法的执行，初始状态为 $C := I_0$ 和 $W := I_0$，其中 W 是一个先进先出队列。\n-   **初始状态：** $C = \\{[S \\to a . A]\\}$，$W = ([S \\to a . A])$。队列长度为 $|W|=1$。目前为止见到的最大长度是 $Q_{\\max} = 1$。\n-   **步骤1：** 出队 $[S \\to a . A]$。点号位于非终结符 $A$ 之前。我们处理 $A$ 的产生式：$A \\to aA$ 和 $A \\to b$。\n    -   对于 $A \\to aA$：项目 $[A \\to . aA]$ 不在 $C$ 中。将其添加到 $C$ 并入队到 $W$。\n        $C = \\{[S \\to a . A], [A \\to . aA]\\}$。\n        $W = ([A \\to . aA])$。现在 $|W|=1$。\n    -   对于 $A \\to b$：项目 $[A \\to . b]$ 不在 $C$ 中。将其添加到 $C$ 并入队到 $W$。\n        $C = \\{[S \\to a . A], [A \\to . aA], [A \\to . b]\\}$。\n        $W = ([A \\to . aA], [A \\to . b])$。现在 $|W|=2$。\n    -   观察到的最大队列长度现在是 $Q_{\\max} = 2$。\n-   **步骤2：** 出队 $[A \\to . aA]$。点号位于终结符 $a$ 之前，所以不执行任何操作。队列现在是 $W = ([A \\to . b])$，且 $|W|=1$。\n-   **步骤3：** 出队 $[A \\to . b]$。点号位于终结符 $b$ 之前，所以不执行任何操作。队列现在为空，$W = ()$，且 $|W|=0$。\n-   队列为空，算法终止。\n\n在此过程中观察到的最大队列长度是 $Q_{\\max} = 2$。\n\n**第3部分：文法 $G$ 的递归展开**\n\n过程从 $C = I_0 = \\{[S \\to a . A]\\}$ 开始，并对 $I_0$ 中的项目进行递归函数的初始调用。我们度量此初始调用之外的深度。\n-   **初始调用：** 一个函数，我们称之为 $\\operatorname{Expand}$，被调用于 $[S \\to a . A]$。这是递归深度1。\n-   在 $\\operatorname{Expand}([S \\to a . A])$ 内部：\n    -   点号位于非终结符 $A$ 之前。我们按顺序处理 $A$ 的产生式：$A \\to aA$，然后是 $A \\to b$。\n    -   对于 $A \\to aA$：项目是 $[A \\to . aA]$。它不在 $C$ 中，所以被添加。这个新项目中的点号位于终结符（$a$）之前，所以没有进行递归调用。\n    -   对于 $A \\to b$：项目是 $[A \\to . b]$。它不在 $C$ 中，所以被添加。这个新项目中的点号位于终结符（$b$）之前，所以没有进行递归调用。\n-   函数 $\\operatorname{Expand}([S \\to a . A])$ 完成时没有进行任何嵌套调用。\n任何时刻活动的最大嵌套递归调用次数是1。因此，$R_{\\max} = 1$。\n\n**第4部分：对文法 $G_n$ 的推广**\n\n文法 $G_n$ 有非终结符 $\\{S, A_1, \\dots, A_n\\}$ 和产生式：\n-   $S \\to a A_1$\n-   $A_i \\to a A_i \\mid A_{i+1}$ 对于 $i=1, \\dots, n-1$\n-   $A_n \\to a A_n \\mid b$\n\n初始集合是 $I_0^{(n)} = \\{[S \\to a . A_1]\\}$。\n\n**闭包基数 $c(n)$：**\n闭包计算从 $[S \\to a . A_1]$ 开始。\n-   $A_1$ 之前的点导致 $A_1$ 产生式的项目被添加：$[A_1 \\to . a A_1]$ 和 $[A_1 \\to . A_2]$。\n-   项目 $[A_1 \\to . A_2]$ 的点在 $A_2$ 之前，这又导致 $A_2$ 产生式的项目被添加：$[A_2 \\to . a A_2]$ 和 $[A_2 \\to . A_3]$。\n-   这产生了一个连锁反应。对于从 $1$ 到 $n-1$ 的每个 $i$，都会创建项目 $[A_i \\to . A_{i+1}]$，从而触发为 $A_{i+1}$ 添加项目。\n-   这个过程最终以项目 $[A_{n-1} \\to . A_n]$ 告终，该项目导致为 $A_n$ 的产生式添加项目：$[A_n \\to . a A_n]$ 和 $[A_n \\to . b]$。\n-   过程在此终止，因为所有新生成的项目中的点都在终结符之前。\n\n$\\operatorname{CLOSURE}(I_0^{(n)})$ 中的完整项目集是：\n1.  初始项目：$[S \\to a . A_1]$ (1 个项目)。\n2.  对于每个 $i \\in \\{1, \\dots, n-1\\}$，生成两个项目：$[A_i \\to . a A_i]$ 和 $[A_i \\to . A_{i+1}]$。这总共有 $2(n-1)$ 个项目。\n3.  对于 $A_n$，生成两个项目：$[A_n \\to . a A_n]$ 和 $[A_n \\to . b]$。这总共有 $2$ 个项目。\n\n总基数是 $c(n) = 1 + 2(n-1) + 2 = 1 + 2n - 2 + 2 = 2n + 1$。\n所以，$c(n) = 2n + 1$。\n\n**最大工作列表队列长度 $Q_{\\max}(n)$：**\n我们跟踪 $G_n$ 的队列状态。\n-   **初始：** $W = ([S \\to a . A_1])$。$|W|=1$。\n-   **步骤1：** 出队 $[S \\to a . A_1]$。入队 $[A_1 \\to . a A_1]$，然后 $[A_1 \\to . A_2]$。队列变为 $W = ([A_1 \\to . a A_1], [A_1 \\to . A_2])$。长度为 $|W|=2$。这是一个潜在的最大值。\n-   **步骤2：** 出队 $[A_1 \\to . a A_1]$。无操作。$|W|=1$。\n-   **步骤3：** 出队 $[A_1 \\to . A_2]$。这是一个点号位于非终结符 ($A_2$) 之前的项目。我们为 $A_2$ 的产生式入队项目：$[A_2 \\to . a A_2]$ 和 $[A_2 \\to . A_3]$。队列变为 $W = ([A_2 \\to . a A_2], [A_2 \\to . A_3])$。长度再次为 $|W|=2$。\n这个模式会重复。在每个阶段 $i=1, \\dots, n$，我们处理一个形式为 $[A_{i-1} \\to . A_i]$（对于 $i=1$ 则是 $[S \\to a . A_1]$）的项目。这导致两个新项目入队，使队列大小变为2。其中一个被处理但没有效果，使大小减至1。另一个继续这个链条。在任何时候，队列包含的项目都不超过两个。\n因此，对于任何 $n \\ge 1$，最大队列长度是 $Q_{\\max}(n) = 2$。\n\n**最大递归深度 $R_{\\max}(n)$：**\n递归算法的调用栈反映了文法中的依赖链。\n-   对 $[S \\to a . A_1]$ 的初始调用（深度1）处理 $A_1$ 的产生式。\n-   产生式 $A_1 \\to a A_1$ 导致添加 $[A_1 \\to . a A_1]$，这不会引起递归调用。\n-   产生式 $A_1 \\to A_2$ 导致添加 $[A_1 \\to . A_2]$，其点号在非终结符 $A_2$ 之前，导致对此新项目的递归调用。此调用处于深度2。\n-   此模式创建了一个递归调用链：\n    -   调用 $[S \\to a . A_1]$ (深度1)\n    -   ...调用 $[A_1 \\to . A_2]$ (深度2)\n    -   ...调用 $[A_2 \\to . A_3]$ (深度3)\n    -   ...\n    -   ...调用 $[A_{n-1} \\to . A_n]$ (深度 $n$)\n-   深度为 $n$ 的调用是针对 $[A_{n-1} \\to . A_n]$ 的。在此调用内部，我们处理 $A_n$ 的产生式，即 $A_n \\to a A_n$ 和 $A_n \\to b$。生成的项目 $[A_n \\to . a A_n]$ 和 $[A_n \\to . b]$ 的点号都在终结符之前，因此不会再有进一步的递归调用。\n然后调用栈回溯。嵌套调用的最大深度是 $n$。\n因此，$R_{\\max}(n) = n$。\n\n**第5部分：组合复杂度统计量 $F(n)$**\n\n我们被要求计算组合统计量 $F(n) = c(n) + Q_{\\max}(n) + R_{\\max}(n)$。\n代入推导出的表达式：\n$c(n) = 2n + 1$\n$Q_{\\max}(n) = 2$\n$R_{\\max}(n) = n$\n\n$$\nF(n) = (2n + 1) + 2 + n = 3n + 3\n$$\n$F(n)$ 的最简封闭形式表达式是 $3n + 3$。", "answer": "$$\\boxed{3n+3}$$", "id": "3655060"}]}