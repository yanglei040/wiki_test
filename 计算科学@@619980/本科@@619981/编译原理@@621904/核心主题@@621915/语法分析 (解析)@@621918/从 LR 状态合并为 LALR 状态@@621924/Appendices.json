{"hands_on_practices": [{"introduction": "本练习将引导你完整地、一步步地体验LALR(1)的构建过程。通过一个简单的文法，你将亲手构造出完整的LR(1)状态集，识别出具有相同核心的状态，并执行合并操作，最终验证合并后的分析器是无冲突的。这项实践对于掌握LALR(1)分析器如何从LR(1)演变而来的核心机制至关重要([@problem_id:3648903])。", "problem": "考虑包含产生式 $S' \\to S$、$S \\to C C$ 和 $C \\to c C \\mid d$ 的增广文法。使用 LR($1$)（带 1 个展望符号的从左到右扫描、最右推导）和 LALR($1$)（向前看 LR(1)）的基本定义，其中 LR($1$) 项目的形式为 $[A \\to \\alpha \\cdot \\beta, a]$，并且其规范族由标准的 $\\operatorname{closure}$ 和 $\\operatorname{goto}$ 操作构建，请完成以下任务：\n\n- 从 $[S' \\to \\cdot S, \\$]$ 开始，使用 $\\operatorname{closure}$ 和 $\\operatorname{goto}$ 的标准定义，为该增广文法构建规范 LR($1$) 项目集。\n- 识别所有同心的 LR($1$) 项目集对或组，其中一个项目集的核心是通过擦除其 LR($1$) 项目的展望符（即将其视为 LR($0$) 项目）得到的。\n- 通过合并每组同心状态来形成 LALR($1$) 自动机，并从分析器动作的基本原理出发，论证为什么对于该文法，合并操作不会引入移入-归约或归约-归约冲突。\n\n将合并同心 LR($1$) 状态后得到的不同 LALR($1$) 状态的总数作为最终答案。最终答案应表示为精确整数，无需四舍五入。", "solution": "该问题要求为一个给定的文法构建 LALR($1$) 自动机，这需要从规范 LR($1$) 项目集开始。这包括三个主要步骤：首先，构建完整的 LR($1$) 项目集族；其次，识别哪些项目集是同心的；第三，合并这些同心集以形成 LALR($1$) 状态，并论证对于这个特定的文法，合并过程不会引入分析冲突。\n\n增广文法由以下产生式给出：\n$1$. $S' \\to S$\n$2$. $S \\to C C$\n$3$. $C \\to c C$\n$4$. $C \\to d$\n\n一个 LR($1$) 项目的形式为 $[A \\to \\alpha \\cdot \\beta, a]$，其中 $A \\to \\alpha\\beta$ 是一个产生式，而 $a$ 是一个作为展望符的终结符。为简洁起见，我们将仅展望符不同的项目集合，如 $\\{[A \\to \\alpha \\cdot \\beta, a_1], [A \\to \\alpha \\cdot \\beta, a_2], \\dots \\}$, 表示为单个条目 $[A \\to \\alpha \\cdot \\beta, a_1/a_2/\\dots]$。\n\n首先，我们必须确定非终结符的 $\\operatorname{FIRST}$ 集，这是 $\\operatorname{closure}$ 操作所需要的。\n$\\operatorname{FIRST}(C)$ 从其产生式 $C \\to cC$ 和 $C \\to d$ 导出。因此，$\\operatorname{FIRST}(C) = \\{c, d\\}$。\n$\\operatorname{FIRST}(S)$ 从 $S \\to CC$ 导出。因此，$\\operatorname{FIRST}(S) = \\operatorname{FIRST}(C) = \\{c, d\\}$。\n\n现在我们开始构建 LR($1$) 项目的规范集族，从初始项目 $[S' \\to \\cdot S, \\$]$ 的闭包开始。\n\n$I_0 = \\operatorname{closure}(\\{[S' \\to \\cdot S, \\$]\\})$\n项目 $[S' \\to \\cdot S, \\$]$ 意味着我们可能会看到一个从 $S$ 推导出的字符串。$S$ 后面的展望符是 $\\$$。因此，我们为 $S$ 的产生式添加展望符为 $\\$$ 的项目。\n$[S \\to \\cdot CC, \\$]$。由于点在非终结符 $C$ 之前，我们添加 $C$ 的产生式项目。这些新项目的展望符是 $\\operatorname{FIRST}(C\\$)$，由于 $C$ 不是可空的，所以它等于 $\\operatorname{FIRST}(C)$。因此，展望符是 $c$ 和 $d$。\n$I_0 = \\{[S' \\to \\cdot S, \\$], [S \\to \\cdot CC, \\$], [C \\to \\cdot cC, c/d], [C \\to \\cdot d, c/d]\\}$\n\n接下来，我们计算 $I_0$ 在所有文法符号 $S, C, c, d$ 上的 $\\operatorname{goto}$ 函数。\n\n$\\operatorname{goto}(I_0, S) = \\operatorname{closure}(\\{[S' \\to S \\cdot, \\$]\\}) = I_1$\n$I_1 = \\{[S' \\to S \\cdot, \\$]\\}$ (接受状态)\n\n$\\operatorname{goto}(I_0, C) = \\operatorname{closure}(\\{[S \\to C \\cdot C, \\$]\\}) = I_2$\n对于 $[S \\to C \\cdot C, \\$]$，点在 $C$ 之前。展望符是 $\\operatorname{FIRST}(\\epsilon\\$) = \\{\\$\\}$。\n$I_2 = \\{[S \\to C \\cdot C, \\$], [C \\to \\cdot cC, \\$], [C \\to \\cdot d, \\$]\\}$\n\n$\\operatorname{goto}(I_0, c) = \\operatorname{closure}(\\{[C \\to c \\cdot C, c/d]\\}) = I_3$\n对于 $[C \\to c \\cdot C, c/d]$，点在 $C$ 之前。展望符是 $\\operatorname{FIRST}(\\epsilon(c/d)) = \\{c, d\\}$。\n$I_3 = \\{[C \\to c \\cdot C, c/d], [C \\to \\cdot cC, c/d], [C \\to \\cdot d, c/d]\\}$\n\n$\\operatorname{goto}(I_0, d) = \\operatorname{closure}(\\{[C \\to d \\cdot, c/d]\\}) = I_4$\n$I_4 = \\{[C \\to d \\cdot, c/d]\\}$ (归约状态)\n\n现在我们为新状态 $I_2, I_3, I_4$ 计算转移。\n\n从 $I_2$：\n$\\operatorname{goto}(I_2, C) = \\operatorname{closure}(\\{[S \\to CC \\cdot, \\$]\\}) = I_5$\n$I_5 = \\{[S \\to CC \\cdot, \\$]\\}$ (归约状态)\n\n$\\operatorname{goto}(I_2, c) = \\operatorname{closure}(\\{[C \\to c \\cdot C, \\$]\\}) = I_6$\n对于 $[C \\to c \\cdot C, \\$]$，新的 $C$-产生式的展望符是 $\\operatorname{FIRST}(\\epsilon\\$) = \\{\\$\\}$。\n$I_6 = \\{[C \\to c \\cdot C, \\$], [C \\to \\cdot cC, \\$], [C \\to \\cdot d, \\$]\\}$\n\n$\\operatorname{goto}(I_2, d) = \\operatorname{closure}(\\{[C \\to d \\cdot, \\$]\\}) = I_7$\n$I_7 = \\{[C \\to d \\cdot, \\$]\\}$ (归约状态)\n\n从 $I_3$：\n$\\operatorname{goto}(I_3, C) = \\operatorname{closure}(\\{[C \\to cC \\cdot, c/d]\\}) = I_8$\n$I_8 = \\{[C \\to cC \\cdot, c/d]\\}$ (归约状态)\n\n$\\operatorname{goto}(I_3, c) = \\operatorname{closure}(\\{[C \\to c \\cdot C, c/d]\\}) = I_3$ (一个回到自身的循环)\n\n$\\operatorname{goto}(I_3, d) = \\operatorname{closure}(\\{[C \\to d \\cdot, c/d]\\}) = I_4$\n\n从 $I_4$：这是一个归约状态，因此没有出向转移。\n\n从 $I_5$：这是一个归约状态，因此没有出向转移。\n\n从 $I_6$：\n$\\operatorname{goto}(I_6, C) = \\operatorname{closure}(\\{[C \\to cC \\cdot, \\$]\\}) = I_9$\n$I_9 = \\{[C \\to cC \\cdot, \\$]\\}$ (归约状态)\n\n$\\operatorname{goto}(I_6, c) = \\operatorname{closure}(\\{[C \\to c \\cdot C, \\$]\\}) = I_6$ (一个回到自身的循环)\n\n$\\operatorname{goto}(I_6, d) = \\operatorname{closure}(\\{[C \\to d \\cdot, \\$]\\}) = I_7$\n\n状态 $I_7, I_8, I_9$ 是归约状态，因此没有更多的状态需要生成。我们已经找到了所有 10 个 LR($1$) 状态（从 $I_0$ 到 $I_9$）。\n\n规范 LR($1$) 项目集如下：\n$I_0 = \\{[S' \\to \\cdot S, \\$], [S \\to \\cdot CC, \\$], [C \\to \\cdot cC, c/d], [C \\to \\cdot d, c/d]\\}$\n$I_1 = \\{[S' \\to S \\cdot, \\$]\\}$\n$I_2 = \\{[S \\to C \\cdot C, \\$], [C \\to \\cdot cC, \\$], [C \\to \\cdot d, \\$]\\}$\n$I_3 = \\{[C \\to c \\cdot C, c/d], [C \\to \\cdot cC, c/d], [C \\to \\cdot d, c/d]\\}$\n$I_4 = \\{[C \\to d \\cdot, c/d]\\}$\n$I_5 = \\{[S \\to CC \\cdot, \\$]\\}$\n$I_6 = \\{[C \\to c \\cdot C, \\$], [C \\to \\cdot cC, \\$], [C \\to \\cdot d, \\$]\\}$\n$I_7 = \\{[C \\to d \\cdot, \\$]\\}$\n$I_8 = \\{[C \\to cC \\cdot, c/d]\\}$\n$I_9 = \\{[C \\to cC \\cdot, \\$]\\}$\n\n接下来，我们识别同心集。一个 LR($1$) 项目集的核心是通过移除展望符得到的 LR($0$) 项目集。\n$\\operatorname{core}(I_0) = \\{S' \\to \\cdot S, S \\to \\cdot CC, C \\to \\cdot cC, C \\to \\cdot d\\}$\n$\\operatorname{core}(I_1) = \\{S' \\to S \\cdot\\}$\n$\\operatorname{core}(I_2) = \\{S \\to C \\cdot C, C \\to \\cdot cC, C \\to \\cdot d\\}$\n$\\operatorname{core}(I_3) = \\{C \\to c \\cdot C, C \\to \\cdot cC, C \\to \\cdot d\\}$\n$\\operatorname{core}(I_4) = \\{C \\to d \\cdot\\}$\n$\\operatorname{core}(I_5) = \\{S \\to CC \\cdot\\}$\n$\\operatorname{core}(I_6) = \\{C \\to c \\cdot C, C \\to \\cdot cC, C \\to \\cdot d\\}$\n$\\operatorname{core}(I_7) = \\{C \\to d \\cdot\\}$\n$\\operatorname{core}(I_8) = \\{C \\to cC \\cdot\\}$\n$\\operatorname{core}(I_9) = \\{C \\to cC \\cdot\\}$\n\n通过比较这些核心，我们识别出以下几组同心状态：\n1. $\\operatorname{core}(I_3) = \\operatorname{core}(I_6)$\n2. $\\operatorname{core}(I_4) = \\operatorname{core}(I_7)$\n3. $\\operatorname{core}(I_8) = \\operatorname{core}(I_9)$\n\nLALR($1$) 自动机是通过合并这些同心集形成的。新状态是原始状态中所有项目的并集。\n$I_{36} = I_3 \\cup I_6 = \\{[C \\to c \\cdot C, c/d/\\$], [C \\to \\cdot cC, c/d/\\$], [C \\to \\cdot d, c/d/\\$]\\}$\n$I_{47} = I_4 \\cup I_7 = \\{[C \\to d \\cdot, c/d/\\$]\\}$\n$I_{89} = I_8 \\cup I_9 = \\{[C \\to cC \\cdot, c/d/\\$]\\}$\n\n不同的 LALR($1$) 状态有：$I_0, I_1, I_2, I_5$ 以及三个新的合并状态 $I_{36}, I_{47}, I_{89}$。\nLALR($1$) 状态的总数是 $4 + 3 = 7$。\n\n最后，我们必须论证为什么这种合并不会引入冲突。LALR($1$) 分析器中的冲突发生在合并过程导致某个状态中，对于单个展望符，存在多种可能的动作（移入或归约）。\n原始的 LR($1$) 自动机在构建过程中已验证是无冲突的。\n我们来分析合并后的状态：\n- **$I_{36}$**：该状态只包含移入型项目（点不在产生式的末尾）。合并这类状态不会产生归约-归约或移入-归约冲突，因为其中不涉及归约项目。分析器将在输入为 $c$ 或 $d$ 时执行移入操作。\n- **$I_{47}$**：合并 $I_4 = \\{[C \\to d \\cdot, c/d]\\}$ 和 $I_7 = \\{[C \\to d \\cdot, \\$]\\}$。结果状态为 $I_{47} = \\{[C \\to d \\cdot, c/d/\\$]\\}$。在此状态下，分析器的动作是在展望符为 $c$、$d$ 或 $\\$$ 时，按产生式 $C \\to d$ 进行归约。由于此状态中只有一条产生式规则，因此不会发生归约-归约冲突。此外，没有移入项目，因此也不会发生移入-归约冲突。如果产生式规则不同，并且它们的展望符集有交集，那么就可能产生冲突，但在这里，规则是相同的（$C \\to d$）。\n- **$I_{89}$**：合并 $I_8 = \\{[C \\to cC \\cdot, c/d]\\}$ 和 $I_9 = \\{[C \\to cC \\cdot, \\$]\\}$。结果状态为 $I_{89} = \\{[C \\to cC \\cdot, c/d/\\$]\\}$。这里的动作是在展望符为 $c$、$d$ 或 $\\$$ 时，按产生式 $C \\to cC$ 进行归约。与 $I_{47}$ 的情况类似，这里只有一条产生式规则，因此没有引入冲突。\n\n总而言之，对于该文法，合并同心状态是安全的。在涉及归约项目的情况下（$I_4$ 和 $I_7$；$I_8$ 和 $I_9$），被合并的两个状态中的归约产生式规则是相同的，并且它们原始的展望符集是不相交的。因此，它们的并集只是为一个单一、明确的归约动作扩展了展望符集。仅包含移入项目的状态（$I_3$ 和 $I_6$）的合并本质上也是安全的。这证实了最终的 LALR($1$) 分析器是无冲突的。\n\n不同的 LALR($1$) 状态的最终计数为 7。", "answer": "$$\\boxed{7}$$", "id": "3648903"}, {"introduction": "虽然状态合并可以减小分析器的大小，但这个过程并非总是没有代价的。本问题提出了一个特殊设计的文法，旨在揭示LALR(1)方法的主要缺点：引入冲突的可能性。你将分析两个本身无冲突的LR(1)状态，如何因其核心相同而被合并，并最终导致一个包含归约/归约冲突的新状态，从而揭示分析器设计中的一个关键权衡([@problem_id:3648846])。", "problem": "考虑一个编译器原理领域中的上下文无关文法，该文法旨在研究规范的先行左到右 (LR(1)) 项目集与在合并状态的先行左到右 (LALR(1)) 分析法中其合并后的对应部分之间的关系。该文法包含所需产生式 $S \\to A a \\mid B b$, $A \\to \\alpha$, $B \\to \\beta$，并被扩展以创建在 LALR(1) 下合并但保留 LR(0) 核心的不同的 LR(1) 上下文。设终结符为 $p$, $q$, $a$, $b$, $c$，非终结符为 $S$, $X$, $Y$, $A$, $B$，开始符号为 $S$。定义\n$$\nS \\to p X \\mid q Y, \\quad X \\to A a \\mid B b, \\quad Y \\to A b \\mid B a, \\quad A \\to c, \\quad B \\to c.\n$$\n使用基于项目、$\\mathrm{closure}$ 和 $\\mathrm{goto}$ 的基本定义的规范 LR(1) 构造方法：\n- 一个 LR(1) 项目写作 $[N \\to \\gamma \\cdot \\delta, t]$，其中 $N$ 是一个非终结符，$\\gamma$ 和 $\\delta$ 是（可能为空的）文法符号串，$\\cdot$ 表示点的位置，而 $t$ 是一个先行终结符。\n- $\\mathrm{closure}$ 操作为紧跟在点后面的非终结符添加项目，其先行符由该非终结符后面的后缀的 $\\mathrm{FIRST}$ 集给出。\n- $\\mathrm{goto}$ 操作将点移动过一个文法符号。\n\n任务：\n1. 从增广文法（带有 $S' \\to S$）的初始 LR(1) 项目集开始，符号化地构造出在分别先扫描 $p$ 和先扫描 $q$ 到达的上下文中，紧接着扫描 $c$ 之后对应于 $A$ 和 $B$ 归约的 LR(1) 项目集。对每个这样的 LR(1) 状态，明确指出其 LR(0) 核心以及附加到 $[A \\to c \\cdot]$ 和 $[B \\to c \\cdot]$ 的先行集。\n2. 对共享相同 LR(0) 核心的状态执行 LALR(1) 状态合并，方法是取相应 LR(0) 项目的先行集的并集。\n3. 将归约/归约冲突定义为：在单个合并状态中，对于同一个终结符，存在两个不同的完整项目，其先行符适用性重叠。计算在为 $A$ 和 $B$ 的归约而合并的 LALR(1) 状态中，$\\{a,b\\}$ 中有多少个终结符产生此类归约/归约冲突。\n\n你的最终答案必须是一个实数值，等于因 LALR(1) 合并而在 $\\{a,b\\}$ 上产生的归约/归约冲突的总数。不需要四舍五入。", "solution": "该问题要求分析一个特定的上下文无关文法，以确定由 LALR($1$) 状态合并引入的归约/归约冲突的数量。第一步是验证问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n已知条件如下：\n-   **文法 $G$**：\n    -   产生式：$S \\to p X \\mid q Y$, $X \\to A a \\mid B b$, $Y \\to A b \\mid B a$, $A \\to c, \\quad B \\to c$。\n    -   终结符：$\\{p, q, a, b, c\\}$。\n    -   非终结符：$\\{S, X, Y, A, B\\}$。\n    -   开始符号：$S$。\n-   **分析器构造方法**：规范 LR($1$)。\n-   **定义**：\n    -   一个 LR(1) 项目是 $[N \\to \\gamma \\cdot \\delta, t]$。\n    -   $\\mathrm{closure}$ 操作为点后的非终结符添加项目。\n    -   $\\mathrm{goto}$ 操作将点移动过一个符号。\n-   **任务**：\n    1.  构造由 $A$ 和 $B$ 的归约产生的特定 LR(1) 项目集。\n    2.  对具有相同 LR(0) 核心的状态执行 LALR(1) 状态合并。\n    3.  在产生的合并状态中，计算终结符集 $\\{a,b\\}$ 的归约/归约冲突总数。\n-   **增广文法**：使用初始产生式 $S' \\to S$，其中 $S'$ 是新的开始符号。初始先行符是输入结束标记，表示为 $\\$$。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题设置在编译器理论（特别是语法分析理论）的形式化背景下。LR(1) 和 LALR(1) 分析器、项目集、closure、goto 和归约/归约冲突等概念是计算机科学中基础且完善的概念。\n-   **适定性**：该文法是无歧义的（在其作为研究对象的 LR(1) 形式下），任务是具体且形式化定义的。一个唯一的步骤序列可以导出一个确定的答案。\n-   **客观性**：该问题使用标准的、形式化的定义，避免了任何主观或模糊的语言。\n-   **完整性**：解决该问题所需的所有必要信息（文法、定义、具体任务）都已提供。\n-   **结论**：该问题是有效的。这是编译器构造原理中的一个标准练习，旨在测试对 LR(1) 和 LALR(1) 分析表之间关系的理解。\n\n### 步骤 3：判定与行动\n该问题有效。将提供详细的解答。\n\n### 解题过程\n\n解题过程包括构造所需的 LR(1) 状态，执行 LALR(1) 合并，并分析结果状态中的冲突。\n\n首先，我们用新的开始符号 $S'$ 和产生式 $S' \\to S$ 来增广文法。初始项目集是 $[S' \\to \\cdot S, \\$]$ 的闭包。\n\n为了计算闭包，我们需要相关非终结符的 $\\mathrm{FIRST}$ 集。\n$\\mathrm{FIRST}(A) = \\mathrm{FIRST}(c) = \\{c\\}$。\n$\\mathrm{FIRST}(B) = \\mathrm{FIRST}(c) = \\{c\\}$。\n$\\mathrm{FIRST}(X) = \\mathrm{FIRST}(Aa) \\cup \\mathrm{FIRST}(Bb) = \\mathrm{FIRST}(A) \\cup \\mathrm{FIRST}(B) = \\{c\\}$。\n$\\mathrm{FIRST}(Y) = \\mathrm{FIRST}(Ab) \\cup \\mathrm{FIRST}(Ba) = \\mathrm{FIRST}(A) \\cup \\mathrm{FIRST}(B) = \\{c\\}$。\n$\\mathrm{FIRST}(S) = \\mathrm{FIRST}(pX) \\cup \\mathrm{FIRST}(qY) = \\{p, q\\}$。\n\n初始 LR(1) 项目集 $I_0$ 是：\n$I_0 = \\mathrm{closure}(\\{[S' \\to \\cdot S, \\$]\\}) = \\{ [S' \\to \\cdot S, \\$], [S \\to \\cdot pX, \\$], [S \\to \\cdot qY, \\$] \\}$。\n\n问题要求找到在首先扫描 $p$ 和 $q$ 后到达的状态。\n令 $I_1 = \\mathrm{goto}(I_0, p)$ 且 $I_2 = \\mathrm{goto}(I_0, q)$。\n\n**状态 $I_1$ 的构造：**\n$I_1 = \\mathrm{goto}(I_0, p) = \\mathrm{closure}(\\{[S \\to p \\cdot X, \\$]\\})$. 为了计算闭包，我们为 $X$ 添加项目。先行符继承自父项目 $[S \\to p \\cdot X, \\$]$，即 $\\$$。\n-   $[X \\to \\cdot Aa, \\$]$\n-   $[X \\to \\cdot Bb, \\$]$\n现在，我们为 $A$ 和 $B$ 添加项目。\n-   对于 $[X \\to \\cdot A a, \\$]$，跟在 $A$ 后面的符号是 $a$。先行符是 $\\mathrm{FIRST}(a\\$) = \\{a\\}$。所以，我们添加 $[A \\to \\cdot c, a]$。\n-   对于 $[X \\to \\cdot B b, \\$]$，跟在 $B$ 后面的符号是 $b$。先行符是 $\\mathrm{FIRST}(b\\$) = \\{b\\}$。所以，我们添加 $[B \\to \\cdot c, b]$。\n因此，状态 $I_1$ 是：\n$I_1 = \\{ [S \\to p \\cdot X, \\$], [X \\to \\cdot Aa, \\$], [X \\to \\cdot Bb, \\$], [A \\to \\cdot c, a], [B \\to \\cdot c, b] \\}$\n\n**状态 $I_2$ 的构造：**\n$I_2 = \\mathrm{goto}(I_0, q) = \\mathrm{closure}(\\{[S \\to q \\cdot Y, \\$]\\})$. 为了计算闭包，我们为 $Y$ 添加项目，先行符为 $\\$$。\n-   $[Y \\to \\cdot Ab, \\$]$\n-   $[Y \\to \\cdot Ba, \\$]$\n现在，我们为 $A$ 和 $B$ 添加项目。\n-   对于 $[Y \\to \\cdot A b, \\$]$，跟在 $A$ 后面的符号是 $b$。先行符是 $\\mathrm{FIRST}(b\\$) = \\{b\\}$。所以，我们添加 $[A \\to \\cdot c, b]$。\n-   对于 $[Y \\to \\cdot B a, \\$]$，跟在 $B$ 后面的符号是 $a$。先行符是 $\\mathrm{FIRST}(a\\$) = \\{a\\}$。所以，我们添加 $[B \\to \\cdot c, a]$。\n因此，状态 $I_2$ 是：\n$I_2 = \\{ [S \\to q \\cdot Y, \\$], [Y \\to \\cdot Ab, \\$], [Y \\to \\cdot Ba, \\$], [A \\to \\cdot c, b], [B \\to \\cdot c, a] \\}$\n\n**第 1 部分：构造目标 LR(1) 归约状态**\n\n我们现在计算从状态 $I_1$ 和 $I_2$ 扫描终结符 $c$ 后到达的状态。\n\n令 $I_3 = \\mathrm{goto}(I_1, c)$。我们在 $I_1$ 中寻找点在 $c$ 之前的项目：$[A \\to \\cdot c, a]$ 和 $[B \\to \\cdot c, b]$。\n$I_3 = \\mathrm{closure}(\\{ [A \\to c \\cdot, a], [B \\to c \\cdot, b] \\})$。由于点位于产生式的末尾，闭包就是该集合本身。\n$I_3 = \\{ [A \\to c \\cdot, a], [B \\to c \\cdot, b] \\}$。\n-   $I_3$ 的 LR(0) 核心是 $\\{ A \\to c \\cdot, B \\to c \\cdot \\}$。\n-   项目 $[A \\to c \\cdot]$ 的先行集是 $\\{a\\}$。\n-   项目 $[B \\to c \\cdot]$ 的先行集是 $\\{b\\}$。\n\n令 $I_4 = \\mathrm{goto}(I_2, c)$。我们在 $I_2$ 中寻找点在 $c$ 之前的项目：$[A \\to \\cdot c, b]$ 和 $[B \\to \\cdot c, a]$。\n$I_4 = \\mathrm{closure}(\\{ [A \\to c \\cdot, b], [B \\to c \\cdot, a] \\})$。同样，闭包就是该集合本身。\n$I_4 = \\{ [A \\to c \\cdot, b], [B \\to c \\cdot, a] \\}$。\n-   $I_4$ 的 LR(0) 核心是 $\\{ A \\to c \\cdot, B \\to c \\cdot \\}$。\n-   项目 $[A \\to c \\cdot]$ 的先行集是 $\\{b\\}$。\n-   项目 $[B \\to c \\cdot]$ 的先行集是 $\\{a\\}$。\n\n**第 2 部分：LALR(1) 状态合并**\n\n状态 $I_3$ 和 $I_4$ 具有相同的 LR(0) 核心：$\\{ A \\to c \\cdot, B \\to c \\cdot \\}$。在 LALR(1) 构造中，这两个状态被合并成一个单一状态，我们称之为 $I_{34}$。这个新状态中的项目是通过取每个相应 LR(0) 项目的先行集的并集来形成的。\n\n-   对于核心项目 $A \\to c \\cdot$：\n    $I_3$ 中的先行符是 $\\{a\\}$。$I_4$ 中的先行符是 $\\{b\\}$。\n    合并后的先行集是 $\\{a\\} \\cup \\{b\\} = \\{a, b\\}$。\n    得到的 LALR(1) 项目是 $[A \\to c \\cdot, a / b]$。\n\n-   对于核心项目 $B \\to c \\cdot$：\n    $I_3$ 中的先行符是 $\\{b\\}$。$I_4$ 中的先行符是 $\\{a\\}$。\n    合并后的先行集是 $\\{b\\} \\cup \\{a\\} = \\{a, b\\}$。\n    得到的 LALR(1) 项目是 $[B \\to c \\cdot, a / b]$。\n\n合并后的 LALR(1) 状态 $I_{34}$ 是：\n$I_{34} = \\{ [A \\to c \\cdot, a / b], [B \\to c \\cdot, a / b] \\}$。\n\n**第 3 部分：计算归约/归约冲突**\n\n当在一个状态中，对于给定的先行终结符，存在两个或更多个不同的产生式可供分析器进行归约时，就会发生归约/归约冲突。状态 $I_{34}$ 包含两个指示归约的完整项目：\n1.  在先行符为 $\\{a, b\\}$ 时，按 $A \\to c$ 归约。\n2.  在先行符为 $\\{a, b\\}$ 时，按 $B \\to c$ 归约。\n\n产生式 $A \\to c$ 和 $B \\to c$ 是不同的。我们检查集合 $\\{a, b\\}$ 中每个终结符的冲突情况。\n\n-   **对于终结符 $a$**：\n    - 终结符 $a$ 在归约 $A \\to c$ 的先行集 $\\{a, b\\}$ 中。\n    - 终结符 $a$ 也在归约 $B \\to c$ 的先行集 $\\{a, b\\}$ 中。\n    - 因此，当看到先行终结符 $a$ 时，分析器有两种选择：按 $A \\to c$ 归约或按 $B \\to c$ 归约。这构成了一个归约/归约冲突。对于终结符 $a$ 的冲突归约对的数量是 $\\binom{2}{2} = 1$。\n\n-   **对于终结符 $b$**：\n    - 终结符 $b$ 在归约 $A \\to c$ 的先行集 $\\{a, b\\}$ 中。\n    - 终结符 $b$ 也在归约 $B \\to c$ 的先行集 $\\{a, b\\}$ 中。\n    - 同样，当看到先行终结符 $b$ 时，分析器有两种选择，这是一个归约/归约冲突。对于终结符 $b$ 的冲突归约对的数量是 $\\binom{2}{2} = 1$。\n\n问题要求在终结符集 $\\{a, b\\}$ 上的归约/归约冲突总数。我们将为每个终结符找到的冲突数量相加。\n总冲突数 = ($a$ 上的冲突数) + ($b$ 上的冲突数) = $1 + 1 = 2$。", "answer": "$$\n\\boxed{2}\n$$", "id": "3648846"}, {"introduction": "在通过完整文法观察了冲突如何产生之后，现在我们将这个核心原理抽象出来。本练习剥离了状态生成的复杂性，让你能专注于冲突产生的条件本身。通过直接处理预先定义好的LR(1)状态及其展望符集，你将应用一个形式化的“合并阻塞准则”来计算“冲突指数”，从而精确量化合并操作引入的歧义性，并巩固你对合并何时以及为何不安全的理解([@problem_id:3648837])。", "problem": "考虑 Look-Ahead Left-to-right Rightmost derivation with one-symbol lookahead (LALR(1)) 分析表的标准构造，即通过合并共享相同核心的 Left-to-right Rightmost derivation with one-symbol lookahead (LR(1)) 状态。一个 $\\text{LR}(1)$ 项目写为 $[A \\rightarrow \\alpha \\, . \\, \\beta, a]$，其中 $A \\rightarrow \\alpha\\beta$ 是一个产生式，点号表示在右部的位置，$a$ 是一个终结符向前看符号。一个归约项目是任何形如 $[A \\rightarrow \\alpha \\, ., a]$ 的项目。一个状态的核心是其所有项目在擦除向前看符号后得到的集合。\n\n如果两个 $\\text{LR}(1)$ 状态在忽略向前看符号后具有相同的项目集，则它们是核心等价的。当将核心等价的 $\\text{LR}(1)$ 状态合并成一个单一的 $\\text{LALR}(1)$ 状态时，相应项目的向前看符号集的并集将被计算。如果在一个状态中存在两个不同的归约项目，它们都规定在同一个终结符上执行归约动作，则会产生归约/归约冲突。\n\n为一对具有共同核心的核心等价 $\\text{LR}(1)$ 状态 $I_{1}$ 和 $I_{2}$ 定义一个局部合并阻塞准则。对于核心中的每个不同归约项目 $r_{i}$，令 $L_{i}^{(1)}$ 和 $L_{i}^{(2)}$ 分别为其在 $I_{1}$ 和 $I_{2}$ 中的向前看符号集。在合并后的状态中，归约项目 $r_{i}$ 的向前看符号集为 $L_{i} = L_{i}^{(1)} \\cup L_{i}^{(2)}$。令冲突集为\n$$\nC = \\left\\{\\, t \\in \\Sigma \\;\\middle|\\; \\text{存在不同的归约项目 } r_{i} \\neq r_{j} \\text{ 使得 } t \\in L_{i} \\text{ 且 } t \\in L_{j} \\,\\right\\},\n$$\n其中 $\\Sigma$ 是终结符集合。如果 $|C| > 0$，则合并被阻塞。合并阻塞冲突指数定义为基数 $|C|$。\n\n现在考虑以下两个核心等价的 $\\text{LR}(1)$ 状态 $I_{1}$ 和 $I_{2}$，它们的共同核心恰好由两个归约项目 $r_{A}$ 和 $r_{B}$ 组成：\n- 核心 $K = \\{ [A \\rightarrow \\alpha \\, ., \\_],\\; [B \\rightarrow \\beta \\, ., \\_] \\}$，其中下划线表示已擦除的向前看符号。\n- 在 $I_{1}$ 中，向前看符号集为 $L_{A}^{(1)} = \\{ a \\}$ 和 $L_{B}^{(1)} = \\{ b, c \\}$。\n- 在 $I_{2}$ 中，向前看符号集为 $L_{A}^{(2)} = \\{ b \\}$ 和 $L_{B}^{(2)} = \\{ a \\}$。\n\n假设 $I_{1}$ 和 $I_{2}$ 各自无冲突（即，对于每个状态，其不同归约项目的向前看符号集是不相交的）。使用上面定义的局部合并阻塞准则，计算由 $I_{1}$ 和 $I_{2}$ 合并形成的状态的合并阻塞冲突指数 $|C|$。以单个整数形式给出 $|C|$ 的最终值。无需四舍五入。", "solution": "首先验证问题以确保其科学上可靠、定义明确且客观。\n\n**步骤1：提取已知信息**\n- 上下文是从 $\\text{LR}(1)$ 状态构造 $\\text{LALR}(1)$ 分析表。\n- 一个 $\\text{LR}(1)$ 项目的形式为 $[A \\rightarrow \\alpha \\, . \\, \\beta, a]$，其中 $A \\rightarrow \\alpha\\beta$ 是一个产生式，点标记当前位置，$a$ 是一个终结符向前看符号。\n- 一个归约项目的形式为 $[A \\rightarrow \\alpha \\, ., a]$。\n- 一个 $\\text{LR}(1)$ 状态的核心是其项目集在擦除向前看符号后的集合。\n- 合并核心等价的 $\\text{LR}(1)$ 状态涉及将相应项目的向前看符号集取并集。\n- 为两个核心等价的 $\\text{LR}(1)$ 状态 $I_{1}$ 和 $I_{2}$ 定义了一个局部合并阻塞准则。\n- 对于共同核心中的每个不同归约项目 $r_{i}$，其在 $I_{1}$ 中的向前看符号集是 $L_{i}^{(1)}$，在 $I_{2}$ 中的是 $L_{i}^{(2)}$。\n- 在合并后的状态中，$r_{i}$ 的向前看符号集是 $L_{i} = L_{i}^{(1)} \\cup L_{i}^{(2)}$。\n- 合并后状态的冲突集定义为 $C = \\left\\{\\, t \\in \\Sigma \\;\\middle|\\; \\text{存在不同的归约项目 } r_{i} \\neq r_{j} \\text{ 使得 } t \\in L_{i} \\text{ 且 } t \\in L_{j} \\,\\right\\}$。\n- 合并阻塞冲突指数定义为 $|C|$。\n- 提供了两个具体的核心等价 $\\text{LR}(1)$ 状态 $I_{1}$ 和 $I_{2}$。\n- 它们的共同核心 $K$ 恰好由两个归约项目组成：$K = \\{ [A \\rightarrow \\alpha \\, ., \\_],\\; [B \\rightarrow \\beta \\, ., \\_] \\}$。我们分别将这些核心项目表示为 $r_{A}$ 和 $r_{B}$。\n- 状态 $I_{1}$ 中的向前看符号集：$L_{A}^{(1)} = \\{ a \\}$ 和 $L_{B}^{(1)} = \\{ b, c \\}$。\n- 状态 $I_{2}$ 中的向前看符号集：$L_{A}^{(2)} = \\{ b \\}$ 和 $L_{B}^{(2)} = \\{ a \\}$。\n- 做出了一个明确的假设：$I_{1}$ 和 $I_{2}$ 各自无冲突。\n- 任务是计算合并后状态的合并阻塞冲突指数 $|C|$。\n\n**步骤2：使用提取的已知信息进行验证**\n该问题定义明确，植根于标准编译器理论。$\\text{LR}(1)$ 项目、状态、核心以及 $\\text{LALR}(1)$ 合并过程的定义都是正确的。归约/归约冲突的概念，以及通过检查单个状态中不同归约产生式的不相交向前看符号集来识别该冲突的方法，是基础性的。该问题在提议的合并上下文中对这一检查进行了形式化。\n状态 $I_{1}$ 和 $I_{2}$ 各自无冲突的假设与给定数据一致。\n- 在状态 $I_{1}$ 中，两个不同归约项目的向前看符号集是 $L_{A}^{(1)} = \\{ a \\}$ 和 $L_{B}^{(1)} = \\{ b, c \\}$。它们的交集是 $L_{A}^{(1)} \\cap L_{B}^{(1)} = \\{ a \\} \\cap \\{ b, c \\} = \\emptyset$。因此，$I_{1}$ 是无冲突的。\n- 在状态 $I_{2}$ 中，两个不同归约项目的向前看符号集是 $L_{A}^{(2)} = \\{ b \\}$ 和 $L_{B}^{(2)} = \\{ a \\}$。它们的交集是 $L_{A}^{(2)} \\cap L_{B}^{(2)} = \\{ b \\} \\cap \\{ a \\} = \\emptyset$。因此，$I_{2}$ 是无冲突的。\n由于该问题内部一致、科学上合理，并为得出唯一解提供了所有必要信息，因此被认为是有效的。\n\n**步骤3：结论与行动**\n问题有效。将提供完整的解答。\n\n**解答**\n目标是计算通过合并两个核心等价的 LR(1) 状态 $I_{1}$ 和 $I_{2}$ 所形成的 LALR(1) 状态的合并阻塞冲突指数 $|C|$。\n\n这些状态的共同核心包含两个不同的归约项目，我们用它们对应的产生式来表示：$r_{A}$ 代表 $A \\rightarrow \\alpha$，$r_{B}$ 代表 $B \\rightarrow \\beta$。问题提供了这两个项目中每一个在两个 $\\text{LR}(1)$ 状态中的向前看符号集。\n\n首先，我们计算合并后状态中每个归约项目的向前看符号集。根据问题定义，合并后状态中一个项目的向前看符号集是其在原始状态中向前看符号集的并集。\n\n对于归约项目 $r_{A}$（来自产生式 $A \\rightarrow \\alpha$），其在合并后状态中的向前看符号集 $L_{A}$ 为：\n$$\nL_{A} = L_{A}^{(1)} \\cup L_{A}^{(2)}\n$$\n代入给定的集合：\n$$\nL_{A} = \\{ a \\} \\cup \\{ b \\} = \\{ a, b \\}\n$$\n\n对于归约项目 $r_{B}$（来自产生式 $B \\rightarrow \\beta$），其在合并后状态中的向前看符号集 $L_{B}$ 为：\n$$\nL_{B} = L_{B}^{(1)} \\cup L_{B}^{(2)}\n$$\n代入给定的集合：\n$$\nL_{B} = \\{ b, c \\} \\cup \\{ a \\} = \\{ a, b, c \\}\n$$\n\n现在我们得到了提议的合并后 $\\text{LALR}(1)$ 状态中所有归约项目及其关联的向前看符号集：\n- 在向前看符号为 $\\{ a, b \\}$ 时按 $A \\rightarrow \\alpha$ 归约。\n- 在向前看符号为 $\\{ a, b, c \\}$ 时按 $B \\rightarrow \\beta$ 归约。\n\n接下来，我们必须找到冲突集 $C$。问题将 $C$ 定义为这样的终结符 $t$ 的集合：存在不同的归约项目 $r_{i}$ 和 $r_{j}$，使得 $t$ 同时在它们的向前看符号集 $L_{i}$ 和 $L_{j}$ 中。在我们的例子中，不同的归约项目是 $r_{A}$ 和 $r_{B}$，它们在合并后状态中的向前看符号集是 $L_{A}$ 和 $L_{B}$。如果一个终结符 $t$ 同时在 $L_{A}$ 和 $L_{B}$ 中，它就会导致一个归约/归约冲突。因此，冲突集 $C$ 是这两个向前看符号集的交集：\n$$\nC = L_{A} \\cap L_{B}\n$$\n使用计算出的集合 $L_{A}$ 和 $L_{B}$：\n$$\nC = \\{ a, b \\} \\cap \\{ a, b, c \\} = \\{ a, b \\}\n$$\n\n最后，合并阻塞冲突指数定义为冲突集 $C$ 的基数，即 $|C|$。\n$$\n|C| = |\\{ a, b \\}| = 2\n$$\n状态 $I_{1}$ 和 $I_{2}$ 的合并在终结符 $a$ 和 $b$ 上引入了归约/归约冲突。这种冲突终结符的数量是 $2$。", "answer": "$$\\boxed{2}$$", "id": "3648837"}]}