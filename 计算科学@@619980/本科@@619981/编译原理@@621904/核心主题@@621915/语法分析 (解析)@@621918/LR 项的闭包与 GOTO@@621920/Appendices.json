{"hands_on_practices": [{"introduction": "要真正掌握LR(1)分析中状态机构建的核心，最好的方法就是亲自动手实践。本节的第一个练习将带你从头开始，为给定的文法构建LR(1)分析器的初始状态 $I_0$。通过应用闭包(closure)操作，我们将从增广文法的开始符号出发，推导出所有可能的初始项目，然后执行基本的`goto`转换，观察分析器如何根据识别到的文法符号转移到新的状态。这个过程是理解语法分析器如何自动生成其状态机的基础。[@problem_id:3627177]", "problem": "考虑由产生式 $S \\to A \\mid B$、$A \\to aA \\mid a$ 以及 $B \\to bB \\mid b$ 定义的上下文无关文法，其中 $S$ 是开始符号，$a$ 和 $b$ 是终结符。通过引入一个新的开始符号 $S'$ 和产生式 $S' \\to S$ 来增广该文法。在具有 $1$ 符号前瞻的规范从左到右、逆向最右推导 (LR) 分析器 (LR($1$)) 的框架下进行操作。仅使用 LR($1$) 项目的核心定义、作用于字符串的 $\\operatorname{FIRST}$ 函数、针对 LR($1$) 项目的 $\\operatorname{closure}$ (闭包) 操作以及针对 LR($1$) 项目集的 $\\operatorname{goto}$ (转移) 操作，从第一性原理出发完成以下任务：\n\n- 构建初始 LR($1$) 项目集 $I_{0} = \\operatorname{closure}(\\{[S' \\to \\cdot S, \\$]\\})$.\n- 构建 $I_{1} = \\operatorname{goto}(I_{0}, S)$.\n- 构建 $I_{2} = \\operatorname{goto}(I_{0}, a)$.\n\n令 $N$ 表示 $I_{0}$、$I_{1}$ 和 $I_{2}$ 中 LR($1$) 项目数量的总和 (即 $N = |I_{0}| + |I_{1}| + |I_{2}|$)。计算 $N$。你的最终答案必须是一个实数值；无需四舍五入。", "solution": "### 解答\n\n本题要求计算给定上下文无关文法在项目集 $I_0$、$I_1$ 和 $I_2$ 中 LR($1$) 项目的总数。将按要求从第一性原理出发进行解答。\n\n给定的文法 $G$ 有以下产生式：\n$S \\to A \\mid B$\n$A \\to aA \\mid a$\n$B \\to bB \\mid b$\n\n非终结符集为 $\\{S, A, B\\}$，终结符集为 $\\{a, b\\}$。开始符号是 $S$。\n\n增广文法 $G'$ 引入了一个新的开始符号 $S'$ 和一个产生式 $S' \\to S$。输入结束标记用 $\\$$ 表示。一个 LR($1$) 项目的形式为 $[A \\to \\alpha \\cdot \\beta, x]$，其中 $A \\to \\alpha \\beta$ 是一个产生式，$x$ 是一个终结符 (前瞻符号)。\n\n首先，我们需要非终结符的 $\\operatorname{FIRST}$ 集，这在 $\\operatorname{closure}$ (闭包) 操作中会用到。\n- $\\operatorname{FIRST}(A)$: 从产生式 $A \\to aA$ 和 $A \\to a$ 可知，从 $A$ 推导出的第一个终结符必定是 $a$。因此，$\\operatorname{FIRST}(A) = \\{a\\}$。\n- $\\operatorname{FIRST}(B)$: 从产生式 $B \\to bB$ 和 $B \\to b$ 可知，从 $B$ 推导出的第一个终结符必定是 $b$。因此，$\\operatorname{FIRST}(B) = \\{b\\}$。\n- $\\operatorname{FIRST}(S)$: 从产生式 $S \\to A$ 和 $S \\to B$ 可知，$\\operatorname{FIRST}(S) = \\operatorname{FIRST}(A) \\cup \\operatorname{FIRST}(B) = \\{a\\} \\cup \\{b\\} = \\{a, b\\}$。\n\n$\\operatorname{closure}$ (闭包) 操作定义如下：对于一个项目集 $I$，$\\operatorname{closure}(I)$ 是包含 $I$ 的最小集合，使得对于集合中的任意项目 $[A \\to \\alpha \\cdot B \\beta, x]$，对于任意产生式 $B \\to \\gamma$，以及对于任意终结符 $y \\in \\operatorname{FIRST}(\\beta x)$，项目 $[B \\to \\cdot \\gamma, y]$ 也在此集合中。\n\n$\\operatorname{goto}$ (转移) 操作定义为：$\\operatorname{goto}(I, X)$ 是所有形如 $[A \\to \\alpha X \\cdot \\beta, x]$ 的项目集合的闭包，其中 $[A \\to \\alpha \\cdot X \\beta, x]$ 属于 $I$。\n\n**任务 1：构建 $I_0 = \\operatorname{closure}(\\{[S' \\to \\cdot S, \\$]\\})$**\n我们从核心集 $\\{[S' \\to \\cdot S, \\$]\\}$ 开始。\n1.  初始项目是 $[S' \\to \\cdot S, \\$]$。点号后面是非终结符 $S$。跟在 $S$ 后面的字符串是空串 ($\\epsilon$)，前瞻符号是 $\\$$。我们需要找到 $\\operatorname{FIRST}(\\epsilon \\$) = \\{\\$\\}$。我们将 $S$ 的所有产生式都添加进来，并使用这个前瞻符号。\n    - $S \\to A$：添加 $[S \\to \\cdot A, \\$]$。\n    - $S \\to B$：添加 $[S \\to \\cdot B, \\$]$。\n    现在项目集为 $\\{[S' \\to \\cdot S, \\$], [S \\to \\cdot A, \\$], [S \\to \\cdot B, \\$]\\}$。\n\n2.  考虑新项目 $[S \\to \\cdot A, \\$]$。点号后面是非终结符 $A$。跟在 $A$ 后面的字符串是 $\\epsilon$，前瞻符号是 $\\$$。$\\operatorname{FIRST}(\\epsilon \\$) = \\{\\$\\}$。我们将 $A$ 的所有产生式都添加进来，并使用这个前瞻符号。\n    - $A \\to aA$：添加 $[A \\to \\cdot aA, \\$]$。\n    - $A \\to a$：添加 $[A \\to \\cdot a, \\$]$。\n    现在集合为 $\\{[S' \\to \\cdot S, \\$], [S \\to \\cdot A, \\$], [S \\to \\cdot B, \\$], [A \\to \\cdot aA, \\$], [A \\to \\cdot a, \\$]\\}$。\n\n3.  考虑新项目 $[S \\to \\cdot B, \\$]$。点号后面是非终结符 $B$。跟在 $B$ 后面的字符串是 $\\epsilon$，前瞻符号是 $\\$$。$\\operatorname{FIRST}(\\epsilon \\$) = \\{\\$\\}$。我们将 $B$ 的所有产生式都添加进来，并使用这个前瞻符号。\n    - $B \\to bB$：添加 $[B \\to \\cdot bB, \\$]$。\n    - $B \\to b$：添加 $[B \\to \\cdot b, \\$]$。\n    现在集合为 $\\{[S' \\to \\cdot S, \\$], [S \\to \\cdot A, \\$], [S \\to \\cdot B, \\$], [A \\to \\cdot aA, \\$], [A \\to \\cdot a, \\$], [B \\to \\cdot bB, \\$], [B \\to \\cdot b, \\$]\\}$。\n\n4.  新项目 $[A \\to \\cdot aA, \\$]$、$[A \\to \\cdot a, \\$]$、$[B \\to \\cdot bB, \\$]$ 和 $[B \\to \\cdot b, \\$]$ 的点号后面都是终结符 ($a$ 或 $b$)。闭包规则仅在点号后为非终结符时适用。因此，不能再添加更多项目。\n\n$I_0$ 的最终项目集是：\n$I_0 = \\{ [S' \\to \\cdot S, \\$], [S \\to \\cdot A, \\$], [S \\to \\cdot B, \\$], [A \\to \\cdot aA, \\$], [A \\to \\cdot a, \\$], [B \\to \\cdot bB, \\$], [B \\to \\cdot b, \\$] \\}$.\n$I_0$ 中的项目数量为 $|I_0| = 7$。\n\n**任务 2：构建 $I_1 = \\operatorname{goto}(I_0, S)$**\n1.  在 $I_0$ 中找到所有点号在 $S$ 之前的项目。只有一个这样的项目：$[S' \\to \\cdot S, \\$]$。\n2.  将点号越过 $S$ 以形成新集合的核心：$\\{[S' \\to S \\cdot, \\$]\\}$。\n3.  计算该核心集的闭包：$\\operatorname{closure}(\\{[S' \\to S \\cdot, \\$]\\})$.\n4.  项目 $[S' \\to S \\cdot, \\$]$ 的点号在产生式的末尾。因此，闭包操作无法添加新项目。\n\n$I_1$ 的最终项目集是：\n$I_1 = \\{ [S' \\to S \\cdot, \\$] \\}$.\n$I_1$ 中的项目数量为 $|I_1| = 1$。这对应于分析器的接受状态。\n\n**任务 3：构建 $I_2 = \\operatorname{goto}(I_0, a)$**\n1.  在 $I_0$ 中找到所有点号在终结符 $a$ 之前的项目。它们是 $[A \\to \\cdot aA, \\$]$ 和 $[A \\to \\cdot a, \\$]$。\n2.  在这些项目中将点号越过 $a$ 以形成新集合的核心：$\\{[A \\to a \\cdot A, \\$], [A \\to a \\cdot, \\$]\\}$。\n3.  计算该核心集的闭包：$\\operatorname{closure}(\\{[A \\to a \\cdot A, \\$], [A \\to a \\cdot, \\$]\\})$。\n    - 项目 $[A \\to a \\cdot, \\$]$ 的点号在末尾，因此它不会添加新项目。\n    - 项目 $[A \\to a \\cdot A, \\$]$ 的点号后面是非终结符 $A$。跟在 $A$ 后面的字符串是 $\\epsilon$，前瞻符号是 $\\$$。我们需要找到 $\\operatorname{FIRST}(\\epsilon \\$) = \\{\\$\\}$。我们将 $A$ 的所有产生式都添加进来，并使用这个前瞻符号。\n        - $A \\to aA$：添加 $[A \\to \\cdot aA, \\$]$。\n        - $A \\to a$：添加 $[A \\to \\cdot a, \\$]$。\n    集合变为 $\\{[A \\to a \\cdot A, \\$], [A \\to a \\cdot, \\$], [A \\to \\cdot aA, \\$], [A \\to \\cdot a, \\$]\\}$。\n\n4.  新添加的项目点号后面是终结符 $a$，因此不能再添加更多项目。\n\n$I_2$ 的最终项目集是：\n$I_2 = \\{ [A \\to a \\cdot A, \\$], [A \\to a \\cdot, \\$], [A \\to \\cdot aA, \\$], [A \\to \\cdot a, \\$] \\}$.\n$I_2$ 中的项目数量为 $|I_2| = 4$。\n\n**最终计算**\n题目要求计算 $N$，即这三个集合中项目数量的总和。\n$N = |I_0| + |I_1| + |I_2|$\n$N = 7 + 1 + 4$\n$N = 12$", "answer": "$$\n\\boxed{12}\n$$", "id": "3627177"}, {"introduction": "接下来的练习将聚焦于一个关键且常常引起困惑的细节：能够推导出空串($\\epsilon$)的产生式如何影响先行符的计算。当一个非终结符可以为空时，它后面的符号就有可能成为先行符，这使得先行符的传播变得更加复杂。我们将通过为一个包含可空非终结符的文法计算闭包，来深入探讨这一机制，理解它是如何确保分析器在面对可能为空的语法结构时做出正确决策的。[@problem_id:3627141]", "problem": "考虑一个上下文无关文法，其非终结符为 $\\{S, A\\}$，终结符为 $\\{a\\}$，产生式为 $S \\to AA$ 和 $A \\to aA \\mid \\epsilon$。使用从左到右扫描、最右推导、带一个前瞻符（LR(1)）项的规范构造方法。一个 LR(1) 项写作 $[X \\to \\alpha \\cdot \\beta, t]$ 的形式，其中 $X \\to \\alpha\\beta$ 是一个产生式，圆点表示分析器的位置，$t$ 是一个单独的前瞻终结符。对一个 LR(1) 项集 $I$ 的闭包操作 $\\mathrm{closure}(I)$ 定义为：重复应用以下规则直到没有新项可以添加为止：对于集合 $I$ 中的任意项 $[X \\to \\alpha \\cdot Y \\beta, a]$ 和任意产生式 $Y \\to \\gamma$，将每个项 $[Y \\to \\cdot \\gamma, b]$ 添加到集合中，其中 $b \\in \\mathrm{FIRST}(\\beta a)$，这里，对于一个符号序列 $\\omega$，$\\mathrm{FIRST}(\\omega)$ 是可以从 $\\omega$ 推导出的字符串的起始终结符集合，并且如果 $\\epsilon \\in \\mathrm{FIRST}(\\beta)$，则 $\\mathrm{FIRST}(\\beta a)=\\left(\\mathrm{FIRST}(\\beta)\\setminus\\{\\epsilon\\}\\right)\\cup\\{a\\}$。将不同的前瞻终结符视为产生不同的 LR(1) 项；不要通过合并前瞻集来合并项。\n\n从单个 LR(1) 项 $[S \\to \\cdot AA, \\$]$ 开始，其中 $\\$$ 表示输入结束标记，并被视为一个终结符，且 $\\mathrm{FIRST}(\\$)=\\{\\$\\}$，计算集合 $\\mathrm{closure}(\\{[S \\to \\cdot AA, \\$]\\}))$ 的基数。请用一个整数表示你的最终答案。无需四舍五入。", "solution": "该问题要求计算对一个给定的初始 LR(1) 项集（含一个项）执行 $\\mathrm{closure}$ 操作后所得集合的基数。文法和计算规则已明确给出。\n\n给定的上下文无关文法 $G$ 包含以下组成部分：\n- 非终结符：$N = \\{S, A\\}$\n- 终结符：$T = \\{a\\}$\n- 开始符号：$S$\n- 产生式 $P$：\n  1. $S \\to AA$\n  2. $A \\to aA$\n  3. $A \\to \\epsilon$（其中 $\\epsilon$ 表示空字符串）\n\n$\\mathrm{closure}$ 操作需要计算文法中非终结符的 $\\mathrm{FIRST}$ 集。\n\n首先，我们计算 $\\mathrm{FIRST}(A)$：\n根据产生式 $A \\to aA$，终结符 $a$ 属于 $\\mathrm{FIRST}(A)$。\n根据产生式 $A \\to \\epsilon$，空字符串 $\\epsilon$ 属于 $\\mathrm{FIRST}(A)$。\n因此，$\\mathrm{FIRST}(A) = \\{a, \\epsilon\\}$。\n\n问题定义的起始项集为 $I = \\{[S \\to \\cdot AA, \\$]\\}$。我们需要计算 $C = \\mathrm{closure}(I)$。这个过程从 $C = I$ 开始。然后，我们根据闭包规则迭代地向 $C$ 中添加项，直到没有新项可以添加为止。\n\n闭包规则规定：对于集合中的任意项 $[X \\to \\alpha \\cdot Y \\beta, t]$，其中 $Y$ 是一个非终结符，对于 $Y$ 的任意产生式 $Y \\to \\gamma$，我们必须为 $\\mathrm{FIRST}(\\beta t)$ 中的每个终结符 $b$ 添加项 $[Y \\to \\cdot \\gamma, b]$。\n\n我们开始计算：\n初始集合：$C_0 = \\{[S \\to \\cdot AA, \\$]\\}$。\n\n我们处理来自 $C_0$ 的项 $[S \\to \\cdot AA, \\$]$。\n- 该项的形式为 $[X \\to \\alpha \\cdot Y \\beta, t]$，其中 $X=S$，$\\alpha=\\epsilon$，$Y=A$，$\\beta=A$，前瞻终结符为 $t=\\$$.\n- 我们需要为新项找到前瞻符，这由集合 $\\mathrm{FIRST}(\\beta t) = \\mathrm{FIRST}(A\\$)$ 给出。\n- 为了计算 $\\mathrm{FIRST}(A\\$)$，我们使用给定的规则：因为 $\\epsilon \\in \\mathrm{FIRST}(A)$，所以 $\\mathrm{FIRST}(A\\$) = (\\mathrm{FIRST}(A)\\setminus\\{\\epsilon\\}) \\cup \\mathrm{FIRST}(\\$)$.\n- 我们已知 $\\mathrm{FIRST}(\\$) = \\{\\$\\}$。\n- 因此，$\\mathrm{FIRST}(A\\$) = (\\{a, \\epsilon\\}\\setminus\\{\\epsilon\\}) \\cup \\{\\$\\} = \\{a, \\$\\}$。\n- 新项的前瞻符是 $a$ 和 $\\$$。\n\n现在，我们为 $A$ 的每个产生式（$A \\to aA$ 和 $A \\to \\epsilon$）以及每个前瞻符添加项。问题指明，具有不同前瞻符的项是不同的。\n- 对于产生式 $A \\to aA$：\n  - 前瞻符为 $a$：添加 $[A \\to \\cdot aA, a]$。\n  - 前瞻符为 $\\$$：添加 $[A \\to \\cdot aA, \\$]$。\n- 对于产生式 $A \\to \\epsilon$：\n  - 前瞻符为 $a$：添加 $[A \\to \\cdot, a]$。\n  - 前瞻符为 $\\$$：添加 $[A \\to \\cdot, \\$]$。\n\n完成这第一步后，项集为：\n$C_1 = C_0 \\cup \\{[A \\to \\cdot aA, a], [A \\to \\cdot aA, \\$], [A \\to \\cdot, a], [A \\to \\cdot, \\$] \\}$。\n所以，当前的集合是：\n1. $[S \\to \\cdot AA, \\$]$\n2. $[A \\to \\cdot aA, a]$\n3. $[A \\to \\cdot aA, \\$]$\n4. $[A \\to \\cdot, a]$\n5. $[A \\to \\cdot, \\$]$\n\n现在，我们必须检查对任何新添加的项应用闭包规则是否会生成更多的项。\n- 考虑项 2：$[A \\to \\cdot aA, a]$。圆点在终结符 $a$ 的前面。闭包规则仅在圆点位于非终结符前面时适用。因此，没有新项被添加。\n- 考虑项 3：$[A \\to \\cdot aA, \\$]$。同样，圆点在终结符前面，因此没有新项被添加。\n- 考虑项 4：$[A \\to \\cdot, a]$。圆点在产生式规则的末尾（$\\gamma=\\epsilon$）。这样的项是一个“规约”项，不会通过闭包规则添加新项。\n- 考虑项 5：$[A \\to \\cdot, \\$]$。这也是一个规约项，不添加新项。\n\n由于没有新项可以添加到集合中，闭包过程终止。最终的集合是 $C_1$。\n集合 $\\mathrm{closure}(\\{[S \\to \\cdot AA, \\$]\\})$ 由以下 5 个不同的项组成：\n1. $[S \\to \\cdot AA, \\$]$\n2. $[A \\to \\cdot aA, a]$\n3. $[A \\to \\cdot, a]$\n4. $[A \\to \\cdot aA, \\$]$\n5. $[A \\to \\cdot, \\$]$\n\n问题要求计算该集合的基数。通过计算不同项的数量，我们发现基数为 $5$。", "answer": "$$\n\\boxed{5}\n$$", "id": "3627141"}, {"introduction": "最后，让我们将所学知识应用于经典的表达式文法，这是一个在编译器设计中无处不在的例子。本练习将通过计算一个`goto`操作序列，来模拟语法分析器在读取输入符号（如`+`号）时，其状态机的跳转过程。这展示了闭包和`goto`操作如何协同工作，一步步地驱动分析过程，并构建出能够处理复杂嵌套结构的分析状态。[@problem_id:3627138]", "problem": "考虑包含产生式 $E \\to E + T \\mid T$、$T \\to T * F \\mid F$ 和 $F \\to ( E ) \\mid id$ 的表达式语法。通过引入新的起始符号 $S'$ 和产生式 $S' \\to E$ 来增广该语法。使用规范的 LR(1)（从左到右，最右推导，带一个前看符号）项目构造方法，令 $I_0 = \\operatorname{closure}(\\{[S' \\to \\cdot E, \\$]\\})$, 其中 $\\$$ 表示输入结束。定义 $I_E = \\operatorname{goto}(I_0, E)$，然后定义 $I_{+} = \\operatorname{goto}(I_E, +)$。从 LR(1) 项目、$\\operatorname{closure}$ 算子、$\\operatorname{goto}$ 算子以及关于终结符/非终结符序列的 $FIRST$ 函数的核心定义出发，确定项目集 $I_{+}$ 中包含的独立 LR(1) 项目的确切数量。将最终答案表示为一个不带单位的整数。无需四舍五入。", "solution": "该问题要求计算项目集 $I_{+}$ 中 LR(1) 项目的数量，该项目集由给定的表达式语法派生而来。一个 LR(1) 项目的形式为 $[A \\to \\alpha \\cdot \\beta, a]$，其中 $A \\to \\alpha \\beta$ 是一个产生式，$a$ 是一个终结符，称为前看符号。\n\n增广语法为：\n$S' \\to E$\n$E \\to E + T \\mid T$\n$T \\to T * F \\mid F$\n$F \\to ( E ) \\mid id$\n\n非终结符集为 $\\{S', E, T, F\\}$，终结符集为 $\\{+, *, (, ), id\\}$。\n\n计算需要三个核心函数：$FIRST$、$\\operatorname{closure}$ 和 $\\operatorname{goto}$。\n\n首先，我们确定非终结符的 $FIRST$ 集，即可以出现在由该非终结符派生的字符串开头的终结符集合。\n-   $\\operatorname{FIRST}(F)$：根据产生式 $F \\to (E)$，终结符 `(` 在 $\\operatorname{FIRST}(F)$ 中。根据 $F \\to id$，终结符 `id` 在 $\\operatorname{FIRST}(F)$ 中。因此，$\\operatorname{FIRST}(F) = \\{ (, id \\}$。\n-   $\\operatorname{FIRST}(T)$：产生式 $T \\to F$ 意味着 $\\operatorname{FIRST}(T)$ 包含 $\\operatorname{FIRST}(F)$。产生式 $T \\to T * F$ 是左递归的，其首个终结符由非递归产生式决定。因此，$\\operatorname{FIRST}(T) = \\operatorname{FIRST}(F) = \\{ (, id \\}$。\n-   $\\operatorname{FIRST}(E)$：产生式 $E \\to T$ 意味着 $\\operatorname{FIRST}(E)$ 包含 $\\operatorname{FIRST}(T)$。产生式 $E \\to E + T$ 是左递归的。因此，$\\operatorname{FIRST}(E) = \\operatorname{FIRST}(T) = \\{ (, id \\}$。\n\n对一个项目集 $I$ 的 $\\operatorname{closure}(I)$ 操作定义如下：\n$1$. 最初，$I$ 中的每个项目都在 $\\operatorname{closure}(I)$ 中。\n$2$. 如果一个项目 $[A \\to \\alpha \\cdot B \\beta, a]$ 在 $\\operatorname{closure}(I)$ 中，且 $B \\to \\gamma$ 是一个产生式，那么对于 $\\operatorname{FIRST}(\\beta a)$ 中的每个终结符 $b$，我们将项目 $[B \\to \\cdot \\gamma, b]$ 添加到集合中。\n$3$. 重复此过程，直到没有新项目可以添加为止。\n\n$\\operatorname{goto}(I, X)$ 函数定义为 $\\operatorname{goto}(I, X) = \\operatorname{closure}(\\{[A \\to \\alpha X \\cdot \\beta, a] \\mid [A \\to \\alpha \\cdot X \\beta, a] \\in I\\})$。\n\n问题要求我们计算 $I_{+} = \\operatorname{goto}(I_E, +)$，其中 $I_E = \\operatorname{goto}(I_0, E)$ 且 $I_0 = \\operatorname{closure}(\\{[S' \\to \\cdot E, \\$]\\})$。\n\n**步骤1：确定 $I_E = \\operatorname{goto}(I_0, E)$ 的核心**\n为了计算 $\\operatorname{goto}(I_0, E)$，我们需要 $I_0$ 中形如 $[A \\to \\alpha \\cdot E \\beta, a]$ 的项目。\n$I_0$ 的初始项目集是 $\\{[S' \\to \\cdot E, \\$]\\}$。我们计算 $I_0$ 的闭包，只需找到所有包含 `•E` 的项目即可。\n$1$. $I_0$ 的核心包含 $[S' \\to \\cdot E, \\$]$。\n$2$. 从 $[S' \\to \\cdot E, \\$]$ 出发，闭包操作添加了 $E$ 的产生式项目。前看符号由 $\\operatorname{FIRST}(\\epsilon \\$) = \\{\\$\\}$ 导出。这会添加 $[E \\to \\cdot E+T, \\$]$ 和 $[E \\to \\cdot T, \\$]$。\n$3$. 从新项目 $[E \\to \\cdot E+T, \\$]$ 出发，闭包操作添加了 $E$ 的产生式项目。前看符号由 $\\operatorname{FIRST}(+T\\$) = \\{+\\}$ 导出。这会添加 $[E \\to \\cdot E+T, +]$ 和 $[E \\to \\cdot T, +]$。\n不会生成其他带有 `•E` 的项目。\n因此，$I_0$ 中点在 $E$ 之前的项目有：\n-   $[S' \\to \\cdot E, \\$]$\n-   $[E \\to \\cdot E+T, \\$]$\n-   $[E \\to \\cdot E+T, +]$\n将这些项目中的点移过 $E$ 之后，我们得到 $I_E$ 的核心：\n核心$(I_E) = \\{[S' \\to E \\cdot, \\$], [E \\to E \\cdot+T, \\$], [E \\to E \\cdot+T, +]\\}$。\n\n**步骤2：计算 $I_E = \\operatorname{closure}(\\text{核心}(I_E))$**\n我们现在计算这个核心集的闭包。\n-   $[S' \\to E \\cdot, \\$]$：点在产生式的末尾。不添加任何项目。\n-   $[E \\to E \\cdot+T, \\$]$：点在一个终结符 ($+$) 之前。不添加任何项目。\n-   $[E \\to E \\cdot+T, +]$：点在一个终结符 ($+$) 之前。不添加任何项目。\n由于每个核心项目中的点都不在非终结符之前，所以闭包操作不添加新项目。\n因此，$I_E = \\{[S' \\to E \\cdot, \\$], [E \\to E \\cdot+T, \\$], [E \\to E \\cdot+T, +]\\}$。\n\n**步骤3：确定 $I_{+} = \\operatorname{goto}(I_E, +)$ 的核心**\n为了计算 $\\operatorname{goto}(I_E, +)$，我们需要 $I_E$ 中形如 $[A \\to \\alpha \\cdot + \\beta, a]$ 的项目。这些是：\n-   $[E \\to E \\cdot+T, \\$]$\n-   $[E \\to E \\cdot+T, +]$\n将点移过 $+$ 之后，得到 $I_{+}$ 的核心：\n核心$(I_{+}) = \\{[E \\to E+ \\cdot T, \\$], [E \\to E+ \\cdot T, +]\\}$。\n\n**步骤4：计算 $I_{+} = \\operatorname{closure}(\\text{核心}(I_{+}))$**\n我们现在计算这个核心集的闭包。\n$1$. 从核心开始：$I_{+} = \\{[E \\to E+ \\cdot T, \\$], [E \\to E+ \\cdot T, +]\\}$。\n$2$. 处理 $[E \\to E+ \\cdot T, \\$]$。点在非终结符 $T$ 之前。$T$ 的产生式的前看符号来自 $\\operatorname{FIRST}(\\epsilon \\$) = \\{\\$\\}$。这会添加：\n    -   $[T \\to \\cdot T*F, \\$]$\n    -   $[T \\to \\cdot F, \\$]$\n$3$. 处理 $[E \\to E+ \\cdot T, +]$。点在 $T$ 之前。前看符号来自 $\\operatorname{FIRST}(\\epsilon +) = \\{+\\}$。这会添加：\n    -   $[T \\to \\cdot T*F, +]$\n    -   $[T \\to \\cdot F, +]$\n$4$. 处理新项目。从 $[T \\to \\cdot T*F, \\$]$ 和 $[T \\to \\cdot T*F, +]$ 出发，点在 $T$ 之前。$T$ 的产生式的前看符号来自 $\\operatorname{FIRST}(*F\\$) = \\{*\\}$ 和 $\\operatorname{FIRST}(*F+) = \\{*\\}$。这会添加：\n    -   $[T \\to \\cdot T*F, *]$\n    -   $[T \\to \\cdot F, *]$\n$5$. 处理带有 `•F` 的项目。这些是 $[T \\to \\cdot F, l]$，其中前看符号 $l \\in \\{\\$, +, *\\}$。点在 $F$ 之前。$F$ 的产生式的前看符号是 $l$ 本身，因为它们来自 $\\operatorname{FIRST}(\\epsilon l) = \\{l\\}$。这会添加：\n    -   $[F \\to \\cdot (E), \\$]$ 和 $[F \\to \\cdot id, \\$]$\n    -   $[F \\to \\cdot (E), +]$ 和 $[F \\to \\cdot id, +]$\n    -   $[F \\to \\cdot (E), *]$ 和 $[F \\to \\cdot id, *]$\n闭包过程现在完成了，因为没有新项目可以添加。\n\n**步骤5：计算 $I_{+}$ 中的项目数量**\n我们列出 $I_{+}$ 中所有不同的项目：\n-   来自 $I_{+}$ 的核心：\n    $1$. $[E \\to E+ \\cdot T, \\$]$\n    $2$. $[E \\to E+ \\cdot T, +]$\n-   由 $T$ 产生式的闭包添加：\n    $3$. $[T \\to \\cdot T*F, \\$]$\n    $4$. $[T \\to \\cdot T*F, +]$\n    $5$. $[T \\to \\cdot T*F, *]$\n    $6$. $[T \\to \\cdot F, \\$]$\n    $7$. $[T \\to \\cdot F, +]$\n    $8$. $[T \\to \\cdot F, *]$\n-   由 $F$ 产生式的闭包添加：\n    $9$. $[F \\to \\cdot (E), \\$]$\n    $10$. $[F \\to \\cdot (E), +]$\n    $11$. $[F \\to \\cdot (E), *]$\n    $12$. $[F \\to \\cdot id, \\$]$\n    $13$. $[F \\to \\cdot id, +]$\n    $14$. $[F \\to \\cdot id, *]$\n\n项目集 $I_{+}$ 中独立 LR(1) 项目的总数是这些项目数量的总和。\n-   产生式 $E \\to E+T$ 的项目：$2$\n-   产生式 $T \\to T*F$ 的项目：$3$\n-   产生式 $T \\to F$ 的项目：$3$\n-   产生式 $F \\to (E)$ 的项目：$3$\n-   产生式 $F \\to id$ 的项目：$3$\n项目总数 = $2 + 3 + 3 + 3 + 3 = 14$。", "answer": "$$\n\\boxed{14}\n$$", "id": "3627138"}]}