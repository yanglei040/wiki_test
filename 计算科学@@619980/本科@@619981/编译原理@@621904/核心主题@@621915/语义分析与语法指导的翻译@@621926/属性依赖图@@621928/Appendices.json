{"hands_on_practices": [{"introduction": "掌握属性依赖图的第一步是为一个简单的例子从头开始构建它。这个练习将重点关注纯粹的综合属性，通过它我们将看到其自下而上的依赖流如何保证图的无环性，这是可调度性的一个基本属性。通过这次实践，你将巩固对语义规则如何直接转化为图依赖关系的理解，并明白为何即使是像左递归这样语法上复杂的结构，也不会对此类属性的求值构成问题 [@problem_id:3622334]。", "problem": "考虑一个只有一个非终结符 $S$ 的上下文无关文法，其产生式为 $S \\to S\\ S \\mid a$。定义一个综合属性 `S.count`，其值等于以 $S$ 为根的子树中叶终结符 $a$ 的数量。根据综合属性的定义，父节点处的 `S.count` 是其产生式右侧符号属性的函数，而绝不依赖于其父节点或子树外部兄弟节点的属性。请为该文法指定与此定义一致的语义规则。\n\n现在，考虑输入字符串 `aaaa` 和以下左分支分析树（由一个左递归推导产生），其中每个内部的 $S$ 都使用 $S \\to S\\ S$ 进行展开，直到使用叶产生式 $S \\to a$：\n- 根节点 $S_0$ 有子节点 $S_1$ 和 $S_2$。\n- $S_1$ 有子节点 $S_3$ 和 $S_4$。\n- $S_3$ 有子节点 $S_5$ 和 $S_6$。\n- $S_5 \\to a$，$S_6 \\to a$，$S_4 \\to a$ 和 $S_2 \\to a$。\n\n使用属性依赖图（ADG）的标准定义，其中每个节点是一个属性的出现（此处为每个分析树节点 $S_i$ 的 `S_i.count` 的出现），每条有向边 $X \\to Y$ 表示属性 $Y$ 的值直接依赖于属性 $X$ 的值，为该分析树构建 ADG。然后，基于属性文法和依赖图的基本原理，论证文法中的左递归是否影响该文法任意分析树的 `S.count` 的可调度性或求值顺序。\n\n选择所有正确的陈述：\n\nA. 对于该文法在这些属性规则下的任何分析树，ADG 都是无环的，其边从子节点的属性指向其父节点的属性，并且对分析树的任何后序遍历都会为所有 `S.count` 生成一个有效的求值调度。左递归不会引入环。\n\nB. 因为文法是左递归的，ADG 必然在某个节点处包含一个形如 $S_i.count \\to S_i.count$ 的环，因此 `S.count` 的求值需要迭代不动点计算。\n\nC. 该属性方案是 S-属性的，并且可以在一次自底向上的遍中计算（例如，在自左向右最右推导（LR）分析期间），无论文法是左递归还是右递归。\n\nD. 由于左递归，必须严格按照最左推导序列从左到右对 `S.count` 求值；任何其他调度都有使用未初始化属性的风险。\n\nE. 消除左递归（例如，通过文法转换）会从根本上改变 `S.count` 的有效调度集，因为该属性会变成继承属性而不是综合属性。", "solution": "首先验证问题陈述，以确保其科学上合理、定义明确且客观。\n\n### 步骤 1：提取已知条件\n-   **文法：** 一个只有一个非终结符 $S$ 的上下文无关文法。\n-   **产生式：** $S \\to S\\ S \\mid a$。\n-   **属性：** 一个名为 `S.count` 的综合属性。\n-   **属性定义：** `S.count` 等于以 $S$ 为根的子树中叶终结符 $a$ 的数量。\n-   **综合属性特性：** 父节点上的值是在该节点使用的产生式右侧符号属性的函数。\n-   **输入字符串：** `aaaa`。\n-   **分析树：** 提供了输入字符串 `aaaa` 的一个特定的左分支分析树：\n    -   根节点 $S_0$ 有子节点 $S_1$ 和 $S_2$ （产生式 $S_0 \\to S_1 S_2$）。\n    -   $S_1$ 有子节点 $S_3$ 和 $S_4$ （产生式 $S_1 \\to S_3 S_4$）。\n    -   $S_3$ 有子节点 $S_5$ 和 $S_6$ （产生式 $S_3 \\to S_5 S_6$）。\n    -   叶产生式为 $S_5 \\to a$，$S_6 \\to a$，$S_4 \\to a$ 和 $S_2 \\to a$。对叶节点的中序遍历得到字符串 $a a a a$。\n-   **属性依赖图 (ADG) 定义：** 节点是属性的出现（`S_i.count`）。一条有向边 $X \\to Y$ 表示属性 $Y$ 的值直接依赖于属性 $X$ 的值。\n-   **任务：** 为给定的树构建 ADG，并论证左递归对 `S.count` 可调度性的影响。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题使用了编译原理中标准的、定义明确的概念，包括上下文无关文法、综合属性、分析树、属性依赖图和左递归。所提供的定义与公认的计算机科学原理一致。\n2.  **定义明确：** 问题陈述清晰。文法、属性和特定的分析树都得到了明确的定义。问题要求基于这些定义进行分析，这可以得出一个明确的结论。\n3.  **客观性：** 语言是形式化且客观的。\n\n问题陈述是完整的、一致的，并且基于已建立的理论。\n\n### 步骤 3：结论与行动\n问题是 **有效的**。现在开始解答过程。\n\n### 推导与分析\n\n首先，我们必须根据属性 `S.count` 的定义为其指定语义规则。这些规则将计算与文法中的每个产生式关联起来。\n\n1.  对于产生式 $S \\to a$：以此 $S$ 为根的子树由单个叶节点 $a$ 组成。因此，$a$ 的计数为 $1$。\n    -   语义规则：$S.count \\leftarrow 1$。\n\n2.  对于产生式 $S_0 \\to S_1 S_2$（使用下标区分不同的出现）：$S_0$ 子树中的终结符是其子节点 $S_1$ 和 $S_2$ 子树中终结符的并集。因此，总计数是两个子树计数的总和。\n    -   语义规则：$S_0.count \\leftarrow S_1.count + S_2.count$。\n\n这两条规则完全定义了该文法生成的任何分析树的 `S.count` 的计算。该属性是纯粹综合的，因为父节点上的值仅依赖于其子节点上属性的值（或者对于终结符产生式来说是一个常数）。\n\n接下来，我们分析属性依赖图（ADG）的性质。根据定义，如果属性 $Y$ 的语义规则使用了属性 $X$ 的值，则存在一条从属性实例 $X$ 到属性实例 $Y$ 的边。\n对于我们的规则：\n-   $S_0.count \\leftarrow S_1.count + S_2.count$：这会创建从 `S_1.count` 到 `S_0.count` 以及从 `S_2.count` 到 `S_0.count` 的依赖边。\n-   $S.count \\leftarrow 1$：这不会创建对其他属性的依赖。\n\n一般而言，对于任何综合属性，ADG 中的依赖边总是从子节点的属性指向其父节点的属性。由于分析树是一种树形结构，节点不能是自身的祖先，因此沿着这些指向父节点的边不可能形成环。因此，任何只有综合属性的文法的 ADG 始终是一个有向无环图（DAG）。\n\n属性的有效求值调度是 ADG 节点的拓扑排序。由于依赖关系是沿树向上传递的，任何在计算父节点属性之前先计算子节点属性的求值顺序都是有效的。分析树的后序遍历恰好具有此性质：它只有在访问完所有子节点后才会访问一个节点。因此，任何后序遍历都会生成一个有效的调度。\n\n文法 $S \\to S\\ S \\mid a$ 是左递归的，因为非终结符 $S$ 出现在产生式 $S \\to S\\ S$ 右侧的最左边。这个性质影响了分析树的结构（如示例所示，倾向于左深），但它不改变综合属性的基本性质。`S.count` 的依赖关系仍然严格地从子节点向父节点流动，因此左递归不会在 ADG 中引入环。\n\n### 逐个选项评估\n\n**A. 对于该文法在这些属性规则下的任何分析树，ADG 都是无环的，其边从子节点的属性指向其父节点的属性，并且对分析树的任何后序遍历都会为所有 `S.count` 生成一个有效的求值调度。左递归不会引入环。**\n这个陈述准确地总结了综合属性的性质。\n-   如上所述，ADG 确实是无环的，其边从子节点指向父节点。\n-   后序遍历是此 ADG 的一种拓扑排序，使其成为一个有效的求值调度。\n-   左递归不会改变综合属性的自底向上数据流，因此不会创建环。\n该陈述与属性文法理论完全一致。\n**结论：正确。**\n\n**B. 因为文法是左递归的，ADG 必然在某个节点处包含一个形如 $S_i.count \\to S_i.count$ 的环，因此 `S.count` 的求值需要迭代不动点计算。**\n这是不正确的。一个形如 $S_i.count \\to S_i.count$ 的环意味着存在一条属性依赖于自身的语义规则，例如 $S.count \\leftarrow S.count + 1$。我们推导出的规则是 $S_0.count \\leftarrow S_1.count + S_2.count$ 和 $S.count \\leftarrow 1$。这两个规则都不是自引用的。文法中的左递归并不意味着综合属性的属性定义中存在循环依赖。\n**结论：不正确。**\n\n**C. 该属性方案是 S-属性的，并且可以在一次自底向上的遍中计算（例如，在自左向右最右推导（LR）分析期间），无论文法是左递归还是右递归。**\n如果一个属性文法只使用综合属性，它就被定义为 S-属性文法。这里就是这种情况。S-属性文法的一个关键特性是它们的属性可以在一次自底向上的分析过程中被求值。LR 分析器通过从叶节点到根节点构建分析树来进行自底向上分析。当它通过一个产生式 $A \\to \\beta$ 进行规约时，$\\beta$ 中符号的子树已经被处理，所以它们的属性是已知的，可以用来计算 $A$ 的属性。这种求值策略适用于任何 S-属性文法，无论其递归结构如何。\n**结论：正确。**\n\n**D. 由于左递归，必须严格按照最左推导序列从左到右对 `S.count` 求值；任何其他调度都有使用未初始化属性的风险。**\n最左推导对应于分析树的前序遍历。在前序遍历中，父节点在其子节点之前被访问。试图按此顺序求值像 `S.count` 这样的综合属性，将意味着在子节点的属性已知之前尝试计算父节点的属性，这违反了依赖关系。例如，人们会尝试在 `S_1.count` 和 `S_2.count` 之前计算 `S_0.count`，这是不可能的。这种求值策略适用于继承属性，而不适用于综合属性。\n**结论：不正确。**\n\n**E. 消除左递归（例如，通过文法转换）会从根本上改变 `S.count` 的有效调度集，因为该属性会变成继承属性而不是综合属性。**\n这个陈述过于绝对，因此是错误的。虽然消除左递归的一种常用技术（通常是为了使文法适用于 LL 分析）确实涉及引入继承属性来传递先前在左递归链上累积的信息，但这并不是一个必然的结果。由 $S \\to S\\ S \\mid a$ 生成的语言是所有非空 $a$ 字符串的集合，即 $a^+$。该语言的一个等价、无歧义且非左递归的文法是 $S \\to a S \\mid a$。对于这个新文法，我们可以用纯粹的综合属性来定义计数：\n-   对于 $S \\to a$：$S.count \\leftarrow 1$。\n-   对于 $S_0 \\to a S_1$：$S_0.count \\leftarrow 1 + S_1.count$。\n由于我们找到了一个等价的非左递归文法，其属性仍然是综合的，因此声称该属性*必须*变为继承属性的说法是错误的。因此，所谓的根本性改变的推理是有缺陷的。\n**结论：不正确。**", "answer": "$$\\boxed{AC}$$", "id": "3622334"}, {"introduction": "一旦我们构建了属性依赖图，就可以用它来分析性能。这个练习将属性求值建模为一组具有依赖关系和执行耗时的任务。我们将学习识别图中的“关键路径”——即最长的依赖链，在理想的并行环境下，这条路径的总耗时决定了完成所有计算所需的最短时间 [@problem_id:3622392]。这个基于计算的实践将理论上的ADG模型与编译器速度这一实际问题联系起来，展示了图分析如何帮助我们预测性能瓶颈。", "problem": "考虑一个属性依赖图 (ADG)，其中每个节点代表属性文法中的一个属性实例，每条有向边代表一个依赖关系，该依赖关系必须在计算依赖属性之前得到满足。设边上的延迟函数表示为 $\\ell(u,v) \\in \\mathbb{R}_{\\ge 0}$，它代表节点 $u$ 产生的值可供节点 $v$ 使用所需的时间。假设编译在完美并行的条件下进行：处理器数量不限，任务创建和通信开销为零，并严格遵守依赖约束。\n\n给定一个 ADG 实例，其节点为 $v_1, v_2, \\dots, v_8$，带延迟的有向边如下：\n- $v_1 \\to v_3$，延迟 $\\ell(v_1,v_3) = 3$。\n- $v_1 \\to v_4$，延迟 $\\ell(v_1,v_4) = 2$。\n- $v_2 \\to v_4$，延迟 $\\ell(v_2,v_4) = 5$。\n- $v_3 \\to v_5$，延迟 $\\ell(v_3,v_5) = 4$。\n- $v_4 \\to v_5$，延迟 $\\ell(v_4,v_5) = 1$。\n- $v_4 \\to v_6$，延迟 $\\ell(v_4,v_6) = 7$。\n- $v_5 \\to v_7$，延迟 $\\ell(v_5,v_7) = 2$。\n- $v_6 \\to v_7$，延迟 $\\ell(v_6,v_7) = 3$。\n- $v_6 \\to v_8$，延迟 $\\ell(v_6,v_8) = 2$。\n- $v_7 \\to v_8$，延迟 $\\ell(v_7,v_8) = 4$。\n\n假设 $v_1$ 和 $v_2$ 是源节点（没有入边），$v_8$ 是最终的汇点节点，其值标志着所考虑代码片段的编译完成。\n\n仅使用有向无环图中的先行约束的基本定义和 ADG 依赖的语义，确定在完美并行假设下计算 $v_8$ 的最小可能完成时间，并解释为什么该时间由给定 ADG 中关键路径的长度作为下界。将关键路径长度的精确值作为您的最终答案。您的答案应以抽象延迟单位表示，且不进行四舍五入。", "solution": "用户想要解决该问题，且该问题已经过我验证。我现在将开始提供解答。\n\n该问题要求计算在给定的属性依赖图 (ADG) 中，计算节点 $v_8$ 处属性的最小完成时间。ADG 是一个有向无环图 (DAG)，其中节点代表属性计算，有向边 $(u, v)$ 代表依赖关系，即计算属性 $v$ 需要属性 $u$ 的值。边的权重由延迟函数 $\\ell(u,v)$ 表示，代表在节点 $u$ 本身计算完成后，其值可用于节点 $v$ 计算所需的时间。问题指定了一个完美并行环境，这意味着只要数据依赖关系得到满足，任意数量的计算都可以同时进行。\n\n设 $T_i$ 是与节点 $v_i$ 对应的属性计算完成的最早可能时间。目标是求出 $T_8$。\n\n问题指出 $v_1$ 和 $v_2$ 是源节点，意味着它们没有入边。在此模型中，它们的值可以被认为在过程开始时（我们定义为时间 $t=0$）就可用。因此，它们的完成时间为 $T_1 = 0$ 和 $T_2 = 0$。\n\n对于任何其他节点 $v_j$，其计算只有在所有前置属性都可用后才能完成。来自前驱节点 $v_i$ 的前置条件在时间 $T_i + \\ell(v_i, v_j)$ 变为可用于 $v_j$ 的计算。由于 $v_j$ 可能依赖于多个前驱节点，其计算必须等待最后到达的前置条件。在完美并行下，一旦所有输入都准备就绪，计算本身所需的时间可以忽略不计。因此，非源节点 $v_j$ 的完成时间 $T_j$ 由其所有必要输入的到达时间的最大值给出。这可以通过递推关系表示：\n$$\nT_j = \\max_{v_i \\to v_j} \\{ T_i + \\ell(v_i, v_j) \\}\n$$\n其中，最大值是在所有存在到 $v_j$ 的有向边的节点 $v_i$ 上计算的。\n\n这个递推关系定义了加权 DAG 中从任意源节点到节点 $v_j$ 的最长路径的长度。整个计算的最小完成时间（最终在 $v_8$ 完成）因此等价于从源节点（$v_1$ 或 $v_2$）到汇点节点 $v_8$ 的最长路径的长度。这条最长路径被称为图的关键路径。沿此路径的任何延迟都会直接增加总完成时间。\n\n我们可以按照图的拓扑顺序计算所有节点 $T_i$ 的值。一个有效的拓扑顺序是 $(v_1, v_2, v_3, v_4, v_5, v_6, v_7, v_8)$。\n\n1.  **基础情况（源节点）：**\n    $T_1 = 0$\n    $T_2 = 0$\n\n2.  **计算 $T_3$：** 节点 $v_3$ 仅依赖于 $v_1$。\n    $T_3 = T_1 + \\ell(v_1, v_3) = 0 + 3 = 3$\n\n3.  **计算 $T_4$：** 节点 $v_4$ 依赖于 $v_1$ 和 $v_2$。\n    $T_4 = \\max \\{ T_1 + \\ell(v_1, v_4), T_2 + \\ell(v_2, v_4) \\}$\n    $T_4 = \\max \\{ 0 + 2, 0 + 5 \\} = \\max \\{ 2, 5 \\} = 5$\n\n4.  **计算 $T_5$：** 节点 $v_5$ 依赖于 $v_3$ 和 $v_4$。\n    $T_5 = \\max \\{ T_3 + \\ell(v_3, v_5), T_4 + \\ell(v_4, v_5) \\}$\n    $T_5 = \\max \\{ 3 + 4, 5 + 1 \\} = \\max \\{ 7, 6 \\} = 7$\n\n5.  **计算 $T_6$：** 节点 $v_6$ 仅依赖于 $v_4$。\n    $T_6 = T_4 + \\ell(v_4, v_6) = 5 + 7 = 12$\n\n6.  **计算 $T_7$：** 节点 $v_7$ 依赖于 $v_5$ 和 $v_6$。\n    $T_7 = \\max \\{ T_5 + \\ell(v_5, v_7), T_6 + \\ell(v_6, v_7) \\}$\n    $T_7 = \\max \\{ 7 + 2, 12 + 3 \\} = \\max \\{ 9, 15 \\} = 15$\n\n7.  **计算 $T_8$：** 节点 $v_8$ 依赖于 $v_6$ 和 $v_7$。\n    $T_8 = \\max \\{ T_6 + \\ell(v_6, v_8), T_7 + \\ell(v_7, v_8) \\}$\n    $T_8 = \\max \\{ 12 + 2, 15 + 4 \\} = \\max \\{ 14, 19 \\} = 19$\n\n$v_8$ 的最小完成时间是 $T_8 = 19$。这个值代表了关键路径的长度。我们可以从 $v_8$ 回溯来确定这条路径。\n$T_8 = 19$ 的值来自于对 $v_7$ 的依赖 ($T_7 + 4$)。\n$T_7 = 15$ 的值来自于对 $v_6$ 的依赖 ($T_6 + 3$)。\n$T_6 = 12$ 的值来自于对 $v_4$ 的依赖 ($T_4 + 7$)。\n$T_4 = 5$ 的值来自于对 $v_2$ 的依赖 ($T_2 + 5$)。\n$T_2 = 0$ 是一个基础情况。\n\n因此，关键路径是 $v_2 \\to v_4 \\to v_6 \\to v_7 \\to v_8$。该路径的长度是其各边延迟的总和：\n$\\ell(v_2, v_4) + \\ell(v_4, v_6) + \\ell(v_6, v_7) + \\ell(v_7, v_8) = 5 + 7 + 3 + 4 = 19$。\n\n这证实了最小完成时间确实是关键路径的长度，即 19 个抽象延迟单位。", "answer": "$$\\boxed{19}$$", "id": "3622392"}, {"introduction": "现实世界中的编译器任务通常涉及比简单自下而上更复杂的依赖关系。本练习将探讨一个计算函数栈帧布局的真实场景，这其中混合了综合属性和继承属性，导致依赖关系在解析树中上下流动。通过构建属性依赖图，你将亲身体会到为何单遍遍历解析树不足以完成计算，以及依赖图如何揭示多遍求值策略的必要性——这是真实编译器中的一项常用技术 [@problem_id:3622373]。", "problem": "考虑编译器原理中的以下设定。属性文法（AG）通过语义属性和语义方程来扩展上下文无关文法。属性依赖图（ADG）是一个有向图，其节点是属性实例，其边表示由语义方程引起的直接依赖关系：如果定义属性 $b$ 的方程使用了属性 $a$，那么就存在一条从 $a$ 到 $b$ 的有向边。一个良构的 AG 对于任何输入都应产生一个无环的 ADG，从而使得拓扑求值成为可能。\n\n假设我们定义一个 AG 片段，用于计算函数的栈帧布局。该 AG 有一个综合属性 `F.size` 表示总帧大小，并为每个变量声明提供一个综合属性 `V.offset`，表示从帧底部到该变量存储起始位置的距离。栈向下增长，帧具有固定的头部开销 $h$，变量的大小由其类型决定。\n\n文法片段：\n- $F \\to \\text{func}~Id~\\{~DL~\\}$\n- $DL \\to V~DL \\mid \\epsilon$\n- $V \\to \\text{var}~Id~:~T~;$\n- $T \\to int \\mid float$\n\n给定大小 $size(int) = 4$，$size(float) = 8$，以及帧头部开销 $h = 16$。\n\n属性：\n- `T.size` 是综合属性：若 $T \\to int$ 则 `T.size` $\\leftarrow$ `4`，若 $T \\to float$ 则 `T.size` $\\leftarrow$ `8`。\n- `V.size` 是综合属性：`V.size` $\\leftarrow$ `T.size`。\n- `DL.totalSize` 是综合属性：当 $DL \\to \\epsilon$ 时，`DL.totalSize` $\\leftarrow$ `0`；当 $DL \\to V~DL_1$ 时，`DL.totalSize` $\\leftarrow$ `V.size` + `DL_1.totalSize`。\n- `DL.prefix` 是继承属性：在 $F$ 下的 $DL$ 处，`DL.prefix` $\\leftarrow$ `0`；当 $DL \\to V~DL_1$ 时，传递 `V.prefix` $\\leftarrow$ `DL.prefix` 和 `DL_1.prefix` $\\leftarrow$ `DL.prefix` + `V.size`。\n- `F.size` 是综合属性：在 $F \\to \\text{func}~Id~\\{~DL~\\}$ 处，`F.size` $\\leftarrow$ `h` + `DL.totalSize`。\n- `V.offset` 是综合属性：在 $V \\to \\text{var}~Id~:~T~;$ 处，`V.offset` $\\leftarrow$ `F.size` - (h + `V.prefix` + `V.size`)，这使得 `V.offset` 依赖于 `F.size`，并强制要求偏移量是从帧底部开始计算的。\n\n考虑以下特定输入：\n- 一个函数 $f$，按顺序包含两个局部声明：$x : int;$ 和 $y : float;$。\n\n按如下方式标记语法分析树中的实例：$F$ 下的外部声明列表是 $DL_0$。第一个变量声明是 $V_1$，其类型为 $T_1$；下一个声明列表是 $DL_1$。第二个变量声明是 $V_2$，其类型为 $T_2$；下一个声明列表是 $DL_2$，然后 $DL_2 \\to \\epsilon$。\n\n任务：\n1) 为此输入构建属性依赖图（ADG），列出由上述语义规则所导出的节点（属性实例）和有向边。你的构建过程应明确体现出那些强制 `V.offset` 节点在 `F.size` 之后求值的依赖关系。\n2) 基于你的 ADG，指出下列哪种求值方案能确保每个 `V.offset` 节点都在 `F.size` 计算完毕之后才被计算。选择所有适用项。\n\n选项：\nA. 在对语法分析树进行单次从左到右的前序遍历中求值属性，在每个 `V.size` 已知后立即计算其 `V.offset`；最后更新 `F.size`。\nB. 根据语义方程构建 ADG，并对 ADG 进行全局拓扑排序；按排序后的顺序求值属性。\nC. 对树进行两次遍历：在第一次遍历中，计算所有的 `T.size`、`V.size`、`DL.totalSize` 和 `F.size`；在第二次遍历中，使用先前计算出的 `F.size` 和已经确定的 `V.prefix` 值来计算所有的 `V.offset`。\nD. 重新定义 `V.offset` 为 `V.offset` $\\leftarrow$ `h` + `V.prefix` 以打破其对 `F.size` 的依赖；然后在单次遍历中，在计算 `F.size` 之前计算所有的 `V.offset`。\n\n通过选择能保证在遵守所述语义的前提下，`V.offset` 节点在 `F.size` 之后计算的选项来回答多选部分。", "solution": "问题陈述已经过验证，被认为是合理的。这是一个在编译器构造领域，特别是关于属性文法及其求值方面，定义明确的问题。所有定义都清晰，设定内部一致，并在计算机科学原理上有坚实的科学基础。\n\n问题的核心是为由属性文法定义的一组属性确定一个正确的求值策略。一个正确的求值策略必须遵守由语义方程定义的依赖关系。我们将首先为给定输入构建属性依赖图（ADG），以明确这些依赖关系。\n\n### 1. 语法分析树和属性实例\n\n对于输入 `func f { var x : int; var y : float; }`，带有指定标记节点的语法分析树是：\n$F \\to \\text{func}~Id~\\{~DL_0~\\}$\n$DL_0 \\to V_1~DL_1$\n$V_1 \\to \\text{var}~Id~:~T_1~;$\n$T_1 \\to int$\n$DL_1 \\to V_2~DL_2$\n$V_2 \\to \\text{var}~Id~:~T_2~;$\n$T_2 \\to float$\n$DL_2 \\to \\epsilon$\n\nADG 的节点是与此语法分析树的节点相关联的属性实例。\n- **综合属性**：`T_1.size`, `T_2.size`, `V_1.size`, `V_2.size`, `DL_2.totalSize`, `DL_1.totalSize`, `DL_0.totalSize`, `F.size`, `V_1.offset`, `V_2.offset`。\n- **继承属性**：`DL_0.prefix`, `V_1.prefix`, `DL_1.prefix`, `V_2.prefix`, `DL_2.prefix`。\n\n### 2. 属性依赖图（ADG）构建\n\nADG 的有向边由语义方程确定。如果计算 $b$ 的值用到了 $a$ 的值，则存在一条从属性实例 $a$ 到 $b$ 的边（记作 $a \\to b$）。\n\n1.  **大小属性（综合属性）**：这些依赖关系通常沿着语法分析树向上流动。\n    - `T_1.size` $\\leftarrow$ `4`。\n    - `T_2.size` $\\leftarrow$ `8`。\n    - `V_1.size` $\\leftarrow$ `T_1.size` $\\implies$ `T_1.size` $\\to$ `V_1.size`。\n    - `V_2.size` $\\leftarrow$ `T_2.size` $\\implies$ `T_2.size` $\\to$ `V_2.size`。\n    - `DL_2.totalSize` $\\leftarrow$ `0`。\n    - `DL_1.totalSize` $\\leftarrow$ `V_2.size` + `DL_2.totalSize` $\\implies$ {`V_2.size`, `DL_2.totalSize`} $\\to$ `DL_1.totalSize`。\n    - `DL_0.totalSize` $\\leftarrow$ `V_1.size` + `DL_1.totalSize` $\\implies$ {`V_1.size`, `DL_1.totalSize`} $\\to$ `DL_0.totalSize`。\n    - `F.size` $\\leftarrow$ `h` + `DL_0.totalSize` $\\implies$ `DL_0.totalSize` $\\to$ `F.size`。\n\n2.  **前缀属性（继承属性）**：这些依赖关系通常沿着语法分析树向下流动，并在兄弟节点之间从左到右流动。\n    - `DL_0.prefix` $\\leftarrow$ `0`。\n    - `V_1.prefix` $\\leftarrow$ `DL_0.prefix` $\\implies$ `DL_0.prefix` $\\to$ `V_1.prefix`。\n    - `DL_1.prefix` $\\leftarrow$ `DL_0.prefix` + `V_1.size` $\\implies$ {`DL_0.prefix`, `V_1.size`} $\\to$ `DL_1.prefix`。\n    - `V_2.prefix` $\\leftarrow$ `DL_1.prefix` $\\implies$ `DL_1.prefix` $\\to$ `V_2.prefix`。\n    - `DL_2.prefix` $\\leftarrow$ `DL_1.prefix` + `V_2.size` $\\implies$ {`DL_1.prefix`, `V_2.size`} $\\to$ `DL_2.prefix`。\n\n3.  **偏移量属性（综合属性）**：这些是本问题的关键属性。\n    - `V_1.offset` $\\leftarrow$ `F.size` - (h + `V_1.prefix` + `V_1.size`) $\\implies$ {`F.size`, `V_1.prefix`, `V_1.size`} $\\to$ `V_1.offset`。\n    - `V_2.offset` $\\leftarrow$ `F.size` - (h + `V_2.prefix` + `V_2.size`) $\\implies$ {`F.size`, `V_2.prefix`, `V_2.size`} $\\to$ `V_2.offset`。\n\n关键的依赖关系是 `V_1.offset` 和 `V_2.offset` 的计算都需要 `F.size` 的值。让我们追踪计算 `F.size` 所需的依赖关系：\n计算 `F.size` 的依赖链纯粹是综合的，并沿着树向上移动：\n(`T_1.size` $\\to$ `V_1.size`) and (`T_2.size` $\\to$ `V_2.size`) $\\to$ (`V_2.size`, `DL_2.totalSize` $\\to$ `DL_1.totalSize`) $\\to$ (`V_1.size`, `DL_1.totalSize` $\\to$ `DL_0.totalSize`) $\\to$ (`DL_0.totalSize` $\\to$ `F.size`)。\n这意味着要计算 `F.size`，必须聚合来自整个声明列表（$DL_0$）的信息。\n\n`F.size` 到 `V.offset` 的依赖关系是从一个祖先节点（$F$）的属性到一个后代节点（$V_1$ 或 $V_2$）的综合属性。这使得在单次深度优先遍历中求值所有属性变得不可能，因为一次简单的遍历无法同时向上收集信息到根节点（以计算 `F.size`），然后在同一次遍历中使用该根节点级别的信息来计算叶子节点中的属性（`V.offset`）。ADG 是无环的，因此存在求值顺序，但它不是一个简单的顺序。\n\n任何有效的求值方案都必须在计算 `V_1.offset` 和 `V_2.offset` 之前计算 `F.size`。\n\n### 3. 选项评估\n\n让我们根据推导出的依赖关系来评估每个选项。\n\n**A. 在对语法分析树进行单次从左到右的前序遍历中求值属性，在每个 `V.size` 已知后立即计算其 `V.offset`；最后更新 `F.size`。**\n在前序遍历中，我们在访问其子节点之前访问父节点。我们将访问 $F$，然后是 $DL_0$，然后是 $V_1$。在 $V_1$ 处，其子节点被处理，从而可以计算 `T_1.size` 和 `V_1.size`。然后该选项建议计算 `V_1.offset`。`V_1.offset` 的公式需要 `F.size`。然而，在遍历的这个时刻，我们还没有访问 $V_2$，因此 `DL_1.totalSize` 以及随后的 `DL_0.totalSize` 和 `F.size` 都无法被计算出来。该选项本身就说明 `F.size` 是“在最后”更新的。这直接违反了 ADG 中的依赖边 (`F.size` $\\to$ `V_1.offset`)。\n**结论：不正确。**\n\n**B. 根据语义方程构建 ADG，并对 ADG 进行全局拓扑排序；按排序后的顺序求值属性。**\n对于任何良构的属性文法（即产生无环 ADG 的文法），这是最通用且理论上最可靠的属性求值方法。有向无环图（DAG）的拓扑排序会产生其节点的线性排序，使得对于每条从节点 $u$ 到节点 $v$ 的有向边，$u$ 都在排序中位于 $v$ 之前。由于我们的 ADG 是无环的，并且包含边 (`F.size` $\\to$ `V_1.offset`) 和 (`F.size` $\\to$ `V_2.offset`)，任何拓扑排序都必然会将 `F.size` 的计算置于 `V_1.offset` 和 `V_2.offset` 的计算之前。根据定义，此方法遵守所有依赖关系。\n**结论：正确。**\n\n**C. 对树进行两次遍历：在第一次遍历中，计算所有的 `T.size`、`V.size`、`DL.totalSize` 和 `F.size`；在第二次遍历中，使用先前计算出的 `F.size` 和已经确定的 `V.prefix` 值来计算所有的 `V.offset`。**\n该选项描述了一种多遍求值策略，这对于非 L-属性的 AG 是一种常见的实用方法。\n- **第一遍：**计算所有与大小相关的属性。这些都是综合属性。它们的依赖关系沿着语法分析树向上流动。这一遍可以实现为一次后序遍历（一次自下而上的遍历）。在这次遍历结束时，根节点处的 `F.size` 的值将是已知的。\n- **第二遍：**计算所有的 `V.offset` 属性。`V.offset` 的规则需要 `F.size`、`V.size` 和 `V.prefix`。`F.size` 和所有的 `V.size` 值可从第一遍中获得。`V.prefix` 属性也可以在这一遍中计算（或在一个单独的预备遍历中），因为它们依赖于其他前缀和大小，而这些都是已知的。例如，第二遍可以是一次前序遍历，在向下遍历的过程中计算前缀，然后计算偏移量。\n该方案的关键在于 `F.size` 在第一遍中被完全计算出来，此时计算 `V.offset` 值的第二遍甚至还未开始。这明确地确保了依赖关系 (`F.size` $\\to$ `V.offset`) 得到满足。\n**结论：正确。**\n\n**D. 重新定义 `V.offset` 为 `V.offset` $\\leftarrow$ `h` + `V.prefix` 以打破其对 `F.size` 的依赖；然后在单次遍历中，在计算 `F.size` 之前计算所有的 `V.offset`。**\n该选项建议修改属性文法的语义规则。问题要求的是一个适用于 *给定* 语义的求值方案（“在遵守所述语义的前提下”）。提议的新规则 `V.offset` $\\leftarrow$ `h` + `V.prefix` 定义的是从变量区域顶部开始的偏移量，而不是像规定中那样从帧底部开始。这一改变会产生不同的偏移数值，因此没有计算问题所定义的属性。例如，使用之前计算的值（$h=16$, `V_1.prefix`=0），新规则得出 `V_1.offset` = 16+0 = 16，而原始规则得出 `V_1.offset` = 8。由于该选项不遵守所述语义，因此它不是所提问题的有效解决方案。\n**结论：不正确。**", "answer": "$$\\boxed{BC}$$", "id": "3622373"}]}