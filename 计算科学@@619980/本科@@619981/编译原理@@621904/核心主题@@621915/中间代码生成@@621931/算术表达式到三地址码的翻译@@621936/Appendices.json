{"hands_on_practices": [{"introduction": "编译器优化的一个诱人前景是利用代数定律来简化表达式，从而生成更快的代码。然而，这种优化必须小心进行，以确保其在任何情况下都保持原始代码的语义。本练习 [@problem_id:3676892] 探讨了代数简化（如平方差公式）的应用，并强调了在优化过程中保留关键运行时检查（例如除零检查）的重要性，揭示了效率和正确性之间的根本权衡。", "problem": "一种编译器中间表示使用三地址码 (TAC)，其中每条指令最多有一个操作符和最多三个操作数，并引入临时变量将复杂表达式分解为单操作步骤。考虑源级算术赋值语句 $$y := \\frac{a^{2} - b^{2}}{a - b},$$ 其中 $a$、$b$ 和 $y$ 是实数范围内的变量，且当分母为零时，除法运算符未定义。\n\n你的任务是：\n- 将该赋值语句翻译成一系列计算 $y$ 值的 TAC 指令，不进行任何代数化简。\n- 然后，仅使用在实数上有效的代数定律和语义保持转换，推导出一个优化的 TAC 序列，以减少操作次数，前提是该优化能防止运行时的除零错误。\n- 最后，在 $a - b \\neq 0$ 的明确前提下，说明优化后的 TAC 计算出的 $y$ 的简化封闭形式解析表达式。\n\n只需提供 $y$ 的最终简化表达式。不需要进行数值计算。", "solution": "此问题需要进行验证。\n\n**步骤 1：提取已知信息**\n- 源级算术赋值语句为 $$y := \\frac{a^{2} - b^{2}}{a - b}$$。\n- 变量 $a$、$b$ 和 $y$ 定义为实数范围内的变量。\n- 给定一个约束：当分母为零时，除法运算符未定义。\n- 任务 1：将该赋值语句翻译成一系列三地址码 (TAC) 指令，不进行任何代数化简。\n- 任务 2：使用代数定律和语义保持转换推导出一个优化的 TAC 序列，该序列必须包含对运行时除零错误的防范。\n- 任务 3：在 $a - b \\neq 0$ 的明确前提下，说明 $y$ 的简化封闭形式解析表达式。\n\n**步骤 2：使用提取的已知信息进行验证**\n该问题在科学上和数学上是合理的。这是一个来自计算机科学领域，特别是编译器设计和优化领域的适定问题。所涉及的代数原理（平方差）是代数的基本定理。该问题区分了一般情况（必须处理除零错误）和特殊情况（前提条件 $a - b \\neq 0$ 使分母不为零），这是一个关键且明确的区分。任务明确，问题包含了继续进行所需的所有信息。该问题不违反任何无效性标准。\n\n**步骤 3：结论与行动**\n此问题有效。将提供一个完整的解决方案。\n\n**解题过程**\n\n该问题需要对赋值语句 $y := \\frac{a^{2} - b^{2}}{a - b}$ 进行三部分分析。\n\n**第 1 部分：未优化的三地址码 (TAC) 翻译**\n\n将表达式直接翻译成三地址码，需要将计算分解为一系列指令，每条指令最多有一个操作符。我们引入临时变量（例如 $t_1, t_2, \\dots$）来保存中间结果。运算顺序遵循标准的数学优先级：先求幂，然后减法，最后是除法。\n\n1.  计算 $a^2$：令 $t_1 = a \\times a$。\n2.  计算 $b^2$：令 $t_2 = b \\times b$。\n3.  计算分子 $a^2 - b^2$：令 $t_3 = t_1 - t_2$。\n4.  计算分母 $a - b$：令 $t_4 = a - b$。\n5.  执行除法：令 $t_5 = t_3 / t_4$。\n6.  将结果赋给 $y$：令 $y = t_5$。\n\n得到的 TAC 序列是：\n`t_1 := a * a`\n`t_2 := b * b`\n`t_3 := t_1 - t_2`\n`t_4 := a - b`\n`t_5 := t_3 / t_4`\n`y := t_5`\n\n这个序列总共包含 $5$ 次算术运算：两次乘法，两次减法和一次除法。\n\n**第 2 部分：优化的三地址码 (TAC) 翻译**\n\n优化依赖于平方差的代数恒等式：$a^2 - b^2 = (a - b)(a + b)$。将此代入原始表达式得到：\n$$y = \\frac{(a - b)(a + b)}{a - b}$$\n在代数上，可以从分子和分母中消去 $(a - b)$ 项，从而将表达式简化为 $y = a + b$。然而，这种消去仅在 $a - b \\neq 0$ 时有效。如果 $a - b = 0$，原始表达式是未定义的（因为除以零），而简化后的表达式 $y = a + b = 2a$ 会产生一个值。\n\n因此，语义保持转换必须保留原始表达式在定义域上的行为。优化后的代码必须仍然防范除零条件。优化的关键在于重构计算，使其在 $a - b \\neq 0$ 的常见情况下更高效。我们首先检查条件 $a - b = 0$，而不是计算完整的分子和分母。\n\n优化的逻辑如下：\n1.  计算分母的值 $a-b$。\n2.  检查该值是否为零。\n3.  如果为零，则发生运行时错误（除零错误）。\n4.  如果不为零，则使用简化表达式 $a+b$ 计算结果。\n\n包含显式防卫的优化 TAC 序列，可以使用条件跳转来编写：\n1.  计算分母：令 $t_1 = a - b$。\n2.  检查除零：`if t_1 == 0 goto L_error`。\n3.  如果检查通过，计算简化结果：令 $t_2 = a + b$。\n4.  将结果赋给 $y$：令 $y = t_2$。\n5.  跳过错误处理：`goto L_end`。\n6.  `L_error:`（处理除零异常的代码）。\n7.  `L_end:`（此代码段结束）。\n\n有效计算路径的 TAC 是：\n`t_1 := a - b`\n`if t_1 == 0 goto L_error`\n`t_2 := a + b`\n`y := t_2`\n\n在 $a \\neq b$ 的情况下，此序列仅需要 $2$ 次算术运算（一次减法，一次加法），与未优化版本中的 $5$ 次运算相比，这是一个显著的减少。该优化通过在执行无效的代数消去*之前*检查可能导致除零的条件，正确地保留了语义。\n\n**第 3 部分：带前提条件的简化解析表达式**\n\n问题的最后一部分要求在 $a - b \\neq 0$ 的明确前提下，给出 $y$ 的简化封闭形式解析表达式。\n\n给定表达式：\n$$y := \\frac{a^{2} - b^{2}}{a - b}$$\n我们使用平方差恒等式 $a^2 - b^2 = (a - b)(a + b)$：\n$$y = \\frac{(a - b)(a + b)}{a - b}$$\n前提条件 $a - b \\neq 0$ 明确指出分母不为零。这使得除法运算是良定义的，并允许从分子和分母中消去 $(a - b)$ 项。\n$$y = a + b$$\n这就是优化后的 TAC 在非错误路径上计算出的最终简化表达式。", "answer": "$$\n\\boxed{a + b}\n$$", "id": "3676892"}, {"introduction": "在将复杂表达式翻译成三地址代码时，一个核心的优化目标是最小化所需临时变量的数量，因为这直接关系到处理器寄存器的有效利用。本练习 [@problem_id:3676922] 将指导你系统地分析一个复合算术表达式的结构，以确定最佳的求值顺序。通过这种方式，你可以学习到如何应用基于表达式树的算法来生成不仅正确而且高效的代码，这是编译器后端设计中的一项基本技能。", "problem": "给定算术表达式 $a + b * c - d / (e + f)$，请为一种机器模型生成三地址码（TAC, three-address code）。在该模型中，每条 TAC 指令的形式为 $x := y \\ \\text{op} \\ z$，其中 $x$、$y$ 和 $z$ 表示变量或临时变量，$\\text{op}$ 表示从 $\\{+, -, *, /\\}$ 中选择的二元运算符。假设存在以下上下文和约束：\n- 所有变量 $a$、$b$、$c$、$d$、$e$ 和 $f$ 表示在一个无副作用的环境中的值；读取这些变量中的任何一个都不会改变程序状态。\n- 运算符 $*$ 和 $/$ 的优先级高于 $+$ 和 $-$，并且括号强制在执行除以 $d$ 的操作之前对 $(e + f)$ 进行分组。\n- 必须精确保留原始表达式的语义；仅当重排序不改变由原始优先级和分组决定的数学值时才被允许。你可以选择独立子表达式的任意求值顺序，并可以在临时变量的先前值不再需要时重用它们。\n- 临时变量是指除 $\\{a,b,c,d,e,f\\}$ 之外，为存储中间结果而引入的任何符号。不同的临时变量按名称计数；对临时变量的重新赋值算作重用，而不是引入新的临时变量。\n\n任务：\n1. 从上述形式化定义出发，推导出一个正确的 TAC 序列，该序列计算 $a + b * c - d / (e + f)$ 的值并存入目标变量 $g$，同时保留给定的优先级和分组。\n2. 重排子表达式的求值顺序，并设计 TAC 以最小化引入的不同临时变量的数量，同时保持语义不变。证明你的重排序和重用策略在约束下是有效的。\n3. 确定计算 $g$ 所需的最少不同临时变量数量，且不改变语义。为你声称的任何下界提供严格的推理，并证明你的 TAC 达到了这个下界。\n\n你最终提交的答案必须是所需的最少不同临时变量的数量，表示为单个整数值。无需四舍五入。", "solution": "所述问题是有效的。它提出了一个来自编译原理领域的明确定义的任务，具体涉及代码生成与优化。表达式 $a + b * c - d / (e + f)$ 是无歧义的，三地址码生成的约束是标准的，而最小化临时变量的目标是一个经典的优化问题。该问题是自洽的，科学上基于计算机科学原理，并且没有任何事实或逻辑上的不一致。\n\n任务是确定计算表达式 $a + b * c - d / (e + f)$ 的值并将其赋给变量 $g$ 所需的最少不同临时变量的数量。\n\n首先，我们将表达式表示为一个抽象语法树（AST），以可视化依赖关系和运算顺序，同时遵循运算符优先级（$*$ 和 $/$ 高于 $+$ 和 $-$）和括号。该表达式等价于 $(a + (b * c)) - (d / (e + f))$。AST 如下：根节点是最后的 $-$ 运算。其左子节点是 $a + (b * c)$ 的子树，右子节点是 $d / (e + f)$ 的子树。\n\n- 根节点是 `$-$`。\n  - 根节点的左子节点是一个 `$+` 节点。\n    - 这个 `$+` 节点的左子节点是叶节点 `$a$`。\n    - 这个 `$+` 节点的右子节点是一个 `*` 节点，其子节点为叶节点 `$b$` 和 `$c$`。\n  - 根节点的右子节点是一个 `$/` 节点。\n    - `$/` 节点的左子节点是叶节点 `$d$`。\n    - `$/` 节点的右子节点是一个 `$+` 节点，其子节点为叶节点 `$e$` 和 `$f$`。\n\n为了找到所需的最少临时变量数量，我们可以应用 Sethi-Ullman 算法的原理。该算法为 AST 中的每个节点 `$n$` 分配一个数字，我们称之为 `$N(n)$`，表示计算以 `$n$` 为根的子树所需的最少临时变量（或寄存器）数量。\n\n计算 `$N(n)$` 的规则如下：\n1.  如果 `$n$` 是一个叶节点（变量或常量），则 `$N(n) = 0$`，因为它的值可以直接从内存中访问，其自身的计算不需要中间临时变量。\n2.  如果 `$n$` 是一个带有一个运算符 `op` 以及子节点 `$n_L$` 和 `$n_R$` 的内部节点，那么：\n    - 设 `$N_L = N(n_L)$` 和 `$N_R = N(n_R)$`。\n    - 如果 `$N_L \\neq N_R$`，我们应该首先计算更复杂的子树（需要更多临时变量的那个）。我们计算它的值，将其存储在一组临时变量中的一个，然后计算更简单的子树。所需的临时变量数量是 `$\\max(N_L, N_R)$`。\n    - 如果 `$N_L = N_R$`，我们必须计算一个子树（例如 `$n_R$`），将其结果存储在一个新的临时变量中，然后计算另一个子树 `$n_L$`。在计算 `$n_L$` 时，它需要 `$N_L$` 个临时变量，并且 `$n_R$` 的结果必须保持存储。因此，所需的临时变量总数为 `$N_L + 1$`。\n    - 所以，总结如下：`$N(n) = \\begin{cases} \\max(N_L, N_R)  & \\text{if } N_L \\neq N_R \\\\ N_L + 1  & \\text{if } N_L = N_R \\end{cases}$`\n\n让我们自底向上地将此方法应用于我们的 AST：\n\n- **叶节点**：对于叶节点 `$a, b, c, d, e, f$`，我们有 `$N(a)=N(b)=N(c)=N(d)=N(e)=N(f)=0$`。\n\n- **节点 `*`**：该节点有子节点 `$b$` 和 `$c$`。我们有 `$N(b) = 0$` 和 `$N(c) = 0$`。由于 `$N(b) = N(c)$`，所需临时变量的数量是 `$N(*) = N(b) + 1 = 0 + 1 = 1$`。这对应于一条类似 `t_1 := b * c` 的指令。\n\n- **节点 `+` (用于 `e + f`)**：该节点有子节点 `$e$` 和 `$f$`。我们有 `$N(e) = 0$` 和 `$N(f) = 0$`。由于 `$N(e) = N(f)$`，所需临时变量的数量是 `$N(+) = N(e) + 1 = 0 + 1 = 1$`。这对应于一条类似 `t_1 := e + f` 的指令。\n\n- **节点 `+` (用于 `a + ...`)**：这是根节点的左子节点。它的子节点是叶节点 `$a$` 和 `*` 节点。我们称 `*` 节点为 `$n_{b*c}`。我们有 `$N(a) = 0$` 和 `$N(n_{b*c}) = 1$`。由于它们不相等，所需临时变量的数量是 `$N(+) = \\max(N(a), N(n_{b*c})) = \\max(0, 1) = 1$`。为了实现这一点，我们必须首先计算更复杂的子树 (`$n_{b*c}$):\n    1. `t_1 := b * c`\n    2. `t_1 := a + t_1` （临时变量被重用）\n所以，子树 `$a + (b * c)$` 可以用一个临时变量来计算。\n\n- **节点 `/`**：这是根节点的右子节点。它的子节点是叶节点 `$d$` 和用于 `$e+f$` 的 `+` 节点。我们称 `+` 节点为 `$n_{e+f}`。我们有 `$N(d) = 0$` 和 `$N(n_{e+f}) = 1$`。由于它们不相等，所需临时变量的数量是 `$N(/) = \\max(N(d), N(n_{e+f})) = \\max(0, 1) = 1$`。为了实现这一点，我们首先计算更复杂的子树 (`$n_{e+f}`):\n    1. `t_1 := e + f`\n    2. `t_1 := d / t_1` （临时变量被重用）\n所以，子树 `$d / (e + f)$` 也可以用一个临时变量来计算。\n\n- **根节点 `-`**：该节点有两个子节点，我们称它们为 `$n_L$`（代表 `$a + (b*c)$`）和 `$n_R$`（代表 `$d / (e+f)$`）。根据我们上面的分析，`$N(n_L) = 1$` 和 `$N(n_R) = 1$`。由于 `$N(n_L) = N(n_R) = 1$`，根节点所需的临时变量数量是 `$N(-) = N(n_L) + 1 = 1 + 1 = 2$`。\n\n这个 `$2$` 的结果构成了所需不同临时变量数量的一个严格下界。其推理是，为了计算最后的减法，我们必须计算其两个操作数 `$a + (b*c)$` 和 `$d / (e+f)$` 的值。由于两个子表达式都是非平凡的（即，它们不是简单的叶节点），它们的计算需要中间结果。根据源自 Sethi-Ullman 算法的逻辑，因为两个主子树在临时变量需求方面的复杂度相等（每个都需要 `$1$` 个临时变量），我们被迫进入这样一种情况：必须计算一个子树的结果，将其存储在一个临时变量中，然后继续计算第二个子树。第二个子树的计算本身将至少需要一个临时变量。在此期间，第一个子树的结果必须保持有效。因此，在计算过程中的某个时刻，必须有两个临时变量同时处于活动状态。\n\n我们可以构造一个三地址码序列，以实现 `$2$` 个临时变量的这个下界。设临时变量为 `$t_1$` 和 `$t_2$`。策略是计算其中一个主子树，存储其结果，然后使用另一个临时变量计算另一个主子树，最后合并结果。\n\n1.  `t_1 := e + f`\n    （计算右子树最内部的部分。`t_1` 保存 `e+f`。）\n2.  `t_1 := d / t_1`\n    （`e+f` 的值不再需要。`t_1` 被重用于保存整个右子树的结果 `d/(e+f)`。）\n3.  `t_2 := b * c`\n    （现在我们开始计算左子树。`t_1` 中的结果必须被保留，所以我们必须使用一个新的临时变量 `t_2`。此时，有两个临时变量处于活动状态：`t_1` 保存 `d/(e+f)`，`t_2` 保存 `b*c`。）\n4.  `t_2 := a + t_2`\n    （临时变量 `t_2` 被重用于保存整个左子树的结果 `a+(b*c)`。）\n5.  `t_2 := t_2 - t_1`\n    （通过从 `t_2` 中的值减去 `t_1` 中的值来计算最终结果。结果可以存回 `t_2` 或 `t_1`。我们使用 `t_2`。现在 `t_1` 空闲了。）\n6.  `g := t_2`\n    （最终结果被赋给目标变量 `g`。）\n\n这个序列最多使用两个不同的临时变量 `t_1` 和 `t_2`，它们在步骤 `$3$` 和 `$4$` 中被同时需要。这证明了 `$2$` 的下界是可以达到的。因此，所需的最少不同临时变量数量是 `$2$`。", "answer": "$$\\boxed{2}$$", "id": "3676922"}, {"introduction": "理论上的代码生成必须与目标机器和编程语言的具体现实相结合。编译器不能仅仅处理抽象的数学运算，还必须应对硬件限制和语言定义的语义。本练习 [@problem_id:3676915] 将抽象的三地址代码生成过程置于一个更实际的场景中，要求你处理整数除法的特定规则（向零截断）并显式地插入运行时错误检查，这体现了编译器在生成健壮和可靠的机器代码时所面临的实际挑战。", "problem": "一种静态类型的命令式语言使用三地址码 (TAC) 作为其中间表示，其中每条指令最多计算一个运算符并引用最多三个地址。在该语言中，变量 $x$、$y$ 和 $p$ 都是 $32$ 位有符号整数，整数上的除法运算符向零截断，而除以零会发出运行时错误信号。考虑源级别的赋值语句 $p = (x - y)/(x + y)$。\n\n从以下原则出发：(i) 算术表达式可以表示为抽象语法树，其内部节点是运算符，叶节点是操作数；(ii) TAC 在其父节点使用一个值之前，会将每个内部节点求值到一个临时变量中。请推导出一个 TAC 序列，该序列为分子使用一个临时变量，为分母使用一个临时变量，在除法之前执行显式的运行时零除检查，然后将商赋给 $p$。假设右侧表达式从左到右求值，并且在求值 $x$ 和 $y$ 时没有副作用。\n\n讨论由向零截断和除以零引起的整数除法边界情况，并比较如果整数除法定义为对实商应用向下取整函数（floor function），结果会有何不同。然后，给定具体输入值 $x = 3$ 和 $y = 7$，计算在给定的向零截断语义下将存储在 $p$ 中的结果值。只报告 $p$ 的最终数值作为你的答案。", "solution": "该问题陈述是编译器原理中的一个有效练习，具体涉及将算术表达式翻译为三地址码 (TAC)、处理整数算术语义以及运行时错误检查。其前提在计算机科学中有科学依据，问题本身定义明确、客观且自成体系。所有变量、条件和要求的输出都已明确定义。\n\n该问题要求推导赋值语句 `$p = (x - y)/(x + y)$` 的 TAC 序列，讨论整数除法的边界情况，并对 `$x$` 和 `$y$` 的特定值进行最终计算。\n\n首先，我们解决到三地址码的翻译问题。这个过程始于问题陈述中列出的原则。\n\n(i) 算术表达式可以表示为抽象语法树 (AST)。对于赋值语句的右侧 `$(x - y)/(x + y)$`，其 AST 的根节点是除法运算符 `$/$`。左子节点是表示分子 `$(x - y)$` 的子树，右子节点是表示分母 `$(x + y)$` 的子树。该 AST 可以用文本表示为 `div(sub(x, y), add(x, y))`。\n\n(ii) TAC 将每个内部节点求值到一个临时变量中。通常使用对表达式 AST 的后序遍历来生成代码。问题指定了右侧表达式的求值顺序为从左到右，这意味着对于运算符 `$/$`，其左操作数 `$(x-y)$` 在其右操作数 `$(x+y)$` 之前求值。这对应于在访问 `$/$` 节点的右子树之前访问其左子树。\n\n遵循这些原则和问题的约束，我们推导出 TAC 序列。\n1.  计算分子 `$(x - y)$` 并将其存储在临时变量 `$t_1$` 中。这对应于 `sub(x, y)` 节点。\n    `t_1 = x - y`\n2.  计算分母 `$(x + y)$` 并将其存储在第二个临时变量 `$t_2$` 中。这对应于 `add(x, y)` 节点。\n    `t_2 = x + y`\n3.  执行显式的运行时零除检查。分母现在位于 `$t_2$` 中。如果 `$t_2$` 等于 `$0$`，则必须将控制权转移到错误处理例程。我们使用一个条件跳转到一个标签，例如 `L_error`。\n    `if t_2 == 0 goto L_error`\n4.  如果检查通过（即 `$t_2 \\neq 0$`），则执行除法。严格的三地址码指令最多包含一个运算符。因此，我们计算商并将其存储在一个新的临时变量 `$t_3$` 中。\n    `t_3 = t_1 / t_2`\n5.  最后，将结果赋给变量 `$p$`。这是一条复制指令。\n    `p = t_3`\n6.  为确保正确的控制流，添加一个无条件跳转以绕过错误处理代码。\n    `goto L_end`\n\n完整的 TAC 序列，包括用于控制流的标签，如下所示：\n`t_1 = x - y`\n`t_2 = x + y`\n`if t_2 == 0 goto L_error`\n`t_3 = t_1 / t_2`\n`p = t_3`\n`goto L_end`\n`L_error: signal_error()`\n`L_end:`\n该序列遵守所有指定的约束：它为分子使用一个临时变量（`t_1`），为分母使用一个临时变量（`t_2`），在除法前执行显式检查，并正确赋最终结果。\n\n接下来，我们讨论整数除法的边界情况。\n第一个边界情况是**除以零**。当分母 `$(x + y)$` 为 `$0$` 时，即 `$y = -x$` 时，会发生这种情况。提供的 TAC 使用 `if t_2 == 0 goto L_error` 明确检查了此条件。这可以防止硬件执行非法操作，而是将控制权转移到发出运行时错误的例程，正如语言规范所要求的那样。\n\n第二个边界情况涉及负数结果的整数除法语义。问题指定除法**向零截断**。设 `$a$` 和 `$b$` 是两个整数，且 `$b \\neq 0$`。实商为 `$q_{real} = a/b$`。向零截断意味着整数除法的结果是 `$\\text{trunc}(q_{real})$`，这是通过丢弃 `$q_{real}$` 的小数部分得到的。\n- 如果 `$q_{real} \\ge 0$`，则 `$\\text{trunc}(q_{real}) = \\lfloor q_{real} \\rfloor$`。例如，`$7/2 = 3.5 \\implies 3$`。\n- 如果 `$q_{real}  0$`，则 `$\\text{trunc}(q_{real}) = \\lceil q_{real} \\rceil$`。例如，`$-7/2 = -3.5 \\implies -3$`。\n这种行为在 C、C++ 和 Java 等语言中是标准的。\n\n问题要求与定义为对实商应用**向下取整函数 (floor function)** 的整数除法进行比较，即 `$\\lfloor q_{real} \\rfloor$`。\n- 如果 `$q_{real} \\ge 0$`，向下取整函数与截断得到相同的结果。\n- 如果 `$q_{real}  0$` 且 `$q_{real}$` 不是整数，向下取整函数会得到不同的结果。`$\\lfloor q_{real} \\rfloor$` 向下舍入到最接近的整数（更负），而截断则向零舍入（更不负）。例如，对于实商 `$-3.5$`，向下取整除法得到 `$-4$`，而截断得到 `$-3$`。向下取整除法是 Python 中的标准。关键区别仅在负非整数商的情况下出现。\n\n最后，我们计算特定输入 `$x = 3$` 和 `$y = 7$` 时 `$p$` 的值。这些变量是 `$32$` 位有符号整数。\n表达式为 `$p = (x - y)/(x + y)$`。\n1.  计算分子：`$x - y = 3 - 7 = -4$`。\n2.  计算分母：`$x + y = 3 + 7 = 10$`。\n3.  需要执行的除法是 `$(-4) / 10$`。\n4.  实商为 `$-0.4$`。\n5.  根据语言指定的语义，整数除法向零截断。\n    `$\\text{trunc}(-0.4) = 0$`。\n    因此，赋给 `$p$` 的值是 `$0$`。\n如果语言使用向下取整除法，结果将是 `$\\lfloor -0.4 \\rfloor = -1$`，这说明了语义上的差异。\n在指定规则下，存储在 `$p$` 中的最终值为 `$0$`。", "answer": "$$\n\\boxed{0}\n$$", "id": "3676915"}]}