{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。本节提供了一系列动手练习，旨在帮助你将回填（backpatching）的抽象概念应用于具体问题。这些练习将引导你从掌握回填的基本机制，到处理更复杂的控制结构，最终学会如何批判性地思考整个过程，从而真正内化这些编译原理的核心技能。\n\n第一个练习是回填技术的一次直接演练。我们将从一段预先生成、包含占位符的中间代码流开始。你的任务就像编译器的回填模块一样，为 `if-then-else` 和 `while` 语句确定正确的跳转目标地址，这其中也包括了如何处理逻辑运算符的短路求值（short-circuit evaluation）。通过这个练习，你将巩固对 `truelist` 和 `falselist` 如何被用来连接控制流的理解。[@problem_id:3623495]", "problem": "考虑一个编译器前端，它为结构化控制流构造生成一种三地址中间表示（IR），其形式为四元式。四元式从 $1$ 开始索引，并使用条件分支和无条件分支，其占位符目标由符号 $?$ 表示，必须通过回填来解析。该 IR 遵循以下被广泛接受的基础原则：\n\n- 逻辑合取 ($\\land$) 和逻辑析取 ($\\lor$) 的短路语义：对于 $E_{1} \\land E_{2}$，如果 $E_{1}$ 为假，则整个表达式为假；否则计算 $E_{2}$ 的值。对于 $E_{1} \\lor E_{2}$，如果 $E_{1}$ 为真，则整个表达式为真；否则计算 $E_{2}$ 的值。\n- 回填：布尔表达式被编译以产生对应于真和假结果的未解析跳转列表，一旦这些目标（then部分、else部分、循环体或出口）的入口点已知，这些跳转就会被修补（回填）到相应的入口点。\n- 结构化控制流：对于一个 $\\text{if}$–$\\text{then}$–$\\text{else}$ 语句，条件的真出口指向then块，假出口指向else块；then块以一个跳转到条件语句之后的汇合点的指令结束。对于一个 $\\text{while}$ 循环，条件在循环头处重新求值；真出口指向循环体，假出口指向循环后的出口点；循环体以一个跳回到循环头的指令结束。\n\n以下 IR 四元式流对必须回填的未解析分支目标使用了占位符 $?$。它编码的程序结构是一个 $\\text{if}$–$\\text{then}$–$\\text{else}$ 语句，后跟一个赋值语句，然后是一个带有短路条件的 $\\text{while}$ 循环：\n\n- $1$: if $a > b$ goto $?$\n- $2$: goto $?$\n- $3$: if $c \\neq d$ goto $?$\n- $4$: goto $?$\n- $5$: $x := x + 1$\n- $6$: goto $?$\n- $7$: $x := x - 1$\n- $8$: $y := 0$\n- $9$: if $p \\le q$ goto $?$\n- $10$: goto $?$\n- $11$: if $r > s$ goto $?$\n- $12$: goto $?$\n- $13$: $y := y + 2$\n- $14$: goto $?$\n- $15$: $\\text{noop}$\n\n任务：\n\n1. 仅使用上述基础原则，确定每个占位符 $?$ 的最终回填目标，以使该 IR 正确实现：\n   - 一个 $\\text{if}$ 条件 $(a > b) \\land (c \\neq d)$，其then块在四元式 $5$ 处，else块在四元式 $7$ 处，条件语句后的汇合点在四元式 $8$ 处。\n   - 一个 $\\text{while}$ 循环，其条件为 $(p \\le q) \\lor (r > s)$，循环体始于四元式 $13$，循环头位于四元式 $9$，出口点位于四元式 $15$。\n2. 列出被回填的四元式索引集合。\n3. 令校验和 $\\Sigma$ 定义为\n$$\n\\Sigma \\;=\\; \\sum_{i \\in P} i \\times t_{i},\n$$\n其中 $P$ 是被回填的四元式索引集合，$t_{i}$ 是四元式 $i$ 的最终回填目标索引。以整数形式精确计算 $\\Sigma$。无需四舍五入。仅报告 $\\Sigma$ 的值作为你的最终答案。\n\n你的回答必须包含回填后完整的四元式数组和对被回填索引的清晰列举，但最终答案必须是上面指定的单个数字。", "solution": "我们从所述的基础原则开始：逻辑合取和析取的短路求值，以及 $\\text{if}$–$\\text{then}$–$\\text{else}$ 和 $\\text{while}$ 构造的结构规则，并使用回填来解析条件和无条件跳转目标，一旦相应的块入口或出口点已知。\n\n首先，我们分析 $\\text{if}$–$\\text{then}$–$\\text{else}$ 部分。条件是 $(a > b) \\land (c \\neq d)$，then块位于四元式 $5$，else块位于四元式 $7$，条件语句后的汇合点位于四元式 $8$。\n\n- 对于短路语义下的逻辑合取 $E_{1} \\land E_{2}$：\n  - 如果 $E_{1}$ 为假，整个条件为假，控制转移到else块。\n  - 如果 $E_{1}$ 为真，则继续对 $E_{2}$ 求值。\n  - 如果 $E_{2}$ 为真，整个条件为真，控制转移到then块。\n  - 如果 $E_{2}$ 为假，控制转移到else块。\n\n将此应用于四元式：\n\n- 四元式 $1$ 是对 $E_{1}$ 的测试：if $a > b$ goto $?$.\n  - 四元式 $1$ 的真分支应跳转到四元式 $3$ 处对 $E_{2}$ 求值，因此我们将四元式 $1$ 的目标回填为 $3$。\n- 四元式 $2$ 是测试 $E_{1}$ 后的假分支：goto $?$.\n  - 假结果应跳转到四元式 $7$ 处的else块，因此我们将四元式 $2$ 的目标回填为 $7$。\n- 四元式 $3$ 是对 $E_{2}$ 的测试：if $c \\neq d$ goto $?$.\n  - 真分支应跳转到四元式 $5$ 处的then块，因此我们将四元式 $3$ 的目标回填为 $5$。\n- 四元式 $4$ 是测试 $E_{2}$ 后的假分支：goto $?$.\n  - 假结果应跳转到四元式 $7$ 处的else块，因此我们将四元式 $4$ 的目标回填为 $7$。\n- 四元式 $5$ 是then块体：$x := x + 1$。\n- 四元式 $6$ 是跳转到汇合点的指令：goto $?$.\n  - 执行完then块后，我们必须跳过else块，跳转到四元式 $8$ 处的汇合点，因此我们将四元式 $6$ 的目标回填为 $8$。\n- 四元式 $7$ 是else块体：$x := x - 1$。\n- 四元式 $8$ 是条件语句后的汇合点：$y := 0$。\n\n接下来，我们分析条件为 $(p \\le q) \\lor (r > s)$ 的 $\\text{while}$ 循环，其循环体始于四元式 $13$，循环头位于四元式 $9$，出口点位于四元式 $15$。\n\n- 对于短路语义下的逻辑析取 $E_{1} \\lor E_{2}$：\n  - 如果 $E_{1}$ 为真，整个条件为真，控制转移到循环体。\n  - 如果 $E_{1}$ 为假，则继续对 $E_{2}$ 求值。\n  - 如果 $E_{2}$ 为真，转移到循环体。\n  - 如果 $E_{2}$ 为假，转移到循环出口。\n\n将此应用于四元式：\n\n- 四元式 $9$ 是对 $E_{1}$ 的测试：if $p \\le q$ goto $?$.\n  - 真分支跳转到四元式 $13$ 处的循环体，因此我们将四元式 $9$ 的目标回填为 $13$。\n- 四元式 $10$ 是在 $E_{1}$ 为假时转移到对 $E_{2}$ 求值的指令：goto $?$.\n  - 它应跳转到四元式 $11$ 处的下一个测试，因此我们将四元式 $10$ 的目标回填为 $11$。\n- 四元式 $11$ 是对 $E_{2}$ 的测试：if $r > s$ goto $?$.\n  - 真分支跳转到四元式 $13$ 处的循环体，因此我们将四元式 $11$ 的目标回填为 $13$。\n- 四元式 $12$ 是测试 $E_{2}$ 后的假分支：goto $?$.\n  - 假结果退出循环，因此我们将四元式 $12$ 的目标回填为 $15$。\n- 四元式 $13$ 是循环体：$y := y + 2$。\n- 四元式 $14$ 是循环的后向边：goto $?$.\n  - 它必须将控制转移回四元式 $9$ 处的循环头以重新求值条件，因此我们将四元式 $14$ 的目标回填为 $9$。\n- 四元式 $15$ 是循环出口点：$\\text{noop}$。\n\n因此，回填后完整的四元式数组是：\n\n- $1$: if $a > b$ goto $3$\n- $2$: goto $7$\n- $3$: if $c \\neq d$ goto $5$\n- $4$: goto $7$\n- $5$: $x := x + 1$\n- $6$: goto $8$\n- $7$: $x := x - 1$\n- $8$: $y := 0$\n- $9$: if $p <= q$ goto $13$\n- $10$: goto $11$\n- $11$: if $r > s$ goto $13$\n- $12$: goto $15$\n- $13$: $y := y + 2$\n- $14$: goto $9$\n- $15$: $\\text{noop}$\n\n被回填的四元式索引集合是 $P = \\{1, 2, 3, 4, 6, 9, 10, 11, 12, 14\\}$，对应的回填目标 $\\{t_{i}\\}$ 是：\n- $t_{1} = 3$\n- $t_{2} = 7$\n- $t_{3} = 5$\n- $t_{4} = 7$\n- $t_{6} = 8$\n- $t_{9} = 13$\n- $t_{10} = 11$\n- $t_{11} = 13$\n- $t_{12} = 15$\n- $t_{14} = 9$\n\n我们现在计算校验和\n$$\n\\Sigma \\;=\\; \\sum_{i \\in P} i \\times t_{i}\n\\;=\\;\n(1 \\times 3)\n+ (2 \\times 7)\n+ (3 \\times 5)\n+ (4 \\times 7)\n+ (6 \\times 8)\n+ (9 \\times 13)\n+ (10 \\times 11)\n+ (11 \\times 13)\n+ (12 \\times 15)\n+ (14 \\times 9).\n$$\n逐项计算：\n- $1 \\times 3 = 3$\n- $2 \\times 7 = 14$\n- $3 \\times 5 = 15$\n- $4 \\times 7 = 28$\n- $6 \\times 8 = 48$\n- $9 \\times 13 = 117$\n- $10 \\times 11 = 110$\n- $11 \\times 13 = 143$\n- $12 \\times 15 = 180$\n- $14 \\times 9 = 126$\n\n求和，\n$$\n\\Sigma = 3 + 14 + 15 + 28 + 48 + 117 + 110 + 143 + 180 + 126 = 784.\n$$\n因此，所求的校验和为 $784$。", "answer": "$$\\boxed{784}$$", "id": "3623495"}, {"introduction": "真实的程序常常包含嵌套的控制结构以及像 `break` 这样改变控制流的特殊语句。这个练习将挑战你跟踪一个嵌套 `while` 循环的代码生成过程。你将看到回填技术如何系统性地管理不同的作用域，以及一个专门的列表（通常称为 `breaklist`）对于正确实现跳出循环到其正确出口的重要性。[@problem_id:3623441]", "problem": "考虑一个编译器中的控制流语句翻译方案，该方案将三地址码（Three-Address Code (TAC)）生成到一个由全局计数器 $nextquad$ 索引的线性四元式序列中。该编译器使用回填方法：布尔表达式产生前向跳转列表（$truelist$ 和 $falselist$）；循环维护一个 $breaklist$ 来捕获从 $break$ 语句到循环出口的未回填跳转。以下基本事实定义了推导的基础：\n\n- 关系条件的布尔测试被翻译成两个 TAC 四元式：一个用于真分支的条件跳转和一个用于假分支的无条件跳转。因此，每个布尔表达式 $E$ 贡献 $2$ 个四元式，并产生 $E.truelist$ 和 $E.falselist$，其中包含待后续回填的已生成跳转的索引。\n- 对于形式为 $while\\ (B)\\ do\\ S$ 的 $while$ 语句，翻译方案如下：\n  1. 在生成 $B$ 之前，记录 $M$，定义为 $M = nextquad$。\n  2. 翻译 $B$ 以产生 $B.truelist$ 和 $B.falselist$。\n  3. 在 $S$ 的开头记录 $N = nextquad$，并将 $B.truelist$ 回填至 $N$。\n  4. 翻译 $S$。\n  5. 生成一个回边 $goto\\ M$。\n  6. 生成回边后，令 $L = nextquad$；将 $B.falselist$ 回填至 $L$，同时也将循环的 $breaklist$ 回填至 $L$。\n- 对于形式为 $if\\ (B)\\ then\\ S_1\\ else\\ S_2$ 的语句，方案如下：\n  1. 翻译 $B$，产生 $B.truelist$ 和 $B.falselist$。\n  2. 记录 $N_{then} = nextquad$ 并将 $B.truelist$ 回填至 $N_{then}$；翻译 $S_1$。\n  3. 生成一个 $goto\\ \\_\\_\\_$（一个 TAC 四元式）以跳过 $S_2$，并将其索引收集到 $nextlist$ 中，以便回填到“if 之后”的汇合点。\n  4. 记录 $N_{else} = nextquad$ 并将 $B.falselist$ 回填至 $N_{else}$；翻译 $S_2$。\n  5. 在 $S_2$ 之后，令 $J = nextquad$；将第 3 步中的 $nextlist$ 回填至 $J$。\n- 循环内的 $break$ 语句生成 $1$ 个 TAC 四元式 $goto\\ \\_\\_\\_$，并将其索引附加到最内层循环的 $breaklist$ 中。该 $breaklist$ 会被回填到上述 $while$ 方案中定义的循环出口标签 $L$。\n\n给定以下嵌套控制流程序片段：\n\n- 程序：\n  - $while\\ (E_1)\\ do$\n    - $while\\ (E_2)\\ do$\n      - $if\\ (E_3)\\ then$\n        - $break;$\n      - $else$\n        - $S_a;$\n      - $S_b;$\n    - $S_c;$\n\n假设以下 TAC 生成成本：\n- 每个布尔表达式 $E_i$ 生成 $2$ 个 TAC 四元式。\n- $break$ 语句生成 $1$ 个 TAC 四元式。\n- $S_a$ 语句生成 $3$ 个 TAC 四元式。\n- $S_b$ 语句生成 $2$ 个 TAC 四元式。\n- $S_c$ 语句生成 $1$ 个 TAC 四元式。\n- 在 $if$ 翻译中，用于 $then$ 部分末尾的无条件 $goto$ 生成 $1$ 个 TAC 四元式。\n\n假设全局计数器初始满足 $nextquad = q_0$，其中 $q_0 = 500$。请严格按照上述方案进行翻译，不进行任何优化或省略。计算内层 $if$ 语句的 $then$ 块中的 $break$ 最终被回填到的确切四元式索引。您的答案必须是一个整数（无单位，不四舍五入）。", "solution": "该问题要求精确追踪给定的编译器翻译方案，以确定特定 `break` 语句的目标四元式索引。生成三地址码（TAC）使用的是回填方法，其中每个四元式的位置由一个全局计数器追踪，我们将其表示为 $q$。初始值给定为 $q_0 = 500$。\n\n该程序片段具有嵌套结构：\n- 外层循环：`while` ($E_1$) `do` {$S_{outer}$}\n- 内层循环：`while` ($E_2$) `do` {$S_{inner}$}\n- `if` 语句：`if` ($E_3$) `then` `break;` `else` {$S_a$;}\n\n我们将根据指定的规则，在编译器处理该片段时逐步追踪 $q$ 计数器的值。\n\n1.  **外层 `while` 循环 (`while (E_1) ...`)**:\n    - 记录循环条件测试开始的地址：$M_1 = q = 500$。\n    - 翻译布尔表达式 $E_1$。根据题目，这会生成 $2$ 个四元式。计数器更新为：$q = 500 + 2 = 502$。这两个四元式是 $E_1$ 的真假情况的跳转。\n    - 循环体的开始位于当前地址，$N_1 = q = 502$。$E_1$ 的真列表（包含第一个跳转的索引，位于 $500$）被回填以指向 $N_1$。\n\n2.  **外层循环体（包含内层 `while` 循环）**:\n    - 外层循环体内的第一条语句是内层 `while` 循环。翻译从 $q=502$ 开始。\n\n3.  **内层 `while` 循环 (`while (E_2) ...`)**:\n    - 记录此循环条件测试开始的地址：$M_2 = q = 502$。\n    - 翻译布尔表达式 $E_2$，生成 $2$ 个四元式。计数器更新为：$q = 502 + 2 = 504$。位于索引 $502$ 和 $503$ 的这两个跳转填充了 $E_2$ 的真假列表。\n    - 内层循环体的开始位于当前地址，$N_2 = q = 504$。$E_2$ 的真列表（包含索引 $502$）被回填以指向 $N_2$。\n\n4.  **内层循环体（包含 `if-else` 和 $S_b$）**:\n    - 继续翻译内层循环的循环体，从 $q=504$ 开始。第一条语句是 `if` 语句。\n\n5.  **`if (E_3) then ... else ...` 语句**:\n    - 翻译布尔表达式 $E_3$，生成 $2$ 个四元式。计数器变为 $q = 504 + 2 = 506$。位于索引 $504$ 和 $505$ 的跳转填充了 $E_3$ 的真假列表。\n    - `then` 块从 $N_{then} = q = 506$ 开始。$E_3$ 的真列表（包含索引 $504$）被回填以指向 $N_{then}$。\n    - `then` 块包含一个 `break` 语句。根据规则，`break` 生成 $1$ 个形式为 `goto ___` 的 TAC 四元式。这个四元式在当前地址 $q=506$ 处生成。此 `goto` 的索引 $506$ 被添加到最内层循环（即 `while (E_2)` 循环）的 `breaklist` 中。我们称此列表为 `breaklist_2`。生成此四元式后，计数器递增：$q = 506 + 1 = 507$。\n    - `then` 块之后，生成一个无条件跳转以跳过 `else` 块。这会消耗 $1$ 个四元式。这个 `goto ___` 在索引 $q=507$ 处生成，其索引被添加到一个名为 $nextlist$ 的列表中。计数器更新为：$q = 507 + 1 = 508$。\n    - `else` 块从 $N_{else} = q = 508$ 开始。$E_3$ 的假列表（包含索引 $505$）被回填以指向 $N_{else}$。\n    - 翻译 `else` 块中的 $S_a$ 语句。它生成 $3$ 个四元式。计数器变为 $q = 508 + 3 = 511$。\n    - `if-else` 语句的翻译结束。语句后的汇合点位于当前地址，$J = q = 511$。$nextlist$（包含索引 $507$）被回填到此目标 $J$。\n\n6.  **继续内层循环体**:\n    - 翻译 `if` 语句之后的 $S_b$ 语句。它生成 $2$ 个四元式。计数器变为 $q = 511 + 2 = 513$。\n\n7.  **内层 `while` 循环的结束**:\n    - 内层 `while` 循环的循环体现已完全翻译。应用 `while` 语句规则的最后步骤。\n    - 生成一个无条件回边 `goto M_2`。我们记录了 $M_2 = 502$。该指令是一个四元式，放置在索引 $q=513$ 处。计数器递增：$q = 513 + 1 = 514$。\n    - 紧随内层循环生成代码之后的地址定义了该循环的出口点。设其为 $L_2$。因此，$L_2 = q = 514$。\n    - 根据 `while` 规则，循环的 `falselist`（来自 $E_2$）和循环的 `breaklist` (`breaklist_2`) 都被回填到这个出口地址 $L_2$。\n\n`if` 块中的 `break` 语句在索引 $506$ 处生成了一个 `goto` 四元式。该四元式的引用被存储在 `breaklist_2` 中。此列表被回填到目标 $L_2$。计算出的 $L_2$ 值为 $514$。因此，索引 $506$ 处的 `goto` 指令被补全为 `goto 514`。\n\n`break` 被回填到的四元式索引是 $514$。", "answer": "$$\n\\boxed{514}\n$$", "id": "3623441"}, {"introduction": "一个健壮的编译器不仅能生成正确的代码，还应具备验证其自身逻辑的机制。最后一个练习将从“应用”转向“分析”，它提供了一个回填过程中出现错误并导致无限循环的场景。你的任务是评估不同的诊断策略，运用控制流图（Control Flow Graph）和回填不变量等概念，找出能够可靠地发现并精确定位错误的方法。这将加深你对回填规则为何如此设计的理解。[@problem_id:3623500]", "problem": "一个编译器使用标准的回填方法将结构化控制流翻译成三地址码。对于布尔表达式，它维护一个真链和一个假链，记为 $\\mathtt{truelist}$ 和 $\\mathtt{falselist}$，它们是待后续回填的不完整跳转指令的集合。对于语句，它维护一个后继链，记为 $\\mathtt{nextlist}$，其中包含应回填到该语句后继指令的不完整跳转。其基本不变式为：对于 while 语句 $\\mathtt{while}\\ (B)\\ S$，$B.\\mathtt{truelist}$ 中的条目被回填到 $S$ 的第一条指令，而 $B.\\mathtt{falselist}$ 中的条目被回填到循环之后的第一条指令。控制流图 (CFG) 的节点是基本块（首指令位于程序的第一条指令、跳转的目标指令，以及紧跟在跳转指令之后的指令），其边由条件跳转、无条件跳转以及顺序执行到下一条指令而产生。\n\n考虑在回填前为一个循环生成的如下三地址码，其中指令编号是最左边的整数，标记 $M$ 和 $N$ 分别记录由语法指导的翻译捕获的循环头和循环后的第一条指令（因此 $M$ 指向测试，而 $N$ 指向循环后的代码）：\n\n- $10$: if $x > y$ goto $\\_$ \n- $11$: goto $\\_$ \n- $12$: $...$ $S$ 的代码开始 $...$\n- $13$: $...$\n- $14$: $...$ $S$ 的代码结束 $...$\n- $15$: goto $10$\n- $16$: $...$ 循环后的代码开始 $...$\n\n在解析完 $B$ 之后、回填之前的那个时刻，$B.\\mathtt{truelist} = \\{10\\}$ （指令10处的条件跳转）且 $B.\\mathtt{falselist} = \\{11\\}$，而 $S.\\mathtt{nextlist} = \\varnothing$。编译器回填例程中的一个缺陷错误地将 $B.\\mathtt{falselist}$ 回填到了 $M$（即指令10），而不是 $N$（即指令16）。最终回填后的代码是：\n\n- $10$: if $x > y$ goto $12$\n- $11$: goto $10$\n- $12$: $...$ $S$ 的代码开始 $...$\n- $13$: $...$\n- $14$: $...$ $S$ 的代码结束 $...$\n- $15$: goto $10$\n- $16$: $...$ 循环后的代码开始 $...$\n\n即使条件 $x > y$ 初始为假，该程序也会表现出无限循环，因为控制流是 $10 \\to 11 \\to 10 \\to 11 \\to \\cdots$。\n\n现在要求你仅使用基本原理来诊断此错误回填：即回填列表的不变式、控制流图（CFG）的定义以及标准的可达性和支配概念。下列哪种诊断方法可以可靠地识别出这一错误回填，并将其正确归因于 $B.\\mathtt{falselist}$ 的错误目标？\n\n选择所有适用项。\n\nA. 构建 CFG，为条件跳转（到目标和顺序执行）、无条件跳转添加边，并在没有跳转覆盖时为顺序执行到下一条指令添加边。使用记录的标记 $N$ 作为循环后首指令（指令 16），检查从循环测试（指令 10）沿假后继路径到 $N$ 的可达性。如果不存在这样的路径，则报告 $B.\\mathtt{falselist}$ 的错误回填，并通过追溯 $B.\\mathtt{falselist}$ 中的哪条指令未被回填到 $N$ 来识别有问题的 goto 指令。\n\nB. 构建 CFG 并计算支配节点。将任何头节点不支配其尾节点的回边标记为此循环中存在错误回填的证据。如果存在这样的边，则将无限循环归因于错误回填的 $B.\\mathtt{falselist}$。\n\nC. 使用列表来源信息而无需构建完整的 CFG：通过检查 $B.\\mathtt{falselist}$ 中的每个条目是否都回填到了 $N$（循环后首指令的标记），并且没有条目回填到 $M$（循环头标记），来验证 while 语句的不变式。如果 $B.\\mathtt{falselist}$ 中的某个成员被回填到了 $M$，报告此错误回填以及负责的确切指令索引。\n\nD. 在任意输入上执行生成的代码，如果在固定的超时时间内不终止，则将不终止归因于循环体中错误的 $\\mathtt{nextlist}$ 回填，而不是 $B.\\mathttfalselist}$。\n\nE. 重编号指令，强制所有条件跳转的假分支边指向严格更大的指令编号。如果程序随后在给定输入上终止，则断定原始的不终止是由错误的 $B.\\mathtt{falselist}$ 回填引起的。\n\n只应选择那些根据上述定义保证能发现此类特定回填缺陷并能正确定位其原因的方法。以所有正确选项的集合形式给出你的答案。", "solution": "首先验证问题陈述，以确保其科学上合理、表述清晰且客观。\n\n### 步骤 1：提取已知条件\n\n- **编译器方法**：用于将结构化控制流翻译成三地址码的标准回填方法。\n- **数据结构**：\n    - `truelist`：布尔表达式 $B$ 的一个不完整跳转集合，应被回填到真出口。\n    - `falselist`：布尔表达式 $B$ 的一个不完整跳转集合，应被回填到假出口。\n    - `nextlist`：语句 $S$ 的一个不完整跳转集合，应被回填到该语句的后继指令。\n- **对于 `while (B) S` 的不变式**：\n    - $B.\\mathtt{truelist}$ 中的条目被回填到 $S$ 的第一条指令。\n    - $B.\\mathtt{falselist}$ 中的条目被回填到循环之后的第一条指令。\n- **CFG 定义**：\n    - 节点是基本块。\n    - 首指令位于程序的第一条指令、跳转的目标指令，以及紧跟在跳转指令之后的指令。\n    - 边由条件跳转、无条件跳转以及顺序执行产生。\n- **场景代码（回填前）**：\n    - $10$: if $x > y$ goto $\\_$\n    - $11$: goto $\\_$\n    - $12$: $...$ $S$ 的代码开始 $...$\n    - $...$\n    - $15$: goto $10$\n    - $16$: $...$ 循环后的代码开始 $...$\n- **场景状态**：\n    - 标记 $M$ 指向指令 $10$（循环头）。\n    - 标记 $N$ 指向指令 $16$（循环后）。\n    - $B.\\mathtt{truelist} = \\{10\\}$。\n    - $B.\\mathtt{falselist} = \\{11\\}$。\n    - $S.\\mathtt{nextlist} = \\varnothing$。\n- **缺陷**：$B.\\mathtt{falselist}$ 被错误地回填到 $M$（指令 $10$）而不是 $N$（指令 $16$）。\n- **最终回填后的代码**：\n    - $10$: if $x > y$ goto $12$\n    - $11$: goto $10$\n    - $12$: $...$ $S$ 的代码开始 $...$\n    - $...$\n    - $15$: goto $10$\n    - $16$: $...$ 循环后的代码开始 $...$\n- **问题**：找出哪种诊断方法可以可靠地识别此错误回填，并将其正确归因于 $B.\\mathtt{falselist}$ 的错误目标，且仅基于基本原理。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n该问题陈述定义清晰，并基于编译器设计的既定原则，特别是语法指导的翻译和代码生成。回填、三地址码、控制流图（CFG）和支配节点的概念都是计算机科学中的标准概念。该场景呈现了一个具体的、合理的缺陷，并要求用形式化方法来检测它。问题是自包含的，提供了所有必要的定义和数据。它是客观的，不包含任何科学或事实上的不健全之处。\n\n### 步骤 3：结论与行动\n\n问题陈述是有效的。解决方案将继续根据所提供的原则分析每种提议的方法。\n\n### 基于原则的推导与选项分析\n\n问题的核心在于违反了结构化程序设计翻译的一条基本不变式。对于 `while` 循环，布尔条件必须提供两条不同的路径：一条进入（或继续）循环体，另一条退出循环。在回填的背景下，这转化为：\n- $B.\\mathtt{truelist}$ 中的跳转必须回填到循环体 ($S$) 的开始处。\n- $B.\\mathtt{falselist}$ 中的跳转必须回填到紧跟在循环之后的指令 ($N$)。\n\n所描述的缺陷是，来自 $B.\\mathtt{falselist}$ 的一条指令（指令 11）被回填到了循环头 $M$（指令 10）而不是循环出口 $N$（指令 16）。这造成了一种情况，即条件的“假”路径又指回到条件本身，从而使得当条件为假时循环永远无法终止。一个有效的诊断方法必须能检测到这个特定的违规行为并找出其原因。\n\n我们来分析一下有缺陷代码的控制流图 (CFG)。首指令是指令 $10$（跳转的目标）、$11$（紧跟条件跳转之后）、$12$（跳转的目标）和 $16$（紧跟跳转之后）。\n基本块是：\n- $B_1$：指令 $10$\n- $B_2$：指令 $11$\n- $B_3$：指令 $12-15$\n- $B_4$：指令 $16$ 及之后\n\n边是：\n- $B_1 \\to B_3$（从 10 处的 `if` 到 12 的真分支）\n- $B_1 \\to B_2$（假分支，从 10 顺序执行到 11）\n- $B_2 \\to B_1$（从 11 到 10 的无条件跳转）\n- $B_3 \\to B_1$（从 15 到 10 的无条件跳转）\n\n请注意，没有指向 $B_4$ 的边，这意味着循环之后的代码是不可达的。\n\n**A. 构建 CFG... 检查从循环测试（指令 10）沿假后继路径到 $N$（指令 16）的可达性。**\n\n该方法提议构建 CFG 并执行可达性分析。循环测试位于指令 10。其“假后继”路径始于从节点 $B_1$（包含指令 10）到节点 $B_2$（包含指令 11）的边。沿着这条路径，我们得到了循环 $B_1 \\to B_2 \\to B_1 \\to \\dots$。节点 $B_4$（包含 $N=16$）从 $B_1$ 或 $B_2$ 均不可达。因此，检查“如果不存在这样的路径，则报告错误回填”将正确触发一个错误。该方法接着提议“通过追溯 $B.\\mathtt{falselist}$ 中的哪条指令未被回填到 $N$ 来识别有问题的 goto 指令”。编译器拥有元数据 $B.\\mathtt{falselist}=\\{11\\}$。通过检查生成的代码，可以看到指令 11 是 `goto 10`。由于目标 $10 \\neq N$，该方法正确地识别了列表中的指令及其不正确的回填。此方法是合理的，并能正确归因。\n结论：**正确**。\n\n**B. 构建 CFG 并计算支配节点。将任何头节点不支配其尾节点的回边标记为...**\n\n该方法依赖于 CFG 中回边的定义，即一条边 $(u, v)$，其头节点 $v$ 支配其尾节点 $u$。此属性用于识别自然循环。让我们以 $B_1$ 为入口计算此 CFG 的支配节点。\n- $\\mathrm{dom}(B_1) = \\{B_1\\}$\n- $\\mathrm{dom}(B_3) = \\{B_1, B_3\\}$\n- $\\mathrm{dom}(B_2) = \\{B_1, B_2\\}$\n回边是指向支配节点的边。\n- 边 $B_3 \\to B_1$：头是 $B_1$，尾是 $B_3$。$B_1 \\in \\mathrm{dom}(B_3)$。这是一条有效的回边。\n- 边 $B_2 \\to B_1$：头是 $B_1$，尾是 $B_2$。$B_1 \\in \\mathrm{dom}(B_2)$。这也是一条有效的回边。\n提议的检查是“标记任何头节点不支配其尾节点的回边”。在我们的例子中，两条回边的头节点都支配其尾节点。因此，该方法将**不会**标记任何错误。该缺陷创建了一个结构上合理（但语义上不正确）的循环。仅凭支配分析不足以检测这种逻辑错误。\n结论：**不正确**。\n\n**C. 使用列表来源信息而无需构建完整的 CFG：通过检查 $B.\\mathtt{falselist}$ 中的每个条目是否都回填到了 $N$...来验证 while 语句的不变式...**\n\n该方法绕过了复杂的图分析，而是直接使用编译器维护的元数据（列表和标记）来验证回填的不变式。`while` 语句的不变式明确要求 $B.\\mathtt{falselist}$ 中的所有指令都必须回填到目标 $N$。提议的检查是遍历 $B.\\mathtt{falselist}$ 中的条目，并验证它们回填的目标确实是 $N$。\n在这种情况下，$B.\\mathtt{falselist} = \\{11\\}$ 且 $N = 16$。检查会审查回填后代码中的指令 11，即 `goto 10`。目标是 10。由于 $10 \\neq 16$，不变式被违反了。该方法正确地报告了错误回填，并识别出确切的责任指令（11）和列表（$B.\\mathtt{falselist}$）。这是找到此特定缺陷的一种直接、精确且可证明正确的方法。\n结论：**正确**。\n\n**D. 在任意输入上执行生成的代码，如果在固定的超时时间内不终止，则将不终止归因于不正确的 $\\mathtt{nextlist}$ 回填...**\n\n该方法提议的是动态分析（测试）而非静态分析。虽然测试可以揭示缺陷的存在（不终止），但作为一种诊断工具，它有几个根本性的缺陷。\n1.  它不是一种*证明*。它只对测试过的特定输入有效。对于不同的初始状态（例如 $x \\ge y$），循环可能会正确终止（通过进入循环体，并在变量适当改变后最终退出），这样缺陷就不会被发现。\n2.  固定的超时是任意的，可能导致假阳性（对于一个正确但运行时间长的循环）或假阴性（如果超时太长）。\n3.  归因是不正确的。它将问题归咎于 `S.nextlist`，而实际的缺陷在于 $B.\\mathtt{falselist}$ 的回填。在给定的场景中，循环体 $S$ 甚至从未被进入，所以 `S.nextlist`（反正它也是空的）是无关的。\n结论：**不正确**。\n\n**E. 重编号指令，强制所有条件跳转的假分支边指向严格更大的指令编号。如果程序随后终止...则断定原始的不终止是由错误的 $B.\\mathtt{falselist}$ 回填引起的。**\n\n这是另一种基于启发式修改后进行测试的方法。短语“重编号指令”是模糊的。如果它仅指改变标签（例如，$10 \\to 100, 11 \\to 101$），`goto 100` 将会保留无限循环。一个更宽容的解释是，它意在强制执行一种代码布局，其中所有“假”情况的控制流都向前走。从指令 10 开始的假路径是顺序执行到 11。指令 11 是 `goto 10`，一个向后跳转。该方法似乎建议修改此跳转使其指向前方。这本质上是提议一个“修复”（将 11 回填到指向 16）然后重新测试。与选项 D 一样，这是一种动态分析形式，而不是静态证明。这是一种“猜测并检查”的方法，而不是从基本原理出发查找并归因错误所在的诊断方法。它不能可靠地识别错误回填；它只是观察到某个特定的更改在一个测试用例上修复了一个症状。\n结论：**不正确**。", "answer": "$$\\boxed{AC}$$", "id": "3623500"}]}