{"hands_on_practices": [{"introduction": "在优化循环之前，编译器必须首先理解其基本属性，例如它执行的次数（即行程计数）以及其变量将持有的值。本练习旨在通过将一个简单 `while` 循环的行为形式化为数学序列 [@problem_id:3653514]，来实践推导这些属性。这项技能是许多高级循环优化的基础。", "problem": "考虑一个在命令式中间表示中对数学整数进行操作的结构化循环，其变量初始化如下：$i \\leftarrow a$，$s \\leftarrow 0$，其中 $a$、$n$ 和 $d$ 是满足 $0 \\le a \\le n$、$d \\ge 1$ 且 $d$ 整除 $(n - a)$ 的整数。该循环具有如下高级形式：当谓词 $i \\le n$ 成立时，执行一个循环体，该循环体执行更新 $s \\leftarrow s + (2i + 1)$，然后通过 $i \\leftarrow i + d$推进循环变量。您必须将此循环降级为规范的单入口单出口循环形式，该形式在控制流图（CFG）中包含一个前置头部（preheader）、一个测试谓词 $i \\le n$ 的头部（header）、一个计算循环有效载荷的主体（body）以及一个更新 $i$ 并分支返回到头部的尾部（latch）。降级过程必须保持语义，使得当且仅当 $i$ 在所述的可整除条件下达到 $n$ 时，最后一次迭代在 $i = n$ 时执行。\n\n仅从循环的基本操作语义（即：while 循环在头部评估其谓词；如果为真，则执行循环体并继续循环；如果为假，则退出）和 CFG 中的标准规范循环结构（头部测试、主体和带有回边的尾部）出发，推导 $i$ 所取的精确动态值序列，得出作为 $a$、$n$ 和 $d$ 的函数的循环体执行次数，然后计算循环退出时 $s$ 的最终值的闭式表达式。假设使用无限精度算术，且不会发生整数溢出。\n\n请以 $a$、$n$ 和 $d$ 的单个闭式解析表达式形式提供您的最终答案。最终答案中不得包含推导过程。无需四舍五入。", "solution": "用户要求我分析一个特定的循环，并推导一个变量最终值的闭式表达式。\n\n### 问题验证\n\n**步骤1：提取给定条件**\n-   **变量初始值**: $i \\leftarrow a$, $s \\leftarrow 0$。\n-   **循环谓词**: $i \\le n$。\n-   **循环体更新**: $s \\leftarrow s + (2i + 1)$。\n-   **循环变量更新（在尾部）**: $i \\leftarrow i + d$。\n-   **参数约束**: $a$、$n$ 和 $d$ 是整数。$0 \\le a \\le n$。$d \\ge 1$。$d$ 整除 $(n-a)$，可写作 $(n-a) \\equiv 0 \\pmod{d}$。\n-   **终止条件**: 最后一次迭代在 $i=n$ 时执行。\n-   **算术模型**: 无限精度算术。\n\n**步骤2：使用提取的给定条件进行验证**\n-   **科学性**: 该问题基于编译器设计（循环分析、中间表示、控制流图）和离散数学（等差数列、求和）的原理。所有概念都是完善且形式化的。\n-   **适定性**: 该问题是适定的。给定的条件充分且一致。约束条件，特别是 $d$ 整除 $(n-a)$，确保了循环计数器 $i$ 将精确地达到值 $n$，从而得到明确定义的迭代次数。存在一个唯一、稳定且有意义的解。\n-   **客观性**: 问题以精确、客观的数学和计算语言陈述。没有主观或模棱两可的术语。\n\n**步骤3：结论与行动**\n问题是有效的。这是一个在计算机科学背景下定义明确的数学问题。我将继续进行解的推导。\n\n### 解的推导\n\n该问题描述了一个 `while` 循环。在规范的控制流图（CFG）表示中，这种结构由用于初始化的前置头部、用于条件测试的头部、用于主计算的主体以及用于更新循环计数器并分支返回到头部的尾部组成。\n\n1.  **分析循环计数器 `i` 的序列**:\n    循环计数器 $i$ 初始化为 $a$。在每次迭代中，它增加 $d$。因此，$i$ 在每次迭代开始时（在头部测试处）所取的值序列构成一个等差数列：\n    $$ a, a+d, a+2d, a+3d, \\dots $$\n\n2.  **确定循环迭代次数**:\n    只要谓词 $i \\le n$ 为真，循环就会执行。问题陈述 $d$ 整除 $(n-a)$。这意味着存在一个整数 $m$ 使得 $n - a = m d$。由于 $n \\ge a$ 且 $d \\ge 1$，我们有 $m \\ge 0$。\n    $i$ 的值序列为 $a+0d, a+1d, a+2d, \\dots, a+md$。该序列中的最后一个值为 $a+md = a+(n-a) = n$。\n    对于这些值中的每一个，循环体都会执行，因为对于 $k \\in \\{0, 1, \\dots, m\\}$，每个值 $a+kd$ 都满足 $a+kd \\le a+md = n$。\n    循环体执行时 $i$ 的值序列是 $a, a+d, \\ldots, n$。\n    为了找到迭代次数，我们计算这个序列中的项数。这些项可以由 $k \\in \\{0, 1, \\dots, m\\}$ 索引。总项数为 $(m - 0) + 1 = m+1$。\n    设 $N_{iter}$ 为迭代次数。\n    $$ N_{iter} = m+1 $$\n    代入 $m = \\frac{n-a}{d}$：\n    $$ N_{iter} = \\frac{n-a}{d} + 1 = \\frac{n-a+d}{d} $$\n\n3.  **计算 `s` 的最终值**:\n    变量 $s$ 初始化为 $0$。在每次迭代中，值 $(2i+1)$ 被加到 $s$ 上。$s$ 的最终值是循环体执行时所有 $i$ 对应的 $(2i+1)$ 的总和。\n    $$ s_{final} = \\sum_{k=0}^{m} \\left( 2(a+kd) + 1 \\right) $$\n    加到 $s$ 上的各项构成一个等差级数。我们来确定首项、末项和项数。\n    -   **项数**: $N = N_{iter} = m+1 = \\frac{n-a+d}{d}$。\n    -   **首项 (当 $k=0$ 时)**: $T_1 = 2(a+0 \\cdot d) + 1 = 2a+1$。\n    -   **末项 (当 $k=m$ 时)**: $T_N = 2(a+m \\cdot d) + 1$。由于 $a+md = n$，此项为 $T_N = 2n+1$。\n\n    等差级数的和由公式 $S_N = \\frac{N}{2}(\\text{首项} + \\text{末项})$ 给出。\n    应用此公式求 $s_{final}$：\n    $$ s_{final} = \\frac{N_{iter}}{2} (T_1 + T_N) $$\n    代入 $N_{iter}$、$T_1$ 和 $T_N$ 的表达式：\n    $$ s_{final} = \\frac{1}{2} \\left( \\frac{n-a+d}{d} \\right) \\left( (2a+1) + (2n+1) \\right) $$\n    现在，我们简化表达式：\n    $$ s_{final} = \\frac{1}{2} \\left( \\frac{n-a+d}{d} \\right) (2a + 2n + 2) $$\n    $$ s_{final} = \\frac{1}{2} \\left( \\frac{n-a+d}{d} \\right) \\cdot 2(a+n+1) $$\n    $$ s_{final} = \\left( \\frac{n-a+d}{d} \\right) (n+a+1) $$\n    这就是循环终止时 $s$ 的值的最终闭式表达式。", "answer": "$$\\boxed{\\left(\\frac{n-a+d}{d}\\right)(n+a+1)}$$", "id": "3653514"}, {"introduction": "现实世界中的循环通常包含 `break` 和 `continue` 语句，这些语句会在程序执行中产生非顺序的跳转。为了正确处理这些情况，编译器将循环表示为控制流图（CFG）。本练习挑战你为一个带有复杂控制流的嵌套循环构建一个CFG [@problem_id:3653528]，并分析其结构复杂性，这是程序分析和测试的一项关键技能。", "problem": "考虑以下高级程序片段，它嵌套了两个循环，在外层循环中使用了条件性 continue 语句，在内层循环中使用了条件性 break 语句。设 $I$、$J$ 和 $k$ 为固定整数，满足 $I \\geq 1$、$J \\geq 1$ 和 $0 \\leq k  J$。该片段如下：\n\n对于 $i$ 从 $0$ 到 $I-1$：\n- 如果 $i \\bmod 2 = 1$，则 continue 到外层循环的下一次迭代。\n- 对于 $j$ 从 $0$ 到 $J-1$：\n  - 如果 $j = k$，则 break 跳出内层循环（即，如同内层循环对于当前 $i$ 已经完成一样继续执行）。\n  - 执行一个基本语句 $S(i,j)$，该语句没有内部控制流（既不分支也不调用任何过程）。\n\n假设采用常规的编译器翻译方法将其转换为三地址码（TAC），其中：\n- 每个循环都使用一个循环初始化块、一个循环条件测试块、一个循环体块和一个循环增量块来实现，这些块通过显式的条件和无条件跳转连接。\n- 每个条件测试（包括循环条件以及对 $i \\bmod 2 = 1$ 和 $j = k$ 的测试）都放在其自己的基本块中。\n- 以下各项均放置在各自独立的基本块中：循环初始化（$i := 0$，$j := 0$）、循环增量（$i := i + 1$，$j := j + 1$）、语句 $S(i,j)$ 以及一个唯一的函数出口块。\n- 只有一个函数入口和一个函数出口，因此控制流图（CFG）有 1 个连通分量。\n\n从上述片段和假设出发，通过识别基本块及其由常规 TAC 翻译所隐含的控制流边来构建 CFG，并包含 $continue$ 和 $break$ 语句的效果。然后，运用编译理论和图论的基本原理，计算所得 CFG 的圈复杂度。\n\n请提供您的最终答案，以单个整数形式表示圈复杂度。无需四舍五入，不涉及单位。", "solution": "该问题要求确定一个控制流图（CFG）的圈复杂度，该 CFG 是根据一组特定的编译器翻译规则，由给定的高级程序片段构建而来的。分析将首先验证问题，然后系统地识别 CFG 的组成部分（其节点和边），最后应用圈复杂度的形式化定义。\n\n问题陈述的验证如下：\n1.  **已知条件提取**：问题提供了一个带有条件性 `continue` 和 `break` 语句的嵌套循环结构。变量 $I$、$J$ 和 $k$ 被定义为具有约束 $I \\geq 1$、$J \\geq 1$ 和 $0 \\leq k  J$ 的固定整数。关键是，它指定了一套将此代码翻译为 CFG 的精确规则，包括如何为初始化、条件测试、增量和其他语句形成基本块。它还指出 CFG 具有单个连通分量。\n2.  **有效性检查**：该问题在编译理论和图论方面具有科学依据，使用了基本块、CFG 和圈复杂度等标准概念。给出的构建 CFG 的规则是明确且无歧义的，使得问题提法明确。语言客观、正式。问题是自洽的，没有违反任何科学原理。\n3.  **结论**：该问题被认为是有效的。可以推导出严谨的解。\n\n解决方案分三个阶段推导得出：识别基本块、通过定义控制流边构建 CFG，以及计算圈复杂度。\n\n首先，我们识别基本块集合，它们将作为我们的 CFG $G=(V,E)$ 的顶点 $V$。根据指定的规则，每个条件测试、初始化、增量和语句 $S(i,j)$ 都构成各自的基本块。我们还包括一个唯一的出口块。\n由此产生的基本块是：\n- $B_1$：外层循环初始化：`$i := 0$`\n- $B_2$：外层循环条件测试：`$i  I$`\n- $B_3$：`continue` 语句条件测试：`$i \\bmod 2 = 1$`\n- $B_4$：内层循环初始化：`$j := 0$`\n- $B_5$：内层循环条件测试：`$j  J$`\n- $B_6$：`break` 语句条件测试：`$j = k$`\n- $B_7$：基本语句：`$S(i,j)$`\n- $B_8$：内层循环增量：`$j := j + 1$`\n- $B_9$：外层循环增量：`$i := i + 1$`\n- $B_{10}$：唯一的函数出口块。\n\n此枚举得出 CFG 中总共有 $N = |V| = 10$ 个节点。\n\n其次，我们确定代表这些块之间控制流的有向边 $E$。\n- $B_1 \\to B_2$：初始化 `$i$` 后，检查外层循环条件。\n- $B_2 \\to B_3$：如果 `$i  I$` 为真，控制进入外层循环体，从 `$i \\bmod 2$` 测试开始。\n- $B_2 \\to B_{10}$：如果 `$i  I$` 为假，外层循环终止，控制转到出口块。\n- $B_3 \\to B_9$：如果 `$i \\bmod 2 = 1$` 为真，执行 `continue` 语句，将控制转移到外层循环的增量块 $B_9$。\n- $B_3 \\to B_4$：如果 `$i \\bmod 2 = 1$` 为假，执行顺序进行到内层循环的初始化。\n- $B_4 \\to B_5$：初始化 `$j$` 后，检查内层循环条件。\n- $B_5 \\to B_6$：如果 `$j  J$` 为真，控制进入内层循环体，从 `$j=k$` 测试开始。\n- $B_5 \\to B_9$：如果 `$j  J$` 为假，内层循环终止。控制接着进行到下一个有效语句，即外层循环的增量块 $B_9$。\n- $B_6 \\to B_9$：如果 `$j = k$` 为真，执行 `break` 语句，终止内层循环并将控制转移到其后的语句，即外层循环的增量块 $B_9$。\n- $B_6 \\to B_7$：如果 `$j = k$` 为假，执行顺序进行到语句 `$S(i,j)$`。\n- $B_7 \\to B_8$：执行 `$S(i,j)$` 后，控制流向内层循环的增量。\n- $B_8 \\to B_5$：增加 `$j$` 后，控制流回到内层循环的条件测试。\n- $B_9 \\to B_2$：增加 `$i$` 后，控制流回到外层循环的条件测试。\n\n计算这些转移，我们发现边的总数为 $E = |E| = 13$。\n\n第三，我们计算圈复杂度 $V(G)$。对于一个有 $N$ 个节点、$E$ 条边和 $P$ 个连通分量的图，复杂度由以下公式给出：\n$$V(G) = E - N + 2P$$\n问题指明 CFG 有 1 个连通分量，因此 $P=1$。代入上面推导出的 $N$ 和 $E$ 的值：\n$$V(G) = 13 - 10 + 2(1) = 3 + 2 = 5$$\n\n这个结果可以用结构化程序的替代公式 $V(G) = D + 1$ 来验证，其中 $D$ 是谓词节点（出度大于 1 的节点）的数量。在我们的 CFG 中，谓词节点是：\n- $B_2$ (测试 `$i  I$`)\n- $B_3$ (测试 `$i \\bmod 2 = 1$`)\n- $B_5$ (测试 `$j  J$`)\n- $B_6$ (测试 `$j = k$`)\n共有 $D=4$ 个这样的节点。因此，圈复杂度为：\n$$V(G) = 4 + 1 = 5$$\n两种方法都得出了相同的结果，证实了分析的正确性。指定 CFG 的圈复杂度为 5。", "answer": "$$\\boxed{5}$$", "id": "3653528"}, {"introduction": "现代编译器将代码转换为一种中间表示（如静态单赋值（SSA）形式）以利于优化。这种转换对最终生成的代码有直接的影响。本练习通过要求你量化与 $\\phi$ 函数（SSA的核心组成部分）相关的运行时成本 [@problem_id:3653540]，来探索嵌套循环结构与其SSA表示之间的联系。", "problem": "编译器将结构化循环转换为低级控制流形式，并将变量置于静态单赋值 (SSA) 形式。考虑在以下假设下，将高级语言中的以下嵌套循环规范化降级为一个具有显式头和闩锁的控制流图：\n\n- 外层循环迭代 $N$ 次，索引 $i$ 的取值范围为 $0, 1, \\dots, N-1$（即，循环守卫条件为 $i  N$）。\n- 对于每个固定的外层索引 $i$，内层循环以索引 $j$ 进行迭代，其边界条件为 $j  i$。也就是说，在每次外层迭代中，$j$ 的取值依次为 $0, 1, \\dots, i-1$。\n- 编译器执行规范化的循环降级，使得每个循环都有一个唯一的预备头、头、循环体和闩锁。循环头支配循环体和闩锁，并且恰好有两条入边：一条来自预备头，一条来自闩锁（回边）。内层索引 $j$ 在每次内层循环执行开始时（即，从预备头进入内层头时）重新初始化为 $0$，并在内层闩锁中沿回边递增 $1$。没有异常退出（没有 `break` 或 `continue`），且循环体是线性代码。\n- 编译器构造 SSA 形式，并在内层循环头为内层索引 $j$ 放置一个 $\\phi$-函数，以合并其两个到达定值：来自预备头的初始值 $0$ 和来自闩锁的增量值 $j+1$。\n- 在解构 SSA 时，编译器将每个 $\\phi$-函数降级为一个并行拷贝，实现为沿每条进入头的入边的一次寄存器到寄存器移动，该移动在运行时每当该边被采用时执行。假设不发生拷贝合并或消除。\n\n仅使用上述 SSA 形式的基本定义、支配合并点处的 $\\phi$-函数以及规范化循环降级语义，推导出一个关于 $N$ 的闭式表达式，表示在整个嵌套循环执行期间，仅由内层循环头的 $j$ 的 $\\phi$-函数所导致的运行时寄存器到寄存器移动指令的总数。\n\n以单个关于 $N$ 的闭式解析表达式给出你的最终答案。不需要四舍五入；不包括单位。假设 $N$ 是一个非负整数。", "solution": "所述问题具有科学依据，提法恰当，客观，并包含足够的信息以获得唯一解。它基于编译器设计的标准原理，包括控制流图、循环降级和静态单赋值 (SSA) 形式。因此，该问题是有效的。\n\n目标是找到一个闭式表达式，表示由于对内层循环索引 $j$ 的 $\\phi$-函数进行去 SSA 降级而执行的寄存器到寄存器移动指令的总数。\n\n根据问题陈述，SSA 解构将内层循环头处的 $\\phi$-函数降级为沿每条进入该头的入边的一次寄存器到寄存器移动指令。每当这些边在运行时被遍历时，就会执行一次移动。\n\n根据所描述的规范化循环结构，内层循环头恰好有两条入边：\n1.  一条来自内层循环预备头的边，每次进入内层循环时遍历一次。\n2.  一条来自内层循环闩锁的边，即循环的回边，在内层循环体每次迭代后遍历，以测试下一次迭代的条件。\n\n设 $M$ 为执行的移动指令总数。该总数是整个嵌套循环执行期间这两条边各自被遍历次数的总和。设 $M_{pre}$ 为预备头到头边的总遍历次数，设 $M_{latch}$ 为闩锁到头（回边）边的总遍历次数。\n$$\nM = M_{pre} + M_{latch}\n$$\n外层循环以索引 $i$ 迭代，取值范围为 $0, 1, \\dots, N-1$。对于这 $N$ 次迭代中的每一次，控制流都会进入包含内层循环结构的外层循环体。因此，对于 $i$ 的每个值，内层循环的预备头都会被精确进入一次。因此，内层循环的预备头到头边总共被遍历 $N$ 次。\n$$\nM_{pre} = N\n$$\n接下来，我们分析内层循环回边的遍历次数。对于一个固定的外层循环索引 $i$，内层循环以索引 $j$ 迭代，条件为 $j  i$。索引 $j$ 初始化为 $0$，并在闩锁中递增 $1$。内层循环体对 $j = 0, 1, \\dots, i-1$ 执行。\n\n对于一个固定的 $i$，我们来计算内层回边被采用的次数。对于给定的 $j$，循环体执行完毕后，会采用回边返回到循环头。对于每个执行循环体的 $j$ 值，这都会发生一次。执行循环体的 $j$ 值是 $0, 1, \\dots, i-1$。共有 $i$ 个这样的值。在 $j=i-1$ 的循环体执行后，闩锁将 $j$ 递增到 $i$，并最后一次采用回边到达循环头，此时条件 $i  i$ 被评估为假，导致循环终止。因此，对于给定的外层循环索引 $i$，内层循环回边恰好被遍历 $i$ 次。\n\n为了找到回边遍历的总次数 $M_{latch}$，我们必须对从 $i=0$ 到 $i=N-1$ 的每次外层循环的遍历次数求和。\n$$\nM_{latch} = \\sum_{i=0}^{N-1} i\n$$\n这是前 $N-1$ 个非负整数的和。等差数列 $0 + 1 + 2 + \\dots + (k-1)$ 的和由公式 $\\frac{k(k-1)}{2}$ 给出。在我们的例子中，级数是 $0 + 1 + \\dots + (N-1)$，这是一个等差数列的前 $N$ 项之和。其和由 $\\frac{n(a_1+a_n)}{2}$ 给出，其中 $n$ 是项数。这里 $n=N$，$a_1=0$，$a_N=N-1$。和为 $\\frac{N(0 + N-1)}{2} = \\frac{N(N-1)}{2}$。\n$$\nM_{latch} = \\sum_{i=0}^{N-1} i = 0 + 1 + 2 + \\dots + (N-1) = \\frac{(N-1)N}{2}\n$$\n现在，我们可以通过将来自两条边的贡献相加来计算移动指令的总数 $M$。\n$$\nM = M_{pre} + M_{latch} = N + \\frac{N(N-1)}{2}\n$$\n为了获得单个闭式表达式，我们对其进行代数简化。\n$$\nM = \\frac{2N}{2} + \\frac{N^2 - N}{2} = \\frac{2N + N^2 - N}{2} = \\frac{N^2 + N}{2}\n$$\n这可以因式分解为：\n$$\nM = \\frac{N(N+1)}{2}\n$$\n这个表达式表示前 $N$ 个正整数的和，也称为第 $N$ 个三角数。\n\n另外，我们可以这样推理：移动的总次数等于内层循环头被进入的总次数。对于给定的外层索引 $i$，内层头从预备头进入一次（为 $j=0$ 启动循环），从闩锁进入 $i$ 次（对应于 $j=0, \\dots, i-1$ 的迭代）。因此，对于给定的 $i$，头被进入 $1+i$ 次。对所有可能的 $i$ 值求和：\n$$\nM = \\sum_{i=0}^{N-1} (1+i) = (1+0) + (1+1) + \\dots + (1 + (N-1)) = \\sum_{k=1}^{N} k\n$$\n这是前 $N$ 个正整数的和，从而证实了结果。\n$$\n\\sum_{k=1}^{N} k = \\frac{N(N+1)}{2}\n$$\n运行时寄存器到寄存器移动指令的总数是 $\\frac{N(N+1)}{2}$。", "answer": "$$\n\\boxed{\\frac{N(N+1)}{2}}\n$$", "id": "3653540"}]}