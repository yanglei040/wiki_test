{"hands_on_practices": [{"introduction": "尽管许多编程语言中的数组默认从0开始索引，但更通用的情况是支持任意的起始边界，包括负数。本练习 [@problem_id:3677213] 旨在巩固核心的地址计算公式。通过处理一个具有负数下界的数组，你将实践如何将逻辑索引转换为基于物理内存的偏移量，这是理解编译器如何普适地处理数组访问的关键第一步。", "problem": "在传统的编译器中间表示中，三地址码（3AC）用于将数组引用转换为显式的地址计算，该过程遵循标准的内存模型。考虑一个一维数组 $A$，其下界和上界分别为 $-5$ 和 $5$，记作 $A[-5..5]$。该数组的每个元素占用 $w$ 个字节，并在内存中连续存放。设 $B$ 表示第一个元素 $A[-5]$ 的机器地址。一个高级语言程序在运行时计算索引 $i := t - 2$（其中 $t$ 是一个整型变量），然后引用 $A[i]$。\n\n使用以下基本原则：\n- 一维数组是连续存储的，因此连续元素之间的地址差为元素宽度 $w$。\n- 基地址 $B$ 指向下界索引处的元素，即此处的 $A[-5]$。\n- 为引用 $A[i]$，编译器必须计算下界元素与目标元素之间的元素数量，通过与 $w$ 相乘将该数量转换为字节位移，然后将结果加到 $B$ 上以获得有效地址。\n\n推导三地址码（3AC）序列，该序列通过首先将逻辑索引 $i$ 偏移为从零开始的位移（即，在缩放前加 $+5$）来正确处理负下界，然后计算有效地址。根据该推导，将有效地址计算简化为关于 $B$、$w$ 和 $t$ 的 $A[i]$ 地址 $E$ 的单一封闭形式代数表达式。\n\n仅提供 $E$ 的简化代数表达式作为最终答案。无需进行舍入。", "solution": "所述问题是有效的。这是一个在编译器设计领域内定义明确的问题，具体涉及数组寻址的中间代码生成。所有必要的参数和定义都已提供，问题没有科学上的不准确、矛盾或含糊之处。\n\n任务是推导数组访问的三地址码（$3$AC），然后将基础计算简化为有效内存地址的单一代数表达式。\n\n首先，我们建立计算一维数组中元素地址的基本公式。对于声明为 `Array[low..high]` 的数组，其中 `low` 是索引下界，元素 `Array[i]` 的内存地址由以下公式给出：\n$$\n\\text{Address}(\\text{Array}[i]) = \\text{BaseAddress} + (i - \\text{low}) \\times w\n$$\n其中 `BaseAddress` 是第一个元素 `Array[low]` 的内存地址，而 `$w$` 是数组中每个元素的宽度（以字节为单位）。\n\n在给定问题中，我们有数组 `$A[-5..5]$`。已知条件如下：\n- 下界 `low` $= -5$。\n- 上界 `high` $= 5$。\n- 元素宽度为 `$w$`。\n- 基地址为 `$B$`，定义为第一个元素 `$A[-5]$` 的地址。\n- 索引 `$i$` 在运行时计算为 `$i := t - 2$`，其中 `$t$` 是一个整型变量。\n\n问题要求使用三地址码进行特定的推导。高级操作是计算元素 `$A[i]$` 的有效地址 `$E$`。\n\n计算 `$A[i]$` 的有效地址 `$E$` 的操作序列可以分解为一系列三地址指令。我们使用临时变量 `$t_1, t_2, \\dots$` 来保存中间结果。\n\n1.  首先，根据变量 `$t$` 计算索引 `$i$` 的值。\n    $$t_1 = t - 2$$\n    这里，临时变量 `$t_1$` 保存 `$i$` 的值。\n\n2.  接下来，计算从数组起始位置开始的零基位移。数组从索引 `$-5$` 开始。起始元素（`$A[-5]$`）与目标元素 `$A[i]$`（或 `$A[t_1]$`）之间的元素数量由 `$i - \\text{low} = t_1 - (-5) = t_1 + 5$` 给出。问题陈述明确指出要“在缩放前加 $+5$”。\n    $$t_2 = t_1 + 5$$\n    这里，`$t_2$` 表示元素的零基偏移量，即如果数组从 `$0$` 开始索引，该元素的位置。\n\n3.  然后，这个零基偏移量必须乘以元素宽度 `$w$`，以获得相对于基地址 `$B$` 的字节偏移量。\n    $$t_3 = t_2 \\times w$$\n    这里，`$t_3$` 是从数组开头算起的总字节位移。\n\n4.  最后，将此字节偏移量 `$t_3$` 加到基地址 `$B$` 上，即可得到有效地址 `$E$`。\n    $$E = B + t_3$$\n\n这样就完成了三地址码序列的推导。为了找到 `$E$` 的简化、单一封闭形式的代数表达式，我们对这些中间步骤进行回代。\n\n从 `$E$` 的最终表达式开始：\n$$E = B + t_3$$\n\n代入 `$t_3$` 的表达式：\n$$E = B + (t_2 \\times w)$$\n\n代入 `$t_2$` 的表达式：\n$$E = B + ((t_1 + 5) \\times w)$$\n\n代入 `$t_1$` 的表达式：\n$$E = B + (((t - 2) + 5) \\times w)$$\n\n现在，我们简化括号内的表达式：\n$$E = B + ((t + 3) \\times w)$$\n\n这可以更清晰地写成：\n$$E = B + w(t + 3)$$\n\n这个最终表达式表示了元素 `$A[t-2]$` 的有效地址 `$E$`，以基地址 `$B$`、元素宽度 `$w$` 和运行时变量 `$t$` 表示。该结果通过计算与基地址的正确偏移量，正确地包含了数组的负下界。", "answer": "$$\\boxed{B + w(t + 3)}$$", "id": "3677213"}, {"introduction": "在掌握了基础地址计算之后，我们将处理一个更复杂的场景：嵌套数组访问，例如 $A[B[i]]$。本练习 [@problem_id:3677330] 揭示了在生成中间代码时，正确排序运算步骤的必要性。它强调了计算一个地址（如 $\\[i]$）与从该地址加载一个值（即 $B[i]$ 的值）之间的本质区别，这是生成正确、高效代码的核心。", "problem": "考虑一个在字节寻址机器上对从零开始索引的数组进行标准编译的场景。适用以下基本原则：\n\n- 数组元素的线性地址由公式 $ \\mathrm{addr}(X[k]) = \\mathrm{base}(X) + k \\cdot \\mathrm{size}(X) $ 给出，其中 $ \\mathrm{base}(X) $ 是数组的基地址（以字节为单位），$ k $ 是从零开始的索引，$ \\mathrm{size}(X) $ 是元素的大小（以字节为单位）。\n- 三地址码 (TAC) 是一种中间表示形式，其中每条语句最多有三个操作数，并执行一个操作，例如 $ t := a \\ \\mathrm{op} \\ b $、$ t := \\mathrm{mem}[\\alpha] $ 或 $ \\mathrm{mem}[\\alpha] := t $。TAC 用于对计算进行排序，并显式地对内存加载和存储进行建模。\n\n您需要将嵌套数组引用 $ A[B[i]] $ 转换为三地址码 (TAC)，该代码能够安全地对内层索引和外层地址的计算进行排序，并通过重用临时变量而非重新计算子表达式来最小化内存加载。假设存在以下具体情景，其布局元数据在编译时已知：\n\n- 数组 $A$ 的基地址为 $A_0 = 4096$，元素大小为 $s_A = 8$，长度为 $n_A = 100$。\n- 数组 $B$ 的基地址为 $B_0 = 2048$，元素大小为 $s_B = 4$，长度为 $n_B = 64$。\n- 运行时索引为 $i = 11$。\n- 位置 $B[i]$ 处的内存内容是整数 $17$，即 $B[11] = 17$。\n\n假设边界元数据 $n_A$ 和 $n_B$ 是代码生成器可用的编译时常量，基地址 $A_0$ 和 $B_0$ 也是编译时常量；因此，使用它们不会产生任何内存加载。将内存加载显式地建模为 $t := \\mathrm{mem}[\\alpha]$，其中 $\\alpha$ 是一个计算出的字节地址。\n\n推导出满足以下条件的三地址码：\n- 计算 $B[i]$ 的地址，\n- 加载值 $j = B[i]$ 一次，并将其作为临时变量重用于外层访问，\n- 计算 $A[j]$ 的地址，无需重新加载 $B[i]$ 或重新计算内层地址。\n\n在推导出您的三地址码后，使用提供的数值数据计算外层访问 $\\mathrm{addr}(A[B[i]])$ 的最终字节地址。将最终答案以表示字节地址的单个实数值形式提供。无需四舍五入。在最终的方框输出中，请以不带单位的形式表达最终答案。", "solution": "该问题已经过验证，被认为是有效的。这是一个在编译原理领域内提法明确、有科学依据的问题，具有一套完整且一致的已知条件。将数组引用转换为三地址码并计算最终地址所需的所有数据均已提供。\n\n主要任务是将嵌套数组引用 $A[B[i]]$ 转换为三地址码 (TAC) 指令序列，然后使用提供的数值数据计算最终的内存地址。求值过程必须从最内层的表达式开始，向外进行。\n\n首先，我们必须确定内层索引的值，该值由表达式 $B[i]$ 给出。这包括两个步骤：\n1.  计算元素 $B[i]$ 的内存地址。\n2.  从该内存地址加载值。\n\n元素 $X[k]$ 的地址由公式 $\\mathrm{addr}(X[k]) = \\mathrm{base}(X) + k \\cdot \\mathrm{size}(X)$ 给出。对于内层数组访问 $B[i]$，基地址是 $B_0$，索引是 $i$，元素大小是 $s_B$。因此，$B[i]$ 的地址是：\n$$ \\mathrm{addr}(B[i]) = B_0 + i \\cdot s_B $$\n\n让我们用三地址码来表示这个计算过程。我们使用表示为 $t_n$ 的临时变量来保存中间结果。\n1.  计算字节偏移量：$t_0 := i \\cdot s_B$。\n2.  计算 $B[i]$ 的完整地址：$t_1 := B_0 + t_0$。\n\n在计算出地址并将其存储在 $t_1$ 中之后，下一步是从这个内存位置加载值。这个值将作为外层数组 $A$ 的索引。根据题目建议，我们称这个值为 $j$。\n3.  加载值：$j := \\mathrm{mem}[t_1]$。\n\n现在我们得到了内层索引的值 $j = B[i]$，我们可以继续进行外层数组访问 $A[j]$。该元素的地址由相同的通用公式给出：\n$$ \\mathrm{addr}(A[j]) = A_0 + j \\cdot s_A $$\n\n这个计算过程同样被转换为三地址码，重用了保存 $B[i]$ 值的临时变量 $j$，从而避免了第二次内存加载。\n4.  计算外层数组的偏移量：$t_2 := j \\cdot s_A$。\n5.  计算 $A[B[i]]$ 的最终地址：$t_3 := A_0 + t_2$。\n\n变量 $t_3$ 现在保存着最终的目标字节地址。完整的三地址码序列是：\n1.  $t_0 := i \\cdot s_B$\n2.  $t_1 := B_0 + t_0$\n3.  $j := \\mathrm{mem}[t_1]$\n4.  $t_2 := j \\cdot s_A$\n5.  $t_3 := A_0 + t_2$\n\n现在，我们代入给定的数值来计算最终地址。\n所提供的数据如下：\n- 数组 $A$：基地址 $A_0 = 4096$，元素大小 $s_A = 8$。\n- 数组 $B$：基地址 $B_0 = 2048$，元素大小 $s_B = 4$。\n- 运行时索引：$i = 11$。\n- 内存内容：$B[11]$ 处的值被给出为 $17$。\n\n让我们用这些值来执行三地址码序列。\n\n步骤 1：计算 $B[11]$ 的地址。\n偏移量为 $i \\cdot s_B = 11 \\cdot 4 = 44$。\n地址为 $\\mathrm{addr}(B[11]) = B_0 + 44 = 2048 + 44 = 2092$。\n所以，$t_1 = 2092$。\n\n步骤 2：加载 $B[11]$ 的值。\n题目说明该位置的值是 $17$。\n所以，$j = \\mathrm{mem}[2092] = 17$。\n\n步骤 3：计算 $A[17]$ 的地址。\n我们使用加载的值 $j = 17$ 作为数组 $A$ 的索引。\n偏移量为 $j \\cdot s_A = 17 \\cdot 8 = 136$。\n最终地址为 $\\mathrm{addr}(A[17]) = A_0 + 136 = 4096 + 136 = 4232$。\n\n因此，表达式 $A[B[i]]$ 的最终字节地址是 $4232$。", "answer": "$$\n\\boxed{4232}\n$$", "id": "3677330"}, {"introduction": "最后的练习将挑战升级到多维数组和嵌套循环，这是科学计算与数据处理中的常见模式。此练习 [@problem_id:3677304] 的目标不仅是为多维数组生成正确的地址计算代码，更重要的是学习如何对其进行优化。你将探索循环不变量外提和强度削减等技术，从而揭示编译器是如何通过重构地址计算来显著提升程序性能的。", "problem": "一个三维数组 $B[i][j][k]$ 以行主序存储，这意味着最右边的索引在内存中变化最快。该数组在三个维度上分别具有任意的下界和上界 $[l_1..u_1][l_2..u_2][l_3..u_3]$。每个元素占用 $w$ 个字节。设数组 $B$ 的基地址为 $\\text{base}(B)$。考虑将一个源代码级别的引用 $B[i][j][k]$ 转换为有效地址，此过程使用三地址码 (3AC)，然后在一个嵌套循环的上下文中，通过循环不变量外提来重构 3AC。在该嵌套循环中，$j$ 和 $k$ 在关于 $i$ 的内层循环中保持不变。\n\n任务：\n1. 仅从行主序布局、数组范围以及多维数组的仿射地址计算的定义出发，推导 $B[i][j][k]$ 的有效地址表达式，该表达式用 $\\text{base}(B)$、$i$、$j$、$k$、$l_1$、$l_2$、$l_3$、$u_2$、$u_3$ 和 $w$ 表示。\n2. 生成一个顺序三地址码 (3AC) 序列，用于计算给定三元组 $(i,j,k)$ 的有效地址。\n3. 现在考虑以下完美嵌套循环，其中 $i$ 是最内层循环的索引，而 $j$ 和 $k$ 在内层循环体中是循环不变量：\nFor $k = K_0$ to $K_1$:\n  For $j = J_0$ to $J_1$:\n    For $i = I_0$ to $I_1$:\n      use $B[i][j][k]$\n使用循环不变量外提重构你的 3AC，使得与 $i$ 无关的计算被提升到内层循环之外，并且内层循环使用强度削减和一个归纳变量，以在每次迭代中通过一个常数增量来推进有效地址。\n\n答案规格：\n作为最终答案，提供一个单一的封闭形式解析表达式，表示当 $i$ 移动到 $i+1$ 且 $j$ 和 $k$ 固定时，有效地址的每次迭代增量。该表达式应为 $l_2$、$u_2$、$l_3$、$u_3$ 和 $w$ 的函数。最终的方框答案中不要包含任何单位。如果你选择使用范围 $n_2 = u_2 - l_2 + 1$ 和 $n_3 = u_3 - l_3 + 1$ 进行简化，请确保你的最终表达式仅依赖于 $l_2$、$u_2$、$l_3$、$u_3$ 和 $w$。不需要进行舍入。", "solution": "该问题要求推导和优化三维数组元素 $B[i][j][k]$ 的地址计算。该数组定义了下界和上界 $[l_1..u_1]$、$[l_2..u_2]$ 和 $[l_3..u_3]$，并以行主序存储。每个元素占用 $w$ 个字节。\n\n### 第1步：有效地址公式的推导\n在行主序存储方案中，最右边的索引变化最快。为了计算元素 $B[i][j][k]$ 的地址，我们确定其相对于基地址 $\\text{base}(B)$ 的偏移量，基地址是第一个元素 $B[l_1][l_2][l_3]$ 的地址。偏移量是位于 $B[i][j][k]$ 之前的元素数量与元素大小 $w$ 的乘积。\n\n首先，我们定义每个维度的范围（extent），即元素数量：\n- 第1个维度（$i$）的范围：$n_1 = u_1 - l_1 + 1$\n- 第2个维度（$j$）的范围：$n_2 = u_2 - l_2 + 1$\n- 第3个维度（$k$）的范围：$n_3 = u_3 - l_3 + 1$\n\n在线性内存布局中，位于 $B[i][j][k]$ 之前的元素总数是通过考虑每个索引相对于其下界的贡献来计算的：\n1.  来自第一个索引 $i$ 的贡献：数组由 $n_1$ 个二维“平面”组成，每个平面的大小为 $n_2 \\times n_3$。要到达索引 $i$ 对应的平面，需要跳过的完整平面数量是 $(i - l_1)$。这部分贡献了 $(i - l_1) \\times n_2 \\times n_3$ 个元素。\n2.  来自第二个索引 $j$ 的贡献：在第 $i$ 个平面内，数据被组织成 $n_2$ 个“行”，每行大小为 $n_3$。要到达索引 $j$ 对应的行，需要跳过的完整行数是 $(j - l_2)$。这部分额外贡献了 $(j - l_2) \\times n_3$ 个元素。\n3.  来自第三个索引 $k$ 的贡献：在第 $i$ 个平面的第 $j$ 行内，要到达索引 $k$ 处的元素，需要跳过的元素数量是 $(k - l_3)$。\n\n位于 $B[i][j][k]$ 之前的元素总数是这些贡献的总和：\n$$ \\text{offset\\_in\\_elements} = (i - l_1) n_2 n_3 + (j - l_2) n_3 + (k - l_3) $$\n字节偏移量是此数量乘以元素大小 $w$。因此，$B[i][j][k]$ 的有效地址是：\n$$ \\text{addr}(B[i][j][k]) = \\text{base}(B) + w \\times \\left[ (i - l_1) n_2 n_3 + (j - l_2) n_3 + (k - l_3) \\right] $$\n代入 $n_2$ 和 $n_3$ 的定义，我们得到所需的表达式：\n$$ \\text{addr}(B[i][j][k]) = \\text{base}(B) + w \\left[ (i - l_1)(u_2 - l_2 + 1)(u_3 - l_3 + 1) + (j - l_2)(u_3 - l_3 + 1) + (k - l_3) \\right] $$\n\n### 第2步：三地址码 (3AC) 序列\n上述公式可以转换为一个顺序的三地址码指令序列。我们记 $n_2 = u_2 - l_2 + 1$ 和 $n_3 = u_3 - l_3 + 1$。3AC 如下：\n$$ t_1 = i - l_1 $$\n$$ t_2 = t_1 \\times n_2 $$\n$$ t_3 = t_2 \\times n_3 $$\n$$ t_4 = j - l_2 $$\n$$ t_5 = t_4 \\times n_3 $$\n$$ t_6 = k - l_3 $$\n$$ t_7 = t_3 + t_5 $$\n$$ t_8 = t_7 + t_6 $$\n$$ t_9 = w \\times t_8 $$\n$$ \\text{addr} = \\text{base}(B) + t_9 $$\n\n### 第3步：为循环优化和增量计算进行重构\n题目指定了一个嵌套循环结构，其中最内层循环对 $i$ 进行迭代，而 $j$ 和 $k$ 保持不变。\n$$\n\\text{For } k = K_0 \\text{ to } K_1: \\\\\n\\quad \\text{For } j = J_0 \\text{ to } J_1: \\\\\n\\quad\\quad \\text{For } i = I_0 \\text{ to } I_1: \\\\\n\\quad\\quad\\quad \\text{use } B[i][j][k]\n$$\n为了优化 $i$-循环内的地址计算，我们应用循环不变量外提。我们重新排列地址公式，以分离依赖于 $i$ 的项和不依赖于 $i$ 的项。\n$$ \\text{addr}(B[i][j][k]) = \\text{base}(B) + w(i \\cdot n_2 n_3 - l_1 n_2 n_3) + w((j - l_2) n_3) + w(k - l_3) $$\n$$ \\text{addr}(B[i][j][k]) = \\left[ \\text{base}(B) - w \\cdot l_1 n_2 n_3 + w \\cdot (j - l_2) n_3 + w \\cdot (k - l_3) \\right] + i \\cdot (w \\cdot n_2 n_3) $$\n该表达式具有 $C_{j,k} + i \\cdot S_i$ 的形式，其中：\n- $C_{j,k} = \\text{base}(B) - w l_1 n_2 n_3 + w (j - l_2) n_3 + w (k - l_3)$ 是相对于 $i$-循环的循环不变量部分。\n- $S_i = w n_2 n_3$ 是步长（stride），或 $i$ 所乘的常数因子。\n\n$C_{j,k}$ 和 $S_i$ 的计算可以被提升到 $i$-循环之外。循环内部的地址计算 $C_{j,k} + i \\cdot S_i$ 是强度削减的候选对象。我们可以维护一个归纳变量（比如 $p$）来保存当前地址，而不是在每次迭代中都进行一次乘法。在循环开始前，$p$ 被初始化为第一个元素 $B[I_0][j][k]$ 的地址。在每次迭代中，$p$ 通过加上一个常数增量来更新，以获得下一个元素 $B[i+1][j][k]$ 的地址。\n\n每次迭代的增量是当 $i$ 增加 1 时地址的差值：\n$$ \\text{Increment} = \\text{addr}(B[i+1][j][k]) - \\text{addr}(B[i][j][k]) $$\n使用优化后的形式 $C_{j,k} + i \\cdot S_i$：\n$$ \\text{Increment} = [C_{j,k} + (i+1) \\cdot S_i] - [C_{j,k} + i \\cdot S_i] $$\n$$ \\text{Increment} = (C_{j,k} + i \\cdot S_i + S_i) - (C_{j,k} + i \\cdot S_i) = S_i $$\n因此，增量就是步长 $S_i = w n_2 n_3$。这个常数代表了数组一个完整的 $(j,k)$ 平面的内存大小。\n\n最后一步是用问题陈述中指定的变量 $l_2$、$u_2$、$l_3$、$u_3$ 和 $w$ 来表示这个增量。我们代入 $n_2$ 和 $n_3$ 的表达式：\n$$ \\text{Increment} = w \\times (u_2 - l_2 + 1) \\times (u_3 - l_3 + 1) $$\n这就是内层循环每次迭代中加到地址归纳变量上的常数值的封闭形式解析表达式。", "answer": "$$\n\\boxed{w (u_2 - l_2 + 1) (u_3 - l_3 + 1)}\n$$", "id": "3677304"}]}