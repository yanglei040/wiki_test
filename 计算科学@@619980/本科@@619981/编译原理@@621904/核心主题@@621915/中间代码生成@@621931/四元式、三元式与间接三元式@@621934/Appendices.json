{"hands_on_practices": [{"introduction": "将源代码翻译成中间表示需要绝对忠实于语言的语义。本练习挑战你对一个带有后自增运算符（$k++$）和特定求值顺序规则的语句进行建模，展示了如何通过仔细设计三元式序列来避免那些细微但致命的“差一错误”。[@problem_id:3665519]", "problem": "考虑一个简单的命令式语言，它包含数组和后增量运算符。表达式 $k++$ 的值为 $k$ 的原始值，并且作为一个副作用，在产生该值后立即将 $k$ 增加 $1$。赋值运算符在计算其右侧之前先计算其左侧（包括任何索引计算和副作用），然后执行存储操作。中间代码使用三地址风格的操作 $load(arr, i)$ 来读取 $arr$ 中索引为 $i$ 的元素，以及 $store(arr, i, v)$ 来将值 $v$ 写入 $arr$ 中索引为 $i$ 的位置。\n\n回顾核心定义：\n- 四元式是一个四元组 $(op, arg_1, arg_2, result)$，其中有一个显式名称 $result$ 用于存放操作的输出。\n- 三元式是一个三元组 $(op, arg_1, arg_2)$，其结果是未命名的，并通过该三元式在序列中的位置（索引）来隐式标识。如果第 $n$ 个三元式是 $(op, arg_1, arg_2)$，其结果可以被后面的三元式引用为 $(n)$。\n- 间接三元式表示法引入了一个指针表 $P$，其中 $P[i]$ 指向要执行的第 $i$ 个三元式。对先前结果的使用仍然引用三元式索引（例如 $(n)$），但通过更改 $P$ 而不是重新编号三元式来实现重排序。\n\n要求您使用三元式对单个语句 $arr[k++] = arr[k] + 1$ 进行建模，以满足以下条件：\n- 左侧索引使用 $k++$ 作为值产生的 $k$ 的原始值。\n- 右侧使用后增量副作用发生后更新的 $k$ 值。\n- 该表示法在后续三元式通过索引引用早期计算时避免了差一错误，并且在转换为间接三元式时保持语义正确（因此通过指针表 $P$ 进行的局部重排序不会改变所引用的具体三元式结果）。\n\n假设三元式遵循以下约定：\n- 三元式 $(copy, x, -)$ 返回变量 $x$ 的当前值作为其结果，而不改变 $x$。\n- 三元式 $(+, x, c)$ 返回 $x$ 与常量 $c$ 的和。\n- 三元式 $(assign, x, y)$ 将值 $y$ 赋给变量 $x$，并返回所赋的值作为其结果。\n- 三元式 $(load, arr, i)$ 返回 $load(arr, i)$ 的值。\n- 三元式 $(store, arr@i, v)$ 表示 $store(arr, i, v)$ 的副作用，并可能返回一个未使用的未定义占位符。\n- 三元式 $(postinc, x, -)$ 返回 $x$ 的原始值，然后作为副作用将 $x$ 增加 $1$。\n\n在所述语义下，哪个选项能正确地用三元式表示 $arr[k++] = arr[k] + 1$，避免因位置引用导致的差一错误，并在转换为间接三元式时保持稳定？\n\nA. 使用单个后增量三元式，并为两侧重用其结果：\n- $0$: $(postinc, k, -)$\n- $1$: $(load, arr, (0))$\n- $2$: $(+, (1), 1)$\n- $3$: $(store, arr@(0), (2))$\n\nB. 为左侧快照原始的 $k$，然后增加 $k$，接着使用更新后的 $k$ 读取右侧，最后使用快照进行存储：\n- $0$: $(copy, k, -)$\n- $1$: $(+, k, 1)$\n- $2$: $(assign, k, (1))$\n- $3$: $(load, arr, (2))$\n- $4$: $(+, (3), 1)$\n- $5$: $(store, arr@(0), (4))$\n\nC. 首先使用当前的 $k$ 计算右侧，然后增加 $k$，接着使用（可能已改变的）$k$ 进行存储：\n- $0$: $(load, arr, k)$\n- $1$: $(+, (0), 1)$\n- $2$: $(store, arr@k, (1))$\n- $3$: $(postinc, k, -)$\n\nD. 使用间接三元式指针表 $P$ 来证明为两侧使用相同快照是合理的，理由是重排序可以稍后处理：\n- 三元式：\n  - $0$: $(copy, k, -)$\n  - $1$: $(+, k, 1)$\n  - $2$: $(assign, k, (1))$\n  - $3$: $(load, arr, (0))$\n  - $4$: $(+, (3), 1)$\n  - $5$: $(store, arr@(0), (4))$\n- 指针表 $P$：$P[0]=0$, $P[1]=1$, $P[2]=2$, $P[3]=3$, $P[4]=4$, $P[5]=5$\n\n选择正确的选项。", "solution": "首先将验证用户提供的问题陈述的科学性和逻辑完整性。\n\n### 步骤1：提取已知条件\n- **语言和语句**：一种命令式语言，待编译的语句为 `$arr[k++] = arr[k] + 1$`。\n- **运算符语义**：\n    - 后增量 `$k++$`：其值为 `$k$` 的当前值，然后立即将 `$k$` 增加 `$1`。\n    - 赋值 `$LHS = RHS$`：\n        1. 计算左侧（`$LHS$`），包括所有索引计算和副作用。\n        2. 计算右侧（`$RHS$`）。\n        3. 执行存储操作（将 `$RHS$` 的结果赋给由 `$LHS$` 决定的位置）。\n- **中间表示（IR）**：三元式，形式为 `$(op, arg_1, arg_2)$` 的三元组。第 $n$ 个三元式的结果被隐式引用为 `$(n)`。\n- **间接三元式**：一种扩展，其中指针表 `$P$` 决定执行顺序，但引用 `$(n)` 仍然指向静态列表中的第 $n$ 个三元式。\n- **语义约束**：表示必须对于给定的语义是正确的，避免位置引用错误，并且对于转换为间接三元式是稳定的。\n- **三元式定义**：\n    - `$(copy, x, -)$`：返回变量 `$x$` 的值。\n    - `$(+, x, c)$`：返回 `$x + c$`。\n    - `$(assign, x, y)$`：将 `$y$` 赋给 `$x$`，返回 `$y$`。\n    - `$(load, arr, i)`：返回 `$arr[i]` 的内容。\n    - `$(store, arr@i, v)`：将值 `$v$` 存入 `$arr[i]`。\n    - `$(postinc, x, -)$`：返回 `$x$` 的原始值，然后将 `$x$` 增加 `$1`。\n\n### 步骤2：使用提取的已知条件进行验证\n问题陈述定义明确，并基于编译器构造的原理，特别是中间代码生成。源语言语句、运算符和目标三元式表示的语义都定义得足够精确，可以进行严格的推导。\n\n让我们根据提供的规则解构语句 `$arr[k++] = arr[k] + 1$`。设 `$k_{orig}$` 为语句执行前 `$k$` 的值。\n\n1.  **计算 LHS**：`$LHS$` 是 `$arr[k++]$`。这涉及到计算用于存储的内存地址。\n    - 计算索引表达式 `$k++$`。\n    - 根据其定义，它产生值 `$k_{orig}$`。这个值将成为存储操作的有效索引。\n    - 紧接着，副作用发生：`$k$` 被增加。`$k$` 的新值为 `$k_{orig} + 1$`。\n    - 在 `$LHS$` 计算结束时，目标地址由索引 `$k_{orig}$` 确定，并且程序状态已更新为 `$k = k_{orig} + 1$`。\n\n2.  **计算 RHS**：`$RHS$` 是 `$arr[k] + 1$`。这是在 `$LHS$` *之后* 计算的。\n    - 此处使用的 `$k$` 的值是其当前值，即 `$k_{orig} + 1$`。\n    - 表达式 `$arr[k]$` 被计算，这意味着 `$(load, arr, k_{orig} + 1)$`。\n    - 然后将值 `$1$` 加到加载结果上。\n\n3.  **执行存储**：将 `$RHS$` 计算的结果存储在 `$LHS$` 计算期间计算出的位置。\n    - 最终操作是 `$(store, arr, k_{orig}, \\text{RHS 的结果})$`。\n\n综合这些步骤，该语句在语义上等同于：`store(arr, k_orig, load(arr, k_orig + 1) + 1)`。\n\n该问题具有科学依据，提法明确且客观。没有发现使其无效的缺陷。\n\n### 步骤3：结论与行动\n问题是**有效的**。继续进行解答。\n\n### 正确三元式表示的推导\n一个正确的三元式序列必须实现以下逻辑：`store(arr, k_orig, load(arr, k_orig + 1) + 1)`。这需要：\n1.  捕获 `$k$` 的原始值 `$k_{orig}$`，用于最终的存储索引。\n2.  将 `$k$` 增加到 `$k_{orig} + 1$`。\n3.  使用 `$k$` 的新值从 `$arr$` 执行加载操作。\n4.  计算要存储的最终值。\n5.  使用保存的 `$k$` 的原始值执行存储操作。\n\n在三元式中表示这一点的最稳健方法，特别是考虑到对间接三元式的稳定性要求，是尽可能使用位置引用 `$(n)$` 来明确所有数据依赖关系。\n\n让我们构建这个序列：\n1.  保存 `$k$` 的原始值。\n    - `$(copy, k, -)$`。这产生 `$k_{orig}$`。设为三元式 `$(0)`。\n2.  增加 `$k$`。这可以分两步完成。\n    - `$(+, k, 1)`。这计算 `$k_{orig} + 1$`。设为三元式 `$(1)`。\n    - `$(assign, k, (1))`。这将 `$k$` 更新为新值。这个三元式（设为 `$(2)`）的结果也是新值 `$k_{orig} + 1$`。\n3.  计算 `$RHS$`。\n    - `$(load, arr, (2))`。我们使用增量操作的显式结果 `$(2)`` 作为索引。这得到 `$arr[k_{orig} + 1]$`。设为三元式 `$(3)`。\n    - `$(+, (3), 1)`。这计算 `$arr[k_{orig} + 1] + 1$`。设为三元式 `$(4)`。\n4.  执行存储。\n    - `$(store, arr@(0), (4))`。这使用从 `$(0)`` 保存的 `$k$` 的原始值作为索引，并使用从 `$(4)`` 计算的 `$RHS$` 值作为要存储的值。\n\n这个序列正确且稳健地实现了所需的语义。\n\n### 逐个选项分析\n\n**A. 使用单个后增量三元式，并为两侧重用其结果：**\n- `$0$: $(postinc, k, -)$` — 结果 `$(0)`` 是 `$k_{orig}$`。副作用：`$k$` 变为 `$k_{orig} + 1$`。\n- `$1$: $(load, arr, (0))$` — 这从索引 `$(0)``（即 `$k_{orig}$`）处加载 `$arr`。这是不正确的。`$RHS$` 的加载必须使用*更新后*的 `$k$` 值，即 `$k_{orig} + 1$`。\n- `$2$: $(+, (1), 1)$`\n- `$3$: $(store, arr@(0), (2))$`\n这个序列计算的是 `$arr[k_{orig}] = arr[k_{orig}] + 1$`。这在语义上是不正确的。\n**结论：不正确**\n\n**B. 为左侧快照原始的 $k$，然后增加 $k$，接着使用更新后的 $k$ 读取右侧，最后使用快照进行存储：**\n- `$0$: $(copy, k, -)$` — 结果 `$(0)`` 是 `$k_{orig}$`。这保存了 `$LHS$` 的索引。\n- `$1$: $(+, k, 1)$` — 结果 `$(1)`` 是 `$k_{orig} + 1$`。\n- `$2$: $(assign, k, (1))$` — `$k$` 更新为 `$k_{orig} + 1$`。结果 `$(2)`` 是 `$k_{orig} + 1$`。这完成了 `$k++$` 的副作用。\n- `$3$: $(load, arr, (2))$` — 这从索引 `$(2)``（即 `$k_{orig} + 1$`）处加载 `$arr`。这正确地计算了 `$RHS$` 的 `$arr[k]$`。\n- `$4$: $(+, (3), 1)`` — 这计算了最终的 `$RHS$` 值。\n- `$5$: $(store, arr@(0), (4))` — 这将 `$RHS$` 的值 `$(4)`` 存储在索引 `$(0)`` 处，即 `$k_{orig}$`。\n这个序列与推导出的正确实现完全匹配。它正确地区分了用于 `$LHS$` 索引的 `$k$` 值和用于 `$RHS$` 访问的 `$k$` 值。使用显式的位置引用使数据流清晰而稳健。\n**结论：正确**\n\n**C. 首先使用当前的 $k$ 计算右侧，然后增加 $k$，接着使用（可能已改变的）$k$ 进行存储：**\n- `$0$: $(load, arr, k)$` — 开始时，`$k = k_{orig}$`。所以这加载了 `$arr[k_{orig}]$`。\n- `$1$: $(+, (0), 1)$` — 计算 `$arr[k_{orig}] + 1$`。\n- `$2$: $(store, arr@k, (1))$` — 将此值存回 `$arr[k_{orig}]$`。\n- `$3$: $(postinc, k, -)$` — 在赋值完成后增加 `$k$`。\n这个序列计算的是 `$arr[k] = arr[k] + 1; k++;`。计算顺序完全违反了问题的规范，其中 `$LHS$` 上的 `$k++$` 的副作用必须在 `$RHS$` 计算之前发生。\n**结论：不正确**\n\n**D. 使用间接三元式指针表 P 来证明为两侧使用相同快照是合理的，理由是重排序可以稍后处理：**\n这个选项提出了一个有缺陷的理由。语句 `$arr[k++] = arr[k] + 1$` 从根本上需要两个不同的 `$k$` 值：用于 `$LHS$` 索引的原始值和用于 `$RHS$` 索引的增量值。不能“为两侧使用相同的快照”。间接三元式是一种在保留数据依赖关系的同时重排序指令的优化技术；它们不能改变源代码的基本语义。所提供的理由在科学上是不成立的。\n尽管此选项中列出的三元式序列与选项 B 中的正确序列相同，但必须根据其全部内容（包括文本理由）来评估整个选项。该理由是错误的，使得整个选项成为一个干扰项，它助长了对问题语义和间接三元式功能的误解。\n**结论：不正确**", "answer": "$$\\boxed{B}$$", "id": "3665519"}, {"introduction": "除了正确性之外，编译器的目标是生成高效的代码。本练习通过比较同一表达式的刚性四元式调度和灵活的三元式调度，探讨了中间表示的结构如何直接影响性能。你将通过计算寄存器溢出成本的减少量，来量化智能指令调度的优势。[@problem_id:3665545]", "problem": "考虑在 $R=3$ 个通用寄存器的约束下，为表达式 $E=(a+b)+(c+d)+(e+f)$ 生成中间代码的策略。在编译器使用的经典中间表示中，四元式通过显式命名的临时变量（例如，$t_1=a+b$）来编码每个操作，而三元式使用位置索引，因此结果通过其操作索引来引用，而无需引入新名称。间接三元式通过一个指向三元式的索引表进一步允许重排，从而实现灵活的调度而无需重命名。\n\n假设以下基础模型：\n- 机器提供 $R=3$ 个寄存器，可用于存放操作数和临时变量。\n- 一次二元加法运算需要两个寄存器操作数，并将其结果放入其中一个寄存器中（也就是说，结果可以覆盖其中一个操作数寄存器）。\n- 一个临时值在其最后一次使用前被认为是活跃的；如果所需的活跃临时变量数量超过可用寄存器数量，则必须将一些值存储（溢出）到内存中，并随后重新加载。\n- 将溢出的临时变量存储到内存的成本为 $\\sigma$（抽象周期），而从内存中重新加载溢出的临时变量的成本为 $\\lambda$（抽象周期）。\n- 所有基本变量 $a,b,c,d,e,f$ 最初都驻留在内存中，使用前必须加载；但是，这些初始加载不计入溢出成本。只有因寄存器压力（临时变量溢出）而发生的存储和重新加载才计入溢出成本。\n\n在这些假设下，比较两种调度策略引起的溢出成本：\n1. 一种基于四元式的调度，它按照程序顺序计算显式临时变量，即 $t_1=a+b$，$t_2=c+d$，$t_3=e+f$，然后是 $E=t_1+t_2+t_3$，并且在这些四元式边界之间不进行重排。\n2. 一种三元式（或间接三元式）调度，它通过在计算下一对之前，在生成每对和之后立即应用成对累加，来最小化同时活跃的临时变量的最大数量，并受限于相同的 $R=3$ 约束和相同的加法语义。\n\n从活跃性和寄存器压力的第一性原理出发，推导每种策略的最小溢出成本，并将差值（四元式溢出成本减去三元式溢出成本）表示为关于 $\\lambda$ 和 $\\sigma$ 的单个封闭形式解析表达式。不需要四舍五入。你的最终答案必须是这个单一表达式。", "solution": "该问题要求在 $R=3$ 个通用寄存器的约束下，对表达式 $E=(a+b)+(c+d)+(e+f)$ 的两种不同中间代码生成和调度策略的溢出成本进行比较分析。将临时变量溢出到内存的成本为 $\\sigma$，重新加载的成本为 $\\lambda$。\n\n我们将通过追踪寄存器使用情况和临时变量的活跃性，从第一性原理出发分析每种策略。一个临时变量从其创建到最后一次使用期间都是活跃的。如果在任何时候所需的寄存器数量超过可用寄存器数量 $R$，就会发生溢出。在给定步骤中所需的寄存器数量是持有当前活跃临时变量所需的寄存器数量与为当前计算持有操作数所需的寄存器数量之和。机器模型规定，二元加法 `op R_dest, R_src` 使用两个寄存器操作数，并用结果覆盖其中一个。从内存加载变量到寄存器是一个 `LOAD` 操作。\n\n**策略1分析：基于四元式的调度**\n\n该策略遵循严格的四元式程序顺序，我们可以将其表示为一系列赋值：\n$1.$ $t_1 = a+b$\n$2.$ $t_2 = c+d$\n$3.$ $t_3 = e+f$\n$4.$ $t_4 = t_1+t_2$\n$5.$ $E = t_4+t_3$\n\n我们来追踪寄存器分配和活跃性。我们将寄存器表示为 $R_1$, $R_2$, $R_3$。\n\n- **步骤1：计算 $t_1 = a+b$**\n  - `LOAD R1, a`\n  - `LOAD R2, b`\n  - `ADD R1, R2` (结果 $t_1$ 现在位于 $R_1$ 中)\n  - 在此步骤结束时，临时变量 $t_1$ 是活跃的，因为它在步骤4中需要被使用。它被保存在 $R_1$ 中。活跃临时变量集合为 {$t_1$}。我们有2个空闲寄存器 ($R_2$, $R_3$)。\n\n- **步骤2：计算 $t_2 = c+d$**\n  - $t_1$ 是活跃的，并占用 $R_1$。我们使用空闲寄存器 $R_2$ 和 $R_3$。\n  - `LOAD R2, c`\n  - `LOAD R3, d`\n  - `ADD R2, R3` (结果 $t_2$ 现在位于 $R_2$ 中)\n  - 在此步骤结束时，$t_1$ 和 $t_2$ 都是活跃的。它们分别保存在 $R_1$ 和 $R_2$ 中。活跃临时变量集合为 {$t_1, t_2$}。我们有1个空闲寄存器 ($R_3$)。\n\n- **步骤3：计算 $t_3 = e+f$**\n  - 此时，$t_1$ (在 $R_1$ 中) 和 $t_2$ (在 $R_2$ 中) 是活跃的。我们需要计算 $t_3=e+f$，这需要在加法前将两个操作数 $e$ 和 $f$ 加载到寄存器中。这需要2个空闲寄存器。然而，我们只有1个空闲寄存器 $R_3$。\n  - 同时需要的总寄存器数量是 $2$ (用于保存活跃临时变量 $t_1, t_2$) 加上 $2$ (用于加载操作数 $e, f$)，总共需要4个寄存器。\n  - 由于我们只有 $R=3$ 个寄存器，我们面临寄存器压力，溢出是不可避免的。我们必须将一个活跃临时变量存储到内存中以释放一个寄存器。我们选择溢出 $t_1$。\n  - `STORE mem_t1, R1` (产生开销：$\\sigma$)。这释放了 $R_1$。\n  - 现在，我们可以继续计算 $t_3$。$R_2$ 保存着 $t_2$。$R_1$ 和 $R_3$ 是空闲的。\n  - `LOAD R1, e`\n  - `LOAD R3, f`\n  - `ADD R1, R3` (结果 $t_3$ 现在位于 $R_1$ 中)\n  - 在此步骤结束时，活跃临时变量集合为 {$t_1, t_2, t_3$}。$t_2$ 在 $R_2$ 中，$t_3$ 在 $R_1$ 中，$t_1$ 在内存中。\n\n- **步骤4：计算 $t_4 = t_1+t_2$**\n  - 操作数是 $t_1$ 和 $t_2$。$t_2$ 在 $R_2$ 中。$t_1$ 在内存中，必须重新加载。我们有一个空闲寄存器 $R_3$。\n  - `LOAD R3, mem_t1` (产生开销：$\\lambda$)。现在 $t_1$ 在 $R_3$ 中。\n  - `ADD R2, R3` (结果 $t_4=t_1+t_2$ 现在位于 $R_2$ 中)。\n  - 在此步骤结束时，临时变量 $t_1$ 和 $t_2$ 不再活跃。新的临时变量 $t_4$ 是活跃的，并且来自步骤3的 $t_3$ 也仍然是活跃的。它们分别保存在 $R_2$ 和 $R_1$ 中。\n\n- **步骤5：计算 $E = t_4+t_3$**\n  - 操作数是 $t_4$ (在 $R_2$ 中) 和 $t_3$ (在 $R_1$ 中)。两者都在寄存器中。\n  - `ADD R1, R2` (最终结果 $E$ 在 $R_1$ 中)。\n  - 不需要进一步的溢出或重新加载。\n\n策略1的总溢出成本是一次溢出和一次重新加载的成本之和。\n$C_1 = \\sigma + \\lambda$。\n\n**策略2分析：基于三元式/间接三元式的调度**\n\n该策略允许重排操作以最小化寄存器压力。“在生成每对和之后立即应用成对累加”这句话意味着一种计算顺序，即中间结果一旦不再作为其他待处理计算的操作数时就立即被消耗。这对应于表达式树 $E=((a+b)+(c+d))+(e+f)$ 的最优求值。操作顺序是：\n$1.$ $t_1 = a+b$\n$2.$ $t_2 = c+d$\n$3.$ $t_3 = t_1+t_2$\n$4.$ $t_4 = e+f$\n$5.$ $E = t_3+t_4$\n\n我们来追踪这个最优顺序的寄存器需求。\n\n- **步骤1：计算 $t_1 = a+b$**\n  - `LOAD R1, a`; `LOAD R2, b`; `ADD R1, R2`。 \n  - 结果 $t_1$ 在 $R_1$ 中。此步骤中使用的最大寄存器数为2。\n  - 活跃临时变量：{$t_1$}。持有临时变量的寄存器数：1。\n\n- **步骤2：计算 $t_2 = c+d$**\n  - $t_1$ 是活跃的并保存在 $R_1$ 中。我们需要加载 $c$ 和 $d$。我们可以使用空闲寄存器 $R_2$ 和 $R_3$。\n  - `LOAD R2, c`; `LOAD R3, d`。\n  - 此时，我们需要1个寄存器用于活跃临时变量 $t_1$，2个寄存器用于操作数 $c$ 和 $d$。总需求为 $1+2=3$ 个寄存器。由于 $R=3$，这可以在不发生溢出的情况下完成。\n  - `ADD R2, R3`。结果 $t_2$ 在 $R_2$ 中。\n  - 活跃临时变量：{$t_1, t_2$}。持有临时变量的寄存器数：2个 ($R_1$ 和 $R_2$)。\n\n- **步骤3：计算 $t_3 = t_1+t_2$**\n  - 操作数 $t_1$ 和 $t_2$ 已经分别在寄存器 $R_1$ 和 $R_2$ 中。\n  - `ADD R1, R2`。结果 $t_3$ 在 $R_1$ 中。\n  - 此操作后，$t_1$ 和 $t_2$ 不再活跃。它们唯一的用途是计算 $t_3$。\n  - 活跃临时变量：{$t_3$}。持有临时变量的寄存器数：1个 ($R_1$)。活跃临时变量的最大数量从2减少到1。\n\n- **步骤4：计算 $t_4 = e+f$**\n  - $t_3$ 是活跃的并保存在 $R_1$ 中。我们需要加载 $e$ 和 $f$。我们可以使用空闲寄存器 $R_2$ 和 $R_3$。\n  - `LOAD R2, e`; `LOAD R3, f`。\n  - 所需总寄存器数再次为 $1$ (用于 $t_3$) + $2$ (用于 $e, f$) = $3$。由于 $R=3$，这是可以的。\n  - `ADD R2, R3`。结果 $t_4$ 在 $R_2$ 中。\n  - 活跃临时变量：{$t_3, t_4$}。持有临时变量的寄存器数：2个 ($R_1$ 和 $R_2$)。\n\n- **步骤5：计算 $E = t_3+t_4$**\n  - 操作数 $t_3$ 和 $t_4$ 在寄存器 $R_1$ 和 $R_2$ 中。\n  - `ADD R1, R2`。结果 $E$ 在 $R_1$ 中。\n  - 此步骤后没有活跃的临时变量。\n\n在整个优化求值过程中，任何时候所需的最大寄存器数量都是3。由于我们有 $R=3$ 个可用寄存器，因此不需要溢出。\n所以，策略2的溢出成本为 $C_2 = 0$。\n\n**溢出成本差异**\n\n问题要求计算四元式溢出成本与三元式溢出成本之间的差值。\n差值 = $C_1 - C_2 = (\\sigma + \\lambda) - 0 = \\sigma + \\lambda$。\n这个差异的产生是因为刚性的四元式调度导致了一个高寄存器压力的点（需要3个活跃的临时变量），而通过三元式/间接三元式实现的灵活调度避免了这一点。", "answer": "$$\n\\boxed{\\sigma + \\lambda}\n$$", "id": "3665545"}, {"introduction": "高效的优化依赖于精确的数据流分析，而中间表示的选择可以促进这种分析。本问题要求你考虑一个常见的优化权衡：是保留一个已计算的值，还是稍后重新计算它。你将分析四元式和三元式如何揭示必要的“定义-使用”信息，以判断在操作数被修改后重新计算是否语义有效。[@problem_id:3665528]", "problem": "考虑一个直线代码片段，它首先计算一个表达式，然后重新定义其操作数之一：首先执行 $x := y + z$，然后执行 $y := 1$，之后有一个对 $x$ 的使用。假设一个典型的编译器后端必须针对寄存器稀缺的机器。因此，它有两种通用选择来使其后的使用点能够获得 $x$ 的值：要么在 $y$ 被重新定义后保留 $x$ 的值（通过将 $x$ 保存在寄存器中，或通过溢出和重载），要么尝试在使用点重新计算 $x$ 的值。\n\n仅使用中间代码表示——四元式、三元式和间接三元式的核心定义，以及数据流概念——定值-使用链和到达定值的标准概念，论证在使用点进行重新计算在语义上是否有效，以及每种表示如何暴露必要的信息。\n\n对于本问题，采用以下经过充分检验的事实作为基础：\n- 在四元式中，一条中间指令表示为一个元组 $(\\mathrm{op}, \\mathrm{arg1}, \\mathrm{arg2}, \\mathrm{result})$，其中计算在 $\\mathrm{result}$ 中产生一个命名的临时变量。\n- 在三元式中，每条中间指令的结果是未命名的，并通过其位置索引来引用；后续指令使用索引来引用早前的结果。\n- 在间接三元式中，一个额外的间接层（一个指针表）将稳定引用映射到三元式条目，以允许在不改变操作数中使用的索引的情况下进行代码移动。\n- 一个定值 $d$ 的定值-使用（def-use）链是从 $d$ 可达且中间没有对被定义名称进行重新定义的使用的集合，而到达定值分析为每个程序点和名称确定哪些定值可以到达该点。\n- 一个值可以在后续点被安全地重新计算，当且仅当该重新计算所使用的操作数值与所考虑的执行路径上原始计算时的值相等；等价地，重新计算必须依赖于所有操作数的相同到达定值，或者这些操作数值本身可以从它们自己的到达定值中重新物化。\n\n基于这些原则，关于在代码片段 $x := y + z$；$y := 1$；使用 $x$ 中，通过三种表示中的def-use链检测后续对 $x$ 的使用是可以通过重新计算处理还是必须通过保留处理，以下哪些陈述是正确的？\n\nA. 在四元式中，def-use链显示 $x$ 的定值在 $x := y + z$ 点依赖于 $y$ 和 $z$。因为中间有对 $y$ 的重新定义，在后续使用点将 $x$ 重新计算为 $y + z$ 通常会产生一个不同的值；因此，除非 $y$ 的早期值（或 $x$ 本身）被保留，否则在使用点进行重新计算在语义上是无效的。\n\nB. 在三元式中，因为后续使用可以直接引用形成 $y + z$ 的计算的索引，所以即使在 $y$ 被重新定义后，编译器也总能在使用点重新物化 $x$ 的原始值，因此保留是不必要的。\n\nC. 对于三元式和间接三元式，来自计算 $y + z$ 的节点的操作数链接标识了该值所依赖的 $y$ 和 $z$ 的特定到达定值；因此，只有当那些到达定值的值仍然可用或其本身可以被重新物化时，在后续使用点进行重新计算才是有效的。对 $y$ 的重新定义而未保留其早期值会阻止正确的重新计算，正如在四元式中一样。\n\nD. 在四元式中，将后续对 $x$ 的使用替换为持有 $y + z$ 的临时变量的复写传播保证了无论 $y := 1$ 的重新定义如何，$x$ 都可以在使用点从当前的 $y$ 和 $z$ 重新计算，因此在这种模式下从不需要保留。\n\n选择所有适用的选项。", "solution": "用户提供了一个关于编译器中间表示和代码重新计算有效性的问题陈述。我现在将执行所需的验证和分析。\n\n### 问题验证\n\n**第一步：提取已知条件**\n\n*   **代码片段：**一个直线指令序列：首先是 `$x := y + z$`，然后是 `$y := 1$`，随后是 `$x$` 的使用。\n*   **机器上下文：**目标机器寄存器稀缺。\n*   **编译器选择：**\n    1.  **保留：**在 `$y$` 的重新定义后保留 `$x$` 的值（例如，在寄存器中或通过溢出/重载）。\n    2.  **重新计算：**在使用点重新计算 `$x$` 的值。\n*   **中间表示（IR）的定义：**\n    *   **四元式：** `$(\\mathrm{op}, \\mathrm{arg1}, \\mathrm{arg2}, \\mathrm{result})$`，在 `result` 中有一个命名的临时变量。\n    *   **三元式：** 结果未命名，通过其位置索引引用。\n    *   **间接三元式：** 一个额外的指针表将稳定引用映射到三元式条目。\n*   **数据流概念的定义：**\n    *   **定值-使用（def-use）链：** 对于一个定值 `$d$`，它是从 `$d$` 可达且中间没有对该定值名称进行重新定义的使用的集合。\n    *   **到达定值分析：** 确定对于每个程序点和每个变量名，哪些定值可以到达该点。\n*   **安全重新计算的条件：** 重新计算是安全的，当且仅当它使用的操作数值与原始计算时的值相等。这等价于依赖于所有操作数的相同到达定值，或确保操作数本身可以被重新物化。\n\n**第二步：使用提取的已知条件进行验证**\n\n*   **科学依据：** 该问题牢固地植根于编译器构建的基本原则。四元式、三元式、间接三元式、def-use链和到达定值的定义都是标准的且陈述准确。重新物化（重新计算）与保留的概念是一个经典的优化权衡。\n*   **问题定义良好：** 该问题提供了一个具体的代码片段和一个关于不同IR对特定优化决策影响的明确问题。所提供的定义和条件为进行严谨且唯一的分析构成了充分的基础。\n*   **客观性：** 语言正式且技术性强，没有歧义、主观性或观点。\n\n**第三步：结论与行动**\n\n问题陈述是 **有效的**。它在科学上是合理的，问题定义良好且客观。它呈现了一个编译器理论中的标准场景，可以基于所提供的原则进行严谨分析。现在我将推导解决方案并评估选项。\n\n### 解决方案推导\n\n核心问题是在“$x$的使用”点将 `$x$` 重新计算为 `$y + z$` 是否在语义上等同于使用最初计算的值。\n\n让代码片段执行前变量的状态表示为一些初始值。\n1.  `$x := y + z$`: `$x$` 的值是使用在此时刻活跃的 `$y$` 和 `$z$` 的值计算的。设这些值为 `$y_0$` 和 `$z_0$`。因此，`$x$` 被赋值为 `$y_0 + z_0$`。称此为定值 `$d_x$`。操作数 `$y$` 和 `$z$` 是对到达此点的定值的使用，比如 `$d_{y0}$` 和 `$d_{z0}$`。\n2.  `$y := 1$`: 变量 `$y$` 被重新定义。它的值现在是 `$1$`。这创建了 `$y$` 的一个新定值，比如 `$d_{y1}$`。这个定值 `$d_{y1}$` *杀死*了之前的定值 `$d_{y0}$`。\n3.  `...` (中间代码，假设不重新定义 `$y$` 或 `$z$`)\n4.  `use of x`: 这是对定值 `$d_x$` 的使用。编译器必须提供值 `$y_0 + z_0$`。\n\n如果编译器选择重新计算，它将在此点执行操作 `$y + z$`。使用的操作数将是 `$y$` 和 `$z$` 的当前值。\n*   到达此点的 `$y$` 的定值是 `$d_{y1}$`（来自 `$y := 1$`），所以 `$y$` 的值是 `$1$`。\n*   到达此点的 `$z$` 的定值仍然是 `$d_{z0}$`，其值为 `$z_0$`。\n\n重新计算的值将是 `$1 + z_0$`。原始值是 `$y_0 + z_0$`。这些值仅在 `$y_0 = 1$` 时才等价。在一般情况下，这不成立。因此，重新计算在语义上是无效的。编译器的分析必须能够检测到这一点。\n\n现在，我们分析每种IR如何暴露做出此判断所需的信息。\n\n**四元式：**\n表示会是这样：\n`(1) (add, y, z, x)` (或 `t1`)\n`(2) (assign, 1, , y)`\n...\n`(n) (... use of x ...)`\n\n在这种结构上的数据流分析是基于符号名 `$x$`, `$y$`, `$z$` 进行的。\n*   在行 `(1)` 的 `$x$` 的定值使用了变量 `$y$` 和 `$z$`。到达定值分析将确定到达行 `(1)` 的 `$y$` 的定值是来自代码块之前的某个 `$d_{y0}$`。\n*   行 `(2)` 创建了一个新定值 `$d_{y1}$`。\n*   在行 `(n)`，到达此点的 `$y$` 的定值是 `$d_{y1}$`。\n*   为了检查在行 `(n)` 处重新计算行 `(1)` 的表达式是否有效，编译器会比较两个点处操作数（`$y$`, `$z$`）的到达定值集合。对于 `$y$`，在 `(1)` 处的到达定值是 `$d_{y0}$`，而在 `(n)` 处是 `$d_{y1}$`。因为 `$\\left\\{d_{y0}\\right\\} \\neq \\left\\{d_{y1}\\right\\}$`，操作数的值已改变，重新计算无效。四元式表示使得这种分析很直接，因为操作数是显式命名的。\n\n**三元式和间接三元式：**\n表示会是这样：\n`(0) (add, y, z)`\n`(1) (assign, y, 1)`\n...\n这里，`x` 在概念上是三元式 `(0)` 结果的别名。对 `$x$` 的使用就是对 `(0)` 计算出的值的使用。三元式 `(0)` 中的操作数是符号 `$y$` 和 `$z$`。一个在三元式上运行的有效的数据流分析框架仍然必须跟踪像 `$y$` 和 `$z$` 这样的符号变量的定值和使用。分析过程与四元式情况完全相同：三元式 `(0)` 中使用的符号 `$y$` 的定值被指令 `(1)` 的操作所杀死。试图在稍后点重新执行三元式 `(0)` 的操作将涉及读取符号 `$y$` 的当前值，而该值已经改变。因此，分析将正确地得出结论，即重新计算是无效的。结果由索引（`(0)`）而非名称（`$x$` 或 `$t1`）引用的事实，并不会改变对源操作数 `$y$` 和 `$z$` 的基本数据依赖。同样的逻辑也适用于间接三元式，它只是为代码移动增加了一个间接层，并未改变依赖表示。\n\n### 逐项分析\n\n**A. 在四元式中，def-use链显示 $x$ 的定值在 $x := y + z$ 点依赖于 $y$ 和 $z$。因为中间有对 $y$ 的重新定义，在后续使用点将 $x$ 重新计算为 $y + z$ 通常会产生一个不同的值；因此，除非 $y$ 的早期值（或 $x$ 本身）被保留，否则在使用点进行重新计算在语义上是无效的。**\n这个陈述是对情况的精确和准确描述。四元式 `$(add, y, z, x)$` 使得对名称 `$y$` 和 `$z$` 的依赖变得明确。标准的到达定值分析（用于构建def-use链）将检测到到达原始计算的 `$y$` 的定值与到达使用点的定值不同。这使得重新计算无效。\n**结论：正确。**\n\n**B. 在三元式中，因为后续使用可以直接引用形成 $y + z$ 的计算的索引，所以即使在 $y$ 被重新定义后，编译器也总能在使用点重新物化 $x$ 的原始值，因此保留是不必要的。**\n这个陈述是错误的。引用一个三元式的索引，比如 `$(k)$`，仅标识了所执行的操作 `$(op, arg1, arg2)$`。“重新物化”或“重新计算”意味着重新执行该操作。该操作的执行使用其操作数的*当前*值。由于操作数 `$y$` 已被重新定义，重新执行会产生一个新的、不正确的结果。三元式表示不会神奇地保留旧的操作数值；它仅仅是一种数据结构。保留确实是必要的。\n**结论：错误。**\n\n**C. 对于三元式和间接三元式，来自计算 $y + z$ 的节点的操作数链接标识了该值所依赖的 $y$ 和 $z$ 的特定到达定值；因此，只有当那些到达定值的值仍然可用或其本身可以被重新物化时，在后续使用点进行重新计算才是有效的。对 $y$ 的重新定义而未保留其早期值会阻止正确的重新计算，正如在四元式中一样。**\n这个陈述正确地解释了一个健全的分析在三元式和间接三元式上必须如何工作。分析框架必须将操作数链接（无论是名称还是索引）解析为产生其值的特定定值。它正确地陈述了重新物化的一般条件，并正确地得出结论，在这种情况下对 `$y$` 的重新定义使重新计算无效，正如在四元式中一样。底层的数据依赖及其分析结论与具体的IR语法无关。\n**结论：正确。**\n\n**D. 在四元式中，将后续对 $x$ 的使用替换为持有 $y + z$ 的临时变量的复写传播保证了无论 $y := 1$ 的重新定义如何，$x$ 都可以在使用点从当前的 $y$ 和 $z$ 重新计算，因此在这种模式下从不需要保留。**\n这个陈述是不正确的，并显示了对复写传播的误解。如果代码是 `t1 := y + z; x := t1`，复写传播可能会将 `use of x` 更改为 `use of t1`。这并不能解决问题；它只是重新表述了问题。编译器仍然需要提供 `$t1$` 的值。如果它选择通过计算 `$y + z$` 来重新计算 `$t1$`，它将面临完全相同的语义有效性问题：`$y$` 的值已经改变。复写传播是一种语法转换，它不改变基本的数据依赖，也不会神奇地验证一个本来无效的重新计算。\n**结论：错误。**", "answer": "$$\\boxed{AC}$$", "id": "3665528"}]}