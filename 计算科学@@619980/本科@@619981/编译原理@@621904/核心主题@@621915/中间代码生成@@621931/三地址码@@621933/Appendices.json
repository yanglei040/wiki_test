{"hands_on_practices": [{"introduction": "从高级语言到中间代码的转换，其核心在于正确地处理控制流。本练习聚焦于三元运算符，它是一种紧凑的 `if-else` 形式。你将学习如何通过三地址码（TAC）中的分支和标签来实现其短路求值（short-circuiting）的特性，以防止诸如“除以零”之类的运行时错误，这是构建健壮编译器的关键一步。[@problem_id:3675498]", "problem": "您正在将表达式 $x = (a == 0 ? 0 : b / a)$ 编译为三地址码（TAC），其中三地址码（TAC）使用带有显式临时变量和标签的基本指令的线性序列。条件运算符必须保留短路语义：如果 $a == 0$，则不得对右侧候选项 $b / a$ 进行求值。特别地，生成的TAC必须在结构上避免除以零。\n\n假设可以使用以下基本TAC指令形式：\n- 条件分支：“if $u$ relop $v$ goto $L$”。\n- 无条件跳转：“goto $L$”。\n- 二元算术运算：“$t = y$ op $z$”（其中除法“$/$”是一种特定运算）。\n- 赋值：“$x = y$”。\n\n标签是分支目标的注解，其本身不产生运行时开销。所有临时变量都必须显式引入。\n\n任务：\n1) 推导出一个带有显式标签和临时变量的最小TAC序列，用于实现 $x = (a == 0 ? 0 : b / a)$，同时保留短路语义并在结构上避免除以零。请展示所使用的分支和临时变量。\n\n2) 假设每条执行的指令产生的开销如下：每个条件分支的开销为 $c_{\\mathrm{br}}$，每个无条件跳转的开销为 $c_{\\mathrm{goto}}$，每个除法运算的开销为 $c_{\\mathrm{div}}$，每个赋值操作的开销为 $c_{\\mathrm{as}}$。设 $p = \\Pr[a = 0]$。仅使用基本原理（条件运算符的语义以及带有分支的TAC的线性执行），以 $p$、$c_{\\mathrm{br}}$、$c_{\\mathrm{goto}}$、$c_{\\mathrm{div}}$ 和 $c_{\\mathrm{as}}$ 的封闭形式表达式计算您的TAC的期望执行开销。标签不产生开销。假设没有其他开销来源。\n\n您的最终答案必须是单一的封闭形式解析表达式。不要四舍五入。不要包含单位。", "solution": "所述问题是有效的。这是一个编译器构造领域的适定问题，它提供了所有必要的定义、约束和数据，以便为正确生成的三地址码（TAC）序列推导出唯一的期望开销解。该问题具有科学依据，是客观且自洽的。\n\n任务是将表达式 $x = (a == 0 ? 0 : b / a)$ 编译为TAC，然后计算期望执行开销。一个关键约束是保留短路语义，即如果 $a=0$，子表达式 $b / a$ 绝不能被求值。\n\n**第一部分：三地址码的推导**\n\n为实现三元运算符的短路行为，我们必须使用条件分支指令。其逻辑如下：首先，对条件 $a == 0$ 求值。如果为真，控制流必须分支到一个将 $0$ 赋给 $x$ 的指令序列。如果条件为假，控制流应继续执行一个序列，该序列计算 $b / a$，将结果赋给 $x$，然后无条件跳转越过为真情况下的代码。\n\n设 $L_1$ 是真分支代码（即当 $a == 0$ 时）的标签，$L_2$ 是紧跟在整个三元运算之后指令的标签。根据所提供的基本TAC指令形式，一个最小序列是：\n\n1. `if` $a == 0$ `goto` $L_1$\n2. $t_1 = b / a$\n3. $x = t_1$\n4. `goto` $L_2$\n5. $L_1$: $x = 0$\n6. $L_2$:\n\n该序列正确地实现了表达式，同时满足所有约束：\n- 第一条指令 `if` $a == 0$ `goto` $L_1` 实现检查。如果 $a$ 确实为 $0$，控制流跳转到标签 $L_1$，完全绕过指令 $2$、$3$ 和 $4$。\n- 第二条指令 $t_1 = b / a$ 执行除法，只有在第一条指令的条件为假时（即 $a \\neq 0$）才可达。这在结构上避免了除以零。结果存储在一个显式引入的临时变量 $t_1$ 中。\n- 第三条指令 $x = t_1$ 将除法结果赋给目标变量 $x$。\n- 第四条指令 `goto` $L_2$ 是一个无条件跳转，用于跳过真分支的代码（指令 $5$），并在条件块之后恢复执行。\n- 第五条指令 $x = 0$ 位于标签 $L_1$ 处，是初始条件跳转的目标。它通过将 $0$ 赋给 $x$ 来处理真分支路径。\n- 标签 $L_2$ 标记了条件逻辑完成后的合并点。\n\n该序列由 $5$ 条指令组成，对于给定的指令集和语义而言是最小的。\n\n**第二部分：期望执行开销计算**\n\n我们记为 $E$ 的期望执行开销，是由两条可能执行路径的开销按其各自的概率加权决定的。给定 $p = \\Pr[a = 0]$，因此 $\\Pr[a \\neq 0] = 1-p$。每种指令类型的开销给定为 $c_{\\mathrm{br}}$、$c_{\\mathrm{goto}}$、$c_{\\mathrm{div}}$ 和 $c_{\\mathrm{as}}$。\n\n**路径 1：$a=0$ 的情况（发生概率为 $p$）**\n执行的指令是：\n1. `if` $a == 0$ `goto` $L_1$：执行条件分支，并进行跳转。开销为 $c_{\\mathrm{br}}$。\n2. (控制流跳转到 $L_1$)\n3. $x = 0$：执行赋值操作。开销为 $c_{\\mathrm{as}}$。\n此路径的总开销 $C_{\\text{true}}$ 是已执行指令开销的总和：\n$$C_{\\text{true}} = c_{\\mathrm{br}} + c_{\\mathrm{as}}$$\n\n**路径 2：$a \\neq 0$ 的情况（发生概率为 $1-p$）**\n执行的指令是：\n1. `if` $a == 0$ `goto` $L_1$：执行条件分支，但不进行跳转（顺序执行）。开销为 $c_{\\mathrm{br}}$。\n2. $t_1 = b / a$：执行除法运算。开销为 $c_{\\mathrm{div}}$。\n3. $x = t_1$：执行赋值操作。开销为 $c_{\\mathrm{as}}$。\n4. `goto` $L_2$：执行无条件跳转。开销为 $c_{\\mathrm{goto}}$。\n此路径的总开销 $C_{\\text{false}}$ 是：\n$$C_{\\text{false}} = c_{\\mathrm{br}} + c_{\\mathrm{div}} + c_{\\mathrm{as}} + c_{\\mathrm{goto}}$$\n\n**计算期望开销**\n期望开销 $E$ 是各路径开销乘以其概率的总和：\n$$E = (\\Pr[a=0] \\cdot C_{\\text{true}}) + (\\Pr[a \\neq 0] \\cdot C_{\\text{false}})$$\n代入概率和开销表达式：\n$$E = p(c_{\\mathrm{br}} + c_{\\mathrm{as}}) + (1-p)(c_{\\mathrm{br}} + c_{\\mathrm{div}} + c_{\\mathrm{as}} + c_{\\mathrm{goto}})$$\n我们可以简化这个表达式。注意，两条路径都执行了条件分支和对 $x$ 的一次赋值。我们可以重新组合这些项：\n$$E = p(c_{\\mathrm{br}} + c_{\\mathrm{as}}) + (1-p)(c_{\\mathrm{br}} + c_{\\mathrm{as}}) + (1-p)(c_{\\mathrm{div}} + c_{\\mathrm{goto}})$$\n从前两项中提出 $(c_{\\mathrm{br}} + c_{\\mathrm{as}})$：\n$$E = (p + 1 - p)(c_{\\mathrm{br}} + c_{\\mathrm{as}}) + (1-p)(c_{\\mathrm{div}} + c_{\\mathrm{goto}})$$\n$$E = 1 \\cdot (c_{\\mathrm{br}} + c_{\\mathrm{as}}) + (1-p)(c_{\\mathrm{div}} + c_{\\mathrm{goto}})$$\n这就得出了期望开销的最终封闭形式表达式：\n$$E = c_{\\mathrm{br}} + c_{\\mathrm{as}} + (1-p)(c_{\\mathrm{div}} + c_{\\mathrm{goto}})$$\n这个表达式直观地说明了总期望开销是总是执行的指令（$c_{\\mathrm{br}} + c_{\\mathrm{as}}$）的开销，加上仅在 $a \\neq 0$ 时执行的指令（$c_{\\mathrm{div}} + c_{\\mathrm{goto}}$）的开销，再乘以该情况发生的概率（$1-p$）。", "answer": "$$ \\boxed{c_{\\mathrm{br}} + c_{\\mathrm{as}} + (1-p)(c_{\\mathrm{div}} + c_{\\mathrm{goto}})} $$", "id": "3675498"}, {"introduction": "除了控制流，编译器还必须细致地管理程序状态，尤其是在表达式带有副作用（side effects）时。本练习将处理在数组访问中常见的后自增运算符 `i++`。通过比较两种不同的三地址码（TAC）实现方案，你将体会到临时变量在保留预期语义和确保操作按正确顺序执行方面所起的关键作用。[@problem_id:3675439]", "problem": "一种简化的命令式源语言支持整型变量和数组，以及变量的后自增运算符。考虑在数组索引中使用了后自增的赋值语句：\n$$\na[i^{++}] = b + c \\cdot d.\n$$\n假设遵循以下基本语义规则。\n- 后自增语义：对 $x^{++}$ 求值会产生 $x$ 的当前值作为表达式的值，并安排副作用 $x := x + 1$ 在获取该值之后、包含它的完整表达式结束之前发生。\n- 赋值语义：对 $L := R$ 求值时，会先对左侧表达式求值得到一个位置（location），并对右侧表达式求值得到一个值（value）；对该位置的存储（store）操作在两侧表达式都求值完毕后发生。算术运算是纯粹的，没有副作用。\n- 无别名和纯粹性：变量 $a$、$b$、$c$、$d$ 和 $i$ 指向不相交的存储空间；$b$、$c$ 和 $d$ 是标量；对 $b$、$c$ 和 $d$ 的求值没有副作用，且不会读取 $i$；数组 $a$ 除了通过其自身元素外，不与 $b$、$c$、$d$ 或 $i$ 中的任何一个产生别名。\n\n一个编译器使用临时变量 $t_1$、$t_2$、$t_3$ 将源语句降级（lowers）为三地址码（TAC; three-address code）。考虑两种候选的 TAC 变体：\n\n变体 X:\n1. $t_1 := i$\n2. $t_2 := c \\cdot d$\n3. $t_3 := b + t_2$\n4. $a[t_1] := t_3$\n5. $i := i + 1$\n\n变体 Y:\n1. $t_1 := i$\n2. $i := i + 1$\n3. $t_2 := c \\cdot d$\n4. $t_3 := b + t_2$\n5. $a[t_1] := t_3$\n\n设执行任一变体前 $i$ 的初始值为任意整数，记作 $i_0$。定义 $\\Delta$ 为变体 X 中用于存储的数组索引与变体 Y 中用于存储的数组索引之差：\n$$\n\\Delta := \\big(\\text{store index in X}\\big) - \\big(\\text{store index in Y}\\big).\n$$\n在所述语义规则和假设下，确定 $\\Delta$ 的精确值。你的最终答案必须是一个实数。不需要四舍五入。将最终答案表示为一个没有任何单位的纯数字。", "solution": "题目要求确定两个三地址码变体（标记为 Variant X 和 Variant Y）中存储指令所使用的数组索引之差 $\\Delta$。\n\n设任一代码变体执行前整型变量 $i$ 的初始值为 $i_0$。我们的分析将从这个初始状态开始，通过追踪每个变体的执行过程来进行。\n\n首先，我们分析 Variant X。其指令序列如下：\n1.  $t_1 := i$\n2.  $t_2 := c \\cdot d$\n3.  $t_3 := b + t_2$\n4.  $a[t_1] := t_3$\n5.  $i := i + 1$\n\n我们追踪相关变量的值，特别是 $i$ 和用作数组索引的临时变量 $t_1$。\n-   最初，$i$ 的值为 $i_0$。\n-   在指令 1，$t_1 := i$ 中，$i$ 的当前值 $i_0$ 被赋给临时变量 $t_1$。此指令执行后，$t_1$ 的值为 $i_0$。$i$ 的值仍为 $i_0$。\n-   指令 2 和 3 计算原始赋值语句的右侧。它们不涉及或修改变量 $i$ 或 $t_1$。因此，在指令 4 之前，$t_1$ 的值仍然是 $i_0$。\n-   指令 4，$a[t_1] := t_3$，是存储操作。所使用的数组索引是变量 $t_1$ 的值。在执行的这个时间点，$t_1$ 的值为 $i_0$。因此，Variant X 中的存储索引是 $i_0$。\n-   指令 5，$i := i + 1$，将 $i$ 的值加一。这发生在存储操作（通过 $t_1$）使用了 $i$ 的原始值之后。\n\n通过以上分析，我们得出结论，Variant X 中的存储索引是 $i_0$。\n\n接下来，我们分析 Variant Y。其指令序列是：\n1.  $t_1 := i$\n2.  $i := i + 1$\n3.  $t_2 := c \\cdot d$\n4.  $t_3 := b + t_2$\n5.  $a[t_1] := t_3$\n\n我们追踪此变体中 $i$ 和 $t_1$ 的值，同样从 $i = i_0$ 开始。\n-   最初，$i$ 的值为 $i_0$。\n-   在指令 1，$t_1 := i$ 中，$i$ 的当前值 $i_0$ 被赋给临时变量 $t_1$。此指令执行后，$t_1$ 的值为 $i_0$。\n-   在指令 2，$i := i + 1$ 中，$i$ 的值被增加到 $i_0 + 1$。此指令修改了 $i$ 的存储位置。然而，它不影响临时变量 $t_1$ 的值，因为 $t_1$ 占用一个不同的存储位置且其值已为 $i_0$。\n-   指令 3 和 4 计算右侧表达式，并且不修改 $i$ 或 $t_1$。在指令 5 之前，$t_1$ 的值保持为 $i_0$，而 $i$ 的值为 $i_0+1$。\n-   指令 5，$a[t_1] := t_3$，是存储操作。所使用的数组索引是 $t_1$ 的值。此时，$t_1$ 的值仍然是 $i_0$。因此，Variant Y 中的存储索引是 $i_0$。\n\n通过以上分析，我们得出结论，Variant Y 中的存储索引也是 $i_0$。\n\n题目将 $\\Delta$ 定义为两个变体存储索引之差：\n$$\n\\Delta := (\\text{store index in X}) - (\\text{store index in Y})\n$$\n代入我们确定的值：\n$$\n\\Delta = i_0 - i_0\n$$\n$$\n\\Delta = 0\n$$\nVariant X 和 Variant Y 中用于存储操作的数组索引之差为 $0$。根据后自增语义规则的要求，两个变体都正确地捕获了自增前 $i$ 的值用作数组索引。自增指令 `i := i + 1` 的不同位置并没有改变用于索引的值，因为该值在两个序列的开始都已保存在临时变量 $t_1$ 中。", "answer": "$$\\boxed{0}$$", "id": "3675439"}, {"introduction": "现在，我们将视角从单个语句提升到完整的函数。这最后一个练习将指导你把一个递归的阶乘函数翻译成三地址码（TAC）。你将需要追踪整个执行过程，从最初的调用到递归的基准情形（base case）再到逐层返回，并在此过程中跟踪临时变量的动态创建过程，从而理解在中间代码层面是如何管理调用栈的。[@problem_id:3675465]", "problem": "给定整数输入 $n \\ge 0$ 的阶乘函数 $f(n)$ 的高层递归定义：\n如果 $n \\le 1$ 则返回 $1$，否则返回 $n \\times f(n-1)$。\n从编译原理中三地址码（TAC）的核心定义出发——其中每条 TAC 指令最多有三个地址，并遵循一个包含临时变量、标签、条件和无条件分支、参数传递、过程调用和返回的规范指令集——请执行以下任务。\n\n1. 使用以下指令形式，将函数 $f(n)$ 翻译成规范的三地址码形式：\n- 将一个基本运算的结果赋值给一个新的临时变量：$t := x \\ \\text{op} \\ y$。\n- 将一个布尔比较的结果赋值给一个新的临时变量：$t := x \\ \\text{relop} \\ y$。\n- 条件分支：$\\text{if} \\ t \\ \\text{goto} \\ L$。\n- 无条件跳转：$\\text{goto} \\ L$。\n- 参数传递：对每个实参使用 $\\text{param} \\ x$。\n- 过程调用，返回值存入一个新的临时变量：$t := \\text{call} \\ f, k$，其中 $k$ 是由之前的 $\\text{param}$ 指令传递的实参个数。\n- 从过程返回：$\\text{ret} \\ x$。\n- 标签：$L:$，它不是一个可执行指令。\n\n请遵循以下约定。\n- 每次对临时变量的赋值执行时，都会引入一个新的临时变量 $t_i$，其索引 $i \\in \\mathbb{N}$ 是全局递增的，在整个运行过程中第一次此类赋值时 $i$ 从 $1$ 开始。\n- 序列 $t_1, t_2, \\dots$ 记录了所有过程中临时变量的动态创建顺序。\n- 标签不计为执行的指令。\n- 指令 $\\text{if}$、$\\text{goto}$、$\\text{param}$、$\\text{call}$ 和 $\\text{ret}$ 在控制流经过它们时被计为执行的指令，但它们本身不创建新的临时变量，除了上述指定的 $\\text{call}$ 形式会将返回值赋给一个新的临时变量。\n- 基本情况返回常量时直接使用 $\\text{ret} \\ 1$，不创建临时变量。\n- 求值顺序为从左到右，递归遵循自然的深度优先调用序列。\n\n一个驱动程序执行以下代码来调用 $f$：\n- $\\text{param} \\ n$\n- $t := \\text{call} \\ f, 1$\n- $\\text{halt}$\n\n假设输入为 $n = 7$。\n\n在这些约定下，为 $f(n)$ 推导一个正确的 TAC。然后，通过跟踪动态调用序列和在运行时创建临时变量 $t_i$ 的顺序（包括驱动程序的调用），确定在驱动程序调用 $f$ 的整个执行过程中直到从 $f$ 返回所创建的最大临时变量 $t_{i_{\\max}}$ 的索引 $i_{\\max}$。你的最终答案必须是一个数字（没有单位，没有解释），精确表示 $i_{\\max}$（没有四舍五入）。", "solution": "该问题陈述经证实具有科学依据、问题明确、客观且自洽。它提出了一个编译理论中的标准问题，涉及为递归函数生成和执行三地址码。所提供的临时变量创建和指令执行规则是明确且一致的，从而可以得出一个唯一的、确定性的解。\n\n首先，我们必须将递归阶乘函数 $f(n)$ 翻译成指定的三地址码（TAC）格式。该函数定义为：\n如果 $n \\le 1$ 则返回 $1$，否则返回 $n \\times f(n-1)$。\n\n设传递给函数 $f$ 的单个参数由地址 `arg` 表示。一个 $f$ 的规范 TAC 表示如下：\n\n`L_f_begin:`\n$t_a := \\text{arg} \\le 1$\n$\\text{if } t_a \\text{ goto } \\text{L_base}$\n$t_b := \\text{arg} - 1$\n$\\text{param } t_b$\n$t_c := \\text{call } f, 1$\n$t_d := \\text{arg} \\times t_c$\n$\\text{ret } t_d$\n$\\text{goto } \\text{L_end}$\n`L_base:`\n$\\text{ret } 1$\n`L_end:`\n\n在这里，$t_a, t_b, t_c,$ 和 $t_d$ 代表动态创建的临时变量。根据问题的规则，在创建它们的指令被执行的时刻，每个临时变量都会在序列 $t_1, t_2, \\dots$ 中获得一个唯一的、全局递增的索引 $i$。\n\n任务是找出在由驱动程序发起的 $f(7)$ 执行期间创建的临时变量的最大索引 $i_{\\max}$。我们必须跟踪动态执行序列。在此跟踪中，有四种类型的指令会创建临时变量：\n1. 驱动程序的调用：`t := call f, 1`\n2. 比较：`t := arg = 1`\n3. 减法：`t := arg - 1`\n4. 乘法：`t := arg * t_result`\n\n跟踪从输入 $n=7$ 的驱动程序执行开始。设 $i$ 为临时变量的全局索引，初始化为 $0$。\n\n1.  **驱动程序执行：**\n    - `param 7` 被执行。\n    - `t := call f, 1` 被执行。这是第一条创建临时变量的指令。索引 $i$ 变为 $1$。创建一个临时变量 $t_1$ 来保存 $f(7)$ 的最终返回值。\n    - 控制权传递给函数 $f$，其参数 `arg` 设置为 $7$。\n\n2.  **递归下降：** 执行沿着递归调用链向下进行。\n    - **在 `f(7)` 中** (`arg = 7`)：\n        - 条件 `arg = 1` 被求值。`t_2 := 7 = 1` 被执行。$i$ 变为 $2$。\n        - 分支不被采纳。\n        - 为下一次调用计算参数。`t_3 := 7 - 1` 被执行。$i$ 变为 $3$。\n        - `param t_3` 被执行。\n        - 进行递归调用。`t_4 := call f, 1` 被执行。$i$ 变为 $4$。控制权传递给 `f(6)`。\n    - **在 `f(6)` 中** (`arg = 6`)：\n        - `t_5 := 6 = 1` 被执行。$i$ 变为 $5$。\n        - `t_6 := 6 - 1` 被执行。$i$ 变为 $6$。\n        - `t_7 := call f, 1` 被执行。$i$ 变为 $7$。控制权传递给 `f(5)`。\n    - **在 `f(5)` 中** (`arg = 5`)：\n        - `t_8 := 5 = 1` 被执行。$i$ 变为 $8$。\n        - `t_9 := 5 - 1` 被执行。$i$ 变为 $9$。\n        - `t_{10} := call f, 1` 被执行。$i$ 变为 $10$。控制权传递给 `f(4)`。\n    - **在 `f(4)` 中** (`arg = 4`)：\n        - `t_{11} := 4 = 1` 被执行。$i$ 变为 $11$。\n        - `t_{12} := 4 - 1` 被执行。$i$ 变为 $12$。\n        - `t_{13} := call f, 1` 被执行。$i$ 变为 $13$。控制权传递给 `f(3)`。\n    - **在 `f(3)` 中** (`arg = 3`)：\n        - `t_{14} := 3 = 1` 被执行。$i$ 变为 $14$。\n        - `t_{15} := 3 - 1` 被执行。$i$ 变为 $15$。\n        - `t_{16} := call f, 1` 被执行。$i$ 变为 $16$。控制权传递给 `f(2)`。\n    - **在 `f(2)` 中** (`arg = 2`)：\n        - `t_{17} := 2 = 1` 被执行。$i$ 变为 $17$。\n        - `t_{18} := 2 - 1` 被执行。$i$ 变为 $18$。\n        - `t_{19} := call f, 1` 被执行。$i$ 变为 $19$。控制权传递给 `f(1)`。\n\n3.  **基本情况：**\n    - **在 `f(1)` 中** (`arg = 1`)：\n        - 条件 `arg = 1` 被求值。`t_{20} := 1 = 1` 被执行。现在 $i$ 的值为 $20$。\n        - 条件分支 `if t_{20} goto L_base` 被采纳。\n        - `ret 1` 被执行。这不会创建新的临时变量。函数返回值 $1$。递归开始回溯。\n\n4.  **递归回升：** 控制权沿调用栈向上传递。\n    - **返回到 `f(2)`：**\n        - 返回值 $1$ 被赋给临时变量 `t_{19}`。\n        - 执行乘法。`t_{21} := 2 \\times t_{19}` 被执行。现在 $i$ 的值为 $21$。\n        - `ret t_{21}` 被执行，返回值 $2$。\n    - **返回到 `f(3)`：**\n        - 返回值 $2$ 被赋给 `t_{16}`。\n        - `t_{22} := 3 \\times t_{16}` 被执行。现在 $i$ 的值为 $22$。\n        - 函数返回值 $6$。\n    - **返回到 `f(4)`：**\n        - 返回值 $6$ 被赋给 `t_{13}`。\n        - `t_{23} := 4 \\times t_{13}` 被执行。现在 $i$ 的值为 $23$。\n        - 函数返回值 $24$。\n    - **返回到 `f(5)`：**\n        - 返回值 $24$ 被赋给 `t_{10}`。\n        - `t_{24} := 5 \\times t_{10}` 被执行。现在 $i$ 的值为 $24$。\n        - 函数返回值 $120$。\n    - **返回到 `f(6)`：**\n        - 返回值 $120$ 被赋给 `t_7`。\n        - `t_{25} := 6 \\times t_7` 被执行。现在 $i$ 的值为 $25$。\n        - 函数返回值 $720$。\n    - **返回到 `f(7)`：**\n        - 返回值 $720$ 被赋给 `t_4`。\n        - 执行最后的乘法。`t_{26} := 7 \\times t_4` 被执行。现在 $i$ 的值为 $26$。\n        - `ret t_{26}` 被执行，返回值 $5040$。\n\n5.  **最终返回到驱动程序：**\n    - 返回值 $5040$ 被赋给初始的临时变量 `t_1`。\n    - `halt` 指令被执行。\n\n在整个过程中创建的最后一个临时变量是 $t_{26}$。因此，最大索引 $i_{\\max}$ 是 $26$。\n\n我们可以为输入 $n > 1$ 概括出所创建的临时变量的数量：\n- 初始驱动程序调用创建 $1$ 个临时变量。\n- 对于从 $f(n)$ 向下到 $f(2)$ 的每次递归调用（共 $n-1$ 次调用），在下降阶段会创建 $3$ 个临时变量（`=`、`-`、`call`）。总计：$3 \\times (n-1)$。\n- 对于基本情况调用 $f(1)$，创建 $1$ 个临时变量（`=`）。\n- 对于从 $f(1)$ 回溯到 $f(n-1)$ 的每次返回（共 $n-1$ 次返回），会为乘法创建 $1$ 个临时变量。总计：$1 \\times (n-1)$。\n对于 $n > 1$ 的总临时变量数：$i_{\\max} = 1 + 3(n-1) + 1 + 1(n-1) = 2 + 4(n-1) = 4n - 2$。\n对于给定的输入 $n=7$，该公式得出：$i_{\\max} = 4(7) - 2 = 28 - 2 = 26$。这证实了详细跟踪得出的结果。", "answer": "$$\\boxed{26}$$", "id": "3675465"}]}