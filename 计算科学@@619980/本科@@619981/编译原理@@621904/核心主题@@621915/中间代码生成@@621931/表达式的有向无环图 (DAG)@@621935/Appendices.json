{"hands_on_practices": [{"introduction": "掌握表达式有向无环图（DAG）的第一步是亲手构建一个。本练习将指导你为一个简单的算术表达式构建 DAG，展示如何识别公共子表达式，并应用交换律和结合律等代数定律以实现最大程度的优化。这个实践的核心在于将一个线性表达式转化为一个高效、无冗余的图结构。[@problem_id:3641786]", "problem": "编译器后端为基本块构建表达式表示，使用有向无环图 (DAG)，其中每个内部节点代表一个二元运算符，每个叶节点代表一个操作数。在此表示中，通过确保具有相同操作数集的相同运算符应用由单个共享节点表示，来执行公共子表达式消除 (CSE)。对于二元加法和乘法，利用加法和乘法满足结合律和交换律的数学事实，在确定节点同一性时对操作数集进行规范化；不要使用任何其他代数变换，例如分配律或引入不存在的数字常量。假设对应于变量的叶节点不计为运算，只有二元加法和二元乘法节点计为运算。\n\n给定表达式\n$$\nx\\cdot y + z\\cdot w + x\\cdot y + z\\cdot w + t,\n$$\n在上述规则下构建具有最大化共享的表达式 DAG，并确定 CSE 后剩余的二元运算节点的最小数量。按顺序报告乘法节点数、加法节点数和二元运算节点总数。将最终答案表示为行矩阵。", "solution": "该问题是有效的，因为它是编译器理论领域内一个定义明确的问题，具体涉及使用有向无环图 (DAG) 的表达式表示以及通过公共子表达式消除 (CSE) 进行的优化。DAG 的构建和优化规则已明确规定。\n\n需要表示的表达式为：\n$$\nE = x \\cdot y + z \\cdot w + x \\cdot y + z \\cdot w + t\n$$\n目标是构建一个具有最大化共享的 DAG，应用加法的 CSE、交换律和结合律，并计算最终的二元运算节点的最小数量。运算符节点严格为二元。变量 $x, y, z, w, t$ 是叶节点，不计为运算节点。\n\n首先，我们识别乘法运算。表达式包含两个不同的乘法子表达式：\n$1$. 子表达式 $x \\cdot y$ 出现两次。由于公共子表达式消除，两个实例都将由 DAG 中的单个共享节点表示。我们将此运算的结果表示为 $N_1 = \\text{node}(\\cdot, x, y)$。这算作一个乘法节点。\n$2$. 子表达式 $z \\cdot w$ 也出现两次。类似地，两个实例都将由第二个共享节点表示。我们将其结果表示为 $N_2 = \\text{node}(\\cdot, z, w)$。这算作第二个乘法节点。\n\n问题指出，使用交换律来规范化操作数集。例如，如果表达式包含 $y \\cdot x$，它将被视为与 $x \\cdot y$ 相同。在本问题中，重复的子表达式是相同的，因此该规则被直接应用。\n没有其他乘法运算。因此，乘法节点的最小数量为 $2$。\n\n接下来，我们分析加法运算。执行乘法后，表达式可以用节点 $N_1$、$N_2$ 和叶节点 $t$ 重写：\n$$\nE = N_1 + N_2 + N_1 + N_2 + t\n$$\n这是五个项的和。问题指出，我们可以利用加法的结合律和交换律来重新排列和重新组合这些项，以最大化共享（即，在加法中创建公共子表达式）。被相加的项的多重集是 $\\{N_1, N_1, N_2, N_2, t\\}$。\n我们可以将和重新排列并分组如下：\n$$\nE = (N_1 + N_2) + (N_1 + N_2) + t\n$$\n这种分组是最优的，因为它创建了重复的子表达式 $(N_1 + N_2)$。让我们为此加法结构构建 DAG：\n$1$. 我们为公共子表达式 $N_1 + N_2$ 创建一个节点。我们称此节点为 $N_3 = \\text{node}(+, N_1, N_2)$。这是我们的第一个加法节点。交换律的性质确保了 $N_2 + N_1$ 会由同一个节点表示。\n$2$. 有了这个新节点，表达式变为 $N_3 + N_3 + t$。我们必须使用二元加法来计算它。我们可以将其分组为 $(N_3 + N_3) + t$。\n$3$. 我们为子表达式 $N_3 + N_3$ 创建一个节点。我们称此节点为 $N_4 = \\text{node}(+, N_3, N_3)$。请注意，此节点接受两个指向同一子节点 $N_3$ 的指针。这是我们的第二个加法节点。\n$4$. 最后，我们创建 DAG 的根节点，它代表整个表达式。该节点计算 $N_4$ 的结果与叶节点 $t$ 的和。设其为 $N_5 = \\text{node}(+, N_4, t)$。这是我们的第三个加法节点。\n\n遵循此构造，我们使用了三个不同的加法节点：$N_3$、$N_4$ 和 $N_5$。对这五个项的任何其他分组都无法用少于三个二元加法节点来实现。例如，一个简单的、不重新组合的左结合求值，如 $(((N_1+N_2)+N_1)+N_2)+t$，不会创建任何公共加法子表达式，并且将需要四个加法节点。\n\n总而言之：\n- 乘法节点数：$2$（用于 $x \\cdot y$ 和 $z \\cdot w$）。\n- 加法节点数：$3$（用于 $(x \\cdot y + z \\cdot w)$、将此子表达式与其自身相加，以及加上 $t$）。\n- 二元运算节点总数：$2 + 3 = 5$。\n\n最终答案要求按顺序给出这三个数字，并表示为行矩阵。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2  3  5\n\\end{pmatrix}\n}\n$$", "id": "3641786"}, {"introduction": "现在我们理解了基本的公共子表达式消除（CSE），那么当表达式包含函数调用时会发生什么呢？这个实践引入了纯函数和副作用这两个关键概念，解释了为什么编译器不能盲目地重用每个函数调用的结果。你将学习如何在 DAG 中使用注解，以做出安全的、能保留程序语义的优化决策。[@problem_id:3641864]", "problem": "给定一个基本块中的表达式 $foo() + bar() + foo()$。编译器使用表达式有向无环图（DAG）来表示计算并执行公共子表达式消除（CSE）。一个函数调用节点由其被调用者名称、参数列表和纯度属性来表征。假设以下基本事实和定义：\n\n- 表达式有向无环图（DAG）是一个有限的有向图，没有有向环，用于表示表达式结构。其中每个节点表示一个操作或操作数，边表示数据依赖。\n- 纯函数是引用透明的：它没有副作用，并且对于相同的参数总是返回相同的结果。非纯函数可能引起副作用或在不同的调用中产生不同的结果。\n- 公共子表达式消除（CSE）在确保语义保持的约束下，合并计算相同值的节点。\n- 在标准数值语义下，二元运算符 $+$ 是纯粹且满足结合律的，但在DAG中可能不意味着任何特定的求值顺序；$+$ 的纯粹性并不允许合并非纯计算。\n\n编译器被要求对DAG节点进行注释，以便CSE仅对表示纯函数调用的节点被允许，而绝不允许对非纯调用进行CSE。在此要求下，选择能够正确表示 $foo() + bar() + foo()$ 并仅对纯调用启用CSE，同时保持可观察的程序行为的DAG构建和注释策略。DAG应通过命名节点及其子节点，并说明与CSE相关的纯度属性来描述。\n\n哪个选项是正确的？\n\nA. 为 $foo()$ 创建一个节点 $n_f$ 并设置属性 $pure(n_f) = \\mathrm{true}$，为 $bar()$ 创建一个节点 $n_b$ 并设置属性 $pure(n_b) = \\mathrm{false}$，并创建两个加法节点 $n_{+1}$ 和 $n_{+2}$，使得 $children(n_{+1}) = (n_f, n_b)$ 和 $children(n_{+2}) = (n_{+1}, n_f)$。应用CSE规则：如果两个函数调用节点 $u$ 和 $v$ 具有相同的被调用者名称和参数，并且 $pure(u) = pure(v) = \\mathrm{true}$，则它们可以被合并。根据此规则，$foo()$ 的两次出现由单个共享的 $n_f$ 表示，而 $bar()$ 仍然是一个独立的、未合并的节点。\n\nB. 为两次 $foo()$ 调用创建不同的节点 $n_f^{(1)}$ 和 $n_f^{(2)}$，并设置 $pure(n_f^{(1)}) = pure(n_f^{(2)}) = \\mathrm{true}$，为 $bar()$ 创建一个节点 $n_b$ 并设置 $pure(n_b) = \\mathrm{false}$。设 $children(n_{+1}) = (n_f^{(1)}, n_b)$ 和 $children(n_{+2}) = (n_{+1}, n_f^{(2)})$。应用策略：无论纯度如何，禁止合并任何函数调用节点，以保持每次调用的求值计数。\n\nC. 为 $foo()$ 创建一个节点 $n_f$ 并设置 $pure(n_f) = \\mathrm{true}$，为 $bar()$ 创建一个节点 $n_b$ 但标记 $pure(n_b) = \\mathrm{true}$。构建 $n_{+1}$ 和 $n_{+2}$，使得 $children(n_{+1}) = (n_f, n_b)$ 和 $children(n_{+2}) = (n_{+1}, n_f)$。应用CSE规则：合并任何语法上相同且 $pure = \\mathrm{true}$ 的函数调用节点，这将允许在多次出现 $bar()$ 调用时合并它们。\n\nD. 为 $foo()$ 创建一个节点 $n_f$，为 $bar()$ 创建一个节点 $n_b$，不带任何纯度注释。构建 $n_{+1}$ 和 $n_{+2}$，使得 $children(n_{+1}) = (n_f, n_b)$ 和 $children(n_{+2}) = (n_{+1}, n_f)$。仅根据函数调用节点的被调用者名称和参数列表的语法相等性来应用CSE，而不考虑纯度，因此如果出现重复的调用（包括非纯调用），也会合并它们。\n\n选择正确的选项。", "solution": "问题陈述描述了在编译器中使用有向无环图（DAG）进行表达式表示和应用公共子表达式消除（CSE）的原则，特别关注处理纯函数和非纯函数调用。核心任务是为表达式 `$foo() + bar() + foo()$` 确定正确的DAG构建和注释策略，以便正确且安全地应用CSE。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- 表达式：`$foo() + bar() + foo()$`，位于单个基本块内。\n- 表示方法：表达式有向无环图（DAG）。\n- 目标：执行公共子表达式消除（CSE）。\n- 函数调用节点属性：被调用者名称、参数列表、纯度属性。\n- DAG定义：一个有限的有向图，没有有向环，其中节点是操作或操作数，边表示数据依赖。\n- 纯度定义：纯函数是引用透明的（没有副作用，对于相同的参数返回相同的值）。非纯函数则不是纯函数。\n- CSE定义：合并计算相同值的节点，同时保持语义。\n- 运算符属性：`+` 运算符是纯粹且满足结合律的。它的纯粹性不允许合并其操作数（如果它们是非纯计算）。\n- 编译器要求：CSE *仅*对表示纯函数调用的节点允许，*绝不*对非纯调用允许。这需要对节点进行注释。\n- 目标：选择能够正确表示表达式、仅对纯调用启用CSE并保持可观察程序行为的DAG构建和注释策略。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题在科学上基于编译器设计的既定原则，特别是像CSE这样的代码优化技术和像纯度这样的数据流分析概念。问题提法清晰，提供了一个明确的表达式、一套规则以及一个寻找符合这些规则的策略的目标。语言客观且技术性强。问题没有明确说明 `$foo()$` 或 `$bar()`$ 的純度，但这并非缺陷。一个通用的策略必须能够处理任何纯度的组合。选项提出了具体的场景和策略，任务是评估哪个选项描述了根据编译器理论是唯一正确且安全的方法。该问题是检验对这些原则理解的有效测试。\n\n**步骤3：结论与行动**\n问题有效。现在开始求解过程。\n\n### 正确策略与DAG的推导\n\n设表达式为 `$E = foo() + bar() + foo()$`。由于解析此类表达式时通常使用左结合性，这等价于 `$(foo() + bar()) + foo()$`。\n\n对函数调用进行CSE的基本原则是，两个调用 `$f(a_1, ..., a_n)$` 和 `$g(b_1, ..., b_m)$` 是一个“公共子表达式”，当且仅当 `$f$` 和 `$g$` 是同一个函数，它们的参数相同，并且——最关键的是——该函数是纯函数。纯函数保证对于相同的输入，输出总是相同的，并且不会发生副作用。因此，通过重用第一个调用的结果来消除对纯函数的第二次调用是保持语义的。相反，消除对非纯函数的调用是错误的，因为它也会消除其预期的副作用（例如I/O、修改全局变量），从而改变程序的可观察行为。\n\n编译器的要求需要一种机制来强制执行这种区别。指定的机制是在DAG中的每个函数调用节点上设置一个`纯度属性`。CSE逻辑必须查询此属性。\n\n因此，一个正确的策略必须是：\n1. 对于表达式中的每个函数调用，在DAG中创建一个节点。\n2. 确定函数的纯度。这可以通过预先存在的注释或全程序分析来完成。结果存储为节点的属性，例如 `$pure(node) = \\mathrm{true}$` 或 `$pure(node) = \\mathrm{false}$`。\n3. 当考虑将一个新的函数调用加入DAG时，编译器搜索一个表示语法上相同调用（相同函数、相同参数）的现有节点。\n4. 如果找到这样的节点 `$n_{existing}$`，编译器会检查其纯度属性。如果 `$pure(n_{existing}) = \\mathrm{true}$`，则新的调用是一个公共子表达式，`$n_{existing}$` 被重用。不创建新节点。如果 `$pure(n_{existing}) = \\mathrm{false}$`，则新的调用不能被消除，必须为其创建一个新的、独立的节点。\n\n让我们将此策略应用于 `$E = (foo() + bar()) + foo()$`。为了测试该策略的全部能力，我们必须考虑CSE适用于一个函数而不适用于另一个函数的情况。让我们假设编译器已确定 `$foo()$` 是纯函数，而 `$bar()$` 是非纯函数。\n\n1. **第一次 `$foo()$` 调用：** 创建一个节点 `$n_f$`。其属性设置为：`$pure(n_f) = \\mathrm{true}$`。\n2. **`$bar()$` 调用：** 创建一个节点 `$n_b$`。其属性设置为：`$pure(n_b) = \\mathrm{false}$`。\n3. **第一次 `+` 操作：** 创建一个加法节点 `$n_{+1}$`。其子节点是 `$n_f$` 和 `$n_b$`。所以，`$children(n_{+1}) = (n_f, n_b)$`。\n4. **第二次 `$foo()$` 调用：** 编译器搜索一个已有的 `$foo()$` 节点。它找到了 `$n_f$`。它检查属性：`$pure(n_f) = \\mathrm{true}$`。满足CSE的条件。因此，现有的节点 `$n_f$` 被重用于这次调用。\n5. **第二次 `+` 操作：** 创建一个最终的加法节点 `$n_{+2}$`。其子节点是第一次加法的结果 `$n_{+1}$` 和第二次 `$foo()$` 的节点，也就是被重用的节点 `$n_f$`。所以，`$children(n_{+2}) = (n_{+1}, n_f)$`。\n\n最终的DAG对两次 `$foo()$` 调用有一个单一的、共享的节点 `$n_f$`，对 `$bar()$` 调用有一个独立的节点 `$n_b$`，以及两个加法节点。这个结构正确地表示了一次 `$foo()$` 调用、一次 `$bar()$` 调用和两次加法，这是保持语义的CSE的结果。\n\n###逐项分析\n\n**A. 为 $foo()$ 创建一个节点 $n_f$ 并设置属性 $pure(n_f) = \\mathrm{true}$，为 $bar()$ 创建一个节点 $n_b$ 并设置属性 $pure(n_b) = \\mathrm{false}$，并创建两个加法节点 $n_{+1}$ 和 $n_{+2}$，使得 $children(n_{+1}) = (n_f, n_b)$ 和 $children(n_{+2}) = (n_{+1}, n_f)$。应用CSE规则：如果两个函数调用节点 $u$ 和 $v$ 具有相同的被调用者名称和参数，并且 $pure(u) = pure(v) = \\mathrm{true}$，则它们可以被合并。根据此规则，$foo()$ 的两次出现由单个共享的 $n_f$ 表示，而 $bar()$ 仍然是一个独立的、未合并的节点。**\n\n此选项与推导出的正确过程完全匹配。它为一个非平凡的情况（`$foo()` 纯，`$bar()` 非纯）指定了正确的纯度属性，概述了查询这些属性的正确CSE规则，并描述了应用此规则所产生的精确、正确优化的DAG结构。\n\n**结论：正确**\n\n**B. 为两次 $foo()$ 调用创建不同的节点 $n_f^{(1)}$ 和 $n_f^{(2)}$，并设置 $pure(n_f^{(1)}) = pure(n_f^{(2)}) = \\mathrm{true}$，为 $bar()$ 创建一个节点 $n_b$ 并设置 $pure(n_b) = \\mathrm{false}$。设 $children(n_{+1}) = (n_f^{(1)}, n_b)$ 和 $children(n_{+2}) = (n_{+1}, n_f^{(2)})$。应用策略：无论纯度如何，禁止合并任何函数调用节点，以保持每次调用的求值计数。**\n\n这个策略过于保守且有根本性缺陷。虽然它是安全的（它通过不执行任何优化来保持语义），但它未能达到*启用*对纯调用进行CSE的目标。该策略正确地将 `$foo()$ ` 识别为纯函数，但随后明确禁止了正是这种纯度信息所允许的优化。它产生了一个仅仅是树的DAG，等同于未优化的表达式，从而违背了使用DAG进行CSE的目的。\n\n**结论：不正确**\n\n**C. 为 $foo()$ 创建一个节点 $n_f$ 并设置 $pure(n_f) = \\mathrm{true}$，为 $bar()$ 创建一个节点 $n_b$ 但标记 $pure(n_b) = \\mathrm{true}$。构建 $n_{+1}$ 和 $n_{+2}$，使得 $children(n_{+1}) = (n_f, n_b)$ 和 $children(n_{+2}) = (n_{+1}, n_f)$。应用CSE规则：合并任何语法上相同且 $pure = \\mathrm{true}$ 的函数调用节点，这将允许在多次出现 $bar()$ 调用时合并它们。**\n\n此选项描述了一个危险且不正确的策略。它建议将一个函数（`$bar()`）标记为纯函数，即使它可能是不纯的。编译器在优化中的首要职责是保持程序的可观察语义。错误地将非纯函数注释为纯函数可能导致错误地消除必要的副作用，从而导致不正确的程序行为。这违反了安全优化的核心原则。\n\n**结论：不正确**\n\n**D. 为 $foo()$ 创建一个节点 $n_f$，为 $bar()$ 创建一个节点 $n_b$，不带任何纯度注释。构建 $n_{+1}$ 和 $n_{+2}$，使得 $children(n_{+1}) = (n_f, n_b)$ 和 $children(n_{+2}) = (n_{+1}, n_f)$。仅根据函数调用节点的被调用者名称和参数列表的语法相等性来应用CSE，而不考虑纯度，因此如果出现重复的调用（包括非纯调用），也会合并它们。**\n\n此选项描述了一种激进但不安全的策略。它违反了问题中明确的要求：“对DAG节点进行注释，以便CSE仅对表示纯函数调用的节点被允许”。通过完全忽略纯度并仅基于语法同一性执行CSE，该策略会错误地消除对非纯函数的调用。例如，如果表达式是 `$bar() + bar()$`，此策略将错误地只执行一次 `$bar()`$ 调用，从而消除了第二次调用的副作用。这是一个严重的语义错误。对于给定的表达式，生成的DAG看起来正确是巧合，这掩盖了其 underlying 策略的缺陷。\n\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3641864"}, {"introduction": "现在让我们深入探讨优化中最复杂的方面：内存。本练习模拟了一个程序读写内存的真实场景。它演示了为什么从同一内存地址加载数据并不总是构成公共子表达式，并引入了别名分析作为编译器的工具，用以推断一个内存位置是否可能被中间的存储操作所改变。这个实践是理解如何将基于 DAG 的优化安全地应用于与内存交互的程序的关键。[@problem_id:3641783]", "problem": "考虑两个$32$位整数数组$A$和$B$，一个可能指向某个内存区域的指针$P$，以及一个在以下线性代码片段中未被修改的整数索引$i$。假设$A$和$B$都未声明为volatile，并且没有函数调用。代码采用静态单赋值（SSA）形式，最终的计算表示为一个有向无环图（DAG），其中加载节点由地址表达式和表示其别名集相关抽象内存状态的内存版本标记进行注释。\n\n代码如下：\n$$\n\\begin{aligned}\nt_0 \\leftarrow A[i] \\\\\n*P \\leftarrow v \\\\\nt_1 \\leftarrow A[i] \\\\\nt_2 \\leftarrow B[i] \\\\\nx \\leftarrow t_0 + t_1 + t_2\n\\end{aligned}\n$$\n\n别名分析报告了以下事实：\n- $A$和$B$是不相交的数组：$\\mathrm{NoAlias}(A, B)$。\n- 指针$P$可能引用$A$区域，但不引用$B$区域：$\\mathrm{MayAlias}(P, A)$和$\\mathrm{NoAlias}(P, B)$。\n- 索引$i$在整个序列中保持不变。\n\n使用以下基本原理来推理表达式DAG：\n- 用于表达式的有向无环图（DAG）会合并相同纯计算的节点。\n- 从内存加载被视为一个依赖于相关抽象内存版本的节点；两个加载操作当且仅当它们从相同的内存版本读取相同的地址表达式，并且根据别名分析，在程序顺序上没有中间的存储操作可能写入该地址时，才能由一个共享的DAG节点表示。\n- 存储操作会更新其可能写入的别名集的抽象内存版本。\n\n在这些条件下，以下哪个陈述正确描述了用于$x$的DAG中的哪些加载节点可以共享，哪些必须是不同的？\n\nA. 将两个$A[i]$加载合并为一个DAG节点，因为地址表达式相同；将$B[i]$加载保留为一个单独的节点。\n\nB. 将两个$A[i]$加载保留为不同的DAG节点，因为中间通过$P$的存储可能与$A$别名，从而可能更新$A[i]$；$B[i]$加载是一个不受存储影响的单一节点，因为$P$不与$B$别名。\n\nC. 所有三个加载都必须是不同的DAG节点，因为任何中间的存储都会强制创建一个新的全局内存版本，无论别名信息如何。\n\nD. 将$A[i]$和$B[i]$加载合并为一个DAG节点，因为它们共享相同的索引$i$；别名结果与加载的DAG节点共享无关。", "solution": "问题陈述被评估为有效。这是一个定义明确的问题，基于编译器设计的既定原则，特别是关于通过有向无环图（DAG）进行代码优化和使用别名分析处理内存操作。给定的条件是自包含、一致的，并且足以推导出唯一的解决方案。\n\n这个问题的核心是确定哪些计算是冗余的，并且可以在DAG中用单个节点表示。对于加载操作，这受公共子表达式消除（CSE）原则的约束，在存在内存操作的情况下，该原则必须由别名分析来指导。\n\n让我们遵循给定的规则，追踪表达式$x \\leftarrow t_0 + t_1 + t_2$的DAG构建过程。关键是为每个相关的别名集追踪抽象内存状态，即“版本”。别名分析将内存划分为至少两个不相交的关注集：一个包含数组$A$，另一个包含数组$B$。指针$P$可能与包含$A$的集合别名，但不会与包含$B$的集合别名。\n\n设$M_A$为包含数组$A$的别名集的内存版本标记，设$M_B$为包含数组$B$的别名集的内存版本标记。\n\n最初，在代码片段执行之前，设内存版本为$M_A^{(0)}$和$M_B^{(0)}$。\n\n1.  **指令：$t_0 \\leftarrow A[i]$**\n    这是一个加载操作。地址由$A$的基址和索引$i$确定。为这个加载创建一个DAG节点。此节点依赖于地址表达式（我们可以表示为$\\mathrm{addr}(A[i])$）及其别名集的当前内存版本$M_A^{(0)}$。\n    此加载的节点是$\\mathrm{Load}(\\mathrm{addr}(A[i]), M_A^{(0)})$。变量$t_0$现在与此节点产生的值相关联。\n\n2.  **指令：$*P \\leftarrow v$**\n    这是一个存储操作。我们必须查阅别名分析结果来确定它对我们内存版本的影响。\n    -   $\\mathrm{MayAlias}(P, A)$: 通过指针$P$的存储*可能*会修改$A$内存区域内的某个位置。由于可能发生修改，保守的编译器必须假设此别名集的内存状态已改变。因此，内存版本$M_A$被更新。设新版本为$M_A^{(1)}$。\n    -   $\\mathrm{NoAlias}(P, B)$: 通过指针$P$的存储*不会*修改$B$内存区域内的任何位置。编译器可以对此确定。因此，$B$的内存状态不受影响，其版本仍为$M_B^{(0)}$。\n    此指令之后，活动的内存版本是$M_A^{(1)}$和$M_B^{(0)}$。\n\n3.  **指令：$t_1 \\leftarrow A[i]$**\n    这是从地址$\\mathrm{addr}(A[i])$的第二次加载。共享加载的DAG节点的规则是，它们必须从相同的地址和相同的内存版本读取。\n    -   地址表达式$\\mathrm{addr}(A[i])$与第一次加载相同。\n    -   但是，此加载发生在对$*P$的存储之后。$A$的别名集的当前内存版本是$M_A^{(1)}$。\n    因此，此加载由节点$\\mathrm{Load}(\\mathrm{addr}(A[i]), M_A^{(1)})$表示。\n    由于$M_A^{(1)} \\ne M_A^{(0)}$，此节点与为$t_0$创建的节点不同。来自$A[i]$的两个加载不能合并。\n\n4.  **指令：$t_2 \\leftarrow B[i]$**\n    这是从地址$\\mathrm{addr}(B[i])$的加载。\n    -   地址表达式$\\mathrm{addr}(B[i])$与$\\mathrm{addr}(A[i])$不同，因为$\\mathrm{NoAlias}(A, B)$。因此，仅凭这一点，此加载就不能与来自$A[i]$的加载共享节点。\n    -   此加载依赖于$B$的别名集的内存版本，即$M_B^{(0)}$。对$*P$的存储并未影响此版本。\n    此加载的节点是$\\mathrm{Load}(\\mathrm{addr}(B[i]), M_B^{(0)})$。\n\n5.  **指令：$x \\leftarrow t_0 + t_1 + t_2$**\n    此表达式组合了三个加载的结果。DAG将具有加法操作符节点，以上述推导出的三个不同的加载节点作为输入。\n\n总之，我们在DAG中需要三个不同的加载节点：\n-   一个用于$t_0 \\leftarrow A[i]$，依赖于内存版本$M_A^{(0)}$。\n-   第二个不同的节点用于$t_1 \\leftarrow A[i]$，依赖于内存版本$M_A^{(1)}$。\n-   第三个不同的节点用于$t_2 \\leftarrow B[i]$，依赖于不同的地址和内存版本$M_B^{(0)}$。\n\n现在，我们基于此推导评估每个选项。\n\n**A. 将两个$A[i]$加载合并为一个DAG节点，因为地址表达式相同；将$B[i]$加载保留为一个单独的节点。**\n此陈述**不正确**。虽然来自$A[i]$的两个加载的地址表达式确实相同，但这并不是合并它们DAG节点的充分条件。中间的存储操作$*P \\leftarrow v$可能与$A$别名（$\\mathrm{MayAlias}(P, A)$），这迫使编译器假设$A$的内存状态发生了变化。第一次加载依赖于存储*之前*的内存状态，而第二次加载依赖于存储*之后*的内存状态。由于内存版本不同，节点不能合并。\n\n**B. 将两个$A[i]$加载保留为不同的DAG节点，因为中间通过$P$的存储可能与$A$别名，从而可能更新$A[i]$；$B[i]$加载是一个不受存储影响的单一节点，因为$P$不与$B$别名。**\n此陈述**正确**。它准确地描述了情况。来自$A[i]$的两个加载必须由不同的节点表示，因为中间的存储$*P \\leftarrow v$对于来自$A$别名集的加载来说是一个“内存屏障”，这是由于$\\mathrm{MayAlias}(P, A)$这一事实。$A[i]$的值必须重新加载。该陈述还正确地指出，来自$B[i]$的加载不受此特定存储的影响，因为别名分析保证了没有重叠（$\\mathrm{NoAlias}(P, B)$）。\n\n**C. 所有三个加载都必须是不同的DAG节点，因为任何中间的存储都会强制创建一个新的全局内存版本，无论别名信息如何。**\n此陈述**不正确**。虽然所有三个加载都必须是不同的这一结论是正确的，但提供的推理是有缺陷的。该陈述声称“任何中间的存储都会强制创建一个新的全局内存版本，无论别名信息如何”。这是错误的。细粒度别名分析的全部目的就是*避免*将内存视为一个单一的整体块。在这里，对$*P$的存储更新了$A$的别名集的内存版本，但*没有*更新$B$的别名集。如果规则如C中所述，那么别名分析对于此优化将毫无用处。\n\n**D. 将$A[i]$和$B[i]$加载合并为一个DAG节点，因为它们共享相同的索引$i$；别名结果与加载的DAG节点共享无关。**\n此陈述**不正确**。它在两个基本点上存在缺陷。首先，从$A[i]$和$B[i]$加载会访问不同的内存地址，因为$A$和$B$是不同的数组（$\\mathrm{NoAlias}(A, B)$）。加载的DAG节点只有在地址相同时才能共享。共享索引$i$是无关紧要的。其次，“别名结果无关紧要”的说法是完全错误的，并且与内存感知编译器优化的基本原则以及问题陈述本身提供的规则相矛盾。别名分析是确定中间存储是否使先前加载无效的关键组成部分。", "answer": "$$\\boxed{B}$$", "id": "3641783"}]}