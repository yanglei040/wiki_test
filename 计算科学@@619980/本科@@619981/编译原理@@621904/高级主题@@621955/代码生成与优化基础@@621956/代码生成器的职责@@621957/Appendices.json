{"hands_on_practices": [{"introduction": "代码生成器的一项核心任务是将高级语言中的操作“降级”为目标机器的指令序列。通常，一个操作有多种实现方式，编译器必须根据目标架构的特性（如可用指令、延迟、吞吐量）选择最优方案。这个练习将通过一个位旋转操作，让你亲身体验在不同指令集下的性能权衡与决策过程 [@problem_id:3628158]。", "problem": "编译器的代码生成器必须将一个高级的、$64$ 位值 $x$ 按编译时常数 $k$ 进行的 $64$ 位右旋操作，降级为目标机器的操作。考虑一个目标指令集架构 (ISA)，它将一个 $64$ 位值表示为一个 $32$ 位寄存器的有序对 $(x_{\\mathrm{lo}}, x_{\\mathrm{hi}})$，并支持以下指令和机器资源：\n\n- 一个移位单元 $S$，执行 $64$ 位逻辑左移或右移。每次 $64$ 位移位操作的延迟为 $\\ell_{S} = 2$ 个周期。该单元是完全流水线化的，启动间隔为 $1$，并且只有一个这样的单元。\n- 一个布尔单元 $B$，执行 $64$ 位按位 $\\mathrm{OR}$ 操作。每次 $64$ 位 $\\mathrm{OR}$ 操作的延迟为 $\\ell_{B} = 1$ 个周期。该单元是完全流水线化的，启动间隔为 $1$，并且只有一个这样的单元。\n- 一个漏斗单元 $F$，执行形式为 $\\mathrm{FSR32}(a,b,s)$ 的 $32$ 位漏斗右移操作。该操作在概念上通过将 $a$ 放置在低半部分、$b$ 放置在高半部分来形成 $64$ 位值 $(b:a)$，然后将其逻辑右移 $s$ 位（其中 $0 \\le s \\le 31$），并返回低 $32$ 位。每次 $\\mathrm{FSR32}$ 操作的延迟为 $\\ell_{F} = 1$ 个周期。该单元是完全流水线化的，启动间隔为 $1$，并且只有一个这样的单元。\n\n对于按常数 $k$ 进行的右旋操作，代码生成器可以选择以下合法降级方案之一：\n\n- 移位-或降级方案：生成一个按 $k$ 位的 $64$ 位逻辑右移、一个按 $(64 - k)$ 位的 $64$ 位逻辑左移，以及一个对两个移位结果进行的 $64$ 位按位 $\\mathrm{OR}$ 操作。\n- 漏斗移位降级方案：生成两条 $\\mathrm{FSR32}$ 指令，以产生旋转后值的新低半部分和高半部分。当 $0 \\le k  32$ 时，使用 $(x_{\\mathrm{lo}}, x_{\\mathrm{hi}})$ 作为输入；当 $32 \\le k  64$ 时，交换输入顺序并使用移位量 $(k - 32)$。假设这两条 $\\mathrm{FSR32}$ 指令将其结果写入两个新的 $32$ 位目标寄存器中，因此不需要额外的移动操作，并且这两个目标寄存器的有序对即为最终结果。\n\n假设输入对 $(x_{\\mathrm{lo}}, x_{\\mathrm{hi}})$ 在周期 $0$ 时可用，常数 $k$ 嵌入在指令中，不存在缓存或取指效应，并且调度仅受数据依赖和上述单实例功能单元的约束。使用基本块调度中的标准概念，即一条指令的结果在其发射后恰好 $\\ell$ 个周期后变得可用，其中 $\\ell$ 是该指令的延迟。\n\n对于特定常数 $k = 37$，当代码生成器选择最佳可用降级方案，并且调度器在资源和依赖约束下尽早发射指令时，确定计算旋转后的 $64$ 位结果所需的最小可能完成时间（以周期为单位）。请将您的最终答案表示为单个整数周期数（最终方框答案中不含单位）。", "solution": "用户要求计算按常数 $k=37$ 进行 $64$ 位右旋操作的最小完成时间。解决方案需要在具有指定功能单元和延迟的目标架构上，分析两种不同的实现策略（即“降级方案”），然后选择两者中较快的一个。分析将通过为每个降级方案构建一个遵守数据依赖和资源约束的调度来进行。“尽早”调度策略被应用，并且所有功能单元都是完全流水线化的，启动间隔为 $1$。\n\n输入的 $64$ 位值 $x$ 由一对 $32$ 位寄存器 $(x_{\\mathrm{lo}}, x_{\\mathrm{hi}})$ 表示，我们将其解释为值 $x = (x_{\\mathrm{hi}} \\ll 32) | x_{\\mathrm{lo}}$，其中 `|` 表示按位或，`` 表示逻辑左移。输入在周期 $0$ 时可用。\n\n### 策略 1：移位-或降级方案\n\n该策略使用其定义来实现 $64$ 位右旋操作 $\\mathrm{ROTR}(x, k)$：\n$$ \\mathrm{ROTR}(x, k) = (x \\gg k) | (x \\ll (64 - k)) $$\n其中 `>>` 是逻辑右移。对于 $k=37$，操作如下：\n1.  `Op1`: $t_1 = x \\gg 37$。这是一个 $64$ 位逻辑右移。\n2.  `Op2`: $t_2 = x \\ll (64 - 37) = x \\ll 27$。这是一个 $64$ 位逻辑左移。\n3.  `Op3`: $y = t_1 | t_2$。这是一个 $64$ 位按位 $\\mathrm{OR}$。\n\n我们根据这些操作的依赖关系和资源需求来调度它们。\n- **依赖关系**：`Op1` 和 `Op2` 依赖于输入 $x$（在周期 $0$ 时可用）。`Op3` 依赖于 `Op1` 和 `Op2` 的结果。\n- **资源**：`Op1` 和 `Op2` 都需要移位单元 $S$。`Op3` 需要布尔单元 $B$。\n- **延迟**：移位单元的延迟为 $\\ell_S = 2$ 个周期。布尔单元的延迟为 $\\ell_B = 1$ 个周期。\n- **流水线**：所有单元的启动间隔都为 $1$，这意味着每个周期都可以向一个单元发射一条新指令。\n\n调度过程如下：\n- **周期 0**：输入 $x$ 可用。`Op1` 和 `Op2` 都已就绪。我们可以将其中一个发射到移位单元 $S$。我们发射 `Op1`。\n  - 在周期 $0$ 发射 `Op1` ($x \\gg 37$)。它使用单元 $S$。\n  - 结果 $t_1$ 将在周期 $0 + \\ell_S = 2$ 时可用。\n- **周期 1**：`Op2` 已就绪。移位单元 $S$ 可用于新指令，因为其启动间隔为 $1$。\n  - 在周期 $1$ 发射 `Op2` ($x \\ll 27$)。它使用单元 $S$。\n  - 结果 $t_2$ 将在周期 $1 + \\ell_S = 3$ 时可用。\n- **周期 2**：结果 $t_1$ 变得可用。`Op3` 尚未就绪，因为它仍在等待 $t_2$。\n- **周期 3**：结果 $t_2$ 变得可用。现在 `Op3` 的两个输入（$t_1$ 和 $t_2$）都已就绪。布尔单元 $B$ 可用。\n  - 在周期 $3$ 发射 `Op3` ($t_1 | t_2$)。它使用单元 $B$。\n  - 最终结果 $y$ 将在周期 $3 + \\ell_B = 4$ 时可用。\n\n移位-或降级方案的完成时间为 $4$ 个周期。\n\n### 策略 2：漏斗移位降级方案\n\n该策略使用两条特殊的 $32$ 位漏斗移位指令 $\\mathrm{FSR32}(a, b, s)$，该指令计算 $64$ 位值 $(b:a)$ 逻辑右移 $s$ 位后的低 $32$ 位。该操作等效于 $(b \\ll (32-s)) | (a \\gg s)$。问题描述指出，对于 $32 \\le k  64$ 的情况，输入顺序被交换，移位量为 $s = k - 32$。在我们的特定情况下，$k=37$，因此移位量为 $s = 37 - 32 = 5$。这两条 $\\mathrm{FSR32}$ 指令必须计算旋转后结果的新低半部分和高半部分，我们称之为 $y_{\\mathrm{lo}}$ 和 $y_{\\mathrm{hi}}$。\n\n让我们推导由 $\\mathrm{ROTR}(x, 37)$ 产生的 $y_{\\mathrm{lo}}$ 和 $y_{\\mathrm{hi}}$ 的表达式：\n新的低半部分 $y_{\\mathrm{lo}}$ 由 $(x \\gg 37)$ 和 $(x \\ll 27)$ 的低 $32$ 位组成。\n$$ y_{\\mathrm{lo}} = (x_{\\mathrm{lo}} \\ll 27) | (x_{\\mathrm{hi}} \\gg 5) $$\n新的高半部分 $y_{\\mathrm{hi}}$ 由相同表达式的高 $32$ 位组成。\n$$ y_{\\mathrm{hi}} = (x_{\\mathrm{hi}} \\ll 27) | (x_{\\mathrm{lo}} \\gg 5) $$\n我们必须将这些表达式与 $\\mathrm{FSR32}$ 指令进行匹配。当 $s=5$ 时：\n- 为了计算 $y_{\\mathrm{lo}} = (x_{\\mathrm{lo}} \\ll 27) | (x_{\\mathrm{hi}} \\gg 5)$：我们设置 $a = x_{\\mathrm{hi}}$ 和 $b = x_{\\mathrm{lo}}$。\n  - `OpA`: $y_{\\mathrm{lo}} = \\mathrm{FSR32}(x_{\\mathrm{hi}}, x_{\\mathrm{lo}}, 5)$。\n- 为了计算 $y_{\\mathrm{hi}} = (x_{\\mathrm{hi}} \\ll 27) | (x_{\\mathrm{lo}} \\gg 5)$：我们设置 $a = x_{\\mathrm{lo}}$ 和 $b = x_{\\mathrm{hi}}$。\n  - `OpB`: $y_{\\mathrm{hi}} = \\mathrm{FSR32}(x_{\\mathrm{lo}}, x_{\\mathrm{hi}}, 5)$。\n\n现在，我们来调度 `OpA` 和 `OpB`。\n- **依赖关系**：`OpA` 和 `OpB` 都依赖于在周期 $0$ 时可用的输入 $x_{\\mathrm{lo}}$ 和 $x_{\\mathrm{hi}}$。这两个操作相互独立。\n- **资源**：`OpA` 和 `OpB`都需要漏斗单元 $F$。\n- **延迟**：漏斗单元的延迟为 $\\ell_F = 1$ 个周期。\n- **流水线**：该单元的启动间隔为 $1$。\n\n调度过程如下：\n- **周期 0**：输入可用。`OpA` 和 `OpB` 都已就绪。我们将其中一个发射到漏斗单元 $F$。我们发射 `OpA`。\n  - 在周期 $0$ 发射 `OpA` ($\\mathrm{FSR32}(x_{\\mathrm{hi}}, x_{\\mathrm{lo}}, 5)$)。它使用单元 $F$。\n  - 结果 $y_{\\mathrm{lo}}$ 将在周期 $0 + \\ell_F = 1$ 时可用。\n- **周期 1**：`OpB` 已就绪。单元 $F$ 可用于新指令。\n  - 在周期 $1$ 发射 `OpB` ($\\mathrm{FSR32}(x_{\\mathrm{lo}}, x_{\\mathrm{hi}}, 5)$)。它使用单元 $F$。\n  - 结果 $y_{\\mathrm{hi}}$ 将在周期 $1 + \\ell_F = 2$ 时可用。\n\n完整的 $64$ 位结果 $(y_{\\mathrm{lo}}, y_{\\mathrm{hi}})$ 只有在两个半部分都计算完毕后才可用。第一个半部分 $y_{\\mathrm{lo}}$ 在周期 $1$ 时就绪。第二个半部分 $y_{\\mathrm{hi}}$ 在周期 $2$ 时就绪。因此，总完成时间是这两个就绪时间的最大值。\n完成时间 = $\\max(1, 2) = 2$ 个周期。\n\n### 结论\n\n比较两种策略：\n- 移位-或降级方案完成时间：$4$ 个周期。\n- 漏斗移位降级方案完成时间：$2$ 个周期。\n\n代码生成器选择最佳（最快）的可用降级方案。在这种情况下，漏斗移位降级方案更优。最小可能完成时间是 $2$ 个周期。", "answer": "$$\\boxed{2}$$", "id": "3628158"}, {"introduction": "除了单个操作，代码生成器还负责优化标准库函数的调用，例如 `memcmp`。现代编译器采用向量化（SIMD）等高级策略来大幅提升这类内存密集型函数的性能。本练习将带你深入研究这种优化的实际细节，包括处理内存对齐和剩余字节的“尾部”问题，展示了编译器如何生成高效的专用代码 [@problem_id:3628165]。", "problem": "编译器的代码生成器正在将对标准内存比较函数 `memcmp` 的一个高级调用降级为一个控制流结构。该结构在可能的情况下使用带有对齐向量加载的提前退出比较，并对尾部数据进行标量清理。内存比较的语义如下：给定两个等长（长度为 $L$）的字节数组 $A$ 和 $B$，操作在发现 $A[i] \\neq B[i]$ 的第一个索引 $i$ 处立即返回，此时已经比较了所有之前的字节 $0, 1, \\ldots, i-1$ 且发现它们均相等。\n\n代码生成器采用以下降级策略，在对齐允许的情况下，依赖单指令多数据（SIMD）向量加载：\n\n1. 序言（头部对齐）：如果 $A$ 和 $B$ 的起始地址具有相同的模 SIMD 宽度 $w$ 的余数，则生成器会发出标量字节比较指令，直到两个指针都前进到下一个 $w$ 字节边界。这个头部的长度为 $h = (w - (p \\bmod w)) \\bmod w$，其中 $p$ 是 $A$ 的起始地址，且两个地址模 $w$ 的余数相同。如果在此头部发现不匹配，操作将提前返回。\n2. 主循环（对齐向量）：当至少还剩 $w$ 个字节时，生成器会发出从 $A$ 和 $B$ 加载 $w$ 字节的对齐 SIMD 指令并进行比较。如果加载的向量相等，则循环继续；否则，操作将在此 $w$ 字节块内执行标量搜索，以定位第一个不同的字节并返回。如果所有完整的向量都相等，控制流将转到尾部处理。\n3. 结尾（尾部）：任何剩余的 $t$ 个字节（少于 $w$ 个）都将逐字节比较。操作在检测到尾部第一个不匹配时立即返回。\n\n假设存在以下具体的、科学上合理的条件，这些条件由代码生成器在编译时确定或在运行时验证：\n\n- 总长度为 $L = 313$ 字节。\n- SIMD 向量宽度为 $w = 16$ 字节。\n- $A$ 和 $B$ 的起始地址具有相同的模 $w$ 余数，即 $p \\bmod w = q \\bmod w = 12$。因此，头部长为 $h = (w - (p \\bmod w)) \\bmod w$。\n- 所有字节都相等，直到在全局索引 $m = 310$（从 A 和 B 的开头开始，以零为基准）处出现一个不匹配，即对于所有 $i  m$，有 $A[i] = B[i]$，而 $A[m] \\neq B[m]$。\n- 动态周期的微体系结构成本模型为：\n  - 每个标量字节比较花费 $1$ 个周期。\n  - 每个相等的 $w$ 字节块的对齐向量比较包括两次对齐的 SIMD 加载和一次向量相等性操作，每次 SIMD 加载花费 $4$ 个周期，向量比较花费 $1$ 个周期。\n  - 没有分支预测错误惩罚，也没有缓存未命中；忽略地址生成成本。如果在向量块中发现不匹配，块内标量搜索的成本是每个被检查字节进行一次标量比较，但在这种特定情况下，不匹配不在任何完整的向量块中。\n- 代码生成器保证不会访问越界内存；对齐的向量加载仅针对由 $L$ 所隐含的边界内完全覆盖的 $w$ 字节块发出。\n\n在这些条件下，计算直到操作在第一个不匹配处返回所花费的中央处理器（CPU）总周期数。以周期为单位，用一个没有四舍五入的精确整数表示你的最终答案。", "solution": "该问题要求计算内存比较操作 `memcmp` 的一个特定实现在找到第一个不匹配并返回之前所消耗的 CPU 总周期数。解决方案是通过系统地分析所述操作的三个阶段得出的：序言、主循环和结尾。\n\n首先，我们用符号表示法定义给定的参数：\n-   数组总长度：$L = 313$ 字节。\n-   SIMD 向量宽度：$w = 16$ 字节。\n-   数组 $A$ 和 $B$ 的起始地址（分别用 $p$ 和 $q$ 表示）具有相同的模 $w$ 余数：$p \\bmod w = q \\bmod w = 12$。\n-   第一个不匹配的索引：$m = 310$（从零开始）。对于所有索引 $i  m$，$A[i] = B[i]$，而在索引 $m$ 处，$A[m] \\neq B[m]$。\n-   单个标量字节比较的成本：$C_{scalar} = 1$ 个周期。\n-   比较两个相等的 $w$ 字节对齐向量的成本：这包括两次 SIMD 加载（每次 4 个周期）和一次向量相等性测试（1 个周期）。因此，$C_{vector} = 2 \\times 4 + 1 = 9$ 个周期。\n\n总周期数 $C_{total}$ 将是直到检测到索引 $m$ 处不匹配为止，所执行的每个操作阶段的周期数之和。\n\n**1. 序言（头部对齐）**\n\n序言执行标量字节比较，以将内存指针与下一个 $w$ 字节边界对齐。此头部区域比较的字节数 $h$ 由以下公式给出：\n$$h = (w - (p \\bmod w)) \\bmod w$$\n代入给定值：\n$$h = (16 - 12) \\bmod 16 = 4 \\bmod 16 = 4$$\n头部包含前 4 个字节，对应于索引 $0, 1, 2$ 和 $3$。由于第一个不匹配发生在索引 $m=310$ 处，因此头部中的所有字节都相等。所以，执行了 4 次标量比较。\n\n序言的成本 $C_{head}$ 是：\n$$C_{head} = h \\times C_{scalar} = 4 \\times 1 = 4 \\text{ 个周期}$$\n序言结束后，已处理 4 个字节。待比较的剩余长度为 $L - h = 313 - 4 = 309$ 字节。此时指针与 16 字节边界对齐。\n\n**2. 主循环（对齐向量比较）**\n\n主循环使用 SIMD 指令比较完整的 $w$ 字节块。只要待比较的字节数至少为 $w$，该循环就会继续。在剩余的 309 个字节中，完整向量块的数量 $N_{vector}$ 是：\n$$N_{vector} = \\left\\lfloor \\frac{L - h}{w} \\right\\rfloor = \\left\\lfloor \\frac{309}{16} \\right\\rfloor = \\lfloor 19.3125 \\rfloor = 19$$\n这 19 个向量块总共覆盖 $19 \\times w = 19 \\times 16 = 304$ 字节。这些字节对应的全局索引从 $h=4$ 开始，直到 $h + (N_{vector} \\times w) - 1 = 4 + 304 - 1 = 307$。\n\n不匹配发生在索引 $m=310$ 处，该索引在主循环覆盖的索引范围 $[4, 307]$ 之外。这证实了问题的前提，即不匹配不会发生在任何完整的向量块内。因此，所有 19 个向量块都被认为是相等的。\n\n主循环的成本 $C_{loop}$ 是向量块的数量乘以每个块的成本：\n$$C_{loop} = N_{vector} \\times C_{vector} = 19 \\times 9 = 171 \\text{ 个周期}$$\n\n**3. 结尾（尾部比较）**\n\n主循环结束后，剩余的字节构成尾部，使用标量字节比较进行处理。\n尾部之前处理的字节数为 $h + (N_{vector} \\times w) = 4 + 304 = 308$ 字节。\n尾部的字节数 $t$ 为：\n$$t = L - (h + N_{vector} \\times w) = 313 - 308 = 5$$\n尾部覆盖了从 308 到 312 的全局索引。比较过程如下：\n-   索引 308：比较 $A[308]$ 和 $B[308]$。它们相等（$308  m$）。花费 1 个周期。\n-   索引 309：比较 $A[309]$ 和 $B[309]$。它们相等（$309  m$）。花费 1 个周期。\n-   索引 310：比较 $A[310]$ 和 $B[310]$。发现不匹配（$310 = m$）。花费 1 个周期，`memcmp` 操作终止并返回。\n\n对索引 311 和 312 的比较不会执行。总计，在结尾部分执行了 3 次标量比较。比较的次数是 $(m - \\text{尾部起始索引}) + 1 = (310 - 308) + 1 = 3$。\n\n结尾部分的成本 $C_{tail}$ 是：\n$$C_{tail} = 3 \\times C_{scalar} = 3 \\times 1 = 3 \\text{ 个周期}$$\n\n**4. CPU 总周期数**\n\nCPU 总周期数是所有三个阶段的周期数之和：\n$$C_{total} = C_{head} + C_{loop} + C_{tail}$$\n$$C_{total} = 4 + 171 + 3 = 178$$\n\n直到操作在第一个不匹配处返回所花费的 CPU 总周期数为 $178$。", "answer": "$$\\boxed{178}$$", "id": "3628165"}, {"introduction": "在选择了指令之后，代码生成器面临着资源管理的挑战：如何将程序中大量的临时变量分配到有限的物理寄存器中。当寄存器不足时（即寄存器压力过高），一些变量必须被“溢出”到内存栈中。本练习将探讨如何通过分析变量的生命周期和重用栈空间来智能地管理溢出代码，从而最小化程序的内存开销 [@problem_id:3628173]。", "problem": "一个简单命令式语言的代码生成器，其目标机器上只有 $2$ 个物理寄存器可用于存放临时变量。单个线性基本块的中间表示 (IR) 由程序点 $\\{1,2,\\dots,16\\}$ 索引。五个临时变量 $t_1, t_2, t_3, t_4, t_5$ 具有以下活跃段（记号 $[a,b]$ 表示该临时变量在每个满足 $a \\leq p \\leq b$ 的整数程序点 $p$ 处都是活跃的，而 $\\cup$ 表示因生命周期空洞而产生的不相交活跃段），并且每个临时变量在被溢出时都有一个关联的存储宽度（以字节为单位）：\n\n- $t_1$：活跃于 $[1,5] \\cup [9,11]$，宽度 $8$。\n- $t_2$：活跃于 $[3,7]$，宽度 $4$。\n- $t_3$：活跃于 $[4,5] \\cup [9,10]$，宽度 $4$。\n- $t_4$：活跃于 $[2,4] \\cup [10,12]$，宽度 $16$。\n- $t_5$：活跃于 $[8,15]$，宽度 $4$。\n\n在任何程序点 $p$，至多有 $2$ 个活跃的临时变量可以占用寄存器。在程序点 $p$ 处，每个未占用寄存器的活跃临时变量都被视为在该点溢出，并且必须占用一个大小至少为其宽度值的栈槽。代码生成器可以随时间改变寄存器中的临时变量，并且可以为不同的溢出临时变量重用同一个栈槽，只要它们溢出后的活跃段在时间上不重叠。一个栈槽的大小固定为曾占用过它的所有临时变量中的最大宽度。假设槽之间没有填充，并且由溢出槽贡献的栈帧大小是其所有槽大小的总和。目标是在所有程序点上选择哪些临时变量占用寄存器，并将溢出的段着色到一组最小的栈槽上，从而最小化由溢出槽造成的总栈帧大小。\n\n基于以上信息，计算最小的总栈帧大小（以字节为单位）。最终答案以字节表示，无需四舍五入。", "solution": "解决此问题的关键在于系统地分析每个程序点的寄存器压力，并应用一种策略来最小化因溢出造成的栈帧大小。最优策略是在出现寄存器冲突时，优先将宽度最大的变量保留在寄存器中，因为栈槽的大小由曾占用它的最宽的变量决定。\n\n**步骤 1：确定每个程序点的活跃变量集**\n\n我们首先列出在每个程序点 $p$ 处活跃的临时变量集合 $L(p)$：\n-   $L(1) = \\{t_1\\}$\n-   $L(2) = \\{t_1, t_4\\}$\n-   $L(3) = \\{t_1, t_2, t_4\\}$\n-   $L(4) = \\{t_1, t_2, t_3, t_4\\}$\n-   $L(5) = \\{t_1, t_2, t_3\\}$\n-   $L(6) = \\{t_2\\}$\n-   $L(7) = \\{t_2\\}$\n-   $L(8) = \\{t_5\\}$\n-   $L(9) = \\{t_1, t_3, t_5\\}$\n-   $L(10) = \\{t_1, t_3, t_4, t_5\\}$\n-   $L(11) = \\{t_1, t_4, t_5\\}$\n-   $L(12) = \\{t_4, t_5\\}$\n-   $L(13) = \\{t_5\\}$\n-   $L(14) = \\{t_5\\}$\n-   $L(15) = \\{t_5\\}$\n-   $L(16) = \\emptyset$\n\n**步骤 2：识别冲突点并决定溢出变量**\n\n由于只有 $2$ 个物理寄存器，当 $|L(p)| > 2$ 时就会发生冲突。我们根据变量宽度（$t_4$: 16字节, $t_1$: 8字节, $t_2, t_3, t_5$: 4字节）决定在冲突点保留哪两个变量。\n\n-   $p=3: |L(3)|=3$。活跃变量为 $\\{t_1(8), t_2(4), t_4(16)\\}$。保留最宽的 $t_4$ 和 $t_1$。**溢出 $t_2$**。\n-   $p=4: |L(4)|=4$。活跃变量为 $\\{t_1(8), t_2(4), t_3(4), t_4(16)\\}$。保留 $t_4$ 和 $t_1$。**溢出 $t_2$ 和 $t_3$**。\n-   $p=5: |L(5)|=3$。活跃变量为 $\\{t_1(8), t_2(4), t_3(4)\\}$。保留 $t_1$ 和 $t_2$。**溢出 $t_3$**。\n-   $p=9: |L(9)|=3$。活跃变量为 $\\{t_1(8), t_3(4), t_5(4)\\}$。保留 $t_1$ 和 $t_5$。**溢出 $t_3$**。\n-   $p=10: |L(10)|=4$。活跃变量为 $\\{t_1(8), t_3(4), t_4(16), t_5(4)\\}$。保留 $t_4$ 和 $t_1$。**溢出 $t_3$ 和 $t_5$**。\n-   $p=11: |L(11)|=3$。活跃变量为 $\\{t_1(8), t_4(16), t_5(4)\\}$。保留 $t_4$ 和 $t_1$。**溢出 $t_5$**。\n\n此策略成功地避免了溢出宽度为 16 或 8 字节的变量（$t_4, t_1$），所有被溢出的变量（$t_2, t_3, t_5$）宽度均为 4 字节。\n\n**步骤 3：确定所需的最少栈槽数量**\n\n栈槽的数量由在任何单个程序点上同时溢出的变量的最大数量决定。\n-   在 $p=4$，我们同时溢出 $t_2$ 和 $t_3$（2个变量）。\n-   在 $p=10$，我们同时溢出 $t_3$ 和 $t_5$（2个变量）。\n-   在其他冲突点，我们最多只溢出 1 个变量。\n\n因此，同时溢出变量的最大数量是 2。这意味着我们至少需要 2 个栈槽。\n\n**步骤 4：分配栈槽并计算总大小**\n\n我们可以将溢出的变量分配到两个栈槽（$S_1$ 和 $S_2$），以确保重叠的溢出段位于不同的槽中。\n-   **溢出段**：\n    -   $t_2$ 的溢出段：$[3,4]$\n    -   $t_3$ 的溢出段：$[4,5] \\cup [9,10]$\n    -   $t_5$ 的溢出段：$[10,11]$\n-   **分配**：\n    -   在 $p=4$，$t_2$ 和 $t_3$ 同时溢出，它们必须在不同的槽中。分配 $t_2$ 到 $S_1$， $t_3$ 到 $S_2$。\n    -   在 $p=10$，$t_3$ 和 $t_5$ 同时溢出。$t_3$ 已经在 $S_2$ 中，所以分配 $t_5$ 到 $S_1$。\n-   **可行性检查**：\n    -   $S_1$ 用于溢出的 $t_2$（区间 $[3,4]$）和 $t_5$（区间 $[10,11]$）。这两个区间不重叠。\n    -   $S_2$ 用于溢出的 $t_3$（区间 $[4,5] \\cup [9,10]$）。\n    -   这个分配是有效的。\n\n现在计算每个槽的大小和总栈帧大小。\n-   $S_1$ 的大小：由占用它的变量的最大宽度决定。$S_1$ 容纳了 $t_2$ 和 $t_5$。$\\max(\\text{宽度}(t_2), \\text{宽度}(t_5)) = \\max(4, 4) = 4$ 字节。\n-   $S_2$ 的大小：$S_2$ 容纳了 $t_3$。$\\text{宽度}(t_3) = 4$ 字节。\n-   **总栈帧大小** = $S_1$ 的大小 + $S_2$ 的大小 = $4 + 4 = 8$ 字节。\n\n通过优先保留宽变量，我们将溢出限制在窄变量上，并使用了最少数量的槽，从而实现了最小的栈帧大小。", "answer": "$$\\boxed{8}$$", "id": "3628173"}]}