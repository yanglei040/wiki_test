{"hands_on_practices": [{"introduction": "要将在指令选择中学到的理论付诸实践，最好的方法莫过于亲自动手。我们从一个经典的优化问题开始：用更快的指令序列替换昂贵的乘法运算。这项练习将探索如何利用常数的二进制表示，通过移位和加减法操作来实现“强度折减”，从而生成更高效的代码。通过解决这个问题[@problem_id:3646809]，你将深入理解编译器如何利用算术恒等式来优化计算。", "problem": "一个编译器后端的目标架构的指令集包含三个相关操作，其语义和成本如下：\n- 立即数左移：对于任意寄存器值 $v$ 和非负整数 $p$，该操作返回 $v \\ll p$，成本为 $c_{s} = 3$ 个周期。\n- 两寄存器相加：对于任意寄存器值 $u$ 和 $v$，该操作返回 $u + v$，成本为 $c_{a} = 5$ 个周期。\n- 两寄存器相减：对于任意寄存器值 $u$ 和 $v$，该操作返回 $u - v$，成本为 $c_{a} = 5$ 个周期。\n\n假设寄存器数量无限，且寄存器之间的值复制成本可忽略不计。当 $p=0$ 时，左移操作为空操作（no-op），成本为零。编译器必须仅使用这些操作来实现与一个已知的固定整数常量 $k$ 的乘法。目标程序为输入寄存器 $x$ 计算 $y = k \\cdot x$。指令选择器被限制于将 $y$ 构造成带符号的 $x$ 移位实例的有限线性组合的策略，具体形式为 $y = \\sum_{i=1}^{m} s_{i} \\cdot (x \\ll p_{i})$，其中每个 $s_{i} \\in \\{+1,-1\\}$ 且每个 $p_{i}$ 是一个非负整数。该组合通过二元加法和减法实现；不允许使用其他操作。\n\n从二进制表示的基本事实和恒等式 $x \\ll p = x \\cdot 2^{p}$ 出发，推导在此限制下，当 $k = 1023$ 时成本最小的指令序列。将最小总成本以单个实数值（单位：周期）表示。无需四舍五入。", "solution": "用户希望我解决这个问题。我将首先进行验证。\n\n### 第1步：提取已知条件\n- 操作1：左移。$v \\ll p$。对于非负整数 $p > 0$，成本为 $c_{s} = 3$ 个周期。对于 $p=0$，成本为 $0$。\n- 操作2：加法。$u + v$。成本为 $c_{a} = 5$ 个周期。\n- 操作3：减法。$u - v$。成本为 $c_{a} = 5$ 个周期。\n- 假设：无限寄存器。\n- 假设：寄存器复制成本可忽略。\n- 恒等式：$x \\ll p = x \\cdot 2^{p}$。\n- 任务：为已知的固定整数常量 $k$ 实现 $y = k \\cdot x$。\n- 限制：实现必须具有形式 $y = \\sum_{i=1}^{m} s_{i} \\cdot (x \\ll p_{i})$，其中 $s_{i} \\in \\{+1,-1\\}$ 且 $p_{i}$ 是非负整数。该和通过二元加法和减法计算。\n- 特定情况：$k = 1023$。\n- 目标：找到最小总成本（以周期为单位）。\n\n### 第2步：使用提取的已知条件进行验证\n1.  **科学或事实的合理性**：该问题基于计算机算术和编译器优化的既定原则，特别是针对常数乘法的强度削减。恒等式 $x \\ll p = x \\cdot 2^{p}$ 是二进制表示的基本属性。这些操作在类 RISC 架构中是标准的。该问题在科学上是合理的。\n2.  **不可形式化或不相关**：该问题在指定的约束条件下可以高度形式化为一个优化问题。它直接关系到编译器设计中的指令选择策略。\n3.  **不完整或矛盾的设置**：该问题是自洽的。它提供了允许的操作集、它们的成本、解决方案的结构以及要实现的特定常量 $k$。成本定义明确，包括 $p=0$ 时的零成本情况。没有矛盾之处。\n4.  **不现实或不可行**：该设置是现实世界编译器问题的一个简化但合理的模型。无限寄存器的假设是这类分析中常见的简化。数据和条件在模型内部是一致且可行的。\n5.  **不适定或结构不良**：该问题是适定的。它要求最小成本，这定义了一个明确的优化目标。搜索空间是 $k$ 表示为 2 的幂的和/差的集合。存在一个最小解，并且在成本上是唯一的。\n6.  **伪深刻、琐碎或同义反复**：该问题并非琐碎。它需要比较表示常量 $k$ 的不同策略，并计算相关成本以找到最优解。多种表示形式（例如，标准二进制与非相邻形式）的存在使得优化并非显而易见。\n7.  **超出科学可验证性**：该解决方案可通过直接计算和比较不同有效指令序列的成本来验证。\n\n### 第3步：结论与行动\n问题是有效的。我将继续进行解答。\n\n该问题要求使用移位、加法和减法操作序列，计算 $y = k \\cdot x$（其中 $k = 1023$）的最小成本。允许的计算结构是 $y = \\sum_{i=1}^{m} s_{i} \\cdot (x \\ll p_{i})$，其中 $s_i \\in \\{+1,-1\\}$。这等同于找到常数 $k$ 的一种 $k = \\sum_{i=1}^{m} s_{i} \\cdot 2^{p_{i}}$ 形式的表示，使得总指令成本最小化。\n\n总成本 $C$ 是移位操作的成本与加法/减法操作的成本之和。\n要计算 $y$，我们首先需要生成 $m$ 个形如 $x \\ll p_i$ 的项。然后，这 $m$ 个项必须使用 $m-1$ 次加法或减法进行组合。\n\n让我们更精确地定义成本函数。\n- 一次移位 $x \\ll p_i$ 的成本，如果 $p_i > 0$ 则为 $c_s = 3$，如果 $p_i = 0$ 则为 $0$。设 $N_s$ 是和式中 $p_i > 0$ 的项数。移位的总成本是 $N_s \\cdot c_s$。\n- 组合 $m$ 个项需要 $m-1$ 次二元运算（加法或减法）。每次运算的成本是 $c_a = 5$。这些运算的总成本是 $(m-1) \\cdot c_a$。\n\n因此，给定表示的总成本 $C$ 为：\n$$C = N_s \\cdot c_s + (m-1) \\cdot c_a$$\n代入给定的成本 $c_s = 3$ 和 $c_a = 5$：\n$$C = 3N_s + 5(m-1)$$\n\n为了最小化 $C$，我们必须为 $k=1023$ 找到一个能使 $m$ 和 $N_s$ 最小化的表示。由于 $c_a > c_s$，最小化 $m$（项的数量）是降低成本的主要因素。\n\n我们将探讨两种表示 $k = 1023$ 的策略。\n\n**策略1：标准二进制表示**\n\n首先，我们将 $k=1023$ 表示为其标准二进制形式。 $1023$ 是 $2^{10} - 1$。在二进制中，这是一串十个 $1$：$1111111111_{2}$。这对应于以下和式：\n$$k = 1023 = \\sum_{i=0}^{9} 1 \\cdot 2^i = 2^9 + 2^8 + 2^7 + 2^6 + 2^5 + 2^4 + 2^3 + 2^2 + 2^1 + 2^0$$\n对于这种表示：\n- 项数为 $m = 10$。\n- 幂 $p_i$ 为 $\\{9, 8, 7, 6, 5, 4, 3, 2, 1, 0\\}$。\n- $p_i > 0$ 的移位数是 $N_s = 9$。项 $2^0$ 对应于 $x \\ll 0$，其成本为 $0$。\n- 将这 $10$ 个项相加所需的加法次数为 $m-1 = 9$。\n\n此策略的总成本 $C_1$ 为：\n$$C_1 = 3 \\cdot N_s + 5 \\cdot (m-1) = 3 \\cdot 9 + 5 \\cdot (10-1) = 27 + 5 \\cdot 9 = 27 + 45 = 72$$\n因此，使用标准二进制展开的成本是 $72$ 个周期。\n\n**策略2：使用减法的表示（非相邻形式）**\n\n二进制表示中一串连续的 $1$ 可以使用恒等式 $\\sum_{i=j}^{n-1} 2^i = 2^n - 2^j$ 来简化。对于 $k=1023$，即 $\\sum_{i=0}^{9} 2^i$，我们有 $n=10$ 和 $j=0$。\n$$k = 1023 = 2^{10} - 2^0 = 1024 - 1$$\n这是 $k$ 表示为两个 $2$ 的幂的差的形式。\n$$k = 1 \\cdot 2^{10} + (-1) \\cdot 2^0$$\n对于这种表示：\n- 项是 $2^{10}$ 和 $-2^0$。项数为 $m=2$。\n- 幂 $p_i$ 为 $\\{10, 0\\}$。\n- $p_i > 0$ 的移位数是 $N_s = 1$（对于 $p_1=10$ 项）。$p_2=0$ 项的移位成本为零。\n- 组合这 $2$ 个项所需的操作次数为 $m-1 = 1$（一次减法）。\n\n此策略的总成本 $C_2$ 为：\n$$C_2 = 3 \\cdot N_s + 5 \\cdot (m-1) = 3 \\cdot 1 + 5 \\cdot (2-1) = 3 + 5 = 8$$\n所以，使用这种更紧凑表示的成本是 $8$ 个周期。\n\n**最优性分析**\n\n我们找到了两个可能的成本，$C_1 = 72$ 和 $C_2 = 8$。到目前为止找到的最小成本是 $8$。我们必须确定是否存在更低的成本。\n成本函数 $C = 3N_s + 5(m-1)$ 随 $m$ 和 $N_s$ 的增加而增加。为了达到最小成本，我们必须使用 $m$ 和 $N_s$ 的最小可能值。\n\n- $m=1$ 的表示意味着 $k$ 是 $2$ 的幂。由于 $1023$ 不是 $2$ 的幂，我们必须有 $m \\ge 2$。\n- 表示 $k = 2^{10} - 1$ 使用了最少的项数，即 $m=2$。\n- 当 $m=2$ 时，成本为 $C = 3N_s + 5(2-1) = 3N_s + 5$。\n- 为了表示 $1023$，我们必须至少有一个非零的 $2$ 的幂（即 $p_i > 0$），所以 $N_s \\ge 1$。\n- 表示 $2^{10} - 1$ 有一个非零的幂 ($2^{10}$），所以 $N_s=1$。这种配置（$m=2$，$N_s=1$）产生的成本为 $3 \\cdot 1 + 5 = 8$。这是任何具有 $m=2$ 个项的表示的最小可能成本。\n\n任何具有 $m \\ge 3$ 个项的表示的成本 $C = 3N_s + 5(m-1) \\ge 3 \\cdot N_s + 5(3-1) = 3N_s + 10$。由于 $N_s \\ge 1$，该成本至少为 $13$，大于 $8$。\n\n因此，将 $k = 1023$ 表示为 $2^{10} - 1$ 是最优的，最小成本为 $8$ 个周期。\n\n指令序列如下：\n1. 计算 $t_1 = x \\ll 10$。成本：$3$ 个周期。\n2. 值 $x$ 即 $x \\ll 0$。成本：$0$ 个周期。\n3. 计算 $y = t_1 - x$。成本：$5$ 个周期。\n总成本：$3 + 0 + 5 = 8$ 个周期。", "answer": "$$\n\\boxed{8}\n$$", "id": "3646809"}, {"introduction": "优秀的指令选择不仅限于算术运算，还必须高效地处理内存访问。现代处理器提供了复杂的寻址模式，能够将地址计算（如索引和缩放）与加载或存储操作本身合并。这个练习[@problem_id:3646830]将向你展示，如何通过模式匹配将多个中间表示（IR）操作“折叠”到一个单一的机器指令中，从而显著减少循环中的指令数量和执行时间。这揭示了理解目标架构特性对于生成高质量代码至关重要。", "problem": "一个编译器后端必须为一个中间表示（IR）中的紧凑循环生成目标代码，该循环对一个包含$n$个$64$位整数的连续数组执行逐元素更新$a[i] = a[i] + k$。该中间表示（IR）使用三地址码，带有显式地址算术和加载/存储操作，并且目标机器支持比例变址寻址模式。\n\nIR中的循环体（使用临时变量 $t_1, t_2, \\dots$）如下：\nL:\n$t_1 \\leftarrow i \\times w$\n$t_2 \\leftarrow base\\_a + t_1$\n$t_3 \\leftarrow \\text{load}(t_2)$\n$t_4 \\leftarrow t_3 + k$\n$\\text{store}(t_2, t_4)$\n$i \\leftarrow i + 1$\nif $i  n$ goto L\n\n假设如下：\n- 元素大小为 $w = 8$ 字节，因此 $a[i]$ 位于地址 $base\\_a + i \\times w$。\n- 目标机器在加载和存储指令中都支持形式为 $[r_b + r_i \\times s]$ 的内存操作数，其中 $s \\in \\{1, 2, 4, 8\\}$。\n- 循环索引 $i$、边界 $n$、常量 $k$ 和基地址 $base\\_a$ 在整个循环过程中都保存在寄存器中。忽略循环设置开销，并假设没有寄存器溢出。\n- 成本模型（每条动态指令的延迟）如下：\n  - 整数加法或减法：$1$个周期。\n  - 整数乘法：$3$个周期。\n  - 比较：$1$个周期。\n  - 条件分支（假设总是正确预测）：$1$个周期。\n  - 加载或存储（使用任何合法寻址模式）：各$4$个周期。\n\n考虑两种指令选择策略：\n- 策略A（朴素策略）：在每次迭代中，将 $i \\times w$ 的结果物化到一个寄存器中，然后与 $base\\_a$ 相加，以计算加载和存储所用的地址。\n- 策略B（寻址模式折叠）：在加载和存储指令中都使用比例变址寻址模式 $[base\\_a + i \\times w]$，从而消除循环体中对 $i \\times w$ 的显式计算以及独立的基地址加法。循环仍然将 $i$ 加 $1$，并执行比较和分支操作。\n\n仅使用以上假设，并从给定的IR循环出发，推导策略A和策略B的每次迭代动态成本，然后计算在使用策略B而非策略A处理 $n = 4096$ 个元素时的总周期节省量。将最终答案表示为单个精确的实数。无需四舍五入。", "solution": "此题要求我们分析一个给定中间表示（IR）循环的两种指令选择策略，计算它们各自的每次迭代成本，并确定在特定迭代次数下的总周期节省量。\n\n该问题已经过验证，并且被认为是有效的，因为它是编译器设计领域一个提法恰当、有科学依据的问题。所有必要的数据和约束都已提供。\n\n首先，我们必须根据提供的IR和成本模型，确定每种策略的机器指令序列及其相关成本。该循环执行$n$次迭代，其中$n = 4096$。\n\n我们将策略A的每次迭代成本表示为$C_A$，策略B的每次迭代成本表示为$C_B$。IR中的循环体如下：\n1.  $t_1 \\leftarrow i \\times w$\n2.  $t_2 \\leftarrow base\\_a + t_1$\n3.  $t_3 \\leftarrow \\text{load}(t_2)$\n4.  $t_4 \\leftarrow t_3 + k$\n5.  $\\text{store}(t_2, t_4)$\n6.  $i \\leftarrow i + 1$\n7.  if $i  n$ goto L\n\n给定的机器指令成本如下：\n- 整数加法/减法：$1$个周期\n- 整数乘法：$3$个周期\n- 比较：$1$个周期\n- 条件分支：$1$个周期\n- 加载或存储：$4$个周期\n\n元素大小为$w = 8$字节。\n\n**策略A（朴素策略）分析**\n该策略为IR中的每个操作生成一个单独的机器指令。我们分析循环体对应的指令成本。\n\n1.  $t_1 \\leftarrow i \\times w$: 这会转换为一条整数乘法指令。\n    成本：$3$个周期。\n2.  $t_2 \\leftarrow base\\_a + t_1$: 这是一个整数加法，用于计算最终地址。\n    成本：$1$个周期。\n3.  $t_3 \\leftarrow \\text{load}(t_2)$: 一条加载指令，使用寄存器中计算出的地址。\n    成本：$4$个周期。\n4.  $t_4 \\leftarrow t_3 + k$: 核心的逐元素加法。\n    成本：$1$个周期。\n5.  $\\text{store}(t_2, t_4)$: 一条存储指令，使用相同的计算地址。\n    成本：$4$个周期。\n6.  $i \\leftarrow i + 1$: 循环索引递增。\n    成本：$1$个周期。\n7.  if $i  n$ goto L: 这涉及一次比较和一次条件分支。\n    - 比较 $i$ 和 $n$：$1$个周期。\n    - 条件分支：$1$个周期。\n    循环控制的总成本：$1 + 1 = 2$个周期。\n\n策略A的每次迭代总成本$C_A$是这些成本的总和：\n$$ C_A = 3 (\\text{mul}) + 1 (\\text{add}) + 4 (\\text{load}) + 1 (\\text{add}) + 4 (\\text{store}) + 1 (\\text{inc}) + 1 (\\text{cmp}) + 1 (\\text{branch}) $$\n$$ C_A = 16 \\text{ 周期} $$\n\n**策略B（寻址模式折叠）分析**\n该策略利用目标机器的比例变址寻址模式 $[r_b + r_i \\times s]$，将地址计算合并到加载和存储指令中。在此，$r_b$ 保存 $base\\_a$，$r_i$ 保存 $i$，比例因子 $s$ 设置为元素宽度 $w = 8$。机器支持 $s=8$，因此这是一个合法的优化。\n\n1.  $t_1 \\leftarrow i \\times w$ 和 $t_2 \\leftarrow base\\_a + t_1$: 这两个IR语句不会被转换为单独的机器指令。相反，它们的功能被“折叠”到内存操作的寻址模式中。\n    显式指令的成本：$0$个周期。\n2.  $t_3 \\leftarrow \\text{load}(t_2)$: 这变成一条带有复杂寻址模式 $[base\\_a + i \\times 8]$ 的 `load` 指令。问题说明，无论寻址模式如何，`load` 的成本都是 $4$ 个周期。\n    成本：$4$个周期。\n3.  $t_4 \\leftarrow t_3 + k$: 核心的逐元素加法保持不变。\n    成本：$1$个周期。\n4.  $\\text{store}(t_2, t_4)$: 与 `load` 类似，这变成了一条使用 $[base\\_a + i \\times 8]$ 寻址模式的 `store` 指令。其成本也是 $4$ 个周期。\n    成本：$4$个周期。\n5.  $i \\leftarrow i + 1$: 循环索引递增保持不变。\n    成本：$1$个周期。\n6.  if $i  n$ goto L: 循环控制逻辑也保持不变。\n    - 比较 $i$ 和 $n$：$1$个周期。\n    - 条件分支：$1$个周期。\n    循环控制的总成本：$1 + 1 = 2$个周期。\n\n策略B的每次迭代总成本$C_B$是这些成本的总和：\n$$ C_B = 4 (\\text{load}) + 1 (\\text{add}) + 4 (\\text{store}) + 1 (\\text{inc}) + 1 (\\text{cmp}) + 1 (\\text{branch}) $$\n$$ C_B = 12 \\text{ 周期} $$\n\n**总节省量计算**\n每次迭代的节省量是两种策略成本之间的差值：\n$$ S_{\\text{iter}} = C_A - C_B = 16 - 12 = 4 \\text{ 周期} $$\n这个节省量来自于策略A中消除了用于地址计算的显式 `MUL` (成本 $3$ 个周期) 和 `ADD` (成本 $1$ 个周期) 指令。\n\n要处理的元素总数为 $n = 4096$。这对应于 $4096$ 次循环迭代。\n总周期节省量 $S_{\\text{total}}$ 是每次迭代的节省量乘以迭代次数：\n$$ S_{\\text{total}} = n \\times S_{\\text{iter}} = 4096 \\times 4 $$\n$$ S_{\\text{total}} = 16384 $$\n总周期节省量为 $16384$。", "answer": "$$\\boxed{16384}$$", "id": "3646830"}, {"introduction": "最优的代码生成往往需要超越局部、逐条指令的视角。当处理超出指令直接编码范围的大常数时，编译器必须仔细管理有限的寄存器资源。这个实践案例[@problem_id:3646810]探讨了指令选择与指令调度的相互作用。你将学习如何通过分析数据依赖性并重新排序指令，将对同一大常数的使用聚集在一起，从而最大限度地减少从内存中加载常数的昂贵操作。这强调了在资源受限的情况下，全局优化策略的重要性。", "problem": "您正在为一台简单的标量机进行开发，并且必须为一个中间表示（IR）基本块进行指令选择，该基本块中的常量超出了立即数编码的范围。目标是最小化仅为了生成大常量而引入的额外内存加载次数。请考虑以下目标机和IR，然后选择能够最小化该基本块每次执行时字面量加载次数的指令选择策略。\n\n目标机模型和约束：\n- 立即数编码限制：带立即数的加法指令 $\\mathrm{ADDI}\\ R_d, R_s, \\mathrm{imm}$ 只接受范围在 $[-2048, 2047]$ 内的有符号立即数 $\\mathrm{imm}$（即，12位有符号数）。\n- 寄存器-寄存器加法 $\\mathrm{ADD}\\ R_d, R_s, R_t$ 可用，且仅使用寄存器。\n- 字面量加载：$\\mathrm{LDRL}\\ R_d, [\\mathrm{PC}+\\mathrm{off}]$ 从一个池中加载一个完整的32位字面量（相对于程序计数器PC）。就本问题而言，每次 $\\mathrm{LDRL}$ 都算作一次“额外加载”。\n- 常量寄存器约束：寄存器分配器恰好提供一个额外的通用寄存器 $r_c$ 来保存任何生成的字面量。任何 $\\mathrm{LDRL}$ 都必须以 $r_c$ 为目标。在任何时候，$r_c$ 最多只能保存一个字面量值；要更改 $r_c$ 中的值，需要发出另一条 $\\mathrm{LDRL}$ 指令（一次额外加载）。不允许使用任何其他寄存器来保存字面量，否则会发生溢出（spilling），而此问题中不允许溢出。\n- 映射约束：每个IR加法必须由一条机器 $\\mathrm{ADD}$ 或一条机器 $\\mathrm{ADDI}$ 指令实现。您不能将单个IR加法分解为多个加法来“累加”一个大常量。允许使用 $\\mathrm{LDRL}$ 将一个操作数（大常量）加载到寄存器中，但IR加法本身仍然是一条 $\\mathrm{ADD}$ 或一条 $\\mathrm{ADDI}$ 指令。\n- 调度：在基本块内，当且仅当保留数据依赖关系时，您才可以重排指令。不允许进行代数重组（例如更改加法的分组或创建新常量）。\n\nIR基本块（三地址码；变量 $a,b,c,d$ 在入口处是活跃的）：\n- $t_1 := \\mathrm{add}(a, 50000)$\n- $t_2 := \\mathrm{add}(b, 50000)$\n- $t_3 := \\mathrm{add}(t_1, t_2)$\n- $t_4 := \\mathrm{add}(c, 70000)$\n- $t_5 := \\mathrm{add}(t_3, 12)$\n- $t_6 := \\mathrm{add}(d, 1024)$\n- $t_7 := \\mathrm{add}(t_6, 50000)$\n\n事实：\n- 立即数 $12$ 和 $1024$ 在12位有符号范围内，因此可以使用 $\\mathrm{ADDI}$ 而无需任何字面量加载。\n- 立即数 $50000$ 和 $70000$ 超出了12位有符号范围，因此无法在单个 $\\mathrm{ADDI}$ 指令中编码。要将这些值提供给 $\\mathrm{ADD}$ 指令，您必须通过 $\\mathrm{LDRL}$ 将常量生成到 $r_c$ 中，然后使用以 $r_c$ 为第三个操作数的 $\\mathrm{ADD}$ 指令。\n\n问题：在上述约束下，哪种策略能为每次执行该基本块产生最少的字面量加载（即 $\\mathrm{LDRL}$ 指令）次数？\n\nA. 不进行重排。对于每个带有大常量的IR加法，在使用它的相应 $\\mathrm{ADD}$ 指令之前，立即发出 $\\mathrm{LDRL}\\ r_c, \\text{const}$ 指令。\n\nB. 不进行重排。提升 $50000$ 并在整个块中将其保留在 $r_c$ 中（在块入口处加载一次），在需要 $50000$ 的地方使用 `ADD`；当需要 $70000$ 时，仅在该使用前将 $r_c$ 的值更改为 $70000$，然后为了后续使用再将其改回 $50000$。\n\nC. 合法地重排独立的IR语句，将所有对 $50000$ 的使用聚集在对 $70000$ 的单次使用之前；在该聚集的指令簇中将 $50000$ 保留在 $r_c$ 中，然后在使用 $70000$ 时切换一次 $r_c$ 的值。\n\nD. 如选项 C 那样进行合法重排，但改为提升并保留 $70000$ 在 $r_c$ 中，而在每次使用 $50000$ 时都重新加载它。", "solution": "用户提供的问题是有效的。这是编译器理论中一个定义明确的问题，具体涉及指令选择和调度，具有清晰定义的约束和可度量的目标。所有术语都是该学科的标准术语，模型虽然简化，但具有科学依据。\n\n该问题要求找到一种指令选择策略，以最小化处理给定中间表示（IR）基本块中大常量所需的字面量加载（`$\\mathrm{LDRL}$`指令）次数。\n\n首先，让我们形式化IR及其依赖关系。IR指令如下：\n- $I_1: t_1 := \\mathrm{add}(a, 50000)$\n- $I_2: t_2 := \\mathrm{add}(b, 50000)$\n- $I_3: t_3 := \\mathrm{add}(t_1, t_2)$\n- $I_4: t_4 := \\mathrm{add}(c, 70000)$\n- $I_5: t_5 := \\mathrm{add}(t_3, 12)$\n- $I_6: t_6 := \\mathrm{add}(d, 1024)$\n- $I_7: t_7 := \\mathrm{add}(t_6, 50000)$\n\n数据依赖关系构成一个有向无环图（DAG）：\n- $I_1 \\rightarrow I_3$（因为 $I_3$ 使用 $t_1$）\n- $I_2 \\rightarrow I_3$（因为 $I_3$ 使用 $t_2$）\n- $I_3 \\rightarrow I_5$（因为 $I_5$ 使用 $t_3$）\n- $I_6 \\rightarrow I_7$（因为 $I_7$ 使用 $t_6$）\n指令 $I_4$ 与块中所有其他指令无关，因为它使用输入变量 $c$ 并产生一个在块内未被使用的结果 $t_4$。\n\n机器约束规定，任何超出范围 $[-2048, 2047]$ 的立即数都必须使用 `$\\mathrm{LDRL}$` 指令从字面量池加载到专用寄存器 $r_c$ 中。\n- 常量 $12$ 和 $1024$ 在范围内，可以在 `$\\mathrm{ADDI}$` 指令中编码，无需额外加载。\n- 常量 $50000$ 和 $70000$ 超出此范围。它们需要一条 `$\\mathrm{LDRL}$` 指令将值加载到 $r_c$ 中，然后是一条使用 $r_c$ 的 `$\\mathrm{ADD}$` 指令。\n\n大常量的使用情况如下：\n- 常量 $50000$ 用于 $I_1$、$I_2$ 和 $I_7$。\n- 常量 $70000$ 用于 $I_4$。\n\n目标是最小化 `$\\mathrm{LDRL}$` 指令的总数。这可以通过智能地调度指令和管理常量寄存器 $r_c$ 的内容来实现。我们现在将评估每种提议的策略。\n\n### 选项 A 分析\n\n**策略**：不进行重排。对于每个带有大常量的IR加法，在使用它的相应 `$\\mathrm{ADD}$` 之前，立即发出 `$\\mathrm{LDRL}\\ r_c, \\text{const}$`。\n\n这是一种简单的局部策略，不尝试重用已存在于 $r_c$ 中的常量。指令序列固定为 $I_1, I_2, I_3, I_4, I_5, I_6, I_7$。\n\n1.  对于 $I_1$（使用 $50000$）：发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（1次加载）\n2.  对于 $I_2$（使用 $50000$）：策略规定每次使用都要发出 `$\\mathrm{LDRL}$`。发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（2次加载）\n3.  $I_3$ 没有大常量。\n4.  对于 $I_4$（使用 $70000$）：发出 `$\\mathrm{LDRL}\\ r_c, =70000$`。（3次加载）\n5.  $I_5$ 和 $I_6$ 有小立即数。\n6.  对于 $I_7$（使用 $50000$）：发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（4次加载）\n\n总字面量加载次数：4次。\n\n**结论**：不正确。该策略效率极低。\n\n### 选项 B 分析\n\n**策略**：不进行重排。提升并在整个块中将 $50000$ 保留在 $r_c$ 中（在块入口加载一次），但当需要 $70000$ 时，切换 $r_c$ 为 $70000$，然后为最终使用再切换回 $50000$。\n\n指令序列是固定的。该策略试图优化重用，但受限于固定的顺序。\n\n1.  在块入口：发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（1次加载）\n2.  对于 $I_1$（使用 $50000$）：使用 $r_c$。无新加载。\n3.  对于 $I_2$（使用 $50000$）：使用 $r_c$。无新加载。\n4.  $I_3$ 没有大常量。\n5.  对于 $I_4$（使用 $70000$）：$r_c$ 中的值是 $50000$。我们必须切换。发出 `$\\mathrm{LDRL}\\ r_c, =70000$`。（2次加载）\n6.  在 $I_4$ 之后，策略要求为 $I_7$ 中的后续使用切换回 $50000$。发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（3次加载）\n7.  $I_5$ 和 $I_6$ 有小立即数。\n8.  对于 $I_7$（使用 $50000$）：使用 $r_c$，它现在存有 $50000$。无新加载。\n\n总字面量加载次数：3次。\n\n**结论**：不正确。这比策略A好，但缺乏重排迫使出现次优的加载-重载模式。\n\n### 选项 C 分析\n\n**策略**：合法地重排IR语句，将所有对 $50000$ 的使用聚集在对 $70000$ 的单次使用之前。在其使用期间将 $50000$ 保留在 $r_c$ 中，然后切换到 $70000$。\n\n该策略将指令调度与对 $r_c$ 的智能管理相结合。目标是在任何需要 $70000$ 的计算之前，执行所有需要 $50000$ 的计算。由于 $I_4$（使用 $70000$）独立于其他指令链，它可以被移动到所有其他指令之后。一个合法的、重排后的调度是：$I_1, I_2, I_3, I_6, I_7, I_5, I_4$。一个更简单且同样能达到目标的调度是：\n1.  $I_1: t_1 := \\mathrm{add}(a, 50000)$\n2.  $I_2: t_2 := \\mathrm{add}(b, 50000)$\n3.  $I_6: t_6 := \\mathrm{add}(d, 1024)$\n4.  $I_7: t_7 := \\mathrm{add}(t_6, 50000)$\n5.  $I_3: t_3 := \\mathrm{add}(t_1, t_2)$\n6.  $I_5: t_5 := \\mathrm{add}(t_3, 12)$\n7.  $I_4: t_4 := \\mathrm{add}(c, 70000)$\n\n此调度是合法的，因为所有依赖关系都得到了遵守。大常量使用的顺序变为：$50000$（$I_1$），$50000$（$I_2$），$50000$（$I_7$），最后是 $70000$（$I_4$）。\n\n1.  在块入口：发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（1次加载）\n2.  对于 $I_1, I_2, I_7$：使用 $r_c$ 中的值。无新加载。\n3.  对于 $I_4$（使用 $70000$）：$r_c$ 中的值是 $50000$。我们必须切换。发出 `$\\mathrm{LDRL}\\ r_c, =70000$`。（2次加载）\n\n总字面量加载次数：2次。\n\n**结论**：正确。该策略是最佳的。它通过调度指令来最大化最频繁大常量的重用，然后在切换到另一个常量，从而最小化了加载次数。\n\n### 选项 D 分析\n\n**策略**：如选项 C 那样合法重排，但改为提升并保留 $70000$，并在每次使用 $50000$ 时加载它。\n\n该策略重排了指令，但在优先选择哪个常量上做出了糟糕的决定。一个合法的调度会将 $I_4$ 放在首位，然后是其他指令，并遵守它们的依赖关系。\n示例调度：$I_4, I_1, I_2, I_6, I_7, I_3, I_5$。\n\n加载策略被描述为“提升并保留 $70000$”（一个智能的全局选择），但“在每次使用 $50000$ 时加载它”（一个简单的局部选择）。我们按其描述来评估该策略。\n\n1.  在块入口：为 $I_4$ 提升常量。发出 `$\\mathrm{LDRL}\\ r_c, =70000$`。（1次加载）\n2.  对于 $I_4$：使用 $r_c$。\n3.  对于第一次使用 $50000$（$I_1$）：策略说每次使用都加载。发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（2次加载）\n4.  对于第二次使用 $50000$（$I_2$）：策略说每次使用都加载。发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（3次加载）\n5.  对于第三次使用 $50000$（$I_7$）：策略说每次使用都加载。发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（4次加载）\n\n总字面量加载次数：4次。\n即使对“每次使用都加载”作更宽容的解释，即“在需要时加载”，该策略也需要先加载 $70000$（1次加载），然后为后续使用加载 $50000$（1次加载），总共2次加载，与选项C相同。然而，明确的措辞“在每次使用时都加载...”与“提升并保留”的措辞形成对比，并暗示对未提升的常量采用简单的实现方式。这使得D中描述的策略劣于C。鉴于这些选项，C描述了明确的最优方法。\n\n**结论**：不正确。该策略是次优的，因为它要么优先考虑了较不频繁的常量，要么明确为较频繁的常量指定了一种简单的加载方法。\n\n**总结**：\n- 策略A：4次加载\n- 策略B：3次加载\n- 策略C：2次加载\n- 策略D：4次加载\n\n最少的字面量加载次数为2次，由策略C实现。", "answer": "$$\\boxed{C}$$", "id": "3646810"}]}