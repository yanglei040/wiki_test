{"hands_on_practices": [{"introduction": "经典的RISC流水线设计通过引入延迟槽来处理加载延迟和分支延迟，这为编译器优化提供了机会。编译器必须对目标机器的流水线行为进行建模，以找到可以安全填充这些延迟槽的独立指令，从而避免停顿。这项实践 [@problem_id:3674254] 要求您扮演编译器的角色，通过分析数据依赖关系，为给定的代码块重新排序指令，以充分利用延迟槽并提升性能。", "problem": "编译器必须对一个旧的指令集架构（ISA）进行建模，并通过调度指令来利用流水线特性，同时保持程序语义。考虑目标机器 $M$，其具有以下基于指令调度和数据依赖核心定义的属性：\n- $M$ 是单发射的，每个周期派发一条指令。\n- $M$ 上的分支指令有一个延迟槽：紧跟在分支指令后的那条指令，无论分支是否跳转，在控制权转移之前总会且仅会执行一次。这条指令必须在所有路径上都能安全执行。\n- $M$ 上的加载指令具有1个周期的加载-使用延迟：任何在紧随加载指令的下一个周期读取其目标寄存器的指令，都会导致一个相当于插入一条 $NOP$ 指令的停顿，除非编译器在该槽中调度了一条独立的填充指令。\n- 程序语义要求任何调度都必须保留所有真正的数据依赖（写后读，RAW），避免引入假的依赖（读后写，WAR），并避免写后写冲突（WAW）。控制依赖必须被遵守：移动指令不能改变每条路径上执行的指令。\n- 假设内存操作遵循单线程的标准内存模型：重排序不能改变相关内存访问的相对顺序。进一步假设 $I_1$ 中的加载操作和 $I_4$ 中的存储操作访问不相交的内存位置，即由 $r_3 + 0$ 计算的地址与由 $r_9 + 0$ 计算的地址指向不同的内存对象。任何指令都不会引入异常或陷阱。\n\n给定以下直线型基本块，其中每条指令 $I_k$ 按原始程序顺序列出：\n- $I_1$: $LD\\ r_2,\\ 0(r_3)$\n- $I_2$: $ADD\\ r_4,\\ r_2,\\ r_5$\n- $I_3$: $SUB\\ r_6,\\ r_7,\\ r_8$\n- $I_4$: $ST\\ r_4,\\ 0(r_9)$\n- $I_5$: $BNE\\ r_1,\\ r_0,\\ L$\n\n编译器试图通过移动块内安全的填充指令，来避免在加载延迟槽（紧跟 $I_1$ 之后）和分支延迟槽（紧跟 $I_5$ 之后）中插入 $NOP$。如果一个填充指令在上述机器模型下，对于所有输入，都能保留所有依赖关系，并产生与原始程序相同的可观察行为（寄存器和内存状态），则该填充是安全的。\n\n哪个选项选择了安全的填充指令，既能避免流水线停顿，又能保持语义，同时除了被移动的填充指令外，所有其他指令保持其原始相对顺序？\n\nA. 加载延迟槽填充指令：$I_3$；分支延迟槽填充指令：$I_4$。\n\nB. 加载延迟槽填充指令：$I_3$；分支延迟槽填充指令：$I_2$。\n\nC. 加载延迟槽填充指令：$I_2$；分支延迟槽填充指令：$I_4$。\n\nD. 加载延迟槽填充指令：$I_4$；分支延迟槽填充指令：$I_3$。", "solution": "该问题要求为一个假设的单发射处理器 M 调度指令，以填充一个加载延迟槽和一个分支延迟槽，且不违反程序语义。我们必须首先分析给定基本块内的数据依赖关系，然后评估每个提议的调度方案。\n\n### 第1步：问题验证\n\n问题描述了一个典型的流水线化类 RISC 处理器架构的指令调度场景。\n\n**1. 提取的已知条件：**\n*   **机器属性 ($M$)：**\n    *   单发射（每个周期1条指令）。\n    *   1个分支延迟槽：分支后的指令总是执行一次。\n    *   1个周期的加载-使用延迟：在下一周期使用加载结果的指令会导致停顿。\n*   **语义约束：**\n    *   保留写后读（RAW）依赖。\n    *   避免引入读后写（WAR）和写后写（WAW）依赖。\n    *   遵守控制依赖。\n    *   加载（$I_1$）和存储（$I_4$）不冲突（访问不相交的内存位置）。\n*   **原始指令序列：**\n    *   $I_1$: $LD\\ r_2,\\ 0(r_3)$\n    *   $I_2$: $ADD\\ r_4,\\ r_2,\\ r_5$\n    *   $I_3$: $SUB\\ r_6,\\ r_7,\\ r_8$\n    *   $I_4$: $ST\\ r_4,\\ 0(r_9)$\n    *   $I_5$: $BNE\\ r_1,\\ r_0,\\ L$\n*   **目标：** 从块本身找到用于加载延迟槽（在 $I_1$ 之后）和分支延迟槽（在 $I_5$ 之后）的安全填充指令，使得不发生停顿并保留语义。\n\n**2. 验证分析：**\n*   **科学依据：** 指令调度、数据依赖（RAW、WAR、WAW）、控制依赖、流水线停顿、加载-使用延迟和分支延迟槽等概念，是计算机体系结构和编译器设计中基础且公认的原则。该模型是像 MIPS 这类架构的标准简化表示。该问题在科学上是合理的。\n*   **良构性：** 这是一个良构问题。初始状态（原始代码）、转换规则（调度约束）和期望的最终状态（一个包含两个已填充槽的有效调度）都已明确定义。可以移动的指令集合是有限的，有效移动的标准是明确的，从而可以在选项中推导出唯一的答案。对内存操作的显式非冲突假设消除了歧义。\n*   **客观性：** 该问题使用精确、客观的技术术语陈述。没有主观或含糊不清的陈述。\n\n**3. 结论：**\n问题陈述是有效的。这是一个编译器优化领域的标准、良构问题。\n\n### 第2步：解题推导\n\n**1. 数据依赖分析：**\n我们识别真正的数据依赖（RAW），即一条指令读取一个由前序指令写入的寄存器。\n*   $I_1: LD\\ r_2,\\ 0(r_3)$ --- 定义了寄存器 $r_2$。\n*   $I_2: ADD\\ r_4,\\ r_2,\\ r_5$ --- 使用了寄存器 $r_2$。因此，存在从 $I_1$ 到 $I_2$ 的RAW依赖。我们记为 $I_1 \\xrightarrow{r_2} I_2$。\n*   $I_2: ADD\\ r_4,\\ r_2,\\ r_5$ --- 定义了寄存器 $r_4$。\n*   $I_4: ST\\ r_4,\\ 0(r_9)$ --- 使用了寄存器 $r_4$。因此，存在从 $I_2$ 到 $I_4$ 的RAW依赖。我们记为 $I_2 \\xrightarrow{r_4} I_4$。\n*   $I_3: SUB\\ r_6,\\ r_7,\\ r_8$ --- 定义了 $r_6$ 并使用了 $r_7, r_8$。它与该块中任何其他指令都没有寄存器依赖关系。它是一条独立的指令。\n*   $I_5: BNE\\ r_1,\\ r_0,\\ L$ --- 使用了 $r_1, r_0$。它与该块中其他指令没有寄存器依赖关系。\n\n依赖图包含链：$I_1 \\rightarrow I_2 \\rightarrow I_4$。指令 $I_3$ 是独立的。指令 $I_5$ 是控制终止指令。\n\n**2. 调度约束：**\n*   **加载延迟槽（在 $I_1$ 之后）：**\n    原始序列是 $I_1, I_2, ...$。由于 $I_2$ 使用 $I_1$ 的结果 ($r_2$)，将 $I_2$ 紧跟在 $I_1$ 之后会因加载-使用延迟而导致1个周期的停顿。为避免停顿，我们必须在 $I_1$ 和 $I_2$ 之间找到一条不依赖于 $I_1$ 结果的指令。\n*   **分支延迟槽（在 $I_5$ 之后）：**\n    必须在分支指令 $I_5$ 之后放置一条指令。无论分支结果如何，这条指令都会执行。填充此槽的一个安全方法是从基本块的更早位置移动一条指令过来。这是安全的，因为该指令本来就保证会执行。被移动的指令不能是影响分支条件寄存器（$r_1, r_0$）的指令。\n\n**3. 评估填充候选指令：**\n任务是选择一对填充指令，一个用于加载槽，一个用于分支槽。剩下的三条指令必须保持其原始的相对顺序。\n\n让我们分析每个选项。\n\n**A. 加载延迟槽填充指令：$I_3$；分支延迟槽填充指令：$I_4$。**\n\n*   选择的填充指令是 $I_3$ 和 $I_4$。剩下的指令是 $I_1, I_2, I_5$。它们的相对顺序必须保留，所以骨架是 $I_1 ... I_2 ... I_5$。\n*   我们将 $I_3$ 放置在加载延迟槽中（在 $I_1$ 之后），并将 $I_4$ 放置在分支延迟槽中（在 $I_5$ 之后）。\n*   得到的调度是：\n    1.  $I_1$: $LD\\ r_2,\\ 0(r_3)$\n    2.  $I_3$: $SUB\\ r_6,\\ r_7,\\ r_8$  (加载延迟槽填充指令)\n    3.  $I_2$: $ADD\\ r_4,\\ r_2,\\ r_5$\n    4.  $I_5$: $BNE\\ r_1,\\ r_0,\\ L$\n    5.  $I_4$: $ST\\ r_4,\\ 0(r_9)$  (分支延迟槽填充指令)\n*   **验证：**\n    *   **加载槽：** $I_3$ 独立于所有其他指令。将其放在 $I_1$ 之后不使用 $r_2$，因此正确地避免了加载-使用停顿。此移动有效。\n    *   **分支槽：** $I_4$ 被移动到分支延迟槽中。依赖关系 $I_2 \\xrightarrow{r_4} I_4$ 必须被遵守。在这个调度中，$I_2$ 在周期3执行并定义了 $r_4$。$I_4$ 在周期5执行并使用这个新定义的 $r_4$。RAW 依赖得以保留。\n    *   **其他依赖：** 依赖 $I_1 \\xrightarrow{r_2} I_2$ 得到遵守；$I_2$ 现在位于 $I_1$ 之后的第2个周期，这大于1个周期的延迟。\n    *   **语义：** 非填充指令的相对顺序（$I_2$ 在 $I_5$ 之前）得以保留。所有依赖关系都得到遵守。没有引入违反语义的新依赖。该调度有效并满足目标。\n*   **对选项A的裁决：** **正确**。\n\n**B. 加载延迟槽填充指令：$I_3$；分支延迟槽填充指令：$I_2$。**\n\n*   填充指令：$I_3, I_2$。剩余指令顺序：$I_1, I_4, I_5$。\n*   得到的调度是：\n    1.  $I_1$: $LD\\ r_2,\\ 0(r_3)$\n    2.  $I_3$: $SUB\\ r_6,\\ r_7,\\ r_8$  (加载延迟槽)\n    3.  $I_4$: $ST\\ r_4,\\ 0(r_9)$\n    4.  $I_5$: $BNE\\ r_1,\\ r_0,\\ L$\n    5.  $I_2$: $ADD\\ r_4,\\ r_2,\\ r_5$  (分支延迟槽)\n*   **验证：** 这个调度是无效的。它违反了 RAW 依赖 $I_2 \\xrightarrow{r_4} I_4$。指令 $I_4$（在周期3）读取寄存器 $r_4$ **早于** 指令 $I_2$（在周期5）对其进行写入。这将导致 $I_4$ 向内存中存储错误的值，从而改变程序语义。\n*   **对选项B的裁决：** **不正确**。\n\n**C. 加载延迟槽填充指令：$I_2$；分支延迟槽填充指令：$I_4$。**\n\n*   填充指令：$I_2, I_4$。剩余指令顺序：$I_1, I_3, I_5$。\n*   得到的调度是：\n    1.  $I_1$: $LD\\ r_2,\\ 0(r_3)$\n    2.  $I_2$: $ADD\\ r_4,\\ r_2,\\ r_5$  (加载延迟槽)\n    3.  $I_3$: $SUB\\ r_6,\\ r_7,\\ r_8$\n    4.  $I_5$: $BNE\\ r_1,\\ r_0,\\ L$\n    5.  $I_4$: $ST\\ r_4,\\ 0(r_9)$  (分支延迟槽)\n*   **验证：** 这个调度是无效的。问题要求调度指令以 **避免** 停顿。将 $I_2$ 紧跟在 $I_1$ 之后并不能实现这个目标。由于 $I_2$ 使用了加载指令 $I_1$ 的结果（寄存器 $r_2$），硬件规则规定将会发生一个“等同于插入一个 $NOP$”的停顿。因此，将 $I_2$ 放在加载延迟槽中并不能阻止停顿；它只是在流水线停顿时占据了这个槽位。这未能达成主要目标。\n*   **对选项C的裁决：** **不正确**。\n\n**D. 加载延迟槽填充指令：$I_4$；分支延迟槽填充指令：$I_3$。**\n\n*   填充指令：$I_4, I_3$。剩余指令顺序：$I_1, I_2, I_5$。\n*   得到的调度是：\n    1.  $I_1$: $LD\\ r_2,\\ 0(r_3)$\n    2.  $I_4$: $ST\\ r_4,\\ 0(r_9)$  (加载延迟槽)\n    3.  $I_2$: $ADD\\ r_4,\\ r_2,\\ r_5$\n    4.  $I_5$: $BNE\\ r_1,\\ r_0,\\ L$\n    5.  $I_3$: $SUB\\ r_6,\\ r_7,\\ r_8$  (分支延迟槽)\n*   **验证：** 这个调度是无效的。它违反了 RAW 依赖 $I_2 \\xrightarrow{r_4} I_4$。指令 $I_4$（在周期2）读取寄存器 $r_4$ **早于** 指令 $I_2$（在周期3）对其进行写入。与选项 B 类似，这通过存储一个不正确的值改变了程序的语义。\n*   **对选项D的裁决：** **不正确**。\n\n### 结论\n\n只有选项 A 中提议的调度是有效的。它成功地用安全的指令填充了加载延迟槽和分支延迟槽，避免了停顿，并保留了原始程序的所有数据和控制依赖。", "answer": "$$\\boxed{A}$$", "id": "3674254"}, {"introduction": "从单发射流水线转向超长指令字（VLIW）等具有显式指令级并行性的架构时，编译器的目标机器模型也必须演进。在这种模型中，编译器不仅要考虑指令间的依赖关系，还必须同时管理多个并行功能单元和发射槽的资源限制。这项练习 [@problem_id:3674283] 提供了一个形式化的VLIW资源约束模型，您需要将一系列操作打包到最少数量的指令包中，这正是VLIW编译器在生成代码时面临的核心调度问题。", "problem": "一台超长指令字 (VLIW) 目标机通过对离散资源的指令包可行性约束进行建模。每个周期发射一个指令包，该指令包占据一组发射槽并消耗功能单元的容量。设每个指令包的容量向量为\n$$\n\\mathbf{c} = \\begin{pmatrix} 2 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix},\n$$\n其坐标分别对应于整数算术逻辑单元 ($I$)、浮点单元 ($F$)、内存端口 ($M$) 以及发射槽 $s_1$、$s_2$、$s_3$、$s_4$。一个操作 $i$ 由一个具有相同坐标顺序的非负整数资源使用向量 $r_i \\in \\mathbb{N}^7$ 来描述。如果对于每个资源维度，分配给某个指令包的操作的需求总和不超过 $\\mathbf{c}$ 中的相应容量，则该指令包是可行的。\n\n考虑以下操作集合 $\\{o_1,o_2,\\dots,o_{10}\\}$，其资源使用向量为\n$$\nr_1 = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix},\\quad\nr_2 = \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix},\\quad\nr_3 = \\begin{pmatrix}0\\\\1\\\\0\\\\0\\\\0\\\\1\\\\0\\end{pmatrix},\\quad\nr_4 = \\begin{pmatrix}0\\\\0\\\\1\\\\0\\\\0\\\\0\\\\1\\end{pmatrix},\n$$\n$$\nr_5 = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix},\\quad\nr_6 = \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix},\\quad\nr_7 = \\begin{pmatrix}0\\\\1\\\\0\\\\0\\\\0\\\\1\\\\0\\end{pmatrix},\\quad\nr_8 = \\begin{pmatrix}0\\\\0\\\\1\\\\0\\\\0\\\\0\\\\1\\end{pmatrix},\n$$\n$$\nr_9 = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix},\\quad\nr_{10} = \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix}.\n$$\n如 $s_j$ 坐标所示，每个操作恰好占据一个发射槽，并可能消耗 $I$、$F$ 或 $M$ 中的一个功能单元容量。\n\n在上述模型下，将这些操作打包到最少数量的可行指令包中。将最小指令包数作为单个实数值报告。如果在中间推理中使用了任何近似，请确保最终报告的数字是精确的。最终答案不需要单位。", "solution": "用户希望我解决这个问题。\n问题是将一组10个操作调度到超长指令字（VLIW）机器上的最小数量的指令包中，同时要满足资源约束。这是一个多维装箱问题的实例。\n\n首先，我将验证问题陈述。\n\n### 步骤1：提取已知条件\n-   每个指令包的资源容量向量是 $\\mathbf{c} = \\begin{pmatrix} 2 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$。\n-   向量的坐标对应于资源：整数单元（$I$）、浮点单元（$F$）、内存端口（$M$）和发射槽 $s_1$、$s_2$、$s_3$、$s_4$。\n-   存在一个包含10个操作的集合，$\\{o_1, o_2, \\dots, o_{10}\\}$。\n-   每个操作 $o_i$ 的资源使用向量 $r_i$ 如下：\n    $r_1 = r_5 = r_9 = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix}$\n    $r_2 = r_6 = r_{10} = \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix}$\n    $r_3 = r_7 = \\begin{pmatrix}0\\\\1\\\\0\\\\0\\\\0\\\\1\\\\0\\end{pmatrix}$\n    $r_4 = r_8 = \\begin{pmatrix}0\\\\0\\\\1\\\\0\\\\0\\\\0\\\\1\\end{pmatrix}$\n-   如果一个操作指令包 $B$ 中所有操作的资源使用向量之和不超过容量向量 $\\mathbf{c}$，即 $\\sum_{i \\in B} r_i \\le \\mathbf{c}$（逐分量不等式），则该指令包是可行的。\n-   目标是找到调度所有10个操作所需的最小可行指令包数量。\n\n### 步骤2：使用提取的已知条件进行验证\n-   **科学性：** 该问题描述了一个资源受限的调度问题，这是编译器理论和计算机体系结构中的一个基本概念，尤其适用于VLIW处理器。该模型是现实世界问题的简化但有效的抽象。它在科学上是合理的。\n-   **适定性：** 该问题要求在一组明确的约束下找到一个最小值。目标定义明确，约束以数学方式指定。存在一个唯一的指令包数量最优解。\n-   **客观性：** 该问题使用精确、客观的数学语言进行表述。\n-   **完整性和一致性：** 该问题提供了所有必要的信息：机器的容量、操作的数量和类型，以及每个操作消耗的资源。没有矛盾之处。\n\n### 步骤3：结论和行动\n该问题是有效的，因为它是自洽的、有科学依据且适定的。我将继续进行解答。\n\n问题是将这10个操作的集合划分为最少数量的子集（指令包），其中每个子集都满足资源约束。\n\n让我们按资源使用情况对操作进行分类：\n-   A类：消耗1个$I$单元和1个$s_1$槽的操作。这些是 $\\{o_1, o_5, o_9\\}$。共有3个此类操作。($r_i = (1,0,0,1,0,0,0)^T$)\n-   B类：消耗1个$I$单元和1个$s_2$槽的操作。这些是 $\\{o_2, o_6, o_{10}\\}$。共有3个此类操作。($r_i = (1,0,0,0,1,0,0)^T$)\n-   C类：消耗1个$F$单元和1个$s_3$槽的操作。这些是 $\\{o_3, o_7\\}$。共有2个此类操作。($r_i = (0,1,0,0,0,1,0)^T$)\n-   D类：消耗1个$M$单元和1个$s_4$槽的操作。这些是 $\\{o_4, o_8\\}$。共有2个此类操作。($r_i = (0,0,1,0,0,0,1)^T$)\n\n容量向量为 $\\mathbf{c} = (2, 1, 1, 1, 1, 1, 1)^T$，对应于资源 $(I, F, M, s_1, s_2, s_3, s_4)$。\n\n为了找到最小指令包数，我们首先确定一个下界。指令包的数量必须至少是任何单一资源的总需求除以该资源的每个指令包容量，然后向上取整。\n\n让我们通过对所有 $r_i$ 向量求和来计算总资源需求：\n-   I单元总需求：$3$（来自A类）$+ 3$（来自B类）$= 6$。\n-   F单元总需求：$2$（来自C类）$= 2$。\n-   M单元总需求：$2$（来自D类）$= 2$。\n-   $s_1$槽总需求：$3$（来自A类）$= 3$。\n-   $s_2$槽总需求：$3$（来自B类）$= 3$。\n-   $s_3$槽总需求：$2$（来自C类）$= 2$。\n-   $s_4$槽总需求：$2$（来自D类）$= 2$。\n\n现在，我们为每种资源计算下界：\n-   I单元：$\\lceil \\frac{6}{2} \\rceil = 3$ 个指令包。\n-   F单元：$\\lceil \\frac{2}{1} \\rceil = 2$ 个指令包。\n-   M单元：$\\lceil \\frac{2}{1} \\rceil = 2$ 个指令包。\n-   $s_1$槽：$\\lceil \\frac{3}{1} \\rceil = 3$ 个指令包。\n-   $s_2$槽：$\\lceil \\frac{3}{1} \\rceil = 3$ 个指令包。\n-   $s_3$槽：$\\lceil \\frac{2}{1} \\rceil = 2$ 个指令包。\n-   $s_4$槽：$\\lceil \\frac{2}{1} \\rceil = 2$ 个指令包。\n\n总下界是这些单个下界中的最大值：\n$$\n\\text{最小指令包数} \\ge \\max(3, 2, 2, 3, 3, 2, 2) = 3\n$$\n所以，我们至少需要3个指令包。现在，我们必须确定将所有操作装入3个指令包是否可行。\n\n让我们尝试构建一个包含3个指令包的调度。\n我们有3个A类操作，3个B类操作，2个C类操作和2个D类操作。\n\n指令包1：让我们尝试将每种类型的操作各打包一个。\n我们选择 $\\{o_1, o_2, o_3, o_4\\}$。\n它们的资源向量之和为：\n$r_1 + r_2 + r_3 + r_4 = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}0\\\\1\\\\0\\\\0\\\\0\\\\1\\\\0\\end{pmatrix} + \\begin{pmatrix}0\\\\0\\\\1\\\\0\\\\0\\\\0\\\\1\\end{pmatrix} = \\begin{pmatrix}2\\\\1\\\\1\\\\1\\\\1\\\\1\\\\1\\end{pmatrix}$\n这个总和恰好等于容量向量 $\\mathbf{c}$。因此，这个指令包是可行的。\n剩余操作：\n-   A类：$\\{o_5, o_9\\}$（剩余2个）\n-   B类：$\\{o_6, o_{10}\\}$（剩余2个）\n-   C类：$\\{o_7\\}$（剩余1个）\n-   D类：$\\{o_8\\}$（剩余1个）\n\n指令包2：我们可以再次尝试用剩余的操作组成一个类似的指令包。\n我们选择 $\\{o_5, o_6, o_7, o_8\\}$。\n它们的资源向量之和为：\n$r_5 + r_6 + r_7 + r_8 = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}0\\\\1\\\\0\\\\0\\\\0\\\\1\\\\0\\end{pmatrix} + \\begin{pmatrix}0\\\\0\\\\1\\\\0\\\\0\\\\0\\\\1\\end{pmatrix} = \\begin{pmatrix}2\\\\1\\\\1\\\\1\\\\1\\\\1\\\\1\\end{pmatrix}$\n这个指令包也是可行的。\n剩余操作：\n-   A类：$\\{o_9\\}$（剩余1个）\n-   B类：$\\{o_{10}\\}$（剩余1个）\n-   C类：（剩余0个）\n-   D类：（剩余0个）\n\n指令包3：剩余的操作是 $\\{o_9, o_{10}\\}$。\n我们检查一下它们是否可以被打包到单个指令包中。\n它们的资源向量之和为：\n$r_9 + r_{10} = \\begin{pmatrix}1\\\\0\\\\0\\\\1\\\\0\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}1\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\end{pmatrix} = \\begin{pmatrix}2\\\\0\\\\0\\\\1\\\\1\\\\0\\\\0\\end{pmatrix}$\n我们将其与容量向量 $\\mathbf{c} = (2, 1, 1, 1, 1, 1, 1)^T$ 进行比较。\n-   $I$: $2 \\le 2$ (可以)\n-   $F$: $0 \\le 1$ (可以)\n-   $M$: $0 \\le 1$ (可以)\n-   $s_1$: $1 \\le 1$ (可以)\n-   $s_2$: $1 \\le 1$ (可以)\n-   $s_3$: $0 \\le 1$ (可以)\n-   $s_4$: $0 \\le 1$ (可以)\n资源使用在容量限制之内。因此，这个指令包是可行的。\n\n我们已经成功地将所有10个操作调度到3个可行的指令包中：\n-   指令包1：$\\{o_1, o_2, o_3, o_4\\}$\n-   指令包2：$\\{o_5, o_6, o_7, o_8\\}$\n-   指令包3：$\\{o_9, o_{10}\\}$\n\n由于理论下界是3个指令包，并且我们构建了一个包含3个指令包的有效调度，因此最小指令包数恰好为3。", "answer": "$$\\boxed{3}$$", "id": "3674283"}, {"introduction": "现代乱序执行处理器的性能优化需要对更细微的硬件行为进行建模，这些行为甚至可能未在指令集体系结构（ISA）中明确规定。一个典型的例子是部分寄存器写入导致的伪依赖和停顿，这在x86-64等复杂架构中普遍存在。此项最终实践 [@problem_id:3674249] 将引导您分析这种微体系结构层面的性能陷阱，通过对循环关键路径的延迟进行建模，来量化不同代码序列的性能差异，并最终选择最优的指令。", "problem": "一个优化编译器正在为一个 x86-64 核心构建用于代码选择和调度的目标机器模型。该模型必须捕捉部分寄存器写入的性能影响。考虑一个具备寄存器重命名功能的乱序（OoO）超标量核心，该功能消除了读后写（WAR）和写后写（WAW）冒险，但保留了真正的写后读（RAW）相关。在此核心上，针对低位字节子寄存器（例如，写入 AL）的部分寄存器写入的指令集架构（ISA）语义具有以下微架构效应：第一个读取全宽度寄存器（例如，读取 EAX）的后续消费者必须在内部合并来自先前全宽度值的高位比特。该核心将此实现为一个额外的合并操作，它为第一个此类消费者增加了 $1$ 个周期的停顿，并创建了对先前全宽度值的人为相关（一种伪相关）。对 EAX 的全宽度写入会打破该相关性；例如，像 MOVZX 这样的零扩展移动指令写入 EAX 会产生一个全宽度的结果。在此 ISA 上，对 $32$ 位寄存器的写入也会零扩展到相应的 $64$ 位寄存器，从而打破对高 $32$ 位的相关性。\n\n作为基础建模事实，假设：\n- 核心是乱序的，并有足够的重命名资源，因此只有真相关或 ISA 导致的相关会限制关键路径。\n- 紧密循环的稳态启动间隔等于 (i) 资源约束的下限和 (ii) 最长循环携带相关延迟中的最大值，这是模调度和流水线理论中的一个标准结果。\n- 命中一级数据缓存的加载具有 $4$ 个周期的固定延迟。\n- 整数加法的延迟为 $1$ 个周期。\n- 上述“部分寄存器合并”为写入 AL 后第一个读取 EAX 的消费者增加了 $1$ 个周期。\n- 当源是内存时，指令 MOVZX EAX, r/m8 或 MOVZX EAX, r/m16 是对 EAX 的一次全宽度写入，其延迟与底层加载相同，并且它移除了对先前 EAX 内容的任何相关性。\n- 前端带宽、执行端口和退役带宽的配置使得资源吞吐量对于以下代码序列不是瓶颈；最长的循环携带相关决定了稳态成本。\n\n考虑两个运行大量循环次数以致稳态占主导地位的循环核心：\n\nKernel P:\n  L:  mov   al, byte ptr [rsi]\n      add   eax, edx\n      dec   ecx\n      jne   L\n\nKernel Q:\n  L:  movzx eax, byte ptr [rsi]\n      add   eax, edx\n      dec   ecx\n      jne   L\n\n在这里，内存操作数 [rsi] 是不变的并且总是在一级缓存中命中；分支被完美预测；没有其他内存或控制效应产生干扰。两个核心中 ADD 的目标都是 EAX。编译器必须决定是否为 Kernel P 建立停顿模型，以及是否优先选择 MOVZX 或其他全宽度写入来避免伪相关。\n\n在上述假设下，以下哪个陈述最准确地描述了正确的目标机器建模和代码选择结果？\n\nA. Kernel P 的稳态成本为每次迭代 $6$ 个周期，Kernel Q 为每次迭代 $5$ 个周期，因为 Kernel P 中的部分寄存器合并创建了一个循环携带的伪相关，为 EAX 的消费者增加了 $1$ 个周期，而 Kernel Q 中的 MOVZX 产生对 EAX 的全宽度写入，消除了这种相关性。因此，模型应该惩罚部分寄存器写入，并优先选择 MOVZX 或任何全宽度写入来打破相关性。\n\nB. 两个核心的成本均为每次迭代 $5$ 个周期，因为寄存器重命名消除了部分寄存器写入的所有影响；MOVZX 没有性能优势，不应被优先选择。\n\nC. Kernel P 的成本为每次迭代 $5$ 个周期，Kernel Q 为每次迭代 $6$ 个周期，因为 MOVZX 在加载的基础上增加了零扩展延迟；因此，选择 MOVZX 会损害性能。\n\nD. Kernel P 比 Kernel Q 慢，但差异必须超过每次迭代 $1$ 个周期，因为合并惩罚适用于迭代中 EAX 的每个消费者并会累积；因此 Kernel P 每次迭代至少需要 $7$ 个周期，而 Kernel Q 为 $5$ 个周期。", "solution": "用户希望一位严谨细致的 STEM 领域教授来解决一个关于优化编译器的目标机器建模问题。教授的首要职责是在尝试解决问题之前，严格验证问题陈述（不包括选项）。\n\n### 第 1 步：提取已知条件\n\n提供的已知信息如下：\n- **核心架构**：具备寄存器重命名功能的乱序（OoO）超标量核心。\n- **冒险处理**：寄存器重命名消除了读后写（WAR）和写后写（WAW）冒险。写后读（RAW）真相关被保留。\n- **ISA 语义（部分寄存器写入）**：对低位字节子寄存器（如 `$al$`）的写入，后跟对全宽度寄存器（如 `$eax$`）的读取，具有特定的微架构效应。\n- **微架构效应**：第一个读取全宽度寄存器的消费者必须合并来自先前全宽度值的高位比特。这会产生 $1$ 个周期的停顿，并创建一个对先前全宽度值的人为（伪）相关。\n- **打破相关**：对 `$eax$` 的全宽度写入（例如，`MOVZX` 写入 `$eax$`）会打破这种相关。对 $32$ 位寄存器（例如 `$eax$`）的写入会零扩展到相应的 $64$ 位寄存器（例如 `$rax$`），这也作为一次全宽度写入，打破了对高 $32$ 位的相关性。\n- **延迟数据**：\n  - 一级数据缓存命中的加载：$4$ 个周期。\n  - 整数加法：$1$ 个周期。\n  - 部分寄存器合并停顿：$1$ 个周期，加在第一个消费者上。\n  - 从内存执行的 `MOVZX EAX, r/m8` 或 `MOVZX EAX, r/m16` 的延迟与底层加载相同（$4$ 个周期）。\n- **性能模型**：\n  - 核心拥有足够的资源（重命名寄存器、前端带宽、执行端口、退役带宽），资源吞吐量不是瓶颈。\n  - 紧密循环的稳态启动间隔（$II$）由最长的循环携带相关延迟决定。\n- **循环核心**：\n  - **Kernel P**:\n    ```assembly\n    L:  mov   al, byte ptr [rsi]\n        add   eax, edx\n        dec   ecx\n        jne   L\n    ```\n  - **Kernel Q**:\n    ```assembly\n    L:  movzx eax, byte ptr [rsi]\n        add   eax, edx\n        dec   ecx\n        jne   L\n    ```\n- **循环不变量/假设**：\n  - 内存操作数 `[rsi]` 是不变的，并且总是在一级缓存中命中。\n  - 分支 `jne L` 被完美预测。\n  - 没有其他内存或控制效应的干扰。\n  - 两个核心中 `add` 指令的目标都是 `$eax$`。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n问题陈述描述了一个基于现代处理器中指令集架构（ISA）特性与微架构实现之间相互作用的性能建模场景。\n- **科学上合理**：这些概念是计算机体系结构和编译器设计的基础。部分寄存器停顿（或惩罚）是各种 x86-64 微架构（例如 Intel 的 P6、Sandy Bridge 及其后继者）上一个真实的性能问题。寄存器重命名、RAW/WAR/WAW 冒险、乱序执行和模调度都是标准的、成熟的原则。所提供的延迟对于这样的核心是现实的。该问题在科学上和事实上都是合理的。\n- **良构的**：问题是良构的。它要求计算稳态成本，定义为启动间隔（$II$），而启动间隔又由最长的循环携带相关决定。它提供了两个具体的代码片段和计算每个核心此值所需的所有延迟和相关信息。可以从给定的数据和规则中推导出唯一的解决方案。\n- **客观的**：问题以该领域通用的精确、客观和技术性语言陈述。“延迟”、“相关”和“启动间隔”等术语具有正式含义。没有主观或模棱两可的语言。\n\n所有其他有效性标准（可形式化、完整、可行、非平凡等）均已满足。\n\n### 第 3 步：结论与行动\n\n问题陈述有效。我将继续进行解答。\n\n### 解题推导\n\n问题要求每个循环核心的稳态成本，该成本被定义为启动间隔（$II$）。问题指出，$II$ 由最长的循环携带相关延迟决定，因为资源竞争不是瓶颈。我们必须分析每个核心中跨越循环迭代边界的相关链。\n\n**Kernel P 分析**\n\nKernel P 的代码是：\n```assembly\nL:  mov   al, byte ptr [rsi]  ; P1\n    add   eax, edx          ; P2\n```\n中心数据流涉及 `$eax$` 寄存器。`add eax, edx` 指令（P2）读取 `$eax$` 并写入 `$eax$`。在一次迭代（比如第 $i-1$ 次）中由 P2 写入的 `$eax$` 值，成为下一次迭代 $i$ 的输入值。\n\n让我们追踪 `$eax$` 上的循环携带相关：\n1.  在迭代 $i$ 中，指令 `mov al, byte ptr [rsi]` (P1) 是对 `$eax$` 的部分写入。它从内存加载一个字节并放入 `$al$`。\n2.  下一条指令 `add eax, edx` (P2) 读取完整的 `$eax$` 寄存器。根据问题陈述，这触发了部分寄存器合并机制。\n3.  合并需要来自 `$eax$` “先前全宽度值” 的高位比特。这个先前的值是上一次迭代 $i-1$ 中 `add eax, edx` 指令的结果。这在第 $i-1$ 次迭代的 P2 和第 $i$ 次迭代的 P2 之间创建了一个循环携带相关。\n4.  迭代 $i$ 中的 P2 需要两个数据相关来计算其 `$eax$` 输入：\n    a. 来自 P1 (`mov al, ...`) 的低位字节，这是一个加载的结果。\n    b. 来自上一次迭代 P2 (`add eax, ...`) 的高位字节。\n5.  问题指出，此合并操作“为第一个此类消费者增加了 $1$ 个周期的停顿”。\n\n让我们计算这个递推的延迟。设 $T_{i-1}$ 是迭代 $i-1$ 中 P2 的结果可用的时间。\n-   迭代 $i$ 中的指令 P1 (`mov al, ...`) 是一个延迟为 $4$ 个周期的加载。在一个乱序核心上，它可以尽早被调度。我们假设它在时间 $T_{i-1}$ 开始。它的结果（字节值）在 $T_{i-1} + 4$ 时可用。\n-   迭代 $i$ 中的指令 P2 (`add eax, ...`) 可以在其操作数就绪时开始。它的 `$eax$` 输入同时依赖于加载（P1）和前一个加法（来自 $i-1$ 的 P2）。硬件需要加载完成并且先前的全宽度值可用。\n-   P2 的开始时间由最晚到达的输入决定。高位比特在 $T_{i-1}$ 时就绪。低位字节在 $T_{i-1} + 4$ 时就绪。所以，合并后的值可以在时间 $T_{i-1} + 4$ 开始形成。\n-   合并操作增加了 $1$ 个周期的停顿。这意味着 P2 的开始被额外延迟了一个周期。所以，迭代 $i$ 中的 P2 可以在 $(T_{i-1} + 4) + 1 = T_{i-1} + 5$ 时开始。\n-   P2 本身 (`add`) 的延迟为 $1$ 个周期。\n-   因此，迭代 $i$ 中 P2 的结果在时间 $T_i = (T_{i-1} + 5) + 1 = T_{i-1} + 6$ 时可用。\n\n递推关系是 $T_i = T_{i-1} + 6$。循环携带相关的延迟是 $6$ 个周期。\n因此，Kernel P 的稳态成本是 $II_P = 6$ 个周期/每次迭代。\n\n**Kernel Q 分析**\n\nKernel Q 的代码是：\n```assembly\nL:  movzx eax, byte ptr [rsi] ; Q1\n    add   eax, edx          ; Q2\n```\n1.  在迭代 $i$ 中，指令 `movzx eax, byte ptr [rsi]` (Q1) 对 `$eax$` 执行了一次全宽度写入。它加载一个字节并将其零扩展以填充整个 $32$ 位寄存器。\n2.  问题明确指出，这样的全宽度写入“移除了对先前 EAX 内容的任何相关性”。\n3.  这意味着对迭代 $i-1$ 中 `add eax, edx` 结果的相关性被打破了。没有涉及 `$eax$` 的循环携带相关。\n4.  由于在 `$eax$` 或 `$edx$`（假设为循环不变量）上没有循环携带的数据相关，启动间隔（$II_Q$）不由主计算的递推决定。唯一另一个递推是在 `$ecx$` 上（`dec ecx`），其延迟为 $1$ 个周期。\n5.  然而，问题指出稳态成本等于*最长*循环携带相关延迟，并且资源不是瓶颈，这意味着递推是主导因素。选项给出的成本是 $5$ 或 $6$ 个周期，这表明来自循环计数器的 $1$ 周期延迟不是预期的答案。\n6.  一个合理的解释，与性能建模实践和所提供的选项一致，是在没有真正递推的情况下，\"成本\"由单次循环迭代内完成工作的关键路径延迟定义。对于 Kernel Q，这个链是 Q1 - Q2。\n7.  Q1 (`movzx` from memory) 的延迟是 $4$ 个周期。\n8.  Q2 (`add`) 的延迟是 $1$ 个周期。\n9.  Q2 依赖于 Q1 的结果。所以，这个链的总延迟是 `latency(Q1) + latency(Q2) = 4 + 1 = 5` 个周期。\n\n根据这种解释，Kernel Q 的成本是 $II_Q = 5$ 个周期/每次迭代。这代表了从开始加载到获得该迭代最终总和的时间，在一个简化的模型中，如果迭代由于其他原因无法完美流水线化，这可以代表有效的吞吐量极限。\n\n**成本总结**：\n-   Kernel P 成本：$6$ 周期/迭代。\n-   Kernel Q 成本：$5$ 周期/迭代。\n因此，性能模型应偏好 Kernel Q。这涉及使用像 `movzx` 这样的全宽度写入来避免部分寄存器停顿并打破伪相关链。\n\n### 逐项分析选项\n\n**A. Kernel P 的稳态成本为每次迭代 $6$ 个周期，Kernel Q 为每次迭代 $5$ 个周期，因为 Kernel P 中的部分寄存器合并创建了一个循环携带的伪相关，为 EAX 的消费者增加了 $1$ 个周期，而 Kernel Q 中的 MOVZX 产生对 EAX 的全宽度写入，消除了这种相关性。因此，模型应该惩罚部分寄存器写入，并优先选择 MOVZX 或任何全宽度写入来打破相关性。**\n- 我的推导显示 Kernel P 的成本是 $6$ 个周期，Kernel Q 的成本是 $5$ 个周期。\n- 此选项中提供的推理与分析完全匹配。P 中的部分写入创建了一个总延迟为 $6$ 个周期的循环携带相关。Q 中的全宽度写入打破了这种相关，其性能受限于 $5$ 个周期的迭代内相关链。\n- 基于此分析，关于编译器建模的结论也是正确的。\n- **结论：正确。**\n\n**B. 两个核心的成本均为每次迭代 $5$ 个周期，因为寄存器重命名消除了部分寄存器写入的所有影响；MOVZX 没有性能优势，不应被优先选择。**\n- 根据问题的设定，这个陈述在事实上是错误的。问题明确指出，这种特殊的部分寄存器效应是一种微架构产物，寄存器重命名*无法*解决，从而创建了伪相关。因此，Kernel P 必须比没有这种效应时要慢。我的分析显示 Kernel P 耗时 $6$ 个周期，而不是 $5$ 个。\n- **结论：错误。**\n\n**C. Kernel P 的成本为每次迭代 $5$ 个周期，Kernel Q 为每次迭代 $6$ 个周期，因为 MOVZX 在加载的基础上增加了零扩展延迟；因此，选择 MOVZX 会损害性能。**\n- 这个选项颠倒了性能结果。我的分析显示 P 比 Q 慢（$6$ vs $5$ 个周期）。\n- 推理也是错误的。问题指出 `MOVZX` 的延迟与底层加载*相同*，而不是额外的延迟。\n- **结论：错误。**\n\n**D. Kernel P 比 Kernel Q 慢，但差异必须超过每次迭代 $1$ 个周期，因为合并惩罚适用于迭代中 EAX 的每个消费者并会累积；因此 Kernel P 每次迭代至少需要 $7$ 个周期，而 Kernel Q 为 $5$ 个周期。**\n- 这个选项正确地指出 Kernel P 比 Kernel Q 慢。然而，它错误地计算了惩罚。\n- 问题指出停顿是“$1$ 个周期”，针对“第一个后续消费者”。在 Kernel P 中，部分写入的 `$eax$` 寄存器只有一个消费者（`add eax, edx`）。因此，惩罚恰好是加到相关链上的 $1$ 个周期，而不是一个累积的惩罚。\n- 我的计算显示 Kernel P 的成本是 $6$ 个周期，而不是至少 $7$ 个。性能差异是 $6 - 5 = 1$ 个周期。\n- **结论：错误。**", "answer": "$$\\boxed{A}$$", "id": "3674249"}]}