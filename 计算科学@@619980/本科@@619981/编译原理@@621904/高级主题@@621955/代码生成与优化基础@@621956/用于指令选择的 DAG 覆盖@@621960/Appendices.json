{"hands_on_practices": [{"introduction": "本练习介绍了DAG覆盖的基本目标：选择一组指令模式，以最低的总成本覆盖整个计算图。通过一个包含共享子表达式的算术表达式，你将实践如何评估不同覆盖策略的成本，特别是权衡使用多个简单指令与使用单个功能更强大的融合指令（如融合乘加）之间的利弊[@problem_id:3634952]。这个过程是指令选择优化的核心。", "problem": "编译器后端通过用指令模式覆盖一个中间表示 (IR) 有向无环图 (DAG) 来执行指令选择，从而使得每个 IR 操作节点都由一条目标指令实现，且总成本最小化。考虑算术表达式 $$((a+b)\\times(c+d))+(a+b),$$ 的 IR DAG，其中子表达式 $$a+b$$ 是显式共享的。设 DAG 节点标记如下：$$n_{1}=\\mathrm{add}(a,b),\\quad n_{2}=\\mathrm{add}(c,d),\\quad n_{3}=\\mathrm{mul}(n_{1},n_{2}),\\quad n_{4}=\\mathrm{add}(n_{3},n_{1}).$$ 所有叶节点 $$a,b,c,d$$ 都是已在寄存器中可用的值，成本为零。\n\n目标机器支持以下指令模式（树模式），其成本以抽象单位计算：\n- $$p_{\\mathrm{add}}:\\ \\mathrm{add}(x,y)\\ \\text{成本为}\\ 1.$$\n- $$p_{\\mathrm{mul}}:\\ \\mathrm{mul}(x,y)\\ \\text{成本为}\\ 2.$$\n- $$p_{\\mathrm{fma}}:\\ \\mathrm{add}(\\mathrm{mul}(x,y),z)\\ \\text{成本为}\\ 2.$$\n\n这里 $$\\mathrm{add}$$ 和 $$\\mathrm{mul}$$ 是可交换运算符，并且由于交换律，融合乘加 (FMA) 指令 $$p_{\\mathrm{fma}}$$ 可以匹配 $$\\mathrm{add}(\\mathrm{mul}(x,y),z)$$ 或 $$\\mathrm{add}(z,\\mathrm{mul}(x,y))$$。如果一个节点的运算符及其子树的形状与模式吻合，则该模式匹配该节点；当在某个节点选择 $$p_{\\mathrm{fma}}$$ 时，它会在一条指令中同时覆盖该 $$\\mathrm{add}$$ 节点及其 $$\\mathrm{mul}$$ 子节点。每个内部 IR 节点必须被某个选定的模式精确覆盖一次，叶节点 $$a,b,c,d$$ 不产生任何成本。总成本是所选模式成本的总和。\n\n仅使用有向无环图 (DAG)、模式匹配和用于指令选择的加性成本模型的定义，确定覆盖给定表达式的 DAG 的最小可能总成本。将最小总成本报告为单个整数。无需四舍五入；请提供一个精确的整数。", "solution": "任务是找到一组指令模式，共同覆盖 DAG 的所有内部节点 $\\{n_1, n_2, n_3, n_4\\}$ 各一次，使得所选模式的成本之和最小化。这等价于找到节点集的最小成本划分，其中划分的每个块由单个指令模式覆盖。\n\n需要被覆盖的节点是 $n_1 = \\mathrm{add}(a,b)$，$n_2 = \\mathrm{add}(c,d)$，$n_3 = \\mathrm{mul}(n_1,n_2)$，以及根节点 $n_4 = \\mathrm{add}(n_3,n_1)$。设 $\\mathcal{N} = \\{n_1, n_2, n_3, n_4\\}$ 为内部节点集合。\n\n我们分析可以在每个节点上匹配的可能模式。如果一个节点是模式的根，则称该模式在该节点处匹配。\n- 在 $n_1 = \\mathrm{add}(a,b)$ 处：唯一匹配的模式是 $p_{\\mathrm{add}}$。叶节点 $a$ 和 $b$ 不构成 `mul` 子树，所以 $p_{\\mathrm{fma}}$ 无法匹配。如果选择此模式，它将覆盖节点 $\\{n_1\\}$。\n- 在 $n_2 = \\mathrm{add}(c,d)$ 处：类似地，只有 $p_{\\mathrm{add}}$ 可以匹配。如果选择此模式，它将覆盖节点 $\\{n_2\\}$。\n- 在 $n_3 = \\mathrm{mul}(n_1,n_2)$ 处：唯一匹配的模式是 $p_{\\mathrm{mul}}$。如果选择此模式，它将覆盖节点 $\\{n_3\\}$。\n- 在 $n_4 = \\mathrm{add}(n_3,n_1)$ 处：\n  1. $p_{\\mathrm{add}}$ 模式可以匹配。如果选择此模式，它将覆盖节点 $\\{n_4\\}$。\n  2. $p_{\\mathrm{fma}}$ 模式，即 $\\mathrm{add}(\\mathrm{mul}(x,y),z)$，也可以匹配。问题陈述中说明 $\\mathrm{add}$ 是可交换的，因此该模式可以匹配 $\\mathrm{add}(\\mathrm{mul}(...),...)$ 或 $\\mathrm{add}(...,\\mathrm{mul}(...))$。节点 $n_4$ 是 $\\mathrm{add}(n_3,n_1)$。由于 $n_3$ 是一个 $\\mathrm{mul}$ 节点，这个结构匹配 $p_{\\mathrm{fma}}$。如果选择此模式，它将同时覆盖 $\\mathrm{add}$ 节点 $n_4$ 及其子节点 $\\mathrm{mul}$ 节点 $n_3$。被覆盖的节点集合是 $\\{n_3, n_4\\}$。\n\n为了找到最小成本覆盖，我们必须为根节点 $n_4$ 的覆盖做出选择。这导致了两种不同的划分节点集 $\\mathcal{N}$ 的情况。\n\n**情况 1：使用 $p_{\\mathrm{add}}$ 模式覆盖节点 $n_4$。**\n- 我们选择模式 $p_{\\mathrm{add}}$ 在节点 $n_4$ 处匹配。这覆盖了节点集 $\\{n_4\\}$。产生的成本为 $1$。\n- 剩余待覆盖的节点是 $\\{n_1, n_2, n_3\\}$。\n- 为了覆盖节点 $n_3 = \\mathrm{mul}(n_1,n_2)$，我们必须使用 $p_{\\mathrm{mul}}$ 模式。这覆盖了节点集 $\\{n_3\\}$。该模式产生的成本为 $2$。\n- 剩余待覆盖的节点是 $\\{n_1, n_2\\}$。\n- 为了覆盖节点 $n_1 = \\mathrm{add}(a,b)$，我们必须使用 $p_{\\mathrm{add}}$ 模式。这覆盖了节点集 $\\{n_1\\}$。成本为 $1$。\n- 为了覆盖节点 $n_2 = \\mathrm{add}(c,d)$，我们必须使用 $p_{\\mathrm{add}}$ 模式。这覆盖了节点集 $\\{n_2\\}$。成本为 $1$。\n- 完整的覆盖由在 $n_4$、$n_3$、$n_1$ 和 $n_2$ 处匹配的模式组成。被覆盖的节点集是 $\\{n_4\\}$、$\\{n_3\\}$、$\\{n_1\\}$ 和 $\\{n_2\\}$，它们构成了 $\\mathcal{N}$ 的一个划分。这是一个有效的覆盖。\n- 此情况下的总成本是所选模式的成本之和：$1 (\\text{用于 } n_4) + 2 (\\text{用于 } n_3) + 1 (\\text{用于 } n_1) + 1 (\\text{用于 } n_2) = 5$。\n\n**情况 2：使用 $p_{\\mathrm{fma}}$ 模式覆盖节点 $n_4$。**\n- 我们选择模式 $p_{\\mathrm{fma}}$ 在节点 $n_4$ 处匹配。该模式匹配结构 $\\mathrm{add}(n_3, n_1)$，因为 $n_3$ 是一个 $\\mathrm{mul}$ 节点。这一个模式同时覆盖了节点 $n_4$ 和 $n_3$。被覆盖的节点集合是 $\\{n_3, n_4\\}$。产生的成本为 $2$。\n- 剩余待覆盖的节点是 $\\{n_1, n_2\\}$。\n- 为了覆盖节点 $n_1 = \\mathrm{add}(a,b)$，我们必须使用 $p_{\\mathrm{add}}$ 模式。这覆盖了 $\\{n_1\\}$。成本为 $1$。\n- 为了覆盖节点 $n_2 = \\mathrm{add}(c,d)$，我们必须使用 $p_{\\mathrm{add}}$ 模式。这覆盖了 $\\{n_2\\}$。成本为 $1$。\n- 完整的覆盖由在 $n_4$ 处的一个 $p_{\\mathrm{fma}}$ 模式和在 $n_1$、$n_2$ 处的 $p_{\\mathrm{add}}$ 模式组成。被覆盖的节点集是 $\\{n_3, n_4\\}$、$\\{n_1\\}$ 和 $\\{n_2\\}$，它们构成了 $\\mathcal{N}$ 的一个划分。这也是一个有效的覆盖。\n- 此情况下的总成本是：$2 (\\text{用于 } n_4 \\text{ 和 } n_3) + 1 (\\text{用于 } n_1) + 1 (\\text{用于 } n_2) = 4$。\n\n**结论**\n我们已经列举了所有可能的 DAG 有效覆盖。两种可能的总成本是 $5$ 和 $4$。最小可能总成本是这些值中的最小值。\n$$ \\min(5, 4) = 4 $$\n因此，覆盖给定 DAG 的最小成本是 $4$。这是通过使用一条融合乘加指令和两条加法指令实现的。", "answer": "$$\\boxed{4}$$", "id": "3634952"}, {"introduction": "在基础成本模型之上，本练习引入了一个源于现实世界RISC架构的关键约束——立即数操作数的大小限制。你将学习如何计算将无法直接编码的大常数“具象化”到寄存器中的成本，以及在DAG中共享这些具象化常数如何影响最终的总指令数[@problem_id:3635002]。这个挑战突显了指令选择必须与目标机器的具体特性紧密结合。", "problem": "一个编译器后端必须在以下中间表示上通过有向无环图（DAG）覆盖来执行指令选择。目标机器是一种加载-存储架构，类似于精简指令集计算机第五版（RISC-V），具有以下相关属性：\n- 所有输入变量 $x$、$y$ 和 $z$ 都存放在寄存器中。\n- 该机器支持单位成本为 $1$ 的算术指令：ADD、ADDI 和 MUL。\n- 立即数形式的 ADDI 使用一个 12 位有符号立即数；也就是说，立即数 $i$ 必须满足 $-2048 \\le i \\le 2047$ 才能被直接编码。\n- LUI 指令以单位成本 $1$ 将一个常数的高位部分加载到寄存器中。任何满足 $|C| \\le 2047$ 的常数 $C$ 都可以通过对零寄存器使用 ADDI 指令，在一条指令内物化；任何满足 $|C|  2047$ 的常数 $C$ 都可以通过 LUI 后跟 ADDI，用恰好 $2$ 条指令物化。假设机器有足够的寄存器，以便常数一旦物化就可以被重用，而无需额外的溢出开销。\n\n需要覆盖的中间表示是一个带有共享常数子表达式的有向无环图（DAG）：\n- 节点：\n  - $n_{1} = \\mathrm{CONST}(5000)$\n  - $n_{2} = \\mathrm{CONST}(131071)$\n  - $n_{3} = \\mathrm{ADD}(x, n_{1})$\n  - $n_{4} = \\mathrm{ADD}(y, n_{1})$\n  - $n_{5} = \\mathrm{MUL}(z, n_{2})$\n  - $n_{6} = \\mathrm{ADD}(n_{5}, n_{1})$\n  - $n_{7} = \\mathrm{ADD}(n_{3}, n_{4})$\n  - $n_{8} = \\mathrm{ADD}(n_{7}, n_{6})$  (根节点)\n\n语义：\n- $\\mathrm{ADD}(a,b)$ 表示 $a$ 和 $b$ 的整数加法。\n- $\\mathrm{MUL}(a,b)$ 表示 $a$ 和 $b$ 的整数乘法。\n- $\\mathrm{CONST}(C)$ 表示整数常量 $C$。\n- 常数 $5000$ 和 $131071$ 的绝对值大于 $2047$，因此它们不符合 ADDI 立即数的范围。\n\n通过 DAG 覆盖进行指令选择时，必须选择能将节点映射到机器指令的模式，同时要遵循立即数范围约束，并允许通过 LUI 后跟 ADDI 来物化大常数。任何将不可编码的常数用作 ADD 或 MUL 的操作数时，都要求该常数已事先物化到一个寄存器中。已物化的常数可以在其于 DAG 中的所有使用点之间共享，而无需额外的物化成本。\n\n使用这些规则，并以最小化机器指令总数为优化目标，计算覆盖以 $n_{8}$ 为根的整个 DAG 所需的最小指令数。仅返回最小指令数（一个整数）。假设不允许代数重结合或重排序；你必须精确地覆盖给定的 DAG。假设所有指令的成本均为 $1$。你不需要对答案进行四舍五入。", "solution": "我们从编译器后端中用于指令选择的有向无环图（DAG）覆盖的核心定义开始。一个 DAG $G$ 编码了操作之间的数据依赖关系。一个覆盖将 DAG 节点映射到目标机器的指令模式，使得：\n- 每个中间表示节点的语义由一条或多条目标指令实现。\n- 仅当常数操作数符合目标机器的立即数范围时，才允许使用立即数形式的指令。\n- 共享子图（例如具有多个父节点的常数节点）可以实现一次并在其所有父节点中重用，前提是目标机器有足够的寄存器。总成本目标是所选目标指令的成本之和。\n\n给定目标机器的属性：\n- ADD 指令使用两个寄存器操作数，成本为 $1$。\n- ADDI 指令成本为 $1$，但仅当立即数 $i$ 满足 $-2048 \\le i \\le 2047$ 时才可用。\n- LUI 指令成本为 $1$，可以与成本为 $1$ 的 ADDI 指令组合来物化任何更大的常数。根据假设，对于 $|C|  2047$ 的常数 $C$，通过 $\\mathrm{LUI} + \\mathrm{ADDI}$ 恰好用 $2$ 条指令物化。\n\n我们分析该 DAG：\n- $n_{1} = \\mathrm{CONST}(5000)$ 的 $|5000|  2047$，因此需要物化。根据规则，通过 $\\mathrm{LUI} + \\mathrm{ADDI}$ 物化 $5000$ 的成本是 $2$ 条指令。因为 $n_{1}$ 被 $n_{3}$、$n_{4}$ 和 $n_{6}$ 共享，我们可以重用存放 $5000$ 的那个已物化的寄存器，而无需额外的物化成本。\n- $n_{2} = \\mathrm{CONST}(131071)$ 的 $|131071|  2047$，因此也需要物化。通过 $\\mathrm{LUI} + \\mathrm{ADDI}$ 物化 $131071$ 的成本是 $2$ 条指令。它在 $n_{5}$ 中使用了一次。\n\n接下来，我们在立即数约束下，枚举操作符节点和可行的指令选择：\n- $n_{3} = \\mathrm{ADD}(x, n_{1})$：由于 $n_{1}$ 对于 ADDI 立即数来说太大了，我们不能直接使用带立即数 $5000$ 的 ADDI。唯一的选择是使用带有两个寄存器操作数的 ADD 指令：存放 $x$ 的寄存器和存放已物化的 $5000$ 的寄存器。这个 ADD 的成本是 $1$。\n- $n_{4} = \\mathrm{ADD}(y, n_{1})$：与 $n_{3}$ 的推理相同；ADD 的成本为 $1$。\n- $n_{5} = \\mathrm{MUL}(z, n_{2})$：没有乘法立即数指令。我们必须将 $z$ 与存放已物化的 $131071$ 的寄存器相乘。这个 MUL 的成本是 $1$。\n- $n_{6} = \\mathrm{ADD}(n_{5}, n_{1})$：同样，由于 $n_{1}$ 不符合立即数范围，我们必须使用带有两个寄存器操作数的 ADD 指令。成本为 $1$。\n- $n_{7} = \\mathrm{ADD}(n_{3}, n_{4})$：两个输入都是由先前计算生成的寄存器；使用两个寄存器操作数的 ADD 指令成本为 $1$。\n- $n_{8} = \\mathrm{ADD}(n_{7}, n_{6})$：类似地，使用两个寄存器操作数的 ADD 指令成本为 $1$。\n\n现在我们对成本求和，并注意由于共享，每个常数的物化只计算一次：\n- 唯一大常数的物化成本：\n  - 对于 $5000$：$2$ 条指令（在 $n_{3}$、$n_{4}$ 和 $n_{6}$ 之间共享）。\n  - 对于 $131071$：$2$ 条指令（在 $n_{5}$ 中使用）。\n  物化的总成本是 $2 + 2 = 4$。\n- 操作符指令成本：\n  - $n_{3}$：ADD，成本 $1$。\n  - $n_{4}$：ADD，成本 $1$。\n  - $n_{5}$：MUL，成本 $1$。\n  - $n_{6}$：ADD，成本 $1$。\n  - $n_{7}$：ADD，成本 $1$。\n  - $n_{8}$：ADD，成本 $1$。\n  操作符的总成本是 $1 + 1 + 1 + 1 + 1 + 1 = 6$。\n\n因此，最小总指令数为\n$$\n4 + 6 = 10.\n$$\n\n剩下的工作是证明其最优性。任何试图在 $n_{1}$ 或 $n_{2}$ 作为操作数时使用 ADDI 替代 ADD 的尝试都是不可行的，因为 $5000$ 和 $131071$ 超出了立即数范围 $[-2048, 2047]$。没有乘法立即数指令，所以 $n_{5}$ 必须使用带有物化常数的 MUL 指令。没有其他模式可以减少组合中间结果所需的 ADD 指令数量，因为代数重结合是不允许的，并且 DAG 规定了加法的确切结构。因为我们可以在 $5000$ 的三个使用点共享其物化结果，任何将 $5000$ 物化超过一次的覆盖方案都是严格次优的。因此，我们计算的覆盖方案是最优的，最小总指令数为 $10$。", "answer": "$$\\boxed{10}$$", "id": "3635002"}, {"introduction": "本练习探讨了一个因DAG的“图”特性而产生的复杂优化困境。当一个子表达式被多次使用时，是计算一次并共享结果更优，还是为每个使用者复制计算以启用专门的、高收益的融合指令更好？通过这个场景，你将学习建立一个决策准则，以在共享和复制之间找到最佳平衡，从而实现最小的总执行成本[@problem_id:3634928]。", "problem": "编译器后端必须通过用目标机指令模式覆盖中间表示有向无环图 (DAG) 来执行指令选择。在加性成本模型中，每条选择的指令都有一个整数成本，总成本是 DAG 覆盖中所有指令成本的总和。考虑以下情况：一个共享的生产者节点为多个消费者节点提供输入。\n\n生产者节点是 $S = \\mathrm{SHL}(x, 1)$，即按常数左移一位。按常数执行 $\\mathrm{SHL}$ 的成本是 $1$ 个成本单位。值 $S$ 被四个消费者节点使用：\n- $C_1 = \\mathrm{ADD}(S, a)$，非融合成本为 $2$。\n- $C_2 = \\mathrm{SUB}(b, S)$，非融合成本为 $2$。\n- $C_3 = \\mathrm{AND}(S, c)$，非融合成本为 $1$。\n- $C_4 = \\mathrm{XOR}(S, d)$，非融合成本为 $1$。\n\n目标机还提供了融合指令模式，这些模式包含了 $\\mathrm{SHL}(x,1)$ 的计算和消费者的操作，但这些融合模式仅在结果 $S$ 不被共享时才可用（也就是说，为该消费者提供输入的 $\\mathrm{SHL}$ 不被任何其他消费者使用）。融合模式及其成本如下：\n- $\\mathrm{FADD}(x, a)$ 用于计算 $\\mathrm{ADD}(\\mathrm{SHL}(x,1), a)$，成本为 $1$。\n- $\\mathrm{FSUB}(b, x)$ 用于计算 $\\mathrm{SUB}(b, \\mathrm{SHL}(x,1))$，成本为 $2$。\n- $\\mathrm{FAND}(x, c)$ 用于计算 $\\mathrm{AND}(\\mathrm{SHL}(x,1), c)$，成本为 $1$。\n- $\\mathrm{FXOR}(x, d)$ 用于计算 $\\mathrm{XOR}(\\mathrm{SHL}(x,1), d)$，成本为 $2$。\n\n假设采用加性成本模型，并忽略寄存器分配和调度的影响。您可以选择计算一次 $S$ 并在任意消费者子集中共享它（这些消费者必须使用非融合模式），或者在任意消费者子集中重复计算 $\\mathrm{SHL}(x,1)$ 以便为这些消费者启用相应的融合模式。如果没有消费者共享 $S$，则无需单独具体化 $S$。\n\n从有向无环图覆盖和加性成本模型的基本定义出发，推导出一个关于何时复制计算是有利的原则性决策准则，并计算在所有可能的选择（即哪些消费者（如果有的话）应该接收重复计算以启用融合模式）中可实现的最小总成本（以成本单位计）。请以成本单位的单个整数形式提供最终答案。所有成本均为整数，无需四舍五入。", "solution": "首先，让我们将问题形式化。我们有四个消费者节点，索引为 $i \\in \\{1, 2, 3, 4\\}$。对于每个消费者 $i$，我们有两种实现选择：\n1. 成本为 $C_{nf,i}$ 的非融合指令。该指令的输入值为 $S = \\mathrm{SHL}(x, 1)$，由一个共享的生产者节点计算得出。计算一次 $S$ 的成本为 $C_{S} = 1$。\n2. 成本为 $C_{f,i}$ 的融合指令。该指令直接计算消费者在移位值 $\\mathrm{SHL}(x, 1)$ 上操作的等效结果，并且只有在为该消费者复制了生产者节点 $S$ 的计算时（即其结果不被任何其他消费者使用时）才能使用。成本 $C_{f,i}$ 包括了 $\\mathrm{SHL}$ 操作的成本。\n\n给定的成本是：\n- 生产者成本：$C_{S} = 1$。\n- 非融合消费者成本：$C_{nf,1}=2$, $C_{nf,2}=2$, $C_{nf,3}=1$, $C_{nf,4}=1$。\n- 融合指令成本：$C_{f,1}=1$, $C_{f,2}=2$, $C_{f,3}=1$, $C_{f,4}=2$。\n\n任务是将消费者集合 $I = \\{1, 2, 3, 4\\}$ 划分为两个不相交的集合：$I_{share}$，即使用单个共享计算 $S$ 结果的消费者集合；以及 $I_{fuse}$，即我们为其使用融合指令的消费者集合。总成本是所有选定指令的成本之和。\n\n总成本函数 $Cost(I_{share}, I_{fuse})$ 可以表示为：\n$$Cost(I_{share}, I_{fuse}) = (\\text{Cost of shared portion}) + (\\text{Cost of fused portion})$$\n融合部分的成本是各个融合指令成本的总和：$\\sum_{j \\in I_{fuse}} C_{f,j}$。\n共享部分的成本取决于是否有节点实际在共享。如果 $I_{share}$ 非空，我们必须支付共享生产者 $S$ 的成本 $C_{S}$，以及每个非融合消费者指令的成本。如果 $I_{share}$ 为空，则此成本为 $0$。\n令 $\\delta(I_{share})$ 为一个指示函数，当 $I_{share}$ 非空时为 $1$，否则为 $0$。总成本为：\n$$Cost(I_{share}, I_{fuse}) = \\delta(I_{share}) \\cdot C_{S} + \\sum_{i \\in I_{share}} C_{nf,i} + \\sum_{j \\in I_{fuse}} C_{f,j}$$\n由于 $I_{share}$ 和 $I_{fuse}$ 构成 $I$ 的一个划分，我们可以将问题定义为找到最小化此函数的集合 $I_{fuse} \\subseteq I$。\n\n**关于复制的原则性决策准则**\n\n为了推导出一个关于何时复制（即使用融合模式）是有利的准则，我们可以分析当将单个消费者 $k$ 从共享组 $I_{share}$ 移动到融合组 $I_{fuse}$ 时总成本的变化 $\\Delta Cost$。我们必须考虑两种情况。\n\n情况1：共享组最初包含多个消费者，即 $|I_{share}|  1$。\n设初始划分为 $(I_{share}, I_{fuse})$。其成本为 $Cost_{old} = C_{S} + \\sum_{i \\in I_{share}} C_{nf,i} + \\sum_{j \\in I_{fuse}} C_{f,j}$。\n我们将消费者 $k \\in I_{share}$ 移动到融合组。新的划分为 $(I'_{share}, I'_{fuse})$，其中 $I'_{share} = I_{share} \\setminus \\{k\\}$ 且 $I'_{fuse} = I_{fuse} \\cup \\{k\\}$。由于 $|I_{share}|  1$，新的共享组 $I'_{share}$ 非空。\n新的成本为 $Cost_{new} = C_{S} + \\sum_{i \\in I'_{share}} C_{nf,i} + \\sum_{j \\in I'_{fuse}} C_{f,j} = C_{S} + (\\sum_{i \\in I_{share}} C_{nf,i} - C_{nf,k}) + (\\sum_{j \\in I_{fuse}} C_{f,j} + C_{f,k})$。\n成本变化为 $\\Delta Cost = Cost_{new} - Cost_{old} = C_{f,k} - C_{nf,k}$。\n因此，如果 $\\Delta Cost  0$，即 $C_{f,k}  C_{nf,k}$，则为消费者 $k$ 进行复制是有利的。\n\n情况2：共享组最初只包含一个消费者，即 $I_{share} = \\{k\\}$。\n初始成本为 $Cost_{old} = C_{S} + C_{nf,k} + \\sum_{j \\in I_{fuse}} C_{f,j}$。\n我们将消费者 $k$ 移动到融合组。新的共享组 $I'_{share}$ 现在为空。\n新的成本为 $Cost_{new} = 0 + \\sum_{j \\in I_{fuse} \\cup \\{k\\}} C_{f,j} = \\sum_{j \\in I_{fuse}} C_{f,j} + C_{f,k}$。\n成本变化为 $\\Delta Cost = Cost_{new} - Cost_{old} = (C_{f,k} + \\sum_{j \\in I_{fuse}} C_{f,j}) - (C_{S} + C_{nf,k} + \\sum_{j \\in I_{fuse}} C_{f,j}) = C_{f,k} - C_{nf,k} - C_{S}$。\n因此，如果 $\\Delta Cost  0$，即 $C_{f,k}  C_{nf,k} + C_{S}$，则为最后一个共享消费者 $k$ 进行复制是有利的。\n\n**最小总成本的计算**\n\n由于只有 $4$ 个消费者，因此存在 $2^4 = 16$ 种可能的划分。我们可以通过穷举评估每种划分的成本来找到最小值，按融合消费者的数量 $|I_{fuse}|$ 分组。\n\n令 $I_{fuse}$ 为融合消费者的索引集合。那么 $I_{share} = \\{1,2,3,4\\} \\setminus I_{fuse}$。\n\n情况 $|I_{fuse}| = 0$：$I_{fuse} = \\emptyset$。\n$I_{share} = \\{1,2,3,4\\}$。共享组非空。\n总成本 = $C_{S} + (C_{nf,1} + C_{nf,2} + C_{nf,3} + C_{nf,4}) = 1 + (2+2+1+1) = 7$。\n\n情况 $|I_{fuse}| = 1$：\n- $I_{fuse}=\\{1\\}$：成本 = $(C_{S} + C_{nf,2}+C_{nf,3}+C_{nf,4}) + C_{f,1} = (1+2+1+1)+1 = 6$。\n- $I_{fuse}=\\{2\\}$：成本 = $(C_{S} + C_{nf,1}+C_{nf,3}+C_{nf,4}) + C_{f,2} = (1+2+1+1)+2 = 7$。\n- $I_{fuse}=\\{3\\}$：成本 = $(C_{S} + C_{nf,1}+C_{nf,2}+C_{nf,4}) + C_{f,3} = (1+2+2+1)+1 = 7$。\n- $I_{fuse}=\\{4\\}$：成本 = $(C_{S} + C_{nf,1}+C_{nf,2}+C_{nf,3}) + C_{f,4} = (1+2+2+1)+2 = 8$。\n\n情况 $|I_{fuse}| = 2$：\n- $I_{fuse}=\\{1,2\\}$：成本 = $(C_{S} + C_{nf,3}+C_{nf,4}) + (C_{f,1}+C_{f,2}) = (1+1+1)+(1+2) = 6$。\n- $I_{fuse}=\\{1,3\\}$：成本 = $(C_{S} + C_{nf,2}+C_{nf,4}) + (C_{f,1}+C_{f,3}) = (1+2+1)+(1+1) = 6$。\n- $I_{fuse}=\\{1,4\\}$：成本 = $(C_{S} + C_{nf,2}+C_{nf,3}) + (C_{f,1}+C_{f,4}) = (1+2+1)+(1+2) = 7$。\n- $I_{fuse}=\\{2,3\\}$：成本 = $(C_{S} + C_{nf,1}+C_{nf,4}) + (C_{f,2}+C_{f,3}) = (1+2+1)+(2+1) = 7$。\n- $I_{fuse}=\\{2,4\\}$：成本 = $(C_{S} + C_{nf,1}+C_{nf,3}) + (C_{f,2}+C_{f,4}) = (1+2+1)+(2+2) = 8$。\n- $I_{fuse}=\\{3,4\\}$：成本 = $(C_{S} + C_{nf,1}+C_{nf,2}) + (C_{f,3}+C_{f,4}) = (1+2+2)+(1+2) = 8$。\n\n情况 $|I_{fuse}| = 3$：\n- $I_{fuse}=\\{1,2,3\\}$：成本 = $(C_{S} + C_{nf,4}) + (C_{f,1}+C_{f,2}+C_{f,3}) = (1+1)+(1+2+1) = 6$。\n- $I_{fuse}=\\{1,2,4\\}$：成本 = $(C_{S} + C_{nf,3}) + (C_{f,1}+C_{f,2}+C_{f,4}) = (1+1)+(1+2+2) = 7$。\n- $I_{fuse}=\\{1,3,4\\}$：成本 = $(C_{S} + C_{nf,2}) + (C_{f,1}+C_{f,3}+C_{f,4}) = (1+2)+(1+1+2) = 7$。\n- $I_{fuse}=\\{2,3,4\\}$：成本 = $(C_{S} + C_{nf,1}) + (C_{f,2}+C_{f,3}+C_{f,4}) = (1+2)+(2+1+2) = 8$。\n\n情况 $|I_{fuse}| = 4$：$I_{fuse} = \\{1,2,3,4\\}$。\n$I_{share} = \\emptyset$。共享部分的成本为 $0$。\n总成本 = $C_{f,1}+C_{f,2}+C_{f,3}+C_{f,4} = 1+2+1+2 = 6$。\n\n通过评估所有 $16$ 种可能的配置，我们发现最小总成本为 $6$ 个成本单位。这个最小成本可以通过几种不同的配置实现，例如，仅融合消费者 $1$，或者融合所有消费者。", "answer": "$$\\boxed{6}$$", "id": "3634928"}]}