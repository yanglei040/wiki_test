{"hands_on_practices": [{"introduction": "指令选择的核心可以看作一个树覆盖问题，其目标是找到一组指令“瓦片”来覆盖整个表达式树，同时使总成本最小化。这个问题通常通过动态规划来解决。本练习将让你亲手实践这一核心算法，通过计算一个表达式树在有无特定复合指令（如 `LEA`）时的最低成本，你将直观地理解特殊指令如何能有效提升代码生成质量。[@problem_id:3679133]", "problem": "您正在设计一个教学用的指令集架构（ISA），用以阐释用于指令选择的树模式匹配。该 ISA 支持以下指令图块，每个图块在被选中时都会生成一条机器指令：\n\n- 一个二元加法图块，匹配树模式 $+(x,y)$，代价为 $1$。\n- 一个常量左移图块，匹配树模式 $\\ll(x,k)$，其中 $k$ 为整数，代价为 $1$。\n- 一系列寻址模式图块（广义的有效地址加载，记作 $LEA$），当同一子表达式 $x$ 出现两次时，可以匹配 $+(x,\\ll(x,k))$ 或 $+(\\ll(x,k),x)$。对于这些图块：\n  - 如果 $k \\in \\{0,1,2,3\\}$，则代价为 $1$。\n  - 如果 $k \\in \\{4,5\\}$，则代价为 $2$。\n  - 如果 $k \\notin \\{0,1,2,3,4,5\\}$，则该模式无法匹配。\n\n假设叶节点 $a$、$b$、$c$ 已驻留在寄存器中，可以用作操作数，代价为零。除了将 $+(x,\\ll(x,k))$ 和 $+(\\ll(x,k),x)$ 均匹配为相同的 $LEA$ 模式外，不允许进行重组或代数重写。您必须使用自底向上的树模式匹配，通过最小化图块代价之和来计算给定表达式树的最优覆盖。\n\n考虑表达式树\n$$\nE = +\\Big( +\\big( +(a, \\ll(a,3)), +(b, \\ll(b,4)) \\big), +(\\ll(c,5), c) \\Big).\n$$\n\n设 $C_{\\text{base}}$ 表示仅当加法和移位图块可用时（即不允许使用 $LEA$ 图块）的最小总代价。设 $C_{\\text{lea}}$ 表示当上述所有图块，包括 $LEA$ 家族，对于每个可编码的 $k$ 均作为具有所述代价的独立图块可用时的最小总代价。\n\n计算单个数值\n$$\nD \\triangleq C_{\\text{base}} - C_{\\text{lea}}.\n$$\n\n请以单个实数形式提供您的最终答案。无需四舍五入。无需单位。", "solution": "用户希望我解决以下问题：\n您正在设计一个教学用的指令集架构（ISA），用以阐释用于指令选择的树模式匹配。该 ISA 支持以下指令图块，每个图块在被选中时都会生成一条机器指令：\n\n- 一个二元加法图块，匹配树模式 $+(x,y)$，代价为 $1$。\n- 一个常量左移图块，匹配树模式 $\\ll(x,k)$，其中 $k$ 为整数，代价为 $1$。\n- 一系列寻址模式图块（广义的有效地址加载，记作 $LEA$），当同一子表达式 $x$ 出现两次时，可以匹配 $+(x,\\ll(x,k))$ 或 $+(\\ll(x,k),x)$。对于这些图块：\n  - 如果 $k \\in \\{0,1,2,3\\}$，则代价为 $1$。\n  - 如果 $k \\in \\{4,5\\}$，则代价为 $2$。\n  - 如果 $k \\notin \\{0,1,2,3,4,5\\}$，则该模式无法匹配。\n\n假设叶节点 $a$、$b$、$c$ 已驻留在寄存器中，可以用作操作数，代价为零。除了将 $+(x,\\ll(x,k))$ 和 $+(\\ll(x,k),x)$ 均匹配为相同的 $LEA$ 模式外，不允许进行重组或代数重写。您必须使用自底向上的树模式匹配，通过最小化图块代价之和来计算给定表达式树的最优覆盖。\n\n考虑表达式树\n$$\nE = +\\Big( +\\big( +(a, \\ll(a,3)), +(b, \\ll(b,4)) \\big), +(\\ll(c,5), c) \\Big).\n$$\n\n设 $C_{\\text{base}}$ 表示仅当加法和移位图块可用时（即不允许使用 $LEA$ 图块）的最小总代价。设 $C_{\\text{lea}}$ 表示当上述所有图块，包括 $LEA$ 家族，对于每个可编码的 $k$ 均作为具有所述代价的独立图块可用时的最小总代价。\n\n计算单个数值\n$$\nD \\triangleq C_{\\text{base}} - C_{\\text{lea}}.\n$$\n\n请以单个实数形式提供您的最终答案。无需四舍五入。无需单位。\n\n### 第1步：问题验证\n\n我将首先验证问题陈述。\n\n#### 1.1. 提取已知条件\n- **图块（基础）：**\n  1. $+(x,y)$，代价 $1$。\n  2. $\\ll(x,k)$，其中 $k$ 为整数，代价 $1$。\n- **图块 (LEA)：**\n  1. $+(x,\\ll(x,k))$ 或 $+(\\ll(x,k),x)$。\n     - 如果 $k \\in \\{0,1,2,3\\}$，代价为 $1$。\n     - 如果 $k \\in \\{4,5\\}$，代价为 $2$。\n- **操作数：** 叶节点 $a, b, c$ 的代价为 $0$。\n- **方法：** 自底向上的树模式匹配（动态规划）以获得最小代价。\n- **约束：** 除了特定的 $LEA$ 模式外，不允许重组或代数重写。\n- **表达式树：** $E = +\\Big( +\\big( +(a, \\ll(a,3)), +(b, \\ll(b,4)) \\big), +(\\ll(c,5), c) \\Big)$。\n- **待求量：**\n  - $C_{\\text{base}}$：仅使用基础图块的最小代价。\n  - $C_{\\text{lea}}$：使用所有图块的最小代价。\n  - $D = C_{\\text{base}} - C_{\\text{lea}}$。\n\n#### 1.2. 使用提取的已知条件进行验证\n该问题在编译器理论领域内有明确定义，特别是在通过树模式匹配进行指令选择方面。这是动态规划在树上的标准应用。\n- **科学依据：** 这些概念是编译器设计的基础。该 ISA 是一个简化但合理的教学模型。所有原则在计算机科学中都是成立的。\n- **适定性：** 表达式树、图块集、代价和优化目标（最小总代价）都已明确定义。这种结构保证了每种情况下都有唯一的最小代价，从而使问题具有适定性。\n- **客观性和完整性：** 问题使用形式化语言陈述，并包含推导解决方案所需的所有必要信息。没有主观或模棱两可的术语。\n\n#### 1.3. 结论和行动\n问题有效。我将继续进行求解。\n\n### 第2步：求解推导\n\n问题要求计算用两种不同的指令图块集覆盖给定表达式树的最小代价。我们将使用自底向上的动态规划方法，计算每个子树的最小代价。设 $cost(N)$ 表示评估以节点 $N$ 为根的子树的最小代价。叶节点 $a, b, c$ 的代价给定为 $0$。\n\n让我们将表达式树 $E$ 分解为其主要子树：\n- $E_1 = +(a, \\ll(a,3))$\n- $E_2 = +(b, \\ll(b,4))$\n- $E_3 = +(\\ll(c,5), c)$\n完整的树是 $E = +\\big(+(E_1, E_2), E_3\\big)$。\n\n#### 2.1. 计算 $C_{\\text{base}}$\n\n在这种情况下，只有加法图块（代价 = 1）和移位图块（代价 = 1）可用。设 $cost_B(N)$ 为子树 $N$ 的代价。\n\n1.  **移位子树的代价：**\n    - $cost_B(\\ll(a,3)) = \\text{cost}(\\ll) + cost_B(a) = 1 + 0 = 1$。使用一个移位图块。\n    - $cost_B(\\ll(b,4)) = \\text{cost}(\\ll) + cost_B(b) = 1 + 0 = 1$。\n    - $cost_B(\\ll(c,5)) = \\text{cost}(\\ll) + cost_B(c) = 1 + 0 = 1$。\n\n2.  **子树 $E_1, E_2, E_3$ 的代价：**\n    - 对于 $E_1 = +(a, \\ll(a,3))$，我们必须使用一个加法图块。其代价是图块代价加上其子节点子树的代价：\n      $cost_B(E_1) = \\text{cost}(+) + cost_B(a) + cost_B(\\ll(a,3)) = 1 + 0 + 1 = 2$。\n    - 类似地，对于 $E_2 = +(b, \\ll(b,4))$：\n      $cost_B(E_2) = \\text{cost}(+) + cost_B(b) + cost_B(\\ll(b,4)) = 1 + 0 + 1 = 2$。\n    - 对于 $E_3 = +(\\ll(c,5), c)$：\n      $cost_B(E_3) = \\text{cost}(+) + cost_B(\\ll(c,5)) + cost_B(c) = 1 + 1 + 0 = 2$。\n\n3.  **中间节点和根节点的代价：**\n    - 下一个节点是 $+(E_1, E_2)$：\n      $cost_B(+(E_1, E_2)) = \\text{cost}(+) + cost_B(E_1) + cost_B(E_2) = 1 + 2 + 2 = 5$。\n    - 根节点是 $E = +\\big(+(E_1, E_2), E_3\\big)$：\n      $cost_B(E) = \\text{cost}(+) + cost_B(+(E_1, E_2)) + cost_B(E_3) = 1 + 5 + 2 = 8$。\n\n因此，仅使用基础图块的最小代价是 $C_{\\text{base}} = 8$。\n\n#### 2.2. 计算 $C_{\\text{lea}}$\n\n现在，我们引入 $LEA$ 系列图块。在每个 `+` 节点，我们必须检查 $LEA$ 图块是否能提供代价更低的覆盖。设 $cost_L(N)$ 为子树 $N$ 的代价。\n\n1.  **移位子树的代价：** 这些不受影响，因为没有新的图块能匹配它们。\n    - $cost_L(\\ll(a,3)) = 1$\n    - $cost_L(\\ll(b,4)) = 1$\n    - $cost_L(\\ll(c,5)) = 1$\n\n2.  **子树 $E_1 = +(a, \\ll(a,3))$ 的代价：**\n    - **选项1（ADD 图块）：** $cost_L = \\text{cost}(+) + cost_L(a) + cost_L(\\ll(a,3)) = 1 + 0 + 1 = 2$。\n    - **选项2（LEA 图块）：** 模式 $+(x, \\ll(x,k))$ 与 $x=a$ 和 $k=3$ 匹配。由于 $k=3$ 属于集合 $\\{0,1,2,3\\}$，该图块的代价为 $1$。这个图块覆盖了整个子树 $E_1$。\n    - 最小代价为 $cost_L(E_1) = \\min(2, 1) = 1$。\n\n3.  **子树 $E_2 = +(b, \\ll(b,4))$ 的代价：**\n    - **选项1（ADD 图块）：** $cost_L = \\text{cost}(+) + cost_L(b) + cost_L(\\ll(b,4)) = 1 + 0 + 1 = 2$。\n    - **选项2（LEA 图块）：** 模式 $+(x, \\ll(x,k))$ 与 $x=b$ 和 $k=4$ 匹配。由于 $k=4$ 属于集合 $\\{4,5\\}$，该图块的代价为 $2$。\n    - 最小代价为 $cost_L(E_2) = \\min(2, 2) = 2$。\n\n4.  **子树 $E_3 = +(\\ll(c,5), c)$ 的代价：**\n    - **选项1（ADD 图块）：** $cost_L = \\text{cost}(+) + cost_L(\\ll(c,5)) + cost_L(c) = 1 + 1 + 0 = 2$。\n    - **选项2（LEA 图块）：** 模式 $+(\\ll(x,k), x)$ 与 $x=c$ 和 $k=5$ 匹配。由于 $k=5$ 属于集合 $\\{4,5\\}$，该图块的代价为 $2$。\n    - 最小代价为 $cost_L(E_3) = \\min(2, 2) = 2$。\n\n5.  **中间节点和根节点的代价：**\n    - 节点 $+(E_1, E_2)$ 不匹配任何 $LEA$ 模式。我们必须使用一个加法图块。\n      $cost_L(+(E_1, E_2)) = \\text{cost}(+) + cost_L(E_1) + cost_L(E_2) = 1 + 1 + 2 = 4$。\n    - 根节点 $E = +\\big(+(E_1, E_2), E_3\\big)$ 也不匹配任何 $LEA$ 模式。我们必须使用一个加法图块。\n      $cost_L(E) = \\text{cost}(+) + cost_L(+(E_1, E_2)) + cost_L(E_3) = 1 + 4 + 2 = 7$。\n\n因此，使用所有可用图块的最小代价是 $C_{\\text{lea}} = 7$。\n\n#### 2.3. 最终计算\n\n题目要求我们计算 $D = C_{\\text{base}} - C_{\\text{lea}}$。\n使用我们计算出的值：\n$D = 8 - 7 = 1$。\n代价的差异是由于能够用一条单一、低代价的 $LEA$ 指令（代价 $1$）来覆盖子树 $+(a, \\ll(a,3))$，而不是使用移位和加法指令的组合（总代价 $2$）。对于另外两个可能的 $LEA$ 匹配，特殊图块并未提供比通用组合更低的代价。", "answer": "$$\n\\boxed{1}\n$$", "id": "3679133"}, {"introduction": "一个优秀的指令选择器不仅要关心成本，更要保证转换的语义等价性。仅仅匹配语法模式是不够的，我们必须确保所选指令的行为与原始中间表示（IR）完全一致。本练习探讨了一个经典且微妙的陷阱：整数除法和算术右移在处理负奇数时，因取整模式（向零取整 vs. 向负无穷取整）不同而产生的差异，这强调了在模式匹配中集成类型信息和保护条件（guards）的重要性。[@problem_id:3679147]", "problem": "一个编译器后端正在为一种树形结构的中间表示（IR）执行指令选择（IS）。考虑表示整数除以常数2的IR节点，记作二元操作符树 $sdiv(x,2)$，其中操作符 $sdiv$ 表示整数除以 $2$，操作数 $x$ 是某个机器整数类型的值。目标架构提供了一条算术右移指令 $SAR(u,k)$（对 $u$进行符号扩展并右移 $k$ 位）和一条逻辑右移指令 $SHR(u,k)$（对 $u$进行零扩展并右移 $k$ 位）。该编译器的 IR 是类型化的，并且区分有符号和无符号整数操作。\n\n基于以下基本前提：\n- 在二进制补码表示法中，算术右移 $SAR(x,1)$ 会复制符号位，对于负奇数 $x$，其代数效果等同于乘以 $2^{-1}$ 并向负无穷大舍入。\n- 逻辑右移 $SHR(x,1)$ 在高位填充零，对于无符号整数，这对应于除以 $2$，其截断方式与无符号整数除法语义相匹配。\n- 语言或 IR 对有符号整数除法的语义可能规定向零舍入；这对于负奇数 $x$，与向负无穷大舍入不同。\n\n你正在设计一个树模式匹配器，它可以在合法的情况下将 $sdiv(x,2)$ 重写为移位操作。哪个选项正确地提出了一个模式，该模式仅在 $x$ 为有符号数时使用 $SAR(x,1)$，并且还指定了匹配器必须如何整合类型信息或保护条件以避免非法匹配？\n\nA. 匹配类型化的有符号除法节点 $\\mathrm{sdiv}(x,2)$ 并将其重写为 $SAR(x,1)$，但仅在满足以下保护条件之一时：IR 的有符号除法语义是向负无穷大舍入，或者已证明的范围分析确保 $x \\ge 0$。否则，不进行匹配。\n\nB. 匹配任何 $x$ 为有符号类型的 $sdiv(x,2)$ 出现，并无条件地将其重写为 $SAR(x,1)$，因为仅有符号性本身就能保证等价。\n\nC. 只要 $x$ 是有符号数，就匹配 $\\mathrm{sdiv}(x,2)$ 并将其重写为 $SHR(x,1)$，因为无论符号如何，右移总是实现除以 2。\n\nD. 只要 $x$ 是有符号数，就匹配 $\\mathrm{sdiv}(x,2)$ 并将其重写为 $SAR(x,2)$，因为移位量应等于除数。", "solution": "用户希望我验证问题陈述，如果有效，则提供详细的解决方案。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 上下文是编译器后端中针对树形结构中间表示（IR）的指令选择（IS）。\n- IR 节点是 $sdiv(x,2)$，表示操作数 $x$ 除以常数 $2$ 的整数除法。\n- 操作数 $x$ 是一个机器整数类型。\n- 目标架构有两条相关指令：\n    - $SAR(u,k)$：算术右移，对 $u$进行符号扩展并右移 $k$ 位。\n    - $SHR(u,k)$：逻辑右移，对 $u$进行零扩展并右移 $k$ 位。\n- IR是类型化的，区分有符号和无符号整数。\n- 问题提供了以下语义定义：\n    1.  架构使用二进制补码表示法。\n    2.  对于负奇数 $x$，$\\mathrm{SAR}(x,1)$ 等价于乘以 $2^{-1}$ 并向负无穷大舍入（向下取整）。\n    3.  $SHR(x,1)$ 对应于无符号整数除以 $2$，它进行截断（向零舍入）。\n    4.  语言或 IR 对有符号整数除法的语义可能规定向零舍入（截断）。\n    5.  对于 $x$ 的负奇数值，向零舍入与向负无穷大舍入不同。\n- 任务是识别正确的模式匹配规则，以将有符号数除以 $2$（表示为 $\\mathrm{sdiv}(x,2)$）重写为算术右移 $1$ 位（$SAR(x,1)$），包括任何必要的保护条件以确保正确性。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学上成立：** 该问题牢固地植根于编译器设计、计算机体系结构和数字算术的原理。移位指令的行为、二进制补码算术以及不同的整数除法舍入模式是计算机科学和工程中的标准且有详细文档记载的主题。该问题在事实上是健全的。\n- **提法得当：** 问题陈述清晰。它提供了源操作（可能具有向零舍入语义的 $\\mathrm{sdiv}$）和目标操作（具有向负无穷大舍入语义的 $SAR$）的语义，并询问它们之间的转换在何种条件下有效。这种结构允许得出唯一且合乎逻辑的解。\n- **客观性：** 语言精确、技术性强，没有歧义或主观性。像“二进制补码”、“算术右移”、“向零舍入”和“向负无穷大舍入”这样的术语都有严格、普遍接受的定义。\n\n**步骤 3：结论与行动**\n问题陈述是**有效的**。这是一个格式良好、技术上健全的问题，代表了编译器优化中的真实挑战。我将继续推导解决方案。\n\n### 解决方案推导\n\n核心任务是确定何时有符号整数除以 $2$（表示为 $\\mathrm{sdiv}(x,2)$）可以被合法地替换为算术右移 $1$ 位（表示为 $SAR(x,1)$）。问题突显了一个关键的语义差异：$\\mathrm{sdiv}$ 可能向零舍入，而 $SAR$ 则向负无穷大舍入。\n\n让我们分析这两种操作在二进制补码下对有符号整数 $x$ 的行为。\n\n令 $f_{sdiv}(x) = \\mathrm{sdiv}(x,2)$ 表示向零舍入（截断）的除法。\n令 $f_{sar}(x) = \\mathrm{SAR}(x,1)$ 表示算术右移，它等价于向负无穷大舍入（向下取整）的除法。\n\n我们分析 $f_{sdiv}(x)$ 和 $f_{sar}(x)$ 的等价性。\n\n**情况 1：$x \\ge 0$（非负整数）**\n对于任何非负数 $z$，向零舍入（$\\mathrm{trunc}(z)$）和向负无穷大舍入（$\\mathrm{floor}(z)$）产生相同的结果。\n例如，$\\mathrm{trunc}(3.5) = 3$ 且 $\\mathrm{floor}(3.5) = 3$。\n因此，对于任何 $x \\ge 0$，我们有：\n$\\mathrm{sdiv}(x,2) = \\mathrm{trunc}(x/2) = \\mathrm{floor}(x/2) = \\mathrm{SAR}(x,1)$\n当已知 $x$ 为非负数时，该转换总是有效的。\n\n**情况 2：$x  0$（负整数）**\n对于负数 $z$，如果 $z$ 不是整数，则向零舍入和向负无穷大舍入的结果不同。\n具体来说，对于 $z  0$，$\\mathrm{trunc}(z) = \\lceil z \\rceil$，而 $\\mathrm{floor}(z)$ 仍然是向下取整。\n- 如果 $x$ 是一个负偶数，那么 $x/2$ 是一个整数。在这种情况下，$\\mathrm{trunc}(x/2) = \\mathrm{floor}(x/2) = x/2$。\n  例如，如果 $x = -8$，$\\mathrm{sdiv}(-8,2) = -4$ 且 $SAR(-8,1) = -4$。它们是相等的。\n- 如果 $x$ 是一个负奇数，那么 $x/2$ 不是一个整数（例如 $-3.5$）。\n  在这种情况下，$\\mathrm{trunc}(x/2) \\ne \\mathrm{floor}(x/2)$。\n  例如，如果 $x = -7$，那么 $x/2 = -3.5$。\n  $\\mathrm{sdiv}(-7,2) = \\mathrm{trunc}(-3.5) = -3$\n  $SAR(-7,1) = \\mathrm{floor}(-3.5) = -4$\n  结果不相等。\n\n**推导结论**\n只有在 IR 的有符号除法语义保证向负无穷大舍入，或者可以证明操作数 $x$ 永远不会是负奇数的情况下，用 $SAR(x,1)$ 直接替换 $\\mathrm{sdiv}(x,2)$ 才是正确的。后者的一个充分条件是证明 $x \\ge 0$。如果 IR 语义规定向零舍入（像 C99/C++/Java 等语言中的常见标准），则该转换对于负奇数输入是非法的，不能无条件应用。一个正确的模式匹配规则必须将这些条件作为保护条件整合进去。\n\n###逐项分析选项\n\n**A. 匹配类型化的有符号除法节点 $\\mathrm{sdiv}(x,2)$ 并将其重写为 $SAR(x,1)$，但仅在满足以下保护条件之一时：IR 的有符号除法语义是向负无穷大舍入，或者已证明的范围分析确保 $x \\ge 0$。否则，不进行匹配。**\n此选项提出了一个受保护的转换。让我们检查这些保护条件：\n1.  **保护条件 1：“IR 的有符号除法语义是向负无穷大舍入”**：如果源操作（$\\mathrm{sdiv}$）和目标指令（$SAR$）具有相同的舍入语义，那么根据定义，该转换对所有输入都是正确的。这是一个有效的条件。\n2.  **保护条件 2：“已证明的范围分析确保 $x \\ge 0$”**：如上所述，对于所有非负的 $x$，两种舍入模式产生相同的结果。因此，如果 $x$ 被证明是非负的，那么无论 IR 对负数的舍入模式语义如何，该转换都是正确的。这也是一个有效的条件。\n该规则正确地指出，如果两个保护条件都不满足，则不进行匹配。这可以防止在除法语义为向零舍入时为负奇数输入生成不正确的代码。此选项完美地捕捉了安全且正确优化所需的必要条件。\n**结论：正确**\n\n**B. 匹配任何 $x$ 为有符号类型的 $sdiv(x,2)$ 出现，并无条件地将其重写为 $SAR(x,1)$，因为仅有符号性本身就能保证等价。**\n此选项提出了无条件重写。我们的分析表明这是不正确的。当 IR 除法向零舍入时，对于负奇数，等价性不成立。声称“仅有符号性本身就能保证等价”是错误的，因为舍入模式是一个关键因素。例如，如果 $\\mathrm{sdiv}(-3,2)$ 定义为 $-1$，$\\mathrm{SAR}(-3,1)$ 会计算出 $-2$。\n**结论：不正确**\n\n**C. 只要 $x$ 是有符号数，就匹配 $\\mathrm{sdiv}(x,2)$ 并将其重写为 $SHR(x,1)$，因为无论符号如何，右移总是实现除以 2。**\n此选项建议对有符号值使用逻辑右移（$SHR$）。逻辑右移会在最高有效位插入零。对于负数（其最高有效位即符号位为 $1$），此操作将改变符号并产生一个大的正数。例如，对于一个 $8$ 位有符号整数 $x=-2$（二进制 `11111110`），$SHR(x,1)$ 将产生 `01111111`，即 $+127$。正确的结果是 $-1$。“无论符号如何，右移总是实现除以 2”这一前提是错误的；必须为正确类型的整数（无符号 vs. 有符号）使用正确类型的移位（逻辑 vs. 算术）。\n**结论：不正确**\n\n**D. 只要 $x$ 是有符号数，就匹配 $\\mathrm{sdiv}(x,2)$ 并将其重写为 $SAR(x,2)$，因为移位量应等于除数。**\n此选项使用了正确类型的移位（$SAR$），但移位量不正确。右移 $k$ 位等价于除以 $2^k$。因此，要实现除以 $2$，移位量 $k$ 必须是 $1$，因为 $2^1=2$。移位量为 $2$（$SAR(x,2)$）将实现除以 $2^2=4$。声称“移位量应等于除数”是根本上错误的。\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3679147"}, {"introduction": "在确保了语义正确性之后，指令选择的最后一道关卡是检查模式在目标硬件上是否“合法”。一个在语义上看似完美的匹配，可能会因为目标架构特定的指令编码规则而变得不可行。本练习通过一个写实的假设场景，展示了指令的位级编码（bit-level encoding）如何否决一个原本理想的匹配，从而突显了为特定硬件量身定制合法性谓词（legality predicates）在构建健壮的指令选择器中的关键作用。[@problem_id:3679135]", "problem": "考虑一个使用树模式匹配进行指令选择的代码生成器。表达式树使用终端节点表示操作，叶子节点表示操作数；例如，子树 $+(x, c)$ 表示寄存器值 $x$ 和常量 $c$ 的整数加法。模式带有合法性谓词，用于约束哪些目标机编码是有效的。\n\n假设一个名为“Zeta”的目标架构，其加立即数指令 ADDI 有两种形式：立即数形式和寄存器形式。立即数形式名义上使用一个 $k$ 位有符号立即数字段（二进制补码），但由于紧凑编码，立即数子字段的最高有效位（符号位）被解码器复用为形式选择器。具体来说，当立即数的最高有效位为 $0$ 时，该指令字被解码为带立即数的 ADDI；当它为 $1$ 时，该指令字被解码为寄存器形式，并且没有立即数。因此，尽管该字段有 $k$ 位宽，但只有那些其二进制补码表示中最高有效位为 $0$ 的常量值才能被编码为立即数。一个有符号 $k$ 位整数 $v$ 的二进制补码表示的范围是 $[-2^{k-1}, 2^{k-1}-1]$，并且对于负数 $v$，其最高有效位恰好为 $1$。\n\n指令选择器有一个用于减一操作 DEC 的树模式，它被表示为 ADDI 的一个特例，其中常量等于 $-1$，即当模式 $+(x,-1)$ 被匹配且合法性谓词成立时，会生成 DEC。选择器使用的合法性谓词是常规的有符号 $k$ 位可编码性测试：立即数必须满足 $v \\in [-2^{k-1}, 2^{k-1}-1]$。\n\n您必须根据以上定义进行推理，以确定在 Zeta 架构上将 $+(x,-1)$ 匹配到 DEC 是否真的合法，并根据被复用的符号位规则所隐含的位级约束来精确解释其结果。假设 $k \\geq 2$ 并且除非另有说明，选择器只强制执行标准的二进制补码范围测试。\n\n在 Zeta 的编码规则下，哪项陈述最准确地描述了正确的合法性结果以及对 $+(x,-1)$ 进行树模式匹配的影响？\n\nA. 匹配始终合法，因为对于任何 $k \\geq 1$，$-1$ 都在 $[-2^{k-1}, 2^{k-1}-1]$ 范围内，所以 DEC 作为带立即数 $-1$ 的 ADDI 生成。\n\nB. 匹配当且仅当 $k \\geq 2$ 时合法，因为对于 $k=1$，范围太小；对于 $k \\geq 2$，常规的有符号范围测试就足够了，所以总是生成 DEC。\n\nC. 根据 Zeta 的复用符号位规则，该匹配是非法的，因为任何负立即数（包括 $-1$）的最高有效位都为 $1$，这将选择寄存器形式并使立即数形式无效；因此，合法性谓词必须拒绝用于 DEC 的 $+(x,-1)$，并且匹配器必须选择一个替代方案，例如寄存器常量或使用无符号 $1$ 的减立即数指令（如果可用）。\n\nD. 匹配是合法的，因为汇编器可以通过模数回绕将 $-1$ 编码为 $2^k-1$；选择器生成 DEC，汇编器会修复编码，而不管符号位如何。", "solution": "首先将验证问题陈述的科学合理性、自洽性和清晰度。\n\n### 步骤 1：提取已知条件\n- **系统**：一个使用树模式匹配进行指令选择的代码生成器。\n- **表达式树**：子树 $+(x, c)$ 表示寄存器值 $x$ 和常量 $c$ 的加法。\n- **架构**：一个名为“Zeta”的目标架构。\n- **指令**：Zeta 有一个加立即数指令 `ADDI`，它有立即数形式和寄存器形式。\n- **立即数字段**：立即数形式使用一个 $k$ 位有符号字段（二进制补码）。\n- **编码规则**：$k$ 位立即数字段的最高有效位（MSB）被复用。\n    - 如果 MSB 是 $0$，指令被解码为带立即数的 `ADDI`。\n    - 如果 MSB 是 $1$，指令被解码为 `ADDI` 的寄存器形式，并且没有立即数。\n- **编码后果**：只有那些 $k$ 位二进制补码表示中 MSB 为 $0$ 的常量值 $v$ 才能被编码为立即数。\n- **二进制补码定义**：一个有符号 $k$ 位整数 $v$ 的范围是 $[-2^{k-1}, 2^{k-1}-1]$。对于负值，其二进制补码表示的 MSB 为 $1$。\n- **模式匹配规则**：指令选择器有一个用于减一操作 `DEC` 的模式，该模式由表达式树 $+(x, -1)$ 生成。\n- **合法性谓词**：指令选择器用于验证匹配的谓词是标准的有符号 $k$ 位范围测试：立即数值 $v$ 必须满足 $v \\in [-2^{k-1}, 2^{k-1}-1]$。\n- **假设**：$k \\geq 2$。选择器仅强制执行标准范围测试。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学基础**：该问题在编译器设计和计算机体系结构的原理方面有很好的基础。指令选择、树模式匹配、指令集体系结构（ISA）的特性、立即数编码、二进制补码算术和合法性谓词等概念都是该领域的标准主题。特定的编码规则虽然是假设性的，却是 ISA 设计权衡中的一个现实例子。\n- **良构性**：该问题是良构的。它为一种架构和编译器提供了一套清晰的规则，设置了一个特定的场景，并要求基于这些规则进行逻辑推导。可以得出一个唯一的、确定性的答案。\n- **客观性**：该问题以精确、客观和技术性的语言陈述，没有歧义或主观性断言。\n\n该问题没有表现出任何列出的缺陷。它并非科学上不合理，因为它使用了二进制补码的正确定义和标准的编译器概念。它并非不完整；问题的核心在于编译器谓词与硬件现实之间的差异，这是有意设计的。它并非不切实际、不良构或微不足道。\n\n### 步骤 3：结论与行动\n问题陈述是 **有效的**。将推导解决方案。\n\n### 解决方案推导\n核心任务是确定将表达式树 $+(x, -1)$ 匹配到 `DEC` 指令（实现为带立即数 $-1$ 的 `ADDI`）在 Zeta 架构上是否合法。这需要比较由编译器谓词决定的合法性与由硬件解码规则决定的合法性。\n\n1.  **分析立即数值**：所讨论的立即数值是 $v = -1$。\n\n2.  **确定 $-1$ 的 $k$ 位二进制补码表示**：\n    在 $k$ 位系统中，负数 $-|N|$ 的二进制补码表示可以通过计算 $2^k - |N|$ 来得到。对于 $-1$，这就是 $2^k - 1$。\n    在二进制中，$2^k$ 是一个 $1$ 后面跟着 $k$ 个零（$100...0$，一个 $(k+1)$-位数）。\n    因此，值 $2^k - 1$ 是一串 $k$ 个 $1$（在 $k$ 位中为 $11...1$）。\n    例如，当 $k=8$ 时，$-1$ 是 $11111111_2$。当 $k=16$ 时，$-1$ 是 $1111111111111111_2$。\n    关键在于，对于任何 $k \\ge 2$，$-1$ 的 $k$ 位二进制补码表示的最高有效位（MSB）始终是 $1$。\n\n3.  **应用 Zeta 架构的硬件解码规则**：\n    问题陈述指出，对于 `ADDI` 指令，仅当立即数字段的 MSB 为 $0$ 时，才会选择立即数形式。如果 MSB 为 $1$，硬件会将指令解码为 `ADDI` 的寄存器形式。\n    由于 $-1$ 的 $k$ 位表示的 MSB 为 $1$，一个带有立即数 $-1$ 的 `ADDI` 指令会被 Zeta CPU 的解码器误解为该指令的寄存器形式。因此，在 Zeta 上将 $-1$ 合法地编码为 `ADDI` 指令的立即数是 **不可能的**。\n\n4.  **分析指令选择器的合法性谓词**：\n    问题陈述指出，选择器使用标准的有符号 $k$ 位可编码性测试：如果 $v \\in [-2^{k-1}, 2^{k-1}-1]$，则立即数 $v$ 是合法的。\n    对于值 $v = -1$ 和假设 $k \\ge 2$：\n    - 下界 $-2^{k-1}$ 总是小于或等于 $-1$（例如，对于 $k=2$，$-2 \\le -1$；对于 $k=3$，$-4 \\le -1$ 等）。\n    - 上界 $2^{k-1}-1$ 总是大于或等于 $-1$（例如，对于 $k=2$，$1 \\ge -1$；对于 $k=3$，$3 \\ge -1$ 等）。\n    因此，对于 $k \\ge 2$，$-1$ 总是满足条件 $v \\in [-2^{k-1}, 2^{k-1}-1]$。\n    这意味着指令选择器，使用其指定的（但有缺陷的）谓词，将错误地确定匹配是合法的，并试图生成一个带有立即数 $-1$ 的 `ADDI` 指令。\n\n5.  **结论**：\n    这里存在直接冲突。编译器的合法性谓词通过了检查，但硬件的解码规则使得生成的指令无效或不正确。问题是问这个匹配是否*真的*合法，这必须根据硬件的约束来判断，而不仅仅是编译器可能错误的逻辑。根据 Zeta 架构的硬件规则，该匹配是 **非法的**。一个为 Zeta 正确实现的编译器需要一个更复杂的合法性谓词，它不仅要检查标准的有符号范围，还要检查特定的 MSB 约束：在这种情况下，它必须验证立即数值是非负的，即 $v \\in [0, 2^{k-1}-1]$。\n\n### 逐项分析选项\n\n*   **A. 匹配始终合法，因为 $-1$ 都在 $[-2^{k-1}, 2^{k-1}-1]$ 范围内，所以 DEC 作为带立即数 $-1$ 的 ADDI 生成。**\n    该陈述正确地注意到 $-1$ 满足标准的有符号范围检查。然而，它完全忽略了问题的关键细节：Zeta 的复用符号位规则，该规则禁止 MSB 为 $1$ 的立即数。其结论“匹配是合法的”是根本错误的，因为合法性是由目标架构决定的，而不仅仅是编译器的范围检查。\n    **结论：不正确。**\n\n*   **B. 匹配当且仅当 $k \\geq 2$ 时合法，因为对于 $k=1$ 范围太小；对于 $k \\geq 2$ 常规的有符号范围测试就足够了，所以总是生成 DEC。**\n    问题陈述明确假设 $k \\ge 2$，使得对 $k=1$ 的讨论变得没有意义。更重要的是，这个选项犯了与选项 A 相同的根本性错误：它断言“常规的有符号范围测试就足够了”，这是错误的。由于特殊的 MSB 规则，这个测试对于 Zeta 架构来说恰恰是不够的。\n    **结论：不正确。**\n\n*   **C. 根据 Zeta 的复用符号位规则，该匹配是非法的，因为任何负立即数（包括 $-1$）的最高有效位都为 $1$，这将选择寄存器形式并使立即数形式无效；因此，合法性谓词必须拒绝用于 DEC 的 $+(x,-1)$，并且匹配器必须选择一个替代方案，例如寄存器常量或使用无符号 $1$ 的减立即数指令（如果可用）。**\n    这个陈述提供了完整且正确的分析。\n    1.  它正确地将匹配识别为“根据 Zeta 的复用符号位规则是非法的”。\n    2.  它提供了正确的原因：任何负立即数（包括 $-1$）在二进制补码中的 MSB 都为 $1$。\n    3.  它正确地推断出这种位模式的后果：CPU 解码器将选择寄存器形式，使得预期的立即数操作无效。\n    4.  它正确地描述了对一个合适的编译器的影响：合法性谓词*应该*被设计为拒绝此模式，并且编译器应该寻找替代的指令序列。\n    **结论：正确。**\n\n*   **D. 匹配是合法的，因为汇编器可以通过模数回绕将 $-1$ 编码为 $2^k-1$；选择器生成 DEC，汇编器会修复编码，而不管符号位如何。**\n    这个陈述是有缺陷的。$-1$ 的二进制补码表示*就是*对应于无符号值 $2^k-1$ 的位模式，但这不是问题所在。问题是该位模式的 MSB。声称“汇编器会修复编码，而不管符号位如何”与问题描述相矛盾。符号位的功能是 CPU 解码器的物理属性，而不是汇编器可以覆盖的软件约定。硬件将根据它接收到的位模式来解释指令；任何汇编器的魔法都无法改变这一点。\n    **结论：不正确。**", "answer": "$$\\boxed{C}$$", "id": "3679135"}]}