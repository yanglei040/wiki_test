{"hands_on_practices": [{"introduction": "编译器优化并非总是“免费的午餐”；它们常常涉及在不同成本之间的权衡。本练习将通过一个经典的循环不变式代码外提（Loop-Invariant Code Motion, LICM）场景，即提取数组边界检查，来具体展示这种权衡。你将运用范围分析来推导保证代码安全的防护条件，并建立一个精确的成本模型来量化优化带来的预期性能提升，从而深入理解编译器在做出优化决策时背后的定量推理过程 [@problem_id:3644311]。", "problem": "一个为具有强制性数组边界检查的语言设计的编译器，当可靠的范围分析能够保证安全性时，会执行全局优化，将循环不变的边界检查提出循环，并插入循环前守卫以保持程序语义。考虑逻辑长度分别为 $L_A$ 和 $L_B$ 的数组 $A$ 和 $B$，以及以下关于归纳变量 $i$ 的循环：\n循环体对所有满足 $0 \\le i  n$ 的迭代计算一个标量累加 $s := s + A[i] \\cdot B[i+1]$。在未优化的基线版本中，编译器在每次迭代中插入动态检查，以确保 $A[i]$ 和 $B[i+1]$ 都在边界内。\n\n你需要使用从 $0 \\le i  n$ 推导出的范围分析，通过添加可靠的循环前守卫来将边界检查提出循环。然后，推导一个考虑该全局转换的成本模型，并计算提出检查的版本相对于基线版本的预期加速比。\n\n假设如下：\n- 访问 $A[k]$ 的基本内存安全要求是 $0 \\le k \\le L_A - 1$，类似地，对于 $B[k]$ 的要求是 $0 \\le k \\le L_B - 1$。\n- 循环精确执行 $n$ 次迭代，其中 $i$ 的范围是 $0 \\le i  n$。\n- 在基线版本中，不包括边界检查的每次迭代成本为 $c_{\\ell}$ 个周期，用于算术和内存操作。\n- 在基线版本中，每次动态边界检查的成本为 $c_b$ 个周期，并且每次迭代执行两次（一次用于 $A[i]$，一次用于 $B[i+1]$）。\n- 在优化版本中，插入了两个循环前守卫，每个守卫的评估成本为 $c_g$ 个周期。如果守卫成功，循环执行时将不进行每次迭代的边界检查。如果任一守卫失败，执行将回退到带有每次迭代检查的基线版本。守卫总是在进入循环前评估一次，并且无论成功或失败，其成本都会产生。\n- 在一次给定的运行中，两个守卫都成功的概率是 $p$，它们失败（导致回退）的概率是 $1-p$。\n\n仅使用给定的定义和事实，首先使用范围分析和安全要求推导出必要的守卫条件，然后推导优化版本的预期运行时间。最后，对于具体参数 $n = 10^{6}$、$c_b = 7$、$c_{\\ell} = 6$、$c_g = 12$ 和 $p = 0.99$，计算预期加速比，即基线运行时间与预期优化运行时间的比率。\n\n将最终答案四舍五入到四位有效数字。最终答案必须是一个不带单位的实数值。", "solution": "问题陈述被评估为有效。它在科学上是可靠的、良构的、客观的和自洽的，代表了编译器优化分析中的一个标准问题。所有必要的常数、变量和条件都已提供，以推导出唯一的解。\n\n解决方案分三个阶段进行：首先，使用范围分析推导必要的循环前守卫条件；其次，为基线版本和优化版本构建成本模型，以推导预期加速比的表达式；第三，代入给定的数值计算最终答案。\n\n**1. 循环前守卫条件的推导**\n\n循环使用归纳变量 $i$ 在范围 $0 \\le i  n$ 内迭代。为了使优化可靠，循环内的每一次数组访问都必须被证明对于 $i$ 的整个范围是安全的。对于逻辑长度为 $L$、索引为 $k$ 的数组访问，其安全要求是 $0 \\le k \\le L - 1$。\n\n- **对数组 A 的分析**：访问是 $A[i]$。索引变量是 $k = i$。\n  给定循环范围 $0 \\le i  n$，索引 $k$ 的最小值为 $0$，最大值为 $n-1$。\n  安全条件 $0 \\le k \\le L_A - 1$ 必须对 $[0, n-1]$ 中的所有 $k$ 值都成立。\n  - 下界检查 $0 \\le 0$ 始终为真。\n  - 上界检查要求最大索引 $n-1$ 在有效范围内：$n-1 \\le L_A - 1$。\n  该不等式简化为 $n \\le L_A$。因此，第一个守卫条件是 $n \\le L_A$。这个检查仅在 $n > 0$ 时是必要的；如果 $n=0$，循环不执行，也就没有访问发生。\n\n- **对数组 B 的分析**：访问是 $B[i+1]$。索引是 $k = i+1$。\n  给定循环范围 $0 \\le i  n$，索引 $k=i+1$ 的范围是 $1 \\le k \\le n$。索引 $k$ 的最小值为 $1$，最大值为 $n$。\n  安全条件 $0 \\le k \\le L_B - 1$ 必须对 $[1, n]$ 中的所有 $k$ 值都成立。\n  - 下界检查 $0 \\le 1$ 始终为真。\n  - 上界检查要求最大索引 $n$ 在有效范围内：$n \\le L_B - 1$。\n  该不等式也可以写成 $n+1 \\le L_B$。因此，第二个守卫条件是 $n+1 \\le L_B$。\n\n因此，两个可靠的循环前守卫是（1）$n \\le L_A$ 和（2）$n+1 \\le L_B$。\n\n**2. 成本模型和预期加速比的推导**\n\n- **基线运行时间 ($T_{base}$)**：在未优化的基线版本中，每次迭代都会产生算术成本 ($c_{\\ell}$) 和两次边界检查的成本 ($2 \\cdot c_b$)。\n$$T_{base} = n \\cdot (c_{\\ell} + 2 c_b)$$\n\n- **预期优化运行时间 ($E[T_{opt}]$)**：优化版本的成本是概率性的。两个守卫评估总是会执行，产生 $2 c_g$ 的成本。\n  - 以概率 $p$，守卫成功。循环执行 $n$ 次，每次迭代只有算术成本 $c_{\\ell}$。这种情况下的总成本是 $T_{succ} = 2 c_g + n c_{\\ell}$。\n  - 以概率 $1-p$，至少有一个守卫失败。执行回退到基线版本。总成本是守卫评估成本加上完整的基线成本：$T_{fail} = 2 c_g + T_{base} = 2 c_g + n(c_{\\ell} + 2 c_b)$。\n\n预期运行时间是这两种结果的加权平均值：\n$$E[T_{opt}] = p \\cdot T_{succ} + (1-p) \\cdot T_{fail}$$\n$$E[T_{opt}] = p(2 c_g + n c_{\\ell}) + (1-p)(2 c_g + n(c_{\\ell} + 2 c_b))$$\n我们可以简化这个表达式：\n$$E[T_{opt}] = p \\cdot 2 c_g + (1-p) \\cdot 2 c_g + p \\cdot n c_{\\ell} + (1-p) \\cdot n c_{\\ell} + (1-p) \\cdot n \\cdot 2 c_b$$\n$$E[T_{opt}] = (p + 1-p) \\cdot 2 c_g + (p + 1-p) \\cdot n c_{\\ell} + (1-p) \\cdot 2 n c_b$$\n$$E[T_{opt}] = 2 c_g + n c_{\\ell} + 2 n c_b (1-p)$$\n\n- **预期加速比 ($S$)**: 加速比是基线运行时间与预期优化运行时间的比率。\n$$S = \\frac{T_{base}}{E[T_{opt}]} = \\frac{n(c_{\\ell} + 2 c_b)}{2 c_g + n c_{\\ell} + 2 n c_b (1-p)}$$\n\n**3. 数值计算**\n\n我们得到以下参数：\n- $n = 10^6$\n- $c_b = 7$\n- $c_{\\ell} = 6$\n- $c_g = 12$\n- $p = 0.99$\n\n首先，我们计算分子 $T_{base}$：\n$$T_{base} = 10^6 \\cdot (6 + 2 \\cdot 7) = 10^6 \\cdot (6 + 14) = 10^6 \\cdot 20 = 20,000,000$$\n\n接下来，我们计算分母 $E[T_{opt}]$：\n$$E[T_{opt}] = 2 \\cdot 12 + 10^6 \\cdot 6 + 2 \\cdot 10^6 \\cdot 7 \\cdot (1 - 0.99)$$\n$$E[T_{opt}] = 24 + 6,000,000 + 14 \\cdot 10^6 \\cdot 0.01$$\n$$E[T_{opt}] = 24 + 6,000,000 + 140,000$$\n$$E[T_{opt}] = 6,140,024$$\n\n最后，我们计算预期加速比 $S$：\n$$S = \\frac{20,000,000}{6,140,024} \\approx 3.2573136...$$\n\n将结果四舍五入到四位有效数字，得到 $3.257$。", "answer": "$$\\boxed{3.257}$$", "id": "3644311"}, {"introduction": "在考量性能收益之前，编译优化的首要前提是保证程序的语义正确性不被改变。本练习设计了一个涉及“除零”异常的场景，旨在揭示为什么仅仅发现两处相同的计算（即“同余计算”）并不足以将它们合并。通过这个例子，你将理解“支配关系”（Dominance）这一基本概念在全局优化（如全局值编号，GVN）中的关键作用，它能有效防止优化过程引入在原程序中本不会发生的错误 [@problem_id:3644367]。", "problem": "考虑一个采用静态单赋值形式 (SSA) 的程序，其控制流图 (CFG) 如下。块标记为 $B_0, B_1, B_2, B_3$，边遵循条件分支的自然结构。假设整数除法在除数等于 $0$ 时会引发异常。程序如下：\n\n入口块 $B_0$:\n- if $(p)$ then goto $B_1$ else goto $B_2$.\n\n块 $B_1$:\n- if $(y \\ne 0)$ then $t_1 := x / y$ else $t_1 := 0$; goto $B_3$.\n\n块 $B_2$:\n- if $(y \\ne 0)$ then $t_2 := x / y$ else $t_2 := 0$; goto $B_3$.\n\n汇合块 $B_3$:\n- $r := \\phi(t_1, t_2)$; use $r$.\n\n其中，$x$、$y$、$p$、$t_1$、$t_2$、$r$ 是程序变量，$ / $ 是在除数为 $0$ 时会引发异常的整数除法，$\\phi$ 是 SSA 合并操作符。如果两个表达式在所有它们都会被求值的执行路径下，都计算出基于相同操作数值的相同数学函数，则称这两个表达式是全等的。\n\n仅使用编译器理论中的基础定义：\n- 支配(Dominance): 如果从入口到块 $N$ 的每一条路径都经过块 $D$，则称块 $D$ 支配块 $N$。\n- 语义保持转换(Semantics-preserving transformation): 一种程序重写，对于所有输入，它都能产生可观察的等价行为，包括相同的异常或没有异常。\n- 全局值编号(Global Value Numbering, GVN): 一种将全等计算分组到等价类中的优化，以便在满足标准可用性和支配约束的条件下进行消除或重用。\n\n回答以下关于在汇合点 $B_3$ 合并 $B_1$ 和 $B_2$ 中的全等计算 $x / y$ 的安全性的多项选择题。选择所有正确的选项。\n\nA. 将两个受保护的除法替换为在 $B_3$ 顶部插入的单个计算是语义保持的：在 $B_3$ 中插入 $t := x / y$，并在 $B_1$ 中设置 $t_1 := t$ 以及在 $B_2$ 中设置 $t_2 := t$。\n\nB. 如果先前的分析证明，在 $B_3$ 的开头，谓词 $y \\ne 0$ 在所有路径上都成立，则选项 A 中的转换变为语义保持的。\n\nC. 直接重用 $t_1$ 来代替 $t_2$（即，将所有对 $t_2$ 的使用替换为 $t_1$）是语义保持的，因为 $x / y$ 在 $B_1$ 和 $B_2$ 中是全等计算的，无论支配关系如何。\n\nD. 尊重支配关系的全局值编号 (GVN) 优化可以为两个 $x / y$ 计算分配相同的值编号，但除非它能在一个支配所有使用点的位置放置一个新的计算，并且不会引入新的可观察行为，否则它不会消除任何一个计算。\n\nE. 如果 $B_1$ 和 $B_2$ 中的除法被替换为加法 $x + y$，且算术运算无溢出、无陷阱、无副作用，那么即使原始的受保护结构在 $y = 0$ 时仍然将 $0$ 赋给临时变量，在 $B_3$ 顶部插入单个 $x + y$ 也总是语义保持的。", "solution": "问题陈述已经过验证且是合理的。它描述了编译器优化中的一个经典场景，涉及部分冗余计算以及对可能引发异常的指令进行的推测性代码移动。\n\n首先，我们来分析原始程序的行为。程序以静态单赋值 (SSA) 形式给出。控制流如下：块 $B_0$ 基于谓词 $p$ 分支到 $B_1$ 或 $B_2$。然后 $B_1$ 和 $B_2$ 都无条件地将控制转移到汇合块 $B_3$。\n\n关键操作是整数除法 $x / y$，它被指定在除数 $y$ 为 $0$ 时引发异常。\n\n在块 $B_1$ 中，代码是：`if ($y \\ne 0$) then $t_1 := x / y$ else $t_1 := 0$`。除法 $x / y$ 仅在 $y$ 不等于 $0$ 时执行。如果 $y$ 等于 $0$，则跳过除法，并将 $t_1$ 赋值为 $0$。因此，沿着通过 $B_1$ 的路径不会引发任何异常。\n\n同样，在块 $B_2$ 中，代码是：`if ($y \\ne 0$) then $t_2 := x / y$ else $t_2 := 0$`。除法 $x / y$ 仅在 $y$ 不等于 $0$ 时执行。如果 $y$ 等于 $0$，则跳过除法，并将 $t_2$ 赋值为 $0$。因此，沿着通过 $B_2$ 的路径不会引发任何异常。\n\n由于程序的任何执行都必须经过 $B_1$ 或 $B_2$，并且两条路径都不能引发除零异常，我们可以得出结论：无论输入值 $x$、$y$ 和 $p$ 是什么，原始程序**永远不会引发异常**。这是评估任何转换的语义等价性的一个关键属性。\n\n在汇合块 $B_3$ 中，$\\phi$ 函数合并结果：$r := \\phi(t_1, t_2)$。\n- 如果执行来自 $B_1$，$r$ 取 $t_1$ 的值。\n- 如果执行来自 $B_2$，$r$ 取 $t_2$ 的值。\n$r$ 的值在 $y \\ne 0$ 时为 $x/y$，在 $y=0$ 时为 $0$。\n\n现在，我们评估每个选项。\n\n**A. 将两个受保护的除法替换为在 $B_3$ 顶部插入的单个计算是语义保持的：在 $B_3$ 中插入 $t := x / y$，并在 $B_1$ 中设置 $t_1 := t$ 以及在 $B_2$ 中设置 $t_2 := t$。**\n\n让我们分析所提议的转换。核心变化是将计算 $x / y$ 移动到块 $B_3$，实际上使 $B_3$ 中的代码变为 $t := x / y; r := t$。每个执行路径都会到达块 $B_3$。考虑一个输入 $y = 0$。在原始程序中，执行继续而没有异常。在转换后的程序中，执行到达 $B_3$，并执行语句 $t := x / y$。由于 $y=0$，这将引发一个除零异常。\n引入新的异常是可观察行为的改变。根据所提供的定义，这种转换是**非语义保持的**。问题在于，一个有条件执行的、受保护的计算被移动到了一个它会被无条件执行的位置，这是一种不安全的推测性执行。\n\n结论：**不正确**。\n\n**B. 如果先前的分析证明，在 $B_3$ 的开头，谓词 $y \\ne 0$ 在所有路径上都成立，则选项 A 中的转换变为语义保持的。**\n\n这个选项增加了一个关键的前提条件：已知每当控制到达 $B_3$ 时，$y \\ne 0$。\n让我们在这个新假设下重新评估 A 中的转换。\n1.  **异常行为：** 转换后的代码在 $B_3$ 中计算 $t := x / y$。由于已证明此时 $y \\ne 0$，除法永远不会引发异常。原始程序也永远不会引发异常。因此，异常行为得以保持。\n2.  **值计算：**\n    - 在原始程序中，由于任何到 $B_3$ 的路径都意味着 $y \\ne 0$，因此 $B_1$ 和 $B_2$ 中的保护条件总是为真。\n    - 因此，在通过 $B_1$ 的路径上，$t_1$ 被赋值为 $x / y$。\n    - 在通过 $B_2$ 的路径上，$t_2$ 被赋值为 $x / y$。\n    - 在 $B_3$ 中，$\\phi$ 函数 $r := \\phi(t_1, t_2)$ 将把 $x / y$ 赋给 $r$，无论采用哪条路径。\n    - 在转换后的程序中，$t := x / y$ 在 $B_3$ 中计算，并且该值用于 $r$。\n    - 在两种情况下，$r$ 的最终值都是 $x / y$。\n由于在此假设下，异常行为和计算出的值都是相同的，因此该转换变为语义保持的。\n\n结论：**正确**。\n\n**C. 直接重用 $t_1$ 来代替 $t_2$（即，将所有对 $t_2$ 的使用替换为 $t_1$）是语义保持的，因为 $x / y$ 在 $B_1$ 和 $B_2$ 中是全等计算的，无论支配关系如何。**\n\n该陈述提出的转换违反了 SSA 形式下数据流的基本原则。变量 $t_1$ 在块 $B_1$ 中定义。变量 $t_2$ 在块 $B_2$ 中定义。块 $B_1$ 不支配块 $B_2$，块 $B_2$ 也不支配块 $B_1$。它们位于互斥的控制流路径上。因此，变量 $t_1$ 的值在块 $B_2$ 中是不可用的，在那里使用它将是无效的。例如，在 $\\phi$ 函数 $r := \\phi(t_1, t_2)$ 中，第二个参数 $t_2$ 必须是在从 $B_2$ 引导的路径上定义的变量。不能简单地用 $t_1$ 替换它。声称这“无论支配关系如何”都是允许的，这直接与使编译器优化可靠的规则相矛盾。虽然计算是全等的，但它们的结果在不同的控制流分支之间是不可用的。\n\n结论：**不正确**。\n\n**D. 尊重支配关系的全局值编号 (GVN) 优化可以为两个 $x / y$ 计算分配相同的值编号，但除非它能在一个支配所有使用点的位置放置一个新的计算，并且不会引入新的可观察行为，否则它不会消除任何一个计算。**\n\n这个选项描述了一个标准的、可靠的 GVN 优化的行为。\n1.  **“为两个 $x / y$ 计算分配相同的值编号”**：$B_1$ 和 $B_2$ 中的表达式 $x/y$ 在文本上是相同的，并且它们的操作数 $x$ 和 $y$ 在进入这两个块时都可用，且具有相同的值编号（因为从 $B_0$ 开始的路径上没有重定义发生）。因此，GVN 会正确地将它们识别为全等的，并为它们分配相同的值编号。这部分是正确的。\n2.  **“但除非……否则它不会消除任何一个计算”**：消除一个冗余计算需要将其（或一个新创建的副本）移动到不同的位置。\n3.  **“在一个支配所有使用点的位置放置一个新的计算”**：该计算的‘使用’是 $B_1$ 中对 $t_1$ 的赋值和 $B_2$ 中对 $t_2$ 的赋值。唯一同时支配 $B_1$ 和 $B_2$ 的块是入口块 $B_0$。因此，为了消除冗余，GVN 必须将 $x / y$ 提升到 $B_0$。\n4.  **“并且不会引入新的可观察行为”**：如对选项 A 的分析，将 $x / y$ 移动到 $B_0$ 将导致它被无条件执行。对于输入 $y=0$，这会引发一个原始程序中不存在的异常。这是可观察行为的改变。\n因此，一个可靠的（即“尊重支配关系”并保持语义的）GVN 优化不会执行此代码移动。该陈述准确地描述了 GVN 将会检测到冗余，但由于安全性约束而被阻止执行该优化。\n\n结论：**正确**。\n\n**E. 如果 $B_1$ 和 $B_2$ 中的除法被替换为加法 $x + y$，且算术运算无溢出、无陷阱、无副作用，那么即使原始的受保护结构在 $y = 0$ 时仍然将 $0$ 赋给临时变量，在 $B_3$ 顶部插入单个 $x + y$ 也总是语义保持的。**\n\n让我们分析这个假设情景。操作 $x+y$ 是不引发异常的，因此代码移动的安全性问题不复存在。我们现在必须检查值的等价性。\n-   **原始（修改后）程序的行为：** $B_1$ 中的代码是 `if ($y \\ne 0$) then $t_1 := x + y$ else $t_1 := 0$`。同样的逻辑适用于 $B_2$ 中的 $t_2$。在 $B_3$，$r$ 变为 $t_1$ 或 $t_2$。\n    - 如果 $y \\ne 0$，结果是 $r = x+y$。\n    - 如果 $y = 0$，结果是 $r = 0$。\n-   **转换后程序的行为：** 在 $B_3$ 的顶部插入一个单独的计算 $t := x+y$。对于所有输入，$r$ 的值都将是 $x+y$。\n-   **比较：** 如果 $y=0$，原始程序计算出 $r=0$。转换后的程序计算出 $r = x+0 = x$。如果 $x \\ne 0$，这些值是不同的。例如，对于输入 $x=5, y=0$，原始程序计算 $r=0$，而转换后的程序计算 $r=5$。由于计算出的值并非对所有输入都相同，因此该转换不是语义保持的。代码移动在异常方面是安全的，但其结果是错误的。\n\n结论：**不正确**。\n\n总而言之，选项 B 和 D 是关于给定程序和编译器优化原则的正确陈述。", "answer": "$$\\boxed{BD}$$", "id": "3644367"}, {"introduction": "全局优化不仅包括消除冗余计算，还涵盖了对关键硬件资源的有效管理。本练习将我们的注意力从计算优化转移到另一项核心的全局任务：寄存器分配。你将通过一个具体实例，学习如何将复杂的寄存器分配问题建模为一个图着色问题，并亲手执行一个经典的分配算法，来决定哪些变量能够存放在宝贵的CPU寄存器中，哪些则必须“溢出”（spill）到内存，并计算其成本 [@problem_id:3644353]。", "problem": "编译器后端将寄存器分配建模为一个全局优化问题：给定一个表示临时变量之间活跃范围冲突的冲突图，分配至多 $k$ 个物理寄存器，使得任意两个相互冲突的临时变量不共享同一个寄存器。如果冲突图不是 $k$-可着色的，一些临时变量必须被溢出到内存中，这会产生估算的成本。\n\n考虑一个冲突图 $G=(V,E)$，其顶点集为 $V=\\{v_1,v_2,v_3,v_4,v_5,v_6\\}$，无向边集为\n$$\nE=\\big\\{\\{v_1,v_2\\},\\{v_1,v_3\\},\\{v_1,v_4\\},\\{v_2,v_3\\},\\{v_2,v_4\\},\\{v_3,v_4\\},\\{v_5,v_1\\},\\{v_5,v_2\\},\\{v_6,v_3\\}\\big\\}.\n$$\n假设有 $k=3$ 个可用寄存器。每个顶点 $v_i$ 有一个估算的溢出成本 $w_i$，如下所示\n$$\nw_1=9,\\quad w_2=4,\\quad w_3=7,\\quad w_4=12,\\quad w_5=8,\\quad w_6=3.\n$$\n\n应用标准的基于简化的全局寄存器分配策略，仅使用以下已确立的原则，并且不进行合并：\n- 如果存在一个度 $\\deg(v)  k$ 的节点，则通过从图中移除该节点并将其压入栈中来**简化**它。\n- 如果不存在度小于 $k$ 的节点，则选择一个**溢出**候选节点 $v$，该节点最小化优先级 $p(v) = w_v / \\deg(v)$。将该节点永久从图中移除并将其添加到溢出集。\n- 如果简化或溢出步骤中存在平局，则选择索引最小的节点。\n\n遵循此算法，直到图为空。计算所有被选择溢出的顶点的溢出成本之和。", "solution": "该问题是有效的，它要求对一个给定的冲突图应用一个标准的、确定性的寄存器分配算法。可用寄存器数量为 $k=3$。\n\n该过程迭代地从图中移除顶点，通过简化或溢出。我们将跟踪图的当前状态、每个顶点的度、一个用于存放简化顶点的栈，以及一个溢出顶点的集合。\n\n**步骤 0：初始状态**\n初始图 $G_0$ 的顶点集为 $V=\\{v_1,v_2,v_3,v_4,v_5,v_6\\}$，边集如题所述。溢出成本为 $w_1=9, w_2=4, w_3=7, w_4=12, w_5=8, w_6=3$。我们首先计算 $G_0$ 中所有顶点的初始度：\n- $\\deg_{G_0}(v_1) = 4$ (邻居: $v_2, v_3, v_4, v_5$)\n- $\\deg_{G_0}(v_2) = 4$ (邻居: $v_1, v_3, v_4, v_5$)\n- $\\deg_{G_0}(v_3) = 4$ (邻居: $v_1, v_2, v_4, v_6$)\n- $\\deg_{G_0}(v_4) = 3$ (邻居: $v_1, v_2, v_3$)\n- $\\deg_{G_0}(v_5) = 2$ (邻居: $v_1, v_2$)\n- $\\deg_{G_0}(v_6) = 1$ (邻居: $v_3$)\n简化节点的栈和溢出节点的集合最初都是空的。\n\n**步骤 1：简化 $v_5$**\n我们检查是否存在度 $\\deg(v)  k=3$ 的节点 $v$。我们找到两个这样的节点：$\\deg(v_5)=2$ 的 $v_5$ 和 $\\deg(v_6)=1$ 的 $v_6$。根据打破平局的规则，我们选择索引最小的节点，即 $v_5$。我们通过从图中移除 $v_5$ 并将其压入栈来简化它。图变为 $G_1 = G_0 \\setminus \\{v_5\\}$。其邻居 $v_1$ 和 $v_2$ 的度减一。\n- 栈: $[v_5]$\n- $G_1$ 中的当前度: $\\deg(v_1)=3$, $\\deg(v_2)=3$, $\\deg(v_3)=4$, $\\deg(v_4)=3$, $\\deg(v_6)=1$。\n\n**步骤 2：简化 $v_6$**\n在当前图 $G_1$ 中，我们再次寻找度小于 $3$ 的节点。只有 $v_6$ 符合条件，其 $\\deg(v_6)=1$。我们简化 $v_6$，将其压入栈并从图中移除，得到 $G_2 = G_1 \\setminus \\{v_6\\}$。其邻居 $v_3$ 的度减一。\n- 栈: $[v_5, v_6]$\n- $G_2$ 中的当前度: $\\deg(v_1)=3$, $\\deg(v_2)=3$, $\\deg(v_3)=3$, $\\deg(v_4)=3$。\n剩余的顶点是 $\\{v_1, v_2, v_3, v_4\\}$，它们构成一个完全子图 ($K_4$)，因为它们都相互邻接。\n\n**步骤 3：溢出 $v_2$**\n在图 $G_2$ 中，没有节点的度小于 $k=3$。所有四个剩余顶点的度都为 $3$。因此，我们必须选择一个顶点进行溢出。溢出候选节点是最小化优先级 $p(v) = w_v/\\deg(v)$ 的节点。\n- $p(v_1) = \\frac{w_1}{\\deg(v_1)} = \\frac{9}{3} = 3$\n- $p(v_2) = \\frac{w_2}{\\deg(v_2)} = \\frac{4}{3} \\approx 1.33$\n- $p(v_3) = \\frac{w_3}{\\deg(v_3)} = \\frac{7}{3} \\approx 2.33$\n- $p(v_4) = \\frac{w_4}{\\deg(v_4)} = \\frac{12}{3} = 4$\n最小优先级是 $p(v_2)=4/3$。因此，选择 $v_2$ 作为溢出候选节点。我们将 $v_2$ 记录为溢出并从图中永久移除它，创建 $G_3 = G_2 \\setminus \\{v_2\\}$。其邻居（$v_1, v_3, v_4$）的度减一。\n- 溢出集: $\\{v_2\\}$，成本: $w_2=4$。\n- $G_3$ 中的当前度: $\\deg(v_1)=2$, $\\deg(v_3)=2$, $\\deg(v_4)=2$。\n\n**步骤 4：简化 $v_1$**\n在图 $G_3$ 中，所有剩余顶点 $\\{v_1, v_3, v_4\\}$ 的度都为 $2$，小于 $k=3$。它们都是简化的候选节点。使用打破平局的规则，我们选择索引最小的一个，即 $v_1$。我们简化 $v_1$，将其压入栈，并创建 $G_4 = G_3 \\setminus \\{v_1\\}$。其邻居 $v_3$ 和 $v_4$ 的度减一。\n- 栈: $[v_5, v_6, v_1]$\n- $G_4$ 中的当前度: $\\deg(v_3)=1$, $\\deg(v_4)=1$。\n\n**步骤 5：简化 $v_3$**\n在图 $G_4$ 中，剩余的两个顶点 $v_3$ 和 $v_4$ 的度都小于 $3$。打破平局的规则选择 $v_3$（索引 $3  4$）。我们简化 $v_3$，将其压入栈，并形成 $G_5 = G_4 \\setminus \\{v_3\\}$。其邻居 $v_4$ 的度减一。\n- 栈: $[v_5, v_6, v_1, v_3]$\n- $G_5$ 中的当前度: $\\deg(v_4)=0$。\n\n**步骤 6：简化 $v_4$**\n最后一个顶点 $v_4$ 的度为 $0  3$。我们简化它，将其压入栈，图变为空。\n- 栈: $[v_5, v_6, v_1, v_3, v_4]$\n- 图现在为空，移除阶段完成。\n\n**结论**\n在此过程中被选择溢出的顶点集合是 $\\{v_2\\}$。问题要求所有溢出顶点的溢出成本之和。由于只有一个顶点被溢出，所以总和就是该顶点的成本。\n溢出成本之和 = $w_2 = 4$。\n着色阶段将通过从栈中弹出节点（$v_4, v_3, v_1, v_6, v_5$）来进行，但题目并未要求此步骤。", "answer": "$$\n\\boxed{4}\n$$", "id": "3644353"}]}