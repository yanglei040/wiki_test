{"hands_on_practices": [{"introduction": "任何数据流分析的第一步都是理解单个基本块内的局部信息。对于活跃变量分析，我们需要确定每个基本块中哪些变量在使用前未经定义（向上暴露变量，`UEVAR` 或 `USE` 集），以及哪些变量在块内被赋值（变量扼杀，`VARKILL` 或 `DEF` 集）。这个练习 [@problem_id:3651457] 将通过手动计算这些集合来巩固这些核心概念，这是掌握整个数据流分析算法的基础。", "problem": "给定一个以控制流图（CFG）形式组织的程序，其中每个节点都是一个基本块（BB）。程序变量的集合为 $$V = \\{a, b, c, d, e, f, g, h, x\\}$$，这些变量按顺序分别映射到比特位 $$0, 1, 2, 3, 4, 5, 6, 7, 8$$。一个基于 $$V$$ 的位向量被解释为一个非负整数掩码，其中当且仅当位置 $$i$$ 上的变量在集合中时，第 $$i$$ 位置位，其位值为 $$2^{i}$$。\n\n基本块和语句如下：\n- $$B_{1}: \\quad x := a + b; \\quad c := x + d; \\quad e := c; \\quad \\mathrm{goto}\\ B_{2}.$$\n- $$B_{2}: \\quad \\mathrm{if}\\ e > f\\ \\mathrm{goto}\\ B_{3}\\ \\mathrm{else}\\ \\mathrm{goto}\\ B_{4}.$$\n- $$B_{3}: \\quad d := e + g; \\quad a := d + 2; \\quad \\mathrm{goto}\\ B_{5}.$$\n- $$B_{4}: \\quad b := h + 1; \\quad g := b + e; \\quad \\mathrm{goto}\\ B_{5}.$$\n- $$B_{5}: \\quad f := a + g; \\quad \\mathrm{return}\\ f.$$\n\n使用活跃变量分析的基本定义，为每个基本块计算其向上暴露变量（UEVAR）和变量杀死（VARKILL）集合。在这里，如果一个变量在同一个块内被使用时，其前面没有任何对该变量的定义，则称该变量在该块中是向上暴露的。如果一个变量在一个块内被定义（赋值），则称该变量在该块中被杀死。\n\n设 $$M_{\\mathrm{UE}}(B_{i})$$ 是 $$UEVAR(B_{i})$$ 的整数掩码，$$M_{\\mathrm{VK}}(B_{i})$$ 是 $$VARKILL(B_{i})$$ 在给定比特映射下的整数掩码。计算值\n$$N = \\sum_{i=1}^{5} M_{\\mathrm{UE}}(B_{i}) \\;+\\; 2 \\sum_{i=1}^{5} M_{\\mathrm{VK}}(B_{i}).$$\n\n提供单个整数 $$N$$ 作为您的最终答案。无需四舍五入。", "solution": "问题陈述已经过验证，被认为是合理的。这是一个在编译器理论，特别是数据流分析领域内，定义明确的问题。所有必要的定义和数据都已提供，没有内部矛盾或歧义。我们可以开始求解。\n\n该问题要求我们为给定控制流图（CFG）中的每个基本块（$$B_i$$）计算两个集合：向上暴露变量（$$UEVAR$$）和变量杀死（$$VARKILL$$）集合。根据这些集合，我们必须计算它们对应的整数掩码 $$M_{\\mathrm{UE}}(B_{i})$$ 和 $$M_{\\mathrm{VK}}(B_{i})$$，并用它们来计算最终值 $$N$$。\n\n变量集合为 $$V = \\{a, b, c, d, e, f, g, h, x\\}$$。从变量到比特位 $$i$$（及其位值 $$2^i$$）的映射如下：\n- $$a \\to 0 \\quad (2^0 = 1)$$\n- $$b \\to 1 \\quad (2^1 = 2)$$\n- $$c \\to 2 \\quad (2^2 = 4)$$\n- $$d \\to 3 \\quad (2^3 = 8)$$\n- $$e \\to 4 \\quad (2^4 = 16)$$\n- $$f \\to 5 \\quad (2^5 = 32)$$\n- $$g \\to 6 \\quad (2^6 = 64)$$\n- $$h \\to 7 \\quad (2^7 = 128)$$\n- $$x \\to 8 \\quad (2^8 = 256)$$\n\n我们将依次分析每个基本块。\n\n**块 $$B_1$$ 的分析**\n$$B_1$$ 中的语句是：$$x := a + b; \\quad c := x + d; \\quad e := c;$$\n- 为了找到 $$UEVAR(B_1)$$，我们识别出在该块内定义之前就被使用的变量。\n  - 在 $$x := a + b$$ 中，使用了变量 $$a$$ 和 $$b$$。在此语句之前，它们都未在 $$B_1$$ 中被定义过。\n  - 在 $$c := x + d$$ 中，使用了变量 $$x$$ 和 $$d$$。变量 $$x$$ 在前一条语句中被定义。变量 $$d$$ 尚未被定义。\n  - 在 $$e := c$$ 中，使用了变量 $$c$$。它在前一条语句中被定义。\n  - 因此，向上暴露变量的集合是 $$UEVAR(B_1) = \\{a, b, d\\}$$。\n- 为了找到 $$VARKILL(B_1)$$，我们识别出在该块中被赋值（定义）的所有变量。\n  - 被定义的变量是 $$x, c, e$$。\n  - 因此，杀死集合是 $$VARKILL(B_1) = \\{x, c, e\\}$$。\n\n**块 $$B_2$$ 的分析**\n$$B_2$$ 中的语句是：$$\\mathrm{if}\\ e > f\\ \\mathrm{goto}\\ B_{3}\\ \\mathrm{else}\\ \\mathrm{goto}\\ B_{4}.$$\n- 为了找到 $$UEVAR(B_2)$$，我们识别出条件表达式中使用的变量。\n  - 使用了变量 $$e$$ 和 $$f$$。\n  - 这个块中没有定义任何变量。\n  - 因此，$$UEVAR(B_2) = \\{e, f\\}$$。\n- 为了找到 $$VARKILL(B_2)$$，我们识别出被定义的变量。没有。\n  - 因此，$$VARKILL(B_2) = \\emptyset$$。\n\n**块 $$B_3$$ 的分析**\n$$B_3$$ 中的语句是：$$d := e + g; \\quad a := d + 2;$$\n- 为了找到 $$UEVAR(B_3)$$：\n  - 在 $$d := e + g$$ 中，使用了变量 $$e$$ 和 $$g$$。在此使用之前，它们都未在 $$B_3$$ 中被定义过。\n  - 在 $$a := d + 2$$ 中，使用了变量 $$d$$，但它在同一个块的前一条语句中被定义。\n  - 因此，$$UEVAR(B_3) = \\{e, g\\}$$。\n- 为了找到 $$VARKILL(B_3)$$：\n  - 被定义的变量是 $$d$$ 和 $$a$$。\n  - 因此，$$VARKILL(B_3) = \\{a, d\\}$$。\n\n**块 $$B_4$$ 的分析**\n$$B_4$$ 中的语句是：$$b := h + 1; \\quad g := b + e;$$\n- 为了找到 $$UEVAR(B_4)$$：\n  - 在 $$b := h + 1$$ 中，使用了变量 $$h$$，它在 $$B_4$$ 中未被定义过。\n  - 在 $$g := b + e$$ 中，使用了变量 $$b$$ 和 $$e$$。$$b$$ 在前一条语句中被定义。$$e$$ 在 $$B_4$$ 中未被定义过。\n  - 因此，$$UEVAR(B_4) = \\{h, e\\}$$。\n- 为了找到 $$VARKILL(B_4)$$：\n  - 被定义的变量是 $$b$$ 和 $$g$$。\n  - 因此，$$VARKILL(B_4) = \\{b, g\\}$$。\n\n**块 $$B_5$$ 的分析**\n$$B_5$$ 中的语句是：$$f := a + g; \\quad \\mathrm{return}\\ f;$$\n- 为了找到 $$UEVAR(B_5)$$：\n  - 在 $$f := a + g$$ 中，使用了变量 $$a$$ 和 $$g$$。它们都未在 $$B_5$$ 中被定义过。\n  - 在 $$\\mathrm{return}\\ f$$ 中，使用了变量 $$f$$，但它刚刚被定义。\n  - 因此，$$UEVAR(B_5) = \\{a, g\\}$$。\n- 为了找到 $$VARKILL(B_5)$$：\n  - 被定义的变量是 $$f$$。\n  - 因此，$$VARKILL(B_5) = \\{f\\}$$。\n\n现在，我们为每个集合计算整数掩码。\n$$M_{\\mathrm{UE}}(B_1) \\text{ (对应 } \\{a,b,d\\}\\text{): } 2^0+2^1+2^3 = 1+2+8 = 11$$\n$$M_{\\mathrm{VK}}(B_1) \\text{ (对应 } \\{x,c,e\\}\\text{): } 2^8+2^2+2^4 = 256+4+16 = 276$$\n\n$$M_{\\mathrm{UE}}(B_2) \\text{ (对应 } \\{e,f\\}\\text{): } 2^4+2^5 = 16+32 = 48$$\n$$M_{\\mathrm{VK}}(B_2) \\text{ (对应 } \\emptyset\\text{): } 0$$\n\n$$M_{\\mathrm{UE}}(B_3) \\text{ (对应 } \\{e,g\\}\\text{): } 2^4+2^6 = 16+64 = 80$$\n$$M_{\\mathrm{VK}}(B_3) \\text{ (对应 } \\{a,d\\}\\text{): } 2^0+2^3 = 1+8 = 9$$\n\n$$M_{\\mathrm{UE}}(B_4) \\text{ (对应 } \\{h,e\\}\\text{): } 2^7+2^4 = 128+16 = 144$$\n$$M_{\\mathrm{VK}}(B_4) \\text{ (对应 } \\{b,g\\}\\text{): } 2^1+2^6 = 2+64 = 66$$\n\n$$M_{\\mathrm{UE}}(B_5) \\text{ (对应 } \\{a,g\\}\\text{): } 2^0+2^6 = 1+64 = 65$$\n$$M_{\\mathrm{VK}}(B_5) \\text{ (对应 } \\{f\\}\\text{): } 2^5 = 32$$\n\n接下来，我们计算最终值 $$N$$ 所需的两个总和。\n首先，是 $$M_{\\mathrm{UE}}$$ 掩码的总和：\n$$ \\sum_{i=1}^{5} M_{\\mathrm{UE}}(B_{i}) = 11 + 48 + 80 + 144 + 65 $$\n$$ \\sum_{i=1}^{5} M_{\\mathrm{UE}}(B_{i}) = 59 + 80 + 144 + 65 = 139 + 144 + 65 = 283 + 65 = 348 $$\n\n其次，是 $$M_{\\mathrm{VK}}$$ 掩码的总和：\n$$ \\sum_{i=1}^{5} M_{\\mathrm{VK}}(B_{i}) = 276 + 0 + 9 + 66 + 32 $$\n$$ \\sum_{i=1}^{5} M_{\\mathrm{VK}}(B_{i}) = 276 + 9 + 66 + 32 = 285 + 66 + 32 = 351 + 32 = 383 $$\n\n最后，我们使用给定的公式计算 $$N$$：\n$$ N = \\sum_{i=1}^{5} M_{\\mathrm{UE}}(B_{i}) \\;+\\; 2 \\sum_{i=1}^{5} M_{\\mathrm{VK}}(B_{i}) $$\n$$ N = 348 + 2 \\times 383 $$\n$$ N = 348 + 766 $$\n$$ N = 1114 $$", "answer": "$$\\boxed{1114}$$", "id": "3651457"}, {"introduction": "在掌握了单个基本块的分析之后，我们现在将视角扩展到整个控制流图。变量的活跃性信息是向后传播的：从一个变量的使用点反向追溯到其定义点。本练习 [@problem_id:3651499] 将引导你应用完整的数据流迭代算法，在一个包含 `switch` 语句的复杂控制流图中，观察活跃性信息如何通过不动点计算逐步稳定下来。", "problem": "考虑一个过程的以下控制流图（Control Flow Graph, CFG），该图由带标签的基本块组成。我们仅对变量 $x$ 进行活跃变量分析（Live Variable Analysis, LVA）。\n\n基本块如下：\n- $B_1$: $x := u + v$; goto $B_S$.\n- $B_S$: switch on $t$ with sparse targets: case $0 \\to B_2$, case $5 \\to B_3$, case $9 \\to B_4$, default $\\to B_5$.\n- $B_2$: $y := x + 1$; goto $B_6$.\n- $B_3$: if $p$ then goto $B_7$ else goto $B_8$.\n- $B_7$: $z := x$; goto $B_6$.\n- $B_8$: $z := 0$; goto $B_6$.\n- $B_4$: $y := 2$; goto $B_6$.\n- $B_5$: $w := 4$; goto $B_6$.\n- $B_6$: $x := y + z$; goto $B_9$.\n- $B_9$: return $x$.\n\n假设遵循通常的语义：$B_S$ 中的 switch 语句根据 $t$ 的值将控制权转移到其目标块中的一个；$B_3$ 中的测试根据 $p$ 的值分支到 $B_7$ 或 $B_8$；$B_9$ 是出口块。不会发生其他副作用。只分析 $x$ 的活跃性；其他变量（$u$、$v$、$y$、$z$、$w$、$t$、$p$）仅在它们出现在语句中时才需要考虑。\n\n使用数据流分析的基本原理，计算每个基本块 $B$ 关于 $x$ 的 $IN[B]$ 和 $OUT[B]$ 集合。然后，确定其入口集合 $IN[B]$ 包含 $x$ 的基本块的总数。\n\n你的最终答案必须是一个实数值，等于入口处 $x$ 活跃的基本块的数量。无需四舍五入。最终答案以一个无单位的纯数字表示。", "solution": "我们从控制流图（CFG）上的活跃变量分析（LVA）的基本定义开始。对每个基本块 $B$，定义：\n- $USE[B]$：在 $B$ 中任何重定义之前被读取的变量集合。\n- $DEF[B]$：在 $B$ 中定义的变量集合。\n\nLVA 的经典后向数据流方程为：\n$$\nIN[B] = USE[B] \\cup \\left(OUT[B] \\setminus DEF[B]\\right),\n$$\n$$\nOUT[B] = \\bigcup_{S \\in succ(B)} IN[S],\n$$\n其中 $succ(B)$ 是 $B$ 的后继块集合。在过程的出口处，我们将 $OUT$ 集合视为空集。\n\n我们只分析变量 $x$，所以每个 $USE[B]$、$DEF[B]$、$IN[B]$ 和 $OUT[B]$ 集合要么是 $\\emptyset$ 要么是 $\\{x\\}$。\n\n首先，枚举后继块：\n- $succ(B_1) = \\{B_S\\}$.\n- $succ(B_S) = \\{B_2, B_3, B_4, B_5\\}$.\n- $succ(B_2) = \\{B_6\\}$.\n- $succ(B_3) = \\{B_7, B_8\\}$.\n- $succ(B_7) = \\{B_6\\}$.\n- $succ(B_8) = \\{B_6\\}$.\n- $succ(B_4) = \\{B_6\\}$.\n- $succ(B_5) = \\{B_6\\}$.\n- $succ(B_6) = \\{B_9\\}$.\n- $succ(B_9) = \\emptyset$.\n\n接下来，计算关于 $x$ 的 $USE[B]$ 和 $DEF[B]$：\n- $B_1$：通过 $x := u + v$ 定义了 $x$，所以 $DEF[B_1] = \\{x\\}$，$USE[B_1] = \\emptyset$。\n- $B_S$：没有提及 $x$，所以 $DEF[B_S] = \\emptyset$，$USE[B_S] = \\emptyset$。\n- $B_2$：在 $y := x + 1$ 中使用了 $x$，所以 $USE[B_2] = \\{x\\}$，$DEF[B_2] = \\emptyset$。\n- $B_3$：没有提及 $x$，所以 $USE[B_3] = \\emptyset$，$DEF[B_3] = \\emptyset$。\n- $B_7$：在 $z := x$ 中使用了 $x$，所以 $USE[B_7] = \\{x\\}$，$DEF[B_7] = \\emptyset$。\n- $B_8$：没有提及 $x$，所以 $USE[B_8] = \\emptyset$，$DEF[B_8] = \\emptyset$。\n- $B_4$：没有提及 $x$，所以 $USE[B_4] = \\emptyset$，$DEF[B_4] = \\emptyset$。\n- $B_5$：没有提及 $x$，所以 $USE[B_5] = \\emptyset$，$DEF[B_5] = \\emptyset$。\n- $B_6$：通过 $x := y + z$ 定义了 $x$，并且在右侧没有读取 $x$，所以 $DEF[B_6] = \\{x\\}$，$USE[B_6] = \\emptyset$。\n- $B_9$：在 return $x$ 中使用了 $x$，所以 $USE[B_9] = \\{x\\}$，$DEF[B_9] = \\emptyset$。\n\n我们现在从出口开始，反向求解方程：\n- 对于 $B_9$，$OUT[B_9] = \\emptyset$（出口）。那么\n  $$\n  IN[B_9] = USE[B_9] \\cup (OUT[B_9] \\setminus DEF[B_9]) = \\{x\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x\\}.\n  $$\n\n- 对于 $B_6$，$OUT[B_6] = IN[B_9] = \\{x\\}$。那么\n  $$\n  IN[B_6] = USE[B_6] \\cup (OUT[B_6] \\setminus DEF[B_6]) = \\emptyset \\cup (\\{x\\} \\setminus \\{x\\}) = \\emptyset.\n  $$\n\n- 对于 $B_2$，$OUT[B_2] = IN[B_6] = \\emptyset$。那么\n  $$\n  IN[B_2] = USE[B_2] \\cup (OUT[B_2] \\setminus DEF[B_2]) = \\{x\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x\\}.\n  $$\n\n- 对于 $B_7$，$OUT[B_7] = IN[B_6] = \\emptyset$。那么\n  $$\n  IN[B_7] = USE[B_7] \\cup (OUT[B_7] \\setminus DEF[B_7]) = \\{x\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x\\}.\n  $$\n\n- 对于 $B_8$，$OUT[B_8] = IN[B_6] = \\emptyset$。那么\n  $$\n  IN[B_8] = USE[B_8] \\cup (OUT[B_8] \\setminus DEF[B_8]) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset.\n  $$\n\n- 对于 $B_4$，$OUT[B_4] = IN[B_6] = \\emptyset$。那么\n  $$\n  IN[B_4] = USE[B_4] \\cup (OUT[B_4] \\setminus DEF[B_4]) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset.\n  $$\n\n- 对于 $B_5$，$OUT[B_5] = IN[B_6] = \\emptyset$。那么\n  $$\n  IN[B_5] = USE[B_5] \\cup (OUT[B_5] \\setminus DEF[B_5]) = \\emptyset.\n  $$\n\n- 对于 $B_3$，$OUT[B_3] = IN[B_7] \\cup IN[B_8] = \\{x\\} \\cup \\emptyset = \\{x\\}$。那么\n  $$\n  IN[B_3] = USE[B_3] \\cup (OUT[B_3] \\setminus DEF[B_3]) = \\emptyset \\cup (\\{x\\} \\setminus \\emptyset) = \\{x\\}.\n  $$\n\n- 对于 $B_S$，$OUT[B_S] = IN[B_2] \\cup IN[B_3] \\cup IN[B_4] \\cup IN[B_5] = \\{x\\} \\cup \\{x\\} \\cup \\emptyset \\cup \\emptyset = \\{x\\}$。那么\n  $$\n  IN[B_S] = USE[B_S] \\cup (OUT[B_S] \\setminus DEF[B_S]) = \\emptyset \\cup (\\{x\\} \\setminus \\emptyset) = \\{x\\}.\n  $$\n\n- 对于 $B_1$，$OUT[B_1] = IN[B_S] = \\{x\\}$。那么\n  $$\n  IN[B_1] = USE[B_1] \\cup (OUT[B_1] \\setminus DEF[B_1]) = \\emptyset \\cup (\\{x\\} \\setminus \\{x\\}) = \\emptyset.\n  $$\n\n汇总 $IN$ 集合：\n- $IN[B_1] = \\emptyset$,\n- $IN[B_S] = \\{x\\}$,\n- $IN[B_2] = \\{x\\}$,\n- $IN[B_3] = \\{x\\}$,\n- $IN[B_4] = \\emptyset$,\n- $IN[B_5] = \\emptyset$,\n- $IN[B_6] = \\emptyset$,\n- $IN[B_7] = \\{x\\}$,\n- $IN[B_8] = \\emptyset$,\n- $IN[B_9] = \\{x\\}$.\n\n因此，其入口集合包含 $x$ 的基本块总数，就是 $IN[B] = \\{x\\}$ 的块的数量，即 5 个（也就是 $B_S$、$B_2$、$B_3$、$B_7$ 和 $B_9$）。", "answer": "$$\\boxed{5}$$", "id": "3651499"}, {"introduction": "活跃变量分析的理论最终要服务于实践，其最重要的应用之一就是指导寄存器分配。通过分析，我们可以构建一个冲突图，其中如果两个变量在程序的任何一点同时活跃，就在它们之间连接一条边。这个综合性练习 [@problem_id:3651500] 将带你走完从活跃变量分析到构建冲突图，并最终确定寄存器可分配性的全过程，让你深刻体会到该技术在编译器优化中的巨大价值。", "problem": "考虑以下用三地址风格编写的伪程序。其控制流图（CFG）由四个基本块组成，边为 $B_{1} \\rightarrow B_{2}$、$B_{1} \\rightarrow B_{3}$、$B_{2} \\rightarrow B_{4}$ 和 $B_{3} \\rightarrow B_{4}$。只有变量 $x$、$y$ 和 $z$ 是寄存器分配的候选对象；所有其他符号表示常驻内存的值，不属于寄存器分配问题的一部分。\n\n块 $B_{1}$：\n- $x := a + 1$\n- $y := b + 1$\n- if $p$ goto $B_{2}$ else goto $B_{3}$\n\n块 $B_{2}$：\n- $z := x + y$\n- $y := z + c$\n- goto $B_{4}$\n\n块 $B_{3}$：\n- $z := y + d$\n- $x := z + e$\n- goto $B_{4}$\n\n块 $B_{4}$：\n- $r := x + y + z$\n- return $r$\n\n使用标准的用于活跃变量分析的后向数据流框架，以及经典方程\n- $\\mathrm{LiveOut}(n) = \\bigcup_{s \\in \\mathrm{succ}(n)} \\mathrm{LiveIn}(s)$,\n- $\\mathrm{LiveIn}(n) = \\mathrm{Use}(n) \\cup \\left( \\mathrm{LiveOut}(n) \\setminus \\mathrm{Def}(n) \\right)$,\n其中 $\\mathrm{Use}(n)$ 和 $\\mathrm{Def}(n)$ 是相对于集合 $\\{x,y,z\\}$ 计算的，请执行以下操作：\n\n- 推导每个基本块 $B_{1}$、$B_{2}$、$B_{3}$ 和 $B_{4}$ 的 $\\mathrm{Use}$ 和 $\\mathrm{Def}$。\n- 求解数据流方程，以获得每个基本块的 $\\mathrm{LiveIn}$ 和 $\\mathrm{LiveOut}$。\n- 根据活跃性信息，构建干涉图，其顶点为 $\\{x,y,z\\}$，两个变量之间的边表示它们在某个程序点上同时活跃。\n- 在寄存器分配模型中，分配 $k$ 个寄存器对应于用 $k$ 种颜色对干涉图进行正常着色。请确定此程序中 $\\{x,y,z\\}$ 的有效 $k$ 寄存器分配数量的关于 $k$ 的封闭形式解析表达式。\n\n将你的最终答案表示为关于 $k$ 的单个解析表达式。无需四舍五入。最终答案中不要包含任何单位。", "solution": "用户希望我解决一个编译器优化问题。\n\n### 问题验证\n\n**第1步：提取已知条件**\n\n-   **程序结构**：一个三地址风格的伪程序。\n-   **控制流图（CFG）**：\n    -   基本块：$B_{1}$、$B_{2}$、$B_{3}$、$B_{4}$。\n    -   边：$B_{1} \\rightarrow B_{2}$、$B_{1} \\rightarrow B_{3}$、$B_{2} \\rightarrow B_{4}$、$B_{3} \\rightarrow B_{4}$。\n    -   后继：$\\mathrm{succ}(B_1) = \\{B_2, B_3\\}$、$\\mathrm{succ}(B_2) = \\{B_4\\}$、$\\mathrm{succ}(B_3) = \\{B_4\\}$、$\\mathrm{succ}(B_4) = \\emptyset$。\n-   **用于寄存器分配的变量**：$\\{x, y, z\\}$。其他符号（$a, b, c, d, e, p, r$）是常驻内存的。\n-   **基本块代码**：\n    -   块 $B_{1}$：\n        -   $x := a + 1$\n        -   $y := b + 1$\n        -   if $p$ goto $B_{2}$ else goto $B_{3}$\n    -   块 $B_{2}$：\n        -   $z := x + y$\n        -   $y := z + c$\n        -   goto $B_{4}$\n    -   块 $B_{3}$：\n        -   $z := y + d$\n        -   $x := z + e$\n        -   goto $B_{4}$\n    -   块 $B_{4}$：\n        -   $r := x + y + z$\n        -   return $r$\n-   **活跃变量分析框架**：\n    -   类型：后向流数据流分析。\n    -   方程：\n        -   $\\mathrm{LiveOut}(n) = \\bigcup_{s \\in \\mathrm{succ}(n)} \\mathrm{LiveIn}(s)$\n        -   $\\mathrm{LiveIn}(n) = \\mathrm{Use}(n) \\cup \\left( \\mathrm{LiveOut}(n) \\setminus \\mathrm{Def}(n) \\right)$\n    -   集合 $\\mathrm{Use}(n)$ 和 $\\mathrm{Def}(n)$ 是相对于变量 $\\{x, y, z\\}$ 计算的。\n-   **任务**：\n    1.  推导每个基本块的 $\\mathrm{Use}$ 和 $\\mathrm{Def}$。\n    2.  求解数据流方程以获得 $\\mathrm{LiveIn}$ 和 $\\mathrm{LiveOut}$。\n    3.  为 $\\{x, y, z\\}$ 构建干涉图。\n    4.  确定有效 $k$ 寄存器分配数量的关于 $k$ 的封闭形式解析表达式。\n\n**第2步：使用提取的已知条件进行验证**\n\n-   **科学依据**：该问题是编译器设计中的一个标准练习，具体涉及寄存器分配。活跃变量分析、干涉图和图着色是该领域的基本、成熟的概念。该问题在科学上是合理的。\n-   **适定性**：问题陈述清晰，提供了所有必要信息。任务是顺序的，并能导出一个唯一确定的答案。\n-   **客观性**：问题使用精确、无歧义的技术语言描述。它不包含任何主观或基于意见的陈述。\n-   **完整性**：所有必需的定义、代码和数据流方程均已提供。问题是自包含的。\n-   **一致性**：CFG结构和代码中的 `goto` 语句是一致的。问题设置中没有矛盾。\n-   **可行性**：该问题是一个小型的教科书式示例，完全可以用手解出。\n\n**第3步：结论与行动**\n\n该问题是**有效的**。这是一个适定的、编译器原理中的标准学术问题。我将继续进行解答。\n\n### 解答\n\n解答按要求分四步进行：计算 `Use/Def` 集合，求解活跃性数据流方程，构建干涉图，以及求该图的色多项式。\n\n**1. $\\mathrm{Use}$ 和 $\\mathrm{Def}$ 集合的推导**\n\n集合 $\\mathrm{Use}(n)$ 包含在块 $n$ 中定义之前就被使用的变量（来自 $\\{x, y, z\\}$）。集合 $\\mathrm{Def}(n)$ 包含在块 $n$ 中被定义（赋值）的变量（来自 $\\{x, y, z\\}$）。\n\n-   **块 $B_{1}$**：\n    -   `x := a + 1`：定义 $x$。\n    -   `y := b + 1`：定义 $y$。\n    -   没有来自 $\\{x, y, z\\}$ 的变量在被定义前使用。\n    -   $\\mathrm{Use}(B_{1}) = \\emptyset$\n    -   $\\mathrm{Def}(B_{1}) = \\{x, y\\}$\n\n-   **块 $B_{2}$**：\n    -   `z := x + y`：使用 $x$ 和 $y$，定义 $z$。\n    -   `y := z + c`：使用 $z$，定义 $y$。变量 $z$ 被使用，但它是在同一块内的前一个语句中定义的，所以它不在 $\\mathrm{Use}(B_2)$ 中。\n    -   $\\mathrm{Use}(B_{2}) = \\{x, y\\}$\n    -   $\\mathrm{Def}(B_{2}) = \\{y, z\\}$\n\n-   **块 $B_{3}$**：\n    -   `z := y + d`：使用 $y$，定义 $z$。\n    -   `x := z + e`：使用 $z$，定义 $x$。变量 $z$ 被使用，但在块中较早的位置被定义。\n    -   $\\mathrm{Use}(B_{3}) = \\{y\\}$\n    -   $\\mathrm{Def}(B_{3}) = \\{x, z\\}$\n\n-   **块 $B_{4}$**：\n    -   `r := x + y + z`：使用 $x$、$y$ 和 $z$。\n    -   没有来自 $\\{x, y, z\\}$ 的变量被定义。\n    -   $\\mathrm{Use}(B_{4}) = \\{x, y, z\\}$\n    -   $\\mathrm{Def}(B_{4}) = \\emptyset$\n\n**2. 活跃变量分析**\n\n我们迭代求解数据流方程，直到达到不动点。我们将所有 $\\mathrm{LiveIn}$ 和 $\\mathrm{LiveOut}$ 集合初始化为 $\\emptyset$。分析从程序出口开始，向后进行。\n\n方程为：\n$\\mathrm{LiveOut}(n) = \\bigcup_{s \\in \\mathrm{succ}(n)} \\mathrm{LiveIn}(s)$\n$\\mathrm{LiveIn}(n) = \\mathrm{Use}(n) \\cup (\\mathrm{LiveOut}(n) \\setminus \\mathrm{Def}(n))$\n\n`Use`/`Def` 集合总结：\n-   $B_{1}$：$\\mathrm{Use} = \\emptyset$, $\\mathrm{Def} = \\{x, y\\}$\n-   $B_{2}$：$\\mathrm{Use} = \\{x, y\\}$, $\\mathrm{Def} = \\{y, z\\}$\n-   $B_{3}$：$\\mathrm{Use} = \\{y\\}$, $\\mathrm{Def} = \\{x, z\\}$\n-   $B_{4}$：$\\mathrm{Use} = \\{x, y, z\\}$, $\\mathrm{Def} = \\emptyset$\n\n**迭代 1：**\n-   **块 $B_{4}$**：\n    -   $\\mathrm{LiveOut}(B_{4}) = \\bigcup_{s \\in \\emptyset} \\mathrm{LiveIn}(s) = \\emptyset$\n    -   $\\mathrm{LiveIn}(B_{4}) = \\mathrm{Use}(B_{4}) \\cup (\\mathrm{LiveOut}(B_{4}) \\setminus \\mathrm{Def}(B_{4})) = \\{x, y, z\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x, y, z\\}$\n-   **块 $B_{3}$**：\n    -   $\\mathrm{LiveOut}(B_{3}) = \\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$\n    -   $\\mathrm{LiveIn}(B_{3}) = \\mathrm{Use}(B_{3}) \\cup (\\mathrm{LiveOut}(B_{3}) \\setminus \\mathrm{Def}(B_{3})) = \\{y\\} \\cup (\\{x, y, z\\} \\setminus \\{x, z\\}) = \\{y\\} \\cup \\{y\\} = \\{y\\}$\n-   **块 $B_{2}$**：\n    -   $\\mathrm{LiveOut}(B_{2}) = \\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$\n    -   $\\mathrm{LiveIn}(B_{2}) = \\mathrm{Use}(B_{2}) \\cup (\\mathrm{LiveOut}(B_{2}) \\setminus \\mathrm{Def}(B_{2})) = \\{x, y\\} \\cup (\\{x, y, z\\} \\setminus \\{y, z\\}) = \\{x, y\\} \\cup \\{x\\} = \\{x, y\\}$\n-   **块 $B_{1}$**：\n    -   $\\mathrm{LiveOut}(B_{1}) = \\mathrm{LiveIn}(B_{2}) \\cup \\mathrm{LiveIn}(B_{3}) = \\{x, y\\} \\cup \\{y\\} = \\{x, y\\}$\n    -   $\\mathrm{LiveIn}(B_{1}) = \\mathrm{Use}(B_{1}) \\cup (\\mathrm{LiveOut}(B_{1}) \\setminus \\mathrm{Def}(B_{1})) = \\emptyset \\cup (\\{x, y\\} \\setminus \\{x, y\\}) = \\emptyset$\n\n**迭代 2：** 我们重新计算集合以检查收敛性。\n-   $\\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$。无变化。\n-   $\\mathrm{LiveOut}(B_{3}) = \\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$。无变化。\n-   $\\mathrm{LiveIn}(B_{3}) = \\{y\\}$。无变化。\n-   $\\mathrm{LiveOut}(B_{2}) = \\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$。无变化。\n-   $\\mathrm{LiveIn}(B_{2}) = \\{x, y\\}$。无变化。\n-   $\\mathrm{LiveOut}(B_{1}) = \\mathrm{LiveIn}(B_{2}) \\cup \\mathrm{LiveIn}(B_{3}) = \\{x, y\\}$。无变化。\n-   $\\mathrm{LiveIn}(B_{1}) = \\emptyset$。无变化。\n\n已达到不动点。最终的活跃性集合为：\n-   $\\mathrm{LiveIn}(B_{1}) = \\emptyset$, $\\mathrm{LiveOut}(B_{1}) = \\{x, y\\}$\n-   $\\mathrm{LiveIn}(B_{2}) = \\{x, y\\}$, $\\mathrm{LiveOut}(B_{2}) = \\{x, y, z\\}$\n-   $\\mathrm{LiveIn}(B_{3}) = \\{y\\}$, $\\mathrm{LiveOut}(B_{3}) = \\{x, y, z\\}$\n-   $\\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$, $\\mathrm{LiveOut}(B_{4}) = \\emptyset$\n\n**3. 干涉图构建**\n\n如果两个变量在任何程序点上同时活跃，则它们相互干涉。我们可以通过检查活跃集合来发现干涉。一组变量之间存在干涉的一个充分条件是它们同时出现在任何 $\\mathrm{LiveIn}$ 或 $\\mathrm{LiveOut}$ 集合中，或者在基本块内的任何点的活跃集合中。\n\n-   在块 $B_{4}$ 的入口处，活跃集合是 $\\mathrm{LiveIn}(B_{4}) = \\{x, y, z\\}$。这意味着变量 $x$、$y$ 和 $z$ 同时都是活跃的。\n-   因此，它们都相互干涉。这意味着存在以下干涉边：\n    -   $(x, y)$\n    -   $(x, z)$\n    -   $(y, z)$\n-   这三条边在顶点集 $\\{x, y, z\\}$ 上形成一个完全图 $K_{3}$。由于这是三个顶点的最大可能边数，我们已经完全确定了干涉图。\n-   确认：集合 $\\mathrm{LiveOut}(B_{2}) = \\{x, y, z\\}$ 和 $\\mathrm{LiveOut}(B_{3}) = \\{x, y, z\\}$ 也表明所有三个变量在块 $B_{2}$ 和 $B_{3}$ 的出口处同时活跃。\n\n干涉图是一个连接顶点 $x$、$y$ 和 $z$ 的三角形。\n\n**4. 有效的 $k$ 寄存器分配数量**\n\n一个有效的 $k$ 寄存器分配对应于用 $k$ 种颜色对干涉图进行正常着色。实现这一目的的方法数由图的色多项式在 $k$ 处的值给出。\n\n干涉图是 3 个顶点上的完全图，记为 $K_{3}$。完全图 $K_{n}$ 的色多项式由以下公式给出：\n$$P(K_{n}, k) = k(k-1)(k-2)\\dots(k-n+1)$$\n这也称为下降阶乘 $k^{(n)}$ 或排列数 $P(k,n)$。\n\n对于我们的图，$n=3$，所以有效的 $k$ 着色（寄存器分配）的数量是：\n$$P(K_{3}, k) = k(k-1)(k-2)$$\n\n该表达式给出了为变量 $x$、$y$ 和 $z$ 分配颜色（寄存器）的方法数，使得没有两个相互干涉的变量共享相同的颜色。\n-   对于变量 $x$，有 $k$ 种颜色选择。\n-   对于与 $x$ 干涉的变量 $y$，有 $k-1$ 种剩余选择。\n-   对于与 $x$ 和 $y$（它们必须有不同的颜色）都干涉的变量 $z$，有 $k-2$ 种剩余选择。\n\n有效的总分配数是乘积 $k(k-1)(k-2)$。这就是所要求的封闭形式解析表达式。", "answer": "$$\n\\boxed{k(k-1)(k-2)}\n$$", "id": "3651500"}]}