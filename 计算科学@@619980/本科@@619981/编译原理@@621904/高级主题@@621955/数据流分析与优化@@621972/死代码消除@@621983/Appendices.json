{"hands_on_practices": [{"introduction": "要消除死代码，编译器首先必须识别出它。这通常通过*活跃度分析*来完成，该分析确定一个变量的值将来是否可能被使用。这个基础练习将引导你为一个小程序计算活跃变量集，并利用这些信息执行一轮死代码消除，让你亲身体验这种优化的核心机制。[@problem_id:3636224]", "problem": "给定一个带有分支的直线式程序，其结构被组织成一个控制流图（CFG）。所有的算术赋值都是纯粹的（没有副作用），唯一必须始终保留的控制操作是条件分支和最终的返回。该CFG有四个基本块 $B_1, B_2, B_3, B_4$，以及有向边 $B_1 \\to B_2$、$B_1 \\to B_3$、$B_2 \\to B_4$、$B_3 \\to B_4$。在每个块中，指令按程序顺序编号如下。\n\n块 $B_1$：\n- $1$: $a \\leftarrow 1$\n- $2$: $b \\leftarrow a + 2$\n- $3$: $c \\leftarrow b \\times 3$\n- $4$: if $c > 10$ goto $B_2$ else goto $B_3$\n\n块 $B_2$：\n- $5$: $d \\leftarrow c - 4$\n- $6$: $e \\leftarrow d + b$\n- $7$: $t \\leftarrow d - d$\n- $8$: $a \\leftarrow e \\times 2$\n- $9$: goto $B_4$\n\n块 $B_3$：\n- $10$: $d \\leftarrow a + 5$\n- $11$: $b \\leftarrow 7$\n- $12$: $f \\leftarrow b + d$\n- $13$: $u \\leftarrow b - b$\n- $14$: goto $B_4$\n\n块 $B_4$：\n- $15$: $g \\leftarrow a + 1$\n- $16$: $h \\leftarrow g + d$\n- $17$: return $h$\n\n使用基本定义——一个变量在某个程序点是活跃的，当且仅当从该点出发的某条路径上，在任何重定义之前存在对该变量的使用——对该CFG执行后向活跃变量分析直至达到不动点，然后按如下方式执行算术赋值的死代码消除：在每个基本块 $B$ 中，逆序扫描指令，并维护一个活跃集，其初始值等于紧跟在该块之后的活跃集；如果 $x$ 不在当前的活跃集中，则算术赋值 $x \\leftarrow \\text{expr}$ 是死的，此时可以移除它，并且它的使用（变量）不会被添加到活跃集中。如果指令不是死的，则通过移除定义的变量并添加其使用的变量来更新活跃集。\n\n在所有块中完成此过程后，总共消除了多少条算术赋值指令？请以单个整数形式提供最终答案。无需四舍五入，也无需单位。", "solution": "该问题要求我们对给定的控制流图（CFG）执行活跃变量分析，然后利用分析结果进行死代码消除。最终答案是消除的算术赋值指令的总数。\n\n### 第一步：问题验证\n\n**1.1. 提取给定条件：**\n- **CFG 结构：** 四个基本块 $B_1, B_2, B_3, B_4$。\n- **边：** $B_1 \\to B_2$、$B_1 \\to B_3$、$B_2 \\to B_4$、$B_3 \\to B_4$。\n- **块 $B_1$ 指令：**\n  - $1$: $a \\leftarrow 1$\n  - $2$: $b \\leftarrow a + 2$\n  - $3$: $c \\leftarrow b \\times 3$\n  - $4$: if $c > 10$ goto $B_2$ else goto $B_3$\n- **块 $B_2$ 指令：**\n  - $5$: $d \\leftarrow c - 4$\n  - $6$: $e \\leftarrow d + b$\n  - $7$: $t \\leftarrow d - d$\n  - $8$: $a \\leftarrow e \\times 2$\n  - $9$: goto $B_4$\n- **块 $B_3$ 指令：**\n  - $10$: $d \\leftarrow a + 5$\n  - $11$: $b \\leftarrow 7$\n  - $12$: $f \\leftarrow b + d$\n  - $13$: $u \\leftarrow b - b$\n  - $14$: goto $B_4$\n- **块 $B_4$ 指令：**\n  - $15$: $g \\leftarrow a + 1$\n  - $16$: $h \\leftarrow g + d$\n  - $17$: return $h$\n- **活跃性定义：** 一个变量在某个程序点是活跃的，如果从该点出发存在一条路径，在该路径上变量在被重定义之前被使用。\n- **死代码消除算法：** 对于每个块 $B$，逆序扫描指令。如果 $x$ 不在当前活跃集中，则赋值 $x \\leftarrow \\text{expr}$ 是死的。如果是死的，则移除它，并且不将其使用的变量添加到活跃集中。如果不是死的，则通过移除 $x$ 并添加 $\\text{expr}$ 中使用的变量来更新活跃集。\n\n**1.2. 使用提取的条件进行验证：**\n该问题是编译器优化理论中的一个标准练习。它自成体系，提供了所有必要的数据和算法。CFG、指令和过程都定义明确。该问题具有科学依据、客观且提法得当。没有矛盾、歧义或事实不符之处。因此，该问题是有效的。\n\n### 第二步：活跃变量分析\n\n我们执行后向数据流分析，以找出每个基本块 $B$ 入口处（$\\text{In}[B]$）和出口处（$\\text{Out}[B]$）的活跃变量集。\n\n首先，我们确定每个块的 $\\text{Use}[B]$ 和 $\\text{Def}[B]$ 集合。\n- $\\text{Use}[B]$：在块 $B$ 中，先于其定义而被使用的变量。\n- $\\text{Def}[B]$：在块 $B$ 中被定义（赋值）的变量。\n\n- **块 $B_1$：**\n  - 使用：指令2中的 $a$，指令3中的 $b$，指令4中的 $c$。所有这些变量在使用前都在块内被定义。\n  - $\\text{Use}[B_1] = \\emptyset$\n  - $\\text{Def}[B_1] = \\{a, b, c\\}$\n- **块 $B_2$：**\n  - 使用：指令5中的 $c$，指令6中的 $b$。这些变量在被使用前没有在 $B_2$ 中被定义。\n  - $\\text{Use}[B_2] = \\{b, c\\}$\n  - $\\text{Def}[B_2] = \\{d, e, t, a\\}$\n- **块 $B_3$：**\n  - 使用：指令10中的 $a$。该变量在被使用前没有在 $B_3$ 中被定义。\n  - $\\text{Use}[B_3] = \\{a\\}$\n  - $\\text{Def}[B_3] = \\{b, d, f, u\\}$\n- **块 $B_4$：**\n  - 使用：指令15中的 $a$，指令16中的 $d$。这些变量在被使用前没有在 $B_4$ 中被定义。在 `return h` 中对 $h$ 的使用发生在其定义之后。\n  - $\\text{Use}[B_4] = \\{a, d\\}$\n  - $\\text{Def}[B_4] = \\{g, h\\}$\n\n数据流方程为：\n$$ \\text{Out}[B] = \\bigcup_{S \\in \\text{Successors}(B)} \\text{In}[S] $$\n$$ \\text{In}[B] = \\text{Use}[B] \\cup (\\text{Out}[B] - \\text{Def}[B]) $$\n我们将所有 $B$ 的 $\\text{In}[B]$ 初始化为 $\\emptyset$，然后迭代直至达到不动点。\n\n**第0次迭代：**\n$$ \\text{In}[B_1] = \\emptyset, \\quad \\text{In}[B_2] = \\emptyset, \\quad \\text{In}[B_3] = \\emptyset, \\quad \\text{In}[B_4] = \\emptyset $$\n\n**第1次迭代（按逆拓扑序处理：$B_4, B_3, B_2, B_1$）：**\n- **块 $B_4$：** $\\text{Successors}(B_4) = \\emptyset$，所以 $\\text{Out}[B_4] = \\emptyset$。\n  $$ \\text{In}[B_4] = \\text{Use}[B_4] \\cup (\\text{Out}[B_4] - \\text{Def}[B_4]) = \\{a, d\\} \\cup (\\emptyset - \\{g, h\\}) = \\{a, d\\} $$\n- **块 $B_3$：** $\\text{Successors}(B_3) = \\{B_4\\}$。\n  $$ \\text{Out}[B_3] = \\text{In}[B_4] = \\{a, d\\} $$\n  $$ \\text{In}[B_3] = \\text{Use}[B_3] \\cup (\\text{Out}[B_3] - \\text{Def}[B_3]) = \\{a\\} \\cup (\\{a, d\\} - \\{b, d, f, u\\}) = \\{a\\} \\cup \\{a\\} = \\{a\\} $$\n- **块 $B_2$：** $\\text{Successors}(B_2) = \\{B_4\\}$。\n  $$ \\text{Out}[B_2] = \\text{In}[B_4] = \\{a, d\\} $$\n  $$ \\text{In}[B_2] = \\text{Use}[B_2] \\cup (\\text{Out}[B_2] - \\text{Def}[B_2]) = \\{b, c\\} \\cup (\\{a, d\\} - \\{d, e, t, a\\}) = \\{b, c\\} \\cup \\emptyset = \\{b, c\\} $$\n- **块 $B_1$：** $\\text{Successors}(B_1) = \\{B_2, B_3\\}$。\n  $$ \\text{Out}[B_1] = \\text{In}[B_2] \\cup \\text{In}[B_3] = \\{b, c\\} \\cup \\{a\\} = \\{a, b, c\\} $$\n  $$ \\text{In}[B_1] = \\text{Use}[B_1] \\cup (\\text{Out}[B_1] - \\text{Def}[B_1]) = \\emptyset \\cup (\\{a, b, c\\} - \\{a, b, c\\}) = \\emptyset $$\n\n**第2次迭代：**\n我们重新计算这些集合。$\\text{In}[B_4]$ 只依赖于常量集合，因此它保持不变。这意味着 $\\text{Out}[B_2]$ 和 $\\text{Out}[B_3]$ 也不变。重新计算 $\\text{In}[B_2]$ 和 $\\text{In}[B_3]$ 会得到相同的结果。这会传播到 $\\text{Out}[B_1]$ 和 $\\text{In}[B_1]$。系统已达到不动点。\n\n**最终活跃集：**\n- $\\text{In}[B_1] = \\emptyset$, $\\text{Out}[B_1] = \\{a, b, c\\}$\n- $\\text{In}[B_2] = \\{b, c\\}$, $\\text{Out}[B_2] = \\{a, d\\}$\n- $\\text{In}[B_3] = \\{a\\}$, $\\text{Out}[B_3] = \\{a, d\\}$\n- $\\text{In}[B_4] = \\{a, d\\}$, $\\text{Out}[B_4] = \\emptyset$\n\n### 第三步：死代码消除\n\n现在，我们对每个基本块应用指定的算法，逆序扫描指令。\n\n**块 $B_4$：**\n- 初始活跃集：$L = \\text{Out}[B_4] = \\emptyset$。\n- `17: return h`：这是对 $h$ 的一次使用，必须保留。该指令之前的活跃集是 $L = \\{h\\}$。\n- `16: h ← g + d`：定义的变量 $h$ 在 $L = \\{h\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{h\\}) \\cup \\{g, d\\} = \\{g, d\\}$。\n- `15: g ← a + 1`：定义的变量 $g$ 在 $L = \\{g, d\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{g\\}) \\cup \\{a\\} = \\{d, a\\}$。\n- $B_4$ 中消除的指令数：$0$。\n\n**块 $B_3$：**\n- 初始活跃集：$L = \\text{Out}[B_3] = \\{a, d\\}$。\n- `14: goto B_4`：保留的控制流。\n- `13: u ← b - b`：定义的变量 $u$ 不在 $L = \\{a, d\\}$ 中。该指令是**死的**。它被消除。$L$ 保持为 $\\{a, d\\}$。\n- `12: f ← b + d`：定义的变量 $f$ 不在 $L = \\{a, d\\}$ 中。该指令是**死的**。它被消除。$L$ 保持为 $\\{a, d\\}$。\n- `11: b ← 7`：定义的变量 $b$ 不在 $L = \\{a, d\\}$ 中。该指令是**死的**。它被消除。$L$ 保持为 $\\{a, d\\}$。\n- `10: d ← a + 5`：定义的变量 $d$ 在 $L = \\{a, d\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{d\\}) \\cup \\{a\\} = \\{a\\}$。\n- $B_3$ 中消除的指令数：$3$。\n\n**块 $B_2$：**\n- 初始活跃集：$L = \\text{Out}[B_2] = \\{a, d\\}$。\n- `9: goto B_4`：保留的控制流。\n- `8: a ← e × 2`：定义的变量 $a$ 在 $L = \\{a, d\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{a\\}) \\cup \\{e\\} = \\{d, e\\}$。\n- `7: t ← d - d`：定义的变量 $t$ 不在 $L = \\{d, e\\}$ 中。该指令是**死的**。它被消除。$L$ 保持为 $\\{d, e\\}$。\n- `6: e ← d + b`：定义的变量 $e$ 在 $L = \\{d, e\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{e\\}) \\cup \\{d, b\\} = \\{d, b\\}$。\n- `5: d ← c - 4`：定义的变量 $d$ 在 $L = \\{d, b\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{d\\}) \\cup \\{c\\} = \\{b, c\\}$。\n- $B_2$ 中消除的指令数：$1$。\n\n**块 $B_1$：**\n- 初始活跃集：$L = \\text{Out}[B_1] = \\{a, b, c\\}$。\n- `4: if c > 10 ...`：保留的控制流。这是对 $c$ 的一次使用。此前的活跃集必须包含 $c$。\n- `3: c ← b × 3`：定义的变量 $c$ 在 $L = \\{a, b, c\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{c\\}) \\cup \\{b\\} = \\{a, b\\}$。\n- `2: b ← a + 2`：定义的变量 $b$ 在 $L = \\{a, b\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{b\\}) \\cup \\{a\\} = \\{a\\}$。\n- `1: a ← 1`：定义的变量 $a$ 在 $L = \\{a\\}$ 中。该指令是**活跃的**。更新 $L = (L - \\{a\\}) \\cup \\emptyset = \\emptyset$。\n- $B_1$ 中消除的指令数：$0$。\n\n**消除的指令总数：**\n消除的算术赋值指令总数是每个块中消除数量的总和：\n总数 = ($B_1$ 中消除数) + ($B_2$ 中消除数) + ($B_3$ 中消除数) + ($B_4$ 中消除数)\n总数 = $0 + 1 + 3 + 0 = 4$。\n被消除的指令是：\n1. `t ← d - d` (在 $B_2$ 中)\n2. `u ← b - b` (在 $B_3$ 中)\n3. `f ← b + d` (在 $B_3$ 中)\n4. `b ← 7` (在 $B_3$ 中)", "answer": "$$\\boxed{4}$$", "id": "3636224"}, {"introduction": "优化过程通常在重复运行时效果最佳。删除一条死指令可能会使其输入的计算指令变得无用，从而产生连锁反应。本练习通过要求你*迭代地*执行死代码消除直至达到不动点，来展示这一强大概念，揭示简单的分析如何发现更深层次的优化机会。[@problem_id:3636266]", "problem": "考虑一个菱形控制流图（CFG）形式的程序，其基本块为 $B_1$（入口）、$B_2$ 和 $B_3$（菱形的两边）以及 $B_4$（汇合点和出口）。假设所有变量都是标量临时变量，所有表达式和赋值没有副作用，并且控制谓词仅影响控制流。使用活跃变量分析的标准定义：如果从一个程序点存在一条路径，在该路径上一个变量被使用，且在使用之前该变量未被重定义，则该变量在该程序点是活跃的。使用针对基本块的、广为人知的后向数据流方程进行活跃变量分析：对于每个基本块 $B$，$LiveOut[B]$ 是 $B$ 的所有后继的 $LiveIn$ 的并集，并且 $LiveIn[B] = Use[B] \\cup (LiveOut[B] \\setminus Def[B])$，其中 $Use[B]$ 包含在 $B$ 块内任何重定义之前被使用的变量，而 $Def[B]$ 包含在 $B$ 块内被定义的变量。在一个基本块内部，对于一条语句 $s$ 及其 $Def[s]$ 和 $Use[s]$，其单条语句的传递函数为 $LiveIn[s] = Use[s] \\cup (LiveOut[s] \\setminus Def[s])$，其中 $LiveOut[s]$ 等于程序顺序中下一条语句的 $LiveIn$，或者对于最后一条语句，等于 $LiveOut[B]$。\n\nCFG 和代码如下：\n- 块 $B_1$：\n  - 语句 $1$: $a = 1$\n  - 语句 $2$: $b = \\mathrm{input}()$\n  - 语句 $3$: if $b  0$ then goto $B_2$ else goto $B_3$\n- 块 $B_2$：\n  - 语句 $4$: $c = a + b$\n  - 语句 $5$: $d = c + 2$\n  - 语句 $6$: $e = d$\n  - goto $B_4$\n- 块 $B_3$：\n  - 语句 $8$: $c = a - b$\n  - 语句 $9$: $d = 2$\n  - 语句 $10$: $f = d + b$\n  - goto $B_4$\n- 块 $B_4$：\n  - 语句 $12$: $g = c + b$\n  - 语句 $13$: $h = a + g$\n  - 语句 $14$: return $h$\n\n使用上述定义，计算每个基本块的 $LiveIn$ 和 $LiveOut$ 集合，以及 $B_2$ 和 $B_3$ 内部每条语句的活跃集，并应用迭代死代码消除（DCE）直至达到不动点：如果一个赋值语句所定义的变量在该赋值之后不是活跃的，则该赋值为死代码，而移除死代码可能会导致更多代码变为死代码。确定在此 CFG 上迭代 DCE 直至不动点时，将被消除的赋值语句总数。将最终答案表示为一个没有单位的整数。无需四舍五入。", "solution": "该问题要求我们对给定的控制流图（CFG）进行活跃变量分析，然后应用迭代死代码消除，直至达到不动点。最终目标是确定被消除的赋值语句的总数。这个过程将分三个阶段进行：初始活跃变量分析、迭代死代码消除和最终移除语句的计数。\n\n首先，我们根据初始程序代码为每个基本块建立 `Use` 和 `Def` 集合。集合 $Use[B]$ 包含在块 $B$ 中先于定义而被使用的变量。集合 $Def[B]$ 包含在块 $B$ 中被定义（即被赋值）的变量。\n\n- **块 $B_1$**:\n  - $s_1: a = 1$\n  - $s_2: b = \\mathrm{input}()$\n  - $s_3: \\text{if } b  0 \\ldots$\n  $Use[B_1] = \\emptyset$。函数 $\\mathrm{input}()$ 是一个源，而不是对程序变量的使用。变量 $b$ 在语句 $s_3$ 中被使用，但这发生在其于 $s_2$ 中被定义之后。\n  $Def[B_1] = \\{a, b\\}$。\n\n- **块 $B_2$**:\n  - $s_4: c = a + b$\n  - $s_5: d = c + 2$\n  - $s_6: e = d$\n  $Use[B_2] = \\{a, b\\}$。变量 $c$ 和 $d$ 在块内被使用，但在它们各自的定义之后。\n  $Def[B_2] = \\{c, d, e\\}$。\n\n- **块 $B_3$**:\n  - $s_8: c = a - b$\n  - $s_9: d = 2$\n  - $s_{10}: f = d + b$\n  $Use[B_3] = \\{a, b\\}$。变量 $d$ 被使用，但在其定义之后。\n  $Def[B_3] = \\{c, d, f\\}$。\n\n- **块 $B_4$**:\n  - $s_{12}: g = c + b$\n  - $s_{13}: h = a + g$\n  - $s_{14}: \\text{return } h$\n  语句 `return h` 构成了对 $h$ 的使用。\n  $Use[B_4] = \\{c, b, a, h\\}$。$g$ 的内部使用不会出现在 $Use[B_4]$ 中，因为它首先被定义。\n  一个更精确的块级 Use 计算是：$Use(s_{14})=\\{h\\}$, $LiveIn(s_{14})=\\{h\\}$。$Use(s_{13})=\\{a,g\\}$, $LiveIn(s_{13})=\\{a,g\\}$。$Use(s_{12})=\\{c,b\\}$, $LiveIn(s_{12})=\\{c,b,a\\}$。因此，$Use[B_4]$（块中先于定义被使用的变量）是 $\\{a, b, c, h\\}$。等一下，`return h` 发生在 $h$ 的定义之后。所以，先于定义被使用的变量是 $\\{c, b, a\\}$。\n  让我们纠正这一点。$h$ 在 $s_{13}$ 中定义，在 $s_{14}$ 中使用。对于整个块来说，$h$ 不是在定义之前被使用的。因此，$Use[B_4] = \\{a, b, c\\}$。\n  $Def[B_4] = \\{g, h\\}$。\n\n**阶段 1：初始活跃变量分析**\n\n我们使用后向数据流分析，其方程为：\n$LiveOut[B] = \\bigcup_{S \\in Succ(B)} LiveIn[S]$\n$LiveIn[B] = Use[B] \\cup (LiveOut[B] \\setminus Def[B])$\n\n后继关系为：$Succ(B_1) = \\{B_2, B_3\\}$, $Succ(B_2) = \\{B_4\\}$, $Succ(B_3) = \\{B_4\\}$, $Succ(B_4) = \\emptyset$。我们将所有活跃集初始化为 $\\emptyset$。\n\n**迭代 1：**\n- $LiveOut[B_4] = \\emptyset$。\n- $LiveIn[B_4] = Use[B_4] \\cup (LiveOut[B_4] \\setminus Def[B_4]) = \\{a, b, c\\} \\cup (\\emptyset \\setminus \\{g, h\\}) = \\{a, b, c\\}$。\n- $LiveOut[B_3] = LiveIn[B_4] = \\{a, b, c\\}$。\n- $LiveIn[B_3] = Use[B_3] \\cup (LiveOut[B_3] \\setminus Def[B_3]) = \\{a, b\\} \\cup (\\{a, b, c\\} \\setminus \\{c, d, f\\}) = \\{a, b\\} \\cup \\{a, b\\} = \\{a, b\\}$。\n- $LiveOut[B_2] = LiveIn[B_4] = \\{a, b, c\\}$。\n- $LiveIn[B_2] = Use[B_2] \\cup (LiveOut[B_2] \\setminus Def[B_2]) = \\{a, b\\} \\cup (\\{a, b, c\\} \\setminus \\{c, d, e\\}) = \\{a, b\\} \\cup \\{a, b\\} = \\{a, b\\}$。\n- $LiveOut[B_1] = LiveIn[B_2] \\cup LiveIn[B_3] = \\{a, b\\} \\cup \\{a, b\\} = \\{a, b\\}$。\n- $LiveIn[B_1] = Use[B_1] \\cup (LiveOut[B_1] \\setminus Def[B_1]) = \\emptyset \\cup (\\{a, b\\} \\setminus \\{a, b\\}) = \\emptyset$。\n\n**迭代 2：**\n- $LiveOut[B_4]$ 未变。$LiveIn[B_4]$ 未变。\n- $LiveOut[B_3]$ 和 $LiveOut[B_2]$ 未变，因为它们依赖于 $LiveIn[B_4]$。\n- $LiveIn[B_3]$ 和 $LiveIn[B_2]$ 的计算结果相同，因为它们的输入未变。\n- $LiveOut[B_1]$ 未变，因为它依赖于 $LiveIn[B_2]$ 和 $LiveIn[B_3]$。\n- $LiveIn[B_1]$ 未变。\n达到不动点。\n\n各块的初始活跃集为：\n- $LiveIn[B_1] = \\emptyset$, $LiveOut[B_1] = \\{a, b\\}$\n- $LiveIn[B_2] = \\{a, b\\}$, $LiveOut[B_2] = \\{a, b, c\\}$\n- $LiveIn[B_3] = \\{a, b\\}$, $LiveOut[B_3] = \\{a, b, c\\}$\n- $LiveIn[B_4] = \\{a, b, c\\}$, $LiveOut[B_4] = \\emptyset$\n\n按照要求，我们计算 $B_2$ 和 $B_3$ 的每条语句的活跃集。\n对于一条语句 $s$，$LiveIn[s] = Use[s] \\cup (LiveOut[s] \\setminus Def[s])$。如果 $x \\notin LiveOut[s]$，则赋值语句 $x = \\dots$ 是死代码。\n\n**分析 $B_2$**:\n- $s_6: e = d$。$LiveOut[s_6] = LiveOut[B_2] = \\{a, b, c\\}$。$Def[s_6] = \\{e\\}$。变量 $e \\notin LiveOut[s_6]$。因此，$s_6$ 是一条死赋值语句。\n- $LiveIn[s_6] = Use[s_6] \\cup (LiveOut[s_6] \\setminus Def[s_6]) = \\{d\\} \\cup (\\{a, b, c\\} \\setminus \\{e\\}) = \\{a, b, c, d\\}$。\n- $s_5: d = c + 2$。$LiveOut[s_5] = LiveIn[s_6] = \\{a, b, c, d\\}$。$Def[s_5] = \\{d\\}$。变量 $d \\in LiveOut[s_5]$。因此，$s_5$ 是活跃的。\n- $LiveIn[s_5] = Use[s_5] \\cup (LiveOut[s_5] \\setminus Def[s_5]) = \\{c\\} \\cup (\\{a, b, c, d\\} \\setminus \\{d\\}) = \\{a, b, c\\}$。\n- $s_4: c = a + b$。$LiveOut[s_4] = LiveIn[s_5] = \\{a, b, c\\}$。$Def[s_4] = \\{c\\}$。变量 $c \\in LiveOut[s_4]$。因此，$s_4$ 是活跃的。\n- $LiveIn[s_4] = Use[s_4] \\cup (LiveOut[s_4] \\setminus Def[s_4]) = \\{a, b\\} \\cup (\\{a, b, c\\} \\setminus \\{c\\}) = \\{a, b\\}$，与 $LiveIn[B_2]$ 一致。\n\n**分析 $B_3$**:\n- $s_{10}: f = d + b$。$LiveOut[s_{10}] = LiveOut[B_3] = \\{a, b, c\\}$。$Def[s_{10}] = \\{f\\}$。变量 $f \\notin LiveOut[s_{10}]$。因此，$s_{10}$ 是一条死赋值语句。\n- $LiveIn[s_{10}] = Use[s_{10}] \\cup (LiveOut[s_{10}] \\setminus Def[s_{10}]) = \\{d, b\\} \\cup (\\{a, b, c\\} \\setminus \\{f\\}) = \\{a, b, c, d\\}$。\n- $s_9: d = 2$。$LiveOut[s_9] = LiveIn[s_{10}] = \\{a, b, c, d\\}$。$Def[s_9] = \\{d\\}$。变量 $d \\in LiveOut[s_9]$。因此，$s_9$ 是活跃的。\n- $LiveIn[s_9] = Use[s_9] \\cup (LiveOut[s_9] \\setminus Def[s_9]) = \\emptyset \\cup (\\{a, b, c, d\\} \\setminus \\{d\\}) = \\{a, b, c\\}$。\n- $s_8: c = a - b$。$LiveOut[s_8] = LiveIn[s_9] = \\{a, b, c\\}$。$Def[s_8] = \\{c\\}$。变量 $c \\in LiveOut[s_8]$。因此，$s_8$ 是活跃的。\n- $LiveIn[s_8] = Use[s_8] \\cup (LiveOut[s_8] \\setminus Def[s_8]) = \\{a, b\\} \\cup (\\{a, b, c\\} \\setminus \\{c\\}) = \\{a, b\\}$，与 $LiveIn[B_3]$ 一致。\n\n**阶段 2：迭代死代码消除 (DCE)**\n\n**DCE 迭代 1：**\n根据初始分析，有两条赋值语句是死代码：\n1. 在 $B_2$ 中: $s_6: e = d$\n2. 在 $B_3$ 中: $s_{10}: f = d + b$\n我们消除这两条赋值语句。已消除的赋值语句数量为 $2$。\n\n代码现在被修改了。我们必须重新运行分析。\n修改后块的新的 $Use/Def$ 集合：\n- $B_2$ 现在只包含 $s_4$ 和 $s_5$。$Use[B_2] = \\{a, b\\}$, $Def[B_2] = \\{c, d\\}$。\n- $B_3$ 现在只包含 $s_8$ 和 $s_9$。$Use[B_3] = \\{a, b\\}$, $Def[B_3] = \\{c, d\\}$。\n\n在修改后的图上进行活跃性分析，得到相同的块级 $LiveIn/LiveOut$ 集合。然而，由于块 $B_2$ 和 $B_3$ 的结构已改变，每条语句的活跃性会发生变化。\n\n**DCE 迭代 2：**\n我们分析修改后的块 $B_2$ 和 $B_3$。\n\n**分析修改后的 $B_2$**:\n- $s_5: d = c + 2$。这现在是最后一条语句。$LiveOut[s_5] = LiveOut[B_2] = \\{a, b, c\\}$。$Def[s_5] = \\{d\\}$。变量 $d \\notin LiveOut[s_5]$。$d$ 的使用是在现已被删除的语句 $s_6$ 中。因此，$s_5$ 现在是死代码。\n\n**分析修改后的 $B_3$**:\n- $s_9: d = 2$。这现在是最后一条语句。$LiveOut[s_9] = LiveOut[B_3] = \\{a, b, c\\}$。$Def[s_9] = \\{d\\}$。变量 $d \\notin LiveOut[s_9]$。$d$ 的使用是在现已被删除的语句 $s_{10}$ 中。因此，$s_9$ 现在是死代码。\n\n我们消除这两条额外的赋值语句。已消除的赋值语句总数现在是 $2 + 2 = 4$。\n\n代码再次被修改。\n- $B_2$ 现在只包含 $s_4: c = a + b$。\n- $B_3$ 现在只包含 $s_8: c = a - b$。\n\n**DCE 迭代 3 (不动点检查)：**\n我们分析剩余的代码。\n- 在 $B_2$ 中，最后一条语句现在是 $s_4: c = a + b$。$LiveOut[s_4] = LiveOut[B_2] = \\{a, b, c\\}$。变量 $c \\in LiveOut[s_4]$ 因为它在 $B_4$ 中被使用。所以，$s_4$ 是活跃的。\n- 在 $B_3$ 中，最后一条语句现在是 $s_8: c = a - b$。$LiveOut[s_8] = LiveOut[B_3] = \\{a, b, c\\}$。变量 $c \\in LiveOut[s_8]$ 因为它在 $B_4$ 中被使用。所以，$s_8$ 是活跃的。\n- 其他块中的其他语句未受影响，对它们的分析表明它们都是活跃的，因为它们定义的变量在程序流的后续部分被使用。例如，$s_{13}$ 中定义的 $h$ 被 return 语句使用，而 $s_{12}$ 中定义的 $g$ 在 $s_{13}$ 中被使用。$B_1$ 中 $a$ 和 $b$ 的定义在 $B_2$、$B_3$ 和 $B_4$ 中被使用。\n\n没有更多的赋值可以被消除。算法已达到不动点。\n\n**阶段 3：最终计数**\n在所有迭代中被消除的赋值语句是：\n1. $s_6: e = d$\n2. $s_{10}: f = d + b$\n3. $s_5: d = c + 2$\n4. $s_9: d = 2$\n\n被消除的赋值语句总数为 $4$。", "answer": "$$\\boxed{4}$$", "id": "3636266"}, {"introduction": "虽然针对简单变量的死代码消除很简单，但指针由于*别名*（即不同指针可能指向同一内存位置的可能性）的存在而引入了巨大的复杂性。本练习探讨了编译器必须如何推理“必须别名”和“可能别名”这两种情况，以安全地消除对内存的写操作。它突出了在处理包含大量指针的代码时，为保证正确性所必须遵循的保守原则。[@problem_id:3636231]", "problem": "考虑一个单线程程序，它在一个严格顺序内存模型中运行，没有外部函数调用，没有输入或输出效应，也没有 volatile 内存。假设指针 $p$ 和 $q$ 的范围是一个非逃逸、非别名的内存区域，除非别名分析事实另有规定。以下线性代码在一个基本块内执行：\n1. $S_1$: $*p \\leftarrow 0$\n2. $S_2$: $*q \\leftarrow 1$\n3. $S_3$: $t \\leftarrow *p$\n4. return $t$\n假设无用存储消除 (Dead Store Elimination, DSE) 从第一性原理定义如下：如果沿着所有可行的执行路径，并且对于所有与可用静态信息一致的内存消歧情况，值 $v$ 在后续对同一位置 $L$ 的存储发生之前，或者在程序到达一个可能使 $v$ 外部可见的观察点之前，从未被读取，那么对内存位置 $L$ 写入值 $v$ 的存储是无用的。该程序是单线程的，除了从 $p$ 和 $q$ 指向的内存区域进行读取之外，没有其他观察点。\n\n定义 $L(p)$ 为在一次给定执行中由 $p$ 指向的内存位置，类似地定义 $L(q)$。考虑两种别名分析结果：\n- 必别名 (must-alias): 在通过该块的所有执行中，$L(p) = L(q)$；\n- 可别名 (may-alias): 存在 $L(p) = L(q)$ 的执行，也存在 $L(p) \\neq L(q)$ 的执行。\n\n仅基于上述基本定义和事实（顺序加载-存储语义以及必别名和可别名的定义），对于给定的代码，在每种别名假设下，关于哪些存储是无用的，以下哪个陈述是正确的？\n\nA. 在 $p$ 和 $q$ 必别名的情况下，$S_1$ 是无用的而 $S_2$ 不是；在可别名的情况下，$S_1$ 和 $S_2$ 都不能被证明是无用的。\n\nB. 在 $p$ 和 $q$ 必别名的情况下，$S_2$ 是无用的而 $S_1$ 不是；在可别名的情况下，$S_1$ 是无用的。\n\nC. 在 $p$ 和 $q$ 必别名的情况下，$S_1$ 和 $S_2$ 都是无用的；在可别名的情况下，$S_2$ 是无用的。\n\nD. 在 $p$ 和 $q$ 可别名的情况下，$S_2$ 不是无用的但 $S_1$ 是；在必别名的情况下，$S_1$ 和 $S_2$ 都不是无用的。", "solution": "首先将验证问题陈述的科学合理性、清晰性和完整性。\n\n### 步骤1：提取已知条件\n问题提供了以下信息：\n- **程序模型**：一个在严格顺序内存模型中运行的单线程程序。\n- **范围**：无外部函数调用，无输入或输出效应，无 volatile 内存。\n- **指针**：$p$ 和 $q$ 的范围是一个非逃逸、非别名的内存区域，除非别名另有规定。\n- **代码**：一个包含以下线性代码的基本块：\n  1. `$S_1$: $*p \\leftarrow 0$`\n  2. `$S_2$: $*q \\leftarrow 1$`\n  3. `$S_3$: $t \\leftarrow *p$`\n  4. `return $t$`\n- **无用存储消除 (DSE) 的定义**：如果沿着所有可行的执行路径，并且对于所有与可用静态信息一致的内存消歧情况，值 $v$ 在后续对同一位置 $L$ 的存储发生之前，或者在程序到达一个可能使 $v$ 外部可见的观察点之前，从未被读取，那么对内存位置 $L$ 写入值 $v$ 的存储是无用的。\n- **观察点**：唯一的观察点是从 $p$ 和 $q$ 指向的内存区域进行读取。语句 $S_3$ 中的读取 $*p$ 是此代码片段中唯一的此类点。\n- **符号**：$L(p)$ 是 $p$ 指向的内存位置，$L(q)$ 是 $q$ 指向的内存位置。\n- **别名分析结果**：\n  - **必别名 (must-alias)**：在通过该块的所有执行中，$L(p) = L(q)$。\n  - **可别名 (may-alias)**：存在 $L(p) = L(q)$ 的执行，也存在 $L(p) \\neq L(q)$ 的执行。\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题设置在计算机科学的一个子领域——编译器理论的形式化范畴内。别名分析、无用存储消除、内存模型和基本块等概念都是标准的、定义明确的主题。所提供的定义虽然特定于本问题，但与基本原则一致。该问题在科学上是合理的。\n2.  **良构性**：该问题是良构的。它提供了所有必要的定义和一个具体的代码示例。问题要求*仅*基于所提供的信息进行逻辑推导，这会导出一个唯一的、可推导的解。\n3.  **客观性**：该问题使用了计算机科学中常见的精确、形式化的语言。术语（例如，DSE、必别名、可别名）都得到了明确定义，没有主观解释的余地。\n4.  **缺陷检查**：该问题没有违反任何无效性标准。这是一个在编译器分析领域中格式良好、自包含的问题。\n\n### 步骤3：结论与行动\n问题有效。现在将给出完整的推导和解答。\n\n### 正确答案的推导\n\n核心任务是确定在 `must-alias` 和 `may-alias` 假设下，存储 `$S_1$` 或 `$S_2$` 中哪一个是无用的。如果一个存储的值在被读取之前，在静态分析信息所允许的所有执行可能性中，都保证被覆盖，则该存储是无用的。\n\n**情况1：`$p$` 和 `$q$` 必别名 (`must-alias`)**\n\n在 `must-alias` 假设下，编译器确定地知道对于每次执行都有 `$L(p) = L(q)$`。设这个单一内存位置为 `$L_{common}$`。代码序列可以分析如下：\n1.  `$S_1$: $*L_{common} \\leftarrow 0$`\n2.  `$S_2$: $*L_{common} \\leftarrow 1$`\n3.  `$S_3$: $t \\leftarrow *L_{common}$`\n\n让我们分析每个存储操作：\n- **对 `$S_1$`（存储 `$0$`）的分析：** 值 `$0$` 被写入 `$L_{common}$`。紧接着，语句 `$S_2$` 将值 `$1$` 写入*完全相同的位置* `$L_{common}$`。这次覆盖发生在从 `$L_{common}$` 进行任何读取之前。随后在 `$S_3$` 的读取将检索到值 `$1$`，而不是 `$0$`。根据定义，由于来自 `$S_1$` 的值在后续对相同位置的存储发生之前从未被读取，因此 **`$S_1$` 处的存储是无用的**。\n- **对 `$S_2$`（存储 `$1$`）的分析：** 值 `$1$` 被写入 `$L_{common}$`。涉及此位置的下一个操作是 `$S_3$` 处的读取 `$t \\leftarrow *L_{common}$`。此读取检索由 `$S_2$` 存储的值 `$1$`。由于 `$S_2$` 存储的值被读取，因此 **`$S_2$` 处的存储不是无用的**。\n\n**`must-alias` 的结论：** `$S_1$` 是无用的，`$S_2$` 不是无用的。\n\n**情况2：`$p$` 和 `$q$` 可别名 (`may-alias`)**\n\n在 `may-alias` 假设下，编译器必须持保守态度。DSE 的定义要求条件“对于所有与可用静态信息一致的内存消歧情况”都成立。这意味着一个存储只有在以下两种可能场景中都是无用的时，才能被声明为无用：\n- 场景 (i)：`$L(p) = L(q)$`（别名情况）\n- 场景 (ii)：`$L(p) \\neq L(q)$`（非别名情况）\n\n让我们在这种保守要求下分析每个存储操作：\n- **对 `$S_1$`（向 `$L(p)$` 存储 `$0$`）的分析：**\n  - 在场景 (i) (`$L(p) = L(q)$`) 中：正如在 `must-alias` 情况下确定的，`$S_1$` 是无用的，因为它的值被 `$S_2$` 覆盖了。\n  - 在场景 (ii) (`$L(p) \\neq L(q)$`) 中：`$S_2$` 处的存储 (`$*q \\leftarrow 1$`) 写入了与 `$L(p)$` 不同的位置。因此，由 `$S_1$` 存储在 `$L(p)$` 中的值 `$0$` 没有被覆盖。它随后被 `$S_3$` (`$t \\leftarrow *p$`) 读取。在这种场景下，`$S_1$` 不是无用的。\n  - **对 `$S_1$` 的结论：** 由于 `$S_1$` 并非在所有可能的消歧情况中都是无用的（它在场景 (ii) 中是活的），因此保守的静态分析无法证明它是无用的。因此，**`$S_1$` 不能被证明是无用的**。\n\n- **对 `$S_2$`（向 `$L(q)$` 存储 `$1$`）的分析：**\n  - 在场景 (i) (`$L(p) = L(q)$`) 中：正如在 `must-alias` 情况下确定的，`$S_2$` 不是无用的，因为它的值被 `$S_3$` 读取。\n  - 在场景 (ii) (`$L(p) \\neq L(q)$`) 中：值 `$1$` 被存入 `$L(q)$`。没有后续指令从 `$L(q)$` 读取；唯一的读取是从 `$L(p)$`。因此，由 `$S_2$` 存储的值从未被读取。在这种场景下，`$S_2$` 是无用的。\n  - **对 `$S_2$` 的结论：** 由于 `$S_2$` 并非在所有可能的消歧情况中都是无用的（它在场景 (i) 中是活的），因此保守的静态分析无法证明它是无用的。因此，**`$S_2$` 不能被证明是无用的**。\n\n**`may-alias` 的结论：** `$S_1$` 和 `$S_2$` 都不能被证明是无用的。\n\n**结论总结：**\n- 在 `must-alias` 下：`$S_1$` 是无用的，`$S_2$` 不是无用的。\n- 在 `may-alias` 下：`$S_1$` 和 `$S_2$` 都不能被证明是无用的。\n\n### 逐项分析\n\n- **A. 在 $p$ 和 $q$ 必别名的情况下，$S_1$ 是无用的而 $S_2$ 不是；在可别名的情况下，$S_1$ 和 $S_2$ 都不能被证明是无用的。**\n  - 该陈述与我们对 `must-alias` 和 `may-alias` 两种情况的推导结果完全匹配。\n  - **结论：** 正确。\n\n- **B. 在 $p$ 和 $q$ 必别名的情况下，$S_2$ 是无用的而 $S_1$ 不是；在可别名的情况下，$S_1$ 是无用的。**\n  - `must-alias` 部分不正确；它颠倒了 `$S_1$` 和 `$S_2$` 的角色。\n  - `may-alias` 部分不正确；`$S_1$` 不能被证明是无用的。\n  - **结论：** 错误。\n\n- **C. 在 $p$ 和 $q$ 必别名的情况下，$S_1$ 和 $S_2$ 都是无用的；在可别名的情况下，$S_2$ 是无用的。**\n  - `must-alias` 部分不正确；`$S_2$` 不是无用的。\n  - `may-alias` 部分不正确；`$S_2$` 不能被证明是无用的。\n  - **结论：** 错误。\n\n- **D. 在 $p$ 和 $q$ 可别名的情况下，$S_2$ 不是无用的但 $S_1$ 是；在必别名的情况下，$S_1$ 和 $S_2$ 都不是无用的。**\n  - `may-alias` 部分不正确；`$S_1$` 不能被证明是无用的。\n  - `must-alias` 部分不正确；`$S_1$` 是无用的。\n  - **结论：** 错误。", "answer": "$$\\boxed{A}$$", "id": "3636231"}]}