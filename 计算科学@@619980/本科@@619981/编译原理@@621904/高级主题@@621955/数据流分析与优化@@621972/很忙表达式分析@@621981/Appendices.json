{"hands_on_practices": [{"introduction": "这个练习将帮助你巩固对“非常忙碌表达式”核心定义的理解。我们将通过分析一个包含条件分支的程序片段，来实际体验“必须在所有路径上”这一要求是如何运作的。理解为何当存在一条路径可以*绕过*某个表达式的计算时，该表达式就不再是“非常忙碌”的，这是掌握此项分析技术的关键第一步 ([@problem_id:3682374])。", "problem": "考虑以下带有显式 goto 和合并点的直线代码段。设目标表达式为 $e \\equiv x + y$。假设 $b$ 是一个布尔值，其求值没有副作用，也不会修改 $x$ 或 $y$。同时假设，除了明确显示的语句外，任何语句都没有隐藏的副作用。\n```\nS_1: if (b) goto S_2 else goto S_4\nS_2: t - x + y\nS_3: goto S_5\nS_4: goto S_5\nS_5: y - y + 1\nS_6: u - x + y\n```\n控制转移如下：从 $S_1$ 到 $S_2$ 或 $S_4$；从 $S_2$ 到 $S_3$；从 $S_3$ 和 $S_4$ 到 $S_5$ 处的合并点；然后到 $S_6$。\n\n定义（基本依据）：如果在从程序点 $p$ 开始的每条路径上，表达式 $e$ 的求值都发生在对 $e$ 的任何操作数进行赋值之前，则称表达式 $e$ 在程序点 $p$ 是非常忙碌的（very busy）。这是数据流分析中的一个后向必须（backward must）属性。\n\n问题：根据上述定义，在下列哪个程序点，$x+y$ 是非常忙碌的？\n\nA. 紧接在 $S_1$ 之前\n\nB. 紧接在 $S_2$ 之前\n\nC. 紧接在 $S_4$ 之前\n\nD. 紧接在 $S_5$ 之前\n\nE. 紧接在 $S_6$ 之前\n\n选择所有适用项。你的理由应依据所述定义和所描述的控制流，并特别注意使用 goto 跳过 $S_2$ 处计算的路径以及路径在 $S_5$ 处重新汇合的合并点。", "solution": "问题要求确定在哪些程序点，表达式 $e \\equiv x + y$ 是“非常忙碌”的。\n\n首先，我们根据所提供的信息将问题形式化。\n该程序由从 $S_1$ 到 $S_6$ 的一系列语句组成。控制流图（CFG）如下：\n- 一个初始块进入 $S_1$。\n- 从 $S_1$ 有两个分支：到 $S_2$ 或 $S_4$。\n- 从 $S_2$，控制流向 $S_3$。\n- 从 $S_4$，控制流向 $S_5$。\n- 从 $S_3$，控制流向 $S_5$。因此，$S_5$ 是来自 $S_3$ 和 $S_4$ 路径的合并点。\n- 从 $S_5$，控制流向 $S_6$。\n- 从 $S_6$ 开始，代码段结束。\n\n语句如下：\n- $S_1$: `if (b) goto S_2 else goto S_4`\n- $S_2$: `t - x + y`\n- $S_3$: `goto S_5`\n- $S_4$: `goto S_5`\n- $S_5$: `y - y + 1`\n- $S_6$: `u - x + y`\n\n目标表达式为 $e \\equiv x + y$。$e$ 的操作数是 $x$ 和 $y$。\n- 表达式 $e$ 在语句 $S_2$ 和 $S_6$ 中被求值。\n- $e$ 的一个操作数在语句 $S_5$ 中被修改（对 $e$ 来说是一个“杀死”），其中 $y$ 被赋予一个新值。\n\n所提供的定义是：“如果在从程序点 $p$ 开始的每条路径上，表达式 $e$ 的求值都发生在对 $e$ 的任何操作数进行赋值之前，则称表达式 $e$ 在程序点 $p$ 是非常忙碌的。”\n\n我们现在将分析选项中指定的每个程序点。\n\nA. **紧接在 $S_1$ 之前**\n设紧接在 $S_1$ 之前的程序点为 $p_1$。从 $p_1$ 开始，有两条可能的路径穿过该代码段：\n1. 路径 1: $S_1 \\rightarrow S_2 \\rightarrow S_3 \\rightarrow S_5 \\rightarrow S_6 \\rightarrow \\dots$\n2. 路径 2: $S_1 \\rightarrow S_4 \\rightarrow S_5 \\rightarrow S_6 \\rightarrow \\dots$\n\n定义要求该条件对*每条*路径都成立。我们来检查路径 2。\n- 在这条路径上，第一个涉及 $e$ 或其操作数的语句是 $S_5$，它包含赋值 `y - y + 1`。这是对 $e$ 的一个操作数的赋值。\n- 这条路径上对 $e$ 的第一次求值发生在后面的语句 $S_6$ 中。\n- 因此，在路径 2 上，对 $e$ 的操作数的赋值发生在对 $e$ 的求值*之前*。\n由于从 $p_1$ 开始的一条路径不满足条件，表达式 $x+y$ 在紧接在 $S_1$ 之前不是非常忙碌的。\n**结论：不正确**\n\nB. **紧接在 $S_2$ 之前**\n设紧接在 $S_2$ 之前的程序点为 $p_2$。从 $p_2$ 开始只有一条路径：\n1. 路径 1: $S_2 \\rightarrow S_3 \\rightarrow S_5 \\rightarrow S_6 \\rightarrow \\dots$\n\n我们来检查这条路径。\n- 这条路径上的第一个语句就是 $S_2$。\n- $S_2$ 包含求值 `t - x + y`。\n- 在这条路径上，此求值之前没有对 $x$ 或 $y$ 的赋值（第一个此类赋值在 $S_5$ 中，位于 $S_2$ 之后）。\n- 因此，沿着这条路径，对 $e$ 的求值发生在对 $e$ 的任何操作数进行赋值之前。\n因为这是从 $p_2$ 开始的唯一路径，所以该条件对“每条路径”都成立。因此，表达式 $x+y$ 在紧接在 $S_2$ 之前是非常忙碌的。\n**结论：正确**\n\nC. **紧接在 $S_4$ 之前**\n设紧接在 $S_4$ 之前的程序点为 $p_4$。从 $p_4$ 开始只有一条路径：\n1. 路径 1: $S_4 \\rightarrow S_5 \\rightarrow S_6 \\rightarrow \\dots$\n\n我们来检查这条路径。\n- 这条路径上的第一个语句是 $S_4$，它是一个 `goto` 语句，不影响 $e$ 或其操作数。\n- 下一个语句是 $S_5$，它包含赋值 `y - y + 1`。这是对 $e$ 的一个操作数的赋值。\n- 这条路径上对 $e$ 的第一次求值发生在后面的语句 $S_6$ 中。\n- 因此，在这条路径上，对 $e$ 的操作数的赋值发生在对 $e$ 的求值*之前*。\n条件不成立。因此，表达式 $x+y$ 在紧接在 $S_4$ 之前不是非常忙碌的。\n**结论：不正确**\n\nD. **紧接在 $S_5$ 之前**\n设紧接在 $S_5$ 之前的程序点为 $p_5$。从 $p_5$ 开始只有一条路径：\n1. 路径 1: $S_5 \\rightarrow S_6 \\rightarrow \\dots$\n\n我们来检查这条路径。\n- 第一个语句是 $S_5$，它包含赋值 `y - y + 1`。这是对 $e$ 的一个操作数的赋值。\n- 这条路径上对 $e$ 的第一次求值发生在下一个语句 $S_6$ 中。\n- 因此，在这条路径上，对 $e$ 的操作数的赋值发生在对 $e$ 的求值*之前*。\n条件不成立。因此，表达式 $x+y$ 在紧接在 $S_5$ 之前不是非常忙碌的。\n**结论：不正确**\n\nE. **紧接在 $S_6$ 之前**\n设紧接在 $S_6$ 之前的程序点为 $p_6$。从 $p_6$ 开始只有一条路径：\n1. 路径 1: $S_6 \\rightarrow \\dots$\n\n我们来检查这条路径。\n- 这条路径上的第一个语句就是 $S_6$。\n- $S_6$ 包含求值 `u - x + y`。\n- 在此求值之前（或在 $S_6$ 内部，在求值之前）没有对 $x$ 或 $y$ 的赋值。\n- 因此，沿着这条路径，对 $e$ 的求值发生在对 $e$ 的任何（可能的后续）操作数进行赋值之前。\n因为这是从 $p_6$ 开始的唯一路径，所以该条件对“每条路径”都成立。因此，表达式 $x+y$ 在紧接在 $S_6$ 之前是非常忙碌的。\n**结论：正确**\n\n分析总结：\n- A: 不是非常忙碌。\n- B: 非常忙碌。\n- C: 不是非常忙碌。\n- D: 不是非常忙碌。\n- E: 非常忙碌。\n\n正确选项是 B 和 E。", "answer": "$$\\boxed{BE}$$", "id": "3682374"}, {"introduction": "在上一个练习的基础上，本题将深入探讨“杀死”（kill）操作的关键作用。我们将研究这样一个场景：目标表达式的一个操作数仅在条件语句的一个分支上被修改。通过这个例子 ([@problem_id:3682423])，你将清楚地看到，即使只是在一个分支上存在*潜在*的重定义，也足以破坏表达式的“非常忙碌”属性。", "problem": "考虑以下带有条件语句的直线型代码片段，该片段以控制流图（CFG）的形式给出，并具有赋值和条件语句的常规语义。所有变量均为标量整数，条件是一个布尔值。该片段有两次对同一二元算术表达式 $x+y$ 的计算，中间由一次对 $x$ 的递增操作隔开：\n- 第 $1$ 行：`t_1 := x + y`\n- 第 $2$ 行：`if c then x := x + 1 else skip`\n- 第 $3$ 行：`t_2 := x + y`\n假设 $c$ 是任意布尔值，且没有关于其值的额外信息（也就是说，不知道 $c$ 是总是为真还是总是为假）。关注表达式 $x+y$ 和以下两个程序点：\n- $P_{\\text{entry}}$：紧邻第 $1$ 行之前的程序点。\n- $P_{1}$：紧邻第 $1$ 行之后、第 $2$ 行之前的程序点。\n使用“非常活跃表达式”(very busy expression) 的标准定义：如果从程序点 $p$ 开始并通往程序出口（或所考虑区域的末尾）的每一条路径上，在表达式 $e$ 中任何变量被赋值之前，都有对 $e$ 的后续求值，则表达式 $e$ 在程序点 $p$ 是非常活跃的。同时使用标准的“杀死”(kill) 概念：语句 `v := ...` 会杀死任何包含变量 $v$ 的表达式，即从该语句开始，该表达式先前预期的值若不重新计算就不能再被重用。\n\n仅根据这些定义和上述代码片段，以下哪些陈述是正确的？选择所有适用项。\n\nA. 赋值语句 `x := x + 1` 在 $P_{1}$ 点为非常活跃分析的目的杀死了表达式 $x+y$；因此 $x+y$ 在 $P_{1}$ 点不是非常活跃的，但由于第 $1$ 行即将进行的求值，$x+y$ 在 $P_{\\text{entry}}$ 点是非常活跃的。\n\nB. 赋值语句 `x := x + 1` 不会杀死 $x+y$，因为该表达式在第 $3$ 行被重新计算；因此 $x+y$ 在 $P_{1}$ 和 $P_{\\text{entry}}$ 两点都是非常活跃的。\n\nC. 只有当 $x$ 和 $y$ 在下一次求值前都被赋值时，赋值语句才会杀死 $x+y$；由于在第 $2$ 行只有 $x$ 被赋值，所以 $x+y$ 在 $P_{1}$ 点仍然是非常活跃的。\n\nD. 仅当已知 $c$ 绝对为假时，表达式 $x+y$ 才会在 $P_{1}$ 点非常活跃；否则，在真分支上可能执行的 `x := x + 1` 会阻止 $x+y$ 在 $P_{1}$ 点成为非常活跃的。", "solution": "问题陈述经过严格验证，认定有效。这是编译器理论中数据流分析标准框架下的一个适定问题。“非常活跃表达式”和“杀死”概念的定义是标准且无歧义的。所给的代码片段简单且足以进行所要求的分析。\n\n我们需要确定表达式$x+y$在两个程序点：$P_{\\text{entry}}$（第 $1$ 行之前）和 $P_1$（第 $1$ 行之后，第 $2$ 行之前）的“非常活跃”状态。\n\n非常活跃表达式的定义如下：如果从程序点$p$开始并通往出口的**每一条路径**上，在表达式$e$中出现的任何变量被**赋值之前**，都有对$e$的后续求值，则表达式$e$在程序点$p$是非常活跃的。这是一个后向数据流分析问题。“每一条路径”的要求意味着在控制流汇合（或在后向分析中是分叉）点，其汇流算子是交集。\n\n让我们从代码片段的末尾开始反向分析$x+y$的“非常活跃”状态。\n\n1.  **在紧邻第 $3$ 行之后的点（此片段的出口）：** 表达式$x+y$不是非常活跃的，因为没有后续路径，因此也没有后续求值。\n\n2.  **在紧邻第 $3$ 行之前的点：** 向前只有一条路径，即执行第 $3$ 行：`t_2 := x + y`。这是对$x+y$的一次求值，并且它发生在对$x$或$y$的任何其他赋值之前。因此，$x+y$在紧邻第 $3$ 行之前的点是非常活跃的。这个点是第 $2$ 行条件语句之后的汇合点。\n\n3.  **在程序点 $P_1$（第 $2$ 行之前）：** 为了确定$x+y$在$P_1$点是否非常活跃，我们必须检查从$P_1$开始的所有路径。由于条件语句 `if c`，存在两条路径：\n    *   **路径 A（‘真’分支）：** 执行语句 `x := x + 1`。这是对变量$x$的赋值，而$x$出现在表达式$x+y$中。根据定义，对表达式中任何变量的赋值都会阻止该表达式在该路径上被预期。问题陈述指出，语句 `v := ...` 会*杀死*任何包含$v$的表达式。因此，赋值 `x := x + 1` 杀死了对$x+y$的预期。尽管$x+y$稍后在第 $3$ 行被求值，但这次求值发生在变量$x$被重新定义*之后*。所以，沿着这条路径，不满足非常活跃的条件。\n    *   **路径 B（‘假’分支）：** 执行 `skip` 语句。这不会修改任何变量。路径继续到第 $3$ 行，在这里$x+y$被求值。沿着这条路径，$x+y$在其任何组成变量被重新赋值之前被求值。所以，沿着这条路径，满足非常活跃的条件。\n\n    “非常活跃”的定义要求条件在**每一条路径**上都成立。由于路径 A 不满足该条件，所以表达式$x+y$在程序点$P_1$**不是非常活跃的**。问题明确指出$c$是任意的，所以我们必须假设两条路径都是可能的。\n\n4.  **在程序点 $P_{\\text{entry}}$（第 $1$ 行之前）：** 从$P_{\\text{entry}}$开始，只有一条向前的路径，直接通向第 $1$ 行：`t_1 := x + y`。这是对表达式$x+y$的一次求值。这次求值是路径上的第一个事件，因此它必然发生在对$x$或$y$的任何重新定义之前。因此，表达式$x+y$在程序点$P_{\\text{entry}}$**是非常活跃的**。\n\n分析总结：\n*   在$P_{\\text{entry}}$，$x+y$是非常活跃的。\n*   在$P_1$，$x+y$不是非常活跃的。\n\n现在我们来评估每个选项。\n\n**A. 赋值语句 `x := x + 1` 在 $P_{1}$ 点为非常活跃分析的目的杀死了表达式 $x+y$；因此 $x+y$ 在 $P_{1}$ 点不是非常活跃的，但由于第 $1$ 行即将进行的求值，$x+y$ 在 $P_{\\text{entry}}$ 点是非常活跃的。**\n这个陈述与我们的分析完全一致。真分支上的赋值 `x := x + 1` 确实杀死了对$x+y$的预期。因为“非常活跃”属性必须在所有路径上都成立，而它在这条路径上不成立，所以$x+y$在$P_1$点不是非常活跃的。该陈述还正确地得出结论，即由于第 $1$ 行的立即求值，$x+y$在$P_{\\text{entry}}$点是非常活跃的。\n**结论：正确**\n\n**B. 赋值语句 `x := x + 1` 不会杀死 $x+y$，因为该表达式在第 $3$ 行被重新计算；因此 $x+y$ 在 $P_{1}$ 和 $P_{\\text{entry}}$ 两点都是非常活跃的。**\n这个陈述误解了数据流分析中“杀死”的概念。对变量$v$的赋值会杀死任何包含$v$的表达式。表达式后来被重新计算这一事实并不能否定杀死操作。在一条路径上的杀死操作意味着赋值前表达式的值不能被使用，这破坏了该路径的“非常活跃”条件。如上所述，$x+y$在$P_1$点非常活跃的结论是错误的。\n**结论：错误**\n\n**C. 只有当 $x$ 和 $y$ 在下一次求值前都被赋值时，赋值语句才会杀死 $x+y$；由于在第 $2$ 行只有 $x$ 被赋值，所以 $x+y$ 在 $P_{1}$ 点仍然是非常活跃的。**\n这个陈述提出了一个错误的“杀死”定义。如果表达式中的**任何**一个变量被重新定义，该表达式就会被杀死。修改$x$足以杀死$x+y$。这个前提是错误的，因此$x+y$在$P_1$点仍然非常活跃的结论也是错误的。\n**结论：错误**\n\n**D. 仅当已知 $c$ 绝对为假时，表达式 $x+y$ 才会在 $P_{1}$ 点非常活跃；否则，在真分支上可能执行的 `x := x + 1` 会阻止 $x+y$ 在 $P_{1}$ 点成为非常活跃的。**\n这个陈述提供了一个正确而细致的解释。如果已知$c$为假，控制流将绕过赋值语句 `x := x + 1`，从而有效地将代码简化为一条直线，其中$x+y$在第 $3$ 行被求值，而中间没有对$x$或$y$进行任何修改。在这种假设情况下，$x+y$在$P_1$点将是非常活跃的。陈述的第二部分，“否则，在真分支上可能执行的 `x := x + 1` 会阻止$x+y$成为非常活跃的”，正确地指出了在问题给定的场景中（$c$是任意的），为什么$x+y$不是非常活跃的。这是“每一条路径”规则在起作用的精确描述。\n**结论：正确**", "answer": "$$\\boxed{AD}$$", "id": "3682423"}, {"introduction": "现在，是时候将所有理论知识整合起来，从头到尾完成一次完整的“非常忙碌表达式”数据流分析了。这个练习 ([@problem_id:3682393]) 将引导你为每个基本块计算其 $GEN$ 集和 $KILL$ 集，然后应用迭代数据流方程，最终求解出所有块的 $IN$ 集和 $OUT$ 集。这完整地模拟了编译器在进行此项优化时所遵循的精确过程。", "problem": "给定以下三地址程序，其中所有变量均为标量，布尔谓词 $p$ 没有副作用，常量是不可变的，并且临时变量 $t_{1}$ 和 $t_{2}$ 从不作为相关表达式中的操作数出现：\n- $1:$ `t_1 := a * b`\n- $2:$ `if p then goto L_1 else goto L_2`\n- $L_{1}:$ `a := a + 1; goto L_3`\n- $L_{2}:$ `b := b + 1; goto L_3`\n- $L_{3}:$ `t_2 := a * b`\n\n考虑一个控制流图，其基本块 $B_{1}$ 包含第 $1$–$2$ 行，$B_{2}$ 包含第 $L_{1}$ 行，$B_{3}$ 包含第 $L_{2}$ 行，以及 $B_{4}$ 包含第 $L_{3}$ 行。后继节点为 $\\text{succ}(B_{1})=\\{B_{2},B_{3}\\}$，$\\text{succ}(B_{2})=\\{B_{4}\\}$，$\\text{succ}(B_{3})=\\{B_{4}\\}$，以及 $\\text{succ}(B_{4})=\\emptyset$。\n\n对非常忙碌表达式 (very busy expressions) 执行经典的后向 must 数据流分析，具体如下：\n- 表达式全集 $E$ 是程序中出现的所有无副作用二元算術表达式的集合：$E=\\{a \\times b,\\ a+1,\\ b+1\\}$。\n- 后继节点上的交汇 (meet) 操作为集合交集 $\\cap$。\n- 每个基本块 $B$ 的传递函数为 $IN[B] = B_{GEN} \\cup \\bigl(OUT[B] - B_{KILL}\\bigr)$。\n- 根据约定，对于程序出口处的非常忙碌表达式，$OUT[B_{4}] = \\varnothing$。\n\n仅使用基本块、控制流图、非常忙碌表达式的集合 $B_{GEN}$ 和 $B_{KILL}$ 的基本定义，以及上述交汇和传递规范，计算每个基本块 $B \\in \\{B_{1},B_{2},B_{3},B_{4}\\}$ 的所有四个集合 $B_{GEN}$、$B_{KILL}$、$IN$ 和 $OUT$。\n\n最后，令标量 $N$ 由下式给出：\n$$\nN \\;=\\; |IN[B_{1}]| \\;+\\; |OUT[B_{1}]| \\;+\\; |IN[B_{2}]| \\;+\\; |OUT[B_{2}]| \\;+\\; |IN[B_{3}]| \\;+\\; |OUT[B_{3}]| \\;+\\; |IN[B_{4}]| \\;+\\; |OUT[B_{4}]|\\,.\n$$\n将 $N$ 的值报告为单个实数。无需四舍五入。", "solution": "我们的目标是为给定的控制流图计算每个基本块的$GEN$、$KILL$、$IN$和$OUT$集合，然后计算这些集合基数的总和$N$。\n\n**1. 计算 $GEN$ 和 $KILL$ 集合**\n\n对于非常忙碌表达式分析：\n- $GEN[B]$：在块$B$中求值且其操作数在求值前未被修改的表达式集合。\n- $KILL[B]$：其操作数在块$B$中被赋值的表达式集合。\n\n表达式全集为 $E = \\{a \\times b, a+1, b+1\\}$。\n\n*   **基本块 $B_1$ (`t_1 := a * b`, `if p ...`)**:\n    *   表达式 $a \\times b$ 在此块中被求值。\n    *   没有对 $a$ 或 $b$ 的赋值。\n    *   $GEN[B_1] = \\{a \\times b\\}$\n    *   $KILL[B_1] = \\emptyset$\n\n*   **基本块 $B_2$ (`a := a + 1`)**:\n    *   表达式 $a+1$ 在赋值语句的右侧被求值。\n    *   变量 $a$ 被重新定义。这会杀死任何包含 $a$ 的表达式。\n    *   $GEN[B_2] = \\{a+1\\}$\n    *   $KILL[B_2] = \\{a \\times b, a+1\\}$\n\n*   **基本块 $B_3$ (`b := b + 1`)**:\n    *   表达式 $b+1$ 在赋值语句的右侧被求值。\n    *   变量 $b$ 被重新定义。这会杀死任何包含 $b$ 的表达式。\n    *   $GEN[B_3] = \\{b+1\\}$\n    *   $KILL[B_3] = \\{a \\times b, b+1\\}$\n\n*   **基本块 $B_4$ (`t_2 := a * b`)**:\n    *   表达式 $a \\times b$ 在此块中被求值。\n    *   没有对 $a$ 或 $b$ 的赋值。\n    *   $GEN[B_4] = \\{a \\times b\\}$\n    *   $KILL[B_4] = \\emptyset$\n\n**2. 求解数据流方程**\n\n我们使用后向分析的数据流方程，从出口块$B_4$开始逆向求解。\n- $OUT[B] = \\bigcap_{S \\in \\text{succ}(B)} IN[S]$\n- $IN[B] = GEN[B] \\cup (OUT[B] - KILL[B])$\n- 边界条件: $OUT[B_4] = \\emptyset$\n\n*   **分析 $B_4$**:\n    *   $OUT[B_4] = \\emptyset$ (给定)\n    *   $IN[B_4] = GEN[B_4] \\cup (OUT[B_4] - KILL[B_4]) = \\{a \\times b\\} \\cup (\\emptyset - \\emptyset) = \\{a \\times b\\}$\n\n*   **分析 $B_2$**:\n    *   $B_2$ 的唯一后继是 $B_4$。\n    *   $OUT[B_2] = IN[B_4] = \\{a \\times b\\}$\n    *   $IN[B_2] = GEN[B_2] \\cup (OUT[B_2] - KILL[B_2]) = \\{a+1\\} \\cup (\\{a \\times b\\} - \\{a \\times b, a+1\\}) = \\{a+1\\} \\cup \\emptyset = \\{a+1\\}$\n\n*   **分析 $B_3$**:\n    *   $B_3$ 的唯一后继是 $B_4$。\n    *   $OUT[B_3] = IN[B_4] = \\{a \\times b\\}$\n    *   $IN[B_3] = GEN[B_3] \\cup (OUT[B_3] - KILL[B_3]) = \\{b+1\\} \\cup (\\{a \\times b\\} - \\{a \\times b, b+1\\}) = \\{b+1\\} \\cup \\emptyset = \\{b+1\\}$\n\n*   **分析 $B_1$**:\n    *   $B_1$ 的后继是 $B_2$ 和 $B_3$。\n    *   $OUT[B_1] = IN[B_2] \\cap IN[B_3] = \\{a+1\\} \\cap \\{b+1\\} = \\emptyset$\n    *   $IN[B_1] = GEN[B_1] \\cup (OUT[B_1] - KILL[B_1]) = \\{a \\times b\\} \\cup (\\emptyset - \\emptyset) = \\{a \\times b\\}$\n\n**3. 总结并计算 $N$**\n\n我们现在汇总所有集合的基数（元素个数）：\n*   $|IN[B_1]| = |\\{a \\times b\\}| = 1$\n*   $|OUT[B_1]| = |\\emptyset| = 0$\n*   $|IN[B_2]| = |\\{a+1\\}| = 1$\n*   $|OUT[B_2]| = |\\{a \\times b\\}| = 1$\n*   $|IN[B_3]| = |\\{b+1\\}| = 1$\n*   $|OUT[B_3]| = |\\{a \\times b\\}| = 1$\n*   $|IN[B_4]| = |\\{a \\times b\\}| = 1$\n*   $|OUT[B_4]| = |\\emptyset| = 0$\n\n最后，计算 $N$：\n$N = 1 + 0 + 1 + 1 + 1 + 1 + 1 + 0 = 6$", "answer": "$$\n\\boxed{6}\n$$", "id": "3682393"}]}