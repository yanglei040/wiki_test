{"hands_on_practices": [{"introduction": "编译器如何判断两个表达式是等价的？这是公共子表达式消除的核心问题。本练习将通过值编号 (Value Numbering) 来探讨这一问题，这是一种为表达式分配唯一标识符的技术。我们将看到，通过应用不同的代数规范化策略（如交换律和结合律），编译器识别等价表达式的能力会发生变化，这直接影响了优化的效果 [@problem_id:3644049]。", "problem": "考虑一个三地址中间表示（IR）程序中的一个直线代码片段，该程序带有一个控制流图（CFG）。其中，变量 $a$、$b$、$c$ 和 $d$ 是在过程入口处定义的参数，并且永远不会被重新赋值。CFG 由四个基本块 $B_0$、$B_1$、$B_2$ 和 $B_3$ 组成，连接方式如下：$B_0$ 是唯一的入口，并分支到 $B_1$ 和 $B_2$；$B_1$ 和 $B_2$ 都汇入 $B_3$。所有计算都是纯函数计算，且运算符 $+$ 是整数加法。IR 语句如下：\n\n在 $B_1$ 中：\n- $e_1 \\leftarrow a + (b + c)$\n- $e_2 \\leftarrow (a + b) + c$\n\n在 $B_2$ 中：\n- $e_3 \\leftarrow (b + c) + a$\n- $e_4 \\leftarrow (c + a) + b$\n\n在 $B_3$ 中：\n- $e_5 \\leftarrow a + (c + b)$\n- $e_6 \\leftarrow (a + c) + b$\n- $e_7 \\leftarrow a + (b + d)$\n- $e_8 \\leftarrow (a + b) + c$\n- $e_9 \\leftarrow a + (b + c)$\n\n假设全局公共子表达式消除（GCSE）是通过在整个 CFG 上使用全局值编号来执行的，并且语言语义允许根据所选策略对加法进行代数规范化。你将比较值编号使用的两种规范化策略：\n\n- 策略 $\\mathcal{C}$：仅独立地对每个二元 $+$ 节点的交换律进行规范化（对于任意 $x$ 和 $y$，$x + y$ 被规范地表示为一个排序后的操作数对），而不使用跨不同 $+$ 节点的结合律。\n- 策略 $\\mathcal{AC}$：通过首先将嵌套的加法展平为一个操作数的多重集，然后对该多重集进行排序，来同时对 $+$ 的结合律和交换律进行规范化。\n\n从以下基本定义出发：(i) 一个等价类将在所选规范化和程序语义下可证明相等的 IR 表达式组合在一起，以及 (ii) 全局值编号必须为同一等价类的所有成员分配相同的值编号，无论它们位于哪个基本块中。请对出现在 $B_1$、$B_2$ 和 $B_3$ 中的所有九个右侧表达式的集合 $E = \\{a + (b + c), (a + b) + c, (b + c) + a, (c + a) + b, a + (c + b), (a + c) + b, a + (b + d), (a + b) + c, a + (b + c)\\}$，确定：\n\n- $K_{\\mathcal{C}}$：在策略 $\\mathcal{C}$ 下不同等价类的数量，\n- $K_{\\mathcal{AC}}$：在策略 $\\mathcal{AC}$ 下不同等价类的数量。\n\n计算单一量 $K_{\\mathcal{C}} - K_{\\mathcal{AC}}$。请以精确整数形式提供最终答案。无需四舍五入。", "solution": "该问题提法清晰，科学上基于编译器理论的原理，并提供了一套完整且一致的已知条件。因此，该问题被认为是有效的，可以推导出解决方案。\n\n问题要求我们确定在两种不同的规范化策略 $\\mathcal{C}$ 和 $\\mathcal{AC}$ 下，给定九个表达式集合的不同等价类的数量。一个等价类将可证明等价的表达式组合在一起。这类类的数量是在给定策略下，表达式可以被归约成的唯一规范形式的数量。这九个右侧表达式的集合，记为 $E$，是：\n$E = \\{a + (b + c), (a + b) + c, (b + c) + a, (c + a) + b, a + (c + b), (a + c) + b, a + (b + d), (a + b) + c, a + (b + c)\\}$。\n等价类的数量取决于 $E$ 中唯一表达式的集合。设 $S$ 为 $E$ 中语法上不同的表达式集合。\n$S = \\{a + (b + c), (a + b) + c, (b + c) + a, (c + a) + b, a + (c + b), (a + c) + b, a + (b + d)\\}$。\n我们将根据每种策略对集合 $S$ 进行划分。\n\n**在策略 $\\mathcal{C}$ 下的分析（仅考虑交换律）**\n\n策略 $\\mathcal{C}$ 允许基于表达式语法树中每个节点的加法运算符 $+$ 的交换律进行规范化，但不考虑结合律。这意味着对于任何子表达式 $x+y$，其规范形式通过对其操作数进行排序来确定。我们假设变量按字母顺序排序，即 $a  b  c  d$。一个涉及子表达式的表达式，例如 $a + (b+c)$，被视为原子 $a$ 和由 $(b+c)$ 所代表的值之间的运算。\n\n让我们为 $S$ 中的每个唯一表达式推导其规范形式：\n1.  对于 $a + (b + c)$：内部子表达式是 $b+c$。其规范形式是 $b+c$。外部表达式是 $a$ 加上内部表达式的结果。因此，整个表达式的规范形式是 $a + (b+c)$。\n\n2.  对于 $(a + b) + c$：内部子表达式是 $a+b$。其规范形式是 $a+b$。外部表达式将 $c$ 加到这个结果上。规范形式是 $(a+b) + c$。这种结构形式与前一个不同。\n\n3.  对于 $(b + c) + a$：内部子表达式 $b+c$ 是规范的。外部表达式是（$b+c$ 的结果）$+ a$。应用交换律，我们对操作数排序得到 $a + (b+c)$，这与第一个表达式的规范形式相同。\n\n4.  对于 $(c + a) + b$：内部子表达式 $c+a$ 规范化为 $a+c$。完整表达式的规范形式是 $(a+c)+b$。这是一个新的结构形式。\n\n5.  对于 $a + (c + b)$：内部子表达式 $c+b$ 规范化为 $b+c$。完整表达式的规范形式是 $a + (b+c)$，与第一个表达式相同。\n\n6.  对于 $(a + c) + b$：内部子表达式 $a+c$ 是规范的。完整表达式的规范形式是 $(a+c)+b$，与第四个表达式相同。\n\n7.  对于 $a + (b + d)$：内部子表达式 $b+d$ 是规范的。完整表达式的规范形式是 $a+(b+d)$。这是一个新的形式，因为它涉及到变量 $d$。\n\n我们在策略 $\\mathcal{C}$ 下识别出以下不同的规范形式：\n- 第 1 类：$a + (b+c)$，代表 $\\{a + (b + c), (b + c) + a, a + (c + b)\\}$。\n- 第 2 类：$(a+b)+c$，代表 $\\{(a + b) + c\\}$。\n- 第 3 类：$(a+c)+b$，代表 $\\{(c + a) + b, (a + c) + b\\}$。\n- 第 4 类：$a+(b+d)$，代表 $\\{a + (b + d)\\}$。\n\n共有 $4$ 个不同的等价类。因此，$K_{\\mathcal{C}} = 4$。\n\n**在策略 $\\mathcal{AC}$ 下的分析（结合律和交换律）**\n\n策略 $\\mathcal{AC}$ 将嵌套的加法视为单个 $n$ 元运算。其规范形式通过将表达式展平为其基本变量操作数的多重集，然后对此多重集进行排序来推导。\n\n让我们将此策略应用于 $S$ 中的表达式：\n1.  对于 $a + (b + c)$：展平后得到多重集 $\\{a, b, c\\}$。排序后的操作数列表为 $(a, b, c)$。\n2.  对于 $(a + b) + c$：展平后得到 $\\{a, b, c\\}$。排序后的列表为 $(a, b, c)$。\n3.  对于 $(b + c) + a$：展平后得到 $\\{b, c, a\\}$。排序后的列表为 $(a, b, c)$。\n4.  对于 $(c + a) + b$：展平后得到 $\\{c, a, b\\}$。排序后的列表为 $(a, b, c)$。\n5.  对于 $a + (c + b)$：展平后得到 $\\{a, c, b\\}$。排序后的列表为 $(a, b, c)$。\n6.  对于 $(a + c) + b$：展平后得到 $\\{a, c, b\\}$。排序后的列表为 $(a, b, c)$。\n\n上述所有六个表达式在策略 $\\mathcal{AC}$ 下是等价的，因为它们都归约到由排序后的操作数列表 $(a, b, c)$ 表示的规范形式。\n\n7.  对于 $a + (b + d)$：展平后得到多重集 $\\{a, b, d\\}$。排序后的操作数列表为 $(a, b, d)$。这是一个不同的规范形式，因为它包含 $d$ 而不是 $c$。\n\n在策略 $\\mathcal{AC}$ 下，我们识别出两种不同的规范形式：\n- 第 1 类：由 $(a, b, c)$ 表示，包含 $S$ 中除 $a+(b+d)$ 之外的所有表达式。\n- 第 2 类：由 $(a, b, d)$ 表示，对应于表达式 $a+(b+d)$。\n\n共有 $2$ 个不同的等价类。因此，$K_{\\mathcal{AC}} = 2$。\n\n**最终计算**\n\n问题要求计算 $K_{\\mathcal{C}} - K_{\\mathcal{AC}}$ 的值。根据我们的分析：\n$K_{\\mathcal{C}} = 4$\n$K_{\\mathcal{AC}} = 2$\n\n最终结果是 $K_{\\mathcal{C}} - K_{\\mathcal{AC}} = 4 - 2 = 2$。", "answer": "$$\\boxed{2}$$", "id": "3644049"}, {"introduction": "理论上的优化在应用于真实世界的程序时，会遇到内存访问和函数调用等复杂情况。本练习 [@problem_id:3643954] 探讨了全局公共子表达式消除面临的一个关键挑战：别名 (aliasing) 问题，即不同的指针可能指向同一块内存。你将学习编译器为何必须采取保守策略，以及精确的程序分析（如 mod/ref 分析）对于安全地进行优化是多么重要。", "problem": "考虑以下直线代码片段，该语言支持一等函数和指针。变量 $a$ 和 $b$ 表示存储在内存中（例如，全局变量或堆上分配的变量）的整数，而 $t_1$ 和 $t_2$ 是临时变量。函数调用 `callee` 可能有内存副作用。\n\n代码：\n- $S_1: t_1 \\leftarrow a \\times b$\n- $C: \\text{call callee}(q)$\n- $S_2: t_2 \\leftarrow a \\times b$\n- $\\text{use}(t_1)$; $\\text{use}(t_2)$\n\n假设：\n- 指针 $q$ 可能指向也可能不指向 $a$ 或 $b$ 的存储位置；这取决于别名信息。\n- 函数 `callee` 可能写入从 $q$ 可达的内存，并且只有在明确指定的情况下，才可能有其他不涉及 $q$ 的副作用。\n- 不会发生未定义行为。\n- 目标是执行全局公共子表达式消除（GCSE），使用标准的数据流概念：如果沿着所有通向程序点 $p$ 的路径，表达式 $e$ 都已被计算且未失效，则该表达式在 $p$ 点是可用的；如果一个语句不修改表达式 $e$ 的任何操作数或这些操作数所依赖的任何内存位置，则该语句相对于 $e$ 是透明的。\n\n您可以使用的基本定义：\n- 如果一个程序点的语句可能修改 $x$ 或 $y$ 的值（包括通过内存效应），则表达式 $x \\times y$ 在该点被杀死（killed）。\n- 在缺乏精确别名信息的情况下，对于一个可能通过指针写入内存的调用，如果该指针可能与操作数的存储位置产生别名，则必须保守地假设该调用会修改该操作数。\n- 静态单赋值（SSA）形式重命名了标量变量的定义，但其本身不捕获内存别名或副作用；内存效应需要单独建模（例如，内存 SSA 或 mod/ref 分析）。\n\n在此代码中，根据所指示的别名假设，选择所有关于表达式 $a \\times b$ 的安全 GCSE 放置的正确陈述。\n\nA. 在一个保守的 may-alias 模型下，其中 $q$ 可能指向 $a$ 或 $b$ 的存储位置，调用 $C$ 对 $a \\times b$ 不是透明的，因此 $a \\times b$ 在 $C$ 之后是不可用的。消除 $S_2$ 或将其移到 $C$ 之上是不安全的。\n\nB. 如果过程间 mod/ref 和别名分析证明 `callee` 既不写入 $a$ 或 $b$ 的存储位置（也没有其他影响它们的副作用），那么调用 $C$ 对 $a \\times b$ 是透明的，GCSE 可以在 $C$ 之前计算一次 $a \\times b$，并在 $C$ 之后重用该值。\n\nC. 即使当 $q$ 可能与 $a$ 或 $b$ 产生别名时，在 $S_1$ 处将调用前 $a \\times b$ 的值保存到临时变量中并在 $C$ 之后重用它也总是安全的，因为临时变量不受别名影响。\n\nD. 将代码转换为静态单赋值（SSA）形式并应用全局值编号（GVN）足以在没有别名信息的情况下，在 $C$ 之后重用调用前 $a \\times b$ 的值。\n\nE. 当别名未知时，一种安全的 GCSE 保守近似方法是将 `callee` 视为相对于 $a$ 和 $b$ 是只读的，从而允许通过跨越 $C$ 重用 $S_1$ 的值来消除 $S_2$。", "solution": "在给出解决方案之前，对问题陈述进行验证。\n\n### 步骤1：提取已知信息\n\n所提供的信息包括：\n- **代码片段：**\n  - $S_1: t_1 \\leftarrow a \\times b$\n  - $C: \\text{call callee}(q)$\n  - $S_2: t_2 \\leftarrow a \\times b$\n  - $\\text{use}(t_1)$; $\\text{use}(t_2)$\n- **变量和函数描述：**\n  - $a, b$：存储在内存中的整数（例如，全局变量或堆分配变量）。\n  - $t_1, t_2$：临时变量。\n  - $q$：一个指针。\n  - `callee`：一个可能有内存副作用的函数。\n- **假设和定义：**\n  - **别名信息：** 指针 $q$ 可能指向也可能不指向 $a$ 或 $b$ 的存储位置。\n  - **函数副作用：** 函数 `callee` 可能写入从 $q$ 可达的内存。\n  - **行为：** 不会发生未定义行为。\n  - **优化目标：** 对表达式 $a \\times b$ 执行全局公共子表达式消除（GCSE）。\n  - **可用性：** 如果沿着所有通向程序点 $p$ 的路径，表达式 $e$ 都已被计算且未失效，则该表达式在 $p$ 点是可用的。\n  - **透明性：** 如果一个语句不修改表达式 $e$ 的任何操作数或这些操作数所依赖的任何内存位置，则该语句相对于 $e$ 是透明的。\n  - **杀死表达式：** 如果一个语句可能修改 $x$ 或 $y$ 的值（包括通过内存效应），则表达式 $x \\times y$ 被杀死。\n  - **保守假设：** 在缺乏精确别名信息的情况下，对于一个可能通过指针写入内存的调用，如果该指针可能与操作数的存储位置产生别名，则必须假设该调用会修改该操作数。\n  - **SSA 形式：** 静态单赋值（SSA）形式重命名了标量变量的定义，但其本身不捕获内存别名或副作用。\n\n### 步骤2：使用提取的已知信息进行验证\n\n评估问题陈述的有效性。\n- **科学依据：** 该问题牢固地植根于编译器理论的原理，特别是用于程序优化的数据流分析。全局公共子表达式消除（GCSE）、别名、mod/ref分析和静态单赋值（SSA）等概念在计算机科学中是标准且成熟的。该问题在科学上是合理的。\n- **良构性（Well-Posed）：** 该问题是良构的。它提出了一个特定的代码片段和一个明确的目标：评估在各种别名分析假设下，关于应用 GCSE 的几个陈述的正确性。所提供的定义足以对每个陈述进行推理并得出明确的结论。\n- **客观性：** 该问题以精确、客观、技术性的语言陈述，没有主观性或歧义。\n\n该问题没有表现出任何列举的缺陷（例如，事实不健全、不可形式化、不完整等）。这个设置是用于教授在存在指针和函数调用的情况下优化挑战的经典示例。\n\n### 步骤3：结论与行动\n\n问题陈述是**有效的**。将推导解决方案。\n\n### 解决方案推导\n\n核心问题是公共子表达式 $a \\times b$ 是否可以被消除。第二次计算 $S_2: t_2 \\leftarrow a \\times b$ 可以被替换为 $t_2 \\leftarrow t_1$ 当且仅当表达式 $a \\times b$ 在 $S_2$ 之前是*可用*的。根据提供的定义，一个表达式是可用的，如果它已经被计算，并且自计算以来其操作数没有被修改。\n\n在这里，$a \\times b$ 在 $S_1$ 处被计算。唯一的中间语句是函数调用 $C: \\text{call callee}(q)$。因此，优化的安全性完全取决于对 `callee` 的调用是否会修改操作数 $a$ 或 $b$ 的值。由于 $a$ 和 $b$ 存储在内存中，这是一个关于内存副作用和别名的问题。\n\n- 表达式 $a \\times b$ 在语句 $S_1$ 处*生成*。\n- 为了在 $S_2$ 之前可用，表达式不能被 $C$ 处的调用*杀死*。\n- 如果 `callee` 可能修改 $a$ 的内存位置或 $b$ 的内存位置，则表达式 $a \\times b$ 在 $C$ 处的调用中被杀死。\n\n在此框架下，对每个选项进行评估。\n\n**A. 在一个保守的 may-alias 模型下，其中 $q$ 可能指向 $a$ 或 $b$ 的存储位置，调用 $C$ 对 $a \\times b$ 不是透明的，因此 $a \\times b$ 在 $C$ 之后是不可用的。消除 $S_2$ 或将其移到 $C$ 之上是不安全的。**\n\n这个陈述描述了编译器优化的标准保守方法。在没有相反的明确信息（即“无别名”证明）的情况下，“may-alias”（可能别名）情况要求编译器为了安全而假设最坏情况。\n- **假设：** `callee` 可能通过指针 $q$ 写入内存，且 $q$ 可能与 $a$ 或 $b$ 产生别名。\n- **推论：** 必须假设在 $C$ 处的调用可能会修改 $a$ 和/或 $b$ 的值。\n- **后果：** 如果操作数 $a$ 或 $b$ 被修改，表达式 $a \\times b$ 就被该调用杀死。因此，该调用相对于 $a \\times b$ 是不透明的。因此，在 $S_1$ 处计算的值不保证等同于在 $S_2$ 处将要计算的值。表达式在 $C$ 之后是不可用的。\n- **安全性：** 消除 $S_2$ 并使用 $t_1$ 将是不安全的优化，因为它可能导致使用一个过时的值，从而改变程序的语义。该陈述是对保守数据流分析原则的正确应用。\n\n**对 A 的 verdict：正确**\n\n**B. 如果过程间 mod/ref 和别名分析证明 `callee` 既不写入 $a$ 或 $b$ 的存储位置（也没有其他影响它们的副作用），那么调用 $C$ 对 $a \\times b$ 是透明的，GCSE 可以在 $C$ 之前计算一次 $a \\times b$，并在 $C$ 之后重用该值。**\n\n这个陈述描述了一个使用更精确、更强大的程序分析的场景。\n- **假设：** 一个可靠的分析已经证明 `callee` 不会修改 $a$ 和 $b$ 的内存位置。这正是“mod/ref”（修改/引用）分析旨在确定的内容。\n- **推论：** 在 $C$ 处的调用不修改表达式 $a \\times b$ 的操作数。\n- **后果：** 该调用相对于表达式 $a \\times b$ 是透明的。表达式不会被该调用杀死。\n- **安全性：** 由于在 $S_1$ 处计算的表达式没有被调用所失效，它在 $S_2$ 点仍然可用。因此，GCSE 是安全的。在 $S_2$ 处的计算是冗余的，可以通过重用 $S_1$ 的结果来消除。这是进行昂贵的过程间分析的主要动机。\n\n**对 B 的 verdict：正确**\n\n**C. 即使当 $q$ 可能与 $a$ 或 $b$ 产生别名时，在 $S_1$ 处将调用前 $a \\times b$ 的值保存到临时变量中并在 $C$ 之后重用它也总是安全的，因为临时变量不受别名影响。**\n\n这个陈述误解了 GCSE 的目标。优化的目的不仅仅是重用一个值，而是在保持程序语义的同时重用*正确*的值。\n- **逻辑：** 该陈述正确地指出临时变量 $t_1$ 很可能不与 $q$ 产生别名。因此，*在* $t_1$ 中的值不会被调用直接改变。\n- **缺陷：** 然而，GCSE 旨在用 $S_1$ 的结果替换计算 $t_2 \\leftarrow a \\times b$（在调用之后，这将使用可能已修改的 $a$ 和 $b$ 的值）。如果 `callee` 将 $a$ 修改为 $a'$，那么 $t_2$ 的正确值应该是 $a' \\times b$。而 $t_1$ 中的值是 $a \\times b$。将 $t_1$ 重用于 $t_2$ 将是语义上不正确的。只有当操作数的值未改变时，这种转换才是安全的，而在所述条件下这是不能保证的。该陈述混淆了临时变量存储的安全性与其所持值的语义有效性。\n\n**对 C 的 verdict：不正确**\n\n**D. 将代码转换为静态单赋值（SSA）形式并应用全局值编号（GVN）足以在没有别名信息的情况下，在 $C$ 之后重用调用前 $a \\times b$ 的值。**\n\n这个陈述夸大了标准 SSA 和 GVN 的能力。\n- **标量的SSA：** 标准 SSA 形式为*标量*变量的每个定义提供唯一的名称。它本身不建模内存。变量 $a$ 和 $b$ 被明确说明在内存中。一个将它们视为标量的朴素 SSA 转换是不可靠的（unsound）。\n- **内存建模：** 为了正确处理内存，必须扩展 SSA（例如，使用内存 SSA）。在这样的模型中，内存的状态像变量一样在程序中传递。在 $C$ 处的调用将被建模为取调用前的内存状态（$Mem_{in}$）并产生一个调用后的内存状态（$Mem_{out}$）。$S_1$ 处的表达式依赖于从 $Mem_{in}$ 加载，而 $S_2$ 处的表达式依赖于从 $Mem_{out}$ 加载。没有别名信息，编译器无法证明从 $Mem_{in}$ 加载 $a$ 等同于从 $Mem_{out}$ 加载 $a$。因此，GVN 将为这两个表达式分配不同的值编号。因此，没有别名分析，标准的 SSA/GVN 是不足够的。\n\n**对 D 的 verdict：不正确**\n\n**E. 当别名未知时，一种安全的 GCSE 保守近似方法是将 `callee` 视为相对于 $a$ 和 $b$ 是只读的，从而允许通过跨越 $C$ 重用 $S_1$ 的值来消除 $S_2$。**\n\n这个陈述错误地定义了“保守近似”。\n- **保守与乐观：** 在优化中，保守近似必须假设最坏情况以保证正确性。对于一个可能有副作用的操作（如调用 `callee`），最坏的情况是它*确实*有副作用，从而使后续计算失效。假设调用是只读的（即，对 $a$ 和 $b$ 没有副作用）是一个*乐观*的假设。\n- **安全性：** 在信息缺乏时做出乐观假设本质上是不安全的。一个这样做地编译器会为任何 `callee` 实际上修改了 $a$ 或 $b$ 的程序生成不正确的代码。正确的保守方法是假设调用杀死了表达式，如选项 A 所述。\n\n**对 E 的 verdict：不正确**\n\n总之，陈述 A 和 B 分别正确描述了在保守分析和精确分析下编译器安全的条件。陈述 C、D 和 E 包含了关于优化安全性、临时变量的语义、SSA 的局限性以及保守近似定义的根本性误解。", "answer": "$$\\boxed{AB}$$", "id": "3643954"}, {"introduction": "有时，即使一个优化机会看起来很明显，程序的控制流结构本身也可能成为阻碍。本练习 [@problem_id:3644037] 聚焦于控制流图中的一个特殊结构——“关键边” (critical edge)。通过分析这个场景，你将理解为什么编译器不能随意地在代码中移动计算，以及如何通过像“边分裂” (edge splitting) 这样的图转换技术，为优化创造安全的插入点，从而最终实现表达式的消除。", "problem": "考虑一个以三地址码形式表示的函数，该函数由一个控制流图（CFG）表示。控制流图（CFG）是一个有向图，其节点是基本块，边代表基本块之间可能的控制转移。如果从入口到节点 $B_y$ 的每一条路径都经过节点 $B_x$，则称节点 $B_x$ 支配节点 $B_y$。如果 $B_p$ 有两个或多个后继，并且 $B_s$ 有两个或多个前驱，则边 $(B_p,B_s)$ 是一条关键边。在静态单赋值（SSA）形式中，每个变量只被赋值一次，并且在交汇点使用 $\\phi$-函数来合并来自不同前驱的值。\n\n给定以下具有基本块和语句的CFG结构，其中 $+$ 表示整数加法，根据源语言语义，该操作可能会引发溢出异常。因此，不允许在最初未执行 $+$ 操作的路径上对其进行推测执行。假设 $a$ 和 $b$ 在唯一的支配性入口块 $B_0$ 中定义，在任何块 $B_1$、$B_2$、$B_3$、$B_5$ 和 $B_4$ 中，$a$ 和 $b$ 都未被重定义，并且 $a$ 和 $b$ 的定义都到达了所有的使用点。除了在此转换中引入 $\\phi$-函数的地方，所有变量都处于SSA形式。\n\nCFG骨架：\n- $B_0$：定义 $a$ 和 $b$，然后跳转到 $B_1$。\n- $B_1$：评估谓词 `cond`，如果为真则跳转到 $B_2$，如果为假则跳转到 $B_3$。\n- $B_2$：计算 $t_1 := a + b$，然后无条件跳转到 $B_4$。\n- $B_3$：不重定义 $a$ 或 $b$，评估谓词 `cond_2`，如果为真则跳转到 $B_4$，如果为假则跳转到 $B_5$。\n- $B_5$：不重定义 $a$ 或 $b$，然后无条件跳转到 $B_4$。\n- $B_4$：计算 $t_2 := a + b$，然后使用 $t_2$。\n\n观察到 $B_4$ 中的 $t_2 := a + b$ 重复了在 $B_2$ 中执行的计算，但该计算结果仅在通过 $B_2$ 的路径上可用。因为 $+$ 操作可能会触发异常，所以你不能将 $a + b$ 移动到它最初未被执行的块中。你的任务是通过合法的插入操作，在不改变程序可观察行为的情况下，使得 $a + b$ 在所有通往 $B_4$ 的路径上都可用，从而在 $B_4$ 处对 $t_2 := a + b$ 启用全局公共子表达式消除（GCSE）。如果在关键边上进行插入，则需要进行边分裂。\n\n在上述约束条件下，以下哪种转换是最小的、能保持语义的变更，并且能够通过一个 $\\phi$-合并值在 $B_4$ 中消除重计算 $t_2 := a + b$？\n\nA. 分裂关键边 $(B_3,B_4)$，方法是在该边上创建一个新块 $S_{34}$。在 $S_{34}$ 中，插入 $t_3 := a + b$ 并跳转到 $B_4$。同时，在 $B_5$ 的末尾（跳转到 $B_4$ 之前）插入 $t_4 := a + b$。在 $B_4$ 中，将 $t_2 := a + b$ 替换为 $t := \\phi(B_2 \\mapsto t_1, S_{34} \\mapsto t_3, B_5 \\mapsto t_4)$ 并使用 $t$。\n\nB. 仅分裂边 $(B_2,B_4)$，方法是在该边上创建一个新块 $S_{24}$，并将 $t_1 := a + b$ 从 $B_2$ 移入 $S_{24}$。保持 $(B_3,B_4)$ 和 $(B_5,B_4)$ 不变。在 $B_4$ 中，将 $t_2 := a + b$ 替换为 $t := \\phi(S_{24} \\mapsto t_1, B_3 \\mapsto \\bot, B_5 \\mapsto \\bot)$ 并使用 $t$，其中 $\\bot$ 表示无可用值。\n\nC. 不分裂任何边，通过在 $B_1$ 的末尾插入 $t_h := a + b$ 将 $a + b$ 从 $B_2$ 提升到 $B_1$。从 $B_2$ 中移除 $t_1 := a + b$，并在 $B_4$ 中用已经计算好的 $t_h$ 替换 $t_2 := a + b$。\n\nD. 同时分裂 $(B_3,B_4)$ 和 $(B_5,B_4)$，方法是在这些边上创建新块 $S_{34}$ 和 $S_{54}$。在 $S_{34}$ 中插入 $t_3 := a + b$，在 $S_{54}$ 中插入 $t_4 := a + b$。同时，将 $t_1 := a + b$ 从 $B_2$ 移入在 $(B_2,B_4)$ 上创建的新分裂块 $S_{24}$ 中。在 $B_4$ 中，将 $t_2 := a + b$ 替换为 $t := \\phi(S_{24} \\mapsto t_1, S_{34} \\mapsto t_3, S_{54} \\mapsto t_4)$ 并使用 $t$。\n\n选择最佳选项。", "solution": "该问题陈述已经过验证且合理。它提出了一个编译器优化理论中的标准问题，涉及在特定约束下的全局公共子表达式消除（GCSE）。\n\n目标是在基本块 $B_4$ 中消除冗余计算 $t_2 := a + b$，方法是确保在从所有前驱路径进入 $B_4$ 时，$a+b$ 的值是可用的。这要求转换既要保持语义，又要最小化。\n\n首先，我们分析控制流图（CFG）的结构以及通往 $B_4$ 的路径。\n基本块及其控制流如下：\n- $B_0 \\to B_1$\n- $B_1 \\to B_2$ (若 $cond$ 为真), $B_1 \\to B_3$ (若 $cond$ 为假)\n- $B_2 \\to B_4$\n- $B_3 \\to B_4$ (若 $cond_2$ 为真), $B_3 \\to B_5$ (若 $cond_2$ 为假)\n- $B_5 \\to B_4$\n$B_4$ 的前驱是 $\\{B_2, B_3, B_5\\}$。计算 $a+b$ 存在于 $B_2$ 中（作为 $t_1$），并在 $B_4$ 中被重计算（作为 $t_2$）。为了消除重计算，必须在所有三条进入 $B_4$ 的路径上都提供 $a+b$ 的值。\n1. 路径 $... \\to B_2 \\to B_4$：表达式 $a+b$ 在 $B_2$ 中计算为 $t_1$。该值可用。\n2. 路径 $... \\to B_3 \\to B_4$：表达式 $a+b$ 未被计算。我们必须在此路径上插入一个计算 $t_3 := a+b$。\n3. 路径 $... \\to B_5 \\to B_4$：表达式 $a+b$ 未被计算。我们必须在此路径上插入一个计算 $t_4 := a+b$。\n\n接下来，我们考虑约束条件。\n- **无推测执行**：$+$ 操作可能触发异常。因此，我们不能将计算 $a+b$ 移动到它最初未被执行的路径上。例如，将 $a+b$ 提升到 $B_1$ 是非法的，因为它会在控制流路径 $B_1 \\to B_3 \\to ...$ 上被推测性地执行，而它最初并不存在于该路径上。这排除了简单的提升操作。\n- **边上的代码放置**：在“边上”插入计算是正确的方法。问题规定，如果 $B_p$ 有两个或多个后继并且 $B_s$ 有两个或多个前驱，则边 $(B_p, B_s)$ 是关键边。在关键边上插入代码需要*边分裂*：在该边上创建一个新的基本块来容纳插入的代码。\n\n让我们识别进入 $B_4$ 的关键边：\n- $B_4$ 的前驱：$\\{B_2, B_3, B_5\\}$。因此，$B_4$ 有3个前驱。\n- $B_2$ 的后继：$\\{B_4\\}$。$B_2$ 有1个后继。边 $(B_2, B_4)$ **不是**关键边。\n- $B_3$ 的后继：$\\{B_4, B_5\\}$。$B_3$ 有2个后继。边 $(B_3, B_4)$ 是**关键边**。\n- $B_5$ 的后继：$\\{B_4\\}$。$B_5$ 有1个后继。边 $(B_5, B_4)$ **不是**关键边。\n\n基于此分析，所需的插入操作如下：\n- 对于从 $B_3$ 到 $B_4$ 的路径：必须在边 $(B_3, B_4)$ 上插入一个计算。由于该边是关键边，必须对其进行分裂。创建一个新块，例如 $S_{34}$。边 $(B_3, B_4)$ 被替换为两条边 $(B_3, S_{34})$ 和 $(S_{34}, B_4)$。计算 $t_3 := a+b$ 被放置在 $S_{34}$ 中。\n- 对于从 $B_5$ 到 $B_4$ 的路径：必须在边 $(B_5, B_4)$ 上插入一个计算。由于该边不是关键边，我们不需要分裂它。计算 $t_4 := a+b$ 可以被放置在块 $B_5$ 的末尾，紧接在跳转到 $B_4$ 之前。\n\n经过这些转换后，表达式 $a+b$ 在所有通往 $B_4$ 的路径上都可用。块 $B_4$ 现在的前驱是 $\\{B_2, S_{34}, B_5\\}$。冗余的计算可以被一个合并这些值的 $\\phi$-函数所取代：\n在 $B_4$ 中：用 $t := \\phi(B_2 \\mapsto t_1, S_{34} \\mapsto t_3, B_5 \\mapsto t_4)$ 替换 $t_2 := a+b$。\n\n这组变更是最小的，因为根据规则必须分裂关键边，并且添加计算以覆盖缺失的路径是使表达式完全可用所必需的。\n\n现在，我们评估给定的选项。\n\n**A. 分裂关键边 $(B_3,B_4)$，方法是在该边上创建一个新块 $S_{34}$。在 $S_{34}$ 中，插入 $t_3 := a + b$ 并跳转到 $B_4$。同时，在 $B_5$ 的末尾（跳转到 $B_4$ 之前）插入 $t_4 := a + b$。在 $B_4$ 中，将 $t_2 := a + b$ 替换为 $t := \\phi(B_2 \\mapsto t_1, S_{34} \\mapsto t_3, B_5 \\mapsto t_4)$ 并使用 $t$。**\n该选项与我们推导出的最小且正确的转换完全匹配。它正确地识别了关键边 $(B_3, B_4)$，对其进行分裂，并在新块 $S_{34}$ 中插入计算。它通过将计算插入到 $B_5$ 中来正确处理来自 $B_5$ 的非关键路径。最后，它使用现在有效的前驱在 $B_4$ 中构造了正确的 $\\phi$-函数。\n**结论：正确。**\n\n**B. 仅分裂边 $(B_2,B_4)$，方法是在该边上创建一个新块 $S_{24}$，并将 $t_1 := a + b$ 从 $B_2$ 移入 $S_{24}$。保持 $(B_3,B_4)$ 和 $(B_5,B_4)$ 不变。在 $B_4$ 中，将 $t_2 := a + b$ 替换为 $t := \\phi(S_{24} \\mapsto t_1, B_3 \\mapsto \\bot, B_5 \\mapsto \\bot)$ 并使用 $t$，其中 $\\bot$ 表示无可用值。**\n这个转换是有缺陷的。它没有使表达式 $a+b$ 在从 $B_3$ 和 $B_5$ 而来的路径上可用。标准SSA形式中的 $\\phi$-函数要求每个前驱路径都有一个有效的变量。使用 $\\bot$ 表示值不可用，这意味着公共子表达式无法被消除。转换的目标没有实现。\n**结论：错误。**\n\n**C. 不分裂任何边，通过在 $B_1$ 的末尾插入 $t_h := a + b$ 将 $a + b$ 从 $B_2$ 提升到 $B_1$。从 $B_2$ 中移除 $t_1 := a + b$，并在 $B_4$ 中用已经计算好的 $t_h$ 替换 $t_2 := a + b$。**\n这个转换违反了无推测执行的约束。将 $t_h := a+b$ 放置在 $B_1$ 中会导致它在路径 $B_1 \\to B_3$ 上执行，而它最初并不在该路径上执行。由于 $+$ 操作可能会触发异常，如果在该路径上发生溢出，这将改变程序的可观察行为。\n**结论：错误。**\n\n**D. 同时分裂 $(B_3,B_4)$ 和 $(B_5,B_4)$，方法是在这些边上创建新块 $S_{34}$ 和 $S_{54}$。在 $S_{34}$ 中插入 $t_3 := a + b$，在 $S_{54}$ 中插入 $t_4 := a + b$。同时，将 $t_1 := a + b$ 从 $B_2$ 移入在 $(B_2,B_4)$ 上创建的新分裂块 $S_{24}$ 中。在 $B_4$ 中，将 $t_2 := a + b$ 替换为 $t := \\phi(S_{24} \\mapsto t_1, S_{34} \\mapsto t_3, S_{54} \\mapsto t_4)$ 并使用 $t$。**\n这个转换是保持语义的，并且实现了启用GCSE的目标。然而，它不是最小的。它不必要地分裂了非关键边 $(B_2, B_4)$ 和 $(B_5, B_4)$。如前所述，代码可以放置在 $B_5$ 的末尾而无需分裂边，而 $B_2$ 中的计算根本不需要移动。这个选项创建了3个新块，而选项A只创建了1个。因此，这个解决方案不是最小的。\n**结论：错误。**\n\n根据分析，选项A是唯一描述了正确、保持语义且最小的转换的选项。", "answer": "$$\\boxed{A}$$", "id": "3644037"}]}