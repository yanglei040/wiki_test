{"hands_on_practices": [{"introduction": "在并发编程中，条件变量是协调线程的强大工具，但其使用也充满陷阱。尤其是在采用 Mesa 风格语义的系统中，线程从等待中被唤醒后，不能想当然地认为其等待的条件已经成立，因为可能存在“伪唤醒”或其它线程在此期间改变了状态。此练习 [@problem_id:3687757] 旨在揭示这种复杂性，挑战您在这些不确定性下，辨别出保护读者-写者问题中共享资源所需的安全等待模式。", "problem": "您正在为一个操作系统 (OS) 设计经典的读者-写者问题的同步机制，该机制具有写者优先策略并使用条件变量 (CV)。共享状态包括一个互斥锁 $m$，条件变量 $canRead$ 和 $canWrite$，一个整数 $activeReaders$，一个整数 $waitingWriters$，以及一个布尔值 $writerActive$。其语义如下：(i) $wait(cv, m)$ 原子地释放 $m$ 并阻塞调用线程；当等待返回时，线程已重新获取 $m$，(ii) $signal(cv)$ 或 $broadcast(cv)$ 可能会唤醒一个或多个等待者，但允许虚假唤醒（即等待的线程可能在没有任何 $signal$ 或 $broadcast$ 调用的情况下被唤醒），以及 (iii) 适用 Mesa 风格的条件变量语义：被信号唤醒的线程只有在发出信号的线程释放 $m$ 之后才能运行，因此在等待者运行时，条件可能已经发生改变。\n\n要求的安全性属性是：最多只有一个写者是活跃的，并且当有写者活跃时，不能有读者在读取。形式化地表示，当 $writerActive = \\text{true}$ 时，则 $activeReaders = 0$。写者优先策略要求，如果任何写者处于活跃或等待状态，则新的读者不能进入。形式化地表示，一个读者只有在 $\\lnot writerActive \\land waitingWriters = 0$ 的条件下才能进入临界区。\n\n考虑两种读者进入代码的结构，它们使用上述共享状态变量进行非正式描述。两者都在持有 $m$ 的情况下执行，并在返回调用者之前增加 $activeReaders$ 的值。\n\n- 单次检查版本：如果准入谓词为假，则执行一次 $wait(canRead, m)$，然后继续增加 $activeReaders$。\n- 循环版本：当准入谓词为假时，循环执行 $wait(canRead, m)$，然后在循环退出时，继续增加 $activeReaders$。\n\n您的任务是根据上述定义进行推理，选择关于在存在虚假唤醒和写者优先策略的情况下如何保护读者进入的正确陈述。\n\n下列哪个选项是正确的？\n\nA. 能够保持安全性和写者优先策略的循环守卫是：当 $\\big(writerActive \\lor waitingWriters > 0\\big)$ 时，调用 $wait(canRead, m)$。只有当循环退出时，才应执行 $activeReaders \\leftarrow activeReaders + 1$。\n\nB. 循环守卫可以弱化为：当 $\\big(writerActive \\land waitingWriters > 0\\big)$ 时，调用 $wait(canRead, m)$，因为如果两者中只有一个为真，不会发生违规。\n\nC. 带有单个 if 测试的单次检查版本是安全的，如果在单个 $wait(canRead, m)$ 调用前检查一次 $\\big(writerActive \\lor waitingWriters > 0\\big)$，因为 $wait$ 在返回前会重新获取 $m$，因此条件不会意外改变。\n\nD. 存在一个调度序列可以证明单次检查版本在虚假唤醒下会失败：在时间 $t_1$，一个写者设置 $writerActive \\leftarrow \\text{true}$ 并持有 $m$；在时间 $t_2$，一个读者 $R$ 执行单次 if 测试，发现 $\\big(writerActive \\lor waitingWriters > 0\\big)$ 为真，并调用 $wait(canRead, m)$；在时间 $t_3$，发生了一次虚假唤醒，$R$ 从 $wait$ 返回并持有 $m$，而此时 $writerActive$ 仍然为 $\\text{true}$；在时间 $t_4$，由于没有重新检查，$R$ 增加了 $activeReaders$ 的值并与写者并发执行，从而违反了安全性。\n\nE. 当写者释放资源时，使用 $signal(canRead)$ 而不是 $broadcast(canRead)$ 可以消除读者代码中循环的必要性，因为最多只有一个读者会被唤醒，并且当它运行时状态是稳定的。\n\n选择所有适用的选项。", "solution": "用户要求对使用 Mesa 风格条件变量、具有写者优先策略的读者-写者问题的同步策略进行批判性分析。我将首先验证问题陈述，在确认其有效后，再对每个选项进行详细分析。\n\n### **问题验证**\n\n**第一步：提取已知条件**\n\n-   **问题领域**：操作系统中的经典读者-写者问题。\n-   **同步策略**：写者优先。\n-   **原语**：互斥锁 $m$ 和条件变量 (CVs) $canRead$ 和 $canWrite$。\n-   **共享状态**：整数 $activeReaders$，整数 $waitingWriters$，布尔值 $writerActive$。\n-   **条件变量语义**：\n    -   (i) $wait(cv, m)$ 原子地释放 $m$，阻塞，并在返回时重新获取 $m$。\n    -   (ii) 允许虚假唤醒。\n    -   (iii) 适用 Mesa 风格语义：被信号唤醒的线程仅在发出信号的线程释放互斥锁 $m$ 后才恢复执行。\n-   **安全性属性**：如果 $writerActive = \\text{true}$，则 $activeReaders = 0$。\n-   **写者优先策略**：读者只有在 $\\lnot writerActive \\land waitingWriters = 0$ 时才能进入其临界区。\n-   **待比较的代码结构**：\n    1.  **单次检查**：在可能执行的 $wait$ 前，使用 `if` 语句测试一次准入谓词。\n    2.  **循环**：在继续执行前，使用 `while` 循环重复测试准入谓词。\n\n**第二步：使用提取的已知条件进行验证**\n\n问题陈述是**有效的**。\n-   它是**基于科学**且**客观的**：该问题是关于并发控制的一个典型的计算机科学问题。术语（Mesa 语义、虚假唤醒、互斥锁、条件变量）和形式化属性在操作系统领域内都有标准且精确的定义。\n-   它**定义明确**：该问题提供了一套完整的规则（原语语义、安全属性、策略），并要求根据这些规则评估具体的实现选择。这允许进行唯一且合乎逻辑的分析。\n-   设置中没有矛盾、歧义或事实错误。\n\n### **推导与求解**\n\n问题的核心在于读者的准入条件与 Mesa 风格条件变量语义之间的相互作用。\n\n**Mesa 风格条件变量的基本原则：**\n问题指出，(ii) 虚假唤醒是可能的，并且 (iii) 由于 Mesa 风格语义，引发 `signal` 的条件在等待线程最终重新获取互斥锁并运行时可能已不再为真。这两个事实都意味着一个关键的设计原则：**从 $wait$ 调用中唤醒后，线程不能假设期望的条件已满足。**它必须重新评估该条件。\n\n使用 Mesa 风格条件变量等待条件 $P$ 变为真的标准且正确的模式是将 $wait$ 调用置于一个 `while` 循环内：\n\n`lock(m);`\n`while (!P)`\n`    wait(cv, m);`\n`// ... proceed, P is guaranteed to be true here`\n`unlock(m);`\n\n任何在 $wait$ 之前使用单个 `if` 检查的实现都存在固有缺陷，因为它在唤醒后未能重新检查条件。\n\n**将原则应用于本问题：**\n写者优先策略规定，读者只有在条件 $P \\equiv (\\lnot writerActive \\land waitingWriters = 0)$ 为真时才能继续。因此，需要等待的条件是 $\\lnot P$。根据德摩根定律：\n$$ \\lnot(\\lnot writerActive \\land waitingWriters = 0) \\equiv (\\lnot(\\lnot writerActive) \\lor \\lnot(waitingWriters = 0)) $$\n$$ \\equiv (writerActive \\lor waitingWriters \\neq 0) $$\n假设 $waitingWriters$ 不能为负，这等价于 $(writerActive \\lor waitingWriters > 0)$。\n\n因此，正确的读者进入代码必须锁定互斥锁 $m$，在 $(writerActive \\lor waitingWriters > 0)$ 的条件下循环，并且只有在循环终止后（即满足继续执行的条件时）才增加 $activeReaders$。\n\n### **逐项分析**\n\n**A. 能够保持安全性和写者优先策略的循环守卫是：当 $\\big(writerActive \\lor waitingWriters > 0\\big)$ 时，调用 $wait(canRead, m)$。只有当循环退出时，才应执行 $activeReaders \\leftarrow activeReaders + 1$。**\n\n-   **分析**：该选项描述了从基本原则推导出的确切实现。`while` 循环通过重新检查谓词，正确处理了虚假唤醒和 Mesa 风格语义中固有的条件变化。谓词本身，$writerActive \\lor waitingWriters > 0$，是读者需要等待的正确条件，因为它是准入谓词 $\\lnot writerActive \\land waitingWriters = 0$ 的否定。在循环之后增加 $activeReaders$ 确保了只有在被授予访问权限后才计算读者数量，从而保持了共享状态的完整性。\n-   **结论**：正确。\n\n**B. 循环守卫可以弱化为：当 $\\big(writerActive \\land waitingWriters > 0\\big)$ 时，调用 $wait(canRead, m)$，因为如果两者中只有一个为真，不会发生违规。**\n\n-   **分析**：这提出了一个错误的等待条件。如果 $\\lnot(writerActive \\land waitingWriters > 0)$ 为真，即 $\\lnot writerActive \\lor waitingWriters = 0$ 为真，循环就会终止。这不是所要求的准入条件。\n    -   情况 1：如果 $writerActive$ 为真且 $waitingWriters = 0$，循环条件为假。读者将退出循环并增加 $activeReaders$，导致状态变为 $writerActive = \\text{true}$ 和 $activeReaders > 0$。这直接违反了指定的安全性属性。\n    -   情况 2：如果 $writerActive$ 为假且 $waitingWriters > 0$，循环条件为假。读者将退出循环并继续执行，违反了要求读者等待正在等待的写者的写者优先策略。\n-   **结论**：不正确。\n\n**C. 带有单个 if 测试的单次检查版本是安全的，如果在单个 $wait(canRead, m)$ 调用前检查一次 $\\big(writerActive \\lor waitingWriters > 0\\big)$，因为 $wait$ 在返回前会重新获取 $m$，因此条件不会意外改变。**\n\n-   **分析**：该选项为单次检查版本辩护。其推理存在根本性缺陷。虽然 $wait(canRead, m)$ 确实会重新获取 $m$，但在线程被信号唤醒（或虚假唤醒）到它重新获取锁之间的这段时间内，其他线程可以运行。另一个线程可能已经获取了 $m$，改变了状态（例如，一个新的写者到达并设置了 $waitingWriters > 0$），然后释放了 $m$。此外，虚假唤醒根本不提供关于状态的任何信息。需要一个 `while` 循环来处理这些情况；一个 `if` 语句是不充分且不安全的。“条件不会意外改变”的说法是错误的。\n-   **结论**：不正确。\n\n**D. 存在一个调度序列可以证明单次检查版本在虚假唤醒下会失败：在时间 $t_1$，一个写者设置 $writerActive \\leftarrow \\text{true}$ 并持有 $m$；在时间 $t_2$，一个读者 $R$ 执行单次 if 测试，发现 $\\big(writerActive \\lor waitingWriters > 0\\big)$ 为真，并调用 $wait(canRead, m)$；在时间 $t_3$，发生了一次虚假唤醒，$R$ 从 $wait$ 返回并持有 $m$，而此时 $writerActive$ 仍然为 $\\text{true}$；在时间 $t_4$，由于没有重新检查，$R$ 增加了 $activeReaders$ 的值并与写者并发执行，从而违反了安全性。**\n\n-   **分析**：该选项为单次检查版本提供了一个具体的失败场景。虽然“在时间 $t_1$，一个写者...持有 $m$”和“在时间 $t_2$，一个读者 $R$ 执行”的措辞略有不精确（两个线程不能同时持有同一个互斥锁），但它所描述的状态逻辑序列是有效的，并展示了一个关键缺陷。一个更精确的时间线是：一个写者获取 $m$，设置 $writerActive \\leftarrow \\text{true}$，然后释放 $m$ 去工作。接着读者 $R$ 获取 $m$，看到 $writerActive$ 为真，并调用 $wait(canRead, m)$，释放了 $m$。然后，发生了一次虚假唤醒。$R$ 重新获取了 $m$。此时，写者仍然是活跃的（$writerActive = \\text{true}$）。单次检查代码不会重新测试条件，所以 $R$ 错误地继续增加 $activeReaders$ 并进入临界区。这导致状态变为 $writerActive = \\text{true}$ 和 $activeReaders > 0$，明显违反了安全性属性。所描述的场景是解释为什么需要 `while` 循环的经典例子。\n-   **结论**：正确。\n\n**E. 当写者释放资源时，使用 $signal(canRead)$ 而不是 $broadcast(canRead)$ 可以消除读者代码中循环的必要性，因为最多只有一个读者会被唤醒，并且当它运行时状态是稳定的。**\n\n-   **分析**：该选项不正确，主要有两个原因。首先，在 Mesa 风格语义下，“当它运行时状态是稳定的”这一说法是错误的。如前所述，另一个线程可以在 `signal` 和等待者恢复执行之间改变状态。其次，它完全忽略了虚假唤醒的可能性，而虚假唤醒与使用的是 `signal` 还是 `broadcast` 无关。虚假唤醒仍然会导致单次检查代码失败。因此，切换到 $signal(canRead)$ 并不能消除对 `while` 循环的需求。\n-   **结论**：不正确。", "answer": "$$\\boxed{AD}$$", "id": "3687757"}, {"introduction": "理论上完美的算法在现实世界中可能会因为未处理的异常而彻底失败。在并发系统中，如果一个线程因错误而未能执行其清理逻辑（例如，释放锁或更新计数器），可能会导致整个系统死锁或资源饥饿。此练习 [@problem_id:3687699] 展示了一个由于异常导致写者线程永久等待的真实场景，并要求您找出能够确保代码在任何执行路径下都能维持系统一致性的关键架构模式。", "problem": "一个系统使用单个互斥锁 $mutex$ 和两个条件变量 $canRead$ 和 $canWrite$ 实现了一个读写者协议。共享状态包括一个整数计数器 $rw\\_count$ 和一个布尔值 $writerActive$。预期的不变量是 $rw\\_count$ 等于当前活动读者线程的数量，并且写者只有在 $rw\\_count = 0$ 且 $writerActive = \\text{false}$ 时才能继续执行。预期的进入/退出行为如下：读者进入时获取 $mutex$，在 $writerActive = \\text{true}$ 时等待，增加 $rw\\_count$，然后释放 $mutex$；读者退出时获取 $mutex$，减少 $rw\\_count$，如果 $rw\\_count = 0$ 则向 $canWrite$ 发出信号，然后释放 $mutex$。写者进入时获取 $mutex$，在 $(rw\\_count > 0) \\lor (writerActive = \\text{true})$ 时等待，将 $writerActive$ 设置为 $\\text{true}$，然后释放 $mutex$；写者退出时获取 $mutex$，将 $writerActive$ 设置为 $\\text{false}$，广播 $canRead$ 并向 $canWrite$ 发出信号，然后释放 $mutex$。\n\n考虑一个包含 $3$ 个读者和 $2$ 个写者的场景。读者 $R\\_1$ 执行进入操作（获取 $mutex$，观察到 $writerActive = \\text{false}$，将 $rw\\_count$ 增加到 $1$，释放 $mutex$）并开始读取。读者 $R\\_2$ 和 $R\\_3$ 随后进入并将 $rw\\_count$ 增加到 $3$。写者 $W\\_1$ 尝试进入，但因为 $rw\\_count > 0$ 而等待。在其读取期间，$R\\_2$ 遇到了一个触发异常的输入/输出错误，导致 $R\\_2$ 立即返回，而没有执行读者退出例程。结果，$rw\\_count$ 即使在 $R\\_2$ 停止读取后仍保持为 $3$，而 $W\\_1$ 继续等待。随着时间的推移，更多的写者到达并被卡住，等待 $rw\\_count$ 变为 $0$。在此期间，没有线程操作 $writerActive$。\n\n仅使用互斥、条件变量和已声明的不变量 $rw\\_count = \\text{活动读者数量}$ 的基本定义，分析为什么写者会被卡住，并找出最稳健的修正方法，该方法即使在读者代码中存在异常的情况下，也能保证安全性（写入期间没有并发读取）和活性（读者结束后写者最终能继续执行）。\n\n哪个选项既正确地诊断了故障，又提出了一个正确的修复模式？\n\nA. 问题在于 $rw\\_count$ 的增加和减少操作不是原子的；修复方法是使 $rw\\_count$ 成为原子类型，这样异常就无法干扰更新。\n\nB. 问题在于异常路径跳过了读者退出部分，违反了不变量 $rw\\_count = \\text{活动读者数量}$；修复方法是将读取部分包装在 try-finally 块中：在 $mutex$ 保护下增加 $rw\\_count$ 并释放 $mutex$ 后，在 try 块中执行读取，并在 finally 块中重新获取 $mutex$，减少 $rw\\_count$，如果 $rw\\_count = 0$ 则向 $canWrite$ 发出信号，然后释放 $mutex$。\n\nC. 问题在于写者在错误的条件变量上等待；修复方法是让写者在 $canRead$ 上等待，这样读者在完成时可以唤醒写者。\n\nD. 问题在于读者增加 $rw\\_count$ 的操作相对于检查 $writerActive$ 的顺序不当；修复方法是将增加 $rw\\_count$ 的操作移到读取完成之后，这样异常就不会使 $rw\\_count$ 保持在高位。\n\nE. 问题在于写者等待时缺少超时机制；修复方法是添加一个超时，以便写者在有界延迟后无论 $rw\\_count$ 的值如何都能继续执行。", "solution": "用户希望我扮演一名STEM教授，解决一个与读写者问题相关的计算机科学问题。\n\n我的计划如下：\n1.  **验证问题陈述**。我将逐字提取所有给定条件，并检查其科学合理性、良构性及其他标准。\n2.  **如果有效，从第一性原理推导解决方案**。我将分析所描述的故障模式的原因，并确定正确的架构模式来防止它，同时保持正确性（安全性和活性）。\n3.  **评估每个选项**。我将根据推导出的解决方案和并发编程的原则，系统地分析选项A、B、C、D和E。\n4.  **格式化输出**。我将严格遵守所有格式化规则，特别是对所有数学和符号实体强制使用LaTeX。\n\n### 步骤1：提取给定条件\n\n*   **同步原语**：单个互斥锁 `$mutex$` 和两个条件变量 `$canRead$` 和 `$canWrite$`。\n*   **共享状态**：一个整数计数器 `$rw\\_count$` 和一个布尔值 `$writerActive$`。\n*   **预期不变量**：`$rw\\_count$` 等于当前活动读者线程的数量。\n*   **写者先决条件**：写者只有在 `$rw\\_count = 0$` 且 `$writerActive = \\text{false}$` 时才能继续执行。\n*   **读者进入协议**：获取 `$mutex$`，在 `$writerActive = \\text{true}$` 时等待，增加 `$rw\\_count$`，然后释放 `$mutex$`。\n*   **读者退出协议**：获取 `$mutex$`，减少 `$rw\\_count$`，如果 `$rw\\_count = 0$` 则向 `$canWrite$` 发出信号，然后释放 `$mutex$`。\n*   **写者进入协议**：获取 `$mutex$`，在 `$(rw\\_count > 0) \\lor (writerActive = \\text{true})$` 时等待，将 `$writerActive$` 设置为 `\\text{true}`，然后释放 `$mutex$`。\n*   **写者退出协议**：获取 `$mutex$`，将 `$writerActive$` 设置为 `\\text{false}`，广播 `$canRead$` 并向 `$canWrite$` 发出信号，然后释放 `$mutex$`。\n*   **场景**：\n    *   一个有 `$3$` 个读者（`$R_1$`、`$R_2$`、`$R_3$`）和 `$2$` 个写者的系统。\n    *   `$R_1$`、`$R_2$` 和 `$R_3$` 成功执行读者进入协议。`$rw\\_count$` 变为 `$3$`。\n    *   一个写者 `$W_1$` 尝试进入并阻塞，等待 `$rw\\_count` 变为 `$0$`。\n    *   读者 `$R_2$` 遇到一个I/O错误，触发了一个异常，导致它立即终止任务。\n    *   关键是，`$R_2$` **没有执行读者退出例程**。\n    *   因此，`$rw\\_count$` 保持在高位。即使在 `$R_1$` 和 `$R_3$` 退出后，`$rw\\_count$` 将是 `$1$`，而不是 `$0$`。\n    *   包括 `$W_1$` 在内的写者无限期地等待下去。\n\n### 步骤2：使用提取的给定条件进行验证\n\n*   **科学基础**：该问题位于并发编程和操作系统领域，处理的是经典的读写者问题。所使用的原语（`mutex`、条件变量）和故障模式（异常安全）是计算机科学中标准且易于理解的概念。该问题在科学和技术上都是合理的。\n*   **良构性**：该问题描述了一个特定的实现、一个特定的故障场景，并要求进行诊断和稳健的修复。修复的目标（保持安全性和活性）已明确说明。可以推导出明确的概念性解决方案。\n*   **客观性**：描述是事实性的，没有主观或模棱两可的语言。系统的行为是根据协议规则确定性地描述的。\n*   **缺陷检查表**：该问题没有违反任何指定的缺陷条件。它不是不合理、不完整、不现实或不良构的。异常短路清理逻辑的场景是现实世界系统中一个常见且严重的错误，这使其成为一个相关且非平凡的问题。\n\n### 步骤3：结论和行动\n\n问题陈述是**有效的**。我将继续解决。\n\n### 解决方案的推导\n\n读写者问题的核心是维护保证安全性和活性的不变量。这种“读者优先”或“共享读锁”模式的安全性不变量是双重的：\n$1$. 允许多个读者并发：`(写者数量) = 0`。\n$2$. 只允许单个写者独占：`(写者数量) = 1` $\\implies$ `(读者数量) = 0`。\n\n所提供的实现使用状态变量 `$rw\\_count$` 和 `$writerActive$` 来强制执行这些不变量。其逻辑依赖于预期的不变量：`$rw\\_count$` 准确反映当前正在执行读取操作的线程数量。\n\n**故障分析**：\n问题陈述指出，读者 `$R_2$` 在遇到异常时，“立即返回而没有执行读者退出例程”。\n\n读者进入例程执行以下状态更改：`$rw\\_count \\leftarrow rw\\_count + 1`。\n读者退出例程负责相应的状态更改：`$rw\\_count \\leftarrow rw\\_count - 1`。\n\n当 `$R_2$` 在没有执行退出例程的情况下终止时，对 `$rw\\_count$` 的增加操作就永远不会被撤销。变量 `$rw\\_count$` 现在永久性地多报了活动读者的数量。系统状态与物理现实不一致；不变量 `$rw\\_count = \\text{活动读者数量}$` 被违反了。\n\n写者进入协议包括条件 `wait while ($rw\\_count > 0$)`。因为 `$rw\\_count$` 永远不会返回到 `$0$`（它被永久地偏移了 `$1$`), 写者继续执行的条件将永远不会被满足。这导致所有写者线程的饥饿。\n\n**稳健修正的原则**：\n根本问题是在存在异常控制流的情况下，未能保证资源清理或状态恢复。这里的“资源”是对读锁的声明，由增加的 `$rw\\_count$` 表示。应该应用的原则是，任何获取资源或修改共享状态的动作，都必须与一个相应的释放/恢复动作配对，并且这个动作必须保证被执行，无论中间的代码是正常完成还是因异常而终止。\n\n在大多数支持异常的现代编程语言中，这种保证由 `try...finally` 块（或 `try...catch...finally`）提供。可能抛出异常的代码放在 `try` 块中，清理代码放在 `finally` 块中。`finally` 的语义保证了在因任何原因退出 `try` 块时它都会被执行。实现相同目标的另一种模式是作用域界定资源管理（Scope-Bound Resource Management, SBRM），在C++中也称为资源获取即初始化（Resource Acquisition Is Initialization, RAII）。\n\n稳健的读者实现的正确结构是：\n$1$. 读者进入:\n   - 获取 `$mutex$`。\n   - 等待读取权限 (例如，`while ($writerActive$) { canRead.wait(mutex); }`)。\n   - 增加 `$rw\\_count$`。\n   - 释放 `$mutex$`。\n$2$. **受保护的读取操作**:\n   - `try`\n      - 执行读取操作 (这是可能发生I/O错误和异常的地方)。\n   - `finally`\n      - 执行读者退出协议：\n         - 获取 `$mutex$`。\n         - 减少 `$rw\\_count$`。\n         - 如果 `$rw\\_count = 0$`，向 `$canWrite$` 发出信号。\n         - 释放 `$mutex$`。\n\n这种结构确保了每当 `$rw\\_count$` 成功增加一次，就保证会相应地减少一次，从而维护共享状态的完整性和协议的正确性。\n\n### 逐项分析\n\n**A. 问题在于 `$rw\\_count$` 的增加和减少操作不是原子的；修复方法是使 `$rw\\_count$` 成为原子类型，这样异常就无法干扰更新。**\n- **分析**：问题陈述指出，对 `$rw\\_count$` 的更新是在持有 `$mutex$` 的情况下执行的。这已经保证了增加和减少操作相对于其他线程是原子的。故障并非增加操作本身被中断，而是整个*退出例程*（其中包含减少操作）因异常而被跳过。将 `$rw\\_count$` 设为硬件支持的原子类型（如C++中的 `std::atomic`）并不能解决这个问题，因为执行原子减少操作的那行代码仍然会被跳过。\n- **结论**：**不正确**。\n\n**B. 问题在于异常路径跳过了读者退出部分，违反了不变量 `$rw\\_count = \\text{活动读者数量}$；修复方法是将读取部分包装在 try-finally 块中：在 $mutex$ 保护下增加 $rw\\_count$ 并释放 $mutex$ 后，在 try 块中执行读取，并在 finally 块中重新获取 $mutex$，减少 $rw\\_count$，如果 $rw\\_count = 0$ 则向 $canWrite$ 发出信号，然后释放 $mutex$。**\n- **分析**：该选项提供了完美的诊断：异常路径跳过了清理代码，导致不变量被破坏。提议的解决方案是使用 `try-finally` 块来包裹可能出错的读取操作。放在 `finally` 块中的代码是完整的读者退出协议。这种架构模式是在面对异常时确保资源释放和状态一致性的经典且稳健的解决方案。这与从第一性原理推导出的解决方案相匹配。\n- **结论**：**正确**。\n\n**C. 问题在于写者在错误的条件变量上等待；修复方法是让写者在 $canRead$ 上等待，这样读者在完成时可以唤醒写者。**\n- **分析**：在所描述的协议中，离开的读者向 `$canWrite$` 发信号，而写者在 `$canWrite$` 上等待。这是一个逻辑上正确的配对。变量 `$canRead$` 是由退出的写者用来向等待的读者发信号的。让写者在 `$canRead$` 上等待在语义上是不正确的。此外，问题不在于写者没有被唤醒；问题在于它等待的条件（`$rw\\_count = 0$`）由于状态损坏而永远无法变为真。更改条件变量并不能解决根本原因。\n- **结论**：**不正确**。\n\n**D. 问题在于读者增加 $rw\\_count$ 的操作相对于检查 $writerActive$ 的顺序不当；修复方法是将增加 $rw\\_count$ 的操作移到读取完成之后，这样异常就不会使 $rw\\_count$ 保持在高位。**\n- **分析**：这个修复尝试解决状态损坏问题，但引入了严重的安全违规。如果 `$rw\\_count$` 仅在读取完成*之后*才增加，那么在整个读取操作期间，`$rw\\_count$` 并没有计入这个活动的读者。如果另一个线程（一个写者）尝试进入，它可能会看到 `$rw\\_count = 0$`（如果没有其他活动读者），然后它将继续写入。这导致写者与读者并发操作，违反了读写者问题的基本安全要求。\n- **结论**：**不正确**。\n\n**E. 问题在于写者等待时缺少超时机制；修复方法是添加一个超时，以便写者在有界延迟后无论 $rw\\_count$ 的值如何都能继续执行。**\n- **分析**：这个“修复”建议写者在等待一段时间后，应该忽略等待条件（`$rw\\_count > 0$`）并继续执行。这将导致写者在读者仍然活动时开始写入，从而引发竞争条件和灾难性的安全违规。虽然超时可以用来检测和处理活性失败（如死锁或饥饿），但它们并不授予线程违反安全不变量的权限。超时的正确用法是记录错误、重试或上报，而不是盲目地继续。这个选项通过破坏协议的安全性来掩盖活性问题。\n- **结论**：**不正确**。", "answer": "$$\\boxed{B}$$", "id": "3687699"}, {"introduction": "掌握了单个同步原语的正确用法后，下一步便是将这些构件整合成一个完整的、功能性的系统。本练习 [@problem_id:2422634] 将引导您超越简单的锁机制，从头开始实现一个带有特定安全和公平性规则的完整读写调度器的逻辑。这要求您将一个正式的规范转化为一个可工作的模拟程序，从而深入理解调度策略在实践中是如何运作的。", "problem": "给定一个共享内存并行系统，其中包含一个由两种类型的操作（读者和写者）访问的单一逻辑共享对象。每个操作都是一个由到达时间和所需服务时长表征的请求，这两者都以离散的无单位时间步来衡量。一个操作一旦开始，将在其开始时间到开始时间加上其时长的半开区间内占用共享对象，即区间 $\\left[ s_i, s_i + d_i \\right)$，其中 $s_i$ 是开始时间，$d_i$ 是时长。\n\n该系统必须满足以下语义和约束。\n\n1) 安全性约束。设 $R(t)$ 表示在时间 $t$ 的活动读者数量，设 $W(t) \\in \\{0,1\\}$ 表示在时间 $t$ 的活动写者数量。系统必须确保在任何时间 $t$，如果 $W(t) = 1$，则 $R(t) = 0$，并且任何时候都不能有超过一个写者同时处于活动状态。在没有写者活动时，可以有多个读者并发活动。\n\n2) 对写者的公平性约束（写者无饥饿）。一旦一个写者已到达并等待开始，直到没有等待中的写者之前，任何新的读者都不能开始。形式上，如果在时间 $t$ 存在一个写者 $j$，其到达时间 $a_j \\le t$，开始时间 $s_j$ 满足 $s_j > t$，那么在时间 $t$ 就不能有任何读者开始。\n\n3) 确定性调度语义。时间在一系列离散的决策时间点上推进。在每个决策时间 $t$，假定在瞬时 $t$ 内遵循以下顺序：首先，所有结束时间恰好为 $t$ 的操作完成并释放资源；其次，所有到达时间等于 $t$ 的操作被视为已到达并加入等待集合；第三，根据以下规则确定新的开始操作：\n   a) 如果至少有一个等待中的写者，且没有活动的读者和活动的写者，则最早到达的那个等待中的写者必须在时间 $t$ 开始。\n   b) 否则，如果没有等待中的写者，且没有活动的写者，则所有等待中的读者必须在时间 $t$ 开始。\n   c) 否则，在时间 $t$ 没有新的操作开始。\n如果多个请求的到达时间相同，它们的相对顺序是该测试用例输入中给出的顺序。一个操作的开始时间不得早于其到达时间。\n\n你的任务是实现一个程序，该程序为每个测试用例的有限请求列表构建满足上述语义的开始时间，然后为每个测试用例计算以下三个量：\n- 一个布尔值，指示生成的调度是否满足上述定义的安全性和写者公平性约束。\n- 最大并发读者数，即调度期间的 $\\max_{t} R(t)$。\n- 完工时间（makespan），定义为最晚完成时间 $\\max_i \\left( s_i + d_i \\right)$ 与最早到达时间 $\\min_i a_i$ 之间的差值。\n\n测试套件。使用以下 $5$ 个测试用例。每个测试用例是一个请求列表。每个请求是一个三元组 $(\\text{type}, a, d)$，其中 $\\text{type} \\in \\{\\text{R}, \\text{W}\\}$，$a$ 是到达时间，$d$ 是时长。对于测试用例内到达时间相同的请求，下面列出的顺序是要求的平局打破顺序。\n\n- 测试用例 $1$：\n  $[(\\text{R},\\, 0,\\, 5),\\, (\\text{R},\\, 1,\\, 3),\\, (\\text{W},\\, 2,\\, 4),\\, (\\text{R},\\, 6,\\, 2),\\, (\\text{W},\\, 6,\\, 1)]$.\n\n- 测试用例 $2$：\n  $[(\\text{R},\\, 0,\\, 2),\\, (\\text{R},\\, 0,\\, 2),\\, (\\text{R},\\, 1,\\, 1)]$.\n\n- 测试用例 $3$：\n  $[(\\text{W},\\, 0,\\, 2),\\, (\\text{W},\\, 1,\\, 2),\\, (\\text{W},\\, 3,\\, 1)]$.\n\n- 测试用例 $4$：\n  $[(\\text{R},\\, 0,\\, 5),\\, (\\text{R},\\, 1,\\, 5),\\, (\\text{W},\\, 2,\\, 2),\\, (\\text{R},\\, 2,\\, 1),\\, (\\text{R},\\, 3,\\, 1)]$.\n\n- 测试用例 $5$：\n  $[(\\text{R},\\, 0,\\, 1),\\, (\\text{W},\\, 0,\\, 1)]$.\n\n最终输出格式。你的程序应产生单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果。每个元素对应一个测试用例，并且其本身必须是 $[\\text{valid}, \\text{max\\_readers}, \\text{makespan}]$ 顺序的三元素列表，不含空格。例如，一个有效的输出形状示例为\n$[[\\text{True},2,7],[\\text{False},1,3],[\\text{True},3,5],[\\text{True},2,4],[\\text{True},1,1]]$\n但实际值由你的实现根据指定的测试套件确定。", "solution": "该问题要求在一个共享资源上，对一个读者-写者问题的确定性调度策略进行模拟。解决方案涉及两个主要阶段：首先，通过在离散时间步上模拟系统来生成一个调度；其次，分析这个调度以计算所需的指标。\n\n**1. 调度策略的模拟**\n\n任务的核心是实现一个严格遵守给定调度语义的离散时间模拟器。在任何时间 `t`，系统的状态可以通过活动操作集合和等待操作集合来描述。\n\n让我们将状态变量形式化：\n- 一个未处理的请求列表，按其到达时间 `a_i` 排序，对于时间相同的，则按其在输入中的顺序排序。每个请求 `i` 是一个（类型, `a_i`, `d_i`）的元组。我们将为其增加一个唯一ID和一个用于记录开始时间 `s_i` 的字段。\n- 一个等待中的读者队列，`waiting_readers`。\n- 一个等待中的写者队列，`waiting_writers`，根据到达时间维持先入先出（FIFO）顺序。\n- 一个活动读者列表，`active_readers`。\n- 一个用于单个活动写者的变量，`active_writer`。\n\n模拟通过从 $t=0$ 开始递增时间变量 `t` 来进行。当所有请求都已到达、开始并完成后，模拟终止。\n\n在每个时间步 `t`，必须按照问题陈述中指定的那样执行以下操作序列：\n\n**第 1 步：处理完成事件**\n任何完成时间 `s_i + d_i` 等于 `t` 的活动操作 `i` 将结束其执行。\n- 如果一个活动写者 `j` 的 `s_j + d_j = t`，则通过将 `active_writer` 设置为空来释放资源。\n- 任何满足 `s_k + d_k = t` 的活动读者 `k` 将从 `active_readers` 列表中移除。\n\n**第 2 步：处理到达事件**\n所有到达时间 `a_i = t` 的请求 `i` 将从未处理列表中移至相应的等待队列（`waiting_readers` 或 `waiting_writers`）。在添加到队列时，必须遵守平局打破规则（对到达时间相同的请求，按输入顺序）。\n\n**第 3 步：做出调度决策**\n根据活动队列和等待队列的当前状态，遵循一套严格的规则来启动新操作：\n- **规则 (a)：**如果 `waiting_writers` 非空 且 `active_readers` 为空 且 `active_writer` 为空，则从 `waiting_writers` 中出队并启动最早到达的写者。其开始时间 `s_i` 被设为 `t`，并成为 `active_writer`。\n- **规则 (b)：**否则，如果 `waiting_writers` 为空 且 `active_writer` 为空，则启动 `waiting_readers` 中的所有读者。对于这些读者中的每一个，其开始时间 `s_i` 被设为 `t`，并被移动到 `active_readers` 列表中。然后清空 `waiting_readers` 队列。\n- **规则 (c)：**在所有其他情况下（例如，资源被写者占用，或在有写者等待时被读者占用），在时间 `t` 不能有新操作开始。\n\n这个 `t++` 模拟循环一直持续到所有请求都完成为止。\n\n**2. 对生成的调度进行分析**\n\n一旦模拟完成，所有请求都将被分配一个开始时间 `s_i`。然后我们分析这个完整的调度，为每个测试用例计算三个量。\n\n**A. 调度有效性**\n问题要求一个布尔值，指示生成的调度是否满足安全性和写者公平性约束。所提供的调度规则在设计上就保证了其构造的调度是有效的。因此，这个检查可以作为对模拟器实现的验证。\n- **安全性检查：**如果在任何时间 `t` 都没有一个写者与任何其他操作（读者或写者）并发活动，并且任何时候都只有一个活动写者，则调度是安全的。这可以通过遍历时间并检查活动操作集合来验证。\n- **公平性检查：**写者无饥饿规则规定，如果有写者在等待，则在时间 `t` 不能有新的读者开始。这通过检查每个读者的开始时间 `s_k` 来进行验证。在 `t = s_k` 时，我们验证不存在写者 `j` 满足 `a_j \\le s_k` 且 `s_j > s_k`。\n\n如果两项检查都通过，则调度是有效的。鉴于确定性的规则，对于一个正确的实现，这个值应该总是 `True`。\n\n**B. 最大并发读者数**\n这是在整个调度期间 `R(t)` 的最大值，其中 `R(t)` 是在时间 `t` 的活动读者数量。这可以通过分析调度来计算。一个高效的方法是创建一个包含 `START_READER` 和 `END_READER` 事件的列表，分别对应时间 `s_i` 和 `s_i+d_i`。通过对这些事件进行排序并按时间扫描，我们可以跟踪当前活动读者的数量并找到其最大值。\n\n**C. 完工时间**\n完工时间定义为从第一个请求到达​​到最后一个请求完成所经过的总时间。其计算公式为：\n$$\n\\text{完工时间} = \\left( \\max_{i} (s_i + d_i) \\right) - \\left( \\min_{i} a_i \\right)\n$$\n最小到达时间 `min(a_i)` 从输入数据中找到。最大完成时间 `max(s_i + d_i)` 由生成的调度确定。\n\n通过对每个测试用例遵循此程序，我们可以系统地得出所需的结果。使用简单的时间步进模拟确保了对问题形式化规范的直接和忠实的实现。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the readers-writers scheduling problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        [('R', 0, 5), ('R', 1, 3), ('W', 2, 4), ('R', 6, 2), ('W', 6, 1)],\n        # Test case 2\n        [('R', 0, 2), ('R', 0, 2), ('R', 1, 1)],\n        # Test case 3\n        [('W', 0, 2), ('W', 1, 2), ('W', 3, 1)],\n        # Test case 4\n        [('R', 0, 5), ('R', 1, 5), ('W', 2, 2), ('R', 2, 1), ('R', 3, 1)],\n        # Test case 5\n        [('R', 0, 1), ('W', 0, 1)],\n    ]\n\n    all_results = []\n    for case_idx, case_data in enumerate(test_cases):\n        # 1. Initialize requests with unique IDs and start times\n        requests = []\n        for i, (req_type, arrival, duration) in enumerate(case_data):\n            requests.append({\n                'id': i,\n                'type': req_type,\n                'a': arrival,\n                'd': duration,\n                's': -1,  # Start time, -1 indicates not started\n            })\n\n        # 2. Simulation\n        time = 0\n        num_completed = 0\n        total_requests = len(requests)\n        \n        arrived_but_not_waiting_requests = sorted(requests, key=lambda r: (r['a'], r['id']))\n        arrived_idx = 0\n\n        waiting_readers = deque()\n        waiting_writers = deque()\n        active_readers = []\n        active_writer = None\n\n        while num_completed  total_requests:\n            # Step 1: Process completions at the beginning of time t\n            completed_this_step = []\n            if active_writer and (active_writer['s'] + active_writer['d'] == time):\n                completed_this_step.append(active_writer)\n                active_writer = None\n\n            remaining_active_readers = []\n            for r in active_readers:\n                if r['s'] + r['d'] == time:\n                    completed_this_step.append(r)\n                else:\n                    remaining_active_readers.append(r)\n            active_readers = remaining_active_readers\n            \n            num_completed += len(completed_this_step)\n\n            # Step 2: Process arrivals at time t\n            while arrived_idx  total_requests and arrived_but_not_waiting_requests[arrived_idx]['a'] == time:\n                req = arrived_but_not_waiting_requests[arrived_idx]\n                if req['type'] == 'R':\n                    waiting_readers.append(req)\n                else: # 'W'\n                    waiting_writers.append(req)\n                arrived_idx += 1\n\n            # Step 3: Make scheduling decisions\n            # Rule a: Start a writer if possible\n            if waiting_writers and not active_readers and not active_writer:\n                writer_to_start = waiting_writers.popleft()\n                writer_to_start['s'] = time\n                active_writer = writer_to_start\n            # Rule b: Otherwise, start readers if possible\n            elif not waiting_writers and not active_writer:\n                while waiting_readers:\n                    reader_to_start = waiting_readers.popleft()\n                    reader_to_start['s'] = time\n                    active_readers.append(reader_to_start)\n            # Rule c: Otherwise, wait\n            \n            time += 1\n        \n        # 3. Analysis of the schedule\n        schedule = requests\n        is_valid = True\n        \n        # Safety and Max Readers calculation\n        max_time = 0\n        if schedule:\n            max_time = max(r['s'] + r['d'] for r in schedule)\n\n        max_readers_count = 0\n        for t in range(max_time):\n            current_readers = [r for r in schedule if r['type'] == 'R' and r['s'] = t  r['s'] + r['d']]\n            current_writers = [r for r in schedule if r['type'] == 'W' and r['s'] = t  r['s'] + r['d']]\n            \n            num_r = len(current_readers)\n            num_w = len(current_writers)\n            \n            max_readers_count = max(max_readers_count, num_r)\n\n            if num_w > 1 or (num_w > 0 and num_r > 0):\n                is_valid = False\n                break\n        \n        # Fairness check\n        if is_valid:\n            for reader in schedule:\n                if reader['type'] == 'R':\n                    start_time = reader['s']\n                    for writer in schedule:\n                        if writer['type'] == 'W':\n                            # Writer was waiting if it arrived at or before reader start, and started after\n                            if writer['a'] = start_time and writer['s'] > start_time:\n                                is_valid = False\n                                break\n                    if not is_valid:\n                        break\n        \n        # Makespan calculation\n        min_arrival_time = min(r['a'] for r in schedule) if schedule else 0\n        max_completion_time = max(r['s'] + r['d'] for r in schedule) if schedule else 0\n        makespan = max_completion_time - min_arrival_time\n\n        all_results.append([is_valid, max_readers_count, makespan])\n\n    # Final formatting\n    result_str = \",\".join([f\"[{v},{r},{m}]\" for v, r, m in all_results])\n    print(f\"[{result_str}]\")\n\n\nsolve()\n```", "id": "2422634"}]}