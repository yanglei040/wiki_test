{"hands_on_practices": [{"introduction": "生产者-消费者问题是并发编程的基石，几乎所有复杂的协调模式都源于此。即使我们拥有信号量和互斥锁这样的正确工具，一个微小的顺序错误也可能导致系统不变量被破坏，引发灾难性后果。本练习旨在通过分析一个有缺陷的消费者实现，训练您追踪并发执行的能力，从而精确地定位并修复那些由不当操作顺序引起的竞态条件。[@problem_id:3687132]", "problem": "考虑一个使用计数信号量和二元互斥锁实现的经典有界缓冲区生产者-消费者问题。假设有两个生产者 $P_1$ 和 $P_2$ 以及一个消费者 $C$。缓冲区的容量为 $B$，共享整数 $count$ 跟踪已占用槽位的数量。系统使用计数信号量 $empty$ 和 $full$，其初始值分别为 $empty = B - count$ 和 $full = count$，以及一个保护缓冲区和 $count$ 的二元互斥锁 $m$。原语的语义如下：$\\text{wait}(s)$ 原子地将信号量 $s$ 减一，如果其值为 $0$ 则阻塞；$\\text{signal}(s)$ 原子地将 $s$ 加一，并唤醒一个被阻塞的线程（如果有的话）。关键的正确性不变量是 $0 \\le count \\le B$ 始终成立，并且对缓冲区和 $count$ 的修改仅在持有 $m$ 时发生。\n\n假设生产者的预期序列如下：\n- $\\text{wait}(empty)$，然后 $\\text{wait}(m)$，然后向缓冲区中 $\\text{put}$，然后 $count := count + 1$，然后 $\\text{signal}(m)$，然后 $\\text{signal}(full)$。\n\n然而，消费者的实现不正确，它会过早地发出 $\\text{signal}(empty)$：\n- $\\text{wait}(full)$，然后 $\\text{signal}(empty)$，然后 $\\text{wait}(m)$，然后从缓冲区中 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n\n从科学上一致的初始状态 $B = 2$, $count = 2$, $empty = 0$, $full = 2$ 开始，并且 $P_1$ 和 $P_2$ 最初都阻塞在 $\\text{wait}(empty)$ 上，构造一个交错执行序列，说明 $C$ 过早执行 $\\text{signal}(empty)$ 如何导致违反不变量 $count \\le B$。然后，确定一个修正后的消费者序列，该序列通过遵守互斥和容量语义，确保在所有交错执行下不变量 $0 \\le count \\le B$ 都得以保持。\n\n以下哪个选项既\n- 提供了一个具体的交错执行序列（在上述有缺陷的消费者的情况下）使得 $count$ 超过 $B$，\n- 又提出了一个修正后的消费者操作顺序，以防止在任何交错执行下发生此类违规？\n\nA. 演示违规的交错执行，然后是修正后的消费者：\n- 交错执行：\n  - $C$：执行 $\\text{wait}(full)$，然后执行 $\\text{signal}(empty)$。\n  - $P_1$：执行 $\\text{wait}(empty)$，然后执行 $\\text{wait}(m)$，然后执行 $\\text{put}$，然后 $count := count + 1$ 使得当 $B=2$ 时 $count=3$，然后执行 $\\text{signal}(m)$，然后执行 $\\text{signal}(full)$。\n- 修正后的消费者序列：\n  - $\\text{wait}(full)$，然后 $\\text{wait}(m)$，然后 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$，然后 $\\text{signal}(empty)$。\n\nB. 没有违规的交错执行，然后是不正确的消费者修正：\n- 交错执行：\n  - $C$：执行 $\\text{wait}(full)$，然后 $\\text{wait}(m)$，然后 $\\text{signal}(empty)$，然后 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n  - $P_1$：执行 $\\text{wait}(empty)$，然后 $\\text{wait}(m)$，然后 $\\text{put}$，然后 $count := count + 1$。\n- 提议的消费者修正（仍然过早）：\n  - $\\text{wait}(full)$，然后 $\\text{signal}(empty)$，然后 $\\text{wait}(m)$，然后 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n\nC. 演示违规的交错执行，然后是不正确的消费者修正：\n- 交错执行：\n  - $C$：执行 $\\text{wait}(full)$，然后执行 $\\text{signal}(empty)$。\n  - $P_1$：执行 $\\text{wait}(empty)$，然后执行 $\\text{wait}(m)$。\n  - $C$：执行 $\\text{wait}(m)$，因 $P_1$ 持有 $m$ 而阻塞。\n  - $P_1$：执行 $\\text{put}$，然后 $count := count + 1$ 使得当 $B=2$ 时 $count=3$，然后执行 $\\text{signal}(m)$。\n- 提议的消费者修正（将 $\\text{take}$ 移到互斥区之外）：\n  - $\\text{wait}(full)$，然后 $\\text{take}$，然后 $\\text{wait}(m)$，然后 $count := count - 1$，然后 $\\text{signal}(empty)$，然后 $\\text{signal}(m)$。\n\nD. 使用过早的 $\\text{signal}(full)$ 演示违规的交错执行，然后是不正确的消费者修正：\n- 交错执行：\n  - $C$：执行 $\\text{wait}(full)$，然后 $\\text{signal}(full)$，然后 $\\text{wait}(m)$。\n  - $P_1$：执行 $\\text{wait}(full)$ 成功，然后执行 $\\text{wait}(m)$，然后执行 $\\text{put}$，然后 $count := count + 1$ 使得当 $B = 2$ 时 $count = 3$。\n- 提议的消费者修正（顺序错误且缺少 $\\text{signal}(empty)$）：\n  - $\\text{wait}(full)$，然后 $\\text{wait}(m)$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n\n选择唯一的最佳选项。", "solution": "在继续之前，对问题陈述进行验证。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 进程：两个生产者 $P_1$ 和 $P_2$，一个消费者 $C$。\n- 缓冲区容量：$B$。\n- 共享状态：一个整数 $count$ 跟踪已占用槽位的数量。\n- 同步原语：\n    - 计数信号量 $empty$，初始化为 $B - count$。\n    - 计数信号量 $full$，初始化为 $count$。\n    - 二元互斥锁 $m$。\n- 原语语义：\n    - $\\text{wait}(s)$：原子地将信号量 $s$ 减一，如果其值为 $0$ 则阻塞。\n    - $\\text{signal}(s)$：原子地将 $s$ 加一，并唤醒一个被阻塞的线程（如果有的话）。\n- 正确性不变量：$0 \\le count \\le B$ 必须始终成立。\n- 生产者逻辑：$\\text{wait}(empty)$，然后 $\\text{wait}(m)$，然后向缓冲区 $\\text{put}$，然后 $count := count + 1$，然后 $\\text{signal}(m)$，然后 $\\text{signal}(full)$。\n- 有缺陷的消费者逻辑：$\\text{wait}(full)$，然后 $\\text{signal}(empty)$，然后 $\\text{wait}(m)$，然后从缓冲区 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n- 特定的初始状态：$B = 2$, $count = 2$, $empty = 0$, $full = 2$。$P_1$ 和 $P_2$ 最初都阻塞在 $\\text{wait}(empty)$ 上。互斥锁 $m$ 假定为可用（值为 $1$）。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在科学上基于并发编程和操作系统的原理。它描述了一个经典的同步问题（有界缓冲区），使用了标准的原语（信号量，互斥锁）。术语精确客观。提供的初始状态 ($B=2, count=2, empty=0, full=2$) 与定义 ($empty=B-count=2-2=0$; $full=count=2$) 一致。问题提取得当，要求提供一个特定的执行轨迹来展示一个缺陷以及一个修正后的代码序列。在软件背景下，该设置并非不完整、矛盾或不切实际。它代表了一种常见的编程错误类型。\n\n**步骤 3：结论与行动**\n问题陈述有效。将推导解决方案。\n\n### 解决方案的推导\n\n问题的核心在于有缺陷的消费者 $C$ 和一个生产者（比如 $P_1$）之间的交互。需要被违反的不变量是 $count \\le B$。我们需要展示一个交错执行如何能导致 $count  2$。\n\n**1. 缺陷分析**\n\n标准的生产者-消费者解决方案使用 $empty$ 和 $full$ 信号量来强制执行缓冲区容量约束。生产者在生产前必须等待一个空槽位（通过调用 $\\text{wait}(empty)$），而消费者在消费前必须等待一个满槽位（通过调用 $\\text{wait}(full)$）。\n\n- **生产者**逻辑是正确的：它等待一个空槽位（$\\text{wait}(empty)$），获取一个锁（$\\text{wait}(m)$）来更新共享状态，添加一个物品并增加 $count$，释放锁（$\\text{signal}(m)$），最后发出一个槽位已满的信号（$\\text{signal}(full)$）。\n- **消费者**逻辑是有缺陷的。操作 $\\text{wait}(full)$ 和 $\\text{signal}(empty)$ 在概念上应该包围消费物品的过程。然而，给出的序列是 $\\text{wait}(full)$，然后 $\\text{signal}(empty)$，然后 $\\text{wait}(m)$ 等。消费者在它实际获取锁 $m$ 并从缓冲区中移除物品*之前*，就发出了一个槽位已空的信号。这造成了一个竞争条件。消费者宣告了一个尚不存在的资源（一个空槽位）。\n\n**2. 构造一个违规的交错执行**\n\n让我们从初始状态开始追踪一次执行：$B=2$, $count=2$, $empty=0$, $full=2$, $m=1$。$P_1$ 和 $P_2$ 阻塞在 $\\text{wait}(empty)$ 上。\n\n1.  $C$ 开始执行。生产者被阻塞，所以它们不能运行。\n2.  $C$ 执行 $\\text{wait}(full)$。$full$ 的值为 $2$，所以调用成功，$full$ 减为 $1$。\n3.  $C$ 执行其有缺陷的指令：$\\text{signal}(empty)$。$empty$ 的值原为 $0$。此调用将 $empty$ 增为 $1$。由于 $P_1$（或 $P_2$）阻塞在该信号量上，操作系统会解除 $P_1$ 的阻塞。$P_1$ 现在处于就绪状态，已经完成了它的 $\\text{wait}(empty)$ 调用。\n4.  此时发生上下文切换，调度器选择运行 $P_1$。消费者 $C$ 在执行 $\\text{wait}(m)$ 之前被抢占。\n5.  $P_1$ 执行它的下一条指令 $\\text{wait}(m)$。互斥锁 $m$ 可用（值为 $1$），所以 $P_1$ 获取了它，$m$ 的值变为 $0$。$P_1$ 现在处于其临界区内。\n6.  在其临界区内，$P_1$ 执行一个 $\\text{put}$ 操作。缓冲区本已满，现在溢出了。\n7.  $P_1$ 执行 $count := count + 1$。$count$ 的值原为 $2$。现在它被增加到 $3$。\n8.  此时，不变量 $count \\le B$ 被违反，因为 $count = 3$ 而 $B = 2$。违规已经发生。$P_1$ 剩余的执行序列（$\\text{signal}(m)$, $\\text{signal}(full)$）以及最终 $C$ 的执行（它将在 $\\text{wait}(m)$ 上阻塞，直到 $P_1$ 释放它）不会改变这个事实。\n\n这个交错执行成功地演示了违规情况。\n\n**3. 提出修正后的消费者序列**\n\n为了修复这个错误，消费者必须在完成移除一个物品并相应更新共享变量 $count$ *之后*，才能发出信号表示一个槽位变空了。对共享状态（缓冲区和 $count$）的修改必须由互斥锁 $m$ 保护。因此，$\\text{signal}(empty)$ 调用必须移到临界区之后。\n\n正确的、标准的消费者序列是：\n1.  $\\text{wait}(full)$: 等待缓冲区中至少有一个物品。\n2.  $\\text{wait}(m)$: 获取锁以访问共享状态。\n3.  $\\text{take}$: 从缓冲区中移除一个物品。\n4.  $count := count - 1$: 将物品计数减一。\n5.  $\\text{signal}(m)$: 释放锁。\n6.  $\\text{signal}(empty)$: 向生产者发信号，表示一个槽位已空出。\n\n这个顺序确保了信号量 $empty$ 正确地表示可用槽位的数量，从而防止了导致违规的竞争条件。\n\n### 逐项分析选项\n\n**A. 演示违规的交错执行，然后是修正后的消费者：**\n- **交错执行：** 所描述的交错执行（$C$ 运行 $\\text{wait}(full)$，然后 $\\text{signal}(empty)$；然后 $P_1$ 醒来，获取 $m$，并将 $count$ 增加到 $3$）与上面推导出的违规轨迹完全匹配。这部分是正确的。\n- **修正后的消费者序列：** 提议的序列是 $\\text{wait}(full)$，$\\text{wait}(m)$，$\\text{take}$，$count := count - 1$，$\\text{signal}(m)$，$\\text{signal}(empty)$。这是标准的正确实现，如上所述。这部分是正确的。\n- **结论：** **正确**。\n\n**B. 没有违规的交错执行，然后是不正确的消费者修正：**\n- **交错执行：** 这里描述了一个 $C$ 在上下文切换前获取互斥锁的交错执行。如分析所示，这个特定的交错执行不会产生违规。任务是展示一个*确实*会产生违规的交错执行。这部分未能完成任务。\n- **提议的消费者修正：** 提议的“修正”与原始的有缺陷序列相同。这部分是不正确的。\n- **结论：** **不正确**。\n\n**C. 演示违规的交错执行，然后是不正确的消费者修正：**\n- **交错执行：** 这个交错执行的描述比选项 A 更详细一些（明确显示了 $C$ 在 $m$ 上阻塞），但它在概念上是同样正确的违规演示。这部分是正确的。\n- **提议的消费者修正：** 提议的序列是 $\\text{wait}(full)$，然后 $\\text{take}$，然后 $\\text{wait}(m)$，... 这有严重缺陷。$\\text{take}$ 操作修改了共享缓冲区，但被放置在由互斥锁 $m$ 保护的临界区之外。这引入了另一种竞争条件。这部分是不正确的。\n- **结论：** **不正确**。\n\n**D. 使用过早的 `signal(full)` 演示违规的交错执行，然后是不正确的消费者修正：**\n- **交错执行：** 该交错执行描述了一个不同的错误，即过早的 $\\text{signal}(full)$。问题明确指出错误是过早的 $\\text{signal}(empty)$。此外，它错误地声称生产者在 `full` 上等待，而实际上它们在 `empty` 上等待。这部分与问题陈述不一致。\n- **提议的消费者修正：** 提议的修正缺少 $\\text{take}$ 操作和 $\\text{signal}(empty)$ 调用，这将最终导致系统死锁，因为生产者永远不会被通知。这部分是不正确的。\n- **结论：** **不正确**。\n\n基于分析，选项 A 是唯一一个既通过有效的交错执行正确演示了违规情况，又为消费者逻辑提供了标准、正确修复方案的选项。", "answer": "$$\\boxed{A}$$", "id": "3687132"}, {"introduction": "哲学家就餐问题是用于阐释死锁的经典隐喻，它形象地展示了多个进程如何因争夺有限资源而陷入集体停滞。然而，避免死锁只是故事的一部分；一个没有死锁的系统仍然可能是不公平的，导致某些进程永远无法获得所需资源，即“饿死”。本练习通过分析一种著名的非对称资源获取策略，挑战您超越死锁的范畴，深入思考系统的活性（liveness）和公平性（fairness）属性，并理解避免死锁与保证系统对所有参与者公平之间的重要区别。[@problem_id:3625780]", "problem": "考虑经典的哲学家就餐问题，有 $n$ 位哲学家，标记为 $P_0, P_1, \\dots, P_{n-1}$，围绕一张圆桌而坐。叉子 $F_i$ 位于哲学家 $P_i$ 和 $P_{(i+1) \\bmod n}$ 之间。每位哲学家永远在三个阶段中循环：思考、变饿和吃饭。吃饭需要独占访问相邻的两把叉子。系统使用一种非对称的叉子拾取策略：索引为偶数 $i$ 的哲学家首先尝试拿起他们的右叉 $F_i$，然后是左叉 $F_{i-1}$；索引为奇数 $i$ 的哲学家首先尝试拿起他们的左叉 $F_{i-1}$，然后是右叉 $F_i$。获取叉子是阻塞的：一旦哲学家持有一把叉子，他们会等待直到第二把可用；只有在吃完饭后才会释放叉子。假设除了这个非对称规则之外，没有全局协调。一个抢占式调度器在每个瞬间选择哪个哲学家运行，并且可能是不公平的（它被允许无限制地偏爱某些就绪的哲学家而不是其他哲学家）。吃饭时间是有限的，并以 $\\Delta  0$ 为界，思考时间是有限的，并以 $\\tau  0$ 为界。\n\n用于推理的基本定义：\n- 互斥：在任何时候，每把叉子 $F_i$ 最多只能由1位哲学家持有。\n- 死锁：一种状态，其中一个非空哲学家集合中的每个哲学家都至少持有1把叉子，并永远等待另一把叉子，从而无法取得任何进一步的进展（吃饭）。\n- 有界等待（公平性）：存在一个有限的界限 $B$，使得对于任何哲学家，从他们变饿到他们吃饭之间，最多只能有 $B$ 个其他吃饭操作完成。\n\n专注于 $n = 5$ 的情况，哲学家为 $P_0, P_1, P_2, P_3, P_4$。在上述非对称策略下，哪个选项正确地指出了一个调度器行为和结果，该行为和结果展示了对有界等待公平性的违反（即哲学家饿死），同时系统保持无死锁状态？\n\nA. 调度器在 $P_0$ 饥饿时，对抗性地交替运行 $P_1$ 和 $P_4$：每当 $P_0$ 持有 $F_4$ 并准备尝试获取 $F_0$ 时，调度器运行 $P_1$（奇数，先拿左叉）以抢占 $F_0$；当 $P_0$ 持有 $F_0$ 并准备尝试获取 $F_4$ 时，调度器运行 $P_4$（偶数，先拿右叉）以抢占 $F_4$。这确保了 $P_0$ 的至少一个邻居总是持有 $P_0$ 接下来需要的叉子，因此 $P_0$ 永远无法获得两把叉子而持续饥饿，而其他人则无限期地吃饭；不会发生死锁，因为总有哲学家在继续吃饭。\n\nB. 非对称策略消除了循环等待，因此对于任何 $n$ 和任何调度器都保证了无死锁和有界等待；饥饿不会发生。\n\nC. 增加一个值为 $n-1$ 的全局信号量，限制同时饥饿的哲学家数量，再结合非对称策略，保证在任何调度器下都不会发生饥饿，因为最多只有 $n-1$ 位哲学家可以同时竞争叉子。\n\nD. 对于奇数 $n$，在非对称策略下，奇偶性的差异意味着邻居们竞争的是相反的“第一把”叉子，这迫使所有人最终都能取得进展；因此，即使是不公平的调度器也无法导致任何哲学家饿死。", "solution": "用户提供了一个经典的哲学家就餐问题的变体，并要求找出一个在没有死锁的情况下展示饥饿现象的场景。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n*   **系统**：经典的哲学家就餐问题，有 $n$ 位哲学家，$P_0, P_1, \\dots, P_{n-1}$。\n*   **资源**：$n$ 把叉子，其中叉子 $F_i$ 位于哲学家 $P_i$ 和 $P_{(i+1) \\bmod n}$ 之间。\n*   **资源需求**：哲学家 $P_i$ 需要独占访问其左边的叉子 $F_{(i-1) \\bmod n}$ 和右边的叉子 $F_i$ 才能吃饭。\n*   **非对称叉子拾取策略**：\n    *   索引为偶数 $i$ 的哲学家首先尝试拿起他们的右叉 ($F_i$)，然后是左叉 ($F_{(i-1) \\bmod n}$)。\n    *   索引为奇数 $i$ 的哲学家首先尝试拿起他们的左叉 ($F_{(i-1) \\bmod n}$)，然后是右叉 ($F_i$)。\n*   **获取协议**：叉子获取是阻塞的。哲学家在等待第二把叉子时会一直持有着第一把。只有在吃完饭后才会释放叉子。\n*   **调度器**：抢占式，且可能是不公平的（可以无限期地忽略一个就绪的哲学家，而偏向于其他哲学家）。\n*   **时间界限**：吃饭时间是有限的，并以 $\\Delta  0$ 为界。思考时间是有限的，并以 $\\tau  0$ 为界。\n*   **案例研究**：$n=5$，哲学家为 $P_0, P_1, P_2, P_3, P_4$。\n*   **定义**：\n    *   **互斥**：标准定义，每把叉子一次只能有一个使用者。\n    *   **死锁**：一个非空集合的哲学家陷入循环等待，阻止任何进一步的进展。\n    *   **有界等待（公平性）**：一个饥饿的哲学家将在有界数量的其他哲学家吃完饭后能够吃饭。违反此规则即为饥饿。\n*   **问题**：找出哪个选项正确描述了一种调度器行为，该行为会导致违反有界等待（饥饿）但无死锁。\n\n**步骤2：使用提取的已知条件进行验证**\n\n*   **科学依据**：该问题是计算机科学中的一个经典问题，用于说明如死锁和饥饿等同步问题。非对称解决方案是一种标准技术。在不同调度假设下对其属性的分析是该主题的核心部分。该问题具有科学依据。\n*   **问题明确**：该问题提供了一个具体的算法（非对称策略）和系统参数（抢占式、不公平调度器），并要求分析其属性（死锁与饥饿）。这是一个问题明确且有逻辑可推导答案的问题。\n*   **客观性**：该问题使用操作系统领域的精确、客观的语言进行陈述。\n*   **结论**：问题陈述有效。它自成一体、前后一致，并基于已建立的计算机科学原理。\n\n### 解题推导\n\n首先，让我们确定在 $n=5$ 的情况下每位哲学家的拿叉顺序：\n*   $P_0$ (偶数)：尝试右叉 $F_0$，然后左叉 $F_4$。\n*   $P_1$ (奇数)：尝试左叉 $F_0$，然后右叉 $F_1$。\n*   $P_2$ (偶数)：尝试右叉 $F_2$，然后左叉 $F_1$。\n*   $P_3$ (奇数)：尝试左叉 $F_2$，然后右叉 $F_3$。\n*   $P_4$ (偶数)：尝试右叉 $F_4$，然后左叉 $F_3$。\n\n**死锁分析**\n这种策略是已知的无死锁策略。死锁需要一个哲学家环路，其中每个哲学家都持有一把叉子并等待环路中下一个哲学家持有的叉子。使用这种策略无法形成这样的环路。快速分析表明，对叉子存在一个偏序关系，可以防止环路。例如，考虑对叉子 $F_4$ 的争用，它被 $P_0$（第二选择）和 $P_4$（第一选择）需要。如果两者同时变饿，$P_4$ 总能比 $P_0$ 更早地占有 $F_4$，因为 $P_0$ 必须先获得 $F_0$ 才能请求 $F_4$。这种强制的顺序打破了形成涉及所有哲学家的“持有并等待”环路所需的对称性。问题陈述正确地假设系统是无死锁的。\n\n**有界等待（饥饿）分析**\n问题明确指出调度器是*不公平*的。这一点至关重要。不公平的调度器可以无限期地忽略一个已经就绪的哲学家。我们可以利用这一点来构造一个哲学家饿死的场景。让我们专注于让 $P_0$ 饿死。\n\n$P_0$ 需要叉子 $F_0$ 和 $F_4$。它们分别与邻居 $P_1$ 和 $P_4$ 共享。\n*   $P_1$ 与 $P_0$ 竞争 $F_0$，并且两者都试图将其作为第一把叉子拿起。\n*   $P_4$ 与 $P_0$ 竞争 $F_4$。$P_4$ 试图首先拿起它，而 $P_0$ 试图第二步拿起它。\n\n一个对抗性的调度器可以按以下方式使 $P_0$ 饿死：\n1.  让 $P_0$ 变饿。它已准备好运行并尝试获取 $F_0$。\n2.  调度器可以选择让 $P_0$ 成功。$P_0$ 获得 $F_0$，现在等待 $F_4$。\n3.  调度器现在激活 $P_4$，$P_4$ 刚结束其（可能非常短的）思考时间，现在也饿了。\n4.  $P_4$ 的第一个动作是获取 $F_4$。由于 $F_4$ 是空闲的，$P_4$ 成功。\n5.  此时，$P_0$ 持有 $F_0$ 并被阻塞等待 $F_4$。$P_4$ 持有 $F_4$ 并等待 $F_3$。\n6.  系统没有死锁。例如，假设 $P_3$ 正在思考，$F_3$ 是空闲的。调度器可以允许 $P_4$ 获取 $F_3$ 并吃饭。\n7.  吃完饭（耗时 $\\Delta$）后，$P_4$ 释放 $F_4$ 和 $F_3$，并开始思考。\n8.  现在，$F_4$ 空闲了，而 $P_0$（仍持有 $F_0$）正在等待它。如果调度器运行 $P_0$，$P_0$ 将获得 $F_4$ 并吃饭。\n9.  然而，不公平的调度器可以拒绝运行 $P_0$。它可以等待 $P_4$ 完成其最短思考时间 $\\tau$，再次变饿，然后运行 $P_4$。\n10. $P_4$ 将再次获取 $F_4$ 作为它的第一把叉子，再次阻塞 $P_0$。\n\n这个循环可以无限重复。$P_4$ 反复吃饭，而 $P_0$ 持有 $F_0$ 并因等待 $F_4$ 而饿死。因为 $P_0$ 永久持有 $F_0$，它的另一个邻居 $P_1$ 也会饿死，因为 $P_1$ 永远无法获得它的第一把叉子 $F_0$。但系统中仍然有进展（例如，$P_4$ 和 $P_2$ 可以吃饭），所以没有死锁，但存在饥饿，这是对有界等待的违反。\n\n### 逐项分析\n\n**A. 调度器在 $P_0$ 饥饿时，对抗性地交替运行 $P_1$ 和 $P_4$：每当 $P_0$ 持有 $F_4$ 并准备尝试获取 $F_0$ 时，调度器运行 $P_1$（奇数，先拿左叉）以抢占 $F_0$；当 $P_0$ 持有 $F_0$ 并准备尝试获取 $F_4$ 时，调度器运行 $P_4$（偶数，先拿右叉）以抢占 $F_4$。这确保了 $P_0$ 的至少一个邻居总是持有 $P_0$ 接下来需要的叉子，因此 $P_0$ 永远无法获得两把叉子而持续饥饿，而其他人则无限期地吃饭；不会发生死锁，因为总有哲学家在继续吃饭。**\n\n这个选项正确地得出结论：通过邻居的对抗性调度，可能在没有死锁的情况下发生饥饿。它描述的第二种情景，“当 $P_0$ 持有 $F_0$ 并准备尝试获取 $F_4$ 时，调度器运行 $P_4$ ... 以抢占 $F_4$”，是使 $P_0$ 饿死的一个有效机制，如上面的推导所示。然而，第一种情景，“每当 $P_0$ 持有 $F_4$ 并准备尝试获取 $F_0$ 时”，描述了一个在给定策略下不可能发生的状态（$P_0$ 必须在 $F_4$ *之前*尝试获取 $F_0$）。尽管在一个子句中存在这个事实上的不准确之处，该选项正确地指出了系统的根本弱点：一个不公平的调度器可以利用哲学家的邻居来制造一个与死锁不同的饥饿场景。在给定的选项中，这个选项对该现象提供了最准确的高层描述。\n\n结论：**正确**，尽管其描述中存在明显的不精确之处。\n\n**B. 非对称策略消除了循环等待，因此对于任何 $n$ 和任何调度器都保证了无死锁和有界等待；饥饿不会发生。**\n\n这个选项不正确。虽然非对称策略通过消除循环等待确实可以防止死锁，但它本身并不能保证有界等待（即防止饥饿）。免于饥饿需要一个公平的调度策略，而问题陈述中明确指出不保证这一点。\n\n结论：**不正确**。\n\n**C. 增加一个值为 $n-1$ 的全局信号量，限制同时饥饿的哲学家数量，再结合非对称策略，保证在任何调度器下都不会发生饥饿，因为最多只有 $n-1$ 位哲学家可以同时竞争叉子。**\n\n管家/主人算法（将并发哲学家数量限制为 n-1）可以防止死锁。然而，如果没有公平的调度器，它并不能保证免于饥饿。一个不公平的调度器仍然可以永久地偏爱 n-2 个哲学家的子集，使剩下的一个饿死，尽管那个哲学家有机会吃饭。声称它“在任何调度器下都保证免于饥饿”是错误的。\n\n结论：**不正确**。\n\n**D. 对于奇数 $n$，在非对称策略下，奇偶性的差异意味着邻居们竞争的是相反的“第一把”叉子，这迫使所有人最终都能取得进展；因此，即使是不公平的调度器也无法导致任何哲学家饿死。**\n\n该选项提出了一个事实不正确的前提。让我们检查 $n=5$ 时相邻的哲学家 $(P_i, P_{(i+1) \\bmod n})$。\n*   考虑邻居 $P_0$（偶数）和 $P_1$（奇数）。$P_0$ 的第一选择是叉子 $F_0$。$P_1$ 的第一选择也是叉子 $F_0$。他们竞争的是*相同*的第一把叉子，而不是相反的。\n*   考虑邻居 $P_2$（偶数）和 $P_3$（奇数）。$P_2$ 的第一选择是叉子 $F_2$。$P_3$ 的第一选择也是叉子 $F_2$。\n由于论证的前提是错误的，所以结论是站不住脚的。\n\n结论：**不正确**。\n\n### 结论\n\n选项 B、C 和 D 对并发原则做出了根本性的错误论断。选项 A 正确地指出，在不公平的调度器下，指定的策略容易导致饥饿（违反有界等待），尽管它是无死锁的。虽然它对饥饿场景的描述在一个可能的系统状态方面包含一个重大错误，但它是唯一一个正确指出了所讨论的失败模式的可能性和一般机制的选项。因此，它是所提供的最佳答案。", "answer": "$$\\boxed{A}$$", "id": "3625780"}, {"introduction": "在解决了经典的学术问题后，我们将注意力转向一个在现代并发系统中极为常见的实际挑战：将持有的读锁（shared mode）“升级”为写锁（exclusive mode）。这个看似简单的功能需求，如果设计不当，极易创造出死锁的条件——例如，当多个读者同时尝试升级时。本练习将理论与实践相结合，要求您运用关于死锁的科夫曼（Coffman）条件来设计一个健壮的同步协议，通过引入一个门控机制来序列化升级请求，从而打破循环等待条件，有效防止这种常见的死锁陷阱。[@problem_id:3625789]", "problem": "一个共享的内存数据结构由一个读写锁（RWLock）保护。线程可以以共享模式（用 $R$ 表示）获取锁以进行并发读取，或者以独占模式（用 $W$ 表示）获取锁以进行互斥写入。我们希望支持一种“升级”操作，即持有 $R$ 锁的线程可以晋升为 $W$ 锁，而无需在此期间释放锁，从而使其读后写临界区是可线性化的。升级操作必须确保在读取和随后的写入之间没有其他 $W$ 操作插入。假设存在以下基础模型和事实：\n- $W$ 的互斥性：如果存在一个 $W$ 锁持有者，那么并发读者的数量 $r$ 为 $0$，并且最多只有 $1$ 个写入者处于活动状态。\n- $R$ 的共享访问：如果不存在 $W$ 锁持有者，任何数量的读者都可以持有 $R$ 锁。\n- 提供原子性的读-修改-写操作，特别是比较并交换（CAS）。\n- 等待写入者和升级者的队列是先入先出（FIFO）的。\n- 弱公平性：一个持续保持可调度状态的线程最终会被调度；没有线程会永远持有锁。\n- 升级的可线性化：从 $R$ 升级到 $W$ 的线程必须表现得如同其 $R$ 临界区和其 $W$ 临界区是连续的，中间没有其他线程的 $W$ 操作介入。\n- 经典的读者-写入者约束和导致死锁的 Coffman 条件适用：死锁可能在互斥、持有并等待、无抢占和循环等待的条件下出现。\n\n考虑当多个持有 $R$ 锁的线程同时尝试升级时发生死锁的风险。要求您选择一个协议，在上述假设下，既能保证升级请求的无死锁和进展（无饿死），同时又能保持可线性化的要求。\n\n哪个选项描述了一个正确的升级协议，既能防止死锁又能确保升级者的进展？\n\nA. 每个升级者持有其 $R$ 锁，设置一个线程级别的“正在升级”标志，并忙等待直到读者数量 $r$ 变为 $1$，然后原子地晋升为 $W$ 锁。当任何升级者在等待时，新读者正常进入。允许多个同时进行的升级者。\n\nB. 最多只有 $1$ 个升级者在等待时持有 $R$ 锁：一个升级者首先尝试使用 CAS 设置一个全局的 `UpgradePending` 标志；如果 CAS 成功，它继续持有其 $R$ 锁，并且当 `UpgradePending` 被设置或有任何写入者在等待时，所有新读者都会被阻塞。该升级者等待直到 $r=1$ 并且没有活动的 $W$ 锁，然后原子地晋升为 $W$ 锁，完成其写入，清除 `UpgradePending` 标志，并唤醒下一个等待者。如果 CAS 失败（另一个升级者已持有该门控），该线程释放 $R$ 锁并在写入者 FIFO 队列中排队。写入者和升级者按 FIFO 顺序服务，当写入者或升级者在排队时，新读者被阻塞。\n\nC. 升级者总是释放其 $R$ 锁，然后在现有写入者之后作为写入者入队，对新读者没有特殊的准入策略或障碍。当它到达写入者队列的头部时，它获得 $W$ 锁。\n\nD. 允许多个同时进行的升级者，并且它们被赋予比写入者更高的严格优先级，但新读者从不被阻塞。每个升级者在 $r \\neq 1$ 时忙等待，然后在可能时原子地晋升为 $W$ 锁。写入者在任何升级者之后等待；读者总是继续被允许进入。\n\n选择唯一的最佳选项。", "solution": "用户希望我扮演一名 STEM 教授，解决一个关于操作系统中读写锁升级协议的问题。\n\n### 问题验证\n\n首先，我必须验证问题陈述。\n\n**步骤1：提取给定信息**\n\n- 一个共享的内存数据结构由一个读写锁（RWLock）保护。\n- 共享模式用 $R$ 表示（并发读取）。\n- 独占模式用 $W$ 表示（互斥写入）。\n- 一个“升级”操作允许持有 $R$ 的线程在不释放锁的情况下晋升为 $W$。\n- 升级的目标是使读后写临界区可线性化。\n- 对升级的约束：在读取和产生的写入之间不能插入其他 $W$ 操作。\n- $W$ 的互斥性：如果存在一个 $W$ 锁持有者，并发读者数量 $r$ 为 $0$，并且最多只有 $1$ 个写入者处于活动状态。\n- $R$ 的共享访问：如果不存在 $W$ 锁持有者，任何数量的读者都可以持有 $R$ 锁。\n- 原子操作：提供比较并交换（CAS）。\n- 队列：等待的写入者和升级者按先入先出（FIFO）顺序服务。\n- 公平性：假设为弱公平性（一个持续可调度的线程最终会被调度）。没有线程会永远持有锁。\n- 升级的可线性化：$R$ 临界区和随后的 $W$ 临界区必须看起来是连续的，中间没有其他线程的 $W$ 操作介入。\n- 死锁背景：问题提到了 Coffman 死锁条件（互斥、持有并等待、无抢占、循环等待）的相关性。\n\n**步骤2：使用提取的给定信息进行验证**\n\n- **科学性：** 该问题是并发编程和操作系统中的一个经典且基础的课题。读写锁、锁升级、死锁、饿死、可线性化以及像 CAS 这样的原子操作都是计算机科学中公认的概念。该问题在科学上是合理的。\n- **良构性（Well-Posed）：** 该问题是良构的。它清晰地定义了初始状态（一个 RWLock 模型）、期望的操作（一个可线性化的升级）、约束条件（无死锁、有进展）以及可用的工具（CAS、FIFO 队列）。问题要求找到一个满足这些特定需求的协议。\n- **客观性：** 语言正式且客观。术语以其精确的技术含义使用。\n- **完整性和一致性：** 问题提供了足够的信息来分析所提出协议中死锁和饿死的可能性。对可线性化、无死锁和有进展的要求是相互一致的，并为并发原语构成了一套连贯的设计目标。\n- **未检测到其他缺陷：** 该问题并非不切实际、病态、微不足道或无法验证。它代表了并发系统中的一个真实世界设计挑战。\n\n**步骤3：结论与行动**\n\n问题陈述有效。我将继续进行解答。\n\n### 解答推导\n\n实现可升级读写锁的核心挑战是在确保进展和正确性（可线性化）的同时防止死锁。经典的死锁场景发生在两个或多个线程各自持有读锁（$R$），并同时尝试升级到写锁（$W$）时。\n\n让我们使用 Coffman 条件来分析这种死锁：\n1.  **互斥：** 写锁（$W$）根据定义是独占的。升级者需要独占访问权，但其他线程（读者或其他升级候选者）持有锁。\n2.  **持有并等待：** 升级者在*持有*其读锁（$R$）的同时，*等待*满足条件 $r=1$，这需要其他读者释放它们的锁。\n3.  **无抢占：** 问题规定升级操作“无需在此期间释放锁”，这是对所持有资源（$R$）的一种无抢占形式。\n4.  **循环等待：** 如果线程 $T_1$ 和线程 $T_2$ 都持有 $R$ 并都决定升级，$T_1$ 等待 $T_2$ 释放其 $R$ 锁（以便 $r$ 能变为 $1$），而 $T_2$ 同时等待 $T_1$ 释放其 $R$ 锁。这就形成了一个循环依赖。\n\n一个正确的协议必须打破这些条件中的至少一个。最实际可打破的条件是循环等待。这可以通过在任何时候只允许最多一个线程处于“尝试升级”状态来实现。\n\n此外，为了确保进展（活性），协议必须防止饿死。一个等待读者数量 $r$ 下降到 $1$ 的升级者可能会因为新读者不断被允许进入而饿死。因此，一个有效的协议必须在升级启动后暂时阻塞新读者。\n\n最后，为了实现可线性化，升级线程绝不能释放其 $R$ 锁然后重新获取一个 $W$ 锁。这样做会创建一个时间窗口，让另一个写入者可以介入，导致在 $R$ 锁下读取的数据对于后续的写操作可能已经过时。\n\n基于这些原则，一个正确的协议必须：\n1.  序列化升级尝试以防止循环等待死锁（例如，使用一个门控或一个特殊标志）。\n2.  在升级待处理期间阻塞新读者，以保证读者数量会耗尽，升级者将取得进展。\n3.  确保升级者在不释放锁的情况下从 $R$ 过渡到 $W$，以保持可线性化。\n4.  采用公平的排队机制，以防止写入者和潜在升级者之间发生饿死。\n\n### 逐项分析\n\n**A. 每个升级者持有其 $R$ 锁，设置一个线程级别的“正在升级”标志，并忙等待直到读者数量 $r$ 变为 $1$，然后原子地晋升为 $W$ 锁。当任何升级者在等待时，新读者正常进入。允许多个同时进行的升级者。**\n\n-   **死锁：** “允许多个同时进行的升级者。” 该协议直接造成了上述的死锁场景。如果两个线程持有 $R$ 锁并尝试升级，它们将无限期地相互等待。\n-   **进展：** “新读者正常进入”。这可能导致升级者饿死。持续不断的新读者流可以阻止读者数量 $r$ 降到 $1$。\n-   **结论：** **错误**。\n\n**B. 最多只有 $1$ 个升级者在等待时持有 $R$ 锁：一个升级者首先尝试使用 CAS 设置一个全局的 `UpgradePending` 标志；如果 CAS 成功，它继续持有其 $R$ 锁，并且当 `UpgradePending` 被设置或有任何写入者在等待时，所有新读者都会被阻塞。该升级者等待直到 $r=1$ 并且没有活动的 $W$ 锁，然后原子地晋升为 $W$ 锁，完成其写入，清除 `UpgradePending` 标志，并唤醒下一个等待者。如果 CAS 失败（另一个升级者已持有该门控），该线程释放 $R$ 锁并在写入者 FIFO 队列中排队。写入者和升级者按 FIFO 顺序服务，当写入者或升级者在排队时，新读者被阻塞。**\n\n-   **死锁：** “最多只有 $1$ 个升级者在等待时持有 $R$ 锁”。这是通过对全局 `UpgradePending` 标志进行原子性 CAS 操作来强制执行的。这个机制作为一个门控，序列化了升级尝试，从而打破了循环等待条件。升级者之间的死锁被防止了。\n-   **进展：** “当 `UpgradePending` 被设置或有任何写入者在等待时，所有新读者都会被阻塞”。这确保了当前的读者数量会耗尽，保证条件 $r=1$ 最终会被满足，从而让升级者能够继续进行。对写入者和升级者使用 FIFO 队列确保了公平性并防止了饿死。\n-   **可线性化：** 成功的升级者（“如果 CAS 成功”）“继续持有其 $R$ 锁”并原子地晋升为 $W$ 锁。这通过确保没有其他写入者可以插入来满足可线性化的要求。对于 CAS 失败的备用路径（释放 $R$，作为写入者入队）是一种处理竞争而不死锁的策略；它中止了该线程的可线性化升级尝试，但允许系统公平地进展。协议本身正确地提供了一条可线性化升级的路径。\n-   **结论：** **正确**。\n\n**C. 升级者总是释放其 $R$ 锁，然后在现有写入者之后作为写入者入队，对新读者没有特殊的准入策略或障碍。当它到达写入者队列的头部时，它获得 $W$ 锁。**\n\n-   **可线性化：** “升级者总是释放其 $R$ 锁，然后在现有写入者之后作为写入者入队”。这明确违反了可线性化的要求。在释放 $R$ 锁和获取 $W$ 锁之间的时间间隔内，另一个线程可以获取一个 $W$ 锁，修改数据，然后释放它。升级线程最初的读取将与其最终的写入脱节。\n-   **进展：** “对新读者没有特殊的准入策略或障碍”。这创建了一个读者偏好系统，可能导致所有写入者饿死，包括那个试图升级的线程。\n-   **结论：** **错误**。\n\n**D. 允许多个同时进行的升级者，并且它们被赋予比写入者更高的严格优先级，但新读者从不被阻塞。每个升级者在 $r \\neq 1$ 时忙等待，然后在可能时原子地晋升为 $W$ 锁。写入者在任何升级者之后等待；读者总是继续被允许进入。**\n\n-   **死锁：** “允许多个同时进行的升级者”。与选项 A 一样，这重新引入了两个或多个升级线程之间的经典死锁。\n-   **进展：** “新读者从不被阻塞...读者总是继续被允许进入。” 与选项 A 一样，这会导致升级者饿死，因为读者数量 $r$ 可能永远不会降到 $1$。\n-   **结论：** **错误**。", "answer": "$$\\boxed{B}$$", "id": "3625789"}]}