{"hands_on_practices": [{"introduction": "使用原子指令构建锁只是并发编程的第一步。当一个程序需要管理多个受保护的资源时，获取这些锁的协议就变得至关重要。本练习将引导您分析一个经典场景：两个线程以不同的顺序获取两个锁。这个思想实验揭示了即使每个锁都正确实现了互斥，不一致的获取顺序也可能导致整个系统陷入僵局，即死锁。通过这个练习，您将掌握避免死锁的关键原则——锁序。[@problem_id:3686956]", "problem": "考虑一个操作系统（OS）中的并发程序，其中两个自旋锁使用硬件的测试并设置（test-and-set）指令实现互斥。测试并设置指令原子性地读取一个内存位置并将其设置为指定值，同时返回先前的值；当用于构建锁时，线程会一直自旋，直到该指令返回“未锁定”的值，然后将锁设置为“已锁定”的值。假设有两个锁，$L_A$ 和 $L_B$，分别保护两个不同的资源，$R_A$ 和 $R_B$。假设有两个线程，$T_1$ 和 $T_2$，调度在两个中央处理器（CPU）上，并且两个线程偶尔都需要联合访问 $R_A$ 和 $R_B$。由于遗留模块边界的原因，$T_1$ 在需要两个锁时首先获取 $L_A$，然后尝试获取 $L_B$；对称地，$T_2$ 在需要两个锁时首先获取 $L_B$，然后尝试获取 $L_A$。一旦线程持有一个锁，它将不会释放该锁，直到完成该资源的临界区，并且锁只能由持有线程自愿释放。\n\n从第一性原理出发，论证 test-and-set 的原子性、互斥和死锁条件（包括循环等待的可能性），并选择在此场景中所有正确的陈述。\n\nA. 当 $T_1$ 尝试先获取 $L_A$ 再获取 $L_B$，而 $T_2$ 尝试先获取 $L_B$ 再获取 $L_A$ 时，可能会发生死锁，因为互斥、持有并等待、无抢占和循环等待这四个条件可以同时成立。\n\nB. test-and-set 指令对单个锁的原子性，隐含地使得多个锁的获取也成为原子操作，从而防止了循环等待，因此无论获取顺序如何都不会发生死锁。\n\nC. 对锁的获取强制执行一个全局总序（例如，要求所有线程在需要两个锁时都先获取 $L_A$ 再获取 $L_B$），可以消除循环等待条件，从而防止死锁。\n\nD. 用比较并交换（Compare-And-Swap, CAS）来代替 test-and-set 实现锁，同时保持相同的获取模式，可以消除死锁，因为 CAS 是一个更强的原子原语。\n\nE. 即使所有线程都遵守一个全局的锁顺序，饥饿也不会发生，因为 test-and-set 自旋锁在竞争条件下保证了有界等待。", "solution": "首先从与此场景相关的基本定义开始。硬件的 test-and-set 指令在单个内存位置的层面上提供了原子性：单个线程可以原子性地读取和设置一个锁变量，从而保证了该锁的互斥性。由 test-and-set 构建的自旋锁会使一个线程忙等待，直到锁变为空闲状态，此时原子指令会将锁设置为“已锁定”状态。死锁分析采用经典的死锁必要条件（通常归功于 Coffman）：互斥、持有并等待、无抢占和循环等待。如果所有四个条件同时存在，就可能发生死锁。\n\n分析给定的获取模式。线程 $T_1$ 获取 $L_A$ 然后尝试获取 $L_B$；线程 $T_2$ 获取 $L_B$ 然后尝试获取 $L_A$。因为锁只在临界区结束时自愿释放，所以操作系统不会强行抢占资源所有权。\n\n评估每个选项：\n\nA. 当 $T_1$ 尝试先获取 $L_A$ 再获取 $L_B$，而 $T_2$ 尝试先获取 $L_B$ 再获取 $L_A$ 时，可能会发生死锁，因为互斥、持有并等待、无抢占和循环等待这四个条件可以同时成立。 推导：互斥条件成立，因为每个锁 $L_A$ 和 $L_B$ 一次只允许一个线程进入其临界区。持有并等待条件成立，因为 $T_1$ 可以在持有 $L_A$ 的同时等待 $L_B$，同时 $T_2$ 可以持有 $L_B$ 并等待 $L_A$。无抢占条件成立，因为操作系统不会从线程中强行移除一个锁；锁只有在持有者自愿退出其临界区时才会被释放。循环等待条件成立，因为 $T_1$ 等待 $L_B$（由 $T_2$ 持有），而 $T_2$ 等待 $L_A$（由 $T_1$ 持有），在等待图（wait-for graph）中形成了一个循环。当这四个条件都存在时，死锁是可能发生的。因此，选项A是正确的。\n\nB. test-and-set 指令对单个锁的原子性，隐含地使得多个锁的获取也成为原子操作，从而防止了循环等待，因此无论获取顺序如何都不会发生死锁。 推导：test-and-set 的原子性适用于对单个内存位置的操作，而不适用于跨多个不同锁的一系列操作。先获取 $L_A$ 再获取 $L_B$ 并不是一个单一的原子事务；一个线程可能成功获取 $L_A$，然后为获取 $L_B$ 而无限自旋。线程之间在不同锁上的交错可能性依然存在，如果获取顺序不一致，就可能产生循环等待。因此，单锁的原子性并不意味着多锁的原子性，这个陈述是错误的。\n\nC. 对锁的获取强制执行一个全局总序（例如，要求所有线程在需要两个锁时都先获取 $L_A$ 再获取 $L_B$），可以消除循环等待条件，从而防止死锁。 推导：强制一个严格的排序关系，比如 $L_A \\prec L_B$，并要求任何需要两个锁的线程都按递增顺序获取它们。假设，为了反证，在这种策略下发生了循环等待。在一个循环中，每个线程持有一个锁并等待一个更高序的锁。但是在一个严格的总序下，等待图中不可能存在循环：一个等待更高序锁的线程不可能成为一个返回到更低序锁的循环的一部分，因为这个顺序是无环的。因此，循环等待被消除，死锁的一个必要条件被打破；因此原因导致的死锁不会发生。选项C是正确的。\n\nD. 用比较并交换（Compare-And-Swap, CAS）来代替 test-and-set 实现锁，同时保持相同的获取模式，可以消除死锁，因为 CAS 是一个更强的原子原语。 推导：比较并交换（CAS）是一个原子指令，它仅当内存位置持有预期值时才更新该位置，但与 test-and-set 一样，它只为单个内存位置提供原子性。所描述的死锁是由资源获取策略（不一致的锁顺序）引起的，而不是原子原语的缺陷。保持相同的获取模式会保留互斥、持有并等待、无抢占和循环等待；CAS既不能使多锁获取变为原子操作，也不能打破循环等待。因此，选项D是错误的。\n\nE. 即使所有线程都遵守一个全局的锁顺序，饥饿也不会发生，因为 test-and-set 自旋锁在竞争条件下保证了有界等待。 推导：test-and-set 自旋锁不保证有界等待或公平性；原则上，一个线程可能会无限期地自旋，而其他线程则反复获取和释放锁（例如，在没有公平机制的重度竞争下）。全局锁顺序通过消除循环等待来防止死锁，但它不引入公平性或有界等待。饥饿仍然是可能发生的。因此，选项E是错误的。\n\n总结来说，选项 A 和 C 是正确的；B、D 和 E 是错误的。", "answer": "$$\\boxed{AC}$$", "id": "3686956"}, {"introduction": "在确保我们的锁协议能避免死锁之后，下一个挑战便是性能。一个简单的测试并设置（test-and-set）自旋锁在低并发下工作良好，但当许多线程同时竞争同一个锁时，会导致所谓的“缓存一致性风暴”，严重降低系统吞吐量。本练习将引导您评估不同的“退避”（backoff）策略，以缓解这种争用。它旨在阐明为何一种自适应的随机化退避策略对于构建可扩展的高性能并发系统至关重要。[@problem_id:3686949]", "problem": "考虑一个在缓存一致性多处理器上使用测试并设置（TAS）指令实现的单一共享自旋锁。测试并设置（TAS）指令原子地读取一个内存位置并将其设置为锁定值；如果先前的值表示该锁是空闲的，则调用线程获得该锁；否则，尝试失败，线程必须重试。有 $N$ 个相同的线程。每个线程在一个平均持续时间为 $t_{n}$ 的非临界区和一个受自旋锁保护的平均持续时间为 $t_{c}$ 的临界区之间交替执行。一次失败的 TAS 尝试会带来一致性流量和每次尝试大约 $\\tau$ 的停顿开销，并且重复的并发 TAS 尝试可能导致锁的缓存行在核心之间来回传送（乒乓效应），从而增加了移交时间。假设机器提供一个中央处理器（CPU）暂停指令，使得等待期间直到下一次 TAS 之前不会产生一致性流量。\n\n您的任务是选择一种仅使用自上次成功以来连续失败的 TAS 操作次数 $k$（成功时将 $k$ 重置为 $0$）来适应竞争的退避策略，并选择其吞吐量预测与第一性原理一致的策略。吞吐量定义为单位时间内成功获取锁的稳态速率，在没有锁转移开销的情况下，其上限为 $1/t_{c}$。\n\n哪个选项最好地同时指明了：\n- 一种基于 $k$ 的竞争自适应退避策略，以及\n- 一个关于吞吐量如何随 $N$ 从小变大而变化的定性正确的预测？\n\nA. 带下限和上限的指数随机退避：在 $k$ 次连续失败后，等待一个随机时间 $W \\sim \\mathrm{Uniform}\\!\\left(0,\\, s_{\\min}\\cdot 2^{k}\\right)$，但对窗口设置上限，使得 $W \\le s_{\\max}$；成功时重置为 $s_{\\min}$，并始终添加小的随机抖动。预测：对于小的 $N$（例如，$N \\le 4$），下限 $s_{\\min}$ 保持开销可忽略不计，因此吞吐量接近理想的 $1/t_{c}$；对于大的 $N$，窗口会扩大，直到每个有效时隙的预期竞争者数量为 $O(1)$，因此一致性风暴被抑制，锁移交开销保持在 $O(1)$，使得吞吐量接近一个常数，接近于 $1/\\left(t_{c}+O(\\tau)\\right)$，基本上与 $N$ 无关。\n\nB. 固定确定性延迟：每次失败后，等待固定的 $s_{0}$ 个周期（无随机性），与 $k$ 无关。预测：随着 $N$ 的增加，固定延迟导致尝试变得均匀间隔，因此吞吐量随 $N$ 严格增加，并且可能超过 $1/t_{c}$，因为固定延迟平滑了竞争。\n\nC. 无上限的线性随机退避：在 $k$ 次失败后，等待 $W \\sim \\mathrm{Uniform}\\!\\left(0,\\, s_{\\min}+c\\cdot k\\right)$，没有上限；成功时重置为 $s_{\\min}$。预测：对于大的 $N$，与指数退避相比，这避免了过度抑制，因此产生比指数退避更高的吞吐量；吞吐量随 $N$ 持续缓慢提高，因为平均窗口仅随 $k$ 线性扩展。\n\nD. 确定性步骤的加性减少、乘性增加：每次失败时，将当前等待时间乘以一个因子 $\\beta>1$；每次成功时，从当前等待时间中减去一个固定的 $\\delta>0$（但不低于 $0$）；无随机性。预测：该方案会自我调整，使得平均窗口大小与 $N$ 成正比，在大的 $N$ 下产生吞吐量 $\\approx \\left(1-\\Theta\\!\\left(1/N\\right)\\right)/t_{c}$，并由于更好的调整而随 $N$ 的增长而提高。\n\n选择正确的选项。", "solution": "用户要求对问题陈述进行关键性验证，然后提供详细的解决方案和对所给选项的评估。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- **系统**：一个缓存一致性多处理器。\n- **同步原语**：一个使用测试并设置（TAS）指令实现的单一共享自旋锁。\n- **TAS 语义**：原子地读取一个内存位置并将其设置为锁定值。返回先前的值。如果先前的值表示“空闲”，则锁被获取。否则，尝试失败。\n- **工作负载**：$N$ 个相同的线程，每个线程在非临界区（平均持续时间 $t_n$）和临界区（平均持续时间 $t_c$）之间交替执行。\n- **竞争成本**：一次失败的 TAS 尝试会产生 $\\tau$ 的成本（一致性流量、停顿）。并发的 TAS 尝试会导致缓存行“乒乓效应”。\n- **硬件特性**：提供 CPU `pause` 指令用于在等待时不产生一致性流量。\n- **退避策略约束**：退避策略必须仅使用 $k$（自上次成功获取以来连续失败的 TAS 操作次数）来适应竞争。成功时 $k$ 重置为 $0$。\n- **性能指标**：吞吐量，定义为单位时间内成功获取锁的稳态速率。问题陈述正确地指出，吞吐量的上限为 $1/t_c$。\n- **目标**：选择一个正确指明以下两点的选项：（1）一种基于 $k$ 的竞争自适应退避策略，以及（2）一个关于吞吐量随 $N$ 变化行为的定性正确的预测。\n\n**步骤2：使用提取的已知条件进行验证**\n根据验证标准对问题陈述进行审查。\n\n- **有科学依据**：该问题植根于计算机体系结构和操作系统的基本原理。诸如缓存一致性、原子指令（TAS）、自旋锁、竞争、一致性风暴（缓存行乒乓效应）和退避算法等概念都是标准且成熟的主题。对其相互作用的描述是准确的。\n- **提法恰当**：该问题提法恰当。它要求从一组选项中确定对标准竞争控制机制及其性能特征的最佳描述。问题的定性性质适合于对系统性能的概念性理解，并且可以从第一性原理推断出唯一的最佳答案。\n- **客观性**：问题陈述是客观的，并使用了精确的技术术语。它不包含主观或基于意见的声明。\n\n该问题没有表现出任何无效性缺陷：\n1.  **科学上不健全**：它没有违反任何科学原理。系统的物理特性描述正确。\n2.  **不可形式化**：该问题是并发系统性能建模中的一个标准课题。\n3.  **不完整或矛盾的设置**：设置提供了足够的信息来推断不同策略的定性行为。\n4.  **不切实际或不可行**：该场景是对多处理器系统中共享资源竞争的真实描绘。\n5.  **提法不当**：问题是明确的。\n6.  **伪深刻/琐碎**：该问题需要对竞争动态和不同退避策略的特性有非凡的理解。\n7.  **超出科学可验证性范围**：选项中提出的主张可以并且已经被分析和经验研究所证实。\n\n**步骤3：结论与行动**\n问题陈述是**有效的**。将推导解决方案。\n\n### 解的推导\n\n问题的核心是在 $N$ 个竞争线程中管理对单一共享资源（自旋锁）的竞争。\n\n**竞争控制的第一性原理：**\n1.  **竞争问题**：当锁被释放时，多个等待线程可能同时尝试执行 TAS 指令。在缓存一致性系统上，这会导致“一致性风暴”，其中包含锁变量的缓存行在互连网络上被反复失效和获取。这会产生大量的总线/互连流量，并显著增加锁移交的延迟。在最坏的情况下，随着 $N$ 的增加，吞吐量可能会崩溃。\n2.  **退避的作用**：为了缓解这种情况，线程在一次失败的 TAS 尝试后应该等待（或“退避”）一段时间再重试。这是通过使用 `pause` 指令来完成的，以避免在等待时消耗执行资源和产生流量。\n3.  **有效退避策略的特性**：\n    *   **适应性**：等待时间应随竞争水平的增加而增加。一个用于衡量竞争的局部启发式方法是连续失败的尝试次数 $k$。\n    *   **随机化**：等待时间应随机化。如果所有线程都使用相同的确定性退避延迟，它们很可能会同步重试，导致大规模尝试和冲突的重复循环。随机化打破了这种对称性。\n4.  **吞吐量特性**：\n    *   绝对最大吞吐量是 $1/t_c$，只有在锁转移开销为零时才能实现。\n    *   对于小的 $N$，竞争很低，因此由退避引起的开销应该很小。吞吐量应该接近 $1/t_c$。\n    *   对于大的 $N$，一个有效的退避算法应该能稳定系统。它应确保在锁被释放时，平均只有少数几个（一个常数数量的）线程在积极尝试获取锁。这将使锁移交开销保持有界，即相对于 $N$ 是 $O(1)$。因此，每次获取的总时间变为 $t_c + \\text{常数开销}$。吞吐量因此应该饱和并趋近于一个小于 $1/t_c$ 的常数值。它不应该持续下降到零，也不应该随 $N$ 持续增加。\n\n### 逐项分析\n\n**A. 带下限和上限的指数随机退避…… 预测：……吞吐量趋近于一个接近 $1/\\left(t_{c}+O(\\tau)\\right)$ 的常数……**\n- **策略**：所提出的策略是截断的随机指数退避。等待时间 $W$ 从一个均匀分布 $\\mathrm{Uniform}\\!\\left(0,\\, s_{\\min}\\cdot 2^{k}\\right)$ 中抽取，并由 $s_{\\max}$ 封顶。这种机制是自适应的（等待时间随 $k$ 指数增长）、随机化的（打破对称性）和有界的（避免病态延迟）。这是竞争控制中经典且高效的策略，用于以太网的 CSMA/CD 协议等场景中。\n- **预测**：该预测在定性上是正确的。\n    - 对于小的 $N$，竞争低，$k$ 值小，退避时间最短，吞吐量接近理想的 $1/t_c$。\n    - 对于大的 $N$，退避窗口大小的指数级增加有效地限制了活跃竞争者的数量，防止了一致性风暴。这导致了一个稳定、有界的锁移交时间，其特征为 $O(1)$，或者更具体地说，与几次失败尝试的成本 $O(\\tau)$ 相关。每次临界区执行的总时间变为 $t_c + \\text{常数开销}$。因此，吞吐量饱和于一个常数值 $1/(t_c + \\text{常数开销})$，这与 $1/(t_c + O(\\tau))$ 一致。\n- **结论**：**正确**。\n\n**B. 固定确定性延迟…… 预测：……吞吐量随 $N$ 严格增加，并可能超过 $1/t_{c}$……**\n- **策略**：使用一个固定的、确定性的延迟 $s_0$。这是有缺陷的。它不能适应竞争的水平。更重要的是，其确定性是一个关键弱点。如果多个线程同时失败，它们将等待相同的持续时间 $s_0$ 并同步重试，导致另一次冲突。\n- **预测**：该预测从根本上是错误的。\n    - “……吞吐量随 $N$ 严格增加”：这是不正确的。随着 $N$ 的增长，竞争加剧，一个非自适应的、确定性的方案很可能导致性能下降，而不是提高。\n    - “……可能超过 $1/t_c$”：这违反了第一性原理。临界区本身构成了一个串行瓶颈；它一次只能由一个线程执行，平均持续时间为 $t_c$。因此，最大完成速率为 $1/t_c$。任何退避方案都不能将吞吐量提高到这个物理限制之上。\n- **结论**：**不正确**。\n\n**C. 无上限的线性随机退避…… 预测：……产生比指数退避更高的吞吐量；吞吐量随 $N$ 持续缓慢提高……**\n- **策略**：该策略，$W \\sim \\mathrm{Uniform}\\!\\left(0,\\, s_{\\min}+c\\cdot k\\right)$，是自适应和随机化的。线性退避是一种可能的策略。\n- **预测**：该预测是可疑的。\n    - “……避免了过度抑制……产生比指数退避更高的吞吐量”：这不是一个普遍真理。虽然一个未经调优的指数退避可能会过度抑制，但一个调优良好的指数退避被认为是鲁棒的。线性退避可能无法足够快地增加其延迟来平息非常高的竞争，可能导致比指数退避*更低*的吞吐量。\n    - “……吞吐量随 $N$ 持续缓慢提高”：对于一个饱和系统来说，这是不正确的。一旦线程数 $N$ 大到足以确保总有至少一个线程在等待进入临界区，增加更多的线程（$N' > N$）并不能提高吞吐量。在最好的情况下，一个理想的退避方案将维持一个恒定的饱和吞吐量。\n- **结论**：**不正确**。\n\n**D. 确定性步骤的加性减少、乘性增加…… 预测：……在大的 $N$ 下吞吐量 $\\approx \\left(1-\\Theta\\!\\left(1/N\\right)\\right)/t_{c}$，并随 $N$ 的增长而提高……**\n- **策略**：这描述了一种乘性增加，加性减少（MIAD）的方案。失败时，等待时间乘以 $\\beta > 1$；成功时，减少 $\\delta > 0$。关键缺陷是它是“确定性的”。与选项B一样，这种缺乏随机性会导致同步重试和冲突。\n- **预测**：该预测在物理上是不现实的。\n    - 吞吐量形式 $\\approx \\left(1-\\Theta\\!\\left(1/N\\right)\\right)/t_{c}$ 意味着当 $N \\to \\infty$ 时，项 $\\Theta(1/N) \\to 0$，因此吞吐量趋近于理想极限 $1/t_c$。这表明当竞争变得无限大时，锁转移开销消失了，这是不可能的。锁获取总会有一些非零的开销。\n    - 它还声称吞吐量“随 $N$ 的增长而提高”，正如对选项C的解释，这不是一个饱和系统的预期行为。\n- **结论**：**不正确**。\n\n基于以上分析，选项A既提供了一种标准的、有效的算法（截断的随机指数退避），又对其性能特征（在高竞争下饱和到一个恒定的吞吐量）做出了定性正确的预测。", "answer": "$$\\boxed{A}$$", "id": "3686949"}, {"introduction": "关于锁竞争的理论模型非常强大，但我们如何验证这些模型并测量现实世界中的性能开销呢？最后的这个练习将让您扮演一位系统性能工程师的角色。您的任务是设计一个微基准测试（microbenchmark），以精确分离和量化原子操作的内在成本与缓存行“颠簸”（cache-line bouncing）等争用成本。这项实践将理论概念与具体的硬件行为联系起来，展示了如何通过严谨的实验设计来理解底层系统的性能。[@problem_id:3686907]", "problem": "一项操作系统实验课的任务要求你设计一个微基准测试，以定量地将在竞争条件下原子“测试并设置”（test-and-set）指令的内在成本与因缓存行移动（通常称为缓存行弹跳）而产生的成本分离开来。你拥有一台对称多处理器，它具有统一内存访问架构和强内存排序模型。你可以将线程固定到特定的核心上。你可以通过在代码区域的入口和出口处使用串行化指令来读取周期计数器，例如时间戳计数器（TSC）。你可以控制线程数量、布局和锁数据的放置，并且可以编写简单的自旋循环。你希望设计一个实验，使用一个在只读行上自旋的“伪锁”作为基线，以从测量中移除循环和分支的开销。\n\n你可以假设以下基本前提。原子“测试并设置”指令是一种原子性的“读-修改-写”操作，它会使一个缓存行进入独占状态并执行一次写入，当该行在核心间共享时，会引发一次“为所有权而读”的传输。相比之下，一个纯粹的加载操作，如果它读取的位置没有被任何线程写入，那么可以从共享状态来服务，而无需使其他缓存失效。在核心间的竞争条件下，对同一内存位置的重复原子“读-修改-写”尝试会导致缓存行在核心之间传输，而单个线程对自己重复执行相同的原子指令会使该行保持本地拥有，不会引起核心间传输。你可以通过填充将锁字单独放置在一个缓存行上。\n\n假设你计划运行 $P$ 个线程，你可以选择 $P$ 的值以及它们相对于 $C$ 个物理核心的布局。设 $M$ 为在一次固定时长的运行中所有线程记录到的成功获取锁的总次数。设 $T_{\\mathrm{cont}}$ 为在 $P$ 个线程上运行竞争性“测试并设置”锁所测得的总周期数， $T_{\\mathrm{solo}}$ 为在同一个锁变量上运行单线程“测试并设置”所测得的总周期数，以及 $T_{\\mathrm{fake}}$ 为运行一个伪锁所测得的总周期数，该伪锁使用相同的循环结构和分支决策在只读字上自旋，但从不执行原子“读-修改-写”或任何写操作。你必须选择 $P$ 和 $C$ 的安排以及如何收集 $T_{\\mathrm{cont}}$、$T_{\\mathrm{solo}}$ 和 $T_{\\mathrm{fake}}$，并提出了一个公式来估算每次获取锁的缓存行弹跳开销 $B$（以周期为单位），并将其与原子指令的内在成本分离开来。\n\n哪个选项最好地描述了一种实验设计和估算方法，该方法使用伪锁基线来隔离缓存行弹跳开销，同时控制了诸如循环开销和缓存行放置等混杂因素？\n\nA. 将 $P$ 个线程固定到 $P$ 个不同的物理核心上，其中 $P \\le C$。通过填充将单个锁字放置在其自己的缓存行上。对于竞争运行，使用不带退避（backoff）的纯“测试并设置”锁：每个线程循环执行原子“测试并设置”直到获取锁，执行一个不触及锁所在缓存行的固定大小的临界区，然后写入 $0$ 来释放锁并重复此过程，测量每个线程的周期数并求和得到 $T_{\\mathrm{cont}}$，并统计总获取次数 $M$。对于单线程运行，将 $1$ 个线程单独固定在一个核心上，让它在一个紧凑循环中获取和释放同一个锁，以获得相同 $M$ 下的 $T_{\\mathrm{solo}}$。对于伪基线，运行相同的循环体和分支结构，但将锁替换为一个永不改变的只读标志，并在一个只读缓存行上自旋，以获得相同循环迭代次数下的 $T_{\\mathrm{fake}}$。将每次获取锁的缓存行弹跳开销估算为 $B \\approx \\left(\\frac{T_{\\mathrm{cont}} - T_{\\mathrm{fake}}}{M}\\right) - \\left(\\frac{T_{\\mathrm{solo}} - T_{\\mathrm{fake}}}{M}\\right)$，同时确保锁所在的行被隔离，并且线程被放置在不同的核心上以最大化核心间的传输。\n\nB. 在固定到不同核心的 $P$ 个线程上只进行两次测量：一次是竞争性“测试并设置”锁，另一次是在只读标志上的伪自旋。计算 $B \\approx \\frac{T_{\\mathrm{cont}} - T_{\\mathrm{fake}}}{M}$，因为减去伪基线可以同时移除循环开销和原子指令的内在成本，只留下缓存行弹跳。\n\nC. 在竞争运行中使用“测试并测试并设置”（TATAS），即线程在一个只读加载上自旋直到锁看起来空闲，然后执行一次原子“测试并设置”；将其与读取一个永不改变的标志的伪自旋进行比较。设 $B \\approx \\frac{T_{\\mathrm{cont}} - T_{\\mathrm{fake}}}{M}$。单线程测量是不必要的，因为 TATAS 已经消除了大部分的弹跳。\n\nD. 将所有 $P$ 个线程固定到同一个物理核心上（如果可用，则使用硬件线程），运行竞争性“测试并设置”以得到 $T_{\\mathrm{cont}}$，运行伪自旋以得到 $T_{\\mathrm{fake}}$，并估算 $B \\approx \\frac{T_{\\mathrm{cont}} - T_{\\mathrm{fake}}}{M}$。因为这些线程共享最低级别的缓存，任何残余差异都纯粹是原子指令的内在延迟，因此根据设计，缓存行弹跳为零，并且可以通过按 $P$ 缩放来推断多核运行的情况。", "solution": "用户希望我扮演一位一丝不苟的STEM教授，验证所提供的问题陈述，然后通过推导正确答案并评估每个选项来解决它。\n\n### 问题验证\n\n首先，我将根据指定标准验证问题陈述。\n\n**步骤1：提取已知条件**\n\n*   **目标：** 设计一个微基准测试，以定量地将在竞争条件下 `test-and-set` 指令的内在成本与因缓存行弹跳而产生的成本分离开来。\n*   **系统：** 对称多处理器（SMP），具有统一内存访问（UMA）架构和强内存排序模型。\n*   **能力：** 将线程固定到特定核心，读取周期计数器（例如，TSC），控制线程数量（$P$）和在 $C$ 个物理核心上的布局，控制锁数据放置（填充），编写简单的自旋循环。\n*   **提议的基线：** 一个在只读行上自旋的“伪锁”，用于测量和移除循环及分支开销。\n*   **假设的原理：**\n    *   `test-and-set` 是一种原子“读-修改-写”（RMW）指令，它获取一个缓存行的独占状态，如果该行被共享，则会引起“为所有权而读”（RFO）的传输。\n    *   对只读位置的纯 `load` 操作可以从共享缓存状态服务，而不会导致失效。\n    *   通过 `test-and-set` 对锁的竞争会导致缓存行弹跳。\n    *   单个线程重复执行 `test-and-set` 不会导致核心间传输。\n*   **变量：**\n    *   $P$：线程数。\n    *   $C$：物理核心数。\n    *   $M$：成功获取锁的总次数。\n    *   $T_{\\mathrm{cont}}$：$P$ 个线程竞争运行的总周期数。\n    *   $T_{\\mathrm{solo}}$：单线程运行的总周期数。\n    *   $T_{\\mathrm{fake}}$：伪锁（只读自旋）运行的总周期数。\n    *   $B$：目标估算量，即每次获取锁的缓存行弹跳开销（以周期为单位）。\n\n**步骤2：使用提取的已知条件进行验证**\n\n*   **科学基础：** 该问题牢固地植根于计算机体系结构和操作系统的原理。关于缓存一致性、原子操作和性能测量技术的描述是准确的，并且是该领域的标准。\n*   **适定性：** 这是一个适定问题。它指定了一个明确的目标（估算 $B$），提供了一组可控参数和可测量量，并基于一套连贯的物理原理。可以推导出一个有意义的（尽管可能是近似的）解。\n*   **客观性：** 问题陈述使用了精确、技术性和无偏见的语言。\n\n**缺陷清单：**\n1.  **科学/事实不健全：** 无。前提是正确的。\n2.  **不可形式化/不相关：** 无。问题直接相关且可形式化。\n3.  **不完整/矛盾的设置：** 无。设置足以构建答案。\n4.  **不切实际/不可行：** 无。所描述的实验能力是系统性能研究的标准。\n5.  **不适定/结构不良：** 无。该问题的结构是一个标准的实验设计问题。\n6.  **伪深刻/琐碎：** 无。该问题需要对性能测量中的混杂因素进行仔细推理。\n7.  **超出科学可验证性范围：** 无。提议的实验是可验证的。\n\n**步骤3：结论与行动**\n\n问题陈述是**有效的**。我将继续进行解法推导和选项分析。\n\n### 基于原理的推导与选项分析\n\n目标是估算 $B$，即每次获取锁的缓存行弹跳开销。这个开销源于核心间的竞争。\n\n让我们定义在不同实验中每次获取锁的平均成本：\n*   $t_{\\mathrm{solo}} = T_{\\mathrm{solo}}/M$：单线程每次获取锁的平均成本。在这种无竞争场景下，锁所在的缓存行总是被执行该线程的核心所拥有。理想情况下，每次获取都涉及对一个“热”缓存行执行一次 `test-and-set` 指令。因此，该测量值主要由原子指令的内在成本，加上来自循环结构和释放操作的任何最小、恒定的开销构成。\n*   $t_{\\mathrm{cont}} = T_{\\mathrm{cont}}/M$：在 $P$ 个线程在 $P$ 个不同核心上竞争的情况下每次获取锁的平均成本。该成本包括成功执行 `test-and-set` 的内在成本，但主要由竞争成本主导。对于一个纯粹的 `test-and-set` 自旋锁（没有先读后测，即不是 TATAS），等待循环中的每次自旋迭代都是一次原子的 RMW (`test-and-set`)。在竞争下，等待线程的每一次 RMW 都会在其本地缓存中未命中，并发出 RFO，导致缓存行在核心之间传输。这就是“弹跳”。因此，总时间 $T_{\\mathrm{cont}}$ 是 $M$ 次成功获取的成本与大量失败的、自旋的 `test-and-set` 尝试的成本之和。\n\n因此，每次获取锁时由竞争产生的总额外成本是 $t_{\\mathrm{cont}} - t_{\\mathrm{solo}}$。对于纯 `test-and-set` 锁，这全部的额外成本都可归因于在共享行上重复的 RMW，即缓存行弹跳。额外的循环迭代*就是*弹跳事件。因此，一个直接且有效的平均每次获取弹跳开销的估算器是：\n$$B \\approx t_{\\mathrm{cont}} - t_{\\mathrm{solo}} = \\frac{T_{\\mathrm{cont}}}{M} - \\frac{T_{\\mathrm{solo}}}{M} = \\frac{T_{\\mathrm{cont}} - T_{\\mathrm{solo}}}{M}$$\n$T_{\\mathrm{fake}}$ 测量的目的被表述为移除“循环和分支开销”。在一个严谨的差分测量中，必须从每个测量值中减去相应的基线开销。然而，竞争情况下的开销（多次自旋迭代）与单线程情况下的开销（一次自旋迭代）截然不同。单个 $T_{\\mathrm{fake}}$ 测量不能同时作为两者的正确基线。然而，选项A中提出的公式使用 $T_{\\mathrm{fake}}$ 的方式使其在代数上被消去，从而得到了上面推导出的简单、直接的估算器。这表明该公式的结构意在表示对一个共同基线的概念性减法，当简化后，它为这种特定类型的锁得出了正确的估算器。\n\n现在，我将基于此推导来评估每个选项。\n\n**选项A. 将 $P$ 个线程固定到 $P$ 个不同的物理核心上... 将每次获取锁的缓存行弹跳开销估算为 $B \\approx \\left(\\frac{T_{\\mathrm{cont}} - T_{\\mathrm{fake}}}{M}\\right) - \\left(\\frac{T_{\\mathrm{solo}} - T_{\\mathrm{fake}}}{M}\\right)$，同时确保锁所在的行被隔离，并且线程被放置在不同的核心上以最大化核心间的传输。**\n\n*   **实验设计：** 该设计是合理的。将 $P$ 个线程固定到 $P$ 个不同的核心是引发和测量核心间竞争的正确方法。将锁放置在其自己的缓存行上（填充）是防止伪共享（false sharing）的关键步骤，伪共享会干扰结果。使用不带退避的纯 `test-and-set` 锁对于测量原始硬件惩罚是正确的。单线程运行提供了必要的无竞争基线。\n*   **估算公式：** 公式为 $B \\approx \\frac{(T_{\\mathrm{cont}} - T_{\\mathrm{fake}}) - (T_{\\mathrm{solo}} - T_{\\mathrm{fake}})}{M}$。代数上，这可以简化为 $B \\approx \\frac{T_{\\mathrm{cont}} - T_{\\mathrm{solo}}}{M}$。如上所述，对于纯 `test-and-set` 锁，这是一个有效的直接估算每次获取弹跳开销的方法。这个包含可消去 $T_{\\mathrm{fake}}$ 项的复杂形式可能是一个有缺陷的尝试，意图展示一个假设的共同开销的抵消，但其简化后的表达式在此情境下是正确的。虽然对于纯 `test-and-set` 锁而言，只读自旋 `fake_lock` 的方法论价值值得商榷（TATAS 锁会是更好的匹配），但在所有选项中，这个选项提供了最连贯的设计和一个最终正确的估算器。\n\n*   **结论：** **正确**。该选项描述了最佳的实验设置，并提供了一个能够正确估算目标数量的公式，尽管其表述复杂且基线的选择存在细微的方法论不匹配。\n\n**选项B. 在固定到不同核心的 $P$ 个线程上只进行两次测量...计算 $B \\approx \\frac{T_{\\mathrm{cont}} - T_{\\mathrm{fake}}}{M}$...**\n\n*   **分析：** 这个方法有缺陷。首先，它忽略了 $T_{\\mathrm{solo}}$ 测量，而这是建立无竞争获取的基线成本（内在成本）所必需的。其次，声称减去 $T_{\\mathrm{fake}}$ 可以移除“原子指令的内在成本”是错误的。伪锁在只读字上自旋，不涉及任何原子 RMW 指令，因此它的测量无法解释原子指令的成本。公式 $B \\approx \\frac{T_{\\mathrm{cont}} - T_{\\mathrm{fake}}}{M}$ 估算的将是内在成本和弹跳开销之和（$C_{\\mathrm{intrinsic}} + B$），而不是单独的 $B$。\n\n*   **结论：** **错误**。\n\n**选项C. 在竞争运行中使用“测试并测试并设置”（TATAS）...设 $B \\approx \\frac{T_{\\mathrm{cont}} - T_{\\mathrm{fake}}}{M}$。单线程测量是不必要的...**\n\n*   **分析：** 该选项将实验从 `test-and-set` 改为 `test-and-test-and-set` (TATAS)。对于 TATAS 锁，只读的伪自旋确实是其只读自旋部分的一个良好基线。然而，所提出的公式 $B \\approx \\frac{T_{\\mathrm{cont}} - T_{\\mathrm{fake}}}{M}$ 是不正确的，原因与选项B相同：它没有减去最后一次 `test-and-set` 指令的内在成本，因此估算的是 $C_{\\mathrm{intrinsic}} + B$。此外，“TATAS 已经消除了大部分弹跳”的理由具有误导性。TATAS 消除了自旋等待阶段的弹跳，但当多个等待者看到锁空闲并都尝试执行原子 `test-and-set` 时，仍然会引发一阵弹跳。这一阵弹跳正是需要测量的竞争。仍然需要单线程测量来分离出内在成本。\n\n*   **结论：** **错误**。\n\n**选项D. 将所有 $P$ 个线程固定到同一个物理核心上...估算 $B \\approx \\frac{T_{\\mathrm{cont}} - T_{\\mathrm{fake}}}{M}$...缓存行弹跳为零...**\n\n*   **分析：** 这个实验设计存在根本性缺陷。目标是测量*核心间*的缓存行弹跳。通过将所有线程固定到同一个物理核心上，它们将共享至少一个级别的缓存（例如，L1和L2）。这种设置有意地*阻止*了作为测量对象的核间缓存流量。声称成本可以通过“按 $P$ 缩放来推断多核运行的情况”是毫无根据的；你不能通过确保一个现象不发生来测量它。\n\n*   **结论：** **错误**。", "answer": "$$\\boxed{A}$$", "id": "3686907"}]}