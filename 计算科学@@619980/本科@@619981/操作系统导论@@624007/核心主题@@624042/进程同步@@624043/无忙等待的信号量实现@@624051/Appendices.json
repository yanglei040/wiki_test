{"hands_on_practices": [{"introduction": "实现无忙等待的信号量看似简单，但实际上充满了微妙的陷阱。一个常见的错误是将检查资源的操作与决定阻塞的操作分离开来，这会产生一个极小的时间窗口，从而引发称为“丢失唤醒”的竞态条件，可能导致线程永久阻塞。本练习 ([@problem_id:3681456]) 将引导你分析一个有缺陷的实现，精确定位导致此问题的线程交错执行序列，并理解“原子性检查并阻塞”这一核心原则的重要性。", "problem": "考虑一个具有整数状态 $S$ 的计数信号量，其目的是确保当 $S = 0$ 时 $P(S)$ 会阻塞，当 $S > 0$ 时会将 $S$ 减一；并且 $V(S)$ 会将 $S$ 加一，并在必要时唤醒一个被阻塞的线程。该实现必须避免忙等待。假设有一个互斥锁 $M$、一个等待线程队列 $Q$ 以及调度原语 $\\text{park}()$ 和 $\\text{unpark}(t)$，其中 $t$ 是一个线程标识符。为了最小化持有 $M$ 的时间，提出了以下有缺陷的设计：\n\n- 提议的 $P(S)$:\n  - 步骤 $1$：$\\text{lock}(M)$。\n  - 步骤 $2$：如果 $S > 0$，则设置 $S := S - 1$，执行 $\\text{unlock}(M)$，然后返回。\n  - 步骤 $3$：$\\text{unlock}(M)$。\n  - 步骤 $4$：$\\text{enqueue}(Q, \\text{self})$。\n  - 步骤 $5$：$\\text{park}()$。\n\n- 提议的 $V(S)$:\n  - 步骤 $1$：$\\text{lock}(M)$。\n  - 步骤 $2$：如果 $\\text{empty}(Q)$，则设置 $S := S + 1$；否则令 $t := \\text{dequeue}(Q)$ 并执行 $\\text{unpark}(t)$。\n  - 步骤 $3$：$\\text{unlock}(M)$。\n\n您可以视为理所当然的基本事实和定义：\n- 信号量由 $P(S)$ 和 $V(S)$ 的原子行为定义：$V(S)$ 的效果必须对 $P(S)$ 可见，可以通过唤醒一个休眠的线程，或者通过增加 $S$ 以便后续的 $P(S)$ 可以继续执行来实现；不得出现丢失的唤醒。\n- $\\text{lock}(M)$ 和 $\\text{unlock}(M)$ 为受保护的状态提供互斥，并为该状态建立标准的先行发生（happens-before）顺序。\n- $\\text{park}()$ 会阻塞调用者，直到相应的 $\\text{unpark}(\\cdot)$ 被发出；在已经被显式 unpark 的情况下调用 $\\text{park}()$ 会立即返回。不允许自旋。\n- 除了队列 $Q$ 明确强制执行的公平性之外，没有其他保证的公平性。\n\n请从第一性原理出发，使用上述定义分析该设计，并回答以下多项选择题。选择所有在每个选项所述意义上正确的选项。\n\nA. 从 $S = 0$ 和 $\\text{empty}(Q)$ 开始，两个线程 $T_1$ 和 $T_2$ 之间的以下交错执行，证明了提议设计中存在一次丢失的唤醒：\n- 步骤 $1$ ($t_1$)：$T_1$ 调用 $P(S)$，执行 $\\text{lock}(M)$，观察到 $S = 0$，执行 $\\text{unlock}(M)$ (完成步骤 $3$)，但尚未执行步骤 $4$。\n- 步骤 $2$ ($t_2$)：调度器切换到 $T_2$。$T_2$ 调用 $V(S)$，执行 $\\text{lock}(M)$，观察到 $\\text{empty}(Q)$，设置 $S := 1$，并执行 $\\text{unlock}(M)$。\n- 步骤 $3$ ($t_3$)：调度器切换回 $T_1$。$T_1$ 执行 $\\text{enqueue}(Q, \\text{self})$，然后执行 $\\text{park}()$。$T_1$ 会无限期地阻塞，因为没有线程会调用 $\\text{unpark}(T_1)$，并且 $S = 1$ 没有被 $T_1$ 消耗。\n\nB. 从 $S = 0$ 和 $\\text{empty}(Q)$ 开始，两个线程 $T_1$ 和 $T_2$ 之间的以下交错执行，证明了提议设计中存在一次丢失的唤醒：\n- 步骤 $1$ ($t_1$)：$T_1$ 调用 $P(S)$，执行 $\\text{lock}(M)$，观察到 $S = 0$，执行 $\\text{unlock}(M)$，然后立即执行 $\\text{enqueue}(Q, \\text{self})$ 和 $\\text{park}()$。\n- 步骤 $2$ ($t_2$)：$T_2$ 调用 $V(S)$，执行 $\\text{lock}(M)$，观察到 $Q$ 非空，将 $T_1$ 出队，执行 $\\text{unpark}(T_1)$，并执行 $\\text{unlock}(M)$。$T_1$ 醒来并从 $P(S)$ 返回，但没有将 $S$ 减一。\n这显示了一次丢失的唤醒，因为 $T_1$ 没有将 $S$ 减一。\n\nC. 一个正确的、无需忙等待的修复方法是，通过将入队操作移到 $M$ 保护下并执行原子性的释放-休眠操作，使得检查和休眠相对于 $V(S)$ 逻辑上原子化。具体来说：在 $P(S)$ 中，步骤 1 之后，如果 $S = 0$，则在持有 $M$ 的同时执行 $\\text{enqueue}(Q, \\text{self})$，然后原子性地释放 $M$ 并阻塞（例如，通过一个将 $\\text{unlock}(M)$ 和 $\\text{park}()$ 作为一个不可中断步骤执行的原语）；唤醒后，重新获取 $M$，酌情将 $S$ 减一，然后返回。等效地，使用一个类似快速用户空间互斥锁（Fast Userspace muTEX, FUTEX）风格的 $\\text{futex\\_wait}(\\, 0)$，它原子性地检查 $S$ 并且仅当 $S$ 仍然为 $0$ 时才休眠。这通过确保等待者在任何 $V(S)$ 观察到它之前在 $Q$ 中可见，或者如果一个 $V(S)$ 已经使 $S > 0$，则等待者不休眠，从而消除了丢失的唤醒。\n\nD. 一个正确的修复方法是在 $P(S)$ 的步骤 3 和步骤 4 之间插入一个完整的内存屏障（memory fence）以防止重排序，并保持设计的其余部分不变。这可以在不改变锁定规则的情况下消除导致丢失唤醒的竞争条件。\n\nE. 一个正确的修复方法是在 $\\text{park}()$ 期间持有 $M$，方法是将 $P(S)$ 的步骤 5 移动到步骤 3 之前。这可以防止在临界区内与 $V(S)$ 的任何交错执行，从而防止丢失的唤醒，同时保留其他线程的进展。", "solution": "用户要求分析一个提议的信号量实现。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n- 计数信号量状态：整数 $S$。\n- 操作：$P(S)$ 和 $V(S)$。\n- $P(S)$ 的理想行为：如果 $S=0$ 则阻塞；如果 $S>0$ 则将 $S$ 减一。\n- $V(S)$ 的理想行为：将 $S$ 加一；如果存在阻塞的线程，则唤醒一个。\n- 实现组件：互斥锁 $M$，等待线程队列 $Q$，原语 $\\text{park}()$ 和 $\\text{unpark}(t)$。\n- 提议的 $P(S)$ 实现：\n  - 步骤 $1$：$\\text{lock}(M)$。\n  - 步骤 $2$：如果 $S > 0$，则设置 $S := S - 1$，执行 $\\text{unlock}(M)$，然后返回。\n  - 步骤 $3$：$\\text{unlock}(M)$。\n  - 步骤 $4$：$\\text{enqueue}(Q, \\text{self})$。\n  - 步骤 $5$：$\\text{park}()$。\n- 提议的 $V(S)$ 实现：\n  - 步骤 $1$：$\\text{lock}(M)$。\n  - 步骤 $2$：如果 $\\text{empty}(Q)$，则设置 $S := S + 1$；否则令 $t := \\text{dequeue}(Q)$ 并执行 $\\text{unpark}(t)$。\n  - 步骤 $3$：$\\text{unlock}(M)$。\n- 基本事实：信号量不能有丢失的唤醒；$\\text{lock}(M)$ 和 $\\text{unlock}(M)$ 提供互斥并建立先行发生顺序；$\\text{park}()$ 阻塞调用者且不自旋。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在操作系统和并发编程领域具有科学依据。所使用的元素——信号量、互斥锁、调度原语——都是标准的、定义明确的概念。提议的实现及其包含的潜在竞争条件（“丢失的唤醒”问题）构成了该领域教学中一个典型且现实的问题。问题陈述是适定的，提供了所有必要的定义、约束和待分析的算法。语言客观而精确。设置在内部是一致的，并且没有违反任何计算机科学的基本原则。这是一个可验证且非平凡的问题。\n\n**步骤 3：结论和行动**\n问题陈述有效。将继续进行分析。\n\n**对提议实现的的第一性原理分析**\n\n信号量实现的核心责任是确保其操作的原子性。对于 $P(S)$，这意味着一个线程必须原子性地检查信号量的值，并且如果必须阻塞，它必须在任何 $V(S)$ 操作尝试唤醒它之前将自己注册为阻塞状态。\n\n给定的 $P(S)$ 实现未能确保这种原子性。当一个线程发现 $S=0$ 时，它会执行以下一系列操作：\n$1$. $\\text{unlock}(M)$ (步骤 $3$)\n$2$. $\\text{enqueue}(Q, \\text{self})$ (步骤 $4$)\n$3$. $\\text{park}()$ (步骤 $5$)\n\n在步骤 3 和步骤 5 之间存在一个漏洞窗口。在线程解锁 $M$ 之后，操作系统调度器可以自由地抢占它并运行另一个线程。如果这第二个线程调用 $V(S)$，它将获取 $M$，检查等待队列 $Q$，并发现它是空的（因为第一个线程尚未执行步骤 4）。因此，$V(S)$ 操作将增加 $S$ 而不会发出 $\\text{unpark}()$ 调用。当第一个线程被重新调度时，它会继续将自己入队，然后调用 $\\text{park}()$，从而导致其阻塞。然而，与 $V(S)$ 调用相对应的唤醒事件已经发生，并且没有指向该线程。这就是一次“丢失的唤醒”：线程现在被阻塞了，但本应阻止其阻塞（或唤醒它）的信号却丢失了。\n\n**逐项分析**\n\n**A. 从 $S = 0$ 和 $\\text{empty}(Q)$ 开始，两个线程 $T_1$ 和 $T_2$ 之间的以下交错执行，证明了提议设计中存在一次丢失的唤醒：[...]**\n\n该选项描述了从第一性原理推导出的确切的“丢失的唤醒”场景。\n- $T_1$ 调用 $P(S)$，获取锁 $M$，看到 $S=0$，然后释放锁 $M$。它在能将自己添加到队列 $Q$ 之前被抢占。\n- $T_2$ 调用 $V(S)$，获取 $M$，并观察到 $Q$ 是空的。根据实现，它将 $S$ 增加到 $1$ 并释放 $M$。没有调用 $\\text{unpark}()$。\n- $T_1$ 恢复执行。它将自己添加到 $Q$ 中，然后调用 $\\text{park}()$，导致其阻塞。\n最终状态是 $T_1$ 阻塞在 $Q$ 中，而 $S=1$。来自 $V(S)$ 调用的“信用”现在在 $S$ 中，但本应消耗它的 $T_1$ 却在休眠。另一个线程对 $P(S)$ 的后续调用会发现 $S=1$，将其减一并继续执行，使 $T_1$ 被困。这是一个典型的丢失唤醒。该分析是合理的，并正确地指出了缺陷。\n\n结论：**正确**。\n\n**B. 从 $S = 0$ 和 $\\text{empty}(Q)$ 开始，两个线程 $T_1$ 和 $T_2$ 之间的以下交错执行，证明了提议设计中存在一次丢失的唤醒：[...]**\n\n该选项描述了另一个不同的场景。\n- $T_1$ 调用 $P(S)$，发现 $S=0$，并成功将自己入队并休眠。\n- $T_2$ 调用 $V(S)$，在 $Q$ 中发现 $T_1$，将其出队，并调用 $\\text{unpark}(T_1)$。$T_1$ 醒来。\n该选项随后声称这是一次丢失的唤醒，因为“$T_1$ 没有将 $S$ 减一”。让我们分析一下状态。最初，$S=0$。在 $V(S)$ 的路径中，由于 $Q$ 不为空，所以 $S$ *没有* 被增加。对 $\\text{unpark}(T_1)$ 的调用消耗了 $V(S)$ 信号。当 $T_1$ 唤醒时，它只是从 $P(S)$ 返回。$S$ 的最终值为 $0$。一次 $P$ 操作和一次 $V$ 操作已经发生，信号量概念值的净变化为 $0$。这是正确的信号量语义。该实现通过增加 $S$（如果没有等待者）或 unpark 一个等待者（如果有等待者）来正确处理资源计数。在这个设计中，被唤醒的线程不应该将 $S$ 减一，因为这将是对信号消耗的双重计算。因此，这个场景并不代表一个缺陷，更不用说丢失的唤醒了。\n\n结论：**不正确**。\n\n**C. 一个正确的、无需忙等待的修复方法是，通过将入队操作移到 $M$ 保护下并执行原子性的释放-休眠操作，使得检查和休眠相对于 $V(S)$ 逻辑上原子化。[...]**\n\n该选项提出了一个修复方案。核心思想是消除漏洞窗口。对于一个必须等待的线程，对 $P(S)$ 提议的更改是：\n$1$. （持有锁 $M$）$\\text{enqueue}(Q, \\text{self})$。\n$2$. 原子性地 $\\text{unlock}(M)$ 并调用 $\\text{park}()$。\n我们来分析这个修复方案。通过将入队操作移到由 $M$ 保护的临界区内，等待的线程 $T_1$ 在释放 $M$ 之前保证已经在 $Q$ 中。任何其他调用 $V(S)$ 的线程 $T_2$ 在 $T_1$ 释放 $M$ 之前都无法获取 $M$。当 $T_2$ 获取 $M$ 时，它将正确地看到 $T_1$ 在 $Q$ 中并发出唤醒。原子性的‘释放-休眠’操作至关重要，它可以防止在解锁和休眠调用本身之间发生竞争。这确保了 $T_1$ 在释放锁之后但在其正式休眠之前不能被抢占。当从互斥锁构建条件变量或信号量时，这种设计是解决丢失唤醒问题的标准、教科书式的解决方案。提到 $\\text{futex\\_wait}$ 是一个准确的类比，因为该原语是专门为在内核级别解决此原子性问题而设计的。\n\n结论：**正确**。\n\n**D. 一个正确的修复方法是在 $P(S)$ 的步骤 3 和步骤 4 之间插入一个完整的内存屏障（memory fence）以防止重排序 [...]**\n\n该选项建议使用内存屏障。顺序将是 $\\text{unlock}(M)$，然后是一个内存屏障，然后是 $\\text{enqueue}(Q, \\text{self})$。内存屏障阻止编译器和 CPU 对跨越屏障的内存操作进行重排序。然而，“丢失的唤醒”问题不是由内存重排序引起的；它是由操作系统调度器管理的线程交错执行引起的。内存屏障对调度器抢占线程的能力没有影响。选项 A 中描述的丢失唤醒场景仍然完全可能发生：一个线程可以在 `unlock`（和屏障）与 `enqueue` 之间被切换出去。这个提议将一个高层次的逻辑竞争条件误认为是一个低层次的内存排序问题。\n\n结论：**不正确**。\n\n**E. 一个正确的修复方法是在 $\\text{park}()$ 期间持有 $M$，方法是将 $P(S)$ 的步骤 5 移动到步骤 3 之前。[...]**\n\n该选项建议通过让等待的线程在休眠时持有锁 $M$ 来解决问题。一个等待线程的执行顺序将是：$\\text{lock}(M)$、$\\text{enqueue}(Q, \\text{self})$、$\\text{park}()$，然后在唤醒时 $\\text{unlock}(M)$。如果线程 $T_1$ 遵循此路径，它将在持有锁 $M$ 的情况下进入休眠。现在，如果另一个线程 $T_2$ 尝试调用 $V(S)$，它的第一步是调用 $\\text{lock}(M)$。它无法获取锁，因为 $T_1$ 正持有它。但 $T_1$ 正在休眠，只能被 $T_2$ 唤醒。$T_2$ 因等待 $T_1$ 释放锁而被阻塞，而 $T_1$ 因等待 $T_2$ 唤醒它而被阻塞。这是一个死锁。声称这“保留了其他线程的进展”是错误的；它会停止任何试图使用该信号量的线程的所有进展。\n\n结论：**不正确**。", "answer": "$$\\boxed{AC}$$", "id": "3681456"}, {"introduction": "除了“丢失唤醒”的bug，信号量的实现还面临其他与性能和正确性相关的挑战。例如，草率地唤醒所有等待线程会导致“惊群”效应，引发大规模的锁竞争和不必要的上下文切换开销。本练习 ([@problem_id:3681460]) 旨在探讨这种低效问题，以及在常见的“Mesa”语义下出现的一个相关正确性漏洞，从而强调被唤醒的线程必须重新检查等待条件。", "problem": "考虑一个旨在提供非忙碌等待的计数信号量 $S$。其内部状态包含一个整数计数 $c$、一个互斥锁 (mutex) $m$ 和一个带有关联的 FIFO 等待队列的条件变量 (Condition Variable, CV) $cv$。该信号量应满足以下源自计数信号量核心定义的基本规范：当一个线程对 $S$ 调用等待操作（传统上表示为 $P(S)$）时，如果 $c > 0$，则它应递减 $c$ 并立即继续执行；如果 $c = 0$，则它必须阻塞且不消耗 CPU 时间，直到另一个线程调用相应的信号操作（传统上表示为 $V(S)$）。当一个线程调用 $V(S)$ 时，它通过递增 $c$ 来增加可用容量，并且应该唤醒与新可用单元数量相符的确切数量的阻塞线程。所有状态更改和队列操作相对于其他线程都必须是原子的，这通过 $m$ 来实现。在广泛使用的条件变量 (CV) 的“Mesa”管程语义下，一个信号仅将等待的线程标记为就绪，但发信号者并不移交执行权；因此，被唤醒的线程在恢复执行时必须重新检查由 $m$ 保护的谓词。\n\n一个系统使用以下伪代码实现 $P(S)$ 和 $V(S)$。变量和常量的命名如上所述，所有队列操作和 CV 等待都是标准的，并遵循 Mesa 语义。初始计数为 $c = 0$。\n\n有缺陷的 $P(S)$:\nlock $m$\nif $c > 0$ then\n  $c \\leftarrow c - 1$\n  unlock $m$\nelse\n  enqueue current thread on wait queue\n  wait on $cv$ releasing $m$ atomically\n  unlock $m$\n\n有缺陷的 $V(S)$:\nlock $m$\n$c \\leftarrow c + 1$\nbroadcast on $cv$ to wake all blocked threads\nunlock $m$\n\n在一个有 $n$ 个等待线程且只有一个资源变为可用（即 $c$ 从 $0$ 变为 $1$）的工作负载中，上述代码会产生“惊群”现象：所有 $n$ 个线程都被唤醒，争夺 $m$ 和单个资源，只有一个线程能继续执行，其余的则返回睡眠状态。当与 $P(S)$ 中的单次检查以及 Mesa 语义的非移交特性相结合时，这会引发过度的上下文切换，还可能导致“丢失唤醒”或不正确的资源核算。\n\n哪项修改能够产生一个正确的计数信号量实现，该实现既能避免忙碌等待，又能通过只唤醒当前 $c$ 所允许数量的线程来消除惊群现象，同时遵守 Mesa 语义？\n\nA. 将 $V(S)$ 中的 `broadcast` 替换为单个 `signal`；保持 $P(S)$ 不变，其在睡眠前仍使用单次 $\\text{if}$ 检查。\n\nB. 在 $P(S)$ 中，将单次 $\\text{if}$ 替换为 $\\text{while}$ 循环，当 $c = 0$ 时等待，退出循环后在解锁前递减 $c$；在 $V(S)$ 中，递增 $c$，并为每个增加的单元调用一次对 $cv$ 的 `signal`，同时在整个计数更新和信号操作期间保持持有 $m$。\n\nC. 在 $V(S)$ 中保留 `broadcast`，但增加一个全局原子计数器来跟踪已成功递减 $c$ 的线程数；通过 `compare-and-swap` 循环让任何多余的线程重新睡眠，直到计数器与可用单元数匹配。\n\nD. 通过将 $c$ 的值限制在 $0$ 或 $1$ 来将 $S$ 转换为二进制信号量，并在 $V(S)$ 中保留 `broadcast`，这样只有一个被唤醒的线程会成功；依靠其他线程立即重试并失败，然后在不进行忙碌等待的情况下返回睡眠。\n\nE. 在 $P(S)$ 中，将阻塞等待替换为一个自旋循环，该循环重复检查 $c$ 直到 $c > 0$，然后递减 $c$ 并继续执行；在 $V(S)$ 中，保留 `broadcast` 以确保所有竞争者能快速观察到更新后的 $c$，从而加速唤醒过程。", "solution": "用户提供了一个关于使用互斥锁和条件变量实现计数信号量的问题，并要求找出对一个有缺陷的实现的正确修改。\n\n### 步骤 1：提取已知条件\n- **对象**：一个计数信号量，表示为 $S$。\n- **目标**：提供非忙碌等待。\n- **内部状态**：\n    1.  一个整数计数 $c$。\n    2.  一个互斥锁 (mutex) $m$。\n    3.  一个带 FIFO 等待队列的条件变量 (Condition Variable, CV) $cv$。\n- **等待操作 ($P(S)$) 的规范**：\n    - 如果 $c > 0$，调用线程递减 $c$ 并继续执行。\n    - 如果 $c = 0$，调用线程阻塞，不消耗 CPU 时间，直到 $V(S)$ 调用发生。\n- **信号操作 ($V(S)$) 的规范**：\n    - 递增计数 $c$。\n    - 唤醒与新可用资源数量相等的阻塞线程数。\n- **原子性**：所有状态更新 ($c$) 和队列操作必须是原子的，由互斥锁 $m$ 强制执行。\n- **条件变量语义**：“Mesa”管程语义，其中信号仅将等待线程移动到就绪状态。发信号的线程继续执行，被唤醒的线程必须在获得互斥锁后重新评估等待条件。\n- **初始状态**：$c = 0$。\n- **有缺陷的实现**：\n  - **有缺陷的 $P(S)$**：\n    ```\n    lock m\n    if c > 0 then\n      c - c - 1\n      unlock m\n    else\n      enqueue current thread on wait queue\n      wait on cv releasing m atomically\n      unlock m\n    ```\n  - **有缺陷的 $V(S)$**：\n    ```\n    lock m\n    c - c + 1\n    broadcast on cv to wake all blocked threads\n    unlock m\n    ```\n- **观察到的问题**：当有 $n$ 个线程等待且只有一个对 $V(S)$ 的调用时，会发生“惊群”现象。所有 $n$ 个线程都被唤醒，导致争用和过度的上下文切换。问题描述还指出，由于 $P(S)$ 中的单次 `if` 检查和 Mesa 语义，可能出现“丢失唤醒或不正确的资源核算”。\n- **问题**：找出能够实现正确且高效的计数信号量并遵守 Mesa 语义的修改。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述具有科学依据、定义明确且客观。\n- **科学依据**：该问题是操作系统领域中并发编程的经典练习。信号量、互斥锁、条件变量、Mesa 语义和“惊群”问题都是标准的、明确定义的概​​念。所提供的有缺陷的代码说明了常见的、现实的实现陷阱。\n- **定义明确性**：问题清晰地定义了初始状态、期望行为（正确的计数信号量）、约束条件（Mesa 语义、非忙碌等待）以及有缺陷的实现。问题要求进行修改以达到期望状态，这是计算机科学中一个可解的标准问题。\n- **客观性与清晰性**：术语精确且标准。伪代码虽然在高级描述中存在结构上的模糊性（两个 `unlock` 调用），但清楚地展示了两个关键缺陷：使用 `broadcast` 和使用 `if` 检查而非 `while` 循环。对由此产生的问题的描述是准确的。\n- **完整性**：提供了所有必要的信息。核心问题在于 $P(S)$ 的逻辑、$V(S)$ 中 `broadcast` 的选择以及 Mesa 语义规则之间的相互作用。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。这是一个计算机科学领域中合理且表述清晰的问题。我现在将推导解决方案并评估各个选项。\n\n### 正确实现的推导\n\n所提供的有缺陷的实现有两个主要缺陷：\n\n1.  **$P(S)$ 中的正确性缺陷**：在 Mesa 语义下，使用单个 `if c > 0` 检查是不正确的。问题陈述正确地指出，被唤醒的线程必须重新检查谓词。当一个线程从 `wait on cv` 被唤醒时，它重新获取锁 $m$。然而，无法保证条件（$c > 0$）仍然为真。另一个同样被广播唤醒的线程可能已经先获得了锁并将 $c$ 递减为 $0$。`if` 语句没有处理这种竞争条件。在给定的伪代码中，被唤醒的线程会继续执行 `wait` 之后的语句，即 `unlock m`，而没有重新检查 $c$。然后它会从 $P(S)$ 返回，却没有正确地获取资源（即没有递减 $c$），从而导致不正确的行为。在 Mesa 语义下，等待条件变量的标准和正确模式是使用 `while` 循环。\n\n    一个正确的 $P(S)$ 必须如下所示：\n    ```\n    P(S):\n    lock m\n    while c == 0 do\n        wait on cv releasing m\n    end while\n    c - c - 1\n    unlock m\n    ```\n    在这种结构中，当一个线程被唤醒并重新获取锁 $m$ 后，它会重新评估条件 `c == 0`。如果另一个线程已经占用了资源，`c` 将再次为 $0$，该线程将正确地重新进入等待状态。如果 $c > 0$，循环终止，线程安全地递减 $c$，然后释放锁。\n\n2.  **$V(S)$ 中的性能缺陷**：使用 `broadcast on cv` 是“惊群”现象的直接原因。当一个资源可用时（即 $c$ 变为 $1$），所有 $n$ 个等待线程都被唤醒。它们都争夺锁 $m$，导致 $n-1$ 次不必要的上下文切换，因为它们醒来后无法获取资源，又返回睡眠状态。规范要求只唤醒与可用资源数量相等的线程。由于标准的 $V(S)$ 操作使一个资源可用（将 $c$ 递增 $1$），它最多应该唤醒一个线程。这可以通过使用 `signal on cv` 而不是 `broadcast on cv` 来实现。\n\n    一个正确且高效的 $V(S)$ 将是：\n    ```\n    V(S):\n    lock m\n    c - c + 1\n    signal on cv\n    unlock m\n    ```\n\n将这两个修正结合起来，就得到了一个正确、健壮且高效的计数信号量实现。\n\n### 逐项分析选项\n\n**A. 将 $V(S)$ 中的 `broadcast` 替换为单个 `signal`；保持 $P(S)$ 不变，其在睡眠前仍使用单次 $\\text{if}$ 检查。**\n- **分析**：此修改通过只唤醒一个线程解决了惊群性能问题。然而，它未能修正 $P(S)$ 中的关键错误。使用 `if` 语句而不是 `while` 循环，违反了 Mesa 语义所要求的协议。被唤醒的线程（即使是唯一的一个）可能是虚假唤醒，并且会错误地继续执行。因此，该实现仍然根本上是错误的。\n- **结论**：不正确。\n\n**B. 在 $P(S)$ 中，将单次 $\\text{if}$ 替换为 $\\text{while}$ 循环，当 $c = 0$ 时等待，退出循环后在解锁前递减 $c$；在 $V(S)$ 中，递增 $c$，并为每个增加的单元调用一次对 $cv$ 的 `signal`，同时在整个计数更新和信号操作期间保持持有 $m$。**\n- **分析**：此选项描述了上文推导出的两个完全相同的修正。\n    1.  它将 $P(S)$ 中的 `if` 替换为 `while c == 0` 循环，这正确地处理了 Mesa 语义并防止了被唤醒线程之间的竞争条件。\n    2.  它将 $V(S)$ 中的 `broadcast` 替换为 `signal`（“为每个增加的单元调用一次 `signal`”），通过为单个可用资源单元只唤醒一个线程来消除惊群现象。\n    这种组合产生了一个典型的正确且高效的实现。\n- **结论**：正确。\n\n**C. 在 $V(S)$ 中保留 `broadcast`，但增加一个全局原子计数器来跟踪已成功递减 $c$ 的线程数；通过 `compare-and-swap` 循环让任何多余的线程重新睡眠，直到计数器与可用单元数匹配。**\n- **分析**：这种方法复杂且低效。它保留了作为惊群根源的 `broadcast`，然后增加了显著的复杂性（一个新的原子计数器、一个 `compare-and-swap` 循环）来管理由此产生的争用。这并没有解决唤醒过多线程并导致过度上下文切换的根本问题。在 $V(S)$ 中简单的 `signal` 调用可以避免这一系列问题。\n- **结论**：不正确。\n\n**D. 通过将 $c$ 的值限制在 $0$ 或 $1$ 来将 $S$ 转换为二进制信号量，并在 $V(S)$ 中保留 `broadcast`，这样只有一个被唤醒的线程会成功；依靠其他线程立即重试并失败，然后在不进行忙碌等待的情况下返回睡眠。**\n- **分析**：问题要求实现一个*计数*信号量，其计数可以大于 $1$。此选项建议通过限制 $c$ 来创建一个*二进制*信号量。这未能满足问题的基本要求。此外，它还保留了低效的 `broadcast`。\n- **结论**：不正确。\n\n**E. 在 $P(S)$ 中，将阻塞等待替换为一个自旋循环，该循环重复检查 $c$ 直到 $c > 0$，然后递减 $c$ 并继续执行；在 $V(S)$ 中，保留 `broadcast` 以确保所有竞争者能快速观察到更新后的 $c$，从而加速唤醒过程。**\n- **分析**：此选项违反了问题陈述中的一个主要约束：“它必须阻塞**且不消耗 CPU 时间**”。自旋循环就是忙碌等待的定义，它在等待时会消耗 CPU 周期。带有阻塞等待的信号量正是为了避免这种低效而设计的。因此，对于所述目标，此修改是根本错误的。\n- **结论**：不正确。", "answer": "$$\\boxed{B}$$", "id": "3681460"}]}