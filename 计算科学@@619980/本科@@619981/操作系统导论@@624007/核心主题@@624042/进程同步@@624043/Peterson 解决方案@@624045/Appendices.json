{"hands_on_practices": [{"introduction": "Peterson算法看似简单，但其正确性却依赖于操作的精确顺序。本实践将挑战你分析当我们交换设置意图标志$flag[i]$和分配优先权$turn$的顺序时会发生什么。通过构造一个具体的执行序列，你将亲手发现这个看似微小的改动是如何导致互斥性被彻底破坏的。[@problem_id:3669544]", "problem": "考虑经典的双进程Peterson临界区问题解决方案。有两个进程 $P_0$ 和 $P_1$，它们在顺序一致性 (Sequential Consistency, SC) 模型下共享3个单写入者/单读取者原子变量：一个布尔数组 $flag[]$，其中 $flag[i]$ 表示进入意图；以及一个整数 $turn \\in \\{0,1\\}$，用作打破平局的标志。对于进程 $P_i$，令 $j = 1 - i$。原始的进入协议在自旋等待之前按顺序执行以下两个操作：设置 $flag[i]$ 表示感兴趣，然后设置 $turn$ 将优先权赋予另一个进程。在正在考虑的修改版本中，这两行代码的顺序被交换，因此每个进程 $P_i$ 按程序顺序执行：\n- $turn := j$\n- $flag[i] := \\text{true}$\n- while $\\big(flag[j] \\land (turn == j)\\big)$ do 忙等待\n- 进入临界区\n- 退出时 $flag[i] := \\text{false}$\n\n假设 $flag[]$ 和 $turn$ 的读写是原子的，并遵循顺序一致性 (SC)。仅使用临界区的安全性和活性核心定义：\n- 互斥性（Mutual exclusion）：任何时候最多只有一个进程处于临界区。\n- 进展性（Progress）（无死锁）：如果没有进程在临界区中，且有一个或多个进程希望进入，那么最终某个进程将会进入。\n\n哪个选项正确地描述了此修改是否违反了互斥性或进展性，并提供了一个具体的交错调度（原子操作序列）来证明该违规？\n\nA. 互斥性被违反。示例调度，两个进程都从剩余区开始并尝试进入：\n- 步骤 $1$：$P_0$ 执行 $turn := 1$。\n- 步骤 $2$：$P_1$ 执行 $turn := 0$。\n- 步骤 $3$：$P_1$ 执行 $flag[1] := \\text{true}$。\n- 步骤 $4$：$P_1$ 评估while条件 $\\big(flag[0] \\land (turn == 0)\\big)$；由于 $flag[0] = \\text{false}$，它进入临界区。\n- 步骤 $5$：$P_0$ 执行 $flag[0] := \\text{true}$。\n- 步骤 $6$：$P_0$ 评估while条件 $\\big(flag[1] \\land (turn == 1)\\big)$；由于 $flag[1] = \\text{true}$ 且 $turn == 0$，它进入临界区。\n$P_1$ 和 $P_0$ 同时处于临界区中。\n\nB. 进展性被违反（两个进程可能永远卡在自旋等待中）。示例调度：\n- 步骤 $1$：$P_0$ 执行 $turn := 1$，然后执行 $flag[0] := \\text{true}$。\n- 步骤 $2$：$P_1$ 执行 $turn := 0$，然后执行 $flag[1] := \\text{true}$。\n- 步骤 $3$：两个进程都评估它们的while条件并永远自旋，因为每个进程都看到对方的 $flag$ 为 $\\text{true}$ 且 $turn$ 偏向于另一个进程。\n\nC. 在顺序一致性下，互斥性和进展性都未被违反；当两个进程都感兴趣时，打破平局的机制仍然确保只有一个进程可以继续执行。\n\nD. 互斥性得到满足，但进展性可能因活锁而被违反，即两个进程重复设置 $turn$ 和 $flag[]$ 并不断相互谦让，导致谁也无法进入临界区。\n\n选择唯一的最佳选项。", "solution": "该问题要求分析Peterson双进程临界区问题解决方案的一个修改版本。该修改涉及交换进入协议中前两条语句的顺序。我们必须确定此修改是否违反了互斥性或进展性属性。\n\n设有两个进程 $P_0$ 和 $P_1$。共享变量是一个布尔数组 $flag[2]$ 和一个整数 $turn \\in \\{0,1\\}$。我们假设标准初始状态，即两个进程都在其剩余区中，因此 $flag[0] = \\text{false}$ 且 $flag[1] = \\text{false}$。$turn$ 的初始值是任意的。对共享变量的所有读写都是原子的，并且系统遵循顺序一致性 (SC)。\n\n对于进程 $P_i$（其中 $i \\in \\{0,1\\}$ 且 $j = 1-i$），修改后的协议是：\n\n**进入区 (Entry Section):**\n1.  $turn := j$\n2.  $flag[i] := \\text{true}$\n3.  `while` ($flag[j] \\land (turn == j)$) `do` 忙等待\n\n**临界区 (Critical Section):**\n...\n\n**退出区 (Exit Section):**\n1.  $flag[i] := \\text{false}$\n\n我们将分析两个基本属性：互斥性和进展性。\n\n### 互斥性分析\n互斥性要求在任何给定时间最多只有一个进程可以处于其临界区内。为了测试是否存在违规，我们寻找一个可能导致 $P_0$ 和 $P_1$ 同时进入其临界区的原子操作的交错执行序列。\n\n让我们考虑以下事件序列，从初始状态 $flag[0] = \\text{false}$、$flag[1] = \\text{false}$ 以及任意的 $turn$ 值开始。\n\n1.  **$P_0$ 执行 `turn := 1`**。共享变量 $turn$ 的值现在为 $1$。共享变量的状态是 ($flag[0]=\\text{false}$, $flag[1]=\\text{false}$, $turn=1$）。\n2.  **$P_0$ 被抢占。**\n3.  **$P_1$ 执行 `turn := 0`**。共享变量 $turn$ 被覆盖，其值现在为 $0$。状态是 ($flag[0]=\\text{false}$, $flag[1]=\\text{false}$, $turn=0$）。\n4.  **$P_1$ 执行 `flag[1] := true`**。状态是 ($flag[0]=\\text{false}$, $flag[1]=\\text{true}$, $turn=0$）。\n5.  **$P_1$ 评估其 `while` 条件**：$flag[0] \\land (turn == 0)$。\n    -   表达式 $flag[0]$ 的值为 $\\text{false}$。\n    -   因此整个合取式为 $\\text{false}$。\n    -   $P_1$ 不会循环并继续进入其临界区。\n6.  **$P_1$ 在其临界区内。$P_0$ 恢复执行。**\n7.  **$P_0$ 执行 `flag[0] := true`**。状态是 ($flag[0]=\\text{true}$, $flag[1]=\\text{true}$, $turn=0$）。\n8.  **$P_0$ 评估其 `while` 条件**：$flag[1] \\land (turn == 1)$。\n    -   表达式 $flag[1]$ 的值为 $\\text{true}$。\n    -   表达式 $(turn == 1)$ 的值为 $\\text{false}$，因为当前 $turn$ 为 $0$。\n    -   因此整个合取式为 $\\text{false}$。\n    -   $P_0$ 不会循环并继续进入其临界区。\n\n此时，$P_1$ 和 $P_0$ 都处于各自的临界区中。这构成了对互斥性属性的明确违反。这个缺陷的产生是因为进程 $P_i$ 可以在设置自己的标志 $flag[i]$ 之前，就设置 $turn$ 变量以让步于 $P_j$。这使得 $P_j$ 可以看到 $P_i$ 不感兴趣（$flag[i]$ 为 $\\text{false}$）并继续执行，同时它自己设置的 $turn$ 值也会在随后允许 $P_i$ 进入。\n\n### 进展性分析\n进展性属性，如定义所示，意味着无死锁：如果没有进程在其临界区内，并且有一个或多个进程希望进入，那么其中一个进程最终必须能够进入。如果两个进程都可能永久地阻塞在它们的 `while` 循环中，那么就发生了违规。\n\n为了进行反证，我们假设两个进程都陷入了死锁。\n-   要使 $P_0$ 被阻塞，它必须在其 `while` 循环中自旋。这要求其条件 $flag[1] \\land (turn == 1)$ 持续为真。这意味着 $flag[1] = \\text{true}$ 且 $turn = 1$。\n-   要使 $P_1$ 被阻塞，它必须在其 `while` 循环中自旋。这要求其条件 $flag[0] \\land (turn == 0)$ 持续为真。这意味着 $flag[0] = \\text{true}$ 且 $turn = 0$。\n\n要使两个进程同时陷入死锁，系统状态必须同时满足所有这些条件。这将要求 $turn == 1$ 和 $turn == 0$ 同时为真，但由于 $turn$ 是一个单一变量，这在逻辑上是不可能的。因此，两个进程不可能同时卡在它们的 `while` 循环中。在任何时刻，至少有一个等待条件必须为假。因此，不会发生死锁，进展性属性没有被违反。\n\n### 选项评估\n\n**A. 互斥性被违反。示例调度，两个进程都从剩余区开始并尝试进入：...**\n此选项声称互斥性被违反，并提供了一个证明性的调度。\n-   调度如下：\n    1.  $P_0$ 执行 $turn := 1$。（状态：$turn=1$）\n    2.  $P_1$ 执行 $turn := 0$。（状态：$turn=0$）\n    3.  $P_1$ 执行 $flag[1] := \\text{true}$。（状态：$flag[1]=\\text{true}, turn=0$）\n    4.  $P_1$ 检查 $flag[0] \\land (turn == 0)$。由于 $flag[0]=\\text{false}$，条件为 $\\text{false}$，$P_1$ 进入其临界区。\n    5.  $P_0$ 执行 $flag[0] := \\text{true}$。（状态：$flag[0]=\\text{true}, flag[1]=\\text{true}, turn=0$）\n    6.  $P_0$ 检查 $flag[1] \\land (turn == 1)$。由于 $turn=0$，子表达式 $(turn==1)$ 为 $\\text{false}$。条件为 $\\text{false}$，$P_0$ 进入其临界区。\n-   该调度是有效的，并正确地显示了两个进程都处于临界区。互斥性被违反的结论是正确的。\n-   **结论：正确。**\n\n**B. 进展性被违反（两个进程可能永远卡在自旋等待中）。示例调度：...**\n此选项声称存在进展性违规（死锁）。我上面的分析证明了死锁是不可能的。我们来分析所提供的调度：\n-   调度如下：\n    1.  $P_0$ 执行 $turn := 1$，然后执行 $flag[0] := \\text{true}$。（状态：$turn=1, flag[0]=\\text{true}$）\n    2.  $P_1$ 执行 $turn := 0$，然后执行 $flag[1] := \\text{true}$。（状态：$turn=0, flag[0]=\\text{true}, flag[1]=\\text{true}$）\n    3.  两个进程都评估它们的while条件。\n-   让我们根据最终状态（$flag[0]=\\text{true}, flag[1]=\\text{true}, turn=0$）检查条件：\n    -   $P_0$ 的条件：$flag[1] \\land (turn==1)$。这是 $\\text{true} \\land (\\text{false})$，结果为 $\\text{false}$。$P_0$ 不会自旋；它进入临界区。\n    -   $P_1$ 的条件：$flag[0] \\land (turn==0)$。这是 $\\text{true} \\land (\\text{true})$，结果为 $\\text{true}$。$P_1$ 自旋。\n-   该选项的结论“两个进程……永远自旋”是错误的。$P_0$ 取得了进展。因此，该调度不会导致死锁。\n-   **结论：不正确。**\n\n**C. 在顺序一致性下，互斥性和进展性都未被违反；当两个进程都感兴趣时，打破平局的机制仍然确保只有一个进程可以继续执行。**\n此选项声称该算法是正确的。我们的分析通过一个有效的反例显示了对互斥性的明确违反。在这个修改版本中，打破平局的机制是有缺陷的。\n-   **结论：不正确。**\n\n**D. 互斥性得到满足，但进展性可能因活锁而被违反，即两个进程重复设置 $turn$ 和 $flag[\\,]$ 并不断相互谦让，导致谁也无法进入临界区。**\n此选项声称互斥性得到满足，这是错误的，如选项A的分析所示。此外，协议中没有机制让进程在不进入临界区的情况下“重复设置 $turn$ 和 $flag[\\,]$”。一旦一个进程设置了它的标志，该标志会一直保持设置状态，直到它退出临界区。互斥性得到满足这个前提就足以使该选项无效。\n-   **结论：不正确。**\n\n分析证实，只有互斥性被违反，而进展性（无死锁）得以维持。选项A正确地指出了这一点，并提供了一个有效的反例。", "answer": "$$\\boxed{A}$$", "id": "3669544"}, {"introduction": "在看到一个小改动如何破坏算法之后，让我们来探索一个可能行得通的不同修改。本实践提议将回合变量$turn$的更新移到退出协议中，每次退出临界区时进行切换。你的任务是证明这种新设计是否仍然保证互斥性，并分析其公平性属性，例如有界等待和严格交替。[@problem_id:3669502]", "problem": "考虑一个具有$2$个并发进程$P_0$和$P_1$的系统，它们使用一种类似于Peterson解法的修改版双进程协议来协调对共享临界区 (CS) 的访问。共享变量为$flag[0]$、$flag[1]$ (布尔类型，初始为$false$) 和$turn \\in \\{0,1\\}$ (初始值为任意但固定的值)。每个进程$P_i$遵循一个进入协议，该协议将$flag[i] := true$设置为真，然后在一个谓词$(flag[j] \\land turn == j)$上进行忙等待，其中$j = 1 - i$。退出协议将$flag[i] := false$设置为假，并通过赋值$turn := 1 - turn$来切换共享变量$turn$的值 (在进入协议期间不会对$turn$进行赋值)。假设对共享变量的所有读写操作都是原子的，并遵循顺序一致性。互斥意味着在任何时候两个进程都不会同时处于临界区中。在此上下文中，公平性指的是有限等待 (Bounded Waiting, BW) 属性：如果进程$P_i$设置了$flag[i] := true$，那么在$P_i$最终进入临界区之前，另一个进程$P_j$可以进入临界区的次数存在一个有限的界限；先到先服务 (First-Come-First-Served, FCFS) 是一个更强的属性，它要求在到达没有重叠的情况下，到达顺序决定服务顺序。\n\n基于以上基本定义和所述的内存假设，以下哪个陈述最能描述该变体的互斥和公平性属性？\n\nA. 互斥性得以保持。有限等待成立，并且在$flag[0] = flag[1] = true$的持续竞争条件下，该协议强制对临界区的访问进行严格交替，但它不能保证在所有到达模式下都满足先到先服务。\n\nB. 互斥性得以保持，但有限等待不成立：一个进程可能会饿死，而另一个进程可以任意多次进入临界区。\n\nC. 互斥性被破坏：当两个进程并发地设置$flag[i] := true$时，它们可以同时进入临界区，因为对$turn$的切换只在退出时发生。\n\nD. 互斥性得以保持，但公平性比原始的Peterson解法更差：当两个进程持续竞争时，一个进程在进入临界区之前可能被另一个进程超越多次。", "solution": "该问题陈述已被验证，并被认为是在操作系统和并发领域中一个定义明确、有科学依据的问题。\n\n进程$P_i$的协议如下，其中$i \\in \\{0,1\\}$且$j = 1 - i$：\n\n共享变量：\n- $flag[0], flag[1]$：布尔类型，初始化为$false$。\n- $turn$：整数$\\in \\{0,1\\}$，初始化为一个任意但固定的值。\n\n$P_i$的进入协议：\n```\nflag[i] := true;\nwhile (flag[j] \\land turn == j) {\n    // busy wait\n}\n```\n\n$P_i$的临界区 (CS)：\n```\n// Critical Section code\n```\n\n$P_i$的退出协议：\n```\nflag[i] := false;\nturn := 1 - turn;\n```\n\n我们现在来分析该协议的属性。\n\n### 1. 互斥性\n\n为了证明互斥性，我们将使用反证法。假设进程$P_0$和$P_1$同时处于它们各自的临界区中。\n\n如果$P_0$在其临界区中，它必须已经执行了其进入协议，并发现其`while`循环的条件为$false$。$P_0$的条件是`flag[1] \\land turn == 1`。要让$P_0$进入临界区，在其最后一次检查时，`\\neg(flag[1] \\land turn == 1)`必须为真。\n\n类似地，如果$P_1$在其临界区中，它必须发现其`while`循环的条件`flag[0] \\land turn == 0`为$false$。要让$P_1$进入临界区，在其最后一次检查时，`\\neg(flag[0] \\land turn == 0)`必须为真。\n\n当两个进程都在临界区中时，它们之前必定都已将其标志设置为$true$。因此，在同时占用临界区的那一刻，$flag[0] = true$且$flag[1] = true$。\n\n让我们在这种状态（$flag[0] = true$且$flag[1] = true$）下重新审视循环条件：\n- 为了让$P_0$进入，其条件`(flag[1] \\land turn == 1)`必须为$false$。由于$flag[1]$为$true$，这意味着`turn == 1`必须为$false$。因此，$P_0$必须观察到$turn = 0$。\n- 为了让$P_1$进入，其条件`(flag[0] \\land turn == 0)`必须为$false$。由于$flag[0]$为$true$，这意味着`turn == 0`必须为$false$。因此，$P_1$必须观察到$turn = 1$。\n\n为了让两个进程都进入临界区，共享变量$turn$需要同时等于$0$ (以便$P_0$继续) 和等于$1$ (以便$P_1$继续)。由于$turn$在任何给定时刻只能持有一个值，这是一个矛盾。\n\n因此，两个进程不能同时处于临界区中。**互斥性得以保持。**\n\n### 2. 公平性 (有限等待和交替)\n\n有限等待要求，如果一个进程$P_i$表明它希望进入临界区（通过设置$flag[i] := true$），那么在$P_i$被授予访问权限之前，另一个进程$P_j$进入临界区的次数存在一个有限的界限。\n\n让我们考虑进程$P_0$等待进入临界区的情况。要使$P_0$卡在其`while`循环中，条件`flag[1] \\land turn == 1`必须为真。这意味着：\n1. $flag[1] = true$：$P_1$要么在其临界区内，要么也在等待进入。\n2. $turn = 1$：$turn$变量被设置为有利于$P_0$的进入（因为$P_0$在$turn==1$时等待）。这意味着$P_1$可以进入，因为它的等待条件`(flag[0] \\land turn==0)`为假，因为$turn \\neq 0$。\n\n所以，如果$P_0$正在等待，那么$P_1$可能在临界区内。让我们看看当$P_1$退出其临界区时会发生什么。\n$P_1$执行其退出协议：\n1. $flag[1] := false$。仅此操作就使$P_0$的等待条件`(flag[1] \\land turn == 1)`变为$false$，从而允许$P_0$继续执行。\n2. $turn := 1 - turn$。由于$P_0$正在等待，我们知道$turn$的值为$1$。所以$P_1$将设置$turn := 1 - 1 = 0$。这也使$P_0$的等待条件变为假。\n\n在$P_1$退出临界区后，$P_0$保证能够进入。$P_1$不能在$P_0$之前重新进入临界区，因为在退出时，$P_1$通过设置$flag[1]:=false$放弃了其声明，并且还以一种解除$P_0$等待的方式更改了$turn$。要让$P_1$重新进入，它必须再次设置$flag[1]:=true$，但到那时$P_0$已经通过了它的等待条件。\n\n因此，如果$P_0$正在等待，$P_1$在$P_0$保证进入之前最多只能进入临界区一次。这被称为1-有界等待。**有限等待得以保持。**\n\n此外，在$flag[0]$和$flag[1]$持续为$true$的持续竞争下，退出部分的`turn := 1 - turn`语句强制实现严格交替。如果$P_0$进入，`turn`必须为$0$。退出时，它将`turn`设置为$1$。现在$P_1$可以进入，而$P_0$必须等待。当$P_1$退出时，它将`turn`设置为$0$，从而允许$P_0$接下来进入。\n\n### 3. 先到先服务 (FCFS)\n\nFCFS意味着如果$P_i$在$P_j$之前到达 (设置$flag[i] := true$)，那么$P_i$应该在$P_j$之前进入临界区。让我们用一个反例来测试这一点。\n\n假设初始状态为$flag[0] = false$，$flag[1] = false$，且$turn = 0$。\n考虑以下事件序列：\n1. $P_1$“到达”并执行`flag[1] := true`。\n2. 在$P_1$检查其`while`条件之前发生上下文切换。\n3. $P_0$运行并执行其进入协议：`flag[0] := true`。\n4. 当前状态为：$flag[0] = true$，$flag[1] = true$，$turn = 0$。\n5. $P_0$检查其等待条件：`(flag[1] \\land turn == 1)`。其计算结果为`(true \\land 0 == 1)`，即$false$。$P_0$进入临界区。\n6. 发生上下文切换。$P_1$恢复执行并检查其等待条件：`(flag[0] \\land turn == 0)`。其计算结果为`(true \\land 0 == 0)`，即$true$。$P_1$必须等待。\n\n在这种情况下，$P_1$首先设置了它的标志，表明它先到达。然而，由于$turn$的初始值和指令的交错执行，$P_0$率先进入了临界区。因此，该协议**不保证先到先服务**。\n\n### 选项评估\n\n**A. 互斥性得以保持。有限等待成立，并且在$flag[0] = flag[1] = true$的持续竞争条件下，该协议强制对临界区的访问进行严格交替，但它不能保证在所有到达模式下都满足先到先服务。**\n- `互斥性得以保持。` - 这是**正确的**，如我们的分析所示。\n- `有限等待成立` - 这是**正确的**。等待是1-有界的。\n- `...强制严格交替...` - 这是**正确的**，因为`turn`变量在每次退出时都会切换。\n- `...不保证先到先服务...` - 这是**正确的**，如反例所示。\n这个陈述准确而全面地描述了该协议的属性。\n\n**B. 互斥性得以保持，但有限等待不成立：一个进程可能会饿死，而另一个进程可以任意多次进入临界区。**\n- 这是**不正确的**。如分析所示，有限等待是成立的。一个等待中的进程在另一个进程最多退出一次后保证能够进入。饿死是不可能的。\n\n**C. 互斥性被破坏：当两个进程并发地设置$flag[i] := true$时，它们可以同时进入临界区，因为对$turn$的切换只在退出时发生。**\n- 这是**不正确的**。`turn`变量，即使在进入阶段是静态的，也足以充当决胜者(tie-breaker)，确保在两个标志都升起时只有一个进程能通过其`while`循环。互斥性得以保持。\n\n**D. 互斥性得以保持，但公平性比原始的Peterson解法更差：当两个进程持续竞争时，一个进程在进入临界区之前可能被另一个进程超越多次。**\n- 这是**不正确的**。分析表明，一个进程最多被“超越”一次，导致1-有界等待。原始的Peterson解法也表现出1-有界等待。因此，就有限等待而言，公平性属性并没有更差；它是等效的。\n\n**结论：**\n选项 A 是唯一正确且完整地描述了给定同步协议行为的陈述。", "answer": "$$\\boxed{A}$$", "id": "3669502"}, {"introduction": "现实世界的实现常常寻求优化，而理论算法必须面对硬件的现实。本实践介绍了一个试图在无竞争场景下减少对$turn$变量不必要写入的变体。除了在理想的顺序一致性模型下分析其正确性，这个练习还促使你思考一个关键的现实问题：像Peterson这样的纯软件算法在具有弱内存模型的现代处理器上会如何表现？[@problem_id:3669493]", "problem": "两个进程（由索引 $i \\in \\{0,1\\}$ 和 $j = 1 - i$ 表示）共享两个布尔变量 $flag[0], flag[1]$ 和一个整型变量 $turn$。所有共享变量初始化为 $flag[0] := \\text{false}, flag[1] := \\text{false}$，且 $turn$ 的初始值为 $\\{0,1\\}$ 中的任意一个。假设读写操作是原子的，并且内存模型提供顺序一致性 (Sequential Consistency, SC)，意即任何执行的结果，都等同于所有进程的所有操作以某种交错顺序执行的结果，并且该交错顺序尊重每个独立进程的程序顺序。\n\n考虑Peterson双进程互斥协议的以下变体。每个进程 $i$ 执行以下循环，其中 $j = 1 - i$：\n- 设置 $flag[i] := \\text{true}$。\n- 如果观察到 $flag[j]$ 为 $\\text{true}$，则设置 $turn := j$；否则，不写入 $turn$。\n- 当 $flag[j] \\wedge (turn == j)$ 时忙等待。\n- 执行临界区。\n- 设置 $flag[i] := \\text{false}$。\n- 执行剩余区。\n\n该变体与教科书中的Peterson解法的唯一不同之处在于，对 $turn$ 的写入是有条件的：只有在检测到 $flag[j] == \\text{true}$ 时才写入 $turn$；在无竞争的情况下 ($flag[j] == \\text{false}$)，跳过对 $turn$ 的写入。\n\n根据互斥性（在任何时刻最多只有一个进程处于临界区）、前进性（如果没有进程在临界区中，且有某个进程希望进入，则最终会有某个进程进入）和有限等待（一个希望进入临界区的进程不会被另一个进程无限次地超越）的基本定义，并且在上述的SC和原子读/写假设下，判断关于此变体的哪些陈述是正确的。\n\n选择所有适用的选项。\n\nA. 与教科书中的Peterson解法相比，该变体在无竞争时（即当 `flag[j] == false` 时）减少了对 `turn` 的写入，并且在SC和原子读/写条件下，它仍然保证互斥性、前进性和有限等待。\n\nB. 该变体可能违反互斥性：如果两个进程在条件更新时都观察到 `flag[j] == false`，那么它们都可以进入临界区，因为 `turn` 可能保留一个过时的值。\n\nC. 该变体可能发生死锁：如果两个进程都没有更新 `turn`（因为它们都观察到 `flag[j] == false`），那么它们都会在 `turn` 不变的情况下永远忙等待。\n\nD. 该变体在SC下保持了互斥性和前进性，但可能违反有限等待；一个进程可能饿死，而另一个进程重复进入。\n\nE. 在没有SC的架构上，并且在没有适当的内存排序原语（如内存屏障）的情况下，教科书中的Peterson解法和这个变体都可能失败；条件更新不能修正弱内存重排序问题。", "solution": "问题要求分析Peterson双进程互斥算法的一个变体。分析将在指定条件下进行：原子读/写操作和顺序一致性（SC）内存模型。需要验证的三个基本属性是互斥性、前进性和有限等待。\n\n进程 $i \\in \\{0, 1\\}$（其中 $j = 1 - i$）的算法如下：\n1. 进入区：\n   1. $flag[i] := \\text{true}$。\n   2. 如果观察到 $flag[j]$ 为 $\\text{true}$，则 $turn := j$。\n   3. 当 $(flag[j] \\wedge (turn == j))$ 时忙等待。\n2. 临界区 (CS)。\n3. 退出区：\n   1. $flag[i] := \\text{false}$。\n4. 剩余区。\n\n共享变量初始化为 $flag[0] := \\text{false}$，$flag[1] := \\text{false}$，并且 $turn$ 被设置为 $\\{0, 1\\}$ 中的一个任意值。\n\n### 在顺序一致性（SC）下的分析\n\n在SC下，来自所有进程的所有内存操作被合并到一个单一的全序中，该全序与每个独立进程的程序顺序一致。\n\n#### 1. 互斥性\n为证明互斥性，我们采用反证法，假设进程 $P_0$ 和 $P_1$ 同时处于其临界区中。\n- 如果 $P_0$ 在其CS中，它必须已经通过了其忙等待循环。这意味着当它最后一次评估条件 $(flag[1] \\wedge (turn == 1))$ 时，该条件为 $\\text{false}$。\n- 如果 $P_1$ 在其CS中，它必须已经通过了其忙等待循环。这意味着当它最后一次评估条件 $(flag[0] \\wedge (turn == 0))$ 时，该条件为 $\\text{false}$。\n\n任何进程 $i$ 要进入其CS，必须先设置 $flag[i] := \\text{true}$。因此，如果两者都在其CS中，那么必然有 $flag[0] = \\text{true}$ 和 $flag[1] = \\text{true}$。\n\n鉴于两个标志都为 $\\text{true}$：\n- $P_0$ 要进入，其循环条件 $(\\text{true} \\wedge (turn == 1))$ 必须为 $\\text{false}$。这要求在其最终检查时 $turn == 0$。\n- $P_1$ 要进入，其循环条件 $(\\text{true} \\wedge (turn == 0))$ 必须为 $\\text{false}$。这要求在其最终检查时 $turn == 1$。\n\n设 $C_0$ 是 $P_0$ 对循环条件的最后一次（成功的）检查，而 $C_1$ 是 $P_1$ 的最后一次检查。在操作 $C_0$ 的时刻，$turn$ 的值必须是 $0$。在操作 $C_1$ 的时刻，$turn$ 的值必须是 $1$。\n\n让我们分析对共享变量 $turn$ 的写入。\n- $P_0$ 只有在观察到 $flag[1] == \\text{true}$ 时才会写入 $turn := 1$。\n- $P_1$ 只有在观察到 $flag[0] == \\text{true}$ 时才会写入 $turn := 0$。\n\n由于两个进程都在CS中，所以 $flag[0]$ 和 $flag[1]$ 都必须为 $\\text{true}$。这意味着如果它们正在竞争，每个进程都会看到对方的标志为 $\\text{true}$，并尝试写入 $turn$。SC模型对这些写入施加了一个全序。设两个进程都进入其CS之前的最后一次对 $turn$ 的写操作为 $W_{last}$。\n- 情况1：$W_{last}$ 是 $P_0$ 写入 $turn := 1$。这次写入后，$turn$ 的值为 $1$。如果 $P_0$ 接着进入其等待循环，它将评估 $(flag[1] \\wedge (turn == 1))$，结果将是 $\\text{true}$（因为 $P_1$ 要在其CS中，$flag[1]$ 必须为 $\\text{true}$）。因此，$P_0$ 会被阻塞。它不可能进入其CS。\n- 情况2：$W_{last}$ 是 $P_1$ 写入 $turn := 0$。这次写入后，$turn$ 的值为 $0$。如果 $P_1$ 接着进入其等待循环，它将评估 $(flag[0] \\wedge (turn == 0))$，结果将是 $\\text{true}$。因此，$P_1$ 会被阻塞。\n\n最后写入 $turn$ 的进程实际上是让步给了另一个进程，阻止了自己进入CS。因此，在竞争情况下，Peterson解法的核心逻辑得以保留。在无竞争情况下（例如，$P_0$ 运行时 $flag[1]$ 为 $\\text{false}$），$P_0$ 会跳过对 $turn$ 的写入，并立即通过等待循环，因为条件的 $flag[1]$ 部分为 $\\text{false}$。如果此时 $P_1$ 尝试进入，它会看到 $flag[0] = \\text{true}$，设置 $turn := 0$，并被迫在条件 $(flag[0] \\wedge (turn == 0))$ 上等待。\n\n互斥性得到保证。\n\n#### 2. 前进性\n前进性要求，如果有进程希望进入其CS且没有进程在其CS中，那么最终必须有某个进程能够进入。这主要是一个避免死锁的问题。\n如果两个进程都永远卡在它们的忙等待循环中，就会发生死锁。\n- 如果 $(flag[1] \\wedge (turn == 1))$ 永久为 $\\text{true}$，$P_0$ 就会被卡住。\n- 如果 $(flag[0] \\wedge (turn == 0))$ 永久为 $\\text{true}$，$P_1$ 就会被卡住。\n\n如果两者都试图进入，它们都会将自己的标志设置为 $\\text{true}$。要发生死锁，需要两个循环条件都为 $\\text{true}$。这要求 $(turn == 1)$ 和 $(turn == 0)$ 同时成立，这是不可能的。因此，在任何时候，最多只有一个进程会被 $turn$ 变量阻塞。另一个进程的循环条件将为 $\\text{false}$，使其能够进入其CS。前进性得到保证。\n\n#### 3. 有限等待\n有限等待意味着，一个希望进入其CS的进程 $P_i$，将会在另一个进程 $P_j$ 被允许进入其CS无限次之前进入。\n假设 $P_0$ 希望进入其CS。它设置 $flag[0] := \\text{true}$，现在在其循环处等待。要使 $P_0$ 等待，必须满足 $flag[1] = \\text{true}$ 和 $turn == 1$。这意味着 $P_1$ 也处于其进入区或临界区。\n$P_1$ 可以在其CS中，因为它的等待条件 $(flag[0] \\wedge (turn == 0))$ 是 $\\text{false}$ 的（因为 $turn==1$）。\n现在，一旦 $P_1$ 退出其CS，它会设置 $flag[1] := \\text{false}$。这立即导致 $P_0$ 的等待条件 $(flag[1] \\wedge (turn == 1))$ 变为 $\\text{false}$，从而允许 $P_0$ 继续前进。\n如果 $P_1$ 速度非常快，并试图在 $P_0$（现已解除阻塞）获得运行机会之前重新进入其CS呢？\n- $P_1$ 循环回来并再次执行其进入协议。它设置 $flag[1] := \\text{true}$。\n- 然后它观察到 $flag[0]$ 为 $\\text{true}$（因为 $P_0$ 仍在等待进入）。\n- 因此，$P_1$ 执行条件写入：$turn := 0$。\n这个操作是关键。通过设置 $turn := 0$，$P_1$ 保证了 $P_0$ 的等待条件 $(flag[1] \\wedge (turn == 1))$ 将为 $\\text{false}$，因为现在 $turn \\neq 1$。$P_0$ 保证能够进入。同时，$P_1$ 现在会卡在自己的等待循环中，评估 $(flag[0] \\wedge (turn == 0))$ 为 $\\text{true}$。\n因此，一个等待中的进程 $P_i$ 最多只能被 $P_j$ 超越一次。有限等待得到保证。\n\n### 在没有顺序一致性的架构上的分析\n\n在许多现代多核处理器上，内存一致性模型比SC“更弱”。这意味着硬件为了性能可以重排内存操作，例如，对不同位置的一个写操作后跟一个读操作，可能不会以程序顺序出现在其他处理器面前。Peterson算法（及其变体）依赖于SC提供的严格排序。例如，进程 $P_i$ 执行 $flag[i] := \\text{true}$，然后读取 $flag[j]$。在弱内存模型上，对 $flag[j]$ 的读取可能会在对 $flag[i]$ 的写入对 $P_j$ 可见之前执行。这可能导致 $P_0$ 和 $P_1$ 都读取到对方的标志为 $\\text{false}$，并继续进入它们的临界区，从而违反互斥性。为防止这种情况，需要使用内存屏障（或栅栏指令）来强制执行必要的排序。该变体中的条件更新不充当内存屏障，也无法解决这个根本问题。\n\n### 选项评估\n\n**A. 与教科书中的Peterson解法相比，该变体在无竞争时（即当 `flag[j] == false` 时）减少了对 `turn` 的写入，并且在SC和原子读/写条件下，它仍然保证互斥性、前进性和有限等待。**\n这个陈述是正确的。条件写入 `if ($flag[j]$)` 明确地避免了在无竞争情况下对 $turn$ 的写入，这是一种优化。如上文详细分析所示，在SC模型下，所有三个正确性属性（互斥性、前进性和有限等待）都得以保留，因为在竞争情况（唯一困难的情况）下，该算法的逻辑与教科书中的Peterson解法完全相同。\n**结论：正确。**\n\n**B. 该变体可能违反互斥性：如果两个进程在条件更新时都观察到 `flag[j] == false`，那么它们都可以进入临界区，因为 `turn` 可能保留一个过时的值。**\n这个陈述是错误的。在SC下，“两个进程都观察到 $flag[j] == \\text{false}$” 的前提是不可能的。$P_0$ 要观察到 $flag[1]==\\text{false}$，其读取必须发生在 $P_1$ 写入 $flag[1]$ 之前。$P_1$ 要观察到 $flag[0]==\\text{false}$，其读取必须发生在 $P_0$ 写入 $flag[0]$ 之前。然而，每个进程都是在读取对方的标志*之前*写入自己的标志。这在SC所要求的操作全序中导致了逻辑矛盾。因此，这个前提是有缺陷的，互斥性不会以这种方式被违反。\n**结论：错误。**\n\n**C. 该变体可能发生死锁：如果两个进程都没有更新 `turn`（因为它们都观察到 `flag[j] == false`），那么它们都会在 `turn` 不变的情况下永远忙等待。**\n这个陈述是错误的。首先，如选项B中所证，在SC下两个进程都观察到 $flag[j] == \\text{false}$ 的前提是不可能的。其次，如果一个进程 $i$ 确实观察到 $flag[j] == \\text{false}$，其忙等待条件的第一部分 $(flag[j] \\wedge \\dots)$ 将为 $\\text{false}$，它根本不会忙等待；它会直接进入临界区。该陈述在逻辑上是不一致的。\n**结论：错误。**\n\n**D. 该变体在SC下保持了互斥性和前进性，但可能违反有限等待；一个进程可能饿死，而另一个进程重复进入。**\n这个陈述是错误的。它正确地指出了互斥性和前进性得到了保留，但错误地声称有限等待被违反了。如分析所示，Peterson解法中确保有限等待的机制仍然完整无缺。一个进程 $j$ 在 $i$ 等待时试图重新进入CS，会被迫设置 $turn := i$，这保证了 $i$ 将获得下一次机会。\n**结论：错误。**\n\n**E. 在没有SC的架构上，并且在没有适当的内存排序原语（如内存屏障）的情况下，教科书中的Peterson解法和这个变体都可能失败；条件更新不能修正弱内存重排序问题。**\n这个陈述是正确的。众所周知，像Peterson这样的纯软件互斥算法在具有弱内存模型的处理器上是不正确的，除非使用显式的内存屏障来对关键内存操作强制执行程序顺序。这个变体中的修改（一个条件写入）是一个控制流的改变，而不是一个内存排序原语。它不能防止有害的重排序，因此不能修复该算法在此类架构上的漏洞。原始算法和这个变体都会以同样的方式失败。\n**结论：正确。**", "answer": "$$\\boxed{AE}$$", "id": "3669493"}]}