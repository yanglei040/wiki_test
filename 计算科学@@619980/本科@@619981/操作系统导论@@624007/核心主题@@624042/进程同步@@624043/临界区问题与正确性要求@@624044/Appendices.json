{"hands_on_practices": [{"introduction": "在并发编程中，一个常见的误解是认为只要为共享资源的写操作加上锁就万事大吉了。本练习将探讨一个微妙的场景：尽管写操作本身受到互斥锁的保护，但用于决定写入位置的共享状态（即游标）的更新却并非原子操作，从而引发了竞态条件。通过仔细追踪一个特定的执行交错，你将亲眼见证“撕裂读”（torn read）如何导致两个线程写入同一位置，揭示出即使存在锁也可能发生的数据竞争问题。[@problem_id:3687271]", "problem": "两个生产者线程 $T_1$ 和 $T_2$ 将记录附加到一个共享的二维缓冲区 $B$ 中，该缓冲区的大小为 $R \\times C$，其中 $C = 2$ 列。$B$ 中的一个位置由一对 $(i,j)$ 寻址，$(i,j)$ 的线性索引是 $s(i,j) = i \\cdot C + j$。有一个共享光标 $(I,J)$，用于编码下一个空闲槽位。为了减少感知到的竞争，该实现使用了以下有缺陷的协议：\n- 每个线程在不持有锁的情况下，分别将 $I$ 和 $J$ 读入各自线程的局部变量 $(i,j)$ 中。\n- 然后，每个线程获取一个互斥锁 $L$，将其记录写入 $B[i][j]$，然后释放 $L$。\n- 释放 $L$ 后，每个线程通过非原子存储来推进共享光标：它首先设置 $J := (j+1) \\bmod C$，如果结果为 $0$，它稍后会设置 $I := I + 1$。对 $J$ 和 $I$ 的这两个更新不是原子执行的，并且两者都不受 $L$ 的保护。\n\n假设初始共享状态为 $(I,J) = (k,0)$，其中 $k \\ge 0$ 是某个整数，并且两个线程都完全按照所描述的协议执行。该系统是一个传统的中央处理器（CPU），对于单变量的读写具有顺序一致性排序，但不能保证对 $(I,J)$ 这对组合状态的原子性。就本问题而言，“重复条目”指的是对同一个 $B[i][j]$ 槽位的两次写入，包含来自 $T_1$ 和 $T_2$ 的不同记录。\n\n尽管存在互斥锁 $L$，但仅仅因为对 $I$ 或 $J$ 的更新是非原子的并且发生在 $L$ 的保护之外，以下哪种交错执行会在 $B$ 中产生重复条目？\n\nA. 安全推进，无撕裂读：\n- $T_1$：读取 $I = k$；读取 $J = 0$；获取 $L$；写入 $B[k][0]$；释放 $L$；设置 $J := 1$。\n- $T_2$：读取 $I = k$；读取 $J = 1$；获取 $L$；写入 $B[k][1]$；释放 $L$；设置 $J := 0$；设置 $I := k + 1$。\n\nB. 跨非原子更新的撕裂读产生重复：\n- $T_1$：读取 $I = k$。\n- $T_2$：获取 $L$；写入 $B[k][0]$；释放 $L$；设置 $J := 1$。\n- $T_1$：读取 $J = 1$；其局部变量现在是 $(i_1,j_1) = (k,1)$。\n- $T_2$：读取 $I = k$；读取 $J = 1$；获取 $L$；写入 $B[k][1]$；释放 $L$；设置 $J := 0$；设置 $I := k + 1$。\n- $T_1$：获取 $L$；写入 $B[k][1]$；释放 $L$；设置 $J := 0$；设置 $I := k + 1$。\n\nC. 跨线程的回绕拆分，但槽位仍然唯一：\n- $T_1$：读取 $I = k$；读取 $J = 0$；获取 $L$；写入 $B[k][0]$；释放 $L$；设置 $J := 1$。\n- $T_2$：读取 $I = k$；读取 $J = 1$；获取 $L$；写入 $B[k][1]$；释放 $L$；设置 $J := 0$；设置 $I := k + 1$。\n- $T_1$：稍后读取 $I = k + 1$；读取 $J = 0$；获取 $L$；写入 $B[k+1][0]$；释放 $L$。\n\nD. I上的增量丢失，但没有重复槽位：\n- $T_1$：读取 $I = k$；读取 $J = 0$；获取 $L$；写入 $B[k][0]$；释放 $L$；设置 $J := 1$。\n- $T_2$：读取 $I = k$；读取 $J = 1$；获取 $L$；写入 $B[k][1]$；释放 $L$；设置 $J := 0$。\n- $T_1$：设置 $I := k + 1$；$T_2$ 也设置 $I := k + 1$；两者在下一次迭代中都以 $I = k + 1$ 和 $J = 0$ 继续。\n\n选择唯一正确的选项。\n\n你的推理必须从临界区问题的核心定义及其正确性要求（互斥、前进、有界等待）以及共享状态更新的原子性定义开始。然后，推断每种交错执行是否会对同一个 $B[i][j]$ 槽位产生重复写入，并解释为什么互斥锁 $L$ 在强制执行必要的正确性方面失败或成功。", "solution": "用户希望我验证并解决一个与并发和临界区问题相关的问题。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n*   **线程：** 两个生产者线程，$T_1$ 和 $T_2$。\n*   **共享缓冲区：** $B$，一个大小为 $R \\times C$ 的二维缓冲区。\n*   **缓冲区列数：** $C = 2$。\n*   **缓冲区寻址：** 一个位置 $(i,j)$ 的线性索引是 $s(i,j) = i \\cdot C + j$。\n*   **共享状态：** 一个光标 $(I,J)$ 指示下一个可用槽位。\n*   **协议：**\n    1.  每个线程分别将共享变量 $I$ 和 $J$ 读入每个线程的局部变量 $(i,j)$ 中。此操作在不持有任何锁的情况下完成。\n    2.  每个线程获取一个互斥锁 $L$。\n    3.  每个线程将其记录写入缓冲区槽位 $B[i][j]$。\n    4.  每个线程释放互斥锁 $L$。\n    5.  释放 $L$ 后，每个线程更新共享光标。它首先执行 $J := (j+1) \\bmod C$。如果此操作导致 $J$ 被设置为 $0$，它随后会执行 $I := I + 1$。对 $I$ 和 $J$ 的这些更新不是原子地一起执行的，也不受互斥锁 $L$ 的保护。\n*   **初始条件：** 共享光标的初始状态为 $(I,J) = (k,0)$，其中 $k \\ge 0$ 是某个整数。\n*   **系统模型：** 单变量读写具有顺序一致性。对 $(I,J)$ 这对变量不能进行原子读或写。\n*   **关键定义：** “重复条目”定义为来自 $T_1$ 和 $T_2$ 的两个不同记录被写入同一个缓冲区槽位 $B[i][j]$。\n*   **问题：** 用户想确定，由于光标更新的非原子性（这些更新发生在由 $L$ 保护的临界区之外），所提供的交错执行中哪一个会导致重复条目。\n\n**步骤2：使用提取的已知条件进行验证**\n\n1.  **科学依据：** 该问题是并发编程中竞争条件的经典示例，是操作系统和计算机科学的核心主题。所使用的元素——线程、共享内存、互斥锁、非原子操作和竞争条件——都是基础且完善的概念。\n2.  **良态问题：** 协议的描述足够详细，可以分析特定执行交错的后果。初始状态已定义，问题要求在一组封闭选项中找到一个具体的、可识别的结果（重复条目）。可以确定一个唯一的正确答案。\n3.  **客观性：** 问题以精确、正式的语言陈述，没有歧义或主观声明。诸如“非原子”、“互斥锁”和“顺序一致”等术语在此上下文中具有标准的、客观的含义。\n4.  **缺陷检查清单：**\n    *   **科学上不健全：** 无。该场景真实地描绘了一个常见的编程错误。\n    *   **不相关性：** 无。该问题与临界区问题、原子性以及并发系统中的正确性条件等主题直接相关。\n    *   **不完整/矛盾：** 无。该问题是自包含的，并提供了追踪执行场景所需的所有必要信息。“有缺陷的协议”的描述是一个前提，而不是一个矛盾。\n    *   **不切实际：** 无。该场景非常现实。程序员经常犯这样的错误：即使保护了对共享资源的访问本身，却没有保护用于确定访问权限的状态。\n    *   **病态问题：** 无。该问题的结构使得可以通过仔细分析得出一个唯一的正确答案。\n    *   **琐碎/同义反复：** 无。该问题并非微不足道。它需要仔细追踪程序状态，并理解互斥锁的保护范围如何可能不足。互斥锁 $L$ 的存在可能会让人误以为所有竞争条件都已防止，但错误在于 $L$ 的保护范围之外。\n\n**步骤3：结论与行动**\n\n问题陈述是**有效的**。它在科学上是健全的，是良态的，客观的，并为分析提供了明确的基础。我将继续推导解决方案。\n\n### 解决方案推导\n\n解决临界区问题的正确性要求确保互斥、前进和有界等待。在此问题中，共享资源是缓冲区 $B$。该协议试图确保每个线程写入一个唯一的槽位。互斥锁 $L$ 正确地对写操作 `writes its record to B[i][j]` 强制执行了互斥。这意味着如果两个线程试图同时写入*完全相同的槽位* $B[i][j]$，互斥锁将序列化它们的访问，从而防止字节级别的写损坏。但是，它不能防止一个线程完成的写入被另一个线程随后对同一位置的写入所覆盖。\n\n根据定义，如果两个线程 $T_1$ 和 $T_2$ 在写入前计算出相同的局部索引对 $(i,j)$，就会发生“重复条目”错误。如果确定下一个空闲槽位的逻辑不是原子的，就会发生这种情况。该协议的漏洞在于，读取共享光标 $(I,J)$ 及其后续更新不是作为一个受互斥锁 $L$ 保护的单一原子操作来执行的。这允许了破坏预期逻辑的交错执行。\n\n光标更新逻辑规定，在写入槽位 $(i,j)$ 后，线程计算 $J_{new} = (j+1) \\bmod 2$。如果 $J_{new}=0$，意味着该行已满，线程还必须增加 $I$。这个两步更新（先 $J$，然后可能是 $I$）是非原子的，并且发生在锁之外。由于最初对 $I$ 和 $J$ 的读取也是分开且无保护的，这个漏洞被进一步加剧。\n\n让我们在初始共享状态为 $(I,J) = (k,0)$ 且 $C=2$ 的情况下分析每个选项。\n\n**选项A：安全推进，无撕裂读**\n1.  $T_1$：读取 $I \\to i_1:=k$；读取 $J \\to j_1:=0$。局部索引是 $(k,0)$。\n2.  $T_1$：获取 $L$，写入 $B[k][0]$，释放 $L$。\n3.  $T_1$：更新共享状态。$j_1=0$，所以它计算 $(0+1)\\bmod 2=1$。设置共享 $J:=1$。共享状态为 $(I,J)=(k,1)$。\n4.  $T_2$：读取 $I \\to i_2:=k$；读取 $J \\to j_2:=1$。局部索引是 $(k,1)$。\n5.  $T_2$：获取 $L$，写入 $B[k][1]$，释放 $L$。\n6.  $T_2$：更新共享状态。$j_2=1$，所以它计算 $(1+1)\\bmod 2=0$。设置共享 $J:=0$。因为结果是 $0$，它接着设置共享 $I:=I+1$，变成 $k+1$。最终共享状态为 $(I,J)=(k+1,0)$。\n这种交错执行正确地填充了槽位 $B[k][0]$ 和 $B[k][1]$，没有冲突。\n**结论：** 不正确。\n\n**选项B：跨非原子更新的撕裂读产生重复**\n该执行轨迹暗示在轨迹开始前，$T_2$ 已经确定其槽位为 $(k,0)$。让我们假设 $T_2$ 之前读取了 $(I,J)=(k,0)$ 以获得其局部索引 $(i_2, j_2)=(k,0)$。\n1.  共享状态：$(I,J)=(k,0)$。\n2.  $T_1$：读取 $I$。局部变量 $i_1$ 现在是 $k$。\n3.  $T_2$：（使用其预先计算的局部索引 $(k,0)$）获取 $L$，写入 $B[k][0]$，释放 $L$。\n4.  $T_2$：更新共享状态。其局部变量 $j_2=0$，所以它设置共享 $J:=(0+1)\\bmod 2 = 1$。共享光标现在是 $(I,J)=(k,1)$。\n5.  $T_1$：读取 $J$。它读到的值是 $1$。它的局部索引现在被组装成 $(i_1,j_1)=(k,1)$。这是一个“撕裂读”，因为 $T_1$ 从状态 $(k,0)$ 读取了 $I$，而从状态 $(k,1)$ 读取了 $J$。\n6.  $T_2$：开始其下一个操作。它读取共享的 $I=k$ 和共享的 $J=1$。它的新局部索引是 $(i_2,j_2)=(k,1)$。\n7.  现在，$T_1$ 和 $T_2$ 都计算出了相同的目标地址：槽位 $B[k][1]$。\n8.  根据执行轨迹：$T_2$ 首先继续。它获取 $L$，将其记录写入 $B[k][1]$，然后释放 $L$。\n9.  然后，$T_1$ 继续。它获取 $L$，将其记录写入 $B[k][1]$，然后释放 $L$。\n$T_1$ 的写入覆盖了 $T_2$ 刚刚写入的记录。这构成了对同一槽位的“重复条目”（或者更准确地说，是一次丢失的更新），违反了程序的意图。这个失败的发生，正是因为 $T_2$ 对共享光标的非原子更新允许了 $T_1$ 执行一次撕裂读。\n**结论：** 正确。\n\n**选项C：跨线程的回绕拆分，但槽位仍然唯一**\n这个执行轨迹基本上结合了选项A的操作，然后多展示了一步。\n1.  $T_1$：写入 $B[k][0]$。共享光标变为 $(k,1)$。\n2.  $T_2$：写入 $B[k][1]$。共享光标变为 $(k+1,0)$。\n3.  $T_1$：（在下一次迭代中）读取 $I=k+1$ 和 $J=0$。获取 $L$ 并写入 $B[k+1][0]$。\n在这个序列中，写入操作分别针对 $B[k][0]$、$B[k][1]$ 和 $B[k+1][0]$。这些都是不同的槽位。没有发生重复条目。\n**结论：** 不正确。\n\n**选项D：I上的增量丢失，但没有重复槽位**\n这个执行轨迹描述了一个场景，$T_1$ 写入 $B[k][0]$ 而 $T_2$ 写入 $B[k][1]$。\n1.  $T_1$ 写入 $B[k][0]$。其局部变量 $j_1=0$。它将共享的 $J$ 更新为 $1$。根据协议，它*不*更新 $I$。\n2.  $T_2$ 写入 $B[k][1]$。其局部变量 $j_2=1$。它将共享的 $J$ 更新为 $0$。根据协议，它*负责*增加 $I$。\n执行轨迹陈述：“$T_1$：设置 $I := k + 1$”。这个陈述与问题指定的协议相矛盾，因为在这种情况下，$T_1$ 没有条件去更新 $I$。尽管执行轨迹的描述中存在这种违反协议的情况，但轨迹本身显示了对 $B[k][0]$ 和 $B[k][1]$ 的写入，它们是不同的槽位。描述甚至明确说明了“没有重复槽位”。$I$ 的增量丢失是另一种类型的并发错误（对 $I$ 本身的数据竞争），它会导致行被跳过或稍后被覆盖，但不会以所描述的方式立即导致重复的槽位写入。\n**结论：** 不正确。", "answer": "$$\\boxed{B}$$", "id": "3687271"}, {"introduction": "像Peterson算法这样的经典同步算法，其正确性证明通常建立在一个强假设之上：顺序一致性（Sequential Consistency）。本练习将揭示当这个假设不成立时会发生什么。你将分析在移除了一个关键的内存屏障（memory fence）后，Peterson算法在具有弱内存模型（特别是存储缓冲）的现代处理器上是如何失效并违反互斥性的。这个实践将凸显抽象算法理论与真实硬件行为之间的重要差异，并让你领会内存屏障的关键作用。[@problem_id:3687333]", "problem": "考虑一个双进程锁，它是 Peterson 双进程算法的一个栅栏增强变体，已知在具有每核存储缓冲的弱序架构上，该锁满足三个临界区正确性要求——互斥、前进和有限等待。存在两个进程 $P_0$ 和 $P_1$ 以及三个共享变量：一个布尔数组 $flag[\\,]$，由进程标识符 $\\{0,1\\}$ 索引，以及一个共享变量 $turn \\in \\{0,1\\}$。初始状态为 $flag[0] = \\text{false}$，$flag[1] = \\text{false}$，以及 $turn = 0$。对于 $i \\in \\{0,1\\}$，每个进程 $P_i$ 在进入其临界区之前执行以下进入协议，并在离开临界区后执行退出协议：\n\n$P_i$ 的进入协议：\n- 设置 $flag[i] \\leftarrow \\text{true}$。\n- 执行一个完整的内存栅栏 $F$。\n- 设置 $turn \\leftarrow 1 - i$。\n- 当 $(flag[1-i] \\land (turn = 1-i))$ 时忙等待。\n- 进入临界区。\n\n$P_i$ 的退出协议：\n- 设置 $flag[i] \\leftarrow \\text{false}$。\n\n假设硬件实现了每核存储缓冲：一个进程的存储操作对该进程自身立即变得可见，但可能需要经过一个不确定性延迟后才对其他进程可见。一个进程的加载操作可以从内存中读取数据，而无需等待该进程先前对不同地址的存储操作对其他进程可见。一个完整的内存栅栏 $F$ 会在允许任何后续内存操作继续之前，排空发出该指令的进程的存储缓冲区。对同一地址的存储操作不会重排序，并且系统遵守按位置一致性。这是一种对带存储缓冲的弱内存的简化且广泛使用的操作性特征描述，足以用于对此程序进行推理。\n\n假设我们从进入协议中移除单个栅栏 $F$（即删除“执行一个完整的内存栅栏 $F$”这一行），并保持所有其他步骤不变。在上述模型下，修改后的锁可能满足也可能不满足正确性要求。\n\n你的任务是从下面的交错执行中选择一个，该交错执行在指定的内存模型下是可行的，并且通过允许一个执行使得 $P_0$ 和 $P_1$ 同时处于临界区内，从而证明了对互斥性的违反。在每个选项中，“已缓冲”意味着存储操作仍保留在发出指令的核心的存储缓冲区中（尚未对其他进程可见），而“可见”意味着存储操作已传播并可被其他进程读取。\n\nA. 利用两个进程的存储缓冲的交错执行：\n- 步骤 $1$：$P_0$：$flag[0] \\leftarrow \\text{true}$ (已缓冲)。\n- 步骤 $2$：$P_1$：$flag[1] \\leftarrow \\text{true}$ (已缓冲)。\n- 步骤 $3$：$P_0$：$turn \\leftarrow 1$ (可见)。早前的 $flag[0]$ 存储操作仍处于缓冲状态。\n- 步骤 $4$：$P_1$：$turn \\leftarrow 0$ (可见)。早前的 $flag[1]$ 存储操作仍处于缓冲状态。\n- 步骤 $5$：$P_0$：加载 $flag[1]$ 并读到 $\\text{false}$（因为 $flag[1]$ 仍在 $P_1$ 中缓冲），将条件 $(flag[1] \\land (turn = 1))$ 评估为 $\\text{false}$，并进入临界区。\n- 步骤 $6$：$P_1$：加载 $flag[0]$ 并读到 $\\text{false}$（因为 $flag[0]$ 仍在 $P_0$ 中缓冲），将条件 $(flag[0] \\land (turn = 0))$ 评估为 $\\text{false}$，并进入临界区。\n- 结果：$P_0$ 和 $P_1$ 同时处于临界区内。\n\nB. 在 $flag$ 上出现竞争但由 $turn$ 解决的交错执行：\n- 步骤 $1$：$P_0$：$flag[0] \\leftarrow \\text{true}$ (可见)。\n- 步骤 $2$：$P_1$：$flag[1] \\leftarrow \\text{true}$ (可见)。\n- 步骤 $3$：$P_0$：$turn \\leftarrow 1$ (可见)。\n- 步骤 $4$：$P_1$：$turn \\leftarrow 0$ (可见)。\n- 步骤 $5$：$P_0$：加载 $flag[1]$ 为 $\\text{true}$ 和 $turn$ 为 $0$，评估 $(\\text{true} \\land (0 = 1)) = \\text{false}$，并进入临界区，而 $P_1$ 则自旋等待。\n- 结果：只有一个进程进入临界区。\n\nC. 假设对同一观察者存在写-写重排序的交错执行：\n- 步骤 $1$：$P_0$：$flag[0] \\leftarrow \\text{true}$ (已缓冲)。\n- 步骤 $2$：$P_0$：$turn \\leftarrow 1$（在 $flag[0]$ 之前对 $P_1$ 可见）。\n- 步骤 $3$：$P_1$：加载 $flag[0]$ 为 $\\text{true}$（即使对 $flag[0]$ 的存储仍在 $P_0$ 中缓冲）并自旋等待。\n- 结果：$P_1$ 等待，互斥性得以保持。\n\nD. 导致两个进程在进入循环中死锁的交错执行：\n- 步骤 $1$：$P_0$ 和 $P_1$ 都使其对 $flag$ 的存储变得可见。\n- 步骤 $2$：两者都将 $turn$ 设置为对方的标识符。\n- 步骤 $3$：两者都读取 $flag[\\cdot]$ 为 $\\text{true}$，并同时读取 $turn$ 等于对方的标识符，因此两个条件都为 $\\text{true}$，两者都永远自旋等待。\n- 结果：两个进程都无限期地卡在进入循环中。\n\n在移除单个栅栏后，哪个选项正确描述了在所述模型下破坏互斥性的可行反例交错执行？\n\n- A\n- B\n- C\n- D", "solution": "首先对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- **进程：** 两个进程，$P_0$ 和 $P_1$。\n- **共享变量：** 一个布尔数组 $flag[\\,]$，由进程标识符 $\\{0,1\\}$ 索引，以及一个共享变量 $turn \\in \\{0,1\\}$。\n- **初始状态：** $flag[0] = \\text{false}$，$flag[1] = \\text{false}$，以及 $turn = 0$。\n- **修改后的进入协议（移除了栅栏），对于 $P_i$，$i \\in \\{0,1\\}$：**\n    1. 设置 $flag[i] \\leftarrow \\text{true}$。\n    2. 设置 $turn \\leftarrow 1 - i$。\n    3. 当 $(flag[1-i] \\land (turn = 1-i))$ 时忙等待。\n    4. 进入临界区。\n- **$P_i$ 的退出协议：**\n    1. 设置 $flag[i] \\leftarrow \\text{false}$。\n- **内存模型：**\n    - 实现了每核存储缓冲。\n    - 存储操作对发出该操作的进程立即变得可见。\n    - 存储操作在经过不确定性延迟后对其他进程可见。\n    - 加载操作可以继续，而无需等待发出该操作的进程先前对不同地址的存储操作对其他进程可见。\n    - 一个完整的内存栅栏 $F$（在本题场景中被移除）会排空存储缓冲区。\n    - 对同一内存地址的存储不会被重排序（遵守按位置一致性）。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据。所描述的场景涉及用于互斥的 Peterson 算法以及一个简化但标准的弱内存一致性模型（具体来说，是一个带有存储缓冲的模型，类似于完全存储定序或 TSO）。这些是操作系统和计算机体系结构中的基本主题。问题提得很好，要求在给定的规则下找到一个具体的反例（违反互斥性）。语言客观而精确。前提条件并不矛盾；移除栅栏是核心的改变，需要探讨其后果。该设置并非微不足道，需要仔细推理算法和内存模型之间的相互作用。问题有效。\n\n**步骤3：结论与行动**\n问题有效。我将继续进行解决方案推导和选项分析。\n\n**推导与选项分析**\n\n目标是为修改后的算法找到一个可行的指令交错执行，该交错执行会导致违反互斥性，即 $P_0$ 和 $P_1$ 同时处于其临界区内。\n\n如果 $P_0$ 绕过其忙等待循环，并且 $P_1$ 也绕过其忙等待循环，就会发生互斥性违反。\n- 为了让 $P_0$ 进入，条件 $(flag[1] \\land (turn = 1))$ 必须评估为 $\\text{false}$。\n- 为了让 $P_1$ 进入，条件 $(flag[0] \\land (turn = 0))$ 必须评估为 $\\text{false}$。\n\n指定内存模型的关键特征是存储缓冲。当 $P_i$ 执行一个存储指令，如 $flag[i] \\leftarrow \\text{true}$ 时，新值被写入其本地存储缓冲区。为了让另一个进程 $P_{1-i}$ 看到这个新值，该存储必须从 $P_i$ 的缓冲区刷新到主内存，这在不确定性延迟之后发生。至关重要的是，没有内存栅栏，$P_i$ 可以在其对 $flag[i]$ 的存储变为全局可见之前，执行后续指令（如设置 $turn$ 或读取 $flag[1-i]$）。\n\n让我们基于这个原理构建一个反例：\n1.  $P_0$ 执行 `Set $flag[0] \\leftarrow \\text{true}$`。这个写操作被保留在 $P_0$ 的存储缓冲区中。主内存仍然包含 $flag[0] = \\text{false}$。\n2.  $P_1$ 执行 `Set $flag[1] \\leftarrow \\text{true}$`。这个写操作被保留在 $P_1$ 的存储缓冲区中。主内存仍然包含 $flag[1] = \\text{false}$。\n3.  $P_0$ 继续进行其忙等待检查：`while $(flag[1] \\land (turn = 1))$`。它执行对 $flag[1]$ 的加载操作。由于 $P_1$ 对 $flag[1]$ 的写操作仍在缓冲区中，$P_0$ 从主内存中读取的值是 $\\text{false}$。\n4.  $P_0$ 的条件变为 $(\\text{false} \\land (\\dots))$，这无疑是 $\\text{false}$。因此，$P_0$ 退出循环并进入临界区。\n5.  $P_1$ 继续进行其忙等待检查：`while $(flag[0] \\land (turn = 0))$`。它执行对 $flag[0]$ 的加载操作。由于 $P_0$ 对 $flag[0]$ 的写操作仍在缓冲区中，$P_1$ 从主内存中读取的值是 $\\text{false}$。\n6.  $P_1$ 的条件变为 $(\\text{false} \\land (\\dots))$，这无疑是 $\\text{false}$。因此，$P_1$ 也退出其循环并进入临界区。\n\n这个序列导致 $P_0$ 和 $P_1$ 同时处于临界区内，这明显违反了互斥性。在这种情况下，对 `turn` 变量的操作是无关紧要的，因为逻辑与表达式的第一部分（$flag[1-i]$）足以使两个进程的整个条件都为假。这个场景在指定的弱内存模型下是可行的。\n\n现在，我们根据这一理解来评估每个提供的选项。\n\n**A. 利用两个进程的存储缓冲的交错执行：**\n- **步骤1：$P_0$：$flag[0] \\leftarrow \\text{true}$ (已缓冲)。** 可行。\n- **步骤2：$P_1$：$flag[1] \\leftarrow \\text{true}$ (已缓冲)。** 可行。\n- **步骤3  4：** 对 `turn` 的写操作发生。我们假设它们变得可见，其中 $P_1$ 的写操作是最后一个，因此内存中有 $turn=0$。对 `flag` 的写操作仍被缓冲。这是合理的，因为对不同地址的存储在可见性上可以被重排序。\n- **步骤5：$P_0$：加载 $flag[1]$ 并读到 $\\text{false}$（因为 $flag[1]$ 仍在 $P_1$ 中缓冲），将条件 $(flag[1] \\land (turn = 1))$ 评估为 $\\text{false}$，并进入临界区。** 这是正确的。$P_0$ 从内存中读取了 $flag[1]$ 的过时值，即 $\\text{false}$。布尔条件 $(\\text{false} \\land \\dots)$ 评估为 $\\text{false}$，$P_0$ 进入临界区。\n- **步骤6：$P_1$：加载 $flag[0]$ 并读到 $\\text{false}$（因为 $flag[0]$ 仍在 $P_0$ 中缓冲），将条件 $(flag[0] \\land (turn = 0))$ 评估为 $\\text{false}$，并进入临界区。** 这也是正确的。$P_1$ 读取了 $flag[0]$ 的过时值 $\\text{false}$。条件 $(\\text{false} \\land \\dots)$ 评估为 $\\text{false}$，$P_1$ 进入临界区。\n- **结果：$P_0$ 和 $P_1$ 同时处于临界区内。**\n这个选项准确地描述了一个在给定内存模型下可行的有效反例，并证明了互斥性的违反。\n**结论：正确。**\n\n**B. 在 `flag` 上出现竞争但由 `turn` 解决的交错执行：**\n这个选项描述了一个所有写操作都立即变得可见的场景，这是顺序一致性系统的特征，而非本题指定的模型。它追溯了 Peterson 算法的一次正确执行，其中互斥性得以保持：`flag` 表示竞争，而 `turn` 解决了它。由于问题要求一个*违反*互斥性的交错执行，此选项不正确。\n**结论：不正确。**\n\n**C. 假设对同一观察者存在写-写重排序的交错执行：**\n- **步骤3：$P_1$：加载 $flag[0]$ 为 `true`（即使对 $flag[0]$ 的存储仍在 $P_0$ 中缓冲）...** 这个陈述包含一个直接的矛盾。如果一个存储在 $P_0$ 中是“已缓冲”，意味着它尚未对 $P_1$ 可见。因此，$P_1$ 无法加载到值 `true`。它会从内存中加载旧值 (`false`)。在定义的内存模型下，此步骤的前提是不可能的。\n**结论：不正确。**\n\n**D. 导致两个进程在进入循环中死锁的交错执行：**\n这个选项声称两个进程都可能永远卡在它们的忙等待循环中。让我们分析一下。假设内存状态为 $flag[0] = \\text{true}$，$flag[1] = \\text{true}$，并且（在两个进程都写入后）$turn = 0$。\n- $P_0$ 检查 $(flag[1] \\land (turn = 1))$。这是 $(\\text{true} \\land (0 = 1))$，结果为 $\\text{false}$。$P_0$ 进入临界区。\n- $P_1$ 检查 $(flag[0] \\land (turn = 0))$。这是 $(\\text{true} \\land (0 = 0))$，结果为 $\\text{true}$。$P_1$ 自旋等待。\n没有死锁。`turn` 变量成功地仲裁了访问，确保一个进程可以继续执行。此外，死锁违反的是*前进*属性，而问题明确要求的是违反*互斥性*。\n**结论：不正确。**\n\n只有选项 A 提供了一个在指定内存模型下可行的交错执行，该执行正确地证明了对互斥属性的违反。", "answer": "$$\\boxed{A}$$", "id": "3687333"}, {"introduction": "手动追踪线程交错来寻找并发漏洞虽然富有启发性，但对于复杂系统而言并不可行。这个综合性练习将让你从分析者转变为创造者：你将用C语言实现一个确定性的测试工具。你的程序将通过系统性地探索随机线程调度，来实证地发现一个有缺陷的锁协议中的互斥性违规问题，为你提供一个亲身实践的机会，初步体验自动化并发测试的世界。[@problem_id:3687277]", "problem": "您需要用 C 语言实现一个确定性测试工具，通过生成线程步骤的随机交错（调度）来经验性地检查一个简单共享锁协议的互斥属性，并在该属性被违反时报告最小反例。该工具必须完全自包含，除了产生最终要求的单行输出外，不执行任何输入或输出，并且不得访问网络或文件系统。\n\n基本和核心定义：\n- 设有 $n$ 个并发线程，每个线程都试图执行一个临界区。互斥的正确性要求规定，在任何逻辑时间 $t$，处于临界区内的线程数最多为 $1$，即 $\\forall t,\\; c(t) \\le 1$，其中 $c(t)$ 表示经过恰好 $t$ 个离散交错步骤后，临界区内的线程计数。\n- 我们采用交错语义：一个全局执行被建模为一个有限调度 $\\sigma \\in \\{0,1,\\dots,n-1\\}^{L}$，其中 $L$ 是调度长度，$\\sigma[k]$ 表示被选中执行第 $(k+1)$ 个步骤的线程。从一个初始状态执行调度 $\\sigma$ 会通过重复应用由每个线程的步骤函数在共享内存上引起的转换关系，产生一个全局状态序列。在模型中单个步骤操作的粒度上，该语义是顺序一致的。\n- 我们将互斥的反例定义为调度的一个前缀 $\\pi$，当执行 $\\pi$ 时，存在第一个索引 $k$，使得 $c(k) \\ge 2$。最小反例是关于长度而言最短的此类前缀。\n\n被测系统（待建模的两个锁协议）：\n- 模型 $\\mathsf{BROKEN}$（非原子性检查后设置）：共享锁是一个整数 $\\ell \\in \\{0,1\\}$，初始值为 $\\ell = 0$。每个线程 $i$ 使用一个私有寄存器 $r_i$ 执行以下步骤序列：\n  - 步骤 A：将 $\\ell$ 读入 $r_i$。\n  - 步骤 B：如果 $r_i = 0$，则写入 $\\ell \\leftarrow 1$，否则跳至完成。\n  - 步骤 C：进入临界区（将 $c$ 增加 $1$）。\n  - 步骤 D：退出临界区（将 $c$ 减少 $1$ 并写入 $\\ell \\leftarrow 0$），然后完成。\n  已知此协议在交错语义下是不正确的，因为两个线程都可以在任一方写入之前读到 $\\ell = 0$，导致两者都进入临界区。\n- 模型 $\\mathsf{ATOMIC}$（原子性测试并设置）：一个单一的原子步骤取代了 A 和 B：如果 $\\ell = 0$，则写入 $\\ell \\leftarrow 1$ 并进入临界区，否则跳至完成。步骤 C 和 D 相同。在交错语义下，此协议强制实现互斥。\n\n测试工具要求：\n- 随机调度生成：对于给定的参数元组 $(n, L_{\\max}, A, s, \\text{model})$，生成最多 $A$ 个候选调度，每个调度长度最多为 $L_{\\max}$。生成方法是，在每一步中，从尚未达到完成状态的线程集合中，均匀随机地选择一个可运行的线程索引 $i \\in \\{0,\\dots,n-1\\}$。使用以整数种子 $s$ 初始化的伪随机数生成器以确保确定性。每个被选中的线程按照模型指定的协议前进一步，并将该选择记录在候选调度中。如果在达到长度 $L_{\\max}$ 之前所有线程都已完成，则提前停止。如果在生成过程中的第 $k$ 步检测到互斥违规，则立即停止该候选调度的生成，并将其长度为 $k$ 的前缀作为初始反例。\n- 违规检测：给定任何有限调度 $\\sigma$ 和模型，定义一个模拟过程，该过程从初始状态重放 $\\sigma$，在每个位置为所选线程应用最多一个步骤。如果在第 $k$ 步后临界区中的线程数超过 $1$，则返回首次违规的索引 $k \\in \\{1,\\dots,|\\sigma|\\}$；如果在 $\\sigma$ 内没有发生违规，则返回 $0$。如果索引指向一个已经处于完成状态的线程，则该步骤为空操作。\n- 通过删除进行最小反例规约：对于任何违规的调度 $\\sigma$，执行迭代删除：尝试从 $\\sigma$ 中移除单个位置（一次一个，从左到右扫描），然后重新模拟；如果对于缩短后的调度，违规仍然发生（可能在更早的索引处），则保留该删除并从同一索引继续扫描；否则，撤销该特定删除并前进到下一个位置。重复此过程直到达到不动点。结果必须是相对于单元素删除而言最小的反例。\n- 跨尝试的聚合：对于每个参数元组，在 $A$ 个生成的候选调度中进行搜索，将每个违规的候选调度规约为一个最小反例，并保留找到的最短长度（任意打破平局）。如果在所有 $A$ 次尝试中都未找到违规，则为该参数元组报告 $0$。\n\n测试套件和要求输出：\n提供以下四个参数集的结果，每个参数集指定为 $(n, \\text{model}, L_{\\max}, A, s)$:\n- 测试 $1$：$(n=2, \\text{model}=\\mathsf{BROKEN}, L_{\\max}=20, A=500, s=1)$。对于这种情况，存在一个最小反例，其长度为 $6$，因为两个线程各需要恰好三个步骤（读取、写入、进入）才能达到违规状态，即第二个线程在第一个线程位于临界区内时进入。\n- 测试 $2$：$(n=2, \\text{model}=\\mathsf{ATOMIC}, L_{\\max}=20, A=500, s=2)$。不存在反例；正确的协议强制实现互斥。\n- 测试 $3$：$(n=3, \\text{model}=\\mathsf{BROKEN}, L_{\\max}=5, A=1000, s=3)$。不存在长度最多为 $5$ 的反例，因为最短的违规至少需要 $6$ 个步骤。\n- 测试 $4$：$(n=1, \\text{model}=\\mathsf{BROKEN}, L_{\\max}=10, A=200, s=4)$。根据定义，单个线程不存在反例。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含四个测试的结果，格式为一个由方括号括起来的逗号分隔的整数列表，没有空格，也没有其他文本。例如，一个有效的格式是 `[x,y,z,w]`。对于本问题，程序必须完全按照上述测试的顺序打印最小反例长度的列表，对于在指定的尝试次数和长度限制内未找到违规的任何测试，使用 $0$。", "solution": "设计一个确定性测试工具以经验性地检查互斥违规的问题是有效的。它在科学上基于并发编程和操作系统理论中广为人知的原理，特别是临界区问题。该问题是适定的，为系统模型（$\\mathsf{BROKEN}$ 和 $\\mathsf{ATOMIC}$ 协议）、执行语义（交错）、正确性属性（互斥）以及所需的测试算法过程（随机调度生成、违规模拟和反例规约）提供了一套完整且一致的定义。测试套件的参数和预期结果都已明确指定且计算上是可行的。整个问题是可形式化且客观的，不依赖于主观声明或不可验证的前提。\n\n该解决方案涉及实现一个单线程 C 程序，该程序根据给定的调度模拟 $n$ 个线程的并发执行。该测试工具将随机生成调度，检查违规情况，并对任何发现的反例应用确定性规约算法。最终的实现将是自包含的，并通过为指定的测试套件编排这些组件来产生所需的输出。\n\n设计基于以下原则和数据结构：\n\n**1. 系统状态表示**\n为了模拟系统，我们必须对共享的全局状态和每个线程的私有状态进行建模。\n\n-   **模型枚举**：定义一个枚举 `Model`，以区分被测试的两种协议：$\\mathsf{BROKEN}$ 和 $\\mathsf{ATOMIC}$。\n-   **线程私有状态 (`ThreadState`)**：一个结构体 `ThreadState` 存储单个线程 $i$ 的状态。它包含：\n    -   `int pc`：一个程序计数器，用于跟踪线程在锁定协议中的当前步骤（例如，步骤 A、B、C 或 D）。\n    -   `int r`：在 $\\mathsf{BROKEN}$ 模型中使用的私有寄存器 $r_i$，用于存储最后读取的锁的值。\n    -   `bool done`：一个标志，指示线程是否已完成其执行并进入“完成”状态。\n-   **全局共享状态 (`GlobalState`)**：一个结构体 `GlobalState` 封装了整个系统的状态。它包含：\n    -   `int lock`：共享锁变量 $\\ell$，可以是 $0$（未锁定）或 $1$（已锁定）。它被初始化为 $0$。\n    -   `int cs_count`：一个计数器 $c(t)$，用于记录当前在临界区中的线程数。如果 $c(t)  1$，则发生违规。\n    -   `ThreadState* threads`：一个大小为 $n$ 的动态分配数组，用于保存所有线程的状态。\n\n**2. 模拟引擎**\n测试工具的核心是能够模拟给定调度 $\\sigma$ 的执行。这由两个函数处理。\n\n-   **`step_thread(GlobalState* state, int thread_id, Model model)`**：此函数根据指定的 `thread_id` 的当前 `pc` 和指定的 `model` 将其推进一个步骤。它实现了问题中定义的状态转换规则。例如，在 $\\mathsf{BROKEN}$ 模型中，如果一个线程的 `pc` 对应于步骤 A，此函数将执行 `state-threads[thread_id].r = state-lock;` 并增加 `pc`。如果一个线程被标记为 `done`，则此函数按要求执行空操作。\n-   **`simulate(const int* schedule, int len, int n, Model model)`**：此函数模拟一个完整的调度。它首先初始化一个 `GlobalState`。然后，它从索引 $k=0$ 到 $k=len-1$ 遍历 `schedule` 数组。在每次迭代中，它为 `schedule[k]` 指定的线程调用 `step_thread`。在每一步之后，它检查 `state-cs_count  1` 是否成立。如果成立，说明发生了互斥违规，函数立即返回基于 1 的步骤索引 $k+1$。如果整个调度执行完毕而计数未超过 $1$，则返回 $0$。\n\n**3. 随机调度生成和即时检查**\n测试工具必须生成随机调度来探测状态空间以寻找错误。\n\n-   **`generate_and_check(int n, Model model, int l_max, unsigned int seed, int* out_schedule)`**：此函数以整数 $s$ 为种子，生成一个长度最多为 $L_{\\max}$ 的随机调度。在生成的每一步中，它识别出*可运行*线程的集合（那些未处于 `done` 状态的线程）。然后，它使用 `rand()` 函数从该集合中均匀随机地选择一个线程。所选线程的索引被附加到调度中，并使用 `step_thread` 将其状态推进一个步骤。关键是，在模拟每一步之后，函数会检查是否存在互斥违规。如果在第 $k$ 步发现违规，生成将立即停止，长度为 $k$ 的违规前缀将存储在 `out_schedule` 中，并返回其长度 $k$。如果没有发生违规并且所有线程都变为 `done`，或者调度达到长度 $L_{\\max}$，则函数返回 $0$。\n\n**4. 反例规约**\n仅仅找到一个违规的调度是不够的；问题要求找到一个*最小*的。指定的规约算法是迭代删除。\n\n-   **`reduce_counterexample(int** schedule_ptr, int* len_ptr, int n, Model model)`**：此函数接收一个违规调度并尝试缩短它。它实现了一个贪婪的不动点算法。它从左到右（索引 $i=0, 1, \\dots$）重复扫描调度。在每个位置 $i$，它创建一个移除了第 $i$ 个元素的临时调度。然后，它在此缩短的调度上调用 `simulate`。如果违规持续存在（`simulate` 返回非零值），则该删除被永久化：原始调度被较短的调度替换，并且规约过程从现在已修改的调度上的同一索引 $i$ 继续。如果删除消除了违规，则丢弃该更改，扫描继续到下一个索引 $i+1$。整个过程重复进行，直到对调度的一次完整遍历没有产生成功的删除，此时已达到不动点，并且该调度相对于单元素删除是最小的。\n\n**5. 编排与测试执行**\n`main` 函数为给定的测试套件编排整个过程。\n\n-   它定义一个 `TestCase` 结构体数组，每个结构体包含一个参数元组 $(n, \\text{model}, L_{\\max}, A, s)$。\n-   它遍历每个测试用例。对于给定的测试用例，它使用 $s$ 为伪随机数生成器设置种子。\n-   它运行一个循环进行 $A$ 次尝试。在每次尝试中，它调用 `generate_and_check`。如果发现违规，生成的调度将被传递给 `reduce_counterexample`。然后将规约后调度的长度与该测试用例迄今为止找到的最短长度进行比较，并保留最小值。\n-   如果在所有 $A$ 次尝试中都未发现违गण，则该测试用例的结果为 $0$。\n-   最后，程序以指定格式打印所有测试用例的结果：`[result1,result2,result3,result4]`。\n\n该设计系统地、结构化地、可验证地实现了问题陈述的所有要求。", "answer": "[6,0,0,0]", "id": "3687277"}]}