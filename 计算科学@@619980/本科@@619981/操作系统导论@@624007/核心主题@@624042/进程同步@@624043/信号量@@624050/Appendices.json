{"hands_on_practices": [{"introduction": "计数信号量的最基本规则是，其代表可用资源的内部计数值永远不能为负。本练习 [@problem_id:3681948] 让你扮演一名系统侦探。通过分析一个给定的成功操作序列，你需要推断出要使该序列合法，系统最初至少需要多少资源，这个过程将加深你对信号量核心不变性（invariant）的理解。", "problem": "计数信号量是一种具有整数状态的抽象数据类型。设 $S$ 是一个单一的计数信号量，用于保护对一个相同资源池的访问。信号量 $S$ 被初始化为一个未知的非负整数 $k$，它等于初始可用的资源单元数量。$P(S)$ 操作（也称为 wait 或 down）尝试获取一个单元：它仅在至少有一个单元可用时才能完成，此时 $S$ 的内部状态减 1；否则，调用者被阻塞，该操作直到未来的某个 $V(S)$ 操作增加了可用性后才能完成。$V(S)$ 操作（也称为 signal 或 up）释放一个单元并将 $S$ 的内部状态加 1，这可能会允许一个被阻塞的 $P(S)$ 操作完成。假设没有所有权要求：任何线程都可以调用 $V(S)$。\n\n给定一个来自 $6$ 个线程 $\\{A,B,C,D,E,F\\}$ 的对 $S$ 操作的完成轨迹。该轨迹列出了每个 $P(S)$ 或 $V(S)$ 操作完成的全局实时顺序。因为该轨迹只记录完成（而非尝试），一个本会阻塞的 $P(S)$ 操作只有在足够多的 $V(S)$ 操作完成以提供可用单元之后，才会出现在轨迹中。\n\n观察到的完成轨迹是以下由线程-操作对组成的有序序列：\n$(A,P)$, $(B,P)$, $(C,P)$, $(B,V)$, $(D,P)$, $(E,P)$, $(C,V)$, $(F,P)$, $(A,V)$, $(D,V)$, $(B,P)$, $(E,V)$, $(F,V)$, $(C,P)$, $(B,V)$, $(A,P)$, $(A,V)$, $(C,V)$, $(D,P)$, $(D,V)$.\n\n根据上述标准计数信号量语义，确定使此轨迹合法的最小整数 $k$。合法意味着轨迹中没有任何一个已完成的 $P(S)$ 操作是在没有可用单元时完成的。请以单个整数（无单位）的形式给出答案。如果需要四舍五入，题目会指明保留几位有效数字；然而，本题要求的是精确的整数。", "solution": "问题要求找出使得给定的已完成信号量操作轨迹合法的最小非负整数初始信号量计数值 $k$。\n\n设轨迹中第 $t$ 个操作完成后计数信号量 $S$ 的状态为 $S_t$。信号量的初始状态为 $S_0 = k$，其中 $k$ 是一个非负整数，表示初始可用资源的数量。\n\n信号量操作的标准语义如下：\n1.  一个在步骤 $t$ 的 $P(S)$ 操作（wait）仅当操作前信号量的值 $S_{t-1}$ 大于 $0$ 时才能完成。由于信号量的值是整数，这等价于 $S_{t-1} \\ge 1$。操作完成后，信号量的值递减：$S_t = S_{t-1} - 1$。\n2.  一个在步骤 $t$ 的 $V(S)$ 操作（signal）无条件完成，并使信号量的值递增：$S_t = S_{t-1} + 1$。\n\n这些规则的一个直接推论是，信号量的内部状态必须始终为非负。对于一个 $P$ 操作，如果 $S_{t-1} \\ge 1$，那么操作后 $S_t = S_{t-1} - 1 \\ge 0$。对于一个 $V$ 操作，如果 $S_{t-1} \\ge 0$，那么 $S_t = S_{t-1} + 1 \\ge 1$。由于初始状态 $k$ 是非负的，所以对于所有 $t \\ge 0$，信号量的值 $S_t$ 必须保持非负。\n\n为了分析该轨迹，我们可以定义一个函数 $C_t$，表示在 $t$ 个操作后净获取的资源数量。这是截至步骤 $t$ 已完成的 $P$ 操作总数减去已完成的 $V$ 操作总数。设 $P_t$ 和 $V_t$ 分别为轨迹前 $t$ 步中 $P$ 和 $V$ 操作的累积计数。那么，$C_t = P_t - V_t$。\n\n$t$ 个操作后信号量的值可以用其初始值 $k$ 和净获取量 $C_t$ 来表示：\n$$S_t = S_0 - (P_t - V_t) = k - C_t$$\n\n为使轨迹合法，对于所有步骤 $t=1, \\dots, 20$，必须满足从信号量语义推导出的两个条件：\n1.  信号量的值绝不能为负：$S_t \\ge 0$。这意味着 $k - C_t \\ge 0$，或者对于所有 $t \\in \\{1, \\dots, 20\\}$，$k \\ge C_t$。\n2.  对于任何是 $P$ 操作的步骤 $t$，操作前的值必须至少为 1：$S_{t-1} \\ge 1$。这意味着 $k - C_{t-1} \\ge 1$，或者 $k \\ge 1 + C_{t-1}$。\n\n让我们分析这两个条件之间的关系。对于步骤 $t$ 的任何 $P$ 操作，我们有 $C_t = C_{t-1} + 1$。第二个条件 $k \\ge 1 + C_{t-1}$ 可以重写为 $k \\ge C_t$。这意味着步骤 $t$ 的 $P$ 操作的条件等价于要求 $k \\ge C_t$，其中 $C_t$ 是 $P$ 操作*之后*的净获取计数。\n\n对于步骤 $t$ 的任何 $V$ 操作，我们有 $C_t = C_{t-1} - 1$。第一个条件 $k \\ge C_t$ 比 $k \\ge C_{t-1}$（该条件必须成立，因为 $t-1$ 是轨迹中的一个有效步骤）更不严格。因此，对 $k$ 的关键约束来自于确保对所有 $t$ 都有 $S_t \\ge 0$。并发持有的资源的最大数量不得超过初始资源数量 $k$。\n\n综合这些，整个轨迹合法的单一充要条件是，在每一步 $t$，$k$ 都必须大于或等于净获取计数 $C_t$。为了找到可能的最小整数 $k$，我们必须找到 $C_t$ 在整个轨迹中所达到的最大值。\n$$k_{min} = \\max_{t \\in \\{0, 1, \\dots, 20\\}} C_t$$\n\n我们现在为给定轨迹中的每一步计算 $C_t$ 的值。设 $C_0 = 0$。\n\n- $t=1: (A,P) \\implies C_1 = C_0 + 1 = 1$\n- $t=2: (B,P) \\implies C_2 = C_1 + 1 = 2$\n- $t=3: (C,P) \\implies C_3 = C_2 + 1 = 3$\n- $t=4: (B,V) \\implies C_4 = C_3 - 1 = 2$\n- $t=5: (D,P) \\implies C_5 = C_4 + 1 = 3$\n- $t=6: (E,P) \\implies C_6 = C_5 + 1 = 4$\n- $t=7: (C,V) \\implies C_7 = C_6 - 1 = 3$\n- $t=8: (F,P) \\implies C_8 = C_7 + 1 = 4$\n- $t=9: (A,V) \\implies C_9 = C_8 - 1 = 3$\n- $t=10: (D,V) \\implies C_{10} = C_9 - 1 = 2$\n- $t=11: (B,P) \\implies C_{11} = C_{10} + 1 = 3$\n- $t=12: (E,V) \\implies C_{12} = C_{11} - 1 = 2$\n- $t=13: (F,V) \\implies C_{13} = C_{12} - 1 = 1$\n- $t=14: (C,P) \\implies C_{14} = C_{13} + 1 = 2$\n- $t=15: (B,V) \\implies C_{15} = C_{14} - 1 = 1$\n- $t=16: (A,P) \\implies C_{16} = C_{15} + 1 = 2$\n- $t=17: (A,V) \\implies C_{17} = C_{16} - 1 = 1$\n- $t=18: (C,V) \\implies C_{18} = C_{17} - 1 = 0$\n- $t=19: (D,P) \\implies C_{19} = C_{18} + 1 = 1$\n- $t=20: (D,V) \\implies C_{20} = C_{19} - 1 = 0$\n\n对于 $t \\in \\{1, \\dots, 20\\}$，$C_t$ 的值序列为：\n$\\{1, 2, 3, 2, 3, 4, 3, 4, 3, 2, 3, 2, 1, 2, 1, 2, 1, 0, 1, 0\\}$。\n\n该序列中的最大值为：\n$$\\max(C_t) = 4$$\n这个最大值在轨迹中的两个点达到：第 $6$ 个操作 $(E,P)$ 之后和第 $8$ 个操作 $(F,P)$ 之后。\n\n为使轨迹合法，$k$ 必须至少是这个最大值。因此，$k \\ge 4$。$k$ 的最小整数值为 $4$。\n\n为了验证，如果我们选择 $k=3$，该轨迹将是非法的。在步骤 $t=6$，操作是 $(E,P)$。此操作之前的状态将是 $S_5 = k - C_5 = 3 - 3 = 0$。如果信号量的值为 $0$，则 $P$ 操作无法完成，因为它要求值至少为 $1$。因此，$k=3$ 不是一个有效的初始值。\n\n如果我们选择 $k=4$，第 $6$ 个操作之前的状态是 $S_5 = k - C_5 = 4 - 3 = 1$。这是一个 $P$ 操作可以完成的有效状态。操作之后，状态变为 $S_6 = S_5 - 1 = 0$，这是非负的。对所有 $P$ 操作的检查证实 $k=4$ 使整个轨迹合法。\n\n因此，使该轨迹合法的最小非负整数 $k$ 是 $4$。", "answer": "$$\\boxed{4}$$", "id": "3681948"}, {"introduction": "单个信号量的行为是直接的，但当多个线程竞争多个信号量时，复杂性便随之而来，并可能导致并发编程中最臭名昭著的问题之一：死锁。本练习 [@problem_id:3681944] 将引导你逐步分析一个系统事件日志。你的任务是追踪每个线程和信号量的状态，从而精确定位出形成循环等待条件、导致整个系统陷入停顿的确切时刻。", "problem": "考虑一个拥有两个计数信号量 $S$ 和 $T$ 的系统，它们均被初始化为整数值 $1$。所有信号量操作均遵循其标准定义：“等待”操作 $P(X)$ 在信号量 $X$ 的值严格大于 $0$ 时，会将其值减一；否则，调用线程将被阻塞并进入 $X$ 的等待队列。“信号”操作 $V(X)$ 在没有线程等待时，会将 $X$ 的值加一；否则，将唤醒一个等待线程（使其出队），该线程将完成其挂起的 $P(X)$ 操作，而信号量的整数值保持在 $0$ 不变。队列遵循先入先出 (FIFO) 原则。被阻塞的线程无法执行任何后续操作，直到一个对应的 $V$ 操作在它们所等待的信号量上执行，从而解除它们的阻塞状态。在各自的时间戳上，所有 $P$ 和 $V$ 操作的执行时间均可忽略不计。对已持有的信号量不存在抢占。\n\n三个线程 $T_1$、$T_2$ 和 $T_3$ 在给定的时间戳（单位为毫秒）执行以下操作：\n- 在 $t = 0\\,\\mathrm{ms}$ 时，线程 $T_1$ 调用 $P(S)$。\n- 在 $t = 1\\,\\mathrm{ms}$ 时，线程 $T_2$ 调用 $P(T)$。\n- 在 $t = 2\\,\\mathrm{ms}$ 时，线程 $T_3$ 调用 $P(S)$。\n- 在 $t = 3\\,\\mathrm{ms}$ 时，线程 $T_1$ 调用 $P(T)$。\n- 在 $t = 4\\,\\mathrm{ms}$ 时，线程 $T_2$ 调用 $P(S)$。\n\n在 $t = 4\\,\\mathrm{ms}$ 之后，没有其他 $P$ 或 $V$ 操作发生。请仅根据计数信号量 $P$ 和 $V$ 的基本定义以及标准的死锁条件，重构在每个列出的时间戳上，$S$ 和 $T$ 的值及其等待队列成员随时间的变化。然后，根据上述日志和给定的语义，确定该系统中可能出现真正死锁的最早时间戳 $t^\\star$（单位为毫秒）。\n\n请以毫秒为单位的单个数值时间戳形式给出最终答案。不要四舍五入，报告精确值。", "solution": "我们将追踪系统在每个指定时间戳的状态。系统状态由信号量 $S$ 和 $T$ 的整数值、它们各自等待队列（我们记为 $Q_S$ 和 $Q_T$）的内容以及每个线程（$T_1, T_2, T_3$）的状态来定义。\n\n**初始状态 (在 $t = 0\\,\\mathrm{ms}$ 之前):**\n- 信号量值：$S = 1$, $T = 1$。\n- 等待队列：$Q_S = []$, $Q_T = []$ (均为空)。\n- 线程状态：$T_1$, $T_2$, $T_3$ 处于就绪状态。\n\n**在 $t = 0\\,\\mathrm{ms}$ 时：**\n- **操作：** 线程 $T_1$ 调用 $P(S)$。\n- **分析：** $S$ 的值为 $1$，大于 $0$。操作成功。$S$ 的值减一。$T_1$ 不阻塞并继续执行。在信号量逻辑的上下文中，$T_1$ 现在“持有”由 $S$ 代表的一个资源单位。\n- **$t = 0\\,\\mathrm{ms}$ 后的状态：**\n  - $S = 0$, $Q_S = []$\n  - $T = 1$, $Q_T = []$\n  - $T_1$：运行中\n  - $T_2$：就绪\n  - $T_3$：就绪\n\n**在 $t = 1\\,\\mathrm{ms}$ 时：**\n- **操作：** 线程 $T_2$ 调用 $P(T)$。\n- **分析：** $T$ 的值为 $1$，大于 $0$。操作成功。$T$ 的值减一。$T_2$ 不阻塞并继续执行。$T_2$ 现在“持有”由 $T$ 代表的一个资源单位。\n- **$t = 1\\,\\mathrm{ms}$ 后的状态：**\n  - $S = 0$, $Q_S = []$\n  - $T = 0$, $Q_T = []$\n  - $T_1$：运行中\n  - $T_2$：运行中\n  - $T_3$：就绪\n\n**在 $t = 2\\,\\mathrm{ms}$ 时：**\n- **操作：** 线程 $T_3$ 调用 $P(S)$。\n- **分析：** $S$ 的值为 $0$。操作无法完成。线程 $T_3$ 被阻塞并加入到 $S$ 的等待队列。$S$ 的值保持为 $0$。\n- **$t = 2\\,\\mathrm{ms}$ 后的状态：**\n  - $S = 0$, $Q_S = [T_3]$\n  - $T = 0$, $Q_T = []$\n  - $T_1$：运行中\n  - $T_2$：运行中\n  - $T_3$：在 $S$ 上阻塞\n\n**在 $t = 3\\,\\mathrm{ms}$ 时：**\n- **操作：** 线程 $T_1$ 调用 $P(T)$。\n- **分析：** $T$ 的值为 $0$。操作无法完成。线程 $T_1$ 被阻塞并加入到 $T$ 的等待队列。$T$ 的值保持为 $0$。\n- **$t = 3\\,\\mathrm{ms}$ 后的状态：**\n  - $S = 0$, $Q_S = [T_3]$\n  - $T = 0$, $Q_T = [T_1]$\n  - $T_1$：在 $T$ 上阻塞\n  - $T_2$：运行中\n  - $T_3$：在 $S$ 上阻塞\n- **死锁检查：** 此时，$T_1$ 持有资源 $S$ 并等待资源 $T$。$T_3$ 正在等待资源 $S$。然而，$T_2$ 持有资源 $T$ 并且仍处于运行状态。因为 $T_2$ 没有被阻塞，它理论上可以执行一个 $V(S)$ 或 $V(T)$ 操作，这将打破依赖关系。因此，系统尚未处于死锁状态。\n\n**在 $t = 4\\,\\mathrm{ms}$ 时：**\n- **操作：** 线程 $T_2$ 调用 $P(S)$。\n- **分析：** $S$ 的值为 $0$。操作无法完成。线程 $T_2$ 被阻塞并加入到 $S$ 的等待队列。由于队列是 FIFO 的， $T_2$ 被放置在 $T_3$ 之后。$S$ 的值保持为 $0$。\n- **$t = 4\\,\\mathrm{ms}$ 后的状态：**\n  - $S = 0$, $Q_S = [T_3, T_2]$\n  - $T = 0$, $Q_T = [T_1]$\n  - $T_1$：在 $T$ 上阻塞\n  - $T_2$：在 $S$ 上阻塞\n  - $T_3$：在 $S$ 上阻塞\n\n**在 $t^\\star = 4\\,\\mathrm{ms}$ 时的死锁分析：**\n如果满足以下四个必要条件，就会发生死锁：\n1.  **互斥条件 (Mutual Exclusion)：** 这是使用初始化为 $1$ 的信号量保护资源的内在属性。多个线程不能同时将信号量的值减至 $0$ 以下。\n2.  **占有并等待 (Hold and Wait)：**\n    - $T_1$ 成功完成了 $P(S)$，因此它“占有”$S$。它现在因等待 $T$ 而被阻塞。\n    - $T_2$ 成功完成了 $P(T)$，因此它“占有”$T$。它现在因等待 $S$ 而被阻塞。\n    此条件已满足。\n3.  **不可抢占 (No Preemption)：** 问题明确指出，资源（信号量“单位”）不能从线程中被强制剥夺。线程必须通过 $V$ 操作自愿释放资源。此条件成立。\n4.  **循环等待 (Circular Wait)：** 这是在 $t = 4\\,\\mathrm{ms}$ 时出现的关键条件。我们可以将依赖关系可视化：\n    - 线程 $T_1$ 正在等待资源 $T$ (请求边 $T_1 \\rightarrow T$)。\n    - 资源 $T$ 由线程 $T_2$ 持有 (持有边 $T \\rightarrow T_2$)。\n    - 线程 $T_2$ 正在等待资源 $S$ (请求边 $T_2 \\rightarrow S$)。\n    - 资源 $S$ 由线程 $T_1$ 持有 (持有边 $S \\rightarrow T_1$)。\n    这形成了一个循环：$T_1 \\rightarrow T \\rightarrow T_2 \\rightarrow S \\rightarrow T_1$。\n\n在 $t = 4\\,\\mathrm{ms}$ 时，$T_2$ 调用 $P(S)$ 的操作导致 $T_2$ 阻塞，从而完成了循环等待条件。在这一刻，所有持有必要资源（$T_1$ 和 $T_2$）的线程自身也都被阻塞了。没有任何线程处于运行状态，并且由于没有安排进一步的 $V$ 操作，没有任何线程能够被解除阻塞。系统陷入了真正的、不可恢复的死锁状态。\n\n这种死锁状态出现的最早时间戳，正是在形成不可解决的循环等待所需的最后一个依赖关系建立的时刻。这发生在 $t = 4\\,\\mathrm{ms}$ 时，即 $T_2$ 在 $S$ 上阻塞的時刻。因此，$t^\\star = 4\\,\\mathrm{ms}$。", "answer": "$$\\boxed{4}$$", "id": "3681944"}]}