{"hands_on_practices": [{"introduction": "要高效地使用“加载链接/条件存储”(LL/SC)指令，我们必须首先理解其底层的硬件行为。这项练习通过模拟一个实验来揭示“保留粒度”（reservation granule）的概念，帮助你理解为什么对一个*邻近*地址的写入会导致条件存储失败，以及这与处理器的缓存架构有何关联。通过这个实践，你将能从更物理的层面把握LL/SC操作的本质。[@problem_id:3654106]", "problem": "要求您使用一个简化且科学上真实的模型来形式化“链接加载”和“条件存储”原语的语义，然后实现一个程序来模拟一个推断监控范围的实验。您必须依赖的核心科学基础是以下定义：一次“链接加载”操作会在包含某个地址的预留粒度上设置一个预留，而随后对同一地址的“条件存储”操作仅当自建立预留以来没有对该粒度中任何字节的存储发生时才会成功。预留粒度的大小是先验未知的，它正是决定监控范围的量。\n\n在本问题中，假设采用以下抽象了常见硬件行为的基本模型：\n- 内存行的大小为 $L$ 字节。\n- 行内的地址是字对齐的，字大小为 $W$ 字节，从而在每个行内产生 $n = L / W$ 个对齐的目标地址，其字节偏移量为 $t_i = i \\cdot W$，其中 $i \\in \\{0, 1, \\dots, n-1\\}$。\n- 对目标偏移量 $t_i$ 的一次“链接加载”会在包含 $t_i$ 的、大小为 $g$ 字节的预留粒度上设置一个预留。定义粒度索引函数为 $G(x; g) = \\left\\lfloor x / g \\right\\rfloor$。\n- 在“链接加载”和“条件存储”之间，一个干扰者在字节偏移量 $S = \\{s_0, s_1, \\dots, s_{m-1}\\}$ 处发起一组干扰性存储。一个干扰性存储 $s_j$ 被认为“在同一行内”，当且仅当 $0 \\le s_j  L$；否则，它指向不同的行，不影响预留。\n- 在此模型下，对 $t_i$ 的“条件存储”失败，当且仅当存在至少一个干扰性存储 $s_j \\in S$，满足 $0 \\le s_j  L$ 且 $G(s_j; g) = G(t_i; g)$。否则，它会成功。\n\n您的任务是为给定的内存行大小 $L$、字大小 $W$ 以及干扰性存储偏移量集合 $S$ 实现一个实验模拟器。该模拟器必须遍历所有对齐的目标 $t_i = i \\cdot W$（其中 $i \\in \\{0, \\dots, n-1\\}$），在假设的预留粒度大小 $g \\in \\{8, 16, 64\\}$ 字节下，确定“条件存储”是否失败，并为每个假设的 $g$ 值计算所有 $n$ 个目标中的失败总数。\n\n测试套件：\n您必须硬编码以下测试用例，每个用例由 $(L, W, S)$ 指定，其中 $L$ 的单位是字节，$W$ 的单位是字节，$S$ 是一个字节偏移量集合：\n- 测试 A：$L = 64$，$W = 8$，$S = \\{16\\}$。\n- 测试 B：$L = 64$，$W = 4$，$S = \\{80\\}$。\n- 测试 C：$L = 64$，$W = 16$，$S = \\{31\\}$。\n- 测试 D：$L = 64$，$W = 64$，$S = \\{8\\}$。\n- 测试 E：$L = 64$，$W = 4$，$S = \\{4, 20, 36, 52\\}$。\n\n对于每个测试用例，为每个 $g \\in \\{8, 16, 64\\}$ 计算在所有 $n = L/W$ 个对齐目标上的“条件存储”失败次数。一个干扰性存储仅当其位于同一行内时（即 $0 \\le s_j  L$）才会影响一个目标的结果。因此，每个测试用例的答案是三个整数，分别代表 $g = 8$、$g = 16$ 和 $g = 64$ 时的失败次数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按 A、B、C、D、E 的顺序串联所有测试的结果，并且在每个测试内部，按 $g = 8$、$g = 16$、$g = 64$ 的顺序排列。例如，输出格式为\n“[a8,a16,a64,b8,b16,b64,c8,c16,c64,d8,d16,d64,e8,e16,e64]”\n其中像 $a8$ 这样的每个符号表示指定测试和粒度大小下的整数失败计数。\n\n您的解决方案必须是一个完整的、可运行的程序，它完全按照规定实现此模拟，并且只打印上述的单行内容。不要求也不允许用户输入。所有答案都是整数；不涉及物理单位或角度。", "solution": "该问题已经过验证，被确定为一项适定（well-posed）且具有科学依据的练习，旨在对计算机科学和操作系统中的一个基本概念进行建模。所提供的“链接加载”和“条件存储”原语模型虽然经过简化，但捕捉到了许多处理器架构中基于预留的原子操作的核心机制。我们现在将进行形式化的求解。\n\n### 基于原理的模型形式化\n\n该问题围绕一个形式化模型展开，该模型描述了“链接加载”/“条件存储”（LL/SC）操作如何与干扰性内存存储相互作用。该模型的关键要素如下：\n\n1.  **内存布局**：内存行的大小为 $L$ 字节。访问是在字对齐的地址上进行的。字大小为 $W$ 字节时，行内有 $n = L/W$ 个可能的目标地址。这些目标字节偏移量由 $t_i = i \\cdot W$ 给出，其中目标索引 $i \\in \\{0, 1, \\dots, n-1\\}$。\n\n2.  **预留粒度**：对目标地址 $t_i$ 的一次 `load-linked` 操作会在一个大小为 $g$ 字节的“预留粒度”上建立预留。该模型通过索引来定义包含字节偏移量 $x$ 的粒度，该索引由函数 $G(x; g) = \\lfloor x / g \\rfloor$ 计算得出。对于非负偏移量，这对应于整数除法。\n\n3.  **干扰与失败条件**：随后对目标地址 $t_i$ 的一次 `store-conditional` 操作会受到一组发生在字节偏移量 $S = \\{s_0, s_1, \\dots, s_{m-1}\\}$ 上的对抗性存储的干扰。一个存储 $s_j$ 仅当它与目标位于同一内存行内（即 $0 \\le s_j  L$）时，才被视为潜在的干扰。对 $t_i$ 的 `store-conditional` 失败，当且仅当至少有一个这样的行内存储 $s_j$ 与目标 $t_i$ 落在同一个预留粒度内。形式上，失败条件为：\n    $$ \\exists s_j \\in S \\text{ such that } (0 \\le s_j  L) \\land (G(s_j; g) = G(t_i; g)) $$\n    否则，`store-conditional` 成功。\n\n我们的任务是针对给定的测试套件模拟此过程，为每个假设的粒度大小 $g \\in \\{8, 16, 64\\}$ 字节，计算 `store-conditional` 将会失败的目标地址总数。\n\n### 算法解决方案\n\n模拟过程直接实现了模型的规则。对于由 $(L, W, S)$ 定义的每个测试用例和每个假设的粒度大小 $g$，算法如下：\n\n1.  为当前测试用例和粒度大小初始化一个失败计数器，其值为 $0$。\n2.  计算对齐目标的数量，$n = L/W$。\n3.  遍历从 $0$ 到 $n-1$ 的每个目标索引 $i$。\n    a. 确定目标偏移量 $t_i = i \\cdot W$。\n    b. 计算此目标的粒度索引：$G_t = \\lfloor t_i / g \\rfloor$。\n    c. 设置一个标志 `failure_for_this_target` 为 false。\n    d. 遍历集合 $S$ 中的每个存储偏移量 $s_j$。\n        i. 检查存储是否在行内：$0 \\le s_j  L$。\n        ii. 如果是，则计算存储的粒度索引：$G_s = \\lfloor s_j / g \\rfloor$。\n        iii. 如果 $G_s = G_t$，则满足失败条件。将 `failure_for_this_target` 设置为 true 并中断关于存储的内层循环，因为一次干扰就足够了。\n    e. 如果 `failure_for_this_target` 为 true，则增加失败计数器。\n4.  遍历所有目标后，失败计数器的值即为给定 $(L, W, S, g)$ 的结果。\n\n### 演算示例：测试用例 C\n\n让我们将此算法应用于测试用例 C：$L = 64$，$W = 16$，$S = \\{31\\}$。\n-   目标数量 $n = L/W = 64/16 = 4$。\n-   目标偏移量 $t_i$：$\\{t_0, t_1, t_2, t_3\\} = \\{0, 16, 32, 48\\}$。\n-   干扰性存储 $s_0 = 31$。它在行内，因为 $0 \\le 31  64$。我们必须检查此存储的干扰。\n\n**情况 1：粒度大小 $g=8$**\n-   存储的粒度索引：$G(31; 8) = \\lfloor 31 / 8 \\rfloor = 3$。\n-   目标的粒度索引：\n    -   $G(t_0; 8) = G(0; 8) = 0$。\n    -   $G(t_1; 8) = G(16; 8) = 2$。\n    -   $G(t_2; 8) = G(32; 8) = 4$。\n    -   $G(t_3; 8) = G(48; 8) = 6$。\n-   存储的粒度索引（$3$）与任何目标的粒度索引（$\\{0, 2, 4, 6\\}$）都不匹配。\n-   结果：**$0$ 次失败**。\n\n**情况 2：粒度大小 $g=16$**\n-   存储的粒度索引：$G(31; 16) = \\lfloor 31 / 16 \\rfloor = 1$。\n-   目标的粒度索引：\n    -   $G(t_0; 16) = G(0; 16) = 0$。\n    -   $G(t_1; 16) = G(16; 16) = 1$。（匹配）\n    -   $G(t_2; 16) = G(32; 16) = 2$。\n    -   $G(t_3; 16) = G(48; 16) = 3$。\n-   存储的粒度索引（$1$）与目标 $t_1$ 的粒度索引匹配。\n-   结果：**$1$ 次失败**。\n\n**情况 3：粒度大小 $g=64$**\n-   存储的粒度索引：$G(31; 64) = \\lfloor 31 / 64 \\rfloor = 0$。\n-   目标的粒度索引：\n    -   $G(t_0; 64) = G(0; 64) = 0$。（匹配）\n    -   $G(t_1; 64) = G(16; 64) = 0$。（匹配）\n    -   $G(t_2; 64) = G(32; 64) = 0$。（匹配）\n    -   $G(t_3; 64) = G(48; 64) = 0$。（匹配）\n-   存储的粒度索引（$0$）与所有 $4$ 个目标的粒度索引都匹配。\n-   结果：**$4$ 次失败**。\n\n因此，测试用例 C 的计算结果为 $[0, 1, 4]$。通过将此相同过程应用于所有测试用例，我们得到完整的结果集。\n\n### 计算结果摘要\n\n-   **测试 A** ($L=64, W=8, S=\\{16\\}$): $[1, 2, 8]$\n-   **测试 B** ($L=64, W=4, S=\\{80\\}$): $[0, 0, 0]$ (存储在行外)\n-   **测试 C** ($L=64, W=16, S=\\{31\\}$): $[0, 1, 4]$\n-   **测试 D** ($L=64, W=64, S=\\{8\\}$): $[0, 1, 1]$\n-   **测试 E** ($L=64, W=4, S=\\{4, 20, 36, 52\\}$): $[8, 16, 16]$\n\n最终程序将按指定顺序串联这些结果。", "answer": "```c\n// The complete and compilable C program.\n// Headers adhere to the specified restrictions.\n#include", "id": "3654106"}, {"introduction": "在掌握了LL/SC原语的物理基础后，我们便可以将其作为构建模块来设计更高级的原子操作。这项练习要求你从理论上使用LL/SC来构造通用的“比较并交换”(Compare-And-Swap, CAS)操作，证明其正确性，并分析其在竞争环境下的性能。这项实践旨在锻炼你在并发系统中的算法合成与形式化推理能力。[@problem_id:3621226]", "problem": "考虑一个带有相干缓存的共享内存多处理器，它提供具有以下架构级语义的 Load-Link (LL) 和 Store-Conditional (SC) 指令：$LL(a)$ 读取地址 $a$ 的当前值，并在 $a$ 上建立一个预留；随后的 $SC(a,v)$ 仅当自建立预留以来没有发生对 $a$ 的冲突存储时，才将值 $v$ 写入 $a$，否则 $SC(a,v)$ 会失败而不写入。即使没有发生冲突存储，失败的 $SC$ 也可能以独立的概率 $\\sigma \\in [0,1)$ 虚假地发生。假设 $LL$ 具有获取语义，成功的 $SC$ 具有释放语义。\n\n软件接口暴露了 Compare-And-Swap (CAS)：$CAS(a,e,n)$ 原子地读取 $a$，如果观察到的值等于 $e$，则写入 $n$；否则它保持 $a$ 不变。它返回从 $a$ 读取的旧值。您需要使用 $LL/SC$ 来合成 $CAS(a,e,n)$ 的语义，并从第一性原理出发进行推理，以建立所合成的 $CAS$ 在给定架构模型下要满足可线性化和无锁性所需的最小正确性约束。您的推理必须从 $LL/SC$、$CAS$、可线性化性和无锁性的核心定义开始；您不得假设超出这些定义的任何捷径属性。\n\n然后，考虑 $k$ 个可能向同一地址 $a$ 存储的并发干扰线程。将每个干扰线程对 $a$ 的存储建模为一个独立的泊松过程，其速率为 $\\lambda_i$，其中 $i \\in \\{1,2,\\dots,k\\}$，并定义 $\\Lambda = \\sum_{i=1}^{k} \\lambda_i$。假设一个 $LL$ 及其后续的决策逻辑和匹配的 $SC$ 尝试，在 $LL$ 结束和 $SC$ 发起之间占据一个长度为 $\\tau  0$ 的确定性时间窗口，在此期间任何对 $a$ 的干扰存储都会破坏预留。假设连续的 $LL/SC$ 尝试之间由独立的思考时间隔开，使得跨尝试的干扰是独立同分布的，并且调用 $CAS$ 的线程仅将在那些 $LL$ 读取值等于 $e$ 但 $SC$ 失败（由于预留冲突或虚假失败）的循环迭代计为重试。在此模型下，推导在合成的 $CAS$ 完成其写入之前（即，在观察到 $e$ 的 $LL$ 之后、第一次成功的 $SC$ 之前，失败的 $SC$ 尝试的期望次数）的期望重试次数 $\\mathbb{E}[R]$ 的闭式解析表达式。\n\n您的最终答案必须是关于 $\\Lambda$、$\\tau$ 和 $\\sigma$ 的单个闭式解析表达式。请勿在最终答案中包含任何单位。", "solution": "所提出的问题是有效且定义明确的，包含三个部分：使用 Load-Link/Store-Conditional ($LL/SC$) 合成 Compare-And-Swap ($CAS$) 原子原语，从第一性原理证明其正确性，以及在随机模型下推导其性能。\n\n首先，我们合成 $CAS(a, e, n)$ 的语义，它原子地从内存地址 $a$ 读取，如果值等于 $e$，则写入 $n$。它返回最初读取的值。这可以使用 $LL/SC$ 在一个重试循环中实现。$LL(a)$ 指令读取值并建立一个预留。$SC(a, n)$ 指令尝试写入，仅在预留完好时才能成功。\n\n合成的算法如下：\n函数 $CAS(a, e, n)$:\n$1.$ 启动一个无限循环。\n$2.$ 在循环内部，执行 $v_{old} \\leftarrow LL(a)$。这将地址 $a$ 的当前值读入一个局部变量 $v_{old}$，并在 $a$ 上放置一个预留。$LL$ 指令具有获取语义。\n$3.$ 比较 $v_{old}$ 与期望值 $e$。\n$4.$ 如果 $v_{old} \\neq e$，则交换的前提条件未满足。操作必须失败而不修改内存。预留被隐式丢弃，函数返回 $v_{old}$。\n$5.$ 如果 $v_{old} = e$，则条件满足。通过执行 $SC(a, n)$ 尝试将新值 $n$ 原子地写入地址 $a$。\n$6.$ 检查 $SC$ 指令的结果。一个成功的 $SC$ 具有释放语义。\n$7.a.$ 如果 $SC(a, n)$ 成功，意味着自 $LL$ 以来没有其他处理器写入过 $a$（并且没有发生虚假失败）。原子交换完成。函数返回 $v_{old}$（它等于 $e$），循环终止。\n$7.b.$ 如果 $SC(a, n)$ 失败，说明 $a$ 上的预留被一个冲突的存储或一个虚假事件所破坏。此 $SC$ 不会修改内存地址 $a$。循环继续到下一次迭代，重试整个 $LL-SC$ 序列。\n\n其次，我们通过证明可线性化性和无锁性来确定此合成的正确性。\n\n可线性化性要求每个操作看起来都在其调用和响应之间的一个唯一的、可识别的“线性化点”上瞬时生效。\n对于我们合成的 $CAS$：\n- 如果 $CAS(a, e, n)$ 操作成功（即它将 $n$ 写入 $a$），线性化点是成功的 $SC(a, n)$ 指令被内存系统执行的那个瞬间。在这一刻，内存中 $a$ 的状态原子地从 $e$ 变为 $n$。操作返回 $e$，这是恰好在此点之前的值，符合 $CAS$ 的规范。\n- 如果 $CAS(a, e, n)$ 操作因为 $LL$ 读取的值 $v_{old} \\neq e$ 而失败，则不会发生写操作。线性化点是 $LL(a)$ 指令读取值 $v_{old}$ 的那个瞬间。该操作等同于一次读取，并返回它观察到的值，这与 $CAS$ 的规范一致。\n- 循环内一次失败的 $SC$ 尝试不构成一个完整的 $CAS$ 操作，因此没有线性化点。它是一个尚未完成的操作的内部步骤。\n$LL$ 上的获取语义和成功的 $SC$ 上的释放语义确保了即使在具有松散内存一致性模型的系统上，这些线性化点相对于其他线程中的内存操作也能被正确排序。\n\n无锁性保证了系统范围的进展，意味着在任何足够长的时间间隔内，至少有一个活动线程将完成其操作。\n考虑多个线程在同一地址 $a$ 上并发执行我们合成的 $CAS$。如果两个或更多线程执行 $LL(a)$ 并读取相同的值 $e$，它们都将继续尝试 $SC$。硬件会对这些并发的 $SC$ 尝试进行仲裁，保证最多只有一个能成功。其 $SC$ 成功的线程完成了它的 $CAS$ 操作，从而取得了进展。所有其他因其预留被成功的写操作破坏而导致 $SC$ 尝试失败的线程将循环并重试。因为一个线程取得了进展，所以整个系统也取得了进展。虚假的 $SC$ 失败以概率 $\\sigma  1$ 发生，它使一个线程重试，但不会无限期地停止进展。对于单个无竞争的线程，无限次连续发生虚假失败的概率为 $\\lim_{N \\to \\infty} \\sigma^N = 0$。因此，总能保证某个线程最终会成功，该算法是无锁的。\n\n第三，我们推导期望重试次数 $\\mathbb{E}[R]$。“重试”定义为循环的一次迭代，其中 $LL$ 读取了 $e$ 但随后的 $SC$ 失败了。我们被要求计算在一次成功的 $SC$ 之前的此类重试的期望次数。这是一个可以用几何分布建模的经典问题。设 $p$ 为在前面的 $LL$ 读取了 $e$ 的情况下，$SC$ 尝试成功的概率。重试次数 $R$ 是在第一次成功之前失败的次数。随机变量 $R$ 服从几何分布，其中 $P(R = j) = (1-p)^j p$，对于 $j \\in \\{0, 1, 2, \\dots\\}$。这样一个随机变量的期望是 $\\mathbb{E}[R] = \\frac{1-p}{p}$。\n\n我们的任务简化为计算 $p$。一个 $SC$ 成功当且仅当两个独立的条件被满足：\n$1.$ 在 $LL$ 和 $SC$ 之间持续时间为 $\\tau$ 的易受攻击窗口内没有发生冲突的存储。\n$2.$ 没有发生虚假失败。\n\n令 $\\mathcal{E}_{conflict}$ 为发生冲突存储的事件，$\\mathcal{E}_{spur}$ 为发生虚假失败的事件。成功的概率是 $p = P(\\mathcal{E}_{conflict}^c \\cap \\mathcal{E}_{spur}^c)$。\n问题陈述这些事件是独立的，所以 $p = P(\\mathcal{E}_{conflict}^c) P(\\mathcal{E}_{spur}^c)$。\n\n虚假失败的概率给定为 $\\sigma$。因此，没有虚假失败的概率是 $P(\\mathcal{E}_{spur}^c) = 1 - \\sigma$。\n\n来自 $k$ 个干扰线程的冲突存储被建模为 $k$ 个速率为 $\\lambda_i$ 的独立泊松过程的叠加。冲突存储的总到达过程是一个速率为 $\\Lambda = \\sum_{i=1}^{k} \\lambda_i$ 的单一泊松过程。\n如果在长度为 $\\tau$ 的时间窗口内至少发生一个存储事件，则发生冲突。此窗口中的事件数 $N(\\tau)$ 服从均值为 $\\mu = \\Lambda \\tau$ 的泊松分布。观察到 $j$ 个事件的概率是 $P(N(\\tau)=j) = \\frac{(\\Lambda \\tau)^j \\exp(-\\Lambda \\tau)}{j!}$。\n没有冲突的概率 $P(\\mathcal{E}_{conflict}^c)$ 是窗口内发生零个事件的概率：\n$$P(\\mathcal{E}_{conflict}^c) = P(N(\\tau)=0) = \\frac{(\\Lambda \\tau)^0 \\exp(-\\Lambda \\tau)}{0!} = \\exp(-\\Lambda \\tau)$$\n结合这些概率，一次 $SC$ 尝试的总成功概率是：\n$$p = P(\\mathcal{E}_{conflict}^c) P(\\mathcal{E}_{spur}^c) = \\exp(-\\Lambda \\tau) (1 - \\sigma)$$\n现在我们可以计算期望的重试次数 $\\mathbb{E}[R]$：\n$$\\mathbb{E}[R] = \\frac{1-p}{p} = \\frac{1 - (1-\\sigma)\\exp(-\\Lambda \\tau)}{(1-\\sigma)\\exp(-\\Lambda \\tau)}$$\n这个表达式可以简化为：\n$$\\mathbb{E}[R] = \\frac{1}{(1-\\sigma)\\exp(-\\Lambda \\tau)} - \\frac{(1-\\sigma)\\exp(-\\Lambda \\tau)}{(1-\\sigma)\\exp(-\\Lambda \\tau)} = \\frac{\\exp(\\Lambda \\tau)}{1-\\sigma} - 1$$\n这是期望重试次数的最终闭式解析表达式。", "answer": "$$\\boxed{\\frac{\\exp(\\Lambda \\tau)}{1-\\sigma} - 1}$$", "id": "3621226"}, {"introduction": "现在，让我们将所学知识应用于一个具体的编程任务。这个问题要求你使用LL/SC实现并验证一个并发的“取值并加法”(fetch-add)计数器，同时处理整数回绕（wraparound）和SC指令伪失败等真实世界中的复杂情况。这是一个关于编写正确、可验证的并发代码的综合性练习，它将巩固你对原子操作、并发正确性（如线性一致性）和测试验证的理解。[@problem_id:3654150]", "problem": "您的任务是通过构建和验证来确定，抽象的加载链接 (LL) 和条件存储 (SC) 原语是否能在并发执行下实现一个正确的模块化 fetch-add 操作，同时妥善处理整数回绕和伪失败，并保持线性一致性。该验证必须以一个可运行程序的形式表达，该程序纯粹基于数学和逻辑结构进行操作，无任何外部输入。程序必须实现一个基于 LL/SC 的模拟模块化 fetch-add，执行一组有界的并发操作，然后根据从第一性原理推导出的形式化标准来判断其正确性。\n\n定义和基础：\n- 共享内存位置是一个单写入者变量，可以被原子地读取和写入。将共享状态定义为集合 $\\{0,1,\\dots,M-1\\}$ 中的一个无符号整数，其中 $M = 2^w$，$w$ 为给定的位宽。\n- 加载链接 (LL) 读取共享内存位置的当前值 $x$ 并建立链接，使得后续的条件存储操作依赖于期间没有发生干预性写入。\n- 条件存储 (SC) 尝试将新值 $y$ 写入同一位置，并且仅在自配对的加载链接操作以来没有发生干预性写入的情况下才会成功。即使没有干预性写入，条件存储也可能发生伪失败。\n- 在整数模 $M$ 上，加数为 $a$ 的模块化 fetch-add 操作将状态 $x$ 映射到新状态 $(x + a) \\bmod M$，并向调用者返回旧状态 $x$。对于从初始状态 $x_0$ 开始的 $N$ 个此类操作，其顺序规范产生的返回值序列为 $r_i = (x_0 + i \\cdot a) \\bmod M$（其中 $i \\in \\{0,1,\\dots,N-1\\}$），最终状态为 $x_N = (x_0 + N \\cdot a) \\bmod M$。\n- 线性一致性要求每个操作看起来像是在其调用和响应之间的某个单一点上生效，并且总体效果必须等同于上述的顺序规范。\n- 回绕行为由模 $M = 2^w$ 的算术精确建模。整数溢出不是一个错误；它因取模操作而表现为回绕。当 $\\gcd(a, M)  1$ 时会出现短周期，周期长度为 $L = \\frac{M}{\\gcd(a, M)}$；经过 $L$ 次操作后，返回值序列会重复。\n\n您的程序必须：\n- 实现一个基于 LL/SC 的模拟模块化 fetch-add 函数，该函数：\n  - 读取当前值 $x$。\n  - 计算 $y = (x + a) \\bmod M$。\n  - 尝试对 $y$ 进行条件存储，并循环直到成功。该函数可以以指定的周期性注入确定性的条件存储伪失败，以模拟条件存储即使在没有干扰的情况下也可能失败。\n  - 在条件存储成功时返回观察到的旧值 $x$。\n- 执行一组并发线程，每个线程从初始状态 $x_0$ 开始，对共享计数器（模 $M$）执行指定数量的、使用相同加数 $a$ 的 fetch-add 操作。\n- 收集所有返回的旧值，并验证以下关于线性一致性和回绕的正确性标准：\n  1. 最终值等于 $x_N = (x_0 + N \\cdot a) \\bmod M$，其中 $N$ 是所有线程执行的总操作数。\n  2. 返回的旧值的多重集等于多重集 $\\{(x_0 + i \\cdot a) \\bmod M \\mid i = 0,1,\\dots,N-1\\}$，其中考虑了回绕以及当 $\\gcd(a, M)  1$ 时可能出现的周期重复。\n\n测试套件：\n提供以下测试用例，每个用例由元组 $(w, x_0, a, T, K, s)$ 定义，其中 $w$ 是位宽，$x_0$ 是初始状态，$a$ 是加数，$T$ 是线程数，$K$ 是每线程操作数，$s$ 是伪失败周期性（$s = 0$ 表示禁用）。令 $M = 2^w$ 且 $N = T \\cdot K$。\n- 测试用例 1：$(w, x_0, a, T, K, s) = (8, 5, 1, 4, 10, 0)$。这是一个一般情况；$N = 40$；由于 $5 + 40  256$，不发生回绕。\n- 测试用例 2：$(w, x_0, a, T, K, s) = (8, 250, 1, 2, 10, 0)$。此用例检验回绕情况；$N = 20$；最终值为 $(250 + 20) \\bmod 256 = 14$。\n- 测试用例 3：$(w, x_0, a, T, K, s) = (8, 3, 2, 3, 60, 0)$。此用例强调周期重复，因为 $\\gcd(2, 256) = 2$；周期长度为 $L = \\frac{256}{2} = 128$，因此当 $N = 180  128$ 时，返回值多重集中会出现重复值。\n- 测试用例 4：$(w, x_0, a, T, K, s) = (8, 0, 1, 3, 50, 2)$。此用例每 2 次尝试注入一次确定性的条件存储伪失败，同时仍要求取得进展；$N = 150$；最终值为 $(0 + 150) \\bmod 256 = 150$。\n\n输出规范：\n- 对于每个测试用例 $i \\in \\{1,2,3,4\\}$，程序必须计算一个布尔指示符 $b_i$。如果两个正确性标准都成立，则 $b_i$ 等于 $1$，否则等于 $0$。\n- 您的程序应产生单行输出，其中包含一个以逗号分隔并用方括号括起来的结果列表，格式必须为 $[b_1,b_2,b_3,b_4]$。", "solution": "我们从加载链接和条件存储的基本定义开始。加载链接 (LL) 读取当前值并建立一个可被任何干预性写入所无效的链接。条件存储 (SC) 尝试写入一个新值，并且仅在该链接保持有效时才会成功。重要的是，即使没有干预性写入，条件存储也可能发生伪失败。加数为 $a$、模数为 $M = 2^w$ 的原子模块化 fetch-add 操作被规定为：读取状态 $x$ 的操作会产生新状态 $y = (x + a) \\bmod M$ 并返回旧状态 $x$。\n\n从状态 $x_0$ 开始，跨越 $N$ 次操作的顺序规范产生：\n- 返回值序列：$r_i = (x_0 + i \\cdot a) \\bmod M$，其中 $i \\in \\{0,1,\\dots,N-1\\}$。\n- 最终状态：$x_N = (x_0 + N \\cdot a) \\bmod M$。\n\n线性一致性要求每个操作看起来像是在其调用和响应之间的某个瞬间发生，并且已完成操作的集合必须等同于顺序规范。在 LL/SC 中，每个成功的条件存储是线性化点，因为只有在没有干预性写入使链接失效的情况下，写入才会原子地发生。伪失败不会损害线性一致性，因为没有发生写入；操作只是简单地重试直到成功。\n\n算法实现：\n- 我们使用一个循环来模拟 LL/SC，该循环由一次原子加载、一次新值（模 $M$）的计算和一次原子条件存储组成，该存储仅在先前读取的值保持为当前值时才成功。在每次尝试中，我们可以选择性地注入一个确定性的伪失败周期 $s$：如果全局尝试计数器满足 $\\text{attempt} \\bmod s = 0$（且 $s > 0$），我们就使条件存储尝试失败（不进行写入）并重试。这模拟了伪失败，同时在 $s$ 为有限值时确保了进展。\n- 当条件存储成功时，我们返回旧值。\n\n正确性标准推导：\n1. 最终状态：因为每个成功的操作都会写入 $y = (x + a) \\bmod M$，并且条件存储构成了线性化点，又因为算术是模 $M$ 的，所以在 $N$ 次成功操作之后，最终状态必须是 $x_N = (x_0 + N \\cdot a) \\bmod M$。伪失败会增加尝试的次数，但不会改变被执行的成功操作的数量 $N$，因此它们不会影响最终状态。\n2. 返回值多重集：每个成功的操作都会返回被 LL 读取和链接、并且直到 SC 操作前都保持不变的旧值 $x$。由于操作以某种顺序线性化，因此存在一个 $\\{0,1,\\dots,N-1\\}$ 的排列 $\\pi$，使得返回的多重集等于 $\\{(x_0 + i \\cdot a) \\bmod M \\mid i = 0,1,\\dots,N-1\\}$。并发性改变了顺序（即排列），但没有改变多重集本身。当 $\\gcd(a, M) > 1$ 时，序列 $r_i$ 以周期长度 $L = \\frac{M}{\\gcd(a, M)}$ 重复。因此，只要 $N > L$，多重集中就预期会出现重复值。我们的验证将观察到的多重集计数与顺序规范的预测计数进行比较；两者相等即可确立返回值的线性一致性。\n\n实现细节：\n- 我们为所有测试用例选择 $w = 8$，因此 $M = 2^w = 256$。通过与 $M - 1$ 进行位掩码操作可以在每次更新中实现回绕，并保证整数溢出按要求表现为模约减。\n- 对于测试用例 1，参数为 $(w, x_0, a, T, K, s) = (8, 5, 1, 4, 10, 0)$，我们有 $N = 40$ 且 $x_N = (5 + 40) \\bmod 256 = 45$。没有发生回绕，多重集包含连续值 $5,6,\\dots,44$。\n- 对于测试用例 2，参数为 $(8, 250, 1, 2, 10, 0)$，我们有 $N = 20$ 且 $x_N = (250 + 20) \\bmod 256 = 14$。发生了回绕；多重集包含值 $250,251,\\dots,255,0,1,\\dots,13$。\n- 对于测试用例 3，参数为 $(8, 3, 2, 3, 60, 0)$，我们有 $N = 180$ 且 $x_N = (3 + 180 \\cdot 2) \\bmod 256 = 107$。由于 $\\gcd(2, 256) = 2$，周期长度为 $L = 128$。因此，多重集在 128 项后开始重复，最后的 52 项与前 52 项重复。\n- 对于测试用例 4，参数为 $(8, 0, 1, 3, 50, 2)$，我们有 $N = 150$ 且 $x_N = 150$。每 2 次尝试发生一次伪失败不会改变多重集或最终状态；这只会增加尝试的次数。\n\n验证方法：\n- 所有线程完成后，我们加载最终状态并计算预期的 $x_N$。我们比较两者是否相等。\n- 我们在 $\\{0,1,\\dots,M-1\\}$ 上统计返回值的观察计数。我们通过枚举 $i = 0$ 到 $N - 1$ 的 $r_i = (x_0 + i \\cdot a) \\bmod M$ 来形成预测计数。这些直方图的相等性确立了多重集属性。\n- 如果两项检查都通过，我们为该测试用例输出 $1$；否则，输出 $0$。\n\n最终输出是单行 $[b_1,b_2,b_3,b_4]$，其中每个 $b_i$ 是如上定义的测试用例 $i$ 的布尔结果。该程序具体地演示了 LL/SC 能够正确实现带回绕的模块化 fetch-add，通过模运算处理整数溢出，并保持线性一致性，包括由 $\\gcd(a, M)$ 决定的周期长度以及确定性伪条件存储失败所带来的细微差别。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include", "id": "3654150"}]}