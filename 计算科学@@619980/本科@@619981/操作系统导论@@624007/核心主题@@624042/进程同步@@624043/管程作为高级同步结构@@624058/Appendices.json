{"hands_on_practices": [{"introduction": "本练习侧重于管程设计中的一个关键区别：Hoare 语义与 Mesa 语义。通过分析一个有界缓冲区的实现，你将发现为何信号（signal）机制决定了等待条件必须如何检查。这项实践对于编写健壮的并发代码以及避免可能破坏共享数据的细微竞争条件至关重要。[@problem_id:3659620]", "problem": "一个管程使用一个用于生产者（$\\texttt{notFull}$）的条件变量和一个用于消费者（$\\texttt{notEmpty}$）的条件变量实现了一个容量为 $N$ 的有界缓冲区。设管程状态由整型变量 $count$、$head$ 和 $tail$ 给出，其不变量为 $0 \\leq count \\leq N$。在 Hoare 风格的语义（发信号并紧急等待）下，执行 $\\texttt{signal}(c)$ 的线程会立即将管程让给某个在 $c$ 上等待的线程，并且该等待线程接下来在管程内运行；否则，如果没有线程在 $c$ 上等待，则 $\\texttt{signal}$ 操作没有效果。该管程在其过程中使用以下模式：\n- 对于 $\\texttt{put}(x)$：如果 $count = N$ 则 $\\texttt{wait}(\\texttt{notFull})$；在位置 $tail$ 处插入 $x$，更新 $tail \\leftarrow (tail + 1) \\bmod N$，递增 $count \\leftarrow count + 1$，并执行 $\\texttt{signal}(\\texttt{notEmpty})$。\n- 对于 $\\texttt{get}()$：如果 $count = 0$ 则 $\\texttt{wait}(\\texttt{notEmpty})$；移除位置 $head$ 处的项目，更新 $head \\leftarrow (head + 1) \\bmod N$，递减 $count \\leftarrow count - 1$，并执行 $\\texttt{signal}(\\texttt{notFull})$。\n\n要求您将此管程移植到 Mesa 风格的语义（发信号并继续），其中 $\\texttt{signal}(c)$ 仅使一个等待的线程有资格在稍后运行；发信号的线程继续在管程中执行直到退出，而被唤醒的线程必须重新获取管程才能继续执行。同时，请考虑使用一次性的 $\\texttt{if}$ 检查而不是重复检查的循环来守卫 $\\texttt{wait}$ 的常见陷阱。\n\n下列哪些陈述是正确的？\n\nA. 当转换为 Mesa 风格的语义时，每个形式为“if $\\,$predicate$\\,$ then $\\texttt{wait}(c)$”的一次性守卫都必须被替换为重复检查的循环“while $\\,$predicate$\\,$ do $\\texttt{wait}(c)$”，因为一个被 $\\texttt{signal}(c)$ 唤醒的线程在它运行时可能会发现该谓词再次变为真。\n\nB. 当转换为 Mesa 风格的语义时，只需将每个 $\\texttt{signal}(c)$ 移动到守卫体内并紧接在 $\\texttt{wait}(c)$ 之前（即执行 $\\texttt{signal}(c)$，然后执行 $\\texttt{wait}(c)$），而无需将 $\\texttt{if}$ 更改为 $\\texttt{while}$。\n\nC. 在 Hoare 风格的语义下，对于此管程，使用一次性的 $\\texttt{if}$ 来守卫 $\\texttt{wait}$ 是健全的，因为 $\\texttt{signal}$ 执行了一次优先交接：它在任何其他线程可以修改共享状态之前，将管程内的控制权转移给一个等待的线程。\n\nD. 在 Mesa 风格的语义下，将每个 $\\texttt{signal}(c)$ 替换为 $\\texttt{broadcast}(c)$，同时保留一次性的 $\\texttt{if}$ 守卫，足以在无需额外更改的情况下保证安全性（无上溢或下溢）。\n\nE. 在使用一次性 $\\texttt{if}$ 守卫的 Mesa 风格语义下，以下交错执行可能因导致上溢而违反不变量 $0 \\leq count \\leq N$：初始时 $count = N$，一个生产者 $P_1$ 调用 $\\texttt{put}$，看到 $count = N$，并执行 $\\texttt{wait}(\\texttt{notFull})$；一个消费者 $C$ 调用 $\\texttt{get}$，移除一个项目使得 $count \\leftarrow N - 1$，并执行 $\\texttt{signal}(\\texttt{notFull})$；在 $P_1$ 重新获取管程之前，另一个生产者 $P_2$ 进入，插入一个项目使得 $count \\leftarrow N$，然后退出；接着 $P_1$ 运行，（由于是一次性的 $\\texttt{if}$）不重新检查条件，插入另一个项目，使得 $count \\leftarrow N + 1$。\n\nF. 在使用一次性 $\\texttt{if}$ 守卫的 Mesa 风格语义下，以下交错执行可能因导致下溢而违反不变量 $0 \\leq count \\leq N$：初始时 $count = 0$，一个消费者 $C_1$ 调用 $\\texttt{get}$，看到 $count = 0$，并执行 $\\texttt{wait}(\\texttt{notEmpty})$；一个生产者 $P$ 调用 $\\texttt{put}$，插入一个项目使得 $count \\leftarrow 1$，并执行 $\\texttt{signal}(\\texttt{notEmpty})$；在 $C_1$ 重新获取管程之前，另一个消费者 $C_2$ 进入，移除该项目使得 $count \\leftarrow 0$，然后退出；接着 $C_1$ 运行，（由于是一次性的 $\\texttt{if}$）不重新检查条件，从一个空缓冲区中移除项目，使得 $count \\leftarrow -1$。\n\n选择所有适用的选项。", "solution": "该问题陈述已经过验证，是并发编程和操作系统研究中一个提法明确的标准问题，特别涉及管程同步。对 Hoare 和 Mesa 语义的描述准确且充分，足以进行严格的分析。\n\n问题的核心在于条件变量上 Hoare 风格和 Mesa 风格信号发送之间的语义差异。\n- **Hoare 语义（发信号并紧急等待）：** 当线程 $T_1$ 执行 $\\texttt{signal}(c)$ 时，它会立即将管程锁的所有权传递给正在条件变量 $c$ 上等待的线程 $T_2$。$T_2$ 立即恢复执行。这保证了由 $T_1$ 建立的、$T_2$ 正在等待的条件仍然成立。没有其他线程可以介入。\n- **Mesa 语义（发信号并继续）：** 当线程 $T_1$ 执行 $\\texttt{signal}(c)$ 时，它保留管程锁的所有权并继续执行。被发信号的线程 $T_2$ 仅仅是从条件变量的等待队列移动到管程的入口队列，使其*有资格*运行。它必须重新竞争管程锁。到 $T_2$ 最终获取锁并恢复执行时，管程的状态可能已经被其他线程改变，包括 $T_1$ 自身或在 $T_1$ 退出后进入管程的其他线程。\n\n基于这些原则，我们将评估每个陈述。\n\n**A. 当转换为 Mesa 风格的语义时，每个形式为“if $\\,$predicate$\\,$ then $\\texttt{wait}(c)$”的一次性守卫都必须被替换为重复检查的循环“while $\\,$predicate$\\,$ do $\\texttt{wait}(c)$”，因为一个被 $\\texttt{signal}(c)$ 唤醒的线程在它运行时可能会发现该谓词再次变为真。**\n\n这条陈述描述了正确使用 Mesa 风格管程的基本要求。在 Mesa 语义中，一个 `signal` 只是一个提示，表明条件*可能*现在为假。在信号发出和等待线程重新获得管程锁之间，状态可能会改变。例如，一个消费者可能在缓冲区有一个空槽时发出 $\\texttt{notFull}$ 信号。在被唤醒的生产者运行之前，另一个生产者可能会获取锁并填满那个槽。当第一个生产者最终运行时，缓冲区又满了。如果它使用 `if` 守卫，它将不会重新检查并会继续向一个已满的缓冲区写入，导致上溢。`while` 循环强制线程在唤醒后重新评估谓词，确保它只在条件实际满足时才继续执行。这是使用 Mesa 风格条件变量进行健壮编程的规范做法。\n\n**结论：正确。**\n\n**B. 当转换为 Mesa 风格的语义时，只需将每个 $\\texttt{signal}(c)$ 移动到守卫体内并紧接在 $\\texttt{wait}(c)$ 之前（即执行 $\\texttt{signal}(c)$，然后执行 $\\texttt{wait}(c)$），而无需将 $\\texttt{if}$ 更改为 $\\texttt{while}$。**\n\n这个提议的更改从根本上误解了生产者-消费者同步的逻辑。让我们用这个更改来分析 `put` 过程。原始逻辑是 `if $count = N$ then $\\texttt{wait}(\\texttt{notFull})$`。提议的更改将其变为 `if $count = N$ then { $\\texttt{signal}(\\texttt{notEmpty})$; $\\texttt{wait}(\\texttt{notFull})$; }`。这是不正确的。一个生产者发现缓冲区已满（$count = N$）。它还没有添加项目，所以没有理由通过 $\\texttt{signal}(\\texttt{notEmpty})$ 来通知消费者。在这一点上发信号在逻辑上是不合理的。$\\texttt{signal}(\\texttt{notEmpty})$ 的目的是通知消费者一个项目*已被添加*。$\\texttt{wait}(\\texttt{notFull})$ 的目的是让生产者阻塞直到空间*变得可用*。颠倒这个逻辑，在等待相反条件之前发信号，会破坏该协议。\n\n**结论：不正确。**\n\n**C. 在 Hoare 风格的语义下，对于此管程，使用一次性的 $\\texttt{if}$ 来守卫 $\\texttt{wait}$ 是健全的，因为 $\\texttt{signal}$ 执行了一次优先交接：它在任何其他线程可以修改共享状态之前，将管程内的控制权转移给一个等待的线程。**\n\n这是对为什么在 Hoare 风格的管程中 `if` 守卫是足够的精确解释。当一个消费者移除一个项目，使得 $count \\leftarrow N-1$，然后执行 $\\texttt{signal}(\\texttt{notFull})$ 时，一个在 $\\texttt{notFull}$ 上等待的生产者线程会立即被唤醒并获得对管程的独占访问权。在生产者恢复的瞬间，它所等待的条件（即 $count  N$）保证为真，因为没有其他线程能够介入。“优先交接”是对这种控制权立即转移的准确描述，它为被唤醒线程的利益维护了信号发送者建立的不变量。因此，重新检查条件是多余的。\n\n**结论：正确。**\n\n**D. 在 Mesa 风格的语义下，将每个 $\\texttt{signal}(c)$ 替换为 $\\texttt{broadcast}(c)$，同时保留一次性的 $\\texttt{if}$ 守卫，足以在无需额外更改的情况下保证安全性（无上溢或下溢）。**\n\n使用 $\\texttt{broadcast}(c)$ 会唤醒在条件 $c$ 上等待的*所有*线程，而不仅仅是一个。如果我们保留 `if` 守卫，这个改变会加剧问题。例如，假设多个生产者在 $\\texttt{notFull}$ 上等待。一个消费者移除了一个项目并执行了 $\\texttt{broadcast}(\\texttt{notFull})$。所有等待的生产者都被唤醒并放入管程的入口队列。一个生产者 $P_1$ 将首先获得锁，填满唯一的空槽，然后退出。然后，另一个被唤醒的生产者 $P_2$ 将获得锁。因为它被一个 `if` 守卫，所以 $P_2$ 不会重新检查缓冲区状态，并将继续执行，好像空间可用一样，从而导致上溢。使用 $\\texttt{broadcast}$ 而没有重复检查的 `while` 循环会使竞争条件更加严重，因为多个线程会错误地假设条件是有利的。\n\n**结论：不正确。**\n\n**E. 在使用一次性 $\\texttt{if}$ 守卫的 Mesa 风格语义下，以下交错执行可能因导致上溢而违反不变量 $0 \\leq count \\leq N$：初始时 $count = N$，一个生产者 $P_1$ 调用 $\\texttt{put}$，看到 $count = N$，并执行 $\\texttt{wait}(\\texttt{notFull})$；一个消费者 $C$ 调用 $\\texttt{get}$，移除一个项目使得 $count \\leftarrow N - 1$，并执行 $\\texttt{signal}(\\texttt{notFull})$；在 $P_1$ 重新获取管程之前，另一个生产者 $P_2$ 进入，插入一个项目使得 $count \\leftarrow N$，然后退出；接着 $P_1$ 运行，（由于是一次性的 $\\texttt{if}$）不重新检查条件，插入另一个项目，使得 $count \\leftarrow N + 1$。**\n\n这个场景是 Mesa 风格管程中“被窃取的唤醒”或“闯入”问题的经典演示。\n1.  状态：$count = N$。\n2.  $P_1$ 调用 `put`，执行 $\\texttt{wait}(\\texttt{notFull})$。\n3.  $C$ 调用 `get`，将 $count$ 减为 $N-1$，调用 $\\texttt{signal}(\\texttt{notFull})$。$P_1$ 现在准备运行，但没有锁。$C$ 退出。\n4.  管程锁被释放。一个新的生产者 $P_2$ 在被唤醒的 $P_1$ 之前获得了锁。这在 Mesa 语义中是允许的。\n5.  $P_2$ 发现 $count = N-1  N$，所以它插入一个项目，将 $count$ 增为 $N$，然后退出。\n6.  $P_1$ 现在获得了锁。它在其 `wait` 调用*之后*恢复执行。`if` 条件不会被重新检查。\n7.  $P_1$ 继续将其项目插入到现已满的缓冲区中，将 $count$ 增为 $N+1$。\n这一事件序列在 Mesa 语义下是有效的，并直接导致违反管程的不变量（$count \\leq N$），造成缓冲区上溢。\n\n**结论：正确。**\n\n**F. 在使用一次性 $\\texttt{if}$ 守卫的 Mesa 风格语义下，以下交错执行可能因导致下溢而违反不变量 $0 \\leq count \\leq N$：初始时 $count = 0$，一个消费者 $C_1$ 调用 $\\texttt{get}$，看到 $count = 0$，并执行 $\\texttt{wait}(\\texttt{notEmpty})$；一个生产者 $P$ 调用 $\\texttt{put}$，插入一个项目使得 $count \\leftarrow 1$，并执行 $\\texttt{signal}(\\texttt{notEmpty})$；在 $C_1$ 重新获取管程之前，另一个消费者 $C_2$ 进入，移除该项目使得 $count \\leftarrow 0$，然后退出；接着 $C_1$ 运行，（由于是一次性的 $\\texttt{if}$）不重新检查条件，从一个空缓冲区中移除项目，使得 $count \\leftarrow -1$。**\n\n这是选项 E 中场景的对称对应部分，演示了缓冲区下溢的可能性。\n1.  状态：$count = 0$。\n2.  $C_1$ 调用 `get`，执行 $\\texttt{wait}(\\texttt{notEmpty})$。\n3.  $P$ 调用 `put`，将 $count$ 增为 $1$，调用 $\\texttt{signal}(\\texttt{notEmpty})$。$C_1$ 现在准备就绪，但没有锁。$P$ 退出。\n4.  管程锁被释放。一个新的消费者 $C_2$ 在被唤醒的 $C_1$ 之前获得了锁。\n5.  $C_2$ 发现 $count = 1 > 0$，所以它移除一个项目，将 $count$ 减为 $0$，然后退出。\n6.  $C_1$ 现在获得了锁。它在其 `wait` 调用*之后*恢复执行，由于 `if` 守卫而没有重新检查条件。\n7.  $C_1$ 继续从现已空的缓冲区中移除一个项目，将 $count$ 减为 $-1$。\n这个序列在 Mesa 语义下是有效的，并因导致缓冲区下溢而违反了不变量（$count \\geq 0$）。\n\n**结论：正确。**", "answer": "$$\\boxed{ACEF}$$", "id": "3659620"}, {"introduction": "在基本的管程原理之上，本问题探讨了一个更复杂且危险的场景：对管程的递归进入。你将研究可重入锁与条件变量的 `wait` 操作之间的交互如何可能导致自我死锁。理解这一边界情况对于在允许或要求递归调用的系统中设计安全的管程至关重要。[@problem_id:3659623]", "problem": "操作系统（OS）中的管程（monitor）是一种高级同步构造，它强制对进入管程过程的互斥访问，并提供用于等待和信号通知的条件变量。考虑一个管程 $M$，它使用一个可重入（递归）锁 $L$ 和一个具有 Mesa 风格语义的条件变量 $c$。假定其基本语义为：进入管程时互斥，条件变量等待操作会原子性地释放管程锁并挂起调用者，条件变量信号操作会唤醒一个等待的线程，并且被唤醒的线程在从等待返回前会重新获取锁。在一个可重入锁中，每次成功进入都会使递归计数 $r$ 增加，每次退出都会使 $r$ 减少；只有当 $r = 0$ 时，锁才被释放。\n\n假设 $M$ 实现了一个有界缓冲区，包含过程 $put$ 和 $get$。一个包装过程 $wrapGet$ 在管程内部调用 $get$。预期的交互如下：\n\n- $wrapGet$：进入 $M$，执行一些与缓冲区无关的操作，调用 $get$，退出 $M$。\n- $get$：进入 $M$，如果缓冲区为空，则调用 $wait(c)$，否则移除并返回一个项目。\n\n假设线程 $T$ 执行以下序列：$T$ 调用 $wrapGet$，进入 $M$ 并将 $r$ 增加到 $1$，然后 $wrapGet$ 调用 $get$，$get$ 递归地重入 $M$ 并将 $r$ 增加到 $2$。在 $get$ 内部，缓冲区为空，因此调用了 $wait(c)$。\n\n下列哪个陈述正确地指出了一个因管程递归和条件变量组合而导致线程 $T$ 自我死锁的情况？\n\nA. 如果 $wait(c)$ 仅通过将 $r$ 从 $2$ 减到 $1$ 来释放一级递归锁，那么 $T$ 在仍然持有 $M$（$r  0$）的情况下保持阻塞，从而阻止任何其他线程进入 $M$ 执行匹配的 $put$ 和 $signal(c)$；这导致了自我死锁。\n\nB. 如果 $wait(c)$ 通过原子性地将 $r$ 设置为 $0$ 来完全释放递归锁，并在返回前重新获取 $L$，那么在 Mesa 语义下，该包装调用是安全的，并且在这种情况下不会导致自我死锁。\n\nC. 在 Hoare 风格的管程语义下，执行 $signal(c)$ 后的立即控制权转移确保了即使 $wait(c)$ 只释放一级锁（剩下 $r = 1$），包装调用也是安全的，不会发生自我死锁。\n\nD. 从 $M$ 外部对 $c$ 进行广播可以避免死锁，因为在任何正确的管程设计中，对条件变量进行信号通知和广播都不需要持有管程锁 $L$。", "solution": "该问题是有效的，探讨了可重入管程中一个经典的死锁场景。其核心在于 `wait` 操作如何与可重入锁的递归计数器交互。\n\n一个可重入（或递归）锁允许同一个线程多次获取该锁而不会死锁。它内部维护一个持有者线程标识和一个递归计数器 $r$。当线程首次获取锁时，$r$ 设为 $1$。如果该线程再次获取锁，$r$ 会递增。每次释放锁时，$r$ 会递减。只有当 $r$ 减到 $0$ 时，该锁才真正被释放，从而允许其他线程获取它。\n\n条件变量的 `wait` 操作必须原子地释放管程锁并阻塞当前线程，以便其他线程可以进入管程，改变共享状态，并最终发出信号。\n\n我们分析问题中描述的场景：\n1.  线程 $T$ 调用 `wrapGet`，获取锁 $L$。状态：$T$ 持有 $L$，$r = 1$。\n2.  `wrapGet` 调用 `get`。由于是同一线程 $T$，$T$ 成功重入管程。状态：$T$ 持有 $L$，$r = 2$。\n3.  在 `get` 内部，缓冲区为空，线程 $T$ 调用 `wait(c)`。\n4.  此时 `wait(c)` 的行为至关重要。它必须释放锁 $L$ 以避免死锁。\n\n现在，我们评估各个选项：\n\n**A. 如果 $wait(c)$ 仅通过将 $r$ 从 $2$ 减到 $1$ 来释放一级递归锁，那么 $T$ 在仍然持有 $M$（$r  0$）的情况下保持阻塞，从而阻止任何其他线程进入 $M$ 执行匹配的 $put$ 和 $signal(c)$；这导致了自我死锁。**\n这是对死锁原因的正确描述。如果 `wait(c)` 的实现有缺陷，只释放了一层递归（即简单地执行了一次“释放”操作，将 $r$ 从 $2$ 减到 $1$），那么锁 $L$ 并未被完全释放，因为 $r$ 仍然大于 $0$。线程 $T$ 随后在条件变量 $c$ 上进入睡眠状态，但它仍然持有管程锁 $L$。因此，任何其他想要进入管程（例如，为了调用 `put` 并最终 `signal(c)`）的线程都会被阻塞。由于没有线程可以进入来唤醒 $T$，$T$ 将永远阻塞。这正是自我死锁。\n\n**结论：正确。**\n\n**B. 如果 $wait(c)$ 通过原子性地将 $r$ 设置为 $0$ 来完全释放递归锁，并在返回前重新获取 $L$，那么在 Mesa 语义下，该包装调用是安全的，并且在这种情况下不会导致自我死锁。**\n这描述了可重入管程中 `wait` 操作的*正确*实现方式。为了允许其他线程进入，`wait` 必须保存当前的递归计数（本例中为 $2$），然后原子地将计数器 $r$ 设置为 $0$ 以完全释放锁。当线程被唤醒并准备从 `wait` 返回时，它必须重新竞争锁，并最终将递归计数恢复到其进入 `wait` 之前的值（即 $2$）。这种实现可以防止死锁。然而，问题要求找出导致死锁的情况，因此这个描述安全情况的选项不是答案。\n\n**结论：不正确（因为它描述了一个安全的场景，而非题目所问的死锁场景）。**\n\n**C. 在 Hoare 风格的管程语义下，执行 $signal(c)$ 后的立即控制权转移确保了即使 $wait(c)$ 只释放一级锁（剩下 $r = 1$），包装调用也是安全的，不会发生自我死锁。**\n这是不正确的。Hoare 语义改变的是 `signal` 的调度行为，而不是 `wait` 的锁释放要求。无论采用何种语义，如果 `wait` 没有完全释放锁，就没有线程能够进入管程来执行 `signal` 操作。Hoare 语义的“立即控制权转移”特性甚至无法发挥作用，因为它依赖于一个线程能够成功进入管程并发出信号。\n\n**结论：不正确。**\n\n**D. 从 $M$ 外部对 $c$ 进行广播可以避免死锁，因为在任何正确的管程设计中，对条件变量进行信号通知和广播都不需要持有管程锁 $L$。**\n这个前提是错误的。管程的一个基本原则是，对条件变量的操作（`wait`、`signal`、`broadcast`）必须在持有管程锁的情况下进行。这是为了防止在检查条件和进入等待状态之间发生竞争条件。在管程外对条件变量进行操作会破坏其安全保证。因此，这既不是正确的管程设计，也不能解决问题中描述的死锁。\n\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3659623"}, {"introduction": "最后的这项实践将挑战你将管程概念应用于一个现实的大规模问题：为多个租户管理资源配额。你将设计一个确定性模拟器，模拟一个强制执行个体和全局限制的管程，同时处理突发请求和复杂的依赖关系。这个练习展示了管程如何作为强大的构建模块，用于创建复杂且正确的并发资源管理器。[@problem_id:3659622]", "problem": "您需要在一个确定性程序中，实现一个离散时间模拟。该模拟器模拟一个管程（monitor），该管程在存在突发到达和相互依赖约束的情况下，强制执行每个租户的加密密钥使用配额，并且无死锁。管程是一种高级同步构造，提供互斥和条件变量。在此场景中，管程保护表示资源计数的共享状态，并且仅当关于共享状态的谓词为真时才接纳请求者。基本假设是标准的管程语义：互斥、采用Mesa风格信令的条件变量，以及使用不变量来确保安全性。程序必须从基本原理出发对以下内容进行建模。\n\n共有 $N$ 个租户。每个租户 $i$ 有一个令牌桶，其容量为 $C_i$，整数补充速率为每时间单位 $R_i$ 个令牌。还有一个全局令牌桶，其容量为 $G_C$，整数补充速率为 $G_R$。时间是离散的，以整数单位 $t \\in \\{0,1,2,\\dots\\}$ 计量。所有桶在时间 $t=0$ 时都处于满容量状态。对于任何容量为 $K$、补充速率为 $r$ 的桶 $B$，如果其在时间 $t$ 的内容为 $b(t)$，那么在时间 $t+1$ 其内容变为 $b(t+1)=\\min(K, b(t)+r)$，此更新在每个时间单位独立应用。这是一个离散时间令牌桶模型。\n\n每个请求是一个三元组 $(a_j,\\tau_j,k_j)$，其中 $a_j$ 是整数到达时间，$\\tau_j \\in \\{0,\\dots,N-1\\}$ 是租户标识符，$k_j$ 是请求的密钥的整数数量。一个请求只有在对应的租户桶和全局桶都至少有 $k_j$ 个令牌时才能被接纳。接纳操作会在某个时间点 $t \\ge a_j$ 原子地从租户桶 $\\tau_j$ 和全局桶中消耗 $k_j$ 个令牌。每个被接纳的请求都有一个关联的完成时间 $f_j$，即它被接纳的时间 $t$。\n\n需强制执行的管程语义：\n- 安全性不变量：在任何时间 $t$，任何桶的内容都不得超过其容量，也绝不能为负。一个请求被接纳当且仅当谓词 $b_{\\tau_j}(t)\\ge k_j \\land b_{\\mathrm{global}}(t)\\ge k_j$ 成立，其中 $b_{\\tau_j}(t)$ 是租户 $\\tau_j$ 的桶内容，$b_{\\mathrm{global}}(t)$ 是全局桶的内容。\n- 无持有并等待：当一个请求在等待时（即在被接纳之前），它不持有任何令牌，从而防止循环等待并确保无死锁。\n- 调度策略：在每个整数时间 $t$，在所有已到达但尚未被接纳的请求中，选择其谓词为真的最早到达的请求（最老就绪优先）。如果多个此类请求具有相同的到达时间，则按其输入顺序打破平局。如果没有已到达的请求当前可被接纳，则将时间推进到 $t+1$，补充桶，然后重试。此策略模拟了一个带有每个租户的条件变量和全局就绪谓词的管程：只有其谓词成立的请求才被唤醒，在避免队头阻塞的同时保持活性。\n\n您必须实现此管程的确定性模拟器。输入作为固定的测试套件嵌入在程序中。对于每个测试用例，输出完成时间列表 $[f_0,f_1,\\dots,f_{M-1}]$，其顺序与该测试用例中列出的请求顺序相同。您的程序必须将所有测试用例的结果聚合到单行中，格式为由方括号括起的、以逗号分隔的各测试用例列表，且不含空格。\n\n程序内部需实现的测试套件：\n- 测试用例 A（正常路径）：\n  - 租户：$N=2$，其中 $(C_0,R_0)=(5,1)$ 和 $(C_1,R_1)=(4,1)$。\n  - 全局：$(G_C,G_R)=(6,2)$。\n  - 按所列顺序的 $M=4$ 个请求：\n    - $(a_0,\\tau_0,k_0)=(0,0,3)$\n    - $(a_1,\\tau_1,k_1)=(0,1,2)$\n    - $(a_2,\\tau_2,k_2)=(1,0,2)$\n    - $(a_3,\\tau_3,k_3)=(3,1,3)$\n- 测试用例 B（突发到达与相互依赖的配额）：\n  - 租户：$N=2$，其中 $(C_0,R_0)=(4,1)$ 和 $(C_1,R_1)=(4,1)$。\n  - 全局：$(G_C,G_R)=(5,1)$。\n  - $M=5$ 个请求：\n    - $(a_0,\\tau_0,k_0)=(0,0,3)$\n    - $(a_1,\\tau_1,k_1)=(0,0,3)$\n    - $(a_2,\\tau_2,k_2)=(0,1,3)$\n    - $(a_3,\\tau_3,k_3)=(1,0,2)$\n    - $(a_4,\\tau_4,k_4)=(1,1,2)$\n- 测试用例 C（零补充，受容量限制）：\n  - 租户：$N=2$，其中 $(C_0,R_0)=(5,0)$ 和 $(C_1,R_1)=(3,0)$。\n  - 全局：$(G_C,G_R)=(6,0)$。\n  - $M=3$ 个请求：\n    - $(a_0,\\tau_0,k_0)=(0,0,2)$\n    - $(a_1,\\tau_1,k_1)=(0,1,3)$\n    - $(a_2,\\tau_2,k_2)=(1,0,1)$\n- 测试用例 D（混合速率和容量与竞争）：\n  - 租户：$N=3$，其中 $(C_0,R_0)=(2,1)$，$(C_1,R_1)=(3,0)$，$(C_2,R_2)=(5,2)$。\n  - 全局：$(G_C,G_R)=(5,2)$。\n  - $M=5$ 个请求：\n    - $(a_0,\\tau_0,k_0)=(0,0,2)$\n    - $(a_1,\\tau_1,k_1)=(0,1,3)$\n    - $(a_2,\\tau_2,k_2)=(0,2,4)$\n    - $(a_3,\\tau_3,k_3)=(1,0,2)$\n    - $(a_4,\\tau_4,k_4)=(2,2,2)$\n\n约束和保证：\n- 所有 $k_j$ 都满足 $k_j \\le C_{\\tau_j}$ 和 $k_j \\le G_C$，以确保在令牌不减少的情况下最终可被接纳。\n- 时间以整数单位计算；不涉及物理单位。\n- 最终输出必须是单行，包含所有结果，格式为由方括号括起的、以逗号分隔的各测试用例列表，且不含空格，例如：`[[\\dots],[\\dots],\\dots]`。\n\n您的任务：\n- 按规定实现模拟器。\n- 以单行形式，严格按照要求的格式生成最终输出。", "solution": "此问题是一个定义明确的确定性离散事件模拟任务。模拟的核心是实现一个主循环，该循环推进时间并根据指定的调度策略处理请求。该策略要求在每个时间点，优先处理已到达且资源充足的请求，并以最早到达时间作为主要排序标准，以输入顺序作为次要平局决胜规则。\n\n### 模拟逻辑\n1.  **初始化**:\n    - 将当前时间 `t` 设为 0。\n    - 根据给定的容量 `C_i` 和 `G_C` 初始化所有租户桶和全局桶。\n    - 创建一个待处理请求列表，并记录所有请求的完成时间（初始为未完成状态）。\n\n2.  **主循环**:\n    - 当仍有未完成的请求时，循环继续。\n    - **内部处理循环**: 在当前时间 `t`，重复以下步骤，直到没有更多请求可以在此时间点被接纳。\n        a. **寻找候选者**: 遍历所有尚未完成的请求。在已到达（`a_j = t`）且资源充足（`tenant_bucket >= k_j` 且 `global_bucket >= k_j`）的请求中，找到最佳候选者。最佳候选者是具有最早到达时间 `a_j` 的请求。如果到达时间相同，则选择输入索引 `j` 最小的请求。\n        b. **处理候选者**:\n            - 如果找到了候选者：记录其完成时间 `f_j = t`，从相应的租户桶和全局桶中减去 `k_j` 个令牌，并将该请求标记为已完成。然后，从步骤 (a) 重新开始内部循环，以检查在更新后的状态下是否有其他请求可以被接纳。\n            - 如果没有找到候选者：退出内部处理循环。\n    - **时间推进**:\n        - 将时间 `t` 增加 1。\n        - 根据各自的补充速率 `R_i` 和 `G_R`，对所有桶进行补充，但确保不超过其容量。\n\n3.  **终止**: 当所有请求都已完成后，主循环终止。收集所有完成时间并按要求的格式输出。\n\n### 测试用例执行跟踪\n\n- **测试用例 A**:\n    - t=0: R0(a=0,k=3) 和 R1(a=0,k=2) 都就绪。R0 优先，被接纳 (`f0=0`)。桶更新后，R1 仍然就绪，被接纳 (`f1=0`)。\n    - t=1: 桶补充。R2(a=1,k=2) 到达并就绪，被接纳 (`f2=1`)。\n    - t=2: 桶补充。无请求到达或就绪。\n    - t=3: 桶补充。R3(a=3,k=3) 到达并就绪，被接纳 (`f3=3`)。\n    - 结果: `[0,0,1,3]`\n\n- **测试用例 B**:\n    - t=0: R0,R1,R2 都到达。R0 就绪，被接纳 (`f0=0`)。全局桶资源不足以满足 R1 或 R2。\n    - t=1: 桶补充。R3,R4 到达。R2(a=0) 最老且就绪，被接纳 (`f2=1`)。全局桶再次耗尽。\n    - t=2: 桶补充。无请求就绪。\n    - t=3: 桶补充。R3(a=1) 就绪，被接纳 (`f3=3`)。全局桶耗尽。\n    - t=4: 桶补充。无请求就绪。\n    - t=5: 桶补充。R4(a=1) 就绪，被接纳 (`f4=5`)。\n    - t=6,7: 桶补充。全局桶不足以满足 R1。\n    - t=8: 桶补充。全局桶达到3，R1(a=0) 就绪，被接纳 (`f1=8`)。\n    - 结果: `[0,8,1,3,5]`\n\n- **测试用例 C**: (无补充)\n    - t=0: R0,R1 到达。R0 就绪，被接纳 (`f0=0`)。之后 R1 仍然就绪，被接纳 (`f1=0`)。\n    - t=1: R2 到达并就绪，被接纳 (`f2=1`)。\n    - 结果: `[0,0,1]`\n\n- **测试用例 D**:\n    - t=0: R0,R1,R2 到达。R0 最优先，被接纳 (`f0=0`)。之后 R1 仍就绪，被接纳 (`f1=0`)。R2 因全局桶不足而等待。\n    - t=1: 桶补充。R3 到达。无请求就绪。\n    - t=2: 桶补充。R4 到达。R2(a=0) 最老且就绪，被接纳 (`f2=2`)。\n    - t=3: 桶补充。R3(a=1) 就绪，被接纳 (`f3=3`)。\n    - t=4: 桶补充。R4(a=2) 就绪，被接纳 (`f4=4`)。\n    - 结果: `[0,0,2,3,4]`\n\n将所有结果汇总成最终输出格式。", "answer": "[[0,0,1,3],[0,8,1,3,5],[0,0,1],[0,0,2,3,4]]", "id": "3659622"}]}