{"hands_on_practices": [{"introduction": "等待图 (Wait-For Graph, WFG) 是一个强大的工具，用于将进程间的依赖关系可视化。在处理单实例资源（如互斥锁）的系统中，等待图中的一个环路直接对应一个死锁。本练习 [@problem_id:3632429] 将引导你模拟一系列锁请求事件，构建相应的等待图，并识别出陷入死锁的线程，从而让你具体理解循环等待是如何在图中体现的。", "problem": "一个操作系统 (OS) 管理着 $n=6$ 个并发线程 $\\{T_1,T_2,T_3,T_4,T_5,T_6\\}$，它们竞争六个不同的不可重入互斥锁 $\\{\\ell_A,\\ell_B,\\ell_C,\\ell_D,\\ell_E,\\ell_F\\}$，所有锁初始时均为空闲状态。该操作系统使用一种基于等待图 (WFG) 的死锁检测算法，其中存在一条有向边 $T_i \\to T_j$ 当且仅当线程 $T_i$ 正在等待某个由线程 $T_j$ 当前持有的锁。当且仅当 WFG 包含至少一个有向环时，存在死锁。当一个线程被阻塞时，它会继续持有其先前获取的所有锁。当一个线程终止时，操作系统会立即释放该线程持有的所有锁。\n\n请按顺序处理以下事件序列。如果请求的锁是空闲的，请求线程将获取它；否则，该线程阻塞并等待该锁可用。\n\n- 事件 $1$：$T_1$ 请求 $\\ell_A$ 并获取 $\\ell_A$。\n- 事件 $2$：$T_2$ 请求 $\\ell_B$ 并获取 $\\ell_B$。\n- 事件 $3$：$T_3$ 请求 $\\ell_C$ 并获取 $\\ell_C$。\n- 事件 $4$：$T_1$ 请求 $\\ell_B$；由于 $\\ell_B$ 由 $T_2$ 持有，$T_1$ 阻塞等待 $\\ell_B$。\n- 事件 $5$：$T_2$ 请求 $\\ell_C$；由于 $\\ell_C$ 由 $T_3$ 持有，$T_2$ 阻塞等待 $\\ell_C$。\n- 事件 $6$：$T_3$ 请求 $\\ell_A$；由于 $\\ell_A$ 由 $T_1$ 持有，$T_3$ 阻塞等待 $\\ell_A$。\n- 事件 $7$：$T_4$ 请求 $\\ell_D$ 并获取 $\\ell_D$。\n- 事件 $8$：$T_5$ 请求 $\\ell_E$ 并获取 $\\ell_E$。\n- 事件 $9$：$T_6$ 请求 $\\ell_F$ 并获取 $\\ell_F$。\n- 事件 $10$：$T_4$ 请求 $\\ell_E$；由于 $\\ell_E$ 由 $T_5$ 持有，$T_4$ 阻塞等待 $\\ell_E$。\n- 事件 $11$：$T_5$ 请求 $\\ell_F$；由于 $\\ell_F$ 由 $T_6$ 持有，$T_5$ 阻塞等待 $\\ell_F$。\n- 事件 $12$：$T_6$ 请求 $\\ell_D$；由于 $\\ell_D$ 由 $T_4$ 持有，$T_6$ 阻塞等待 $\\ell_D$。\n\n处理完事件 $12$ 后，根据最终状态构建等待图 (WFG)。确认此时 WFG 中是否存在特定的环 $C: T_1 \\to T_2 \\to T_3 \\to T_1$。然后，假设终止任何线程会立即释放其持有的所有锁，并且没有其他事件发生，计算为确保系统无死锁并能继续运行而必须终止的最小线程数 $k$。仅提供 $k$ 的值作为您的最终答案。答案应为精确整数，无需四舍五入。", "solution": "本题要求我们分析多线程环境中的一个事件序列，以确定死锁状态以及为解决死锁需要终止的最小线程数。分析过程将首先跟踪锁和线程的状态，然后构建等待图 (WFG)，识别其中的环，最后确定为使图无环所需移除的最小顶点数。\n\n首先，我们通过给定的 12 个事件序列来跟踪系统状态。系统状态由哪些线程持有哪个锁以及哪些线程在等待其他线程来定义。\n\n- **初始状态**：所有六个锁 $\\{\\ell_A, \\ell_B, \\ell_C, \\ell_D, \\ell_E, \\ell_F\\}$ 均为空闲。所有六个线程 $\\{T_1, T_2, T_3, T_4, T_5, T_6\\}$ 均已就绪。\n\n- **事件 $1-3$**：线程 $T_1$、$T_2$ 和 $T_3$ 分别获取锁 $\\ell_A$、$\\ell_B$ 和 $\\ell_C$。\n  - 事件 $1$ 后：$T_1$ 持有 $\\ell_A$。\n  - 事件 $2$ 后：$T_2$ 持有 $\\ell_B$。\n  - 事件 $3$ 后：$T_3$ 持有 $\\ell_C$。\n\n- **事件 $4-6$**：在 $T_1, T_2, T_3$ 之间建立了一组循环依赖关系。\n  - 事件 $4$：$T_1$ 请求 $\\ell_B$，该锁由 $T_2$ 持有。$T_1$ 阻塞。这建立了一个等待关系：$T_1 \\to T_2$。\n  - 事件 $5$：$T_2$ 请求 $\\ell_C$，该锁由 $T_3$ 持有。$T_2$ 阻塞。这建立了一个等待关系：$T_2 \\to T_3$。\n  - 事件 $6$：$T_3$ 请求 $\\ell_A$，该锁由 $T_1$ 持有。$T_3$ 阻塞。这建立了一个等待关系：$T_3 \\to T_1$。\n\n- **事件 $7-9$**：线程 $T_4$、$T_5$ 和 $T_6$ 分别获取锁 $\\ell_D$、$\\ell_E$ 和 $\\ell_F$。\n  - 事件 $7$ 后：$T_4$ 持有 $\\ell_D$。\n  - 事件 $8$ 后：$T_5$ 持有 $\\ell_E$。\n  - 事件 $9$ 后：$T_6$ 持有 $\\ell_F$。\n\n- **事件 $10-12$**：在 $T_4, T_5, T_6$ 之间建立了第二组循环依赖关系。\n  - 事件 $10$：$T_4$ 请求 $\\ell_E$，该锁由 $T_5$ 持有。$T_4$ 阻塞。这建立了一个等待关系：$T_4 \\to T_5$。\n  - 事件 $11$：$T_5$ 请求 $\\ell_F$，该锁由 $T_6$ 持有。$T_5$ 阻塞。这建立了一个等待关系：$T_5 \\to T_6$。\n  - 事件 $12$：$T_6$ 请求 $\\ell_D$，该锁由 $T_4$ 持有。$T_6$ 阻塞。这建立了一个等待关系：$T_6 \\to T_4$。\n\n处理完所有 12 个事件后，系统状态如下：\n- **锁持有者**：\n  - $T_1$ 持有 $\\ell_A$。\n  - $T_2$ 持有 $\\ell_B$。\n  - $T_3$ 持有 $\\ell_C$。\n  - $T_4$ 持有 $\\ell_D$。\n  - $T_5$ 持有 $\\ell_E$。\n  - $T_6$ 持有 $\\ell_F$。\n- **等待中的线程**：\n  - $T_1$ 正在等待 $\\ell_B$（由 $T_2$ 持有）。\n  - $T_2$ 正在等待 $\\ell_C$（由 $T_3$ 持有）。\n  - $T_3$ 正在等待 $\\ell_A$（由 $T_1$ 持有）。\n  - $T_4$ 正在等待 $\\ell_E$（由 $T_5$ 持有）。\n  - $T_5$ 正在等待 $\\ell_F$（由 $T_6$ 持有）。\n  - $T_6$ 正在等待 $\\ell_D$（由 $T_4$ 持有）。\n\n接下来，我们构建等待图 $G=(V, E)$，其中顶点集 $V$ 是线程集合，如果线程 $T_i$ 正在等待由线程 $T_j$ 持有的锁，则存在一条有向边 $(T_i, T_j) \\in E$。\n- 顶点集：$V = \\{T_1, T_2, T_3, T_4, T_5, T_6\\}$。\n- 边集：$E = \\{(T_1, T_2), (T_2, T_3), (T_3, T_1), (T_4, T_5), (T_5, T_6), (T_6, T_4)\\}$。\n\n当且仅当 WFG 包含至少一个有向环时，存在死锁。我们检查图中的环。\n边集清晰地定义了两个不同的环：\n1.  环 $C_1$：$T_1 \\to T_2 \\to T_3 \\to T_1$。该环由边 $(T_1, T_2)$、$(T_2, T_3)$ 和 $(T_3, T_1)$ 形成。\n2.  环 $C_2$：$T_4 \\to T_5 \\to T_6 \\to T_4$。该环由边 $(T_4, T_5)$、$(T_5, T_6)$ 和 $(T_6, T_4)$ 形成。\n\n题目明确要求确认环 $C: T_1 \\to T_2 \\to T_3 \\to T_1$ 的存在。根据我们构建的 WFG，这个环是存在的，并且是系统中两个死锁之一。\n\n最后的任务是计算为消除所有死锁而必须终止的最小线程数 $k$。终止一个线程对应于从 WFG 中移除其对应的顶点。要打破有向图中的所有环，我们必须找到一个最小反馈顶点集，这是一个最小的顶点集合，移除该集合中的顶点后图将变为无环图。\n\n本题中的 WFG 由两个顶点不相交的分量组成，每个分量都是一个简单环。\n- 第一个分量涉及顶点 $\\{T_1, T_2, T_3\\}$ 并形成环 $C_1$。\n- 第二个分量涉及顶点 $\\{T_4, T_5, T_6\\}$ 并形成环 $C_2$。\n\n由于这两个环是顶点不相交的，从一个环中移除一个顶点不会影响另一个环。因此，要打破所有环，我们必须独立地打破每个环。\n- 要打破环 $C_1$，我们必须从集合 $\\{T_1, T_2, T_3\\}$ 中终止至少一个线程。所需的最小数量是 $1$。\n- 要打破环 $C_2$，我们必须从集合 $\\{T_4, T_5, T_6\\}$ 中终止至少一个线程。所需的最小数量是 $1$。\n\n需要终止的最小线程总数 $k$ 是打破每个不相交环所需的最小数量之和。\n$$k = (\\text{打破 } C_1 \\text{ 所需的最小线程数}) + (\\text{打破 } C_2 \\text{ 所需的最小线程数}) = 1 + 1 = 2$$\n例如，终止线程 $T_1$ 和 $T_4$ 将是一个可能的最小终止集合。终止 $T_1$ 会释放 $\\ell_A$，从而打破环 $C_1$。终止 $T_4$ 会释放 $\\ell_D$，从而打破环 $C_2$。最终的系统将没有死锁。\n\n因此，必须终止的最小线程数是 $2$。", "answer": "$$\\boxed{2}$$", "id": "3632429"}, {"introduction": "当系统涉及具有多个实例的资源类型时，简单的等待图便不足以明确地判断是否存在死锁。此时，我们需要使用一种更强大的、基于矩阵的算法，它类似于银行家算法的检测变体。本练习 [@problem_id:3632410] 提供了一个包含具体分配矩阵和请求矩阵的场景，让你能够逐步应用该检测算法，以判断系统当前是否处于安全状态，或者是否存在死锁。", "problem": "考虑一个操作系统（OS），其中有 $n=6$ 个进程 $\\{P_0,P_1,P_2,P_3,P_4,P_5\\}$ 竞争 $m=4$ 种资源类型 $\\{R_1,R_2,R_3,R_4\\}$，每种资源有多个实例。系统状态由资源分配矩阵 $\\mathbf{Allocation} \\in \\mathbb{Z}^{6 \\times 4}$、未满足的请求矩阵 $\\mathbf{Request} \\in \\mathbb{Z}^{6 \\times 4}$ 以及当前可用实例向量 $\\mathbf{Available} \\in \\mathbb{Z}^{4}$ 来表征，具体如下所示。每行对应一个进程 $P_i$，每列对应一种资源类型 $R_j$。\n\n$$\n\\mathbf{Allocation} =\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  0  1  0 \\\\\n0  2  0  0 \\\\\n1  0  0  0 \\\\\n0  0  1  1 \\\\\n0  1  0  0\n\\end{pmatrix},\n\\quad\n\\mathbf{Request} =\n\\begin{pmatrix}\n0  0  1  0 \\\\\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  1 \\\\\n0  1  0  0\n\\end{pmatrix},\n\\quad\n\\mathbf{Available} =\n\\begin{pmatrix}\n1  0  1  0\n\\end{pmatrix}.\n$$\n\n使用经典的多实例资源死锁检测算法，该算法迭代地寻找一个未完成的进程 $P_i$，其请求向量 $Request_i$ 满足 $Request_i \\leq Work$（其中 $Work$ 初始化为 $\\mathbf{Available}$）。当找到这样的进程时，就认为 $P_i$ 能够完成并释放其分配的资源，然后更新 $Work \\leftarrow Work + Allocation_i$。持续此过程直到不存在这样的 $P_i$；此时仍未完成的进程被认为是不可完成的。\n\n定义量 $S$ 为所有不可完成进程的索引之和，即，如果不可完成的进程集合是 $\\{P_{i_1}, P_{i_2}, \\dots\\}$，则 $S = i_1 + i_2 + \\dots$。计算 $S$。请以精确整数形式提供最终答案，无需四舍五入。", "solution": "任务是确定在一个有 $n=6$ 个进程和 $m=4$ 种资源类型的系统中，不可完成的进程集合。系统状态由 $\\mathbf{Allocation}$ 矩阵、$\\mathbf{Request}$ 矩阵和 $\\mathbf{Available}$ 向量给出。\n\n已知条件如下：\n- 进程数：$n=6$, $\\{P_0,P_1,P_2,P_3,P_4,P_5\\}$。\n- 资源类型数：$m=4$, $\\{R_1,R_2,R_3,R_4\\}$。\n- 分配矩阵 $\\mathbf{Allocation} \\in \\mathbb{Z}^{6 \\times 4}$：\n$$\n\\mathbf{Allocation} =\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  0  1  0 \\\\\n0  2  0  0 \\\\\n1  0  0  0 \\\\\n0  0  1  1 \\\\\n0  1  0  0\n\\end{pmatrix}\n$$\n- 请求矩阵 $\\mathbf{Request} \\in \\mathbb{Z}^{6 \\times 4}$：\n$$\n\\mathbf{Request} =\n\\begin{pmatrix}\n0  0  1  0 \\\\\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  1 \\\\\n0  1  0  0\n\\end{pmatrix}\n$$\n- 可用向量 $\\mathbf{Available} \\in \\mathbb{Z}^{4}$：\n$$\n\\mathbf{Available} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}\n$$\n\n我们应用死锁检测算法。设 $\\mathbf{Work}$ 为一个长度为 $m$ 的向量，$\\mathbf{Finish}$ 为一个长度为 $n$ 的布尔向量。向量不等式 $\\mathbf{A} \\leq \\mathbf{B}$ 成立当且仅当对于所有分量 $k$ 都有 $A_k \\leq B_k$。\n\n**步骤 1：初始化**\n将 $\\mathbf{Work}$ 初始化为 $\\mathbf{Available}$，并将所有进程 $i = 0, \\dots, 5$ 的 $\\mathbf{Finish}_i$ 初始化为 false。\n$$ \\mathbf{Work} = \\mathbf{Available} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix} $$\n$$ \\mathbf{Finish} = \\begin{pmatrix} \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix} $$\n\n**步骤 2：迭代搜索与更新**\n该算法通过寻找一个索引 $i$，使得 $\\mathbf{Finish}_i$ 为 false 且其请求向量 $\\mathbf{Request}_i \\leq \\mathbf{Work}$。如果找到，该进程理论上可以完成，因此我们通过更新 $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_i$ 并设置 $\\mathbf{Finish}_i \\leftarrow \\text{true}$ 来释放其资源。重复此过程，直到找不到这样的进程为止。\n\n**迭代 1：**\n我们搜索一个进程 $P_i$，其 $\\mathbf{Finish}_i = \\text{false}$ 且 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}$。\n- $P_0$：$\\mathbf{Request}_0 = \\begin{pmatrix} 0  0  1  0 \\end{pmatrix} \\leq \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}$。此条件满足。\n我们选择 $P_0$。\n更新 $\\mathbf{Work}$：$\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_0 = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix} + \\begin{pmatrix} 1  0  0  1 \\end{pmatrix} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$。\n更新 $\\mathbf{Finish}$：$\\mathbf{Finish}_0 \\leftarrow \\text{true}$。\n当前状态为 $\\mathbf{Work} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$ 且 $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix}$。\n\n**迭代 2：**\n我们搜索一个未完成的进程 $P_i$，其 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$。\n- $P_1$：$\\mathbf{Request}_1 = \\begin{pmatrix} 1  0  0  0 \\end{pmatrix} \\leq \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$。此条件满足。\n我们选择 $P_1$。\n更新 $\\mathbf{Work}$：$\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_1 = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix} + \\begin{pmatrix} 0  0  1  0 \\end{pmatrix} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$。\n更新 $\\mathbf{Finish}$：$\\mathbf{Finish}_1 \\leftarrow \\text{true}$。\n当前状态为 $\\mathbf{Work} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$ 且 $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix}$。\n\n**迭代 3：**\n我们搜索一个未完成的进程 $P_i$，其 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$。\n- $P_2$：$\\mathbf{Request}_2 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$。这不满足 $\\leq \\mathbf{Work}$，因为对于第二种资源，$1  0$。\n- $P_3$：$\\mathbf{Request}_3 = \\begin{pmatrix} 0  0  0  0 \\end{pmatrix} \\leq \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$。此条件满足。\n我们选择 $P_3$。\n更新 $\\mathbf{Work}$：$\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_3 = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix} + \\begin{pmatrix} 1  0  0  0 \\end{pmatrix} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$。\n更新 $\\mathbf{Finish}$：$\\mathbf{Finish}_3 \\leftarrow \\text{true}$。\n当前状态为 $\\mathbf{Work} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$ 且 $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{false}  \\text{false} \\end{pmatrix}$。\n\n**迭代 4：**\n我们搜索一个未完成的进程 $P_i$，其 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$。\n- $P_2$：$\\mathbf{Request}_2$ 仍然不满足。\n- $P_4$：$\\mathbf{Request}_4 = \\begin{pmatrix} 0  0  0  1 \\end{pmatrix} \\leq \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$。此条件满足。\n我们选择 $P_4$。\n更新 $\\mathbf{Work}$：$\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_4 = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix} + \\begin{pmatrix} 0  0  1  1 \\end{pmatrix} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$。\n更新 $\\mathbf{Finish}$：$\\mathbf{Finish}_4 \\leftarrow \\text{true}$。\n当前状态为 $\\mathbf{Work} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$ 且 $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{true}  \\text{false} \\end{pmatrix}$。\n\n**迭代 5：**\n我们搜索一个未完成的进程 $P_i$，其 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$。剩余未完成的进程是 $P_2$ 和 $P_5$。\n- $P_2$：$\\mathbf{Request}_2 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$。这不满足 $\\leq \\mathbf{Work}$，因为对于 $R_2$，$1  0$。\n- $P_5$：$\\mathbf{Request}_5 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$。这不满足 $\\leq \\mathbf{Work}$，因为对于 $R_2$，$1  0$。\n\n**步骤 3：终止**\n当前 $\\mathbf{Work}$ 向量无法满足任何剩余未完成进程的请求。算法终止。\n\n**步骤 4：识别不可完成的进程并计算 S**\n那些 $\\mathbf{Finish}_i$ 仍然为 false 的进程被认为是不可完成的。从最终的 $\\mathbf{Finish}$ 向量 $\\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{true}  \\text{false} \\end{pmatrix}$ 可知，不可完成的进程是 $\\{P_2, P_5\\}$。\n\n问题将 $S$ 定义为所有不可完成进程的索引之和。\n$$ S = 2 + 5 = 7 $$\n造成死锁的物理原因是 $P_2$ 和 $P_5$ 都在请求资源 $R_2$ 的一个实例。而 $R_2$ 的可用实例为 0，并且没有其他能够完成的进程持有 $R_2$ 的实例可以释放。因此，$P_2$ 和 $P_5$ 将无限期地等待。", "answer": "$$\\boxed{7}$$", "id": "3632410"}, {"introduction": "死锁检测算法的准确性，完全取决于其所基于的系统模型的精确度。错误地解读同步原语的语义会导致错误的结论，例如将资源饥饿（starvation）误判为死锁。这个发人深省的练习 [@problem_id:3632504] 通过一个读写锁的例子，探讨了一个常见的陷阱，旨在挑战你分析为何一个“天真”的死锁检测器会错误地报告死锁，并量化这种误判发生的条件。", "problem": "考虑一个读者优先的单读写锁，它允许多个读者并发持有锁，但要求写者独占锁。系统遵循读者优先原则：一旦有写者到达，后续的读者仍然可以立即获得锁；因此，如果读者不断到达，写者可能会饿死，但在正确的建模下不存在真正的死锁，因为读者之间不会相互等待。操作系统的死锁检测器会构建一个等待图 (Wait-For Graph, WFG)，其中节点是线程，当且仅当线程 $P$ 正在等待一个由线程 $Q$ 当前持有或保证在 $P$ 之前获取的资源时，存在一条边 $P \\to Q$。当且仅当WFG中存在有向环时，系统处于死锁状态。\n\n在时间 $t_0$，假设有 $x$ 个读者线程 $R_1,\\dots,R_x$ 持有锁，以及 $y$ 个写者线程 $W_1,\\dots,W_y$ 已经到达并等待获取锁。在 $t_0$ 之后，另外 $n$ 个读者线程 $R_{x+1},\\dots,R_{x+n}$ 到达。在读者优先原则下，这 $n$ 个读者立即加入当前持有者的集合，无需等待。然而，一个简陋的死锁检测器会错误地将读写锁视为严格的先入先出互斥锁，忽略了锁模式和读者优先原则，它构建WFG的方式是：对于每个等待获取锁的线程，添加指向当前持有锁或在队列中任何位置（不考虑队列位置和锁模式）的每个线程的边。在这个简陋的模型下：\n- 对于每个等待的写者 $W_k$，检测器为所有 $i \\in \\{1,\\dots,x+n\\}$ 添加边 $W_k \\to R_i$。\n- 对于每个新到达的读者 $R_j$（其中 $j \\in \\{x+1,\\dots,x+n\\}$），检测器（错误地）假设它在写者之后排队，并为所有 $k \\in \\{1,\\dots,y\\}$ 添加边 $R_j \\to W_k$。\n\n请基于以上定义，通过一次推导回答以下问题：\n1. 从WFG构建和读写锁语义的基本原理出发，解释为什么正确的检测必须将读者与写者区别对待，以及为什么所描述的读者优先行为在正确建模下不会产生死锁。\n2. 在简陋检测器的模型下，量化WFG中出现的不同双节点环（相互等待对）的数量，将其表示为 $n$ 和 $y$ 的函数。\n3. 部署的简陋检测器仅在不同双节点环的数量至少达到一个固定阈值 $T$ 时（以避免虚假的单周期噪声）才会触发死锁警报。求出最小整数 $n^{\\star}$，使得简陋检测器将此情况错误分类为死锁（即双节点环的数量至少为 $T$），并将其表示为 $y$ 和 $T$ 的闭式函数。\n\n将您的最终答案表示为 $n^{\\star}$ 的单个闭式解析表达式。无需四舍五入。", "solution": "**1. 正确的死锁检测分析**\n\n死锁由等待图（WFG）中是否存在环来定义。WFG中的一条边 $P \\to Q$ 表示线程 $P$ 处于等待状态，等待线程 $Q$ 释放其持有的资源。我们为所描述的状态构建正确的WFG。\n\n系统中的线程是读者 $R_1, \\dots, R_{x+n}$ 和写者 $W_1, \\dots, W_y$。我们必须确定哪些线程在等待。\n- 读者 $R_1, \\dots, R_x$ 在时间 $t_0$ 时持有锁。它们没有在等待。\n- 写者 $W_1, \\dots, W_y$ 已经到达并等待获取锁。锁由读者持有。因此，对于每个写者 $W_k$（其中 $k \\in \\{1, \\dots, y\\}$），它正在等待所有当前锁的持有者。持有者是读者 $R_1, \\dots, R_{x+n}$。因此，对于所有 $k \\in \\{1, \\dots, y\\}$ 和 $i \\in \\{1, \\dots, x+n\\}$，存在边 $W_k \\to R_i$。\n- 新读者 $R_{x+1}, \\dots, R_{x+n}$ 在写者之后到达。然而，系统实施读者优先，意味着这些新读者“被立即接纳”并“无需等待即加入当前持有者集合”。由于它们不等待，因此WFG中没有任何从读者节点 $R_j$ 发出的出边。\n\n有向图中的环是一条或多条边的路径，其起点和终点是同一个节点，例如 $P_1 \\to P_2 \\to \\dots \\to P_m \\to P_1$。在我们正确构建的WFG中，唯一存在的边形式为 $W_k \\to R_i$。没有任何从读者节点 $R_i$ 发出的边。因此，不可能形成长度为2或更长的路径，因为任何路径都必须在读者节点处终止。要存在环，就需要有一条从读者 $R_i$ 回到写者 $W_k$（或任何其他存在路径到 $W_k$ 的节点）的路径，但无法形成这样的路径。WFG是一个二分图，所有边都从写者节点集合指向读者节点集合。根据定义，这样的图是无环的。因此，在正确的WFG模型下，没有死锁。\n\n**2. 在简陋检测器模型下量化双节点环**\n\n简陋检测器在一个有缺陷的模型下运行。我们分析它构建的WFG，以计算双节点环的数量。线程 $P$ 和 $Q$ 之间的双节点环由两条边组成：$P \\to Q$ 和 $Q \\to P$。我们试图找到简陋检测器的规则为其创建了这种相互等待条件的线程对。\n\n边创建的规则是：\n- (A) 对于每个等待的写者 $W_k$ ($k \\in \\{1, \\dots, y\\}$)，为所有 $i \\in \\{1, \\dots, x+n\\}$ 添加边 $W_k \\to R_i$。\n- (B) 对于每个新到达的读者 $R_j$ ($j \\in \\{x+1, \\dots, x+n\\}$)，为所有 $k \\in \\{1, \\dots, y\\}$ 添加边 $R_j \\to W_k$。\n\n让我们考虑一个由一个写者 $W_k$ 和一个新读者 $R_j$ 组成的线程对，其中 $k \\in \\{1, \\dots, y\\}$ 且 $j \\in \\{x+1, \\dots, x+n\\}$。\n- 边 $W_k \\to R_j$ 是否存在？是的，根据规则(A)，会从每个写者 $W_k$ 创建到每个读者的边，包括新读者。\n- 边 $R_j \\to W_k$ 是否存在？是的，根据规则(B)，会从每个新读者 $R_j$ 创建到每个写者 $W_k$ 的边。\n\n因此，对于每个写者 $W_k$ 和每个新读者 $R_j$，简陋检测器都会构建一个双节点环 $\\{W_k, R_j\\}$。\n\n现在我们必须计算这种不同环路的总数。一个不同的双节点环由一对唯一的节点定义。这些配对的形式是 $\\{W_k, R_j\\}$。\n- 写者线程 $W_k$ 的选择有 $y$ 种。\n- 新读者线程 $R_j$ 的选择有 $n$ 种。\n\n唯一配对的总数，也就是不同双节点环的数量，是每种线程选择数量的乘积。设 $C$ 为环的数量。\n$$C = n \\times y = ny$$\n请注意，原始的读者 $R_1, \\dots, R_x$ 不参与这些双节点环。虽然规则(A)为 $i \\in \\{1, \\dots, x\\}$ 创建了边 $W_k \\to R_i$，但规则(B)不适用于这些读者，因此没有为这个群体创建形如 $R_i \\to W_k$ 的边。因此，参数 $x$ 与双节点环的计数无关。\n\n**3. 确定最小整数 $n^{\\star}$**\n\n如果不同双节点环的数量 $C$ 至少达到一个固定的阈值 $T$，简陋检测器就会触发警报。\n$$C \\ge T$$\n代入第2部分中 $C$ 的表达式：\n$$ny \\ge T$$\n我们被要求找到满足此条件的最小整数 $n$，记为 $n^{\\star}$。我们可以解这个关于 $n$ 的不等式。假设 $y  0$ （因为如果 $y=0$，则没有等待的写者，因此 $C=0$，对于 $T0$ 的情况不可能触发警报），我们可以两边同除以 $y$：\n$$n \\ge \\frac{T}{y}$$\n因为 $n$ 必须是代表线程数的整数，所以满足此不等式的最小整数 $n$ 值是表达式 $\\frac{T}{y}$ 的上取整。上取整函数，记为 $\\lceil z \\rceil$，给出大于或等于 $z$ 的最小整数。\n因此，最小整数 $n^{\\star}$ 是：\n$$n^{\\star} = \\left\\lceil \\frac{T}{y} \\right\\rceil$$\n\n这就是 $n^{\\star}$ 作为 $y$ 和 $T$ 的函数的最终闭式表达式。", "answer": "$$\\boxed{\\left\\lceil \\frac{T}{y} \\right\\rceil}$$", "id": "3632504"}]}