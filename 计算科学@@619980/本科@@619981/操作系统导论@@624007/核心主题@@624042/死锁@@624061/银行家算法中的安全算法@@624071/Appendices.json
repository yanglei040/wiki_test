{"hands_on_practices": [{"introduction": "当一个系统的可用资源向量为零时，是否意味着系统已陷入僵局？这个练习挑战了这种直觉，并揭示了一个关键点：即使当前没有立即可用的资源，如果存在一个已经满足其所有需求（即其 $Need$ 向量为零）的进程，系统仍然可能是安全的。通过识别并首先完成这个进程，我们可以释放其占有的资源，从而启动一个导致所有进程完成的安全序列。[@problem_id:3678920]", "problem": "考虑一个操作系统中使用银行家算法进行死锁避免调度的系统。存在 $4$ 个进程 $\\{P_1,P_2,P_3,P_4\\}$ 和 $3$ 种资源类型。设分配矩阵 $A$ 和最大需求矩阵 $M$ 如下：\n- $A(P_1)=\\langle 1,0,1\\rangle$, $A(P_2)=\\langle 0,1,0\\rangle$, $A(P_3)=\\langle 1,1,0\\rangle$, $A(P_4)=\\langle 0,0,2\\rangle$。\n- $M(P_1)=\\langle 1,1,1\\rangle$, $M(P_2)=\\langle 0,1,0\\rangle$, $M(P_3)=\\langle 1,1,1\\rangle$, $M(P_4)=\\langle 1,0,2\\rangle$。\n\n假设初始可用资源向量为 $Available=\\langle 0,0,0\\rangle$。仅使用支持银行家算法安全性检查的核心定义——即需求矩阵 $Need=M-A$，一个进程 $P_i$ 如果其 $Need_i \\leq Work$（对当前 $Work$ 向量，初始化为 $Available$）分量级成立则有资格完成，以及当 $P_i$ 完成后其已分配的资源被释放，使得 $Work \\leftarrow Work + A(P_i)$——来确定系统是否处于安全状态。\n\n如果系统是安全的，在每一步选择在安全性检查下能够完成的最小索引进程（按标识符 $1$ 到 $4$），并继续直到所有进程都能完成。将得到的字典序最小的安全序列表示为一个十进制整数，该整数由按顺序连接所选进程的标识符构成（例如，序列 $\\langle P_2,P_1,P_3,P_4\\rangle$ 将被写成整数 $2134$）。如果不存在安全序列，则报告的整数为 $0$。\n\n你的最终答案必须是这个单一整数。无需四舍五入。", "solution": "首先验证问题，以确保其自洽、有科学依据且定义明确。\n\n### 步骤 1：提取已知信息\n- 进程数量：$4$，记为 $\\{P_1, P_2, P_3, P_4\\}$。\n- 资源类型数量：$3$。\n- 分配矩阵 $A$：\n  - $A(P_1) = \\langle 1, 0, 1 \\rangle$\n  - $A(P_2) = \\langle 0, 1, 0 \\rangle$\n  - $A(P_3) = \\langle 1, 1, 0 \\rangle$\n  - $A(P_4) = \\langle 0, 0, 2 \\rangle$\n- 最大需求矩阵 $M$：\n  - $M(P_1) = \\langle 1, 1, 1 \\rangle$\n  - $M(P_2) = \\langle 0, 1, 0 \\rangle$\n  - $M(P_3) = \\langle 1, 1, 1 \\rangle$\n  - $M(P_4) = \\langle 1, 0, 2 \\rangle$\n- 初始可用资源向量：$Available = \\langle 0, 0, 0 \\rangle$。\n- 安全性算法规则：\n  1. $Need = M - A$。\n  2. 如果 $Need_i \\le Work$，则进程 $P_i$ 可以完成，其中 $Work$ 是当前可用资源向量。比较是分量级的。\n  3. 初始时，$Work = Available$。\n  4. 当 $P_i$ 完成后，其资源被释放：$Work \\leftarrow Work + A(P_i)$。\n- 决胜规则：如果有多个进程可以完成，选择索引最小的那个（例如，$P_1$ 优先于 $P_2$）。\n- 输出格式：如果存在安全序列，则将进程索引连接成一个整数。如果不存在，则输出为 $0$。\n\n### 步骤 2：使用提取的已知信息进行验证\n问题陈述为银行家算法的安全性检查提供了一套完整且一致的数据。银行家算法是操作系统中用于死锁避免的一个基本概念，这使得该问题具有科学依据。对于所有进程，其已分配资源不超过其最大需求的条件（对所有 $i$，$A(P_i) \\le M(P_i)$）均得到满足。\n- 对于 $P_1$：$\\langle 1,0,1 \\rangle \\le \\langle 1,1,1 \\rangle$，成立。\n- 对于 $P_2$：$\\langle 0,1,0 \\rangle \\le \\langle 0,1,0 \\rangle$，成立。\n- 对于 $P_3$：$\\langle 1,1,0 \\rangle \\le \\langle 1,1,1 \\rangle$，成立。\n- 对于 $P_4$：$\\langle 0,0,2 \\rangle \\le \\langle 1,0,2 \\rangle$，成立。\n该问题定义明确，目标清晰，并且有一个确定性的决胜规则，确保了唯一解。初始条件 $Available = \\langle 0,0,0 \\rangle$ 不常见但并非无效；这是一个需要分析的特定状态。该问题没有任何科学缺陷、歧义或矛盾。\n\n### 步骤 3：结论与行动\n问题有效。将按规定应用安全性算法推导求解。\n\n### 解题过程\n\n第一步是计算 $Need$ 矩阵，其中 $Need_i = M_i - A_i$。$Need$ 矩阵的行对应于进程 $P_1, P_2, P_3, P_4$。\n- $Need(P_1) = M(P_1) - A(P_1) = \\langle 1, 1, 1 \\rangle - \\langle 1, 0, 1 \\rangle = \\langle 0, 1, 0 \\rangle$。\n- $Need(P_2) = M(P_2) - A(P_2) = \\langle 0, 1, 0 \\rangle - \\langle 0, 1, 0 \\rangle = \\langle 0, 0, 0 \\rangle$。\n- $Need(P_3) = M(P_3) - A(P_3) = \\langle 1, 1, 1 \\rangle - \\langle 1, 1, 0 \\rangle = \\langle 0, 0, 1 \\rangle$。\n- $Need(P_4) = M(P_4) - A(P_4) = \\langle 1, 0, 2 \\rangle - \\langle 0, 0, 2 \\rangle = \\langle 1, 0, 0 \\rangle$。\n\n我们可以用一个表格来表示初始状态：\n| 进程 | 已分配 | 最大需求 | 需求 |\n| :--- | :---: | :---: | :---: |\n| $P_1$ | $\\langle 1,0,1 \\rangle$ | $\\langle 1,1,1 \\rangle$ | $\\langle 0,1,0 \\rangle$ |\n| $P_2$ | $\\langle 0,1,0 \\rangle$ | $\\langle 0,1,0 \\rangle$ | $\\langle 0,0,0 \\rangle$ |\n| $P_3$ | $\\langle 1,1,0 \\rangle$ | $\\langle 1,1,1 \\rangle$ | $\\langle 0,0,1 \\rangle$ |\n| $P_4$ | $\\langle 0,0,2 \\rangle$ | $\\langle 1,0,2 \\rangle$ | $\\langle 1,0,0 \\rangle$ |\n\n现在，我们应用安全性算法。\n- 初始化 $Work = Available = \\langle 0, 0, 0 \\rangle$。\n- 初始化 $Finish = [\\text{假}, \\text{假}, \\text{假}, \\text{假}]$。\n- 安全序列初始为空：$S = \\langle \\rangle$。\n\n**第 1 轮迭代：**\n- 当前 $Work = \\langle 0, 0, 0 \\rangle$。未完成的进程：$\\{P_1, P_2, P_3, P_4\\}$。\n- 我们寻找一个进程 $P_i$，使得 $Finish[i]$ 为假且 $Need_i \\le Work$。\n  - 对于 $P_1$：$Need_1 = \\langle 0,1,0 \\rangle \\not\\le \\langle 0,0,0 \\rangle$。\n  - 对于 $P_2$：$Need_2 = \\langle 0,0,0 \\rangle \\le \\langle 0,0,0 \\rangle$。此进程可以执行。\n  - 对于 $P_3$：$Need_3 = \\langle 0,0,1 \\rangle \\not\\le \\langle 0,0,0 \\rangle$。\n  - 对于 $P_4$：$Need_4 = \\langle 1,0,0 \\rangle \\not\\le \\langle 0,0,0 \\rangle$。\n- 只有 $P_2$ 可以完成。我们选择 $P_2$。\n- 更新 $Work$：$Work \\leftarrow Work + A_2 = \\langle 0,0,0 \\rangle + \\langle 0,1,0 \\rangle = \\langle 0,1,0 \\rangle$。\n- 更新 $Finish$：$Finish[2] \\leftarrow \\text{真}$。\n- 更新序列：$S = \\langle P_2 \\rangle$。\n\n**第 2 轮迭代：**\n- 当前 $Work = \\langle 0, 1, 0 \\rangle$。未完成的进程：$\\{P_1, P_3, P_4\\}$。\n- 我们寻找一个进程 $P_i$，使得 $Finish[i]$ 为假且 $Need_i \\le Work$。\n  - 对于 $P_1$：$Need_1 = \\langle 0,1,0 \\rangle \\le \\langle 0,1,0 \\rangle$。此进程可以执行。\n  - 对于 $P_3$：$Need_3 = \\langle 0,0,1 \\rangle \\not\\le \\langle 0,1,0 \\rangle$。\n  - 对于 $P_4$：$Need_4 = \\langle 1,0,0 \\rangle \\not\\le \\langle 0,1,0 \\rangle$。\n- 只有 $P_1$ 可以完成。我们选择 $P_1$。\n- 更新 $Work$：$Work \\leftarrow Work + A_1 = \\langle 0,1,0 \\rangle + \\langle 1,0,1 \\rangle = \\langle 1,1,1 \\rangle$。\n- 更新 $Finish$：$Finish[1] \\leftarrow \\text{真}$。\n- 更新序列：$S = \\langle P_2, P_1 \\rangle$。\n\n**第 3 轮迭代：**\n- 当前 $Work = \\langle 1, 1, 1 \\rangle$。未完成的进程：$\\{P_3, P_4\\}$。\n- 我们寻找一个进程 $P_i$，使得 $Finish[i]$ 为假且 $Need_i \\le Work$。\n  - 对于 $P_3$：$Need_3 = \\langle 0,0,1 \\rangle \\le \\langle 1,1,1 \\rangle$。此进程可以执行。\n  - 对于 $P_4$：$Need_4 = \\langle 1,0,0 \\rangle \\le \\langle 1,1,1 \\rangle$。此进程也可以执行。\n- 根据决胜规则，我们必须选择索引最小的进程，即 $P_3$。\n- 选择 $P_3$。\n- 更新 $Work$：$Work \\leftarrow Work + A_3 = \\langle 1,1,1 \\rangle + \\langle 1,1,0 \\rangle = \\langle 2,2,1 \\rangle$。\n- 更新 $Finish$：$Finish[3] \\leftarrow \\text{真}$。\n- 更新序列：$S = \\langle P_2, P_1, P_3 \\rangle$。\n\n**第 4 轮迭代：**\n- 当前 $Work = \\langle 2, 2, 1 \\rangle$。未完成的进程：$\\{P_4\\}$。\n- 我们寻找一个进程 $P_i$，使得 $Finish[i]$ 为假且 $Need_i \\le Work$。\n  - 对于 $P_4$：$Need_4 = \\langle 1,0,0 \\rangle \\le \\langle 2,2,1 \\rangle$。此进程可以执行。\n- 我们选择 $P_4$。\n- 更新 $Work$：$Work \\leftarrow Work + A_4 = \\langle 2,2,1 \\rangle + \\langle 0,0,2 \\rangle = \\langle 2,2,3 \\rangle$。\n- 更新 $Finish$：$Finish[4] \\leftarrow \\text{真}$。\n- 更新序列：$S = \\langle P_2, P_1, P_3, P_4 \\rangle$。\n\n**结论：**\n所有进程都已完成，即 $Finish = [\\text{真}, \\text{真}, \\text{真}, \\text{真}]$。因此，系统处于安全状态。字典序最小的安全序列是 $\\langle P_2, P_1, P_3, P_4 \\rangle$。\n问题要求将此序列表示为由连接进程标识符构成的单个十进制整数。这些标识符是 $2$、$1$、$3$ 和 $4$。连接这些数字得到整数 $2134$。", "answer": "$$\\boxed{2134}$$", "id": "3678920"}, {"introduction": "我们已经知道如何找到一个安全序列，但这是否意味着解决方案总是唯一的？这个练习将引导我们探索一个资源高度受限的系统状态，在这种状态下，安全算法的每一步都只有一个唯一的选择，形成一条通往安全的“独木桥”。通过解决这个问题，你将学会如何严谨地论证为何任何偏离此序列的尝试都将导致不安全状态，从而深入理解唯一安全序列的概念及其对系统稳定性的意义。[@problem_id:3678954]", "problem": "您正在一个操作系统（OS）中使用银行家算法研究死锁避免问题。回顾安全算法中使用的核心定义：系统跟踪每个进程对多种资源类型的最大需求和当前分配。派生矩阵 $Need$ 通过 $Need = Max - Allocation$ 计算，初始的 $Available$ 向量等于 $Total - \\sum Allocation$。如果存在一个进程序列，使得从 $Available$ 作为工作向量开始，序列中的每个进程都满足其 $Need \\leq$ 当前工作向量，能够完成执行，然后将其 $Allocation$ 释放回工作向量以供下一个进程使用，那么该状态就是安全的。\n\n考虑一个系统，有 $m = 3$ 种资源类型和 $n = 4$ 个进程，标记为 $P_0, P_1, P_2, P_3$。总资源向量为\n$$\nTotal = \\begin{pmatrix} 5 \\\\ 5 \\\\ 4 \\end{pmatrix}.\n$$\n当前的 $Allocation$ 和 $Max$ 矩阵为：\n$$\nAllocation = \n\\begin{pmatrix}\n1  3  0 \\\\\n1  0  2 \\\\\n1  2  0 \\\\\n1  0  1\n\\end{pmatrix},\n\\quad\nMax =\n\\begin{pmatrix}\n5  3  0 \\\\\n1  2  3 \\\\\n2  2  0 \\\\\n4  0  2\n\\end{pmatrix}.\n$$\n任务：\n1. 使用上述基本定义，推导出 $Need$ 矩阵和初始的 $Available$ 向量。\n2. 从第一性原理出发，应用安全算法来确定该状态是否安全，如果安全，请找出一个安全序列。\n3. 通过证明在安全算法的每一步中只有一个进程符合条件，从而严格论证只存在一个安全序列；论述任何偏离该顺序的行为都会导致安全检查受阻（即构成死锁风险，因为在这种偏离下安全算法无法找到一个安全的完成顺序）。\n4. 以单个整数的形式，报告此状态下不同安全序列的数量。\n\n将您的最终答案表示为不同安全序列的数量。无需四舍五入。", "solution": "该问题已经过验证，被认为是可靠、自洽、一致且定义明确的。我们可以开始求解。\n\n该问题要求使用银行家算法对一个系统状态进行死锁避免分析。我们已知进程数量 $n=4$（标记为 $P_0, P_1, P_2, P_3$），资源类型数量 $m=3$，总资源向量 $Total$，当前分配矩阵 $Allocation$，以及最大需求矩阵 $Max$。\n\n给定的数据是：\n$$\nTotal = \\begin{pmatrix} 5 \\\\ 5 \\\\ 4 \\end{pmatrix}\n$$\n$$\nAllocation = \n\\begin{pmatrix}\n1  3  0 \\\\\n1  0  2 \\\\\n1  2  0 \\\\\n1  0  1\n\\end{pmatrix}\n\\quad\nMax =\n\\begin{pmatrix}\n5  3  0 \\\\\n1  2  3 \\\\\n2  2  0 \\\\\n4  0  2\n\\end{pmatrix}\n$$\n\n设 $Allocation$ 和 $Max$ 矩阵的行分别表示为 $Allocation_i$ 和 $Max_i$，对应于进程 $P_i$。\n\n**任务1：推导出 $Need$ 矩阵和初始的 $Available$ 向量。**\n\n首先，我们计算 $Available$ 资源向量。它被定义为总资源减去当前所有已分配资源的总和。让我们先通过对 $Allocation$ 矩阵的各列求和来计算总已分配资源。\n$$\n\\sum_{i=0}^{3} Allocation_i = \\begin{pmatrix} 1+1+1+1 \\\\ 3+0+2+0 \\\\ 0+2+0+1 \\end{pmatrix} = \\begin{pmatrix} 4 \\\\ 5 \\\\ 3 \\end{pmatrix}\n$$\n那么，$Available$ 向量为：\n$$\nAvailable = Total - \\sum_{i=0}^{3} Allocation_i = \\begin{pmatrix} 5 \\\\ 5 \\\\ 4 \\end{pmatrix} - \\begin{pmatrix} 4 \\\\ 5 \\\\ 3 \\end{pmatrix} = \\begin{pmatrix} 5-4 \\\\ 5-5 \\\\ 4-3 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix}\n$$\n接下来，我们计算 $Need$ 矩阵，其中对于每个进程 $P_i$，$Need_i = Max_i - Allocation_i$。\n对于 $P_0$：$Need_0 = Max_0 - Allocation_0 = \\begin{pmatrix} 5  3  0 \\end{pmatrix} - \\begin{pmatrix} 1  3  0 \\end{pmatrix} = \\begin{pmatrix} 4  0  0 \\end{pmatrix}$\n对于 $P_1$：$Need_1 = Max_1 - Allocation_1 = \\begin{pmatrix} 1  2  3 \\end{pmatrix} - \\begin{pmatrix} 1  0  2 \\end{pmatrix} = \\begin{pmatrix} 0  2  1 \\end{pmatrix}$\n对于 $P_2$：$Need_2 = Max_2 - Allocation_2 = \\begin{pmatrix} 2  2  0 \\end{pmatrix} - \\begin{pmatrix} 1  2  0 \\end{pmatrix} = \\begin{pmatrix} 1  0  0 \\end{pmatrix}$\n对于 $P_3$：$Need_3 = Max_3 - Allocation_3 = \\begin{pmatrix} 4  0  2 \\end{pmatrix} - \\begin{pmatrix} 1  0  1 \\end{pmatrix} = \\begin{pmatrix} 3  0  1 \\end{pmatrix}$\n将这些行向量组合起来，得到 $Need$ 矩阵：\n$$\nNeed = \n\\begin{pmatrix}\n4  0  0 \\\\\n0  2  1 \\\\\n1  0  0 \\\\\n3  0  1\n\\end{pmatrix}\n$$\n\n**任务2：应用安全算法来确定该状态是否安全，并找出一个安全序列。**\n\n安全算法执行如下。我们初始化一个工作向量 $Work = Available$ 和一个长度为 $n$ 的布尔向量 $Finish$，其所有条目都设置为 false。\n初始状态：\n$Work = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix}$\n$Finish = \\begin{pmatrix} \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix}$\n\n我们寻找一个进程 $P_i$，满足 $Finish_i$ 为 false 且 $Need_i \\le Work$。当且仅当对于所有分量 $j$ 都有 $A_j \\le B_j$ 时，向量 $A \\le B$。\n\n**步骤1：** 我们将每个未完成进程的 $Need$ 向量与当前的 $Work$ 向量进行比较。\n- $P_0$: $Need_0 = \\begin{pmatrix} 4  0  0 \\end{pmatrix}$。$\\begin{pmatrix} 4  0  0 \\end{pmatrix} \\le \\begin{pmatrix} 1  0  1 \\end{pmatrix}$ 是否成立？不成立，因为 $4 > 1$。\n- $P_1$: $Need_1 = \\begin{pmatrix} 0  2  1 \\end{pmatrix}$。$\\begin{pmatrix} 0  2  1 \\end{pmatrix} \\le \\begin{pmatrix} 1  0  1 \\end{pmatrix}$ 是否成立？不成立，因为 $2 > 0$。\n- $P_2$: $Need_2 = \\begin{pmatrix} 1  0  0 \\end{pmatrix}$。$\\begin{pmatrix} 1  0  0 \\end{pmatrix} \\le \\begin{pmatrix} 1  0  1 \\end{pmatrix}$ 是否成立？成立，因为 $1 \\le 1$，$0 \\le 0$ 且 $0 \\le 1$。\n- $P_3$: $Need_3 = \\begin{pmatrix} 3  0  1 \\end{pmatrix}$。$\\begin{pmatrix} 3  0  1 \\end{pmatrix} \\le \\begin{pmatrix} 1  0  1 \\end{pmatrix}$ 是否成立？不成立，因为 $3 > 1$。\n\n只有进程 $P_2$ 满足条件。我们选择 $P_2$，模拟其完成，并释放其资源。\n$Work = Work + Allocation_2 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ 2 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 2 \\\\ 1 \\end{pmatrix}$。\n$Finish_2 = \\text{true}$。\n$Finish = \\begin{pmatrix} \\text{false}  \\text{false}  \\text{true}  \\text{false} \\end{pmatrix}$。\n\n**步骤2：** 我们用更新后的 $Work$ 向量在剩下的未完成进程（$P_0, P_1, P_3$）中重复搜索。\n$Work = \\begin{pmatrix} 2 \\\\ 2 \\\\ 1 \\end{pmatrix}$。\n- $P_0$: $Need_0 = \\begin{pmatrix} 4  0  0 \\end{pmatrix}$。$\\begin{pmatrix} 4  0  0 \\end{pmatrix} \\le \\begin{pmatrix} 2  2  1 \\end{pmatrix}$ 是否成立？不成立，因为 $4 > 2$。\n- $P_1$: $Need_1 = \\begin{pmatrix} 0  2  1 \\end{pmatrix}$。$\\begin{pmatrix} 0  2  1 \\end{pmatrix} \\le \\begin{pmatrix} 2  2  1 \\end{pmatrix}$ 是否成立？成立，因为 $0 \\le 2$，$2 \\le 2$ 且 $1 \\le 1$。\n- $P_3$: $Need_3 = \\begin{pmatrix} 3  0  1 \\end{pmatrix}$。$\\begin{pmatrix} 3  0  1 \\end{pmatrix} \\le \\begin{pmatrix} 2  2  1 \\end{pmatrix}$ 是否成立？不成立，因为 $3 > 2$。\n\n只有进程 $P_1$ 满足条件。我们选择 $P_1$。\n$Work = Work + Allocation_1 = \\begin{pmatrix} 2 \\\\ 2 \\\\ 1 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ 0 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 3 \\\\ 2 \\\\ 3 \\end{pmatrix}$。\n$Finish_1 = \\text{true}$。\n$Finish = \\begin{pmatrix} \\text{false}  \\text{true}  \\text{true}  \\text{false} \\end{pmatrix}$。\n\n**步骤3：** 我们继续处理进程 $P_0, P_3$。\n$Work = \\begin{pmatrix} 3 \\\\ 2 \\\\ 3 \\end{pmatrix}$。\n- $P_0$: $Need_0 = \\begin{pmatrix} 4  0  0 \\end{pmatrix}$。$\\begin{pmatrix} 4  0  0 \\end{pmatrix} \\le \\begin{pmatrix} 3  2  3 \\end{pmatrix}$ 是否成立？不成立，因为 $4 > 3$。\n- $P_3$: $Need_3 = \\begin{pmatrix} 3  0  1 \\end{pmatrix}$。$\\begin{pmatrix} 3  0  1 \\end{pmatrix} \\le \\begin{pmatrix} 3  2  3 \\end{pmatrix}$ 是否成立？成立，因为 $3 \\le 3$，$0 \\le 2$ 且 $1 \\le 3$。\n\n只有进程 $P_3$ 满足条件。我们选择 $P_3$。\n$Work = Work + Allocation_3 = \\begin{pmatrix} 3 \\\\ 2 \\\\ 3 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 4 \\\\ 2 \\\\ 4 \\end{pmatrix}$。\n$Finish_3 = \\text{true}$。\n$Finish = \\begin{pmatrix} \\text{false}  \\text{true}  \\text{true}  \\text{true} \\end{pmatrix}$。\n\n**步骤4：** 唯一剩下的进程是 $P_0$。\n$Work = \\begin{pmatrix} 4 \\\\ 2 \\\\ 4 \\end{pmatrix}$。\n- $P_0$: $Need_0 = \\begin{pmatrix} 4  0  0 \\end{pmatrix}$。$\\begin{pmatrix} 4  0  0 \\end{pmatrix} \\le \\begin{pmatrix} 4  2  4 \\end{pmatrix}$ 是否成立？成立，因为 $4 \\le 4$，$0 \\le 2$ 且 $0 \\le 4$。\n\n选择进程 $P_0$。\n$Work = Work + Allocation_0 = \\begin{pmatrix} 4 \\\\ 2 \\\\ 4 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ 3 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 5 \\\\ 5 \\\\ 4 \\end{pmatrix}$。注意，最终的 $Work$ 向量等于 $Total$ 资源向量，符合预期。\n$Finish_0 = \\text{true}$。\n$Finish = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{true}  \\text{true} \\end{pmatrix}$。\n\n由于 $Finish$ 向量中的所有条目都为 true，算法成功终止。该状态是安全的。找到的安全序列是 $\\langle P_2, P_1, P_3, P_0 \\rangle$。\n\n**任务3：论证只存在一个安全序列。**\n\n任务2中安全算法的逐步执行过程为安全序列的唯一性提供了论证。在构建序列的每个阶段，选择下一个进程都没有歧义。\n\n- **初始步骤：** 当 $Work = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix}$ 时，只有进程 $P_2$ 满足条件 $Need_i \\le Work$。$P_0$、$P_1$ 和 $P_3$ 的需求都超过了可用资源。因此，任何安全序列都必须以 $P_2$ 开始。任何其他起始选择都会导致安全检查立即失败，因为没有资源可以被授予。\n\n- **第二步：** 在 $P_2$ 概念上完成后，可用资源变为 $Work = \\begin{pmatrix} 2 \\\\ 2 \\\\ 1 \\end{pmatrix}$。在剩下的进程（$P_0, P_1, P_3$）中，只有 $P_1$ 的需求（$Need_1 = \\begin{pmatrix} 0  2  1 \\end{pmatrix}$）可以被当前的 $Work$ 向量满足。$P_0$ 和 $P_3$ 的需求过大。因此，任何安全序列中的第二个进程必须是 $P_1$。像 $\\langle P_2, P_0, \\dots \\rangle$ 或 $\\langle P_2, P_3, \\dots \\rangle$ 这样的序列是不可能的。\n\n- **第三步：** 在 $P_2$ 和 $P_1$ 完成后，$Work = \\begin{pmatrix} 3 \\\\ 2 \\\\ 3 \\end{pmatrix}$。在剩下的进程（$P_0, P_3$）中，只有 $P_3$ 的需求（$Need_3 = \\begin{pmatrix} 3  0  1 \\end{pmatrix}$）小于或等于 $Work$。$P_0$ 的需求不满足。因此，第三个进程必须是 $P_3$。\n\n- **最后一步：** 唯一剩下的进程是 $P_0$。它的需求可以被 $P_2, P_1$ 和 $P_3$ 释放的资源所满足。\n\n由于每一步的进程选择都是唯一确定的，因此安全算法的状态空间路径是唯一的。任何偏离这个特定顺序 $\\langle P_2, P_1, P_3, P_0 \\rangle$ 的行为都将导致一个状态，在该状态下，没有任何未完成的进程的需求能被可用资源满足，从而导致安全算法无法找到一个完整的序列。因此，只存在一个安全序列。\n\n**任务4：报告不同安全序列的数量。**\n\n根据任务3的严格论证，对于给定的系统状态，只存在一个可能的安全序列。\n不同安全序列的数量是 $1$。", "answer": "$$\n\\boxed{1}\n$$", "id": "3678954"}, {"introduction": "现在，让我们从分析者转变为系统设计者，不再是简单地检查一个给定的状态，而是通过设置系统参数来主动塑造系统的行为。你的任务是精确地选择一个值 $x$，以确保某个特定进程 $P_0$ 必须在任何安全序列中都最后完成。这个“逆向工程”问题要求你对 $Work$ 向量的演变和 $Need$ 向量的约束有全面的掌握，是检验你是否能从期望的结果出发，反向推理并设计系统状态的终极挑战。[@problem_id:3678969]", "problem": "考虑一个操作系统（OS）的资源分配系统，其中有两种资源类型，表示为 $R_1$ 和 $R_2$。有四个进程 $P_0, P_1, P_2, P_3$。总资源向量为\n$$\n\\mathbf{T} = \\begin{pmatrix} 14 \\\\ 9 \\end{pmatrix}.\n$$\n对于进程 $P_1, P_2, P_3$，当前分配矩阵 $\\mathbf{Allocation}$ 和最大需求矩阵 $\\mathbf{Max}$ 如下所示：\n- 对于 $P_1$：$\\mathbf{Allocation}_1 = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$，$\\mathbf{Max}_1 = \\begin{pmatrix} 3 \\\\ 3 \\end{pmatrix}$。\n- 对于 $P_2$：$\\mathbf{Allocation}_2 = \\begin{pmatrix} 3 \\\\ 2 \\end{pmatrix}$，$\\mathbf{Max}_2 = \\begin{pmatrix} 3 \\\\ 3 \\end{pmatrix}$。\n- 对于 $P_3$：$\\mathbf{Allocation}_3 = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$，$\\mathbf{Max}_3 = \\begin{pmatrix} 2 \\\\ 4 \\end{pmatrix}$。\n\n进程 $P_0$ 有一个固定的当前分配\n$$\n\\mathbf{Allocation}_0 = \\begin{pmatrix} 3 \\\\ 1 \\end{pmatrix},\n$$\n以及一个部分未指定的最大需求\n$$\n\\mathbf{Max}_0 = \\begin{pmatrix} 3 + x \\\\ 4 \\end{pmatrix},\n$$\n其中 $x$ 是一个非负整数设计参数，代表 $P_0$ 对资源 $R_1$ 的额外需求，需要由你来选择。\n\n银行家算法的安全性检查过程使用以下定义：\n- 对于每个进程 $P_i$，$ \\mathbf{Need}_i = \\mathbf{Max}_i - \\mathbf{Allocation}_i$。\n- $\\mathbf{Available} = \\mathbf{T} - \\sum_{i=0}^{3} \\mathbf{Allocation}_i$。\n- 工作向量 $\\mathbf{Work}$ 初始值为 $\\mathbf{Available}$，当一个进程 $P_i$ 在满足 $\\mathbf{Need}_i \\leq \\mathbf{Work}$（分量逐一比较）的条件下完成时，它会释放其已分配的资源 $\\mathbf{Allocation}_i$，使得 $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_i$。\n\n你的任务是选择最小的整数 $x$，使得在安全算法下，进程 $P_0$ 在任何安全序列中都必须最后完成。换句话说，对于任何一个安全序列的前缀，如果其中已完成的进程少于 $\\{P_1, P_2, P_3\\}$ 的全体，那么在该点尝试接着运行 $P_0$ 都会因为 $\\mathbf{Need}_0 \\nleq \\mathbf{Work}$ 而失败；只有在 $P_1, P_2, P_3$ 全部完成后，$\\mathbf{Need}_0 \\leq \\mathbf{Work}$ 才成立。通过以上基本定义进行推理，并明确分析 $\\mathbf{Work}$ 如何根据 $\\{P_1, P_2, P_3\\}$ 子集的分配情况演变，来验证你的选择。\n\n以 $x$ 的精确整数值的形式给出你的最终答案。无需四舍五入。无需单位。", "solution": "问题陈述被评估为有效。它内容完整、数学上一致，并且在操作系统中用于死锁避免的银行家算法标准框架内是适定的。所有必要的数据和定义都已提供。\n\n解决过程首先计算必要的状态矩阵和向量，然后将进程 $P_0$ 必须最后完成的条件形式化，最后求解满足此条件的参数 $x$ 的最小整数值。\n\n首先，我们使用定义 $\\mathbf{Need}_i = \\mathbf{Max}_i - \\mathbf{Allocation}_i$ 来计算每个进程的 $\\mathbf{Need}$ 矩阵。\n对于进程 $P_0$：\n$$\n\\mathbf{Need}_0 = \\mathbf{Max}_0 - \\mathbf{Allocation}_0 = \\begin{pmatrix} 3 + x \\\\ 4 \\end{pmatrix} - \\begin{pmatrix} 3 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} x \\\\ 3 \\end{pmatrix}\n$$\n对于进程 $P_1$：\n$$\n\\mathbf{Need}_1 = \\mathbf{Max}_1 - \\mathbf{Allocation}_1 = \\begin{pmatrix} 3 \\\\ 3 \\end{pmatrix} - \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}\n$$\n对于进程 $P_2$：\n$$\n\\mathbf{Need}_2 = \\mathbf{Max}_2 - \\mathbf{Allocation}_2 = \\begin{pmatrix} 3 \\\\ 3 \\end{pmatrix} - \\begin{pmatrix} 3 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\n对于进程 $P_3$：\n$$\n\\mathbf{Need}_3 = \\mathbf{Max}_3 - \\mathbf{Allocation}_3 = \\begin{pmatrix} 2 \\\\ 4 \\end{pmatrix} - \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}\n$$\n\n接下来，我们计算初始的 $\\mathbf{Available}$ 资源向量。\n已分配的资源总量是所有进程分配量的总和：\n$$\n\\sum_{i=0}^{3} \\mathbf{Allocation}_i = \\mathbf{Allocation}_0 + \\mathbf{Allocation}_1 + \\mathbf{Allocation}_2 + \\mathbf{Allocation}_3 = \\begin{pmatrix} 3 \\\\ 1 \\end{pmatrix} + \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} + \\begin{pmatrix} 3 \\\\ 2 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 9 \\\\ 6 \\end{pmatrix}\n$$\n可用资源是总资源减去已分配的资源：\n$$\n\\mathbf{Available} = \\mathbf{T} - \\sum_{i=0}^{3} \\mathbf{Allocation}_i = \\begin{pmatrix} 14 \\\\ 9 \\end{pmatrix} - \\begin{pmatrix} 9 \\\\ 6 \\end{pmatrix} = \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix}\n$$\n安全算法以工作向量 $\\mathbf{Work} = \\mathbf{Available}$ 开始。\n\n“$P_0$ 在任何安全序列中都必须最后完成”的条件意味着两件事：\n1. 对于 $\\{P_1, P_2, P_3\\}$ 的任意真子集已完成的任何状态，$P_0$ 都不能运行。也就是说，在任何这些中间阶段，$\\mathbf{Need}_0 \\nleq \\mathbf{Work}$。\n2. 在 $\\{P_1, P_2, P_3\\}$ 中的所有进程都完成后，$P_0$ 必须能够运行。也就是说，在这个最后阶段，$\\mathbf{Need}_0 \\leq \\mathbf{Work}$。\n\n让我们分析第一个条件。工作向量 $\\mathbf{Work}$ 随着进程的完成而演变。设 $S$ 是 $\\{P_1, P_2, P_3\\}$ 的一个子集，代表已完成的进程。相应的工作向量为 $\\mathbf{Work}_S = \\mathbf{Available} + \\sum_{i \\in S} \\mathbf{Allocation}_i$。$P_0$ 不能运行的条件是对于所有真子集 $S \\subset \\{P_1, P_2, P_3\\}$，都有 $\\mathbf{Need}_0 \\nleq \\mathbf{Work}_S$。我们有 $\\mathbf{Need}_0 = \\begin{pmatrix} x \\\\ 3 \\end{pmatrix}$，其中 $x \\ge 0$ 是一个整数。条件 $\\mathbf{Need}_0 \\nleq \\mathbf{Work}_S$ 意味着 $\\mathbf{Need}_0$ 的第一个分量大于 $\\mathbf{Work}_S$ 的第一个分量，或者第二个分量大于 $\\mathbf{Work}_S$ 的第二个分量。\n\n让我们检查所有真子集 $S \\subset \\{P_1, P_2, P_3\\}$ 的 $\\mathbf{Work}_S$ 的可能值：\n- $S = \\emptyset$: $\\mathbf{Work}_{\\emptyset} = \\mathbf{Available} = \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix}$。\n  条件是 $\\begin{pmatrix} x \\\\ 3 \\end{pmatrix} \\nleq \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix}$。这意味着 $x > 5$ 或 $3 > 3$。由于 $3 > 3$ 不成立，所以我们必须有 $x > 5$。\n- $S = \\{P_1\\}$: $\\mathbf{Work}_{\\{P_1\\}} = \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix} + \\mathbf{Allocation}_1 = \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix} + \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 7 \\\\ 4 \\end{pmatrix}$。\n  条件是 $\\begin{pmatrix} x \\\\ 3 \\end{pmatrix} \\nleq \\begin{pmatrix} 7 \\\\ 4 \\end{pmatrix}$。这意味着 $x > 7$ 或 $3 > 4$。由于 $3 > 4$ 不成立，因此我们必须有 $x > 7$。\n- $S = \\{P_2\\}$: $\\mathbf{Work}_{\\{P_2\\}} = \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix} + \\mathbf{Allocation}_2 = \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix} + \\begin{pmatrix} 3 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 8 \\\\ 5 \\end{pmatrix}$。\n  条件是 $\\begin{pmatrix} x \\\\ 3 \\end{pmatrix} \\nleq \\begin{pmatrix} 8 \\\\ 5 \\end{pmatrix}$。这意味着 $x > 8$。\n- $S = \\{P_3\\}$: $\\mathbf{Work}_{\\{P_3\\}} = \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix} + \\mathbf{Allocation}_3 = \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 6 \\\\ 5 \\end{pmatrix}$。\n  条件要求 $x > 6$。\n- $S = \\{P_1, P_2\\}$: $\\mathbf{Work}_{\\{P_1, P_2\\}} = \\mathbf{Work}_{\\emptyset} + \\mathbf{Allocation}_1 + \\mathbf{Allocation}_2 = \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix} + \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} + \\begin{pmatrix} 3 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 10 \\\\ 6 \\end{pmatrix}$。\n  条件要求 $x > 10$。\n- $S = \\{P_1, P_3\\}$: $\\mathbf{Work}_{\\{P_1, P_3\\}} = \\mathbf{Work}_{\\emptyset} + \\mathbf{Allocation}_1 + \\mathbf{Allocation}_3 = \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix} + \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 8 \\\\ 6 \\end{pmatrix}$。\n  条件要求 $x > 8$。\n- $S = \\{P_2, P_3\\}$: $\\mathbf{Work}_{\\{P_2, P_3\\}} = \\mathbf{Work}_{\\emptyset} + \\mathbf{Allocation}_2 + \\mathbf{Allocation}_3 = \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix} + \\begin{pmatrix} 3 \\\\ 2 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 9 \\\\ 7 \\end{pmatrix}$。\n  条件要求 $x > 9$。\n\n为了让 $P_0$ 在所有这些中间阶段都被阻塞，$x$ 必须同时满足所有推导出的不等式：\n$$\nx > 5, \\quad x > 7, \\quad x > 8, \\quad x > 6, \\quad x > 10, \\quad x > 8, \\quad x > 9\n$$\n为了满足所有这些条件，$x$ 必须大于这些下界的最大值：\n$$\nx > \\max\\{5, 7, 8, 6, 10, 8, 9\\} = 10\n$$\n所以，第一个条件要求 $x > 10$。\n\n现在，我们分析第二个条件：$P_0$ 必须在 $P_1, P_2, P_3$ 全部完成后能够运行。\n$P_1, P_2, P_3$ 完成后的工作向量是：\n$$\n\\mathbf{Work}_{\\{P_1, P_2, P_3\\}} = \\mathbf{Available} + \\mathbf{Allocation}_1 + \\mathbf{Allocation}_2 + \\mathbf{Allocation}_3 = \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix} + \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} + \\begin{pmatrix} 3 \\\\ 2 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 11 \\\\ 8 \\end{pmatrix}\n$$\n$P_0$ 能够运行的条件是 $\\mathbf{Need}_0 \\leq \\mathbf{Work}_{\\{P_1, P_2, P_3\\}}$：\n$$\n\\begin{pmatrix} x \\\\ 3 \\end{pmatrix} \\leq \\begin{pmatrix} 11 \\\\ 8 \\end{pmatrix}\n$$\n这给出了两个分量不等式：$x \\leq 11$ 和 $3 \\leq 8$。第二个不等式 $3 \\leq 8$ 是成立的。因此，我们必须满足 $x \\leq 11$。\n\n结合关于整数 $x$ 的两个条件：\n1. $x > 10$\n2. $x \\leq 11$\n\n满足 $10  x \\leq 11$ 的唯一整数值是 $x = 11$。由于只有一个可能的整数解，它必然是最小的。\n\n我们还应该确保对于进程集合 $\\{P_1, P_2, P_3\\}$ 至少存在一个安全序列。开始时，$\\mathbf{Work} = \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix}$。\n- $\\mathbf{Need}_1 = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} \\leq \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix}$ (成立)\n- $\\mathbf{Need}_2 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} \\leq \\begin{pmatrix} 5 \\\\ 3 \\endpmatrix}$ (成立)\n- $\\mathbf{Need}_3 = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} \\leq \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix}$ (成立)\n所有这三个进程都可以被选择首先运行。由于它们的需要可以被初始可用资源满足，所以 $\\{P_1, P_2, P_3\\}$ 的任何执行顺序都将是安全的，因为释放资源只会增加 $\\mathbf{Work}$ 向量并满足更多的需求。因此，对于这个子集存在安全序列，我们对所有中间 $\\mathbf{Work}_S$ 向量的分析对于任何这样的序列都是有效的。\n\n$x$ 的最小整数值为 11。", "answer": "$$\\boxed{11}$$", "id": "3678969"}]}