{"hands_on_practices": [{"introduction": "第一个实践将我们的理解建立在死锁的基本条件之上。通过分析一个由进程和打印机组成的简单系统，你将推导出一个保证死锁不可能发生的硬性规则。这个练习促使你思考资源分配的“最坏情况”，并展示了仔细的资源配置如何成为最有效的死锁预防形式。[@problem_id:3633188]", "problem": "考虑一个由$m$台相同打印机和$n$个进程组成的单一资源类。每个进程在其生命周期内最多可能需要$2$台打印机。系统遵循四个Coffman死锁条件：互斥、占有并等待、不可抢占和循环等待。进程一次请求一台打印机，并且在获得完成所需的所有打印机之前，不会释放其持有的任何打印机。假设$m \\geq 2$，以确保每个进程的最大需求在物理上是可实现的。使用单一资源类型的死锁系统模型和资源分配图（RAG）的概念从第一性原理进行推理。\n\n任务：\n- 仅使用上述核心定义（不借助任何已证明的快捷准则），推导出一个关于$m$和$n$的参数化条件。在该条件下，当每个进程最多可需要$2$台打印机时，最坏情况下可能出现死锁状态。\n- 然后，将您的条件具体化，计算当$n=3$，$n=4$和$n=5$时，使死锁不可能发生的$m$的最小值。按$n=3$，$n=4$，$n=5$的顺序提供您计算出的三个$m$的最小值。\n\n无需四舍五入。最终答案以三个整数表示。", "solution": "问题要求在一个包含$n$个进程和$m$个相同实例的单一资源类系统中，推导出现死锁可能性的条件。每个进程最多需要$2$个资源实例。推导必须从第一性原理出发，使用资源分配图（RAG）的概念。\n\n首先，让我们建立基本原则。死锁是一种状态，其中一组进程被阻塞，因为每个进程都持有一个资源，并等待该集合中另一个进程持有的另一个资源。对于单一资源类型的系统，资源分配图中存在环路是发生死锁的充分必要条件。如果存在一组等待进程$\\{P_1, P_2, \\dots, P_k\\}$，使得$P_1$等待$P_2$持有的资源，$P_2$等待$P_3$持有的资源，...，而$P_k$等待$P_1$持有的资源，则存在环路。\n\n给定四个Coffman条件成立：\n1.  互斥：每台打印机一次只能由一个进程使用。这是问题固有的。\n2.  占有并等待：进程在等待额外打印机时，会继续持有已分配给它们的打印机。问题陈述明确了此行为。\n3.  不可抢占：打印机不能被强制从进程中收回。这是假设的。\n4.  循环等待：这是我们必须分析的条件。当且仅当循环等待可能发生时，死锁才可能发生。\n\n为了确定可能发生死锁的条件，我们必须识别出可能导致这种循环等待的资源分配的最坏情况。就资源分配而言，一个进程可以处于三种状态之一：持有$0$台打印机、持有$1$台打印机或持有$2$台打印机。持有$2$台打印机的进程其最大需求已得到满足，最终将完成并释放其资源。持有$0$台打印机的进程对死锁的“占有并等待”方面没有贡献。因此，进程的关键状态是持有一台打印机并等待第二台。\n\n系统的最坏情况，即死锁可能性最大化的情况，发生在尽可能多的进程处于此关键状态时。让我们假设系统中所有$n$个进程都逐一尝试获取它们的资源。导致最高资源争用的事件序列如下：$n$个进程中的每一个都请求并被授予一台打印机。\n\n为了使该状态可达，系统必须有足够的打印机来为$n$个进程中的每一个分配一台。如果打印机总数$m$至少等于进程数$n$，这是可能的。如果$m  n$，那么只有$m$个进程可以同时持有一台打印机。\n\n让我们分析$m$和$n$之间关系的两种情况。\n\n情况1：$m \\le n$。\n在这种情况下，死锁是可能的。为了证明这一点，我们构造一个导致死锁的事件序列。\n设参与死锁的进程数量为$k = m$。请注意，$k \\le n$。\n1.  前$m$个进程，$P_1, P_2, \\dots, P_m$，每个都请求一台打印机。\n2.  操作系统批准了这些请求。假设进程$P_i$被分配了打印机$R_i$。\n此时，所有$m$台打印机都已分配。可用打印机数量为$m - m = 0$。\n3.  现在，这$m$个进程中的每一个都请求它的第二台打印机。为了形成一个环路，我们可以想象以下请求：\n    - $P_1$请求打印机$R_2$，该打印机由$P_2$持有。\n    - $P_2$请求打印机$R_3$，该打印机由$P_3$持有。\n    - ...\n    - $P_{m-1}$请求打印机$R_m$，该打印机由$P_m$持有。\n    - $P_m$请求打印机$R_1$，该打印机由$P_1$持有。\n现在存在一个循环等待条件：$P_1 \\to R_2 \\to P_2 \\to \\dots \\to P_m \\to R_1 \\to P_1$。由于没有可用的打印机，这些请求都无法被满足。进程$P_1, \\dots, P_m$处于死锁状态。由于这样的事件序列是可能的，如果$m \\le n$，则死锁是可能的。\n\n情况2：$m > n$。\n在这种情况下，死锁是不可能的。为了证明这一点，我们将表明无论资源分配状态如何，总有至少一个进程可以完成，这意味着系统总是处于安全状态。\n考虑任何任意的资源分配状态。设$n_1$是持有$1$台打印机的进程数，$n_0$是持有$0$台打印机的进程数。任何持有$2$台打印机的进程都可以完成，所以我们不将它们视为潜在死锁的一部分。我们有$n_0 + n_1 = n$。\n已分配的打印机总数为$n_1$。\n可用打印机的数量为$A = m - n_1$。\n持有$1$台打印机的进程需要再$1$台才能完成。持有$0$台打印机的进程需要$1$或$2$台。死锁状态是没有任何进程的请求可以被满足的状态。这将要求每个进程的剩余需求都大于可用打印机的数量。\n对于持有$1$台打印机的进程，其剩余需求为$1$。要使其被阻塞，必须满足$1 > A$，这意味着$A=0$。\n这蕴含了$m - n_1 = 0$，或$m = n_1$。\n然而，我们有条件$m > n$。我们也知道$n_1 \\le n$。\n这导致了一个矛盾：$n_1 = m > n \\ge n_1$，可简化为$n_1 > n_1$。这是不可能的。\n因此，当有进程持有$1$个资源时，$A=0$不成立。让我们将其形式化：由$m > n$和$n \\ge n_1$可得$m > n_1$。由于$m$和$n_1$是整数，这等价于$m \\ge n_1 + 1$。\n可用打印机的数量为$A = m - n_1 \\ge (n_1 + 1) - n_1 = 1$。\n所以，总是有至少一台打印机可用。这台打印机可以分配给任何一个等待第二台打印机的$n_1$个进程。一旦那个进程收到了它的第二台打印机，它的最大需求$2$就得到了满足，可以运行至完成。完成后，它会释放其持有的两台打印机。可用打印机的数量增加到$A - 1 + 2 = A + 1$，等待进程的数量减少。这个过程可以重复进行，直到所有进程都完成。因此，如果$m > n$，死锁永远不会发生。\n\n推导条件的总结：\n- 当且仅当$m \\le n$时，死锁是可能的。\n- 当且仅当$m > n$时，死锁是不可能的。\n\n现在，我们将此结果具体化，以计算对于给定的$n$值，使死锁不可能发生的$m$的最小值。\n死锁不可能的条件是$m > n$。对于给定的整数$n$，满足此不等式的最小整数$m$是$m = n+1$。\n\n对于$n=3$：\n使死锁不可能发生的$m$的最小值为$m = 3+1 = 4$。\n\n对于$n=4$：\n使死锁不可能发生的$m$的最小值为$m = 4+1 = 5$。\n\n对于$n=5$：\n使死锁不可能发生的$m$的最小值为$m = 5+1 = 6$。\n\n三个$m$的最小值分别为$4$，$5$和$6$，分别对应于$n=3$，$n=4$和$n=5$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4  5  6\n\\end{pmatrix}\n}\n$$", "id": "3633188"}, {"introduction": "从静态预防转向动态的死锁避免，我们现在将探讨银行家算法。该算法通过模拟是否存在一条能让所有进程完成的路径来定义“安全状态”。这个问题挑战你正确应用该算法，并识别出一种常见但有缺陷的简化方法中的错误，从而巩固你对何为真正安全状态的理解。[@problem_id:3633110]", "problem": "考虑一个包含 $n$ 个进程和 $m$ 种资源类型的死锁系统模型。每个系统状态由三个矩阵或向量来表征：每个进程的 $Allocation$ 矩阵（当前持有量）、每个进程的 $Max$ 矩阵（已声明的最大需求量），以及系统的 $Available$ 向量（当前可用单元数）。一个简陋的检测器会错误地判断安全性，它只检查是否存在一个进程，其声明的最大需求向量按分量小于或等于当前的 $Available$ 向量；也就是说，如果在初始状态下，对于所有进程 $i$ 都有 $Max_i \\nleq Available$，它就会宣布该状态为不安全，而忽略了当前的持有量。\n\n下面的哪个选项提供了一个具体的实例（$n = 3$ 且 $m = 2$），在该实例中，根据银行家算法使用的正确安全概念，状态是安全的，但对于上述简陋的检测器来说却显得不安全？对于每个选项，每个进程的数据以 $P_1$、$P_2$、$P_3$ 的形式列出，其中 $Allocation$ 和 $Max$ 是有序对，$Available$ 也是一个有序对。\n\n- A. $Allocation$: $P_1:(1,2)$, $P_2:(3,0)$, $P_3:(1,1)$; $Max$: $P_1:(3,2)$, $P_2:(3,2)$, $P_3:(4,3)$; $Available:(2,2)$.\n\n- B. $Allocation$: $P_1:(1,0)$, $P_2:(2,0)$, $P_3:(0,2)$; $Max$: $P_1:(1,1)$, $P_2:(3,3)$, $P_3:(3,3)$; $Available:(1,1)$.\n\n- C. $Allocation$: $P_1:(2,0)$, $P_2:(0,1)$, $P_3:(0,0)$; $Max$: $P_1:(3,1)$, $P_2:(3,2)$, $P_3:(2,2)$; $Available:(3,1)$.\n\n- D. $Allocation$: $P_1:(2,1)$, $P_2:(1,1)$, $P_3:(0,0)$; $Max$: $P_1:(3,2)$, $P_2:(2,2)$, $P_3:(1,1)$; $Available:(1,0)$.\n\n选择唯一正确的选项。", "solution": "正确的安全概念源于银行家算法。死锁系统模型的基本定义如下：\n\n- 对于每个进程 $P_i$，其剩余需求（通常称为“need”）由以下公式定义\n$$\nNeed_i = Max_i - Allocation_i,\n$$\n按每种资源类型逐分量计算。\n- 如果存在一个进程的排序（一个安全序列）$(Q_1, Q_2, \\dots, Q_n)$，使得从 $Work = Available$ 开始，对于序列中的每个 $Q_k$，\n$$\nNeed_{Q_k} \\le Work,\n$$\n然后该进程可以完成并释放其持有的资源，从而\n$$\nWork \\leftarrow Work + Allocation_{Q_k},\n$$\n之后再继续处理序列中的下一个进程，则状态是安全的。所有关系都应在 $m$ 种资源类型上逐分量解释。\n\n问题描述中的简陋检测器是错误的，因为它忽略了当前的持有量，只检查初始时是否存在某个进程满足 $Max_i \\le Available$。这错误地将声明的最大值视为即时需求，并且没有认识到进程可能已经持有了足以完成任务的资源，或者一个进程的完成会释放资源，从而使其他进程能够完成。\n\n我们现在使用基于原则的定义来分析每个选项。\n\n选项 A：\n- 数据：$Allocation$: $P_1:(1,2)$, $P_2:(3,0)$, $P_3:(1,1)$; $Max$: $P_1:(3,2)$, $P_2:(3,2)$, $P_3:(4,3)$; $Available:(2,2)$.\n- 计算 $Need$：\n$$\nNeed_1 = (3,2) - (1,2) = (2,0),\\quad\nNeed_2 = (3,2) - (3,0) = (0,2),\\quad\nNeed_3 = (4,3) - (1,1) = (3,2).\n$$\n- 从 $Work = (2,2)$ 开始。\n- 检查 $P_1$：$Need_1 = (2,0) \\le (2,2)$，所以 $P_1$ 可以完成。更新\n$$\nWork \\leftarrow (2,2) + Allocation_1 = (2,2) + (1,2) = (3,4).\n$$\n- 检查 $P_2$：$Need_2 = (0,2) \\le (3,4)$，所以 $P_2$ 可以完成。更新\n$$\nWork \\leftarrow (3,4) + Allocation_2 = (3,4) + (3,0) = (6,4).\n$$\n- 检查 $P_3$：$Need_3 = (3,2) \\le (6,4)$，所以 $P_3$ 可以完成。更新\n$$\nWork \\leftarrow (6,4) + Allocation_3 = (6,4) + (1,1) = (7,5).\n$$\n- 所有进程可以按序列 $(P_1, P_2, P_3)$ 完成；该状态是安全的。\n- 简陋的检测器：它在初始时测试 $Max_i \\le Available$。我们有\n$$\n(3,2) \\nleq (2,2),\\quad (3,2) \\nleq (2,2),\\quad (4,3) \\nleq (2,2).\n$$\n开始时没有进程满足 $Max_i \\le Available$，因此简陋的检测器宣布该状态为不安全。所以，选项A在银行家算法下是安全的，但对简陋的检测器来说是不安全的。结论：正确。\n\n选项 B：\n- 数据：$Allocation$: $P_1:(1,0)$, $P_2:(2,0)$, $P_3:(0,2)$; $Max$: $P_1:(1,1)$, $P_2:(3,3)$, $P_3:(3,3)$; $Available:(1,1)$.\n- 计算 $Need$：\n$$\nNeed_1 = (1,1) - (1,0) = (0,1),\\quad\nNeed_2 = (3,3) - (2,0) = (1,3),\\quad\nNeed_3 = (3,3) - (0,2) = (3,1).\n$$\n- 从 $Work = (1,1)$ 开始。\n- 初始时，只有 $P_1$ 满足 $Need_1 \\le Work$，因为 $(0,1) \\le (1,1)$，而 $(1,3) \\nleq (1,1)$ 且 $(3,1) \\nleq (1,1)$。\n- 完成 $P_1$ 并更新\n$$\nWork \\leftarrow (1,1) + Allocation_1 = (1,1) + (1,0) = (2,1).\n$$\n- 当 $Work = (2,1)$ 时，检查剩余进程：\n$$\nNeed_2 = (1,3) \\nleq (2,1),\\quad Need_3 = (3,1) \\nleq (2,1).\n$$\n- 没有其他进程可以完成；算法找不到安全序列。该状态是不安全的。\n- 简陋的检测器：它检查初始时是否有某个 $Max_i \\le Available$。这里，\n$$\n(1,1) \\le (1,1) \\text{ 对于 } P_1,\n$$\n所以简陋的检测器会宣布状态为安全。这是一个方向相反的错误分类。选项B不符合所要求的属性。结论：不正确。\n\n选项 C：\n- 数据：$Allocation$: $P_1:(2,0)$, $P_2:(0,1)$, $P_3:(0,0)$; $Max$: $P_1:(3,1)$, $P_2:(3,2)$, $P_3:(2,2)$; $Available:(3,1)$.\n- 计算 $Need$：\n$$\nNeed_1 = (3,1) - (2,0) = (1,1),\\quad\nNeed_2 = (3,2) - (0,1) = (3,1),\\quad\nNeed_3 = (2,2) - (0,0) = (2,2).\n$$\n- 从 $Work = (3,1)$ 开始。\n- $P_1$ 可以完成，因为 $(1,1) \\le (3,1)$。更新\n$$\nWork \\leftarrow (3,1) + (2,0) = (5,1).\n$$\n- 当 $Work = (5,1)$ 时，$P_2$ 可以完成，因为 $(3,1) \\le (5,1)$。更新\n$$\nWork \\leftarrow (5,1) + (0,1) = (5,2).\n$$\n- 当 $Work = (5,2)$ 时，$P_3$ 可以完成，因为 $(2,2) \\le (5,2)$。更新\n$$\nWork \\leftarrow (5,2) + (0,0) = (5,2).\n$$\n- 所有进程都可以完成；该状态是安全的。\n- 简陋的检测器：初始时，\n$$\nMax_1 = (3,1) \\le (3,1),\n$$\n所以简陋的检测器也会宣布状态为安全。该选项对于简陋的检测器来说并非不安全。结论：不正确。\n\n选项 D：\n- 数据：$Allocation$: $P_1:(2,1)$, $P_2:(1,1)$, $P_3:(0,0)$; $Max$: $P_1:(3,2)$, $P_2:(2,2)$, $P_3:(1,1)$; $Available:(1,0)$.\n- 计算 $Need$：\n$$\nNeed_1 = (3,2) - (2,1) = (1,1),\\quad\nNeed_2 = (2,2) - (1,1) = (1,1),\\quad\nNeed_3 = (1,1) - (0,0) = (1,1).\n$$\n- 从 $Work = (1,0)$ 开始。\n- 对于所有三个进程，\n$$\n(1,1) \\nleq (1,0),\n$$\n所以没有进程可以完成。不存在安全序列；该状态是不安全的。\n- 简陋的检测器：初始时，对于每个进程 $i$，\n$$\nMax_i \\nleq (1,0),\n$$\n所以它也会宣布状态为不安全。该选项不满足所要求的属性。结论：不正确。\n\n结论：只有选项A提供了一个在银行家算法下是安全的，但对于错误地在初始状态下比较 $Max$ 和 $Available$ 的简陋检测器来说却是不安全的状态。", "answer": "$$\\boxed{A}$$", "id": "3633110"}, {"introduction": "当预防和避免策略不切实际时，系统会采用死锁检测和恢复的手段。这最后一个实践提出了一个已经发生死锁的场景，并通过等待图（Wait-For Graph）将其可视化。你的任务是扮演操作系统恢复管理器的角色，创建一个模型，以最小的可能代价打破所有循环，将一个复杂的操作系统问题转化为一个具体的优化任务。[@problem_id:3633125]", "problem": "一个操作系统 (OS) 在一个每种资源类型都只有一个实例的系统上使用死锁检测。在这种情况下，存在死锁当且仅当等待图 (WFG) 中存在一个有向环。当检测到死锁时，恢复策略是中止一个或多个进程，其中中止进程 $P_i$ 会导致损失 $w_i$ 个单位的工作量。目标是设计一个合理的恢复策略，在保证解决死锁的同时，最小化总工作量损失。仅使用 WFG 中死锁的定义和环的概念，构建一个数学模型，该模型选择要中止的进程，以便以最小的总工作量损失消除所有死锁，然后在下面的具体系统上对其进行评估。\n\n该 WFG 有 $6$ 个进程 $P_1, P_2, P_3, P_4, P_5, P_6$，其边集为\n$$\nE \\;=\\; \\{(P_1 \\to P_2),\\; (P_2 \\to P_3),\\; (P_3 \\to P_1),\\; (P_3 \\to P_4),\\; (P_4 \\to P_5),\\; (P_5 \\to P_3),\\; (P_2 \\to P_4),\\; (P_4 \\to P_2),\\; (P_5 \\to P_6),\\; (P_6 \\to P_5)\\}.\n$$\n每个进程的工作量损失权重为\n$$\nw_1 = 7,\\quad w_2 = 3,\\quad w_3 = 6,\\quad w_4 = 2,\\quad w_5 = 5,\\quad w_6 = 4.\n$$\n\n任务：\n- 以单实例资源死锁的 WFG 环特征作为唯一的基本事实，定义二进制决策变量并建立一个优化模型，该模型体现了“中止一个与每个有向环都相交的进程集合”的策略，同时最小化总工作量损失。\n- 找出给定 WFG 中的所有简单有向环。\n- 对于给定的 $w_i$ 求解该优化模型，以获得最小的总工作量损失。将最终答案表示为一个等于最小总工作量损失（以工作单位计）的数字。无需四舍五入。", "solution": "我们从单实例资源的基本特征出发：在等待图 (WFG) 中，存在死锁当且仅当存在一个有向环。因此，要消除所有死锁，其充要条件是在每个有向环上至少中止一个进程。我们寻求的策略必须选择一个与每个有向环都相交的进程子集，同时最小化总工作量损失。\n\n建模框架。对于每个进程 $P_i$，定义一个二进制决策变量 $x_i \\in \\{0,1\\}$，其中 $x_i = 1$ 表示进程 $P_i$ 被中止，$x_i = 0$ 表示进程 $P_i$ 未被中止。总工作量损失为\n$$\nL(x) \\;=\\; \\sum_{i=1}^{6} w_i x_i.\n$$\n为了保证 WFG 中的每个有向环 $C$ 都被打破，我们必须要求\n$$\n\\sum_{P_i \\in C} x_i \\;\\ge\\; 1\n$$\n对于每个有向环 $C$，因为必须中止该环上的至少一个进程才能打破它。因此，优化模型是以下二进制整数规划：\n$$\n\\min_{x_1,\\dots,x_6 \\in \\{0,1\\}} \\;\\; \\sum_{i=1}^{6} w_i x_i\n\\quad \\text{约束条件为} \\quad \\sum_{P_i \\in C_k} x_i \\ge 1 \\;\\; \\text{对于 WFG 中的所有有向环 } C_k.\n$$\n\n枚举环。根据边集\n$$\nE \\;=\\; \\{(P_1 \\to P_2),\\; (P_2 \\to P_3),\\; (P_3 \\to P_1),\\; (P_3 \\to P_4),\\; (P_4 \\to P_5),\\; (P_5 \\to P_3),\\; (P_2 \\to P_4),\\; (P_4 \\to P_2),\\; (P_5 \\to P_6),\\; (P_6 \\to P_5)\\},\n$$\n简单有向环为：\n- $C_1 = \\{P_1, P_2, P_3\\}$ 通过 $P_1 \\to P_2 \\to P_3 \\to P_1$，\n- $C_2 = \\{P_3, P_4, P_5\\}$ 通过 $P_3 \\to P_4 \\to P_5 \\to P_3$，\n- $C_3 = \\{P_2, P_4\\}$ 通过 $P_2 \\to P_4 \\to P_2$，\n- $C_4 = \\{P_5, P_6\\}$ 通过 $P_5 \\to P_6 \\to P_5$。\n\n任何更大的有向环必然是这些简单环的组合，并且通过要求每个简单环至少中止一个进程的约束，已经覆盖了这些情况。\n\n因此，约束条件变为：\n$$\n\\begin{aligned}\nx_1 + x_2 + x_3 \\ge 1 \\text{(环 } C_1\\text{)},\\\\\nx_3 + x_4 + x_5 \\ge 1 \\text{(环 } C_2\\text{)},\\\\\nx_2 + x_4 \\ge 1 \\text{(环 } C_3\\text{)},\\\\\nx_5 + x_6 \\ge 1 \\text{(环 } C_4\\text{)}.\n\\end{aligned}\n$$\n目标函数为，其中 $w_1 = 7$, $w_2 = 3$, $w_3 = 6$, $w_4 = 2$, $w_5 = 5$, $w_6 = 4$：\n$$\n\\min \\; 7x_1 + 3x_2 + 6x_3 + 2x_4 + 5x_5 + 4x_6.\n$$\n\n通过结构化推理求解。我们寻求这些环的一个最小权重命中集。观察到 $x_4$ 的成本很低，为 $w_4 = 2$，并且它同时有助于满足 $C_2$ 和 $C_3$ 的约束。然而，无论 $x_4$ 取何值，环 $C_1$ 和环 $C_4$ 仍然需要被打破。\n\n我们考虑以下组合：\n\n- 选择 $x_5 = 1$ 以满足 $C_4$，成本为 $5$；然后为了满足 $C_1$ 和 $C_3$，最便宜的方法是选择 $x_2 = 1$（成本为 $3$），这也满足了 $C_1$ 和 $C_3$。$x_2 = 1$ 的选择本身并不能满足 $C_2$，但由于我们已经选择 $x_5 = 1$ 满足了 $C_2$，因此所有约束都得到满足。总成本为 $5 + 3 = 8$。\n\n- 或者，选择 $x_6 = 1$（成本为 $4$）以满足 $C_4$。这样，$C_2$ 仍需被打破，$C_1$ 和 $C_3$ 也需要被覆盖。一个低成本的方法是设置 $x_4 = 1$（成本为 $2$）来打破 $C_2$ 和 $C_3$，并设置 $x_2 = 1$（成本为 $3$）来打破 $C_1$；总成本为 $4 + 2 + 3 = 9$。\n\n- 考虑使用 $x_3 = 1$（成本为 $6$）来同时打破 $C_1$ 和 $C_2$。这没有打破 $C_3$ 或 $C_4$，因此我们还必须为 $C_3$ 选择 $x_2 = 1$ 或 $x_4 = 1$，为 $C_4$ 选择 $x_5 = 1$ 或 $x_6 = 1$。最便宜的补全方案是 $x_4 = 1$ 和 $x_6 = 1$，总成本为 $6 + 2 + 4 = 12$，比 $8$ 更差。\n\n- 考虑使用 $x_4 = 1$（成本为 $2$）来打破 $C_2$ 和 $C_3$，然后以最小成本覆盖 $C_1$ 和 $C_4$。对于 $C_1$，最便宜的是 $x_2 = 1$（成本为 $3$），对于 $C_4$，最便宜的是 $x_6 = 1$（成本为 $4$）。总成本为 $2 + 3 + 4 = 9$，同样比 $8$ 更差。\n\n我们现在论证成本为 $8$ 的解 $\\{x_2 = 1, x_5 = 1\\}$ 的最优性。任何可行解都必须打破 $C_4$，这要求 $x_5$ 或 $x_6$ 中至少有一个为 $1$，成本至少为 $\\min\\{5,4\\} = 4$。如果选择 $x_6 = 1$（成本为 $4$），那么 $C_2$ 必须由 $\\{x_3, x_4, x_5\\}$ 中的一个打破，$C_1$ 必须由 $\\{x_1, x_2, x_3\\}$ 中的一个打破，并且 $C_3$ 必须由 $\\{x_2, x_4\\}$ 中的一个打破。同时覆盖 $C_2$ 和 $C_3$ 的最便宜组合是 $x_4 = 1$（成本为 $2$），然后 $C_1$ 至少需要 $x_2 = 1$（成本为 $3$）或 $x_3 = 1$（成本为 $6$）或 $x_1 = 1$（成本为 $7$），导致总成本至少为 $4 + 2 + 3 = 9$。如果转而选择 $x_5 = 1$（成本为 $5$），那么 $C_2$ 已经被打破，我们仍必须打破 $C_1$ 和 $C_3$。同时打破这两者的最便宜方法是 $x_2 = 1$（成本为 $3$），总成本为 $5 + 3 = 8$。没有单个进程能打破所有环，因为没有一个顶点同时位于 $C_1, C_2, C_3$ 和 $C_4$ 中。因此，成本严格低于 $8$ 是不可能的，最小总工作量损失为 $8$。\n\n因此，在最优恢复策略下，最小总损失工作量为 $8$ 个单位的工作量。", "answer": "$$\\boxed{8}$$", "id": "3633125"}]}