{"hands_on_practices": [{"introduction": "在深入复杂的计算之前，理解银行家算法的基本规则至关重要。第一个练习探讨了当一个进程发出逻辑上无效的请求（例如请求负数个资源）时会发生什么。通过分析这个假设情景[@problem_id:3678032]，您将明白为什么输入验证是维护系统状态完整性的第一道防线，以及算法的不变量是如何被保护的。", "problem": "一个系统运行银行家算法以避免死锁。系统中有 $n=3$ 个进程 $\\{P_0,P_1,P_2\\}$ 和 $m=3$ 种资源类型。总资源向量为 $\\vec{T}=(6,5,7)$。当前的分配矩阵 $Allocation$（行对应于 $P_0,P_1,P_2$）是：\n- $P_0$: $(1,1,2)$\n- $P_1$: $(2,0,3)$\n- $P_2$: $(0,1,1)$\n\n最大需求矩阵 $Max$ 是：\n- $P_0$: $(3,2,3)$\n- $P_1$: $(4,2,3)$\n- $P_2$: $(2,3,2)$\n\n进程 $P_2$ 发出一个资源请求向量 $\\vec{R}_2 = (-1,2,1)$，其中第一个分量是负数。假设资源计数以及 $Allocation$、$Max$、$Need$、$Available$ 和任何请求向量的所有条目都旨在模拟实例计数，因此是非负整数集合的元素。\n\n选择所有关于资源管理器必须做什么以及忽略请求非负性所产生后果的正确陈述：\n\nA. 资源管理器必须立即拒绝 $\\vec{R}_2$ 并保持状态不变，因为在进行任何进一步考虑之前，请求的每个分量都必须按分量满足 $\\vec{R}_2 \\ge \\vec{0}$。\n\nB. 如果跳过非负性检查并执行临时分配步骤 $Available := Available - \\vec{R}_2$ 和 $Allocation_2 := Allocation_2 + \\vec{R}_2$，那么 $Allocation_2$ 会出现一个负数条目，违反了所有资源计数都是非负的不变式。\n\nC. 如果跳过非负性检查，系统仍然是安全的，因为安全检查仍然会阻止任何不安全的分配；因此，没有不变式被违反。\n\nD. 如果跳过非负性检查，$Need_2$ 向量必然按分量减少，使得完成更加困难，但所有条目都保持在区间 $[0, Max_2]$ 内。\n\nE. 如果跳过非负性检查并执行临时分配，那么 $Need_2$ 向量的某个分量可能会增加到超过 $Max_2$，从而使银行家算法关于最大声明的基本前提无效。\n\n选择所有适用的选项。", "solution": "用户希望我验证问题陈述，如果有效，则根据银行家算法的原则分析给定选项来解决问题。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 进程数，$n=3$，记为 $\\{P_0, P_1, P_2\\}$。\n- 资源类型数，$m=3$。\n- 总资源向量：$\\vec{T}=(6,5,7)$。\n- 分配矩阵，$Allocation$：\n  - $Allocation_0 = (1,1,2)$\n  - $Allocation_1 = (2,0,3)$\n  - $Allocation_2 = (0,1,1)$\n- 最大需求矩阵，$Max$：\n  - $Max_0 = (3,2,3)$\n  - $Max_1 = (4,2,3)$\n  - $Max_2 = (2,3,2)$\n- 来自进程 $P_2$ 的资源请求：$\\vec{R}_2 = (-1,2,1)$。\n- 核心假设：所有资源计数（$Allocation$、$Max$、$Need$、$Available$ 和请求向量中的条目）都是非负整数。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，是操作系统中的一个标准主题（死锁避免）。所提供的数据是自洽且一致的。首先，我们计算初始状态向量。\n\n已分配资源总量是 $Allocation$ 矩阵各行之和：\n$$ \\sum_{i=0}^{2} \\vec{Allocation}_i = (1,1,2) + (2,0,3) + (0,1,1) = (3,2,6) $$\n可用资源向量是总资源减去已分配资源：\n$$ \\vec{Available} = \\vec{T} - \\sum_{i=0}^{2} \\vec{Allocation}_i = (6,5,7) - (3,2,6) = (3,3,1) $$\n需求矩阵 $Need = Max - Allocation$，为每个进程计算如下：\n- $ \\vec{Need}_0 = \\vec{Max}_0 - \\vec{Allocation}_0 = (3,2,3) - (1,1,2) = (2,1,1) $\n- $ \\vec{Need}_1 = \\vec{Max}_1 - \\vec{Allocation}_1 = (4,2,3) - (2,0,3) = (2,2,0) $\n- $ \\vec{Need}_2 = \\vec{Max}_2 - \\vec{Allocation}_2 = (2,3,2) - (0,1,1) = (2,2,1) $\n\n所有初始数据都是一致的。基本不变式 $\\vec{Allocation}_i \\le \\vec{Max}_i$ 对所有进程都成立。该问题是适定 (well-posed) 的。请求向量 $\\vec{R}_2 = (-1,2,1)$ 因其负分量而非常规，但问题的目标是分析此类请求的程序和逻辑后果，这是一个有效的理论练习，用以测试对算法不变式和所需检查的理解。该问题没有缺陷。\n\n**步骤 3：结论和行动**\n问题是有效的。我将继续进行解答。\n\n### 解答推导\n\n一个进程 $P_i$ 发出请求 $\\vec{R}_i$ 的资源请求算法包括一系列检查，然后进行安全性评估。\n1.  **有效性检查 1：** 请求必须按分量非负：$\\vec{R}_i \\ge \\vec{0}$。请求是用于获取资源；释放资源是另一个独立的操作。请求中的负分量是一个错误。\n2.  **有效性检查 2：** 请求不能超过进程声明的最大需求：$\\vec{R}_i \\le \\vec{Need}_i$。\n3.  **可用性检查：** 请求不能超过当前可用的资源：$\\vec{R}_i \\le \\vec{Available}$。\n4.  **临时分配和安全性检查：** 如果前三个检查通过，系统会临时批准该请求，并使用安全性算法检查结果状态是否安全。\n    - $\\vec{Available}' = \\vec{Available} - \\vec{R}_i$\n    - $\\vec{Allocation}_i' = \\vec{Allocation}_i + \\vec{R}_i$\n    - $\\vec{Need}_i' = \\vec{Need}_i - \\vec{R}_i$\n    - 如果新状态 $(\\vec{Available}', Allocation', Need')$ 是安全的，则批准被最终确定。否则，状态将回滚，$P_i$ 必须等待。\n\n问题要求评估特定请求 $\\vec{R}_2 = (-1,2,1)$ 的后果，以及如果忽略非负性检查（步骤 1）会发生什么。\n\n#### 逐项分析\n\n**A. 资源管理器必须立即拒绝 $\\vec{R}_2$ 并保持状态不变，因为在进行任何进一步考虑之前，请求的每个分量都必须按分量满足 $\\vec{R}_2 \\ge \\vec{0}$。**\n请求向量为 $\\vec{R}_2 = (-1,2,1)$。第一个分量是 $-1$，违反了条件 $\\vec{R}_2 \\ge \\vec{0}$。这个条件是资源请求算法中的第一个逻辑检查。其目的是确保请求在物理上是有意义的（不能请求负数个物品），并区分资源获取与资源释放。因此，一个正确实现的资源管理器必须将其识别为错误，立即拒绝请求，并且不改变系统状态。\n**结论：正确。**\n\n**B. 如果跳过非负性检查并执行临时分配步骤 $Available := Available - \\vec{R}_2$ 和 $Allocation_2 := Allocation_2 + \\vec{R}_2$，那么 $Allocation_2$ 会出现一个负数条目，违反了所有资源计数都是非负的不变式。**\n让我们执行指定的计算。$P_2$ 的初始分配是 $\\vec{Allocation}_2 = (0,1,1)$。请求是 $\\vec{R}_2 = (-1,2,1)$。\n新的临时分配将是：\n$$ \\vec{Allocation}_2' = \\vec{Allocation}_2 + \\vec{R}_2 = (0,1,1) + (-1,2,1) = (0-1, 1+2, 1+1) = (-1,3,2) $$\n新分配向量的第一个分量是 $-1$。这违反了资源分配计数必须是非负整数的基本模型假设。一个进程被分配负数个资源在物理上是不可能的。\n**结论：正确。**\n\n**C. 如果跳过非负性检查，系统仍然是安全的，因为安全检查仍然会阻止任何不安全的分配；因此，没有不变式被违反。**\n这个陈述提出了两个主张。\n主张 1：“没有不变式被违反”。如选项 B 的分析所示，$Allocation$ 矩阵的非负性被违反了。正如我们将在选项 E 的分析中看到的，$Need \\le Max$ 的不变式也被违反了。所以，这部分陈述是错误的。\n主张 2：“系统仍然是安全的，因为安全检查仍然会阻止任何不安全的分配”。安全性算法将在一个已损坏、物理上无意义的状态上运行。在这种情况下，安全性算法的任何输出（“安全”或“不安全”）都是无意义的。系统状态不是“安全的”；它是无效的。初步检查的目的正是为了避免用这种无效数据污染核心的安全性算法。\n**结论：不正确。**\n\n**D. 如果跳过非负性检查，$Need_2$ 向量必然按分量减少，使得完成更加困难，但所有条目都保持在区间 $[0, Max_2]$ 内。**\n需求向量的更新规则是 $\\vec{Need}_2' = \\vec{Need}_2 - \\vec{R}_2$。\n$P_2$ 的初始需求是 $\\vec{Need}_2 = (2,2,1)$。请求是 $\\vec{R}_2 = (-1,2,1)$。\n新的临时需求向量是：\n$$ \\vec{Need}_2' = \\vec{Need}_2 - \\vec{R}_2 = (2,2,1) - (-1,2,1) = (2-(-1), 2-2, 1-1) = (3,0,0) $$\n比较 $\\vec{Need}_2'=(3,0,0)$ 和 $\\vec{Need}_2=(2,2,1)$，第一个分量从 $2$ 增加到了 $3$。因此，“向量必然按分量减少”的说法是错误的。此外，$P_2$ 的最大需求是 $\\vec{Max}_2 = (2,3,2)$。对第一种资源的新需求 $3$ 超过了声明的最大需求 $2$。所以，“所有条目都保持在区间 $[0, Max_2]$ 内”的说法也是错误的。\n**结论：不正确。**\n\n**E. 如果跳过非负性检查并执行临时分配，那么 $Need_2$ 向量的某个分量可能会增加到超过 $Max_2$，从而使银行家算法关于最大声明的基本前提无效。**\n如为选项 D 计算的那样，新的临时需求向量是 $\\vec{Need}_2' = (3,0,0)$。$P_2$ 的最大需求是 $\\vec{Max}_2 = (2,3,2)$。\n我们比较 $\\vec{Need}_2'$ 的第一个分量和 $\\vec{Max}_2$ 的第一个分量：$3 > 2$。\n这违反了银行家算法的基本不变式，即对于任何进程 $P_i$，其当前需求必须小于或等于其最大声明，即 $\\vec{Need}_i \\le \\vec{Max}_i$。向量 $\\vec{Need}_i$ 表示达到最大值所需的剩余资源，因此它永远不能超过最大值。一个负的请求通过实际上将进程的总声明增加到超过其已声明的范围而导致了这种违反。\n**结论：正确。**\n\n总而言之，陈述 A、B 和 E 是正确的。陈述 A 描述了正确实现的算法所要求的操作。陈述 B 和 E 描述了如果跳过初始检查，会发生的两种对算法基本不变式的不同且严重的违反。", "answer": "$$\\boxed{ABE}$$", "id": "3678032"}, {"introduction": "银行家算法的设计具有很强的鲁棒性。本练习将探讨一个微妙的边界情况：一个进程请求零个资源。这个看似微不足道的场景[@problem_id:3678119]，实际上考验了您对算法核心流程的理解，并验证了该算法无需特殊处理即可优雅地应对此类请求，体现了其逻辑的严谨性。", "problem": "在操作系统（OS）课程中，一个计算系统使用 Dijkstra 的银行家算法来防止死锁。系统中有 $n = 4$ 个进程 $\\{P_0, P_1, P_2, P_3\\}$ 和 $m = 3$ 种资源类型 $\\{R_1, R_2, R_3\\}$。总资源由向量 $\\vec{T} = (8, 7, 6)$ 给出。当前的分配矩阵 $A$ 和最大需求矩阵 $M$ 如下：\n$$\nA = \n\\begin{bmatrix}\n1  1  0 \\\\\n2  0  1 \\\\\n0  2  1 \\\\\n2  1  0\n\\end{bmatrix},\\quad\nM =\n\\begin{bmatrix}\n3  2  1 \\\\\n3  3  3 \\\\\n1  2  3 \\\\\n3  1  2\n\\end{bmatrix}.\n$$\n根据银行家算法的核心定义，需求矩阵 $N$ 定义为 $N = M - A$，可用资源向量 $\\vec{Available}$ 定义为 $\\vec{T} - \\sum \\text{A 的行}$。假设发生了以下资源请求：进程 $P_3$ 发出 $Request_3 = \\vec{0}$，即 $Request_3 = (0, 0, 0)$。\n\n仅使用银行家算法中资源请求算法的基本步骤：\n- 逐分量检查是否满足 $Request_i \\leq Need_i$。\n- 逐分量检查是否满足 $Request_i \\leq \\vec{Available}$。\n- 如果两个检查都通过，则假装分配，设置 $\\vec{Available} := \\vec{Available} - Request_i$，$A_i := A_i + Request_i$ 和 $N_i := N_i - Request_i$，然后运行安全性测试。\n以及基本的安全性测试，该测试初始化 $\\vec{Work} := \\vec{Available}$ 和对所有 $j$ 设置 $Finish[j] := \\text{false}$，然后重复寻找一个索引 $k$，满足 $Finish[k] = \\text{false}$ 和 $N_k \\leq \\vec{Work}$，设置 $Finish[k] := \\text{true}$ 并更新 $\\vec{Work} := \\vec{Work} + A_k$，直到找不到这样的 $k$ 为止，\n\n回答以下问题。假设在安全性测试中，平局情况通过首先选择最小的进程索引来解决。\n\n对于给定状态，哪个陈述最好地描述了资源请求算法对 $Request_3 = \\vec{0}$ 的行为以及在安全性测试中 $\\vec{Work}$ 和 $Finish$ 的相应演变？\n\nA. 零请求被批准，状态不变；安全性测试以 $\\vec{Work} = (3, 3, 4)$ 和 $Finish = (\\text{false}, \\text{false}, \\text{false}, \\text{false})$ 开始，然后按顺序选择 $P_0, P_1, P_2, P_3$，最终以 $\\vec{Work} = (8, 7, 6)$ 和所有 $Finish$ 条目为 $\\text{true}$ 结束。\n\nB. 零请求被拒绝，因为 $Request_3$ 必须为严格正值才能被服务；$\\vec{Work}$ 和 $Finish$ 保持未定义状态。\n\nC. 零请求被批准，安全性测试在不检查 $N_3 \\leq \\vec{Work}$ 的情况下立即将 $Finish[3]$ 设置为 $\\text{true}$；因此，在考虑其他进程之前，$\\vec{Work}$ 首先变为 $(5, 4, 4)$。\n\nD. 零请求被视为资源释放，因此 $\\vec{Available}$ 增加了 $A_3$；因此，安全性测试从 $\\vec{Work} = (5, 4, 4)$ 和 $Finish[3] = \\text{false}$ 开始。", "solution": "首先验证问题陈述，以确保其科学上合理、定义明确、客观且自包含。\n\n### 步骤 1：提取已知条件\n- 进程数量, $n = 4$: $\\{P_0, P_1, P_2, P_3\\}$。\n- 资源类型数量, $m = 3$: $\\{R_1, R_2, R_3\\}$。\n- 总资源向量: $\\vec{T} = (8, 7, 6)$。\n- 分配矩阵 $A$:\n$$\nA = \n\\begin{bmatrix}\n1  1  0 \\\\\n2  0  1 \\\\\n0  2  1 \\\\\n2  1  0\n\\end{bmatrix}\n$$\n- 最大需求矩阵 $M$:\n$$\nM =\n\\begin{bmatrix}\n3  2  1 \\\\\n3  3  3 \\\\\n1  2  3 \\\\\n3  1  2\n\\end{bmatrix}\n$$\n- 需求矩阵定义: $N = M - A$。\n- 可用资源向量定义: $\\vec{Available} = \\vec{T} - \\sum \\text{A 的行}$。\n- 来自进程 $P_3$ 的资源请求: $Request_3 = (0, 0, 0)$。\n- 提供了资源请求算法的步骤。\n- 提供了安全性测试算法的步骤。\n- 安全性测试的平局解决规则：首先选择最小的进程索引。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题描述了应用 Dijkstra 银行家算法的标准场景，这是操作系统中避免死锁的一个基本概念。所提供的定义和算法都是标准的。我们必须检查初始状态的内部一致性。\n\n1.  **已分配资源总量**: 我们对分配矩阵 $A$ 的各列求和。\n    - 已分配 $R_1$ 总量: $1 + 2 + 0 + 2 = 5$。\n    - 已分配 $R_2$ 总量: $1 + 0 + 2 + 1 = 4$。\n    - 已分配 $R_3$ 总量: $0 + 1 + 1 + 0 = 2$。\n    总分配向量为 $\\sum_{i=0}^{3} A_i = (5, 4, 2)$。\n\n2.  **一致性检查**: 已分配资源总量不能超过系统中的总资源量。\n    - $\\sum A_i = (5, 4, 2) \\leq \\vec{T} = (8, 7, 6)$。这逐分量成立（$5 \\leq 8$, $4 \\leq 7$, $2 \\leq 6$）。\n\n3.  **声明一致性检查**: 分配给一个进程的资源数量不能超过其最大声明。这意味着对每个进程 $i$ 都有 $A_i \\leq M_i$。\n    - $P_0$: $A_0 = (1, 1, 0) \\leq M_0 = (3, 2, 1)$。成立。\n    - $P_1$: $A_1 = (2, 0, 1) \\leq M_1 = (3, 3, 3)$。成立。\n    - $P_2$: $A_2 = (0, 2, 1) \\leq M_2 = (1, 2, 3)$。成立。\n    - $P_3$: $A_3 = (2, 1, 0) \\leq M_3 = (3, 1, 2)$。成立。\n\n该问题在科学上是有根据的、定义明确、客观且内部一致。\n\n### 步骤 3：结论和行动\n问题有效。可以继续求解过程。\n\n### 求解过程推导\n\n首先，我们计算系统的初始状态，特别是 `Available` 向量和 `Need` 矩阵。\n\n**1. 计算 `Available` 向量：**\n`Available` 向量是总资源减去已分配资源总量。\n$$\n\\vec{Available} = \\vec{T} - \\sum_{i=0}^{3} A_i = (8, 7, 6) - (5, 4, 2) = (3, 3, 4)\n$$\n\n**2. 计算 `Need` 矩阵：**\n`Need` 矩阵定义为 $N = M - A$。我们逐行计算。\n- $N_0 = M_0 - A_0 = (3, 2, 1) - (1, 1, 0) = (2, 1, 1)$。\n- $N_1 = M_1 - A_1 = (3, 3, 3) - (2, 0, 1) = (1, 3, 2)$。\n- $N_2 = M_2 - A_2 = (1, 2, 3) - (0, 2, 1) = (1, 0, 2)$。\n- $N_3 = M_3 - A_3 = (3, 1, 2) - (2, 1, 0) = (1, 0, 2)$。\n所以，`Need` 矩阵是：\n$$\nN = \n\\begin{bmatrix}\n2  1  1 \\\\\n1  3  2 \\\\\n1  0  2 \\\\\n1  0  2\n\\end{bmatrix}\n$$\n\n**3. 处理资源请求 $Request_3 = (0, 0, 0)$：**\n我们遵循针对 $P_3$ 的资源请求算法步骤。\n- **步骤 1：检查是否满足 $Request_3 \\leq Need_3$。**\n  - $Request_3 = (0, 0, 0)$。\n  - $Need_3 = (1, 0, 2)$。\n  - 条件 $(0, 0, 0) \\leq (1, 0, 2)$ 逐分量成立。检查通过。\n\n- **步骤 2：检查是否满足 $Request_3 \\leq \\vec{Available}$。**\n  - $Request_3 = (0, 0, 0)$。\n  - $\\vec{Available} = (3, 3, 4)$。\n  - 条件 $(0, 0, 0) \\leq (3, 3, 4)$ 逐分量成立。检查通过。\n\n- **步骤 3：尝试性分配与安全性测试。**\n  由于两个检查都通过，算法继续进行。在运行安全性测试之前，系统状态被假设性地更新。\n  - $\\vec{Available} := \\vec{Available} - Request_3 = (3, 3, 4) - (0, 0, 0) = (3, 3, 4)$。\n  - $A_3 := A_3 + Request_3 = (2, 1, 0) + (0, 0, 0) = (2, 1, 0)$。\n  - $N_3 := N_3 - Request_3 = (1, 0, 2) - (0, 0, 0) = (1, 0, 2)$。\n  请求的资源为零，所以系统状态（$A$, $N$, $\\vec{Available}$）没有改变。请求被“批准”，意味着算法进入安全性测试阶段，而不是被拒绝。\n\n**4. 运行安全性测试：**\n在（未改变的）状态上运行安全性测试。\n- **初始化：**\n  - $\\vec{Work} := \\vec{Available} = (3, 3, 4)$。\n  - $Finish := (\\text{false}, \\text{false}, \\text{false}, \\text{false})$。\n\n- **执行循环：** 寻找一个进程 $P_k$ 使得 $Finish[k] = \\text{false}$ 且 $N_k \\leq \\vec{Work}$。\n  - **迭代 1：** $\\vec{Work} = (3, 3, 4)$。\n    - 对于 $k=0$：$N_0 = (2, 1, 1) \\leq (3, 3, 4)$。成立。\n    - 由于在平局情况下必须首先选择最小的索引，我们选择 $P_0$。\n    - $\\vec{Work} := \\vec{Work} + A_0 = (3, 3, 4) + (1, 1, 0) = (4, 4, 4)$。\n    - $Finish := (\\text{true}, \\text{false}, \\text{false}, \\text{false})$。\n\n  - **迭代 2：** $\\vec{Work} = (4, 4, 4)$。\n    - 对于 $k=1$：$N_1 = (1, 3, 2) \\leq (4, 4, 4)$。成立。\n    - 选择 $P_1$。\n    - $\\vec{Work} := \\vec{Work} + A_1 = (4, 4, 4) + (2, 0, 1) = (6, 4, 5)$。\n    - $Finish := (\\text{true}, \\text{true}, \\text{false}, \\text{false})$。\n\n  - **迭代 3：** $\\vec{Work} = (6, 4, 5)$。\n    - 对于 $k=2$：$N_2 = (1, 0, 2) \\leq (6, 4, 5)$。成立。\n    - 选择 $P_2$。\n    - $\\vec{Work} := \\vec{Work} + A_2 = (6, 4, 5) + (0, 2, 1) = (6, 6, 6)$。\n    - $Finish := (\\text{true}, \\text{true}, \\text{true}, \\text{false})$。\n\n  - **迭代 4：** $\\vec{Work} = (6, 6, 6)$。\n    - 对于 $k=3$：$N_3 = (1, 0, 2) \\leq (6, 6, 6)$。成立。\n    - 选择 $P_3$。\n    - $\\vec{Work} := \\vec{Work} + A_3 = (6, 6, 6) + (2, 1, 0) = (8, 7, 6)$。\n    - $Finish := (\\text{true}, \\text{true}, \\text{true}, \\text{true})$。\n\n- **安全性测试结论：**\n  $Finish$ 向量中的所有条目都为 true，所以状态是安全的。找到的安全序列是 $\\langle P_0, P_1, P_2, P_3 \\rangle$。$\\vec{Work}$ 的最终值是 $(8, 7, 6)$，这正确地匹配了总资源 $\\vec{T}$。\n\n### 逐项分析选项\n\n- **A. 零请求被批准，状态不变；安全性测试以 $\\vec{Work} = (3, 3, 4)$ 和 $Finish = (\\text{false}, \\text{false}, \\text{false}, \\text{false})$ 开始，然后按顺序选择 $P_0, P_1, P_2, P_3$，最终以 $\\vec{Work} = (8, 7, 6)$ 和所有 $Finish$ 条目为 $\\text{true}$ 结束。**\n  这个陈述与上面的分步推导完全匹配。零请求通过了检查，因此被“批准”并进入安全性测试。状态未改变。初始的 `Work` 向量是正确的。找到的进程序列和最终的 `Work` 向量也是正确的。\n  **结论：正确。**\n\n- **B. 零请求被拒绝，因为 $Request_3$ 必须为严格正值才能被服务；$\\vec{Work}$ 和 $Finish$ 保持未定义状态。**\n  这是不正确的。银行家算法使用小于等于比较（$Request_i \\leq Need_i$ 和 $Request_i \\leq \\vec{Available}$），零向量可以轻易满足这些条件。没有规则规定请求必须是严格正值。该请求是按算法处理的，而不是直接被拒绝。\n  **结论：不正确。**\n\n- **C. 零请求被批准，安全性测试在不检查 $N_3 \\leq \\vec{Work}$ 的情况下立即将 $Finish[3]$ 设置为 $\\text{true}$；因此，在考虑其他进程之前，$\\vec{Work}$ 首先变为 $(5, 4, 4)$。**\n  这是不正确的。安全性测试算法独立于发出请求的进程。它遵循自己的循环，从索引 0 开始，检查所有 $Finish$ 标志为 false 的进程。它不会给予请求进程特殊的优先级或处理。$Finish[3]$ 在未经检查的情况下被设置的前提是违反算法的。\n  **结论：不正确。**\n\n- **D. 零请求被视为资源释放，因此 $\\vec{Available}$ 增加了 $A_3$；因此，安全性测试从 $\\vec{Work} = (5, 4, 4)$ 和 $Finish[3] = \\text{false}$ 开始。**\n  这是不正确的。问题明确指出 $P_3$ 发出的是一个*请求*。请求和释放是不同的操作。请求零资源在语义上不等同于释放一个进程当前持有的所有资源。这个选项混淆了整个资源管理方案中的两个不同部分。\n  **结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3678119"}, {"introduction": "银行家算法的关键作用不仅是做出“安全”或“不安全”的二元判断，更是量化系统距离危险状态的程度。这个练习[@problem_id:3678059]将挑战您去寻找一个资源请求的精确“安全阈值”。您需要确定在系统从安全状态转变为不安全状态之前，可以被批准的最大资源数量，从而锻炼您运用该算法进行量化分析的能力。", "problem": "一个操作系统使用银行家算法来避免在一个包含 $n=4$ 个进程 $\\{P_0,P_1,P_2,P_3\\}$ 和 $m=3$ 种资源类型 $\\{A,B,C\\}$ 的系统中出现死锁。当前状态由 Allocation 矩阵、Max 矩阵和 Available 向量指定如下：\n$$\n\\text{Allocation} =\n\\begin{pmatrix}\n0  1  0 \\\\\n2  0  0 \\\\\n3  0  2 \\\\\n2  1  1\n\\end{pmatrix},\\quad\n\\text{Max} =\n\\begin{pmatrix}\n7  5  3 \\\\\n3  2  2 \\\\\n9  2  2 \\\\\n4  3  3\n\\end{pmatrix},\\quad\n\\text{Available} =\n\\begin{pmatrix}\n3  3  4\n\\end{pmatrix}.\n$$\n进程 $P_2$ 发出一个仅针对资源类型 $A$ 的请求，该请求由单个整数 $k \\ge 0$ 参数化，其请求向量为\n$$\nRequest_2(k) = \\begin{pmatrix} k  0  0 \\end{pmatrix}.\n$$\n你必须遵循银行家算法中的资源请求算法，来决定操作系统现在是否会批准 $Request_2(k)$。仅使用该算法的基本定义，即：需求关系 $\\text{Need} = \\text{Max} - \\text{Allocation}$，请求可接受性检查 $Request_i \\le \\text{Need}_i$ 和 $Request_i \\le \\text{Available}$（两者都按分量比较），以及在试探性地分配所请求的资源后，通过是否存在安全序列来定义的安全新测试。\n\n存在一个最大的整数 $k^\\ast$，使得批准 $Request_2(k^\\ast)$ 会使系统保持在安全状态，而批准 $Request_2(k^\\ast+1)$ 会导致安全性测试失败，即使其满足基本的可接受性检查。确定这个阈值 $k^\\ast$。\n\n你的答案应为一个整数（无需四舍五入）。", "solution": "首先验证问题，以确保其科学性、良构性和客观性。\n\n### 步骤 1：提取已知条件\n问题为包含 $n=4$ 个进程 $\\{P_0,P_1,P_2,P_3\\}$ 和 $m=3$ 种资源类型 $\\{A,B,C\\}$ 的系统提供了以下数据：\n- Allocation 矩阵：\n$$\n\\text{Allocation} =\n\\begin{pmatrix}\n0  1  0 \\\\\n2  0  0 \\\\\n3  0  2 \\\\\n2  1  1\n\\end{pmatrix}\n$$\n- Max 矩阵：\n$$\n\\text{Max} =\n\\begin{pmatrix}\n7  5  3 \\\\\n3  2  2 \\\\\n9  2  2 \\\\\n4  3  3\n\\end{pmatrix}\n$$\n- Available 向量：\n$$\n\\text{Available} =\n\\begin{pmatrix}\n3  3  4\n\\end{pmatrix}\n$$\n- 进程 $P_2$ 请求 $k \\ge 0$ 个资源类型 A 的实例：\n$$\nRequest_2(k) = \\begin{pmatrix} k  0  0 \\end{pmatrix}\n$$\n- 问题要求找出最大的整数 $k^\\ast$，使得批准 $Request_2(k^\\ast)$ 导致安全状态，而批准 $Request_2(k^\\ast+1)$ 是可接受的但导致不安全状态。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述描述了一个应用银行家算法的标准场景，该算法是操作系统中一种成熟的死锁避免算法。所提供的数据（矩阵和向量）对于应用此算法是一致和完整的。使用的术语是精确和标准的。快速的一致性检查表明，系统中的总资源数量与已分配和可用资源一致，并且每个进程的最大声明不超过总数。该问题具有科学性（在计算机科学领域内）、良构性和客观性。它没有违反任何无效性标准。因此，该问题是有效的。\n\n### 步骤 3：结论与行动\n该问题是有效的。我们开始解题。\n\n### 解题过程\n求解需要应用针对进程 $P_2$ 的资源请求算法。该算法包括两个阶段：可接受性检查和安全性检查。\n\n首先，我们计算 `Need` 矩阵，定义为 $\\text{Need} = \\text{Max} - \\text{Allocation}$。该矩阵的行 $\\text{Need}_i$ 代表每个进程 $P_i$ 剩余所需的资源。\n$$\n\\text{Need}_0 = \\begin{pmatrix} 7  5  3 \\end{pmatrix} - \\begin{pmatrix} 0  1  0 \\end{pmatrix} = \\begin{pmatrix} 7  4  3 \\end{pmatrix}\n$$\n$$\n\\text{Need}_1 = \\begin{pmatrix} 3  2  2 \\end{pmatrix} - \\begin{pmatrix} 2  0  0 \\end{pmatrix} = \\begin{pmatrix} 1  2  2 \\end{pmatrix}\n$$\n$$\n\\text{Need}_2 = \\begin{pmatrix} 9  2  2 \\end{pmatrix} - \\begin{pmatrix} 3  0  2 \\end{pmatrix} = \\begin{pmatrix} 6  2  0 \\end{pmatrix}\n$$\n$$\n\\text{Need}_3 = \\begin{pmatrix} 4  3  3 \\end{pmatrix} - \\begin{pmatrix} 2  1  1 \\end{pmatrix} = \\begin{pmatrix} 2  2  2 \\end{pmatrix}\n$$\n因此，完整的 `Need` 矩阵是：\n$$\n\\text{Need} =\n\\begin{pmatrix}\n7  4  3 \\\\\n1  2  2 \\\\\n6  2  0 \\\\\n2  2  2\n\\end{pmatrix}\n$$\n\n接下来，我们检查 $Request_2(k) = \\begin{pmatrix} k  0  0 \\end{pmatrix}$ 的可接受性。一个请求如果满足以下两个条件（向量分量逐一比较），就是可接受的：\n1.  $Request_2(k) \\le \\text{Need}_2$\n2.  $Request_2(k) \\le \\text{Available}$\n\n应用这些条件：\n1.  $\\begin{pmatrix} k  0  0 \\end{pmatrix} \\le \\begin{pmatrix} 6  2  0 \\end{pmatrix} \\Rightarrow k \\le 6$, $0 \\le 2$, $0 \\le 0$。这意味着 $k \\le 6$。\n2.  $\\begin{pmatrix} k  0  0 \\end{pmatrix} \\le \\begin{pmatrix} 3  3  4 \\end{pmatrix} \\Rightarrow k \\le 3$, $0 \\le 3$, $0 \\le 4$。这意味着 $k \\le 3$。\n\n两个条件都必须满足，所以 $k$ 必须小于或等于 $3$。由于 $k \\ge 0$，请求只能在 $k \\in \\{0, 1, 2, 3\\}$ 的范围内考虑。任何 $k > 3$ 的请求都将因没有足够的可用资源而被立即拒绝。\n\n问题指出 $Request_2(k^\\ast+1)$ 是可接受的。这意味着 $k^\\ast+1 \\le 3$，即 $k^\\ast \\le 2$。我们正在寻找导致安全状态的最大 $k$ 值。我们应该从大到小测试 $k$ 的可能值。$k^\\ast$ 的候选值是 $2$、$1$ 和 $0$。根据问题陈述，我们期望随着 $k$ 的增加，会发现一个从安全到不安全状态的转变。\n\n让我们测试 $k=3$（这对应于一个潜在的 $k^\\ast = 2$）。\n如果 $k=3$，我们测试批准 $Request_2(3)$ 是否会导致安全状态。首先，我们构建假设的新状态：\n- $Request_2(3) = \\begin{pmatrix} 3  0  0 \\end{pmatrix}$\n- $\\text{Available}' = \\text{Available} - Request_2(3) = \\begin{pmatrix} 3  3  4 \\end{pmatrix} - \\begin{pmatrix} 3  0  0 \\end{pmatrix} = \\begin{pmatrix} 0  3  4 \\end{pmatrix}$\n- $\\text{Allocation}_2' = \\text{Allocation}_2 + Request_2(3) = \\begin{pmatrix} 3  0  2 \\end{pmatrix} + \\begin{pmatrix} 3  0  0 \\end{pmatrix} = \\begin{pmatrix} 6  0  2 \\end{pmatrix}$\n- $\\text{Need}_2' = \\text{Need}_2 - Request_2(3) = \\begin{pmatrix} 6  2  0 \\end{pmatrix} - \\begin{pmatrix} 3  0  0 \\end{pmatrix} = \\begin{pmatrix} 3  2  0 \\end{pmatrix}$\n\n现在我们用 $\\text{Work} = \\text{Available}' = \\begin{pmatrix} 0  3  4 \\end{pmatrix}$ 和 $\\text{Finish} = (\\text{false, false, false, false})$ 来运行安全性算法。\n`Need` 向量为 $\\text{Need}_0=(7,4,3)$，$\\text{Need}_1=(1,2,2)$，$\\text{Need}_2'=(3,2,0)$，$\\text{Need}_3=(2,2,2)$。\n- $P_0$ 能否运行？ $\\text{Need}_0 = (7,4,3) \\not\\le (0,3,4)$。否。\n- $P_1$ 能否运行？ $\\text{Need}_1 = (1,2,2) \\not\\le (0,3,4)$。否。\n- $P_2$ 能否运行？ $\\text{Need}_2' = (3,2,0) \\not\\le (0,3,4)$。否。\n- $P_3$ 能否运行？ $\\text{Need}_3 = (2,2,2) \\not\\le (0,3,4)$。否。\n没有进程可以获得其所需资源。安全性算法未能找到一个可以完成的进程。因此，批准 $Request_2(3)$ 所导致的状态是**不安全**的。\n\n$k=3$ 的这个结果与问题中对 $k^\\ast+1$ 状态的描述相符。这表明 $k^\\ast=2$。为确认这一点，我们必须验证批准 $Request_2(2)$ 会导致一个**安全**状态。\n\n让我们测试 $k=2$。\n- $Request_2(2) = \\begin{pmatrix} 2  0  0 \\end{pmatrix}$。这是可接受的，因为 $2 \\le 3$ 且 $2 \\le 6$。\n- 假设的新状态：\n  - $\\text{Available}'' = \\text{Available} - Request_2(2) = \\begin{pmatrix} 3  3  4 \\end{pmatrix} - \\begin{pmatrix} 2  0  0 \\end{pmatrix} = \\begin{pmatrix} 1  3  4 \\end{pmatrix}$\n  - $\\text{Allocation}_2'' = \\text{Allocation}_2 + Request_2(2) = \\begin{pmatrix} 3  0  2 \\end{pmatrix} + \\begin{pmatrix} 2  0  0 \\end{pmatrix} = \\begin{pmatrix} 5  0  2 \\end{pmatrix}$\n  - $\\text{Need}_2'' = \\text{Need}_2 - Request_2(2) = \\begin{pmatrix} 6  2  0 \\end{pmatrix} - \\begin{pmatrix} 2  0  0 \\end{pmatrix} = \\begin{pmatrix} 4  2  0 \\end{pmatrix}$\n\n用 $\\text{Work} = \\text{Available}'' = \\begin{pmatrix} 1  3  4 \\end{pmatrix}$ 和 $\\text{Finish} = (\\text{false, false, false, false})$ 运行安全性算法。\n`Need` 向量为 $\\text{Need}_0=(7,4,3)$，$\\text{Need}_1=(1,2,2)$，$\\text{Need}_2''=(4,2,0)$，$\\text{Need}_3=(2,2,2)$。\n`Allocation` 向量（在一个进程完成后使用）为 $\\text{Allocation}_0=(0,1,0)$，$\\text{Allocation}_1=(2,0,0)$，$\\text{Allocation}_2''=(5,0,2)$，$\\text{Allocation}_3=(2,1,1)$。\n\n1.  初始化 $\\text{Work} = (1, 3, 4)$，$\\text{Finish} = (F, F, F, F)$。\n2.  找到一个满足 $\\text{Finish}_i = F$ 和 $\\text{Need}_i \\le \\text{Work}$ 的进程 $P_i$。\n    - $P_0$：$\\text{Need}_0=(7,4,3) \\not\\le (1,3,4)$。\n    - $P_1$：$\\text{Need}_1=(1,2,2) \\le (1,3,4)$。是。\n    - 执行 $P_1$：\n      $\\text{Work} = \\text{Work} + \\text{Allocation}_1 = (1,3,4) + (2,0,0) = (3,3,4)$。\n      $\\text{Finish} = (F, T, F, F)$。\n3.  寻找下一个进程。当前 $\\text{Work} = (3,3,4)$。\n    - $P_0$：$\\text{Need}_0=(7,4,3) \\not\\le (3,3,4)$。\n    - $P_2$：$\\text{Need}_2''=(4,2,0) \\not\\le (3,3,4)$。\n    - $P_3$：$\\text{Need}_3=(2,2,2) \\le (3,3,4)$。是。\n    - 执行 $P_3$：\n      $\\text{Work} = \\text{Work} + \\text{Allocation}_3 = (3,3,4) + (2,1,1) = (5,4,5)$。\n      $\\text{Finish} = (F, T, F, T)$。\n4.  寻找下一个进程。当前 $\\text{Work} = (5,4,5)$。\n    - $P_0$：$\\text{Need}_0=(7,4,3) \\not\\le (5,4,5)$。\n    - $P_2$：$\\text{Need}_2''=(4,2,0) \\le (5,4,5)$。是。\n    - 执行 $P_2$：\n      $\\text{Work} = \\text{Work} + \\text{Allocation}_2'' = (5,4,5) + (5,0,2) = (10,4,7)$。\n      $\\text{Finish} = (F, T, T, T)$。\n5.  寻找下一个进程。当前 $\\text{Work} = (10,4,7)$。\n    - $P_0$：$\\text{Need}_0=(7,4,3) \\le (10,4,7)$。是。\n    - 执行 $P_0$：\n      $\\text{Work} = \\text{Work} + \\text{Allocation}_0 = (10,4,7) + (0,1,0) = (10,5,7)$。\n      $\\text{Finish} = (T, T, T, T)$。\n\n所有进程都可以完成。已经找到了一个安全序列，例如 $\\langle P_1, P_3, P_2, P_0 \\rangle$。因此，批准 $Request_2(2)$ 所导致的状态是**安全**的。\n\n我们已经证明：\n- 对于 $k=2$，请求被批准（可接受且导致安全状态）。\n- 对于 $k=3$，请求不被批准（可接受但导致不安全状态）。\n\n这与问题中对 $k^\\ast=2$ 和 $k^\\ast+1=3$ 的定义相符。批准请求的最大整数 $k^\\ast$ 是 2。", "answer": "$$\\boxed{2}$$", "id": "3678059"}]}