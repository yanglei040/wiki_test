{"hands_on_practices": [{"introduction": "银行家算法的正确性依赖于其核心数据结构（如 `Allocation`、`Max` 和 `Need` 矩阵）之间内在关系的完整性。在执行复杂的安全性检查之前，验证这些数据的一致性是至关重要的一步。本练习将引导你通过检查算法的基本不变量来诊断和定位数据错误，这是保证系统可靠性的基本功。[@problem_id:3622586]", "problem": "一个系统使用银行家算法 (BA) 来管理 $n$ 个进程的 $m$ 种资源类型。BA 针对每个进程 $P_i$ 和资源类型 $R_j$ 维护以下数据结构：一个分配矩阵 $A$，其中 $A[i,j]$ 是当前分配给 $P_i$ 的 $R_j$ 类型的实例数；一个最大需求矩阵 $M$，其中 $M[i,j]$ 是 $P_i$ 可能请求的 $R_j$ 类型的声明最大实例数；以及一个需求矩阵 $N$，根据基本原则定义为 $N[i,j] = M[i,j] - A[i,j]$。该系统还跟踪一个总资源向量 $\\mathbf{T}$ 和一个可用向量 $\\mathbf{V}$，它们必须按分量满足 $\\mathbf{V} = \\mathbf{T} - \\sum_{i} A[i,*]$，且所有条目均为非负整数。BA 数据模型的一个基本不变量是，对于每个 $i$ 和 $j$，$0 \\le A[i,j] \\le M[i,j]$ 且 $0 \\le N[i,j] \\le M[i,j]$，其中 $N[i,j]$ 精确地计算为 $M[i,j] - A[i,j]$。\n\n考虑以下快照，其中有 $n = 4$ 个进程和 $m = 3$ 种资源类型 $\\{A,B,C\\}$。向量和矩阵如下：\n\n$$ \\mathbf{T} = (12, 9, 8), \\quad \\mathbf{V} = (4, 4, 2) $$\n\n$$A = \\begin{bmatrix}\n3  0  1 \\\\\n2  1  3 \\\\\n2  3  1 \\\\\n1  1  1\n\\end{bmatrix}, \\quad\nM = \\begin{bmatrix}\n7  5  3 \\\\\n3  2  7 \\\\\n4  3  3 \\\\\n3  4  4\n\\end{bmatrix}, \\quad\nN = \\begin{bmatrix}\n4  5  2 \\\\\n1  1  4 \\\\\n2  0  2 \\\\\n2  5  3\n\\end{bmatrix}$$\n\n假设分配矩阵 $A$、需求矩阵 $N$ 以及向量 $\\mathbf{T}, \\mathbf{V}$ 都是准确的测量值。最大需求矩阵 $M$ 中恰好有一个条目是数据录入错误，其真实值必须是在不改变任何其他条目的情况下，能使 BA 不变量对所有进程和资源类型同时成立的值。下列哪个陈述正确地指出了错误的条目及其更正后的值？\n\nA. 错误的条目是 $M[P_3,B]$；其正确的值是 $6$。\n\nB. 错误的条目是 $N[P_3,B]$；其正确的值是 $3$。\n\nC. 错误的条目是 $A[P_2,B]$；其正确的值是 $2$。\n\nD. 可用向量 $\\mathbf{V}$ 不正确；其正确的值是 $(3, 4, 2)$。\n\nE. 错误的条目是 $M[P_0,B]$；其正确的值是 $6$。", "solution": "用户希望我验证并解决一个关于银行家算法数据结构的问题。\n\n### 第一步：提取已知条件\n- 进程数 $n=4$，记为 $P_0, P_1, P_2, P_3$。\n- 资源类型数 $m=3$，记为 $A, B, C$。\n- 总资源向量：$\\mathbf{T} = (12, 9, 8)$。\n- 可用资源向量：$\\mathbf{V} = (4, 4, 2)$。\n- 分配矩阵 $A$：\n$$A = \\begin{bmatrix}\n3  0  1 \\\\\n2  1  3 \\\\\n2  3  1 \\\\\n1  1  1\n\\end{bmatrix}$$\n- 最大需求矩阵 $M$：\n$$M = \\begin{bmatrix}\n7  5  3 \\\\\n3  2  7 \\\\\n4  3  3 \\\\\n3  4  4\n\\end{bmatrix}$$\n- 需求矩阵 $N$：\n$$N = \\begin{bmatrix}\n4  5  2 \\\\\n1  1  4 \\\\\n2  0  2 \\\\\n2  5  3\n\\end{bmatrix}$$\n- 核心不变量：\n  1. 对所有 $i,j$，$N[i,j] = M[i,j] - A[i,j]$。\n  2. $\\mathbf{V} = \\mathbf{T} - \\sum_{i=0}^{n-1} A[i,*]$（按分量对所有进程求和）。\n- 问题前提：矩阵 $A$ 和 $N$，以及向量 $\\mathbf{T}$ 和 $\\mathbf{V}$ 都是准确的。矩阵 $M$ 中恰好有一个不正确的条目。\n\n### 第二步：使用提取的已知条件进行验证\n问题陈述提供了一组数据和一套需要检查的清晰规则（银行家算法的不变量）。任务是根据这些规则找到唯一的不一致之处。\n\n首先，我将验证声明为“准确”的数据的一致性：$A, N, \\mathbf{T}, \\mathbf{V}$。连接 $\\mathbf{T}, \\mathbf{V}$ 和 $A$ 的关系必须成立。\n每种类型的总已分配资源是分配矩阵 $A$ 的列之和。\n设 $\\mathbf{A}_{\\text{total}}$ 为总已分配资源的向量。\n- 资源类型 A（第0列）的总分配量：$3 + 2 + 2 + 1 = 8$。\n- 资源类型 B（第1列）的总分配量：$0 + 1 + 3 + 1 = 5$。\n- 资源类型 C（第2列）的总分配量：$1 + 3 + 1 + 1 = 6$。\n因此，$\\mathbf{A}_{\\text{total}} = (8, 5, 6)$。\n\n根据不变量，可用向量 $\\mathbf{V}$ 应为 $\\mathbf{T} - \\mathbf{A}_{\\text{total}}$。我们来计算一下：\n$\\mathbf{T} - \\mathbf{A}_{\\text{total}} = (12, 9, 8) - (8, 5, 6) = (12-8, 9-5, 8-6) = (4, 4, 2)$。\n这个计算出的可用向量 $(4, 4, 2)$ 与给定的可用向量 $\\mathbf{V} = (4, 4, 2)$ 相匹配。\n因此，$\\mathbf{T}$、$\\mathbf{V}$ 和 $A$ 之间的关系是一致的。\n\n接下来，问题指出错误在 $M$ 中，而 $A$ 和 $N$ 是准确的。这意味着由于 $M$ 中的错误，基本关系 $N[i,j] = M[i,j] - A[i,j]$ 肯定在某个条目上被违反了。为了找到这个错误，我们可以检查所有 $i, j$ 的等价公式 $M[i,j] = A[i,j] + N[i,j]$。给定的 $M$ 与 $A+N$ 之和不同的位置就是错误的位置。\n\n### 第三步：判断与行动\n该问题在科学上植根于操作系统的原理，特别是资源分配和死锁避免。它问题明确、客观、自洽，并提供了足够的信息来得出唯一解。前提条件内部一致。因此，该问题是有效的。我将继续进行解答。\n\n### 解题推导\n核心任务是找出矩阵 $M$ 中唯一的错误条目。根据问题的前提，$A$ 和 $N$ 是正确的，因此正确的最大需求矩阵（我们称之为 $M'$）可以直接根据不变量 $M'[i,j] = A[i,j] + N[i,j]$ 计算得出。然后我们将 $M'$ 与给定的 $M$ 进行比较，以找出差异。\n\n矩阵的行对应进程 $P_0, P_1, P_2, P_3$（索引为 $0, 1, 2, 3$），列对应资源类型 $A, B, C$（索引为 $0, 1, 2$）。\n\n让我们逐个元素计算 $M' = A + N$：\n$M' = \\begin{bmatrix}\n3+4  0+5  1+2 \\\\\n2+1  1+1  3+4 \\\\\n2+2  3+0  1+2 \\\\\n1+2  1+5  1+3\n\\end{bmatrix} = \\begin{bmatrix}\n7  5  3 \\\\\n3  2  7 \\\\\n4  3  3 \\\\\n3  6  4\n\\end{bmatrix}$\n\n现在，我们将这个计算出的正确矩阵 $M'$ 与给定的矩阵 $M$ 进行比较：\n$M = \\begin{bmatrix}\n7  5  3 \\\\\n3  2  7 \\\\\n4  3  3 \\\\\n3  4  4\n\\end{bmatrix}$\n\n通过检查，发现两个矩阵只有一个条目不同：\n- 位于行索引 $3$、列索引 $1$ 的条目（进程 $P_3$，资源类型 B）。\n- 给定值为 $M[3,1] = 4$。\n- 正确计算出的值为 $M'[3,1] = 6$。\n\n因此，错误的条目是 $M[P_3,B]$（可以写作 $M[3,1]$），其给定值为 $4$，正确值为 $6$。\n\n### 逐项分析选项\n\n**A. 错误的条目是 $M[P_3,B]$；其正确的值是 $6$。**\n这个陈述与我们的推导完全一致。该条目对应于矩阵 $M$ 的行索引 $3$ 和列索引 $1$ 的元素。我们发现 $M[3,1]$ 应该是 $A[3,1] + N[3,1] = 1 + 5 = 6$，但给定值为 $4$。\n**判断：正确。**\n\n**B. 错误的条目是 $N[P_3,B]$；其正确的值是 $3$。**\n这个陈述与问题的前提（即需求矩阵 $N$ 是准确的，错误在 $M$ 中）相矛盾。如果我们假设 $A$ 和 $M$ 是正确的，那么 $N[P_3,B]$ 将是 $M[P_3,B] - A[P_3,B] = 4-1=3$。然而，这违反了问题的明确条件。\n**判断：不正确。**\n\n**C. 错误的条目是 $A[P_2,B]$；其正确的值是 $2$。**\n这个陈述与问题的前提（即分配矩阵 $A$ 是准确的）相矛盾。更改 $A$ 也会违反我们之前验证过的 $\\mathbf{T}, \\mathbf{V}, A$ 关系的一致性。\n**判断：不正确。**\n\n**D. 可用向量 $\\mathbf{V}$ 不正确；其正确的值是 $(3, 4, 2)$。**\n这个陈述与问题的前提（即可用向量 $\\mathbf{V}$ 是准确的）相矛盾。此外，我们的验证步骤已确认给定的 $\\mathbf{V}$ 与给定的 $\\mathbf{T}$ 和 $A$ 是一致的。\n**判断：不正确。**\n\n**E. 错误的条目是 $M[P_0,B]$；其正确的值是 $6$。**\n我们的分析表明错误在 $M[P_3,B]$，而不是 $M[P_0,B]$。对于 $M[P_0,B]$（即 $M[0,1]$），正确的值是 $A[0,1] + N[0,1] = 0 + 5 = 5$。给定值也是 $5$。这个位置没有错误。\n**判断：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3622586"}, {"introduction": "在确保算法正确性的基础上，提升其运行效率是系统优化的关键目标。本练习通过一个假设场景，量化比较了两种不同数据结构（字节数组与压缩位集）在实现安全性检查中 `Finish` 向量时的性能差异。通过这个实践，你将学会如何利用底层硬件特性（如位操作）来优化数据表示，从而显著提升算法性能。[@problem_id:3622562]", "problem": "考虑一个管理 $N$ 个进程的操作系统中，银行家算法的安全性检查循环所使用的数组 $Finish$ 的数据结构选择问题。数组 $Finish$ 记录哪些进程已完成安全性检查，其中 $Finish[i] = 1$ 表示已完成，$Finish[i] = 0$ 表示未完成。你需要比较在对所有 $N$ 个进程进行一次完整扫描期间，用以识别未完成进程的两种表示方法和扫描策略。\n\n假设以下基本事实和定义：\n- 工作量与基本操作的计数成正比；预期的总工作量是这些操作的预期计数之和。\n- 一个紧凑位集每比特存储一个布尔值，并且可以一次处理一个机器字。\n- 查找第一个置位 (FFS) 操作能在常数时间内返回一个字中最低有效置位比特的索引。\n\n你将比较：\n1. 一个以字节形式存储的布尔数组（每个标志占一个字节），进行顺序扫描。\n2. 一个存储在 $64$ 位字中的紧凑位集；扫描使用字级操作和查找第一个置位 (FFS) 原语，通过对每个字的按位取反结果进行操作来枚举未完成进程的索引。\n\n假设：\n- 共有 $N = 4096$ 个进程。\n- 每个进程独立地以 $0.9$ 的概率完成，以 $0.1$ 的概率未完成。\n- 在字节数组表示法中，扫描每个条目会产生每个被检查条目 $c_b = 1$ 个操作的固定成本。此外，每次检测到一个未完成的进程时，处理它会产生 $c_u = 2$ 个操作的固定开销（例如，将索引入队以进行后续的准入检查）。同样的开销 $c_u$ 适用于两种表示方法。\n- 在位集表示法中：\n  - 位集被划分为连续的 $64$ 位字；将字的数量表示为 $W$。\n  - 对于每个 $64$ 位字，你执行一次 $64$ 位加载、一次按位取反和一次零测试，其每个操作的成本分别为 $c_L = 1$、$c_I = 1$ 和 $c_Z = 1$。\n  - 对于一个字内的每个未完成进程（在取反后的掩码中为 $1$ 的比特），除了共享开销 $c_u = 2$ 外，你还执行一次成本为 $c_F = 3$ 的 FFS 操作和一次成本为 $c_C = 1$ 的清除最低置位比特操作。\n- 使用独立性和期望的线性性质来处理期望；除了所述成本外，不要假设任何额外的分支或缓存惩罚。\n\n从第一性原理推导出每种表示方法在一次完整扫描中的预期总操作数，然后计算预期加速比\n$$S = \\frac{\\text{字节数组扫描的预期总操作数}}{\\text{位集扫描的预期总操作数}}。$$\n将 $S$ 报告为一个纯数。将你的答案四舍五入到四位有效数字。最终答案中不要包含任何单位。", "solution": "问题要求计算在银行家算法的安全性检查中，使用紧凑位集表示法相对于字节数组表示法处理 $Finish$ 数组所实现的预期加速比 $S$。加速比 $S$ 定义为单次扫描的预期总操作数之比。\n\n设 $E_B$ 为字节数组扫描的预期总操作数，$E_{BS}$ 为位集扫描的预期总操作数。加速比则为：\n$$S = \\frac{E_B}{E_{BS}}$$\n\n给定以下参数：\n- 进程数，$N = 4096$。\n- 一个进程已完成的概率，$p_{fin} = 0.9$。\n- 一个进程未完成的概率，$p_{unfin} = 1 - p_{fin} = 0.1$。\n- 检查字节数组中一个条目的成本，$c_b = 1$。\n- 处理一个未完成进程的开销成本，$c_u = 2$。\n- 机器字大小，$k = 64$ 比特。\n- 位集中的字数，$W = \\frac{N}{k} = \\frac{4096}{64} = 64$。\n- 一次 $64$ 位加载的成本，$c_L = 1$。\n- 一次按位取反操作的成本，$c_I = 1$。\n- 一次零测试的成本，$c_Z = 1$。\n- 一次查找第一个置位 (FFS) 操作的成本，$c_F = 3$。\n- 一次清除最低置位比特操作的成本，$c_C = 1$。\n\n首先，我们推导字节数组表示法的预期操作数 $E_B$。\n一次扫描的总成本 $C_B$ 是扫描所有条目的成本与为每个找到的未完成进程付出的额外开销之和。\n设 $N_{unfin}$ 是代表未完成进程总数的随机变量。\n总成本由以下表达式给出：\n$$C_B = N \\cdot c_b + N_{unfin} \\cdot c_u$$\n为了求得预期成本 $E_B = E[C_B]$，我们使用期望的线性性质：\n$$E_B = E[N \\cdot c_b + N_{unfin} \\cdot c_u] = N \\cdot c_b + E[N_{unfin}] \\cdot c_u$$\n未完成进程的期望数量 $E[N_{unfin}]$，可以通过考虑以下事实来求得：$N$ 个进程中的每一个都以概率 $p_{unfin}$ 独立地处于未完成状态。设 $X_i$ 是一个指示变量，如果进程 $i$ 未完成，则 $X_i=1$，否则 $X_i=0$。那么 $E[X_i] = 1 \\cdot P(X_i=1) + 0 \\cdot P(X_i=0) = p_{unfin}$。\n未完成进程的总数是 $N_{unfin} = \\sum_{i=1}^{N} X_i$。\n根据期望的线性性质：\n$$E[N_{unfin}] = E\\left[\\sum_{i=1}^{N} X_i\\right] = \\sum_{i=1}^{N} E[X_i] = N \\cdot p_{unfin}$$\n将此代回 $E_B$ 的表达式中：\n$$E_B = N \\cdot c_b + (N \\cdot p_{unfin}) \\cdot c_u$$\n代入给定值：\n$$E_B = 4096 \\cdot 1 + (4096 \\cdot 0.1) \\cdot 2 = 4096 + 409.6 \\cdot 2 = 4096 + 819.2 = 4915.2$$\n\n接下来，我们推导紧凑位集表示法的预期操作数 $E_{BS}$。\n总成本 $C_{BS}$ 是处理 $W$ 个字中每个字的成本与处理每个未完成进程的成本之和。\n对于 $W$ 个字中的每一个，都会执行一次加载、一次非操作和一次零测试。这部分的总成本是 $W \\cdot (c_L + c_I + c_Z)$。\n对于在整个位集中找到的每个未完成进程，会产生一次 FFS、一次清除最低置位比特操作和共享开销。每个未完成进程的成本是 $(c_F + c_C + c_u)$。\n总成本 $C_{BS}$ 是：\n$$C_{BS} = W \\cdot (c_L + c_I + c_Z) + N_{unfin} \\cdot (c_F + c_C + c_u)$$\n再次使用期望的线性性质来求得 $E_{BS} = E[C_{BS}]$：\n$$E_{BS} = W \\cdot (c_L + c_I + c_Z) + E[N_{unfin}] \\cdot (c_F + c_C + c_u)$$\n我们已经确定 $E[N_{unfin}] = N \\cdot p_{unfin}$。代入此式可得：\n$$E_{BS} = W \\cdot (c_L + c_I + c_Z) + (N \\cdot p_{unfin}) \\cdot (c_F + c_C + c_u)$$\n代入给定值：\n$$W = \\frac{4096}{64} = 64$$\n$$E_{BS} = 64 \\cdot (1 + 1 + 1) + (4096 \\cdot 0.1) \\cdot (3 + 1 + 2)$$\n$$E_{BS} = 64 \\cdot 3 + 409.6 \\cdot 6$$\n$$E_{BS} = 192 + 2457.6 = 2649.6$$\n\n最后，我们计算加速比 $S$：\n$$S = \\frac{E_B}{E_{BS}} = \\frac{4915.2}{2649.6}$$\n$$S \\approx 1.85507246...$$\n将结果四舍五入到四位有效数字，我们得到 $S = 1.855$。", "answer": "$$\\boxed{1.855}$$", "id": "3622562"}, {"introduction": "理论算法通常假设资源是离散的整数，但现实世界中的系统常常需要处理分数形式的资源，例如 CPU 时间片或网络带宽。本练习探讨了在银行家算法中使用定点数表示法所带来的挑战，特别是取整误差可能引发的正确性问题。通过推导一个最小安全边界，你将理解如何设计一个在面对数值精度限制时依然稳健的资源分配系统。[@problem_id:3622589]", "problem": "考虑一个使用银行家算法的系统，该系统有两种资源类型：中央处理器（CPU）份额和输入/输出（I/O）带宽。现有 $n=3$ 个进程，分别标记为 $P_1$、$P_2$ 和 $P_3$。数据结构定义如下：$Max[i]$ 是进程 $i$ 的最大需求向量，$Allocation[i]$ 是进程 $i$ 的当前分配向量，$Need[i]$ 是进程 $i$ 的剩余需求向量，定义为 $Need[i] = Max[i] - Allocation[i]$，$Available$ 是当前可用资源向量。银行家算法维护一个工作向量 $Work$，该向量初始化为 $Available$，并且每当进程 $i$ 完成时，更新 $Work := Work + Allocation[i]$。如果存在一个进程的排列，使得对于该排列中的每个进程 $i$，在考虑进程 $i$ 时，不等式 $Need[i] \\leq Work$ 按分量成立，则该状态被认为是安全的。\n\n假设分数资源表示为定点整数，比例因子为 $10^{k}$，其中 $k=2$（即，每个实数值 $v$ 内部表示为整数 $\\mathrm{round}(v \\cdot 10^{2})$，并在此整数域中进行算术比较）。$Available$、$Allocation[i]$、$Max[i]$ 和 $Need[i]$ 的所有分量都在此比例下通过四舍五入进行转换。具体来说，$Need[i]$ 首先在实数算术中计算为 $Max[i] - Allocation[i]$，然后四舍五入到比例为 $10^{2}$ 的最近定点整数。\n\n设初始的真实（实数）状态为\n- $Max[1] = (0.50, 0.40)$，$Allocation[1] = (0.20, 0.10)$\n- $Max[2] = (0.30, 0.50)$，$Allocation[2] = (0.10, 0.20)$\n- $Max[3] = (0.20, 0.30)$，$Allocation[3] = (0.05, 0.05)$\n- $Available = (0.40, 0.35)$\n\n假设我们在缩放和舍入之前，为 $Available$ 的每个分量增加一个安全裕度 $\\delta$，因此基于整数的算法使用的是 $Available + (\\delta,\\delta)$ 的表示。请根据银行家算法和定点舍入的核心定义，推导出 $\\delta$ 的精确最小值（以真实资源单位表示），该值能保证以下安全属性：如果基于整数的银行家算法（完全在比例为 $10^{2}$ 的定点整数表示上操作，并采用四舍五入）为此状态找到了一个安全序列，那么真实的份数状态也是安全的，无论舍入误差如何影响该序列中的每个比较和每个释放步骤。\n\n将最小的 $\\delta$ 表示为单个实数。除了从 $k=2$ 的精确算术中得出的结果外，最终值不需要进行舍入。[@problem_id:734]", "solution": "用户希望找到最小的安全裕度 $\\delta$，以确保如果运行在资源定点整数表示上的银行家算法找到了一个安全序列，那么真实的份数状态也保证是安全的。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件**\n- **系统：** 用于死锁避免的银行家算法。\n- **资源：** 2 种类型（CPU，I/O）。\n- **进程：** $n=3$ 个，标记为 $P_1、P_2、P_3$。\n- **数据结构：**\n    - $Max[i]$：进程 $i$ 的最大需求向量。\n    - $Allocation[i]$：进程 $i$ 的当前分配向量。\n    - $Need[i]$：剩余需求向量，定义为 $Need[i] = Max[i] - Allocation[i]$。\n    - $Available$：当前可用资源向量。\n    - $Work$：安全算法的工作向量。\n- **安全条件：** 一个状态是安全的，如果存在一个进程序列 $\\langle P_{p_1}, \\dots, P_{p_n} \\rangle$，使得对于序列中的每个进程 $P_{p_j}$，在其被考虑时，条件 $Need[p_j] \\leq Work$（按分量）成立，其中 $Work$ 初始化为 $Available$，并在 $P_{p_j}$ 完成后通过 $Work := Work + Allocation[p_j]$ 更新。\n- **定点算术：**\n    - 实数值 $v$ 表示为整数 $v_I = \\mathrm{round}(v \\cdot 10^{k})$，其中 $k=2$。所以 $v_I = \\mathrm{round}(v \\cdot 100)$。这意味着 $|v \\cdot 100 - v_I| \\leq 0.5$，或 $|v - v_I/100| \\leq 0.005$。\n    - 整数 $Need[i]$ 表示是通过首先计算实数 $Need[i]$ 向量，然后将其分量四舍五入到最近的整数表示来计算的。\n- **初始真实状态：**\n    - $Max[1] = (0.50, 0.40)$，$Allocation[1] = (0.20, 0.10)$\n    - $Max[2] = (0.30, 0.50)$，$Allocation[2] = (0.10, 0.20)$\n    - $Max[3] = (0.20, 0.30)$，$Allocation[3] = (0.05, 0.05)$\n    - $Available = (0.40, 0.35)$\n- **安全裕度：** 在缩放和舍入之前，为 $Available$ 的每个分量增加一个裕度 $\\delta$。整数算法使用 $Available + (\\delta, \\delta)$ 的整数表示。\n- **目标：** 找到 $\\delta$ 的精确最小值，使得：如果基于整数的算法找到了一个安全序列，那么真实的份数状态（使用原始 $Available$ 向量）也一定是安全的，无论舍入误差如何影响。\n\n**1.2. 使用提取的已知条件进行验证**\n- **科学依据：** 该问题基于银行家算法，这是操作系统中的一个标准课题。引入定点算术和舍入误差是实现此类算法时的一个实际问题，这使得该问题具有充分的科学依据。\n- **适定性：** 该问题要求找到一个最小值 $\\delta$，以保证一个特定的逻辑蕴含。这是一个定义明确的优化或约束问题。所有必要的定义和数据均已提供。\n- **客观性：** 该问题以精确、客观的语言陈述。术语都有定义，任务是进行形式化推导。\n\n**1.3. 结论与行动**\n问题是有效的。这是计算科学中一个非平凡且适定的问题。继续进行求解。\n\n### 步骤 2：求解推导\n\n设 $x_R$ 为一个实数值的资源量，$x_I$ 为其在比例为 $100$ 下的定点整数表示。舍入规则为 $x_I = \\mathrm{round}(100 \\cdot x_R)$。这意味着从整数重构实数值的误差是有界的：\n$$|x_R - \\frac{x_I}{100}| \\leq \\frac{0.5}{100} = 0.005$$\n我们将重构误差定义为 $\\epsilon_x = x_R - x_I/100$。其边界为 $|\\epsilon_x| \\leq 0.005$。因此，$x_R = x_I/100 + \\epsilon_x$。\n\n问题陈述道，如果基于整数的算法找到了一个安全序列，那么实数值系统也必须是安全的。设整数算法找到的安全序列为 $\\pi = \\langle P_{p_1}, P_{p_2}, ..., P_{p_n} \\rangle$。我们必须确保这个相同的序列对于实数值系统也是安全的。\n\n对于序列中的任何步骤 $j$（$j=1, \\dots, n$）以及每个资源分量（为清晰起见我们省略它，因为两者的逻辑是相同的），整数算法得以继续的条件是：\n$$N_{I, p_j} \\leq W_{I, j-1}$$\n其中 $W_{I, 0} = \\mathrm{round}(100 \\cdot (V_R + \\delta))$ 且对于 $j  1$，$W_{I, j-1} = W_{I, 0} + \\sum_{i=1}^{j-1} A_{I, p_i}$。\n\n我们必须为实数值系统保证的条件是：\n$$N_{R, p_j} \\leq W_{R, j-1}$$\n其中 $W_{R, 0} = V_R$ 且对于 $j  1$，$W_{R, j-1} = V_R + \\sum_{i=1}^{j-1} A_{R, p_i}$。\n\n让我们用整数值及其误差来表示实数值。\n真实需求为 $N_{R, p_j} = N_{I, p_j}/100 + \\epsilon_N$。\n在步骤 $j$ 的真实可用工作量为 $W_{R, j-1} = V_R + \\sum_{i=1}^{j-1} A_{R, p_i}$。让我们将其与整数工作量 $W_{I, j-1}$ 联系起来。\n和的组成部分是：\n$V_{R} + \\delta = W_{I, 0}/100 + \\epsilon_{V+\\delta} \\implies V_R = W_{I, 0}/100 - \\delta + \\epsilon_{V+\\delta}$\n$A_{R, p_i} = A_{I, p_i}/100 + \\epsilon_{A_i}$\n将这些相加：\n$$W_{R, j-1} = \\left(\\frac{W_{I, 0}}{100} - \\delta + \\epsilon_{V+\\delta}\\right) + \\sum_{i=1}^{j-1} \\left(\\frac{A_{I, p_i}}{100} + \\epsilon_{A_i}\\right)$$\n$$W_{R, j-1} = \\frac{1}{100} \\left(W_{I, 0} + \\sum_{i=1}^{j-1} A_{I, p_i}\\right) - \\delta + \\left(\\epsilon_{V+\\delta} + \\sum_{i=1}^{j-1} \\epsilon_{A_i}\\right)$$\n设 $W_{I,R,j-1} = W_{I,j-1}/100$。设 $E_j = \\epsilon_{V+\\delta} + \\sum_{i=1}^{j-1} \\epsilon_{A_i}$ 是构成可用工作量的 $j$ 个项的总累积误差。这个误差和的界是 $|E_j| \\leq j \\cdot 0.005$。\n因此，$W_{R, j-1} = W_{I,R,j-1} - \\delta + E_j$。\n\n现在，我们将这些表达式代入我们必须保证的不等式 $N_{R, p_j} \\leq W_{R, j-1}$ 中：\n$$\\frac{N_{I, p_j}}{100} + \\epsilon_N \\leq \\frac{W_{I, j-1}}{100} - \\delta + E_j$$\n我们正在寻找最小的 $\\delta$，以确保在 $N_{I, p_j} \\leq W_{I, j-1}$ 的条件下此不等式成立。让我们重新排列以找到 $\\delta$ 的一个下界：\n$$\\delta \\geq \\frac{N_{I, p_j} - W_{I, j-1}}{100} + \\epsilon_N - E_j$$\n关于 $\\delta$ 的这个不等式必须“无论舍入误差如何影响每个比较”都成立。这意味着我们必须找到一个大于或等于右侧（RHS）最大可能值的 $\\delta$，并考虑到所有可能的舍入误差值和所有有效的整数检查。\n\n设 $\\Delta_I = W_{I, j-1} - N_{I, p_j}$。从整数安全检查中，我们知道 $\\Delta_I \\geq 0$。不等式变为：\n$$\\delta \\geq \\frac{-\\Delta_I}{100} + \\epsilon_N - E_j$$\n为了找到 $\\delta$ 所需的下界，我们在所有可能性上最大化右侧：\n$$\\max_{\\text{errors, }\\Delta_I} \\left(\\frac{-\\Delta_I}{100} + \\epsilon_N - E_j\\right) = \\max_{\\Delta_I \\geq 0} \\left(\\frac{-\\Delta_I}{100}\\right) + \\max(\\epsilon_N) - \\min(E_j)$$\n1.  当 $\\Delta_I$ 最小时，项 $\\frac{-\\Delta_I}{100}$ 最大化。由于 $\\Delta_I$ 是一个非负整数，其最小值为 $0$。这对应于最紧凑的整数检查，即 $N_{I, p_j} = W_{I, j-1}$。\n2.  单个 $Need$ 分量的误差 $\\epsilon_N$ 在 $\\max(\\epsilon_N) = 0.005$ 时最大化。\n3.  累积误差 $E_j$ 是 $j$ 个单个误差项的和，每个误差项都在 $[-0.005, 0.005]$ 范围内。当每个项都取最小值时，$E_j$ 的和最小化：$\\min(E_j) = j \\cdot (-0.005) = -0.005j$。\n\n代入这些最坏情况下的值：\n$$\\delta \\geq \\frac{-0}{100} + 0.005 - (-0.005j)$$\n$$\\delta \\geq 0.005 + 0.005j$$\n$$\\delta \\geq 0.005(j+1)$$\n这个条件必须对任何潜在安全序列的任何步骤 $j$ 都成立。对于 $n=3$ 个进程，一个安全序列最多可以有 $3$ 个步骤，所以 $j$ 可以是 $1$、$2$ 或 $3$。为了确保该条件对所有可能的步骤都成立，我们必须满足最严格的要求，这对应于 $j$ 的最大值。\n$j$ 的最大值是 $n=3$。对于 $j=3$，条件是：\n$$\\delta \\geq 0.005(3+1)$$\n$$\\delta \\geq 0.005(4)$$\n$$\\delta \\geq 0.02$$\n满足此条件，适用于所有可能情景（任何安全序列、任何步骤 $j$、任何分量以及任何舍入组合）的 $\\delta$ 的最小值是 $0.02$。所提供的特定初始状态值对于此最坏情况推导不是必需的，但它们确认了在给定规则下安全状态可以存在。", "answer": "$$\\boxed{0.02}$$", "id": "3622589"}]}