{"hands_on_practices": [{"introduction": "理论知识只有通过实践才能变得生动。这个练习将带你一步步模拟资源分配图（RAG）随时间演变的过程。通过跟踪一系列请求和分配事件，你将亲眼见证一个循环——也就是死锁条件——是如何在系统中逐步形成的，从而对死锁的产生建立起直观的认识。[@problem_id:3677751]", "problem": "一个操作系统 (OS) 维护一个资源分配图 (RAG)，其中进程和资源作为节点。进程 $P_i$ 绘制为圆形，资源 $R_j$ 绘制为方形。一条有向边 $P_i \\rightarrow R_j$ 是请求边，表示进程 $P_i$ 正在等待资源 $R_j$。一条有向边 $R_j \\rightarrow P_i$ 是分配边，表示资源 $R_j$ 当前已分配给进程 $P_i$。一条声明边 $P_i \\rightarrow R_j$ 表示进程 $P_i$ 将来可能会请求 $R_j$；声明边在请求发出之前存在，当进程实际请求该资源时，它会转换成请求边。如果请求被批准且资源空闲，请求边会转换为分配边；如果资源不空闲，请求边将保持不变。当一个进程释放资源时，分配边 $R_j \\rightarrow P_i$ 被移除，相应的声明边 $P_i \\rightarrow R_j$ 会被恢复。在每种资源类型只有一个实例的系统中，请求边和分配边之间存在有向环是死锁的充分必要条件。\n\n考虑三个进程 $P_1, P_2, P_3$ 和两个资源 $R_a, R_b$，每个资源只有一个实例。在时间 $t=0$ 时的初始声明边如下：\n- $P_1 \\rightarrow R_a$, $P_1 \\rightarrow R_b$,\n- $P_2 \\rightarrow R_a$, $P_2 \\rightarrow R_b$,\n- $P_3 \\rightarrow R_b$.\n\n系统随后在离散时间片 $t=1,2,3,\\dots$ 中根据以下事件演化。在每个时间点 $t$，如果资源是空闲的，操作系统会立即批准请求；否则，请求边被添加并保持存在，直到资源变为空闲。不应用任何死锁避免决策。\n\n- 在 $t=1$ 时，$P_1$ 发出对 $R_a$ 的请求。\n- 在 $t=2$ 时，$P_2$ 发出对 $R_b$ 的请求。\n- 在 $t=3$ 时，$P_1$ 发出对 $R_b$ 的请求。\n- 在 $t=4$ 时，$P_2$ 发出对 $R_a$ 的请求。\n- 在 $t=5$ 时，$P_3$ 发出对 $R_b$ 的请求。\n\n假设在 $t \\in \\{1,2,3,4,5\\}$ 期间没有资源释放发生。根据本问题的约定，在判断是否存在环时，只考虑请求边和分配边，忽略声明边。\n\n仅使用上述基本定义和给定的事件序列，确定请求边和分配边构成的图中首次出现有向环的最小正整数 $t^\\*$。将 $t^\\*$ 报告为一个精确整数，不带单位。无需四舍五入。", "solution": "问题要求我们确定在一个给定的进程和资源系统中，资源分配图 (RAG) 中首次出现有向环的最小正整数时间，记为 $t^\\*$。RAG 由进程节点 $\\{P_1, P_2, P_3\\}$、资源节点 $\\{R_a, R_b\\}$ 以及两种与环检测相关的有向边组成：请求边 ($P_i \\rightarrow R_j$) 和分配边 ($R_j \\rightarrow P_i$)。根据问题陈述，对于每个都只有一个实例的资源，这种环的存在是死锁的充分必要条件。我们将根据指定的事件序列，逐步追踪 RAG 的演化过程。\n\n设时间 $t$ 时图中请求边和分配边的集合为 $E_t$。\n\n**$t=0$ 时的初始状态：**\n系统开始时有三个进程 $P_1, P_2, P_3$ 和两个单实例资源 $R_a$ 和 $R_b$。两个资源最初都是空闲和可用的。没有活动的请求或分配。\n- 边集：$E_0 = \\emptyset$。\n- 图中没有边，因此没有环。\n\n**时间步 $t=1$：**\n- **事件：** 进程 $P_1$ 发出对资源 $R_a$ 的请求。\n- **分析：** 此时，资源 $R_a$ 是空闲的。根据规则，操作系统立即批准该请求。此操作将临时的请求边转换为永久的分配边。\n- **状态更新：** 一条分配边 $R_a \\rightarrow P_1$ 被添加到图中。资源 $R_a$ 现在已分配给 $P_1$。\n- **边集：** $E_1 = \\{R_a \\rightarrow P_1\\}$。\n- **环检测：** 图中只有一条边。无法形成有向环。\n\n**时间步 $t=2$：**\n- **事件：** 进程 $P_2$ 发出对资源 $R_b$ 的请求。\n- **分析：** 资源 $R_b$ 是空闲的。该请求被立即批准。\n- **状态更新：** 一条分配边 $R_b \\rightarrow P_2$ 被添加到图中。资源 $R_b$ 现在已分配给 $P_2$。\n- **边集：** $E_2 = \\{R_a \\rightarrow P_1, R_b \\rightarrow P_2\\}$。\n- **环检测：** 该图由两条长度为1的不相交路径组成。不存在有向环。\n\n**时间步 $t=3$：**\n- **事件：** 进程 $P_1$ 发出对资源 $R_b$ 的请求。\n- **分析：** 资源 $R_b$ 不空闲；它当前已分配给进程 $P_2$（由边 $R_b \\rightarrow P_2$ 表示）。该请求无法被批准。\n- **状态更新：** 一条请求边 $P_1 \\rightarrow R_b$ 被添加到图中，表示 $P_1$ 现在正在等待 $R_b$。\n- **边集：** $E_3 = \\{R_a \\rightarrow P_1, R_b \\rightarrow P_2, P_1 \\rightarrow R_b\\}$。\n- **环检测：** 我们可以从现有的分配边 $R_a \\rightarrow P_1$ 追踪到新的请求边 $P_1 \\rightarrow R_b$，然后再到另一条分配边 $R_b \\rightarrow P_2$。这构成了一条有向路径 $R_a \\rightarrow P_1 \\rightarrow R_b \\rightarrow P_2$。没有从 $P_2$ 指向该路径中任何已有节点的边。因此，不存在有向环。\n\n**时间步 $t=4$：**\n- **事件：** 进程 $P_2$ 发出对资源 $R_a$ 的请求。\n- **分析：** 资源 $R_a$ 不空闲；它当前已分配给进程 $P_1$（由边 $R_a \\rightarrow P_1$ 表示）。该请求无法被批准。\n- **状态更新：** 一条请求边 $P_2 \\rightarrow R_a$ 被添加到图中，表示 $P_2$ 现在正在等待 $R_a$。\n- **边集：** $E_4 = \\{R_a \\rightarrow P_1, R_b \\rightarrow P_2, P_1 \\rightarrow R_b, P_2 \\rightarrow R_a\\}$。\n- **环检测：** 让我们检查图中的路径。\n  1. 进程 $P_1$ 正在等待资源 $R_b$：这是边 $P_1 \\rightarrow R_b$。\n  2. 资源 $R_b$ 被进程 $P_2$ 持有：这是边 $R_b \\rightarrow P_2$。\n  3. 进程 $P_2$ 正在等待资源 $R_a$：这是新边 $P_2 \\rightarrow R_a$。\n  4. 资源 $R_a$ 被进程 $P_1$ 持有：这是边 $R_a \\rightarrow P_1$。\n组合这些边，我们可以构建以下节点和边的序列：$P_1 \\rightarrow R_b \\rightarrow P_2 \\rightarrow R_a \\rightarrow P_1$。这个序列形成了一个闭环，即 RAG 中的一个有向环。这个环涉及到进程 $P_1$ 和 $P_2$ 以及资源 $R_a$ 和 $R_b$。具体来说，$P_1$ 持有 $R_a$ 并请求 $R_b$，而 $P_2$ 持有 $R_b$ 并请求 $R_a$，这是一个典型的死锁条件。\n\n由于有向环在 $t=4$ 时首次出现，这就是我们所寻求的值。分析可以在这里终止，因为问题要求的是最小的此类正整数。\n\n请求边和分配边构成的图中首次出现有向環的最小正整数 $t^\\*$ 是 $4$。", "answer": "$$\\boxed{4}$$", "id": "3677751"}, {"introduction": "知道“循环”意味着死锁是一回事，但操作系统如何高效地“检测”到这个循环呢？本练习将理论与算法实践相结合，指导你使用深度优先搜索（DFS）这一核心图算法来执行资源分配图的循环检查。这让你不仅仅是理解概念，更是掌握了实现死锁避免机制的关键技术。[@problem_id:3677764]", "problem": "给定一个有向二部图 $G$，它代表一个资源分配图 (RAG)。进程节点为 $\\{P_1, P_2, P_3\\}$，资源节点为 $\\{R_a, R_b, R_c\\}$。所有资源都是单实例的。边 $R_x \\to P_y$ 表示将资源 $R_x$ 分配给进程 $P_y$，边 $P_y \\to R_x$ 表示进程 $P_y$ 请求资源 $R_x$。$G$ 当前的邻接表（邻居的探索顺序与列表顺序完全一致）如下：\n- $P_1: [R_b]$\n- $P_2: [\\,]$\n- $P_3: [R_a]$\n- $R_a: [P_1]$\n- $R_b: [P_2]$\n- $R_c: [P_3]$\n\n现提议添加一条请求边 $P_2 \\to R_c$。使用深度优先搜索 (DFS)，在添加边 $P_2 \\to R_c$ 后，立即从 $P_2$ 开始执行实时周期检测。在DFS中，邻居节点按所提供列表的精确顺序进行探索，并使用颜色状态法来检测周期（白色 = 未访问，灰色 = 已发现且在当前递归栈中，黑色 = 已完成）。如果遇到指向灰色节点的回边，则在单实例假设下系统是不安全的，该请求必须被拒绝。\n\n定义 $L$ 为在添加 $P_2 \\to R_c$ 后从 $P_2$ 开始的DFS通过回边检测到的第一个简单有向环的长度（不同有向边的数量）。计算 $L$。将最终答案表示为一个不带单位的整数。", "solution": "第一步是构建添加新请求边后的资源分配图 (RAG) 的状态。\n顶点集合为 $V = \\{P_1, P_2, P_3, R_a, R_b, R_c\\}$。\n基于问题的邻接表，初始的边如下：\n- 请求边 (进程 $\\to$ 资源): $(P_1, R_b)$, $(P_3, R_a)$。\n- 分配边 (资源 $\\to$ 进程): $(R_a, P_1)$, $(R_b, P_2)$, $(R_c, P_3)$。\n添加一条新的请求边 $(P_2, R_c)$。\n图 $G$ 中完整的有向边集合为 $E = \\{(P_1, R_b), (P_3, R_a), (R_a, P_1), (R_b, P_2), (R_c, P_3), (P_2, R_c)\\}$。\n$P_2$ 更新后的邻接表为 $P_2: [R_c]$。\n\n接下来，我们从节点 $P_2$ 开始执行深度优先搜索 (DFS) 来检测周期。我们将跟踪每个节点的颜色（初始为白色）和每个节点在DFS树中的父节点。\n\n1.  **初始化**: 对所有 $v \\in V$，`color[v] = WHITE`。对所有 $v \\in V`，`parent[v] = NULL`。\n2.  **开始DFS**: 调用 `DFS-Visit(P_2)`。\n\n**`DFS-Visit` 的追踪过程：**\n\n- **调用 `DFS-Visit(P_2)`**：\n    - 设置 `color[P_2] = GRAY`。\n    - `parent[P_2] = NULL`。\n    - 探索 $P_2$ 的邻居。邻接表为 $[R_c]$。\n    - 邻居是 $R_c$。`color[R_c]` 是白色。这是一条树边。\n    - 设置 `parent[R_c] = P_2`。\n    - 递归调用 `DFS-Visit(R_c)`。\n\n- **调用 `DFS-Visit(R_c)`**：\n    - 设置 `color[R_c] = GRAY`。\n    - 探索 $R_c$ 的邻居。邻接表为 $[P_3]$。\n    - 邻居是 $P_3$。`color[P_3]` 是白色。这是一条树边。\n    - 设置 `parent[P_3] = R_c`。\n    - 递归调用 `DFS-Visit(P_3)`。\n\n- **调用 `DFS-Visit(P_3)`**：\n    - 设置 `color[P_3] = GRAY`。\n    - 探索 $P_3$ 的邻居。邻接表为 $[R_a]$。\n    - 邻居是 $R_a$。`color[R_a]` 是白色。这是一条树边。\n    - 设置 `parent[R_a] = P_3`。\n    - 递归调用 `DFS-Visit(R_a)`。\n\n- **调用 `DFS-Visit(R_a)`**：\n    - 设置 `color[R_a] = GRAY`。\n    - 探索 $R_a$ 的邻居。邻接表为 $[P_1]$。\n    - 邻居是 $P_1$。`color[P_1]` 是白色。这是一条树边。\n    - 设置 `parent[P_1] = R_a`。\n    - 递归调用 `DFS-Visit(P_1)`。\n\n- **调用 `DFS-Visit(P_1)`**：\n    - 设置 `color[P_1] = GRAY`。\n    - 探索 $P_1$ 的邻居。邻接表为 $[R_b]$。\n    - 邻居是 $R_b$。`color[R_b]` 是白色。这是一条树边。\n    - 设置 `parent[R_b] = P_1`。\n    - 递归调用 `DFS-Visit(R_b)`。\n\n- **调用 `DFS-Visit(R_b)`**：\n    - 设置 `color[R_b] = GRAY`。\n    - 探索 $R_b$ 的邻居。邻接表为 $[P_2]$。\n    - 邻居是 $P_2$。`color[P_2]` 是灰色。\n    - 由于 $P_2$ 是一个灰色节点，边 $(R_b, P_2)$ 是一条回边。检测到了一个周期。DFS算法终止搜索并报告该周期。\n\n第一个周期在发现回边 $(R_b, P_2)$ 时被检测到。该周期由这条边以及DFS树中从目标节点 $P_2$到源节点 $R_b$ 的路径组成。我们可以通过从 $R_b$ 回溯 `parent` 指针到 $P_2$ 来重建这条路径。\n\n- `parent[R_b] = P_1`\n- `parent[P_1] = R_a`\n- `parent[R_a] = P_3`\n- `parent[P_3] = R_c`\n- `parent[R_c] = P_2`\n\n从 $P_2$ 到 $R_b$ 的路径是 $P_2 \\to R_c \\to P_3 \\to R_a \\to P_1 \\to R_b$。\n追加回边 $(R_b, P_2)$ 闭合了该周期：\n$P_2 \\to R_c \\to P_3 \\to R_a \\to P_1 \\to R_b \\to P_2$。\n\n问题要求计算 $L$，即这个周期的长度，也就是它所包含的不同有向边的数量。这些边是：\n1. $(P_2, R_c)$\n2. $(R_c, P_3)$\n3. $(P_3, R_a)$\n4. $(R_a, P_1)$\n5. $(P_1, R_b)$\n6. $(R_b, P_2)$\n\n这个简单有向环中有 $6$ 条边。因此，长度 $L$ 为 $6$。", "answer": "$$\\boxed{6}$$", "id": "3677764"}, {"introduction": "在真实的操作系统中，调度器需要不断地根据当前系统状态评估并决策是否批准新的资源请求。这个练习模拟了这样一个决策场景，要求你在一个已存在复杂依赖关系的系统中，对多个潜在请求逐一应用死锁避免规则。这能有效检验你是否能准确地在复杂情况下运用循环检测原则来保障系统的安全性。[@problem_id:3677767]", "problem": "您正在测试资源分配图 (RAG) 算法，用于在每种资源类型只有一个实例的情况下进行死锁避免。考虑一个系统，其中包含进程 $P_1, P_2, P_3, P_4, P_5$ 和资源 $R_1, R_2, R_3, R_4, R_5$，每种资源恰好有一个实例。当前的图包含以下分配边（资源到进程）和请求边（进程到资源）：\n- 分配边：$R_1 \\to P_2$，$R_2 \\to P_3$，$R_3 \\to P_4$，$R_4 \\to P_5$，$R_5 \\to P_1$。\n- 请求边：$P_1 \\to R_1$，$P_2 \\to R_2$，$P_3 \\to R_3$，$P_4 \\to R_4$。\n\n对于接下来可能发出的以下潜在请求，存在预约边（即，这些是唯一可以添加的额外请求边）：$P_5 \\to R_5$，$P_3 \\to R_5$，$P_5 \\to R_2$，$P_2 \\to R_4$，$P_4 \\to R_1$。除了已有的请求边和这些潜在请求，系统中不存在其他预约边。\n\n观察到当前图中包含一条长度为 $L = 8$ 条边的简单路径：\n$$\nP_1 \\to R_1 \\to P_2 \\to R_2 \\to P_3 \\to R_3 \\to P_4 \\to R_4 \\to P_5,\n$$\n这条路径目前还不是一个环，但如果增加一条合适的额外边，它将成为一个环。\n\n根据资源分配图算法的死锁避免规则（即，拒绝任何会导致在图中形成环的请求），确定所列出的待处理请求中有多少个必须被拒绝，因为它们的加入会将现有路径扩展成一个环。请将您的最终答案表示为整数 $D$。无需四舍五入。", "solution": "该问题要求我们分析一组潜在的资源请求，并逐一确定批准该请求是否会在资源分配图中形成环。在一个每种资源类型只有一个实例的系统中，RAG 死锁避免算法规定，一个由进程 $P_i$ 对资源 $R_j$ 发出的请求（表示为请求边 $P_i \\to R_j$），只有在向图中添加这条边不会形成环的情况下才能被批准。如果图中已存在一条从资源 $R_j$ 到进程 $P_i$ 的路径，那么就会形成环。\n\n首先，让我们表示系统的当前状态图，该图由进程 $P_k$、资源 $R_k$ 和现有边组成。\n\n进程集合为 $\\mathcal{P} = \\{P_1, P_2, P_3, P_4, P_5\\}$。\n资源集合为 $\\mathcal{R} = \\{R_1, R_2, R_3, R_4, R_5\\}$。\n\n图中当前的边如下：\n1.  **分配边**（资源被进程持有）：\n    - $R_1 \\to P_2$（$P_2$ 持有 $R_1$）\n    - $R_2 \\to P_3$（$P_3$ 持有 $R_2$）\n    - $R_3 \\to P_4$（$P_4$ 持有 $R_3$）\n    - $R_4 \\to P_5$（$P_5$ 持有 $R_4$）\n    - $R_5 \\to P_1$（$P_1$ 持有 $R_5$）\n2.  **请求边**（进程等待资源）：\n    - $P_1 \\to R_1$（$P_1$ 等待 $R_1$）\n    - $P_2 \\to R_2$（$P_2$ 等待 $R_2$）\n    - $P_3 \\to R_3$（$P_3$ 等待 $R_3$）\n    - $P_4 \\to R_4$（$P_4$ 等待 $R_4$）\n\n当前图不包含环。它包含一条长路径，如问题陈述中所述：$P_1 \\to R_1 \\to P_2 \\to R_2 \\to P_3 \\to R_3 \\to P_4 \\to R_4 \\to P_5$。\n\n我们现在必须评估五个潜在请求中的每一个，看其加入是否会闭合一个环。\n\n**1. 请求：$P_5 \\to R_5$**\n为检查此请求是否会形成环，我们必须确定是否存在一条从资源 $R_5$ 到进程 $P_5$ 的现有路径。\n- 从 $R_5$ 出发的路径：$R_5 \\to P_1$（分配）\n- 从 $P_1$ 出发的路径：$P_1 \\to R_1$（请求）\n- 从 $R_1$ 出发的路径：$R_1 \\to P_2$（分配）\n- 从 $P_2$ 出发的路径：$P_2 \\to R_2$（请求）\n- 从 $R_2$ 出发的路径：$R_2 \\to P_3$（分配）\n- 从 $P_3$ 出发的路径：$P_3 \\to R_3$（请求）\n- 从 $R_3$ 出发的路径：$R_3 \\to P_4$（分配）\n- 从 $P_4$ 出发的路径：$P_4 \\to R_4$（请求）\n- 从 $R_4$ 出发的路径：$R_4 \\to P_5$（分配）\n将这些边连接起来，我们找到了路径：$R_5 \\to P_1 \\to R_1 \\to P_2 \\to R_2 \\to P_3 \\to R_3 \\to P_4 \\to R_4 \\to P_5$。\n由于存在从 $R_5$ 到 $P_5$ 的路径，添加边 $P_5 \\to R_5$ 将会形成一个环。\n**结论：拒绝。**\n\n**2. 请求：$P_3 \\to R_5$**\n我们检查是否存在从 $R_5$ 到 $P_3$ 的现有路径。\n- 从 $R_5$ 出发的路径：$R_5 \\to P_1$（分配）\n- 从 $P_1$ 出发的路径：$P_1 \\to R_1$（请求）\n- 从 $R_1$ 出发的路径：$R_1 \\to P_2$（分配）\n- 从 $P_2$ 出发的路径：$P_2 \\to R_2$（请求）\n- 从 $R_2$ 出发的路径：$R_2 \\to P_3$（分配）\n路径为 $R_5 \\to P_1 \\to R_1 \\to P_2 \\to R_2 \\to P_3$。\n存在一条从 $R_5$ 到 $P_3$ 的路径。添加边 $P_3 \\to R_5$ 将会形成一个环。\n**结论：拒绝。**\n\n**3. 请求：$P_5 \\to R_2$**\n我们检查是否存在从 $R_2$ 到 $P_5$ 的现有路径。\n- 从 $R_2$ 出发的路径：$R_2 \\to P_3$（分配）\n- 从 $P_3$ 出发的路径：$P_3 \\to R_3$（请求）\n- 从 $R_3$ 出发的路径：$R_3 \\to P_4$（分配）\n- 从 $P_4$ 出发的路径：$P_4 \\to R_4$（请求）\n- 从 $R_4$ 出发的路径：$R_4 \\to P_5$（分配）\n路径为 $R_2 \\to P_3 \\to R_3 \\to P_4 \\to R_4 \\to P_5$。\n存在一条从 $R_2$ 到 $P_5$ 的路径。添加边 $P_5 \\to R_2$ 将会形成一个环。\n**结论：拒绝。**\n\n**4. 请求：$P_2 \\to R_4$**\n我们检查是否存在从 $R_4$ 到 $P_2$ 的现有路径。\n- 从 $R_4$ 出发的唯一出边是分配边 $R_4 \\to P_5$。\n- 从 $P_5$ 出发，在当前图中没有出边（因为 $P_5$ 当前没有请求任何资源）。\n因此，不存在从 $R_4$ 到任何其他进程（包括 $P_2$）的路径。添加边 $P_2 \\to R_4$ 不会形成环。\n**结论：批准。**\n\n**5. 请求：$P_4 \\to R_1$**\n我们检查是否存在从 $R_1$ 到 $P_4$ 的现有路径。\n- 从 $R_1$ 出发的路径：$R_1 \\to P_2$（分配）\n- 从 $P_2$ 出发的路径：$P_2 \\to R_2$（请求）\n- 从 $R_2$ 出发的路径：$R_2 \\to P_3$（分配）\n- 从 $P_3$ 出发的路径：$P_3 \\to R_3$（请求）\n- 从 $R_3$ 出发的路径：$R_3 \\to P_4$（分配）\n路径为 $R_1 \\to P_2 \\to R_2 \\to P_3 \\to R_3 \\to P_4$。\n存在一条从 $R_1$ 到 $P_4$ 的路径。添加边 $P_4 \\to R_1$ 将会形成一个环。\n**结论：拒绝。**\n\n总结如下：\n- 请求 $P_5 \\to R_5$：拒绝\n- 请求 $P_3 \\to R_5$：拒绝\n- 请求 $P_5 \\to R_2$：拒绝\n- 请求 $P_2 \\to R_4$：批准\n- 请求 $P_4 \\to R_1$：拒绝\n\n必须拒绝的请求数量 $D$ 是“拒绝”结论的计数。我们有 4 个这样的请求。\n因此，$D=4$。", "answer": "$$\n\\boxed{4}\n$$", "id": "3677767"}]}