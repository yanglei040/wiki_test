{"hands_on_practices": [{"introduction": "终止进程是另一种主要的死锁恢复方法。其中最关键的决策是选择哪个进程作为“牺牲品”，以最小化对整个系统的代价。本练习将演示如何使用加权评分函数——一种常见的启发式方法——来权衡进程优先级、已占用资源和重启代价等多个因素，从而做出明智的选择 ([@problem_id:3676663])。", "problem": "考虑一个必须通过进程终止或资源抢占来从检测到的死锁中恢复的操作系统（OS）。使用以下基本事实和定义作为基本出发点。当且仅当资源分配图中存在有向环时，才会出现死锁。在从死锁中恢复时，一个共同的目标是通过平衡几个考虑因素来选择一个牺牲进程，以最小化总恢复影响：预期的回滚或重启成本、抢占能在多大程度上释放足够资源以打破循环，以及由进程优先级反映出的管理或服务重要性。令 $D$ 表示死锁进程的集合。对于每个 $i \\in D$，令 $c_i$ 为一个无量纲的回滚成本指数，令 $h_i$ 为当前持有的资源实例总数，令 $\\pi_i$ 为数字优先级，其中较小的数值表示较高的优先级。假设存在由系统管理员选择的严格为正的无量纲权重 $\\lambda$、$\\mu$ 和 $\\nu$，分别用来编码回滚成本、持有资源和优先级的相对重要性。\n\n任务 $1$ (推导)：从给定的基本事实和定义出发，为进程 $i$ 推导一个线性的牺牲进程选择分数。该分数应与倾向于终止回滚成本较小、持有资源较少和优先级较低（即数字优先级 $\\pi_i$ 较大）的进程的目标相一致，并且可以通过最小化该分数来选择牺牲进程。请提供用 $\\lambda$、$\\mu$、$\\nu$、$c_i$、$h_i$ 和 $\\pi_i$ 表示的分数的符号表达式。\n\n任务 $2$ (应用)：在以下具体的死锁实例上测试你推导出的分数。有资源类型 $R_A$、$R_B$ 和 $R_C$，每种各有 $1$ 个实例；以及第四种资源类型 $R_D$，有 $2$ 个实例。有三个进程 $P_1$、$P_2$ 和 $P_3$，它们的持有和请求情况如下：\n- $P_1$ 持有 $R_A$ 和 $1$ 个 $R_D$ 实例；$P_1$ 请求 $R_B$。\n- $P_2$ 持有 $R_B$；$P_2$ 请求 $R_C$。\n- $P_3$ 持有 $R_C$ 和 $1$ 个 $R_D$ 实例；$P_3$ 请求 $R_A$。\n这在 $P_1$、$P_2$ 和 $P_3$ 之间形成了一个死锁环。各指数为 $c_1 = 1.8$，$h_1 = 2$，$\\pi_1 = 2$；$c_2 = 1.2$，$h_2 = 1$，$\\pi_2 = 4$；$c_3 = 2.6$，$h_3 = 2$，$\\pi_3 = 1$。使用权重 $\\lambda = 0.6$，$\\mu = 0.8$ 和 $\\nu = 0.5$。计算 $D$ 中每个进程的牺牲分数，通过最小化分数来确定牺牲进程，并报告所选牺牲进程分数的数值。\n\n将你的最终数值答案表示为一个无量纲标量，并四舍五入到四位有效数字。", "solution": "该问题是有效的，因为它在操作系统原理，特别是死锁恢复启发式算法方面有科学依据，并且问题设定良好，具有一套完整且一致的数据和目标。\n\n**任务 1：牺牲进程选择分数的推导**\n\n目标是为死锁进程集合 $D$ 中的一个进程 $i$ 推导出一个线性分数，我们将其记为 $S_i$。该分数的公式必须使得其最小化能够选出一个与给定目标一致的牺牲进程。该分数将是进程的回滚成本指数 $c_i$、其持有的资源实例总数 $h_i$ 以及其数字优先级 $\\pi_i$ 的线性组合。该组合将由严格为正的无量纲常数 $\\lambda$、$\\mu$ 和 $\\nu$ 加权。\n\n选择标准是最小化分数 $S_i$。因此，使一个进程成为更理想牺牲者的因素应导致较低的分数，而使其成为不那么理想的牺牲者的因素应导致较高的分数。\n\n$1$。 **回滚成本 ($c_i$)**：目标是倾向于终止具有*较小*回滚成本的进程。这意味着具有较大回滚成本指数 $c_i$ 的进程是一个较差的牺牲者选择，因此应具有较高的分数。因此，分数 $S_i$ 必须是 $c_i$ 的增函数。对分数有贡献的线性项因此与 $c_i$ 成正比，并由其重要性因子 $\\lambda$ 加权。该项为 $+\\lambda c_i$。\n\n$2$。 **持有资源 ($h_i$)**：目标是倾向于终止持有*较少*资源的进程。一个持有大量资源 $h_i$ 的进程是一个不那么理想的牺牲者，应具有较高的分数。因此，分数 $S_i$ 也必须是 $h_i$ 的增函数。该因素的线性项与 $h_i$ 成正比，并由 $\\mu$ 加权。该项为 $+\\mu h_i$。\n\n$3$。 **优先级 ($\\pi_i$)**：目标是倾向于终止*较低*优先级的进程。问题定义*较大*的 $\\pi_i$ 数值对应于较低的优先级。因此，具有较大 $\\pi_i$ 的进程是一个更理想的牺牲者，应具有*较低*的分数以便在最小化过程中被选中。这意味着分数 $S_i$ 必须是 $\\pi_i$ 的减函数。为了在线性模型中实现这一点，涉及 $\\pi_i$ 的项必须有一个负系数。权重 $\\nu$ 代表了优先级的重要性，并且由于 $\\nu$ 是严格为正的，该项必须构造为 $-\\nu \\pi_i$。\n\n结合这三个项，得到进程 $i$ 的总线性牺牲进程选择分数：\n$$S_i = \\lambda c_i + \\mu h_i - \\nu \\pi_i$$\n这个表达式关于 $c_i$、$h_i$ 和 $\\pi_i$ 是线性的，并且最小化它满足了所有陈述的牺牲进程选择目标。\n\n**任务 2：应用于具体实例**\n\n我们现在将推导出的分数函数应用于给定的死锁场景。死锁进程的集合是 $D = \\{P_1, P_2, P_3\\}$。\n\n给定的权重是：\n$\\lambda = 0.6$\n$\\mu = 0.8$\n$\\nu = 0.5$\n\n每个进程的参数是：\n- 对于 $P_1$：$c_1 = 1.8$，$h_1 = 2$，$\\pi_1 = 2$。\n- 对于 $P_2$：$c_2 = 1.2$，$h_2 = 1$，$\\pi_2 = 4$。\n- 对于 $P_3$：$c_3 = 2.6$，$h_3 = 2$，$\\pi_3 = 1$。\n\n我们为每个进程计算分数 $S_i$。\n\n**进程 $P_1$ 的分数**：\n$S_1 = \\lambda c_1 + \\mu h_1 - \\nu \\pi_1$\n$S_1 = (0.6)(1.8) + (0.8)(2) - (0.5)(2)$\n$S_1 = 1.08 + 1.6 - 1.0$\n$S_1 = 1.68$\n\n**进程 $P_2$ 的分数**：\n$S_2 = \\lambda c_2 + \\mu h_2 - \\nu \\pi_2$\n$S_2 = (0.6)(1.2) + (0.8)(1) - (0.5)(4)$\n$S_2 = 0.72 + 0.8 - 2.0$\n$S_2 = 1.52 - 2.0$\n$S_2 = -0.48$\n\n**进程 $P_3$ 的分数**：\n$S_3 = \\lambda c_3 + \\mu h_3 - \\nu \\pi_3$\n$S_3 = (0.6)(2.6) + (0.8)(2) - (0.5)(1)$\n$S_3 = 1.56 + 1.6 - 0.5$\n$S_3 = 3.16 - 0.5$\n$S_3 = 2.66$\n\n为了选择牺牲进程，我们在 $\\{S_1, S_2, S_3\\}$ 中找到最小的分数：\n$$\\min(S_1, S_2, S_3) = \\min(1.68, -0.48, 2.66) = -0.48$$\n最小分数是 $-0.48$，对应于进程 $P_2$。因此，$P_2$ 被选为要终止的牺牲进程。\n\n问题要求给出所选牺牲进程分数的数值，并四舍五入到四位有效数字。计算出的分数恰好是 $-0.48$。用四位有效数字表示，即为 $-0.4800$。", "answer": "$$\\boxed{-0.4800}$$", "id": "3676663"}, {"introduction": "决定终止一个进程后，接下来会发生什么？实际情况可能比想象中更复杂。本练习深入探讨了资源释放的现实复杂性，揭示了资源类型（例如 POSIX 锁与 `flock` 锁）及其共享方式如何导致“孤儿锁”等意外后果 ([@problem_id:3676679])。这突显了理解内核管理资源和用户空间资源之间差异的重要性。", "problem": "一个操作系统（OS）正在通过终止进程来从死锁中恢复。假设有一个父进程 $P$ 和一个子进程 $C$，它们是通过一个导致它们共享单个文件描述符表 $T$ 的原语创建的（例如，带有 `CLONE_FILES` 标志的 Linux `clone` 调用）。$P$ 和 $C$ 在 $T$ 中都有一个表项 $k$，该表项指向文件 $F$ 的同一个打开文件描述 $d$。系统使用建议性文件锁来协调对 $F$ 的访问。在一个包含多个进程的死锁环中检测到了死锁，其中一个进程是 $C$。死锁恢复策略选择 $C$ 作为牺牲者来终止。\n\n请使用以下基本原理来推断文件锁会发生什么，以及如何避免在终止后无意中持续存在的锁（即所谓的孤儿锁）：\n\n- 死锁是一组进程中的每个进程都在等待一个只有该集合中另一个进程才能引发的事件的状态；通过进程终止进行恢复会抢占资源，这些资源在所属实体被销毁时释放。\n- 内核对象（如打开文件描述）是引用计数的：如果引用计数为 $r$，那么关闭一个文件描述符会使 $r$ 减 1，只有当 $r = 0$ 时，该对象（以及它拥有的任何资源）才会被回收。\n- 文件锁的语义各不相同。通过文件控制（`fcntl`）设置的可移植操作系统接口（POSIX）记录锁与加锁进程（由进程标识符（PID）标识）相关联，并在该进程退出时释放。相比之下，`flock` 风格的建议性锁可能与打开文件描述 $d$ 相关联；只要对 $d$ 的任何引用保持打开状态，这种锁就会持续存在。\n\n假设在恢复前的一瞬间：\n- 情况 X：$C$ 获取了对 $F$ 的一个锁 $L$。\n- 情况 Y：$C$ 被阻塞，等待获取锁 $L$，该锁当前由 $P$ 通过同一个 $d$ 持有。\n\n下列哪个陈述是正确的？选择所有适用的选项。\n\nA. 在通过 `fcntl` 实现的 POSIX 记录锁下，如果在情况 X 中 $C$ 持有 $L$，终止 $C$ 会释放 $L$，尽管 $P$ 共享文件描述符表 $T$，因为锁的所有权是基于进程的，而不是基于文件描述符或打开文件描述的。\n\nB. 在与打开文件描述 $d$ 相关联的 `flock` 风格的锁下，如果在情况 X 中 $C$ 持有 $L$ 且 $P$ 仍然引用 $d$，终止 $C$ 会立即释放 $L$，因为 $d$ 的共享者中至少有一个已经退出。\n\nC. 在情况 Y 中，终止 $C$ 会释放 $L$，尽管 $C$ 只是被阻塞而 $P$ 是持有者，因为杀死等待图中的任何参与者都会释放该集合持有的所有锁。\n\nD. 为避免在杀死 $C$ 后锁无意中持续存在，应确保每个进程在加锁前独立打开 $F$（创建不同的打开文件描述）；这样，杀死锁的持有者将只释放其自身的锁，并且引用计数确保持有者的 $d$ 的 $r \\to r - 1$ 最终达到 $0$。\n\nE. 在文件描述符 $k$ 上设置 close-on-exec 标志 `FD_CLOEXEC` 可以保证当 $C$ 终止时，对 $F$ 的任何锁都将被释放，因为该描述符将在进程退出时自动关闭。", "solution": "用户要求对问题陈述进行严格验证，然后提供一个完整的解决方案，并对所有选项进行分析。\n\n### 问题验证\n\n**第 1 步：提取已知信息**\n\n-   一个操作系统（OS）正在通过终止进程从死锁中恢复。\n-   存在一个父进程 $P$ 和一个子进程 $C$。\n-   $P$ 和 $C$ 是通过一个导致它们共享单个文件描述符表 $T$ 的原语创建的（例如，带有 `CLONE_FILES` 标志的 Linux `clone` 调用）。\n-   $P$ 和 $C$ 在共享表 $T$ 中都有一个表项 $k$。\n-   表项 $k$ 指向文件 $F$ 的同一个打开文件描述 $d$。\n-   系统使用建议性文件锁。\n-   在一个涉及多个进程的死锁环中检测到了死锁，其中包括 $C$。\n-   进程 $C$ 被选为终止的牺牲者。\n-   **基本原理：**\n    1.  通过进程终止进行死锁恢复会抢占资源，这些资源在所属实体被销毁时释放。\n    2.  像打开文件描述这样的内核对象是引用计数的。如果引用计数为 $r$，关闭一个文件描述符会使 $r$ 减 1。只有当 $r=0$ 时，该对象才会被回收。\n    3.  POSIX 记录锁（通过 `fcntl`）与加锁进程（由进程标识符 PID 标识）相关联，并在该进程退出时释放。\n    4.  `flock` 风格的锁可能与打开文件描述 $d$ 相关联，并且只要对 $d$ 的任何引用保持打开状态，它就会持续存在。\n-   **情景案例：**\n    -   情况 X：进程 $C$ 获取并持有了对文件 $F$ 的一个锁 $L$。\n    -   情况 Y：进程 $C$ 被阻塞，等待获取锁 $L$，该锁由进程 $P$ 通过同一个打开文件描述 $d$ 持有。\n\n**第 2 步：使用提取的已知信息进行验证**\n\n-   **科学依据充分：** 该问题牢固地植根于已建立的操作系统设计概念，特别是在类 UNIX 系统（如 Linux）中常见的概念。使用共享资源进行进程创建（`clone`）、文件描述符和打开文件描述之间的区别、引用计数、死锁恢复以及 POSIX（`fcntl`）和 BSD（`flock`）风格锁的语义，都是计算机科学中标准且描述准确的主题。\n-   **问题定义明确：** 该问题提供了一个清晰而具体的场景。进程（$P$, $C$）与内核对象（$T$, $k$, $d$, $F$）之间的关系被明确定义。两种相关锁机制的行为被作为推理的基础给出。选项中提出的问题可以根据这些前提来回答。\n-   **客观性：** 所使用的语言是技术性的、精确的，并且没有任何主观或模棱两可的术语。\n\n**第 3 步：结论与行动**\n\n问题陈述科学合理、定义明确且客观。它提出了一个基于操作系统基本原理进行分析的有效场景。未检测到任何缺陷。因此，我将继续进行求解推导。\n\n### 求解推导\n\n问题的核心在于理解哪个实体“拥有”文件锁，以及该实体的生命周期是如何管理的，尤其是在涉及共享文件描述符表的非标准进程设置中。\n\n当 $P$ 使用像带有 `CLONE_FILES` 标志的 `clone` 这样的机制创建 $C$ 时，$P$ 和 $C$ 共享同一个文件描述符表 $T$。这意味着表 $T$ 本身是由内核进行引用计数的（或者其管理方式保证只要有一个共享进程存在，它就会持续存在）。当进程 $C$ 被终止时，它不再是表 $T$ 的用户。然而，由于进程 $P$ 仍然存活并且也使用 $T$，所以表 $T$ 不会被销毁。因此，$T$ 中的文件描述符 $k$ 不会被关闭，其指向的打开文件描述 $d$ 的引用计数 $r$ 也*不会*减少。打开文件描述 $d$ 会一直持续到共享表 $T$ 的最后一个进程（在本例中为 $P$）终止或显式关闭描述符 $k$。\n\n基于这一理解，我们可以评估每个陈述。\n\n**选项 A 分析**\n\n-   **陈述：** 在通过 `fcntl` 实现的 POSIX 记录锁下，如果在情况 X 中 $C$ 持有 $L$，终止 $C$ 会释放 $L$，尽管 $P$ 共享文件描述符表 $T$，因为锁的所有权是基于进程的，而不是基于文件描述符或打开文件描述的。\n-   **情景：** 情况 X（$C$ 持有锁 $L$）。锁机制是 POSIX `fcntl` 锁。\n-   **推理：** 问题的基本原理明确指出，POSIX 记录锁与加锁进程相关联，由其 PID 标识。在这种情况下，进程 $C$ 获取了锁 $L$，因此该锁在内核中注册为属于 $C$ 的 PID。当操作系统终止进程 $C$ 时，它会为该特定 PID 执行清理程序。此清理包括释放该进程拥有的所有 POSIX 记录锁。打开文件描述 $d$ 的持久性与 `fcntl` 锁的所有权和生命周期无关。锁是与正在被销毁的进程绑定的。\n-   **结论：** **正确**。\n\n**选项 B 分析**\n\n-   **陈述：** 在与打开文件描述 $d$ 相关联的 `flock` 风格的锁下，如果在情况 X 中 $C$ 持有 $L$ 且 $P$ 仍然引用 $d$，终止 $C$ 会立即释放 $L$，因为 $d$ 的共享者中至少有一个已经退出。\n-   **情景：** 情况 X（$C$ 持有锁 $L$）。锁机制是 `flock` 风格的锁。\n-   **推理：** 问题的基本原理指出，`flock` 风格的锁与打开文件描述 $d$ 相关联，并且只要对 $d$ 的*任何*引用保持打开状态，它就会持续存在。当 $C$ 被终止时，进程 $P$ 仍然存在并共享文件描述符表 $T$，该表包含指向 $d$ 的表项 $k$。因此，对 $d$ 的一个引用仍然保持打开。$d$ 的引用计数不会降至 $0$。根据给定的规则，与 $d$ 相关联的锁 $L$ 将会持续存在。该陈述声称锁被释放，这与原理相矛盾。一个共享者的退出不足以释放锁；必须关闭对打开文件描述的所有引用。这种情况描述了“孤儿锁”的产生。\n-   **结论：** **错误**。\n\n**选项 C 分析**\n\n-   **陈述：** 在情况 Y 中，终止 $C$ 会释放 $L$，尽管 $C$ 只是被阻塞而 $P$ 是持有者，因为杀死等待图中的任何参与者都会释放该集合持有的所有锁。\n-   **情景：** 情况 Y（$C$ 正在等待 $L$，而 $L$ 由 $P$ 持有）。\n-   **推理：** “杀死等待图中的任何参与者都会释放该集合持有的所有锁”这一说法是一种不成立的泛化。通过进程终止进行死锁恢复的工作原理是打破依赖循环。这是通过释放*被终止的牺牲者进程*所持有的资源来实现的。在情况 Y 中，牺牲者是 $C$。进程 $C$ 因等待锁 $L$ 而被阻塞；它不持有 $L$。锁 $L$ 由进程 $P$ 持有。终止 $C$ 将释放 $C$ *正在*持有的任何资源（死锁环中的其他一些进程可能正在等待这些资源），从而打破死锁。然而，这不会强制释放像 $P$ 这样未被终止的进程所持有的资源。锁 $L$ 将继续由 $P$ 持有。\n-   **结论：** **错误**。\n\n**选项 D 分析**\n\n-   **陈述：** 为避免在杀死 $C$ 后锁无意中持续存在，应确保每个进程在加锁前独立打开 $F$（创建不同的打开文件描述）；这样，杀死锁的持有者将只释放其自身的锁，并且引用计数确保持有者的 $d$ 的 $r \\to r - 1$ 最终达到 $0$。\n-   **推理：** 该陈述为孤儿 `flock` 风格锁问题提出了一个解决方案。如果每个进程（$P$ 和 $C$）都独立打开文件 $F$，它们各自会获得自己的文件描述符，以及至关重要的、各自独立的打开文件描述。我们称之为 $d_P$ 和 $d_C$。如果 $C$ 随后获取一个 `flock` 风格的锁，该锁将与其自己的打开文件描述 $d_C$ 相关联。在这种标准设置下，$d_C$ 的引用计数 $r$ 为 $1$。当 $C$ 被终止时，操作系统会关闭其所有的文件描述符。这会将 $d_C$ 的引用计数从 $1$ 减到 $0$。如原理中所述，当 $r=0$ 时，内核对象 $d_C$ 被回收，其拥有的任何资源——包括 `flock` 锁——都会被释放。这个策略正确地将锁的生命周期与进程的生命周期联系起来，从而防止了孤儿锁。\n-   **结论：** **正确**。\n\n**选项 E 分析**\n\n-   **陈述：** 在文件描述符 $k$ 上设置 close-on-exec 标志 `FD_CLOEXEC` 可以保证当 $C$ 终止时，对 $F$ 的任何锁都将被释放，因为该描述符将在进程退出时自动关闭。\n-   **推理：** `FD_CLOEXEC` 标志的功能是使文件描述符在进程通过 `exec` 系列系统调用（例如 `execl`、`execve`）执行新程序时自动关闭。问题描述的是进程*终止*（例如通过 `exit()` 或被信号杀死），而不是 `exec` 调用。`FD_CLOEXEC` 标志与一般进程终止时发生的情况无关。在终止时，无论此标志的状态如何，内核都会关闭进程的所有文件描述符。更重要的是，正如在选项 B 的分析中所确立的，由于文件描述符表 $T$ 是共享的，终止 $C$ 首先就不会导致描述符 $k$ 被关闭。因此，该标志与问题无关有两个原因：它适用于错误的事件（`exec` vs. 终止），并且即使它适用，也无法解决底层共享资源的问题。\n-   **结论：** **错误**。", "answer": "$$\\boxed{AD}$$", "id": "3676679"}]}