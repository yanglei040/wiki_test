{"hands_on_practices": [{"introduction": "饿死现象通常发生在资源被高优先级任务完全占用的情况下。本练习将这个抽象概念具体化。通过分析一个实时调度场景，你将基于处理器利用率，计算出导致低优先级后台任务被无限期阻塞的精确边界条件。这个实践旨在巩固任务工作负载与系统活性之间的关键关系。", "problem": "考虑一个使用固定优先级、完全抢占式调度的单处理器操作系统。三个独立的实时任务，表示为 $\\tau_1$、$\\tau_2$ 和 $\\tau_3$，其优先级严格高于一个后台维护线程 $M$，而线程 $M$ 的优先级最低。每个任务 $\\tau_i$ 都是周期性的，其到达间隔时间（周期）为 $T_i$，最坏情况执行时间为 $C_i$。假设所有任务在时间 $t=0$ 时同步释放，截止时间等于周期，没有输入或输出阻塞，也没有自我挂起；只要有更高优先级的任务就绪，它就会抢占任何更低优先级的任务。\n\n后台线程 $M$ 的无限期阻塞（饥饿）意味着 $M$ 在一个无限的时间间隔内得不到任何处理器时间。仅使用处理器容量和保守工作抢占式调度的基本定义，推导由更高优先级任务产生的总处理器需求。然后，确定临界值 $T_3^{\\star}$，使得当 $T_3 \\leq T_3^{\\star}$ 时，后台线程 $M$ 可能会无限期饥饿；而当 $T_3  T_3^{\\star}$ 时，后台线程 $M$ 必然会无限多次地获得处理器时间。\n\n任务参数如下：\n- $\\tau_1$：$C_1 = 2 \\,\\mathrm{ms}$，$T_1 = 5 \\,\\mathrm{ms}$，\n- $\\tau_2$：$C_2 = 1.5 \\,\\mathrm{ms}$，$T_2 = 4 \\,\\mathrm{ms}$，\n- $\\tau_3$：$C_3 = 1 \\,\\mathrm{ms}$，$T_3$ 未知。\n\n根据更高优先级任务的总处理器需求刚好等于处理器容量的要求，计算 $T_3^{\\star}$。将 $T_3^{\\star}$ 的最终数值答案四舍五入到四位有效数字，并以毫秒为单位表示。", "solution": "问题要求确定实时任务 $\\tau_3$ 的临界周期 $T_3^{\\star}$，该值是低优先级后台线程 $M$ 发生无限期饥饿的边界。系统在具有固定优先级、抢占式调度的单处理器上运行。\n\n解决此问题的基本原理是处理器利用率。对于单处理器，总可用处理能力被归一化为 $1$。一组周期性任务只有在它们的总利用率小于或等于 $1$ 的情况下，才能被调度而不会使处理器过载。\n\n一个最坏情况执行时间为 $C_i$、周期为 $T_i$ 的周期性任务 $\\tau_i$ 的利用率 $U_i$ 定义为它长期消耗的处理器时间的分数：\n$$ U_i = \\frac{C_i}{T_i} $$\n后台线程 $M$ 的优先级最低。根据保守工作抢占式调度的规则，$M$ 只有在没有更高优先级的任务（$\\tau_1, \\tau_2, \\tau_3$）准备运行时，才会被分配处理器时间。如果处理器在任何无限区间内被更高优先级的任务完全占用，就会发生 $M$ 的无限期饥饿。如果总处理器需求（即任务 $\\tau_1, \\tau_2$ 和 $\\tau_3$ 的利用率之和）等于或大于总处理器容量，则满足此条件。\n\n令 $U_{total}$ 为更高优先级任务的总利用率：\n$$ U_{total} = U_1 + U_2 + U_3 = \\frac{C_1}{T_1} + \\frac{C_2}{T_2} + \\frac{C_3}{T_3} $$\n$M$ 发生无限期饥饿的条件是 $U_{total} \\geq 1$。相反，如果 $U_{total}  1$，就会有空闲的处理器容量，这些容量将被分配给 $M$，从而防止饥饿。\n\n问题要求的是临界值 $T_3^{\\star}$，使得当 $T_3 \\leq T_3^{\\star}$ 时，可能发生饥饿。这个临界边界对应于总处理器需求恰好等于处理器容量的情况。因此，我们将总利用率设为 $1$：\n$$ \\frac{C_1}{T_1} + \\frac{C_2}{T_2} + \\frac{C_3}{T_3^{\\star}} = 1 $$\n我们可以解这个关于 $T_3^{\\star}$ 的方程。首先，我们分离出包含 $T_3^{\\star}$ 的项：\n$$ \\frac{C_3}{T_3^{\\star}} = 1 - \\left( \\frac{C_1}{T_1} + \\frac{C_2}{T_2} \\right) $$\n然后，我们求解 $T_3^{\\star}$：\n$$ T_3^{\\star} = \\frac{C_3}{1 - \\frac{C_1}{T_1} - \\frac{C_2}{T_2}} $$\n这个表达式在分母为正的情况下有效，即 $1 - \\frac{C_1}{T_1} - \\frac{C_2}{T_2} > 0$。\n\n现在，我们代入给定的任务参数：\n- $\\tau_1$：$C_1 = 2 \\,\\mathrm{ms}$，$T_1 = 5 \\,\\mathrm{ms}$\n- $\\tau_2$：$C_2 = 1.5 \\,\\mathrm{ms}$，$T_2 = 4 \\,\\mathrm{ms}$\n- $\\tau_3$：$C_3 = 1 \\,\\mathrm{ms}$\n\n首先，我们计算 $\\tau_1$ 和 $\\tau_2$ 的利用率：\n$$ U_1 = \\frac{C_1}{T_1} = \\frac{2}{5} = 0.4 $$\n$$ U_2 = \\frac{C_2}{T_2} = \\frac{1.5}{4} = \\frac{3/2}{4} = \\frac{3}{8} = 0.375 $$\n这些利用率之和为：\n$$ U_1 + U_2 = 0.4 + 0.375 = 0.775 $$\n在达到饱和之前，可用于任务 $\\tau_3$ 的剩余处理器容量是 $1 - 0.775 = 0.225$。当 $\\tau_3$ 的利用率恰好是这个值时，满足临界条件：\n$$ U_3^{\\star} = \\frac{C_3}{T_3^{\\star}} = 0.225 $$\n代入 $C_3 = 1 \\,\\mathrm{ms}$：\n$$ \\frac{1}{T_3^{\\star}} = 0.225 $$\n求解 $T_3^{\\star}$：\n$$ T_3^{\\star} = \\frac{1}{0.225} = \\frac{1}{225/1000} = \\frac{1000}{225} $$\n通过将分子和分母除以它们的最大公约数 $25$ 来化简分数：\n$$ T_3^{\\star} = \\frac{1000 \\div 25}{225 \\div 25} = \\frac{40}{9} \\,\\mathrm{ms} $$\n作为小数，其值为 $T_3^{\\star} = 4.4444... \\,\\mathrm{ms}$。问题要求将最终答案四舍五入到四位有效数字。\n$$ T_3^{\\star} \\approx 4.444 \\,\\mathrm{ms} $$\n如果 $T_3$ 小于或等于此值，高优先级任务的总利用率将大于或等于 $1$，不会给后台线程 $M$ 留下任何处理器时间。如果 $T_3$ 大于此值，总利用率将小于 $1$，从而保证 $M$ 会获得一些处理器时间。", "answer": "$$ \\boxed{4.444} $$", "id": "3649175"}, {"introduction": "尽管资源饱和是导致饿死的直接原因，但更复杂的饿死场景源于系统组件间的相互作用。本问题将深入探讨“优先级反转”这一经典问题，其中一个公平锁的保证可能被抢占式优先级调度器所破坏。你将首先分析两种常见锁算法的内在公平性，然后探索系统级调度策略如何破坏这些保证并导致饿死。", "problem": "考虑一个共享内存多处理器系统，其中有 $N$ 个并发线程竞争一个互斥锁。正在考虑两种锁设计：票据锁（ticket lock）和 Mellor-Crummey and Scott (MCS) 锁。票据锁维护两个共享计数器，$next$ 和 $now$。为了获取锁，线程原子地获取并递增 $next$ 的值，从而得到一个票据值 $t$，然后等待直到 $now = t$。在解锁时，锁的持有者将 $now$ 递增 1。MCS 锁维护一个等待线程的链式队列，每个线程通过原子操作将自己的节点加入队列尾部，然后在其节点中的一个私有标志上自旋；解锁时，持有者设置后继节点的标志以移交所有权。假设系统满足顺序一致性，无故障，并且如果锁的持有者被调度，其解锁操作最终会执行。\n\n将锁算法的公平性保证 $F(N)$ 定义为一个关于 $N$ 的函数，它是在给定线程 $i$ 开始竞争之后、且在线程 $i$ 自己进入临界区之前，其他竞争者可以成功进入临界区的次数的最紧上界。假设调度器是弱公平的，即保证任何可运行的线程最终都会执行，并且线程不会放弃尝试。\n\n仅从上述票据锁和 MCS 锁的定义，以及互斥和排队的常规属性出发，推导 $F_{\\text{ticket}}(N)$ 和 $F_{\\text{MCS}}(N)$ 的封闭形式表达式。\n\n然后，考虑将弱公平调度器替换为一个严格的、具有高和低两个优先级的固定优先级抢占式调度器。假设一个低优先级线程持有锁，而一群从不使用该锁的高优先级线程持续保持可运行状态。使用无限期阻塞（饥饿）的定义，即等待线程进入临界区的时间不存在任何有限上界，从第一性原理出发，解释先前推导的 $F(N)$ 界限在系统级别上是否仍然适用，并根据锁和调度器的语义推理来证明你的结论。\n\n以包含 $F_{\\text{ticket}}(N)$ 和 $F_{\\text{MCS}}(N)$ 最简封闭形式的行矩阵报告你的最终答案。不需要进行数值代入。不要包含单位。如果你选择简化任何表达式，请确保简化是精确的。", "solution": "整个问题分为两部分。第一部分要求推导两种不同锁算法——票据锁和 MCS 锁——的公平性保证 $F(N)$。第二部分要求分析当底层调度器改变时，这些保证会受到怎样的影响。\n\n首先，我们分析公平性保证 $F(N)$ 的定义。它被定义为在给定线程 $i$ 开始竞争之后、且在线程 $i$ 自己进入临界区之前，其他竞争者可以成功进入临界区的次数的最紧上界。设线程 $k$ 开始竞争锁的事件表示为 $C_k$，线程 $k$ 进入临界区的事件表示为 $E_k$。对于给定的线程 $i$，我们必须计数的进入事件集合是 $\\{ j \\mid j \\neq i \\land (C_i  E_j  E_i) \\}$，其中排序关系 $$ 指的是事件的时间序列。$F(N)$ 是在所有包含 $N$ 个线程的可能执行中，该集合的最大可能大小。\n\n票据锁和 MCS 锁都是先进先出 (FIFO) 的排队锁。这意味着线程进入临界区的顺序与它们成功竞争锁的顺序相同。也就是说，如果线程 $j$ 在线程 $i$ 之前竞争 ($C_j  C_i$)，那么它保证在线程 $i$ 之前进入临界区 ($E_j  E_i$)。因此，要使线程 $j$ 满足条件 $E_j  E_i$，它必须在线程 $i$ 之前竞争，即 $C_j  C_i$。\n\n因此，要对一个进入事件 $E_j$ 进行计数，必须同时满足两个条件：\n1. $C_j  C_i$ (线程 $j$ 必须在队列中位于线程 $i$ 之前)。\n2. $C_i  E_j$ (线程 $j$ 必须在线程 $i$ 加入队列*之后*才进入临界区)。\n\n为了找到最紧上界 $F(N)$，我们必须为线程 $i$ 构建一个最坏情况的执行序列，以最大化满足这两个条件的线程 $j$ 的数量。\n\n$F_{\\text{ticket}}(N)$ 的推导：\n票据锁使用两个计数器 `next` 和 `now`。线程通过原子执行 `t = fetch_and_increment(next)` 来进行竞争。这个操作确立了它在 FIFO 队列中的位置，因此该事件对应于 $C_k$。持有票据 $t_k$ 的线程 $k$ 在 `now` 等于 $t_k$ 时进入临界区。\n\n考虑一个有 $N$ 个线程的系统。为了从线程 $i$ 的角度最大化被计数的进入次数，我们构建以下在弱公平调度器下允许的场景：\n1. 最初，一个线程（不在我们考虑的 $N$ 个竞争者之中，或者是其中一个已经通过的线程）持有锁。假设 `now` 计数器的值为 $k$。`next` 计数器的值为 $k+1$。\n2. 调度器运行 $N-1$ 个线程（除线程 $i$ 外的所有竞争者）。这些线程各自执行 `fetch_and_increment(next)`。它们获得了票据 $k+1, k+2, \\ldots, k+N-1$。对于这些线程中的每一个 $j$，竞争事件 $C_j$ 已经发生。此时 `next` 计数器为 $k+N$。`now` 计数器仍为 $k$，因此没有新线程能进入临界区。\n3. 调度器现在运行线程 $i$。它执行 `fetch_and_increment(next)` 并获得票据 $k+N$。此事件为 $C_i$。\n4. 此刻，对于所有其他 $N-1$ 个竞争者，都有 $C_j  C_i$。\n5. 最初的锁持有者（持有票据 $k$）完成其临界区，并将 `now` 递增至 $k+1$。\n6. 持有票据 $k+1$ 的线程现在进入临界区。其进入事件 $E_{k+1}$ 发生在 $C_i$ 之后。因此，该线程的进入被计数。\n7. 这个过程继续进行。持有票据 $k+1, \\ldots, k+N-1$ 的 $N-1$ 个线程依次进入并退出临界区。它们各自的进入事件 $E_j$ 都发生在 $C_i$ 之后。\n8. 最后，`now` 被递增至 $k+N$，允许线程 $i$ 进入。\n\n在这种情况下，所有其他 $N-1$ 个线程都在线程 $i$ 竞争之后、且在线程 $i$ 进入之前进入临界区。这代表了一种可能的执行。这样的线程数量不能超过 $N-1$，因为总共只有 $N-1$ 个其他线程。因此，最紧上界是 $N-1$。\n$$F_{\\text{ticket}}(N) = N-1$$\n\n$F_{\\text{MCS}}(N)$ 的推导：\nMCS 锁实现了一个显式的链表队列。线程通过将自己的节点原子地附加到列表尾部来进行竞争。这个原子操作（例如，对尾指针执行 `compare-and-swap` 或 `fetch-and-store`）确立了其队列位置，并对应于事件 $C_k$。当列表中的前一个线程通过设置该线程节点中的一个标志来显式传递所有权时，该线程进入临界区。\n\n我们可以构建一个与票据锁类似的的最坏情况场景：\n1. 最初，一个线程持有锁。该线程是 MCS 队列的头部。\n2. 调度器运行 $N-1$ 个线程（除 $i$ 之外的所有竞争者）。每个线程 $j$ 原子地将其节点附加到队列中。对所有这些线程，事件 $C_j$ 都已发生，形成了一个包含 $N-1$ 个等待线程的队列。\n3. 调度器现在运行线程 $i$。它原子地将其节点附加到队列的末尾。此事件为 $C_i$。队列现在包含 $N$ 个等待线程，其中 $i$ 位于最后。\n4. 此刻，对于所有其他 $N-1$ 个竞争者，都有 $C_j  C_i$，并且最初持有锁的线程仍在其临界区内。\n5. 最初的锁持有者退出并把所有权传递给等待队列中的第一个线程。该线程的进入事件 $E_j$ 发生在 $C_i$ 之后。这次进入被计数。\n6. 这个过程沿着链继续下去。在 $i$ 之前排队的 $N-1$ 个线程中的每一个都进入临界区。它们各自的进入事件都发生在 $C_i$ 之后。\n7. 最后，紧邻 $i$ 前面的线程退出并将所有权传递给 $i$，从而允许 $i$ 进入。\n\n与票据锁类似，所有其他 $N-1$ 个线程都可以在公平性保证所定义的时间间隔内进入临界区。竞争者的数量不能超过 $N-1$。因此，最紧上界是 $N-1$。\n$$F_{\\text{MCS}}(N) = N-1$$\n\n固定优先级抢占式调度器分析：\n问题的第二部分将调度器模型更改为严格的固定优先级抢占式调度器，并引入了一个体现优先级反转的场景。在这种场景下，一个低优先级线程 `L` 持有锁，而一群不需要该锁的高优先级线程 `H` 持续处于可运行状态。\n\n在严格的抢占式优先级调度器下，只要有任何高优先级线程可运行，低优先级线程就不会被调度。在给定场景中，高优先级的 `H` 线程将持续抢占低优先级的锁持有者 `L`。结果是，`L` 因得不到 CPU 时间而饿死，永远无法执行完成其临界区并释放锁的代码。\n\n锁持有者线程 `L` 的这种无限期延迟，对任何其他等待该锁的线程 `W`（无论其优先级如何）都有直接影响。由于 `L` 永远不释放锁，`W` 将永远等待。这种情况符合无限期阻塞或饥饿的定义：`W` 的等待时间没有有限上界。\n\n现在我们必须评估 $F(N)$ 界限在系统级别上是否仍然适用。界限 $F_{\\text{ticket}}(N) = N-1$ 和 $F_{\\text{MCS}}(N) = N-1$ 是从锁算法固有的 FIFO 排队逻辑中推导出来的。这种逻辑决定了进入的*顺序*，而不是*时机*。调度器不会改变排队机制；高优先级线程不能在票据锁或 MCS 锁中插队。因此，在等待线程 `i` 之前能够进入临界区的线程数仍然受其在队列中前面线程数量的限制，最多为 $N-1$。\n\n从纯数学的角度来看，界限 $F(N) \\leq N-1$ 仍然成立。如果系统在轮到线程 `i` 之前因优先级反转而陷入死锁，那么在 `i` 之前其他线程进入的次数可能是某个值 $k \\le N-1$，甚至是 $0$。在这种情况下，不等式被平凡地满足。\n\n然而，在*系统层面*上，这个界限作为公平性保证失去了其实际意义。公平性保证 $F(N)$ 之所以有用，是因为它意味着在有界数量的其他线程进入之后，等待的线程将轮到自己。这依赖于系统能够取得进展。在优先级反转的情况下，系统在锁方面停止了进展。等待锁的线程会饿死，意味着它们的等待时间是无限的。如果那些先前的进入事件以及等待线程自己的进入事件可能永远不会发生，那么“先前的进入次数是有限的”这一事实就是一个空洞的保证。\n\n总之，虽然表达式 $F(N)=N-1$ 仍然是对由锁的内部逻辑定义的计数的一个有效上界，但它未能描述系统层面的行为。系统表现出饥饿（无限等待时间），这是一种活性失败（liveness failure），而 $F(N)$ 度量，作为一种衡量顺序公平性而非时间进展的指标，并不能捕捉到这一点。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nN-1  N-1\n\\end{pmatrix}\n}\n$$", "id": "3649189"}, {"introduction": "在诊断了饿死的成因之后，我们现在转向设计解决方案。由于固定优先级调度容易导致饿死，操作系统通常会实施“老化”（aging）等对策。本练习要求你将这种机制形式化。你将设计一个包含老化策略的优先级更新规则，并推导出保证没有线程被饿死所需的最小老化速率，从而将一个理论概念转化为一个可量化的系统参数。", "problem": "一个操作系统在单个中央处理器（CPU）上使用一个抢占式的、基于优先级的调度器，其时间量长度固定，持续时间为 $\\Delta$。每个线程 $i$ 有一个基础优先级 $b_{i} \\in (0,1)$ 和一个有效优先级 $p_{i}(t)$。有效优先级在每个时间量结束时更新，以防止无限期阻塞（饥饿）。你需要形式化一个优先级衰减机制，该机制能避免振荡的优先级动态，同时保证在存在更高基础优先级的线程时，较低基础优先级的线程不会饿死。\n\n从核心定义出发，即饥饿是服务的无限期延迟，而老化是等待时有效优先级的单调增加，按以下步骤进行：\n\n- 提出了一个具有单一速率参数 $\\lambda0$ 的连续时间衰减函数 $d(t)$，该函数将经过的时间 $t$ 映射为一个作用于 $p_{i}(t)$ 与 $b_{i}$ 之间距离的乘性衰减因子，使得在每个时间量结束时引起的离散时间更新是单调且非振荡的。\n\n- 给定你的 $d(t)$，假设每个时间量的更新规则为\n$$\np_{i}^{+} \\;=\\; d(\\Delta)\\,p_{i} \\;+\\; \\bigl(1-d(\\Delta)\\bigr)\\,b_{i} \\;+\\; \\mu\\,\\Delta\\,\\mathbf{1}\\{\\text{线程 $i$ 在该时间量内等待}\\}\n$$\n其中 $\\mu0$ 是一个恒定的老化率，$\\mathbf{1}\\{\\cdot\\}$ 是指示函数。调度器总是在一个时间量开始时运行有效优先级最高的线程，并任意打破平局。\n\n- 考虑两个线程，$H$ 和 $L$，其基础优先级 $b_{H}$ 和 $b_{L}$ 满足 $b_{H}b_{L}$。初始时 $p_{H}(0)=b_{H}$ 且 $p_{L}(0)=b_{L}$。分析 $L$ 的最坏情况调度，即只要 $p_{H}\\ge p_{L}$，$H$ 就继续运行。仅使用上述定义和基于第一性原理的线性时不变推理，推导出一个关于 $b_{H},b_{L},\\lambda$ 和 $\\Delta$ 的最小老化率 $\\mu_{\\min}$ 的闭式表达式，以保证 $L$ 不会饿死。\n\n你的最终答案必须是 $\\mu_{\\min}$ 的单个闭式解析表达式。不要四舍五入。不需要单位。", "solution": "该问题被认为是有效的，因为它在科学上基于操作系统理论，问题提出得当、客观，并包含足够的信息以获得唯一解。我们开始推导。\n\n该问题要求我们形式化一个优先级更新机制以防止饥饿。这涉及三个主要步骤：提出一个合适的衰减函数，为双线程场景建立系统动态，以及推导保证低优先级线程不饿死的最小老化率 $\\mu_{\\min}$。\n\n首先，我们必须提出一个具有单一速率参数 $\\lambda  0$ 的连续时间衰减函数 $d(t)$。在没有老化的情况下，优先级 $p_i$ 的更新规则是 $p_{i}^{+} = d(\\Delta)p_{i} + (1-d(\\Delta))b_{i}$，其中 $p_i$ 是当前优先级，$p_i^+$ 是经过一个持续时间为 $\\Delta$ 的时间量后的优先级。这可以重写为 $p_{i}^{+} - b_{i} = d(\\Delta)(p_{i} - b_{i})$，表明有效优先级与基础优先级的偏差在每个时间步长中衰减一个因子 $d(\\Delta)$。这个离散一阶过程的连续时间对应物是一阶线性常微分方程：\n$$ \\frac{d}{dt} \\left( p_{i}(t) - b_{i} \\right) = -\\lambda \\left( p_{i}(t) - b_{i} \\right) $$\n其中 $\\lambda0$ 是衰减率。该方程的解是：\n$$ p_{i}(t) - b_{i} = (p_{i}(0) - b_{i}) \\exp(-\\lambda t) $$\n这描述了优先级偏差在时间间隔 $t$ 内的演变。显然，作用于偏差随时间 $t$ 变化的乘性衰减因子是 $\\exp(-\\lambda t)$。因此，最自然和最合适的衰减函数选择是：\n$$ d(t) = \\exp(-\\lambda t) $$\n这个函数有一个单一的速率参数 $\\lambda  0$。对于一个时间量 $\\Delta$ 上的离散更新，因子是 $d(\\Delta) = \\exp(-\\lambda\\Delta)$。由于 $\\lambda  0$ 且 $\\Delta  0$，我们有 $0  \\exp(-\\lambda\\Delta)  1$。在线性递推关系中，此范围内的特征根确保了单调、非振荡的收敛，满足了问题的要求。为方便起见，我们定义常数 $\\gamma = d(\\Delta) = \\exp(-\\lambda\\Delta)$。\n\n接下来，我们分析低优先级线程 $L$ 的最坏情况。我们有两个线程，$H$（高基础优先级）和 $L$（低基础优先级），且 $b_{H}  b_{L}$。初始条件是 $p_{H}(0) = b_{H}$ 和 $p_{L}(0) = b_{L}$。设 $p_{H,k}$ 和 $p_{L,k}$ 分别表示线程 $H$ 和 $L$ 在第 $k$ 个时间量结束时（即时间 $t=k\\Delta$）的有效优先级。初始状态为 $p_{H,0} = b_{H}$ 和 $p_{L,0} = b_{L}$。\n\n在第一个时间量开始时（$k=0$），我们有 $p_{H,0} > p_{L,0}$，所以调度器运行线程 $H$。对于 $L$ 来说，最坏的情况是，只要 $H$ 的优先级大于或等于 $L$ 的优先级，即对于所有后续步骤 $k$ 都有 $p_{H,k} \\ge p_{L,k}$，$H$ 就继续运行。在此假设下，对于每个时间量 $k+1$（从 $t=k\\Delta$ 到 $t=(k+1)\\Delta$），线程 $H$ 运行，线程 $L$ 等待。\n\n每个时间量结束时的优先级更新规则是：\n对于线程 $H$（已运行）：\n$p_{H,k+1} = \\gamma p_{H,k} + (1-\\gamma)b_{H} + \\mu \\Delta \\cdot 0 = \\gamma p_{H,k} + (1-\\gamma)b_{H}$\n对于线程 $L$（已等待）：\n$p_{L,k+1} = \\gamma p_{L,k} + (1-\\gamma)b_{L} + \\mu \\Delta \\cdot 1 = \\gamma p_{L,k} + (1-\\gamma)b_{L} + \\mu\\Delta$\n\n我们现在解这两个线性递推关系。\n对于线程 $H$，初始条件是 $p_{H,0}=b_{H}$。对于 $k=0$：\n$p_{H,1} = \\gamma p_{H,0} + (1-\\gamma)b_{H} = \\gamma b_{H} + (1-\\gamma)b_{H} = b_{H}$。\n通过归纳法，如果 $p_{H,k}=b_{H}$，则 $p_{H,k+1} = \\gamma b_{H} + (1-\\gamma)b_{H} = b_{H}$。因此，只要 $H$ 持续运行，其优先级保持不变：\n$$ p_{H,k} = b_{H} \\quad \\text{对于所有 } k \\ge 0 $$\n\n对于线程 $L$，我们有递推关系 $p_{L,k+1} = \\gamma p_{L,k} + C$，其中 $C = (1-\\gamma)b_{L} + \\mu\\Delta$。这是一个标准的一阶非齐次递推关系。解由齐次部分和特解组成。不动点（特解）$p_{L}^*$ 满足 $p_{L}^* = \\gamma p_{L}^* + C$，这给出 $p_{L}^* = \\frac{C}{1-\\gamma}$。\n$$ p_{L}^* = \\frac{(1-\\gamma)b_{L} + \\mu\\Delta}{1-\\gamma} = b_{L} + \\frac{\\mu\\Delta}{1-\\gamma} $$\n通解的形式为 $p_{L,k} = A\\gamma^k + p_{L}^*$，其中 $A$ 是由初始条件 $p_{L,0}=b_{L}$ 决定的常数。\n$p_{L,0} = A\\gamma^0 + p_{L}^* = A + b_{L} + \\frac{\\mu\\Delta}{1-\\gamma}$。\n$b_{L} = A + b_{L} + \\frac{\\mu\\Delta}{1-\\gamma} \\implies A = - \\frac{\\mu\\Delta}{1-\\gamma}$。\n因此，$p_{L,k}$ 的闭式解为：\n$$ p_{L,k} = \\left(b_{L} + \\frac{\\mu\\Delta}{1-\\gamma}\\right) - \\left(\\frac{\\mu\\Delta}{1-\\gamma}\\right)\\gamma^k = b_{L} + \\frac{\\mu\\Delta}{1-\\gamma}(1-\\gamma^k) $$\n\n线程 $L$ 的饥饿发生在它被无限期推迟时。在我们的模型中，这意味着对于所有 $k \\ge 0$，$p_{L,k} \\le p_{H,k}$。为了保证 $L$ 不会饿死，它的优先级最终必须超过 $H$ 的优先级。由于 $p_{L,k}$ 是 $k$ 的单调递增函数（因为 $0  \\gamma  1$），如果它要超过 $p_{H,k}=b_H$，那么只要老化项继续作用，它就会超过并保持在 $b_H$ 之上。保证不发生饥饿的条件是 $p_{L,k}$ 的渐近极限必须严格大于 $b_H$。\n$$ \\lim_{k\\to\\infty} p_{L,k} > b_{H} $$\n当 $k \\to \\infty$ 时，$\\gamma^k \\to 0$ 因为 $0  \\gamma  1$。所以，极限是：\n$$ \\lim_{k\\to\\infty} p_{L,k} = b_{L} + \\frac{\\mu\\Delta}{1-\\gamma} $$\n防止饥饿的条件变为：\n$$ b_{L} + \\frac{\\mu\\Delta}{1-\\gamma} > b_{H} $$\n我们对这个不等式求解 $\\mu$：\n$$ \\frac{\\mu\\Delta}{1-\\gamma} > b_{H} - b_{L} $$\n$$ \\mu > \\frac{(1-\\gamma)(b_{H} - b_{L})}{\\Delta} $$\n最小老化率 $\\mu_{\\min}$ 是满足此条件的 $\\mu$ 值集合的下确界，这对应于不等式的边界。\n$$ \\mu_{\\min} = \\frac{(1-\\gamma)(b_{H} - b_{L})}{\\Delta} $$\n最后，我们代回 $\\gamma = \\exp(-\\lambda\\Delta)$：\n$$ \\mu_{\\min} = \\frac{(1 - \\exp(-\\lambda\\Delta))(b_{H} - b_{L})}{\\Delta} $$\n如果 $\\mu$ 设置为此值，$p_{L,k}$ 将从下方渐近地趋近于 $b_H$，在有限时间内永远不会达到它。因此，任何 $\\mu > \\mu_{\\min}$ 都将保证 $p_{L,k}$ 在有限步数后超过 $b_H$，从而防止饥饿。问题要求的是建立此保证的最小速率 $\\mu_{\\min}$。", "answer": "$$\\boxed{\\frac{\\left(1 - \\exp(-\\lambda\\Delta)\\right)\\left(b_{H} - b_{L}\\right)}{\\Delta}}$$", "id": "3649191"}]}