{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。这个练习 [@problem_id:3662708] 将带你从代码层面分析一个常见的嵌套锁死锁问题，并探讨如何通过非阻塞的 `try_lock` 操作打破“持有并等待”条件。通过这个练习，你将学会一种实用的死锁规避技术，并理解其对系统活性和性能的潜在影响。", "problem": "考虑一个通用操作系统（OS）上的多线程程序，该程序使用两个名为 $A$ 和 $B$ 的互斥锁来保护一个共享数据结构。原始代码路径以嵌套方式获取锁：首先 `lock(A)`，然后 `lock(B)`，执行一个临界区，最后以相反的顺序释放锁。如果线程 $T_1$ 执行 `lock(A)` 后等待 `lock(B)`，而线程 $T_2$ 执行 `lock(B)` 后等待 `lock(A)`，就可能产生死锁。一项提议的修改将锁的获取方式改为对第二个锁进行非阻塞尝试，并在失败时立即释放第一个锁：获取 $A$；尝试 `try_lock(B)`；如果尝试失败，则释放 $A$，执行有限的回退（backoff），然后重试；否则，进入临界区，然后释放两个锁。\n\n请仅使用经典的死锁必要条件（通常称为 Coffman 条件）作为你的基础——即互斥、持有并等待、无抢占和循环等待——来回答以下问题。指出该修改有意破坏了哪个必要条件，并论证与原始嵌套锁定相比，此更改带来的主要活性（liveness）和性能后果。选择所有正确的选项。\n\nA. 该修改破坏了“持有并等待”条件，因为它确保线程在持有 $A$ 的同时不会等待 $B$；结果是，$A$ 和 $B$ 上的死锁被阻止，但如果没有随机回退，可能会发生活锁或饥饿。\n\nB. 该修改破坏了“无抢占”条件，因为当一个线程获取 $B$ 失败时，$A$ 可能会被强制从该线程中夺走；因此，死锁被阻止，并且抢占开销增加。\n\nC. 该修改保持所有四个 Coffman 条件不变；如果两个线程无限循环，死锁仍然可能发生。\n\nD. 该修改需要一个全局锁顺序来避免死锁；否则它会破坏互斥条件并可能损坏临界区。\n\nE. 尽管阻止了死锁，但该修改可能因重试、自旋或频繁唤醒而增加中央处理器（CPU）的使用率。", "solution": "该问题要求基于死锁的四个必要条件，对一种死锁避免技术及其活性和性能影响进行分析。\n\n### 步骤 1：问题验证\n\n问题陈述提供了一个清晰且独立的场景，该场景来自操作系统和并发领域。\n\n**已知条件：**\n1.  一个系统中有两个互斥锁 `$A$` 和 `$B$`，用于保护一个共享数据结构。\n2.  一种可能导致死锁的原始锁定方案：线程 `$T_1$` 调用 `lock(A)` 然后 `lock(B)`，而另一个线程 `$T_2$` 调用 `lock(B)` 然后 `lock(A)`。\n3.  一项提议的锁定协议修改：\n    a. 获取 `$A$` (`lock(A)`)。\n    b. 非阻塞地尝试获取 `$B$` (`try_lock(B)`)。\n    c. 如果 `try_lock(B)` 成功，则进入临界区，然后释放两个锁。\n    d. 如果 `try_lock(B)` 失败，则释放 `$A$`，执行有限的回退，然后重试整个序列。\n4.  分析必须基于死锁的四个经典必要条件（Coffman 条件）：互斥、持有并等待、无抢占和循环等待。\n\n**验证：**\n- **科学依据：** 该问题基于计算机科学的基本和标准原则，特别是关于并发控制和死锁的操作系统理论。互斥锁、`lock`、`try_lock`、回退以及 Coffman 条件等概念都是公认的。该场景是用于教授死锁避免的典型示例。\n- **适定性：** 问题陈述清晰。它描述了一个初始算法、一个修改后的算法，并要求根据特定的理论框架（Coffman 条件）及其现实后果（活性、性能）对修改进行分析。描述足以推导出一个唯一且有意义的解决方案。\n- **客观性：** 语言技术性强、精确，没有歧义或主观论断。\n\n该问题是有效的，因为它是计算机科学中一个标准的、适定的问题，具有科学合理性和客观性。\n\n### 步骤 2：分析修改后的锁定协议\n\n我们将根据死锁的四个必要条件来分析修改后的协议。要发生死锁，所有四个条件必须同时成立。修改的目标是破坏其中至少一个条件。\n\n1.  **互斥：** 此条件指出，至少有一个资源必须以非共享模式持有。根据定义，互斥锁 `$A$` 和 `$B$` 是排他性锁定资源。修改后的方案继续将它们用作互斥锁，确保在任何时候只有一个线程可以持有给定的锁。因此，**互斥**条件保持不变。\n\n2.  **持有并等待：** 此条件指出，一个线程必须至少持有一个资源，并等待获取当前被其他线程持有的额外资源。\n    - 在原始协议中，一个线程可以成功执行 `lock(A)`，然后无限期地在 `lock(B)` 上阻塞（等待）。在此等待期间，它持有资源 `$A$` 并等待资源 `$B$`。这满足了持有并等待条件。\n    - 在修改后的协议中，一个线程获取 `$A$`。然后它使用 `try_lock(B)` 尝试获取 `$B$`。这个调用是非阻塞的；它会立即返回，指示成功或失败。如果失败，线程的逻辑规定它必须立即释放 `$A$`。在任何时候，线程都不会在*等待*资源 `$B$` 的同时持有资源 `$A$`。它要么快速连续地获取 `$A$` 和 `$B$`，要么在释放 `$A$` 之前仅持有它很短的一段时间，然后什么也不持有。因此，该修改**破坏了“持有并等待”条件**。\n\n3.  **无抢占：** 此条件指出，资源不能被从线程中强制夺走；它们必须由持有它们的线程自愿释放。在修改后的协议中，当一个线程获取 `$B$` 失败时，它会释放 `$A$`。这种释放是自愿的；它是线程编程逻辑的一个明确部分。操作系统或其他线程不会强制抢占锁 `$A$`。因此，经典定义的**无抢占**条件保持不变。\n\n4.  **循环等待：** 此条件指出，必须存在一组等待线程 `{$T_0, T_1, ..., T_n$}`，使得 `$T_0$` 等待由 `$T_1$` 持有的资源，`$T_1$` 等待由 `$T_2$` 持有的资源，...，而 `$T_n$` 等待由 `$T_0$` 持有的资源。通过破坏“持有并等待”条件，修改后的方案使得循环等待不可能发生。一个未能获取第二个锁的线程不会等待；它会释放其第一个锁，从而打破任何潜在的依赖链。因此，作为破坏“持有并等待”条件的后果，**循环等待**条件也得到了有效阻止。\n\n该修改的逻辑直接针对并破坏的主要条件是**持有并等待**。\n\n### 步骤 3：活性和性能后果分析\n\n- **活性（Liveness）：** 死锁是一种活性失败，其中进程被永久阻塞。修改后的方案防止了死锁。然而，它引入了其他活性失败的可能性。\n    - **活锁（Livelock）：** 考虑两个线程 `$T_1$` 和 `$T_2$` 几乎同时尝试该协议。`$T_1$` 获取 `$A$`。`$T_2$` 获取 `$B$`。`$T_1$` 的 `try_lock(B)` 失败并释放 `$A$`。`$T_2$` 的 `try_lock(A)` 失败并释放 `$B$`。两者都进行回退。如果它们的回退周期相同且有限，它们可能会无限期地重复这个序列。两个线程都在活动（执行指令），但没有取得进展。这就是活锁。通常使用随机回退策略来降低活锁的概率，但不能完全消除它。\n    - **饥饿（Starvation）：** 在一个多线程系统中，可能某个特定线程会反复地不走运。它可能因为其他线程总是能成功获取它需要的某个锁而持续无法获取两个锁。当其他线程取得进展时，这个线程就“饿死了”。\n\n- **性能：**\n    - 原始的阻塞协议 (`lock(A)`, `lock(B)`) 会在锁不可用时导致线程被操作系统调度器挂起。在挂起期间，线程不消耗任何中央处理器（CPU）资源。\n    - 修改后的协议涉及一个重试循环。每次尝试都包括 `lock`、`try_lock`，以及（在失败时）`unlock` 和 `backoff`。这个循环会消耗 CPU 周期。即使回退使线程进入睡眠状态，重复的锁定尝试和频繁的上下文切换（唤醒）的开销也可能远高于阻塞方法的单次上下文切换，尤其是在高争用情况下。这导致 **CPU 使用率增加**。\n\n### 步骤 4：逐项评估选项\n\n**A. 该修改破坏了“持有并等待”条件，因为它确保线程在持有 $A$ 的同时不会等待 $B$；结果是，$A$ 和 $B$ 上的死锁被阻止，但如果没有随机回退，可能会发生活锁或饥饿。**\n- 该陈述正确地指出**持有并等待**条件被破坏。\n- 它正确地得出结论，即死锁因此被阻止。\n- 它正确地指出了可能出现的活性问题，如**活锁**和**饥饿**。\n**结论：正确。**\n\n**B. 该修改破坏了“无抢占”条件，因为当一个线程获取 $B$ 失败时，$A$ 可能会被强制从该线程中夺走；因此，死锁被阻止，并且抢占开销增加。**\n- 该陈述错误地声称**无抢占**条件被破坏。锁 `$A$` 是由线程自己的逻辑自愿释放的，而不是被外部代理强制抢占的。\n**结论：不正确。**\n\n**C. 该修改保持所有四个 Coffman 条件不变；如果两个线程无限循环，死锁仍然可能发生。**\n- 该陈述在两点上是错误的。首先，它错误地声称所有四个条件都保持不变，而实际上“持有并等待”已被破坏。其次，它将**活锁**（无限循环但无进展）与**死锁**（被无限期阻塞）混淆了。由于一个条件被破坏，死锁是不可能的。\n**结论：不正确。**\n\n**D. 该修改需要一个全局锁顺序来避免死锁；否则它会破坏互斥条件并可能损坏临界区。**\n- 该陈述是错误的。`尝试锁定并释放`策略是强制执行全局锁顺序的一种*替代方案*。全局锁顺序是另一种防止死锁的方法（通过防止循环等待）。\n- 它还错误地声称该方法破坏了**互斥**。互斥锁的使用确保了互斥性得以维持，并且线程只有在获取*两个*锁之后才能进入临界区，从而防止数据损坏。\n**结论：不正确。**\n\n**E. 尽管阻止了死锁，但该修改可能因重试、自旋或频繁唤醒而增加中央处理器（CPU）的使用率。**\n- 该陈述正确地指出了一个关键的性能后果。重试机制是一种形式的忙等待或导致频繁的线程调度，与阻塞（睡眠线程不消耗CPU）相比，这两种情况都会增加**CPU使用率**。它还正确地指出死锁被阻止了。\n**结论：正确。**\n\n选项 A 和 E 都对该修改提供了正确的分析，涵盖了问题的不同部分（死锁条件、活性和性能）。", "answer": "$$\\boxed{AE}$$", "id": "3662708"}, {"introduction": "在上一个练习的基础上，我们现在将注意力转向另一个关键的死锁必要条件：“循环等待”。这个经典的环形等待场景 [@problem_id:3662794] 模拟了多个线程竞争一组循环依赖的资源。你的任务是分析并识别出通过建立全局资源获取顺序来直接打破“循环等待”条件的策略，从而加深对资源排序这一核心死锁预防原则的理解。", "problem": "一个操作系统 (OS) 管理着一组共 $n$ 个文件锁 $\\{F_0,F_1,\\dots,F_{n-1}\\}$，每个锁都是一个二元互斥锁。有 $n$ 个线程 $\\{T_0,T_1,\\dots,T_{n-1}\\}$，对于每个 $i\\in\\{0,1,\\dots,n-1\\}$，线程 $T_i$ 必须获得恰好 $2$ 个锁才能完成其临界区：$F_i$ 和 $F_{(i+1)\\bmod n}$。基准的加锁策略是阻塞式获取：每个线程尝试获取它的第一个锁，一旦持有，就尝试获取它的第二个锁，必要时会阻塞；锁一旦授予，操作系统不会强制撤销。\n\n使用以下第一性原理基础：\n- 死锁需要以下四个必要条件同时存在：互斥、持有并等待、无抢占和循环等待。\n- 互斥意味着一个锁一次最多只能被一个线程持有。\n- 持有并等待意味着一个线程在等待获取额外资源的同时，至少持有一个资源。\n- 无抢占意味着一个资源一旦被获取，就不能被强制夺走；它必须被自愿释放。\n- 循环等待意味着存在一个线程循环，其中每个线程都在等待循环中下一个线程所持有的资源。\n\n考虑这个环中的经典死锁模式：如果每个 $T_i$ 首先获取 $F_i$，然后等待 $F_{(i+1)\\bmod n}$，就可能出现一个长度为 $n$ 的循环等待。找出能够打破循环等待的最小策略变更，同时保留互斥性并保持资源语义不变。选择最佳选项。\n\nA. 对文件锁施加严格的全局排序：从一个全序关系中为每个 $F_k$ 分配一个唯一的等级 $r(F_k)$，并要求所有线程严格按照等级递增的顺序获取所需的锁。\n\nB. 允许操作系统在持有者等待另一个锁时，在超时后强制撤销其持有的锁，从而实现锁的抢占。\n\nC. 用两阶段尝试加锁策略替换阻塞式获取：线程非阻塞地尝试获取两个锁；如果获取第二个锁失败，则释放第一个锁并在稍后重试。\n\nD. 用一个保护所有文件的全局锁 $G$ 替换 $n$ 个文件锁，这样每个线程在其整个临界区周围只获取 $1$ 个锁 $G$。\n\n回答正确的选项。", "solution": "### 问题验证\n\n#### 步骤 1：提取已知条件\n- 一个操作系统管理着一组共 $n$ 个文件锁 $\\{F_0, F_1, \\dots, F_{n-1}\\}$。\n- 每个锁都是一个二元互斥锁。\n- 有 $n$ 个线程 $\\{T_0, T_1, \\dots, T_{n-1}\\}$。\n- 对于每个 $i \\in \\{0, 1, \\dots, n-1\\}$，线程 $T_i$ 必须获得恰好 $2$ 个锁才能完成其临界区：$F_i$ 和 $F_{(i+1)\\bmod n}$。\n- 基准的加锁策略是阻塞式获取：一个线程获取它的第一个锁，然后获取它的第二个锁，必要时会阻塞。\n- 锁不会被强制撤销（无抢占）。\n- 第一性原理基础：死锁需要四个必要条件同时存在：\n    1.  **互斥**：一个锁一次最多只能被一个线程持有。\n    2.  **持有并等待**：一个线程在等待获取额外资源的同时，至少持有一个资源。\n    3.  **无抢占**：一个资源不能被强制夺走。\n    4.  **循环等待**：存在一个线程循环，其中每个线程都在等待循环中下一个线程所持有的资源。\n- 问题要求找出能够**打破循环等待**的最小策略变更，同时保留互斥性并保持资源语义不变。\n\n#### 步骤 2：使用提取的已知条件进行验证\n该问题陈述是操作系统和资源加锁背景下“哲学家就餐问题”的经典表述。\n- **科学依据**：该问题牢固地基于计算机科学中已确立的概念，特别是操作系统理论中关于并发、资源管理和死锁的部分。死锁的四个必要条件是该领域的一个基石。\n- **问题明确**：问题定义清晰。它描述了一个系统、一个潜在的问题（死锁），并要求一种特定类型的解决方案（一个打破其中一个必要条件的策略变更）。可以推导出一个唯一且有意义的解决方案。\n- **客观性**：语言精确且技术性强，没有含糊不清或主观的陈述。\n\n该问题没有表现出验证标准中列出的任何缺陷。在其领域内，这是一个健全、可形式化且标准的问题。\n\n#### 步骤 3：结论与行动\n问题陈述是**有效的**。将推导解决方案。\n\n### 基于原理的推导\n问题要求一种策略变更，通过打破**循环等待**条件来专门防止死锁。在所描述的系统中，当且仅当所有四个必要条件——互斥、持有并等待、无抢占和循环等待——同时满足时，才会发生死锁。问题指出，互斥和无抢占是基准系统的特性。当一个线程成功获取其第一个锁然后阻塞等待其第二个锁时，持有并等待条件就满足了。\n\n目标是循环等待条件。如果存在一个等待线程的循环，就会出现此条件。在给定的设置中，如果每个线程 $T_i$ 获取其第一个锁 $F_i$，然后等待其第二个锁 $F_{(i+1)\\bmod n}$，就可能发生死锁。这导致了以下循环依赖：\n- $T_0$ 持有 $F_0$ 并等待 $F_1$。\n- $F_1$ 被 $T_1$ 持有，而 $T_1$ 等待 $F_2$。\n- ...\n- $T_{n-2}$ 持有 $F_{n-2}$ 并等待 $F_{n-1}$。\n- $T_{n-1}$ 持有 $F_{n-1}$ 并等待 $F_0$，而 $F_0$ 被 $T_0$ 持有。\n\n这就形成了一个循环 $T_0 \\to T_1 \\to \\dots \\to T_{n-1} \\to T_0$，其中“$\\to$”表示“等待某个资源，而该资源被...持有”。要打破循环等待，我们必须引入一个使这种循环无法形成的策略。\n\n### 逐项分析\n\n**A. 对文件锁施加严格的全局排序：从一个全序关系中为每个 $F_k$ 分配一个唯一的等级 $r(F_k)$，并要求所有线程严格按照等级递增的顺序获取所需的锁。**\n\n这是预防死锁的经典技术。我们来分析它对循环等待的影响。不失一般性，假设锁 $F_k$ 的等级是其索引，即 $r(F_k) = k$。\n一个线程 $T_i$ 需要锁 $F_i$ 和 $F_{(i+1)\\bmod n}$。\n- 对于 $i \\in \\{0, 1, \\dots, n-2\\}$，所需的锁是 $F_i$ 和 $F_{i+1}$。由于 $r(F_i) = i  i+1 = r(F_{i+1})$，线程 $T_i$ 必须先获取 $F_i$，然后获取 $F_{i+1}$。\n- 对于线程 $T_{n-1}$，所需的锁是 $F_{n-1}$ 和 $F_0$。由于 $r(F_0) = 0  n-1 = r(F_{n-1})$，线程 $T_{n-1}$ 必须先获取 $F_0$，然后获取 $F_{n-1}$。\n\n现在，为得出矛盾，假设存在一个循环等待。这意味着存在一组线程 $\\{P_1, P_2, \\dots, P_k\\}$，使得 $P_1$ 等待 $P_2$ 持有的锁，$P_2$ 等待 $P_3$ 持有的锁，...，而 $P_k$ 等待 $P_1$ 持有的锁。\n根据该策略，一个线程 $P_j$ 只能等待一个等级*高于*其当前持有的任何锁的等级的锁。设 $L_j$ 是 $P_j$ 正在等待的锁。$L_j$ 被 $P_{j+1}$ 持有（索引对 $k$ 取模）。所以，对于每个 $j$，$P_{j+1}$ 持有锁 $L_j$。当 $P_{j+1}$ 稍后等待锁 $L_{j+1}$ 时，必须有 $r(L_j)  r(L_{j+1})$。将此逻辑应用于整个循环：\n- $P_1$ 等待 $P_2$ 持有的 $L_1$。\n- $P_2$ 持有 $L_1$ 并等待 $L_2$。根据规则，$r(L_1)  r(L_2)$。\n- $P_3$ 持有 $L_2$ 并等待 $L_3$。根据规则，$r(L_2)  r(L_3)$。\n- ...\n- $P_k$ 持有 $L_{k-1}$ 并等待 $L_k$。根据规则，$r(L_{k-1})  r(L_k)$。\n- $P_1$ 持有 $L_k$ 并等待 $L_1$。根据规则，$r(L_k)  r(L_1)$。\n\n将这些不等式组合起来，得到链条 $r(L_1)  r(L_2)  \\dots  r(L_k)  r(L_1)$。这是一个逻辑矛盾。因此，循环等待不可能存在。\n这个策略直接且可证明地打破了循环等待条件。这是一个“最小变更”，因为它保留了 $n$ 个锁及其对线程的分配（“资源语义”），仅仅增加了一个行为规则。\n结论：**正确**\n\n**B. 允许操作系统在持有者等待另一个锁时，在超时后强制撤销其持有的锁，从而实现锁的抢占。**\n\n这个策略变更针对的是**无抢占**条件，而不是循环等待条件。打破四个必要条件中的任何一个都足以防止死锁。然而，问题明确要求一个“打破循环等待”的策略。此选项打破了另一个条件。\n结论：**错误**\n\n**C. 用两阶段尝试加锁策略替换阻塞式获取：线程非阻塞地尝试获取两个锁；如果获取第二个锁失败，则释放第一个锁并在稍后重试。**\n\n这个策略变更针对的是**持有并等待**条件。遵循此策略的线程永远不会在等待另一个资源的同时持有一个资源。它要么在一个原子步骤中获取其所有需要的资源（两个锁），要么不持有任何资源。如果一个线程未能获取第二个锁，它会释放第一个锁，此时它并没有在“等待”时“持有”。这有效地消除了持有并等待条件。同样，虽然这能防止死锁，但它并非通过打破问题所要求的循环等待条件来实现的。\n结论：**错误**\n\n**D. 用一个保护所有文件的全局锁 $G$ 替换 $n$ 个文件锁，这样每个线程在其整个临界区周围只获取 $1$ 个锁 $G$。**\n\n这个策略变更确实能防止死锁。由于每个线程只需要一个资源（$G$），持有并等待条件被打破了（线程不能在等待另一个资源时持有一个资源）。循环等待条件也被打破了，因为等待循环至少需要两个不同的被争夺的资源。然而，问题要求的是一种*最小*的策略变更，且保持“资源语义不变”。用一个粗粒度的全局锁替换 $n$ 个细粒度的锁是对资源语义的根本性且非最小的改变。这是一种会极大地降低潜在并发性的激烈措施。选项A远比它更小，因为它保留了原始的 $n$ 个锁及其用途，仅增加了一个获取的排序规则。因此，该选项不如选项A更好地满足问题约束。\n结论：**错误**\n\n最终结论：选项A是唯一一个按照要求直接针对循环等待条件的选项，并且它通过最小的变更来实现了这一点，同时保留了底层的资源结构。", "answer": "$$\\boxed{A}$$", "id": "3662794"}, {"introduction": "死锁预防策略并非没有代价，理解其对性能的影响至关重要。这个练习 [@problem_id:3662788] 引入了一种严格的预防策略——进程一次性获取所有所需资源，从而消除“持有并等待”条件。你的任务是通过量化计算任务完成时间和资源利用率，直观地感受在系统设计中安全与效率之间的现实权衡。", "problem": "考虑以下系统，其中进程竞争访问两个不可抢占、互斥的设备，表示为 $R_1$ 和 $R_2$。使用设备的进程在其使用期间独占该设备，且设备不可被抢占。在操作系统中，死锁的经典定义是一组进程被永久阻塞，因为集合中的每个进程都在等待一个只能由该集合中另一个进程引起的事件。众所周知的死锁必要条件是互斥、持有并等待、不可抢占和循环等待。\n\n该系统强制执行一项禁止持有并等待的策略：每个进程在执行前必须声明其将需要的所有设备，并且只有在所有声明的设备都空闲时才被接纳；一旦被接纳，它将持有所有声明的设备直到完成，即使在不活跃使用其中某些设备的阶段也是如此。如果在接纳时某个声明的设备不空闲，则该进程在不持有任何设备的情况下等待。\n\n有 $3$ 个进程，$P_1$、$P_2$ 和 $P_3$，其总运行时间（从接纳到完成）和设备使用区间是相对于每个进程的开始时间给出的：\n\n- 进程 $P_1$ 运行 $10$ 个时间单位。它在 $[2,4]$ 和 $[8,9]$ 期间使用 $R_1$，在 $[5,7]$ 期间使用 $R_2$。\n- 进程 $P_2$ 运行 $8$ 个时间单位。它在 $[1,2]$ 期间使用 $R_1$，在 $[6,8]$ 期间使用 $R_2$。\n- 进程 $P_3$ 运行 $6$ 个时间单位。它在 $[2,3]$ 期间使用 $R_2$。\n\n假设所有区间代表连续使用，其长度等于端点之差，并且没有进程同时使用两个设备。在上述禁止持有并等待的策略下，$P_1$ 和 $P_2$ 必须声明 $\\{R_1, R_2\\}$，而 $P_3$ 必须声明 $\\{R_2\\}$。在增量式（传统）分配策略下，进程仅在需要时请求和释放设备，并且可以在等待另一个设备时持有一个设备，这同样受到不可抢占和互斥约束的限制。\n\n选择所有正确选项：\n\nA. 在此系统中消除持有并等待破坏了死锁的一个必要条件；因此，无论请求模式如何，都不会发生死锁。\n\nB. 对于给定的工作负载，两个设备的总繁忙时间固定为 $9$ 个时间单位。在禁止持有并等待的策略下，完工时间为 $24$ 个时间单位，得出双设备利用率为 $3/16$。存在一个可行的增量式调度，其完工时间为 $12$，得出双设备利用率为 $3/8$。\n\nC. 因为在禁止持有并等待的策略下资源被预先保留，所以相对于增量式分配，吞吐量严格增加；因此设备得到更充分的利用。\n\nD. 在禁止持有并等待的策略下，进程饥饿是不可能的，因为等待的进程不持有任何设备。", "solution": "我们从标准的第一性原理开始：操作系统中的死锁需要以下必要条件（Coffman 条件）同时存在：互斥、持有并等待、不可抢占和循环等待。如果其中任何一个条件不满足，死锁就不会发生。\n\n在给定的策略下，持有并等待被明确禁止：一个进程要么 (i) 被接纳并从开始到完成一直持有所有声明的设备，要么 (ii) 在不持有任何设备的情况下等待，直到所有声明的设备同时变为空闲。这意味着持有设备的进程不会等待更多设备，而等待的进程不持有任何设备。因此，持有并等待的条件不成立，破坏了死锁的一个必要条件。由于死锁需要所有必要条件同时满足，因此在此策略下不可能发生死锁。这直接证明了选项 A 的正确性。\n\n接下来，我们分析利用率。将双设备利用率 $U$ 定义为\n$$\nU \\;=\\; \\frac{\\text{两个设备的总繁忙时间}}{\\text{设备数量} \\times \\text{完工时间}}。\n$$\n两个设备的总繁忙时间仅取决于所有进程实际使用区间的总和；它不依赖于分配策略。根据给定的区间：\n\n- 对于 $R_1$：$P_1$ 使用 $[2,4]$（长度 $4-2=2$）和 $[8,9]$（长度 $9-8=1$），总计 $2+1=3$ 个单位。$P_2$ 使用 $[1,2]$（长度 $2-1=1$），计 $1$ 个单位。$P_3$ 不使用 $R_1$。因此，$R_1$ 的总繁忙时间为 $3+1=4$ 个单位。\n- 对于 $R_2$：$P_1$ 使用 $[5,7]$（长度 $7-5=2$），计 $2$ 个单位。$P_2$ 使用 $[6,8]$（长度 $8-6=2$），计 $2$ 个单位。$P_3$ 使用 $[2,3]$（长度 $3-2=1$），计 $1$ 个单位。因此，$R_2$ 的总繁忙时间为 $2+2+1=5$ 个单位。\n\n因此，两个设备的总繁忙时间为 $4+5=9$ 个单位。这个值在不同策略下是不变的，因为它加总了实际的使用时长。\n\n在禁止持有并等待的策略下，$P_1$ 和 $P_2$ 声明 $\\{R_1, R_2\\}$，并且一旦被接纳，就在其整个运行期间持有这两个设备。$P_3$ 声明 $\\{R_2\\}$，并且如果被接纳，就在其整个运行期间持有 $R_2$。因为 $P_1$ 或 $P_2$ 在其全部运行时间内都持有 $R_1$ 和 $R_2$，所以需要任一设备的其他进程都不能与它们重叠。特别是，$P_3$ 不能与 $P_1$ 或 $P_2$ 重叠，因为它需要 $R_2$，而这两个进程在它们的整个运行期间都持有 $R_2$，即使在它们不活跃使用 $R_2$ 的阶段也是如此。因此，$\\{P_1, P_2\\}$ 中至多只有一个能同时运行，并且 $P_3$ 也必须与它们串行执行。因此，该策略下的完工时间是它们运行时间的总和：$10+8+6=24$。\n\n因此，在禁止持有并等待的策略下，双设备利用率为\n$$\nU_{\\text{one-shot}} \\;=\\; \\frac{9}{2 \\times 24} \\;=\\; \\frac{9}{48} \\;=\\; \\frac{3}{16}.\n$$\n\n我们现在论证存在一个完工时间更短、利用率更高的可行增量式调度。考虑在增量式分配下的以下开始时间：在 $t=0$ 时启动 $P_1$，在 $t=0$ 时启动 $P_3$，在 $t=4$ 时启动 $P_2$。验证设备使用不重叠：\n\n- 对于 $R_1$：$P_1$ 使用 $[2,4]$ 和 $[8,9]$（绝对时间，因为 $P_1$ 在 $t=0$ 开始）。$P_2$ 从 $t=4$ 开始，在其自身开始时间的相对区间 $[1,2]$ 内使用 $R_1$，即绝对时间 $[5,6]$。这些区间与 $[2,4]$ 或 $[8,9]$ 不重叠。\n- 对于 $R_2$：$P_3$（从 $t=0$ 开始）使用绝对时间 $[2,3]$。$P_1$ 使用绝对时间 $[5,7]$。$P_2$ 在其 $t=4$ 开始的相对区间 $[6,8]$ 内使用，即绝对时间 $[10,12]$。这些区间两两不相交。\n\n因为在此调度中，所有进程的设备使用窗口都不重叠，所以没有设备竞争发生，因此没有进程等待设备。所有三个进程可以在时间上重叠而没有资源冲突。完成时间为：$P_1$ 在 $t=10$ 完成，$P_3$ 在 $t=6$ 完成，而 $P_2$ 在 $t=4+8=12$ 完成。因此，完工时间为 $\\max\\{10,6,12\\}=12$。\n\n在这种可行的增量式调度下，双设备利用率为\n$$\nU_{\\text{incremental}} \\;=\\; \\frac{9}{2 \\times 12} \\;=\\; \\frac{9}{24} \\;=\\; \\frac{3}{8}.\n$$\n因此，对于此工作负载，增量式分配下的利用率严格更高，因为分母（完工时间乘以设备数量）更小，而分子（总繁忙时间）相同。这证明了选项 B 的正确性。\n\n我们现在分析其余选项：\n\n- 选项 C 声称，在禁止持有并等待的策略下，吞吐量严格增加，因为设备得到了更充分的利用。这是不正确的。上面的例子显示了相反的现象：资源被预留但长时间闲置，阻止了其他进程在需要时使用它们。完工时间从 $12$（增量式）增加到 $24$（禁止持有并等待），利用率从 $3/8$ 下降到 $3/16$。\n\n- 选项 D 声称，在禁止持有并等待的策略下，饥饿是不可能的，因为等待的进程不持有任何设备。这是不正确的。饥饿是一个调度属性，并不仅仅通过消除持有并等待就能消除。例如，考虑一连串声明 $\\{R_1, R_2\\}$ 的长进程，它们总是被优先于一个声明 $\\{R_2\\}$ 的短进程接纳；如果接纳或优先级规则永久性地偏向新到达的进程，那么这个短进程可能会无限期地等待。等待的进程不持有设备这一事实可以防止死锁，但不能防止饥饿。\n\n结论：\n\n- A: 正确。通过禁止持有并等待，死锁的一个必要条件不成立，因此不可能发生死锁。\n- B: 正确。计算表明，对于完工时间 $24$，一次性分配策略的利用率 $U_{\\text{one-shot}}=3/16$，而一个可行的增量式调度在完工时间 $12$ 时产生利用率 $U_{\\text{incremental}}=3/8$。\n- C: 不正确。该策略通过预留闲置设备会降低利用率和吞吐量。\n- D: 不正确。即使等待的进程不持有设备，由于调度/接纳策略，饥饿仍然可能发生。", "answer": "$$\\boxed{AB}$$", "id": "3662788"}]}