{"hands_on_practices": [{"introduction": "对于拥有多个同类资源实例的系统，我们可以使用一种类似于银行家算法的死锁检测算法。这个练习让你扮演操作系统的角色，通过分析当前系统的资源分配矩阵、请求矩阵和可用资源向量，来判断是否存在一个安全的执行序列。通过这个计算，你将掌握检查系统状态以识别死锁的核心逻辑。[@problem_id:3632410]", "problem": "考虑一个操作系统 (OS)，其中有 $n=6$ 个进程 $\\{P_0,P_1,P_2,P_3,P_4,P_5\\}$ 竞争 $m=4$ 种资源类型 $\\{R_1,R_2,R_3,R_4\\}$，每种资源类型都有多个实例。系统状态由资源分配矩阵 $\\mathbf{Allocation} \\in \\mathbb{Z}^{6 \\times 4}$、请求矩阵 $\\mathbf{Request} \\in \\mathbb{Z}^{6 \\times 4}$ 以及当前可用实例向量 $\\mathbf{Available} \\in \\mathbb{Z}^{4}$ 来表征，具体如下所示。每一行对应一个进程 $P_i$，每一列对应一种资源类型 $R_j$。\n\n$$\n\\mathbf{Allocation} =\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  0  1  0 \\\\\n0  2  0  0 \\\\\n1  0  0  0 \\\\\n0  0  1  1 \\\\\n0  1  0  0\n\\end{pmatrix},\n\\quad\n\\mathbf{Request} =\n\\begin{pmatrix}\n0  0  1  0 \\\\\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  1 \\\\\n0  1  0  0\n\\end{pmatrix},\n\\quad\n\\mathbf{Available} =\n\\begin{pmatrix}\n1  0  1  0\n\\end{pmatrix}.\n$$\n\n使用经典的多实例资源死锁检测算法，该算法迭代地寻找一个未完成的进程 $P_i$，其请求向量 $Request_i$ 满足 $Request_i \\leq Work$（其中 $Work$ 初始化为 $\\mathbf{Available}$）。当找到这样一个进程时，就认为 $P_i$ 能够完成并释放其分配的资源，然后更新 $Work \\leftarrow Work + Allocation_i$。持续这个过程，直到不存在这样的 $P_i$ 为止；此时仍未完成的进程被视为不可完成的。\n\n定义量 $S$ 为所有不可完成进程的下标之和，即，如果不可完成的进程集合是 $\\{P_{i_1}, P_{i_2}, \\dots\\}$，那么 $S = i_1 + i_2 + \\dots$。计算 $S$。请以精确整数形式提供您的最终答案。无需四舍五入。", "solution": "该问题经验证具有科学依据、提法明确且客观。它描述了操作系统中的一个标准场景，并要求应用经典的死锁检测算法。所有必要的数据均已提供，问题没有矛盾或歧义。\n\n任务是确定在一个有 $n=6$ 个进程和 $m=4$ 种资源类型的系统中，不可完成的进程集合。系统状态由 $\\mathbf{Allocation}$ 矩阵、$\\mathbf{Request}$ 矩阵和 $\\mathbf{Available}$ 向量给出。\n\n已知条件如下：\n- 进程数：$n=6$，$\\{P_0,P_1,P_2,P_3,P_4,P_5\\}$。\n- 资源类型数：$m=4$，$\\{R_1,R_2,R_3,R_4\\}$。\n- 分配矩阵 $\\mathbf{Allocation} \\in \\mathbb{Z}^{6 \\times 4}$：\n$$\n\\mathbf{Allocation} =\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  0  1  0 \\\\\n0  2  0  0 \\\\\n1  0  0  0 \\\\\n0  0  1  1 \\\\\n0  1  0  0\n\\end{pmatrix}\n$$\n- 请求矩阵 $\\mathbf{Request} \\in \\mathbb{Z}^{6 \\times 4}$：\n$$\n\\mathbf{Request} =\n\\begin{pmatrix}\n0  0  1  0 \\\\\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  1 \\\\\n0  1  0  0\n\\end{pmatrix}\n$$\n- 可用向量 $\\mathbf{Available} \\in \\mathbb{Z}^{4}$：\n$$\n\\mathbf{Available} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}\n$$\n\n我们应用死锁检测算法。设 $\\mathbf{Work}$ 是一个长度为 $m$ 的向量，$\\mathbf{Finish}$ 是一个长度为 $n$ 的布尔向量。向量不等式 $\\mathbf{A} \\leq \\mathbf{B}$ 成立当且仅当对于所有分量 $k$ 都有 $A_k \\leq B_k$。\n\n**步骤 1：初始化**\n将 $\\mathbf{Work}$ 初始化为 $\\mathbf{Available}$，并将所有进程 $i = 0, \\dots, 5$ 的 $\\mathbf{Finish}_i$ 初始化为 false。\n$$ \\mathbf{Work} = \\mathbf{Available} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix} $$\n$$ \\mathbf{Finish} = \\begin{pmatrix} \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix} $$\n\n**步骤 2：迭代搜索和更新**\n算法的执行过程是，寻找一个索引 $i$，使得 $\\mathbf{Finish}_i$ 为 false 且其请求向量 $\\mathbf{Request}_i \\leq \\mathbf{Work}$。如果找到，该进程理论上可以完成，因此我们通过更新 $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_i$ 来释放其资源，并设置 $\\mathbf{Finish}_i \\leftarrow \\text{true}$。重复此过程，直到找不到这样的进程为止。\n\n**迭代 1：**\n我们寻找一个满足 $\\mathbf{Finish}_i = \\text{false}$ 且 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}$ 的进程 $P_i$。\n- $P_0$: $\\mathbf{Request}_0 = \\begin{pmatrix} 0  0  1  0 \\end{pmatrix} \\leq \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}$。此条件满足。\n我们选择 $P_0$。\n更新 $\\mathbf{Work}$：$\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_0 = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix} + \\begin{pmatrix} 1  0  0  1 \\end{pmatrix} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$。\n更新 $\\mathbf{Finish}$：$\\mathbf{Finish}_0 \\leftarrow \\text{true}$。\n当前状态为 $\\mathbf{Work} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$ 且 $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix}$。\n\n**迭代 2：**\n我们寻找一个未完成的进程 $P_i$，其请求满足 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$。\n- $P_1$: $\\mathbf{Request}_1 = \\begin{pmatrix} 1  0  0  0 \\end{pmatrix} \\leq \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$。此条件满足。\n我们选择 $P_1$。\n更新 $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_1 = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix} + \\begin{pmatrix} 0  0  1  0 \\end{pmatrix} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$。\n更新 $\\mathbf{Finish}$: $\\mathbf{Finish}_1 \\leftarrow \\text{true}$。\n当前状态为 $\\mathbf{Work} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$ 且 $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix}$。\n\n**迭代 3：**\n我们寻找一个未完成的进程 $P_i$，其请求满足 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$。\n- $P_2$: $\\mathbf{Request}_2 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$。这不满足 $\\leq \\mathbf{Work}$，因为对于第二种资源，$1 > 0$。\n- $P_3$: $\\mathbf{Request}_3 = \\begin{pmatrix} 0  0  0  0 \\end{pmatrix} \\leq \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$。此条件满足。\n我们选择 $P_3$。\n更新 $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_3 = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix} + \\begin{pmatrix} 1  0  0  0 \\end{pmatrix} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$。\n更新 $\\mathbf{Finish}$: $\\mathbf{Finish}_3 \\leftarrow \\text{true}$。\n当前状态为 $\\mathbf{Work} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$ 且 $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{false}  \\text{false} \\end{pmatrix}$。\n\n**迭代 4：**\n我们寻找一个未完成的进程 $P_i$，其请求满足 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$。\n- $P_2$: $\\mathbf{Request}_2$ 仍然不满足条件。\n- $P_4$: $\\mathbf{Request}_4 = \\begin{pmatrix} 0  0  0  1 \\end{pmatrix} \\leq \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$。此条件满足。\n我们选择 $P_4$。\n更新 $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_4 = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix} + \\begin{pmatrix} 0  0  1  1 \\end{pmatrix} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$。\n更新 $\\mathbf{Finish}$: $\\mathbf{Finish}_4 \\leftarrow \\text{true}$。\n当前状态为 $\\mathbf{Work} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$ 且 $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{true}  \\text{false} \\end{pmatrix}$。\n\n**迭代 5：**\n我们寻找一个未完成的进程 $P_i$，其请求满足 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$。剩余的未完成进程是 $P_2$ 和 $P_5$。\n- $P_2$: $\\mathbf{Request}_2 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$。这不满足 $\\leq \\mathbf{Work}$，因为对于 $R_2$，$1 > 0$。\n- $P_5$: $\\mathbf{Request}_5 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$。这不满足 $\\leq \\mathbf{Work}$，因为对于 $R_2$，$1 > 0$。\n\n**步骤 3：终止**\n没有剩余的未完成进程的请求可以被当前的 $\\mathbf{Work}$ 向量所满足。算法终止。\n\n**步骤 4：确定不可完成的进程并计算 S**\n$\\mathbf{Finish}_i$ 仍为 false 的进程被认为是不可完成的。从最终的 $\\mathbf{Finish}$ 向量 $\\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{true}  \\text{false} \\end{pmatrix}$ 来看，不可完成的进程是 $\\{P_2, P_5\\}$。\n\n问题将 $S$ 定义为所有不可完成进程的下标之和。\n$$ S = 2 + 5 = 7 $$\n造成死锁的实际原因是，$P_2$ 和 $P_5$ 都在请求资源 $R_2$ 的一个实例。而 $R_2$ 的可用实例为 0，并且没有其他可以完成的进程持有任何 $R_2$ 的实例可以释放。因此，$P_2$ 和 $P_5$ 将无限期等待。", "answer": "$$\\boxed{7}$$", "id": "3632410"}, {"introduction": "当每种资源只有一个实例时，使用等待图 (Wait-For Graph) 是一种更直观的死锁检测方法。但检测到死锁（即在图中找到环）只是问题的一半，下一步是解除死锁。这个练习不仅要求你构建等待图并识别环路，还挑战你思考如何通过抢占最少数量的进程来打破所有死锁，从而将抽象的检测问题与实际的系统恢复操作联系起来。[@problem_id:3632133]", "problem": "一个操作系统使用资源分配图 (RAG) 及其派生的等待图 (WFG) 来监控系统中的资源分配快照。在具有逻辑“与”请求语义的单实例资源模型下，当且仅当进程 $P_{i}$ 当前被阻塞并且正在请求至少一个由进程 $P_{j}$ 持有的资源时，WFG 中才会出现一条从进程 $P_{i}$ 到进程 $P_{j}$ 的边。当且仅当 WFG 包含至少一个有向环时，存在死锁。系统可以执行资源抢占来进行恢复：抢占进程 $P_{v}$ 会立即释放 $P_{v}$ 持有的所有资源，并从 WFG 中移除 $P_{v}$ 及其所有关联边。\n\n考虑以下包含 $7$ 个进程 $\\{P_{1},P_{2},P_{3},P_{4},P_{5},P_{6},P_{7}\\}$ 和 $8$ 个单实例资源 $\\{R_{1},R_{2},R_{3},R_{4},R_{5},R_{6},R_{8}\\}$ 的科学上合理的快照（请注意，资源标识符不必是连续的）：\n\n- 当前持有情况（每个资源恰好由一个进程持有）：\n  - $R_{3}$ 由 $P_{1}$ 持有。\n  - $R_{1}$ 由 $P_{2}$ 持有。\n  - $R_{2}$ 由 $P_{3}$ 持有。\n  - $R_{4}$ 由 $P_{4}$ 持有。\n  - $R_{5}$ 由 $P_{5}$ 持有。\n  - $R_{6}$ 由 $P_{6}$ 持有。\n  - $R_{8}$ 由 $P_{7}$ 持有。\n\n- 当前待处理请求（每个项目符号表示一个被阻塞的进程，该进程同时请求所有列出的资源，而每个资源当前都由上述指定的持有者持有）：\n  - $P_{1}$ 请求 $\\{R_{1}\\}$。\n  - $P_{2}$ 请求 $\\{R_{2},R_{5}\\}$。\n  - $P_{3}$ 请求 $\\{R_{3},R_{4}\\}$。\n  - $P_{4}$ 请求 $\\{R_{5},R_{8}\\}$。\n  - $P_{5}$ 请求 $\\{R_{2},R_{6}\\}$。\n  - $P_{6}$ 请求 $\\{R_{1}\\}$。\n  - $P_{7}$ 请求 $\\{R_{4}\\}$。\n\n仅使用上述基本定义：\n- 通过为 $P_{i}$ 请求的、当前由 $P_{j}$ 持有的每个资源引入一条有向边 $P_{i} \\to P_{j}$ 来构建等待图。\n- 通过识别 WFG 中的有向环来推断死锁。\n- 在所述的抢占模型下，将死锁恢复解释为选择一组进程（牺牲者），抢占这些进程会破坏 WFG 中的所有有向环。\n\n确定为使最终的 WFG 成为无环图而必须抢占的进程的最小可能数量。以单个整数形式报告您的答案。无需四舍五入，也无需单位。最终答案必须是单个整数。", "solution": "问题提供了一个包含多个进程和单实例资源的系统快照，并要求为解决所有死锁而需要抢占的最小进程数。该问题基于操作系统和图论的标准原则，科学上成立、定义明确且客观。因此，这是一个有效的问题。\n\n解决方案分三步进行：\n1.  根据给定的进程持有情况和请求构建等待图 (WFG)。\n2.  识别 WFG 中的所有有向环，因为环表示存在死锁。\n3.  确定移除后能破坏所有环的最小顶点（进程）集。这等同于寻找 WFG 的最小反馈顶点集。\n\n**步骤 1：构建等待图 (WFG)**\n\nWFG 的顶点是进程集合 $V = \\{P_{1}, P_{2}, P_{3}, P_{4}, P_{5}, P_{6}, P_{7}\\}$。\n如果进程 $P_{i}$ 正在请求一个由进程 $P_{j}$ 持有的资源，则存在一条有向边 $P_{i} \\to P_{j}$。我们分析给定的请求来确定图的边集 $E$。\n\n-   进程 $P_{1}$ 请求 $\\{R_{1}\\}$。资源 $R_{1}$ 由 $P_{2}$ 持有。这创建一条边 $P_{1} \\to P_{2}$。\n-   进程 $P_{2}$ 请求 $\\{R_{2}, R_{5}\\}$。资源 $R_{2}$ 由 $P_{3}$ 持有，$R_{5}$ 由 $P_{5}$ 持有。这创建边 $P_{2} \\to P_{3}$ 和 $P_{2} \\to P_{5}$。\n-   进程 $P_{3}$ 请求 $\\{R_{3}, R_{4}\\}$。资源 $R_{3}$ 由 $P_{1}$ 持有，$R_{4}$ 由 $P_{4}$ 持有。这创建边 $P_{3} \\to P_{1}$ 和 $P_{3} \\to P_{4}$。\n-   进程 $P_{4}$ 请求 $\\{R_{5}, R_{8}\\}$。资源 $R_{5}$ 由 $P_{5}$ 持有，$R_{8}$ 由 $P_{7}$ 持有。这创建边 $P_{4} \\to P_{5}$ 和 $P_{4} \\to P_{7}$。\n-   进程 $P_{5}$ 请求 $\\{R_{2}, R_{6}\\}$。资源 $R_{2}$ 由 $P_{3}$ 持有，$R_{6}$ 由 $P_{6}$ 持有。这创建边 $P_{5} \\to P_{3}$ 和 $P_{5} \\to P_{6}$。\n-   进程 $P_{6}$ 请求 $\\{R_{1}\\}$。资源 $R_{1}$ 由 $P_{2}$ 持有。这创建一条边 $P_{6} \\to P_{2}$。\n-   进程 $P_{7}$ 请求 $\\{R_{4}\\}$。资源 $R_{4}$ 由 $P_{4}$ 持有。这创建一条边 $P_{7} \\to P_{4}$。\n\nWFG 中完整的边集为：\n$E = \\{ (P_{1}, P_{2}), (P_{2}, P_{3}), (P_{2}, P_{5}), (P_{3}, P_{1}), (P_{3}, P_{4}), (P_{4}, P_{5}), (P_{4}, P_{7}), (P_{5}, P_{3}), (P_{5}, P_{6}), (P_{6}, P_{2}), (P_{7}, P_{4}) \\}$。\n\n**步骤 2：识别有向环**\n\n当且仅当 WFG 中至少存在一个有向环时，才存在死锁。通过检查由 $V$ 和 $E$ 定义的图，我们可以识别出以下基本环：\n\n1.  $C_{1}: P_{1} \\to P_{2} \\to P_{3} \\to P_{1}$。该环涉及进程 $\\{P_{1}, P_{2}, P_{3}\\}$。\n2.  $C_{2}: P_{2} \\to P_{5} \\to P_{3} \\to P_{1} \\to P_{2}$。该环涉及进程 $\\{P_{1}, P_{2}, P_{3}, P_{5}\\}$。\n3.  $C_{3}: P_{2} \\to P_{5} \\to P_{6} \\to P_{2}$。该环涉及进程 $\\{P_{2}, P_{5}, P_{6}\\}$。\n4.  $C_{4}: P_{4} \\to P_{7} \\to P_{4}$。该环涉及进程 $\\{P_{4}, P_{7}\\}$。\n5.  $C_{5}: P_{3} \\to P_{4} \\to P_{5} \\to P_{3}$。该环涉及进程 $\\{P_{3}, P_{4}, P_{5}\\}$。\n\n由于存在多个环，系统处于死锁状态。所有 7 个进程都至少参与了一个环。\n\n**步骤 3：确定最小抢占数量**\n\n为从死锁中恢复，我们必须抢占一组进程（牺牲者），使得从 WFG 中移除它们可以消除所有有向环。这就是最小反馈顶点集问题。对于这种规模的图，我们可以通过直接分析来确定最小数量。\n\n首先，我们检查抢占单个进程是否足够。\n-   抢占 $P_{1}$：破坏环 $C_{1}$ 和 $C_{2}$。环 $C_{3}$、$C_{4}$ 和 $C_{5}$ 仍然存在。\n-   抢占 $P_{2}$：破坏环 $C_{1}$、$C_{2}$ 和 $C_{3}$。环 $C_{4}$ 和 $C_{5}$ 仍然存在。\n-   抢占 $P_{3}$：破坏环 $C_{1}$、$C_{2}$ 和 $C_{5}$。环 $C_{3}$ 和 $C_{4}$ 仍然存在。\n-   抢占 $P_{4}$：破坏环 $C_{4}$ 和 $C_{5}$。环 $C_{1}$、$C_{2}$ 和 $C_{3}$ 仍然存在。\n-   抢占 $P_{5}$：破坏环 $C_{2}$、$C_{3}$ 和 $C_{5}$。环 $C_{1}$ 和 $C_{4}$ 仍然存在。\n-   抢占 $P_{6}$：仅破坏环 $C_{3}$。\n-   抢占 $P_{7}$：仅破坏环 $C_{4}$。\n\n由于没有任何一次单一抢占可以破坏所有环，因此最小牺牲者数量必须大于 1。\n\n接下来，我们检查抢占两个进程是否足够。我们需要找到一对进程 $\\{P_{i}, P_{j}\\}$，它们共同存在于每个环中。\n让我们分析每个进程参与的环：\n-   $P_{1}$：在 $\\{C_{1}, C_{2}\\}$ 中\n-   $P_{2}$：在 $\\{C_{1}, C_{2}, C_{3}\\}$ 中\n-   $P_{3}$：在 $\\{C_{1}, C_{2}, C_{5}\\}$ 中\n-   $P_{4}$：在 $\\{C_{4}, C_{5}\\}$ 中\n-   $P_{5}$：在 $\\{C_{2}, C_{3}, C_{5}\\}$ 中\n-   $P_{6}$：在 $\\{C_{3}\\}$ 中\n-   $P_{7}$：在 $\\{C_{4}\\}$ 中\n\n考虑牺牲者集合 $\\{P_{2}, P_{4}\\}$。\n-   抢占 $P_{2}$ 会破坏环 $C_{1}$、$C_{2}$ 和 $C_{3}$。\n-   剩余需要破坏的环是 $C_{4}$ 和 $C_{5}$。\n-   抢占 $P_{4}$ 会破坏环 $C_{4}$ 和 $C_{5}$。\n\n因此，抢占进程集 $\\{P_{2}, P_{4}\\}$ 足以破坏 WFG 中的所有环。\n因为抢占 1 个进程不足够，而抢占 2 个进程足够，所以必须抢占的进程的最小可能数量是 2。", "answer": "$$\\boxed{2}$$", "id": "3632133"}, {"introduction": "为了将理论付诸实践，没有什么比亲手实现一个死锁检测器更好的了。这个练习将指导你利用图论中的强连通分量 (Strongly Connected Components, SCC) 算法来高效地寻找等待图中的环。通过编写代码来分析给定的等待图，你将不仅加深对死锁条件的理解，还能体会到算法在解决实际系统问题中的强大作用。[@problem_id:3632165]", "problem": "考虑在操作系统死锁检测背景下的以下计算实验。给定一组由进程集合导出的等待图 (WFG)，这些图是有限有向图。WFG 是一个有向图，其顶点是进程，当且仅当进程 $P_i$ 正在等待由进程 $P_j$ 持有的资源时，存在一条从 $P_i$ 到 $P_j$ 的有向边。我们将依赖的基础包括以下来自图论和操作系统的标准定义和事实。\n\n1. 一个有向图存在死锁，当且仅当图中存在至少一个有向环。在 WFG 中，有向环对应一组进程，其中每个进程都在等待环中的下一个进程，因此若无外部干预，它们都无法继续执行。\n2. 强连通分量 (SCC) 是一个顶点极大集合，其中集合内的任意两个顶点相互可达。每个有向环都完全包含在单个 SCC 内。反之，每个规模至少为 $2$ 的 SCC 至少包含一个有向环；规模为 $1$ 的 SCC 仅在有自环的情况下才包含环。\n3. 任务是检测 SCC，并将其与最小死锁环进行比较，以理解为什么在第 $1$ 项的精确定义下，某些 SCC 并不对应于死锁。\n\n你的程序必须：\n- 在内部构建每个测试图并执行两项分析：\n  - 计算 SCC 的数量，以及根据上述定义实际表示死锁的 SCC 的数量（即，规模至少为 $2$ 的 SCC，或带有自环的规模为 $1$ 的 SCC）。\n  - 计算整个图中最短有向环（一个最小死锁环）的长度，长度定义为环上不同顶点的数量。如果不存在有向环，则长度应报告为 $0$。\n- 此外，报告陷入死锁的总进程数，定义为所有符合刚才定义的死锁 SCC 的规模之和。\n\n对于每个图，你必须将进程标识符视为从 $1$ 到 $n$ 的整数。所有图都是有限有向图。\n\n测试套件：\n为恰好 $4$ 个测试图提供结果。每个图由一个序对 $\\left(n, E\\right)$ 指定，其中 $n$ 是进程（顶点）数， $E$ 是有向边的集合：\n- 测试用例 $1$：$n = 5$，边 $E = \\{(1,2),(2,3),(3,1),(4,5)\\}$。\n- 测试用例 $2$：$n = 4$，边 $E = \\{(1,2),(2,3),(3,4)\\}$。\n- 测试用例 $3$：$n = 4$，边 $E = \\{(1,1),(2,3),(3,2)\\}$。\n- 测试用例 $4$：$n = 6$，边 $E = \\{(1,2),(2,3),(3,1),(3,4),(4,2),(5,6)\\}$。\n\n对于每个测试用例，你的程序必须计算以下 $4$ 个整数：\n- $s$：强连通分量的总数，\n- $d$：根据上述定义构成死锁的 SCC 数量，\n- $\\ell$：整个图中最短有向环的长度（如果没有环，则使用 $\\ell = 0$），\n- $t$：陷入死锁的总进程数（所有死锁 SCC 的规模之和）。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含所有四个测试用例的结果，格式为逗号分隔的列表的列表，每个内部列表按 $\\left[s,d,\\ell,t\\right]$ 的顺序排列，并用一对单独的方括号括起来。例如，格式必须与\n$[\\,[s_1,d_1,\\ell_1,t_1],[s_2,d_2,\\ell_2,t_2],[s_3,d_3,\\ell_3,t_3],[s_4,d_4,\\ell_4,t_4]\\,]$ 完全一样。\n\n本问题不涉及物理单位或角度。所有输出均为以十进制数字书写的整数。", "solution": "该问题在科学上是有效的，它基于图论的既定原则及其在操作系统死锁检测中的应用。问题定义明确、客观，并提供了推导出唯一、可验证解所需的所有信息。\n\n对于每个给定的有向图，我们需要计算四个值：\n1.  $s$：强连通分量 (SCC) 的总数。\n2.  $d$：构成死锁的 SCC 的数量（规模 $\\ge 2$ 的 SCC，或带有自环的规模为 $1$ 的 SCC）。\n3.  $\\ell$：图中最短有向环的长度（若无环则为 0）。\n4.  $t$：陷入死锁的总进程数（所有死锁 SCC 的规模之和）。\n\n我们将对每个测试用例进行分析。\n\n**测试用例 1：$n = 5$，边 $E = \\{(1,2),(2,3),(3,1),(4,5)\\}$**\n-   **图结构**：该图包含一个由进程 $\\{1,2,3\\}$ 构成的环 ($1 \\to 2 \\to 3 \\to 1$) 和一条独立的边 $4 \\to 5$。\n-   **SCC 分析**：\n    -   强连通分量为 $\\{1,2,3\\}$, $\\{4\\}$, 和 $\\{5\\}$。因此，$s=3$。\n    -   $\\{1,2,3\\}$ 的规模为 3 ( $\\ge 2$ )，构成一个死锁。$\\{4\\}$ 和 $\\{5\\}$ 规模为 1 且无自环，不是死锁。因此，$d=1$。\n    -   陷入死锁的进程总数为 $\\{1,2,3\\}$ 的规模，即 $t=3$。\n-   **最短环**：图中唯一的环是 $1 \\to 2 \\to 3 \\to 1$，其长度为 3。因此，$\\ell=3$。\n-   **结果**: $[3, 1, 3, 3]$。\n\n**测试用例 2：$n = 4$，边 $E = \\{(1,2),(2,3),(3,4)\\}$**\n-   **图结构**：这是一个有向无环图 (DAG)，形如一条链 $1 \\to 2 \\to 3 \\to 4$。\n-   **SCC 分析**：\n    -   每个顶点自身构成一个强连通分量：$\\{1\\}, \\{2\\}, \\{3\\}, \\{4\\}$。因此，$s=4$。\n    -   所有 SCC 的规模均为 1 且无自环。因此，不存在死锁，$d=0$。\n    -   陷入死锁的进程总数为 $t=0$。\n-   **最短环**：图中没有环。因此，$\\ell=0$。\n-   **结果**: $[4, 0, 0, 0]$。\n\n**测试用例 3：$n = 4$，边 $E = \\{(1,1),(2,3),(3,2)\\}$**\n-   **图结构**：该图包含一个在进程 1 上的自环 ($1 \\to 1$)，一个在进程 $\\{2,3\\}$ 之间的双向环 ($2 \\leftrightarrow 3$)，以及一个孤立的进程 4。\n-   **SCC 分析**：\n    -   强连通分量为 $\\{1\\}, \\{2,3\\}, \\{4\\}$。因此，$s=3$。\n    -   $\\{1\\}$ 是一个规模为 1 但有自环的 SCC，构成死锁。$\\{2,3\\}$ 是一个规模为 2 的 SCC，也构成死锁。$\\{4\\}$ 不是死锁。因此，$d=2$。\n    -   陷入死锁的进程总数为 $\\{1\\}$ 和 $\\{2,3\\}$ 的规模之和，即 $1+2=3$。因此，$t=3$。\n-   **最短环**：图中存在两个环：$1 \\to 1$ (长度 1) 和 $2 \\to 3 \\to 2$ (长度 2)。最短环的长度是 1。因此，$\\ell=1$。\n-   **结果**: $[3, 2, 1, 3]$。\n\n**测试用例 4：$n = 6$，边 $E = \\{(1,2),(2,3),(3,1),(3,4),(4,2),(5,6)\\}$**\n-   **图结构**：该图包含两个交错的环：$1 \\to 2 \\to 3 \\to 1$ 和 $2 \\to 3 \\to 4 \\to 2$。此外还有一条边 $5 \\to 6$。\n-   **SCC 分析**：\n    -   由于环的交错，进程 $\\{1,2,3,4\\}$ 都是相互可达的，因此它们共同构成一个大的强连通分量。进程 5 和 6 各自构成一个 SCC。强连通分量为 $\\{1,2,3,4\\}, \\{5\\}, \\{6\\}$。因此，$s=3$。\n    -   $\\{1,2,3,4\\}$ 的规模为 4，构成死锁。$\\{5\\}$ 和 $\\{6\\}$ 不是死锁。因此，$d=1$。\n    -   陷入死锁的进程总数为 $\\{1,2,3,4\\}$ 的规模，即 $t=4$。\n-   **最短环**：图中存在两个长度为 3 的环：$1 \\to 2 \\to 3 \\to 1$ 和 $2 \\to 3 \\to 4 \\to 2$。最短环长度是 3。因此，$\\ell=3$。\n-   **结果**: $[3, 1, 3, 4]$。\n\n将所有结果汇总，得到最终输出。", "answer": "[[3,1,3,3],[4,0,0,0],[3,2,1,3],[3,1,3,4]]", "id": "3632165"}]}