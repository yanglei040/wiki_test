{"hands_on_practices": [{"introduction": "理论知识是基础，但真正的理解来自于将其应用于解决实际问题。这个练习将我们置于一个实验室协调员的角色，面对一个经典的资源共享难题。通过评估不同的设备预订策略，我们不仅能复习死锁产生的四个必要条件，还能深入理解死锁预防（如资源排序）和死锁避免（如银行家算法）在设计上的根本区别与权衡[@problem_id:3631764]。", "problem": "一位实验室协调员希望将课堂设备借出系统建模为操作系统 (OS) 框架内的一个资源分配问题，以避免在实验室轮换期间出现死锁。现有 $2$ 种资源类型：显微镜（$r_1$ 型）和示波器（$r_2$ 型）。两者都是物理设备，因此资源是不可抢占的。实验小组随时间动态到达，他们可能从事需要单个设备的任务，或者对于跨学科步骤，需要同时使用两种设备。协调员无法提前可靠地知道每个小组未来的最大需求。目标是采用一种可证明能避免死锁的预留策略，同时在安全的情况下，仍然允许小组在使用单个设备时取得进展（例如，在等待示波器的同时，使用显微镜准备样品）。\n\n使用死锁理论的基本基础：Coffman 条件指出，如果以下所有条件同时成立，就可能出现死锁——互斥、持有并等待、不可抢占和循环等待。可以通过设计策略来确保系统永远不会进入可能发生死锁的状态，从而实现死锁避免。\n\n哪一项预留策略最能满足协调员的约束和目标？\n\nA. 先来先服务 (FCFS)：当所请求的设备可用时，批准每个请求；如果一个小组持有一个设备，允许它等待直到第二个设备可用，对请求顺序没有限制。\n\nB. 对资源类型强制实施一个严格的全序关系，并要求所有小组按递增顺序请求（例如，总是先请求 $r_1$ 再请求 $r_2$），并拒绝任何不按顺序的请求；小组可以持有 $r_1$ 并在之后根据该顺序请求 $r_2$。\n\nC. 尽管每个小组未来的最大声明未知，仍在每次请求时应用银行家算法；仅从当前可用性推断安全性，并接受任何不会立即耗尽设备的请求。\n\nD. 强制执行“要么全部，要么全不”的组合预留：仅当 $r_1$ 和 $r_2$ 同时可用时才批准小组的请求；否则拒绝并要求稍后重新提交，从而阻止在等待时使用单个设备取得任何进展。", "solution": "解决此问题的关键是分析每个策略如何与死锁的四个必要条件（特别是“持有并等待”和“循环等待”）相互作用，以及它们是否满足问题中给出的所有约束（例如，不知道最大需求）。\n\n*   **A. 先来先服务 (FCFS):** 该策略允许一个小组持有一个资源（例如显微镜，$r_1$）同时等待另一个资源（示波器，$r_2$）。如果另一个小组同时持有 $r_2$ 并等待 $r_1$，就会形成一个由两个小组组成的循环等待链。由于互斥、持有并等待、非抢占和循环等待这四个条件都可以同时满足，因此该策略不能保证避免死锁。因此，A 是不正确的。\n\n*   **B. 资源排序:** 该策略通过破坏**循环等待**条件来预防死锁。通过强制所有小组都必须按特定顺序（$r_1$ 先于 $r_2$）请求资源，就不可能形成一个循环的等待链。例如，一个持有 $r_2$ 的小组永远不能请求 $r_1$，从而打破了潜在的循环。该策略不需要知道未来的最大需求，并且允许一个小组在持有 $r_1$ 的同时等待 $r_2$，满足了“在使用单个设备时取得进展”的要求。因此，B 是一个有效且合适的策略。\n\n*   **C. 银行家算法:** 这是一个经典的死锁**避免**算法，但它有一个关键的前提条件：系统必须预先知道每个进程（小组）对其所需的所有资源的最大声明。问题明确指出“协调员无法提前可靠地知道每个小组未来的最大需求”。因此，银行家算法在这种情况下是不适用的。因此，C 是不正确的。\n\n*   **D. “要么全部，要么全不” (All-or-Nothing):** 该策略通过破坏**持有并等待**条件来预防死锁。小组要么一次性获得所有需要的资源，要么一个也得不到（并且必须等待）。这可以有效地防止死锁。然而，它违反了问题中的一个关键目标：“允许小组在使用单个设备时取得进展”。在这种策略下，一个小组不能持有显微镜来准备样品，除非示波器也同时可用。因此，D 是不合适的。\n\n**结论:** 资源排序（选项 B）是唯一一个既能保证避免死锁，又符合所有操作约束（无需知道最大需求，并允许部分资源分配）的策略。", "answer": "$$\\boxed{B}$$", "id": "3631764"}, {"introduction": "银行家算法的核心在于其“安全性检查”机制，即判断系统是否处于一个“安全状态”。这个练习将这个抽象概念具体化为一个计算任务。通过手动计算需求矩阵并一步步寻找所有可能的安全序列，你将亲身体验该算法的运作流程，从而将理论知识转化为解决问题的实用技能[@problem_id:3631832]。", "problem": "一个移动机器人实验室部署了一个由 $3$ 个机器人组成的集群，它们以类似操作系统 (OS) 的方式共享由中央实验室调度器提供的两种充电资源：快速充电桩 ($F$) 和标准充电桩 ($S$)。每个机器人都需要这些资源的组合来完成其充电过程。该实验室调度器使用死锁避免中的概念为资源使用建模，特别是安全状态的概念以及作为银行家调度策略基础的最大需求框架。\n\n实验室内可用的资源总数为 $\\mathbf{T} = (F, S) = (5, 6)$。在某一时刻，每个机器人的当前资源分配和声明的最大需求如下所示，其中行对应机器人 $R_1$、$R_2$ 和 $R_3$，列对应 $F$ 和 $S$：\n\n当前分配矩阵 $\\mathbf{A}$：\n$$\n\\mathbf{A} = \n\\begin{pmatrix}\n1  2 \\\\\n2  0 \\\\\n1  3\n\\end{pmatrix}.\n$$\n\n最大需求矩阵 $\\mathbf{M}$：\n$$\n\\mathbf{M} =\n\\begin{pmatrix}\n3  3 \\\\\n3  2 \\\\\n2  4\n\\end{pmatrix}.\n$$\n\n从死锁避免中安全状态的核心定义出发——即，如果存在某个机器人完成顺序，使得每个机器人都能从当前可用资源加上先前完成的机器人所释放的资源中获得其剩余所需资源，则该状态是安全的——请将此充电场景映射到最大需求框架，并确定此刻存在多少个不同的安全充电完成序列。将最终答案表示为一个整数。无需四舍五入。", "solution": "问题要求根据用于死锁避免的银行家算法，计算一个由 $3$ 个机器人竞争 $2$ 种资源的系统中不同安全完成序列的数量。如果存在至少一个机器人完成序列，使得每个机器人都能获得其所需的最大资源，则该状态是安全的。我们需要找到所有这样的唯一序列。\n\n首先，我们使用银行家算法的标准术语将问题形式化。\n进程（机器人）的数量为 $n=3$，资源类型（充电桩）的数量为 $m=2$。\n\n已知条件如下：\n- 每种可用资源的总数，由向量 $\\mathbf{T} = (5, 6)$ 表示，其中第一个分量代表快速充电桩 ($F$)，第二个分量代表标准充电桩 ($S$)。\n- 当前分配矩阵 $\\mathbf{A}$，它指定了当前分配给每个机器人的每种资源的数量。\n$$\n\\mathbf{A} = \n\\begin{pmatrix}\n1  2 \\\\\n2  0 \\\\\n1  3\n\\end{pmatrix}\n$$\n行对应机器人 $R_1$、$R_2$ 和 $R_3$。\n- 最大需求矩阵 $\\mathbf{M}$，它指定了每个机器人在其整个充电过程中可能请求的每种资源的最大数量。\n$$\n\\mathbf{M} =\n\\begin{pmatrix}\n3  3 \\\\\n3  2 \\\\\n2  4\n\\end{pmatrix}\n$$\n\n根据这些已知条件，我们可以推导出安全算法所需的关键组件。\n\n1.  **计算可用资源向量 $\\mathbf{V}$**：\n每种类型的已分配资源总数是分配矩阵 $\\mathbf{A}$ 的列之和。\n已分配的 $F$ 资源总数：$1 + 2 + 1 = 4$。\n已分配的 $S$ 资源总数：$2 + 0 + 3 = 5$。\n已分配资源总量向量为 $(4, 5)$。\n\n可用资源向量 $\\mathbf{V}$ 是总资源向量 $\\mathbf{T}$ 减去已分配资源总量向量。\n$$\n\\mathbf{V} = \\mathbf{T} - (4, 5) = (5, 6) - (4, 5) = (1, 1)\n$$\n因此，初始时，有 $1$ 个快速充电桩和 $1$ 个标准充电桩可用。\n\n2.  **计算需求矩阵 $\\mathbf{N}$**：\n需求矩阵 $\\mathbf{N}$ 表示每个机器人可能还需请求的剩余资源。它通过最大需求矩阵 $\\mathbf{M}$ 与当前分配矩阵 $\\mathbf{A}$ 之差计算得出。\n$$\n\\mathbf{N} = \\mathbf{M} - \\mathbf{A} = \n\\begin{pmatrix}\n3 - 1  3 - 2 \\\\\n3 - 2  2 - 0 \\\\\n2 - 1  4 - 3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n2  1 \\\\\n1  2 \\\\\n1  1\n\\end{pmatrix}\n$$\n$\\mathbf{N}$ 的行是每个机器人的需求向量：\n- $R_1$ 的需求：$\\mathbf{N}_1 = (2, 1)$\n- $R_2$ 的需求：$\\mathbf{N}_2 = (1, 2)$\n- $R_3$ 的需求：$\\mathbf{N}_3 = (1, 1)$\n\n3.  **使用安全算法找到所有安全序列**：\n安全算法检查是否存在一个机器人序列 $\\langle R_{i_1}, R_{i_2}, \\dots, R_{i_n} \\rangle$，使得对于每个机器人 $R_{i_k}$，其需求向量 $\\mathbf{N}_{i_k}$ 小于或等于当前可用资源向量。如果此条件成立，该机器人就可以完成其任务并释放其已分配的资源，这些资源随后被添加到可用资源池中。我们必须找到所有这样的有效序列。\n\n设未完成的机器人集合为 $\\{R_1, R_2, R_3\\}$。初始可用向量为 $\\mathbf{V}^{(0)} = (1, 1)$。\n\n**第 1 步：寻找序列中的第一个机器人。**\n我们检查哪个机器人 $R_i$ 满足条件 $\\mathbf{N}_i \\le \\mathbf{V}^{(0)}$。如果对于所有分量 $j$ 都有 $a_j \\le b_j$，则向量 $\\mathbf{a} \\le \\mathbf{b}$。\n- 对于 $R_1$：$\\mathbf{N}_1 = (2, 1) \\le (1, 1)$ 是否成立？否，因为 $2 > 1$。\n- 对于 $R_2$：$\\mathbf{N}_2 = (1, 2) \\le (1, 1)$ 是否成立？否，因为 $2 > 1$。\n- 对于 $R_3$：$\\mathbf{N}_3 = (1, 1) \\le (1, 1)$ 是否成立？是，因为 $1 \\le 1$ 且 $1 \\le 1$。\n\n只有 $R_3$ 可以作为安全序列中的第一个机器人。因此，任何安全序列都必须以 $\\langle R_3, \\dots \\rangle$ 开头。\n\n**第 2 步：寻找序列中的第二个机器人。**\n假设 $R_3$ 运行至完成，它会释放其已分配的资源 $\\mathbf{A}_3 = (1, 3)$。新的可用资源向量变为：\n$$\n\\mathbf{V}^{(1)} = \\mathbf{V}^{(0)} + \\mathbf{A}_3 = (1, 1) + (1, 3) = (2, 4)\n$$\n现在未完成的机器人集合是 $\\{R_1, R_2\\}$。我们检查在可用资源为 $\\mathbf{V}^{(1)} = (2, 4)$ 的情况下，这些机器人中哪个可以接下来运行。\n- 对于 $R_1$：$\\mathbf{N}_1 = (2, 1) \\le (2, 4)$ 是否成立？是，因为 $2 \\le 2$ 且 $1 \\le 4$。\n- 对于 $R_2$：$\\mathbf{N}_2 = (1, 2) \\le (2, 4)$ 是否成立？是，因为 $1 \\le 2$ 且 $2 \\le 4$。\n\n$R_1$ 和 $R_2$ 都可以作为序列中的第二个机器人。这产生了两个不同的分支。\n\n**分支 A：序列为 $\\langle R_3, R_1, \\dots \\rangle$。**\n$R_1$ 运行并释放其已分配的资源 $\\mathbf{A}_1 = (1, 2)$。新的可用向量为：\n$$\n\\mathbf{V}^{(2A)} = \\mathbf{V}^{(1)} + \\mathbf{A}_1 = (2, 4) + (1, 2) = (3, 6)\n$$\n唯一剩下的未完成机器人是 $R_2$。我们检查它是否可以运行。\n- 对于 $R_2$：$\\mathbf{N}_2 = (1, 2) \\le (3, 6)$ 是否成立？是，因为 $1 \\le 3$ 且 $2 \\le 6$。\n$R_2$ 可以完成。这得出了第一个安全序列：$\\langle R_3, R_1, R_2 \\rangle$。\n\n**分支 B：序列为 $\\langle R_3, R_2, \\dots \\rangle$。**\n$R_2$ 运行并释放其已分配的资源 $\\mathbf{A}_2 = (2, 0)$。新的可用向量为：\n$$\n\\mathbf{V}^{(2B)} = \\mathbf{V}^{(1)} + \\mathbf{A}_2 = (2, 4) + (2, 0) = (4, 4)\n$$\n唯一剩下的未完成机器人是 $R_1$。我们检查它是否可以运行。\n- 对于 $R_1$：$\\mathbf{N}_1 = (2, 1) \\le (4, 4)$ 是否成立？是，因为 $2 \\le 4$ 且 $1 \\le 4$。\n$R_1$ 可以完成。这得出了第二个安全序列：$\\langle R_3, R_2, R_1 \\rangle$。\n\n我们已经探索了所有可能的路径。搜索的结论是，恰好存在两个不同的安全完成序列。\n\n安全序列的集合是：\n1. $\\langle R_3, R_1, R_2 \\rangle$\n2. $\\langle R_3, R_2, R_1 \\rangle$\n\n不同的安全充电完成序列的总数为 $2$。", "answer": "$$\\boxed{2}$$", "id": "3631832"}, {"introduction": "现实世界中的系统很少是静态的，进程的需求可能会在运行时发生变化。这个更具挑战性的练习探讨了当一个进程动态增加其最大资源声明时，系统如何维持安全状态。这不仅考验了你对银行家算法基本应用的掌握，更促使你思考在动态环境中维持系统稳定性的关键约束条件，这是设计稳健资源管理器的核心能力[@problem_id:3631866]。", "problem": "考虑一个使用 Dijkstra 银行家算法（一种资源分配和死锁避免算法）来管理两种资源类型（表示为 $R_1$ 和 $R_2$）的系统。设总资源向量为 $$T = \\begin{pmatrix} 10 \\\\ 9 \\end{pmatrix},$$ 其中第一个分量对应于 $R_1$，第二个分量对应于 $R_2$。系统中有 4 个进程，$P_1, P_2, P_3, P_4$。当前分配矩阵为 $$A = \\begin{pmatrix} 2  1 \\\\ 3  2 \\\\ 2  3 \\\\ 1  1 \\end{pmatrix},$$ 其中第 $i$ 行给出了当前分配给进程 $P_i$ 的 $(R_1, R_2)$ 资源单位数。初始声明的最大需求矩阵为 $$M = \\begin{pmatrix} 4  3 \\\\ 5  4 \\\\ 3  5 \\\\ 3  2 \\end{pmatrix},$$ 其中第 $i$ 行给出了进程 $P_i$ 在其整个生命周期中可能需要的 $(R_1, R_2)$ 资源的最大单位数。\n\n在时刻 $t$，在上述分配生效之后、任何进一步的资源请求被批准之前，进程 $P_1$ 发出一个动态更新，将其对 $R_1$ 的最大需求增加 $x$ 个单位（其对 $R_2$ 的最大需求保持不变）。这将其最大需求行从 $\\begin{pmatrix} 4  3 \\end{pmatrix}$ 变为 $\\begin{pmatrix} 4 + x  3 \\end{pmatrix}$。系统将接受此动态更新，当且仅当根据安全状态的定义，由此产生的状态仍然是安全的：存在某个进程终止序列，使得序列中的每个进程，其剩余需求都能由当前可用资源加上先前已完成进程释放的资源来满足。\n\n假设不允许抢占当前持有的资源，除非在动态更新后无法维持安全性。仅使用安全状态、可用资源、分配、最大需求和需求的基石定义，确定最大的整数 $x$，使得该动态更新可以在不强制抢占的情况下被接受。请以精确整数形式给出答案，无需四舍五入。", "solution": "问题要求找出最大的整数 $x$，使得对进程 $P_1$ 最大需求的动态更新是允许的，即更新后的系统状态仍然是安全的。一个状态是安全的，如果存在一个进程序列，使得每个进程都能获取其所需的最大资源并运行至完成。\n\n首先，让我们将给定的信息形式化。系统有 4 个进程，$P_1, P_2, P_3, P_4$，和 2 种资源类型，$R_1$ 和 $R_2$。\n\n总资源向量由下式给出：\n$$T = \\begin{pmatrix} 10 \\\\ 9 \\end{pmatrix}$$\n\n当前分配矩阵 $A$ 为：\n$$A = \\begin{pmatrix} 2  1 \\\\ 3  2 \\\\ 2  3 \\\\ 1  1 \\end{pmatrix}$$\n其中第 $i$ 行对应于分配给进程 $P_i$ 的资源。\n\n初始最大需求矩阵 $M$ 为：\n$$M = \\begin{pmatrix} 4  3 \\\\ 5  4 \\\\ 3  5 \\\\ 3  2 \\end{pmatrix}$$\n\n每种资源类型的已分配资源总量是分配矩阵 $A$ 各列之和。我们将其表示为向量 $A_{total}$。\n$$A_{total} = \\begin{pmatrix} 2+3+2+1 \\\\ 1+2+3+1 \\end{pmatrix} = \\begin{pmatrix} 8 \\\\ 7 \\end{pmatrix}$$\n\n可用资源向量 $V$ 是总资源减去总已分配资源：\n$$V = T - A_{total} = \\begin{pmatrix} 10 \\\\ 9 \\end{pmatrix} - \\begin{pmatrix} 8 \\\\ 7 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$$\n\n进程 $P_1$ 将其对 $R_1$ 的最大需求增加一个整数值 $x$。新的最大需求矩阵 $M'$ 变为：\n$$M' = \\begin{pmatrix} 4+x  3 \\\\ 5  4 \\\\ 3  5 \\\\ 3  2 \\end{pmatrix}$$\n\n需求矩阵 $N$ 表示每个进程为完成其任务可能仍需请求的剩余资源。它被定义为 $N = M - A$。更新后，新的需求矩阵 $N'$ 为：\n$$N' = M' - A = \\begin{pmatrix} 4+x  3 \\\\ 5  4 \\\\ 3  5 \\\\ 3  2 \\end{pmatrix} - \\begin{pmatrix} 2  1 \\\\ 3  2 \\\\ 2  3 \\\\ 1  1 \\end{pmatrix} = \\begin{pmatrix} 2+x  2 \\\\ 2  2 \\\\ 1  2 \\\\ 2  1 \\end{pmatrix}$$\n\n为使此更新有效，必须满足两个条件：\n1. 任何进程的新最大需求都不能超过系统中的总资源。对于 $P_1$，这意味着其在 $M'$ 中的行向量必须按分量小于或等于 $T$。\n$$ \\begin{pmatrix} 4+x  3 \\end{pmatrix} \\le \\begin{pmatrix} 10  9 \\end{pmatrix} $$\n这给出了两个不等式：$4+x \\le 10$ 和 $3 \\le 9$。第二个不等式成立。第一个不等式意味着 $x \\le 6$。由于 $x$ 必须是整数，其最大可能值为 $6$。\n\n2. 由矩阵 $A$、$M'$ 以及派生的向量 $V$ 和 $N'$ 所定义的结果状态必须是一个安全状态。\n\n为了找到最大的整数 $x$，我们从测试其最大可能值 $x=6$ 开始，并使用银行家安全算法来检查所得到的状态是否安全。\n\n我们来测试 $x=6$ 时的状态。\n当 $x=6$ 时，需求矩阵 $N'$ 为：\n$$N' = \\begin{pmatrix} 2+6  2 \\\\ 2  2 \\\\ 1  2 \\\\ 2  1 \\end{pmatrix} = \\begin{pmatrix} 8  2 \\\\ 2  2 \\\\ 1  2 \\\\ 2  1 \\end{pmatrix}$$\n\n安全算法按以下步骤进行：\n- 我们从可用资源向量 `Work` $= V = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$ 开始。\n- 我们还维护一个布尔向量 `Finish`，对于所有 4 个进程，其初始值均为 false。\n- 我们寻找一个进程 $P_i$，满足 `Finish[i]` 为 false，且其需求向量 $Need_i$ 按分量小于或等于 `Work` 向量。\n\n让我们应用该算法：\n初始状态：`Work` = $\\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$, `Finish` = `[F, F, F, F]`。\n\n步骤 1：找到一个进程 $P_i$，其 $Need_i \\le$ `Work`。\n- $P_1$：$Need_1 = \\begin{pmatrix} 8 \\\\ 2 \\end{pmatrix}$。该向量不满足 $\\le \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$，因为 $8 > 2$。\n- $P_2$：$Need_2 = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$。该向量满足 $\\le \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$。\n- $P_3$：$Need_3 = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$。该向量满足 $\\le \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$。\n- $P_4$：$Need_4 = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$。该向量满足 $\\le \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$。\n\n我们可以在 $P_2$、$P_3$ 和 $P_4$ 中进行选择。只要存在任何一个安全序列就足够了。我们选择 $P_3$。\n\n步骤 2：假设 $P_3$ 运行至完成。它会释放其已分配的资源。\n- 新的 `Work` = `Work` + `Allocation`$_3 = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix} + \\begin{pmatrix} 2 \\\\ 3 \\end{pmatrix} = \\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix}$。\n- `Finish` = `[F, F, T, F]`。\n\n步骤 3：寻找下一个进程。当前 `Work` = $\\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix}$。\n- $P_1$：$Need_1 = \\begin{pmatrix} 8 \\\\ 2 \\end{pmatrix}$。不满足 $\\le \\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix}$（因为 $8 > 4$）。\n- $P_2$：$Need_2 = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$。是，满足 $\\le \\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix}$。\n- $P_4$：$Need_4 = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$。是，满足 $\\le \\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix}$。\n\n我们选择 $P_2$。\n\n步骤 4：假设 $P_2$ 运行至完成。\n- 新的 `Work` = `Work` + `Allocation`$_2 = \\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix} + \\begin{pmatrix} 3 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 7 \\\\ 7 \\end{pmatrix}$。\n- `Finish` = `[F, T, T, F]`。\n\n步骤 5：寻找下一个进程。当前 `Work` = $\\begin{pmatrix} 7 \\\\ 7 \\end{pmatrix}$。\n- $P_1$：$Need_1 = \\begin{pmatrix} 8 \\\\ 2 \\end{pmatrix}$。不满足 $\\le \\begin{pmatrix} 7 \\\\ 7 \\end{pmatrix}$（因为 $8 > 7$）。\n- $P_4$：$Need_4 = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$。是，满足 $\\le \\begin{pmatrix} 7 \\\\ 7 \\end{pmatrix}$。\n\n我们必须选择 $P_4$。\n\n步骤 6：假设 $P_4$ 运行至完成。\n- 新的 `Work` = `Work` + `Allocation`$_4 = \\begin{pmatrix} 7 \\\\ 7 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 8 \\\\ 8 \\end{pmatrix}$。\n- `Finish` = `[F, T, T, T]`。\n\n步骤 7：寻找最后一个进程。只剩下 $P_1$。当前 `Work` = $\\begin{pmatrix} 8 \\\\ 8 \\end{pmatrix}$。\n- $P_1$：$Need_1 = \\begin{pmatrix} 8 \\\\ 2 \\end{pmatrix}$。是，满足 $\\le \\begin{pmatrix} 8 \\\\ 8 \\end{pmatrix}$。\n\n步骤 8：$P_1$ 运行至完成。\n- 新的 `Work` = `Work` + `Allocation`$_1 = \\begin{pmatrix} 8 \\\\ 8 \\end{pmatrix} + \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 10 \\\\ 9 \\end{pmatrix}$。\n- 这个最终的 `Work` 向量等于总资源向量 $T$，符合预期。\n- `Finish` = `[T, T, T, T]`。\n\n由于所有进程都能完成，我们找到了一个安全序列，例如 $\\langle P_3, P_2, P_4, P_1 \\rangle$。这意味着对于 $x=6$，系统状态是安全的。\n\n由于我们从根据资源总量约束推导出的 $x$ 的最大可能值开始测试，并且该值被证明是安全的，因此，最大的整数 $x$ 就是 $6$。", "answer": "$$\\boxed{6}$$", "id": "3631866"}]}