{"hands_on_practices": [{"introduction": "稳定序紧缩虽然实现简单，但可能不是成本最低的方案。本练习将引导你对比“稳定”与“非稳定”紧缩策略的成本差异。通过允许重新排列内存段的顺序，你将探索如何通过优化布局来最小化数据迁移量，从而揭示算法设计中简单性与效率之间的权衡 [@problem_id:3626069]。", "problem": "一个单道程序的段式内存系统会产生外部碎片：已分配的段之间存在空闲间隙。紧凑技术旨在通过重新定位段，将空闲内存合并成一个单一的连续空闲区域。考虑一个从地址 $0$ 到地址 $180$ 字节的内存区域，其当前布局如下（地址从左到右递增）：\n\n大小为 $30$ 字节的段 $S_1$ 起始基地址为 $0$，其后是一个大小为 $10$ 字节的空闲间隙；大小为 $20$ 字节的段 $S_2$ 起始基地址为 $40$，其后是一个大小为 $20$ 字节的空闲间隙；大小为 $40$ 字节的段 $S_3$ 起始基地址为 $80$，其后是一个大小为 $10$ 字节的空闲间隙；以及大小为 $50$ 字节的段 $S_4$ 起始基地址为 $130$。\n\n假设操作系统执行紧凑操作以消除所有间隙，在内存起始处生成一个包含所有段的连续块，其后是内存末尾的一个单一连续空闲区域。定义重定位成本 $R$ 为紧凑期间复制的总字节数，等于所有被重定位到不同基地址的段的大小（以字节为单位）之和。\n\n考虑两种紧凑策略：\n1. 稳定紧凑：最终布局保留段的当前相对顺序（$S_1$，然后是 $S_2$，然后是 $S_3$，然后是 $S_4$）。\n2. 非稳定紧凑：最终布局可以任意重排段以最小化 $R$。\n\n计算稳定紧凑相对于最优选择的非稳定紧凑所产生的重定位成本增加量 $\\Delta R = R_{\\text{stable}} - R_{\\text{unstable}}$。最终答案以字节为单位表示。无需四舍五入。", "solution": "### 解答\n\n设 $s_i$ 为段 $S_i$ 的大小，$b_i$ 为其初始基地址。给定值为：\n- $S_1$：$s_1 = 30$，$b_1 = 0$。\n- $S_2$：$s_2 = 20$，$b_2 = 40$。\n- $S_3$：$s_3 = 40$，$b_3 = 80$。\n- $S_4$：$s_4 = 50$，$b_4 = 130$。\n\n已分配内存的总大小为 $\\sum_{i=1}^{4} s_i = 30 + 20 + 40 + 50 = 140$ 字节。紧凑后，这些段将占用从地址 $0$ 到 $140$ 的内存区域。如果一个段 $S_i$ 的最终基地址 $b'_i$ 不等于其初始基地址 $b_i$，则该段被重定位。重定位成本 $R$ 是所有被重定位段的大小之和。\n\n**1. 计算稳定紧凑成本 ($R_{\\text{stable}}$)**\n\n在稳定紧凑中，段的相对顺序被保留。最终布局将是 $S_1, S_2, S_3, S_4$，从地址 $0$ 开始。我们计算新的基地址 ($b'_i$)：\n- $S_1$ 在起始位置：$b'_1 = 0$。\n- $S_2$ 跟随 $S_1$：$b'_2 = b'_1 + s_1 = 0 + 30 = 30$。\n- $S_3$ 跟随 $S_2$：$b'_3 = b'_2 + s_2 = 30 + 20 = 50$。\n- $S_4$ 跟随 $S_3$：$b'_4 = b'_3 + s_3 = 50 + 40 = 90$。\n\n现在，我们通过比较初始和最终基地址来确定哪些段被重定位：\n- $S_1$：$b_1 = 0$，$b'_1 = 0$。由于 $b_1 = b'_1$，$S_1$ 未被重定位。\n- $S_2$：$b_2 = 40$，$b'_2 = 30$。由于 $b_2 \\neq b'_2$，$S_2$ 被重定位。\n- $S_3$：$b_3 = 80$，$b'_3 = 50$。由于 $b_3 \\neq b'_3$，$S_3$ 被重定位。\n- $S_4$：$b_4 = 130$，$b'_4 = 90$。由于 $b_4 \\neq b'_4$，$S_4$ 被重定位。\n\n稳定重定位成本是被重定位段的大小之和：\n$$R_{\\text{stable}} = s_2 + s_3 + s_4 = 20 + 40 + 50 = 110$$\n\n**2. 计算最优非稳定紧凑成本 ($R_{\\text{unstable}}$)**\n\n在非稳定紧凑中，我们可以重排段以最小化重定位成本 $R$。最小化 $R$ 等同于最大化*未*被重定位的段的总大小。如果一个段 $S_i$ 的最终位置的基地址与其初始位置的基地址相同，即 $b'_i = b_i$，则该段未被重定位。\n\n设未重定位段的集合为 $K$。要使 $K$ 非空，必须至少存在一个段 $S_k \\in K$，其最终基地址 $b'_k$ 等于其初始基地址 $b_k$。在最终的紧凑布局中，段从地址 $0$ 开始形成一个连续块。假设未重定位的段按其基地址排序为 $S_{k_1}, S_{k_2}, \\ldots, S_{k_m}$，且 $b_{k_1}  b_{k_2}  \\ldots  b_{k_m}$。\n最终序列中的第一个段的基地址必须为 $0$。如果这个段（比如 $S_i$）要保持不重定位，其初始基地址必须为 $0$。只有 $S_1$ 的初始基地址为 $0$。因此，如果有任何段要保持固定，$S_1$ 必须是最终布局中的第一个段，因此它不被重定位。\n\n所以，任何未重定位段的集合都必须包含 $S_1$。让我们测试一下除了 $S_1$ 之外，还有哪些段可以保持在原位。\n我们假设 $S_1$ 和 $S_j$（其中 $b_j > b_1$）都未被重定位。在最终布局中，从 $S_1$ 的末尾（地址 $b_1+s_1$）到 $S_j$ 的起始处（地址 $b_j$）的内存块必须由剩余（被重定位）段的一个子集精确填充。填充此间隙所需的空间大小为 $b_j - (b_1 + s_1)$。\n\n- **测试 $\\{S_1, S_2\\}$ 为不重定位：**\n  - $b_1=0$，$s_1=30$。$b_2=40$。\n  - 需要填充的间隙大小：$b_2 - (b_1 + s_1) = 40 - (0 + 30) = 10$。\n  - 其他段是 $S_3$（大小 $40$）和 $S_4$（大小 $50$）。$\\{S_3, S_4\\}$ 的任何子集的总大小都不为 $10$。因此，不可能同时保持 $S_1$ 和 $S_2$ 固定。\n\n- **测试 $\\{S_1, S_3\\}$ 为不重定位：**\n  - $b_1=0$，$s_1=30$。$b_3=80$。\n  - 需要填充的间隙大小：$b_3 - (b_1 + s_1) = 80 - (0 + 30) = 50$。\n  - 其他段是 $S_2$（大小 $20$）和 $S_4$（大小 $50$）。段 $S_4$ 的大小为 $50$。我们可以将 $S_4$ 放入该间隙。\n  - 这导致了一个有效的布局：最终顺序是 $(S_1, S_4, S_3, S_2)$。\n    - $S_1$ 从 $0$ 开始（未重定位）。\n    - $S_4$ 从 $0+s_1=30$ 开始（从 $130$ 重定位而来）。\n    - $S_3$ 从 $30+s_4=30+50=80$ 开始（未重定位）。\n    - $S_2$ 从 $80+s_3=80+40=120$ 开始（从 $40$ 重定位而来）。\n  - 未重定位段的总大小为 $s_1 + s_3 = 30 + 40 = 70$。\n\n- **测试 $\\{S_1, S_4\\}$ 为不重定位：**\n  - $b_1=0$，$s_1=30$。$b_4=130$。\n  - 需要填充的间隙大小：$b_4 - (b_1 + s_1) = 130 - (0 + 30) = 100$。\n  - 其他段是 $S_2$（大小 $20$）和 $S_3$（大小 $40$）。它们的总大小为 $20+40=60$，不等于 $100$。因此，不可能同时保持 $S_1$ 和 $S_4$ 固定。\n\n根据分析，可以保持在原位置的段的最大总大小是 $70$ 字节（通过保持 $S_1$ 和 $S_3$ 固定）。\n最小重定位成本是所有段的总大小减去这个最大的未重定位大小。\n$$R_{\\text{unstable}} = \\left(\\sum_{i=1}^{4} s_i\\right) - (s_1 + s_3) = 140 - (30 + 40) = 140 - 70 = 70$$\n\n**3. 计算重定位成本的增加量 ($\\Delta R$)**\n\n重定位成本的增加量是稳定成本和最优非稳定成本之间的差值。\n$$\\Delta R = R_{\\text{stable}} - R_{\\text{unstable}} = 110 - 70 = 40$$\n\n成本增加量为 $40$ 字节。", "answer": "$$\n\\boxed{40}\n$$", "id": "3626069"}, {"introduction": "完全紧缩可能是一项开销巨大的操作，而有时我们仅需创建一个足够大的连续空闲块。本练习引入了“部分紧缩”这一实用概念，其目标是执行最少的数据迁移来满足特定的内存分配需求。这要求你从全局最优的角度思考，如何在满足任务要求的同时，最大限度地降低紧缩对系统性能的即时影响 [@problem_id:3626125]。", "problem": "一个操作系统在随机存取存储器 (RAM) 中对进程使用连续分配。外部碎片表现为多个与已分配段（进程）交错分布的不连续空闲区域（空洞）。紧凑技术通过重定位已分配段来合并空洞，从而增加可分配的最大连续块。假设以下模型和约束适用：\n\n- 内存是一个从低地址到高地址的线性地址空间。\n- 从低地址到高地址的当前布局是：一个大小为 $60\\,\\text{KiB}$ 的空洞，然后是一个大小为 $80\\,\\text{KiB}$ 的已分配段 $P_1$，然后是一个大小为 $50\\,\\text{KiB}$ 的空洞，然后是一个大小为 $100\\,\\text{KiB}$ 的已分配段 $P_2$，然后是一个大小为 $120\\,\\text{KiB}$ 的空洞，然后是一个大小为 $90\\,\\text{KiB}$ 的已分配段 $P_3$，然后是一个大小为 $40\\,\\text{KiB}$ 的空洞，然后是一个大小为 $60\\,\\text{KiB}$ 的已分配段 $P_4$，最后是一个大小为 $50\\,\\text{KiB}$ 的空洞。\n- 重定位一个段的成本等于其大小（重定位的字节数）。段必须作为一个完整的、连续的单元被重定位到一个大小至少等于该段大小的单一现有空洞中；禁止将一个段分割到多个空洞中。重定位的段不得与任何其他段重叠，且总空闲空间保持不变。\n- 在完全紧凑下，操作系统执行稳定的向左打包：所有已分配段都向最低地址移动，同时保持它们的相对顺序，以消除所有内部空洞，最终在最高地址处留下一个单一的大空洞。\n\n从上述布局开始，执行一次部分紧凑，以实现目标最大空洞大小 $h_{\\max} = 160\\,\\text{KiB}$，策略为“仅为达到目标而紧凑”：重定位所需的最少数据总量 $R$ (以 $\\text{KiB}$ 为单位)，以确保存在至少一个大小不小于 $h_{\\max}$ 的连续空闲区域，此过程受上述重定位约束的限制。设 $R_{\\text{full}}$ 为在所述的稳定向左打包策略下，完全紧凑所重定位的数据总量。\n\n计算比率 $R/R_{\\text{full}}$，并将您的最终答案表示为一个无量纲小数，四舍五入到四位有效数字。", "solution": "### 解答\n\n**1. 分析初始内存布局**\n\n我们首先列出内存中进程和空洞的大小和顺序（所有单位均为 KiB）：\n- 空洞：`H1(60)`, `H2(50)`, `H3(120)`, `H4(40)`, `H5(50)`\n- 进程：`P1(80)`, `P2(100)`, `P3(90)`, `P4(60)`\n- 布局：`H1(60) | P1(80) | H2(50) | P2(100) | H3(120) | P3(90) | H4(40) | P4(60) | H5(50)`\n\n**2. 计算完全紧缩成本 ($R_{\\text{full}}$)**\n\n完全紧缩（稳定的向左打包）的目标是将所有进程 `P1, P2, P3, P4` 移动到内存的最低地址处，形成一个连续的已分配块。由于初始内存布局以一个空洞 `H1` 开始，所有进程都必须被重定位才能实现此目标。\n重定位成本是所有被移动进程的大小之和。\n$$R_{\\text{full}} = \\text{size}(P_1) + \\text{size}(P_2) + \\text{size}(P_3) + \\text{size}(P_4)$$\n$$R_{\\text{full}} = 80 + 100 + 90 + 60 = 330\\,\\text{KiB}$$\n\n**3. 计算部分紧缩的最小成本 ($R$)**\n\n部分紧缩的目标是创建一个大小至少为 $h_{\\max} = 160\\,\\text{KiB}$ 的空洞，同时最小化重定位成本 $R$。\n我们可以通过移动位于两个或多个空洞之间的进程来合并这些空洞。\n- **分析单进程移动：**\n  - **移动 P1 (80 KiB) 以合并 H1 和 H2：**\n    - 移动 `P1` 会将其占用的空间（80 KiB）转变成一个空洞，该空洞与相邻的 `H1(60)` 和 `H2(50)` 合并，形成一个大小为 $60 + 80 + 50 = 190\\,\\text{KiB}$ 的新空洞。\n    - $190\\,\\text{KiB} \\ge 160\\,\\text{KiB}$，满足目标。\n    - 此移动是否可行？`P1` (大小 80 KiB) 必须被移动到一个大小至少为 80 KiB 的**现有**空洞中。空洞 `H3` (120 KiB) 满足此条件。\n    - 因此，这是一个有效的单步解决方案。成本 $R = \\text{size}(P_1) = 80\\,\\text{KiB}$。\n  - **移动 P2 (100 KiB) 以合并 H2 和 H3：**\n    - 这将创建一个大小为 $50 + 100 + 120 = 270\\,\\text{KiB}$ 的空洞。\n    - 然而，要移动 `P2`，需要一个大小至少为 100 KiB 的现有空洞。除了 `H3`（我们正试图合并的空洞之一）之外，可用的空洞是 `H1(60)`、`H4(40)` 和 `H5(50)`。没有一个足够大。因此，此移动在单步中不可行。\n  - **移动 P3 (90 KiB) 以合并 H3 和 H4：**\n    - 这将创建一个大小为 $120 + 90 + 40 = 250\\,\\text{KiB}$ 的空洞。\n    - 同样，没有足够大的现有外部空洞来容纳 `P3`。此移动在单步中不可行。\n  - **移动 P4 (60 KiB) 以合并 H4 和 H5：**\n    - 这将创建一个大小为 $40 + 60 + 50 = 150\\,\\text{KiB}$ 的空洞。这小于目标 $160\\,\\text{KiB}$，因此不足以实现目标。\n\n- **分析多进程移动：**\n  - 我们的单步解决方案成本为 80 KiB。任何更优的解决方案的总成本必须小于 80 KiB。\n  - 多步移动的总成本是所有被移动进程的大小之和。\n  - 唯一大小小于 80 KiB 的进程是 `P4` (60 KiB)。因此，任何可能更便宜的解决方案都必须以移动 `P4` 开始。\n  - 如果我们移动 `P4` (成本 60 KiB)，我们已经证明这本身并不能创建足够大的空洞。我们必须再移动至少一个进程。\n  - 第二个移动的进程 `P_x` 的大小将增加到总成本中。最小的进程大小是 60 KiB。\n  - 因此，任何两步移动的成本至少是 $60 + 60 = 120\\,\\text{KiB}$（如果我们能以某种方式移动 P4 两次，这不合逻辑）或更现实地是 $60 + \\text{size}(\\text{next smallest}) = 60 + 80 = 140\\,\\text{KiB}$。\n  - 所有多步解决方案的成本都将大于 80 KiB。\n\n因此，最小的重定位成本 $R$ 是通过移动 `P1` 实现的。\n$$R = 80\\,\\text{KiB}$$\n\n**4. 计算比率**\n现在我们计算比率 $R/R_{\\text{full}}$。\n$$\\frac{R}{R_{\\text{full}}} = \\frac{80\\,\\text{KiB}}{330\\,\\text{KiB}} = \\frac{8}{33} \\approx 0.242424...$$\n四舍五入到四位有效数字，结果为 $0.2424$。", "answer": "$$\n\\boxed{0.2424}\n$$", "id": "3626125"}]}