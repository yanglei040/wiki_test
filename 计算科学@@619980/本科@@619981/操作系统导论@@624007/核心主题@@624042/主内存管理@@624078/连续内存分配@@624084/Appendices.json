{"hands_on_practices": [{"introduction": "在连续内存分配中，碎片是核心挑战，它分为内部碎片和外部碎片。本练习将通过一个具体的工作负载，帮助你亲手计算这两种碎片的量，从而直观理解分配器策略（如内存对齐）如何影响内存利用率。通过这个实践，你将学会量化和区分不同类型的内存浪费[@problem_id:3628308]。", "problem": "考虑一个单道程序系统，该系统在一个大小为 $M$ 字节的单一区域上使用连续内存分配器。该分配器强制实施 $a$ 字节的对齐约束，并将每个请求的大小向上取整到不小于所请求大小的 $a$ 的最小倍数。分配器采用首次适应策略，在分配时分割空闲块，在释放时仅合并相邻的空闲块。假设所有簿记元数据的开销可以忽略不计。\n\n从一个基地址为 $0$、大小为 $M = 4096$ 字节的初始空内存区域开始，执行以下工作负载：\n- 执行 $n = 45$ 次分配请求，每次请求大小为 $s = 33$ 字节。\n- 然后释放已分配块序列中非两端的一个块（具体来说，释放第 $23$ 个分配的块）。\n\n定义内部碎片为所有当前已分配块的分配器向上取整后的大小与请求大小之差的总和。定义工作负载结束时的外部碎片为总空闲内存减去最大单个空闲块的大小。\n\n令 $\\rho$ 为工作负载结束时总碎片中由内部碎片所占的比例，即 $\\rho$ 等于内部碎片除以内部碎片与外部碎片之和。\n\n仅使用基本定义和指定的分配器行为，计算当 $a = 64$，$M = 4096$，$n = 45$，$s = 33$ 时的 $\\rho$。请以无单位的精确简化分数形式提供最终答案。", "solution": "题目陈述经验证是自洽、一致且科学地基于操作系统内存管理原理的。所有参数、定义和分配器行为都已明确指定，从而可以得出一个确定且唯一的解。\n\n该问题可以通过模拟内存分配和释放过程，计算由此产生的内部和外部碎片，然后计算它们的比率来解决。\n\n首先，我们确定每个分配块的实际大小。请求大小为 $s = 33$ 字节，对齐要求为 $a = 64$ 字节。分配器将每个请求的大小向上取整到不小于所请求大小的 $a$ 的最小倍数。设这个分配的大小为 $S_{alloc}$。\n$$S_{alloc} = \\left\\lceil \\frac{s}{a} \\right\\rceil \\times a = \\left\\lceil \\frac{33}{64} \\right\\rceil \\times 64 = 1 \\times 64 = 64 \\text{ 字节}$$\n因此，每次分配都将保留一个 $64$ 字节的块。\n\n系统始于一个大小为 $M = 4096$ 字节的空内存区域，它是一个从地址 $0$ 到 $4095$ 的单一空闲块。\n工作负载包含 $n = 45$ 次分配请求。由于分配器采用首次适应策略，且内存最初是一个单一的连续空闲块，因此这 $45$ 次分配将从地址 $0$ 开始一个接一个地放置。\n这 $45$ 个块占用的总内存为：\n$$n \\times S_{alloc} = 45 \\times 64 = 2880 \\text{ 字节}$$\n在此分配阶段之后，内存映射包括：\n1.  一个大小为 $2880$ 字节的已分配区域，从地址 $0$ 到 $2879$。\n2.  一个大小为 $M - 2880 = 4096 - 2880 = 1216$ 字节的剩余单一空闲块，从地址 $2880$ 到 $4095$。\n\n接下来，释放第 $23$ 个已分配的块。第 $k$ 个分配的块占据内存地址范围 $[(k-1)S_{alloc}, k \\cdot S_{alloc} - 1]$。对于第 $23$ 个块 ($k=23$)：\n-   起始地址：$(23-1) \\times 64 = 22 \\times 64 = 1408$。\n-   结束地址：$23 \\times 64 - 1 = 1472 - 1 = 1471$。\n分配器的策略是在释放时仅与相邻的空闲块合并。被释放块紧邻的前一个块（第 $22$ 个块）仍处于分配状态。紧邻的后一个块（第 $24$ 个块）也仍处于分配状态。因此，不会发生合并。这次释放操作在地址 $1408$ 处创建了一个新的、孤立的、大小为 $64$ 字节的空闲块。\n\n内存的最终状态如下：\n-   已分配块 $1$ 到 $22$：占据地址 $0$ 到 $1407$。总数：$22$。\n-   一个大小为 $64$ 字节的空闲块：占据地址 $1408$ 到 $1471$。\n-   已分配块 $24$ 到 $45$：占据地址 $1472$ 到 $2879$。总数：$45 - 24 + 1 = 22$。\n-   一个大小为 $1216$ 字节的空闲块：占据地址 $2880$ 到 $4095$。\n\n当前已分配块的总数为 $45 - 1 = 44$。\n\n现在，我们根据这个最终的内存状态计算内部和外部碎片。\n\n内部碎片 ($I$) 是所有已分配块内部浪费空间的总和。对于 $44$ 个已分配块中的每一个，请求的大小是 $s=33$ 字节，但分配的大小是 $S_{alloc}=64$ 字节。\n$$I = (\\text{已分配块数量}) \\times (S_{alloc} - s)$$\n$$I = 44 \\times (64 - 33) = 44 \\times 31 = 1364 \\text{ 字节}$$\n\n外部碎片 ($E$) 定义为总空闲内存减去最大单个空闲块的大小。\n-   空闲块的大小分别为 $64$ 字节和 $1216$ 字节。\n-   总空闲内存，$F_{total} = 64 + 1216 = 1280$ 字节。\n-   最大单个空闲块的大小是 $F_{max} = \\max(64, 1216) = 1216$ 字节。\n$$E = F_{total} - F_{max} = 1280 - 1216 = 64 \\text{ 字节}$$\n\n最后，我们计算比率 $\\rho$，即总碎片中由内部碎片所占的比例。\n$$\\rho = \\frac{I}{I + E}$$\n$$\\rho = \\frac{1364}{1364 + 64} = \\frac{1364}{1428}$$\n为了简化这个分数，我们可以用分子和分母的最大公约数来除。两者都可以被 $4$ 整除。\n$$\\rho = \\frac{1364 \\div 4}{1428 \\div 4} = \\frac{341}{357}$$\n我们通过质因数分解来检查是否存在其他公因数：\n-   分子：$341 = 11 \\times 31$。\n-   分母：$357 = 3 \\times 119 = 3 \\times 7 \\times 17$。\n没有共同的质因数，所以这个分数已经是最简形式。", "answer": "$$\\boxed{\\frac{341}{357}}$$", "id": "3628308"}, {"introduction": "伙伴系统是一种经典的动态内存分配算法，它通过将内存划分为$2$的幂次大小的块来简化管理。本练习将揭示该算法的核心权衡：为了管理上的便利，请求的内存大小会被向上取整到最近的$2$的幂，这可能导致显著的内部碎片。你将通过计算这种策略产生的“浪费分数”，来量化这种空间换时间的代价[@problem_id:3628282]。", "problem": "一个计算机系统在随机存取存储器（RAM）的单个区域内使用连续内存分配。其分配器是一个伙伴系统，该系统强制使用2的幂次方的块大小，并将一个较大的连续区域分割成较小的2的幂次方的块。可分配的最小块为一KiB（kibibyte）。在伙伴系统下，对于一个大小为 $s$ 的块请求，会通过将 $s$ 向上取整到不小于 $s$ 的最小2的幂次方来满足，然后连续地分配一个这样大小的块。\n\n考虑一个初始大小为 $512$ KiB（kibibytes）的空闲连续区域。一个进程按顺序发出四个分配请求，每个请求都需要一个连续的块：$62$ KiB, $90$ KiB, $35$ KiB 和 $10$ KiB。在理想的可变大小分割的连续内存分配下，每个请求都会通过精确划分出所请求的大小来满足，从而产生零内部碎片。在伙伴系统下，每个请求在分配前都会被向上取整到最小的2的幂次方的块大小。\n\n仅使用连续内存分配、内部碎片和伙伴系统的2的幂次方取整规则的核心定义，确定由伙伴分配器相对于理想连续分割基准所引起的内部碎片浪费。将浪费分数定义为额外分配的字节数除以请求的字节数，并计算此分配模式下的精确值。以无单位的分数形式表示您的最终答案。", "solution": "该问题要求计算在伙伴系统下，一系列内存分配请求相对于理想分配方案所产生的内部碎片浪费分数。解决方案需要分步分析伙伴系统如何处理每个请求，并计算由此产生的碎片。\n\n首先，我们来形式化给定的信息和定义。\n内存请求序列的大小分别为 $s_1 = 62$ KiB, $s_2 = 90$ KiB, $s_3 = 35$ KiB, 和 $s_4 = 10$ KiB。\n总请求大小，记为 $S_{req}$，是各个请求大小的总和：\n$$S_{req} = s_1 + s_2 + s_3 + s_4$$\n\n在伙伴系统下，一个大小为 $s$ 的请求由一个大小为 $a$ 的块来满足，其中 $a$ 是满足 $a \\ge s$ 的最小2的幂次方。在数学上，这可以表示为 $a = 2^{\\lceil \\log_2(s) \\rceil}$。最小可分配块大小为 $1$ KiB，即 $2^0$ KiB，这与2的幂次方规则一致。\n\n问题定义了“理想的可变大小分割”基准，其中分配的大小恰好等于请求的大小。对于这个基准，总分配内存将等于 $S_{req}$，因此内部碎片为零。\n\n单次分配的内部碎片是分配大小与请求大小之差，即 $a - s$。总内部碎片，或总“额外分配字节数” ($I$)，是每个请求的碎片之和。\n$$I = \\sum_{i=1}^{4} (a_i - s_i) = \\left(\\sum_{i=1}^{4} a_i\\right) - \\left(\\sum_{i=1}^{4} s_i\\right) = S_{alloc} - S_{req}$$\n其中 $S_{alloc}$ 是伙伴系统分配的总大小。\n\n“浪费分数” $F_w$ 定义为额外分配的字节数除以请求的字节数：\n$$F_w = \\frac{I}{S_{req}} = \\frac{S_{alloc} - S_{req}}{S_{req}}$$\n\n现在，我们进行计算。\n\n第1步：计算总请求内存大小 $S_{req}$。\n$$S_{req} = 62 + 90 + 35 + 10 = 197 \\text{ KiB}$$\n\n第2步：根据伙伴系统的2的幂次方取整规则，计算每个请求 $s_i$ 的分配大小 $a_i$。\n- 对于第一个请求 $s_1 = 62$ KiB：\n2的幂次方有 $..., 32, 64, 128, ...$。不小于 $62$ 的最小2的幂次方是 $64$。因此，$a_1 = 64$ KiB。这对应于 $2^6$。\n\n- 对于第二个请求 $s_2 = 90$ KiB：\n不小于 $90$ 的最小2的幂次方是 $128$。因此，$a_2 = 128$ KiB。这对应于 $2^7$。\n\n- 对于第三个请求 $s_3 = 35$ KiB：\n不小于 $35$ 的最小2的幂次方是 $64$。因此，$a_3 = 64$ KiB。这对应于 $2^6$。\n\n- 对于第四个请求 $s_4 = 10$ KiB：\n不小于 $10$ 的最小2的幂次方是 $16$。因此，$a_4 = 16$ KiB。这对应于 $2^4$。\n\n第3步：计算总分配内存大小 $S_{alloc}$。\n$$S_{alloc} = a_1 + a_2 + a_3 + a_4 = 64 + 128 + 64 + 16 = 272 \\text{ KiB}$$\n请注意，总分配大小（$272$ KiB）小于初始空闲区域（$512$ KiB），因此所有分配都成功。\n\n第4步：计算总额外分配字节数（内部碎片）$I$。\n$$I = S_{alloc} - S_{req} = 272 - 197 = 75 \\text{ KiB}$$\n\n第5步：计算浪费分数 $F_w$。\n$$F_w = \\frac{I}{S_{req}} = \\frac{75}{197}$$\n\n为确保分数是最简形式，我们求出分子和分母的质因数。\n分子是 $75 = 3 \\times 25 = 3 \\times 5^2$。\n对于分母 $197$，我们检查它是否能被小的质数整除。\n- $197$ 不能被 $2$ 整除（它是奇数）。\n- 各位数字之和为 $1+9+7 = 17$，不能被 $3$ 整除。\n- 它不以 $0$ 或 $5$ 结尾，所以不能被 $5$ 整除。\n- 我们继续检查直到 $\\sqrt{197} \\approx 14$ 的质数：$7, 11, 13$。\n  - $197 \\div 7 = 28$ 余 $1$。\n  - $197 \\div 11 = 17$ 余 $10$。\n  - $197 \\div 13 = 15$ 余 $2$。\n由于 $197$ 不能被任何小于或等于其平方根的质数整除，所以 $197$ 是一个质数。\n因此，分数 $\\frac{75}{197}$ 是最简分数。", "answer": "$$\\boxed{\\frac{75}{197}}$$", "id": "3628282"}, {"introduction": "当外部碎片变得严重，以至于无法满足新的内存请求时，内存紧缩（compaction）就成了一种必要的整理手段。本练习模拟了一个内存高度碎片化的“瑞士奶酪”场景，要求你规划并执行紧缩操作。通过追踪块的移动并计算所需步骤，你将深入理解紧缩过程的机制及其操作成本[@problem_id:3628275]。", "problem": "一个操作系统 (OS) 管理随机存取存储器 (RAM) 中的一个单一连续主内存区域。在连续内存分配中，每个进程驻留在一个连续的物理地址段中。当进程终止时，它们的段被释放，从而在仍在分配的段之间产生空闲内存的空洞。随着时间的推移，随机的释放会产生高度碎片化或“瑞士奶酪”般的布局。操作系统可以执行紧凑，这是一种在内存中移动已分配的段以消除空洞并将空闲空间合并成一个更大的连续块的行为，同时保持每个段的完整性。\n\n考虑以下沿物理地址递增方向（从低到高）的当前内存布局。内存由空闲空洞和已分配段交替组成。设空闲空洞的大小用 $h_i$ 表示，单位为千字节 (kB)，已分配段的大小用 $a_i$ 表示，单位为千字节 (kB)。从最低地址到最高地址的布局是：\n$h_{0} = 12$, $a_{1} = 180$, $h_{1} = 36$, $a_{2} = 72$, $h_{2} = 20$, $a_{3} = 150$, $h_{3} = 55$, $a_{4} = 90$, $h_{4} = 40$, $a_{5} = 60$, $h_{5} = 30$, $a_{6} = 200$, $h_{6} = 17$, $a_{7} = 85$, $h_{7} = 28$。\n\n假设操作系统根据以下策略执行紧凑：\n- 已分配段的相对顺序保持不变。\n- 只允许向左移动，每次移动包括将单个已分配段向左滑动，以完全消除其紧邻的前一个空洞。\n- 每次移动后，总的空闲内存保持不变，但被消除的空洞的容量被有效地合并到高地址端的连续空闲空间中。\n\n请您提出一个遵循上述策略的具体紧凑路径，然后确定需要多少次移动才能在最高地址处创建一个大小至少为 $R = 150$ kB 的单一连续空闲块。请将所需的最小移动次数作为您的最终答案。无需四舍五入。在最终数值答案中不要包含单位。", "solution": "题目陈述已经过验证，被认为是自洽的、在操作系统原理背景下具有科学依据且定义明确的。所有数据和条件都已提供，足以确定唯一解。\n\n该问题描述了一种连续内存分配方案。内存布局由交替的空闲空洞（大小用 $h_i$ 表示）和已分配段（大小用 $a_i$ 表示）组成，其中 $i \\in \\{0, 1, 2, \\dots\\}$。布局是沿物理地址递增的方向指定的，从最低地址开始：\n$h_{0} = 12$ kB, $a_{1} = 180$ kB, $h_{1} = 36$ kB, $a_{2} = 72$ kB, $h_{2} = 20$ kB, $a_{3} = 150$ kB, $h_{3} = 55$ kB, $a_{4} = 90$ kB, $h_{4} = 40$ kB, $a_{5} = 60$ kB, $h_{5} = 30$ kB, $a_{6} = 200$ kB, $h_{6} = 17$ kB, $a_{7} = 85$ kB, $h_{7} = 28$ kB。\n\n紧凑的目标是移动已分配的段，形成一个单一、大的、连续的已分配内存块，这反过来又将所有空闲空间合并成另一个单一、大的、连续的块。该策略规定，紧凑操作将段向左（朝低地址方向）移动，并保持已分配段的相对顺序。这意味着最终的配置将把所有已分配的段放在内存区域的起始位置，后面跟着一个大的空闲块。最终布局将是：\n$[a_1][a_2][a_3][a_4][a_5][a_6][a_7][\\text{空闲空间}]$\n\n为了在保持段的相对顺序的同时达到这种最终状态，紧凑过程必须顺序进行。首先，必须移动段 $a_1$ 到内存的起始位置，消除空洞 $h_0$。然后，必须移动段 $a_2$ 使其与 $a_1$ 相邻，消除空洞 $h_1$。这个过程顺序继续。一次“移动”被定义为将单个段 $a_i$ 向左滑动，以消除其紧邻的前一个空洞 $h_{i-1}$。因此，紧凑路径是固定的：\n1. 移动 $a_1$ 以消除 $h_0$。\n2. 移动 $a_2$ 以消除 $h_1$。\n3. 移动 $a_3$ 以消除 $h_2$。\n以此类推。\n\n问题陈述指出，当一个空洞被消除时，其容量被合并到最高地址端的空闲块中。设 $H_{end}$ 为这个连续末端空闲块的大小。最初，这个块就是布局中的最后一个空洞 $h_7$。\n末端空闲块的初始大小：$H_{end}(0) = h_7 = 28$ kB。\n\n我们需要找到所需的最小移动次数 $N$，以使这个末端空闲块的大小至少为 $R = 150$ kB。每次移动对应于按顺序消除一个空洞，从 $h_0$ 开始。经过 $N$ 次移动后，空洞 $h_0, h_1, \\dots, h_{N-1}$ 将被消除，并且它们的大小被加到末端空闲块中。\n\n经过 $N$ 次移动后，末端空闲块的大小 $H_{end}(N)$ 由初始大小加上被消除空洞的大小之和给出：\n$$H_{end}(N) = h_7 + \\sum_{i=0}^{N-1} h_i$$\n\n我们寻求满足 $H_{end}(N) \\ge 150$ 的最小整数 $N$。让我们计算每次移动后末端块的累积大小。\n\n初始状态（$N=0$ 次移动）：\n$H_{end}(0) = 28$ kB。这小于 $150$ kB。\n\n经过 $N=1$ 次移动（消除 $h_0$）：\n空洞 $h_0$ 的大小为 $12$ kB。\n$H_{end}(1) = H_{end}(0) + h_0 = 28 + 12 = 40$ kB。这小于 $150$ kB。\n\n经过 $N=2$ 次移动（消除 $h_0$ 和 $h_1$）：\n空洞 $h_1$ 的大小为 $36$ kB。\n$H_{end}(2) = H_{end}(1) + h_1 = 40 + 36 = 76$ kB。这小于 $150$ kB。\n\n经过 $N=3$ 次移动（消除 $h_0, h_1, h_2$）：\n空洞 $h_2$ 的大小为 $20$ kB。\n$H_{end}(3) = H_{end}(2) + h_2 = 76 + 20 = 96$ kB。这小于 $150$ kB。\n\n经过 $N=4$ 次移动（消除 $h_0, h_1, h_2, h_3$）：\n空洞 $h_3$ 的大小为 $55$ kB。\n$H_{end}(4) = H_{end}(3) + h_3 = 96 + 55 = 151$ kB。\n\n此时，$H_{end}(4) = 151$ kB，大于或等于所需大小 $R = 150$ kB。\n因此，所需的最小移动次数为 $4$。紧凑路径包括移动段 $a_1$ 以消除 $h_0$，然后移动 $a_2$ 以消除 $h_1$，接着移动 $a_3$ 以消除 $h_2$，最后移动 $a_4$ 以消除 $h_3$。", "answer": "$$\\boxed{4}$$", "id": "3628275"}]}