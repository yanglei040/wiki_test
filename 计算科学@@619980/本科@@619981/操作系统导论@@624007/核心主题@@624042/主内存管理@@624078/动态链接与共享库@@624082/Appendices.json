{"hands_on_practices": [{"introduction": "现代操作系统严重依赖共享库以节省内存和磁盘空间。然而，只有当多个进程能真正共享同一份物理内存副本时，这种节省才能实现。本练习将引导你通过一个计算模型，量化位置无关代码（PIC）与非位置无关代码在内存共享方面的差异，从而揭示为何PIC是实现高效动态链接的基石。[@problem_id:3636956]", "problem": "你的任务是，在一个使用分页虚拟内存和写时复制技术的操作系统中，为加载共享库时动态重定位对内存共享的影响进行建模和量化。你将比较一个非位置无关代码 (non-PIC) 共享对象与一个位置无关代码 (PIC) 共享对象。目标是推导并计算在每种模型下，跨多个进程由重定位引起的额外私有内存；解释为何在严格的“写异或执行”策略下，non-PIC 文本重定位可能会失败；以及全局偏移表 (GOT) 和过程链接表 (PLT) 的设计如何将重定位写入操作移出只读的文本段。\n\n基本原理：\n- 大小为 $P$ 字节的虚拟内存页的定义，具有写时复制语义：如果 $k$ 个进程映射了同一个由文件支持的只读页面，它们共享一个物理副本。如果任何一个进程写入该页面，操作系统会为该进程创建一个私有副本。因此，对一个使用写时复制的页面进行写入，会在单个共享副本之外，为写入操作的进程增加 $P$ 字节的私有内存使用量。\n- 运行时链接器通过动态重定位，将解析后的地址写入重定位目标中。\n- 在非位置无关模型中，文本段中的绝对地址需要进行文本重定位；写入文本段会导致每个进程对这些页面进行写时复制，或者在禁止将文本段设为可写的严格“写异或执行”策略下失败。\n- 在位置无关模型中，全局偏移表 (GOT) 保存待解析的地址，过程链接表 (PLT) 通过 GOT 进行间接跳转。重定位写入被重定向到可写的数据页 (GOT) 中，从而保持文本段只读且完全可共享。\n\n数学模型与所需计算：\n- 假设有 $N$ 个进程同时映射同一个共享对象。\n- 假设页面大小为 $P$ 字节。\n- 假设文本段大小为 $T$ 字节。令 non-PIC 文本重定位偏移量的集合为 $\\mathcal{O} = \\{o_1, o_2, \\dots, o_a\\}$，其中每个 $o_i$ 是动态链接器写入的位置，为距离文本段起始位置 $[0, T-1]$ 范围内的字节偏移量。\n- 假设 GOT 总大小为 $G$ 字节，划分为大小为 $E$ 字节的条目。令需要重定位的 GOT 索引集合为 $\\mathcal{I} = \\{i_1, i_2, \\dots, i_b\\}$，其中每个 $i_j$ 是一个整数索引，满足 $0 \\le i_j \\cdot E  G$。这些 GOT 重定位在 non-PIC 和 PIC 模式下都会发生。\n- 定义被重定位弄脏的文本页集合为 $\\mathcal{P}_{\\text{text}} = \\left\\{ \\left\\lfloor \\dfrac{o}{P} \\right\\rfloor \\,\\middle|\\, o \\in \\mathcal{O} \\right\\}$，其基数为 $U_{\\text{text}} = \\left|\\mathcal{P}_{\\text{text}}\\right|$。\n- 定义被重定位弄脏的 GOT 页集合为 $\\mathcal{P}_{\\text{got}} = \\left\\{ \\left\\lfloor \\dfrac{i \\cdot E}{P} \\right\\rfloor \\,\\middle|\\, i \\in \\mathcal{I} \\right\\}$，其基数为 $U_{\\text{got}} = \\left|\\mathcal{P}_{\\text{got}}\\right|$。\n- 仅由重定位引起的额外私有内存使用写时复制语义计算如下：\n  - 对于 non-PIC，文本页和 GOT 页都会被弄脏：\n    $$M_{\\text{nonpic}} = (N - 1) \\cdot (U_{\\text{text}} + U_{\\text{got}}) \\cdot P.$$\n  - 对于 PIC，只有 GOT 页会被弄脏（文本段保持只读且完全共享）：\n    $$M_{\\text{pic}} = (N - 1) \\cdot U_{\\text{got}} \\cdot P.$$\n- 给定一个严格的“写异或执行”策略指示符 $\\sigma \\in \\{0,1\\}$，其中 $\\sigma = 1$ 表示禁止文本重定位。失败指示符为\n  $$F = \\begin{cases}\n  1,  \\text{if } \\sigma = 1 \\text{ and } U_{\\text{text}}  0,\\\\\n  0,  \\text{otherwise.}\n  \\end{cases}$$\n\n你的程序必须为每个测试用例计算四元组\n$$\\left[F,\\; M_{\\text{nonpic}},\\; M_{\\text{pic}},\\; M_{\\text{nonpic}} - M_{\\text{pic}}\\right],$$\n其中所有量都是以字节为单位的整数。差值 $M_{\\text{nonpic}} - M_{\\text{pic}}$ 表示使用位置无关代码所节省的额外私有内存的字节数；在此模型下，它将是非负的。\n\n单位：所有内存大小必须以字节表示。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n测试套件，需在你的程序中实现：\n- 案例 A (一般情况):\n  - $P = 4096$, $N = 10$, $T = 16384$, $G = 4096$, $E = 8$, $\\sigma = 0$,\n  - $\\mathcal{O} = \\{100, 4095, 4096, 8191\\}$,\n  - $\\mathcal{I} = \\{0, 1\\}$.\n- 案例 B (无文本重定位，仅 GOT 重定位，启用严格策略):\n  - $P = 4096$, $N = 5$, $T = 4096$, $G = 4096$, $E = 8$, $\\sigma = 1$,\n  - $\\mathcal{O} = \\emptyset$,\n  - $\\mathcal{I} = \\{0, 400\\}$.\n- 案例 C (所有文本重定位均在单个页面内，重复的偏移量，去重处理的边界条件):\n  - $P = 1024$, $N = 3$, $T = 2048$, $G = 1024$, $E = 16$, $\\sigma = 1$,\n  - $\\mathcal{O} = \\{0, 1, 1023\\}$,\n  - $\\mathcal{I} = \\{0\\}$.\n- 案例 D (GOT 条目因其大小而跨越两个页面，触及多个文本页，大于 1 的最小 $N$ 值):\n  - $P = 4096$, $N = 2$, $T = 32768$, $G = 9000$, $E = 500$, $\\sigma = 0$,\n  - $\\mathcal{O} = \\{0, 5000, 9000, 16000, 32000\\}$,\n  - $\\mathcal{I} = \\{0, 9\\}$.\n\n最终输出格式要求：\n- 你的程序应生成单行输出，其中包含一个逗号分隔的各测试结果列表，并用一对总的方括号括起来。每个测试结果本身必须是方括号内的四个整数列表。输出中任何位置都不允许有空格。\n- 示例总体形式：\n  - 对于 $k$ 个测试用例，输出应如下所示\n  $$\\text{\"[[r_{1,1},r_{1,2},r_{1,3},r_{1,4}],[r_{2,1},r_{2,2},r_{2,3},r_{2,4}],\\dots,[r_{k,1},r_{k,2},r_{k,3},r_{k,4}]]\"}.$$", "solution": "该问题要求分析共享库动态重定位所产生的内存开销，并比较位置无关代码 (PIC) 与非位置无关代码 (non-PIC)。此分析基于一个采用分页内存管理和写时复制 (COW) 机制的现代操作系统环境。\n\n### 基本原理\n\n1.  **虚拟内存与分页**：操作系统为每个进程提供其自己的私有虚拟地址空间，该空间以称为“页”的离散单元映射到物理内存。一个页是大小为 $P$ 字节的连续虚拟内存块。\n\n2.  **共享库与写时复制 (COW)**：为节省物理内存，当多个进程加载同一个共享库时，操作系统会将其相应的虚拟页映射到相同的物理内存页。最初，这些页被标记为只读。如果任何进程试图写入这样一个共享页，COW 机制就会被触发。操作系统会截获该写入操作，分配一个新的物理页，将原始共享页的内容复制到新页中，并将写入进程的虚拟页映射到这个新的、私有的、可写的副本上。这在确保进程隔离的同时，最大化了只读数据的内存共享。对于 $N$ 个最终都会写入同一个页面的进程，单个页面上发生 COW 的成本是创建 $N-1$ 个新的物理页，即在第一次写入触发初始分离后，为其余每个进程创建一个。总私有内存变为 $N \\cdot P$ 字节，比单个共享页面增加了 $(N-1) \\cdot P$ 字节。\n\n3.  **动态重定位**：当一个程序使用共享库时，该库中函数和全局变量的地址在编译时是未知的。动态链接器在加载时或运行时解析这些符号引用，方法是将实际的虚拟地址写入指定的位置。这些写入操作称为重定位。\n\n4.  **非位置无关代码 (non-PIC)**：在这种较旧的模型中，编译器生成使用绝对地址的代码。因此，机器码本身（即 `.text` 段）包含了必须由动态链接器用正确地址进行修补的位置。这些被称为文本重定位。当一个进程加载一个 non-PIC 共享库时，动态链接器必须写入其 `.text` 段。这种写入行为会对每个包含重定位目标的页面触发 COW。\n\n5.  **位置无关代码 (PIC) 与 GOT/PLT**：为避免文本重定位，现代系统使用 PIC。所有内存访问都相对于当前指令指针进行。对于外部符号，这是通过两个结构来介导的：\n    *   **全局偏移表 (GOT)**：一个位于可写数据段中的表，用于存储外部函数和变量的绝对地址。\n    *   **过程链接表 (PLT)**：一个位于文本段中的只读表，包含小的代码存根。当共享库中的一个函数首次被调用时，其 PLT 条目会调用动态链接器中的一个解析例程。该解析例程找到函数的真实地址，并将其写入相应的 GOT 条目中。之后对同一函数的调用将通过 PLT 重定向到 GOT，GOT 中现在包含了正确的地址，从而直接跳转到该函数。\n\n    这种设计确保了所有的重定位写入都发生在可写的数据段中（具体来说是 GOT），使得文本段保持原始状态（只读）。因此，文本段可以在所有进程之间共享，而不会因为重定位而触发 COW 错误。\n\n6.  **写异或执行 (W^X)**：一种安全策略，防止内存页同时具有可写和可执行权限。这可以缓解某些类型的漏洞利用，例如注入并执行恶意代码的缓冲区溢出。在严格的 W^X 策略下，试图将一个可执行页（如 `.text` 段中的页）变为可写将会失败。因此，在这种策略下，加载需要文本重定位的 non-PIC 共享库是不可能的。\n\n### 数学模型推导\n\n该问题提供了一个形式化模型来量化内存影响。\n\n-   **唯一的脏页**：一个位于偏移量 $o$ 的重定位会弄脏索引为 $\\left\\lfloor o/P \\right\\rfloor$ 的页面。由于多个重定位可能落在同一个页面内，我们必须计算受影响的*唯一*页面的数量。被弄脏的唯一文本页集合为 $\\mathcal{P}_{\\text{text}} = \\left\\{ \\left\\lfloor o/P \\right\\rfloor \\mid o \\in \\mathcal{O} \\right\\}$，其基数为 $U_{\\text{text}} = |\\mathcal{P}_{\\text{text}}|$。类似地，对于 GOT，索引为 $i$ 的条目的重定位发生在偏移量 $i \\cdot E$ 处。被弄脏的唯一 GOT 页集合为 $\\mathcal{P}_{\\text{got}} = \\left\\{ \\left\\lfloor (i \\cdot E)/P \\right\\rfloor \\mid i \\in \\mathcal{I} \\right\\}$，其基数为 $U_{\\text{got}} = |\\mathcal{P}_{\\text{got}}|$。\n\n-   **额外私有内存计算**：对于每个被写入的唯一页面，会在 $N$ 个进程中创建 $N-1$ 个私有副本，每个副本的大小为 $P$。\n    -   对于 **non-PIC** 库，会发生文本和 GOT 重定位。被弄脏的唯一页面总数为 $U_{\\text{text}} + U_{\\text{got}}$。因此，总的额外私有内存为：\n        $$M_{\\text{nonpic}} = (N - 1) \\cdot (U_{\\text{text}} + U_{\\text{got}}) \\cdot P$$\n    -   对于 **PIC** 库，只发生 GOT 重定位。文本段不会被写入，因此 $U_{\\text{text}}$ 不会产生 COW 开销。额外私有内存为：\n        $$M_{\\text{pic}} = (N - 1) \\cdot U_{\\text{got}} \\cdot P$$\n\n-   **失败指示符 ($F$)**：该指示符模拟了 W^X 策略的效果。如果策略是严格的（$\\sigma=1$）并且存在任何文本重定位（$U_{\\text{text}}  0$），则加载过程失败。\n    $$F = \\begin{cases} 1,  \\text{if } \\sigma = 1 \\text{ and } U_{\\text{text}}  0 \\\\ 0,  \\text{otherwise} \\end{cases}$$\n\n-   **内存节省**：差值 $M_{\\text{nonpic}} - M_{\\text{pic}}$ 量化了通过使用 PIC 实现的内存节省，这完全归功于避免了文本重定位：\n    $$M_{\\text{nonpic}} - M_{\\text{pic}} = (N - 1) \\cdot U_{\\text{text}} \\cdot P$$\n\n### 测试用例计算\n\n解决方案需要为每个提供的测试用例计算四元组 $\\left[F, M_{\\text{nonpic}}, M_{\\text{pic}}, M_{\\text{nonpic}} - M_{\\text{pic}}\\right]$。这涉及到通过为给定的重定位偏移量找到唯一的页面索引数来确定 $U_{\\text{text}}$ 和 $U_{\\text{got}}$，然后应用上述公式。\n\n**案例 A：** $P=4096, N=10, \\sigma=0, \\mathcal{O}=\\{100, 4095, 4096, 8191\\}, \\mathcal{I}=\\{0, 1\\}, E=8$。\n-   $U_{\\text{text}}$：偏移量 $100, 4095$ 映射到页面 $\\lfloor 100/4096 \\rfloor = \\lfloor 4095/4096 \\rfloor = 0$。偏移量 $4096, 8191$ 映射到页面 $\\lfloor 4096/4096 \\rfloor = \\lfloor 8191/4096 \\rfloor = 1$。唯一页面集合为 $\\{0, 1\\}$，因此 $U_{\\text{text}}=2$。\n-   $U_{\\text{got}}$：索引 $0, 1$ 得到偏移量 $0 \\cdot 8=0$ 和 $1 \\cdot 8=8$。两者都映射到页面 $\\lfloor 0/4096 \\rfloor = \\lfloor 8/4096 \\rfloor = 0$。集合为 $\\{0\\}$，因此 $U_{\\text{got}}=1$。\n-   $F=0$ 因为 $\\sigma=0$。\n-   $M_{\\text{nonpic}} = (10-1) \\cdot (2+1) \\cdot 4096 = 9 \\cdot 3 \\cdot 4096 = 110592$ 字节。\n-   $M_{\\text{pic}} = (10-1) \\cdot 1 \\cdot 4096 = 9 \\cdot 4096 = 36864$ 字节。\n-   差值 = $110592 - 36864 = 73728$ 字节。\n-   结果: $[0, 110592, 36864, 73728]$\n\n**案例 B：** $P=4096, N=5, \\sigma=1, \\mathcal{O}=\\emptyset, \\mathcal{I}=\\{0, 400\\}, E=8$。\n-   $U_{\\text{text}}=0$ 因为 $\\mathcal{O}$ 是空集。\n-   $U_{\\text{got}}$：索引 $0, 400$ 得到偏移量 $0, 3200$。两者都映射到页面 $\\lfloor 0/4096 \\rfloor = \\lfloor 3200/4096 \\rfloor = 0$。集合为 $\\{0\\}$，因此 $U_{\\text{got}}=1$。\n-   $F=0$ 因为 $U_{\\text{text}}=0$。\n-   $M_{\\text{nonpic}} = (5-1) \\cdot (0+1) \\cdot 4096 = 4 \\cdot 4096 = 16384$ 字节。\n-   $M_{\\text{pic}} = (5-1) \\cdot 1 \\cdot 4096 = 4 \\cdot 4096 = 16384$ 字节。\n-   差值 = $0$ 字节。\n-   结果: $[0, 16384, 16384, 0]$\n\n**案例 C：** $P=1024, N=3, \\sigma=1, \\mathcal{O}=\\{0, 1, 1023\\}, \\mathcal{I}=\\{0\\}, E=16$。\n-   $U_{\\text{text}}$：偏移量 $0, 1, 1023$ 都映射到页面 $\\lfloor 0/1024 \\rfloor = \\dots = \\lfloor 1023/1024 \\rfloor = 0$。集合为 $\\{0\\}$，因此 $U_{\\text{text}}=1$。\n-   $U_{\\text{got}}$：索引 $0$ 得到偏移量 $0$，映射到页面 $\\lfloor 0/1024 \\rfloor = 0$。集合为 $\\{0\\}$，因此 $U_{\\text{got}}=1$。\n-   $F=1$ 因为 $\\sigma=1$ 且 $U_{\\text{text}}=1  0$。\n-   $M_{\\text{nonpic}} = (3-1) \\cdot (1+1) \\cdot 1024 = 2 \\cdot 2 \\cdot 1024 = 4096$ 字节。\n-   $M_{\\text{pic}} = (3-1) \\cdot 1 \\cdot 1024 = 2 \\cdot 1024 = 2048$ 字节。\n-   差值 = $2048$ 字节。\n-   结果: $[1, 4096, 2048, 2048]$\n\n**案例 D：** $P=4096, N=2, \\sigma=0, \\mathcal{O}=\\{0, 5000, 9000, 16000, 32000\\}, \\mathcal{I}=\\{0, 9\\}, E=500$。\n-   $U_{\\text{text}}$：页面索引为 $\\lfloor 0/4096 \\rfloor=0$, $\\lfloor 5000/4096 \\rfloor=1$, $\\lfloor 9000/4096 \\rfloor=2$, $\\lfloor 16000/4096 \\rfloor=3$, $\\lfloor 32000/4096 \\rfloor=7$。集合为 $\\{0, 1, 2, 3, 7\\}$，因此 $U_{\\text{text}}=5$。\n-   $U_{\\text{got}}$：索引 $0, 9$ 得到偏移量 $0, 4500$。页面索引为 $\\lfloor 0/4096 \\rfloor=0$, $\\lfloor 4500/4096 \\rfloor=1$。集合为 $\\{0, 1\\}$，因此 $U_{\\text{got}}=2$。\n-   $F=0$ 因为 $\\sigma=0$。\n-   $M_{\\text{nonpic}} = (2-1) \\cdot (5+2) \\cdot 4096 = 1 \\cdot 7 \\cdot 4096 = 28672$ 字节。\n-   $M_{\\text{pic}} = (2-1) \\cdot 2 \\cdot 4096 = 1 \\cdot 2 \\cdot 4096 = 8192$ 字节。\n-   差值 = $28672 - 8192 = 20480$ 字节。\n-   结果: $[0, 28672, 8192, 20480]$", "answer": "```c\n#include", "id": "3636956"}, {"introduction": "动态链接最强大的特性之一是其在运行时的灵活性，特别是符号拦截（symbol interposition）能力。通过`LD_PRELOAD`等机制，我们可以在不修改原始程序的情况下改变其行为，这在调试、监控和扩展功能时非常有用。本练习模拟了动态链接器如何根据加载顺序、安全设置和符号属性来选择函数的具体实现，让你亲身体验符号拦截的威力与规则。[@problem_id:3636919]", "problem": "您将实现一个完整、可运行的程序，该程序在一个简化的、但在科学上合理的“可执行与可链接格式 (ELF)”运行时解析的抽象模型下，对名为 \"open\" 的单个符号进行动态链接器符号介入的建模。对于一个固定的测试套件，该程序必须确定运行时链接器选择了哪个对象的 \"open\" 定义，以及这个选择是否构成了通过加载预载入 (LD_PRELOAD) 机制实现的符号介入。程序必须生成一行输出来编码这些结果。\n\n此任务的基本依据是以下来自操作系统和动态链接领域且经过充分检验的事实与核心定义。动态链接器会构建一个带有有序搜索列表的全局解析作用域；列表中靠前的条目会对靠后的条目进行介入。当应用 LD_PRELOAD 时，其库文件会被放在搜索顺序的最前面。在安全执行上下文中（例如，set-user-ID 二进制文件会引发动态加载器进入安全模式），基于环境的预加载会被忽略。一个符号定义必须以默认可见性被全局导出，并且匹配所需的符号版本，才有资格被解析。隐藏可见性通过使符号不可抢占来防止外部介入，而版本不匹配的情况则会被拒绝。\n\n使用以下定义来建模运行时解析。假设有 $n$ 个动态加载的对象（包括主可执行文件）。每个对象由一个属性元组 $(\\text{id}, \\text{is\\_main}, \\text{load\\_source}, \\text{preload\\_order}, \\text{dep\\_order}, \\text{defines}, \\text{visibility}, \\text{version})$ 描述，其中：\n- $\\text{id} \\in \\mathbb{Z}$ 是在结果中报告的标识符（例如，主可执行文件为 $0$）。\n- $\\text{is\\_main} \\in \\{0,1\\}$ 指示该对象是否是主可执行文件（$1$）或不是（$0$）。\n- $\\text{load\\_source} \\in \\{0,1\\}$ 指示是正常依赖（$0$）还是 LD_PRELOAD（$1$）。\n- $\\text{preload\\_order} \\in \\mathbb{Z}$ 是在 LD_PRELOAD 库中的位置（数值越小越靠前）；对于非 LD_PRELOAD 对象，此值设为 $-1$。\n- $\\text{dep\\_order} \\in \\mathbb{Z}$ 是在正常依赖中的依赖加载顺序（数值越小越靠前）；对于非依赖对象（如主可执行文件），此值设为 $-1$。\n- $\\text{defines} \\in \\{0,1\\}$ 指示对象是否定义了符号 \"open\"。\n- $\\text{visibility} \\in \\{0,1\\}$ 指示 \"open\" 符号的可见性为默认（$0$）或隐藏（$1$）。\n- $\\text{version} \\in \\mathbb{Z}$ 是对象为 \"open\" 提供的符号版本。\n\n设全局所需版本为 $V_{\\text{req}} \\in \\mathbb{Z}$，并设 $\\text{secure} \\in \\{0,1\\}$ 指示安全执行是否激活（$1$）或未激活（$0$）。动态链接器的搜索顺序建模如下：\n- 如果 $\\text{secure} = 0$，搜索列表以按 $\\text{preload\\_order}$ 升序排序的 LD_PRELOAD 库开始，然后是主可执行文件（$\\text{is\\_main} = 1$ 的唯一对象），接着是按 $\\text{dep\\_order}$ 升序排序的正常依赖。\n- 如果 $\\text{secure} = 1$，LD_PRELOAD 库被忽略，搜索列表以主可执行文件开始，然后是按 $\\text{dep\\_order}$ 升序排序的正常依赖。\n\n将对象 $o$ 的资格谓词 $P(o)$ 定义为 $P(o) = (\\text{defines} = 1) \\land (\\text{visibility} = 0) \\land (\\text{version} = V_{\\text{req}})$。解析函数 $R$ 返回搜索列表中第一个使 $P(o)$ 为真的对象的 $\\text{id}$，如果不存在这样的对象，则返回 $-1$。定义介入指示符 $I$：如果所选对象的 $\\text{load\\_source} = 1$，则 $I$ 为 $1$，否则为 $0$；如果 $R = -1$，则 $I = 0$。\n\n用 C 语言实现一个程序，硬编码下面的测试套件，并按指定格式将所有情况的结果打印在单行上。该程序不得执行任何文件输入或输出，除了基本的计算和打印外，不得依赖任何操作系统功能。程序必须通过根据上述规则构建搜索顺序并应用谓词 $P$ 来为每个测试用例计算 $R$ 和 $I$。\n\n测试套件：\n- Case $1$ (使用 LD_PRELOAD 介入的正常路径):\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 3$.\n  - 对象:\n    - 主可执行文件 $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n    - 预加载库 $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n    - 正常依赖 $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n- Case $2$ (安全执行忽略 LD_PRELOAD):\n  - $\\text{secure} = 1$, $V_{\\text{req}} = 10$, $n = 3$.\n  - 对象:\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=0, \\text{visibility}=0, \\text{version}=0)$。\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n- Case $3$ (隐藏可见性阻止介入):\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 3$.\n  - 对象:\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=0, \\text{visibility}=0, \\text{version}=0)$。\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=1, \\text{version}=10)$。\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n- Case $4$ (LD_PRELOAD 中的版本不匹配导致回退):\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 3$.\n  - 对象:\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=0, \\text{visibility}=0, \\text{version}=0)$。\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=20)$。\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n- Case $5$ (多个 LD_PRELOAD 库，顺序决定介入):\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 4$.\n  - 对象:\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n    - $L3$: $(\\text{id}=3, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=1, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n- Case $6$ (没有合格的提供者：边界情况):\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 3$.\n  - 对象:\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=0, \\text{visibility}=0, \\text{version}=0)$。\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=20)$。\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=30)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须包含 $12$ 个整数：对于从 $1$ 到 $6$ 的每个测试用例 $i$，输出所选提供者的 $\\text{id}$，后跟介入指示符。格式为 $[\\text{id}_1,I_1,\\text{id}_2,I_2,\\dots,\\text{id}_6,I_6]$，不含多余的空格或文本。", "solution": "该问题要求我们实现一个动态链接器符号解析的计算模型，并将其应用于六个测试用例。核心任务是根据 `secure` 标志正确构建符号搜索列表，然后遍历该列表以找到第一个*合格的*符号提供者。\n\n### 核心逻辑\n\n1.  **构建搜索列表**：\n    -   将对象分为三组：`LD_PRELOAD` 库、主可执行文件和正常依赖项。\n    -   按 `preload_order` 对 `LD_PRELOAD` 库进行升序排序。\n    -   按 `dep_order` 对正常依赖项进行升序排序。\n    -   如果 `secure == 0`，最终搜索顺序为：排序后的 `LD_PRELOAD` 库 -> 主可执行文件 -> 排序后的依赖项。\n    -   如果 `secure == 1`，最终搜索顺序为：主可执行文件 -> 排序后的依赖项。\n\n2.  **查找获胜者**：\n    -   遍历构建好的搜索列表。\n    -   对于每个对象 `o`，使用谓词 $P(o) = (\\text{defines} = 1) \\land (\\text{visibility} = 0) \\land (\\text{version} = V_{\\text{req}})$ 来检查其是否合格。\n    -   第一个满足 $P(o)$ 的对象即为获胜者。其 `id` 是结果 $R$。\n    -   如果获胜者的 `load_source` 为 1，则介入标志 $I$ 为 1，否则为 0。\n    -   如果没有对象满足该谓词，则 $R=-1$ 且 $I=0$。\n\n### 测试用例分析\n\n*   **案例 1**：正常预加载。`secure=0`, $V_{\\text{req}}=10$。\n    -   搜索列表：L1 (id=1, preload), E (id=0, main), L2 (id=2, dep)。\n    -   检查 L1：`defines=1`, `visibility=0`, `version=10`。匹配。**获胜者：L1 (id=1)**。\n    -   介入：L1 的 `load_source=1`。因此，$I=1$。\n    -   结果：`[1, 1]`。\n\n*   **案例 2**：安全执行。`secure=1`, $V_{\\text{req}}=10$。\n    -   `LD_PRELOAD` (L1) 被忽略。搜索列表：E (id=0, main), L2 (id=2, dep)。\n    -   检查 E：`defines=0`。不合格。\n    -   检查 L2：`defines=1`, `visibility=0`, `version=10`。匹配。**获胜者：L2 (id=2)**。\n    -   介入：L2 的 `load_source=0`。因此，$I=0$。\n    -   结果：`[2, 0]`。\n\n*   **案例 3**：隐藏可见性。`secure=0`, $V_{\\text{req}}=10$。\n    -   搜索列表：L1 (id=1), E (id=0), L2 (id=2)。\n    -   检查 L1：`visibility=1`。不合格。\n    -   检查 E：`defines=0`。不合格。\n    -   检查 L2：`defines=1`, `visibility=0`, `version=10`。匹配。**获胜者：L2 (id=2)**。\n    -   介入：L2 的 `load_source=0`。因此，$I=0$。\n    -   结果：`[2, 0]`。\n\n*   **案例 4**：版本不匹配。`secure=0`, $V_{\\text{req}}=10$。\n    -   搜索列表：L1 (id=1), E (id=0), L2 (id=2)。\n    -   检查 L1：`version=20`。不合格。\n    -   检查 E：`defines=0`。不合格。\n    -   检查 L2：`defines=1`, `visibility=0`, `version=10`。匹配。**获胜者：L2 (id=2)**。\n    -   介入：L2 的 `load_source=0`。因此，$I=0$。\n    -   结果：`[2, 0]`。\n\n*   **案例 5**：多个预加载库。`secure=0`, $V_{\\text{req}}=10$。\n    -   `LD_PRELOAD` 库为 L3 (`preload_order=0`) 和 L1 (`preload_order=1`)。排序后列表：L3, L1。\n    -   搜索列表：L3 (id=3), L1 (id=1), E (id=0), L2 (id=2)。\n    -   检查 L3：`defines=1`, `visibility=0`, `version=10`。匹配。**获胜者：L3 (id=3)**。\n    -   介入：L3 的 `load_source=1`。因此，$I=1$。\n    -   结果：`[3, 1]`。\n\n*   **案例 6**：没有合格的提供者。`secure=0`, $V_{\\text{req}}=10$。\n    -   搜索列表：L1 (id=1), E (id=0), L2 (id=2)。\n    -   检查 L1：`version=20`。不合格。\n    -   检查 E：`defines=0`。不合格。\n    -   检查 L2：`version=30`。不合格。\n    -   未找到获胜者。**结果：$R=-1$**。\n    -   介入：$I=0$。\n    -   结果：`[-1, 0]`。\n\n该详细分析确认了生成最终输出字符串所需的逻辑。程序将实现此逻辑，为所有案例计算结果，并按要求格式化输出。", "answer": "```c\n#include", "id": "3636919"}, {"introduction": "当程序不再需要某个共享库时，将其从内存中卸载似乎是理所当然的。然而，如果卸载时机不当，可能会导致灾难性的“悬挂指针”问题，即调用已被卸载的代码。本练习将通过一个事件驱动的模型，生动地展示这种“卸载后使用”（use-after-unload）的危险，并对比一种简单的卸载策略和一种基于引用计数的安全模式，帮助你理解构建健壮动态程序的关键。[@problem_id:3636903]", "problem": "要求您设计一个精确、可执行的动态链接行为模型，以演示在回调到某个共享库的可能性依然存在时卸载该库的风险。您的程序必须实现两种策略，并在一个固定的事件序列测试套件上检查每种策略下的“卸载后使用”风险。这两种策略模拟了：(i) 一种朴素卸载，它在收到关闭请求时立即解除库的映射；以及 (ii) 一种安全卸载，它将解除映射的操作推迟到没有引用剩余为止，并包含一个用于取消回调的显式关闭钩子。\n\n基本基础。使用以下经过充分测试的事实和核心定义作为您模型的基础。当一个共享对象被动态链接时，该对象的代码和数据会被映射到进程的地址空间中；一个引用共享对象中代码的函数指针仅在该代码保持映射状态时有效。如果一个指向库函数的回调指针在该库被卸载后被调用，该调用将尝试执行未映射的代码，这是一种“卸载后使用”风险。一种广泛使用的安全模式采用引用计数来推迟卸载，直到所有使用都已释放，有时还会结合一个显式的关闭钩子来取消或注销悬而未决的回调。您的模型应忠实地、抽象地捕捉这些行为。\n\n形式化模型。您将模拟一个单一进程与一个单一动态加载库的交互。时间以离散的步长推进，由 $t \\in \\{1,2,\\dots,T\\}$ 索引。在每一步，恰好发生一个事件，选自以下事件集：\n- 注册回调：令牌 R\n- 注销回调：令牌 U\n- 触发回调：令牌 F（如果存在已注册的回调，则尝试调用它）\n- 关闭请求（请求卸载库）：令牌 C\n- 获取一个非回调引用（例如，一个正在处理的任务）：令牌 A\n- 释放一个非回调引用：令牌 D\n- 执行关闭钩子（显式注销所有回调）：令牌 S\n\n朴素策略的状态变量：\n- $L(t) \\in \\{0,1\\}$ 表示库当前是否被映射（$1$ 表示已映射）。\n- $N(t) \\in \\mathbb{N}_0$ 统计已注册的悬而未决的回调数量。\n- 风险指示器 $H_{\\mathrm{naive}} \\in \\{0,1\\}$ 在任何 F 事件发生于 $L(t)=0$ 且 $N(t)0$ 时变为 $1$。\n\n安全策略的状态变量（带有关闭钩子的引用计数）：\n- $L(t) \\in \\{0,1\\}$ 表示库当前是否被映射。\n- $W(t) \\in \\{0,1\\}$ 表示一个待处理的关闭请求。\n- $N(t) \\in \\mathbb{N}_0$ 统计已注册的悬而未决的回调数量。\n- $Q(t) \\in \\mathbb{N}_0$ 统计非回调引用（获取）的数量。\n- 引用计数为 $R(t) = N(t) + Q(t)$。\n- 风险指示器 $H_{\\mathrm{safe}} \\in \\{0,1\\}$ 在任何 F 事件发生于 $L(t)=0$ 且 $N(t)0$ 时变为 $1$。\n- 卸载条件：当且仅当 $W(t)=1$ 且 $R(t)=0$ 时发生卸载。\n\n事件语义。初始化 $L(0)=1$，$W(0)=0$，$N(0)=0$，$Q(0)=0$，并且两个风险指示器均为 $0$。\n- R: $N \\leftarrow N+1$。在安全策略中，$R$ 也因此增加 $1$。\n- U: 如果 $N0$ 则 $N \\leftarrow N-1$。\n- F: 如果 $L=0$ 且 $N0$ 则将相应的风险指示器设置为 $1$；否则状态无变化。\n- C（朴素策略）：立即 $L \\leftarrow 0$。C（安全策略）：$W \\leftarrow 1$；如果 $R=0$ 则 $L \\leftarrow 0$，否则 $L$ 保持为 $1$ 直到 $R$ 变为 $0$。\n- A: $Q \\leftarrow Q+1$。\n- D: 如果 $Q0$ 则 $Q \\leftarrow Q-1$。\n- S（仅安全策略）：原子地注销所有回调，即 $N \\leftarrow 0$；在朴素策略中此事件无效果。\n- 在安全策略中，任何事件变化后，如果 $W=1$ 且 $R=0$，则设置 $L \\leftarrow 0$。\n\n任务。实现一个程序，该程序：\n- 精确地编码上述语义。\n- 在下面的每个事件序列上模拟两种策略。\n- 对于每个序列，输出两个结果：首先是 $H_{\\mathrm{naive}}$，然后是 $H_{\\mathrm{safe}}$，每个结果为 $0$ 或 $1$。\n\n测试套件。使用以下 $5$ 个序列，每个序列都以事件令牌的连续字符串形式给出：\n- 序列 1：RFUC\n- 序列 2：RCFU\n- 序列 3：CF\n- 序列 4：RACFDU\n- 序列 5：RCSF\n\n覆盖理由。该套件包括一个正常情况（序列 1），一个在朴素卸载策略下可演示的风险，其中回调在关闭后触发（序列 2），一个没有回调的无操作关闭（序列 3），来自额外非回调引用的干扰（序列 4），以及使用显式关闭钩子在关闭请求后安全地分离回调（序列 5）。\n\n输出格式。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含 $10$ 个整数，对应于 $[H_{\\mathrm{naive}}^{(1)},H_{\\mathrm{safe}}^{(1)},H_{\\mathrm{naive}}^{(2)},H_{\\mathrm{safe}}^{(2)},\\dots,H_{\\mathrm{naive}}^{(5)},H_{\\mathrm{safe}}^{(5)}]$，不含空格。例如：“[0,0,1,0,0,0,1,0,1,0]”。不应读取任何输入，也不应打印任何其他输出。", "solution": "该问题要求模拟两种处理共享库卸载的策略——一种朴素策略和一种安全的、带引用计数的策略——并确定对于一组给定的事件序列，是否会发生“卸载后使用”风险。\n\n模拟遵循指定的形式化模型。系统的状态由每种策略的一组变量定义，这些变量根据指定的事件语义在离散的时间步中演化。两种策略在时间 $t=0$ 的初始状态是：库已映射（$L(0)=1$）、没有已注册的回调（$N(0)=0$）、没有非回调引用（$Q(0)=0$）、没有待处理的关闭请求（$W(0)=0$），且未检测到风险（$H_{\\mathrm{naive}}=0$，$H_{\\mathrm{safe}}=0$）。\n\n两种策略的风险条件是相同的：如果“触发回调”事件（F）发生在一个时间点 $t$，此时库未被映射（$L(t)=0$）但仍存在悬而未决的已注册回调（$N(t)0$），则风险标志（$H_{\\mathrm{naive}}$ 或 $H_{\\mathrm{safe}}$）被设置为 $1$。\n\n我们现在将在朴素和安全两种策略下，追踪 5 个测试序列中每一个的状态变量演化过程。\n\n### 序列 1：`RFUC`\n此序列代表一个正常的、安全的操作生命周期。\n- **朴素策略：**\n  1. `R`：回调计数变为 $N=1$。\n  2. `F`：库是映射的（$L=1$），所以触发回调是安全的。$H_{\\mathrm{naive}}$ 保持为 $0$。\n  3. `U`：回调被注销，因此 $N$ 变为 $0$。\n  4. `C`：一个关闭请求卸载了库，设置 $L=0$。此时，$N=0$，所以没有潜在风险。\n  **结果：** $H_{\\mathrm{naive}}=0$。\n- **安全策略：**\n  1. `R`：回调计数 $N$ 变为 $1$。总引用计数为 $R = N+Q = 1$。\n  2. `F`：库是映射的（$L=1$），所以调用是安全的。$H_{\\mathrm{safe}}$ 保持为 $0$。\n  3. `U`：回调被注销（$N=0$），使得引用计数 $R=0$。\n  4. `C`：一个关闭请求被注册（$W=1$）。因为引用计数 $R$ 已经是 $0$，满足卸载条件（$W=1 \\text{ 且 } R=0$），库被立即卸载（$L=0$）。\n  **结果：** $H_{\\mathrm{safe}}=0$。\n- **配对结果：** $[0,0]$\n\n### 序列 2：`RCFU`\n此序列旨在暴露朴素策略中的风险。\n- **朴素策略：**\n  1. `R`：回调计数变为 $N=1$。\n  2. `C`：库被立即卸载，设置 $L=0$。一个回调仍然被注册（$N=1$）。\n  3. `F`：触发事件发生。库未被映射（$L=0$），而回调存在（$N0$）。这触发了风险条件。$H_{\\mathrm{naive}}$ 被设置为 $1$。\n  4. `U`：回调被注销（$N=0$）。风险标志保持被设置的状态。\n  **结果：** $H_{\\mathrm{naive}}=1$。\n- **安全策略：**\n  1. `R`：回调计数 $N$ 变为 $1$，所以引用计数为 $R=1$。\n  2. `C`：一个关闭请求被注册（$W=1$）。因为 $R=1$，库不会被卸载；$L$ 保持为 $1$。\n  3. `F`：触发事件在库仍然映射时（$L=1$）发生。调用是安全的。$H_{\\mathrm{safe}}$ 保持为 $0$。\n  4. `U`：回调被注销（$N=0$），所以引用计数变为 $R=0$。事件后检查发现满足卸载条件（$W=1 \\text{ 且 } R=0$），所以库现在被卸载（$L=0$）。\n  **结果：** $H_{\\mathrm{safe}}=0$。\n- **配对结果：** $[1,0]$\n\n### 序列 3：`CF`\n此序列测试了从未注册任何回调时的行为。\n- **朴素策略：**\n  1. `C`：库被卸载（$L=0$）。回调计数为 $N=0$。\n  2. `F`：触发事件发生。尽管库未被映射（$L=0$），但没有已注册的回调（$N=0$），所以没有风险发生。\n  **结果：** $H_{\\mathrm{naive}}=0$。\n- **安全策略：**\n  1. `C`：一个关闭请求被注册（$W=1$）。引用计数为 $R=0$。满足卸载条件，所以库被立即卸载（$L=0$）。\n  2. `F`：触发事件在 $L=0$ 和 $N=0$ 时发生。无风险。\n  **结果：** $H_{\\mathrm{safe}}=0$。\n- **配对结果：** $[0,0]$\n\n### 序列 4：`RACFDU`\n此序列演示了在安全策略中，非回调引用如何同样能防止过早卸载。\n- **朴素策略：** `A` (获取) 和 `D` (释放) 事件没有效果。该序列实际上变成了 `RCFU`。\n  1. `R`：$N=1$。\n  2. `C`：$L=0$。\n  3. `F`：$L=0$ 且 $N0$。风险被触发。$H_{\\mathrm{naive}}$ 被设置为 $1$。\n  **结果：** $H_{\\mathrm{naive}}=1$。\n- **安全策略：**\n  1. `R`：$N$ 变为 $1$。引用计数 $R = 1$。\n  2. `A`：获取了一个非回调引用，$Q=1$。引用计数变为 $R = N+Q = 1+1=2$。\n  3. `C`：关闭请求被注册（$W=1$）。由于 $R=2$，库保持加载状态（$L=1$）。\n  4. `F`：触发事件在 $L=1$ 时安全发生。\n  5. `D`：非回调引用被释放，$Q=0$。引用计数变为 $R=N+Q = 1+0=1$。卸载条件尚未满足。\n  6. `U`：回调被注销，$N=0$。引用计数变为 $R=N+Q = 0+0=0$。事件后检查发现 $W=1$ 且 $R=0$，所以库现在被卸载（$L=0$）。\n  **结果：** $H_{\\mathrm{safe}}=0$。\n- **配对结果：** $[1,0]$\n\n### 序列 5：`RCSF`\n此序列展示了显式关闭钩子的作用。\n- **朴素策略：** `S` (关闭) 事件没有效果。该序列实际上是 `RCF`。\n  1. `R`：$N=1$。\n  2. `C`：$L=0$。\n  3. `F`：$L=0$ 且 $N0$。风险被触发。$H_{\\mathrm{naive}}$ 被设置为 $1$。\n  **结果：** $H_{\\mathrm{naive}}=1$。\n- **安全策略：**\n  1. `R`：$N$ 变为 $1$，所以 $R=1$。\n  2. `C`：关闭请求被注册（$W=1$）。由于 $R0$，库保持加载状态（$L=1$）。\n  3. `S`：关闭钩子运行，原子地注销所有回调。$N$ 变为 $0$。引用计数现在为 $R=0$。事件后检查发现 $W=1$ 且 $R=0$，所以库被卸载（$L=0$）。\n  4. `F`：触发事件发生。尽管库未被映射（$L=0$），但关闭钩子已经清除了回调（$N=0$），因此不会尝试调用，也没有风险发生。\n  **结果：** $H_{\\mathrm{safe}}=0$。\n- **配对结果：** $[1,0]$\n\n### 最终汇总结果\n每个序列的风险标志为：\n- 序列 1：$[H_{\\mathrm{naive}}^{(1)}, H_{\\mathrm{safe}}^{(1)}] = [0,0]$\n- 序列 2：$[H_{\\mathrm{naive}}^{(2)}, H_{\\mathrm{safe}}^{(2)}] = [1,0]$\n- 序列 3：$[H_{\\mathrm{naive}}^{(3)}, H_{\\mathrm{safe}}^{(3)}] = [0,0]$\n- 序列 4：$[H_{\\mathrm{naive}}^{(4)}, H_{\\mathrm{safe}}^{(4)}] = [1,0]$\n- 序列 5：$[H_{\\mathrm{naive}}^{(5)}, H_{\\mathrm{safe}}^{(5)}] = [1,0]$\n\n将这些结果组合起来，得出最终的输出字符串。", "answer": "```c\n#include", "id": "3636903"}]}