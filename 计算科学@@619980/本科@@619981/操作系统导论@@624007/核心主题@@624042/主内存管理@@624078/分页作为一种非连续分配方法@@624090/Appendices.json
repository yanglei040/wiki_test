{"hands_on_practices": [{"introduction": "分页机制通过允许非连续分配内存，极大地提高了内存利用率，但这种灵活性并非没有代价。当程序访问一个不在物理内存中的页面时，会触发一个代价高昂的缺页中断。这个练习将引导你推导有效访存时间（$EAT$）的公式，从而定量地理解缺页率对系统整体性能的巨大影响。通过这个计算，你将体会到为何现代操作系统和程序员都必须竭力降低缺页率。[@problem_id:3668071]", "problem": "一台计算机采用请求分页来支持虚拟内存，并使用分页作为一种非连续分配方法。考虑一次由中央处理器（CPU）执行的单一内存引用。设当被引用的页存在于主存中时，完成一次内存引用的时间为 $t_m$。当发生页错误时，操作系统必须处理该错误，总的页错误处理时间为 $t_f$（包括输入/输出（I/O）传输、操作系统开销和进程重启）。在错误处理完毕后，原始的内存引用会重试，并在 $t_m$ 时间内完成。假设页错误率，定义为一次随机内存引用引发页错误的概率，是 $\\epsilon \\in [0,1]$。\n\n从随机变量的全期望定律出发，推导有效访问时间（EAT）作为 $\\epsilon$、$t_m$ 和 $t_f$ 的函数。使用您推导出的表达式，求解使得有效访问时间满足 $EAT \\leq 2t_m$ 的最大 $\\epsilon$。将您的最终答案表示为最大允许 $\\epsilon$ 的封闭形式符号表达式。不需要进行数值计算。", "solution": "首先评估问题的有效性。\n\n### 第一步：提取已知条件\n-   一台计算机使用请求分页和分页作为非连续分配方法。\n-   当页在主存中时，完成一次内存引用的时间是 $t_m$。\n-   当发生页错误时，总的页错误处理时间是 $t_f$。\n-   页错误处理完毕后，原始内存引用将重试，并在时间 $t_m$ 内完成。\n-   页错误率，即发生页错误的概率，是 $\\epsilon$，其中 $\\epsilon \\in [0,1]$。\n-   有效访问时间（EAT）的推导必须从全期望定律开始。\n-   最终目标是求解使得 $EAT \\leq 2t_m$ 的最大 $\\epsilon$。\n\n### 第二步：使用提取的已知条件进行验证\n该问题具有科学依据，是操作系统研究中一个标准的性能分析模型。所有术语，如“请求分页”、“页错误”、“有效访问时间”，在该领域内都有明确的定义。该问题是适定的，提供了所有必要的变量（$t_m$、$t_f$、$\\epsilon$）和一个明确的目标。它也是客观的，使用了精确的技术语言。问题设定是完整且一致的，能够导出一个唯一且有意义的解。该问题不违反任何无效性标准。\n\n### 第三步：结论与行动\n问题有效。将提供一个完整的解。\n\n### 求解推导\n该问题要求推导请求分页内存系统的有效访问时间（EAT）。我们必须从随机变量的全期望定律开始。\n\n设 $T$ 是表示完成一次内存引用总时间的随机变量。根据定义，EAT 是该随机变量的期望值，即 $EAT = E[T]$。\n\n设 $F$ 为内存引用导致页错误的事件。设 $F^c$ 为其互补事件，即被引用的页存在于主存中（页命中）。问题给出发生页错误的概率为页错误率 $\\epsilon$。\n$$ P(F) = \\epsilon $$\n因此，页命中的概率为：\n$$ P(F^c) = 1 - P(F) = 1 - \\epsilon $$\n\n对于随机变量 $T$，以互斥且穷举的事件 $F$ 和 $F^c$ 为条件的全期望定律由下式给出：\n$$ E[T] = E[T|F] P(F) + E[T|F^c] P(F^c) $$\n其中 $E[T|A]$ 是在事件 $A$ 发生的条件下 $T$ 的条件期望。\n\n我们必须根据问题陈述确定这两个条件期望的值。\n\n1.  $E[T|F^c]$：这是在页错误*不*发生（页命中）时的期望访问时间。问题陈述，当页在主存中时，完成一次内存引用的时间是 $t_m$。因此：\n    $$ E[T|F^c] = t_m $$\n\n2.  $E[T|F]$：这是在页错误*确实*发生时的期望访问时间。问题描述了发生错误时的一系列事件：\n    - 操作系统处理错误，总共耗时 $t_f$。\n    - 错误处理完毕后，重试原始的内存引用。由于此时可以保证页在主存中，这个重试操作将在 $t_m$ 时间内完成。\n    发生页错误情况下的总时间是服务时间与成功重试时间之和。\n    $$ E[T|F] = t_f + t_m $$\n\n现在，我们将这些部分代回全期望定律的公式中：\n$$ EAT = E[T] = (t_f + t_m) \\cdot P(F) + (t_m) \\cdot P(F^c) $$\n$$ EAT = (t_f + t_m) \\epsilon + t_m (1 - \\epsilon) $$\n\n我们简化这个 EAT 的表达式：\n$$ EAT = t_f \\epsilon + t_m \\epsilon + t_m - t_m \\epsilon $$\n$$ EAT = t_m + t_f \\epsilon $$\n这就是推导出的有效访问时间作为 $\\epsilon$、$t_m$ 和 $t_f$ 的函数表达式。\n\n问题的第二部分要求找到页错误率 $\\epsilon$ 的最大值，使得 EAT 不超过内存访问时间 $t_m$ 的两倍。这可以用不等式表示为：\n$$ EAT \\leq 2t_m $$\n\n将我们推导出的 EAT 表达式代入这个不等式：\n$$ t_m + t_f \\epsilon \\leq 2t_m $$\n\n为了解出 $\\epsilon$，我们首先通过在不等式两边减去 $t_m$ 来分离含有 $\\epsilon$ 的项：\n$$ t_f \\epsilon \\leq 2t_m - t_m $$\n$$ t_f \\epsilon \\leq t_m $$\n\n量 $t_m$ 和 $t_f$ 代表时间长度，因此是物理上的正实数。具体来说，$t_f > 0$。因此，我们可以在不等式两边同时除以 $t_f$ 而不改变不等号的方向：\n$$ \\epsilon \\leq \\frac{t_m}{t_f} $$\n\n问题要求满足此条件的*最大* $\\epsilon$ 值。所有有效的 $\\epsilon$ 值集合是区间 $[0, \\frac{t_m}{t_f}]$，同时也遵循固有的物理约束 $\\epsilon \\geq 0$。此区间中的最大值是 $\\frac{t_m}{t_f}$。问题还指出 $\\epsilon \\in [0,1]$。在任何实际的计算机系统中，涉及机械磁盘I/O的页错误处理时间 $t_f$ 比主存访问时间 $t_m$ 大几个数量级（例如，毫秒对纳秒）。因此，比率 $\\frac{t_m}{t_f}$ 是一个远小于1的小正数，所以约束 $\\epsilon \\leq 1$ 是隐式满足的。\n\n最大允许的页错误率是推导出的不等式的上界。", "answer": "$$ \\boxed{\\frac{t_m}{t_f}} $$", "id": "3668071"}, {"introduction": "为了实现虚拟地址到物理地址的映射，操作系统需要为每个进程维护一套页表结构。尽管分页解决了外部碎片问题，但页表本身也占用了宝贵的物理内存，构成了所谓的“内部开销”。这个练习将让你亲手计算在一个多级分页系统中，一个具有特定内存使用模式的进程需要多大的页表空间。这有助于你具体地理解分页机制在空间效率上的权衡。[@problem_id:3668035]", "problem": "一个系统为虚拟内存实现了分层页表，其属性基于以下标准定义。每个虚拟地址的宽度为 $48$ 位。一个页面的大小为 $4$ KiB，即 $4 \\times 2^{10}$ 字节，每个页表条目占用 $8$ 字节。每个页表本身恰好占用一个物理页面。只使用标准的 $4$ KiB 页面（不使用更大的页面）。每个进程独占其页表层次结构；页表页面不在进程间共享。考虑一个进程，它精确分配了 $64$ MiB 的用户空间虚拟内存，此外别无他物。这个 $64$ MiB 的区域是页面对齐的、连续的，对齐到 $2$ MiB 边界，并且完全位于虚拟地址空间中的单个 $1$ GiB 范围和单个 $512$ GiB 范围内。\n\n仅从以下核心定义出发：页偏移量的宽度等于页面大小（以字节为单位）的 $\\log_{2}$ 值，每个页表的条目数等于页面大小除以条目大小，一个包含 $n$ 个条目的级别占用虚拟地址的 $\\log_{2}(n)$ 个索引位。请推导出该进程的页表总内存开销，以及在所有级别上实例化的页表页面的实际数量。将内存开销以 KiB 为单位表示，页表页面计数以纯数字表示。提供精确的整数值；不要四舍五入。将你的最终答案报告为一个行向量 $\\big[$以 KiB 为单位的开销, 页表页面计数$\\big]$。", "solution": "我们从分页的基本定义开始。设页面大小为 $P$ 字节，每个页表条目的大小为 $E$ 字节。那么每个页表的条目数是\n$$\nN \\;=\\; \\frac{P}{E}.\n$$\n页偏移量需要\n$$\nb_{\\text{off}} \\;=\\; \\log_{2}(P)\n$$\n位的虚拟地址。如果每个页表有 $N$ 个条目，则每级的索引宽度为\n$$\nb_{\\ell} \\;=\\; \\log_{2}(N) \\;=\\; \\log_{2}\\!\\left(\\frac{P}{E}\\right).\n$$\n给定虚拟地址宽度为 $B$ 位，所有级别的索引位总数为 $B - b_{\\text{off}}$，这决定了级别的数量\n$$\nL \\;=\\; \\frac{B - b_{\\text{off}}}{b_{\\ell}}.\n$$\n\n代入参数。页面大小为 $P = 4 \\text{ KiB} = 4 \\times 2^{10} \\text{ 字节} = 2^{12} \\text{ 字节}$。条目大小为 $E = 8 \\text{ 字节} = 2^{3} \\text{ 字节}$。因此\n$$\nN \\;=\\; \\frac{2^{12}}{2^{3}} \\;=\\; 2^{9} \\;=\\; 512,\n$$\n并且\n$$\nb_{\\text{off}} \\;=\\; \\log_{2}(2^{12}) \\;=\\; 12,\\quad b_{\\ell} \\;=\\; \\log_{2}(2^{9}) \\;=\\; 9.\n$$\n当 $B = 48$ 时，索引位的数量为 $48 - 12 = 36$，因此级别数为\n$$\nL \\;=\\; \\frac{36}{9} \\;=\\; 4.\n$$\n因此，我们有一个标准的四级层次结构，其中每个较低级别的页表（1级）映射 $N$ 个页面，即 $N \\times P$ 字节：\n$$\n\\text{每个1级表的覆盖范围} \\;=\\; N \\cdot P \\;=\\; 2^{9} \\cdot 2^{12} \\;=\\; 2^{21} \\text{ 字节} \\;=\\; 2 \\text{ MiB}.\n$$\n\n该进程分配了一个大小为 $S = 64 \\text{ MiB} = 64 \\times 2^{20} \\text{ 字节} = 2^{26} \\text{ 字节}$ 的单一连续区域。在叶级别所需的页面数量为\n$$\nn_{\\text{pages}} \\;=\\; \\frac{S}{P} \\;=\\; \\frac{2^{26}}{2^{12}} \\;=\\; 2^{14} \\;=\\; 16384.\n$$\n每个1级页表映射 $2 \\text{ MiB}$，即 $512$ 个页面。因此，所需的1级页表数量为\n$$\nn_{L1} \\;=\\; \\frac{n_{\\text{pages}}}{N} \\;=\\; \\frac{2^{14}}{2^{9}} \\;=\\; 2^{5} \\;=\\; 32.\n$$\n因为这个 $64$ MiB 的区域对齐到 $2$ MiB 边界，且其大小是 $2$ MiB 的整数倍，所以恰好需要 $32$ 个1级页表，没有任何部分填充的额外页表。\n\n现在考虑2级。每个2级页表有 $512$ 个条目，每个条目指向一个1级页表，因此一个2级页表最多可以覆盖\n$$\n512 \\times (2 \\text{ MiB}) \\;=\\; 1 \\text{ GiB}.\n$$\n根据假设，这个 $64$ MiB 的区域完全位于单个 $1$ GiB 的范围内。因此，\n$$\nn_{L2} \\;=\\; 1.\n$$\n\n考虑3级。每个3级页表有 $512$ 个条目，每个条目指向一个2级页表，因此一个3级页表最多可以覆盖 $512 \\text{ GiB}$。我们的区域位于单个 $512$ GiB 的范围内，所以所需的3级页表数量是\n$$\nn_{L3} \\;=\\; 1.\n$$\n\n在4级（顶层），根据假设，每个进程都有自己的顶层页表，因此\n$$\nn_{L4} \\;=\\; 1.\n$$\n\n因此，实例化的页表页面总数是各级别之和：\n$$\nn_{\\text{pt-pages}} \\;=\\; n_{L1} + n_{L2} + n_{L3} + n_{L4} \\;=\\; 32 + 1 + 1 + 1 \\;=\\; 35.\n$$\n\n每个页表占用一个大小为 $P = 4 \\text{ KiB}$ 的物理页面。因此，由页表引起的内存开销是\n$$\n\\text{overhead} \\;=\\; n_{\\text{pt-pages}} \\times 4 \\text{ KiB} \\;=\\; 35 \\times 4 \\text{ KiB} \\;=\\; 140 \\text{ KiB}.\n$$\n\n根据要求，我们将内存开销（以 KiB 为单位）和页表页面计数报告为一个行向量。因此，最终的数值对是\n$$\n\\big[140,\\, 35\\big].\n$$", "answer": "$$\\boxed{\\begin{pmatrix}140  35\\end{pmatrix}}$$", "id": "3668035"}, {"introduction": "理论概念最终要指导实践。内存访问模式对分页系统的性能有着决定性的影响，糟糕的访问模式可能导致“内存颠簸”（thrashing），即系统花费大量时间在页面换入换出上，而几乎没有做有效工作。本练习通过分析矩阵遍历的两种不同循环顺序，揭示了程序的局部性原理与分页性能的深刻联系。通过计算不同访问模式下的缺页次数，你将学会如何通过优化代码来适应底层内存管理机制，从而获得数量级的性能提升。[@problem_id:3668050]", "problem": "考虑一个操作系统中的采用请求分页技术的两级存储系统。一个维度为 $M \\times N$ 的矩阵 $A$ 以行主序存储在单个连续的虚拟地址范围内。每个元素占用 $E$ 字节。系统使用的页面大小为 $P$ 字节，并维护 $F$ 个物理页帧。页面置换策略为最近最少使用（LRU）。中央处理器（CPU）的缓存行大小为 $L$ 字节。假设如下：\n- 所有页帧初始为空，并且只有访问 $A$ 的数据页才会导致缺页中断。\n- 在页面级别上，没有预取和预读。\n- 一旦一个页面驻留在一个帧中，除非它被换出，否则对该页面的后续访问不会导致缺页中断。\n- 忽略转译后备缓冲器（TLB）效应和页面级别以下的任何缓存未命中；只计算操作系统的缺页中断。\n- 程序执行以下两种嵌套循环遍历 $A$ 的方式之一，每种方式都恰好访问每个元素一次：\n  1. 行主序友好顺序：外层循环 $i$ 从 $0$ 到 $M-1$，内层循环 $j$ 从 $0$ 到 $N-1$，访问 $A[i][j]$。\n  2. 列主序：外层循环 $j$ 从 $0$ 到 $N-1$，内层循环 $i$ 从 $0$ 到 $M-1$，访问 $A[i][j]$。\n\n从分页、虚拟到物理页面映射以及行主序矩阵的地址映射等基本定义出发。运用这些原理，推导每种遍历方式下所访问的虚拟页号序列，以及在LRU策略下这些页面的重用距离。然后，在以下具体参数下，计算每种遍历方式的总缺页中断次数，以及将循环从列主序交换为行主序所带来的减少量：\n- $M = 1500$，$N = 1024$，$E = 8$ 字节，$P = 4096$ 字节，$F = 512$ 帧，以及 $L = 64$ 字节。\n\n将你的最终答案表示为一个整数，该整数等于将循环从列主序顺序交换为行主序友好顺序所实现的缺页中断减少量。无需四舍五入。在最终的方框答案中只写明该整数（不带单位）。", "solution": "我们从核心定义开始：\n\n- 在请求分页中，虚拟内存被划分为大小为 $P$ 字节的固定大小页面，这些页面被映射到物理页帧。当进程引用一个当前不在任何物理帧中的虚拟页面时，就会发生缺页中断。\n- 在最近最少使用（LRU）置换策略下，当没有空闲帧时，如果发生新的缺页中断，最近一次访问时间最久远的页面将被换出。\n- 一个大小为 $M \\times N$、元素大小为 $E$ 字节的行主序矩阵，其元素 $A[i][j]$ 存储在线性索引 $k = iN + j$ 处，虚拟字节地址为 $a(i,j) = a_{0} + E(iN + j)$，其中 $a_{0}$ 是 $A$ 的基地址。\n- 访问 $A[i][j]$ 所触及的虚拟页号为 $v(i,j) = \\left\\lfloor \\dfrac{a(i,j)}{P} \\right\\rfloor = \\left\\lfloor \\dfrac{a_{0}}{P} + \\dfrac{E(iN + j)}{P} \\right\\rfloor$。由于只有 $v(i,j)$ 的差异是重要的，我们可以忽略常数项 $\\left\\lfloor \\dfrac{a_{0}}{P} \\right\\rfloor$，专注于 $\\left\\lfloor \\dfrac{E(iN + j)}{P} \\right\\rfloor$。\n\n我们将针对每种遍历顺序计算缺页中断次数，假设初始时驻留帧集合为空，并使用LRU策略跟踪重用模式，具体参数如下：\n- $M = 1500$，$N = 1024$，$E = 8$，$P = 4096$，$F = 512$，$L = 64$。\n\n请注意，在所述假设下，CPU缓存行大小 $L$ 不会改变缺页中断的计数，因为缺页中断发生在页面粒度 $P$ 上。一旦一个页面存在于内存中，页内空间局部性（即使分布在多个大小为 $L$ 的缓存行中）也不会引发额外的缺页中断。我们仍然明确保留 $L$ 是为了强调在此模型中，子页面级别的局部性不影响缺页中断计数。\n\n步骤1：计算 $A$ 的总大小和不同页面的总数。\n\n$A$ 的总字节数为\n$$\nB = M N E = 1500 \\times 1024 \\times 8 = 12{,}288{,}000.\n$$\n$A$ 占用的不同虚拟页面总数为\n$$\nT = \\left\\lceil \\frac{B}{P} \\right\\rceil = \\left\\lceil \\frac{12{,}288{,}000}{4096} \\right\\rceil = \\left\\lceil 3000 \\right\\rceil = 3000.\n$$\n因为 $A$ 占用一个连续的虚拟区域，并且行主序友好遍历基本上是按连续顺序扫描该区域，所以在该遍历中，这 $T$ 个页面中的每一个都将被精确访问一次，并且之后不会再被重用。\n\n步骤2：行主序友好顺序（外层 $i$，内层 $j$）的缺页中断。\n\n在行主序友好遍历中，内层循环增加 $j$，因此对于固定的 $i$，$A[i][j]$ 会访问连续的地址 $a(i,j) = a_{0} + E(iN + j)$。在整个遍历过程中，地址流在连续的数组中单调递增。\n\n关键结论：由于没有虚拟页面被重新访问（对连续区域的单调扫描），缺页中断的次数等于被访问的 $A$ 的不同页面的数量，这与 $F$ 或置换策略无关。即，\n$$\n\\text{PF}_{\\text{row}} = T = 3000.\n$$\n\n步骤3：列主序（外层 $j$，内层 $i$）下每行的页面结构及重用机会。\n\n首先，确定每行 $N$ 个元素跨越多少个页面。每页的元素数量为\n$$\n\\alpha = \\frac{P}{E} = \\frac{4096}{8} = 512 \\text{ 个元素/页}.\n$$\n因此，每行长度为 $N = 1024$ 个元素占用\n$$\nq = \\left\\lceil \\frac{N}{\\alpha} \\right\\rceil = \\left\\lceil \\frac{1024}{512} \\right\\rceil = 2 \\text{ 个页面}.\n$$\n对于固定的列 $j$，当 $i$ 增加 1 时，线性索引增加 $N$，所以字节步长为\n$$\nS = E N = 8 \\times 1024 = 8192 \\text{ 字节} = 2P.\n$$\n因此，在单列内部，连续的访问恰好跳跃 2 个页面；对于 $i=0,1,2,\\dots$，虚拟页号序列 $v(i,j)$ 每次严格增加 2（不考虑由 $j$ 决定的基准偏移量）。因此，在单列 $j$ 内部，没有虚拟页面被重新访问；该列中的每次访问都会触及一个新的虚拟页面。\n\n然而，在跨列访问时，存在潜在的重用：对于 $0 \\leq j \\leq 511$，元素 $A[i][j]$ 位于第 $i$ 行的 2 个页面中的第一个页面；而对于 $512 \\leq j \\leq 1023$，它位于第 $i$ 行的第二个页面。因此，对于前半部分的所有列（$j \\in [0,511]$），对第 $i$ 行的访问总是针对该行的同一个页面（其第一个页面）；类似地，对于后半部分（$j \\in [512,1023]$），访问针对的是该行的第二个页面。\n\n因此，如果系统能够在连续的列访问之间，将与当前半部分对应的所有 $M$ 个页面（每行一个页面）保留在物理内存中，那么前半部分将在列 $j=0$ 时产生 $M$ 次初始缺页中断，然后在列 $j=1,\\dots,511$ 时产生零次中断；后半部分类似地将在 $j=512$ 时产生 $M$ 次初始缺页中断，之后则为零次。总计，列主序遍历的最佳情况下的缺页中断次数为 $2M$。\n\n步骤4：在 $F = 512$ 帧和 LRU 策略下列主序的缺页中断。\n\n我们现在考虑在LRU策略下，在列之间保留这 $M$ 个页面的可行性。在遍历列 $j$ 期间，内层循环访问 $M$ 个不同的页面（每行一个），并且在列内部不重新访问任何页面。在列 $j$ 结束时，根据LRU策略，近期使用顺序是这样的：最近使用的页面对应于最大的 $i$ 值。当移动到列 $j+1$ 并在 $i=0$ 处重新开始内层循环时，对第 $i=0$ 行的访问试图重用大约在 $M$ 次页面引用之前最后被引用的页面。为了在该重用上避免缺页中断，帧的数量 $F$ 需要至少为 $M$，这样当前半部分的 $M$ 个不同行页面才不会被换出。如果 $F  M$，那么在一列遍历结束时，这些页面中至少有 $M - F$ 个已经被换出，特别是最早访问的那些（最小的 $i$）将不再驻留内存。因此，在下一列开始时，对 $i=0$ 的页面访问将发生缺页中断，对 $i=1$ 也是如此，以此类推。事实上，当 $F \\ll M$ 时，每一列中的每一次访问都会导致缺页中断，因为重用距离约为 $M$ 并且超出了可用的帧数量，导致完全的颠簸。\n\n给定 $F = 512$ 和 $M = 1500$，我们有 $F  M$。因此，在列主序下：\n- 在每列 $j$ 内部， $M$ 次访问中的每一次都在该列中首次触及一个不同的页面，因此每次访问都会导致缺页中断。\n- 在跨列访问时，由于在LRU策略下 $F  M$，没有重用被捕获，因此每次访问都会继续导致缺页中断。\n\n因此，列主序的总缺页中断次数为\n$$\n\\text{PF}_{\\text{col}} = M N = 1500 \\times 1024 = 1{,}536{,}000.\n$$\n\n步骤5：通过从列主序到行主序的循环交换所带来的缺页中断减少量。\n\n减少量为\n$$\n\\Delta = \\text{PF}_{\\text{col}} - \\text{PF}_{\\text{row}} = 1{,}536{,}000 - 3000 = 1{,}533{,}000.\n$$\n\n步骤6：解释 $P$ 和 $L$ 的作用以及循环交换何时有帮助的条件。\n\n- 页面大小 $P$ 决定了 $\\alpha = P/E$，从而决定了每行的页面数 $q = \\lceil N / \\alpha \\rceil$。在我们的参数中，$q = 2$，这意味着当有足够多的帧时，最优的列主序缺页中断计数为 $qM = 2M$，这与连续扫描的行主序计数 $\\lceil M N E / P \\rceil = qM$ 相匹配。\n- 缓存行大小 $L$ 影响处理器缓存行为，但在给定假设下不影响操作系统的缺页中断次数。因此 $L$ 不会进入缺页中断的计算中。\n- 一般来说，对于行主序存储的矩阵，在LRU策略下列主序遍历时，当 $F  M$ 时，交换循环会减少缺页中断，因为每半列的工作集为 $M$ 个页面且无法被保留；当 $F \\geq M$ 时，列主序遍历可以捕获每半部分内的列间重用，产生 $qM$ 次缺页中断，与行主序的计数相等。\n\n对于所要求的具体数值参数，确切的减少量就是上面计算出的整数。", "answer": "$$\\boxed{1533000}$$", "id": "3668050"}]}