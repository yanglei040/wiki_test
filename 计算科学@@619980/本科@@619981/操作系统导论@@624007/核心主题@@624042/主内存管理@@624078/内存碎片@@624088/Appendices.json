{"hands_on_practices": [{"introduction": "伙伴系统（buddy system）是一种高效的内存分配策略，它通过将内存块限制为 $2$ 的幂次方大小来简化管理和合并。然而，这种便利性是有代价的：当请求的大小不是 $2$ 的幂时，向上取整会浪费一部分内存，这被称为内部碎片。通过本练习，你将为一个具体的请求序列计算这种浪费，从而直观地理解内部碎片的来源和量化方法。", "problem": "一个计算机系统在随机存取存储器（RAM）的单个区域内使用连续内存分配。分配器是一个伙伴系统，它强制使用2的幂次大小的块，并将一个较大的连续区域分割成较小的2的幂次大小的块。最小可分配块为一KiB（kibibyte）。在伙伴系统下，对于一个大小为 $s$ 的块的请求，会通过将 $s$ 向上取整到大于或等于 $s$ 的最小的2的幂次方来满足，然后连续地分配一个这样的块。\n\n考虑一个初始空闲的、大小为 $512$ KiB（kibibytes）的连续区域。一个进程按顺序发出四个分配请求，每个请求都需要一个连续的块：$62$ KiB、$90$ KiB、$35$ KiB 和 $10$ KiB。在具有理想可变大小分割的连续内存分配下，每个请求将通过精确划分出所请求的大小来满足，从而产生零内部碎片。在伙伴系统下，每个请求在分配前都被向上取整到最小的2的幂次方块大小。\n\n仅使用连续内存分配、内部碎片和伙伴系统的2的幂次方取整规则的核心定义，确定由伙伴分配器相对于理想连续分割基线所引起的内部碎片浪费。将浪费分数定义为超额分配的字节数除以请求的字节数，并计算此分配模式下其精确值。将最终答案表示为不带单位的分数。", "solution": "问题要求计算在一个伙伴系统下，相对于理想分配方案，一系列内存分配请求的内部碎片浪费分数。解决方案需要分步分析伙伴系统如何为每个请求提供服务，并计算由此产生的碎片。\n\n首先，让我们将给定的信息和定义形式化。\n内存请求序列的大小分别为 $s_1 = 62$ KiB、$s_2 = 90$ KiB、$s_3 = 35$ KiB 和 $s_4 = 10$ KiB。\n总请求大小，记为 $S_{req}$，是各个请求大小的总和：\n$$S_{req} = s_1 + s_2 + s_3 + s_4$$\n\n在伙伴系统下，大小为 $s$ 的请求通过分配一个大小为 $a$ 的块来满足，其中 $a$ 是满足 $a \\ge s$ 的最小的2的幂。数学上，这可以表示为 $a = 2^{\\lceil \\log_2(s) \\rceil}$。最小可分配块大小为 $1$ KiB，即 $2^0$ KiB，这与2的幂次方规则一致。\n\n问题定义了“理想可变大小分割”基线，其中分配的大小恰好是请求的大小。对于这个基线，总分配内存将等于 $S_{req}$，因此内部碎片为零。\n\n单次分配的内部碎片是分配大小与请求大小之间的差值，即 $a - s$。总内部碎片，或总“超额分配字节数”（$I$），是每个请求的碎片之和。\n$$I = \\sum_{i=1}^{4} (a_i - s_i) = \\left(\\sum_{i=1}^{4} a_i\\right) - \\left(\\sum_{i=1}^{4} s_i\\right) = S_{alloc} - S_{req}$$\n其中 $S_{alloc}$ 是伙伴系统分配的总大小。\n\n“浪费分数” $F_w$ 定义为超额分配的字节数除以请求的字节数：\n$$F_w = \\frac{I}{S_{req}} = \\frac{S_{alloc} - S_{req}}{S_{req}}$$\n\n现在，我们进行计算。\n\n步骤1：计算总请求内存大小 $S_{req}$。\n$$S_{req} = 62 + 90 + 35 + 10 = 197 \\text{ KiB}$$\n\n步骤2：根据伙伴系统的2的幂次方取整规则，为每个请求 $s_i$ 计算分配的大小 $a_i$。\n- 对于第一个请求 $s_1 = 62$ KiB：\n2的幂次方有 $..., 32, 64, 128, ...$。大于或等于 $62$ 的最小的2的幂是 $64$。所以，$a_1 = 64$ KiB。这对应于 $2^6$。\n\n- 对于第二个请求 $s_2 = 90$ KiB：\n大于或等于 $90$ 的最小的2的幂是 $128$。所以，$a_2 = 128$ KiB。这对应于 $2^7$。\n\n- 对于第三个请求 $s_3 = 35$ KiB：\n大于或等于 $35$ 的最小的2的幂是 $64$。所以，$a_3 = 64$ KiB。这对应于 $2^6$。\n\n- 对于第四个请求 $s_4 = 10$ KiB：\n大于或等于 $10$ 的最小的2的幂是 $16$。所以，$a_4 = 16$ KiB。这对应于 $2^4$。\n\n步骤3：计算总分配内存大小 $S_{alloc}$。\n$$S_{alloc} = a_1 + a_2 + a_3 + a_4 = 64 + 128 + 64 + 16 = 272 \\text{ KiB}$$\n注意，总分配大小（$272$ KiB）小于初始空闲区域（$512$ KiB），因此所有分配都成功。\n\n步骤4：计算总超额分配字节数（内部碎片）$I$。\n$$I = S_{alloc} - S_{req} = 272 - 197 = 75 \\text{ KiB}$$\n\n步骤5：计算浪费分数 $F_w$。\n$$F_w = \\frac{I}{S_{req}} = \\frac{75}{197}$$\n\n为确保分数是最简形式，我们找出分子和分母的质因数。\n分子是 $75 = 3 \\times 25 = 3 \\times 5^2$。\n对于分母 $197$，我们检查它是否能被小的质数整除。\n- $197$ 不能被 $2$ 整除（它是奇数）。\n- 数字之和是 $1+9+7 = 17$，不能被 $3$ 整除。\n- 它不以 $0$ 或 $5$ 结尾，所以不能被 $5$ 整除。\n- 我们继续检查直到 $\\sqrt{197} \\approx 14$ 的质数：$7, 11, 13$。\n  - $197 \\div 7 = 28$ 余 $1$。\n  - $197 \\div 11 = 17$ 余 $10$。\n  - $197 \\div 13 = 15$ 余 $2$。\n因为 $197$ 不能被任何小于或等于其平方根的质数整除，所以 $197$ 是一个质数。\n因此，分数 $\\frac{75}{197}$ 是不可约分的。", "answer": "$$\\boxed{\\frac{75}{197}}$$", "id": "3628282"}, {"introduction": "单个请求序列的分析很有用，但要评估一个内存分配器的通用性能，我们需要考虑它在成千上万次不同请求下的平均表现。这需要引入概率模型来描述请求大小的分布。在本练习中，你将为一种采用 $2$ 的幂次方大小分箱的“分离式空闲链表”分配器，计算其在特定请求分布下的期望内部碎片率，从而掌握一种更通用的性能分析方法。", "problem": "一个操作系统内存分配器使用分离式空闲链表（SFL），其中空闲块被组织成大小为2的幂的桶。具体来说，可用的块大小为 $2^{0}, 2^{1}, 2^{2}, \\dots, 2^{m}$ 字节，其中 $m$ 是一个固定的正整数。对于一个大小为 $s$ 字节的请求，其中 $1 \\leq s \\leq 2^{m}$，分配器会选择满足 $b(s) \\geq s$ 的最小块大小 $b(s)$。假设每个块的元数据和对齐开销都可以忽略不计。\n\n从内部碎片率的核心定义（即分配给请求的块内部未被使用的部分所占的比例）出发，将内部碎片率表示为 $s$ 和 $b(s)$ 的函数，然后在以下工作负载模型下计算其期望值：请求大小在 $[1, 2^{m}]$ 上连续分布，其概率密度函数为\n$$\nf(s) = \\frac{1}{s \\, m \\, \\ln 2} \\quad \\text{for } 1 \\leq s \\leq 2^{m},\n$$\n这是在 $[1, 2^{m}]$ 上归一化的对数均匀分布。\n\n推导出期望内部碎片率的、以自然对数表示的单一封闭形式解析表达式。将你的最终答案表示为精确表达式；不要进行四舍五入。", "solution": "第一步是表示内部碎片率。内部碎片是已分配块中未使用的空间。对于一个大小为 $s$ 的内存请求，分配的块大小为 $b(s)$。因此，未使用的空间量为 $b(s) - s$。问题将内部碎片率定义为已分配块中未使用部分所占的比例。记该比率为 $I(s)$。\n\n$$\nI(s) = \\frac{\\text{Unused Space}}{\\text{Allocated Block Size}} = \\frac{b(s) - s}{b(s)} = 1 - \\frac{s}{b(s)}\n$$\n\n接下来，我们必须确定函数 $b(s)$。内存分配器使用的块大小是2的幂：$2^0, 2^1, \\dots, 2^m$。对于大小为 $s$ 的请求，分配器会选择满足 $b(s) \\geq s$ 的最小块大小 $b(s)$。该策略意味着，如果请求大小 $s$ 落在区间 $(2^{k-1}, 2^k]$ 内，则分配的块大小为 $b(s) = 2^k$。这对 $k = 1, 2, \\dots, m$ 成立。对于 $s=1=2^0$ 的特殊情况，分配的块是 $b(1)=2^0=1$。\n\n问题要求计算内部碎片率的期望值 $E[I(s)]$，其中请求大小 $s$ 是一个具有给定概率密度函数（PDF）$f(s)$ 的随机变量。期望值由以下积分定义：\n$$\nE[I(s)] = \\int_{1}^{2^m} I(s) f(s) \\, ds\n$$\n代入 $I(s)$ 和 $f(s)$ 的表达式：\n$$\nE[I(s)] = \\int_{1}^{2^m} \\left(1 - \\frac{s}{b(s)}\\right) \\frac{1}{s \\, m \\, \\ln 2} \\, ds\n$$\n我们可以重写被积函数：\n$$\nE[I(s)] = \\frac{1}{m \\ln 2} \\int_{1}^{2^m} \\left(\\frac{1}{s} - \\frac{1}{b(s)}\\right) \\, ds\n$$\n由于 $b(s)$ 是一个在形如 $(2^{k-1}, 2^k]$ 的区间上为常数的阶梯函数，我们必须相应地划分积分域 $[1, 2^m]$。该域可以写成区间 $\\{1\\} \\cup \\bigcup_{k=1}^{m} (2^{k-1}, 2^k]$ 的并集。由于单点 $s=1$ 对积分的贡献为零，我们可以将积分表示为在这些区间上的求和：\n$$\nE[I(s)] = \\frac{1}{m \\ln 2} \\sum_{k=1}^{m} \\int_{2^{k-1}}^{2^k} \\left(\\frac{1}{s} - \\frac{1}{b(s)}\\right) \\, ds\n$$\n在每个积分区间 $(2^{k-1}, 2^k]$ 内，分配的块大小是恒定的：$b(s) = 2^k$。\n$$\nE[I(s)] = \\frac{1}{m \\ln 2} \\sum_{k=1}^{m} \\int_{2^{k-1}}^{2^k} \\left(\\frac{1}{s} - \\frac{1}{2^k}\\right) \\, ds\n$$\n让我们计算和式中单项的积分，该项对应于特定的整数 $k$（其中 $1 \\le k \\le m$）：\n$$\nJ_k = \\int_{2^{k-1}}^{2^k} \\left(\\frac{1}{s} - \\frac{1}{2^k}\\right) \\, ds\n$$\n该积分计算如下：\n$$\nJ_k = \\left[ \\ln(s) - \\frac{s}{2^k} \\right]_{s=2^{k-1}}^{s=2^k}\n$$\n在上限 $s=2^k$ 处求值：\n$$\n\\ln(2^k) - \\frac{2^k}{2^k} = k \\ln 2 - 1\n$$\n在下限 $s=2^{k-1}$ 处求值：\n$$\n\\ln(2^{k-1}) - \\frac{2^{k-1}}{2^k} = (k-1) \\ln 2 - \\frac{1}{2}\n$$\n用上限的求值结果减去下限的求值结果：\n$$\nJ_k = (k \\ln 2 - 1) - \\left((k-1) \\ln 2 - \\frac{1}{2}\\right) = k \\ln 2 - 1 - (k-1) \\ln 2 + \\frac{1}{2}\n$$\n$$\nJ_k = (k - (k-1))\\ln 2 - 1 + \\frac{1}{2} = \\ln 2 - \\frac{1}{2}\n$$\n值得注意的是，积分 $J_k$ 的值是一个与 $k$ 无关的常数。\n\n现在我们可以将此结果代回到期望值的表达式中：\n$$\nE[I(s)] = \\frac{1}{m \\ln 2} \\sum_{k=1}^{m} J_k = \\frac{1}{m \\ln 2} \\sum_{k=1}^{m} \\left(\\ln 2 - \\frac{1}{2}\\right)\n$$\n该和式由 $m$ 个相同的项组成：\n$$\n\\sum_{k=1}^{m} \\left(\\ln 2 - \\frac{1}{2}\\right) = m \\left(\\ln 2 - \\frac{1}{2}\\right)\n$$\n最后，我们得到期望内部碎片率：\n$$\nE[I(s)] = \\frac{1}{m \\ln 2} \\left[ m \\left(\\ln 2 - \\frac{1}{2}\\right) \\right] = \\frac{\\ln 2 - \\frac{1}{2}}{\\ln 2}\n$$\n这个表达式可以化简为：\n$$\nE[I(s)] = 1 - \\frac{1/2}{\\ln 2} = 1 - \\frac{1}{2 \\ln 2}\n$$\n这就是期望内部碎片率的最终封闭形式表达式，它与参数 $m$ 无关。", "answer": "$$\n\\boxed{1 - \\frac{1}{2 \\ln(2)}}\n$$", "id": "3657360"}, {"introduction": "内存浪费不仅存在于已分配的块“内部”，也存在于空闲块“外部”。当空闲内存被分割成许多不连续的小块时，即使总的空闲空间足够，也可能无法满足一个较大的内存请求，这就是外部碎片。本练习将引导你追踪一个经典的分配与释放序列，该序列会产生严重的外部碎片，帮助你理解其形成机制，并学会如何量化这种“可用但不可用”的内存浪费。", "problem": "一个系统为大小为 $M$ 的堆使用连续区域内存分配，模型中每个块的开销为零且没有对齐约束，因此大小为 $x$ 的分配恰好消耗 $x$ 个连续字节。使用 mebibytes (MiB) 作为内存大小的单位。外部碎片定义为在给定时间，总空闲内存中不包含在单一最大连续空闲块中的部分所占的比例 $f$。\n\n考虑在一个大小为 $M = 1024 \\, \\text{MiB}$ 的堆上执行以下操作序列：\n- 步骤 $1$：在最低可用地址处分配一个大小为 $H = 512 \\, \\text{MiB}$ 的大块。\n- 步骤 $2$：在大块上方的剩余空闲区域中，使用首次适应策略分配 $n = 192$ 个小块，每个小块大小为 $s = 2 \\, \\text{MiB}$，该策略精确分割空闲区域，并在空间允许的情况下将这些小块一个接一个地连续放置。\n- 步骤 $3$：释放所有偶数索引的小块（即按分配顺序编号为 $2, 4, 6, \\dots$ 的块），保留奇数索引的小块仍处于分配状态。这会在大块上方的区域产生交错的空闲和已分配的小块区域，并使第一个小块（与大块相邻）保持分配状态。\n- 步骤 $4$：释放大小为 $H$ 的大块。\n\n假设分配器不合并非相邻的空闲区域，并且由于这些特定的释放操作，步骤 $3$ 和 $4$ 中产生的任何空闲区域都不会变得相邻；特别是，由于第一个小块在步骤 $3$ 中保持分配状态，所以在步骤 $4$ 中通过释放 $H$ 创建的空闲区域不会与任何其他空闲区域相邻。在这些假设下，根据上述定义，计算步骤 $4$ 结束后立即产生的外部碎片比例 $f$。将最终答案表示为一个最简分数（无单位）。不要使用百分号。", "solution": "我们将通过指定的操作序列来追踪总大小为 $M = 1024 \\, \\text{MiB}$ 的堆的状态。\n\n最初，整个堆是一个大小为 $1024 \\, \\text{MiB}$ 的单一空闲块。\n\n**步骤 1：** 在最低地址处分配一个大小为 $H = 512 \\, \\text{MiB}$ 的块。\n- 已分配内存：$[0, 512)$。该块的大小为 $512 \\, \\text{MiB}$。\n- 空闲内存：一个位于 $[512, 1024)$ 的单一块。该空闲块的大小为 $1024 - 512 = 512 \\, \\text{MiB}$。\n\n**步骤 2：**\n在大小为 $512 \\, \\text{MiB}$ 的剩余空闲区域中，连续分配 $n = 192$ 个小块，每个小块的大小为 $s = 2 \\, \\text{MiB}$。\n- 已分配小块的总大小：$S_{alloc} = n \\times s = 192 \\times 2 = 384 \\, \\text{MiB}$。\n- 这些块从地址 $512$ 开始放置。它们占据了区域 $[512, 512 + 384) = [512, 896)$。\n- 此步骤后，内存布局如下：\n    - 已分配的块 $H$：$[0, 512)$，大小 $512 \\, \\text{MiB}$。\n    - $192$ 个已分配的小块：$[512, 896)$，总大小 $384 \\, \\text{MiB}$。\n    - 一个剩余的单一空闲块：$[896, 1024)$，大小 $1024 - 896 = 128 \\, \\text{MiB}$。\n\n**步骤 3：**\n释放每个偶数索引的小块。小块的索引为 $1, 2, 3, \\dots, 192$。我们释放块 $2, 4, \\dots, 192$。\n- 释放的块数为 $\\frac{192}{2} = 96$。\n- 仍保持分配状态的块数也是 $\\frac{192}{2} = 96$。这些是奇数索引的块 $1, 3, \\dots, 191$。\n- 这会创建 $96$ 个新的空闲块，每个大小为 $s = 2 \\, \\text{MiB}$。\n- 已分配的奇数索引块和新释放的偶数索引块在区域 $[512, 896)$ 中交错排列。例如，块 $1$（已分配）位于 $[512, 514)$，释放块 $2$ 会在 $[514, 516)$ 处创建一个空闲区域，块 $3$（已分配）位于 $[516, 518)$，以此类推。\n- 此处，分配器不合并非相邻空闲区域的假设至关重要。这 $96$ 个大小为 $2 \\, \\text{MiB}$ 的空闲块彼此之间以及与大小为 $128 \\, \\text{MiB}$ 的最终空闲块都保持独立。\n\n**步骤 4：**\n释放堆起始处大小为 $H = 512 \\, \\text{MiB}$ 的大块。\n- 这会在 $[0, 512)$ 处创建一个大小为 $512 \\, \\text{MiB}$ 的新空闲块。\n- 问题明确指出，这个新的空闲区域不会与任何其他空闲区域相邻，因为第一个小块（块 $1$，位于 $[512, 514)$）仍然处于分配状态。\n\n现在，我们根据最终的内存状态计算外部碎片比例 $f$。\n首先，我们确定所有空闲块及其大小：\n1.  一个来自释放 $H$ 的空闲块：大小 $512 \\, \\text{MiB}$。\n2.  $96$ 个来自释放偶数索引小块的空闲块：每个大小为 $2 \\, \\text{MiB}$。\n3.  一个小块分配后的剩余空闲块：大小 $128 \\, \\text{MiB}$。\n\n空闲内存总量 $F_{total}$ 是所有空闲块大小的总和：\n$$F_{total} = 512 + (96 \\times 2) + 128$$\n$$F_{total} = 512 + 192 + 128 = 832 \\, \\text{MiB}$$\n\n另外，总分配内存由 $96$ 个奇数索引的小块组成：\n$A_{total} = 96 \\times 2 = 192 \\, \\text{MiB}$。\n总空闲内存必须为 $M - A_{total} = 1024 - 192 = 832 \\, \\text{MiB}$。计算结果一致。\n\n接下来，我们确定单一最大连续空闲块的大小 $L$。通过比较空闲块的大小（$512$、$128$ 和 $2$），我们发现：\n$$L = 512 \\, \\text{MiB}$$\n\n外部碎片比例 $f$ 定义为总空闲内存中不在最大空闲块内的部分所占的比例。\n$$f = \\frac{F_{total} - L}{F_{total}}$$\n代入计算出的值：\n$$f = \\frac{832 - 512}{832} = \\frac{320}{832}$$\n\n为了简化这个分数，我们求出分子和分母的最大公约数。\n$320 = 32 \\times 10 = (2^5) \\times (2 \\times 5) = 2^6 \\times 5 = 64 \\times 5$.\n$832 = 13 \\times 64$.\n因此：\n$$f = \\frac{64 \\times 5}{64 \\times 13} = \\frac{5}{13}$$\n外部碎片比例为 $\\frac{5}{13}$。", "answer": "$$\\boxed{\\frac{5}{13}}$$", "id": "3657357"}]}