{"hands_on_practices": [{"introduction": "为了真正理解动态加载，我们必须超越理论，亲手对其行为进行建模。第一个实践练习聚焦于程序生命周期的最初阶段：动态加载器读取可执行文件并准备执行的过程。我们将通过一个计算模型，探讨加载器如何利用符号表来解析依赖关系，以及“剥离”（stripping）二进制文件等优化选择如何影响加载过程和后续的调试能力 [@problem_id:3637126]。这个练习有助于厘清可执行文件中哪些信息对运行至关重要，哪些信息主要用于调试。", "problem": "您需要从第一性原理出发，对移除一个类可执行与可链接格式（ELF）二进制文件的非动态符号表如何影响动态加载器行为和调试能力进行建模，并将该模型实现为一个完整、可运行的程序。您应从以下基本前提开始：(i) 动态加载器使用动态符号表来解析外部引用，(ii) 重定位处理的通用概念，包括延迟绑定或立即绑定，以及 (iii) 在将程序载入内存时，加载器不会读取未映射到可加载段的节区。\n\n从以下核心定义和事实开始。一个二进制文件包含一个通用符号表（通常命名为 .symtab）和一个动态符号表（通常命名为 .dynsym）。动态加载器仅使用动态符号表来解析外部引用。通用符号表由静态链接器和调试器使用，而不是动态加载器。对于重定位处理，如果启用了延迟绑定，函数调用重定位会通过过程链接表和全局偏移表延迟到首次调用时处理；而立即绑定则在加载时解析所有重定位。加载器只会将标记为可加载的段读入内存；通用符号表等不可加载的节区不属于加载器从磁盘读取的内容。调试能力受到符号名称和展开元数据的存在与否的影响：如果没有通用符号表，通常只有导出的动态符号名称可见；如果没有展开信息，可靠的堆栈回溯将受到限制。\n\n您的程序必须不接受任何输入，并且必须通过纯粹基于这些基本原理实现以下概念，来为下面描述的固定测试套件计算结果：\n\n- 存在标志：设 $S \\in \\{0,1\\}$ 表示通用符号表是否存在，$D \\in \\{0,1\\}$ 表示动态符号表是否存在，$L \\in \\{0,1\\}$ 表示延迟绑定 ($L=1$) 或立即绑定 ($L=0$)，$U \\in \\{0,1\\}$ 表示展开信息是否存在。\n- 加载器要完成的工作：设 $T \\in \\mathbb{Z}_{\\ge 0}$ 为需要符号解析的重定位总数，设 $F \\in \\mathbb{Z}_{\\ge 0}$ 为其中在延迟绑定下将被推迟的函数调用重定位的子集。假设在有效配置中 $F \\le T$。\n- 加载时的 I/O：设 $B \\in \\mathbb{Z}_{\\ge 0}$ 为程序启动时加载器从磁盘读取的可加载段的总字节数，以字节为单位。设 $Y \\in \\mathbb{Z}_{\\ge 0}$ 为通用符号表的字节大小。\n- 加载器成功标准：考虑如果存在需要解析的重定位（$T>0$）但动态符号表缺失（$D=0$），则动态加载无法成功进行。\n\n基于这些，实现一个模型，为每个测试用例计算以下输出：\n\n1) $load\\_success \\in \\{0,1\\}$，指示加载器在程序启动时是否成功。\n2) $relocations\\_at\\_load \\in \\mathbb{Z}_{\\ge 0}$，在成功的情况下，加载器在加载时解析的重定位数量，是 $T$、$F$ 和 $L$ 的函数。\n3) $io\\_bytes \\in \\mathbb{Z}_{\\ge 0}$，加载时从磁盘读取的字节数，等于可加载段的大小（以字节为单位）。\n4) $debug\\_score \\in \\{0,1,2,3\\}$，一个综合分数，其中符号名称覆盖范围和展开能力以加法方式贡献：如果 $S=1$，名称覆盖贡献 $2$；如果 $S=0$ 且 $D=1$，贡献 $1$；如果 $S=0$ 且 $D=0$，贡献 $0$。如果 $U=1$，展开能力贡献 $1$；如果 $U=0$，贡献 $0$。该分数为这两部分之和。\n5) $loader\\_uses\\_dynsym \\in \\{0,1\\}$，指示加载器在程序启动期间是否使用动态符号表，这当且仅当动态加载成功进行且至少有一个重定位需要在加载时或之后解析时发生。\n6) $error\\_code \\in \\{0,1,2\\}$，其解释如下：$0$ 表示没有错误；$1$ 表示 $T>0$ 且 $D=0$，因此动态解析不可能；$2$ 表示无效输入，例如 $F>T$，或 $T, F, B, Y$ 中存在任何负数，或任何标志不属于 $\\{0,1\\}$。\n\n边界行为要求：\n\n- 如果 $error\\_code = 2$，报告 $load\\_success = 0$、$relocations\\_at\\_load = 0$ 和 $loader\\_uses\\_dynsym = 0$，但仍需报告 $io\\_bytes = B$ 并根据 $S$、$D$ 和 $U$ 计算 $debug\\_score$。\n- 如果 $T=0$，则加载时不需要动态解析；在这种情况下，无论 $D$ 为何值，$load\\_success = 1$ 且 $relocations\\_at\\_load = 0$。\n- 如果启用了延迟绑定 ($L=1$) 且输入有效且 $load\\_success = 1$，则在加载时解析的重定位不包括 $F$ 个函数调用重定位，因此只有非函数重定位在加载时被解析。如果启用了立即绑定 ($L=0$)，则在成功时所有 $T$ 个重定位都在加载时被解析。\n\n请注意，移除通用符号表但保留动态符号表的剥离操作对应于 $S=0$ 和 $D=1$；与 $S=1$ 相比，这些操作不应改变加载器成功率、$io\\_bytes$ 或加载时的重定位计数，但应降低 $debug\\_score$。\n\n待评估的测试套件参数：\n\n- 案例 A（已剥离，延迟绑定，有展开信息）：$S=0$, $D=1$, $L=1$, $U=1$, $T=120$, $F=40$, $B=1000000$, $Y=200000$。\n- 案例 B（未剥离基线，延迟绑定，有展开信息）：$S=1$, $D=1$, $L=1$, $U=1$, $T=120$, $F=40$, $B=1000000$, $Y=200000$。\n- 案例 C（已剥离，立即绑定，无展开信息）：$S=0$, $D=1$, $L=0$, $U=0$, $T=50$, $F=50$, $B=409600$, $Y=150000$。\n- 案例 D（无效：函数调用重定位超过总数）：$S=0$, $D=1$, $L=1$, $U=1$, $T=10$, $F=15$, $B=123456$, $Y=654321$。\n- 案例 E（缺少动态符号表但存在重定位）：$S=1$, $D=0$, $L=1$, $U=1$, $T=80$, $F=20$, $B=777000$, $Y=300000$。\n- 案例 F（完全没有重定位）：$S=0$, $D=0$, $L=1$, $U=0$, $T=0$, $F=0$, $B=2048$, $Y=32000$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含所有案例的结果，形式为一个逗号分隔的列表，列表中的每个元素也是一个案例的结果，并用方括号括起来。每个案例的结果本身必须是一个用方括号括起的、逗号分隔的列表，顺序必须为 $[load\\_success,relocations\\_at\\_load,io\\_bytes,debug\\_score,loader\\_uses\\_dynsym,error\\_code]$。例如：$[[a\\_1,b\\_1,c\\_1,d\\_1,e\\_1,f\\_1],[a\\_2,b\\_2,c\\_2,d\\_2,e\\_2,f\\_2],\\dots]$。所有值都必须是整数，其中 $io\\_bytes$ 以字节表示。", "solution": "问题陈述经过仔细验证，并被确定为有效。它在科学上基于操作系统加载器和链接器的原理，问题定义清晰，目标明确，没有任何主观或矛盾的陈述。我现在将进行正式的解答。\n\n该问题要求我们基于一组基本原理和输入参数，构建一个动态加载器行为的计算模型。我们必须为给定的测试套件计算六个输出指标。该模型的逻辑从第一性原理推导如下。\n\n设给定二进制文件的输入参数为一个元组 $(S, D, L, U, T, F, B, Y)$，其中：\n- $S \\in \\{0,1\\}$：通用符号表（`.symtab`）是否存在。\n- $D \\in \\{0,1\\}$：动态符号表（`.dynsym`）是否存在。\n- $L \\in \\{0,1\\}$：使用延迟绑定（$L=1$）还是立即绑定（$L=0$）。\n- $U \\in \\{0,1\\}$：展开信息是否存在。\n- $T \\in \\mathbb{Z}_{\\ge 0}$：重定位总数。\n- $F \\in \\mathbb{Z}_{\\ge 0}$：符合延迟绑定条件的函数调用重定位数量。\n- $B \\in \\mathbb{Z}_{\\ge 0}$：可加载段的大小（以字节为单位）。\n- $Y \\in \\mathbb{Z}_{\\ge 0}$：通用符号表的大小（以字节为单位）。\n\n我们需要计算以下六个输出：$load\\_success$、$relocations\\_at\\_load$、$io\\_bytes$、$debug\\_score$、$loader\\_uses\\_dynsym$ 和 $error\\_code$。每个输出的推导过程如下。\n\n**1. 错误代码 ($error\\_code \\in \\{0,1,2\\}$)**\n\n$error\\_code$ 标识了场景的有效性和可执行性。\n- $error\\_code$ 为 $2$ 表示无效输入参数。这在任何标志不为 $\\{0,1\\}$、任何计数/大小为负数、或函数重定位数 $F$ 超过总重定位数 $T$ 时发生。\n$$ error\\_code = 2 \\iff (S,D,L,U \\notin \\{0,1\\}) \\lor (T0 \\lor F0 \\lor B0 \\lor Y0) \\lor (F > T) $$\n- $error\\_code$ 为 $1$ 表示加载时因缺少先决条件而失败。动态加载器需要动态符号表（`.dynsym`，由 $D=1$ 表示）来解析任何重定位（$T  0$）。如果需要重定位但该表缺失，则加载失败。\n$$ error\\_code = 1 \\iff (T > 0 \\land D = 0) \\land (\\text{inputs are valid}) $$\n- $error\\_code$ 为 $0$ 表示配置有效且加载器可以继续执行。\n$$ error\\_code = 0 \\iff (\\text{not error code 1 or 2}) $$\n\n**2. 加载时 I/O ($io\\_bytes \\in \\mathbb{Z}_{\\ge 0}$)**\n\n动态加载器只将二进制文件的可加载段从磁盘读入内存。这些段的总大小由 $B$ 给出。大小为 $Y$ 的通用符号表通常不在可加载段中，因此不会被加载器读取。因此，加载时的 I/O 与其他因素无关，始终等于 $B$。\n$$ io\\_bytes = B $$\n\n**3. 可调试性分数 ($debug\\_score \\in \\{0,1,2,3\\}$)**\n\n调试分数是基于符号可用性和展开信息的综合指标。\n- 符号名称覆盖：完整的调试符号位于通用符号表（`.symtab`，$S=1$）中，贡献分数为 $2$。如果 `.symtab` 被剥离（$S=0$）但动态符号表（`.dynsym`，$D=1$）仍然存在，则可用的符号信息有限（仅限导出符号），贡献分数为 $1$。如果两者都缺失（$S=0, D=0$），则没有符号信息，贡献分数为 $0$。\n$$ \\text{score}_{\\text{name}} = \\begin{cases} 2  \\text{if } S=1 \\\\ 1  \\text{if } S=0 \\land D=1 \\\\ 0  \\text{if } S=0 \\land D=0 \\end{cases} $$\n- 展开能力：展开信息（$U=1$）的存在对于可靠的堆栈回溯至关重要，贡献分数为 $1$。其缺失（$U=0$）贡献分数为 $0$。\n$$ \\text{score}_{\\text{unwind}} = U $$\n总分是两项之和：\n$$ debug\\_score = \\text{score}_{\\text{name}} + \\text{score}_{\\text{unwind}} $$\n此分数在计算时与 $error\\_code$ 无关。\n\n**4. 加载器成功率 ($load\\_success \\in \\{0,1\\}$)**\n\n加载器当且仅当场景有效且可执行时才会成功，这对应于 $error\\_code$ 为 $0$。任何其他错误代码都表示失败条件。\n$$ load\\_success = \\begin{cases} 1  \\text{if } error\\_code = 0 \\\\ 0  \\text{if } error\\_code \\in \\{1, 2\\} \\end{cases} $$\n\n**5. 加载时解析的重定位数量 ($relocations\\_at\\_load \\in \\mathbb{Z}_{\\ge 0}$)**\n\n该指标仅在成功加载时才有意义。如果加载失败，加载器最终不会解析任何重定位。\n- 如果 $load\\_success = 0$，则 $relocations\\_at\\_load = 0$。\n- 如果 $load\\_success = 1$：\n    - 使用立即绑定（$L=0$）时，加载器在程序启动时解析所有 $T$ 个重定位。\n    - 使用延迟绑定（$L=1$）时，加载器在程序启动时解析所有非函数数据重定位（$T-F$），并推迟 $F$ 个函数重定位。\n$$ relocations\\_at\\_load = \\begin{cases} 0  \\text{if } load\\_success = 0 \\\\ T-F  \\text{if } load\\_success = 1 \\land L=1 \\\\ T  \\text{if } load\\_success = 1 \\land L=0 \\end{cases} $$\n请注意，这与 $T=0$ 的边界条件一致，此时 $F$ 也必须为 $0$，从而得出 $relocations\\_at\\_load=0$。\n\n**6. 加载器对动态符号表的使用情况 ($loader\\_uses\\_dynsym \\in \\{0,1\\}$)**\n\n加载器当且仅当加载成功进行且存在任何需要在加载时或之后解析的重定位时，才会查阅动态符号表（`.dynsym`）。重定位的总数为 $T$。\n$$ loader\\_uses\\_dynsym = \\begin{cases} 1  \\text{if } load\\_success = 1 \\land T  0 \\\\ 0  \\text{otherwise} \\end{cases} $$\n\n这些派生出的规则构成了待实现的完整模型。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include", "id": "3637126"}, {"introduction": "程序加载后便开始运行，而“延迟绑定”（lazy binding）是一种常见的性能优化，它将函数地址的解析推迟到首次调用时才进行。本实践将构建一个仿真模型，以探索这种优化的利弊，特别是当所需库文件在程序启动后、函数首次调用前被移除时可能出现的有趣失效模式 [@problem_id:3637179]。通过这个练习，你将对动态链接中的时间动态性及稳健性考量获得具体的理解。", "problem": "在一个简化的、形式化指定的设置中，您需要对动态链接器在延迟绑定（lazy binding）下的行为进行建模和仿真。目标是评估当提供符号的共享库文件在程序启动和符号解析之间被移除时，程序对导入符号的调用是否会崩溃。您将编写一个程序，仅使用所提供的形式化模型，在明确定义的策略和事件顺序下模拟此行为。\n\n定义和模型：\n- 时间是离散的，步长为 $t \\in \\mathbb{Z}_{\\ge 0}$。\n- 一个主可执行文件从一个共享库中精确导入一个符号。\n- 库文件的存在由一个谓词 $P(t) \\in \\{0,1\\}$ 建模，其中 $P(t) = 1$ 当且仅当库文件在时间 $t$ 存在。\n- 每个场景都指定一个移除时间 $t_r \\in \\mathbb{Z} \\cup \\{-1\\}$，具体如下：如果 $t_r = -1$，则对于所有 $t \\ge 0$，$P(t) = 1$；如果 $t_r \\ge 0$，则对于所有 $t  t_r$，$P(t) = 1$，对于所有 $t \\ge t_r$，$P(t) = 0$。移除操作（如果发生）在一个时间步的开始时处理。\n- 动态链接器的行为由一个策略 $\\pi \\in \\{\\text{LAZY}, \\text{EAGER}\\}$ 参数化。\n- 存在两个内部状态位：\n  1. $M(t) \\in \\{0,1\\}$ 表示提供库是否在时间 $t$ 前已被映射到进程地址空间。\n  2. $C(t) \\in \\{0,1\\}$ 表示调用点是否在时间 $t$ 前已缓存解析后的符号地址。\n- 策略语义：\n  - 在 $\\text{LAZY}$ 策略下：$M(0) = 0$ 且 $C(0) = 0$。\n  - 在 $\\text{EAGER}$ 策略下：加载器在程序启动时、在任何移除操作之前映射库，因此 $M(0) = 1$ 且 $C(0) = 0$。\n- 每个时间步 $t$ 的事件顺序：\n  1. 如果 $t = t_r \\ge 0$，首先处理移除操作，将 $P(t)$ 设置为 $0$。\n  2. 然后处理在时间 $t$ 安排的任何调用。\n- 时间 $t$ 的调用处理规则：\n  - 如果 $M(t) = 0$：\n    - 如果 $P(t) = 0$，调用立即崩溃（$M$ 或 $C$ 不发生变化）。\n    - 如果 $P(t) = 1$，加载器映射库并解析符号，设置 $M(t^{+}) = 1$ 和 $C(t^{+}) = 1$，调用成功。\n  - 如果 $M(t) = 1$，调用成功，我们设置 $C(t^{+}) = 1$。\n- 持久性：一旦 $M(t)$ 变为 $1$，它将此后保持为 $1$；一旦 $C(t)$ 变为 $1$，它将此后保持为 $1$。\n\n您的仿真的输入：\n- 一个有限的测试场景序列，每个场景由以下内容定义：\n  - 一个策略 $\\pi \\in \\{\\text{LAZY}, \\text{EAGER}\\}$。\n  - 一个移除时间 $t_r \\in \\mathbb{Z} \\cup \\{-1\\}$。\n  - 一个非递减的有限调用时间列表 $\\langle t_1, t_2, \\dots, t_k \\rangle$，其中每个 $t_i \\in \\mathbb{Z}_{\\ge 0}$ 是对导入符号的调用时间，必须使用上述规则进行模拟。\n\n要求的输出：\n- 对于每个场景中按发生顺序排列的每个调用事件，输出一个整数 $x \\in \\{0,1\\}$，其中如果该调用在模型下崩溃，则 $x = 1$，如果成功，则 $x = 0$。\n- 将所有场景的输出汇总成单行，格式为用方括号括起来的逗号分隔列表，例如 $[x_1,x_2,\\dots,x_N]$。\n\n要实现和评估的测试套件：\n- 测试 $1$（在第一次调用前移除库时，延迟绑定下的第一次调用失败）：\n  - 策略 $\\pi = \\text{LAZY}$，移除时间 $t_r = 1$，调用 $\\langle 2 \\rangle$。\n- 测试 $2$（移除和第一次调用发生在同一时间步的边界条件：首先处理移除）：\n  - 策略 $\\pi = \\text{LAZY}$，移除时间 $t_r = 3$，调用 $\\langle 3 \\rangle$。\n- 测试 $3$（即时映射下的鲁棒性：在第一次调用前移除不会导致崩溃）：\n  - 策略 $\\pi = \\text{EAGER}$，移除时间 $t_r = 1$，调用 $\\langle 2 \\rangle$。\n- 测试 $4$（缓存鲁棒性：移除前的第一次调用解析并映射，移除后的后续调用仍然成功）：\n  - 策略 $\\pi = \\text{LAZY}$，移除时间 $t_r = 2$，调用 $\\langle 0, 3 \\rangle$。\n- 测试 $5$（理想路径：无移除，延迟绑定在第一次调用时解析）：\n  - 策略 $\\pi = \\text{LAZY}$，移除时间 $t_r = -1$，调用 $\\langle 0 \\rangle$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[x_1,x_2,\\dots,x_N]$）。每个结果的单位是 $\\{0,1\\}$ 中的一个纯数字。", "solution": "该问题已经过验证，被认为是定义明确、科学严谨且客观的。它提出了一个动态链接器行为的形式化、确定性模型，可以通过仿真为每个指定场景得出唯一的结果。我们现在将根据提供的规则分析每个测试用例，从而进行求解。\n\n每个测试场景的系统状态由元组 $(M(t), C(t), P(t))$ 描述，其中 $M(t) \\in \\{0,1\\}$ 是库的内存映射状态，$C(t) \\in \\{0,1\\}$ 是符号地址的缓存状态，而 $P(t) \\in \\{0,1\\}$ 是库文件在磁盘上的存在状态。该状态的演变由策略 $\\pi \\in \\{\\text{LAZY}, \\text{EAGER}\\}$、移除时间 $t_r \\in \\mathbb{Z} \\cup \\{-1\\}$ 以及调用时间序列 $\\langle t_i \\rangle$ 决定。\n\n**测试 1 分析**\n*   **参数**：策略 $\\pi = \\text{LAZY}$，移除时间 $t_r = 1$，调用于 $\\langle 2 \\rangle$。\n*   **初始状态 ($t=0$)**：在 $\\text{LAZY}$ 策略下，库在程序启动时未被映射。因此，$M(0) = 0$ 且 $C(0) = 0$。\n*   **环境**：移除时间为 $t_r = 1$。库存在谓词为：对于 $t  1$，$P(t) = 1$；对于 $t \\ge 1$，$P(t) = 0$。\n*   **在 $t=2$ 时的调用**：\n    1.  我们在 $t=2$ 时调用处理开始时评估状态。由于在 $t=0$ 和 $t=2$ 之间没有发生任何会改变状态的事件，因此 $M(2) = M(0) = 0$。\n    2.  此时库的存在状态为 $P(2) = 0$，因为 $2 \\ge t_r$。\n    3.  我们应用 $M(t)=0$ 情况下的调用处理规则。该规则规定，如果 $P(t)=0$，调用会崩溃。\n*   **结果**：在 $t=2$ 时的调用崩溃。输出为 $1$。\n\n**测试 2 分析**\n*   **参数**：策略 $\\pi = \\text{LAZY}$，移除时间 $t_r = 3$，调用于 $\\langle 3 \\rangle$。\n*   **初始状态 ($t=0$)**：$\\pi = \\text{LAZY}$，所以 $M(0) = 0$ 且 $C(0) = 0$。\n*   **环境**：$t_r = 3$，所以对于 $t  3$，$P(t) = 1$；对于 $t \\ge 3$，$P(t) = 0$。\n*   **在 $t=3$ 时的调用**：\n    1.  在给定的时间步 $t$ 中，事件顺序是明确定义的：移除操作在调用之前处理。在 $t=3$ 时，由于 $t=t_r$，首先处理移除操作，将 $P(3)$ 设置为 $0$。\n    2.  移除之后，处理在 $t=3$ 时的调用。状态 $M(3)$ 仍为 $0$，因为之前没有发生过成功的解析。\n    3.  我们应用 $M(3)=0$ 的调用处理规则。因为 $P(3)=0$，调用崩溃。\n*   **结果**：在 $t=3$ 时的调用崩溃。输出为 $1$。\n\n**测试 3 分析**\n*   **参数**：策略 $\\pi = \\text{EAGER}$，移除时间 $t_r = 1$，调用于 $\\langle 2 \\rangle$。\n*   **初始状态 ($t=0$)**：在 $\\text{EAGER}$ 策略下，库在程序启动时即被映射。因此，$M(0) = 1$ 且 $C(0) = 0$。\n*   **环境**：$t_r = 1$，所以对于 $t  1$，$P(t) = 1$；对于 $t \\ge 1$，$P(t) = 0$。\n*   **在 $t=2$ 时的调用**：\n    1.  我们评估在 $t=2$ 时的状态。状态位 $M$ 是持久的；一旦 $M=1$，它将保持为 $1$。所以，$M(2) = M(0) = 1$。\n    2.  我们应用 $M(t)=1$ 情况下的调用处理规则。该规则规定调用成功。文件是否存在，$P(2)=0$，是无关紧要的，因为库已经位于进程的地址空间中。该调用还确保了缓存被填充，因此 $C(2^{+})=1$。\n*   **结果**：在 $t=2$ 时的调用成功。输出为 $0$。\n\n**测试 4 分析**\n*   **参数**：策略 $\\pi = \\text{LAZY}$，移除时间 $t_r = 2$，调用于 $\\langle 0, 3 \\rangle$。\n*   **初始状态 ($t=0$)**：$\\pi = \\text{LAZY}$，所以 $M(0) = 0$ 且 $C(0) = 0$。\n*   **环境**：$t_r = 2$，所以对于 $t  2$，$P(t) = 1$；对于 $t \\ge 2$，$P(t) = 0$。\n*   **在 $t=0$ 时的第一次调用**：\n    1.  调用开始时的状态为 $M(0)=0$。\n    2.  库的存在状态为 $P(0)=1$，因为 $0  t_r$。\n    3.  我们应用 $M(t)=0$ 且 $P(t)=1$ 时的规则。调用成功，状态更新为 $M(0^{+})=1$ 和 $C(0^{+})=1$。\n*   **第一次调用的结果**：在 $t=0$ 时的调用成功。输出为 $0$。\n*   **在 $t=3$ 时的第二次调用**：\n    1.  我们评估在 $t=3$ 时的状态。根据持久性规则以及在 $t=0$ 时的成功调用，状态为 $M(3)=1$。在 $t=2$ 时的移除事件将 $t \\ge 2$ 的 $P(t)$ 设置为 $0$，因此 $P(3)=0$。\n    2.  我们应用 $M(3)=1$ 情况下的调用处理规则。调用成功。$P(3)$ 的值无关紧要。\n*   **第二次调用的结果**：在 $t=3$ 时的调用成功。输出为 $0$。\n*   **组合结果**：此测试用例的输出序列为 $(0, 0)$。\n\n**测试 5 分析**\n*   **参数**：策略 $\\pi = \\text{LAZY}$，移除时间 $t_r = -1$，调用于 $\\langle 0 \\rangle$。\n*   **初始状态 ($t=0$)**：$\\pi = \\text{LAZY}$，所以 $M(0) = 0$ 且 $C(0) = 0$。\n*   **环境**：$t_r = -1$，意味着库永远不会被移除。对于所有 $t \\ge 0$，$P(t)=1$。\n*   **在 $t=0$ 时的调用**：\n    1.  调用开始时的状态为 $M(0)=0$。\n    2.  库的存在状态为 $P(0)=1$。\n    3.  我们应用 $M(t)=0$ 且 $P(t)=1$ 时的规则。调用成功，状态更新为 $M(0^{+})=1$ 和 $C(0^{+})=1$。\n*   **结果**：在 $t=0$ 时的调用成功。输出为 $0$。\n\n**最终汇总结果**\n按指定顺序整理每个测试的结果：\n- 测试 1：$1$\n- 测试 2：$1$\n- 测试 3：$0$\n- 测试 4：$0, 0$\n- 测试 5：$0$\n最终的输出序列为 $\\langle 1, 1, 0, 0, 0, 0 \\rangle$。", "answer": "```c\n#include", "id": "3637179"}, {"introduction": "动态链接程序的生命周期还包括资源的释放。最后一个实践模拟了使用类似于 `dlclose` 的机制卸载共享库的过程。我们将实现一个引用计数系统，以理解为何一个库在收到卸载请求后可能不会立即从内存中移除，从而揭示延迟卸载（deferred unmap）的概念以及防止悬挂指针导致程序崩溃的安全原则 [@problem_id:3637167]。这对于构建稳定、模块化的应用程序至关重要。", "problem": "考虑一个简化的、纯逻辑的操作系统 (OS) 动态加载和卸载模型。其目标是捕捉以下原理：卸载动态加载模块的请求（例如，通过一个类似于 POSIX (Portable Operating System Interface) 函数 $dlclose$ 的函数）在模块仍被引用的情况下，不会回收其代码页，并演示延迟卸载映射行为。你必须构建一个程序来模拟一组模块、它们的句柄引用计数、临时执行引用以及其代码页的映射和回收。\n\n使用的基本依据和定义：\n1. 如果一个模块至少有一个句柄引用或至少一个临时执行引用，它就被认为是驻留的（已映射）。句柄代表显式的动态加载器引用（例如，来自 $dlopen$），而临时引用代表瞬时联系，如活动函数指针或在模块代码内执行的线程。\n2. 设模块集由 $i \\in \\{0,\\dots,N-1\\}$ 索引。对每个模块 $i$，定义：\n   - $P_i$：模块占用的代码页数。\n   - $h_i$：句柄引用计数。\n   - $e_i$：临时执行引用计数。\n   - $m_i \\in \\{0,1\\}$：映射状态，其中 $m_i=1$ 表示模块当前已映射（驻留），$m_i=0$ 表示未映射。\n   - $d_i \\in \\{0,1\\}$：一个延迟卸载映射标志，当卸载请求发生但临时引用仍然存在 ($e_i0$) 时设置。\n3. 模拟过程处理每个模块的一系列事件：\n   - $L_i$：获取模块 $i$ 的句柄；$h_i \\leftarrow h_i + 1$，如果 $m_i=0$ 则 $m_i \\leftarrow 1$（发生映射）。\n   - $C_i$：如果 $h_i0$，释放模块 $i$ 的句柄（一个卸载请求）；$h_i \\leftarrow h_i - 1$。如果递减后 $h_i=0$ 且 $e_i0$，则设置 $d_i \\leftarrow 1$（延迟卸载映射）。如果 $h_i=0$ 且 $e_i=0$，则立即卸载映射。\n   - $A_i$：获取模块 $i$ 的临时引用；$e_i \\leftarrow e_i + 1$，如果 $m_i=0$ 则 $m_i \\leftarrow 1$（发生映射）。\n   - $R_i$：如果 $e_i0$，释放模块 $i$ 的临时引用；$e_i \\leftarrow e_i - 1$。如果此时 $h_i=0$ 且 $e_i=0$ 且 $m_i=1$，则立即卸载映射，并消耗掉任何延迟的卸载映射请求。\n4. 卸载映射规则和回收：每当 $m_i=1$、$h_i=0$ 和 $e_i=0$ 时，模块的代码页被回收，并且 $m_i \\leftarrow 0, d_i \\leftarrow 0$。一个测试的总回收页数是所有卸载映射事件中回收的 $P_i$ 之和。最终驻留页数为 $\\sum_i m_i \\cdot P_i$。\n\n你的程序必须为提供的测试套件确定性地实现这个模型，并生成单行输出，汇总所有测试用例的结果。每个测试用例的结果必须是一个包含两个整数 $[R,F]$ 的列表，其中 $R$ 是整个事件序列中回收的总页数，$F$ 是所有事件之后最终的驻留页数。\n\n测试套件：\n- 测试用例 1（演示延迟卸载映射的正常路径）：\n  - 模块：$N=1$。\n  - 初始状态：$P_0=5$, $h_0=1$, $e_0=1$, $m_0=1$（根据定义，因为 $h_00$ 或 $e_00$）。\n  - 事件：$C_0$, $R_0$。\n  - 解释：卸载尝试 $C_0$ 无法回收页面，因为 $e_00$；回收发生在 $R_0$ 之后，当两个引用都为 $0$ 时。\n- 测试用例 2（多个句柄，当两个计数都达到零时立即卸载映射）：\n  - 模块：$N=1$。\n  - 初始状态：$P_0=3$, $h_0=2$, $e_0=0$, $m_0=1$。\n  - 事件：$C_0$, $C_0$。\n  - 解释：只有在第二次关闭后，$h_0$ 才达到 $0$ 且 $e_0=0$，因此页面被立即回收。\n- 测试用例 3（两个模块，混合立即和延迟卸载映射）：\n  - 模块：$N=2$。\n  - 初始状态：模块 $0$ 具有 $P_0=4$, $h_0=1$, $e_0=0$, $m_0=1$；模块 $1$ 具有 $P_1=2$, $h_1=1$, $e_1=1$, $m_1=1$。\n  - 事件：$C_0$, $C_1$, $R_1$。\n  - 解释：模块 $0$ 在 $C_0$ 上立即回收。模块 $1$ 在 $C_1$ 上延迟，并仅在 $R_1$ 上回收。\n- 测试用例 4（边界情况：在零句柄时发出卸载请求，然后通过句柄映射，并因临时引用而延迟）：\n  - 模块：$N=1$。\n  - 初始状态：$P_0=7$, $h_0=0$, $e_0=0$, $m_0=0$。\n  - 事件：$C_0$, $L_0$, $A_0$, $C_0$, $R_0$。\n  - 解释：初始的 $C_0$ 是一个无操作（no-op），因为 $h_0=0$。$L_0$ 映射该模块。$A_0$ 添加一个临时引用。$C_0$ 延迟卸载映射，而 $R_0$ 触发回收。\n- 测试用例 5（结尾时驻留：额外的句柄阻止了卸载映射）：\n  - 模块：$N=1$。\n  - 初始状态：$P_0=9$, $h_0=1$, $e_0=0$, $m_0=1$。\n  - 事件：$L_0$, $C_0$。\n  - 解释：净句柄计数保持为 $h_0=1$，因此模块保持映射状态，没有页面被回收。\n\n你的程序应生成单行输出，其中包含用方括号括起来的、逗号分隔的结果列表，每个测试用例按顺序产生其 $[R,F]$ 列表。例如，输出格式必须与 $[[r_1,f_1],[r_2,f_2],\\dots]$ 完全一样，其中包含整数。不涉及物理单位或角度单位，也不需要百分比。程序没有输入；所有参数都作为与上述测试套件匹配的常量嵌入在程序中。", "solution": "我们从动态加载、引用计数和内存映射行为的基本定义开始。在动态加载环境中，一个模块的驻留状态（其代码页是否被映射）取决于是否存在未完成的引用。显式的动态加载器句柄（例如来自 POSIX (Portable Operating System Interface) 中的 $dlopen$）被计入一个句柄引用计数中，而瞬时执行联系如活动栈帧或函数指针则被捕获为临时执行引用。从操作系统的角度来看，只有当没有代码路径或句柄引用模块时，回收内存页才是安全的。这引出了引用计数和安全回收的原则。\n\n我们用以下参数对每个模块 $i$ 进行建模：\n- $P_i$：其代码占用的页数。\n- $h_i$：句柄计数。\n- $e_i$：临时引用计数。\n- $m_i \\in \\{0,1\\}$：映射状态，初始时如果 $h_i0$ 或 $e_i0$ 则推断为 $m_i=1$，否则为 $m_i=0$。\n- $d_i \\in \\{0,1\\}$：延迟卸载映射标志，记录在 $e_i0$ 时发生过卸载尝试。\n\n我们将事件和状态转换形式化：\n1. 对于 $L_i$ 事件，我们设置 $h_i \\leftarrow h_i+1$，并且如果 $m_i=0$，则 $m_i \\leftarrow 1$，因为获取句柄意味着需要映射模块。\n2. 对于 $C_i$ 事件，如果 $h_i0$，我们设置 $h_i \\leftarrow h_i-1$。如果递减后 $h_i=0$ 且 $e_i0$ 且 $m_i=1$，我们设置 $d_i \\leftarrow 1$ 来记录一个延迟卸载映射条件。如果递减后 $h_i=0$ 且 $e_i=0$ 且 $m_i=1$，我们立即卸载映射：\n   - 回收 $\\Delta R = P_i$ 页，\n   - 设置 $m_i \\leftarrow 0$ 和 $d_i \\leftarrow 0$。\n3. 对于 $A_i$ 事件，我们设置 $e_i \\leftarrow e_i+1$，并且如果 $m_i=0$，则设置 $m_i \\leftarrow 1$，因为临时执行引用意味着模块必须是驻留的。\n4. 对于 $R_i$ 事件，如果 $e_i0$，我们设置 $e_i \\leftarrow e_i-1$。如果递减后 $h_i=0$ 且 $e_i=0$ 且 $m_i=1$，我们立即卸载映射：\n   - 回收 $\\Delta R = P_i$ 页，\n   - 设置 $m_i \\leftarrow 0$ 和 $d_i \\leftarrow 0$。\n\n我们在每个事件后实现一个统一的卸载映射检查：\n- 如果 $m_i=1$ 且 $h_i=0$ 且 $e_i=0$，则回收 $P_i$，设置 $m_i \\leftarrow 0$ 和 $d_i \\leftarrow 0$。这既体现了立即卸载映射，也实现了延迟卸载映射条件，并确保当两类引用同时达到零时，每个模块的回收恰好发生一次。\n\n正确性和不变量：\n- 安全性不变量：一个模块只有在 $h_i=0$ 且 $e_i=0$ 时才能被卸载映射。这反映了操作系统在引用仍然存在时不回收任何代码页的约束。\n- 活性不变量：如果一个卸载请求使得 $h_i=0$ 但临时引用仍然存在 ($e_i0$)，那么卸载映射将被延迟；之后，当 $e_i$ 达到 $0$ 时，延迟条件被解决，页面被回收。$d_i$ 标志在诊断上很有帮助，但如果我们总是在每个事件后检查卸载映射条件，那么它对于正确性来说并非严格必需。\n- 记账不变量：一个测试用例的总回收页数 $R$ 等于序列中发生的所有卸载映射事件回收的 $P_i$ 之和。最终驻留页数 $F$ 是在处理完所有事件后计算得出的 $\\sum_i m_i \\cdot P_i$。\n\n我们现在应用测试套件中的事件序列：\n- 测试用例 1：从 $P_0=5, h_0=1, e_0=1, m_0=1$ 开始。事件 $C_0$ 将 $h_0$ 设置为 $0$，而此时 $e_0=1$，延迟卸载映射 ($d_0=1$)。事件 $R_0$ 将 $e_0$ 设置为 $0$，并且由于 $h_0=0, e_0=0, m_0=1$，我们卸载映射并回收 $5$ 页；最终驻留页数为 $0$。\n- 测试用例 2：从 $P_0=3, h_0=2, e_0=0, m_0=1$ 开始。事件 $C_0$ 将 $h_0$ 设置为 $1$，不卸载映射。事件 $C_0$ 将 $h_0$ 设置为 $0$ 且 $e_0=0$，而此时 $m_0=1$，所以我们卸载映射并回收 $3$ 页；最终驻留页数为 $0$。\n- 测试用例 3：模块 $0$ 具有 $P_0=4, h_0=1, e_0=0, m_0=1$；模块 $1$ 具有 $P_1=2, h_1=1, e_1=1, m_1=1$。事件 $C_0$ 将 $h_0$ 设置为 $0$ 且 $e_0=0$，而此时 $m_0=1$，因此我们立即回收 $4$ 页。事件 $C_1$ 将 $h_1$ 设置为 $0$，而此时 $e_1=1$，延迟卸载映射。事件 $R_1$ 将 $e_1$ 设置为 $0$ 并触发卸载映射，回收 $2$ 页；最终驻留页数为 $0$。\n- 测试用例 4：从 $P_0=7, h_0=0, e_0=0, m_0=0$ 开始。事件 $C_0$ 是一个无操作，因为 $h_0=0$。事件 $L_0$ 将 $h_0$ 设置为 $1$ 并进行映射 ($m_0=1$)。事件 $A_0$ 将 $e_0$ 设置为 $1$。事件 $C_0$ 将 $h_0$ 设置为 $0$，而此时 $e_0=1$，延迟卸载映射。事件 $R_0$ 将 $e_0$ 设置为 $0$ 并触发卸载映射，回收 $7$ 页；最终驻留页数为 $0$。\n- 测试用例 5：从 $P_0=9, h_0=1, e_0=0, m_0=1$ 开始。事件 $L_0$ 将 $h_0$ 设置为 $2$，事件 $C_0$ 将 $h_0$ 设置为 $1$。由于 $h_00$，模块保持映射状态，没有页面被回收；最终驻留页数为 $9$。\n\n因此，预期的输出是单行 $[[5,0],[3,0],[6,0],[7,0],[0,9]]$。该实现是完全自包含的，除了打印这最后一行外，不执行任何输入/输出，并遵循指定的格式。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include", "id": "3637167"}]}