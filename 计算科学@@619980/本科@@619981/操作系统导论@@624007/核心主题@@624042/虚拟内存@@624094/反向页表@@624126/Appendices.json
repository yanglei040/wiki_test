{"hands_on_practices": [{"introduction": "倒排页表的效率在很大程度上取决于其哈希函数的质量。一个设计不佳的哈希函数可能导致所有条目都映射到同一个桶中，从而使哈希表退化为低效的线性链表。本练习将引导您分析这种最坏情况，通过一个具体的假设场景，揭示不良哈希对系统性能的灾难性影响，并量化其查找成本。[@problem_id:3651073]", "problem": "一个系统实现了一个倒排页表（IPT），该页表为每个物理帧精确存储一个条目。查找虚拟地址时，使用基于哈希的索引来访问一个包含 $B$ 个桶的表，并通过分离链接法解决冲突。用于哈希的键是一个有序对 $\\left(PID, VPN\\right)$，其中 $PID$ 是进程标识符（Process Identifier, PID），$VPN$ 是虚拟页号（Virtual Page Number, VPN）。系统设计者错误地部署了一个劣质的哈希函数 $h\\left(PID, VPN\\right) = PID \\bmod B$。假设在某个瞬间有 $n$ 个被占用的 IPT 条目，其中不保证 $n \\leq B$，并且单个进程可能占用多个帧。假设没有诸如转换后备缓冲区（Translation Lookaside Buffer, TLB）之类的辅助加速结构；查找操作通过在每个节点上比较 $PID$ 和 $VPN$ 字段是否相等来遍历桶中的链。\n\n仅从倒排页表、分离链接法哈希和基于相等的键比较的定义出发，完成以下任务：\n\n- 推导一个关于已占用条目集合 $\\left\\{\\left(PID_{j}, VPN_{j}\\right)\\right\\}_{j=1}^{n}$ 和桶数量 $B$ 的充分必要条件，在该条件下，当使用哈希函数 $h\\left(PID, VPN\\right) = PID \\bmod B$ 时，所有 $n$ 个条目都会冲突到单个桶中。您的推导必须明确指出描述这种退化情况的精确谓词。\n- 在这种退化情况下，确定单次查找（无论是成功还是不成功）所执行的最坏情况下的键比较次数，作为 $n$ 的函数。\n\n仅提供最坏情况下比较次数的表达式作为您的最终答案，形式为封闭形式，无单位。如果您选择简化，请进行精确简化；不需要四舍五入。", "solution": "用户希望我解决提示中描述的问题。\n\n### 第 1 步：问题验证\n\n首先，我将根据指定标准验证问题陈述。\n\n#### 第 1.1 步：提取已知条件\n\n*   **系统架构**：一个倒排页表（IPT），每个物理帧有一个条目。\n*   **查找机制**：基于哈希的索引，访问一个包含 $B$ 个桶的表。\n*   **冲突解决方法**：分离链接法。\n*   **哈希键**：一个有序对 $(PID, VPN)$，其中 $PID$ 是进程标识符，$VPN$ 是虚拟页号。\n*   **哈希函数**：$h(PID, VPN) = PID \\bmod B$。\n*   **系统状态**：有 $n$ 个被占用的 IPT 条目。\n*   **条目集合**：被占用的条目集合表示为 $\\{(PID_j, VPN_j)\\}_{j=1}^{n}$。\n*   **约束条件**：不保证 $n \\leq B$。单个进程可能占用多个帧。\n*   **假设**：没有诸如转换后备缓冲区（TLB）之类的辅助加速结构。查找通过比较 $PID$ 和 $VPN$ 字段是否相等来遍历链。\n*   **目标**：\n    1.  推导所有 $n$ 个条目冲突到单个桶中的充分必要条件。\n    2.  在此条件下，确定单次查找的最坏情况下的键比较次数，作为 $n$ 的函数。\n\n#### 第 1.2 步：使用提取的已知条件进行验证\n\n*   **科学依据**：该问题基于操作系统和数据结构的基本概念，特别是虚拟内存管理（倒排页表）和哈希（使用分离链接法的哈希表）。设计不佳的哈希函数的场景是一个标准的教学示例，用于说明哈希函数质量的重要性。这些概念在科学和计算上都是合理的。\n*   **良构性**：该问题是良构的。它清楚地定义了系统、哈希函数和数据。它要求两个可以推导出的不同结果：一个逻辑条件和一个最坏情况下的复杂度分析。提供了所需的信息，可以确定一个唯一的、有意义的答案。\n*   **客观性**：该问题以精确、客观的语言陈述，没有歧义或主观声明。诸如“倒排页表”、“分离链接法”和“键比较”等术语在计算机科学中具有标准的、明确的含义。\n\n问题陈述没有违反任何无效性标准。这是一个来自计算机科学领域的、科学上合理、良构且客观的问题。\n\n#### 第 1.3 步：结论与行动\n\n该问题是**有效的**。我将继续进行解答。\n\n### 第 2 步：解答推导\n\n该问题有两个部分。首先，我们必须推导出最大冲突的条件，其次，我们必须在该条件下分析最坏情况的性能。\n\n#### 第 1 部分：退化的充分必要条件\n\n哈希表有 $B$ 个桶，索引从 $0$ 到 $B-1$。键为 $(PID, VPN)$ 的条目所在的桶由哈希函数 $h(PID, VPN)$ 的值确定。给定的哈希函数是 $h(PID, VPN) = PID \\bmod B$。值得注意的是，哈希值仅取决于 $PID$，而与 $VPN$ 无关。\n\n所有 $n$ 个被占用的条目（由集合 $\\{(PID_j, VPN_j)\\}_{j=1}^{n}$ 表示）冲突到单个桶中的充分必要条件是，它们都哈希到相同的桶索引。设这个公共桶索引为一个整数 $k$，其中 $0 \\leq k  B$。\n\n这个条件可以用数学方式表示为：\n$$h(PID_j, VPN_j) = k \\quad \\text{for all } j \\in \\{1, 2, \\dots, n\\}$$\n\n代入哈希函数的定义，我们得到：\n$$PID_j \\bmod B = k \\quad \\text{for all } j \\in \\{1, 2, \\dots, n\\}$$\n\n这个陈述意味着，来自被占用条目集合的每个进程标识符 $PID_j$ 在除以 $B$ 时都必须有相同的余数 $k$。这是模 $B$ 同余的定义。因此，对于集合中的任意两个 PID，比如说 $PID_i$ 和 $PID_j$，必须有 $PID_i \\bmod B = PID_j \\bmod B$。这等价于说所有 PID 都属于模 $B$ 的同一个同余类。\n\n因此，充分必要条件是：\n存在一个整数 $k \\in \\{0, 1, \\dots, B-1\\}$，使得对于所有被占用的条目 $(PID_j, VPN_j)$（其中 $j \\in \\{1, \\dots, n\\}$），进程标识符 $PID_j$ 都满足同余关系 $PID_j \\equiv k \\pmod{B}$。\n\n#### 第 2 部分：最坏情况下的键比较次数\n\n在上面推导出的退化条件下，所有 $n$ 个被占用的条目都存储在与一个桶（比如桶 $k$）相关联的单个链表（一个链）中。这个链的长度是 $n$。\n\n对目标键 $(PID_{target}, VPN_{target})$ 的查找过程如下：\n1.  计算桶索引：$i = h(PID_{target}, VPN_{target}) = PID_{target} \\bmod B$。\n2.  遍历桶 $i$ 处的链表。在列表中的每个节点，将存储的键 $(PID_{stored}, VPN_{stored})$ 与目标键 $(PID_{target}, VPN_{target})$ 进行比较。单次“键比较”涉及检查两个字段是否都相等：$(PID_{stored} = PID_{target}) \\land (VPN_{stored} = VPN_{target})$。\n\n我们需要找到这种比较的最坏情况次数。最坏情况可能发生在成功查找或不成功查找中。我们必须同时考虑这两种情况。\n\n**情况 A：成功查找**\n当目标键 $(PID_{target}, VPN_{target})$ 是链中 $n$ 个条目之一时，发生成功查找。在链表中搜索的最坏情况发生在目标元素是列表中的最后一个元素时。为了找到它，算法必须遍历所有前面的 $n-1$ 个节点，在每个节点上执行一次失败的比较，然后在第 $n$ 个节点上执行一次最终的、成功的比较。因此，键比较的总次数是 $n$。\n\n**情况 B：不成功查找**\n当目标键 $(PID_{target}, VPN_{target})$ 不在 IPT 中时，发生不成功查找。不成功查找的最坏情况发生在搜索被导向到最拥挤的桶时。为了让查找被导向到长度为 $n$ 的链，目标 PID 必须满足 $PID_{target} \\bmod B = k$。然后，算法将遍历整个长度为 $n$ 的链表，在 $n$ 个节点中的每一个上都执行一次键比较。由于键不存在，所有 $n$ 次比较都会失败。在检查完所有 $n$ 个条目并到达列表末尾后，搜索终止。执行的键比较总次数是 $n$。\n\n**结论**\n成功查找的最坏情况比较次数是 $n$。不成功查找的最坏情况比较次数也是 $n$。因此，在给定的退化条件下，任何单次查找（成功或不成功）的总体最坏情况键比较次数是这两个值的最大值，即 $n$。", "answer": "$$\\boxed{n}$$", "id": "3651073"}, {"introduction": "在理解了不良哈希的危害之后，我们现在来分析一个使用良好、均匀哈希函数的倒排页表的性能。本练习将经典的“球与箱”概率模型应用于倒排页表，让您推导出关键的性能指标，例如空桶的期望比例。通过这个过程，您将学会如何量化分析哈希表的负载，并为调整其大小以达到目标性能提供理论依据。[@problem_id:3651017]", "problem": "一个操作系统（OS）使用一种倒排页表（Inverted Page Table, IPT），该页表被组织成一个带链地址法的哈希表。该表有 $m$ 个桶，并且有 $n$ 个活动的页表条目。每个条目被均匀且独立地哈希到 $m$ 个桶中的一个。在桶中定位一个条目的时间与该桶中的条目数量成正比，因此桶的占用情况直接影响查找性能。\n\n从概率、指示器随机变量和期望的线性性的定义出发，推导空桶所占的确切期望分数，作为 $m$ 和 $n$ 的函数。然后，使用一个大系统近似，其中 $m$ 和 $n$ 很大，而负载因子 $\\alpha = n/m$ 保持不变，推导空桶期望分数的渐近形式。最后，假设系统旨在调整 $m$，使得空桶的期望分数等于一个目标值 $\\theta$（其中 $0  \\theta  1$）。使用渐近形式，推导出 $m$ 关于 $n$ 和 $\\theta$ 的闭式表达式。\n\n请以一个包含两个条目的行矩阵形式提供您的最终答案：第一个条目是空桶的确切期望分数（作为 $m$ 和 $n$ 的函数），第二个条目是 $m$ 关于 $n$ 和 $\\theta$ 的渐近表达式。不需要进行数值近似或四舍五入。", "solution": "该问题要求进行三个相关的推导，这些推导关乎倒排页表中条目的分布，该倒排页表被建模为带链地址法的哈希表。我们将按照要求，从第一性原理出发，依次解决每个部分。\n\n这个设置是概率论中一个经典的“球与箱”问题，其中 $n$ 个球（页表条目）被独立且均匀随机地投入 $m$ 个箱（桶）中。\n\n首先，我们推导空桶的确切期望分数。设 $X$ 是表示空桶总数的随机变量。我们想要找到期望分数，即 $\\frac{E[X]}{m}$。为了计算 $E[X]$，我们使用指示器随机变量的方法。\n\n对于 $i \\in \\{1, 2, \\dots, m\\}$，设 $X_i$ 是桶 $i$ 为空这一事件的指示器随机变量。根据定义：\n$$\nX_i =\n\\begin{cases}\n1  \\text{如果桶 } i \\text{ 为空} \\\\\n0  \\text{如果桶 } i \\text{ 不为空}\n\\end{cases}\n$$\n空桶的总数是这些指示器随机变量的和：\n$$X = \\sum_{i=1}^{m} X_i$$\n根据期望的线性性，空桶的期望数量是这些指示器随机变量的期望值的和：\n$$E[X] = E\\left[\\sum_{i=1}^{m} X_i\\right] = \\sum_{i=1}^{m} E[X_i]$$\n一个指示器随机变量的期望等于它所指示事件的概率。因此，$E[X_i] = P(\\text{桶 } i \\text{ 为空})$。\n\n我们来计算这个概率。考虑单个页表条目。由于哈希是均匀的，该条目被哈希到任何特定桶 $i$ 的概率是 $\\frac{1}{m}$。因此，该条目*不*被哈希到桶 $i$ 的概率是 $1 - \\frac{1}{m} = \\frac{m-1}{m}$。\n\n总共有 $n$ 个条目，它们的哈希位置是独立的。“桶 $i$ 为空”这一事件发生当且仅当 $n$ 个条目中没有一个被哈希到桶 $i$。这个复合事件的概率是每个条目各自概率的乘积：\n$$P(\\text{桶 } i \\text{ 为空}) = \\left(\\frac{m-1}{m}\\right) \\times \\left(\\frac{m-1}{m}\\right) \\times \\dots \\times \\left(\\frac{m-1}{m}\\right) \\quad (n \\text{ 次})$$\n$$P(\\text{桶 } i \\text{ 为空}) = \\left(\\frac{m-1}{m}\\right)^n = \\left(1 - \\frac{1}{m}\\right)^n$$\n所以，对于任何桶 $i$，我们有 $E[X_i] = \\left(1 - \\frac{1}{m}\\right)^n$。\n\n现在，我们可以求出空桶的期望总数：\n$$E[X] = \\sum_{i=1}^{m} \\left(1 - \\frac{1}{m}\\right)^n = m \\left(1 - \\frac{1}{m}\\right)^n$$\n空桶的期望分数是 $\\frac{E[X]}{m}$：\n$$\\text{期望分数} = \\frac{m \\left(1 - \\frac{1}{m}\\right)^n}{m} = \\left(1 - \\frac{1}{m}\\right)^n$$\n这是第一个要求的结果。\n\n其次，我们推导该分数在大系统极限下的渐近形式，其中 $m \\to \\infty$ 且 $n \\to \\infty$，使得负载因子 $\\alpha = \\frac{n}{m}$ 保持不变。我们将 $n = \\alpha m$ 代入分数的表达式中：\n$$\\left(1 - \\frac{1}{m}\\right)^n = \\left(1 - \\frac{1}{m}\\right)^{\\alpha m}$$\n我们计算当 $m \\to \\infty$ 时的极限：\n$$\\lim_{m \\to \\infty} \\left(1 - \\frac{1}{m}\\right)^{\\alpha m} = \\lim_{m \\to \\infty} \\left[ \\left(1 + \\frac{-1}{m}\\right)^m \\right]^{\\alpha}$$\n我们使用指数函数的基本极限定义，$\\lim_{x \\to \\infty} \\left(1 + \\frac{k}{x}\\right)^x = \\exp(k)$。这里，$x=m$ 且 $k=-1$。\n$$\\lim_{m \\to \\infty} \\left(1 + \\frac{-1}{m}\\right)^m = \\exp(-1)$$\n因此，该分数的渐近极限是：\n$$\\left[\\exp(-1)\\right]^{\\alpha} = \\exp(-\\alpha) = \\exp\\left(-\\frac{n}{m}\\right)$$\n空桶期望分数的渐近形式是 $\\exp\\left(-\\frac{n}{m}\\right)$。\n\n第三，我们使用这个渐近形式来推导 $m$ 关于 $n$ 和目标空桶期望分数 $\\theta$ 的表达式，其中 $0  \\theta  1$。我们将渐近分数设为等于 $\\theta$：\n$$\\exp\\left(-\\frac{n}{m}\\right) = \\theta$$\n为了求解 $m$，我们对两边取自然对数：\n$$\\ln\\left(\\exp\\left(-\\frac{n}{m}\\right)\\right) = \\ln(\\theta)$$\n$$-\\frac{n}{m} = \\ln(\\theta)$$\n由于 $0  \\theta  1$，其对数 $\\ln(\\theta)$ 是一个非零负数。我们现在可以求解 $m$：\n$$m = -\\frac{n}{\\ln(\\theta)}$$\n这也可以写成 $m = \\frac{n}{\\ln(1/\\theta)}$。该表达式是良定义的且为正，符合对桶数量的要求。这是第二个要求的结果。\n\n最终答案将是一个行矩阵，包含确切的期望分数和推导出的 $m$ 的表达式。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\left(1 - \\frac{1}{m}\\right)^n  -\\frac{n}{\\ln(\\theta)}\n\\end{pmatrix}\n}\n$$", "id": "3651017"}, {"introduction": "倒排页表的结构虽然高效地支持了从虚拟地址到物理地址的转换，但其逆向操作——即查找一个物理帧被哪些虚拟地址映射——却变得十分困难。然而，这项功能对于操作系统调试和内存管理至关重要。本练习将挑战您设计一个高效的辅助数据结构来解决这个实际问题，同时还需要考虑共享内存带来的复杂性。[@problem_id:3651074]", "problem": "一个操作系统使用倒排页表来实现请求分页。根据定义，一个倒排页表为每个物理帧仅设一个条目，因此其基数等于物理帧的数量，记为 $F$。对于 $0 \\le i  F$ 的每个索引 $i$ 处的条目，记录了当前映射到物理帧号（Physical Frame Number, PFN）为 $i$ 的物理帧的所有者元组（进程标识符 (PID)，虚拟页号 (VPN)）。在存在共享内存和内存映射文件的情况下，单个物理帧可能会被多个进程和多个虚拟页号别名（aliased）；设某个特定 PFN 的此类别名数量为 $k$，并设系统范围内的别名总数为 $A$。\n\n你需要设计一个调试工具，该工具在给定一个 PFN 的情况下，能够重建所有当前映射到该 PFN 的 $(\\text{PID}, \\text{VPN})$ 对。该工具必须支持一个查询操作，在给定一个 PFN 时，其定位别名容器的平均时间复杂度为 $O(1)$，枚举 $k$ 个对的输出敏感复杂度为 $O(k)$。系统支持标准数据结构，如数组、哈希表和链表。假设系统可以在不影响地址转换正确性的前提下，在倒排页表旁维护辅助元数据。设 $P$ 为进程数。\n\n哪种设计在存在共享帧的情况下能够达到所述的平均时间查询复杂度并保持正确性？并且，为了在页映射和取消映射事件下维护正确性，其相应的渐进空间和更新时间成本是多少？\n\nA. 维护一个反向索引：一个长度为 $F$ 的数组，由 PFN 索引，其中每个条目指向一个包含该 PFN 的 $(\\text{PID}, \\text{VPN})$ 别名的哈希集合容器。查询一个 PFN 时，以 $O(1)$ 的平均时间对数组进行索引，并返回一个可迭代的集合；枚举的时间复杂度为 $O(k)$。在映射和取消映射时，每次插入和删除别名的平均时间复杂度为 $O(1)$，总空间复杂度为 $O(F + A)$。\n\nB. 线性扫描倒排页表以定位所有引用给定 PFN 的条目，对于共享帧，则扫描每个进程的页表以发现额外的别名。查询时间为 $O(F + P)$，更新时间为 $O(1)$，空间开销为 $O(1)$。\n\nC. 仅使用前向映射：一个以 $(\\text{PID}, \\text{VPN})$ 为键、映射到 PFN 的全局哈希表。为了重建给定 PFN 的别名，需要扫描所有桶并收集其值等于该 PFN 的键。查询时间为 $O(A)$，平均更新时间为 $O(1)$，空间开销为 $O(A)$。\n\nD. 为每个 PFN 维护一个别名的双向链表，并将头指针存储在一个由 PFN 索引的长度为 $F$ 的数组中。查询一个 PFN 时，以 $O(1)$ 的时间获取头指针，并以 $O(k)$ 的时间枚举 $k$ 个节点。在映射和取消映射时，通过反向指针，插入和删除的最坏情况时间复杂度为 $O(1)$，总空间复杂度为 $O(F + A)$。\n\nE. 增强每个倒排页表条目，使其只存储一个 $(\\text{PID}, \\text{VPN})$ 元组，并依赖于转译旁观缓冲器（Translation Lookaside Buffer, TLB）按需重建共享映射。查询时间为 $O(1)$ 以获取单个元组，更新时间为 $O(1)$，空间开销为 $O(F)$。", "solution": "问题陈述在操作系统内存管理的背景下提出了一个数据结构设计挑战，特别涉及倒排页表和共享内存。在推导解决方案之前，需要对问题陈述进行严格的验证。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n-   系统使用倒排页表（IPT）进行请求分页。\n-   IPT 每个物理帧有一个条目。其大小为 $F$，即物理帧的数量。\n-   在基础 IPT 中，索引为 $i$（$0 \\le i  F$）的条目被定义为记录物理帧号（PFN）为 $i$ 的物理帧的单个所有者元组（进程标识符 (PID)，虚拟页号 (VPN)）。\n-   单个物理帧可以被多个进程和虚拟页别名（共享）。\n-   $k$ 是某个特定 PFN 的别名数量。\n-   $A$ 是系统范围内的别名总数。\n-   $P$ 是进程的数量。\n-   需要设计一个调试工具，用于查找给定 PFN 的所有 $(\\text{PID}, \\text{VPN})$ 对。\n-   查询操作必须具有 $O(1)$ 的平均时间复杂度来定位别名容器，以及 $O(k)$ 的输出敏感复杂度来枚举这 $k$ 个对。\n-   可以使用标准数据结构（数组、哈希表、链表）。\n-   可以在 IPT 旁维护辅助元数据。\n-   问题要求提供一个满足这些复杂度要求的设计，并说明相关的空间和更新时间成本。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学基础**：所呈现的概念——倒排页表、请求分页、共享内存（别名）、PID、VPN、PFN 以及性能复杂度分析——都是操作系统研究中的标准和基础概念。该问题具有科学基础。\n-   **适定性**：目标明确：设计一个数据结构，用于从 PFN 到一组 $(\\text{PID}, \\text{VPN})$ 元组的反向映射。性能要求（$O(1)$ 平均访问 + $O(k)$ 枚举）是具体且可衡量的。可用的工具也已指定。该问题是适定的。\n-   **客观性**：问题以精确的技术语言陈述，没有主观或模糊的术语。\n-   **一致性**：基础 IPT 条目定义为持有*一个*所有者元组，与一个物理帧具有*k*个别名的现实之间存在明显的矛盾。然而，这不是一个缺陷，而是问题的核心挑战。提示明确允许维护“辅助元数据”，这意味着基础 IPT 结构本身是不够的，必须进行增强。因此，问题不在于使用有缺陷的基础结构，而在于设计一个新的、正确的结构来处理别名问题，同时满足性能目标。\n\n**步骤 3：结论与行动**\n问题陈述是有效的。它提出了一个定义明确的数据结构设计问题，其基础是成熟的计算机科学原理。表面上的矛盾是构建此设计挑战的前提。我们可以继续进行解答。\n\n**解决方案的推导**\n\n目标是创建一个从给定的物理帧号（PFN）到所有映射到它的 $(\\text{PID}, \\text{VPN})$ 元组集合的映射。设 PFN 为 $p$。查询操作包括两部分：找到 $p$ 的别名集合，然后枚举它们。\n\n1.  **定位别名集合**：PFN, $p$，是一个在 $[0, F-1]$ 范围内的整数。要求是在 $O(1)$ 平均时间内定位别名集合。将密集整数范围映射到数据的最直接、最高效的数据结构是数组。我们可以定义一个“反向映射”为一个大小为 $F$ 的数组，称之为 `ReverseMap`。访问 `ReverseMap[p]` 需要 $O(1)$ 的最坏情况时间，这满足了 $O(1)$ 平均时间的要求。该数组的空间成本为 $O(F)$。\n\n2.  **存储和枚举别名**：存储在 `ReverseMap[p]` 处的对象必须是一个包含 $k$ 个元组的容器。对该容器所需的操作是添加别名、移除别名和枚举所有别名。\n    -   **枚举**：复杂度必须是输出敏感的，即 $O(k)$。链表和哈希表都支持在 $O(k)$ 时间内遍历其 $k$ 个元素。\n    -   **更新（映射/取消映射）**：\n        -   **哈希集合**：向哈希集合中插入或删除一个 $(\\text{PID}, \\text{VPN})$ 元组的平均时间为 $O(1)$。\n        -   **双向链表**：在列表头部插入一个新别名的最坏情况时间为 $O(1)$。删除任意别名需要先找到它，这将是 $O(k)$。但是，如果主前向映射结构（例如，进程页表）存储一个直接指向此反向映射链表中相应节点的指针，那么从双向链表中删除操作可以在 $O(1)$ 的最坏情况时间内完成。这是一种标准的系统编程技术。\n\n3.  **总体复杂度**：\n    -   **查询时间**：索引主数组 `ReverseMap` 需要 $O(1)$，加上遍历所选集合（哈希集合或链表）的 $O(k)$。总时间为 $O(1) + O(k)$，由于任何已映射的帧 $k \\ge 1$，因此简化为 $O(k)$。“定位容器”部分为 $O(1)$，满足了问题的特定要求。\n    -   **更新时间**：对于影响一个别名的映射/取消映射操作，对于哈希集合实现，时间为 $O(1)$ 平均；对于双向链表实现（带有反向指针），时间为 $O(1)$ 最坏情况。\n    -   **空间复杂度**：所需空间为 `ReverseMap` 数组的 $O(F)$ 加上所有别名的空间。由于系统范围内总共有 $A$ 个别名，每个别名需要常量存储（作为节点或哈希表条目），因此集合的总空间为 $O(A)$。因此，总空间复杂度为 $O(F + A)$。\n\n基于哈希集合数组的设计和基于双向链表数组的设计都是有效的，并且都满足指定的性能标准。\n\n**逐项分析**\n\n**A. 维护一个反向索引：一个长度为 $F$ 的数组，由 PFN 索引，其中每个条目指向一个包含该 PFN 的 $(\\text{PID}, \\text{VPN})$ 别名的哈希集合容器。查询一个 PFN 时，以 $O(1)$ 的平均时间对数组进行索引，并返回一个可迭代的集合；枚举的时间复杂度为 $O(k)$。在映射和取消映射时，每次插入和删除别名的平均时间复杂度为 $O(1)$，总空间复杂度为 $O(F + A)$。**\n此设计与我们推导出的最优解之一相匹配。长度为 $F$ 的数组提供了对容器的 $O(1)$ 访问。哈希集合提供了 $O(1)$ 的平均时间插入/删除和 $O(k)$ 的枚举。总空间被正确地确定为 $O(F + A)$。“以 $O(1)$ 平均时间索引数组”的措辞略有不精确，因为数组索引是 $O(1)$ 最坏情况，但这并不影响整个设计的正确性及其复杂度分析的有效性。\n**结论：正确。**\n\n**B. 线性扫描倒排页表以定位所有引用给定 PFN 的条目，对于共享帧，则扫描每个进程的页表以发现额外的别名。查询时间为 $O(F + P)$，更新时间为 $O(1)$，空间开销为 $O(1)$。**\n这种方法根本上是低效的。首先，根据定义，基础 IPT 是由 PFN 索引的，因此为了查找给定的 PFN 而进行“线性扫描”是无意义的。其次，更关键的是，扫描所有 $P$ 个进程的每个进程页表是一项极其昂贵的操作，远超 $O(F+P)$。查询时间将与所有虚拟地址空间大小的总和成正比，这是不可接受的。它未能满足指定的查询时间复杂度。\n**结论：不正确。**\n\n**C. 仅使用前向映射：一个以 $(\\text{PID}, \\text{VPN})$ 为键、映射到 PFN 的全局哈希表。为了重建给定 PFN 的别名，需要扫描所有桶并收集其值等于该 PFN 的键。查询时间为 $O(A)$，平均更新时间为 $O(1)$，空间开销为 $O(A)$。**\n这描述了使用标准倒排页表进行反向查找。所提出的方法是扫描整个数据结构，其中包含 $A$ 个条目。$O(A)$ 的查询时间太慢，不满足 $O(1)$ 访问 + $O(k)$ 枚举的要求，因为 $A$ 可能远大于 $k$。\n**结论：不正确。**\n\n**D. 为每个 PFN 维护一个别名的双向链表，并将头指针存储在一个由 PFN 索引的长度为 $F$ 的数组中。查询一个 PFN 时，以 $O(1)$ 的时间获取头指针，并以 $O(k)$ 的时间枚举 $k$ 个节点。在映射和取消映射时，通过反向指针，插入和删除的最坏情况时间复杂度为 $O(1)$，总空间复杂度为 $O(F + A)$。**\n此设计与我们推导出的第二个最优解相匹配。头指针数组提供了 $O(1)$ 的最坏情况访问。双向链表允许 $O(k)$ 的枚举。更新时间的分析也很精确：借助前向映射结构的反向指针，从列表中删除成为一个 $O(1)$ 的最坏情况操作。空间复杂度被正确地陈述为 $O(F + A)$。此设计有效并满足所有要求。\n**结论：正确。**\n\n**E. 增强每个倒排页表条目，使其只存储一个 $(\\text{PID}, \\text{VPN})$ 元组，并依赖于转译旁观缓冲器（Translation Lookaside Buffer, TLB）按需重建共享映射。查询时间为 $O(1)$ 以获取单个元组，更新时间为 $O(1)$，空间开销为 $O(F)$。**\n这个提议有根本性的缺陷。它没有解决核心问题，即找到*所有* $k$ 个别名。它只提供了一种找到一个别名的机制。“依赖 TLB”的建议是无稽之谈；TLB 是一个硬件翻译缓存，没有机制去发现当前未缓存的映射。它不能用于重建物理帧的完整别名列表。\n**结论：不正确。**\n\n选项 A 和 D 都描述了满足问题所有要求的有效、高效的设计。它们代表了解决此类反向映射问题的两种标准且正确的实现选择。因此，它们都是正确答案。", "answer": "$$\\boxed{AD}$$", "id": "3651074"}]}