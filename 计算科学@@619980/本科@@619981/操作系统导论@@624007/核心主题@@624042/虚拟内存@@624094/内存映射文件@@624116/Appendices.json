{"hands_on_practices": [{"introduction": "在理论层面理解了内存映射文件后，我们来探讨一个核心的实践问题：如何精确访问文件中任意位置的数据？操作系统要求 `mmap` 的文件偏移量必须是页大小的整数倍，但我们关心的数据（例如，一条记录或一个对象）很少恰好从页边界开始。这个练习将指导你解决这个不对齐的挑战，通过映射包含数据的整个内存页，并使用指针运算来精确定位目标。[@problem_id:3658292]", "problem": "给定一个大文件，其中存储了一个由定长记录组成的数组，记录之间背靠背排列，没有填充。记录大小为 $R = 3600$ 字节。在一个兼容可移植操作系统接口（POSIX）的系统上，系统页面大小为 $P = 4096$ 字节，内存映射系统调用要求文件偏移量参数是 $P$ 的倍数。文件长度为 $L = 10{,}000{,}000$ 字节。你希望通过内存映射或定位读取的方式访问索引为 $i = 523$ 的记录。\n\n你可以假设以下基本事实：\n- 虚拟内存映射的创建和保护是以页面粒度 $P$ 进行的。\n- 内存映射系统调用要求文件偏移量是 $P$ 的倍数。\n- 第 $i$ 条记录从文件偏移量 $O = i \\cdot R$ 开始。\n\n令 $O = i \\cdot R$ 为记录起始位置的字节偏移量。令 $A = \\left\\lfloor \\frac{O}{P} \\right\\rfloor \\cdot P$ 为不超过 $O$ 的最大页面对齐偏移量，令 $\\Delta = O - A$ 为记录起始位置相对于 $A$ 的页内位移。假设映射返回一个基地址 $b$，对应于文件偏移量 $A$ 和长度 $\\ell$。\n\n下列哪些陈述是正确的？选择所有适用项。\n\nA. 为了精确映射第 $i$ 条记录所需的字节，计算 $A = \\left\\lfloor \\frac{O}{P} \\right\\rfloor \\cdot P$ 和 $\\Delta = O - A$，然后以偏移量 $A$ 和长度 $\\ell = \\Delta + R$ 调用内存映射，接着使用指针运算来寻址位于 $r = b + \\Delta$ 的记录。只要 $O + R \\leq L$，即使 $O$ 未页面对齐，此操作也是安全的。\n\nB. 可以直接用偏移量 $O$ 调用内存映射；内核会隐式地将 $O$ 向下取整到一个页面边界，因此你可以设置 $\\ell = R$ 并将 $b$ 用作记录指针。\n\nC. 使用偏移量 $O$ 和长度 $R$ 进行定位读取（pread）会返回与通过正确的页面对齐映射及指针调整访问记录相同的数据，并且它不要求偏移量 $O$ 是页面对齐的。只要 $O + R \\leq L$ 且文件没有被并发地截断，这种做法符合标准且是安全的。\n\nD. 映射长度 $\\ell$ 必须向上取整到页面大小的倍数，因此必须设置 $\\ell = \\left\\lceil \\frac{\\Delta + R}{P} \\right\\rceil \\cdot P$；否则，映射调用会违反接口规范。\n\nE. 在这个具体案例中，$R = 3600$，$i = 523$，$P = 4096$，我们有 $\\Delta + R > P$，所以该记录相对于 $A$ 跨越了两个页面。如果错误地选择 $\\ell = R$（忽略了 $\\Delta$），从 $b$ 开始对偏移量为 $[\\Delta, \\Delta + R)$ 的字节进行解引用，最终会访问到第二个页面并因映射长度不足而产生故障。\n\nF. 如果 $O + R$ 超出 $L$ 不足 $P$ 字节，记录的超出部分可以通过映射安全地读取，并会显示为零，因此只要 $\\ell \\geq \\Delta + R$，读取完整的 $R$ 字节是安全的。", "solution": "用户希望我扮演一位严谨苛刻的STEM领域教授，来解决一个与内存映射文件相关的问题。\n\n### 问题验证\n\n**步骤 1: 提取已知条件**\n\n-   记录大小: $R = 3600$ 字节。\n-   系统页面大小: $P = 4096$ 字节。\n-   系统兼容POSIX。\n-   内存映射系统调用要求文件偏移量参数是 $P$ 的倍数。\n-   文件长度: $L = 10,000,000$ 字节。\n-   目标记录索引: $i = 523$。\n-   基本假设：虚拟内存映射的创建和保护是以页面粒度 $P$进行的。\n-   基本假设：内存映射系统调用要求文件偏移量是 $P$ 的倍数。\n-   基本假设：第 $i$ 条记录从文件偏移量 $O = i \\cdot R$ 开始。\n-   定义：$O = i \\cdot R$ 是记录起始位置的字节偏移量。\n-   定义：$A = \\left\\lfloor \\frac{O}{P} \\right\\rfloor \\cdot P$ 是不超过 $O$ 的最大页面对齐偏移量。\n-   定义：$\\Delta = O - A$ 是记录起始位置相对于 $A$ 的页内位移。\n-   定义：映射返回一个基地址 $b$，对应于文件偏移量 $A$ 和长度 $\\ell$。\n\n**步骤 2: 使用提取的已知条件进行验证**\n\n根据验证标准分析问题陈述：\n\n-   **科学依据**：该问题基于操作系统核心且公认的概念，特别是POSIX兼容系统上的内存管理和文件I/O。关于 `mmap`（页面对齐的偏移量）和 `pread` 的通用行为的规则，都是对这些系统调用的真实表述。该问题在科学上是合理的。\n-   **定义良好**：该问题提供了分析情况和评估给定陈述所需的所有必要数据（$R, P, L, i$）和清晰、正式的定义（$O, A, \\Delta$）。可以确定一组明确的正确和错误陈述。\n-   **客观性**：语言技术性强、精确，没有任何主观性或歧义。\n-   **不完整或矛盾的设置**：该问题是自包含且内部一致的。提供的“基本事实”加强了所涉及系统调用的标准行为。\n-   **不切实际或不可行**：页面大小、记录大小和文件长度的数值都在典型计算场景的实际范围内。\n-   **问题不适定或结构不良**：该问题结构良好，通过标准定义引导分析，以分解相对于页面边界的文件偏移量。\n\n**步骤 3: 结论与行动**\n\n问题陈述有效。这是一个关于`mmap`和`pread`系统调用的正确用法和常见陷阱的良好问题。可以继续进行求解过程。\n\n### 求解推导\n\n首先，我们计算给定参数的具体值。\n记录索引是 $i = 523$。\n记录大小是 $R = 3600$ 字节。\n页面大小是 $P = 4096$ 字节。\n文件长度是 $L = 10,000,000$ 字节。\n\n1.  **计算记录的起始偏移量 $O$**：\n    $O = i \\cdot R = 523 \\cdot 3600 = 1,882,800$ 字节。\n\n2.  **验证记录是否在文件边界内**：\n    该记录占据字节范围 $[O, O + R - 1]$。记录的结束位置在偏移量 $O + R - 1 = 1,882,800 + 3600 - 1 = 1,886,399$ 处。\n    由于 $1,886,399  10,000,000 = L$，整个记录都包含在文件内。\n\n3.  **计算页面对齐的基准偏移量 $A$**：\n    `mmap` 调用要求偏移量是页面大小 $P$ 的倍数。因此我们必须找到包含偏移量 $O$ 的页面的起始位置。\n    $A = \\left\\lfloor \\frac{O}{P} \\right\\rfloor \\cdot P = \\left\\lfloor \\frac{1,882,800}{4096} \\right\\rfloor \\cdot 4096$\n    $1,882,800 \\div 4096 \\approx 459.6679$\n    $A = \\lfloor 459.6679 \\rfloor \\cdot 4096 = 459 \\cdot 4096 = 1,880,064$ 字节。\n\n4.  **计算页内位移 $\\Delta$**：\n    这是记录的起始位置相对于页面对齐映射起始位置的偏移量。\n    $\\Delta = O - A = 1,882,800 - 1,880,064 = 2736$ 字节。\n\n有了这些值，我们现在可以分析此记录的内存映射原理。\n-   `mmap` 系统调用必须以 `offset = A = 1,880,064` 来调用。\n-   映射将返回一个对应于文件偏移量 $A$ 的基指针 $b$。\n-   所需的记录从文件偏移量 $O$ 开始。在虚拟地址空间中，这对应于地址 $b + \\Delta$。\n-   为了访问大小为 $R$ 的整个记录，我们需要能够从地址 $b + \\Delta$ 读取字节，直到 $b + \\Delta + R - 1$。\n-   这意味着映射区域必须至少延伸到这个地址。映射的长度 $\\ell$ 必须满足 $b + \\ell - 1 \\geq b + \\Delta + R - 1$，简化后为 $\\ell \\geq \\Delta + R$。\n-   所需的最小映射长度是 $\\ell_{min} = \\Delta + R = 2736 + 3600 = 6336$ 字节。\n\n### 逐项分析\n\n**A. 为了精确映射第 $i$ 条记录所需的字节，计算 $A = \\left\\lfloor \\frac{O}{P} \\right\\rfloor \\cdot P$ 和 $\\Delta = O - A$，然后以偏移量 $A$ 和长度 $\\ell = \\Delta + R$ 调用内存映射，接着使用指针运算来寻址位于 $r = b + \\Delta$ 的记录。只要 $O + R \\leq L$，即使 $O$ 未页面对齐，此操作也是安全的。**\n\n该陈述准确地描述了映射非页面边界开始的文件区域的标准流程。\n-   偏移量必须是页面对齐的，所以使用 $A$ 是正确的。\n-   长度必须足以覆盖从映射开始（$A$）到记录结束（$O+R$）的数据。所需的长度是 $(O+R) - A = (O-A) + R = \\Delta+R$。因此，设置 $\\ell = \\Delta+R$ 是正确的最小长度。\n-   记录指针 $r$ 必须从映射的基地址 $b$ 调整页内位移 $\\Delta$，所以 $r = b + \\Delta$ 是正确的。\n-   该流程专为 $O$ 未页面对齐的情况而设计，而条件 $O+R \\leq L$ 确保操作不会试图访问超出文件定义长度的数据。\n该陈述的所有部分都与 `mmap` 的 POSIX 标准一致。\n\n**结论：正确。**\n\n**B. 可以直接用偏移量 $O$ 调用内存映射；内核会隐式地将 $O$ 向下取整到一个页面边界，因此你可以设置 $\\ell = R$ 并将 $b$ 用作记录指针。**\n\n这个陈述根本上是错误的。`mmap` 的 POSIX 标准是严格的：`offset` 参数必须是页面大小的倍数。在这个问题中，$O = 1,882,800$ 不是 $P=4096$ 的倍数。使用未页面对齐的偏移量调用 `mmap` 将会失败，返回 `MAP_FAILED` 并将 `errno` 变量设置为 `EINVAL`（无效参数）。内核不会隐式纠正无效的偏移量；它会拒绝该系统调用。\n\n**结论：错误。**\n\n**C. 使用偏移量 $O$ 和长度 $R$ 进行定位读取（pread）会返回与通过正确的页面对齐映射及指针调整访问记录相同的数据，并且它不要求偏移量 $O$ 是页面对齐的。只要 $O + R \\leq L$ 且文件没有被并发地截断，这种做法符合标准且是安全的。**\n\n这个陈述正确地描述了 `pread` 系统调用。\n-   `pread` 从给定偏移量读取指定数量的字节。其签名为 `pread(fd, buf, count, offset)`。\n-   `pread` 相对于 `mmap` 在某些任务上的一个关键特性和优势是其 `offset` 参数没有任何对齐要求。\n-   因此，使用偏移量 $O$ 和长度 $R$ 调用 `pread` 是将记录读入缓冲区的直接且正确的方式。\n-   获取的数据将与通过正确配置的内存映射访问的数据相同。\n-   安全条件（$O+R \\leq L$ 和无并发截断）是有效且正确性所必需的。该陈述完全准确。\n\n**结论：正确。**\n\n**D. 映射长度 $\\ell$ 必须向上取整到页面大小的倍数，因此必须设置 $\\ell = \\left\\lceil \\frac{\\Delta + R}{P} \\right\\rceil \\cdot P$；否则，映射调用会违反接口规范。**\n\n这是一个常见的误解。虽然内核以页面粒度管理内存并执行实际的映射，但传递给 `mmap` 系统调用本身的 `length` 参数并不要求是页面大小的倍数。`length` 参数定义了进程可访问区域的大小。如果一个进程试图访问从基指针 `b` 开始，偏移量大于或等于 `length` 的内存，它将收到一个 `SIGSEGV` 信号，即使底层的页面已被映射。指定所需的确切长度（例如 $\\ell = \\Delta+R$）是完全有效且通常是可取的，这并不违反 `mmap` 接口。\n\n**结论：错误。**\n\n**E. 在这个具体案例中，$R = 3600$，$i = 523$，$P = 4096$，我们有 $\\Delta + R  P$，所以该记录相对于 $A$ 跨越了两个页面。如果错误地选择 $\\ell = R$（忽略了 $\\Delta$），从 $b$ 开始对偏移量为 $[\\Delta, \\Delta + R)$ 的字节进行解引用，最终会访问到第二个页面并因映射长度不足而产生故障。**\n\n让我们验证一下数值声明。\n-   我们计算出 $\\Delta = 2736$ 字节，已知 $R = 3600$ 和 $P = 4096$。\n-   检查跨度：$\\Delta + R = 2736 + 3600 = 6336$ 字节。\n-   由于 $6336  4096$，我们有 $\\Delta + R  P$。这是正确的。该记录从映射的第一个页面偏移 $2736$ 字节处开始，并延续 $3600$ 字节，因此延伸到第二个页面。\n-   现在，考虑错误场景：使用正确的偏移量 $A$ 但错误的长度 $\\ell = R = 3600$ 调用 `mmap`。\n-   进程的有效虚拟地址范围是从 $b$ 到 $b + \\ell - 1$，即 $[b, b+3599]$。\n-   代码将尝试从地址 $b + \\Delta$ 访问记录到 $b + \\Delta + R - 1$。\n-   这对应于地址范围 $[b+2736, b+2736+3600-1] = [b+2736, b+6335]$。\n-   访问从 $b+2736$ 开始，这在有效映射范围 $[b, b+3599]$ 之内。\n-   然而，访问一直持续到 $b+6335$。由于 $6335  3599$，任何超出 $b+3599$ 的访问都在请求的映射长度 $\\ell=3600$ 之外。\n-   这样的访问将导致段错误（`SIGSEGV`）。故障的原因恰恰是映射长度不足。该陈述是对这一错误的正确分析。\n\n**结论：正确。**\n\n**F. 如果 $O + R$ 超出 $L$ 不足 $P$ 字节，记录的超出部分可以通过映射安全地读取，并会显示为零，因此只要 $\\ell \\geq \\Delta + R$，读取完整的 $R$ 字节是安全的。**\n\n该陈述对映射超出文件末尾（EOF）时的行为提出了一个主张。根据 POSIX 标准，如果映射包含了包含 EOF 的页面，那么对该页面内超出 EOF 的地址的任何引用都将被零填充。然而，对任何对应于完全超出 EOF 的*整个页面*中的文件偏移量的内存地址的引用将导致一个 `SIGBUS` 信号。\n条件“$O + R$ 超出 $L$ 不足 $P$ 字节”并不足以保证安全。考虑一个长度为 $L = 4097$ 的文件（刚刚进入第二个页面，其中 $P=4096$）。假设一次读取的记录使得 $O+R = 8192$（第三个页面的开始）。这里，$(O+R)-L = 4095  P$。然而，读取试图访问一个完全超出文件末尾的页面中的地址，这将触发一个 `SIGBUS`。这次读取是不安全的。只有当整个读取操作都包含在拥有 EOF 的部分页面内时，才是安全的。该陈述的安全声明过于笼统，因此是错误的。\n\n**结论：错误。**", "answer": "$$\\boxed{ACE}$$", "id": "3658292"}, {"introduction": "掌握了单次映射的技巧后，我们来应对一个更宏大的挑战：如何处理一个远超可用虚拟地址空间的大文件？在 $32$ 位系统中，这是一个非常常见的限制，即使在 $64$ 位系统中，一次性映射一个巨大的文件也可能是不明智的。此练习模拟了在有限且碎片化的地址空间中，通过“滑动窗口”策略分块处理大文件的真实场景，让你亲身体会映射开销与数据吞吐量之间的权衡。[@problem_id:3658332]", "problem": "一个 $32$ 位进程运行在一个操作系统（OS）上，其内核永久占据虚拟地址空间的顶部 $1\\,\\mathrm{GiB}$，留下大小为 $U=3\\,\\mathrm{GiB}$ 的用户虚拟地址空间。系统页面大小为 $P=4\\,\\mathrm{KiB}$，分配粒度为 $G=64\\,\\mathrm{KiB}$，因此任何内存映射文件视图的基地址和长度都必须与 $G$ 的倍数对齐。内存映射接口在每次映射之前和之后自动强制实施一个 $64\\,\\mathrm{KiB}$ 的保护区域，该区域不能被视图使用。单个映射视图的最大允许大小为 $1\\,\\mathrm{GiB}$。该进程当前的分配使得用户空间碎片化，导致空闲用户空间由四个不相交的连续空洞组成，大小分别为 $768\\,\\mathrm{MiB}$、$512\\,\\mathrm{MiB}$、$192\\,\\mathrm{MiB}$ 和 $64\\,\\mathrm{MiB}$。\n\n你必须通过在最大可用空洞内的一个固定基地址上重复映射一个固定大小的窗口，然后取消映射，再在同一基地址上重新映射下一个文件段（一种滑动固定基址策略），来顺序遍历一个大小为 $F=137\\,\\mathrm{GiB}$ 的非常大的文件。每个窗口的每次映射-取消映射周期会产生 $t_{m}=2.5\\times 10^{-3}\\,\\mathrm{s}$ 的开销，该开销与窗口大小无关。存储子系统通过内存映射窗口访问时，可维持 $B=1.6\\,\\mathrm{GiB/s}$ 的顺序读取吞吐量。假设映射开销和数据传输时间线性相加得到总的墙上时钟时间。所有映射和大小都必须与 $G$ 的倍数对齐，并且必须遵守保护区域的规定。\n\n从基本的虚拟内存原理（有限的虚拟地址空间、页面和粒度对齐的映射以及连续性约束）出发，完成以下任务：\n- 在给定约束下，确定滑动策略允许的最大固定窗口大小 $W$。\n- 计算使用此 $W$ 时覆盖整个文件所需的映射窗口数量。\n- 使用简单的碎片化风险代理指标 $r = 1 - L/F_{\\text{free}}$（其中 $L$ 是最大空闲空洞的大小，$F_{\\text{free}}$ 是总空闲用户空间），评估 $r$。\n- 推导并计算使用滑动策略遍历整个文件的总时间 $T_{\\text{total}}(W)$。\n\n将你的最终数值答案 $T_{\\text{total}}$ 四舍五入到四位有效数字，并以秒为单位表示。你提交的最终答案必须是这个单一的舍入后数字。", "solution": "首先对问题进行验证，以确保其科学上成立、定义明确且客观。\n\n### 步骤 1：提取已知条件\n- 进程架构：一个 $32$ 位进程。\n- 内核虚拟地址空间预留：顶部 $1\\,\\mathrm{GiB}$。\n- 用户虚拟地址空间大小：$U=3\\,\\mathrm{GiB}$。\n- 系统页面大小：$P=4\\,\\mathrm{KiB}$。\n- 分配粒度：$G=64\\,\\mathrm{KiB}$。\n- 对齐约束：内存映射文件视图的基地址和长度必须与 $G$ 的倍数对齐。\n- 保护区域：每次映射前后自动强制实施 $64\\,\\mathrm{KiB}$。\n- 最大视图大小：$1\\,\\mathrm{GiB}$。\n- 空闲用户空间碎片化：四个大小分别为 $H_1=768\\,\\mathrm{MiB}$、$H_2=512\\,\\mathrm{MiB}$、$H_3=192\\,\\mathrm{MiB}$ 和 $H_4=64\\,\\mathrm{MiB}$ 的不相交连续空洞。\n- 待遍历的总文件大小：$F=137\\,\\mathrm{GiB}$。\n- 遍历策略：滑动固定基址（在固定基地址上重复映射-取消映射一个固定大小的窗口）。\n- 映射-取消映射周期开销：$t_{m}=2.5\\times 10^{-3}\\,\\mathrm{s}$。\n- 顺序读取吞吐量：$B=1.6\\,\\mathrm{GiB/s}$。\n- 总时间模型：映射开销和数据传输时间的线性相加。\n- 碎片化风险代理指标定义：$r = 1 - L/F_{\\text{free}}$，其中 $L$ 是最大空闲空洞的大小，$F_{\\text{free}}$ 是总空闲用户空间。\n- 最终答案要求：将 $T_{\\text{total}}$ 四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n对问题陈述进行有效性分析。\n- **科学基础**：所提出的概念是操作系统理论中的标准概念。一个 $32$ 位地址空间对应 $2^{32}$ 字节，即 $4\\,\\mathrm{GiB}$。内核空间（$1\\,\\mathrm{GiB}$）和用户空间（$3\\,\\mathrm{GiB}$）之间的划分是一种常见的内存布局。内存映射文件、页面大小、分配粒度、保护区域和对齐约束都是虚拟内存管理中现实且成熟的概念。该问题具有科学基础。\n- **良构性**：问题清晰地定义了所有必要的参数、约束和关系。它要求计算可以从已知条件中推导出的特定量（$W$、$N$、$r$、$T_{\\text{total}}$）。求解路径是唯一且稳定的。\n- **客观性**：问题使用精确的技术语言陈述，没有主观或模糊的术语。\n- **完整性与一致性**：所提供的数据是自洽的。$3\\,\\mathrm{GiB}$ 的用户空间与 $4\\,\\mathrm{GiB}$ 总空间减去 $1\\,\\mathrm{GiB}$ 内核空间是一致的。所有单位和数值都已指定。约束条件之间不相互矛盾。例如，保护区域大小（$64\\,\\mathrm{KiB}$）等于分配粒度（$G=64\\,\\mathrm{KiB}$），这是一个常见且合乎逻辑的简化。\n- **可行性**：文件大小、吞吐量和映射开销的数值都在现代计算系统的合理范围内。\n\n### 步骤 3：结论与行动\n问题被判定为**有效**。这是一个定义明确、自洽且基于成熟计算机科学原理的问题。可以继续进行求解过程。\n\n---\n\n### 求解推导\n\n我们将按顺序解决问题的每个部分。我们为计算建立一致的单位。我们将使用二进制前缀，其中 $1\\,\\mathrm{KiB} = 2^{10}$ 字节，$1\\,\\mathrm{MiB} = 2^{20}$ 字节，以及 $1\\,\\mathrm{GiB} = 2^{30}$ 字节。\n\n分配粒度为 $G=64\\,\\mathrm{KiB}$。\n保护区域大小也是 $64\\,\\mathrm{KiB}$，我们可以将其表示为 $G$。\n\n**1. 确定允许的最大固定窗口大小 $W$。**\n滑动窗口策略在最大可用空洞内使用一个固定的基地址。最大的空洞是 $L = H_1 = 768\\,\\mathrm{MiB}$。\n一个大小为 $W$ 的内存映射视图需要一个连续的虚拟地址空间块。这个块必须能容纳视图本身以及两个保护区域。\n所需总空间 $S_{\\text{req}}$ 为：\n$$S_{\\text{req}} = (\\text{Guard Before}) + W + (\\text{Guard After})$$\n$$S_{\\text{req}} = G + W + G = W + 2G$$\n这个所需的连续空间必须完全容纳在最大的空洞 $L$ 内。\n$$W + 2G \\le L$$\n问题说明视图的长度 $W$ 必须是分配粒度 $G$ 的倍数。因此，设 $W = kG$，其中 $k$ 是一个正整数。\n将此代入不等式中：\n$$kG + 2G \\le L \\implies (k+2)G \\le L$$\n$$k+2 \\le \\frac{L}{G}$$\n我们需要计算 $L/G$。\n$$L = 768\\,\\mathrm{MiB} = 768 \\times 1024\\,\\mathrm{KiB} = 786432\\,\\mathrm{KiB}$$\n$$G = 64\\,\\mathrm{KiB}$$\n$$\\frac{L}{G} = \\frac{786432\\,\\mathrm{KiB}}{64\\,\\mathrm{KiB}} = 12288$$\n因此，$k+2 \\le 12288$，这意味着 $k \\le 12286$。\n$k$ 的最大整数值为 $12286$。因此，允许的最大窗口大小 $W$ 是：\n$$W = k_{\\text{max}}G = 12286 \\times 64\\,\\mathrm{KiB} = 786304\\,\\mathrm{KiB}$$\n以 MiB 表示：\n$$W = \\frac{786304}{1024}\\,\\mathrm{MiB} = 767.875\\,\\mathrm{MiB}$$\n我们还必须遵守最大视图大小为 $1\\,\\mathrm{GiB}$ 的规定。由于 $767.875\\,\\mathrm{MiB}  1024\\,\\mathrm{MiB}$（即 $1\\,\\mathrm{GiB}$），此约束得到满足。\n\n**2. 计算映射窗口的数量 $N$。**\n使用大小为 $W$ 的窗口遍历总大小为 $F=137\\,\\mathrm{GiB}$ 的文件。窗口数量 $N$ 是总文件大小除以窗口大小，并向上取整（ceiling 函数），因为文件的任何剩余部分都需要一次完整的映射操作。\n$$N = \\left\\lceil \\frac{F}{W} \\right\\rceil$$\n让我们将 $F$ 和 $W$ 都用相同的单位表示，例如 GiB。\n$$F = 137\\,\\mathrm{GiB}$$\n$$W = 767.875\\,\\mathrm{MiB} = \\frac{767.875}{1024}\\,\\mathrm{GiB} = 0.7498779296875\\,\\mathrm{GiB}$$\n$$N = \\left\\lceil \\frac{137}{0.7498779296875} \\right\\rceil = \\left\\lceil 182.697... \\right\\rceil$$\n为了精确计算，我们使用以 $G$ 为单位的值：\n注意，$1\\,\\mathrm{GiB} = 1024\\,\\mathrm{MiB} = 1024 \\times 1024\\,\\mathrm{KiB} = 16384 \\times 64\\,\\mathrm{KiB} = 16384 G$。\n因此，$F = 137 \\times 16384 G = 2244608 G$。\n而 $W = 12286 G$。\n$$N = \\left\\lceil \\frac{2244608 G}{12286 G} \\right\\rceil = \\left\\lceil \\frac{2244608}{12286} \\right\\rceil = \\left\\lceil 182.697... \\right\\rceil = 183$$\n所以，需要 $183$ 个映射窗口。\n\n**3. 评估碎片化风险代理指标 $r$。**\n该代理指标定义为 $r = 1 - L/F_{\\text{free}}$。\n$L$ 是最大空闲空洞的大小：$L = 768\\,\\mathrm{MiB}$。\n$F_{\\text{free}}$ 是总空闲用户空间，即所有空洞大小的总和。\n$$F_{\\text{free}} = H_1 + H_2 + H_3 + H_4 = 768\\,\\mathrm{MiB} + 512\\,\\mathrm{MiB} + 192\\,\\mathrm{MiB} + 64\\,\\mathrm{MiB}$$\n$$F_{\\text{free}} = 1536\\,\\mathrm{MiB}$$\n现在我们计算 $r$：\n$$r = 1 - \\frac{L}{F_{\\text{free}}} = 1 - \\frac{768\\,\\mathrm{MiB}}{1536\\,\\mathrm{MiB}} = 1 - \\frac{1}{2} = 0.5$$\n\n**4. 推导并计算总时间 $T_{\\text{total}}(W)$。**\n总时间是总映射开销和总数据传输时间之和。\n$$T_{\\text{total}} = T_{\\text{map}} + T_{\\text{transfer}}$$\n总映射开销是映射-取消映射周期数 $N$ 乘以每个周期的开销 $t_m$。\n$$T_{\\text{map}} = N \\times t_m = 183 \\times (2.5 \\times 10^{-3}\\,\\mathrm{s}) = 457.5 \\times 10^{-3}\\,\\mathrm{s} = 0.4575\\,\\mathrm{s}$$\n总数据传输时间是总文件大小 $F$ 除以持续吞吐量 $B$。\n$$T_{\\text{transfer}} = \\frac{F}{B} = \\frac{137\\,\\mathrm{GiB}}{1.6\\,\\mathrm{GiB/s}} = \\frac{137}{1.6}\\,\\mathrm{s} = 85.625\\,\\mathrm{s}$$\n总时间是这两个部分之和：\n$$T_{\\text{total}} = 0.4575\\,\\mathrm{s} + 85.625\\,\\mathrm{s} = 86.0825\\,\\mathrm{s}$$\n问题要求将最终答案四舍五入到四位有效数字。\n$$T_{\\text{total}} \\approx 86.08\\,\\mathrm{s}$$\n第四位有效数字是 $8$，其后的数字是 $2$，所以我们向下舍入。最终的数值是 $86.08$。", "answer": "$$\\boxed{86.08}$$", "id": "3658332"}, {"introduction": "内存映射不仅是实现高效 I/O 的工具，更是进行精细内存管理的利器。最后一个练习将展示如何利用 `mmap` 的保护标志来增强程序的健壮性。我们将学习如何使用 `PROT_NONE` 标志在数据缓冲区的两侧创建不可访问的“保护页”，这是一种能够自动捕获缓冲区溢出错误的强大技术，能将潜在的数据损坏问题转变为一个明确、可立即定位的程序崩溃。[@problem_id:3658310]", "problem": "您正在为一个内存映射数组建模，该数组前后均由保护级别为“无”（PROT_NONE）的保护页保护，以捕获缓冲区溢出。在真实的操作系统中，内存保护是以虚拟内存页的粒度来强制执行的。以下基本事实将作为本问题的基础：\n\n- 虚拟内存被划分为大小为 $P$ 字节的页。所有保护都按页应用。\n- 一个连续的映射可以从与 $P$ 对齐的基地址 $B$ 开始。\n- 一个保护级别为“无”（PROT_NONE）的保护区域会拒绝所有访问；任何尝试读取或写入保护区域中地址的操作都会同步引发一个故障，而引发故障的虚拟地址就是程序试图访问的确切地址。\n- 如果一个长度为 $N$ 字节的数据区域被放置在保护页之间，操作系统会映射一个可访问区域，其大小会向上取整到页大小的倍数，因为保护是按页应用的。设 $L' = \\lceil N / P \\rceil \\cdot P$。那么，数据的可访问映射占据半开区间 $[S, S + L')$，其中 $S = B + G \\cdot P$，$G$ 是每侧的保护页数量。前置保护区是 $[B, S)$，后置保护区是 $[S + L', B + (L' + 2 G P))$。\n- 任何对地址 $X \\in [S, S + L')$ 的访问都会被页保护机制所允许。任何对 $X \\in [B, S)$ 或 $X \\in [S + L', B + (L' + 2 G P))$（或任何在 $[B, B + (L' + 2 G P))$ 之外的 $X$）的访问都是一个保护故障。如果发生保护故障，处理程序记录的违规地址就是被访问的地址 $X$。\n\n您的任务是编写一个程序，给定一组测试用例，判断相对于数据数组起始位置 $S$ 的偏移量 $k$ 处的单字节访问尝试是否会被页保护机制允许，还是会因访问保护区域（或整个映射之外的区域）而引发故障。如果访问被允许，输出 $0$。如果会引发故障，则以十进制整数形式输出违规的虚拟地址 $X = S + k$。\n\n所有地址必须视为以字节为单位的整数。总映射的起始地址 $B$ 是页对齐的。对于以下所有测试用例，每侧的保护页数量 $G = 1$。页大小 $P$ 和数据长度 $N$ 按每个测试用例提供。单次访问尝试由相对于 $S$ 的有符号偏移量 $k$ 指定。\n\n对于每个测试用例：\n- 计算 $S = B + G \\cdot P$。\n- 计算 $L' = \\lceil N / P \\rceil \\cdot P$。\n- 可访问区域为 $[S, S + L')$。\n- 总映射为 $[B, B + (L' + 2 G P))$。\n- 对于访问尝试 $X = S + k$：\n  - 如果 $X \\in [S, S + L')$，输出 $0$。\n  - 否则，以十进制整数形式输出 $X$（违规地址）。\n\n使用以下测试套件。每个测试用例是一个元组 $(B, P, N, G, k)$，所有情况下 $G=1$。为清晰起见，地址 $B$ 以十六进制和十进制两种形式给出；请将它们视为整数（您可以在程序中使用十进制形式）：\n\n1. $(B = 0x10000000\\; (=\\, 268435456),\\; P = 4096,\\; N = 10000,\\; G = 1,\\; k = 5000)$\n2. $(B = 0x10000000\\; (=\\, 268435456),\\; P = 4096,\\; N = 10000,\\; G = 1,\\; k = 10100)$\n3. $(B = 0x10000000\\; (=\\, 268435456),\\; P = 4096,\\; N = 10000,\\; G = 1,\\; k = 12288)$\n4. $(B = 0x10000000\\; (=\\, 268435456),\\; P = 4096,\\; N = 10000,\\; G = 1,\\; k = -16)$\n5. $(B = 0x10000000\\; (=\\, 268435456),\\; P = 4096,\\; N = 10000,\\; G = 1,\\; k = 9999)$\n6. $(B = 0x10000000\\; (=\\, 268435456),\\; P = 4096,\\; N = 10000,\\; G = 1,\\; k = 12287)$\n7. $(B = 0x10000000\\; (=\\, 268435456),\\; P = 4096,\\; N = 10000,\\; G = 1,\\; k = 1000000)$\n8. $(B = 0x20000000\\; (=\\, 536870912),\\; P = 1024,\\; N = 3072,\\; G = 1,\\; k = 3072)$\n9. $(B = 0x20000000\\; (=\\, 536870912),\\; P = 1024,\\; N = 3072,\\; G = 1,\\; k = -1024)$\n10. $(B = 0x20000000\\; (=\\, 536870912),\\; P = 1024,\\; N = 3072,\\; G = 1,\\; k = -2048)$\n11. $(B = 0x30000000\\; (=\\, 805306368),\\; P = 4096,\\; N = 8192,\\; G = 1,\\; k = 8191)$\n12. $(B = 0x30000000\\; (=\\, 805306368),\\; P = 4096,\\; N = 8192,\\; G = 1,\\; k = 8192)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。对于上述给定顺序的每个测试用例，如果访问被允许，则输出 $0$；否则，以十进制整数形式输出违规地址 $X$。例如：$[r_1,r_2,\\dots,r_{12}]$。\n\n此问题不涉及任何物理单位或角度。所有输出均为整数。", "solution": "该问题已经过验证，并被确定为一个定义明确、有科学依据的关于操作系统内存管理原则的计算建模练习。所有提供的数据和定义都是自洽的，足以推导出唯一的解决方案。\n\n问题的核心是确定在给定地址的内存访问是落在允许的区域内，还是落在受保护的保护区域内。内存布局由几个参数定义：基地址 `$B$`、页大小 `$P$`、标称数据长度 `$N$`，以及数据区两侧的保护页数量 `$G$`。对于所有测试用例，`$G=1$`。\n\n每个测试用例 `$(B, P, N, G, k)$` 的解决方案按以下步骤进行：\n\n1.  **定义地址和大小变量**：所有地址和大小都以字节为单位作为整数处理。为了适应可能很大的地址空间，审慎的做法是对所有相关变量（`$B$`、`$P$`、`$N$`、`$k$`、`$S$`、`$L'$` 和 `$X$`）使用64位整数类型，例如C语言中的 `long long`。\n\n2.  **计算数据区起始地址 `$S$`**：数据区域前面有 `$G$` 个保护页。由于一个页的大小为 `$P$`，前置保护区的总大小为 `$G \\cdot P$`。因此，数据区的起始地址 `$S$` 位于距基地址 `$B$` 偏移 `$G \\cdot P$` 的位置。\n    $$S = B + G \\cdot P$$\n    对于所有给定的测试用例，`$G=1$`，所以这可以简化为 `$S = B + P$`。\n\n3.  **计算映射的数据区长度 `$L'$`**：操作系统以页大小的块为数据区域分配内存。因此，实际分配的长度 `$L'$` 必须是请求的长度 `$N$` 向上取整到页大小 `$P$` 的下一个倍数。这等同于计算除法 `$N/P$` 的上限值再乘以 `$P$`。\n    $$L' = \\left\\lceil \\frac{N}{P} \\right\\rceil \\cdot P$$\n    使用整数算术可以避免潜在的浮点不精确性，该计算可以可靠地执行为：\n    $$L' = \\left( \\frac{N + P - 1}{P} \\right) \\cdot P$$\n    其中除法是整数除法。\n\n4.  **定义允许的内存区间**：可用于数据的内存区域是半开区间 `$[S, S + L')$`。对地址 `$X$` 的访问被允许，当且仅当 `$S \\le X  S + L'$`。\n\n5.  **计算目标访问地址 `$X$`**：问题指定的访问尝试不是绝对地址，而是相对于数据区起始地址 `$S$` 的一个有符号字节偏移量 `$k$`。访问的绝对虚拟地址 `$X$` 是：\n    $$X = S + k$$\n\n6.  **评估访问条件**：为了确定访问是否被允许，我们检查地址 `$X$` 是否落在允许的区间内。\n    $$S \\le X  S + L'$$\n    将 `$X = S + k$` 代入，我们得到：\n    $$S \\le S + k  S + L'$$\n    从不等式的各部分减去 `$S$`，得到一个关于偏移量 `$k$` 的更简单的条件：\n    $$0 \\le k  L'$$\n    这个简化的条件是判断内存访问是否有效的确定性测试。\n\n7.  **确定输出**：\n    - 如果条件 `$0 \\le k  L'$` 为真，则访问被允许，要求的输出是 `$0$`。\n    - 如果条件为假，则访问是故障。访问发生在保护页中或完全在映射区域之外。在这种情况下，要求的输出是引发故障的虚拟地址 `$X = S + k$`。\n\n将此过程应用于每个测试用例，即可得出最终结果集。例如，对于测试用例3：`$(B = 268435456, P = 4096, N = 10000, G = 1, k = 12288)$`。\n-   `$S = 268435456 + 1 \\cdot 4096 = 268439552$`。\n-   `$L' = ((10000 + 4096 - 1) / 4096) \\cdot 4096 = (14095 / 4096) \\cdot 4096 = 3 \\cdot 4096 = 12288$`。\n-   条件 `$0 \\le k  L'$` 变为 `$0 \\le 12288  12288$`，此为假。\n-   输出是引发故障的地址 `$X = S + k = 268439552 + 12288 = 268451840$`。\n\n对于测试用例4：`$(B = 268435456, P = 4096, N = 10000, G = 1, k = -16)$`。\n-   `$S = 268439552$`。\n-   `$L' = 12288$`。\n-   条件 `$0 \\le k  L'$` 变为 `$0 \\le -16  12288$`，此为假。\n-   输出是引发故障的地址 `$X = S + k = 268439552 - 16 = 268439536$`。\n\n将定义的规则系统性地应用于所有提供的测试用例，将产生所需的输出列表。", "answer": "[0, 0, 268451840, 268439536, 0, 0, 269439552, 536875008, 536870912, 536869888, 0, 805318656]", "id": "3658310"}]}