{"hands_on_practices": [{"introduction": "当一个新进程启动时，操作系统面临一个关键决策：如何为其分配内存？这个练习让你量化本地和全局分配策略在这种场景下的核心权衡。通过计算新进程的启动延迟和对现有进程造成的干扰，你将从根本上理解全局策略的灵活性以及它可能带来的系统稳定性代价 [@problem_id:3645334]。", "problem": "考虑一个简化的操作系统 (OS) 内存管理模型，其中物理内存被划分为大小相同的帧。在新进程到达之前，系统中存在 $m$ 个现有进程，它们具有稳定的驻留工作集。每个现有进程 $i$ 当前分配了 $A_i$ 个帧，其工作集大小为 $W_i$ 页，且完全驻留在内存中，并满足不变量 $A_i \\geq W_i$。系统中的总帧数为 $F$，空闲帧的数量为 $F_{\\text{free}} = F - \\sum_{i=1}^{m} A_i$。一个新进程到达，其工作集大小为 $W_{\\text{new}}$ 页，这些页最初都不在内存中。\n\n使用以下基本原理来推断启动行为：\n- 工作集模型：工作集是在一个时间窗口内活跃使用的页的集合，每个这样的页都需要一个驻留帧。\n- 当引用的页未驻留内存时，会发生缺页中断；将其调入内存会消耗一个帧。\n- 在局部置换策略下，现有进程永远不会因为新进程而失去帧；新进程只能使用 $F_{\\text{free}}$。\n- 在全局置换策略下，新进程可以从现有进程借用帧。从现有进程已分配但其工作集之外的未使用部分借用的帧不会干扰它们。如果借用的帧超出了这些未使用部分，则会从现有进程的工作集中驱逐页面，当这些被驱逐的页面下次被引用时，会导致额外的缺页中断。\n\n将新进程的冷启动延迟定义为在给定分配策略下，为了在启动期间使其工作集驻留内存而必须引发缺页中断的不同页面的数量。将干扰定义为在预热期间，由于新进程从其他进程的工作集中驱逐页面而导致这些进程产生的额外缺页中断的总数。\n\n任务：实现一个程序，为每个测试用例计算三个整数：\n- $L_{\\text{local}}$：局部置换策略下的冷启动延迟。如果新进程仅使用 $F_{\\text{free}}$ 帧无法使其整个工作集驻留内存，则设置 $L_{\\text{local}} = -1$。\n- $L_{\\text{global}}$：全局置换策略下的冷启动延迟，假设系统在启动期间可以根据需要从当前已分配的帧中借用帧，直至达到物理内存上限。\n- $D_{\\text{global}}$：全局置换策略下的总干扰，量化为在预热期间因从其他进程的工作集中驱逐页面而导致的额外缺页中断次数。\n\n您的程序必须仅使用上述定义，从第一性原理出发计算这些值。对于每个测试用例，给定 $F$、$m$、向量 $A = [A_1, A_2, \\dots, A_m]$、$W = [W_1, W_2, \\dots, W_m]$ 和 $W_{\\text{new}}$。\n\n测试套件（每行为一个独立的测试用例）：\n- 案例 1：$F = 32$, $m = 2$, $A = [12, 10]$, $W = [10, 8]$, $W_{\\text{new}} = 14$。\n- 案例 2：$F = 32$, $m = 2$, $A = [14, 14]$, $W = [12, 12]$, $W_{\\text{new}} = 16$。\n- 案例 3：$F = 40$, $m = 3$, $A = [10, 10, 10]$, $W = [8, 9, 7]$, $W_{\\text{new}} = 9$。\n- 案例 4：$F = 20$, $m = 2$, $A = [9, 9]$, $W = [9, 9]$, $W_{\\text{new}} = 18$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个内部列表对应一个测试用例，并按 $[L_{\\text{local}}, L_{\\text{global}}, D_{\\text{global}}]$ 的顺序排列。例如，输出必须类似于 $[[x_1,y_1,z_1],[x_2,y_2,z_2],\\dots]$，不含空格。", "solution": "问题陈述已经过严格验证，被认为是自洽的、科学上基于操作系统内存管理原理的，并且是适定的。所有提供的数据和定义都是一致且充分的，足以推导出唯一且有意义的解。\n\n任务是为一个到达拥有 $m$ 个现有进程的系统的新进程计算三个量：局部置换策略下的冷启动延迟 ($L_{\\text{local}}$)、全局置换策略下的冷启动延迟 ($L_{\\text{global}}$) 以及全局置换策略下的全系统干扰 ($D_{\\text{global}}$)。分析从问题陈述中给出的第一性原理出发。\n\n设一个测试用例的给定参数为：\n- $F$：物理内存总帧数。\n- $m$：现有进程数。\n- $A_i$：分配给现有进程 $i$ 的帧数，其中 $i \\in \\{1, \\dots, m\\}$。\n- $W_i$：现有进程 $i$ 的工作集大小（以页为单位），其中 $i \\in \\{1, \\dots, m\\}$。\n- $W_{\\text{new}}$：新进程的工作集大小（以页为单位）。\n\n根据这些给定条件，我们可以推导出几个描述新进程到达前系统状态的关键量。\n1.  分配给现有进程的总帧数是它们各自所分配帧数的总和：\n    $$A_{\\text{total}} = \\sum_{i=1}^{m} A_i$$\n2.  系统中可用的空闲帧数是总帧数减去已分配的帧数：\n    $$F_{\\text{free}} = F - A_{\\text{total}}$$\n3.  现有进程工作集占用的总帧数是：\n    $$W_{\\text{total}} = \\sum_{i=1}^{m} W_i$$\n\n在确定了这些量之后，我们可以推导出所需的值。\n\n**1. 局部置换策略下的冷启动延迟 ($L_{\\text{local}}$)**\n\n在局部置换策略下，新进程仅限于使用空闲池中的帧 $F_{\\text{free}}$。现有进程的帧分配不受影响。新进程需要 $W_{\\text{new}}$ 个帧来使其工作集驻留内存。\n\n- 如果空闲帧数足以容纳新进程的整个工作集 ($F_{\\text{free}} \\geq W_{\\text{new}}$)，那么该进程的 $W_{\\text{new}}$ 个页每页都会产生一次缺页中断。因此，其冷启动延迟等于其工作集大小。\n  $$L_{\\text{local}} = W_{\\text{new}} \\quad \\text{if } F_{\\text{free}} \\geq W_{\\text{new}}$$\n- 如果空闲帧数不足 ($F_{\\text{free}}  W_{\\text{new}}$)，新进程无法使其工作集驻留内存。根据问题对此场景的明确指示，延迟被设置为一个标记值。\n  $$L_{\\text{local}} = -1 \\quad \\text{if } F_{\\text{free}}  W_{\\text{new}}$$\n\n结合这两个条件，$L_{\\text{local}}$ 的公式为：\n$$L_{\\text{local}} = \\begin{cases} W_{\\text{new}}  \\text{if } F - \\sum_{i=1}^{m} A_i \\geq W_{\\text{new}} \\\\ -1  \\text{otherwise} \\end{cases}$$\n\n**2. 全局置换策略下的冷启动延迟 ($L_{\\text{global}}$)**\n\n冷启动延迟被定义为“为使其工作集驻留内存而必须引发缺页中断的不同页面的数量”。新进程到达时，其工作集中的所有 $W_{\\text{new}}$ 个页都不在内存中。要将每个唯一的页调入一个帧，每页都必须产生一次缺页中断。在全局策略下，系统可以通过从任何进程重新分配帧来提供帧。因此，无论后续系统的稳定性或可能发生的颠簸，新进程为加载其工作集而产生的初始中断数就是其工作集的大小。\n$$L_{\\text{global}} = W_{\\text{new}}$$\n\n**3. 全局置换策略下的干扰 ($D_{\\text{global}}$)**\n\n干扰是由于新进程从其他进程的工作集中驱逐页面而导致这些进程产生的额外缺页中断的总数。为了计算这个值，我们必须确定新进程需要多少帧以及操作系统将从何处获取这些帧。操作系统会以最小化干扰的顺序回收帧。\n\n新进程需要 $W_{\\text{new}}$ 个帧。可用的来源按优先顺序列出：\n1.  **空闲帧**：有 $F_{\\text{free}}$ 个帧可用，不会对其他进程造成成本。\n2.  **剩余帧**：这些是分配给现有进程但不属于其工作集的帧。剩余帧的总数为 $S_{\\text{total}} = \\sum_{i=1}^{m} (A_i - W_i)$。回收这些帧不会引起干扰。\n\n可以在不引起干扰的情况下回收的总帧数是空闲帧和剩余帧的总和：\n$$N_{\\text{no-disrupt}} = F_{\\text{free}} + S_{\\text{total}} = \\left(F - \\sum_{i=1}^{m} A_i\\right) + \\left(\\sum_{i=1}^{m} A_i - \\sum_{i=1}^{m} W_i\\right) = F - W_{\\text{total}}$$\n这清楚地表明，所有不属于现有工作集活跃部分的帧都可以在不引起干扰的情况下被使用。\n\n如果新进程的需求 $W_{\\text{new}}$ 超过了这个池 ($W_{\\text{new}} > N_{\\text{no-disrupt}}$)，系统就必须从现有进程的工作集中回收剩余的帧。以这种方式必须窃取的帧数直接对应于干扰 $D_{\\text{global}}$。\n\n帧的缺口为：\n$$N_{\\text{deficit}} = W_{\\text{new}} - N_{\\text{no-disrupt}} = W_{\\text{new}} - (F - W_{\\text{total}}) = W_{\\text{new}} + W_{\\text{total}} - F$$\n只有当这个缺口为正时才会发生干扰。因此，\n$$D_{\\text{global}} = \\max(0, N_{\\text{deficit}}) = \\max(0, W_{\\text{new}} + W_{\\text{total}} - F)$$\n这代表了为满足新进程的内存需求而从进程 1 到 $m$ 的工作集中被驱逐的页面数量。", "answer": "[[-1,14,0],[-1,16,8],[9,9,0],[-1,18,16]]", "id": "3645334"}, {"introduction": "理论分析之后，让我们通过编写代码来深入探索页面分配的动态过程。在这个练习中，你将模拟两种具有不同内存访问模式的进程——一个顺序扫描的“流式”进程和一个在小工作集上循环的“循环”进程 [@problem_id:3645321]。通过亲手实现和观察，你将直观地感受到全局分配策略如何成为一把双刃剑，它可能帮助一个进程，却同时损害另一个进程的性能。", "problem": "考虑一个双进程虚拟内存系统，在该系统中，虚拟内存页面被映射到一组有限的物理帧中。其基本出发点是缺页中断的定义：当一个进程引用一个当前未驻留在任何物理帧中的虚拟页时，系统会发生一次缺页中断，并且必须将该页面加载到一个帧中，这可能需要根据页面置换策略来置换一个现有页面。我们将使用最近最少使用 (LRU) 策略，该策略会置换最后访问时间最久远的页面。我们定义两种帧分配策略：局部（本地）分配，其中每个进程只从其自己分配的帧中进行置换；以及全局分配，其中所有帧都被汇集在一起，置换可以移除属于任何进程的页面。\n\n您需要模拟两种特定进程在两种策略下的行为：\n- 一个流式进程，它顺序扫描一组唯一的页面，并可能重复此扫描多次。\n- 一个循环进程，它在一组固定的工作集页面上重复循环。\n\n核心定义：\n- 设流式进程的工作集大小为 $U_s$ 个不同页面。它对这 $U_s$ 个页面执行 $P_s$ 次顺序扫描，总共产生 $T_s = U_s \\cdot P_s$ 次引用。在每次扫描中，它严格按照 $0, 1, 2, \\dots, (U_s - 1)$ 的顺序引用页面。\n- 设循环进程的工作集大小为 $U_l$ 个不同页面。它对这 $U_l$ 个页面执行 $P_l$ 次完整循环，总共产生 $T_l = U_l \\cdot P_l$ 次引用。在每次循环中，它严格按照 $0, 1, 2, \\dots, (U_l - 1)$ 的顺序引用页面。\n- 交错调度：在每个周期中，系统首先从流式进程发出 $q_s$ 次引用（如果还有剩余引用），然后从循环进程发出 $q_l$ 次引用（如果还有剩余引用），并重复此周期，直到两个进程都完成其总引用次数 $T_s$ 和 $T_l$。当一个进程提前完成时，另一个进程将独自继续执行。\n- 在局部（本地）分配下，流式进程拥有 $f_s$ 个帧，循环进程拥有 $f_l$ 个帧；页面置换只在所属进程的帧内发生。在全局分配下，两个进程共享总共 $F$ 个帧；页面置换可以置换任何进程的任何页面。\n- 我们假设有一个单一的全局时钟用于 LRU：每次引用都会使一个全局时间计数器递增，LRU 的牺牲页是最后访问时间戳最小的页面。若时间戳相同，则选择最后访问时间值最小的页面（这在 LRU 下是等效的）。一个页面只有在它的进程标识和页号都匹配时才被认为是相同的；来自不同进程的页面即使页号相同也是不同的。\n\n您的任务是使用 C 语言实现一个完整的、可运行的程序，该程序能够：\n1. 模拟上述定义的局部（本地）和全局分配策略。\n2. 在每种策略下，分别为流式进程和循环进程统计缺页中断次数。\n3. 对每个测试用例，根据以下判断条件，确定全局分配是否对流式进程有帮助，以及是否破坏了循环进程：\n   - 当且仅当 $PF^{G}_s  PF^{L}_s$ 时，全局分配对流式进程有帮助，其中 $PF^{G}_s$ 和 $PF^{L}_s$ 分别表示流式进程在全局和局部（本地）分配策略下的缺页中断次数。\n   - 当且仅当 $PF^{G}_l > PF^{L}_l$ 时，全局分配破坏了循环进程，其中 $PF^{G}_l$ 和 $PF^{L}_l$ 分别表示循环进程在全局和局部（本地）分配策略下的缺页中断次数。\n\n为以下测试套件提供结果。每个测试用例由 $(U_s, P_s, U_l, P_l, f_s, f_l, F, q_s, q_l)$ 指定，所有量均为非负整数，且 $F \\ge f_s + f_l$ 以维持物理上的一致性：\n- 测试用例 1：$(U_s, P_s, U_l, P_l, f_s, f_l, F, q_s, q_l) = (50, 2, 5, 20, 3, 5, 60, 5, 1)$。\n- 测试用例 2：$(U_s, P_s, U_l, P_l, f_s, f_l, F, q_s, q_l) = (40, 2, 6, 30, 3, 6, 20, 8, 1)$。\n- 测试用例 3：$(U_s, P_s, U_l, P_l, f_s, f_l, F, q_s, q_l) = (20, 2, 10, 30, 10, 10, 20, 1, 1)$。\n- 测试用例 4：$(U_s, P_s, U_l, P_l, f_s, f_l, F, q_s, q_l) = (30, 1, 10, 40, 3, 10, 13, 20, 1)$。\n\n输出规范：\n- 对于每个测试用例，计算两个布尔值：$b_1$ 表示全局分配是否对流式进程有帮助（如果是则为 $1$，否则为 $0$），$b_2$ 表示全局分配是否破坏了循环进程（如果是则为 $1$，否则为 $0$）。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个包含两个整数的列表 $[b_1, b_2]$。例如，总输出必须具有确切的形式 $$[[b_{1,1}, b_{1,2}], [b_{2,1}, b_{2,2}], [b_{3,1}, b_{3,2}], [b_{4,1}, b_{4,2}]]$$ 不得添加空格或任何额外文本。\n该问题不涉及任何物理单位或角度；所有输出都是无单位的整数。最终程序必须是自包含的，并且不得读取输入。", "solution": "该问题已经过验证，被认为是定义明确、有科学依据且内部一致的。它提出了一个操作系统领域的标准模拟任务，所有参数和行为都得到了清晰和形式化的定义。没有发现逻辑矛盾、歧义或事实不健全之处。\n\n该问题要求在两种不同的内存帧分配策略（局部和全局）下模拟一个双进程系统。目标是量化每个进程在每种策略下的缺页中断次数，并比较结果。模拟将由一个流式进程 $S$ 和一个循环进程 $L$ 生成的确定性引用串驱动。\n\n解决方案的核心是一个离散时间事件模拟。一个由变量 `time` 表示的全局时钟，在每次内存引用时递增。物理内存的状态由一个数据结构数组表示，每个数据结构对应一个物理帧。一个 `Frame` 结构必须包含：\n1.  `process_id`：所属进程的标识符（流式进程为 $0$，循环进程为 $1$）。哨兵值 $-1$ 可表示空闲帧。\n2.  `page_num`：存储在帧中的虚拟页号。\n3.  `last_used_time`：该页面最后一次被引用时的全局时钟值。这对于实现最近最少使用 (LRU) 置换策略至关重要。\n\n模拟通过根据指定的交错调度生成内存引用来进行。对于在时间 $t$ 对虚拟页 $(p_{id}, p_{num})$ 的每次引用，其中 $p_{id}$ 是进程ID，$p_{num}$ 是页号，系统必须检查此页面是否驻留在物理帧中。\n\n-   **页命中**：如果页面 $(p_{id}, p_{num})$ 在一个帧中被找到，则为页命中。唯一需要的操作是将该帧的 `last_used_time` 更新为当前时间 $t$。\n\n-   **缺页中断**：如果未找到页面，则发生缺页中断。进程 $p_{id}$ 的缺页中断计数器递增。然后系统必须将该页面加载到一个帧中。\n    1.  **寻找目标帧**：系统首先搜索一个空闲帧（其中 `process_id` 为 $-1$）。如果找到可用空闲帧，则选择它作为目标。\n    2.  **LRU 置换**：如果相关池中的所有帧都已被占用，则调用 LRU 策略。具有最小 `last_used_time` 值的帧被识别为牺牲页。这是最长时间未被使用的帧。\n    3.  **加载页面**：将新页面 $(p_{id}, p_{num})$ 及其引用时间 $t$ 加载到目标帧中（新找到的空闲帧或牺牲帧），覆盖其先前的内容。\n\n模拟必须针对两种不同的策略配置执行：\n\n1.  **局部（本地）分配**：维护两个独立的帧池。一个大小为 $f_s$ 的池用于流式进程 ($S$)，另一个大小为 $f_l$ 的池用于循环进程 ($L$)。当进程 $S$ 发生缺页中断时，寻找空闲帧或 LRU 牺牲页的操作完全限制在其专用的 $f_s$ 个帧的池中。类似地，进程 $L$ 只使用其 $f_l$ 个帧。这将进程彼此的内存访问行为隔离开来。\n\n2.  **全局分配**：一个大小为 $F$ 的单一共享帧池可供两个进程使用。当任一进程发生缺页中断时，寻找空闲帧或 LRU 牺牲页的操作在整个 $F$ 帧池中进行。这意味着进程 $S$ 的一个页面可能被置换以便为进程 $L$ 的一个页面腾出空间，反之亦然。LRU 牺牲页是整个系统中最久未被使用的页面，无论它属于哪个进程。\n\n主模拟驱动程序根据流式进程的参数 $(U_s, P_s, q_s)$ 和循环进程的参数 $(U_l, P_l, q_l)$ 生成引用序列。它以周期方式迭代，为进程 $S$ 发出 $q_s$ 次引用，然后为进程 $L$ 发出 $q_l$ 次引用，直到两个进程都完成其总引用次数 $T_s = U_s \\cdot P_s$ 和 $T_l = U_l \\cdot P_l$。流式进程的第 $k$ 次引用（0-索引）是针对页面 $k \\pmod{U_s}$，循环进程的第 $k$ 次引用是针对页面 $k \\pmod{U_l}$。\n\n对于每个测试用例，我们首先在局部（本地）分配下运行模拟，以获得缺页中断次数 $PF^{L}_s$ 和 $PF^{L}_l$。然后我们重置系统，在全局分配下再次运行模拟，以获得 $PF^{G}_s$ 和 $PF^{G}_l$。最后，我们计算两个布尔指标：\n-   `全局分配对流式进程有帮助`，$b_1$，如果 $PF^{G}_s  PF^{L}_s$ 则为 $1$，否则为 $0$。\n-   `全局分配破坏了循环进程`，$b_2$，如果 $PF^{G}_l > PF^{L}_l$ 则为 $1$，否则为 $0$。\n\n程序将对所有指定的测试用例执行此过程，并将结果格式化为单行的布尔值对列表。", "answer": "[[1,0],[1,1],[0,1],[1,1]]", "id": "3645321"}, {"introduction": "纯粹的本地或全局策略代表了两种极端。这个练习将引导你探索一种更精妙的混合方法，它结合了本地分配的稳定性和全局分配的灵活性 [@problem_id:3645310]。你将学习如何将帧分配问题形式化为一个优化问题，并运用贪心策略来最小化系统的总缺页率，这是一种在资源管理中非常强大的技术。", "problem": "考虑一个操作系统（OS）在一种称为“预留之上全局分配”的混合帧分配策略下管理 $N$ 个并发进程。每个进程 $i$ 必须保证获得最少 $k_i$ 个页框的预留，而超出这些预留的所有页框则进行全局分配，以优化系统性能。\n\n从以下基本定义和广为接受的事实出发：\n- “局部”帧分配策略独立地为每个进程固定其页框数，而“全局”策略则允许进程竞争一个共享的页框池。\n- 对于给定的进程 $i$，其稳态缺页率 $f_i(m)$ 是分配给它的页框数 $m$ 的递减函数。超出进程工作集的额外页框通常产生递减的收益。\n\n给定 $N=3$ 个进程和总共 $M=15$ 个物理页框。每个进程的预留量为 $k_1=3$，$k_2=2$ 和 $k_3=4$。定义分配给进程 $i$ 的页框为 $m_i$，其约束条件为 $m_i \\geq k_i$ 且 $\\sum_{i=1}^{N} m_i = M$。设额外页框 $e_i$ 定义为 $e_i = m_i - k_i \\geq 0$，因此 $\\sum_{i=1}^{N} e_i = M - \\sum_{i=1}^{N} k_i$。\n\n在“预留之上全局分配”策略下，系统首先分配预留页框，然后分配额外的页框，以最小化总稳态缺页率 $\\sum_{i=1}^{N} f_i(m_i)$。对于每个进程 $i$，在预留分配下的缺页率为 $f_i(k_i) = f_{i,0}$，分配给进程 $i$ 的每个额外页框 $j$ 会使其缺页率产生一个边际减少量 $r_{i,j}$。假设对于每个进程 $i$，序列 $\\{r_{i,j}\\}$ 关于 $j$ 是非递增的（收益递减），并且超出所列出的 $r_{i,j}$ 值之外的额外页框产生的边际减少量为零。\n\n参数如下：\n- $f_{1,0} = 0.30$, $r_{1,1} = 0.08$, $r_{1,2} = 0.06$, $r_{1,3} = 0.05$, $r_{1,4} = 0.02$.\n- $f_{2,0} = 0.40$, $r_{2,1} = 0.12$, $r_{2,2} = 0.07$, $r_{2,3} = 0.03$.\n- $f_{3,0} = 0.25$, $r_{3,1} = 0.09$, $r_{3,2} = 0.04$.\n\n任务：\n1. 将此混合的“预留之上全局分配”策略形式化为一个关于额外页框 $e_i$ 的优化问题，该问题在满足预留约束的条件下最小化 $\\sum_{i=1}^{N} f_i(m_i)$。\n2. 使用提供的 $f_{i,0}$ 和 $r_{i,j}$ 值，计算在此策略下 $\\sum_{i=1}^{N} f_i(m_i)$ 的最小值。\n\n将您的最终数值答案表示为四舍五入到四位有效数字的小数。不要使用百分号；将所有缺页率视为无量纲分数。", "solution": "该问题被验证为具有科学依据、良构、客观和完整。它代表了操作系统领域内一个标准的资源分配问题。\n\n### 第1步：优化问题的形式化\n\n目标是最小化总稳态缺页率，记为 $F$，它是每个进程各自缺页率的总和：\n$$\nF = \\sum_{i=1}^{N} f_i(m_i)\n$$\n其中 $N=3$ 是进程数，$m_i$ 是分配给进程 $i$ 的页框数。\n\n总页框数为 $M=15$。分配必须满足所有页框都被使用的约束条件：\n$$\n\\sum_{i=1}^{N} m_i = M\n$$\n\n每个进程 $i$ 都有一个 $k_i$ 帧的保证最小预留量，因此分配还必须遵守以下约束：\n$$\nm_i \\geq k_i \\quad \\text{for } i=1, 2, \\dots, N\n$$\n\n我们将分配给进程 $i$ 超出其预留量的“额外”页框数定义为 $e_i = m_i - k_i$。根据定义，$e_i \\geq 0$。将 $m_i = k_i + e_i$ 代入总页框约束可得：\n$$\n\\sum_{i=1}^{N} (k_i + e_i) = M \\implies \\sum_{i=1}^{N} e_i = M - \\sum_{i=1}^{N} k_i\n$$\n这个总和代表了可供全局分配的额外页框总池，记为 $E$。\n\n拥有 $m_i = k_i + e_i$ 个页框的进程 $i$ 的缺页率，由其在预留水平上的缺页率 $f_{i,0} = f_i(k_i)$ 减去由 $e_i$ 个额外页框带来的累积减少量给出：\n$$\nf_i(m_i) = f_i(k_i + e_i) = f_{i,0} - \\sum_{j=1}^{e_i} r_{i,j}\n$$\n其中 $r_{i,j}$ 是分配给进程 $i$ 的第 $j$ 个额外页框带来的边际减少量。\n\n现在，总缺页率可以表示为额外页框分配 $e_i$ 的函数：\n$$\nF(e_1, \\dots, e_N) = \\sum_{i=1}^{N} \\left( f_{i,0} - \\sum_{j=1}^{e_i} r_{i,j} \\right) = \\left(\\sum_{i=1}^{N} f_{i,0}\\right) - \\left(\\sum_{i=1}^{N} \\sum_{j=1}^{e_i} r_{i,j}\\right)\n$$\n第一项 $\\sum_{i=1}^{N} f_{i,0}$ 是一个基于初始预留分配的常数。因此，最小化总缺页率 $F$ 等价于最大化总缺页率减少量 $R$：\n$$\n\\text{Maximize } R(e_1, \\dots, e_N) = \\sum_{i=1}^{N} \\sum_{j=1}^{e_i} r_{i,j}\n$$\n形式化的优化问题是找到非负整数 $e_1, e_2, \\dots, e_N$，在约束条件 $\\sum_{i=1}^{N} e_i = M - \\sum_{i=1}^{N} k_i$ 下最大化 $R$。\n\n### 第2步：最小化缺页率的计算\n\n首先，我们计算可用于全局分配的额外页框总数。\n预留量为 $k_1 = 3$, $k_2 = 2$, $k_3 = 4$。预留页框的总数是：\n$$\n\\sum_{i=1}^{3} k_i = 3 + 2 + 4 = 9\n$$\n在总共有 $M = 15$ 个物理页框的情况下，需要分配的额外页框数量是：\n$$\nE = M - \\sum_{i=1}^{3} k_i = 15 - 9 = 6\n$$\n问题现在简化为分配这6个额外页框。由于每个进程的边际收益 $\\{r_{i,j}\\}$ 是非递增的，一个总是将下一个页框分配给提供最高边际减少量的进程的贪心算法将产生一个最优解。\n\n我们列出所有可用的边际减少量 $r_{i,j}$：\n- 进程 1: $r_{1,1} = 0.08$, $r_{1,2} = 0.06$, $r_{1,3} = 0.05$, $r_{1,4} = 0.02$\n- 进程 2: $r_{2,1} = 0.12$, $r_{2,2} = 0.07$, $r_{2,3} = 0.03$\n- 进程 3: $r_{3,1} = 0.09$, $r_{3,2} = 0.04$\n\n我们开始贪心地分配这6个页框：\n\n1.  **分配 1:** 可用的最大减少量是 $r_{2,1} = 0.12$。将第1个额外页框分配给进程2。\n    - 目前总减少量: $0.12$。剩余页框数: $5$。\n\n2.  **分配 2:** 下一个可用的最大减少量是 $r_{3,1} = 0.09$。将第2个额外页框分配给进程3。\n    - 目前总减少量: $0.12 + 0.09 = 0.21$。剩余页框数: $4$。\n\n3.  **分配 3:** 下一个最大的是 $r_{1,1} = 0.08$。将第3个额外页框分配给进程1。\n    - 目前总减少量: $0.21 + 0.08 = 0.29$。剩余页框数: $3$。\n\n4.  **分配 4:** 下一个最大的是 $r_{2,2} = 0.07$ (来自进程2)。将第4个额外页框分配给进程2。\n    - 目前总减少量: $0.29 + 0.07 = 0.36$。剩余页框数: $2$。\n\n5.  **分配 5:** 下一个最大的是 $r_{1,2} = 0.06$ (来自进程1)。将第5个额外页框分配给进程1。\n    - 目前总减少量: $0.36 + 0.06 = 0.42$。剩余页框数: $1$。\n\n6.  **分配 6:** 下一个最大的是 $r_{1,3} = 0.05$ (来自进程1)。将第6个额外页框分配给进程1。\n    - 目前总减少量: $0.42 + 0.05 = 0.47$。剩余页框数: $0$。\n\n6个额外页框的分配完成。最大化的总减少量为 $R_{max} = 0.47$。\n\n额外页框的最终分配是：\n- 进程 1: $e_1 = 3$ 个页框\n- 进程 2: $e_2 = 2$ 个页框\n- 进程 3: $e_3 = 1$ 个页框\n\n每个进程的总页框数是：\n- $m_1 = k_1 + e_1 = 3 + 3 = 6$\n- $m_2 = k_2 + e_2 = 2 + 2 = 4$\n- $m_3 = k_3 + e_3 = 4 + 1 = 5$\n\n仅分配预留页框时的初始总缺页率是：\n$$\n\\sum_{i=1}^{3} f_{i,0} = f_{1,0} + f_{2,0} + f_{3,0} = 0.30 + 0.40 + 0.25 = 0.95\n$$\n最小化的总缺页率是初始缺页率减去最大总减少量：\n$$\nF_{min} = \\left(\\sum_{i=1}^{3} f_{i,0}\\right) - R_{max} = 0.95 - 0.47 = 0.48\n$$\n为了验证，我们可以计算每个进程的最终缺页率：\n- $f_1(6) = f_{1,0} - (r_{1,1} + r_{1,2} + r_{1,3}) = 0.30 - (0.08 + 0.06 + 0.05) = 0.30 - 0.19 = 0.11$\n- $f_2(4) = f_{2,0} - (r_{2,1} + r_{2,2}) = 0.40 - (0.12 + 0.07) = 0.40 - 0.19 = 0.21$\n- $f_3(5) = f_{3,0} - r_{3,1} = 0.25 - 0.09 = 0.16$\n\n最小化的总缺页率是这些各自缺页率的总和：\n$$\nF_{min} = f_1(6) + f_2(4) + f_3(5) = 0.11 + 0.21 + 0.16 = 0.48\n$$\n问题要求答案四舍五入到四位有效数字，即 $0.4800$。", "answer": "$$\\boxed{0.4800}$$", "id": "3645310"}]}