{"hands_on_practices": [{"introduction": "在深入研究多级页表的复杂性之前，我们首先需要掌握一个基本概念：页表层次结构如何划分虚拟地址空间。这个练习将帮助你理解顶层页目录条目与它所能覆盖的地址空间大小之间的直接关系。通过一个简化的场景，你将推导出一个基本公式，用于计算映射一个给定大小的内存区域需要多少顶层条目[@problem_id:3647771]。", "problem": "考虑一个由虚拟内存子系统使用的二级分层分页方案。顶层结构是页目录（PD），第二层结构是页表（PT）。页目录（PD）包含多个条目，每个条目恰好引用一个页表（PT）。每个页表（PT）包含 $E_{2}$ 个条目。每个页表条目映射一个大小为 $P$ 字节的页面。根据构造，单个页目录条目因此管理着一段大小为 $A$ 的连续虚拟地址空间，其中 $A = E_{2} \\times P$。由页目录条目管理的地址范围互不重叠，并在 $A$ 的整数倍边界处划分虚拟地址空间。\n\n假设一个进程需要映射一个大小为 $R$ 字节的连续虚拟内存区域。该区域的起始地址与 $A$ 对齐，意味着起始地址是 $A$ 的整数倍。任何覆盖该区域至少一个字节的页目录条目都必须存在（它可能引用一个部分填充的页表），并且即使其对应的页表仅被部分使用，页目录条目也会被计入总数。假设 $R > 0$ 且 $A > 0$。\n\n仅使用上面给出的分层分页定义以及起始地址与 $A$ 对齐会将区域的起始点置于页目录边界这一事实，推导出一个封闭形式的解析表达式，用于计算覆盖整个区域所需的最少顶层条目数，记为 $n_{\\text{top}}$。最终答案仅用 $R$ 和 $A$ 表示。不需要进行数值舍入。", "solution": "用户请求解答一个关于虚拟内存系统中分层分页的问题。第一步是验证问题陈述。\n\n### 步骤 1：提取已知条件\n- 系统使用二级分层分页方案。\n- 顶层结构是页目录（PD）。\n- 第二层结构是页表（PT）。\n- 每个PD条目引用一个PT。\n- 每个PT包含 $E_{2}$ 个条目。\n- 每个PT条目映射一个大小为 $P$ 字节的页面。\n- 单个PD条目管理一段大小为 $A$ 的连续虚拟地址空间，其中 $A = E_{2} \\times P$。\n- PD条目所管理的地址范围互不重叠，并在 $A$ 的整数倍边界处划分虚拟地址空间。\n- 一个进程需要映射一个大小为 $R$ 字节的连续虚拟内存区域。\n- 该区域的起始地址与 $A$ 对齐（即，它是 $A$ 的整数倍）。\n- 任何覆盖该区域至少一个字节的PD条目都必须存在。\n- $R > 0$ 且 $A > 0$。\n- 目标是找到覆盖该区域所需的最少顶层条目数 $n_{\\text{top}}$ 的封闭形式表达式，用 $R$ 和 $A$ 表示。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据指定标准对问题进行验证。\n\n- **科学依据**：该问题描述了一个简化但标准的分层分页模型，这是操作系统中的一个基本概念。页目录、页表、页面大小和地址空间划分之间的关系与既定的计算机体系结构和操作系统原理相符。该问题在科学上是合理的。\n- **适定性**：该问题要求在明确的约束条件下（连续区域、特定大小 $R$ 以及起始地址与 $A$ 对齐）所需的最少条目数。参数 $R$ 和 $A$ 已给出，目标是求 $n_{\\text{top}}$。对齐约束简化了情景，确保了唯一最小解的存在。\n- **客观性**：该问题使用精确的技术语言陈述（例如，“连续虚拟内存区域”、“与 $A$ 对齐”、“不重叠”）。没有主观或含糊不清的术语。\n- **不完整或矛盾的设置**：该问题提供了确定顶层条目数所需的所有必要信息。要映射的区域大小（$R$）和单个顶层条目所跨越的地址空间大小（$A$）是计算所需的唯一变量，且都以符号形式给出。起始地址的对齐是一个关键且不矛盾的约束。\n- **不切实际或不可行**：该模型是一个抽象，但并非物理上不可能或科学上难以置信。它代表了一个有效但理想化的内存管理情景。\n- **其他缺陷**：该问题不是比喻性的、琐碎的、同义反复的，也不在科学可验证性范围之外。这是一个需要基于所提供模型进行逻辑推导的形式化问题。\n\n### 步骤 3：结论与行动\n问题是有效的。可以开始对解进行严格推导。\n\n### 解题推导\n\n目标是找到映射一个大小为 $R$ 字节的连续内存区域所需的最小顶层页目录条目数 $n_{\\text{top}}$。\n\n假设虚拟地址空间由一条从地址 $0$ 开始的数轴表示。顶层页目录条目将此空间划分为连续、不重叠的块。每个块（或范围）的大小为 $A$。这些范围的边界出现在地址 $0, A, 2A, 3A, \\dots, kA, \\dots$ 处，其中 $k$ 为非负整数。第 $k$ 个这样的范围（对于 $k \\ge 0$）覆盖虚拟地址区间 $[kA, (k+1)A)$。\n\n问题陈述，要映射的内存区域大小为 $R$，其起始地址与 $A$ 对齐。设该区域的起始地址为 $S$。对齐约束意味着 $S$ 是 $A$ 的整数倍。因此，我们可以写出 $S = m \\cdot A$，其中 $m$ 是某个非负整数。\n\n从地址 $S$ 开始的大小为 $R$ 的连续区域占据了虚拟地址的半开区间 $[S, S+R)$。代入 $S = m \\cdot A$，该区域为 $[m \\cdot A, m \\cdot A + R)$。\n\n我们需要找到覆盖整个区域所需的最少顶层条目数 $n_{\\text{top}}$。由于该区域的起始点恰好位于一个页目录条目所管理的范围的边界上，因此所需的第一个条目就是覆盖从 $S = m \\cdot A$ 开始的那个范围的条目。\n\n设 $n_{\\text{top}}$ 是使用的连续顶层条目的数量。这些条目将从用于范围 $[m \\cdot A, (m+1)A)$ 的那个开始，总共持续 $n_{\\text{top}}$ 个条目。这 $n_{\\text{top}}$ 个连续条目所覆盖的总虚拟地址范围将从起始地址 $S$ 到 $S + n_{\\text{top}} \\cdot A$。也就是说，它们覆盖了地址区间 $[S, S + n_{\\text{top}} \\cdot A)$。\n\n要映射大小为 $R$ 的整个区域，它所占据的地址范围 $[S, S+R)$ 必须是已分配的页目录条目所覆盖的地址范围 $[S, S + n_{\\text{top}} \\cdot A)$ 的子集。\n$$[S, S+R) \\subseteq [S, S + n_{\\text{top}} \\cdot A)$$\n当且仅当该区域区间的结束点小于或等于所覆盖区间的结束点时，此子集条件才满足。\n$$S + R \\le S + n_{\\text{top}} \\cdot A$$\n从不等式两边减去 $S$ 得：\n$$R \\le n_{\\text{top}} \\cdot A$$\n由于问题指定 $A > 0$，我们可以用 $A$ 除以两边而不改变不等号的方向：\n$$n_{\\text{top}} \\ge \\frac{R}{A}$$\n变量 $n_{\\text{top}}$ 代表页目录条目的数量，因此它必须是一个整数。我们正在寻找*最少*的条目数，这意味着我们必须找到满足条件 $n_{\\text{top}} \\ge \\frac{R}{A}$ 的最小整数 $n_{\\text{top}}$。\n\n根据定义，大于或等于实数 $x$ 的最小整数是 $x$ 的上取整（ceiling），记为 $\\lceil x \\rceil$。\n因此，所需的最少顶层条目数为：\n$$n_{\\text{top}} = \\left\\lceil \\frac{R}{A} \\right\\rceil$$\n该表达式是仅用 $R$ 和 $A$ 表示的封闭形式解析表达式，符合要求。", "answer": "$$\n\\boxed{\\left\\lceil \\frac{R}{A} \\right\\rceil}\n$$", "id": "3647771"}, {"introduction": "理论上，页表是一个静态的树状结构，但在实际的操作系统中，页表页是按需分配的。这个练习模拟了这一动态过程，要求你追踪当添加新的虚拟地址映射时，需要额外分配多少页表内存。通过解决这个问题，你将具体地体会到多级页表的内存开销，并理解共享页表路径是如何节省内存的，这是理解稀疏地址空间管理的关键[@problem_id:3647750]。", "problem": "一个进程运行在一个使用分层页表的系统上，该系统具有以下特性：虚拟地址为 $48$ 位；页面大小为 $4\\,\\mathrm{KiB}$；有 $4$ 个页表级别；每个页表恰好占用一个大小为 $4\\,\\mathrm{KiB}$ 的页面；每个页表项 (PTE) 为 $8$ 字节。从虚拟地址中提取的四个级别索引为 $i_4,i_3,i_2,i_1$，每个索引宽度为 $9$ 位，后面跟着一个 $12$ 位的页内偏移。\n\n假设该进程的第 $4$ 级根页表页已经存在，独立于此处讨论的任何映射，并且其存在不计入任何内存总量。已为物理页 $P$ 建立了一个单一的基准映射，其虚拟地址索引为 $(i_4,i_3,i_2,i_1)=(100,200,300,400)$。此基准映射已经分配了该路径上所有缺失的页表页。进程中不存在其他页表结构。\n\n现在，您为同一个物理页 $P$ 在以下虚拟地址处引入额外的别名映射，这些虚拟地址由其 $(i_4,i_3,i_2,i_1)$ 索引元组列出：\n- A组：$(100,200,300,401)$, $(100,200,300,402)$, $(100,200,300,403)$。\n- B组：$(100,200,301,10)$, $(100,200,302,11)$。\n- C组：$(100,201,0,1)$, $(100,202,2,3)$。\n- D组：$(101,0,0,0)$, $(102,7,8,9)$。\n\n使用以下关于分层页表的基本事实：\n- 一个虚拟页的映射需要沿着其 $(i_4,i_3,i_2,i_1)$ 路径，有一条通向第 $1$ 级叶子 PTE 的有效页表链。\n- 如果在某个级别上所需的页表尚不存在，操作系统会为该页表分配一个大小为 $4\\,\\mathrm{KiB}$ 的新页面，并在父级中安装一个指向它的指针。\n- 占用一个 PTE 条目本身不会分配超出包含它的页表页的额外内存。\n\n计算引入 A组 到 D组 的所有别名映射所分配的总额外页表内存（以字节为单位），这是相对于单一基准映射而言的。不要计算第 $4$ 级根页表页，因为它无论如何都存在。以字节为单位，用一个精确的整数表示你的最终答案。不需要四舍五入。", "solution": "该问题要求计算在引入一组新的虚拟到物理地址映射时，为页表分配的总额外内存。系统采用 $4$ 级分层页表方案。我们必须首先确定页表结构的初始状态，然后分析添加每个新映射的内存成本。\n\n系统参数如下：\n- 虚拟地址大小：$48$ 位。\n- 页面大小：$4\\,\\mathrm{KiB}$，等于 $4 \\times 1024 = 4096$ 字节。\n- 页表级别：$4$。\n- 页表大小：一个页面，即 $4096$ 字节。\n- 页表项 (PTE) 大小：$8$ 字节。\n- 虚拟地址结构：一个 $48$ 位的地址被划分为四个 $9$ 位的索引 $(i_4, i_3, i_2, i_1)$ 和一个 $12$ 位的偏移量。索引字段总和为 $4 \\times 9 = 36$ 位，加上 $12$ 位的偏移量得到 $36+12=48$ 位，这是正确的。每个 $9$ 位的索引可以寻址 $2^9 = 512$ 个条目。一个页表中可以容纳的PTE数量是 $\\frac{4096 \\text{ 字节/页表}}{8 \\text{ 字节/PTE}} = 512$ 个条目/页表。参数是一致的。\n\n分层页表的核心原理是通过遍历页表树来转换虚拟地址。要映射由索引 $(i_4, i_3, i_2, i_1)$ 定义的虚拟页，必须存在一条有效路径。这需要：\n1.  一个第 4 级 (L4) 页表（根页表，已知存在）。\n2.  L4 表中索引 $i_4$ 处的 PTE 指向一个已存在的第 3 级 (L3) 页表。\n3.  该 L3 表中索引 $i_3$ 处的 PTE 指向一个已存在的第 2 级 (L2) 页表。\n4.  该 L2 表中索引 $i_2$ 处的 PTE 指向一个已存在的第 1 级 (L1) 页表。\n5.  该 L1 表中索引 $i_1$ 处的 PTE 指向最终的物理页帧。\n\n如果在任何步骤中所需的页表不存在，就必须为其分配一个大小为 $4096$ 字节的新页面。我们被要求找出相对于基准映射所分配的*额外*内存。\n\n**基准状态**\n存在一个针对索引为 $(i_4, i_3, i_2, i_1) = (100, 200, 300, 400)$ 的虚拟地址的单一映射。这意味着存在以下页表，这些页表是为建立此路径而分配的。根据题目说明，L4 根页表不包括在内存成本计算中。\n- L4 根页表中索引 $i_4=100$ 处的 PTE 指向一个 L3 页表。我们称之为 $PT_3(100)$。这需要一次页面分配。\n- $PT_3(100)$ 中索引 $i_3=200$ 处的 PTE 指向一个 L2 页表，$PT_2(100, 200)$。这需要第二次页面分配。\n- $PT_2(100, 200)$ 中索引 $i_2=300$ 处的 PTE 指向一个 L1 页表，$PT_1(100, 200, 300)$。这需要第三次页面分配。\n因此，基准配置已经分配了 $3 \\times 4096$ 字节的内存。我们相对于这个状态计算新的分配。\n\n**额外映射分析**\n\n我们将分析每组新映射，以确定必须分配的新页表的数量。\n\n**A组：映射 $(100, 200, 300, 401)$、$(100, 200, 300, 402)$ 和 $(100, 200, 300, 403)$**\n这三个映射都与基准映射共享相同的索引 $i_4=100$、$i_3=200$ 和 $i_2=300$。这意味着它们通过 L4、L3 和 L2 表遍历相同的路径，到达相同的 L1 页表 $PT_1(100, 200, 300)$，该页表已经存在。新的映射只需要在这个已存在的 L1 表中填充索引为 $401$、$402$ 和 $403$ 的 PTE。由于占用一个 PTE 条目不会分配新的页面，因此该组不需要额外的页表内存。\n*A组的新页表数量：$0$。*\n\n**B组：映射 $(100, 200, 301, 10)$ 和 $(100, 200, 302, 11)$**\n- 对于映射 $(100, 200, 301, 10)$：路径前缀 $(i_4, i_3) = (100, 200)$ 与基准映射共享。因此，L2 页表 $PT_2(100, 200)$ 被重用。然而，索引 $i_2=301$ 在这一级是新的（基准映射使用 $i_2=300$）。因此，必须分配一个新的 L1 页表 $PT_1(100, 200, 301)$。这是一个新的页表。\n- 对于映射 $(100, 200, 302, 11)$：同样，L2 页表 $PT_2(100, 200)$ 被重用。索引 $i_2=302$ 也是新的。这需要分配另一个新的 L1 页表 $PT_1(100, 200, 302)$。这是第二个新的页表。\n*B组的新页表数量：$2$。*\n\n**C组：映射 $(100, 201, 0, 1)$ 和 $(100, 202, 2, 3)$**\n- 对于映射 $(100, 201, 0, 1)$：路径前缀 $i_4=100$ 是共享的，所以 L3 页表 $PT_3(100)$ 被重用。索引 $i_3=201$ 是新的。这需要分配一个新的 L2 页表 $PT_2(100, 201)$。沿着这条新路径，索引 $i_2=0$ 对于这个分支也必然是新的，所以还必须分配一个新的 L1 页表 $PT_1(100, 201, 0)$。此映射需要 $2$ 个新页表（一个 L2，一个 L1）。\n- 对于映射 $(100, 202, 2, 3)$：该路径再次重用 $PT_3(100)$。索引 $i_3=202$ 是新的，并且与 $200$ 和 $201$ 都不同。这需要分配一个新的 L2 页表 $PT_2(100, 202)$。随后，必须分配一个新的 L1 页表 $PT_1(100, 202, 2)$。此映射也需要 $2$ 个新页表。\n*C组的新页表数量：$2 + 2 = 4$。*\n\n**D组：映射 $(101, 0, 0, 0)$ 和 $(102, 7, 8, 9)$**\n- 对于映射 $(101, 0, 0, 0)$：索引 $i_4=101$ 在 L4 级别是新的。这需要创建一个全新的页表层次结构分支。\n    1. 必须分配一个新的 L3 页表 $PT_3(101)$。\n    2. 必须分配一个新的 L2 页表 $PT_2(101, 0)$。\n    3. 必须分配一个新的 L1 页表 $PT_1(101, 0, 0)$。\n    此映射需要 $3$ 个新页表。\n- 对于映射 $(102, 7, 8, 9)$：索引 $i_4=102$ 也是新的，并且与 $100$ 和 $101$ 不同。这需要另一个完全独立的分支。\n    1. 必须分配一个新的 L3 页表 $PT_3(102)$。\n    2. 必须分配一个新的 L2 页表 $PT_2(102, 7)$。\n    3. 必须分配一个新的 L1 页表 $PT_1(102, 7, 8)$。\n    此映射也需要 $3$ 个新页表。\n*D组的新页表数量：$3 + 3 = 6$。*\n\n**总额外内存计算**\n新分配的页表总数是各组数量的总和：\n新页表总数 = $0 (\\text{A组}) + 2 (\\text{B组}) + 4 (\\text{C组}) + 6 (\\text{D组}) = 12$。\n\n每个新页表消耗一页内存，即 $4096$ 字节。\n总额外内存 = (新页表总数) $\\times$ (一页的大小)\n总额外内存 = $12 \\times 4096$ 字节\n总额外内存 = $49152$ 字节。\n\n这就是为容纳所有新的别名映射而分配的页表总额外内存。", "answer": "$$\n\\boxed{49152}\n$$", "id": "3647750"}, {"introduction": "虽然标准的 $4 \\text{ KiB}$ 页面提供了极大的灵活性，但在映射大型连续内存区域（如数据库缓存或虚拟机内存）时，它会导致巨大的页表开销和TLB未命中。现代处理器通过支持“大页”（Huge Pages）来解决这个问题。这个练习将挑战你扮演操作系统内存管理器的角色，利用混合页面大小来以最优方式映射一个包含“空洞”的内存区域，从而最小化所需的页表条目总数[@problem_id:3647756]。", "problem": "一个操作系统 (OS) 在一个 $64$ 位架构上使用四级分层分页，并支持来自集合 $S=\\{4 \\text{ KiB}, 2 \\text{ MiB}, 1 \\text{ GiB}\\}$ 的混合页面大小。一个大小为 $p \\in S$ 的页面仅当其虚拟基地址与 $p$ 字节对齐，并且整个 $p$ 字节区域被连续映射而没有空洞时，才能用作叶映射。考虑映射一个大小为 $R$ 字节的连续虚拟区域，其中该区域的一部分（比例为 $f$，表示为 $[0,1)$ 内的小数）以 $4 \\text{ KiB}$ 的基本页面粒度被有意地保留为未映射的空洞。假设如下：\n\n- $R$ 是 $4 \\text{ KiB}$ 的正整数倍，即对于某个整数 $n \\geq 1$，有 $R = n \\cdot 4 \\text{ KiB}$。\n- 未映射的基本页面数量恰好是 $f n$，因此 $(1-f)R$ 也是 $4 \\text{ KiB}$ 的倍数。\n- 操作系统可以选择区域内空洞的位置以及该区域的虚拟基地址。特别是，它可以将区域基地址与 $1 \\text{ GiB}$ 边界对齐，以最小化叶条目的数量。\n- 此处，页表项 (PTE) 定义为其各自级别上的单个叶映射：级别1的 $4 \\text{ KiB}$ PTE，级别2的 $2 \\text{ MiB}$ PTE，或级别3的 $1 \\text{ GiB}$ PTE。不要计算非叶条目。\n\n仅使用分层分页的基本属性（对齐和连续性约束）以及页面大小 $4 \\text{ KiB}=2^{12}$ 字节, $2 \\text{ MiB}=2^{21}$ 字节, 和 $1 \\text{ GiB}=2^{30}$ 字节，推导出一个关于 $R$ 和 $f$ 的闭式表达式，用于表示在满足上述约束条件下映射该区域所需的最小可能叶 PTE 数量。您可以使用向下取整函数 $\\lfloor \\cdot \\rfloor$、向上取整函数 $\\lceil \\cdot \\rceil$ 和模运算 $\\bmod$。您的最终答案必须是单一的解析表达式。无需进行四舍五入，且最终表达式中不应包含任何单位。", "solution": "该问题是有效的，因为它科学地基于操作系统内存管理的原理，特别是分层分页和使用大页面（巨页）。该问题提法得当、客观，并包含足够的信息来推导出唯一的最小解。\n\n目标是找到映射一个大小为 $R$ 的虚拟内存区域所需的最少叶页表项 (PTE) 数量。该区域包含未映射的空洞，已映射部分的总大小为 $(1-f)R$。操作系统可以自由选择区域的虚拟基地址和空洞的位置。为了最小化 PTE 的数量，必须最大化使用可用的最大页面大小。\n\n可用的页面大小为 $P_3 = 1\\ \\text{GiB} = 2^{30}$ 字节, $P_2 = 2\\ \\text{MiB} = 2^{21}$ 字节, 和 $P_1 = 4\\ \\text{KiB} = 2^{12}$ 字节。一个大小为 $p$ 的页面只有在大小为 $p$ 的虚拟地址块在 $p$ 字节边界上对齐且被完全映射（连续，无空洞）时才能被使用。\n\n为了在最小化 PTE 数量的同时满足这些约束，操作系统的最优策略如下：\n1.  **对齐区域**: 操作系统应将大小为 $R$ 的整个虚拟区域的基地址与 $1\\ \\text{GiB}$ 边界对齐。这确保了区域的起始地址对于最大页面大小 $P_3$ 是最优对齐的。为简单起见且不失一般性，我们假设该区域从虚拟地址 $0$ 开始。\n2.  **合并空洞**: 为了最大化连续映射内存的大小，操作系统应将所有未映射的 $4\\ \\text{KiB}$ 页面（即空洞）放在一起。最好的放置方式是放在区域的末尾。这会在区域的开头创建一个单一的、连续的已映射内存块。任何其他的空洞排列方式都会使已映射区域碎片化，从而破坏潜在的大页面映射，进而增加 PTE 的总数。\n\n通过这种策略，我们得到一个大小为 $M = (1-f)R$ 的单一连续映射块。这个块从虚拟地址 $0$ 开始（该地址是 $1\\ \\text{GiB}$ 对齐的），并延伸到地址 $M-1$。区域的其余部分，从地址 $M$ 到 $R-1$，是未映射的。\n\n现在，我们可以贪心地使用最大的页面优先来覆盖这个大小为 $M$ 的已映射块。\n\n**第1步：使用 $1\\ \\text{GiB}$ 页面 ($P_3$) 进行映射**\n已映射的区域是 $[0, M-1]$。由于该区域从一个 $1\\ \\text{GiB}$ 对齐的地址开始，我们可以使用尽可能多的完整的 $1\\ \\text{GiB}$ 页面。这样的页面数量 $N_3$ 是 $P_3$ 能完全放入 $M$ 的次数。\n$$N_3 = \\left\\lfloor \\frac{M}{P_3} \\right\\rfloor = \\left\\lfloor \\frac{(1-f)R}{2^{30}} \\right\\rfloor$$\n这些页面覆盖了从地址 $0$ 到 $N_3 \\cdot P_3 - 1$ 的内存范围。\n\n**第2步：使用 $2\\ \\text{MiB}$ 页面 ($P_2$) 进行映射**\n在使用 $1\\ \\text{GiB}$ 页面进行映射后，待映射的剩余内存大小为 $M_{\\text{rem},2} = M - N_3 \\cdot P_3 = M \\bmod P_3$。这个剩余的块从地址 $N_3 \\cdot P_3$ 开始，该地址与 $P_3 = 2^9 \\cdot P_2$ 对齐，因此也与 $P_2$ 对齐。我们可以用 $2\\ \\text{MiB}$ 页面贪心地覆盖这个剩余的块。$2\\ \\text{MiB}$ 页面的数量 $N_2$ 是：\n$$N_2 = \\left\\lfloor \\frac{M_{\\text{rem},2}}{P_2} \\right\\rfloor = \\left\\lfloor \\frac{M \\bmod P_3}{P_2} \\right\\rfloor = \\left\\lfloor \\frac{((1-f)R) \\bmod 2^{30}}{2^{21}} \\right\\rfloor$$\n这些页面覆盖了从地址 $N_3 \\cdot P_3$ 到 $N_3 \\cdot P_3 + N_2 \\cdot P_2 - 1$ 的内存范围。\n\n**第3步：使用 $4\\ \\text{KiB}$ 页面 ($P_1$) 进行映射**\n在使用 $2\\ \\text{MiB}$ 页面后，最后待映射的剩余内存部分的大小为 $M_{\\text{rem},1} = M_{\\text{rem},2} - N_2 \\cdot P_2 = M_{\\text{rem},2} \\bmod P_2$。由于 $P_3$ 是 $P_2$ 的整数倍，可以得出 $(M \\bmod P_3) \\bmod P_2 = M \\bmod P_2$。所以，$M_{\\text{rem},1} = M \\bmod P_2$。这个剩余的块从地址 $N_3 \\cdot P_3 + N_2 \\cdot P_2$ 开始，该地址与 $P_2=2^9 \\cdot P_1$ 对齐，因此也与 $P_1$ 对齐。问题陈述保证了总映射内存 $M=(1-f)R$ 是基本页面大小 $P_1 = 4\\ \\text{KiB}$ 的整数倍。由于被 $P_3$ 和 $P_2$ 页面覆盖的部分也是 $P_1$ 的倍数，剩余大小 $M_{\\text{rem},1}$ 也必须是 $P_1$ 的倍数。因此，这最后的剩余部分可以被 $4\\ \\text{KiB}$ 页面完美地覆盖。这样的页面数量 $N_1$ 是：\n$$N_1 = \\frac{M_{\\text{rem},1}}{P_1} = \\frac{M \\bmod P_2}{P_1} = \\frac{((1-f)R) \\bmod 2^{21}}{2^{12}}$$\n\n**总叶 PTE 数量**\n最少的总叶 PTE 数量 $N_{PTE}$ 是各级 PTE 的总和：\n$$N_{PTE} = N_3 + N_2 + N_1$$\n代入上面推导出的表达式，我们得到关于 $R$ 和 $f$ 的最终闭式表达式：\n$$N_{PTE}(R, f) = \\left\\lfloor \\frac{(1-f)R}{2^{30}} \\right\\rfloor + \\left\\lfloor \\frac{((1-f)R) \\bmod 2^{30}}{2^{21}} \\right\\rfloor + \\frac{((1-f)R) \\bmod 2^{21}}{2^{12}}$$\n这个表达式代表了最优贪心覆盖策略的结果，该策略的实现得益于操作系统对齐内存区域和合并未映射空洞的能力。", "answer": "$$\\boxed{\\left\\lfloor \\frac{(1-f)R}{2^{30}} \\right\\rfloor + \\left\\lfloor \\frac{((1-f)R) \\bmod 2^{30}}{2^{21}} \\right\\rfloor + \\frac{((1-f)R) \\bmod 2^{21}}{2^{12}}}$$", "id": "3647756"}]}