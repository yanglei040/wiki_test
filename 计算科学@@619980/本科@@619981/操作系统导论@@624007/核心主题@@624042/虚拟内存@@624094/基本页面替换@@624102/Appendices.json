{"hands_on_practices": [{"introduction": "要真正掌握页面置换算法的工作原理，没有什么比亲手追踪更能加深理解的了。我们的第一个实践将聚焦于概念最简单的先进先出（FIFO）策略。通过处理一个特定的引用序列，你不仅将计算缺页次数，还将揭示一个被称为“贝拉迪异常”（Belady's Anomaly）的反直觉现象——即增加物理帧有时反而会导致性能下降。这个练习 [@problem_id:3623347] 对于理解算法性能并非总是直线上升至关重要。", "problem": "一个请求分页虚拟内存系统维护一个固定大小的物理帧集合，并在发生缺页时使用先入先出 (FIFO) 策略替换页面，即驻留时间最长的页面（也就是最先到达的页面）被换出。当引用的页面当前未驻留在任何帧中时，就会发生缺页错误。假设所有帧最初都是空的，并且一次引用会将页面加载到一个空闲帧中（如果存在的话）；否则，FIFO 策略会在加载新页面之前换出最早驻留的页面。令 $f_{\\text{FIFO}}(k)$ 表示在 FIFO 策略下，对于给定的引用序列使用 $k$ 个帧时发生缺页错误的总次数。\n\n给定经典引用序列 $S = (1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5)$，计算 $f_{\\text{FIFO}}(3)$ 和 $f_{\\text{FIFO}}(4)$，并根据上述定义，解释为什么所得结果是 Belady 异常的例证，即在 FIFO 策略下，增加帧的数量反而可能导致缺页错误次数的增加。\n\n将您的最终答案表示为一个包含两个条目的行矩阵 $\\begin{pmatrix} f_{\\text{FIFO}}(3)  f_{\\text{FIFO}}(4) \\end{pmatrix}$，其值为精确整数。无需四舍五入。", "solution": "问题陈述是完全自包含的，科学上基于操作系统内存管理的原理，并且是良构的。所有术语都是标准的且定义清晰，为唯一且可验证的解提供了基础。因此，该问题被认为是有效的。\n\n任务是计算给定引用序列 $S = (1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5)$ 在使用先入先出 (FIFO) 页面替换策略且分别有 $k=3$ 和 $k=4$ 个帧时发生的缺页错误次数，记为 $f_{\\text{FIFO}}(3)$ 和 $f_{\\text{FIFO}}(4)$。随后，我们必须解释为什么这个结果展示了 Belady 异常。\n\nFIFO 策略的运作方式类似于一个队列。当必须换出一个页面时，会选择在内存中驻留时间最长的页面。我们将追踪每种情况下内存帧的状态。缺页错误用 'F' 表示，命中用 'H' 表示。帧内容代表当前在内存中的页面集合。“到达顺序”队列显示了从最旧到最新的页面。\n\n**情况 1: $k=3$ 个帧**\n\n我们为 $f_{\\text{FIFO}}(3)$ 逐步模拟该过程。\n\n| 引用 | 页面 | 帧 (集合)  | 缺页/命中 | 到达顺序 (最旧 $\\rightarrow$ 最新) | 操作                               |\n|-----------|------|---------------|-----------|---------------------------------------------|--------------------------------------|\n| 1         | $1$  | $\\{1\\}$       | F         | $[1]$                                       | 将 $1$ 加载到空闲帧中。          |\n| 2         | $2$  | $\\{1, 2\\}$    | F         | $[1, 2]$                                    | 将 $2$ 加载到空闲帧中。          |\n| 3         | $3$  | $\\{1, 2, 3\\}$ | F         | $[1, 2, 3]$                                 | 将 $3$ 加载到空闲帧中。          |\n| 4         | $4$  | $\\{2, 3, 4\\}$ | F         | $[2, 3, 4]$                                 | 换出 $1$ (最旧)，加载 $4$。          |\n| 5         | $1$  | $\\{3, 4, 1\\}$ | F         | $[3, 4, 1]$                                 | 换出 $2$ (最旧)，加载 $1$。          |\n| 6         | $2$  | $\\{4, 1, 2\\}$ | F         | $[4, 1, 2]$                                 | 换出 $3$ (最旧)，加载 $2$。          |\n| 7         | $5$  | $\\{1, 2, 5\\}$ | F         | $[1, 2, 5]$                                 | 换出 $4$ (最旧)，加载 $5$。          |\n| 8         | $1$  | $\\{1, 2, 5\\}$ | H         | $[1, 2, 5]$                                 | 页面 $1$ 在内存中。               |\n| 9         | $2$  | $\\{1, 2, 5\\}$ | H         | $[1, 2, 5]$                                 | 页面 $2$ 在内存中。               |\n| 10        | $3$  | $\\{2, 5, 3\\}$ | F         | $[2, 5, 3]$                                 | 换出 $1$ (最旧)，加载 $3$。          |\n| 11        | $4$  | $\\{5, 3, 4\\}$ | F         | $[5, 3, 4]$                                 | 换出 $2$ (最旧)，加载 $4$。          |\n| 12        | $5$  | $\\{5, 3, 4\\}$ | H         | $[5, 3, 4]$                                 | 页面 $5$ 在内存中。               |\n\n计算缺页错误 (F) 的次数，我们发现共有 $9$ 次缺页错误。\n因此，$f_{\\text{FIFO}}(3) = 9$。\n\n**情况 2: $k=4$ 个帧**\n\n接下来，我们为 $f_{\\text{FIFO}}(4)$ 模拟该过程。\n\n| 引用 | 页面 | 帧 (集合)    | 缺页/命中 | 到达顺序 (最旧 $\\rightarrow$ 最新) | 操作                               |\n|-----------|------|-----------------|-----------|---------------------------------------------|--------------------------------------|\n| 1         | $1$  | $\\{1\\}$         | F         | $[1]$                                       | 将 $1$ 加载到空闲帧中。          |\n| 2         | $2$  | $\\{1, 2\\}$      | F         | $[1, 2]$                                    | 将 $2$ 加载到空闲帧中。          |\n| 3         | $3$  | $\\{1, 2, 3\\}$   | F         | $[1, 2, 3]$                                 | 将 $3$ 加载到空闲帧中。          |\n| 4         | $4$  | $\\{1, 2, 3, 4\\}$| F         | $[1, 2, 3, 4]$                              | 将 $4$ 加载到空闲帧中。          |\n| 5         | $1$  | $\\{1, 2, 3, 4\\}$| H         | $[1, 2, 3, 4]$                              | 页面 $1$ 在内存中。               |\n| 6         | $2$  | $\\{1, 2, 3, 4\\}$| H         | $[1, 2, 3, 4]$                              | 页面 $2$ 在内存中。               |\n| 7         | $5$  | $\\{2, 3, 4, 5\\}$| F         | $[2, 3, 4, 5]$                              | 换出 $1$ (最旧)，加载 $5$。          |\n| 8         | $1$  | $\\{3, 4, 5, 1\\}$| F         | $[3, 4, 5, 1]$                              | 换出 $2$ (最旧)，加载 $1$。          |\n| 9         | $2$  | $\\{4, 5, 1, 2\\}$| F         | $[4, 5, 1, 2]$                              | 换出 $3$ (最旧)，加载 $2$。          |\n| 10        | $3$  | $\\{5, 1, 2, 3\\}$| F         | $[5, 1, 2, 3]$                              | 换出 $4$ (最旧)，加载 $3$。          |\n| 11        | $4$  | $\\{1, 2, 3, 4\\}$| F         | $[1, 2, 3, 4]$                              | 换出 $5$ (最旧)，加载 $4$。          |\n| 12        | $5$  | $\\{2, 3, 4, 5\\}$| F         | $[2, 3, 4, 5]$                              | 换出 $1$ (最旧)，加载 $5$。          |\n\n计算缺页错误 (F) 的次数，我们发现共有 $10$ 次缺页错误。\n因此，$f_{\\text{FIFO}}(4) = 10$。\n\n**Belady 异常的解释**\n\n计算得到的值为 $f_{\\text{FIFO}}(3) = 9$ 和 $f_{\\text{FIFO}}(4) = 10$。我们观察到 $f_{\\text{FIFO}}(4) > f_{\\text{FIFO}}(3)$。这种增加分配的内存帧数反而导致缺页错误次数增加的现象，被称为 Belady 异常。这是一个违反直觉的结果，因为人们通常期望更多的资源（即更多的帧）会改善性能（即导致更少的缺页错误）。\n\n该异常的发生是因为 FIFO 替换算法不考虑页面的使用历史或将来被引用的可能性；它只考虑到达时间。本例中出现异常的具体原因可以通过比较帧状态来确定。\n\n在第 7 次引用时，序列请求页面 $5$。\n- 在 $k=3$ 的情况下，帧中包含 $\\{2, 3, 4\\}$，页面 $1$ 已在第 4 次引用时被换出。最旧的页面是 $2$，但根据追踪记录，在第 7 次引用之前，帧内容为 $\\{4, 1, 2\\}$。让我们更精确一些。在第 7 次引用之前，帧内容为 $\\{4, 1, 2\\}$，到达顺序为 $[4, 1, 2]$。页面 $4$ 是最旧的，被换出以加载页面 $5$。新状态为 $\\{1, 2, 5\\}$。至关重要的是，页面 $1$ 和 $2$ 仍保留在内存中。随后对 $1$ 和 $2$ 的引用是命中。\n- 在 $k=4$ 的情况下，帧中包含 $\\{1, 2, 3, 4\\}$。最旧的页面是 $1$。为了加载页面 $5$，页面 $1$ 被换出。新状态为 $\\{2, 3, 4, 5\\}$。这次换出是有害的，因为页面 $1$ 在紧接着的下一步（第 8 次引用）就被请求，导致立即发生缺页错误。\n\n较大的帧集合 ($k = 4$) 使得“错误”的页面（页面 $1$，它很快又被需要）成为最早驻留的页面，从而成为替换的牺牲品。相比之下，较小的帧集合 ($k = 3$) 已经换出了不是立即需要的页面，从而形成了一种偶然地在后续引用中表现更好的帧构成。\n\nBelady 异常是那些不属于“栈算法”的页面替换算法的特征。栈算法具有这样的性质：在引用序列的任何时刻，拥有 $k$ 个帧的内存中的页面集合总是拥有 $k+1$ 个帧的内存中页面集合的子集。FIFO 不满足此性质，如此处所示：在第 7 次引用后，$k=3$ 的帧集合是 $\\{1, 2, 5\\}$，而 $k=4$ 的帧集合是 $\\{2, 3, 4, 5\\}$。前者不是后者的子集。\n\n最终计算出的值以一个包含两个条目的行矩阵形式呈现。", "answer": "$$\n\\boxed{\\begin{pmatrix} 9  10 \\end{pmatrix}}\n$$", "id": "3623347"}, {"introduction": "在见识到FIFO可能出现的意外行为之后，我们现在来探究其绝对的“最坏情况”性能。这个实践 [@problem_id:3623284] 将引导你分析一个循环引用序列，其中独立页面数量超过了可用物理帧的数量。你的任务是从基本定义出发，论证为何这种特定的访问模式会迫使FIFO陷入“颠簸”（thrashing）状态，导致每次内存访问都发生缺页。这突显了FIFO策略的关键缺陷：它完全忽略了页面的访问历史。", "problem": "一个操作系统使用请求分页，有固定数量的物理帧 $k \\in \\mathbb{N}$，由先入先出 (FIFO) 策略管理。当发生页面错误时，先入先出 (FIFO) 策略会淘汰在内存中驻留时间最长的页面。考虑一个虚拟地址空间，它由 $M \\in \\mathbb{N}$ 个不同的页面 $\\{p_1, p_2, \\dots, p_M\\}$ 组成，其中 $M \\geq k+1$。定义一个引用串 $R$，通过将周期 $(p_1, p_2, \\dots, p_M)$ 连续重复 $T \\in \\mathbb{N}$ 次得到，因此总引用次数为 $N = T \\cdot M$。在第一个周期开始时，内存初始为空。\n\n仅从上述定义（页面错误、驻留集、FIFO 淘汰顺序）出发，且不引入任何快捷公式，分析 FIFO 在引用串 $R$ 上的行为，并确定在固定的 $k$ 和 $M \\geq k+1$ 条件下的极限缺页率，定义为 $\\lim_{N \\to \\infty} \\frac{R \\text{上的缺页次数}}{N}$。将最终答案表示为一个实数。不需要四舍五入，也没有物理单位。你的推导必须证明为什么对于所有足够大的 $N$ 该结果都成立，并说明 FIFO 淘汰顺序如何与 $R$ 的周期性结构相互作用（特别地，请注意当 $M = k+1$ 时，每次缺页时被淘汰的页面恰好是周期中下一个被请求的页面）。", "solution": "经分析，问题陈述有效。这是一个操作系统算法领域的良定问题，基于已确立的计算机科学原理。所有必要的参数和条件都已提供，没有内部矛盾或歧义。\n\n我们被要求确定在先入先出 (FIFO) 页面置换策略下，针对一个特定的周期性引用串的极限缺页率。设 $k$ 为物理帧的数量，$M$ 为不同页面的数量，且满足条件 $M \\geq k+1$。引用串 $R$ 由周期 $(p_1, p_2, \\dots, p_M)$ 重复 $T$ 次构成，总引用次数为 $N = T \\cdot M$。内存初始为空。\n\n当引用的页面不在当前驻留于物理帧中的页面集合（即驻留集）中时，就会发生页面错误（或称为未命中）。FIFO 策略规定，在发生页面错误时，如果所有帧都已被占用，则需要淘汰的页面是在内存中停留时间最长的那个。\n\n我们将从头开始追踪内存帧的状态。设内存中的页面集合用 $S$ 表示。初始时，$S=\\emptyset$。\n\n引用串中的前 $k$ 次引用是针对不同的页面 $p_1, p_2, \\dots, p_k$。\n1.  引用 $p_1$：由于内存为空，$p_1 \\notin S$。这是一个强制性页面错误。$p_1$ 被加载到一个帧中。驻留集变为 $S=\\{p_1\\}$。FIFO 队列（按从最旧到最新的顺序）为 $(p_1)$。总未命中数：$1$。\n2.  引用 $p_2$：由于 $p_2 \\notin S$，这是另一次强制性错误。$p_2$ 被加载。驻留集变为 $S=\\{p_1, p_2\\}$。FIFO 队列为 $(p_1, p_2)$。总未命中数：$2$。\n...\n$k$. 引用 $p_k$：这是一个错误，因为 $p_k$ 不在集合 $\\{p_1, \\dots, p_{k-1}\\}$ 中。$p_k$ 被加载。驻留集现在是 $S=\\{p_1, p_2, \\dots, p_k\\}$，物理内存已满。FIFO 队列是 $(p_1, p_2, \\dots, p_k)$，其中 $p_1$ 是最旧的页面。总未命中数：$k$。\n\n现在，让我们考虑后续的引用。\n$k+1$. 引用 $p_{k+1}$：驻留集是 $S=\\{p_1, \\dots, p_k\\}$。由于页面 $p_1, \\dots, p_M$ 是不同的且 $k+1 \\leq M$，页面 $p_{k+1}$ 不在 $S$ 中。这导致一次页面错误。根据 FIFO 策略，最旧的页面 $p_1$ 被淘汰。$p_{k+1}$ 被加载。新的驻留集是 $S=\\{p_2, p_3, \\dots, p_{k+1}\\}$。FIFO 队列是 $(p_2, \\dots, p_{k+1})$。总未命中数：$k+1$。\n\n让我们概括这种行为。考虑对任意 $j > k$ 的页面 $p_j$ 的引用。我们可以通过归纳法证明，在这次引用之前，内存中的页面集合将是 $\\{p_{j-k}, p_{j-k+1}, \\dots, p_{j-1}\\}$。\n$j=k+1$ 的基础情形已如上所示：内存包含 $\\{p_2, \\dots, p_{k+1}\\} = \\{p_{(k+1)-k}, \\dots, p_{(k+1)-1}\\}$。\n现在，对于归纳步骤，假设对于引用 $p_j$（其中 $j>k$），内存中的页面是 $S_{j-1} = \\{p_{j-k}, p_{j-k+1}, \\dots, p_{j-1}\\}$。要引用的页面是 $p_j$。由于所有页面 $p_1, \\dots, p_M$ 都是不同的且 $M > k$，页面 $p_j$ 不是前 $k$ 个唯一页面组成的集合 $S_{j-1}$ 中的元素。因此，对 $p_j$ 的引用是一次页面错误。\nFIFO 算法淘汰队列中最旧的页面，即 $p_{j-k}$。然后新的页面 $p_j$ 被加载。内存中新的页面集合变为 $S_j = \\{p_{j-k+1}, \\dots, p_{j-1}, p_j\\}$。这就完成了归纳证明。\n\n这个论证表明，在最初 $k-1$ 次强制性未命中部分填充内存之后，随后的每一次引用都会导致页面错误。前 $k$ 次引用都是未命中。对于步骤 $j > k$ 的任何引用，所请求的页面 $p_j$（其中索引取自全局序列）不在先前引用的 $k$ 个页面集合中，而这些页面正是驻留在内存中的页面。这一点由引用串的周期性以及条件 $M > k$ 所保证。例如，在完成对 $(p_1, \\dots, p_M)$ 的一个完整周期引用后，内存中包含 $\\{p_{M-k+1}, \\dots, p_M\\}$。下一次引用是 $p_1$。由于 $M \\geq k+1$，我们有 $M-k+1 \\geq 2$，这保证了 $p_1$ 不在内存集合中。这种模式会无限延续下去。\n\n因此，对于给定的总长度为 $N$ 的引用串 $R$，每一次引用都会导致页面错误。总未命中数恰好为 $N$。\n\n缺页率定义为未命中次数除以总引用次数。\n$$ \\text{缺页率} = \\frac{R \\text{上的未命中次数}}{N} $$\n在这种情况下，未命中数为 $N$。\n$$ \\text{缺页率} = \\frac{N}{N} = 1 $$\n这个结果对于任何周期数 $T$ 都成立，因此对于任何总引用次数 $N = T \\cdot M$ 也成立。\n\n因此，极限缺页率为：\n$$ \\lim_{N \\to \\infty} \\frac{R \\text{上的未命中次数}}{N} = \\lim_{N \\to \\infty} \\frac{N}{N} = \\lim_{N \\to \\infty} 1 = 1 $$\n\n问题要求具体评论 $M = k+1$ 的情况。在这种情况下，引用串是 $(p_1, p_2, \\dots, p_{k+1})$ 的重复。让我们追踪一下状态。引用 $p_{k+1}$ 后，发生一次错误，$p_1$ 被淘汰，内存中包含 $\\{p_2, \\dots, p_{k+1}\\}$。下一次引用是 $p_1$。刚刚被淘汰的页面就是 $p_1$。然后对 $p_1$ 的引用发生错误，淘汰了 $p_2$。内存中包含 $\\{p_3, \\dots, p_{k+1}, p_1\\}$。下一次引用是 $p_2$。刚刚被淘汰的页面就是 $p_2$。\n一般来说，对于 $M=k+1$ 的情况，当对页面 $p_j$ 发生错误时，被淘汰的页面是内存中最旧的那个，即 $p_{j-(k+1)+1} = p_{j-k}$。周期中下一个要请求的页面是 $p_{j+1}$。我们必须检查页面索引在模 $M=k+1$ 的意义下是否等价。被淘汰页面的索引是 $j-k$。下一个被请求页面的索引是 $j+1$。由于 $-k \\equiv 1 \\pmod{k+1}$，我们有 $j-k \\equiv j+1 \\pmod{k+1}$。这证实了对于 $M=k+1$，FIFO 策略总是会淘汰掉下一次引用恰好需要的那个页面。这是 FIFO 病态行为的一个经典例子，并为缺页率为 $1$ 的原因提供了清晰的机制。对于一般情况 $M \\geq k+1$，被淘汰的页面不一定是下一个需要的页面，但对超出可用帧数的页面数量的周期性访问模式仍然确保了被请求的页面永远不在内存中。\n\n缺页率始终为 $1$，所以极限是 $1$。", "answer": "$$\\boxed{1}$$", "id": "3623284"}, {"introduction": "现在，我们将注意力转向最近最少使用（LRU）算法，这是一种通常比FIFO表现更优的复杂策略。虽然LRU能够避免贝拉迪异常，但它是否完美无缺？这个练习 [@problem_id:3623298] 将挑战你构建一个“对抗性”的引用序列，该序列恰好利用了LRU的决策逻辑，导致其达到接近100%的缺页率。通过理解如何让一个优秀的算法失效，你将对算法设计的精妙之处以及工作负载特征的重要性有更深刻的体悟。", "problem": "考虑一个使用最近最少使用 (LRU) 页面替换策略的请求分页系统。LRU 策略维护一个新近度栈，并且在每个时间步，驻留在容量为 $k$ 帧的缓存中的页面集合恰好是最近引用的 $k$ 个不同页面。设 $k \\in \\mathbb{N}$ 为缓存容量，并固定整数 $k_1, k_2 \\in \\mathbb{N}$ 使得 $k_1 + k_2 = k$ 且 $k_1 \\geq 1$, $k_2 \\geq 1$。构建两个不相交的虚拟页面集合 $A$ 和 $B$，其大小分别为 $|A| = k_1 + 1$ 和 $|B| = k_2 + 1$。通过如下方式循环交错这两个集合来定义无限引用字符串 $S$：在每个周期中，以任意固定顺序无重复地引用集合 $A$ 中的每个页面一次，然后以任意固定顺序无重复地引用集合 $B$ 中的每个页面一次，并无限重复此双块模式。仅使用 LRU 策略的核心定义和上述新近度栈的特征，推导 LRU 在无限序列 $S$ 上的精确稳态未命中率。将你的最终答案表示为一个实数；无需四舍五入。", "solution": "问题要求计算最近最少使用 (LRU) 页面替换策略在一种特定类型的无限引用字符串上的稳态未命中率。我将首先验证问题陈述，如果问题有效，则继续进行形式化推导。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **策略：** 最近最少使用 (LRU) 页面替换。\n- **LRU 定义：** 在任何时候，缓存中的页面集合是“恰好是最近引用的 $k$ 个不同页面”。\n- **缓存容量：** $k \\in \\mathbb{N}$。\n- **整数划分：** $k_1, k_2 \\in \\mathbb{N}$ 使得 $k_1 + k_2 = k$，$k_1 \\geq 1$ 且 $k_2 \\geq 1$。\n- **页面集合：** 两个不相交的虚拟页面集合 $A$ 和 $B$。\n- **集合大小：** $|A| = k_1 + 1$ 和 $|B| = k_2 + 1$。\n- **引用字符串：** 无限字符串 $S$ 由循环引用 $A$ 中的所有页面（以固定顺序），然后引用 $B$ 中的所有页面（以固定顺序）形成。此模式（$A\\text{-块}, B\\text{-块}$）无限重复。\n- **任务：** 推导精确的稳态未命中率。\n- **答案格式：** 一个实数。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题设置在操作系统算法分析的标准理论框架内。LRU 策略和请求分页是核心概念。该问题在科学上和数学上是合理的。\n- **适定性：** 问题对 LRU 策略、缓存大小、页面集合和引用字符串给出了精确定义。它要求一个特定的、可计算的量（稳态未命中率）。参数 $k, k_1, k_2$ 被定义为固定但任意的自然数。“一个实数”的要求意味着结果必须独立于这些参数。我的分析将确定情况是否如此。\n- **客观性：** 问题以形式化、客观的语言陈述，没有歧义或主观断言。\n\n该问题不违反任何无效性标准。这是一个定义明确的理论计算机科学问题。涉及 $k_1$ 和 $k_2$ 的构造可能很复杂，但它并非矛盾或不完整。\n\n**步骤 3：结论与行动**\n问题被判定为 **有效**。我将继续进行解答。\n\n### 稳态未命中率的推导\n\n设不同页面的总集合为 $P = A \\cup B$。由于 $A$ 和 $B$ 不相交，不同页面的总数为：\n$$N = |P| = |A| + |B| = (k_1 + 1) + (k_2 + 1) = k_1 + k_2 + 2$$\n鉴于 $k = k_1 + k_2$，不同页面的总数是 $N = k + 2$。\n\n引用字符串 $S$ 是通过重复循环遍历 $P$ 中的所有 $N = k+2$ 个页面生成的。一个完整的引用周期包含 $|A| + |B| = k+2$ 次单独的页面引用。\n\n我们关心的是稳态未命中率。在稳态下，缓存的行为遵循由引用字符串的循环性质决定的重复模式。当引用的页面 $p$ 在引用时不存在于缓存中时，就会发生页面错误（未命中）。\n\n根据问题的定义，缓存包含最近引用的 $k$ 个不同页面。因此，当且仅当页面 $p$ 不在最近引用的 $k$ 个不同页面的集合中时，对页面 $p$ 的访问才会发生未命中。\n\n让我们考虑集合 $P$ 中的任意页面 $p \\in P$。我们将分析在稳态下对该页面 $p$ 的两次连续引用。设引用字符串表示为 $(r_1, r_2, r_3, \\dots)$。\n假设在时间 $t_i$ 发生对页面 $p$ 的引用，即 $r_{t_i} = p$。\n对同一页面 $p$ 的下一次引用将发生在时间 $t_{i+1}$。由于引用字符串是所有 $N = k+2$ 个不同页面的一个循环，在这两次对 $p$ 的连续访问之间，恰好引用了 $N-1$ 个其他不同的页面。\n因此，两次引用之间经过的时间是 $t_{i+1} - t_i = N = k+2$ 步。\n\n让我们检查在时间 $t_{i+1}$ 引用 $p$ 之前系统的状态。在时间 $t_i$ 和 $t_{i+1}$ 之间的引用序列是 $(r_{t_i+1}, r_{t_i+2}, \\dots, r_{t_i+N-1})$。这个序列由 $P \\setminus \\{p\\}$ 中的 $N-1 = (k+2)-1 = k+1$ 个不同页面组成。\n\n在时间 $t_{i+1}-1$，最近的引用是 $r_{t_{i+1}-1}$。在此点结束的引用历史是 $(\\dots, r_{t_i}, r_{t_i+1}, \\dots, r_{t_{i+1}-1})$。\n从时间 $t_i+1$ 到 $t_{i+1}-1$ 引用的不同页面集合恰好是 $P \\setminus \\{p\\}$，其大小为 $k+1$。根据定义，这些是在时间 $t_{i+1}$ 之前最近引用的 $k+1$ 个不同页面。\n\n根据定义，LRU 缓存包含最近引用的 $k$ 个不同页面。在时间 $t_{i+1}$ 引用 $p$ 之前的瞬间，这 $k$ 个页面的集合必须是 $P \\setminus \\{p\\}$ 中 $k+1$ 个页面的一个子集。\n由于 $p \\notin (P \\setminus \\{p\\})$，它不可能在 $P \\setminus \\{p\\}$ 的任何子集中。因此，此时 $p$ 不在缓存中。\n\n因此，在时间 $t_{i+1}$ 对页面 $p$ 的引用会导致页面错误。\n\n这个推理对任何页面 $p \\in P$ 都有效。因此，在稳态下，对任何页面的每次引用都会导致未命中。\n\n字符串 $S$ 的一个完整周期内的总引用次数是 $|A| + |B| = k+2$。\n如上所示，一个完整周期内的未命中次数也是 $k+2$。\n\n稳态未命中率定义为一个周期内未命中次数与引用次数的比率：\n$$\\text{Miss Rate} = \\frac{\\text{Number of Misses in a Cycle}}{\\text{Number of References in a Cycle}} = \\frac{k+2}{k+2} = 1$$\n\n涉及集合 $A$ 和 $B$ 以及参数 $k_1$ 和 $k_2$ 的特定构造，其作用是定义一个由 $k+2$ 个不同页面组成的循环排列的引用字符串。推导出的未命中率 1 是对于在大小为 $k$ 的 LRU 缓存上任何此类访问模式的通用结果，并且独立于 $k, k_1, k_2$ 的具体值（只要满足条件 $k_1 \\ge 1, k_2 \\ge 1$）。结果是一个实数，符合要求。", "answer": "$$\\boxed{1}$$", "id": "3623298"}]}