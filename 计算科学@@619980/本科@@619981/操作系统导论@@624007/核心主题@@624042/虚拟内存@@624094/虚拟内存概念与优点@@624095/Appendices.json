{"hands_on_practices": [{"introduction": "地址转换的速度对计算机性能至关重要，而转换检测缓冲区（TLB）是加速这一过程的关键硬件缓存。本练习旨在探讨“TLB覆盖范围”（TLB reach）这一概念，即TLB无需访问完整页表即可直接映射的内存总量。通过计算TLB的覆盖范围并确定特定应用程序工作集所需的TLB大小，你将具体理解硬件资源如何直接影响应用程序性能 [@problem_id:3689807]。", "problem": "通用计算机上的一个进程使用虚拟内存 (VM)，它将其虚拟地址空间划分为大小为 $p$ 的固定大小的页面。处理器维护一个转译后备缓冲器 (TLB)，它是近期页到帧转换的高速缓存；每个TLB条目精确映射一个虚拟页面。可由TLB立即转换而无需访问页表的虚拟内存总量称为TLB覆盖范围。考虑一个系统，其页面大小 $p = 4\\,\\text{KiB}$ (其中 $1\\,\\text{KiB} = 1024\\,\\text{bytes}$ 且 $1\\,\\text{MiB} = 1024^2\\,\\text{bytes}$)，TLB当前有 $N_{\\text{entries}} = 256$ 个条目，以及一个工作集大小为 $W = 19.7\\,\\text{MiB}$ 的进程。\n\n仅使用上述VM页面和TLB条目的核心定义，首先确定当前TLB的覆盖范围，并以 $\\text{MiB}$ 为单位表示。然后，确定所需的 $N_{\\text{entries}}$ 的最小整数值，以使TLB覆盖范围至少为工作集大小 $W$。请提供最小的 $N_{\\text{entries}}$ 作为最终答案；最终答案中不要包含单位。", "solution": "首先将验证问题陈述，以确保其是自洽的、科学上合理的和适定的。\n\n### 第1步：提取已知条件\n- 虚拟内存被划分为大小为 $p$ 的页面。\n- 每个TLB条目精确映射一个虚拟页面。\n- TLB覆盖范围是可由TLB转换的虚拟内存总量。\n- 页面大小，$p = 4\\,\\text{KiB}$。\n- 单位转换: $1\\,\\text{KiB} = 1024\\,\\text{bytes}$。\n- 单位转换: $1\\,\\text{MiB} = 1024^2\\,\\text{bytes}$。\n- 当前TLB条目数，$N_{\\text{entries}} = 256$。\n- 进程工作集大小，$W = 19.7\\,\\text{MiB}$。\n\n### 第2步：使用提取的已知条件进行验证\n该问题具有科学依据，因为它基于计算机体系结构和操作系统中的基本和标准概念，即虚拟内存、分页和转译后备缓冲器 (TLB)。所提供的定义和数值在此背景下是真实且常用的。该问题是适定的，提供了计算唯一解所需的所有必要数据（$p$、$N_{\\text{entries}}$、$W$ 和单位定义）。语言客观而精确。该问题是完整的、一致的，并且不违反任何物理或逻辑原理。这是一个标准的、可形式化的问题，旨在考验对页面大小、TLB大小和内存覆盖范围之间关系的理解。\n\n### 第3步：结论与行动\n该问题被认定为 **有效**。将提供完整解答。\n\n其核心原理是，TLB覆盖范围（我们可记为 $R_{\\text{TLB}}$）是由TLB所有条目映射的页面所能寻址的总内存。由于每个条目映射一个大小为 $p$ 的单个页面，因此TLB覆盖范围是条目数与页面大小的乘积。\n\nTLB覆盖范围的公式为：\n$$R_{\\text{TLB}} = N_{\\text{entries}} \\times p$$\n\n首先，我们计算当前系统配置的TLB覆盖范围。\n已知条件是：\n- 当前条目数，$N_{\\text{entries}} = 256$。\n- 页面大小，$p = 4\\,\\text{KiB}$。\n\n将这些值代入公式：\n$$R_{\\text{TLB}} = 256 \\times 4\\,\\text{KiB} = 1024\\,\\text{KiB}$$\n\n问题要求将此值以MiB为单位表示。我们已知转换因子：$1\\,\\text{KiB} = 1024\\,\\text{bytes}$ 且 $1\\,\\text{MiB} = 1024^2\\,\\text{bytes}$。由此，我们可以推导出KiB和MiB之间的关系：\n$$1\\,\\text{MiB} = 1024 \\times 1024\\,\\text{bytes} = 1024 \\times (1\\,\\text{KiB}) = 1024\\,\\text{KiB}$$\n因此，当前的TLB覆盖范围是：\n$$R_{\\text{TLB}} = 1024\\,\\text{KiB} = 1\\,\\text{MiB}$$\n\n接下来，我们必须确定所需的最小TLB条目数，以使TLB覆盖范围至少等于工作集大小 $W$。设所需的条目数为 $N'_{\\text{entries}}$。该条件可以表示为一个不等式：\n$$N'_{\\text{entries}} \\times p \\ge W$$\n\n我们需要解出 $N'_{\\text{entries}}$：\n$$N'_{\\text{entries}} \\ge \\frac{W}{p}$$\n\n给定值为：\n- 工作集大小，$W = 19.7\\,\\text{MiB}$。\n- 页面大小，$p = 4\\,\\text{KiB}$。\n\n为了进行除法运算，我们必须将两个量表示为相同的单位。让我们将它们都转换为KiB：\n$$W = 19.7\\,\\text{MiB} = 19.7 \\times 1024\\,\\text{KiB}$$\n$$p = 4\\,\\text{KiB}$$\n\n现在，将这些值代入不等式：\n$$N'_{\\text{entries}} \\ge \\frac{19.7 \\times 1024\\,\\text{KiB}}{4\\,\\text{KiB}}$$\n\nKiB单位相互抵消：\n$$N'_{\\text{entries}} \\ge 19.7 \\times \\frac{1024}{4}$$\n$$N'_{\\text{entries}} \\ge 19.7 \\times 256$$\n$$N'_{\\text{entries}} \\ge 5043.2$$\n\n由于TLB条目的数量必须是整数，且不等式要求该值大于或等于 $5043.2$，我们必须取满足此条件的最小整数。这可以通过对结果应用向上取整函数来实现。\n$$N'_{\\text{entries, min}} = \\lceil 5043.2 \\rceil = 5044$$\n\n因此，至少需要 $5044$ 个TLB条目才能确保TLB覆盖范围能够覆盖该进程的整个工作集。", "answer": "$$\\boxed{5044}$$", "id": "3689807"}, {"introduction": "程序访问数据的方式对虚拟内存性能有巨大影响，这一现象可以通过“局部性原理”来解释。本练习将通过一个经典案例，鲜明地展示具有良好空间局部性的内存访问模式与缺乏空间局部性的访问模式之间的巨大差异。通过比较对一个矩阵进行行主序和列主序遍历时产生的缺页中断次数，你将亲眼见证名为“颠簸”（thrashing）的性能灾难，并深刻体会到数据布局对高效编程的重要性 [@problem_id:3689767]。", "problem": "考虑一台实现固定大小分页虚拟内存的机器。一个程序分配了一个 $m \\times n$ 的元素矩阵，每个元素占用 $E$ 字节，在虚拟内存中以行主序连续布局。该矩阵的基虚拟地址与页面边界对齐。系统使用带有最近最少使用 (LRU) 替换策略的请求分页，没有预取，并且开始时没有矩阵页面驻留在物理内存中。该进程有且仅有 $f$ 个物理页框可用，并且在遍历期间没有其他内存活动竞争这些页框。当程序引用一个未驻留在物理内存中的虚拟页面时，就会发生缺页中断。\n\n您将比较对该矩阵的两种完整遍历：一种是按行主序访问元素，另一种是按列主序访问元素。对于两种遍历，每个矩阵元素都只被读取一次。仅使用以下给定的机器和工作负载参数：\n- $m = 1024$\n- $n = 1024$\n- $E = 8$ 字节\n- 页面大小 $P = 4096$ 字节\n- 可用页框数量 $f = 2$\n\n从虚拟内存、分页和引用局部性（时间和空间）的核心定义出发，根据这些假设推导出每次遍历所产生的总缺页中断数。然后，计算比率\n$$\\rho = \\frac{\\text{列主序遍历的总缺页中断数}}{\\text{行主序遍历的总缺页中断数}}。$$\n给出 $\\rho$ 的最终答案，形式为一个无单位的精确整数。", "solution": "该问题是有效的，因为它在科学上基于操作系统的原理，特别是虚拟内存管理，并且给出了唯一解所需的所有必要参数，因此问题是适定 (well-posed) 的。\n\n这个问题需要分析内存访问模式及其与分页式虚拟内存系统的交互。关键概念包括：虚拟内存，它为每个进程提供一个大的、私有的地址空间；分页，它将这个地址空间划分为称为页面的固定大小的块，这些页面被映射到物理内存的页框中；以及缺页中断，它在程序引用当前不在物理内存中的页面时发生。这种系统的性能在很大程度上受到引用局部性原理的影响，该原理指出程序倾向于访问其最近访问过的内存位置附近的位置。空间局部性指的是访问邻近内存地址的倾向，而时间局部性指的是重新访问相同位置的倾向。\n\n首先，我们根据给定值确定内存布局的相关参数。\n矩阵有 $m=1024$ 行和 $n=1024$ 列。\n每个元素为 $E=8$ 字节。\n页面大小为 $P=4096$ 字节。\n\n单个页面可以容纳的元素数量为：\n$$ N_{E/P} = \\frac{P}{E} = \\frac{4096}{8} = 512 \\text{ 个元素/页} $$\n\n一行的字节大小为：\n$$ S_{row} = n \\times E = 1024 \\times 8 = 8192 \\text{ 字节} $$\n\n存储单行所需的页面数量为：\n$$ N_{P/row} = \\frac{S_{row}}{P} = \\frac{8192}{4096} = 2 \\text{ 个页面/行} $$\n\n存储整个 $m \\times n$ 矩阵所需的虚拟页面总数为：\n$$ N_{pages} = m \\times N_{P/row} = 1024 \\times 2 = 2048 \\text{ 个页面} $$\n或者，矩阵的总大小为 $m \\times n \\times E = 1024 \\times 1024 \\times 8$ 字节。页面总数为 $\\frac{m \\times n \\times E}{P} = \\frac{1024 \\times 1024 \\times 8}{4096} = \\frac{2^{10} \\times 2^{10} \\times 2^3}{2^{12}} = 2^{23-12} = 2^{11} = 2048$ 个页面。\n\n设 $F_{row}$ 为行主序遍历的总缺页中断数。\n在行主序遍历中，程序访问元素 `A[0][0], A[0][1], ..., A[0][n-1], A[1][0], ...`。这种访问模式在虚拟内存中是顺序的，因为矩阵是按行主序布局的。这种遍历表现出非常高的空间局部性。在首次访问任何新页面上的元素时，都会发生一次缺页中断。由于系统使用请求分页且没有预取，程序接着会访问该同一页面上剩余的 $N_{E/P} - 1 = 511$ 个元素，所有这些访问都将是内存命中。因为遍历是纯粹顺序地通过矩阵的 $2048$ 个页面，并且只有 $f=2$ 个页框，所以它永远不需要重新调入一个很久以前被换出的页面。因此，每个唯一的页面恰好发生一次缺页中断。总缺页中断数等于矩阵占用的总页面数。\n$$ F_{row} = N_{pages} = 2048 $$\n\n设 $F_{col}$ 为列主序遍历的总缺页中断数。\n在列主序遍历中，程序访问元素 `A[0][0], A[1][0], ..., A[m-1][0], A[0][1], ...`。对于以行主序存储的矩阵，这种访问模式表现出非常差的空间局部性。\n让我们分析被访问的虚拟地址。元素 `A[i][j]` 的地址由其从0开始的索引位置 $(i, j)$ 决定，并与 $i \\times n + j$ 成正比。\n在列主序扫描中，`A[i][j]` 与下一个元素 `A[i+1][j]` 之间的虚拟地址跳跃为：\n$$ \\Delta_{\\text{address}} = ((i+1) \\times n + j) \\times E - (i \\times n + j) \\times E = n \\times E = 1024 \\times 8 = 8192 \\text{ 字节} $$\n这个地址跳跃等于 $2 \\times P$。这意味着在列扫描中，连续的元素访问相隔两个完整的页面大小。元素 `A[i][j]` 的虚拟页面是 $VP(i, j) = \\lfloor \\frac{(i \\times n + j) \\times E}{P} \\rfloor = \\lfloor \\frac{(i \\times 1024 + j) \\times 8}{4096} \\rfloor = \\lfloor 2i + \\frac{j}{512} \\rfloor$。\n\n考虑第一列 ($j=0$) 的遍历。程序访问 `A[0][0], A[1][0], A[2][0], ...`。\n- 访问 `A[0][0]`：页面 $VP(0,0)=0$。这导致一次缺页中断。页面 $0$ 被加载到页框1。驻留页面集合为 $\\{P_0\\}$。\n- 访问 `A[1][0]`：页面 $VP(1,0)=2$。这导致一次缺页中断。页面 $2$ 被加载到页框2。驻留页面集合为 $\\{P_0, P_2\\}$。最近最少使用的页面是 $P_0$。\n- 访问 `A[2][0]`：页面 $VP(2,0)=4$。这导致一次缺页中断。由于只有 $f=2$ 个页框，最近最少使用的页面 $P_0$ 被换出。页面 $4$ 被加载。驻留页面集合为 $\\{P_2, P_4\\}$。最近最少使用的页面是 $P_2$。\n- 访问 `A[3][0]`：页面 $VP(3,0)=6$。这导致一次缺页中断。最近最少使用的页面 $P_2$ 被换出。页面 $6$ 被加载。驻留页面集合为 $\\{P_4, P_6\\}$。最近最少使用的页面是 $P_4$。\n\n这种现象，即由于局部性所需的工作集页面数量超过了可用页框数量，导致每次访问都引起缺页中断，被称为颠簸（thrashing）。对于任何列 $j$，访问的页面序列是 $VP(0,j), VP(1,j), VP(2,j), \\dots$。页面号为 $\\lfloor \\frac{j}{512} \\rfloor, \\lfloor 2 + \\frac{j}{512} \\rfloor, \\lfloor 4 + \\frac{j}{512} \\rfloor, \\dots$。这是一个公差为 $2$ 的等差数列页面号。由于我们只有 $f=2$ 个页框，系统最多只能持有此序列中的两个页面。在任何一步，下一个所需的页面都保证不在内存中。因此，对每个元素 `A[i][j]` 的每一次内存访问都会导致一次缺页中断。\n\n矩阵中的元素总数为 $m \\times n$。\n$$ F_{col} = m \\times n = 1024 \\times 1024 = 1,048,576 $$\n\n最后，我们计算比率 $\\rho$：\n$$ \\rho = \\frac{F_{col}}{F_{row}} = \\frac{1024 \\times 1024}{2048} $$\n由于 $2048 = 2 \\times 1024$，我们有：\n$$ \\rho = \\frac{1024 \\times 1024}{2 \\times 1024} = \\frac{1024}{2} = 512 $$\n\n这个比率表明，忽略数据布局因而未能利用空间局部性的访问模式会导致严重的性能损失，即颠簸。\n\n对该比率的更一般性推导证实了这一结果。\n$$F_{col} = m \\times n$$\n$$F_{row} = \\frac{m \\times n \\times E}{P}$$\n$$\\rho = \\frac{F_{col}}{F_{row}} = \\frac{m \\times n}{\\frac{m \\times n \\times E}{P}} = \\frac{P}{E}$$\n代入给定值：\n$$\\rho = \\frac{4096}{8} = 512$$", "answer": "$$\\boxed{512}$$", "id": "3689767"}, {"introduction": "我们需要一种方法来衡量内存系统的平均性能，该方法需要同时考虑快速的内存命中和缓慢的缺页中断。本练习将引入“有效访问时间”（Effective Access Time, EAT）的概念，它是一种基于缺页中断概率计算的内存访问延迟的加权平均值。通过建立EAT模型，你可以量化缺页中断带来的性能损失，并评估旨在降低缺页率的缓存策略等优化措施所带来的收益，从而在系统设计和优化权衡中做出更明智的决策 [@problem_id:3689756]。", "problem": "一个计算系统使用虚拟内存来允许进程逻辑地寻址内存，而物理内存则通过页面进行访问。每次内存访问要么在主内存中命中，要么触发一个必须被服务的页面错误。设每次访问的主内存延迟为 $t$，由页面错误引起的额外服务时间为 $\\alpha$。设页面错误概率为 $p_f$，并假设在一个长序列中，内存访问是独立同分布的。\n\n从数学期望的定义出发，将有效访问时间（EAT）建模为代表单次访问延迟的随机变量的期望值。然后，考虑一种缓存策略，它将页面错误概率从 $p_{f0}$ 降低到 $p_{f1}$，其中 $p_{f1}  p_{f0}$。如果有效访问时间的减少量至少是基本主内存延迟 $t$ 的一个分数 $\\delta$，则定义该缓存为“关键”的。形式上，如果无缓存和有缓存的有效访问时间之差至少为 $\\delta t$，则该缓存是关键的。\n\n以 $t$、$p_{f0}$、$p_{f1}$ 和 $\\delta$ 表示，推导出一个闭式解阈值 $\\alpha^{\\star}$，使得缓存是关键的当且仅当 $\\alpha \\ge \\alpha^{\\star}$。\n\n最后，对于 $t = 80$ 纳秒、$p_{f0} = 0.03$、$p_{f1} = 0.012$ 和 $\\delta = 0.10$，数值计算这个阈值。将您的最终数值答案四舍五入到四位有效数字。以纳秒为单位表示最终阈值 $\\alpha^{\\star}$。", "solution": "问题陈述已经过验证，被认为是科学合理的、适定的和客观的。它为推导和评估指定的阈值提供了一套完整且一致的定义和数值。\n\n设 $X$ 为代表单次内存访问延迟的随机变量。问题陈述指出，一次内存访问可能导致以下两种结果之一：\n$1$. 在主内存中命中，发生概率为 $1 - p_f$。此事件的延迟为 $t$。\n$2$. 发生页面错误，概率为 $p_f$。此事件的延迟是主内存延迟和页面错误服务时间之和，即 $t + \\alpha$。\n\n有效访问时间（EAT）被定义为随机变量 $X$ 的数学期望，记为 $E[X]$。使用离散随机变量的期望定义，我们有：\n$$\n\\text{EAT} = E[X] = \\sum_{i} x_i P(X=x_i)\n$$\n在我们的情况下，访问时间的可能值 $x_i$ 是 $t$ 和 $t+\\alpha$。它们各自的概率是 $1-p_f$ 和 $p_f$。\n$$\n\\text{EAT} = (t) \\cdot (1 - p_f) + (t + \\alpha) \\cdot p_f\n$$\n展开此表达式，我们得到：\n$$\n\\text{EAT} = t - t \\cdot p_f + t \\cdot p_f + \\alpha \\cdot p_f\n$$\n$$\n\\text{EAT} = t + \\alpha \\cdot p_f\n$$\n这就是有效访问时间的一般公式。\n\n现在，我们考虑所提出的两种情况：无缓存和有缓存。\n设 $\\text{EAT}_0$ 为无缓存时的有效访问时间，此时页面错误概率为 $p_{f0}$。\n$$\n\\text{EAT}_0 = t + \\alpha \\cdot p_{f0}\n$$\n设 $\\text{EAT}_1$ 为采用缓存策略时的有效访问时间，此时页面错误概率降低至 $p_{f1}$。\n$$\n\\text{EAT}_1 = t + \\alpha \\cdot p_{f1}\n$$\n问题将缓存策略定义为“关键”的，条件是EAT的减少量至少是基本主内存延迟 $t$ 的一个分数 $\\delta$。这可以表示为以下不等式：\n$$\n\\text{EAT}_0 - \\text{EAT}_1 \\ge \\delta t\n$$\n我们将 $\\text{EAT}_0$ 和 $\\text{EAT}_1$ 的表达式代入此不等式：\n$$\n(t + \\alpha \\cdot p_{f0}) - (t + \\alpha \\cdot p_{f1}) \\ge \\delta t\n$$\n简化不等式的左侧：\n$$\nt + \\alpha \\cdot p_{f0} - t - \\alpha \\cdot p_{f1} \\ge \\delta t\n$$\n$$\n\\alpha \\cdot p_{f0} - \\alpha \\cdot p_{f1} \\ge \\delta t\n$$\n提取因子 $\\alpha$：\n$$\n\\alpha (p_{f0} - p_{f1}) \\ge \\delta t\n$$\n问题要求找到阈值 $\\alpha^{\\star}$，使得条件满足当且仅当 $\\alpha \\ge \\alpha^{\\star}$。为了找到这个阈值，我们必须对 $\\alpha$ 求解该不等式。由于问题指出缓存策略降低了页面错误概率，我们有 $p_{f1}  p_{f0}$，这意味着项 $(p_{f0} - p_{f1})$ 是正数。因此，我们可以在不等式两边同时除以 $(p_{f0} - p_{f1})$ 而不改变不等号的方向。\n$$\n\\alpha \\ge \\frac{\\delta t}{p_{f0} - p_{f1}}\n$$\n从这个不等式中，我们可以直接确定阈值 $\\alpha^{\\star}$：\n$$\n\\alpha^{\\star} = \\frac{\\delta t}{p_{f0} - p_{f1}}\n$$\n这就是阈值 $\\alpha^{\\star}$ 的闭式表达式。\n\n最后，我们使用给定的数值进行数值计算：$t = 80$ 纳秒、$p_{f0} = 0.03$、$p_{f1} = 0.012$ 和 $\\delta = 0.10$。\n将这些值代入 $\\alpha^{\\star}$ 的表达式中：\n$$\n\\alpha^{\\star} = \\frac{(0.10) \\cdot (80)}{0.03 - 0.012}\n$$\n$$\n\\alpha^{\\star} = \\frac{8}{0.018}\n$$\n$$\n\\alpha^{\\star} = \\frac{8}{\\frac{18}{1000}} = \\frac{8000}{18} = \\frac{4000}{9}\n$$\n计算数值：\n$$\n\\alpha^{\\star} = 444.444...\n$$\n问题要求将最终答案四舍五入到四位有效数字。前四位数字是 $4, 4, 4, 4$。第五位数字是 $4$，小于 $5$，所以我们向下舍入。\n$$\n\\alpha^{\\star} \\approx 444.4\n$$\n单位与延迟的单位相同，即纳秒。因此，阈值为 $444.4$ 纳秒。", "answer": "$$\n\\boxed{444.4}\n$$", "id": "3689756"}]}