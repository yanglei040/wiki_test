{"hands_on_practices": [{"introduction": "理解任何算法的第一步都是单步追踪其执行过程。第一个练习将提供一个直接的机会，让你观察先进先出（FIFO）策略的实际运作。通过追踪每个页面请求对应的内存帧状态，你将为其基于队列的机制建立坚实的直觉，并观察其简单的“最老页面出局”规则如何决定命中、缺页和替换。[@problem_id:3644489]", "problem": "一个进程在一个操作系统（OS）的请求分页虚拟内存下执行。先入先出（FIFO）页面置换策略维护一个按插入页框集合的时间排序的队列：当内存满时，发生未命中时，最老的页面（在队首）首先被换出，而队列顺序在命中时不会改变。初始时，所有页框都是空的。引用串为 $S = [2,3,2,1,5,2,4,5,3,2,5,2]$，可用页框的数量为 $k = 3$。\n\n从请求分页、缺页和FIFO队列行为的核心定义出发，重构在引用串 $S$ 中每次引用时的FIFO队列状态，明确指出每一步访问是命中还是未命中，以及如果是未命中，哪个页面被换出。解释你观察到的任何反直觉行为是如何由队列顺序以及FIFO在命中时不调整顺序这一事实引起的。\n\n在 $k=3$ 的情况下，计算整个引用串在FIFO策略下发生的所有缺页的总数。请以单个整数形式提供最终答案。无需四舍五入。", "solution": "该问题要求在一个请求分页虚拟内存系统中，分析先入先出（FIFO）页面置换算法。我们必须为给定的引用串重构内存状态，并计算缺页的总数。\n\n请求分页的基本原理是，只有当一个页面被引用且尚未在主存中时，它才会被从辅存加载到主存。尝试访问不在内存中的页面称为缺页（page fault）或未命中（miss）。访问已在内存中的页面称为命中（hit）。系统有固定数量的物理内存槽，称为页框，用 $k$ 表示。在本问题中，$k=3$。\n\nFIFO页面置换策略将内存中的页面集作为一个队列来管理。当一个页面被加载到内存时，它被添加到此队列的队尾。当发生缺页且所有页框都已占满时，队首的页面（即在内存中停留时间最长的页面）被选中换出。问题陈述指出了FIFO策略的一个关键特性：队列顺序完全由插入时间决定，并且在命中时不会改变。最老的页面仍然是最老的，无论它最近或多频繁地被访问过。\n\n我们给定的引用串是 $S = [2,3,2,1,5,2,4,5,3,2,5,2]$，可用页框数为 $k=3$。初始时，所有页框都是空的。我们将追踪FIFO队列（代表内存中的页面）的状态以及每次引用的缺页情况。队首在左侧，队尾在右侧。\n\n1.  引用页面 $2$：页框为空。这是一次未命中。页面 $2$ 被加载。\n    -   缺页数: $1$。\n    -   FIFO队列: $[2]$。\n\n2.  引用页面 $3$：页框未满。这是一次未命中。页面 $3$ 被加载。\n    -   缺页数: $1+1 = 2$。\n    -   FIFO队列: $[2, 3]$。\n\n3.  引用页面 $2$：页面 $2$ 已在内存中。这是一次命中。\n    -   缺页数: $2$。\n    -   FIFO队列: $[2, 3]$ (不变)。页面 $2$ 仍然是最老的页面。\n\n4.  引用页面 $1$：页框未满。这是一次未命中。页面 $1$ 被加载。\n    -   缺页数: $2+1 = 3$。\n    -   FIFO队列: $[2, 3, 1]$。页框现已满。\n\n5.  引用页面 $5$：页面 $5$ 不在内存中，且页框已满。这是一次未命中。队首的页面 $2$ 被换出。页面 $5$ 被插入到队尾。\n    -   缺页数: $3+1 = 4$。\n    -   FIFO队列: $[3, 1, 5]$。\n\n6.  引用页面 $2$：页面 $2$ 不在内存中。这是一次未命中。队首的页面 $3$ 被换出。页面 $2$ 被插入到队尾。\n    -   缺页数: $4+1 = 5$。\n    -   FIFO队列: $[1, 5, 2]$。\n\n7.  引用页面 $4$：页面 $4$ 不在内存中。这是一次未命中。队首的页面 $1$ 被换出。页面 $4$ 被插入到队尾。\n    -   缺页数: $5+1 = 6$。\n    -   FIFO队列: $[5, 2, 4]$。\n\n8.  引用页面 $5$：页面 $5$ 在内存中。这是一次命中。\n    -   缺页数: $6$。\n    -   FIFO队列: $[5, 2, 4]$ (不变)。\n\n9.  引用页面 $3$：页面 $3$ 不在内存中。这是一次未命中。队首的页面 $5$ 被换出。页面 $3$ 被插入到队尾。\n    -   缺页数: $6+1 = 7$。\n    -   FIFO队列: $[2, 4, 3]$。\n\n10. 引用页面 $2$：页面 $2$ 在内存中。这是一次命中。\n    -   缺页数: $7$。\n    -   FIFO队列: $[2, 4, 3]$ (不变)。页面 $2$ 仍然是最老的页面。\n\n11. 引用页面 $5$：页面 $5$ 不在内存中。这是一次未命中。队首的页面 $2$ 被换出。页面 $5$ 被插入到队尾。\n    -   缺页数: $7+1 = 8$。\n    -   FIFO队列: $[4, 3, 5]$。\n\n12. 引用页面 $2$：页面 $2$ 不在内存中。这是一次未命中。队首的页面 $4$ 被换出。页面 $2$ 被插入到队尾。\n    -   缺页数: $8+1 = 9$。\n    -   FIFO队列: $[3, 5, 2]$。\n\n模拟完成。缺页总数为 $9$。\n\nFIFO的反直觉行为在此追踪过程中清晰可见。例如，在第 $3$ 步，页面 $2$ 被引用（一次命中），表明它正在被活跃使用。然而，由于FIFO的队列顺序在命中时不变，页面 $2$ 仍然是“最老”的页面。因此，在第 $5$ 步，当必须换出一个页面为页面 $5$ 腾出空间时，最近使用过的页面 $2$ 被选为被置换者，仅仅因为它是在当前驻留页面中第一个被加载的。像最近最少使用（LRU）这样的算法，在第 $3$ 步命中后，会认为页面 $2$ 是最近使用过的页面，并在第 $5$ 步保护它不被换出。FIFO策略对访问模式的忽略导致了可能还有用的页面被换出，这会增加缺页率。这一点在页面 $2$ 被换出后不久就再次发生缺页（第 $6, 12$ 步）的情况中表现得很明显。这种看起来简单公平的算法表现却不佳的现象，是页面置换算法研究中的一个关键教训。", "answer": "$$\\boxed{9}$$", "id": "3644489"}, {"introduction": "虽然FIFO实现简单，但其性能有时会出人意料地违反直觉。本练习将探讨FIFO的一个著名弱点，即Belady异常，即分配更多内存反而可能导致更多页面错误。通过对同一引用字符串在不同数量的帧分配下计算缺页次数并进行比较，你将揭示导致这种不理想行为的具体条件。[@problem_id:3623347]", "problem": "一个按需分页的虚拟内存系统维护一个固定大小的物理帧集合，并在发生缺页时使用先进先出（FIFO）策略替换页面，即驻留在内存中时间最长（即最先到达）的页面被换出。当引用的页面当前未驻留在任何帧中时，就会发生缺页错误。假设所有帧最初都是空的，并且引用会将页面加载到一个空闲帧中（如果存在）；否则，FIFO策略会在加载新页面之前换出最旧的驻留页面。令 $f_{\\text{FIFO}}(k)$ 表示在给定引用字符串下，使用 $k$ 个帧并采用FIFO策略时的总缺页次数。\n\n给定经典引用序列 $S = (1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5)$，计算 $f_{\\text{FIFO}}(3)$ 和 $f_{\\text{FIFO}}(4)$，并从上述定义出发，解释为什么所得结果是Belady异常的一个例子，即在FIFO策略下增加帧数反而可能导致缺页次数增加。\n\n将您的最终答案表示为一个包含两个精确整数值的行矩阵 $\\begin{pmatrix} f_{\\text{FIFO}}(3)  f_{\\text{FIFO}}(4) \\end{pmatrix}$。无需四舍五入。", "solution": "问题陈述完全自洽，科学上基于操作系统内存管理的原理，并且定义明确。所有术语都是标准的且定义清晰，为得出唯一且可验证的解提供了基础。因此，该问题被认为是有效的。\n\n任务是计算给定引用字符串 $S = (1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5)$ 在使用先进先出（FIFO）页面替换策略且分别有 $k=3$ 和 $k=4$ 个帧时的缺页次数，记为 $f_{\\text{FIFO}}(3)$ 和 $f_{\\text{FIFO}}(4)$。随后，我们必须解释为什么这个结果展示了Belady异常。\n\nFIFO策略的运作方式类似于一个队列。当必须换出一个页面时，会选择在内存中驻留时间最长的那个。我们将为每种情况跟踪内存帧的状态。缺页用 'F' 表示，命中用 'H' 表示。帧内容代表当前在内存中的页面集合。“到达顺序”队列显示了从最旧到最新的页面。\n\n**情况1：$k=3$ 个帧**\n\n我们为 $f_{\\text{FIFO}}(3)$ 逐步模拟该过程。\n\n| 引用 | 页面 | 帧（集合） | 缺页/命中 | 到达顺序（最旧 $\\rightarrow$ 最新） | 操作 |\n|:---:|:---:|:---:|:---:|:---|:---|\n| 1 | $1$ | $\\{1\\}$ | F | $[1]$ | 将 $1$ 加载到空帧中。 |\n| 2 | $2$ | $\\{1, 2\\}$ | F | $[1, 2]$ | 将 $2$ 加载到空帧中。 |\n| 3 | $3$ | $\\{1, 2, 3\\}$ | F | $[1, 2, 3]$ | 将 $3$ 加载到空帧中。 |\n| 4 | $4$ | $\\{2, 3, 4\\}$ | F | $[2, 3, 4]$ | 换出 $1$（最旧），加载 $4$。 |\n| 5 | $1$ | $\\{3, 4, 1\\}$ | F | $[3, 4, 1]$ | 换出 $2$（最旧），加载 $1$。 |\n| 6 | $2$ | $\\{4, 1, 2\\}$ | F | $[4, 1, 2]$ | 换出 $3$（最旧），加载 $2$。 |\n| 7 | $5$ | $\\{1, 2, 5\\}$ | F | $[1, 2, 5]$ | 换出 $4$（最旧），加载 $5$。 |\n| 8 | $1$ | $\\{1, 2, 5\\}$ | H | $[1, 2, 5]$ | 页面 $1$ 在内存中。 |\n| 9 | $2$ | $\\{1, 2, 5\\}$ | H | $[1, 2, 5]$ | 页面 $2$ 在内存中。 |\n| 10 | $3$ | $\\{2, 5, 3\\}$ | F | $[2, 5, 3]$ | 换出 $1$（最旧），加载 $3$。 |\n| 11 | $4$ | $\\{5, 3, 4\\}$ | F | $[5, 3, 4]$ | 换出 $2$（最旧），加载 $4$。 |\n| 12 | $5$ | $\\{5, 3, 4\\}$ | H | $[5, 3, 4]$ | 页面 $5$ 在内存中。 |\n\n统计缺页（F）的次数，我们发现共有 $9$ 次缺页。\n因此，$f_{\\text{FIFO}}(3) = 9$。\n\n**情况2：$k=4$ 个帧**\n\n接下来，我们为 $f_{\\text{FIFO}}(4)$ 模拟该过程。\n\n| 引用 | 页面 | 帧（集合） | 缺页/命中 | 到达顺序（最旧 $\\rightarrow$ 最新） | 操作 |\n|:---:|:---:|:---:|:---:|:---|:---|\n| 1 | $1$ | $\\{1\\}$ | F | $[1]$ | 将 $1$ 加载到空帧中。 |\n| 2 | $2$ | $\\{1, 2\\}$ | F | $[1, 2]$ | 将 $2$ 加载到空帧中。 |\n| 3 | $3$ | $\\{1, 2, 3\\}$ | F | $[1, 2, 3]$ | 将 $3$ 加载到空帧中。 |\n| 4 | $4$ | $\\{1, 2, 3, 4\\}$| F | $[1, 2, 3, 4]$ | 将 $4$ 加载到空帧中。 |\n| 5 | $1$ | $\\{1, 2, 3, 4\\}$| H | $[1, 2, 3, 4]$ | 页面 $1$ 在内存中。 |\n| 6 | $2$ | $\\{1, 2, 3, 4\\}$| H | $[1, 2, 3, 4]$ | 页面 $2$ 在内存中。 |\n| 7 | $5$ | $\\{2, 3, 4, 5\\}$| F | $[2, 3, 4, 5]$ | 换出 $1$（最旧），加载 $5$。 |\n| 8 | $1$ | $\\{3, 4, 5, 1\\}$| F | $[3, 4, 5, 1]$ | 换出 $2$（最旧），加载 $1$。 |\n| 9 | $2$ | $\\{4, 5, 1, 2\\}$| F | $[4, 5, 1, 2]$ | 换出 $3$（最旧），加载 $2$。 |\n| 10 | $3$ | $\\{5, 1, 2, 3\\}$| F | $[5, 1, 2, 3]$ | 换出 $4$（最旧），加载 $3$。 |\n| 11 | $4$ | $\\{1, 2, 3, 4\\}$| F | $[1, 2, 3, 4]$ | 换出 $5$（最旧），加载 $4$。 |\n| 12 | $5$ | $\\{2, 3, 4, 5\\}$| F | $[2, 3, 4, 5]$ | 换出 $1$（最旧），加载 $5$。 |\n\n统计缺页（F）的次数，我们发现共有 $10$ 次缺页。\n因此，$f_{\\text{FIFO}}(4) = 10$。\n\n**Belady异常的解释**\n\n计算得到的值为 $f_{\\text{FIFO}}(3) = 9$ 和 $f_{\\text{FIFO}}(4) = 10$。我们观察到 $f_{\\text{FIFO}}(4) > f_{\\text{FIFO}}(3)$。这种增加分配的内存帧数反而导致缺页次数增加的现象，被称为Belady异常。这是一个违反直觉的结果，因为人们通常期望更多的资源（即更多的帧）会提升性能（即导致更少的缺页）。\n\n出现这种异常是因为FIFO替换算法不考虑页面的使用历史或将来被引用的可能性；它只考虑到达时间。本例中出现异常的具体原因可以通过比较帧状态来确定。\n\n在第7次引用时，引用串请求页面 $5$。\n- 在 $k=3$ 的情况下，帧包含 $\\{1, 2, 5\\}$。关键是，页面 $1$ 和 $2$ 仍然在内存中。随后对 $1$ 和 $2$ 的引用是命中的。\n- 在 $k=4$ 的情况下，帧包含 $\\{1, 2, 3, 4\\}$。最旧的页面是 $1$。为了加载页面 $5$，页面 $1$ 被换出。新状态为 $\\{2, 3, 4, 5\\}$。这次换出是有害的，因为在紧接着的下一步（第8次引用）就请求了页面 $1$，导致立即发生缺页。\n\n较大的帧集（$k = 4$）使得“错误”的页面（页面 $1$，它很快会再次被需要）成为驻留最久的页面，从而成为被替换的对象。相比之下，较小的帧集（$k = 3$）已经换出了那些不是立即需要的页面，从而形成了一种在后续引用中幸运地表现更好的帧构成。\n\nBelady异常是那些非“栈算法”的页面替换算法的一个特征。栈算法具有这样的性质：在引用字符串的任何时刻，拥有 $k$ 个帧的内存中的页面集合总是拥有 $k+1$ 个帧的内存中页面集合的子集。FIFO不满足此性质，如此处所示：在第7次引用后，$k=3$ 的帧集合为 $\\{1, 2, 5\\}$，而 $k=4$ 的帧集合为 $\\{2, 3, 4, 5\\}$。前者不是后者的子集。\n\n最终计算值以一个包含两个条目的行矩阵形式呈现。", "answer": "$$\n\\boxed{\\begin{pmatrix} 9  10 \\end{pmatrix}}\n$$", "id": "3623347"}, {"introduction": "要真正掌握一种算法，从纸上追踪到构建一个可工作的实现是至关重要的一步。这个动手编程挑战要求你从基本原理出发，构建一个FIFO页面替换模拟器，并使用链表来实现核心的队列数据结构。这个练习不仅会巩固你对FIFO的理解，还将加强你关于如何应用抽象数据结构来解决实际操作系统问题的知识。[@problem_id:3246836]", "problem": "设计并实现一个完整的、可运行的程序，该程序使用一个以单向链表实现的页框队列，来模拟操作系统（OS）虚拟内存管理器的先进先出（FIFO）页面置换策略。该模拟必须基于数据结构的基本原理：队列由入队和出队操作定义，并遵循元素按其插入顺序被移除的不变性；单向链表定义为一系列节点的序列，其中每个节点包含一个值和一个指向下一个节点的指针，通过头指针和尾指针，可以在与 $O(1)$ 成正比的时间内实现尾部插入和头部移除。页面置换被定义为当帧集合已满且必须加载新页面时，决定淘汰哪个现有页框的过程。在先进先出（FIFO）策略下，驻留时间最长的页面被淘汰，而不考虑其未来使用情况，这恰好是队列的头部。\n\n从以下核心定义和事实开始：\n- 队列 $Q$ 维护一个元素序列，其入队和出队操作满足不变性，即出队操作移除在队列中停留时间最长的元素。\n- 当同时维护头指针和尾指针时，单向链表支持 $O(1)$ 的尾部插入和 $O(1)$ 的头部移除，以及在一般情况下 $O(n)$ 的成员资格检查，其中 $n$ 表示节点数。\n- 页面引用串 $R$ 是一个页面编号序列，帧容量 $C$ 是一个非负整数，表示可同时驻留在内存中的最大页面数。\n- 当引用的页面已驻留时，发生页面命中；否则发生页面错误。发生错误时：\n  - 如果队列大小小于 $C$，则将该页面入队至队尾，不进行淘汰。\n  - 如果队列大小等于 $C$，则将队头（最旧的页面）出队，然后将新页面入队至队尾。\n\n将队列实现为带有显式节点对象的单向链表；不要使用内置的基于数组的队列抽象。使用该队列处理所有驻留和淘汰逻辑。内置数组（列表）唯一允许的用途是表示输入引用串和汇总最终输出结果。\n\n对每个测试用例，计算：\n- 页面错误的整数计数 $F$。\n- 页面命中的整数计数 $H$。\n- 页面错误率 $f = F / |R|$，以小数形式表示，四舍五入到四位小数（当 $|R| = 0$ 时定义为 $0$）。\n\n您的程序必须将模拟应用于以下测试套件，其中 $C$ 表示帧容量，$R$ 表示页面引用串：\n- 案例 1：$C = 3$, $R = [7,0,1,2,0,3,0,4,2,3,0,3,2]$。\n- 案例 2：$C = 1$, $R = [1,2,3,4,1]$。\n- 案例 3：$C = 4$, $R = [1,1,1,1,1,1]$。\n- 案例 4：$C = 4$, $R = []$。\n- 案例 5：$C = 4$, $R = [1,2,3,4]$。\n\n最终输出格式必须按顺序将所有测试用例的结果汇总为单行，该行包含一个由方括号括起来的逗号分隔列表，其中每个测试用例贡献一个包含三个值 $[F,H,f]$ 的列表。例如，输出形式必须为 $[[F_1,H_1,f_1],[F_2,H_2,f_2],\\dots]$。不得打印任何其他文本。", "solution": "问题陈述经分析后被确定为 **有效**。它在科学上基于操作系统和数据结构的既定原则，特别是先进先出（FIFO）页面置换算法及其使用基于单向链表的队列的实现。该问题定义明确，提供了所有必要的定义、约束和测试用例，以得出一个唯一的、可验证的解决方案。目标以清晰、明确的语言陈述。\n\n任务是模拟FIFO页面置换策略。该策略规定，当需要将一个页面加载到已满的内存帧集时，在内存中停留时间最长的页面将被淘汰。这种行为可以通过队列数据结构完美建模，该结构遵循先进先出的原则。问题要求使用单向链表从基本原理上实现此队列。\n\n首先，我们定义必要的数据结构。单向链表由节点组成。每个 `` `Node` `` 将存储一个 `` `value` ``（代表页面号）和一个 `` `next` `` 指针（引用列表中的后续节点）。\n\n接下来，我们构建 `` `Queue` `` 类。该类将管理节点集合，并且必须维护指向列表 `` `head` ``（第一个元素）和 `` `tail` ``（最后一个元素）的指针。它还将跟踪其当前的 `` `size` ``。这些属性使得基本的队列操作——入队和出队——能够以常数时间 $O(1)$ 执行。\n\n-   `` `head` ``：指向队列中第一个 `` `Node` `` 的指针。这是驻留时间最长的页面。\n-   `` `tail` ``：指向队列中最后一个 `` `Node` `` 的指针。这是最近添加的页面。\n-   `` `size` ``：队列中当前节点数的整数计数。\n\n`` `Queue` `` 类将实现以下方法：\n1.  `` `enqueue(value)` ``：此操作将一个新页面添加到内存中。创建一个包含 `` `value` `` 的新 `` `Node` ``。如果队列为空（`` `size = 0` ``），则 `` `head` `` 和 `` `tail` `` 指针都设置为这个新节点。否则，当前 `` `tail` `` 节点的 `` `next` `` 指针将更新为指向新节点，然后 `` `tail` `` 指针更新为这个新节点。`` `size` `` 会递增。这是一个 $O(1)$ 操作。\n2.  `` `dequeue()` ``：此操作从内存中淘汰最旧的页面。它移除队列 `` `head` `` 处的节点。检索 `` `head` `` 节点的 `` `value` ``，并将 `` `head` `` 指针前移到下一个节点 (`` `head.next` ``)。如果移除后队列变空，`` `tail` `` 指针也必须设置为 `` `None` ``。`` `size` `` 会递减。这是一个 $O(1)$ 操作。\n3.  `` `contains(value)` ``：此操作检查一个页面是否已驻留在内存中。它需要从 `` `head` `` 到 `` `tail` `` 遍历链表，将每个节点的 `` `value` `` 与目标值进行比较。如果找到该值，操作返回 `` `True` ``，否则返回 `` `False` ``。根据问题规定，这是一个 $O(n)$ 操作，其中 $n$ 是帧中当前的页面数。\n\n模拟过程是通过处理给定的页面引用串 $R$ 和固定的帧容量 $C$ 来进行的。我们将页面错误计数器 $F$ 和页面命中计数器 $H$ 初始化为 $0$。然后，我们遍历 $R$ 中的每个页面引用 $p$。\n\n对于每个页面 $p$：\n-   我们首先使用 `` `contains(p)` `` 方法检查它是否存在于我们的队列中。\n-   **情况1：页面命中。** 如果 `` `contains(p)` `` 返回 `` `True` ``，则页面已在内存中。我们增加命中计数器 $H$。队列的状态保持不变，因为FIFO在命中时不会改变页面的顺序。\n-   **情况2：页面错误。** 如果 `` `contains(p)` `` 返回 `` `False` ``，则页面不在内存中，发生页面错误。我们增加错误计数器 $F$，并按以下逻辑进行：\n    -   如果内存中的页面数小于容量 $C$（即 `` `queue.size`  $C$ ``），则有空闲帧。通过调用 `` `enqueue(p)` `` 将新页面 $p$ 添加到内存中。\n    -   如果内存已满（即 `` `queue.size` == $C$ ``），则必须替换一个页面。根据FIFO策略，我们通过调用 `` `dequeue()` `` 淘汰最旧的页面。然后，通过调用 `` `enqueue(p)` `` 将新页面 $p$ 加载到新释放的帧中。\n\n遍历完整个引用串 $R$ 后，一个测试用例的模拟就完成了。然后我们计算所需的指标：\n-   总页面错误数：$F$\n-   总页面命中数：$H$\n-   页面错误率：$f$。计算方法是总错误数与总引用数的比率，即 $f = F / |R|$。根据规定，如果引用串的长度 $|R|$ 为 $0$，则错误率 $f$ 定义为 $0$。结果四舍五入到四位小数。\n\n对问题陈述中提供的每个测试用例重复此过程，并将每个案例的结果 $[F, H, f]$ 汇总到一个最终列表中以供输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the FIFO page replacement simulation problem for the given test suite.\n    \"\"\"\n\n    class Node:\n        \"\"\"\n        A node in a singly linked list.\n        \"\"\"\n        def __init__(self, value):\n            self.value = value\n            self.next = None\n\n    class Queue:\n        \"\"\"\n        A queue implemented with a singly linked list, designed for FIFO simulation.\n        It supports O(1) enqueue and dequeue, and O(n) membership checking.\n        \"\"\"\n        def __init__(self):\n            self.head = None\n            self.tail = None\n            self.size = 0\n\n        def enqueue(self, value):\n            \"\"\"Adds an element to the tail of the queue in O(1).\"\"\"\n            new_node = Node(value)\n            if self.tail is None:\n                self.head = self.tail = new_node\n            else:\n                self.tail.next = new_node\n                self.tail = new_node\n            self.size += 1\n\n        def dequeue(self):\n            \"\"\"Removes an element from the head of the queue in O(1).\"\"\"\n            if self.head is None:\n                return None\n            \n            value = self.head.value\n            self.head = self.head.next\n            if self.head is None:\n                self.tail = None\n            \n            self.size -= 1\n            return value\n\n        def contains(self, value):\n            \"\"\"Checks if a value is in the queue by traversing the list in O(n).\"\"\"\n            current = self.head\n            while current:\n                if current.value == value:\n                    return True\n                current = current.next\n            return False\n\n    def fifo_simulation(capacity, ref_string):\n        \"\"\"\n        Simulates the FIFO page replacement algorithm.\n\n        Args:\n            capacity (int): The number of page frames.\n            ref_string (list[int]): The sequence of page references.\n\n        Returns:\n            tuple[int, int, float]: A tuple containing page faults (F),\n                                    page hits (H), and fault rate (f).\n        \"\"\"\n        page_frames = Queue()\n        page_faults = 0\n        page_hits = 0\n        \n        for page in ref_string:\n            if page_frames.contains(page):\n                page_hits += 1\n            else:\n                page_faults += 1\n                if page_frames.size == capacity:\n                    page_frames.dequeue()\n                page_frames.enqueue(page)\n        \n        num_references = len(ref_string)\n        if num_references == 0:\n            fault_rate = 0.0\n        else:\n            fault_rate = page_faults / num_references\n            \n        return page_faults, page_hits, fault_rate\n\n    # The test suite provided in the problem description.\n    test_cases = [\n        # Case 1\n        (3, [7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2]),\n        # Case 2\n        (1, [1, 2, 3, 4, 1]),\n        # Case 3\n        (4, [1, 1, 1, 1, 1, 1]),\n        # Case 4\n        (4, []),\n        # Case 5\n        (4, [1, 2, 3, 4]),\n    ]\n\n    all_results = []\n    for C, R in test_cases:\n        F, H, f = fifo_simulation(C, R)\n        all_results.append([F, H, f])\n\n    # Format the final output string exactly as required.\n    result_strings = []\n    for F, H, f in all_results:\n        # Format float to four decimal places.\n        f_str = f\"{f:.4f}\"\n        result_strings.append(f\"[{F},{H},{f_str}]\")\n        \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3246836"}]}