{"hands_on_practices": [{"introduction": "要真正掌握 Belady 异常，没有什么比亲眼见证其一步步发生更能说明问题的了。第一个练习要求你针对一个特定的页面请求序列，细致地追踪先进先出（FIFO）算法的执行过程，并比较在拥有3个和4个内存帧时的结果。通过精确定位异常发生的瞬间 [@problem_id:3623853]，你将对这一反直觉的现象建立起基础性的、机制层面的理解。", "problem": "一个单进程运行在一个具有虚拟内存的系统上，该系统被组织成固定大小的页面和固定数量的物理页框。每次内存引用都指向一个虚拟页面。如果被引用的页面不存在于任何页框中，就会发生缺页中断，此时会将一个页面加载到一个页框中，并在必要时根据页面替换策略换出一个驻留页面。所使用的策略是先进先出（FIFO），它会换出在内存中驻留时间最长的页面；一次命中不会改变FIFO队列中页面的顺序。\n\n考虑一个包含 $k=5$ 个不同虚拟页面（标记为 $\\{1,2,3,4,5\\}$）的引用串：\n$$\nR \\;=\\; (\\,1,\\,2,\\,3,\\,4,\\,1,\\,2,\\,5,\\,1,\\,2,\\,3,\\,4,\\,5\\,).\n$$\n假设物理页框集合和FIFO队列初始为空。设起初页框数量为 $n=3$，然后考虑增加一个页框，使得总数变为 $n+1=4$ 个页框。\n\n定义 $F_{m}(i)$ 为使用 $m$ 个页框的FIFO算法在处理 $R$ 的前 $i$ 个引用所组成的前缀时产生的累计缺页中断次数，其中 $i \\in \\{1,2,\\dots,|R|\\}$ 且 $m \\in \\{n,n+1\\}$。定义异常索引\n$$\ni^{\\star} \\;=\\; \\min \\big\\{\\, i \\in \\{1,2,\\dots,|R|\\} \\;\\big|\\; F_{n+1}(i) - F_{n}(i) \\;>\\; 0 \\,\\big\\},\n$$\n即，在FIFO策略下，将页框数从 $n$ 增加到 $n+1$ 导致累计缺页中断次数严格增加的最早引用位置。\n\n从上述核心定义出发，追踪在引用串 $R$ 上，当 $m=n$ 和 $m=n+1$ 时FIFO队列的演变过程，计算所有相关 $i$ 的 $F_{n}(i)$ 和 $F_{n+1}(i)$，并确定 $i^{\\star}$ 的值。将 $i^{\\star}$ 的最终值报告为单个整数。无需四舍五入，也无需报告单位。", "solution": "该问题陈述经确认为具有科学依据、定义明确且客观。它是操作系统中页面替换算法分析的一个标准练习。所有必要的数据和定义都已提供，没有矛盾或含糊不清之处。该问题是有效的。\n\n目标是找到异常索引 $i^{\\star}$，它被定义为在给定的引用串 $R$ 中，使得拥有 $m=n+1=4$ 个页框时的累计缺页中断次数 $F_{n+1}(i)$ 严格大于拥有 $m=n=3$ 个页框时的缺页中断次数 $F_{n}(i)$ 的最早引用位置 $i$。\n$$\ni^{\\star} \\;=\\; \\min \\big\\{\\, i \\in \\{1, 2, \\dots, |R|\\} \\;\\big|\\; F_{n+1}(i) - F_{n}(i) \\;>\\; 0 \\,\\big\\}\n$$\n引用串为 $R = (\\,1,\\,2,\\,3,\\,4,\\,1,\\,2,\\,5,\\,1,\\,2,\\,3,\\,4,\\,5\\,)$，页面替换算法为先进先出（FIFO）。物理页框初始为空。\n\n我们将追踪页框数分别为 $m=3$ 和 $m=4$ 时FIFO算法的执行过程，以计算累计缺页中断次数序列 $F_{3}(i)$ 和 $F_{4}(i)$。FIFO队列将表示为一个有序列表，其中最左边的页面是先进的（最旧的），最右边的页面是后进的（最新的）。\n\n首先，我们追踪 $n=3$ 个页框的情况。\n$$\n\\begin{array}{|c|c|l|c|c|}\n\\hline\n\\textbf{索引 } i  \\textbf{引用}  \\textbf{FIFO 队列状态 (最旧} \\to \\textbf{最新)}  \\textbf{缺页?}  \\textbf{累计缺页次数 } F_{3}(i) \\\\\n\\hline\n1  1  (1)  \\text{是}  1 \\\\\n2  2  (1, 2)  \\text{是}  2 \\\\\n3  3  (1, 2, 3)  \\text{是}  3 \\\\\n4  4  (2, 3, 4) \\quad \\text{(换出 1)}  \\text{是}  4 \\\\\n5  1  (3, 4, 1) \\quad \\text{(换出 2)}  \\text{是}  5 \\\\\n6  2  (4, 1, 2) \\quad \\text{(换出 3)}  \\text{是}  6 \\\\\n7  5  (1, 2, 5) \\quad \\text{(换出 4)}  \\text{是}  7 \\\\\n8  1  (1, 2, 5)  \\text{否}  7 \\\\\n9  2  (1, 2, 5)  \\text{否}  7 \\\\\n10  3  (2, 5, 3) \\quad \\text{(换出 1)}  \\text{是}  8 \\\\\n11  4  (5, 3, 4) \\quad \\text{(换出 2)}  \\text{是}  9 \\\\\n12  5  (5, 3, 4)  \\text{否}  9 \\\\\n\\hline\n\\end{array}\n$$\n对于 $n=3$ 个页框，累计缺页中断次数的序列为 $F_{3} = (1, 2, 3, 4, 5, 6, 7, 7, 7, 8, 9, 9)$。\n\n接下来，我们追踪 $n+1=4$ 个页框的情况。\n$$\n\\begin{array}{|c|c|l|c|c|}\n\\hline\n\\textbf{索引 } i  \\textbf{引用}  \\textbf{FIFO 队列状态 (最旧} \\to \\textbf{最新)}  \\textbf{缺页?}  \\textbf{累计缺页次数 } F_{4}(i) \\\\\n\\hline\n1  1  (1)  \\text{是}  1 \\\\\n2  2  (1, 2)  \\text{是}  2 \\\\\n3  3  (1, 2, 3)  \\text{是}  3 \\\\\n4  4  (1, 2, 3, 4)  \\text{是}  4 \\\\\n5  1  (1, 2, 3, 4)  \\text{否}  4 \\\\\n6  2  (1, 2, 3, 4)  \\text{否}  4 \\\\\n7  5  (2, 3, 4, 5) \\quad \\text{(换出 1)}  \\text{是}  5 \\\\\n8  1  (3, 4, 5, 1) \\quad \\text{(换出 2)}  \\text{是}  6 \\\\\n9  2  (4, 5, 1, 2) \\quad \\text{(换出 3)}  \\text{是}  7 \\\\\n10  3  (5, 1, 2, 3) \\quad \\text{(换出 4)}  \\text{是}  8 \\\\\n11  4  (1, 2, 3, 4) \\quad \\text{(换出 5)}  \\text{是}  9 \\\\\n12  5  (2, 3, 4, 5) \\quad \\text{(换出 1)}  \\text{是}  10 \\\\\n\\hline\n\\end{array}\n$$\n对于 $n+1=4$ 个页框，累计缺页中断次数的序列为 $F_{4} = (1, 2, 3, 4, 4, 4, 5, 6, 7, 8, 9, 10)$。\n\n最后，我们在每个步骤 $i$ 比较 $F_{3}(i)$ 和 $F_{4}(i)$，以找到使 $F_{4}(i) > F_{3}(i)$ 成立的最小 $i$。我们计算差值 $D(i) = F_{4}(i) - F_{3}(i)$。\n$$\n\\begin{array}{|c|c|c|c|}\n\\hline\n\\textbf{索引 } i  F_{3}(i)  F_{4}(i)  D(i) = F_{4}(i) - F_{3}(i) \\\\\n\\hline\n1  1  1  0 \\\\\n2  2  2  0 \\\\\n3  3  3  0 \\\\\n4  4  4  0 \\\\\n5  5  4  -1 \\\\\n6  6  4  -2 \\\\\n7  7  5  -2 \\\\\n8  7  6  -1 \\\\\n9  7  7  0 \\\\\n10  8  8  0 \\\\\n11  9  9  0 \\\\\n12  9  10  1 \\\\\n\\hline\n\\end{array}\n$$\n条件 $F_{4}(i) - F_{3}(i) > 0$ 在 $i=12$ 时首次满足，此时差值为 $10 - 9 = 1$。因此，异常索引为 $i^{\\star} = 12$。这种在FIFO策略下，增加可用页框数反而导致某些引用串的缺页中断次数增加的现象，被称为Belady异常。", "answer": "$$\\boxed{12}$$", "id": "3623853"}, {"introduction": "为什么 Belady 异常会影响 FIFO，却不会影响像最近最少使用（LRU）这样的其他算法？本练习旨在回答这个关键问题，它将引导你比较这两种算法在同一个引用字符串上的性能 [@problem_id:3623877]。通过计算并对比它们的缺页次数，你将发现它们行为上的根本差异，并深入理解使 LRU 免于此异常的“栈算法”特性。", "problem": "在一个请求分页的虚拟内存系统中，页面引用串是一个由页面标识符组成的有限序列。当请求的页面不在可用物理帧集合中驻留时，就会发生缺页中断。考虑两种页面置换策略：先入先出 (FIFO) 和最近最少使用 (LRU)。先入先出 (FIFO) 总是淘汰驻留时间最长的页面，而不考虑其使用情况；而最近最少使用 (LRU) 则淘汰最后一次访问时间距今最远的页面。对于一个策略 $P$ 和帧数 $n$，我们将缺页中断计数函数 $f_{P}(n)$ 定义为：在使用 $n$ 个可用帧、从一个初始为空的帧集开始且无预取的情况下，处理给定引用串所产生的缺页中断总数。\n\n设页面引用串为\n$$R = 1,2,3,4,1,2,5,1,2,3,4,5.$$\n假设帧初始为空，发生未命中时，如果有空闲帧，则载入页面，否则策略选择一个牺牲页进行置换；发生命中时，对于 FIFO，驻留集保持不变，对于 LRU，仅更新其近期性元数据。\n\n仅使用上述定义作为基本依据，推导字符串 $R$ 的 $f_{FIFO}(3)$、$f_{FIFO}(4)$、$f_{LRU}(3)$ 和 $f_{LRU}(4)$。然后，定义异常差距\n$$\\Delta \\equiv \\left(f_{FIFO}(4) - f_{FIFO}(3)\\right) - \\left(f_{LRU}(4) - f_{LRU}(3)\\right).$$\n用文字解释，计算出的值说明了对于此引用串，先入先出 (FIFO) 策略下是否出现 Belady 异常，以及最近最少使用 (LRU) 策略下是否可能出现该异常。将 $\\Delta$ 的值报告为一个精确的整数；无需四舍五入。", "solution": "该问题定义明确，并以操作系统原理（特别是页面置换算法）为科学依据。它提供了所有必要的定义、一个具体的引用串以及清晰的计算和分析指令。我们将通过系统地模拟先入先出 (FIFO) 和最近最少使用 (LRU) 算法在 $n=3$ 和 $n=4$ 个帧的情况下的行为，来确定各自的缺页中断计数。\n\n页面引用串给定为\n$$R = 1,2,3,4,1,2,5,1,2,3,4,5.$$\n我们用 F 表示缺页中断，用 H 表示命中。\n\n**1. $f_{FIFO}(3)$ 的计算**\n我们模拟具有 $n=3$ 个帧的 FIFO 策略。帧集合被当作一个队列来管理，其中队列头部的页面是驻留时间最长的页面，也是被淘汰的候选页面。\n\n| 引用 | 帧 (从最旧到最新) | 换入/换出 | 类型 | 缺页数 |\n|---|---|---|---|---|\n| $1$ | $[1]$ | $1$ 换入 | F | $1$ |\n| $2$ | $[1, 2]$ | $2$ 换入 | F | $2$ |\n| $3$ | $[1, 2, 3]$ | $3$ 换入 | F | $3$ |\n| $4$ | $[2, 3, 4]$ | $1$ 换出, $4$ 换入| F | $4$ |\n| $1$ | $[3, 4, 1]$ | $2$ 换出, $1$ 换入| F | $5$ |\n| $2$ | $[4, 1, 2]$ | $3$ 换出, $2$ 换入| F | $6$ |\n| $5$ | $[1, 2, 5]$ | $4$ 换出, $5$ 换入| F | $7$ |\n| $1$ | $[1, 2, 5]$ | - | H | $7$ |\n| $2$ | $[1, 2, 5]$ | - | H | $7$ |\n| $3$ | $[2, 5, 3]$ | $1$ 换出, $3$ 换入| F | $8$ |\n| $4$ | $[5, 3, 4]$ | $2$ 换出, $4$ 换入| F | $9$ |\n| $5$ | $[5, 3, 4]$ | - | H | $9$ |\n\n对于有 $3$ 个帧的 FIFO 策略，总缺页中断数为 $f_{FIFO}(3) = 9$。\n\n**2. $f_{FIFO}(4)$ 的计算**\n我们模拟具有 $n=4$ 个帧的 FIFO 策略。\n\n| 引用 | 帧 (从最旧到最新) | 换入/换出 | 类型 | 缺页数 |\n|---|---|---|---|---|\n| $1$ | $[1]$ | $1$ 换入 | F | $1$ |\n| $2$ | $[1, 2]$ | $2$ 换入 | F | $2$ |\n| $3$ | $[1, 2, 3]$ | $3$ 换入 | F | $3$ |\n| $4$ | $[1, 2, 3, 4]$ | $4$ 换入 | F | $4$ |\n| $1$ | $[1, 2, 3, 4]$ | - | H | $4$ |\n| $2$ | $[1, 2, 3, 4]$ | - | H | $4$ |\n| $5$ | $[2, 3, 4, 5]$ | $1$ 换出, $5$ 换入| F | $5$ |\n| $1$ | $[3, 4, 5, 1]$ | $2$ 换出, $1$ 换入| F | $6$ |\n| $2$ | $[4, 5, 1, 2]$ | $3$ 换出, $2$ 换入| F | $7$ |\n| $3$ | $[5, 1, 2, 3]$ | $4$ 换出, $3$ 换入| F | $8$ |\n| $4$ | $[1, 2, 3, 4]$ | $5$ 换出, $4$ 换入| F | $9$ |\n| $5$ | $[2, 3, 4, 5]$ | $1$ 换出, $5$ 换入| F | $10$|\n\n对于有 $4$ 个帧的 FIFO 策略，总缺页中断数为 $f_{FIFO}(4) = 10$。\n\n**3. $f_{LRU}(3)$ 的计算**\n我们模拟具有 $n=3$ 个帧的 LRU 策略。帧集合根据使用的近期性，作为一个栈或有序列表来管理。最近最少使用的页面位于栈底（或列表头部），而最近使用的页面位于栈顶（或列表尾部）。\n\n| 引用 | 帧 (从LRU到MRU) | 换入/换出 | 类型 | 缺页数 |\n|---|---|---|---|---|\n| $1$ | $[1]$ | $1$ 换入 | F | $1$ |\n| $2$ | $[1, 2]$ | $2$ 换入 | F | $2$ |\n| $3$ | $[1, 2, 3]$ | $3$ 换入 | F | $3$ |\n| $4$ | $[2, 3, 4]$ | $1$ 换出, $4$ 换入| F | $4$ |\n| $1$ | $[3, 4, 1]$ | $2$ 换出, $1$ 换入| F | $5$ |\n| $2$ | $[4, 1, 2]$ | $3$ 换出, $2$ 换入| F | $6$ |\n| $5$ | $[1, 2, 5]$ | $4$ 换出, $5$ 换入| F | $7$ |\n| $1$ | $[2, 5, 1]$ | - | H | $7$ |\n| $2$ | $[5, 1, 2]$ | - | H | $7$ |\n| $3$ | $[1, 2, 3]$ | $5$ 换出, $3$ 换入| F | $8$ |\n| $4$ | $[2, 3, 4]$ | $1$ 换出, $4$ 换入| F | $9$ |\n| $5$ | $[3, 4, 5]$ | $2$ 换出, $5$ 换入| F | $10$|\n\n对于有 $3$ 个帧的 LRU 策略，总缺页中断数为 $f_{LRU}(3) = 10$。\n\n**4. $f_{LRU}(4)$ 的计算**\n我们模拟具有 $n=4$ 个帧的 LRU 策略。\n\n| 引用 | 帧 (从LRU到MRU) | 换入/换出 | 类型 | 缺页数 |\n|---|---|---|---|---|\n| $1$ | $[1]$ | $1$ 换入 | F | $1$ |\n| $2$ | $[1, 2]$ | $2$ 换入 | F | $2$ |\n| $3$ | $[1, 2, 3]$ | $3$ 换入 | F | $3$ |\n| $4$ | $[1, 2, 3, 4]$ | $4$ 换入 | F | $4$ |\n| $1$ | $[2, 3, 4, 1]$ | - | H | $4$ |\n| $2$ | $[3, 4, 1, 2]$ | - | H | $4$ |\n| $5$ | $[4, 1, 2, 5]$ | $3$ 换出, $5$ 换入| F | $5$ |\n| $1$ | $[4, 2, 5, 1]$ | - | H | $5$ |\n| $2$ | $[4, 5, 1, 2]$ | - | H | $5$ |\n| $3$ | $[5, 1, 2, 3]$ | $4$ 换出, $3$ 换入| F | $6$ |\n| $4$ | $[1, 2, 3, 4]$ | $5$ 换出, $4$ 换入| F | $7$ |\n| $5$ | $[2, 3, 4, 5]$ | $1$ 换出, $5$ 换入| F | $8$ |\n\n对于有 $4$ 个帧的 LRU 策略，总缺页中断数为 $f_{LRU}(4) = 8$。\n\n**5. 结果分析与 $\\Delta$ 的计算**\n\n计算出的缺页中断计数如下：\n- $f_{FIFO}(3) = 9$\n- $f_{FIFO}(4) = 10$\n- $f_{LRU}(3) = 10$\n- $f_{LRU}(4) = 8$\n\n**Belady 异常：**\n当增加可用帧的数量导致缺页中断次数增加时，就会出现这种异常。\n\n对于 **FIFO** 策略，我们观察到 $f_{FIFO}(4) = 10 > f_{FIFO}(3) = 9$。这表明对于给定的引用串 $R$，将帧数从 $3$ 增加到 $4$ 会导致额外一次缺页中断。因此，在这种特定情况下，**FIFO 策略出现了 Belady 异常**。原因是 FIFO 不是一种“栈算法”；在引用串的任何时刻， $n$ 个帧的内存中的页面集合不一定是 $n+1$ 个帧的内存中页面集合的子集。淘汰决策完全基于到达时间，而非使用模式，这可能导致淘汰一个很快又会被需要的页面，而更多的帧反而会使这种情况恶化，这是一个悖论。\n\n对于 **LRU** 策略，我们观察到 $f_{LRU}(4) = 8  f_{LRU}(3) = 10$。将帧数从 $3$ 增加到 $4$ 减少了缺页中断的次数，这是预期的行为。因此，**LRU 策略没有出现 Belady 异常**。这是因为 LRU 是一种栈算法。对于任何栈算法，在引用串的任何时刻，驻留在 $n$ 个帧中的页面集合总是驻留在 $n+1$ 个帧中的页面集合的子集。此属性保证了缺页中断计数是帧数的非增函数，即对于任何 $n$，都有 $f_{P}(n+1) \\leq f_{P}(n)$。\n\n**异常差距 $\\Delta$ 的计算：**\n异常差距定义为 $\\Delta \\equiv \\left(f_{FIFO}(4) - f_{FIFO}(3)\\right) - \\left(f_{LRU}(4) - f_{LRU}(3)\\right)$。\n代入计算出的值：\n$$ \\Delta = (10 - 9) - (8 - 10) $$\n$$ \\Delta = (1) - (-2) $$\n$$ \\Delta = 1 + 2 = 3 $$\n$\\Delta$ 的值为 $3$。这个值代表了当帧数增加时，FIFO 性能的变化（异常增加 $1$ 次中断）与 LRU 性能的变化（正常减少 $2$ 次中断）之间的差异。", "answer": "$$\\boxed{3}$$", "id": "3623877"}, {"introduction": "在 FIFO 算法中，帧分配与缺页次数之间的关系不仅是非单调的，甚至可能是不可预测的。最后一个练习将探讨这种复杂性，展示一个从 $n$ 帧增加到 $n+1$ 帧时性能恶化，但再增加到 $n+2$ 帧时性能又显著改善的场景 [@problem_id:3623856]。这个练习突出了 FIFO 效率的不稳定特性，并再次强调了为什么我们不能简单地通过增加更多内存来可靠地预测其性能。", "problem": "一个计算机系统使用先进先出（FIFO）页面置换算法。页面引用串是页面标识符的序列。当引用的页面不在任何帧中时，会发生页面错误；如果存在空闲帧，则加载该页面，否则将驻留时间最长（即仍在内存中最早到达的页面）的页面换出。所有帧最初都是空的，FIFO使用基于到达时间的严格队列纪律；一次命中不会改变页面在队列中的位置。\n\n设 $f(k)$ 表示当有 $k$ 个页面帧时，FIFO在固定的引用串上产生的页面错误数。考虑引用串\n$$\nR = \\langle 2,3,4,5,2,3,1,2,3,4,5,1 \\rangle,\n$$\n并设 $n=3$。\n\n仅使用上述操作定义，通过精确模拟FIFO来确定给定 $R$ 的 $f(n)$、$f(n+1)$ 和 $f(n+2)$。以行矩阵的形式报告您的最终数值结果，顺序为 $\\big(f(n),\\,f(n+1),\\,f(n+2)\\big)$。\n\n无需四舍五入。仅将行矩阵作为您的最终答案。", "solution": "问题陈述已经过验证，被认为是自洽的、有科学依据的且定义明确的。它描述了操作系统研究中的一个标准场景——页面置换算法的模拟。定义是精确的，并且所需的计算可以通过算法执行以得出唯一解。我们将通过模拟先进先出（FIFO）页面置换算法来对指定数量的帧进行求解。\n\n任务是计算当页面帧数 $k \\in \\{3, 4, 5\\}$ 时，页面错误数 $f(k)$。给定的引用串是 $R = \\langle 2,3,4,5,2,3,1,2,3,4,5,1 \\rangle$。FIFO算法会换出在内存中停留时间最长的页面。我们维护一个当前在帧中的页面队列，其中队首是最旧的页面，队尾是最近加载的页面。\n\n**情况1：$k=n=3$ 个页面帧**\n\n我们用 $3$ 个帧来模拟该过程。页面错误用 'F' 标记，命中用 'H' 标记。跟踪帧的状态（作为集合）和FIFO队列（有序列表，从队首到队尾）。\n\n| 时间步 | 引用 | 帧内容（集合） | FIFO队列（最旧...最新） | 结果 |\n| :---: | :---: | :---: | :---: | :---: |\n| $1$ | $2$ | $\\{2\\}$ | $\\langle 2 \\rangle$ | F ($1$) |\n| $2$ | $3$ | $\\{2, 3\\}$ | $\\langle 2, 3 \\rangle$ | F ($2$) |\n| $3$ | $4$ | $\\{2, 3, 4\\}$ | $\\langle 2, 3, 4 \\rangle$ | F ($3$) |\n| $4$ | $5$ | $\\{3, 4, 5\\}$ | $\\langle 3, 4, 5 \\rangle$ | F ($4$, 换出 $2$) |\n| $5$ | $2$ | $\\{4, 5, 2\\}$ | $\\langle 4, 5, 2 \\rangle$ | F ($5$, 换出 $3$) |\n| $6$ | $3$ | $\\{5, 2, 3\\}$ | $\\langle 5, 2, 3 \\rangle$ | F ($6$, 换出 $4$) |\n| $7$ | $1$ | $\\{2, 3, 1\\}$ | $\\langle 2, 3, 1 \\rangle$ | F ($7$, 换出 $5$) |\n| $8$ | $2$ | $\\{2, 3, 1\\}$ | $\\langle 2, 3, 1 \\rangle$ | H |\n| $9$ | $3$ | $\\{2, 3, 1\\}$ | $\\langle 2, 3, 1 \\rangle$ | H |\n| $10$ | $4$ | $\\{3, 1, 4\\}$ | $\\langle 3, 1, 4 \\rangle$ | F ($8$, 换出 $2$) |\n| $11$ | $5$ | $\\{1, 4, 5\\}$ | $\\langle 1, 4, 5 \\rangle$ | F ($9$, 换出 $3$) |\n| $12$ | $1$ | $\\{1, 4, 5\\}$ | $\\langle 1, 4, 5 \\rangle$ | H |\n\n对于 $k=3$ 个帧，总页面错误数为 $9$。因此，$f(3) = 9$。\n\n**情况2：$k=n+1=4$ 个页面帧**\n\n我们用 $4$ 个帧重复此模拟。\n\n| 时间步 | 引用 | 帧内容（集合） | FIFO队列（最旧...最新） | 结果 |\n| :---: | :---: | :---: | :---: | :---: |\n| $1$ | $2$ | $\\{2\\}$ | $\\langle 2 \\rangle$ | F ($1$) |\n| $2$ | $3$ | $\\{2, 3\\}$ | $\\langle 2, 3 \\rangle$ | F ($2$) |\n| $3$ | $4$ | $\\{2, 3, 4\\}$ | $\\langle 2, 3, 4 \\rangle$ | F ($3$) |\n| $4$ | $5$ | $\\{2, 3, 4, 5\\}$ | $\\langle 2, 3, 4, 5 \\rangle$ | F ($4$) |\n| $5$ | $2$ | $\\{2, 3, 4, 5\\}$ | $\\langle 2, 3, 4, 5 \\rangle$ | H |\n| $6$ | $3$ | $\\{2, 3, 4, 5\\}$ | $\\langle 2, 3, 4, 5 \\rangle$ | H |\n| $7$ | $1$ | $\\{3, 4, 5, 1\\}$ | $\\langle 3, 4, 5, 1 \\rangle$ | F ($5$, 换出 $2$) |\n| $8$ | $2$ | $\\{4, 5, 1, 2\\}$ | $\\langle 4, 5, 1, 2 \\rangle$ | F ($6$, 换出 $3$) |\n| $9$ | $3$ | $\\{5, 1, 2, 3\\}$ | $\\langle 5, 1, 2, 3 \\rangle$ | F ($7$, 换出 $4$) |\n| $10$ | $4$ | $\\{1, 2, 3, 4\\}$ | $\\langle 1, 2, 3, 4 \\rangle$ | F ($8$, 换出 $5$) |\n| $11$ | $5$ | $\\{2, 3, 4, 5\\}$ | $\\langle 2, 3, 4, 5 \\rangle$ | F ($9$, 换出 $1$) |\n| $12$ | $1$ | $\\{3, 4, 5, 1\\}$ | $\\langle 3, 4, 5, 1 \\rangle$ | F ($10$, 换出 $2$) |\n\n对于 $k=4$ 个帧，总页面错误数为 $10$。因此，$f(4) = 10$。\n我们观察到 $f(4) > f(3)$，这是 Belady 异常的一个实例，它是 FIFO 算法的一个已知特性。\n\n**情况3：$k=n+2=5$ 个页面帧**\n\n最后，我们用 $5$ 个帧进行模拟。\n\n| 时间步 | 引用 | 帧内容（集合） | FIFO队列（最旧...最新） | 结果 |\n| :---: | :---: | :---: | :---: | :---: |\n| $1$ | $2$ | $\\{2\\}$ | $\\langle 2 \\rangle$ | F ($1$) |\n| $2$ | $3$ | $\\{2, 3\\}$ | $\\langle 2, 3 \\rangle$ | F ($2$) |\n| $3$ | $4$ | $\\{2, 3, 4\\}$ | $\\langle 2, 3, 4 \\rangle$ | F ($3$) |\n| $4$ | $5$ | $\\{2, 3, 4, 5\\}$ | $\\langle 2, 3, 4, 5 \\rangle$ | F ($4$) |\n| $5$ | $2$ | $\\{2, 3, 4, 5\\}$ | $\\langle 2, 3, 4, 5 \\rangle$ | H |\n| $6$ | $3$ | $\\{2, 3, 4, 5\\}$ | $\\langle 2, 3, 4, 5 \\rangle$ | H |\n| $7$ | $1$ | $\\{2, 3, 4, 5, 1\\}$ | $\\langle 2, 3, 4, 5, 1 \\rangle$ | F ($5$) |\n| $8$ | $2$ | $\\{2, 3, 4, 5, 1\\}$ | $\\langle 2, 3, 4, 5, 1 \\rangle$ | H |\n| $9$ | $3$ | $\\{2, 3, 4, 5, 1\\}$ | $\\langle 2, 3, 4, 5, 1 \\rangle$ | H |\n| $10$ | $4$ | $\\{2, 3, 4, 5, 1\\}$ | $\\langle 2, 3, 4, 5, 1 \\rangle$ | H |\n| $11$ | $5$ | $\\{2, 3, 4, 5, 1\\}$ | $\\langle 2, 3, 4, 5, 1 \\rangle$ | H |\n| $12$ | $1$ | $\\{2, 3, 4, 5, 1\\}$ | $\\langle 2, 3, 4, 5, 1 \\rangle$ | H |\n\n引用串中的唯一页面集合是 $\\{1, 2, 3, 4, 5\\}$，其基数为 $5$。由于可用帧数 $k=5$ 等于唯一页面的数量，因此页面错误仅在首次引用每个唯一页面时发生。在前 $7$ 个时间步之后，所有唯一页面都已加载到帧中，不再发生换出或错误。\n对于 $k=5$ 个帧，总页面错误数为 $5$。因此，$f(5) = 5$。\n\n**结果摘要**\n计算出的页面错误数如下：\n$f(n) = f(3) = 9$\n$f(n+1) = f(4) = 10$\n$f(n+2) = f(5) = 5$\n\n问题要求将这些结果以行矩阵 $\\big(f(n),\\,f(n+1),\\,f(n+2)\\big)$ 的形式报告。\n代入我们找到的值：$\\begin{pmatrix} 9  10  5 \\end{pmatrix}$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 9  10  5 \\end{pmatrix}}\n$$", "id": "3623856"}]}