{"hands_on_practices": [{"introduction": "需求分页性能分析的核心是有效访问时间（$EAT$），它综合了快速的内存命中时间和缓慢的缺页处理时间。本练习 [@problem_id:3668900] 将这一概念置于一个具体的硬件对比场景中，要求你计算并比较使用固态硬盘（SSD）与传统机械硬盘（HDD）作为后备存储时的 $EAT$。通过解决这个问题，你不仅能练习 $EAT$ 的计算，还能通过分析不同设备对平均性能和关键的性能可预测性（延迟的方差和尾部延迟）的影响，建立起对现代系统为何普遍青睐SSD的直观理解。", "problem": "一个进程在一台工作站上使用请求分页和单级页表，其主存访问时间为 $t_{m} = 0.1 \\,\\mu \\text{s}$。每次内存引用时，发生缺页的概率为 $p = 2 \\times 10^{-4}$。当发生缺页时，操作系统会陷入内核，更新页表，调度读取缺失的页面，并恢复进程。此处理过程中输入/输出之外的处理器开销为 $t_{\\text{os}} = 25 \\,\\mu \\text{s}$。\n\n后备存储是固态硬盘 (SSD) 或机械硬盘 (HDD)。对于每次缺页，存储服务时间包括固定的控制器延迟和页面的顺序传输时间。将存储延迟建模为随机变量 $L$，其均值为 $\\mathbb{E}[L]$，方差为 $\\operatorname{Var}(L)$；页面传输时间由 $t_{x} = S / B$ 给出，其中 $S$ 是页面大小，$B$ 是持续读取带宽。页面大小为 $S = 4096 \\text{ 字节}$。假设对于SSD，$\\mathbb{E}[L_{\\text{SSD}}] = 100 \\,\\mu \\text{s}$ 且 $\\operatorname{Var}(L_{\\text{SSD}}) = (20 \\,\\mu \\text{s})^{2}$，其持续带宽为 $B_{\\text{SSD}} = 500 \\times 10^{6} \\text{ 字节/秒}$。假设对于HDD，$\\mathbb{E}[L_{\\text{HDD}}] = 6000 \\,\\mu \\text{s}$ 且 $\\operatorname{Var}(L_{\\text{HDD}}) = (3000 \\,\\mu \\text{s})^{2}$，其持续带宽为 $B_{\\text{HDD}} = 150 \\times 10^{6} \\text{ 字节/秒}$。\n\n仅使用伯努利混合结果（无故障与缺页）的期望值定义和上述参数，推导在SSD和HDD下有效访问时间 (EAT) 的表达式。然后计算差值 $\\Delta EAT = EAT_{\\text{HDD}} - EAT_{\\text{SSD}}$，结果为一个实数。最后，从方差和尾部概率的基本原理出发，定性地解释为什么相对于HDD，使用SSD作为后备存储可以减少访问时间的方差和缺页的尾延迟。\n\n将 $\\Delta EAT$ 的最终数值以 $\\mu \\text{s}$ 为单位表示，并四舍五入到四位有效数字。", "solution": "该问题要求推导有效访问时间 (EAT) 的表达式，计算使用机械硬盘 (HDD) 和固态硬盘 (SSD) 作为后备存储时的 EAT 差异，并对 SSD 在访问时间方差和尾延迟方面的性能优势进行定性解释。\n\n首先，我们建立有效访问时间的模型。一次内存引用会产生两种结果之一：如果页面在主存中，则访问成功（此事件概率为 $1-p$）；如果不在，则发生缺页（此事件概率为 $p$）。EAT 是此伯努利分布结果下访问时间的期望值。\n\n设 $T_{hit}$ 为页面在内存中时的内存访问时间，设 $T_{fault}$ 为处理缺页的时间。问题指定主存访问时间为 $t_m$。在没有关于转译后备缓冲器 (TLB) 或多级页表的进一步信息的情况下，我们将无故障访问时间 $T_{hit}$ 定义为 $t_m$。那么 EAT 由下式给出：\n$$EAT = (1-p) \\cdot T_{hit} + p \\cdot \\mathbb{E}[T_{fault}]$$\n此处，$\\mathbb{E}[T_{fault}]$ 是期望的缺页服务时间。\n\n缺页服务时间 $T_{fault}$ 由几个部分组成：操作系统开销 ($t_{os}$)、存储设备延迟 ($L$) 和页面传输时间 ($t_x$)。\n$$T_{fault} = t_{os} + L + t_x$$\n延迟 $L$ 是一个随机变量，而对于给定的设备，$t_{os}$ 和 $t_x$ 是常数。通过应用期望的线性性质，可以找到期望的缺页服务时间：\n$$\\mathbb{E}[T_{fault}] = \\mathbb{E}[t_{os} + L + t_x] = t_{os} + \\mathbb{E}[L] + t_x$$\n\n页面传输时间 $t_x$ 由页面大小 $S$ 和设备的持续读取带宽 $B$ 决定，其中 $t_x = S/B$。我们分别为 SSD 和 HDD 计算这个值。\n\n对于 SSD：\n$S = 4096 \\text{ 字节}$\n$B_{\\text{SSD}} = 500 \\times 10^{6} \\text{ 字节/秒}$\n$$t_{x, \\text{SSD}} = \\frac{S}{B_{\\text{SSD}}} = \\frac{4096}{500 \\times 10^{6}} \\text{ s} = 8.192 \\times 10^{-6} \\text{ s} = 8.192 \\,\\mu\\text{s}$$\n\n对于 HDD：\n$S = 4096 \\text{ 字节}$\n$B_{\\text{HDD}} = 150 \\times 10^{6} \\text{ 字节/秒}$\n$$t_{x, \\text{HDD}} = \\frac{S}{B_{\\text{HDD}}} = \\frac{4096}{150 \\times 10^{6}} \\text{ s} \\approx 27.3067 \\times 10^{-6} \\text{ s} = 27.3067 \\,\\mu\\text{s}$$\n\n现在，我们可以使用给定的参数为每种设备写出期望的缺页服务时间的完整表达式：$t_{os} = 25 \\,\\mu\\text{s}$，$\\mathbb{E}[L_{\\text{SSD}}] = 100 \\,\\mu\\text{s}$，以及 $\\mathbb{E}[L_{\\text{HDD}}] = 6000 \\,\\mu\\text{s}$。\n\nSSD的期望缺页时间：\n$$\\mathbb{E}[T_{\\text{fault, SSD}}] = t_{os} + \\mathbb{E}[L_{\\text{SSD}}] + t_{x, \\text{SSD}} = 25 \\,\\mu\\text{s} + 100 \\,\\mu\\text{s} + 8.192 \\,\\mu\\text{s} = 133.192 \\,\\mu\\text{s}$$\n\nHDD的期望缺页时间：\n$$\\mathbb{E}[T_{\\text{fault, HDD}}] = t_{os} + \\mathbb{E}[L_{\\text{HDD}}] + t_{x, \\text{HDD}} \\approx 25 \\,\\mu\\text{s} + 6000 \\,\\mu\\text{s} + 27.3067 \\,\\mu\\text{s} = 6052.3067 \\,\\mu\\text{s}$$\n\n每种配置的有效访问时间为：\n$$EAT_{\\text{SSD}} = (1-p)t_m + p \\cdot \\mathbb{E}[T_{\\text{fault, SSD}}]$$\n$$EAT_{\\text{HDD}} = (1-p)t_m + p \\cdot \\mathbb{E}[T_{\\text{fault, HDD}}]$$\n\n我们需要计算差值 $\\Delta EAT = EAT_{\\text{HDD}} - EAT_{\\text{SSD}}$。\n$$\\Delta EAT = \\left( (1-p)t_m + p \\cdot \\mathbb{E}[T_{\\text{fault, HDD}}] \\right) - \\left( (1-p)t_m + p \\cdot \\mathbb{E}[T_{\\text{fault, SSD}}] \\right)$$\n项 $(1-p)t_m$ 消去，表达式简化为：\n$$\\Delta EAT = p \\left( \\mathbb{E}[T_{\\text{fault, HDD}}] - \\mathbb{E}[T_{\\text{fault, SSD}}] \\right)$$\n代入计算出的值：\n$$\\Delta EAT = (2 \\times 10^{-4}) \\left( 6052.3067 \\,\\mu\\text{s} - 133.192 \\,\\mu\\text{s} \\right)$$\n$$\\Delta EAT = (2 \\times 10^{-4}) \\left( 5919.1147 \\,\\mu\\text{s} \\right)$$\n$$\\Delta EAT \\approx 1.1838229 \\,\\mu\\text{s}$$\n四舍五入到四位有效数字得到 $1.184 \\,\\mu\\text{s}$。\n\n最后，我们定性地解释为什么相对于 HDD，SSD 可以减少访问时间的方差和缺页的尾延迟。\n\n1.  **访问时间的方差**：缺页服务时间 $T_{fault} = t_{os} + L + t_x$ 中的随机部分是存储延迟 $L$，因为 $t_{os}$ 和 $t_x$ 都是确定性常数。因此，缺页服务时间的方差等于延迟的方差：$\\operatorname{Var}(T_{fault}) = \\operatorname{Var}(t_{os} + L + t_x) = \\operatorname{Var}(L)$。问题提供了这些方差：\n    $$\\operatorname{Var}(L_{\\text{SSD}}) = (20 \\,\\mu\\text{s})^2 = 400 \\,(\\mu\\text{s})^2$$\n    $$\\operatorname{Var}(L_{\\text{HDD}}) = (3000 \\,\\mu\\text{s})^2 = 9 \\times 10^6 \\,(\\mu\\text{s})^2$$\n    标准差分别为 $\\sigma_{\\text{SSD}} = 20 \\,\\mu\\text{s}$ 和 $\\sigma_{\\text{HDD}} = 3000 \\,\\mu\\text{s}$。HDD 延迟的方差（和标准差）比 SSD 的要大几个数量级。这是它们物理性质的直接结果。HDD 的延迟主要由机械操作决定：移动读写磁头到正确磁道的寻道时间，以及等待所需扇区旋转到磁头下的旋转延迟。这些时间高度可变，取决于磁头和磁盘的初始和最终位置。相比之下，SSD 的延迟是纯电子的，涉及寻址和访问闪存单元，这是一个确定性高得多、也更一致的过程。操作上的这种根本差异解释了为什么 $\\operatorname{Var}(L_{\\text{HDD}}) \\gg \\operatorname{Var}(L_{\\text{SSD}})$，因此使用 SSD 时缺页服务时间的方差要小得多。\n\n2.  **尾延迟**：尾延迟指的是观察到非常长的服务时间的概率，通常用服务时间分布的高百分位数（例如第99或99.9百分位数）来表征。一个方差较大的随机变量将具有更宽的概率分布，意味着其值更分散地分布在均值周围。一个具有较大方差和/或较大均值的分布通常会有一个“更重”或“更长”的尾部，这表明观察到远离均值的结果的概率不可忽略。HDD 的延迟分布既有大得多的均值（$\\mathbb{E}[L_{\\text{HDD}}] = 6000 \\,\\mu\\text{s}$ 对比 $\\mathbb{E}[L_{\\text{SSD}}] = 100 \\,\\mu\\text{s}$），也有大得多的方差。因此，对于 HDD 来说，经历比平均值长得多的缺页服务时间（即尾延迟事件）的概率要高得多。对于 SSD，其低均值和极小的方差意味着其延迟分布是高度集中的，使得极长的延迟变得非常不可能。因此，SSD 不仅提供了更快的平均性能，而且性能更可预测，最坏情况下的延迟峰值发生率也低得多。", "answer": "$$\\boxed{1.184}$$", "id": "3668900"}, {"introduction": "硬件决定了单次缺页的代价，而页面置换算法的选择则决定了缺页发生的频率。本练习 [@problem_id:3668817] 要求你在一个精心构造的内存引用序列上，手动追踪并比较几种关键算法——FIFO、LRU和Clock——的性能。通过这种亲手实践的分析，你将加深对它们不同行为的理解，并接触到一些基本的理论特性，例如栈属性和著名的Belady异常，后者揭示了某些算法与直觉相悖的性能表现。", "problem": "一个虚拟内存系统使用请求分页机制，其主存为包含 $M$ 个页帧的全相联内存，运行一个其访问流呈现出明显局部性阶段的单一进程。考虑以下由两个阶段 $\\mathcal{A}$ 和 $\\mathcal{B}$ 重复拼接两次构成的访问轨迹 $\\mathcal{S}$：\n$$\n\\mathcal{A} = [\\,1,\\,2,\\,1,\\,2,\\,1,\\,2,\\,3,\\,1,\\,2,\\,1,\\,2,\\,3\\,], \\quad\n\\mathcal{B} = [\\,1,\\,2,\\,3,\\,4,\\,1,\\,2,\\,5,\\,1,\\,2,\\,3,\\,4,\\,5\\,],\n$$\n因此\n$$\n\\mathcal{S} = \\mathcal{A} \\,\\Vert\\, \\mathcal{B} \\,\\Vert\\, \\mathcal{A} \\,\\Vert\\, \\mathcal{B},\n$$\n其中 $\\Vert$ 表示拼接。$\\mathcal{S}$ 的总长度为 $48$ 次访问。需要比较的页面置换算法有：先进先出（FIFO）、最近最少使用（LRU）和第二次机会（Clock）算法。假设为单级统一内存访问，快表（Translation Lookaside Buffer）效应可忽略不计，并且在处理 $\\mathcal{S}$ 的第一次访问之前，所有页帧初始为空，所有引用位均已清零。\n\n您将使用重用（栈）距离的概念来分析请求分页的性能。对于时刻 $t$ 对某个页面的访问，其重用距离 $K$ 定义为从该页面上一次被访问到当前时刻 $t$ 之间，严格地被访问过的不同页面的数量；对于一个页面的首次访问（无先前访问记录），令 $K = \\infty$。设 $D(k)$ 表示在整个轨迹 $\\mathcal{S}$ 上测得的 $K$ 的经验分布，即对于每个 $k \\in \\{1,2,3,\\dots\\}$ 和 $k=\\infty$，$D(k)$ 是 $\\mathcal{S}$ 中重用距离等于 $k$ 的访问所占的比例。\n\n任务：\n- 仅使用请求分页、重用距离的核心定义以及 LRU 的定性栈属性（即在同一轨迹上，使用 $M$ 个帧的 LRU 内存中的页面集合总是使用 $M-1$ 个帧时的超集），计算给定 $\\mathcal{S}$ 的经验分布 $D(k)$。\n- 从基本原理出发，推导如何根据 $D(k)$ 和帧数 $M$ 计算 LRU 的期望缺页次数，并对 $\\mathcal{S}$ 在 $M=3$ 的情况下进行求值。\n- 通过对算法定义的直接推理，确定当 $M=3$ 时，在 $\\mathcal{S}$ 上 FIFO 和第二次机会（Clock）算法所产生的总缺页次数，并与您从 $D(k)$ 推导出的 LRU 结果进行定性比较。\n- 专注于单个阶段 $\\mathcal{B}$（该 12 次访问的子序列），在冷启动（$\\mathcal{B}$ 开始时帧为空）的条件下，通过比较 FIFO 在该子序列上 $M=3$ 与 $M=4$ 时的总缺页次数，讨论 FIFO 算法出现 Belady 异常的风险，并从缺乏栈属性的角度解释任何观察到的异常的根本原因。\n\n最终答案仅提供在整个 $48$ 次访问的轨迹 $\\mathcal{S}$ 上，$M=3$ 时 LRU 的期望总缺页次数，以一个不带单位的整数形式给出。不要在最终答案框中包含中间结果。", "solution": "我们从核心定义开始。当被访问的页面不在 $M$ 个页帧的集合中时，就会发生缺页。对于一次访问，其重用距离 $K$ 是指从该页面上一次出现到当前时刻之间，严格地被访问过的不同页面的数量；对于一个页面的首次访问， $K=\\infty$。对于最近最少使用（LRU）算法，一次访问是命中，当且仅当自上次访问该页面以来使用过的不同页面数严格小于帧数 $M$，因为 LRU 在内存中维护的是最近使用过的 $M$ 个不同页面。因此，在使用 $M$ 个帧的 LRU 算法下，一次访问会发生缺页，当且仅当 $K \\ge M$（包括 $K=\\infty$）。由此可得，对于一个长度为 $N$ 的轨迹，LRU 的缺页次数等于\n$$\nN \\cdot \\Big( D(\\infty) \\;+\\; \\sum_{k=M}^{\\infty} D(k) \\Big),\n$$\n其中 $D(k)$ 是经验重用距离分布。\n\n步骤 $1$：计算 $\\mathcal{S}$ 的经验分布 $D(k)$。\n\n我们扫描 $\\mathcal{S}$ 一遍，对每次访问，计算其 $K$ 值，即自同一页面上一次被访问以来遇到的不同页面的数量；如果是首次访问，则 $K=\\infty$。对全部 $48$ 次访问进行计数，得到以下统计结果：\n- $5$ 次访问的 $K=\\infty$，\n- $12$ 次访问的 $K=1$，\n- $16$ 次访问的 $K=2$，\n- $4$ 次访问的 $K=3$，\n- $11$ 次访问的 $K=4$，\n对于所有其他有限的 $k$ 值，计数为 $0$。\n这些计数总和为 $48$，符合要求。因此，\n$$\nD(\\infty) \\;=\\; \\frac{5}{48},\\quad D(1)\\;=\\;\\frac{12}{48},\\quad D(2)\\;=\\;\\frac{16}{48},\\quad D(3)\\;=\\;\\frac{4}{48},\\quad D(4)\\;=\\;\\frac{11}{48},\n$$\n对于所有 $k \\ge 5$，$D(k)=0$。\n\n步骤 $2$：推导并计算 $M=3$ 时 LRU 的期望缺页次数。\n\n根据 LRU 的栈属性和重用距离的定义，在使用 $M=3$ 的 LRU 算法下，如果 $K \\in \\{\\infty\\} \\cup \\{3,4,5,\\dots\\}$，则访问会发生缺页。使用上述经验分布 $D(k)$ 和 $N=48$，\n$$\n\\text{Faults}_{\\text{LRU},\\,M=3}\n\\;=\\;\n48 \\cdot \\Big( D(\\infty) + \\sum_{k=3}^{\\infty} D(k) \\Big)\n\\;=\\;\n48 \\cdot \\Big( \\frac{5}{48} + \\frac{4}{48} + \\frac{11}{48} \\Big)\n\\;=\\;\n48 \\cdot \\frac{20}{48}\n\\;=\\;\n20.\n$$\n等价地，直接计数：$5$ 次首次接触的访问加上 $4$ 次 $K=3$ 的访问再加上 $11$ 次 $K=4$ 的访问，共产生 $20$ 次 LRU 缺页。\n\n步骤 $3$：通过直接的算法推理，比较 $M=3$ 时 FIFO 和第二次机会（Clock）的性能。\n\n我们现在根据其定义来模拟 FIFO 和 Clock 算法。对于先进先出（FIFO），维护一个按到达顺序排列的已加载帧队列；在内存已满时发生未命中，则驱逐最旧的帧（队头）。对于第二次机会（Clock），维护一个带有引用位的帧的循环列表；命中时，将该页的引用位置为 $1$；未命中时，移动指针，将遇到的引用位为 $1$ 的清零并继续，直到找到一个引用位为 $0$ 的帧；驱逐该帧，将新页面装入该位置并将引用位置为 $1$，然后将指针前进一个位置。\n\n对 $48$ 次访问的轨迹 $\\mathcal{S}$ 进行逐步模拟，其中 $M=3$（帧初始为空，对于 Clock 算法，所有引用位初始为 $0$，指针位于第一个帧），得出以下总缺页次数：\n- $\\text{Faults}_{\\text{FIFO},\\,M=3} = 18$，\n- $\\text{Faults}_{\\text{Clock},\\,M=3} = 18$，\n这两个值可能低于、等于或高于 LRU 的计数值，具体取决于访问轨迹；在这里，LRU 的经验计数值为 $20$。这说明，尽管 LRU 具有栈属性，并且在典型的具有丰富局部性的轨迹上，对于给定的 $M$，它倾向于在栈算法中最小化缺页次数，但 FIFO 和 Clock 并非栈算法；特别是，在给定的有限轨迹上，FIFO 有时可能比 LRU 产生更少或更多的缺页。\n\n步骤 $4$：讨论在阶段 $\\mathcal{B}$ 上 FIFO 算法的 Belady 异常风险。\n\nBelady 异常指的是这样一种可能性：在 FIFO 算法下，增加页帧数量反而可能增加缺页次数。考虑单个阶段 $\\mathcal{B} = [\\,1,\\,2,\\,3,\\,4,\\,1,\\,2,\\,5,\\,1,\\,2,\\,3,\\,4,\\,5\\,]$，在冷启动（$\\mathcal{B}$ 开始时帧为空）的情况下。一次直接的 FIFO 模拟显示：\n- 当 $M=3$ 时，在 $\\mathcal{B}$ 上 FIFO 的总缺页次数为 $9$ 次。\n- 当 $M=4$ 时，在 $\\mathcal{B}$ 上 FIFO 的总缺页次数为 $10$ 次。\n因此，将帧数从 $3$ 增加到 $4$，FIFO 的缺页次数从 $9$ 增加到 $10$，这是 Belady 异常的一个实例。其根本原因是 FIFO 缺乏栈属性：在同一访问字符串上，给定时刻 $M=4$ 时的内存页面集合不一定是 $M=3$ 时的超集，因此，额外的容量可能会以一种导致额外未命中的方式扰乱驱逐顺序。\n\n结论和要求的数值结果。\n\n根据测得的 $D(k)$ 和 LRU 的栈属性，在 $\\mathcal{S}$ 上当 $M=3$ 时，LRU 的期望总缺页次数等于 $20$。", "answer": "$$\\boxed{20}$$", "id": "3668817"}, {"introduction": "在掌握了 $EAT$ 计算和算法行为分析的基础之上，最后一个练习将这些原理应用于一个与云计算相关的现代系统优化问题。这个挑战 [@problem_id:3668872] 是为一个新的应用实例确定最佳的“预热”策略，即在预加载页面所花费的前期成本与运行时较低的缺页率带来的长期收益之间取得平衡。你将构建一个总成本模型，并利用微积分来寻找最优的预取页面数量，从而体验如何通过量化分析来指导关键的工程决策，以实现最佳的整体性能。", "problem": "一个云服务在一个采用请求分页虚拟内存系统的服务器池中部署应用实例。在实例开始为流量提供服务之前，平台可以选择性地预接触 $K$ 个虚拟页面来预热工作集。目标是选择一个 $K$ 值，以最小化由一个全新实例处理单个请求的预期完成时间。\n\n假设以下情况，这些情况基于标准请求分页行为：\n\n- 有效访问时间 (EAT) 取决于每次内存引用的缺页概率。每次内存引用，如果在内存中命中，则需要基准内存访问时间 $m$；如果发生缺页，则会产生用于处理缺页的额外开销 $F$。\n- 预热 $K$ 个页面所需的时间与 $K$ 呈线性关系：接触每个页面需要 $t_{\\mathrm{touch}}$ 秒，并且此过程与处理请求不重叠。\n- 预热根据收益递减模型降低了每次引用的缺页概率：$p(K) = p_{0}\\,\\exp(-\\alpha K)$。\n- 每个全新实例将执行恰好 $N$ 次内存引用来处理一个请求，之后该实例将被销毁。基准内存访问时间 $m$ 不依赖于 $K$。\n\n使用以下参数值，单位为秒、引用次数和页面数：\n- $m = 1.0 \\times 10^{-7}$，\n- $F = 8.0 \\times 10^{-3}$，\n- $t_{\\mathrm{touch}} = 1.0 \\times 10^{-3}$，\n- $p_{0} = 2.0 \\times 10^{-5}$，\n- $\\alpha = 5.0 \\times 10^{-2}$，\n- $N = 5.0 \\times 10^{6}$。\n\n从请求分页下的时间期望值定义和上述线性预热模型出发，推导出一个关于 $K$ 的函数表达式，表示完成请求的预期总时间，并确定使其最小化的整数 $K^{*}$。将 $K^{*}$ 报告为单个整数页面数。除了选择使预期总时间最小化的整数之外，不需要其他舍入规则。最终答案必须是一个数字。", "solution": "目标是最小化完成请求的总预期时间 $T(K)$，该时间由预热时间 $T_{\\text{warm}}(K)$ 和请求处理时间 $T_{\\text{req}}(K)$ 组成。\n$$T(K) = T_{\\text{warm}}(K) + T_{\\text{req}}(K)$$\n根据模型，预热时间为 $T_{\\text{warm}}(K) = K \\cdot t_{\\mathrm{touch}}$。请求处理时间为 $T_{\\text{req}}(K) = N \\cdot \\text{EAT}(K)$，其中有效访问时间 $\\text{EAT}(K) = m + p(K) \\cdot F$。将缺页概率模型 $p(K) = p_{0} \\exp(-\\alpha K)$ 代入，得到总时间函数：\n$$T(K) = K \\cdot t_{\\mathrm{touch}} + N \\left(m + p_{0} F \\exp(-\\alpha K)\\right)$$\n$$T(K) = K t_{\\mathrm{touch}} + N m + N p_{0} F \\exp(-\\alpha K)$$\n为了找到最小值，我们将 $T(K)$ 对 $K$ 求导并令其为零：\n$$\\frac{dT(K)}{dK} = t_{\\mathrm{touch}} - \\alpha N p_{0} F \\exp(-\\alpha K) = 0$$\n解出最优的连续值 $K_{\\mathrm{opt}}$：\n$$K_{\\mathrm{opt}} = \\frac{1}{\\alpha} \\ln\\left(\\frac{\\alpha N p_{0} F}{t_{\\mathrm{touch}}}\\right)$$\n二阶导数 $\\frac{d^2T(K)}{dK^2} = \\alpha^2 N p_{0} F \\exp(-\\alpha K)$ 始终为正，确认 $K_{\\mathrm{opt}}$ 对应一个全局最小值。\n代入给定参数：\n$\\alpha = 5.0 \\times 10^{-2}$, $N = 5.0 \\times 10^{6}$, $p_{0} = 2.0 \\times 10^{-5}$, $F = 8.0 \\times 10^{-3}$, $t_{\\mathrm{touch}} = 1.0 \\times 10^{-3}$。\n计算对数函数的参数：\n$$\\frac{\\alpha N p_{0} F}{t_{\\mathrm{touch}}} = \\frac{(5.0 \\times 10^{-2}) (5.0 \\times 10^{6}) (2.0 \\times 10^{-5}) (8.0 \\times 10^{-3})}{1.0 \\times 10^{-3}} = \\frac{0.04}{0.001} = 40$$\n计算 $K_{\\mathrm{opt}}$：\n$$K_{\\mathrm{opt}} = \\frac{1}{0.05} \\ln(40) = 20 \\ln(40) \\approx 20 \\times 3.688879 = 73.77758$$\n由于 $K$ 必须是整数，最优解 $K^{*}$ 必须是 $\\lfloor K_{\\mathrm{opt}} \\rfloor = 73$ 或 $\\lceil K_{\\mathrm{opt}} \\rceil = 74$。因为 $T(K)$ 是一个凸函数，我们只需比较 $T(73)$ 和 $T(74)$ 的值。\n$T(73) \\approx \\text{const} + (73)(10^{-3}) + (0.8) e^{-3.65} \\approx \\text{const} + 0.073 + 0.020792 = \\text{const} + 0.093792$\n$T(74) \\approx \\text{const} + (74)(10^{-3}) + (0.8) e^{-3.70} \\approx \\text{const} + 0.074 + 0.019776 = \\text{const} + 0.093776$\n由于 $T(74)  T(73)$，使预期总时间最小化的整数页面数是 $K^{*} = 74$。", "answer": "$$\\boxed{74}$$", "id": "3668872"}]}