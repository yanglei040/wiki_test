{"hands_on_practices": [{"introduction": "虽然最不常用（LFU）和最近最少使用（LRU）算法都可以用计数器实现，但它们的决策逻辑却有天壤之别。本练习将通过一个经典案例[@problem_id:3655493]，揭示LFU算法在程序局部性发生变化时如何因其“历史包袱”而导致性能急剧下降，从而凸显LRU算法关注“就近原则”的优越性。", "problem": "考虑一个请求分页系统，其内存帧的固定工作集大小为 $M = 3$。当引用的页面当前未驻留时，使用页面置换算法。对任何未驻留页面的引用都会发生缺页中断。两种经典的置换策略通常通过计数器来实现：最近最少使用（LRU）和最不经常使用（LFU）。最近最少使用（LRU）选择淘汰最后访问时间最久远的页面；一种实现方式是维护一个栈（最近使用的在栈顶，最久未使用的在栈底），每次引用时将页面移至栈顶，并在需要时从栈底淘汰页面。最不经常使用（LFU）选择淘汰引用计数最小的页面；一种实现方式是为每个页面维护一个频率计数器，每次引用时增加计数，并使用最近最少使用（LRU）规则来打破平局，以做出确定性选择。假设频率计数器在页面被淘汰后仍然保持（当页面离开内存时它们不会重置）。\n\n有些学生将频率计数器与新近度计数器相混淆，并假设它们的行为相似。您的任务是根据上述核心定义进行推理，并展示一个工作负载，在该负载下，LFU 计数器做出的决策严格劣于 LRU 的新近度规则。考虑以下包含两个阶段的引用串，它模拟了程序局部性的阶段性变化：\n\n- 阶段 $1$：序列 $\\left(A,B,C\\right)$ 重复 $5$ 次，总共 $15$ 次引用。\n- 阶段 $2$：序列 $\\left(D,E,F\\right)$ 重复 $4$ 次，总共 $12$ 次引用。\n\n假设内存初始为空，并且所有页面 $A,B,C,D,E,F$ 都是不同的。仅使用上面给出的 LRU 和 LFU 的操作定义，确定哪个陈述最能概括这两种策略在此工作负载上的缺页中断次数及其差异的根本原因。\n\nA. LRU 产生 $6$ 次缺页中断，而 LFU 产生 $15$ 次缺页中断，因为 LFU 的持久性频率计数器在整个阶段 $2$ 中保持高频但已变冷的页面 $A,B,C$ 驻留，导致在 $D,E,F$ 之间发生抖动，直到它们的计数赶上为止；而 LRU 的栈属性通过淘汰最近最少使用的页面，立即适应了阶段变化。\n\nB. 在此工作负载上，LRU 和 LFU 都产生 $6$ 次缺页中断，因为当工作集能容纳于 $3$ 个帧中时，新近度与频率重合，所以两种类型的计数器行为相同。\n\nC. 在此工作负载上，LFU 产生的缺页中断（$9$ 次）少于 LRU（$12$ 次），因为频率计数器优先考虑全局热门页面，而新近度规则在阶段边界处过于激进地淘汰了有用的页面。\n\nD. 当使用最近最少使用规则打破平局时，对于所有具有不同页面的工作负载，LRU 和 LFU 的缺页中断次数都相同，因此任何观察到的差异都必须归因于实现开销而不是策略本身。", "solution": "**解答推导**\n\n为了确定两种策略的缺页中断次数，我们将逐步追踪在给定引用串下，每种算法的内存状态和页面淘汰决策。系统内存大小为 $M=3$ 帧，初始为空。\n\n**LRU 算法追踪**\n\n*   **阶段 1：(A, B, C) x 5**\n    *   引用 1 (`A`), 2 (`B`), 3 (`C`): 导致 3 次缺页中断，因为内存初始为空。内存状态为 `{A, B, C}`。LRU 栈为 `[C, B, A]` (C在栈顶)。\n    *   此后阶段 1 的所有引用均为命中，因为工作集 `{A, B, C}` 已完全在内存中。每次引用仅更新 LRU 栈的顺序。\n    *   阶段 1 结束时，总缺页次数为 3。\n\n*   **阶段 2：(D, E, F) x 4**\n    *   引用 16 (`D`): 缺页。LRU 页面（栈底）为 `A`，将其淘汰。`D` 进入内存。内存状态 `{D, C, B}`。缺页次数: $3+1=4$。\n    *   引用 17 (`E`): 缺页。LRU 页面为 `B`，将其淘汰。`E` 进入内存。内存状态 `{E, D, C}`。缺页次数: $4+1=5$。\n    *   引用 18 (`F`): 缺页。LRU 页面为 `C`，将其淘汰。`F` 进入内存。内存状态 `{F, E, D}`。缺页次数: $5+1=6$。\n    *   此时，内存包含新的工作集 `{D, E, F}`。此后阶段 2 的所有引用均为命中。\n    *   阶段 2 总共产生 3 次缺页中断。\n\n*   **总缺页次数 (LRU)：** $3$ (阶段 1) + $3$ (阶段 2) = $6$ 次。\n\n**LFU 算法追踪**\n\n*   **阶段 1：(A, B, C) x 5**\n    *   与 LRU 相同，初始三次引用 A, B, C 导致 3 次缺页中断。\n    *   此后阶段 1 的所有引用均为命中。\n    *   阶段 1 结束时，总缺页次数为 3。内存中为 `{A, B, C}`，每个页面的频率计数器均为 5。计数状态: `{A:5, B:5, C:5}`。用于平局打破的 LRU 顺序为 `[C, B, A]`。\n\n*   **阶段 2：(D, E, F) x 4**\n    *   引用 16 (`D`): 缺页。需要淘汰。内存中的页面 A, B, C 计数均为 5，出现平局。使用 LRU 规则打破平局，淘汰 `A`。`D` 进入内存。计数状态: `{A:5, B:5, C:5, D:1}`。缺页次数: $3+1=4$。\n    *   引用 17 (`E`): 缺页。需要淘汰。内存中页面为 `{B, C, D}`，计数为 `{5, 5, 1}`。LFU 淘汰计数最小的 `D`。`E` 进入。计数状态: `{..., D:1, E:1}`。缺页次数: $4+1=5$。\n    *   引用 18 (`F`): 缺页。需要淘汰。内存中页面为 `{B, C, E}`，计数为 `{5, 5, 1}`。LFU 淘汰计数最小的 `E`。`F` 进入。计数状态: `{..., E:1, F:1}`。缺页次数: $5+1=6$。\n    *   引用 19 (`D`): 缺页。需要淘汰。内存中页面为 `{B, C, F}`，计数为 `{5, 5, 1}`。LFU 淘汰计数最小的 `F`。`D` 进入。计数状态: `{..., D:2, F:1}`。缺页次数: $6+1=7$。\n    *   这个模式持续下去。新工作集 `{D, E, F}` 的页面（其计数最高只能达到 4）不断地相互淘汰，因为它们的计数值始终低于旧工作集页面 `B` 和 `C` 的计数值（恒为 5）。这导致了“抖动”（thrashing）。\n    *   因此，在阶段 2 中，每一次对 `D, E, F` 的引用（共 12 次）都会导致一次缺页中断。\n\n*   **总缺页次数 (LFU)：** $3$ (阶段 1) + $12$ (阶段 2) = $15$ 次。\n\n**结论**\n\nLRU 算法产生了 6 次缺页中断，而 LFU 算法产生了 15 次。原因是 LFU 的频率计数器使其无法适应程序局部性的变化，它固守着历史高频页面（A, B, C），导致新工作集（D, E, F）在仅有的一个内存帧中抖动。相比之下，LRU 能够立即淘汰最近未使用的页面，从而快速适应新的工作集。\n\n这个分析与选项 A 的描述完全一致。", "answer": "$$\n\\boxed{A}\n$$", "id": "3655493"}, {"introduction": "一个完整的LRU堆栈实现起来可能代价不菲，无论是在硬件层面还是更新开销上。本练习[@problem_id:3655422]将探讨一种常见的现实世界解决方案：使用一个位数有限的计数器将页面分组到不同的“新近度桶”中，从而近似实现LRU。你将分析这种近似方法带来的固有权衡，计算其导致的排序冲突概率和错误淘汰率。", "problem": "一位系统设计者希望用一个最小化的每页计数器来替换一个完整的最近最少使用 (LRU) 堆栈，以便为驱逐决策近似 LRU 算法。最近最少使用 (LRU) 算法根据新近度维护页面的全序关系：每个驻留页面都有一个唯一的堆栈位置，位置 $1$ 为最近引用的页面，位置 $N$ 为最久未引用的页面，其中 $N$ 是驻留帧的数量。为节省内存，设计者提出了一种基于计数器的近似方法，每页使用 $b=4$ 位，只存储粗粒度的排名，而非确切的堆栈位置。\n\n最小化计数器 LRU 的构造如下。设 $N$ 为驻留帧的数量，并定义桶宽\n$$\nq \\equiv \\frac{N}{2^{b}}.\n$$\n将 LRU 堆栈位置 $\\{1,2,\\dots,N\\}$ 划分为 $2^{b}$ 个连续的桶，每个桶的宽度为 $q$。对于真实堆栈位置为 $s \\in \\{1,\\dots,N\\}$ 的页面，定义其存储的计数器值为\n$$\nc(s) \\equiv \\min\\!\\left(\\left\\lfloor \\frac{s-1}{q}\\right\\rfloor,\\,2^{b}-1\\right),\n$$\n它将 $s$ 映射到一个桶索引 $c \\in \\{0,1,\\dots,2^{b}-1\\}$。驱逐时，算法从计数器等于 $2^{b}-1$（最后一个桶）的页面中均匀随机地选择一个，而不查阅确切的堆栈顺序或时间戳。假设 $N$ 是 $2^{b}$ 的正整数倍，因此 $q$ 是一个整数，并且每个桶都正好包含 $q$ 个页面。\n\n仅使用 LRU 的基本属性（驻留页面的唯一堆栈顺序）和在驻留集内稳态随机引用下均匀随机堆栈排序的对称性，执行以下操作：\n\n1. 构建计数器映射 $c(s)$，并解释为什么桶的大小相等，以及为什么排名冲突（不同页面共享相同的计数器）必然会发生。\n2. 在堆栈位置均匀随机分布的情况下，从第一性原理推导两个随机选择的不同驻留页面具有相同计数器值的概率。\n3. 推导上述计数器 LRU 的预期错误驱逐率，其定义为算法在驱逐时驱逐的页面不是真正的最近最少使用页面的概率。\n\n假设 $N=64$ 帧且 $b=4$ 位。以小数形式提供冲突概率和错误驱逐率的最终结果。将答案四舍五入到四位有效数字。无需单位。", "solution": "**问题解答**\n\n首先，我们根据给定值 $N=64$ 和 $b=4$ 计算系统参数。\n可能的计数器值（也就是桶）的数量为 $2^{b} = 2^{4} = 16$。\n桶宽为 $q \\equiv \\frac{N}{2^{b}} = \\frac{64}{16} = 4$。\n\n**1. 计数器映射与冲突**\n\n对于一个真实堆栈位置为 $s \\in \\{1, 2, \\dots, N\\}$ 的页面，其计数器值由 $c(s) \\equiv \\min\\!\\left(\\left\\lfloor \\frac{s-1}{q}\\right\\rfloor,\\,2^{b}-1\\right)$ 给出。\n对于给定的参数，$N/2^b = q$ 是整数，映射简化为 $c(s) = \\left\\lfloor \\frac{s-1}{q}\\right\\rfloor$。该函数将 $N$ 个堆栈位置映射到 $2^b$ 个计数器值 $\\{0, 1, \\dots, 2^{b}-1\\}$。\n\n为了确定每个桶的大小，我们找到映射到给定计数器值 $k \\in \\{0, 1, \\dots, 2^{b}-1\\}$ 的堆栈位置 $s$ 的集合。\n$$\nc(s) = k \\implies k = \\left\\lfloor \\frac{s-1}{q}\\right\\rfloor\n$$\n根据下取整函数的定义，这等价于：\n$$\nk \\le \\frac{s-1}{q}  k+1\n$$\n乘以 $q$ 得：\n$$\nkq \\le s-1  (k+1)q\n$$\n所有部分加 1，得到桶 $k$ 的堆栈位置范围：\n$$\nkq+1 \\le s \\le (k+1)q\n$$\n此范围内的整数位置数量为 $((k+1)q) - (kq+1) + 1 = q$。\n因此，每个计数器值 $k$ 对应一个恰好包含 $q$ 个堆栈位置的连续块。这证实了所有桶的大小都相等。\n\n排名冲突是指两个或多个不同的页面被分配了相同的计数器值。在此系统中，有 $N=64$ 个驻留页面，但只有 $2^b=16$ 个不同的计数器值。根据鸽巢原理，由于页面数 $N$ 大于可用计数值的数量 $2^b$，冲突是必然的。具体来说，恰好有 $q=4$ 个不同的页面会共享任何给定的计数器值。\n\n**2. 冲突概率**\n\n我们要求出两个随机选择的不同驻留页面具有相同计数器值的概率。\n选择两个不同的页面 $P_1$ 和 $P_2$。设它们的堆栈位置分别为 $s_1$ 和 $s_2$ ($s_1 \\neq s_2$)。我们想要求出概率 $P(c(s_1) = c(s_2))$。\n\n考虑页面 $P_1$。它的堆栈位置 $s_1$ 会落入某个桶中。该桶总共包含 $q$ 个堆栈位置。现在，考虑页面 $P_2$。有 $N-1$ 个剩余的堆栈位置可供它使用。要使 $P_2$ 的计数器与 $P_1$ 相同，其堆栈位置 $s_2$ 必须是与 $s_1$ 位于同一桶中的其他 $q-1$ 个位置之一。\n$s_2$ 落在这些 $q-1$ 个有利位置之一的概率（总共有 $N-1$ 个可用位置）是：\n$$\nP(\\text{collision}) = \\frac{q-1}{N-1}\n$$\n使用给定值 $N=64$ 和 $q=4$：\n$$\nP(\\text{collision}) = \\frac{4-1}{64-1} = \\frac{3}{63} = \\frac{1}{21}\n$$\n作为小数，这是 $1 \\div 21 \\approx 0.0476190...$。四舍五入到四位有效数字，概率为 $0.04762$。\n\n**3. 错误驱逐率**\n\n如果算法驱逐的页面不是真正的最近最少使用 (LRU) 页面，则发生错误驱逐。真正的 LRU 页面是位于堆栈位置 $s=N$ 的页面。\n\n驱逐算法识别出所有计数器值最大（即 $c_{max} = 2^b - 1$）的页面，并从中均匀随机选择一个进行驱逐。\n根据第 1 部分，对应于最后一个桶 $k = 2^b - 1$ 的堆栈位置是 $s \\in [N-q+1, N]$。\n当 $N=64$ 且 $q=4$ 时，候选驱逐页面是位于堆栈位置 $\\{61, 62, 63, 64\\}$ 的页面。该集合包含 $q=4$ 个页面。\n真正的 LRU 页面位于位置 $s=64$，它是该候选集的一个成员。\n算法以均匀的概率从这 $q$ 个页面的集合中选择一个。如果被选中的页面不是位置为 $s=N$ 的那个，就发生了错误驱逐。\n\n候选驱逐集包含一个真正的 LRU 页面和 $q-1$ 个其他页面。从此集合中选择真正的 LRU 页面的概率是 $\\frac{1}{q}$。\n因此，发生错误驱逐的概率是选择其他 $q-1$ 个页面中任意一个的概率：\n$$\nP(\\text{mis-eviction}) = \\frac{q-1}{q}\n$$\n使用值 $q=4$：\n$$\nP(\\text{mis-eviction}) = \\frac{4-1}{4} = \\frac{3}{4} = 0.75\n$$\n四舍五入到四位有效数字得到 $0.7500$。\n\n最终结果是：\n- 冲突概率：$0.04762$\n- 错误驱逐率：$0.7500$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.04762  0.7500\n\\end{pmatrix}\n}\n$$", "id": "3655422"}, {"introduction": "使用位数有限的计数器作为时间戳，看似是实现LRU的直接方法，但当计数器溢出并回绕时会发生什么呢？这项高级练习[@problem_id:3655499]将挑战你构建一个“对抗性”的访问模式，利用计数器回绕的缺陷，诱导算法做出最差的淘汰决策，从而揭示其与真实LRU策略相比可能导致的灾难性性能退化。", "problem": "考虑一个具有 $C$ 个页帧缓存容量的请求分页内存系统。真正的最近最少使用 (LRU) 策略定义为：在发生未命中时，驱逐最长时间未被使用的页面。该策略具有 LRU 栈属性：对于相同的引用串，在比较两个容量 $C_{1}$ 和 $C_{2}$（其中 $C_{1}  C_{2}$）时，在任何时刻，容量为 $C_{1}$ 的缓存所持有的页面集合总是容量为 $C_{2}$ 的缓存所持有页面集合的子集。现在考虑一种试图通过每页计数器来实现 LRU 的方法（称之为计数器-LRU）：它维护一个全局 $b$ 位计数器 $t \\in \\{0,1,\\ldots,2^{b}-1\\}$，该计数器在每次引用时加 1，并按模 $M = 2^{b}$ 回绕。每次访问页面 $p$ 时，该页面的存储时间戳 $p.\\mathrm{ts}$ 被设置为计数器 $t$ 的当前值。发生未命中时，选择具有数值最小的 $p.\\mathrm{ts}$ 的常驻页面作为被替换的页面（若数值相同，则由最小的页面标识符打破平局）。该实现将时间戳值作为普通整数进行比较，并且不知道回绕，因此在计数器回绕时不能保持真正的近期性顺序。\n\n你需要构建一个带有循环工作集的对抗性访问模式，该模式导致计数器-LRU 在每个阶段边界处错误地排序近期性，从而比真正的 LRU 产生更多的缺页。使用以下固定参数和约定：\n\n- 设缓存容量为 $C = W$，其中 $W \\ge 2$ 是一个整数。\n- 设有两个不相交的工作集 $A = \\{a_{1},\\ldots,a_{W}\\}$ 和 $B = \\{b_{1},\\ldots,b_{W}\\}$，因此在任何时候，活动工作集的大小都为 $W$。\n- 在工作集 $X \\in \\{A,B\\}$ 上的一个阶段包括：对 $X$ 中的页面以固定的循环顺序进行 $K$ 个完整轮次的访问，期间没有立即的自我重复（例如，对于 $K$ 轮，访问顺序为 $x_{1},x_{2},\\ldots,x_{W},x_{1},x_{2},\\ldots$），然后是一个填充序列，该序列重复引用 $X$ 的最后一个元素，直到在阶段切换前，全局计数器满足 $t \\equiv M - 1 \\pmod{M}$。假设 $K W \\le M - 1$，以确保在一个阶段内 $t$ 不会回绕。\n- 访问序列无限地在阶段 $A$ 和 $B$ 之间交替。初始缓存为空，初始计数器为 $t = 0$。\n\n仅从上述核心定义出发，完成以下任务：\n\n- 构建描述中隐含的显式对抗性访问模式，确保在每个阶段切换时，进入的工作集中的页面的数值时间戳严格小于离开的集合中的页面的时间戳。\n- 解释为什么在计数器-LRU下，这会导致进入的集合在整个阶段中驱逐自身而不是离开的集合，并计算计数器-LRU下每阶段的稳态缺页数。\n- 解释为什么在真正的LRU下，一旦进入的集合在一个阶段开始时被加载，该阶段内的所有后续引用都是命中（忽略整个访问序列的初始冷启动，并计算每阶段的稳态缺页数）。\n- 将膨胀因子 $\\rho$ 定义为在该对抗性访问序列下，计数器-LRU 每阶段的稳态缺页数与真正的 LRU 每阶段的稳态缺页数之比，并根据 $K$、$W$ 和 $b$（满足 $K W \\le M - 1$ 和 $M = 2^{b}$）推导 $\\rho$ 的闭式表达式。\n\n你的最终答案必须是 $\\rho$ 的单一闭式符号表达式。无需四舍五入，也无需单位。", "solution": "该问题要求构建并分析一种基于计数器的 LRU 近似算法的对抗性访问模式，并将其性能与真正的 LRU 进行比较。目标是推导出性能膨胀因子 $\\rho$。\n\n分析将分步进行：首先构建对抗性模式，然后分别为真正的 LRU 和计数器-LRU 计算稳态缺页数，最后推导它们的比率。\n\n**1. 对抗性访问模式与时间戳**\n\n访问序列在工作集 A 和 B 之间交替。让我们考虑从 A 阶段到 B 阶段的转换。\n*   **阶段 A (结束时):** 按照约定，阶段 A 在全局计数器 $t$ 达到 $M-1$ 时结束。在阶段 A 期间，缓存被工作集 A 的页面 $\\{a_1, \\ldots, a_W\\}$ 填满。这些页面的时间戳是它们最后一次被访问的时间。根据访问模式，除了在填充序列中被重复访问的 $a_W$ 外，其他页面 $a_i$ 的时间戳都在 $[0, KW-1]$ 范围内。而 $a_W$ 的时间戳被设置为 $M-1$。因此，A 集合中页面的时间戳都很大。\n*   **阶段 B (开始时):** 阶段 B 的第一次访问发生在下个时间点。计数器从 $M-1$ 回绕到 $0$。因此，对 $b_1$ 的第一次访问将其时间戳 $b_1.\\mathrm{ts}$ 设置为 $0$。对 $b_2$ 的访问将其时间戳设置为 $1$，以此类推。进入的 B 集合页面的时间戳将是从 $0$ 开始的小数值。\n*   **对抗性条件:** 在阶段切换时，常驻的 A 集合页面的时间戳（特别是 $a_W.\\mathrm{ts} = M-1$）数值上远大于新进入的 B 集合页面的时间戳（例如 $b_1.\\mathrm{ts}=0$）。\n\n**2. 真正的 LRU 分析**\n\n真正的 LRU 基于访问的先后顺序，不受时间戳数值的影响。我们分析一个稳态阶段（例如，B 阶段）的缺页数。\n*   **初始状态:** 阶段 B 开始时，容量为 $C=W$ 的缓存包含工作集 A 的页面 $\\{a_1, \\ldots, a_W\\}$。\n*   **加载新工作集:** 对 B 集合的前 $W$ 次访问 ($b_1, b_2, \\ldots, b_W$) 都是缺页，因为这些页面不在缓存中。每次缺页都会淘汰 A 集合中最近最少使用的页面。\n*   **稳态:** 在这最初的 $W$ 次缺页之后，缓存恰好包含完整的工作集 B。阶段 B 中所有后续的 $(K-1)W$ 次访问以及填充访问都是命中。\n*   **缺页计数:** 因此，真正的 LRU 每阶段的稳态缺页数等于加载新工作集所需的强制性缺页次数。\n$$\nN_{\\mathrm{LRU}} = W\n$$\n\n**3. 计数器-LRU 分析**\n\n计数器-LRU 驱逐具有数值最小时间戳的页面。\n*   **初始状态:** 阶段 B 开始时，缓存包含页面 $\\{a_1, \\ldots, a_W\\}$。\n*   **关键缺陷:** 访问 $b_1$ 时发生缺页。算法寻找淘汰页面。此时缓存中 A 集合页面的时间戳都很大，而 $b_1$ 的时间戳是 $0$。当访问 $b_2$ 再次缺页时，算法比较缓存中所有页面的时间戳。它会发现 $b_1$ 的时间戳 $0$ 是最小的，因此会淘汰 $b_1$ 而不是任何一个 A 集合的页面。\n*   **抖动:** 这个过程持续下去。由于条件 $KW \\le M-1$，在阶段 B 的主要部分中，任何 $B$ 集合页面的时间戳（范围为 $[0, KW-1]$）都将小于至少一个 A 集合页面（$a_W$）的时间戳（$M-1$）。因此，至少有一个 A 集合的页面会“卡”在缓存中，使得可用于 B 集合的有效缓存大小小于 $W$。对于一个大小为 $W$ 的循环工作集，在大小小于 $W$ 的缓存中，每次访问都会导致缺页。\n*   **缺页计数:** 阶段 B 的主要部分包含 $K$ 轮对 $W$ 个页面的访问，总共 $KW$ 次访问。每一次访问都会因为上述抖动效应而导致缺页。填充访问是对 $b_W$ 的重复引用，会是命中。因此，计数器-LRU 每阶段的总缺页数等于该阶段主要部分的访问次数。\n$$\nN_{\\mathrm{C-LRU}} = K W\n$$\n\n**4. 膨胀因子 $\\rho$ 推导**\n\n膨胀因子 $\\rho$ 是两种策略下每阶段稳态缺页数的比率。\n$$\n\\rho = \\frac{N_{\\mathrm{C-LRU}}}{N_{\\mathrm{LRU}}} = \\frac{KW}{W}\n$$\n消去 $W$：\n$$\n\\rho = K\n$$\n膨胀因子 $\\rho$ 就是 $K$。这表明，在这种对抗性模式下，计数器回绕的缺陷导致性能下降了一个与每个阶段的循环次数成正比的因子。问题的约束条件 $C=W$, $M=2^b$, 和 $KW \\le M-1$ 确保了这种对抗模式的有效性，但这些参数不出现在最终的比率表达式中。", "answer": "$$\\boxed{K}$$", "id": "3655499"}]}