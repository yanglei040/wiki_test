{"hands_on_practices": [{"introduction": "一个进程的内存通常分为不同区域，例如调用栈和堆，它们各自具有独特的访问模式和局部性。当物理内存有限时，如何在这些区域间分配宝贵的页帧，以最小化总体的缺页率（PFF），就成了一个经典的优化问题。本练习将引导你通过数学分析，找到最佳的页帧分配策略，并揭示一个重要原则：最优决策应关注分配额外资源所带来的边际收益，而非仅仅关注当前哪个区域的PFF更高。[@problem_id:3667671]", "problem": "一个进程的内存访问分为调用栈区域和堆区域。设访问栈的引用比例为 $r_{s}$，访问堆的引用比例为 $r_{h}=1-r_{s}$。缺页频率（Page-Fault Frequency, PFF）定义为每次内存引用的缺页次数，它是在一个足够长的观察窗口内测量的，以使遍历均值与期望值一致。假设在最近最少使用（Least Recently Used, LRU）策略下，每个区域的每次引用未命中概率可以根据经验建模为一个严格递减的凸函数，该函数依赖于分配给该区域的页框数量。具体来说，对于栈和堆，未命中概率为\n$$m_{s}(f_{s})=\\exp(-a_{s} f_{s}), \\quad m_{h}(f_{h})=\\exp(-a_{h} f_{h}),$$\n其中 $f_{s}$ 和 $f_{h}$ 分别是分配给栈和堆的页框数，而 $a_{s}>0$ 和 $a_{h}>0$ 是捕捉局部性强度的区域特定参数。该进程的总页框预算是固定的 $F$，因此 $f_{s}+f_{h}=F$，其中 $f_{s}\\ge 0$ 且 $f_{h}\\ge 0$。\n\n给定 $r_{s}=0.4$，因此 $r_{h}=0.6$，以及 $a_{s}=0.35$，$a_{h}=0.15$，总页框预算 $F=30$。\n\n任务：\n- 仅使用缺页频率（PFF）的定义（即每次引用的期望缺页数）和给定的未命中概率模型，推导 $PFF_{stack}(f_{s})$、$PFF_{heap}(f_{h})$ 以及总 PFF 作为仅 $f_{s}$ 的函数的符号表达式，给定约束条件 $f_{h}=F-f_{s}$。\n- 从第一性原理出发，解释“优先考虑 PFF 较高区域”的策略如何转化为一个每页框分配决策规则，该规则根据将一个额外页框分配给任一区域时总 PFF 的边际减少量来决定。\n- 使用给定的数值参数，计算在约束条件 $f_{s}+f_{h}=F$ 下最小化总 PFF 的栈分配值 $f_{s}^{\\star}$。将您的答案四舍五入到三位有效数字，并以页框为单位表示。", "solution": "所述问题具有科学依据，提法恰当，客观且内部一致。它在操作系统资源管理的背景下，提出了一个标准的优化问题，该问题基于一个简化但有效的程序局部性经验模型。所有必要的参数和定义都已提供，从而可以得到一个唯一且有意义的解。因此，该问题被认为是有效的。\n\n解决方案通过解决问题陈述中概述的三个任务来进行。\n\n首先，我们推导缺页频率（PFF）各组成部分的符号表达式。PFF 定义为每次内存引用的期望缺页数。总 PFF 是来自栈区域和堆区域贡献的总和。\n\n栈对总 PFF 的贡献，记为 $PFF_{stack}$，是一个随机选择的内存引用指向栈且导致缺页的概率。这是访问栈的引用比例 $r_{s}$ 与栈的未命中概率 $m_{s}(f_{s})$ 的乘积。\n$$PFF_{stack}(f_{s}) = r_{s} m_{s}(f_{s}) = r_{s} \\exp(-a_{s} f_{s})$$\n类似地，堆对总 PFF 的贡献，记为 $PFF_{heap}$，是访问堆的引用比例 $r_{h}$ 与堆的未命中概率 $m_{h}(f_{h})$ 的乘积。\n$$PFF_{heap}(f_{h}) = r_{h} m_{h}(f_{h}) = r_{h} \\exp(-a_{h} f_{h})$$\n该进程的总 PFF 是这两个贡献之和：\n$$PFF(f_{s}, f_{h}) = PFF_{stack}(f_{s}) + PFF_{heap}(f_{h}) = r_{s} \\exp(-a_{s} f_{s}) + r_{h} \\exp(-a_{h} f_{h})$$\n利用总页框数固定为 $F$ 的约束条件，我们有 $f_{s} + f_{h} = F$，这意味着 $f_{h} = F - f_{s}$。将此代入总 PFF 的表达式，得到总 PFF 仅作为 $f_{s}$ 的函数：\n$$PFF(f_{s}) = r_{s} \\exp(-a_{s} f_{s}) + r_{h} \\exp(-a_{h} (F - f_{s}))$$\n\n其次，我们解释分配决策规则。一个简单的策略是“优先考虑 PFF 较高的区域”，这意味着如果 $PFF_{stack}(f_s) > PFF_{heap}(f_h)$，则将一个页框分配给栈，否则分配给堆。然而，这个策略并非最优。最优的资源分配策略旨在实现总体目标函数（即总 PFF）的最大可能改进（即减少）。\n\n正确的决策规则基于将一个额外页框分配给某个区域所获得的总 PFF 的边际减少量。对于页框分配的连续近似，这可以通过总 PFF 对分配给每个区域的页框数的一阶偏导数来捕捉。向栈增加一个页框带来的总 PFF 的边际减少量是 $-\\frac{\\partial PFF}{\\partial f_{s}}$，而对于堆则是 $-\\frac{\\partial PFF}{\\partial f_{h}}$。\n\n让我们根据它们各自对总 PFF 的贡献来计算这些边际减少量：\n栈的边际减少量是：\n$$R_{s}(f_{s}) = -\\frac{d}{d f_{s}} (PFF_{stack}(f_{s})) = -\\frac{d}{d f_{s}} [r_{s} \\exp(-a_{s} f_{s})] = a_{s} r_{s} \\exp(-a_{s} f_{s})$$\n堆的边际减少量是：\n$$R_{h}(f_{h}) = -\\frac{d}{d f_{h}} (PFF_{heap}(f_{h})) = -\\frac{d}{d f_{h}} [r_{h} \\exp(-a_{h} f_{h})] = a_{h} r_{h} \\exp(-a_{h} f_{h})$$\n决策规则是将下一个页框分配给具有更高边际减少量的区域。当边际减少量相等时，即 $R_{s}(f_{s}^{\\star}) = R_{h}(f_{h}^{\\star})$，达到最优静态分配。此条件确保了没有任何页框可以从一个区域重新分配到另一个区域以实现总 PFF 的更大减少。\n\n第三，我们计算最小化总 PFF 的最优栈分配 $f_{s}^{\\star}$。为了找到 $PFF(f_s)$ 的最小值，我们将其关于 $f_s$ 的一阶导数设为零。\n$$PFF(f_{s}) = r_{s} \\exp(-a_{s} f_{s}) + r_{h} \\exp(-a_{h} (F - f_{s}))$$\n$$\\frac{d PFF(f_{s})}{d f_{s}} = -a_{s} r_{s} \\exp(-a_{s} f_{s}) + a_{h} r_{h} \\exp(-a_{h} (F - f_{s}))$$\n将导数设为零：\n$$-a_{s} r_{s} \\exp(-a_{s} f_{s}^{\\star}) + a_{h} r_{h} \\exp(-a_{h} (F - f_{s}^{\\star})) = 0$$\n$$a_{s} r_{s} \\exp(-a_{s} f_{s}^{\\star}) = a_{h} r_{h} \\exp(-a_{h} (F - f_{s}^{\\star}))$$\n这个方程与边际减少量相等的平衡条件相同。为了求解 $f_{s}^{\\star}$，我们对两边取自然对数：\n$$\\ln(a_{s} r_{s}) - a_{s} f_{s}^{\\star} = \\ln(a_{h} r_{h}) - a_{h} (F - f_{s}^{\\star})$$\n$$\\ln(a_{s} r_{s}) - a_{s} f_{s}^{\\star} = \\ln(a_{h} r_{h}) - a_{h} F + a_{h} f_{s}^{\\star}$$\n重新整理各项以分离出 $f_{s}^{\\star}$：\n$$a_{h} F + \\ln(a_{s} r_{s}) - \\ln(a_{h} r_{h}) = (a_{s} + a_{h}) f_{s}^{\\star}$$\n$$f_{s}^{\\star} = \\frac{a_{h} F + \\ln\\left(\\frac{a_{s} r_{s}}{a_{h} r_{h}}\\right)}{a_{s} + a_{h}}$$\n现在，我们代入给定的数值：$r_{s}=0.4$，$r_{h}=0.6$，$a_{s}=0.35$，$a_{h}=0.15$，$F=30$。\n分母是 $a_{s} + a_{h} = 0.35 + 0.15 = 0.5$。\n分子项是：\n$a_{h} F = 0.15 \\times 30 = 4.5$。\n对数的参数是 $\\frac{a_{s} r_{s}}{a_{h} r_{h}} = \\frac{0.35 \\times 0.4}{0.15 \\times 0.6} = \\frac{0.14}{0.09} = \\frac{14}{9}$。\n所以，$\\ln\\left(\\frac{14}{9}\\right) \\approx 0.44183$。\n将这些值代入 $f_s^{\\star}$ 的表达式中：\n$$f_{s}^{\\star} = \\frac{4.5 + \\ln\\left(\\frac{14}{9}\\right)}{0.5} \\approx \\frac{4.5 + 0.44183}{0.5} = \\frac{4.94183}{0.5} \\approx 9.88366$$\n$PFF(f_s)$ 的二阶导数是 $a_{s}^2 r_{s} \\exp(-a_{s} f_{s}) + a_{h}^2 r_{h} \\exp(-a_{h} (F - f_{s}))$，对于所有 $f_s$ 它都严格为正，这证实了该临界点是一个全局最小值。\n将结果四舍五入到三位有效数字，我们得到 $9.88$。该值在有效范围 $[0, 30]$ 内。", "answer": "$$\\boxed{9.88}$$", "id": "3667671"}, {"introduction": "缺页率不仅受操作系统策略的影响，也与应用程序自身的算法设计密切相关。本练习将探讨分块矩阵乘法，这是一种旨在提升缓存和内存局部性的常用高性能计算技术。你将推导该算法的缺页率（PFF）表达式，并学习如何通过选择最优的“块大小”来最小化缺页，从而深刻理解算法设计如何影响系统性能。[@problem_id:3667672]", "problem": "一个进程执行分块矩阵乘法来计算 $C = A \\times B$，该计算在大小为 $t \\times t$ 个元素的方形块上进行。每个矩阵元素占用 $s$ 字节，虚拟内存页面大小为 $p$ 字节，操作系统使用最近最少使用 (LRU) 替换算法。该进程拥有固定的 $f$ 个页帧分配。考虑一个单一的分块微内核步骤，该步骤通过将一对块 $A_{i,k}$ 和 $B_{k,j}$ 相乘并累加到 $C_{i,j}$ 中来更新一个输出块 $C_{i,j}$，即，对于一个固定的三元组 $(i,j,k)$，它执行 $C_{i,j} \\leftarrow C_{i,j} + A_{i,k} \\times B_{k,j}$。假设如下：\n\n- 在此微内核步骤开始时，包含这三个块的页面均未驻留在该进程的内存中。\n- 在此步骤中，对一个页面内的访问在该页面的首次访问时会产生恰好一次缺页中断，只要该页面保持驻留，此后在该步骤中不会再产生缺页中断。\n- 帧预算 $f$ 足够大，可以在整个步骤中保留这三个块的全部工作集，因此一旦它们的页面被调入，步骤中不会发生页面驱逐。\n- 标量计算遵循关于块索引的标准三重循环：对于 $\\{1,\\dots,t\\}$ 中的每个 $i$、$\\{1,\\dots,t\\}$ 中的每个 $j$ 以及 $\\{1,\\dots,t\\}$ 中的每个 $k$，执行 $C[i,j] \\leftarrow C[i,j] + A[i,k] \\cdot B[k,j]$。该实现会在需要时读取每个 $A$ 和 $B$ 元素，而对于 $C$，在此步骤中对每个元素执行一次读取和一次写入。\n- 没有预取，也没有 I/O 重叠；缺页中断仅由此步骤中对页面的首次访问引起。\n\n使用缺页率 (PFF) 的定义，即在所考虑的时间间隔内，缺页中断次数除以内存引用次数，完成以下任务：\n\n1.  在上述假设下，针对这单一微内核步骤，推导出一个关于 $t$、$p$ 和 $s$ 的 $\\mathrm{PFF}(t)$ 解析表达式。\n2.  在三个块的工作集必须能被容纳的帧预算约束下，确定能使 $\\mathrm{PFF}(t)$ 最小化的块大小 $t^{\\ast}$（作为 $f$、$p$ 和 $s$ 的函数）。\n\n请以闭式形式表达您的答案。不要使用百分号；将 PFF 视为纯比率。如果需要使用整数取整运算符，您可以使用上取整函数 $\\lceil \\cdot \\rceil$ 和下取整函数 $\\lfloor \\cdot \\rfloor$。请将您的最终结果表示为两个表达式：$\\mathrm{PFF}(t)$ 和 $t^{\\ast}$。", "solution": "所述问题具有科学依据、提法恰当、客观且自成体系。这是一个计算机系统性能评估中的标准分析问题，特别关注于常见数值算法的内存层次结构行为。所有假设都已明确说明，并且可以从所提供的信息中推导出唯一且有意义的解。因此，该问题被认为是有效的。\n\n解答按要求分为两部分：推导作为块大小 $t$ 函数的缺页率（$\\mathrm{PFF}$），以及在给定的内存约束下确定最小化该函数的最优块大小 $t^{\\ast}$。\n\n**第一部分：$\\mathrm{PFF}(t)$ 的推导**\n\n缺页率定义为在给定区间内，总缺页中断次数与总内存引用次数之比。\n$$\n\\mathrm{PFF}(t) = \\frac{\\text{总缺页中断次数}}{\\text{总内存引用次数}}\n$$\n我们必须确定单一微内核步骤 $C_{i,j} \\leftarrow C_{i,j} + A_{i,k} \\times B_{k,j}$ 的分子和分母。\n\n**分子：总缺页中断次数**\n\n问题陈述，在该步骤开始时，包含三个块（$A_{i,k}$、$B_{k,j}$ 和 $C_{i,j}$）的页面均未驻留在内存中。对页面内任何数据的首次访问都会发生一次缺页中断。分配的 $f$ 帧内存足以容纳这三个块的所有页面，因此在此步骤中没有页面被驱逐。因此，总缺页中断次数就是这三个块所跨越的唯一页面总数。\n\n每个块由 $t \\times t = t^2$ 个元素组成。\n每个元素的大小为 $s$ 字节。\n单个块的总大小（以字节为单位）是 $t^2 s$。\n虚拟内存页面大小为 $p$ 字节。\n\n假设每个块的数据在虚拟内存中是连续存储的，那么存储一个块所需的页面数是该块的总字节大小除以页面大小，并向上取整。\n$$\n\\text{每块的页面数} = \\left\\lceil \\frac{t^2 s}{p} \\right\\rceil\n$$\n由于有三个块（$A_{i,k}$、$B_{k,j}$、$C_{i,j}$）且初始时都未驻留，总缺页中断次数为：\n$$\n\\text{总缺页中断次数} = 3 \\times (\\text{每块的页面数}) = 3 \\left\\lceil \\frac{t^2 s}{p} \\right\\rceil\n$$\n\n**分母：总内存引用次数**\n\n计算由一个标准的三重循环结构执行：\n`for i in 1..t, for j in 1..t, for k in 1..t`\n`C[i,j] += A[i,k] * B[k,j]`\n\n我们来分析在整个微内核步骤中这些循环产生的内存引用。一次内存引用是一次读取（加载）或一次写入（存储）操作。\n\n1.  **对矩阵 A 的引用**：对于外两层循环中的每一对索引 $(i,j)$，最内层的关于 $k$ 从 $1$ 到 $t$ 的循环会读取元素 $A[i,1], A[i,2], \\dots, A[i,t]$。外层循环遍历所有 $t^2$ 对 $(i,j)$。因此，对于一个固定的 $i$，行 $A[i,:]$ 被读取 $t$ 次（对应于每个 $j$ 值一次）。由于有 $t$ 行，从块 $A_{i,k}$ 读取的总次数为 $t \\times t \\times t = t^3$。\n\n2.  **对矩阵 B 的引用**：类似地，对于每一对索引 $(i,j)$，最内层的关于 $k$ 的循环会读取元素 $B[1,j], B[2,j], \\dots, B[t,j]$。对于一个固定的 $j$，这一列 $B[:,j]$ 被读取 $t$ 次（对应于每个 $i$ 值一次）。由于有 $t$ 列，从块 $B_{k,j}$ 读取的总次数为 $t \\times t \\times t = t^3$。\n\n3.  **对矩阵 C 的引用**：累加操作 $C[i,j] \\leftarrow C[i,j] + \\dots$ 意味着对于块 $C_{i,j}$ 中的 $t^2$ 个元素中的每一个，其初始值被读取一次，其最终累加值被写回一次。这与问题陈述“对于 C，在此步骤中对每个元素执行一次读取和一次写入”相符。\n    - 从 $C_{i,j}$ 的总读取次数：$t^2$\n    - 对 $C_{i,j}$ 的总写入次数：$t^2$\n\n总内存引用次数是所有读取和写入的总和：\n$$\n\\text{总内存引用次数} = (\\text{A 读取次数}) + (\\text{B 读取次数}) + (\\text{C 读取次数}) + (\\text{C 写入次数})\n$$\n$$\n\\text{总内存引用次数} = t^3 + t^3 + t^2 + t^2 = 2t^3 + 2t^2\n$$\n\n**组合得到 $\\mathrm{PFF}(t)$**\n\n将分子和分母的表达式代入 PFF 定义中得到：\n$$\n\\mathrm{PFF}(t) = \\frac{3 \\left\\lceil \\frac{t^2 s}{p} \\right\\rceil}{2t^3 + 2t^2}\n$$\n\n**第二部分：最优块大小 $t^{\\ast}$**\n\n我们需要找到在帧预算约束下使 $\\mathrm{PFF}(t)$ 最小化的块大小 $t^{\\ast}$。\n\n首先，我们分析 $\\mathrm{PFF}(t)$ 作为 $t$ 的函数的行为。包括上取整函数的分子，其增长大约与 $t^2$ 成正比：$3 \\left\\lceil \\frac{t^2 s}{p} \\right\\rceil \\approx \\frac{3st^2}{p}$。对于较大的 $t$，分母的增长与 $t^3$ 成正比：$2t^3 + 2t^2 \\approx 2t^3$。因此，该比率的行为近似为：\n$$\n\\mathrm{PFF}(t) \\approx \\frac{3st^2/p}{2t^3} = \\frac{3s}{2pt}\n$$\n这个函数是 $t$ 的递减函数。附加项和上取整函数不会改变这一总体趋势：分母的增长速度（$O(t^3)$）渐进地快于分子（$O(t^2)$）。因此，为了最小化 $\\mathrm{PFF}(t)$，我们必须选择满足帧预算约束的可能的最大整数值 $t$。\n\n约束条件是工作集（三个块）所需的总页面数不能超过分配的页帧数 $f$。\n$$\n\\text{使用的总页面数} \\le f\n$$\n使用的总页面数等于前面计算的总缺页中断次数：\n$$\n3 \\left\\lceil \\frac{t^2 s}{p} \\right\\rceil \\le f\n$$\n为了找到满足此不等式的最大整数 $t$，我们首先解出上取整函数内的项。\n$$\n\\left\\lceil \\frac{t^2 s}{p} \\right\\rceil \\le \\frac{f}{3}\n$$\n由于左侧必须是一个整数，该不等式等价于：\n$$\n\\left\\lceil \\frac{t^2 s}{p} \\right\\rceil \\le \\left\\lfloor \\frac{f}{3} \\right\\rfloor\n$$\n令 $K = \\lfloor \\frac{f}{3} \\rfloor$。不等式为 $\\lceil x \\rceil \\le K$，其中 $x = \\frac{t^2 s}{p}$。此条件意味着 $x$ 不能大于 $K$。如果 $x > K$，那么 $\\lceil x \\rceil \\ge K+1$，这将违反不等式。因此，我们必须有 $x \\le K$。\n$$\n\\frac{t^2 s}{p} \\le \\left\\lfloor \\frac{f}{3} \\right\\rfloor\n$$\n现在，我们解出 $t$：\n$$\nt^2 \\le \\frac{p}{s} \\left\\lfloor \\frac{f}{3} \\right\\rfloor\n$$\n$$\nt \\le \\sqrt{\\frac{p}{s} \\left\\lfloor \\frac{f}{3} \\right\\rfloor}\n$$\n由于块大小 $t$ 必须是整数，最优块大小 $t^{\\ast}$ 是满足此条件的最大整数。这通过对右侧取下整得到。\n$$\nt^{\\ast} = \\left\\lfloor \\sqrt{\\frac{p}{s} \\left\\lfloor \\frac{f}{3} \\right\\rfloor} \\right\\rfloor\n$$\n这是在给定约束下最大化内存利用率，从而最小化缺页率的块大小。", "answer": "$$\n\\boxed{\n\\begin{aligned}\n\\mathrm{PFF}(t) = \\frac{3 \\left\\lceil \\frac{t^2 s}{p} \\right\\rceil}{2t^3 + 2t^2} \\\\\nt^{\\ast} = \\left\\lfloor \\sqrt{\\frac{p}{s} \\left\\lfloor \\frac{f}{3} \\right\\rfloor} \\right\\rfloor\n\\end{aligned}\n}\n$$", "id": "3667672"}, {"introduction": "理论学习最终要应用于实践。系统性能工程师会使用 Linux `perf` 等工具来测量缺页率（PFF）及其他关键指标，以诊断程序瓶颈。本练习模拟了这一真实场景，要求你分析假设的性能计数器数据，通过解读缺页率和系统调用率的变化，准确判断线程处于计算密集型、I/O密集型还是内存颠簸状态。[@problem_id:3667759]", "problem": "一个多线程工作负载使用 Linux 性能分析工具 (perf) 进行检测，以研究缺页频率 (PFF)。在本实验中，缺页频率 (PFF) 的操作性定义是：一个线程在固定的墙钟时间间隔内所经历的缺页速率。当一个线程引用一个当前未映射到可用物理帧的虚拟内存页面时，就会发生缺页；这包括次要缺页（页面已在内存中，但未映射到进程地址空间）和主要缺页（页面不在内存中，必须从磁盘获取）。系统调用 (syscall) 率被用作识别输入/输出 (I/O) 密集型阶段的代理指标，因为执行 I/O 的线程通常会调用许多系统调用（例如 `read` 和 `write`）。中央处理器 (CPU) 密集型行为的特点是持续计算，系统调用很少。该实验在三个具有已知墙钟持续时间且不重叠的阶段中，对每个线程的计数器进行采样。\n\n该工作负载有两个线程，$T_1$ 和 $T_2$。对于每个阶段，perf 报告了以下关于缺页（次要加主要的总和）和系统调用的每线程计数：\n\n阶段 $\\mathrm{A}$ 跨度为 $0$ 到 $10$ 秒，持续 $10$ 秒。\n- $T_1$: 缺页 $2000$ 次，系统调用 $80$ 次。\n- $T_2$: 缺页 $100$ 次，系统调用 $60$ 次。\n\n阶段 $\\mathrm{B}$ 跨度为 $10$ 到 $30$ 秒，持续 $20$ 秒。\n- $T_1$: 缺页 $150$ 次，系统调用 $5000$ 次。\n- $T_2$: 缺页 $2500$ 次，系统调用 $200$ 次。\n\n阶段 $\\mathrm{C}$ 跨度为 $30$ 到 $45$ 秒，持续 $15$ 秒。\n- $T_1$: 缺页 $20$ 次，系统调用 $40$ 次。\n- $T_2$: 缺页 $30$ 次，系统调用 $35$ 次。\n\n根据上述基本定义以及在已知持续时间内报告的每线程计数，哪个选项最能正确描述阶段行为，并给出计算每线程缺页频率 (PFF) 并将其与系统调用率关联以区分 I/O 密集型与 CPU 密集型阶段的适当测量方法？\n\nA. 在每个阶段中，将每线程的 PFF 计算为总缺页数（次要加主要）除以阶段持续时间，并类似地计算每线程的系统调用率。然后，对于 $T_1$，阶段 $\\mathrm{A}$ 表现为高 PFF 和低系统调用率（与 CPU 密集型工作期间的内存抖动一致），阶段 $\\mathrm{B}$ 表现为低 PFF 和非常高的系统调用率（与 I/O 密集型行为一致），阶段 $\\mathrm{C}$ 表现为低 PFF 和低系统调用率（与具有常驻工作集的 CPU 密集型计算一致）。对于 $T_2$，阶段 $\\mathrm{A}$ 表现为低 PFF 和低系统调用率（工作集较小的 CPU 密集型），阶段 $\\mathrm{B}$ 表现为非常高的 PFF 和中等的系统调用率（与内存抖动一致），阶段 $\\mathrm{C}$ 表现为低 PFF 和低系统调用率（CPU 密集型）。\n\nB. 任何具有高系统调用率的阶段也必须具有高 PFF，因为系统调用会触发缺页；因此，在阶段 $\\mathrm{B}$ 中 $T_1$ 和 $T_2$ 都是 I/O 密集型的，并且 PFF 无法区分 CPU 密集型与 I/O 密集型阶段。\n\nC. 为了正确计算 PFF，只应计算主要缺页，因为次要缺页不反映内存驻留情况；因此，具有许多次要缺页的阶段应被视为 PFF 为零，分类应仅依赖于主要缺页。\n\nD. 每线程 PFF 应通过汇总系统范围的缺页并除以进程 CPU 时间（而非墙钟时间）来计算，因为墙钟时间包括 I/O 等待，因此会低估真实频率；使用系统范围的计数器在归一化后仍能揭示每线程的阶段行为。\n\n选择唯一最佳选项。", "solution": "推导从核心定义开始。缺页是当一个线程引用一个当前未映射到可用物理帧的虚拟内存页面时触发的事件。在固定时间间隔内离散事件的速率（频率）定义为总计数除以时间间隔的长度；因此，在本实验中，缺页频率 (PFF) 的操作性计算方法是：每线程的缺页计数除以测量窗口的墙钟持续时间。系统调用 (syscall) 率的计算方法类似，即每线程的系统调用计数除以墙钟持续时间。这些定义遵循标准的频率概念：如果在时间间隔 $\\Delta t$ 内均匀发生 $N$ 个事件，则事件频率为 $N / \\Delta t$。在操作系统中，I/O 密集型阶段通常表现出高系统调用率（如调用 `read`、`write`、`open`），而 CPU 密集型阶段则表现出低系统调用率和持续的计算。内存抖动的特点是极高的 PFF（频繁的缺页），表明工作集大小超过了可用的物理帧或映射能力，而低 PFF 则表示一个常驻、稳定的工作集。\n\n计算每个阶段中每线程的 PFF 和系统调用率：\n\n对于 $T_1$：\n- 阶段 $\\mathrm{A}$ 持续 $10$ 秒。PFF $= 2000 / 10 = 200$ 次缺页/秒。系统调用率 $= 80 / 10 = 8$ 次系统调用/秒。解释：极高的 PFF，低的系统调用率。这与 CPU 密集的内存抖动行为一致（线程在进行计算并导致大量缺页，而不是发出许多 I/O 系统调用）。\n- 阶段 $\\mathrm{B}$ 持续 $20$ 秒。PFF $= 150 / 20 = 7.5$ 次缺页/秒。系统调用率 $= 5000 / 20 = 250$ 次系统调用/秒。解释：低的 PFF，极高的系统调用率。这与 I/O 密集型行为（大量系统调用）以及相对稳定的工作集（低 PFF）一致。\n- 阶段 $\\mathrm{C}$ 持续 $15$ 秒。PFF $= 20 / 15 \\approx 1.33$ 次缺页/秒。系统调用率 $= 40 / 15 \\approx 2.67$ 次系统调用/秒。解释：低的 PFF 和低的系统调用率。这与具有常驻工作集的 CPU 密集型计算一致。\n\n对于 $T_2$：\n- 阶段 $\\mathrm{A}$ 持续 $10$ 秒。PFF $= 100 / 10 = 10$ 次缺页/秒。系统调用率 $= 60 / 10 = 6$ 次系统调用/秒。解释：低的 PFF 和低的系统调用率。这与工作集较小的 CPU 密集型行为一致。\n- 阶段 $\\mathrm{B}$ 持续 $20$ 秒。PFF $= 2500 / 20 = 125$ 次缺页/秒。系统调用率 $= 200 / 20 = 10$ 次系统调用/秒。解释：极高的 PFF 和中等的系统调用率。这与 CPU 密集型工作期间的内存抖动一致，而非 I/O 密集型行为。\n- 阶段 $\\mathrm{C}$ 持续 $15$ 秒。PFF $= 30 / 15 = 2$ 次缺页/秒。系统调用率 $= 35 / 15 \\approx 2.33$ 次系统调用/秒。解释：低的 PFF 和低的系统调用率。这与 CPU 密集型行为一致。\n\n根据这些计算，正确的分类和测量方法是：使用每线程的计数除以墙钟时间间隔来计算每线程的 PFF 和系统调用率，然后在 PFF 较低的情况下将高系统调用率解释为 I/O 密集型，将高 PFF 和低系统调用率解释为内存抖动的 CPU 密集型行为。这与选项 A 完全匹配。\n\n评估每个选项：\n\nA. 选项 A 描述了将每线程 PFF 计算为总缺页数（次要加主要）除以阶段持续时间，并类似地计算每线程系统调用率。然后它提供的解释与计算出的速率完全匹配：$T_1$ 阶段 $\\mathrm{A}$ 高 PFF 低系统调用率（内存抖动），阶段 $\\mathrm{B}$ 低 PFF 极高系统调用率（I/O 密集型），阶段 $\\mathrm{C}$ 低 PFF 低系统调用率（CPU 密集型）；以及 $T_2$ 阶段 $\\mathrm{A}$ 低 PFF 低系统调用率（CPU 密集型），阶段 $\\mathrm{B}$ 极高 PFF 中等系统调用率（内存抖动），阶段 $\\mathrm{C}$ 低 PFF 低系统调用率（CPU 密集型）。结论 — 正确。\n\nB. 选项 B 断言，任何具有高系统调用率的阶段也必须具有高 PFF，因为系统调用会触发缺页。这是一个误解。系统调用通常不会直接导致缺页；许多系统调用操作的是已驻留的数据，或涉及不导致用户页面缺页的内核工作。我们的数据显示了一个反例：$T_1$ 阶段 $\\mathrm{B}$ 的系统调用率极高（每秒 $250$ 次），但 PFF 很低（每秒 $7.5$ 次）。此外，PFF 清楚地区分了内存抖动的 CPU 密集型阶段（例如，$T_1$ 阶段 $\\mathrm{A}$ 和 $T_2$ 阶段 $\\mathrm{B}$）与 I/O 密集型阶段（例如，$T_1$ 阶段 $\\mathrm{B}$）。结论 — 错误。\n\nC. 选项 C 声称只应计算主要缺页来得到 PFF，因为次要缺页不反映内存驻留情况，并建议将具有许多次要缺页的阶段视为 PFF 为零。这在实验室的定义和操作目标的背景下是错误的。次要缺页表明页面在访问时未映射到进程地址空间中；它们是影响局部性和映射的内存管理事件的证据，并且它们对线程所经历的有效缺页频率有贡献。排除次要缺页会扭曲观察到的 PFF 特征，并可能掩盖表现为频繁次要缺页的抖动（例如，写时复制缺页或页表填充）。结论 — 错误。\n\nD. 选项 D 建议通过汇总系统范围的缺页并除以进程 CPU 时间（而非墙钟时间）来计算每线程 PFF，并声称系统范围的计数器仍能揭示每线程的行为。这有两个缺陷。首先，每线程 PFF 必须根据每线程的计数来计算，以保持归属性；系统范围的聚合会混合来自不相关线程和进程的事件，从而破坏每线程的解析度。其次，频率是根据单位时间定义的；使用 CPU 时间排除了 I/O 等待和其他调度器引起的延迟，而这些都是我们旨在分类的行为的一部分。按 CPU 时间进行归一化会夸大 I/O 密集型阶段的表观速率，并混淆解释。结论 — 错误。\n\n因此，选项 A 是唯一的最佳选择。", "answer": "$$\\boxed{A}$$", "id": "3667759"}]}