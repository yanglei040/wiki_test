{"hands_on_practices": [{"introduction": "要真正掌握附加参考位（ARB）算法，我们必须首先从数学上理解其核心工作原理。这个练习旨在通过严格的推导，证明一个 $k$ 位的 ARB 寄存器实际上是如何编码了最近 $k$ 个时间间隔的页面引用历史。通过完成这项实践，你将深刻理解为什么 ARB 是对最近最少使用（LRU）策略的一种近似，并明确其信息丢失的内在机制。", "problem": "考虑一个操作系统，它实现了用于页面置换的附加引用位 (ARB) 算法，该算法是最近最少使用 (LRU) 算法的一种近似。对于每个页面 $i$，ARB 算法会维护一个 $k$ 位的寄存器 $R_i$，并每隔 $\\Delta t$ 秒使用一次周期性定时器中断。寄存器 $R_i$ 被初始化为全 0 位。在时间索引 $t \\in \\{1, 2, \\dots, n\\}$ 的每次中断期间，该算法执行以下操作：它将 $R_i$ 右移一位，丢弃最低有效位，然后将该时间间隔的引用位 $r_i(t) \\in \\{0, 1\\}$ 写入 $R_i$ 的最高有效位位置。在第 $n$ 次更新后，算法将 $R_i$ 解释为一个无符号二进制整数，记作 $V_i$，该值用于对页面进行排序以确定置换顺序。\n\n仅从 ARB 算法的这些操作性定义（初始化、移位、插入 $r_i(t)$ 和无符号解释）出发，并假设 $n \\geq k$，执行以下任务：\n\n- 证明在第 $n$ 次更新后，$R_i$ 的内容精确地编码了二进制引用历史 $\\{r_i(1), r_i(2), \\dots, r_i(n)\\}$ 的最后 $k$ 位，并按时间顺序排列，其中 $r_i(n)$ 占据 $R_i$ 的最高有效位。\n\n- 使用该解释，精确地描述在何种情况下，两个长度为 $n$ 的不同二进制引用历史在第 $n$ 次更新后会产生相同的无符号值 $V_i$。\n\n- 以 $n$ 和 $k$ 的函数的闭合形式，计算映射到第 $n$ 次更新后某一固定值 $V_i$ 的长度为 $n$ 的不同二进制引用历史的数量。\n\n将您的最终答案表示为一个关于 $n$ 和 $k$ 的单一闭合解析表达式。无需四舍五入，也无需单位。", "solution": "该问题已经过验证，被认为是合理的。其科学基础在于操作系统算法的原理，提法得当，对附加引用位 (ARB) 算法有清晰和形式化的定义，且语言客观。所提供的信息是自洽的，足以进行严格的推导。我们可以开始求解。\n\n该问题要求在 ARB 算法下对 $k$ 位寄存器 $R_i$ 的状态进行三个相关的分析。我们将系统地解决每个部分。设第 $t$ 次更新后寄存器 $R_i$ 的状态为一个位向量 $R_i^{(t)} = (b_{k-1}^{(t)}, b_{k-2}^{(t)}, \\dots, b_0^{(t)})$，其中 $b_{k-1}^{(t)}$ 是最高有效位 (MSB)，$b_0^{(t)}$ 是最低有效位 (LSB)。寄存器初始化为全 0，意味着 $R_i^{(0)} = (0, 0, \\dots, 0)$。在每个时间步 $t \\in \\{1, 2, \\dots, n\\}$，更新操作包括一次右移，随后将引用位 $r_i(t)$ 插入到 MSB 位置。该操作可以用以下递推关系描述：\n$b_{k-1}^{(t)} = r_i(t)$\n$b_{j}^{(t)} = b_{j+1}^{(t-1)}$ for $j \\in \\{0, 1, \\dots, k-2\\}$。\n\n首先，我们证明第 $n$ 次更新后 $R_i$ 的内容。让我们追踪寄存器位的状态。\n在 $t=1$ 时：寄存器右移，内容仍为 $(0, \\dots, 0)$，然后插入 $r_i(1)$。因此，$R_i^{(1)} = (r_i(1), 0, \\dots, 0)$。\n在 $t=2$ 时：$R_i^{(1)}$ 右移得到 $(0, r_i(1), 0, \\dots, 0)$。然后插入 $r_i(2)$。因此，$R_i^{(2)} = (r_i(2), r_i(1), 0, \\dots, 0)$。\n通过归纳法，我们可以确定经过 $t$ 次更新后寄存器中位 $b_j^{(t)}$ 的一般形式。让我们展开 $t=n$ 时状态的递推关系。\n在第 $n$ 步，MSB $b_{k-1}^{(n)}$ 被设置为 $r_i(n)$。\n$b_{k-1}^{(n)} = r_i(n)$。\n下一位 $b_{k-2}^{(n)}$ 从前一个状态的 MSB $b_{k-1}^{(n-1)}$ 获得其值。\n$b_{k-2}^{(n)} = b_{k-1}^{(n-1)} = r_i(n-1)$。\n类似地，位 $b_{k-3}^{(n)}$ 从 $b_{k-2}^{(n-1)}$ 获得其值，而后者又来自于 $b_{k-1}^{(n-2)}$。\n$b_{k-3}^{(n)} = b_{k-2}^{(n-1)} = b_{k-1}^{(n-2)} = r_i(n-2)$。\n推广这个模式，经过 $n$ 次更新后，位置 $j$ 上的位 $b_j^{(n)}$（其中 LSB 是位置 0），是 $k-1-j$ 步前处于 MSB 位置的值。也就是说，是在时间 $n-(k-1-j) = n-k+1+j$ 插入的值。\n让我们用另一种索引约定来验证这一点。对于 $m \\in \\{0, 1, \\dots, k-1\\}$，位 $b_{k-1-m}^{(n)}$ 对应于时间 $n$ 之前 $m$ 步插入的引用位，即 $r_i(n-m)$。\n对于 $m=0$，$b_{k-1}^{(n)} = r_i(n)$。\n对于 $m=1$，$b_{k-2}^{(n)} = r_i(n-1)$。\n...\n对于 $m=k-1$，$b_{0}^{(n)} = r_i(n-(k-1)) = r_i(n-k+1)$。\n这成立是因为问题假设 $n \\geq k$，这确保了时间索引 $n-k+1$ 至少为 1。初始的 0 位已完全被移出寄存器。\n因此，第 $n$ 次更新后寄存器的状态是：\n$$R_i^{(n)} = (r_i(n), r_i(n-1), \\dots, r_i(n-k+1))$$\n这表示引用历史 $\\{r_i(1), \\dots, r_i(n)\\}$ 的最后 $k$ 位。最近的位 $r_i(n)$ 占据最高有效位，而这些位从 MSB 到 LSB 是按时间倒序排列的。问题的措辞“按时间顺序排列，且 $r_i(n)$ 占据最高有效位”是定义布局的一个特定指令，我们的推导证实了这一点。\n\n第二，我们描述两个不同的二进制引用历史在何种情况下会产生相同的值 $V_i$。一个历史是一个序列 $H = \\{r_i(1), r_i(2), \\dots, r_i(n)\\}$。值 $V_i$ 是最终寄存器状态 $R_i^{(n)}$ 的无符号二进制整数解释。\n$$V_i = \\sum_{j=0}^{k-1} b_j^{(n)} 2^j$$\n将我们关于位 $b_j^{(n)}$ 的结果代入：\n$$V_i = b_{k-1}^{(n)}2^{k-1} + b_{k-2}^{(n)}2^{k-2} + \\dots + b_0^{(n)}2^0$$\n$$V_i = r_i(n)2^{k-1} + r_i(n-1)2^{k-2} + \\dots + r_i(n-k+1)2^0$$\n这个表达式表明，值 $V_i$ 仅取决于引用历史的最后 $k$ 位，即 $\\{r_i(n-k+1), r_i(n-k+2), \\dots, r_i(n)\\}$。来自前 $n-k$ 个引用位 $\\{r_i(1), \\dots, r_i(n-k)\\}$ 的任何信息都丢失了。\n因此，两个不同的历史 $H$ 和 $H'$ 产生相同的值 $V_i$ 当且仅当它们最后的 $k$ 个引用位是相同的。也就是说，对于 $H = \\{r_i(1), \\dots, r_i(n)\\}$ 和 $H' = \\{r'_i(1), \\dots, r'_i(n)\\}$，条件 $V_i = V'_i$ 等价于：\n$$r_i(t) = r'_i(t) \\quad \\text{for all } t \\in \\{n-k+1, n-k+2, \\dots, n\\}$$\n由于规定历史是不同的 ($H \\neq H'$)，它们必须在前 $n-k$ 个引用位中至少有一个不同。\n\n第三，我们计算映射到固定值 $V_i$ 的长度为 $n$ 的不同二进制引用历史的数量。一个固定的整数值 $V_i$（其中 $0 \\leq V_i  2^k$）有一个唯一的 $k$ 位二进制表示。这个唯一的位模式固定了寄存器 $R_i^{(n)}$ 所需的状态。\n根据我们的第一个结果，固定 $R_i^{(n)}$ 的状态等价于固定最后 $k$ 个引用位 $\\{r_i(n), r_i(n-1), \\dots, r_i(n-k+1)\\}$ 的值。\n一个历史是 $n$ 位的序列 $\\{r_i(1), r_i(2), \\dots, r_i(n)\\}$。为了映射到所选的 $V_i$，最后的 $k$ 位是确定的。然而，历史的前 $n-k$ 位 $\\{r_i(1), r_i(2), \\dots, r_i(n-k)\\}$ 不影响 $V_i$ 的最终值。这 $n-k$ 位中的每一位都可以独立地选择为 0 或 1。\n$r_i(1)$ 的选择数量是 $2$。\n$r_i(2)$ 的选择数量是 $2$。\n...\n$r_i(n-k)$ 的选择数量是 $2$。\n不同历史的总数是这些独立位中每一位的选择数量的乘积。因此，映射到固定值 $V_i$ 的长度为 $n$ 的引用历史的数量是：\n$$ \\underbrace{2 \\times 2 \\times \\dots \\times 2}_{n-k \\text{ times}} = 2^{n-k} $$\n这个结果与所选择的 $V_i$ 的具体值无关。假设 $n \\geq k$ 确保了指数 $n-k$ 是一个非负整数。", "answer": "$$\\boxed{2^{n-k}}$$", "id": "3619905"}, {"introduction": "在理想模型之外，现实世界的系统总是伴随着噪声和不确定性。这项实践将引导你探索硬件噪声如何影响 ARB 算法的准确性，特别是当一个“冷”页面（从未被真实访问）的参考位被随机置位时。通过计算这种噪声导致的 ARB 计数值的期望“膨胀”，你将学会如何运用概率工具来量化算法在非理想条件下的稳健性。", "problem": "一个虚拟内存系统实现了附加参考位（ARB）页面置换算法。对于每个页面 $i$，ARB 维护一个 $k$ 位寄存器，其无符号整数解释表示为 $V_i$。在每个采样周期结束时，该算法对每个页面执行以下更新：将 $k$ 位寄存器右移 $1$ 位，丢弃最低有效位，将当前的硬件参考位 $R_i$ 插入最高有效位，然后清除 $R_i$。因此，最近的引用对 $V_i$ 的贡献具有更高的权重位。\n\n考虑一个真正“冷”的页面，意味着它从未被任何进程实际引用过。然而，假设硬件参考位 $R_i$ 被随机噪声虚假地设置：在每个采样周期中，与其他所有周期独立，$R_i$ 以概率 $\\epsilon$ 被设置为 $1$，否则保持为 $0$。假设该页面的 ARB 寄存器初始化为 $0$。\n\n仅使用 ARB 更新机制的核心定义和基本概率论（期望的线性性质和独立性），推导 $M$ 次 ARB 更新后 $V_i$ 的期望值的闭式表达式，该表达式是 $\\epsilon$、$k$ 和 $M$ 的函数。然后取 $M \\to \\infty$ 的极限，以获得这样一个冷页面 $V_i$ 的稳态期望膨胀值。将您的最终答案表示为关于 $\\epsilon$ 和 $k$ 的单个闭式解析表达式。不要对您的答案进行四舍五入。", "solution": "问题要求在附加参考位（ARB）页面置换系统中，一个 $k$ 位寄存器 $V_i$ 在受到虚假位设置影响下的稳态期望值。推导过程将首先建立寄存器在 $M$ 次更新后其值的形式化表示，然后计算其期望值，最后取 $M \\to \\infty$ 的极限。\n\n设 $V_i(t)$ 为页面 $i$ 的 $k$ 位寄存器在 $t$ 次更新后的无符号整数值。初始状态给定为 $V_i(0)=0$。该寄存器由 $k$ 个位组成，我们将其表示为 $b_{k-1}(t), b_{k-2}(t), \\ldots, b_0(t)$，其中 $b_{k-1}$ 是最高有效位（MSB），$b_0$ 是最低有效位（LSB）。寄存器在时间 $t$ 的值由标准的二进制到整数转换给出：\n$$V_i(t) = \\sum_{j=0}^{k-1} b_j(t) 2^j$$\n在每个采样周期 $t \\in \\{1, 2, \\ldots, M\\}$ 结束时执行的 ARB 更新机制由两个动作定义：\n$1$. 寄存器右移一位。这意味着位置 $j$ 的位从前一个状态的位置 $j+1$ 的位获取其新值：对于所有 $j \\in \\{0, 1, \\ldots, k-2\\}$，$b_j(t) = b_{j+1}(t-1)$。\n$2$. MSB 用当前周期的硬件参考位 $R_i(t)$ 的值进行更新：$b_{k-1}(t) = R_i(t)$。\n\n对于所讨论的冷页面，参考位 $R_i(t)$ 被建模为独立的伯努利随机变量，对于每个周期 $t$，$P(R_i(t)=1) = \\epsilon$ 且 $P(R_i(t)=0) = 1-\\epsilon$。因此，每个参考位的期望值为 $E[R_i(t)] = 1 \\cdot P(R_i(t)=1) + 0 \\cdot P(R_i(t)=0) = \\epsilon$。\n\n为了找到 $M$ 次更新后的值 $V_i(M)$，我们必须确定每个位 $b_j(M)$ 的值。我们可以通过重复应用更新规则来追溯每个位的来源：\n$$b_j(M) = b_{j+1}(M-1) = b_{j+2}(M-2) = \\ldots = b_{j+s}(M-s)$$\n我们可以将位置 $j$ 的位及时追溯 $s = k-1-j$ 步，此时它的来源是位置 $k-1$ 处的 MSB：\n$$b_j(M) = b_{k-1}(M - (k-1-j)) = R_i(M - k + 1 + j)$$\n如果参考位的时间索引为正，即 $M - k + 1 + j \\ge 1$，这个关系成立，可简化为 $M+j \\ge k$。\n\n如果 $M+j  k$，则在 $M$ 次更新内追溯不到一个 MSB。相反，我们将该位的来源追溯到 $t=0$ 的初始状态：\n$$b_j(M) = b_{j+1}(M-1) = \\ldots = b_{j+M}(M-M) = b_{j+M}(0)$$\n由于条件是 $M+j  k$，索引 $j+M$ 是一个有效的位位置（即 $j+M  k$）。初始条件 $V_i(0)=0$ 意味着所有初始位都为零，所以 $b_{j+M}(0) = 0$。因此，对于 $M+j  k$，我们有 $b_j(M) = 0$。\n\n结合这两种情况，在 $M$ 次更新后，位 $j$ 的状态是：\n$$b_j(M) = \\begin{cases} R_i(M - k + 1 + j)  \\text{若 } M+j \\ge k \\\\ 0  \\text{若 } M+j  k \\end{cases}$$\n条件 $M+j \\ge k$ 等价于 $j \\ge k-M$。我们现在可以写出 $V_i(M)$ 的表达式：\n$$V_i(M) = \\sum_{j=0}^{k-1} b_j(M) 2^j = \\sum_{j=\\max(0, k-M)}^{k-1} R_i(M - k + 1 + j) 2^j$$\n问题要求 $V_i(M)$ 的期望值。利用期望的线性性质，我们有：\n$$E[V_i(M)] = E\\left[ \\sum_{j=\\max(0, k-M)}^{k-1} R_i(M - k + 1 + j) 2^j \\right] = \\sum_{j=\\max(0, k-M)}^{k-1} E[R_i(M - k + 1 + j)] 2^j$$\n代入对所有 $t$ 都有的 $E[R_i(t)] = \\epsilon$：\n$$E[V_i(M)] = \\sum_{j=\\max(0, k-M)}^{k-1} \\epsilon \\cdot 2^j = \\epsilon \\sum_{j=\\max(0, k-M)}^{k-1} 2^j$$\n这个和是一个等比数列。设下界为 $a = \\max(0, k-M)$，上界为 $b = k-1$。等比数列 $\\sum_{j=a}^{b} r^j$ 的和由 $\\frac{r^a - r^{b+1}}{1-r}$ 给出。对于 $r=2$，这简化为 $2^{b+1} - 2^a$。\n代入我们的 $a$ 和 $b$ 的界限：\n$$\\sum_{j=\\max(0, k-M)}^{k-1} 2^j = 2^{(k-1)+1} - 2^{\\max(0, k-M)} = 2^k - 2^{\\max(0, k-M)}$$\n因此，$M$ 次更新后期望值的闭式表达式为：\n$$E[V_i(M)] = \\epsilon \\left(2^k - 2^{\\max(0, k-M)}\\right)$$\n最后一步是通过取 $M \\to \\infty$ 的极限来找到稳态期望值：\n$$E[V_i]_{\\text{steady-state}} = \\lim_{M \\to \\infty} E[V_i(M)] = \\lim_{M \\to \\infty} \\left[ \\epsilon \\left(2^k - 2^{\\max(0, k-M)}\\right) \\right]$$\n当 $M \\to \\infty$ 时，项 $k-M \\to -\\infty$。因此，对于任何 $M \\ge k$，$\\max(0, k-M)$ 变为 $0$。\n因此，项 $2^{\\max(0, k-M)}$ 的极限是：\n$$\\lim_{M \\to \\infty} 2^{\\max(0, k-M)} = 2^0 = 1$$\n将此结果代入期望值的极限中：\n$$E[V_i]_{\\text{steady-state}} = \\epsilon (2^k - 1)$$\n这个值表示一个冷页面的 ARB 计数器的稳态期望膨胀，这完全是由参考位中的随机噪声引起的。", "answer": "$$\\boxed{\\epsilon (2^k - 1)}$$", "id": "3619934"}, {"introduction": "算法的性能不仅取决于其自身设计，还取决于它与操作系统中其他机制的复杂交互。这项动手实践提供了一个具体的模拟挑战，揭示了 ARB 算法在“大页降级”这一实际场景中的一个重要缺陷。你将通过编程模拟来量化 ARB 在无法区分大页内部访问局部性时，如何错误地将“冷”页面标记为“热”页面，从而深刻体会到在系统层面评估算法的重要性。", "problem": "你需要在一个真实的虚拟内存场景下严格评估附加参考位 (ARB) 算法，该场景涉及一个大内存页（大页）被降级为多个基本页。ARB 算法为每个页面维护一个 $k$ 位的老化寄存器 $V_i$，该寄存器编码了引用的新近度和频率。在每个以 $t \\in \\{1,2,\\dots,n\\}$ 为索引的离散时间间隔结束时，该实现会将每个 $V_i$ 右移一位，并将最近的参考位 $r_i(t) \\in \\{0,1\\}$ 作为最高有效位插入。这种设计在操作系统中被广泛用于通过硬件支持的参考位来近似实现页面替换策略。\n\n使用的基本依据和假设：\n- 虚拟内存由页组成。一个大页将 $M$ 个基本页聚合为一个连续区域。\n- 附加参考位 (ARB) 算法使用每个被跟踪页面的一个 $k$ 位老化寄存器来近似最近的使用历史。\n- 大页降级会将一个被跟踪的大页替换为 $M$ 个独立跟踪的基本页。一个常见的 seeding (种子设定) 策略是将每个降级后基本页的寄存器初始化为该大页当前的寄存器值。\n- 我们考虑一个大页以及仅发生在该大页内部的引用。在每个时间间隔 $t$ 内，恰好有一次小内存访问，且被访问的子页索引由一个确定性的、均匀的过程决定，除非另有说明。\n\n你的任务是模拟并量化当访问频繁但分散在整个大页时，ARB 算法在降级时刻如何未能捕捉到子页局部性。具体来说，你必须计算在降级时，由于继承了大页的老化寄存器而被错误分类为“热”页的子页数量，并与一个从一开始就单独跟踪每个基本页的基准情况进行比较。\n\n定义与度量：\n- 设 $n$ 为模拟的总时间间隔数。\n- 设 $M$ 为构成大页的基本页数量。\n- 设 $k$ 为 ARB 寄存器的位数。\n- 设 $V_H$ 表示当作为一个单页跟踪时，大页在时间 $n$ 的 ARB 寄存器值。\n- 设 $V_i^{\\text{base}}$ 表示当每个基本页从一开始就单独跟踪时，基本页 $i \\in \\{0,1,\\dots,M-1\\}$ 在时间 $n$ 的基准 ARB 寄存器值。\n- 设 $V_i^{\\text{demote}}$ 表示降级后立即得到的基本页 $i$ 的 ARB 寄存器，其中种子设定策略为所有 $i$ 赋予 $V_i^{\\text{demote}} := V_H$。\n- 定义“热”阈值为 $\\theta := 2^{k-1}$。\n- 定义时间 $n$ 的“热”集为 $H_{\\text{base}} := \\{i \\mid V_i^{\\text{base}} \\ge \\theta\\}$ 和 $H_{\\text{demote}} := \\{i \\mid V_i^{\\text{demote}} \\ge \\theta\\}$。\n- 你必须报告的错误分类是伪热页的数量，由 $\\left|H_{\\text{demote}} \\setminus H_{\\text{base}}\\right|$ 给出，这是一个整数。\n\n引用生成：\n- 使用确定性的线性同余生成器以保证可重复性，其递归关系为 $x_{t+1} := (a x_t + c) \\bmod 2^{32}$，其中 $a := 1664525$ 且 $c := 1013904223$，从指定的无符号种子 $x_0$ 开始。\n- 对于均匀分布，在时间 $t$ 选择被引用的子页索引为 $i_t := x_t \\bmod M$。\n- 对于集中访问，引入一个大小为 $s$ 的“热集”和一个概率 $p \\in (0,1)$：以概率 $p$ 在热集内均匀引用一个子页；以概率 $1-p$ 在剩余的 $M-s$ 个子页中均匀引用一个子页。使用生成器进行伯努利决策和索引选择。\n\n程序要求：\n- 实现针对 $n$ 个时间间隔的大页和基准的按子页跟踪的 ARB 更新。对于大页，如果大页内的任何子页在时间间隔 $t$ 被引用，则每间隔参考位为 $r_H(t) := 1$，在此设置中恒为 $1$。\n- 在时间 $n$（降级时刻），对所有 $i$ 构建 $V_i^{\\text{demote}} := V_H$，使用阈值 $\\theta$ 计算 $H_{\\text{base}}$ 和 $H_{\\text{demote}}$，并输出 $\\left|H_{\\text{demote}} \\setminus H_{\\text{base}}\\right|$。\n- 不要假设任何特定的硬件页面大小；将 $M$ 纯粹视为一个计数。\n- 角度、物理单位和百分比不适用；所有输出都是无单位的整数。\n\n测试套件：\n运行以下四个测试用例并汇总其结果：\n1. 通用分布情况：$M = 128$，$k = 8$，$n = 256$，子页上均匀分布，种子 $x_0 = 1$。\n2. 边界降级情况：$M = 1$，$k = 8$，$n = 256$，均匀分布，种子 $x_0 = 1$。\n3. 集中子页局部性：$M = 64$，$k = 8$，$n = 256$，“热集”大小 $s = 2$，概率 $p = 0.9$，种子 $x_0 = 42$。\n4. ARB 中的量化边缘情况：$M = 64$，$k = 3$，$n = 64$，均匀分布，种子 $x_0 = 7$。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来的结果（例如，$[r_1,r_2,r_3,r_4]$），其中 $r_j$ 是使用上述定义的测试用例 $j$ 的伪热页计数。", "solution": "该问题要求分析附加参考位 (ARB) 页面老化算法，特别是关于当一个大页被降级为其组成的基本页时发生的信息损失。我们需要计算在降级后立即被错误分类为“热”页的基本页数量，并与一个从一开始就单独跟踪每个页面引用历史的基准情况进行比较。\n\nARB 算法的核心是页面 $i$ 的 $k$ 位老化寄存器 $V_i$ 的更新规则。在每个时间间隔 $t \\in \\{1, 2, \\dots, n\\}$ 结束时，寄存器根据该间隔的参考位 $r_i(t) \\in \\{0, 1\\}$ 进行更新：\n$$\nV_i(t) = (V_i(t-1) \\gg 1) \\lor (r_i(t) \\ll (k-1))\n$$\n其中 $\\gg$ 表示按位右移，$\\ll$ 表示按位左移，$\\lor$ 表示按位或操作。我们假设寄存器初始化为 0，即 $V_i(0)=0$。\n\n问题要求我们在特定时刻 $t=n$（代表大页降级的时刻）比较两种情况。\n\n情况 1：大页跟踪\n为整个由 $M$ 个基本页组成的大页维护一个单独的 ARB 寄存器 $V_H$。问题指出，每个时间间隔恰好访问一个子页。因此，整个大页在每个间隔都被引用，这意味着其参考位始终为 $1$。因此，对于所有 $t \\in \\{1, 2, \\dots, n\\}$，$r_H(t) = 1$。\n$V_H$ 的更新规则是：\n$$\nV_H(t) = (V_H(t-1) \\gg 1) \\lor (1 \\ll (k-1))\n$$\n从 $V_H(0) = 0$ 开始，经过 $n$ 步后，$V_H(n)$ 的值是 2 的幂之和：\n$$\nV_H(n) = \\sum_{j=0}^{\\min(n, k)-1} 2^{k-1-j}\n$$\n这是一个可以以闭合形式计算的几何级数。对于 $n \\ge k$，寄存器将被 $1$ 填满，因此 $V_H(n) = 2^k - 1$。对于 $n  k$，值为 $V_H(n) = (2^k - 1) - (2^{k-n} - 1) = 2^k-2^{k-n}$。在所有测试用例中，$n \\ge k$，因此 $V_H(n) = 2^k - 1$。\n\n降级时， $M$ 个基本页中的每一个都继承此寄存器值：对于所有 $i \\in \\{0, 1, \\dots, M-1\\}$，$V_i^{\\text{demote}} = V_H(n)$。\n\n情况 2：基准独立跟踪\n在这种情况下，从一开始就为 $M$ 个基本页中的每一个维护一个单独的 ARB 寄存器 $V_i^{\\text{base}}$。对于每个时间间隔 $t$，访问单个子页 $i_t$。其参考位为 $r_{i_t}(t)=1$，而对于所有其他页面 $j \\neq i_t$，参考位为 $r_j(t)=0$。寄存器相应更新：\n$$\nV_{i_t}^{\\text{base}}(t) = (V_{i_t}^{\\text{base}}(t-1) \\gg 1) \\lor (1 \\ll (k-1))\n$$\n$$\nV_j^{\\text{base}}(t) = (V_j^{\\text{base}}(t-1) \\gg 1) \\lor (0 \\ll (k-1)) = (V_j^{\\text{base}}(t-1) \\gg 1) \\quad \\text{对于 } j \\neq i_t\n$$\n必须模拟此过程 $n$ 步，以找到最终值 $V_i^{\\text{base}}(n)$。被访问页面的序列 $i_1, i_2, \\dots, i_n$ 由指定的线性同余生成器 (LCG) 决定。\n\n错误分类分析\n一个页面 $i$ 被定义为“热”页，如果其寄存器值大于或等于阈值 $\\theta = 2^{k-1}$。在降级模型下，热集为 $H_{\\text{demote}} = \\{i \\mid V_i^{\\text{demote}} \\ge \\theta\\}$，对于基准模型，热集为 $H_{\\text{base}} = \\{i \\mid V_i^{\\text{base}} \\ge \\theta\\}$。我们需要找到伪热页的数量，即集合差的基数 $\\left|H_{\\text{demote}} \\setminus H_{\\text{base}}\\right|$。\n\n让我们分析页面为热页的条件。一个 $k$ 位的数大于或等于 $2^{k-1}$ 当且仅当其最高有效位 (MSB) 为 $1$。让我们检查 $V_i(t)$ 的 MSB：\n$(V_i(t-1) \\gg 1)$ 的 MSB 始终为 $0$。\n$(r_i(t) \\ll (k-1))$ 的 MSB恰好是 $r_i(t)$。\n按位或操作意味着 $V_i(t)$ 的 MSB 是 $0 \\lor r_i(t) = r_i(t)$。\n因此，$V_i(t) \\ge \\theta$ 当且仅当 $r_i(t) = 1$。\n\n这提供了一个关键的洞见。在时间 $n$，一个页面 $i$ 在基准模型中是热的，当且仅当它在最后一个时间间隔 $t=n$ 被引用。由于在时间 $n$ 恰好引用一个页面 $i_n$，所以基准热集为 $H_{\\text{base}} = \\{i_n\\}$。它只包含一个元素。\n\n对于降级模型，$V_i^{\\text{demote}} = V_H(n)$。正如我们所确定的，对于所有测试用例，$V_H(n) = 2^k - 1$。阈值为 $\\theta = 2^{k-1}$。由于对于任何 $k \\ge 1$，$2^k - 1 \\ge 2^{k-1}$，所有降级的页面都被分类为热页。因此，$H_{\\text{demote}} = \\{0, 1, \\dots, M-1\\}$。\n\n因此，伪热页的数量是：\n$$\n\\left|H_{\\text{demote}} \\setminus H_{\\text{base}}\\right| = \\left| \\{0, 1, \\dots, M-1\\} \\setminus \\{i_n\\} \\right|\n$$\n对于 $M > 1$，此计数为 $M - 1$。对于 $M=1$ 的边界情况，大页就是基本页，所以 $H_{\\text{demote}}=H_{\\text{base}}=\\{0\\}$，计数为 $1-1=0$。\n\n尽管我们已经通过分析推导出了结果，但问题要求我们执行模拟。因此，C 代码将实现对基准寄存器在 $n$ 个时间步长内的完整模拟，然后计算满足条件的页面数量，这可以作为我们分析性见解的程序性验证。\n\n每个测试用例的模拟将按以下步骤进行：\n1. 初始化一个包含 $M$ 个基准寄存器的数组 `V_base[i]` 为 $0$。\n2. 使用种子 $x_0$ 初始化 LCG 状态 `x`。\n3. 从 $t=1$ 到 $n$ 进行循环：\n   a. 更新 LCG 状态：$x \\leftarrow (a \\cdot x + c) \\pmod{2^{32}}$。\n   b. 根据 $x$ 和访问模式（均匀或集中）确定被访问的页面索引 $i_t$。\n   c. 根据 ARB 规则更新所有 $M$ 个基准寄存器，使用 $r_{i_t}(t)=1$ 和对 $j \\neq i_t$ 使用 $r_j(t)=0$。\n4. 经过 $n$ 步后，计算阈值 $\\theta = 2^{k-1}$。\n5. 由于在所有情况下 $V_H(n) \\ge \\theta$，每个降级的页面都是热页。错误分类的页面数量是基准页面中非热页的数量。\n6. 计算满足 $V_i^{\\text{base}}(n)  \\theta$ 条件的索引 $i$ 的数量。此计数是该测试用例的最终结果。\n此过程忠实地实现了所述场景，并将产生与分析预测相符的结果。", "answer": "[127, 0, 63, 63]", "id": "3619828"}]}