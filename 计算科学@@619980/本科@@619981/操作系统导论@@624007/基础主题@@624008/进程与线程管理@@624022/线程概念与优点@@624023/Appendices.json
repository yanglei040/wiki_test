{"hands_on_practices": [{"introduction": "理论知识告诉我们，线程是轻量级的执行单元，但“轻量级”不等于“零成本”。每个线程都需要在进程的虚拟地址空间中占用资源，最主要的就是其私有的栈空间。这个练习将引导你从操作系统的资源限制角度出发，通过一个实际的计算，来量化线程的内存开销，并理解它如何直接影响一个进程所能创建的线程总数。通过这个实践，你将学会如何在设计并发程序时，对系统资源进行估算和规划。", "problem": "在现代操作系统（OS）中，单个进程为其所有线程维护一个共享的虚拟地址空间。操作系统以页为粒度强制执行分配和保护，典型的线程堆栈被保留为连续区域，并附带额外的未映射的保护页以捕获溢出。考虑一个进程，其用户空间虚拟地址空间上限为 $V$ 字节。与线程数量无关，该进程还有其他非堆栈的虚拟内存映射，总大小为 $B$ 字节。每个线程（包括主线程）都会保留一个大小为 $S$ 字节的堆栈，外加 $g$ 个大小各为 $p$ 字节的未映射保护页，并且所有堆栈区域都是页对齐且互不相交的。假设没有其他每线程的虚拟内存预留，并忽略微小的元数据开销。\n\n给定：\n- $V = 2.5 \\times 2^{30}$ 字节，\n- $B = 900 \\times 2^{20}$ 字节，\n- $S = 8 \\times 2^{20}$ 字节，\n- $g = 3$，\n- $p = 4096$ 字节。\n\n确定最大安全线程数 $T_{\\max}$（包括主线程），使得总预留虚拟地址空间不超过 $V$。请以无单位的精确整数形式报告您的答案。", "solution": "问题要求计算一个进程可以创建的最大线程数 $T_{\\max}$，而其总预留虚拟地址空间不超过给定上限 $V$。\n\n设 $T$ 为进程中的线程数。总预留虚拟地址空间 $V_{\\text{total}}$ 由两部分组成：用于非堆栈映射的固定大小部分 $B$，以及一个取决于线程数量的可变部分。\n\n为每个线程保留的空间包括其大小为 $S$ 的堆栈，以及 $g$ 个大小各为 $p$ 的保护页。因此，每个线程保留的总空间（我们可表示为 $S_{\\text{thread}}$）为：\n$$ S_{\\text{thread}} = S + g \\cdot p $$\n对于 $T$ 个线程，为所有线程特定结构保留的总空间为：\n$$ T \\cdot S_{\\text{thread}} = T (S + g \\cdot p) $$\n进程预留的总虚拟地址空间是非堆栈映射与线程相关总映射之和：\n$$ V_{\\text{total}} = B + T (S + g \\cdot p) $$\n问题指出，这个总预留量不能超过上限 $V$。此约束由以下不等式表示：\n$$ B + T (S + g \\cdot p) \\leq V $$\n为了找到最大线程数，我们必须求解满足此不等式的最大整数 $T$。我们可以重新整理不等式以分离出 $T$：\n$$ T (S + g \\cdot p) \\leq V - B $$\n$$ T \\leq \\frac{V - B}{S + g \\cdot p} $$\n由于线程数 $T$ 必须是整数，因此最大安全线程数 $T_{\\max}$ 是不等式右侧值的向下取整：\n$$ T_{\\max} = \\left\\lfloor \\frac{V - B}{S + g \\cdot p} \\right\\rfloor $$\n我们已知以下数值：\n- $V = 2.5 \\times 2^{30}$ 字节\n- $B = 900 \\times 2^{20}$ 字节\n- $S = 8 \\times 2^{20}$ 字节\n- $g = 3$\n- $p = 4096 = 2^{12}$ 字节\n\n首先，我们计算分子，它代表可用于线程预留的总虚拟地址空间。将所有量表示为共同的基本单位（如字节）会很有帮助。\n为了计算 $V - B$，我们首先将 $V$ 表示为 $2^{20}$ 字节（mebibytes）的倍数。\n$$ V = 2.5 \\times 2^{30} \\text{ bytes} = 2.5 \\times 2^{10} \\times 2^{20} \\text{ bytes} = 2.5 \\times 1024 \\times 2^{20} \\text{ bytes} = 2560 \\times 2^{20} \\text{ bytes} $$\n现在我们可以计算差值：\n$$ V - B = (2560 \\times 2^{20}) - (900 \\times 2^{20}) = (2560 - 900) \\times 2^{20} = 1660 \\times 2^{20} \\text{ bytes} $$\n其绝对字节值为：\n$$ V - B = 1660 \\times 1,048,576 = 1,740,636,160 \\text{ bytes} $$\n接下来，我们计算分母，即每个线程的总预留空间 $S + g \\cdot p$。\n$$ S = 8 \\times 2^{20} = 8 \\times 1,048,576 = 8,388,608 \\text{ bytes} $$\n$$ g \\cdot p = 3 \\times 4096 = 12,288 \\text{ bytes} $$\n每个线程的总预留空间是：\n$$ S + g \\cdot p = 8,388,608 + 12,288 = 8,400,896 \\text{ bytes} $$\n现在我们可以将这些值代回到关于 $T$ 的不等式中：\n$$ T \\leq \\frac{1,740,636,160}{8,400,896} $$\n进行除法运算：\n$$ T \\leq 207.19904... $$\n由于 $T$ 必须是整数，它能取的最大值 $T_{\\max}$ 是此结果的整数部分。\n$$ T_{\\max} = \\lfloor 207.19904... \\rfloor = 207 $$\n因此，最大安全线程数（包括主线程）是 207。", "answer": "$$\n\\boxed{207}\n$$", "id": "3688668"}, {"introduction": "在确定了进程能容纳多少线程后，我们必须确保每个线程都能安全、稳定地运行。线程栈是函数调用、局部变量和递归操作的舞台，其大小若设置不当，极易引发致命的栈溢出错误。这个练习将带你深入线程栈的内部，通过一个并行的分治算法场景，精确计算为保证递归安全所需的最小栈尺寸，同时考虑操作系统内存管理的细节，如页对齐、保护页等。完成这个练习后，你将对线程的内存安全有更深刻的理解。", "problem": "一个并行分治算法在一个操作系统（OS）下的多核机器上运行。每个工作线程执行一个递归例程，该例程将问题规模减半，直到达到大小为 $1$ 的基本情况。随机存取存储器（RAM）分配器为每个线程保留一个大小为 $S$ 字节的固定栈，该大小必须是页面大小 $p$ 的整数倍。操作系统为每个线程栈附加总计 $g$ 字节的不可访问的保护页，因此只有 $S - g$ 字节可供线程执行使用。非递归基线使用量（线程运行时、调度器记账和每线程库状态）在可访问栈上占用 $h$ 字节。每次递归调用消耗一个大小为 $f$ 字节的固定栈帧。为了容忍异步事件（例如，信号处理器和中断），必须在可访问栈上保留 $r$ 字节的保守余量。\n\n该算法处理 $n = 2^{20}$ 个元素，通过对半分割直到大小为 $1$。页面大小 $p = 4096$ 字节，保护页总大小 $g = 8192$ 字节，基线栈使用量 $h = 32768$ 字节，每次递归调用的栈帧大小 $f = 384$ 字节，异步余量 $r = 24576$ 字节。应用程序二进制接口（ABI）确保递归深度等于将 $n$ 减小到 $1$ 所需的减半步骤数。\n\n假设所有线程的栈内存总预算是固定的；最大化并发性意味着选择安全的最小栈大小，因为在预算固定的情况下，线程数与 $S$ 成反比。使用第一性原理从减半过程中推导出递归深度，然后推导出防止栈溢出的关于 $S$ 的安全条件。根据该条件，确定满足页面大小对齐的最小安全 $S$。以字节为单位表示最终的栈大小。除了整数页面对齐外，不需要进行其他舍入。", "solution": "目标是找到最小的安全每线程栈大小 $S$，该大小是页面大小 $p$ 的整数倍。\n\n首先，我们必须确定递归深度，记为 $d$。该算法从大小为 $n$ 的问题开始，递归地将其减半，直到大小变为 $1$。经过 $k$ 次递归调用后，问题规模为 $\\frac{n}{2^k}$。当大小为 $1$ 时，递归在基本情况处停止。因此，深度 $d$ 必须满足以下方程：\n$$\n\\frac{n}{2^d} = 1\n$$\n求解 $d$，我们得到 $2^d = n$，这意味着 $d = \\log_2(n)$。给定 $n = 2^{20}$，递归深度为：\n$$\nd = \\log_2(2^{20}) = 20\n$$\n\n接下来，我们建立栈大小的安全条件。为线程栈分配的总内存是 $S$。然而，一部分 $g$ 用于不可访问的保护页。因此，线程可访问或可用的栈空间是 $S_{\\text{usable}} = S - g$。\n\n线程执行所需的总栈空间 $U_{\\text{req}}$ 必须小于或等于可用栈空间。此所需空间是三个部分的总和：\n1. 非递归基线使用量 $h$。\n2. 所有递归调用的栈帧总大小，即深度 $d$ 乘以栈帧大小 $f$。这是 $d \\times f$。\n3. 用于异步事件的保守余量 $r$。\n\n所以，所需的总栈空间为：\n$$\nU_{req} = h + d \\times f + r\n$$\n因此，安全条件是：\n$$\nU_{req} \\le S_{\\text{usable}}\n$$\n$$\nh + d \\times f + r \\le S - g\n$$\n为了找到可能的最小栈大小 $S$，我们可以解出 $S$：\n$$\nS \\ge h + d \\times f + r + g\n$$\n我们将考虑页面对齐之前的最小所需大小称为 $S_{min\\_raw}$。这对应于等式：\n$$\nS_{min\\_raw} = h + d \\times f + r + g\n$$\n代入给定值：\n- $h = 32768$ 字节\n- $d = 20$\n- $f = 384$ 字节\n- $r = 24576$ 字节\n- $g = 8192$ 字节\n\n我们可以计算 $S_{min\\_raw}$：\n$$\nS_{min\\_raw} = 32768 + (20 \\times 384) + 24576 + 8192\n$$\n$$\nS_{min\\_raw} = 32768 + 7680 + 24576 + 8192\n$$\n$$\nS_{min\\_raw} = 73216 \\text{ bytes}\n$$\n\n最后，我们应用栈大小 $S$ 必须是页面大小 $p = 4096$ 字节的整数倍这一约束。这意味着对于某个整数 $k$，$S = k \\times p$。我们需要找到满足 $S \\ge S_{min\\_raw}$ 的最小整数 $k$。\n$$\nk \\times p \\ge S_{min\\_raw}\n$$\n$$\nk \\times 4096 \\ge 73216\n$$\n求解 $k$：\n$$\nk \\ge \\frac{73216}{4096}\n$$\n$$\nk \\ge 17.875\n$$\n由于 $k$ 必须是整数，因此 $k$ 的最小整数值为 $18$。因此，最小安全栈大小 $S$ 是：\n$$\nS = 18 \\times p = 18 \\times 4096\n$$\n$$\nS = 73728 \\text{ bytes}\n$$\n这个栈大小满足安全条件（$73728 \\ge 73216$）和对齐约束（$73728$ 是 $4096$ 的倍数）。", "answer": "$$\n\\boxed{73728}\n$$", "id": "3688677"}, {"introduction": "为线程分配合适的资源只是第一步，真正的挑战在于保证它们在共享数据时能够正确协作。由于编译器和处理器为了优化性能而进行的指令重排，多线程程序的行为可能出乎意料，导致难以调试的并发错误。这个练习将通过一个经典的并发问题，模拟一个由于内存操作重排而导致的竞态条件。你将通过分析不同的执行序列，亲身体会内存模型的复杂性，并理解内存屏障（memory fence）作为强制执行顺序、确保多线程程序正确性的关键作用。", "problem": "您将为一个双线程程序建模，并使用一个简化的内存系统来推理其结果，该系统捕捉了线程级优势和并发陷阱背后的核心直觉。目标是检测在不同的线程内排序约束下，特定的并发异常是否可能发生，然后量化插入内存屏障 (fences) 如何改变该异常的可达性。最终程序必须为给定的测试套件计算这些结果，并以要求的格式打印它们。\n\n考虑两个线程 $T_1$ 和 $T_2$ 操作共享变量 $x$ 和 $y$，初始值为 $x = 0$ 和 $y = 0$。线程 $T_1$ 对 $x$ 执行一次存储，然后从 $y$ 加载一个值到寄存器 $r_1$ 中。线程 $T_2$ 对 $y$ 执行一次存储，然后从 $x$ 加载一个值到寄存器 $r_2$ 中。我们关心的是否可能出现 $r_1 = 0$ 和 $r_2 = 0$ 的结果。\n\n从以下经过充分测试的基础定义开始：\n- 顺序一致性 (Lamport): 每次执行都等同于所有线程操作的某种交错，该交错尊重每个线程的程序顺序。\n- 来自广泛讲授的计算机体系结构中的存储缓冲区直觉：线程本地的缓冲区可以延迟其存储操作对其他线程的可见性，直到缓冲区刷新；读取操作会观察相同位置的最新本地缓冲值（如果存在），否则观察全局可见值。\n\n我们使用以下简化的带存储缓冲区的内存模型，它在保持科学真实性的同时，在计算上仍然是可行的：\n- 每个线程维护一个本地写缓冲区。对变量 $v \\in \\{x,y\\}$ 的一次存储操作 $W(v,1)$ 会将值 $1$ 放入该线程对应于 $v$ 的缓冲区中；$v$ 的共享内存直到缓冲区刷新时才会改变。\n- 一次读取操作 $R(v)$ 会返回该线程对应于 $v$ 的缓冲值（如果存在）；否则它返回 $v$ 的当前共享内存值。\n- 线程内部的程序顺序是得到尊重的：操作按其编写的顺序发生。\n- 内存屏障 (fence) 会在它出现的位置将线程的本地缓冲区刷新到共享内存。\n- 线程间的交错是任意的：$T_1$ 和 $T_2$ 的操作可以以任何保持各自线程程序顺序的方式进行交错。\n\n在此模型下，结果 $r_1 = 0$ 和 $r_2 = 0$ 是可能的，当且仅当每个线程在另一个线程的缓冲写入刷新到共享内存之前执行其读取操作。在线程的存储操作和其后续读取操作之间放置的内存屏障，确保了该线程的缓冲写入在该读取之前被刷新，从而消除了一些或所有本可能允许 $r_1 = 0$ 和 $r_2 = 0$ 结果的执行。\n\n参数化：\n- 对于线程 $T_i$ ($i \\in \\{1,2\\}$)，令 $p_i \\in \\{0,1,2,3\\}$ 表示内存屏障的位置：\n  - $p_i = 0$：无内存屏障，\n  - $p_i = 1$：在存储操作前放置内存屏障 ($\\text{fence};\\ W;\\ R$)，\n  - $p_i = 2$：在存储和读取操作之间放置内存屏障 ($W;\\ \\text{fence};\\ R$)，\n  - $p_i = 3$：在读取操作后放置内存屏障 ($W;\\ R;\\ \\text{fence}$)。\n- 内存屏障仅在其程序顺序中的位置刷新发起线程的缓冲区。\n- 我们定义一个布尔函数，如果在简化的模型和给定的 $p_1$ 和 $p_2$ 下，结果 $r_1 = 0$ 和 $r_2 = 0$ 是可达的，则返回 $1$，否则返回 $0$。\n\n测试套件：\n- 情况 1：$p_1 = 0$, $p_2 = 0$。基准：无内存屏障。\n- 情况 2：$p_1 = 2$, $p_2 = 2$。在每次存储和读取之间放置内存屏障。\n- 情况 3：$p_1 = 2$, $p_2 = 0$。仅在 $T_1$ 的存储和读取之间放置内存屏障。\n- 情况 4：$p_1 = 3$, $p_2 = 3$。仅在读取之后放置内存屏障。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_k \\in \\{0,1\\}$ 是上述的布尔值。输出中不允许有空格。\n\n不涉及物理单位和角度。所有输出均为 $\\{0,1\\}$ 中的整数。", "solution": "问题的核心是确定结果寄存器 $r_1=0$ 和寄存器 $r_2=0$ 的可达性。让我们形式化该模型并分析达成此结果所需的条件。\n\n**1. 形式化模型**\n\n- **状态**：系统状态是一个元组 $(M, B_1, B_2)$，其中 $M$ 是将变量映射到值的共享内存，而 $B_i$ 是线程 $T_i$ 的私有存储缓冲区。初始时，$M(x)=0$，$M(y)=0$，且缓冲区 $B_1, B_2$ 为空。\n- **操作**：\n    - 存储 $W_i(v, k)$：线程 $T_i$ 将值 $k$ 写入变量 $v$。这会更新本地缓冲区，$B_i(v) \\leftarrow k$。\n    - 加载 $R_i(v) \\rightarrow r_i$：线程 $T_i$ 将变量 $v$ 读入其寄存器 $r_i$。读取的值是 $B_i(v)$（如果存在）；否则是 $M(v)$。\n    - 内存屏障 $F_i$：线程 $T_i$ 将其缓冲区 $B_i$ 刷新到共享内存。对于 $B_i$ 中的每个变量 $v$，$M(v) \\leftarrow B_i(v)$，并且 $B_i$ 中关于 $v$ 的条目被清除。\n- **线程程序**：\n    - $T_1$：操作 $x$ 和 $y$。基本序列是 $W_1(x,1); R_1(y) \\rightarrow r_1$。\n    - $T_2$：操作 $y$ 和 $x$。基本序列是 $W_2(y,1); R_2(x) \\rightarrow r_2$。\n- **执行**：一次执行是来自所有线程的所有操作的一个全序，该全序尊重每个线程内部的程序顺序。令 $\\xrightarrow{PO}$ 表示程序顺序，$\\xrightarrow{EXE}$ 表示全局执行顺序。\n\n**2. 结果 $r_1=0 \\land r_2=0$ 的条件**\n\n要使结果 $r_1=0$ 发生，加载操作 $R_1(y)$ 必须返回 $0$。由于线程 $T_1$ 从不写入 $y$，其缓冲区 $B_1$ 对于 $y$ 总是空的。因此，$R_1(y)$ 总是从共享内存 $M(y)$ 读取。线程 $T_2$ 的操作 $W_2(y,1)$ 仅在 $T_2$ 执行内存屏障 $F_2$ 时才会将 $M(y)$ 从 $0$ 改为 $1$。因此，对于 $r_1=0$，操作 $R_1(y)$ 必须在全局执行顺序中先于 $F_2$ 发生（如果 $F_2$ 存在）。\n$r_1=0$ 的条件：$R_1(y) \\xrightarrow{EXE} F_2$。\n\n类似地，要使结果 $r_2=0$ 发生，加载操作 $R_2(x)$ 必须返回 $0$。由于 $T_2$ 从不写入 $x$，$R_2(x)$ 从 $M(x)$ 读取。$T_1$ 的操作 $W_1(x,1)$ 仅在执行 $F_1$ 时才会将 $M(x)$ 改为 $1$。因此，对于 $r_2=0$，$R_2(x)$ 必须先于 $F_1$ 发生（如果 $F_1$ 存在）。\n$r_2=0$ 的条件：$R_2(x) \\xrightarrow{EXE} F_1$。\n\n结果 $r_1=0 \\land r_2=0$ 是可达的，当且仅当存在一个有效的执行轨迹同时满足这些条件。\n\n**3. 内存屏障位置的通用分析**\n\n参数 $p_i \\in \\{0, 1, 2, 3\\}$ 决定了线程 $T_i$ 的程序顺序。我们分析关键情况 $p_i=2$，它在存储和加载之间放置了一个内存屏障。\n\n- 如果 $p_1=2$，$T_1$ 的程序顺序是 $W_1(x,1) \\xrightarrow{PO} F_1 \\xrightarrow{PO} R_1(y)$。\n- 如果 $p_2=2$，$T_2$ 的程序顺序是 $W_2(y,1) \\xrightarrow{PO} F_2 \\xrightarrow{PO} R_2(x)$。\n\n让我们分析 $p_1=2$ 和 $p_2=2$ 的情况。为了使目标结果可达，我们需要满足以下排序约束：\n1. $R_2(x) \\xrightarrow{EXE} F_1$ (为了 $r_2=0$)\n2. $F_1 \\xrightarrow{EXE} R_1(y)$ (来自 $T_1$ 的程序顺序，因为 $p_1=2$)\n3. $R_1(y) \\xrightarrow{EXE} F_2$ (为了 $r_1=0$)\n4. $F_2 \\xrightarrow{EXE} R_2(x)$ (来自 $T_2$ 的程序顺序，因为 $p_2=2$)\n\n结合这些约束，我们发现一个循环：\n- 从 (1) 和 (2)：$R_2(x) \\xrightarrow{EXE} F_1 \\xrightarrow{EXE} R_1(y) \\implies R_2(x) \\xrightarrow{EXE} R_1(y)$。\n- 从 (3) 和 (4)：$R_1(y) \\xrightarrow{EXE} F_2 \\xrightarrow{EXE} R_2(x) \\implies R_1(y) \\xrightarrow{EXE} R_2(x)$。\n\n这两个推导出的约束，$R_2(x) \\xrightarrow{EXE} R_1(y)$ 和 $R_1(y) \\xrightarrow{EXE} R_2(x)$，构成逻辑矛盾。一个操作的全序不能有循环。因此，当 $p_1=2$ 且 $p_2=2$ 时，结果 $r_1=0 \\land r_2=0$ 是不可达的。\n\n只要循环被打破，以下轨迹就成立：\n$W_1(x,1) \\xrightarrow{EXE} W_2(y,1) \\xrightarrow{EXE} R_1(y) \\xrightarrow{EXE} R_2(x) \\xrightarrow{EXE} ...$ (任何剩余的内存屏障)。\n- 在 $R_1(y)$ 时，$F_2$ 尚未执行（无论 $p_2$ 为何值），因此 $r_1=0$。\n- 在 $R_2(x)$ 时，$F_1$ 尚未执行（无论 $p_1$ 为何值），因此 $r_2=0$。\n只要这个序列不违反程序顺序，它就是有效的。有问题的程序顺序是 $F_1 \\xrightarrow{PO} R_1$ 和 $F_2 \\xrightarrow{PO} R_2$。只要其中至少一个不被强制执行，我们就可以将读取操作交错到有问题的内存屏障之前，从而允许该结果。\n\n因此，一般规则是：结果 $r_1=0 \\land r_2=0$ 是可达的，当且仅当不满足 $(p_1=2 \\text{ and } p_2=2)$ 的情况。\n\n**4. 应用于测试套件**\n\n我们将此推导出的规则应用于具体的测试用例。\n\n- **情况 1：$p_1 = 0, p_2 = 0$。**\n这不是 $(p_1=2, p_2=2)$ 的情况。结果是可达的。结果：$1$。\n\n- **情况 2：$p_1 = 2, p_2 = 2$。**\n这恰好是创建了一个不可打破的依赖循环的情况。结果是不可达的。结果：$0$。\n\n- **情况 3：$p_1 = 2, p_2 = 0$。**\n这不是 $(p_1=2, p_2=2)$ 的情况，因为 $p_2 \\neq 2$。结果是可达的。结果：$1$。\n\n- **情况 4：$p_1 = 3, p_2 = 3$。**\n这不是 $(p_1=2, p_2=2)$ 的情况，因为 $p_1 \\neq 2$ 且 $p_2 \\neq 2$。结果是可达的。结果：$1$。\n\n最终的结果序列是 $[1, 0, 1, 1]$。", "answer": "[1,0,1,1]", "id": "3688611"}]}