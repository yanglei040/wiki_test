{"hands_on_practices": [{"introduction": "要真正理解管道，一个有效的方法是亲手模拟它们的行为。本练习旨在引导您实现管道的两个核心特性：数据是短暂的（读取是破坏性的）以及数据流是不可寻址的。通过构建这个模拟程序，您将对管道如何管理数据流以及为何它们与常规文件有本质区别有一个具体而深入的理解。[@problem_id:3669825]", "problem": "要求您编写一个完整的程序，该程序模拟匿名管道作为字节流通道的行为，并具备操作系统教科书中确立的两个基本特性：(i) 读取是破坏性的，会消耗流；(ii) 流是不可寻址的，因为它没有可寻址的位置。请基于以下基础进行构建：匿名管道是一个不支持随机访问的先进先出（FIFO）字节流，对于没有稳定后备存储的流，任何重新定位读取偏移量（例如，通过寻道操作）的尝试根据定义都是无效的。\n\n您的程序必须仅使用内存数据结构和标准输入/输出（I/O）文件函数来模拟匿名管道。该模拟必须捕获上述两个特性，并支持一个审计机制，该机制通过将流经模拟读取的字节复制到一个文件中来模仿“tee”操作的行为。除了标准 C 库文件 I/O 之外，不允许使用任何操作系统调用。设计约束如下：\n\n1. 模拟管道是一个容量为 $C$ 的字节流，其中 $C$ 是您选择的任意固定有限整数（为使程序具体化，您可以取 $C = 64$）。您必须存储当前未读内容和一个读取指针。读取 $k$ 字节将返回 $\\min(k, r)$ 字节，其中 $r$ 是未读字节数，并按实际返回的字节数前移读取指针。这模拟了数据的破坏性、短暂消耗。\n2. 任何“寻道”管道的尝试，即通过任意偏移量 $o \\in \\mathbb{Z}$ 更改读取指针，都必须通过返回错误码 $-1$ 来拒绝。这体现了不可寻道特性。\n3. 带审计的读取操作必须使用标准文件 I/O 将读取操作返回的完全相同的字节写入审计文件。这模拟了用于审计的“tee”操作，确保字节在从流中消耗的同时被复制到持久存储中。\n\n您的程序必须构建并执行以下测试套件，并生成单行输出，其中包含所有结果，聚合为一个由方括号括起来的逗号分隔列表。所有输出都必须是整数。\n\n测试套件：\n- 测试 A (不可寻道语义)：用字节序列`hello`初始化模拟管道。尝试以偏移量 $0$ 进行寻道，如果结果等于 $-1$ 则返回 $1$，否则返回 $0$。这验证了寻道操作被拒绝。\n- 测试 B (短暂消耗)：用字节序列`ABCDE`初始化模拟管道。分别执行三次大小为 $2$、$3$ 和 $1$ 字节的读取，记录每次读取实际返回的字节数。正确的短暂消耗行为产生三元组 $\\langle 2, 3, 0 \\rangle$，因为前两次读取后流已耗尽。\n- 测试 C (通过 tee 进行审计)：用长度为 $22$ 的字节序列`os-pipes-are-ephemeral`初始化模拟管道。执行一次带审计的读取操作，请求 $1000$ 字节（大于可用字节数），以便该操作返回所有可用字节，并将相同的字节写入审计文件。读取完成后，从审计文件内容中计算两个整数：文件的字节长度 $L$ 和字节总和 $S = \\sum_{i=1}^{L} b_i$，其中 $b_i$ 是第 $i$ 个字节的无符号值。对于所提供的确切字符串，$L = 22$ 且 $S = 2165$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按以下顺序排列的结果，格式为由方括号括起来的逗号分隔列表：\n1. 测试 A 的结果（整数 $0$ 或 $1$），\n2. 测试 B 的第一次读取大小（整数），\n3. 测试 B 的第二次读取大小（整数），\n4. 测试 B 的第三次读取大小（整数），\n5. 测试 C 的文件长度 $L$（整数），\n6. 测试 C 的字节总和 $S$（整数）。\n\n具体来说，输出必须具有 `[resA,resB1,resB2,resB3,L,S]` 的确切形式，行内没有空格也没有其他文本。", "solution": "问题陈述已经过严格评估，并被确定为**有效**。它在科学上基于操作系统关于匿名管道的既定原则，问题阐述清晰，目标明确且可实现，并且没有歧义或矛盾。该问题为模拟字节流通道提供了正式规范，并提供了一个具体的测试套件来验证模拟的正确性。\n\n任务是模拟匿名管道，这是一种基本的进程间通信机制。该模型必须遵守两个定义性属性：(i) 读取是破坏性的，意味着数据在被读取后即从流中消耗掉；(ii) 流是不可寻址的，意味着没有机制可以任意重新定位读取指针。该模拟将使用 C 语言，通过内存数据结构和标准文件 I/O 函数来实现。\n\n一个合适的表示模拟管道的数据结构是 C `struct`。这个结构将封装管道的状态：一个固定大小的缓冲区用于存放字节流，一个变量用于跟踪最初写入管道的总字节数，以及一个读取指针用于跟踪消耗情况。\n\n我们将该结构定义为 `SimulatedPipe`：\n- `char data[C]`：一个固定容量为 $C$ 的字符数组。根据建议，我们将使用 $C=64$ 字节。该数组存储字节流。\n- `int content_length`：一个整数，表示管道内部缓冲区当前持有的字节数。\n- `int read_offset`：一个整数，表示读取头的当前位置。此偏移量跟踪从流的开始处已消耗了多少字节。\n\n管道的行为由对该结构的一组操作定义。\n\n1.  **初始化 (`pipe_init`)**：此函数准备管道以供使用。它接受一个指向 `SimulatedPipe` 结构的指针和初始数据字符串。它将数据复制到管道的缓冲区中，将 `content_length` 设置为输入数据的长度（最多为容量 $C$），并将 `read_offset` 初始化为 $0$，表示尚未消耗任何数据。\n\n2.  **寻道 (`pipe_seek`)**：此函数模拟管道的不可寻道特性。问题规定，任何尝试以偏移量 $o \\in \\mathbb{Z}$ 进行寻道的行为都必须被拒绝。因此，此函数将忽略其输入参数，并无条件返回错误码 $-1$，从而正确模拟真实的 `lseek()` 系统调用在管道文件描述符上会返回的 `ESPIPE` 错误（`Illegal seek`）。\n\n3.  **读取 (`pipe_read`)**：此函数模拟破坏性读取操作。它接受要读取的请求字节数 $k$。\n    - 首先，它计算流中剩余的未读字节数 $r$。这由 $r = \\text{content\\_length} - \\text{read\\_offset}$ 给出。\n    - 实际可以返回的字节数是请求量和可用量中的最小值：$\\min(k, r)$。我们称之为 `bytes_to_return`。\n    - 从内部缓冲区当前 `read_offset` 位置开始，将 `bytes_to_return` 个字节复制到调用者提供的输出缓冲区。\n    - 然后 `read_offset` 增加 `bytes_to_return`。这是模拟读取“破坏性”或“短暂性”的关键步骤：数据现在被视为已消耗，不再可用于后续读取。\n    - 函数返回 `bytes_to_return`。如果没有可用字节（$r \\le 0$），则返回 $0$。\n\n4.  **带审计的读取 (`pipe_read_with_audit`)**：此操作模拟“tee”工具，其中流经管道的数据被复制到次要目的地，在本例中是一个审计文件。\n    - 它在内部调用 `pipe_read` 来执行读取操作。捕获实际读取的字节数，我们称之为 `bytes_read`。\n    - 然后使用标准文件 I/O 函数（`fopen`、`fwrite`、`fclose`）将这些已复制到调用者输出缓冲区的 `bytes_read` 个字节写入指定的审计文件。这确保审计日志包含该操作期间从管道消耗的数据的精确副本。\n\n现在可以使用这些函数执行指定的测试套件。\n\n- **测试 A (不可寻道语义)**：用字节序列 \"hello\" 初始化管道。调用 `pipe_seek` 并设置偏移量为 $0$。按照设计，函数返回 $-1$。测试结果为 $1$，证实了不可寻道属性的正确实现。\n\n- **测试 B (短暂消耗)**：用 \"ABCDE\" 初始化管道，因此 `content_length` 为 $5$。\n    1.  请求读取 $k=2$ 字节。可用字节数为 $r = 5 - 0 = 5$。操作返回 $\\min(2, 5) = 2$ 字节 (\"AB\")。`read_offset` 变为 $2$。第一个结果是 $2$。\n    2.  请求读取 $k=3$ 字节。此时可用字节数为 $r = 5 - 2 = 3$。操作返回 $\\min(3, 3) = 3$ 字节 (\"CDE\")。`read_offset` 变为 $2 + 3 = 5$。第二个结果是 $3$。\n    3.  请求读取 $k=1$ 字节。可用字节数为 $r = 5 - 5 = 0$。操作返回 $\\min(1, 0) = 0$ 字节。`read_offset` 保持为 $5$。第三个结果是 $0$。\n    最终读取大小的序列为 $\\langle 2, 3, 0 \\rangle$，展示了正确的短暂消耗行为。\n\n- **测试 C (通过 tee 进行审计)**：用长度为 $22$ 的字符串 \"os-pipes-are-ephemeral\" 初始化管道。\n    - 执行一次 `pipe_read_with_audit` 操作，请求 $k=1000$ 字节。\n    - 可用字节数为 $r = 22 - 0 = 22$。读取操作返回 $\\min(1000, 22) = 22$ 字节。整个字符串被消耗。\n    - 这 $22$ 个字节被写入一个审计文件。\n    - 为了验证审计，以读取模式打开文件。确定其长度 $L$（例如，使用 `fseek` 到文件末尾和 `ftell`），该长度将为 $22$。\n    - 然后逐字节读取文件，并将每个字节 $b_i$ 的无符号值累加到总和 $S$ 中。对于给定的字符串，此总和为 $S = \\sum_{i=1}^{22} b_i = 2165$。\n    此测试的结果为 $L=22$ 和 $S=2165$。\n\n最终的程序会将这些结果组合成指定的逗号分隔格式。", "answer": "```c\n// The complete and compilable C program.\n#include", "id": "3669825"}, {"introduction": "在实际应用中，管道中的进程可能会意外终止，从而导致通信中断。本练习探讨了向一个没有读取者的管道写入数据时的关键错误情景，重点关注 `SIGPIPE` 信号和 `EPIPE` 错误码。掌握如何处理这种情况对于编写能够优雅地处理“断开的管道”而不会意外崩溃的健壮程序至关重要。[@problem_id:3669766]", "problem": "一个单线程写入进程 $P_w$ 和一个读取进程 $P_r$ 通过一个由 `pipe(pipefd)` 创建的匿名管道进行通信，其中 `pipefd[0]` 是读取端，`pipefd[1]` 是写入端。按设计，$P_r$ 在 fork 后立即关闭 `pipefd[1]`，并且只从 `pipefd[0]` 读取。然而，在该场景中，$P_r$ 在执行任何读取操作之前提前退出，这导致其文件描述符被操作系统关闭，使得 $P_w$ 只有 `pipefd[1]` 保持打开，而管道上没有任何读取者。\n\n假设存在以下系统特性和广为接受的事实：\n- 在可移植操作系统接口 (POSIX) 标准下，对一个没有打开的读取端的管道调用 `write()` 会导致 `SIGPIPE` 信号被发送给调用进程；如果该信号被忽略或其处理程序返回，则 `write()` 调用会失败，返回值为 $-1$ 并将 `errno` 设置为 `EPIPE`。\n- `SIGPIPE` 的默认行为是终止进程。\n- 对于至少有一个读取者的管道，$PIPE\\_BUF$ 是一个系统定义的大小，任何大小 $\\le PIPE\\_BUF$ 的单次 `write()` 操作相对于其他写入者都是原子的。POSIX 要求 $PIPE\\_BUF \\ge 512$。对于本系统，设 $PIPE\\_BUF = 4096$ 字节，管道容量 $C = 65536$ 字节。\n- `write()` 系统调用遵循应用程序编程接口 (API) 约定：它返回成功写入的字节数（$\\ge 0$），或在出错时返回 $-1$，此时 `errno` 会指明错误类型。\n\n进程 $P_w$ 尝试向 $P_r$ 发送一个大小为 $N = 100000$ 字节的消息，它以大小为 $s = 8192$ 字节的数据块进行迭代，重复调用 `write(pipefd[1], buf + offset, s)` 直到所有字节被写入或发生错误。考虑 $P_w$ 配置的三种变体：\n1. `SIGPIPE` 使用其默认处置方式。\n2. 通过将 `SIGPIPE` 设置为忽略来抑制它。\n3. 通过安装一个立即返回的处理程序来抑制 `SIGPIPE`（处理程序内部没有 `longjmp` 或重试）。\n\n在此场景下，关于控制流和错误恢复的下列陈述中，哪些是正确的？选择所有适用的选项。\n\nA. 在 `SIGPIPE` 为默认处置方式的情况下，当 $P_w$ 对没有读取者的管道进行第一次 `write()` 操作时，内核会传递 `SIGPIPE` 信号，默认行为会终止 $P_w$，写入了 0 字节，并且 `write()` 调用不会返回到用户空间。\n\nB. 如果在 $P_w$ 中忽略 `SIGPIPE`，对没有读取者的管道的第一次 `write()` 操作将返回 $-1$ 且 `errno = EPIPE`，写入 0 字节，并且控制流在 `write()` 调用后继续，从而允许应用程序执行清理并决定恢复策略。\n\nC. 如果 $P_w$ 安装一个会返回的 `SIGPIPE` 处理程序，对没有读取者的管道的第一次 `write()` 操作将返回 $-1$ 且 `errno = EPIPE`，写入 0 字节，并且执行在 `write()` 调用后继续，从而可以在不终止进程的情况下进行恢复。\n\nD. 对于任何写入大小 $n \\le PIPE\\_BUF$，操作系统保证交付整个记录，即使不存在读取者也是如此，因此抑制 `SIGPIPE` 会允许数据被缓冲直到读取者出现，并且不会发生 `EPIPE`。\n\nE. 当 $N > C$ 且至少存在一个读取者时，`write()` 可能会传输部分字节数并返回一个小于 $N$ 的正值；然而，当没有读取者时，`write()` 传输 0 字节并报告 `EPIPE`，无论 $N$ 或 $s$ 的大小如何。", "solution": "问题陈述描述了一个常见的进程间通信（IPC）场景，涉及在一个遵循 POSIX 的系统上，写入进程 $P_w$ 和读取进程 $P_r$ 使用匿名管道。问题的核心在于读取进程 $P_r$ 的提前退出，它关闭了管道的读取端 `pipefd[0]`。这个行为使得写入进程 $P_w$ 拥有一个连接到没有活动读取者的管道的打开的写入端 `pipefd[1]`。\n\n### **问题验证**\n\n**步骤 1：提取已知条件**\n- **进程和管道：** 写入进程 $P_w$ 和读取进程 $P_r$ 通过一个由 `pipe(pipefd)` 创建的管道进行通信。`pipefd[0]` 是读取端，`pipefd[1]` 是写入端。\n- **场景：** $P_r$ 从 $P_w$ fork 出来，关闭 `pipefd[1]`，并计划从 `pipefd[0]` 读取。然而，$P_r$ 在读取前退出，导致其所有文件描述符（包括 `pipefd[0]`）被关闭。因此，该管道没有打开的读取端。\n- **系统行为 (POSIX)：**\n    - 对一个没有打开的读取端的管道执行 `write()` 会传递 `SIGPIPE` 信号。\n    - 如果 `SIGPIPE` 被忽略或由一个会返回的处理程序处理，则 `write()` 会失败，返回 $-1$ 并将 `errno` 设置为 `EPIPE`。\n    - `SIGPIPE` 的默认行为是终止进程。\n- **系统参数：**\n    - 原子写入的管道缓冲区大小：$PIPE\\_BUF = 4096$ 字节。\n    - 管道总容量：$C = 65536$ 字节。\n- **写入者的行为：** $P_w$ 尝试以大小为 $s = 8192$ 字节的数据块写入 $N = 100000$ 字节，使用 `write(pipefd[1], buf + offset, s)`。\n- **$P_w$ 的配置：**\n    1.  `SIGPIPE` 采用其默认处置方式。\n    2.  `SIGPIPE` 被忽略。\n    3.  为 `SIGPIPE` 安装了一个立即返回的处理程序。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据、提法明确且客观。它基于 POSIX 标准所定义的管道、系统调用和信号的标准、可验证的行为。该场景是一个经典的 IPC 错误条件，健壮的程序必须处理。前提在事实上是合理的，术语是精确的，并且设置是内部一致且完整的。不存在科学或逻辑上的缺陷。\n\n**步骤 3：结论和行动**\n问题陈述是**有效的**。开始解答。\n\n### **推导和选项分析**\n\n控制此场景的基本原则是：管道是至少一个写入者和至少一个读取者之间的单向通信通道。当管道的打开的读取描述符（`pipefd[0]`）数量降至零时，该管道被认为是“损坏的”。任何后续向此管道写入的尝试都是一个错误。内核通过发送 `SIGPIPE` 信号来通知写入进程此错误。进程对此信号的响应决定了最终结果。\n\n我们来分析一下为 $P_w$ 指定的三种配置：\n\n1.  **默认 `SIGPIPE` 处置方式：** `SIGPIPE` 的默认行为是终止进程。当 $P_w$ 执行其第一次 `write()` 调用时，内核检测到管道没有读取者，并向 $P_w$ 发送 `SIGPIPE` 信号。默认的信号处理程序被调用，它会立即终止该进程。结果是，`write()` 系统调用被中止，不会将控制权返回给用户空间代码。程序的执行被停止。\n\n2.  **忽略 `SIGPIPE`：** 如果进程已将 `SIGPIPE` 的处置方式设置为忽略（例如，通过 `signal(SIGPIPE, SIG_IGN)`），当调用 `write()` 时，内核仍然会检测到损坏的管道。它尝试传递 `SIGPIPE`，看到它应该被忽略，于是丢弃该信号。根据问题陈述和 POSIX 标准，`write()` 调用随后会平稳地失败，返回 $-1$ 并将全局变量 `errno` 设置为 `EPIPE`。控制权返回到 `write()` 调用之后的指令，允许应用程序检查返回值、`errno`，并执行错误处理或清理逻辑。\n\n3.  **处理 `SIGPIPE`：** 如果进程为 `SIGPIPE` 安装了一个仅作返回的自定义处理程序，那么关于 `write()` 调用失败的事件序列与忽略该信号的情况类似。当对损坏的管道调用 `write()` 时，内核发送 `SIGPIPE` 信号。进程的执行被中断，控制权转移到信号处理程序。处理程序执行并返回。在处理程序返回后，被中断的系统调用（`write()`）不会自动重启，因为底层的错误条件（损坏的管道）是持续存在的。该调用失败，返回 $-1$ 并将 `errno` 设置为 `EPIPE`。控制权在 `write()` 调用之后返回到用户空间代码，从而可以进行恢复。\n\n现在我们基于此分析来评估每个选项。\n\n**A. 在 `SIGPIPE` 为默认处置方式的情况下，当 $P_w$ 对没有读取者的管道进行第一次 `write()` 操作时，内核会传递 `SIGPIPE` 信号，默认行为会终止 $P_w$，写入了 0 字节，并且 `write()` 调用不会返回到用户空间。**\n这个陈述准确地描述了 `SIGPIPE` 采用默认处置方式（情况 1）的结果。内核发送 `SIGPIPE`，默认行为是终止，而这种终止会抢占系统调用的完成，这意味着它永远不会返回到用户程序。写入操作本身失败，因此传输了 0 字节。\n**结论：正确。**\n\n**B. 如果在 $P_w$ 中忽略 `SIGPIPE`，对没有读取者的管道的第一次 `write()` 操作将返回 $-1$ 且 `errno = EPIPE`，写入 0 字节，并且控制流在 `write()` 调用后继续，从而允许应用程序执行清理并决定恢复策略。**\n这个陈述准确地描述了忽略 `SIGPIPE`（情况 2）时的结果。通过忽略该信号，进程选择通过系统调用的返回值和 `errno` 来接收错误通知。这使得程序能够保持控制权，并在不被终止的情况下处理错误。\n**结论：正确。**\n\n**C. 如果 $P_w$ 安装一个会返回的 `SIGPIPE` 处理程序，对没有读取者的管道的第一次 `write()` 操作将返回 $-1$ 且 `errno = EPIPE`，写入 0 字节，并且执行在 `write()` 调用后继续，从而可以在不终止进程的情况下进行恢复。**\n这个陈述准确地描述了为 `SIGPIPE` 安装返回处理程序（情况 3）时的结果。问题陈述和 POSIX 行为都证实，在处理程序返回后，这个永久失败的系统调用将通过返回 $-1$ 并将 `errno` 设置为 `EPIPE` 来指示错误。此机制同样能防止进程终止，并允许进行程序化的错误处理。\n**结论：正确。**\n\n**D. 对于任何写入大小 $n \\le PIPE\\_BUF$，操作系统保证交付整个记录，即使不存在读取者也是如此，因此抑制 `SIGPIPE` 会允许数据被缓冲直到读取者出现，并且不会发生 `EPIPE`。**\n这个陈述存在根本性错误。$PIPE\\_BUF$ 提供的保证关系到对一个*有效的、可工作的*管道（即有读取者的管道）进行写入操作的原子性。它确保大小小于或等于 $PIPE\\_BUF$ 的写入不会与其他写入者的数据交错。这不适用于损坏的管道。内核不会在没有读取者的管道中缓冲数据；“不存在读取者”这个条件正是 `SIGPIPE` 和 `EPIPE` 设计用来报告的错误。抑制信号并不能改变写入操作不可能完成这一根本事实。\n**结论：不正确。**\n\n**E. 当 $N > C$ 且至少存在一个读取者时，`write()` 可能会传输部分字节数并返回一个小于 $N$ 的正值；然而，当没有读取者时，`write()` 传输 0 字节并报告 `EPIPE`，无论 $N$ 或 $s$ 的大小如何。**\n这个陈述正确地对比了管道的两种不同行为。\n- **第一部分：** 当存在读取者时，对管道的 `write()` 操作确实可能返回一个“部分计数值”（一个大于 $0$ 但小于请求字节数的返回值）。如果管道缓冲区在写入过程中变满，这种情况就可能发生，特别是对于非原子写入（写入大小大于 $PIPE\\_BUF$，本例中 $s = 8192 > PIPE\\_BUF = 4096$ 就是这种情况）。该陈述提到返回一个小于 $N$ ($100000$) 的值，这对于任何一次大小为 $s=8192$ 的成功写入都是正确的。所以，这部分是正确的。\n- **第二部分：** 这部分正确地重申了损坏管道的行为：没有读取者时，任何写入尝试都会立即失败，传输 0 字节，并导致 `EPIPE` 错误（假设信号被处理或忽略），无论预期的写入大小（$N$ 或 $s$）是多少。\n整个陈述对管道在有效状态与损坏状态下的行为进行了准确的比较。\n**结论：正确。**", "answer": "$$\\boxed{ABCE}$$", "id": "3669766"}, {"introduction": "在使用管道时，一个常见且令人头疼的问题是进程“挂起”或陷入死锁。本练习要求您运用“从空管道读取操作会一直阻塞，直到所有写入端都关闭”这一核心规则来诊断一个挂起的管道。这个调试思想实验将锻炼您追踪文件描述符继承和定位管道停滞根源的能力，这是系统编程中的一项关键技能。[@problem_id:3669787]", "problem": "在可移植操作系统接口 (POSIX) 中，匿名管道是一个由内核管理的缓冲区，它恰好有两个端点：一个读端和一个写端。根据定义，当管道缓冲区不含任何字节且至少有一个写端保持打开时，对管道的读操作会阻塞；当所有写端都已关闭时，读操作返回文件结束符 (EOF)。文件描述符通过 `fork()` 系统调用在进程创建时被继承，并且在 `exec()` 系统调用后保持打开状态，除非设置了 Close-On-Execute (`CLOEXEC`) 标志。像 `A | B | C` 这样的 shell 管道是通过两个匿名管道实现的：一个在 $A$ 和 $B$ 之间，另一个在 $B$ 和 $C$ 之间。进程状态 (`ps`) 在概念上暴露了父子关系，而列出打开的文件 (`lsof`) 在概念上揭示了每个进程打开的文件描述符以及每个管道的内核对象标识。\n\n考虑一个由 shell 创建的管道，其中命令 $A$、$B$ 和 $C$ 的进程标识符 (PID) 分别为 $2301$、$2302$ 和 $2303$。该 shell 创建了两个匿名管道，内核对象标识分别为 $p_{\\alpha}$ 和 $p_{\\beta}$，其中 $p_{\\alpha}$ 的标识符为 $41001$，$p_{\\beta}$ 的标识符为 $41002$。在时间 $t_{0}$，管道设置完成后立即出现以下情况：\n\n- 进程 $A$ (PID $2301$，父进程标识符 (PPID) $2299$) 的文件描述符 $1$ 打开并指向管道 $p_{\\alpha}$ (标识符 $41001$) 的写端。其文件描述符 $0$ 是一个常规文件。\n- 进程 $B$ (PID $2302$，PPID $2299$) 的文件描述符 $0$ 打开并指向管道 $p_{\\alpha}$ (标识符 $41001$) 的读端，文件描述符 $1$ 打开并指向管道 $p_{\\beta}$ (标识符 $41002$) 的写端。\n- 进程 $C$ (PID $2303$，PPID $2299$) 的文件描述符 $0$ 打开并指向管道 $p_{\\beta}$ (标识符 $41002$) 的读端。\n\n之后，进程 $B$ 在未对其文件描述符设置 `CLOEXEC` 的情况下执行了一个辅助程序。具体来说，进程 $B$ `fork()` 然后 `exec()` 了一个辅助进程 $H$ (PID $2310$，PPID $2302$)，该进程继承了指向管道 $p_{\\beta}$ (标识符 $41002$) 写端的文件描述符 $1$。此后不久，在时间 $t_{1}$，进程 $B$ 终止并成为一个僵尸进程 (defunct)，释放了其文件描述符。在时间 $t_{2} > t_{1}$，与该管道相关的系统状态如下：\n\n- 进程 $A$ (PID $2301$) 的文件描述符 $1$ 仍然打开并指向管道 $p_{\\alpha}$ (标识符 $41001$) 的写端。它没有任何指向管道 $p_{\\beta}$ (标识符 $41002$) 的描述符。\n- 进程 $B$ (PID $2302$) 是一个僵尸进程，没有打开的文件描述符。\n- 进程 $C$ (PID $2303$) 在其文件描述符 $0$（即管道 $p_{\\beta}$ (标识符 $41002$) 的读端）上的读操作中被阻塞。\n- 辅助进程 $H$ (PID $2310$，PPID $2302$) 的文件描述符 $1$ 打开并指向管道 $p_{\\beta}$ (标识符 $41002$) 的写端。它没有写入任何数据并且正在睡眠。\n- 系统中没有其他进程持有指向管道 $p_{\\beta}$ (标识符 $41002$) 的打开描述符。\n\n测量表明，在时间 $t_{2}$，管道 $p_{\\beta}$ 的缓冲区包含 $0$ 字节。管道看起来“挂起”了，因为 $C$ 正在等待管道 $p_{\\beta}$ 上的 EOF 信号以便继续执行，但尚未观察到 EOF。\n\n哪个选项指出了在时间 $t_{2}$ 唯一一个其打开的写端足以阻止管道 $p_{\\beta}$ 上出现 EOF 的进程，因此必须关闭该描述符（或被终止）才能通过让 $C$ 观察到 EOF 并解除阻塞来“解救”该管道？\n\nA. 进程 $A$ (PID $2301$)\n\nB. 进程 $B$ (PID $2302$)\n\nC. 进程 $C$ (PID $2303$)\n\nD. 辅助进程 $H$ (PID $2310$)", "solution": "将通过首先提取给定信息，然后评估其科学依据、一致性和完整性来验证问题陈述。\n\n**步骤 1：提取已知条件**\n- 在 POSIX 中，匿名管道是一个内核缓冲区，有读端和写端。\n- 如果缓冲区为空且至少有一个写端打开，对管道的 `read()` 操作将阻塞。\n- 如果缓冲区为空且所有写端都已关闭，对管道的 `read()` 操作将返回文件结束符 (EOF)。\n- 文件描述符在 `fork()` 时被继承，并且在 `exec()` 后保持打开状态，除非设置了 `CLOEXEC` 标志。\n- 一个 shell 管道 `A | B | C` 是用两个匿名管道实现的。\n- 管道 $p_{\\alpha}$ 的内核对象标识符为 $41001$。\n- 管道 $p_{\\beta}$ 的内核对象标识符为 $41002$。\n- 在时间 $t_0$，管道设置完成后立即：\n    - 进程 $A$ (PID $2301$, PPID $2299$) 的文件描述符 (FD) $1$ 打开并指向 $p_{\\alpha}$ 的写端。\n    - 进程 $B$ (PID $2302$, PPID $2299$) 的 FD $0$ 打开并指向 $p_{\\alpha}$ 的读端，FD $1$ 打开并指向 $p_{\\beta}$ 的写端。\n    - 进程 $C$ (PID $2303$, PPID $2299$) 的 FD $0$ 打开并指向 $p_{\\beta}$ 的读端。\n- $t_0$ 之后：\n    - 进程 $B$ fork 一个子进程，该子进程随后执行一个辅助程序，成为进程 $H$。\n    - `exec()` 调用没有在 $B$ 的文件描述符上设置 `CLOEXEC`。\n    - 进程 $H$ (PID $2310$, PPID $2302$) 继承了描述符，包括指向 $p_{\\beta}$ 写端的 FD $1$。\n    - 在时间 $t_1$，进程 $B$ 终止，成为一个僵尸进程，其文件描述符被释放。\n- 在时间 $t_2 > t_1$，系统状态为：\n    - 进程 $A$ (PID $2301$) 的 FD $1$ 打开并指向 $p_{\\alpha}$ 的写端。它不持有 $p_{\\beta}$ 的描述符。\n    - 进程 $B$ (PID $2302$) 是一个没有打开文件描述符的僵尸进程。\n    - 进程 $C$ (PID $2303$) 在 FD $0$（$p_{\\beta}$ 的读端）上的 `read()` 操作中被阻塞。\n    - 进程 $H$ (PID $2310$) 的 FD $1$ 打开并指向 $p_{\\beta}$ 的写端。\n    - 没有其他进程持有管道 $p_{\\beta}$ 的打开描述符。\n    - 管道 $p_{\\beta}$ 的缓冲区包含 $0$ 字节。\n- 问题要求识别出在管道 $p_{\\beta}$ 上，哪个单一进程的打开的写端阻止了进程 $C$ 接收 EOF，从而导致管道“挂起”。\n\n**步骤 2：使用提取的已知条件进行验证**\n问题陈述是对 Unix/POSIX 系统中涉及使用管道进行进程间通信的一个常见场景的格式良好且准确的描述。\n- **科学依据充分：** 对管道语义（阻塞读、EOF 条件）、通过 `fork()` 和 `exec()` 的文件描述符继承以及进程状态（僵尸）的描述，完全符合操作系统的既定原则，特别是 POSIX 标准。该场景是“管道卡死”错误的典型例子。\n- **问题定义明确：** 问题提供了系统在特定时间 ($t_2$) 的完整且一致的状态，并就特定行为（进程 $C$ 阻塞）的原因提出了一个精确的、可回答的问题。可以从提供的信息中推导出唯一且明确的答案。\n- **客观性：** 问题使用精确的技术术语（PID、PPID、文件描述符、`CLOEXEC`、僵尸）和量化标识符进行陈述。它没有歧义或主观性陈述。\n\n**步骤 3：结论与行动**\n问题陈述有效。可以继续进行分析。\n\n**解题推导**\n问题的核心在于对管道的 `read()` 操作返回文件结束符 (EOF) 的规则。正如问题描述中所述，这发生在“（指向该管道的）所有写端都已关闭”时。进程 $C$ 当前在从管道 $p_{\\beta}$ 读取时被阻塞，并且管道的缓冲区是空的。只要至少有一个进程持有对应于 $p_{\\beta}$ 写端的打开文件描述符，这就是预期的行为。要“解救”进程 $C$ 并使其能够观察到 EOF，所有这样的写端文件描述符都必须被关闭。\n\n任务是识别在时间 $t_2$ 哪个或哪些进程持有管道 $p_{\\beta}$ 写端的打开文件描述符。我们必须系统地检查在 $t_2$ 的状态描述中提到的每个进程。\n\n1.  **目标管道**：问题集中在管道 $p_{\\beta}$（标识符 $41002$）上，因为进程 $C$ 在从中读取时被阻塞。\n\n2.  **EOF 条件**：为了让进程 $C$ 接收到 EOF，内核对管道 $p_{\\beta}$ 打开的写端的内部引用计数必须降至 $0$。\n\n3.  **$t_2$ 时的进程状态分析**：\n    - **进程 $A$ (PID $2301$)：** 问题陈述：“它没有任何指向管道 $p_{\\beta}$ 的描述符”。因此，进程 $A$ 没有保持 $p_{\\beta}$ 的写端打开。\n    - **进程 $B$ (PID $2302$)：** 问题陈述：“进程 $B$ (PID $2302$) 是一个僵尸进程，没有打开的文件描述符。” 当一个进程终止时，操作系统内核会关闭其所有打开的文件描述符。因此，进程 $B$ 曾经持有的指向 $p_{\\beta}$ 写端的文件描述符在时间 $t_1$ 就被关闭了。在时间 $t_2$，进程 $B$ 对打开的写入者计数没有贡献。\n    - **进程 $C$ (PID $2303$)：** 这个进程是管道 $p_{\\beta}$ 上的读取者。它持有的是读端的描述符，而不是写端。它是等待 EOF 的一方，而不是阻止 EOF 的一方。\n    - **辅助进程 $H$ (PID $2310$)：** 问题明确指出：“辅助进程 $H$ (PID $2310$，PPID $2302$) 的文件描述符 $1$ 打开并指向管道 $p_{\\beta}$ (标识符 $41002$) 的写端... 它没有写入任何数据并且正在睡眠。” 这是进程 $B$ 在没有设置 `CLOEXEC` 标志的情况下 `fork()` 并 `exec()` $H$ 的直接后果；进程 $H$ 继承了打开的文件描述符。\n    - **其他进程：** 问题陈述：“系统中没有其他进程持有指向管道 $p_{\\beta}$ 的打开描述符”。\n\n4.  **结论**：根据分析，在时间 $t_2$，整个系统中只有一个指向管道 $p_{\\beta}$ 写端的打开文件描述符。该描述符由辅助进程 $H$ 持有。这个单一打开的写句柄的存在，足以阻止内核向进程 $C$ 发送 EOF。因此，进程 $H$ 是管道挂起的唯一原因。要解决此问题，进程 $H$ 必须关闭其文件描述符 $1$ 或被终止，这将导致内核代表它关闭该描述符。\n\n**逐项分析选项**\n\n- **A. 进程 $A$ (PID $2301$)：** 如前所述，进程 $A$ 没有与管道 $p_{\\beta}$ 相关联的打开文件描述符。因此，它在阻止 $p_{\\beta}$ 上出现 EOF 方面不起任何作用。**错误**。\n\n- **B. 进程 $B$ (PID $2302$)：** 进程 $B$ 已终止。虽然它在执行进程 $H$ 之前因不当管理文件描述符而造成了此种情况，但在时间 $t_2$，它是一个僵尸进程，不持有任何打开的文件描述符。内核在其于 $t_1$ 终止时关闭了它的描述符。因此，它不是当前阻止 EOF 的进程。**错误**。\n\n- **C. 进程 $C$ (PID $2303$)：** 进程 $C$ 是管道 $p_{\\beta}$ 上的消费者，持有读端的描述符。它是管道挂起的受害者，而不是原因。**错误**。\n\n- **D. 辅助进程 $H$ (PID $2310$)：** 进程 $H$ 继承并持有一个指向管道 $p_{\\beta}$ 写端的打开文件描述符。只要此描述符是打开的，为进程 $C$ 生成 EOF 的条件（即所有写端都已关闭）就不满足。进程 $H$ 是唯一一个其打开的写端足以阻止 EOF 的进程。**正确**。", "answer": "$$\\boxed{D}$$", "id": "3669787"}]}