{"hands_on_practices": [{"introduction": "在进程竞争范围（PCS）的“多对一”线程模型中，一个核心风险在于单个用户线程的阻塞性系统调用会导致管理所有用户线程的那个内核线程被挂起，从而使整个进程停滞。本练习通过一个简单的概率模型来量化这种风险。通过计算因不可预测的阻塞而产生的预期等待时间，我们可以更深刻地理解为什么操作系统需要引入异步I/O或更复杂的调度器激活（Scheduler Activations）机制来缓解这一基本问题[@problem_id:3672449]。", "problem": "考虑一个多线程进程，其用户级运行时使用进程竞争范围 (PCS) 将用户线程多路复用到单个轻量级进程 (LWP，一种内核可调度实体) 上。在 PCS 中，如果一个用户线程发出一个会阻塞的系统调用，LWP 会被内核置于休眠状态，并且同一进程中的其他用户线程在内核解除 LWP 的阻塞之前都无法取得进展。相比之下，在具有多个内核线程的系统竞争范围 (SCS) 下，一个线程的阻塞不一定会导致其他线程停滞；然而，在本场景中，该进程被限制为使用 PCS 且只有一个 LWP。\n\n假设运行时错误地预测了就绪状态，并调度了一个立即尝试进行具有不可预测阻塞结果的系统调用的用户线程。设系统调用阻塞的概率为 $p_b$，并假设试验是独立的，且没有其他延迟来源。如果阻塞，LWP 将休眠 $t_b$ 毫秒，在此期间所有其他可运行的用户线程都将等待。如果不阻塞，系统调用会足够快地完成，下一个可运行用户线程被调度前的唯一延迟是 $t_c$ 毫秒的协作式切换和调度器开销。\n\n给定 $p_b = 0.32$，$t_b = 50$ 毫秒，以及 $t_c = 3$ 毫秒，请使用概率论的基本原理和期望值的定义来推导由于这次 PCS 错误预测，其他可运行用户线程所经历的期望等待时间 $E[W]$（以毫秒为单位）。用毫秒表示最终答案，并四舍五入到四位有效数字。", "solution": "用户要求推导在一个受限于进程竞争范围 (PCS) 且只有一个轻量级进程 (LWP) 的多线程进程中，可运行用户线程的期望等待时间。必须首先验证问题的科学合理性、完整性和客观性。\n\n### 步骤 1：提取已知条件\n逐字提取所提供的数据和条件：\n- 系统使用进程竞争范围 (PCS) 且只有一个 LWP。\n- 一个用户线程尝试进行一个具有不可预测阻塞结果的系统调用。\n- 系统调用阻塞的概率为 $p_b$。\n- 如果调用阻塞，LWP 将休眠 $t_b$ 的时间。\n- 如果调用不阻塞，延迟是调度器开销 $t_c$。\n- 试验是独立的，没有其他延迟来源。\n- $p_b = 0.32$\n- $t_b = 50$ 毫秒\n- $t_c = 3$ 毫秒\n- 目标是求出期望等待时间 $E[W]$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据既定标准对问题进行评估：\n- **科学依据**：问题陈述准确地描述了多对一线程模型（多个用户线程映射到一个内核线程/LWP）的行为，这也是进程竞争范围的本质。一个用户线程的阻塞性系统调用导致复用在该 LWP 上的所有用户线程组停滞的场景，是该模型的一个定义性特征。使用期望值来分析系统性能是计算机科学和工程中的一个标准且有效的方法。该问题在根本上是合理的。\n- **良构性**：该问题是良构的。它定义了一个离散随机变量，即等待时间 $W$，它可以取两个特定值之一。每个值的概率已经提供，或者可以从已知条件（$p_b$ 和 $1-p_b$）中直接推断出来。计算期望值所需的所有参数（$t_b$，$t_c$，$p_b$）都已明确说明。目标清晰，且存在唯一解。\n- **客观性**：该问题以精确、客观的语言陈述。它描述了一个技术场景，没有任何主观、模糊或基于观点的论断。\n\n该问题没有违反任何无效标准。它具有科学合理性、良构性、完全指定性和客观性。因此，该问题被认为是**有效的**。\n\n### 步骤 3：进行求解\n其他可运行用户线程所经历的等待时间，用随机变量 $W$ 表示，取决于系统调用的结果。存在两种互斥的结果：调用阻塞，或不阻塞。\n\n设 $p_b$ 为系统调用阻塞的概率。\n系统调用不阻塞的概率是其补集，即 $1 - p_b$。\n\n等待时间 $W$ 的值由发生哪种结果决定：\n1.  如果系统调用阻塞，等待时间为 $t_b$。这种情况发生的概率为 $p_b$。\n2.  如果系统调用不阻塞，等待时间为 $t_c$。这种情况发生的概率为 $1 - p_b$。\n\n离散随机变量的期望值定义为变量的每个可能值与其相应概率的乘积之和。对于随机变量 $W$，其期望值 $E[W]$ 由下式给出：\n$$E[W] = (\\text{阻塞时的 W 值}) \\times P(\\text{阻塞}) + (\\text{不阻塞时的 W 值}) \\times P(\\text{不阻塞})$$\n\n代入问题陈述中的符号变量：\n$$E[W] = t_b \\cdot p_b + t_c \\cdot (1 - p_b)$$\n\n现在，我们代入问题陈述中提供的数值：\n- $p_b = 0.32$\n- $t_b = 50$ 毫秒\n- $t_c = 3$ 毫秒\n\n不阻塞的概率为 $1 - p_b = 1 - 0.32 = 0.68$。\n\n将这些值代入期望等待时间的公式中：\n$$E[W] = (50) \\cdot (0.32) + (3) \\cdot (0.68)$$\n\n我们计算和的两个分量：\n$$50 \\cdot 0.32 = 16.0$$\n$$3 \\cdot 0.68 = 2.04$$\n\n将这些分量相加得到最终的期望值：\n$$E[W] = 16.0 + 2.04 = 18.04$$\n\n问题要求最终答案以毫秒表示，并保留四位有效数字。计算出的值为 $18.04$ 毫秒，这已经有四位有效数字（$1$、$8$、$0$、$4$）。因此，无需进一步的四舍五入。", "answer": "$$\\boxed{18.04}$$", "id": "3672449"}, {"introduction": "除了阻塞调用这一特定问题，我们将视野拓宽到并发系统中普遍存在的性能开销：上下文切换。本练习引导我们建立一个模型，来量化在资源超订（oversubscription）的情况下，由上下文切换开销引起的性能下降。通过推导一个“减速因子”$ \\delta $，我们可以定量地比较在用户态（PCS）和内核态（SCS）进行线程切换的效率差异[@problem_id:3672426]。", "problem": "您将获得一个模型，用于推断在超额配置（oversubscription）情况下，进程竞争范围（Process-Contention Scope, PCS）和系统竞争范围（System-Contention Scope, SCS）调度如何影响执行时间。请从第一性原理出发，使用以下基本定义和事实来推导出一个定量的减速模型，并将其在一个程序中实现。\n\n基本定义和事实：\n- 进程竞争范围（PCS）：由用户级库在一个单一进程内对用户级线程进行的调度，其中内核仅调度一组数量较少的内核可见执行实体（例如，每个中央处理器（CPU）一个）。用户级库在其用户线程之间执行上下文切换。\n- 系统竞争范围（SCS）：由操作系统内核在系统上所有进程的内核可见线程之间进行的调度，通过内核感知的负载均衡将可运行线程分布到各个 CPU 上。\n- 轮询时间共享：每个可运行线程在一个 CPU 上获得一个长度为 $q$ 的时间片，然后被抢占。一次上下文切换会产生固定的开销 $s$，在此期间不执行任何有效工作。对于 PCS，开销记为 $s_{\\mathrm{PCS}}$；对于 SCS，开销记为 $s_{\\mathrm{SCS}}$。\n- 相同的工作负载：$N$ 个相同的线程每个都需要 $W$ 单位的纯计算时间。假设归一化的 CPU 速度为每 CPU 每秒 1 单位工作量，因此 $W$ 以理想计算时间的秒为单位。\n- CPU 时间的公平共享与守恒：在轮询调度、线程相同且负载均衡完美的情况下，每个 CPU 将其可用的有效时间平均分配给分配给它的可运行线程。每个 CPU 的总有效速率会因上下文切换开销所占的时间比例而降低。当有可运行线程可用时，空闲时间为零。\n\n设置：\n- 设 CPU 数量为 $C$，并设置线程数量 $N = 2C$ 以创建超额配置。假设在 SCS 下，内核感知的负载均衡使每个 CPU 上的可运行线程数保持相等。\n- 对于 PCS，假设 $C$ 个内核可见的执行实体被固定到 $C$ 个 CPU 上，用户级库使用轮询调度（时间片为 $q$，每次用户级上下文切换开销为 $s_{\\mathrm{PCS}}$）在这 $C$ 个实体上多路复用 $N$ 个用户线程。\n- 对于 SCS，假设内核使用轮询调度（时间片为 $q$，每次内核级上下文切换开销为 $s_{\\mathrm{SCS}}$）在 $C$ 个 CPU 上多路复用 $N$ 个内核可见线程，且内核感知的负载均衡消除了额外的迁移惩罚。\n\n任务：\n1. 仅从上述基本定义和事实出发，逻辑推导出当 $N=2C$ 时，在 PCS 下单个线程的完成时间 $T_{\\mathrm{PCS}}$ 和在 SCS 下单个线程的完成时间 $T_{\\mathrm{SCS}}$，用 $W$、$q$、$s_{\\mathrm{PCS}}$、$s_{\\mathrm{SCS}}$、$N$ 和 $C$ 表示。将减速比定义为 $\\delta = T/T_{\\mathrm{ideal}}$，其中 $T_{\\mathrm{ideal}}$ 是在 $N=C$ 且没有时间分片开销时单个线程的完成时间。将 $\\delta_{\\mathrm{PCS}}$ 和 $\\delta_{\\mathrm{SCS}}$ 表示为无量纲比率。\n2. 实现一个完整的、可运行的程序，为以下测试套件计算 $\\delta_{\\mathrm{PCS}}$ 和 $\\delta_{\\mathrm{SCS}}$。将所有时间 $q$、$s_{\\mathrm{PCS}}$ 和 $s_{\\mathrm{SCS}}$ 视为秒，将 $W$ 视为理想计算时间的秒数。您的程序不得使用任何随机性或操作系统并发性；它必须是纯计算的。\n3. 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，值按 $[\\delta_{\\mathrm{PCS}}^{(1)},\\delta_{\\mathrm{SCS}}^{(1)},\\delta_{\\mathrm{PCS}}^{(2)},\\delta_{\\mathrm{SCS}}^{(2)},\\dots]$ 的顺序排列，并四舍五入到六位小数。\n\n测试套件（每种情况下 $N=2C$）：\n- 情况 1（理想路径）：$C=4$, $N=8$, $W=1.0$, $q=0.010$, $s_{\\mathrm{PCS}}=0.0005$, $s_{\\mathrm{SCS}}=0.0010$。\n- 情况 2（零开销边界）：$C=4$, $N=8$, $W=2.5$, $q=0.010$, $s_{\\mathrm{PCS}}=0.0000$, $s_{\\mathrm{SCS}}=0.0000$。\n- 情况 3（小时间片，显著开销）：$C=2$, $N=4$, $W=1.0$, $q=0.0010$, $s_{\\mathrm{PCS}}=0.0005$, $s_{\\mathrm{SCS}}=0.0005$。\n- 情况 4（单 CPU 边界）：$C=1$, $N=2$, $W=3.0$, $q=0.0200$, $s_{\\mathrm{PCS}}=0.0008$, $s_{\\mathrm{SCS}}=0.0010$。\n- 情况 5（较大系统，轻度开销不平衡）：$C=8$, $N=16$, $W=0.5$, $q=0.0050$, $s_{\\mathrm{PCS}}=0.0002$, $s_{\\mathrm{SCS}}=0.0006$。\n\n答案格式：\n- 精确输出一行，格式为 $[\\text{float},\\text{float},\\dots]$，无空格，每个浮点数按规定四舍五入到六位小数。", "solution": "这项任务是为一个特定的超额配置场景推导一个量化模型，该模型描述了进程竞争范围（PCS）和系统竞争范围（SCS）调度所引入的性能减速。推导过程必须基于所提供的第一性原理。\n\n首先，我们建立比较的基准线，即理想完成时间 $T_{\\mathrm{ideal}}$。这被定义为当线程数 $N$ 等于 CPU 数 $C$ 且没有时间分片开销时，一个线程完成其工作所需的时间。在这种情况下， $C$ 个线程中的每一个都被分配到一个 CPU 上，并运行至完成而无需中断。鉴于每个线程需要 $W$ 秒的纯计算时间，且 CPU 的归一化速度为每秒 1 单位工作量，理想完成时间就是：\n$$ T_{\\mathrm{ideal}} = W $$\n\n接下来，我们分析在带开销的轮询调度下 CPU 的性能。考虑一个调度 $k$ 个线程的 CPU。一个完整的调度周期包括给 $k$ 个线程中的每一个分配一个时间片 $q$，每次授予 CPU 后都伴随着一个持续时间为 $s$ 的上下文切换。一个完整周期的总时间是所有时间片和所有上下文切换时间的总和：\n$$ T_{\\mathrm{cycle}} = k \\cdot q + k \\cdot s = k(q+s) $$\n在此周期内完成的有效工作是执行线程代码所花费的时间总和：\n$$ W_{\\mathrm{cycle}} = k \\cdot q $$\nCPU 的有效服务率 $\\eta$ 是它用于有效工作的时间比例。这是有效时间与总周期时间之比：\n$$ \\eta = \\frac{W_{\\mathrm{cycle}}}{T_{\\mathrm{cycle}}} = \\frac{k \\cdot q}{k(q+s)} = \\frac{q}{q+s} $$\n这个有效分数 $\\eta$ 代表了 CPU 总时间中转化为有用计算的部分。请注意，只要 $k \\ge 1$，这个速率就与被调度的线程数 $k$ 无关。\n\n现在，我们将此模型应用于两种调度范围，针对给定的 $N=2C$ 个线程在 $C$ 个 CPU 上的设置。\n\n对于系统竞争范围（SCS），操作系统内核在 $C$ 个 CPU 上调度所有 $N=2C$ 个线程。问题陈述中说明，内核感知的负载均衡会均匀分配这些线程。因此， $C$ 个 CPU 中的每一个都有 $k = N/C = 2C/C = 2$ 个线程需要管理。这些是内核可见线程，因此每次上下文切换都会产生内核级开销 $s_{\\mathrm{SCS}}$。因此，每个 CPU 的有效服务率为：\n$$ \\eta_{\\mathrm{SCS}} = \\frac{q}{q + s_{\\mathrm{SCS}}} $$\n根据公平共享策略，这个有效速率在 CPU 上的 2 个线程之间平均共享。单个线程完成其工作的速率是 CPU 有效速率的一半：\n$$ \\text{Rate}_{\\text{per thread, SCS}} = \\frac{1}{2} \\eta_{\\mathrm{SCS}} = \\frac{1}{2} \\left( \\frac{q}{q + s_{\\mathrm{SCS}}} \\right) $$\n一个线程完成其工作负载 $W$ 所需的总时间 $T_{\\mathrm{SCS}}$ 是工作量除以其被服务的速率：\n$$ T_{\\mathrm{SCS}} = \\frac{W}{\\text{Rate}_{\\text{per thread, SCS}}} = \\frac{W}{\\frac{1}{2} \\left( \\frac{q}{q + s_{\\mathrm{SCS}}} \\right)} = \\frac{2W(q + s_{\\mathrm{SCS}})}{q} $$\n\n对于进程竞争范围（PCS），设置涉及 $C$ 个内核可见的实体被固定到 $C$ 个 CPU 上。操作系统看到每个 CPU 上有一个实体，因此在内核层面不执行时间分片。用户级库负责在这 $C$ 个内核实体上调度 $N=2C$ 个用户线程。假设库将它们均匀分配，每个内核实体（并延伸至每个 CPU）负责调度 $k = N/C = 2$ 个用户线程。这种用户级调度使用一个时间片 $q$ 和一个上下文切换开销 $s_{\\mathrm{PCS}}$。其逻辑结构与 SCS 情况相同，但开销参数不同。\n由用户级调度器调节的 CPU 有效服务率为：\n$$ \\eta_{\\mathrm{PCS}} = \\frac{q}{q + s_{\\mathrm{PCS}}} $$\n该速率在分配给内核实体的 2 个用户线程之间共享。每个线程的速率为：\n$$ \\text{Rate}_{\\text{per thread, PCS}} = \\frac{1}{2} \\eta_{\\mathrm{PCS}} = \\frac{1}{2} \\left( \\frac{q}{q + s_{\\mathrm{PCS}}} \\right) $$\n一个线程完成其工作负载 $W$ 的总时间 $T_{\\mathrm{PCS}}$ 是：\n$$ T_{\\mathrm{PCS}} = \\frac{W}{\\text{Rate}_{\\text{per thread, PCS}}} = \\frac{W}{\\frac{1}{2} \\left( \\frac{q}{q + s_{\\mathrm{PCS}}} \\right)} = \\frac{2W(q + s_{\\mathrm{PCS}})}{q} $$\n\n最后，我们计算减速比 $\\delta$，定义为实际完成时间 $T$ 与理想时间 $T_{\\mathrm{ideal}}$ 之比。\n对于 PCS，减速比 $\\delta_{\\mathrm{PCS}}$ 为：\n$$ \\delta_{\\mathrm{PCS}} = \\frac{T_{\\mathrm{PCS}}}{T_{\\mathrm{ideal}}} = \\frac{ \\frac{2W(q + s_{\\mathrm{PCS}})}{q} }{W} = \\frac{2(q + s_{\\mathrm{PCS}})}{q} = 2 \\left(1 + \\frac{s_{\\mathrm{PCS}}}{q}\\right) $$\n对于 SCS，减速比 $\\delta_{\\mathrm{SCS}}$ 为：\n$$ \\delta_{\\mathrm{SCS}} = \\frac{T_{\\mathrm{SCS}}}{T_{\\mathrm{ideal}}} = \\frac{ \\frac{2W(q + s_{\\mathrm{SCS}})}{q} }{W} = \\frac{2(q + s_{\\mathrm{SCS}})}{q} = 2 \\left(1 + \\frac{s_{\\mathrm{SCS}}}{q}\\right) $$\n这些表达式是所要求的无量纲比率。因子 $2$ 来自于竞争（超额配置因子 $N/C = 2$），而项 $(1 + s/q)$ 代表了相对于时间片的上下文切换开销所带来的惩罚。", "answer": "[2.100000,2.200000,2.000000,2.000000,3.000000,3.000000,2.080000,2.200000,2.080000,2.240000]", "id": "3672426"}, {"introduction": "理论模型为我们提供了深刻的洞见，但现实世界的性能分析则需要我们将这些理论应用于实际测量数据。本练习模拟了一次真实的性能诊断过程，你将利用现代追踪工具（如 eBPF）采集到的数据来剖析性能瓶颈。通过将不同的延迟来源精确地归类为进程内竞争（PCS）或系统级竞争（SCS），你将掌握一项在复杂应用中定位性能问题的关键技能[@problem_id:3672486]。", "problem": "考虑一个用户空间运行时，它将许多用户级线程复用到较少数量的内核级线程上，从而在进程竞争范围（Process-Contention Scope, PCS）和系统竞争范围（System-Contention Scope, SCS）之间产生了潜在的分离。进程竞争范围指的是完全在单个进程的用户空间运行时内部管理和体现的竞争（例如，用户级锁、自旋和协作式让步），而系统竞争范围指的是对操作系统内核调度器可见并由其管理的竞争（例如，一个可运行的线程在内核运行队列中等待，或在内核管理的等待中阻塞）。\n\n你需要设计一种使用扩展伯克利包过滤器（Extended Berkeley Packet Filter, eBPF）的追踪方法，以区分PCS与SCS的竞争，并提出量化各自范围的计数器。eBPF uprobes可以附加到用户空间函数上以捕获用户级事件，而eBPF kprobes或内核跟踪点可以附加到内核函数上以捕获内核级事件。\n\n将计数器 $C_{\\text{user}}$ 和 $C_{\\text{kernel}}$ 定义为在持续时间为 $T$ 的测量窗口内，目标进程所有线程的总竞争时间度量，其中 $C_{\\text{user}}$ 捕获用户空间竞争时间，$C_{\\text{kernel}}$ 捕获内核可见的竞争时间。假设在该窗口期间，收集并分类了以下被插桩的事件类别：\n\n- 用户空间在用户级同步上自旋：所有线程的总聚合时间 $D_{\\text{spin}} = 6.4$ 秒。\n- 在用户级互斥锁上阻塞的用户空间（完全在用户空间内管理，不调用内核等待）：总聚合时间 $D_{\\text{umutex}} = 3.6$ 秒。\n- 内核管理的等待（例如，futex等待或对内核可见的其他阻塞调用）：总聚合时间 $D_{\\text{futex}} = 2.2$ 秒。\n- 因内核运行队列竞争而处于可运行但未运行状态（例如，通过调度器跟踪点测量，显示线程已准备好运行但未被调度）：总聚合时间 $D_{\\text{rq}} = 1.1$ 秒。\n\n所有持续时间都是跨线程聚合的，因此可能超过挂钟测量持续时间 $T$。你可以假设这些分类是互斥的，并且共同涵盖了此进程所关注的竞争状态。\n\n从PCS和SCS的基本定义以及一个连贯的竞争时间核算模型出发，推导出PCS贡献率 $\\rho$ 的估计量（用 $C_{\\text{user}}$ 和 $C_{\\text{kernel}}$ 表示），然后根据给定的测量值计算 $\\rho$。将最终比率表示为一个无量纲的小数，并将你的答案四舍五入到四位有效数字。", "solution": "问题要求我们为进程竞争范围（PCS）对多线程应用程序所经历的总竞争的贡献开发一个定量度量。我们获得了PCS和系统竞争范围（SCS）的定义，以及一组通过eBPF收集的、针对不同类型竞争的总时间测量值。\n\n首先，我们必须根据所提供的概念描述和测量数据，形式化定义总竞争时间计数器 $C_{\\text{user}}$ 和 $C_{\\text{kernel}}$。\n\n进程竞争范围（PCS）被定义为完全在进程的用户空间内管理的竞争。计数器 $C_{\\text{user}}$ 是在这种状态下花费的总时间。根据所提供的数据，有两类属于此定义：\n1. 用户空间在用户级同步上自旋 ($D_{\\text{spin}}$)。在此状态下，线程在一个用户级循环中主动消耗CPU周期以等待资源。这对内核调度器是不可见的，内核调度器认为该线程正在运行。这是一种PCS。\n2. 在用户级互斥锁上阻塞的用户空间 ($D_{\\text{umutex}}$)。问题指明这是“完全在用户空间内管理，不调用内核等待”。这意味着用户空间运行时调度器会取消调度该用户级线程，并可能在同一内核线程上运行另一个用户级线程。内核不知道这次上下文切换。这也是一种PCS。\n\n因此，用户空间总竞争时间 $C_{\\text{user}}$ 是这些事件持续时间的总和。\n$$C_{\\text{user}} = D_{\\text{spin}} + D_{\\text{umutex}}$$\n\n系统竞争范围（SCS）被定义为对操作系统内核调度器可见并由其管理的竞争。计数器 $C_{\\text{kernel}}$ 是在这些状态下花费的总时间。数据中有两类符合此描述：\n1. 内核管理的等待 ($D_{\\text{futex}}$)。这包括在阻塞系统调用中花费的时间，其中内核明确地将线程置于睡眠状态（例如，等待futex、I/O或其他内核同步原语）。对资源的竞争由内核管理。这是一种SCS。\n2. 可运行但未运行 ($D_{\\text{rq}}$)。这表示内核线程已准备好执行，但在内核的运行队列中等待可用的CPU核心。这是对CPU核心的竞争，CPU核心是直接由内核调度器管理的资源。这是一种SCS。\n\n因此，内核可见的总竞争时间 $C_{\\text{kernel}}$ 是这些事件持续时间的总和。\n$$C_{\\text{kernel}} = D_{\\text{futex}} + D_{\\text{rq}}$$\n\n总竞争时间 $C_{\\text{total}}$ 是来自两个范围的竞争之和。鉴于事件类别是互斥且共同涵盖了我们所关注的竞争状态的假设，我们可以写出：\n$$C_{\\text{total}} = C_{\\text{user}} + C_{\\text{kernel}}$$\n\n问题要求的是PCS贡献率，我们用 $\\rho$ 表示。这个比率的一个逻辑定义是总竞争时间中可归因于PCS的部分。\n$$\\rho = \\frac{C_{\\text{user}}}{C_{\\text{total}}} = \\frac{C_{\\text{user}}}{C_{\\text{user}} + C_{\\text{kernel}}}$$\n代入 $C_{\\text{user}}$ 和 $C_{\\text{kernel}}$ 的表达式：\n$$\\rho = \\frac{D_{\\text{spin}} + D_{\\text{umutex}}}{ (D_{\\text{spin}} + D_{\\text{umutex}}) + (D_{\\text{futex}} + D_{\\text{rq}}) }$$\n\n现在，我们将给定的数值代入这些表达式中：\n$D_{\\text{spin}} = 6.4$ 秒\n$D_{\\text{umutex}} = 3.6$ 秒\n$D_{\\text{futex}} = 2.2$ 秒\n$D_{\\text{rq}} = 1.1$ 秒\n\n首先，我们计算 $C_{\\text{user}}$ 和 $C_{\\text{kernel}}$：\n$$C_{\\text{user}} = 6.4 + 3.6 = 10.0 \\text{ s}$$\n$$C_{\\text{kernel}} = 2.2 + 1.1 = 3.3 \\text{ s}$$\n\n接下来，我们计算总竞争时间 $C_{\\text{total}}$：\n$$C_{\\text{total}} = C_{\\text{user}} + C_{\\text{kernel}} = 10.0 + 3.3 = 13.3 \\text{ s}$$\n\n最后，我们计算比率 $\\rho$：\n$$\\rho = \\frac{C_{\\text{user}}}{C_{\\text{total}}} = \\frac{10.0}{13.3}$$\n$$\\rho \\approx 0.751879699...$$\n\n问题要求答案四舍五入到四位有效数字。\n$$\\rho \\approx 0.7519$$\n这个无量纲的比率表明，大约 $75.19\\%$ 的测量竞争发生在用户空间运行时（PCS）内部，而剩余部分是由于对内核管理的资源（SCS）的竞争。", "answer": "$$\\boxed{0.7519}$$", "id": "3672486"}]}