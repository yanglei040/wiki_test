{"hands_on_practices": [{"introduction": "在分析复杂的线程交互之前，我们必须首先理解操作系统内核中延迟的基本来源。本练习将延迟分解为其核心组成部分——线程分派延迟和中断延迟——揭示了内核设计决策（例如临界区和中断屏蔽）如何直接影响系统响应能力。通过计算这些值，您将对调度器最底层的“时间都去哪儿了”有一个具体的认识。[@problem_id:3688825]", "problem": "一个单核中央处理器 (CPU) 在一个操作系统 (OS) 内部运行一个基于优先级的、完全抢占式的线程调度器。内核有时会在一个禁用线程抢占的临界区中执行。在该临界区的某个子区间内，硬件中断也会被屏蔽。以下条件成立。\n\n- 当内核中禁用线程抢占时，一个更高优先级的就绪线程无法抢占当前正在运行的线程，直到内核到达一个重新启用抢占的调度点。\n- 离开临界区后，内核会执行一次重新调度检查，如果有一个更高优先级的线程就绪，调度器将运行并执行一次上下文切换，然后新线程开始执行。\n- 当中断被屏蔽时，CPU 会推迟对硬件中断的服务；一旦中断被解除屏蔽，CPU 会以有限的进入延迟跳转到相应的中断服务程序 (ISR)。\n\n假设系统行为如下：\n\n- 内核禁用抢占的最坏情况持续时间为 $T_{\\text{crit}} = 84$ 微秒。\n- 在每个这样的临界区内部，中断被屏蔽的最坏情况连续子区间为 $T_{\\text{mask}} = 31$ 微秒。\n- 重新调度检查后，调度器的决策过程产生的开销为 $T_{\\text{sched}} = 11$ 微秒，随后的上下文切换开销为 $T_{\\text{cs}} = 19$ 微秒。\n- 硬件中断进入延迟（从中断解除屏蔽到 ISR 的第一条指令）为 $T_{\\text{irq}} = 7$ 微秒。\n- 忽略任何其他延迟，如缓存效应或不可屏蔽中断，并假设除了所描述的活动之外没有并发活动。\n\n在时间 $t_0$，一个高优先级的用户线程变为就绪状态，而一个较低优先级的线程正在运行，并且刚刚进入了禁用抢占的内核临界区。另外，考虑一个硬件事件，它在内核开始屏蔽子区间的那一刻精确地引发一个中断。\n\n仅使用抢占式优先级调度、内核临界区、调度点和中断屏蔽的核心定义，推导并计算：\n\n1. 从 $t_0$ 到高优先级用户线程开始执行其第一条用户模式指令的最坏情况时间。\n2. 从硬件事件到达其 ISR 的第一条指令的最坏情况时间。\n\n两个最终答案都以微秒表示。无需四舍五入。你的最终答案应包含按上述顺序列出的两个数字，并放在单行中。", "solution": "该问题陈述已经过验证，被认为是合理的。它在科学上基于操作系统设计的原理，特别是实时调度和中断处理。这是一个适定问题，提供了计算所需延迟的所有必要参数，并且没有矛盾或含糊之处。\n\n该问题要求在一个具有抢占式、基于优先级的调度器的单核系统上进行两种不同的最坏情况延迟计算。\n\n**第1部分：高优先级用户线程的最坏情况延迟**\n\n我们需要计算从一个高优先级用户线程变为就绪状态的时刻（时间 $t_0$）到它开始执行其第一条用户模式指令的最坏情况时间。这也被称为分派延迟。\n\n该场景指定，在时间 $t_0$，一个较低优先级的线程正在运行，并且刚刚进入一个禁用抢占的内核临界区。这种禁用抢占状态的最坏情况持续时间为 $T_{\\text{crit}}$。\n\n1.  **等待抢占点：** 因为当前运行的较低优先级线程处于一个不可抢占的临界区中，所以新就绪的高优先级线程必须等待。由于低优先级线程*刚刚进入*这个区域，最坏情况的等待时间对应于整个临界区的持续时间，即 $T_{\\text{crit}}$。\n\n2.  **调度器开销：** 退出临界区后，内核到达一个调度点。它执行一次重新调度检查，发现一个更高优先级的线程已就绪。然后调用调度器进行决策。问题陈述指出，这个决策过程会产生 $T_{\\text{sched}}$ 的开销。\n\n3.  **上下文切换开销：** 在调度器决定运行高优先级线程后，操作系统必须执行一次上下文切换。这包括保存低优先级线程的状态和加载高优先级线程的状态。这个过程的开销为 $T_{\\text{cs}}$。\n\n高优先级线程的总最坏情况延迟（我们称之为 $L_{\\text{thread}}$）是这些顺序延迟的总和。组件 $T_{\\text{mask}}$ 和 $T_{\\text{irq}}$ 与此计算无关，因为它们涉及硬件中断处理，而不是线程抢占。\n\n总时间由以下总和给出：\n$$L_{\\text{thread}} = T_{\\text{crit}} + T_{\\text{sched}} + T_{\\text{cs}}$$\n\n代入给定值：\n$T_{\\text{crit}} = 84$ 微秒\n$T_{\\text{sched}} = 11$ 微秒\n$T_{\\text{cs}} = 19$ 微秒\n\n$$L_{\\text{thread}} = 84 \\mu s + 11 \\mu s + 19 \\mu s = 114 \\mu s$$\n\n所以，到高优先级线程开始执行的最坏情况时间是 $114$ 微秒。\n\n**第2部分：硬件中断的最坏情况延迟**\n\n我们需要计算从硬件事件到达时到其相应的中断服务程序（ISR）的第一条指令执行时的最坏情况时间。这是对中断延迟的一种度量。\n\n该场景指定，硬件事件在内核开始一个连续的屏蔽中断的子区间时精确地引发一个中断。这个屏蔽时段的最坏情况持续时间是 $T_{\\text{mask}}$。\n\n1.  **等待中断解除屏蔽：** 当中断到达时，CPU 的中断功能被禁用（屏蔽）。CPU 无法响应中断信号，并会推迟它。内核继续执行。由于中断在屏蔽区间的最初时刻到达，系统必须等待整个最坏情况的区间持续时间过去，中断才会被重新启用。这个时间是 $T_{\\text{mask}}$。\n\n2.  **中断进入延迟：** 一旦中断被解除屏蔽，CPU 的中断控制器将发出挂起的中断信号。然后，CPU 保存最小的上下文并跳转到相应 ISR 的起始位置。问题将从中断解除屏蔽到执行第一条 ISR 指令的延迟定义为 $T_{\\text{irq}}$。\n\nISR 的总最坏情况延迟（我们称之为 $L_{\\text{irq}}$）是这两个顺序延迟的总和。较大临界区的持续时间（$T_{\\text{crit}}$）和线程调度开销（$T_{\\text{sched}}$, $T_{\\text{cs}}$）与此无关。中断分派是一种硬件级机制，通常绕过线程调度器。一旦中断被解除屏蔽，CPU 就会将控制权转移到 ISR，而不管当时哪个线程正在运行。\n\n总时间由以下总和给出：\n$$L_{\\text{irq}} = T_{\\text{mask}} + T_{\\text{irq}}$$\n\n代入给定值：\n$T_{\\text{mask}} = 31$ 微秒\n$T_{\\text{irq}} = 7$ 微秒\n\n$$L_{\\text{irq}} = 31 \\mu s + 7 \\mu s = 38 \\mu s$$\n\n所以，从硬件事件到 ISR 开始的最坏情况时间是 $38$ 微秒。\n\n计算出的两个值是 $114$ 和 $38$，单位均为微秒。", "answer": "$$\\boxed{\\begin{pmatrix} 114 & 38 \\end{pmatrix}}$$", "id": "3688825"}, {"introduction": "在我们理解了基本延迟的基础上，现在我们来为一个包含多个线程的完整实时系统建模。本练习将向您介绍响应时间分析（Response Time Analysis, RTA），这是验证实时系统的基石。您将计算一个线程在考虑了高优先级任务的抢占干扰和低优先级任务的阻塞后的最坏情况响应时间。解决这个问题需要一种迭代方法，该方法也反映了实时性保证在工程实践中是如何被形式化确定的。[@problem_id:3688824]", "problem": "一个单处理器操作系统 (OS) 使用固定优先级抢占式调度策略，并带有短暂的不可抢占区域：当一个线程在不可抢占区域内执行时，抢占最多被禁用 $L_{\\mathrm{np}}$ 个时间单位。所有线程都是周期性的且相互独立。中央处理器 (CPU) 完全可供软件使用，没有直接内存访问或其他自治设备。\n\n系统中存在三个线程，其静态优先级从高到低排序为 $M \\succ H \\succ L$。线程 $M$ 是一个维护线程，其周期为 $T_{M}$，最坏情况执行时间 (WCET) 为 $C_{M}$；线程 $H$ 是我们关心的高优先级应用线程，其 WCET 为 $C_{H}$；线程 $L$ 是任意的低优先级后台活动。假设：\n- 在 $H$ 的一个作业被释放的瞬间，某个低优先级线程可能正在一个不可抢占区域内执行，因此 $H$ 在开始执行前可能被阻塞一次，时间最多为 $L_{\\mathrm{np}}$。\n- 在 $H$ 的响应窗口期间，$M$ 可能会到达并抢占 $H$，只要 $M$ 有待处理的工作，因为 $M$ 的优先级高于 $H$。\n- 除了不可抢占区域外，没有其他共享资源；除不可抢占性外，所有其他开销都可以忽略不计，并已包含在 WCET 参数中。\n- 假设 $M$ 和 $H$ 之间存在最坏情况下的相位关系，使得 $H$ 经历的延迟最大化。\n\n请从基本原理出发，利用固定优先级抢占式调度和有界不可抢占阻塞的定义，推导一个方程，用于描述 $H$ 的一个作业的响应时间（从其释放到完成所经过的时间）的上界，该方程需考虑到由不可抢占性引起的一次性阻塞以及所有来自 $M$ 的抢占。然后，使用以下参数评估此上界：\n- $C_{H} = 2.0~\\mathrm{ms}$，\n- $C_{M} = 0.8~\\mathrm{ms}$，\n- $T_{M} = 3.0~\\mathrm{ms}$，\n- $L_{\\mathrm{np}} = 0.3~\\mathrm{ms}$。\n\n请以毫秒为单位表示 $H$ 的最终响应时间，并将答案四舍五入到四位有效数字。", "solution": "首先将根据指定标准对问题进行验证。\n\n### 步骤 1：提取已知条件\n从问题陈述中逐字提取的已知条件如下：\n- 系统：单处理器操作系统 (OS)\n- 调度策略：固定优先级抢占式调度\n- 不可抢占区域：最大持续时间 $L_{\\mathrm{np}}$\n- 线程：周期性且独立的\n- CPU 可用性：完全可用，无 DMA 或其他自治设备\n- 线程优先级：$M \\succ H \\succ L$（从高到低）\n- 线程 M：周期 $T_{M}$，最坏情况执行时间 (WCET) $C_{M}$\n- 线程 H：WCET $C_{H}$\n- 线程 L：任何低优先级的后台活动\n- 阻塞：线程 $H$ 可能被一个低优先级线程阻塞一次，时间最多为 $L_{\\mathrm{np}}$。\n- 抢占：线程 $M$ 可能抢占 $H$。\n- 开销：所有其他开销均可忽略不计，并已包含在 WCET 中。\n- 相位：$M$ 和 $H$ 之间的最坏情况相位关系。\n- 任务 1：推导 $H$ 响应时间上界的方程。\n- 任务 2：使用给定参数评估此上界。\n- 参数：\n  - $C_{H} = 2.0~\\mathrm{ms}$\n  - $C_{M} = 0.8~\\mathrm{ms}$\n  - $T_{M} = 3.0~\\mathrm{ms}$\n  - $L_{\\mathrm{np}} = 0.3~\\mathrm{ms}$\n- 输出要求：最终响应时间以毫秒为单位，并四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n对该问题进行验证：\n- **科学依据：** 该问题牢固地建立在实时系统的既定理论之上，特别是关于固定优先级抢占式调度的理论。最坏情况执行时间 (WCET)、周期、优先级、抢占、阻塞和响应时间等概念在该领域都是标准术语。所描述的模型是响应时间分析 (RTA) 的一个经典场景。\n- **适定性：** 该问题是适定的。它要求推导一个标准方程，并使用一套完整的参数对其进行评估。目标明确，通过标准的 RTA 迭代方法可以获得唯一的稳定解。\n- **客观性：** 语言技术性强、精确，没有主观或模棱两可的陈述。\n- 问题是自洽的，没有缺失或矛盾的信息。数值参数对于实时嵌入式系统来说在物理上是合理的。\n\n### 步骤 3：结论与行动\n该问题有效。现在将提供完整的解决方案。\n\n### 解题推导\n问题要求计算线程 $H$ 的一个作业的最坏情况响应时间的上界，记为 $R_H$。响应时间是指从作业释放到其完成所经过的总时间。在一个固定优先级抢占式系统中，线程 $i$ 的响应时间由三部分组成：\n1.  其自身的最坏情况执行时间，$C_i$。\n2.  它可能被低优先级线程阻塞的最长时间，$B_i$。\n3.  抢占它的高优先级线程的总执行时间，称为干扰 (interference)，$I_i$。\n\n响应时间 $R_i$ 的通用方程是：\n$$R_i = C_i + B_i + I_i$$\n\n对于线程 $H$，这变为：\n$$R_H = C_H + B_H + I_H$$\n\n我们现在来确定线程 $H$ 的每个组成部分。\n\n**1. 执行时间 ($C_H$)：**\n线程 $H$ 的 WCET 已知为 $C_H$。\n\n**2. 阻塞时间 ($B_H$)：**\n问题陈述指出，线程 $H$ 在其执行开始时，可能被任何一个正在不可抢占区域内执行的低优先级线程 ($L$) 阻塞一次。这种区域的最大持续时间已知为 $L_{\\mathrm{np}}$。因此，线程 $H$ 的最大阻塞时间是：\n$$B_H = L_{\\mathrm{np}}$$\n\n**3. 干扰时间 ($I_H$)：**\n对线程 $H$ 的干扰是由高优先级线程的执行引起的。唯一优先级高于 $H$ 的线程是 $M$。为了计算最坏情况下的干扰，我们假设一个“临界时刻”，即 $H$ 的一个作业与每个更高优先级线程的一个作业同时释放。这种配置会使抢占最大化，从而使响应时间最大化。\n\n$H$ 的响应时间 $R_H$ 定义了一个我们必须考虑抢占的时间窗口。在这个长度为 $R_H$ 的时间间隔内，线程 $M$ 将被释放一定的次数。在时间间隔 $R_H$ 内可以释放并执行的 $M$ 的最大作业数由 $\\lceil \\frac{R_H}{T_M} \\rceil$ 给出，其中 $T_M$ 是 $M$ 的周期。\n\n$M$ 的每个作业最多执行其 WCET，$C_M$。因此，来自线程 $M$ 对线程 $H$ 的总干扰为：\n$$I_H = \\left\\lceil \\frac{R_H}{T_M} \\right\\rceil C_M$$\n\n**4. H 的响应时间方程：**\n将 $B_H$ 和 $I_H$ 的表达式代入 $H$ 的响应时间方程，我们得到描述其响应时间上界的方程：\n$$R_H = C_H + L_{\\mathrm{np}} + \\left\\lceil \\frac{R_H}{T_M} \\right\\rceil C_M$$\n这个方程是一个递归关系，因为 $R_H$ 出现在方程的两边。它可以用迭代方法求解。我们定义一个 $R_H$ 的近似序列，记为 $R_H^{(k)}$，其中 $k$ 是迭代索引（$k=0, 1, 2, \\dots$）。\n\n迭代公式为：\n$$R_H^{(k+1)} = C_H + L_{\\mathrm{np}} + \\left\\lceil \\frac{R_H^{(k)}}{T_M} \\right\\rceil C_M$$\n\n一个合适的迭代初始值 $R_H^{(0)}$ 是 $H$ 的执行时间加上任何阻塞，即假设没有干扰时的响应时间：\n$$R_H^{(0)} = C_H + L_{\\mathrm{np}}$$\n\n迭代继续，直到数值稳定，即 $R_H^{(k+1)} = R_H^{(k)}$。这个稳定值就是最坏情况响应时间。\n\n### 数值计算\n我们现在使用给定的参数来评估这个上界：\n- $C_{H} = 2.0~\\mathrm{ms}$\n- $C_{M} = 0.8~\\mathrm{ms}$\n- $T_{M} = 3.0~\\mathrm{ms}$\n- $L_{\\mathrm{np}} = 0.3~\\mathrm{ms}$\n\n**迭代 0：**\n用 $H$ 自身的执行时间和阻塞时间之和来初始化响应时间。\n$$R_H^{(0)} = C_H + L_{\\mathrm{np}} = 2.0 + 0.3 = 2.3~\\mathrm{ms}$$\n\n**迭代 1：**\n使用 $R_H^{(0)}$ 计算下一个估计值 $R_H^{(1)}$。\n$$R_H^{(1)} = C_H + L_{\\mathrm{np}} + \\left\\lceil \\frac{R_H^{(0)}}{T_M} \\right\\rceil C_M$$\n$$R_H^{(1)} = 2.0 + 0.3 + \\left\\lceil \\frac{2.3}{3.0} \\right\\rceil \\times 0.8$$\n$$R_H^{(1)} = 2.3 + \\lceil 0.766... \\rceil \\times 0.8$$\n$$R_H^{(1)} = 2.3 + 1 \\times 0.8 = 3.1~\\mathrm{ms}$$\n\n**迭代 2：**\n使用 $R_H^{(1)}$ 计算 $R_H^{(2)}$。\n$$R_H^{(2)} = C_H + L_{\\mathrm{np}} + \\left\\lceil \\frac{R_H^{(1)}}{T_M} \\right\\rceil C_M$$\n$$R_H^{(2)} = 2.0 + 0.3 + \\left\\lceil \\frac{3.1}{3.0} \\right\\rceil \\times 0.8$$\n$$R_H^{(2)} = 2.3 + \\lceil 1.033... \\rceil \\times 0.8$$\n$$R_H^{(2)} = 2.3 + 2 \\times 0.8 = 2.3 + 1.6 = 3.9~\\mathrm{ms}$$\n\n**迭代 3：**\n使用 $R_H^{(2)}$ 计算 $R_H^{(3)}$。\n$$R_H^{(3)} = C_H + L_{\\mathrm{np}} + \\left\\lceil \\frac{R_H^{(2)}}{T_M} \\right\\rceil C_M$$\n$$R_H^{(3)} = 2.0 + 0.3 + \\left\\lceil \\frac{3.9}{3.0} \\right\\rceil \\times 0.8$$\n$$R_H^{(3)} = 2.3 + \\lceil 1.3 \\rceil \\times 0.8$$\n$$R_H^{(3)} = 2.3 + 2 \\times 0.8 = 2.3 + 1.6 = 3.9~\\mathrm{ms}$$\n\n由于 $R_H^{(3)} = R_H^{(2)}$，迭代已经收敛。线程 $H$ 的最坏情况响应时间是 $R_H = 3.9~\\mathrm{ms}$。\n\n问题要求答案四舍五入到四位有效数字。数值 $3.9$ 写为 $3.900$ 以满足此要求。", "answer": "$$\\boxed{3.900}$$", "id": "3688824"}, {"introduction": "从固定优先级的世界转向现代的公平共享调度，本练习将挑战您模拟一个受Linux完全公平调度器（Completely Fair Scheduler, CFS）启发的调度器核心逻辑。您将首先推导“虚拟运行时间”的基本更新法则，然后通过编程实现一个仿真，以观察该机制如何在线程权重动态变化时依然能实现加权公平性。这项动手编码任务将让您深入了解当今最重要的调度算法之一。[@problem_id:3688841]", "problem": "您需要编写一个完整的程序，模拟一个基于虚拟运行时归一化原理的加权公平线程调度器，其精神源自于完全公平调度器 (Completely Fair Scheduler)。该模拟必须以纯粹的数学和逻辑术语表达，并且必须是自包含的。线程始终处于可运行状态，每个线程 $i$ 都有一个权重 $w_i$，该权重可以在预定义的阶段中随时间变化，调度器为每个线程维护一个虚拟运行时 $v_i$，并且在每次调度决策时，它会选择 $v_i$ 最小的线程（平局必须通过最小的索引 $i$ 来确定性地打破）。模拟以离散的时间量子运行，每个时间量子的大小为 $q$ 毫秒。程序中所有的时间单位都必须视为毫秒，所有输出都必须表示为四舍五入到 $6$ 位小数的无单位小数分数。\n\n基本定义和事实：\n- 加权处理器共享要求，在任何权重固定的区间内，分配给线程 $i$ 的处理时间比例与其权重 $w_i$ 成正比。如果有 $N$ 个权重为 $w_1,\\dots,w_N$ 的线程，那么线程 $i$ 的理想份额分数为 $s_i = \\dfrac{w_i}{\\sum_{j=1}^{N} w_j}$。等效地，在一个持续时间为 $\\Delta t$ 的小区间内，线程 $i$ 应获得 $\\Delta a_i = \\Delta t \\cdot s_i$ 个单位的处理时间。\n- 虚拟运行时 $v_i$ 充当一种平衡势能：调度器总是选择 $v_i$ 最小的线程。为了实现与加权处理器共享相匹配的公平性，执行期间 $v_i$ 的更新法则必须从上述不变性原理推导得出，并且必须确保低权重线程比高权重线程更快地累积 $v_i$。\n- 总时间 $T$ 是所有阶段持续时间的总和。对于权重可以按阶段变化的工作负载，线程 $i$ 的理想累积处理时间 $I_i$ 是 $s_i$ 在整个执行过程中的时间积分：通过具有恒定权重的阶段进行分段积分。实际累积处理时间 $A_i$ 是为线程 $i$ 执行的离散量子的总和。\n\n您的程序必须：\n1. 根据加权处理器共享的不变性和虚拟运行时选择的定义，推导出当线程 $i$ 运行时，在一个持续时间为 $q$ 的执行量子内 $v_i$ 的一致性更新法则。\n2. 针对一组权重跨阶段变化的测试工作负载模拟调度器：\n   - 在时间 $t=0$ 时，为所有线程初始化 $v_i = 0$。\n   - 对于每个持续时间为 $D_p$ 毫秒且权重向量恒为 $\\{w_i^{(p)}\\}_{i=1}^N$ 的阶段 $p$，执行 $D_p / q$ 次大小为 $q$ 毫秒的离散调度决策。\n   - 在每次决策时，选择 $v_i$ 最小的线程（若出现平局，则由最小的索引 $i$ 打破），运行它 $q$ 毫秒，根据您推导的法则更新其 $v_i$，并使用份额 $s_i^{(p)} = \\dfrac{w_i^{(p)}}{\\sum_{j=1}^{N} w_j^{(p)}}$ 在 $q$ 毫秒内更新所有线程的理想累积时间 $I_i$。\n3. 在最后一个阶段之后，计算公平性差距\n   $$G = \\max_{i \\in \\{1,\\dots,N\\}} \\frac{\\left|A_i - I_i\\right|}{T},$$\n   这是一个无单位的小数分数。\n\n要实现的测试套件和参数：\n- 对所有案例使用 $q = 1$ 毫秒的调度量子。\n- 案例 1 (理想路径，权重相等)：$N = 2$，阶段数 $P = 1$，持续时间 $\\{D_1\\} = \\{40\\}$ 毫秒，每阶段权重 $\\{w^{(1)}\\} = \\{10, 10\\}$。\n- 案例 2 (动态权重，整型友好)：$N = 3$，$P = 2$，持续时间 $\\{D_1, D_2\\} = \\{60, 40\\}$ 毫秒，每阶段权重 $\\{w^{(1)}\\} = \\{1, 2, 3\\}$ 和 $\\{w^{(2)}\\} = \\{3, 1, 1\\}$。\n- 案例 3 (极端不平衡，边界覆盖)：$N = 4$，$P = 2$，持续时间 $\\{D_1, D_2\\} = \\{50, 50\\}$ 毫秒，每阶段权重 $\\{w^{(1)}\\} = \\{1, 1, 50, 1\\}$ 和 $\\{w^{(2)}\\} = \\{1, 50, 1, 1\\}$。\n\n最终输出规范：\n- 您的程序必须生成一个单行，其中包含一个逗号分隔的列表，用方括号括起每个案例的公平性差距 $G$，顺序为案例 1、案例 2、案例 3，四舍五入到 $6$ 位小数。例如，输出格式必须严格为 $[g_1,g_2,g_3]$ 的形式，其中每个 $g_k$ 是一个四舍五入到 $6$ 位的小数。", "solution": "问题陈述已经过分析，并被确定为**有效**。它在科学上基于操作系统调度理论的原理，问题设定良好，条件清晰明确，并以客观、可形式化的语言表达。模拟所需的所有数据均已提供。\n\n### 1. 虚拟运行时更新法则的推导\n\n加权公平调度器的目标是为一组竞争线程 $\\{1, \\dots, N\\}$ 分配处理时间，使得每个线程 $i$ 获得的时间部分与其分配的权重 $w_i$ 成正比。在给定的时间间隔内，线程 $i$ 的理想处理器份额由 $s_i = \\frac{w_i}{\\sum_{j=1}^{N} w_j}$ 给出。\n\n调度器为每个线程使用一个虚拟运行时 $v_i$。在任何调度点，具有最小虚拟运行时的线程被选择执行。此机制确保在“归一化”意义上运行较少的线程被优先处理，从而驱动系统趋向于公平状态。\n\n为了建立 $v_i$ 的更新法则，我们必须将线程运行的物理时间与其虚拟运行时的增加联系起来。假设线程 $k$ 被选中运行一个持续时间为 $q$ 的离散时间量子。它的实际物理运行时增加了 $q$。为使系统公平，此次执行的“成本”（由其虚拟运行时增加量 $\\Delta v_k$ 表示）必须根据其权重 $w_k$ 进行缩放。\n\n权重较高的线程 $w_k$ 有权获得更多的处理器时间。因此，对于相同的物理执行时间，其虚拟运行时的累积速度应慢于权重较低的线程。这意味着虚拟运行时累积速率与权重之间存在反比关系。\n\n此原理最直接和最基本的表述是将虚拟运行时的增加定义为所经过的物理时间，并按线程权重的倒数进行缩放。因此，当线程 $k$ 执行一个量子 $q$ 时，其虚拟运行时的更新为：\n$$\n\\Delta v_k = \\frac{q}{w_k}\n$$\n新的虚拟运行时则为：\n$$\nv_k \\leftarrow v_k + \\frac{q}{w_k}\n$$\n所有其他未执行线程 $j \\neq k$ 的虚拟运行时在此量子期间保持不变。\n\n这个更新法则保证了加权公平性。例如，考虑两个权重为 $w_a$ 和 $w_b$ 的线程。它们虚拟运行时增加的速率分别为 $\\frac{q}{w_a}$ 和 $\\frac{q}{w_b}$。为了让调度器长期保持它们的虚拟运行时大致相等（即 $v_a \\approx v_b$），分配的总物理时间 $A_a$ 和 $A_b$ 必须满足 $\\frac{A_a}{w_a} \\approx \\frac{A_b}{w_b}$，这可以简化为 $\\frac{A_a}{A_b} \\approx \\frac{w_a}{w_b}$。这正是加权处理器共享的定义。\n\n### 2. 模拟算法\n\n模拟通过根据指定的规则对系统的离散时间演化进行建模来进行。\n\n**初始化：**\n1.  对于一个给定的有 $N$ 个线程的工作负载，为每个线程 $i \\in \\{1, \\dots, N\\}$ 初始化虚拟运行时 $v_i$、实际累积时间 $A_i$ 和理想累积时间 $I_i$ 为 $0$。\n    $$\n    v_i = 0, \\quad A_i = 0, \\quad I_i = 0 \\quad \\forall i \\in \\{1, \\dots, N\\}\n    $$\n2.  初始化总模拟时间 $T$ 为 $0$。调度量子固定为 $q=1$ 毫秒。\n\n**执行循环：**\n模拟通过一系列阶段 $p \\in \\{1, \\dots, P\\}$ 进行。对于每个阶段 $p$：\n1.  确定阶段持续时间 $D_p$ 和恒定权重向量 $\\{w_i^{(p)}\\}_{i=1}^N$。\n2.  将阶段持续时间加到总时间上：$T \\leftarrow T + D_p$。\n3.  计算当前阶段的权重总和：$W_{sum}^{(p)} = \\sum_{j=1}^{N} w_j^{(p)}$。\n4.  计算每个线程 $i$ 的理想份额分数：$s_i^{(p)} = w_i^{(p)} / W_{sum}^{(p)}$。\n5.  执行一个循环 $D_p/q$ 次，代表该阶段内的离散时间量子。在每次迭代中：\n    a. **选择线程：** 找到使虚拟运行时最小化的线程索引 $k$。\n       $$\n       k = \\arg\\min_{j \\in \\{1, \\dots, N\\}} \\{v_j\\}\n       $$\n       如果多个线程具有相同的最小虚拟运行时，则通过选择索引 $j$ 最小的线程来打破平局。\n    b. **更新实际时间：** 为选定的线程 $k$ 增加实际时间。\n       $$\n       A_k \\leftarrow A_k + q\n       $$\n    c. **更新虚拟运行时：** 使用选定线程 $k$ 的当前阶段权重 $w_k^{(p)}$ 来更新其虚拟运行时。\n       $$\n       v_k \\leftarrow v_k + \\frac{q}{w_k^{(p)}}\n       $$\n    d. **更新理想时间：** 对于**所有**线程 $j \\in \\{1, \\dots, N\\}$，根据它们在当前阶段的份额来增加其理想累积时间。\n       $$\n       I_j \\leftarrow I_j + q \\cdot s_j^{(p)}\n       $$\n\n**最终计算：**\n在所有阶段都模拟完毕后：\n1.  计算公平性差距 $G$，定义为所有线程的实际累积时间与理想累积时间之间的最大归一化偏差。\n    $$\n    G = \\max_{i \\in \\{1,\\dots,N\\}} \\frac{\\left|A_i - I_i\\right|}{T}\n    $$\n对提供的每个测试案例执行模拟，并报告最终的公平性差距 $G$。案例 1 和 2 的特定权重和持续时间被选择得使得完美的、零误差的调度成为可能，从而导致 $G=0$。案例 3 使用的参数中，阶段持续时间不是公平性周期长度的倍数，这导致在阶段边界处出现非零差距，因此最终的 $G$ 也非零。", "answer": "$$\\boxed{[0.000000, 0.000000, 0.001132]}$$", "id": "3688841"}]}