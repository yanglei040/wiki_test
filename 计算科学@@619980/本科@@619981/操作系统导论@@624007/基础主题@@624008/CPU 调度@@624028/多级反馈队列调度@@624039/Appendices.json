{"hands_on_practices": [{"introduction": "选择时间片长度是调度器设计中的一个基本权衡。较大的时间片可以通过减少上下文切换的开销来提高系统吞吐量，但较小的时间片对于保证交互式任务的低延迟至关重要。[@problem_id:3660269] 这个练习将引导你进入一个具体的场景，通过计算在满足特定延迟约束 $T_{\\text{resp}}$ 的同时，能够最大化吞吐量的最优时间片长度 $Q_{0}$。", "problem": "单个中央处理器 (CPU) 运行一个多级反馈队列 (MLFQ) 调度器。其最高优先级队列对所有较低优先级队列拥有严格优先权，并使用轮询方式对任务进行时间分片。最高优先级队列的时间量为 $Q_{0}$ 个时钟周期。调度器的时钟频率为每秒 $f$ 个时钟周期，因此一个时钟周期持续 $1/f$ 秒。每当一个时间片结束且调度器选择下一个任务时，系统会产生 $c$ 秒的上下文切换成本。假设由于有 $n$ 个始终就绪的交互式任务，最高优先级队列持续非空，并且严格优先级确保了较低优先级的队列不会干扰最高优先级队列的时序。\n\n采用以下定义和假设：\n- 吞吐量是指在最高优先级队列持续繁忙时，用于有效任务执行（而非上下文切换）的时间在长期运行中所占的比例。\n- 对于最高优先级队列中的一个交互式任务，其最坏情况响应时间是指，在 $n$ 个最高优先级队列任务的轮询调度下，从该任务变为就绪状态到其下一次在最高优先级队列中获得 CPU 服务开始之间的最大可能时间。\n\n给定 $f = 1000$ 时钟周期/秒，$c = 3.0 \\times 10^{-4}$ 秒，$n = 6$，以及交互式延迟要求 $T_{\\text{resp}} \\le X$，其中 $X = 2.0 \\times 10^{-2}$ 秒。请选择 $Q_{0}$ 以在满足最高优先级队列延迟约束的条件下最大化吞吐量。将最优的 $Q_{0}$ 报告为整数个时钟周期。最终答案必须是一个不带单位的数字。", "solution": "问题要求解多级反馈队列 (MLFQ) 调度器中最高优先级队列的最优时间量 $Q_0$。优化目标是在满足该队列中任务的最坏情况响应时间约束的前提下，最大化吞吐量。$Q_0$ 必须是整数个时钟周期。\n\n首先，我们根据给定参数将调度器的性能指标形式化。给定参数如下：\n- 时钟频率，$f = 1000$ 时钟周期/秒。\n- 上下文切换成本，$c = 3.0 \\times 10^{-4}$ 秒。\n- 最高优先级队列中始终就绪的任务数量，$n = 6$。\n- 允许的最大最坏情况响应时间，$X = 2.0 \\times 10^{-2}$ 秒。\n\n最高优先级队列的时间量为 $Q_0$ 个时钟周期。这个时间量以秒为单位的持续时间，记为 $T_Q$，由时钟周期数除以时钟频率得出：\n$$\nT_Q = \\frac{Q_0}{f}\n$$\n\n接下来，我们构建吞吐量的表达式。吞吐量，记为 $\\eta$，定义为 CPU 用于有效任务执行的时间（相对于上下文切换开销）所占的比例。在一个队列非空的轮询系统中，CPU 重复执行持续时间为 $T_Q$ 的任务，然后进行持续时间为 $c$ 的上下文切换。这样一个任务“切片”及其后续上下文切换的总时间为 $T_Q + c$。这段时间中用于有效工作的部分是：\n$$\n\\eta = \\frac{T_Q}{T_Q + c}\n$$\n将 $T_Q$ 的表达式用 $Q_0$ 代入：\n$$\n\\eta(Q_0) = \\frac{Q_0/f}{Q_0/f + c} = \\frac{Q_0}{Q_0 + fc}\n$$\n为了最大化吞吐量，我们分析 $\\eta$ 如何随 $Q_0$ 变化。我们可以考察 $\\eta$ 对 $Q_0$ 的导数：\n$$\n\\frac{d\\eta}{dQ_0} = \\frac{(1)(Q_0 + fc) - Q_0(1)}{(Q_0 + fc)^2} = \\frac{fc}{(Q_0 + fc)^2}\n$$\n因为 $f > 0$ 且 $c > 0$，所以对于任何非负的 $Q_0$，导数 $\\frac{d\\eta}{dQ_0}$ 总是正的。这表明吞吐量 $\\eta(Q_0)$ 是 $Q_0$ 的单调递增函数。因此，为了最大化吞吐量，我们必须选择满足给定约束条件的 $Q_0$ 的最大可能值。\n\n现在，我们构建最坏情况响应时间 $T_{\\text{resp}}$ 的表达式。问题将其定义为从任务变为就绪状态到其下一次 CPU 服务开始之间的最大可能时间。对于最高优先级队列中的 $n=6$ 个始终就绪的任务，一个任务在其上一个时间量用尽的瞬间再次变为就绪状态。为了确定其下一次服务开始前的等待时间，我们必须考虑所有其他任务的执行以及相关的上下文切换。\n\n考虑一个刚刚完成其时间量的任务，任务 A。它在就绪队列中等待，同时其他 $n-1$ 个任务被服务。在任务 A 能够再次运行之前，事件序列如下：\n1. 从任务 A 到队列中下一个任务的上下文切换。\n2. 下一个任务运行其时间量 $T_Q$。\n3. 这种（上下文切换，任务执行）的模式对所有其他 $n-1$ 个任务重复进行。\n4. 最后，发生一次上下文切换，将任务 A 调回 CPU。任务 A 的服务只有在这次最终的上下文切换完成后才开始。\n\n这个等待期的总持续时间包括其他 $n-1$ 个任务的执行时间以及发生的所有上下文切换的时间。在一个完整的轮转中，每个 $n$ 个任务都有一次上下文切换。因此，总等待时间是 $(n-1)$ 个时间量和 $n$ 次上下文切换的总和：\n$$\nT_{\\text{resp}} = (n-1)T_Q + nc\n$$\n代入 $T_Q = Q_0/f$：\n$$\nT_{\\text{resp}}(Q_0) = (n-1)\\frac{Q_0}{f} + nc\n$$\n问题施加了一个延迟约束：$T_{\\text{resp}} \\le X$。我们现在可以为 $Q_0$ 建立一个上界：\n$$\n(n-1)\\frac{Q_0}{f} + nc \\le X\n$$\n求解 $Q_0$：\n$$\n(n-1)\\frac{Q_0}{f} \\le X - nc\n$$\n$$\nQ_0 \\le \\frac{f(X - nc)}{n-1}\n$$\n由于我们的目标是最大化 $Q_0$，我们应该选择此不等式允许的最大值。由于 $Q_0$ 必须是整数个时钟周期，最优值是右侧表达式的向下取整。\n$$\nQ_{0, \\text{optimal}} = \\left\\lfloor \\frac{f(X - nc)}{n-1} \\right\\rfloor\n$$\n现在，我们代入给定的数值：\n- $f = 1000$\n- $c = 3.0 \\times 10^{-4}$\n- $n = 6$\n- $X = 2.0 \\times 10^{-2}$\n\n首先，计算项 $nc$：\n$$\nnc = 6 \\times (3.0 \\times 10^{-4}) = 18.0 \\times 10^{-4} = 0.0018 \\text{ 秒}\n$$\n接下来，计算分子 $f(X-nc)$：\n$$\nf(X - nc) = 1000 \\times (2.0 \\times 10^{-2} - 0.0018) = 1000 \\times (0.02 - 0.0018) = 1000 \\times 0.0182 = 18.2\n$$\n分母是 $n-1 = 6-1=5$。\n现在我们可以求出 $Q_0$ 的最大值：\n$$\nQ_0 \\le \\frac{18.2}{5} = 3.64\n$$\n因为 $Q_0$ 必须是整数个时钟周期，满足此约束的最大整数值为 $\\lfloor 3.64 \\rfloor$。\n$$\nQ_{0, \\text{optimal}} = 3\n$$\n因此，最高优先级队列的最优时间量是 $3$ 个时钟周期。这个值在确保最坏情况响应时间不超过指定限制的同时，最大化了吞吐量。", "answer": "$$\\boxed{3}$$", "id": "3660269"}, {"introduction": "理论上完美的调度算法在现实中可能会被“聪明”的进程所利用，这种行为被称为“游戏调度器”。本练习模拟了这样一个场景：一个进程通过在时间片耗尽前主动放弃CPU来避免被降级，从而“欺骗”MLFQ调度器。[@problem_id:3660276] 它挑战你像操作系统设计者一样思考，评估不同的策略，以设计一个更稳健的调度器，能够准确识别并处理那些试图伪装成交互式任务的CPU密集型任务。", "problem": "一个操作系统使用一个具有多个优先级队列的多级反馈队列（MLFQ）调度器。最高优先级队列的时间量为 $q$ 毫秒。根据设计，一个用满其全部 $q$ 时间量的进程会被降级到较低优先级的队列，而一个在用满全部 $q$ 时间量之前让出处理器的进程则保留在最高优先级队列中。MLFQ的目标是优先服务交互式任务，同时允许长时间运行的中央处理器（CPU）密集型任务的优先级随时间逐渐降低。考虑一个进程 $P$，它在每次调度中故意在时间 $q - \\varepsilon$（对于某个小的 $\\varepsilon \\in (0, q)$）时让出，以避免被降级，但它非常频繁地重复此行为，在墙上时钟时间内消耗了大部分CPU时间。为了对抗这种投机行为，同时为真正的交互式任务保留MLFQ的响应性，调度器设计者提议跟踪一个反映近期CPU消耗的、每个进程独有的CPU“信用” $C$，并在 $C$ 超过阈值 $\\kappa$ 时降级一个进程，即使该进程在消耗完一个完整的时间量之前频繁让出。\n\n您被告知以下基本事实和定义：\n- MLFQ通过根据观察到的近期行为而非生命周期行为来调整优先级，以模拟最短作业优先的偏向，从而为交互式任务实现低响应时间。\n- 任何仅基于“进程是否消耗了完整时间量”来决定降级的机制，都可能被主动让出行为所利用；因此，降级决策必须与近期的墙上时鐘时间内的CPU使用率相关，并且不能因让出而被重置。\n- 操作系统必须实现该规则，其每个进程的状态和更新成本的界限为每次时钟滴答 $O(1)$ 和每次调度事件 $O(1)$，且与任何可调窗口长度参数无关。\n- 交互式任务的特点是短暂、不频繁的CPU突发，并由输入/输出（I/O）等待隔开；CPU密集型任务则在近期表现出持续的CPU使用，很少或没有I/O等待。\n\n假设 $q = 10$ 毫秒，并且进程 $P$ 在每次调度中于 $q - 1$ 毫秒时让出，并频繁重复。假设设计者想要一个策略，对于一个约 $W = 200$ 毫秒的可调“近期性尺度”和一个 $\\kappa = 60$ 毫秒的阈值，该策略会降级进程 $P$（尽管它频繁让出），但不会降级一个每 $200$ 毫秒使用约 $5$ 毫秒CPU时间的真正交互式任务。\n\n以下哪条候选规则在定义和操作 $C$ 方面最能实现所述目标和约束？\n\nA. 将 $C$ 定义为一个进程自创建以来使用的累积CPU时间。一旦 $C > \\kappa$ 就立即降级；$C$ 永远不会减少，也永远不会被重置。\n\nB. 将 $C$ 定义为最近一个 $W$ 毫秒墙上时钟时间的滑动窗口中使用的总CPU时间，在每一毫秒都通过一个移动窗口精确更新。只要 $C > \\kappa$ 就降级；仅允许通过系统的周期性全局优先级提升来重新升级。\n\nC. 将 $C$ 定义为自上次调度以来使用的CPU时间。每次主动让出时将 $C$ 重置为 $0$。当且仅当在抢占或让出时 $C \\ge \\kappa$ 才降级。\n\nD. 将 $C$ 定义为过去 $W$ 毫秒内主动让出的次数。当次数超过一个固定阈值时降级，理由是频繁让出表明存在投机行为。\n\nE. 将 $C$ 定义为近期墙上时钟时间内CPU使用率的指数加权移动平均（EWMA）：在每个长度为 $\\tau$ 的调度器滴答时，更新 $C \\leftarrow \\lambda C + (1 - \\lambda) U$，其中 $U \\in \\{0, 1\\}$ 表示进程在上一个滴答期间是否使用了CPU，且 $\\lambda \\approx e^{-\\tau / W}$。当 $C \\cdot W > \\kappa$ 时降级，并在 $C \\cdot W$ 衰减到 $\\kappa$ 以下时允许升级，无论让出或休眠；休眠导致 $U = 0$，因此 $C$ 在I/O等待期间会衰减。\n\n在给定的目标和约束下选择最佳选项。提供一个基于MLFQ基本原则和所述实现约束的简要理由。可能存在不止一个合理的规则，但请选择满足所有约束并在所述数值场景中实现预期行为的那个。", "solution": "在进行求解之前，先分析问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n- **调度器类型**：多级反馈队列（MLFQ）。\n- **最高优先级队列时间量**：$q$ 毫秒。\n- **标准降级规则**：如果一个进程用满了它的完整时间量 $q$，它就会被降级。\n- **标准保留规则**：如果一个进程在用完完整时间量 $q$ 之前让出，它将保持在其优先级级别。\n- **目标**：优先服务交互式任务；让CPU密集型任务逐渐降至较低优先级。\n- **待解决的问题**：一个进程 $P$ 通过重复使用几乎完整的时间量（$q - \\varepsilon$）然后让出以避免降级的方式来“钻”调度器的“空子”，从而垄断CPU。这里 $\\varepsilon$ 是一个小的正时间，$\\varepsilon \\in (0, q)$。\n- **提议的解决方案框架**：引入一个CPU“信用”度量 $C$。如果 $C$ 超过一个阈值 $\\kappa$，进程将被降级，无论它是否完成了一个完整的时间量。\n- **基本原则与约束**：\n    1.  调度器必须基于*近期*行为而非生命周期行为进行调整。\n    2.  降级决策必须基于近期的墙上时鐘时间内的CPU使用情况，并且*不能*因主动让出而被重置。\n    3.  实现的计算成本必须是每次时钟滴答 $O(1)$ 和每次调度事件 $O(1)$，并且存储和计算成本与任何可调窗口长度参数无关。\n    4.  交互式任务的定义是短暂、不频繁的CPU突发。CPU密集型任务具有持续的CPU使用。\n- **数值场景**：\n    - 时间量 $q = 10$ 毫秒。\n    - 投机进程 $P$ 在 $t = q - 1 = 9$ 毫秒时让出。\n    - 可调的“近期性尺度”：$W = 200$ 毫秒。\n    - CPU使用阈值：$\\kappa = 60$ 毫秒。\n    - 一个真正的交互式任务每 $200$ 毫秒使用约 $5$ 毫秒的CPU，并且不应被降级。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述在操作系统调度算法这一成熟领域，特别是在MLFQ方面，具有科学依据。所描述的“投机”场景是朴素MLFQ实现的一个已知弱点。所提供的约束，如 $O(1)$ 的更新成本，是操作系统内核设计中现实且关键的考量。该问题定义良好，提供了明确的目标（降级投机者，保护交互式任务）、用于测试案例的明确数值参数以及一组不同的算法选项以供评估。语言客观且技术性强。该问题不违反任何无效性标准。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将通过对照所述目标和约束评估每个选项来推导解决方案。\n\n### 解题推导与选项分析\n\n一个成功规则的核心要求是：\n1.  **对抗投机行为的有效性**：它必须能降级进程 $P$，该进程频繁使用CPU，以至于在 $200$ 毫秒的墙上时钟周期内累积使用超过 $60$ 毫秒。\n2.  **保护交互性**：它**不能**降级一个在 $200$ 毫秒周期内仅使用 $5$ 毫秒CPU的任务。\n3.  **遵守原则**：该度量必须反映*近期*的CPU使用情况，且不因主动让出而被重置。\n4.  **性能约束**：更新机制的时间和空间复杂度必须为 $O(1)$，且与窗口大小 $W$ 无关。\n\n**选项A分析：**\n- **规则**：$C$ 是自进程创建以来的累积CPU时间。当 $C > \\kappa$ 时降级。\n- **评估**：此规则最终会在投机进程 $P$ 的总CPU使用量超过 $\\kappa = 60$ 毫秒时将其降级。然而，它也会降级任何长时间运行的交互式任务。一个每 $200$ 毫秒使用 $5$ 毫秒CPU的交互式进程，在 $13$ 次这样的突发后（在 $2.6$ 秒内总共使用 $65$ 毫秒CPU），就会被降级，尽管其近期行为完全是交互式的。这违反了MLFQ应适应*近期*行为而非生命周期历史的基本原则。\n- **结论**：**不正确**。\n\n**选项B分析：**\n- **规则**：$C$ 是过去 $W = 200$ 毫秒墙上时钟时间的精确滑动窗口中使用的CPU时间总和。当 $C > \\kappa$ 时降级。\n- **评估**：这个规则在概念上是理想的。对于投机进程 $P$，如果在任何 $200$ 毫秒区间内消耗超过 $60$ 毫秒的CPU，它将被降级。对于交互式进程，它在任何 $200$ 毫秒窗口内的使用量约为 $5$ 毫秒，小于 $\\kappa = 60$ 毫秒，因此不会被降级。这满足了行为目标。然而，实现约束是“在每一毫秒都通过一个移动窗口精确更新”。这将需要存储过去 $200$ 毫秒每一毫秒的使用情况，例如，在一个大小为 $200$ 的循环缓冲区中。该数据结构的内存需求为 $O(W)$。这违反了实现成本必须与可调参数 $W$ 无关的严格约束。\n- **结论**：**不正确**。\n\n**选项C分析：**\n- **规则**：$C$ 是自上次调度以来使用的CPU时间，每次主动让出时重置为 $0$。如果 $C \\ge \\kappa$ 则降级。\n- **评估**：这个规则有根本性缺陷。投机进程 $P$ 运行 $9$ 毫秒然后主动让出。在让出时，其当前的CPU使用量为 $C = 9$ 毫秒。由于 $9  60$，它不会被降级。然后规则将 $C$ 重置为 $0$。这个机制正是该进程所利用的。该规则明确允许投机行为成功，并直接与“降级决策‘不能因让出而被重置’”的要求相矛盾。\n- **结论**：**不正确**。\n\n**选项D分析：**\n- **规则**：$C$ 是过去 $W$ 毫秒内主动让出的次数。如果次数超过一个阈值则降级。\n- **评估**：此规则试图通过惩罚症状（频繁让出）而非根本原因（高CPU消耗）来解决问题。虽然它可能会降级进程 $P$，但这是一种脆弱的启发式方法。首先，它将主动让出（例如 `sched_yield`）与I/O阻塞混为一谈，而后者是真正交互式进程的行为。如果I/O阻塞被计为让出，交互式进程将受到不公平的惩罚。如果不计，投机进程可以轻易地通过执行一个微不足道的、快速的I/O操作来代替让出，从而在此规则下显得像交互式进程。最重要的是，此规则未能满足“降级决策必须与近期的墙上时钟时间内的CPU使用率相关”的指定要求。\n- **结论**：**不正确**。\n\n**选项E分析：**\n- **规则**：$C$ 是CPU使用率的指数加权移动平均（EWMA）。在每个滴答 $\\tau$ 时更新：$C \\leftarrow \\lambda C + (1 - \\lambda) U$，其中 $U \\in \\{0, 1\\}$ 表示进程在该滴答期间的CPU使用情况，且 $\\lambda \\approx e^{-\\tau / W}$。当 $C \\cdot W > \\kappa$ 时降级。\n- **评估**：\n    - **性能约束**：每次滴答的更新需要一次乘法和一次加法，这是 $O(1)$ 的计算量。每个进程所需的状态是一个浮点数 $C$，这是 $O(1)$ 的空间。两者都与 $W$ 无关。这满足了性能约束。\n    - **遵守原则**：让出不会重置 $C$；它仅仅结束了进程的 $U=1$ 的时期。根据其移动平均的定义，$C$ 跟踪了近期的CPU使用情况。当一个进程为I/O休眠时，$U=0$，导致 $C$ 指数级衰减。这正确地模拟了交互式任务的行为，并允许一个被降级的进程在其行为改变后再次被升级。\n    - **有效性**：项 $C$ 近似表示进程在近期运行的时间比例。降级条件 $C \\cdot W > \\kappa$ 将估算的近期CPU使用量（时间窗口 $W$ 的 $C$ 比例）与阈值 $\\kappa$进行比较。\n        - **投机进程 $P$**：此进程具有高占空比。如果它在每（比如说）$15$ 毫秒中使用 $9$ 毫秒的CPU，其占空比为 $9/15 = 0.6$。EWMA值 $C$ 将收敛到约 $0.6$。检查变为 $C \\cdot W \\approx 0.6 \\cdot 200 = 120$ 毫秒。由于 $120 > \\kappa = 60$，该进程被正确降级。\n        - **交互式进程**：此进程每 $200$ 毫秒使用 $5$ 毫秒CPU。其占空比为 $5/200 = 0.025$。其EWMA值 $C$ 将收敛到约 $0.025$。检查变为 $C \\cdot W \\approx 0.025 \\cdot 200 = 5$ 毫秒。由于 $5  \\kappa = 60$，该进程被正确地保护免于降级。\n    - EWMA是一种标准的、计算上高效的技术，用于近似滑动窗口平均值（如选项B中），同时满足严格的 $O(1)$ 复杂度约束。它满足了所有要求。\n- **结论**：**正确**。", "answer": "$$\\boxed{E}$$", "id": "3660276"}, {"introduction": "调度器并非孤立运行，它必须与操作系统中的其他机制（如锁）进行复杂的交互。本练习探讨了“优先级反转”这一关键问题，即一个高优先级任务被一个持有必要资源的低优先级任务阻塞。[@problem_id:3660203] 通过分析一个有界的优先级“捐赠”机制，你将揭示其潜在的缺陷，并深入理解调度、同步和资源竞争之间复杂的相互作用。", "problem": "一个系统使用多级反馈队列（MLFQ）调度器，其具有以下属性，这些属性基于抢占式优先级调度和时间分片的标准定义。系统有$3$个队列：$Q_0$（最高优先级）、$Q_1$和$Q_2$（最低优先级）。该策略严格按队列级别进行抢占：任何在较高优先级队列中的就绪任务都会抢占较低优先级队列中的任务。在单个队列内部，任务使用带有固定时间量的轮询（RR）算法进行调度。各队列的时间量分别为：$Q_0$为$q_0 = 5\\,\\mathrm{ms}$，$Q_1$为$q_1 = 10\\,\\mathrm{ms}$，$Q_2$为$q_2 = 20\\,\\mathrm{ms}$。假设系统有单个中央处理器（CPU），并且上下文切换开销可忽略不计（为分析方便，假设为$0$）。\n\n该系统采用基于快速用户空间互斥锁（futex）的锁，并支持跨MLFQ级别的优先级捐赠：如果$Q_0$中的任务$H$试图锁定一个由较低优先级队列中的任务$L$持有的互斥锁，那么$L$将临时继承提升到$Q_0$的优先级。捐赠是有限的：由于此捐赠，锁持有者$L$在$Q_0$级别运行时，被授予最多为$W$的累积CPU时间预算。当$H$阻塞时，捐赠在下一次调度决策时立即开始，并将$L$置于$Q_0$就绪队列的头部。预算$W$仅在$L$运行时才减少（也就是说，其他任务运行所经过的墙上时钟时间不会减少$W$）。当$L$释放互斥锁或其捐赠的CPU预算$W$耗尽时，捐赠结束。对于每次连续的锁持有，最多只授予$L$一个捐赠窗口（在锁被释放并重新获取之前，不会再次进行捐赠）。\n\n考虑以下基于这些定义的场景：\n- 在时间$t = 0$时，任务$L$位于$Q_2$队列中并已持有一个互斥锁；其剩余临界区长度需要$C$个单位的CPU时间（假设$C$已知）。\n- 在时间$t = 0$时，$Q_0$中的任务$H$试图获取该互斥锁并因$L$持有的futex而阻塞，从而触发了上述有界捐赠。\n- 在时间$t = 0$时，$Q_0$中还有一个与互斥锁无关的独立任务$R$，该任务始终处于就绪状态（CPU密集型）。任务$R$在任何时候都保持就绪且永不阻塞。\n- 系统中没有其他任务。\n\n分析两组参数：\n- 参数集$\\mathcal{A}$：$q_0 = 5\\,\\mathrm{ms}$，$W = 9\\,\\mathrm{ms}$，$C = 11\\,\\mathrm{ms}$。\n- 参数集$\\mathcal{B}$：$q_0 = 5\\,\\mathrm{ms}$，$W = 11\\,\\mathrm{ms}$，$C = 11\\,\\mathrm{ms}$。\n\n仅根据上述基本调度器定义，选择所有正确的陈述。\n\nA. 在参数集$\\mathcal{A}$下，$H$进入其临界区的等待时间可能是无界的（即，墙上时钟延迟没有有限的上限），因为在$L$耗尽其捐赠预算但仍持有锁之后，$Q_0$中的$R$可以无限期地抢占$Q_2$中的$L$。\n\nB. 在参数集$\\mathcal{B}$下，$H$将在$t = 0$后的最多$11\\,\\mathrm{ms}$墙上时钟时间内进入其临界区。\n\nC. 在参数集$\\mathcal{B}$下，当$Q_0$中只有一个始终就绪的竞争任务$R$时，$L$释放锁所需的墙上时钟时间上限为$2C$。\n\nD. 即使每次锁持有都有一个有界的窗口$W$，一个恶意的$Q_2$任务也可以通过反复重新获取锁并引发一系列$Q_0$等待者，从而在长时间间隔内获得任意大的CPU时间份额，除非调度器也对单位时间内累积的捐赠CPU实施上限。\n\nE. 无论$C$的值以及$Q_0$中是否存在始终就绪的任务，设置$W = q_0$总是足以避免无界优先级反转。\n\n选择所有适用的选项。", "solution": "首先将对问题陈述的科学合理性、完整性和客观性进行验证。\n\n### 步骤1：提取已知条件\n问题描述了一个拥有单个中央处理器（CPU）和多级反馈队列（MLFQ）调度器的计算机系统。明确的已知条件如下：\n- **队列**：定义了一个包含$3$个队列的系统：$Q_0$（最高优先级）、$Q_1$和$Q_2$（最低优先级）。\n- **队列间调度**：抢占式优先级调度，即较高优先级队列中的就绪任务会抢占任何在较低优先级队列中运行的任务。\n- **队列内调度**：轮询（RR）调度，每个队列有固定的时间量。\n- **时间量**：$Q_0$为$q_0 = 5\\,\\mathrm{ms}$，$Q_1$为$q_1 = 10\\,\\mathrm{ms}$，$Q_2$为$q_2 = 20\\,\\mathrm{ms}$。\n- **系统模型**：假设为单个CPU，上下文切换开销可忽略不计（为分析方便，假设为$0$）。\n- **优先级捐赠机制**：\n    - 较高优先级队列中的任务$H$在等待较低优先级队列中的任务$L$持有的互斥锁时发生阻塞，会导致$L$被临时提升到$H$的优先级（在此场景中即$Q_0$队列）。\n    - 提升过程受一个CPU时间预算$W$的限制。这个预算$W$仅在$L$实际在CPU上运行时才减少。\n    - 当$H$阻塞时，捐赠在下一次调度决策时立即开始，并将$L$置于$Q_0$就绪队列的头部。\n    - 如果$L$释放了互斥锁，或者其捐赠的预算$W$耗尽，捐赠就会结束。\n    - 每次连续持有锁只授予一个捐赠窗口。\n- **初始场景 ($t=0$)**：\n    - 任务$L$在$Q_2$中，持有一个互斥锁，其剩余临界区需要$C$单位的CPU时间。\n    - 任务$H$在$Q_0$中，并试图获取同一个互斥锁，导致其阻塞并触发对$L$的捐赠。\n    - 任务$R$在$Q_0$中，始终处于就绪状态（CPU密集型），与该互斥锁无关。\n    - 系统中没有其他任务。\n- **参数集**：\n    - 集合$\\mathcal{A}$：$q_0 = 5\\,\\mathrm{ms}$，$W = 9\\,\\mathrm{ms}$，$C = 11\\,\\mathrm{ms}$。\n    - 集合$\\mathcal{B}$：$q_0 = 5\\,\\mathrm{ms}$，$W = 11\\,\\mathrm{ms}$，$C = 11\\,\\mathrm{ms}$。\n\n### 步骤2：使用提取的已知条件进行验证\n根据标准对问题陈述进行有效性评估。\n- **科学依据**：所提出的概念——MLFQ、抢占式优先级调度、轮询、优先级反转和优先级继承（此处具体化为通过futex机制实现的有界“优先级捐赠”）——都是操作系统研究中的基础和标准主题。该模型虽然经过简化（例如，上下文切换成本为$0$），但在科学和逻辑上与其所描述的原理一致。\n- **适定性**：问题是适定的。系统的初始状态被清晰定义，状态转换的规则（调度、抢占、捐赠）是明确的，所提出的问题是具体和确定性的。可以从前提推导出一系列唯一的事件。\n- **客观性**：语言技术性强、精确，没有主观或含糊的术语。\n- **缺陷审查**：\n    1. **科学性不健全**：无。该模型是调度问题的标准表示。\n    2. **不相关**：无。主题集中于操作系统调度。\n    3. **不完整/矛盾**：无。规则足以模拟系统的行为。例如，$Q_0$内部的平局打破规则（将被捐赠的任务$L$置于头部）已明确说明。\n    4. **不切实际的条件**：假设上下文切换开销为零是理论分析中常见且可接受的简化。参数值对于此类问题是合理的。\n    5. **结构不当**：无。问题结构逻辑清晰，可导向唯一解。\n\n### 步骤3：结论与行动\n问题陈述**有效**。可以进行详细分析。\n\n### 推导与分析\n\n问题的核心是在轮询策略下追踪队列$Q_0$中任务$L$和$R$的执行过程，同时跟踪任务$L$的剩余临界区时间$C$和捐赠时间预算$W$。\n\n**参数集$\\mathcal{A}$的分析 ($q_0 = 5\\,\\mathrm{ms}$, $W = 9\\,\\mathrm{ms}$, $C = 11\\,\\mathrm{ms}$)**\n\n在$t=0$时，任务$H$（在$Q_0$中）因任务$L$（在$Q_2$中）持有的互斥锁而阻塞。这触发了优先级捐赠。$L$被提升到$Q_0$并被放置在就绪队列的头部。$Q_0$的就绪队列为$(L, R)$。状态为：$C_{rem} = 11\\,\\mathrm{ms}$，$W_{rem} = 9\\,\\mathrm{ms}$。\n\n1.  **$t = [0, 5)\\,\\mathrm{ms}$**：任务$L$运行，因为它在$Q_0$队列的头部。它运行了完整的时间量，$q_0 = 5\\,\\mathrm{ms}$。\n    -   $C_{rem}$变为$11 - 5 = 6\\,\\mathrm{ms}$。\n    -   $W_{rem}$变为$9 - 5 = 4\\,\\mathrm{ms}$。\n    -   在$t=5\\,\\mathrm{ms}$时，$L$被抢占并移至$Q_0$队列的尾部。队列现在是$(R, L)$。\n\n2.  **$t = [5, 10)\\,\\mathrm{ms}$**：任务$R$运行其时间量，$q_0 = 5\\,\\mathrm{ms}$。\n    -   在$t=10\\,\\mathrm{ms}$时，$R$被抢占并移至队尾。队列现在是$(L, R)$。\n\n3.  **$t = [10, 14)\\,\\mathrm{ms}$**：任务$L$再次运行。它需要$C_{rem} = 6\\,\\mathrm{ms}$来完成其临界区，但其剩余的捐赠预算只有$W_{rem} = 4\\,\\mathrm{ms}$。它也受到时间量$q_0 = 5\\,\\mathrm{ms}$的限制。它将运行$\\min(q_0, C_{rem}, W_{rem}) = \\min(5, 6, 4) = 4\\,\\mathrm{ms}$。\n    -   $L$运行$4\\,\\mathrm{ms}$。\n    -   $C_{rem}$变为$6 - 4 = 2\\,\\mathrm{ms}$。\n    -   $W_{rem}$变为$4 - 4 = 0\\,\\mathrm{ms}$。\n\n4.  **在$t=14\\,\\mathrm{ms}$时**：任务$L$耗尽其捐赠预算$W$。捐赠结束。$L$立即被降级回其原始队列$Q_2$。关键是，$L$尚未完成其临界区（$C_{rem} = 2\\,\\mathrm{ms}$）并且仍持有互斥锁。\n\n5.  **对于$t \\geq 14\\,\\mathrm{ms}$**：就绪队列为$Q_0: (R)$，$Q_1: (\\text{空})$，$Q_2: (L)$。任务$H$仍然阻塞。由于任务$R$在$Q_0$中且被定义为“始终就绪”，它将被持续调度。调度器永远不会从像$Q_2$这样的较低优先级队列中选择任务。因此，$L$被饿死，永远无法运行以完成其剩余的$2\\,\\mathrm{ms}$临界区工作。它将永远不会释放互斥锁。这导致任务$H$的等待时间无界。\n\n**参数集$\\mathcal{B}$的分析 ($q_0 = 5\\,\\mathrm{ms}$, $W = 11\\,\\mathrm{ms}$, $C = 11\\,\\mathrm{ms}$)**\n\n在$t=0$时，设置相同。$Q_0$的就绪队列为$(L, R)$。状态为：$C_{rem} = 11\\,\\mathrm{ms}$，$W_{rem} = 11\\,\\mathrm{ms}$。关键区别在于$W=C$。\n\n1.  **$t = [0, 5)\\,\\mathrm{ms}$**：任务$L$运行$q_0 = 5\\,\\mathrm{ms}$。\n    -   $C_{rem} = 11 - 5 = 6\\,\\mathrm{ms}$。\n    -   $W_{rem} = 11 - 5 = 6\\,\\mathrm{ms}$。\n    -   在$t=5\\,\\mathrm{ms}$时，队列变为$(R, L)$。\n\n2.  **$t = [5, 10)\\,\\mathrm{ms}$**：任务$R$运行$q_0 = 5\\,\\mathrm{ms}$。\n    -   在$t=10\\,\\mathrm{ms}$时，队列变为$(L, R)$。\n\n3.  **$t = [10, 15)\\,\\mathrm{ms}$**：任务$L$运行$q_0 = 5\\,\\mathrm{ms}$。\n    -   $C_{rem} = 6 - 5 = 1\\,\\mathrm{ms}$。\n    -   $W_{rem} = 6 - 5 = 1\\,\\mathrm{ms}$。\n    -   在$t=15\\,\\mathrm{ms}$时，队列变为$(R, L)$。\n\n4.  **$t = [15, 20)\\,\\mathrm{ms}$**：任务$R$运行$q_0 = 5\\,\\mathrm{ms}$。\n    -   在$t=20\\,\\mathrm{ms}$时，队列变为$(L, R)$。\n\n5.  **$t = [20, 21)\\,\\mathrm{ms}$**：任务$L$运行。它只需要$C_{rem} = 1\\,\\mathrm{ms}$即可完成。它还有$W_{rem} = 1\\,\\mathrm{ms}$的预算剩余。\n    -   $L$运行$1\\,\\mathrm{ms}$。\n    -   $C_{rem} = 1 - 1 = 0\\,\\mathrm{ms}$。\n    -   $W_{rem}$变为$1 - 1 = 0\\,\\mathrm{ms}$。\n\n6.  **在$t=21\\,\\mathrm{ms}$时**：任务$L$完成其临界区并释放互斥锁。任务$H$解除阻塞，在$Q_0$中变为就绪状态，现在可以被调度。$H$进入其临界区的等待时间为$21\\,\\mathrm{ms}$。\n\n### 逐项分析\n\n**A. 在参数集$\\mathcal{A}$下，$H$进入其临界区的等待时间可能是无界的（即，墙上时钟延迟没有有限的上限），因为在$L$耗尽其捐赠预算但仍持有锁之后，$Q_0$中的$R$可以无限期地抢占$Q_2$中的$L$。**\n这个陈述完全符合对参数集$\\mathcal{A}$的分析结果。捐赠的预算$W=9\\,\\mathrm{ms}$不足以让$L$在与$R$竞争的同时完成其$C=11\\,\\mathrm{ms}$的临界区。$L$在临界区执行中途被降级，随后被高优先级任务$R$饿死，导致一种类似死锁的情况，其中$H$无限期等待。这是管理不当的优先级反转的一个典型例子。\n**结论：正确。**\n\n**B. 在参数集$\\mathcal{B}$下，$H$将在$t = 0$后的最多$11\\,\\mathrm{ms}$墙上时钟时间内进入其临界区。**\n对参数集$\\mathcal{B}$的详细分析表明，由于与任务$R$的交错执行，任务$L$需要$21\\,\\mathrm{ms}$的墙上时钟时间来完成其临界区。因此，$H$的等待时间是$21\\,\\mathrm{ms}$。由于$21\\,\\mathrm{ms}$不小于等于$11\\,\\mathrm{ms}$，该陈述是错误的。\n**结论：不正确。**\n\n**C. 在参数集$\\mathcal{B}$下，当$Q_0$中只有一个始终就绪的竞争任务$R$时，$L$释放锁所需的墙上时钟时间上限为$2C$。**\n这个陈述概括了从集合$\\mathcal{B}$中得到的观察。为了完成其长度为$C$的临界区，任务$L$需要总共运行$C$的CPU时间。在时间量为$q_0$的情况下，这需要$N_L = \\lceil C/q_0 \\rceil$次在$Q_0$轮询调度中的独立运行。在$L$的前$N_L - 1$次运行之间，任务$R$将每次运行一个完整的时间量$q_0$。\n总墙上时钟时间$T_{wall}$是$L$运行的时间（$C$）和$R$运行的时间之和。\n$T_{wall} = C + (N_L - 1)q_0 = C + (\\lceil C/q_0 \\rceil - 1)q_0$。\n要验证界限$T_{wall} \\leq 2C$，我们必须检查$C + (\\lceil C/q_0 \\rceil - 1)q_0 \\leq 2C$，这可以简化为$(\\lceil C/q_0 \\rceil - 1)q_0 \\leq C$。\n根据向上取整函数的定义，我们知道$\\lceil x \\rceil  x + 1$。令$x = C/q_0$。\n那么$(\\lceil C/q_0 \\rceil - 1)  (C/q_0 + 1 - 1) = C/q_0$。\n两边乘以$q_0$得到$(\\lceil C/q_0 \\rceil - 1)q_0  C$。\n因此，严格不等式成立。如果$C$是$q_0$的整数倍，$C = k \\cdot q_0$，那么$\\lceil C/q_0 \\rceil = k$，表达式变为$(k-1)q_0$，它小于$C = k \\cdot q_0$（对于 $k>1$）。不等式$(\\lceil C/q_0 \\rceil - 1)q_0 \\leq C$总是成立的。这意味着$T_{wall} \\leq 2C$。\n对于参数集$\\mathcal{B}$，$C=11\\,\\mathrm{ms}$，$q_0=5\\,\\mathrm{ms}$。$T_{wall} = 11 + (\\lceil 11/5 \\rceil - 1) \\times 5 = 11 + (3 - 1) \\times 5 = 11 + 10 = 21\\,\\mathrm{ms}$。界限$2C$是$2 \\times 11 = 22\\,\\mathrm{ms}$。$21\\,\\mathrm{ms} \\leq 22\\,\\mathrm{ms}$，所以界限成立。只要无界反转被阻止（对于集合$\\mathcal{B}$是成立的，因为$W \\geq C$），该分析就是有效的。\n**结论：正确。**\n\n**D. 即使每次锁持有都有一个有界的窗口$W$，一个恶意的$Q_2$任务也可以通过反复重新获取锁并引发一系列$Q_0$等待者，从而在长时间间隔内获得任意大的CPU时间份额，除非调度器也对单位时间内累积的捐赠CPU实施上限。**\n所描述的捐赠策略限制了*每次锁获取*所授予的CPU时间。它没有对一个任务在较长时间内可以接收的总捐赠时间施加任何限制。一个恶意任务可以反复执行一个循环：(1) 获取一个锁，(2) 让一个高优先级任务阻塞在该锁上，(3) 接收并使用高优先级的$W$预算，(4) 释放锁，(5) 重复。如果这个循环可以迅速执行，恶意任务实际上可以在很大一部分时间内以高优先级运行，绕过了MLFQ的设计意图。该陈述正确地指出了这个漏洞，以及需要进一步的机制（如对捐赠的速率限制）来防止这种滥用。\n**结论：正确。**\n\n**E. 无论$C$的值以及$Q_0$中是否存在始终就绪的任务，设置$W = q_0$总是足以避免无界优先级反转。**\n这个陈述做出了一个很强的普适性断言。要证伪它，一个反例就足够了。让我们使用问题中的场景，即$Q_0$中有一个始终就绪的竞争者$R$。\n设置$W = q_0 = 5\\,\\mathrm{ms}$。让临界区比时间量长，例如，$C = 6\\,\\mathrm{ms}$。\n- $t=0$：$L$被提升到$Q_0$。$W_{rem}=5, C_{rem}=6$。\n- $t = [0, 5)\\,\\mathrm{ms}$：$L$运行$5\\,\\mathrm{ms}$。它耗尽了全部预算$W$。\n- 在$t=5\\,\\mathrm{ms}$时：$W_{rem}=0$，捐赠结束。$L$被降级到$Q_2$。然而，它的临界区没有完成，因为$C_{rem}=1\\,\\mathrm{ms}$。\n- 对于$t \\geq 5\\,\\mathrm{ms}$：$L$在持有锁的同时位于$Q_2$中，而始终就绪的任务$R$在$Q_0$中。$R$将持续抢占$L$，导致无界优先级反转。\n因此，如果$C > W$，设置$W=q_0$是不够的。该陈述声称“无论$C$的值如何”都有效是错误的。\n**结论：不正确。**", "answer": "$$\\boxed{ACD}$$", "id": "3660203"}]}