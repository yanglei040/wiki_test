{"hands_on_practices": [{"introduction": "在实证资产定价中，诸如规模（$SMB$）和价值（$HML$）之类的因子并非抽象的理论概念，而是可以通过构建特定的投资组合在现实中交易的。本实践将指导你完成构建此类“因子模拟投资组合”的核心步骤。你将学习如何运用约束最优化方法，构建一个对新型特征（如本例中的$ESG$得分）具有单位敞口，同时对市场、规模和价值等其他既定因子保持中性的投资组合。掌握这项技能是检验任何新资产定价因子的基石。[@problem_id:2392242]", "problem": "给定一组横截面资产及其与 Fama-French 三因子模型（FF3）和一个新颖特征相关的风险暴露。Fama-French 三因子模型（FF3）包含市场因子、Small-Minus-Big (SMB) 和 High-Minus-Low (HML)。这个新颖的特征是环境、社会和治理（ESG）评分。您的任务是，使用给定的资产超额收益面板数据，在特定的线性风险暴露约束下，为 ESG 特征构建最小方差因子模拟投资组合。\n\n假设有 $N=6$ 种资产和 $T=10$ 个时间周期。令 $R \\in \\mathbb{R}^{T \\times N}$ 表示以小数形式表示的资产超额收益矩阵，其中第 $t$ 行包含时期 $t$ 的 $N$ 种资产的超额收益。$R$ 的数据如下：\n- 第 1 行：$(0.012, 0.008, 0.015, 0.005, 0.010, 0.011)$\n- 第 2 行：$(-0.020, -0.015, -0.018, -0.022, -0.017, -0.019)$\n- 第 3 行：$(0.025, 0.020, 0.028, 0.018, 0.022, 0.024)$\n- 第 4 行：$(0.005, 0.007, 0.004, 0.009, 0.006, 0.005)$\n- 第 5 行：$(0.030, 0.026, 0.033, 0.021, 0.027, 0.029)$\n- 第 6 行：$(-0.010, -0.012, -0.009, -0.013, -0.011, -0.010)$\n- 第 7 行：$(0.018, 0.014, 0.020, 0.012, 0.016, 0.017)$\n- 第 8 行：$(-0.005, -0.006, -0.004, -0.007, -0.005, -0.005)$\n- 第 9 行：$(0.022, 0.019, 0.024, 0.016, 0.020, 0.021)$\n- 第 10 行：$(0.003, 0.004, 0.002, 0.005, 0.003, 0.003)$\n\n令 $\\Sigma \\in \\mathbb{R}^{N \\times N}$ 表示资产超额收益的协方差矩阵，使用总体协方差估计量计算如下：\n$$\n\\Sigma \\;=\\; \\frac{1}{T} \\sum_{t=1}^{T} \\left( r_t - \\bar{r} \\right)\\left( r_t - \\bar{r} \\right)^{\\top},\n$$\n其中 $r_t \\in \\mathbb{R}^{N}$ 是 $R$ 的第 $t$ 行，$\\bar{r} \\in \\mathbb{R}^{N}$ 是资产收益的时间序列均值向量。\n\n此外，还给定了每种资产对 FF3 因子和 ESG 特征的风险暴露向量。令 $f^{\\text{MKT}}, f^{\\text{SMB}}, f^{\\text{HML}}, f^{\\text{ESG}} \\in \\mathbb{R}^{N}$ 表示每种资产的风险暴露：\n- $f^{\\text{MKT}} = (1.10, 0.90, 1.20, 0.80, 1.00, 1.05)$\n- $f^{\\text{SMB}} = (-0.30, 0.50, -0.20, 0.70, 0.10, -0.40)$\n- $f^{\\text{HML}} = (0.60, -0.20, 0.40, -0.50, 0.00, 0.30)$\n- $f^{\\text{ESG}} = (0.80, 0.20, -0.40, 1.10, -0.60, 0.30)$\n\n因子模拟投资组合是一个投资组合权重向量 $w \\in \\mathbb{R}^{N}$，其选择旨在满足线性风险暴露约束的同时最小化投资组合方差。形式上，对于给定的约束矩阵 $A \\in \\mathbb{R}^{K \\times N}$ 和目标风险暴露向量 $b \\in \\mathbb{R}^{K}$，权重 $w$ 求解以下问题：\n$$\n\\min_{w \\in \\mathbb{R}^{N}} \\; w^{\\top}\\Sigma w \\quad \\text{subject to} \\quad A w = b.\n$$\n\n考虑以下四个测试用例，每个用例指定了一组约束条件。令 $\\mathbf{1} \\in \\mathbb{R}^{N}$ 表示全为 1 的向量。\n\n- 测试用例 1（自融资，对 FF3 中性，单位 ESG 暴露）：\n  - 约束条件：$\\mathbf{1}^{\\top} w = 0$, $(f^{\\text{MKT}})^{\\top} w = 0$, $(f^{\\text{SMB}})^{\\top} w = 0$, $(f^{\\text{HML}})^{\\top} w = 0$, $(f^{\\text{ESG}})^{\\top} w = 1$.\n- 测试用例 2（自融资，对 FF3 中性，负单位 ESG 暴露）：\n  - 约束条件：$\\mathbf{1}^{\\top} w = 0$, $(f^{\\text{MKT}})^{\\top} w = 0$, $(f^{\\text{SMB}})^{\\top} w = 0$, $(f^{\\text{HML}})^{\\top} w = 0$, $(f^{\\text{ESG}})^{\\top} w = -1$.\n- 测试用例 3（完全投资，对 FF3 中性，0.5 ESG 暴露）：\n  - 约束条件：$\\mathbf{1}^{\\top} w = 1$, $(f^{\\text{MKT}})^{\\top} w = 0$, $(f^{\\text{SMB}})^{\\top} w = 0$, $(f^{\\text{HML}})^{\\top} w = 0$, $(f^{\\text{ESG}})^{\\top} w = 0.5$.\n- 测试用例 4（自融资，对 FF3 中性，零 ESG 暴露；边界情况）：\n  - 约束条件：$\\mathbf{1}^{\\top} w = 0$, $(f^{\\text{MKT}})^{\\top} w = 0$, $(f^{\\text{SMB}})^{\\top} w = 0$, $(f^{\\text{HML}})^{\\top} w = 0$, $(f^{\\text{ESG}})^{\\top} w = 0$.\n\n对于每个测试用例，计算最小方差因子模拟投资组合 $w$ 并将投资组合方差 $v = w^{\\top} \\Sigma w$ 报告为一个实数。收益输入是无单位的小数，报告的 $v$ 也必须是无单位的。\n\n您的程序应生成单行输出，其中包含按测试用例 1 到 4 的顺序排列的结果，格式为方括号内以逗号分隔的列表，例如：“[v1,v2,v3,v4]”。", "solution": "所提出的问题是量化金融中的一个标准练习：在一组线性约束下构建最小方差因子模拟投资组合。这是一个典型的约束二次优化问题。\n\n该问题定义如下：\n$$ \\min_{w \\in \\mathbb{R}^{N}} \\; v = w^{\\top}\\Sigma w $$\n满足以下线性等式约束：\n$$ A w = b $$\n其中 $w \\in \\mathbb{R}^{N}$ 是投资组合权重向量，$\\Sigma \\in \\mathbb{R}^{N \\times N}$ 是资产超额收益的协方差矩阵， $A \\in \\mathbb{R}^{K \\times N}$ 是约束系数（因子暴露）矩阵， $b \\in \\mathbb{R}^{K}$ 是目标风险暴露向量。此处，资产数量为 $N=6$，约束数量为 $K=5$。\n\n此问题的解可通过拉格朗日乘数法系统地导出。拉格朗日函数 $\\mathcal{L}$ 的形式为：\n$$ \\mathcal{L}(w, \\lambda) = w^{\\top}\\Sigma w - \\lambda^{\\top}(Aw - b) $$\n其中 $\\lambda \\in \\mathbb{R}^{K}$ 是拉格朗日乘数向量。\n\n获得最小值的必要一阶条件是通过将拉格朗日函数对 $w$ 的梯度设为零来找到：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial w} = 2\\Sigma w - A^{\\top}\\lambda = \\mathbf{0} $$\n假设协方差矩阵 $\\Sigma$ 是可逆的，我们可以解出 $w$：\n$$ w = \\frac{1}{2} \\Sigma^{-1} A^{\\top} \\lambda $$\n为了求得 $\\lambda$，我们将 $w$ 的表达式代入约束方程 $Aw=b$ 中：\n$$ A \\left( \\frac{1}{2} \\Sigma^{-1} A^{\\top} \\lambda \\right) = b $$\n$$ \\left( A \\Sigma^{-1} A^{\\top} \\right) \\lambda = 2b $$\n当 $\\Sigma$ 是正定矩阵且 $A$ 具有满行秩时，矩阵 $A \\Sigma^{-1} A^{\\top}$ 是可逆的。此问题中这两个条件都满足。因此，我们可以解出 $\\lambda$：\n$$ \\lambda = 2 \\left( A \\Sigma^{-1} A^{\\top} \\right)^{-1} b $$\n将 $\\lambda$ 代回到 $w$ 的方程中，得到最优权重向量 $w^{\\star}$：\n$$ w^{\\star} = \\Sigma^{-1} A^{\\top} \\left( A \\Sigma^{-1} A^{\\top} \\right)^{-1} b $$\n最小投资组合方差 $v$ 则由 $v = (w^{\\star})^{\\top}\\Sigma w^{\\star}$ 给出。通过代入 $w^{\\star}$ 的表达式，我们得到一个更直接的方差计算公式：\n$$ v = \\left( \\Sigma^{-1}A^{\\top}(A\\Sigma^{-1}A^{\\top})^{-1}b \\right)^{\\top} \\Sigma \\left( \\Sigma^{-1}A^{\\top}(A\\Sigma^{-1}A^{\\top})^{-1}b \\right) $$\n$$ v = b^{\\top} \\left( (A\\Sigma^{-1}A^{\\top})^{-1} \\right)^{\\top} (A\\Sigma^{-1})^{\\top} \\Sigma \\Sigma^{-1} A^{\\top} (A\\Sigma^{-1}A^{\\top})^{-1} b $$\n$$ v = b^{\\top} (A\\Sigma^{-1}A^{\\top})^{-1} A \\Sigma^{-1} A^{\\top} (A\\Sigma^{-1}A^{\\top})^{-1} b $$\n$$ v = b^{\\top} (A\\Sigma^{-1}A^{\\top})^{-1} b $$\n这个最终表达式在计算上是高效的，并将用于求解每个测试用例中的方差。\n\n计算步骤如下：\n$1$. 资产超额收益协方差矩阵 $\\Sigma \\in \\mathbb{R}^{6 \\times 6}$ 是根据所提供的数据矩阵 $R \\in \\mathbb{R}^{10 \\times 6}$，使用指定的总体协方差公式计算得出的：$\\Sigma = \\frac{1}{T} \\sum_{t=1}^{T} ( r_t - \\bar{r} )( r_t - \\bar{r} )^{\\top}$，其中 $T=10$ 是时间周期数，$r_t$ 是时间 $t$ 的收益向量，$\\bar{r}$ 是每种资产收益的时间序列均值。\n\n$2$. 约束矩阵 $A \\in \\mathbb{R}^{5 \\times 6}$ 是通过将全 1 向量 $\\mathbf{1}$ 和因子暴露向量 $f^{\\text{MKT}}$、 $f^{\\text{SMB}}$、 $f^{\\text{HML}}$ 和 $f^{\\text{ESG}}$作为行堆叠而成的：\n$$ A = \\begin{pmatrix} \\mathbf{1}^{\\top} \\\\ (f^{\\text{MKT}})^{\\top} \\\\ (f^{\\text{SMB}})^{\\top} \\\\ (f^{\\text{HML}})^{\\top} \\\\ (f^{\\text{ESG}})^{\\top} \\end{pmatrix} $$\n\n$3$. 为四个测试用例中的每一个定义对应的目标暴露向量 $b \\in \\mathbb{R}^{5}$。\n\n$4$. 计算核心矩阵 $M = (A\\Sigma^{-1}A^{\\top})^{-1}$。\n\n$5$. 每个用例的最小方差计算公式为 $v = b^{\\top}Mb$。\n\n测试用例的评估过程如下：\n- 对于测试用例 1，$b_1 = [0, 0, 0, 0, 1]^{\\top}$。方差为 $v_1 = b_1^{\\top}Mb_1$。\n- 对于测试用例 2，$b_2 = [0, 0, 0, 0, -1]^{\\top}$。由于 $b_2 = -b_1$，方差为 $v_2 = (-b_1)^{\\top}M(-b_1) = b_1^{\\top}Mb_1 = v_1$。用例 1 和 2 的方差必须相同。\n- 对于测试用例 3，$b_3 = [1, 0, 0, 0, 0.5]^{\\top}$。方差为 $v_3 = b_3^{\\top}Mb_3$。\n- 对于测试用例 4，$b_4 = [0, 0, 0, 0, 0]^{\\top}$。目标向量是零向量。这直接意味着方差 $v_4 = \\mathbf{0}^{\\top}M\\mathbf{0} = 0$。最优投资组合就是 $w^{\\star} = \\mathbf{0}$，其方差为零，并满足齐次约束 $A w = \\mathbf{0}$。\n\n下面的实现以数值方式执行这些计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes minimum-variance factor-mimicking portfolio variances for four test cases.\n    \"\"\"\n    # Number of assets N and time periods T\n    N = 6\n    T = 10\n\n    # Data from the problem statement\n    # Asset excess returns matrix R in decimal form\n    R = np.array([\n        [0.012, 0.008, 0.015, 0.005, 0.010, 0.011],\n        [-0.020, -0.015, -0.018, -0.022, -0.017, -0.019],\n        [0.025, 0.020, 0.028, 0.018, 0.022, 0.024],\n        [0.005, 0.007, 0.004, 0.009, 0.006, 0.005],\n        [0.030, 0.026, 0.033, 0.021, 0.027, 0.029],\n        [-0.010, -0.012, -0.009, -0.013, -0.011, -0.010],\n        [0.018, 0.014, 0.020, 0.012, 0.016, 0.017],\n        [-0.005, -0.006, -0.004, -0.007, -0.005, -0.005],\n        [0.022, 0.019, 0.024, 0.016, 0.020, 0.021],\n        [0.003, 0.004, 0.002, 0.005, 0.003, 0.003]\n    ])\n\n    # Factor exposure vectors\n    f_mkt = np.array([1.10, 0.90, 1.20, 0.80, 1.00, 1.05])\n    f_smb = np.array([-0.30, 0.50, -0.20, 0.70, 0.10, -0.40])\n    f_hml = np.array([0.60, -0.20, 0.40, -0.50, 0.00, 0.30])\n    f_esg = np.array([0.80, 0.20, -0.40, 1.10, -0.60, 0.30])\n\n    # Step 1: Compute the population covariance matrix Sigma.\n    # The problem asks for the population covariance estimator, which corresponds\n    # to using a divisor of T (ddof=0 in numpy.cov).\n    Sigma = np.cov(R, rowvar=False, ddof=0)\n\n    # Step 2: Construct the constraint matrix A.\n    # The rows of A are the constraint vectors.\n    ones_vec = np.ones(N)\n    A = np.vstack([ones_vec, f_mkt, f_smb, f_hml, f_esg])\n\n    # Step 3: Compute the core matrix M = (A * Sigma_inv * A^T)^-1.\n    try:\n        Sigma_inv = np.linalg.inv(Sigma)\n        M = np.linalg.inv(A @ Sigma_inv @ A.T)\n    except np.linalg.LinAlgError as e:\n        # This case should not be reached given the problem data.\n        print(f\"Error during matrix inversion: {e}\")\n        return\n\n    # Step 4: Define the target exposure vectors 'b' for each test case.\n    test_cases = [\n        # Case 1: self-financing, FF3-neutral, unit ESG exposure\n        {\"b\": np.array([0., 0., 0., 0., 1.])},\n        # Case 2: self-financing, FF3-neutral, negative unit ESG exposure\n        {\"b\": np.array([0., 0., 0., 0., -1.])},\n        # Case 3: fully invested, FF3-neutral, half ESG exposure\n        {\"b\": np.array([1., 0., 0., 0., 0.5])},\n        # Case 4: self-financing, FF3-neutral, zero ESG exposure (boundary case)\n        {\"b\": np.array([0., 0., 0., 0., 0.])}\n    ]\n\n    results = []\n    # Step 5: Calculate the minimum variance for each test case.\n    for case in test_cases:\n        b = case[\"b\"]\n        variance = b.T @ M @ b\n        results.append(variance)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2392242"}, {"introduction": "一个有效的资产定价模型应该能解释资产回报中所有的系统性变化，只留下不可预测的随机“噪声”。本练习通过一个模拟实验，直观地展示了模型设定不当（即遗漏变量）所带来的后果。通过比较简化的资本资产定价模型（$CAPM$）与更完整的三因子模型的回归残差，你将学会使用Ljung-Box等统计工具来诊断模型的残差是否表现出白噪声特性，从而为评估模型的充分性提供一个具体的量化标准。[@problem_id:2448010]", "problem": "考虑一个单一资产的超额收益序列，该序列由一个带有白噪声扰动的线性因子模型建模。令市场因子、市值因子和价值因子分别表示为 $M_t$、$\\mathrm{SMB}_t$ 和 $\\mathrm{HML}_t$。对于每个时间指数 $t \\in \\{1,2,\\dots,T\\}$，资产的超额收益 $R_t^{e}$ 由以下公式生成\n$$\nR_t^{e} \\;=\\; \\alpha \\;+\\; \\beta_M M_t \\;+\\; \\beta_S \\mathrm{SMB}_t \\;+\\; \\beta_H \\mathrm{HML}_t \\;+\\; \\varepsilon_t,\n$$\n其中扰动项 $\\{\\varepsilon_t\\}$ 是一个白噪声过程：$\\mathbb{E}[\\varepsilon_t]=0$，$\\operatorname{Var}(\\varepsilon_t)=\\sigma_{\\varepsilon}^2$，且对于 $t\\neq s$ 有 $\\operatorname{Cov}(\\varepsilon_t,\\varepsilon_s)=0$。\n\n因子 $(M_t,\\mathrm{SMB}_t,\\mathrm{HML}_t)$ 服从独立的、带有高斯新息和零初始条件的一阶自回归过程：\n$$\nM_t \\;=\\; \\phi_M M_{t-1} \\;+\\; \\eta_{M,t}, \\quad \\mathrm{SMB}_t \\;=\\; \\phi_S \\mathrm{SMB}_{t-1} \\;+\\; \\eta_{S,t}, \\quad \\mathrm{HML}_t \\;=\\; \\phi_H \\mathrm{HML}_{t-1} \\;+\\; \\eta_{H,t},\n$$\n其中 $M_0=\\mathrm{SMB}_0=\\mathrm{HML}_0=0$。$\\{\\eta_{M,t}\\}$、$\\{\\eta_{S,t}\\}$ 和 $\\{\\eta_{H,t}\\}$ 是相互独立的序列，每个序列都由独立同分布的高斯随机变量构成，其均值为 $0$，方差的选择使得每个因子过程的平稳方差为 $1$。也就是说，对于 $f \\in \\{M,S,H\\}$，新息方差满足 $\\operatorname{Var}(\\eta_{f,t})=1-\\phi_f^2$。\n\n对于 $\\{(R_t^{e},M_t,\\mathrm{SMB}_t,\\mathrm{HML}_t)\\}_{t=1}^T$ 的一个给定实现，考虑两个带截距项的线性回归：\n(1) 资本资产定价模型 (CAPM)：$R_t^{e}$ 对 $\\{1,M_t\\}$ 的回归，以及\n(2) Fama-French三因子模型：$R_t^{e}$ 对 $\\{1,M_t,\\mathrm{SMB}_t,\\mathrm{HML}_t\\}$ 的回归。\n两种模型都将通过最小二乘法进行估计，即最小化残差平方和，从而产生残差序列 $\\{e^{\\mathrm{CAPM}}_t\\}_{t=1}^T$ 和 $\\{e^{\\mathrm{FF3}}_t\\}_{t=1}^T$。\n\n对于一个残差序列 $\\{e_t\\}_{t=1}^T$，其滞后 $k$ 阶的样本自相关 $\\hat{r}_k$ 定义为\n$$\n\\hat{r}_k \\;=\\; \\frac{\\sum_{t=k+1}^{T} (e_t - \\bar{e})(e_{t-k} - \\bar{e})}{\\sum_{t=1}^{T} (e_t - \\bar{e})^2}, \\quad \\text{其中 } \\bar{e}=\\frac{1}{T}\\sum_{t=1}^{T} e_t.\n$$\n最大滞后阶数为 $m$ 的 Ljung-Box 综合检验统计量 $Q(m)$ 定义为\n$$\nQ(m) \\;=\\; T(T+2)\\sum_{k=1}^{m} \\frac{\\hat{r}_k^2}{T-k}.\n$$\n在残差为白噪声的原假设下，$Q(m)$ 的参考分布为自由度为 $m$ 的卡方分布。对于一个给定的残差序列，令其白噪声检验的 $p$ 值为 $p = 1 - F_{\\chi^2_m}(Q(m))$，其中 $F_{\\chi^2_m}$ 表示自由度为 $m$ 的卡方分布的累积分布函数。我们定义，如果一组残差的 Ljung-Box $p$ 值严格大于另一组，则前者比后者“更白”。\n\n为了保证可复现性，使用一个固定的随机种子，根据上述规范生成因子过程和资产收益。然后，对下面的每个测试用例，估计两种回归模型，并计算在指定最大滞后阶数下的 Ljung-Box $p$ 值。对每个测试用例，如果Fama-French三因子模型的残差比CAPM模型的残差更白，则输出布尔值`true`，否则输出`false`。\n\n所有用例中使用的全局模拟参数：\n- 因子自回归系数：$\\phi_M=0.6$, $\\phi_S=0.5$, $\\phi_H=0.4$。\n- 初始条件：$M_0=\\mathrm{SMB}_0=\\mathrm{HML}_0=0$。\n\n测试套件（四个用例），每个用例由 $(T, \\beta_M, \\beta_S, \\beta_H, \\sigma_{\\varepsilon}, m)$ 指定：\n- 用例 1：$(T=\\;600,\\;\\beta_M=\\;0.9,\\;\\beta_S=\\;0.5,\\;\\beta_H=\\;-0.3,\\;\\sigma_{\\varepsilon}=\\;0.5,\\;m=\\;10)$。\n- 用例 2：$(T=\\;600,\\;\\beta_M=\\;1.1,\\;\\beta_S=\\;0.0,\\;\\beta_H=\\;0.0,\\;\\sigma_{\\varepsilon}=\\;0.5,\\;m=\\;10)$。\n- 用例 3：$(T=\\;120,\\;\\beta_M=\\;0.0,\\;\\beta_S=\\;0.8,\\;\\beta_H=\\;0.8,\\;\\sigma_{\\varepsilon}=\\;0.5,\\;m=\\;10)$。\n- 用例 4：$(T=\\;60,\\;\\beta_M=\\;0.0,\\;\\beta_S=\\;0.0,\\;\\beta_H=\\;0.0,\\;\\sigma_{\\varepsilon}=\\;1.0,\\;m=\\;10)$。\n\n随机性与重用规则：\n- 使用一个长度为 $T_{\\max}$ 的单一共同因子过程实现，其中 $T_{\\max}$ 是所有测试用例中最大的 $T$。对于每个用例，使用每个因子的前 $T$ 个观测值。使用一个固定的、明确指定的随机种子，以使该实现是唯一确定的。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的四个布尔值列表，按测试用例的顺序排列，例如 `[True,False,True,False]`。\n- 不涉及物理单位。不涉及角度。如果需要使用分数，应表示为小数，但此处要求的输出仅为布尔值。", "solution": "所提出的问题是金融计量经济学中一个定义明确的模拟练习。它在科学上基于线性因子模型和模型诊断的理论，特别是关于遗漏变量偏差及其通过检验回归残差的序列相关性来进行检测的问题。它的陈述完整、一致、客观，因此是一个有效的问题。我们将着手解决它。\n\n所考察的基本原理是正确的模型设定。资产超额收益 $R_t^{e}$ 的数据生成过程（DGP）由 Fama-French 三因子模型加上一个附加的白噪声扰动项 $\\{\\varepsilon_t\\}$ 给出：\n$$\nR_t^{e} \\;=\\; \\alpha \\;+\\; \\beta_M M_t \\;+\\; \\beta_S \\mathrm{SMB}_t \\;+\\; \\beta_H \\mathrm{HML}_t \\;+\\; \\varepsilon_t\n$$\n因子本身 $\\{M_t\\}$、$\\{\\mathrm{SMB}_t\\}$ 和 $\\{\\mathrm{HML}_t\\}$ 并非白噪声，而是表现出时间依赖性，因为它们被建模为一阶自回归（AR($1$)）过程。\n\n当我们通过将 $R_t^e$ 仅对一个常数和市场因子 $M_t$ 进行回归来估计资本资产定价模型（CAPM）时，如果真实系数 $\\beta_S$ 或 $\\beta_H$ 不为零，我们就会引入设定误差。遗漏因子 $\\mathrm{SMB}_t$ 和 $\\mathrm{HML}_t$ 的影响被 CAPM 的残差项所吸收。设估计的 CAPM 为 $\\hat{R}_t^e = \\hat{a}_{\\mathrm{CAPM}} + \\hat{b}_M M_t$。产生的残差 $e_t^{\\mathrm{CAPM}} = R_t^e - \\hat{R}_t^e$ 将近似于：\n$$\ne_t^{\\mathrm{CAPM}} \\approx (\\alpha - \\hat{a}_{\\mathrm{CAPM}}) + (\\beta_M - \\hat{b}_M) M_t + \\beta_S \\mathrm{SMB}_t + \\beta_H \\mathrm{HML}_t + \\varepsilon_t\n$$\n由于 $\\mathrm{SMB}_t$ 和 $\\mathrm{HML}_t$ 是序列相关的，这种自相关结构被传递给了 CAPM 的残差，导致它们偏离白噪声。\n\n相反，估计 Fama-French 三因子模型与 DGP 是一致的。来自这个正确设定模型的残差 $e_t^{\\mathrm{FF3}}$ 将是真实新息 $\\varepsilon_t$ 的一致估计量，而新息被规定为白噪声。\n\nLjung-Box 检验是一种用于检验自相关的正式统计检验。检验统计量 $Q(m)$ 汇总了前 $m$ 个样本自相关系数的平方。在序列是白噪声的原假设下，$Q(m)$ 近似服从自由度为 $m$ 的卡方随机变量分布。较低的 p 值表示拒绝原假设，表明存在显著的序列相关性。\n\n因此，当 $\\beta_S$ 或 $\\beta_H$ 不为零时，我们预期应用于设定错误的 CAPM 残差的 Ljung-Box 检验会产生一个较低的 p 值（检测到自相关）。而对 FF3 残差的检验应该会产生一个较高的 p 值（未能检测到自相关）。问题将“更白”的残差定义为具有严格更大 p 值的残差，因此我们预期在 CAPM 设定错误的情况下，FF3 残差将比 CAPM 残差更白。在 CAPM 是真实模型的情况下（即 $\\beta_S = \\beta_H = 0$），两个残差序列都应近似为白噪声，p 值的任何差异都源于有限样本的估计方差。\n\n解决该问题的算法如下：\n1. **设置**：为了可复现性，使用一个固定的随机种子（$42$）。定义全局参数（$\\phi_M=0.6$, $\\phi_S=0.5$, $\\phi_H=0.4$）。不失一般性地，将 DGP 中的截距 $\\alpha$ 设为 $0$，因为带截距项的普通最小二乘法（OLS）对此类平移是不变的。\n\n2. **因子生成**：将因子过程（$M_t, \\mathrm{SMB}_t, \\mathrm{HML}_t$）生成为长度为 $T_{\\max}=600$ 期的 AR($1$) 序列，这是测试套件要求的最大长度。对于每个因子 $f \\in \\{M,S,H\\}$，新息方差设为 $\\sigma^2_{\\eta,f} = 1 - \\phi_f^2$，以确保因子的平稳方差为 $1$。初始条件为 $M_0=\\mathrm{SMB}_0=\\mathrm{HML}_0=0$。\n\n3. **迭代分析**：我们遍历四个测试用例中的每一个。对于一个给定的参数为 $(T, \\beta_M, \\beta_S, \\beta_H, \\sigma_{\\varepsilon}, m)$ 的用例：\n    a. 我们选择已生成的因子序列的前 $T$ 个观测值。\n    b. 使用特定于该用例的 $\\beta$ 参数和一列新的高斯白噪声误差 $\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma_{\\varepsilon}^2)$ 来合成资产收益序列 $R_t^e$。\n    c. 使用普通最小二乘法（OLS）估计两个模型：\n        i. CAPM: $R_t^e$ 对一个常数和 $M_t$ 的回归。\n        ii. FF3: $R_t^e$ 对一个常数、$M_t$、$\\mathrm{SMB}_t$ 和 $\\mathrm{HML}_t$ 的回归。\n    d. 为每个模型计算残差向量 $e^{\\mathrm{CAPM}}$ 和 $e^{\\mathrm{FF3}}$。\n    e. 使用提供的样本自相关 $\\hat{r}_k$ 和 $Q(m)$ 统计量的公式，以及一个 $\\chi^2_m$ 参考分布，为两个残差序列计算 Ljung-Box p 值。\n    f. 通过条件 $p_{\\mathrm{FF3}} > p_{\\mathrm{CAPM}}$ 确定一个布尔结果。\n\n4. **最终输出**：将四个布尔结果的列表按指定格式进行格式化和打印。\n\n实现将使用 `numpy` 进行数组计算并通过 `numpy.linalg.lstsq` 进行 OLS 估计，并使用 `scipy.stats.chi2.cdf` 计算卡方累积分布函数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Solves the problem by simulating asset returns, estimating CAPM and FF3 models,\n    and comparing the whiteness of their residuals using the Ljung-Box test.\n    \"\"\"\n    # Define global simulation parameters and random seed for reproducibility.\n    SEED = 42\n    rng = np.random.default_rng(SEED)\n    \n    phi_M = 0.6\n    phi_S = 0.5\n    phi_H = 0.4\n    alpha = 0.0  # Assumed value, does not affect residuals with intercept.\n\n    # Define the test suite.\n    test_cases = [\n        # (T, beta_M, beta_S, beta_H, sigma_eps, m)\n        (600, 0.9, 0.5, -0.3, 0.5, 10),\n        (600, 1.1, 0.0, 0.0, 0.5, 10),\n        (120, 0.0, 0.8, 0.8, 0.5, 10),\n        (60, 0.0, 0.0, 0.0, 1.0, 10),\n    ]\n\n    T_max = max(case[0] for case in test_cases)\n\n    def generate_ar1(T, phi, rng_gen):\n        \"\"\"Generates an AR(1) process of length T with stationary variance 1.\"\"\"\n        sigma_eta = np.sqrt(1 - phi**2)\n        eta = rng_gen.normal(loc=0.0, scale=sigma_eta, size=T)\n        process = np.zeros(T)\n        # Process starts at t=1 with F_0 = 0.\n        # F_1 = phi * F_0 + eta_1 = eta_1.\n        if T > 0:\n            process[0] = eta[0]\n            for t in range(1, T):\n                process[t] = phi * process[t-1] + eta[t]\n        return process\n\n    # Generate a single common realization of factor processes.\n    M_full = generate_ar1(T_max, phi_M, rng)\n    SMB_full = generate_ar1(T_max, phi_S, rng)\n    HML_full = generate_ar1(T_max, phi_H, rng)\n    \n    def ljung_box_p_value(residuals, m):\n        \"\"\"Computes the Ljung-Box Q-statistic and its p-value.\"\"\"\n        T = len(residuals)\n        e_bar = np.mean(residuals) # Should be ~0 for OLS with intercept\n        e_demeaned = residuals - e_bar\n        \n        denominator = np.sum(e_demeaned**2)\n        if denominator  1e-12:  # Avoid division by zero\n            return 1.0  # No variation means no autocorrelation.\n\n        q_terms = []\n        for k in range(1, m + 1):\n            numerator_k = np.sum(e_demeaned[k:] * e_demeaned[:-k])\n            r_k = numerator_k / denominator\n            q_terms.append(r_k**2 / (T - k))\n            \n        Q_m = T * (T + 2) * np.sum(q_terms)\n        \n        # p-value from chi-square distribution with m degrees of freedom.\n        p_val = 1.0 - chi2.cdf(Q_m, df=m)\n        return p_val\n\n    results = []\n    for case in test_cases:\n        T, beta_M, beta_S, beta_H, sigma_eps, m = case\n\n        # Use the first T observations of the common factor series.\n        M_t = M_full[:T]\n        SMB_t = SMB_full[:T]\n        HML_t = HML_full[:T]\n\n        # Generate asset returns for the current case.\n        epsilon = rng.normal(loc=0.0, scale=sigma_eps, size=T)\n        R_e = alpha + beta_M * M_t + beta_S * SMB_t + beta_H * HML_t + epsilon\n\n        # (1) Estimate CAPM and get residuals.\n        X_capm = np.vstack([np.ones(T), M_t]).T\n        beta_hat_capm = np.linalg.lstsq(X_capm, R_e, rcond=None)[0]\n        e_capm = R_e - X_capm @ beta_hat_capm\n        \n        # (2) Estimate Fama-French 3-factor model and get residuals.\n        X_ff3 = np.vstack([np.ones(T), M_t, SMB_t, HML_t]).T\n        beta_hat_ff3 = np.linalg.lstsq(X_ff3, R_e, rcond=None)[0]\n        e_ff3 = R_e - X_ff3 @ beta_hat_ff3\n\n        # Compute Ljung-Box p-values for both residual series.\n        p_val_capm = ljung_box_p_value(e_capm, m)\n        p_val_ff3 = ljung_box_p_value(e_ff3, m)\n\n        # Compare p-values to determine which residual set is \"whiter\".\n        is_ff3_whiter = p_val_ff3 > p_val_capm\n        results.append(is_ff3_whiter)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2448010"}, {"introduction": "现实世界的金融市场并非静止不变，资产定价因子与回报之间的关系可能会随着整体经济环境的变化而改变。这个高级实践将带你超越静态的线性三因子模型，引入一个动态的状态转换框架。你将通过实现一个隐马尔可夫模型（Hidden Markov Model），允许因子溢价（factor premia）根据一个不可观测的经济“状态”（如牛市或熊市）进行切换，从而学习一种更动态、更贴近现实的资产定价方法。[@problem_id:2392227]", "problem": "给定一个用于预期回报的 Fama-French 三因子模型的双状态转换公式。对于单个资产，其对市场、小市值减大市值 (SMB) 和高账面市值比减低账面市值比 (HML) 因子的因子敞口分别为 $\\beta_{M}$、$\\beta_{S}$ 和 $\\beta_{H}$，其条件期望超额回报被假定为依赖于经济的潜在状态 $S_t \\in \\{1,2\\}$，这种依赖性通过 SMB 和 HML 因子的状态依赖因子溢价体现。具体来说，在每个时间点 $t$，观测到的超额回报 $r_t$ 被建模为\n$$\nr_t \\mid S_t=s \\sim \\mathcal{N}\\left(\\mu_s, \\sigma^2\\right), \\quad s \\in \\{1,2\\},\n$$\n其条件均值为\n$$\n\\mu_s \\;=\\; \\beta_{M}\\,\\lambda_{M} \\;+\\; \\beta_{S}\\,\\lambda_{SMB}^{(s)} \\;+\\; \\beta_{H}\\,\\lambda_{HML}^{(s)},\n$$\n其中 $\\lambda_{M}$ 是市场溢价，$\\lambda_{SMB}^{(s)}$ 和 $\\lambda_{HML}^{(s)}$ 是 SMB 和 HML 因子的状态依赖因子溢价。潜在状态 $\\{S_t\\}$ 服从一个时间齐次一阶马尔可夫链，其转移矩阵为\n$$\nP \\;=\\; \n\\begin{bmatrix}\np_{11}  p_{12} \\\\\np_{21}  p_{22}\n\\end{bmatrix},\n\\quad \\text{其中 } p_{ij} = \\mathbb{P}(S_t=j \\mid S_{t-1}=i), \\; p_{12}=1-p_{11}, \\; p_{21}=1-p_{22}.\n$$\n设初始状态分布为 $\\pi_0 = \\big(\\mathbb{P}(S_0=1), \\mathbb{P}(S_0=2)\\big)$。\n\n您的任务是为每个提供的测试用例计算：\n- 在指定模型下，观测序列 $\\{r_t\\}_{t=1}^{T}$ 的总对数似然，以及\n- 滤波概率 $\\mathbb{P}(S_T=1 \\mid r_1,\\dots,r_T)$。\n\n所有回报都是以十进制形式表示的超额回报。高斯似然必须使用指定的方差 $\\sigma^2$ 通过精确的密度函数计算。结果必须报告为四舍五入到六位小数的实数。\n\n测试套件：\n- 测试用例 A：\n  - 参数：\n    - $\\beta_{M} = 1.1$, $\\beta_{S} = 0.4$, $\\beta_{H} = -0.2$。\n    - $\\lambda_{M} = 0.006$。\n    - $\\lambda_{SMB}^{(1)} = 0.004$, $\\lambda_{HML}^{(1)} = 0.002$；$\\lambda_{SMB}^{(2)} = -0.001$, $\\lambda_{HML}^{(2)} = 0.005$。\n    - $\\sigma = 0.01$。\n    - $P = \\begin{bmatrix} 0.9  0.1 \\\\ 0.2  0.8 \\end{bmatrix}$。\n    - $\\pi_0 = \\big(2/3,\\, 1/3\\big)$。\n  - 观测值 (十进制)：$[\\,0.006,\\,0.009,\\,0.004,\\,0.007,\\,0.005,\\,0.008\\,]$。\n- 测试用例 B：\n  - 参数：\n    - $\\beta_{M} = 0.9$, $\\beta_{S} = 0.7$, $\\beta_{H} = 0.3$。\n    - $\\lambda_{M} = 0.005$。\n    - $\\lambda_{SMB}^{(1)} = 0.003$, $\\lambda_{HML}^{(1)} = 0.001$；$\\lambda_{SMB}^{(2)} = -0.002$, $\\lambda_{HML}^{(2)} = -0.001$。\n    - $\\sigma = 0.008$。\n    - $P = \\begin{bmatrix} 0.99  0.01 \\\\ 0.02  0.98 \\end{bmatrix}$。\n    - $\\pi_0 = \\big(2/3,\\,1/3\\big)$。\n  - 观测值 (十进制)：$[\\,0.0065,\\,0.0072,\\,0.0023,\\,0.0030,\\,0.0068\\,]$。\n- 测试用例 C (状态均值相等的边界情况)：\n  - 参数：\n    - $\\beta_{M} = 1.0$, $\\beta_{S} = 0.5$, $\\beta_{H} = 0.5$。\n    - $\\lambda_{M} = 0.004$。\n    - $\\lambda_{SMB}^{(1)} = 0.002$, $\\lambda_{HML}^{(1)} = 0.001$；$\\lambda_{SMB}^{(2)} = 0.002$, $\\lambda_{HML}^{(2)} = 0.001$。\n    - $\\sigma = 0.012$。\n    - $P = \\begin{bmatrix} 0.6  0.4 \\\\ 0.3  0.7 \\end{bmatrix}$。\n    - $\\pi_0 = \\big(3/7,\\,4/7\\big)$。\n  - 观测值 (十进制)：$[\\,0.0040,\\,0.0060,\\,0.0050,\\,0.0070\\,]$。\n\n要求的最终输出格式：\n- 您的程序必须生成单行输出，该行包含一个列表，每个测试用例对应一个条目。\n- 每个条目必须是一个包含两个元素的列表，其中包含：\n  - 总对数似然（四舍五入到六位小数），以及\n  - 滤波概率 $\\mathbb{P}(S_T=1 \\mid r_1,\\dots,r_T)$（四舍五入到六位小数）。\n- 确切的字符串格式必须是：[[\\ell_A,p_A],[\\ell_B,p_B],[\\ell_C,p_C]]，其中 $\\ell_\\cdot$ 和 $p_\\cdot$ 分别是测试用例 A、B 和 C 的四舍五入后的值。", "solution": "该问题要求计算由双状态转换 Fama-French 模型生成的资产回报序列的总对数似然和最终滤波状态概率。这是一个隐马尔可夫模型 (HMM) 的经典应用，其标准解决方法是前向-后向算法的前向传递部分，通常称为 Hamilton 滤波器。\n\n该模型规定如下：\n在时间 $t$ 观测到的超额回报（记为 $r_t$）是从高斯分布中抽取的，其参数取决于潜在状态 $S_t \\in \\{1, 2\\}$。\n$$\nr_t \\mid S_t=s \\sim \\mathcal{N}(\\mu_s, \\sigma^2)\n$$\n状态依赖均值 $\\mu_s$ 是三个因子的线性函数，其中 SMB 和 HML 因子具有状态依赖的溢价：\n$$\n\\mu_s = \\beta_{M}\\lambda_{M} + \\beta_{S}\\lambda_{SMB}^{(s)} + \\beta_{H}\\lambda_{HML}^{(s)}\n$$\n潜在状态序列 $\\{S_t\\}$ 是一个一阶马尔可夫链，具有给定的转移矩阵 $P$ 和状态 $S_0$ 的初始状态分布 $\\pi_0$。观测数据从 $t=1$ 到 $t=T$ 提供。\n\n目标是计算总对数似然 $\\mathcal{L} = \\log \\mathbb{P}(r_1, \\dots, r_T)$ 和滤波概率 $\\mathbb{P}(S_T=1 \\mid r_1, \\dots, r_T)$。这可以通过递归计算滤波概率 $\\pi_{t|t} = (\\mathbb{P}(S_t=1 \\mid \\mathcal{F}_t), \\mathbb{P}(S_t=2 \\mid \\mathcal{F}_t))$ 来完成，其中 $\\mathcal{F}_t = \\{r_1, \\dots, r_t\\}$ 是在时间 $t$ 的信息集。\n\nHamilton 滤波器算法对 $t = 1, \\dots, T$ 进行迭代：\n\n1.  **初始化**：过程从 $t=1$ 开始。在观测到 $r_1$ 之前，我们需要状态 $S_1$ 的概率分布。这是在 $t=1$ 时的预测概率，以 $t=0$ 时的信息为条件（从观测角度看，信息为空）。问题将 $S_0$ 的分布指定为 $\\pi_0$。因此，$S_1$ 的预测概率向量是 $\\pi_{1|0} = \\pi_0 P$，其中 $P$ 是转移矩阵。对于递归的第一步，我们使用 $\\pi_{0|0} = \\pi_0$。\n\n2.  **递归步骤 ($t=1, \\dots, T$)**：给定上一步的滤波概率 $\\pi_{t-1|t-1} = (\\mathbb{P}(S_{t-1}=1 \\mid \\mathcal{F}_{t-1}), \\mathbb{P}(S_{t-1}=2 \\mid \\mathcal{F}_{t-1}))$，我们执行两个操作：预测和更新。\n\n    a.  **预测步**：我们使用马尔可夫性质预测时间 $t$ 的状态概率：\n        $$\n        \\pi_{t|t-1} = \\pi_{t-1|t-1} P\n        $$\n        其中 $\\pi_{t|t-1}(j) = \\mathbb{P}(S_t=j \\mid \\mathcal{F}_{t-1})$。\n\n    b.  **更新步**：观测到 $r_t$ 后，我们使用贝叶斯定理更新我们对状态 $S_t$ 的信念。\n        首先，我们计算每个状态 $s \\in \\{1, 2\\}$ 下观测值 $r_t$ 的条件概率密度，我们将其表示为 $\\eta_s(r_t)$：\n        $$\n        \\eta_s(r_t) = f(r_t \\mid S_t=s) = \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{(r_t - \\mu_s)^2}{2\\sigma^2}\\right)\n        $$\n        给定过去的观测值 $\\mathcal{F}_{t-1}$，观测到 $r_t$ 的边际似然是这些密度的加权平均，权重由预测概率给出：\n        $$\n        f(r_t \\mid \\mathcal{F}_{t-1}) = \\sum_{s=1}^{2} f(r_t \\mid S_t=s) \\mathbb{P}(S_t=s \\mid \\mathcal{F}_{t-1}) = \\sum_{s=1}^{2} \\eta_s(r_t) \\pi_{t|t-1}(s)\n        $$\n        整个序列的对数似然是每个时间步这些边际似然的对数之和：\n        $$\n        \\mathcal{L} = \\sum_{t=1}^{T} \\log f(r_t \\mid \\mathcal{F}_{t-1})\n        $$\n        最后，通过使用来自 $r_t$ 的信息更新预测概率来计算滤波概率向量 $\\pi_{t|t}$：\n        $$\n        \\pi_{t|t}(s) = \\mathbb{P}(S_t=s \\mid \\mathcal{F}_t) = \\frac{f(r_t \\mid S_t=s) \\mathbb{P}(S_t=s \\mid \\mathcal{F}_{t-1})}{f(r_t \\mid \\mathcal{F}_{t-1})} = \\frac{\\eta_s(r_t) \\pi_{t|t-1}(s)}{\\sum_{k=1}^{2} \\eta_k(r_t) \\pi_{t|t-1}(k)}\n        $$\n\n这个递归过程应用于 $t=1, \\dots, T$。在最后一步 $t=T$ 之后，累加和即为总对数似然 $\\mathcal{L}$，最终的滤波概率向量为 $\\pi_{T|T}$。问题要求此向量的第一个分量，即 $\\mathbb{P}(S_T=1 \\mid \\mathcal{F}_T)$。\n\n对于测试用例 C，我们注意到状态依赖的均值是相同的，即 $\\mu_1 = \\mu_2$。这意味着条件密度也是相同的，对于任何 $r_t$ 都有 $\\eta_1(r_t) = \\eta_2(r_t)$。因此，观测值 $r_t$ 不提供区分状态的信息。更新步骤简化为 $\\pi_{t|t}(s) = \\pi_{t|t-1}(s)$。因此，滤波概率仅仅根据马尔可夫链的动态演化：$\\pi_{t|t} = \\pi_{t-1|t-1} P$。由于提供的初始分布 $\\pi_0 = (3/7, 4/7)$ 是给定转移矩阵 $P$ 的平稳分布，因此对于所有 $t$ 都有 $\\pi_{t|t} = \\pi_0$。最终的滤波概率 $\\mathbb{P}(S_T=1 \\mid \\mathcal{F}_T)$ 因此必须是 $3/7$。对数似然只是在单一均值 $\\mu = \\mu_1 = \\mu_2$ 处评估的对数密度之和。\n\n实现将对每个测试用例遵循此逻辑，计算状态依赖的均值，然后遍历观测值以执行滤波器递归。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the regime-switching Fama-French model problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"betas\": (1.1, 0.4, -0.2), # (beta_M, beta_S, beta_H)\n            \"lambda_M\": 0.006,\n            \"lambda_s1\": (0.004, 0.002), # (lambda_SMB_1, lambda_HML_1)\n            \"lambda_s2\": (-0.001, 0.005), # (lambda_SMB_2, lambda_HML_2)\n            \"sigma\": 0.01,\n            \"P\": np.array([[0.9, 0.1], [0.2, 0.8]]),\n            \"pi0\": np.array([2/3, 1/3]),\n            \"observations\": [0.006, 0.009, 0.004, 0.007, 0.005, 0.008]\n        },\n        {\n            \"betas\": (0.9, 0.7, 0.3),\n            \"lambda_M\": 0.005,\n            \"lambda_s1\": (0.003, 0.001),\n            \"lambda_s2\": (-0.002, -0.001),\n            \"sigma\": 0.008,\n            \"P\": np.array([[0.99, 0.01], [0.02, 0.98]]),\n            \"pi0\": np.array([2/3, 1/3]),\n            \"observations\": [0.0065, 0.0072, 0.0023, 0.0030, 0.0068]\n        },\n        {\n            \"betas\": (1.0, 0.5, 0.5),\n            \"lambda_M\": 0.004,\n            \"lambda_s1\": (0.002, 0.001),\n            \"lambda_s2\": (0.002, 0.001),\n            \"sigma\": 0.012,\n            \"P\": np.array([[0.6, 0.4], [0.3, 0.7]]),\n            \"pi0\": np.array([3/7, 4/7]),\n            \"observations\": [0.0040, 0.0060, 0.0050, 0.0070]\n        }\n    ]\n\n    def run_filter(case):\n        \"\"\"\n        Implements the Hamilton filter for a single test case.\n        \"\"\"\n        beta_m, beta_s, beta_h = case[\"betas\"]\n        lambda_m = case[\"lambda_M\"]\n        lambda_smb1, lambda_hml1 = case[\"lambda_s1\"]\n        lambda_smb2, lambda_hml2 = case[\"lambda_s2\"]\n        sigma = case[\"sigma\"]\n        P = case[\"P\"]\n        pi0 = case[\"pi0\"]\n        observations = case[\"observations\"]\n\n        # Calculate state-dependent means\n        mu1 = beta_m * lambda_m + beta_s * lambda_smb1 + beta_h * lambda_hml1\n        mu2 = beta_m * lambda_m + beta_s * lambda_smb2 + beta_h * lambda_hml2\n        \n        mus = np.array([mu1, mu2])\n\n        total_log_likelihood = 0.0\n        # Initialize filtered probability with pi0 (for state S_0)\n        filtered_prob = pi0\n\n        for r_t in observations:\n            # Prediction step: P(S_t | F_{t-1}) = P(S_{t-1} | F_{t-1}) * P\n            predicted_prob = filtered_prob @ P\n            \n            # Likelihood of observation r_t in each state\n            # eta_s = P(r_t | S_t=s)\n            emission_likelihoods = norm.pdf(r_t, loc=mus, scale=sigma)\n            \n            # Marginal likelihood of observation r_t\n            # f(r_t | F_{t-1})\n            marginal_likelihood = np.dot(predicted_prob, emission_likelihoods)\n            \n            # Update total log-likelihood\n            total_log_likelihood += np.log(marginal_likelihood)\n            \n            # Update step: P(S_t | F_t)\n            # using Bayes' rule: P(S_t | r_t, F_{t-1}) approx P(S_t | F_t)\n            numerator = predicted_prob * emission_likelihoods\n            filtered_prob = numerator / marginal_likelihood\n        \n        final_filtered_prob_s1 = filtered_prob[0]\n        \n        return [round(total_log_likelihood, 6), round(final_filtered_prob_s1, 6)]\n\n    results = []\n    for case in test_cases:\n        results.append(run_filter(case))\n\n    # Format the output string to match the required format exactly.\n    # The format [l,p] should not have spaces after the comma.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "2392227"}]}