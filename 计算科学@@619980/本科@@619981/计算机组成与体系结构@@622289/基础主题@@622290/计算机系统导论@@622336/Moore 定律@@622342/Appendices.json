{"hands_on_practices": [{"introduction": "摩尔定律描述了晶体管数量的指数级增长，但我们如何从原始数据中验证并量化这一趋势呢？本练习将指导你运用数据线性化这一核心科学方法，通过对数变换将指数关系转化为线性关系，从而能够使用标准的线性回归技术来估计增长率和倍增时间。这项实践不仅能加深你对摩尔定律数学本质的理解，还能让你掌握一种在众多科学和工程领域中分析指数过程的通用技能。 [@problem_id:3221591]", "problem": "要求您在与摩尔定律相关的指数增长模型假设下，分析晶体管数量与日历年之间的经验关系。请使用符合上下文的基本原理，即指数增长由一个其值与其当前值成比例增加的函数来描述，从而导致其对自变量呈指数依赖关系。具体来说，假设晶体管数量 $N$ 作为日历年 $t$ 的函数，遵循一个带有未知参数的指数模型 $N(t)$。您的任务是执行数据线性化以估计这些参数，量化拟合优度，并进行预测。\n\n从指数增长和自然对数函数的基本定义出发，对数据进行变换，以使普通最小二乘法（OLS）线性回归的应用是合适的。根据此回归，为每个数据集计算以下量：\n- 估计的年指数增长率，记为 $k$，以实数形式表示，单位为 $1/\\text{年}$。\n- 估计的倍增时间 $T_d$，定义为在指数模型下晶体管数量翻倍所需的时间（以年为单位），以实数形式表示，单位为年。\n- 变换后数据的线性拟合的决定系数（记为 $R^2$），以实数形式表示。\n- 预测晶体管数量首次达到阈值 $N_{\\text{th}}$ 的日历年 $t^\\star$，以实数形式表示，单位为年。\n\n对于任何对数变换，请使用自然对数（以 $e$ 为底）。使用 $N_{\\text{th}} = 10^{10}$ 个晶体管作为阈值。\n\n测试套件：\n为以下三个数据集提供结果：\n- 案例 A（一般现实数据集）：\n  年份 $[1971, 1972, 1974, 1978, 1982, 1985, 1989, 1993, 1997, 2000, 2005, 2010]$,\n  晶体管数量 $[2300, 3500, 6000, 29000, 120000, 275000, 1200000, 3100000, 7500000, 42000000, 291000000, 2300000000]$。\n- 案例 B（边界数据集，含两个点）：\n  年份 $[1971, 1974]$,\n  晶体管数量 $[2300, 6000]$。\n- 案例 C（边缘数据集，含一个离群值）：\n  年份 $[1978, 1982, 1985, 1989, 1993, 1997, 2000]$,\n  晶体管数量 $[29000, 120000, 275000, 1200000, 3100000, 250000000, 42000000]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个案例的结果必须是按 $[k, T_d, R^2, t^\\star]$ 顺序排列的四个实数列表。将三个案例的结果聚合为一个列表的列表。例如，最终输出必须类似于 $[[k_A, T_{d,A}, R^2_A, t^\\star_A],[k_B, T_{d,B}, R^2_B, t^\\star_B],[k_C, T_{d,C}, R^2_C, t^\\star_C]]$，其中所有量都以实数表示，$T_d$ 和 $t^\\star$ 的单位为年。", "solution": "用户提供的问题被评估为有效，因为它具有科学依据、问题明确且客观。它展示了一个数据线性化和回归分析的标准练习，该练习牢固地植根于数值方法和科学计算。所有数据、定义和约束都已提供，从而可以得到唯一且可验证的解。\n\n该问题要求基于通常与摩尔定律相关的指数增长模型，对晶体管数量随时间变化的数据进行分析。晶体管数量 $N$ 作为日历年 $t$ 的函数的模型由以下指数关系给出：\n$$N(t) = N_0 e^{k(t-t_0)}$$\n其中 $k$ 是指数增长率，$N_0$ 是参考年份 $t_0$ 时的晶体管数量。这个方程可以重写为更通用的形式 $N(t) = A e^{kt}$，其中常数 $A = N_0 e^{-kt_0}$ 整合了初始条件。\n\n为了从一组数据点 $(t_i, N_i)$ 估计参数 $k$ 和 $A$，我们按照问题陈述中的规定，通过应用自然对数来线性化模型。对等式两边取自然对数，得到：\n$$\\ln(N(t)) = \\ln(A e^{kt})$$\n利用对数的性质，这可以分解为：\n$$\\ln(N(t)) = \\ln(A) + \\ln(e^{kt})$$\n$$\\ln(N(t)) = kt + \\ln(A)$$\n此方程是直线形式 $y = mx + c$，其中：\n-   变换后的因变量是 $y = \\ln(N)$。\n-   自变量是 $x = t$。\n-   直线的斜率是 $m = k$。\n-   直线的 y 轴截距是 $c = \\ln(A)$。\n\n现在我们可以对变换后的数据点 $(x_i, y_i) = (t_i, \\ln(N_i))$ 使用普通最小二乘法（OLS）线性回归，以找到斜率 $m$ 和截距 $c$ 的最佳拟合值。这些参数最小化了观测值 $y_i$ 与线性模型预测值 $f(x_i) = mx_i + c$ 之间的平方差之和。\n\n一旦确定了回归线的斜率 $m$ 和截距 $c$，我们就可以为每个数据集计算所需的四个量。\n\n1.  **指数增长率 ($k$)**：增长率 $k$ 直接由半对数图上线性拟合的斜率 $m$ 给出。\n    $$k = m$$\n    其单位是 $1/\\text{年}$，因为它表示单位时间内的分数增长。\n\n2.  **倍增时间 ($T_d$)**：倍增时间是晶体管数量翻倍所需的时间段。我们寻求一个时间间隔 $T_d = t_2 - t_1$，使得 $N(t_2) = 2N(t_1)$。\n    $$A e^{kt_2} = 2 A e^{kt_1}$$\n    $$e^{k(t_2 - t_1)} = 2$$\n    $$k(t_2 - t_1) = \\ln(2)$$\n    求解时间间隔 $T_d = t_2 - t_1$ 可得：\n    $$T_d = \\frac{\\ln(2)}{k}$$\n    $T_d$ 的单位是年。\n\n3.  **决定系数 ($R^2$)**：该值量化了线性模型的拟合优度。它表示因变量（$y = \\ln(N)$）的方差中可由自变量（$x = t$）预测的部分。其计算公式为：\n    $$R^2 = 1 - \\frac{SS_{\\text{res}}}{SS_{\\text{tot}}}$$\n    其中 $SS_{\\text{res}} = \\sum_{i} (y_i - f(x_i))^2$ 是残差平方和（观测值与预测值之差），而 $SS_{\\text{tot}} = \\sum_{i} (y_i - \\bar{y})^2$ 是总平方和（观测数据的方差），$\\bar{y}$ 是观测值 $y_i$ 的平均值。对于简单线性回归，$R^2$ 也是 $x$ 和 $y$ 变量之间皮尔逊相关系数的平方。\n\n4.  **预测年份 ($t^\\star$)**：我们需要找到晶体管数量达到阈值 $N_{\\text{th}} = 10^{10}$ 的年份 $t^\\star$。使用我们的拟合线性模型，我们设 $y = \\ln(N_{\\text{th}})$ 并求解 $x = t^\\star$：\n    $$\\ln(N_{\\text{th}}) = k t^\\star + c$$\n    重新整理以求解 $t^\\star$ 可得：\n    $$t^\\star = \\frac{\\ln(N_{\\text{th}}) - c}{k}$$\n    代入 $N_{\\text{th}} = 10^{10}$，我们得到：\n    $$t^\\star = \\frac{\\ln(10^{10}) - c}{k} = \\frac{10\\ln(10) - c}{k}$$\n    $t^\\star$ 的单位是年。\n\n该过程将应用于所提供的三个数据集中的每一个。对于案例 B，由于只包含两个数据点，线性拟合将是完美的，导致 $SS_{\\text{res}} = 0$ 从而 $R^2 = 1$。对于案例 C，与没有此类点的数据集相比，离群值的存在预计会降低 $R^2$ 的值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes transistor count data using data linearization and OLS regression\n    to estimate parameters of an exponential growth model (Moore's Law).\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            # Case A (general realistic dataset)\n            np.array([1971, 1972, 1974, 1978, 1982, 1985, 1989, 1993, 1997, 2000, 2005, 2010], dtype=np.float64),\n            np.array([2300, 3500, 6000, 29000, 120000, 275000, 1200000, 3100000, 7500000, 42000000, 291000000, 2300000000], dtype=np.float64),\n        ),\n        (\n            # Case B (boundary dataset with two points)\n            np.array([1971, 1974], dtype=np.float64),\n            np.array([2300, 6000], dtype=np.float64),\n        ),\n        (\n            # Case C (edge dataset with an outlier)\n            np.array([1978, 1982, 1985, 1989, 1993, 1997, 2000], dtype=np.float64),\n            np.array([29000, 120000, 275000, 1200000, 3100000, 250000000, 42000000], dtype=np.float64),\n        ),\n    ]\n\n    all_results = []\n    N_th = 10.0**10.0\n\n    for t_data, N_data in test_cases:\n        # Linearize the data by taking the natural logarithm of the transistor counts.\n        # The model is N(t) = A * exp(k*t).\n        # Linear form: ln(N) = k*t + ln(A), where y = ln(N), x = t, m = k, c = ln(A)\n        x = t_data\n        y = np.log(N_data)\n\n        # Perform Ordinary Least Squares (OLS) linear regression to find slope (m) and intercept (c).\n        # np.polyfit(x, y, 1) returns [m, c] for a first-degree polynomial (a line).\n        m, c = np.polyfit(x, y, 1)\n\n        # 1. Calculate the exponential growth rate, k.\n        k = m\n\n        # 2. Calculate the doubling time, T_d.\n        # T_d = ln(2) / k\n        Td = np.log(2) / k\n\n        # 3. Calculate the coefficient of determination, R^2.\n        # For simple linear regression, R^2 is the square of the Pearson correlation coefficient.\n        # This is a numerically stable way to compute R^2.\n        # An R^2 of 1.0 indicates a perfect fit.\n        # A special case check for ss_tot=0 is not strictly necessary here since\n        # all input t_data arrays have variance.\n        correlation_matrix = np.corrcoef(x, y)\n        correlation_xy = correlation_matrix[0, 1]\n        R2 = correlation_xy**2\n        \n        # Handle the edge case of perfect anti-correlation in a 2-point case if x decreases while y increases\n        # (not present in this problem's data but good practice). Here, all correlations are positive.\n        if m == 0 and np.std(y) > 0: # Avoid division by zero for Td and t_star\n            R2 = 0.0 # No correlation if slope is zero\n            Td = np.inf\n            t_star = np.inf\n        elif np.std(y) == 0: # All y values are the same\n            R2 = 0.0 # No variance to explain\n            Td = np.inf if m == 0 else (np.inf if m0 else np.log(2)/m)\n            t_star = np.inf if y[0]  np.log(N_th) else (-np.inf if y[0] > np.log(N_th) else x[0])\n        else:\n            # 4. Predict the year t_star when the transistor count reaches N_th.\n            # ln(N_th) = k * t_star + c  => t_star = (ln(N_th) - c) / k\n            t_star = (np.log(N_th) - c) / k\n\n        all_results.append([k, Td, R2, t_star])\n    \n    # Format the final output string as a list of lists.\n    # We use f-strings and map to create the desired output format.\n    result_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```", "id": "3221591"}, {"introduction": "摩尔定律的预测为芯片设计者提供了不断增长的晶体管“预算”。然而，如何明智地“花费”这些资源以最大化性能，是一个核心的工程挑战。本练习将你置于微架构师的角色，你需要根据摩尔定律预测的可用晶体管数量和功耗限制，来决定如何在二级（L2）和三级（L3）缓存之间进行最优划分，以最小化每指令周期数（CPI）。通过解决这个优化问题，你将体会到在现实约束下进行工程权衡的精髓。 [@problem_id:3659947]", "problem": "一位微架构师在面临新一代半导体技术的缓存层次结构大小决策时，试图利用摩尔定律预测的规模缩放效应，在二级（L2）和三级（L3）缓存之间分配总缓存容量。其目标是通过选择L2和L3的大小，在满足特定技术代下产生的实际面积和功耗限制的条件下，最小化每指令周期数（CPI）。\n\n这个问题的基本依据是摩尔定律的定义，以及经过充分检验的关于缓存未命中率作为缓存容量函数的经验关系，和因缓存未命中导致的停頓周期的标准期望模型：\n- 摩尔定律：晶体管数量大约每隔一个固定周期翻一番，因此在时间 $t$ 之后，晶体管数量为 $T(t) = T_0 \\cdot 2^{t/\\tau}$。\n- 静态随机存取存储器（SRAM）位单元成本和开销决定了在给定的晶体管预算下可以构建多少字节的SRAM。\n- 由存储层次结构未命中导致的每指令预期停頓周期数，是通过将每条指令的平均内存访问次数与各级缓存的未命中概率及其相应的停頓惩罚相乘来建模的。\n\n给定以下场景：\n- 在 $t=0$ 时，基准晶體管數量为 $T_0 = 1.0 \\times 10^9$ 个。\n- 翻倍周期为 $\\tau = 2$ 年。考虑 $t = 6$ 年。因此，适用公式 $T(t) = T_0 \\cdot 2^{t/\\tau}$。\n- 总晶体管预算的 $\\phi = 0.25$ 部分被预留给片上缓存（L2加L3）。\n- 每个SRAM位单元成本为 $n_b = 6$ 个晶体管，并且每字节的外围电路有一个固定的开销因子 $k_{\\text{ov}} = 1.5$。将 $1$ 字节视为 $8$ 位。因此，每字节的晶体管成本为 $n_{\\text{byte}} = n_b \\cdot 8 \\cdot k_{\\text{ov}}$。\n- 可用于片上缓存的动态随机存取存储器（DRAM）接口功率预算为 $P_{\\max} = 5$ W，而每 mebibyte 的动态功耗成本为 $p_{\\text{MiB}} = 0.2$ W。因此，以 mebibyte 为单位的功耗限制的总缓存容量为 $S_{\\text{power}} = P_{\\max} / p_{\\text{MiB}}$。\n- 将有效总缓存容量预算取为 $S_{\\text{tot}} = \\min\\{S_{\\text{area}}, S_{\\text{power}}\\}$，其中 $S_{\\text{area}}$ 是从晶体管预算得出的面积限制容量，$S_{\\text{power}}$ 是功耗限制容量，两者均以 mebibyte 为单位，并且 $1$ mebibyte 等于 $2^{20}$ 字节。\n\n该微架构师使用经过充分检验的幂律拟合，对工作区域内的未命中率与容量的关系进行建模：\n- 二级未命中率：$MR_2(S_2) = \\dfrac{a_2}{S_2}$，其中 $a_2 = 0.6$。\n- 三级未命中率：$MR_3(S_3) = \\dfrac{a_3}{S_3}$，其中 $a_3 = 0.3$。\n此处 $S_2$ 和 $S_3$ 分别是以 mebibyte 为单位测量的L2和L3大小。\n\n假设平均每条指令有 $r = 1.2$ 次内存访问，一次由三级缓存满足的二级缓存未命中会引起平均 $L_{23} = 35$ 个周期的停頓，而一次需要访问主存（动态随机存取存储器，DRAM）的三级缓存未命中会引起额外的 $L_{3M} = 200$ 个周期的停頓。设没有内存停頓时的基准CPI为 $C_0 = 1.0$。您必须从第一性原理出发，在所提供的未命中率拟合中隐含的独立性假设下，推导出一个数学上适定的CPI表达式，该表达式能解释由于L2和L3未命中导致的每指令预期停頓周期，然后确定在约束条件 $S_2 + S_3 = S_{\\text{tot}}$ 下能最小化此CPI的L2和L3大小 $S_2$ 和 $S_3$。\n\n任务：\n1. 从摩尔定律和给定的晶体管、面积和功耗数据出发，计算以 mebibyte 为单位的 $S_{\\text{tot}}$。\n2. 使用预期停頓周期的基本定义，推导出用 $MR_2(S_2)$、$MR_3(S_3)$、$r$、$L_{23}$ 和 $L_{3M}$ 表示的 $\\text{CPI}(S_2,S_3)$ 的符号表达式，然后在约束 $S_2 + S_3 = S_{\\text{tot}}$ 下将此约束最小化问题简化为单变量问题。\n3. 在提供的未命中率模型下，求解最小化CPI的最优划分 $(S_2^{\\star}, S_3^{\\star})$。\n\n请用 mebibyte (MiB) 表示最终的大小 $S_2^{\\star}$ 和 $S_3^{\\star}$，并将您的答案四舍五入到三位有效数字。最终答案必须仅为有序对 $(S_2^{\\star}, S_3^{\\star})$。", "solution": "首先根据指定标准验证问题。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n- 基准晶体管数量：$T_0 = 1.0 \\times 10^9$\n- 经过时间：$t = 6$ 年\n- 翻倍周期：$\\tau = 2$ 年\n- 晶体管数量缩放定律：$T(t) = T_0 \\cdot 2^{t/\\tau}$\n- 用于缓存（L2+L3）的晶体管预算比例：$\\phi = 0.25$\n- 每个SRAM位单元的晶体管数：$n_b = 6$\n- 外围电路的开销因子：$k_{\\text{ov}} = 1.5$\n- 每字节的位数：$8$\n- 每字节的晶体管成本：$n_{\\text{byte}} = n_b \\cdot 8 \\cdot k_{\\text{ov}}$\n- 缓存的最大功耗：$P_{\\max} = 5$ W\n- 每 mebibyte 的动态功耗成本：$p_{\\text{MiB}} = 0.2$ W/MiB\n- 功耗限制的总缓存容量：$S_{\\text{power}} = P_{\\max} / p_{\\text{MiB}}$\n- Mebibyte 定义：$1$ MiB $= 2^{20}$ 字节\n- 有效总缓存容量：$S_{\\text{tot}} = \\min\\{S_{\\text{area}}, S_{\\text{power}}\\}$\n- L2未命中率模型：$MR_2(S_2) = a_2/S_2$，其中 $a_2 = 0.6$，$S_2$ 单位为 MiB\n- L3未命中率模型：$MR_3(S_3) = a_3/S_3$，其中 $a_3 = 0.3$，$S_3$ 单位为 MiB\n- 每条指令的平均内存访问次数：$r = 1.2$\n- L2未命中、L3命中的停頓惩罚：$L_{23} = 35$ 周期\n- L3未命中的额外停頓惩罚：$L_{3M} = 200$ 周期\n- 基准CPI（无内存停頓）：$C_0 = 1.0$\n- 约束条件：$S_2 + S_3 = S_{\\text{tot}}$\n\n**步骤2：使用提取的给定信息进行验证**\n- **科学依据：** 该问题牢固地建立在计算机体系结构的既定原则之上。它利用摩尔定律进行技术缩放，使用标准模型从晶体管数量计算缓存面积，考虑了功耗限制的设计约束，并采用了基于缓存未命中率和惩罚计算每指令周期数（CPI）的常规公式。未命中率模型（$MR \\propto 1/S$）是常见的经验近似。所有方面在科学上都是合理的。\n- **适定性：** 该问题提供了一个明确的目标（最小化CPI），以及一组定义明确的约束和参数集。它要求通过在一个闭区间上最小化一个连续可微的函数来找到唯一解 $(S_2^{\\star}, S_3^{\\star})$，这是一个适定的优化问题。\n- **客观性：** 语言精确且定量。所有术语都有定义，并且提供的数据是问题背景下的客观事实。\n\n**步骤3：结论与行动**\n该问题在科学上是合理的、适定的、客观的且完整的。它被判定为**有效**。现在开始解题过程。\n\n### 解题推导\n\n解题过程按题目要求分为三个阶段进行。\n\n**1. 计算总缓存容量 $S_{\\text{tot}}$**\n\n首先，我们使用摩尔定律计算 $t=6$ 年时的总晶体管数量 $T(t)$。\n$$\nT(t) = T_0 \\cdot 2^{t/\\tau} = (1.0 \\times 10^9) \\cdot 2^{6/2} = (1.0 \\times 10^9) \\cdot 2^3 = 8.0 \\times 10^9 \\text{ 晶体管}\n$$\n用于L2和L3缓存的晶体管预算是此总数的一部分 $\\phi$。\n$$\nT_{\\text{cache}} = \\phi \\cdot T(6) = 0.25 \\cdot (8.0 \\times 10^9) = 2.0 \\times 10^9 \\text{ 晶体管}\n$$\n接下来，我们确定每字节SRAM缓存所需的晶体管数量。\n$$\nn_{\\text{byte}} = n_b \\cdot 8 \\frac{\\text{bits}}{\\text{byte}} \\cdot k_{\\text{ov}} = 6 \\cdot 8 \\cdot 1.5 = 72 \\frac{\\text{晶体管}}{\\text{字节}}\n$$\n面积限制的缓存容量 $S_{\\text{area}}$ 是总缓存晶体管预算除以每字节的成本。我们将其转换为 mebibyte (MiB)。\n$$\nS_{\\text{area}} = \\frac{T_{\\text{cache}}}{n_{\\text{byte}} \\cdot 2^{20} \\frac{\\text{bytes}}{\\text{MiB}}} = \\frac{2.0 \\times 10^9}{72 \\cdot 2^{20}} \\approx 26.491 \\text{ MiB}\n$$\n功耗限制的缓存容量 $S_{\\text{power}}$ 由总功率预算和每 mebibyte 的功耗成本确定。\n$$\nS_{\\text{power}} = \\frac{P_{\\max}}{p_{\\text{MiB}}} = \\frac{5 \\text{ W}}{0.2 \\text{ W/MiB}} = 25 \\text{ MiB}\n$$\n有效总缓存容量 $S_{\\text{tot}}$ 是面积限制容量和功耗限制容量中的较小者。\n$$\nS_{\\text{tot}} = \\min\\{S_{\\text{area}}, S_{\\text{power}}\\} = \\min\\{26.491, 25\\} = 25 \\text{ MiB}\n$$\n\n**2. 推导CPI表达式并构建优化问题**\n\n总每指令周期数（CPI）是基准CPI与因存储层次结构未命中导致的每指令停頓周期数之和。\n$$\n\\text{CPI} = C_0 + \\text{CPI}_{\\text{stall}}\n$$\n停頓CPI是每指令内存访问次数 $r$ 与每次内存访问的平均停頓周期数的乘积。停頓周期由L2未命中引起。\n$$\n\\text{CPI}_{\\text{stall}} = r \\cdot MR_2(S_2) \\cdot (\\text{平均L2未命中惩罚})\n$$\n一次L2未命中可能在L3缓存中命中，也可能在L3缓存中未命中。问题将 $MR_3(S_3)$ 定义为L3未命中率，这被解释为到达L3的访问的局部未命中率。\n因此，平均L2未命中惩罚为：\n$$\n(\\text{平均L2未命中惩罚}) = P(\\text{L3命中} | \\text{L2未命中}) \\cdot L_{23} + P(\\text{L3未命中} | \\text{L2未命中}) \\cdot (L_{23} + L_{3M})\n$$\n$$\n= (1 - MR_3(S_3)) \\cdot L_{23} + MR_3(S_3) \\cdot (L_{23} + L_{3M}) = L_{23} + MR_3(S_3) \\cdot L_{3M}\n$$\n将此代回CPI表达式中：\n$$\n\\text{CPI}(S_2, S_3) = C_0 + r \\cdot MR_2(S_2) \\cdot (L_{23} + MR_3(S_3) \\cdot L_{3M})\n$$\n现在，我们代入给定的未命中率幂律模型，$MR_2(S_2) = a_2/S_2$ 和 $MR_3(S_3) = a_3/S_3$：\n$$\n\\text{CPI}(S_2, S_3) = C_0 + r \\cdot \\frac{a_2}{S_2} \\left( L_{23} + \\frac{a_3}{S_3} L_{3M} \\right) = C_0 + \\frac{r a_2 L_{23}}{S_2} + \\frac{r a_2 a_3 L_{3M}}{S_2 S_3}\n$$\n为了在约束条件 $S_2 + S_3 = S_{\\text{tot}}$ 下最小化此函数，我们代入 $S_3 = S_{\\text{tot}} - S_2$。由于 $C_0$ 是一个常数，最小化 $\\text{CPI}(S_2)$ 等同于最小化停頓部分。设 $f(S_2)$ 为停頓部分。\n$$\nf(S_2) = \\frac{r a_2 L_{23}}{S_2} + \\frac{r a_2 a_3 L_{3M}}{S_2 (S_{\\text{tot}} - S_2)}\n$$\n这就是在 $S_2 \\in (0, S_{\\text{tot}})$ 区间上需要最小化的单变量函数。\n\n**3. 求解最优缓存大小 $(S_2^{\\star}, S_3^{\\star})$**\n\n为了找到 $f(S_2)$ 的最小值，我们计算它关于 $S_2$ 的导数，并令其为零。\n$$\n\\frac{df}{dS_2} = \\frac{d}{dS_2}\\left( \\frac{r a_2 L_{23}}{S_2} + \\frac{r a_2 a_3 L_{3M}}{S_2 S_{\\text{tot}} - S_2^2} \\right)\n$$\n$$\n\\frac{df}{dS_2} = -\\frac{r a_2 L_{23}}{S_2^2} + r a_2 a_3 L_{3M} \\frac{2S_2 - S_{\\text{tot}}}{(S_2 S_{\\text{tot}} - S_2^2)^2} = 0\n$$\n$$\n\\frac{r a_2 L_{23}}{S_2^2} = \\frac{r a_2 a_3 L_{3M} (2S_2 - S_{\\text{tot}})}{(S_2(S_{\\text{tot}} - S_2))^2}\n$$\n由于 $r, a_2 > 0$ 且我们在寻找 $S_2 > 0$ 的解，我们可以消去公因式 $r a_2 / S_2^2$：\n$$\nL_{23}(S_{\\text{tot}} - S_2)^2 = a_3 L_{3M}(2S_2 - S_{\\text{tot}})\n$$\n展开此式，得到一个关于 $S_2$ 的二次方程：\n$$\nL_{23}(S_{\\text{tot}}^2 - 2S_{\\text{tot}}S_2 + S_2^2) = 2 a_3 L_{3M} S_2 - a_3 L_{3M} S_{\\text{tot}}\n$$\n$$\n(L_{23})S_2^2 + (-2L_{23}S_{\\text{tot}} - 2a_3 L_{3M})S_2 + (L_{23}S_{\\text{tot}}^2 + a_3 L_{3M}S_{\\text{tot}}) = 0\n$$\n现在，代入数值：$S_{\\text{tot}} = 25$，$L_{23} = 35$，$L_{3M} = 200$，$a_3 = 0.3$。\n二次方程的系数为：\n$A = L_{23} = 35$\n$B = -2L_{23}S_{\\text{tot}} - 2a_3 L_{3M} = -2(35)(25) - 2(0.3)(200) = -1750 - 120 = -1870$\n$C = L_{23}S_{\\text{tot}}^2 + a_3 L_{3M}S_{\\text{tot}} = 35(25^2) + (0.3)(200)(25) = 21875 + 1500 = 23375$\n$S_2$ 的二次方程为：\n$$\n35 S_2^2 - 1870 S_2 + 23375 = 0\n$$\n除以 $5$：\n$$\n7 S_2^2 - 374 S_2 + 4675 = 0\n$$\n使用二次公式 $S_2 = \\frac{-B \\pm \\sqrt{B^2 - 4AC}}{2A}$：\n$$\nS_2 = \\frac{374 \\pm \\sqrt{(-374)^2 - 4(7)(4675)}}{2(7)} = \\frac{374 \\pm \\sqrt{139876 - 130900}}{14}\n$$\n$$\nS_2 = \\frac{374 \\pm \\sqrt{8976}}{14} \\approx \\frac{374 \\pm 94.74175}{14}\n$$\n这产生两个可能的 $S_2$ 解：\n$$\nS_{2,1} \\approx \\frac{374 + 94.74175}{14} \\approx 33.48 \\text{ MiB}\n$$\n$$\nS_{2,2} \\approx \\frac{374 - 94.74175}{14} \\approx 19.947 \\text{ MiB}\n$$\n解必须在物理上有意义，即 $0  S_2  S_{\\text{tot}}$。由于 $S_{\\text{tot}} = 25$ MiB，第一个解 $S_{2,1} \\approx 33.48$ MiB 是无效的。第二个解是有效的。\n函数 $f(S_2)$ 在 $S_2 \\to 0^+$ 和 $S_2 \\to S_{\\text{tot}}^-$ 时趋近于无穷大。由于在区间 $(0, S_{\\text{tot}})$ 内只有一个临界点，因此它必定对应于全局最小值。\n因此，最优的L2缓存大小是 $S_2^{\\star} \\approx 19.947$ MiB。\n\n相应的最优L3缓存大小 $S_3^{\\star}$ 是：\n$$\nS_3^{\\star} = S_{\\text{tot}} - S_2^{\\star} = 25 - 19.947 = 5.053 \\text{ MiB}\n$$\n按要求将结果四舍五入到三位有效数字：\n$$\nS_2^{\\star} \\approx 19.9 \\text{ MiB}\n$$\n$$\nS_3^{\\star} \\approx 5.05 \\text{ MiB}\n$$\n最终答案是有序对 $(S_2^{\\star}, S_3^{\\star})$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n19.9  5.05\n\\end{pmatrix}\n}\n$$", "id": "3659947"}, {"introduction": "随着单核性能提升遭遇瓶颈，摩尔定律的延续转向了增加处理器核心数量。但这是否意味着性能能够无限地线性提升？本练习探讨了这一关键问题，它将摩尔定律驱动的核心数增长与阿姆达尔定律（Amdahl's Law）对并行加速的限制结合起来。你的任务是推导出，为了使应用程序的整体加速比能够跟上摩尔定律的步伐，其代码的并行化部分需要如何随时间演进。这个思想实验揭示了在多核时代，软件和算法协同进化的至关重要性。 [@problem_id:3659950]", "problem": "一个计算平台根据摩尔定律随时间演进，而一个应用程序则通过算法重构来增加其可利用的并行性。假设如下：\n\n- 芯片上的总晶体管数量 $N(t)$ 在每个固定的技术周期 $T$ 内翻倍，因此对于时间 $t \\ge 0$，有 $N(t) = N_0 \\cdot 2^{t/T}$。\n- 核心数量 $p(t)$ 与晶体管数量成线性关系（每个核心面积恒定且开销固定），其中 $p(0)=p_0 \\ge 1$ 且 $p(t) \\propto N(t)$，因此 $p(t) = p_0 \\cdot 2^{t/T}$。\n- 对于一个固定大小的工作负载和应用程序的并行部分比例 $f(t)$（其余部分为串行），在 $p$ 个相同核心上可实现的加速比（相对于具有相同单核性能的单核基准）由 Amdahl 定律决定：$S(p) = \\dfrac{1}{1 - f + \\dfrac{f}{p}}$。\n- 假设每个核心的性能不随 $t$ 变化；只有 $p(t)$ 如上所述变化。\n\n假设管理层要求，在时间 $t$ 时应用程序相对于其 $t=0$ 基准的端到端观测加速比必须“追随摩尔定律”，即在所有 $t \\ge 0$ 的情况下，总加速比必须等于 $2^{t/T}$。在上述假设下，确定在 $p(t)$ 个核心上运行时实现此目标所需的并行部分比例 $f(t)$（作为 $t$、$T$ 和 $p_0$ 的闭式函数）。请以单个简化的解析表达式形式给出 $f(t)$ 的最终答案。不需要进行数值计算，也不需要进行四舍五入。", "solution": "我们从两个被广泛接受并经过独立验证的基础出发：\n\n- Moore 的经验观察，即晶体管数量在每个固定周期 $T$ 内翻倍，我们将其建模为 $N(t) = N_0 \\cdot 2^{t/T}$。\n- Amdahl 定律，描述了具有并行部分比例 $f$ 的固定大小工作负载在 $p$ 个相同核心上的强扩展性，即 $S(p) = \\dfrac{1}{1 - f + \\dfrac{f}{p}}$，假设除了串行部分外，其他开销可忽略不计。\n\n根据假设，核心数量与晶体管数量成正比，比例常数的选择满足初始条件 $p(0)=p_0$。因为 $N(t)/N(0) = 2^{t/T}$，我们有\n$$\np(t) \\;=\\; p_0 \\cdot \\frac{N(t)}{N(0)} \\;=\\; p_0 \\cdot 2^{t/T}.\n$$\n管理层的要求是，作为时间 $t$ 函数的实现加速比必须等于摩尔定律的翻倍轨迹，\n$$\nS\\bigl(p(t)\\bigr) \\;=\\; 2^{t/T}.\n$$\n使用 Amdahl 定律，代入随时间变化的并行部分比例 $f(t)$ 和 $p(t)$ 个核心，我们写出\n$$\nS\\bigl(p(t)\\bigr) \\;=\\; \\frac{1}{\\,1 - f(t) + \\dfrac{f(t)}{p(t)}\\,}.\n$$\n将其与目标轨迹相等，并求解 $f(t)$，得到\n$$\n\\frac{1}{\\,1 - f(t) + \\dfrac{f(t)}{p(t)}\\,} \\;=\\; 2^{t/T}.\n$$\n两边取倒数：\n$$\n1 - f(t) + \\frac{f(t)}{p(t)} \\;=\\; 2^{-t/T}.\n$$\n合并包含 $f(t)$ 的项：\n$$\n1 - f(t)\\!\\left(1 - \\frac{1}{p(t)}\\right) \\;=\\; 2^{-t/T}.\n$$\n整理以分离出 $f(t)$：\n$$\nf(t)\\!\\left(1 - \\frac{1}{p(t)}\\right) \\;=\\; 1 - 2^{-t/T}.\n$$\n因此，\n$$\nf(t) \\;=\\; \\frac{\\,1 - 2^{-t/T}\\,}{\\,1 - \\dfrac{1}{p(t)}\\,}.\n$$\n代入 $p(t) = p_0 \\cdot 2^{t/T}$：\n$$\nf(t) \\;=\\; \\frac{\\,1 - 2^{-t/T}\\,}{\\,1 - \\dfrac{1}{p_0 2^{t/T}}\\,}.\n$$\n\n这个表达式已经简化，并给出了所需的并行部分比例作为 $t$、$T$ 和 $p_0$ 的函数。它也具有合理的极限：在 $t=0$ 时，分子和分母分别简化为 $0$ 和 $1 - \\dfrac{1}{p_0}$，得出 $f(0)=0$，这与基准时 $S=1$ 相符。当 $t \\to \\infty$ 时，$2^{-t/T} \\to 0$，所以 $f(t) \\to 1$，这表明为了仅通过增加核心数量的并行化来继续匹配摩尔定律的轨迹，应用程序必须渐近地接近完全并行的行为。", "answer": "$$\\boxed{\\frac{1 - 2^{-t/T}}{1 - \\frac{1}{p_0 2^{t/T}}}}$$", "id": "3659950"}]}