{"hands_on_practices": [{"introduction": "CPU性能不仅取决于时钟速度，还深刻地受到所执行指令组合的影响。此练习模拟了一个常见的编译器优化场景，其中高成本的除法指令被替换为成本较低的乘法指令，但代价是总指令数略有增加。通过这个练习[@problem_id:3631100]，你将亲手计算这种权衡如何影响最终的执行时间，从而深入理解指令数（$IC$）和每指令周期数（$CPI$）之间的相互作用。", "problem": "一个程序运行在单核中央处理器 (CPU) 上，由于微架构延迟，其流水线对不同指令类别的周期数也不同。在任何转换之前，动态指令混合如下：算术除法指令占已执行指令的 $5\\%$，每条需要 $12$ 个周期；算术乘法指令占已执行指令的 $10\\%$，每条需要 $4$ 个周期；加、减和逻辑指令占已执行指令的 $35\\%$，每条需要 $1$ 个周期；加载和存储指令占已执行指令的 $35\\%$，每条需要 $2$ 个周期；控制转移（分支）指令占已执行指令的 $15\\%$，每条需要 $3$ 个周期。一种保持语义的代码转换将每个算术除法操作替换为通过预计算的倒数进行的等效乘法，从而将那 $5\\%$ 的指令的周期数从 $12$ 个周期变为 $4$ 个周期。该转换还以额外加法指令的形式引入了额外的簿记工作，这些指令数量等于原始指令数的 $2\\%$，每条耗费 $1$ 个周期。假设时钟频率保持不变，并且转换不会改变周期时间。\n\n仅使用执行周期和时间的基本定义，确定总执行时间的净变化，以乘法因子 $T_{\\text{new}}/T_{\\text{old}}$ 的形式表示。将答案四舍五入到四位有效数字。由于所求量为无量纲量，因此不需要单位。", "solution": "我们使用的基本定义是：(1) 总执行时间 $T$ 等于总时钟周期数与时钟周期时间的乘积，以及 (2) 总时钟周期数等于对所有已执行指令的每条指令所用周期数求和。等价地，如果 $IC$ 表示动态指令总数 (IC)，$\\overline{CPI}$ 表示每条指令的平均周期数 (CPI)，那么总周期数等于 $IC \\times \\overline{CPI}$，并且 $T = IC \\times \\overline{CPI} \\times t_{c}$，其中 $t_{c}$ 是周期时间。当在相同的 $t_{c}$ 下比较两个版本时，执行时间的比率等于总周期数的比率。\n\n设原始指令数为 $N$。原始的各类别指令计数如下：\n- 除法指令：$0.05N$，每条耗费 $12$ 个周期，贡献 $0.05N \\times 12 = 0.60N$ 个周期，\n- 乘法指令：$0.10N$，每条耗费 $4$ 个周期，贡献 $0.10N \\times 4 = 0.40N$ 个周期，\n- 加法/逻辑指令：$0.35N$，每条耗费 $1$ 个周期，贡献 $0.35N \\times 1 = 0.35N$ 个周期，\n- 内存（加载/存储）指令：$0.35N$，每条耗费 $2$ 个周期，贡献 $0.35N \\times 2 = 0.70N$ 个周期，\n- 分支指令：$0.15N$，每条耗费 $3$ 个周期，贡献 $0.15N \\times 3 = 0.45N$ 个周期。\n\n因此，原始的总周期数为\n$$\n\\text{cycles}_{\\text{old}} = (0.60 + 0.40 + 0.35 + 0.70 + 0.45)N = 2.50N,\n$$\n所以原始的平均 $CPI$ 为\n$$\n\\overline{CPI}_{\\text{old}} = \\frac{\\text{cycles}_{\\text{old}}}{N} = 2.50.\n$$\n\n转换后，所有除法指令都被替换为耗费 $4$ 个周期的乘法指令，因此除法指令的贡献为 $0$，乘法指令数增加 $0.05N$ 达到 $0.15N$；这些指令贡献了 $0.15N \\times 4 = 0.60N$ 个周期。该转换还增加了 $0.02N$ 条额外的加法指令，每条耗费 $1$ 个周期，使得加法/逻辑指令从 $0.35N$ 增加到 $0.37N$，贡献了 $0.37N \\times 1 = 0.37N$ 个周期。内存和分支指令数保持为 $0.35N$ 和 $0.15N$，分别贡献了 $0.35N \\times 2 = 0.70N$ 和 $0.15N \\times 3 = 0.45N$ 个周期。因此，新的总周期数为\n$$\n\\text{cycles}_{\\text{new}} = (0.60 + 0.37 + 0.70 + 0.45)N = 2.12N.\n$$\n\n新的指令数为 $N_{\\text{new}} = 1.02N$，所以新的平均 $CPI$ 为\n$$\n\\overline{CPI}_{\\text{new}} = \\frac{\\text{cycles}_{\\text{new}}}{N_{\\text{new}}} = \\frac{2.12N}{1.02N} = \\frac{2.12}{1.02}.\n$$\n\n执行时间的净变化，以乘法因子表示，为\n$$\n\\frac{T_{\\text{new}}}{T_{\\text{old}}} = \\frac{\\text{cycles}_{\\text{new}}}{\\text{cycles}_{\\text{old}}} = \\frac{2.12N}{2.50N} = \\frac{2.12}{2.50} = 0.848.\n$$\n\n四舍五入到四位有效数字得出 $0.8480$。", "answer": "$$\\boxed{0.8480}$$", "id": "3631100"}, {"introduction": "现代CPU通过向量化（或SIMD）等架构特性来加速特定类型的计算。此练习探讨了将一部分标量指令转换为向量指令所带来的性能变化。虽然向量指令本身可能需要更多的周期来执行，但它们能够一次性处理多个数据元素，从而显著减少所需执行的指令总数。[@problem_id:3631193]将帮助你量化这种性能提升，并理解指令集架构对程序执行效率的直接影响。", "problem": "一个单发射标量中央处理器 (CPU) 执行一个程序，其总指令数为 $IC_{0}$，平均每条指令周期数 (CPI) 为 $\\mathrm{CPI}_{0} = 1$。在所有实验中，时钟频率 $f$ 保持不变。该程序由两个不相交的类别组成：一个可向量化的类别，占原始指令的 $0.4$；以及一个不可向量化的剩余部分，占 $0.6$。一种提议的向量化方法对可向量化类别中的每条指令进行转换，使得一条向量指令能够完成 $4$ 条标量指令的工作，从而将该类别的指令数减少为原来的 $1/4$。由于微架构的开销，转换后类别的向量指令的平均 CPI 变为 $2$。不可向量化的类别保持不变。\n\n仅使用时钟周期和执行时间的第一性原理定义，确定比率 $T_{1}/T_{0}$，其中 $T_{0}$ 是原始执行时间，$T_{1}$ 是向量化后的执行时间。将最终答案表示为小数。无需进行四舍五入。", "solution": "CPU 执行时间 $T$ 的基本关系由下式给出：\n$$T = IC \\times \\mathrm{CPI} \\times t_c$$\n其中 $IC$ 是指令数，$\\mathrm{CPI}$ 是平均每条指令周期数，$t_c$ 是时钟周期时间。时钟周期时间是时钟频率 $f$ 的倒数，因此 $t_c = 1/f$。所以，执行时间也可以表示为：\n$$T = \\frac{IC \\times \\mathrm{CPI}}{f}$$\n执行一个程序所需的总时钟周期数 $C$ 为 $C = IC \\times \\mathrm{CPI}$。因此，$T = C/f$。\n\n问题要求计算比率 $T_{1}/T_{0}$，其中 $T_{0}$ 是原始执行时间，$T_{1}$ 是向量化后的执行时间。\n$$T_{0} = \\frac{C_{0}}{f}$$\n$$T_{1} = \\frac{C_{1}}{f}$$\n由于时钟频率 $f$ 保持不变，执行时间的比率等于总时钟周期的比率：\n$$\\frac{T_{1}}{T_{0}} = \\frac{C_{1}/f}{C_{0}/f} = \\frac{C_{1}}{C_{0}}$$\n\n首先，我们确定原始程序 $C_{0}$ 的总周期数。\n给定初始总指令数 $IC_{0}$ 和平均每条指令周期数 $\\mathrm{CPI}_{0} = 1$：\n$$C_{0} = IC_{0} \\times \\mathrm{CPI}_{0} = IC_{0} \\times 1 = IC_{0}$$\n\n接下来，我们确定向量化程序 $C_{1}$ 的总周期数。我们计算两个不相交的指令类别（不可向量化和可向量化）的周期数并将它们相加。\n\n原始程序的指令划分如下：\n- 不可向量化指令：$IC_{\\mathrm{non-vec},0} = 0.6 \\times IC_{0}$\n- 可向量化指令：$IC_{\\mathrm{vec},0} = 0.4 \\times IC_{0}$\n\n问题陈述意味着，对于平均 $\\mathrm{CPI}_{0}=1$ 的基准标量处理器，可以合理地假设所有指令类别的 CPI 均为 $1$。因此，一条指令对总周期数的贡献是 $1$ 个周期。原始程序中每个部分的周期数是：\n- 不可向量化部分的周期数（原始）：$C_{\\mathrm{non-vec},0} = IC_{\\mathrm{non-vec},0} \\times 1 = 0.6 \\times IC_{0}$\n- 可向量化部分的周期数（原始）：$C_{\\mathrm{vec},0} = IC_{\\mathrm{vec},0} \\times 1 = 0.4 \\times IC_{0}$\n- 原始总周期数：$C_{0} = C_{\\mathrm{non-vec},0} + C_{\\mathrm{vec},0} = 0.6 \\times IC_{0} + 0.4 \\times IC_{0} = IC_{0}$。这与我们之前的计算一致。\n\n现在我们分析向量化后的状态。\n不可向量化的类别保持不变。这意味着其指令数和 CPI 相同。因此，它对新程序总周期数的贡献保持不变：\n$$C_{\\mathrm{non-vec},1} = C_{\\mathrm{non-vec},0} = 0.6 \\times IC_{0}$$\n\n对于可向量化类别，指令数减少为原来的 $1/4$。该类别的新指令数 $IC_{\\mathrm{vec},1}$ 为：\n$$IC_{\\mathrm{vec},1} = \\frac{IC_{\\mathrm{vec},0}}{4} = \\frac{0.4 \\times IC_{0}}{4} = 0.1 \\times IC_{0}$$\n这些新向量指令的平均 CPI 被给定为 $\\mathrm{CPI}_{\\mathrm{vec},1} = 2$。\n这个转换后类别的周期数是：\n$$C_{\\mathrm{vec},1} = IC_{\\mathrm{vec},1} \\times \\mathrm{CPI}_{\\mathrm{vec},1} = (0.1 \\times IC_{0}) \\times 2 = 0.2 \\times IC_{0}$$\n\n新程序 $C_{1}$ 的总周期数是这两个类别周期数的总和：\n$$C_{1} = C_{\\mathrm{non-vec},1} + C_{\\mathrm{vec},1} = (0.6 \\times IC_{0}) + (0.2 \\times IC_{0}) = 0.8 \\times IC_{0}$$\n\n最后，我们通过计算 $C_{1}/C_{0}$ 来计算比率 $T_{1}/T_{0}$：\n$$\\frac{T_{1}}{T_{0}} = \\frac{C_{1}}{C_{0}} = \\frac{0.8 \\times IC_{0}}{IC_{0}} = 0.8$$\n新的执行时间与原始执行时间的比率为 $0.8$。", "answer": "$$\\boxed{0.8}$$", "id": "3631193"}, {"introduction": "CPU的性能并非孤立存在，它与内存系统紧密相连，缓存和地址转换的效率对总执行时间有巨大影响。本练习将CPU性能公式应用于一个真实的Web服务器场景，分析启用HTTP持久连接（keep-alive）如何通过改善缓存和TLB的命中率来减少请求处理延迟。通过解决[@problem_id:3631109]，你将能够把$CPI$分解为基础部分和由内存系统停顿引起的部分，从而揭示系统级优化对性能的关键作用。", "problem": "一个 Web 服务器运行在一台中央处理器 (CPU) 上，其时钟频率为 $f = 3.2 \\times 10^{9}\\ \\mathrm{cycles/s}$。对于单个 HTTP 请求的应用逻辑，动态指令数为 $IC = 2.5 \\times 10^{6}$ 条指令。基础每指令周期数（在所有内存层级都命中的情况下）为 $\\mathrm{CPI}_{\\mathrm{base}} = 0.8$。内存停顿来自指令缓存 (I-cache)、数据缓存 (D-cache) 以及用于指令获取 (iTLB) 和数据访问 (dTLB) 的转译旁观缓冲器 (TLB)。假设如下：\n- 每条指令从 I-cache 获取一条指令。\n- 每条指令的平均数据内存引用次数为 $m_{d} = 0.35$。\n- 缺失代价（以周期为单位）为：I-cache $= 30$，D-cache $= 40$，TLB（iTLB 和 dTLB）$= 100$。\n- 在冷连接（无重用）下，缺失率分别为：每条指令的 I-cache 缺失率 $r_{I,\\mathrm{cold}} = 0.004$，每次数据引用的 D-cache 缺失率 $r_{D,\\mathrm{cold}} = 0.02$，每条指令的 iTLB 缺失率 $r_{i,\\mathrm{cold}} = 0.0002$，每次数据引用的 dTLB 缺失率 $r_{d,\\mathrm{cold}} = 0.0005$。\n- 在热状态（有重用）下，缺失率分别为：每条指令的 I-cache 缺失率 $r_{I,\\mathrm{warm}} = 0.0005$，每次数据引用的 D-cache 缺失率 $r_{D,\\mathrm{warm}} = 0.003$，每条指令的 iTLB 缺失率 $r_{i,\\mathrm{warm}} = 0.00005$，每次数据引用的 dTLB 缺失率 $r_{d,\\mathrm{warm}} = 0.0001$。\n\n最初，服务器不使用 HTTP 持久连接 (keep-alive)，因此每个请求都经历冷行为。然后，服务器启用了 keep-alive，每个连接平均携带 $k = 8$ 个请求：每个连接的第一个请求是冷的，后续每个请求是热的。假设来自 I-cache、D-cache、iTLB 和 dTLB 的停顿代价是累加的且没有重叠，$\\mathrm{CPI}_{\\mathrm{base}}$ 和各项代价不发生改变，并且 keep-alive 不会改变每个请求的指令数 $IC$。\n\n仅使用周期、时间和平均每指令周期数的核心定义，计算每个请求的 CPU 执行时间的平均减少量，定义为\n$$\\Delta T = T_{\\mathrm{no\\ KA}} - T_{\\mathrm{with\\ KA}},$$\n其中 $T_{\\mathrm{no\\ KA}}$ 是每个请求都是冷请求时，单个请求的 CPU 时间，而 $T_{\\mathrm{with\\ KA}}$ 是在每个连接有一个冷请求和 $k-1$ 个热请求的情况下，单个请求的平均 CPU 时间。请以微秒表示你的最终答案，并四舍五入到四位有效数字。", "solution": "该问题要求计算启用 HTTP 持久连接 (keep-alive) 后，每个请求的 CPU 执行时间的平均减少量。决定 CPU 执行时间的基本关系由 CPU 性能方程给出：\n$$T_{CPU} = \\frac{N_{cycles}}{f}$$\n其中 $T_{CPU}$ 是以秒为单位的执行时间，$N_{cycles}$ 是 CPU 总周期数，$f$ 是以周期/秒为单位的时钟频率。总周期数可以表示为指令数 ($IC$) 与平均每指令周期数 ($\\mathrm{CPI}$) 的乘积：\n$$N_{cycles} = IC \\times \\mathrm{CPI}$$\n结合这两个公式，单个请求的执行时间为：\n$$T = \\frac{IC \\times \\mathrm{CPI}}{f}$$\n总 $\\mathrm{CPI}$ 是基础 $\\mathrm{CPI}$（假设没有内存停顿）与由各种停顿源贡献的额外 $\\mathrm{CPI}$ 之和。问题陈述，来自 I-cache、D-cache、iTLB 和 dTLB 的停顿是累加的。\n$$\\mathrm{CPI}_{total} = \\mathrm{CPI}_{\\mathrm{base}} + \\mathrm{CPI}_{\\mathrm{stalls}}$$\n$$\\mathrm{CPI}_{\\mathrm{stalls}} = \\mathrm{CPI}_{I} + \\mathrm{CPI}_{D} + \\mathrm{CPI}_{iTLB} + \\mathrm{CPI}_{dTLB}$$\n每个组件的停顿 CPI 是每条指令的该类型内存访问次数、该访问类型的缺失率以及相应的缺失代价（以周期为单位）的乘积。\n\n1.  **指令缓存 (I-cache) 每指令停顿**：每条指令需要一次获取。\n    $$\\mathrm{CPI}_{I} = (\\text{每指令缺失数}) \\times (\\text{缺失代价}) = r_{I} \\times P_{I}$$\n2.  **数据缓存 (D-cache) 每指令停顿**：每条指令有 $m_d$ 次数据引用。\n    $$\\mathrm{CPI}_{D} = (\\text{每指令数据引用数}) \\times (\\text{每次引用的缺失率}) \\times (\\text{缺失代价}) = m_{d} \\times r_{D} \\times P_{D}$$\n3.  **指令 TLB (iTLB) 每指令停顿**：每次指令获取都是一次需要翻译的内存访问。\n    $$\\mathrm{CPI}_{iTLB} = (\\text{每指令指令获取数}) \\times (\\text{每次获取的缺失率}) \\times (\\text{缺失代价}) = 1 \\times r_{i} \\times P_{T} = r_{i} \\times P_{T}$$\n4.  **数据 TLB (dTLB) 每指令停顿**：每次数据引用都是一次需要翻译的内存访问。\n    $$\\mathrm{CPI}_{dTLB} = (\\text{每指令数据引用数}) \\times (\\text{每次引用的缺失率}) \\times (\\text{缺失代价}) = m_{d} \\times r_{d} \\times P_{T}$$\n\n综合这些，总 $\\mathrm{CPI}$ 的一般表达式为：\n$$\\mathrm{CPI} = \\mathrm{CPI}_{\\mathrm{base}} + r_{I}P_{I} + m_{d}r_{D}P_{D} + r_{i}P_{T} + m_{d}r_{d}P_{T}$$\n\n我们给定的参数如下：\n- $\\mathrm{CPI}_{\\mathrm{base}} = 0.8$\n- $m_{d} = 0.35$\n- $P_{I} = 30$ 周期\n- $P_{D} = 40$ 周期\n- $P_{T} = 100$ 周期\n\n首先，我们使用冷缺失率计算一个冷请求的 $\\mathrm{CPI}$，即 $\\mathrm{CPI}_{\\mathrm{cold}}$：\n$r_{I,\\mathrm{cold}} = 0.004$, $r_{D,\\mathrm{cold}} = 0.02$, $r_{i,\\mathrm{cold}} = 0.0002$, $r_{d,\\mathrm{cold}} = 0.0005$。\n$$\\mathrm{CPI}_{\\mathrm{cold}} = 0.8 + (0.004)(30) + (0.35)(0.02)(40) + (0.0002)(100) + (0.35)(0.0005)(100)$$\n$$\\mathrm{CPI}_{\\mathrm{cold}} = 0.8 + 0.12 + 0.28 + 0.02 + 0.0175 = 1.2375$$\n\n接下来，我们使用热缺失率计算一个热请求的 $\\mathrm{CPI}$，即 $\\mathrm{CPI}_{\\mathrm{warm}}$：\n$r_{I,\\mathrm{warm}} = 0.0005$, $r_{D,\\mathrm{warm}} = 0.003$, $r_{i,\\mathrm{warm}} = 0.00005$, $r_{d,\\mathrm{warm}} = 0.0001$。\n$$\\mathrm{CPI}_{\\mathrm{warm}} = 0.8 + (0.0005)(30) + (0.35)(0.003)(40) + (0.00005)(100) + (0.35)(0.0001)(100)$$\n$$\\mathrm{CPI}_{\\mathrm{warm}} = 0.8 + 0.015 + 0.042 + 0.005 + 0.0035 = 0.8655$$\n\n现在我们可以确定两种情况下的执行时间。\n**情况 1：无 Keep-Alive ($T_{\\mathrm{no\\ KA}}$)**\n在这种情况下，每个请求都是冷请求。每个请求的 CPU 时间为：\n$$T_{\\mathrm{no\\ KA}} = \\frac{IC \\times \\mathrm{CPI}_{\\mathrm{cold}}}{f}$$\n\n**情况 2：有 Keep-Alive ($T_{\\mathrm{with\\ KA}}$)**\n在这种情况下，一个连接由 $k=8$ 个请求组成：一个冷请求和 $k-1=7$ 个热请求。一个连接的总周期数为：\n$$N_{cycles, conn} = (IC \\times \\mathrm{CPI}_{\\mathrm{cold}}) \\times 1 + (IC \\times \\mathrm{CPI}_{\\mathrm{warm}}) \\times (k-1)$$\n每个请求的平均 CPU 时间 $T_{\\mathrm{with\\ KA}}$ 是连接的总时间除以请求数 $k$：\n$$T_{\\mathrm{with\\ KA}} = \\frac{N_{cycles, conn}}{k \\times f} = \\frac{IC \\times (\\mathrm{CPI}_{\\mathrm{cold}} + (k-1)\\mathrm{CPI}_{\\mathrm{warm}})}{k \\times f}$$\n\n问题要求计算每个请求的 CPU 执行时间的平均减少量 $\\Delta T$：\n$$\\Delta T = T_{\\mathrm{no\\ KA}} - T_{\\mathrm{with\\ KA}}$$\n代入时间的表达式：\n$$\\Delta T = \\frac{IC \\times \\mathrm{CPI}_{\\mathrm{cold}}}{f} - \\frac{IC \\times (\\mathrm{CPI}_{\\mathrm{cold}} + (k-1)\\mathrm{CPI}_{\\mathrm{warm}})}{k \\times f}$$\n我们可以提出公因式 $\\frac{IC}{f}$：\n$$\\Delta T = \\frac{IC}{f} \\left( \\mathrm{CPI}_{\\mathrm{cold}} - \\frac{\\mathrm{CPI}_{\\mathrm{cold}} + (k-1)\\mathrm{CPI}_{\\mathrm{warm}}}{k} \\right)$$\n将括号内的项通分母 $k$：\n$$\\Delta T = \\frac{IC}{f} \\left( \\frac{k\\mathrm{CPI}_{\\mathrm{cold}} - (\\mathrm{CPI}_{\\mathrm{cold}} + (k-1)\\mathrm{CPI}_{\\mathrm{warm}})}{k} \\right)$$\n$$\\Delta T = \\frac{IC}{f} \\left( \\frac{(k-1)\\mathrm{CPI}_{\\mathrm{cold}} - (k-1)\\mathrm{CPI}_{\\mathrm{warm}}}{k} \\right)$$\n化简为：\n$$\\Delta T = \\frac{IC \\times (k-1)}{f \\times k} \\left(\\mathrm{CPI}_{\\mathrm{cold}} - \\mathrm{CPI}_{\\mathrm{warm}}\\right)$$\n这个表达式代表了在 $k-1$ 个热请求中节省的总时间，分摊到连接中的所有 $k$ 个请求上。\n\n现在，我们将已知值代入这个最终表达式：\n$IC = 2.5 \\times 10^{6}$\n$f = 3.2 \\times 10^{9}$\n$k = 8$\n$\\mathrm{CPI}_{\\mathrm{cold}} = 1.2375$\n$\\mathrm{CPI}_{\\mathrm{warm}} = 0.8655$\n$$\\Delta T = \\frac{(2.5 \\times 10^{6}) \\times (8-1)}{(3.2 \\times 10^{9}) \\times 8} \\left(1.2375 - 0.8655\\right)$$\n$$\\Delta T = \\frac{2.5 \\times 10^{6} \\times 7}{25.6 \\times 10^{9}} \\left(0.372\\right)$$\n$$\\Delta T = \\frac{17.5 \\times 10^{6}}{25.6 \\times 10^{9}} \\times 0.372$$\n$$\\Delta T \\approx (0.68359375 \\times 10^{-3}) \\times 0.372$$\n$$\\Delta T \\approx 0.000254296875 \\text{ s}$$\n问题要求答案以微秒 ($\\mu\\mathrm{s}$) 为单位，其中 $1 \\text{ s} = 10^{6} \\mu\\mathrm{s}$。\n$$\\Delta T \\approx 0.000254296875 \\times 10^{6} \\mu\\mathrm{s} = 254.296875 \\mu\\mathrm{s}$$\n四舍五入到四位有效数字，我们得到：\n$$\\Delta T \\approx 254.3 \\mu\\mathrm{s}$$", "answer": "$$\n\\boxed{254.3}\n$$", "id": "3631109"}]}