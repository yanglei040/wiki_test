{"hands_on_practices": [{"introduction": "掌握任何数字系统的第一步都是熟练进行其二进制表示与十进制值之间的转换。本练习 [@problem_id:3662341] 提供了对反码（one's complement）进行编码和解码的综合实践，旨在帮助你巩固其基本规则。通过处理包括正数、负数以及独特的正零 ($+0$) 和负零 ($-0$) 在内的各种情况，你将加深对反码表示法核心特征的理解。", "problem": "一个数字系统使用反码表示法来表示有符号的 $n$ 位整数。在反码表示法中，正值在其最高有效位（MSB）处用一个前导零进行编码，而负值则通过对其绝对值的正数编码进行按位取反来编码。零有两种不同的编码，记为 $+0$ 和 $-0$。考虑以下两个任务，它们要求在两种不同的字长下，在十进制和反码表示之间进行转换。\n\n任务 A（$n=5$ 位的编码）：将十进制值 $+7$、$-7$、$+0$ 和 $-0$ 编码为 $5$ 位反码。对于每个得到的 $5$ 位字，将其位解释为无符号二进制数，以得到一个整数 $U$。设这四个无符号整数分别为 $U_{+7}$、 $U_{-7}$、 $U_{+0}$ 和 $U_{-0}$。\n\n任务 B（$n=6$ 位的解码）：将以下 $6$ 位反码字解码为有符号十进制值：$101101$、$010010$、$111111$ 和 $000000$。设解码后的十进制值分别为 $D_{101101}$、$D_{010010}$、$D_{111111}$ 和 $D_{000000}$。\n\n仅使用反码表示法的基础定义，不使用任何记忆中的快捷公式，计算以下量：\n$$\nS = \\left(U_{+7} + U_{-7} + U_{+0} + U_{-0}\\right) + \\left(D_{101101} + D_{010010} + D_{111111} + D_{000000}\\right).\n$$\n将 $S$ 以单个整数的形式给出。无需四舍五入。", "solution": "问题要求计算一个总和 $S$，该总和通过两个涉及反码表示法的任务得出：一个针对 $5$ 位系统的编码任务和一个针对 $6$ 位系统的解码任务。\n\n问题陈述已经过验证，被认为是有效的。它在科学上是合理的，提法明确，且客观。所有必要的定义和数据均已提供。我们开始解答。\n\n解答的结构是首先完成任务 A，然后完成任务 B，最后计算总和 $S$。\n\n### 任务 A：$n=5$ 位的编码\n\n我们需要将十进制值 $+7$、$-7$、$+0$ 和 $-0$ 编码为 $5$ 位反码，然后将这些二进制字解释为无符号整数。\n\n1.  **编码 $+7$**：\n    该数为正数，所以其最高有效位（MSB）必须是 $0$。其绝对值为 $7$，二进制表示为 $111_2$。要在 $5$ 位系统中表示 $+7$，我们需要用前导零填充其绝对值的二进制表示，使其总长度达到 $5$ 位。\n    $$ +7_{10} \\rightarrow 00111_2 $$\n    将 $00111_2$ 解释为无符号整数，得到 $U_{+7}$。\n    $$ U_{+7} = 0 \\cdot 2^4 + 0 \\cdot 2^3 + 1 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0 = 0 + 0 + 4 + 2 + 1 = 7 $$\n\n2.  **编码 $-7$**：\n    负数的反码表示是其正数绝对值表示的按位取反。我们对 $+7$ 的二进制字进行取反操作。\n    $$ \\text{NOT}(00111_2) = 11000_2 $$\n    因此，$-7_{10}$ 被编码为 $11000_2$。将其解释为无符号整数，得到 $U_{-7}$。\n    $$ U_{-7} = 1 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 0 \\cdot 2^1 + 0 \\cdot 2^0 = 16 + 8 + 0 + 0 + 0 = 24 $$\n\n3.  **编码 $+0$**：\n    正零（$+0$）的表示是一个全为零的比特串。\n    $$ +0_{10} \\rightarrow 00000_2 $$\n    将 $00000_2$ 解释为无符号整数，得到 $U_{+0}$。\n    $$ U_{+0} = 0 $$\n\n4.  **编码 $-0$**：\n    负零（$-0$）的表示是 $+0$ 表示的按位取反。\n    $$ \\text{NOT}(00000_2) = 11111_2 $$\n    将 $11111_2$ 解释为无符号整数，得到 $U_{-0}$。\n    $$ U_{-0} = 1 \\cdot 2^4 + 1 \\cdot 2^3 + 1 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0 = 16 + 8 + 4 + 2 + 1 = 31 $$\n\n任务 A 的总和是：\n$$ U_{+7} + U_{-7} + U_{+0} + U_{-0} = 7 + 24 + 0 + 31 = 62 $$\n可以观察到，对于任何值 $x$，其无符号解释 $U_x$ 与其反码负数 $U_{-x}$ 的无符号解释之和为 $2^n-1$。这里，$n=5$，所以 $2^5-1=31$。确实，$U_{+7} + U_{-7} = 7 + 24 = 31$ 并且 $U_{+0} + U_{-0} = 0 + 31 = 31$。总和是 $31 + 31 = 62$。\n\n### 任务 B：$n=6$ 位的解码\n\n我们需要将四个 $6$ 位反码字解码为有符号十进制值。\n\n1.  **解码 $101101_2$**：\n    MSB 为 $1$，所以这是一个负数。为了求其绝对值，我们进行按位取反。\n    $$ \\text{NOT}(101101_2) = 010010_2 $$\n    其绝对值是这个取反后的二进制字的十进制值。\n    $$ 010010_2 = 1 \\cdot 2^4 + 0 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 0 \\cdot 2^0 = 16 + 2 = 18 $$\n    因为这个数是负数，所以其值为 $-18$。\n    $$ D_{101101} = -18 $$\n\n2.  **解码 $010010_2$**：\n    MSB 为 $0$，所以这是一个正数。其值就是该二进制字的直接解释。\n    $$ 010010_2 = 1 \\cdot 2^4 + 1 \\cdot 2^1 = 16 + 2 = 18 $$\n    其值为 $+18$。\n    $$ D_{010010} = 18 $$\n\n3.  **解码 $111111_2$**：\n    MSB 为 $1$，所以这是一个负数。这个全为一的特定模式代表负零（$-0$）。为了确认，我们进行按位取反。\n    $$ \\text{NOT}(111111_2) = 000000_2 $$\n    绝对值为 $0$。因此，其值为 $0$。\n    $$ D_{111111} = 0 $$\n\n4.  **解码 $000000_2$**：\n    MSB 为 $0$。这个全为零的模式代表正零（$+0$）。其值为 $0$。\n    $$ D_{000000} = 0 $$\n\n任务 B 的总和是：\n$$ D_{101101} + D_{010010} + D_{111111} + D_{000000} = -18 + 18 + 0 + 0 = 0 $$\n\n### 最终计算\n\n总和 $S$ 是任务 A 和任务 B 结果之和。\n$$ S = \\left(U_{+7} + U_{-7} + U_{+0} + U_{-0}\\right) + \\left(D_{101101} + D_{010010} + D_{111111} + D_{000000}\\right) $$\n代入计算出的值：\n$$ S = (62) + (0) = 62 $$\n最终结果是 $62$。", "answer": "$$\\boxed{62}$$", "id": "3662341"}, {"introduction": "在掌握了基本的转换规则后，我们可以进一步探索如何在反码系统上实现算法。本练习 [@problem_id:3662312] 要求你为一项基本运算——求绝对值——设计并验证一个正确的算法。这需要你从第一性原理出发，严谨地分析所有可能输入，特别是负数和特殊的负零 ($-0$) 表示，从而锻炼你将理论知识应用于算法设计的能力。", "problem": "考虑一个 $n$ 位的反码（one's complement）表示法，其中 $n \\geq 2$。在该系统中，每个位向量 $x \\in \\{0,1\\}^{n}$ 都有一个最高有效位（Most Significant Bit, MSB），记为 $x_{n-1}$，并且数学值 $0$ 存在两种编码：全零向量 $0^{n}$（记为 $+0$）和全一向量 $1^{n}$（记为 $-0$）。对于任意位向量 $x$，令 $\\overline{x}$ 表示其按位取反，并令 $m(x) \\triangleq \\sum_{i=0}^{n-1} x_{i} 2^{i}$ 表示其无符号大小。反码中的数学值映射定义如下：如果 $x_{n-1} = 0$，则 $\\mathrm{val}(x) = m(x)$；如果 $x_{n-1} = 1$ 且 $x \\neq 1^{n}$，则 $\\mathrm{val}(x) = - m(\\overline{x})$；如果 $x = 1^{n}$，则 $\\mathrm{val}(x) = 0$。对于任何满足 $0 \\le y \\le 2^{n-1}-1$ 的整数 $y$，定义规范非负编码器 $\\mathrm{enc}(y)$ 为 MSB 为 $0$ 且无符号大小等于 $y$ 的唯一 $n$ 位向量，因此，特别地，$\\mathrm{enc}(0) = 0^{n}$。绝对值函数必须产生 $|\\mathrm{val}(x)|$ 的规范非负编码。\n\n给出了三种在 $n$ 位反码输入上实现绝对值的候选方案：\n1. $f_{0}(x)$ 将 MSB 清零并保持所有其他位不变，即 $f_{0}(x)$ 是一个位向量，其位满足 $(f_{0}(x))_{n-1} = 0$ 和对于所有 $0 \\le i \\le n-2$，$(f_{0}(x))_{i} = x_{i}$。\n2. $f_{1}(x)$ 与 $f_{0}(x)$ 相同，但增加了对负零的特殊情况处理：如果 $x = 1^{n}$，则 $f_{1}(x) = 0^{n}$。\n3. 当且仅当 MSB 为 $1$ 时，$g(x)$ 将所有位取反，即当 $x_{n-1} = 1$ 时 $g(x) = \\overline{x}$，当 $x_{n-1} = 0$ 时 $g(x) = x$。\n\n仅从上述定义以及正确绝对值必须等于 $\\mathrm{enc}(|\\mathrm{val}(x)|)$ 的要求出发，分析每种实现，并确定（作为 $n$ 的函数）有多少个输入 $x \\in \\{0,1\\}^{n}$ 使得其输出等于规范编码 $\\mathrm{enc}(|\\mathrm{val}(x)|)$ 的确切数量。将这些基数记为 $|S_{f_{0}}|$、 $|S_{f_{1}}|$ 和 $|S_{g}|$，其中对于一个实现 $h$，$S_{h} \\triangleq \\{x \\in \\{0,1\\}^{n} \\mid h(x) = \\mathrm{enc}(|\\mathrm{val}(x)|)\\}$。将您的最终答案表示为单个有序三元组。无需四舍五入，也不涉及单位。", "solution": "我的目标是找出集合 $S_{f_0}$、$S_{f_1}$ 和 $S_g$ 的大小。我需要为所有可能的输入 $x \\in \\{0,1\\}^n$ 分析每个函数。一个自然的方法是根据最高有效位 (MSB) $x_{n-1}$ 对输入进行划分。\n\n**情况1：$x_{n-1} = 0$（非负数）**\n*   共有 $2^{n-1}$ 个这样的数。\n*   对于这些数，$\\mathrm{val}(x) = m(x)$。由于 $x_{n-1}=0$，其值为非负，所以 $\\mathrm{val}(x) \\ge 0$。\n*   $|\\mathrm{val}(x)| = |m(x)| = m(x)$。\n*   正确的输出必须是 $\\mathrm{enc}(|\\mathrm{val}(x)|) = \\mathrm{enc}(m(x))$。\n*   根据 `enc` 的定义，`enc(y)` 是 MSB 为 0 且无符号大小为 $y$ 的 $n$ 位向量。\n*   输入 $x$ 本身的 MSB 就是 0。如果 $x_{n-1}=0$，$\\mathrm{val}(x) = \\sum_{i=0}^{n-2} x_i 2^i$。我们称这个值为 $y$。\n*   所以，$\\mathrm{val}(x) = y$，其中 $0 \\le y \\le 2^{n-1}-1$。\n*   那么 $|\\mathrm{val}(x)| = y$。\n*   目标输出是 $\\mathrm{enc}(y)$。根据定义，$\\mathrm{enc}(y)$ 是 MSB 为 0 且无符号大小等于 $y$ 的位向量。这正是我们开始时的位向量 $x$。\n*   因此，对于任何满足 $x_{n-1}=0$ 的 $x$，正确的输出就是 $x$ 本身。\n*   我们来检查每个函数在 $x_{n-1}=0$ 时的行为：\n    *   **`f_0(x)`**: 将 MSB 清零。由于 $x_{n-1}$ 已经是 0，$f_0(x)$ 不会改变它。所有其他位也保持不变。因此，$f_0(x) = x$。这是正确的。这对所有 $2^{n-1}$ 个非负输入都成立。\n    *   **`f_1(x)`**: 由于 $x_{n-1}=0$，$x$ 不可能是 $1^n$。所以 $f_1(x) = f_0(x) = x$。这对所有 $2^{n-1}$ 个非负输入也都是正确的。\n    *   **`g(x)`**: 由于 $x_{n-1}=0$，$g(x) = x$。这对所有 $2^{n-1}$ 个非负输入也都是正确的。\n\n*   **非负输入的结论**: 对于所有 $x_{n-1}=0$ 的 $2^{n-1}$ 个输入，这三个函数都是正确的。\n\n**情况2：$x_{n-1} = 1$（负数和负零）**\n*   共有 $2^{n-1}$ 个这样的数。\n*   这个情况可以分为两个子情况：$x=1^n$（负零）和 $x \\neq 1^n$（严格为负的数）。\n\n**子情况 2a：$x \\neq 1^n$ 且 $x_{n-1}=1$（严格为负的数）**\n*   共有 $2^{n-1}-1$ 个这样的数。\n*   对于这些输入，$\\mathrm{val}(x) = -m(\\overline{x})$。\n*   $|\\mathrm{val}(x)| = |-m(\\overline{x})| = m(\\overline{x})$。\n*   正确的输出必须是 $\\mathrm{enc}(|\\mathrm{val}(x)|) = \\mathrm{enc}(m(\\overline{x}))$。\n*   令 $y = \\overline{x}$。由于 $x_{n-1}=1$，我们有 $y_{n-1}=0$。由于 $x \\neq 1^n$，我们有 $y \\neq 0^n$。\n*   我们需要编码的值是 $m(\\overline{x})$。\n*   $\\mathrm{enc}(m(\\overline{x}))$ 是什么？它是 MSB 为 0 且无符号大小为 $m(\\overline{x})$ 的唯一 $n$ 位向量。\n*   我们来看位向量 $\\overline{x}$。它的 MSB 是 $0$。它的无符号大小是 $m(\\overline{x})$。因此，根据定义，$\\mathrm{enc}(m(\\overline{x})) = \\overline{x}$。\n*   所以，对于任何严格为负的输入 $x$，正确的输出是 $\\overline{x}$。\n*   我们来为这 $2^{n-1}-1$ 个输入检查每个函数：\n    *   **`f_0(x)`**:\n        *   $f_0(x)$ 将 $x$ 的 MSB 清零，所以 $(f_0(x))_{n-1}=0$。其余各位保持不变，即对于所有 $0 \\le i \\le n-2$，有 $(f_0(x))_i = x_i$。\n        *   $f_0(x) = \\overline{x}$ 是否成立？\n        *   MSB 匹配：$(f_0(x))_{n-1} = 0$，并且 $(\\overline{x})_{n-1} = 0$。\n        *   向量 $f_0(x)$ 是 $0x_{n-2}...x_0$。\n        *   向量 $\\overline{x}$ 是 $0\\overline{x}_{n-2}...\\overline{x}_0$。\n        *   它们相等，当且仅当对于所有 $i \\in \\{0, ..., n-2\\}$ 都有 $x_i = \\overline{x}_i$。这永远不会是真的，因为一个比特位不等于其自身的反码。\n        *   所以对于任何严格为负的数，$f_0(x)$ 永远不正确。\n\n    *   **`f_1(x)`**:\n        *   由于 $x \\neq 1^n$，$f_1(x) = f_0(x)$。\n        *   与上面相同的原因，$f_1(x)$ 对于任何严格为负的数永远不正确。\n\n    *   **`g(x)`**:\n        *   由于 $x_{n-1}=1$，$g(x) = \\overline{x}$。\n        *   正如我们推导的，正确的输出是 $\\overline{x}$。\n        *   因此，$g(x)$ 对于所有 $2^{n-1}-1$ 个严格为负的数都是正确的。\n\n**子情况 2b：$x = 1^n$（负零）**\n*   这是一个单一输入。\n*   对于这个输入，$\\mathrm{val}(1^n) = 0$。\n*   $|\\mathrm{val}(1^n)| = 0$。\n*   正确的输出必须是 $\\mathrm{enc}(|\\mathrm{val}(1^n)|) = \\mathrm{enc}(0)$。\n*   根据定义，$\\mathrm{enc}(0) = 0^n$。\n*   所以，对于 $x=1^n$，正确的输出是 $0^n$。\n*   我们来为这个输入检查每个函数：\n    *   **`f_0(1^n)`**:\n        *   $f_0(x)$ 将 MSB 清零并保持其他位不变。\n        *   输入 $x = 11...1$。\n        *   输出将是 $01...1$。\n        *   正确的输出是 $00...0 = 0^n$。\n        *   $01...1 = 00...0$ 吗？不，因为 $n \\ge 2$，在 $f_0$ 的输出中至少有一个位（在索引 $n-2$ 处）是 $1$。所以 $f_0$ 对于 $x=1^n$ 是不正确的。\n\n    *   **`f_1(1^n)`**:\n        *   定义中对这个确切的输入有一个特殊情况：如果 $x=1^n$，则 $f_1(x) = 0^n$。\n        *   正确的输出是 $0^n$。\n        *   所以，$f_1$ 对于 $x=1^n$ 是正确的。\n\n    *   **`g(1^n)`**:\n        *   由于 $1^n$ 的 MSB 是 $1$，$g(1^n) = \\overline{1^n} = 0^n$。\n        *   正确的输出是 $0^n$。\n        *   所以，$g$ 对于 $x=1^n$ 是正确的。\n\n**正确性计数总结**：\n\n我们来统计每个函数的结果。输入总数是 $2^{n-1} + (2^{n-1}-1) + 1 = 2^n$。\n\n*   **对于 `f_0(x)`**：\n    *   对所有 $2^{n-1}$ 个非负输入（$x_{n-1}=0$）都正确。\n    *   对所有 $2^{n-1}-1$ 个严格为负的输入都不正确。\n    *   对负零输入（$x=1^n$）不正确。\n    *   总正确数：$|S_{f_0}| = 2^{n-1}$。\n\n*   **对于 `f_1(x)`**：\n    *   对所有 $2^{n-1}$ 个非负输入（$x_{n-1}=0$）都正确。\n    *   对所有 $2^{n-1}-1$ 个严格为负的输入都不正确。\n    *   对负零输入（$x=1^n$）正确。\n    *   总正确数：$|S_{f_1}| = 2^{n-1} + 1$。\n\n*   **对于 `g(x)`**：\n    *   对所有 $2^{n-1}$ 个非负输入（$x_{n-1}=0$）都正确。\n    *   对所有 $2^{n-1}-1$ 个严格为负的输入都正确。\n    *   对负零输入（$x=1^n$）正确。\n    *   总正确数：$|S_g| = 2^{n-1} + (2^{n-1}-1) + 1 = 2 \\cdot 2^{n-1} = 2^n$。\n\n所以，$g(x)$ 对所有输入都是一个正确的实现。我们来复核一下这个逻辑。\n对于 $x_{n-1}=0$，$g(x)=x$。我们需要证明 $x = \\mathrm{enc}(|\\mathrm{val}(x)|)$。\n如果 $x_{n-1}=0$，$\\mathrm{val}(x) \\ge 0$。所以 $|\\mathrm{val}(x)|=\\mathrm{val}(x)$。我们需要证明 $x = \\mathrm{enc}(\\mathrm{val}(x))$。根据 `enc` 的定义，这正是 $x$ 本身。所以 $g(x)$ 在这些情况下是正确的。\n\n对于 $x_{n-1}=1$，$g(x)=\\overline{x}$。我们需要证明 $\\overline{x} = \\mathrm{enc}(|\\mathrm{val}(x)|)$。\n如果 $x_{n-1}=1$ 且 $x \\ne 1^n$，$\\mathrm{val}(x)=-m(\\overline{x})$。所以 $|\\mathrm{val}(x)|=m(\\overline{x})$。我们需要证明 $\\overline{x} = \\mathrm{enc}(m(\\overline{x}))$。向量 $\\overline{x}$ 的 MSB 是 0，其无符号值确实是 $m(\\overline{x})$，所以这符合 `enc` 的定义。因此，$g(x)$ 在这些情况下是正确的。\n\n如果 $x=1^n$，$\\mathrm{val}(x)=0$。所以 $|\\mathrm{val}(x)|=0$。目标是 $\\mathrm{enc}(0) = 0^n$。函数给出 $g(1^n)=\\overline{1^n}=0^n$。所以 $g(x)$ 对于 $x=1^n$ 也是正确的。\n\n因此，$g(x)$ 对于所有 $2^n$ 个输入都是正确的。$|S_g|=2^n$。\n最终的计数是：$|S_{f_0}| = 2^{n-1}$， $|S_{f_1}| = 2^{n-1} + 1$， $|S_g| = 2^n$。\n这些结果形成有序三元组 $(2^{n-1}, 2^{n-1} + 1, 2^n)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2^{n-1}  2^{n-1} + 1  2^{n}\n\\end{pmatrix}\n}\n$$", "id": "3662312"}, {"introduction": "最后的练习将带你深入探讨反码在累加求和这类实际场景中的应用，及其背后的理论内涵。本练习 [@problem_id:3662339] 引导你比较处理“循环进位”（end-around carry）的不同实现策略。通过分析，你将揭示位级操作机制与其在模运算 ($ \\pmod{2^n-1} $) 这一数学基础之间的深刻联系，从而对反码运算获得更本质的认识。", "problem": "您正在为一台 $n$ 位反码机器设计一个求和程序。在反码加法中，将两个 $n$ 位字 $a$ 和 $b$ 相加的操作是：首先执行普通的二进制加法，得到一个 $(n+1)$ 位的和，然后重复地“规范化”——将最高有效位的任何进位回卷到最低有效位，直到没有进位为止。您必须对 $k$ 个输入字 $x_1, x_2, \\ldots, x_k$求和，每个字都是一个 $n$ 位反码值，以生成一个符合反码算术规则的 $n$ 位结果。\n\n正在考虑两种高级策略：\n\n- 分步规范化（Step-normalize）：在将每个操作数加到 $n$ 位累加器后，立即通过循环进位折叠进行规范化，直到没有进位为止。\n\n- 末端规范化（End-normalize）：首先累加所有操作数，不进行任何循环进位折叠，然后在最后执行一个单一的最终规范化步骤。\n\n假设目标是对于所有 $n \\ge 1$、$k \\ge 1$ 的选择以及 $n$ 位反码域中的所有输入字 $x_i$ 都是正确的。关于这些策略的正确性，以下哪个陈述是正确的？\n\nA. 为了保证正确性，每次加法后都必须进行规范化。对于任意的 $k$ 和 $n$，将规范化推迟到最后是无法做到正确的。\n\nB. 对于所有的 $k$ 和 $n$，两种策略都可以是正确的，条件是：在推迟规范化时，您需要在一个足够宽以避免溢出的寄存器中累加精确的整数和，然后在最后通过重复地将所有高位溢出折叠回低 $n$ 位来进行完全规范化，直到没有进位为止。\n\nC. 总是只需使用一个 $(n+1)$ 位的累加器，推迟规范化，并在最后将单个最终的进位位加到低 $n$ 位一次即可。\n\nD. 仅在对最多 $2$ 个操作数求和时，推迟规范化才是正确的；对于 $3$ 个或更多操作数，它必然是错误的。", "solution": "用户希望我分析两种对反码数求和的不同策略，并确定所提供的关于其正确性的陈述中哪一个是正确的。\n\n### 问题验证\n\n**第1步：提取已知信息**\n- **机器：**一台 $n$ 位反码机器。\n- **输入：** $k$ 个字，表示为 $x_1, x_2, \\ldots, x_k$。\n- **字属性：**每个 $x_i$ 是一个 $n$ 位反码值。\n- **求和目标：**生成一个符合反码算术规则的 $n$ 位结果。\n- **反码加法定义：**对于两个 $n$ 位字 $a$ 和 $b$：1. 执行普通二进制加法，得到一个 $(n+1)$ 位的和。2. 重复“规范化”，即将最高有效位（MSB）的任何进位加回到最低有效位（LSB），直到没有进位为止。这被称为循环进位（end-around carry）。\n- **策略1（分步规范化）：**将每个操作数 $x_i$ 加到 $n$ 位累加器后，立即通过循环进位进行规范化。\n- **策略2（末端规范化）：**首先累加所有操作数，不进行任何循环进位折叠，然后在最后执行一个单一的最终规范化步骤。\n- **正确性条件：**所选策略必须对所有整数 $n \\ge 1$、$k \\ge 1$ 以及所有可能的 $n$ 位反码输入字 $x_i$ 都正确。\n\n**第2步：使用提取的已知信息进行验证**\n根据验证标准对问题陈述进行评估。\n\n- **科学性：**是。该问题设置在计算机组成和体系结构的背景下。反码是表示有符号整数的一种标准方法，尽管现在很大程度上已成为历史。通过循环进位来描述反码加法是准确的。\n- **适定性：**是。问题清晰地定义了两种不同的算法，并要求在一般条件下评估其正确性。该问题有一个可以从数系的数学属性中推导出的确定答案。\n- **客观性：**是。术语是技术性的、精确的，没有主观或含糊的语言。\n\n**缺陷清单：**\n1.  **科学或事实不准确：**无。反码算术的原理陈述正确。\n2.  **不可形式化或不相关：**不适用。该问题可以使用模算术直接形式化。\n3.  **不完整或矛盾的设置：**“末端规范化”关于累加器宽度的描述略显不足，但所提供的选项（B和C）探讨了这些实现细节，使得整个问题成为一个对策略正确性所需条件的明确探索。这本身不是问题陈述中的致命缺陷。\n4.  **不切实际或不可行：**不适用。这是一个关于算法的概念性问题。\n5.  **不适定或结构不良：**无。\n6.  **伪深刻、琐碎或同义反复：**无。该问题需要对计算机算术有非凡的理解。\n7.  **无法通过科学验证：**不适用。这些主张可以通过数学证明。\n\n**第3步：结论和行动**\n问题陈述是**有效的**。可以继续进行分析。\n\n### 推导\n\n$n$ 位反码算术的基本原理是它等价于模 $(2^n - 1)$ 的算术。设 $M = 2^n-1$。设一个 $n$ 位模式 $a$ 的无符号整数值表示为 $a_{uint}$。将两个模式 $a$ 和 $b$ 进行二进制相加，然后进行循环进位的操作，可以正确计算出 $(a_{uint} + b_{uint}) \\pmod{M}$ 的位模式。\n\n要理解其原因，考虑和 $S'_{uint} = a_{uint} + b_{uint}$。这个和可以写成 $S'_{uint} = c \\cdot 2^n + S_{low}$，其中 $S_{low}$ 是和的低 $n$ 位（即 $S'_{uint} \\pmod{2^n}$），$c$ 是进位位。循环进位操作计算出的最终结果是对应于值 $S_{uint} = S_{low} + c$ 的位模式。\n\n使用模算术，我们知道 $2^n \\equiv 1 \\pmod{M}$。因此：\n$$S'_{uint} = c \\cdot 2^n + S_{low} \\equiv c \\cdot 1 + S_{low} \\pmod{M}$$\n这证实了计算 $S_{low} + c$ 的循环进位操作，产生的结果与整数和 $a_{uint} + b_{uint}$ 模 $(2^n-1)$ 同余。如果 $S_{low} + c$ 本身产生进位，则重复该过程，这只是相同模属性的另一次应用，直到结果小于 $2^n$。\n\n目标是计算 $k$ 个字的和，这对应于 $(\\sum_{i=1}^k x_{i,uint}) \\pmod{M}$ 的最终位模式。\n\n**策略1分析：分步规范化**\n该策略以迭代方式计算和。设累加 $i$ 个字后的累加器值为 $A_i$。\n$A_0 = 0$\n$A_1 = (x_{1,uint}) \\pmod M$\n$A_2 = (A_1 + x_{2,uint}) \\pmod M = ((x_{1,uint}) \\pmod M + x_{2,uint}) \\pmod M = (x_{1,uint} + x_{2,uint}) \\pmod M$\n通过归纳法，累加所有 $k$ 个字后的最终结果是：\n$$A_k = (\\sum_{i=1}^k x_{i,uint}) \\pmod M$$\n这正是正确的结果。因此，分步规范化策略总是正确的。\n\n**策略2分析：末端规范化**\n该策略首先通过简单的二进制加法计算一个中间和，然后在最后进行一次规范化。设完整的整数和为 $S_{int} = \\sum_{i=1}^k x_{i,uint}$。为了保证正确，最终结果必须是 $S_{int} \\pmod M$。\n\n此策略的关键要求是，中间和 $S_{int}$ 必须被精确计算，不能因溢出而丢失任何信息。输入字 $x_{i,uint}$ 是 $n$ 位无符号值，因此 $0 \\le x_{i,uint} \\le 2^n-1$。$S_{int}$ 的最大值是 $k(2^n-1)$。存储这个和所需的位数大约是 $n + \\lceil\\log_2 k\\rceil$。因此，一个“足够宽以避免溢出”的寄存器是必要的。\n\n假设使用了这样的寄存器并计算出了 $S_{int}$，那么最终的规范化步骤必须正确计算 $S_{int} \\pmod{2^n-1}$。问题将此规范化描述为“重复地将所有高位溢出折叠回低 $n$ 位，直到没有进位为止”。让我们形式化这个折叠过程。设 $S_{int} = Q \\cdot 2^n + R$，其中 $R = S_{int} \\pmod{2^n}$（低 $n$ 位），$Q = \\lfloor S_{int} / 2^n \\rfloor$（所有高位）。折叠操作计算出一个新的和 $S_1 = Q+R$。\n\n如前所示，$2^n \\equiv 1 \\pmod{2^n-1}$，所以：\n$$S_{int} = Q \\cdot 2^n + R \\equiv Q \\cdot 1 + R \\pmod{2^n-1}$$\n因此，$S_1 \\equiv S_{int} \\pmod{2^n-1}$。这个折叠过程可以在 $S_1$、$S_2$ 等上重复进行，直到结果是一个 $n$ 位的值。每一步都保留了模 $2^n-1$ 的值。这个过程是计算模数的有效算法。\n\n因此，只要使用足够宽的累加器首先计算出精确的整数和，末端规范化策略也是正确的。\n\n### 逐项分析\n\n**A. 为了保证正确性，每次加法后都必须进行规范化。对于任意的 $k$ 和 $n$，将规范化推迟到最后是无法做到正确的。**\n我们的分析表明，如果中间和存储在一个足够宽的寄存器中而没有信息丢失，“末端规范化”策略是可以做到正确的。该陈述声称它*无法*做到正确，这是错误的。\n**结论：不正确。**\n\n**B. 对于所有的 $k$ 和 $n$，两种策略都可以是正确的，条件是：在推迟规范化时，您需要在一个足够宽以避免溢出的寄存器中累加精确的整数和，然后在最后通过重复地将所有高位溢出折叠回低 $n$ 位来进行完全规范化，直到没有进位为止。**\n这个陈述与我们的推导完全一致。它正确地指出，分步规范化策略是正确的（这是标准方法，所以是隐含的），并且在指定条件下，末端规范化策略也是正确的：即使用足够宽的累加器来获取精确的整数和，并执行完整的模约简（“重复折叠”）。\n**结论：正确。**\n\n**C. 总是只需使用一个 $(n+1)$ 位的累加器，推迟规范化，并在最后将单个最终的进位位加到低 $n$ 位一次即可。**\n这为末端规范化策略提出了一个特定的、固定大小的实现。一个 $(n+1)$ 位累加器能容纳的最大值是 $2^{n+1}-1$。最大和是 $k(2^n-1)$。对于 $k=3$，最大和是 $3(2^n-1) = 3 \\cdot 2^n - 3$。对于任何 $n \\ge 2$，$3 \\cdot 2^n - 3  2 \\cdot 2^n - 1 = 2^{n+1}-1$。例如，当 $n=2$ 时，最大和是 $3(3)=9$。一个 $(n+1)=3$ 位的累加器会溢出，因为它只能容纳最大为 $7$ 的值。信息会丢失。因此，对于任意 $k \\ge 3$，一个 $(n+1)$ 位的累加器并不能“总是足够”。此外，将*单个*进位位加回去的过程仅在总和已知小于 $2 \\cdot 2^n$ 时才足够，因为大于该值的和会产生一个多位的溢出部分（我们分析中的 $Q$）。\n**结论：不正确。**\n\n**D. 仅在对最多 $2$ 个操作数求和时，推迟规范化才是正确的；对于 $3$ 个或更多操作数，它必然是错误的。**\n这个陈述过于绝对。如对B的分析所示，只要实现时使用足够大小的寄存器（例如，$n+\\lceil\\log_2 k\\rceil$ 位），对于任意数量的操作数 $k$，推迟规范化都是一个有效的策略。该策略本身对于 $k \\ge 3$ 并非“必然不正确”；相反，一个使用固定宽度累加器（如 $n$ 或 $n+1$ 位）的简单实现会是不正确的。\n**结论：不正确。**", "answer": "$$\\boxed{B}$$", "id": "3662339"}]}