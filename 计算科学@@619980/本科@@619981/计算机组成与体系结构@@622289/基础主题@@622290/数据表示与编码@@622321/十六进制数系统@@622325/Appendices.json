{"hands_on_practices": [{"introduction": "十六进制的核心价值在于其作为二进制数据紧凑、易读形式的能力。本练习将通过一个实际的进制转换任务 [@problem_id:1948850]，帮助你熟练掌握十六进制、八进制和二进制之间的内在联系。这项技能对于理解和操作底层硬件（如内存控制器和CPU寄存器）中的地址与数据至关重要。", "problem": "在数字系统工程中，数据常常需要在不同的数制之间进行转换，以确保组件之间的兼容性。考虑这样一个场景：一个专用嵌入式系统中的内存控制器使用基于八进制（基数为8）的寻址方案。一个新的中央处理器（CPU）正在被集成到这个系统中，但其内部寄存器使用十六进制（Hex）数制（基数为16）来引用内存地址。\n\n为了测试地址转换逻辑，我们选择一个特定的内存地址。CPU生成了十六进制地址`$9C$`。为了让内存控制器能够访问正确的位置，这个地址必须被转换成其等效的八进制表示。十六进制数`$9C$`的八进制等价值是多少？", "solution": "我们需要求十六进制数$9C$的八进制表示。由于$16=2^{4}$，每个十六进制数字对应一个4位的二进制块。十六进制数字是$9$和$C$，其中$C=12$。\n\n使用二进制展开将每个十六进制数字转换为二进制：\n$$9=8+1 \\implies 9_{16} \\to 1001_{2}, \\quad C=12=8+4 \\implies C_{16} \\to 1100_{2}.$$\n因此，\n$$9C_{16}=(1001\\,1100)_{2}.$$\n\n要将二进制转换为八进制，从右边开始将二进制数字按3位一组进行分组（因为$8=2^{3}$），必要时在左边用零填充：\n$$(10011100)_{2}=(010\\,011\\,100)_{2}.$$\n计算每个3位组的值：\n$$010_{2}=2, \\quad 011_{2}=3, \\quad 100_{2}=4.$$\n所以，\n$$9C_{16}=234_{8}.$$\n\n作为检验，我们将$9C_{16}$转换为十进制，然后再表示为八进制。使用基数为16的位值，\n$$9C_{16}=9\\cdot 16^{1}+12\\cdot 16^{0}=144+12=156.$$\n将$156$表示为八进制：\n$$156=2\\cdot 8^{2}+3\\cdot 8^{1}+4\\cdot 8^{0}=128+24+4,$$\n这对应于$234_{8}$，从而证实了结果。", "answer": "$$\\boxed{234}$$", "id": "1948850"}, {"introduction": "十六进制数在计算机体系结构中不仅是数据的表示，更承载着特定的算术意义，例如在二进制补码系统中的有符号整数。本练习 [@problem_id:3647781] 模拟了一个常见的场景：当一个较短的立即数（如 $12$ 位）参与一个较宽（如 $32$ 位）的算术运算时，CPU如何通过“符号扩展”来保持其数值的正确性。通过分析一个假设的硬件错误，你将更深刻地理解这一过程的重要性。", "problem": "一个 32 位精简指令集计算 (RISC) 核心使用二进制补码表示有符号整数，并实现位宽为 $12$ 位的立即数操作数。在算术逻辑单元 (ALU) 执行的一条加法指令中，$12$ 位的立即数字段为十六进制值 $0xF7F$，目标寄存器初始包含十六进制值 $0x10001000$。该架构规范要求立即数在被 ALU 使用前必须符号扩展到 $32$ 位，但一个错误的实现却对立即数进行了零扩展。\n\n从位值计数系统和二进制补码算术的第一性原理出发，通过比较正确的符号扩展行为与错误的零扩展行为，确定计算出的寄存器值的差异的精确大小。具体来说，令 $I_{\\text{sext}}$ 为 $12$ 位立即数 $0xF7F$ 正确的 $32$ 位符号扩展值，令 $I_{\\text{zext}}$ 为同一立即数的错误的 $32$ 位零扩展值。在正确的行为下，ALU 计算 $R'_{\\text{sext}} = R + I_{\\text{sext}}$；在错误的行为下，ALU 计算 $R'_{\\text{zext}} = R + I_{\\text{zext}}$，其中 $R = 0x10001000$。计算\n$$D = \\left|R'_{\\text{sext}} - R'_{\\text{zext}}\\right|,$$\n的精确值，并将你的最终答案表示为一个以 $10$ 为基数的整数。不需要四舍五入，也不涉及物理单位。", "solution": "问题要求确定在使用正确符号扩展的立即数和错误零扩展的立即数进行加法运算时，结果之间的差异大小 $D$。\n\n首先，让我们对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 架构：$32$ 位 RISC 核心。\n- 整数表示：有符号整数采用二进制补码。\n- 立即数操作數位宽：$12$ 位。\n- 立即数值 (十六进制)：$0xF7F$。\n- 初始目标寄存器值 (十六进制)：$R = 0x10001000$。\n- 正确行为：将 $12$ 位立即数符号扩展到 $32$ 位。设此值为 $I_{\\text{sext}}$。\n- 错误行为：将 $12$ 位立即数零扩展到 $32$ 位。设此值为 $I_{\\text{zext}}$。\n- 正确计算结果：$R'_{\\text{sext}} = R + I_{\\text{sext}}$。\n- 错误计算结果：$R'_{\\text{zext}} = R + I_{\\text{zext}}$。\n- 待计算量：差异 $D = \\left|R'_{\\text{sext}} - R'_{\\text{zext}}\\right|$。\n- 最终答案必须是一个以 $10$ 为基数的整数。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题基于计算机组成与架构的基本概念，包括位值计数系统（十六进制、二进制）、二进制补码算术，以及指令集架构特性，如立即数操作数、符号扩展和零扩展。这些概念是公认且科学上合理的。\n- **适定性**：问题是完全指定的。所有值和行为都有定义，目标是一个明确陈述的数学计算。存在唯一解。\n- **客观性**：问题以精确、客观的语言陈述，没有歧义或主观声明。\n\n**结论与行动**\n问题有效。它有科学依据、适定且客观。没有矛盾、信息缺失或逻辑缺陷。我们继续进行解答。\n\n需要计算的量是正确结果与错误结果之差的绝对值：\n$$D = \\left|R'_{\\text{sext}} - R'_{\\text{zext}}\\right|$$\n代入 $R'_{\\text{sext}}$ 和 $R'_{\\text{zext}}$ 的定义：\n$$D = \\left|(R + I_{\\text{sext}}) - (R + I_{\\text{zext}})\\right|$$\n简化表达式，寄存器的初始值 $R$ 被消掉了：\n$$D = \\left|R + I_{\\text{sext}} - R - I_{\\text{zext}}\\right| = \\left|I_{\\text{sext}} - I_{\\text{zext}}\\right|$$\n因此，问题简化为求立即数的符号扩展值和零扩展值之差的绝对值。初始寄存器值 $R = 0x10001000$ 是无关信息。\n\n让我们从第一性原理分析立即数值。该立即数是一个 $12$ 位的十六进制值 $0xF7F$。\n在一个基数为 $b$ 的位值计数系统中，由数字 $d_{n-1}d_{n-2}...d_0$ 表示的数的值为 $\\sum_{i=0}^{n-1} d_i b^i$。\n首先，我们将这个 $12$ 位的十六进制值转换为其二进制表示。每个十六进制数字对应 $4$ 个二进制数字（位）：\n- $F_{16} = 15_{10} = 1111_2$\n- $7_{16} = 7_{10} = 0111_2$\n- $F_{16} = 15_{10} = 1111_2$\n\n组合起来，这个 $12$ 位立即数的二进制表示为 $111101111111_2$。我们用 $J$ 表示这个位模式。\n\n在二进制补码表示法中，一个数的符号由其最高有效位 (MSB) 决定。对于一个 $12$ 位的数，MSB 是第 $11$ 位（从第 $0$ 位开始计数）。在模式 $111101111111_2$ 中，MSB 是 $1$。这表示该立即数代表一个负值。\n\n设 $j_{11}j_{10}...j_0$ 是 $12$ 位立即数 $J$ 的二进制表示。\n一个有符号 $12$ 位二进制补码整数的值由以下公式给出：\n$$V(J) = -j_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} j_i \\cdot 2^i$$\n一个无符号 $12$ 位整数的值为：\n$$V_U(J) = \\sum_{i=0}^{11} j_i \\cdot 2^i = j_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} j_i \\cdot 2^i$$\n\n零扩展到 $32$ 位涉及在前面添加 $32 - 12 = 20$ 个零。得到的 $32$ 位数 $I_{\\text{zext}}$ 被系统解释为一个正数，其值就是原始 $12$ 位模式的无符号值。\n$$V(I_{\\text{zext}}) = V_U(J) = \\sum_{i=0}^{11} j_i \\cdot 2^i$$\n\n符号扩展到 $32$ 位涉及在前面添加 $20$ 个原始 $12$ 位数的 MSB ($j_{11}$) 的副本。这个过程保留了原始数的有符号数值。\n$$V(I_{\\text{sext}}) = V(J) = -j_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} j_i \\cdot 2^i$$\n\n现在我们计算它们的值的差：\n$$V(I_{\\text{sext}}) - V(I_{\\text{zext}}) = \\left(-j_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} j_i \\cdot 2^i\\right) - \\left(j_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} j_i \\cdot 2^i\\right)$$\n求和项被消掉了：\n$$V(I_{\\text{sext}}) - V(I_{\\text{zext}}) = -j_{11} \\cdot 2^{11} - j_{11} \\cdot 2^{11} = -2 \\cdot j_{11} \\cdot 2^{11} = -j_{11} \\cdot 2^{12}$$\n对于给定的立即数 $0xF7F$，其二进制表示为 $111101111111_2$，因此其 MSB 为 $j_{11} = 1$。\n将 $j_{11} = 1$ 代入差值公式：\n$$V(I_{\\text{sext}}) - V(I_{\\text{zext}}) = -1 \\cdot 2^{12} = -2^{12}$$\n差异 $D$ 是这个差的绝对值：\n$$D = \\left|I_{\\text{sext}} - I_{\\text{zext}}\\right| = \\left|V(I_{\\text{sext}}) - V(I_{\\text{zext}})\\right| = \\left|-2^{12}\\right| = 2^{12}$$\n最后，我们计算其以 $10$ 为基数的值：\n$$2^{10} = 1024$$\n$$2^{11} = 2 \\times 1024 = 2048$$\n$$2^{12} = 2 \\times 2048 = 4096$$\n差异的大小是 $4096$。\n这个结果是通用的：对于一个 MSB 为 $1$ 的 $k$ 位立即数，错误的零扩展代替符号扩展将产生一个比正确值恰好大 $2^k$ 的值。如果 MSB 为 $0$，两种扩展将是相同的，差异将为 $0$。", "answer": "$$\\boxed{4096}$$", "id": "3647781"}, {"introduction": "在系统编程和硬件交互中，我们常常需要精确地修改一个寄存器或数据字中的特定比特位，同时保持其余部分不变。本练习 [@problem_id:3647874] 将引导你从第一性原理出发，推导并应用一种称为“位掩码”的标准技术。通过结合使用十六进制字面量和位运算符，你将学会如何实现对数据的精准控制，这是底层软件开发的一项基本功。", "problem": "在中央处理器（CPU）的数据通路中，基于掩码的字段插入是一种常规操作，用于设置一个字中的特定位字段，同时保持所有其他位不变。考虑一个宽度为 $32$ 位的字长寄存器，其位的位置从 $0$（最低有效位）到 $31$（最高有效位）编号。设 $x$ 表示寄存器的内容，初始值为 $x = 0x12345678$。目标是将 $x$ 的第 $8$ 位到第 $11$ 位设置为十六进制半字节 $0xA$，并保持所有其他位不变。\n\n仅从位运算“按位与”(``)、“按位或”(`|`)、“按位非”(`~`)和“左移”(``)的定义，以及十六进制数位在二进制中的位置含义（每个十六进制数位等于四个连续的二进制位）出发，从第一性原理推导出一个正确的掩码插入过程，以完成所需的字段插入。然后将您推导出的过程应用于给定的 $x$，计算出最终的寄存器值。\n\n将您的最终答案表示为带前缀 $0x$ 的单个十六进制整数。无需四舍五入。", "solution": "该问题是有效的，因为它在计算机体系结构方面有科学依据，问题陈述清晰、客观，并包含了推导唯一解所需的所有信息。\n\n任务是修改一个 $32$ 位寄存器中的特定位字段。设寄存器的初始内容由变量 $x$ 表示。目标是将第 $8$ 位到第 $11$ 位设置为十六进制值 $0xA$，同时保留所有其他位的状态。这个操作通常被称为字段插入，并且可以从第一性原理使用位逻辑运算推导出来。\n\n该过程包括两个基本步骤：\n1.  **清除目标位字段**：首先，我们必须将目标字段（第 $8$ 位到第 $11$ 位）中的位设置为 $0$。这能确保后续的插入步骤不会破坏最终的值。这是通过与一个“清除掩码”进行“按位与”(``)运算来实现的。\n2.  **插入新值**：其次，我们必须将新值放入已被清除的目标字段中。这是通过与一个“插入值”进行“按位或”(`|`)运算来完成的。\n\n让我们根据问题陈述推导所需的掩码和值。寄存器宽度为 $32$ 位。目标字段从位 $i=8$ 延伸到位 $j=11$。该字段的宽度为 $w = j - i + 1 = 11 - 8 + 1 = 4$ 位。该字段的新值为 $v = 0xA$。\n\n**步骤1：推导清除掩码**\n\n为了清除 $x$ 中的目标字段，我们使用一个清除掩码，我们称之为 $M_{clear}$。这个掩码必须在第 $8$ 位到第 $11$ 位的位置上为 $0$，在所有其他 $28$ 个位置上为 $1$。执行 `x  M_clear` 将目标位设置为 $0$，同时保持 $x$ 的所有其他位不变（因为对于任意位 $b$，$b \\ \\ \\ 1 = b$ 且 $b \\ \\ \\ 0 = 0$）。\n\n我们可以通过先定义一个只在目标位字段中为 $1$ 的掩码，然后对其进行按位取反(`~`)来构造 $M_{clear}$。我们称这个中间掩码为 $M_{field}$。$M_{field}$ 从第 $8$ 位开始有 $4$ 个连续的 $1$。一个由 $w$ 个 $1$ 组成的块可以用整数 $2^w - 1$ 表示。对于 $w=4$，这个值是 $2^4 - 1 = 15$，在十六进制中为 $0xF$。\n\n为了将这些 $1$ 定位到正确的位置，我们必须将这个值按起始位位置 $i=8$ 进行左移(``)。\n$$M_{\\text{field}} = 0xF \\ll 8$$\n在一个 $32$ 位系统中，一个十六进制数是 $8$ 个半字节（4位组）的序列。左移 $8$ 位相当于移动两个十六进制位置。\n十六进制常数 $0xF$ 在 $32$ 位中表示为 $0x0000000F$。\n$$M_{\\text{field}} = 0x0000000F \\ll 8 = 0x00000F00$$\n清除掩码 $M_{clear}$ 是 $M_{field}$ 的按位非：\n$$M_{\\text{clear}} = \\sim M_{\\text{field}} = \\sim (0x00000F00)$$\n对这个 $32$ 位值执行按位非运算得到：\n$$M_{\\text{clear}} = 0xFFFFF0FF$$\n因此，清除 $x$ 中字段的操作是 `x  0xFFFFF0FF`。\n\n**步骤2：推导插入值**\n\n要插入的新值是 $v = 0xA$。这个 $4$ 位值必须在 $32$ 位字中正确定位，以便与目标字段（第 $8-11$ 位）对齐。这同样通过左移操作实现。设准备好的值为 $V_{insert}$。\n$$V_{\\text{insert}} = v \\ll i = 0xA \\ll 8$$\n十六进制常数 $0xA$ 在 $32$ 位中表示为 $0x0000000A$。\n$$V_{\\text{insert}} = 0x0000000A \\ll 8 = 0x00000A00$$\n这个值将与被清除版本的 $x$ 使用按位或运算结合。由于被清除的 $x$ 中的目标字段全为零，或运算将插入 $V_{insert}$ 的位，而不会影响任何其他位（因为对于任意位 $b$，$b \\ | \\ 0 = b$）。\n\n**完整过程**\n\n结合这两个步骤，最终值 $x_{new}$ 计算如下：\n$$x_{\\text{new}} = (x \\ \\ \\ M_{\\text{clear}}) \\ | \\ V_{\\text{insert}}$$\n代入推导出的表达式：\n$$x_{\\text{new}} = (x \\ \\ \\ (\\sim(0xF \\ll 8))) \\ | \\ (0xA \\ll 8)$$\n\n**应用于给定数据**\n\n现在我们将此过程应用于给定的初始寄存器内容 $x = 0x12345678$。\n\n首先，我们清除目标字段：\n$$x_{\\text{cleared}} = x \\ \\ \\ M_{\\text{clear}} = 0x12345678 \\ \\ \\ 0xFFFFF0FF$$\n这个操作会保留 $x$ 中所有掩码对应位为 $F$ 的十六进制数位，并将掩码对应位为 $0$ 的数位清零。掩码在对应于第 $8-11$ 位的位置上为 $0$，这与 $0x12345678$ 中的数字“$6$”对齐。\n$$x_{\\text{cleared}} = 0x12345078$$\n\n接下来，我们插入新值：\n$$x_{\\text{new}} = x_{\\text{cleared}} \\ | \\ V_{\\text{insert}} = 0x12345078 \\ | \\ 0x00000A00$$\n或运算将值 $A$ 放入从右数第三个半字节（第 $8-11$ 位），该位置之前已被清除为 $0$。\n$$x_{\\text{new}} = 0x12345A78$$\n\n最终的寄存器值为 $0x12345A78$。", "answer": "$$\\boxed{0x12345A78}$$", "id": "3647874"}]}