{"hands_on_practices": [{"introduction": "计算机科学中的一个基本问题是如何用二进制位来表示信息。这个练习将带你解决一个核心的设计挑战：确定编码一个给定的符号集所需的最小位数。通过解决这个问题 [@problem_id:3622814]，你将掌握将抽象信息需求转化为具体硬件规格的基本原则，并理解为什么像字节（8位）这样的标准单元在计算机体系结构中如此重要。", "problem": "一个计算系统必须为一个设备无关的文本和控制接口编码一个统一的符号集。该符号集由美国信息交换标准代码 (ASCII) 定义的所有字符和一个额外的设备特定控制集组成。美国信息交换标准代码 (ASCII) 定义了 $128$ 个不同的码点。设备特定控制集向此统一符号集添加了 $24$ 个新的、不同的控制符号。系统设计者规定为每个符号使用一个定长二进制码，其中每个码字恰好有 $b$ 位，并且每个符号都必须单射地映射到一个唯一的 $b$ 位字符串。\n\n从一个长度为 $b$ 的定长二进制字在两个符号 $\\{0,1\\}$ 的字母表上具有 $2^{b}$ 个不同模式的基本定义出发，推导出编码该统一符号集所需的最小整数位数 $b$。在你的推理中，论证文本编码历史上使用7位与8位的原因，并解释典型内存系统中的硬件字节对齐如何影响 $b$ 的选择。以单个整数形式提供最终答案。无需四舍五入，也不涉及物理单位。最终答案仅表示为最小位数 $b$。", "solution": "该问题要求确定唯一地编码一个统一符号集所需的最小整数位数 $b$。解决方案必须从信息论和计算机体系结构的基本原理推导出来。\n\n首先，我们必须确定需要唯一二进制表示的不同符号的总数。一个长度为 $b$ 的二进制字由一个 $b$ 位的序列组成，其中每一位可以是两个符号之一，通常是 $\\{0, 1\\}$。用 $b$ 位可以形成的不同模式或码字的总数由表达式 $2^b$ 给出。为了使定长编码有效，集合中的每个符号都必须单射地映射到一个唯一的码字。这要求可用码字的数量至少等于要编码的符号总数。如果我们用 $N$ 表示符号总数，这个条件可以正式表示为不等式：\n$$2^b \\ge N$$\n\n问题指明，统一符号集由两个子集组成：美国信息交换标准代码 (ASCII) 符号集和设备特定控制集。\n\nASCII 集合中的符号数量为 $N_{ASCII} = 128$。\n设备特定控制集中额外的、不同符号的数量为 $N_{device} = 24$。\n\n统一集合中的符号总数 $N$ 是这两个不相交集合中符号数量的总和：\n$$N = N_{ASCII} + N_{device} = 128 + 24 = 152$$\n\n现在，我们必须找到满足不等式 $2^b \\ge 152$ 的最小整数 $b$。我们可以通过测试2的连续整数次幂来解决这个问题：\n当 $b=1$ 时，$2^1 = 2$\n当 $b=2$ 时，$2^2 = 4$\n当 $b=3$ 时，$2^3 = 8$\n当 $b=4$ 时，$2^4 = 16$\n当 $b=5$ 时，$2^5 = 32$\n当 $b=6$ 时，$2^6 = 64$\n当 $b=7$ 时，$2^7 = 128$。这是不够的，因为 $128  152$。\n当 $b=8$ 时，$2^8 = 256$。这是足够的，因为 $256 \\ge 152$。\n\n使该不等式成立的最小整数值 $b$ 是 $b=8$。\n\n或者，我们可以通过对不等式 $2^b \\ge N$ 两边取以2为底的对数来求解：\n$$b \\ge \\log_2(N)$$\n将 $N=152$ 代入，我们得到：\n$$b \\ge \\log_2(152)$$\n我们知道 $\\log_2(128) = 7$ 并且 $\\log_2(256) = 8$。因为 $128  152  256$，所以 $7  \\log_2(152)  8$。由于 $b$ 必须是整数，满足此条件的最小整数值 $b$ 是 $b=8$。这等同于计算对数的向上取整：$b = \\lceil \\log_2(152) \\rceil = 8$。\n\n问题还要求论证历史上文本编码使用7位与8位的原因以及硬件字节对齐的影响。\n\n最初的 ASCII 标准使用7位，提供了 $2^7 = 128$ 个码点。这足以表示大小写英文字母、数字、标点符号和一组控制字符。在那个时代的系统中，数据通常是串行传输的，一个字节的第8位可用作错误检测的奇偶校验位，或者被简单地设置为 $0$。\n\n字符代码本身使用完整的8位，而不仅仅是7位加一个奇偶校验位的这种转变，促成了“扩展 ASCII”的出现。这种扩展提供了额外的128个码点，总计 $2^8 = 256$ 个。这些额外的码位被用来编码原始 ASCII 中不存在的符号，例如特定外语的字母（如 é, ä, ç）、货币符号和块图形字符。这种8位编码成为了主流。\n\n硬件字节对齐的影响是系统设计中的一个关键因素。现代计算机内存和处理器几乎普遍被设计为以字节为单位操作数据，其中一个字节定义为8位。内存是字节可寻址的，这意味着每个字节都有一个唯一的内存地址。数据总线被设计用于以8位的倍数传输数据。因此，使用不是8的倍数的编码长度效率极低。例如，在一个8位字节可寻址的内存中存储7位字符流，要么会每个字节浪费一位，要么需要复杂的位打包和解包操作（移位和掩码），这会产生显著的计算开销，并使硬件和软件设计复杂化。\n\n对于这个问题，所需的最小位数在数学上确定为 $8$。这与8位字节的硬件标准完全一致。即使符号集需要，例如，9位（如，如果 $N=300$），一个实际的系统设计几乎肯定会为每个符号分配16位（两个字节），以保持字节对齐以及在内存寻址和数据处理方面的相关效率。因此，选择 $b=8$ 不仅是为了容纳这152个符号在数学上的必要之举，而且从计算机体系结构的角度来看，也是最实用和高效的选择。", "answer": "$$\\boxed{8}$$", "id": "3622814"}, {"introduction": "掌握了二进制表示的基础后，下一步是学习如何巧妙地操纵这些位。本练习 [@problem_id:3622812] 将挑战你使用位运算来实现一个无分支（branchless）的绝对值函数，这在高性能计算中是一项关键技术。这个过程不仅能加深你对补码算术精妙之处的理解，还能让你领略到如何通过位操作编写出在硬件层面极为高效的算法。", "problem": "一个使用二进制补码系统和固定字长为 $w$ 位的中央处理器 (CPU) 支持按位异或 (XOR)、加法、减法和算术右移。在二进制补码中，一个 $w$ 位向量 $x = x_{w-1} x_{w-2} \\dots x_{0}$ 的数值由 $-x_{w-1} 2^{w-1} + \\sum_{i=0}^{w-2} x_i 2^i$ 给出，其中最高有效位 (MSB) $x_{w-1}$ 是符号位。算术右移会将 $x_{w-1}$ 复制到每个空出的位置。\n\n- 仅使用这些基本定义和操作，推导一个由符号位构建的掩码 $m(x)$，使得对于非负的 $x$， $m(x)$ 等于 $0$，对于负的 $x$，$m(x)$ 等于 $-1$（即，在二进制补码中所有位都设置为 $1$）。\n- 从第一性原理出发，推导一个无分支的闭式表达式，该表达式仅使用 $\\oplus$、 $+$ 或 $-$ 以及掩码 $m(x)$ 来计算绝对值 $\\mathrm{abs}(x)$；并证明为何除了可能的极值 $x = -2^{w-1}$ 外，它对所有可表示的 $x$ 都能产生正确的结果。\n- 将您推导的表达式应用于 $w=32$ 位的设置中，计算有符号整数 $x$ 的绝对值 $\\mathrm{abs}(x)$，其二进制补码表示为十六进制数 $0x\\mathrm{F0A3B7C9}$。将最终结果表示为十进制整数。无需四舍五入。", "solution": "### 解答推导\n\n**第 1 部分：掩码 $m(x)$ 的推导**\n\n问题要求一个掩码 $m(x)$，根据 $x$ 的符号选择性地等于 $0$ 或 $-1$。在所述的二进制补码系统中，整数 $x$ 的符号完全由其最高有效位 (MSB) $x_{w-1}$ 决定。\n- 如果 $x \\ge 0$，其符号位为 $x_{w-1} = 0$。\n- 如果 $x  0$，其符号位为 $x_{w-1} = 1$。\n\n我们需要 $m(x)$ 在 $x_{w-1}=0$ 时是全零的位模式（表示整数 $0$），在 $x_{w-1}=1$ 时是全一的位模式（表示整数 $-1$）。\n\n算术右移操作被定义为复制符号位。我们将算术右移 $k$ 位表示为 $\\gg_a k$。当我们对 $x$ 执行 $w-1$ 位的算术右移时，原始的 $w-1$ 个最低有效位被移出。最高有效位 (MSB) $x_{w-1}$被复制以填充所有 $w-1$ 个空出的位位置。MSB 本身保持为 $x_{w-1}$。因此，结果数的所有 $w$ 位都变得与原始符号位 $x_{w-1}$ 相等。\n\n我们来分析操作 $x \\gg_a (w-1)$ 的结果：\n- 如果 $x \\ge 0$，则 $x_{w-1} = 0$。操作 $x \\gg_a (w-1)$ 产生一个全零的 $w$ 位向量。该向量的数值为 $0$。\n- 如果 $x  0$，则 $x_{w-1} = 1$。操作 $x \\gg_a (w-1)$ 产生一个全一的 $w$ 位向量。在二进制补码中，全一的位向量表示整数 $-1$。\n\n此行为精确匹配掩码 $m(x)$ 的要求。因此，掩码可以表示为：\n$$m(x) = x \\gg_a (w-1)$$\n\n**第 2 部分：$\\mathrm{abs}(x)$ 的推导与证明**\n\n绝对值函数定义为：\n$$ \\mathrm{abs}(x) = \\begin{cases} x  \\text{if } x \\ge 0 \\\\ -x  \\text{if } x  0 \\end{cases} $$\n我们需要构建一个单一的、无分支的表达式，使用允许的操作和掩码 $m(x)$ 来实现此逻辑。在二进制补码中，数 $y$ 的相反数 $-y$ 计算为 $(\\sim y) + 1$，其中 $\\sim y$ 是 $y$ 的按位取反。按位取反操作可以使用异或实现，因为对于任何位 $b$，$b \\oplus 1 = \\sim b$。因此，对一个 $w$ 位的数 $y$ 进行按位取反等价于 $y \\oplus (-1)$，因为 $-1$ 表示为全一的位向量。所以，$-y = (y \\oplus (-1)) + 1$。\n\n我们提出以下表达式来计算 $\\mathrm{abs}(x)$：\n$$ \\mathrm{abs}(x) = (x \\oplus m(x)) - m(x) $$\n\n我们必须针对 $x$ 符号的两种情况来证明此表达式的正确性。\n\n情况 1：$x \\ge 0$。\n在这种情况下，$m(x) = 0$。将其代入表达式得：\n$$ (x \\oplus 0) - 0 $$\n异或操作 $x \\oplus 0$ 的结果为 $x$。表达式简化为 $x - 0 = x$。这对于非负数是正确的结果。\n\n情况 2：$x  0$。\n在这种情况下，$m(x) = -1$。将其代入表达式得：\n$$ (x \\oplus (-1)) - (-1) = (x \\oplus (-1)) + 1 $$\n如前所述，项 $x \\oplus (-1)$ 是 $x$ 的按位取反 (即 $\\sim x$)。因此表达式变为 $(\\sim x) + 1$，这是二进制补码求相反数的标准公式。结果是 $-x$。这对于负数是正确的绝对值。\n\n因此，公式 $\\mathrm{abs}(x)=(x \\oplus m(x)) - m(x)$ 对于所有结果可表示的值都是正确的。\n\n关于例外情况 $x = -2^{w-1}$ 的证明：\n一个 $w$ 位二进制补码系统的可表示整数范围是 $[-2^{w-1}, 2^{w-1}-1]$。对于最小值 $x = -2^{w-1}$，其数学上的绝对值是 $|-2^{w-1}| = 2^{w-1}$，这超出了可表示范围。\n我们来追踪公式对 $x = -2^{w-1}$ 的执行过程。该值由位向量 $100\\dots0$ 表示。\n由于 $x  0$，$m(x) = -1$。\n表达式计算为 $(x \\oplus (-1)) + 1$。\n- $x$ 是 $100\\dots0$。\n- $-1$ 是 $111\\dots1$。\n- $x \\oplus (-1)$ 产生 $011\\dots1$。这是 $2^{w-1}-1$ 的位表示。\n- 对此结果加 $1$：$(2^{w-1}-1) + 1 = 2^{w-1}$。然而，这是使用 $w$ 位算术执行的。\n- 加法 $(011\\dots1) + (000\\dots1)$ 的结果是 $100\\dots0$，产生的进位被丢弃。\n最终的位模式是 $100\\dots0$，它表示原始数字 $-2^{w-1}$。\n所以，对于 $x=-2^{w-1}$，表达式产生 $-2^{w-1}$，这不是数学上的绝对值。这种行为是整数溢出的结果，是固定宽度二进制补码算术固有的特性，它证实了问题中指明的限制。\n\n**第 3 部分：应用于 $w=32$ 和 $x=0x\\mathrm{F0A3B7C9}$**\n\n给定 $w=32$ 且 $x$ 的十六进制表示为 $0x\\mathrm{F0A3B7C9}$。\n\n首先，我们确定 $x$ 的符号。十六进制表示的最高有效位是 `F`，即 $1111_2$。因此，该 $32$ 位整数的最高有效位 (MSB) 是 $1$，表明 $x$ 是一个负数。\n\n由于 $x  0$，掩码 $m(x)$ 是 $-1$。对于 $w=32$ 位，$-1$ 的十六进制表示为 $0x\\mathrm{FFFFFFFF}$。\n\n我们应用推导出的绝对值公式：\n$$ \\mathrm{abs}(x) = (x \\oplus m(x)) - m(x) = (x \\oplus (-1)) + 1 $$\n\n让我们用十六进制进行运算：\n- $x = 0x\\mathrm{F0A3B7C9}$\n- $m(x) = -1 = 0x\\mathrm{FFFFFFFF}$\n\n1.  计算异或操作：$x \\oplus m(x)$。\n    $$ 0x\\mathrm{F0A3B7C9} \\oplus 0x\\mathrm{FFFFFFFF} = 0x\\mathrm{0F5C4836} $$\n    此操作等价于按位取反。\n\n2.  减去掩码：$(x \\oplus m(x)) - m(x)$。这等价于加 $1$。\n    $$ 0x\\mathrm{0F5C4836} - (0x\\mathrm{FFFFFFFF}) = 0x\\mathrm{0F5C4836} + 1 = 0x\\mathrm{0F5C4837} $$\n\n结果 $\\mathrm{abs}(x)$ 的十六进制表示为 $0x\\mathrm{0F5C4837}$。\n\n最后，我们将此十六进制结果转换为其十进制整数值：\n$$ 0x\\mathrm{0F5C4837} = (0 \\times 16^7) + (15 \\times 16^6) + (5 \\times 16^5) + (12 \\times 16^4) + (4 \\times 16^3) + (8 \\times 16^2) + (3 \\times 16^1) + (7 \\times 16^0) $$\n$$ = 15 \\times 16777216 + 5 \\times 1048576 + 12 \\times 65536 + 4 \\times 4096 + 8 \\times 256 + 3 \\times 16 + 7 \\times 1 $$\n$$ = 251658240 + 5242880 + 786432 + 16384 + 2048 + 48 + 7 $$\n$$ = 257706039 $$\n\n$\\mathrm{abs}(x)$ 的值为 $257,706,039$。", "answer": "$$ \\boxed{257706039} $$", "id": "3622812"}, {"introduction": "在计算中，乘法通常被认为是一个昂贵的操作。然而，当乘以一个常数时，我们可以利用二进制的特性将其分解为一系列更快的移位和加法操作。这个练习 [@problem_id:3622837] 将引导你探索这种高级优化技术，为常数乘法设计一个高效的实现方案。通过将一个常数分解为其有符号二进制表示，你将学会一种在编译器和定制硬件设计中用于提升性能的强大方法。", "problem": "一个处理器的数据通路仅使用移位和加/减法来实现整数常数乘法，而不使用通用乘法器。假设整数为 $32$ 位二进制补码形式，并假定运算过程中不会发生溢出。根据二进制数系的基本原理，任何非负整数常数 $C$ 都可以表示为2的幂次之和，且将一个整数 $x$ 乘以 $2$ 的幂 $2^{k}$ 等同于将 $x$ 算术左移 $k$ 个比特位。为了最小化加/减法运算的次数，可以允许使用带符号的二进制分解，其中每个数字 $d_{k}$ 属于集合 $\\{-1,0,1\\}$，因此 $C=\\sum_{k} d_{k} 2^{k}$，这种方法通过消除相邻的连续1来减少非零项的数量。\n\n仅使用关于二进制展开和左移的这些基础知识，推导出一个乘以常数 $C=2317$ 的加减移位实现，该实现应在带符号二进制分解中使用最少数量的非零2的幂次项。将您的最终实现表示为一个关于 $x$ 的单一代数表达式，该表达式是形如 $2^{k} x$ 的项的和与差。不要提取公因式 $x$ 或将表达式简化为单个常数乘以 $x$ 的形式。\n\n您的最终答案必须是一个单一的封闭形式表达式。无需四舍五入。", "solution": "为了找到使用最少加/减法运算的实现，我们需要将常数 $C=2317$ 表示为其非相邻形式（Non-Adjacent Form, NAF）。NAF 是一种带符号的二进制表示，它保证了非零项的数量最少，并且没有任何两个连续的项是非零的。这直接关系到执行乘法所需的加/减法操作的最小数量。\n\n1.  **将常数转换为二进制**\n\n    首先，我们将十进制数 $2317$ 转换为其标准的二进制表示形式。\n    $2317 = 2048 + 269 = 2048 + 256 + 13 = 2048 + 256 + 8 + 4 + 1$\n    用2的幂次表示为：\n    $C = 2^{11} + 2^8 + 2^3 + 2^2 + 2^0$\n    因此，二进制表示为 $(100100001101)_2$。此表示中有5个值为1的位。\n\n2.  **从二进制转换为非相邻形式（NAF）**\n\n    标准的 NAF 转换算法旨在消除二进制表示中所有相邻的1。我们观察到在 $C$ 的二进制表示中，比特位2和比特位3上有一串连续的1（$...11...$）。\n    这串连续的1代表 $2^3 + 2^2$。我们可以使用恒等式 $2^n + ... + 2^m = 2^{n+1} - 2^m$ 来替换它。对于 $2^3 + 2^2$ 的情况，这等价于 $2^{3+1} - 2^2 = 2^4 - 2^2$。\n    因此，我们可以将原始表达式中的 $2^3 + 2^2$ 替换为 $2^4 - 2^2$：\n    $C = 2^{11} + 2^8 + (2^4 - 2^2) + 2^0$\n    整理后得到带符号的数字表示：\n    $C = 2^{11} + 2^8 + 2^4 - 2^2 + 2^0$\n    此表示对应于 NAF $(100100010\\bar{1}01)_S$，其中 $\\bar{1}$ 代表 $-1$。此表示中没有相邻的非零项，并且非零项的数量（5个）是最小的。\n\n3.  **推导最终的代数表达式**\n\n    现在我们有了 $C$ 的最优表示，我们可以通过将每一项乘以 $x$ 来得到常数乘法 $C \\cdot x$ 的实现。根据问题要求，这应表示为 $x$ 的移位版本的和与差。\n    $2317x = (2^{11} + 2^8 + 2^4 - 2^2 + 2^0)x$\n    将 $x$ 分配到每个项中，我们得到最终的代数表达式：\n    $2^{11}x + 2^{8}x + 2^{4}x - 2^{2}x + 2^{0}x$\n    这个表达式使用了5个2的幂次项，因此需要 $5-1=4$ 次加/减运算来计算，这是最优的。每个 $2^k x$ 项都通过将 $x$ 算术左移 $k$ 位来实现。", "answer": "$$\n\\boxed{2^{11}x + 2^{8}x + 2^{4}x - 2^{2}x + 2^{0}x}\n$$", "id": "3622837"}]}