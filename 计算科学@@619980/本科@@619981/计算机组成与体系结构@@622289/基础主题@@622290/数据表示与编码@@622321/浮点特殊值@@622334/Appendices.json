{"hands_on_practices": [{"introduction": "要真正掌握浮点数的概念，我们必须超越规则的记忆，深入研究其位表示。第一个练习要求你从零开始构建一个迷你的 8 位浮点系统 [@problem_id:2395264]。通过为每个可能的位模式实现解码逻辑，你将对规格化数、非规格化数、无穷大和 NaN 的表示方式获得具体的理解。", "problem": "你需要实现一个总宽度为$8$位的二进制浮点“玩具”格式的完整枚举和解码。其布局为：$1$个符号位、$3$个指数位和$4$个分数（尾数）位。指数使用标准的偏置表示法，对于$k$个指数位，偏置$b$定义为 $b = 2^{k-1} - 1$。其解释遵循电气和电子工程师协会（IEEE）$754$标准关于规格化数、非规格化数、带符号的零、无穷大和非数值（NaN）有效载荷的约定，包括对规格化数使用等于$1$的隐含前导二进制数字，而对非规格化数则没有隐含前导数字。指数域全为1时，根据分数是否为零，分别编码无穷大和NaN。指数域全为0时，当分数非零时编码非规格化数，当分数为零时编码带符号的零。介于两者之间的指数域编码带有偏置指数的规格化数。\n\n根据这些核心定义，推导出每个$8$位模式到以下类别之一的精确解码：规格化有限数、非规格化有限数、带符号的零、无穷大或非数值。除了上述结构规则外，你不能假设任何公式；相反，应使用这些定义为每个可表示的有限编码构建精确的数值。你的实现必须是通用的、有原则的，并且不应依赖任何硬编码的答案。\n\n你的程序必须：\n- 枚举所有$256$个位模式。\n- 根据上述规则将每个模式解码为其数值，为有限编码生成实数，为无穷大和非数值生成相应的IEEE $754$特殊值。\n- 使用穷举枚举（而非分析捷径）来计算所需的量。\n\n使用以下测试套件，它探测了该格式的不同方面（覆盖范围包括正常路径、边缘情况和边界条件）。对于所描述的$8$位格式，按规定顺序生成以下结果：\n\n1. 有限编码的总数（包括$+0$和$-0$），以整数形式表示。\n2. 非数值（Not a Number）编码的总数，以整数形式表示。\n3. 无穷大编码的总数，以整数形式表示。\n4. 最小的严格正非规格化值，以实数形式表示。\n5. 最小的严格正规格化值，以实数形式表示。\n6. 最大有限值，以实数形式表示。\n7. 1.0之上的间距，定义为$1.0$与下一个更大的可表示正有限数之间的差值，以实数形式表示。\n8. 1.0之下的间距，定义为$1.0$与下一个更小的可表示正有限数之间的差值，以实数形式表示。\n9. 位模式$0\\mathrm{b}00110000$的解码值（以实数形式表示）。\n10. 位模式$0\\mathrm{b}11101111$的解码值（以实数形式表示）。\n11. 位模式$0\\mathrm{b}00000001$的解码值（以实数形式表示）。\n12. 一个布尔值，指示严格正有限值集合（不包括$0$）在排序后是否严格递增，并且是否具有给定格式的预期基数。\n\n角度单位不适用。没有物理单位；所有数值都是无量纲的。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，结果严格按照上面列出的顺序排列。例如，一个包含三个结果的输出应如下所示：$[r_1,r_2,r_3]$。\n\n约束和注意事项：\n- 将带符号的零视为有限编码。\n- 对于规格化数，有效数的前导二进制数字隐含为$1$；对于非规格化数，没有隐含的前导数字。\n- 指数偏置必须根据上述定义从基本原理计算得出，而不是未经证明就硬编码为字面值。\n- 不需要任何用户输入。程序必须按原样运行，并严格按照指定格式打印一行。[@problem_id:154]", "solution": "问题陈述是一个关于浮点数表示原理的有效、定义明确的计算物理学练习。它提供了一套完整且一致的规则，用于基于IEEE 754标准定义一个“玩具”$8$位浮点格式。我们将从基本原理出发，推导其属性并解码数值。\n\n该格式由总宽度$N=8$位定义，由$N_s=1$个符号位（$s$）、$k=3$个指数位（$E$）和$m=4$个分数位（$F$）组成。位模式为$s E_{k-1}...E_0 F_{m-1}...F_0$。\n\n首先，我们确定指数偏置$b$。提供的公式是$b = 2^{k-1} - 1$。对于$k=3$个指数位，偏置为：\n$$\nb = 2^{3-1} - 1 = 2^2 - 1 = 4 - 1 = 3\n$$\n我们记指数域的整数值为$E_{val}$，其范围从$0$到$2^k-1=7$。分数字段的整数值为$F_{val}$，其范围从$0$到$2^m-1=15$。一个表示的数值$v$由符号位$s$、$E_{val}$和$F_{val}$根据以下情况确定。\n\n一个$8$位整数$I \\in [0, 255]$被解析为其组成部分：\n- 符号位：$s = \\lfloor I / 2^{k+m} \\rfloor = \\lfloor I / 128 \\rfloor$。符号乘数为$(-1)^s$。\n- 指数字段值：$E_{val} = \\lfloor (I \\pmod{128}) / 16 \\rfloor$。\n- 分数字段值：$F_{val} = I \\pmod{16}$。\n\n解码规则如下：\n\n情况1：特殊值（$E_{val} = 2^k - 1 = 7$）\n如果指数域全为1，则表示无穷大或非数值（NaN）。\n- 如果$F_{val} = 0$，值为带符号的无穷大：$v = (-1)^s \\infty$。这提供了两种表示：$+\\infty$（$I=0\\text{b}01110000$）和$-\\infty$（$I=0\\text{b}11110000$）。\n- 如果$F_{val} \\neq 0$，值为NaN。有$2 \\times (2^m - 1) = 2 \\times 15 = 30$种这样的NaN表示。\n\n情况2：非规格化数和零（$E_{val} = 0$）\n如果指数域全为0，则数值为非规格化数（denormalized）或零。\n- 有效指数固定为$e = 1 - b = 1 - 3 = -2$。\n- 有效数$M$没有隐含的前导$1$，由$M = F_{val} / 2^m = F_{val} / 16$给出。\n- 如果$F_{val} = 0$，则$M=0$，值为带符号的零：$v = (-1)^s \\times 0$。这提供了$+0$（$I=0\\text{b}00000000$）和$-0$（$I=0\\text{b}10000000$）。\n- 如果$F_{val} \\neq 0$，值为非规格化数：$v = (-1)^s \\times M \\times 2^e = (-1)^s \\times (F_{val} / 16) \\times 2^{-2}$。有$2 \\times (2^m-1) = 30$种这样的表示。\n\n情况3：规格化数（$1 \\le E_{val} \\le 6$）\n如果指数域不全为0也不全为1，则数值为规格化数。\n- 有效指数为$e = E_{val} - b = E_{val} - 3$。\n- 有效数$M$有一个隐含的前导$1$：$M = 1 + F_{val} / 2^m = 1 + F_{val} / 16$。\n- 值为$v = (-1)^s \\times M \\times 2^e = (-1)^s \\times (1 + F_{val}/16) \\times 2^{E_{val}-3}$。有$2 \\times (2^k-2) \\times 2^m = 2 \\times 6 \\times 16 = 192$种这样的表示。\n\n基于此框架，我们现在可以穷举枚举所有$256$个位模式并计算所需的量。\n\n1.  有限编码的总数：这包括带符号的零、非规格化数和规格化数。\n    - 零：$2$种表示（$+0, -0$）。\n    - 非规格化数：$2 \\times (2^m-1) = 2 \\times (16-1) = 30$。\n    - 规格化数：$2 \\times (2^k-2) \\times 2^m = 2 \\times (8-2) \\times 16 = 2 \\times 6 \\times 16 = 192$。\n    - 有限编码总数 = $2 + 30 + 192 = 224$。\n\n2.  非数值（Not a Number）编码的总数：\n    - 条件：$E_{val}=7$, $F_{val} \\neq 0$。这适用于两种符号。\n    - NaN总数 = $2 \\times (2^m-1) = 2 \\times 15 = 30$。\n\n3.  无穷大编码的总数：\n    - 条件：$E_{val}=7$, $F_{val} = 0$。这适用于两种符号。\n    - 无穷大总数 = $2$。\n\n4.  最小的严格正非规格化值：\n    - 这要求$s=0$, $E_{val}=0$和最小的非零$F_{val}$，即$F_{val}=1$。\n    - $v = (+1) \\times (1 / 2^4) \\times 2^{1-b} = (1/16) \\times 2^{-2} = 1/64 = 0.015625$。\n\n5.  最小的严格正规格化值：\n    - 这要求$s=0$，最小的规格化指数$E_{val}=1$，以及最小的分数$F_{val}=0$。\n    - $e = E_{val} - b = 1 - 3 = -2$。\n    - $M = 1 + 0/16 = 1$。\n    - $v = (+1) \\times 1 \\times 2^{-2} = 1/4 = 0.25$。\n\n6.  最大有限值：\n    - 这要求$s=0$，最大的规格化指数$E_{val}=6$，以及最大的分数$F_{val}=15$。\n    - $e = E_{val} - b = 6 - 3 = 3$。\n    - $M = 1 + 15/16 = 31/16$。\n    - $v = (+1) \\times (31/16) \\times 2^3 = (31/16) \\times 8 = 31/2 = 15.5$。\n\n7.  1.0之上的间距：\n    - 首先，我们表示$1.0$。我们需要$v=1.0 = 1.0 \\times 2^0$。这意味着$e=0$和$M=1.0$。\n    - $e = E_{val} - b = 0 \\implies E_{val} = b = 3$。\n    - $M = 1 + F_{val}/16 = 1 \\implies F_{val}=0$。\n    - 所以，$1.0$由$s=0, E_{val}=3, F_{val}=0$表示。\n    - 下一个更大的可表示值具有相同的符号和指数，但$F_{val}$增加到$1$。\n    - $v_{next} = (+1) \\times (1 + 1/16) \\times 2^{3-3} = 17/16 = 1.0625$。\n    - 间距为$v_{next} - 1.0 = 1.0625 - 1.0 = 0.0625$。\n\n8.  1.0之下的间距：\n    - 恰好在$1.0$之下的值对应于$1.0$位模式之前的那个位模式。\n    - 1.0的模式是$0 \\ 011 \\ 0000$。它前面的一个是$0 \\ 010 \\ 1111$。\n    - 解码$s=0, E_{val}=2, F_{val}=15$：\n    - $e = E_{val} - b = 2 - 3 = -1$。\n    - $M = 1 + 15/16 = 31/16$。\n    - $v_{prev} = (+1) \\times (31/16) \\times 2^{-1} = 31/32 = 0.96875$。\n    - 间距为$1.0 - v_{prev} = 1.0 - 0.96875 = 0.03125$。\n\n9.  位模式$0\\mathrm{b}00110000$的解码值：\n    - 这是模式$s=0, E_{val}=3, F_{val}=0$，如上所述，它表示$1.0$。\n\n10. 位模式$0\\mathrm{b}11101111$的解码值：\n    - $s=1$（负）。\n    - $E_{val} = 110_2 = 6$。这是一个规格化数。$e = 6 - 3 = 3$。\n    - $F_{val} = 1111_2 = 15$。\n    - $M = 1 + 15/16 = 31/16$。\n    - $v = (-1) \\times (31/16) \\times 2^3 = -15.5$。这是最大有限值的负值。\n\n11. 位模式$0\\mathrm{b}00000001$的解码值：\n    - $s=0$（正）。\n    - $E_{val} = 0$。这是一个非规格化数。$e = 1 - b = -2$。\n    - $F_{val} = 1$。\n    - $M = 1/16$。\n    - $v = (+1) \\times (1/16) \\times 2^{-2} = 1/64 = 0.015625$。这是最小的正非规格化值。\n\n12. 关于严格正有限值集合属性的布尔值：\n    - 该集合包含所有正的非规格化数和规格化数。\n    - 正非规格化数数量：$2^m-1 = 15$。\n    - 正规格化数数量：$(2^k-2) \\times 2^m = 6 \\times 16 = 96$。\n    - 期望的基数是$15 + 96 = 111$。\n    - 这些值的构造方式使其唯一且严格递增。对于任何指数，增加分数位都会增加值。指数范围$e$的最大值严格小于指数范围$e+1$的最小值。\n    - 最大非规格化数：$(2^m-1)/2^m \\times 2^{1-b} = (15/16) \\times 2^{-2} = 15/64$。\n    - 最小规格化数：$1 \\times 2^{1-b} = 1 \\times 2^{-2} = 1/4 = 16/64$。\n    - 由于$15/64  16/64$，没有重叠。这对所有指数转换都成立。因此，该集合是严格递增的，并具有预期的基数。结果为真。\n\n实现将通过穷举枚举来证实这些推导。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Enumerates and decodes an 8-bit toy floating-point format to answer specific questions.\n    \"\"\"\n    N_BITS = 8\n    K_BITS = 3  # exponent bits\n    M_BITS = 4  # fraction bits\n\n    # Calculate exponent bias from first principles as required.\n    # b = 2^(k-1) - 1\n    bias = 2**(K_BITS - 1) - 1\n\n    e_max = (1  K_BITS) - 1\n    f_mask = (1  M_BITS) - 1\n\n    finite_vals = []\n    infinities = []\n    nans = []\n    positive_finite_vals = []\n    \n    # A helper function to decode a single integer representation\n    def decode_integer(i):\n        s_val = i >> (K_BITS + M_BITS)\n        e_val = (i >> M_BITS)  e_max\n        f_val = i  f_mask\n\n        sign = (-1)**s_val\n\n        # Case 1: Exponent is all ones (special values)\n        if e_val == e_max:\n            if f_val == 0:\n                # Infinity\n                return (sign * np.inf, \"inf\")\n            else:\n                # Not a Number (NaN)\n                return (np.nan, \"nan\")\n\n        # Case 2: Exponent is all zeros (subnormals and zero)\n        elif e_val == 0:\n            exponent = 1 - bias\n            # Significand has no implicit leading 1\n            significand = f_val / (2**M_BITS)\n            val = sign * significand * (2**exponent)\n            if f_val == 0:\n                return (val, \"zero\")\n            else:\n                return (val, \"subnormal\")\n\n        # Case 3: Normalized numbers\n        else:\n            exponent = e_val - bias\n            # Significand has an implicit leading 1\n            significand = 1 + f_val / (2**M_BITS)\n            val = sign * significand * (2**exponent)\n            return (val, \"normal\")\n\n    # Enumerate all 2^8 = 256 patterns\n    for i in range(1  N_BITS):\n        value, category = decode_integer(i)\n        \n        if category in [\"zero\", \"subnormal\", \"normal\"]:\n            finite_vals.append(value)\n            if value >= 0: # Includes +0.0\n                # The question is about *strictly* positive set, so filter 0 later.\n                positive_finite_vals.append(value)\n        elif category == \"inf\":\n            infinities.append(value)\n        elif category == \"nan\":\n            nans.append(value)\n\n    # 1. Total count of finite encodings (zeros, subnormals, normalized)\n    res1_finite_count = len(finite_vals)\n\n    # 2. Total count of Not a Number encodings\n    res2_nan_count = len(nans)\n\n    # 3. Total count of infinity encodings\n    res3_inf_count = len(infinities)\n    \n    # Filter out zero for strictly positive set\n    strictly_positive_finite_vals = sorted([v for v in positive_finite_vals if v > 0])\n\n    # 4. Smallest strictly positive subnormal value\n    subnormals = [v for v in finite_vals if v > 0 and abs(v)  (2**(1-bias))]\n    res4_min_pos_subnormal = min(subnormals) if subnormals else 0\n\n    # 5. Smallest strictly positive normalized value\n    normals = [v for v in finite_vals if v > 0 and abs(v) >= (2**(1-bias))]\n    res5_min_pos_normalized = min(normals) if normals else 0\n\n    # 6. Largest finite value\n    res6_max_finite = max(finite_vals)\n\n    # 7. Spacing above 1.0\n    # 8. Spacing below 1.0\n    try:\n        idx_1 = strictly_positive_finite_vals.index(1.0)\n        res7_spacing_above_1 = strictly_positive_finite_vals[idx_1 + 1] - 1.0\n        res8_spacing_below_1 = 1.0 - strictly_positive_finite_vals[idx_1 - 1]\n    except (ValueError, IndexError):\n        res7_spacing_above_1 = np.nan\n        res8_spacing_below_1 = np.nan\n\n    # 9. Decoded value for 0b00110000\n    res9_decode_1 = decode_integer(0b00110000)[0]\n\n    # 10. Decoded value for 0b11101111\n    res10_decode_2 = decode_integer(0b11101111)[0]\n    \n    # 11. Decoded value for 0b00000001\n    res11_decode_3 = decode_integer(0b00000001)[0]\n\n    # 12. Boolean property of the strictly positive finite value set\n    expected_cardinality = ((1  K_BITS) - 2) * (1  M_BITS) + ((1  M_BITS) - 1)\n    cardinality_ok = len(strictly_positive_finite_vals) == expected_cardinality\n    strictly_increasing = all(\n        strictly_positive_finite_vals[i]  strictly_positive_finite_vals[i+1]\n        for i in range(len(strictly_positive_finite_vals) - 1)\n    )\n    res12_set_property = cardinality_ok and strictly_increasing\n    \n    results = [\n        res1_finite_count,\n        res2_nan_count,\n        res3_inf_count,\n        res4_min_pos_subnormal,\n        res5_min_pos_normalized,\n        res6_max_finite,\n        res7_spacing_above_1,\n        res8_spacing_below_1,\n        res9_decode_1,\n        res10_decode_2,\n        res11_decode_3,\n        res12_set_property\n    ]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2395264"}, {"introduction": "既然我们已经了解了特殊值的表示方式，接下来让我们探究它们在计算中的行为。这个练习让你扮演硬件验证工程师的角色，预测涉及无穷大和零的算术运算（例如 $\\infty - \\infty$）的结果 [@problem_id:3641973]。掌握这一点对于编写能够正确处理异常情况的稳健数值代码至关重要。", "problem": "一个处理器核心实现了电气和电子工程师协会（IEEE）754浮点算术标准，采用binary32格式，默认舍入模式为“向最近舍入，偶数优先”(round-to-nearest, ties-to-even)。该架构公开了五个标准的浮点异常标志：无效操作、除以零、上溢、下溢和不精确。根据 IEEE 754 语义，特殊值包括 $+\\infty$、$-\\infty$、$+0$、$-0$ 和非数值 (NaN)。当运算在数学上有意义时，其定义基于扩展实数算术；否则，将发出无效操作信号并返回一个静默 NaN。\n\n你的任务是构建一个最小化的测试平台，以验证按顺序执行的以下四个操作的特殊情况处理：\n1. $+\\infty + +\\infty$,\n2. $+\\infty - +\\infty$,\n3. $+\\infty \\times 0$,\n4. $0 / 0$.\n\n假设所有输入都是非信令的（即，没有一个是信令 NaN），因此这些操作产生的任何 NaN 都是静默 NaN。对于每个操作，请仅根据 IEEE 754 的核心定义和关于特殊值的经过充分测试的事实，确定预期的结果类别（$+\\infty$、有限值或静默 NaN 之一）以及触发的异常标志集。\n\n为了使测试平台能够自检查，请将第 $i$ 个操作的异常标志编码为一个五位向量，固定顺序为：无效、除以零、上溢、下溢、不精确。位值为 $1$ 表示“标志触发”，$0$ 表示“标志不触发”。将该向量映射为一个整数\n$$c_i \\;=\\; 16 \\cdot I_i \\;+\\; 8 \\cdot D_i \\;+\\; 4 \\cdot O_i \\;+\\; 2 \\cdot U_i \\;+\\; 1 \\cdot X_i,$$\n其中 $I_i$、$D_i$、$O_i$、$U_i$ 和 $X_i$ 分别是操作 $i$ 的无效、除以零、上溢、下溢和不精确标志的位值。最后，计算聚合校验和\n$$S \\;=\\; c_1 \\;+\\; 3\\,c_2 \\;+\\; 9\\,c_3 \\;+\\; 27\\,c_4.$$\n\n请提供每个操作的预期结果类别和标志，然后计算单个实数值 $S$。$S$ 的最终值无需舍入。", "solution": "该问题要求分析由电气和电子工程师协会（IEEE）754标准定义的涉及特殊值（$+\\infty$、$0$）的四个特定浮点运算。对于每个操作，我们必须确定其结果值的类别以及五个标准异常标志的状态。这些标志是无效操作 ($I$)、除以零 ($D$)、上溢 ($O$)、下溢 ($U$) 和不精确 ($X$)。然后，使用这些标志为每个操作 $i$ 计算一个整数代码 $c_i$，并最终计算出聚合校验和 $S$。\n\n该问题定义明确，并基于 IEEE 754 标准的既定原则，该标准是计算机组成和体系结构的基石。所有必要信息均已提供，目标明确。我们接下来对每个操作进行分析。\n\n**操作 1: $+\\infty + +\\infty$**\n\n根据 IEEE 754 标准，两个同符号无穷大的和等于该无穷大。\n- **结果类别**：结果为 $+\\infty$。\n- **异常标志**：\n    - 无效操作 ($I_1$)：此操作在扩展实数算术中是有效且明确定义的。不引发此标志。$I_1 = 0$。\n    - 除以零 ($D_1$)：这不是一个除法操作。不引发此标志。$D_1 = 0$。\n    - 上溢 ($O_1$)：当操作数包含无穷大且产生无穷大结果时，该操作被认为是精确的，不会导致上溢。不引发此标志。$O_1 = 0$。\n    - 下溢 ($U_1$)：结果不是一个微小的非规格化数。不引发此标志。$U_1 = 0$。\n    - 不精确 ($X_1$)：结果 $+\\infty$ 是一个精确表示。不引发此标志。$X_1 = 0$。\n\n标志向量为 $(0, 0, 0, 0, 0)$。整数代码 $c_1$ 计算如下：\n$$c_1 = 16 \\cdot I_1 + 8 \\cdot D_1 + 4 \\cdot O_1 + 2 \\cdot U_1 + 1 \\cdot X_1 = 16 \\cdot 0 + 8 \\cdot 0 + 4 \\cdot 0 + 2 \\cdot 0 + 1 \\cdot 0 = 0$$\n\n**操作 2: $+\\infty - +\\infty$**\n\n此操作等价于 $+\\infty + (-\\infty)$。这是一个不定式。\n- **结果类别**：IEEE 754 标准定义，两个同符号无穷大的减法是无效操作。结果是一个静默非数值 (qNaN)。\n- **异常标志**：\n    - 无效操作 ($I_2$)：此操作被明确定义为无效。引发此标志。$I_2 = 1$。\n    - 除以零 ($D_2$)：不是除法。$D_2 = 0$。\n    - 上溢 ($O_2$)：无上溢。$O_2 = 0$。\n    - 下溢 ($U_2$)：无下溢。$U_2 = 0$。\n    - 不精确 ($X_2$)：无效操作异常具有优先权，在这种情况下通常不会设置其他标志。该操作不涉及传统意义上的舍入。不引发此标志。$X_2 = 0$。\n\n标志向量为 $(1, 0, 0, 0, 0)$。整数代码 $c_2$ 为：\n$$c_2 = 16 \\cdot 1 + 8 \\cdot 0 + 4 \\cdot 0 + 2 \\cdot 0 + 1 \\cdot 0 = 16$$\n\n**操作 3: $+\\infty \\times 0$**\n\n这是一个不定式。标准为此情况提供了特定的结果。\n- **结果类别**：无穷大与零的乘法是无效操作。结果是一个静默 NaN。我们假设操作数‘0’指的是 $+0$，但对于 $-0$ 结果也是相同的。\n- **异常标志**：\n    - 无效操作 ($I_3$)：此操作被定义为无效。引发此标志。$I_3 = 1$。\n    - 除以零 ($D_3$)：不是除法。$D_3 = 0$。\n    - 上溢 ($O_3$)：无上溢。$O_3 = 0$。\n    - 下溢 ($U_3$)：无下溢。$U_3 = 0$。\n    - 不精确 ($X_3$)：无效操作标志被引发，具有优先权。不引发此标志。$X_3 = 0$。\n\n标志向量为 $(1, 0, 0, 0, 0)$。整数代码 $c_3$ 为：\n$$c_3 = 16 \\cdot 1 + 8 \\cdot 0 + 4 \\cdot 0 + 2 \\cdot 0 + 1 \\cdot 0 = 16$$\n\n**操作 4: $0 / 0$**\n\n这是典型的未定式。\n- **结果类别**：零除以零是无效操作。结果是一个静默 NaN。\n- **异常标志**：\n    - 无效操作 ($I_4$)：此操作被定义为无效。引发此标志。$I_4 = 1$。\n    - 除以零 ($D_4$)：除以零标志专门用于有限非零数除以零的情况。对于 $0/0$，会引发无效操作异常。$D_4 = 0$。\n    - 上溢 ($O_4$)：无上溢。$O_4 = 0$。\n    - 下溢 ($U_4$)：无下溢。$U_4 = 0$。\n    - 不精确 ($X_4$)：无效操作标志被引发，具有优先权。不引发此标志。$X_4 = 0$。\n\n标志向量为 $(1, 0, 0, 0, 0)$。整数代码 $c_4$ 为：\n$$c_4 = 16 \\cdot 1 + 8 \\cdot 0 + 4 \\cdot 0 + 2 \\cdot 0 + 1 \\cdot 0 = 16$$\n\n**聚合校验和计算**\n\n现在我们使用提供的公式和计算出的 $c_1, c_2, c_3, c_4$ 值来计算最终的校验和 $S$。\n$$S = c_1 + 3\\,c_2 + 9\\,c_3 + 27\\,c_4$$\n代入数值：\n$$S = 0 + 3 \\cdot 16 + 9 \\cdot 16 + 27 \\cdot 16$$\n我们可以提取公因数 $16$：\n$$S = (0 + 3 + 9 + 27) \\cdot 16$$\n$$S = 39 \\cdot 16$$\n$$S = 624$$", "answer": "$$\\boxed{624}$$", "id": "3641973"}, {"introduction": "算术运算只是故事的一半；程序的逻辑通常依赖于数值比较。最后的这个练习将深入探讨涉及特殊值的浮点数比较的独特规则 [@problem_id:3642868]。你将探索当存在 NaN 时“无序”结果的关键概念，并验证涉及有符号零和无穷大的比较行为。", "problem": "一个处理器实现了一个符合电气和电子工程师协会 (IEEE) $754$ 标准的浮点单元 (FPU) 比较器，该比较器接收二进制 $64$ 位格式的操作数 $x$ 和 $y$，并产生五个布尔输出：$l$ (表示 $x  y$)、$e$ (表示 $x = y$)、$g$ (表示 $x > y$)、$u$ (表示无序)，和 $I$ (表示无效操作异常)。对于以下六个测试用例，请从给出的选项中选择正确的结果集。\n\n- 用例 $\\mathrm{C1}$: $x=\\mathrm{qNaN}$, $y=1.0$\n- 用例 $\\mathrm{C2}$: $x=\\mathrm{sNaN}$, $y=-2.0$\n- 用例 $\\mathrm{C3}$: $x=+0.0$, $y=-0.0$\n- 用例 $\\mathrm{C4}$: $x=-\\infty$, $y=-\\infty$\n- 用例 $\\mathrm{C5}$: $x=-\\infty$, $y=+\\infty$\n- 用例 $\\mathrm{C6}$: $x=1.0$, $y=\\mathrm{qNaN}$", "solution": "根据 IEEE $754$ 标准的比较规则，我们可以确定每个测试用例的预期输出。输出是一个元组 $(l, e, g, u, I)$，其中：\n- $l$: $x  y$ (小于)\n- $e$: $x = y$ (等于)\n- $g$: $x > y$ (大于)\n- $u$: 无序 (至少一个操作数是 NaN)\n- $I$: 无效操作异常 (为 sNaN 发出信号)\n\n对每个用例进行分析：\n\n- **用例 $\\mathrm{C1}$**: 由于一个操作数 ($x$) 是 NaN，比较是无序的。这意味着 $l, e, g$ 都为假 ($0$)，而 $u$ 为真 ($1$)。由于 $x$ 是一个静默 NaN (qNaN)，不会引发无效操作异常，所以 $I$ 为假 ($0$)。预期输出：$(0,0,0,1,0)$。\n\n- **用例 $\\mathrm{C2}$**: 与 C1 类似，由于一个操作数是 NaN，比较是无序的。所以，$l=0, e=0, g=0, u=1$。然而，由于 $x$ 是一个信号 NaN (sNaN)，必须引发无效操作异常。因此，$I$ 为真 ($1$)。预期输出：$(0,0,0,1,1)$。\n\n- **用例 $\\mathrm{C3}$**: 根据 IEEE $754$ 标准，正零和负零在比较中被认为是相等的。因此，“等于”谓词 $e$ 为真 ($1$)，而 $l, g$ 为假 ($0$)。比较是有序的，所以 $u$ 为假 ($0$)。不引发异常。预期输出：$(0,1,0,0,0)$。\n\n- **用例 $\\mathrm{C4}$**: 负无穷大等于其自身。这是一个有序比较。所以，$e=1$，而 $l, g, u$ 均为 $0$。无异常。预期输出：$(0,1,0,0,0)$。\n\n- **用例 $\\mathrm{C5}$**: 负无穷大 小于 正无穷大。这是一个有序比较。因此，“小于”谓词 $l$ 为真 ($1$)，而 $e, g, u$ 为假 ($0$)。无异常。预期输出：$(1,0,0,0,0)$。\n\n- **用例 $\\mathrm{C6}$**: 这与 C1 对称。一个操作数 ($y$) 是 qNaN，所以比较是无序的 ($u=1$)，并且有序谓词为假 ($l=0, e=0, g=0$)。对于 qNaN 不引发异常 ($I=0$)。预期输出：$(0,0,0,1,0)$。\n\n将这些结果与给定选项进行比较：\n- 选项 A：\n  - $\\mathrm{C1}$: $(0,0,0,1,0)$ (匹配)\n  - $\\mathrm{C2}$: $(0,0,0,1,1)$ (匹配)\n  - $\\mathrm{C3}$: $(0,1,0,0,0)$ (匹配)\n  - $\\mathrm{C4}$: $(0,1,0,0,0)$ (匹配)\n  - $\\mathrm{C5}$: $(1,0,0,0,0)$ (匹配)\n  - $\\mathrm{C6}$: $(0,0,0,1,0)$ (匹配)\n\n- 选项 B 在 C1 和 C6 上是错误的 (它为 qNaN 引发了异常)。\n- 选项 C 在 C3 上是错误的 (它声称 $+0.0  -0.0$ 而不是相等)。\n- 选项 D 在多个用例上都是错误的。\n\n因此，选项 A 是唯一与所有 IEEE $754$ 规则完全匹配的选项。", "answer": "$$\\boxed{A}$$", "id": "3642868"}]}