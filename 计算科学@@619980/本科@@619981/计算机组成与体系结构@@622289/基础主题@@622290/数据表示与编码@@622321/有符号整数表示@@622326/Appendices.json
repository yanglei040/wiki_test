{"hands_on_practices": [{"introduction": "在计算机中，一串相同的二进制比特模式（如 $100...0$）在不同的有符号数表示法下可能代表完全不同的数值。这个练习将帮助你深入理解符号-数值（sign-magnitude）表示法和二进制补码（two's complement）这两种关键方案之间的根本区别。通过分析这个特定的边界情况，你将亲自探索“负零”的概念，并理解二进制补码如何巧妙地利用所有比特模式来表示一个非对称但连续的整数范围 [@problem_id:3676847]。", "problem": "设 $n \\geq 3$ 为一个表示字长的正整数。考虑一个 $n$ 位模式 $p$，其最高有效位 (MSB) 为 $1$，其余 $n-1$ 位均为 $0$，即 $p = 1\\underbrace{00\\cdots0}_{n-1 \\text{ 个 } 0}$。在符号-数值表示法下，采用一个约定，即“有效的负数”要求符号位为 $1$ 且数值域为一个严格为正的二进制整数；符号位为 $1$ 且数值域全为零的码字是所谓的“负零”，其数值上等于 $0$，但在此约定下不被视为有效的负数。首先，在符号-数值表示法下，判断 $p$ 是否为一个有效的负数，并确定它所表示的整数。接着，在不改变位的情况下，根据补码表示法（Two's Complement，简称 TC，以计算机算术中使用的标准方式解释）来解释相同的固定位模式 $p$。计算通过此补码重新解释所获得的带符号整数值，作为 $n$ 的函数。仅报告此值的封闭形式表达式。无需舍入，也不涉及单位。", "solution": "该问题被认为是有效的，因为它科学地基于计算机算术的原理，定义明确无歧义，且语言客观。它提出了一个比较带符号数表示法的标准练习。\n\n问题定义了一个 $n$ 位模式 $p$，其中 $n \\geq 3$。此模式的最高有效位 (MSB) 为 $1$，所有其他 $n-1$ 位均为 $0$。用符号表示可写为 $p = 1\\underbrace{00\\cdots0}_{n-1}$。我们需要用两种不同的带符号整数表示法来分析这个模式：符号-数值表示法和补码表示法。\n\n首先，我们用符号-数值表示法来分析模式 $p$。在这种表示法中，MSB 作为符号位，其中 $1$ 表示负数，$0$ 表示正数。剩下的 $n-1$ 位表示数的量值。\n对于模式 $p = 100\\cdots0$：\n- 符号位是 $b_{n-1} = 1$，表示该数为负。\n- 量值由剩下的 $n-1$ 位给出，这些位全为 $0$。一个全零二进制串的整数值为 $0$。\n因此，在符号-数值表示法中，$p$ 所表示的数是 $-(0)$，等于 $0$。这个特定的表示 $100\\cdots0$ 通常被称为“负零”。\n\n问题对“有效的负数”施加了一个特定约定：符号位必须是 $1$，且数值域必须表示一个严格为正的二进制整数。在我们的情况下，量值为 $0$，不是严格为正。因此，根据此约定，模式 $p$ 表示整数 $0$，但不符合“有效的负数”的条件。\n\n接下来，我们用补码 (TC) 表示法来解释相同的 $n$ 位模式 $p = 100\\cdots0$。一个 $n$ 位二进制数 $b_{n-1}b_{n-2}\\cdots b_1b_0$ 在补码系统中的值使用以下公式计算：\n$$V = -b_{n-1} \\cdot 2^{n-1} + \\sum_{i=0}^{n-2} b_i \\cdot 2^i$$\n对于模式 $p$，其各位为：\n- $b_{n-1} = 1$ (最高有效位)\n- 对于所有从 $0$ 到 $n-2$ 的 $i$，$b_i = 0$。\n\n将这些位值代入公式：\n求和项变为：\n$$\\sum_{i=0}^{n-2} b_i \\cdot 2^i = \\sum_{i=0}^{n-2} 0 \\cdot 2^i = 0$$\n最高有效位的项是：\n$$-b_{n-1} \\cdot 2^{n-1} = -1 \\cdot 2^{n-1} = -2^{n-1}$$\n结合这些结果，模式 $p$ 在补码中的总值 $V$ 为：\n$$V = -2^{n-1} + 0 = -2^{n-1}$$\n这个值 $-2^{n-1}$ 表示在补码系统中可以用 $n$ 位表示的最小负整数。问题要求将此值表示为 $n$ 的函数的封闭形式表达式。\n\n当用补码表示法解释时，位模式 $p$ 的值的最终表达式是 $-2^{n-1}$。", "answer": "$$\\boxed{-2^{n-1}}$$", "id": "3676847"}, {"introduction": "二进制补码算术中的“环绕”（wrap-around）现象——例如，最大正数加一会变成最小负数——并非一个随意的硬件怪癖，而是根植于模算术的坚实数学原理。本练习引导你使用模 $2^n$ 整数环 $\\mathbb{Z}_{2^{n}}$ 的形式化定义，来推导和验证这些边界条件下的算术行为。通过这个实践，你将从“位操作技巧”的层面，上升到对计算机算术背后优雅数学结构的深刻理解 [@problem_id:3676829]。", "problem": "一个算术逻辑单元 (ALU) 使用二进制补码表示法对 $n$ 位字执行加法和减法运算，其回绕语义与整数模 $2^{n}$ 的环（记为 $\\mathbb{Z}_{2^{n}}$）中的算术运算相同。对于一个固定的整数 $n \\ge 2$，定义位模式（视为 $\\{0,1,\\ldots,2^{n}-1\\} \\subset \\mathbb{Z}_{2^{n}}$ 的元素）与有符号整数之间的两个映射：\n- 编码映射 $E:\\mathbb{Z}\\to\\{0,1,\\ldots,2^{n}-1\\}$，其中 $E(y)$ 等于 $y$ 模 $2^{n}$ 的剩余类，并解释为其在 $\\{0,1,\\ldots,2^{n}-1\\}$ 中的标准代表元。\n- 解码映射 $D:\\{0,1,\\ldots,2^{n}-1\\}\\to\\mathbb{Z}$ 定义为\n$$\nD(x)=\n\\begin{cases}\nx,  0 \\le x \\le 2^{n-1}-1,\\\\\nx-2^{n},  2^{n-1} \\le x \\le 2^{n}-1.\n\\end{cases}\n$$\nALU 的操作语义等同于在 $\\mathbb{Z}_{2^{n}}$ 中对编码值执行加法或减法，然后通过 $D(\\cdot)$ 解码结果。\n\n仅从这些定义以及 $\\mathbb{Z}_{2^{n}}$ 的环性质出发，考虑以下两个边界操作：\n1. 计算 $A$：取可表示的最大非负有符号整数 $2^{n-1}-1$，在 $\\mathbb{Z}_{2^{n}}$ 中加 $1$，然后解码：$A := D\\!\\left(\\left(2^{n-1}-1 + 1\\right) \\bmod 2^{n}\\right)$。\n2. 计算 $B$：取可表示的最小负有符号整数 $-2^{n-1}$，使用 ALU 的减法（即在 $\\mathbb{Z}_{2^{n}}$ 中对编码值进行减法）减去 $1$，然后解码：$B := D\\!\\left(\\left(E(-2^{n-1}) - 1\\right) \\bmod 2^{n}\\right)$。\n\n从基本原理出发，推导\n$$\nS(n) = A + B,\n$$\n的封闭形式的值，结果为一个实整数。请以单个简化数字或封闭形式表达式给出最终答案。无需四舍五入，最终答案中不应包含任何单位。", "solution": "该问题定义明确，并基于计算机系统中有符号整数算术的标准原理。我们需要推导 $S(n) = A + B$ 的值，其中 $n \\ge 2$ 是一个整数，而 $A$ 和 $B$ 是在 $n$ 位二进制补码系统中特定边界情况算术运算的结果。我们将根据所提供的定义，分别计算 $A$ 和 $B$。\n\n首先，我们计算 $A$ 的值。其定义如下：\n$$\nA := D\\!\\left(\\left(2^{n-1}-1 + 1\\right) \\bmod 2^{n}\\right)\n$$\n该表达式模拟了取可表示的最大正整数 $2^{n-1}-1$，并在 $\\mathbb{Z}_{2^{n}}$ 的算术体系中对其加 $1$ 的结果。我们简化括号内的表达式：\n$$\n(2^{n-1}-1 + 1) \\bmod 2^{n} = 2^{n-1} \\bmod 2^{n}\n$$\n由于 $n \\ge 2$，我们有 $2^{n-1} \\ge 2^{2-1} = 2$。同样地，$2^{n-1}  2^n$ 也成立。因此，值 $2^{n-1}$ 在区间 $[0, 2^n-1]$ 内，这意味着它对 $2^n$ 取模的值就是其自身。\n$$\n2^{n-1} \\bmod 2^{n} = 2^{n-1}\n$$\n将其代回，我们得到：\n$$\nA = D(2^{n-1})\n$$\n现在我们将解码映射 $D(x)$ 应用于参数 $x = 2^{n-1}$。$D(x)$ 的定义是：\n$$\nD(x)=\n\\begin{cases}\nx,  0 \\le x \\le 2^{n-1}-1,\\\\\nx-2^{n},  2^{n-1} \\le x \\le 2^{n}-1.\n\\end{cases}\n$$\n参数 $x = 2^{n-1}$ 满足第二种情况的条件，$2^{n-1} \\le x \\le 2^{n}-1$。因此，我们应用规则 $D(x) = x - 2^n$：\n$$\nA = D(2^{n-1}) = 2^{n-1} - 2^{n} = 2^{n-1} - 2 \\cdot 2^{n-1} = -2^{n-1}\n$$\n这个结果，$A = -2^{n-1}$，代表了算术溢出，即最大正数加 $1$ 得到最小负数。\n\n接下来，我们计算 $B$ 的值。其定义如下：\n$$\nB := D\\!\\left(\\left(E(-2^{n-1}) - 1\\right) \\bmod 2^{n}\\right)\n$$\n该表达式模拟了取最小负整数 $-2^{n-1}$，并从中减去 $1$ 的过程。首先，我们必须计算编码值 $E(-2^{n-1})$。编码映射 $E(y)$ 给出 $y$ 在 $\\{0, 1, \\ldots, 2^n - 1\\}$ 中的标准代表元。\n$$\nE(-2^{n-1}) = (-2^{n-1}) \\bmod 2^{n} = -2^{n-1} + 2^{n} = 2^{n-1}\n$$\n现在我们将此结果代入 $B$ 的表达式中：\n$$\nB = D\\!\\left(\\left(2^{n-1} - 1\\right) \\bmod 2^{n}\\right)\n$$\n对于 $n \\ge 2$，我们有 $2^{n-1}-1 \\ge 2^{1}-1 = 1$。并且，$2^{n-1}-1  2^n$。因此，值 $2^{n-1}-1$ 在区间 $[0, 2^n-1]$ 内，它对 $2^n$ 取模的值就是其自身。\n$$\n(2^{n-1} - 1) \\bmod 2^{n} = 2^{n-1} - 1\n$$\n所以，$B$ 的表达式简化为：\n$$\nB = D(2^{n-1} - 1)\n$$\n我们将解码映射 $D(x)$ 应用于参数 $x = 2^{n-1} - 1$。此参数满足第一种情况的条件，$0 \\le x \\le 2^{n-1}-1$。因此，我们应用规则 $D(x) = x$：\n$$\nB = D(2^{n-1} - 1) = 2^{n-1} - 1\n$$\n这个结果，$B = 2^{n-1} - 1$，代表了算术下溢，即最小负数减 $1$ 得到最大正数。\n\n最后，我们计算总和 $S(n) = A + B$。\n$$\nS(n) = A + B = (-2^{n-1}) + (2^{n-1} - 1)\n$$\n简化该表达式，我们得到：\n$$\nS(n) = -2^{n-1} + 2^{n-1} - 1 = -1\n$$\n对于所有整数 $n \\ge 2$，$S(n)$ 的值是一个常数 $-1$。", "answer": "$$\n\\boxed{-1}\n$$", "id": "3676829"}, {"introduction": "在高性能计算中，避免使用条件分支是提升代码效率的关键技巧，因为它可以减少现代处理器流水线中的中断。本练习向你提出了一个经典的挑战：推导并实现一个“无分支”的绝对值函数 [@problem_id:3676833]。要成功完成此任务，你不仅需要巧妙运用位运算（如 $x \\oplus m - m$），还必须深刻理解二进制补码的求反操作，并精确处理最负数（如 $-2^{n-1}$）这一棘手的边界情况，此时求绝对值会发生溢出。", "problem": "给定一个在 $n$ 位二进制补码系统中表示的有符号整数 $x$，其中 $n \\geq 2$。在一个 $n$ 位的二进制补码系统中，可表示的整数集合是范围在 $[-2^{n-1}, 2^{n-1}-1]$ 内的所有整数。所有的算术和位运算都以 $2^n$ 为模进行，并且我们约定，位模式 $u \\in [0, 2^n-1]$ 的有符号值是其二进制补码的解释：如果最高有效位是 $0$，其值是 $u$，否则是 $u - 2^n$。您可以使用的基本事实是：二进制补码中的有符号数取反等价于按位取反后加一（模 $2^n$），即 $-x \\equiv \\tilde{x} + 1 \\pmod{2^n}$，并且 $x$ 的最高有效位是其符号位。\n\n任务 1：从这些基本定义出发，推导出一个计算绝对值 $\\lvert x \\rvert$ 的无分支表达式，该表达式只能使用按位异或 $\\oplus$、减法以及一个仅从 $x$ 的符号派生出的掩码。该掩码必须通过将 $x$ 算术右移 $n-1$ 位（即移入符号位的副本）来获得符号信息，但在推导过程中不得使用条件分支。证明为什么您的表达式对于可表示范围内的所有 $x$（可能在一个边界值处除外）都能得到 $\\lvert x \\rvert$。精确地指出该边界值（作为 $n$ 的函数），并使用二进制补码模算术模型解释在该情况下会发生什么，以及为什么这种行为是不可避免的。\n\n任务 2：实现一个完整的、可运行的程序，对于每个测试用例 $(n,x)$，计算：\n- 在 $n$ 位二进制补码解释下，作为有符号整数的无分支绝对值结果。\n- 一个溢出指示符，如果数学上的绝对值 $\\lvert x \\rvert$ 不能在 $n$ 位上表示（即，如果 $x = -2^{n-1}$），则为 $1$，否则为 $0$。\n\n您的实现必须显式地模拟 $n$ 位二进制补码算术，并且不得依赖 C 语言对负值的右移行为。所有 $n$ 位运算的内部算术必须以 $2^n$ 为模进行，并且转换回有符号结果必须遵循二进制补码的解释。\n\n测试套件：您的程序必须为以下 $(n,x)$ 对计算结果，其中每个 $x$ 都保证在可表示范围 $[-2^{n-1}, 2^{n-1}-1]$ 内：\n- $(8, 0)$\n- $(8, 127)$\n- $(8, -128)$\n- $(8, -1)$\n- $(8, -42)$\n- $(16, -32768)$\n- $(16, 32767)$\n- $(16, -12345)$\n- $(2, -2)$\n- $(2, 1)$\n- $(12, -2048)$\n- $(12, -2047)$\n- $(32, -2147483648)$\n- $(32, 2147483647)$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。列表中的每个元素对应一个测试用例，顺序与上面列出的一致，并且本身必须是一个形式为 $[a,b]$ 的双元素列表，其中 $a$ 是计算出的无分支绝对值（作为有符号整数），$b$ 是溢出指示符（$0$ 或 $1$）。例如，整体输出应类似于 $[[a_1,b_1],[a_2,b_2],\\dots,[a_{14},b_{14}]]$. 不应打印任何其他文本。", "solution": "该问题要求在一个 $n$ 位二进制补码系统中，推导一个用于计算有符号整数绝对值的无分支表达式，然后通过一个实现来模拟这个逻辑。\n\n### 第 1 部分：推导与分析\n\n给定一个在 $n$ 位二进制补码系统中表示的有符号整数 $x$，其中 $n \\geq 2$。可表示的整数范围是 $[-2^{n-1}, 2^{n-1}-1]$。所有算术运算都以 $2^n$ 为模进行。绝对值的数学定义是条件性的：\n$$\n\\lvert x \\rvert = \n\\begin{cases} \nx  \\text{如果 } x \\geq 0 \\\\\n-x  \\text{如果 } x  0 \n\\end{cases}\n$$\n我们的目标是找到一个单一的、无分支的表达式，该表达式仅使用按位异或运算符（$\\oplus$）、减法和一个特殊掩码来实现此逻辑。\n\n**1. 推导掩码**\n\n该表达式必须能够区分非负数和负数。这个信息被编码在 $x$ 的符号位中，也就是位于第 $n-1$ 位的最高有效位（MSB）。如果 $x \\geq 0$，符号位为 $0$；如果 $x  0$，符号位为 $1$。\n\n问题指定一个掩码（我们称之为 $m$）必须通过将 $x$ 算术右移 $n-1$ 位来获得。我们将此操作表示为 $x \\gg_{\\text{arith}} (n-1)$。算术右移会将符号位传播到空出的位置。\n\n-   如果 $x \\geq 0$，其符号位为 $0$。将其右移 $n-1$ 位会用零填充整个 $n$ 位字。得到的位模式是 $00...0_2$，代表整数 $0$。\n-   如果 $x  0$，其符号位为 $1$。将其右移 $n-1$ 位会用一填充整个 $n$ 位字。得到的位模式是 $11...1_2$，在二进制补码表示法中是整数 $-1$。\n\n因此，掩码 $m$ 定义为：\n$$ m = x \\gg_{\\text{arith}} (n-1) = \n\\begin{cases} \n0  \\text{如果 } x \\geq 0 \\\\\n-1  \\text{如果 } x  0 \n\\end{cases}\n$$\n\n**2. 构建无分支表达式**\n\n我们寻找一个表达式 $f(x, m)$，当 $m=0$ 时其值等于 $x$，当 $m=-1$ 时其值等于 $-x$。让我们使用提供的二进制补码取反恒等式：$-x \\equiv \\tilde{x} + 1 \\pmod{2^n}$，其中 $\\tilde{x}$ 是 $x$ 的按位取反。\n\n按位异或运算（$\\oplus$）的一个关键属性是，对于任何位模式 $b$，$b \\oplus 0 = b$ 且 $b \\oplus 1 = \\neg b$（反转位）。当我们将整个字 $x$ 与一个全为一的字（代表 $-1$）进行异或运算时，结果是 $x$ 的按位取反：\n$$ x \\oplus (-1) = \\tilde{x} $$\n\n让我们检查表达式 $x \\oplus m$：\n-   如果 $x \\geq 0$，那么 $m=0$。表达式的值为 $x \\oplus 0 = x$。\n-   如果 $x  0$，那么 $m=-1$。表达式的值为 $x \\oplus (-1) = \\tilde{x}$。\n\n这是一个很有希望的中间步骤。我们为非负数情况生成了 $x$，为负数情况生成了 $\\tilde{x}$。为了得到最终的绝对值，我们必须调整这个中间结果。\n-   当 $x \\geq 0$ 时，我们有 $x$，需要的是 $x$。不需要调整。\n-   当 $x  0$ 时，我们有 $\\tilde{x}$，需要的是 $-x = \\tilde{x} + 1$。我们需要加 $1$。\n\n我们需要找到一个单一的操作，在第一种情况下加 $0$，在第二种情况下加 $1$。可以观察到，这恰好是加上 $-m$ 的操作：\n-   如果 $x \\geq 0$，$m=0$，所以我们加 $-m = 0$。\n-   如果 $x  0$，$m=-1$，所以我们加 $-m = 1$。\n\n在二进制补码算术中，加上 $-m$ 等价于减去 $m$。因此，计算绝对值的完整无分支表达式（我们称之为 $v$）是：\n$$ v = (x \\oplus m) - m $$\n\n**3. 正确性证明**\n\n让我们验证该表达式对于可表示范围内的所有 $x$ 值都成立。\n\n**情况 1：$x \\geq 0$** ($x \\in [0, 2^{n-1}-1]$)\n在这种情况下，掩码 $m=0$。表达式变为：\n$$ v = (x \\oplus 0) - 0 = x $$\n由于 $x \\geq 0$，$\\lvert x \\rvert = x$，所以表达式是正确的。\n\n**情况 2：$x  0$** ($x \\in [-2^{n-1}, -1]$)\n在这种情况下，掩码 $m=-1$。表达式变为：\n$$ v = (x \\oplus (-1)) - (-1) = (x \\oplus (-1)) + 1 $$\n如前所述，$x \\oplus (-1)$ 是按位取反 $\\tilde{x}$。所以表达式的值为 $\\tilde{x} + 1$。根据二进制补码取反的定义，这与 $-x$ 模 $2^n$ 同余。\n$$ v \\equiv -x \\pmod{2^n} $$\n对于任何 $x  0$，其数学绝对值为 $\\lvert x \\rvert = -x$。只要 $-x$ 是可表示的，该表达式就能给出正确的值。\n\n**4. 边界情况与不可避免的溢出**\n\n一个 $n$ 位二进制补码系统的可表示范围是 $[-2^{n-1}, 2^{n-1}-1]$。让我们检查对于 $x  0$，$ -x$ 是否总是可表示的。\n\n-   如果 $x \\in [-2^{n-1}+1, -1]$，那么 $-x \\in [1, 2^{n-1}-1]$。这个范围完全在该数字系统的可表示正数部分之内。对于这些值，我们的表达式计算出正确的数学绝对值。\n\n-   边界值是最小的负数，$x_{min} = -2^{n-1}$。其数学绝对值为 $\\lvert -2^{n-1} \\rvert = 2^{n-1}$。这个值 $2^{n-1}$ 超出了可表示范围，因为可表示的最大正数是 $2^{n-1}-1$。因此，在 $n$ 位系统内，任何运算都不可能产生 $x_{min}$ 的真实数学绝对值。\n\n让我们看看我们的表达式对 $x = -2^{n-1}$ 计算出什么结果。$x$ 的位模式是 $100...0_2$（其无符号值为 $2^{n-1}$）。\n由于 $x  0$，掩码为 $m=-1$。表达式计算出 $v \\equiv -x \\pmod{2^n}$。\n为了计算 $x = -2^{n-1}$（位模式 $u_x = 2^{n-1}$）的负数，我们找到它的补码并加一：\n-   按位取反：$\\tilde{u_x} = \\text{NOT}(100...0_2) = 011...1_2$。这个模式的值为 $2^{n-1}-1$。\n-   加一：$(\\tilde{u_x} + 1) = (2^{n-1}-1) + 1 = 2^{n-1}$。\n结果的位模式是 $2^{n-1}$，即 $100...0_2$。这与原始数字 $x = -2^{n-1}$ 的位模式完全相同。当作为有符号整数解释时，此模式表示值 $-2^{n-1}$。\n\n因此，对于边界值 $x = -2^{n-1}$，我们的表达式计算结果为：\n$$ v = ((-2^{n-1}) \\oplus (-1)) - (-1) = -2^{n-1} $$\n这种行为是二进制补码表示法不可避免的结果。在模 $2^n$ 算术中，$-2^{n-1}$ 的负数会溢出并回绕到其自身。\n\n问题所要求的溢出指示符当且仅当 $x=-2^{n-1}$ 时应为 $1$。这恰好对应于计算出的绝对值 $v$ 是一个负数的情况。对于任何其他输入 $x$，计算出的值 $v = \\lvert x \\rvert$ 是非负的。因此，可以通过检查结果 $v$ 的符号位是否为 $1$ 来检测溢出条件。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include\n```", "id": "3676833"}]}