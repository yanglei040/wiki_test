{"hands_on_practices": [{"introduction": "在数字系统中，设计寄存器或内存时的一个基本问题是：需要多少位来安全地存储所需范围的数值？这个练习将带你扮演系统工程师的角色，为特定应用确定所需的最小位数。通过解决这个问题 [@problem_id:1960341]，你将加深对符号-数值表示法（sign-magnitude）结构的理解，即它如何将一位用于符号，其余位用于表示数值的大小。", "problem": "一个工程师团队正在为一个物理实验设计一个简单的数字数据采集系统。该系统需要记录一个特定的物理量，该物理量可以围绕一个零点进行正向和负向波动。这些值的范围是从-63到+63的整数（包含两端）。工程师们决定使用符号-数值表示法（sign-magnitude representation）将这些值存储在一个二进制寄存器中。\n\n在符号-数值数制中，最高有效位（MSB），即最左边的位，用作符号位。符号位为0表示正数或零，而符号位为1表示负数。寄存器中的其余位用于表示该数的数值大小，形式为一个标准的无符号二进制整数。\n\n假定该寄存器必须能够表示从-63到+63的每一个整数值，那么这个寄存器所需的最少总位数是多少？", "solution": "设该寄存器使用一个符号位和 $m$ 个数值位。在符号-数值表示法中，数值字段是一个无符号二进制整数，其范围从 $0$ 到 $2^{m}-1$。为了表示所有需要的绝对值 $|x| \\in \\{0,1,\\dots,63\\}$，其数值部分必须满足\n$$2^{m}-1 \\ge 63.$$\n这等价于\n$$2^{m} \\ge 64,$$\n因此，最小整数 $m$ 是\n$$m = \\lceil \\log_{2}(64) \\rceil = 6.$$\n包括一个符号位，所需的总位数为\n$$1 + m = 1 + 6 = 7.$$", "answer": "$$\\boxed{7}$$", "id": "1960341"}, {"introduction": "掌握了数的表示方法后，下一步自然是进行算术运算。与补码不同，符号-数值表示法的加法并非简单的二进制相加，它需要根据符号的异同采取不同的策略。这个练习 [@problem_id:1960327] 模拟了一个简单处理器的算术逻辑单元（ALU）如何处理同号数相加，并让你亲手判断运算是否会导致“溢出”，从而揭示其硬件实现的内在逻辑和复杂性。", "problem": "一个基本嵌入式控制系统中的处理器使用5位符号-数值表示法对整数进行操作。在这种格式中，最高有效位（MSB）作为符号位，其中0表示正数，1表示负数。其余4位表示数的量值。该系统的算术逻辑单元（ALU）设计用于将两个数相加，$A = -9$和$B = -8$。\n\nALU对两个同符号数相加的步骤如下：它使用一个4位加法器对其4位量值进行二进制加法。该加法运算的4位结果作为最终答案的量值存储，结果的符号位与两个输入数的符号相同。当且仅当4位量值加法的最高有效位产生进位时，溢出标志位置为1；否则，该标志位为0。\n\n根据此特定硬件实现，以下哪个选项正确描述了存储在结果寄存器中的最终5位二进制模式以及溢出标志位的状态？\n\nA. 模式为 `10001` 且溢出标志位置位。\n\nB. 模式为 `10001` 且溢出标志位未置位。\n\nC. 模式为 `110001` 且溢出标志位置位。\n\nD. 模式为 `11111` 且溢出标志位未置位。\n\nE. 模式为 `00001` 且溢出标志位置位。", "solution": "在5位符号-数值系统中，一个数表示为$[s\\,m_{3}m_{2}m_{1}m_{0}]$，其中$s$是符号位，$m_{3}m_{2}m_{1}m_{0}$是4位量值。对于$A=-9$和$B=-8$，其量值分别为$9$和$8$，对应的4位二进制形式分别为$1001$和$1000$。因此，\n$$A = 1\\,1001,\\quad B = 1\\,1000。$$\nALU对两个同符号数相加的规则是：用一个4位加法器将两个4位量值相加，将4位的和作为量值存储，保持输入数的符号作为结果的符号，并且当且仅当4位加法的最高有效位有进位输出时，将溢出标志位置位。\n\n计算4位量值之和：\n$$1001 + 1000 = 1\\,0001,$$\n其中最左边的$1$是4位加法器最高有效位的进位输出，而保留的4位和是$0001$。\n\n因此：\n- 存储的量值为$0001$。\n- 结果的符号位是$1$（负），与输入相匹配。\n- 溢出标志位被置为$1$，因为4位量值加法的最高有效位产生了进位。\n\n因此，最终的5位模式是$1\\,0001$且溢出标志位置位，这对应于选项A。", "answer": "$$\\boxed{A}$$", "id": "1960327"}, {"introduction": "符号-数值表示法最著名也最棘手的特性之一是它存在两种零的编码：$+0$ 和 $-0$。这个看似微小的冗余在硬件设计和软件编程中会引发一系列深刻的问题。这个高级练习 [@problem_id:3676527] 将挑战你从计算机体系结构设计师的视角出发，思考如何通过“规范化”处理来消除寄存器中的 $-0$，并分析这一硬件层面的决策对那些依赖区分两种零的软件算法会产生怎样的语义影响。", "problem": "考虑一个指令集架构（ISA），它对一个表示为 $\\mathsf{S}_n$ 的 $n$ 位有符号整数类型使用符号-数值表示法。在符号-数值表示法中，每个整数值都由一个数对 $(s,m)$ 表示，其中 $s \\in \\{0,1\\}$ 是符号位，$m \\in \\{0,1,\\dots,2^{n-1}-1\\}$ 是数值。与 $(s,m)$ 对应的数值 $v$ 定义为 $v = (-1)^s \\cdot m$。这种表示法允许两种对零的编码：$+0$ 编码为 $(0,0)$，$-0$ 编码为 $(1,0)$。\n\n该ISA的一个流水线实现包含一个寄存器写回阶段，该阶段提交所有写入架构寄存器的指令的结果。假设微架构设计师考虑在寄存器写回阶段引入一个规范化策略，以确保架构寄存器文件中不包含 $-0$。\n\n哪个选项最能指定一个在寄存器写回阶段应用的、将 $-0 \\to +0$ 映射的正确规范化策略，并正确预测其对依赖于不同零编码的算法的程序语义的影响？\n\nA. 在寄存器写回阶段，对于每一条将 $\\mathsf{S}_n$ 值写入架构寄存器的指令（包括算术指令、加载指令和移动指令），将任何 $m=0$ 的 $(s,m)$ 替换为 $(0,0)$；即，只要 $m=0$ 就强制 $s:=0$。这将在架构寄存器中合并两种零编码。只观察值级语义（对 $v$ 的算术运算，对 $v$ 的比较）的程序不受影响，因为对于两种编码，都有 $(-1)^s \\cdot 0 = 0$。但是，依赖于位级区分（例如，在 $m=0$ 时检查符号位 $s$，使用 $-0$ 作为哨兵值）的算法将失去区分 $-0$ 和 $+0$ 的能力，其可观察行为也会相应改变。\n\nB. 在寄存器写回阶段，仅通过将 $(1,0)$ 映射到 $(0,0)$ 来规范化算术指令的结果，而不规范化由加载或移动指令产生的值；这样可以在消除算术运算产生的 $-0$ 的同时，为数据移动保留不同的零编码。因此，这对任何程序的语义都没有影响，包括那些依赖于不同零编码的程序，因为加载操作会保持 $-0$ 不变。\n\nC. 在寄存器读取时而非写入时执行规范化：每当读取一个持有 $(1,0)$ 的寄存器时，对于消费该值的指令，将其视为 $(0,0)$，但在其到达写回阶段时继续存储 $(1,0)$。由于 $+0$ 和 $-0$ 代表相同的数值，因此这对程序没有影响，包括那些测试符号位或使用 $-0$ 作为标记的程序。\n\nD. 在寄存器写回阶段，通过在 $s=1$ 且 $m>0$ 时强制 $s:=0$ 来规范化所有负值，同时保持 $(1,0)$ 不变；这保证了单一的零编码，并且对依赖于不同零编码的算法没有影响，因为只有非零负值被改变，而 $-0$ 保持不变。\n\n选择唯一最佳选项。", "solution": "该问题的核心在于理解数字的*数值*（value）与其*位级表示*（bit-level representation）之间的区别，以及架构层面的决策如何影响程序语义。\n\n- **数值 vs. 表示**：在原码中，`+0`（编码为 `(s=0, m=0)`）和 `-0`（编码为 `(s=1, m=0)`）代表相同的数学值——零。标准算术运算和比较（例如 `if (x == 0)`）作用于这个数值，因此对编码方式不敏感。然而，某些算法可能会利用位级的差异，例如，当数值为零时检查符号位，将 `-0` 用作特殊的标志或哨兵值。\n\n- **分析策略**：目标是确保任何寄存器都永远不持有 `-0` 的表示 `(1,0)`。为使该策略有效，任何写入寄存器的操作（算术、加载、移动）如果产生了 `-0` 的结果，都必须在写回阶段完成写入前将其转换为 `+0`（`(0,0)`）。\n\n基于此分析，我们来评估各个选项：\n\n- **选项 A**：此选项提出了一个全面且正确的策略。它将规范化应用于*每一条*写入寄存器的指令。它正确地指出，这将在架构状态中合并两种零的表示。其影响分析也同样准确：只关心零的数学值的程序不受影响，但依赖于区分 `+0` 和 `-0` 位模式能力的程序，其行为将会改变，因为这种区分在架构层面已不复存在。这是正确且完整的答案。\n\n- **选项 B**：该策略不完整。它只规范化算术结果，而不处理加载或移动指令的结果，因此未能实现设计目标。一个 `-0` 值可以从内存中加载并存入寄存器，这违反了寄存器不得包含 `-0` 的规则。\n\n- **选项 C**：这种“读取时规范化”的策略也未能达成设计目标，因为它明确允许 `-0` 存储在寄存器文件中。目标是从寄存器本身消除 `-0`，而不仅仅是在使用时屏蔽它。\n\n- **选项 D**：该策略存在根本性错误。它建议将所有非零负数规范化（例如，将 `-5` 变为 `+5`），这将完全破坏有符号算术。此外，它明确声明将保持 `-0` 不变，这与既定目标完全相反。\n\n因此，选项A提供了唯一正确的策略实现及其对程序语义影响的合理分析。", "answer": "$$\\boxed{A}$$", "id": "3676527"}]}