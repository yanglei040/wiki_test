{"hands_on_practices": [{"introduction": "掌握浮点数的第一步是理解计算机如何解释一串原始的二进制位。本练习将让你直接实践应用 IEEE 754 标准，将一个32位的二进制模式解码为其对应的实数值，重点关注符号、指数偏移量和隐藏前导“1”的作用。[@problem_id:3546510]", "problem": "考虑电气和电子工程师协会 (IEEE) $754$ 二进制$32$位浮点格式。一个浮点数据由其位域给出：符号位 $s=0$、指数域 $E=10000001_{2}$ 和小数域 $f=01000000000000000000000_{2}$。仅使用该标准关于二进制$32$位编码的核心定义（符号位、偏置值为 $b=127$ 的带偏置指数，以及规格化有效数的隐含前导 $1$），确定此位模式所表示的精确实数值。您的推导过程必须根据域值明确说明该数的分类（规格化数、非规格化数或特殊值）的理由，并且必须解释偏置值 $b=127$ 在从存储的指数域中恢复真实指数时的作用。请以无舍入的精确实数形式提供最终答案。", "solution": "此问题有效。这是一个基于已确立的 IEEE $754$ 浮点算术标准的适定且有科学依据的问题。所有必要信息均已提供，任务是根据该标准的定义执行直接计算。\n\n在 IEEE $754$ 标准中，浮点数的值由其三个部分决定：符号位 $s$、指数域 $E$ 和小数域 $f$。问题中给出的值为：\n- 符号位：$s=0$\n- 指数域：$E = 10000001_{2}$\n- 小数域：$f = 01000000000000000000000_{2}$\n\n分析过程是通过根据二进制$32$位格式规则解释这些域来进行的。\n\n首先，我们必须将该数分类为规格化数、非规格化数或特殊值。此分类取决于指数域 $E$ 的值。二进制$32$位格式使用一个$8$位指数域，因此其值范围可以从 $0$ 到 $255$。特殊值是 $E=0$（用于零和非规格化数）和 $E=255$（用于无穷大和 NaN）。所有其他值，即 $1 \\le E \\le 254$，都表示规格化数。\n\n我们将给定的指数域 $E$ 从二进制转换为十进制：\n$$E = 1 \\times 2^{7} + 0 \\times 2^{6} + 0 \\times 2^{5} + 0 \\times 2^{4} + 0 \\times 2^{3} + 0 \\times 2^{2} + 0 \\times 2^{1} + 1 \\times 2^{0}$$\n$$E = 128 + 1 = 129$$\n由于 $1 \\le 129 \\le 254$，该位模式表示一个**规格化**数。\n\n对于规格化数，其值 $v$ 由以下公式给出：\n$$v = (-1)^{s} \\times M \\times 2^{e}$$\n其中 $M$ 是有效数（尾数），$e$ 是真实指数。\n\n符号由符号位 $s$ 决定。由于 $s=0$，该数为正数。因子 $(-1)^{s}$ 为 $(-1)^{0} = 1$。\n\n真实指数 $e$ 是通过从存储的指数域 $E$ 中减去一个偏置值 $b$ 来恢复的。对于二进制$32$位格式，偏置值为 $b=127$。偏置值的作用是允许$8$位的无符号指数域表示正负两种真实指数。存储值为 $E=127$ 对应于真实指数 $e=0$。大于 $127$ 的值产生正指数，小于 $127$ 的值产生负指数。\n计算真实指数：\n$$e = E - b = 129 - 127 = 2$$\n\n有效数 $M$ 由小数域 $f$ 构成。对于规格化数，存在一个不被存储的隐含前导位 $1$。因此，有效数的形式为 $1.f$。\n给定小数域 $f=01000000000000000000000_{2}$，完整的二进制有效数为：\n$$M = 1.01000000000000000000000_{2}$$\n为了求出 $M$ 的十进制值，我们将每个位位置对应的 $2$ 的幂相加：\n$$M = 1 \\times 2^{0} + 0 \\times 2^{-1} + 1 \\times 2^{-2} + 0 \\times 2^{-3} + \\dots$$\n$$M = 1 + \\frac{1}{4} = 1 + 0.25 = 1.25$$\n\n最后，我们将所有部分组合起来，求出精确的实数值 $v$：\n$$v = (-1)^{s} \\times M \\times 2^{e}$$\n$$v = (-1)^{0} \\times 1.25 \\times 2^{2}$$\n$$v = 1 \\times 1.25 \\times 4$$\n$$v = 5$$\n该位模式表示的精确实数值是 $5$。", "answer": "$$\\boxed{5}$$", "id": "3546510"}, {"introduction": "理解了规格化数之后，探索其在精度极限下的行为至关重要。本练习将深入研究次规格化数（或非规格化数）的领域，它们填补了最小规格化数与零之间的空隙。你将检视不同的硬件下溢处理策略如何导致截然不同的结果和精度。[@problem_id:3642263]", "problem": "考虑一种遵循 Institute of Electrical and Electronics Engineers (IEEE) 浮点算术标准 (IEEE 754) 中 `binary32` 格式（单精度）的算术。该格式使用 $1$ 个符号位、$8$ 个指数位和 $23$ 个尾数位，对于规格化数，其含有一个隐含的前导 $1$。在此格式中，当指数域全为零时，会出现次规格化数（denormal）；它们没有隐含的前导 $1$，并且其间距是均匀的。最小的正次规格化数的量级为 $2^{-149}$，下一个更大的可表示值（次规格化或规格化）通过加上 $2^{-149}$ 获得。\n\n一个处理器对于实数操作数 $y$ 和 $z$ 的运算 $x = y - z$ 支持两种下溢处理模式：\n- 渐进下溢：精确的实数差值使用“向最接近的值舍入，偶数优先”的规则，舍入到最接近的可表示 `binary32` 值。\n- 冲刷至零：任何非零的次规格化结果都被替换为 $0$，否则使用常规舍入。\n\n假设 $y > z > 0$ 是实数，使得精确差值为\n$$d = y - z = \\frac{101}{200}\\cdot 2^{-149},$$\n且 $|d|  2^{-149}$。定义标量\n$$R = \\frac{\\text{冲刷至零模式下的绝对误差}}{\\text{渐进下溢模式下的绝对误差}},$$\n其中“绝对误差”指计算结果与精确实数结果 $d$ 之间差值的绝对值。\n\n仅使用 IEEE 754 `binary32` 的基本属性（格式结构、次规格化数间距和“向最接近的值舍入，偶数优先”规则），确定 $R$ 的精确值，表示为单个实数。无需单位。不要舍入；以精确形式给出答案。", "solution": "首先将对问题的科学合理性、自洽性和良定性进行验证。\n\n### 步骤 1：提取已知条件\n问题陈述中明确给出的数据和条件如下：\n- **浮点系统**：Institute of Electrical and Electronics Engineers (IEEE) 标准 754，`binary32` 格式（单精度）。\n- **格式结构**：$1$ 个符号位，$8$ 个指数位，$23$ 个尾数位。\n- **规格化数**：隐含的前导 $1$。\n- **次规格化数**：指数域全为零，无隐含前导 $1$，间距均匀。\n- **最小正次规格化数**：量级为 $s_{min} = 2^{-149}$。\n- **次规格化数间距**：相邻次规格化数之间的间距为 $2^{-149}$。这也是最大次规格化数与最小规格化数之间的差值。\n- **运算**：$x = y - z$，其中 $y$ 和 $z$ 是实数，且 $y > z > 0$。\n- **精确差值**：$d = y - z = \\frac{101}{200} \\cdot 2^{-149}$。还指出 $|d|  2^{-149}$。\n- **下溢模式 1（渐进下溢）**：精确的实数差值 $d$ 使用“向最接近的值舍入，偶数优先”规则，舍入到最接近的可表示 `binary32` 值。\n- **下溢模式 2（冲刷至零）**：任何非零的次规格化结果都被替换为 $0$。否则使用常规舍入。\n- **待求量**：比率 $R = \\frac{\\text{冲刷至零模式下的绝对误差}}{\\text{渐进下溢模式下的绝对误差}}$。\n- **误差定义**：“绝对误差”是计算结果与精确实数结果 $d$ 之间差值的绝对值。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题基于明确定义的 IEEE 754 浮点算术标准。\n- **科学合理性**：`binary32` 格式的细节是正确的。对于规格化数，偏置指数范围是 $[-126, 127]$。指数域全为零表示次规格化数或零；对于次规格化数，有效指数固定为最小规格化数的指数，即 $1 - \\text{bias} = 1 - 127 = -126$。次规格化数的值为 $v = (-1)^S \\times 0.F \\times 2^{-126}$，其中 $F$ 是 $23$ 位的尾数。最小正次规格化值出现在尾数 $F$ 的最低有效位为 $1$ 而所有其他位为 $0$ 时，因此 $F = 2^{-23}$。其值因而为 $2^{-23} \\times 2^{-126} = 2^{-149}$。关于最小正次规格化数量级为 $2^{-149}$ 的陈述是正确的。次规格化数的间距是均匀的，其量子为 $2^{-149}$，这也陈述正确。渐进下溢和冲刷至零的定义是标准的。该问题在科学上是合理的。\n- **良定性**：问题提供了确定两种模式下计算值、计算各自误差并求其比率所需的所有信息。问题清晰明确，并导向一个唯一的、稳定的解。\n- **客观性**：语言技术性强且精确。\n\n问题陈述有效。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n### 解答\n目标是计算比率 $R = \\frac{E_{flush}}{E_{grad}}$，其中 $E_{flush}$ 和 $E_{grad}$ 分别是冲刷至零和渐进下溢模式下的绝对误差。给定的精确差值为 $d = \\frac{101}{200} \\cdot 2^{-149}$。\n\n首先，我们分析接近零的可表示 `binary32` 数的集合。次规格化数是最小正次规格化值 $s_{min} = 2^{-149}$ 的整数倍。接近零的正可表示数为 $\\{0, 1 \\cdot 2^{-149}, 2 \\cdot 2^{-149}, 3 \\cdot 2^{-149}, \\dots\\}$。\n\n精确结果为 $d = \\frac{101}{200} \\cdot 2^{-149} = 0.505 \\cdot 2^{-149}$。该值不是 $2^{-149}$ 的整数倍，因此它不是一个可表示的 `binary32` 数。它必须被舍入。\n\n**1. 渐进下溢的计算**\n\n在渐进下溢模式下，精确结果 $d$ 被舍入到最接近的可表示数。指定的规则是“向最接近的值舍入，偶数优先”。值 $d$ 位于两个连续的可表示数之间：$0$ 和 $s_{min} = 1 \\cdot 2^{-149}$。\n\n为了确定最接近的可表示数，我们将 $d$ 与 $0$ 和 $s_{min}$ 之间的中点进行比较。\n中点 $m$ 为：\n$$m = \\frac{0 + s_{min}}{2} = \\frac{1}{2} s_{min} = \\frac{1}{2} \\cdot 2^{-149} = 0.5 \\cdot 2^{-149}$$\n\n我们将 $d$ 与 $m$ 比较：\n$$d = 0.505 \\cdot 2^{-149}$$\n$$m = 0.5 \\cdot 2^{-149}$$\n由于 $0.505 > 0.5$，我们有 $d > m$。这意味着 $d$ 比起 $0$ 更接近 $s_{min}$。由于这不是一个平局（tie）情况，规则中“偶数优先”的部分无关紧要。结果被舍入到最接近的值，即 $s_{min}$。\n\n在渐进下溢模式下的计算结果为 $x_{grad}$：\n$$x_{grad} = s_{min} = 2^{-149}$$\n\n渐进下溢模式下的绝对误差 $E_{grad}$ 是计算结果与精确结果之间的绝对差值：\n$$E_{grad} = |x_{grad} - d| = |2^{-149} - \\frac{101}{200} \\cdot 2^{-149}|$$\n提出因子 $2^{-149}$：\n$$E_{grad} = |1 - \\frac{101}{200}| \\cdot 2^{-149} = |\\frac{200 - 101}{200}| \\cdot 2^{-149} = \\frac{99}{200} \\cdot 2^{-149}$$\n\n**2. 冲刷至零的计算**\n\n在冲刷至零模式下，任何会成为非零次规格化数的结果都会被强制置为零。精确结果 $d = 0.505 \\cdot 2^{-149}$ 处于次规格化范围内，因为其量级小于最小正规格化数（$2^{-126}$）但大于零。IEEE 754 标准规定，当精确结果极小（在次规格化范围内）且会导致精度损失时，会发生下溢。在冲刷至零模式下，这样的结果被替换为零。\n\n在冲刷至零模式下的计算结果为 $x_{flush}$：\n$$x_{flush} = 0$$\n\n冲刷至零模式下的绝对误差 $E_{flush}$ 是：\n$$E_{flush} = |x_{flush} - d| = |0 - \\frac{101}{200} \\cdot 2^{-149}|$$\n$$E_{flush} = \\frac{101}{200} \\cdot 2^{-149}$$\n\n**3. 比率 R 的计算**\n\n比率 $R$ 定义为两个绝对误差的商：\n$$R = \\frac{E_{flush}}{E_{grad}}$$\n代入我们推导出的表达式：\n$$R = \\frac{\\frac{101}{200} \\cdot 2^{-149}}{\\frac{99}{200} \\cdot 2^{-149}}$$\n分子和分母中的公因子 $\\frac{1}{200} \\cdot 2^{-149}$ 被消去。\n$$R = \\frac{101}{99}$$\n这就是所要求的最终精确值。", "answer": "$$\\boxed{\\frac{101}{99}}$$", "id": "3642263"}, {"introduction": "浮点表示的有限性意味着并非所有实数都能被精确存储，这会导致表示误差。这个动手实践将展示这些微小误差的一个关键后果：灾难性抵消。当两个几乎相等的数相减时，可能会导致相对精度的巨大损失，本练习将通过一个具体例子，带你了解这一现象是如何发生的。[@problem_id:3642283]", "problem": "考虑在电气与电子工程师协会（IEEE $754$）浮点数算术标准中执行的算术运算，具体使用 binary$32$ 格式，该格式具有 1 个符号位，8 个指数位（偏置值为 $127$），以及 23 个尾数位（对于规格化数，有一个隐藏的前导 $1$）。两个十进制输入 $x = 123456.78$ 和 $y = 123456.77$ 首先使用“向最近的偶数舍入”规则转换为 binary$32$ 格式，然后执行减法 $x - y$，并根据相同规则将结果正确舍入到 binary$32$ 格式。仅从 binary$32$ 的结构定义和规格化出发，确定硬件为该减法运算返回的精确十进制值。\n\n将最终答案表示为一个精确的十进制数。无需单位。", "solution": "用户希望我解决一个浮点数算术问题。\n\n### 第 1 步：提取已知条件\n- **标准**：IEEE $754$ binary$32$ 格式。\n- **格式**：1 个符号位，8 个指数位，23 个尾数位。\n- **偏置值**：指数偏置值为 $127$。\n- **规格化**：规格化数有隐藏的前导 $1$。\n- **舍入规则**：向最近的偶数舍入。\n- **输入 `x`**：$x = 123456.78$\n- **输入 `y`**：$y = 123456.77$\n- **运算**：\n  1. 将 $x$ 转换为其 binary$32$ 表示，记为 $x_{b32}$。\n  2. 将 $y$ 转换为其 binary$32$ 表示，记为 $y_{b32}$。\n  3. 计算差值 $d = x_{b32} - y_{b32}$ 并将结果舍入到 binary$32$ 格式。\n- **目标**：求出最终计算结果的精确十进制值。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题基于 IEEE $754$ 标准，这是计算机体系结构和数值计算中一个基础且被普遍接受的标准。其原理在科学和数学上是合理的。\n- **适定性**：该问题提供了所有必要的参数：数字格式（binary$32$）、具体输入（$x$ 和 $y$）以及精确的算术规则（舍入模式）。这确保了存在一个唯一的、确定性的解。\n- **客观性**：问题陈述是精确和技术性的，没有歧义或主观性语言。\n\n该问题不违反任何无效性标准。这是一个适定的、数值分析中的标准问题，特别关注浮点数运算中的表示误差和灾难性抵消。\n\n### 第 3 步：结论与行动\n该问题是**有效的**。将提供完整解答。\n\n### 解题过程\n\n该问题要求我们模拟遵循 IEEE $754$ binary$32$ 标准的硬件执行浮点数转换和减法运算的过程。\n\n**1. 确定相关的浮点数精度（ULP）**\n\n首先，我们必须确定输入数 $x = 123456.78$ 和 $y = 123456.77$ 的量级。我们可以找到包围它们的 2 的幂：\n$$2^{16} = 65536$$\n$$2^{17} = 131072$$\n由于 $2^{16}  x, y  2^{17}$，这些数的任何规格化 binary$32$ 表示都将具有一个无偏指数 $E=16$。\n在此格式中，一个规格化数的值由 $v = (-1)^s \\times (1.f)_2 \\times 2^E$ 给出，其中 $s$ 是符号位，$f$ 是 23 位的尾数部分。存储在 8 位指数域中的偏置指数为 $e = E + 127 = 16 + 127 = 143$。\n\n在此范围内的数的精度由有效数（significand）的最低有效位的值决定。这被称为最后一位的单位（Unit in the Last Place, ULP）。\n$$\\text{ULP} = 2^E \\times 2^{-23} = 2^{16} \\times 2^{-23} = 2^{-7}$$\n作为一个十进制数，ULP 是：\n$$\\text{ULP} = \\frac{1}{128} = 0.0078125$$\n在范围 $[2^{16}, 2^{17})$ 内的每个实数都被映射到此 ULP 值的最接近的倍数。\n\n**2. 将输入 `x` 转换为 binary32 格式**\n\n为了找到 $x = 123456.78$ 的 binary$32$ 表示，我们将 $x$ 除以 ULP，以确定它最接近哪个倍数。\n$$\\frac{x}{\\text{ULP}} = \\frac{123456.78}{0.0078125} = 123456.78 \\times 128 = 15802467.84$$\n这个数字表示按 $2^{23}$ 缩放后的有效数。根据“向最近的偶数舍入”规则，我们必须将其舍入到最近的整数。由于小数部分 $0.84$ 大于 $0.5$，我们向上舍入。\n$$N_x = \\text{round}(15802467.84) = 15802468$$\n存储的 $x$ 的值，我们称之为 $x_{b32}$，是 ULP 的这个整数倍。\n$$x_{b32} = N_x \\times \\text{ULP} = 15802468 \\times 0.0078125 = 123456.78125$$\n\n**3. 将输入 `y` 转换为 binary32 格式**\n\n我们对 $y = 123456.77$ 重复同样的过程。\n$$\\frac{y}{\\text{ULP}} = \\frac{123456.77}{0.0078125} = 123456.77 \\times 128 = 15802466.56$$\n小数部分 $0.56$ 大于 $0.5$，所以我们向上舍入。请注意，这不是一个平局（tie），所以规则中“偶数优先”的部分没有被触发。\n$$N_y = \\text{round}(15802466.56) = 15802467$$\n存储的 $y$ 的值，我们称之为 $y_{b32}$，是：\n$$y_{b32} = N_y \\times \\text{ULP} = 15802467 \\times 0.0078125 = 123456.7734375$$\n\n**4. 执行减法并确定最终结果**\n\n硬件对存储的表示 $x_{b32}$ 和 $y_{b32}$ 执行减法。该减法的精确结果是：\n$$d = x_{b32} - y_{b32} = 123456.78125 - 123456.7734375 = 0.0078125$$\n最后一步是确保这个结果 $d$ 正确地存储在一个 binary$32$ 寄存器中，这可能涉及另一次舍入。我们必须检查 $d$ 是否可以精确表示。\n$$d = 0.0078125 = \\frac{1}{128} = 2^{-7}$$\n这个值可以用规格化浮点形式写成 $1.0_2 \\times 2^{-7}$。\n- 符号为正 ($s=0$)。\n- 有效数是 $1.0_2$，所以尾数部分 $f$ 全为零。\n- 无偏指数为 $E = -7$。\n该指数在 binary$32$ 规格化数的有效范围 $[-126, 127]$ 内。由于该值是 2 的幂，因此它可以在二进制浮点格式中精确表示。因此，最终结果不需要舍入。\n\n硬件返回的值是存储值相减的精确结果。", "answer": "$$\n\\boxed{0.0078125}\n$$", "id": "3642283"}]}