{"hands_on_practices": [{"introduction": "理解字节序的第一步是观察数字在内存中的实际布局。第一个练习将让你扮演一名系统分析师的角色。通过分析原始的十六进制内存转储，你的任务是识别数据中的模式，从而推断出机器的体系结构。这个练习将大端和小端字节序的抽象定义与你在调试器中看到的具体字节直接联系起来。[@problem_id:3639638]", "problem": "一个无符号 $32$ 位整数（$\\texttt{uint32\\_t}$）数组从基地址 $\\texttt{0x2000}$ 开始在内存中连续存储。硬件的字节序是未知的。该数组的元素构成一个等差数列 $\\{a_k\\}$，满足 $a_k = a_0 + k\\,d$，其中 $k \\in \\{0,1,2,3,4\\}$，$a_0$ 和 $d$ 是非负整数，并且在此范围内不会发生 $32$ 位整数的回绕。公差满足 $0  d  256$，并且在这五个元素之间，从低位字节到高位字节没有进位。\n\n我们得到了从地址 $\\texttt{0x2000}$ 到 $\\texttt{0x2013}$ 的前 $20$ 个字节（五个字）的线性十六进制转储，按地址递增顺序列出。这些字节是：\n$\\texttt{40 30 20 10 50 30 20 10 60 30 20 10 70 30 20 10 80 30 20 10}$。\n\n仅使用字节序的核心定义（在小端字节序中，一个字的最低有效字节位于最低地址；在大端字节序中，最高有效字节位于最低地址）和等差数列的定义，确定该系统的字节序并重构 $a_0$ 和 $d$。请将公差 $d$ 以十进制整数形式报告。无需四舍五入。", "solution": "题目要求我们确定一个计算机系统的字节序，并找出存储在内存中的一个等差数列的公差 `d`。\n\n首先，我们来整理一下已知信息。\n一个包含五个 $32$ 位无符号整数（$\\texttt{uint32\\_t}$）的数组，我们记作 $\\{a_k\\}_{k=0}^4$，从地址 $\\texttt{0x2000}$ 开始存储在内存中。提供了前 $20$ 个字节的内存转储：\n$\\texttt{40 30 20 10 50 30 20 10 60 30 20 10 70 30 20 10 80 30 20 10}$。\n\n该序列是一个等差数列，定义为 $a_k = a_0 + k\\,d$，其中 $k \\in \\{0, 1, 2, 3, 4\\}$。\n约束条件如下：\n1. $a_0$ 和 $d$ 是非负整数。\n2. 公差 $d$ 满足 $0  d  256$。用十六进制表示，即 $0  d  \\texttt{0x100}$。\n3. 在计算 $a_{k+1} = a_k + d$（其中 $k \\in \\{0, 1, 2, 3\\}$）时，从低位字节到高位字节没有进位。鉴于 $d$ 是一个单字节值，这意味着在每一步中，将 $d$ 加到 $a_k$ 的最低有效字节上，产生的结果不会大于或等于 $256$（即 $\\texttt{0x100}$）。\n\n内存转储对应于五个连续的 $32$ 位字。我们按字来分割字节流：\n- 字 0 ($a_0$)：地址 $\\texttt{0x2000}-\\texttt{0x2003}$ 处的字节是 $\\texttt{40}, \\texttt{30}, \\texttt{20}, \\texttt{10}$。\n- 字 1 ($a_1$)：地址 $\\texttt{0x2004}-\\texttt{0x2007}$ 处的字节是 $\\texttt{50}, \\texttt{30}, \\texttt{20}, \\texttt{10}$。\n- 字 2 ($a_2$)：地址 $\\texttt{0x2008}-\\texttt{0x200B}$ 处的字节是 $\\texttt{60}, \\texttt{30}, \\texttt{20}, \\texttt{10}$。\n- 字 3 ($a_3$)：地址 $\\texttt{0x200C}-\\texttt{0x200F}$ 处的字节是 $\\texttt{70}, \\texttt{30}, \\texttt{20}, \\texttt{10}$。\n- 字 4 ($a_4$)：地址 $\\texttt{0x2010}-\\texttt{0x2013}$ 处的字节是 $\\texttt{80}, \\texttt{30}, \\texttt{20}, \\texttt{10}$。\n\n我们必须对系统的字节序测试两种假设。\n\n**假设 1：系统是大端字节序**\n在大端字节序架构中，一个多字节字的最高有效字节（MSB）存储在最低的内存地址。字节按从最高有效到最低有效的顺序存储。\n\n在此假设下，我们来构造 $\\{a_k\\}$ 的整数值：\n- $a_0 = \\texttt{0x40302010}$\n- $a_1 = \\texttt{0x50302010}$\n- $a_2 = \\texttt{0x60302010}$\n- $a_3 = \\texttt{0x70302010}$\n- $a_4 = \\texttt{0x80302010}$\n\n现在，我们通过计算连续项之间的差来检查这个序列是否构成一个等差数列。\n$d = a_1 - a_0 = \\texttt{0x50302010} - \\texttt{0x40302010} = \\texttt{0x10000000}$\n我们为其他元素验证这个公差：\n$a_2 - a_1 = \\texttt{0x60302010} - \\texttt{0x50302010} = \\texttt{0x10000000}$\n$a_3 - a_2 = \\texttt{0x70302010} - \\texttt{0x60302010} = \\texttt{0x10000000}$\n$a_4 - a_3 = \\texttt{0x80302010} - \\texttt{0x70302010} = \\texttt{0x10000000}$\n该序列确实是一个等差数列，公差为 $d = \\texttt{0x10000000}$。\n\n接下来，我们将这个 $d$ 值与题目的约束条件 $0  d  256$ 进行核对。\n$d$ 的十进制值为 $d = 16^7 = 268,435,456$。\n这个值 $268,435,456$ 不在所要求的范围 $(0, 256)$ 内。\n因此，大端字节序的假设是错误的。\n\n**假设 2：系统是小端字节序**\n在小端字节序架构中，一个多字节字的最低有效字节（LSB）存储在最低的内存地址。为了构成按常规写法（MSB 在前）的整数，必须按相反的顺序读取内存中的字节。\n\n在此假设下，我们来构造 $\\{a_k\\}$ 的整数值：\n- 对于 $a_0$，字节是 $\\texttt{40}, \\texttt{30}, \\texttt{20}, \\texttt{10}$。将它们反转得到 $\\texttt{10}, \\texttt{20}, \\texttt{30}, \\texttt{40}$。所以，$a_0 = \\texttt{0x10203040}$。\n- 对于 $a_1$，字节是 $\\texttt{50}, \\texttt{30}, \\texttt{20}, \\texttt{10}$。将它们反转得到 $\\texttt{10}, \\texttt{20}, \\texttt{30}, \\texttt{50}$。所以，$a_1 = \\texttt{0x10203050}$。\n- 按照这个模式处理所有的字：\n  - $a_0 = \\texttt{0x10203040}$\n  - $a_1 = \\texttt{0x10203050}$\n  - $a_2 = \\texttt{0x10203060}$\n  - $a_3 = \\texttt{0x10203070}$\n  - $a_4 = \\texttt{0x10203080}$\n\n现在，我们检查这个序列是否是一个等差数列。\n$d = a_1 - a_0 = \\texttt{0x10203050} - \\texttt{0x10203040} = \\texttt{0x10}$\n我们为其他元素验证这个公差：\n$a_2 - a_1 = \\texttt{0x10203060} - \\texttt{0x10203050} = \\texttt{0x10}$\n$a_3 - a_2 = \\texttt{0x10203070} - \\texttt{0x10203060} = \\texttt{0x10}$\n$a_4 - a_3 = \\texttt{0x10203080} - \\texttt{0x10203070} = \\texttt{0x10}$\n该序列是一个等差数列，公差为 $d = \\texttt{0x10}$。\n\n接下来，我们将这个 $d$ 值与题目的约束条件进行核对。\n首先，$0  d  256$。\n$d$ 的十进制值为 $d = 16^1 = 16$。\n条件 $0  16  256$ 得到满足。\n\n其次，我们必须验证“无进位”的约束条件。这意味着加上 $d$ 不会引起从低位字节到高位字节的进位。\n设 $a_k = B_{k,3}2^{24} + B_{k,2}2^{16} + B_{k,1}2^8 + B_{k,0}$ 是 $a_k$ 的字节表示。\n操作是 $a_{k+1} = a_k + d$。由于 $d = \\texttt{0x10}$ 小于 $\\texttt{0x100}$（或 $256$），除非产生进位，否则加法仅影响最低有效字节 $B_{k,0}$。约束条件声明没有进位发生。\n- 对于 $k=0$：$a_0 = \\texttt{0x10203040}$。最低有效字节是 $B_{0,0} = \\texttt{0x40}$。\n  $B_{0,0} + d = \\texttt{0x40} + \\texttt{0x10} = \\texttt{0x50}$。因为 $\\texttt{0x50}  \\texttt{0x100}$，所以没有进位。\n  $a_1 = a_0 + d = \\texttt{0x10203040} + \\texttt{0x10} = \\texttt{0x10203050}$。这与我们计算出的 $a_1$ 值相符。\n- 对于 $k=1$：$a_1 = \\texttt{0x10203050}$。最低有效字节是 $B_{1,0} = \\texttt{0x50}$。\n  $B_{1,0} + d = \\texttt{0x50} + \\texttt{0x10} = \\texttt{0x60}$。因为 $\\texttt{0x60}  \\texttt{0x100}$，所以没有进位。\n  $a_2 = a_1 + d = \\texttt{0x10203050} + \\texttt{0x10} = \\texttt{0x10203060}$。这与我们计算出的 $a_2$ 值相符。\n- 对于 $k=2$：$a_2 = \\texttt{0x10203060}$。最低有效字节是 $B_{2,0} = \\texttt{0x60}$。\n  $B_{2,0} + d = \\texttt{0x60} + \\texttt{0x10} = \\texttt{0x70}$。因为 $\\texttt{0x70}  \\texttt{0x100}$，所以没有进位。\n  $a_3 = a_2 + d = \\texttt{0x10203060} + \\texttt{0x10} = \\texttt{0x10203070}$。这与我们计算出的 $a_3$ 值相符。\n- 对于 $k=3$：$a_3 = \\texttt{0x10203070}$。最低有效字节是 $B_{3,0} = \\texttt{0x70}$。\n  $B_{3,0} + d = \\texttt{0x70} + \\texttt{0x10} = \\texttt{0x80}$。因为 $\\texttt{0x80}  \\texttt{0x100}$，所以没有进位。\n  $a_4 = a_3 + d = \\texttt{0x10203070} + \\texttt{0x10} = \\texttt{0x10203080}$。这与我们计算出的 $a_4$ 值相符。\n\n在小端字节序的假设下，所有约束条件都得到满足。\n字节序是小端字节序。\n数列的首项是 $a_0 = \\texttt{0x10203040}$。\n公差是 $d = \\texttt{0x10}$，即十进制的 $16$。\n\n题目要求以十进制整数形式报告公差 $d$。\n$d = 16$。", "answer": "$$\\boxed{16}$$", "id": "3639638"}, {"introduction": "字节序问题最常导致网络编程中棘手的错误。下一个练习将你带入一个真实的调试场景，其中多余的字节交换操作导致了令人困惑的结果。通过仔细追踪数据从发送方到接收方的完整路径，你将学会如何理清这些常见的错误，并体会到标准网络字节序的重要性。[@problem_id:3639618]", "problem": "一台小端序主机 $A$ 与一台小端序主机 $B$ 使用一个远程过程调用 (RPC) 层进行通信。该 RPC 层将 $16$ 位字段以大端序打包到网络线路中，并通过将原始字节从网络线路复制到主机内存来进行解包，而不执行任何转换。应用程序的开发者在发送端将数据传递给 RPC 打包器之前，错误地应用了主机到网络短整型 (HTONS) 函数，并在接收端于 RPC 解包字节后应用了网络到主机短整型 (NTOHS) 函数。线路协议强制规定所有 $16$ 位字段都采用大端序。\n\n要求你设计一种调试方法，使用探针值 $p_{1} = 0x00FF$ 和 $p_{2} = 0xFF00$ 来检测上述双重交换错误的存在。设 $V(p)$ 表示在由开发者的转换和 RPC 打包器/解包器组成的整个流水线执行后，最终传递到主机 $B$ 上应用程序的 $16$ 位无符号整数值。定义诊断标量\n$$\nD \\equiv V(p_{1}) - V(p_{2}),\n$$\n将 $V(p_{1})$ 和 $V(p_{2})$ 都解释为无符号 $16$ 位整数，并在主机上使用标准整数算术（而不是模 $2^{16}$）执行减法。\n\n仅从大端和小端字节序的核心定义以及对一个 $16$ 位值进行单字节交换的操作出发，为该流水线推导 $V(p)$，并为给定的探针值数值计算诊断值 $D$。将最终的诊断值 $D$ 表示为一个无符号十进制整数。不需要四舍五入。", "solution": "用户想要为一个存在字节序相关错误的数据传输流水线计算诊断标量 `D` 的值。\n\n### 步骤1：提取已知条件\n- **主机字节序**：主机A和主机B都是小端序。\n- **线路协议**：线路协议对 $16$ 位字段使用大端字节序。\n- **RPC层行为（发送）**：发送端的RPC打包器接收一个 $16$ 位值，并以大端序将其打包到网络线路中。\n- **RPC层行为（接收）**：接收端的RPC解包器将原始字节从网络线路直接复制到主机内存，不进行任何字节序转换。\n- **开发者错误（发送）**：开发者的发送代码在将数据传递给RPC打包器*之前*，对数据应用了 `Host-To-Network-Short` (`HTONS`) 函数。\n- **开发者行为（接收）**：开发者的接收代码在从RPC解包器接收数据*之后*，对数据应用了 `Network-To-Host-Short` (`NTOHS`) 函数。\n- **探针值**：使用两个 $16$ 位探针值：$p_{1} = 0x00FF$ 和 $p_{2} = 0xFF00$。\n- **函数定义**：$V(p)$ 是最终传递到主机B上应用程序的 $16$ 位无符号整数值。\n- **诊断定义**：$D \\equiv V(p_{1}) - V(p_{2})$，其中减法是标准整数算术。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据和客观性**：该问题根植于计算机组织与体系结构的原理，特别是网络字节序和主机字节序（endianness）。大端序、小端序、`HTONS` 和 `NTOHS` 的概念在网络编程中是标准的。\n- **良态问题**：该问题提供了数据处理流水线的完整且一致的描述。追踪数据从主机A到主机B转换所需的所有必要信息都已提供。在计算机科学的背景下，函数和操作都有明确的定义。\n- **可形式化**：该问题使用精确的术语描述，可以进行数学和算法形式化。\n- **无缺陷**：该问题不违反任何科学原理，不不完整或矛盾，并且不是微不足道的。所描述的RPC层行为不寻常但有明确定义，使其成为一个可解决的场景。\n\n### 步骤3：结论和行动\n问题有效。将提供详细的解决方案。\n\n### V(p) 变换的推导\n\n让我们用其最高有效字节 (MSB) $B_H$ 和最低有效字节 (LSB) $B_L$ 来定义一个通用的 $16$ 位无符号整数 $p$。$p$ 的值由 $p = 256 \\cdot B_H + B_L$ 给出。我们用十六进制表示为 $p = 0x B_H B_L$。\n\n**大端序**系统将此值存储在内存中，MSB位于较低地址，后跟LSB：$[B_H, B_L]$。\n**小端序**系统将LSB存储在较低地址，后跟MSB：$[B_L, B_H]$。\n\n在小端序主机上，`HTONS` 和 `NTOHS` 的核心操作是字节交换。让我们定义交换操作符 $S(p)$ 如下：\n$$\nS(p) = S(256 \\cdot B_H + B_L) = 256 \\cdot B_L + B_H\n$$\n在十六进制表示法中，$S(0x B_H B_L) = 0x B_L B_H$。\n\n现在我们追踪值 $p$ 从主机A到主机B的整个流水线过程。\n\n1.  **从主机A（小端序）开始**：应用程序以 $16$ 位值 $p = 0x B_H B_L$ 开始。\n\n2.  **开发者的 `HTONS` 调用**：开发者错误地对 $p$ 调用了 `HTONS`。由于主机A是小端序，`HTONS` 执行字节交换。传递给RPC层的值是：\n    $p' = \\text{HTONS}(p) = S(p) = 0x B_L B_H$\n\n3.  **主机A上的RPC打包器**：RPC层接收到值 $p' = 0x B_L B_H$。它的任务是以大端序将此值打包到网络线路中。对于值 $p'$，其MSB是 $B_L$，LSB是 $B_H$。大端序线路格式要求先发送MSB，然后是LSB。因此，在线路上发送的字节序列是：\n    $\\text{Wire Bytes} = [B_L, B_H]$\n\n4.  **主机B上的RPC解包器**：RPC解包器接收到字节流 $[B_L, B_H]$。根据问题描述，它“通过将原始字节从网络线路复制到主机内存来解包，而不执行任何转换”。字节 $B_L$ 被写入内存地址 $m$，字节 $B_H$ 被写入下一个地址 $m+1$。现在主机B的内存包含字节序列 $[B_L, B_H]$。\n\n5.  **主机B上的数据解释（小端序）**：RPC层将此内存位置的值传递给应用程序。由于主机B是小端序，其CPU将内存序列 $[B_L, B_H]$（LSB在较低地址，MSB在较高地址）解释为值：\n    $p'' = 256 \\cdot B_H + B_L = p$\n    因此，开发者的应用程序代码（在调用其自己的 `NTOHS` 之前）接收到的值是原始值 $p$。发送端开发者的 `HTONS` 和RPC层行为的组合，导致 $p$ 未经改变地传输到主机B的应用层。\n\n6.  **开发者的 `NTOHS` 调用**：主机B上的应用程序接收到值 $p'' = p$ 并对其调用 `NTOHS`。由于主机B是小端序，`NTOHS` 执行字节交换。\n    $V(p) = \\text{NTOHS}(p'') = \\text{NTOHS}(p) = S(p)$\n\n因此，整个流水线的净效应是一次单字节交换：$V(p) = S(p) = 0x B_L B_H$。\n\n### 诊断标量 D 的计算\n\n现在我们将此变换应用于探针值 $p_1$ 和 $p_2$。\n\n对于 $p_{1} = 0x00FF$：\n高字节是 $B_H = 0x00$，低字节是 $B_L = 0xFF$。\n主机B上的最终值是：\n$V(p_{1}) = S(0x00FF) = 0xFF00$\n作为一个无符号十进制整数，$V(p_{1}) = 255 \\times 256 + 0 = 65280$。\n\n对于 $p_{2} = 0xFF00$：\n高字节是 $B_H = 0xFF$，低字节是 $B_L = 0x00$。\n主机B上的最终值是：\n$V(p_{2}) = S(0xFF00) = 0x00FF$\n作为一个无符号十进制整数，$V(p_{2}) = 0 \\times 256 + 255 = 255$。\n\n最后，我们使用标准整数算术计算诊断标量 $D$：\n$D = V(p_{1}) - V(p_{2}) = 65280 - 255$\n$D = 65025$\n诊断标量 $D$ 的值是 $65025$。这个非零结果成功地检测到了数据编组异常的存在。", "answer": "$$\n\\boxed{65025}\n$$", "id": "3639618"}, {"introduction": "除了简单的调试，对字节序的深刻理解还能用于复杂的系统分析。最后一个练习挑战你像测试工程师一样思考，设计一个“智能”探针。你将发现，一个精心构造的字节序列如何能让一个远程系统不仅揭示其字节序，还暴露其数据解释规则（整型与浮点型），这展示了互操作性测试中的一个强大原则。[@problem_id:3639653]", "problem": "一个远程仪器接收严格按内存地址升序排列的四个字节，并返回一个十进制值。在内部，该仪器根据四种假设之一来解释接收到的$32$位字：大端序无符号整数、小端序无符号整数、大端序电气和电子工程师协会（IEEE）浮点算术标准（IEEE-754）单精度浮点数，或小端序IEEE-754单精度浮点数。解释方式是固定的但未知。测量约束如下：当内部解释为浮点数且计算出的值不是有限实数（例如，$+\\infty$、$-\\infty$或非数值）时，仪器返回十进制数$0$；否则，它返回解释结果的精确十进制值。当内部解释为整数时，仪器返回精确的无符号十进制值。\n\n您必须选择由四字节序列组成的测试向量，这些字节模式在组合成一个$32$位字时，能够仅使用字节序和IEEE-754单精度编码的基本定义，使得四种假设下的输出可被明确区分。请使用以下候选测试向量：\n- $v_1$：字节$\\{0x7F, 0x80, 0x00, 0x00\\}$，按地址升序排列，\n- $v_2$：字节$\\{0x00, 0x00, 0x00, 0x01\\}$，按地址升序排列。\n\n您可以使用的基本依据：\n- 字节序定义：如果字节$\\{B_0, B_1, B_2, B_3\\}$从最低地址到最高地址排列，则大端序$32$位字为$X_{\\mathrm{BE}} = B_0 \\cdot 2^{24} + B_1 \\cdot 2^{16} + B_2 \\cdot 2^{8} + B_3$，小端序$32$位字为$X_{\\mathrm{LE}} = B_0 + B_1 \\cdot 2^{8} + B_2 \\cdot 2^{16} + B_3 \\cdot 2^{24}$。\n- IEEE-754单精度布局：给定一个$32$位字$X$，符号位是$s = (X \\gg 31)  1$，指数场是$e = (X \\gg 23)  0xFF$，尾数场是$f = X  0x7FFFFF$。其值为\n  - 如果$e = 255$且$f = 0$，则为$(-1)^s \\cdot \\infty$，\n  - 如果$e = 0$且$f \\neq 0$，则为$(-1)^s \\cdot 2^{-126} \\cdot \\frac{f}{2^{23}}$（非规格化数），\n  - 如果$0  e  255$，则为$(-1)^s \\cdot 2^{e - 127} \\cdot \\left(1 + \\frac{f}{2^{23}}\\right)$。\n\n根据这些基本依据推导，是仅$v_1$、仅$v_2$还是两者共同作用，才能保证仪器的单一十进制输出能唯一确定四种假设中的哪一种生效。您的推理不得使用快捷查找表，并且必须说明对于所选的测试向量，为何四种假设下的输出是两两不同的，同时要考虑到仪器对非有限浮点数的映射规则。最后，给出从$\\{v_1, v_2\\}$中保证能区分这四种假设所需的最少不同测试向量的数量。请用一个整数表示您的最终答案。无需四舍五入。", "solution": "该问题是有效的。它在科学上基于计算机体系结构的原理，特别是数据表示（字节序和IEEE-754浮点标准）。问题陈述清晰，提供了所有必要的定义和约束，以得出一个唯一的、合乎逻辑的解决方案。问题陈述是客观和完整的。\n\n任务是确定从集合$\\{v_1, v_2\\}$中需要的最少测试向量数量，以唯一识别仪器使用四种假设中的哪一种来解释一个四字节序列。这四种假设是大端序无符号整数（BE_UINT）、小端序无符号整数（LE_UINT）、大端序IEEE-754单精度浮点数（BE_FLOAT）和小端序IEEE-754单精度浮点数（LE_FLOAT）。如果对于任何一对不同的假设，集合中至少有一个向量能为每种假设产生不同的输出，则该测试向量集是充分的。最少数量是满足此条件的最小集合的大小。\n\n设四个字节按内存地址升序排列为$\\{B_0, B_1, B_2, B_3\\}$。问题定义了大端序和小端序的$32$位字如下：\n$X_{\\mathrm{BE}} = B_0 \\cdot 2^{24} + B_1 \\cdot 2^{16} + B_2 \\cdot 2^{8} + B_3$\n$X_{\\mathrm{LE}} = B_0 + B_1 \\cdot 2^{8} + B_2 \\cdot 2^{16} + B_3 \\cdot 2^{24}$\n\n我们将通过计算每个测试向量在所有四种假设下的仪器输出来分析它们。\n\n测试向量$v_1 = \\{0x7F, 0x80, 0x00, 0x00\\}$的分析\n\n对于$v_1$，字节为$B_0 = 0x7F = 127$，$B_1 = 0x80 = 128$，$B_2 = 0x00 = 0$，$B_3 = 0x00 = 0$。\n\n1.  **假设：大端序无符号整数（BE_UINT）**\n    $32$位字为$X_{\\mathrm{BE}}$。用十六进制表示，这是通过连接字节形成的：$X_{\\mathrm{BE}} = 0x7F800000$。\n    十进制值为$127 \\cdot 2^{24} + 128 \\cdot 2^{16} + 0 \\cdot 2^8 + 0 \\cdot 2^0 = 2130706432 + 8388608 = 2139095040$。\n    仪器输出为$2139095040$。\n\n2.  **假设：小端序无符号整数（LE_UINT）**\n    $32$位字为$X_{\\mathrm{LE}}$。用十六进制表示，这是通过按重要性倒序连接字节形成的：$X_{\\mathrm{LE}} = 0x0000807F$。\n    十进制值为$127 \\cdot 2^0 + 128 \\cdot 2^8 + 0 \\cdot 2^{16} + 0 \\cdot 2^{24} = 127 + 32768 = 32895$。\n    仪器输出为$32895$。\n\n3.  **假设：大端序IEEE-754单精度浮点数（BE_FLOAT）**\n    $32$位字为$X = X_{\\mathrm{BE}} = 0x7F800000$。\n    二进制表示为`0111 1111 1000 0000 0000 0000 0000 0000`。\n    符号位为$s = (X \\gg 31)  1 = 0$。\n    指数场为$e = (X \\gg 23)  0xFF$。这些位是`11111111`，所以$e = 255$。\n    尾数场为$f = X  0x7FFFFF$。这些位全是`0`，所以$f = 0$。\n    根据提供的规则，对于$e = 255$和$f = 0$，值为$(-1)^s \\cdot \\infty$。当$s=0$时，这是$+\\infty$。\n    仪器对于非有限值返回$0$。\n    仪器输出为$0$。\n\n4.  **假设：小端序IEEE-754单精度浮点数（LE_FLOAT）**\n    $32$位字为$X = X_{\\mathrm{LE}} = 0x0000807F$。\n    二进制表示为`0000 0000 0000 0000 1000 0000 0111 1111`。\n    符号位为$s = (X \\gg 31)  1 = 0$。\n    指数场为$e = (X \\gg 23)  0xFF = 0$。\n    尾数场为$f = X  0x7FFFFF = 0x807F = 32895$。\n    根据提供的规则，对于$e=0$和$f \\neq 0$，这是一个非规格化数。其值为$(-1)^s \\cdot 2^{-126} \\cdot \\frac{f}{2^{23}}$。\n    当$s=0$且$f=32895$时，值为$2^{-126} \\cdot \\frac{32895}{2^{23}} = 2^{-126} \\cdot \\frac{32895}{8388608}$。\n    这是一个有限、正、非零的实数。\n    仪器输出为$2^{-126} \\cdot \\frac{32895}{8388608}$。\n\n$v_1$的输出如下：\n-   BE_UINT: $2139095040$\n-   LE_UINT: $32895$\n-   BE_FLOAT: $0$\n-   LE_FLOAT: $2^{-126} \\cdot \\frac{32895}{8388608}$（一个很小的正数）\n\n这四个值在数值上都是不同的。因此，通过发送测试向量$v_1$并观察其单一的十进制输出，可以唯一地确定四种假设中哪一种是正确的。这意味着仅$v_1$就足够了。因此，所需的最少向量数量最多为$1$。\n\n为了完整性，我们分析向量$v_2$。\n\n测试向量$v_2 = \\{0x00, 0x00, 0x00, 0x01\\}$的分析\n\n对于$v_2$，字节为$B_0 = 0x00 = 0$，$B_1 = 0x00 = 0$，$B_2 = 0x00 = 0$，$B_3 = 0x01 = 1$。\n\n1.  **假设：大端序无符号整数（BE_UINT）**\n    $32$位字为$X_{\\mathrm{BE}} = 0x00000001$。\n    十进制值为$0 \\cdot 2^{24} + 0 \\cdot 2^{16} + 0 \\cdot 2^8 + 1 \\cdot 2^0 = 1$。\n    仪器输出为$1$。\n\n2.  **假设：小端序无符号整数（LE_UINT）**\n    $32$位字为$X_{\\mathrm{LE}} = 0x01000000$。\n    十进制值为$0 \\cdot 2^0 + 0 \\cdot 2^8 + 0 \\cdot 2^{16} + 1 \\cdot 2^{24} = 16777216$。\n    仪器输出为$16777216$。\n\n3.  **假设：大端序IEEE-754单精度浮点数（BE_FLOAT）**\n    $32$位字为$X = X_{\\mathrm{BE}} = 0x00000001$。\n    符号位为$s = 0$。\n    指数场为$e = 0$。\n    尾数场为$f = 1$。\n    对于$e=0$和$f \\neq 0$，值为非规格化数：$(-1)^s \\cdot 2^{-126} \\cdot \\frac{f}{2^{23}} = 2^{-126} \\cdot \\frac{1}{2^{23}} = 2^{-149}$。\n    仪器输出为$2^{-149}$。\n\n4.  **假设：小端序IEEE-754单精度浮点数（LE_FLOAT）**\n    $32$位字为$X = X_{\\mathrm{LE}} = 0x01000000$。\n    二进制表示为`0000 0001 0000 0000 0000 0000 0000 0000`。\n    符号位为$s = 0$。\n    指数场为$e = (X \\gg 23)  0xFF = 2$。\n    尾数场为$f = X  0x7FFFFF = 0$。\n    对于$0  e  255$，值为规格化数：$(-1)^s \\cdot 2^{e-127} \\cdot (1 + \\frac{f}{2^{23}}) = 2^{2-127} \\cdot (1 + 0) = 2^{-125}$。\n    仪器输出为$2^{-125}$。\n\n$v_2$的输出如下：\n-   BE_UINT: $1$\n-   LE_UINT: $16777216$\n-   BE_FLOAT: $2^{-149}$\n-   LE_FLOAT: $2^{-125}$\n\n这四个值（$1$、$16777216$、$2^{-149}$和$2^{-125}$）在数值上都是不同的。因此，仅$v_2$也足以区分这四种假设。\n\n由于单独使用向量$v_1$或单独使用向量$v_2$都足以唯一确定仪器的解释模式，因此从集合$\\{v_1, v_2\\}$中所需的最少不同测试向量数量是$1$。", "answer": "$$\n\\boxed{1}\n$$", "id": "3639653"}]}