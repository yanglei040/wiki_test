{"hands_on_practices": [{"introduction": "理解优先编码器工作原理的最佳方式，莫过于通过一个具体实例来追踪其逻辑。这项练习要求你像电路本身一样思考，当面对多个有效输入信号时，如何应用优先级规则来决定最终的编码输出。通过解决这个问题 [@problem_id:1954014]，你将掌握一个 $4$-to-$2$ 优先编码器的核心功能，即在存在多个中断或请求时，如何准确识别并编码优先级最高的信号。", "problem": "4-2优先编码器是一种组合逻辑电路，它接受四个输入并产生一个两位二进制输出。该编码器旨在从其四个数据输入（记为 $I_3$、$I_2$、$I_1$ 和 $I_0$）中识别出最高优先级的有效输入。对于这个特定的设备，输入 $I_3$ 具有最高优先级，其次是 $I_2$，然后是 $I_1$，最后是优先级最低的 $I_0$。\n\n该编码器有两个二进制输出 $Y_1$ 和 $Y_0$，它们代表最高优先级有效输入的二进制索引（其中“有效”意味着输入为逻辑‘1’）。例如，如果 $I_2$ 是最高优先级的有效输入，则输出 $Y_1Y_0$ 将是2的二进制表示，即‘10’。除了编码输出外，还有一个“有效”位 $V$。如果一个或多个输入有效，则有效位 $V$ 置为‘1’；仅当所有输入都无效（逻辑‘0’）时，它才为‘0’。\n\n给定输入数据向量 $I_3I_2I_1I_0 = 1011$，确定输出 $V, Y_1,$ 和 $Y_0$ 的结果状态。请从以下选项中选择正确的选项。\n\nA. $V=1, Y_1=0, Y_0=1$\n\nB. $V=1, Y_1=1, Y_0=0$\n\nC. $V=1, Y_1=1, Y_0=1$\n\nD. $V=0, Y_1=1, Y_0=1$\n\nE. $V=1, Y_1=0, Y_0=0$", "solution": "4-2优先编码器选择最高优先级的置位输入，并在 $(Y_{1},Y_{0})$ 上以二进制形式输出其索引，$V$ 则指示是否有任何输入被置位。使用标准布尔代数（其中+表示“或”运算，并置或$\\cdot$表示“与”运算，上划线表示“非”运算），对于优先级为 $I_{3} \\succ I_{2} \\succ I_{1} \\succ I_{0}$ 的4-2优先编码器，其规范表达式为：\n$$V = I_{3} + I_{2} + I_{1} + I_{0},$$\n$$Y_{1} = I_{3} + I_{2},$$\n$$Y_{0} = I_{3} + \\overline{I_{2}}\\,I_{1}.$$\n理由如下：\n- 如果有任何输入有效，$V$ 就为1，因此是所有输入的“或”运算。\n- 当且仅当所选索引为2或3时，$Y_{1}$ 为1。这种情况发生在 $I_{3}=1$ 时，或（在 $I_{3}=0$ 的情况下）$I_{2}=1$ 时，得出 $I_{3} + I_{2}$。\n- 当所选索引为奇数（1或3）时，$Y_{0}$ 为1。当 $I_{3}=1$ 时，索引为3。仅当 $I_{3}=0$, $I_{2}=0$ 且 $I_{1}=1$ 时，索引为1。因此表达式为 $I_{3} + \\overline{I_{2}}\\,I_{1}$。\n\n给定 $I_{3}I_{2}I_{1}I_{0} = 1011$，我们有 $I_{3}=1$, $I_{2}=0$, $I_{1}=1$, $I_{0}=1$。代入可得：\n$$V = 1 + 0 + 1 + 1 = 1,$$\n$$Y_{1} = 1 + 0 = 1,$$\n$$Y_{0} = 1 + \\overline{0}\\cdot 1 = 1 + 1\\cdot 1 = 1.$$\n因此输出为 $V=1$, $Y_{1}=1$, $Y_{0}=1$，这对应于选项C。", "answer": "$$\\boxed{C}$$", "id": "1954014"}, {"introduction": "优先编码器在实际应用中很少单独使用，它们通常是更复杂系统中的一个构建模块。这项练习 [@problem_id:1954013] 挑战你的设计思维，要求你构建一个小型逻辑电路来处理一个 $8$-to-$3$ 优先编码器的输出。你的任务是检测最高优先级有效输入的索引是否为奇数，这需要你发现输入信号的属性与编码器二进制输出之间的巧妙联系。", "problem": "一个8-3优先编码器有八个高电平有效输入，表示为 $I_7, I_6, \\dots, I_0$，并产生一个3位二进制输出码，表示为 $Y_2Y_1Y_0$。该编码器的工作方式是，其输出代表当前有效（处于逻辑'1'状态）的输入中索引最高的那个输入的二进制索引。例如，如果输入 $I_5$、$I_2$ 和 $I_1$ 都有效，编码器的输出将是 $Y_2Y_1Y_0 = 101$，因为在所有有效输入中 $I_5$ 的索引最高。本问题仅考虑至少有一个输入有效的情况。\n\n来自优先编码器的这个3位输出被送入一个次级组合逻辑电路。这个次级电路被设计用于产生一个单位输出 $F$。该电路的功能是，当且仅当优先编码器的索引最高的有效输入是奇数索引的输入（即 $I_1, I_3, I_5,$ 或 $I_7$）时，将其输出 $F$ 置为'1'。否则，输出 $F$ 为'0'。\n\n确定输出 $F$ 作为编码器输出 $Y_2, Y_1,$ 和 $Y_0$ 的函数的最小化积之和（SOP）布尔表达式。", "solution": "8-3优先编码器输出索引最高的有效输入的二进制索引 $k \\in \\{0,1,\\dots,7\\}$。次级电路必须在且仅在 $k$ 为奇数时输出 $F=1$，即 $k \\in \\{1,3,5,7\\}$。由于编码器的输出 $(Y_{2},Y_{1},Y_{0})$ 以标准二进制形式表示 $k$，因此 $F=1$ 的最小项恰好是那些 $(Y_{2},Y_{1},Y_{0})$ 等于 $001,011,101,111$ 的项。\n\n根据这些最小项写出规范的积之和形式：\n$$\nF = \\overline{Y_{2}}\\,\\overline{Y_{1}}\\,Y_{0} \\;+\\; \\overline{Y_{2}}\\,Y_{1}\\,Y_{0} \\;+\\; Y_{2}\\,\\overline{Y_{1}}\\,Y_{0} \\;+\\; Y_{2}\\,Y_{1}\\,Y_{0}.\n$$\n提取公因式 $Y_{0}$：\n$$\nF = Y_{0}\\left(\\overline{Y_{2}}\\,\\overline{Y_{1}} \\;+\\; \\overline{Y_{2}}\\,Y_{1} \\;+\\; Y_{2}\\,\\overline{Y_{1}} \\;+\\; Y_{2}\\,Y_{1}\\right).\n$$\n使用 $\\overline{A}+A=1$ 和分配律进行分组和化简：\n$$\n\\overline{Y_{2}}\\,\\overline{Y_{1}} + \\overline{Y_{2}}\\,Y_{1} = \\overline{Y_{2}}(\\overline{Y_{1}}+Y_{1}) = \\overline{Y_{2}},\n$$\n$$\nY_{2}\\,\\overline{Y_{1}} + Y_{2}\\,Y_{1} = Y_{2}(\\overline{Y_{1}}+Y_{1}) = Y_{2},\n$$\n所以\n$$\nF = Y_{0}\\left(\\overline{Y_{2}} + Y_{2}\\right) = Y_{0}\\cdot 1 = Y_{0}.\n$$\n因此，最小化的SOP表达式就是编码器输出的最低有效位。", "answer": "$$\\boxed{Y_{0}}$$", "id": "1954013"}, {"introduction": "在现代数字设计中，工程师们使用硬件描述语言（HDL）如Verilog来描述电路功能，而非手动绘制逻辑门。这项练习 [@problem_id:1943463] 将带你从理论走向实践，任务是编写一条简洁高效的Verilog语句来为一个 $4$-to-$2$ 优先编码器建模。通过这个过程，你将体会到抽象的“优先级”逻辑是如何在代码中被优雅地实现的。", "problem": "在数字逻辑设计中，优先编码器是一种组合电路，可将多个二进制输入转换为数量较少的输出。其输出表示处于有效状态的最高优先级输入的二进制编码索引。\n\n考虑一个要在硬件描述语言（HDL）如Verilog中实现的4-2优先编码器模块。该模块具有以下接口：\n- 一个4位输入向量 `d`，其中 `d[3]` 具有最高优先级，`d[0]` 具有最低优先级。\n- 一个2位输出向量 `y`，它应表示最高优先级置位（逻辑'1'）输入的二进制索引。\n- 一个1位输出 `v`（代表“有效”），如果 `d` 中有任何输入置位，它应为'1'，否则为'0'。\n\n如果没有输入置位（即 `d` 为 `4'b0000`），则 `v` 输出必须为'0'，而 `y` 的输出值可被视为“无关项”（通常设置为'0'）。\n\n您的任务是使用嵌套条件（三元）运算符（`? :`），找出一个单一的连续赋值语句，通过将适当的值赋给拼接向量 `{v, y}` 来正确实现此4-2优先编码器的逻辑。\n\n以下哪个Verilog语句正确地建模了指定的优先编码器？\n\nA. `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b000;`\n\nB. `assign {v, y} = d[0] ? 3'b100 : d[1] ? 3'b101 : d[2] ? 3'b110 : d[3] ? 3'b111 : 3'b000;`\n\nC. `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b110 : d[0] ? 3'b100 : 3'b000;`\n\nD. `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b100;`\n\nE. `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b101 : d[1] ? 3'b011 : d[0] ? 3'b001 : 3'b000;`", "solution": "题目要求用户使用带有嵌套条件运算符的单一 `assign` 语句，找出4-2优先编码器的正确Verilog实现。赋值的输出是3位拼接向量 `{v, y}`。\n\n首先，让我们根据问题描述建立优先编码器的真值表。输入为 `d[3:0]`，输出为 `v` 和 `y[1:0]`。优先级为 `d[3] > d[2] > d[1] > d[0]`。我们还确定了拼接向量 `{v, y}` 所需的3位值。真值表中的 'x' 代表“无关”条件。\n\n| `d[3]` | `d[2]` | `d[1]` | `d[0]` | `v` | `y[1:0]` | `{v, y}` (3位值) |\n|:------:|:------:|:------:|:------:|:-----:|:--------:|:----------------------:|\n| 1 | x | x | x | 1 | `2'b11` | `3'b111` |\n| 0 | 1 | x | x | 1 | `2'b10` | `3'b110` |\n| 0 | 0 | 1 | x | 1 | `2'b01` | `3'b101` |\n| 0 | 0 | 0 | 1 | 1 | `2'b00` | `3'b100` |\n| 0 | 0 | 0 | 0 | 0 | `2'b00` | `3'b000` |\n*（注意：在没有输入置位的情况下，`y` 是无关项，通常设置为 `2'b00`）*\n\nVerilog中的嵌套条件（三元）运算符 `condition ? value_if_true : value_if_false` 创建了一个等效于 `if-else if-else` 链的优先级结构。该语句将按条件出现的顺序进行检查。\n\n让我们根据真值表和优先级规则构建正确的语句：\n\n1.  **检查最高优先级输入 `d[3]`：** 如果 `d[3]` 为'1'，输出 `{v, y}` 必须为 `3'b111`。\n    语句以以下形式开始：`d[3] ? 3'b111 : ...`\n\n2.  **检查下一个优先级输入 `d[2]`：** 如果 `d[3]` 为'0'，我们检查 `d[2]`。如果 `d[2]` 为'1'，输出 `{v, y}` 必须为 `3'b110`。\n    这构成了第一个嵌套：`d[3] ? 3'b111 : (d[2] ? 3'b110 : ...)`\n\n3.  **检查 `d[1]`：** 如果 `d[3]` 和 `d[2]` 都为'0'，我们检查 `d[1]`。如果 `d[1]` 为'1'，输出 `{v, y}` 必须为 `3'b101`。\n    嵌套继续：`... : (d[2] ? 3'b110 : (d[1] ? 3'b101 : ...))`\n\n4.  **检查最低优先级输入 `d[0]`：** 如果 `d[3]`、`d[2]` 和 `d[1]` 都为'0'，我们检查 `d[0]`。如果 `d[0]` 为'1'，输出 `{v, y}` 必须为 `3'b100`。\n    嵌套变为：`... : (d[1] ? 3'b101 : (d[0] ? 3'b100 : ...))`\n\n5.  **默认情况：** 如果所有输入都为'0'，则所有条件都不满足。这是最后的 `else` 情况。输出 `{v, y}` 必须为 `3'b000`。\n    完整的语句是：`assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b000;`\n\n现在，我们来评估给出的选项：\n\n*   **A: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b000;`**\n    该语句与我们推导出的逻辑完全匹配。它正确地实现了从 `d[3]` 到 `d[0]` 的优先级，并为每种情况（包括默认情况）生成了正确的 `{v, y}` 值。这是正确答案。\n\n*   **B: `assign {v, y} = d[0] ? 3'b100 : d[1] ? 3'b101 : d[2] ? 3'b110 : d[3] ? 3'b111 : 3'b000;`**\n    该语句颠倒了优先级顺序，首先检查 `d[0]`。它实现了一个 `d[0]` 具有最高优先级的优先编码器，这与问题规范相矛盾。\n\n*   **C: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b110 : d[0] ? 3'b100 : 3'b000;`**\n    该语句在 `d[1]` 情况下的输出有误。当 `d[1]` 置位（且 `d[3]`、`d[2]` 未置位）时，它输出 `3'b110`，这对应于 `{v=1, y=2'b10}`。正确的输出应该是 `{v=1, y=2'b01}` 或 `3'b101`。\n\n*   **D: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b100;`**\n    该语句在最后的 `else`（默认）情况中有误。如果没有输入置位（`d == 4'b0000`），它会将 `3'b100` 赋给 `{v, y}`。这意味着 `v` 变为'1'，这是不正确的，因为当没有输入有效时，有效位应为'0'。\n\n*   **E: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b101 : d[1] ? 3'b011 : d[0] ? 3'b001 : 3'b000;`**\n    该语句似乎是为赋值给 `{y, v}` 而不是 `{v, y}` 构建的。让我们分析 `d[2]` 的情况：`{v, y}` 的正确输出是 `3'b110`。该语句提供 `3'b101`，这意味着 `v=1, y=2'b01`。这对应于索引1，而不是2。然而，如果目标是 `{y, v}`，值将是 `{2'b10, 1'b1}`，即 `3'b101`。此选项表明对问题中指定的拼接顺序存在误解。\n\n因此，选项A是唯一一个正确建模了指定的4-2优先编码器逻辑的选项。", "answer": "$$\\boxed{A}$$", "id": "1943463"}]}