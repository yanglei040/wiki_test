{"hands_on_practices": [{"introduction": "异或门不仅是基本的逻辑构建块，更是逻辑综合中的一把“瑞士军刀”。这个练习将引导你将一个标准的选择器（MUX）的“和之积”表达式，巧妙地转换为一个以异或为核心的等价形式。通过这个过程，你将体会到如何利用异或门的特性来重构和优化数字电路，这是一个在现代电路设计中至关重要的技能。[@problem_id:3688749]", "problem": "一个具有选择输入 $s$ 和数据输入 $a$、$b$ 的 $2$选$1$多路复用器 (Multiplexer (MUX)) 由布尔函数 $z=(s \\land a)\\lor(\\overline{s}\\land b)$ 指定。请仅使用基本布尔代数和异或（exclusive OR (XOR)）运算的定义性质——交换律、结合律、单位元性质 $x\\oplus 0=x$ 和自逆性 $x\\oplus x=0$——推导出一个 $z$ 的等价表达式。该表达式应采用以异或为中心的结构，其中一个输入是 $b$，另一个输入是 $s$ 与 $a$ 和 $b$ 的异或的乘积。然后，在一个只允许使用 $2$输入门 $\\{\\text{AND}, \\text{OR}, \\text{XOR}\\}$ 和反相器的标准单元模型中，将电路的门深度定义为任何输入到输出路径上的最大门级数，其中一个反相器计为一级。确定积之和实现和您推导的以异或为中心的实现的门深度。\n\n假设 $2$输入门和反相器的传播延迟如下：$t_{\\text{AND}}=45\\,\\text{ps}$、$t_{\\text{OR}}=45\\,\\text{ps}$、$t_{\\text{XOR}}=110\\,\\text{ps}$、$t_{\\text{INV}}=20\\,\\text{ps}$。将最坏情况传播延迟建模为关键输入到输出路径上最长逻辑链的延迟之和，并假设所有输入同时变化。\n\n设 $T_{\\text{SOP}}$ 为积之和实现的最坏情况传播延迟，$T_{\\text{XOR}}$ 为您推导的以异或为中心的实现的最坏情况传播延迟。计算标量差 $\\Delta T = T_{\\text{XOR}} - T_{\\text{SOP}}$，并以纳秒为单位表示您的最终答案。将您的答案四舍五入到三位有效数字。", "solution": "我们从具有选择输入 $s$ 和数据输入 $a$、$b$ 的 $2$选$1$多路复用器 (MUX) 的布尔定义开始：\n$$\nz=(s\\land a)\\lor(\\overline{s}\\land b).\n$$\n我们将使用异或（XOR）的基本性质来推导一个等价的以异或为中心的形式。异或运算满足交换律、结合律、单位元性质 $x\\oplus 0=x$ 和自逆性 $x\\oplus x=0$。此外，MUX的语义是：当 $s=0$ 时，输出等于 $b$；当 $s=1$ 时，输出等于 $a$。\n\n考虑候选结构 $b\\oplus\\big(s\\cdot(a\\oplus b)\\big)$，并通过对 $s$ 分情况讨论来验证其等价性：\n- 如果 $s=0$，则\n$$\nb\\oplus\\big(0\\cdot(a\\oplus b)\\big)=b\\oplus 0=b,\n$$\n这与 $z=(0\\land a)\\lor(1\\land b)=b$ 相匹配。\n- 如果 $s=1$，则\n$$\nb\\oplus\\big(1\\cdot(a\\oplus b)\\big)=b\\oplus(a\\oplus b).\n$$\n根据异或的结合律和交换律，\n$$\nb\\oplus(a\\oplus b)=(b\\oplus b)\\oplus a=0\\oplus a=a,\n$$\n这与 $z=(1\\land a)\\lor(0\\land b)=a$ 相匹配。\n\n由于这两个表达式在 $s=0$ 和 $s=1$ 两种情况下结果一致，因此它们对所有输入组合都是等价的。所以，以异或为中心的形式是\n$$\nz=b\\oplus\\big(s\\cdot(a\\oplus b)\\big).\n$$\n\n接下来，我们在给定的门集下，比较积之和 (SOP) 实现和以异或为中心的实现的门深度。\n\n对于积之和实现 $z=(s\\land a)\\lor(\\overline{s}\\land b)$：\n- 从 $s$ 到 $z$ 的路径经过一个反相器以形成 $\\overline{s}$，然后是一个 $2$输入与门，再是一个 $2$输入或门。将每个门计为一级，这条路径的深度为 $3$。\n- 从 $a$ 到 $z$ 的路径经过一个与门再到一个或门，深度为 $2$；类似地，从 $b$ 经过一个与门和一个或门，深度也为 $2$。\n- 电路的门深度是所有输入到输出路径深度的最大值，因此深度为 $3$。\n\n对于以异或为中心的实现 $z=b\\oplus\\big(s\\cdot(a\\oplus b)\\big)$：\n- 计算 $a\\oplus b$ 使用一个异或门（沿 $a$ 和 $b$ 的路径深度为 $1$）。\n- 与 $s$ 的乘积运算在内部异或门之后增加了一个与门，因此沿 $a$（或 $b$）的路径变为异或门再到与门，深度为 $2$；沿 $s$ 的路径目前只有一个与门，深度为 $1$。\n- 与 $b$ 的最终外部异或运算又增加了一级。最长的链是沿 $a$（或内部的 $b$）的路径：内部异或 → 与门 → 外部异或，深度为 $3$。直接输入到外部异或门的 $b$ 只经过该异或门，但电路的整体门深度由最长链决定，因此为 $3$。\n\n因此，两种实现的门深度都为 $3$。\n\n现在我们使用提供的各门延迟来计算最坏情况传播延迟。设 $t_{\\text{AND}}=45\\,\\text{ps}$，$t_{\\text{OR}}=45\\,\\text{ps}$，$t_{\\text{XOR}}=110\\,\\text{ps}$，以及 $t_{\\text{INV}}=20\\,\\text{ps}$。\n\n对于积之和实现，关键路径是从 $s$ 经过反相器、与门和或门：\n$$\nT_{\\text{SOP}}=t_{\\text{INV}}+t_{\\text{AND}}+t_{\\text{OR}}=20\\,\\text{ps}+45\\,\\text{ps}+45\\,\\text{ps}=110\\,\\text{ps}.\n$$\n\n对于以异或为中心的实现，关键路径是从 $a$（或内部的 $b$）经过内部异或门、与 $s$ 进行与运算的与门，然后是外部异或门：\n$$\nT_{\\text{XOR}}=t_{\\text{XOR}}+t_{\\text{AND}}+t_{\\text{XOR}}=110\\,\\text{ps}+45\\,\\text{ps}+110\\,\\text{ps}=265\\,\\text{ps}.\n$$\n\n差值为\n$$\n\\Delta T=T_{\\text{XOR}}-T_{\\text{SOP}}=265\\,\\text{ps}-110\\,\\text{ps}=155\\,\\text{ps}.\n$$\n将皮秒转换为纳秒，使用 $1\\,\\text{ns}=1000\\,\\text{ps}$，\n$$\n\\Delta T=\\frac{155}{1000}\\,\\text{ns}=0.155\\,\\text{ns}.\n$$\n四舍五入到三位有效数字，结果仍为 $0.155\\,\\text{ns}$。\n\n因此，所要求的数值答案（以纳秒为单位）是 $0.155$。", "answer": "$$\\boxed{0.155}$$", "id": "3688749"}, {"introduction": "一个在软件中看似天衣无缝的算法，在硬件中执行时可能会遇到意想不到的挑战。本练习聚焦于著名的“异或交换”算法，要求你从微体系结构的角度分析其在同步数据路径上的执行过程。你将深入研究时序、数据依赖（读后写冒险）和寄存器别名等硬件层面的细节如何影响算法的正确性，这是连接软件思维与硬件现实的关键一步。[@problem_id:3688756]", "problem": "一个同步数据通路由一个位宽为 $n$、拥有两个读端口和一个写端口的寄存器文件，以及一个计算按位异或 (XOR) 的功能单元组成，XOR 运算表示为 $\\,\\oplus\\,$。每个微操作占用一个时钟周期：两个源寄存器的值在周期开始时被读取，而目标寄存器在同一周期结束时被写入。设 $x$ 和 $y$ 是逻辑寄存器名，它们可能指向也可能不指向同一个物理寄存器（别名）。考虑一个旨在交换 $x$ 和 $y$ 的三步序列：\n$x \\leftarrow x \\oplus y$; $y \\leftarrow x \\oplus y$; $x \\leftarrow x \\oplus y$。\n你的任务是从第一性原理出发——即根据 XOR 的按位真值表和同步寄存器读/写语义——来推理该序列在硬件中的正确性和可能存在的冒险。\n\n选择所有正确的陈述。\n\nA. 在所述的单发射、每周期单操作语义下，如果 $x$ 和 $y$ 是不同的物理寄存器，该序列能在 $3$ 个周期内完成一次正确的交换，且无需额外存储空间。如果 $x$ 和 $y$ 是同一物理寄存器的别名，则它们最终都会得到全零值，因为按位运算 $x \\oplus x = 0$。\n\nB. 如果这三个赋值语句被放置在硬件描述语言 (HDL) 的一个时钟块中，并使用非阻塞更新，那么交换操作对所有情况都有效（包括 $x$ 和 $y$ 是别名的情况），因为所有右侧表达式都使用时钟触发前的值，并且同时应用。\n\nC. 如果控制单元错误地在同一个时钟周期内发射前两个赋值操作，导致两个操作的右侧都读取周期前 $x$ 和 $y$ 的值，并且两次写入同时发生，那么从第一次更新 $x$到第二次更新 $y$ 的预期数据相关（流相关）将被破坏，构成写后读 (RAW) 冒险；因此，即使 $x$ 和 $y$ 是不同的寄存器，交换操作也会失败。\n\nD. 当 $x$ 和 $y$ 是别名时，第一个赋值操作实际上是将相同的信号馈入一个异或门的两个输入端；该门对相等的输入输出逻辑高电平，因此寄存器被驱动为全一值而不是零。", "solution": "在进行求解之前，首先严格评估问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n- 数据通路类型：同步。\n- 寄存器文件规格：位宽 $n$，两个读端口，一个写端口。\n- 功能单元：按位异或 (XOR)，表示为 $\\oplus$。\n- 微操作时序：每个操作一个时钟周期。\n- 寄存器读取语义：源寄存器的值在时钟周期开始时被读取。\n- 寄存器写入语义：目标寄存器在同一时钟周期结束时被写入。\n- 逻辑寄存器：$x$ 和 $y$。\n- 别名：$x$ 和 $y$ 可能指向同一个物理寄存器。\n- 操作序列：\n  $1$. $x \\leftarrow x \\oplus y$\n  $2$. $y \\leftarrow x \\oplus y$\n  $3$. $x \\leftarrow x \\oplus y$\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于数字逻辑设计和计算机体系结构的基本原理，特别是同步数据通路、寄存器文件以及异或运算的性质。异或交换是一种众所周知的算法。\n- **定义明确**：问题定义清晰。硬件语义（周期初读取，周期末写入）是明确的，允许对状态演化进行确定性分析。\n- **客观性**：该问题使用了计算机工程领域的精确、标准术语，没有任何主观或模糊的语言。\n- **完整性与一致性**：问题提供了在指定的微架构约束下分析操作序列所需的所有必要信息。给定信息中没有矛盾。例如，每周期单操作模型与拥有两个读端口和一个写端口的寄存器文件是一致的。\n\n### 步骤 3：结论与行动\n问题陈述在科学上是合理的、定义明确且自洽的。这是一个有效的计算机体系结构问题。现在将从第一性原理推导解决方案。\n\n### 从第一性原理推导\n设寄存器的初始值为 $x_{init}$ 和 $y_{init}$。分析将基于同步读/写语义，通过追踪寄存器 $x$ 和 $y$ 在三周期序列中的状态来进行。设 $x_i$ 和 $y_i$ 表示在周期 $i$ *开始*时寄存器的值。\n\n**情况 1：$x$ 和 $y$ 是不同的物理寄存器。**\n- **初始状态（周期 1 开始时）：**\n  - $x_1 = x_{init}$\n  - $y_1 = y_{init}$\n\n- **周期 1：$x \\leftarrow x \\oplus y$**\n  - 周期开始时读取的值：$x_1$ 和 $y_1$。\n  - 计算：$x_1 \\oplus y_1 = x_{init} \\oplus y_{init}$。\n  - 周期结束时写入 $x$ 的值。\n  - **周期 2 开始时的状态：**\n    - $x_2 = x_{init} \\oplus y_{init}$\n    - $y_2 = y_1 = y_{init}$（因为 $y$ 没有被写入）。\n\n- **周期 2：$y \\leftarrow x \\oplus y$**\n  - 周期开始时读取的值：$x_2$ 和 $y_2$。\n  - 计算：$x_2 \\oplus y_2 = (x_{init} \\oplus y_{init}) \\oplus y_{init}$。\n  - 使用异或的性质（$A \\oplus A = 0$ 和 $A \\oplus 0 = A$）：$(x_{init} \\oplus y_{init}) \\oplus y_{init} = x_{init} \\oplus (y_{init} \\oplus y_{init}) = x_{init} \\oplus 0 = x_{init}$。\n  - 周期结束时写入 $y$ 的值。\n  - **周期 3 开始时的状态：**\n    - $x_3 = x_2 = x_{init} \\oplus y_{init}$（因为 $x$ 没有被写入）。\n    - $y_3 = x_{init}$。\n\n- **周期 3：$x \\leftarrow x \\oplus y$**\n  - 周期开始时读取的值：$x_3$ 和 $y_3$。\n  - 计算：$x_3 \\oplus y_3 = (x_{init} \\oplus y_{init}) \\oplus x_{init}$。\n  - 使用异或的性质（$A \\oplus A = 0$ 和 $0 \\oplus B = B$）：$(x_{init} \\oplus y_{init}) \\oplus x_{init} = (x_{init} \\oplus x_{init}) \\oplus y_{init} = 0 \\oplus y_{init} = y_{init}$。\n  - 周期结束时写入 $x$ 的值。\n  - **最终状态（周期 3 结束时）：**\n    - $x$ 的最终值为 $y_{init}$。\n    - $y$ 的最终值为 $x_{init}$（来自周期 2）。\n\n该序列在 3 个周期内正确地交换了 $x$ 和 $y$ 的内容，且无需临时寄存器。\n\n**情况 2：$x$ 和 $y$ 是同一个物理寄存器（例如 $R$）的别名。**\n序列变为：($1$) $R \\leftarrow R \\oplus R$；($2$) $R \\leftarrow R \\oplus R$；($3$) $R \\leftarrow R \\oplus R$。\n\n- **初始状态（周期 1 开始时）：**\n  - $R_1 = R_{init}$\n\n- **周期 1：$R \\leftarrow R \\oplus R$**\n  - 周期开始时读取的值：两个读端口都获取 $R_1 = R_{init}$。\n  - 计算：$R_1 \\oplus R_1 = R_{init} \\oplus R_{init} = 0$（全零值）。\n  - 周期结束时写入 $R$ 的值。\n  - **周期 2 开始时的状态：**\n    - $R_2 = 0$。\n\n- **周期 2：$R \\leftarrow R \\oplus R$**\n  - 读取的值：$R_2=0$。\n  - 计算：$0 \\oplus 0 = 0$。\n  - **周期 3 开始时的状态：**\n    - $R_3 = 0$。\n\n- **周期 3：$R \\leftarrow R \\oplus R$**\n  - 读取的值：$R_3=0$。\n  - 计算：$0 \\oplus 0 = 0$。\n  - **最终状态（周期 3 结束时）：**\n    - $R$ 中的最终值为 $0$。\n\n当 $x$ 和 $y$ 是别名时，寄存器的内容被清零。\n\n### 逐项分析\n\n**A. 在所述的单发射、每周期单操作语义下，如果 $x$ 和 $y$ 是不同的物理寄存器，该序列能在 $3$ 个周期内完成一次正确的交换，且无需额外存储空间。如果 $x$ 和 $y$ 是同一物理寄存器的别名，则它们最终都会得到全零值，因为按位运算 $x \\oplus x = 0$。**\n- **分析：** 这个陈述全面地描述了上述两种情况的结果。情况 1 的推导表明，在 3 个周期内无需额外寄存器即可完成正确的交换。情况 2 的推导表明，别名寄存器的最终值变为全零值，这是异或自反性质（$A \\oplus A = 0$）的直接结果。所提供的推理完全正确。\n- **结论：** **正确**。\n\n**B. 如果这三个赋值语句被放置在硬件描述语言 (HDL) 的一个时钟块中，并使用非阻塞更新，那么交换操作对所有情况都有效（包括 $x$ 和 $y$ 是别名的情况），因为所有右侧表达式都使用时钟触发前的值，并且同时应用。**\n- **分析：** 在像 Verilog 这样的 HDL 中，单个时钟块（`always @(posedge clk)`）内的非阻塞赋值（`=`）会导致所有右侧 (RHS) 表达式都使用时钟周期开始时的值进行求值。然后，结果被调度以同时更新左侧 (LHS) 的变量。然而，在同一个块中对同一个变量 ($x$) 进行两次赋值在标准 HDL 语法中是非法的，并会被综合工具标记为错误。如果我们忽略这一点并尝试解释“同时更新”的概念，那么所有三个 RHS 表达式 ($x \\oplus y$) 都将使用相同的时钟触发前的 $x$ 和 $y$ 值（设为 $x_{pre}$ 和 $y_{pre}$）进行求值。\n  - 对 $y$ 的更新：$y$ 将被更新为 $x_{pre} \\oplus y_{pre}$。\n  - 对 $x$ 的更新：$x$ 也将被更新为 $x_{pre} \\oplus y_{pre}$（假设最后一次对 $x$ 的赋值生效）。\n  - 最终状态将是 $x = x_{pre} \\oplus y_{pre}$ 和 $y = x_{pre} \\oplus y_{pre}$。这不是交换；两个寄存器得到了相同的值。原始值丢失了。该陈述声称交换“对所有情况都有效”是错误的。\n- **结论：** **不正确**。\n\n**C. 如果控制单元错误地在同一个时钟周期内发射前两个赋值操作，导致两个操作的右侧都读取周期前 $x$ 和 $y$ 的值，并且两次写入同时发生，那么从第一次更新 $x$到第二次更新 $y$ 的预期数据相关（流相关）将被破坏，构成写后读 (RAW) 冒险；因此，即使 $x$ 和 $y$ 是不同的寄存器，交换操作也会失败。**\n- **分析：** 正确的顺序执行（$x \\leftarrow x \\oplus y$；然后 $y \\leftarrow x \\oplus y$）在寄存器 $x$ 上存在真数据相关（RAW 冒险）：第二条指令必须在第一条指令写入 $x$ *之后*读取其值。如果两条指令在同一周期内被发射，硬件会在周期开始时为这两条指令读取源操作数。\n  - 设初始值为 $x_0$ 和 $y_0$。\n  - 指令 1 ($x \\leftarrow x \\oplus y$) 读取 $x_0, y_0$ 并计算 $x_0 \\oplus y_0$。\n  - 指令 2 ($y \\leftarrow x \\oplus y$) 读取 $x_0, y_0$ 并计算 $x_0 \\oplus y_0$。\n  第二条指令读取的是旧值 $x_0$，而不是第一条指令正在计算的新值。这是一个典型的 RAW 冒险。在周期结束时，$x$ 和 $y$ 都将被写入相同的值 $x_0 \\oplus y_0$。交换失败。该陈述正确地指出了 RAW 冒险及其后果。请注意，这种情况也会在单个写端口上造成结构冒险，但由 RAW 冒险引起的逻辑失败与此无关，并且足以使操作无效。\n- **结论：** **正确**。\n\n**D. 当 $x$ 和 $y$ 是别名时，第一个赋值操作实际上是将相同的信号馈入一个异或门的两个输入端；该门对相等的输入输出逻辑高电平，因此寄存器被驱动为全一值而不是零。**\n- **分析：** 该陈述正确地观察到当 $x$ 和 $y$ 是别名时，操作 $x \\leftarrow x \\oplus y$ 变为 $x \\leftarrow x \\oplus x$，将相同的信号馈送到异或功能单元的两个输入端。然而，它错误地描述了异或门的行为。异或的真值表规定，当输入相同时输出 $0$（$0 \\oplus 0 = 0$；$1 \\oplus 1 = 0$），输入不同时输出 $1$。对相同输入输出逻辑高电平（$1$）的门是同或门 (XNOR)。因此，$x \\oplus x$ 的结果是按位全零值，而不是全一值。\n- **结论：** **不正确**。", "answer": "$$\\boxed{AC}$$", "id": "3688756"}, {"introduction": "当计算规模从几个比特扩展到数十个比特时，电路的架构选择变得至关重要。这个练习将探讨如何为一个64位的宽数据字计算奇偶校验位，这是纠错码中的一个常见操作。你将对比两种经典的实现架构——简单的串行链式结构和高性能的并行树形结构，并量化分析它们在延迟和资源上的根本性权衡，这个实践清晰地揭示了架构决策如何能够带来数量级的性能差异。[@problem_id:3688782]", "problem": "一个流水线阶段必须计算 $64$ 个独立输入位的奇偶校验值，其中奇偶校验定义为所有 $64$ 个输入的按位异或 (XOR)。正在考虑两种备选的组合拓扑结构，以仅使用双输入异或 (XOR) 门和专用的双路扇出缓冲器来实现奇偶校验功能：\n\n- 涟波异或链：将 $64$ 个输入连接成一个由双输入异或门组成的线性链，使得一个异或门的输出馈送到下一个异或门的一个输入，从而在链的末端产生奇偶校验值。\n\n- Kogge–Stone 风格的异或前缀网络：将 $64$ 个输入安排在一个全并行规约中，其中每个逻辑级通过双输入异或门组合不相交的对，并且每个后续级别组合前一级结果的不相交对，如此继续直到只剩下一个奇偶校验输出。这种规约在每一级对信号进行配对，从而使每级的信号数量减半，直到只剩下一个信号。\n\n假设采用以下延迟模型，该模型包括了使用显式缓冲器来应对有限扇出驱动能力的影响：\n\n- 每个双输入异或门的传播延迟为 $t_{\\text{XOR}} = 80\\,\\text{ps}$，当其输出在下一级中恰好驱动一个门输入时。\n\n- 当一个节点的输出必须驱动下一级中的两个消费者时，使用一个显式的双路扇出缓冲单元。该缓冲器会为该信号的关键路径增加 $t_{b} = 30\\,\\text{ps}$ 的传播延迟。该缓冲器被理想化为产生其输入信号的两个副本，并紧接在产生信号的门之后插入。忽略导线延迟，并假设已选择合适的尺寸，使得当使用缓冲器强制实现双路扇出时，$t_{\\text{XOR}}$ 与负载无关。\n\n- 在涟波异或链中，每个异或输出只驱动下一级的一个异或输入，因此关键路径上任何地方都不需要扇出缓冲器。\n\n- 在 Kogge–Stone 风格的异或前缀网络中，关键路径上有 $\\lceil \\log_{2}(64) \\rceil$ 个逻辑级的双输入异或门。此外，在前 $\\lceil \\log_{2}(64) \\rceil - 1$ 个级别中的每一个级别，路径上的节点的输出都必须被复制以供应给下一级的两个消费者，因此在每个这些级别之后，关键路径上都恰好有一个延迟为 $t_{b}$ 的双路扇出缓冲器。最后一级的输出直接产生奇偶校验结果，不需要复制。\n\n仅使用异或 (XOR) 操作的定义以及关键路径延迟作为任何输入到输出路径上门延迟最大总和的概念，推导出每种拓扑的关键路径延迟，然后计算涟波链关键路径延迟与 Kogge–Stone 风格前缀网络关键路径延迟的比率。将最终比率表示为一个无单位的精确值。", "solution": "$64$ 个输入的奇偶校验是结合组合 $x_{0} \\oplus x_{1} \\oplus \\cdots \\oplus x_{63}$，其中 $\\oplus$ 表示异或 (XOR)。因为异或运算满足结合律和交换律，我们可以将该函数实现为线性链（涟波）或并行规约（前缀/树）。关键路径延迟是速度最慢的输入到输出路径所经过的所有元件的延迟之和。\n\n首先，考虑涟波异或链。要使用双输入异或门在线性链中对 $64$ 个输入进行异或运算，我们需要 $64 - 1 = 63$ 个顺序连接的异或门。每个异或门的输出只驱动下一个门的一个输入，因此关键路径上不需要扇出缓冲器。根据给定的延迟模型，涟波关键路径延迟为\n$$\nD_{\\text{ripple}} \\;=\\; 63 \\cdot t_{\\text{XOR}} \\;=\\; 63 \\cdot 80\\,\\text{ps} \\;=\\; 5040\\,\\text{ps}.\n$$\n\n接下来，考虑 Kogge–Stone 风格的异或前缀网络。一个在每一级将信号数量减半的全并行规约，在关键路径上需要 $\\lceil \\log_{2}(64) \\rceil$ 个级别的双输入异或门。由于 $64 = 2^{6}$，我们有\n$$\n\\lceil \\log_{2}(64) \\rceil \\;=\\; 6.\n$$\n因此，关键路径上有 $6$ 个异或逻辑级。根据所述约束，在前 $6 - 1 = 5$ 个级别中的每一个级别，路径上的节点的输出都必须被复制以驱动下一级的两个消费者，因此在每个这些级别之后，关键路径上都存在一个延迟为 $t_{b}$ 的双路扇出缓冲器。最终（第六个）异或级别的输出产生奇偶校验值，并且不被复制。\n\n因此，Kogge–Stone 风格的关键路径延迟是 $6$ 个异或延迟和 $5$ 个缓冲器延迟的总和：\n$$\nD_{\\text{KS}} \\;=\\; 6 \\cdot t_{\\text{XOR}} \\;+\\; 5 \\cdot t_{b}\n\\;=\\; 6 \\cdot 80\\,\\text{ps} \\;+\\; 5 \\cdot 30\\,\\text{ps}\n\\;=\\; 480\\,\\text{ps} \\;+\\; 150\\,\\text{ps}\n\\;=\\; 630\\,\\text{ps}.\n$$\n\n最后，所要求的涟波链关键路径延迟与 Kogge–Stone 风格关键路径延迟的比率为\n$$\n\\frac{D_{\\text{ripple}}}{D_{\\text{KS}}}\n\\;=\\;\n\\frac{5040\\,\\text{ps}}{630\\,\\text{ps}}\n\\;=\\;\n8.\n$$\n根据要求，该比率为精确值且无量纲。", "answer": "$$\\boxed{8}$$", "id": "3688782"}]}