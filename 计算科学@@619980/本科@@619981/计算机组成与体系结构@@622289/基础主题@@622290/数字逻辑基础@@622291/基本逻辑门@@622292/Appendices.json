{"hands_on_practices": [{"introduction": "将布尔函数的规格说明转化为高效的电路是数字设计中的一项基本技能。本练习将引导你使用卡诺图进行逻辑化简，推导出最小的和之积（SOP）与积之和（POS）形式。通过比较这两种形式在门级实现上的成本，你将获得关于逻辑等价结构如何影响硬件复杂度的实践经验。[@problem_id:3622497]", "problem": "考虑布尔函数 $f(A,B,C,D)$，其中最小项由二进制码 $ABCD$ 索引，$A$ 为最高有效位。On-set (开集，即 $f=1$ 的集合) 为最小项集合 $\\{4,5,8,9,10,11,12,13,14,15\\}$，无关项集为 $\\{2,3\\}$，而 Off-set (关集，即 $f=0$ 的集合) 由其余的最小项组成。\n\n使用一个4变量卡诺图 (Karnaugh map (K-map)) 和标准的邻接规则，推导 $f$ 的最小积之和 (SOP) 范式和最小和之积 (POS) 范式，并考虑给定的无关项条件。\n\n然后，在以下门级约束和定义下实现每种范式：\n- 仅可使用2输入 $\\land$ (与) 门、2输入 $\\lor$ (或) 门和1输入 $\\lnot$ (非) 门。\n- 主输入仅以非反向形式提供；任何反向文字 $X'$ 必须通过一个作用于 $X$ 的独立 $\\lnot$ 门来实现。\n- 一个反向信号 (例如 $\\lnot C$) 可以在任何使用它的地方共享；不要不必要地重复使用反相器。\n- SOP 范式应严格实现为一个积项的 $\\lor$ 运算，其中每个积项由2输入 $\\land$ 门的树形结构构成；POS 范式应严格实现为一个和项的 $\\land$ 运算，其中每个和项由2输入 $\\lor$ 门的树形结构构成。\n- 门数是所使用的 $\\land$、$\\lor$ 和 $\\lnot$ 门的总数。\n- 逻辑深度定义为从任一主输入到输出的路径上门级的最大数量，路径上遇到的每个 $\\lnot$ 门计为深度1，每个 $\\land$ 或 $\\lor$ 门计为深度1。导线贡献的深度为零。\n\n计算每种实现 (SOP 和 POS) 的 $\\land$、$\\lor$ 和 $\\lnot$ 门的总数以及最坏情况下的逻辑深度。最后，报告以下单一数量\n$$\\Delta \\equiv N_{\\text{gates}}^{\\text{POS}} - N_{\\text{gates}}^{\\text{SOP}},$$\n其中 $N_{\\text{gates}}$ 表示门的总数 ($\\land+\\lor+\\lnot$)。无需四舍五入；提供一个精确的整数作为最终答案。", "solution": "用户希望找出给定布尔函数的最小积之和 (SOP) 与最小和之积 (POS) 实现之间的门数差异。\n\n### 步骤 1：问题验证\n\n首先，我将验证问题陈述。\n\n**1.1. 提取给定条件**\n- **函数**：一个4变量布尔函数 $f(A,B,C,D)$。\n- **索引**：最小项由二进制码 $ABCD$ 索引，$A$ 为最高有效位 (MSB)。\n- **On-Set (开集，即 $f=1$ 的最小项)**：$S_m = \\{4, 5, 8, 9, 10, 11, 12, 13, 14, 15\\}$。\n- **无关项集**：$S_d = \\{2, 3\\}$。\n- **Off-Set (关集，即 $f=0$ 的最小项)**：来自 $\\{0, 1, \\dots, 15\\}$ 的其余最小项。\n- **任务**：使用4变量卡诺图 (K-map) 推导 $f$ 的最小 SOP 和 POS 范式。\n- **实现约束**：\n  - 可用门：2输入 $\\land$ (与)、2输入 $\\lor$ (或)、1输入 $\\lnot$ (非)。\n  - 主输入 ($A,B,C,D$) 为非反向形式。反向文字 ($\\lnot X$) 需要一个 $\\lnot$ 门。\n  - 反相器可以共享。\n  - SOP 实现：积项的 $\\lor$ 运算。每个积项是2输入 $\\land$ 门的树形结构。\n  - POS 实现：和项的 $\\land$ 运算。每个和项是2输入 $\\lor$ 门的树形结构。\n- **度量标准**：\n  - $N_{\\text{gates}}$：$\\land$、$\\lor$ 和 $\\lnot$ 门的总数。\n  - 逻辑深度：任何输入到输出路径上的最大门数。\n- **最终目标**：计算 $\\Delta \\equiv N_{\\text{gates}}^{\\text{POS}} - N_{\\text{gates}}^{\\text{SOP}}$。\n\n**1.2. 使用提取的条件进行验证**\n- **科学依据**：该问题植根于数字逻辑设计的基本原理，特别是布尔代数、卡诺图化简和门级实现。这是计算机工程中一种标准的、完善的问题类型。该问题在科学上是合理的。\n- **适定性**：函数通过其开集、关集和无关项集被完全指定。化简过程是标准的，可以得到一个最小范式（在本例中是唯一的）。门级实现的约束是精确的。最终目标是一个明确定义的计算。该问题是适定的。\n- **客观性**：问题使用正式、客观的语言陈述，没有歧义或主观因素。\n\n**1.3. 结论与行动**\n问题有效。我将继续解决它。\n\n### 步骤 2：卡诺图构建与化简\n\n首先，我们确定关集。所有最小项的集合是 $\\{0, 1, ..., 15\\}$。\n关集 $S_f$ 是 $\\{0, 1, ..., 15\\} \\setminus (S_m \\cup S_d) = \\{0, 1, 6, 7\\}$。\n\n我们为 $f(A,B,C,D)$ 构建一个4变量卡诺图。该图的结构为：变量 $AB$ 代表行，变量 $CD$ 代表列，两者均按格雷码顺序 ($00, 01, 11, 10$) 排列。\n\n卡诺图填充如下：\n- `1` 代表开集中的最小项：$\\{4, 5, 8, 9, 10, 11, 12, 13, 14, 15\\}$\n- `X` 代表无关项集中的最小项：$\\{2, 3\\}$\n- `0` 代表关集中的最小项：$\\{0, 1, 6, 7\\}$\n\n得到的卡诺图是：\n$$\n\\begin{array}{c|c|c|c|c|}\n\\multicolumn{1}{r}{CD}   \\multicolumn{4}{c}{AB} \\\\\n\\multicolumn{1}{r}{}  00  01  11  \\multicolumn{1}{c}{10} \\\\\n\\cline{2-5}\n00  0_{0}  1_{4}  1_{12}  1_{8} \\\\\n\\cline{2-5}\n01  0_{1}  1_{5}  1_{13}  1_{9} \\\\\n\\cline{2-5}\n11  X_{3}  0_{7}  1_{15}  1_{11} \\\\\n\\cline{2-5}\n10  X_{2}  0_{6}  1_{14}  1_{10} \\\\\n\\cline{2-5}\n\\end{array}\n$$\n\n**2.1. 最小积之和 (SOP) 范式**\n我们对 $1$ 进行分组，根据需要使用 $X$，以形成大小为2的幂的最大可能矩形组。\n\n1.  可以通过组合最右边的两列（$AB=11$ 和 $AB=10$）形成一个包含8个项的组，这对应于所有 $A=1$ 的最小项。该组覆盖了最小项 $\\{8,9,10,11,12,13,14,15\\}$。对应的积项是 $A$。\n\n2.  剩余未覆盖的 $1$ 位于最小项 $4$ 和 $5$。我们可以通过包含已覆盖的最小项 $12$ 和 $13$ 来形成一个包含4个项的组。该组覆盖了 $\\{4,5,12,13\\}$。这对应于 $B=1$ 和 $C=0$。积项是 $B \\land (\\lnot C)$，或 $B C'$。\n\n这两个项覆盖了开集中的所有最小项。`A` 是像 $10, 11, 14, 15$ 这些最小项的本质主蕴含项。`BC'` 是最小项 $4$ 和 $5$ 的本质主蕴含项。因此，最小 SOP 表达式是唯一的。\n\n$$f_{SOP}(A,B,C,D) = A \\lor (B \\land C')$$\n\n**2.2. 最小和之积 (POS) 范式**\n为了找到 $f$ 的最小 POS 范式，我们首先通过对卡诺图中的 $0$ 进行分组（并根据需要使用 $X$），来找到其补函数 $\\lnot f$ 的最小 SOP 范式。\n\n1.  可以由最小项 $\\{0,1\\}$ 和无关项 $\\{2,3\\}$ 形成一个包含4个项的组。这对应于 $A=0$ 和 $B=0$ 的区域。积项是 $(\\lnot A) \\land (\\lnot B)$，或 $A'B'$。这是 $\\lnot f$ 的本质主蕴含项，因为它是唯一覆盖最小项 $0$ 和 $1$ 的项。\n\n2.  可以由最小项 $\\{6,7\\}$ 和无关项 $\\{2,3\\}$ 形成另一个包含4个项的组。这对应于 $A=0$ 和 $C=1$ 的区域。积项是 $(\\lnot A) \\land C$，或 $A'C$。这是 $\\lnot f$ 的本质主蕴含项，覆盖了最小项 $6$ 和 $7$。\n\n$\\lnot f$ 的最小 SOP 是：\n$$\\lnot f(A,B,C,D) = (A' \\land B') \\lor (A' \\land C)$$\n\n应用德摩根定律来找到 $f$ 的 POS 范式：\n$$f = \\lnot(\\lnot f) = \\lnot((A' \\land B') \\lor (A' \\land C))$$\n$$f = \\lnot(A' \\land B') \\land \\lnot(A' \\land C)$$\n$$f = (\\lnot(A') \\lor \\lnot(B')) \\land (\\lnot(A') \\lor \\lnot(C))$$\n$$f_{POS}(A,B,C,D) = (A \\lor B) \\land (A \\lor C')$$\n\n### 步骤 3：门级实现分析\n\n我们现在根据给定的约束分析每种最小范式的门数和深度。\n\n**3.1. SOP 实现：$f = A \\lor (B \\land C'$)**\n- **文字**：表达式使用文字 $A$、$B$ 和 $C'$。\n- **非门**：需要一个 $\\lnot$ 门从 $C$ 生成 $C'$。\n  $N_{\\lnot}^{\\text{SOP}} = 1$。\n- **与门**：需要一个2输入 $\\land$ 门用于积项 $B \\land C'$。\n  $N_{\\land}^{\\text{SOP}} = 1$。\n- **或门**：需要一个2输入 $\\lor$ 门用于最终的和 $A \\lor (B \\land C')$。注意 $A$ 是一个单文字项，直接送入 $\\lor$ 门。\n  $N_{\\lor}^{\\text{SOP}} = 1$。\n- **总门数**：\n  $N_{\\text{gates}}^{\\text{SOP}} = N_{\\lnot}^{\\text{SOP}} + N_{\\land}^{\\text{SOP}} + N_{\\lor}^{\\text{SOP}} = 1 + 1 + 1 = 3$。\n- **逻辑深度**：从输入到输出的最长路径是针对输入 $C$ 的路径。\n  路径($C$)：$C \\rightarrow \\lnot \\rightarrow \\land \\rightarrow \\lor \\rightarrow f$。\n  深度为 $1 (\\lnot) + 1 (\\land) + 1 (\\lor) = 3$。\n\n**3.2. POS 实现：$f = (A \\lor B) \\land (A \\lor C'$)**\n- **文字**：表达式使用文字 $A$、$B$ 和 $C'$。\n- **非门**：需要一个 $\\lnot$ 门用于 $C'$。这是共享的。\n  $N_{\\lnot}^{\\text{POS}} = 1$。\n- **或门**：需要两个2输入 $\\lor$ 门用于和项 $(A \\lor B)$ 和 $(A \\lor C')$。\n  $N_{\\lor}^{\\text{POS}} = 2$。\n- **与门**：需要一个2输入 $\\land$ 门用于两个和项的最终乘积。\n  $N_{\\land}^{\\text{POS}} = 1$。\n- **总门数**：\n  $N_{\\text{gates}}^{\\text{POS}} = N_{\\lnot}^{\\text{POS}} + N_{\\lor}^{\\text{POS}} + N_{\\land}^{\\text{POS}} = 1 + 2 + 1 = 4$。\n- **逻辑深度**：最长路径同样是针对输入 $C$ 的路径。\n  路径($C$)：$C \\rightarrow \\lnot \\rightarrow \\lor \\rightarrow \\land \\rightarrow f$。\n  深度为 $1 (\\lnot) + 1 (\\lor) + 1 (\\land) = 3$。\n\n### 步骤 4：最终计算\n\n问题要求计算数量 $\\Delta \\equiv N_{\\text{gates}}^{\\text{POS}} - N_{\\text{gates}}^{\\text{SOP}}$。\n使用计算出的门数：\n$$N_{\\text{gates}}^{\\text{SOP}} = 3$$\n$$N_{\\text{gates}}^{\\text{POS}} = 4$$\n$$\\Delta = 4 - 3 = 1$$", "answer": "$$\\boxed{1}$$", "id": "3622497"}, {"introduction": "在复杂的数字系统中，寻找共享逻辑的机会是实现高效设计的关键。本练习将演示代数分解，这是一种强大的技术，用于识别和重用跨多个函数的公共子表达式。通过量化门数量和逻辑深度的减少，你将看到多级逻辑优化相比于各自独立实现的朴素方法的实际优势。[@problem_id:3622449]", "problem": "考虑同步数据通路中的控制输出 $F_{1}$ 和 $F_{2}$，每个输出都由主输入 $p,q,r,s,t$ 使用布尔运算符 $\\land$ (逻辑与)、$\\lor$ (逻辑或) 和 $\\lnot$ (逻辑非) 表示如下：\n$$\nF_{1} \\;=\\; (\\lnot p \\land q \\land r) \\;\\lor\\; (\\lnot p \\land q \\land s), \\quad\nF_{2} \\;=\\; (\\lnot p \\land q \\land r) \\;\\lor\\; (\\lnot p \\land q \\land t).\n$$\n您将仅使用2输入$\\land$门和$\\lor$门以及1输入$\\lnot$门来实现这些输出。任何信号的扇出不产生门成本。逻辑深度定义为从主输入到给定输出的任何路径上的最大门级数，其中一个$\\lnot$门计为一级，每个2输入$\\land$门或$\\lor$门计为一级。基准实现独立地以其给定的积之和形式构建$F_{1}$和$F_{2}$，并遵循以下约束：在单个函数内部，像$\\lnot p$这样的文字可以扇出而无需额外的门，但任何重复的非文字子表达式（例如$(\\lnot p \\land q)$）在每个乘积项内都需单独重新计算。在基准实现中，不同输出之间不发生共享。\n\n使用布尔代数，从$\\land$和$\\lor$的结合律、交换律和分配律等基本法则出发，执行代数除法以分解出任何公共核，并重构网络，使得共享核只计算一次，并被重用于实现$F_{1}$和$F_{2}$。在相同的门和深度模型下，计算：\n- 从基准实现转换到分解后的共享核实现时，门总数的减少量，以及\n- 两个输出中最大逻辑深度的减少量。\n\n将最终答案表示为一个双元素行矩阵，其中第一个元素等于门数量的减少值，第二个元素等于最大逻辑深度的减少值。无需四舍五入。", "solution": "用户希望分析一个逻辑电路的基准实现和优化实现，并计算门数量和逻辑深度的减少量。\n\n### 问题验证\n\n首先，我将验证问题陈述。\n\n**步骤1：提取已知条件**\n- 控制输出为 $F_{1}$ 和 $F_{2}$。\n- 主输入为 $p, q, r, s, t$。\n- 布尔运算符为 $\\land$ (与)、$\\lor$ (或) 和 $\\lnot$ (非)。\n- 逻辑函数：\n  $$F_{1} \\;=\\; (\\lnot p \\land q \\land r) \\;\\lor\\; (\\lnot p \\land q \\land s)$$\n  $$F_{2} \\;=\\; (\\lnot p \\land q \\land r) \\;\\lor\\; (\\lnot p \\land q \\land t)$$\n- 可用门：2输入$\\land$门、2输入$\\lor$门和1输入$\\lnot$门。\n- 任何信号的扇出成本为0门。\n- 逻辑深度定义为从主输入到输出的任何路径上的最大门级数。\n- 基准实现约束：\n  1. $F_1$ 和 $F_2$ 独立构建。\n  2. 实现遵循给定的积之和形式。\n  3. 一个文字（例如 $\\lnot p$）可以在函数内扇出。\n  4. 任何重复的非文字子表达式（例如 $(\\lnot p \\land q)$）在每次使用时都需重新计算。\n  5. 两个不同输出（$F_1$ 和 $F_2$）之间不共享逻辑。\n- 优化任务：\n  1. 使用布尔代数（结合律、交换律、分配律）进行代数除法。\n  2. 分解出公共核。\n  3. 重构网络，使共享核计算一次并被 $F_1$ 和 $F_2$ 重用。\n- 要求输出：\n  1. 门总数的减少量。\n  2. 两个输出中最大逻辑深度的减少量。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题植根于数字逻辑设计和布尔代数的基本原理，这是计算机工程和计算机科学的核心课题。逻辑门、积之和形式、逻辑深度和因式分解等概念都是标准内容。\n- **问题明确**：该问题提供了明确的布尔函数、对门和成本指标（门数量和深度）的清晰定义，以及对基准和优化实现的具体约束。这种结构确保可以推导出一个唯一的、稳定的、有意义的解。\n- **客观性**：该问题使用精确的数学符号和形式化语言陈述，没有歧义或主观性陈述。\n\n**步骤3：结论与行动**\n问题是有效的。这是一个定义明确且标准的逻辑综合练习。我将继续进行解答。\n\n### 解答\n\n解决方案涉及分析基准实现和优化实现，以确定它们的门数量和逻辑深度。\n\n**1. 基准实现分析**\n\n在基准实现中，$F_1$ 和 $F_2$ 是独立综合的。\n\n**$F_1 = (\\lnot p \\land q \\land r) \\lor (\\lnot p \\land q \\land s)$ 的分析**：\n两个乘积项是 $T_1 = \\lnot p \\land q \\land r$ 和 $T_2 = \\lnot p \\land q \\land s$。\n- 为实现 $T_1$，我们需要使用2输入与门来计算一个3输入与。这需要两个$\\land$门，例如，作为 $((\\lnot p \\land q) \\land r)$。\n  - 一个$\\lnot$门用于$\\lnot p$。\n  - 一个$\\land$门用于 $(\\lnot p \\land q)$。\n  - 第二个$\\land$门用于 $((\\lnot p \\land q) \\land r)$。\n- 为实现 $T_2$，根据问题约束，非文字子表达式 $(\\lnot p \\land q)$ 必须重新计算。文字 $\\lnot p$ 可以从第一次计算中扇出。\n  - 一个$\\land$门用于 $(\\lnot p \\land q)$（重新计算）。\n  - 第二个$\\land$门用于 $((\\lnot p \\land q) \\land s)$。\n- 最后，需要一个$\\lor$门来组合这两个乘积项：$F_1 = T_1 \\lor T_2$。\n\n$F_1$ 的门数量：\n- $\\lnot$门：1个（用于 $\\lnot p$）\n- $\\land$门：2个（用于 $T_1$）+ 2个（用于 $T_2$）= 4个\n- $\\lor$门：1个\n- $F_1$ 的总门数：$1 + 4 + 1 = 6$。\n\n$F_1$ 的逻辑深度：\n逻辑深度是从任何主输入到输出的最长路径。我们追踪从输入 $p$ 开始的路径：\n- 第1级：$p \\to \\lnot p$ ($\\lnot$门)\n- 第2级：$(\\lnot p, q) \\to (\\lnot p \\land q)$ ($\\land$门)\n- 第3级：$((\\lnot p \\land q), r) \\to ((\\lnot p \\land q) \\land r)$ ($\\land$门)\n- 第4级：$((\\lnot p \\land q \\land r), (\\lnot p \\land q \\land s)) \\to F_1$ ($\\lor$门)\n$F_1$ 的最大深度为 $4$。\n\n**$F_2 = (\\lnot p \\land q \\land r) \\lor (\\lnot p \\land q \\land t)$ 的分析**：\n$F_2$ 的结构与 $F_1$ 相同，只是输入 $t$ 替换了 $s$。由于在基准实现中 $F_1$ 和 $F_2$ 之间没有逻辑共享，因此 $F_2$ 的门数量和深度与 $F_1$ 相同。\n- $F_2$ 的总门数：$6$。\n- $F_2$ 的最大深度：$4$。\n\n**基准实现总计**：\n- 总门数量 = ($F_1$ 的门数) + ($F_2$ 的门数) = $6 + 6 = 12$。\n- 最大逻辑深度 = $\\max(\\text{depth of } F_1, \\text{depth of } F_2) = \\max(4, 4) = 4$。\n\n**2. 分解（共享核）实现分析**\n\n我们首先应用布尔代数的分配律 $A \\land B \\lor A \\land C = A \\land (B \\lor C)$ 来分解 $F_1$ 和 $F_2$ 的表达式。\n- 对于 $F_1$：令 $A = (\\lnot p \\land q)$。\n  $F_1 = (\\lnot p \\land q \\land r) \\lor (\\lnot p \\land q \\land s) = (\\lnot p \\land q) \\land (r \\lor s)$。\n- 对于 $F_2$：类似地，\n  $F_2 = (\\lnot p \\land q \\land r) \\lor (\\lnot p \\land q \\land t) = (\\lnot p \\land q) \\land (r \\lor t)$。\n\n要共享的公共核是子表达式 $K = \\lnot p \\land q$。网络被重构以计算一次 $K$ 并重用它。\n\n**共享网络的实现**：\n1. 计算文字 $\\lnot p$：\n   - 一个$\\lnot$门。\n2. 计算共享核 $K = \\lnot p \\land q$：\n   - 一个$\\land$门。此信号扇出到用于 $F_1$ 和 $F_2$ 的逻辑。\n3. 计算 $F_1 = K \\land (r \\lor s)$：\n   - 一个$\\lor$门用于 $(r \\lor s)$。\n   - 一个$\\land$门用于组合 $K$ 和 $(r \\lor s)$。\n4. 计算 $F_2 = K \\land (r \\lor t)$：\n   - 一个$\\lor$门用于 $(r \\lor t)$。\n   - 一个$\\land$门用于组合 $K$ 和 $(r \\lor t)$。\n\n分解实现的门数量：\n- $\\lnot$门：1个（用于 $\\lnot p$）\n- $\\land$门：1个（用于 $K$）+ 1个（用于 $F_1$）+ 1个（用于 $F_2$）= 3个\n- $\\lor$门：1个（用于 $F_1$）+ 1个（用于 $F_2$）= 2个\n- 共享实现的总门数：$1 + 3 + 2 = 6$。\n\n分解实现的逻辑深度：\n- 核 $K$ 的深度：从 $p$ 出发的路径是 $p \\to \\lnot p \\to K$。这条路径有 $2$ 个门级。\n- $F_1 = K \\land (r \\lor s)$ 的深度：深度为 $\\max(\\text{depth of } K, \\text{depth of } (r \\lor s)) + 1$。\n  - $(r \\lor s)$ 的深度为 $1$。\n  - $F_1$ 的深度为 $\\max(2, 1) + 1 = 3$。\n- $F_2 = K \\land (r \\lor t)$ 的深度：深度为 $\\max(\\text{depth of } K, \\text{depth of } (r \\lor t)) + 1$。\n  - $(r \\lor t)$ 的深度为 $1$。\n  - $F_2$ 的深度为 $\\max(2, 1) + 1 = 3$。\n\n**分解实现总计**：\n- 总门数量 = $6$。\n- 最大逻辑深度 = $\\max(\\text{depth of } F_1, \\text{depth of } F_2) = \\max(3, 3) = 3$。\n\n**3. 计算减少量**\n\n我们现在比较基准实现和分解实现。\n\n**门数量减少量**：\n- 基准门数量：$12$。\n- 分解门数量：$6$。\n- 减少量 = (基准数量) - (分解数量) = $12 - 6 = 6$。\n\n**最大逻辑深度减少量**：\n- 基准最大深度：$4$。\n- 分解最大深度：$3$。\n- 减少量 = (基准深度) - (分解深度) = $4 - 3 = 1$。\n\n最终答案是一个双元素行矩阵，分别包含门数量减少值和深度减少值。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n6  1\n\\end{pmatrix}\n}\n$$", "id": "3622449"}, {"introduction": "数字电路通常需要处理特定的数据格式，并对无效输入保持稳健。这个问题要求你设计一个“独热码”（one-hot）到二进制的编码器，这是一个常见的组合逻辑构建模块。除了实现核心功能外，你还将设计一个错误检测机制，从而学习如何创建完整且可靠的数字组件。[@problem_id:3622523]", "problem": "考虑一个独热码到二进制码的编码器，其输入向量为 $\\mathbf{x} = (x_0, x_1, x_2, x_3)$，其中对于 $i \\in \\{0,1,2,3\\}$，每个 $x_i \\in \\{0,1\\}$，并且在有效操作下，恰好有一个 $x_i$ 被置位（等于 $1$）。该编码器产生一个两位二进制输出 $(b_1, b_0)$，其值等于使得 $x_i = 1$ 的索引 $i$（例如，$x_2 = 1$ 意味着 $(b_1, b_0) = (1,0)$）。此外，当输入不是独热码时，即当 $\\sum_{i=0}^{3} x_i \\neq 1$（零条或多于一条线路被置位）时，编码器必须置位一个非法输入标志 $e$。您必须仅使用逻辑与 $\\land$、逻辑或 $\\lor$ 和逻辑非 $\\lnot$ 来实现所有逻辑。\n\n使用的基本定义：逻辑与 $a \\land b$ 等于 $1$ 当且仅当 $a$ 和 $b$ 都等于 $1$；逻辑或 $a \\lor b$ 等于 $1$ 当且仅当 $a$ 或 $b$ 中至少有一个等于 $1$；逻辑非 $\\lnot a$ 等于 $1$ 当且仅当 $a$ 等于 $0$。\n\n选择一个选项，该选项给出了仅使用 $\\land$、$\\lor$ 和 $\\lnot$ 对 $(b_1, b_0)$ 和 $e$ 的正确门级实现，并且在有效独热码输入的假设下是正确的，同时也能正确标记所有非法输入。\n\nA. $b_1 = x_2 \\lor x_3$, $b_0 = x_1 \\lor x_3$, $e = \\lnot(x_0 \\lor x_1 \\lor x_2 \\lor x_3) \\lor (x_0 \\land x_1) \\lor (x_0 \\land x_2) \\lor (x_0 \\land x_3) \\lor (x_1 \\land x_2) \\lor (x_1 \\land x_3) \\lor (x_2 \\land x_3)$\n\nB. $b_1 = x_1 \\lor x_3$, $b_0 = x_2 \\lor x_3$, $e = \\lnot(x_0 \\lor x_1 \\lor x_2 \\lor x_3) \\lor (x_0 \\land x_1) \\lor (x_0 \\land x_2) \\lor (x_0 \\land x_3) \\lor (x_1 \\land x_2) \\lor (x_1 \\land x_3) \\lor (x_2 \\land x_3)$\n\nC. $b_1 = x_2 \\lor x_3$, $b_0 = x_1 \\lor x_3$, $e = (x_0 \\land x_1) \\lor (x_1 \\land x_2) \\lor (x_2 \\land x_3)$\n\nD. $b_1 = x_2 \\lor x_3$, $b_0 = x_1 \\lor x_3$, $e = \\lnot\\big((x_0 \\oplus x_1) \\oplus (x_2 \\oplus x_3)\\big)$, 其中 $\\oplus$ 表示异或", "solution": "我们严格从逻辑与、逻辑或和逻辑非的基本定义出发。独热码输入意味着恰好有一个 $x_i$ 等于 $1$，而其他的都等于 $0$。二进制输出 $(b_1, b_0)$ 必须等于被置位输入线的索引 $i$ 的标准二进制表示，所以：\n- 如果 $x_0 = 1$，那么 $(b_1, b_0) = (0, 0)$。\n- 如果 $x_1 = 1$，那么 $(b_1, b_0) = (0, 1)$。\n- 如果 $x_2 = 1$，那么 $(b_1, b_0) = (1, 0)$。\n- 如果 $x_3 = 1$，那么 $(b_1, b_0) = (1, 1)$。\n\n使用逻辑或的定义，如果一次只能有一个 $x_i$ 为 $1$，那么我们可以将每个输出位实现为那些其对应二进制位等于 $1$ 的输入的逻辑或：\n- 最高有效位 $b_1$ 等于 $1$ 当且仅当被置位的线路是 $x_2$ 或 $x_3$，所以 $b_1 = x_2 \\lor x_3$。\n- 最低有效位 $b_0$ 等于 $1$ 当且仅当被置位的线路是 $x_1$ 或 $x_3$，所以 $b_0 = x_1 \\lor x_3$。\n\n这些结论源于 $\\lor$ 的语义：因为恰好有一个 $x_i$ 等于 $1$，所以 $x_2 \\lor x_3$ 仅在 $x_2 = 1$ 或 $x_3 = 1$ 时等于 $1$，否则等于 $0$；对于 $x_1 \\lor x_3$ 也是如此。\n\n接下来，我们推导一个非法输入标志 $e$，它当且仅当输入不是独热码时置位。输入为独热码当且仅当两个条件同时成立：\n- 至少有一个输入被置位：$(x_0 \\lor x_1 \\lor x_2 \\lor x_3) = 1$。\n- 没有任何一对输入同时被置位：$\\lnot\\big((x_0 \\land x_1) \\lor (x_0 \\land x_2) \\lor (x_0 \\land x_3) \\lor (x_1 \\land x_2) \\lor (x_1 \\land x_3) \\lor (x_2 \\land x_3)\\big) = 1$。\n\n根据逻辑与的定义，独热码谓词是\n$$\n\\text{one\\_hot} \\;=\\; (x_0 \\lor x_1 \\lor x_2 \\lor x_3) \\;\\land\\; \\lnot\\Big( (x_0 \\land x_1) \\lor (x_0 \\land x_2) \\lor (x_0 \\land x_3) \\lor (x_1 \\land x_2) \\lor (x_1 \\land x_3) \\lor (x_2 \\land x_3) \\Big).\n$$\n我们需要非法输入标志 $e$ 在 $\\text{one\\_hot} = 0$ 时恰好置位，所以 $e = \\lnot(\\text{one\\_hot})$。使用逻辑非的定义和关于 $\\land$ 与 $\\lor$ 的德摩根定律：\n$$\ne \\;=\\; \\lnot\\Big( (x_0 \\lor x_1 \\lor x_2 \\lor x_3) \\land \\lnot(P) \\Big) \\;=\\; \\lnot(x_0 \\lor x_1 \\lor x_2 \\lor x_3) \\;\\lor\\; \\lnot\\big(\\lnot(P)\\big) \\;=\\; \\lnot(x_0 \\lor x_1 \\lor x_2 \\lor x_3) \\;\\lor\\; P,\n$$\n其中\n$$\nP \\;=\\; (x_0 \\land x_1) \\lor (x_0 \\land x_2) \\lor (x_0 \\land x_3) \\lor (x_1 \\land x_2) \\lor (x_1 \\land x_3) \\lor (x_2 \\land x_3).\n$$\n这个 $e$ 通过 $\\lnot(x_0 \\lor x_1 \\lor x_2 \\lor x_3)$ 检测“无输入置位”的情况，并通过 $P$ 检测“多输入置位”的情况。\n\n逐个选项分析：\n\n- 选项A：$b_1 = x_2 \\lor x_3$ 和 $b_0 = x_1 \\lor x_3$ 与在独热码假设下推导的二进制编码相匹配。标志 $e$ 等于 $\\lnot(x_0 \\lor x_1 \\lor x_2 \\lor x_3) \\lor P$，这正是上面推导出的代数形式。此选项仅使用 $\\land$、$\\lor$ 和 $\\lnot$，并且对所有非法输入（零个或多于一个输入置位）正确置位 $e$，对有效的独热码输入取消置位 $e$。结论：正确。\n\n- 选项B：错误检测 $e$ 与选项A中正确的形式相同，但输出映射不正确：$b_1 = x_1 \\lor x_3$ 和 $b_0 = x_2 \\lor x_3$ 交换了 $x_1$ 和 $x_2$ 的作用。要看出错误，考虑有效的独热码输入 $x_2 = 1$ 且 $x_0 = x_1 = x_3 = 0$。正确的 $(b_1, b_0)$ 应该是 $(1, 0)$，但此选项给出 $b_1 = x_1 \\lor x_3 = 0$ 和 $b_0 = x_2 \\lor x_3 = 1$，即 $(0, 1)$，这是错误的。结论：错误。\n\n- 选项C：输出映射 $b_1 = x_2 \\lor x_3$ 和 $b_0 = x_1 \\lor x_3$ 是正确的，但非法输入标志 $e = (x_0 \\land x_1) \\lor (x_1 \\land x_2) \\lor (x_2 \\land x_3)$ 是不完整的。它无法检测许多多重置位模式，例如 $x_0 = 1$ 和 $x_2 = 1$（此时 $e = 0$，尽管输入非法，因为没有列出的相邻对被置位），也无法检测“无输入置位”的情况 $x_0 = x_1 = x_2 = x_3 = 0$（此时 $e$ 同样为 $0$，尽管非法）。因此它不满足正确性要求。结论：错误。\n\n- 选项D：输出映射 $b_1 = x_2 \\lor x_3$ 和 $b_0 = x_1 \\lor x_3$ 是正确的，但非法输入标志 $e = \\lnot\\big((x_0 \\oplus x_1) \\oplus (x_2 \\oplus x_3)\\big)$ 使用了异或，即“异或(XOR)”，这违反了“仅使用 $\\land$、$\\lor$、$\\lnot$”的约束。即使不考虑门集的违规，其行为也是错误的：对所有四个输入进行异或运算后再取非，其结果等于 $1$ 当且仅当被置位输入的总数为偶数；这将正确标记 $0$、$2$ 或 $4$ 条线路被置位的情况，但将无法标记 $3$ 条线路被置位的非法情况（奇校验），此时 $e$ 将等于 $0$。因此它不是一个正确的非法输入检测器。结论：错误。\n\n因为只有选项A使用规定的门满足了所需的映射和非法输入检测，所以选项A是唯一正确的选择。", "answer": "$$\\boxed{A}$$", "id": "3622523"}]}