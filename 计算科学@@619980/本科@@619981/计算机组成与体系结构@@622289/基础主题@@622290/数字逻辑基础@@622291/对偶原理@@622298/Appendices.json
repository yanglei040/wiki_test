{"hands_on_practices": [{"introduction": "指令译码的核心是模式匹配。本练习探讨了逻辑上的“不匹配”检测器与“匹配”检测器之间的对偶关系。通过从一个推导另一个，你将直接体验布尔代数中的对偶原理如何指导互补硬件功能的设计。[@problem_id:3668156]", "problem": "中央处理器 (CPU) 通过测试一个运行时位向量是否等于一个固定模式来解码指令字段。设运行时字段为位向量 $\\mathbf{b} = (b_{0}, b_{1}, \\dots, b_{m-1})$，固定模式为 $\\mathbf{p} = (p_{0}, p_{1}, \\dots, p_{m-1})$，其中对于 $i \\in \\{0,1,\\dots,m-1\\}$，每个 $b_{i} \\in \\{0,1\\}$ 且 $p_{i} \\in \\{0,1\\}$。考虑一个由逐位异或构建的不匹配检测器，定义为 $d_{i} = b_{i} \\oplus p_{i}$，以及一个聚合不匹配输出，定义为所有位的结合律逻辑析取，在布尔代数中写作\n$$\nM(\\mathbf{b}, \\mathbf{p}) = \\sum_{i=0}^{m-1} d_{i},\n$$\n其中 $\\sum$ 表示结合律逻辑析取，$\\cdot$ 表示结合律逻辑合取。使用布尔代数的基本定义和定律（包括对偶原理、德摩根定律以及异或和双条件的规范定义），推导对偶匹配检测器 $N(\\mathbf{b}, \\mathbf{p})$，该检测器当且仅当 $\\mathbf{b}$ 的所有位与 $\\mathbf{p}$ 的相应位相匹配时输出 $1$。使用结合律逻辑合取 $\\prod$ 和双条件运算符 $\\leftrightarrow$，或等价地，仅使用 $+$、$\\cdot$ 和 $\\overline{(\\cdot)}$，将 $N(\\mathbf{b}, \\mathbf{p})$ 表示为关于 $\\mathbf{b}$ 和 $\\mathbf{p}$ 的单一闭式解析表达式。你的最终答案必须是单一的解析表达式。不需要数值近似。", "solution": "该问题要求为匹配检测器 $N(\\mathbf{b}, \\mathbf{p})$ 推导一个布尔表达式，该检测器被描述为给定不匹配检测器 $M(\\mathbf{b}, \\mathbf{p})$ 的对偶。推导必须基于布尔代数的原理。\n\n首先，我们对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 运行时位向量：$\\mathbf{b} = (b_{0}, b_{1}, \\dots, b_{m-1})$，其中 $b_{i} \\in \\{0,1\\}$。\n- 固定模式位向量：$\\mathbf{p} = (p_{0}, p_{1}, \\dots, p_{m-1})$，其中 $p_{i} \\in \\{0,1\\}$。\n- 逐位不匹配检测：$d_{i} = b_{i} \\oplus p_{i}$，其中 $\\oplus$ 是异或运算符。\n- 聚合不匹配输出：$M(\\mathbf{b}, \\mathbf{p}) = \\sum_{i=0}^{m-1} d_{i}$，其中 $\\sum$ 表示结合律逻辑析取 (OR)。\n- 结合律逻辑合取 (AND) 用 $\\cdot$ 表示。\n- 所需的匹配检测器 $N(\\mathbf{b}, \\mathbf{p})$ 当且仅当 $\\mathbf{b}$ 的所有位与 $\\mathbf{p}$ 的相应位相匹配时必须输出 $1$。这意味着 $N(\\mathbf{b}, \\mathbf{p}) = 1$ 当且仅当对于所有 $i \\in \\{0, 1, \\dots, m-1\\}$ 都有 $b_i = p_i$。\n- 待使用的工具：对偶原理、德摩根定律、异或 ($\\oplus$) 和双条件 ($\\leftrightarrow$) 的定义。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在数字逻辑和布尔代数方面具有科学依据。问题提法明确，所有必要术语均已定义，目标清晰。语言形式化且客观。该问题不违反任何无效标准。这是一个数字电路设计中的标准问题，可以被形式化并求解以找到唯一的解析表达式。\n\n**步骤 3：结论与行动**\n问题是有效的。我们继续进行求解。\n\n不匹配检测器由 $M(\\mathbf{b}, \\mathbf{p})$ 给出。如果至少有一位不匹配，其输出为 $1$；如果所有位都匹配，其输出为 $0$。\n逐位不匹配检测器 $d_i = b_i \\oplus p_i$ 在 $b_i \\neq p_i$ 时值为 $1$，在 $b_i = p_i$ 时值为 $0$。\n聚合不匹配函数是所有逐位不匹配信号的逻辑或：\n$$\nM(\\mathbf{b}, \\mathbf{p}) = d_0 + d_1 + \\dots + d_{m-1} = \\sum_{i=0}^{m-1} (b_i \\oplus p_i)\n$$\n如果任意 $d_i$ 为 $1$，此函数 $M$ 的值为 $1$，表示存在不匹配。仅当所有 $d_i$ 都为 $0$ 时，其值才为 $0$，表示完全匹配。\n\n问题要求一个匹配检测器 $N(\\mathbf{b}, \\mathbf{p})$，它在完全匹配时输出 $1$，并由此引申，在任何不匹配时输出 $0$。此功能行为恰好是不匹配检测器 $M(\\mathbf{b}, \\mathbf{p})$ 的逻辑非。\n因此，我们可以将匹配检测器定义为：\n$$\nN(\\mathbf{b}, \\mathbf{p}) = \\overline{M(\\mathbf{b}, \\mathbf{p})}\n$$\n代入 $M$ 的表达式：\n$$\nN(\\mathbf{b}, \\mathbf{p}) = \\overline{\\left( \\sum_{i=0}^{m-1} d_i \\right)} = \\overline{d_0 + d_1 + \\dots + d_{m-1}}\n$$\n问题陈述援引了对偶原理和德摩根定律。德摩根定律是对偶原理的直接推论。将德摩根定律应用于 $N$ 的表达式，可以将逻辑和 (OR) 转换为逻辑积 (AND)，并对每一项进行取反：\n$$\nN(\\mathbf{b}, \\mathbf{p}) = \\overline{d_0} \\cdot \\overline{d_1} \\cdot \\dots \\cdot \\overline{d_{m-1}}\n$$\n使用结合律逻辑合取 ($\\prod$) 的表示法，这可以写作：\n$$\nN(\\mathbf{b}, \\mathbf{p}) = \\prod_{i=0}^{m-1} \\overline{d_i}\n$$\n该表达式显示了逻辑结构中的对偶性：用于不匹配检测器的宽或门结构变成了用于匹配检测器的宽与门结构。\n\n现在，我们必须找到取反后的逐位信号 $\\overline{d_i}$ 的表达式。\n已知 $d_i = b_i \\oplus p_i$。那么 $\\overline{d_i} = \\overline{b_i \\oplus p_i}$。\n异或 (XOR) 运算的逻辑非是双条件运算符（也称为等价或同或 (XNOR)），用 $\\leftrightarrow$ 表示。双条件运算符 $A \\leftrightarrow B$ 当且仅当 $A = B$ 时值为 $1$。这恰好是逐位*匹配*检测器的功能。\n所以，$\\overline{d_i} = b_i \\leftrightarrow p_i$。\n\n将此代回我们的 $N(\\mathbf{b}, \\mathbf{p})$ 表达式中：\n$$\nN(\\mathbf{b}, \\mathbf{p}) = \\prod_{i=0}^{m-1} (b_i \\leftrightarrow p_i)\n$$\n此表达式是匹配检测器的最终闭式表示。它表明，当且仅当从 $i=0$ 到 $m-1$ 的所有位的按位匹配都为真时，总体匹配才为真（值为 $1$）。这满足了问题的所有条件。\n\n为求完整，我们也可以仅使用基本运算符 $+$、$\\cdot$ 和 $\\overline{(\\cdot)}$ 来表示。双条件运算符可以定义为 $A \\leftrightarrow B = A B + \\overline{A}\\overline{B}$。因此，$N$ 的表达式也可以写作：\n$$\nN(\\mathbf{b}, \\mathbf{p}) = \\prod_{i=0}^{m-1} (b_i p_i + \\overline{b_i}\\overline{p_i})\n$$\n使用双条件运算符的形式更为紧凑，并直接关联到从不匹配检测器 (XOR) 到匹配检测器 (XNOR/双条件) 的概念转换。", "answer": "$$\n\\boxed{\\prod_{i=0}^{m-1} (b_i \\leftrightarrow p_i)}\n$$", "id": "3668156"}, {"introduction": "在计算机算术中，减法通常通过加法实现，这揭示了一个深刻的对偶性。本练习将引导你推导二进制补码减法中的借位标志 $C_{sub}$ 与底层加法操作的进位标志 $C_{add}$ 之间的精确关系。理解这种 $C_{sub} = \\overline{C_{add}}$ 的对偶性是掌握高效 ALU 设计的关键。[@problem_id:3668114]", "problem": "考虑一个 $n$ 位算术逻辑单元 (ALU)，它使用二进制补码将减法 $A - B$ 实现为加法 $A + \\overline{B} + 1$，其中 $\\overline{B}$ 是 $B$ 的按位取反。设 $A, B \\in \\{0, 1, \\dots, 2^{n} - 1\\}$ 被解释为无符号 $n$ 位整数，并设 $C_{add}$ 表示加法 $A + \\overline{B} + 1$ 从最高有效位 (MSB) 产生的进位输出位。定义减法借位标志 $C_{sub}$：如果在 $A - B$ 中发生借位（等价于 $A  B$），则为 $1$；否则为 $0$。\n\n仅从二进制补码、无符号 $n$ 位范围以及进位和借位的基本定义出发，推导一个完全用 $C_{add}$ 表示借位标志 $C_{sub}$ 的表达式（不显式包含 $A$ 或 $B$）。您必须从二进制算术的第一性原理出发来证明该表达式的合理性。\n\n然后，对于 $n = 8$ 和特定操作数 $A = 0101\\,1110_{2}$ 和 $B = 1010\\,0011_{2}$，使用 $A + \\overline{B} + 1$ 实现来计算 ALU 产生的借位标志 $C_{sub}$ 的值。报告 $C_{sub}$ 的值作为您的最终答案。不需要四舍五入，也不涉及物理单位。", "solution": "1.  问题陈述：从 $C_{add}$ 推导 $C_{sub}$，然后为给定值计算它。\n        2.  通过形式化地定义各个量来开始推导。\n        3.  用 $B$ 和 $n$ 表示 $\\overline{B}$：$\\overline{B} = (2^n - 1) - B$。\n        4.  将此代入 ALU 操作：$A + \\overline{B} + 1 = A + ((2^n - 1) - B) + 1 = A - B + 2^n$。\n        5.  解释 $n$ 位 ALU 执行模 $2^n$ 的加法，而进位输出 $C_{add}$ 是完整整数和中 $2^n$ 项的系数。因此，完整的和是 $C_{add} \\cdot 2^n + (\\text{n-bit result})$。\n        6.  将完整和的两个表达式相等：$A - B + 2^n$。\n        7.  根据 $C_{sub}$ 的定义分析两种情况。\n        8.  情况 1：$A \\ge B$。这意味着 $C_{sub} = 0$。值 $A-B$ 在范围 $[0, 2^n - 1)$ 内。那么 $A - B + 2^n$ 在范围 $[2^n, 2^{n+1} - 1)$ 内。对于此范围内的值，第 $n$ 位（权重为 $2^n$）是 $1$。因此，$C_{add} = 1$。比较可知，如果 $C_{sub}=0$，则 $C_{add}=1$。\n        9.  情况 2：$A  B$。这意味着 $C_{sub} = 1$。值 $A-B$ 在范围 $(-(2^n - 1), 0)$ 内。设 $A-B = -d$，其中 $d0$。那么和为 $2^n - d$。此值在范围 $(0, 2^n)$ 内。对于此范围 $[1, 2^n-1]$ 内的值，第 $n$ 位是 $0$。因此，$C_{add} = 0$。比较可知，如果 $C_{sub}=1$，则 $C_{add}=0$。\n        10. 从这两种情况得出结论：$C_{sub} = \\overline{C_{add}}$。\n        11. 现在，进行 $n=8$ 的具体计算。\n        12. 给出给定值：$A = 0101\\,1110_{2}$ 和 $B = 1010\\,0011_{2}$。\n        13. 要找到 $C_{sub}$，我们必须首先通过运算 $A + \\overline{B} + 1$ 计算出 $C_{add}$。\n        14. 计算 $\\overline{B}$：$\\overline{1010\\,0011_{2}} = 0101\\,1100_{2}$。\n        15. 执行 $8$ 位加法 $S = A + \\overline{B} + 1$：$0101\\,1110_{2} + 0101\\,1100_{2} + 1$。分步显示或使用列式加法。$A + (\\overline{B}+1) = 0101\\,1110_{2} + 0101\\,1101_{2}$。结果是 $1011\\,1011_{2}$。\n        16. 指出最高有效位 (MSB) 的进位输出是 $0$。因此，$C_{add} = 0$。\n        17. 使用推导出的关系：$C_{sub} = \\overline{C_{add}} = \\overline{0} = 1$。\n        18. 这个结果与 $C_{sub}$ 的定义一致，因为简单比较 $A$ 和 $B$ 的无符号值可知 $A  B$。（$A = 94_{10}$，$B=163_{10}$）。这部分是合理性检查，不是主线推理。我会将其包括在内。", "answer": "$$ \\boxed{1} $$", "id": "3668114"}, {"introduction": "CPU 流水线中的控制逻辑是应用对偶原理的一个绝佳场景。本练习要求你为一个流水线设计“冒险”检测逻辑，并推导其对偶的“安全发射”逻辑。通过将抽象的布尔向量应用于实际的指令序列，你将看到对偶性如何直接影响 CPU 的性能和正确性。[@problem_id:3668128]", "problem": "考虑一个标量、顺序、单发射、五级流水线，其阶段包括指令获取 (IF)、指令解码和寄存器读取 (ID)、执行 (EX)、内存访问 (MEM) 和写回 (WB)。该流水线为在执行阶段产生结果的算术和逻辑指令实现了完全旁路 (转发)，但仍然存在加载-使用冒险：如果在执行阶段的指令是加载指令，它将写入其目标寄存器的值要到下一个周期的内存访问阶段结束时才可用，因此紧随其后需要该值的指令无法在下一个周期进入执行阶段。\n\n定义在大小为 $N=8$ 的寄存器文件（寄存器 $r_0,\\dots,r_7$）上的以下布尔向量信号：\n- 周期 $t$ 的读取需求向量 $R_d(t)$，如果在周期 $t$，指令解码和寄存器读取阶段的指令读取寄存器 $r_i$，则其第 $i$ 位置为 $1$，否则为 $0$。\n- 周期 $t$ 的写入待定向量 $W_s(t)$，如果在周期 $t$，执行阶段有一条加载指令将写入寄存器 $r_i$ 并且其值在下一周期的执行阶段不可用，则其第 $i$ 位置为 $1$，否则为 $0$。\n\n按位冒险掩码由布尔合取 $mask(t) = R_d(t) \\cdot W_s(t)$ 定义，其中点表示跨 $N$ 位的按位合取。流水线互锁使用一个对偶的“发射许可”向量 $unmask(t)$ 来决定安全性：当且仅当 $unmask(t)$ 的每一位都为 $1$ 时，才允许在周期 $t$ 发射；否则插入一个单周期气泡，将指令保持在指令解码和寄存器读取阶段，并冻结指令获取。\n\n仅从布尔代数公理和对偶原理出发，推导 $unmask(t)$ 关于 $R_d(t)$ 和 $W_s(t)$ 的表达式，且不引入任何新的原语。然后，应用您推导的 $unmask(t)$，根据所述的流水线规则评估以下指令序列。假设所有算术和逻辑指令在执行阶段产生的结果都可以无停顿地转发；加载-使用冒险是停顿的唯一来源。指令序列如下：\n\n$I_1$: load $r_1 \\leftarrow M[r_2]$  \n$I_2$: add $r_3 \\leftarrow r_1 + r_4$  \n$I_3$: add $r_5 \\leftarrow r_3 + r_6$  \n$I_4$: load $r_3 \\leftarrow M[r_7]$  \n$I_5$: add $r_0 \\leftarrow r_3 + r_1$  \n$I_6$: add $r_7 \\leftarrow r_0 + r_3$\n\n计算完成所有 $6$ 条指令所需的总时钟周期数，包括初始的流水线填充和使用您的 $unmask(t)$ 表达式由互锁引起的任何停顿。将您的最终答案表示为单个整数周期数。无需四舍五入。", "solution": "该问题要求完成两项主要任务：首先，基于对偶原理推导出一个“发射许可”向量 $unmask(t)$ 的表达式；其次，将此逻辑应用于给定的指令序列，以确定以时钟周期为单位的总执行时间。\n\n### 问题验证\n首先，对问题陈述进行验证。\n**已知条件：**\n- 一个标量、顺序、单发射、五级流水线：指令获取 (IF)、指令解码/寄存器读取 (ID)、执行 (EX)、内存访问 (MEM)、写回 (WB)。\n- 对来自 EX 阶段的算术/逻辑指令结果实现完全旁路。\n- 存在加载-使用冒险：来自 EX 阶段 `load` 指令的值在随后的 MEM 阶段结束时才可用，这为依赖该值的指令造成了潜在的单周期停顿。\n- 寄存器文件大小 $N=8$，寄存器 $r_0, \\dots, r_7$。\n- 读取需求向量 $R_d(t)$：如果在周期 $t$，ID 阶段的指令读取寄存器 $r_i$，则第 $i$ 位为 $1$。\n- 写入待定向量 $W_s(t)$：如果在周期 $t$，EX 阶段的 `load` 指令将写入寄存器 $r_i$，则第 $i$ 位为 $1$。\n- 冒险掩码：$mask(t) = R_d(t) \\cdot W_s(t)$，其中 $\\cdot$ 是按位布尔合取 (AND)。\n- 发射许可向量：$unmask(t)$，被描述为 $mask(t)$ 的“对偶”。\n- 停顿条件：如果 $unmask(t)$ 的并非每一位都为 $1$，则插入一个单周期气泡。当且仅当 $unmask(t)$ 的所有位都为 $1$ 时，才允许发射。\n- 指令序列：\n  $I_1$: `load r1 ← M[r2]`\n  $I_2$: `add r3 ← r1 + r4`\n  $I_3$: `add r5 ← r3 + r6`\n  $I_4$: `load r3 ← M[r7]`\n  $I_5$: `add r0 ← r3 + r1`\n  $I_6$: `add r7 ← r0 + r3`\n\n**验证结论：**\n该问题在科学上是合理的、定义明确且客观的。它使用标准模型和术语描述了计算机体系结构中的一个典型问题（流水线冒险检测）。布尔向量和对偶原理的使用与数字逻辑设计相关，而数字逻辑设计是计算机硬件的基础。该问题是自洽的，并提供了足够的信息来推导出唯一、可验证的解。因此，该问题是**有效的**。\n\n### 第一部分：`unmask(t)` 向量表达式的推导\n\n任务的核心是使用对偶原理推导 $unmask(t)$ 的表达式。让我们将冒险和发射条件形式化。\n\n如果 ID 阶段的指令需要读取一个寄存器，而该寄存器是当前处于 EX 阶段的 `load` 指令的目的寄存器，则会发生加载-使用冒险。\n用给定的向量表示：\n- $R_{d,i}(t) = 1$ 表示 ID 阶段的指令读取寄存器 $r_i$。\n- $W_{s,i}(t) = 1$ 表示 EX 阶段的 `load` 指令写入寄存器 $r_i$。\n\n如果这两个条件同时满足，即冒险掩码的第 $i$ 位 $mask_i(t) = R_{d,i}(t) \\cdot W_{s,i}(t)$ 为 $1$，则对特定寄存器 $r_i$ 存在冒险。\n\n如果对*任何*寄存器存在冒险，流水线就必须停顿。这对应于 $mask(t)$ 向量中至少有一位为 $1$ 的情况。总的停顿信号 $S(t)$ 可以表示为 $mask(t)$ 向量的或-归约：\n$$S(t) = \\bigvee_{i=0}^{N-1} mask_i(t) = \\bigvee_{i=0}^{N-1} (R_{d,i}(t) \\cdot W_{s,i}(t))$$\n如果 $S(t)=1$，则发生停顿。\n\n问题陈述中提到，当且仅当 $unmask(t)$ 的所有位都为 $1$ 时，才允许发射。这个全局“发射许可”信号 $P(t)$ 是 $unmask(t)$ 向量的与-归约：\n$$P(t) = \\bigwedge_{i=0}^{N-1} unmask_i(t)$$\n如果 $P(t)=1$，则允许发射。\n\n逻辑上，当且仅当没有停顿条件时，才允许发射。因此，$P(t) = \\neg S(t)$。\n$$P(t) = \\neg \\left( \\bigvee_{i=0}^{N-1} (R_{d,i}(t) \\cdot W_{s,i}(t)) \\right)$$\n布尔代数中的对偶原理指出，交换与 ($\\cdot$) 和或 ($+$) 运算符，以及单位元 $0$ 和 $1$，可以将一个有效的表达式转换为其对偶表达式。该原理的一个直接推论是德摩根定律。将德摩根定律应用于 $P(t)$ 的表达式：\n$$P(t) = \\bigwedge_{i=0}^{N-1} \\neg(R_{d,i}(t) \\cdot W_{s,i}(t))$$\n我们现在有两个关于全局发射许可信号 $P(t)$ 的表达式：\n$$P(t) = \\bigwedge_{i=0}^{N-1} unmask_i(t) = \\bigwedge_{i=0}^{N-1} \\neg(R_{d,i}(t) \\cdot W_{s,i}(t))$$\n为了使这个等式对任何输入向量组合都成立，我们必须使每一位都相等：\n$$unmask_i(t) = \\neg(R_{d,i}(t) \\cdot W_{s,i}(t))$$\n这是按位布尔与非 (NAND) 运算。以向量形式，对偶“发射许可”向量的表达式是冒险掩码向量的按位取反：\n$$unmask(t) = \\neg mask(t) = \\neg(R_d(t) \\cdot W_s(t))$$\n在单位表达式上使用德摩根定律，我们也可以写成 $unmask_i(t) = \\neg R_{d,i}(t) + \\neg W_{s,i}(t)$。\n\n### 第二部分：流水线执行分析\n\n我们现在分析给定指令序列的执行，以确定总的时钟周期数。停顿的唯一来源是加载-使用冒险。算术逻辑单元 (ALU) 到 ALU 的依赖（例如，一条 `add` 指令后跟着另一条使用其结果的 `add` 指令）由于“完全旁路 (转发)”而不会导致停顿。加载-使用依赖（例如，一条 `load` 指令后跟着一条使用加载值的 `add` 指令）会产生一个周期的停顿。\n\n序列中的依赖关系如下：\n1.  $I_1 \\rightarrow I_2$：`load r1` 之后是 `add r3 ← r1 ...`。这是一个加载-使用依赖。预计会发生停顿。\n2.  $I_2 \\rightarrow I_3$：`add r3` 之后是 `add r5 ← r3 ...`。这是一个 ALU-ALU 依赖。由于转发，不会停顿。\n3.  $I_4 \\rightarrow I_5$：`load r3` 之后是 `add r0 ← r3 ...`。这是一个加载-使用依赖。预计会发生停顿。\n4.  $I_5 \\rightarrow I_6$：`add r0` 之后是 `add r7 ← r0 ...`。这是一个 ALU-ALU 依赖。由于转发，不会停顿。\n5.  $I_4 \\rightarrow I_6$：`load r3` 之后是 `add r7 ← ... r3`。$I_6$ 需要 $r_3$ 的值。这个依赖通过寄存器文件的写/读时序解决，不会产生停顿。\n\n让我们逐周期地跟踪流水线执行。`*` 表示 ID 阶段指令的停顿周期。\n\n| 周期 | $I_1$ (load) | $I_2$ (add) | $I_3$ (add) | $I_4$ (load) | $I_5$ (add) | $I_6$ (add) | 注释 |\n|:-----:|:------------:|:-----------:|:-----------:|:------------:|:-----------:|:-----------:|:-------------------------------------------|\n| 1     | IF           |             |             |              |             |             |                                            |\n| 2     | ID           | IF          |             |              |             |             |                                            |\n| 3     | EX           | ID          | IF          |              |             |             | $I_2$ 读取 $r_1$，而 $I_1$ 是 EX 阶段的 `load` 指令。**停顿**。 |\n| 4     | MEM          | ID*         | IF          |              |             |             | $I_2$ 停顿。气泡进入 EX 阶段。           |\n| 5     | WB           | EX          | ID          | IF           |             |             | $I_2$ 继续执行。$r_1$ 从 $I_1$ 转发。    |\n| 6     |              | MEM         | EX          | ID           | IF          |             | $r_3$ 从 $I_2$ 转发到 $I_3$。         |\n| 7     |              | WB          | MEM         | EX           | ID          | IF          | $I_5$ 读取 $r_3$，而 $I_4$ 是 EX 阶段的 `load` 指令。**停顿**。 |\n| 8     |              |             | WB          | MEM          | ID*         | IF          | $I_5$ 停顿。气泡进入 EX 阶段。           |\n| 9     |              |             |             | WB           | EX          | ID          | $I_5$ 继续执行。$r_3$ 从 $I_4$ 转发。    |\n| 10    |              |             |             |              | MEM         | EX          | $r_0$ 从 $I_5$ 转发到 $I_6$。         |\n| 11    |              |             |             |              | WB          | MEM         |                                            |\n| 12    |              |             |             |              |             | WB          | $I_6$ 完成。                           |\n\n在一个 $m=5$ 级流水线中处理 $k=6$ 条指令的基准周期数为 $m-1+k = 5-1+6 = 10$ 个周期。\n确定了两个加载-使用冒险：\n1.  $I_2$ 对 $I_1$ 的依赖导致一个停顿周期（在周期 4）。\n2.  $I_5$ 对 $I_4$ 的依赖导致一个停顿周期（在周期 8）。\n\n每次停顿都会使总执行时间增加一个周期。\n总周期数 = 基准周期数 + 停顿周期数\n总周期数 = $10 + 2 = 12$。\n\n最后一条指令 $I_6$ 在周期 $12$ 的末尾完成其 WB 阶段。因此，所需的总时钟周期数为 $12$。", "answer": "$$\\boxed{12}$$", "id": "3668128"}]}