{"hands_on_practices": [{"introduction": "编写中断服务程序（ISR）的首要原则是确保其正确性。本练习将探讨在处理具有副作用的内存映射I/O（MMIO）和电平触发中断时，如何设计一个健壮的ISR。你将需要从基本原理出发，仔细考虑竞争条件、可重入性以及内存排序问题，以保证每个设备事件都被精确地处理一次，不多也不少 ([@problem_id:3653019])。", "problem": "一个计算机系统使用中断服务程序（ISR）分派来处理来自外设的事件，该外设暴露了内存映射输入/输出（MMIO）寄存器。该外设实现了以下具有科学上真实行为的内存映射寄存器：\n\n- 位于地址 $A_D$ 的数据寄存器，每次 MMIO 读取时返回下一个事件的有效负载，并具有读副作用：每次读取恰好消耗一个事件，并将待处理计数 $N$ 减 $1$。如果 $N=0$，对 $A_D$ 的读取在架构上是未定义的，必须避免。\n- 位于地址 $A_S$ 的状态寄存器，其位 $RDY$ 当且仅当 $N>0$ 时被设置；读取 $A_S$ 没有副作用。\n- 位于地址 $A_M$ 的中断屏蔽寄存器，写入值 $1$ 会屏蔽设备中断，写入值 $0$ 则取消屏蔽。\n- 位于地址 $A_E$ 的中断结束（End-of-Interrupt）寄存器，写入值 $1$ 会向中断控制器发送 EOI 信号。\n\n当 $RDY=1$ 时，设备会触发一个电平触发的中断线。中央处理器（CPU）运行一个单生产者/单消费者驱动程序，其中 ISR 是生产者，负责将有效负载入队到一个带有头指针 $h$ 和尾指针 $t$ 的环形缓冲区 $Q$ 中，而一个用户线程是消费者。发布步骤定义为将有效负载写入 $Q[h]$，然后以释放语义（release semantics）原子性地增加 $h$。\n\n该架构的内存模型是松散的：在没有显式屏障的情况下，普通内存操作和 MMIO 操作可能会被重排序。存在一个屏障 $B()$，它保证所有先前的 MMIO 读取操作在任何后续的普通内存存储操作对其他核心或线程可见之前完成。$h$ 的原子性增量对普通内存具有释放语义，但如果没有显式的 $B()$，它不意味着相对于 MMIO 的排序。\n\n“恰好一次消费”定义为设备事件和软件入队之间随时间推移的一一映射关系：对于在时间 $t$ 对 $N$ 贡献 $+1$ 的每个设备事件，ISR 最终会将恰好一个对应的有效负载入队到 $Q$ 中并发布一次，没有重复也没有丢失，即使在 ISR 执行期间有新事件到达。\n\n你需要从第一性原理出发，对中断、MMIO、读副作用、电平触发和内存排序进行推理。考虑以下候选的 ISR，它们以有序步骤表示，并选择能保证“恰好一次消费”且避免竞争、可重入性危险和排序违规的设计。\n\n选项 A：\n- 向 $A_M$ 写入 $1$ 以屏蔽设备中断。\n- 当 $\\text{mmio\\_read}(A_S)$ 指示 $RDY=1$ 时，循环执行：\n  - 令 $d \\leftarrow \\text{mmio\\_read}(A_D)$。\n  - 调用 $B()$。\n  - 将 $d$ 写入 $Q[h]$。\n  - 以释放语义原子性地增加 $h$。\n- 向 $A_E$ 写入 $1$ 以发送 EOI。\n- 向 $A_M$ 写入 $0$ 以取消屏蔽设备中断。\n\n选项 B：\n- 立即向 $A_E$ 写入 $1$ 以发送 EOI。\n- 不屏蔽设备；当 $\\text{mmio\\_read}(A_S)$ 指示 $RDY=1$ 时循环执行：\n  - 令 $d \\leftarrow \\text{mmio\\_read}(A_D)$。\n  - 将 $d$ 写入 $Q[h]$。\n  - 以释放语义原子性地增加 $h$。\n  - 调用 $B()$。\n- 始终不屏蔽设备。\n\n选项 C：\n- 向 $A_M$ 写入 $1$ 以屏蔽设备中断。\n- 读取 $\\text{mmio\\_read}(A_S)$ 一次；如果 $RDY=1$：\n  - 令 $d \\leftarrow \\text{mmio\\_read}(A_D)$。\n  - 将 $d$ 写入 $Q[h]$。\n  - 以释放语义原子性地增加 $h$。\n- 向 $A_E$ 写入 $1$ 以发送 EOI。\n- 向 $A_M$ 写入 $0$ 以取消屏蔽设备中断。\n\n选项 D：\n- 向 $A_M$ 写入 $1$ 以屏蔽设备中断。\n- 从 $\\text{mmio\\_read}(A_S)$ 读取一个就绪计数的近似值 $c$（假设 $c$ 反映了该瞬间待处理事件的数量）。\n- 对于 $i$ 从 $1$ 到 $c$ 循环：\n  - 令 $d \\leftarrow \\text{mmio\\_read}(A_D)$。\n  - 将 $d$ 写入 $Q[h]$。\n  - 以释放语义原子性地增加 $h$。\n- 循环结束后调用一次 $B()$。\n- 向 $A_E$ 写入 $1$ 以发送 EOI。\n- 向 $A_M$ 写入 $0$ 以取消屏蔽设备中断。\n\n在所述假设下，哪个选项能确保“恰好一次消费”并防止竞争和排序违规？选择唯一的最佳答案。\n\nA. 选项 A\nB. 选项 B\nC. 选项 C\nD. 选项 D", "solution": "这个问题的结论是选项 A 是唯一正确的设计。\n\n为了从第一性原理推导出这个结论，我们必须分析系统中的四个关键挑战：电平触发中断、MMIO 读副作用、可重入性和弱内存排序。一个健壮的 ISR 必须同时正确处理这四个问题。\n\n1.  **电平触发中断（Level-triggered Interrupts）**：设备只要满足条件（$RDY=1$），就会持续地触发中断信号。因此，ISR 不仅仅是响应一次中断，它有责任通过处理所有待办事件来使中断信号无效（即让 $RDY$ 变为 0）。如果 ISR 退出时 $RDY$ 仍然为 1，中断会立即再次触发，可能导致“中断风暴”，耗尽 CPU 资源。这意味着 ISR 必须在一个循环中处理事件，直到状态寄存器 $A_S$ 显示 $RDY=0$ 为止。\n\n2.  **MMIO 读副作用（Read Side-effects）**：每次从数据寄存器 $A_D$ 读取都会消耗一个事件。因此，在读取 $A_D$ 之前，必须先检查状态寄存器 $A_S$ 以确认确实有事件待处理（$RDY=1$）。否则，当 $N=0$ 时读取 $A_D$ 会导致未定义的行为。\n\n3.  **可重入性（Reentrancy）**：如果一个 ISR 正在执行时，同一个中断再次发生并抢占了它，这就构成了可重入。由于该 ISR 会修改共享数据（环形缓冲区的头指针 $h$），可重入会导致竞争条件，损坏数据结构。防止这种情况的经典方法是在 ISR 的入口处屏蔽（mask）来自该设备的中断，并在出口处取消屏蔽（unmask）。\n\n4.  **内存排序（Memory Ordering）**：系统内存模型是松散的，MMIO 操作和普通内存操作可能被重排序。消费者线程通过检查头指针 $h$ 来决定是否从缓冲区 $Q$ 读取数据。我们必须确保当消费者看到新的 $h$ 值时，对应的数据 $d$ 已经安全地写入了 $Q[h]$。问题中描述的屏障 $B()$ 保证了所有先前的 MMIO 读操作在后续的普通内存写操作对其他线程可见之前完成。因此，$B()$ 必须在 MMIO 读取 $d$ 之后，但在将 $d$ 写入 $Q$ 或发布新的 $h$ 之前被调用。\n\n现在，我们用这些原则来评估每个选项：\n\n- **选项 A**：\n    - **屏蔽中断**：向 $A_M$ 写入 1，正确地防止了可重入。\n    - **循环处理**：`while (RDY==1)` 循环确保了所有待处理的事件都被处理，正确地应对了电平触发中断。\n    - **安全读取**：在循环内部，先检查 $RDY$ 再读取 $A_D$，避免了对空设备进行读取。\n    - **内存排序**：在读取 $d$ 之后、写入 $Q$ 之前调用 $B()$。这确保了在消费者看到更新的 $h$ 并尝试读取 `Q[h]` 之前，从 $A_D$ 读取的数据 $d$ 已经通过了总线并到达了内存/缓存，可以被写入 $Q$。这是正确的排序。\n    - **EOI 和取消屏蔽**：在循环之后发送 EOI 并取消屏蔽中断，这是正确的清理顺序。\n    - **结论**：此选项正确地处理了所有四个挑战。\n\n- **选项 B**：\n    - **立即发送 EOI**：这是一个严重错误。由于 $RDY$ 可能仍然为 1，中断控制器会立即看到一个仍然有效的中断请求，导致 ISR 在返回后立即被再次调用，形成中断风暴。\n    - **不屏蔽中断**：这使得 ISR 是可重入的，对共享的 $h$ 和 $Q$ 存在竞争条件风险。\n    - **内存排序**：在发布 $h$ 之后调用 $B()$ 是错误的。它不能保证数据 $d$ 在 $h$ 更新对消费者可见之前被写入 $Q$。\n    - **结论**：此选项在多个方面都是不安全的。\n\n- **选项 C**：\n    - **仅处理一次**：该 ISR 只检查一次 $RDY$ 并最多处理一个事件。如果在处理期间有新事件到达（或者原本就有多个事件），ISR 退出时 $RDY$ 仍将为 1，导致中断风暴。这是处理电平触发中断的典型错误。\n    - **结论**：此选项不能保证正确性。\n\n- **选项 D**：\n    - **读取近似计数 $c$**：这是一个不稳定的策略。在读取 $c$ 和处理事件之间，新的事件可能已经到达。循环只会处理 $c$ 个事件，可能会留下未处理的事件，导致 $RDY$ 保持为 1 和中断风暴。\n    - **内存排序**：在循环之后只调用一次 $B()$ 是不正确的。屏障必须在每次发布新数据之前确保对应的 MMIO 读取已完成。对于循环中的每一次迭代，都存在一次 MMIO 读和一次数据发布，因此屏障应该在循环内部。\n    - **结论**：此选项既不可靠也不正确。\n\n综上所述，只有选项 A 提供了保证“恰好一次消费”且在所有方面都健壮的实现。", "answer": "$$\\boxed{A}$$", "id": "3653019"}, {"introduction": "一个正确的ISR还必须是高效的，尤其是在实时系统中。本练习将重点从逻辑正确性转向定量性能分析。你将学习如何通过计算来确定一个ISR在满足长期CPU占用率预算和硬实时截止时间这两个约束条件下，所能承担的最大计算工作量 ([@problem_id:3653028])。这项技能对于设计响应迅速且可靠的嵌入式系统至关重要。", "problem": "一个微控制器为一个周期性传感器执行中断驱动的输入/输出。中央处理器（CPU）的时钟频率为 $100\\,\\mathrm{MHz}$。一个硬件计时器以 $1\\,\\mathrm{kHz}$ 的频率触发一个传感器采样中断服务程序（ISR），使得中断之间的周期为 $1\\,\\mathrm{ms}$。系统施加了两个约束条件：\n- 长期 CPU 时间预算：在任何时间间隔内，传感器 ISR（包括其固定的进入/退出开销）最多只能消耗总 CPU 时间的 $B$ 部分。这里，$B = 0.18$。\n- 硬实时截止期限：每次 ISR 调用都必须在其 $1\\,\\mathrm{ms}$ 的周期结束前完成，即使在最坏的情况下，系统中其他地方的中断被临时禁用长达 $120\\,\\mu\\mathrm{s}$。\n\n假设每次中断有 $800$ 个周期的固定开销，用于中断进入/退出以及强制性的寄存器保存/恢复，这必须计入 ISR 的时间使用中。ISR 内所有剩余的周期都可用于应用程序的传感器处理计算。\n\n仅从 CPU 利用率（在一个时间间隔内 CPU 时间的分数）、截止期限可行性（在最坏情况延迟下于周期结束前完成执行）以及时间与周期通过 CPU 频率的关系这些核心定义出发，确定每次中断可以在 ISR 计算主体（不包括固定的 $800$ 周期开销）中花费的最大周期数 $C_{\\max}$，同时满足预算和截止期限两个约束条件。\n\n用周期数表示每次中断允许的最终计算量 $C_{\\max}$。在你的答案中报告一个精确的整数周期数。最终答案中不要包含任何单位。", "solution": "该问题要求找到中断服务程序（ISR）的最大计算周期数，记为 $C_{\\max}$，该周期数需满足两个约束条件：长期 CPU 利用率预算和硬实时截止期限。我们首先正式定义系统参数和约束条件。\n\n给定的参数如下：\n- CPU 时钟频率：$f_{CPU} = 100\\,\\mathrm{MHz} = 100 \\times 10^6\\,\\mathrm{Hz}$\n- 中断频率：$f_{ISR} = 1\\,\\mathrm{kHz} = 1 \\times 10^3\\,\\mathrm{Hz}$\n- CPU 时间预算分数：$B = 0.18$\n- 最坏情况下的中断延迟：$T_{latency} = 120\\,\\mu\\mathrm{s} = 120 \\times 10^{-6}\\,\\mathrm{s}$\n- ISR 固定开销：$C_{overhead} = 800$ 周期\n\n根据中断频率，我们可以确定中断之间的周期：\n$$ T_{ISR} = \\frac{1}{f_{ISR}} = \\frac{1}{1 \\times 10^3\\,\\mathrm{Hz}} = 10^{-3}\\,\\mathrm{s} = 1\\,\\mathrm{ms} $$\n\n设 $C_{comp}$ 为 ISR 内可用于应用程序计算的周期数。单次 ISR 调用消耗的总周期数是开销和计算周期之和：\n$$ C_{total} = C_{overhead} + C_{comp} $$\n\n一次 ISR 调用的总执行时间通过 CPU 频率与总周期数相关：\n$$ T_{exec} = \\frac{C_{total}}{f_{CPU}} = \\frac{C_{overhead} + C_{comp}}{f_{CPU}} $$\n\n我们现在将分析这两个约束条件中的每一个，以找到 $C_{comp}$ 的最大允许值。最终答案 $C_{\\max}$ 将是这两个限制中最严格的一个。\n\n约束条件 1：长期 CPU 时间预算\nISR 的长期 CPU 利用率不得超过预算分数 $B$。CPU 利用率 $U$ 是 CPU 忙于执行 ISR 的时间分数。在一个周期 $T_{ISR}$ 内，这是 ISR 的执行时间 $T_{exec}$ 与周期 $T_{ISR}$ 的比率。\n$$ U = \\frac{T_{exec}}{T_{ISR}} \\le B $$\n\n代入 $T_{exec}$ 和 $T_{ISR}$ 的表达式：\n$$ \\frac{\\left(\\frac{C_{overhead} + C_{comp}}{f_{CPU}}\\right)}{\\left(\\frac{1}{f_{ISR}}\\right)} \\le B $$\n$$ \\frac{(C_{overhead} + C_{comp}) \\cdot f_{ISR}}{f_{CPU}} \\le B $$\n\n我们求解这个不等式，以得到预算所允许的最大 $C_{comp}$，我们称之为 $C_{comp, budget}$。\n$$ C_{overhead} + C_{comp, budget} \\le \\frac{B \\cdot f_{CPU}}{f_{ISR}} $$\n$$ C_{comp, budget} \\le \\frac{B \\cdot f_{CPU}}{f_{ISR}} - C_{overhead} $$\n\n代入给定的数值：\n$$ C_{comp, budget} \\le \\frac{0.18 \\cdot (100 \\times 10^6\\,\\mathrm{Hz})}{1 \\times 10^3\\,\\mathrm{Hz}} - 800 $$\n$$ C_{comp, budget} \\le \\frac{18 \\times 10^6}{1 \\times 10^3} - 800 $$\n$$ C_{comp, budget} \\le 18000 - 800 $$\n$$ C_{comp, budget} \\le 17200\\,\\text{cycles} $$\n\n约束条件 2：硬实时截止期限\n截止期限要求每次 ISR 调用在下一次中断发生前完成，即在周期 $T_{ISR}$ 内完成。这必须在最坏的情况下也成立，即 ISR 的开始被最大中断延迟 $T_{latency}$ 所延迟。\n\n从 ISR 实际开始执行的时刻算起，可用于 ISR 执行的时间是周期持续时间减去延迟：\n$$ T_{available} = T_{ISR} - T_{latency} $$\n\nISR 的总执行时间 $T_{exec}$ 必须小于或等于这个可用时间：\n$$ T_{exec} \\le T_{available} $$\n$$ \\frac{C_{overhead} + C_{comp}}{f_{CPU}} \\le T_{ISR} - T_{latency} $$\n\n我们求解这个不等式，以得到截止期限所允许的最大 $C_{comp}$，我们称之为 $C_{comp, deadline}$。\n$$ C_{overhead} + C_{comp, deadline} \\le (T_{ISR} - T_{latency}) \\cdot f_{CPU} $$\n$$ C_{comp, deadline} \\le (T_{ISR} - T_{latency}) \\cdot f_{CPU} - C_{overhead} $$\n\n代入给定的数值：\n$$ T_{ISR} - T_{latency} = (1 \\times 10^{-3}\\,\\mathrm{s}) - (120 \\times 10^{-6}\\,\\mathrm{s}) = (1000 \\times 10^{-6}\\,\\mathrm{s}) - (120 \\times 10^{-6}\\,\\mathrm{s}) = 880 \\times 10^{-6}\\,\\mathrm{s} $$\n现在，我们可以计算周期的限制：\n$$ C_{comp, deadline} \\le (880 \\times 10^{-6}\\,\\mathrm{s}) \\cdot (100 \\times 10^6\\,\\mathrm{Hz}) - 800 $$\n$$ C_{comp, deadline} \\le (880 \\times 100) - 800 $$\n$$ C_{comp, deadline} \\le 88000 - 800 $$\n$$ C_{comp, deadline} \\le 87200\\,\\text{cycles} $$\n\n最终确定\n计算周期数 $C_{comp}$ 必须同时满足两个约束条件。因此，最大允许周期数 $C_{\\max}$ 是从每个约束条件推导出的限制中的最小值。\n$$ C_{\\max} = \\min(C_{comp, budget}, C_{comp, deadline}) $$\n$$ C_{\\max} = \\min(17200, 87200) $$\n$$ C_{\\max} = 17200 $$\n\n因此，在满足预算和截止期限两个约束条件的情况下，可以在 ISR 计算主体中花费的最大周期数是 $17200$。在此系统中，预算约束是更具限制性的条件。", "answer": "$$\\boxed{17200}$$", "id": "3653028"}, {"introduction": "即使是精心设计的软件也可能出现故障，例如ISR陷入死循环。最后的这个练习将介绍如何通过看门狗定时器（Watchdog Timer）来提升系统的可靠性，以捕获并处理ISR锁死等故障。你需要运用最坏情况下的时序分析来设置一个安全的超时阈值，并设计一个稳健的恢复流程，从而确保系统能够优雅地从故障中恢复 ([@problem_id:3652973])。", "problem": "一个嵌入式控制器使用中断驱动的输入/输出，其中一个硬件传感器产生周期性中断，由一个中断服务程序 (ISR) 进行服务。必须定期服务（“喂狗”）看门狗定时器 (WDT) 以表明其活性；如果 WDT 在超时期限内未被服务，它将触发一个不可屏蔽事件。当前设计在每次 ISR 成功执行结束时服务 WDT。您需要选择一个 WDT 超时时间和安全的恢复路径，以捕捉 ISR 锁定问题，同时避免误报。\n\n在正常操作期间，系统表现出以下经过充分测试的行为边界：\n- 传感器产生的中断标称周期为 $T_{irq} = 4.8\\,\\mathrm{ms}$，正抖动最高可达 $\\Delta = 0.4\\,\\mathrm{ms}$，因此正常情况下的最长到达间隔为 $T_{irq}^{\\max} = T_{irq} + \\Delta$。\n- 在原子临界区期间，全局中断可能被屏蔽长达 $B = 12\\,\\mathrm{ms}$。\n- 中断解除屏蔽后，更高优先级的活动可能会使 ISR 调度延迟长达 $P = 3.0\\,\\mathrm{ms}$，并且调度器开销贡献了 $S = 0.2\\,\\mathrm{ms}$。\n- ISR 的最坏情况执行时间为 $W = 1.1\\,\\mathrm{ms}$。\n- 系统定时器分辨率为 $R_t = 0.1\\,\\mathrm{ms}$，在推导时间间隔时应作为余量包含在内。\n\n安全性和可用性要求规定，任何 ISR 锁定必须在 $T_{\\text{detect}}^{\\max} = 25\\,\\mathrm{ms}$ 内被检测和处理，并且恢复过程必须避免完整的系统复位，使设备静默以防止进一步数据损坏，保留诊断日志，并重新建立正常的中断驱动操作。假设看门狗定时器可以配置为在第一次超时时引发一个不可屏蔽中断 (NMI)，而不是立即执行系统复位。\n\n根据第一性原理，WDT 超时时间 $T_{wd}$ 必须严格大于在无故障条件下可能出现的连续两次 WDT 服务之间的最长时间间隔，并且小于或等于 $T_{\\text{detect}}^{\\max}$。哪个选项最能满足这些约束？\n\nA. 设置 $T_{wd} = 8\\,\\mathrm{ms}$；超时后，立即复位整个系统。\n\nB. 设置 $T_{wd} = 15\\,\\mathrm{ms}$；超时后，仅重新启用全局中断并从故障处理程序返回以继续正常操作。\n\nC. 设置 $T_{wd} = 22\\,\\mathrm{ms}$；超时后，引发一个不可屏蔽中断 (NMI)，该中断调用一个故障处理程序，该程序记录故障、清空出站 I/O 队列、停止所有直接内存访问 (DMA) 引擎并将设备置于有文档记录的静默状态，仅对 I/O 子系统执行有针对性的软复位，重新安装并重新启用 ISR，在恢复前发布一个内存屏障，然后返回正常操作。\n\nD. 设置 $T_{wd} = 30\\,\\mathrm{ms}$；超时后，屏蔽中断，自旋等待设备清除其状态，然后解除中断屏蔽。", "solution": "用户要求我验证并解决一个关于为中断驱动的嵌入式系统选择看门狗定时器 (WDT) 超时时间和恢复策略的问题。\n\n### 问题验证\n\n首先，我必须仔细验证问题陈述。\n\n#### 步骤 1：提取给定条件\n从问题陈述中逐字提取的数据：\n- **标称中断周期**：$T_{irq} = 4.8\\,\\mathrm{ms}$\n- **正中断抖动**：$\\Delta = 0.4\\,\\mathrm{ms}$\n- **最长到达间隔时间**：$T_{irq}^{\\max} = T_{irq} + \\Delta$\n- **最大中断屏蔽时间**：$B = 12\\,\\mathrm{ms}$\n- **更高优先级任务的最大抢占延迟**：$P = 3.0\\,\\mathrm{ms}$\n- **调度器开销**：$S = 0.2\\,\\mathrm{ms}$\n- **ISR 最坏情况执行时间**：$W = 1.1\\,\\mathrm{ms}$\n- **系统定时器分辨率（余量）**：$R_t = 0.1\\,\\mathrm{ms}$\n- **允许的锁定检测最长时间**：$T_{\\text{detect}}^{\\max} = 25\\,\\mathrm{ms}$\n- **WDT 服务点**：每次 ISR 成功执行结束时。\n- **WDT 机制**：可配置为引发不可屏蔽中断 (NMI)。\n- **恢复要求**：必须 (1) 避免完整系统复位，(2) 使设备静默，(3) 保留诊断日志，以及 (4) 重新建立正常操作。\n- **核心约束**：WDT 超时时间 $T_{wd}$ 必须严格大于 WDT 服务之间的最长无故障间隔，并且小于或等于 $T_{\\text{detect}}^{\\max}$。\n\n#### 步骤 2：使用提取的给定条件进行验证\n- **科学依据**：该问题基于实时系统分析的基本和标准原理，包括中断响应时间计算和看门狗定时器等容错机制。所有概念在计算机工程中都是标准的，并且内部一致。\n- **适定性**：该问题是适定的。它提供了计算 WDT 服务之间最坏情况时间所需的所有定量数据。恢复路径的定性要求清晰具体，可以对选项进行客观评估。\n- **客观性**：语言精确、技术性强，没有主观性。\n\n该问题通过了所有验证检查。未发现任何缺陷。这是一个嵌入式系统设计中标准的、可解决的问题。\n\n#### 步骤 3：结论与行动\n此问题是**有效的**。我将继续推导解决方案。\n\n### 解决方案推导\n\n主要任务是确定 WDT 超时时间 $T_{wd}$ 的有效范围。该范围由一个下界和一个上界定义。\n\n1.  **$T_{wd}$ 的上界**：\n    问题指出，任何 ISR 锁定都必须在 $T_{\\text{detect}}^{\\max} = 25\\,\\mathrm{ms}$ 内被检测到。WDT 超时是用于此检测的机制。因此，超时值必须小于或等于此最大允许时间。\n    $$T_{wd} \\le 25\\,\\mathrm{ms}$$\n\n2.  **$T_{wd}$ 的下界**：\n    超时时间 $T_{wd}$ 必须严格大于在正常（无故障）条件下，WDT 两次连续服务之间的最大可能时间间隔。这可以防止误报，即即使系统正常运行，WDT 也会触发。设这个最大间隔为 $T_{interval}^{\\max}$。\n\n    WDT 在每次 ISR 完成时被服务。我们需要找到一个 ISR（例如 $ISR_n$）的完成与下一个 ISR（$ISR_{n+1}$）的完成之间的最大可能时间。设 $A_k$ 是中断 $IRQ_k$ 的到达时间，$C_k$ 是 $ISR_k$ 的完成时间。该时间间隔为 $C_{n+1} - C_n$。\n\n    为了最大化此间隔，我们构建一个最坏情况场景：\n    - $IRQ_n$ 和 $IRQ_{n+1}$ 的到达间隔被最大化。\n    - $ISR_n$ 的响应时间（从 $A_n$ 到 $C_n$）被最小化。\n    - $ISR_{n+1}$ 的响应时间（从 $A_{n+1}$ 到 $C_{n+1}$）被最大化。\n\n    该间隔可以表示为：\n    $$T_{interval}^{\\max} = (A_{n+1} - A_n)_{\\max} + (C_{n+1} - A_{n+1})_{\\max} - (C_n - A_n)_{\\min}$$\n\n    我们来计算每一项：\n    - **最大到达间隔时间**：问题明确定义其为 $T_{irq}^{\\max} = T_{irq} + \\Delta$。\n      $$T_{irq}^{\\max} = 4.8\\,\\mathrm{ms} + 0.4\\,\\mathrm{ms} = 5.2\\,\\mathrm{ms}$$\n    - **最大 ISR 响应时间 ($T_{resp}^{\\max}$)**：这是最大调度延迟和最坏情况执行时间的总和。最大延迟发生在中断被屏蔽最长时间 ($B$)，然后被更高优先级任务延迟 ($P$)，再加上调度器开销 ($S$)。\n      $$T_{resp}^{\\max} = B + P + S + W$$\n      $$T_{resp}^{\\max} = 12\\,\\mathrm{ms} + 3.0\\,\\mathrm{ms} + 0.2\\,\\mathrm{ms} + 1.1\\,\\mathrm{ms} = 16.3\\,\\mathrm{ms}$$\n    - **最小 ISR 响应时间 ($T_{resp}^{\\min}$)**：这发生在最小延迟（仅调度器开销 $S$）和最小执行时间的情况下。问题未给出最佳情况执行时间；对此分析，一个标准且安全的假设是其可以忽略不计 ($W_{\\min} \\approx 0$)。\n      $$T_{resp}^{\\min} = S + W_{\\min} \\approx 0.2\\,\\mathrm{ms} + 0\\,\\mathrm{ms} = 0.2\\,\\mathrm{ms}$$\n\n    现在，我们计算 WDT 服务之间的最大间隔：\n    $$T_{interval}^{\\max} = T_{irq}^{\\max} + T_{resp}^{\\max} - T_{resp}^{\\min}$$\n    $$T_{interval}^{\\max} = 5.2\\,\\mathrm{ms} + 16.3\\,\\mathrm{ms} - 0.2\\,\\mathrm{ms} = 21.3\\,\\mathrm{ms}$$\n\n    最后，我们必须将定时器分辨率余量 $R_t = 0.1\\,\\mathrm{ms}$ 加到此值上，以创建对抗量化误差的安全边际。WDT 超时必须严格大于此结果。\n    $$T_{wd} > T_{interval}^{\\max} + R_t = 21.3\\,\\mathrm{ms} + 0.1\\,\\mathrm{ms} = 21.4\\,\\mathrm{ms}$$\n\n3.  **$T_{wd}$ 的有效范围**：\n    结合下界和上界，我们得到：\n    $$21.4\\,\\mathrm{ms}  T_{wd} \\le 25\\,\\mathrm{ms}$$\n\n### 逐项分析\n\n现在我将根据推导出的超时范围和问题的恢复要求来评估每个选项。\n\n**A. 设置 $T_{wd} = 8\\,\\mathrm{ms}$；超时后，立即复位整个系统。**\n- **超时值**：$T_{wd} = 8\\,\\mathrm{ms}$。这不在有效范围 $(21.4\\,\\mathrm{ms}, 25\\,\\mathrm{ms}]$ 内。$8\\,\\mathrm{ms}$ 的超时远短于最大正常间隔 $21.4\\,\\mathrm{ms}$，这必然导致虚假的 WDT 事件和系统不稳定。\n- **恢复路径**：完整的系统复位违反了“避免完整系统复位”的明确要求。\n- **结论**：**不正确**。\n\n**B. 设置 $T_{wd} = 15\\,\\mathrm{ms}$；超时后，仅重新启用全局中断并从故障处理程序返回以继续正常操作。**\n- **超时值**：$T_{wd} = 15\\,\\mathrm{ms}$。这不在有效范围 $(21.4\\,\\mathrm{ms}, 25\\,\\mathrm{ms}]$ 内。这个超时太短，会导致误报。\n- **恢复路径**：此路径根本上是不安全的。如果 ISR 真的锁定了（例如，在一个无限的 `while(1)` 循环中），从 NMI 处理程序返回将恢复被锁定的 ISR，导致 WDT 立即被重新触发。它没有解决根本问题。\n- **结论**：**不正确**。\n\n**C. 设置 $T_{wd} = 22\\,\\mathrm{ms}$；超时后，引发一个不可屏蔽中断 (NMI)，该中断调用一个故障处理程序，该程序记录故障、清空出站 I/O 队列、停止所有直接内存访问 (DMA) 引擎并将设备置于有文档记录的静默状态，仅对 I/O 子系统执行有针对性的软复位，重新安装并重新启用 ISR，在恢复前发布一个内存屏障，然后返回正常操作。**\n- **超时值**：$T_{wd} = 22\\,\\mathrm{ms}$。该值满足推导出的约束条件 $21.4\\,\\mathrm{ms}  22\\,\\mathrm{ms} \\le 25\\,\\mathrm{ms}$。这是一个安全且有效的超时。\n- **恢复路径**：此路径是对恢复要求的全面而稳健的实现。它正确地记录诊断信息（“保留诊断日志”），将 I/O 带入安全状态（“使设备静默”），避免灾难性故障（“避免完整系统复位”），并正确采取步骤恢复功能（“重新建立正常...操作”）。此恢复策略的各个方面都是健全的，并与容错嵌入式系统的最佳实践保持一致。\n- **结论**：**正确**。\n\n**D. 设置 $T_{wd} = 30\\,\\mathrm{ms}$；超时后，屏蔽中断，自旋等待设备清除其状态，然后解除中断屏蔽。**\n- **超时值**：$T_{wd} = 30\\,\\mathrm{ms}$。这违反了上界要求 $T_{wd} \\le 25\\,\\mathrm{ms}$。系统将无法满足其指定的故障最大检测时间。\n- **恢复路径**：此路径设计不当。在高优先级的 NMI 处理程序内部屏蔽中断并进入自旋等待，很可能会冻结整个系统，从而杜绝任何恢复的机会。这与安全恢复路径背道而驰。\n- **结论**：**不正确**。", "answer": "$$\\boxed{C}$$", "id": "3652973"}]}