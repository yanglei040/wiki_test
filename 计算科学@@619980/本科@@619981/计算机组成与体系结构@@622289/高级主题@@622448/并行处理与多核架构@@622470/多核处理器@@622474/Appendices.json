{"hands_on_practices": [{"introduction": "伪共享（False Sharing）是多核编程中一个隐蔽的性能陷阱。当逻辑上独立的变量恰好位于同一缓存行时，一个核心对其中一个变量的写操作会使其他核心的缓存行副本失效，从而引发不必要的缓存一致性流量。本练习将通过一个具体的场景，让你亲手计算如何通过数据填充（padding）来对齐数据结构，确保每个线程的私有数据都独占一个缓存行，这是多核性能调优中一项基础而关键的技能 [@problem_id:3661029]。", "problem": "一个在共享内存多核处理器上运行的并行应用程序使用一个每线程记录的数组，每个线程一个记录，这些记录在内存中连续存储。为了在具有大小为 $L$ 的缓存行的高速缓存一致性协议下防止伪共享，记录大小可以通过附加 $p$ 字节的尾部填充来增加，以确保每个记录都从一个独立的缓存行开始。分配器返回一个数组的基地址，该地址对齐到 $L$ 字节的缓存行边界。\n\n每个记录按所列顺序包含以下C语言风格的字段，具有指定的尺寸和自然对齐要求（假设在一个常规的应用程序二进制接口中，每个字段都对齐到其自身的大小，最大为8字节，并且总记录大小向上取整为任何字段所使用的最大对齐值的倍数）：\n- 一个64位浮点值（大小8字节，对齐8字节），\n- 一个64位无符号整数（大小8字节，对齐8字节），\n- 一个32位有符号整数（大小4字节，对齐4字节），\n- 一个16位有符号整数（大小2字节，对齐2字节），\n- 一个8位无符号整数（大小1字节，对齐1字节），\n- 一个3字节的数组（大小3字节，对齐1字节）。\n\n设 $s$ 表示记录在经过字段对齐所需的内部填充以及为满足记录自身的对齐要求而向上取整后的大小（以字节为单位）。设 $p$ 为附加到每个记录的尾部填充字节数，以使数组中每个记录的起始地址都位于一个独立的缓存行上。\n\n给定 $L = 64$ 字节，确定最小的非负整数 $p$（以字节为单位），该值能保证当数组连续布局时，每个记录都从一个新的缓存行开始。用一个数字表示你的答案（以字节为单位）。", "solution": "该问题要求我们确定需要添加到数据记录中的最小非负尾部填充 $p$，以确保连续数组中的每个记录都从一个新的缓存行开始。解决方案包括两个主要步骤：首先，计算考虑了内部填充和对齐规则后的记录大小 $s$；其次，使用 $s$ 和缓存行大小 $L$ 来推导 $p$ 的条件并找到其最小值。\n\n第1部分：计算未填充的记录大小 $s$。\n大小 $s$ 由记录内字段的布局、它们各自的对齐要求以及记录结构本身的最终对齐要求决定。我们按顺序计算每个字段的偏移量，假设记录从偏移量 $0$ 开始。字段的偏移量必须是其对齐要求的倍数。\n\n字段按顺序给出其大小和对齐要求：\n1.  `field1`：一个64位浮点数（大小8字节，对齐8字节）。\n    从偏移量 $0$ 开始。占据字节 $[0, 7]$。下一个可用偏移量是 $8$。\n2.  `field2`：一个64位无符号整数（大小8字节，对齐8字节）。\n    下一个偏移量 $8$ 是对齐要求 $8$ 的倍数。它从偏移量 $8$ 开始。占据字节 $[8, 15]$。下一个可用偏移量是 $16$。\n3.  `field3`：一个32位有符号整数（大小4字节，对齐4字节）。\n    下一个偏移量 $16$ 是对齐要求 $4$ 的倍数。它从偏移量 $16$ 开始。占据字节 $[16, 19]$。下一个可用偏移量是 $20$。\n4.  `field4`：一个16位有符号整数（大小2字节，对齐2字节）。\n    下一个偏移量 $20$ 是对齐要求 $2$ 的倍数。它从偏移量 $20$ 开始。占据字节 $[20, 21]$。下一个可用偏移量是 $22$。\n5.  `field5`：一个8位无符号整数（大小1字节，对齐1字节）。\n    下一个偏移量 $22$ 是对齐要求 $1$ 的倍数。它从偏移量 $22$ 开始。占据字节 $22$。下一个可用偏移量是 $23$。\n6.  `field6`：一个3字节的数组（大小3字节，对齐1字节）。\n    下一个偏移量 $23$ 是对齐要求 $1$ 的倍数。它从偏移量 $23$ 开始。占据字节 $[23, 25]$。下一个可用偏移量是 $26$。\n\n在布局完所有字段后，总占用空间为 $26$ 字节。然而，问题指出，总记录大小 $s$ 必须向上取整为任何字段所使用的最大对齐值的倍数。字段的对齐要求分别为 $8$、$8$、$4$、$2$、$1$ 和 $1$ 字节。这些值中的最大值为 $8$ 字节。\n因此，$s$ 必须是大于或等于 $26$ 的 $8$ 的最小倍数。\n$8$ 的倍数是 $8, 16, 24, 32, \\dots$。大于等于 $26$ 的最小的 $8$ 的倍数是 $32$。\n因此，未填充的记录大小为 $s = 32$ 字节。\n\n第2部分：计算最小尾部填充 $p$。\n一个填充后记录的总大小是 $S' = s + p$。这些记录连续存储在一个数组中，其基地址 $A_{base}$ 对齐到 $L = 64$ 字节的缓存行边界。这意味着 $A_{base}$ 是 $L$ 的倍数。\n数组中第 $i$ 个记录（对于 $i \\ge 0$）的地址由 $A_i = A_{base} + i \\cdot S'$ 给出。\n条件是每个记录都从一个独立的缓存行开始。地址 $A$ 的缓存行索引是 $\\lfloor \\frac{A}{L} \\rfloor$。因此，我们要求对于任何 $i \\neq j$ 都有 $\\lfloor \\frac{A_i}{L} \\rfloor \\neq \\lfloor \\frac{A_j}{L} \\rfloor$。由于地址随 $i$ 单调递增，这等效于要求每个记录的缓存行索引严格大于前一个记录的缓存行索引：\n$$ \\left\\lfloor \\frac{A_{i+1}}{L} \\right\\rfloor > \\left\\lfloor \\frac{A_i}{L} \\right\\rfloor \\quad \\text{for all } i \\ge 0 $$\n代入 $A_i$ 的表达式：\n$$ \\left\\lfloor \\frac{A_{base} + (i+1)S'}{L} \\right\\rfloor > \\left\\lfloor \\frac{A_{base} + iS'}{L} \\right\\rfloor $$\n由于 $A_{base}$ 是 $L$ 的倍数，设 $A_{base} = k \\cdot L$，其中 $k$ 为某个整数。不等式变为：\n$$ \\left\\lfloor \\frac{kL + (i+1)S'}{L} \\right\\rfloor > \\left\\lfloor \\frac{kL + iS'}{L} \\right\\rfloor $$\n$$ k + \\left\\lfloor \\frac{(i+1)S'}{L} \\right\\rfloor > k + \\left\\lfloor \\frac{iS'}{L} \\right\\rfloor $$\n$$ \\left\\lfloor \\frac{(i+1)S'}{L} \\right\\rfloor > \\left\\lfloor \\frac{iS'}{L} \\right\\rfloor $$\n这个不等式必须对所有非负整数 $i$ 成立。让我们测试 $i=0$ 的情况：\n$$ \\left\\lfloor \\frac{S'}{L} \\right\\rfloor > \\left\\lfloor 0 \\right\\rfloor \\implies \\left\\lfloor \\frac{S'}{L} \\right\\rfloor > 0 $$\n由于 $\\lfloor \\frac{S'}{L} \\rfloor$ 必须是整数，这意味着一个必要条件：\n$$ \\left\\lfloor \\frac{S'}{L} \\right\\rfloor \\ge 1 \\implies \\frac{S'}{L} \\ge 1 \\implies S' \\ge L $$\n这个条件也是充分的。如果 $S' \\ge L$，那么设 $c = \\frac{S'}{L} \\ge 1$。我们必须满足的不等式是 $\\lfloor (i+1)c \\rfloor > \\lfloor ic \\rfloor$。设 $f(i) = \\lfloor ic \\rfloor$。然后我们需要证明 $f(i+1) > f(i)$。\n差值为 $f(i+1) - f(i) = \\lfloor ic + c \\rfloor - \\lfloor ic \\rfloor$。\n使用性质 $\\lfloor x+y \\rfloor \\ge \\lfloor x \\rfloor + \\lfloor y \\rfloor$，我们有：\n$$ \\lfloor ic + c \\rfloor \\ge \\lfloor ic \\rfloor + \\lfloor c \\rfloor $$\n因此，$f(i+1) - f(i) \\ge \\lfloor c \\rfloor$。因为 $c = \\frac{S'}{L} \\ge 1$，我们有 $\\lfloor c \\rfloor \\ge 1$。\n所以，$f(i+1) - f(i) \\ge 1$，这证实了 $f(i+1) > f(i)$。因此，条件 $S' \\ge L$ 是充分且必要的。\n\n我们需要找到满足此条件的最小非负整数 $p$。\n$$ s + p \\ge L $$\n代入已知值 $s = 32$ 和 $L = 64$：\n$$ 32 + p \\ge 64 $$\n$$ p \\ge 64 - 32 $$\n$$ p \\ge 32 $$\n满足此不等式的最小非负整数 $p$ 是 $32$。因此，所需的尾部填充是 $p = 32$ 字节。\n填充后记录的总大小变为 $s+p = 32+32 = 64$ 字节，这正好是缓存行的大小。这确保了每个记录都从一个新的缓存行边界开始。", "answer": "$$\\boxed{32}$$", "id": "3661029"}, {"introduction": "在上一个练习的基础上，我们已经了解了如何从结构上避免伪共享，但其性能影响究竟有多大？本练习将通过对一个常见的生产者-消费者环形缓冲区进行性能建模，来量化伪共享带来的开销 [@problem_id:3660978]。通过计算和对比数据对齐前后系统的吞吐量，你将深刻理解为何设计缓存友好（cache-aware）的数据结构至关重要。", "problem": "一个单生产者/单消费者的无锁环形缓冲区被实现在一个芯片多处理器（chip multiprocessor）的两个不同核心上，每个核心都有一个私有的写回式缓存（write-back cache）和一个使用失效协议（invalidation protocol）的相干共享内存系统。该环形缓冲区使用两个指针变量：一个仅由消费者更新的头指针（head pointer）和一个仅由生产者更新的尾指针（tail pointer）。两个核心都会读取这两个指针以检查空/满条件。缓存行大小为 $L=64 \\text{ B}$，每个指针大小为 $p=8 \\text{ B}$。在未对齐布局（unaligned layout）中，头指针和尾指针在内存中连续放置，没有填充；在对齐布局（aligned layout）中，每个指针都被填充，使其完全位于各自的缓存行内。\n\n假设以下经过充分验证的事实和成本：\n- 一个核心的稳态吞吐量是其处理单个项目时间的倒数，而系统的吞吐量是生产者和消费者吞吐量中的最小值。\n- 在未对齐布局中（伪共享，false sharing），生产者对尾指针的写入和消费者对头指针的写入发生在同一个缓存行上，导致每次写入时所有权在核心之间来回“乒乓”（ping-pong）。将每次此类写入的相干性成本（coherence cost）建模为一个恒定的所有权转移延迟 $T_{x}$ 个周期。\n- 在对齐布局中（无伪共享），每个指针的缓存行由其写入核心“拥有”；然而，由于另一个核心会周期性地读取该指针，所有者随后的每次写入都需要一次失效/升级（invalidate/upgrade）。将这种每次写入的升级延迟建模为 $T_{u}$ 个周期。\n- 生产者的本地每次入队记账成本为 $C_{e}$ 个周期（不包括相干性效应），消费者的本地每次出队记账成本为 $C_{d}$ 个周期（不包括相干性效应）。\n- 处理器核心频率为每秒 $f$ 个周期。\n\n假设 $f=3.2\\times 10^{9} \\text{ cycles/s}$，$C_{e}=40 \\text{ cycles}$，$C_{d}=40 \\text{ cycles}$，$T_{x}=150 \\text{ cycles}$，以及 $T_{u}=30 \\text{ cycles}$。您可以忽略所有未明确说明的成本。\n\n请从第一性原理出发，通过计算生产者和消费者处理每个项目的周期成本以及较慢一方的限制效应，推导出在未对齐和对齐布局下的稳态最大吞吐量（以每秒项数计）。然后，将对齐布局吞吐量与未对齐布局吞吐量的比率作为一个无单位的实数作为最终答案。不要四舍五入；如果可能，请提供一个精确值。", "solution": "首先验证问题，以确保其科学上合理、设定良好且客观。\n\n### 第1步：提取已知条件\n- 系统：在两个核心上的单生产者/单消费者无锁环形缓冲区。\n- 缓存架构：私有写回式缓存，使用失效协议的相干共享内存。\n- 指针：`head`（由消费者写入），`tail`（由生产者写入）。两者均由两个核心读取。\n- 缓存行大小：$L = 64 \\text{ B}$。\n- 指针大小：$p = 8 \\text{ B}$。\n- 未对齐布局：`head` 和 `tail` 指针在内存中是连续的。\n- 对齐布局：`head` 和 `tail` 指针被填充以位于不同的缓存行中。\n- 吞吐量定义：系统吞吐量是 $\\min(\\text{生产者吞吐量}, \\text{消费者吞吐量})$。一个核心的吞吐量是其处理单个项目时间的倒数。\n- 未对齐成本模型（伪共享）：每次写入的相干性成本是所有权转移延迟 $T_{x}$ 个周期。\n- 对齐成本模型（无伪共享）：每次写入的升级延迟是 $T_{u}$ 个周期。\n- 本地处理成本：生产者的本地记账成本为 $C_{e}$ 个周期；消费者为 $C_{d}$ 个周期。\n- 核心频率：$f = 3.2 \\times 10^{9} \\text{ cycles/s}$。\n- 给定的成本值：$C_{e} = 40 \\text{ cycles}$，$C_{d} = 40 \\text{ cycles}$，$T_{x} = 150 \\text{ cycles}$，$T_{u} = 30 \\text{ cycles}$。\n- 说明：忽略所有未明确说明的成本。\n\n### 第2步：使用提取的已知条件进行验证\n该问题在科学上是合理的，因为它描述了计算机体系结构中一个被称为伪共享（false sharing）的经典且被深入理解的性能问题。缓存相干性、失效协议和生产者-消费者数据结构等概念是计算机组织和芯片多处理器领域的基础。该问题设定良好，提供了所有必要的定义和数值（$L$, $p$, $f$, $C_e$, $C_d$, $T_x$, $T_u$）以推导出唯一解。语言客观而精确。数值对于现代处理器是现实的。该问题不完整、不矛盾、也不含糊。它构成了一个有效且可形式化的性能建模练习。\n\n### 第3步：结论与行动\n该问题是有效的。将提供完整的解答。\n\n### 解题推导\n系统的稳态吞吐量 $\\Theta_{sys}$ 受限于两个核心（生产者或消费者）中较慢的一个。单个核心的吞吐量是处理一个项目所需的总时间（以周期数衡量）的倒数，再乘以核心频率 $f$。\n设 $T_{prod}$ 为生产者处理每个项目的总周期成本，$T_{cons}$ 为消费者处理每个项目的总周期成本。\n各自的吞吐量为 $\\Theta_{prod} = \\frac{f}{T_{prod}}$ 和 $\\Theta_{cons} = \\frac{f}{T_{cons}}$。\n系统吞吐量为 $\\Theta_{sys} = \\min(\\Theta_{prod}, \\Theta_{cons}) = \\min\\left(\\frac{f}{T_{prod}}, \\frac{f}{T_{cons}}\\right) = \\frac{f}{\\max(T_{prod}, T_{cons})}$。\n每个核心处理每个项目的总周期成本是其本地记账成本与因缓存相干性效应产生的任何额外成本之和。我们将分别分析未对齐和对齐布局。\n\n#### 未对齐布局分析（伪共享）\n在未对齐布局中，`head` 和 `tail` 指针在内存中连续放置。每个指针的大小为 $p=8 \\text{ B}$。两个指针占用的总大小为 $p+p = 8 \\text{ B} + 8 \\text{ B} = 16 \\text{ B}$。由于这小于缓存行大小 $L=64 \\text{ B}$，两个指针位于同一个缓存行上。\n\n这造成了“伪共享”（false sharing）情景。当生产者核心写入 `tail` 指针时，它必须获得该缓存行的独占所有权。这会使消费者核心持有的该缓存行副本失效。随后，当消费者核心写入同一缓存行上的 `head` 指针时，它必须获得独占所有权，这又会使生产者的副本失效。这种缓存行所有权的来回转移被称为“乒乓效应”（ping-ponging）。\n\n问题指出，每次此类所有权转移的成本为 $T_{x}$。\n- 生产者的每项总成本是其本地成本加上相干性成本：\n$$T_{prod, unaligned} = C_{e} + T_{x}$$\n- 消费者的每项总成本是其本地成本加上相干性成本：\n$$T_{cons, unaligned} = C_{d} + T_{x}$$\n\n代入给定值：\n$C_{e} = 40 \\text{ cycles}$\n$C_{d} = 40 \\text{ cycles}$\n$T_{x} = 150 \\text{ cycles}$\n\n$$T_{prod, unaligned} = 40 + 150 = 190 \\text{ cycles}$$\n$$T_{cons, unaligned} = 40 + 150 = 190 \\text{ cycles}$$\n\n未对齐系统的有效每项周期成本是两者中的最大值：\n$$T_{sys, unaligned} = \\max(T_{prod, unaligned}, T_{cons, unaligned}) = \\max(190, 190) = 190 \\text{ cycles}$$\n未对齐情况下的系统吞吐量为 $\\Theta_{sys, unaligned} = \\frac{f}{190}$。\n\n#### 对齐布局分析（无伪共享）\n在对齐布局中，使用填充来确保 `head` 和 `tail` 指针位于不同的缓存行上。生产者只写入 `tail` 指针所在的缓存行，消费者只写入 `head` 指针所在的缓存行。这消除了伪共享的乒乓效应。\n\n然而，出现了一种不同的、成本较低的相干性流量模式。消费者必须周期性地读取 `tail` 指针来检查缓冲区是否为空。这个操作导致消费者的缓存获取一个 `tail` 指针所在缓存行的“共享”（Shared）副本。当生产者下一次写入 `tail` 指针时，其缓存控制器必须先使消费者缓存中的共享副本失效，然后才能执行写入。这是一个“升级”（upgrade）操作（从共享状态到修改/独占状态）。问题将此操作的延迟建模为 $T_{u}$。对于由生产者读取、由消费者写入的 `head` 指针，也发生对称的交互。\n\n- 生产者的每项总成本是其本地成本加上升级延迟：\n$$T_{prod, aligned} = C_{e} + T_{u}$$\n- 消费者的每项总成本是其本地成本加上升级延迟：\n$$T_{cons, aligned} = C_{d} + T_{u}$$\n\n代入给定值：\n$C_{e} = 40 \\text{ cycles}$\n$C_{d} = 40 \\text{ cycles}$\n$T_{u} = 30 \\text{ cycles}$\n\n$$T_{prod, aligned} = 40 + 30 = 70 \\text{ cycles}$$\n$$T_{cons, aligned} = 40 + 30 = 70 \\text{ cycles}$$\n\n对齐系统的有效每项周期成本是两者中的最大值：\n$$T_{sys, aligned} = \\max(T_{prod, aligned}, T_{cons, aligned}) = \\max(70, 70) = 70 \\text{ cycles}$$\n对齐情况下的系统吞吐量为 $\\Theta_{sys, aligned} = \\frac{f}{70}$。\n\n#### 吞吐量比率\n问题要求计算对齐布局吞吐量与未对齐布局吞吐量的比率。\n$$Ratio = \\frac{\\Theta_{sys, aligned}}{\\Theta_{sys, unaligned}}$$\n代入吞吐量的表达式：\n$$Ratio = \\frac{f / T_{sys, aligned}}{f / T_{sys, unaligned}}$$\n频率 $f$ 被消去，比率简化为系统周期成本的反比：\n$$Ratio = \\frac{T_{sys, unaligned}}{T_{sys, aligned}}$$\n代入计算出的周期成本：\n$$Ratio = \\frac{190}{70} = \\frac{19}{7}$$\n问题要求一个单一的实数。分数 $\\frac{19}{7}$ 代表了精确的实数值。", "answer": "$$\\boxed{\\frac{19}{7}}$$", "id": "3660978"}, {"introduction": "现在，让我们将优化的视角从底层的数据布局提升到高层的算法设计。全局共享计数器是多核应用中常见的可伸缩性瓶颈，一个标准的优化模式是将其分解为多个核的本地计数器，并周期性地将本地计数值合并到全局计数器中。本练习将引导你对这种方法的性能权衡进行建模，特别是分析合并操作的频率如何影响整个系统的吞吐量，从而掌握在高争用场景下提升性能的策略 [@problem_id:3660990]。", "problem": "考虑一个片上多处理器，其包含 $N=8$ 个相同的核心，运行时钟频率为 $f = 3.2 \\text{ GHz}$。一个工作负载重复地递增一个全局计数器。现有两种实现方式：\n\n- 基准实现：一个单一的共享计数器，在一个由自旋锁保护的临界区内进行更新。在稳态下，每次递增操作的临界区串行化服务时间（包括加锁/解锁和一致性效应）为 $t_{s} = 120$ 个时钟周期。假设这使得基准吞吐量完全受限于串行化。\n\n- 重构实现：每个核心维护一个私有的每核心计数器，并执行本地递增，每次递增的成本为 $t_{\\ell} = 6$ 个时钟周期。在每个核心上每完成一批 $K$ 次本地递增后，一个合并例程会获取相同的自旋锁，并将该批次的增量加到全局计数器上。合并操作的串行化服务时间是一个未知的常数 $m$ 个时钟周期，且与 $K$ 无关。假设合并操作被该锁完全串行化，并且在稳态下，系统除了串行化区域的服务时间外，没有额外的排队延迟。\n\n当以 $K = 100$ 运行重构实现时，测得的聚合稳态吞吐量为 $R_{100} = 150 \\times 10^{6} \\text{ increments/sec}$，且硬件性能计数器表明锁已饱和（合并操作是瓶颈）。\n\n任务：\n- 从吞吐量的基本定义（即每次操作平均时间的倒数）以及任何完全串行化的区域都会施加一个等于其服务能力上限的约束这一概念出发，推导重构实现的聚合吞吐量 $R(K)$ 作为 $N$、$f$、$t_{\\ell}$、$m$ 和 $K$ 的函数表达式。\n- 使用 $K=100$ 的测量数据和所述的瓶颈条件，估计合并服务时间 $m$（以时钟周期为单位）。\n- 使用相同的 $m$，在相同假设下预测 $K = 400$ 时的聚合吞吐量，然后计算重构实现相对于基准实现的吞吐量增益 $G$，定义为 $G = \\frac{R_{400}}{R_{\\mathrm{base}}}$。\n\n将 $m$ 以时钟周期为单位表示，$G$ 以无量纲比率表示。将 $m$ 和 $G$ 都四舍五入到三位有效数字。最终答案必须以一行两个值的形式报告，顺序为 $\\bigl[m,\\,G\\bigr]$。", "solution": "用户要求我解决一个关于片上多处理器性能的计算机体系结构多部分问题。我将首先验证问题陈述，如果问题被认为是有效的，则继续进行完整解答。\n\n### 第1步：提取已知条件\n- 核心数：$N=8$\n- 时钟频率：$f = 3.2 \\text{ GHz} = 3.2 \\times 10^9 \\text{ s}^{-1}$\n- 基准串行化服务时间：$t_s = 120$ 个时钟周期\n- 重构后本地递增成本：$t_{\\ell} = 6$ 个时钟周期\n- 重构后合并串行化服务时间：$m$ 个时钟周期（未知）\n- 批处理大小：$K$ 次递增\n- 当 $K=100$ 时，测得的聚合吞吐量为 $R_{100} = 150 \\times 10^6 \\text{ increments/sec}$。\n- 当 $K=100$ 时，系统受限于串行化（锁饱和）。\n- 基准吞吐量完全受限于串行化。\n- 系统在服务时间之外没有额外的排队延迟。\n\n### 第2步：使用提取的已知条件进行验证\n该问题在科学上基于计算机体系结构的原理，特别是多核处理器性能、竞争和串行化。所使用的概念——例如时钟频率、时钟周期、吞吐量、自旋锁和临界区——都是标准且定义明确的。给定的数值对于现代硬件是合理的。问题陈述清晰，提供了明确的目标和足够的数据来推导未知数。语言客观且正式。所提供的假设（例如，“完全受限于串行化”、“没有额外的排队”）用于创建一个简化但一致的分析模型，这是一种常见且有效的教学方法。该问题不违反任何无效性标准。\n\n### 第3步：结论与行动\n该问题是有效的。我将继续进行解答。\n\n### 详细解答\n\n该问题要求推导吞吐量表达式，估计未知参数 $m$，并预测性能增益。问题的核心在于将系统吞吐量建模为受其瓶颈组件的限制。\n\n#### 第1部分：聚合吞吐量 $R(K)$ 的推导\n\n重构实现涉及两个不同的工作阶段：\n1.  **本地递增**：$N$ 个核心中的每一个都对其私有计数器执行递增操作。这项工作是并行的。\n2.  **全局合并**：在一批 $K$ 次本地递增之后，每个核心必须获取一个全局锁，以将其本地计数合并到全局计数器中。这项工作是串行的。\n\n系统的整体吞吐量由这两个阶段的吞吐量能力的最小值决定。这类似于一个流水线，其整体速率由最慢的阶段决定。\n\n**并行阶段（本地递增）的能力：**\n单个核心每 $t_{\\ell}$ 个时钟周期可以执行一次本地递增。因此，一个核心的递增速率为每秒 $\\frac{f}{t_{\\ell}}$ 次递增。在 $N$ 个核心并行操作的情况下，如果这是唯一的阶段，最大聚合吞吐量将是：\n$$R_{\\mathrm{parallel}} = N \\frac{f}{t_{\\ell}}$$\n\n**串行阶段（全局合并）的能力：**\n单次合并操作需要 $m$ 个时钟周期，并由一个锁进行串行化。这意味着系统最多每 $m$ 个时钟周期可以完成一次合并。合并的最大速率是每秒 $\\frac{f}{m}$ 次合并。每次合并操作对应于完成一批 $K$ 次本地递增。因此，如果受合并过程限制，最大聚合吞吐量为：\n$$R_{\\mathrm{serial}}(K) = K \\left(\\frac{f}{m}\\right) = \\frac{K f}{m}$$\n\n**整体吞吐量 $R(K)$：**\n整个系统的稳态聚合吞吐量 $R(K)$ 是并行阶段和串行阶段能力的最小值。\n$$R(K) = \\min\\left(R_{\\mathrm{parallel}}, R_{\\mathrm{serial}}(K)\\right) = \\min\\left(\\frac{N f}{t_{\\ell}}, \\frac{K f}{m}\\right)$$\n这也可以写成：\n$$R(K) = f \\cdot \\min\\left(\\frac{N}{t_{\\ell}}, \\frac{K}{m}\\right)$$\n这个表达式表示了聚合吞吐量作为给定参数的函数。\n\n#### 第2部分：合并服务时间 $m$ 的估计\n\n给定当批处理大小为 $K=100$ 时，测得的吞吐量为 $R_{100} = 150 \\times 10^6 \\text{ increments/sec}$，并且在此工作点，“锁已饱和”。锁饱和意味着串行阶段是瓶颈。这意味着：\n$$R_{100} = R_{\\mathrm{serial}}(100) = \\frac{100 f}{m}$$\n我们可以重新整理这个方程来求解未知的合并服务时间 $m$：\n$$m = \\frac{100 f}{R_{100}}$$\n代入给定值：\n$$m = \\frac{100 \\cdot (3.2 \\times 10^9 \\text{ s}^{-1})}{150 \\times 10^6 \\text{ increments/sec}} = \\frac{3.2 \\times 10^{11}}{1.5 \\times 10^8} \\frac{\\text{increments}}{\\text{s}} \\cdot \\frac{\\text{s}}{\\text{cycles}} = \\frac{3.2}{1.5} \\times 10^3 \\text{ cycles/increment}$$\n由于一次合并对应一批次的增量，单位应为 `cycles`。\n$$m = \\frac{100 \\cdot (3.2 \\times 10^9 \\text{ cycles/s})}{150 \\times 10^6 \\text{ increments/s}} = \\frac{3.2 \\times 10^{11}}{1.5 \\times 10^8} \\text{ cycles/increment} \\approx 2133.33 \\text{ cycles}$$\n四舍五入到三位有效数字，我们得到：\n$$m \\approx 2.13 \\times 10^3 \\text{ cycles}$$\n\n我们应该验证饱和条件。如果 $\\frac{N}{t_{\\ell}} \\geq \\frac{K}{m}$，则系统受限于串行化。\n使用我们计算出的 $m$：\n$$\\frac{N}{t_{\\ell}} = \\frac{8}{6} \\approx 1.333$$\n$$\\frac{K}{m} = \\frac{100}{2133.33...} \\approx 0.046875$$\n由于 $1.333 > 0.046875$，条件 $\\frac{N}{t_{\\ell}} > \\frac{K}{m}$ 成立，这证实了对于 $K=100$ 的情况，锁确实是瓶颈。\n\n#### 第3部分：吞吐量增益 $G$ 的预测\n\n首先，我们预测 $K=400$ 时的聚合吞吐量，记为 $R_{400}$。使用推导出的 $R(K)$ 表达式和估计的 $m$ 值：\n$$R_{400} = R(400) = f \\cdot \\min\\left(\\frac{N}{t_{\\ell}}, \\frac{400}{m}\\right)$$\n我们比较最小值函数中的两项：\n$$\\frac{N}{t_{\\ell}} = \\frac{8}{6} \\approx 1.333$$\n$$\\frac{400}{m} = \\frac{400}{2133.33...} \\approx 0.1875$$\n由于 $1.333 > 0.1875$，串行部分仍然是瓶颈。因此：\n$$R_{400} = \\frac{400 f}{m}$$\n我们可以相对于 $R_{100}$ 来计算这个值：\n$$R_{400} = \\frac{400 f}{m} = 4 \\cdot \\left(\\frac{100 f}{m}\\right) = 4 \\cdot R_{100}$$\n$$R_{400} = 4 \\cdot (150 \\times 10^6 \\text{ increments/s}) = 600 \\times 10^6 \\text{ increments/s}$$\n\n接下来，我们计算基准吞吐量 $R_{\\mathrm{base}}$。问题陈述基准实现完全受限于一个服务时间为 $t_s = 120$ 个时钟周期的临界区。\n$$R_{\\mathrm{base}} = \\frac{f}{t_s} = \\frac{3.2 \\times 10^9 \\text{ s}^{-1}}{120} = \\frac{32 \\times 10^8}{120} \\text{ s}^{-1} = \\frac{8}{3} \\times 10^7 \\text{ s}^{-1}$$\n$$R_{\\mathrm{base}} \\approx 26.67 \\times 10^6 \\text{ s}^{-1}$$\n\n最后，我们计算 $K=400$ 时重构实现相对于基准实现的吞吐量增益 $G$。\n$$G = \\frac{R_{400}}{R_{\\mathrm{base}}} = \\frac{600 \\times 10^6 \\text{ s}^{-1}}{\\frac{8}{3} \\times 10^7 \\text{ s}^{-1}}$$\n$$G = \\frac{60 \\times 10^7}{\\frac{8}{3} \\times 10^7} = \\frac{60 \\cdot 3}{8} = \\frac{180}{8} = \\frac{45}{2} = 22.5$$\n数值 $22.5$ 具有三位有效数字。\n\n最终值为 $m \\approx 2.13 \\times 10^3$ 个时钟周期和 $G = 22.5$。", "answer": "$$ \\boxed{[2.13 \\times 10^3, 22.5]} $$", "id": "3660990"}]}