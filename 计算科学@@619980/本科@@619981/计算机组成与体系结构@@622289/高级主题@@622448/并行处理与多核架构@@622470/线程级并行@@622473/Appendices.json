{"hands_on_practices": [{"introduction": "在并行编程中，保证正确性是首要挑战。一个在单线程环境中看似无懈可击的逻辑，在多线程并发执行时可能会因为编译器和硬件的指令重排序而失败。本实践将通过分析经典的“双重检查锁定”（Double-Checked Locking）模式，深入探讨弱内存模型如何导致“部分构造对象”等并发错误的产生，并揭示如何使用内存栅栏（fences）或`volatile`等机制来确保跨线程的可见性和顺序性，从而保证程序的正确性。[@problem_id:3685181]", "problem": "两个线程，表示为 $T_P$（生产者）和 $T_C$（消费者），通过双重检查锁定模式实现一个单例，该模式使用一个共享指针 $p$ 和一个互斥锁 $m$。生产者执行分配和初始化，如下所示：它将对象字段 $x$ 和 $y$ 写入特定于应用程序的非零值，然后发布指向新分配对象的指针 $p$，所有这些都在由 $m$ 保护的临界区内完成。消费者首先在不持有 $m$ 的情况下读取 $p$；如果 $p$ 非空，则直接返回 $p$；否则，它获取 $m$，重新检查 $p$，如果仍然为空，则在 $m$ 内部执行初始化和发布。形式上，$T_P$ 上预期的程序顺序是 $x \\leftarrow v_x$，$y \\leftarrow v_y$，$p \\leftarrow \\text{addr}$，其中 $v_x \\neq 0$，$v_y \\neq 0$。在 $T_C$ 上，当观察到 $p$ 非空时，预期的顺序是 $r_p \\leftarrow p$，然后是 $r_x \\leftarrow x$，$r_y \\leftarrow y$，并返回 $r_p$。\n\n在你的推理中使用以下基本依据：\n- 顺序一致性（Sequential Consistency, SC）：任何执行的结果都与所有处理器的操作以某种单一的、一次一个的总顺序执行的结果相同，并且每个独立处理器的操作都以其程序顺序出现在这个总顺序中。\n- 全局存储顺序（Total Store Order, TSO）：一种广泛实现的硬件内存模型，其中来自单个处理器的加载和存储按以下方式排序：存储不会被其他处理器乱序观察到（保留存储-存储顺序），加载相对于其他加载不会被重排序（保留加载-加载顺序），但加载可能会在同一处理器对不同位置的先前存储之前被服务（通过写缓冲允许存储-加载重排序）。\n- 先行发生（Happens-before）：由程序顺序加上同步操作（例如，内存屏障、获取和释放语义）定义的偏序关系，使得如果 $A$ 先行发生于 $B$，则 $B$ 能读取到 $A$ 的效果。\n\n考虑一个弱内存模型，它允许存储-存储重排序和存储在线程间的非多副本原子性传播，因此一个较晚的存储可能会在一个较早的对不同位置的存储之前对另一个线程可见，并且可见性可能在不同线程之间暂时不同。假设编译器可以自由地重排序独立的内存操作，除非受到语言级语义的限制（例如，Java中的 $volatile$ 或C++11及更高版本中的C++原子操作），并且内存屏障会约束硬件重排序，但除非特别指定，否则本身不会约束高级别的编译器重排序。\n\n选择所有关于双重检查锁定模式、在弱排序下“部分构造对象”错误的表现，以及内存屏障或 $volatile$ 语义如何在TSO与SC上跨线程恢复正确性的正确陈述：\n\nA. 在顺序一致性（SC）下，如果 $T_P$ 按程序顺序执行 $x \\leftarrow v_x$，$y \\leftarrow v_y$，然后 $p \\leftarrow \\text{addr}$，任何读取到 $p$ 非空的 $T_C$ 都将随后读取到 $x$ 和 $y$ 的值分别为 $v_x$ 和 $v_y$；因此，双重检查锁定模式在硬件级别上，在SC下是正确的，剩下的风险仅在于编译器重排序，除非语言禁止这种重排序。\n\nB. 在全局存储顺序（TSO）下，双重检查锁定模式在硬件级别上是不正确的，因为 $p \\leftarrow \\text{addr}$ 可能在 $x \\leftarrow v_x$ 和 $y \\leftarrow v_y$ 之前变得可见；因此，必须使用存储-存储屏障来防止这个错误。\n\nC. 在一个其 $volatile$ 关键字意味着写操作为释放（release）语义、读操作为获取（acquire）语义的语言中（例如，Java 5之后的Java内存模型），将 $p$ 声明为 $volatile$ 可以确保 $T_P$ 中的写操作 $p \\leftarrow \\text{addr}$ 先行发生于 $T_C$ 中的读操作 $r_p \\leftarrow p$，从而强制所有先前的对象字段存储对 $T_C$ 可见，这即使在弱内存模型上也能修复该模式。\n\nD. 仅在 $T_C$ 读取 $p$ 之后插入一个加载-加载屏障（即，在 $r_p \\leftarrow p$ 之后对 $r_x \\leftarrow x$，$r_y \\leftarrow y$ 进行排序），就足以在所有弱内存模型上修复双重检查锁定错误，而无需在 $T_P$ 上使用任何内存屏障或 $volatile$。\n\nE. 在允许存储-存储重排序或非多副本原子性存储的模型上，如果没有语言级的 $volatile$ 或显式内存屏障，$T_C$ 可能观察到 $p$ 为非空，但读取到 $x$ 和 $y$ 的默认值（例如，$0$），这展示了由于 $p$ 的发布在完全初始化变得可见之前而导致的双重检查锁定错误。\n\n选择所有适用项。", "solution": "该问题要求在各种内存一致性模型下分析双重检查锁定模式（DCLP）。DCLP的核心错误是生产者线程 $T_P$（初始化对象并发布指向它的指针）与消费者线程 $T_C$（不获取锁就读取此指针并使用对象，即“快速路径”）之间的数据竞争。生产者的预期程序顺序是先初始化对象的字段（$x \\leftarrow v_x$，$y \\leftarrow v_y$），然后才发布指针（$p \\leftarrow \\text{addr}$）。如果消费者 $T_C$ 观察到了新的指针值（$r_p \\leftarrow p$），但读取到对象字段的未初始化或陈旧值（$r_x \\leftarrow x$，$r_y \\leftarrow y$），则会发生错误。这可能是由于编译器指令重排序或硬件内存重排序造成的。\n\n让生产者 $T_P$ 的写操作表示为 $W(x, v_x)$、$W(y, v_y)$ 和 $W(p, \\text{addr})$。程序顺序为 $W(x, v_x) \\rightarrow_{po} W(y, v_y) \\rightarrow_{po} W(p, \\text{addr})$。\n让消费者 $T_C$ 在快速路径上的读操作为 $R(p)$，后跟 $R(x)$ 和 $R(y)$。程序顺序为 $R(p) \\rightarrow_{po} R(x) \\rightarrow_{po} R(y)$。\n如果写操作 $W(p, \\text{addr})$ 在写操作 $W(x, v_x)$ 和 $W(y, v_y)$ 对 $T_C$ 可见之前就变得可见，DCLP错误就会显现。\n\n**选项 A 评估**\n该陈述断言，在顺序一致性（SC）下，DCLP在硬件级别是正确的。SC被定义为一个系统，其中所有线程的所有操作都以某个单一的总顺序执行，并且这个总顺序与每个独立线程的程序顺序一致。\n\n如果 $T_C$ 读取了由 $T_P$ 写入的指针值，即 $R(p)$ 读取了来自 $W(p, \\text{addr})$ 的值，那么在全局SC总顺序中，$W(p, \\text{addr})$ 必须在 $R(p)$ 之前。\n$$ W(p, \\text{addr}) \\rightarrow_{SC} R(p) $$\n因为SC总顺序必须尊重 $T_P$ 的程序顺序，所以在 $T_P$ 程序中 $W(p, \\text{addr})$ 之前的所有操作也必须在SC总顺序中位于 $W(p, \\text{addr})$ 之前。\n$$ W(x, v_x) \\rightarrow_{po} W(p, \\text{addr}) \\implies W(x, v_x) \\rightarrow_{SC} W(p, \\text{addr}) $$\n$$ W(y, v_y) \\rightarrow_{po} W(p, \\text{addr}) \\implies W(y, v_y) \\rightarrow_{SC} W(p, \\text{addr}) $$\n通过传递性，我们得到：\n$$ W(x, v_x) \\rightarrow_{SC} R(p) \\quad \\text{和} \\quad W(y, v_y) \\rightarrow_{SC} R(p) $$\n由于消费者的读操作 $R(x)$ 和 $R(y)$ 在其程序顺序中位于 $R(p)$ 之后，它们在SC总顺序中也必须位于 $R(p)$ 之后。因此，$R(x)$ 和 $R(y)$ 保证能观察到分别来自 $W(x, v_x)$ 和 $W(y, v_y)$ 的值。硬件不允许导致该错误的重排序。\n\n该陈述正确地指出，剩下的风险是编译器重排序。一个不了解跨线程依赖关系的编译器，可能会将 $T_P$ 代码中独立的存储操作重排序为 $p \\leftarrow \\text{addr}; x \\leftarrow v_x; y \\leftarrow v_y$。如果这段重排序后的代码在SC机器上运行，DCLP错误仍然会发生。因此，需要语言级的约束来防止这种情况。该陈述是准确的。\n\n结论：**正确**。\n\n**选项 B 评估**\n该陈述声称，在全局存储顺序（TSO）下，DCLP在硬件级别是不正确的，原因是存储-存储重排序，因此必须使用存储-存储屏障。\n问题将TSO定义为一个模型，其中“存储不会被其他处理器乱序观察到（保留存储-存储顺序）”。这意味着如果 $T_P$ 按顺序执行存储 $W(x, v_x)$、$W(y, v_y)$、$W(p, \\text{addr})$，任何其他线程 $T_C$ 将以相同的顺序观察到这些存储的效果。硬件不会让对 $p$ 的存储在对 $x$ 和 $y$ 的存储之前可见。TSO允许处理器在对不同地址的先前存储完成之前继续执行加载（存储-加载重排序），但从其他观察者的角度来看，它不会重排序存储之间的相对顺序。\n\n因此，声称DCLP在TSO上*硬件级别*不正确是因为存储重排序的说法是错误的。在像x86这样的TSO架构上，DCLP仍然可能失败，但原因通常是编译器重排序，而不是硬件对存储的重排序。在TSO机器上，存储-存储屏障对于强制存储-存储顺序是多余的，因为硬件已经提供了这个保证。\n\n结论：**不正确**。\n\n**选项 C 评估**\n此陈述描述了使用内存语义（例如Java 5之后对`volatile`变量或C++11 `std::atomic`变量的获取-释放顺序）来修复DCLP的方法。对这类变量的写操作具有*释放*语义，读操作具有*获取*语义。\n1.  **释放语义（生产者 $T_P$）：** 对 $p$ 的释放写操作保证了所有在程序顺序中发生在该写操作之前的内存写操作（即 $x \\leftarrow v_x$，$y \\leftarrow v_y$）在该写操作对其他线程可见之前就对它们可见。这可以防止编译器重排序和硬件重排序将初始化写操作移到指针发布之后。\n2.  **获取语义（消费者 $T_C$）：** 对 $p$ 的获取读操作保证了所有在程序顺序中发生在该读操作之后的内存读操作（即 $r_x \\leftarrow x$，$r_y \\leftarrow y$）不会在该读操作之前执行。\n3.  **先行发生关系：** 至关重要的是，一个释放写与一个读取该写入值的获取读同步。这在生产者的写 $p$ 之前的操作与消费者的读 $p$ 之后的操作之间建立了一条“先行发生”边。\n形式上：$(W(x), W(y)) \\rightarrow_{hb} W_{release}(p)$ 和 $R_{acquire}(p) \\rightarrow_{hb} (R(x), R(y))$。同步关系建立了 $W_{release}(p) \\rightarrow_{syncs-with} R_{acquire}(p)$，这意味着 $W_{release}(p) \\rightarrow_{hb} R_{acquire}(p)$。通过传递性，$(W(x), W(y)) \\rightarrow_{hb} (R(x), R(y))$。这保证了消费者会读取到已初始化的值。\n\n该陈述对现代语言级内存排序语义如何修复DCLP错误给出了正确且完整的描述。\n\n结论：**正确**。\n\n**选项 D 评估**\n该陈述认为仅在消费者 $T_C$ 上使用一个加载-加载屏障就足以修复该错误。在读取 $p$ 之后放置一个加载-加载屏障会强制 $T_C$ 内部的操作顺序：\n$$ r_p \\leftarrow p; \\quad \\text{LoadLoadFence}; \\quad r_x \\leftarrow (*r_p).x; $$\n这确保了对 $p$ 的读取在对 $x$ 的读取开始之前完成。然而，DCLP的根本问题不在于消费者端的操作顺序。对象字段的加载本来就数据依赖于指针的加载，所以在大多数情况下它们不会被重排到指针加载之前。问题出在生产者端 $T_P$，即发布指针的写操作 $W(p, \\text{addr})$ 可能在初始化对象的写操作 $W(x, v_x)$ 和 $W(y, v_y)$ 之前对 $T_C$ 可见。$T_C$ 上的屏障对 $T_P$ 执行的写操作的顺序或可见性没有影响。$T_C$ 仍然可能读取到指向部分初始化对象的非空指针。因此，这个提议是不正确的。\n\n结论：**不正确**。\n\n**选项 E 评估**\n此陈述描述了DCLP在弱内存模型上的失败模式。弱内存模型是指那些允许超出TSO所允许范围的重排序的模型，例如存储-存储重排序。像ARM和POWER这样的架构就有这样的模型。在这些系统上，如果 $T_P$ 执行 $W(x, v_x); W(y, v_y); W(p, \\text{addr})$，硬件本身可能重排序这些操作，使得对指针 $p$ 的存储在对字段 $x$ 和 $y$ 的存储之前提交到共享内存系统并对 $T_C$ 可见。这是该错误的直接原因。\n\n非多副本原子性是一个性质，即一个存储可能在不同时间对不同线程可见。这也可能导致DCLP失败，因为对 $p$ 的存储可能在对 $x$ 和 $y$ 的存储传播到 $T_C$ 之前先传播过去。无论是在显式存储-存储重排序的情况下，还是在非均匀传播的情况下，可观察到的结果都是 $T_C$ 可能读到一个非空的 $p$，但随后读到 $x$ 和 $y$ 的默认值（例如，$0$）或未初始化的值。这就是经典的“部分构造对象”错误。该陈述正确地指出，这种情况发生在没有语言级说明符（如具有适当语义的`volatile`）或显式内存屏障来强制必要顺序的情况下。\n\n结论：**正确**。", "answer": "$$\\boxed{ACE}$$", "id": "3685181"}, {"introduction": "解决了正确性问题后，性能便成为线程级并行的核心议题。然而，即使是逻辑正确的并行代码，也可能因为硬件底层机制而表现出非预期的低性能。“伪共享”（False Sharing）就是一个典型的例子，它源于不同核心上的线程频繁写入位于同一缓存行（cache line）的不同数据。本实践将指导你设计一个严谨的实验，学习如何利用性能监控单元（PMU）等工具，从操作系统调度的影响中剥离出由缓存一致性协议引起的性能瓶颈，从而精确地诊断问题所在。[@problem_id:3640995]", "problem": "一位工程师正在调查一台具有一致性缓存的对称多处理（SMP）机器上，一个微基准测试出现的吞吐量下降问题。该机器的缓存行大小为典型的$64$字节。该基准测试启动$2$个线程，这两个线程重复写入两个不同的$8$字节字段$x$和$y$。这两个字段在内存中的同一个结构体实例内是相邻的，因此很可能共享同一个缓存行。这两个线程预计在两个不同的核心上运行。操作系统（OS）使用时间分片技术，时间量（quantum）在毫秒级别，并且可以抢占线程。该工程师怀疑存在伪共享（false sharing）问题，但同时也怀疑上下文切换可能通过减少两个线程写操作的有效重叠，从而掩盖了其性能影响。\n\n请从缓存一致性和调度的基本原理出发，解释为什么时间分片执行可以降低观测到的伪共享成本，然后在选项中选择最合适的实验方法，以区分调度引起的影响和缓存一致性引起的影响。你的选择应明确具体的控制措施和测量指标，以便将性能下降归因于缓存行弹跳（cache line bouncing），还是归因于调度导致的写操作频率降低或交错。\n\n假设：\n-   一个实现类似“修改-独占-共享-无效”（MESI）的写-失效协议的一致性缓存层级。\n-   一个$64$字节的缓存行大小。\n-   同一插槽（socket）上有两个可用的逻辑核心。\n-   有可用的工具来读取性能监控单元（PMU）事件，也称为硬件性能计数器（HPC），包括用于上下文切换、缓存行失效或一致性流量以及末级缓存未命中的计数器。\n-   线程亲和性、调度器策略和线程让步（yield）行为是可控的。\n\n哪个选项最能将缓存一致性效应与调度重叠效应分离开来？\n\nA. 使用线程亲和性将两个线程绑定到同一插槽上的两个不同核心。将中央处理器（CPU）频率固定在一个恒定的性能状态。使用实时调度器类别或高优先级以最小化非自愿抢占。对于每个线程固定的写入速率，测量以下指标：每秒的一致性失效事件数、每秒的末级缓存未命中数、每秒的上下文切换次数以及总运行时间。运行三种情况：（i）基准情况，两个字段相邻（可能共享一个缓存行）；（ii）调度和写入速率与(i)相同，但对两个字段进行填充，使每个字段都位于其自己的缓存行上（缓存对齐）；（iii）恢复到相邻布局，但插入周期性的线程让步，以在保持每个线程写入速率恒定的情况下，强制以受控的周期进行交替执行。将在相同调度下(i)和(ii)之间的差异归因于缓存效应，将在相同内存布局下(i)和(iii)之间的差异归因于调度重叠效应。\n\nB. 允许操作系统自由调度线程，不进行绑定。仅测量墙钟吞吐量，同时增加总数据大小以超过一级（L1）缓存容量。如果数据集较小，将任何吞吐量波动归因于伪共享；如果数据集较大，则归因于调度，而不使用硬件计数器。\n\nC. 将两个线程都绑定到同一个核心，以确保它们永远不会并发运行。测量由此导致的更高的上下文切换率和墙钟时间，并通过与未绑定情况的比较来推断伪共享的程度。\n\nD. 添加一个互斥锁（mutex）来保护该结构体，以便一次只有一个线程进行写操作。测量因可运行竞争减少而降低的上下文切换次数，并推断任何剩余的开销必定来自缓存效应。不修改内存布局或线程放置；仅测量总运行时间和上下文切换次数。", "solution": "该问题陈述是有效的。它提出了一个在计算机系统性能分析领域中基于科学、定义明确且客观的场景。所提供的假设和可用工具是现实的，并且足以设计一个结论性的实验。\n\n首先，我们必须从基本原理出发，解释为什么时间分片执行可以降低观测到的伪共享成本。\n\n伪共享是一种性能下降现象，发生在具有一致性缓存的多处理器系统中。当两个或多个在不同处理器核心上运行的线程，频繁地写入恰好位于同一缓存行上的不同变量时，就会出现这种现象。在这个问题中，两个$8$字节的字段$x$和$y$是相邻的，因此极有可能落入单个$64$字节的缓存行内。\n\n我们把运行线程1的核心记为$C_1$，运行线程2的核心记为$C_2$。缓存一致性协议，如MESI（修改-独占-共享-无效），确保所有核心对内存有一致的视图。其机制如下：\n1.  $C_1$上的线程1写入字段$x$。为此，$C_1$必须获得该缓存行的独占所有权。它将该行带入其本地缓存（例如L1），状态为“修改”或“独占”。\n2.  如果$C_2$上的线程2随后尝试写入字段$y$，它也需要同一缓存行的独占所有权。\n3.  一致性协议检测到此冲突。$C_2$发送一个对该缓存行的请求。这迫使$C_1$首先将其修改过的行写回到共享级别的缓存或主内存，然后使其本地副本失效（状态转变为“无效”）。\n4.  $C_2$随后可以获取该行并执行其写入操作，将其副本标记为“修改”。\n5.  如果线程1再次写入$x$，整个过程将反向重复。\n\n这种缓存行在$C_1$和$C_2$的缓存之间“弹跳”的过程会产生巨大的延迟，因为它涉及通过处理器互连进行通信，这比本地缓存访问慢几个数量级。伪共享现象显现的关键因素是来自不同核心对同一缓存行的写入在*时间上的邻近性*。\n\n由操作系统（OS）管理的时间分片调度可以缓解这种影响。OS调度器为每个可运行的线程分配一个时间量（通常为毫秒级）在一个核心上执行。如果这两个线程没有被绑定到不同的核心，或者受到其他抢占，它们的执行可能不是真正并发的。\n-   **真正并发执行：** 如果线程1和线程2同时在$C_1$和$C_2$上运行，每一次对$x$和$y$的交错写入都可能触发一次缓存行失效和传输。一致性事件的数量将与总写入次数成正比。\n-   **时间分片（非重叠）执行：** 调度器可能先在一个核心上运行线程1，让其完成整个时间片，在此期间它对$x$执行一连串的多次写入。此时，线程2未被调度，不会争用该缓存行。然后，OS抢占线程1并调度线程2。线程2接着执行其对$y$的一连串写入。在这种情况下，缓存行只需要在每个线程的时间片开始时“弹跳”一次，而不是在每次单独的写入时都发生。写入操作实际上被调度器以粗粒度的方式序列化了。\n\n通过降低跨核心交错写入的频率，时间分片减少了昂贵的一致性流量的速率，从而减少或“掩盖”了伪共享的整体性能损失。问题要求设计一个实验来区分这种调度效应和底层的缓存一致性效应。\n\n现在，我们评估所提出的实验方法。\n\n**A. 将两个线程绑定...固定CPU频率...使用实时调度器...运行三种情况...**\n\n该选项提出了一个严谨的、受控的实验。\n-   **控制变量：** 将线程绑定到不同核心、固定CPU频率以及使用实时调度器是最小化噪声和外部变量的基本控制措施。绑定确保了线程*可以*并发运行，而使用实时调度器则最小化了非自愿抢占，从而将系统与OS调度抖动隔离开来。这种设置创建了一个可靠的环境来暴露最坏情况下的伪共享。\n-   **情况(i) vs. (ii)：** 这个比较隔离了伪共享的影响。\n    -   (i) 基准：相邻布局（存在伪共享）。\n    -   (ii) 填充布局（消除了伪共享）。\n    -   调度、写入速率和所有其他参数都保持不变。因此，(i)和(ii)之间测得的任何性能差异（运行时间、一致性事件、LLC未命中）都直接归因于共享缓存行引起的缓存一致性竞争。一致性失效事件的数量是衡量此效应最直接的指标。\n-   **情况(i) vs. (iii)：** 这个比较隔离了调度重叠的影响。\n    -   (i) 基准：相邻布局，最大并发度。\n    -   (iii) 相邻布局，但通过让步（yielding）强制进行受控的、非重叠的执行。\n    -   内存布局保持不变，因此两种情况下伪共享的*可能性*是相同的。被操纵的变量是执行重叠的程度。(i)和(iii)之间的任何性能差异都表明，改变写入重叠（一种调度效应）如何影响一个易受伪共享影响的内存布局的性能。\n-   **测量指标：** 使用性能监控单元（PMU）事件至关重要。直接测量一致性失效可以量化伪共享的硬件效应。上下文切换计数可以验证调度器控制是否按预期工作。总运行时间提供了对吞吐量的整体影响。\n\n这种方法正确地使用了科学方法中的变量隔离法来测试特定假设。它提供了一种方法来分别量化伪共享的成本（通过`(i)` vs. `(ii)`）以及调度在多大程度上可以缓解它（通过`(i)` vs. `(iii)`）。\n\n**评定：正确。**\n\n**B. 允许操作系统自由调度线程...仅测量墙钟吞吐量...**\n\n这种方法在实验上是薄弱的。\n-   **缺乏控制：** 允许OS自由调度线程引入了显著的不确定性。实际的并发程度是未知的，并且在不同运行之间会有所变化，使得结果充满噪声且难以解释。缓存效应和调度效应以一种不受控制的方式混杂在一起。\n-   **有缺陷的方法论：** 将小数据集的吞吐量变化归因于伪共享，将大数据集的吞吐量变化归因于调度，这是一种未经证实的启发式方法。虽然改变数据集大小确实会改变内存访问模式，但它并不能清晰地分离这两个目标效应。它可能会引入其他效应，如缓存容量或关联未命中。\n-   **测量不足：** 仅测量墙钟时间是不够的。没有来自PMU的直接硬件证据（例如，一致性流量计数器），任何关于性能下降原因的归属都只是猜测。\n\n**评定：不正确。**\n\n**C. 将两个线程都绑定到同一个核心...**\n\n这种方法是有缺陷的，因为它消除了它本想研究的现象。\n-   **消除并发性：** 将两个线程都绑定到同一个核心，确保了它们在该单个核心上进行时间分片，并且*永远无法*并发运行。伪共享从根本上说是一个*不同*核心*并发*访问的问题。因此，这种设置下的伪共享为零。\n-   **有缺陷的比较：** 无法通过比较一个伪共享为零的场景（绑定到单个核心）和一个伪共享量和调度噪声都未知且不受控的场景（未绑定情况）来衡量伪共享的程度。这个实验未能隔离感兴趣的变量。\n\n**评定：不正确。**\n\n**D. 添加一个互斥锁来保护该结构体...**\n\n这种方法与C类似，是消除了效应而不是测量它。\n-   **软件序列化：** 互斥锁在软件层面强制实现互斥，只允许一个线程在同一时间进行写入。这将冲突的访问序列化了，就像绑定到单个核心一样，完全阻止了产生伪共享所需的并发写入。\n-   **混淆变量：** 这个实验不是在测量伪共享，而是在测量一个序列化程序的性能以及互斥锁本身的开销。“任何剩余的开销必定来自缓存效应”的推断是毫无根据的。主要的性能特征将是锁开销和并行性的损失，而不是缓存效应。这个测试从根本上将问题从无阻塞并行访问转变为基于锁的同步问题。\n\n**评定：不正确。**\n\n总之，选项A描述了唯一科学上有效的实验，它恰当地控制了变量，并使用适当的测量方法来隔离和区分缓存一致性效应与调度重叠效应。", "answer": "$$\\boxed{A}$$", "id": "3640995"}, {"introduction": "在掌握了如何保证正确性和诊断性能陷阱之后，下一步是主动进行可扩展性设计。对于高并发系统中常见的共享资源争用问题，“分片”（Sharding）是一种关键的优化技术。本实践将通过对一个共享计数器进行分片来减少争用，引导你建立一个量化模型，以平衡更新操作的吞吐量提升与读取数据时因聚合延迟产生的精度损失。通过求解这个优化问题，你将学会如何在性能增益和设计复杂度或成本之间做出有数据支持的权衡。[@problem_id:3685186]", "problem": "一个多核系统采用线程级并行（TLP），有 $n$ 个并发线程周期性地对一个共享计数器进行增量操作。每个线程以平均每秒 $f$ 次更新的速率发出计数器更新请求，且与其他线程无关。单个共享计数器通过原子增量操作实现，其无竞争服务时间为 $c$ 秒。当许多线程更新共享计数器时，原子增量操作的行为类似于一个单服务器队列，其服务时间呈指数分布，总到达率为 $\\lambda = n f$。已知该队列仅在 $\\lambda c  < 1$ 时稳定。为减少竞争，系统通过哈希将更新均匀地分配到 $k$ 个桶中，对计数器进行分片，使得每个桶在期望上接收到的到达率为 $\\lambda/k$，并提供相同的服务时间 $c$。\n\n总计数值的读取由一个聚合器负责，该聚合器对所有 $k$ 个桶的值求和。聚合器周期性运行；在没有任何分片的情况下，其基础周期为 $\\tau_{0}$ 秒。采用分片后，聚合 $k$ 个桶会产生额外的线性扩展的合并开销，每次聚合需要 $a k$ 秒，因此聚合周期变为 $\\tau(k) = \\tau_{0} + a k$。假设相对于聚合调度，读取在时间上是均匀发生的。为了量化分片的精度成本，将每次读取的期望绝对过期计数误差定义为两次聚合之间发生的期望更新次数的一半。\n\n从基本的排队论和并发原理出发，通过比较 $k$ 个分片下的期望单次更新完成时间与单个共享计数器下的期望单次更新完成时间，推导出更新操作的吞吐量提升，该提升是关于 $k$, $n$, $f$ 和 $c$ 的函数。然后，定义一个标量权衡目标\n$$\nJ(k) = I(k) - \\beta E(k),\n$$\n其中 $I(k)$ 是你推导出的吞吐量提升，$E(k)$ 是在周期 $\\tau(k)$ 下每次读取的期望绝对过期计数误差，而 $\\beta > 0$ 是一个用于平衡性能和精度的每单位计数的惩罚权重。将 $k$ 视为一个正实数决策变量，并假设系统保持稳定，即 $n f c  < 1$。\n\n找出在正数 $k$ 上最大化 $J(k)$ 的值 $k^{*}$ 的闭式表达式。你的最终答案必须是 $k^{*}$ 关于 $n$, $f$, $c$, $a$ 和 $\\beta$ 的单个解析表达式。不要四舍五入；请提供精确表达式。", "solution": "首先对用户的问题陈述进行严格的验证过程。\n\n### 步骤1：提取已知条件\n- 并发线程数：$n$\n- 每个线程的更新速率：每秒 $f$ 次更新\n- 总到达率：$\\lambda = n f$\n- 原子增量的无竞争服务时间：$c$ 秒\n- 排队模型：服务时间呈指数分布的单服务器队列\n- 单个队列的稳定性条件：$\\lambda c  < 1$\n- 分片（桶）数：$k$\n- 每个分片的到达率：$\\lambda/k$\n- 每个分片的服务时间：$c$\n- 基础聚合周期（无分片）：$\\tau_0$ 秒\n- 聚合合并开销：$a k$ 秒\n- 采用分片时的聚合周期：$\\tau(k) = \\tau_0 + a k$\n- 每次读取的期望绝对过期计数误差：$E(k)$ = 两次聚合之间期望更新次数的一半\n- 吞吐量提升：$I(k)$\n- 权衡目标函数：$J(k) = I(k) - \\beta E(k)$\n- 惩罚权重：$\\beta > 0$\n- 决策变量：$k$，一个正实数\n- 稳定性假设：系统保持稳定，具体为 $n f c  < 1$。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，提法恰当且客观。它利用了计算机体系结构（线程级并行、分片）和排队论（用于资源竞争的 M/M/1 模型）中的标准模型。所有术语都得到了明确定义，并且提供了足够的信息来构建目标函数 $J(k)$。假设稳定性由单计数器条件 $n f c  < 1$ 决定，虽然这是对更一般的分片稳定性条件 $nfc < k$ 的简化，但它是问题的明确前提。这并未使问题无效，而是定义了必须在其中解决该问题的特定背景。该问题是可形式化的，并且不包含矛盾或歧义。\n\n### 步骤3：结论与行动\n该问题被判定为**有效**。将提供一个完整且论证充分的解决方案。\n\n### 求解推导\n目标是找到使目标函数 $J(k) = I(k) - \\beta E(k)$ 最大化的 $k$ 值，记为 $k^*$。我们必须首先推导吞吐量提升 $I(k)$ 和过期计数误差 $E(k)$ 的表达式。\n\n**1. 每次更新的完成时间**\n共享计数器（或每个分片）的竞争被建模为 M/M/1 队列。对于一个到达率为 $\\Lambda$、平均服务时间为 $c$ 的 M/M/1 队列，其系统内期望时间（等待时间 + 服务时间），即对应每次更新的完成时间 $T$，由以下公式给出：\n$$\nT = \\frac{c}{1 - \\Lambda c}\n$$\n该模型在系统稳定时有效，即 $\\Lambda c  < 1$。\n\n对于单个共享计数器的情况（$k=1$），总到达率为 $\\lambda = n f$。期望完成时间 $T_1$ 为：\n$$\nT_1 = \\frac{c}{1 - \\lambda c} = \\frac{c}{1 - n f c}\n$$\n问题陈述要求假设 $nfc  < 1$，这确保了未分片系统是稳定的。\n\n对于具有 $k$ 个桶的分片情况，更新被均匀地哈希分配。任何单个分片的到达率为 $\\lambda_k = \\frac{\\lambda}{k} = \\frac{n f}{k}$。分片中一次增量操作的服务时间仍为 $c$。因此，一次更新的期望完成时间 $T_k$ 为：\n$$\nT_k = \\frac{c}{1 - \\lambda_k c} = \\frac{c}{1 - \\frac{n f c}{k}}\n$$\n为使该表达式有效，必须满足分片的稳定性条件，即 $\\frac{nfc}{k}  < 1$，或 $k > nfc$。如验证步骤中所讨论的，问题中 $nfc<1$ 的简化假设允许我们对所有 $k>0$ 进行优化。\n\n**2. 吞吐量提升 $I(k)$**\n问题要求通过比较期望的单次更新完成时间来推导“更新操作的吞吐量提升”。对此，一个标准的无量纲度量是加速比，定义为旧延迟与新延迟的比率。\n$$\nI(k) = \\frac{T_1}{T_k} = \\frac{\\frac{c}{1 - nfc}}{\\frac{c}{1 - \\frac{nfc}{k}}} = \\frac{1 - \\frac{nfc}{k}}{1 - nfc}\n$$\n这个量是无量纲的，这对于在目标函数 $J(k)$ 中使用它是必要的，我们接下来会看到这一点。\n\n**3. 过期计数误差 $E(k)$**\n期望绝对过期计数误差 $E(k)$ 定义为两次聚合之间发生的期望更新次数的一半。聚合周期为 $\\tau(k) = \\tau_0 + a k$。总更新速率恒为 $\\lambda = nf$。\n在一个聚合周期内，期望的更新次数为 $\\lambda \\tau(k)$。因此，误差为：\n$$\nE(k) = \\frac{1}{2} \\lambda \\tau(k) = \\frac{1}{2} n f (\\tau_0 + a k)\n$$\n$E(k)$ 的单位是“计数”（无量纲）。鉴于 $\\beta$ 的单位是“每单位计数的惩罚”，$\\beta E(k)$ 这一项也是无量纲的，与 $I(k)$ 一致。\n\n**4. 最大化目标函数 $J(k)$**\n现在我们可以写出目标函数 $J(k)$ 的完整表达式：\n$$\nJ(k) = I(k) - \\beta E(k) = \\frac{1 - \\frac{nfc}{k}}{1 - nfc} - \\beta \\left( \\frac{1}{2} n f (\\tau_0 + a k) \\right)\n$$\n为了找到最大化 $J(k)$ 的值 $k^*$，我们计算 $J(k)$ 关于 $k$ 的导数并将其设为零。首先，我们展开 $J(k)$ 的表达式：\n$$\nJ(k) = \\frac{1}{1 - nfc} - \\frac{nfc}{(1 - nfc)k} - \\frac{1}{2}\\beta n f \\tau_0 - \\frac{1}{2} \\beta n f a k\n$$\n项 $\\frac{1}{1-nfc}$ 和 $\\frac{1}{2}\\beta n f \\tau_0$ 是关于 $k$ 的常数。对 $J(k)$ 关于 $k$ 求导：\n$$\n\\frac{dJ}{dk} = \\frac{d}{dk} \\left( -\\frac{nfc}{(1 - nfc)} k^{-1} - \\frac{1}{2} \\beta n f a k \\right)\n$$\n$$\n\\frac{dJ}{dk} = - \\frac{nfc}{1 - nfc} (-1)k^{-2} - \\frac{1}{2} \\beta n f a\n$$\n$$\n\\frac{dJ}{dk} = \\frac{nfc}{(1 - nfc)k^2} - \\frac{1}{2} \\beta n f a\n$$\n我们通过将导数设为零来找到临界点 $k^*$：\n$$\n\\frac{nfc}{(1 - nfc)(k^*)^2} - \\frac{1}{2} \\beta n f a = 0\n$$\n$$\n\\frac{nfc}{(1 - nfc)(k^*)^2} = \\frac{1}{2} \\beta n f a\n$$\n求解 $(k^*)^2$：\n$$\n(k^*)^2 = \\frac{nfc}{\\frac{1}{2} \\beta n f a (1 - nfc)} = \\frac{2 n f c}{\\beta n f a (1 - nfc)}\n$$\n项 $n$ 和 $f$ 消掉了：\n$$\n(k^*)^2 = \\frac{2c}{\\beta a (1 - nfc)}\n$$\n因为 $k$ 必须是正数，我们取正平方根：\n$$\nk^* = \\sqrt{\\frac{2c}{\\beta a (1 - nfc)}}\n$$\n为了确认该临界点对应于一个最大值，我们检查二阶导数：\n$$\n\\frac{d^2J}{dk^2} = \\frac{d}{dk} \\left( \\frac{nfc}{(1 - nfc)}k^{-2} - \\frac{1}{2} \\beta n f a \\right) = \\frac{nfc}{1 - nfc} (-2)k^{-3} = -\\frac{2nfc}{(1 - nfc)k^3}\n$$\n鉴于 $n, f, c, a, \\beta$ 都是正参数，并且问题假设 $1 - nfc > 0$，所以分子中的所有项都是正的。对于任何 $k > 0$，分母也是正的。因此，$\\frac{d^2J}{dk^2} < 0$，这证实了 $k^*$ 是一个局部最大值。由于它是 $k>0$ 范围内唯一的临界点，因此它也是全局最大值。", "answer": "$$\n\\boxed{\\sqrt{\\frac{2c}{\\beta a (1 - nfc)}}}\n$$", "id": "3685186"}]}