{"hands_on_practices": [{"introduction": "现代处理器为了追求极致性能，常常会偏离我们直观的顺序执行模型。本练习将深入探讨一个重要的宽松内存模型——完全存储定序（Total Store Order, TSO）。通过一个经典的“存储缓冲”测试用例，我们将动手推演在TSO的特定规则下，一段简单的并发程序可能产生的所有结果，并理解为何会出现与顺序一致性模型截然不同的意外行为。这个实践将帮助你建立一个关于存储缓冲如何工作的具体心智模型。[@problem_id:3656554]", "problem": "一个双核系统实现了完全存储定序（Total Store Order, TSO）。在TSO模型下，每个核心都有一个私有的先进先出（FIFO）存储缓冲区；一次存储操作在到达共享内存之前会先进入本地缓冲区，并在按程序顺序从缓冲区排出时变为全局可见。如果核心的存储缓冲区中存在对地址 $a$ 的写入，则该核心对地址 $a$ 的加载操作会从最近的这次写入中读取数据（存储到加载前递）；否则，它会从共享内存中读取当前值。程序中没有使用显式的内存屏障。\n\n两个共享变量 $x$ 和 $y$ 初始化为 $x=0$ 和 $y=0$。考虑以下双线程程序，其中 $W(v)\\leftarrow b$ 表示将值 $b$ 写入地址 $v$，而 $r \\leftarrow R(v)$ 表示从地址 $v$ 读取数据到寄存器 $r$：\n\n- 线程 $P_0$：$W(x)\\leftarrow 1$；然后 $r_1 \\leftarrow R(y)$。\n- 线程 $P_1$：$W(y)\\leftarrow 1$；然后 $r_2 \\leftarrow R(x)$。\n\n仅使用上述TSO的基本操作规则（每核心的FIFO存储缓冲区、对相同地址的存储到加载前递、以及加载操作可以读取内存而无需等待对不同地址的旧存储操作完成），确定在程序结束时TSO所允许的所有不同可观察结果对 $(r_1,r_2)$ 的集合 $S$ 的基数。\n\n将您的最终答案表示为给出 $|S|$ 的单个整数。无需四舍五入。", "solution": "问题要求我们确定在完全存储定序（TSO）内存一致性模型下，寄存器对 $(r_1, r_2)$ 所有可能的结果集。我们将根据所提供的规则来分析执行过程。\n\n共享内存的初始状态为 $x=0$ 和 $y=0$。\n两个线程执行以下指令：\n- 线程 $P_0$：$W(x)\\leftarrow 1$；然后 $r_1 \\leftarrow R(y)$。\n- 线程 $P_1$：$W(y)\\leftarrow 1$；然后 $r_2 \\leftarrow R(x)$。\n\nTSO的操作规则如下：\n1.  核心的存储操作 $W(v)\\leftarrow b$ 首先被放入该核心的私有FIFO存储缓冲区中。此时，该存储对其他核心尚不可见。\n2.  核心可以继续按程序顺序执行后续指令。\n3.  当存储操作从存储缓冲区的头部出队并写入共享内存时，它变得全局可见。存储操作按FIFO顺序排出。\n4.  核心的加载操作 $r \\leftarrow R(v)$ 首先检查自己的存储缓冲区。如果存在对同一地址 $v$ 的存储操作，则将最近一次此类存储的值前递到寄存器 $r$（存储到加载前递）。\n5.  如果本地存储缓冲区中没有对地址 $v$ 的存储操作，则加载操作从共享内存中读取值。\n6.  关键在于，即使存储缓冲区中存在对*不同*地址的更早的待处理存储操作，对地址 $v$ 的加载操作也可以执行。\n\n让我们分析 $(r_1, r_2)$ 的可能结果。寄存器只能存放值 $0$ 或 $1$。我们将研究四种可能的结果对——$(0,0)$、$(0,1)$、$(1,0)$ 和 $(1,1)$——是否都是允许的结果。在下文中，设 $SB_0$ 和 $SB_1$ 分别为 $P_0$ 和 $P_1$ 的存储缓冲区，并设 $Mem[v]$ 表示共享内存中变量 $v$ 的值。\n\n1.  **结果是否可能为 $(r_1, r_2) = (0, 1)$？**\n    是的。如果 $P_0$ 的操作在 $P_1$ 的读取操作之前有效完成，并且 $P_1$ 的写入操作对 $P_0$ 不可见，则可能发生这种情况。\n    - $P_0$ 执行 $W(x)\\leftarrow 1$。这将 $(x,1)$ 放入 $SB_0$。$Mem[x]=0$，$Mem[y]=0$。\n    - $P_0$ 执行 $r_1 \\leftarrow R(y)$。$SB_0$ 中包含对 $x$ 的存储，而不是 $y$。加载操作从内存中读取：$r_1 \\leftarrow Mem[y]$，其值为 $0$。因此，$r_1=0$。\n    - $SB_0$ 中的存储操作排入内存。现在 $Mem[x]=1$。\n    - $P_1$ 执行 $W(y)\\leftarrow 1$。这将 $(y,1)$ 放入 $SB_1$。$Mem[y]$ 仍为 $0$。\n    - $P_1$ 执行 $r_2 \\leftarrow R(x)$。$SB_1$ 中没有对 $x$ 的存储。加载操作从内存中读取：$r_2 \\leftarrow Mem[x]$，其值为 $1$。因此，$r_2=1$。\n    此执行轨迹产生结果 $(0, 1)$。\n\n2.  **结果是否可能为 $(r_1, r_2) = (1, 0)$？**\n    是的。这与前一种情况对称。\n    - $P_1$ 执行 $W(y)\\leftarrow 1$。这将 $(y,1)$ 放入 $SB_1$。$Mem[x]=0$，$Mem[y]=0$。\n    - $P_1$ 执行 $r_2 \\leftarrow R(x)$。$SB_1$ 中没有对 $x$ 的存储。加载操作从内存中读取：$r_2 \\leftarrow Mem[x]$，其值为 $0$。因此，$r_2=0$。\n    - $SB_1$ 中的存储操作排入内存。现在 $Mem[y]=1$。\n    - $P_0$ 执行 $W(x)\\leftarrow 1$。这将 $(x,1)$ 放入 $SB_0$。$Mem[x]$ 仍为 $0$。\n    - $P_0$ 执行 $r_1 \\leftarrow R(y)$。$SB_0$ 中没有对 $y$ 的存储。加载操作从内存中读取：$r_1 \\leftarrow Mem[y]$，其值为 $1$。因此，$r_1=1$。\n    此执行轨迹产生结果 $(1, 0)$。\n\n3.  **结果是否可能为 $(r_1, r_2) = (1, 1)$？**\n    是的。如果两次写入操作在任一读取操作发生之前都变为全局可见，则可能发生这种情况。\n    - $P_0$ 执行 $W(x)\\leftarrow 1$。将 $(x,1)$ 放入 $SB_0$。\n    - $P_1$ 执行 $W(y)\\leftarrow 1$。将 $(y,1)$ 放入 $SB_1$。\n    - $SB_0$ 中的存储操作排入内存。$Mem[x]$ 变为 $1$。\n    - $SB_1$ 中的存储操作排入内存。$Mem[y]$ 变为 $1$。\n    - $P_0$ 执行 $r_1 \\leftarrow R(y)$。加载操作从内存中读取：$r_1 \\leftarrow Mem[y]$，其值为 $1$。因此，$r_1=1$。\n    - $P_1$ 执行 $r_2 \\leftarrow R(x)$。加载操作从内存中读取：$r_2 \\leftarrow Mem[x]$，其值为 $1$。因此，$r_2=1$。\n    此执行轨迹产生结果 $(1, 1)$。\n\n4.  **结果是否可能为 $(r_1, r_2) = (0, 0)$？**\n    是的。这是像TSO这样的宽松内存模型的典型结果，在顺序一致性（Sequential Consistency）下是不允许的。这是可能的，因为加载操作可以绕过对不同地址的较早的存储操作。\n    - $P_0$ 执行 $W(x)\\leftarrow 1$。这将 $(x,1)$ 放入 $SB_0$。共享内存不变：$Mem[x]=0, Mem[y]=0$。\n    - $P_1$ 执行 $W(y)\\leftarrow 1$。这将 $(y,1)$ 放入 $SB_1$。共享内存仍然不变：$Mem[x]=0, Mem[y]=0$。\n    - $P_0$ 继续执行其下一条指令 $r_1 \\leftarrow R(y)$。其存储缓冲区 $SB_0$ 中有一个对 $x$ 的待处理存储。由于加载是针对不同地址（$y$），加载操作被允许绕过存储操作并直接从共享内存读取。$r_1 \\leftarrow Mem[y]$，其值为 $0$。因此，$r_1=0$。\n    - $P_1$ 继续执行其下一条指令 $r_2 \\leftarrow R(x)$。其存储缓冲区 $SB_1$ 中有一个对 $y$ 的待处理存储。这个对 $x$ 的加载操作也被允许绕过存储操作并从共享内存读取。$r_2 \\leftarrow Mem[x]$，其值为 $0$。因此，$r_2=0$。\n    - 稍后，$SB_0$ 和 $SB_1$ 中的存储操作将排入内存，但寄存器 $r_1$ 和 $r_2$ 已经捕获了 $(0, 0)$ 的状态。\n    此执行轨迹产生结果 $(0, 0)$。\n\n所有四个可能的 $(r_1, r_2)$ 值对在所述的TSO模型下都是允许的。不同可观察结果对的集合是 $S = \\{(0,0), (0,1), (1,0), (1,1)\\}$。\n该集合的基数是不同结果的总数。\n$$|S| = 4$$", "answer": "$$\\boxed{4}$$", "id": "3656554"}, {"introduction": "在理解了内存访问的顺序可能被重排之后，我们必须将内存一致性与另一个基本概念——原子性——区分开来。本练习将探讨“撕裂读”（Torn Read）现象，即一个线程读取到的数据是新旧值混合的“撕裂”状态。通过分析这个问题，你将清楚地认识到，内存一致性模型是针对一系列*原子*操作的排序进行约束的，而数据撕裂则是一个原子性问题，仅靠一致性模型本身无法解决。[@problem_id:3656511]", "problem": "考虑一个在内存中占用 $64$ 位的共享标量变量 $x$。令 $x[\\text{lo}]$ 表示低 $32$ 位 ($x[31:0]$)，$x[\\text{hi}]$ 表示高 $32$ 位 ($x[63:32]$)。初始状态为 $x = 0x0000000000000000$。三个线程在没有同步或内存屏障的情况下并发执行：\n\n- 线程 $T_0$：$x[\\text{lo}] := 0xAAAAAAAA$。\n- 线程 $T_1$：$x[\\text{hi}] := 0xBBBBBBBB$。\n- 线程 $T_2$：$r := \\text{load}_{64}(x)$，对 $x$ 的整个 $64$ 位值执行一次读取，其中 $r$ 是 $T_2$ 的局部变量。\n\n假设机器对内存的每个字节都是缓存一致的，并且编译器可能会根据可用的原子宽度将 $\\text{load}_{64}(x)$ 实现为单个 $64$ 位加载或两个 $32$ 位加载。定义“撕裂读”（torn read）为对 $64$ 位对象 $x$ 的任何读取，其返回值的低 $32$ 位和高 $32$ 位半区源于对 $x$ 的不同写事件。具体来说，“混合”值\n$$\nr_{\\text{mixed}} = (0xBBBBBBBB \\ll 32) + 0xAAAAAAAA\n$$\n就是这样一个候选结果，其中 $0xAAAAAAAA$ 由 $T_0$ 写入，$0xBBBBBBBB$ 由 $T_1$ 写入。\n\n你需要基于以下基本原则进行推理：\n- 内存一致性模型 (Memory Consistency Model, MCM) 的定义：一个约束内存操作的可见性和顺序的规则集（例如，顺序一致性 (Sequential Consistency, SC) 强制要求所有操作看起来像是以符合程序顺序的某个单一全局顺序交错执行），并假设内存操作在建模的粒度上是原子的。\n- 原子性 (atomicity) 的定义：如果一个操作相对于其他线程是不可分割的，那么它就是原子的；没有其他线程可以观察到该操作的部分效果。\n- 缓存一致性 (cache coherence) 的定义：对于每个字节可寻址的位置，存在一个一致的存储顺序，加载操作会返回该顺序中对该位置的最近一次存储。\n- C11/C++11 语言内存模型：对同一对象的非原子并发访问若无同步，则会产生数据竞争，从而导致未定义行为；对 $\\text{atomic}$ 对象的原子操作是不可分割的，并禁止字撕裂 (word tearing)。\n\n基于以上定义和上述场景，以下哪些陈述是正确的？\n\nA. 在一个抽象的顺序一致性 (Sequential Consistency) 模型下，如果在一台 $32$ 位机器上 $\\text{load}_{64}(x)$ 被实现为两次原子的 $32$ 位加载（一次加载 $x[\\text{lo}]$，一次加载 $x[\\text{hi}]$），那么结果 $r = r_{\\text{mixed}}$ 是被顺序一致性所允许的，因为 SC 对各个独立的 $32$ 位加载和存储进行排序，但并不要求读取的两个半区是同时发生的。\n\nB. 仅靠更强的内存一致性（例如，顺序一致性 (Sequential Consistency) 或完全存储定序 (Total Store Order)）就能禁止 $r = r_{\\text{mixed}}$ 的出现，无论 $\\text{load}_{64}(x)$ 是被原子地实现还是被实现为两次 $32$ 位的加载。\n\nC. 在 C11/C++11 内存模型中，如果 $x$ 是一个非原子对象，并且线程们执行了无同步的并发访问，那么程序就存在数据竞争，其行为是未定义的；该模型既不保证也不禁止观察到 $r = r_{\\text{mixed}}$。\n\nD. 在一个缺少无锁 $64$ 位原子操作的 $32$ 位架构上（因此 $\\text{load}_{64}(x)$ 会被编译成两次 $32$ 位加载），即使在顺序一致性 (Sequential Consistency) 模型下，$r = r_{\\text{mixed}}$ 也可能发生，因为 SC 会分别对两次 $32$ 位加载进行推理，并允许一种交错执行，使得读取的两个半区来自不同的存储操作。\n\nE. 缓存一致性保证 `r` 必须等于来自对 $x$ 的某次单一、完整存储的值；因此 $r = r_{\\text{mixed}}$ 是不可能的。\n\n选择所有正确的选项。", "solution": "问题要求我们评估关于三个并发线程对一个 $64$ 位共享变量 $x$ 进行内存操作的几个陈述。初始值为 $x = 0x0000000000000000$。这些线程在没有同步的情况下执行以下操作：\n- 线程 $T_0$：$x[\\text{lo}] := 0xAAAAAAAA$。我们把值 $0xAAAAAAAA$ 记为 $A$。这是一个对 $x$ 低半部分的 $32$ 位写操作。我们可以把这个操作记为 $W_A$。\n- 线程 $T_1$：$x[\\text{hi}] := 0xBBBBBBBB$。我们把值 $0xBBBBBBBB$ 记为 $B$。这是一个对 $x$ 高半部分的 $32$ 位写操作。我们可以把这个操作记为 $W_B$。\n- 线程 $T_2$：$r := \\text{load}_{64}(x)$。这是一个对整个 $64$ 位值的读操作。\n\n我们讨论的值是 $r_{\\text{mixed}} = 0xBBBBBBBBAAAAAAAA$，它对应于观察到高半部分是来自 $T_1$ 的写入，而低半部分是来自 $T_0$ 的写入。问题的关键在于内存一致性、缓存一致性和原子性之间的区别，特别是关于 $64$ 位加载是单个原子操作还是两个独立的 $32$ 位加载。\n\n基本原则如下：\n- **原子性 (Atomicity)**：一个操作如果对所有其他线程来说都像是瞬间发生的，那么它就是原子的。一个由两次 $32$ 位加载组成的非原子 $64$ 位加载可能被中断，这意味着其他线程可以在这两次组成加载之间执行操作。\n- **缓存一致性 (Cache Coherence)**：保证对于任何单个内存位置（例如，一个字节或一个字），所有处理器都能观察到一个单一、一致的写操作序列。它*不*强制规定对*不同*位置的写操作之间的任何顺序，也不保证多字操作的原子性。\n- **内存一致性模型 (MCM)**：定义了不同线程之间内存操作的允许顺序。顺序一致性 (SC) 是一个强模型，要求所有操作看起来都像是以某个单一的、与每个线程内部的程序顺序一致的全局顺序执行。\n- **C11/C++11 内存模型**：对于非原子变量，任何对同一内存位置的并发读和写，或两次写，若没有同步，就构成数据竞争，从而导致未定义行为 (Undefined Behavior, UB)。\n\n基于这些原则，我们来分析每个选项。\n\n**A. 在一个抽象的顺序一致性 (Sequential Consistency) 模型下，如果在一台 $32$ 位机器上 $\\text{load}_{64}(x)$ 被实现为两次原子的 $32$ 位加载（一次加载 $x[\\text{lo}]$，一次加载 $x[\\text{hi}]$），那么结果 $r = r_{\\text{mixed}}$ 是被顺序一致性所允许的，因为 SC 对各个独立的 $32$ 位加载和存储进行排序，但并不要求读取的两个半区是同时发生的。**\n\n该陈述是**正确的**。如果 `load_64(x)` 不是原子的，而是作为两次 $32$ 位的加载（$R_{\\text{hi}}$ 和 $R_{\\text{lo}}$）执行，那么 SC 推理所依据的基本原子操作就是 $32$ 位的写操作（$W_A$、$W_B$）和 $32$ 位的读操作。SC 要求这些原子操作存在一个单一的全序关系。如果 $T_0$ 和 $T_1$ 的写操作与 $T_2$ 的读操作交错执行，就有可能发生撕裂读。\n考虑以下操作的全局顺序，这是 SC 模型下一种有效的交错执行方式：\n1.  $T_1$ 执行其写操作：$W_B$ 将 $0xBBBBBBBB$ 存入 $x[\\text{hi}]$。\n2.  $T_2$ 执行高半部分的读操作：$R_{\\text{hi}}$ 读取 $x[\\text{hi}]$，得到 $0xBBBBBBBB$。\n3.  $T_0$ 执行其写操作：$W_A$ 将 $0xAAAAAAAA$ 存入 $x[\\text{lo}]$。\n4.  $T_2$ 执行低半部分的读操作：$R_{\\text{lo}}$ 读取 $x[\\text{lo}]$，得到 $0xAAAAAAAA$。\n最终在 $T_2$ 的寄存器 $r$ 中组装的值是 $0xBBBBBBBBAAAAAAAA$，即 $r_{\\text{mixed}}$。因为一个符合 SC 的有效交错执行能够导致这个结果，所以该结果是被 SC 所允许的。选项中给出的推理是合理的。\n\n**B. 仅靠更强的内存一致性（例如，顺序一致性 (Sequential Consistency) 或完全存储定序 (Total Store Order)）就能禁止 $r = r_{\\text{mixed}}$ 的出现，无论 $\\text{load}_{64}(x)$ 是被原子地实现还是被实现为两次 $32$ 位的加载。**\n\n该陈述是**不正确的**。\n- 情况 1：`load` 是两次 $32$ 位的加载。如选项 A 的分析所示，SC *允许* $r = r_{\\text{mixed}}$ 的结果。\n- 情况 2：`load` 是一个单一的原子 $64$ 位加载。在两次写操作 $W_A$ 和 $W_B$ 都完成后，$64$ 位变量 $x$ 的最终状态是 $0xBBBBBBBBAAAAAAAA$。一个原子的 $64$ 位加载可以在两次写操作都全局可见之后自由执行，在这种情况下，它将合法地读到 $r_{\\text{mixed}}$。一个强一致性模型并不禁止读取变量在某个时间点合法持有的值。\n由于该论断在两种情况下都为假，因此该陈述不正确。内存一致性无法在硬件不提供原子性的地方创造原子性，也不禁止读取有效的、已完全写入的状态。\n\n**C. 在 C11/C++11 内存模型中，如果 $x$ 是一个非原子对象，并且线程们执行了无同步的并发访问，那么程序就存在数据竞争，其行为是未定义的；该模型既不保证也不禁止观察到 $r = r_{\\text{mixed}}$。**\n\n该陈述是**正确的**。该场景描述了多个线程在没有同步的情况下访问同一内存对象 $x$，并且至少有一个访问是写操作（$T_0$ 和 $T_1$ 都在写入）。当 $x$ 是一个标准的非原子类型时，这正是 C11/C++11 内存模型中数据竞争的定义。数据竞争的后果是未定义行为 (Undefined Behavior, UB)。UB 意味着 C++ 标准对程序的行为不作任何要求。程序可能会崩溃，产生任意值，或者看起来像预期的那样工作。因此，实现可以自由地生成导致 $r = r_{\\text{mixed}}$ 的代码，但也可以自由地产生任何其他结果。模型“既不保证也不禁止”这个特定结果，这是对 UB 的精确描述。\n\n**D. 在一个缺少无锁 $64$ 位原子操作的 $32$ 位架构上（因此 $\\text{load}_{64}(x)$ 会被编译成两次 $32$ 位加载），即使在顺序一致性 (Sequential Consistency) 模型下，$r = r_{\\text{mixed}}$ 也可能发生，因为 SC 会分别对两次 $32$ 位加载进行推理，并允许一种交错执行，使得读取的两个半区来自不同的存储操作。**\n\n该陈述是**正确的**。这是对选项 A 中描述情况的一个更具体的重述。在一个没有原生 $64$ 位原子操作的 $32$ 位机器上，对 $x$ 的 $64$ 位加载必然是非原子的，被实现为两次独立的 $32$ 位加载。正如选项 A 的分析所确立的，顺序一致性是基于这些基本的 $32$ 位原子操作的序列进行推理的。它允许一种交错执行，即 $x$ 的一个半区在对另一个半区的写操作之前被读取，而 $x$ 的第二个半区在该写操作之后被读取，从而导致撕裂读。选项中提供的逻辑是完全正确的。\n\n**E. 缓存一致性保证 `r` 必须等于来自对 $x$ 的某次单一、完整存储的值；因此 `r = r_{\\text{mixed}}` 是不可能的。**\n\n该陈述是**不正确的**。这混淆了缓存一致性的保证和原子性的保证。缓存一致性确保所有处理器看到对*单个内存位置*的写操作的一致序列化。在这个问题中，$x[\\text{lo}]$ 和 $x[\\text{hi}]$ 是不同的内存位置（或者在缓存行内可以被视为不同）。一致性保证了对 $x[\\text{lo}]$ 的写操作有一致的视图，对 $x[\\text{hi}]$ 的写操作有另一个独立的一致视图。它*不*关联对这两个不同位置的写入时序。一个读操作必须返回来自“单一、完整存储”的值的陈述是原子读的属性，而这不是由缓存一致性保证的。由于 $64$ 位加载可能不是原子的，并且没有单一的 $64$ 位存储操作写入了 $r_{\\text{mixed}}$，因此缓存一致性并不禁止这个结果的出现。", "answer": "$$\\boxed{ACD}$$", "id": "3656511"}, {"introduction": "理解宽松内存模型的陷阱是第一步，更关键的是学会如何驾驭它。本练习将引导你从分析转向综合设计。你的任务是为一个复杂的多线程依赖关系，使用现代并发编程中极为重要的“释放-获取”（Release-Acquire）语义，设计一个正确且最小化的同步方案。这不仅能检验你对内存模型的理解深度，还能锻炼你构建可靠并发系统的实践能力。[@problem_id:3656597]", "problem": "考虑一个在 Release-Acquire (RA) 内存模型下运行的共享内存程序。在 RA 模型中，当一个标记为 acquire 的加载操作从同一个原子变量上读取由一个标记为 release 的存储操作写入的值时，就会创建一个潜在的线程间顺序。happens-before (hb) 关系被定义为每个线程内部的程序顺序 (program order, po) 加上由匹配的 release-acquire 对引发的 synchronizes-with (sw) 边的传递闭包；松散（relaxed）的加载和存储不贡献于线程间的 hb 关系。全局 hb 关系必须是无环的。\n\n给定一个有向有根依赖树，其节点是变量 $x_{1},\\dots,x_{10}$，其有向边编码了形式为“对父节点变量的写入应 happen-before 其子节点变量的首次读取”的预期。具体来说，该树的结构如下：\n- 根节点 $x_{1}$ 有子节点 $x_{2}$、$x_{3}$ 和 $x_{4}$。\n- 节点 $x_{2}$ 有子节点 $x_{5}$ 和 $x_{6}$。\n- 节点 $x_{3}$ 有子节点 $x_{7}$。\n- 节点 $x_{4}$ 有子节点 $x_{8}$、$x_{9}$ 和 $x_{10}$。\n\n每个变量 $x_{i}$ 由一个独立的线程 $T_{i}$ 所拥有。对于每条有向边 $x_{u} \\rightarrow x_{v}$，线程 $T_{u}$ 对 $x_{u}$ 执行一次写入操作，而线程 $T_{v}$ 稍后将对 $x_{v}$ 执行其首次读取操作。对于边 $x_{u} \\rightarrow x_{v}$ 的预期是，在全局 hb 关系中，对 $x_{u}$ 的写入必须 happen-before 对 $x_{v}$ 的首次读取。\n\n你只被允许以 RA 注解的形式放置“栅栏（fences）”：即对某个原子同步变量的存储操作施加 release 注解，以及对加载操作施加 acquire 注解。假设每个内部节点 $x_{u}$ 可以使用一个专用的原子标志 $f_{u}$ 与其所有子节点通信；一个子节点 $x_{v}$ 可以对 $f_{u}$ 执行 acquire 加载，以观察到 $T_{u}$ 已完成其写入操作。在同一个标志上，一个被观察到的 release-acquire 对（即 acquire 操作读取了 release 操作写入的值）会引发一个从 $T_{u}$到 $T_{v}$ 的 synchronizes-with 边。任何不由 release-acquire 对支持的顺序要求必须仅由线程内的 po 满足，并且不贡献于线程间的 hb 关系。你可以选择哪些存储是 release 存储，哪些加载是 acquire 加载；每个 RA 注解（存储上的 release 或加载上的 acquire）计为一个栅栏。\n\n计算所需的此类栅栏的最小总数，以确保对于树中的所有边 $x_{u} \\rightarrow x_{v}$，预期的“对 $x_{u}$ 的写入 happen-before 对 $x_{v}$ 的首次读取”顺序在全局 hb 关系中成立，并且全局 hb 关系保持无环。请用一个整数表示你的答案。无需四舍五入，也无需报告单位。", "solution": "该问题要求找到满足共享内存程序中一组顺序约束所需的“栅栏”（Release-Acquire 注解）的最小数量。这些约束源自一个依赖树结构，该结构涉及 $10$ 个变量 $x_1, \\dots, x_{10}$，每个变量分别由一个独立的线程 $T_1, \\dots, T_{10}$ 所拥有。\n\n核心要求是，对于给定树中的每条有向边 $x_u \\rightarrow x_v$，操作“对 $x_u$ 的写入”必须 happen-before “对 $x_v$ 的首次读取”。我们用 $W(x_u)$ 表示线程 $T_u$ 对变量 $x_u$ 的写入操作，用 $R(x_v)$ 表示线程 $T_v$ 对变量 $x_v$ 的首次读取操作。要求是确保对于所有边 $x_u \\rightarrow x_v$ 都有 $W(x_u) \\text{ hb } R(x_v)$。\n\nhappens-before 关系 ($hb$) 被定义为程序顺序 ($po$) 和 synchronizes-with ($sw$) 的传递闭包。\n一个 $sw$ 边在一个 release 存储和一个 acquire 加载之间建立，条件是它们作用于同一个原子变量，并且加载操作读取了存储操作写入的值。由于 $W(x_u)$ 和 $R(x_v)$ 发生在不同的线程（$T_u$ 和 $T_v$）中，它们之间的 $hb$ 关系不能仅通过 $po$ 建立。它必须依赖于一个包含至少一个 $sw$ 边的关系链。\n\n让我们分析单个父子依赖关系 $x_u \\rightarrow x_v$ 的机制。为了确保 $W(x_u) \\text{ hb } R(x_v)$，线程 $T_u$ 和 $T_v$ 可以按照题目中的规定，使用一个专用的原子标志，比如说 $f_u$。\n操作序列如下：\n1.  在线程 $T_u$ 中：写入操作 $W(x_u)$ 必须被排序在一个对标志 $f_u$ 的 release 存储之前。设这个存储操作为 $S(f_u)$。这给出了程序顺序关系 $W(x_u) \\text{ po } S(f_u)$。为了使之成为一个同步点，$S(f_u)$ 必须是一个 release 存储。这需要一个 `release` 注解，计为一个栅栏。\n2.  在线程 $T_v$ 中：一个从标志 $f_u$ 的 acquire 加载，我们称之为 $L(f_u)$，必须被排序在读取操作 $R(x_v)$ 之前。这给出了程序顺序关系 $L(f_u) \\text{ po } R(x_v)$。为了同步，$L(f_u)$ 必须是一个 acquire 加载。这需要一个 `acquire` 注解，这是另一个栅栏。\n\n如果线程 $T_v$ 中的 acquire 加载 $L(f_u)$ 读取了线程 $T_u$ 中的 release 存储 $S(f_u)$ 写入的值，就会创建一个 synchronizes-with 边：$S(f_u) \\text{ sw } L(f_u)$。\n根据 $hb$ 关系的传递性，我们有：\n$$W(x_u) \\xrightarrow{po} S(f_u) \\xrightarrow{sw} L(f_u) \\xrightarrow{po} R(x_v)$$\n这个复合关系意味着 $W(x_u) \\text{ hb } R(x_v)$，满足了边 $x_u \\rightarrow x_v$ 的约束。对于一条边，这个最小方案需要一个 release 栅栏和一个 acquire 栅栏，总共 $2$ 个栅栏。\n\n题目指出，一个内部节点 $x_u$ 可以使用单个标志 $f_u$ 与其*所有*子节点通信。让我们考虑一个拥有 $k$ 个子节点 $\\{x_{v_1}, x_{v_2}, \\dots, x_{v_k}\\}$ 的父节点 $x_u$。\n为了满足所有 $k$ 个依赖关系，即对于 $i=1, \\dots, k$ 都有 $W(x_u) \\text{ hb } R(x_{v_i})$：\n-   线程 $T_u$ 在其写入 $W(x_u)$ 之后，对其标志 $f_u$ 执行一次 `release` 存储。这花费 $1$ 个栅栏。\n-   每个子线程 $T_{v_i}$ 必须在其读取 $R(x_{v_i})$ 之前，对标志 $f_u$ 执行一次 `acquire` 加载。由于每个子节点都在一个独立的线程中，这需要 $k$ 次独立的 acquire 加载，每个子节点一次。这花费 $k$ 个栅栏。\n为一个有 $k$ 个子节点的父节点满足其所有依赖关系所需的栅栏总数是 $1+k$。这是最小数量，因为父节点的 release 是必需的，且每个子节点都必须独立地执行 acquire 以与父节点建立同步。\n\n为了找到最小栅栏总数，我们可以根据每个节点在树中的角色，将它们所需的栅栏数量相加。一个栅栏是对一个操作的注解。\n-   任何作为**父节点**（非叶节点）的节点都必须执行一次 `release` 存储来通知其子节点。这要求每个父节点有一个 release 栅栏。\n-   任何作为**子节点**（非根节点）的节点都必须执行一次 `acquire` 加载来与其父节点同步。这要求每个子节点有一个 acquire 栅栏。\n\n让我们从给定的树结构中识别出父节点和子节点：\n-   树的节点为 $x_1, \\dots, x_{10}$。\n-   $x_1$ 有子节点 $x_2, x_3, x_4$。\n-   $x_2$ 有子节点 $x_5, x_6$。\n-   $x_3$ 有子节点 $x_7$。\n-   $x_4$ 有子节点 $x_8, x_9, x_{10}$。\n\n**父节点**（非叶节点）的集合是 $P = \\{x_1, x_2, x_3, x_4\\}$。父节点的数量是 $|P| = 4$。这些节点中的每一个都对应一个必须执行一次 release 存储的线程。因此，release 栅栏的总数是 $4$。\n\n**子节点**（非根节点）的集合是 $C = \\{x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_{10}\\}$。子节点的数量是 $|C| = 9$。这些节点中的每一个都对应一个必须执行一次 acquire 加载的线程。因此，acquire 栅栏的总数是 $9$。\n\n最小栅栏总数是所有必需的 release 和 acquire 栅栏的总和。\n栅栏总数 = (release 栅栏数量) + (acquire 栅栏数量) = $|P| + |C| = 4 + 9 = 13$。\n\n节点 $x_2, x_3, x_4$ 既是父节点也是子节点。例如，线程 $T_2$ 必须对标志 $f_1$ 执行一次 acquire 加载以与其父节点 $T_1$ 同步，并对其自己的标志 $f_2$ 执行一次 release 存储以通知其子节点 $T_5$ 和 $T_6$。这在线程 $T_2$ 内部需要两个栅栏。这与我们的计数方法是一致的。\n\n最后，问题要求全局 `hb` 关系是无环的。我们方案建立的线程间 `hb` 关系都遵循依赖树中边的方向 ($T_{parent} \\rightarrow T_{child}$)。由于依赖结构是一棵树，它本身就是无环的。因此，线程间同步形成的图也是一个有向无环图，这保证了全局 `hb` 关系保持无环。\n\n所需的最小栅栏总数是 $13$。", "answer": "$$\\boxed{13}$$", "id": "3656597"}]}