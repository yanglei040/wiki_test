{"hands_on_practices": [{"introduction": "同时多线程（SMT）通过在单个处理器核心上交错执行多个线程的指令，从而提高了吞吐量。然而，这种性能提升并非没有代价。本练习将引导你使用经典的CPU性能公式，量化SMT带来的双重影响：一方面通过隐藏延迟减少了停顿周期，另一方面由于资源竞争又可能增加指令数量。通过这个计算，你将更深入地理解SMT性能表现的本质权衡。[@problem_id:3631114]", "problem": "一个单核中央处理器 (CPU) 以 $f = 3.2~\\text{GHz}$ 的固定时钟频率执行程序 A。当该程序以单线程模式运行时，测得的每线程基准每指令周期数 (CPI) 分解为非停顿部分 $CPI_{\\text{base}} = 0.90$ 和停顿部分 $CPI_{\\text{stall},0} = 0.60$。基准每线程指令数为 $IC_{0} = 1.80 \\times 10^{9}$ 条指令。\n\n现在考虑启用同时多线程 (SMT)，也称为超线程，其中两个硬件线程共享该核心。由于长延迟事件的重叠，每线程的 CPI 停顿部分相对于其单线程值减少了 $30\\%$。然而，共享资源争用使每线程指令数相对于其单线程值增加了 $1\\%$。假设在 SMT 下，每线程的非停顿部分 $CPI_{\\text{base}}$ 保持不变，且时钟频率不发生变化。\n\n计算程序 A 在 SMT 下的每线程执行时间 $T$。最终答案以秒为单位，并四舍五入到四位有效数字。", "solution": "在尝试解答之前，对问题进行验证。\n\n### 第1步：提取已知条件\n-   时钟频率: $f = 3.2~\\text{GHz}$\n-   单线程非停顿每指令周期数 (CPI): $CPI_{\\text{base}} = 0.90$\n-   单线程停顿 CPI: $CPI_{\\text{stall},0} = 0.60$\n-   单线程基准指令数: $IC_{0} = 1.80 \\times 10^{9}$ 条指令\n-   同时多线程 (SMT) 硬件线程数: $2$\n-   在 SMT 下每线程停顿 CPI 的减少量: $30\\%$\n-   在 SMT 下每线程指令数的增加量: $1\\%$\n-   恒定的每线程非停顿 CPI: $CPI_{\\text{base}}$ 不变。\n-   恒定的时钟频率: $f$ 不变。\n-   目标: 计算程序 A 在 SMT 下的每线程执行时间 $T$。\n\n### 第2步：使用提取的已知条件进行验证\n评估问题的有效性。\n-   **科学性**：该问题利用了基本的 CPU 性能方程和计算机组成与体系结构中的标准概念，包括 CPI、指令数、时钟频率和 SMT。所描述的 SMT 效应——通过延迟隐藏减少停顿周期和由于资源争用增加指令数——是记录详实且符合现实的现象。提供的数值对于现代处理器是合理的。\n-   **良构性**：该问题给出了计算唯一解所需的所有数据和约束，目标明确。\n-   **客观性**：该问题以精确、定量和不偏不倚的语言表述。\n\n该问题未违反任何无效标准。它具有科学性、良构性和客观性。\n\n### 第3步：结论与行动\n该问题被判定为**有效**。将推导解答。\n\n程序在 CPU 上的执行时间由 CPU 性能方程确定：\n$$T = \\frac{IC \\times CPI}{f}$$\n其中 $IC$ 是指令数，$CPI$ 是平均每指令周期数，$f$ 是时钟频率。$CPI$ 可以分解为非停顿部分 $CPI_{\\text{base}}$ 和停顿部分 $CPI_{\\text{stall}}$：\n$$CPI = CPI_{\\text{base}} + CPI_{\\text{stall}}$$\n\n首先，我们确定单线程执行模式的参数。此模式下的总 CPI，$CPI_{0}$，为：\n$$CPI_{0} = CPI_{\\text{base}} + CPI_{\\text{stall},0} = 0.90 + 0.60 = 1.50$$\n给定的时钟频率为 $f = 3.2~\\text{GHz} = 3.2 \\times 10^{9}~\\text{Hz}$。\n\n接下来，我们确定在 SMT 下运行的单个线程的参数。用下标 $SMT$ 表示这些参数。\n\n在 SMT 下，每线程指令数 $IC_{SMT}$ 相对于基准指令数 $IC_{0}$ 增加了 $1\\%$：\n$$IC_{SMT} = IC_{0} \\times (1 + 0.01) = 1.01 \\times IC_{0}$$\n代入 $IC_{0}$ 的值：\n$$IC_{SMT} = 1.01 \\times (1.80 \\times 10^{9}) = 1.818 \\times 10^{9}~\\text{条指令}$$\n\n在 SMT 下，每线程的 CPI 停顿部分 $CPI_{\\text{stall},SMT}$ 相对于其单线程值 $CPI_{\\text{stall},0}$ 减少了 $30\\%$：\n$$CPI_{\\text{stall},SMT} = CPI_{\\text{stall},0} \\times (1 - 0.30) = 0.70 \\times CPI_{\\text{stall},0}$$\n代入 $CPI_{\\text{stall},0}$ 的值：\n$$CPI_{\\text{stall},SMT} = 0.70 \\times 0.60 = 0.42$$\n\nCPI 的非停顿部分 $CPI_{\\text{base}}$ 保持不变。因此，在 SMT 下的总每线程 CPI，$CPI_{SMT}$，为：\n$$CPI_{SMT} = CPI_{\\text{base}} + CPI_{\\text{stall},SMT} = 0.90 + 0.42 = 1.32$$\n\n现在，我们可以使用 CPU 性能方程计算在 SMT 下的每线程执行时间 $T_{SMT}$。时钟频率 $f$ 保持不变。\n$$T_{SMT} = \\frac{IC_{SMT} \\times CPI_{SMT}}{f}$$\n代入计算出的值：\n$$T_{SMT} = \\frac{(1.818 \\times 10^{9}) \\times 1.32}{3.2 \\times 10^{9}~\\text{Hz}}$$\n分子和分母中的因子 $10^{9}$ 被消掉：\n$$T_{SMT} = \\frac{1.818 \\times 1.32}{3.2}~\\text{s}$$\n$$T_{SMT} = \\frac{2.39976}{3.2}~\\text{s}$$\n$$T_{SMT} = 0.749925~\\text{s}$$\n\n问题要求最终答案四舍五入到四位有效数字。\n第五位有效数字是 $2$，小于 $5$，因此我们向下舍入。\n$$T_{SMT} \\approx 0.7499~\\text{s}$$", "answer": "$$\n\\boxed{0.7499}\n$$", "id": "3631114"}, {"introduction": "上一节我们从宏观上看到了SMT如何影响执行时间，现在我们将深入微架构层面，探究其工作原理。一个超标量处理器核心拥有多个执行端口（如整数、浮点、内存单元），但单个线程往往无法使其全部保持繁忙。本练习通过一个概率模型，让你计算和比较单线程与SMT模式下执行端口的期望占用率，直观地揭示SMT如何通过填补执行资源中的“空闲气泡”来提升整体效率。[@problem_id:3677167]", "problem": "一个支持同时多线程 (SMT) 的超标量核心拥有 $3$ 个不相交的、单发射执行端口：整数算术端口 $p_{0}$、整数算术端口 $p_{1}$ 和一个内存端口 $p_{M}$。每个端口每个周期最多可以发射 $1$ 个微操作，且每个发射的微操作恰好需要这些端口中的一个。硬件在满足每个端口容量限制的前提下，发射所有就绪的微操作；如果来自不同线程的多个就绪微操作在同一周期内同时需要同一个端口，则通过公平仲裁精确选择一个，但该周期内该端口最多只能发射一个。考虑以下两个线程：\n- 线程 A：在任何周期内，它有就绪微操作的概率为 $0.92$；在就绪的条件下，该微操作需要端口 $p_{0}$ 的概率为 $0.50$，需要端口 $p_{1}$ 的概率为 $0.30$，需要端口 $p_{M}$ 的概率为 $0.20$。\n- 线程 B：在任何周期内，它有就绪微操作的概率为 $0.85$；在就绪的条件下，该微操作需要端口 $p_{0}$ 的概率为 $0.20$，需要端口 $p_{1}$ 的概率为 $0.60$，需要端口 $p_{M}$ 的概率为 $0.20$。\n\n假设就绪状态和操作类型的选择在线程间和周期内是独立的。将一个端口的预期每周期占用率定义为该端口在任意周期内发射一个微操作的长期概率。计算在单线程执行 $T=1$（只有线程 A 存在）和双线程 SMT $T=2$（线程 A 和 B 都存在）情况下每个端口的预期占用率。将您的最终答案表示为一个行向量\n$$\n\\big[\\,O_{p_{0}}^{(T=1)},\\,O_{p_{1}}^{(T=1)},\\,O_{p_{M}}^{(T=1)},\\,O_{p_{0}}^{(T=2)},\\,O_{p_{1}}^{(T=2)},\\,O_{p_{M}}^{(T=2)}\\,\\big]\n$$\n四舍五入到四位有效数字。不需要单位。", "solution": "问题要求计算三个执行端口（$p_0$、$p_1$、$p_M$）在两种情况下的预期每周期占用率：单线程执行（$T=1$），只有线程 A；以及双线程同时多线程（SMT）执行（$T=2$），有线程 A 和 B。预期占用率定义为一个端口在给定周期内发射一个微操作的概率。\n\n首先，我们使用概率符号来形式化给定的信息。\n设 $R_A$ 表示线程 A 在一个周期内有就绪微操作的事件，设 $R_B$ 表示线程 B 有就绪微操作的事件。给出的概率如下：\n$$P(R_A) = 0.92$$\n$$P(R_B) = 0.85$$\n\n设 $C_{A,i}$ 表示线程 A 的一个就绪微操作需要端口 $p_i$ 的事件，其中 $i \\in \\{0, 1, M\\}$。条件概率如下：\n$$P(C_{A,0} | R_A) = 0.50$$\n$$P(C_{A,1} | R_A) = 0.30$$\n$$P(C_{A,M} | R_A) = 0.20$$\n注意，这些概率之和为 $1$，符合预期：$0.50 + 0.30 + 0.20 = 1.0$。\n\n类似地，设 $C_{B,i}$ 表示线程 B 的一个就绪微操作需要端口 $p_i$ 的事件。条件概率如下：\n$$P(C_{B,0} | R_B) = 0.20$$\n$$P(C_{B,1} | R_B) = 0.60$$\n$$P(C_{B,M} | R_B) = 0.20$$\n这些概率之和也为 $1$：$0.20 + 0.60 + 0.20 = 1.0$。\n\n设 $U_{A,i}$ 为线程 A 在一个周期内需要端口 $p_i$ 的事件。这当且仅当线程 A 有一个就绪的微操作并且该操作需要端口 $p_i$ 时发生。因此，$U_{A,i} = R_A \\cap C_{A,i}$。这个联合事件的概率是：\n$$P(U_{A,i}) = P(R_A \\cap C_{A,i}) = P(C_{A,i} | R_A) P(R_A)$$\n类似地，设 $U_{B,i}$ 为线程 B 需要端口 $p_i$ 的事件。其概率是：\n$$P(U_{B,i}) = P(R_B \\cap C_{B,i}) = P(C_{B,i} | R_B) P(R_B)$$\n\n问题说明所有事件在线程间和周期内是独立的。\n\n让我们为每个端口 $p_i$ 计算概率 $P(U_{A,i})$ 和 $P(U_{B,i})$：\n对于线程 A：\n$$P(U_{A,0}) = 0.50 \\times 0.92 = 0.46$$\n$$P(U_{A,1}) = 0.30 \\times 0.92 = 0.276$$\n$$P(U_{A,M}) = 0.20 \\times 0.92 = 0.184$$\n\n对于线程 B：\n$$P(U_{B,0}) = 0.20 \\times 0.85 = 0.17$$\n$$P(U_{B,1}) = 0.60 \\times 0.85 = 0.51$$\n$$P(U_{B,M}) = 0.20 \\times 0.85 = 0.17$$\n\n现在我们可以计算两种情况下的端口占用率。设 $O_{p_i}^{(T)}$ 为有 $T$ 个线程时端口 $p_i$ 的占用率。\n\n情况 1：单线程执行（$T=1$，只有线程 A）\n在这种情况下，一个端口 $p_i$ 被占用当且仅当线程 A 需要它。因此，占用率就是概率 $P(U_{A,i})$。\n$$O_{p_0}^{(T=1)} = P(U_{A,0}) = 0.46$$\n$$O_{p_1}^{(T=1)} = P(U_{A,1}) = 0.276$$\n$$O_{p_M}^{(T=1)} = P(U_{A,M}) = 0.184$$\n\n情况 2：双线程 SMT 执行（$T=2$，线程 A 和 B）\n在 SMT 情况下，如果至少有一个线程需要端口 $p_i$，那么该端口就被占用。也就是说，如果线程 A 需要它，或者线程 B 需要它。端口 $p_i$ 被占用的事件是并集 $U_{A,i} \\cup U_{B,i}$。占用率是这个并集的概率。\n$$O_{p_i}^{(T=2)} = P(U_{A,i} \\cup U_{B,i})$$\n使用容斥原理，以及两个线程的独立性（这意味着 $P(U_{A,i} \\cap U_{B,i}) = P(U_{A,i}) P(U_{B,i})$），我们有：\n$$O_{p_i}^{(T=2)} = P(U_{A,i}) + P(U_{B,i}) - P(U_{A,i}) P(U_{B,i})$$\n或者，如果端口不空闲，则它被占用。一个端口只有在两个线程都不需要它时才空闲。\n$$O_{p_i}^{(T=2)} = 1 - P(\\text{端口 } p_i \\text{ 空闲}) = 1 - P(\\neg U_{A,i} \\cap \\neg U_{B,i})$$\n根据独立性，这等于：\n$$O_{p_i}^{(T=2)} = 1 - P(\\neg U_{A,i}) P(\\neg U_{B,i}) = 1 - (1 - P(U_{A,i}))(1 - P(U_{B,i}))$$\n这个公式是等价的，并且在计算上是稳定的。\n\n对于端口 $p_0$：\n$$O_{p_0}^{(T=2)} = 1 - (1 - 0.46)(1 - 0.17) = 1 - (0.54)(0.83) = 1 - 0.4482 = 0.5518$$\n\n对于端口 $p_1$：\n$$O_{p_1}^{(T=2)} = 1 - (1 - 0.276)(1 - 0.51) = 1 - (0.724)(0.49) = 1 - 0.35476 = 0.64524$$\n\n对于端口 $p_M$：\n$$O_{p_M}^{(T=2)} = 1 - (1 - 0.184)(1 - 0.17) = 1 - (0.816)(0.83) = 1 - 0.67728 = 0.32272$$\n\n问题要求最终答案四舍五入到四位有效数字。\n$O_{p_0}^{(T=1)} = 0.46 \\rightarrow 0.4600$\n$O_{p_1}^{(T=1)} = 0.276 \\rightarrow 0.2760$\n$O_{p_M}^{(T=1)} = 0.184 \\rightarrow 0.1840$\n$O_{p_0}^{(T=2)} = 0.5518 \\rightarrow 0.5518$\n$O_{p_1}^{(T=2)} = 0.64524 \\rightarrow 0.6452$\n$O_{p_M}^{(T=2)} = 0.32272 \\rightarrow 0.3227$\n\n最终结果是按指定顺序排列的这六个值的行向量。\n$$\n\\big[\\,O_{p_{0}}^{(T=1)},\\,O_{p_{1}}^{(T=1)},\\,O_{p_{M}}^{(T=1)},\\,O_{p_{0}}^{(T=2)},\\,O_{p_{1}}^{(T=2)},\\,O_{p_{M}}^{(T=2)}\\,\\big]\n$$\n$$\n\\big[\\,0.4600,\\,0.2760,\\,0.1840,\\,0.5518,\\,0.6452,\\,0.3227\\,\\big]\n$$", "answer": "$$\n\\boxed{\n\\begin{bmatrix}\n0.4600  0.2760  0.1840  0.5518  0.6452  0.3227\n\\end{bmatrix}\n}\n$$", "id": "3677167"}, {"introduction": "在多线程编程中，“伪共享”（false sharing）是一个众所周知的性能陷阱，它发生在不同核心上的线程访问同一缓存行中的不同数据时。那么，当SMT的两个“兄弟”线程在同一个核心上做类似操作时，会发生什么呢？本练习旨在澄清一个常见的误解，通过分析在共享L1缓存的SMT线程之间的数据访问模式，帮助你区分核心内部的资源竞争与核心之间的缓存一致性开销。[@problem_id:3641063]", "problem": "考虑一个支持同步多线程（SMT）的单个物理处理器核心，该核心有 $2$ 个逻辑线程，一个在逻辑线程之间共享的一级数据缓存（L1D），以及一个修改-独占-共享-无效（MESI）缓存一致性协议。假设以下经过充分检验的事实和定义为基本前提：\n\n- 缓存行是一致性的单位，MESI 协议按缓存行而不是按线程跟踪状态。只有当多个物理核心以冲突的方式访问同一缓存行时，才需要进行一致性失效；同一物理核心上的逻辑线程共享相同的私有一级数据缓存内容。\n- 该核心使用写回（write-back）、写分配（write-allocate）策略。对已存在于 L1D 中且可写的数据的存储操作会在该缓存中命中，并且不会立即传播到更低级别的缓存。\n- 该核心有一个到 L1D 的存储数据执行端口，在稳态下，每个周期最多可以完成 $1$ 个对齐的 $w$ 字节存储。设每次存储的大小为 $w = 8$ 字节。\n- L1D 缓存行大小为 $\\ell = 64$ 字节。\n- 核心频率为 $f = 3.0 \\times 10^{9}$ 周期/秒。\n\n两个兄弟逻辑线程（线程 $0$ 和线程 $1$）在同一个物理核心上执行。每个线程无限循环，对其自己的内存位置执行存储操作，没有读取、栅栏或系统调用，并且该内存区域不被任何其他物理核心或设备触及。考虑两种情况：\n\n- 情况 $\\mathrm{S}$（相同行）：线程 $0$ 和线程 $1$ 各自重复地向位于同一 $\\ell$ 字节缓存行内的不同 $8$ 字节字进行存储（例如，单个行内偏移量为 $0$ 和 $8$ 的位置）。每个线程在每次迭代中都向同一个字进行存储，因此工作集保持为一行。\n- 情况 $\\mathrm{D}$（不同行）：线程 $0$ 和线程 $1$ 各自重复地向位于不同缓存行中的不同 $8$ 字节字进行存储。每个线程的工作集保持为一行，且这两行是不同的。\n\n在任何初始行分配后的稳态下，根据上述资源和一致性约束，预测情况 $\\mathrm{S}$ 和情况 $\\mathrm{D}$ 下两个线程的总持续存储吞吐量 $T$。选择最佳选项。\n\nA. $T_{\\mathrm{S}} \\approx T_{\\mathrm{D}} \\approx f \\times w = 3.0 \\times 10^{9} \\times 8 \\approx 24 \\,\\text{千兆字节/秒}$，因为两种情况都是在单个核心上的 L1D 存储命中，没有一致性失效，并且 SMT 线程共享同一个存储数据端口。\n\nB. $T_{\\mathrm{S}} \\ll T_{\\mathrm{D}}$ （例如，$T_{\\mathrm{S}}$ 低于 $1 \\,\\text{千兆字节/秒}$），因为对同一缓存行中的不同字进行存储会在兄弟线程之间引发伪共享，导致在共享的 L1D 上频繁发生一致性失效和缓存行乒乓。\n\nC. $T_{\\mathrm{D}}  T_{\\mathrm{S}}$ 大约 $2$ 倍（例如，$T_{\\mathrm{D}} \\approx 48 \\,\\text{千兆字节/秒}$ 而 $T_{\\mathrm{S}} \\approx 24 \\,\\text{千兆字节/秒}$），因为写入不同的行允许 L1D 并行使用多个写端口或存储体，而当两个线程都以同一行为目标时，这些端口或存储体是不可用的。\n\nD. $T_{\\mathrm{S}}  T_{\\mathrm{D}}$ （例如，$T_{\\mathrm{S}} \\approx 30 \\,\\text{千兆字节/秒}$ 而 $T_{\\mathrm{D}} \\approx 24 \\,\\text{千兆字节/秒}$），因为两个线程写入同一行可以实现跨线程写合并，从而有效地将每周期存储完成率提高到超出单个端口的限制。", "solution": "该问题要求在两种不同的内存访问模式下，预测运行在单个启用SMT的物理核心上的两个逻辑线程的总持续存储吞吐量。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 核心：单个支持同步多线程（SMT）的物理处理器核心。\n- 逻辑线程：$2$ 个（线程 $0$，线程 $1$）。\n- 一级数据缓存（L1D）：在两个逻辑线程之间共享。\n- 缓存一致性协议：修改-独占-共享-无效（MESI）。\n- 一致性范围：一致性失效发生在多个物理核心之间；同一核心上的逻辑线程共享L1D内容，无需此类失效。\n- 缓存策略：写回、写分配。\n- 执行资源：一个到 L1D 的存储数据执行端口。\n- 存储端口吞吐量：在稳态下，每个周期最多完成 $1$ 个对齐的 $w$ 字节存储。\n- 存储大小：$w = 8$ 字节。\n- L1D 缓存行大小：$\\ell = 64$ 字节。\n- 核心频率：$f = 3.0 \\times 10^{9}$ 周期/秒。\n- 情况 S（相同行）：两个线程都向位于同一 $\\ell=64$ 字节缓存行内的不同 $8$ 字节字进行存储。\n- 情况 D（不同行）：两个线程向位于不同缓存行中的 $8$ 字节字进行存储。\n- 场景约束：线程无限循环执行存储；内存区域不被其他核心访问；分析针对初始行分配后的稳态。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在现代计算机体系结构原理方面有充分的依据。它准确地描述了一种常见配置：一个带有共享 L1D 缓存的 SMT 核心、特定的存储流水线限制和标准的缓存一致性协议（MESI）。核心间一致性与核心内资源共享之间的区别是一个关键且陈述正确的概念。\n- **问题定义明确**：该问题定义明确。它提供了计算理论最大吞吐量所需的所有必要参数（$f, w$，存储端口限制）。两种场景（情况 S 和情况 D）定义清晰，可以进行比较分析。可以从给定的条件中推导出理论吞吐量的唯一、稳定解。\n- **客观性**：该问题使用精确的技术语言和量化数据进行客观陈述。它不含主观性论断。\n- **完整性和一致性**：问题陈述是自洽且一致的。它提供了一个简化但连贯的处理器核心模型。“一个存储数据执行端口”这一明确约束是主要瓶颈，提供的其他细节与此模型一致。\n\n**步骤 3：结论和行动**\n问题陈述有效。它提出了一个清晰、一致且科学合理的分析场景。我将继续进行解答。\n\n### 解答推导\n\n这个问题的核心在于识别所述工作负载的主要性能瓶颈。问题指出，该物理核心有**一个存储数据执行端口**，每个周期最多可以完成**$1$ 个对齐的 $w$ 字节存储**。\n\n由于两个逻辑线程（线程 $0$ 和线程 $1$）都在同一个物理核心上执行，它们必须共享这一个存储数据端口。同步多线程允许来自两个线程的指令都存在于处理器的流水线中，但它们仍然必须竞争有限的物理资源以执行。在这种情况下，关键的共享资源是存储端口。\n\n因此，两个线程的总存储吞吐量 $T$ 受限于该单个端口服务存储操作的最大速率。这个最大速率给定为每个周期 $1$ 次存储。\n\n吞吐量（字节/秒）可以计算如下：\n$$T = (\\text{每周期存储次数}) \\times (\\text{每次存储的字节数}) \\times (\\text{每秒周期数})$$\n\n使用给定的值：\n- 每周期存储次数：$1$\n- 每次存储的字节数：$w = 8$ 字节\n- 每秒周期数：$f = 3.0 \\times 10^{9} \\text{ s}^{-1}$\n\n所以，理论上的最大总吞吐量是：\n$$T_{\\text{max}} = 1 \\frac{\\text{store}}{\\text{cycle}} \\times 8 \\frac{\\text{bytes}}{\\text{store}} \\times 3.0 \\times 10^{9} \\frac{\\text{cycles}}{\\text{s}} = 24.0 \\times 10^{9} \\frac{\\text{bytes}}{\\text{s}} = 24 \\text{ GB/s}$$\n\n现在我们必须分析情况 S 和情况 D 是否与此基准不同。\n\n**情况 D（不同行）：**\n线程 $0$ 向缓存行 $L_A$ 中的一个位置存储，线程 $1$ 向缓存行 $L_B$ 中的一个位置存储，其中 $L_A \\neq L_B$。在稳态下，两个存储都是在共享的 L1D 缓存中命中。这两个线程将发出存储指令，这些指令将由单个存储数据执行端口进行交错和序列化处理。总吞吐量将受限于此端口，因此我们预期 $T_{\\mathrm{D}} \\approx T_{\\text{max}} = 24 \\text{ GB/s}$。\n\n**情况 S（相同行）：**\n线程 $0$ 和线程 $1$ 向同一缓存行 $L_C$ 内的不同字进行存储。在这里，“伪共享”的分析至关重要。\n- 问题明确指出，“只有当多个物理核心访问同一缓存行时...才需要进行一致性失效；同一物理核心上的逻辑线程共享相同的私有一级数据缓存内容。”\n- 这意味着 MESI 协议不会被调用以在兄弟线程之间使缓存行失效，因为它们访问的是*完全相同*的物理缓存和*完全相同*的缓存行副本。在不同缓存之间不存在缓存行的“乒乓效应”。伪共享现象，即由于*不同核心*之间的一致性流量导致的严重性能下降，在这里并不适用。\n\n情况 S 中的争用纯粹是针对核心内部资源。两个线程的存储操作都必须通过单个存储数据端口完成。从端口的角度来看，它接收一个存储请求流。这些请求针对同一缓存行（但不同的字）这一事实，并不会改变它每个周期只能服务一个请求的基本约束。虽然可能存在像存储体冲突这样复杂的微架构效应，但问题中明确指出的主要约束是单个完成端口。因此，总吞吐量仍然受限于该端口的最大速率。我们预期 $T_{\\mathrm{S}} \\approx T_{\\text{max}} = 24 \\text{ GB/s}$。\n\n**结论：**\n根据所提供的模型，单个存储数据端口在两种情况下都是限制因素。表征核心间伪共享的争用类型（一致性失效）不存在。因此，两种情况下的总吞吐量应该大致相同。\n$$T_{\\mathrm{S}} \\approx T_{\\mathrm{D}} \\approx 24 \\text{ GB/s}$$\n\n### 逐项分析选项\n\n**A. $T_{\\mathrm{S}} \\approx T_{\\mathrm{D}} \\approx f \\times w = 3.0 \\times 10^{9} \\times 8 \\approx 24 \\,\\text{千兆字节/秒}$，因为两种情况都是在单个核心上的 L1D 存储命中，没有一致性失效，并且 SMT 线程共享同一个存储数据端口。**\n该选项正确地指出了单个存储数据端口是 SMT 核心上两个线程的共同瓶颈。它正确地计算出由此产生的吞吐量为 $f \\times w = (3.0 \\times 10^9) \\times 8 = 24 \\times 10^9$ 字节/秒，即 $24$ GB/s。它还正确地指出没有一致性失效，否定了将“伪共享”概念错误地应用于单个核心上的兄弟线程的情况。推理是合理的，并且与推导过程完全一致。\n**结论：正确**\n\n**B. $T_{\\mathrm{S}} \\ll T_{\\mathrm{D}}$ （例如，$T_{\\mathrm{S}}$ 低于 $1 \\,\\text{千兆字节/秒}$），因为对同一缓存行中的不同字进行存储会在兄弟线程之间引发伪共享，导致在共享的 L1D 上频繁发生一致性失效和缓存行乒乓。**\n这个选项有根本性的缺陷。它误解了“伪共享”。正如问题陈述中明确澄清的，以及 SMT 架构的实际情况，同一核心上的兄弟线程共享 L1D 缓存。缓存行只有一个副本，因此它们之间不可能发生 MESI 级别的失效或“乒乓效应”。其论点的前提是错误的。\n**结论：错误**\n\n**C. $T_{\\mathrm{D}}  T_{\\mathrm{S}}$ 大约 $2$ 倍（例如，$T_{\\mathrm{D}} \\approx 48 \\,\\text{千兆字节/秒}$ 而 $T_{\\mathrm{S}} \\approx 24 \\,\\text{千兆字节/秒}$），因为写入不同的行允许 L1D 并行使用多个写端口或存储体，而当两个线程都以同一行为目标时，这些端口或存储体是不可用的。**\n这个选项与问题的一个关键前提相矛盾。问题明确指出，核心有“一个存储数据执行端口”，能够“每个周期最多完成 $1$ 个对齐的 $w$ 字节存储”。$48$ GB/s 的吞吐量将需要每个周期完成 $2$ 次存储，这在给定的约束条件下是不可能的。多个写端口的存在是问题陈述中不支持的虚构。\n**结论：错误**\n\n**D. $T_{\\mathrm{S}}  T_{\\mathrm{D}}$ （例如，$T_{\\mathrm{S}} \\approx 30 \\,\\text{千兆字节/秒}$ 而 $T_{\\mathrm{D}} \\approx 24 \\,\\text{千兆字节/秒}$），因为两个线程写入同一行可以实现跨线程写合并，从而有效地将每周期存储完成率提高到超出单个端口的限制。**\n这个选项也是有缺陷的。$30$ GB/s 的吞吐量将需要每周期完成 $30 / (8 \\times 3) = 1.25$ 次存储，这超过了单个存储端口每周期 1 次存储的硬性限制。虽然先进的微架构可能具有写合并等功能，但它们不能违反完成指令的执行单元的基本吞吐量限制。声称完成率可以“超出单个端口的限制”与给定的约束相矛盾。\n**结论：错误**", "answer": "$$\\boxed{A}$$", "id": "3641063"}]}