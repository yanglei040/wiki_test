{"hands_on_practices": [{"introduction": "网络拓扑结构是互连网络设计的基石，它直接决定了通信的基本成本。平均跳数（average hop count）是衡量网络通信延迟的一个基本指标。这项练习将引导你通过第一性原理，计算并比较三种经典拓扑结构——总线、环形和网格——的平均跳数，从而建立起关于网络结构如何影响通信代价的直观理解 [@problem_id:3652325]。", "problem": "一个多处理器片上系统采用三种备选的互连拓扑结构来承载一致性流量，以在共享者之间移动缓存行：共享总线、双向环和二维网格片上网络（NoC）。所有拓扑结构都具有相同数量的核心，$N = 64$。在网格情况下，核心排列在一个规整的 $8 \\times 8$ 网格上，路由器位于网格交叉点，缓存行数据沿源和目的地之间的维度顺序路径（曼哈顿路由）传输。在环情况下，路由器以循环方式连接，数据总是沿着环周围两个方向中较短的一个方向传输。在总线情况下，所有核心都连接到一个单一的共享介质。假设采用基于目录的缓存一致性协议（DCCP），并且缓存行从当前所有者到请求共享者的传输沿拓扑中的最短路径进行，没有通过宿主节点的间接传输，也没有竞争或排队。\n\n将一次传输的跳数定义为缓存行数据从源到目的地沿最短路径所经过的不同路由器间链路段的数量。对于总线，无论源和目的地的连接点在哪里，都将共享介质的遍历视为一次单跳。假设在 $N$ 个核心中均匀随机地选择一个给定缓存行的两个不同共享者，并且该缓存行从一个迁移到另一个。仅使用这些拓扑结构的核心定义和第一性原理计数论证，计算每种拓扑结构下此迁移的平均跳数：网格、环和总线。按网格、环、总线的顺序报告你的三个答案。将每个值四舍五入到四位有效数字。不需要物理单位；报告无量纲的跳数。", "solution": "问题要求计算在一个包含 $N=64$ 个核心的系统中，对于三种不同的互连拓扑结构：一个 $8 \\times 8$ 的二维网格、一个 $64$ 节点的双向环和一个共享总线，缓存行在两个不同的、随机选择的核心之间迁移的平均跳数。\n\n平均跳数 $\\bar{H}$ 定义为所有不同源-目的对之间的最短路径跳数之和，除以此类对的总数。由于两个不同的核心是均匀随机选择的，源核心有 $N$ 种选择，目的核心有 $N-1$ 种选择。不同核心的有序对总数为 $N(N-1)$。\n\n平均跳数的一般公式为：\n$$ \\bar{H} = \\frac{\\sum_{i=1}^{N} \\sum_{j=1, j \\neq i}^{N} H(i, j)}{N(N-1)} $$\n其中 $H(i, j)$ 是从源核心 $i$ 到目的核心 $j$ 的跳数。\n\n我们现在将分别分析每种拓扑结构。\n\n### 1. 共享总线拓扑\n对于共享总线，问题陈述指明任何两个连接点之间的传输构成一次单跳。因此，对于任何不同的源核心 $i$ 和目的核心 $j$，跳数是恒定的。\n$$ H_{bus}(i, j) = 1 \\quad \\forall i \\neq j $$\n所有不同对的跳数总和为：\n$$ \\sum_{i=1}^{N} \\sum_{j=1, j \\neq i}^{N} H_{bus}(i, j) = \\sum_{i=1}^{N} \\sum_{j=1, j \\neq i}^{N} 1 = N(N-1) $$\n因此，平均跳数为：\n$$ \\bar{H}_{bus} = \\frac{N(N-1)}{N(N-1)} = 1 $$\n对于 $N=64$，总线的平均跳数恰好为 $1$。\n\n### 2. 双向环拓扑\n在具有 $N$ 个核心的双向环中，我们可以将核心从 $0$ 标记到 $N-1$。核心 $i$ 和核心 $j$ 之间的跳数是沿环路较短路径的长度。一个方向的距离是 $|i-j|$，另一个方向的距离是 $N - |i-j|$。因此，跳数为：\n$$ H_{ring}(i, j) = \\min(|i-j|, N - |i-j|) $$\n由于环形拓扑的对称性，从任何给定核心到所有其他核心的距离之和是相同的。因此，我们可以计算单个源（比如核心 $0$）的这个和，然后乘以 $N$ 得到所有源核心的总和。\n从核心 $0$ 到所有其他核心 $j \\in \\{1, 2, \\dots, N-1\\}$ 的距离之和为：\n$$ S_0 = \\sum_{j=1}^{N-1} H_{ring}(0, j) = \\sum_{j=1}^{N-1} \\min(j, N-j) $$\n给定 $N=64$，这是一个偶数，最大最短路径距离为 $N/2 = 32$。这个距离对于直径上相对的节点是唯一的。对于所有其他距离 $d  N/2$，有两个节点处于该距离。\n这个和可以写成：\n$$ S_0 = \\sum_{j=1}^{N/2 - 1} j + \\frac{N}{2} + \\sum_{j=N/2 + 1}^{N-1} (N-j) $$\n第二个求和可以重新索引。令 $k = N-j$。当 $j=N/2+1$ 时，$k=N/2-1$。当 $j=N-1$ 时，$k=1$。所以，$\\sum_{j=N/2 + 1}^{N-1} (N-j) = \\sum_{k=1}^{N/2-1} k$。\n$$ S_0 = 2 \\sum_{j=1}^{N/2 - 1} j + \\frac{N}{2} $$\n使用前 $m$ 个整数的和的公式 $\\sum_{j=1}^{m} j = \\frac{m(m+1)}{2}$：\n$$ S_0 = 2 \\left( \\frac{(\\frac{N}{2}-1)(\\frac{N}{2}-1+1)}{2} \\right) + \\frac{N}{2} = (\\frac{N}{2}-1)\\frac{N}{2} + \\frac{N}{2} = \\frac{N}{2}(\\frac{N}{2}-1+1) = \\left(\\frac{N}{2}\\right)^2 = \\frac{N^2}{4} $$\n所有不同对的总跳数为 $N \\times S_0 = N \\cdot \\frac{N^2}{4} = \\frac{N^3}{4}$。\n平均跳数是这个总和除以对的数量 $N(N-1)$：\n$$ \\bar{H}_{ring} = \\frac{N^3/4}{N(N-1)} = \\frac{N^2}{4(N-1)} $$\n对于 $N=64$：\n$$ \\bar{H}_{ring} = \\frac{64^2}{4(64-1)} = \\frac{4096}{4 \\times 63} = \\frac{1024}{63} \\approx 16.253968... $$\n\n### 3. 二维网格拓扑\n系统有 $N=64$ 个核心，排列在一个规整的 $K \\times K$ 网格中，其中 $K = \\sqrt{N} = \\sqrt{64} = 8$。一个核心的位置可以通过坐标 $(x, y)$ 来识别，其中 $x, y \\in \\{0, 1, \\dots, K-1\\}$。\n问题指明了曼哈顿路由，所以位于 $(x_s, y_s)$ 的源核心和位于 $(x_d, y_d)$ 的目的核心之间的跳数为：\n$$ H_{mesh}((x_s, y_s), (x_d, y_d)) = |x_s - x_d| + |y_s - y_d| $$\n平均跳数是这个量在所有不同源-目的对上的期望值。根据期望的线性性，这等于：\n$$ \\bar{H}_{mesh} = E[|x_s - x_d| + |y_s - y_d|] = E[|x_s - x_d|] + E[|y_s - y_d|] $$\n$x$ 维度上的平均位移 $E[|x_s - x_d|]$ 是 $x$ 位移的总和除以不同对的总数 $N(N-1)$。\n$$ E[|x_s - x_d|] = \\frac{\\sum_{s \\neq d} |x_s - x_d|}{N(N-1)} $$\n这个和是针对所有 $N(N-1)$ 个不同核心的对。我们可以计算所有 $N^2$ 个对（包括核心到自身的对）的总和，并注意到对于自身对（$s=d$），位移 $|x_s - x_s|$ 为 $0$。因此，不同对上的和与所有对上的和相同。\n$$ \\sum_{s \\neq d} |x_s - x_d| = \\sum_{s=1}^{N} \\sum_{d=1}^{N} |x_s - x_d| = \\sum_{y_s=0}^{K-1} \\sum_{x_s=0}^{K-1} \\sum_{y_d=0}^{K-1} \\sum_{x_d=0}^{K-1} |x_s - x_d| $$\n我们可以重新排列求和：\n$$ \\sum_{y_s=0}^{K-1} \\sum_{y_d=0}^{K-1} \\left( \\sum_{x_s=0}^{K-1} \\sum_{x_d=0}^{K-1} |x_s - x_d| \\right) $$\n外面关于 $y_s$ 和 $y_d$ 的两个求和产生一个 $K^2$ 的因子。内部的双重求和是一条线上 $K$ 个节点的总一维距离和。对于包括自身对在内的所有对，这个和是 $\\frac{K(K^2-1)}{3}$。\n因此，$x$ 位移的总和是 $K^2 \\times \\frac{K(K^2-1)}{3} = \\frac{K^3(K^2-1)}{3}$。\n平均 $x$ 位移是：\n$$ E[|x_s - x_d|] = \\frac{K^3(K^2-1)/3}{N(N-1)} = \\frac{K^3(K^2-1)/3}{K^2(K^2-1)} = \\frac{K}{3} $$\n根据对称性，平均 $y$ 位移 $E[|y_s - y_d|]$ 也是 $\\frac{K}{3}$。\n网格的平均总跳数为：\n$$ \\bar{H}_{mesh} = \\frac{K}{3} + \\frac{K}{3} = \\frac{2K}{3} $$\n对于 $K=8$：\n$$ \\bar{H}_{mesh} = \\frac{2 \\times 8}{3} = \\frac{16}{3} = 5.333333... $$\n\n### 结果总结\n计算出的平均跳数为：\n- 网格：$\\bar{H}_{mesh} = \\frac{16}{3} \\approx 5.3333...$\n- 环：$\\bar{H}_{ring} = \\frac{1024}{63} \\approx 16.2539...$\n- 总线：$\\bar{H}_{bus} = 1$\n\n根据要求，将每个值四舍五入到四位有效数字：\n- 网格：$5.333$\n- 环：$16.25$\n- 总线：$1.000$\n\n问题要求按网格、环、总线的顺序给出答案。", "answer": "$$\n\\boxed{\\begin{pmatrix} 5.333  16.25  1.000 \\end{pmatrix}}\n$$", "id": "3652325"}, {"introduction": "在分析了简单拓扑的基本属性后，我们转向更复杂的多级互连网络（multi-stage interconnection networks）。这项练习 [@problem_id:3652356] 探讨了Banyan网络中的一个关键问题——内部阻塞（internal blocking）。理解阻塞现象至关重要，因为它即使在网络链路未完全饱和时也可能严重降低性能，同时本练习还将介绍如何通过排序网络来构建无阻塞交换结构，这是一个经典的体系结构设计模式。", "problem": "考虑一个由 $2 \\times 2$ 交换单元构建的 $N \\times N$ Banyan 网络，其中 $N = 2^{k}$，$k$ 为某个整数且 $k \\ge 1$。该网络有 $k$ 级，每级包含 $N/2$ 个相同的 $2 \\times 2$ 交换机。级间互连是完美混洗（perfect shuffle），且网络是自路由的：在第 $s$ 级（$s \\in \\{1,\\dots,k\\}$），每个数据包根据其目的地址的第 $s$ 个最高有效位来选择其当前 $2 \\times 2$ 交换机的上输出或下输出。每个 $2 \\times 2$ 交换机都是无缓冲的，并且在每个时间槽内每个输出链路最多转发一个数据包；如果两个输入都请求相同的输出，则只有一个数据包能前进，另一个在该时隙内不能被转发。\n\n假设在离散时间槽内同步操作，并且一个时隙内是置换流量，意味着每个输入注入一个数据包，且 $N$ 个目的地都是不同的（一对一映射）。您可以使用以下基本依据：\n- Banyan 网络的结构定义及其在通过目的地址位进行自路由下的唯一路径。\n- 均匀随机置换下的基本概率计数。\n- 链路容量限制：每个有向链路在每个时间槽内最多一个数据包。\n\n下列哪个陈述是正确的？选择所有适用项。\n\nA. 对于每个时隙独立抽取的均匀随机置换，并且对于大的 $N$，跨级的独立性近似得出，在一个 $k$ 级无缓冲 Banyan 网络中，一次通过便成功到达其目的地的输入的期望分数近似为 $(3/4)^{k}$。\n\nB. 对于 $N = 8$ 和补码置换 $d(i) = 7 - i$（对于输入 $i \\in \\{0,1,\\dots,7\\}$），每个第一级 $2 \\times 2$ 交换单元都面临两个输入请求相同输出的情况，因此在没有任何内部缓冲的单个时隙内，最多有 $4$ 个数据包可以到达任何输出。\n\nC. 在 Banyan 网络前加一个按目的地址对数据包进行排序的 Batcher 排序网络，可以消除单个时隙内置换流量的内部阻塞，因此组合的排序器加 Banyan 网络可以为任何置换在每个时隙内递送 $N$ 个数据包。\n\nD. 对于 $N = 2^{k}$ 输入上的任何置换，根据最高有效目的地址位将数据包划分为两个不相交的集合（在该位为 $0$ 的在时隙 $1$ 发送，为 $1$ 的在时隙 $2$ 发送）总是足以在没有任何附加硬件的普通 Banyan 网络上通过两个时隙实现完整的置换。\n\n请给出你的选择。", "solution": "用户要求对问题陈述进行严格验证，然后提供详细的解决方案和对所给选项的评估。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n-   网络类型: $N \\times N$ Banyan 网络。\n-   交换单元 (SEs): $2 \\times 2$。\n-   网络规模: $N = 2^{k}$，其中 $k \\ge 1$ 为整数。\n-   网络结构: $k$ 级，每级包含 $N/2$ 个相同的 $2 \\times 2$ 交换机。\n-   级间互连: 完美混洗。\n-   路由算法: 自路由。在第 $s$ 级 ($s \\in \\{1,\\dots,k\\}$)，根据目的地址的第 $s$ 个最高有效位选择输出。\n-   交换机行为: 无缓冲。每个时间槽内每个输出链路最多一个数据包。如果两个输入都请求相同的输出，一个数据包被转发，另一个在该时隙内被阻塞。\n-   操作条件: 同步，离散时间槽。\n-   流量模型: 置换流量，即 $N$ 个输入各注入一个数据包，且 $N$ 个目的地各不相同。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学依据：** 该问题描述了一个典型的 Banyan 网络，这是计算机体系结构和并行处理领域一个被充分研究的课题。自路由、完美混洗互连、阻塞和置换流量等概念在此背景下都有标准且严谨的定义。该问题在科学上是合理的。\n-   **定义明确：** 网络结构、路由机制和冲突解决规则都得到了清晰的说明。选项中提出的问题是具体的，可以使用网络理论和组合数学的既定原则进行分析。\n-   **客观性：** 问题陈述使用精确、技术性的语言表达，没有歧义或主观性。\n-   **完整性和一致性：** 所提供的信息足以分析网络在指定条件下的行为。不存在矛盾之处。\n-   **其他缺陷：** 该问题在其理论建模的背景下并非不切实际、定义不善、微不足道或无法验证。\n\n**步骤 3：结论和行动**\n问题陈述是有效的。将推导完整的解决方案。\n\n### 解决方案推导与选项分析\n\n该问题要求评估关于一个无缓冲 $N \\times N$ Banyan 网络行为的四个陈述。\n\n**A. 对于每个时隙独立抽取的均匀随机置换，并且对于大的 $N$，跨级的独立性近似得出，在一个 $k$ 级无缓冲 Banyan 网络中，一次通过便成功到达其目的地的输入的期望分数近似为 $(3/4)^{k}$。**\n\n这个陈述描述了对网络吞吐量的简化概率分析。我们来分析单个 $2 \\times 2$ 交换机内部的冲突概率。\n假设一个交换机接收到两个数据包。对于随机置换和大的 $N$，这两个数据包的目的地址近似独立且均匀分布。第 $s$ 级的路由取决于目的地址的第 $s$ 个最高有效位。设这两个数据包的该位分别为 $b_1$ 和 $b_2$。\n每个位为 $0$ 或 $1$ 的概率是 $1/2$。\n-   如果 $b_1 = b_2$，则发生冲突。概率为 $P(b_1=0, b_2=0) + P(b_1=1, b_2=1) = (1/2)(1/2) + (1/2)(1/2) = 1/2$。在这种情况下，一个数据包通过，一个被阻塞。\n-   如果 $b_1 \\neq b_2$，则不发生冲突。概率为 $1/2$。在这种情况下，两个数据包都通过。\n\n通过一个接收两个数据包的交换机的期望数据包数量是 $1 \\times P(\\text{冲突}) + 2 \\times P(\\text{无冲突}) = 1 \\times (1/2) + 2 \\times (1/2) = 3/2$。\n由于有两个数据包进入，一个*特定*数据包通过的概率（假定有两个数据包到达其交换机）是 $(3/2)/2 = 3/4$。\n\n陈述中提到的“独立性近似”意味着一个简化的模型，其中一个数据包通过任何给定级的概率与其历史和其他级的行为无关。\n-   在第 1 级，每个输入都是活跃的，所以每个交换机都接收到两个数据包。通过第 1 级的数据包比例恰好是 $3/4$。\n-   该近似假设对于任何后续的级 $s$，数据包成功穿过它的概率也是 $3/4$。这实际上假设了每个进入第 $s$ 级的数据包都会在其交换机上遇到一个竞争者，这并不完全正确，因为一些数据包已经被阻塞了。更精确的分析表明，第 $s$ 级的吞吐量是 $p_s = p_{s-1} - p_{s-1}^2/4$，其中 $p_{s-1}$ 是前一级的吞吐量。对于 $s1$，$p_{s-1}  1$，所以通过第 $s$ 级的条件概率，即 $1-p_{s-1}/4$，实际上大于 $3/4$。\n然而，该陈述描述的是一个*特定的、已命名的近似方法*的结果。在这种简化模型下——将每级通过的概率独立地近似为 $3/4$——一个数据包通过所有 $k$ 级的总概率是各级概率的乘积，即 $(3/4) \\times (3/4) \\times \\dots \\times (3/4) = (3/4)^k$。该陈述是对从这个特定近似中获得的结果的正确描述。\n\n因此，陈述 A 是**正确的**。\n\n**B. 对于 $N = 8$ 和补码置换 $d(i) = 7 - i$（对于输入 $i \\in \\{0,1,\\dots,7\\}$），每个第一级 $2 \\times 2$ 交换单元都面临两个输入请求相同输出的情况，因此在没有任何内部缓冲的单个时隙内，最多有 $4$ 个数据包可以到达任何输出。**\n\n我们来分析这个具体案例。$N=8$，所以 $k=\\log_2 8 = 3$。网络在第一级有 $N/2 = 4$ 个交换机。一个标准的 Banyan 网络假设交换机 $j$ 接收输入 $2j$ 和 $2j+1$。第 1 级的路由基于目的地址的最高有效位 (MSB)。我们约定 MSB=$0$ 选择上输出，MSB=$1$ 选择下输出。\n\n我们将每个输入 $i$ 映射到其目的地 $d(i)=7-i$，并找出 $d(i)$ 的 MSB。\n-   输入 $i=0$: $d(0)=7=(111)_2$。MSB 是 $1$。\n-   输入 $i=1$: $d(1)=6=(110)_2$。MSB 是 $1$。\n-   输入 $i=2$: $d(2)=5=(101)_2$。MSB 是 $1$。\n-   输入 $i=3$: $d(3)=4=(100)_2$。MSB 是 $1$。\n-   输入 $i=4$: $d(4)=3=(011)_2$。MSB 是 $0$。\n-   输入 $i=5$: $d(5)=2=(010)_2$。MSB 是 $0$。\n-   输入 $i=6$: $d(6)=1=(001)_2$。MSB 是 $0$。\n-   输入 $i=7$: $d(7)=0=(000)_2$。MSB 是 $0$。\n\n现在，我们检查第一级交换机的冲突情况：\n-   交换机 0 (输入 $0, 1$): 来自输入 $0$ 的数据包目的地 MSB=$1$。来自输入 $1$ 的数据包目的地 MSB=$1$。两者都请求相同的输出。**冲突**。\n-   交换机 1 (输入 $2, 3$): 来自输入 $2$ 的数据包目的地 MSB=$1$。来自输入 $3$ 的数据包目的地 MSB=$1$。两者都请求相同的输出。**冲突**。\n-   交换机 2 (输入 $4, 5$): 来自输入 $4$ 的数据包目的地 MSB=$0$。来自输入 $5$ 的数据包目的地 MSB=$0$。两者都请求相同的输出。**冲突**。\n-   交换机 3 (输入 $6, 7$): 来自输入 $6$ 的数据包目的地 MSB=$0$。来自输入 $7$ 的数据包目的地 MSB=$0$。两者都请求相同的输出。**冲突**。\n\n陈述的第一部分，“每个第一级 $2 \\times 2$ 交换单元都面临两个输入请求相同输出的情况”，是正确的。\n由于这些冲突，4 个交换机中的每一个都只能转发其两个输入数据包中的一个。另一个被阻塞。因此，总共有 4 个数据包通过第 1 级，4 个数据包被阻塞。\n由于只有 4 个数据包从第 1 级出来，无论后续各级发生什么，最多也只有 4 个数据包可能到达最终的网络输出。结论“最多有 $4$ 个数据包可以到达任何输出”是正确的。\n\n因此，陈述 B 是**正确的**。\n\n**C. 在 Banyan 网络前加一个按目的地址对数据包进行排序的 Batcher 排序网络，可以消除单个时隙内置换流量的内部阻塞，因此组合的排序器加 Banyan 网络可以为任何置换在每个时隙内递送 $N$ 个数据包。**\n\n这描述了经典的 Batcher-Banyan 无阻塞交换结构。\nBanyan 网络是一个阻塞网络；如选项 B 所示，某些置换会导致内部冲突。\nBatcher 排序网络是一个无阻塞网络，能够根据一个键对其 $N$ 个输入进行排序。在此背景下，键是数据包的目的地址。\nBatcher 网络从任意源端口接收数据包，并将它们排列在其输出端，使得目的地址最小的数据包出现在输出 $0$，次小的出现在输出 $1$，依此类推。\n这个排好序的数据包流然后被送入 Banyan 网络。互连网络理论中的一个基本定理是，Banyan 网络（及其同构变体，如 Omega 网络）对于任何其目的地址相对于其输入端口地址是单调排序的置换都是无阻塞的。Batcher 网络恰好强制执行了这一条件。\n因为进入 Banyan 网络的输入是按目的地排序的，所以在 Banyan 内部的任何 $2 \\times 2$ 交换机中，都不会有两个数据包争用一个输出链路。因此，整个 Batcher-Banyan 组件可以无内部阻塞地路由任何置换。\n声称这个组合网络“可以为任何置换在每个时隙内递送 $N$ 个数据包”是这种无阻塞特性的直接结果。此处的“时隙”指的是一组数据包通过整个网络所需的时间。\n\n因此，陈述 C 是**正确的**。\n\n**D. 对于 $N = 2^{k}$ 输入上的任何置换，根据最高有效目的地址位将数据包划分为两个不相交的集合（在该位为 $0$ 的在时隙 $1$ 发送，为 $1$ 的在时隙 $2$ 发送）总是足以在没有任何附加硬件的普通 Banyan 网络上通过两个时隙实现完整的置换。**\n\n这个陈述提出了一种两遍路由方案以避免冲突。我们来测试这个提议。\n-   在时隙 1，所有目的地址 MSB=$0$ 的数据包被发送。\n-   在时隙 2，所有目的地址 MSB=$1$ 的数据包被发送。\n\n该方案旨在通过在时间上分离它们来防止在第 1 级中想要上输出（MSB=$0$）的数据包和想要下输出（MSB=$1$）的数据包之间的冲突。然而，它并不能防止*都*想要上输出或*都*想要下输出的数据包之间的冲突。\n如果在时隙 1 中，两个目的地址 MSB都为 $0$ 的数据包被路由到同一个第一级交换机，就会发生冲突。\n考虑一个 $N=4$ 网络（$k=2$）上的恒等置换 $d(i)=i$。\n-   目的地：$d(0)=0=(00)_2$, $d(1)=1=(01)_2$, $d(2)=2=(10)_2$, $d(3)=3=(11)_2$。\n-   目的地址 MSB=$0$ 的数据包：来自源 $0$（到目的地 $0$）和源 $1$（到目的地 $1$）。\n-   目的地址 MSB=$1$ 的数据包：来自源 $2$（到目的地 $2$）和源 $3$（到目的地 $3$）。\n\n根据该方案，在时隙 1，发送来自源 $0$ 和 $1$ 的数据包。\n-   输入 $0$ 和 $1$ 进入第一级交换机 0。\n-   来自源 $0$ 的数据包的目的地是 $0$，MSB=$0$。它想要上输出。\n-   来自源 $1$ 的数据包的目的地是 $1$，MSB=$0$。它想要上输出。\n两个数据包到达同一个交换机并请求相同的输出。这导致了冲突，其中一个数据包将被阻塞。\n对于这个简单案例，该方案未能在两个时隙内实现置换。由于该陈述声称它对*任何*置换都有效，这一个反例就足以使其无效。\n\n因此，陈述 D 是**不正确的**。", "answer": "$$\\boxed{ABC}$$", "id": "3652356"}, {"introduction": "互连网络并非孤立存在，而是整个计算机系统中的关键一环。最后的这项练习 [@problem_id:3652369] 将探讨互连网络的设计如何对一个根本性的系统级挑战——缓存一致性（cache coherence）——产生深远影响。通过对比提供全局总顺序（total order）的总线和仅提供部分顺序（partial order）的片上网络（NoC），我们可以理解为何互连网络的选择直接决定了内存一致性协议的复杂性和设计。", "problem": "一个共享内存多处理器有四个核心 $C_0$、$C_1$、$C_2$ 和 $C_3$，并为单个缓存行 $X$ 实现缓存一致性。考虑两种互连设计：\n\n- 设计 B：一个带有中心化仲裁器的单一共享总线。一致性协议使用监听（snooping）和原子总线请求；总线仲裁器一次只批准一个请求者，所有缓存观察到相同的一致性事务序列。\n- 设计 N：一个片上网络（NoC），具体来说是一个 $2$-D 网格，采用维度顺序路由和每链路先进先出（FIFO）队列。网络接口独立地注入数据包，互连不强制所有数据包遵循单一的全局顺序。一致性协议在 $X$ 的主节点（home node）使用一个目录；无效化和数据响应是独立的报文。\n\n请求的时间线如下：在时间 $t_1$，核心 $C_1$ 对 $X$ 发出写操作；在时间 $t_2$，核心 $C_2$ 对 $X$ 发出写操作；在时间 $t_3$，核心 $C_3$ 对 $X$ 发出读操作，其中 $t_1  t_2  t_3$。假设写请求使用写-无效策略，并且在更新 $X$ 之前必须获得独占所有权，并且 $C_0$ 最初持有一个干净的共享副本，主存的值与 $C_0$ 的值相同。\n\n运用排序和一致性的基本定义，分析互连引起的排序如何影响可以观察到的值，以及需要什么样的协议机制来维护单写者、多读者不变量。选择所有正确的陈述。\n\nA. 在设计 B（总线）上，一致性请求的组合序列形成一个被所有缓存观察到的单一全序；监听协议可以依赖这种串行化来维护单写者、多读者不变量，而无需为每个请求设置序列号。\n\nB. 在设计 N（片上网络）上，每链路 FIFO 队列保证了整个网络中所有数据包的全局全序，因此可以不加改变地使用类似总线的监听协议。\n\nC. 在设计 N（片上网络）上，为了在潜在的消息重排下维护一致性，协议必须要么通过诸如主节点的目录、确认和瞬态等机制来强制实施每个地址的排序，要么引入额外的虚拟通道或每个源的序列号来防止与重排相关的竞争。\n\nD. 在设计 B（总线）上，如果 $C_1$ 和 $C_2$ 几乎同时对 $X$ 发出写请求，总线仲裁器的授权顺序定义了它们的串行化；如果 $C_3$ 的读请求在两次写请求的授权都发生之后才在总线上发出，那么它的读操作将观察到两次写操作中较晚一次写入的值，这与到仲裁器的物理距离无关。\n\nE. 在设计 N（片上网络）中，维度顺序路由确保所有缓存观察到相同地址的请求顺序相同，因此与总线相比，协议复杂性降低了。\n\n选择所有适用的选项。", "solution": "从计算机组成和体系结构中的核心定义和广泛接受的事实开始：\n\n- 缓存一致性协议必须强制执行单写者、多读者不变量：在任何逻辑时间点，要么一个核心持有某个缓存行的独占可写副本，要么多个核心持有共享的只读副本，并且写操作必须被串行化，以便读者看到一个一致的值。这要求对给定行的操作允许一种与每个核心的程序顺序一致的串行化。\n- 带有仲裁的共享总线充当单一的串行化点：总线请求一次只被批准一个，所有观察者看到相同的总线事务全序。监听协议利用这一特性，通过简单的状态转换来实现一致性，因为所有缓存可以就所有权变更、无效化和数据更新发生的顺序达成一致。\n- 带有包交换、每链路FIFO队列和维度顺序路由的片上网络（NoC），通常不为源自不同源头并沿着不同路径传播的所有数据包提供单一的全局全序。即使每个链路都保持了通过该链路的数据包的顺序，路径长度、争用和独立注入的差异也可能导致不同的观察者看到对给定地址的请求以不同的顺序到达，除非强制执行额外的排序机制。\n\n将这些应用于该场景：\n\n对于设计 B（总线），假设 $C_1$ 在时间 $t_1$ 请求独占所有权，$C_2$ 在时间 $t_2$ 请求，且 $t_1  t_2$。总线仲裁器一次选择一个请求者；授权顺序为所有缓存定义了一个全序。如果 $C_1$ 首先获得授权，它会广播无效化消息，通过监听或总线语义隐式地接收确认，然后将新值写入 $X$。当 $C_2$ 随后请求所有权时，它被串行化在 $C_1$ 之后，其写操作将在 $C_1$ 的写操作之后发生。如果 $C_3$ 在时间 $t_3$ 发出读请求，并且总线在两次写操作都获得授权并完成后处理该请求，那么该读操作被排序在较晚的写操作之后，因此观察到较晚的值。到仲裁器的物理线路延迟不会改变逻辑上的总线串行化：总线定义了一个单一的、全局观察到的顺序。\n\n对于设计 N（片上网络），用于请求、无效化、确认和数据响应的数据包会经过不同的路径。每链路 FIFO 排序仅保留同一链路上数据包的顺序；它不会在所有链路和源之间创建一个全局全序。考虑 $C_1$ 和 $C_2$ 向 $X$ 的目录主节点发送请求。如果 $C_1$ 的请求经过 3 跳，而 $C_2$ 的请求经过 1 跳，那么即使 $t_1  t_2$，$C_2$ 的请求也可能先到达目录。同样，对共享者的无效化和对请求者的数据响应可能会在不同时间、以不同的相对顺序到达每个核心，因为它们经历了不同的网络拥塞。如果没有额外的协议机制，一个假设单一串行化点的监听协议可能会失败：$C_3$ 的读操作可能在无效化完成之前由内存来服务，或者两个写者可能暂时都认为自己拥有权限。为防止此类竞争，使用了带有显式确认的基于目录的一致性协议，以确保写者在完成前获得独占所有权，并且读者只有在无效化完成后才被服务。瞬态用于跟踪进行中的请求和确认。设计者也可能使用虚拟通道来分离请求、响应和确认流量，并使用每个源的序列号来防止对于给定地址必须按顺序处理的消息发生重排，从而相对于总线监听设计增加了协议的复杂性。\n\n逐项分析：\n\n- A. 这个陈述与总线作为全局串行化点是一致的。所有缓存观察到相同的总线事务全序；监听协议利用了这一点，并且不需要每个请求的序列号，因为总线定义了顺序。结论：正确。\n\n- B. 每链路FIFO仅保证在任何给定链路上数据包不会被重排；它没有在整个网络上施加单一的全局全序。不同的路径和源导致不同的到达顺序。因此，在没有额外排序或目录机制的情况下，类似总线的监听协议不能在通用的NoC上不加改变地使用。结论：不正确。\n\n- C. 这正确地指出了在NoC情况下需要额外的排序和跟踪机制。目录控制器对每个地址的请求进行串行化，确认确保无效化完成，瞬态跟踪进行中的操作，而虚拟通道或每个源的序列号被用来防止死锁和对重排敏感的竞争。结论：正确。\n\n- D. 在总线上，仲裁定义了串行化，而不管物理距离如何。如果 $C_3$ 的读请求在总线上的排序位于两次写授权都完成之后，该读操作将观察到较晚写操作的值，这与单写者、多读者不变量和总线串行化一致。结论：正确。\n\n- E. 维度顺序路由限制了数据包所走的路径，但不能确保所有缓存都观察到相同地址的请求的相同顺序，特别是当数据包源自不同源头并经过不同跳数时。与总线相比，协议复杂性没有降低；它通常会增加以处理重排和分布式串行化。结论：不正确。\n\n因此，正确的选项是 A、C 和 D。", "answer": "$$\\boxed{ACD}$$", "id": "3652369"}]}