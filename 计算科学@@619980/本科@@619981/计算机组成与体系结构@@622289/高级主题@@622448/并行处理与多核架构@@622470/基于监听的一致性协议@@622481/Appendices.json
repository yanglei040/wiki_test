{"hands_on_practices": [{"introduction": "要真正掌握监听协议，最好的方法就是亲自动手追踪其状态变化。本练习将引导你在一系列内存操作下，手动模拟一个缓存块在写失效和写更新这两种基本协议中的状态演变。通过计算关键的状态转换和总线事件数量，你将对这两种协议的独特行为和产生的通信量有更具体的认识。", "problem": "考虑一个基于窥探的多处理器，其包含三个核心 $C_0$、$C_1$ 和 $C_2$，以及一个单一的缓存块 $X$。对于缓存块 $X$，所有缓存最初都处于无效状态 $I$。假设采用写回式缓存层次结构和单一共享总线。该系统通过窥探来维护缓存一致性，可以采用写无效协议或写更新协议。对于每种协议，请使用以下关于缓存一致性、总线事务和状态变化的基础行为定义和经过充分测试的规则：\n\n- 缓存状态含义（写无效）：修改（$M$）、独占（$E$）、共享（$S$）、无效（$I$），如同修改-独占-共享-无效（MESI）协议中一样。未命中的加载操作会发出 $\\mathrm{BusRd}$；需要独占权的存储操作会发出 $\\mathrm{BusRdX}$ 或 $\\mathrm{BusUpgr}$；本地存储导致的 $\\mathrm{E}$ 到 $\\mathrm{M}$ 的转换是静默的（无总线活动）。一个处于 $\\mathrm{E}$ 状态的持有者看到 $\\mathrm{BusRd}$ 会导致 $\\mathrm{E}\\to\\mathrm{S}$；一个处于 $\\mathrm{M}$ 状态的持有者看到 $\\mathrm{BusRd}$ 会导致数据供应和 $\\mathrm{M}\\to\\mathrm{S}$。从 $\\mathrm{S}$ 状态的写入会导致其他共享者的副本失效（它们的 $\\mathrm{S}\\to\\mathrm{I}$），并且写入者从 $\\mathrm{S}\\to\\mathrm{M}$。从 $\\mathrm{I}$ 状态的写入会发出 $\\mathrm{BusRdX}$，获得 $\\mathrm{M}$ 状态，并使其他副本失效（如果有的话，$\\mathrm{S}\\to\\mathrm{I}$）。在写无效协议中没有总线更新事件。\n\n- 缓存状态含义（写更新）：使用类 Dragon 协议的状态，即独占洁净（$E$）、共享洁净（$Sc$）、共享修改（$Sm$）和修改（$M$）。未命中的加载操作会发出 $\\mathrm{BusRd}$；如果没有其他缓存持有 $X$，请求者获得 $E$ 状态。如果另一个缓存以任何非无效状态持有 $X$，请求者获得 $Sc$ 状态，并且前一个所有者根据以下规则进行转换：$E\\to Sc$，$M\\to Sm$，$Sm$ 保持 $Sm$。从 $E$ 状态的写入会静默地转换到 $M$ 状态（无总线活动）；从 $Sc$ 状态的写入会转换到 $Sm$ 状态并向所有共享者广播总线更新 $\\mathrm{BusUpd}$；从 $Sm$ 状态的写入保持 $Sm$ 状态并广播 $\\mathrm{BusUpd}$。在广播 $\\mathrm{BusUpd}$ 的写入操作中，写入者成为 $Sm$ 状态的所有者，而任何之前处于 $Sm$ 状态的所有者则转换到 $Sc$ 状态。在写更新协议中没有无效操作。\n\n对于两种协议，定义在整个执行过程中针对缓存块 $X$ 在所有缓存中的事件计数器如下：计算 $\\mathrm{S}\\to\\mathrm{I}$ 转换、$\\mathrm{I}\\to\\mathrm{S}$ 转换、$\\mathrm{S}\\to\\mathrm{M}$ 转换以及总线更新事件 $\\mathrm{BusUpd}$ 的总数。仅当缓存对 $X$ 的状态确实发生此类变化时才计数；不要计算 $E\\to M$、$M\\to S$、$E\\to S$ 或任何其他未列出的转换。每当写更新协议因对共享块的存储而广播更新时，就计为一个总线更新事件 $\\mathrm{BusUpd}$。在写无效协议下，不会发生 $\\mathrm{BusUpd}$ 事件。\n\n执行以下针对缓存块 $X$ 的综合内存操作序列：\n- 步骤 1：$C_0$ 执行 $\\mathrm{Load}\\, X$。\n- 步骤 2：$C_1$ 执行 $\\mathrm{Load}\\, X$。\n- 步骤 3：$C_0$ 执行 $\\mathrm{Store}\\, X$。\n- 步骤 4：$C_2$ 执行 $\\mathrm{Load}\\, X$。\n- 步骤 5：$C_1$ 执行 $\\mathrm{Store}\\, X$。\n- 步骤 6：$C_0$ 执行 $\\mathrm{Load}\\, X$。\n- 步骤 7：$C_2$ 执行 $\\mathrm{Store}\\, X$。\n- 步骤 8：$C_1$ 执行 $\\mathrm{Load}\\, X$。\n\n仅使用上述规则，计算在整个操作序列中，写无效协议和写更新协议的 $\\mathrm{S}\\to\\mathrm{I}$、$\\mathrm{I}\\to\\mathrm{S}$、$\\mathrm{S}\\to\\mathrm{M}$ 和 $\\mathrm{BusUpd}$ 事件的总数。将你的最终答案表示为单行矩阵\n$$\\begin{pmatrix}\n\\text{写无效 } \\mathrm{S}\\to\\mathrm{I}  \\text{写无效 } \\mathrm{I}\\to\\mathrm{S}  \\text{写无效 } \\mathrm{S}\\to\\mathrm{M}  \\text{写无效 } \\mathrm{BusUpd}  \\text{写更新 } \\mathrm{S}\\to\\mathrm{I}  \\text{写更新 } \\mathrm{I}\\to\\mathrm{S}  \\text{写更新 } \\mathrm{S}\\to\\mathrm{M}  \\text{写更新 } \\mathrm{BusUpd}\n\\end{pmatrix}.$$\n无需四舍五入。", "solution": "该问题被验证为具有科学依据、定义明确且客观。它为两种缓存一致性协议（一种类 MESI 的写无效协议和一种类 Dragon 的写更新协议）以及一个特定的内存操作序列提供了一套自洽的规则。任务是追踪三个核心（$C_0, C_1, C_2$）中缓存块 $X$ 的状态，并统计四种特定事件的发生次数：$\\mathrm{S}\\to\\mathrm{I}$ 转换、$\\mathrm{I}\\to\\mathrm{S}$ 转换、$\\mathrm{S}\\to\\mathrm{M}$ 转换和 $\\mathrm{BusUpd}$ 事件。\n\n解决方案将通过为每种协议细致地追踪给定的操作序列，跟踪缓存状态并根据所提供的规则递增事件计数器来得出。\n\n**第一部分：写无效（WI）协议分析**\n\n我们追踪缓存 $C_0$、$C_1$ 和 $C_2$ 中块 $X$ 的状态。状态包括修改（$M$）、独占（$E$）、共享（$S$）或无效（$I$）。所有缓存的初始状态为 $(I, I, I)$。事件计数器 $(\\mathrm{S}\\to\\mathrm{I}, \\mathrm{I}\\to\\mathrm{S}, \\mathrm{S}\\to\\mathrm{M}, \\mathrm{BusUpd})$ 从 $(0, 0, 0, 0)$ 开始。\n\n- **初始状态：** 缓存状态：$(C_0: I, C_1: I, C_2: I)$。计数器：$(0, 0, 0, 0)$。\n\n- **步骤 1：$C_0$ 执行 $\\mathrm{Load}\\, X$。**\n  - $C_0$ 未命中，发出 $\\mathrm{BusRd}$。没有其他缓存持有该块。内存提供数据。\n  - $C_0$ 从 $I$ 转换到 $E$。没有指定的计数器受到影响。\n  - 缓存状态：$(C_0: E, C_1: I, C_2: I)$。计数器：$(0, 0, 0, 0)$。\n\n- **步骤 2：$C_1$ 执行 $\\mathrm{Load}\\, X$。**\n  - $C_1$ 未命中，发出 $\\mathrm{BusRd}$。\n  - $C_0$ 窥探到 $\\mathrm{BusRd}$，其持有该块的状态为 $E$。$C_0$ 提供数据并从 $E \\to S$ 转换。\n  - $C_1$ 接收数据并从 $I \\to S$ 转换。\n  - **事件：** $C_1$ 发生一次 $\\mathrm{I}\\to\\mathrm{S}$ 转换。\n  - 缓存状态：$(C_0: S, C_1: S, C_2: I)$。计数器：$(0, 1, 0, 0)$。\n\n- **步骤 3：$C_0$ 执行 $\\mathrm{Store}\\, X$。**\n  - $C_0$ 持有该块的状态为 $S$。为了写入，它必须获得独占所有权。它发出一个总线事务（例如 $\\mathrm{BusUpgr}$ 或 $\\mathrm{BusRdX}$）来使其他共享者失效。\n  - $C_1$ 窥探到无效信号并从 $S \\to I$ 转换。\n  - $C_0$ 执行写入并从 $S \\to M$ 转换。\n  - **事件：** $C_1$：$\\mathrm{S}\\to\\mathrm{I}$；$C_0$：$\\mathrm{S}\\to\\mathrm{M}$。\n  - 缓存状态：$(C_0: M, C_1: I, C_2: I)$。计数器：$(1, 1, 1, 0)$。\n\n- **步骤 4：$C_2$ 执行 $\\mathrm{Load}\\, X$。**\n  - $C_2$ 未命中，发出 $\\mathrm{BusRd}$。\n  - $C_0$ 窥探到 $\\mathrm{BusRd}$，其持有状态为 $M$。$C_0$ 将该块写回内存，向 $C_2$ 提供数据，并从 $M \\to S$ 转换。\n  - $C_2$ 接收数据并从 $I \\to S$ 转换。\n  - **事件：** $C_2$：$\\mathrm{I}\\to\\mathrm{S}$。\n  - 缓存状态：$(C_0: S, C_1: I, C_2: S)$。计数器：$(1, 2, 1, 0)$。\n\n- **步骤 5：$C_1$ 执行 $\\mathrm{Store}\\, X$。**\n  - $C_1$ 未命中（状态为 $I$）。它发出 $\\mathrm{BusRdX}$ 以获取具有独占所有权的块。\n  - 该事务使所有其他副本失效。$C_0$ 和 $C_2$ 都窥探到 $\\mathrm{BusRdX}$ 并使其副本失效，从 $S \\to I$ 转换。\n  - $C_1$ 获得该块并转换到状态 $M$。这个 $I \\to M$ 转换不被计数。\n  - **事件：** $C_0$：$\\mathrm{S}\\to\\mathrm{I}$；$C_2$：$\\mathrm{S}\\to\\mathrm{I}$。\n  - 缓存状态：$(C_0: I, C_1: M, C_2: I)$。计数器：$(1+2=3, 2, 1, 0)$。\n\n- **步骤 6：$C_0$ 执行 $\\mathrm{Load}\\, X$。**\n  - $C_0$ 未命中，发出 $\\mathrm{BusRd}$。\n  - $C_1$ 窥探到 $\\mathrm{BusRd}$，其持有状态为 $M$。$C_1$ 写回数据，提供数据，并从 $M \\to S$ 转换。\n  - $C_0$ 接收数据并从 $I \\to S$ 转换。\n  - **事件：** $C_0$：$\\mathrm{I}\\to\\mathrm{S}$。\n  - 缓存状态：$(C_0: S, C_1: S, C_2: I)$。计数器：$(3, 3, 1, 0)$。\n\n- **步骤 7：$C_2$ 执行 $\\mathrm{Store}\\, X$。**\n  - $C_2$ 未命中（状态为 $I$）。它发出 $\\mathrm{BusRdX}$。\n  - $C_0$ 和 $C_1$ 窥探到 $\\mathrm{BusRdX}$ 并使其副本失效，从 $S \\to I$ 转换。\n  - $C_2$ 获得该块并转换到 $M$。\n  - **事件：** $C_0$：$\\mathrm{S}\\to\\mathrm{I}$；$C_1$：$\\mathrm{S}\\to\\mathrm{I}$。\n  - 缓存状态：$(C_0: I, C_1: I, C_2: M)$。计数器：$(3+2=5, 3, 1, 0)$。\n\n- **步骤 8：$C_1$ 执行 $\\mathrm{Load}\\, X$。**\n  - $C_1$ 未命中，发出 $\\mathrm{BusRd}$。\n  - $C_2$ 窥探到 $\\mathrm{BusRd}$，其持有状态为 $M$。$C_2$ 写回数据，提供数据，并从 $M \\to S$ 转换。\n  - $C_1$ 接收数据并从 $I \\to S$ 转换。\n  - **事件：** $C_1$：$\\mathrm{I}\\to\\mathrm{S}$。\n  - 缓存状态：$(C_0: I, C_1: S, C_2: S)$。计数器：$(5, 4, 1, 0)$。\n\n**写无效（WI）协议的最终计数：**\n- 总 $\\mathrm{S}\\to\\mathrm{I}$ 转换次数：$5$。\n- 总 $\\mathrm{I}\\to\\mathrm{S}$ 转换次数：$4$。\n- 总 $\\mathrm{S}\\to\\mathrm{M}$ 转换次数：$1$。\n- 总 $\\mathrm{BusUpd}$ 事件数：$0$。\n\n**第二部分：写更新（WU）协议分析**\n\n我们使用类 Dragon 协议的状态来追踪块 $X$ 的状态：独占洁净（$E$）、共享洁净（$Sc$）、共享修改（$Sm$）、修改（$M$）和无效（$I$）。初始状态为 $(I, I, I)$。事件计数器 $(\\mathrm{S}\\to\\mathrm{I}, \\mathrm{I}\\to\\mathrm{S}, \\mathrm{S}\\to\\mathrm{M}, \\mathrm{BusUpd})$ 从 $(0, 0, 0, 0)$ 开始。根据问题为此协议设定的规则：\n- 没有无效操作，因此 $\\mathrm{S}\\to\\mathrm{I}$ 的计数必须为 $0$。\n- 唯一转换到 $M$ 状态的路径是从 $E$ 状态。不存在 $Sc \\to M$ 或 $Sm \\to M$ 的转换。我们将计数器“S→M”中的“S”解释为 $Sc$ 或 $Sm$，因此 $\\mathrm{S}\\to\\mathrm{M}$ 的计数必须为 $0$。\n- $I \\to Sc$ 的转换被计为一次 $\\mathrm{I}\\to\\mathrm{S}$ 转换。\n\n- **初始状态：** 缓存状态：$(C_0: I, C_1: I, C_2: I)$。计数器：$(0, 0, 0, 0)$。\n\n- **步骤 1：$C_0$ 执行 $\\mathrm{Load}\\, X$。**\n  - $C_0$ 未命中，发出 $\\mathrm{BusRd}$。没有其他缓存持有该块。\n  - $C_0$ 从 $I \\to E$ 转换。没有指定的计数器受到影响。\n  - 缓存状态：$(C_0: E, C_1: I, C_2: I)$。计数器：$(0, 0, 0, 0)$。\n\n- **步骤 2：$C_1$ 执行 $\\mathrm{Load}\\, X$。**\n  - $C_1$ 未命中，发出 $\\mathrm{BusRd}$。\n  - $C_0$ 窥探到 $\\mathrm{BusRd}$（状态为 $E$），提供数据，并从 $E \\to Sc$ 转换。\n  - $C_1$ 接收数据并从 $I \\to Sc$ 转换。\n  - **事件：** $C_1$：$\\mathrm{I}\\to\\mathrm{S}$。\n  - 缓存状态：$(C_0: Sc, C_1: Sc, C_2: I)$。计数器：$(0, 1, 0, 0)$。\n\n- **步骤 3：$C_0$ 执行 $\\mathrm{Store}\\, X$。**\n  - $C_0$ 持有状态为 $Sc$。它从 $Sc \\to Sm$ 转换并广播一个 $\\mathrm{BusUpd}$。它现在是所有者。\n  - $C_1$ 窥探到 $\\mathrm{BusUpd}$，更新其数据，其状态保持为 $Sc$。\n  - **事件：** 发生一次 $\\mathrm{BusUpd}$。\n  - 缓存状态：$(C_0: Sm, C_1: Sc, C_2: I)$。计数器：$(0, 1, 0, 1)$。\n\n- **步骤 4：$C_2$ 执行 $\\mathrm{Load}\\, X$。**\n  - $C_2$ 未命中，发出 $\\mathrm{BusRd}$。\n  - 存在共享者。$C_0$（状态 $Sm$，所有者）提供数据并保持 $Sm$ 状态。$C_1$（状态 $Sc$）不做任何操作。\n  - $C_2$ 接收数据并从 $I \\to Sc$ 转换。\n  - **事件：** $C_2$：$\\mathrm{I}\\to\\mathrm{S}$。\n  - 缓存状态：$(C_0: Sm, C_1: Sc, C_2: Sc)$。计数器：$(0, 2, 0, 1)$。\n\n- **步骤 5：$C_1$ 执行 $\\mathrm{Store}\\, X$。**\n  - $C_1$ 持有状态为 $Sc$。它从 $Sc \\to Sm$ 转换并广播一个 $\\mathrm{BusUpd}$。$C_1$ 成为新的所有者。\n  - 前一个所有者 $C_0$（状态 $Sm$）窥探到 $\\mathrm{BusUpd}$，更新其数据，并从 $Sm \\to Sc$ 转换。\n  - $C_2$（状态 $Sc$）更新其数据并保持 $Sc$ 状态。\n  - **事件：** 发生一次 $\\mathrm{BusUpd}$。\n  - 缓存状态：$(C_0: Sc, C_1: Sm, C_2: Sc)$。计数器：$(0, 2, 0, 2)$。\n\n- **步骤 6：$C_0$ 执行 $\\mathrm{Load}\\, X$。**\n  - $C_0$ 持有状态为 $Sc$。这是一次加载命中。没有状态改变或总线事务。\n  - 缓存状态：$(C_0: Sc, C_1: Sm, C_2: Sc)$。计数器：$(0, 2, 0, 2)$。\n\n- **步骤 7：$C_2$ 执行 $\\mathrm{Store}\\, X$。**\n  - $C_2$ 持有状态为 $Sc$。它从 $Sc \\to Sm$ 转换并广播一个 $\\mathrm{BusUpd}$。$C_2$ 成为新的所有者。\n  - 前一个所有者 $C_1$（状态 $Sm$）窥探、更新，并从 $Sm \\to Sc$ 转换。\n  - $C_0$（状态 $Sc$）更新并保持 $Sc$ 状态。\n  - **事件：** 发生一次 $\\mathrm{BusUpd}$。\n  - 缓存状态：$(C_0: Sc, C_1: Sc, C_2: Sm)$。计数器：$(0, 2, 0, 3)$。\n\n- **步骤 8：$C_1$ 执行 $\\mathrm{Load}\\, X$。**\n  - $C_1$ 持有状态为 $Sc$。这是一次加载命中。没有状态改变。\n  - 缓存状态：$(C_0: Sc, C_1: Sc, C_2: Sm)$。计数器：$(0, 2, 0, 3)$。\n\n**写更新（WU）协议的最终计数：**\n- 总 $\\mathrm{S}\\to\\mathrm{I}$ 转换次数：$0$。\n- 总 $\\mathrm{I}\\to\\mathrm{S}$ 转换次数：$2$。\n- 总 $\\mathrm{S}\\to\\mathrm{M}$ 转换次数：$0$。\n- 总 $\\mathrm{BusUpd}$ 事件数：$3$。\n\n**结果总结**\n将两种协议的结果合并为所需的矩阵格式：\n- 写无效 $\\mathrm{S}\\to\\mathrm{I}$：$5$\n- 写无效 $\\mathrm{I}\\to\\mathrm{S}$：$4$\n- 写无效 $\\mathrm{S}\\to\\mathrm{M}$：$1$\n- 写无效 $\\mathrm{BusUpd}$：$0$\n- 写更新 $\\mathrm{S}\\to\\mathrm{I}$：$0$\n- 写更新 $\\mathrm{I}\\to\\mathrm{S}$：$2$\n- 写更新 $\\mathrm{S}\\to\\mathrm{M}$：$0$\n- 写更新 $\\mathrm{BusUpd}$：$3$\n\n最终答案是按指定顺序排列的这些计数的行矩阵。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n5  4  1  0  0  2  0  3\n\\end{pmatrix}\n}\n$$", "id": "3678515"}, {"introduction": "现实世界中的问题往往更为复杂，本练习将带你处理一个实际中可能遇到的挑战：数据未对齐。你将研究一个跨越两个缓存行的变量如何影响一致性通信量，这会让你深刻理解一致性是在缓存行粒度上维护的，而非变量粒度。解决这个问题将加深你对协议粒度及其对软件性能实际影响的认识。", "problem": "考虑一个共享内存多处理器，它有 $3$ 个核心，分别表示为 $C_0$、$C_1$ 和 $C_2$。每个核心都有一个私有的写回式缓存（write-back cache），该缓存通过单个共享总线参与一个监听一致性协议（snooping coherence protocol）。缓存行大小为 $64$ 字节。一个大小为 $24$ 字节的程序变量 $v$ 未对齐，以至于它恰好跨越了两个相邻的缓存行 $L_0$ 和 $L_1$：$L_0$ 的最后 $8$ 个字节存储了 $v$ 的前 $8$ 个字节，$L_1$ 的前 $16$ 个字节存储了 $v$ 剩余的 $16$ 个字节。\n\n假设存在以下初始条件和硬件行为：\n- 在时间 $t=0$ 时，没有核心的缓存中持有 $L_0$ 或 $L_1$。\n- 当一个读请求需要的数据不在缓存行中时，会为所需的缓存行发出一次行填充（line fill）。当一次读取填充了一个缓存行，且当前没有其他缓存持有该行时，该行被调入请求者的缓存中。在写无效协议（write-invalidate protocol）下，该行进入独占（Exclusive）状态；在写更新协议（write-update protocol）下，该行进入共享（Shared）状态。\n- 每次修改缓存行内任意字节的存储操作都以缓存行粒度进行一致性操作，这意味着一个同时触及 $L_0$ 和 $L_1$ 的存储操作将被实现为两次独立的、针对单个缓存行的存储，一次对 $L_0$，一次对 $L_1$。\n- 在以下场景中，没有缓存行被驱逐。\n\n定义需要分析的两种一致性协议变体：\n- 使用修改-独占-共享-无效（Modified–Exclusive–Shared–Invalid, MESI）状态机的写无效协议。计算的一致性广播包括：每次 $\\text{BusRd}$（读未命中行填充）计一次，每次 $\\text{BusRdX}$（为写入不存在的行而获取所有权）计一次，以及每次 $\\text{BusUpgr}$（为写入已存在的行而从共享升级到修改）计一次。不计算静默状态转换或对内存的写回；只计算促使其他缓存监听其标签的监听总线广播。\n- 采用写分配（write-allocate）和逐行更新的写更新协议。计算的一致性广播包括：每次 $\\text{BusRd}$（为获取共享副本而进行的读未命中行填充）计一次，以及每次 $\\text{BusUpdate}$（写入时向其他共享副本广播新数据）计一次。不计算静默状态转换或对内存的写回。\n\n现在对变量 $v$ 执行以下操作序列：\n1. 核心 $C_0$ 执行一次对 $v$ 的读取，该操作触及 $L_0$ 和 $L_1$。\n2. 核心 $C_1$ 执行两次存储操作：首先，它在 $v$ 位于 $L_0$ 的部分内写入 $4$ 个连续字节；其次，它在 $v$ 位于 $L_1$ 的部分内写入 $8$ 个连续字节。\n3. 核心 $C_2$ 在 $v$ 位于 $L_1$ 的部分内执行一次对 $8$ 个连续字节的存储操作。\n4. 核心 $C_0$ 再次执行一次对 $v$ 的读取，触及 $L_0$ 和 $L_1$。\n5. 核心 $C_1$ 在 $v$ 位于 $L_0$ 的部分内执行一次对 $4$ 个连续字节的存储操作。\n6. 核心 $C_2$ 在 $v$ 位于 $L_1$ 的部分内执行一次对 $4$ 个连续字节的存储操作。\n\n在上述假设下，令 $M_{\\text{inv}}$ 为写无效协议下的监听总线广播总数，$M_{\\text{upd}}$ 为写更新协议下的总数。计算单一量 $M_{\\text{upd}} - M_{\\text{inv}}$。请用一个没有单位的纯数字表示最终答案。如果需要任何数值近似，请四舍五入到四位有效数字；否则给出精确的整数值。", "solution": "该问题定义明确，科学上基于计算机体系结构的原理，并提供了一套完整的初始条件、操作序列和协议规则。所有必要信息都已提供，足以确定性地追踪系统状态，并为两种不同的缓存一致性协议计算指定的总线广播次数。因此，该问题是有效的，可以推导出解决方案。\n\n目标是计算差值 $M_{\\text{upd}} - M_{\\text{inv}}$，其中 $M_{\\text{inv}}$ 是写无效（MESI）协议下的监听总线广播总数，$M_{\\text{upd}}$ 是写更新协议下的总数。该分析需要追踪两个缓存行 $L_0$ 和 $L_1$ 在 $3$ 个核心（$C_0$、$C_1$、$C_2$）上执行 $6$ 个操作序列时的状态。\n\n让三个核心的缓存行状态由一个成对的元组表示：$((S_{0,0}, S_{0,1}), (S_{1,0}, S_{1,1}), (S_{2,0}, S_{2,1}))$，其中 $S_{i,j}$ 是核心 $C_i$ 缓存中缓存行 $L_j$ 的状态。所有缓存中所有行的初始状态均为无效（Invalid, I）：$((I, I), (I, I), (I, I))$。\n\n**第1部分：写无效（MESI）协议分析**\n\n我们根据MESI状态（修改、独占、共享、无效）追踪操作并计算广播次数（$M_{\\text{inv}}$）。\n\n初始状态：$((I, I), (I, I), (I, I))$，$M_{\\text{inv}} = 0$。\n\n1.  **$C_0$ 读取 $v$（触及 $L_0$ 和 $L_1$）**：这包括两次读未命中。\n    -   $C_0$ 读取 $L_0$：这是一次未命中。由于没有其他缓存持有 $L_0$，$C_0$ 发出一次 `BusRd` 并将该行置为 **独占（Exclusive, E）** 状态。\n        -   总线广播：$1$ 次（`BusRd`）。$M_{\\text{inv}} \\leftarrow 0 + 1 = 1$。\n    -   $C_0$ 读取 $L_1$：这也是一次未命中。同样，$C_0$ 发出一次 `BusRd` 并将 $L_1$ 置为 **E** 状态。\n        -   总线广播：$1$ 次（`BusRd`）。$M_{\\text{inv}} \\leftarrow 1 + 1 = 2$。\n    -   操作1后状态：$((E, E), (I, I), (I, I))$。此步骤总广播数：$2$。\n\n2.  **$C_1$ 写入 $L_0$ 和 $L_1$**：这包括两次写未命中。\n    -   $C_1$ 写入 $L_0$：一次写未命中。$C_1$ 发出一次 `BusRdX`（为写而读所有权）。$C_0$ 监听到总线，看到对其持有的 **E** 状态的 $L_0$ 的请求，并使其副本无效（**E** $\\rightarrow$ **I**）。$C_1$ 将该行加载到 **修改（Modified, M）** 状态。\n        -   总线广播：$1$ 次（`BusRdX`）。$M_{\\text{inv}} \\leftarrow 2 + 1 = 3$。\n    -   $C_1$ 写入 $L_1$：另一次写未命中。$C_1$ 为 $L_1$ 发出一次 `BusRdX`。$C_0$ 使其 $L_1$ 的副本无效（**E** $\\rightarrow$ **I**）。$C_1$ 将 $L_1$ 置为 **M** 状态。\n        -   总线广播：$1$ 次（`BusRdX`）。$M_{\\text{inv}} \\leftarrow 3 + 1 = 4$。\n    -   操作2后状态：$((I, I), (M, M), (I, I))$。此步骤总广播数：$2$。\n\n3.  **$C_2$ 写入 $L_1$**：这是一次写未命中。\n    -   $C_2$ 为 $L_1$ 发出一次 `BusRdX`。$C_1$ 监听到总线，看到它持有 **M** 状态的 $L_1$，将数据刷到内存（或直接传给 $C_2$），并使其副本无效（**M** $\\rightarrow$ **I**）。$C_2$ 将该行加载到 **M** 状态。\n        -   总线广播：$1$ 次（`BusRdX`）。$M_{\\text{inv}} \\leftarrow 4 + 1 = 5$。\n    -   操作3后状态：$((I, I), (M, I), (I, M))$。此步骤总广播数：$1$。\n\n4.  **$C_0$ 读取 $v$（触及 $L_0$ 和 $L_1$）**：两次读未命中。\n    -   $C_0$ 读取 $L_0$：未命中。$C_0$ 发出一次 `BusRd`。$C_1$ 监听到，它持有 **M** 状态的 $L_0$，提供数据，并将其状态转换为 **共享（Shared, S）**。$C_0$ 将该行加载到 **S** 状态。\n        -   总线广播：$1$ 次（`BusRd`）。$M_{\\text{inv}} \\leftarrow 5 + 1 = 6$。\n    -   $C_0$ 读取 $L_1$：未命中。$C_0$ 发出一次 `BusRd`。$C_2$ 监听到，它持有 **M** 状态的 $L_1$，提供数据，并将其状态转换为 **S**。$C_0$ 将该行加载到 **S** 状态。\n        -   总线广播：$1$ 次（`BusRd`）。$M_{\\text{inv}} \\leftarrow 6 + 1 = 7$。\n    -   操作4后状态：$((S, S), (S, I), (I, S))$。此步骤总广播数：$2$。\n\n5.  **$C_1$ 写入 $L_0$**：一次写命中，但作用于共享行。\n    -   $C_1$ 持有 **S** 状态的 $L_0$。为了写入，它必须获得独占所有权。它发出一次 `BusUpgr` 事务。$C_0$ 监听到并使其 $L_0$ 的副本无效（**S** $\\rightarrow$ **I**）。$C_1$ 将其状态从 **S** 转换为 **M**。\n        -   总线广播：$1$ 次（`BusUpgr`）。$M_{\\text{inv}} \\leftarrow 7 + 1 = 8$。\n    -   操作5后状态：$((I, S), (M, I), (I, S))$。此步骤总广播数：$1$。\n\n6.  **$C_2$ 写入 $L_1$**：一次写命中，但作用于共享行。\n    -   $C_2$ 持有 **S** 状态的 $L_1$。它发出一次 `BusUpgr`。$C_0$ 监听到并使其 $L_1$ 的副本无效（**S** $\\rightarrow$ **I**）。$C_2$ 将其状态从 **S** 转换为 **M**。\n        -   总线广播：$1$ 次（`BusUpgr`）。$M_{\\text{inv}} \\leftarrow 8 + 1 = 9$。\n    -   操作6后状态：$((I, I), (M, I), (I, M))$。此步骤总广播数：$1$。\n\n写无效协议的总线广播总数为 $M_{\\text{inv}} = 9$。\n\n**第2部分：写更新协议分析**\n\n我们追踪操作并计算广播次数（$M_{\\text{upd}}$）。根据问题描述，状态被简化为共享（Shared, S）和无效（Invalid, I）。对共享行的写入会触发一次 `BusUpdate`，所有副本保持共享状态。写未命中会触发一次 `BusRd`，然后是一次 `BusUpdate`。\n\n初始状态：$((I, I), (I, I), (I, I))$，$M_{\\text{upd}} = 0$。\n\n1.  **$C_0$ 读取 $v$（触及 $L_0$ 和 $L_1$）**：两次读未命中。\n    -   $C_0$ 读取 $L_0$：未命中。由于没有其他缓存持有该行，根据规则，$C_0$ 发出一次 `BusRd` 并将该行置为 **共享（Shared, S）** 状态。\n        -   总线广播：$1$ 次（`BusRd`）。$M_{\\text{upd}} \\leftarrow 0 + 1 = 1$。\n    -   $C_0$ 读取 $L_1$：未命中。$C_0$ 发出一次 `BusRd` 并将 $L_1$ 置为 **S** 状态。\n        -   总线广播：$1$ 次（`BusRd`）。$M_{\\text{upd}} \\leftarrow 1 + 1 = 2$。\n    -   操作1后状态：$((S, S), (I, I), (I, I))$。此步骤总广播数：$2$。\n\n2.  **$C_1$ 写入 $L_0$ 和 $L_1$**：两次写未命中。\n    -   $C_1$ 写入 $L_0$：这是一次写未命中（“写分配”）。$C_1$ 首先发出一次 `BusRd` 来获取该行。$C_0$ 持有 **S** 状态的 $L_0$。$C_1$ 将该行加载到 **S** 状态。然后，$C_1$ 执行写入，此时是命中一个共享行，触发一次 `BusUpdate`。$C_0$ 更新其副本。\n        -   总线广播：$1$ 次（`BusRd`）+ $1$ 次（`BusUpdate`）。$M_{\\text{upd}} \\leftarrow 2 + 2 = 4$。\n    -   $C_1$ 写入 $L_1$：类似地，$C_1$ 为 $L_1$ 发出一次 `BusRd`，将其置为 **S** 状态。然后它为写入发出一次 `BusUpdate`。$C_0$ 更新其副本。\n        -   总线广播：$1$ 次（`BusRd`）+ $1$ 次（`BusUpdate`）。$M_{\\text{upd}} \\leftarrow 4 + 2 = 6$。\n    -   操作2后状态：$((S, S), (S, S), (I, I))$。此步骤总广播数：$4$。\n\n3.  **$C_2$ 写入 $L_1$**：一次写未命中。\n    -   $C_2$ 发出一次 `BusRd` 以获取 $L_1$。$C_0$ 和 $C_1$ 持有 **S** 状态的该行。$C_2$ 将 $L_1$ 加载到 **S** 状态。然后 $C_2$ 写入，发出一次 `BusUpdate`。$C_0$ 和 $C_1$ 更新它们的副本。\n        -   总线广播：$1$ 次（`BusRd`）+ $1$ 次（`BusUpdate`）。$M_{\\text{upd}} \\leftarrow 6 + 2 = 8$。\n    -   操作3后状态：$((S, S), (S, S), (I, S))$。此步骤总广播数：$2$。\n\n4.  **$C_0$ 读取 $v$（触及 $L_0$ 和 $L_1$）**：两次读命中。\n    -   $C_0$ 读取 $L_0$：在 **S** 状态下命中。无广播。\n    -   $C_0$ 读取 $L_1$：在 **S** 状态下命中。无广播。\n    -   操作4后状态：$((S, S), (S, S), (I, S))$。此步骤总广播数：$0$。\n\n5.  **$C_1$ 写入 $L_0$**：一次写命中，但作用于共享行。\n    -   $C_1$ 持有 **S** 状态的 $L_0$。它执行写入并发出一次 `BusUpdate`。$C_0$ 更新其副本。两个缓存中的该行都保持 **S** 状态。\n        -   总线广播：$1$ 次（`BusUpdate`）。$M_{\\text{upd}} \\leftarrow 8 + 1 = 9$。\n    -   操作5后状态：$((S, S), (S, S), (I, S))$。此步骤总广播数：$1$。\n\n6.  **$C_2$ 写入 $L_1$**：一次写命中，但作用于共享行。\n    -   $C_2$ 持有 **S** 状态的 $L_1$。它执行写入并发出一次 `BusUpdate`。$C_0$ 和 $C_1$ 更新它们的副本。三个缓存中的该行都保持 **S** 状态。\n        -   总线广播：$1$ 次（`BusUpdate`）。$M_{\\text{upd}} \\leftarrow 9 + 1 = 10$。\n    -   操作6后状态：$((S, S), (S, S), (I, S))$。此步骤总广播数：$1$。\n\n写更新协议的总线广播总数为 $M_{\\text{upd}} = 10$。\n\n**第3部分：最终计算**\n\n题目要求我们计算 $M_{\\text{upd}} - M_{\\text{inv}}$ 的值。\n-   写无效协议的总广播数：$M_{\\text{inv}} = 9$。\n-   写更新协议的总广播数：$M_{\\text{upd}} = 10$。\n\n差值为：\n$M_{\\text{upd}} - M_{\\text{inv}} = 10 - 9 = 1$。\n最终答案是一个精确的整数值。", "answer": "$$\\boxed{1}$$", "id": "3678490"}]}