{"hands_on_practices": [{"introduction": "时间侧信道攻击的核心在于精确测量由秘密操作引起的微小时间差异。然而，在实际中，我们可用的计时器精度有限，可能无法直接捕捉到单个操作的纳秒级延迟。本练习将引导你通过一个思想实验，探索如何通过重复执行目标操作来放大这种微小的时间信号，直至其足以被低分辨率计时器检测到，这是许多现实世界时间攻击的必要第一步。[@problem_id:3676151]", "problem": "攻击者正在对中央处理器 (CPU) 发起时间侧信道攻击，通过测量一段代码路径的执行时间，该路径可能包含恰好一次额外的末级缓存 (LLC) 未命中。相对于无未命中的基线，这一次未命中的惩罚会给执行时间增加一个大小为 $\\delta$ 的微小真实时间增量，其中 $\\delta \\ll \\Delta$。可用的计时器具有有限的分辨率 $\\Delta$：任何真实的经过时间 $T$ 将被返回为不超过 $T$ 的 $\\Delta$ 的最大倍数。\n\n攻击者可以通过将同一个对测量敏感的操作连续重复 $R$ 次，然后读取一次计时器来放大时间差异，这对基线路径和每次操作产生一次额外未命中的路径都适用。假设与计时器分辨率引起的量化相比，所有其他噪声源都可以忽略不计，并且每次操作的真实未命中惩罚 $\\delta$ 在重复执行中是恒定且独立的。\n\n仅从以下基本依据出发：\n- 如果单个操作在两种条件下表现出 $\\delta$ 的真实时间差异，那么 $R$ 次相同的连续重复将在这些条件下表现出 $R \\delta$ 的真实时间差异。\n- 对于真实时间 $T$，计时器返回的测量时间为 $M(T) = \\Delta \\left\\lfloor \\frac{T}{\\Delta} \\right\\rfloor$，其中 $\\left\\lfloor \\cdot \\right\\rfloor$ 是向下取整函数。\n\n推导出一个关于 $R$ 的条件，该条件保证对于量化区间内真实时间的任何可能对齐方式，两种测量时间（基线与每次操作一次未命中）都将是不同的。然后，确定满足此条件的最小整数 $R$。将您的最终答案表示为关于 $\\Delta$ 和 $\\delta$ 的单个闭式解析表达式。", "solution": "该问题要求推导一个关于重复次数 $R$ 的条件，以保证可测量的计时差异，并由此得出 $R$ 的最小整数值。分析将从提供的基本定义出发。\n\n首先，我们定义真实执行时间。设 $T_{0}$ 为基线（无未命中）操作的真实执行时间。\n基线路径重复 $R$ 次的真实执行时间为：\n$$T_{base} = R T_{0}$$\n\n每次操作有一次额外未命中的路径，其单次操作的真实执行时间为 $T_{0} + \\delta$。对于 $R$ 次连续重复，其真实执行时间为：\n$$T_{miss} = R (T_{0} + \\delta) = R T_{0} + R \\delta$$\n\n计时器具有有限分辨率 $\\Delta$。对于真实时间 $T$，测得的时间 $M$ 由以下函数给出：\n$$M(T) = \\Delta \\left\\lfloor \\frac{T}{\\Delta} \\right\\rfloor$$\n其中 $\\lfloor \\cdot \\rfloor$ 是向下取整函数。\n\n将此应用于我们的两种情况，基线路径的测量时间为：\n$$M_{base} = M(T_{base}) = \\Delta \\left\\lfloor \\frac{R T_{0}}{\\Delta} \\right\\rfloor$$\n\n有未命中路径的测量时间为：\n$$M_{miss} = M(T_{miss}) = \\Delta \\left\\lfloor \\frac{R T_{0} + R \\delta}{\\Delta} \\right\\rfloor$$\n\n目标是找到一个关于 $R$ 的条件，该条件保证对于 $T_{0}$ 的任何可能值，都有 $M_{miss} \\neq M_{base}$。由于未命中惩罚 $\\delta$ 是一个正的时间增量，所以 $T_{miss} > T_{base}$。因此，测量的时间不会减少，即 $M_{miss} \\ge M_{base}$。因此，测量时间不同的条件等价于要求 $M_{miss} > M_{base}$。\n\n$$ \\Delta \\left\\lfloor \\frac{R T_{0} + R \\delta}{\\Delta} \\right\\rfloor > \\Delta \\left\\lfloor \\frac{R T_{0}}{\\Delta} \\right\\rfloor $$\n\n两边同除以 $\\Delta$（这是一个正的时间量），不等式保持不变：\n$$ \\left\\lfloor \\frac{R T_{0}}{\\Delta} + \\frac{R \\delta}{\\Delta} \\right\\rfloor > \\left\\lfloor \\frac{R T_{0}}{\\Delta} \\right\\rfloor $$\n\n我们引入无量纲变量 $x = \\frac{R T_{0}}{\\Delta}$ 和 $y = \\frac{R \\delta}{\\Delta}$。所需条件变为：\n$$ \\lfloor x + y \\rfloor > \\lfloor x \\rfloor $$\n这个不等式必须对任何 $x \\ge 0$ 的值都成立，因为基线时间 $T_{0}$ 是未知的，可能导致“量化区间内真实时间的任何对齐方式”。变量 $x$ 代表这种对齐方式，并按重复次数 $R$ 进行了缩放。\n\n当且仅当区间 $(x, x+y]$ 中没有整数时，不等式 $\\lfloor x + y \\rfloor > \\lfloor x \\rfloor$ 不成立。这种情况，即 $\\lfloor x+y \\rfloor = \\lfloor x \\rfloor$，对攻击者构成了最大的挑战。我们需要找到一个关于 $y$（也就是关于 $R$）的条件，以防止对于任何 $x$ 这种相等情况的发生。\n\n区分时间的最坏情况发生在基线真实时间 $T_{base}$（即 $x$）的位置使得增加的放大惩罚 $R\\delta$（即 $y$）最不可能跨越计时器分辨率的整数边界。这种情况发生在基线时间 $T_{base}$ 恰好略大于 $\\Delta$ 的某个倍数时。\n\n让我们将其形式化。设 $k = \\lfloor x \\rfloor$ 为一个整数。$x$ 的值可以写成 $x = k + \\epsilon$，其中 $0 \\le \\epsilon  1$。变量 $\\epsilon$ 表示 $x$ 的小数部分，对应于计时器量化区间内的对齐方式。问题陈述这必须对*任何*可能的对齐方式都成立，因此我们必须考虑 $\\epsilon \\in [0, 1)$ 的所有可能值。\n\n不等式变为：\n$$ \\lfloor k + \\epsilon + y \\rfloor  \\lfloor k + \\epsilon \\rfloor $$\n由于 $k$ 是整数且 $0 \\le \\epsilon  1$，我们有 $\\lfloor k + \\epsilon \\rfloor = k$。条件是：\n$$ \\lfloor k + \\epsilon + y \\rfloor  k $$\n这等价于要求：\n$$ k + \\epsilon + y \\ge k+1 $$\n$$ \\epsilon + y \\ge 1 $$\n\n这个不等式 $y \\ge 1 - \\epsilon$ 必须对 $\\epsilon \\in [0, 1)$ 的所有可能值都成立。为保证这一点，我们必须为“最坏情况”下的 $\\epsilon$ 值满足不等式，即最难满足条件的值。右侧的 $1-\\epsilon$ 在 $\\epsilon$ 最小时最大化。$\\epsilon$ 的下界是 $0$。为确保条件对于任意小的正数 $\\epsilon$ 都成立，我们必须考虑当 $\\epsilon \\to 0^{+}$ 时的极限。\n在此极限下，条件变为：\n$$ y \\ge 1 $$\n\n代回 $y = \\frac{R\\delta}{\\Delta}$：\n$$ \\frac{R\\delta}{\\Delta} \\ge 1 $$\n$$ R\\delta \\ge \\Delta $$\n\n这是关于 $R$ 的通用条件，它保证无论初始时间对齐如何，测量的时间都将是不同的。总的放大时间差 $R\\delta$ 必须至少与单个计时器分辨率间隔 $\\Delta$ 一样大。\n\n最后一步是确定满足此条件的最小*整数* $R$。从不等式 $R\\delta \\ge \\Delta$，我们可以分离出 $R$：\n$$ R \\ge \\frac{\\Delta}{\\delta} $$\n由于 $R$ 必须是整数，满足此不等式的最小整数值 $R$ 是比率 $\\frac{\\Delta}{\\delta}$ 的向上取整。向上取整函数 $\\lceil z \\rceil$ 给出大于或等于 $z$ 的最小整数。\n\n因此，最小的整数重复次数是：\n$$ R_{min} = \\left\\lceil \\frac{\\Delta}{\\delta} \\right\\rceil $$\n该表达式是最小整数 $R$ 的完整且最终的解析解。问题陈述中的初始条件 $\\delta \\ll \\Delta$ 意味着 $\\frac{\\Delta}{\\delta} \\gg 1$，这证实了攻击要成功确实需要大量的重复，这与放大微小信号的前提是一致的。", "answer": "$$\\boxed{\\left\\lceil \\frac{\\Delta}{\\delta} \\right\\rceil}$$", "id": "3676151"}, {"introduction": "一旦我们掌握了测量微小时间差异的方法，下一个关键问题是：这些差异究竟泄露了关于秘密的什么信息？本练习模拟了一个针对加密算法中S盒（替换盒）的缓存攻击场景。你将从底层硬件原理出发，分析内存地址如何映射到缓存行，并推导出一次缓存观测能揭示多少关于密钥的信息，最终使用信息论的熵来精确量化攻击后密钥的剩余不确定性。[@problem_id:3676164]", "problem": "一个具有 $256$ 个条目的单字节替换盒（S-box）连续存储在内存中，并与一个 $64$ 字节的边界对齐。每个条目的大小为 $e$ 字节，其中 $e$ 是 $2$ 的幂，且 $1 \\leq e \\leq 64$。该表总共占用 $256e$ 字节。中央处理器（CPU）缓存的缓存行大小为 $64$ 字节。假设每次S-box查找只访问一个缓存行，并且没有硬件特性（如预取）会获取不相关的缓存行。\n\n使用一个秘密密钥字节 $k \\in \\{0,1,\\dots,255\\}$ 来构成S-box索引 $i = p \\oplus k$，其中 $\\oplus$ 表示按位异或，而 $p$ 是由攻击者提供的已知明文字节。攻击者可以执行 $m \\geq 1$ 次选择明文查询，使用明文字節 $p_{1},\\dots,p_{m}$，并且对于每次查询，只能观察到S-box查找所访问的缓存行索引 $\\ell \\in \\{0,1,\\dots,L-1\\}$，其中 $L$ 是该表所跨越的缓存行数量。\n\n从与缓存和内存寻址相关的计算机组成第一性原理出发，回答以下问题：\n\n1. 推导映射到给定缓存行索引 $\\ell$ 的S-box索引 $i$ 的集合。用 $e$、$64$ 和 $\\ell$ 来表达你的推导过程，不要使用任何快捷公式。\n\n2. 在 $k$ 在 $\\{0,\\dots,255\\}$ 上服从均匀先验分布，并假设在已知 $p_{j}$ 的情况下进行了 $m \\geq 1$ 次观察，通过计算后验分布的香农熵（以比特为单位）来量化这些观察之后关于 $k$ 的剩余不确定性。将最终结果表示为关于 $e$ 的封闭形式表达式。不要四舍五入；结果以比特表示。", "solution": "这个问题分为两部分。首先，我们必须推导出S-box索引与其对应的缓存行索引之间的关系。其次，我们必须利用这种关系，使用香农熵来量化关于秘密密钥泄露的信息。\n\n### 第一部分：每个缓存行的S-box索引推导\n\n给定一个具有 $256$ 个条目的S-box表，它在内存中连续存储。表的起始地址与一个 $64$ 字节的边界对齐。设S-box表的基地址为 $A_{\\text{base}}$。对齐条件意味着 $A_{\\text{base}}$ 是 $64$ 的倍数。数学上表示为 $A_{\\text{base}} \\pmod{64} = 0$。\n\nS-box中的每个条目大小为 $e$ 字节。S-box由 $i \\in \\{0, 1, \\dots, 255\\}$ 索引。索引 $i$ 的条目的第一个字节的内存地址由下式给出：\n$$A_i = A_{\\text{base}} + i \\cdot e$$\nCPU缓存的缓存行大小为 $C_S = 64$ 字节。一个内存地址 $A$ 映射到一个物理缓存行。包含地址 $A$ 的缓存行的索引是 $\\lfloor A / C_S \\rfloor = \\lfloor A / 64 \\rfloor$。\n\n问题陈述攻击者观察到一个相对缓存行索引 $\\ell$。这是相对于S-box表起始位置的缓存行索引。该表占用的第一个缓存行的绝对索引是 $\\lfloor A_{\\text{base}} / 64 \\rfloor$。由于 $A_{\\text{base}}$ 是 $64$ 的倍数，假设 $A_{\\text{base}} = 64 \\cdot N$（其中 $N$ 为某个整数），这个索引就是 $N$。\n\n内存地址 $A_i$ 的绝对缓存行索引是 $\\lfloor A_i / 64 \\rfloor$。相对索引 $\\ell$ 是它与基地址索引的差：\n$$\\ell = \\lfloor \\frac{A_i}{64} \\rfloor - \\lfloor \\frac{A_{\\text{base}}}{64} \\rfloor$$\n代入 $A_i$ 和 $A_{\\text{base}}$ 的表达式：\n$$\\ell = \\left\\lfloor \\frac{64 \\cdot N + i \\cdot e}{64} \\right\\rfloor - \\left\\lfloor \\frac{64 \\cdot N}{64} \\right\\rfloor$$\n利用向下取整函数对于任意整数 $k$ 的性质 $\\lfloor x+k \\rfloor = \\lfloor x \\rfloor + k$：\n$$\\ell = \\left\\lfloor \\frac{i \\cdot e}{64} + N \\right\\rfloor - N = \\left\\lfloor \\frac{i \\cdot e}{64} \\right\\rfloor + N - N = \\left\\lfloor \\frac{i \\cdot e}{64} \\right\\rfloor$$\n这个方程提供了从S-box索引 $i$ 到观察到的相对缓存行索引 $\\ell$ 的映射关系。\n\n为了找到映射到给定缓存行索引 $\\ell$ 的S-box索引 $i$ 的集合，我们必须解这个关于 $i$ 的方程。根据向下取整函数的定义，方程 $\\ell = \\lfloor x \\rfloor$ 等价于不等式 $\\ell \\le x  \\ell + 1$。将此应用于我们的方程：\n$$\\ell \\le \\frac{i \\cdot e}{64}  \\ell + 1$$\n为了分离出 $i$，我们将不等式两边乘以 $64/e$：\n$$\\frac{64\\ell}{e} \\le i  \\frac{64(\\ell+1)}{e}$$\n由于 $i$ 必须是整数并且被限制在范围 $\\{0, 1, \\dots, 255\\}$ 内，映射到特定缓存行索引 $\\ell$ 的S-box索引集合 $S_\\ell$ 是：\n$$S_\\ell = \\left\\{ i \\in \\{0, 1, \\dots, 255\\} \\, \\middle| \\, \\frac{64\\ell}{e} \\le i  \\frac{64(\\ell+1)}{e} \\right\\}$$\n每个缓存行的S-box索引数量对于所有的 $\\ell$ 都是常数，等于 $\\frac{64(\\ell+1)}{e} - \\frac{64\\ell}{e} = \\frac{64}{e}$。我们用 $N_C = \\frac{64}{e}$ 来表示这个数量。因为 $e$ 是2的幂且 $1 \\le e \\le 64$，所以 $N_C$ 也是2的幂且 $1 \\le N_C \\le 64$。因此，索引集合可以写为 $\\{i \\mid \\ell N_C \\le i  (\\ell+1)N_C\\}$。\n\n### 第二部分：量化剩余不确定性\n\n攻击者执行选择明文攻击。对于一个选择的明文 $p$，S-box索引是 $i = p \\oplus k$，其中 $k$ 是秘密密钥。攻击者观察到缓存行索引 $\\ell = \\lfloor (p \\oplus k) \\cdot e / 64 \\rfloor$。这个观察揭示了值 $p \\oplus k$ 属于哪个集合 $S_\\ell$。\n\n条件 $i \\in S_\\ell$ 等价于 $\\lfloor i/N_C \\rfloor = \\ell$，其中 $N_C = 64/e$。如前所述，$N_C$ 是2的幂。设 $N_C = 2^n$。操作 $i \\to \\lfloor i/2^n \\rfloor$ 等价于将8位整数 $i$进行 $n$ 位的算术右移。此操作有效地提取了 $i$ 的最高有效 $8-n$ 位。$i$ 的最低 $n$ 位被丢弃。\n\n因此，观察索引 $i=p \\oplus k$ 所对应的 $\\ell$ 等价于获知值 $p \\oplus k$ 的最高有效 $8-n$ 位。\n按位异或操作没有进位，这意味着结果 $p \\oplus k$ 的每一位只取决于 $p$ 和 $k$ 的相应位。设 $x_{MSB}$ 和 $x_{LSB}$ 分别表示一个8位值 $x$ 的最高有效 $8-n$ 位和最低有效 $n$ 位。那么：\n$$(p \\oplus k)_{MSB} = p_{MSB} \\oplus k_{MSB}$$\n$$(p \\oplus k)_{LSB} = p_{LSB} \\oplus k_{LSB}$$\n攻击者观察到 $(p \\oplus k)_{MSB}$。由于攻击者选择了 $p$，他们知道 $p_{MSB}$。因此，他们可以计算出秘密密钥的最高有效 $8-n$ 位：\n$$k_{MSB} = (p \\oplus k)_{MSB} \\oplus p_{MSB}$$\n对于任何已知的 $p$，单次观察就足以确定 $k_{MSB}$。使用其他明文 $p_j$ 进行的任何进一步观察只会再次确认关于 $k_{MSB}$ 的相同信息。\n\n关键在于，观察完全没有提供关于密钥最低有效 $n$ 位（即 $k_{LSB}$）的任何信息。$k$ 的先验分布在所有 $256$ 种可能性上是均匀的，这意味着 $k$ 的 $8$ 个比特中的每一个都是独立且均匀随机的二进制数字。攻击之后，最高的 $8-n$ 位是已知的，但最低的 $n$ 位仍然完全未知，并且仍然是均匀分布的。\n\n可能的密钥集合被缩减为那些共享已确定的 $k_{MSB}$ 的密钥。由于 $k_{LSB}$ 中有 $n$ 个未知位，因此还剩下 $2^n$ 个可能的密钥。后验概率分布在这个包含 $2^n$ 个密钥的集合上是均匀的。这些剩余密钥中每一个的概率是 $P(k) = 1/2^n$。\n\n密钥 $K$ 的后验分布的香农熵由 $H(K) = -\\sum_{k} P(k) \\log_2 P(k)$ 给出。对于我们在 $2^n$ 个结果上的均匀分布：\n$$H(K) = - \\sum_{j=1}^{2^n} \\frac{1}{2^n} \\log_2\\left(\\frac{1}{2^n}\\right) = - 2^n \\cdot \\frac{1}{2^n} \\log_2(2^{-n}) = - (-n) = n$$\n剩余的不确定性是 $n$ 比特。我们必须用给定的参数 $e$ 来表示它。我们有关系式 $N_C = 2^n$ 和 $N_C=64/e$。\n$$2^n = \\frac{64}{e}$$\n对等式两边取以2为底的对数：\n$$n = \\log_2\\left(\\frac{64}{e}\\right) = \\log_2(64) - \\log_2(e) = \\log_2(2^6) - \\log_2(e) = 6 - \\log_2(e)$$\n因此，关于密钥 $k$ 的剩余不确定性，通过其后验分布的香农熵来量化，是 $6 - \\log_2(e)$ 比特。", "answer": "$$\n\\boxed{6 - \\log_{2}(e)}\n$$", "id": "3676164"}, {"introduction": "了解攻击原理后，防御侧信道攻击就变得至关重要，而软件实现方式的选择是第一道防线。本练习将对比两种实现同一加密功能（AES的SubBytes）的方法：一种是易受缓存攻击的查表法，另一种是旨在消除数据依赖性的“位切片”（bit-slicing）法。通过分析，你将辨别不同微架构效应（如缓存、分支预测）如何成为泄露源，并思考如何通过经验性测试来评估和验证“恒定时间”代码的安全性。[@problem_id:3676135]", "problem": "一个实现者正在比较两种高级加密标准 (AES) SubBytes 设计在一个现代的乱序超标量核心上的性能。该核心具有私有的指令和数据缓存、固定的频率，并且没有同步多线程。实现 $\\mathrm{I}_{\\mathrm{TBL}}$ 使用一个由秘密字节索引的 $256$ 项查找表，代码为直线型代码，没有条件分支。实现 $\\mathrm{I}_{\\mathrm{BIT}}$ 是一个位切片（bit-sliced）实现，它仅使用寄存器上的布尔运算来计算相同的映射，没有依赖于秘密的控制流，也没有依赖于秘密的内存地址；轮密钥从固定地址加载。在每次运行之前，缓存都会被无效化。攻击者可以收集每次调用的踪迹（trace），包括挂钟周期数（wall-clock cycles）、选定的硬件性能计数器（例如，数据缓存未命中、分支预测错误以及每个端口的微操作发射计数），以及输入类别标签。攻击者无法直接测量功耗或电磁辐射。目标是根据第一性原理推断，与 $\\mathrm{I}_{\\mathrm{TBL}}$ 相比，$\\mathrm{I}_{\\mathrm{BIT}}$ 中哪些微架构效应仍可能产生依赖于秘密的时间或计数器变化，以及如何根据收集到的踪迹凭经验估计一个残余泄漏度量 $\\ell$。\n\n仅使用侧信道泄漏的核心定义和关于微架构可变性的公认事实作为出发点：依赖于秘密的内存地址可能导致可变延迟的缓存行为，预测错误的分支会招致惩罚，执行端口根据指令组合来调度微操作。推断在所述条件下，这些效应是否能在每种实现中产生与秘密相关的可观测变量。\n\n下列哪个陈述是正确的？\n\nA. 在 $\\mathrm{I}_{\\mathrm{TBL}}$ 中，数据缓存行为是依赖于秘密的，因为表索引是秘密的，所以即使没有分支，缓存命中和未命中（以及总周期数）也与秘密相关。在 $\\mathrm{I}_{\\mathrm{BIT}}$ 中，消除依赖于秘密的内存地址和分支可以去除基于缓存和分支的时间泄漏；如果指令组合与秘密无关，执行端口的争用不会泄漏秘密。为了估计 $\\ell$，可以收集两组踪迹（固定秘密与随机秘密），并对周期数和未命中计数等特征应用双样本统计检验；一个较大的绝对检验统计量表示存在泄漏。\n\nB. 在 $\\mathrm{I}_{\\mathrm{BIT}}$ 中，指令缓存仍然会泄漏秘密，因为指令获取地址依赖于由秘密驱动的分支目标。通过仅比较固定秘密和随机秘密之间的平均周期数来估计 $\\ell$ 是足够的；不需要统计检验。\n\nC. 在 $\\mathrm{I}_{\\mathrm{TBL}}$ 中，缓存不会泄漏，因为表足够小，可以驻留在数据缓存中，所以能保证命中。在 $\\mathrm{I}_{\\mathrm{BIT}}$ 中，布尔运算具有依赖于数据的延迟，这会改变执行端口的使用情况，从而创建一个依赖于秘密的时间信道。估计 $\\ell$ 最直接的方法是计算分支预测错误的数量。\n\nD. 在所述条件下，$\\mathrm{I}_{\\mathrm{BIT}}$ 中唯一剩余的泄漏源是数据通路中的功耗或电磁开关活动，而不是缓存、分支或端口时序；因此，$\\ell$ 无法通过时序或硬件计数器检测到，必须从功耗踪迹中估计。\n\nE. 在所述的单线程、固定频率条件下，$\\mathrm{I}_{\\mathrm{BIT}}$ 消除了依赖于秘密的缓存和分支效应，并且如果指令序列是固定的，其执行端口的使用也是与秘密无关的。一种根据可用踪迹凭经验估计 $\\ell$ 的方法是，计算所选秘密特征（例如，秘密字节的一个比特）与时序和计数器测量向量之间的互信息估计值；一个非零的估计值表示存在可测量的泄漏。", "solution": "此问题要求分析两种AES SubBytes实现（查表法 $\\mathrm{I}_{\\mathrm{TBL}}$ 和位切片法 $\\mathrm{I}_{\\mathrm{BIT}}$）的侧信道漏洞，并确定评估泄漏的方法。\n\n**选项 A 的分析：**\n- 对 $\\mathrm{I}_{\\mathrm{TBL}}$ 的分析是正确的。该实现使用由秘密索引的查找表，导致内存访问地址依赖于秘密。这会造成数据缓存的命中/未命中模式以及总执行时间与秘密相关，构成一个典型的缓存侧信道。\n- 对 $\\mathrm{I}_{\\mathrm{BIT}}$ 的分析也是正确的。通过消除依赖于秘密的内存访问和分支，它确实关闭了主要的缓存和分支预测信道。其固定的指令序列也使得执行端口争用与秘密无关。\n- 泄漏评估方法是正确的。收集两组踪迹（固定秘密与随机秘密）并应用双样本统计检验（如t检验）是测试向量泄漏评估（TVLA）的标准方法，一个显著的检验统计量表明存在泄漏。\n因此，陈述 A 是正确的。\n\n**选项 B 的分析：**\n这是错误的。$\\mathrm{I}_{\\mathrm{BIT}}$ 被明确描述为“没有依赖于秘密的控制流”，因此指令获取地址与秘密无关，指令缓存不会成为泄漏源。此外，仅比较平均值不足以证明泄漏，需要统计检验来区分信号和随机噪声。\n\n**选项 C 的分析：**\n这是错误的。$\\mathrm{I}_{\\mathrm{TBL}}$ 中的小表并不能保证无泄漏，特别是每次运行前清空缓存，使得依赖于秘密的地址会导致对不同缓存行的强制未命中。关于 $\\mathrm{I}_{\\mathrm{BIT}}$，现代CPU中简单的布尔运算通常具有固定的延迟，不会因数据值不同而改变执行端口使用模式从而产生时序信道。\n\n**选项 D 的分析：**\n这是错误的。虽然 $\\mathrm{I}_{\\mathrm{BIT}}$ 中剩余泄漏的物理根源可能是功耗变化，但这种变化可以耦合到时序域，产生可测量的执行时间抖动（jitter）。因此，泄漏可以通过高精度计时器（如挂钟周期计数器）检测到，该陈述错误地排除了时序检测的可能性。\n\n**选项 E 的分析：**\n- 对 $\\mathrm{I}_{\\mathrm{BIT}}$ 的分析是正确的。它准确地总结了其设计如何消除依赖于秘密的缓存、分支和执行端口使用效应。\n- 泄漏评估方法是正确的。计算秘密与测量向量之间的互信息（MI）是一种更根本、更通用的量化信息泄漏的方法。一个非零的互信息估计值直接证明了存在可测量的统计依赖性，即信息泄漏。\n因此，陈述 E 是正确的。\n\n综上所述，陈述 A 和 E 都是正确的。它们都对实现进行了正确的分析，并描述了行业标准的、有效的泄漏评估方法。", "answer": "$$\\boxed{AE}$$", "id": "3676135"}]}