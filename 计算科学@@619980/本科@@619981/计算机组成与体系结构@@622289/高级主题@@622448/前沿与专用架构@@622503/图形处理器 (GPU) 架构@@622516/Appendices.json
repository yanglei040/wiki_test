{"hands_on_practices": [{"introduction": "GPU 的强大性能源于其通过大量活动线程束（warps）来隐藏内存延迟的能力，这一指标被称为“占用率”（occupancy）。然而，最大化占用率并非总是最优解，因为它受到寄存器、共享内存等多种资源的限制。本练习将引导你通过数学建模来分析线程块大小（block size）如何影响资源消耗，并最终找到在满足内核需求的同时最大化占用率的最佳配置，这是 GPU 性能调优中的一项核心技能。[@problem_id:3644790]", "problem": "图形处理单元 (GPU) 中的流式多处理器 (SM) 以称为线程束 (warp) 的线程组形式执行单指令多线程 (SIMT) 工作。SM 的占用率 (occupancy) 定义为活跃线程束数量与 SM 可支持的最大线程束数量之比。考虑一个具有以下特征的 GPU：线程束大小 $W=32$，每个 SM 的最大线程束数 $W_{\\max}=64$，每个 SM 的最大线程数 $T_{\\mathrm{SM}}^{\\max}=2048$，每个 SM 的最大线程块数 $B_{\\mathrm{SM}}^{\\max}=32$，每个 SM 的寄存器文件大小 $R_{\\mathrm{SM}}=65536$ (32位寄存器)，每个 SM 的共享内存大小 $S_{\\mathrm{SM}}=65536$ 字节，以及每个线程块的最大线程数 $T_{\\mathrm{blk}}^{\\max}=1024$。\n\n一个内核 (kernel) 以线程块大小 $T$ (每个线程块的线程数) 启动，其中 $T$ 必须是 $W$ 的正整数倍。对于此内核，每个线程的寄存器使用量建模为 $r(T)=r_{0}+\\alpha \\log_{2}\\!\\left(\\frac{T}{W}\\right)$，其中 $r_{0}=28$ 且 $\\alpha=4$；每个线程块的共享内存使用量建模为 $S(T)=s_{0}+\\beta T$，其中 $s_{0}=2048\\,\\text{bytes}$ 且 $\\beta=16\\,\\text{bytes/thread}$。为了确保足够的指令级并行性（ILP），内核要求每个线程的寄存器数至少为 $r_{\\min}=32$。请确定在满足所有约束条件的情况下，能够最大化 SM 占用率的整数线程块大小 $T$。", "solution": "所述问题在科学上基于 GPU 架构的原理，是一个设定良好 (well-posed) 的优化问题，具有一套完整且一致的给定条件。所有参数对于现代流式多处理器而言都是物理上现实的。因此，我们可以进行形式化的求解。\n\n我们的目标是找到整数线程块大小 $T$，以最大化流式多处理器 (SM) 的占用率。占用率 $\\mathcal{O}$ 定义为活跃线程束数量 $W_{\\text{active}}$ 与 SM 可支持的最大线程束数量 $W_{\\max}$ 之比。\n$$\n\\mathcal{O} = \\frac{W_{\\text{active}}}{W_{\\max}}\n$$\n最大化占用率等同于在硬件和内核约束条件下最大化活跃线程束的数量 $W_{\\text{active}}$。活跃线程束的数量是 SM 上同时驻留的线程块数量 $B_{\\text{active}}$ 与每个线程块的线程束数量 $W_{\\text{blk}}$ 的乘积。\n\n每个线程块的线程数 $T$ 受限于必须是线程束大小 $W=32$ 的正整数倍。因此，每个线程块的线程束数量是一个整数，由下式给出：\n$$\nW_{\\text{blk}} = \\frac{T}{W} = \\frac{T}{32}\n$$\n那么，总的活跃线程束数量为：\n$$\nW_{\\text{active}}(T) = B_{\\text{active}}(T) \\times W_{\\text{blk}} = B_{\\text{active}}(T) \\times \\frac{T}{32}\n$$\n活跃线程块的数量 $B_{\\text{active}}(T)$ 受限于 SM 的有限资源。对于给定的线程块大小 $T$，能够同时活跃的线程块数量是由最大线程块数、最大线程数、寄存器和共享内存施加的限制中的最小值决定的。\n\n让我们从每种资源确定对 $B_{\\text{active}}$ 的限制：\n1.  **每个 SM 的最大线程块数：** 硬件最多支持 $B_{\\mathrm{SM}}^{\\max}$ 个线程块。\n    $$B_{\\text{active}} \\le B_{\\mathrm{SM}}^{\\max} = 32$$\n\n2.  **每个 SM 的最大线程数：** 所有活跃线程块的总线程数不能超过 $T_{\\mathrm{SM}}^{\\max}$。\n    $$B_{\\text{active}} \\times T \\le T_{\\mathrm{SM}}^{\\max} \\implies B_{\\text{active}} \\le \\left\\lfloor \\frac{T_{\\mathrm{SM}}^{\\max}}{T} \\right\\rfloor = \\left\\lfloor \\frac{2048}{T} \\right\\rfloor$$\n    请注意，此约束等同于最大线程束约束，因为 $W_{\\text{active}} = B_{\\text{active}} \\frac{T}{W} \\le \\lfloor \\frac{T_{\\mathrm{SM}}^{\\max}}{T} \\rfloor \\frac{T}{W} \\le \\frac{T_{\\mathrm{SM}}^{\\max}}{T} \\frac{T}{W} = \\frac{T_{\\mathrm{SM}}^{\\max}}{W} = \\frac{2048}{32} = 64 = W_{\\max}$。\n\n3.  **每个 SM 的寄存器文件大小：** 所有活跃线程块使用的总寄存器数不能超过 $R_{\\mathrm{SM}}$。每个线程块的寄存器数量是每个线程块的线程数 $T$ 与每个线程的寄存器数 $r(T)$ 的乘积。\n    $$r(T) = r_{0}+\\alpha \\log_{2}\\!\\left(\\frac{T}{W}\\right) = 28+4 \\log_{2}\\!\\left(\\frac{T}{32}\\right)$$\n    $$B_{\\text{active}} \\times T \\times r(T) \\le R_{\\mathrm{SM}} \\implies B_{\\text{active}} \\le \\left\\lfloor \\frac{R_{\\mathrm{SM}}}{T \\cdot r(T)} \\right\\rfloor = \\left\\lfloor \\frac{65536}{T \\left(28+4 \\log_{2}\\!\\left(\\frac{T}{32}\\right)\\right)} \\right\\rfloor$$\n\n4.  **每个 SM 的共享内存：** 所有活跃线程块使用的总共享内存不能超过 $S_{\\mathrm{SM}}$。每个线程块的共享内存由 $S(T)$ 给出。\n    $$S(T) = s_{0}+\\beta T = 2048 + 16T$$\n    $$B_{\\text{active}} \\times S(T) \\le S_{\\mathrm{SM}} \\implies B_{\\text{active}} \\le \\left\\lfloor \\frac{S_{\\mathrm{SM}}}{S(T)} \\right\\rfloor = \\left\\lfloor \\frac{65536}{2048 + 16T} \\right\\rfloor$$\n\n综合这些，对于给定的 $T$，活跃线程块的数量是：\n$$\nB_{\\text{active}}(T) = \\min\\left(32, \\left\\lfloor \\frac{2048}{T} \\right\\rfloor, \\left\\lfloor \\frac{65536}{T \\cdot r(T)} \\right\\rfloor, \\left\\lfloor \\frac{65536}{2048 + 16T} \\right\\rfloor\\right)\n$$\n我们现在必须确定线程块大小 $T$ 的有效范围。问题对 $T$ 规定了三个约束：\n1.  $T$ 必须是 $W=32$ 的正整数倍。\n2.  $T \\le T_{\\mathrm{blk}}^{\\max} = 1024$。\n3.  必须满足指令级并行 (ILP) 约束：$r(T) \\ge r_{\\min} = 32$。\n    $$28+4 \\log_{2}\\!\\left(\\frac{T}{32}\\right) \\ge 32 \\implies 4 \\log_{2}\\!\\left(\\frac{T}{32}\\right) \\ge 4 \\implies \\log_{2}\\!\\left(\\frac{T}{32}\\right) \\ge 1 \\implies \\frac{T}{32} \\ge 2 \\implies T \\ge 64$$\n因此，可行的线程块大小 $T$ 的集合是 $\\{64, 96, 128, 160, \\dots, 1024\\}$。我们将对这个离散的值集评估 $W_{\\text{active}}(T)$ 以找到最大值。\n\n让我们为几个可行的 $T$ 值计算 $B_{\\text{active}}(T)$ 和 $W_{\\text{active}}(T)$。\n\n对于 $T=64$:\n$r(64) = 28+4\\log_2(2) = 32$。 $S(64) = 2048+16(64) = 3072$。\n$B_{\\text{active}}(64) = \\min\\left(32, \\lfloor\\frac{2048}{64}\\rfloor, \\lfloor\\frac{65536}{64 \\cdot 32}\\rfloor, \\lfloor\\frac{65536}{3072}\\rfloor\\right) = \\min(32, 32, 32, 21) = 21$。\n$W_{\\text{active}}(64) = 21 \\times \\frac{64}{32} = 21 \\times 2 = 42$。\n\n对于 $T=96$:\n$r(96) = 28+4\\log_2(3) \\approx 34.34$。 $S(96) = 2048+16(96) = 3608$。\n$B_{\\text{active}}(96) = \\min\\left(32, \\lfloor\\frac{2048}{96}\\rfloor, \\lfloor\\frac{65536}{96 \\cdot (28+4\\log_2(3))}\\rfloor, \\lfloor\\frac{65536}{3608}\\rfloor\\right) = \\min(32, 21, 19, 18) = 18$。\n$W_{\\text{active}}(96) = 18 \\times \\frac{96}{32} = 18 \\times 3 = 54$。\n\n对于 $T=128$:\n$r(128) = 28+4\\log_2(4) = 36$。 $S(128) = 2048+16(128) = 4096$。\n$B_{\\text{active}}(128) = \\min\\left(32, \\lfloor\\frac{2048}{128}\\rfloor, \\lfloor\\frac{65536}{128 \\cdot 36}\\rfloor, \\lfloor\\frac{65536}{4096}\\rfloor\\right) = \\min(32, 16, 14, 16) = 14$。\n$W_{\\text{active}}(128) = 14 \\times \\frac{128}{32} = 14 \\times 4 = 56$。\n\n对于 $T=160$:\n$r(160) = 28+4\\log_2(5) \\approx 37.29$。 $S(160) = 2048+16(160) = 4608$。\n$B_{\\text{active}}(160) = \\min\\left(32, \\lfloor\\frac{2048}{160}\\rfloor, \\lfloor\\frac{65536}{160 \\cdot (28+4\\log_2(5))}\\rfloor, \\lfloor\\frac{65536}{4608}\\rfloor\\right) = \\min(32, 12, 10, 14) = 10$。\n$W_{\\text{active}}(160) = 10 \\times \\frac{160}{32} = 10 \\times 5 = 50$。\n\n对于 $T=192$:\n$r(192) = 28+4\\log_2(6) \\approx 38.34$。 $S(192) = 2048+16(192) = 5120$。\n$B_{\\text{active}}(192) = \\min\\left(32, \\lfloor\\frac{2048}{192}\\rfloor, \\lfloor\\frac{65536}{192 \\cdot (28+4\\log_2(6))}\\rfloor, \\lfloor\\frac{65536}{5120}\\rfloor\\right) = \\min(32, 10, 8, 12) = 8$。\n$W_{\\text{active}}(192) = 8 \\times \\frac{192}{32} = 8 \\times 6 = 48$。\n\n计算出的活跃线程束数值为 $42, 54, 56, 50, 48, \\dots$。由于 floor 函数和不同约束之间的相互作用，函数 $W_{\\text{active}}(T)$ 不是单调的。然而，趋势表明峰值在 $T=128$ 附近。当 $T  128$ 时，寄存器限制 $\\lfloor \\frac{R_{\\mathrm{SM}}}{T \\cdot r(T)} \\rfloor$ 和线程限制 $\\lfloor \\frac{T_{\\mathrm{SM}}^{\\max}}{T} \\rfloor$ 变得越来越严格，导致 $B_{\\text{active}}(T)$ 以及随后的 $W_{\\text{active}}(T)$ 减小。$T=192$ 的计算证实了这种下降趋势。\n\n找到的最大活跃线程束数量为 $56$，这在线程块大小为 $T=128$ 时出现。这对应于占用率 $\\mathcal{O} = 56/64 = 0.875$。\n\n因此，在所有给定约束下最大化占用率的整数线程块大小 $T$ 是 $128$。", "answer": "$$\n\\boxed{128}\n$$", "id": "3644790"}, {"introduction": "在了解了流式多处理器（SM）的宏观资源平衡后，我们将深入探讨一个关键的片上资源——共享内存。共享内存被划分为多个存储体（bank）以实现并行访问，但若同一线程束中的多个线程同时访问同一存储体，就会引发“存储体冲突”（bank conflict），导致访问串行化，严重影响性能。本练习将通过一个经典的矩阵转置问题，让你亲手推导如何通过内存填充（padding）来消除存储体冲突，从而深刻理解硬件结构对代码效率的决定性影响。[@problem_id:3644845]", "problem": "图形处理单元 (GPU) 遵循单指令多线程 (SIMT) 模型，以组的形式执行线程。其中，一个线程束由 $32$ 个线程组成，这些线程访问片上共享内存。共享内存被组织成 $B=32$ 个存储体，每个存储体在没有冲突的情况下，每个周期可以服务一个 $4$ 字节的字。对于一个给定字地址为 $a$ 的 $4$ 字节字，其存储体索引由基本映射规则 $a \\bmod B$ 给出。如果在同一条指令中，同一线程束内的两个或多个线程访问映射到同一存储体的不同地址，就会发生存储体冲突。考虑一个使用共享内存实现的分块矩阵转置，其中一个分块被声明为维度为 $T \\times (T+p)$ 的行主序数组，$T$ 是分块大小，$p$ 是一个整数列填充。每个元素是一个 $4$ 字节的字。在转置的第二阶段，一个包含 $32$ 个线程的完整线程束从共享内存中读取分块的一列（即，线程 $t$ 读取行索引为 $t$ 且列索引固定的元素）。\n\n从存储体映射规则和存储体冲突的定义出发，推导出一个最小非负整数填充 $p$（表示为关于 $T$ 的符号表达式），该填充能保证完整线程束对分块所有列的读取都是无存储体冲突的。假设分块的共享内存基地址与存储体边界对齐，使得分块的第一个元素的存储体索引为 $0$。将你的最终答案表示为关于 $T$ 的单个解析表达式。不需要进行取整。", "solution": "我们的目标是找到最小的非负整数填充 $p$，以确保当一个完整的线程束（32个线程）按列访问一个共享内存分块时不会发生存储体冲突。\n\n1.  **地址计算**: 矩阵以行主序存储，维度为 $T \\times (T+p)$，每个元素是一个字（4字节）。因此，位于 `(row, col)` 的元素的字地址为 `addr(row, col) = row * (T+p) + col`。\n\n2.  **存储体映射**: 共享内存有 $B=32$ 个存储体。字地址为 $a$ 的数据被映射到存储体 `bank_index = a mod 32`。\n\n3.  **访问模式**: 一个线程束（32个线程，索引 $t$ 从0到31）读取一个固定的列 $j$。线程 $t$ 读取 `(row=t, col=j)` 处的元素。\n\n4.  **推导存储体索引**: 对于线程 $t$，它访问的字地址为 `addr(t, j) = t * (T+p) + j`。该地址对应的存储体索引为 `bank(t) = (t * (T+p) + j) mod 32`。\n\n5.  **无冲突条件**: 为了避免存储体冲突，线程束中的所有32个线程必须访问不同的存储体。这意味着对于任意两个不同的线程索引 $t_1, t_2 \\in \\{0, 1, \\dots, 31\\}$，它们访问的存储体索引必须不同：\n    `bank(t_1) ≠ bank(t_2)`。\n\n    假设发生了冲突，即对于 $t_1 \\neq t_2$，有 `bank(t_1) = bank(t_2)`。\n    $$(t_1 \\cdot (T+p) + j) \\bmod 32 = (t_2 \\cdot (T+p) + j) \\bmod 32$$\n    $$((t_1 - t_2) \\cdot (T+p)) \\bmod 32 = 0$$\n\n6.  **分析冲突条件**: 为了保证对于任何 $t_1 \\neq t_2$（即 $t_1 - t_2$ 是 $\\{1, 2, \\dots, 31\\}$ 中的某个值）都不会发生冲突，我们需要确保 `(t_1 - t_2) * (T+p)` 永远不是32的倍数。\n    \n    这要求步幅 `(T+p)` 与存储体数量32互质。因为 $32 = 2^5$，所以 `(T+p)` 不能是偶数，即 `(T+p)` 必须是奇数。\n\n7.  **确定最小非负填充p**: 我们需要找到最小的非负整数 $p$，使得 `T+p` 为奇数。\n    -   如果 $T$ 是偶数，为了使 `T+p` 成为奇数，`p` 必须是奇数。最小的非负奇数 $p$ 是1。\n    -   如果 $T$ 是奇数，为了使 `T+p` 成为奇数，`p` 必须是偶数。最小的非负偶数 $p$ 是0。\n\n8.  **统一表达式**: 我们可以将这个分情况的逻辑统一为一个表达式。我们注意到：\n    -   如果 $T$ 是偶数， $T+1$ 是奇数， $(T+1) \\bmod 2 = 1$。\n    -   如果 $T$ 是奇数， $T+1$ 是偶数， $(T+1) \\bmod 2 = 0$。\n\n    这正好匹配了我们需要的 $p$ 值。因此，最小非负填充 $p$ 可以表示为 $p = (T+1) \\bmod 2$。", "answer": "$$\n\\boxed{(T+1) \\bmod 2}\n$$", "id": "3644845"}, {"introduction": "在掌握了片上资源的优化后，我们来探讨一种旨在减少高延迟全局内存访问的强大技术——内核融合（kernel fusion）。该技术将多个连续的、对数据进行逐元素操作的内核合并为一个，从而显著减少了与主内存的交互次数。然而，这种优化是有代价的：它会增加每个线程的寄存器使用量，进而可能降低占用率。本练习将让你量化这一核心权衡，计算在维持必要占用率以隐藏延迟的前提下，最多可以融合多少个操作，从而揭示内存优化与计算资源限制之间的微妙平衡。[@problem_id:3644777]", "problem": "一个使用单指令多线程 (SIMT) 的图形处理单元 (GPU) 处理器执行按元素的核函数，这些核函数在大于缓存的数组上进行流式处理。考虑在一个包含 $N$ 个元素的数组上执行一个由 $k$ 个按元素操作组成的流水线，其中每个操作为每个元素读取一个 $4$ 字节的输入值并写入一个 $4$ 字节的输出值。当这些操作作为 $k$ 个独立的核函数执行时，每个元素的总内存流量与核函数的数量成正比；而当它们融合成一个单一的核函数时，数组只被读取一次并写入一次，从而使总内存流量大约减少了 $k$ 倍。\n\n然而，核函数融合会增加每线程的寄存器使用量。假设单个流式多处理器 (SM) 具有以下特性：\n- SM 有一个大小为 $R_{\\mathrm{SM}} = 65536$ 个寄存器的寄存器文件（每个寄存器为 $32$ 位）。\n- 每个 SM 的硬件线程数上限为 $T_{\\max} = 2048$。\n- 每个 SM 的最大驻留线程块数为 $B_{\\max} = 8$。\n- 每个线程块包含 $t_b = 256$ 个线程。\n- 每个线程的寄存器硬件上限为 $r_{\\mathrm{thr\\_max}} = 255$。\n- 基础的未融合核函数（$k=1$）每线程使用 $r_0 = 20$ 个寄存器。\n- 由于活跃的临时变量和指令级并行，每个额外的融合的按元素操作会使每线程寄存器使用量增加 $\\alpha = 8$ 个寄存器，因此融合 $k$ 个操作时的每线程寄存器使用量为 $r(k) = r_0 + \\alpha(k - 1)$。\n- 忽略除寄存器、线程数和线程块数之外的所有资源限制。假设寄存器是按线程精确分配的，没有粒度效应。\n\n占用率定义为每个 SM 的驻留线程数除以 $T_{\\max}$。为保持延迟隐藏，要求占用率至少为 $0.5$。每个 SM 的驻留线程块数受寄存器、线程数和线程块数的限制，其值为 $\\min\\!\\left(B_{\\max}, \\left\\lfloor \\dfrac{R_{\\mathrm{SM}}}{r(k)\\, t_b} \\right\\rfloor, \\left\\lfloor \\dfrac{T_{\\max}}{t_b} \\right\\rfloor \\right)$。\n\n在这些假设下，确定能使融合核函数保持至少 $0.5$ 占用率的最大整数 $k$。最终答案只需提供 $k$ 的最大整数值。", "solution": "我们的目标是找到能够保持最低 GPU 占用率的融合操作的最大整数数量 $k$。解决方案需要逐步应用给定的约束条件。\n\n首先，我们将占用率的要求形式化。占用率 $O$ 定义为流式多处理器 (SM) 上的驻留线程数与每个 SM 可能的最大线程数 $T_{\\max}$ 的比率。驻留线程数是驻留线程块数 $B_{\\mathrm{res}}$ 与每块线程数 $t_b$ 的乘积。约束条件是 $O \\ge 0.5$。\n\n$$O = \\frac{B_{\\mathrm{res}} \\times t_b}{T_{\\max}} \\ge 0.5$$\n\n给定 $T_{\\max} = 2048$ 和 $t_b = 256$。代入这些值，我们可以求解所需的最小驻留块数 $B_{\\mathrm{res}}$：\n\n$$\\frac{B_{\\mathrm{res}} \\times 256}{2048} \\ge 0.5$$\n$$\\frac{B_{\\mathrm{res}}}{8} \\ge 0.5$$\n$$B_{\\mathrm{res}} \\ge 4$$\n\n由于线程块数必须是整数，这意味着 SM 上必须至少有 $4$ 个驻留线程块。\n\n每个 SM 的驻留块数 $B_{\\mathrm{res}}$ 受三个因素限制：每个 SM 的最大块数 ($B_{\\max}$)、总寄存器文件大小 ($R_{\\mathrm{SM}}$) 和每个 SM 的最大线程数 ($T_{\\max}$)。提供的公式是：\n\n$$B_{\\mathrm{res}} = \\min\\!\\left(B_{\\max}, \\left\\lfloor \\frac{R_{\\mathrm{SM}}}{r(k) \\cdot t_b} \\right\\rfloor, \\left\\lfloor \\frac{T_{\\max}}{t_b} \\right\\rfloor \\right)$$\n\n我们计算这个表达式中的常数项。给定 $B_{\\max} = 8$。由线程数施加的限制是：\n\n$$\\left\\lfloor \\frac{T_{\\max}}{t_b} \\right\\rfloor = \\left\\lfloor \\frac{2048}{256} \\right\\rfloor = \\lfloor 8 \\rfloor = 8$$\n\n因此，$B_{\\mathrm{res}}$ 的公式简化为：\n\n$$B_{\\mathrm{res}} = \\min\\!\\left(8, \\left\\lfloor \\frac{R_{\\mathrm{SM}}}{r(k) \\cdot t_b} \\right\\rfloor \\right)$$\n\n现在，我们将其与我们推导出的条件 $B_{\\mathrm{res}} \\ge 4$ 结合起来：\n\n$$\\min\\!\\left(8, \\left\\lfloor \\frac{R_{\\mathrm{SM}}}{r(k) \\cdot t_b} \\right\\rfloor \\right) \\ge 4$$\n\n要使两个量的最小值至少为 $4$，这两个量都必须至少为 $4$。第一个条件 $8 \\ge 4$ 显然成立。第二个条件给出了系统的主要约束：\n\n$$\\left\\lfloor \\frac{R_{\\mathrm{SM}}}{r(k) \\cdot t_b} \\right\\rfloor \\ge 4$$\n\n由于 floor 函数的性质，这意味着其内部的参数必须大于或等于 4：\n\n$$\\frac{R_{\\mathrm{SM}}}{r(k) \\cdot t_b} \\ge 4$$\n\n这个不等式为每线程的寄存器数量 $r(k)$ 设定了一个上限。我们可以解出 $r(k)$：\n\n$$r(k) \\le \\frac{R_{\\mathrm{SM}}}{4 \\cdot t_b}$$\n\n代入给定值 $R_{\\mathrm{SM}} = 65536$ 和 $t_b = 256$：\n\n$$r(k) \\le \\frac{65536}{4 \\times 256} = \\frac{65536}{1024} = 64$$\n\n所以，为了维持所需的占用率，每线程的寄存器使用量不能超过 $64$。\n\n题目提供了一个关于寄存器使用量作为融合操作数 $k$ 的函数的模型：\n\n$$r(k) = r_0 + \\alpha(k - 1)$$\n\n我们已知基础寄存器使用量 $r_0 = 20$ 和每次融合操作的增量 $\\alpha = 8$。对于 $k \\ge 1$，我们有：\n\n$$r(k) = 20 + 8(k - 1)$$\n\n现在我们应用推导出的约束条件 $r(k) \\le 64$：\n\n$$20 + 8(k - 1) \\le 64$$\n\n我们对这个不等式求解 $k$：\n\n$$8(k - 1) \\le 64 - 20$$\n$$8(k - 1) \\le 44$$\n$$k - 1 \\le \\frac{44}{8}$$\n$$k - 1 \\le 5.5$$\n$$k \\le 6.5$$\n\n题目要求的是 $k$ 的最大整数值。由于 $k$ 必须是整数且 $k \\le 6.5$，所以 $k$ 可能的最大整数值是 $6$。\n\n为了验证，如果 $k = 6$，$r(6) = 20 + 8(6-1) = 60$。那么 $B_{\\mathrm{res}} = \\min(8, \\lfloor \\frac{65536}{60 \\times 256} \\rfloor) = \\min(8, \\lfloor 4.26\\dots \\rfloor) = \\min(8, 4) = 4$。占用率为 $\\frac{4 \\times 256}{2048} = 0.5$，满足要求。\n如果 $k = 7$，$r(7) = 20 + 8(7-1) = 68$。那么 $B_{\\mathrm{res}} = \\min(8, \\lfloor \\frac{65536}{68 \\times 256} \\rfloor) = \\min(8, \\lfloor 3.76\\dots \\rfloor) = \\min(8, 3) = 3$。占用率为 $\\frac{3 \\times 256}{2048} = 0.375$，低于所要求的 $0.5$。\n因此，最大的整数 $k$ 是 $6$。", "answer": "$$\\boxed{6}$$", "id": "3644777"}]}