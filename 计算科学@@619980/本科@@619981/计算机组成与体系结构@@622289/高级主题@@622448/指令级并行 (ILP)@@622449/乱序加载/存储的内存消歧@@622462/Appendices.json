{"hands_on_practices": [{"introduction": "在乱序执行处理器中，内存排序冲突是一个核心挑战。当对内存依赖关系的推测性预测失败时，处理器必须采取纠正措施，但这会带来性能开销。本练习提供了一个具体的内存排序违规场景，要求您应用一种明确定义的恢复策略，通过计算必须被清除和重新发出的加载指令数量，您将能深入理解内存违规的后果以及加载存储队列（LSQ）在维护程序正确性中的关键作用 [@problem_id:3664944]。", "problem": "一个超标量乱序核强制按序引退，并实现了一个加载-存储队列（LSQ）来维持加载和存储之间的内存顺序。LSQ 的深度为 $D=16$。该机器允许推测性内存消歧：即使存在地址未解析的旧存储指令，较新的加载指令也可以发射。当加载的有效地址与某个旧存储的地址匹配时，核心会使用来自存储缓冲区的存储到加载前递。在内存依赖预测错误时（例如，尽管一个旧的未解析的存储指令实际上与之别名，但一个较新的加载指令被允许发射），核心采用全局加载重放策略：当违规的旧存储指令的地址解析并检测到冲突时，所有比该存储指令新且已执行其内存访问的加载指令都将被清除并重新发射。\n\n考虑在某个旧存储指令解析其地址并检测到冲突的瞬间，当前驻留在加载-存储队列（LSQ）中的以下按程序顺序排列的内存操作序列。索引随程序顺序递增；索引 $0$ 是最旧的条目，索引 $13$ 是最新的条目。因此，LSQ 的占用率为 $14$，在深度 $D=16$ 的范围内。每个操作都用其类型和有效地址符号进行注释。在检测到冲突的瞬间，所有列出的加载指令都已经执行了其内存访问。\n\n索引 $0$：$S_{0}$ 写入 $A$（$S_{0}$ 的地址在插入时已解析）。\n索引 $1$：$L_{1}$ 读取 $A$（已执行；从 $S_{0}$ 正确前递）。\n索引 $2$：$L_{2}$ 读取 $B$（已执行；与 $S_{0}$ 无别名）。\n索引 $3$：$S_{1}$ 写入一个最初未解析的地址，该地址后来解析为 $A$（这是违规的存储指令）。\n索引 $4$：$L_{3}$ 读取 $A$（推测性发射；内存依赖预测器声称与 $S_{1}$“无别名”；从 $S_{0}$ 前递，这是不正确的，因为 $S_{1}$ 更旧，应提供该值）。\n索引 $5$：$L_{4}$ 读取 $C$（已执行）。\n索引 $6$：$S_{2}$ 写入 $D$。\n索引 $7$：$L_{5}$ 读取 $E$（已执行）。\n索引 $8$：$L_{6}$ 读取 $F$（已执行）。\n索引 $9$：$S_{3}$ 写入 $G$。\n索引 $10$：$L_{7}$ 读取 $H$（已执行）。\n索引 $11$：$L_{8}$ 读取 $I$（已执行）。\n索引 $12$：$S_{4}$ 写入 $J$。\n索引 $13$：$L_{9}$ 读取 $K$（已执行）。\n\n定义重放窗口 $W_{r}$ 为在索引 $3$ 的 $S_{1}$ 处检测到预测错误时必须被清除并重新发射的较新加载指令的数量。使用提供的 LSQ 深度 $D$ 和程序顺序的内存序列计算 $W_{r}$。用一个没有单位的精确整数表示你的答案。", "solution": "首先将验证问题的科学合理性、自洽性和清晰度。\n\n### 步骤 1：提取已知条件\n- **核心架构**：超标量、乱序执行、按序引退。\n- **加载-存储队列 (LSQ)**：深度 $D=16$。\n- **内存消歧**：推测性；较新的加载指令可以在地址未解析的旧存储指令解析之前发射。\n- **前递**：实现了存储到加载的前递。\n- **预测错误恢复策略**：使用全局加载重放策略。一旦检测到内存依赖预测错误（即，在别名的旧存储指令的地址已知之前，一个较新的加载指令被错误地执行），核心将清除并重新发射**所有比违规存储指令新**且已执行其内存访问的加载指令。\n- **违规存储指令**：索引 $3$ 处的 $S_{1}$。它最初有一个未解析的地址，现在解析为地址 $A$，揭示了与推测执行的加载指令 $L_3$ 的冲突。\n- **LSQ 状态**：LSQ 中存在一个包含 $14$ 个内存操作（索引 $0$ 到 $13$）的序列。\n- **执行状态**：在检测到预测错误的瞬间，所有列出的加载指令都已经执行了它们的内存访问。\n- **内存操作序列**：\n    - 索引 $0$：存储指令 $S_{0}$ 写入地址 $A$。\n    - 索引 $1$：加载指令 $L_{1}$ 从地址 $A$ 读取。\n    - 索引 $2$：加载指令 $L_{2}$ 从地址 $B$ 读取。\n    - 索引 $3$：存储指令 $S_{1}$ 写入地址 $A$（这是违规的存储指令）。\n    - 索引 $4$：加载指令 $L_{3}$ 从地址 $A$ 读取。\n    - 索引 $5$：加载指令 $L_{4}$ 从地址 $C$ 读取。\n    - 索引 $6$：存储指令 $S_{2}$ 写入地址 $D$。\n    - 索引 $7$：加载指令 $L_{5}$ 从地址 $E$ 读取。\n    - 索引 $8$：加载指令 $L_{6}$ 从地址 $F$ 读取。\n    - 索引 $9$：存储指令 $S_{3}$ 写入地址 $G$。\n    - 索引 $10$：加载指令 $L_{7}$ 从地址 $H$ 读取。\n    - 索引 $11$：加载指令 $L_{8}$ 从地址 $I$ 读取。\n    - 索引 $12$：存储指令 $S_{4}$ 写入地址 $J$。\n    - 索引 $13$：加载指令 $L_{9}$ 从地址 $K$ 读取。\n- **目标**：计算重放窗口 $W_{r}$，定义为必须被清除并重新发射的较新加载指令的数量。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题是有效的。\n- **科学依据**：所述场景是高性能乱序微处理器设计中的一个标准且基本的问题。诸如加载-存储队列（LSQ）、推测性内存消歧、存储到加载前递以及内存顺序冲突检测和恢复等概念是计算机体系结构的核心主题。“全局加载重放”策略是一种有效（尽管简单）的硬件恢复实现策略。\n- **定义明确**：问题定义清晰。它明确了要应用的恢复策略，并提供了预测错误检测瞬间 LSQ 相关部分的完整状态。问题要求基于这些精确条件计算一个单一的可计算整数值 $W_{r}$。\n- **目标**：问题使用计算机体系结构领域的精确技术术语陈述，没有主观或模糊的语言。\n\n该问题要求将陈述的规则直接应用于给定的数据集。它是自洽的、一致的且科学合理的。\n\n### 步骤 3：进行求解\n问题是有效的，将提供解决方案。\n\n问题的核心在于严格应用指定的内存依赖预测错误恢复策略。该策略被明确定义为**全局加载重放**。它规定：“……当违规的旧存储指令的地址解析并检测到冲突时，所有比该存储指令新且已执行其内存访问的加载指令都将被清除并重新发射。”\n\n让我们剖析这个策略，并将其应用于给定的 LSQ 状态。\n\n1.  **识别违规的存储指令**：问题将索引 $3$ 处的存储操作（表示为 $S_{1}$）识别为“违规的存储指令”。该指令在程序顺序中作为参考点。\n\n2.  **识别较新的指令**：该策略涉及“所有比该存储指令新的加载指令”。在维持程序顺序的 LSQ 上下文中，“较新”的指令是指索引更高的指令。因此，我们必须考虑所有索引大于 $3$ 的指令。这些是从索引 $4$ 到索引 $13$ 的指令。\n\n3.  **筛选加载指令**：该策略仅适用于“加载指令”。我们必须在已识别的较新指令窗口（索引 $4$ 到 $13$）中列举所有的`加载`操作。\n    - 索引 $4$：$L_{3}$ (加载)\n    - 索引 $5$：$L_{4}$ (加载)\n    - 索引 $6$：$S_{2}$ (存储) - 排除\n    - 索引 $7$：$L_{5}$ (加载)\n    - 索引 $8$：$L_{6}$ (加载)\n    - 索引 $9$：$S_{3}$ (存储) - 排除\n    - 索引 $10$：$L_{7}$ (加载)\n    - 索引 $11$：$L_{8}$ (加载)\n    - 索引 $12$：$S_{4}$ (存储) - 排除\n    - 索引 $13$：$L_{9}$ (加载)\n\n4.  **确认执行状态**：该策略适用于“已执行其内存访问”的加载指令。问题陈述明确确认了此条件：“在检测到冲突的瞬间，所有列出的加载指令都已经执行了其内存访问。”因此，上一步中识别的所有加载指令都满足此条件，必须被清除。\n\n5.  **计算重放窗口 $W_{r}$**：重放窗口 $W_{r}$ 是必须被清除并重新发射的加载指令的总数。根据步骤 3 中的列举，这些加载指令是 $L_{3}$、$L_{4}$、$L_{5}$、$L_{6}$、$L_{7}$、$L_{8}$ 和 $L_{9}$。\n\n计算这些加载指令的数量得出：\n$$W_{r} = 7$$\n\n加载指令 $L_{3}$ 是其推测执行不正确的具体指令（它从 $S_{0}$ 获得了前递值，而本应从 $S_{1}$ 接收新值）。然而，重放策略的“全局”性质意味着恢复操作不仅限于 $L_{3}$。所有在程序顺序上比违规存储指令 $S_{1}$ 年轻的其他加载指令也会被卷入重放，无论它们本身是否对 $S_{1}$ 有数据依赖。加载指令 $L_{1}$ 和 $L_{2}$ 比 $S_{1}$ 旧，因此不受影响。LSQ 深度 $D=16$ 是无关信息，因为占用率和状态已完全指定。", "answer": "$$\\boxed{7}$$", "id": "3664944"}, {"introduction": "了解了错误预测的代价后，理解处理器如何正确处理复杂的内存访问就变得至关重要。本练习模拟了一条跨越页边界的加载指令的执行过程，其所需数据部分来自存储队列，部分来自缓存。通过精确计算总执行延迟，您将能更深刻地体会到转译后备缓冲区（TLB）、缓存以及存储转发逻辑之间复杂的协同工作机制 [@problem_id:3657275]。", "problem": "一个超标量、乱序执行核心为单个硬件线程实现了一个带有存储队列的内存消歧机制。虚拟内存使用大小为 $P$ 字节的页面，其中 $P = 4096$。一个位于虚拟地址 $A$、宽度为 $w$ 字节的加载操作，当且仅当 $A \\bmod P > P - w$ 时，会跨越页面边界。考虑一个加载的动态实例，其宽度 $w = 16$ 且 $A \\bmod P = 4092$。因此该加载操作跨越了从 $A$ 到 $A + w - 1$ 的地址范围，覆盖了两个连续的虚拟页面，我们将其表示为页面 $p$ 和页面 $p + 1$。根据定义，在页面 $p$ 上访问的字节偏移量为 $4092, 4093, 4094, 4095$，在页面 $p+1$ 上访问的字节偏移量为 $0, 1, \\dots, 11$。\n\n存储队列中有四个较早的存储操作，它们的虚拟地址和大小已知，全部来自同一个线程，并按从旧到新的程序顺序排列如下：$S_3$、$S_1$、$S_4$、$S_2$。它们相对于该加载操作所触及的页面的虚拟地址偏移量和长度如下：\n- $S_3$：页面 $p$，地址偏移量 $4088$，长度 $4$ 字节，\n- $S_1$：页面 $p$，地址偏移量 $4094$，长度 $2$ 字节，\n- $S_4$：页面 $p+1$，地址偏移量 $0$，长度 $4$ 字节，\n- $S_2$：页面 $p+1$，地址偏移量 $8$，长度 $8$ 字节。\n\n内存消歧和数据供给规则如下：\n- 对于加载操作中被一个或多个较早存储操作覆盖的每个字节，其值将从覆盖该字节的最新存储操作中前递。如果一个加载操作总共需要从 $k$ 个不同的较早存储操作中前递数据，合并这些前递的数据片会产生额外的 $k$ 个周期的延迟。\n- 对于加载操作需要从一级数据缓存 (L1) 中获取任何字节的每个页面，访问延迟为 $L_c = 4$ 个周期，且每个这样的页面只需支付一次。如果某个页面的所有字节都从存储队列中前递，则对该页面的一级数据缓存 (L1) 访问将被抑制，不产生任何延迟。\n- 转译后备缓冲区 (TLB) 行为：数据侧转译后备缓冲区 (TLB) 只有一个查找端口，并且必须在访问该页面的一级数据缓存 (L1) 之前为其提供地址翻译。一个页面的 TLB 命中需要 $t_h = 1$ 个周期；一个页面的 TLB 未命中需要 $t_m = 13$ 个周期（这是为该页面生成翻译所需的总时间）。如果一个页面的数据完全由存储前递满足，其 TLB 查找将被推迟到退役阶段，并且不会计入此加载操作的执行延迟。\n- 如果此加载操作的执行需要对两个页面进行查找，这些查找将通过单个 TLB 端口串行化，其延迟会相加。如果需要访问两个页面的一级数据缓存 (L1)，其访问延迟也会相加。前递字节的合并延迟在转译后备缓冲区 (TLB) 和一级数据缓存 (L1) 延迟之后相加。对于本问题，假设这些组件之间在时间上没有重叠。\n\n假设此动态实例发生以下事件：\n- 页面 $p$ 的 TLB 查找命中。\n- 页面 $p+1$ 的 TLB 查找未命中。\n- 任何所需的一级数据缓存 (L1) 访问都在缓存中命中。\n\n从内存消歧的范围交集基本定义和给定的执行规则出发，确定此加载操作的总执行延迟（以周期为单位），包括由两个页面上的部分重叠决定的 TLB、一级数据缓存 (L1) 和存储前递合并成本。报告一个等于总周期数的实数值。在最终的方框答案中不要包含单位。", "solution": "问题陈述经评估有效。它在科学上基于计算机体系结构的原理，特别是乱序执行和内存消歧。该问题定义明确，提供了一套自洽且一致的规则和数据，从而可以推导出唯一且有意义的解决方案。所有术语都得到了清晰的定义，并且在所建立的假设处理器模型中，其前提在事实上是合理的。\n\n任务是计算特定加载指令的总执行延迟。根据问题定义，此延迟是三个组成部分的总和：转译后备缓冲区 (TLB) 延迟、一级 (L1) 数据缓存访问延迟以及存储前递合并延迟。我们将分析受影响的两个虚拟页面上的内存访问，以确定每个延迟分量的贡献。\n\n首先，我们确定加载和存储操作的地址范围。\n页面大小为 $P = 4096$ 字节。\n加载操作宽度为 $w = 16$ 字节，起始于虚拟地址 $A$，满足 $A \\bmod P = 4092$。\n加载操作访问从地址 $A$ 到 $A + w - 1 = A + 15$ 的字节。\n此访问跨越两个页面，我们将其表示为 $p$ 和 $p+1$。\n- 在页面 $p$ 上，加载操作访问偏移量为 $[4092, 4095]$ 的字节。总共 $4$ 字节。\n- 在页面 $p+1$ 上，加载操作访问偏移量为 $[0, 11]$ 的字节。总共 $12$ 字节。\n总字节数为 $4 + 12 = 16$，与加载宽度 $w$ 一致。\n\n四个较早的存储操作按程序顺序（从旧到新）为 $S_3, S_1, S_4, S_2$。它们的地址范围是：\n- $S_3$：页面 $p$，偏移量 $4088$，长度 $4$。偏移量范围：$[4088, 4091]$。\n- $S_1$：页面 $p$，偏移量 $4094$，长度 $2$。偏移量范围：$[4094, 4095]$。\n- $S_4$：页面 $p+1$，偏移量 $0$，长度 $4$。偏移量范围：$[0, 3]$。\n- $S_2$：页面 $p+1$，偏移量 $8$，长度 $8$。偏移量范围：$[8, 15]$。\n\n现在，我们分析每个页面的数据来源。\n\n**页面 $p$ 的分析**\n加载操作需要从页面 $p$ 获取偏移量为 $[4092, 4095]$ 的字节。我们检查此页面上与较早存储操作的重叠情况。\n- 存储 $S_3$ 占据偏移量 $[4088, 4091]$。与加载范围 $[4092, 4095]$ 的交集为空：$[4092, 4095] \\cap [4088, 4091] = \\emptyset$。\n- 存储 $S_1$ 占据偏移量 $[4094, 4095]$。与加载范围的交集为 $[4092, 4095] \\cap [4094, 4095] = [4094, 4095]$。\n根据存储前递规则，偏移量为 $4094$ 和 $4095$ 的字节的值将从存储 $S_1$ 前递。\n偏移量为 $4092$ 和 $4093$ 的字节未被存储队列中任何较早的存储操作覆盖。因此，这些字节必须从内存层次结构中获取，具体来说是一级数据缓存。\n由于页面 $p$ 的所有字节并非都由存储前递完全满足，因此对页面 $p$ 的 L1 缓存访问和之前的 TLB 查找是必需的。\n\n**页面 $p+1$ 的分析**\n加载操作需要从页面 $p+1$ 获取偏移量为 $[0, 11]$ 的字节。我们检查此页面上与较早存储操作的重叠情况。\n- 存储 $S_4$ 占据偏移量 $[0, 3]$。与加载范围的交集为 $[0, 11] \\cap [0, 3] = [0, 3]$。\n- 存储 $S_2$ 占据偏移量 $[8, 15]$。与加载范围的交集为 $[0, 11] \\cap [8, 15] = [8, 11]$。\n程序顺序是 $S_4$ 在前，$S_2$ 在后（即 $S_2$ 更新）。受影响的字节范围 $[0, 3]$ 和 $[8, 11]$ 是不相交的，因此不存在一个字节被多个存储操作覆盖的冲突。\n- 偏移量为 $[0, 3]$ 的字节将从存储 $S_4$ 前递。\n- 偏移量为 $[8, 11]$ 的字节将从存储 $S_2$ 前递。\n偏移量为 $[4, 7]$ 的字节未被任何较早的存储操作覆盖。这些字节必须从一级数据缓存中获取。\n由于页面 $p+1$ 的所有字节并非都由存储前递完全满足，因此对页面 $p+1$ 的 L1 缓存访问和之前的 TLB 查找也是必需的。\n\n基于此分析，我们可以计算总延迟。\n\n**1. 总 TLB 延迟**\n页面 $p$ 和页面 $p+1$ 都需要进行 TLB 查找。这些查找是串行化的。\n- 页面 $p$ 的查找命中，耗时 $t_h = 1$ 个周期。\n- 页面 $p+1$ 的查找未命中，耗时 $t_m = 13$ 个周期。\n总 TLB 延迟 = $t_h + t_m = 1 + 13 = 14$ 个周期。\n\n**2. 总 L1 数据缓存延迟**\n页面 $p$ 和页面 $p+1$ 都需要进行 L1 缓存访问。问题陈述这些访问在缓存中命中，并且它们的延迟相加。\n- 访问页面 $p$ 产生 $L_c = 4$ 个周期的延迟。\n- 访问页面 $p+1$ 产生 $L_c = 4$ 个周期的延迟。\n总 L1 缓存延迟 = $L_c + L_c = 4 + 4 = 8$ 个周期。\n\n**3. 存储前递合并延迟**\n合并延迟为 $k$ 个周期，其中 $k$ 是加载操作从中前递数据的不同较早存储操作的总数。\n- 从页面 $p$，数据从存储 $S_1$ 前递。\n- 从页面 $p+1$，数据从存储 $S_4$ 和 $S_2$ 前递。\n不同的前递存储操作集合为 $\\{S_1, S_2, S_4\\}$。\n不同存储操作的数量为 $k = 3$。\n存储前递合并延迟 = $k = 3$ 个周期。\n\n**4. 总执行延迟**\n总延迟是各非重叠部分的总和。\n总延迟 = (总 TLB 延迟) + (总 L1 缓存延迟) + (存储前递合并延迟)\n总延迟 = $14 + 8 + 3 = 25$ 个周期。\n\n此加载操作的总执行延迟为 $25$ 个周期。", "answer": "$$\\boxed{25}$$", "id": "3657275"}, {"introduction": "为了避免代价高昂的流水线冲刷和指令重放，现代处理器采用内存依赖性预测器来提前判断加载和存储指令之间是否存在别名。本练习将视角转向了此类预测器的硬件实现层面。您将分析一个具体的预测器设计方案，并计算其所需的总存储位数，从而学习像硬件设计者一样，在预测能力和芯片物理资源之间进行权衡 [@problem_id:3657211]。", "problem": "一个微架构使用乱序 (OoO) 执行，并带有一个内存依赖性预测器，该预测器对加载和存储指令进行内存消歧。当观察到一条加载指令 (表示为 $L$) 与一条较早的存储指令 (表示为 $S$) 发生冲突，其程序顺序距离为 $d$（在 $L$ 发出时，$S$ 和 $L$ 之间较早的在途存储指令的数量）时，预测器会更新 $L$ 的相关状态，以便在未来的执行中，它会保守地将 $L$ 视为依赖于距离 $d$ 内所有较早的存储指令。为了跨动态上下文关联依赖行为，对于每个静态加载指令的程序计数器 (PC)，预测器会为每条加载指令维护一个包含最近 $H$ 次观察到的冲突距离的循环历史记录，并将该窗口内的最大值预测为下一个依赖距离。为了在硬件中支持此行为，预测器必须存储这 $H$ 个距离本身。\n\n该预测器实现为一个具有 $E$ 个条目的直接映射表，通过加载指令 PC $PC_L$ 的低位进行寻址。每个条目包含：一个有效位、一个由未用于索引表的高位 PC 位组成的标签、一个 $c$ 位的饱和置信度计数器，以及该加载指令的 $H$ 个最近的冲突距离。该机器有一个容量为 $Q$ 个条目的存储队列 (SQ)；因此任何冲突距离 $d$ 都在集合 $\\{1,\\dots,Q\\}$ 中。为了能够表示历史记录位置中尚未观察到冲突的情况，该设计使用一个额外的代码来编码距离，因此距离字段必须能编码 $Q+1$ 个不同的值。地址宽度为 $A$ 位。\n\n假设具体参数如下：$A = 48$，$E = 512$，$Q = 56$，$c = 2$。标签存储 $PC_L$ 的高 $A - \\log_{2}(E)$ 位，并且由于该表是直接映射的，除了有效位之外没有替换元数据。推导整个预测器表所需总存储容量的精确闭式表达式（以比特为单位），该表达式是历史长度 $H$ 的函数。将最终答案表示为关于 $H$ 的单个闭式表达式，不带单位。无需四舍五入。", "solution": "用户希望我扮演一位严谨苛刻的STEM领域教授。我必须首先验证问题陈述，如果有效，再提供解决方案。\n\n### 第 1 步：问题验证\n\n**1. 提取已知条件：**\n- 预测器类型：具有 $E$ 个条目的直接映射表。\n- 表索引：加载程序计数器 ($PC_L$) 的低位。\n- 地址宽度：$A = 48$ 位。\n- 条目数：$E = 512$。\n- 存储队列容量：$Q = 56$。\n- 冲突距离范围：$d \\in \\{1, 2, \\dots, Q\\}$。\n- 距离编码所需值的数量：$Q+1$（包括一个表示无冲突的代码）。\n- 每个条目的组成部分：\n    - 一个有效位。\n    - 一个标签：$PC_L$ 的高 $A - \\log_2(E)$ 位。\n    - 一个置信度计数器：$c$ 位饱和计数器，$c = 2$。\n    - 一个距离历史记录：$H$ 个最近的冲突距离。\n- 替换策略：除了直接映射结构的有效位外，未指定其他策略。\n\n**2. 使用提取的已知条件进行验证：**\n- **科学依据**：该问题描述了一个内存依赖性预测器，这是高性能计算机架构中的一个标准组件。所使用的所有概念（直接映射表、程序计数器、标签、存储队列、乱序执行）都是计算机组成和体系结构的基础。该设计是合理的。\n- **问题定义明确**：该问题要求计算一个硬件结构的总存储容量（以比特为单位）。它提供了计算该结构大小所需的所有必要参数和定义。可以推导出一个唯一的、精确的解。\n- **客观性**：问题陈述使用了精确的技术语言，没有主观或模棱两可的术语。\n- **一致性**：问题陈述是自洽且内部一致的。例如，它明确给出了标签大小为 $A - \\log_2(E)$，这与一个由 $A$ 位地址索引的 $E$ 个条目的直接映射表的描述是一致的。\n- **可行性**：给定的参数（$A=48$, $E=512$, $Q=56$, $c=2$）对于现代处理器设计是现实的。\n\n**3. 结论与行动：**\n该问题是有效的。这是一个在计算机体系结构领域定义明确、具有科学依据的问题。我将继续进行解答。\n\n### 第 2 步：求解过程\n\n预测器表的总存储容量，记为 $S_{total}$，是条目数 $E$ 与单个条目大小 $S_{entry}$ 的乘积。\n$$S_{total} = E \\times S_{entry}$$\n表中的单个条目由四个不同的字段组成：一个有效位、一个标签、一个置信度计数器和用于存储 $H$ 个冲突距离的空间。一个条目的大小是这些字段大小的总和：\n$$S_{entry} = S_{valid} + S_{tag} + S_{confidence} + S_{distances}$$\n我们现在将确定每个组件的大小（以比特为单位）。\n\n1.  **有效位的大小 ($S_{valid}$)**：该条目包含一个有效位。\n    $$S_{valid} = 1$$\n\n2.  **标签的大小 ($S_{tag}$)**：问题陈述指出，标签存储 $A$ 位程序计数器 ($PC_L$) 中未用于索引表的高位。该表有 $E$ 个条目并且是直接映射的，因此索引所需的位数是 $\\log_2(E)$。问题明确给出了标签的大小为：\n    $$S_{tag} = A - \\log_2(E)$$\n    代入给定值 $A=48$ 和 $E=512$：\n    $$\\log_2(E) = \\log_2(512) = \\log_2(2^9) = 9$$\n    $$S_{tag} = 48 - 9 = 39 \\text{ 比特}$$\n\n3.  **置信度计数器的大小 ($S_{confidence}$)**：问题指定了一个 $c$ 位的饱和计数器，参数 $c=2$。\n    $$S_{confidence} = c = 2 \\text{ 比特}$$\n\n4.  **距离历史记录的大小 ($S_{distances}$)**：每个条目存储 $H$ 个冲突距离。首先，我们必须确定存储单个距离值所需的比特数，我们将其记为 $S_{dist\\_field}$。冲突距离 $d$ 是范围在 $[1, Q]$ 内的整数。问题陈述指出，使用一个额外的代码来表示未发生冲突的情况。因此，单个距离的字段必须能够编码 $Q+1$ 个不同的值。表示 $N$ 个值所需的比特数是 $\\lceil\\log_2(N)\\rceil$。\n    对于我们的情况，$N = Q+1$ 且 $Q=56$：\n    $$S_{dist\\_field} = \\lceil \\log_2(Q+1) \\rceil = \\lceil \\log_2(56+1) \\rceil = \\lceil \\log_2(57) \\rceil$$\n    为了计算该值，我们观察到 $2^5 = 32$ 且 $2^6 = 64$。因为 $32  57  64$，所以 $5  \\log_2(57)  6$。该值的向上取整是：\n    $$S_{dist\\_field} = 6 \\text{ 比特}$$\n    一个条目中存储 $H$ 个距离所需的总空间是 $H$ 与单个距离字段大小的乘积：\n    $$S_{distances} = H \\times S_{dist\\_field} = H \\times 6 = 6H \\text{ 比特}$$\n\n现在，我们可以通过将各组件的大小相加来计算单个条目的总大小 $S_{entry}$：\n$$S_{entry} = S_{valid} + S_{tag} + S_{confidence} + S_{distances} = 1 + 39 + 2 + 6H$$\n$$S_{entry} = 42 + 6H \\text{ 比特}$$\n\n最后，整个预测器表的总存储容量 $S_{total}$，可以通过将单个条目的大小乘以总条目数 $E=512$ 来得到。\n$$S_{total}(H) = E \\times S_{entry} = 512 \\times (42 + 6H)$$\n展开此表达式，得到最终的关于 $H$ 的闭式方程：\n$$S_{total}(H) = 512 \\times 42 + 512 \\times 6H$$\n$$S_{total}(H) = 21504 + 3072H$$\n该表达式给出了预测器表的总存储容量（以比特为单位）。", "answer": "$$\n\\boxed{21504 + 3072H}\n$$", "id": "3657211"}]}