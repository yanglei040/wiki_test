{"hands_on_practices": [{"introduction": "拥有多个功能单元并不总能保证并行执行。这个练习使用一个精心设计的指令序列，来揭示数据依赖链如何完全串行化流水线，迫使指令顺序执行，即使硬件资源充足。通过这个练习，你将深入理解为何简单的乱序执行机制有时会受限于代码本身的结构 [@problem_id:3638642]。", "problem": "考虑一个经典的、基于记分板的动态调度处理器，其风格类似于 CDC 6600。记分板为每条指令实现了以下四个生命周期阶段：发射 (Issue)、读操作数 (Read Operands)、执行 (Execute) 和写结果 (Write Result)。规则如下：\n\n- 发射 (Issue)：仅当有合适的功能单元空闲，并且其目标寄存器上不存在写后写 (WAW) 冒险时，指令才能按程序顺序发射。\n- 读操作数 (Read Operands)：当指令的两个源寄存器都被标记为就绪（没有待处理的生产者），并且所有 RAW 约束都得到满足时，指令可以读取其源寄存器。\n- 执行 (Execute)：指令会占用其功能单元，持续时间为该操作特定的固定延迟。\n- 写结果 (Write Result)：当与任何尚未读取其操作数的更早指令不存在写后读 (WAR) 冒险时，指令可以写入其目标寄存器。\n\n假设该机器有两个相同的整数加法器。每条加法指令使用一个加法器，执行延迟为 $3$ 个周期。发射阶段、读操作数阶段和写结果阶段各需要 $1$ 个周期。每个周期只能发射一条指令。功能单元在发射阶段被分配，并一直被占用直到写结果阶段完成。在周期 $t$ 的写结果阶段结束时，功能单元在周期 $t+1$ 变得可用于发射。所有初始寄存器值在周期 $0$ 时均可用。\n\n考虑以下三条按程序顺序排列的整数加法指令，其数据流是明确的：\n\n- 指令 $I_1: R_1 \\leftarrow R_2 + R_3$，\n- 指令 $I_2: R_2 \\leftarrow R_1 + R_4$，\n- 指令 $I_3: R_3 \\leftarrow R_2 + R_5$，\n\n其中 $R_2$、$R_3$、$R_4$ 和 $R_5$ 在周期 $0$ 时已就绪，并具有有效的初始值。\n\n仅根据上述记分板规则以及写后读 (RAW)、读后写 (WAR) 和写后写 (WAW) 冒险的语义，推断对于此指令序列，执行阶段是否存在任何并行性，并确定在给定的延迟和资源约束下，所有三条指令的最小完成时间（即最后一条指令的写结果阶段完成的周期）。以周期为单位表示最终时间。无需四舍五入。", "solution": "该问题陈述经证实具有科学依据、问题明确、客观且内部一致。它描述了计算机体系结构中的一个经典场景，可以使用所提供的规则进行形式化分析。其中没有歧义或矛盾。\n\n该问题要求确定在一个基于记分板的处理器上，一个包含三条指令的序列在执行阶段是否可能存在并行性，并找出最小完成时间。该分析需要对处理器的状态进行逐步模拟，该模拟受记分板规则的支配，并受到数据依赖和资源可用性的约束。\n\n首先，我们识别指令之间的数据依赖关系：\n- $I_1: R_1 \\leftarrow R_2 + R_3$\n- $I_2: R_2 \\leftarrow R_1 + R_4$\n- $I_3: R_3 \\leftarrow R_2 + R_5$\n\n1.  **写后读 (RAW) 或真数据依赖**：一条指令必须等待其源操作数由前一条指令产生。\n    - $I_2$ 读取 $I_1$ 写入的 $R_1$。这产生了一个 RAW 依赖，表示为 $I_1 \\xrightarrow{\\text{RAW}} I_2$。$I_2$ 在 $I_1$ 完成其写结果阶段之前无法读取其操作数。\n    - $I_3$ 读取 $I_2$ 写入的 $R_2$。这产生了一个 RAW 依赖，$I_2 \\xrightarrow{\\text{RAW}} I_3$。$I_3$ 在 $I_2$ 完成其写结果阶段之前无法读取其操作数。\n    这些依赖关系形成了一个链：$I_1 \\rightarrow I_2 \\rightarrow I_3$。\n\n2.  **读后写 (WAR) 或反依赖**：一条指令不能在先前的指令从同一寄存器读取之前写入其目标寄存器。\n    - $I_2$ 写入 $R_2$，而 $I_1$ 读取 $R_2$。这产生了一个 WAR 依赖，$I_1 \\xrightarrow{\\text{WAR}} I_2$。$I_2$ 在 $I_1$ 读取其操作数之前不能写入其结果。\n    - $I_3$ 写入 $R_3$，而 $I_1$ 读取 $R_3$。这产生了一个 WAR 依赖，$I_1 \\xrightarrow{\\text{WAR}} I_3$。$I_3$ 在 $I_1$ 读取其操作数之前不能写入其结果。\n    记分板通过延迟写入指令（$I_2$、$I_3$）的写结果阶段，直到读取指令（$I_1$）完成其读操作数阶段，来处理这些冒险。\n\n3.  **写后写 (WAW) 或输出依赖**：一条指令不能在先前的指令写入同一目标寄存器之前写入该寄存器。\n    - 指令 $I_1$、$I_2$ 和 $I_3$ 分别写入不同的寄存器（$R_1$、$R_2$、$R_3$）。因此，它们之间没有 WAW 冒险。相对于此序列中的其他指令，发射阶段可以继续进行而不会因 WAW 停顿。\n\n处理器有两个相同的整数加法器，我们称之为 $FU_1$ 和 $FU_2$。每个阶段（发射、读操作数、写结果）需要 $1$ 个周期。加法操作的执行阶段需要 $3$ 个周期。功能单元从其发射的周期开始被占用，直到其写结果阶段完成的周期结束。\n\n我们可以构建一个时序图来跟踪每条指令通过四个流水线阶段的进度：发射 ($I$)、读操作数 ($RO$)、执行 ($EX$) 和写结果 ($WR$)。表中的数字代表每个阶段完成的周期号。$EX$ 阶段的持续时间由它占用的周期范围表示。\n\n| 指令 | 阶段 $I$ | 阶段 $RO$ | 阶段 $EX$ | 阶段 $WR$ | FU | 注释 |\n|----------------|-----------|------------|----------------|------------|-------|----------|\n| $I_1: R_1 \\leftarrow R_2 + R_3$ | $1$ | $2$ | $3, 4, 5$ | $6$ | $FU_1$ | 在周期 1 发射。$R_2, R_3$ 已就绪，因此 RO 在周期 2。 |\n| $I_2: R_2 \\leftarrow R_1 + R_4$ | $2$ | $7$ | $8, 9, 10$ | $11$ | $FU_2$ | 在周期 2 发射。因对 $R_1$ 的 RAW 依赖而停顿。$I_1$ 的 WR 在周期 6 完成，因此 $I_2$ 的 RO 在周期 7 开始。 |\n| $I_3: R_3 \\leftarrow R_2 + R_5$ | $7$ | $12$ | $13, 14, 15$ | $16$ | $FU_1$ | 因 FU 占用而停顿。$FU_1$ 在周期 7 空闲。因对 $R_2$ 的 RAW 依赖而停顿。$I_2$ 的 WR 在周期 11 完成，因此 $I_3$ 的 RO 在周期 12 开始。 |\n\n**逐周期分析：**\n\n- **周期 1**：$I_1$ 发射，因为 $FU_1$ 空闲且没有 WAW 冒险。$FU_1$ 分配给 $I_1$。\n- **周期 2**：$I_1$ 进入读操作数 ($RO$) 阶段。其源寄存器 $R_2$ 和 $R_3$ 在周期 0 时已就绪。$I_1$ 完成 $RO$。同时，$I_2$ 发射，因为 $FU_2$ 空闲。$FU_2$ 分配给 $I_2$。$I_3$ 无法发射，因为每个周期只能发射一条指令。\n- **周期 3**：$I_1$ 开始其为期 3 个周期的执行。它将占用 $FU_1$ 三个周期：$3, 4, 5$。$I_2$ 尝试进入其 $RO$ 阶段，但因其源寄存器 $R_1$ 尚不可用（正由 $I_1$ 产生）而停顿。$I_3$ 无法发射，因为两个功能单元都已被分配。\n- **周期 4, 5**：$I_1$ 继续执行。$I_2$ 继续在 $RO$ 阶段停顿。$I_3$ 继续在发射阶段停顿。\n- **周期 6**：$I_1$ 完成执行并进入写结果 ($WR$) 阶段。它写入 $R_1$。WAR 冒险检查 ($I_1 \\xrightarrow{\\text{WAR}} I_2, I_3$) 没有影响，因为 $I_1$ 是第一条指令。$R_1$ 在该周期结束时变为可用。$I_2$ 仍在等待 $R_1$。$I_3$ 仍在等待空闲的 FU。\n- **周期 7**：$I_1$ 完成。$FU_1$ 对新指令可用（因为 $I_1$ 的 $WR$ 在周期 $t=6$ 完成，所以 FU 在 $t+1=7$ 时空闲）。$I_3$ 现在发射，占用 $FU_1$。同时，$I_2$ 检测到 $R_1$ 已就绪，并继续其 $RO$ 阶段，该阶段在本周期完成。\n- **周期 8**：$I_2$ 在 $FU_2$ 中开始其为期 3 个周期的执行（周期 $8, 9, 10$）。$I_3$ 尝试进入其 $RO$ 阶段，但因等待 $I_2$ 产生的 $R_2$ 而停顿。\n- **周期 9, 10**：$I_2$ 继续执行。$I_3$ 继续在 $RO$ 阶段停顿。\n- **周期 11**：$I_2$ 完成执行并进入 $WR$ 阶段。它写入 $R_2$。WAR 冒险检查 ($I_1 \\xrightarrow{\\text{WAR}} I_2$) 通过，因为 $I_1$ 在周期 2 完成了其 $RO$ 阶段。$R_2$ 在该周期结束时变为可用。\n- **周期 12**：$I_2$ 完成。$I_3$ 检测到 $R_2$ 已就绪，并继续其 $RO$ 阶段。\n- **周期 13, 14, 15**：$I_3$ 处于 $EX$ 阶段，使用 $FU_1$。\n- **周期 16**：$I_3$ 完成执行并进入 $WR$ 阶段。WAR 冒险检查 ($I_1 \\xrightarrow{\\text{WAR}} I_3$) 通过，因为 $I_1$ 在周期 2 完成了其 $RO$ 阶段。它写入 $R_3$ 并完成。\n\n**关于并行性和完成时间的结论：**\n\n这三条指令的执行阶段发生在以下周期区间：\n- $I_{1, EX}$：周期 $3-5$\n- $I_{2, EX}$：周期 $8-10$\n- $I_{3, EX}$：周期 $13-15$\n\n这些区间是不相交的。因此，**在执行阶段没有实现并行性**。强大的 RAW 依赖链 ($I_1 \\xrightarrow{\\text{RAW}} I_2 \\xrightarrow{\\text{RAW}} I_3$) 使执行串行化，尽管有两个可用的功能单元，指令仍被迫一个接一个地进行。\n\n最后一条指令 $I_3$ 在周期 16 结束时完成其写结果阶段。因此，所有三条指令的最小完成时间是 $16$ 个周期。", "answer": "$$ \\boxed{16} $$", "id": "3638642"}, {"introduction": "在理解了依赖关系对性能的宏观影响之后，现在是时候深入了解记分板的底层工作机制了。这个练习要求你对一个给定的程序进行细致的逐周期模拟。你将扮演处理器控制逻辑的角色，在每个周期中决策指令的发射、操作数读取、执行和结果写回，并在此过程中准确地识别和处理读后写（RAW）、写后读（WAR）和写后写（WAW）等数据冒险 [@problem_id:3638650]。", "problem": "考虑一个玩具指令集架构（ISA），它具有三地址整数指令和一个经典的基于 scoreboard 的动态调度器。该机器支持乱序执行，但受 scoreboard 的冒险和阶段规则的约束。ISA 和微架构规则如下。\n\n- 指令集架构（ISA）：指令格式为 $\\mathrm{OP}\\;R_{d}, R_{s1}, R_{s2}$，其语义为 $R_{d} \\leftarrow R_{s1}\\;\\mathrm{OP}\\;R_{s2}$。支持的操作和延迟如下：\n  - 在整数算术逻辑单元（ALU）上执行的 $\\mathrm{ADD}$：延迟 $L_{A} = 2$ 个周期。\n  - 在乘法器上执行的 $\\mathrm{MUL}$：延迟 $L_{M} = 5$ 个周期。\n  - 在加载单元上执行的 $\\mathrm{LD}$：格式为 $\\mathrm{LD}\\;R_{d}, [R_{s1}]$，延迟 $L_{L} = 3$ 个周期。假设地址通过使用 $R_{s1}$ 中的值形成；不存在存储体冲突。\n\n- 微架构和 Scoreboard：\n  - 功能单元（FU）：$2$ 个 ALU，$1$ 个乘法器，$1$ 个加载单元。每个 FU 一次最多只能执行一条指令；FU 在发射阶段被预留，并在写回结果阶段后释放。\n  - 每条指令的流水线阶段：发射 $\\rightarrow$ 读操作数 $\\rightarrow$ 执行 $\\rightarrow$ 写回结果。发射和读操作数各占 $1$ 个周期；执行根据操作类型需要 $L$ 个周期；写回结果占 $1$ 个周期。\n  - 周期内的阶段顺序：首先执行所有符合条件的写回结果操作，然后执行所有符合条件的读操作数操作，最后执行最多一条指令的单次发射。读操作数阶段的操作数就绪状态在周期开始时评估，早于该周期内的任何写操作；在周期 $t$ 写入的值最早在周期 $t+1$ 才能被读取。\n  - 由 scoreboard 强制执行的冒险：\n    - 写后写（WAW）：在发射阶段，如果任何活跃（已发射但尚未完成）指令的目标寄存器与传入指令的目标寄存器相同，则停顿。\n    - 写后读（RAW）：在读操作数阶段停顿，直到每个源寄存器都就绪（即，其最后一个更早的写入者已完成写回结果）。\n    - 读后写（WAR）：在写回结果阶段停顿，如果任何更早的活跃指令尚未执行读操作数阶段，并且该指令使用写入者的目标寄存器作为其源之一。\n  - 结果总线：只有一个全局写端口；每个周期最多只能发生一次写回结果。如果有多条指令在同一周期准备好写回，除一条外，其他所有指令都将发生结构性停顿。对于下面的问题，写端口上的这些结构性停顿不得计入 WAW 或 WAR 停顿。\n\n- 初始条件：在周期 $1$ 时，所有架构寄存器 $R_{0}, R_{1}, \\dots$ 都具有有效的初始值（即，它们被视为就绪），除了那些将由程序本身定义的寄存器。没有缓存未命中或超出 $L_{L}$ 的额外内存延迟，也没有分支指令。\n\n要执行的程序（按程序顺序，指令标识符为 $I_{1}$ 到 $I_{5}$）：\n1. $I_{1}: \\mathrm{LD}\\;R_{9}, [R_{10}]$\n2. $I_{2}: \\mathrm{ADD}\\;R_{7}, R_{5}, R_{9}$\n3. $I_{3}: \\mathrm{ADD}\\;R_{5}, R_{1}, R_{2}$\n4. $I_{4}: \\mathrm{MUL}\\;R_{5}, R_{3}, R_{4}$\n5. $I_{5}: \\mathrm{ADD}\\;R_{8}, R_{5}, R_{6}$\n\n注：\n- 两条指令 $I_{3}$ 和 $I_{4}$ 都写入 $R_{5}$，造成了目标寄存器别名。\n- 指令 $I_{2}$ 读取 $R_{5}$，但必须等待来自 $I_{1}$ 的 $R_{9}$，这与后续指令尝试写入 $R_{5}$ 时的 WAR 约束相互作用。\n- 按照规则允许的尽可能积极地调度执行，以最小化总时间：每个阶段都应在 scoreboard 约束和 FU 可用性允许的最早周期发生。\n\n任务：\n在上述模型下，计算完整执行 $I_{1}$ 到 $I_{5}$ 期间，完全由写后写（WAW）和读后写（WAR）冒险导致的总停顿周期数。不要计算由写后读（RAW）冒险或结构性约束（如单一写端口或 FU 可用性）引起的停顿周期。将最终答案表示为单个整数。无需四舍五入。", "solution": "用户希望我确定在一个基于 scoreboard 的处理器上，给定代码序列因写后写（WAW）和读后写（WAR）冒险而产生的总停顿周期数。\n\n### 步骤 1：问题验证\n\n**1. 提取已知条件：**\n*   **指令集和延迟：**\n    *   $\\mathrm{OP}\\;R_{d}, R_{s1}, R_{s2}$，语义为 $R_{d} \\leftarrow R_{s1}\\;\\mathrm{OP}\\;R_{s2}$。\n    *   $\\mathrm{ADD}$：延迟 $L_{A} = 2$ 个周期。\n    *   $\\mathrm{MUL}$：延迟 $L_{M} = 5$ 个周期。\n    *   $\\mathrm{LD}\\;R_{d}, [R_{s1}]$：延迟 $L_{L} = 3$ 个周期。\n*   **微架构：**\n    *   功能单元（FU）：$2$ 个 ALU，$1$ 个乘法器，$1$ 个加载单元。FU 从发射到写回结果期间一直繁忙。\n    *   流水线阶段：发射（$1$ 周期），读操作数（$1$ 周期），执行（$L$ 周期），写回结果（$1$ 周期）。\n    *   周期内阶段顺序：1. 写回结果, 2. 读操作数, 3. 发射。\n    *   操作数前推：在周期 $t$ 写入的结果在周期 $t+1$ 可用于读操作数。\n    *   写端口：单个写端口，每周期最多允许一次写回结果。\n*   **冒险规则：**\n    *   **WAW（写后写）：** 如果有活跃指令具有相同的目标寄存器，则在发射阶段停顿。\n    *   **RAW（写后读）：** 在读操作数阶段停顿，直到源寄存器就绪。\n    *   **WAR（读后写）：** 如果有更早的活跃指令尚未使用其操作数，且该指令使用写入者的目标寄存器作为其源，则在写回结果阶段停顿。\n*   **初始条件：**\n    *   除程序定义的寄存器外，所有寄存器在周期 1 均就绪。\n*   **程序序列：**\n    1.  $I_{1}: \\mathrm{LD}\\;R_{9}, [R_{10}]$\n    2.  $I_{2}: \\mathrm{ADD}\\;R_{7}, R_{5}, R_{9}$\n    3.  $I_{3}: \\mathrm{ADD}\\;R_{5}, R_{1}, R_{2}$\n    4.  $I_{4}: \\mathrm{MUL}\\;R_{5}, R_{3}, R_{4}$\n    5.  $I_{5}: \\mathrm{ADD}\\;R_{8}, R_{5}, R_{6}$\n\n**2. 使用提取的已知条件进行验证：**\n*   **科学基础：** 该问题是计算机体系结构中的一个经典练习，基于 scoreboard 动态调度的成熟原理。所有规则和概念都是该领域的标准。\n*   **良构性：** 问题提供了一套完整且确定性的规则、延迟和程序序列。目标是计算一个具体的、可验证的量。存在唯一解。\n*   **客观性：** 问题以精确、正式的语言陈述，没有任何主观或模棱两可的术语。\n*   **完整性和一致性：** 所有必要的参数（延迟、FU 数量、冒险规则）都已指定。规则内部一致，允许对处理器的执行进行逐步模拟。\n*   **其他缺陷：** 该问题并非无关紧要、隐喻性或超出科学分析范围。它直接探讨了动态调度的主题。\n\n**3. 结论和行动：**\n该问题是有效且良构的。我将进行详细的逐周期模拟来解决它。\n\n### 步骤 2：逐周期执行分析\n\n为确定停顿周期数，我们将构建一个流水线时序图。每条指令依次通过以下阶段：发射（I）、读操作数（RO）、执行（E）和写回结果（WR）。停顿用“(S)”表示。延迟为 $L$ 的指令的执行阶段需要 $L$ 个周期，在第 $L$ 个周期结束时完成。请注意，问题要求只计算 WAW 和 WAR 停顿。\n\n**指令依赖关系：**\n*   $I_2$ 对 $I_1$ 的寄存器 $R_9$ 存在 RAW 依赖。\n*   $I_3$ 对 $I_2$ 的寄存器 $R_5$ 存在 WAR 依赖（$I_2$ 在 $I_3$ 写入 $R_5$ 之前读取它）。\n*   $I_4$ 对 $I_3$ 的寄存器 $R_5$ 存在 WAW 依赖。\n*   $I_5$ 对 $I_4$ 的寄存器 $R_5$ 存在 RAW 依赖。\n\n**时间线：**\n*   **周期 1：** $I_1$ 发射（加载 FU 被占用）。\n*   **周期 2：** $I_1$ 读取操作数。$I_2$ 发射（ALU1 被占用）。\n*   **周期 3：** $I_1$ 开始执行（3个周期中的第1个周期）。$I_2$ 在 RO 阶段停顿（因 $R_9$ 存在 RAW 冒险，该值尚未由 $I_1$ 写入）。$I_3$ 发射（ALU2 被占用）。\n*   **周期 4：** $I_1$ 执行（3个周期中的第2个周期）。$I_2$ 仍然停顿（因 $R_9$ 存在 RAW）。$I_3$ 读取操作数。$I_4$ 尝试发射。它被阻塞，因为一条活跃指令（$I_3$）也正在写入 $R_5$。这是一个 **WAW 停顿**。（WAW 停顿周期 = 1）。\n*   **周期 5：** $I_1$ 执行（3个周期中的第3个周期），在本周期末完成。$I_2$ 仍然停顿（因 $R_9$ 存在 RAW）。$I_3$ 开始执行（2个周期中的第1个周期）。$I_4$ 因 $I_3$ 引起的 **WAW 冒险** 而在发射阶段继续停顿。（WAW 停顿周期 = 2）。\n*   **周期 6：** $I_1$ 执行写回结果。$R_9$ 将在周期 7 可用。$I_2$ 仍然停顿（因 $R_9$ 存在 RAW）。$I_3$ 执行（2个周期中的第2个周期），在本周期末完成。$I_4$ 因 $I_3$ 引起的 **WAW 冒险** 而在发射阶段继续停顿。（WAW 停顿周期 = 3）。\n*   **周期 7：**\n    *   $I_3$ 准备好进行写回结果。然而，一条更早的指令 $I_2$ 尚未读取其操作数，并且使用了 $R_5$（$I_3$ 的目标寄存器）作为源。$I_3$ 必须停顿。这是一个 **WAR 停顿**。（WAR 停顿周期 = 1）。\n    *   由于 $R_9$ 已可用，$I_2$ 现在读取其操作数。\n    *   $I_4$ 因 $I_3$（仍处于活跃状态，因为它尚未完成 WR）引起的 **WAW 冒险** 而在发射阶段继续停顿。（WAW 停顿周期 = 4）。\n*   **周期 8：**\n    *   由于 $I_2$ 在上一周期读取了其操作数，$I_3$ 的 WAR 条件现已解除。$I_3$ 执行写回结果。$I_3$ 对 $R_5$ 的寄存器预留被释放。\n    *   $I_2$ 开始执行（2个周期中的第1个周期）。\n    *   在同一周期内 $I_3$ 的 WR 之后，$I_4$ 的 WAW 冒险被解除。$I_4$ 发射（乘法器 FU 被占用）。\n*   **周期 9：** $I_2$ 执行（2个周期中的第2个周期），在本周期末完成。$I_4$ 读取操作数。$I_5$ 发射（ALU2 被占用）。\n*   **周期 10：** $I_2$ 执行写回结果。$I_4$ 开始执行（5个周期中的第1个周期）。$I_5$ 在 RO 阶段停顿（因 $R_5$ 存在 RAW 冒险，该值正在由 $I_4$ 计算）。\n*   **周期 11-14：** $I_4$ 继续执行（第2、3、4、5个周期）。$I_5$ 仍然停顿（RAW）。在周期 14 结束时，$I_4$ 完成执行。\n*   **周期 15：** $I_4$ 执行写回结果。没有 WAR 停顿，因为读取 $R_5$ 的 $I_5$ 是一条后续指令，而不是更早的指令。$R_5$ 将在周期 16 可用。$I_5$ 读取操作数。\n*   **周期 16-17：** $I_5$ 执行。\n*   **周期 18：** $I_5$ 执行写回结果。所有指令完成。\n\n### 步骤 3：统计停顿\n\n我们现在将明确标识为由 WAW 或 WAR 冒险引起的停顿周期数相加。\n\n*   **WAW 停顿：**\n    *   指令 $I_4$ 在周期 4 时准备好发射，但由于 $I_3$ 写入同一目标寄存器 $R_5$ 而被阻塞。\n    *   $I_4$ 在周期 $4, 5, 6,$ 和 $7$ 期间停顿。\n    *   总 WAW 停顿周期 = $4$。\n\n*   **WAR 停顿：**\n    *   指令 $I_3$ 在周期 7 时准备好执行写回结果，但由于更早的指令 $I_2$ 尚未读取其源操作数 $R_5$ 而被阻塞。\n    *   $I_3$ 在周期 $7$ 期间停顿。\n    *   总 WAR 停顿周期 = $1$。\n\n*   **总停顿周期 (WAW + WAR)：**\n    *   完全归因于 WAW 和 WAR 冒险的总停顿周期数是各项计数的总和。\n    *   总计 = (WAW 停顿) + (WAR 停顿) = $4 + 1 = 5$。\n\n$I_2$ 和 $I_5$ 经历的停顿周期是由于 RAW 冒险，根据题目要求不予计算。没有发生写端口上的结构性停顿。", "answer": "$$\n\\boxed{5}\n$$", "id": "3638650"}, {"introduction": "真实世界的程序充满了循环，因此，分析跨越循环迭代的依赖关系对于理解性能至关重要。这个最终练习将挑战你分析一个微基准测试循环，你将发现“伪依赖”（WAR 和 WAW）如何形成一个限制性能的循环瓶颈。通过计算在理想条件下（即消除这些伪依赖后）可达到的最佳性能，你将体会到为何需要像寄存器重命名这样的更高级技术 [@problem_id:3638623]。", "problem": "一个中央处理器 (CPU) 实现了一个经典的记分板，具有顺序发射、乱序读取和写入以及以下特性。一条指令经历四个概念阶段：发射 (Issue)、读操作数 (Read Operands)、执行 (Execute) 和写回结果 (Write Result)。记分板按如下方式强制处理冒险：在发射阶段，它通过禁止对同一架构寄存器有多个活动写入者来防止写后写 (WAW) 冒险；在读操作数阶段，它通过延迟操作数的读取，直到每个源寄存器的最近的前一个生产者写回其结果，来防止写后读 (RAW) 冒险；在写回结果阶段，它通过延迟写入，直到所有读取该寄存器的更早指令都已完成其读取操作，来防止读后写 (WAR) 冒险。功能单元的可用性被追踪；每条指令必须在发射阶段获得一个功能单元。假设功能单元是完全流水线化的，具有固定的执行延迟，并且除了记分板已经建模的冲突外，寄存器堆或写回端口上没有结构性冲突。\n\n考虑一个由三条指令的迭代体组成的无限循环微基准测试：\n- $I_1: R_1 \\leftarrow R_2 + R_3$ (使用加法器)，\n- $I_2: R_2 \\leftarrow R_1 + R_4$ (使用加法器)，\n- $I_3: R_3 \\leftarrow R_2 \\times R_5$ (使用乘法器)，\n\n其中 $R_4$ 和 $R_5$ 是循环不变量。加法器的执行延迟为 $L_A$ 个周期，乘法器的执行延迟为 $L_M$ 个周期。一条指令的结果在其执行延迟完成后的下一个周期即可供相关的消费者使用。假设循环被调度，使得在每次迭代中，三条指令都以程序顺序 $I_1$、$I_2$、$I_3$ 出现，并且循环中没有其他指令。\n\n任务：\n- 从数据相关和冒险（RAW、WAR、WAW）的基本定义出发，构建单次迭代内的相关关系和连续迭代间的循环携带相关。解释为什么在一个没有寄存器重命名（寄存器重命名 (RR) 是将架构寄存器动态映射到不同的物理寄存器以消除伪相关的技术）的记分板下，这些关系会形成一个有向循环，从而强制迭代串行启动，即使功能单元是完全流水线化的。\n- 然后，假设理想的寄存器重命名消除了所有反相关 (WAR) 和输出相关 (WAW)，同时保留了真数据相关 (RAW)，请从第一性原理推导出该循环可以实现的最小稳态启动间隔（以周期/迭代为单位），作为 $L_A$ 和 $L_M$ 的函数。\n- 最后，对 $L_A = 2$ 和 $L_M = 4$ 的情况，评估您的表达式，并将稳态启动间隔报告为单个数字。将最终答案表示为每个迭代的周期数（无单位）。无需四舍五入。", "solution": "用户提供的问题是计算机体系结构中的一个有效练习，具体涉及带有记分板的动态调度处理器的性能分析。所有提供的信息都是自洽的、一致的，并且科学地基于处理器设计的既定原则。因此，我们可以进行完整的解答。\n\n分析按要求分为三个部分：首先，检查没有寄存器重命名时的循环执行；其次，推导有理想寄存器重命名时的最小启动间隔；第三，对结果进行数值计算。\n\n### 第1部分：无寄存器重命名分析\n\n当两条指令访问同一内存位置或寄存器，且至少有一次访问是写操作时，它们之间就存在数据相关。数据相关有三种类型：\n1.  写后读 (RAW)，或称真相关：一条指令在先前的指令写入某个位置后读取该位置。例如，$I_i: R_x \\leftarrow \\dots; \\dots; I_j: \\dots \\leftarrow R_x + \\dots$。\n2.  读后写 (WAR)，或称反相关：一条指令在先前的指令读取某个位置后写入该位置。例如，$I_i: \\dots \\leftarrow R_x + \\dots; \\dots; I_j: R_x \\leftarrow \\dots$。\n3.  写后写 (WAW)，或称输出相关：一条指令在先前的指令也写入某个位置后写入该位置。例如，$I_i: R_x \\leftarrow \\dots; \\dots; I_j: R_x \\leftarrow \\dots$。\n\nRAW 相关代表了真实的数据流。WAR 和 WAW 相关是“伪”相关或“名”相关，因为它们是由有限数量的架构寄存器名称的重用引起的，而不是因为数据需要在指令之间流动。\n\n令 $I_j^k$ 表示迭代 $k$ 中的指令 $I_j$。指令如下：\n- $I_1^k: R_1 \\leftarrow R_2 + R_3$\n- $I_2^k: R_2 \\leftarrow R_1 + R_4$\n- $I_3^k: R_3 \\leftarrow R_2 \\times R_5$\n\n**单次迭代 ($k$) 内的相关性：**\n-   $I_1^k \\xrightarrow{\\text{RAW}, R_1} I_2^k$: $I_2^k$ 在 $I_1^k$ 写入 $R_1$ 后读取它。\n-   $I_2^k \\xrightarrow{\\text{RAW}, R_2} I_3^k$: $I_3^k$ 在 $I_2^k$ 写入 $R_2$ 后读取它。\n-   $I_1^k \\xrightarrow{\\text{WAR}, R_2} I_2^k$: $I_2^k$ 在 $I_1^k$ 读取 $R_2$ 后写入它。\n-   $I_1^k \\xrightarrow{\\text{WAR}, R_3} I_3^k$: $I_3^k$ 在 $I_1^k$ 读取 $R_3$ 后写入它。\n\n**循环携带相关（从迭代 $k$ 到 $k+1$）：**\n$I_1^{k+1}$ 读取的寄存器 $R_2$ 和 $R_3$ 的值是在迭代 $k$ 中产生的。\n-   $I_2^k \\xrightarrow{\\text{RAW}, R_2} I_1^{k+1}$: $I_1^{k+1}$ 读取由 $I_2^k$ 产生的 $R_2$ 的值。\n-   $I_3^k \\xrightarrow{\\text{RAW}, R_3} I_1^{k+1}$: $I_1^{k+1}$ 读取由 $I_3^k$ 产生的 $R_3$ 的值。\n\n由于寄存器名 $R_1, R_2, R_3$ 的重用，跨迭代也存在伪相关。\n-   $I_j^k \\xrightarrow{\\text{WAW}, R_j} I_j^{k+1}$ 对于 $j \\in \\{1, 2, 3\\}$。例如，$I_2^k$ 和 $I_2^{k+1}$ 都写入 $R_2$。\n-   $I_1^{k+1} \\xrightarrow{\\text{WAR}, R_2} I_2^{k+1}$: $I_2^{k+1}$ 写入 $R_2$，而更早的指令 $I_1^{k+1}$ 读取了该寄存器。\n-   $I_1^{k+1} \\xrightarrow{\\text{WAR}, R_3} I_3^{k+1}$: $I_3^{k+1}$ 写入 $R_3$，而更早的指令 $I_1^{k+1}$ 读取了该寄存器。\n\n由于这些相关的相互作用，经典的记分板会使迭代串行化。让我们以寄存器 $R_2$ 为例。形成了一个有向的约束循环：\n1.  **RAW 冒险**: $I_2^k \\xrightarrow{\\text{RAW}, R_2} I_1^{k+1}$。记分板将暂停 $I_1^{k+1}$ 的读操作数阶段，直到 $I_2^k$ 完成其写回结果阶段。我们将指令 $I$ 的阶段 `S` 表示为 $S(I)$。这意味着 $RO(I_1^{k+1})$ 必须在 $WB(I_2^k)$ 之后发生。\n2.  **WAR 冒险**: $I_1^{k+1} \\xrightarrow{\\text{WAR}, R_2} I_2^{k+1}$。记分板将延迟 $I_2^{k+1}$ 的写回结果阶段，直到更早的指令 $I_1^{k+1}$ 完成其读操作数阶段。这意味着 $WB(I_2^{k+1})$ 必须在 $RO(I_1^{k+1})$ 之后发生。\n3.  **WAW 冒险**: $I_2^k \\xrightarrow{\\text{WAW}, R_2} I_2^{k+1}$。记分板将暂停 $I_2^{k+1}$ 的发射阶段，直到 $I_2^k$ 不再是活动写入者，这意味着 $I_2^k$ 必须完成其写回结果阶段。这意味着 $Issue(I_2^{k+1})$ 必须在 $WB(I_2^k)$ 之后发生。\n\n结合这些约束，我们得到一个链条：$WB(I_2^k)$ 使得 $Issue(I_2^{k+1})$ 可以进行，并且也使得 $RO(I_1^{k+1})$ 可以进行。$RO(I_1^{k+1})$ 的完成又使得 $WB(I_2^{k+1})$ 可以进行。因此，$I_2^{k+1}$ 的执行受到 $I_2^k$ 的完成和 $I_1^{k+1}$ 进度的严格约束。寄存器 $R_3$ 也存在类似的循环。这些作用于相同寄存器名的迭代间 RAW、WAR 和 WAW 冒险的综合效应是，迭代 $k+1$ 不能与迭代 $k$ 大量重叠。迭代 $k+1$ 的开始依赖于迭代 $k$ 的完成，从而强制迭代串行启动。\n\n### 第2部分：有理想寄存器重命名分析\n\n理想的寄存器重命名通过将架构寄存器动态映射到一个大的物理寄存器池来消除所有 WAR 和 WAW 冒险。这只留下了真数据 (RAW) 相关。最小稳态启动间隔 $II$ 是连续循环迭代开始之间的时间。它受两个因素的制约：数据流图中的递推 ($II_{rec}$) 和硬件资源限制 ($II_{res}$)。可实现的 $II$ 是这两个下界的最大值：$II = \\max(II_{rec}, II_{res})$。\n\n**递推约束的最小启动间隔 ($II_{rec}$):**\n我们分析 RAW 相关以找到跨越迭代边界的相关图中的循环。令 $S_j(k)$ 为迭代 $k$ 中指令 $I_j$ 的开始执行时间。指令的结果在其延迟之后可用。相关指令的开始时间必须大于或等于所需结果可用的时间。\nRAW 相关给出以下不等式：\n1.  $S_2(k) \\ge S_1(k) + L_A$\n2.  $S_3(k) \\ge S_2(k) + L_A$\n3.  $S_1(k+1) \\ge S_2(k) + L_A$\n4.  $S_1(k+1) \\ge S_3(k) + L_M$\n\n为了找到最小 $II$，我们寻找最紧的约束。我们可以组合这些不等式来找到形成递推的最长相关路径。\n从 (4) 可知，迭代 $k+1$ 中 $I_1$ 的开始依赖于迭代 $k$ 中 $I_3$ 的完成。\n$$ S_1(k+1) \\ge S_3(k) + L_M $$\n将 (2) 代入此表达式：\n$$ S_1(k+1) \\ge (S_2(k) + L_A) + L_M $$\n将 (1) 代入此表达式：\n$$ S_1(k+1) \\ge ( (S_1(k) + L_A) + L_A ) + L_M $$\n$$ S_1(k+1) \\ge S_1(k) + 2L_A + L_M $$\n该不等式描绘了关键递推路径：$I_1^k \\rightarrow I_2^k \\rightarrow I_3^k \\rightarrow I_1^{k+1}$。\n在稳态下，连续迭代中相同指令的开始时间之差就是启动间隔 $II$。因此，$S_1(k+1) = S_1(k) + II$。将其代入不等式得：\n$$ S_1(k) + II \\ge S_1(k) + 2L_A + L_M $$\n$$ II \\ge 2L_A + L_M $$\n这确立了递推约束的下界：$II_{rec} = 2L_A + L_M$。\n\n**资源约束的最小启动间隔 ($II_{res}$):**\n这个界限由每种类型功能单元的需求决定。功能单元是完全流水线化的，意味着它们可以在每个时钟周期接受一个新的操作。\n-   **加法器：** 被 $I_1$ 和 $I_2$ 使用。每次迭代使用 $2$ 次。假设有 1 个加法器单元，满足这些请求所需的最小间隔为 $II_{res}(\\text{加法器}) = \\frac{2 \\text{ 次使用}}{1 \\text{ 单元}} = 2$ 周期/迭代。\n-   **乘法器：** 被 $I_3$ 使用。每次迭代使用 $1$ 次。假设有 1 个乘法器单元，最小间隔为 $II_{res}(\\text{乘法器}) = \\frac{1 \\text{ 次使用}}{1 \\text{ 单元}} = 1$ 周期/迭代。\n\n总的资源约束 MII 是所有资源类型中的最大值：\n$$ II_{res} = \\max(2, 1) = 2 $$\n\n**最小启动间隔 ($II$):**\n可实现的启动间隔是递推约束和资源约束的最大值。\n$$ II = \\max(II_{rec}, II_{res}) = \\max(2L_A + L_M, 2) $$\n由于执行延迟 $L_A$ 和 $L_M$ 是正整数（至少为 $1$），因此项 $2L_A + L_M$ 至少为 $2(1) + 1 = 3$。因此，递推总是限制因素。\n$$ II = 2L_A + L_M $$\n\n### 第3部分：数值计算\n\n给定延迟 $L_A = 2$ 个周期和 $L_M = 4$ 个周期。将这些值代入我们推导出的最小启动间隔表达式中：\n$$ II = 2(2) + 4 $$\n$$ II = 4 + 4 $$\n$$ II = 8 $$\n最小稳态启动间隔是 8 周期/迭代。", "answer": "$$\\boxed{8}$$", "id": "3638623"}]}