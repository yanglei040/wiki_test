{"hands_on_practices": [{"introduction": "为了充分利用指令级并行（ILP），处理器必须区分真正的依赖关系和由于寄存器名称复用引起的“伪”依赖关系。本练习将通过对比有无寄存器重命名的两种处理器，直观地揭示伪依赖（写后读 WAR 和写后写 WAW）如何限制并行性。通过计算性能提升，你将深刻理解寄存器重命名这一现代乱序执行处理器的核心技术为何至关重要 [@problem_id:3651255]。", "problem": "您正在分析一个基本块在两个其他方面相同乱序 (OoO) 处理器上的指令级并行性 (ILP)。机器 $\\mathcal{M}_0$ 没有寄存器重命名，因此必须遵守所有名称相关（写后写和读后写），而机器 $\\mathcal{M}_1$ 具有完美的寄存器重命名，可以消除所有名称相关，同时保留真正的数据相关（写后读）。假设一个理想化的流水线，具有无限的发射宽度、无限的功能单元、完美的分支预测，并且没有缓存或结构性停顿。每条算术指令的延迟为 $1$ 个周期。在这些假设下，指令级并行性 (ILP) 定义为该基本块每个周期完成的平均指令数。\n\n考虑以下由 $8$ 个整数加法组成的基本块，按给定的静态程序顺序排列，其中 $R_x$ 表示体系结构寄存器，每行是一条指令：\n- $I_1$: $R_1 \\leftarrow R_2 + R_3$\n- $I_2$: $R_4 \\leftarrow R_1 + R_5$\n- $I_3$: $R_4 \\leftarrow R_4 + R_7$\n- $I_4$: $R_8 \\leftarrow R_4 + R_9$\n- $I_5$: $R_1 \\leftarrow R_{10} + R_{11}$\n- $I_6$: $R_4 \\leftarrow R_1 + R_{13}$\n- $I_7$: $R_4 \\leftarrow R_4 + R_{15}$\n- $I_8$: $R_{16} \\leftarrow R_4 + R_{17}$\n\n任务：\n- 仅使用动态调度中相关类型的核心定义，识别该块中的哪些指令间边缘是 $\\mathcal{M}_0$ 上的真正数据相关（写后读，RAW），哪些是伪名称相关（读后写，WAR；写后写，WAW）。\n- 基于这些相关性，确定在 $\\mathcal{M}_0$ 和 $\\mathcal{M}_1$ 上执行该块所需的最短完成时间（以周期为单位）。对于 $\\mathcal{M}_1$，假设完美的寄存器重命名，通过为逻辑上独立的结果分配不同的物理寄存器来消除所有 WAR 和 WAW 约束，同时保留所有 RAW 相关。\n- 令 $ILP_0$ 和 $ILP_1$ 分别表示 $\\mathcal{M}_0$ 和 $\\mathcal{M}_1$ 上的指令级并行性，计算公式为 $ILP = \\dfrac{N}{T}$，其中 $N$ 是块中的指令数，$T$ 是在所述模型下完成该块所需的最少周期数。\n\n数值增量 $\\Delta ILP = ILP_1 - ILP_0$ 是多少？请用一个精确的既约分数表示您的答案。不需要四舍五入，也不需要单位。", "solution": "该问题要求分析一个给定的基本块在两个不同的乱序处理器 $\\mathcal{M}_0$ 和 $\\mathcal{M}_1$ 上的指令级并行性 (ILP)。ILP 定义为 $ILP = \\frac{N}{T}$，其中 $N$ 是指令数，$T$ 是以周期为单位的最短执行时间。该基本块包含 $N=8$ 条指令，每条指令的延迟为 1 个周期。在周期 $c$ 开始的指令的结果，在周期 $c+1$ 的开始时对相关指令可用。\n\n首先，我们必须为没有寄存器重命名的处理器 $\\mathcal{M}_0$ 识别出所有的指令间相关性。这些相关性被分为真正的数据相关（写后读，RAW）、反相关（读后写，WAR）和输出相关（写后写，WAW）。\n\n指令序列如下：\n$I_1: R_1 \\leftarrow R_2 + R_3$\n$I_2: R_4 \\leftarrow R_1 + R_5$\n$I_3: R_4 \\leftarrow R_4 + R_7$\n$I_4: R_8 \\leftarrow R_4 + R_9$\n$I_5: R_1 \\leftarrow R_{10} + R_{11}$\n$I_6: R_4 \\leftarrow R_1 + R_{13}$\n$I_7: R_4 \\leftarrow R_4 + R_{15}$\n$I_8: R_{16} \\leftarrow R_4 + R_{17}$\n\n**1. 机器 $\\mathcal{M}_0$ 的相关性分析（无寄存器重命名）**\n\n我们识别所有具有相关性的指令对 $(I_i, I_j)$，其中 $j > i$。\n\n- **真正的数据相关 (RAW):** $I_i$ 写入一个寄存器，而 $I_j$ 读取该寄存器。\n  - $(I_1, I_2)$ 在 $R_1$ 上：$I_1$ 写入 $R_1$，而 $I_2$ 读取 $R_1$。\n  - $(I_2, I_3)$ 在 $R_4$ 上：$I_2$ 写入 $R_4$，而 $I_3$ 读取 $R_4$。\n  - $(I_3, I_4)$ 在 $R_4$ 上：$I_3$ 写入 $R_4$，而 $I_4$ 读取 $R_4$。\n  - $(I_5, I_6)$ 在 $R_1$ 上：$I_5$ 写入 $R_1$，而 $I_6$ 读取 $R_1$。\n  - $(I_6, I_7)$ 在 $R_4$ 上：$I_6$ 写入 $R_4$，而 $I_7$ 读取 $R_4$。\n  - $(I_7, I_8)$ 在 $R_4$ 上：$I_7$ 写入 $R_4$，而 $I_8$ 读取 $R_4$。\n\n- **反相关 (WAR):** $I_i$ 读取一个寄存器，而 $I_j$ 写入该寄存器。\n  - $(I_2, I_5)$ 在 $R_1$ 上：$I_2$ 读取 $R_1$，而 $I_5$ 写入 $R_1$。\n  - $(I_3, I_6)$ 在 $R_4$ 上：$I_3$ 读取 $R_4$，而 $I_6$ 写入 $R_4$。\n  - $(I_3, I_7)$ 在 $R_4$ 上：$I_3$ 读取 $R_4$，而 $I_7$ 写入 $R_4$。\n  - $(I_4, I_6)$ 在 $R_4$ 上：$I_4$ 读取 $R_4$，而 $I_6$ 写入 $R_4$。\n  - $(I_4, I_7)$ 在 $R_4$ 上：$I_4$ 读取 $R_4$，而 $I_7$ 写入 $R_4$。\n\n- **输出相关 (WAW):** $I_i$ 和 $I_j$ 都写入同一个寄存器。处理器必须确保寄存器中的最终值与程序顺序中的最后一次写入相对应。\n  - $(I_1, I_5)$ 在 $R_1$ 上。\n  - 在 $R_4$ 上，指令 $I_2, I_3, I_6, I_7$ 都进行写入。这产生了以下 WAW 相关：$(I_2, I_3)$、$(I_2, I_6)$、$(I_2, I_7)$、$(I_3, I_6)$、$(I_3, I_7)$ 和 $(I_6, I_7)$。注意，其中一些指令对也存在 RAW 相关（例如 $(I_2,I_3)$），这是一个更强的约束。\n\n**2. 在机器 $\\mathcal{M}_0$ 上的执行时间**\n\n最短执行时间由完整相关图中的关键路径决定。从 $I_i$ 到 $I_j$ 的一条边意味着 $I_j$ 可以在 $I_i$ 完成的那个周期或之后开始。令 $S(I_k)$ 为指令 $I_k$ 的开始周期（从 $S=0$ 开始），$C(I_k) = S(I_k) + 1$ 为其完成周期。\n\n- $S(I_1) = 0$。$C(I_1) = 1$。\n- $S(I_2) \\geq C(I_1)$ (RAW)。$\\implies S(I_2) = 1, C(I_2) = 2$。\n- $S(I_3) \\geq C(I_2)$ (RAW)。$\\implies S(I_3) = 2, C(I_3) = 3$。\n- $S(I_4) \\geq C(I_3)$ (RAW)。$\\implies S(I_4) = 3, C(I_4) = 4$。\n- $S(I_5) \\geq C(I_2)$ (在 $R_1$ 上的 WAR)。并且 $S(I_5) \\geq C(I_1)$ (在 $R_1$ 上的 WAW)。由于 $C(I_2) > C(I_1)$，WAR 相关是约束性条件。$\\implies S(I_5) = 2, C(I_5) = 3$。\n- $S(I_6)$ 取决于多个前驱指令：\n    - $S(I_6) \\geq C(I_5)$ (在 $R_1$ 上的 RAW)。所以 $S(I_6) \\geq 3$。\n    - $S(I_6) \\geq C(I_4)$ (在 $R_4$ 上的 WAR)。所以 $S(I_6) \\geq 4$。\n    - $S(I_6) \\geq C(I_3)$ (在 $R_4$ 上的 WAW 和 WAR)。所以 $S(I_6) \\geq 3$。\n    最严格的约束来自 $I_4$，因此 $S(I_6) \\geq \\max(3, 4, 3) = 4$。$\\implies S(I_6) = 4, C(I_6) = 5$。\n- $S(I_7) \\geq C(I_6)$ (RAW)。$\\implies S(I_7) = 5, C(I_7) = 6$。\n- $S(I_8) \\geq C(I_7)$ (RAW)。$\\implies S(I_8) = 6, C(I_8) = 7$。\n\n最后一条指令 $I_8$ 在周期 7 完成。在 $\\mathcal{M}_0$ 上执行该块的总时间为 $T_0 = 7$ 个周期。\nILP 为 $ILP_0 = \\frac{N}{T_0} = \\frac{8}{7}$。\n\n**3. 在机器 $\\mathcal{M}_1$ 上的执行时间（完美寄存器重命名）**\n\n在机器 $\\mathcal{M}_1$ 上，完美的寄存器重命名消除了所有 WAR 和 WAW 相关。只剩下 RAW 相关。\nRAW 相关将指令划分为两个独立的链：\n- 链 A：$I_1 \\rightarrow_{RAW} I_2 \\rightarrow_{RAW} I_3 \\rightarrow_{RAW} I_4$。\n- 链 B：$I_5 \\rightarrow_{RAW} I_6 \\rightarrow_{RAW} I_7 \\rightarrow_{RAW} I_8$。\n\n在无限资源的情况下，这两条链并行执行。总执行时间由较长链的长度决定。\n- 链 A 的长度是其 $4$ 条指令的延迟总和，即 $1+1+1+1 = 4$ 个周期。\n- 链 B 的长度是其 $4$ 条指令的延迟总和，即 $1+1+1+1 = 4$ 个周期。\n\n两条链的长度相等。执行过程如下：\n- 周期 0：$I_1$ 和 $I_5$ 发射。\n- 周期 1：$I_2$ 和 $I_6$ 发射。\n- 周期 2：$I_3$ 和 $I_7$ 发射。\n- 周期 3：$I_4$ 和 $I_8$ 发射。\n\n所有指令在周期 4 结束时完成。总执行时间为 $T_1 = 4$ 个周期。\nILP 为 $ILP_1 = \\frac{N}{T_1} = \\frac{8}{4} = 2$。\n\n**4. $\\Delta ILP$ 的计算**\n\nILP 的数值增量为 $\\Delta ILP = ILP_1 - ILP_0$。\n$\\Delta ILP = 2 - \\frac{8}{7}$\n为了进行减法，我们找到一个公分母：\n$\\Delta ILP = \\frac{14}{7} - \\frac{8}{7} = \\frac{14 - 8}{7} = \\frac{6}{7}$。\n结果是所要求的精确既约分数。", "answer": "$$\\boxed{\\frac{6}{7}}$$", "id": "3651255"}, {"introduction": "在识别出可并行的指令后，下一个挑战是如何在处理器有限的硬件资源下高效地调度它们。本练习模拟了一个具有固定发射宽度（每个周期最多发射3条指令）的超标量处理器 [@problem_id:3651239]。你需要像调度器一样思考，在每个时钟周期填充可用的指令发射槽，以最小化总执行时间，并最终计算指令吞吐率（IPC）。", "problem": "考虑一个在利用指令级并行 (ILP) 的超标量处理器上调度的基本块。该处理器每个周期最多可以发射 $w=3$ 条指令，具有完美的分支预测，执行寄存器重命名以消除命名冲突，并且没有内存停顿或缓存未命中。假设所有功能单元的延迟均为一个周期，并且依赖于前驱指令的指令只能在前驱指令被发射的严格后续周期中发射。\n\n该基本块由三个不相交的真数据依赖链组成：\n- 链 $\\mathcal{A}$：指令 $A_1 \\rightarrow A_2 \\rightarrow A_3 \\rightarrow A_4 \\rightarrow A_5$，\n- 链 $\\mathcal{B}$：指令 $B_1 \\rightarrow B_2 \\rightarrow B_3 \\rightarrow B_4$，\n- 链 $\\mathcal{C}$：指令 $C_1 \\rightarrow C_2 \\rightarrow C_3 \\rightarrow C_4 \\rightarrow C_5 \\rightarrow C_6$，\n\n以及最后一条指令 $X$，它依赖于每个链的最后一条指令，即 $X$ 对 $A_5$、$B_4$ 和 $C_6$ 存在真数据依赖。不存在其他链间依赖。\n\n定义“并行阶段”为处理器恰好发射 $w$ 条指令的任何周期。在一个遵守所述约束的理想乱序调度器下，确定：\n1. 基本块执行期间的并行阶段数量。\n2. 预期的每周期指令数 (IPC)，定义为基本块中动态指令总数与发射整个块所需的总周期数之比。\n\nIPC应表示为精确值，无需四舍五入。最终答案应以无单位的纯数字形式给出。", "solution": "首先，我们分析问题中的约束和指令集。\n- 处理器发射宽度 $w=3$。\n- 指令延迟为1个周期，依赖指令在父指令发射后的下一周期才能发射。\n- 共有三个独立的依赖链 $\\mathcal{A}$ (5条指令), $\\mathcal{B}$ (4条指令), $\\mathcal{C}$ (6条指令) 和一条最终指令 $X$。\n\n**1. 指令总数计算**\n基本块中的动态指令总数 $N_{instr}$ 是所有链的指令数加上最终指令 $X$ 的总和：\n$$ N_{instr} = 5 (\\text{链}\\mathcal{A}) + 4 (\\text{链}\\mathcal{B}) + 6 (\\text{链}\\mathcal{C}) + 1 (\\text{指令}X) = 16 $$\n\n**2. 指令调度模拟**\n我们模拟一个理想的乱序调度器，在每个时钟周期尽可能多地发射就绪指令，最多不超过发射宽度 $w=3$。\n\n- **周期 1**：三个链的起始指令 $A_1, B_1, C_1$ 都没有依赖，因此它们是就绪的。处理器可以发射全部3条。\n  - 已发射: $\\{A_1, B_1, C_1\\}$。发射数: 3。\n  - 这是一个**并行阶段**。\n\n- **周期 2**：指令 $A_2, B_2, C_2$ 的依赖项已在周期1发射，因此它们现在是就绪的。处理器可以发射全部3条。\n  - 已发射: $\\{A_2, B_2, C_2\\}$。发射数: 3。\n  - 这是一个**并行阶段**。\n\n- **周期 3**：指令 $A_3, B_3, C_3$ 变为就绪。处理器发射全部3条。\n  - 已发射: $\\{A_3, B_3, C_3\\}$。发射数: 3。\n  - 这是一个**并行阶段**。\n\n- **周期 4**：指令 $A_4, B_4, C_4$ 变为就绪。处理器发射全部3条。\n  - 已发射: $\\{A_4, B_4, C_4\\}$。发射数: 3。\n  - 链 $\\mathcal{B}$ 的所有指令均已发射。\n  - 这是一个**并行阶段**。\n\n- **周期 5**：链 $\\mathcal{B}$ 已完成。就绪指令为 $A_5$ (依赖 $A_4$) 和 $C_5$ (依赖 $C_4$)。处理器发射这两条指令。\n  - 已发射: $\\{A_5, C_5\\}$。发射数: 2。\n  - 链 $\\mathcal{A}$ 的所有指令均已发射。\n\n- **周期 6**：链 $\\mathcal{A}$ 已完成。唯一就绪的指令是 $C_6$ (依赖 $C_5$)。\n  - 已发射: $\\{C_6\\}$。发射数: 1。\n  - 链 $\\mathcal{C}$ 的所有指令均已发射。\n\n- **周期 7**：最终指令 $X$ 依赖于 $A_5, B_4, C_6$。这些指令分别在周期5、4和6发射。由于依赖规则， $X$ 只能在最后一个依赖项 $C_6$ 发射后的下一周期发射。因此，$X$ 在周期 $6+1=7$ 变为就绪。\n  - 已发射: $\\{X\\}$。发射数: 1。\n\n所有16条指令都已发射。执行在第7个周期结束时完成。总执行周期数 $N_{cycles} = 7$。\n\n**3. 结果计算**\n\n**并行阶段数量**:\n并行阶段定义为恰好发射 $w=3$ 条指令的周期。根据模拟，周期1、2、3和4满足此条件。\n因此，并行阶段的数量为 **4**。\n\n**每周期指令数 (IPC)**:\nIPC 定义为总指令数与总周期数之比。\n$$ \\text{IPC} = \\frac{N_{instr}}{N_{cycles}} = \\frac{16}{7} $$\n\n最终答案为并行阶段的数量和IPC值。", "answer": "$$\n\\boxed{\\begin{pmatrix} 4 & \\frac{16}{7} \\end{pmatrix}}\n$$", "id": "3651239"}, {"introduction": "真实世界的处理器不仅有发射宽度的限制，其内部的功能单元（如整数ALU、浮点单元）数量也是有限的。本练习将挑战你为一组具有不同类型和延迟的指令制定最佳调度方案，同时要考虑功能单元的可用性 [@problem_id:3651272]。通过解决这个问题，你将学会如何识别并处理由特定计算资源（而非数据依赖）造成的性能瓶颈。", "problem": "超标量处理器通过在同一时钟周期内发射多个独立操作来利用指令级并行（ILP），但这受限于功能单元的可用性和数据依赖约束。考虑一个要在具有以下属性的处理器上调度的基本块：\n- 有 $2$ 个相同的整数算术逻辑单元（ALU）和 $1$ 个浮点（FP）单元。\n- 所有单元都是完全流水线化的，因此每个单元每个周期最多可以接收一个新操作。\n- 整数ALU操作的延迟为 $1$ 个周期。\n- 浮点加法的延迟为 $3$ 个周期，浮点乘法的延迟为 $4$ 个周期。\n- 一个操作产生的操作数在发射后恰好 $d$ 个周期变为可用，其中 $d$ 是该操作的延迟。一个依赖的消费者操作可以在其最后一个操作数变为可用的同一周期内发射。\n- 没有内存操作，没有控制依赖，并且寄存器被完全重命名，从而消除了伪依赖（没有读后写或写后写冒险）。只有真数据依赖适用。\n\n基本块包含以下操作。每一行列出操作标签、操作类型及其显式真依赖：\n- $I_1$：整数加法，不依赖于任何先前的操作。\n- $I_2$：整数加法，不依赖于任何先前的操作。\n- $I_3$：整数加法，依赖于 $I_1$。\n- $I_4$：整数加法，依赖于 $I_1$ 和 $I_2$。\n- $I_5$：整数加法，依赖于 $I_3$ 和 $I_4$。\n- $F_1$：浮点乘法，不依赖于任何先前的操作。\n- $F_2$：浮点加法，不依赖于任何先前的操作。\n- $F_3$：浮点加法，依赖于 $F_1$ 和 $F_2$。\n- $F_4$：浮点乘法，依赖于 $F_3$。\n- $F_5$：浮点加法，依赖于 $F_4$ 和 $F_1$。\n\n假设在所述约束下允许乱序发射，并且整数操作必须分配给整数ALU，而浮点操作必须分配给FP单元。从周期 $0$ 开始，在一个最大化ILP并满足给定约束的最优调度下，确定最小完工时间 $M$。$M$ 定义为基本块中所有操作都已完成（所有结果都已就绪）的最早周期。请用一个不带单位的整数周期数表示你的答案。", "solution": "该问题要求确定一组指令在具有特定功能单元和延迟的超标量处理器上执行的最小完工时间 $M$。$M$ 定义为所有操作的结果都变为可用的最早时钟周期。调度必须同时满足数据依赖和资源约束。\n\n**1. 问题形式化与约束**\n- **资源**: 2个整数ALU，1个浮点(FP)单元。\n- **延迟**: $d_{int}=1$, $d_{fp\\_add}=3$, $d_{fp\\_mult}=4$。\n- **调度规则**:\n  - 数据依赖: 操作 $O$ 的发射周期 $Issue(O)$ 必须大于或等于其所有依赖项 $P$ 的就绪周期 $Ready(P)$。$Issue(O) \\ge \\max_{P \\in Dependencies(O)} \\{Ready(P)\\}$。\n  - 资源约束: 每个周期最多发射2个整数操作和1个浮点操作。\n- **完成时间**: $Ready(O) = Issue(O) + d(O)$。\n- **目标**: 最小化 $M = \\max_{\\text{all } O} \\{Ready(O)\\}$。\n\n**2. 关键路径分析 (下界确定)**\n我们首先分析数据依赖链，计算在无限资源下的最早完成时间，以确定完工时间的理论下界。\n\n- **整数指令链**:\n  - $Ready(I_1) = 0 + d_{int} = 1$\n  - $Ready(I_2) = 0 + d_{int} = 1$\n  - $Ready(I_3) = Ready(I_1) + d_{int} = 1 + 1 = 2$\n  - $Ready(I_4) = \\max(Ready(I_1), Ready(I_2)) + d_{int} = 1 + 1 = 2$\n  - $Ready(I_5) = \\max(Ready(I_3), Ready(I_4)) + d_{int} = 2 + 1 = 3$\n\n- **浮点指令链**:\n  - $Ready(F_1) = 0 + d_{fp\\_mult} = 4$\n  - $Ready(F_2) = 0 + d_{fp\\_add} = 3$\n  - $Issue(F_3) \\ge \\max(Ready(F_1), Ready(F_2)) = 4 \\implies Ready(F_3) = 4 + d_{fp\\_add} = 7$\n  - $Issue(F_4) \\ge Ready(F_3) = 7 \\implies Ready(F_4) = 7 + d_{fp\\_mult} = 11$\n  - $Issue(F_5) \\ge \\max(Ready(F_4), Ready(F_1)) = 11 \\implies Ready(F_5) = 11 + d_{fp\\_add} = 14$\n\n关键路径由浮点指令链决定，其长度为14个周期。因此，最小完工时间 $M \\ge 14$。\n\n**3. 资源约束下的调度模拟**\n现在我们进行逐周期的贪心调度，以验证是否存在一个满足资源约束且能达到14个周期完工时间的调度方案。\n\n- **周期 0**:\n  - 就绪指令: $\\{I_1, I_2, F_1, F_2\\}$。\n  - 调度: 发射 $I_1$ (ALU), $I_2$ (ALU), $F_1$ (FP)。($F_2$ 因FP单元占用而等待)。\n  - 完成时间: $Ready(I_1)=0+1=1$, $Ready(I_2)=0+1=1$, $Ready(F_1)=0+4=4$。\n\n- **周期 1**:\n  - 就绪指令: $\\{I_3, I_4, F_2\\}$。($I_3, I_4$ 的依赖项在周期1就绪；$F_2$ 仍然就绪)。\n  - 调度: 发射 $I_3$ (ALU), $I_4$ (ALU), $F_2$ (FP)。\n  - 完成时间: $Ready(I_3)=1+1=2$, $Ready(I_4)=1+1=2$, $Ready(F_2)=1+3=4$。\n\n- **周期 2**:\n  - 就绪指令: $\\{I_5\\}$。($I_5$ 的依赖项在周期2就绪)。\n  - 调度: 发射 $I_5$ (ALU)。\n  - 完成时间: $Ready(I_5)=2+1=3$。\n\n- **周期 3**: 无就绪指令。\n\n- **周期 4**:\n  - 就绪指令: $\\{F_3\\}$。($F_3$ 的依赖项 $F_1, F_2$ 均在周期4就绪)。\n  - 调度: 发射 $F_3$ (FP)。\n  - 完成时间: $Ready(F_3)=4+3=7$。\n\n- **周期 5, 6**: 无就绪指令。\n\n- **周期 7**:\n  - 就绪指令: $\\{F_4\\}$。($F_4$ 的依赖项 $F_3$ 在周期7就绪)。\n  - 调度: 发射 $F_4$ (FP)。\n  - 完成时间: $Ready(F_4)=7+4=11$。\n\n- **周期 8, 9, 10**: 无就绪指令。\n\n- **周期 11**:\n  - 就绪指令: $\\{F_5\\}$。($F_5$ 的依赖项 $F_4$ 在周期11就绪)。\n  - 调度: 发射 $F_5$ (FP)。\n  - 完成时间: $Ready(F_5)=11+3=14$。\n\n**4. 最小完工时间确定**\n所有指令都已调度。最后一个完成的操作是 $F_5$，其结果在周期14就绪。\n$M = \\max(Ready(I_1..I_5), Ready(F_1..F_5)) = \\max(3, 14) = 14$。\n由于我们构建的调度方案的完工时间与理论下界相同，因此该调度是最优的。\n\n最小完工时间为14个周期。", "answer": "$$\n\\boxed{14}\n$$", "id": "3651272"}]}