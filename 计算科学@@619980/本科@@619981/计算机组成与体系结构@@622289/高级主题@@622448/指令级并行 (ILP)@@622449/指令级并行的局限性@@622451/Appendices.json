{"hands_on_practices": [{"introduction": "指令级并行性（ILP）的上限从根本上受两个因素制约：代码中固有的数据依赖关系（形成了“关键路径”）和处理器有限的指令执行能力。这项练习 [@problem_id:3651332] 提供了一个清晰的量化场景，让您通过计算来确定这两个因素中哪一个成为性能瓶颈，从而决定最终的每周期指令数（IPC），这是理解乱序执行处理器性能的基础。", "problem": "一个程序基本块仅包含算术指令，并在两种基于相同流水线设计构建的微架构上执行：一种是每周期最多能发射 $1$ 条指令的标量核心，另一种是每周期最多能发射 $w$ 条指令的超标量核心，其中 $w=4$。两种核心都是乱序执行，具备完美的寄存器重命名、无限大的指令窗口以及足够多的相同整数算术功能单元，因此唯一的每周期资源限制是发射宽度。所有指令都是单位延迟的单周期整数算术运算，没有多周期效应。忽略所有缓存未命中、内存消歧、与真数据依赖无关的流水线气泡以及分支预测错误的影响。假设只有真数据依赖限制指令重排序。考虑基本块内的以下数据依赖关系：\n- 有一条长度为 $10$ 的单真依赖链，由以下 $10$ 条指令（均为整数加法）组成，其中每条指令都依赖于列表中紧邻其前的一条指令：$I_{1}$ 定义一个临时变量，$I_{2}$ 使用 $I_{1}$ 的结果，$I_{3}$ 使用 $I_{2}$ 的结果，以此类推，直到 $I_{10}$ 使用 $I_{9}$ 的结果。\n- 此外，还有 $17$ 条其他算术指令，它们相互之间独立，并且也独立于上述的 $10$ 指令链。\n\n设基本块中的总指令数为 $N$，最长真依赖链的长度（在单位延迟下，以周期为单位）为 $L$。每周期指令数 (IPC) 定义为：在遵守发射宽度限制和真数据依赖的最优乱序调度下，执行该基本块所退役的总指令数除以总周期数。\n\n在上述假设下，计算 $w=4$ 的超标量核心在独立执行此基本块时所能达到的预期稳态 IPC。请用精确值表示你的答案，无需四舍五入。", "solution": "该问题陈述已经过评估并被认为是有效的。这是一个在计算机体系结构领域中定义明确、自成体系的问题，其基础是指令级并行和超标量处理器性能分析的既定原则。所有必要的参数和简化假设均已提供。\n\n目标是计算一个给定的基本块在超标量乱序处理器上执行时的每周期指令数 (IPC)。IPC 定义为执行的总指令数除以执行所需的总周期数。\n\n设 $N$ 为基本块中的总指令数。\n设 $L$ 为最长真依赖链的长度（以周期为单位）。\n设 $w$ 为超标量核心的最大发射宽度。\n\n根据问题陈述，我们已知：\n有一条包含 $10$ 条指令的单真依赖链。\n另有 $17$ 条指令独立于该链且相互独立。\n发射宽度为 $w=4$。\n所有指令的单位延迟均为 $1$ 个周期。\n\n首先，我们确定总指令数 $N$。它是在依赖链中的指令数与独立指令数之和。\n$$N = 10 + 17 = 27$$\n\n接下来，我们确定关键路径的长度 $L$。问题陈述中有一条包含 $10$ 条指令的链，其中每条指令 $I_{k+1}$ 都依赖于前一条指令 $I_k$ 的结果。由于每条指令的延迟为 $1$ 个周期，因此该链的执行是顺序的。假设 $I_1$ 在周期 $1$ 发射并执行。其结果在周期 $2$ 开始时可用。因此，$I_2$ 可以在周期 $2$ 发射并执行。这个过程沿着链继续下去，指令 $I_k$ 在周期 $k$ 执行。链中的最后一条指令 $I_{10}$ 只能在周期 $10$ 执行。它将在周期 $10$ 结束时完成。因此，决定了最小可能执行时间的关键依赖路径的长度是 $10$ 个周期。问题将此值定义为 $L$。\n$$L = 10 \\text{ 周期}$$\n\n乱序超标量处理器的性能受两个主要因素制约：\n$1$. 数据依赖，它定义了关键路径长度 ($L$)。总执行时间 $T$ 不能小于 $L$。\n$$T \\ge L$$\n$2$. 资源限制，主要是指令发射宽度 ($w$)。处理器每周期最多能发射 $w$ 条指令。要执行 $N$ 条指令，即使在无限并行的情况下，也需要一个最小周期数。\n$$w \\times T \\ge N \\implies T \\ge \\frac{N}{w}$$\n由于周期数 $T$ 必须是整数，因此基于资源的下限为 $T \\ge \\lceil \\frac{N}{w} \\rceil$。\n\n结合这两个界限，总执行时间 $T$ 必须至少是这两个下限中的最大值：\n$$T \\ge \\max\\left(L, \\left\\lceil \\frac{N}{w} \\right\\rceil\\right)$$\n让我们代入问题中的数值：\n$$T \\ge \\max\\left(10, \\left\\lceil \\frac{27}{4} \\right\\rceil\\right)$$\n$$T \\ge \\max(10, \\lceil 6.75 \\rceil)$$\n$$T \\ge \\max(10, 7)$$\n$$T \\ge 10 \\text{ 周期}$$\n\n这给出了执行时间的理论下限。我们现在需要验证 $T=10$ 个周期的执行时间是否可以实现。具有无限指令窗口的乱序机器中的最优调度器将尝试用独立指令填满每个周期的发射槽位。\n\n关键路径要求在 $10$ 个周期中的每一个周期内执行一条指令。这会占用每周期一个发射槽位。发射宽度为 $w=4$，因此在每个执行关键路径指令的周期中，还有 $w-1 = 4-1 = 3$ 个额外的发射槽位可用于独立指令。\n\n在由关键路径决定的 $L=10$ 个周期内，可用于独立指令的总槽位数量为：\n$$ \\text{可用于独立工作的槽位} = (w-1) \\times L = (4-1) \\times 10 = 30 $$\n需要执行的独立指令数量为 $17$。\n\n由于独立指令的数量 ($17$) 小于与关键路径并行执行它们所需的可用槽位数量 ($30$)，因此所有独立指令都可以在不将总执行时间延长到超过关键路径所需的 $10$ 个周期的情况下被发射和执行。\n\n让我们用一个明确的调度来说明：\n-   周期 $1$：发射 $I_1$（关键路径）和 $3$ 条独立指令。\n-   周期 $2$：发射 $I_2$（关键路径）和 $3$ 条独立指令。\n-   周期 $3$：发射 $I_3$（关键路径）和 $3$ 条独立指令。\n-   周期 $4$：发射 $I_4$（关键路径）和 $3$ 条独立指令。\n-   周期 $5$：发射 $I_5$（关键路径）和 $3$ 条独立指令。（总共发射了 $15$ 条独立指令）\n-   周期 $6$：发射 $I_6$（关键路径）和剩下的 $2$ 条独立指令。（此时所有 $17$ 条独立指令均已发射）\n-   周期 $7$：发射 $I_7$（关键路径）。\n-   周期 $8$：发射 $I_8$（关键路径）。\n-   周期 $9$：发射 $I_9$（关键路径）。\n-   周期 $10$：发射 $I_{10}$（关键路径）。\n\n在周期 $10$ 结束时，所有 $27$ 条指令都已发射。最后完成的指令是 $I_{10}$，它在周期 $10$ 发射，并因其单位延迟而在周期 $10$ 结束时完成。所有其他指令的完成时间不晚于此。\n因此，总执行时间确实由关键路径长度决定。\n$$T = L = 10 \\text{ 周期}$$\n\n最后，我们可以计算 IPC。\n$$ \\text{IPC} = \\frac{\\text{总指令数}}{\\text{总周期数}} = \\frac{N}{T} $$\n$$ \\text{IPC} = \\frac{27}{10} = 2.7 $$\n该基本块的预期稳态 IPC 为 $2.7$。", "answer": "$$\n\\boxed{2.7}\n$$", "id": "3651332"}, {"introduction": "处理器的资源限制不仅体现在总的指令发射宽度上，还体现在各类专用功能单元（如算术逻辑单元与加载/存储单元）的数量上。此练习 [@problem_id:3651306] 旨在探讨程序的指令混合比例如何与硬件执行资源相匹配，并揭示即使在某些资源闲置的情况下，饱和的“瓶颈”资源也会限制整体ILP。理解这一点对于设计均衡的微体系结构至关重要。", "problem": "一个乱序超标量处理器的设计具有以下执行资源和假设。该处理器有两个整数算术逻辑单元 (ALU) 和一个加载/存储单元 (LSU)。所有功能单元都完全流水线化，并且每个单元每个周期可以启动一个新的操作。指令窗口足够大，可以发掘所有可用的并行性，寄存器重命名是完美的，内存消歧是完美的，分支预测也是完美的；除了结构资源竞争之外的控制和数据依赖关系可以忽略。提交带宽不是瓶颈。任何周期内的发射宽度仅受可用功能单元可启动的操作数量的限制。内存系统是理想化的，在稳态下，LSU 每个周期可以启动一个内存操作。指令级并行 (ILP) 定义为每个周期完成的指令的稳态平均数，等效于以每周期指令数 (IPC) 为单位的稳态吞吐量。\n\n考虑两个独立的指令流，其动态混合仅由整数 ALU 操作和内存操作（加载或存储）组成，没有其他指令类型：\n\n- 整数密集型混合：整数 ALU 操作的比例为 $p_{\\text{ALU}}^{(I)} = \\frac{4}{5}$，内存操作的比例为 $p_{\\text{MEM}}^{(I)} = \\frac{1}{5}$。\n- 内存密集型混合：整数 ALU 操作的比例为 $p_{\\text{ALU}}^{(M)} = \\frac{2}{5}$，内存操作的比例为 $p_{\\text{MEM}}^{(M)} = \\frac{3}{5}$。\n\n仅使用流守恒推理以及由两个 ALU 和一个 LSU 所隐含的容量限制，确定每种混合的最大可持续指令级并行，然后计算整数密集型 ILP 与内存密集型 ILP 的比率。请以精确实数形式提供您的最终答案（不要四舍五入）。最终答案不需要单位。", "solution": "该问题要求计算在理想化的超标量处理器上，两种不同指令混合的最大可持续指令级并行 ($ILP$) 之间的比率。$ILP$ 定义为每个周期完成的指令的稳态平均数 ($IPC$)。处理器的性能受其功能单元容量的限制。问题指导使用“流守恒推理”，这意味着稳态吞吐量由首先饱和的资源决定，即瓶颈。\n\n设 $N_{ALU}$ 为整数算术逻辑单元 ($ALU$) 的数量， $N_{LSU}$ 为加载/存储单元 ($LSU$) 的数量。根据题目描述，处理器配备有：\n$$ N_{ALU} = 2 $$\n$$ N_{LSU} = 1 $$\n\n每个功能单元都是完全流水线化的，每个周期可以启动一个新操作。因此，$ALU$ 操作的最大速率是每周期 2 次，内存操作的最大速率是每周期 1 次。\n\n对于任何给定的动态指令流，设 $p_{ALU}$ 是 $ALU$ 操作的比例，$p_{MEM}$ 是内存操作的比例。如果处理器维持每周期 $I$ 条指令的总吞吐量，那么执行 $ALU$ 指令的速率为 $I \\times p_{ALU}$，执行内存指令的速率为 $I \\times p_{MEM}$。\n\n为了使稳态成为可能，每种资源的需求不能超过其容量。这导致了对 $I$ 的最大可能值的两个独立约束：\n\n1.  $ALU$ 约束：$ALU$ 指令的执行速率不能超过总的 $ALU$ 容量。\n    $$ I \\times p_{ALU} \\le N_{ALU} \\implies I \\le \\frac{N_{ALU}}{p_{ALU}} $$\n2.  $LSU$ 约束：内存指令的执行速率不能超过总的 $LSU$ 容量。\n    $$ I \\times p_{MEM} \\le N_{LSU} \\implies I \\le \\frac{N_{LSU}}{p_{MEM}} $$\n\n最大可持续 $ILP$ (我们将其表示为 $ILP_{max}$) 是同时满足这两个约束的 $I$ 的最高值。该值由两个上界中更具限制性的一个决定，对应于瓶颈资源。\n$$ ILP_{max} = \\min\\left(\\frac{N_{ALU}}{p_{ALU}}, \\frac{N_{LSU}}{p_{MEM}}\\right) $$\n\n我们现在将此框架应用于提供的两种指令混合。\n\n**整数密集型混合 (I)**\n对于这种混合，比例为 $p_{\\text{ALU}}^{(I)} = \\frac{4}{5}$ 和 $p_{\\text{MEM}}^{(I)} = \\frac{1}{5}$。\n$ALU$ 资源对 $ILP$ 施加的上限是：\n$$ I_{ALU-bound}^{(I)} = \\frac{N_{ALU}}{p_{\\text{ALU}}^{(I)}} = \\frac{2}{4/5} = \\frac{2 \\times 5}{4} = \\frac{10}{4} = 2.5 $$\n$LSU$ 资源对 $ILP$ 施加的上限是：\n$$ I_{LSU-bound}^{(I)} = \\frac{N_{LSU}}{p_{\\text{MEM}}^{(I)}} = \\frac{1}{1/5} = 5 $$\n整数密集型混合的最大可持续 $ILP$ ($ILP_I$) 是这两个上界的最小值：\n$$ ILP_I = \\min(2.5, 5) = 2.5 $$\n在这种情况下，两个 $ALU$ 是瓶颈。\n\n**内存密集型混合 (M)**\n对于这种混合，比例为 $p_{\\text{ALU}}^{(M)} = \\frac{2}{5}$ 和 $p_{\\text{MEM}}^{(M)} = \\frac{3}{5}$。\n$ALU$ 资源对 $ILP$ 施加的上限是：\n$$ I_{ALU-bound}^{(M)} = \\frac{N_{ALU}}{p_{\\text{ALU}}^{(M)}} = \\frac{2}{2/5} = \\frac{2 \\times 5}{2} = 5 $$\n$LSU$ 资源对 $ILP$ 施加的上限是：\n$$ I_{LSU-bound}^{(M)} = \\frac{N_{LSU}}{p_{\\text{MEM}}^{(M)}} = \\frac{1}{3/5} = \\frac{5}{3} $$\n内存密集型混合的最大可持续 $ILP$ ($ILP_M$) 是这两个上界的最小值：\n$$ ILP_M = \\min\\left(5, \\frac{5}{3}\\right) = \\frac{5}{3} $$\n在这种情况下，单个 $LSU$ 是瓶颈。\n\n**比率计算**\n最后，我们计算整数密集型 $ILP$ 与内存密集型 $ILP$ 的比率：\n$$ \\text{Ratio} = \\frac{ILP_I}{ILP_M} $$\n代入计算出的值：\n$$ \\text{Ratio} = \\frac{2.5}{5/3} = \\frac{5/2}{5/3} = \\frac{5}{2} \\times \\frac{3}{5} = \\frac{15}{10} = \\frac{3}{2} $$\n将此表示为精确实数，得到 $1.5$。", "answer": "$$\\boxed{1.5}$$", "id": "3651306"}, {"introduction": "我们需要区分两种依赖：一种是真正的数据流依赖（RAW），它是算法固有的；另一种是由于指令集体系结构（ISA）中资源命名方式而产生的“伪”依赖（WAR 和 WAW）。通过一个共享状态寄存器（标志位）的经典例子，本练习 [@problem_id:3654313] 生动地展示了伪依赖如何不必要地串行化本可并行的代码，并阐明了为何像寄存器重命名这样的现代微架构技术对于发掘更高层次的ILP至关重要。", "problem": "一个现代的乱序超标量核心试图通过重叠独立的指令来发掘指令级并行（ILP），但这受限于数据相关和资源约束。考虑一台具有以下特性的机器：无限的功能单元、所有整数操作的单周期延迟、按序引退、通用寄存器重命名，以及一个单一的架构状态寄存器（SR），其持有条件码（CC），如进位标志（CF）和零标志（ZF）。每个生成标志的指令将整个SR作为一个架构名称进行写入，每个消耗标志的指令读取程序顺序中最近的前一个生成标志的指令所产生的SR值。在该代码块内没有控制流的改变，并且我们假设块外的推测执行和分支预测是完美的。该代码块是：\n\n- $I_1$: $ADD~r_1, r_2$；写入 $SR$。\n- $I_2$: $ADC~r_3, r_4$；从最近的前一个 $SR$ 写入者读取 $CF$，然后写入 $SR$。\n- $I_3$: $CMP~r_5, r_6$；写入 $SR$。\n- $I_4$: $CMOVZ~r_7, r_8$；从最近的前一个 $SR$ 写入者读取 $ZF$；不写入 $SR$。\n- $I_5$: $ADD~r_9, r_{10}$；写入 $SR$。\n- $I_6$: $CMOVC~r_{11}, r_{12}$；从最近的前一个 $SR$ 写入者读取 $CF$；不写入 $SR$。\n\n所有通用寄存器 $r_i$ 都是不同的，并且在指令间不重用，因此通用寄存器之间没有数据相关。唯一的相关性来自于对 $SR$ 的读写。该机器最初不支持标志重命名；之后，我们考虑一个可以重命名 $SR$ 的变体，为每个生成标志的指令分配一个不同的物理标志版本，并将每个消耗标志的指令链接到相应的生产者版本，从而在保留架构语义的同时消除对单一 $SR$ 的伪名相关。\n\n使用数据相关（写后读、读后写和写后写）的基本定义以及定义消费者必须观察哪个 $SR$ 值的程序顺序语义，确定以下哪些陈述是正确的：\n\nA. 在没有标志重命名的情况下，$SR$ 作为一个单一的架构名称，在 $I_1$ 到 $I_6$ 之间引入了一系列的写后读、读后写和写后写相关，迫使所有六条指令串行化；最小完成时间为 $6$ 个周期，该块的平均 $ILP$ 为 $1$。\n\nB. 在有标志重命名的情况下，三个生产者-消费者对 $\\left(I_1 \\rightarrow I_2\\right)$、$\\left(I_3 \\rightarrow I_4\\right)$ 和 $\\left(I_5 \\rightarrow I_6\\right)$ 成为独立的链，其消费者仅对其自身的生产者有写后读相关；通过在周期 $1$ 发射 $I_1$、$I_3$、$I_5$ 并在周期 $2$ 发射 $I_2$、$I_4$、$I_6$，最小完成时间减少到 $2$ 个周期，产生的平均 $ILP$ 为 $3$。\n\nC. 标志重命名消除了对标志的写后读相关，因此 $I_2$、$I_4$ 和 $I_6$ 可以分别与 $I_1$、$I_3$ 和 $I_5$ 在同一周期发射。\n\nD. 在没有标志重命名时观察到的串行化，根本上是由于单一 $SR$ 上的伪名相关（写后写和读后写），这些相关将本应独立的生产者-消费者链连接在一起，并阻止了乱序调度器对它们进行重叠。\n\nE. 即使没有标志重命名，$I_3$ 和 $I_5$ 也可以并行发射，因为它们写入不同的条件码位（$ZF$ 和 $CF$），因此在 $SR$ 上没有写后写冒险。\n\n选择所有适用的选项。", "solution": "在进行解答之前，首先对问题陈述的有效性进行严格分析。\n\n### 步骤 1：提取已知条件\n- **机器模型**：乱序超标量核心，无限功能单元，通用寄存器重命名，按序引退。\n- **指令延迟**：所有整数操作都具有单周期延迟。\n- **无重命名的状态寄存器 ($SR$)**：存在一个单一的架构状态寄存器 ($SR$)，包含进位标志 ($CF$) 和零标志 ($ZF$) 等条件码。每个生成标志的指令都将*整个* $SR$ 作为一个单一的架构名称进行写入。每个消耗标志的指令都从程序顺序中最近的前一个生成标志的指令读取 $SR$ 值。\n- **有重命名的状态寄存器 ($SR$)**：另一种机器配置支持重命名 $SR$。对 $SR$ 的每次写入都被分配一个不同的物理版本，并且消费者被链接到正确的版本，从而消除伪名相关（写后写和读后写）。\n- **指令序列**：\n    - $I_1$: $ADD~r_1, r_2$；写入 $SR$。\n    - $I_2$: $ADC~r_3, r_4$；从 $I_1$ 读取 $CF$，然后写入 $SR$。\n    - $I_3$: $CMP~r_5, r_6$；写入 $SR$。\n    - $I_4$: $CMOVZ~r_7, r_8$；从 $I_3$ 读取 $ZF$；不写入 $SR$。\n    - $I_5$: $ADD~r_9, r_{10}$；写入 $SR$。\n    - $I_6$: $CMOVC~r_{11}, r_{12}$；从 $I_5$ 读取 $CF$；不写入 $SR$。\n- **数据相关**：通用寄存器 $r_i$ 都是不同的，因此它们之间不存在相关性。相关性仅由 $SR$ 产生。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学基础**：该问题很好地植根于计算机组成和体系结构的原理，特别是关注指令级并行（$ILP$）、数据相关（写后读、写后写、读后写）和寄存器重命名。这些是现代高性能处理器设计中的基本概念。\n- **良构性**：问题定义清晰。机器模型、指令语义和相关性规则都已明确，允许在两种指定场景下（有和没有标志重命名）对指令块的执行时间和 $ILP$ 进行唯一且确定性的分析。\n- **客观性**：语言是技术性的、精确的，没有主观或模糊的术语。诸如“将整个SR作为一个架构名称进行写入”之类的约束是明确的，并且对分析至关重要。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。这是一个良构的、科学上合理的问题，可以通过严格应用数据相关性分析来解决。\n\n### 推导与选项分析\n\n让我们分析两种情况下的数据相关和执行调度。从指令 $I_i$到 $I_j$ 的相关表示为 $I_i \\rightarrow I_j$。\n\n**情况 1：无标志重命名**\n\n在这种情况下，$SR$ 是一个单一的架构寄存器。我们必须识别所有三种类型的数据相关：\n- **写后读 (RAW)**：真相关，即一条指令消耗由前一条指令产生的值。\n    - $I_1 \\rightarrow I_2$：$I_2$ 读取由 $I_1$ 产生的 $CF$。\n    - $I_3 \\rightarrow I_4$：$I_4$ 读取由 $I_3$ 产生的 $ZF$。\n    - $I_5 \\rightarrow I_6$：$I_6$ 读取由 $I_5$ 产生的 $CF$。\n- **写后写 (WAW)**：伪（名）相关，即两条指令写入同一位置。为确保最终状态正确，写入必须按程序顺序发生。问题陈述中说明整个 $SR$ 被作为一个名称写入。\n    - $I_1 \\rightarrow I_2$, $I_1 \\rightarrow I_3$, $I_1 \\rightarrow I_5$\n    - $I_2 \\rightarrow I_3$, $I_2 \\rightarrow I_5$\n    - $I_3 \\rightarrow I_5$\n- **读后写 (WAR)**：伪（名）相关，即一条指令写入一个被前序指令读取的位置。写入操作不能在读取完成之前完成。\n    - $I_2 \\rightarrow I_3$：$I_2$ 读取 $SR$（来自 $I_1$），而 $I_3$ 写入 $SR$。为了保持语义，$I_2$ 必须读取来自 $I_1$ 的值，而不是来自后面的指令 $I_3$。这迫使 $I_3$ 等待 $I_2$ 发射并读取其源操作数之后。\n    - $I_4 \\rightarrow I_5$：$I_4$ 读取 $SR$（来自 $I_3$），而 $I_5$ 写入 $SR$。这迫使 $I_5$ 等待 $I_4$ 读取其源操作数。\n\n综合这些相关性，我们形成了一个单一的相关链：\n$I_1 \\xrightarrow{\\text{RAW}} I_2 \\xrightarrow{\\text{WAR/WAW}} I_3 \\xrightarrow{\\text{RAW}} I_4 \\xrightarrow{\\text{WAR}} I_5 \\xrightarrow{\\text{RAW}} I_6$。\n这种完全的串行化意味着一次只能执行一条指令。鉴于每条指令的延迟为单周期，执行过程如下：\n- 周期 $1$：$I_1$ 执行。\n- 周期 $2$：$I_2$ 执行。\n- 周期 $3$：$I_3$ 执行。\n- 周期 $4$：$I_4$ 执行。\n- 周期 $5$：$I_5$ 执行。\n- 周期 $6$：$I_6$ 执行。\n完成这 $6$ 条指令的总时间是 $6$ 个周期。平均指令级并行（$ILP$）是指令数除以周期数，即 $6/6 = 1$。\n\n**情况 2：有标志重命名**\n\n标志重命名通过为 $SR$ 的每个新值分配一个唯一的物理存储位置来消除伪名相关（WAW 和 WAR）。只剩下真数据相关（RAW）。\nRAW 相关如下：\n1.  $I_1 \\rightarrow I_2$\n2.  $I_3 \\rightarrow I_4$\n3.  $I_5 \\rightarrow I_6$\n\n伪相关（$I_2 \\rightarrow I_3$，$I_4 \\rightarrow I_5$ 等）被移除。这把单一的长链分解为三个独立的短链。由于有无限的功能单元，这三个链可以并行执行。\n执行调度如下：\n- **周期 1**：每个链的头部指令，没有未决的相关性，可以同时发射：$I_1, I_3, I_5$。它们都在这个周期内完成。\n- **周期 2**：来自 $I_1, I_3,$ 和 $I_5$ 的结果现在可用。相关的指令 $I_2, I_4,$ 和 $I_6$ 可以同时发射。它们都在这个周期内完成。\n完成所有 $6$ 条指令的总时间是 $2$ 个周期。平均 $ILP$ 是 $6 / 2 = 3$。\n\n### 逐项选项分析\n\n**A. 在没有标志重命名的情况下，$SR$ 作为一个单一的架构名称，在 $I_1$ 到 $I_6$ 之间引入了一系列的写后读、读后写和写后写相关，迫使所有六条指令串行化；最小完成时间为 $6$ 个周期，该块的平均 $ILP$ 为 $1$。**\n我们对情况 1 的分析完全证实了这一陈述。单一 $SR$ 上的 RAW、WAR 和 WAW 相关组合创建了一个串行依赖链，导致执行时间为 $6$ 个周期， $ILP$ 为 $1$。\n**结论：正确。**\n\n**B. 在有标志重命名的情况下，三个生产者-消费者对 $\\left(I_1 \\rightarrow I_2\\right)$、$\\left(I_3 \\rightarrow I_4\\right)$ 和 $\\left(I_5 \\rightarrow I_6\\right)$ 成为独立的链，其消费者仅对其自身的生产者有写后读相关；通过在周期 $1$ 发射 $I_1$、$I_3$、$I_5$ 并在周期 $2$ 发射 $I_2$、$I_4$、$I_6$，最小完成时间减少到 $2$ 个周期，产生的平均 $ILP$ 为 $3$。**\n我们对情况 2 的分析完全证实了这一陈述。重命名消除了伪相关，留下了三个独立的 RAW 链。并行执行调度、2 个周期的完成时间以及 3 的平均 $ILP$ 都是正确的。\n**结论：正确。**\n\n**C. 标志重命名消除了对标志的写后读相关，因此 $I_2$、$I_4$ 和 $I_6$ 可以分别与 $I_1$、$I_3$ 和 $I_5$ 在同一周期发射。**\n这个陈述根本上是错误的。寄存器重命名是一种消除*伪*（名）相关（WAR 和 WAW）的技术，而不是*真*数据相关（RAW）。RAW 相关代表了从生产者到消费者的基本数据流；消费者在收到数据之前无法执行。因此，像 $I_2$ 这样的消费者必须等待其生产者 $I_1$ 完成。声称它们可以在同一周期发射是错误的。\n**结论：不正确。**\n\n**D. 在没有标志重命名时观察到的串行化，根本上是由于单一 $SR$ 上的伪名相关（写后写和读后写），这些相关将本应独立的生产者-消费者链连接在一起，并阻止了乱序调度器对它们进行重叠。**\n这个陈述为两种情况之间的性能差异提供了正确的概念性原因。三个生产者-消费者对 $(I_1, I_2)$、$(I_3, I_4)$ 和 $(I_5, I_6)$ 在数据流方面是逻辑上独立的。然而，没有重命名时，对单一架构名称“$SR$”的重用产生了伪 WAR 和 WAW 相关（例如，在 $I_2$ 和 $I_3$ 之间，以及在 $I_4$ 和 $I_5$ 之间），这些相关将这些链连接在一起，迫使串行执行。这正是寄存器重命名所解决的问题。\n**结论：正确。**\n\n**E. 即使没有标志重命名，$I_3$ 和 $I_5$ 也可以并行发射，因为它们写入不同的条件码位（$ZF$ 和 $CF$），因此在 $SR$ 上没有写后写冒险。**\n这个陈述与问题的一个关键前提相矛盾：“每个生成标志的指令都将**整个 SR 作为一个架构名称**进行写入。”这意味着硬件将 $SR$ 视为一个原子单元。任何写入都是对整个寄存器的写入，无论修改的是哪个单独的位。因此，在 $I_3$ 和 $I_5$ 之间存在 WAW 相关，阻止了它们的并行执行。所描述的机器不支持此选项所暗示的子寄存器粒度。\n**结论：不正确。**", "answer": "$$\\boxed{ABD}$$", "id": "3654313"}]}