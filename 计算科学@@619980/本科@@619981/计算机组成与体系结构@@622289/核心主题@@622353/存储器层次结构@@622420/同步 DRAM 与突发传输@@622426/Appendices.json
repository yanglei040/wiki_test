{"hands_on_practices": [{"introduction": "SDRAM的时序参数，如列地址选通延迟（$CL$）和行地址到列地址延迟（$t_{RCD}$），并非抽象符号，它们直接决定了可观测的性能。本练习模拟了一个常见的校准任务：通过测量行命中（row hit）和行未命中（row miss）时的访问延迟，来反向推导这些关键的底层硬件时序。这个实践将加深你对指令序列如何转化为实际延迟的理解，并揭示了不同内存访问模式下性能差异的根本原因。[@problem_id:3684083]", "problem": "一项实验室性能剖析工作旨在通过观测读事务的首个数据拍延迟，来校准双倍数据速率同步动态随机存取存储器 (DDR SDRAM) 通道的命令时序参数。在此设置中，对一个已打开行的读取（行命中）仅需发出一个 READ 命令，而对一个已关闭行的读取（行未命中）则需要在发出 READ 命令之前，先发出一个 ACTIVATE 命令来打开该行。假设时序环境如下：只有一个未完成的读请求，命令总线每个时钟周期可以接受一个命令，没有附加延迟，并且总线在其他情况下是空闲的，因此没有总线方向转换或体冲突。命令和数据都由同一个同步时钟锁存；所有延迟均以时钟周期为单位进行测量。\n\n首个数据拍延迟定义为：从内存控制器为处理该读取而发出所需的最早命令（对于行未命中是 ACTIVATE，对于行命中是 READ）的那个周期，到第一个数据拍出现在数据总线上的那个周期之间的时钟周期数。\n\n以下量是同步动态随机存取存储器 (SDRAM) 的标准时序参数：\n- 列地址选通延迟 ($CL$)，即从发出 READ 命令到出现第一个数据拍之间的延迟。\n- 行至列延迟 ($t_{RCD}$)，即从发出 ACTIVATE 命令到可以对该行发出 READ 命令的最小延迟。\n- 突发长度 ($BL$)，即一次突发读取返回的数据拍数量；首拍延迟只关心到第一个数据拍的时间，而不关心整个突发的完成。\n\n在一次突发长度 $BL=8$ 的校准运行中，您观测到以下首个数据拍延迟：\n- 行未命中首拍延迟 $T = 14$ 个时钟周期。\n- 行命中首拍延迟 $H = 10$ 个时钟周期。\n\n仅使用上述定义，求解 $CL$ 和 $t_{RCD}$ 的值（以时钟周期为单位）。然后，通过考虑在 $BL=4$ 下的第二次运行来验证首拍延迟与 $BL$ 的无关性：预测在 $BL=4$ 时的行命中和行未命中首拍延迟（以时钟周期为单位），并根据定义解释它们是否与 $BL=8$ 的情况有所不同。以时钟周期为单位，给出 $CL$ 和 $t_{RCD}$ 的最终值。无需四舍五入。", "solution": "该问题是有效的，因为它科学上基于计算机内存体系结构的原理，问题提法得当，数据充分且一致，并用客观、正式的语言表述。我们可以进行正式求解。\n\n问题要求根据观测到的行命中和行未命中的首个数据拍延迟，来确定两个基本的同步动态随机存取存储器 (SDRAM) 时序参数：列地址选通延迟 ($CL$) 和行至列延迟 ($t_{RCD}$)。\n\n让我们首先根据所提供的定义，将观测到的延迟与时序参数之间的关系形式化。所有延迟都以时钟周期为单位测量。\n\n1.  **行命中延迟 ($H$)**：对一个已打开行的读取被称为行命中。该过程涉及发出一个单一的 READ 命令。行命中的首个数据拍延迟 $H$ 定义为从发出 READ 命令到第一个数据拍出现在数据总线上的时钟周期数。根据定义，这个延迟就是列地址选通延迟，$CL$。\n    $$H = CL$$\n    已知观测到的行命中延迟为 $H = 10$ 个时钟周期，我们可以直接确定 $CL$：\n    $$CL = 10$$\n\n2.  **行未命中延迟 ($T$)**：对一个已关闭行的读取是行未命中。这需要两个顺序的命令：一个用于打开行的 ACTIVATE 命令，随后是一个用于选择该行内列的 READ 命令。\n    -   对于行未命中，其首个数据拍延迟 $T$ 是从发出第一个必要命令 (ACTIVATE) 的那个周期开始测量的。让我们将发出 ACTIVATE 的周期记为周期 $0$。\n    -   行至列延迟 $t_{RCD}$ 是从发出 ACTIVATE 命令到可以对同一行发出 READ 命令的最小延迟。因此，READ 命令不能在周期 $t_{RCD}$ 之前发出。问题陈述了命令总线每个周期可以接受一个命令并且在其他情况下是空闲的。由于总线约束，READ 命令最早可以在周期 $1$ 发出；而由于时序约束，它必须在周期 $t_{RCD}$ 或之后发出。因此，READ 命令在周期 $\\max(1, t_{RCD})$ 发出。由于物理 DRAM 的时序总是满足 $t_{RCD} > 1$，所以 READ 命令在周期 $t_{RCD}$ 发出。\n    -   一旦 READ 命令在周期 $t_{RCD}$ 发出，还需要额外的 $CL$ 个周期，第一个数据拍才会出现。\n    -   因此，数据在周期 $t_{RCD} + CL$ 出现。\n    -   从周期 $0$ 开始测量的总延迟 $T$ 是这两个延迟之和。\n    $$T = t_{RCD} + CL$$\n    已知观测到的行未命中延迟为 $T = 14$ 个时钟周期，并且我们已经求得 $CL = 10$，我们可以求解 $t_{RCD}$：\n    $$14 = t_{RCD} + 10$$\n    $$t_{RCD} = 14 - 10$$\n    $$t_{RCD} = 4$$\n    因此，时序参数为 $CL = 10$ 个时钟周期和 $t_{RCD} = 4$ 个时钟周期。\n\n3.  **与突发长度 ($BL$) 的无关性**：问题要求预测突发长度为 $BL=4$ 时的延迟，并解释与 $BL=8$ 的情况相比是否有任何变化。\n    -   参数 $CL$ 被定义为到*第一个数据拍*的延迟。\n    -   参数 $t_{RCD}$ 是 ACTIVATE 和 READ 命令之间的延迟，它完全发生在数据传输之前。\n    -   对于行命中和行未命中，首拍延迟根据定义只关心直到*第一个*数据拍到达的时间。推导出的表达式 $H = CL$ 和 $T = t_{RCD} + CL$ 仅依赖于这两个参数。\n    -   突发长度 ($BL$) 决定了在支付了初始访问延迟*之后*传输的连续数据拍的数量。例如，在突发长度为 $BL=8$ 时，会返回八个连续的数据拍，通常从第一个数据拍到达的周期开始，并持续几个后续周期（取决于数据总线宽度和时钟方案，例如，对于具有 $8$ 拍突发的 DDR，需要 $4$ 个周期）。将 $BL$ 更改为 $4$ 意味着只返回四个数据拍。\n    -   由于 $H$ 和 $T$ 的定义完全基于*第一个*数据拍的到达，因此它们从根本上独立于突发中的总数据拍数。\n    -   因此，将突发长度从 $BL=8$ 更改为 $BL=4$ 不会影响首拍延迟。在 $BL=4$ 时预测的延迟将与在 $BL=8$ 时观测到的延迟相同：\n        -   在 $BL=4$ 时预测的行命中延迟 ($H'$)：$H' = CL = 10$ 个时钟周期。\n        -   在 $BL=4$ 时预测的行未命中延迟 ($T'$)：$T' = t_{RCD} + CL = 4 + 10 = 14$ 个时钟周期。\n\n所请求参数的最终值为 $CL = 10$ 个时钟周期和 $t_{RCD} = 4$ 个时钟周期。", "answer": "$$\\boxed{\\begin{pmatrix} 10  4 \\end{pmatrix}}$$", "id": "3684083"}, {"introduction": "在理解了 $CL$ 和 $t_{RCD}$ 等基本时序参数后，我们将更进一步，像内存控制器一样思考。本练习提供一个指令序列，你的任务是检查其是否违反了SDRAM规范中定义的多个时序约束，如 $t_{RAS}$ 和 $t_{RC}$。通过识别并修正这些时序违规，你将亲身体验确保内存操作正确执行所涉及的精密调度过程，并理解各指令间复杂的时序依赖关系。[@problem_id:3684049]", "problem": "一个内存控制器以一个同步动态随机存取存储器 (SDRAM) 设备为目标，并发出了一系列分 bank 命令。该控制器必须遵守标准定义的命令到命令之间的最小间隔的 per-bank 时序约束。对于单个 bank，需要强制执行的主要约束如下：\n\n- 行至列延迟 (tRCD)：在对同一 bank 发出激活 (ACT) 命令后，必须经过至少 $t_{RCD}$ 个周期才能发出后续的读取 (READ) 命令。\n- 行有效时间 (tRAS)：在对同一 bank 发出激活 (ACT) 命令后，必须经过至少 $t_{RAS}$ 个周期才能发出后续的预充电 (PRE) 命令。\n- 行预充电时间 (tRP)：在对同一 bank 发出预充电 (PRE) 命令后，必须经过至少 $t_{RP}$ 个周期才能发出后续的激活 (ACT) 命令。\n- 行周期时间 (tRC)：在对同一 bank 的连续激活 (ACT) 命令之间，必须经过至少 $t_{RC}$ 个周期。\n- 读取到预充电 (tRTP)：在对同一 bank 发出读取 (READ) 命令后，必须经过至少 $t_{RTP}$ 个周期才能发出后续的预充电 (PRE) 命令。\n\n其他相关参数包括列地址选通 (CAS) 延迟 (CL) 和突发长度 (BL)。您可以假设读取到预充电约束 $t_{RTP}$ 已经包含了与读取流水线相关的必要限制，并且一旦 $t_{RTP}$ 和 $t_{RAS}$ 都得到满足，就允许显式预充电。可以根据需要插入无操作 (NOP) 周期，但必须保留原始的命令顺序。\n\n考虑单个 bank $B0$，其时序参数如下，均以时钟周期表示：$t_{RCD}=3$，$t_{RAS}=6$，$t_{RP}=3$，$t_{RC}=9$，$t_{RTP}=2$，$CL=3$，$BL=4$。控制器在指定的时钟周期发出以下命令序列（周期索引从 $0$ 开始）：\n\n- 周期 $0$：ACT $B0$\n- 周期 $2$：READ $B0$\n- 周期 $5$：PRE $B0$\n- 周期 $7$：ACT $B0$\n- 周期 $9$：READ $B0$\n- 周期 $12$：PRE $B0$\n\n哪个选项正确地指出了上述调度中所有违反的时序约束，并提供了最早的修正后周期号（不重新排序，仅插入最少的必要空闲周期），使得该序列相对于所有陈述的约束都合法？\n\nA. 违规：周期 $2$ 的 $t_{RCD}$，周期 $5$ 的 $t_{RAS}$，周期 $7$ 的 $t_{RP}$。最早的修正：将周期 $2$ 的 READ 移至周期 $3$，将周期 $5$ 的 PRE 移至周期 $6$，将周期 $7$ 的 ACT 移至周期 $8$；保持周期 $9$ 的 READ 和周期 $12$ 的 PRE 不变。\n\nB. 违规：周期 $2$ 和 $9$ 的 $t_{RCD}$，周期 $5$ 和 $12$ 的 $t_{RAS}$，周期 $7$ 的 $t_{RP}$ 和 $t_{RC}$。最早的修正：将周期 $2$ 的 READ 移至周期 $3$，将周期 $5$ 的 PRE 移至周期 $6$，将周期 $7$ 的 ACT 移至周期 $9$，将周期 $9$ 的 READ 移至周期 $12$，将周期 $12$ 的 PRE 移至周期 $15$。\n\nC. 违规：仅周期 $5$ 和 $12$ 的 $t_{RTP}$。最早的修正：将周期 $5$ 的 PRE 移至周期 $6$，将周期 $12$ 的 PRE 移至周期 $11$；所有其他命令保持不变。\n\nD. 违规：仅周期 $7$ 的 $t_{RC}$。最早的修正：将周期 $7$ 的 ACT 移至周期 $9$；保持所有其他命令的时间不变。\n\nE. 违规：周期 $2$ 和 $9$ 的 $t_{RCD}$，周期 $5$ 和 $12$ 的 $t_{RAS}$，周期 $7$ 的 $t_{RP}$ 和 $t_{RC}$。使用数据突发完成作为门控条件的修正：将周期 $2$ 的 READ 移至周期 $3$，将周期 $5$ 的 PRE 移至周期 $10$，将周期 $7$ 的 ACT 移至周期 $13$，将周期 $9$ 的 READ 移至周期 $16$，将周期 $12$ 的 PRE 移至周期 $22$。", "solution": "从核心的 SDRAM per-bank 时序定义开始：\n\n- 对一个给定的 bank 发出 ACTIVATE 后，必须经过至少 $t_{RCD}$ 个周期才能对该 bank 发出 READ。\n- 对一个给定的 bank 发出 ACTIVATE 后，必须经过至少 $t_{RAS}$ 个周期才能对该 bank 发出 PRECHARGE。\n- 对一个给定的 bank 发出 PRECHARGE 后，必须经过至少 $t_{RP}$ 个周期才能对该 bank 发出下一个 ACTIVATE。\n- 对同一个 bank 的两个 ACTIVATE 命令之间，必须经过至少 $t_{RC}$ 个周期。\n- 对一个给定的 bank 发出 READ 后，必须经过至少 $t_{RTP}$ 个周期才能对该 bank 发出 PRECHARGE。\n\n所有参数都是 per-bank 的，并以周期为单位给出：$t_{RCD}=3$, $t_{RAS}=6$, $t_{RP}=3$, $t_{RC}=9$, $t_{RTP}=2$，$CL=3$ 和 $BL=4$ 是为了完整性而提供。我们允许插入空闲周期 (NOPs)，但不允许重新排序命令。\n\n逐步评估给定的调度：\n\n- 周期 $0$：ACT $B0$。这在周期 $0$ 打开一个行。\n\n- 周期 $2$：READ $B0$。检查 $t_{RCD}$：周期 $0$ 的 ACT 要求 READ 不早于周期 $0 + t_{RCD} = 0 + 3 = 3$。在周期 $2$ 发出违反了 $t_{RCD}$。因此，最早合法的 READ 在周期 $3$。\n\n- 周期 $5$：PRE $B0$。适用两个检查：\n  1) ACT 和 PRE 之间的 $t_{RAS}$：PRE 必须不早于周期 $0 + t_{RAS} = 0 + 6 = 6$。在周期 $5$ 发出违反了 $t_{RAS}$。\n  2) READ 和 PRE 之间的 $t_{RTP}$：如果 READ 被移动到周期 $3$（按要求），PRE 必须不早于周期 $3 + t_{RTP} = 3 + 2 = 5$。结合两者，PRE 必须同时满足这两个约束，所以最早合法的 PRE 在 $\\max(6,5) = 6$。因此，在周期 $5$ 发出是非法的，因为违反了 $t_{RAS}$。\n\n- 周期 $7$：ACT $B0$。对下一个 ACT 适用两个检查：\n  1) 从前一个 PRE 开始的 $t_{RP}$：将 PRE 修正到周期 $6$后，下一个 ACT 必须不早于周期 $6 + t_{RP} = 6 + 3 = 9$。在周期 $7$ 发出违反了 $t_{RP}$。\n  2) 从前一个 ACT 开始的 $t_{RC}$：下一个 ACT 必须不早于周期 $0 + t_{RC} = 0 + 9 = 9$。在周期 $7$ 发出也违反了 $t_{RC}$。因此，最早合法的 ACT 在周期 $9$。\n\n- 周期 $9$：READ $B0$。将 ACT 修正到周期 $9$后，检查 $t_{RCD}$：READ 必须不早于周期 $9 + t_{RCD} = 9 + 3 = 12$。在周期 $9$ 发出违反了 $t_{RCD}$。最早合法的 READ 在周期 $12$。\n\n- 周期 $12$：PRE $B0$。适用两个检查：\n  1) 从第二个 ACT（在周期 $9$）开始的 $t_{RAS}$：PRE 必须不早于周期 $9 + t_{RAS} = 9 + 6 = 15$。\n  2) 从第二个 READ（在周期 $12$）开始的 $t_{RTP}$：PRE 必须不早于周期 $12 + t_{RTP} = 12 + 2 = 14$。\nPRE 必须满足两者，因此最早合法的 PRE 在 $\\max(15,14) = 15$。在周期 $12$ 发出违反了 $t_{RAS}$。\n\n原始调度中的违规总结：\n- 周期 $2$ 的 READ 和周期 $9$ 的 READ 违反了 $t_{RCD}$。\n- 周期 $5$ 的 PRE 和周期 $12$ 的 PRE 违反了 $t_{RAS}$。\n- 周期 $7$ 的 ACT 违反了 $t_{RP}$ 和 $t_{RC}$。\n\n最早的修正后调度，保留顺序且仅插入必要的空闲周期：\n- ACT 在周期 $0$（不变）。\n- READ 在周期 $3$（满足 $t_{RCD}$ 的最早时间）。\n- PRE 在周期 $6$（同时满足 $t_{RAS}$ 和 $t_{RTP}$ 的最早时间）。\n- ACT 在周期 $9$（同时满足 $t_{RP}$ 和 $t_{RC}$ 的最早时间）。\n- READ 在周期 $12$（满足 $t_{RCD}$ 的最早时间）。\n- PRE 在周期 $15$（同时满足 $t_{RAS}$ 和 $t_{RTP}$ 的最早时间）。\n\n注意，$CL=3$ 和 $BL=4$ 意味着第一次读取的数据从周期 $3+3=6$ 开始返回，持续 $4$ 个周期（周期 $6$ 到 $9$），这与只要满足 $t_{RTP}$ 和 $t_{RAS}$ 就允许在周期 $6$ 进行 PRE 的情况是一致的；问题陈述规定一旦 $t_{RTP}$ 和 $t_{RAS}$ 都得到满足，就允许显式预充电。\n\n逐个选项分析：\n\n- 选项 A：仅列出了周期 $2$ 的 $t_{RCD}$，周期 $5$ 的 $t_{RAS}$，和周期 $7$ 的 $t_{RP}$，遗漏了周期 $7$ 的 $t_{RC}$ 违规和周期 $9$ 的第二次 $t_{RCD}$ 违规，以及周期 $12$ 的 $t_{RAS}$ 违规。它提议的在周期 $8$ 的 ACT 也违反了 $t_{RC}$ 和 $t_{RP}$，并且将 READ 留在周期 $9$ 会相对于修正后的 ACT 违反 $t_{RCD}$。不正确。\n\n- 选项 B：识别了所有违规（周期 $2$ 和 $9$ 的 $t_{RCD}$，周期 $5$ 和 $12$ 的 $t_{RAS}$，以及周期 $7$ 的 $t_{RP}$ 和 $t_{RC}$）并给出了最早的修正周期：READ 在 $3$，PRE 在 $6$，ACT 在 $9$，READ 在 $12$，PRE 在 $15$。正确。\n\n- 选项 C：声称仅有 PRE 命令的 $t_{RTP}$ 违规。这是不正确的，因为原始在周期 $5$ 的 PRE 已经满足了来自原始在周期 $2$ 的 READ 的 $t_{RTP}$（差值 $3 \\ge 2$），并且原始在周期 $12$ 的 PRE 满足了来自周期 $9$ 的 READ 的 $t_{RTP}$（差值 $3 \\ge 2$）。此外，它忽略了 $t_{RCD}$、$t_{RAS}$、$t_{RP}$ 和 $t_{RC}$ 的违规。不正确。\n\n- 选项 D：声称仅有周期 $7$ 的 $t_{RC}$ 违规，并提议将 ACT 移至周期 $9$ 而其他保持不变。这忽略了周期 $2$ 的初始 $t_{RCD}$ 违规、周期 $5$ 的 $t_{RAS}$ 违规，并且仍然会使周期 $9$ 的 READ 相对于周期 $9$ 的 ACT 违反 $t_{RCD}$，以及周期 $12$ 的 PRE 违反 $t_{RAS}$。不正确。\n\n- 选项 E：正确列出了所有违规，但提出了一个非最小的修正调度，因为它额外等待数据突发完成作为 PRE 的门控条件（例如，将 PRE 移至周期 $10$）。问题要求的是最早的修正周期号；因此，即使其约束是保守的，该选项也不可接受。不正确。\n\n因此，正确的选择是既识别出所有违规又提供了最早合法修正的选项，即选项 B。", "answer": "$$\\boxed{B}$$", "id": "3684049"}, {"introduction": "本章的最终练习将视角从单个指令的正确性提升到整个系统的宏观性能。你的任务是计算在理想的流式读取场景下，内存子系统所能达到的最大数据吞吐率。这项练习不仅能让你将时序参数与最终的带宽联系起来，更重要的是，它将训练你分析和识别系统中性能瓶颈的关键能力——即判断在特定配置下，是指令总线、数据总线还是某个特定的时序约束（如 $t_{CCD}$）限制了整体性能。[@problem_id:3684048]", "problem": "一个单通道双倍数据速率同步动态随机存取存储器 (DDR SDRAM) 子系统，其内存时钟频率为 $f_{\\text{clk}} = 800\\,\\text{MHz}$，数据总线宽度为 $64\\,\\text{bits}$。该设备使用固定的突发长度 $BL = 8$。命令/地址总线在每个内存时钟周期最多可以发出一个命令。在一个长的稳态流式传输期间，内存控制器只发出读 (READ) 命令，并且目标是那些各自都已有一个打开行的存储体，因此在此期间不会发出激活 (ACT) 或预充电 (PRE) 命令。在发出READ命令之前应用的所有时序约束，即行至列延迟 $t_{RCD} = 11$ 个周期和行预充电时间 $t_{RP} = 11$ 个周期，都已在流式传输期间开始前得到满足。列至列命令间隔为 $t_{CCD} = 6$ 个周期，列地址选通 (CAS) 延迟为 $CL = 11$ 个周期。不会发生刷新或写操作，并且有足够多的独立存储体来保持数据总线繁忙，仅受所述约束的限制。\n\n从双倍数据速率信号传输（每个内存时钟周期两次数据传输）和同步动态随机存取存储器 (SDRAM) 中突发传输的基本定义出发，并仅使用上述给出的约束，确定在此流式传输期间的最大可持续数据吞吐率。以千兆字节/秒 (GB/s) 为单位表示您的最终答案，其中 $1\\,\\text{GB} = 10^9\\,\\text{bytes}$，并将答案四舍五入到四位有效数字。此外，请在 $t_{RCD}$、$t_{RP}$、$t_{CCD}$、$CL$ 以及每周期一个命令的命令总线速率中，指出在给定配置下从根本上限制此吞吐率的单一约束（请在您的推理中说明）。", "solution": "该问题要求计算在特定稳态条件下，一个双倍数据速率同步动态随机存取存储器 (DDR SDRAM) 子系统的最大可持续数据吞吐率，并识别出主要的性能限制约束。\n\n经核验，该问题被认为具有科学依据、提法得当、客观且内容自洽。所有提供的参数在内存子系统分析中都是标准参数，并且都在现实的范围内。所描述的场景——对已打开行的稳定读取操作流——是评估峰值内存带宽的经典案例。因此，可以推导出一个严谨的解。\n\n数据吞吐率 $R$ 的基本定义是单位时间 $T$ 内传输的数据量 $D$：\n$$R = \\frac{D}{T}$$\n\n我们首先确定单次内存操作中传输的数据量。指定的操作是一个 `READ` 命令，它会启动一个突发传输。数据总线宽度为 $W = 64\\,\\text{bits}$，相当于 $8\\,\\text{bytes}$。突发长度为 $BL = 8$。一个长度为 $BL$ 的突发对应于 $BL$ 次连续的数据传输，每次传输的数据量等于总线宽度。因此，每次突发传输的总数据量为：\n$$D_{\\text{burst}} = W \\times BL = (64\\,\\text{bits}) \\times 8 = 512\\,\\text{bits}$$\n使用 $8\\,\\text{bits} = 1\\,\\text{byte}$ 的关系将其转换为字节：\n$$D_{\\text{burst}} = \\frac{512\\,\\text{bits}}{8\\,\\text{bits/byte}} = 64\\,\\text{bytes}$$\n\n接下来，我们必须确定连续 `READ` 命令启动之间的最小时间间隔 $T_{\\text{period}}$。这个周期由系统中针对此特定访问模式的最严格的时序约束所决定。我们分析潜在的限制因素。\n\n1.  **数据总线占用**：DDR SDRAM 的内存时钟频率为 $f_{\\text{clk}} = 800\\,\\text{MHz}$。“双倍数据速率”这一名称意味着每个内存时钟周期发生两次数据传输。一个长度为 $BL = 8$ 的突发包含 8 次传输。因此，单次突发传输数据所占用的数据总线时间 $T_{\\text{bus\\_busy}}$ 为：\n    $$T_{\\text{bus\\_busy}} = \\frac{BL}{2} \\text{ cycles} = \\frac{8}{2} \\text{ cycles} = 4 \\text{ cycles}$$\n    为了实现数据总线的最大利用率，需要每 4 个时钟周期启动一次新的突发传输。这为 `READ` 命令之间的时间间隔建立了一个潜在的下限。\n\n2.  **命令发出约束**：问题提供了几个与命令相关的时序参数。\n    *   命令/地址总线每个时钟周期可以发出一个命令。这是命令总线的物理限制，允许每 1 个周期发出一个新命令。\n    *   列至列命令间隔为 $t_{CCD} = 6$ 个周期。此约束规定了两个列访问命令（如 `READ`）之间必须经过的最小时间。这意味着一个新的 `READ` 命令最多每 6 个时钟周期才能发出一次。\n    *   CAS 延迟 $CL = 11$ 个周期，是发出 `READ` 命令到总线上出现第一份数据之间的延迟。在一个流水线化的稳态读取流中，延迟会影响填充流水线的初始延迟，但不会限制后续命令的发出速率。因此，$CL$ 不限制可持续吞吐率。\n    *   时序参数 $t_{RCD}$ 和 $t_{RP}$ 与行激活和预充电有关。问题陈述，流式传输期间只涉及对已打开行的 `READ` 命令，并明确指出不发出 `ACT` 和 `PRE` 命令，且它们之前的约束已得到满足。因此，$t_{RCD}$ 和 $t_{RP}$ 与此稳态吞吐率计算无关。\n\n比较命令发出速率的约束，1 个周期的物理总线限制没有 $t_{CCD} = 6$ 个周期的要求严格。因此，由于命令总线的限制，`READ` 命令之间的有效最小时间为 6 个周期。\n\n为了找到连续突发开始之间的实际时间周期 $T_{\\text{period}}$，我们必须取数据总线完成其传输所需时间与命令总线发出下一个命令所需时间的最大值。\n$$T_{\\text{period\\_in\\_cycles}} = \\max\\left(\\frac{BL}{2}, t_{CCD}\\right)$$\n代入给定值：\n$$T_{\\text{period\\_in\\_cycles}} = \\max(4, 6) = 6 \\text{ cycles}$$\n\n这个结果表明系统受命令时序的限制，而不是数据总线。由于 $t_{CCD}$ 约束，新的 `READ` 命令只能每 6 个时钟周期发出一次，尽管数据总线在 4 个周期后就已经空闲。这意味着在每次突发传输之间，数据总线将空闲 $6 - 4 = 2$ 个周期。因此，在此配置中从根本上限制吞吐率的单一约束是列至列命令间隔 $t_{CCD}$。\n\n现在我们可以计算最大可持续吞吐率。该周期的时间长度为：\n$$T_{\\text{period}} = T_{\\text{period\\_in\\_cycles}} \\times T_{\\text{clk}} = \\frac{T_{\\text{period\\_in\\_cycles}}}{f_{\\text{clk}}} = \\frac{6}{800 \\times 10^6\\,\\text{s}}$$\n吞吐率 $R$ 是每次突发的数据量除以这个周期：\n$$R = \\frac{D_{\\text{burst}}}{T_{\\text{period}}} = \\frac{64\\,\\text{bytes}}{6 / (800 \\times 10^6\\,\\text{s}^{-1})} = \\frac{64 \\times 800 \\times 10^6}{6} \\,\\text{B/s}$$\n$$R = \\frac{51200 \\times 10^6}{6} \\,\\text{B/s} = \\frac{51.2 \\times 10^9}{6} \\,\\text{B/s}$$\n问题要求以千兆字节/秒 ($\\text{GB/s}$) 为单位给出答案，其中 $1\\,\\text{GB} = 10^9\\,\\text{bytes}$。\n$$R = \\frac{51.2}{6} \\,\\text{GB/s} \\approx 8.5333... \\,\\text{GB/s}$$\n将结果四舍五入到四位有效数字，得到：\n$$R \\approx 8.533 \\,\\text{GB/s}$$", "answer": "$$\\boxed{8.533}$$", "id": "3684048"}]}