{"hands_on_practices": [{"introduction": "平均内存访问时间（AMAT）是评估缓存性能的基石。本练习不仅将从第一性原理推导多级缓存的 AMAT 公式，还将引入微积分中的敏感性分析。通过这种方法，我们可以量化 AMAT 对各级缓存未命中率的依赖程度，从而识别出对整体性能影响最大的瓶颈，为系统优化指明方向 [@problem_id:3660682]。", "problem": "一个三级缓存层次结构由一级（$L1$）、二级（$L2$）和三级（$L3$）缓存组成，其后是主内存。平均内存访问时间（AMAT）定义为每次内存访问的期望延迟。设 $m_1$、$m_2$ 和 $m_3$ 分别表示 $L1$、$L2$ 和 $L3$ 的缺失率，其中每个 $m_i$ 是在访问已到达第 $i$ 级的情况下的条件缺失概率。设 $t_1$、$t_2$ 和 $t_3$ 分别表示访问 $L1$、$L2$ 和 $L3$ 的服务时间（延迟），并设 $t_M$ 表示主内存访问延迟。假设一次内存访问需要 $t_1$ 的时间来探测 $L1$；如果 $L1$ 缺失，则需要 $t_2$ 的时间来探测 $L2$；如果 $L2$ 缺失，则需要 $t_3$ 的时间来探测 $L3$；如果 $L3$ 缺失，则需要 $t_M$ 的时间来访问主内存。假设没有重叠，并且延迟沿缺失路径累加。\n\n仅从全期望定律以及条件概率和每事件期望成本的定义出发，完成以下任务：\n\n1. 将 AMAT 表示为基于在各级缓存命中或缺失的互斥事件的期望，使用 $t_1$、$t_2$、$t_3$、$t_M$ 以及条件缺失率 $m_1$、$m_2$、$m_3$ 来表达。然后，通过计算偏导数 $\\frac{\\partial\\, AMAT}{\\partial m_1}$、$\\frac{\\partial\\, AMAT}{\\partial m_2}$ 和 $\\frac{\\partial\\, AMAT}{\\partial m_3}$，符号化地推导出 AMAT 对每个 $m_i$ 的敏感度。\n\n2. 假设你有硬件性能计数器（HPC），可报告总周期数 $C$、总内存访问次数 $N$ 以及各级缓存的缺失次数 $M_1$、$M_2$、$M_3$。请描述一个基于经验的步骤，通过设计受控的扰动实验来调整 $m_i$ 同时保持其他 $m_j$ 近似恒定，从而估计在一个工作点附近每个偏导数 $\\frac{\\partial\\, AMAT}{\\partial m_i}$ 的值。你的设计必须解释如何使用相对于 $L1$、$L2$ 和 $L3$ 容量的工作负载工作集来隔离 $m_1$、$m_2$ 和 $m_3$ 的变化，以及如何使用从计数器得到的估计值 $\\hat{AMAT} = \\frac{C}{N}$ 和 $\\hat{m}_i$ 通过小有限差分来近似每个导数。\n\n3. 对于一个系统，其参数为 $t_1 = 1$ 个周期、$t_2 = 12$ 个周期、$t_3 = 35$ 个周期、$t_M = 220$ 个周期、$m_1 = 0.07$、$m_2 = 0.22$ 和 $m_3 = 0.40$，计算在此工作点上 $\\frac{\\partial\\, AMAT}{\\partial m_2}$ 的数值。以周期为单位表示最终答案，并将其四舍五入到 $4$ 位有效数字。", "solution": "该问题陈述具有科学依据、提法得当，并提供了所有必要的参数和定义。它与计算机体系结构和性能分析的既定原则相符。因此，该问题被视为有效，并提供完整解答如下。\n\n解决方案按要求分为三个部分呈现。\n\n### 第 1 部分：AMAT 推导与敏感度分析\n\n平均内存访问时间（AMAT）是服务一次内存访问所需总时间 $T$ 的期望值。我们可以使用全期望定律，考虑存储器层次结构中每一级产生的成本，来推导出 AMAT 的表达式。该模型指定了一种顺序、非重叠的访问模式。\n\n每次内存访问都必须首先访问一级（$L1$）缓存。这需要 $t_1$ 的时间。\n这些访问中的一部分（由条件 $L1$ 缺失率 $m_1$ 给出）将在 $L1$ 中缺失，然后必须继续访问二级（$L2$）缓存。访问 $L2$ 产生的额外时间是 $t_2$。\n到达 $L2$ 的访问中的一部分（由条件 $L2$ 缺失率 $m_2$ 给出）也将在 $L2$ 中缺失。在 $L1$ 和 $L2$ 中都缺失的访问占总访问次数的绝对比例是概率的乘积 $m_1 m_2$。这些访问将继续访问三级（$L3$）缓存，产生额外的 $t_3$ 时间开销。\n最后，到达 $L3$ 的访问中的一部分（由条件 $L3$ 缺失率 $m_3$ 给出）将会缺失。在所有三级缓存中都缺失的访问占总访问次数的绝对比例是 $m_1 m_2 m_3$。这些访问必须访问主内存，产生最终的额外 $t_M$ 时间开销。\n\n将这些成本按其发生的概率进行加权求和，得到 AMAT 方程：\n$$AMAT = t_1 + m_1 t_2 + (m_1 m_2) t_3 + (m_1 m_2 m_3) t_M$$\n\n该表达式表示期望成本，从访问 $L1$ 的基础成本开始，并加上在每个后续级别发生缺失的期望开銷。\n\n为了求出 AMAT 对每个条件缺失率 $m_i$ 的敏感度，我们计算 AMAT 表达式关于 $m_1$、$m_2$ 和 $m_3$ 的偏导数。\n\n**对 $m_1$ 的敏感度：**\n我们将 $m_2$ 和 $m_3$ 视为常数，并对 $m_1$ 求导：\n$$ \\frac{\\partial\\, AMAT}{\\partial m_1} = \\frac{\\partial}{\\partial m_1} (t_1 + m_1 t_2 + m_1 m_2 t_3 + m_1 m_2 m_3 t_M) $$\n$$ \\frac{\\partial\\, AMAT}{\\partial m_1} = 0 + t_2 + m_2 t_3 + m_2 m_3 t_M $$\n$$ \\frac{\\partial\\, AMAT}{\\partial m_1} = t_2 + m_2(t_3 + m_3 t_M) $$\n该导数表示 $L1$ 缺失率的微小变化引起的 AMAT 变化。它是一次 $L1$ 缺失的全部开销，包括访问 $L2$ 的时间（$t_2$）加上存储器层次结构中更低级别的期望缺失开销。\n\n**对 $m_2$ 的敏感度：**\n我们将 $m_1$ 和 $m_3$ 视为常数，并对 $m_2$ 求导：\n$$ \\frac{\\partial\\, AMAT}{\\partial m_2} = \\frac{\\partial}{\\partial m_2} (t_1 + m_1 t_2 + m_1 m_2 t_3 + m_1 m_2 m_3 t_M) $$\n$$ \\frac{\\partial\\, AMAT}{\\partial m_2} = 0 + 0 + m_1 t_3 + m_1 m_3 t_M $$\n$$ \\frac{\\partial\\, AMAT}{\\partial m_2} = m_1 (t_3 + m_3 t_M) $$\n该导数乘以了 $m_1$，因为 $m_2$ 的任何变化只影响那些已经在 $L1$ 中缺失的访问比例。$(t_3 + m_3 t_M)$ 这一项是 $L2$ 缺失的开销。\n\n**对 $m_3$ 的敏感度：**\n我们将 $m_1$ 和 $m_2$ 视为常数，并对 $m_3$ 求导：\n$$ \\frac{\\partial\\, AMAT}{\\partial m_3} = \\frac{\\partial}{\\partial m_3} (t_1 + m_1 t_2 + m_1 m_2 t_3 + m_1 m_2 m_3 t_M) $$\n$$ \\frac{\\partial\\, AMAT}{\\partial m_3} = 0 + 0 + 0 + m_1 m_2 t_M $$\n$$ \\frac{\\partial\\, AMAT}{\\partial m_3} = m_1 m_2 t_M $$\n该导数乘以了因子 $m_1 m_2$，因为 $m_3$ 的变化只与那些已经在 $L1$ 和 $L2$ 中都缺失的访问相关。$t_M$ 这一项是 $L3$ 缺失的开销。\n\n### 第 2 部分：经验性估计步骤\n\n为了经验性地估计偏导数 $\\frac{\\partial\\, AMAT}{\\partial m_i}$，我们可以设计受控实验，单独扰动每个 $m_i$ 并测量 AMAT 的相应变化。此步骤使用硬件性能计数器（HPC）和有限差分法。\n\n首先，我们建立模型参数与 HPC 可观测值之间的关系：\n-   总内存访问次数：$N$\n-   这些访问的总执行周期数：$C$\n-   $L1$ 缺失次数：$M_1$\n-   $L2$ 缺失次数：$M_2$\n-   $L3$ 缺失次数：$M_3$\n\n根据这些计数器，我们可以估计在一个工作点附近的模型参数：\n-   估计的 AMAT：$\\hat{AMAT} = \\frac{C}{N}$\n-   估计的条件 $L1$ 缺失率：$\\hat{m}_1 = \\frac{M_1}{N}$\n-   估计的条件 $L2$ 缺失率：$\\hat{m}_2 = \\frac{M_2}{M_1}$（当 $M_1 > 0$ 时）\n-   估计的条件 $L3$ 缺失率：$\\hat{m}_3 = \\frac{M_3}{M_2}$（当 $M_2 > 0$ 时）\n\n估计 $\\frac{\\partial\\, AMAT}{\\partial m_i}$ 的实验步骤如下：\n\n**通用步骤：**\n$1$. **隔离目标变量：** 为了估计对特定缺失率 $m_i$ 的敏感度，我们必须设计一种方法来改变 $m_i$，同时保持其他缺失率 $m_j$（其中 $j \\neq i$）尽可能恒定。这可以通过仔细控制测试工作负载的工作集大小（WSS）相对于缓存容量 $S_1  S_2  S_3$ 来实现。\n\n$2$. **设计扰动工作负载：** 针对每个目标 $m_i$，创建两个工作负载：一个基准工作负载（$W_a$）和一个扰动后的工作负载（$W_b$）。\n    -   为了扰动 $m_1$：设计 $W_a$ 的 $WSS  S_1$，设计 $W_b$ 的 $WSS > S_1$ 但 $WSS \\ll S_2$。\n    -   为了扰动 $m_2$：设计 $W_a$ 的 $WSS > S_1$ 但 $WSS \\le S_2$，设计 $W_b$ 的 $WSS > S_2$ 但 $WSS \\ll S_3$。\n    -   为了扰动 $m_3$：设计 $W_a$ 的 $WSS > S_2$ 但 $WSS \\le S_3$，设计 $W_b$ 的 $WSS > S_3$。\n\n$3$. **数据收集：** 在目标系统上执行两个工作负载（$W_a$ 和 $W_b$），并收集每次运行的 HPC 数据（$C, N, M_1, M_2, M_3$）。设基准运行收集的数据为（$C_a, N_a, M_{1a}, M_{2a}, M_{3a}$），扰动运行收集的数据为（$C_b, N_b, M_{1b}, M_{2b}, M_{3b}$）。\n\n$4$. **计算经验参数：** 对于每次运行 $k \\in \\{a, b\\}$，使用上面定义的公式计算估计参数 $\\hat{AMAT}_k$、$\\hat{m}_{1,k}$、$\\hat{m}_{2,k}$ 和 $\\hat{m}_{3,k}$。\n\n$5$. **近似导数：** 使用偏导数的有限差分近似法。例如，要估计对 $m_2$ 的敏感度：\n$$ \\frac{\\partial\\, AMAT}{\\partial m_2} \\approx \\frac{\\Delta \\hat{AMAT}}{\\Delta \\hat{m}_2} = \\frac{\\hat{AMAT}_b - \\hat{AMAT}_a}{\\hat{m}_{2,b} - \\hat{m}_{2,a}} $$\n\n$6$. **验证：** 一个关键步骤是验证实验的质量。非目标缺失率的变化 $|\\hat{m}_{j,b} - \\hat{m}_{j,a}|$（其中 $j \\neq i$）应该显著小于目标缺失率的变化 $|\\hat{m}_{i,b} - \\hat{m}_{i,a}|$。如果不满足此条件，则必须改进实验设置（例如，工作负载的 WSS）以更好地隔离感兴趣的变量。\n\n这个系统性的步骤能够基于经验来估计系统性能（AMAT）对缓存层次结构中每一级效率的敏感程度。\n\n### 第 3 部分：数值计算\n\n我们需要计算在特定工作点上 $\\frac{\\partial\\, AMAT}{\\partial m_2}$ 的数值。在第 1 部分推导出的公式是：\n$$ \\frac{\\partial\\, AMAT}{\\partial m_2} = m_1 (t_3 + m_3 t_M) $$\n\n给定值为：\n-   $t_1 = 1$ 个周期\n-   $t_2 = 12$ 个周期\n-   $t_3 = 35$ 个周期\n-   $t_M = 220$ 个周期\n-   $m_1 = 0.07$\n-   $m_2 = 0.22$\n-   $m_3 = 0.40$\n\n将相关值代入偏导数表达式中：\n$$ \\frac{\\partial\\, AMAT}{\\partial m_2} = 0.07 \\times (35 + 0.40 \\times 220) $$\n首先，我们计算括号内的项，它代表 $L2$ 的缺失开销：\n$$ 35 + 0.40 \\times 220 = 35 + 88 = 123 $$\n现在，我们乘以 $L1$ 的缺失率：\n$$ \\frac{\\partial\\, AMAT}{\\partial m_2} = 0.07 \\times 123 = 8.61 $$\n结果是 $8.61$ 个周期。问题要求将答案四舍五入到 $4$ 位有效数字。因此，该值为 $8.610$。这个值表明，对于 $L2$ 条件缺失率的一个微小增加，例如 $0.01$（即 $1\\%$），AMAT 将大约增加 $0.01 \\times 8.610 = 0.0861$ 个周期。", "answer": "$$\n\\boxed{8.610}\n$$", "id": "3660682"}, {"introduction": "理论联系实际是掌握缓存知识的关键。本练习将我们从抽象的 AMAT 公式带入一个具体的性能瓶颈场景：缓存争用。通过分析一个微基准测试，你将学会如何根据工作集大小、缓存关联度以及替换策略来预测未命中率，从而深刻理解程序行为与硬件性能之间直接而具体的关系 [@problem_id:3660665]。", "problem": "一个单线程微基准测试在一个处理器上执行，该处理器具有统一的一级缓存（L1）和多级存储层次结构。统一的一级缓存容量为 $64 \\,\\text{KiB}$，相联度为 $4$（四路组相联），缓存行大小为 $64 \\,\\text{B}$。二级缓存（L2）是统一的，容量为 $512 \\,\\text{KiB}$，相联度为 $8$，缓存行大小为 $64 \\,\\text{B}$。三级缓存（L3）是统一的，容量为 $8 \\,\\text{MiB}$，相联度为 $16$，缓存行大小为 $64 \\,\\text{B}$。统一的一级缓存是物理索引和物理标记的，其组索引由地址位 $b_{6..13}$ 构成。\n\n该微基准测试将一个大的代码段及其只读数据数组连续地存放在内存中，并按 $64 \\,\\text{B}$ 对齐。代码段大小为 $96 \\,\\text{KiB}$，数据数组大小为 $48 \\,\\text{KiB}$。在微基准测试的每次迭代中：\n- 指令流顺序执行整个 $96 \\,\\text{KiB}$ 的代码段一次，以恒定速率获取指令，具有空间局部性，每个 $64 \\,\\text{B}$ 的缓存行恰好被访问一次。\n- 数据访问模式在整个 $48 \\,\\text{KiB}$ 的数据数组中，从每个 $64 \\,\\text{B}$ 的缓存行中顺序加载一个 $8 \\,\\text{B}$ 的元素一次，每个数据行产生一次请求加载。\n\n假设如下：\n- 代码和数据的放置方式使其地址均匀地分布在统一的一级缓存的相同组索引上，即，两个流都均匀分布在所有一级缓存组上，并且由于它们是连续和对齐的，因此会竞争相同的组，且索引位 $b_{6..13}$ 为一级缓存选择了 $256$ 个组。\n- 替换策略是真正的最近最少使用（LRU）。\n- 二级缓存可以容纳来自两个流的整个工作集而不在一次迭代中发生替换，并且从二级缓存命中以重新填充一级缓存行的延迟为 $12$ 个周期。在此场景中忽略三级缓存和主内存。\n- 来自统一的一级缓存的未命中不会重叠；即，每次一级缓存未命中都会加性地增加流水线停顿周期，且处理器无法隐藏这些开销。\n\n从未命中率和相联度约束的定义出发，确定指令获取和数据加载的稳态一级缓存未命中率，分别表示为 $m_{I1}$ 和 $m_{D1}$。然后，假设每次一级缓存未命中都由二级缓存的命中延迟 $12$ 个周期来服务，计算每次迭代中由两个流的一级缓存未命中导致的总流水线停顿周期。最终的停顿计数以每次迭代的周期数表示，并将此停顿计数四舍五入到四位有效数字。最终答案必须是一个单行矩阵，按顺序包含 $m_{I1}$、$m_{D1}$ 和四舍五入后的每次迭代的停顿周期数。", "solution": "用户要求我解决一个关于缓存性能的问题。\n\n### 步骤 1：问题验证\n\n我将首先验证问题陈述。\n\n#### 提取的已知条件：\n- **处理器：** 单线程。\n- **L1 缓存（统一）：**\n  - 容量：$C_1 = 64 \\,\\text{KiB}$\n  - 相联度：$A_1 = 4$ (四路组相联)\n  - 缓存行大小：$L = 64 \\,\\text{B}$\n  - 索引/标记：物理索引，物理标记。\n  - 组索引：地址位 $b_{6..13}$。\n- **L2 缓存（统一）：**\n  - 容量：$C_2 = 512 \\,\\text{KiB}$\n  - 相联度：$A_2 = 8$\n  - 缓存行大小：$L = 64 \\,\\text{B}$\n- **L3 缓存（统一）：**\n  - 容量：$C_3 = 8 \\,\\text{MiB}$\n  - 相联度：$A_3 = 16$\n  - 缓存行大小：$L = 64 \\,\\text{B}$\n- **微基准测试工作负载：**\n  - 代码段大小：$W_I = 96 \\,\\text{KiB}$\n  - 数据数组大小：$W_D = 48 \\,\\text{KiB}$\n  - 放置：代码和数据在内存中连续存放，并按 $64 \\,\\text{B}$ 边界对齐。\n- **访问模式（每次迭代）：**\n  - **指令：** 顺序获取整个 $96 \\,\\text{KiB}$ 代码段，每个 $64 \\,\\text{B}$ 行恰好访问一次。\n  - **数据：** 在整个 $48 \\,\\text{KiB}$ 数据数组中，从每个 $64 \\,\\text{B}$ 行顺序加载一个 $8 \\,\\text{B}$ 元素，每个数据行产生一次请求加载。\n- **假设：**\n  1. 代码和数据的地址均匀地跨越相同的 L1 组索引，导致竞争。索引位 $b_{6..13}$ 对应 $256$ 个组。\n  2. 替换策略：真正的最近最少使用（LRU）。\n  3. L2 缓存足够大，可以容纳整个工作集 ($96 \\,\\text{KiB} + 48 \\,\\text{KiB} = 144 \\,\\text{KiB}  512 \\,\\text{KiB}$)。\n  4. L1 未命中开销（由 L2 命中服务）：$T_{penalty} = 12$ 个周期。\n  5. L1 未命中不重叠，其开销是累加的。\n- **要求输出：**\n  1. 稳态 L1 指令未命中率，$m_{I1}$。\n  2. 稳态 L1 数据未命中率，$m_{D1}$。\n  3. 每次迭代的总流水线停顿周期，四舍五入到四位有效数字。\n\n#### 使用提取的已知条件进行验证：\n1.  **科学或事实上的不健全性：** 问题是科学上合理的。缓存参数是现实的。我们来验证一下 L1 缓存的结构。偏移位用于 $64 \\,\\text{B}$ 的行，所以 $2^6 = 64$，这意味着地址位 $b_{0..5}$ 是字节偏移。索引由位 $b_{6..13}$ 给出，即 $13 - 6 + 1 = 8$ 位。组的数量是 $S_1 = 2^8 = 256$。L1 的总容量是 $C_1 = S_1 \\times A_1 \\times L = 256 \\times 4 \\times 64 \\,\\text{B} = 1024 \\times 64 \\,\\text{B} = 65536 \\,\\text{B} = 64 \\,\\text{KiB}$。这与给定的容量一致。所有前提都基于计算机组成和体系结构的标准原理。\n2.  **不可形式化或不相关：** 问题是形式化的，并且与多级缓存的主题直接相关。\n3.  **不完整或矛盾的设置：** 问题定义明确且自洽。所有必要的数据（大小、延迟、策略、访问模式）都已提供。没有矛盾。\n4.  **不切实际或不可行：** 对于一个旨在测试缓存竞争的微基准测试来说，参数和场景是合理的。\n5.  **不适定或结构不良：** 问题是适定的，有明确的假设，可以导出一个唯一的、可推导的解。\n6.  **伪深刻、琐碎或同义反复：** 问题并非琐碎；它需要对 LRU 策略下的缓存竞争进行仔细分析。\n7.  **超出科学可验证性范围：** 结果可以通过计算或模拟来验证。\n\n#### 结论：\n问题是有效的。我将继续进行解答。\n\n### 步骤 2：解题\n\n问题要求我们确定指令流和数据流的 L1 未命中率，以及由此产生的总流水线停顿。问题的核心在于分析统一 L1 缓存中指令流和数据流之间的竞争。\n\n首先，让我们分析 L1 缓存结构以及相对于它的内存访问模式。\nL1 缓存有 $S_1 = 256$ 个组，相联度为 $A_1 = 4$。这意味着每个组可以容纳 $4$ 个唯一的缓存行。替换策略是 LRU。\n\n总工作集由一个 $W_I = 96 \\,\\text{KiB}$ 的代码段和一个 $W_D = 48 \\,\\text{KiB}$ 的数据数组组成。缓存行大小为 $L = 64 \\,\\text{B}$。\n指令流的缓存行数量为：\n$$N_I = \\frac{W_I}{L} = \\frac{96 \\times 2^{10} \\,\\text{B}}{64 \\,\\text{B}} = \\frac{98304 \\,\\text{B}}{64 \\,\\text{B}} = 1536 \\text{ 行}$$\n数据流的缓存行数量为：\n$$N_D = \\frac{W_D}{L} = \\frac{48 \\times 2^{10} \\,\\text{B}}{64 \\,\\text{B}} = \\frac{49152 \\,\\text{B}}{64 \\,\\text{B}} = 768 \\text{ 行}$$\n\n问题陈述，两个流都均匀分布在所有 $S_1 = 256$ 个 L1 组上。因此，我们可以分析一个代表性组的行为。\n映射到每个组的指令行数：\n$$N_{I,set} = \\frac{N_I}{S_1} = \\frac{1536}{256} = 6$$\n映射到每个组的数据行数：\n$$N_{D,set} = \\frac{N_D}{S_1} = \\frac{768}{256} = 3$$\n\n映射到任意给定组的唯一内存行总数为：\n$$N_{total,set} = N_{I,set} + N_{D,set} = 6 + 3 = 9$$\n\nL1 缓存是 $A_1 = 4$ 路组相联的。然而，对于每个组，在每次迭代中都必须访问来自组合工作集的 $9$ 个唯一行。由于竞争行数（$9$）大于组相联度（$4$），冲突未命中是不可避免的。\n\n在一次迭代中，两个流的访问模式都是顺序的，并且每个行都只被访问一次。让我们考虑对一个代表性组的访问序列。组合流包括对 $6$ 个唯一的指令行和 $3$ 个唯一的数据行的访问。由于在一次迭代中没有行被访问超过一次，因此给定组的访问序列是 $9$ 个唯一行地址的排列。\n\n在 LRU 替换策略下，当在一个满的组中发生未命中时，最近最少使用的行将被替换。让我们追踪一个组的状态。\n1. 对组中一个行的第一次访问是强制性未命中。该行被加载进来。\n2. 对另一个不同行的第二次访问也是强制性未命中。它被加载进来。\n3. 对于前 $4$ 次唯一的行访问，此过程继续。现在该组已满。假设其内容为 $\\{L_1, L_2, L_3, L_4\\}$。\n4. 对第五个唯一行 $L_5$ 的访问将是未命中。由于该组已满，LRU 策略将替换最近最少使用的行（即 $L_1$）。该组现在包含 $\\{L_2, L_3, L_4, L_5\\}$。\n5. 对于随后的每一次唯一访问，这个替换过程都会继续。第 $k$ 次唯一访问（对于 $k  4$）将替换掉第 $(k-4)$ 个被加载进来的行。\n\n由于微基准测试在每次迭代中每个组访问 $9$ 个唯一的行，而相联度只有 $4$，因此每次访问都会发现所需的行不在缓存中。前 $4$ 次访问是填充该组的强制性未命中。从第 $5$ 次到第 $9$ 次的每一次后续访问都是冲突未命中，因为它会替换掉之前加载的行。因为在同一次迭代中没有行被重新引用，所以没有命中的机会。在迭代结束时，该组将包含最后访问的 $4$ 个行。在下一次迭代开始时，程序将再次从第一个行开始访问，而这个行早已被替换出去。因此，在稳态下，对每个唯一行的每一次访问都将导致未命中。\n\n问题要求的是未命中率，定义为未命中次数与访问次数的比率。这里的“访问”是指对每个缓存行的请求。\n对于指令流，对 $N_I = 1536$ 个行中的每一个都有一次访问。所有这些访问都将未命中。\n指令未命中次数 = $1536$。\n指令访问次数 = $1536$。\nL1 指令未命中率为：\n$$m_{I1} = \\frac{\\text{指令未命中次数}}{\\text{指令访问次数}} = \\frac{1536}{1536} = 1$$\n\n对于数据流，对 $N_D = 768$ 个行中的每一个都有一次访问。所有这些访问都将未命中。\n数据未命中次数 = $768$。\n数据访问次数 = $768$。\nL1 数据未命中率为：\n$$m_{D1} = \\frac{\\text{数据未命中次数}}{\\text{数据访问次数}} = \\frac{768}{768} = 1$$\n\n现在，我们计算每次迭代的总流水线停顿周期。\n每次迭代的 L1 未命中总数是指令未命中和数据未命中之和：\n$$\\text{总未命中次数} = N_I + N_D = 1536 + 768 = 2304$$\n每次未命中会产生 $T_{penalty} = 12$ 个周期的开销，并且这些开销是累加的。\n每次迭代的总停顿周期为：\n$$\\text{停顿周期} = (\\text{总未命中次数}) \\times T_{penalty} = 2304 \\times 12$$\n$$\\text{停顿周期} = 27648$$\n问题要求将此值四舍五入到四位有效数字。数字 $27648$ 有五位有效数字。要将其四舍五入到四位，我们检查第五位数字，即 $8$。由于 $8 \\ge 5$，我们将第四位数字（$4$）向上取整为 $5$。\n$$\\text{四舍五入后的停顿周期} = 27650$$\n\n最终答案由三个计算值组成：$m_{I1}$、$m_{D1}$ 和四舍五入后的停顿周期。\n$m_{I1} = 1$\n$m_{D1} = 1$\n四舍五入后的停顿周期 = $27650$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  1  27650\n\\end{pmatrix}\n}\n$$", "id": "3660665"}, {"introduction": "提升性能不仅依赖于硬件设计，巧妙的软件策略同样至关重要。本练习探讨了一种主动优化技术：软件控制的缓存刷新。你将通过编程实践来评估在不同程序阶段间刷新缓存的利弊，权衡刷新操作本身带来的开销与后续阶段因减少缓存干扰而获得的性能收益，这对于编写缓存友好型软件至关重要 [@problem_id:3660690]。", "problem": "给定一个在三级缓存层次结构上运行的两阶段工作负载，该结构由1级缓存、2级缓存和3级缓存组成，之后是主内存。该层次结构是串行访问的：一个请求首先探测1级缓存，只有在未命中时才会继续探测2级缓存，以此类推。将各级的探测时间（检查一个级别并在命中时服务该访问所需的时间）分别表示为 $L_1$、$L_2$ 和 $L_3$（分别对应1级、2级和3级缓存），主内存服务时间表示为 $L_M$。所有时间单位均为周期。对于每个阶段，给定局部未命中率 $m_1$、$m_2$ 和 $m_3$，它们在层次结构中被解释为条件概率：$m_1$ 是在1级缓存中未命中的概率，$m_2$ 是在1级缓存未命中的情况下2级缓存也未命中的概率，$m_3$ 是在1级和2级缓存都未命中的情况下3级缓存也未命中的概率。为计算期望的目的，假定所有访问都是独立同分布的。\n\n使用的基本原理是基于层次结构事件的期望定义以及平均内存访问时间 (AMAT) 的定义。单次访问的期望访问时间是访问在层次结构中命中的位置（这些是互斥结果）的期望值，每个结果贡献其探测时间以及在未命中时任何后续的探测时间。\n\n考虑在两个阶段之间执行的软件控制的驱逐（也称为缓存刷新），以从下一阶段不会使用的数组中移除缓存状态。一次刷新会产生 $C_F$ 个周期的单次成本。如果不进行刷新，第二阶段可能会因第一阶段的足迹（footprint）而遭受干扰，导致第二阶段有不同的未命中率。如果进行刷新，第二阶段将使用其自身在没有干扰情况下的未命中率。第一阶段的未命中率不受两阶段之间是否刷新这一决定的影响。\n\n你的任务是，为每个测试用例计算，在两阶段之间执行刷新时，相较于不执行刷新，整体平均内存访问时间 (AMAT) 的改善量。将整体 AMAT 定义为两个阶段的总时间除以总访问次数。设阶段 $p$ 的访问次数为 $N_p$，其中 $p \\in \\{1,2\\}$。不刷新时的总时间是各阶段 $N_p$ 乘以使用不刷新未命中率的阶段 $p$ 的期望访问时间的总和。刷新时的总时间是相同的总和，但对阶段2使用刷新未命中率，再加上一次性刷新成本 $C_F$。需要报告的改善量是差值\n$$\\Delta = \\text{AMAT}_{\\text{no-flush}} - \\text{AMAT}_{\\text{flush}}.$$\n正值的 $\\Delta$ 表示刷新是有益的。\n\n实现一个程序，为以下每个测试用例计算 $\\Delta$。所有概率必须使用 $[0,1]$ 范围的小数，而不是百分比。所有时间必须以周期为单位计算，最终答案必须以每个访问的周期数为单位表示，并四舍五入到小数点后恰好 $6$ 位。\n\n对于每个测试用例，给定：\n- $L_1, L_2, L_3, L_M$（周期），\n- $N_1, N_2$（阶段1和阶段2的访问次数），\n- 阶段1的未命中率 $m_{1,1}, m_{2,1}, m_{3,1}$，\n- 阶段2不刷新时的未命中率 $m_{1,2}^{\\text{nf}}, m_{2,2}^{\\text{nf}}, m_{3,2}^{\\text{nf}}$，\n- 阶段2刷新时的未命中率 $m_{1,2}^{\\text{f}}, m_{2,2}^{\\text{f}}, m_{3,2}^{\\text{f}}$，\n- 刷新成本 $C_F$（周期）。\n\n使用以下测试套件：\n- 测试用例 1 (刷新有益)：\n  - $L_1=4$, $L_2=12$, $L_3=30$, $L_M=120$,\n  - $N_1=10000$, $N_2=20000$,\n  - 阶段 1: $m_{1,1}=0.05$, $m_{2,1}=0.20$, $m_{3,1}=0.10$,\n  - 阶段 2 不刷新: $m_{1,2}^{\\text{nf}}=0.25$, $m_{2,2}^{\\text{nf}}=0.30$, $m_{3,2}^{\\text{nf}}=0.20$,\n  - 阶段 2 刷新: $m_{1,2}^{\\text{f}}=0.08$, $m_{2,2}^{\\text{f}}=0.15$, $m_{3,2}^{\\text{f}}=0.10$,\n  - $C_F=50000$。\n- 测试用例 2 (因成本过高而刷新有害)：\n  - 与测试用例 1 相同，除了 $C_F=200000$。\n- 测试用例 3 (边界情况，无影响)：\n  - $L_1=1$, $L_2=5$, $L_3=15$, $L_M=90$,\n  - $N_1=5000$, $N_2=5000$,\n  - 阶段 1: $m_{1,1}=0.10$, $m_{2,1}=0.20$, $m_{3,1}=0.30$,\n  - 阶段 2 不刷新: $m_{1,2}^{\\text{nf}}=0.10$, $m_{2,2}^{\\text{nf}}=0.20$, $m_{3,2}^{\\text{nf}}=0.30$,\n  - 阶段 2 刷新: $m_{1,2}^{\\text{f}}=0.10$, $m_{2,2}^{\\text{f}}=0.20$, $m_{3,2}^{\\text{f}}=0.30$,\n  - $C_F=0$。\n- 测试用例 4 (资源密集型的第二阶段有巨大改善)：\n  - $L_1=3$, $L_2=10$, $L_3=28$, $L_M=200$,\n  - $N_1=2000$, $N_2=100000$,\n  - 阶段 1: $m_{1,1}=0.02$, $m_{2,1}=0.10$, $m_{3,1}=0.20$,\n  - 阶段 2 不刷新: $m_{1,2}^{\\text{nf}}=0.50$, $m_{2,2}^{\\text{nf}}=0.60$, $m_{3,2}^{\\text{nf}}=0.80$,\n  - 阶段 2 刷新: $m_{1,2}^{\\text{f}}=0.10$, $m_{2,2}^{\\text{f}}=0.20$, $m_{3,2}^{\\text{f}}=0.30$,\n  - $C_F=300000$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例的顺序排列结果，每个值都四舍五入到小数点后恰好 $6$ 位。例如，输出格式必须与 $[x_1,x_2,x_3,x_4]$ 完全一样，其中每个 $x_i$ 是一个实数，单位是每个访问的周期数，小数点后有 $6$ 位数字。", "solution": "用户希望找出在一个两阶段工作负载之间执行缓存刷新时，整体平均内存访问时间 (AMAT) 的改善量。\n\n### 基于原理的设计\n\n该问题围绕分层内存系统中的平均内存访问时间 (AMAT) 概念展开。整体 AMAT 定义为所有内存访问的总时间除以总访问次数。我们需要为两种情况计算这个值：一种是在两个工作负载阶段之间不进行缓存刷新，另一种是进行刷新。改善量是这两个 AMAT 值之间的差。\n\n我们首先为这个三级缓存层次结构中的单次内存访问建立期望访问时间 (EAT) 的公式。该层次结构是串行探测的：1级 (L1)，然后是2级 (L2)，接着是3级 (L3)，最后是主内存。\n\n给定的延迟是：\n- $L_1$: L1 缓存的探测时间。\n- $L_2$: L2 缓存的探测时间。\n- $L_3$: L3 缓存的探测时间。\n- $L_M$: 主内存的服务时间。\n\n局部未命中率以条件概率的形式给出：\n- $m_1$: 在 L1 中未命中的概率。\n- $m_2$: 在 L1 未命中的情况下，在 L2 也未命中的概率。\n- $m_3$: 在 L1 和 L2 都未命中的情况下，在 L3 也未命中的概率。\n\n单次访问的时间可以通过考虑访问在哪个层次结构级别被满足（“命中”）来公式化：\n1.  **在 L1 命中**：访问成本为 $L_1$。这种情况发生的概率是 $(1-m_1)$。\n2.  **在 L1 未命中，在 L2 命中**：访问首先探测 L1 (成本 $L_1$)，然后探测 L2 (成本 $L_2$)。总成本为 $L_1+L_2$。这种情况发生的概率是 $m_1(1-m_2)$。\n3.  **在 L1 和 L2 未命中，在 L3 命中**：访问探测 L1、L2 和 L3。成本为 $L_1+L_2+L_3$。这种情况发生的概率是 $m_1 m_2 (1-m_3)$。\n4.  **在 L1、L2 和 L3 均未命中**：访问探测所有缓存，并由主内存服务。成本为 $L_1+L_2+L_3+L_M$。这种情况发生的概率是 $m_1 m_2 m_3$。\n\n一个更简单、等价的期望访问时间 (EAT) 公式，我们将其表示为函数 $E(m_1, m_2, m_3)$：\n$$ E(m_1, m_2, m_3) = L_1 + m_1 L_2 + m_1 m_2 L_3 + m_1 m_2 m_3 L_M $$\n该公式可以通过认识到一次访问总是会产生 $L_1$ 的成本来推导。只有当 L1 未命中时（概率为 $m_1$），它才会产生额外的成本 $L_2$。只有当 L1 和 L2 都未命中时（概率为 $m_1 m_2$），它才会产生更进一步的成本 $L_3$，以此类推。\n\n工作负载包含两个阶段，分别有 $N_1$ 和 $N_2$ 次访问。总访问次数为 $N_{\\text{total}} = N_1 + N_2$。\n\n阶段 1 的未命中率为 $m_{1,1}$, $m_{2,1}$, $m_{3,1}$。其期望访问时间为：\n$$ E_1 = E(m_{1,1}, m_{2,1}, m_{3,1}) $$\n\n阶段 2 的未命中率取决于是否执行刷新。\n- 不刷新：未命中率为 $m_{1,2}^{\\text{nf}}$, $m_{2,2}^{\\text{nf}}$, $m_{3,2}^{\\text{nf}}$。EAT 为 $E_{2,\\text{nf}} = E(m_{1,2}^{\\text{nf}}, m_{2,2}^{\\text{nf}}, m_{3,2}^{\\text{nf}})$。\n- 刷新：未命中率为 $m_{1,2}^{\\text{f}}$, $m_{2,2}^{\\text{f}}$, $m_{3,2}^{\\text{f}}$。EAT 为 $E_{2,\\text{f}} = E(m_{1,2}^{\\text{f}}, m_{2,2}^{\\text{f}}, m_{3,2}^{\\text{f}})$。\n\n现在，我们可以计算两种情况下的整体 AMAT。\n\n**1. 不刷新场景**\n总时间是每个阶段时间的总和：\n$$ T_{\\text{no-flush}} = N_1 E_1 + N_2 E_{2,\\text{nf}} $$\n整体 AMAT 是：\n$$ \\text{AMAT}_{\\text{no-flush}} = \\frac{T_{\\text{no-flush}}}{N_1 + N_2} = \\frac{N_1 E_1 + N_2 E_{2,\\text{nf}}}{N_1 + N_2} $$\n\n**2. 刷新场景**\n总时间包括一次性的刷新成本 $C_F$：\n$$ T_{\\text{flush}} = N_1 E_1 + N_2 E_{2,\\text{f}} + C_F $$\n整体 AMAT 是：\n$$ \\text{AMAT}_{\\text{flush}} = \\frac{T_{\\text{flush}}}{N_1 + N_2} = \\frac{N_1 E_1 + N_2 E_{2,\\text{f}} + C_F}{N_1 + N_2} $$\n\n**3. AMAT 改善量 ($\\Delta$)**\n所需的改善量是 $\\Delta = \\text{AMAT}_{\\text{no-flush}} - \\text{AMAT}_{\\text{flush}}$。\n$$ \\Delta = \\frac{N_1 E_1 + N_2 E_{2,\\text{nf}}}{N_1 + N_2} - \\frac{N_1 E_1 + N_2 E_{2,\\text{f}} + C_F}{N_1 + N_2} $$\n我们可以通过合并分数来简化这个表达式：\n$$ \\Delta = \\frac{(N_1 E_1 + N_2 E_{2,\\text{nf}}) - (N_1 E_1 + N_2 E_{2,\\text{f}} + C_F)}{N_1 + N_2} $$\n$N_1 E_1$ 项被消掉了：\n$$ \\Delta = \\frac{N_2 E_{2,\\text{nf}} - N_2 E_{2,\\text{f}} - C_F}{N_1 + N_2} $$\n这简化为最终公式：\n$$ \\Delta = \\frac{N_2 (E_{2,\\text{nf}} - E_{2,\\text{f}}) - C_F}{N_1 + N_2} $$\n这表明改善量仅取决于阶段 2 访问性能的变化、刷新成本，以及这个成本/收益被摊销的总访问次数。阶段 1 的性能与两种策略之间的*差异*无关。\n\n我们将为每个测试用例实现这个最终公式。\n- 一个函数 `calculate_eat` 将根据给定的延迟和未命中率参数计算 $E(m_1, m_2, m_3)$。\n- 对于每个测试用例，我们计算 $E_{2,\\text{nf}}$ 和 $E_{2,\\text{f}}$。\n- 然后我们将这些值代入 $\\Delta$ 的公式。\n- 最终结果将格式化为逗号分隔的列表，并四舍五入到小数点后6位。", "answer": "[2.057333, -2.942667, 0.000000, 54.549020]", "id": "3660690"}]}