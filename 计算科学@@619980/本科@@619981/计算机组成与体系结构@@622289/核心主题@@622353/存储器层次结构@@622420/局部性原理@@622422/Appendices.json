{"hands_on_practices": [{"introduction": "局部性原理是计算机体系结构中的基石，尤其空间局部性指出，程序倾向于访问彼此靠近的内存地址。本练习通过一个经典场景——遍历按行优先顺序存储的二维数组——来具体化这一概念。通过对比行优先和列优先访问模式所导致的缓存未命中数量，你将亲手量化访问模式与内存布局的协同程度对性能的巨大影响 [@problem_id:3668437]。", "problem": "一个二维标量元素数组在主内存中以行主序存储。该数组有 $W$ 列和 $H$ 行，每个元素占用 $E$ 字节。数组的基地址与缓存行边界对齐。\n\n系统有一个单级、直接映射的数据缓存，有 $S$ 个组，行大小为 $B$ 字节，因此总缓存容量为 $S B$ 字节。缓存初始为空，并且没有硬件预取。考虑只读遍历，每个元素只访问一次。\n\n考虑两种遍历顺序：\n1. 按行遍历：对于从 $0$ 到 $H-1$ 的每一行 $r$，访问从 $0$ 到 $W-1$ 的列 $c$。\n2. 按列遍历：对于从 $0$ 到 $W-1$ 的每一列 $c$，访问从 $0$ 到 $H-1$ 的行 $r$。\n\n假设以下现实约束成立：\n- $E$ 能整除 $B$，因此 $L \\equiv B/E$ 是每个缓存行中的整数个元素。\n- $W \\geq L$ 且 $W$ 是 $L$ 的倍数。\n- $W E$ 是 $S B$ 的倍数。\n- $H \\geq 2$。\n\n从行主序布局和直接映射缓存索引的基本定义出发，确定按列遍历所产生的缓存未命中总数与按行遍历所产生的缓存未命中总数之比，并用 $B$ 和 $E$ 表示为最简闭合形式。将最终答案表示为不带单位的单个简化符号表达式。无需四舍五入。", "solution": "用户提供的问题被评估为有效。它在科学上基于计算机体系结构的原理，问题设定良好，有唯一且可确定的解，并以客观、正式的语言陈述。所提供的约束虽然创建了一个特定的场景，但在内部是一致且物理上是合理的。因此，我将进行正式的解答。\n\n设数组的基地址为 $A_0$。问题陈述数组以行主序存储，其基地址与缓存行边界对齐。单个元素的大小为 $E$ 字节。数组有 $H$ 行和 $W$ 列。位于行 $r$ 和列 $c$ 的元素的地址（使用基于 0 的索引，因此 $0 \\le r  H$ 且 $0 \\le c  W$）由下式给出：\n$$\n\\text{Addr}(r, c) = A_0 + (r \\times W + c) \\times E\n$$\n缓存是直接映射的，有 $S$ 个组，行大小为 $B$ 字节。单个缓存行能容纳的元素数量为 $L = B/E$，已知这是一个整数。一个内存地址 $\\text{addr}$ 按如下方式映射到缓存组索引：\n$$\n\\text{Index}(\\text{addr}) = \\left\\lfloor \\frac{\\text{addr}}{B} \\right\\rfloor \\pmod{S}\n$$\n由于基地址 $A_0$ 与缓存行边界对齐，所以 $A_0$ 是 $B$ 的倍数。设 $A_0 = m \\times B$，其中 $m$ 为某个非负整数。\n\n首先，我们分析按行遍历的缓存未命中数，记为 $M_{\\text{row}}$。访问模式是顺序通过内存，在移动到下一行之前扫描给定行的所有列。\n$$\n\\text{for } r = 0 \\text{ to } H-1 \\\\\n\\quad \\text{for } c = 0 \\text{ to } W-1 \\\\\n\\qquad \\text{access element at } (r, c)\n$$\n缓存初始为空。第一次访问，即访问 $\\text{Addr}(0,0)$，是一次强制性未命中（compulsory miss）。这次未命中导致包含第 $0$ 行前 $L$ 个元素（即元素 $(0,0)$ 到 $(0,L-1)$）的缓存行被加载到缓存中。随后的 $L-1$ 次对元素 $(0,1)$ 到 $(0,L-1)$ 的访问都将是命中，因为它们现在已在缓存中。这是空间局部性（spatial locality）的直接结果。\n\n对元素 $(0,L)$ 的访问是下一个数据块的第一个元素，它将导致另一次未命中。这种模式会重复。每访问 $L$ 个连续元素，第一次访问导致一次未命中，随后的 $L-1$ 次访问则为命中。\n数组中的总元素数为 $H \\times W$。\n由于遍历是完全顺序的，并且每次未命中都会带入 $L$ 个元素，因此未命中的总数是总元素数除以每个缓存行的元素数。\n$$\nM_{\\text{row}} = \\frac{H \\times W}{L}\n$$\n给定的约束确保了这个简单模型的成立，并且不会因行之间的冲突未命中（conflict misses）而变得复杂。$W$ 是 $L$ 的倍数这一约束保证了行不会共享缓存行。\n\n接下来，我们分析按列遍历的缓存未命中数，记为 $M_{\\text{col}}$。访问模式是：\n$$\n\\text{for } c = 0 \\text{ to } W-1 \\\\\n\\quad \\text{for } r = 0 \\text{to } H-1 \\\\\n\\qquad \\text{access element at } (r, c)\n$$\n为了分析未命中，我们必须确定每次访问映射到哪个缓存组。元素 $(r,c)$ 地址的索引是：\n$$\n\\text{Index}(r, c) = \\left\\lfloor \\frac{A_0 + (rW + c)E}{B} \\right\\rfloor \\pmod{S} = \\left\\lfloor \\frac{mB + (rW+c)E}{B} \\right\\rfloor \\pmod{S} = \\left( m + \\left\\lfloor \\frac{(rW+c)E}{B} \\right\\rfloor \\right) \\pmod{S}\n$$\n使用 $L = B/E$，这变为：\n$$\n\\text{Index}(r, c) = \\left( m + \\left\\lfloor \\frac{rW+c}{L} \\right\\rfloor \\right) \\pmod{S}\n$$\n现在，我们应用给定的约束条件，$W \\times E$ 是 $S \\times B$ 的倍数。设 $W \\times E = q \\times S \\times B$，其中 $q \\ge 1$ 是某个整数。\n代入 $E=B/L$，我们得到 $W \\times (B/L) = q \\times S \\times B$。两边除以 $B$（非零），得到 $W/L = qS$。这意味着每行的缓存行数 $W/L$ 是缓存组数 $S$ 的整数倍。\n设 $n = W/L=qS$。我们可以写成 $W = nL = (qS)L$。\n将此代入索引公式：\n$$\n\\text{Index}(r, c) = \\left( m + \\left\\lfloor \\frac{r(qS)L+c}{L} \\right\\rfloor \\right) \\pmod{S} = \\left( m + \\left\\lfloor rqS + \\frac{c}{L} \\right\\rfloor \\right) \\pmod{S}\n$$\n因为 $r$、$q$ 和 $S$ 都是整数，所以 $rqS$ 是一个整数。因此：\n$$\n\\text{Index}(r, c) = \\left( m + rqS + \\left\\lfloor \\frac{c}{L} \\right\\rfloor \\right) \\pmod{S}\n$$\n由于 $rqS$ 是 $S$ 的倍数，它对模 $S$ 的和的贡献为 $0$。因此，索引简化为：\n$$\n\\text{Index}(r, c) = \\left( m + \\left\\lfloor \\frac{c}{L} \\right\\rfloor \\right) \\pmod{S}\n$$\n这是一个关键结果：元素 $(r,c)$ 的缓存组索引仅取决于其列 $c$，而不取决于其行 $r$。同一列中的所有元素，$\\text{A}[0][c], \\text{A}[1][c], \\dots, \\text{A}[H-1][c]$，都映射到完全相同的缓存组。\n\n现在，考虑按列遍历。外层循环固定一个列 $c$，内层循环遍历行 $r = 0, 1, \\dots, H-1$。\n对于一个固定的列 $c$，所有 $H$ 次访问都映射到同一个组。让我们追踪内层循环：\n1. 访问 $\\text{A}[0][c]$：这次访问是一次未命中。（缓存要么是空的，要么包含来自前一个外层循环迭代中不同行列块的缓存行）。包含第 0 行元素的缓存行被加载到确定的组中。\n2. 访问 $\\text{A}[1][c]$：这次访问映射到同一个组。然而，元素 $\\text{A}[1][c]$ 位于不同的缓存行中（一个对应于第 1 行的缓存行）。因为缓存是直接映射的，所以这个新的行必须替换刚刚加载的第 0 行的行。这是一次冲突未命中（conflict miss）。\n3. 访问 $\\text{A}[2][c]$：这次访问也映射到同一个组，需要第 2 行的缓存行，因此会驱逐第 1 行的缓存行。这是另一次冲突未命中。\n\n这种驱逐模式在内层循环的所有 $H$ 次访问中都会持续。对于任何给定的列 $c$，每一次的 $H$ 次访问都会导致一次缓存未命中。因为有 $W$ 列，所以未命中的总数是：\n$$\nM_{\\text{col}} = H \\times W\n$$\n问题要求按列遍历所产生的缓存未命中总数与按行遍历所产生的缓存未命中总数之比。\n$$\n\\text{Ratio} = \\frac{M_{\\text{col}}}{M_{\\text{row}}} = \\frac{H \\times W}{\\frac{H \\times W}{L}} = L\n$$\n最后，我们使用定义 $L=B/E$，用 $B$ 和 $E$ 来表示这个结果。\n$$\n\\text{Ratio} = \\frac{B}{E}\n$$\n这个结果量化了一种与内存存储布局相悖的访问模式所带来的性能影响，尤其是在会引发严重缓存冲突的条件下。", "answer": "$$\\boxed{\\frac{B}{E}}$$", "id": "3668437"}, {"introduction": "掌握了访问模式对空间局部性的影响后，我们可以更进一步，主动设计数据结构来优化性能。本练习模拟了一个常见的系统设计问题：如何排列一个记录中的字段以最大化缓存效率。你将通过计算和分析，探索如何通过“填充”这一技巧，以可控的内存开销为代价，确保关键数据（热字段）总是能被一次缓存行读取所满足，从而深刻理解性能优化中的权衡之术 [@problem_id:3668467]。", "problem": "一位系统设计师正在优化一个记录数组，以利用单级缓存中的局部性原理。该缓存以大小为 $64$ 字节的固定大小缓存行来获取和存储数据。考虑一种记录类型，其字段按以下顺序占用内存：一个 $24$ 字节的非热点数据块，一个 $8$ 字节的热点字段 $H_{1}$，一个 $8$ 字节的热点字段 $H_{2}$，一个 $4$ 字节的热点字段 $H_{3}$，以及一个 $4$ 字节的非热点字段。假设标准的对齐约束已通过此顺序得到满足，因此不带额外填充的记录大小恰好为 $48$ 字节，并且三个热点字段在每个记录内连续地分布在 $20$ 字节的内存跨度上。\n\n数组的基地址与 $64$ 字节边界对齐。应用程序在一个大数组上执行均匀分布的随机元素访问，并对每个访问的元素读取所有三个热点字段 $H_{1}$、$H_{2}$ 和 $H_{3}$。在这些条件下，由于记录大小 $48$ 和缓存行大小 $64$ 的最大公约数为 $16$，因此记录的起始偏移量模 $64$ 的值以相等的频率取集合 $\\{0,16,32,48\\}$ 中的值。\n\n设计师考虑对记录进行填充以增加空间局部性，通过添加 $16$ 字节的填充，使每个记录的大小恰好变为 $64$ 字节，同时保持热点字段的相对位置连续。数组被分配，以便每个记录都从一个缓存行边界开始。\n\n将此工作负载的空间局部性利用率定义为：对于被访问的记录，其热点字段读操作可由单次缓存行获取所满足的比例。将内存开销分数定义为每个记录增加的填充与原始记录大小的比率。\n\n仅使用上述事实以及时间和空间局部性的定义，推导填充前和填充后的预期空间局部性利用率，计算填充引入的内存开销分数，然后计算效益-开销度量\n$$\\eta=\\frac{\\text{(填充后的空间局部性利用率)}-\\text{(填充前的空间局部性利用率)}}{\\text{内存开销分数}}。$$\n将您的 $\\eta$ 最终值四舍五入到四位有效数字。将最终答案表示为无量纲数。", "solution": "用户要求验证所提供的问题陈述，如果问题被认为是有效的，则随后提供完整的解决方案。\n\n### 问题验证\n\n**第1步：提取已知信息**\n- 缓存行大小：$64$ 字节\n- 原始记录布局：\n  - 非热点数据块：$24$ 字节\n  - 热点字段 $H_{1}$：$8$ 字节\n  - 热点字段 $H_{2}$：$8$ 字节\n  - 热点字段 $H_{3}$：$4$ 字节\n  - 非热点字段：$4$ 字节\n- 原始记录大小：$48$ 字节\n- 热点字段（$H_{1}$、$H_{2}$、$H_{3}$）是连续的，跨越 $20$ 字节。\n- 数组基地址与 $64$ 字节边界对齐。\n- 对于一个被访问的元素，所有三个热点字段都会被读取。\n- 记录的起始偏移量模 $64$ 为 $\\{0, 16, 32, 48\\}$，且频率相等。\n- 提议的修改：为每个记录添加 $16$ 字节的填充。\n- 新记录大小：$64$ 字节。\n- 新布局：每个记录都从一个缓存行边界开始。\n- 空间局部性利用率的定义：由单次缓存行获取满足的热点字段读操作的比例。\n- 内存开销分数的定义：每个记录增加的填充与原始记录大小的比率。\n- 要计算的度量：$\\eta=\\frac{\\text{(填充后的空间局部性利用率)}-\\text{(填充前的空间局部性利用率)}}{\\text{内存开销分数}}$。\n- 最终答案精度：四舍五入到四位有效数字。\n\n**第2步：使用提取的已知信息进行验证**\n- **科学依据：** 该问题牢固地植根于计算机体系结构的原理，特别是存储器层次结构、缓存性能和数据结构对齐。空间局部性、缓存行、填充和性能权衡等概念是标准的，并且表述准确。\n- **问题定义良好：** 所有必要的参数都已定义（缓存行大小、记录大小、数据布局、工作负载）。要计算的度量的定义清晰，可以得出唯一解。\n- **客观性：** 问题以精确、技术性的语言陈述，没有歧义或主观论断。\n- **完整且一致：** 提供的数据是自洽的。关于记录起始偏移量模 $64$ 的值为 $\\{0, 16, 32, 48\\}$ 的陈述，是一个由 $48$ 字节记录组成的数组在 $64$ 字节边界上开始的正确推论，因为 $\\text{gcd}(48, 64) = 16$，并且偏移量的周期长度为 $64/16 = 4$。问题阐述清晰。\n- **现实且可行：** 缓存行和数据字段的字节大小是现代计算系统的典型值。该优化场景是系统设计师面临的一个实际问题。\n\n**第3步：结论与行动**\n该问题是有效的。它在科学上是合理的，问题定义良好，客观且完整。将提供详细的解决方案。\n\n### 解决方案\n\n目标是计算效益-开销度量 $\\eta$，其定义为：\n$$\n\\eta = \\frac{U_{after} - U_{before}}{O_{mem}}\n$$\n其中 $U_{before}$ 是填充前的空间局部性利用率，$U_{after}$ 是填充后的利用率，而 $O_{mem}$ 是内存开销分数。我们将分别计算这三个量。\n\n**1. 内存开销分数 ($O_{mem}$)**\n内存开销分数定义为每个记录增加的填充与原始记录大小的比率。\n原始记录大小为 $48$ 字节。\n增加的填充为 $16$ 字节。\n因此，内存开销分数为：\n$$\nO_{mem} = \\frac{\\text{增加的填充}}{\\text{原始记录大小}} = \\frac{16}{48} = \\frac{1}{3}\n$$\n\n**2. 填充后的空间局部性利用率 ($U_{after}$)**\n填充后，记录大小变为 $48 + 16 = 64$ 字节。问题陈述中提到，数组被分配，使得每个记录都从一个缓存行边界开始。由于缓存行大小也是 $64$ 字节，每个记录完美地恰好占用一个缓存行。\n热点字段（$H_{1}$、$H_{2}$ 和 $H_{3}$）形成一个 $8+8+4 = 20$ 字节的连续块。由于这个块是 $64$ 字节记录的内部部分，它必须完全包含在存放该记录的单个缓存行内。\n因此，对记录热点字段的任何访问都将由单次缓存行获取来满足。\n所以，所有访问的空间局部性利用率均为 $1$。\n$$\nU_{after} = 1\n$$\n\n**3. 填充前的空间局部性利用率 ($U_{before}$)**\n填充前，记录大小为 $48$ 字节。热点字段形成一个 $20$ 字节的块。在记录内部，这些字段之前有一个 $24$ 字节的非热点数据块。因此，一个记录的热点数据从距记录开始处 $24$ 字节的偏移量开始，到 $24 + 20 - 1 = 43$ 字节的偏移量结束。\n\n问题陈述中提到，由于 $48$ 字节的记录大小和 $64$ 字节的数组对齐，一个记录的起始地址模 $64$（缓存行大小）可以以等概率取四个值之一：$S \\in \\{0, 16, 32, 48\\}$。每种情况发生的概率为 $\\frac{1}{4}$。\n\n如果整个 $20$ 字节的热点块落入单个 $64$ 字节的缓存行内，则实现了空间局部性利用。如果热点块不跨越缓存行边界，就会发生这种情况。设一个记录的起始地址为 $A$。热点数据位于绝对地址范围 $[A+24, A+43]$ 内。当且仅当 $\\lfloor \\frac{A+24}{64} \\rfloor \\neq \\lfloor \\frac{A+43}{64} \\rfloor$ 时，此范围会跨越边界。\n让我们针对每个可能的起始偏移量 $S = A \\pmod{64}$ 进行分析。\n相对于缓存行边界，热点数据从相对偏移量 $S+24$ 开始，到相对偏移量 $S+43$ 结束。如果 $\\lfloor \\frac{S+24}{64} \\rfloor = \\lfloor \\frac{S+43}{64} \\rfloor$，则使用单个缓存行。\n\n- **情况 1: $S = 0$**\n  热点数据在缓存行内占据字节偏移量 $[0+24, 0+43] = [24, 43]$。\n  $\\lfloor \\frac{24}{64} \\rfloor = 0$ 且 $\\lfloor \\frac{43}{64} \\rfloor = 0$。数据在一个行内。利用率为 $1$。\n\n- **情况 2: $S = 16$**\n  热点数据在缓存行内占据字节偏移量 $[16+24, 16+43] = [40, 59]$。\n  $\\lfloor \\frac{40}{64} \\rfloor = 0$ 且 $\\lfloor \\frac{59}{64} \\rfloor = 0$。数据在一个行内。利用率为 $1$。\n\n- **情况 3: $S = 32$**\n  热点数据占据字节偏移量 $[32+24, 32+43] = [56, 75]$。\n  $\\lfloor \\frac{56}{64} \\rfloor = 0$ 但 $\\lfloor \\frac{75}{64} \\rfloor = 1$。数据跨越了第一个缓存行（偏移量 $0-63$）和下一个缓存行（偏移量 $64-127$）之间的边界。需要两次缓存行获取。利用率为 $0$。\n\n- **情况 4: $S = 48$**\n  热点数据占据字节偏移量 $[48+24, 48+43] = [72, 91]$。\n  $\\lfloor \\frac{72}{64} \\rfloor = 1$ 且 $\\lfloor \\frac{91}{64} \\rfloor = 1$。虽然数据与记录的起始不在同一个缓存行中，但整个热点块都包含在*下一个*缓存行内。单次缓存行获取（针对下一个行）就足够了。利用率为 $1$。\n\n预期利用率 $U_{before}$ 是这四种等可能情况的平均值：\n$$\nU_{before} = \\frac{1}{4} \\times (1) + \\frac{1}{4} \\times (1) + \\frac{1}{4} \\times (0) + \\frac{1}{4} \\times (1) = \\frac{3}{4}\n$$\n\n**4. 计算度量 $\\eta$**\n现在我们可以将计算出的值代入 $\\eta$ 的公式中：\n$$\n\\eta = \\frac{U_{after} - U_{before}}{O_{mem}} = \\frac{1 - \\frac{3}{4}}{\\frac{1}{3}} = \\frac{\\frac{1}{4}}{\\frac{1}{3}} = \\frac{1}{4} \\times 3 = \\frac{3}{4}\n$$\n将其转换为小数，$\\eta = 0.75$。问题要求答案四舍五入到四位有效数字。\n$$\n\\eta = 0.7500\n$$", "answer": "$$\\boxed{0.7500}$$", "id": "3668467"}, {"introduction": "除了空间局部性，时间局部性——即重复访问同一数据项——同样至关重要，而缓存替换策略正是管理时间局部性的关键。虽然最近最少使用（LRU）策略因其直观有效而广为人知，但它并非万能。本练习将通过构建一个特殊的访问序列，揭示LRU策略在特定负载下可能导致缓存颠簸（thrashing）的性能陷阱，并展示在同样场景下，另一种策略（MRU）为何能表现更优 [@problem_id:3668494]。", "problem": "一个容量为 $M$ 块（$M \\geq 2$）、块大小为 $1$ 个项目的全相联高速缓存由一个单线程程序访问。高速缓存初始为空。考虑两种替换策略：最近最少使用（LRU）和最近刚使用（MRU）。最近最少使用（LRU）在发生未命中时，会淘汰自上次访问以来时间最长的块，而最近刚使用（MRU）在发生未命中时，会淘汰最近刚被访问的块。局部性原理指出，程序倾向于重用时间距离短的数据和指令（时间局部性），并访问邻近的地址（空间局部性）。\n\n构造一个表现出流式访问和轻微时间复用的访问模式，使得 MRU 的性能优于 LRU，然后计算两种策略在该模式下一个宏周期内的总未命中次数。使用以下访问模式：\n$$\nS = \\underbrace{(1,2,\\dots,M,A)}_{\\text{cycle}}, \\text{ repeated exactly } (M+1) \\text{ times},\n$$\n其中符号 $1,2,\\dots,M,A$ 表示不同的高速缓存块，该表示法意味着周期 $(1,2,\\dots,M,A)$ 被连接 $(M+1)$ 次，总共有 $(M+1)^2$ 次访问。符号 $A$ 是一个单一的干扰块，它破坏了对 $1,2,\\dots,M$ 进行流式遍历时的完全复用。\n\n从时间局部性、空间局部性的核心定义以及 LRU 和 MRU 在未命中和命中情况下的行为出发，首先论证为什么序列 $S$ 体现了流式访问和轻微的时间复用，以及为什么可以预期 MRU 在序列 $S$ 上的性能会优于 LRU。然后，从基本原理出发，不使用任何未经证明的快捷公式，推导出 LRU 和 MRU 在整个序列 $S$ 上发生的高速缓存未命中的确切总数。\n\n以“LRU 总未命中数，MRU 总未命中数”的形式提供最终答案。无需四舍五入。最终答案应表示为关于 $M$ 的精确符号表达式。", "solution": "该问题是有效的。它在科学上基于计算机体系结构的原理，特别是高速缓存存储器的组织和性能分析。问题陈述清晰，所有必要参数（高速缓存大小、块大小、替换策略、初始状态、访问模式）都已明确定义。目标明确，问题没有歧义或矛盾。\n\n问题的核心是分析两种高速缓存替换策略——最近最少使用（LRU）和最近刚使用（MRU）——在特定访问模式 $S$ 下的性能。高速缓存的容量为 $M$ 块，块大小为 $1$ 个项目，且高速缓存初始为空。策略定义如下：\n- **LRU**：发生高速缓存未命中时，淘汰最长时间未被访问的块。\n- **MRU**：发生高速缓存未命中时，淘汰最近刚被访问的块。\n\n访问模式由序列 $S = (1, 2, \\dots, M, A)$ 精确重复 $(M+1)$ 次给出。这构成了总共 $(M+1) \\times (M+1) = (M+1)^2$ 次内存访问。符号 $1, 2, \\dots, M, A$ 代表 $M+1$ 个不同的内存块。\n\n首先，我们在局部性原理的背景下分析该访问模式。该序列重复访问块集合 $\\{1, 2, \\dots, M, A\\}$。这种重复构成了时间局部性，因为每个块都会随着时间的推移被重用。任何给定块的重用距离是 $M$ 次访问（例如，块 $1$ 被访问后，接着是 $M$ 个其他不同的块，然后才再次访问 $1$）。子序列 $(1, 2, \\dots, M)$ 是对数据的线性扫描或“流式”访问。干扰块 $A$ 的存在，以及循环中唯一块的总数 $M+1$ 大于高速缓存容量 $M$ 这一事实，造成了高速缓存竞争的情景。这种模式，即一个略大于高速缓存的循环，是用来展示不同替换策略性能差异的经典例子。由于“抖动”，LRU 的性能预计会很差，而 MRU 淘汰最近项的策略预计能保护较旧的、即将被重用的循环项。\n\n我们现在将从基本原理出发，推导每种策略的总未命中次数。\n\n**最近最少使用（LRU）策略分析**\n\nLRU 策略淘汰访问时间最旧的块。我们追踪序列 $S$ 的执行过程。总访问次数为 $(M+1)^2$。\n\n1.  **初始访问**：前 $M$ 次访问是针对不同的块 $1, 2, \\dots, M$。由于高速缓存初始为空，这些都是强制性未命中。\n    -   访问 $1$ 后：高速缓存 = $\\{1\\}$。未命中 = $1$。\n    -   访问 $2$ 后：高速缓存 = $\\{1, 2\\}$。未命中 = $2$。\n    -   ...\n    -   访问 $M$ 后：高速缓存 = $\\{1, 2, \\dots, M\\}$。未命中 = $M$。块按近期性排序，$M$ 是最近使用的，$1$ 是最久未使用的。\n\n2.  **首次容量未命中**：第 $(M+1)$ 次访问是块 $A$。块 $A$ 不在高速缓存中，因此这是一次未命中。高速缓存已满，必须进行淘汰。LRU 淘汰最近最少使用的块，即 $1$。\n    -   访问 $A$ 后：高速缓存 = $\\{2, 3, \\dots, M, A\\}$。未命中 = $M+1$。此时的 LRU 块是 $2$。\n\n3.  **抖动行为**：让我们考虑在高速缓存填满后，访问任何块 $X$ 时高速缓存的状态。大小为 $M$ 的高速缓存将包含紧接在 $X$ 之前访问的 $M$ 个块。在我们这个由 $M+1$ 个不同块组成的循环模式中，任何给定块 $X$ 之前访问的 $M$ 个块恰好是集合 $\\{1, 2, \\dots, M, A\\} \\setminus \\{X\\}$。因此，在访问块 $X$ 时，它永远不会在高速缓存中。这对于前 $M$ 次强制性未命中之后的每一次访问都成立。\n    -   第 $(M+2)$ 次访问是块 $1$（第二个周期的开始）。高速缓存包含 $\\{2, 3, \\dots, M, A\\}$。块 $1$ 不存在。这是一次未命中。LRU 块 $2$ 被淘汰。高速缓存变为 $\\{3, \\dots, M, A, 1\\}$。\n    -   下一次访问是块 $2$。高速缓存包含 $\\{3, \\dots, M, A, 1\\}$。块 $2$ 不存在。这是一次未命中。\n\n这种被称为抖动的模式会无限持续下去。每一次访问都会导致高速缓存未命中。由于序列 $S$ 中总共有 $(M+1)^2$ 次访问，因此 LRU 策略的总未命中数等于总访问数。\n\nLRU 总未命中数 = $(M+1)^2 = M^2 + 2M + 1$。\n\n**最近刚使用（MRU）策略分析**\n\nMRU 策略淘汰访问时间最新的块。我们逐个周期地追踪执行过程。\n\n1.  **周期 1**：访问序列为 $(1, 2, \\dots, M, A)$。\n    -   前 $M$ 次访问（$1, 2, \\dots, M$）是强制性未命中。此后，高速缓存包含 $\\{1, 2, \\dots, M\\}$。最近刚使用的块是 $M$。未命中计数为 $M$。\n    -   第 $(M+1)$ 次访问是块 $A$。这是一次未命中。MRU 淘汰最近刚使用的块，即 $M$。高速缓存变为 $\\{1, 2, \\dots, M-1, A\\}$。新的 MRU 块是 $A$。\n    -   周期 1 的总未命中数：$M+1$。\n\n2.  **周期 2**：访问序列为 $(1, 2, \\dots, M, A)$。\n    -   高速缓存初始内容为 $\\{1, 2, \\dots, M-1, A\\}$。MRU 块是 $A$。\n    -   访问 $1$：命中。高速缓存内容不变。新的 MRU 块是 $1$。\n    -   访问 $2$：命中。... 新的 MRU 是 $2$。\n    -   ...\n    -   访问 $M-1$：命中。新的 MRU 变为 $M-1$。\n    -   访问 $M$：未命中。块 $M$ 不在高速缓存中。MRU 淘汰当前最近刚使用的块，即 $M-1$。高速缓存变为 $\\{1, 2, \\dots, M-2, A, M\\}$。新的 MRU 是 $M$。\n    -   访问 $A$：命中。新的 MRU 是 $A$。\n    -   周期 2 的总未命中数：$1$。\n\n3.  **周期 3**：访问序列为 $(1, 2, \\dots, M, A)$。\n    -   高速缓存初始内容为 $\\{1, 2, \\dots, M-2, A, M\\}$。MRU 块是 $A$。\n    -   访问 $1, ..., M-2$：全部命中。这些访问之后，MRU 块是 $M-2$。\n    -   访问 $M-1$：未命中。淘汰 MRU 块 $M-2$。高速缓存变为 $\\{1, \\dots, M-3, A, M, M-1\\}$。新的 MRU 是 $M-1$。\n    -   访问 $M$：命中。新的 MRU 是 $M$。\n    -   访问 $A$：命中。新的 MRU 是 $A$。\n    -   周期 3 的总未命中数：$1$。\n\n一个模式出现了：对于从 $k=2$ 到 $k=M$ 的每个周期 $k$，都恰好有一次未命中。这次未命中发生在访问块 $M-(k-2)$ 时。\n\n4.  **周期 2 到 M**：共有 $M-1$ 个这样的周期（从 $k=2$ 到 $k=M$）。每个周期贡献恰好 $1$ 次未命中。\n    -   周期 2 到 M 的总未命中数：$M-1$。\n    -   让我们检查周期 $M$ 结束时的状态。未命中的块是 $M-(M-2)=2$。被淘汰的块是 $1$。高速缓存将包含 $\\{A, 2, 3, \\dots, M\\}$。\n\n5.  **周期 M+1**：访问序列为 $(1, 2, \\dots, M, A)$。\n    -   高速缓存初始内容为 $\\{A, 2, 3, \\dots, M\\}$。前一个周期的 MRU 块是 $A$。\n    -   访问 $1$：未命中。淘汰 MRU 块 $A$。高速缓存变为 $\\{2, 3, \\dots, M, 1\\}$。新的 MRU 是 $1$。\n    -   访问 $2$：命中。... 新的 MRU 是 $2$。\n    -   ...\n    -   访问 $M$：命中。新的 MRU 是 $M$。\n    -   访问 $A$：未命中。淘汰 MRU 块 $M$。高速缓存变为 $\\{2, 3, \\dots, M-1, 1, A\\}$。新的 MRU 是 $A$。\n    -   周期 M+1 的总未命中数：$2$。\n\n为了计算 MRU 的总未命中数，我们将所有周期的未命中数相加。\n-   周期 1 的未命中数：$M+1$。\n-   周期 2 到 M（共 $M-1$ 个周期）的未命中数：$(M-1) \\times 1 = M-1$。\n-   周期 M+1 的未命中数：$2$。\n\nMRU 总未命中数 = $(M+1) + (M-1) + 2 = 2M + 2$。\n\n比较两种策略，对于 $M \\geq 2$，LRU 有 $M^2+2M+1$ 次未命中，而 MRU 有 $2M+2$ 次未命中。不等式 $M^2+2M+1  2M+2$ 可简化为 $M^2-1  0$，即 $(M-1)(M+1)  0$，这对所有 $M1$ 都成立。因此，MRU 在此访问模式上的性能明显优于 LRU。\n\n总未命中数的最终结果是：\n-   LRU 总未命中数：$M^2+2M+1 = (M+1)^2$\n-   MRU 总未命中数：$2M+2$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n(M+1)^2  2M+2\n\\end{pmatrix}\n}\n$$", "id": "3668494"}]}