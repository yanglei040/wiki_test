{"hands_on_practices": [{"introduction": "内存调度的核心在于对DRAM底层时序约束的精确掌握。本练习将引导你手动计算一个命令序列的最短调度时间，通过应用一系列基础时序参数（如 $t_{RCD}$、$t_{RTW}$ 等），你将深入理解内存控制器必须遵守的刚性规则。这个过程好比学习DRAM命令语言的“语法”，是设计高效内存系统的基石。[@problem_id:3656949]", "problem": "一个内存控制器针对一个单列（single-rank）、单存储体（single-bank）的动态随机存取存储器（DRAM）设备，并且必须向同一个存储体调度以下固定的命令序列：激活（Activate, $\\mathrm{ACT}$）、读取（Read, $\\mathrm{RD}$）、写入（Write, $\\mathrm{WR}$）、读取（Read, $\\mathrm{RD}$）、预充电（Precharge, $\\mathrm{PRE}$）。该控制器每个命令时钟周期最多发出一个命令。下面所有的时序参数都以命令时钟周期为单位。\n\n使用以下设备级约束，这些是控制器为保证正确性必须遵守的不变时序规则：\n- 行至列延迟：在对一个存储体发出$\\mathrm{ACT}$命令后，发往该存储体的第一个列命令（$\\mathrm{RD}$或$\\mathrm{WR}$）必须至少延迟$t_{RCD}$个周期。\n- 列至列延迟：在发往同一列（rank）的任意两个连续列命令（任何$\\mathrm{RD}$或$\\mathrm{WR}$）之间，必须至少有$t_{CCD}$个周期。\n- 读到写总线转换：从一个$\\mathrm{RD}$命令到一个后续的$\\mathrm{WR}$命令，必须至少有$t_{RTW}$个周期以允许数据总线转换。\n- 写到读总线转换：从一个$\\mathrm{WR}$命令到一个后续的$\\mathrm{RD}$命令，必须至少有$t_{WTR}$个周期以允许数据总线转换。\n- 激活到预充电（行活动时间）：在对一个存储体发出$\\mathrm{ACT}$命令后，发往同一存储体的$\\mathrm{PRE}$命令必须至少延迟$t_{RAS}$个周期。\n- 读到预充电：在对一个存储体发出$\\mathrm{RD}$命令后，发往同一存储体的$\\mathrm{PRE}$命令必须至少延迟$t_{RTP}$个周期。\n- 写恢复：在对一个存储体发出$\\mathrm{WR}$命令后，发往同一存储体的$\\mathrm{PRE}$命令必须至少延迟$t_{WR}$个周期。\n\n假设：\n- 在发出$\\mathrm{ACT}$命令之前，DRAM处于空闲和预充电状态。\n- 命令速率为每个周期一个命令（一个命令恰好占用一个命令时钟周期）。\n- 序列中的所有命令都针对同一列（rank）中的同一个存储体（bank）。\n- 没有其他命令被发往任何存储体或列。\n\n时序参数为：\n- $t_{RCD} = 4$, $t_{CCD} = 4$, $t_{RTW} = 6$, $t_{WTR} = 3$, $t_{RAS} = 12$, $t_{RTP} = 4$, $t_{WR} = 6$。\n\n定义调度在周期$0$发出$\\mathrm{ACT}$命令开始。设调度长度$L$为发出$\\mathrm{PRE}$命令的周期索引（即，从周期$0$发出$\\mathrm{ACT}$到发出$\\mathrm{PRE}$所经过的周期数）。计算满足上述所有约束的最小可能$L$。以周期为单位，用一个整数表示你的答案。", "solution": "问题要求确定一个固定的动态随机存取存储器（DRAM）命令序列的最小调度长度。调度长度$L$定义为发出最后一个命令，即预充电（$\\mathrm{PRE}$）命令的周期索引。调度必须遵守一组指定的时序约束。\n\n首先，让我们将问题形式化。命令序列是$\\mathrm{ACT}$、$\\mathrm{RD}$、$\\mathrm{WR}$、$\\mathrm{RD}$、$\\mathrm{PRE}$。为了区分两个读取命令，我们将其表示为$\\mathrm{RD}_1$和$\\mathrm{RD}_2$。因此，序列为$\\mathrm{ACT}, \\mathrm{RD}_1, \\mathrm{WR}, \\mathrm{RD}_2, \\mathrm{PRE}$。\n\n设$C(cmd)$为命令$cmd$发出的周期数。问题陈述调度从周期$0$发出$\\mathrm{ACT}$开始。\n所以，$C(\\mathrm{ACT}) = 0$。\n\n我们的目标是通过找到序列中每个命令最早可能的发出周期来找到$L = C(\\mathrm{PRE})$的最小可能值。我们将按时间顺序进行。\n\n1.  **发出第一个读取命令 ($\\mathrm{RD}_1$)**：\n    $\\mathrm{ACT}$之后的第一个命令是$\\mathrm{RD}_1$。由于$\\mathrm{RD}_1$是一个列命令，其发出受到相对于$\\mathrm{ACT}$命令的行至列延迟$t_{RCD}$的约束。\n    约束为：\n    $$C(\\mathrm{RD}_1) - C(\\mathrm{ACT}) \\ge t_{RCD}$$\n    代入给定值，$C(\\mathrm{ACT}) = 0$ 和 $t_{RCD} = 4$：\n    $$C(\\mathrm{RD}_1) - 0 \\ge 4 \\implies C(\\mathrm{RD}_1) \\ge 4$$\n    $\\mathrm{RD}_1$可以被发出的最早周期是周期$4$。因此，我们设置$C(\\mathrm{RD}_1) = 4$。\n\n2.  **发出写入命令 ($\\mathrm{WR}$)**：\n    $\\mathrm{WR}$命令跟在$\\mathrm{RD}_1$之后。$\\mathrm{WR}$的发出受到相对于$\\mathrm{RD}_1$的两个约束：\n    a.  两个连续列命令之间的列至列延迟$t_{CCD}$。\n        $$C(\\mathrm{WR}) - C(\\mathrm{RD}_1) \\ge t_{CCD}$$\n        $$C(\\mathrm{WR}) \\ge C(\\mathrm{RD}_1) + t_{CCD} = 4 + 4 = 8$$\n    b.  当$\\mathrm{WR}$跟在$\\mathrm{RD}$之后时，所需的读到写总线转换时间$t_{RTW}$。\n        $$C(\\mathrm{WR}) - C(\\mathrm{RD}_1) \\ge t_{RTW}$$\n        $$C(\\mathrm{WR}) \\ge C(\\mathrm{RD}_1) + t_{RTW} = 4 + 6 = 10$$\n    为满足这两个约束，$C(\\mathrm{WR})$必须大于或等于两个下界中的最大值：\n    $$C(\\mathrm{WR}) \\ge \\max(8, 10) = 10$$\n    $\\mathrm{WR}$的最早周期是周期$10$。因此，我们设置$C(\\mathrm{WR}) = 10$。\n\n3.  **发出第二个读取命令 ($\\mathrm{RD}_2$)**：\n    $\\mathrm{RD}_2$命令跟在$\\mathrm{WR}$之后。其发出受到相对于$\\mathrm{WR}$的两个约束：\n    a.  列至列延迟$t_{CCD}$。\n        $$C(\\mathrm{RD}_2) - C(\\mathrm{WR}) \\ge t_{CCD}$$\n        $$C(\\mathrm{RD}_2) \\ge C(\\mathrm{WR}) + t_{CCD} = 10 + 4 = 14$$\n    b.  当$\\mathrm{RD}$跟在$\\mathrm{WR}$之后时，所需的写到读总线转换时间$t_{WTR}$。\n        $$C(\\mathrm{RD}_2) - C(\\mathrm{WR}) \\ge t_{WTR}$$\n        $$C(\\mathrm{RD}_2) \\ge C(\\mathrm{WR}) + t_{WTR} = 10 + 3 = 13$$\n    为满足这两个约束，$C(\\mathrm{RD}_2)$必须大于或等于两个下界中的最大值：\n    $$C(\\mathrm{RD}_2) \\ge \\max(14, 13) = 14$$\n    $\\mathrm{RD}_2$的最早周期是周期$14$。因此，我们设置$C(\\mathrm{RD}_2) = 14$。\n\n4.  **发出预充电命令 ($\\mathrm{PRE}$)**：\n    最后一个命令是$\\mathrm{PRE}$，其周期索引为$L = C(\\mathrm{PRE})$。$\\mathrm{PRE}$命令关闭当前活动的行。其时序受到几个先前命令的约束。\n    a.  激活到预充电时间$t_{RAS}$，这是一行必须保持活动的最小时间。这是从$\\mathrm{ACT}$命令开始测量的。\n        $$C(\\mathrm{PRE}) - C(\\mathrm{ACT}) \\ge t_{RAS}$$\n        $$C(\\mathrm{PRE}) \\ge C(\\mathrm{ACT}) + t_{RAS} = 0 + 12 = 12$$\n    b.  写恢复时间$t_{WR}$，这是在$\\mathrm{WR}$命令之后必须经过的时间，然后存储体才能被预充电。\n        $$C(\\mathrm{PRE}) - C(\\mathrm{WR}) \\ge t_{WR}$$\n        $$C(\\mathrm{PRE}) \\ge C(\\mathrm{WR}) + t_{WR} = 10 + 6 = 16$$\n    c.  读到预充电时间$t_{RTP}$，这是在$\\mathrm{RD}$命令之后必须经过的时间，然后存储体才能被预充电。这个约束必须相对于发出的*最后*一个读取命令来满足，也就是$\\mathrm{RD}_2$。\n        $$C(\\mathrm{PRE}) - C(\\mathrm{RD}_2) \\ge t_{RTP}$$\n        $$C(\\mathrm{PRE}) \\ge C(\\mathrm{RD}_2) + t_{RTP} = 14 + 4 = 18$$\n        （注意：来自$\\mathrm{RD}_1$的约束，$C(\\mathrm{PRE}) \\ge C(\\mathrm{RD}_1) + t_{RTP} = 4 + 4 = 8$，被来自$\\mathrm{RD}_2$的约束严格主导，可以忽略。）\n\n    为满足所有这些约束，$C(\\mathrm{PRE})$必须大于或等于所有下界中的最大值：\n    $$L = C(\\mathrm{PRE}) \\ge \\max(12, 16, 18) = 18$$\n    发出$\\mathrm{PRE}$命令的最小可能周期索引是$18$。\n\n最小延迟调度如下：\n- 周期 $0$：$\\mathrm{ACT}$\n- 周期 $4$：$\\mathrm{RD}_1$（受$t_{RCD}$约束）\n- 周期 $10$：$\\mathrm{WR}$（受$t_{RTW}$约束）\n- 周期 $14$：$\\mathrm{RD}_2$（受$t_{CCD}$约束）\n- 周期 $18$：$\\mathrm{PRE}$（受来自$\\mathrm{RD}_2$的$t_{RTP}$约束）\n\n最小调度长度$L$是$\\mathrm{PRE}$命令的周期索引，即$18$。", "answer": "$$\\boxed{18}$$", "id": "3656949"}, {"introduction": "一个优秀的内存调度器不仅要遵守时序规则，更要做出智能决策以优化性能。这项实践将挑战你从“应用规则”升级到“设计策略”。通过推导并实现一个基于预测的主动预充电策略，你将亲身体验如何将理论模型转化为能切实提升系统性能的调度逻辑。[@problem_id:3656923]", "problem": "您需要设计并实现一个周期精确且简化的动态随机存取存储器（DRAM）bank级调度器。该调度器会根据预测的重用分数，优先执行行关闭（预充电命令），以便为未来的激活操作释放bank。您的设计必须从以下基础且广为接受的DRAM事实和定义出发，并逻辑地推导出一个具体的调度规则。\n\n基本依据：\n- DRAM设备被划分为多个bank。每个bank都有一个行缓冲区，一次可以保持一个打开的行。\n- 核心DRAM操作是激活（ACT）、读或写（RD/WR）和预充电（PRE）。我们使用以下标准时序常数：\n  - 行至列延迟 $t_{\\mathrm{RCD}}$：从ACT到最早的RD/WR的最小时间。\n  - 列访问延迟 $t_{\\mathrm{CL}}$：行被激活后，服务一次读（或写）操作所需的时间。\n  - 预充电时间 $t_{\\mathrm{RP}}$：关闭当前打开行所需的时间。\n- 请求延迟定义为从请求到达bank到其完成的周期数。我们假设：\n  - 如果目标行已经打开（行命中），一个请求一旦开始服务需要 $t_{\\mathrm{CL}}$ 个周期。\n  - 如果bank已关闭（没有打开的行），一个请求一旦开始服务需要 $t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}$ 个周期。\n  - 如果一个不同的行是打开的（行冲突），服务该请求需要 $t_{\\mathrm{RP}} + t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}$ 个周期。\n- 各bank独立服务，且在此模型中命令总线不是瓶颈。一个bank不能重叠服务两个请求；它只有在当前请求完成后才能再次变为可用。\n\n预测重用分数：\n- 对于任何当前打开的行 $r$，提供一个预测的重用分数 $s(r) \\in [0,1]$。将 $s(r)$ 解释为下一次访问该bank将命中同一行 $r$ 的概率，而 $1 - s(r)$ 是命中不同行的概率。\n\n调度问题：\n- 您必须设计一个bank级策略，当一个bank变为空闲时（在当前时间或之前没有待处理的请求），该策略决定是否立即发出预充电（PRE）命令以关闭当前打开的行 $r$。您的设计必须是一个基于基本依据推导出的理性决策，使用到下一个请求的预期关键路径时间来表示，且仅用 $t_{\\mathrm{RCD}}$、$t_{\\mathrm{CL}}$、$t_{\\mathrm{RP}}$ 和 $s(r)$ 表示。\n- 具体来说，推导出一个决策规则，该规则比较在空闲时间内发出主动PRE的预期收益和成本，并将其实现为一个形式为“如果 $s(r)  \\theta$ 则发出PRE”的阈值规则，其中 $\\theta$ 必须从基本依据中证明，并且仅用 $t_{\\mathrm{RCD}}$ 和 $t_{\\mathrm{RP}}$ 表示。除了 $s(r)$ 外，不要假设对未来的到达有任何预知性知识；控制器只能在一个bank空闲时发出主动PRE。如果在当前时间或之前有待处理的请求，bank必须服务该请求，而不能在其前面插入额外的主动PRE。\n\n仿真模型：\n- 每个测试用例使用一个bank。该bank要么处于关闭状态，要么有一个打开的行，其标识符为 $r \\in \\mathbb{Z}_{\\ge 0}$。\n- 请求以元组 $(t_{\\mathrm{arr}}, r, \\mathrm{op})$ 的时间排序序列形式给出，其中整数到达时间 $t_{\\mathrm{arr}}$ 以周期为单位，目标行为 $r$，操作为 $\\mathrm{op} \\in \\{\\mathrm{R}, \\mathrm{W}\\}$。在 $t_{\\mathrm{CL}}$ 下，读和写的服务时间相同。\n- bank仅当在时间 $t$ 空闲且在 $t$ 或之前没有已到达的请求时，才能在时间 $t$ 执行主动PRE。如果选择主动PRE，它会立即在当前的bank空闲时间开始，并占用bank $t_{\\mathrm{RP}}$ 个周期，之后bank关闭。\n- 请求在其到达时间和当前bank空闲时间的最大值时开始服务，然后产生由该开始时间时bank的状态（行命中、关闭或冲突，如上所述）决定的相应服务时间。\n- 请求的延迟是其完成时间减去其到达时间，单位为周期。一个测试用例的结果是该测试用例中所有请求延迟的算术平均值（平均值），以实数形式表示，单位为周期。\n\n测试套件：\n使用以下四个测试用例。在每个用例中，所有时间都以周期为单位，因此请以周期为单位报告输出。预测的重用分数 $s(r)$ 按行标识符给出，并假设在整个仿真过程中保持不变。\n\n所有用例的全局时序参数：\n- $t_{\\mathrm{RCD}} = 12$\n- $t_{\\mathrm{CL}} = 10$\n- $t_{\\mathrm{RP}} = 12$\n\n情况 1：\n- 时间 $0$ 时的初始bank状态：打开行 $1$。\n- 预测重用分数：$s(1) = 0.1$。\n- 请求：一个请求 $(40, 2, \\mathrm{R})$。\n\n情况 2：\n- 时间 $0$ 时的初始bank状态：打开行 $3$。\n- 预测重用分数：$s(3) = 0.9$。\n- 请求：一个请求 $(5, 3, \\mathrm{R})$。\n\n情况 3：\n- 时间 $0$ 时的初始bank状态：打开行 $7$。\n- 预测重用分数：$s(7) = 0.5$。\n- 请求：一个请求 $(50, 9, \\mathrm{R})$。\n\n情况 4：\n- 时间 $0$ 时的初始bank状态：打开行 $4$。\n- 预测重用分数：$s(4) = 0.3$， $s(8) = 0.2$。\n- 请求：三个请求 $(0, 4, \\mathrm{R})$，$(15, 8, \\mathrm{R})$，$(60, 1, \\mathrm{R})$。\n\n要求的最终输出：\n- 您的程序应生成单行输出，其中包含每个测试用例的平均请求延迟（以周期为单位），格式为用方括号括起来的逗号分隔列表，每个值四舍五入到小数点后三位，例如 $[x_1,x_2,x_3,x_4]$。\n\n程序不应读取任何输入；它必须是自包含的，并计算上述测试套件的结果。", "solution": "该问题具有科学依据，表述清晰，并且为获得唯一解提供了所有必要的参数和条件。我将继续推导调度策略并应用它。\n\n问题的核心是推导一个理性的、基于阈值的策略，用于在DRAM bank变为空闲时发出主动预充电命令（PRE）。该决策必须基于最小化下一个访问该bank请求的预期延迟。决策规则将采用以下形式：如果一个打开的行 $r$ 的预测重用分数 $s(r)$ 低于某个阈值 $\\theta$，则为其发出PRE。\n\n首先，让我们确定决策点。当一个bank变为空闲时，比如在时间 $t_{idle}$，可以考虑发出一个主动PRE。此时，有一个打开的行 $r$，并且在 $t_{idle}$ 或之前没有已到达的待处理请求。调度器必须在两种操作之间做出选择：\n\n1.  **保持打开**：将行 $r$ 保持在行缓冲区中打开。\n2.  **主动预充电**：立即发出PRE命令以关闭行 $r$。\n\n最优决策是能够最小化*下一个*请求的预期服务时间的决策。主动预充电策略的关键见解在于，预充电所需的时间 $t_{\\mathrm{RP}}$ 可以在bank的空闲期间被“隐藏”起来。我们将基于这一原则进行推导，并假设空闲期足够长以吸收 $t_{\\mathrm{RP}}$ 的成本。\n\n让我们比较每种策略下下一个请求的预期服务时间。\n\n**策略1：保持打开**\n如果我们保持行 $r$ 打开，下一个请求的服务时间取决于它是行命中还是行冲突。\n-   以概率 $s(r)$，下一个请求命中同一行 $r$，导致行命中。服务时间为 $t_{\\mathrm{CL}}$。\n-   以概率 $1 - s(r)$，下一个请求命中不同的行，导致行冲突。这需要一个PRE、一个ACT，然后是RD/WR访问。服务时间为 $t_{\\mathrm{RP}} + t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}$。\n\n如果我们保持行打开，预期的服务时间 $E_{\\text{keep}}$ 为：\n$$E_{\\text{keep}} = s(r) \\cdot t_{\\mathrm{CL}} + (1 - s(r)) \\cdot (t_{\\mathrm{RP}} + t_{\\mathrm{RCD}} + t_{\\mathrm{CL}})$$\n\n**策略2：主动预充电**\n如果我们发出一个主动PRE，当下一个请求到达时，bank将处于关闭状态。这假设从bank在 $t_{idle}$ 变为空闲到下一个请求到达之间的空闲时间大于 $t_{\\mathrm{RP}}$。\n-   以概率 $1$，下一个请求将发现一个关闭的bank，导致bank未命中（或行未命中）。这需要一个ACT命令，然后是RD/WR访问。服务时间为 $t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}$。\n\n如果我们主动预充电，预期的服务时间 $E_{\\text{precharge}}$ 为：\n$$E_{\\text{precharge}} = 1 \\cdot (t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}) = t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}$$\n\n一个理性的调度器应该在主动PRE的预期服务时间低于保持行打开的预期服务时间时选择发出主动PRE。因此，预充电的条件是 $E_{\\text{precharge}}  E_{\\text{keep}}$。\n\n$$t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}  s(r) \\cdot t_{\\mathrm{CL}} + (1 - s(r)) \\cdot (t_{\\mathrm{RP}} + t_{\\mathrm{RCD}} + t_{\\mathrm{CL}})$$\n\n让我们展开并简化这个不等式，以找到 $s(r)$ 的阈值：\n$$t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}  s(r) t_{\\mathrm{CL}} + t_{\\mathrm{RP}} + t_{\\mathrm{RCD}} + t_{\\mathrm{CL}} - s(r)t_{\\mathrm{RP}} - s(r)t_{\\mathrm{RCD}} - s(r) t_{\\mathrm{CL}}$$\n\n右侧的 $s(r) t_{\\mathrm{CL}}$ 项相互抵消。\n$$t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}  t_{\\mathrm{RP}} + t_{\\mathrm{RCD}} + t_{\\mathrm{CL}} - s(r)(t_{\\mathrm{RP}} + t_{\\mathrm{RCD}})$$\n\n我们可以从两边减去 $t_{\\mathrm{RCD}} + t_{\\mathrm{CL}}$：\n$$0  t_{\\mathrm{RP}} - s(r)(t_{\\mathrm{RP}} + t_{\\mathrm{RCD}})$$\n\n现在，我们解出 $s(r)$：\n$$s(r)(t_{\\mathrm{RP}} + t_{\\mathrm{RCD}})  t_{\\mathrm{RP}}$$\n$$s(r)  \\frac{t_{\\mathrm{RP}}}{t_{\\mathrm{RP}} + t_{\\mathrm{RCD}}}$$\n\n这就得到了我们想要的阈值规则。阈值 $\\theta$ 为：\n$$\\theta = \\frac{t_{\\mathrm{RP}}}{t_{\\mathrm{RP}} + t_{\\mathrm{RCD}}}$$\n策略是：当bank变为空闲时，如果当前打开的行 $r$ 的重用分数 $s(r)  \\theta$，则发出一个主动PRE。否则，保持该行打开。\n\n使用全局指定的时序参数：\n-   $t_{\\mathrm{RCD}} = 12$ 周期\n-   $t_{\\mathrm{RP}} = 12$ 周期\n\n阈值 $\\theta$ 的数值为：\n$$\\theta = \\frac{12}{12 + 12} = \\frac{12}{24} = 0.5$$\n我们的调度策略是，如果 $s(r)  0.5$，则发出主动PRE。\n\n现在，我们将应用此策略来仿真给定的测试用例。我们同样使用 $t_{\\mathrm{CL}} = 10$。\n\n**情况 1：**\n-   初始状态：时间 $t=0$，bank在行1上打开，bank在 $t_{free}=0$ 时空闲。\n-   重用分数：$s(1) = 0.1$。\n-   请求：$(40, 2, \\mathrm{R})$。\n1.  在 $t=0$ 时，bank是空闲的。下一个请求在 $t_{arr}=40$ 到达。由于 $t_{free}  t_{arr}$，可以做出主动决策。\n2.  打开的行是1，其分数为 $s(1)=0.1$。我们检查条件：$s(1)  0.5$？是的，$0.1  0.5$。\n3.  操作：发出一个主动PRE。此操作从 $t=0$ 开始，耗时 $t_{\\mathrm{RP}}=12$ 个周期。Bank变为关闭状态，并在 $t_{free} = 0 + 12 = 12$ 时再次空闲。\n4.  请求 $(40, 2, \\mathrm{R})$ 在 $t=40$ 到达。它可以在 $\\max(t_{arr}, t_{free}) = \\max(40, 12) = 40$ 时开始服务。\n5.  在 $t=40$ 时，bank是关闭的。对行2的请求是bank未命中。服务时间 = $t_{\\mathrm{RCD}} + t_{\\mathrm{CL}} = 12 + 10 = 22$ 个周期。\n6.  请求在 $t_{comp} = 40 + 22 = 62$ 完成。\n7.  延迟 = $t_{comp} - t_{arr} = 62 - 40 = 22$ 个周期。平均延迟是 $22.0$。\n\n**情况 2：**\n-   初始状态：时间 $t=0$，bank在行3上打开，bank在 $t_{free}=0$ 时空闲。\n-   重用分数：$s(3) = 0.9$。\n-   请求：$(5, 3, \\mathrm{R})$。\n1.  在 $t=0$ 时，bank是空闲的。下一个请求在 $t_{arr}=5$ 到达。由于 $t_{free}  t_{arr}$，可以做出主动决策。\n2.  打开的行是3，其分数为 $s(3)=0.9$。我们检查条件：$s(3)  0.5$？不，$0.9 \\not 0.5$。\n3.  操作：保持行3打开。Bank保持空闲，空闲时间为 $t_{free}=0$。\n4.  请求 $(5, 3, \\mathrm{R})$ 在 $t=5$ 到达。它可以在 $\\max(5, 0) = 5$ 时开始服务。\n5.  在 $t=5$ 时，bank的行3是打开的。请求是针对行3的，这是一个行命中。服务时间 = $t_{\\mathrm{CL}} = 10$ 个周期。\n6.  请求在 $t_{comp} = 5 + 10 = 15$ 完成。\n7.  延迟 = $15 - 5 = 10$ 个周期。平均延迟是 $10.0$。\n\n**情况 3：**\n-   初始状态：时间 $t=0$，bank在行7上打开，bank在 $t_{free}=0$ 时空闲。\n-   重用分数：$s(7) = 0.5$。\n-   请求：$(50, 9, \\mathrm{R})$。\n1.  在 $t=0$ 时，bank是空闲的。下一个请求在 $t_{arr}=50$ 到达。由于 $t_{free}  t_{arr}$，可以做出主动决策。\n2.  打开的行是7，其分数为 $s(7)=0.5$。我们检查：$s(7)  0.5$？不，$0.5 \\not 0.5$（严格不等式）。\n3.  操作：保持行7打开。Bank在 $t_{free}=0$ 时空闲。\n4.  请求 $(50, 9, \\mathrm{R})$ 在 $t=50$ 到达。它可以在 $\\max(50, 0) = 50$ 时开始服务。\n5.  在 $t=50$ 时，bank的行7是打开的。请求是针对行9的，这是一个行冲突。服务时间 = $t_{\\mathrm{RP}} + t_{\\mathrm{RCD}} + t_{\\mathrm{CL}} = 12 + 12 + 10 = 34$ 个周期。\n6.  请求在 $t_{comp} = 50 + 34 = 84$ 完成。\n7.  延迟 = $84 - 50 = 34$ 个周期。平均延迟是 $34.0$。\n\n**情况 4：**\n-   初始状态：时间 $t=0$，bank在行4上打开，bank在 $t_{free}=0$ 时空闲。\n-   分数：$s(4) = 0.3$，$s(8) = 0.2$。其他行默认为0。\n-   请求：$(0, 4, \\mathrm{R})$，$(15, 8, \\mathrm{R})$，$(60, 1, \\mathrm{R})$。\n1.  **请求 1: (0, 4, R)**。在 $t_{arr}=0$ 到达。由于一个请求在 $t_{free}=0$ 时已到达，不考虑主动PRE。\n    -   开始时间：$\\max(0, 0) = 0$。\n    -   Bank的行4是打开的。请求是针对行4的。行命中。服务时间：$t_{\\mathrm{CL}} = 10$。\n    -   完成时间：$t_{comp} = 0 + 10 = 10$。延迟：$10 - 0 = 10$。\n    -   Bank现在在 $t_{free}=10$ 时空闲，行4保持打开。\n2.  **请求间歇期 1**。在 $t=10$ 时，bank是空闲的。下一个请求在 $t_{arr}=15$ 到达。可以做出主动决策。\n    -   打开的行是4，$s(4) = 0.3$。检查：$0.3  0.5$？是的。\n    -   操作：发出主动PRE。这需要 $t_{\\mathrm{RP}}=12$ 个周期。Bank现在关闭，并在 $t_{free} = 10 + 12 = 22$ 时空闲。\n3.  **请求 2: (15, 8, R)**。在 $t_{arr}=15$ 到达。\n    -   开始时间：$\\max(15, 22) = 22$。\n    -   Bank是关闭的。Bank未命中。服务时间：$t_{\\mathrm{RCD}} + t_{\\mathrm{CL}} = 12 + 10 = 22$。\n    -   现在打开行8。\n    -   完成时间：$t_{comp} = 22 + 22 = 44$。延迟：$44 - 15 = 29$。\n    -   Bank现在在 $t_{free}=44$ 时空闲，行8保持打开。\n4.  **请求间歇期 2**。在 $t=44$ 时，bank是空闲的。下一个请求在 $t_{arr}=60$ 到达。可以做出主动决策。\n    -   打开的行是8，$s(8) = 0.2$。检查：$0.2  0.5$？是的。\n    -   操作：发出主动PRE。这需要 $t_{\\mathrm{RP}}=12$ 个周期。Bank现在关闭，并在 $t_{free} = 44 + 12 = 56$ 时空闲。\n5.  **请求 3: (60, 1, R)**。在 $t_{arr}=60$ 到达。\n    -   开始时间：$\\max(60, 56) = 60$。\n    -   Bank是关闭的。Bank未命中。服务时间：$t_{\\mathrm{RCD}} + t_{\\mathrm{CL}} = 22$。\n    -   完成时间：$t_{comp} = 60 + 22 = 82$。延迟：$82 - 60 = 22$。\n6.  总延迟 = $10 + 29 + 22 = 61$。请求数 = $3$。\n7.  平均延迟 = $61 / 3 \\approx 20.333$。\n\n最终结果：\n-   情况 1：$22.000$\n-   情况 2：$10.000$\n-   情况 3：$34.000$\n-   情况 4：$20.333$", "answer": "[22.000, 10.000, 34.000, 20.333]", "id": "3656923"}, {"introduction": "要理解内存控制器在真实负载下的行为，我们需要借助更高层次的系统模型。本练习引入了排队论这一强大工具，用于分析系统级的性能表现。通过将内存控制器建模为一个 M/D/1 排队系统，你将学会如何预测平均等待时间等关键性能指标，从而洞察系统瓶颈与资源利用率。[@problem_id:3656957]", "problem": "一个单通道动态随机存取存储器 (DRAM) 控制器对中央处理器 (CPU) 生成的读取请求执行先到先服务 (FCFS) 调度。经验测量表明，请求的到达间隔时间可以很好地用速率为 $\\lambda$ 的泊松过程建模，并且控制器的服务时间主要由固定的行周期和数据突发决定，因此服务时间可以近似为均值为 $E[S]$ 的确定性时间。假设这是一个单服务器队列，请求不会中途放弃，并且控制器是功保守的。\n\n从泊松到达过程的基本性质、单服务器系统的流量强度 $\\rho$ 的定义、泊松到达看到时间平均 (PASTA) 性质以及更新过程的剩余服务时间出发，推导出一个 $M/D/1$ 队列近似，用于计算平均排队等待时间 $E[W]$（即请求从到达至其服务开始之间的时间，不包括其自身的服务时间）。然后，使用以下测量参数评估所得表达式：\n- 到达率 $\\lambda = 16 \\times 10^{6}$ 请求/秒。\n- 确定性服务时间 $E[S] = 42 \\times 10^{-9}$ 秒。\n\n使用 $M/D/1$ 近似，并为给定参数提供 $E[W]$ 的数值。将您的答案四舍五入到四位有效数字。用纳秒表示您的最终数值答案。", "solution": "该问题要求推导 M/D/1 队列中的平均等待时间，并进行后续的数值计算。该系统是一个具有泊松到达 (M)、确定性服务时间 (D) 和单个服务器 (1) 的单服务器队列。调度策略是先到先服务 (FCFS)。\n\n首先，我们推导 M/G/1 系统（泊松到达，通用服务时间分布）中平均排队等待时间 $E[W]$ 的通用公式。问题指明了此推导所需的起点。一个新到达请求的等待时间 $W$ 是它在服务开始前在队列中花费的时间。该时间等于清除其到达时系统中已存在的所有请求所需的总服务时间。\n\n假设一个任意请求在时间 $t$ 到达。该请求的等待时间 $W$ 是两个部分之和：\n1. 当前正在服务的请求的剩余服务时间 $S_{res}$（如果有的话）。\n2. 已经在队列中等待的所有其他请求的全部服务时间之和。\n\n设 $N_q$ 为我们的测试请求到达时队列中的请求数（不包括正在服务的请求）。设 $S_i$ 为队列中第 $i$ 个请求的服务时间。等待时间可以表示为：\n$$W = S_{res} + \\sum_{i=1}^{N_q} S_i$$\n为了求平均等待时间 $E[W]$，我们对该表达式取期望：\n$$E[W] = E[S_{res}] + E\\left[\\sum_{i=1}^{N_q} S_i\\right]$$\n对于 M/G/1 队列，服务时间 $S_i$ 是独立同分布的，并且也独立于到达者所看到的队列长度 $N_q$。使用瓦尔德等式，该和的期望变为：\n$$E\\left[\\sum_{i=1}^{N_q} S_i\\right] = E[N_q] E[S]$$\n其中 $E[S]$ 是平均服务时间。根据泊松到达看到时间平均 (PASTA) 性质，一个到达请求所看到的队列中的平均请求数 $E[N_q]$ 等于队列中请求数的时间平均值。根据应用于等待请求队列的利特尔法则，这由 $E[N_q] = \\lambda E[W]$ 给出，其中 $\\lambda$ 是到达率。\n\n将这些结果代回，我们得到：\n$$E[W] = E[S_{res}] + (\\lambda E[W]) E[S]$$\n设 $\\rho = \\lambda E[S]$ 为流量强度或服务器利用率。方程变为：\n$$E[W] = E[S_{res}] + \\rho E[W]$$\n重新整理以求解 $E[W]$（假设系统稳定，即 $\\rho  1$）：\n$$E[W](1 - \\rho) = E[S_{res}]$$\n$$E[W] = \\frac{E[S_{res}]}{1 - \\rho}$$\n下一步是求平均剩余服务时间 $E[S_{res}]$。一个到达的请求发现服务器忙碌的概率为 $\\rho$（再次根据 PASTA），发现服务器空闲的概率为 $1-\\rho$。如果服务器空闲，则 $S_{res} = 0$。如果服务器忙碌，则请求在一个服务周期内的随机时间点到达。在一个服务周期内发生了一次到达，该服务周期的预期剩余时间是更新理论中与检查悖论相关的一个经典结果。对于代表服务时间的随机变量 $S$，预期剩余寿命由 $\\frac{E[S^2]}{2 E[S]}$ 给出。\n\n因此，总的平均剩余服务时间是：\n$$E[S_{res}] = P(\\text{server busy}) \\times E[\\text{residual time} | \\text{busy}] + P(\\text{server idle}) \\times 0$$\n$$E[S_{res}] = \\rho \\times \\frac{E[S^2]}{2 E[S]}$$\n代入 $\\rho = \\lambda E[S]$：\n$$E[S_{res}] = (\\lambda E[S]) \\frac{E[S^2]}{2 E[S]} = \\frac{\\lambda E[S^2]}{2}$$\n现在，我们将 $E[S_{res}]$ 的这个表达式代回我们的 $E[W]$ 方程中：\n$$E[W] = \\frac{\\frac{\\lambda E[S^2]}{2}}{1 - \\rho} = \\frac{\\lambda E[S^2]}{2(1 - \\rho)}$$\n这就是 M/G/1 队列平均等待时间的 Pollaczek-Khinchine 公式。\n\n问题指定了确定性服务时间，这对应于 M/D/1 队列。对于确定性服务时间，服务时长 $S$ 是一个常数。设这个常数为 $D$。那么，平均服务时间是 $E[S] = D$。二阶矩是 $E[S^2] = D^2 = (E[S])^2$。\n将 $E[S^2] = (E[S])^2$ 代入 Pollaczek-Khinchine 公式：\n$$E[W] = \\frac{\\lambda (E[S])^2}{2(1 - \\rho)}$$\n因为 $\\rho = \\lambda E[S]$，我们可以将其重写为：\n$$E[W] = \\frac{(\\lambda E[S]) E[S]}{2(1 - \\rho)} = \\frac{\\rho E[S]}{2(1 - \\rho)}$$\n这就是 M/D/1 队列平均等待时间的最终表达式。\n\n现在，我们使用给定的参数来评估这个表达式：\n- 到达率 $\\lambda = 16 \\times 10^6$ 请求/秒。\n- 确定性服务时间 $E[S] = 42 \\times 10^{-9}$ 秒。\n\n首先，计算流量强度 $\\rho$：\n$$\\rho = \\lambda E[S] = (16 \\times 10^6 \\, \\text{s}^{-1}) \\times (42 \\times 10^{-9} \\, \\text{s})$$\n$$\\rho = 16 \\times 42 \\times 10^{-3} = 672 \\times 10^{-3} = 0.672$$\n由于 $\\rho = 0.672  1$，队列是稳定的，存在稳态等待时间。\n\n接下来，计算平均等待时间 $E[W]$：\n$$E[W] = \\frac{\\rho E[S]}{2(1 - \\rho)} = \\frac{0.672 \\times (42 \\times 10^{-9} \\, \\text{s})}{2(1 - 0.672)}$$\n$$E[W] = \\frac{28.224 \\times 10^{-9} \\, \\text{s}}{2(0.328)} = \\frac{28.224 \\times 10^{-9} \\, \\text{s}}{0.656}$$\n$$E[W] \\approx 43.02439 \\times 10^{-9} \\, \\text{s}$$\n问题要求答案以纳秒为单位，并四舍五入到四位有效数字。由于 $1 \\, \\text{ns} = 10^{-9} \\, \\text{s}$：\n$$E[W] \\approx 43.02439 \\, \\text{ns}$$\n四舍五入到四位有效数字得到 $43.02 \\, \\text{ns}$。", "answer": "$$\\boxed{43.02}$$", "id": "3656957"}]}