{"hands_on_practices": [{"introduction": "理解冲突未命中的最佳方式是构建一个能精准分离出此现象的最小化示例。本练习使用一个精心设计的内存访问模式，强制将三个不同的内存块映射到同一个仅有两路的组相联高速缓存组中，从而展示了定义冲突未命中的“颠簸”现象。通过解决这个问题，你将为有限的关联度如何直接导致性能下降建立起基础直觉。[@problem_id:3625340]", "problem": "一个采用物理索引、物理标签的一级数据缓存有 $S$ 个组，块大小为 $B$ 字节，关联度为 $A$ 路，并采用最近最少使用（LRU）替换策略。该缓存初始为空。考虑一个微基准测试，它进行 $T$ 次迭代，每次迭代按顺序执行以下 3 次加载：从地址 $o$ 加载，然后从地址 $o + S \\cdot B$ 加载，最后从地址 $o + 2 S \\cdot B$ 加载。假设 $o$ 是 $B$ 的一个非负整数倍，因此这些地址中的每一个都指向一个不同块的起始位置。没有其他内存引用，没有预取，并忽略翻译后备缓冲器（TLB）的影响。缓存总容量为 $C = S \\cdot A \\cdot B$ 字节。\n\n请使用组相联缓存中组索引的基本定义和标准的未命中分类法——其中强制性未命中（compulsory miss）是指对一个块的首次引用，容量性未命中（capacity miss）是指在具有相同总容量 $C$ 和 LRU 策略的全相联缓存中同样会发生的未命中，而冲突性未命中（conflict miss）是指既非强制性也非容量性的任何未命中——回答以下问题，以推理该微基准测试的未命中行为：\n\n(1) 判断地址 $o$、$o + S \\cdot B$ 和 $o + 2 S \\cdot B$ 这三个地址是否映射到同一个缓存组，并从基本原理出发证明你的结论。\n\n(2) 对于 $A = 2$ 和 $T = 10^{4}$ 次迭代，从空缓存开始，推导出整个运行过程中的冲突性未命中总数。根据标准未命中分类法精确地对所有未命中进行分类。\n\n(3) 在保持 $S$ 和 $B$ 不变的情况下改变 $A$，确定能够消除除初始强制性未命中外的所有冲突性未命中的最小关联度 $A_{\\min}$，并根据 LRU 下的替换动态来证明你的答案。\n\n请给出所有推理步骤。对于你的最终数值答案，仅报告 $A_{\\min}$ 的值，不带单位。", "solution": "该问题是计算机体系结构中一个明确定义的练习，具体涉及缓存性能分析。它在科学上基于缓存存储器的组织、操作和未命中分类的既定原则。问题陈述是自洽的、客观的且内部一致的，提供了推导唯一解所需的所有必要参数和定义（$S$、$A$、$B$、$T$、访问模式以及未命中分类法）。因此，该问题被认为是有效的，我们可以进行形式化的求解。\n\n解决方案需要解决三个不同的部分。我们将按顺序进行。\n\n(1) 判断这三个地址是否映射到同一个缓存组。\n\n内存地址的组索引由其块地址确定。对于一个块大小为 $B$ 字节、有 $S$ 个组的物理索引缓存，物理地址 $\\alpha$ 的组索引 $i$ 由以下公式给出：\n$$\ni = \\left\\lfloor \\frac{\\alpha}{B} \\right\\rfloor \\pmod S\n$$\n其中 $\\lfloor \\frac{\\alpha}{B} \\rfloor$ 是块地址。我们已知基地址 $o$ 是块大小 $B$ 的非负整数倍。这使我们可以写出 $o = k \\cdot B$，其中 $k$ 为某个非负整数。\n\n让我们计算访问模式中三个地址各自的组索引。\n\n地址 1: $\\alpha_1 = o$。\n块地址为 $\\lfloor \\frac{o}{B} \\rfloor = \\lfloor \\frac{k \\cdot B}{B} \\rfloor = k$。\n组索引为 $i_1 = k \\pmod S$。\n\n地址 2: $\\alpha_2 = o + S \\cdot B$。\n块地址为 $\\lfloor \\frac{o + S \\cdot B}{B} \\rfloor = \\lfloor \\frac{k \\cdot B + S \\cdot B}{B} \\rfloor = \\lfloor k + S \\rfloor = k + S$。\n组索引为 $i_2 = (k + S) \\pmod S$。使用模运算的性质 $(a+b) \\pmod n = ((a \\pmod n) + (b \\pmod n)) \\pmod n$，我们发现：\n$$\ni_2 = (k \\pmod S + S \\pmod S) \\pmod S = (k \\pmod S + 0) \\pmod S = k \\pmod S\n$$\n\n地址 3: $\\alpha_3 = o + 2 S \\cdot B$。\n块地址为 $\\lfloor \\frac{o + 2 S \\cdot B}{B} \\rfloor = \\lfloor \\frac{k \\cdot B + 2 S \\cdot B}{B} \\rfloor = \\lfloor k + 2S \\rfloor = k + 2S$。\n组索引为 $i_3 = (k + 2S) \\pmod S$。应用相同的模运算性质：\n$$\ni_3 = (k \\pmod S + 2S \\pmod S) \\pmod S = (k \\pmod S + 0) \\pmod S = k \\pmod S\n$$\n由于 $i_1 = i_2 = i_3 = k \\pmod S$，所有三个地址都精确地映射到同一个缓存组。我们用 $BLK_0$、$BLK_1$ 和 $BLK_2$ 来表示这三个地址对应的不同块。\n\n(2) 对于 $A = 2$ 和 $T = 10^{4}$，推导出冲突性未命中的总数。\n\n缓存初始为空。我们追踪参数 $A=2$ 时的访问情况。从第 (1) 部分可知，所有 3 个块（$BLK_0, BLK_1, BLK_2$）竞争同一个 2 路组。替换策略是 LRU。\n\n迭代 1 (当 $t=0$):\n- 从地址 $o$ ($BLK_0$) 加载：**未命中**。这是对 $BLK_0$ 的首次引用。该组为空。$BLK_0$ 被加载。组状态：$\\{BLK_0\\}$。这是一个**强制性未命中**。\n- 从地址 $o + S \\cdot B$ ($BLK_1$) 加载：**未命中**。这是对 $BLK_1$ 的首次引用。组中还有一个空位。$BLK_1$ 被加载。组状态：$\\{BLK_0, BLK_1\\}$。LRU 顺序：$BLK_0$ 是 LRU，$BLK_1$ 是 MRU（最近使用）。这是一个**强制性未命中**。\n- 从地址 $o + 2 S \\cdot B$ ($BLK_2$) 加载：**未命中**。这是对 $BLK_2$ 的首次引用。该组已满。LRU 块 $BLK_0$ 被逐出。$BLK_2$ 被加载。组状态：$\\{BLK_1, BLK_2\\}$。LRU 顺序：$BLK_1$ 是 LRU，$BLK_2$ 是 MRU。这是一个**强制性未命中**。\n\n在第一次迭代结束时，共有 3 次未命中，全部是强制性未命中。\n\n迭代 2 (当 $t=1$):\n该组包含 $\\{BLK_1, BLK_2\\}$，其中 $BLK_1$ 是 LRU。\n- 从地址 $o$ ($BLK_0$) 加载：**未命中**。$BLK_0$ 不在组中。LRU 块 $BLK_1$ 被逐出。$BLK_0$ 被加载。组状态：$\\{BLK_2, BLK_0\\}$。LRU 顺序：$BLK_2$ 是 LRU，$BLK_0$ 是 MRU。\n- 从地址 $o + S \\cdot B$ ($BLK_1$) 加载：**未命中**。$BLK_1$ 不在组中。LRU 块 $BLK_2$ 被逐出。$BLK_1$ 被加载。组状态：$\\{BLK_0, BLK_1\\}$。LRU 顺序：$BLK_0$ 是 LRU，$BLK_1$ 是 MRU。\n- 从地址 $o + 2 S \\cdot B$ ($BLK_2$) 加载：**未命中**。$BLK_2$ 不在组中。LRU 块 $BLK_0$ 被逐出。$BLK_2$ 被加载。组状态：$\\{BLK_1, BLK_2\\}$。LRU 顺序：$BLK_1$ 是 LRU，$BLK_2$ 是 MRU。\n\n第 2 次迭代结束时组的状态与第 1 次迭代结束时的状态相同。因此，从 $t=1$ 到 $t=T-1$ 的所有后续迭代中，每次迭代 3 次未命中的模式将会重复。\n\n现在，我们必须对这些未命中进行分类。它们不是强制性的，因为所有块都已在第一次迭代中被访问过。为了区分容量性未命中和冲突性未命中，我们分析一个具有相同容量 $C = S \\cdot A \\cdot B = 2SB$ 的全相联缓存。该缓存可以容纳的块数为 $C/B = 2S$。我们的微基准测试的工作集仅包含 3 个唯一的块。假设 $S \\ge 2$（这对于组相联缓存是典型情况），则以块为单位的容量为 $2S \\ge 4$。由于工作集大小（3 个块）小于缓存容量（$2S$ 个块），全相联缓存在初始强制性未命中之后将能容纳所有 3 个块。因此，在全相联缓存中不会再有未命中。\n我们在 2 路组相联缓存的第 2 次到第 $T$ 次迭代中观察到的未命中不是强制性的，并且在等效的全相联缓存中不会发生。根据定义，这些是**冲突性未命中**。\n\n冲突性未命中的总数是（第一次迭代后的）每次迭代的未命中次数乘以这样的迭代次数。\n- 每次迭代的冲突性未命中次数（对于 $t \\ge 1$）：3。\n- 发生冲突性未命中的迭代次数：$T - 1 = 10^4 - 1 = 9999$。\n- 冲突性未命中总数 = $3 \\times (T - 1) = 3 \\times 9999 = 29997$。\n（注：如果 $S=1$，容量为 2 个块。3 个块的工作集将无法容纳，所有非强制性未命中都将是容量性未命中。然而，问题的结构，特别是要求 $A_{\\min}$ 来消除冲突性未命中，暗示了一种情景，即工作集可以放入缓存，但受限于关联度，即 $3 \\le C/B$，这使得 $S \\ge 2$ 的假设成为隐含条件。）\n\n(3) 确定消除所有冲突性未命中的最小关联度 $A_{\\min}$。\n\n发生冲突性未命中的原因是，映射到单个组的活动块的数量超过了该组的关联度 $A$。在这个微基准测试中，我们已经确定恰好有 3 个唯一的块（$BLK_0$、$BLK_1$、$BLK_2$）映射到同一个组并被重复访问。\n\n为了在初始强制性阶段后消除所有冲突性未命中，缓存组必须足够大，以同时容纳所有这些竞争的块。由于有 3 个这样的块，关联度 $A$ 必须至少为 3。\n让我们验证 $A=3$ 的情况：\n- 迭代 1：对 $BLK_0$、$BLK_1$ 和 $BLK_2$ 的首次访问各自导致一次强制性未命中。在迭代结束时，该组容纳了所有三个块：$\\{BLK_0, BLK_1, BLK_2\\}$。\n- 迭代 2 及以后：访问模式是加载 $BLK_0$，加载 $BLK_1$，加载 $BLK_2$。由于所有三个块都已驻留在该组中（其容量为 3），这些加载中的每一次都将导致**命中**。每次命中都会更新 LRU 状态，但不会有块被逐出。\n\n因此，当关联度为 $A=3$ 时，唯一发生的未命中是最初的 3 次强制性未命中。所有冲突性未命中都被消除了。任何低于 3 的关联度（即 $A=1$ 或 $A=2$）都不足以容纳所有 3 个块，从而导致逐出和随后的冲突性未命中，如第 (2) 部分所示。\n因此，消除所有冲突性未命中的最小关联度是 $A_{\\min} = 3$。", "answer": "$$\n\\boxed{3}\n$$", "id": "3625340"}, {"introduction": "从理论走向实践，虽然综合性示例很有用，但冲突未命中常常在真实世界的代码中以意想不到的方式出现，尤其是在科学计算和数据处理领域。本问题探讨了一个常见场景——访问一个按行主序存储的大型矩阵的列，并演示了特定的访问步长如何创建一个“热点组”，导致大量数据块争夺有限的高速缓存空间。通过这个练习，你将认识到，要编写出高速缓存友好型代码，理解内存布局和访问模式是何等关键。[@problem_id:3625437]", "problem": "考虑一个中央处理器（CPU），其一级数据缓存的参数如下：总容量为 128 KiB，2路组相联，缓存行大小为 64 B。假设缓存使用标准的组索引规则，即缓存组索引是块号对组数取模的结果，其中块号是地址除以缓存行大小的整数部分。矩阵 $A$ 的维度为 $N \\times M$，其中 $N = 512$，$M = 8192$，以行主序存储，且 $A$ 的每个元素都是大小为 8 B 的双精度浮点值。$A$ 的基地址是 $A_0$，它与 64 B 边界对齐。\n\n一个内核连续两次执行以下访问模式：对于从 $0$ 到 $N-1$ 的每个行索引 $i$，它读取 $A[i,0]$ 和 $A[i,k]$，其中 $k$ 是一个正整数。假设在这两次遍历之间没有其他内存访问，也没有预取。您可以假设使用确定性的替换策略，例如最近最少使用（LRU）或任何其他常用策略；下面所要求的结论不应依赖于超出关联度限制的特定策略。\n\n从缓存块号、组索引以及缓存未命中（强制性、容量性和冲突性）的标准分类的定义出发，推导对于每一行 $i$，两个元素 $A[i,0]$ 和 $A[i,k]$ 映射到相同缓存组的条件 $k$。使用这个条件来选择满足它的最小正整数 $k$。您的推导理由必须明确使用 $M$ 是 8 的倍数以及 $A_0$ 与 64 B 对齐这两个事实。\n\n此外，解释为什么在选择的 $k$ 值下，即使所访问的两列数据的总独立数据足迹（以缓存行衡量）可以容纳在缓存容量内，第二次遍历中观察到的未命中仍被归类为冲突未命中。您不需要计算未命中次数；分类的推理必须从基本定义开始。\n\n确保对于所有 $i$，$A[i,0]$ 和 $A[i,k]$ 都位于同一缓存组中的最小正整数 $k$ 是多少？请以精确整数形式提供 $k$ 的值。无需四舍五入。", "solution": "该问题要求找到一个特定的列索引步长 $k$，该步长会导致特定的缓存映射行为，然后对由此产生的缓存未命中进行分类。解决方案分三个阶段进行：首先，计算相关的缓存架构参数；其次，推导关于 $k$ 的条件并找到其最小正整数值；第三，根据标准定义分析缓存未命中。\n\n首先，我们必须根据给定信息确定缓存架构的关键参数。\n缓存容量为 $C = 128 \\text{ KiB} = 128 \\times 2^{10} \\text{ B} = 2^7 \\times 2^{10} \\text{ B} = 2^{17} \\text{ B}$。\n缓存行大小（或块大小）为 $L = 64 \\text{ B} = 2^6 \\text{ B}$。\n关联度为 $W = 2$路。\n缓存行总数为 $N_{lines} = \\frac{C}{L} = \\frac{2^{17}}{2^6} = 2^{11} = 2048$。\n缓存中的组数为 $S = \\frac{N_{lines}}{W} = \\frac{2048}{2} = 1024 = 2^{10}$。\n\n内存地址到缓存组的映射由其块号决定。块号定义为 $\\text{BlockNumber} = \\lfloor \\frac{\\text{Address}}{L} \\rfloor$。然后，组索引由 $\\text{SetIndex} = \\text{BlockNumber} \\pmod S$ 给出。\n\n接下来，我们形式化所访问元素的内存地址。矩阵 $A$ 的维度为 $N \\times M$，其中 $N=512$，$M=8192$。它以行主序存储，每个元素的大小为 $E = 8 \\text{ B}$。元素 $A[i,j]$ 的地址由以下公式给出：\n$$ \\text{Addr}(A[i,j]) = A_0 + (i \\cdot M + j) \\cdot E $$\n其中 $A_0$ 是矩阵的基地址。\n\n问题要求对于任何行 $i$，元素 $A[i,0]$ 和 $A[i,k]$ 都映射到同一个缓存组。这意味着它们的块号必须在模组数 $S$ 下同余。\n设 $B(i,j)$ 为 $A[i,j]$ 地址的块号。条件是：\n$$ B(i,0) \\pmod S = B(i,k) \\pmod S \\quad \\forall i \\in [0, N-1] $$\n这等价于说它们的块号之差必须是 $S$ 的倍数：\n$$ (B(i,k) - B(i,0)) \\pmod S = 0 $$\n我们来计算块号。\n$B(i,0) = \\left\\lfloor \\frac{\\text{Addr}(A[i,0])}{L} \\right\\rfloor = \\left\\lfloor \\frac{A_0 + i \\cdot M \\cdot E}{L} \\right\\rfloor$\n$B(i,k) = \\left\\lfloor \\frac{\\text{Addr}(A[i,k])}{L} \\right\\rfloor = \\left\\lfloor \\frac{A_0 + (i \\cdot M + k) \\cdot E}{L} \\right\\rfloor = \\left\\lfloor \\frac{A_0 + i \\cdot M \\cdot E + k \\cdot E}{L} \\right\\rfloor$\n\n问题陈述，基地址 $A_0$ 与 $64 \\text{ B}$ 边界对齐，这意味着 $A_0$ 是 $L=64$ 的倍数。设 $A_0 = q_0 L$ 对于某个整数 $q_0$。\n我们还必须检查矩阵一行的字节大小：$M \\cdot E = 8192 \\cdot 8 = 2^{13} \\cdot 2^3 = 2^{16} \\text{ B}$。由于 $L=64=2^6 \\text{ B}$，一行的大小是行大小的整数倍：$\\frac{M \\cdot E}{L} = \\frac{2^{16}}{2^6} = 2^{10} = 1024$。这意味着每一行的起始地址 $\\text{Addr}(A[i,0]) = A_0 + i \\cdot M \\cdot E$ 都是 $L$ 的倍数。这个事实是 $A_0$ 对齐和矩阵维度的直接结果。问题中提到 $M$ 是 $8$ 的倍数，这意味着每个缓存行中的元素数量 $L/E = 64/8 = 8$ 能整除列数 $M=8192$，导致一行正好跨越 $8192/8 = 1024$ 个缓存行。\n\n由于 $\\frac{A_0 + i \\cdot M \\cdot E}{L}$ 是整数，因此 $B(i,0)$ 的向下取整函数可以去掉：\n$$ B(i,0) = \\frac{A_0}{L} + i \\cdot \\frac{M \\cdot E}{L} $$\n对于 $B(i,k)$，我们可以使用整数 $n$ 的性质 $\\lfloor x+n \\rfloor = \\lfloor x \\rfloor + n$：\n$$ B(i,k) = \\left\\lfloor \\left(\\frac{A_0}{L} + i \\cdot \\frac{M \\cdot E}{L}\\right) + \\frac{k \\cdot E}{L} \\right\\rfloor = B(i,0) + \\left\\lfloor \\frac{k \\cdot E}{L} \\right\\rfloor $$\n因此，块号之差为：\n$$ B(i,k) - B(i,0) = \\left\\lfloor \\frac{k \\cdot E}{L} \\right\\rfloor $$\n这个差值与行索引 $i$ 无关，所以如果条件对一个 $i$ 成立，那么它对所有 $i$ 都成立。条件 $(B(i,k) - B(i,0)) \\pmod S = 0$ 变为：\n$$ \\left\\lfloor \\frac{k \\cdot E}{L} \\right\\rfloor \\pmod S = 0 $$\n这意味着 $\\lfloor \\frac{k \\cdot E}{L} \\rfloor$ 必须是 $S$ 的整数倍。设其为 $m \\cdot S$，其中 $m$ 是某个整数。为了找到最小的正整数 $k$，我们应该选择最小的正整数倍数，即 $m=1$。\n$$ \\left\\lfloor \\frac{k \\cdot E}{L} \\right\\rfloor = S $$\n代入值 $E=8$，$L=64$ 和 $S=1024$：\n$$ \\left\\lfloor \\frac{k \\cdot 8}{64} \\right\\rfloor = 1024 \\implies \\left\\lfloor \\frac{k}{8} \\right\\rfloor = 1024 $$\n根据向下取整函数的定义，该不等式成立：\n$$ 1024 \\le \\frac{k}{8}  1025 $$\n乘以 $8$：\n$$ 8192 \\le k  8200 $$\n满足此条件的最小正整数 $k$ 是 $k=8192$。\n\n最后，我们必须解释为什么对于 $k=8192$ 这个选择，第二次遍历中的未命中被归类为冲突未命中。\n访问模式涉及矩阵的两列，第 $0$ 列和第 $k=8192$ 列。行数为 $N=512$。因此，程序访问 $A[i,0]$ 和 $A[i,k]$，其中 $i \\in [0, 511]$。\n所访问的独立缓存块集合是那些包含所有 $i$ 的 $A[i,0]$ 和 $A[i,k]$ 的块。$A[i,0]$ 和 $A[i,k]$ 之间的地址差是 $k \\cdot E = 8192 \\cdot 8 = 65536$ 字节，即 $65536/64=1024$ 个缓存块。所以 $A[i,0]$ 和 $A[i,k]$ 在不同的块中。访问的独立块总数为 $2 \\times N = 2 \\times 512 = 1024$。\n这个工作集的内存足迹是 $1024 \\text{ 块} \\times 64 \\frac{\\text{B}}{\\text{块}} = 65536 \\text{ B} = 64 \\text{ KiB}$。\n缓存总容量是 $128 \\text{ KiB}$。由于工作集大小（$64 \\text{ KiB}$）小于缓存容量，第二次遍历中观察到的未命中不可能是容量未命中。根据定义，容量未命中是指在相同容量的全相联缓存中仍会发生的未命中。在这样的缓存中，所有 $1024$ 个块都能装下，所以第二次遍历不会有任何未命中。\n\n我们来分析一下组映射。包含 $A[i,j]$ 的块的组索引是 $I(i,j) = B(i,j) \\pmod S$。\n$A[i,0]$ 的组索引是：\n$$ I(i,0) = \\left(\\frac{A_0}{L} + i \\cdot \\frac{M \\cdot E}{L}\\right) \\pmod S $$\n代入 $\\frac{M \\cdot E}{L} = 1024 = S$：\n$$ I(i,0) = \\left(\\frac{A_0}{L} + i \\cdot S\\right) \\pmod S = \\frac{A_0}{L} \\pmod S $$\n$A[i,k]$ 的组索引是：\n$$ I(i,k) = \\left(B(i,0) + \\left\\lfloor \\frac{k \\cdot E}{L} \\right\\rfloor \\right) \\pmod S = \\left(B(i,0) + S\\right) \\pmod S = B(i,0) \\pmod S = I(i,0) $$\n关键在于，不仅对于给定的 $i$，$A[i,0]$ 和 $A[i,k]$ 映射到同一个组，而且对于所有 $i \\in [0, 511]$，所有被访问的块都映射到同一个组 $s_{conflict} = \\frac{A_0}{L} \\pmod S$。\n缓存是 $2$ 路组相联（$W=2$）的，这意味着这个组 $s_{conflict}$ 一次只能容纳 $2$ 个块。然而，程序试图访问 $1024$ 个不同的块，而这些块都映射到这一个组。\n在第一次遍历期间，随着循环的迭代，它将新的块对（$b(i,0), b(i,k)$）带入组 $s_{conflict}$，导致先前迭代的块被替换出去。例如，当访问 $A[1,0]$ 和 $A[1,k]$ 时，$A[0,0]$ 和 $A[0,k]$ 的块被替换出去（假设是类似 LRU 的策略）。在第一次遍历结束时，只有最后一次迭代的块 $b(511,0)$ 和 $b(511,k)$ 仍留在缓存中。第一次遍历的未命中都是强制性未命中，因为这 $1024$ 个块中的每一个都是首次被访问。\n\n在第二次遍历中，访问序列被重复。当再次访问 $A[0,0]$ 时，它的块不在缓存中，因为它在第一次遍历时被替换出去了。这导致了一次未命中。这次未命中不是强制性的，因为该块之前被访问过。它不是容量未命中，因为整个工作集可以装入缓存。因此，根据定义，它必须是冲突未命中。发生这种未命中是因为工作集中的大量块竞争单个缓存组中有限的槽位（$2$个），这是我们选择的 $k$ 值所造成的病态映射的直接后果。这个推理适用于第二次遍历中的每一次访问，所有这些访问都将是冲突未命中。", "answer": "$$\\boxed{8192}$$", "id": "3625437"}, {"introduction": "最后，我们来探讨另一个常见的冲突原因：对多个地址不幸对齐的数组进行交错访问。本练习研究了直接映射高速缓存——最容易发生冲突的缓存结构——以分析当以固定步长访问多个数组时会发生什么。通过分析高速缓存经过多轮循环后的状态，你将看到最初的强制性未命中如何演变成一连串持续的冲突未命中，从而加深对这两种未命中类型区别的理解。[@problem_id:3625419]", "problem": "考虑一个具有 $S=64$ 个组和块大小为 $B$ 字节的直接映射缓存。字节地址为 $x$ 的内存块的组索引定义为 $i=\\lfloor \\frac{x}{B} \\rfloor \\bmod S$。三个数组 $A$、$B$ 和 $C$ 在主存中布局，使得它们的基块地址模 $S$ 同余；等价地，如果 $a_{0}$、$b_{0}$ 和 $c_{0}$ 表示 $A$、$B$ 和 $C$ 的基块号，则 $a_{0} \\equiv b_{0} \\equiv c_{0} \\pmod{S}$。你将以 $s=3B$ 字节的步幅访问每个数组，即每个数组中连续访问的块号前进 $3$。\n\n定义一个对 $t$ 的两遍循环，其中 $t$ 的范围从 $0$ 到 $63$（含）。在每一遍中，对于每个 $t$，按固定顺序发出三个内存访问：首先是块号为 $a_{0}+3t$ 的 $A$ 数组块，然后是块号为 $b_{0}+3t$ 的 $B$ 数组块，最后是块号为 $c_{0}+3t$ 的 $C$ 数组块。假设在第一遍开始时缓存是空的。\n\n仅使用直接映射索引 $i=\\lfloor \\frac{x}{B} \\rfloor \\bmod S$ 的核心定义和标准的未命中分类（强制性未命中发生在首次引用一个被调入缓存的块时；容量性未命中发生在即使使用最优替换策略缓存也无法容纳工作集时；冲突性未命中发生在多个块映射到组相联或直接映射缓存中的同一组时），完成以下任务：\n\n- 推导由步幅 $s=3B$ 和同余基块条件 $a_{0} \\equiv b_{0} \\equiv c_{0} \\pmod{64}$ 引起的冲突模式，解释每一步中哪些组被访问，以及这三个数组是否在组内发生冲突。\n- 基于该模式，对第一遍中的所有未命中进行分类。\n- 然后，假设访问顺序和地址相同，对第二遍中的所有未命中进行分类，并确定其中有多少是冲突性未命中。\n\n提供在第二遍循环（$t=0,1,\\dots,63$）中发生的冲突性未命中总数作为你的最终答案。答案必须是一个实数值。无需四舍吾入。", "solution": "该问题要求在直接映射缓存中，对一个特定内存访问模式的两遍循环进行缓存未命中分析。我们将首先验证问题陈述，然后进行系统性求解。\n\n### 步骤 1：提取已知条件\n- 缓存架构：直接映射\n- 组数：$S = 64$\n- 块大小：$B$ 字节\n- 组索引函数：$i = \\lfloor \\frac{x}{B} \\rfloor \\bmod S$，其中 $k = \\lfloor \\frac{x}{B} \\rfloor$ 是内存块号。因此，$i = k \\bmod S$。\n- 数组：$A$, $B$, $C$。\n- 基块号：$a_0$, $b_0$, $c_0$。\n- 基块同余：$a_0 \\equiv b_0 \\equiv c_0 \\pmod{S}$，即 $a_0 \\equiv b_0 \\equiv c_0 \\pmod{64}$。\n- 访问步幅：$s = 3B$ 字节，对应块号步幅为 $3$。\n- 循环结构：对 $t$ 进行两遍循环，其中 $t$ 的范围从 $0$ 到 $63$。\n- 每次迭代 $t$ 的访问顺序：\n  1. 访问块号为 $k_A(t) = a_0 + 3t$ 的 $A$ 数组块。\n  2. 访问块号为 $k_B(t) = b_0 + 3t$ 的 $B$ 数组块。\n  3. 访问块号为 $k_C(t) = c_0 + 3t$ 的 $C$ 数组块。\n- 初始条件：在第一遍开始时缓存为空。\n- 任务：确定第二遍中的冲突性未命中总数。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在科学上基于计算机体系结构和缓存行为的原理。它是一个适定问题，提供了所有必要的参数（$S$、访问模式、初始条件）来确定一个唯一的数值答案。语言客观而精确。前提是一致的，所需任务可以通过基于所提供定义的逻辑推导来解决。没有矛盾、歧义或不切实际的假设。该问题被认为是**有效的**。\n\n### 步骤 3：求解推导\n\n#### 冲突模式分析\n内存访问的组索引由其块号对组数 $S=64$ 取模确定。让我们确定一次迭代 $t$ 中三次访问中每一次的组索引。\n\n在步骤 $t$ 时，数组 $A$ 的块号是 $k_A(t) = a_0 + 3t$。对应的组索引是：\n$$i_A(t) = k_A(t) \\pmod S = (a_0 + 3t) \\pmod{64}$$\n\n类似地，对于数组 $B$ 和 $C$：\n$$i_B(t) = k_B(t) \\pmod S = (b_0 + 3t) \\pmod{64}$$\n$$i_C(t) = k_C(t) \\pmod S = (c_0 + 3t) \\pmod{64}$$\n\n我们已知基块地址模 $64$ 同余：$a_0 \\equiv b_0 \\equiv c_0 \\pmod{64}$。设这个公共余数为 $r$。即，$a_0 \\pmod{64} = b_0 \\pmod{64} = c_0 \\pmod{64} = r$。\n利用模运算的性质，我们可以简化组索引表达式：\n$$i_A(t) = (a_0 \\pmod{64} + 3t \\pmod{64}) \\pmod{64} = (r + 3t) \\pmod{64}$$\n$$i_B(t) = (b_0 \\pmod{64} + 3t \\pmod{64}) \\pmod{64} = (r + 3t) \\pmod{64}$$\n$$i_C(t) = (c_0 \\pmod{64} + 3t \\pmod{64}) \\pmod{64} = (r + 3t) \\pmod{64}$$\n\n这个结果至关重要：对于任何给定的迭代 $t$，所有三次内存访问——对块 $k_A(t)$、$k_B(t)$ 和 $k_C(t)$ 的访问——都映射到完全相同的组索引 $i(t) = (r + 3t) \\pmod{64}$。由于缓存是直接映射的，每个组只有一个缓存行。因此，这三次访问将竞争同一个缓存行，导致在每次迭代 $t$ 中发生替换。\n\n接下来，我们分析当 $t$ 从 $0$ 变化到 $63$ 时，被访问的组索引序列。索引序列是 $i(t) = (r + 3t) \\pmod{64}$。被访问的索引集合是 $\\{ (r + 3t) \\pmod{64} \\mid t=0, 1, \\dots, 63 \\}$。当且仅当步幅 $3$ 与组数 $64$ 互质时，这个序列将恰好访问一次从 $0$ 到 $63$ 的每个组。我们计算最大公约数：$\\gcd(3, 64) = 1$，因为 $3$ 的质因数只有 $\\{3\\}$，而 $64=2^6$ 的质因数只有 $\\{2\\}$。\n因为 $\\gcd(3, 64) = 1$，函数 $f(t) = 3t \\pmod{64}$ 是 $\\{0, 1, \\dots, 63\\}$ 的一个排列。这意味着在完整的一遍循环（$t=0, \\dots, 63$）中，$64$ 个组中的每一个都被恰好访问一次。因此，在同一遍循环中，来自不同迭代 $t_1 \\neq t_2$ 的访问不会相互干扰。\n\n#### 第一遍分析（$t=0, \\dots, 63$）\n缓存初始为空。我们分析迭代 $t$ 中的事件。\n1.  **访问 $k_A(t)$**：这是该块首次被引用。对应的组 $i(t)$ 是空的。这导致一次**强制性未命中**。块 $k_A(t)$ 被加载到组 $i(t)$ 的缓存行中。\n2.  **访问 $k_B(t)$**：这是该块首次被引用。它映射到同一个组 $i(t)$，该组当前存有块 $k_A(t)$。由于 $k_B(t) \\ne k_A(t)$（它们属于不同的数组），这次访问导致未命中。因为这是对 $k_B(t)$ 的首次访问，所以这是一次**强制性未命中**。块 $k_A(t)$ 被替换出去，块 $k_B(t)$ 被加载进来。\n3.  **访问 $k_C(t)$**：这是该块首次被引用。它映射到组 $i(t)$，该组现在存有 $k_B(t)$。这导致未命中，同样也是一次**强制性未命中**。块 $k_B(t)$ 被替换出去，块 $k_C(t)$ 被加载进来。\n\n这个模式对从 $0$ 到 $63$ 的每次迭代 $t$ 都会重复。在每次迭代中，有 $3$ 次内存访问，全部 $3$ 次都是强制性未命中。\n第一遍的总访问次数：$64 \\text{ 次迭代} \\times 3 \\text{ 次访问/迭代} = 192$。\n第一遍的总未命中次数：$64 \\times 3 = 192$ 次未命中，全部是强制性未命中。\n\n在第一遍结束时，缓存是满的。对于每个迭代 $t \\in \\{0, \\dots, 63\\}$，加载到组 $i(t)$ 的最后一个块是 $k_C(t)$。因此，在第二遍开始时，每个缓存组 $j \\in \\{0, \\dots, 63\\}$ 都包含块 $k_C(t_j)$，其中 $t_j$ 是 $\\{0, \\dots, 63\\}$ 中使得 $i(t_j) = j$ 的唯一 $t$ 值。\n\n#### 第二遍分析（$t=0, \\dots, 63$）\n第一遍的缓存状态被带到第二遍。我们再次分析迭代 $t$ 中的事件。在第二遍的迭代 $t$ 开始时，缓存组 $i(t)$ 包含块 $k_C(t) = c_0 + 3t$。\n\n1.  **访问 $k_A(t)$**：请求的块是 $k_A(t) = a_0 + 3t$。缓存中存有 $k_C(t)$。这是一次未命中。这次未命中不是强制性的，因为块 $k_A(t)$ 在第一遍中（在相同的迭代 $t$）已经被访问并加载到缓存中。它随后被对 $k_B(t)$ 的访问所替换。因此，这是一次**冲突性未命中**。块 $k_C(t)$ 被替换出去，块 $k_A(t)$ 被加载进来。\n2.  **访问 $k_B(t)$**：请求的块是 $k_B(t) = b_0 + 3t$。缓存现在存有 $k_A(t)$。这是一次未命中。这同样不是强制性未命中，因为块 $k_B(t)$ 在第一遍中被加载过。它被对 $k_C(t)$ 的访问所替换。这是一次**冲突性未命中**。块 $k_A(t)$ 被替换出去，块 $k_B(t)$ 被加载进来。\n3.  **访问 $k_C(t)$**：请求的块是 $k_C(t) = c_0 + 3t$。缓存现在存有 $k_B(t)$。这是一次未命中。块 $k_C(t)$ 在本次迭代开始时就在缓存中，但被对 $k_A(t)$ 的访问所替换。它在第一遍的这次迭代结束时也在缓存中。因此，这是一次**冲突性未命中**。块 $k_B(t)$ 被替换出去，块 $k_C(t)$ 被加载进来。\n\n这个包含三次冲突性未命中的循环在从 $0$ 到 $63$ 的每次迭代 $t$ 中都会发生。循环运行 $64$ 次迭代。\n每次迭代的冲突性未命中次数是 $3$。\n第二遍中冲突性未命中的总数是迭代次数乘以每次迭代的冲突性未命中次数。\n第二遍的总冲突性未命中次数 = $64 \\times 3 = 192$。", "answer": "$$\\boxed{192}$$", "id": "3625419"}]}