{"hands_on_practices": [{"introduction": "理解交错式存储器的第一步是掌握如何将一个给定的内存地址映射到特定的存储体。这个练习 [@problem_id:1941843] 提供了一个具体的场景，它结合了分段式地址转换和低位交错技术。通过计算一个逻辑地址最终访问的物理地址及其对应的存储体编号，你可以巩固地址映射的基本规则。", "problem": "一个32位计算机系统实现了一个基于分段的简化内存管理单元（MMU）。在此方案中，一个逻辑地址由一个段号和一个偏移量组成。物理地址通过将偏移量加到指定段的基地址上来计算。该系统的主存储器采用4路低位交叉编址架构构建，其中存储体的索引为 0、1、2 和 3。对于任意给定的物理地址 $P$，为其服务的存储体 $B$ 由公式 $B = P \\bmod 4$ 确定。\n\n该系统的段表部分定义如下：\n- 段 0 基地址：$2C00A000_{16}$\n- 段 1 基地址：$A1B2C000_{16}$\n- 段 2 基地址：$F01D3000_{16}$\n\n一个进程需要访问位于逻辑地址的数据，该地址对应的段号为1，偏移量为 $0000F7A6_{16}$。\n\n确定将为该请求提供服务的存储体的索引。请以单个整数形式提供答案。", "solution": "在这种分段方案中，逻辑地址通过将偏移量加到所选段的基地址上来转换为物理地址。因此，对于段号为1、基地址为 $A1B2C000_{16}$ 且偏移量为 $0000F7A6_{16}$ 的情况，物理地址 $P$ 为\n$$\nP = A1B2C000_{16} + 0000F7A6_{16}.\n$$\n使用16位部分进行相加，以明确显示进位：\n$$\n\\text{低16位：} C000_{16} + F7A6_{16} = 1B7A6_{16} \\Rightarrow P\\text{的低16位} = B7A6_{16},\\; \\text{进位 } c=1,\n$$\n$$\n\\text{高16位：} A1B2_{16} + 0000_{16} + c = A1B3_{16}.\n$$\n因此，\n$$\nP = A1B3B7A6_{16}.\n$$\n对于4路低位交叉编址，服务的存储体索引由 $B = P \\bmod 4$ 给出。由于模4运算仅取决于最后两位二进制位（等效于最后一位十六进制数的奇偶性和值的范围），而 $P$ 的最后一位十六进制数是 $6$，我们得到\n$$\nB = A1B3B7A6_{16} \\bmod 4 = 6 \\bmod 4 = 2.\n$$\n因此，存储体索引是 $2$。", "answer": "$$\\boxed{2}$$", "id": "1941843"}, {"introduction": "掌握了地址映射的基础后，我们可以进一步探讨访问模式对性能的影响。这个练习 [@problem_id:3657588] 构建了一个思想实验，其中一个特定的内存访问步幅（stride）导致了严重的存储体冲突。通过分析这种情况下的性能损失，你将深刻理解为何精心设计数据访问模式对于发挥交错存储的带宽优势至关重要。", "problem": "一个处理器执行一个紧凑循环，在每次迭代中会发出 $k$ 条加载指令，这些指令相互独立且同时就绪。如果这些请求访问不同的内存体，那么该微体系结构每个周期最多可以发出 $k$ 个内存请求。该内存系统使用 $N$ 路交错的单端口内存体，并采用缓存行粒度的低位交错方式：地址 $a$ 映射到内存体索引 $b(a) = \\left\\lfloor \\frac{a}{L} \\right\\rfloor \\bmod N$，其中 $L$ 是缓存行的大小（以字节为单位）。每个内存体每个周期最多能接受 $1$ 个请求，但是是完全流水线化的。忽略除内存体冲突之外的任何影响（例如，假设互连网络和缺失处理能够维持必要的带宽，并且假设请求延迟可以被流水线完全重叠）。\n\n在每次循环迭代中，这 $k$ 条加载指令访问的地址为 $a_j = a_0 + j \\cdot s$，其中 $j \\in \\{0, 1, \\dots, k-1\\}$，步长为 $s = N \\cdot L$。假设 $a_0$ 是任意的，但在不同迭代中是固定的。将冲突引起的惩罚 $P(k,N)$ 定义为：在此访问模式下，发出所有 $k$ 条加载指令所需的每次迭代的额外周期数，该额外周期数是相对于一个理想的、无冲突的基线而言的。该基线仅受内存体数量的限制（也就是说，该基线在 $N$ 个单端口内存体和 $k$ 的发射宽度下，达到了发出指令所需的最小可能周期数）。\n\n推导 $P(k,N)$ 作为 $k$ 和 $N$ 的函数的闭式表达式。你的最终答案必须是单个解析表达式。不要进行四舍五入。", "solution": "问题要求计算由冲突引起的惩罚，记为 $P(k,N)$。这个惩罚被定义为：在存在内存体冲突的情况下发出所有 $k$ 条加载指令所需的实际周期数 $C_{actual}$，与在理想的、无冲突场景下所需的周期数 $C_{ideal}$ 之间的差值。它们的关系由下式给出：\n$$\nP(k,N) = C_{actual} - C_{ideal}\n$$\n为了求出 $P(k,N)$，我们必须根据问题的参数推导出 $C_{actual}$ 和 $C_{ideal}$ 的表达式。\n\n首先，我们通过分析内存访问模式和由此产生的内存体利用率来确定 $C_{actual}$。对于第 $j$ 条加载指令（其中 $j \\in \\{0, 1, \\dots, k-1\\}$），其地址由等差数列 $a_j = a_0 + j \\cdot s$ 给出。步长 $s$ 被指定为 $s = N \\cdot L$，其中 $N$ 是内存体的数量，$L$ 是缓存行的大小。任何地址 $a$ 的内存体索引 $b(a)$ 由低位交错函数确定：\n$$\nb(a) = \\left\\lfloor \\frac{a}{L} \\right\\rfloor \\bmod N\n$$\n我们可以通过将 $a_j$ 的表达式代入此函数来找到第 $j$ 次访问的内存体索引 $b(a_j)$：\n$$\nb(a_j) = \\left\\lfloor \\frac{a_0 + j \\cdot s}{L} \\right\\rfloor \\bmod N\n$$\n已知 $s = N \\cdot L$，我们将其代入方程：\n$$\nb(a_j) = \\left\\lfloor \\frac{a_0 + j \\cdot N \\cdot L}{L} \\right\\rfloor \\bmod N = \\left\\lfloor \\frac{a_0}{L} + j \\cdot N \\right\\rfloor \\bmod N\n$$\n对于任意实数 $x$ 和任意整数 $i$，向下取整函数（floor function）具有性质 $\\lfloor x + i \\rfloor = \\lfloor x \\rfloor + i$。由于 $j$ 和 $N$ 是整数，它们的乘积 $j \\cdot N$ 也是整数。应用此性质可得：\n$$\nb(a_j) = \\left( \\left\\lfloor \\frac{a_0}{L} \\right\\rfloor + j \\cdot N \\right) \\bmod N\n$$\n对于任意整数 $m$、$q$ 和 $n$，模运算符具有性质 $(m + q \\cdot n) \\bmod n = m \\bmod n$。在我们的表达式中，$\\lfloor a_0/L \\rfloor$、$j$ 和 $N$ 都是整数。因此，我们可以将表达式简化为：\n$$\nb(a_j) = \\left\\lfloor \\frac{a_0}{L} \\right\\rfloor \\bmod N\n$$\n这个结果表明，内存体索引 $b(a_j)$ 是一个常数，不依赖于 $j$。这关键性地意味着循环中所有 $k$ 条加载指令都访问同一个内存体。由于基地址 $a_0$ 是固定的，每次迭代中的所有 $k$ 个请求都被导向索引为 $(\\lfloor a_0/L \\rfloor) \\bmod N$ 的内存体。\n\n问题指出每个内存体都是单端口的，这意味着它每个周期最多能接受 $1$ 个请求。处理器试图同时发出所有 $k$ 个请求。然而，由于所有请求都访问同一个内存体，产生了严重的内存体冲突，因此在第一个周期只能接受 $1$ 个请求。剩下的 $k-1$ 个请求被阻塞。在第二个周期，一个被阻塞的请求被接受，还剩下 $k-2$ 个。这个过程按顺序继续，直到所有 $k$ 个请求都已被该内存体服务。因此，发出所有 $k$ 个请求所需的总周期数为 $k$。\n$$\nC_{actual} = k\n$$\n接下来，我们确定理想周期数 $C_{ideal}$。问题将理想基线定义为一个仅受内存体数量限制且假设没有内存体冲突的场景。这意味着 $k$ 个请求被最优地分布到 $N$ 个可用的内存体上。整个内存系统由 $N$ 个单端口内存体组成，如果每个请求都访问不同的内存体，那么它每个周期最多可以服务 $N$ 个请求。要发出总共 $k$ 个请求，最小周期数是请求总数除以最大服务速率（每周期 $N$ 个请求）。由于周期是离散的，我们必须对结果向上取整。\n$$\nC_{ideal} = \\left\\lceil \\frac{k}{N} \\right\\rceil\n$$\n最后，我们将推导出的 $C_{actual}$ 和 $C_{ideal}$ 的表达式代入原始定义中，以计算惩罚 $P(k,N)$：\n$$\nP(k,N) = C_{actual} - C_{ideal} = k - \\left\\lceil \\frac{k}{N} \\right\\rceil\n$$\n这就得到了由冲突引起的惩罚作为 $k$ 和 $N$ 的函数的最终闭式表达式。", "answer": "$$\n\\boxed{k - \\left\\lceil \\frac{k}{N} \\right\\rceil}\n$$", "id": "3657588"}, {"introduction": "在分析了特定冲突场景后，我们从“事后分析”转向“事前设计”，学习如何主动避免冲突。这个练习 [@problem_id:3657535] 挑战你推导一个通用的公式，用于计算在给定步幅下、能够保证无存储体冲突的最大向量访问长度。这个强大的结论使我们能够预测和优化向量化操作的内存性能，是连接理论与实践的关键一环。", "problem": "一个系统在其动态随机存取存储器（DRAM）中，跨 $N$ 个相同的存储体实现内存交错。存储体选择函数以缓存行粒度定义：地址 $A$ 映射到存储体索引 $b(A) = \\left(\\left\\lfloor \\frac{A}{L} \\right\\rfloor \\bmod N\\right)$，其中 $L$ 是以字节为单位的缓存行大小，且 $N \\geq k$，$k$ 是单条向量指令加载的行数。考虑一个向量加载操作，它向地址 $A_{i} = A_{0} + i S$（其中 $i = 0, 1, \\dots, k-1$）发出 $k$ 次行大小的内存传输，其中 $A_{0}$ 是基地址，$S$ 是以字节为单位的固定步长。为消除指令内存储体冲突，这 $k$ 次行大小的加载必须映射到 $k$ 个不同的存储体。\n\n从 $b(A)$ 的定义和关于剩余类的模运算标准结果出发，假设存在基于行的传输所特有的对齐约束，具体来说，$A_{0}$ 与缓存行边界对齐，并且步长是行大小的整数倍（即 $A_{0} \\equiv 0 \\pmod{L}$ 且 $S \\equiv 0 \\pmod{L}$）。推导在这些对齐约束下，能够保证访问不同存储体的最大向量长度 $k_{\\max}$，并仅用 $N$、$L$ 和 $S$ 进行符号化表示。您的最终答案必须是单个闭式解析表达式。不需要进行四舍五入，并且表达式中不应包含任何物理单位。", "solution": "首先，我们使用给定的对齐约束来简化存储体索引 $b(A_i)$ 的表达式。约束条件是：\n1.  $A_{0}$ 与缓存行边界对齐：$A_{0} \\equiv 0 \\pmod{L}$。这意味着 $A_{0}$ 是 $L$ 的整数倍。我们可以写成 $A_{0} = m_{0}L$，其中 $m_{0}$ 为某个非负整数。\n2.  步长 $S$ 是行大小 $L$ 的整数倍：$S \\equiv 0 \\pmod{L}$。这意味着 $S = m_{S}L$，其中 $m_{S}$ 为某个整数。\n\n将这些代入地址公式 $A_{i} = A_{0} + i S$，我们得到：\n$$A_{i} = m_{0}L + i(m_{S}L) = (m_{0} + i m_{S})L$$\n现在，我们将这个简化的地址 $A_i$ 代入存储体选择函数 $b(A) = \\left(\\left\\lfloor \\frac{A}{L} \\right\\rfloor \\bmod N\\right)$：\n$$b(A_{i}) = \\left(\\left\\lfloor \\frac{(m_{0} + i m_{S})L}{L} \\right\\rfloor \\bmod N\\right)$$\n由于 $m_0$、$i$ 和 $m_S$ 都是整数，向下取整函数内的项可以简化为一个整数。因此，向下取整操作是多余的。\n$$\\left\\lfloor \\frac{(m_{0} + i m_{S})L}{L} \\right\\rfloor = m_{0} + i m_{S}$$\n因此，第 $i$ 次访问的存储体索引变为：\n$$b(A_{i}) = (m_{0} + i m_{S}) \\pmod{N}$$\n这表明存储体索引序列构成一个模 $N$ 的等差数列。\n\n为了使向量加载无存储体冲突，所有 $k$ 个存储体索引 $b(A_{0}), b(A_{1}), \\dots, b(A_{k-1})$ 必须是不同的。如果对于两个不同的索引 $i, j \\in \\{0, 1, \\dots, k-1\\}$ 有 $b(A_{i}) = b(A_{j})$，则发生冲突。不失一般性，假设 $i > j$。冲突的条件是：\n$$(m_{0} + i m_{S}) \\equiv (m_{0} + j m_{S}) \\pmod{N}$$\n从两边减去 $m_{0}$ 和 $j m_{S}$，我们得到：\n$$(i - j) m_{S} \\equiv 0 \\pmod{N}$$\n令 $\\Delta i = i - j$。由于 $0 \\le j  i \\le k-1$，我们有 $1 \\le \\Delta i \\le k-1$。如果同余式 $\\Delta i \\cdot m_{S} \\equiv 0 \\pmod{N}$ 在此范围内对 $\\Delta i$ 有解，则会发生冲突。\n\n为保证长度为 $k$ 的向量没有冲突，我们必须确保该同余式在 $1 \\le \\Delta i \\le k-1$ 范围内无解。我们感兴趣的是满足此同余式的最小正整数 $\\Delta i$。这个值将决定存储体索引序列中重复的周期。在重复发生之前生成的唯一存储体索引的数量恰好是这个最小的正 $\\Delta i$。\n\n根据数论，对于形如 $ax \\equiv 0 \\pmod n$ 的线性同余式，其最小正整数解 $x$ 由 $x = \\frac{n}{\\gcd(a, n)}$ 给出。在我们的问题中，$x = \\Delta i$，$a = m_{S}$，$n=N$。因此，发生冲突的最小正整数 $\\Delta i$ 是：\n$$\\Delta i_{\\min} = \\frac{N}{\\gcd(m_{S}, N)}$$\n这个值代表了该序列生成的不同存储体索引的数量。索引为 $0, 1, \\dots, \\Delta i_{\\min}-1$ 的访问都将映射到不同的存储体。索引为 $\\Delta i_{\\min}$ 的访问将与索引为 $0$ 的访问发生冲突，因为它们的索引差是 $\\Delta i_{\\min}$。\n\n因此，保证无冲突的最大连续访问次数恰好是这个值。最大向量长度 $k_{\\max}$ 是：\n$$k_{\\max} = \\frac{N}{\\gcd(m_{S}, N)}$$\n最后，我们必须用原始问题变量 $N$、$L$ 和 $S$ 来表示这个结果。我们定义了 $m_{S} = \\frac{S}{L}$。由于 $S$ 是 $L$ 的整数倍，$\\frac{S}{L}$ 是一个整数。将其代回，得到 $k_{\\max}$ 的最终表达式：\n$$k_{\\max} = \\frac{N}{\\gcd\\left(\\frac{S}{L}, N\\right)}$$\n这就是在给定的对齐约束下，能够保证访问不同内存存储体的最大向量长度。", "answer": "$$\\boxed{\\frac{N}{\\gcd\\left(\\frac{S}{L}, N\\right)}}$$", "id": "3657535"}]}