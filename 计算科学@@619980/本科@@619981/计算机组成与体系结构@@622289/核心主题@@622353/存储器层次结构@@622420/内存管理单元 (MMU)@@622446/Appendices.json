{"hands_on_practices": [{"introduction": "要真正掌握内存管理单元（MMU）的角色，我们必须首先理解它所管理的内存规模。第一个实践将我们带回基础。通过从地址宽度和页面大小等基本参数推导物理帧和页表条目的数量公式，你将对虚拟内存和物理内存如何划分建立起定量的理解。[@problem_id:3657823]", "problem": "一个计算机系统使用内存管理单元 (MMU)，该单元实现具有固定大小页面的纯分页机制。该系统具有 $v$ 位的虚拟地址 (VA) 宽度和 $p_{a}$ 位的物理地址 (PA) 宽度。每个页面的大小为 $p$ 字节。MMU 采用单级页表，每个页表条目 (PTE) 将一个虚拟页面映射到一个物理帧。假设没有分段、没有超级页面、没有保留区域，并且所有可寻址的虚拟空间和物理内存都已完全填充且可用。同时假设页面大小是 2 的精确幂次方字节，以便页面偏移字段能够明确定义。\n\n从分页系统中地址分解的核心定义出发，推导出不同物理帧的最大数量 $F$ 和覆盖整个虚拟地址空间所需的 PTE 数量 $N$，并用 $v$、$p_{a}$ 和 $p$ 来表示。然后，对于特定的机器参数 $v = 36$、$p_{a} = 32$ 和 $p = 2^{12}$ 字节，计算你推导出的表达式的值。\n\n将你的最终答案表示为一个行矩阵 $\\left(F \\;\\; N\\right)$，其中两个条目均为精确整数。不需要四舍五入，最终答案中也不应包含单位。", "solution": "用户要求对一个关于计算机系统内存管理单元 (MMU) 的问题进行严格验证，并在问题有效的情况下提供解决方案。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 系统使用具有固定大小页面的纯分页机制。\n- 虚拟地址 (VA) 宽度为 $v$ 位。\n- 物理地址 (PA) 宽度为 $p_{a}$ 位。\n- 页面大小为 $p$ 字节。\n- 页表是单级结构。\n- 每个页表条目 (PTE) 将一个虚拟页面映射到一个物理帧。\n- 假设没有分段、没有超级页面、没有保留区域。\n- 所有可寻址的虚拟空间和物理内存都已完全填充且可用。\n- 页面大小 $p$ 是 2 的精确幂次方。\n- 用于求值的具体参数为 $v = 36$、$p_{a} = 32$ 和 $p = 2^{12}$ 字节。\n- 目标是推导出不同物理帧的最大数量 $F$ 和覆盖整个虚拟地址空间所需的 PTE 数量 $N$ 的表达式，然后使用给定参数对它们进行求值。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题牢固地建立在计算机体系结构和操作系统的基本原理之上，特别是使用分页的虚拟内存管理。所有术语和概念都是标准的并且有明确的定义。\n- **良构性**：该问题是良构的。它提供了所有必要的参数（$v$、$p_a$、$p$）来唯一确定所求的量（$F$、$N$）。简化假设（单级页表、无分段）消除了歧义，并确保存在唯一解。\n- **客观性**：问题陈述是客观的，使用了精确的技术语言，没有主观或基于观点的论断。\n- **完整性与一致性**：该问题是自洽且一致的。给定值（$v=36$、$p_a=32$、$p=2^{12}$）是合理的，并且彼此之间或与基本原理没有矛盾。虚拟地址空间大于物理地址空间的体系结构是一种常见的设计模式。\n- **其他缺陷**：该问题在科学上不是不合理的、不可形式化的、不切实际的、病态的、故作高深的，或超出科学可验证范围的。这是一个计算机组成领域的标准可解问题。\n\n**步骤 3：结论与行动**\n问题有效。将提供完整的解决方案。\n\n### 解题推导\n\n分析从物理和虚拟地址空间及其划分为帧和页面的基本定义开始。\n\n**1. 物理帧数量 ($F$) 的推导**\n\n物理地址空间是所有可能物理地址的集合。该空间的大小由物理地址宽度 $p_{a}$ 决定。\n物理内存总大小 $= 2^{p_{a}}$ 字节。\n\n该物理内存被划分为一组称为物理帧的固定大小的块。每个帧的大小被指定为等于页面大小 $p$。\n帧大小 $= p$ 字节。\n\n不同物理帧的最大数量 $F$ 是物理内存总大小除以单个帧的大小。\n$$F = \\frac{\\text{物理内存总大小}}{\\text{帧大小}}$$\n$$F = \\frac{2^{p_{a}}}{p}$$\n\n此表达式给出了硬件可以支持的物理帧的最大数量。\n\n**2. 页表条目数量 ($N$) 的推导**\n\n虚拟地址空间是程序可以生成的所有虚拟地址的集合。该空间的大小由虚拟地址宽度 $v$ 决定。\n虚拟地址空间总大小 $= 2^{v}$ 字节。\n\n该虚拟地址空间被划分为称为虚拟页面的固定大小的块。页面的大小给定为 $p$。\n页面大小 $= p$ 字节。\n\n问题陈述 MMU 必须为整个虚拟地址空间提供覆盖。在单级分页方案中，这要求每个虚拟页面都有一个页表条目 (PTE)。因此，PTE 的总数 $N$ 必须等于虚拟页面的总数。\n$$N = \\frac{\\text{虚拟地址空间总大小}}{\\text{页面大小}}$$\n$$N = \\frac{2^{v}}{p}$$\n\n**3. 特定机器参数的求值**\n\n问题提供了以下具体值：\n- 虚拟地址宽度，$v = 36$\n- 物理地址宽度，$p_{a} = 32$\n- 页面大小，$p = 2^{12}$ 字节\n\n我们将这些值代入推导出的 $F$ 和 $N$ 的表达式中。\n\n$F$ 的计算：\n$$F = \\frac{2^{p_{a}}}{p} = \\frac{2^{32}}{2^{12}}$$\n使用指数性质 $\\frac{a^m}{a^n} = a^{m-n}$：\n$$F = 2^{32 - 12} = 2^{20}$$\n为了求出整数值，我们可以利用 $2^{10} = 1024$ 这一事实：\n$$F = (2^{10})^2 = (1024)^2 = 1,048,576$$\n所以，不同物理帧的最大数量是 $1,048,576$。\n\n$N$ 的计算：\n$$N = \\frac{2^{v}}{p} = \\frac{2^{36}}{2^{12}}$$\n使用相同的指数性质：\n$$N = 2^{36 - 12} = 2^{24}$$\n为了求出整数值：\n$$N = 2^4 \\times 2^{20} = 16 \\times 1,048,576$$\n执行乘法运算：\n$$N = 16,777,216$$\n所以，覆盖整个虚拟地址空间所需的 PTE 数量是 $16,777,216$。\n\n最终答案应表示为一个行矩阵 $(F \\;\\; N)$。", "answer": "$$\\boxed{\\begin{pmatrix} 1048576  16777216 \\end{pmatrix}}$$", "id": "3657823"}, {"introduction": "虽然我们第一个练习中的单级页表是一个有用的模型，但对于拥有巨大虚拟地址空间的现代系统来说，它是不切实际的。这个实践介绍了几乎所有现代处理器都采用的解决方案：分级页表（hierarchical paging）。在这里，你将剖析一个多级页表结构以计算其总大小，从而揭示映射一个庞大虚拟地址空间所需的可观但可控的内存开销。[@problem_id:3657878]", "problem": "一个在 $64$ 位计算机上运行的进程使用内存管理单元（MMU），通过分层分页机制将虚拟地址转换为物理地址。考虑一种实现，其中虚拟地址为 $48$ 位宽，页面大小为 $4\\,\\mathrm{KiB}$。MMU 使用一个 4 级页表层次结构，其中每个页表页恰好占用一个内存页，每个页表项为 $8$ 字节。假设如下：\n- 该进程以页面为粒度映射其全部的 $48$ 位虚拟地址空间（即，每个虚拟页都有一个有效的映射）。\n- 这 4 个级别平均划分虚拟地址的非偏移位。\n- 没有大页面；只使用基本大小的页面。\n- 每个级别的每个页表页在适用时都被完全填充。\n\n从分页和分层索引的基本定义出发，确定：\n(i) 一个进程所需的叶页表项（直接将虚拟页映射到物理帧的条目）的总数，以及\n(ii) 该进程在所有级别上的所有页表结构所消耗的总内存开销（以字节为单位）（不包括进程自身数据页的内存；仅包括所有级别上页表页所使用的内存）。\n\n提供精确值（无需四舍五入）。将最终结果按 (i)、(ii) 的顺序表示为单个行矩阵中的两个数字。以字节为单位表示内存开销。", "solution": "内存管理单元（MMU）通过将虚拟地址空间划分为固定大小的页面，并使用页表将虚拟页映射到物理帧来实现虚拟内存。虚拟页的数量由虚拟地址宽度和页面大小决定。在分层页表中，虚拟地址被分为一个页偏移量和几个索引字段（每个级别一个），每个级别的每个页表包含固定数量的条目，该数量由其索引的宽度决定。\n\n我们从基本定义开始：\n- 页面大小为 $4\\,\\mathrm{KiB}$ 意味着页偏移量为 $\\log_{2}(4\\,\\mathrm{KiB}) = \\log_{2}(4096) = 12$ 位。将页偏移量宽度表示为 $b_{\\mathrm{off}}$，所以 $b_{\\mathrm{off}} = 12$。\n- 虚拟地址宽度为 $48$ 位。因此，所有级别上可用于页表索引的总位数为 $48 - b_{\\mathrm{off}} = 48 - 12 = 36$ 位。\n- 对于 4 个级别和索引位的平均划分，每个级别使用 $36/4 = 9$ 个索引位。\n\n由此，我们推导出关键的结构属性：\n- 任何级别的每个页表都包含 $2^{9} = 512$ 个条目，因为表的索引是 $9$ 位宽。\n- 不同虚拟页的数量（也就是叶映射的数量）等于非偏移位的不同值的数量，即 $2^{36}$。\n\n第 (i) 部分：所需的叶页表项总数等于虚拟页的总数，因为每个虚拟页都恰好有一个叶条目（在整个虚拟地址空间都被映射的假设下）。因此，\n$$\nN_{\\mathrm{leaf}} = 2^{48 - 12} = 2^{36}.\n$$\n\n第 (ii) 部分：总内存开销由所有四个级别的页表页占用的内存总和构成。每个页表页的大小恰好为一个内存页，即 $4\\,\\mathrm{KiB}$，并且被完全填充。\n\n让我们计算每个级别的页表页数量。\n\n- 叶级别（第 $4$ 级，即页表本身）：每个叶页表页包含 $512$ 个叶条目，因此覆盖 $512$ 个虚拟页。由于有 $N_{\\mathrm{leaf}} = 2^{36}$ 个虚拟页，叶页表页的数量是\n$$\nN_{L4} = \\frac{2^{36}}{2^{9}} = 2^{27}.\n$$\n\n- 上一个级别（第 $3$ 级，通常称为页目录）：每个条目指向一个第 $4$ 级的页表页，而每个第 $3$ 级的页表页包含 $512$ 个这样的条目。因此\n$$\nN_{L3} = \\frac{N_{L4}}{2^{9}} = \\frac{2^{27}}{2^{9}} = 2^{18}.\n$$\n\n- 第 $2$ 级（通常称为页目录指针表）：同样地，\n$$\nN_{L2} = \\frac{N_{L3}}{2^{9}} = \\frac{2^{18}}{2^{9}} = 2^{9}.\n$$\n\n- 第 $1$ 级（顶级，通常称为 4 级页映射表）：最后，\n$$\nN_{L1} = \\frac{N_{L2}}{2^{9}} = \\frac{2^{9}}{2^{9}} = 1.\n$$\n\n每个页表页占用 $4\\,\\mathrm{KiB} = 2^{12}$ 字节。因此，总内存开销 $M$（不包括数据页）是\n$$\nM = 2^{12}\\left(N_{L4} + N_{L3} + N_{L2} + N_{L1}\\right)\n= 2^{12}\\left(2^{27} + 2^{18} + 2^{9} + 1\\right)\n= 2^{39} + 2^{30} + 2^{21} + 2^{12}\\ \\text{bytes}.\n$$\n\n这些是精确的整数。为了完整起见，我们对它们进行数值计算：\n- $2^{36} = 68{,}719{,}476{,}736$。\n- $2^{39} = 549{,}755{,}813{,}888$,\n- $2^{30} = 1{,}073{,}741{,}824$,\n- $2^{21} = 2{,}097{,}152$,\n- $2^{12} = 4{,}096$。\n\n对 $M$ 求和：\n$$\nM = 549{,}755{,}813{,}888 + 1{,}073{,}741{,}824 + 2{,}097{,}152 + 4{,}096 = 550{,}831{,}656{,}960\\ \\text{bytes}.\n$$\n\n因此，最终结果是：\n- (i) $N_{\\mathrm{leaf}} = 2^{36} = 68{,}719{,}476{,}736$,\n- (ii) $M = 550{,}831{,}656{,}960$ 字节。", "answer": "$$\\boxed{\\begin{pmatrix} 68719476736  550831656960 \\end{pmatrix}}$$", "id": "3657878"}, {"introduction": "除了页表的静态结构，MMU 的真正复杂性在于其在内存访问过程中的动态行为。这个练习提出了一个关键的边界情况：跨越页面边界的未对齐内存访问。通过对这一场景的推理，你将探索 MMU 如何处理跨越多个页面的访问，以及当其中一个页面未被映射时会发生什么——这将导致一个至关重要的页错误（page fault）异常。这个思想实验阐明了 MMU 在确保精确和可恢复指令执行中的作用。[@problem_id:3657891]", "problem": "一个进程在一台采用基于页的虚拟内存和字节寻址架构的机器上执行。内存管理单元 (MMU) 使用页表将每个虚拟页转换为物理页，该页表可能被缓存在转译后备缓冲区 (TLB) 中。页面大小为 $P = 4096$ 字节。考虑一条指令，它从虚拟地址 $v = 0x0000000000000\\mathrm{FFB}$ 开始执行一次 $w = 8$ 字节的加载操作。\n\n假设如下：\n- 包含起始地址的第一个页面是有效且已映射的。\n- 紧随其后的页面未被映射（没有有效的页表项），因此任何对它的访问都会触发一个异常。\n\n从基本原理出发，推断 MMU 必须执行多少次页面翻译才能完成这次加载，以及在第二个页面未映射的情况下会产生何种异常行为。选择最能描述这次 $w$ 字节访问所需的翻译次数和由此产生的故障语义的选项。\n\nA. MMU 执行 $1$ 次翻译，因为该指令是单个内存操作；不会发生故障，因为缓存会透明地跨页边界检索数据。\n\nB. MMU 执行 $2$ 次翻译，因为访问的字节范围跨越了两个页面；在翻译第二个页面时，MMU 检测到它未被映射并引发一个页故障异常，指令中止，并且没有部分数据或副作用在架构上可见。\n\nC. MMU 执行 $2$ 次翻译；前 $4$ 个字节从已映射的页面返回，然后由于第二个页面未映射而引发一个通用保护故障，并且架构状态反映了加载的部分结果。\n\nD. MMU 执行 $w = 8$ 次独立的翻译，每个访问的字节一次；异常被推迟到所有字节翻译都尝试完毕后，从而保证在发生故障前，来自已映射页面的部分数据变得可见。", "solution": "我们将通过把问题陈述分解为其基本组成部分，并验证其科学和逻辑上的一致性来确认问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n- **系统架构**：基于页的虚拟内存，字节寻址。\n- **翻译单元**：内存管理单元 (MMU) 处理虚拟到物理地址的翻译。\n- **页面大小**：$P = 4096$ 字节。\n- **指令**：单个加载操作。\n- **访问大小**：$w = 8$ 字节。\n- **起始虚拟地址**：$v = 0x0000000000000\\mathrm{FFB}$。\n- **条件 1**：包含起始地址 $v$ 的虚拟页是有效且已映射的。\n- **条件 2**：紧随第一个虚拟页之后的页面未被映射。任何对它的访问都会触发一个异常。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题描述了一个跨越页面边界的内存访问，这是计算机体系结构中的一个经典场景。\n\n- **科学基础**：虚拟内存、页表、MMU、页故障和字节寻址等概念都是计算机组成与体系结构中的基本和标准概念。$4096$ 字节（$4$ KiB）的页面大小非常普遍。$8$ 字节的加载对于 $64$ 位架构是典型的（例如，加载一个 `double` 或 `long long`）。这个场景在科学和技术上是合理的。\n- **问题的适定性**：该问题提供了确定结果所需的所有必要信息。起始地址、访问大小和页面大小允许精确计算所涉及的虚拟地址。相关页面（已映射 vs. 未映射）的状态已明确说明。问题具体且可回答。\n- **客观性**：问题以精确、客观的技术语言陈述，没有歧义或主观陈述。\n\n问题陈述是有效的。这是一个适定的、计算机体系结构中的标准问题。我们可以继续进行解答。\n\n### 解答推导\n解决方案是从虚拟内存管理的基本原理推导出来的。\n\n1.  **确定内存访问的虚拟地址范围。**\n    加载操作是针对 $w=8$ 字节，从虚拟地址 $v = 0x0000000000000\\mathrm{FFB}$ 开始。访问跨越的字节地址从 $v$ 到 $v + w - 1$。\n    - 起始地址：$0x...0\\mathrm{FFB}$\n    - 结束地址：$0x...0\\mathrm{FFB} + 8 - 1 = 0x...0\\mathrm{FFB} + 7 = 0x...0\\mathrm{FFE} + 4 = 0x...0\\mathrm{FFF} + 3 = 0x...1002$。\n    加载操作的完整虚拟地址范围是 $[0x0000000000000\\mathrm{FFB}, 0x0000000000001002]$。\n\n2.  **识别此地址范围所跨越的虚拟页。**\n    页面大小为 $P = 4096$ 字节，即 $2^{12}$ 字节或十六进制的 $0x1000$ 字节。一个虚拟地址被划分为一个虚拟页号 (VPN) 和一个页内偏移。偏移量由地址的低 $12$ 位组成。\n    - 页面边界出现在 $0x1000$ 的倍数处。前几个页面是：\n        - 页面 0：地址范围 $[0x...0000, 0x...0\\mathrm{FFF}]$。\n        - 页面 1：地址范围 $[0x...1000, 0x...1\\mathrm{FFF}]$。\n        - 依此类推。\n    - 访问的起始地址 $0x...0\\mathrm{FFB}$ 属于页面 0。其 VPN 可视为 $0$，其偏移量为 $0\\mathrm{FFB}$。\n    - 访问的结束地址 $0x...1002$ 属于页面 1。其 VPN 为 $1$，其偏移量为 $0x002$。\n    - 由于访问从页面 0 开始，在页面 1 结束，因此单个 $8$ 字节的加载操作跨越了两个不同的虚拟页。\n\n3.  **分析 MMU 的翻译需求。**\n    MMU 将虚拟页号 (VPN) 转换为物理帧号 (PFN)。由于内存访问触及了两个不同的虚拟页，MMU 必须为这两个页面各执行一次翻译，以构建加载操作所需的完整物理地址范围。\n    - **翻译 1**：MMU 必须为访问的第一部分（从地址 $0x...0\\mathrm{FFB}$ 到 $0x...0\\mathrm{FFF}$ 的字节）翻译 VPN。这对应于页面 0。问题陈述中提到“包含起始地址的第一个页面是有效且已映射的。”因此，这次翻译会成功。\n    - **翻译 2**：MMU 还必须为访问的第二部分（从地址 $0x...1000$ 到 $0x...1002$ 的字节）翻译 VPN。这对应于页面 1。问题陈述中提到“紧随其后的页面未被映射。”当 MMU 试图查找页面 1 的页表项时，它会发现该项是无效的（或不存在）。此事件会触发一个硬件异常。\n\n4.  **分析异常语义（指令的原子性）。**\n    访问未映射页面所触发的异常是**页故障 (page fault)**。现代处理器设计有精确异常语义。这意味着当一条指令发生故障时，处理器状态会恢复到故障指令开始执行前那一刻的状态。任何架构状态（例如加载操作的目标寄存器的内容）都不会被修改。\n    - 这种“全有或全无”的行为至关重要。它允许操作系统的页故障处理程序解决该故障（例如，通过将所需的页面从磁盘加载到内存中），然后重新启动故障指令，就好像它从未被尝试过一样。\n    - 在本场景中，MMU 翻译第二个页面地址（$0x...1000$）的尝试将会失败。一个页故障会立即被引发。CPU 不会继续加载任何数据。它会丢弃为该指令所做的任何部分的、推测性的工作，确保没有寄存器被更新，并将控制权转移给操作系统。程序计数器将被设置为故障加载指令的地址。\n    - 因此，MMU 尝试进行 $2$ 次翻译。第二次翻译失败，引发一个页故障。指令被中止，没有任何部分结果在架构上可见。\n\n### 逐项分析\n\n- **A. MMU 执行 $1$ 次翻译，因为该指令是单个内存操作；不会发生故障，因为缓存会透明地跨页边界检索数据。**\n  - MMU 只执行 $1$ 次翻译的前提是错误的。所需的翻译次数由访问的不同页面数量决定，即 $2$ 次。\n  - 缓存会透明地绕过页面映射故障的说法从根本上是错误的。缓存与包括 MMU 在内的内存层次结构协同工作。未映射的页面是一个错误条件，缓存不能也不可能覆盖它。\n  - **结论**：错误。\n\n- **B. MMU 执行 $2$ 次翻译，因为访问的字节范围跨越了两个页面；在翻译第二个页面时，MMU 检测到它未被映射并引发一个页故障异常，指令中止，并且没有部分数据或副作用在架构上可见。**\n  - 该陈述正确地指出访问跨越两个页面，因此需要 $2$ 次翻译。\n  - 它正确地描述了访问未映射的第二个页面的后果：一个页故障异常。\n  - 它正确地描述了现代 CPU 的精确异常模型：指令被中止，没有部分结果或副作用成为架构状态的一部分。这与我们从基本原理出发的推导完全一致。\n  - **结论**：正确。\n\n- **C. MMU 执行 $2$ 次翻译；前 $4$ 个字节从已映射的页面返回，然后由于第二个页面未映射而引发一个通用保护故障，并且架构状态反映了加载的部分结果。**\n  - 翻译次数（$2$ 次）是正确的。\n  - 对于一个不存在的页面，故障类型通常是*页故障*，而不是*通用保护故障*（后者通常与对存在页面的访问权限有关）。\n  - 声称部分结果在架构上可见是错误的，因为它违反了精确、可重启异常的原则。\n  - **结论**：错误。\n\n- **D. MMU 执行 $w = 8$ 次独立的翻译，每个访问的字节一次；异常被推迟到所有字节翻译都尝试完毕后，从而保证在发生故障前，来自已映射页面的部分数据变得可见。**\n  - MMU 为每个字节执行一次翻译的前提是错误的。翻译是以页为粒度进行的。这将需要 $2$ 次翻译，而不是 $8$ 次。\n  - 故障不会被推迟。它在检测到无效访问时立即被引发。\n  - 声称部分数据变得可见是错误的，原因如前所述。\n  - **结论**：错误。", "answer": "$$\\boxed{B}$$", "id": "3657891"}]}