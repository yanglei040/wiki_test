{"hands_on_practices": [{"introduction": "浮点运算中最经典的“意外”之一，莫过于在大多数编程语言中 `0.1 + 0.2` 并不精确等于 `0.3`。这个练习将带你从根本上剖析这一现象。通过从第一性原理出发，推导十进制数 $0.1$ 在二进制（`binary32`）和十进制（`decimal32`）浮点格式中的精确表示，你将亲身体会到表示误差的来源。这个练习 [@problem_id:3642002] 旨在让你掌握浮点数表示的核心机制，并理解为何对于需要精确处理十进制小数的金融等应用，硬件级别的十进制浮点支持至关重要。", "problem": "一个计算系统实现了电气和电子工程师协会（IEEE）754浮点算术标准，支持二进制单精度（$\\text{binary32}$）和十进制单精度（$\\text{decimal32}$）。该系统使用“向最近舍入，偶数优先”的舍入模式，并且每个基本运算都正确舍入到目标格式。对于规格化数，$\\text{binary32}$ 格式将一个实数值编码为 $(-1)^{s} \\cdot (1.f) \\cdot 2^{E - 127}$，其中 $s$ 是符号位，$E$ 是带有偏置值 $127$ 的 $8$ 位指数场，$f$ 是 $23$ 位的小数部分。$\\text{decimal32}$ 格式将一个实数值编码为 $(-1)^{s} \\cdot c \\cdot 10^{q}$，其中 $c$ 是一个最多有 $7$ 位十进制数字的以10为底的系数，$q$ 是一个以10为底的指数，并且它能够精确表示像 $0.1$ 这样的十进制小数。\n\n从这些定义出发，并且不假设任何预先计算的常数，执行以下操作：\n\n1. 在“向最近舍入，偶数优先”的模式下，推导在 $\\text{binary32}$ 格式中编码 $0.1_{10}$ 时产生的精确实数值。具体来说，确定其规格化指数和最接近的可表示规格化有效数，并将得到的 $\\text{binary32}$ 值表示为一个精确的有理数。\n\n2. 在相同的舍入模式下，推导在 $\\text{decimal32}$ 格式中编码 $0.1_{10}$ 时产生的精确实数值，并将其表示为一个精确的有理数。\n\n3. 在每种格式中，计算顺序求和 $0.1 + 0.1 + 0.1$ 的结果，其中每次加法都在该格式下执行，并在操作后进行正确舍入。将每个最终和表示为一个精确的有理数。\n\n4. 计算在第 $3$ 部分中得到的两个最终和之间的绝对差。\n\n将您的最终数值答案四舍五入到四位有效数字。不需要单位。", "solution": "该问题要求对两种不同的IEEE 754格式，即 $\\text{binary32}$ 和 $\\text{decimal32}$ 中的浮点运算进行详细分析，重点是值 $0.1$ 的表示和求和。分析将按规定分四个部分进行。\n\n**第1部分：推导 $0.1_{10}$ 的 $\\text{binary32}$ 表示**\n\n需要表示的数是 $0.1_{10}$，即有理数 $\\frac{1}{10}$。规格化数的 $\\text{binary32}$ 格式为 $(-1)^s \\cdot (1.f) \\cdot 2^{E-127}$。首先，我们必须确定指数。我们寻找一个整数指数 $e$ 使得 $1 \\le \\frac{1}{10} \\times 2^{-e}  2$。因为 $2^3 = 8$ 且 $2^4 = 16$，所以有 $2^3  10  2^4$。取倒数得到 $2^{-4}  \\frac{1}{10}  2^{-3}$。为了规格化 $\\frac{1}{10}$，我们将其写成 $M \\times 2^{-4}$ 的形式，其中 $M = \\frac{1}{10} \\times 2^4 = \\frac{16}{10} = 1.6$。因此，真实指数为 $e = -4$。带有偏置的指数为 $E = e + 127 = -4 + 127 = 123$。\n\n需要编码的有效数是 $1.6_{10}$。$\\text{binary32}$ 格式有 $1$ 个隐含位和 $23$ 个显式小数位，总精度为 $24$ 位。为了确定有效数的 $24$ 位表示，我们将值 $1.6$ 乘以 $2^{23}$ 并将结果舍入到最近的整数。\n缩放后的有效数为 $1.6 \\times 2^{23} = \\frac{16}{10} \\times 2^{23} = \\frac{8}{5} \\times 2^{23} = \\frac{2^3 \\times 2^{23}}{5} = \\frac{2^{26}}{5} = \\frac{67108864}{5} = 13421772.8$。\n\n舍入模式是“向最近舍入，偶数优先”。值 $13421772.8$ 不是一个中间值（即不是在两个整数的正中间）。它更接近 $13421773$ 而不是 $13421772$。因此，我们向上舍入到 $13421773$。\n这个整数 $13421773$ 代表了有效数的 $24$ 位。因此，有效数的值是这个整数除以 $2^{23}$。\n$M_{\\text{b32}} = \\frac{13421773}{2^{23}}$。\n\n在 $\\text{binary32}$ 格式中表示的最终值，我们记作 $x_{\\text{b32}}$，是该有效数与指数部分的乘积：\n$x_{\\text{b32}} = M_{\\text{b32}} \\times 2^{-4} = \\frac{13421773}{2^{23}} \\times 2^{-4} = \\frac{13421773}{2^{27}}$。\n作为一个有理数，$0.1$ 的 $\\text{binary32}$ 表示为 $\\frac{13421773}{134217728}$。\n\n**第2部分：推导 $0.1_{10}$ 的 $\\text{decimal32}$ 表示**\n\n$\\text{decimal32}$ 格式将一个数表示为 $(-1)^s \\cdot c \\cdot 10^q$，其中 $c$ 是一个最多有 $7$ 位数字的以10为底的系数。值 $0.1_{10}$ 可以表示为 $1 \\times 10^{-1}$。这完全符合该格式。我们可以设置符号 $s=0$，系数 $c=1$，指数 $q=-1$。由于系数 $c=1$ 只需要一个数字，它远在 $7$ 位数字的限制之内。因此，$\\text{decimal32}$ 格式可以精确表示 $0.1$。该值，我们记作 $x_{\\text{d32}}$，就是精确的 $0.1$，或有理数 $\\frac{1}{10}$。\n\n**第3部分：计算顺序求和 $0.1 + 0.1 + 0.1$**\n\n我们在每种格式中计算这个和，每次加法后都进行舍入。\n\n对于 **$\\text{decimal32}$ 格式**：\n初始值为 $x_{\\text{d32}} = \\frac{1}{10}$。\n第一次加法：$S_1 = x_{\\text{d32}} + x_{\\text{d32}} = \\frac{1}{10} + \\frac{1}{10} = \\frac{2}{10} = 0.2$。这个值可以在 $\\text{decimal32}$ 格式中精确表示（$c=2, q=-1$）。不需要舍入。\n第二次加法：$S_2 = S_1 + x_{\\text{d32}} = \\frac{2}{10} + \\frac{1}{10} = \\frac{3}{10} = 0.3$。这个值也可以在 $\\text{decimal32}$ 格式中精确表示（$c=3, q=-1$）。不需要舍入。\n在 $\\text{decimal32}$ 格式中的最终和为 $S_{\\text{d32}} = \\frac{3}{10}$。\n\n对于 **$\\text{binary32}$ 格式**：\n初始值为 $x_{\\text{b32}} = \\frac{13421773}{2^{27}}$。\n第一次加法：$S'_1 = x_{\\text{b32}} + x_{\\text{b32}} = 2 \\times \\frac{13421773}{2^{27}} = \\frac{13421773}{2^{26}}$。\n此操作对应于将 $x_{\\text{b32}}$ 的指数增加 $1$ 而有效数保持不变。结果 $\\frac{13421773}{2^{26}}$ 是一个有效的 $\\text{binary32}$ 数，因此它被精确存储而无需舍入。\n\n第二次加法：$S'_2 = S'_1 + x_{\\text{b32}} = \\frac{13421773}{2^{26}} + \\frac{13421773}{2^{27}}$。\n为了执行此加法，我们通分：\n$S'_2 = \\frac{2 \\cdot 13421773}{2^{27}} + \\frac{13421773}{2^{27}} = \\frac{3 \\cdot 13421773}{2^{27}} = \\frac{40265319}{134217728}$。\n这是该和的精确数学结果。现在，必须将其舍入到 $\\text{binary32}$ 格式。该值约为 $0.3$。真实指数 $e$ 将为 $-2$，因为 $2^{-2} = 0.25$ 且 $2^{-1} = 0.5$。规格化形式为 $M' \\times 2^{-2}$。\n有效数是 $M' = S'_2 \\times 2^2 = \\frac{40265319}{134217728} \\times 4 = \\frac{40265319}{33554432}$。\n为了将其舍入到 $24$ 位精度，我们将其乘以 $2^{23}$：\n缩放后的有效数整数 $= M' \\times 2^{23} = \\frac{40265319}{33554432} \\times 2^{23} = \\frac{40265319}{2^{25}} \\times 2^{23} = \\frac{40265319}{2^2} = \\frac{40265319}{4} = 10066329.75$。\n这个结果恰好位于整数 $10066329$ 和 $10066330$ 的正中间，构成了一个中间值。“偶数优先”规则要求舍入到偶数。整数部分 $10066329$ 是奇数。因此，我们必须向上舍入到最近的偶数，即 $10066330$。\n舍入后的 $24$ 位有效数对应于整数 $10066330$。其值为 $M'_{\\text{b32}} = \\frac{10066330}{2^{23}}$。\n在 $\\text{binary32}$ 格式中的最终和 $S_{\\text{b32}}$ 为：\n$S_{\\text{b32}} = M'_{\\text{b32}} \\times 2^{-2} = \\frac{10066330}{2^{23}} \\times 2^{-2} = \\frac{10066330}{2^{25}} = \\frac{5033165}{16777216}$。\n\n**第4部分：计算绝对差**\n\n最终的和是 $S_{\\text{d32}} = \\frac{3}{10}$ 和 $S_{\\text{b32}} = \\frac{5033165}{16777216}$。绝对差 $\\Delta$ 是：\n$\\Delta = |S_{\\text{d32}} - S_{\\text{b32}}| = |\\frac{3}{10} - \\frac{5033165}{16777216}|$。\n我们将各项通分：\n$\\Delta = |\\frac{3 \\cdot 16777216 - 10 \\cdot 5033165}{10 \\cdot 16777216}| = |\\frac{50331648 - 50331650}{167772160}|$。\n$\\Delta = |\\frac{-2}{167772160}| = \\frac{2}{167772160} = \\frac{1}{83886080}$。\n这是差值的精确有理数值。\n\n为了提供最终答案，我们必须将此值表示为小数形式并四舍五入到四位有效数字。\n$\\Delta = \\frac{1}{83886080} = 0.000000011920928955078125$。\n用科学记数法表示，这是 $1.19209289... \\times 10^{-8}$。\n四舍五入到四位有效数字得到 $1.192 \\times 10^{-8}$。", "answer": "$$\n\\boxed{1.192 \\times 10^{-8}}\n$$", "id": "3642002"}, {"introduction": "除了表示误差，浮点算术本身也充满了“陷阱”。一个常见的例子是，代数中不证自明的恒等式 $(a+b)-a=b$ 在计算机中可能不成立。本练习 [@problem_id:3641990] 深入探讨了这一问题，即当一个大数与一个小数相加时发生的“大数吃小数”现象（也称作“淹没”或“吸收”）。你将通过分析浮点加法中的指数对齐步骤，推导出该恒等式失效的条件，并用一个具体的例子验证你的结论。掌握这一概念对于编写任何需要高精度或处理不同尺度数据的数值代码都至关重要。", "problem": "一位软件工程师遵循电气与电子工程师协会（IEEE）浮点数算术标准（IEEE 754）的 binary32（单精度）格式编写了一个数值核心程序，使用的舍入模式为“向最近舍入，偶数优先 (round to nearest, ties to even)”。令 $\\operatorname{fl}(\\cdot)$ 表示在此格式下一次运算的浮点结果。考虑计算量\n$$\ny \\;=\\; \\operatorname{fl}\\!\\left(\\,\\operatorname{fl}(a + b)\\;-\\;a\\,\\right),\n$$\n这反映了一种计算残差的朴素代码模式。该工程师注意到，在实数算术中 $((a+b)-a)=b$，但在浮点算术中这个恒等式可能不成立。\n\n在以下模型中进行分析：\n- 一个规格化的 binary32 数的形式为 $x = (-1)^{s}\\,(1.f)_2\\,2^{E-127}$，其中 $s \\in \\{0,1\\}$，$f$ 是一个 23 位的小数部分，$E \\in \\{1,2,\\dots,254\\}$ 是偏置指数。精度为 $p=24$ 个有效位（包括隐含的前导 $1$）。\n- 对于一个无偏指数为 $e$ 的规格化量值 $x$，“末位单位 (Unit in the Last Place, ULP)” 为 $\\operatorname{ulp}(x)=2^{e-(p-1)}$。\n- 对于 $\\circ \\in \\{+,-,\\times,\\div\\}$，一次正确的舍入操作 $\\operatorname{fl}(x \\circ y)$ 返回与精确结果最接近的唯一浮点数，当距离相等时，向偶数有效数（significand）方向舍入。\n\n任务：\n1. 从这些定义出发，用 $a$、$b$ 以及单次加法的舍入误差推导出 $y$ 的表达式。仅使用上述定义和浮点加法中指数对齐的基本性质。得出一个在此模型下使得 $y=b$ 的充要条件，并用 $a+b$ 在 binary32 格式下能否精确表示来表述该条件。\n2. 将你的结论具体化到以下情况：$a$ 是一个规格化数，$b$ 与 $a$ 符号相同且满足 $|b| \\ll |a|$。使用 $\\operatorname{ulp}(a)$ 来表达你的条件，并从浮点加法器的指数对齐步骤的角度解释其含义。\n3. 现在取 $a=10^8$ 和 $b=1$，将它们解释为一次 binary32 计算的实数输入，并精确计算 $y=\\operatorname{fl}(\\operatorname{fl}(a+b)-a)$ 的 binary32 值。你的最终答案必须是一个实数。最终答案无需舍入。", "solution": "我们从 IEEE 754 binary32（单精度）的核心定义和正确舍入算术的语义开始。一个规格化的浮点数形式为 $x = (-1)^{s}\\,(1.f)_2\\,2^{E-127}$，具有 $p=24$ 个有效位。在无偏指数为 $e$ 的规格化数 $x$ 附近，其“末位单位 (ULP)”为 $\\operatorname{ulp}(x)=2^{e-(p-1)}=2^{e-23}$，这是由 $e$ 定义的指数区间（binade）中连续浮点数之间的间距。\n\n步骤 1：通过一次加法和减法的舍入误差来表示 $y$。\n\n我们用 $s = a+b$ 表示精确的实数和。根据“向最近舍入，偶数优先”的正确舍入规则，存在一个舍入误差 $\\delta$ 使得\n$$\n\\operatorname{fl}(a+b) \\;=\\; s + \\delta \\;=\\; a + b + \\delta,\n$$\n并满足约束条件 $|\\delta| \\le \\tfrac{1}{2}\\,\\operatorname{ulp}(s)$。对于 $|b|\\ll |a|$ 且 $a$ 是规格化数的情况，$s$ 的指数区间通常与 $a$ 的一致（指数不会溢出到下一个指数区间），因此 $|\\delta| \\le \\tfrac{1}{2}\\,\\operatorname{ulp}(a)$。\n\n计算得到的量为\n$$\ny \\;=\\; \\operatorname{fl}\\!\\left(\\operatorname{fl}(a+b) - a\\right) \\;=\\; \\operatorname{fl}\\!\\left((a+b+\\delta)-a\\right) \\;=\\; \\operatorname{fl}\\!\\left(b+\\delta\\right).\n$$\n现在，我们使用一个关于浮点数减法精确性的著名性质：当两个浮点数之比在 2 的因子范围内时，减法是精确的。具体来说，根据 Sterbenz 引理（一个可以从指数对齐和规格化推导出的标准结果），如果 $x$ 和 $y$ 是浮点数且 $\\tfrac{1}{2}\\le \\tfrac{x}{y}\\le 2$，那么 $x-y$ 可以在相同格式下被精确表示。在我们的情况下，$\\operatorname{fl}(a+b)$ 和 $a$ 都是浮点数，当 $|b| \\ll |a|$ 时，它们的比值在 2 的因子范围内，所以减法 $\\operatorname{fl}(a+b)-a$ 是精确的。因此，\n$$\ny \\;=\\; \\left(\\operatorname{fl}(a+b)\\right)-a \\;=\\; (a+b+\\delta)-a \\;=\\; b+\\delta.\n$$\n由此可知，$y=b$ 当且仅当 $\\delta=0$，也就是说，当且仅当 $\\operatorname{fl}(a+b)=a+b$（即和在 binary32 格式中可以被精确表示，无舍入）。这就建立了充要条件：\n$$\ny=b \\quad\\Longleftrightarrow\\quad a+b \\text{ 在 binary32 格式下可以被精确表示}。\n$$\n\n步骤 2：使用 $\\operatorname{ulp}(a)$ 和指数对齐进行具体化分析。\n\n在二进制加法器中，为计算 $a+b$，需要对齐有效数，方法是把具有较小无偏指数的操作数的有效数右移 $d$ 位，其中 $d$ 是指数差。如果 $|b|\\ll |a|$ 且 $a$ 和 $b$ 符号相同，那么对齐后，$b$ 对和的贡献在 $a$ 的尺度上被有效地量化在 $\\operatorname{ulp}(a)$ 的网格上。具体地，当加法后 $a$ 保持在相同的指数区间内时，我们有\n$$\n\\operatorname{ulp}(a)=2^{e-23}, \\quad \\text{其中 } e=\\lfloor \\log_{2}|a| \\rfloor,\n$$\n并且和 $a+b$ 能被精确表示，当且仅当 $b$ 是 $\\operatorname{ulp}(a)$ 的整数倍，并且加法不会导致指数重新规格化为 $e+1$。等价地，舍入误差 $\\delta$ 为零，当且仅当 $b \\in \\operatorname{ulp}(a)\\,\\mathbb{Z}$ 且 $a+b$ 保持在无偏指数为 $e$ 的指数区间内。直观地，这表明等式 $y=b$ 精确成立的条件是 $b$ 被“缩放”到由 $a$ 附近可表示数之间的间距定义的局部网格上；如果 $b$ 不在该网格上，对齐和舍入会强制产生一个非零的 $\\delta$ 从而 $y\\ne b$。\n\n步骤 3：对 $a=10^8$ 和 $b=1$ 进行计算。\n\n我们现在为 $a=10^8$ 和 $b=1$ 计算 $y=\\operatorname{fl}(\\operatorname{fl}(a+b)-a)$ 在 binary32 中的值。\n\n首先，确定 $a$ 的无偏指数 $e$：\n$$\n2^{26} \\;=\\; 67{,}108{,}864 \\;\\; 10^{8} \\;\\; 134{,}217{,}728 \\;=\\; 2^{27},\n$$\n所以 $e=\\lfloor \\log_{2}(10^{8}) \\rfloor = 26$。因此，$a$ 处的局部间距是\n$$\n\\operatorname{ulp}(a) \\;=\\; 2^{e-23} \\;=\\; 2^{3} \\;=\\; 8.\n$$\n因为 $|b|=1  \\tfrac{1}{2}\\operatorname{ulp}(a)=4$，所以正确舍入后的和满足\n$$\n\\operatorname{fl}(a+b) \\;=\\; a \\quad\\text{(向最近舍入，偶数优先)}.\n$$\n因此，加法上的舍入误差是 $\\delta = -b = -1$，并且减法是精确的（如上所述），得到\n$$\ny \\;=\\; \\operatorname{fl}\\!\\left(\\operatorname{fl}(a+b)-a\\right) \\;=\\; (a+b+\\delta)-a \\;=\\; (a+1-1)-a \\;=\\; 0.\n$$\n因此，在 binary32 中计算出的值 $y$ 精确地为 $0$。这展示了一个反例，在该例中 $((a+b)-a)$ 不等于 $b$，除非 $b$ 被缩放到 $\\operatorname{ulp}(a)$ 的网格上（这里 $\\operatorname{ulp}(a)=8$，而 $b=1$ 不是 $8$ 的整数倍）。", "answer": "$$\\boxed{0}$$", "id": "3641990"}, {"introduction": "理论概念最终要应用于解决实际问题。本练习 [@problem_id:3642006] 将我们之前学到的关于“淹没”的知识应用到一个常见的计算任务中：求直角三角形的斜边长 $h = \\sqrt{x^2+y^2}$。当两条边的长度相差悬殊时，朴素的计算方法会因精度损失而失败。这个练习要求你分析一个朴素算法和一个经过优化的“补偿”算法，并揭示即使是看似更稳健的方法，在极端输入下也可能因浮点数的内在限制而失效。通过这个例子，你将更深刻地理解数值算法设计中稳定性的重要性。", "problem": "一个系统实现了电气和电子工程师协会 (IEEE) $754$ binary$32$ 浮点格式，采用“舍入到最近，偶数优先”的舍入规则，并对以下每项算术运算（乘法、加法、除法和平方根）后都进行舍入。binary$32$ 格式有 $1$ 个符号位、$8$ 个指数位（偏置值为 $127$）和 $23$ 个尾数位；有效数精度为 $p=24$ 位。考虑使用两种算法计算 $x=10^{8}$ 和 $y=1$ 时的斜边 $h=\\sqrt{x^{2}+y^{2}}$：\n\n(i) 朴素平方算法：计算 $x^{2}$，然后计算 $x^{2}+y^{2}$，再计算 $\\sqrt{x^{2}+y^{2}}$，每步运算都舍入到 binary$32$ 格式。\n\n(ii) 补偿缩放方法：令 $r=\\max(|x|,|y|)$ 和 $s=\\min(|x|,|y|)$，然后计算 $r\\cdot\\sqrt{1+(s/r)^{2}}$，每步运算都舍入到 binary$32$ 格式。\n\n仅根据上述 IEEE $754$ binary$32$ 的结构特性和舍入规则，分析每一步的舍入，确定每种算法返回的最终 binary$32$ 结果，并将其与精确实数值 $h=\\sqrt{10^{16}+1}$ 进行比较。根据此分析，确定计算出的斜边（在本例中两种方法结果相同）相对于精确实数值的相对误差，其定义为 $\\displaystyle \\frac{|h_{\\mathrm{comp}}-h|}{h}$，其中 $h_{\\mathrm{comp}}$ 是任一方法返回的浮点结果。将你的最终答案表示为单个实数，并四舍五入到四位有效数字。", "solution": "用户要求分析使用 IEEE $754$ binary$32$ 浮点算术计算 $x=10^{8}$ 和 $y=1$ 时的斜边 $h=\\sqrt{x^{2}+y^{2}}$ 的两种算法。分析必须确定每种算法的计算结果以及与精确值相比的相对误差。\n\nIEEE $754$ binary$32$ 格式使用 $1$ 个符号位、$8$ 个指数位（偏置值为 $127$）和 $23$ 个显式尾数位。有效数精度为 $p=24$ 位（1 个隐含位 + 23 个尾数位）。舍入模式为“舍入到最近，偶数优先”。\n\n首先，我们将输入 $x=10^{8}$ 和 $y=1$ 表示为 binary$32$ 格式。\n数字 $y=1$ 精确地等于 $1.0 \\times 2^{0}$。这是可以精确表示的。$\\hat{y} = 1$。\n数字 $x=10^{8}$ 需要进行转换。\n$x = 100,000,000$。其指数为 $E = \\lfloor \\log_2(10^8) \\rfloor = 26$。\n为了表示 $10^8$，我们对其进行规格化：$10^8 = m \\times 2^{26}$，其中 $m = 10^8 / 2^{26}$。\n$10^8 = (101111101011110000100000000)_2$。\n表示为整数需要 $27$ 位。为了规格化，我们将其写为：$x = 1.01111101011110000100000000_2 \\times 2^{26}$。\n有效数有 $1$ 个整数位和 $26$ 个小数位。有效数精度 $p=24$ 不足以精确存储此值。然而，我们观察到最后一个有效位在第 $18$ 个小数位上。\n$x = 1.011111010111100001_2 \\times 2^{26}$。\n这个有效数的长度是 $19$ 位。由于 $19  24$，因此 $x=10^8$ 在 binary$32$ 格式中可以精确表示。存储的值为 $\\hat{x} = 10^8$。其有效数为 $1.01111101011110000100000_2$，存储的指数为 $26+127 = 153$。\n\n令 $fl(\\cdot)$ 表示带舍入的浮点运算。\n\n### 算法 (i)：朴素平方算法 $h_{\\mathrm{comp1}} = fl(\\sqrt{fl(fl(\\hat{x}^2) + fl(\\hat{y}^2))})$\n\n1.  **计算 $fl(\\hat{x}^2)$**：\n    我们计算 $\\hat{x}^2 = (10^8)^2 = 10^{16}$。这个精确值必须舍入到 binary$32$ 格式。\n    $10^{16}$ 的指数为 $E = \\lfloor \\log_2(10^{16}) \\rfloor = 53$。\n    精确的有效数为 $m = 10^{16} / 2^{53} \\approx 1.109335529$。\n    用二进制表示，$m \\approx 1.00011011101101100100111101..._2$。\n    为了以 $p=24$ 位的精度存储这个数，我们必须进行舍入。前 $24$ 位是 $1.00011011101101100100111_2$。下一位（保护位）是 $1$。保护位之后的位不全为零。因此，我们向上舍入。\n    尾数的最后一位是 $1$。向上舍入意味着在第 $23$ 个小数位上加 $1$。\n    截断的有效数：$1.00011011101101100100111_2$。\n    加上 $2^{-23}$：$1.00011011101101100100111_2 + 0.00000000000000000000001_2 = 1.00011011101101100101000_2$。\n    我们将舍入后的有效数称为 $m_{x^2}$。$fl(\\hat{x}^2)$ 的值为 $m_{x^2} \\times 2^{53}$。\n    未规格化的有效数的整数表示为 $(100011011101101100101000)_2 = (8DD698)_{16} = 9295512$。\n    所以 $fl(\\hat{x}^2) = 9295512 \\times 2^{53 - 23} = 9295512 \\times 2^{30} = 10000000216535040$。\n\n2.  **计算 $fl(fl(\\hat{x}^2) + fl(\\hat{y}^2))$**：\n    $fl(\\hat{y}^2)=fl(1^2)=1$。我们需要计算 $fl(10000000216535040 + 1)$。\n    第一个数的指数是 $53$。第二个数 $1$ 的指数是 $0$。\n    为了执行加法，必须对齐指数。较小数（$1$）的有效数必须右移指数差值，即 $53$ 位。\n    $1.0 \\times 2^0 = 0.\\underbrace{00...0}_{52}1 \\times 2^{53}$。\n    $1$ 的有效数向右移动得太远，以至于完全丢失，因为 binary$32$ 只保持 $24$ 位的精度。加法对较大数的有效数没有影响。这种现象称为“淹没”(swamping)。\n    $fl(fl(\\hat{x}^2) + 1) = fl(\\hat{x}^2) = 10000000216535040$。\n\n3.  **计算 $h_{\\mathrm{comp1}} = fl(\\sqrt{10000000216535040})$**：\n    精确的平方根是 $\\sqrt{10000000216535040} \\approx 100000001.082675$。\n    我们必须将这个值舍入到最接近的 binary$32$ 数。\n    这个数大约是 $10^8$，所以它的指数是 $26$。对于这个数量级的数，最后一位的单位 (ULP) 是 $2^{E - (p-1)} = 2^{26-23} = 2^3=8$。\n    在 $10^8$ 附近的可表示数为 $8$ 的倍数，例如 $100,000,000$ 和 $100,000,008$。\n    值 $100000001.082675$ 位于这两个数之间。它们的中点是 $100,000,004$。\n    由于 $100000001.082675  100000004$，它被向下舍入到最接近的可表示数。\n    $h_{\\mathrm{comp1}} = 100,000,000 = 10^8$。\n\n### 算法 (ii)：补偿缩放方法 $h_{\\mathrm{comp2}} = fl(\\hat{r} \\cdot fl(\\sqrt{fl(1 + fl(fl(\\hat{s}/\\hat{r})^2))})))$\n\n1.  **确定 $r$ 和 $s$**：\n    $r=\\max(|x|,|y|) = 10^8$，并且 $s=\\min(|x|,|y|) = 1$。存储的值是精确的：$\\hat{r}=10^8$, $\\hat{s}=1$。\n\n2.  **计算 $fl(\\hat{s}/\\hat{r})$**：\n    这是 $fl(1/10^8) = fl(10^{-8})$。这是一个非常小的数。\n\n3.  **计算 $fl(fl(\\hat{s}/\\hat{r})^2)$**：\n    这将是一个约等于 $(10^{-8})^2 = 10^{-16}$ 的数。其指数将在 $\\lfloor\\log_2(10^{-16})\\rfloor = -54$ 左右。\n\n4.  **计算 $fl(1 + fl(fl(\\hat{s}/\\hat{r})^2))$**：\n    我们正在将 $1$（指数为 $0$）与一个非常小的数（指数约为 $-54$）相加。指数差约为 $54$，远大于 $24$ 位的有效数精度。与算法 (i) 中一样，发生了淹没现象。在为加法对齐时，较小的数完全丢失。\n    $fl(1 + (\\text{一个数量级为 } 10^{-16} \\text{ 的数})) = 1$。\n\n5.  **计算 $fl(\\sqrt{...})$**：\n    $fl(\\sqrt{1}) = 1$。这是精确的。\n\n6.  **计算 $h_{\\mathrm{comp2}} = fl(\\hat{r} \\cdot 1)$**：\n    $h_{\\mathrm{comp2}} = fl(10^8 \\cdot 1) = 10^8$。这个乘法是精确的。\n\n两种算法都得到相同的计算结果：$h_{\\mathrm{comp}} = 10^8$。\n\n### 相对误差计算\n\n相对误差定义为 $\\frac{|h_{\\mathrm{comp}}-h|}{h}$，其中 $h_{\\mathrm{comp}} = 10^8$ 且 $h=\\sqrt{10^{16}+1}$。\n\n$h = \\sqrt{10^{16}+1} = 10^8 \\sqrt{1+10^{-16}}$。\n对于小的 $\\epsilon$，使用近似公式 $\\sqrt{1+\\epsilon} \\approx 1+\\epsilon/2$：\n$h \\approx 10^8(1+\\frac{1}{2}10^{-16}) = 10^8 + 0.5 \\times 10^{-8}$。\n绝对误差为 $|h_{\\mathrm{comp}}-h| = |10^8 - (10^8+0.5 \\times 10^{-8})| = 0.5 \\times 10^{-8}$。\n为了避免精度损失，我们使用共轭表达式：\n$h-h_{\\mathrm{comp}} = \\sqrt{10^{16}+1}-10^8 = (\\sqrt{10^{16}+1}-10^8) \\frac{\\sqrt{10^{16}+1}+10^8}{\\sqrt{10^{16}+1}+10^8} = \\frac{(10^{16}+1)-10^{16}}{\\sqrt{10^{16}+1}+10^8} = \\frac{1}{\\sqrt{10^{16}+1}+10^8}$。\n\n相对误差为 $\\frac{|h_{\\mathrm{comp}}-h|}{h} = \\frac{h-h_{\\mathrm{comp}}}{h} = \\frac{1}{h(\\sqrt{10^{16}+1}+10^8)}$。\n由于 $h = \\sqrt{10^{16}+1} \\approx 10^8$，我们可以近似计算相对误差：\n相对误差 $\\approx \\frac{1}{10^8(10^8+10^8)} = \\frac{1}{10^8(2 \\cdot 10^8)} = \\frac{1}{2 \\cdot 10^{16}} = 0.5 \\times 10^{-16} = 5 \\times 10^{-17}$。\n\n题目要求答案四舍五入到四位有效数字。\n$5 \\times 10^{-17} = 5.000 \\times 10^{-17}$。", "answer": "$$\\boxed{5.000 \\times 10^{-17}}$$", "id": "3642006"}]}