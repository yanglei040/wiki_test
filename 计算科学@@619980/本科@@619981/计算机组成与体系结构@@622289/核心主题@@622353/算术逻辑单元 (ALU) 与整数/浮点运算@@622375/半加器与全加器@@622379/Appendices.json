{"hands_on_practices": [{"introduction": "理论知识只有通过实践才能真正巩固。本节将从最基本的加法单元——半加法器——开始。这个练习要求你仅使用与非门（NAND gate）来构建一个半加法器，这不仅能加深你对通用逻辑门概念的理解，还能让你亲身体验如何分析和优化电路的性能，特别是传播延迟[@problem_id:3645102]。", "problem": "半加法器的布尔输出定义为 $S = A \\oplus B$ 和 $C = A \\cdot B$，其中 $A$ 和 $B$ 是布尔输入，$\\oplus$ 表示异或。请仅使用双输入与非门（NAND gate）重新设计此半加法器，并遵循以下实现规则和时序模型：每个与非门具有相同的传播延迟 $t_{pd}$；反相器必须通过将一个与非门的两个输入连接在一起实现；扇出不受限制；导线/互连延迟被忽略；并且中间信号可以在 $S$ 和 $C$ 之间共享。将一个输出的逻辑深度定义为从任意主输入到该输出的最长路径上的门级数。半加法器的最坏情况传播延迟是 $S$ 和 $C$ 传播延迟中的最大值。\n\n在这些约束条件下，请确定在所有能同时产生 $S$ 和 $C$ 的纯与非门半加法器实现中，可实现的最小最坏情况传播延迟，并以包含 $t_{pd}$ 的闭式解析表达式表示。您的推理必须说明每个输出的门深度，并证明所达到的深度是最小的。只需报告以 $t_{pd}$ 表示的最终表达式；无需绘图，也无需四舍五入。", "solution": "用户希望我解决这个问题。\n\n**1. 角色扮演：** 作为一名严谨的STEM教授，我必须确保科学正确性和逻辑严密性。\n\n**2. 任务：** 核心任务是要求在给定的时序模型下，计算一个仅用双输入与非门实现的半加法器的最小最坏情况传播延迟。\n\n**3. 问题验证：**\n\n*   **步骤1：提取已知条件**\n    *   半加法器输出：$S = A \\oplus B$，$C = A \\cdot B$。\n    *   输入：$A$，$B$（布尔值）。\n    *   实现方式：仅使用双输入与非门。\n    *   时序模型：\n        *   每个与非门的传播延迟为 $t_{pd}$。\n        *   反相器是一个输入端相连的与非门，其延迟也为 $t_{pd}$。\n        *   扇出不受限制。\n        *   导线延迟被忽略。\n    *   信号共享：$S$ 和 $C$ 的逻辑电路之间可以共享中间信号。\n    *   定义：\n        *   逻辑深度：从主输入到输出的最长路径上的门级数。\n        *   最坏情况传播延迟：$\\max(\\text{delay}(S), \\text{delay}(C))$，其中一个输出的延迟是其逻辑深度乘以 $t_{pd}$。\n    *   目标：以包含 $t_{pd}$ 的闭式表达式，求出可实现的最小最坏情况传播延迟。\n\n*   **步骤2：先验验证**\n    *   **科学依据：** 该问题牢固地植根于经典的数字逻辑设计和布尔代数，这是计算机工程和电气工程的核心学科。半加法器、与非逻辑和传播延迟的定义都是标准且符合事实的。\n    *   **适定性：** 问题明确了组件（双输入与非门）、约束条件（纯与非门实现）、明确的目标（最小化最坏情况延迟）以及明确的评估指标（逻辑深度）。预期存在一个唯一的最小延迟解。\n    *   **客观性：** 问题以精确、无歧义的技术术语陈述，不含主观主张或意见。\n    *   **结论：** 该问题是**有效的**。我将着手构建解决方案。\n\n*   **步骤3：裁定**\n    *   该问题是**有效的**。我将着手构建解决方案。\n\n**4. 求解过程**\n\n问题在于要使用仅含双输入与非门的方式，合成一个由和（$S$）与进位（$C$）的布尔函数定义的半加法器，并找出可能的最小最坏情况传播延迟。\n\n半加法器输出的布尔表达式为：\n$$\nS = A \\oplus B\n$$\n$$\nC = A \\cdot B\n$$\n其中 $A$ 和 $B$ 是主输入。符号 $\\oplus$ 代表异或（XOR）运算。\n\n在给定模型下，逻辑电路的传播延迟由其逻辑深度决定。一个输出的延迟是其逻辑深度乘以门延迟 $t_{pd}$。半加法器的最坏情况传播延迟是 $S$ 和 $C$ 输出延迟中的最大值。为了最小化此延迟，我们必须最小化 $S$ 和 $C$ 逻辑深度的最大值。设 $\\text{depth}(X)$ 表示信号 $X$ 的逻辑深度。目标是找到一种实现，使得 $\\max(\\text{depth}(S), \\text{depth}(C))$ 最小。\n\n首先，我们分析进位输出 $C$。其函数为 $C = A \\cdot B$。由于与非门是功能完备的，任何布尔函数都可以用它实现。与（AND）函数 $A \\cdot B$ 可以通过双重否定实现，利用与非门的定义 $(X \\cdot Y)'$。\n$$\nC = A \\cdot B = ((A \\cdot B)')'\n$$\n该表达式可以直接映射到一个两级与非门电路：\n1.  第一级与非门计算信号 $N_1 = (A \\cdot B)'$。输入 $A$ 和 $B$ 是主输入，深度为0。因此，$N_1$ 的深度为1。\n2.  第二级与非门用作反相器，计算 $C = (N_1)' = (N_1 \\cdot N_1)'$。输入 $N_1$ 的深度为1，所以输出 $C$ 的深度为 $1+1=2$。\n\n逻辑路径是 $A,B \\rightarrow \\text{NAND}_1 \\rightarrow \\text{NAND}_2 \\rightarrow C$。进位输出的最小逻辑深度是 $\\text{depth}(C) = 2$。相应的延迟是 $2 \\cdot t_{pd}$。这个深度无法再减少，因为单个与非门产生的是 $(A \\cdot B)'$，而不是 $A \\cdot B$。\n\n接着，我们分析和输出 $S$。其函数为 $S = A \\oplus B$。异或的标准积之和展开式为：\n$$\nS = (A' \\cdot B) + (A \\cdot B')\n$$\n直接实现此表达式会导致很高的逻辑深度。我们必须寻找一个更优化的结构。一个著名且高效的纯与非门异或函数实现如下，它巧妙地复用了一个中间信号：\n$$\nS = ((A \\cdot (A \\cdot B)')') \\cdot ((B \\cdot (A \\cdot B)')'))'\n$$\n让我们分析这个结构及其深度，并利用可能与进位逻辑共享信号的优势。令 $N_1 = (A \\cdot B)'$。这与进位实现的第一级信号相同。\n1.  $N_1 = (A \\cdot B)'$。这是一个与非门。$\\text{depth}(N_1) = 1$。此信号可用于 $S$ 和 $C$ 的逻辑。\n2.  $N_2 = (A \\cdot N_1)'$。这是第二个与非门。其输入为 $A$（深度0）和 $N_1$（深度1）。因此，$\\text{depth}(N_2) = \\max(0, 1) + 1 = 2$。\n3.  $N_3 = (B \\cdot N_1)'$。这是第三个与非门。其输入为 $B$（深度0）和 $N_1$（深度1）。因此，$\\text{depth}(N_3) = \\max(0, 1) + 1 = 2$。\n4.  $S = (N_2 \\cdot N_3)'$。这是第四个与非门。其输入为 $N_2$ 和 $N_3$，两者的深度都为2。因此，最终输出 $S$ 的深度为 $\\text{depth}(S) = \\max(2, 2) + 1 = 3$。\n\n例如，$S$ 的最长深度逻辑路径为 $A \\rightarrow \\text{NAND}_1 \\rightarrow \\text{NAND}_2 \\rightarrow \\text{NAND}_4 \\rightarrow S$。此路径包含3个门级。相应的延迟是 $3 \\cdot t_{pd}$。可以形式上证明，对于未取反的输入，一个双输入异或函数不能用少于3级的双输入与非门/或非门逻辑来实现。因此，$\\text{depth}(S)=3$ 是最小的。\n\n现在我们组装完整的半加法器，共享中间信号 $N_1$：\n-   $S$ 的逻辑如上所述，得出 $\\text{depth}(S) = 3$。\n-   $C$ 的逻辑复用了信号 $N_1 = (A \\cdot B)'$（深度为1）并将其反相：$C = (N_1 \\cdot N_1)'$。该输出的深度为 $1+1=2$。所以，$\\text{depth}(C) = 2$。\n\n两个输出的逻辑深度分别为 $\\text{depth}(S) = 3$ 和 $\\text{depth}(C) = 2$。\n各自的传播延迟为：\n$$\n\\text{delay}(S) = \\text{depth}(S) \\cdot t_{pd} = 3 \\cdot t_{pd}\n$$\n$$\n\\text{delay}(C) = \\text{depth}(C) \\cdot t_{pd} = 2 \\cdot t_{pd}\n$$\n\n半加法器的最坏情况传播延迟是这两个值中的最大值：\n$$\n\\text{Delay}_{\\text{worst-case}} = \\max(\\text{delay}(S), \\text{delay}(C)) = \\max(3 \\cdot t_{pd}, 2 \\cdot t_{pd}) = 3 \\cdot t_{pd}\n$$\n由于异或函数（$S$）的最小可能深度为3，任何实现都无法达到小于3的最坏情况深度。所提出的设计达到了这个下界，因此在最小化最坏情况传播延迟方面是最优的。最终表达式为 $3 \\cdot t_{pd}$。", "answer": "$$\n\\boxed{3 \\cdot t_{pd}}\n$$", "id": "3645102"}, {"introduction": "在掌握了半加法器的基础上，我们来挑战一个更复杂的单元——全加法器。全加法器中的进位逻辑是决定多位加法器速度的关键路径。通过这个练习[@problem_id:3645089]，你将运用布尔代数对进位输出表达式进行因式分解，并比较不同逻辑实现方式下的信号延迟，从而揭示逻辑表达式的代数形式如何直接影响电路的性能和路径平衡。", "problem": "一个全加器的进位输出可以写成布尔表达式 $C_{out} = A B + C_{in}(A + B)$，其中 $A$、$B$ 和 $C_{in}$ 是布尔输入，$C_{out}$ 是进位输出。仅使用布尔代数的公理和定理（交换律、结合律、分配律、幂等律和吸收律），首先推导出 $C_{out}$ 的一个仅使用“或”和“与”运算的“和之积”分解形式。然后，在一个均匀延迟模型下考虑两种电路实现，其中每个基本的“与”或“或”运算都会产生 1 个单位延迟：\n- 实现 $\\mathcal{S}$（使用复合门的“积之和”）：使用一个双输入“或”门构成 $S = A + B$，然后一个双输入“与”门构成 $P = C_{in} \\cdot S$，最后用一个计算 $Y = (X_1 \\cdot X_2) + Z$ 的“与或”（AO）复合门来实现 $C_{out} = (A \\cdot B) + P$。这里的“与或”（AO）表示实现函数 $Y = (X_1 \\cdot X_2) + Z$ 的单个门，它在逻辑上等同于一个封装内的“与”门后接一个“或”门。\n- 实现 $\\mathcal{P}$（和之积）：直接使用多个“或”门馈入一个最终的“与”门，来实现你分解出的“和之积”形式。\n\n假设在 AO 门内部，其内部的“与”和“或”操作各产生 1 个单位延迟，因此进入 AO 门“与”输入的信号路径会经过两个内部级（先“与”后“或”），而进入 AO 门“或”输入的信号路径会经过一个内部级（“或”）。在此模型下，关于代数分解以及实现 $\\mathcal{S}$ 与 $\\mathcal{P}$ 的相对信号到达时间平衡性，哪种说法是正确的？\n\nA. 正确的分解形式是 $C_{out} = (A + B)(A + C_{in})(B + C_{in})$。实现 $\\mathcal{S}$ 使用一个“或”门生成 $S$，一个“与”门生成 $P$，以及一个 AO 门生成 $C_{out}$，但其路径不平衡：从 $A$ 或 $B$ 到 $C_{out}$ 的路径经过 2 个 AO 门内部级，而 $C_{in}$ 经过 3 个级（外部的“或”和“与”门，再加上 AO 门的最终“或”门）。相比之下，实现 $\\mathcal{P}$ 为每个输入提供了 2 级路径（一个“或”门后接最终的“与”门），因此它的平衡性更好。\n\nB. 正确的分解形式是 $C_{out} = (A + C_{in})(B + C_{in})$。在所述延迟模型下，实现 $\\mathcal{S}$ 和 $\\mathcal{P}$ 从所有输入到 $C_{out}$ 都具有平衡的 2 级路径。\n\nC. 正确的分解形式是 $C_{out} = (A \\cdot B) + (A \\oplus B) C_{in}$，并且实现 $\\mathcal{S}$ 是路径平衡的，因为每个输入在到达 $C_{out}$ 之前都恰好经过 2 级。\n\nD. 正确的分解形式是 $C_{out} = (A + B)(A + C_{in})(B + C_{in})$，但实现 $\\mathcal{P}$ 为 $C_{in}$ 产生的路径（3 级）比为 $A$ 或 $B$ 产生的路径更长，因此 $\\mathcal{S}$ 的平衡性比 $\\mathcal{P}$ 更好。", "solution": "问题陈述被评估为有效。它在科学上基于布尔代数和数字逻辑设计，提法得当，目标明确，数据充分，并以客观语言表达。不存在会使问题无效的缺陷。\n\n分析分三部分进行：首先，推导进位输出 $C_{out}$ 的和之积（POS）形式；其次，对所描述的两种电路实现 $\\mathcal{S}$ 和 $\\mathcal{P}$ 进行延迟分析；第三，基于此分析对每个提供的选项进行评估。\n\n**1. 和之积（POS）分解形式的推导**\n\n全加器进位输出的初始布尔表达式为：\n$$C_{out} = A B + C_{in}(A + B)$$\n这是一个基于积之和（SOP）的形式。为了仅使用布尔代数公理将其转换为和之积（POS）形式，我们应用分配律，具体为 $X + YZ = (X+Y)(X+Z)$。\n\n首先，我们将 $AB$ 视为单个项，并对与 $C_{in}(A+B)$ 的加法应用分配律。令 $X = AB$，$Y = C_{in}$，$Z = A+B$。\n$$C_{out} = X + YZ = (X+Y)(X+Z)$$\n代入回去：\n$$C_{out} = (AB + C_{in})(AB + (A+B))$$\n让我们使用吸收律 ($U + UV = U$) 来化简第二项 $(AB + A + B)$：\n$$AB + A + B = (A + AB) + B = A + B$$\n因此，表达式化简为：\n$$C_{out} = (AB + C_{in})(A+B)$$\n现在，我们再次对第一项 $(AB + C_{in})$ 应用分配律。令 $X' = C_{in}$，$Y' = A$，$Z' = B$。\n$$X' + Y'Z' = (X'+Y')(X'+Z')$$\n代入回去：\n$$C_{in} + AB = (C_{in} + A)(C_{in} + B)$$\n根据交换律，这等于 $(A+C_{in})(B+C_{in})$。\n\n综上所述，最终的 POS 分解形式为：\n$$C_{out} = (A+B)(A+C_{in})(B+C_{in})$$\n代数推导到此完成。\n\n**2. 实现 $\\mathcal{S}$ 和 $\\mathcal{P}$ 的延迟分析**\n\n均匀延迟模型指出，每个基本的“与”或“或”运算产生 1 个单位延迟。\n\n**实现 $\\mathcal{S}$（带 AO 门的 SOP）的分析：**\n该电路计算 $C_{out} = (A \\cdot B) + P$，其中 $P = C_{in} \\cdot S$ 且 $S = A+B$。最终操作使用一个“与或”（AO）复合门。我们来分析信号到达时间，假设输入 $A$、$B$ 和 $C_{in}$ 在时间 $t=0$ 时可用。\n\nAO 门计算 $Y = (X_1 \\cdot X_2) + Z$。对于此实现，$X_1=A$，$X_2=B$，$Z=P$。AO 门的延迟模型是：对于 $X$ 输入为 2 级（内部“与”，然后内部“或”），对于 $Z$ 输入为 1 级（内部“或”）。\n\n- **路径 1（通过 AO 门的“与”输入）：** 信号 $A$ 和 $B$ 进入 AO 门的“与”输入。通过该路径的延迟是 2 个单位。因此，来自该路径对 $C_{out}$ 的贡献在 $t = 0 + 2 = 2$ 时到达。\n\n- **路径 2（通过 AO 门的“或”输入）：** 信号 $P$ 进入 AO 门的“或”输入。我们必须首先计算 $P$ 的到达时间。\n  - $S = A+B$ 由一个外部“或”门计算。其输出在 $t_S = 1$ 时就绪。\n  - $P = C_{in} \\cdot S$ 由一个外部“与”门计算。其输出在 $t_P = \\max(t_{C_{in}}, t_S) + 1 = \\max(0, 1) + 1 = 2$ 时就绪。\n  - 信号 $P$ 在 $t=2$ 时到达 AO 门的 $Z$ 输入。从该输入到输出的延迟是 1 个单位。\n  - 来自该路径对 $C_{out}$ 的贡献在 $t = t_P + 1 = 2 + 1 = 3$ 时到达。\n\n当所有贡献路径都稳定下来后，最终输出 $C_{out}$ 才稳定。因此，实现 $\\mathcal{S}$ 的总延迟为 $\\max(2, 3) = 3$。信号路径是不平衡的：一条路径的延迟为 2 个单位，而关键路径的延迟为 3 个单位。\n\n**实现 $\\mathcal{P}$（POS）的分析：**\n该电路使用多个“或”门馈入一个最终的“与”门来计算 $C_{out} = (A+B)(A+C_{in})(B+C_{in})$。假设最终级使用一个三输入“与”门，这符合 1 个单位的 uniform delay model。\n\n- **第 1 级（“或”门）：** 三个“或”运算并行执行。\n  - $T_1 = A+B$：在 $t=1$ 时就绪。\n  - $T_2 = A+C_{in}$：在 $t=1$ 时就绪。\n  - $T_3 = B+C_{in}$：在 $t=1$ 时就绪。\n\n- **第 2 级（最终“与”门）：** 一个“与”门接收 $T_1$、$T_2$ 和 $T_3$ 作为输入。由于所有三个输入都在 $t=1$ 时到达，最终输出在 $t = 1 + 1 = 2$ 时就绪。\n\n在此实现中，从任何输入（$A$、$B$ 或 $C_{in}$）到输出 $C_{out}$ 的每条路径都由一个“或”门后跟一个“与”门组成。每条路径的总延迟为 $1+1=2$ 个单位。路径是完全平衡的，关键路径延迟为 2。\n\n**分析结论：** 实现 $\\mathcal{P}$ 既更快（延迟为 2 vs 3）又完全路径平衡，而实现 $\\mathcal{S}$ 则更慢且路径不平衡。\n\n**3. 选项评估**\n\n**A. 正确的分解形式是 $C_{out} = (A + B)(A + C_{in})(B + C_{in})$。实现 $\\mathcal{S}$ 使用一个“或”门生成 $S$，一个“与”门生成 $P$，以及一个 AO 门生成 $C_{out}$，但其路径不平衡：从 $A$ 或 $B$ 到 $C_{out}$ 的路径经过 2 个 AO 门内部级，而 $C_{in}$ 经过 3 个级（外部的“或”和“与”门，再加上 AO 门的最终“或”门）。相比之下，实现 $\\mathcal{P}$ 为每个输入提供了 2 级路径（一个“或”门后接最终的“与”门），因此它的平衡性更好。**\n- 分解形式如上推导是正确的。\n- 关于实现 $\\mathcal{P}$ 具有平衡的 2 级路径的描述是正确的。\n- 关于实现 $\\mathcal{S}$ 路径不平衡的结论是正确的。\n- 关于 $\\mathcal{S}$ 中路径长度的推理略有模糊，但抓住了时序的本质。关键路径涉及 $C_{in}$，总延迟等效于 3 个门级（$A+B$ $\\to$ $(A+B)C_{in}$ $\\to$ 最终的“或”），这一点被正确地指出了。对于 $A$ 和 $B$ 的更快路径（通过内部 AO-AND）具有 2 级的延迟。该陈述正确地得出结论，即 $\\mathcal{S}$ 是不平衡的，而 $\\mathcal{P}$ 的平衡性更好。\n- 结论：**正确**。\n\n**B. 正确的分解形式是 $C_{out} = (A + C_{in})(B + C_{in})$。在所述延迟模型下，实现 $\\mathcal{S}$ 和 $\\mathcal{P}$ 从所有输入到 $C_{out}$ 都具有平衡的 2 级路径。**\n- 分解形式不正确。它化简为 $AB+C_{in}$，这与全加器进位输出不等价。例如，如果 $A=0$，$B=0$，$C_{in}=1$，那么 $C_{out}=0$ 但 $AB+C_{in}=1$。\n- 声称 $\\mathcal{S}$ 具有平衡的 2 级路径是不正确的。\n- 结论：**不正确**。\n\n**C. 正确的分解形式是 $C_{out} = (A \\cdot B) + (A \\oplus B) C_{in}$，并且实现 $\\mathcal{S}$ 是路径平衡的，因为每个输入在到达 $C_{out}$ 之前都恰好经过 2 级。**\n- 表达式 $C_{out} = AB + (A \\oplus B) C_{in}$ 是进位输出的一个有效表示。然而，问题明确要求一个“仅使用‘或’和‘与’运算”的 POS 分解形式。此形式使用了异或（$\\oplus$）并且是一个 SOP 形式，因此不满足问题的推导要求。\n- 如分析所示，声称实现 $\\mathcal{S}$ 是路径平衡的是不正确的。其关键路径延迟为 3。\n- 结论：**不正确**。\n\n**D. 正确的分解形式是 $C_{out} = (A + B)(A + C_{in})(B + C_{in})$，但实现 $\\mathcal{P}$ 为 $C_{in}$ 产生的路径（3 级）比为 $A$ 或 $B$ 产生的路径更长，因此 $\\mathcal{S}$ 的平衡性比 $\\mathcal{P}$ 更好。**\n- 分解形式是正确的。\n- 声称实现 $\\mathcal{P}$ 对 $C_{in}$ 有一条 3 级路径是不正确的。如分析所示，在 $\\mathcal{P}$ 中所有输入都有一条 2 级路径。\n- 结论“$\\mathcal{S}$ 比 $\\mathcal{P}$ 平衡性更好”是不正确的。事实恰恰相反。\n- 结论：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "3645089"}, {"introduction": "一个电路设计得再巧妙，如果无法验证其在物理制造后是否功能正常，也是徒劳的。本练习[@problem_id:3645151]将你带入硬件测试的世界，使用经典的“固定型故障”（stuck-at fault）模型来分析半加法器。你的任务是系统地推导出一个最小化的测试向量集，以确保能够检测出所有可能的单一固定型故障，这是保证数字芯片可靠性的关键一步。", "problem": "考虑一个具有两个主输入 $A$ 和 $B$ 以及两个主输出：和 $S$ 与进位 $C$ 的半加器。根据定义，和是输入的异或（XOR），进位是输入的逻辑与（AND），因此 $S = A \\oplus B$ 且 $C = A \\cdot B$。使用单一固定型故障（SAF）模型：四个信号线 $A$、$B$、$S$（XOR 输出）和 $C$（AND 输出）中的每一个都可能固定为0或固定为1，从而产生8个不同的单一故障。如果在故障情况下，主输出 $\\{S,C\\}$ 中至少有一个与同一 $(A,B)$ 产生的无故障值不同，则测试向量 $(A,B)$ 检测到特定的单一固定型故障。\n\n仅从半加器和单一固定型故障模型的形式化定义出发，完成以下任务：\n- 构建一个完整的故障表，对于每个输入向量 $(A,B) \\in \\{(0,0),(0,1),(1,0),(1,1)\\}$，该表指出在信号线 $\\{A,B,S,C\\}$ 上的8个单一固定型故障中哪些被检测到。\n- 基于您的故障表和关于故障敏化和传播的第一性原理推理，确定一个能够检测所有8个单一固定型故障的最小输入测试向量集。\n\n您的最终答案只需提供实现完全检测所需的不同测试向量的最小数量。最终答案必须是单个整数。", "solution": "该问题要求确定一个最小的输入测试向量集，以检测半加器主输入和主输出上的所有单一固定型故障。解决方案从电路和故障模型的定义出发，通过第一性原理推导得出。\n\n半加器是一个数字逻辑电路，有两个输入（我们记为 $A$ 和 $B$）和两个输出（和 $S$ 与进位 $C$）。其逻辑行为由以下布尔表达式定义：\n$$S = A \\oplus B$$\n$$C = A \\cdot B$$\n其中 $\\oplus$ 代表异或（XOR）运算，$\\cdot$ 代表逻辑与（AND）运算。\n\n所有可能的输入向量集合是 $\\{(0,0), (0,1), (1,0), (1,1)\\}$。我们将这四个向量分别记为 $T_0 = (0,0)$、$T_1 = (0,1)$、$T_2 = (1,0)$ 和 $T_3 = (1,1)$。\n\n首先，我们为每个输入向量列出无故障的输出值：\n| 测试向量 $(A,B)$ | 无故障和 $S$ | 无故障进位 $C$ |\n| :--- | :---: | :---: |\n| $T_0 = (0,0)$ | $0 \\oplus 0 = 0$ | $0 \\cdot 0 = 0$ |\n| $T_1 = (0,1)$ | $0 \\oplus 1 = 1$ | $0 \\cdot 1 = 0$ |\n| $T_2 = (1,0)$ | $1 \\oplus 0 = 1$ | $1 \\cdot 0 = 0$ |\n| $T_3 = (1,1)$ | $1 \\oplus 1 = 0$ | $1 \\cdot 1 = 1$ |\n\n故障模型是单一固定型故障（SAF）模型。所考虑的故障发生在信号线 $A$、$B$、$S$ 和 $C$ 上。每条信号线都可能固定为0（SA0）或固定为1（SA1）。这总共产生需要分析的 $4 \\times 2 = 8$ 个故障：\n$f_1: A$ 固定为0, $f_2: A$ 固定为1, $f_3: B$ 固定为0, $f_4: B$ 固定为1, $f_5: S$ 固定为0, $f_6: S$ 固定为1, $f_7: C$ 固定为0, $f_8: C$ 固定为1。\n\n如果在故障情况下，电路的主输出对 $(S_{faulty}, C_{faulty})$ 与无故障输出对 $(S, C)$ 不同，则测试向量 $(A,B)$ 检测到该故障。\n\n我们现在分析4个输入向量中每一个对8个故障中每一个的可检测性。\n\n**输入信号线（$A$, $B$）上的故障**\n要检测到输入信号线上的故障，必须满足两个条件：\n1.  **故障敏化**：输入向量必须为该信号线赋予与固定值相反的值。例如，要测试 $A$ 固定为0，输入 $A$ 必须为 $1$。\n2.  **故障传播**：输入信号线上的错误必须导致至少一个主输出 $S$ 或 $C$ 发生变化。\n\n- **故障 $f_1$: $A$ 固定为0**：必须有 $A=1$。候选向量为 $T_2=(1,0)$ 和 $T_3=(1,1)$。\n  - 对于 $T_2=(1,0)$，无故障输出为 $(S,C) = (1,0)$。当 $A$ 固定为0时，门的输入变为 $(0,0)$，产生的故障输出为 $(S_f, C_f) = (0,0)$。由于 $(0,0) \\neq (1,0)$，该故障被检测到。\n  - 对于 $T_3=(1,1)$，无故障输出为 $(S,C) = (0,1)$。当 $A$ 固定为0时，输入变为 $(0,1)$，产生的故障输出为 $(S_f, C_f) = (1,0)$。由于 $(1,0) \\neq (0,1)$，该故障被检测到。\n  - 故障 $A$ 固定为0 可被 $\\{T_2, T_3\\}$ 检测到。\n\n- **故障 $f_2$: $A$ 固定为1**：必须有 $A=0$。候选向量为 $T_0=(0,0)$ 和 $T_1=(0,1)$。\n  - 对于 $T_0=(0,0)$，无故障输出为 $(0,0)$。当 $A$ 固定为1时，输入变为 $(1,0)$，得到 $(S_f, C_f) = (1,0)$。由于 $(1,0) \\neq (0,0)$，该故障被检测到。\n  - 对于 $T_1=(0,1)$，无故障输出为 $(1,0)$。当 $A$ 固定为1时，输入变为 $(1,1)$，得到 $(S_f, C_f) = (0,1)$。由于 $(0,1) \\neq (1,0)$，该故障被检测到。\n  - 故障 $A$ 固定为1 可被 $\\{T_0, T_1\\}$ 检测到。\n\n- **故障 $f_3$: $B$ 固定为0**：必须有 $B=1$。候选向量为 $T_1=(0,1)$ 和 $T_3=(1,1)$。\n  - 对于 $T_1=(0,1)$，无故障输出为 $(1,0)$。当 $B$ 固定为0时，输入变为 $(0,0)$，得到 $(S_f, C_f) = (0,0)$。检测到。\n  - 对于 $T_3=(1,1)$，无故障输出为 $(0,1)$。当 $B$ 固定为0时，输入变为 $(1,0)$，得到 $(S_f, C_f) = (1,0)$。检测到。\n  - 故障 $B$ 固定为0 可被 $\\{T_1, T_3\\}$ 检测到。\n\n- **故障 $f_4$: $B$ 固定为1**：必须有 $B=0$。候选向量为 $T_0=(0,0)$ 和 $T_2=(1,0)$。\n  - 对于 $T_0=(0,0)$，无故障输出为 $(0,0)$。当 $B$ 固定为1时，输入变为 $(0,1)$，得到 $(S_f, C_f) = (1,0)$。检测到。\n  - 对于 $T_2=(1,0)$，无故障输出为 $(1,0)$。当 $B$ 固定为1时，输入变为 $(1,1)$，得到 $(S_f, C_f) = (0,1)$。检测到。\n  - 故障 $B$ 固定为1 可被 $\\{T_0, T_2\\}$ 检测到。\n\n**输出信号线（$S$, $C$）上的故障**\n要检测到输出信号线上的故障，输入向量必须在该信号线上产生一个与固定值相反的无故障值。另一个输出信号线不受影响。\n\n- **故障 $f_5$: $S$ 固定为0**：必须有无故障 $S=1$。这发生在 $T_1=(0,1)$ 和 $T_2=(1,0)$。\n  - 对于 $T_1$ 和 $T_2$，无故障输出均为 $(S,C) = (1,0)$。$S$ 固定为0的故障强制输出为 $(S_f, C_f) = (0,0)$。由于 $(0,0) \\neq (1,0)$，两个向量都能检测到该故障。\n  - 故障 $S$ 固定为0 可被 $\\{T_1, T_2\\}$ 检测到。\n\n- **故障 $f_6$: $S$ 固定为1**：必须有无故障 $S=0$。这发生在 $T_0=(0,0)$ 和 $T_3=(1,1)$。\n  - 对于 $T_0=(0,0)$，无故障 $(S,C)=(0,0)$。故障输出为 $(1,0)$。检测到。\n  - 对于 $T_3=(1,1)$，无故障 $(S,C)=(0,1)$。故障输出为 $(1,1)$。检测到。\n  - 故障 $S$ 固定为1 可被 $\\{T_0, T_3\\}$ 检测到。\n\n- **故障 $f_7$: $C$ 固定为0**：必须有无故障 $C=1$。这只发生在 $T_3=(1,1)$。\n  - 对于 $T_3=(1,1)$，无故障 $(S,C)=(0,1)$。$C$ 固定为0的故障强制输出为 $(S_f, C_f) = (0,0)$。由于 $(0,0) \\neq (0,1)$，该故障被检测到。\n  - 故障 $C$ 固定为0 只能被 $\\{T_3\\}$ 检测到。\n\n- **故障 $f_8$: $C$ 固定为1**：必须有无故障 $C=0$。这发生在 $T_0=(0,0)$、$T_1=(0,1)$ 和 $T_2=(1,0)$。\n  - 对于 $T_0=(0,0)$，无故障 $(S,C)=(0,0)$。故障输出为 $(0,1)$。检测到。\n  - 对于 $T_1=(0,1)$，无故障 $(S,C)=(1,0)$。故障输出为 $(1,1)$。检测到。\n  - 对于 $T_2=(1,0)$，无故障 $(S,C)=(1,0)$。故障输出为 $(1,1)$。检测到。\n  - 故障 $C$ 固定为1 可被 $\\{T_0, T_1, T_2\\}$ 检测到。\n\n我们将这些结果汇总成一个故障表，其中 '1' 表示测试向量（行）检测到故障（列）。\n\n| 向量        | $A$ 固定为0 | $A$ 固定为1 | $B$ 固定为0 | $B$ 固定为1 | $S$ 固定为0 | $S$ 固定为1 | $C$ 固定为0 | $C$ 固定为1 |\n| :---          | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| $T_0=(0,0)$   | $0$   | $1$   | $0$   | $1$   | $0$   | $1$   | $0$   | $1$   |\n| $T_1=(0,1)$   | $0$   | $1$   | $1$   | $0$   | $1$   | $0$   | $0$   | $1$   |\n| $T_2=(1,0)$   | $1$   | $0$   | $0$   | $1$   | $1$   | $0$   | $0$   | $1$   |\n| $T_3=(1,1)$   | $1$   | $0$   | $1$   | $0$   | $0$   | $1$   | $1$   | $0$   |\n\n最后一步是找到一个覆盖所有8个故障的最小测试向量集。这是一个集合覆盖问题。我们寻求最小的行子集，使得每一列至少有一个 '1'。\n\n1.  **识别必要向量**：必要向量是指能够检测到其他任何向量都无法检测到的故障的向量。\n    - 检查故障 $C$ 固定为0 所在的列，我们看到它只能被向量 $T_3=(1,1)$ 检测到。因此，$T_3$ 是一个必要测试向量，必须包含在最小集中。\n\n2.  **覆盖剩余故障**：测试向量 $T_3$ 检测了故障集 {$A$ 固定为0, $B$ 固定为0, $S$ 固定为1, $C$ 固定为0}。\n    剩余待检测的故障是 {$A$ 固定为1, $B$ 固定为1, $S$ 固定为0, $C$ 固定为1}。\n\n3.  **选择额外向量**：我们必须向当前的测试集 $\\{T_3\\}$ 中添加向量来覆盖这些剩余的故障。让我们看看再增加一个向量是否足够。\n    - $T_0$ 覆盖了 {$A$ 固定为1, $B$ 固定为1, $S$ 固定为1, $C$ 固定为1}。它未覆盖 $S$ 固定为0。\n    - $T_1$ 覆盖了 {$A$ 固定为1, $B$ 固定为0, $S$ 固定为0, $C$ 固定为1}。它未覆盖 $B$ 固定为1。\n    - $T_2$ 覆盖了 {$A$ 固定为0, $B$ 固定为1, $S$ 固定为0, $C$ 固定为1}。它未覆盖 $A$ 固定为1。\n    由于没有单个额外向量可以覆盖所有剩余故障，因此大小为2的测试集是不可能的。最小大小必须至少为3。\n\n4.  **构建大小为3的集合**：让我们构建一个大小为3的集合。我们从必要向量 $T_3$ 开始。\n    - 测试集：$\\{T_3\\}$。剩余故障：{$A$ 固定为1, $B$ 固定为1, $S$ 固定为0, $C$ 固定为1}。\n    - 让我们添加 $T_1$。$T_1$ 覆盖了 {$A$ 固定为1, $S$ 固定为0, $C$ 固定为1}。\n    - 测试集：$\\{T_3, T_1\\}$。剩余故障：{$B$ 固定为1}。\n    - 为了覆盖 $B$ 固定为1，我们可以添加 $T_0$ 或 $T_2$。我们选择 $T_2$。\n    - 最终的测试集是 $\\{T_1, T_2, T_3\\}$，对应于输入向量 $\\{(0,1), (1,0), (1,1)\\}$。让我们验证这个集合是否覆盖了所有故障。\n      - $A$ 固定为0：被 $T_2, T_3$ 覆盖。\n      - $A$ 固定为1：被 $T_1$ 覆盖。\n      - $B$ 固定为0：被 $T_1, T_3$ 覆盖。\n      - $B$ 固定为1：被 $T_2$ 覆盖。\n      - $S$ 固定为0：被 $T_1, T_2$ 覆盖。\n      - $S$ 固定为1：被 $T_3$ 覆盖。\n      - $C$ 固定为0：被 $T_3$ 覆盖。\n      - $C$ 固定为1：被 $T_1, T_2$ 覆盖。\n    所有8个故障都被集合 $\\{(0,1), (1,0), (1,1)\\}$ 检测到。\n\n由于大小为2的测试集不足，而大小为3的测试集是足够的，因此实现完全故障检测所需的不同测试向量的最小数量是3。", "answer": "$$\n\\boxed{3}\n$$", "id": "3645151"}]}