{"hands_on_practices": [{"introduction": "本练习将引导您量化使用先进乘法算法所带来的硬件节省。通过推导一种计算基本构建模块——$3:2$压缩器——数量的方法，您将直接比较简单阵列乘法器与更高效的布斯编码乘法器的硬件成本。这个过程将揭示算法优化在硬件设计中的实际效益 [@problem_id:3652024]。", "problem": "考虑在位级实现的无符号整数乘法。一个$3:2$压缩器（功能上等同于一个全加器）接收三个权重相同的单比特输入$2^{i}$，并产生两个单比特输出：一个位于权重$2^{i}$的和位，以及一个位于权重$2^{i+1}$的进位位。一个位堆由其列高轮廓$\\{H_{i}\\}$描述，其中$H_{i}$是在进行任何压缩之前，第$i$列（权重$2^{i}$）中最初存在的单比特信号的数量。Wallace 风格列压缩的目标是仅使用$3:2$压缩器将每一列都归约到至多两个比特，同时进位会传播到更高权重的列。\n\n从位加法和$3:2$压缩的核心定义出发，推导一个公式，该公式对于一个通用的列高轮廓$\\{H_{i}\\}$，能给出在每一列（以及总共）将每一列归约到至多两个比特所需的最少$3:2$压缩器数量。你的推导必须考虑到由低权重列的压缩产生并进入高权重列的进位。\n\n然后将你的公式应用于以下两种科学上真实的$8$比特乘以$8$比特乘法的列高轮廓：\n\n- 阵列乘法器（教科书式部分积）：对于$i = 0,1,\\dots,14$，\n$$\nH_{i}^{\\text{array}} = \n\\begin{cases}\ni+1,  0 \\leq i \\leq 7, \\\\\n15 - i,  8 \\leq i \\leq 14,\n\\end{cases}\n$$\n具体表示为\n$$\n\\{H_{i}^{\\text{array}}\\}_{i=0}^{14} = \\{1,2,3,4,5,6,7,8,7,6,5,4,3,2,1\\}.\n$$\n\n- 基数-$4$ Booth 编码（不存在符号校正位，四个部分积行分别移位$0,2,4,6$）：对于$i = 0,1,\\dots,14$，其轮廓为\n$$\n\\{H_{i}^{\\text{Booth}}\\}_{i=0}^{14} = \\{1,1,2,2,3,3,4,4,3,3,2,2,1,1,0\\}.\n$$\n\n计算每种轮廓所需的最少$3:2$压缩器数量，并报告其差值（阵列乘法器减去 Booth 编码）作为一个实数值。不需要四舍五入。你的最终答案应表示为一个不带单位的纯数字。", "solution": "问题要求推导一个计算归约位堆所需的$3:2$压缩器数量的公式，然后将该公式应用于两个具体示例。\n\n### 第 1 部分：通用公式的推导\n\n$3:2$压缩器，也称为全加器，是并行乘法器中的一个基本组件。它接收三个具有相同算术权重（例如$2^i$）的单比特输入，并产生两个单比特输出：一个权重为$2^i$的和位，以及一个权重为$2^{i+1}$的进位位。此操作可表示为：第$i$列的$3$个比特 $\\rightarrow$ 第$i$列的$1$个比特和第$i+1$列的$1$个比特。\n\n让我们分析对一个初始高度为$h$比特的单列$i$的归约过程。目标是使用$3:2$压缩器将此高度归约到至多为$2$。每个压缩器使当前列中的比特数减少$3-1 = 2$。这个归约过程可能需要多个阶段。\n\n设$h_0 = h$为该列的初始高度。\n在第一阶段的归约中，我们可以应用$k_1 = \\lfloor h_0/3 \\rfloor$个压缩器。这些压缩器消耗了该列的$3k_1$个比特。\n输出为：\n1. $k_1$个和位，保留在当前列$i$中。\n2. $k_1$个进位位，传递到下一个更高权重的列$i+1$。\n\n第$i$列中未被任何压缩器处理的比特数是$h_0 \\pmod 3$。\n因此，经过一阶段压缩后，第$i$列的新高度是产生的和位与未处理的比特之和：\n$$h_1 = k_1 + (h_0 \\pmod 3) = \\lfloor \\frac{h_0}{3} \\rfloor + (h_0 \\pmod 3)$$\n如果$h_1 > 2$，这组新的$h_1$个比特必须被进一步压缩。这个过程会重复进行。设$h_j$为第$j$阶段的列高。归约过程如下：\n$$h_{j+1} = \\lfloor \\frac{h_j}{3} \\rfloor + (h_j \\pmod 3)$$\n这个过程一直持续到某个阶段$m$，在该阶段$h_m \\le 2$。\n\n该列使用的压缩器总数是每个阶段使用的压缩器之和：$N_{\\text{comp}}(h) = \\sum_{j=0}^{m-1} k_{j+1} = \\sum_{j=0}^{m-1} \\lfloor h_j/3 \\rfloor$。\n同样，产生并传递到下一列的进位总数是$C_{\\text{out}}(h) = \\sum_{j=0}^{m-1} k_{j+1}$。\n因此，对于一个初始高度为$h$的单列，所需的压缩器数量$N_{\\text{comp}}(h)$等于它产生的进位数$C_{\\text{out}}(h)$。\n\n我们定义一个函数$f(h)$来表示这个量，$N_{\\text{comp}}(h) = C_{\\text{out}}(h)$。\n基于分阶段的归约，我们可以为$f(h)$写出一个递归公式：\n- 如果$h \\le 2$，则不需要压缩器，所以$f(h) = 0$。\n- 如果$h > 2$，我们在第一阶段使用$\\lfloor h/3 \\rfloor$个压缩器，问题简化为压缩一个高度为$h' = \\lfloor h/3 \\rfloor + (h \\pmod 3)$的列。所以，$f(h) = \\lfloor h/3 \\rfloor + f(\\lfloor h/3 \\rfloor + (h \\pmod 3))$。\n\n这个递归公式使我们能够计算任何给定列高的压缩器数量。\n\n现在，考虑一个通用的位堆轮廓$\\{H_i\\}$。由于进位的传播，各列的压缩不是独立的。该过程必须从最低有效列（$i=0$）开始顺序向上进行。\n\n设$N_i$为第$i$列使用的压缩器数量，设$C_i$为第$i$列产生并传递到第$i+1$列的进位数。如前所述，$N_i = C_i$。\n设$H_i$为问题陈述中给出的第$i$列的初始高度。\n设$H'_i$为压缩前第$i$列的总高度，它包括来自前一列的进位。\n我们从$C_{-1} = 0$开始。\n\n对于每一列$i=0, 1, 2, \\dots$：\n1. 需要压缩的总高度是$H'_i = H_i + C_{i-1}$。\n2. 该列所需的压缩器数量是$N_i = f(H'_i)$。\n3. 传递到下一列的进位数是$C_i = N_i$。\n\n这导出了每列$i$中压缩器数量$N_i$的以下递推关系：\n$$N_i = f(H_i + N_{i-1}), \\quad \\text{其中 } N_{-1}=0$$\n这里$f(h)$是之前定义的递归函数。整个位堆的$3:2$压缩器总数是所有列的总和：\n$$N_{\\text{total}} = \\sum_i N_i$$\n这就构成了通用的公式和步骤。\n\n### 第 2 部分：应用于特定轮廓\n\n首先，我们预先计算相关高度$h$的$f(h)$值。\n$f(0)=0, f(1)=0, f(2)=0$\n$f(3) = \\lfloor 3/3 \\rfloor + f(1) = 1+0=1$\n$f(4) = \\lfloor 4/3 \\rfloor + f(2) = 1+0=1$\n$f(5) = \\lfloor 5/3 \\rfloor + f(3) = 1+1=2$\n$f(6) = \\lfloor 6/3 \\rfloor + f(2) = 2+0=2$\n$f(7) = \\lfloor 7/3 \\rfloor + f(3) = 2+1=3$\n$f(8) = \\lfloor 8/3 \\rfloor + f(4) = 2+1=3$\n$f(9) = \\lfloor 9/3 \\rfloor + f(3) = 3+1=4$\n$f(10) = \\lfloor 10/3 \\rfloor + f(4) = 3+1=4$\n$f(11) = \\lfloor 11/3 \\rfloor + f(5) = 3+2=5$\n$f(12) = \\lfloor 12/3 \\rfloor + f(4) = 4+1=5$\n$f(13) = \\lfloor 13/3 \\rfloor + f(5) = 4+2=6$\n\n**轮廓 1：阵列乘法器**\n初始轮廓为$\\{H_{i}^{\\text{array}}\\}_{i=0}^{14} = \\{1,2,3,4,5,6,7,8,7,6,5,4,3,2,1\\}$。\n我们计算$N_i^{\\text{array}} = C_i^{\\text{array}} = f(H_i^{\\text{array}} + C_{i-1}^{\\text{array}})$，其中$C_{-1}^{\\text{array}} = 0$。\n\n$i=0: H'_0 = 1+0=1 \\implies N_0^{\\text{array}} = f(1)=0$。$C_0=0$。\n$i=1: H'_1 = 2+0=2 \\implies N_1^{\\text{array}} = f(2)=0$。$C_1=0$。\n$i=2: H'_2 = 3+0=3 \\implies N_2^{\\text{array}} = f(3)=1$。$C_2=1$。\n$i=3: H'_3 = 4+1=5 \\implies N_3^{\\text{array}} = f(5)=2$。$C_3=2$。\n$i=4: H'_4 = 5+2=7 \\implies N_4^{\\text{array}} = f(7)=3$。$C_4=3$。\n$i=5: H'_5 = 6+3=9 \\implies N_5^{\\text{array}} = f(9)=4$。$C_5=4$。\n$i=6: H'_6 = 7+4=11 \\implies N_6^{\\text{array}} = f(11)=5$。$C_6=5$。\n$i=7: H'_7 = 8+5=13 \\implies N_7^{\\text{array}} = f(13)=6$。$C_7=6$。\n$i=8: H'_8 = 7+6=13 \\implies N_8^{\\text{array}} = f(13)=6$。$C_8=6$。\n$i=9: H'_9 = 6+6=12 \\implies N_9^{\\text{array}} = f(12)=5$。$C_9=5$。\n$i=10: H'_{10} = 5+5=10 \\implies N_{10}^{\\text{array}} = f(10)=4$。$C_{10}=4$。\n$i=11: H'_{11} = 4+4=8 \\implies N_{11}^{\\text{array}} = f(8)=3$。$C_{11}=3$。\n$i=12: H'_{12} = 3+3=6 \\implies N_{12}^{\\text{array}} = f(6)=2$。$C_{12}=2$。\n$i=13: H'_{13} = 2+2=4 \\implies N_{13}^{\\text{array}} = f(4)=1$。$C_{13}=1$。\n$i=14: H'_{14} = 1+1=2 \\implies N_{14}^{\\text{array}} = f(2)=0$。$C_{14}=0$。\n\n阵列乘法器的压缩器总数：\n$$N_{\\text{total}}^{\\text{array}} = 0+0+1+2+3+4+5+6+6+5+4+3+2+1+0 = 42$$\n\n**轮廓 2：基数-4 Booth 编码**\n初始轮廓为$\\{H_{i}^{\\text{Booth}}\\}_{i=0}^{14} = \\{1,1,2,2,3,3,4,4,3,3,2,2,1,1,0\\}$。\n我们计算$N_i^{\\text{Booth}} = C_i^{\\text{Booth}} = f(H_i^{\\text{Booth}} + C_{i-1}^{\\text{Booth}})$，其中$C_{-1}^{\\text{Booth}} = 0$。\n\n$i=0: H'_0 = 1+0=1 \\implies N_0^{\\text{Booth}} = f(1)=0$。$C_0=0$。\n$i=1: H'_1 = 1+0=1 \\implies N_1^{\\text{Booth}} = f(1)=0$。$C_1=0$。\n$i=2: H'_2 = 2+0=2 \\implies N_2^{\\text{Booth}} = f(2)=0$。$C_2=0$。\n$i=3: H'_3 = 2+0=2 \\implies N_3^{\\text{Booth}} = f(2)=0$。$C_3=0$。\n$i=4: H'_4 = 3+0=3 \\implies N_4^{\\text{Booth}} = f(3)=1$。$C_4=1$。\n$i=5: H'_5 = 3+1=4 \\implies N_5^{\\text{Booth}} = f(4)=1$。$C_5=1$。\n$i=6: H'_6 = 4+1=5 \\implies N_6^{\\text{Booth}} = f(5)=2$。$C_6=2$。\n$i=7: H'_7 = 4+2=6 \\implies N_7^{\\text{Booth}} = f(6)=2$。$C_7=2$。\n$i=8: H'_8 = 3+2=5 \\implies N_8^{\\text{Booth}} = f(5)=2$。$C_8=2$。\n$i=9: H'_9 = 3+2=5 \\implies N_9^{\\text{Booth}} = f(5)=2$。$C_9=2$。\n$i=10: H'_{10} = 2+2=4 \\implies N_{10}^{\\text{Booth}} = f(4)=1$。$C_{10}=1$。\n$i=11: H'_{11} = 2+1=3 \\implies N_{11}^{\\text{Booth}} = f(3)=1$。$C_{11}=1$。\n$i=12: H'_{12} = 1+1=2 \\implies N_{12}^{\\text{Booth}} = f(2)=0$。$C_{12}=0$。\n$i=13: H'_{13} = 1+0=1 \\implies N_{13}^{\\text{Booth}} = f(1)=0$。$C_{13}=0$。\n$i=14: H'_{14} = 0+0=0 \\implies N_{14}^{\\text{Booth}} = f(0)=0$。$C_{14}=0$。\n\nBooth 编码乘法器的压缩器总数：\n$$N_{\\text{total}}^{\\text{Booth}} = 0+0+0+0+1+1+2+2+2+2+1+1+0+0+0 = 12$$\n\n### 第 3 部分：最终计算\n\n问题要求计算压缩器数量的差值，即：\n$$N_{\\text{total}}^{\\text{array}} - N_{\\text{total}}^{\\text{Booth}} = 42 - 12 = 30$$\n对于这个$8$比特乘以$8$比特的案例，Booth 编码乘法器比阵列乘法器少用$30$个$3:2$压缩器。这说明了 Booth 算法的一个主要优点：它减少了部分积的数量，从而得到一个更小、更快的归约树。", "answer": "$$\\boxed{30}$$", "id": "3652024"}, {"introduction": "在了解了布斯算法可以减少硬件之后，本练习将探讨其有效性背后的“原因”。您将分析乘数操作数中的不同位模式如何影响操作数量，从而确定最佳和最坏情况。这项练习旨在巩固您对布斯编码如何通过利用操作数表示中的冗余来提高效率的概念性理解 [@problem_id:3652101]。", "problem": "考虑使用带符号的基4布斯重编码，将一个固定宽度的$n$位二补码乘数$Q$与一个$n$位二补码被乘数$M$相乘。设$Q$的位为$q_{n-1}\\dots q_{1}q_{0}$，其中$q_{k}\\in\\{0,1\\}$，并定义一个辅助位$q_{-1}=0$。在基4布斯重编码中，乘数$Q$被重写为带符号的基4数位$d_{i}\\in\\{-2,-1,0,+1,+2\\}$的和，其位权为$4^{i}$，这些数位由重叠的三元位组$\\left(q_{2i+1},q_{2i},q_{2i-1}\\right)$（其中$i=0,1,\\dots$）形成，因此部分积为$d_{i}\\cdot M\\cdot 4^{i}$，非零部分积的数量等于$d_{i}\\neq 0$的索引$i$的个数。布斯重编码的目的是通过对$Q$中连续的相同位进行编码，来减少非零部分积的数量。\n\n以下关于$Q$的位模式及其在带符号的基4布斯重编码下产生的非零部分积数量的陈述中，哪些是正确的？\n\nA. 对于$Q=00\\cdots 0$（所有位均为$0$），非零部分积的数量为$0$。对于$Q=11\\cdots 1$（所有位均为$1$，在二补码中表示$-1$），非零部分积的数量恰好为$1$，与$n$无关。\n\nB. 在所有$n$位模式中，交替的位模式如$Q=10\\,10\\,\\cdots$或$Q=01\\,01\\,\\cdots$会使非零部分积的数量最大化，且其数量等于$\\lceil n/2\\rceil$。\n\nC. 单个连续的1串，$Q=00\\cdots 0111\\cdots 100\\cdots 0$，会使非零部分积的数量最大化，因为每个三元位组必须重编码为$+2$或$-2$。\n\nD. 对于$n$位$Q$，在带符号的基4布斯重编码下，可能的最大非零部分积数量为$n$，当$Q$以$10\\,10\\,\\cdots$的形式交替时达到。\n\n选择所有正确的选项，并从二补码的位级解释以及带符号的基4布斯重编码的基本原理（将位分组为重叠的三元位组并消除连续串）出发，证明你的选择。", "solution": "问题描述了用于将两个$n$位二补码数（乘数$Q$和被乘数$M$）相乘的带符号基4布斯重编码算法。该算法的核心是将乘数$Q$重编码为一系列带符号数位$d_i \\in \\{-2, -1, 0, +1, +2\\}$。部分积的数量由这些数位的数量决定，即$k = \\lceil n/2 \\rceil$。*非零*部分积的数量是不等于0的数位$d_i$的个数。\n\n数位$d_i$是通过检查乘数$Q$中重叠的三元位组生成的。设$Q$由位$q_{n-1} \\dots q_1 q_0$表示。我们定义一个辅助位$q_{-1}=0$。对于二补码数，任何超出最高有效位的位，即对于$k \\ge n$的$q_k$，都假定为符号扩展，即对于$k \\ge n$，$q_k = q_{n-1}$。\n\n用于数位$d_i$的三元位组是$(q_{2i+1}, q_{2i}, q_{2i-1})$。数位$d_i$的值计算为$d_i = q_{2i-1} + q_{2i} - 2q_{2i+1}$。这提供了一个查找表：\n- $(0,0,0) \\implies d_i = 0+0-2(0) = 0$\n- $(0,0,1) \\implies d_i = 1+0-2(0) = +1$\n- $(0,1,0) \\implies d_i = 0+1-2(0) = +1$\n- $(0,1,1) \\implies d_i = 1+1-2(0) = +2$\n- $(1,0,0) \\implies d_i = 0+0-2(1) = -2$\n- $(1,0,1) \\implies d_i = 1+0-2(1) = -1$\n- $(1,1,0) \\implies d_i = 0+1-2(1) = -1$\n- $(1,1,1) \\implies d_i = 1+1-2(1) = 0$\n\n当且仅当对应的三元位组不是$(0,0,0)$或$(1,1,1)$时，才会产生非零部分积。\n\n让我们来评估每个陈述。\n\n**A. 对于$Q=00\\cdots 0$（所有位均为$0$），非零部分积的数量为$0$。对于$Q=11\\cdots 1$（所有位均为$1$，在二补码中表示$-1$），非零部分积的数量恰好为$1$，与$n$无关。**\n\n- **情况 1: $Q = 00\\cdots0$**\n如果$Q$的所有位都为$0$，则对于$0 \\le i  n$，$q_i=0$。由于$q_{-1}=0$，每个可能的三元位组$(q_{2i+1}, q_{2i}, q_{2i-1})$都将是$(0,0,0)$。根据查找表，此三元位组重编码为$d_i=0$。因此，所有数位$d_i$都为$0$，非零部分积的数量为$0$。该陈述的这部分是正确的。\n\n- **情况 2: $Q = 11\\cdots1$**\n对于任何字长$n \\ge 1$，此位模式在二补码表示中代表数字$-1$。这里，对于$0 \\le i  n$，$q_i=1$。我们还有$q_{-1}=0$。\n让我们分析数位$d_i$：\n- 对于$i=0$：三元位组为$(q_1, q_0, q_{-1})$。由于$q_1=1$, $q_0=1$以及$q_{-1}=0$，三元位组是$(1,1,0)$。这重编码为$d_0 = 0+1-2(1) = -1$。这是一个非零数位。\n- 对于$i > 0$且$2i+1  n$：三元位组为$(q_{2i+1}, q_{2i}, q_{2i-1})$。由于$2i-1 \\ge 1$，三元位组中的所有三个位都来自$Q$且等于$1$。三元位组是$(1,1,1)$。这重编码为$d_i = 1+1-2(1) = 0$。\n- 对于最后一个数位：这涉及到符号扩展位。数位的总数是$\\lceil n/2 \\rceil$。设$k = \\lceil n/2 \\rceil - 1$是最后一个数位的索引。其三元位组是$(q_{2k+1}, q_{2k}, q_{2k-1})$。位$q_{2k}$和$q_{2k-1}$是原始数字的一部分（或对于奇数$n$是最后一位），并且等于$1$。位$q_{2k+1}$是$q_{n-1}$的符号扩展。由于$q_{n-1}=1$，我们有$q_{2k+1}=1$。因此，最后一个三元位组也是$(1,1,1)$，重编码为$d_k=0$。\n因此，只有$d_0$非零。非零部分积的数量恰好为$1$。这对任何$n \\ge 1$都成立。$Q$的值被正确计算为$d_0 \\cdot 4^0 = -1 \\cdot 1 = -1$。\n整个陈述是正确的。\n\n对A的结论：**正确**。\n\n**B. 在所有$n$位模式中，交替的位模式如$Q=10\\,10\\,\\cdots$或$Q=01\\,01\\,\\cdots$会使非零部分积的数量最大化，且其数量等于$\\lceil n/2\\rceil$。**\n\n重编码数位（因此也是部分积）的总数是$\\lceil n/2 \\rceil$。要最大化*非零*部分积的数量，我们需要为每个可能的$i$值都生成一个非零数位$d_i$。这意味着我们必须避免形成三元位组$(0,0,0)$和$(1,1,1)$。这些三元位组是由连续的相同位形成的。交替的位模式与连续的相同位是截然相反的。让我们来分析它们。\n\n- **情况 1: $Q$具有模式$0101\\cdots$（即$q_{2j}=1, q_{2j+1}=0$）。**\n- 对于$i=0$：三元位组是$(q_1, q_0, q_{-1}) = (0, 1, 0)$。这重编码为$d_0 = 0+1-2(0) = +1$。\n- 对于$i>0$：三元位组是$(q_{2i+1}, q_{2i}, q_{2i-1})$。$q_{2i+1}=0$（奇数索引），$q_{2i}=1$（偶数索引），$q_{2i-1}=0$（奇数索引）。三元位组是$(0,1,0)$，重编码为$d_i=+1$。只要这些位在$Q$的范围内，这就成立。\n- 对于最后一个数位（如果$n$是奇数，$n=2k+1$）：$Q$以$q_{n-1}=q_{2k}=1$结尾。我们需要三元位组$(q_{2k+1}, q_{2k}, q_{2k-1})$。问题陈述说$Q=0101...$。这意味着$q_0=1, q_1=0, q_2=1, ...$。所以$q_{2j}=1$而$q_{2j+1}=0$。\n  - $i=0$：$(q_1, q_0, q_{-1}) = (0,1,0) \\implies d_0=+1$。\n  - $i>0$：$(q_{2i+1}, q_{2i}, q_{2i-1}) = (0,1,0) \\implies d_i=+1$。只要$2i+1  n$，这就有效。\n  - 符号扩展：如果$n$是偶数（$n=2k$），$q_{n-1}=q_{2k-1}=0$。最后一个三元位组的索引$i=k-1$涉及到的位最多到$q_{2k-1}=q_{n-1}$，因此不需要符号扩展。所有数位都是$+1$。\n  - 如果$n$是奇数（$n=2k+1$），$q_{n-1}=q_{2k}=1$。最后一个三元位组的索引是$i=k$。我们使用$(q_{2k+1}, q_{2k}, q_{2k-1})$。$q_{2k}=1, q_{2k-1}=0$。符号位是$q_{n-1}=1$，所以其扩展是$q_{2k+1}=1$。三元位组是$(1,1,0)$，得到$d_k=-1$。仍然非零。\n在所有情况下，对于模式$0101\\cdots$，每个重编码的数位$d_i$都是非零的。\n\n- **情况 2: $Q$具有模式$1010\\cdots$（即$q_{2j}=0, q_{2j+1}=1$）。**\n- 对于$i=0$：三元位组是$(q_1, q_0, q_{-1}) = (1, 0, 0)$。这重编码为$d_0 = 0+0-2(1)=-2$。\n- 对于$i>0$：三元位组是$(q_{2i+1}, q_{2i}, q_{2i-1}) = (1, 0, 1)$。这重编码为$d_i = 1+0-2(1)=-1$。\n- 符号扩展：如果$n$是奇数（$n=2k+1$），$q_{n-1}=q_{2k}=0$。最后一个三元位组是$(q_{2k+1}, q_{2k}, q_{2k-1})=(0,0,1)$，得到$d_k=+1$。\n在所有情况下，对于模式$1010\\cdots$，每个重编码的数位$d_i$都是非零的。\n\n由于交替的位模式确保了没有一个三元位组是$(0,0,0)$或$(1,1,1)$，所以$\\lceil n/2 \\rceil$个位中的每一个都是非零的。这是可能的最大数量。\n\n对B的结论：**正确**。\n\n**C. 单个连续的1串，$Q=00\\cdots 0111\\cdots 100\\cdots 0$，会使非零部分积的数量最大化，因为每个三元位组必须重编码为$+2$或$-2$。**\n\n这个陈述与布斯算法的根本目的相悖，该算法旨在高效处理长串的相同位。\n让我们考虑一个只有一串连续$1$的数字，例如$Q=...0011...1100...$。\n- 在全为$0$的区域，所有三元位组都是$(0,0,0)$，得到$d_i=0$。\n- 在连续$1$串的内部，所有三元位组都是$(1,1,1)$，得到$d_i=0$。\n- 非零数位只能在连续$1$串的边界处产生。\n- 在串的开始处（$0 \\to 1$转换）：一个三元位组将跨越这个边界。例如，在$...0011...$中，我们可能形成三元位组$(0,1,1)$，重编码为$d_i=+2$，或者$(0,0,1)$，重编码为$d_i=+1$。\n- 在串的结束处（$1 \\to 0$转换）：一个三元位组将跨越这个边界。例如，在$...1100...$中，我们可能形成三元位组$(1,0,0)$，重编码为$d_j=-2$，或者$(1,1,0)$，重编码为$d_j=-1$。\n一串连续的$1$最多会产生两个非零数位，一个在串开始附近，一个在串结束附近。对于较大的$n$，$2$远小于交替模式所能达到的最大值$\\lceil n/2 \\rceil$。因此，这种模式并不能最大化非零部分积的数量；反而使其最小化。\n此外，给出的理由“因为每个三元位组必须重编码为$+2$或$-2$”是错误的。如上所示，在边界处可以很容易地生成数位$+1$和$-1$。例如，如果$Q=...0001110...$，我们在串的开始处形成一个三元位组$(q_{2i+1}, q_{2i}, q_{2i-1})=(0,0,1)$，这将产生$d_i=+1$。\n该陈述在两个方面都是不正确的。\n\n对C的结论：**不正确**。\n\n**D. 对于$n$位$Q$，在带符号的基4布斯重编码下，可能的最大非零部分积数量为$n$，当$Q$以$10\\,10\\,\\cdots$的形式交替时达到。**\n\n基4方案将位分成对（有一个位的重叠）。对于一个$n$位的乘数，这将产生$\\lceil n/2 \\rceil$个组或数位。部分积的总数（无论是零还是非零）是$\\lceil n/2 \\rceil$。因此，*非零*部分积可能的最大数量不能超过这个值。\n该陈述声称最大值为$n$。对于任何$n > 2$，$n > \\lceil n/2 \\rceil$。例如，如果$n=8$，非零部分积的最大数量是$8/2 = 4$，而不是$8$。该陈述从根本上将重编码数位的数量与乘数中的位数混淆了。虽然模式$1010\\cdots$确实最大化了非零乘积的数量，但该最大值为$\\lceil n/2 \\rceil$，而不是$n$。\n\n对D的结论：**不正确**。\n\n最终结论：陈述A和B是正确的。", "answer": "$$\\boxed{AB}$$", "id": "3652101"}, {"introduction": "最后的这项练习将所有概念融入一个真实的工程挑战中：设计一个高速流水线乘法器。您需要将有关布斯编码和华莱士树的知识应用于现代时序分析，进行权衡以满足严苛的时钟频率目标。这项练习弥合了理论算法与高性能数字设计实践约束之间的差距 [@problem_id:3652039]。", "problem": "您正在设计一个有符号$N=64$位定宽整数乘法器，该乘法器使用基-$4$ Booth 重编码、一个由$3:2$压缩器组成的 Wallace 风格树，以及一个实现为并行前缀加法器的末级进位传播加法器 (CPA)。该乘法器将被深度流水线化，寄存器仅插入在与完整操作（Booth 重编码和部分积选择、归约树中的各个压缩器级以及 CPA 内部的前缀级）重合的阶段边界处。目标最大时钟频率为$f_{\\max}=2~\\mathrm{GHz}$。\n\n在一个成熟的纳米级互补金属氧化物半导体 (CMOS) 工艺库中，使用以下实际的标准单元时序模型：\n- 扇出为$4$的反相器延迟$t_{\\mathrm{FO4}}=35~\\mathrm{ps}$。\n- 双输入门$\\mathrm{AND2}$或$\\mathrm{OR2}$：$1.0\\,t_{\\mathrm{FO4}}$。\n- 双输入$\\mathrm{XOR2}$：$2.0\\,t_{\\mathrm{FO4}}$。\n- 二选一多路复用器$\\mathrm{MUX2}$：$2.0\\,t_{\\mathrm{FO4}}$。\n- 一个基于全加器的$3:2$压缩器级的延迟（和/进位），包括局部互连：$2.6\\,t_{\\mathrm{FO4}}$。\n- 每个流水线级的寄存器（触发器）时序开销，包括 clock-to-$Q$ 延迟、建立时间和局部时钟偏斜：$t_{\\mathrm{reg}}=80~\\mathrm{ps}$。\n\n架构假设：\n- 对$64$位乘数操作数应用基-$4$ Booth 重编码，产生$M=\\lceil N/2\\rceil$行部分积，通过布线移位对齐。每比特的 Booth 重编码器和部分积选择网络由一个解码器和一个小型多路复用器网络实现，该网络从$\\{0,\\pm X,\\pm 2X\\}$中进行选择，其中$X$是被乘数。将整个重编码和部分积生成模块的端到端延迟建模为$D_{\\mathrm{BR}}=7\\,t_{\\mathrm{FO4}}$。\n- 部分积通过一个由$3:2$压缩器和偶尔使用的$2:2$压缩器组成的 Wallace 树进行归约，直到只剩下两行。将每级的行数减少建模为大约$3/2$的因子，并通过迭代行数减少来计算将$M$行减少到$2$行所需的压缩器级数$L$。\n- CPA 是一个 Kogge–Stone 并行前缀加法器，具有$\\lceil \\log_{2}(N)\\rceil$个前缀级。将每个前缀级建模为$2.0\\,t_{\\mathrm{FO4}}$，预计算生成/传播信号的形成建模为$1.0\\,t_{\\mathrm{FO4}}$，最终的和$\\mathrm{XOR}$建模为$2.0\\,t_{\\mathrm{FO4}}$。忽略给定每级延迟之外的长线延迟惩罚。\n\n基本时序规则：每级的时钟周期必须满足$T_{\\mathrm{clk}} \\ge t_{\\mathrm{reg}} + t_{\\mathrm{logic}}$，其中$t_{\\mathrm{logic}}$是该级内的最差情况组合逻辑延迟。目标周期为$T_{\\mathrm{clk}}=1/f_{\\max}$。\n\n任务：\n- 确定为满足$f_{\\max}=2~\\mathrm{GHz}$所需的最少总流水线级数。\n- 在您的推理中，明确计算 Wallace 树的$L$，并论证在时序约束下，可以将多少个压缩器级组合到一个流水线级中。同时，论证 CPA 内部需要多少个流水线级。\n- 您必须分配哪些级用于 Booth 重编码和部分积选择，哪些用于压缩器级，哪些用于 CPA，并确保每个级都满足时序约束。\n\n将您的最终答案表示为等于最小流水线级数的单个整数。无需四舍五入。最终答案中不要包含任何单位。", "solution": "该问题要求确定一个$64$位有符号整数乘法器在最大时钟频率$f_{\\max}=2~\\mathrm{GHz}$下运行所需的最小流水线级数。该设计包括三个主要部分：Booth 重编码和部分积生成、用于部分积归约的 Wallace 树，以及用于最终求和的 Kogge-Stone 加法器。解决方案涉及计算每个部分的延迟，并将其划分为流水线级，以确保任何级中的组合逻辑延迟不超过允许的最大值。\n\n首先，我们确定基本的时序约束。目标最大时钟频率为$f_{\\max}=2~\\mathrm{GHz}$，对应的最小始终周期为：\n$$T_{\\mathrm{clk}} = \\frac{1}{f_{\\max}} = \\frac{1}{2 \\times 10^9~\\mathrm{Hz}} = 0.5~\\mathrm{ns} = 500~\\mathrm{ps}$$\n每个流水线级的时序规则由$T_{\\mathrm{clk}} \\ge t_{\\mathrm{reg}} + t_{\\mathrm{logic}}$给出。流水线寄存器开销为$t_{\\mathrm{reg}}=80~\\mathrm{ps}$。因此，任何单个流水线级内允许的最大组合逻辑延迟为：\n$$t_{\\mathrm{logic,max}} = T_{\\mathrm{clk}} - t_{\\mathrm{reg}} = 500~\\mathrm{ps} - 80~\\mathrm{ps} = 420~\\mathrm{ps}$$\n问题提供了一个基于扇出为$4$的反相器延迟$t_{\\mathrm{FO4}} = 35~\\mathrm{ps}$的标准单元时序模型。我们可以用这个单位来表示最大逻辑延迟：\n$$t_{\\mathrm{logic,max}} = \\frac{420~\\mathrm{ps}}{35~\\mathrm{ps}/t_{\\mathrm{FO4}}} = 12~t_{\\mathrm{FO4}}$$\n\n现在，我们分析乘法器设计的每个部分，以确定所需的级数。\n\n1. Booth 重编码与部分积生成\n问题指出，基-$4$ Booth 重编码器和部分积选择网络的端到端延迟建模为$D_{\\mathrm{BR}} = 7~t_{\\mathrm{FO4}}$。以绝对时间计算，该延迟为：\n$$D_{\\mathrm{BR}} = 7 \\times 35~\\mathrm{ps} = 245~\\mathrm{ps}$$\n由于此延迟小于最大允许逻辑延迟（$245~\\mathrm{ps}  420~\\mathrm{ps}$），整个模块可以在一个流水线级内实现。\nBooth 重编码所需的级数 = $1$。\n\n2. Wallace 树归约\n乘数操作数的位宽为$N=64$位。采用基-$4$ Booth 重编码后，需要求和的部分积数量为$M = \\lceil N/2 \\rceil = \\lceil 64/2 \\rceil = 32$。Wallace 树使用$3:2$压缩器将这$32$行归约为$2$行。我们必须计算此归约所需的压缩器级数$L$。设$H_k$为第$k$级之后的行数，其中$H_0=32$。每级的行数根据公式$H_{k+1} = 2 \\cdot \\lfloor H_k/3 \\rfloor + (H_k \\pmod 3)$进行减少。\n- $H_0 = 32$\n- $H_1 = 2 \\cdot \\lfloor 32/3 \\rfloor + (32 \\pmod 3) = 2 \\cdot 10 + 2 = 22$\n- $H_2 = 2 \\cdot \\lfloor 22/3 \\rfloor + (22 \\pmod 3) = 2 \\cdot 7 + 1 = 15$\n- $H_3 = 2 \\cdot \\lfloor 15/3 \\rfloor + (15 \\pmod 3) = 2 \\cdot 5 + 0 = 10$\n- $H_4 = 2 \\cdot \\lfloor 10/3 \\rfloor + (10 \\pmod 3) = 2 \\cdot 3 + 1 = 7$\n- $H_5 = 2 \\cdot \\lfloor 7/3 \\rfloor + (7 \\pmod 3) = 2 \\cdot 2 + 1 = 5$\n- $H_6 = 2 \\cdot \\lfloor 5/3 \\rfloor + (5 \\pmod 3) = 2 \\cdot 1 + 2 = 4$\n- $H_7 = 2 \\cdot \\lfloor 4/3 \\rfloor + (4 \\pmod 3) = 2 \\cdot 1 + 1 = 3$\n- $H_8 = 2 \\cdot \\lfloor 3/3 \\rfloor + (3 \\pmod 3) = 2 \\cdot 1 + 0 = 2$\n此归约需要$L=8$级压缩器。\n\n单个$3:2$压缩器级的延迟为$t_{\\mathrm{comp}} = 2.6~t_{\\mathrm{FO4}}$。以绝对时间计算：\n$$t_{\\mathrm{comp}} = 2.6 \\times 35~\\mathrm{ps} = 91~\\mathrm{ps}$$\n为最小化流水线级数，我们将尽可能多的压缩器级组合到单个级中。每流水线级可容纳的最大层数为：\n$$\\text{每流水线级可容纳的层数} = \\left\\lfloor \\frac{t_{\\mathrm{logic,max}}}{t_{\\mathrm{comp}}} \\right\\rfloor = \\left\\lfloor \\frac{420~\\mathrm{ps}}{91~\\mathrm{ps}} \\right\\rfloor = \\lfloor 4.615... \\rfloor = 4$$\n总共有$L=8$级，每级最多$4$级，因此 Wallace 树所需的最小级数为：\n$$\\text{Wallace 树所需级数} = \\left\\lceil \\frac{L}{4} \\right\\rceil = \\left\\lceil \\frac{8}{4} \\right\\rceil = 2$$\n这两个级将分别包含压缩器树的第$1-4$级和第$5-8$级。每个级的延迟为$4 \\times 91~\\mathrm{ps} = 364~\\mathrm{ps}$，在$420~\\mathrm{ps}$的预算之内。\n\n3. 末级进位传播加法器 (CPA)\n末级加法器是一个$64$位 Kogge-Stone 并行前缀加法器。其操作可分解为具有指定延迟的三个逻辑部分：\n- 预计算生成/传播信号：$t_{\\mathrm{pre}} = 1.0~t_{\\mathrm{FO4}} = 35~\\mathrm{ps}$。\n- 前缀树计算：对于$N=64$，级数为$\\lceil \\log_{2}(N) \\rceil = \\lceil \\log_{2}(64) \\rceil = 6$。每级延迟为$t_{\\mathrm{prefix}} = 2.0~t_{\\mathrm{FO4}} = 70~\\mathrm{ps}$。\n- 最终和异或：$t_{\\mathrm{sum}} = 2.0~t_{\\mathrm{FO4}} = 70~\\mathrm{ps}$。\n\n问题允许在这些不同的操作（预计算、每个前缀级、最终求和）之间插入流水线寄存器。我们必须将这些操作组合成最少的级数。我们采用贪心法来填满每个级的延迟预算。\n- CPA-1 级：从预计算（$35~\\mathrm{ps}$）开始。我们可以添加前缀级。\n  - 包含$k$个前缀级的延迟：$t_{\\mathrm{pre}} + k \\cdot t_{\\mathrm{prefix}} = 35 + k \\cdot 70$。\n  - 当$k=5$时，延迟为$35 + 5 \\cdot 70 = 35 + 350 = 385~\\mathrm{ps}$。这$\\le 420~\\mathrm{ps}$。\n  - 当$k=6$时，延迟为$35 + 6 \\cdot 70 = 35 + 420 = 455~\\mathrm{ps}$，超过了预算。\n  - 因此，第一个 CPA 级可以包含预计算模块和$5$个前缀级。延迟为$385~\\mathrm{ps}$。\n- CPA-2 级：剩余的逻辑由$1$个前缀级和最终的和异或组成。\n  - 延迟为$t_{\\mathrm{prefix}} + t_{\\mathrm{sum}} = 70~\\mathrm{ps} + 70~\\mathrm{ps} = 140~\\mathrm{ps}$。\n  - 这完全在$420~\\mathrm{ps}$的预算之内。\n因此，CPA 最少需要$2$个流水线级。\n\n总流水线级数\n为了找到整个乘法器所需的最小总流水线级数，我们将每个部分所需的级数相加：\n$$N_{\\mathrm{stages}} = (\\text{Booth所需级数}) + (\\text{Wallace树所需级数}) + (\\text{CPA所需级数})$$\n$$N_{\\mathrm{stages}} = 1 + 2 + 2 = 5$$\n最终架构由$5$个流水线级组成：\n- 第$1$级：Booth 重编码和部分积生成（延迟$245~\\mathrm{ps}$）。\n- 第$2$级：Wallace 树压缩器第$1-4$级（延迟$364~\\mathrm{ps}$）。\n- 第$3$级：Wallace 树压缩器第$5-8$级（延迟$364~\\mathrm{ps}$）。\n- 第$4$级：CPA 预计算和前缀第$1-5$级（延迟$385~\\mathrm{ps}$）。\n- 第$5$级：CPA 前缀第$6$级和最终求和（延迟$140~\\mathrm{ps}$）。\n\n所有级都满足时序约束$t_{\\mathrm{logic}} \\le 420~\\mathrm{ps}$。因此，最小总流水线级数为$5$。", "answer": "$$\\boxed{5}$$", "id": "3652039"}]}