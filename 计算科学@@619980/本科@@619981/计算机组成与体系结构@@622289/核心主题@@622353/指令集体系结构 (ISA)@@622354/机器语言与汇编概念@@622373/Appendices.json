{"hands_on_practices": [{"introduction": "计算机指令本质上是二进制编码，不同的编码方式会直接影响程序的内存占用和执行效率。本练习将带你亲手体验现代指令集架构（如 RISC-V）如何通过压缩指令来优化代码密度，并分析这种变化对程序布局和分支跳转计算带来的影响。[@problem_id:3655278]", "problem": "一个精简指令集计算机第五版 (RISC-V) 的32位整数基础指令集 (RV32I) 程序需要进行编码，分别只使用基准的 RV32I $32$ 位指令和使用 RISC-V 压缩 (RVC) 扩展。RVC 扩展为某些特定情况引入了 $16$ 位的编码。代码从地址 $0x1000$ 开始，并按地址递增的顺序执行。\n\n给你以下指令语义和编码信息子集作为基本依据：\n\n- 基准 RV32I：\n  - 所有基准指令占用 $32$ 位，即每个指令 $4$ 字节。\n  - 程序计数器 (PC) 在每次取指后增加指令宽度。\n  - 以下指令的语义是标准的：\n    - $\\mathrm{ADDI}\\ r_d, r_s, i$：$r_d \\leftarrow r_s + i$。\n    - $\\mathrm{ADD}\\ r_d, r_s1, r_s2$：$r_d \\leftarrow r_{s1} + r_{s2}$。\n    - $\\mathrm{ANDI}\\ r_d, r_s, i$：$r_d \\leftarrow r_s \\,\\&\\, i$。\n    - $\\mathrm{ORI}\\ r_d, r_s, i$：$r_d \\leftarrow r_s \\,|\\, i$。\n    - $\\mathrm{LW}\\ r_d, u(r_s)$：$r_d \\leftarrow \\mathrm{MEM}[r_s + u]$，其中 $u$ 是一个字节偏移量。\n    - $\\mathrm{SW}\\ r_s2, u(r_s1)$：$\\mathrm{MEM}[r_{s1} + u] \\leftarrow r_{s2}$。\n    - $\\mathrm{BEQ}\\ r_s1, r_s2, \\mathrm{label}$：如果 $r_{s1} = r_{s2}$，则使用一个PC相对位移 $\\delta$ 跳转到 $\\mathrm{label}$，该位移计算公式为 $\\delta = \\mathrm{addr}(\\mathrm{label}) - (\\mathrm{PC} + 4)$；$\\delta$ 必须是架构范围内的2字节的有符号倍数，才能被编码。\n- 本问题中使用的 RISC-V 压缩 (RVC) $16$ 位形式（所有未提及的形式均不可用）：\n  - $\\mathrm{C.ADDI}\\ r_d, i$：当 $r_d \\neq x0$ 且 $i \\in \\{-32, -31, \\ldots, -1, 1, \\ldots, 31\\}$ 时可用；语义与 $\\mathrm{ADDI}\\ r_d, r_d, i$ 相同；宽度为 $16$ 位。\n  - $\\mathrm{C.ANDI}\\ r_d, i$：当 $r_d \\in \\{x8, x9, \\ldots, x15\\}$ 且 $i \\in \\{-32, -31, \\ldots, 31\\}$ 时可用；语义与 $\\mathrm{ANDI}\\ r_d, r_d, i$ 相同；宽度为 $16$ 位。\n  - $\\mathrm{C.LW}\\ r_d, u(r_s)$：当 $r_d, r_s \\in \\{x8, x9, \\ldots, x15\\}$ 且 $u$ 是一个无符号字节偏移量，是 $4$ 的倍数且在 $\\{0, 4, 8, \\ldots, 252\\}$ 范围内时可用；语义与 $\\mathrm{LW}$ 相同；宽度为 $16$ 位。\n  - $\\mathrm{C.SW}\\ r_s2, u(r_s1)$：当 $r_s2, r_s1 \\in \\{x8, x9, \\ldots, x15\\}$ 且 $u$ 是一个无符号字节偏移量，是 $4$ 的倍数且在 $\\{0, 4, 8, \\ldots, 252\\}$ 范围内时可用；语义与 $\\mathrm{SW}$ 相同；宽度为 $16$ 位。\n  - $\\mathrm{C.BEQZ}\\ r_s, \\mathrm{label}$：当 $r_s \\in \\{x8, x9, \\ldots, x15\\}$ 时可用；如果 $r_s = x0$ 则跳转，使用位移 $\\delta = \\mathrm{addr}(\\mathrm{label}) - (\\mathrm{PC} + 2)$，该位移必须是集合 $\\{-256, -254, \\ldots, -2, 0, 2, \\ldots, 254\\}$ 内2字节的有符号倍数；宽度为 $16$ 位。\n  - 此子集中没有 $\\mathrm{C.ORI}$；$\\mathrm{ORI}$ 保持为 $32$ 位。\n- 所有内存访问都是自然对齐且合法的；寄存器 $x0$ 硬连线到零；寄存器名称 $x0, x1, \\ldots, x31$ 指的是标准的 RISC-V 整数寄存器。\n- 这里所要求的执行等效性是指，将基准指令替换为其压缩形式（当可用时）会保留寄存器和内存的架构状态转换，并保留控制流目标。\n\n考虑以下 RV32I 汇编代码片段，其标签和基地址如下所示：\n- 基地址：$\\mathrm{addr}(\\mathrm{start}) = 0x1000$。\n- 代码：\n  1) $\\mathrm{ADDI}\\ x8, x8, 12$\n  2) $\\mathrm{LW}\\ x9, 16(x8)$\n  3) $\\mathrm{ADD}\\ x5, x6, x7$\n  4) $\\mathrm{SW}\\ x9, 20(x8)$\n  5) $\\mathrm{ORI}\\ x10, x10, 512$\n  6) $\\mathrm{BEQ}\\ x10, x0, \\mathrm{L1}$\n  7) $\\mathrm{ADDI}\\ x3, x3, 100$\n  8) $\\mathrm{L1}: \\mathrm{ANDI}\\ x12, x12, 31$\n\n任务：\n1) 对于每条指令，判断上面定义的 RVC $16$ 位形式是否适用，如果适用请指明其名称；否则，它将保持为 $32$ 位。\n2) 假设仅使用 RV32I（所有指令为 $32$ 位），计算每条指令的地址以及第 $6$ 行的 $\\mathrm{BEQ}$ 指令所使用的分支位移 $\\delta_{\\mathrm{RV32I}}$。\n3) 在任务 $1$ 中适用 RVC 的地方使用 RVC，计算混合宽度编码下每条指令的地址以及第 $6$ 行的 $\\mathrm{C.BEQZ}$ 指令（如果可压缩）所使用的分支位移 $\\delta_{\\mathrm{RVC}}$。\n4) 计算两种编码的总代码大小（以字节为单位）以及代码大小压缩率\n   $$R \\equiv \\frac{\\text{压缩后的总字节数}}{\\text{基准总字节数}}。$$\n   将 $R$ 表示为最简分数。不需要四舍五入。\n5) 简要说明，在所述约束条件下，压缩替换为何能保持此代码片段的执行等效性。\n\n你的最终答案必须仅为 $R$ 的值，以无单位的最简分数形式呈现，且不包含其他任何内容。", "solution": "该问题陈述已经过验证，被认为是合理的。这是一个计算机体系结构领域定义明确的问题，具体涉及 RISC-V 指令集。所提供的规则，尽管是完整规范的一个子集，并包含了分支位移计算的特定定义，但它们是自包含且一致的。\n\n解题过程将按问题陈述中列出的五个任务逐一进行。\n\n**任务1：RVC 适用性分析**\n\n我们分析所提供代码片段中的每一条指令，以根据给定规则确定它是否可以被替换为 $16$ 位的 RVC 等效指令。\n\n1.  $\\mathrm{ADDI}\\ x8, x8, 12$：此指令符合 $\\mathrm{ADDI}\\ r_d, r_d, i$ 的形式。目标寄存器为 $r_d = x8$，不等于 $x0$。立即数为 $i = 12$，在 $\\mathrm{C.ADDI}$ 允许的范围 $\\{-32, \\ldots, -1, 1, \\ldots, 31\\}$ 之内。因此，此指令可压缩为 $\\mathrm{C.ADDI}\\ x8, 12$。其宽度为 $16$ 位（$2$ 字节）。\n\n2.  $\\mathrm{LW}\\ x9, 16(x8)$：寄存器为 $r_d = x9$ 和 $r_s = x8$。两者都在 $\\mathrm{C.LW}$ 要求的集合 $\\{x8, x9, \\ldots, x15\\}$ 中。偏移量为 $u = 16$。这是一个无符号的 $4$ 的倍数，且在允许的范围 $\\{0, 4, \\ldots, 252\\}$ 内。因此，此指令可压缩为 $\\mathrm{C.LW}\\ x9, 16(x8)$。其宽度为 $16$ 位（$2$ 字节）。\n\n3.  $\\mathrm{ADD}\\ x5, x6, x7$：这是一个三操作数的寄存器-寄存器指令。问题没有为此形式提供 $16$ 位的 RVC 等效指令。因此，它仍是一条 $32$ 位（$4$ 字节）的基准指令。\n\n4.  $\\mathrm{SW}\\ x9, 20(x8)$：寄存器为 $r_{s2} = x9$ 和 $r_{s1} = x8$。两者都在 $\\mathrm{C.SW}$ 要求的集合 $\\{x8, x9, \\ldots, x15\\}$ 中。偏移量为 $u = 20$。这是一个无符号的 $4$ 的倍数，且在允许的范围 $\\{0, 4, \\ldots, 252\\}$ 内。因此，此指令可压缩为 $\\mathrm{C.SW}\\ x9, 20(x8)$。其宽度为 $16$ 位（$2$ 字节）。\n\n5.  $\\mathrm{ORI}\\ x10, x10, 512$：问题陈述明确指出“此子集中没有 $\\mathrm{C.ORI}$”。此外，立即数 $i=512$ 远超 RVC 指令典型的小立即数范围。此指令仍是一条 $32$ 位（$4$ 字节）的基准指令。\n\n6.  $\\mathrm{BEQ}\\ x10, x0, \\mathrm{L1}$：此指令在寄存器 $x10$ 等于寄存器 $x0$（硬连线为零）时跳转。这等同于在 $x10$ 为零时跳转。RVC 形式 $\\mathrm{C.BEQZ}\\ r_s, \\mathrm{label}$ 在 $r_s \\in \\{x8, \\ldots, x15\\}$ 时可用。此处，$r_s = x10$，满足该条件。压缩的有效性还取决于分支位移，我们稍后将进行分析，但指令形式是可压缩的。假设位移有效，其宽度为 $16$ 位（$2$ 字节）。\n\n7.  $\\mathrm{ADDI}\\ x3, x3, 100$：此指令符合可能压缩为 $\\mathrm{C.ADDI}$ 的形式。然而，立即数为 $i = 100$。该值不在允许的范围 $\\{-32, \\ldots, -1, 1, \\ldots, 31\\}$ 内。因此，此指令不可压缩，仍是一条 $32$ 位（$4$ 字节）的基准指令。\n\n8.  $\\mathrm{ANDI}\\ x12, x12, 31$：此指令的 $r_d = x12$，在 $\\mathrm{C.ANDI}$ 要求的集合 $\\{x8, \\ldots, x15\\}$ 中。立即数为 $i = 31$，在允许的范围 $\\{-32, \\ldots, 31\\}$ 内。因此，此指令可压缩为 $\\mathrm{C.ANDI}\\ x12, 31$。其宽度为 $16$ 位（$2$ 字节）。\n\n**任务2：仅使用基准 RV32I 指令的分析**\n\n假设所有 $8$ 条指令都是 $32$ 位（$4$ 字节）宽，我们可以从基地址 $0x1000$ 开始确定每条指令的地址。\n\n- 指令 1 ($\\mathrm{ADDI}$): 地址 $ = 0x1000$\n- 指令 2 ($\\mathrm{LW}$): 地址 $ = 0x1000 + 4 = 0x1004$\n- 指令 3 ($\\mathrm{ADD}$): 地址 $ = 0x1004 + 4 = 0x1008$\n- 指令 4 ($\\mathrm{SW}$): 地址 $ = 0x1008 + 4 = 0x100C$\n- 指令 5 ($\\mathrm{ORI}$): 地址 $ = 0x100C + 4 = 0x1010$\n- 指令 6 ($\\mathrm{BEQ}$): 地址 $ = 0x1010 + 4 = 0x1014$\n- 指令 7 ($\\mathrm{ADDI}$): 地址 $ = 0x1014 + 4 = 0x1018$\n- 指令 8 ($\\mathrm{L1}: \\mathrm{ANDI}$): 地址 $ = 0x1018 + 4 = 0x101C$\n\n代码总大小为 $8 \\times 4 = 32$ 字节。\n\n位于地址 $\\mathrm{PC} = 0x1014$ 的 $\\mathrm{BEQ}$ 指令的分支位移使用给定公式 $\\delta_{\\mathrm{RV32I}} = \\mathrm{addr}(\\mathrm{label}) - (\\mathrm{PC} + 4)$ 计算。目标标签 $\\mathrm{L1}$ 位于地址 $0x101C$。\n$$ \\delta_{\\mathrm{RV32I}} = 0x101C - (0x1014 + 4) = 0x101C - 0x1018 = 4 $$\n位移为 $4$ 字节，这是一个 $2$ 字节的有符号倍数，并且在 B 型指令的标准架构范围内。\n\n**任务3：使用 RVC 替换的分析**\n\n根据任务1的压缩性结果，我们确定新的指令地址。\n压缩后的大小分别为：$2, 2, 4, 2, 4, 2, 4, 2$ 字节。\n\n- 指令 1 ($\\mathrm{C.ADDI}$): 地址 $ = 0x1000$，大小 $ = 2$\n- 指令 2 ($\\mathrm{C.LW}$): 地址 $ = 0x1000 + 2 = 0x1002$，大小 $ = 2$\n- 指令 3 ($\\mathrm{ADD}$): 地址 $ = 0x1002 + 2 = 0x1004$，大小 $ = 4$\n- 指令 4 ($\\mathrm{C.SW}$): 地址 $ = 0x1004 + 4 = 0x1008$，大小 $ = 2$\n- 指令 5 ($\\mathrm{ORI}$): 地址 $ = 0x1008 + 2 = 0x100A$，大小 $ = 4$\n- 指令 6 ($\\mathrm{C.BEQZ}$): 地址 $ = 0x100A + 4 = 0x100E$，大小 $ = 2$\n- 指令 7 ($\\mathrm{ADDI}$): 地址 $ = 0x100E + 2 = 0x1010$，大小 $ = 4$\n- 指令 8 ($\\mathrm{L1}: \\mathrm{C.ANDI}$): 地址 $ = 0x1010 + 4 = 0x1014$，大小 $ = 2$\n\n压缩后代码的总大小为 $2+2+4+2+4+2+4+2 = 22$ 字节。\n\n位于地址 $\\mathrm{PC} = 0x100E$ 的 $\\mathrm{C.BEQZ}$ 指令的分支位移使用给定公式 $\\delta_{\\mathrm{RVC}} = \\mathrm{addr}(\\mathrm{label}) - (\\mathrm{PC} + 2)$ 计算。目标标签 $\\mathrm{L1}$ 现在位于地址 $0x1014$。\n$$ \\delta_{\\mathrm{RVC}} = 0x1014 - (0x100E + 2) = 0x1014 - 0x1010 = 4 $$\n位移为 $4$ 字节。该值是 $2$ 的有符号倍数，并且在为 $\\mathrm{C.BEQZ}$ 指定的集合 $\\{-256, \\dots, 254\\}$ 内。因此，该分支指令的压缩是有效的。\n\n**任务4：代码大小与压缩率**\n\n- 基准代码总大小（仅 RV32I）：$32$ 字节。\n- 压缩后代码总大小（使用 RVC）：$22$ 字节。\n\n代码大小压缩率 $R$ 定义为：\n$$ R = \\frac{\\text{压缩后的总字节数}}{\\text{基准总字节数}} = \\frac{22}{32} $$\n将分子和分母除以它们的最大公约数 $2$ 来化简此分数：\n$$ R = \\frac{11}{16} $$\n\n**任务5：执行等效性的论证**\n\n对于这个特定的代码片段，用 RVC 形式替换基准指令可以保持执行等效性。\n1.  **状态保持**：对于每条可压缩的指令（$\\mathrm{ADDI}$, $\\mathrm{LW}$, $\\mathrm{SW}$, $\\mathrm{ANDI}$），RVC 的语义被定义为与其 RV32I 对应指令相同，前提是满足对操作数（寄存器编号、立即数值）的特定约束。例如，$\\mathrm{C.ADDI}\\ r_d, i$ 在语义上与 $\\mathrm{ADDI}\\ r_d, r_d, i$ 完全相同。由于我们的分析确认所有约束都已满足，因此每个压缩指令对寄存器和/或内存执行的操作与原始 $32$ 位指令完全相同。\n2.  **控制流保持**：条件分支 $\\mathrm{BEQ}\\ x10, x0, \\mathrm{L1}$ 被替换为 $\\mathrm{C.BEQZ}\\ x10, \\mathrm{L1}$。两者都在且仅在寄存器 $x10$ 的内容为零时发生跳转。分支目标是标签 $\\mathrm{L1}$。尽管 $\\mathrm{L1}$ 的绝对地址在两种编码之间发生了变化（从 $0x101C$ 变为 $0x1014$），但分支指令使用的是 PC 相对寻址。我们计算了位移（$\\delta_{\\mathrm{RV32I}} = 4$ 和 $\\delta_{\\mathrm{RVC}} = 4$）并确认它们在各自的内存布局中正确地编码了从分支指令到目标指令的跳转。由于分支条件和逻辑目标相同，控制流得以保持。\n\n因此，两种程序编码的架构状态变化序列是相同的。", "answer": "$$\\boxed{\\frac{11}{16}}$$", "id": "3655278"}, {"introduction": "在了解了指令的内存布局后，我们可以进一步探索如何构建复杂的控制流结构，例如跳转表。本练习将指导你实现一个“地址无关”的跳转表的核心逻辑，这对于现代操作系统和共享库至关重要，你将学会如何通过相对偏移量、边界检查和对齐验证来确保代码无论加载到内存何处都能正确跳转。[@problem_id:3655275]", "problem": "要求您在一个通用编程语言中，形式化并实现机器语言和汇编中常见的与位置无关的跳转表的核心思想。其基本依据是程序计数器（PC）的定义，在典型的指令集架构（ISA）中，PC是一个按字节寻址的寄存器，指向当前待执行的指令。在一种由表驱动的控制转移机制中，一个由大小相等的连续代码条目组成的块可以作为跳转目标，通过索引进行选择。\n\n从以下基本定义出发：\n- 程序计数器 $PC$ 是一个字节地址。\n- 一个代码区域由一个基地址 $B$、每个条目以字节为单位的固定步长 $S$ 以及一个逻辑容量 $n$ 个条目来表征。\n- 索引必须在重定位下保持不变：如果代码区域和 $PC$ 都被一个位移 $\\delta$ 移动，计算出的索引必须保持不变。\n- 要求对齐和边界正确性：只有与声明的步长对齐且在逻辑容量范围内的条目才是有效的目标。\n- 允许稀疏性：某些逻辑索引可能故意没有分配处理程序。\n\n您的任务是根据这些定义，推导出一个标准化过程，该过程将 $PC$ 映射到表的逻辑索引 $i$，并包含所有必要的边界和对齐检查，以及对稀疏索引的妥善处理。然后，您必须将此过程实现在一个完整的、可运行的程序中，该程序在给定一小组参数集的测试套件下，计算出所选的处理程序标识符或一个明确定义的错误码。\n\n实现模型和正确性要求：\n- 将地址视为字节地址。使用非负整数作为处理程序标识符。使用负数处理程序标识符表示稀疏（缺失）的条目。\n- 每个测试用例的结果必须是一个整数：\n  - 当标准化索引有效且条目存在时，返回一个等于处理程序标识符的非负整数。\n  - 如果 $PC$ 超出由 $B$、$S$ 和 $n$ 指定的区域范围，返回 $-1$。\n  - 如果 $PC$ 在边界内但未与步长 $S$ 对齐，返回 $-2$。\n  - 如果标准化索引有效但条目是稀疏的（缺失），返回 $-3$。\n- 标准化必须是与位置无关的：对于任何位移 $\\delta$，如果 $B \\mapsto B + \\delta$ 且 $PC \\mapsto PC + \\delta$，计算出的索引 $i$ 必须完全相同。\n\n测试套件：\n为以下测试用例提供结果，每个用例由 $(B, S, n, PC, \\text{handlers}[0..n-1])$ 指定，其中地址为十六进制字面量，步长和容量为十进制。处理程序为十进制，任何负数处理程序表示缺失的条目。\n\n- 用例A（正常路径）：$(B = 0x1000, S = 8, n = 5, PC = 0x1000 + 2 \\cdot 8, \\text{handlers} = [10, 11, 12, 13, 14])$。\n- 用例B（下边界越界）：$(B = 0x1000, S = 8, n = 5, PC = 0x0, \\text{handlers} = [10, 11, 12, 13, 14])$。\n- 用例C（边界内未对齐）：$(B = 0x1000, S = 8, n = 5, PC = 0x1000 + 3 \\cdot 8 + 4, \\text{handlers} = [10, 11, 12, 13, 14])$。\n- 用例D（稀疏缺失条目）：$(B = 0x2000, S = 4, n = 6, PC = 0x2000 + 3 \\cdot 4, \\text{handlers} = [0, -1, 2, -1, 4, 5])$。\n- 用例E（重定位不变性）：$(B = 0x1000 + 0x300, S = 8, n = 5, PC = (0x1000 + 2 \\cdot 8) + 0x300, \\text{handlers} = [10, 11, 12, 13, 14])$。\n- 用例F（上边界包含）：$(B = 0x3000, S = 16, n = 4, PC = 0x3000 + 3 \\cdot 16, \\text{handlers} = [100, 101, 102, 103])$。\n- 用例G（结束边界不包含）：$(B = 0x3000, S = 16, n = 4, PC = 0x3000 + 4 \\cdot 16, \\text{handlers} = [100, 101, 102, 103])$。\n- 用例H（大步长）：$(B = 0x80000000, S = 512, n = 3, PC = 0x80000000 + 512, \\text{handlers} = [7, 8, 9])$。\n- 用例I（基址条目）：$(B = 0x5000, S = 32, n = 2, PC = 0x5000, \\text{handlers} = [42, 43])$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[\\text{result}_A,\\text{result}_B,\\dots]$）。不应打印任何其他文本。", "solution": "该问题定义明确，科学上基于计算机体系结构原理，并为推导和实现一个过程提供了完整的规范。它不包含任何矛盾或歧义。因此，该问题被认为是有效的。\n\n任务是形式化并实现一个过程，该过程将程序计数器地址 $PC$ 映射到一个与位置无关的跳转表的逻辑索引 $i$。该表由一个基地址 $B$、每个条目的固定大小步长 $S$ 以及总容量为 $n$ 个条目来定义。该过程必须执行所有必要的边界和对齐检查，并处理稀疏条目。\n\n标准化过程的推导从给定的要求逐步进行。\n\n1.  **重定位不变性**：基本约束是索引机制必须是位置无关的。这意味着如果整个代码段，包括跳转表和当前程序计数器，被某个位移 $\\delta$ 重定位，计算出的索引必须保持不变。设原始基地址为 $B$，程序计数器为 $PC$。重定位后，新地址为 $B' = B + \\delta$ 和 $PC' = PC + \\delta$。为了使索引保持不变，其计算必须仅依赖于 $PC$ 和 $B$ 之间的相对偏移量 $\\Delta = PC - B$。这是因为新的偏移量 $\\Delta' = PC' - B' = (PC + \\delta) - (B + \\delta) = PC - B = \\Delta$。因此，所有后续的检查和计算都必须基于这个相对偏移量 $\\Delta$。为计算目的，地址被视为非负无符号整数。\n\n2.  **边界检查**：跳转表由 $n$ 个条目组成，每个条目大小为 $S$ 字节。该表所占用的内存区域从地址 $B$ 开始，到地址 $B + n \\cdot S$ 之前结束。因此，表中任何目标的有效地址范围是 $[B, B + n \\cdot S)$。一个给定的程序计数器 $PC$ 处于此区域边界内的充分必要条件是满足 $B \\le PC  B + n \\cdot S$。这是要执行的第一个检查。如果 $PC$ 在此范围之外，则被视为越界。问题规定，在这种情况下，过程必须返回错误码 $-1$。\n\n3.  **对齐检查**：一个有效的跳转目标必须对应于表条目之一的起始位置。这些入口点的地址是 $B$, $B+S$, $B+2S$, ..., $B+(n-1)S$。这意味着 $PC$ 相对于基地址 $B$ 的偏移量 $\\Delta = PC - B$ 必须是步长 $S$ 的整数倍。这个属性被称为对齐。可以通过检查 $\\Delta$ 除以 $S$ 的余数是否为零来验证，即 $(PC - B) \\pmod S = 0$。此检查应对任何在边界内的 $PC$ 执行。如果一个在边界内的 $PC$ 未与步长 $S$ 对齐，过程必须返回错误码 $-2$。\n\n4.  **索引计算**：如果一个 $PC$ 同时通过了边界和对齐检查，它就指向一个有效的条目。该条目的逻辑索引 $i$ 对应于从基地址开始的偏移量中包含多少个大小为 $S$ 的步长。这通过整数除法计算：\n    $$i = \\frac{PC - B}{S}$$\n    鉴于边界检查 ($0 \\le PC - B  n \\cdot S$)，计算出的索引 $i$ 被保证在大小为 $n$ 的数组的有效范围内，即 $0 \\le i  n$。\n\n5.  **稀疏性处理**：问题允许“稀疏”表，其中某些逻辑索引可能没有对应的处理程序。这些稀疏条目在提供的 `handlers` 数组中用负值表示。在计算出有效索引 $i$ 后，过程必须从 `handlers`[$i$] 中检索处理程序标识符。如果该值为负（即 $\\text{handlers}[i]  0$），则表示这是一个稀疏条目。在这种情况下，过程必须返回错误码 $-3$。\n\n6.  **成功查找**：如果检索到的处理程序标识符是非负的（即 $\\text{handlers}[i] \\ge 0$），则查找成功。过程的最终结果就是这个非负的处理程序标识符。\n\n总而言之，对于给定的参数集 $(B, S, n, PC, \\text{handlers})$，完整的算法如下：\n1.  检查是否 $PC  B$ 或 $PC \\ge B + n \\cdot S$。如果为真，返回 $-1$。\n2.  计算偏移量 $\\Delta = PC - B$。\n3.  检查是否 $\\Delta \\pmod S \\neq 0$。如果为真，返回 $-2$。\n4.  计算索引 $i = \\Delta / S$。\n5.  检索处理程序标识符 $h = \\text{handlers}[i]$。\n6.  检查是否 $h  0$。如果为真，返回 $-3$。\n7.  否则，返回 $h$。", "answer": "[12,-1,-2,-3,12,103,-1,8,42]", "id": "3655275"}]}