{"hands_on_practices": [{"introduction": "指令集架构 (ISA) 设计的一个核心挑战是在有限的指令位宽内高效地编码信息。立即数字段（用于表示常数和偏移量）的设计尤为关键，因为它直接影响指令的功能和性能。本练习将引导你基于真实操作数分布的统计模型，来确定立即数字段的合适位宽，旨在平衡编码覆盖率和宝贵的指令空间。[@problem_id:3650299]", "problem": "一种精简指令集计算机 (RISC) 的指令集架构 (ISA) 使用二进制补码编码的符号扩展立即数。一条立即数加法指令有一个 $k_{\\text{add}}$ 位的立即数字段，该字段必须能编码一个范围在 $[-2^{k_{\\text{add}}-1},\\,2^{k_{\\text{add}}-1}-1]$ 内的有符号整数 $C$。一条条件分支指令有一个 $k_{\\text{br}}$ 位的有符号偏移量，以完整的指令字为单位进行度量（即，偏移量为 $d$ 编码了 $d$ 个指令字的位移）。假设指令为定长指令，大小为 $4$ 字节，但分支位移如上所述，以指令字为单位度量。\n\n全程序剖析得出了以下统计稳定模型。\n\n1. 对于立即数加法，绝对值 $X := |C|$ 具有一个混合分布，该分布对于 $C$ 的符号是对称的，并具有以下条件分布：\n   - 以 $0.50$ 的概率，$X$ 在 $[0,\\,31]$ 上均匀分布。\n   - 以 $0.35$ 的概率，$X$ 在 $(31,\\,255]$ 上均匀分布。\n   - 以 $0.15$ 的概率，$X$ 在 $(255,\\,4095]$ 上均匀分布。\n\n   $C$ 的符号是独立且对称的。\n\n2. 对于以指令字为单位的分支位移，位移 $D$ 被建模为一个零均值拉普拉斯分布，参数为 $\\lambda = 1/20$（因此概率密度函数为 $f_{D}(d) = (\\lambda/2)\\exp(-\\lambda |d|)$，其中 $d$ 的单位是指令字）。在进行覆盖率估计时，将 $D$ 视为连续变量。\n\n设计目标如下：\n- 选择最小的整数 $k_{\\text{add}}$，使得从模型中抽取的立即数加法常量 $C$ 可被编码的概率至少为 $0.97$。\n- 选择最小的整数 $k_{\\text{br}}$，使得从模型中抽取的分支位移 $D$ 可被编码的概率至少为 $0.999$。\n\n现在假设立即数加法的立即数字段必须减少 $\\Delta = 2$ 位，变为 $k_{\\text{add}}' = k_{\\text{add}} - 2$。在相同的常量模型下，估计立即数加法字面量池溢出的期望频率，该频率定义为 $C$ 无法用缩减后的宽度 $k_{\\text{add}}'$ 编码的概率。\n\n将 $k_{\\text{add}}$ 和 $k_{\\text{br}}$ 以整数形式（单位为位）报告，并将溢出频率以小数形式报告（不带百分号）。将溢出频率四舍五入到四位有效数字。", "solution": "用户提供了一个关于指令集架构 (ISA) 设计的计算机体系结构问题。在进行解答之前，我将首先验证问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n-   **ISA 类型**: 精简指令集计算机 (RISC)。\n-   **指令格式**: 定长指令，大小为 $4$ 字节。\n-   **立即数加法指令**:\n    -   有一个 $k_{\\text{add}}$ 位的立即数字段，用于存放有符号整数 $C$。\n    -   值 $C$ 以二进制补码编码，有效范围为 $[-2^{k_{\\text{add}}-1}, 2^{k_{\\text{add}}-1}-1]$。\n-   **条件分支指令**:\n    -   有一个 $k_{\\text{br}}$ 位的有符号偏移量字段，用于存放整数位移 $d$。\n    -   位移以指令字为单位度量（即 4 字节的倍数）。\n    -   $d$ 的有效范围为 $[-2^{k_{\\text{br}}-1}, 2^{k_{\\text{br}}-1}-1]$。\n-   **立即数加法常量 $C$ 的模型**:\n    -   绝对值 $X := |C|$ 服从一个混合分布。$C$ 的符号是独立且对称的。\n    -   以概率 $p_1 = 0.50$，$X$ 在整数集合 $[0, 31]$ 上均匀分布。\n    -   以概率 $p_2 = 0.35$，$X$ 在整数集合 $(31, 255]$（即 $[32, 255]$）上均匀分布。\n    -   以概率 $p_3 = 0.15$，$X$ 在整数集合 $(255, 4095]$（即 $[256, 4095]$）上均匀分布。\n-   **分支位移 $D$ 的模型**:\n    -   位移 $D$（以指令字为单位）被建模为一个连续随机变量，服从零均值拉普拉斯分布。\n    -   概率密度函数 (PDF) 为 $f_{D}(d) = (\\lambda/2)\\exp(-\\lambda |d|)$，其中 $\\lambda = 1/20$。\n-   **设计目标**:\n    1.  找到最小的整数 $k_{\\text{add}}$，使得立即数加法常量 $C$ 可被编码的概率至少为 $0.97$。\n    2.  找到最小的整数 $k_{\\text{br}}$，使得分支位移 $D$ 可被编码的概率至少为 $0.999$。\n-   **情景**:\n    1.  立即数加法字段宽度减少到 $k_{\\text{add}}' = k_{\\text{add}} - \\Delta$，其中 $\\Delta = 2$。\n    2.  估计溢出频率，定义为 $C$ 不能用宽度 $k_{\\text{add}}'$ 编码的概率。\n-   **报告要求**:\n    -   以整数形式报告 $k_{\\text{add}}$ 和 $k_{\\text{br}}$。\n    -   将溢出频率报告为小数，并四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题在计算机体系结构和 ISA 设计方面有坚实的理论基础。有符号立即数、二进制补码、分支偏移量以及操作数值的统计模型（混合均匀分布、拉普拉斯分布）的使用都是该领域的标准概念和实践。\n-   **良定性**：该问题是良定的。所有必要的分布、参数和设计约束都已提供。目标明确，可以得出唯一的、可计算的解。\n-   **客观性**：问题以精确的技术语言陈述，没有任何主观性或歧义。\n-   **结论**：没有发现可识别的缺陷（例如，科学上不健全、信息缺失、矛盾之处）。该问题有效。\n\n### 步骤 3：判定与行动\n问题有效。我将继续进行详细解答。\n\n### 解答\n\n问题分为三个部分：确定 $k_{\\text{add}}$，确定 $k_{\\text{br}}$，以及计算溢出频率。\n\n**第 1 部分：确定立即数加法字段宽度 $k_{\\text{add}}$**\n\n一个常量 $C$ 如果在范围 $[-2^{k_{\\text{add}}-1}, 2^{k_{\\text{add}}-1}-1]$ 内，就可以用一个 $k_{\\text{add}}$ 位的二进制补码字段进行编码。设 $X = |C|$。\n$C$ 可被编码的概率 $P(\\text{encodable})$ 由下式给出：\n$P(\\text{encodable}) = P(-2^{k_{\\text{add}}-1} \\le C \\le 2^{k_{\\text{add}}-1}-1)$。\n\n鉴于 $C$ 的符号是对称的（对于 $C \\neq 0$，$P(C>0) = P(C0)$），我们可以用 $X$ 来表示该概率。假设 $P(C \\ge 0) = P(C \\le 0) = 0.5$：\n$P(\\text{encodable}) = P(X \\le 2^{k_{\\text{add}}-1}-1 | C\\ge 0)P(C\\ge 0) + P(X \\le 2^{k_{\\text{add}}-1} | C  0)P(C  0)$\n$P(\\text{encodable}) = 0.5 \\cdot P(X \\le 2^{k_{\\text{add}}-1}-1) + 0.5 \\cdot P(X \\le 2^{k_{\\text{add}}-1})$。\n\n$X$ 的分布是三个离散均匀分布的混合：\n1.  在 $\\{0, \\dots, 31\\}$ 上的 $U_1$（$32$ 个点），混合权重 $p_1=0.50$。\n2.  在 $\\{32, \\dots, 255\\}$ 上的 $U_2$（$224$ 个点），混合权重 $p_2=0.35$。\n3.  在 $\\{256, \\dots, 4095\\}$ 上的 $U_3$（$3840$ 个点），混合权重 $p_3=0.15$。\n\n$X$ 的累积分布函数 (CDF) 是 $F_X(x) = P(X \\le x) = \\sum_{i=1}^3 p_i P(X \\le x | U_i)$。\n对于整数 $x$，离散均匀分布在 $\\{a, \\dots, b\\}$ 上的 CDF 为 $P(X \\le x) = (\\lfloor x \\rfloor - a + 1) / (b - a + 1)$，其中 $a \\le x \\le b$。\n\n我们需要找到最小的整数 $k_{\\text{add}}$，使得 $P(\\text{encodable}) \\ge 0.97$。我们来测试 $k_{\\text{add}}$ 的整数值。\n\n测试 $k_{\\text{add}} = 12$：\n范围是 $[-2^{11}, 2^{11}-1] = [-2048, 2047]$。\n我们需要 $P(X \\le 2047)$ 和 $P(X \\le 2048)$。\n$P(X \\le 2047) = 0.50 \\cdot P(X \\le 2047 | U_1) + 0.35 \\cdot P(X \\le 2047 | U_2) + 0.15 \\cdot P(X \\le 2047 | U_3)$。\n$P(X \\le 2047 | U_1) = 1$ (因为 $2047 > 31$)。\n$P(X \\le 2047 | U_2) = 1$ (因为 $2047 > 255$)。\n$P(X \\le 2047 | U_3) = \\frac{2047 - 256 + 1}{3840} = \\frac{1792}{3840} = \\frac{7}{15}$。\n$P(X \\le 2047) = 0.50(1) + 0.35(1) + 0.15(\\frac{7}{15}) = 0.85 + 0.07 = 0.92$。\n\n$P(X \\le 2048) = 0.50(1) + 0.35(1) + 0.15 \\cdot P(X \\le 2048 | U_3)$。\n$P(X \\le 2048 | U_3) = \\frac{2048 - 256 + 1}{3840} = \\frac{1793}{3840}$。\n$P(X \\le 2048) = 0.85 + 0.15 \\left(\\frac{1793}{3840}\\right) = 0.85 + \\frac{1793}{25600} \\approx 0.85 + 0.070039 = 0.920039$。\n\n$P(\\text{encodable for } k_{\\text{add}}=12) = 0.5(0.92) + 0.5(0.920039) \\approx 0.92002$。\n由于 $0.92002  0.97$，$k_{\\text{add}}=12$ 是不够的。\n\n测试 $k_{\\text{add}} = 13$：\n范围是 $[-2^{12}, 2^{12}-1] = [-4096, 4095]$。\n模型中 $X$ 的最大值是 $4095$。\n$P(X \\le 4095) = 1$。\n$P(X \\le 4096) = 1$。\n$P(\\text{encodable for } k_{\\text{add}}=13) = 0.5(1) + 0.5(1) = 1$。\n由于 $1 \\ge 0.97$，$k_{\\text{add}}=13$ 是足够的。\n因此，最小整数值为 $k_{\\text{add}} = 13$。\n\n**第 2 部分：确定分支偏移字段宽度 $k_{\\text{br}}$**\n\n如果分支位移 $d$ 在范围 $[-2^{k_{\\text{br}}-1}, 2^{k_{\\text{br}}-1}-1]$ 内，则它是可编码的。位移 $D$ 是一个连续变量，其 PDF 为 $f_{D}(d) = (\\lambda/2)\\exp(-\\lambda |d|)$，其中 $\\lambda=1/20$。我们需要 $P(-2^{k_{\\text{br}}-1} \\le D \\le 2^{k_{\\text{br}}-1}-1) \\ge 0.999$。\n\n一个常见且合理的简化是检查最大对称范围 $|D| \\le 2^{k_{\\text{br}}-1}-1$ 的覆盖率。\n$|D|$ 的 CDF 是 $F_{|D|}(y) = P(|D| \\le y) = \\int_{-y}^y f_D(d)\\,\\mathrm{d}d = 1 - \\exp(-\\lambda y)$，其中 $y \\ge 0$。\n我们需要 $1 - \\exp(-\\lambda (2^{k_{\\text{br}}-1}-1)) \\ge 0.999$。\n$\\exp(-\\lambda(2^{k_{\\text{br}}-1}-1)) \\le 0.001$。\n$-\\lambda(2^{k_{\\text{br}}-1}-1) \\le \\ln(0.001) = -3\\ln(10)$。\n$2^{k_{\\text{br}}-1}-1 \\ge \\frac{3\\ln(10)}{\\lambda} = \\frac{3\\ln(10)}{1/20} = 60\\ln(10)$。\n使用 $\\ln(10) \\approx 2.3026$，我们得到 $2^{k_{\\text{br}}-1}-1 \\ge 60 \\times 2.3026 = 138.156$。\n$2^{k_{\\text{br}}-1} \\ge 139.156$。\n由于 $k_{\\text{br}}$ 必须是整数，$k_{\\text{br}}-1$ 也必须是整数。我们必须找到最小的整数 $k_{\\text{br}}-1$，使得 $2^{k_{\\text{br}}-1} \\ge 139.156$。\n我们知道 $2^7=128$ 和 $2^8=256$。\n所以，我们必须有 $k_{\\text{br}}-1 \\ge 8$，这意味着 $k_{\\text{br}} \\ge 9$。最小整数值为 $k_{\\text{br}}=9$。\n\n我们来检查这个结果。\n对于 $k_{\\text{br}}=8$，范围是 $[-128, 127]$。对称范围是 $|D| \\le 127$。\n$P(|D| \\le 127) = 1 - \\exp(-127/20) = 1 - \\exp(-6.35) \\approx 1 - 0.001747 = 0.998253$。\n由于 $0.998253  0.999$，$k_{\\text{br}}=8$ 不足。\n\n对于 $k_{\\text{br}}=9$，范围是 $[-256, 255]$。对称范围是 $|D| \\le 255$。\n$P(|D| \\le 255) = 1 - \\exp(-255/20) = 1 - \\exp(-12.75) \\approx 1 - 2.895 \\times 10^{-6} = 0.999997$。\n由于 $0.999997 \\ge 0.999$，$k_{\\text{br}}=9$ 足够。\n因此，最小整数值为 $k_{\\text{br}} = 9$。\n\n**第 3 部分：计算溢出频率**\n\n原始宽度为 $k_{\\text{add}}=13$。新宽度为 $k_{\\text{add}}' = k_{\\text{add}} - 2 = 13 - 2 = 11$。\n溢出频率是常量 $C$ *不能* 用 11 位字段编码的概率。\n$P(\\text{spill}) = 1 - P(\\text{encodable for } k_{\\text{add}}'=11)$。\n对于 $k_{\\text{add}}'=11$，可编码范围是 $[-2^{10}, 2^{10}-1] = [-1024, 1023]$。\n$P(\\text{encodable for } k_{\\text{add}}'=11) = 0.5 \\cdot P(X \\le 1023) + 0.5 \\cdot P(X \\le 1024)$。\n\n首先，计算 $P(X \\le 1023)$:\n$P(X \\le 1023) = 0.50 \\cdot P(X \\le 1023 | U_1) + 0.35 \\cdot P(X \\le 1023 | U_2) + 0.15 \\cdot P(X \\le 1023 | U_3)$。\n$P(X \\le 1023 | U_1) = 1$。\n$P(X \\le 1023 | U_2) = 1$。\n$P(X \\le 1023 | U_3) = \\frac{1023 - 256 + 1}{3840} = \\frac{768}{3840} = \\frac{1}{5} = 0.2$。\n$P(X \\le 1023) = 0.50(1) + 0.35(1) + 0.15(0.2) = 0.85 + 0.03 = 0.88$。\n\n接着，计算 $P(X \\le 1024)$:\n$P(X \\le 1024) = 0.85 + 0.15 \\cdot P(X \\le 1024 | U_3) = 0.85 + 0.15 \\left(\\frac{1024 - 256 + 1}{3840}\\right) = 0.85 + 0.15 \\left(\\frac{769}{3840}\\right)$。\n$P(X \\le 1024) = 0.85 + \\frac{115.35}{3840} = 0.85 + 0.0300390625 = 0.8800390625$。\n\n现在，计算总的可编码概率：\n$P(\\text{encodable}) = 0.5(0.88) + 0.5(0.8800390625) = 0.44 + 0.44001953125 = 0.88001953125$。\n\n溢出频率为：\n$P(\\text{spill}) = 1 - P(\\text{encodable}) = 1 - 0.88001953125 = 0.11998046875$。\n\n问题要求四舍五入到四位有效数字。\n$0.11998046875 \\approx 0.1200$。\n\n所需的三个值是 $k_{\\text{add}}=13$，$k_{\\text{br}}=9$，以及溢出频率 $0.1200$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n13  9  0.1200\n\\end{pmatrix}\n}\n$$", "id": "3650299"}, {"introduction": "ISA 不仅定义了计算指令，还必须明确处理器与内存系统的交互方式，包括如何处理非对齐内存访问等特殊情况。本练习将探讨两种主流策略——通过陷阱（trap）由软件模拟，或在硬件中直接支持——的性能权衡。这个设计决策对架构的性能、复杂性和软件生态有着深远的影响。[@problem_id:3650322]", "problem": "一位 $64$ 位指令集架构 (ISA) 设计者必须决定，非对齐的 $8$ 字节加载和存储操作是应该引发软件陷阱，还是应该通过执行多次对齐访问在硬件中直接支持。假设采用以下有科学依据的性能模型和定义。\n\n- 如果内存操作的有效地址是 $8$ 的倍数，则该操作是“对齐的”；否则是“非对齐的”。系统使用一级缓存 (L1)，其缓存行大小为 $\\ell = 64$ 字节。所有内存访问都在 L1 中命中。\n- 设 $f$ 为非对齐内存操作的动态比例，并假设非对齐访问的起始字节偏移量在所有不是 $8$ 的倍数的偏移量（模 $\\ell$）中呈均匀分布。\n- 对齐内存操作的基础 L1 命中延迟为 $L=4$ 个周期。\n\n正在考虑两种 ISA 设计选项：\n\n1) 非对齐时陷阱 (Trap-on-unaligned):\n- 每个非对齐内存操作都会引发一个精确陷阱，其固定的陷阱进入/返回开销为 $T=180$ 个周期。\n- 操作系统处理程序通过两次对齐的内存操作来模拟非对齐操作，并合并结果，这会产生额外的软件开销 $M_s=6$ 个周期。\n- 从处理程序返回时，重新填充流水线会产生 $R=15$ 个周期的额外成本。\n- 对齐内存操作的成本仍然是基础的 $L$ 个周期。\n\n2) 硬件支持非对齐 (Hardware support for unaligned):\n- 一个对齐处理流水线阶段会为每个内存操作（无论对齐或非对齐）增加 $a=1$ 个周期的成本。\n- 对于不跨越缓存行边界的非对齐操作，硬件在同一缓存行内执行两次对齐访问并合并数据，在对齐阶段之外还有 $b=2$ 个周期的额外固定开销。\n- 对于跨越缓存行边界的非对齐操作，硬件对两个缓存行进行顺序访问。将其建模为基础延迟 $2L$ 加上合并/控制开销 $c=3$ 个周期，此外还有对齐阶段的成本 $a$。\n\n仅使用以上信息，从第一性原理出发完成以下任务：\n- 在所述的均匀性假设下，推导一个随机的非对齐 $8$ 字节内存操作跨越一个 $64$ 字节缓存行边界的概率。\n- 为每个 ISA 设计，建立每个内存操作的预期平均周期数关于 $f$ 的函数。\n- 求解收支平衡的非对齐比例 $f^{\\star}$（以小数形式表示），其定义为两种设计具有相等预期平均每内存操作延迟时的 $f$ 值。\n\n将您的 $f^{\\star}$ 最终数值结果四舍五入到四位有效数字。将答案表示为一个纯数字（无单位，无百分号）。", "solution": "在尝试求解之前，对问题陈述的有效性进行评估。\n\n### 步骤 1：提取已知条件\n- ISA 位宽：$64$ 位\n- 内存操作大小：$8$ 字节\n- L1 缓存行大小：$\\ell = 64$ 字节\n- 所有内存访问都在 L1 缓存中命中。\n- $f$：非对齐内存操作的动态比例。\n- 非对齐访问是指其有效地址不是 $8$ 的倍数的访问。\n- 非对齐访问的起始字节偏移量在所有不是 $8$ 的倍数的偏移量（模 $\\ell$）中呈均匀分布。\n- 对齐内存操作的基础 L1 命中延迟：$L = 4$ 个周期。\n\n设计 1：非对齐时陷阱\n- 陷阱进入/返回开销：$T = 180$ 个周期。\n- 软件处理程序开销：$M_s = 6$ 个周期。\n- 处理程序使用两次对齐的内存操作来模拟非对齐操作。\n- 返回时的流水线重新填充成本：$R = 15$ 个周期。\n\n设计 2：硬件支持非对齐\n- 对齐处理流水线阶段成本（适用于所有内存操作）：$a = 1$ 个周期。\n- 非对齐、不跨行访问：额外开销 $b = 2$ 个周期。此访问类型涉及在单个缓存行内的两次对齐访问。\n- 非对齐、跨行访问：基础延迟 $2L$ 加开销 $c = 3$ 个周期。此访问类型涉及对两个缓存行的顺序访问。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题是计算机体系结构中一个定义明确的性能分析练习。\n- **有科学依据：** 该问题使用了一个标准的、简化的性能模型，该模型基于指令周期计算、缓存行为和异常处理等基本概念。给定的参数是假设性的，但对于建模目的而言是切合实际的。\n- **问题良构：** 该问题提供了一套完整的参数和明确的目标：推导一个概率，建立两个成本函数，并找到它们的盈亏平衡点。根据所提供的信息可以推导出唯一的解。\n- **客观性：** 该问题以精确、定量的术语陈述，没有主观或模糊的语言。\n\n该问题不违反任何无效标准。在性能建模的背景下，它是自洽的、一致的，并且在科学上是合理的。\n\n### 步骤 3：结论与行动\n该问题是有效的。将推导解答。\n\n### 解答推导\n\n解答需要三个连续的推导：非对齐访问跨越缓存行边界的概率、每种设计的平均内存访问成本，以及盈亏平衡点。\n\n**1. 缓存行跨越概率 ($P_{cross}$)**\n\n一个 $8$ 字节的内存访问，如果在一个 $64$ 字节的缓存行（其中一行包含偏移量 $0, 1, ..., 63$）内以字节偏移量 $k$ 开始，当访问延伸到该行的最后一个字节之外时，就会跨越缓存行边界。该访问覆盖从 $k$到 $k+7$ 的字节。如果 $k+7 \\ge 64$，即 $k \\ge 57$，则发生跨越。导致跨越的可能起始偏移量 $k$ 为 $\\{57, 58, 59, 60, 61, 62, 63\\}$。共有 $7$ 个这样的起始偏移量。\n\n问题规定，如果访问的起始地址不是 $8$ 的倍数，则该访问是“非对齐的”。在一个 $64$ 字节的行内，对齐的偏移量是 $8$ 的倍数：$\\{0, 8, 16, 24, 32, 40, 48, 56\\}$。共有 $64/8 = 8$ 个对齐的偏移量。可能的起始偏移量总数为 $64$。因此，非对齐的起始偏移量数量为 $64 - 8 = 56$。\n\n问题指出，非对齐访问的起始字节偏移量在这 $56$ 个非对齐偏移量的集合中是均匀分布的。我们必须确定这 $7$ 个跨行偏移量中有多少也是非对齐的。跨行偏移量为 $\\{57, 58, 59, 60, 61, 62, 63\\}$。这些值没有一个是 $8$ 的倍数，所以所有 $7$ 个跨行偏移量都是非对齐的。\n\n因此，一个随机的非对齐访问跨越缓存行边界的概率 $P_{cross}$ 是非对齐跨行偏移量的数量与非对齐偏移量总数的比率：\n$$P_{cross} = \\frac{\\text{非对齐跨行偏移量数量}}{\\text{非对齐偏移量总数}} = \\frac{7}{56} = \\frac{1}{8}$$\n\n**2. 平均内存操作成本函数**\n\n设 $C_1(f)$ 和 $C_2(f)$ 分别为“非对齐时陷阱”和“硬件支持”两种设计中，每个内存操作的预期平均周期数，作为非对齐比例 $f$ 的函数。内存操作的总群体由比例为 $(1-f)$ 的对齐操作和比例为 $f$ 的非对齐操作组成。\n\n**设计 1：非对齐时陷阱 ($C_1(f)$)**\n- 对齐操作的成本：$L = 4$ 个周期。\n- 非对齐操作的成本：这会触发一个陷阱。总成本是陷阱开销、处理程序执行时间以及流水线重新填充成本的总和。处理程序本身执行两次对齐的内存操作，每次成本为 $L$，外加软件开销 $M_s$。\n$$ \\text{成本}_{\\text{非对齐}} = T + (2L + M_s) + R $$\n代入给定值：\n$$ \\text{成本}_{\\text{非对齐}} = 180 + (2 \\times 4 + 6) + 15 = 180 + 8 + 6 + 15 = 209 \\text{ 个周期} $$\n平均成本 $C_1(f)$ 是对齐和非对齐成本的加权平均值：\n$$ C_1(f) = (1-f) \\times \\text{成本}_{\\text{对齐}} + f \\times \\text{成本}_{\\text{非对齐}} $$\n$$ C_1(f) = (1-f) \\times 4 + f \\times 209 = 4 - 4f + 209f $$\n$$ C_1(f) = 4 + 205f $$\n\n**设计 2：硬件支持 ($C_2(f)$)**\n- 一个对齐处理阶段为每个内存操作增加 $a=1$ 个周期的成本。\n- 对齐操作的成本：基础延迟加上对齐阶段的成本：\n$$ \\text{成本}_{\\text{对齐}} = L + a = 4 + 1 = 5 \\text{ 个周期} $$\n- 非对齐操作的成本：这取决于是否跨越了缓存行边界。\n  - 如果不跨行（概率为 $1 - P_{cross} = 1 - 1/8 = 7/8$）：通过从单个缓存行中获取数据来处理该访问。问题描述将此情况与跨边界情况（延迟明确为 $2L$）区分开来。对于不跨行的访问，可以通过一次延迟为 $L$ 的缓存访问来服务。总成本由对齐阶段、基础 L1 访问和合并开销组成。\n    $$ \\text{成本}_{\\text{不跨行}} = L + a + b = 4 + 1 + 2 = 7 \\text{ 个周期} $$\n  - 如果跨行（概率为 $P_{cross} = 1/8$）：该操作需要对两个缓存行进行顺序访问，指定的基础延迟为 $2L$，外加对齐阶段和合并/控制开销。\n    $$ \\text{成本}_{\\text{跨行}} = 2L + a + c = 2 \\times 4 + 1 + 3 = 8 + 1 + 3 = 12 \\text{ 个周期} $$\n在此设计中，一个非对齐操作的预期成本是：\n$$ \\text{成本}_{\\text{非对齐}} = (1 - P_{cross}) \\times \\text{成本}_{\\text{不跨行}} + P_{cross} \\times \\text{成本}_{\\text{跨行}} $$\n$$ \\text{成本}_{\\text{非对齐}} = \\left(\\frac{7}{8}\\right) \\times 7 + \\left(\\frac{1}{8}\\right) \\times 12 = \\frac{49}{8} + \\frac{12}{8} = \\frac{61}{8} = 7.625 \\text{ 个周期} $$\n平均成本 $C_2(f)$ 是对齐和非对齐成本的加权平均值：\n$$ C_2(f) = (1-f) \\times \\text{成本}_{\\text{对齐}} + f \\times \\text{成本}_{\\text{非对齐}} $$\n$$ C_2(f) = (1-f) \\times 5 + f \\times 7.625 = 5 - 5f + 7.625f $$\n$$ C_2(f) = 5 + 2.625f $$\n\n**3. 盈亏平衡的非对齐比例 ($f^{\\star}$)**\n\n盈亏平衡比例 $f^{\\star}$ 是指两种设计性能相等时的 $f$ 值，即 $C_1(f^{\\star}) = C_2(f^{\\star})$。\n$$ 4 + 205f^{\\star} = 5 + 2.625f^{\\star} $$\n为求解 $f^{\\star}$，我们整理方程：\n$$ 205f^{\\star} - 2.625f^{\\star} = 5 - 4 $$\n$$ 202.375f^{\\star} = 1 $$\n$$ f^{\\star} = \\frac{1}{202.375} $$\n计算数值：\n$$ f^{\\star} \\approx 0.004941334 $$\n问题要求将结果四舍五入到四位有效数字。\n$$ f^{\\star} \\approx 0.004941 $$", "answer": "$$\n\\boxed{0.004941}\n$$", "id": "3650322"}, {"introduction": "为了提升性能，ISA 设计有时会暴露部分底层流水线特性，允许软件（编译器）进行针对性优化，分支延迟槽便是这样一个经典例子。这个练习要求你在给定数据和控制依赖约束下，通过指令调度来填充分支延迟槽，以避免性能损失。这是理解 ISA 与其微架构实现之间紧密联系的一项基本实践。[@problem_id:3650325]", "problem": "一个具有单个分支延迟槽的指令集架构 (ISA) 被定义为：无论分支是否发生跳转，紧随任何分支指令之后的那条指令总是会被执行。处理器是按序、单发射的。算术和逻辑的寄存器-寄存器指令是纯粹的（除了写入其目标寄存器外没有其他副作用），内存存储写入是可观察的副作用，而分支条件的求值依赖于分支指令在程序顺序中的操作数值。数据依赖类别被定义为写后读 (RAW)、读后写 (WAR) 和写后写 (WAW)。正确的调度必须保持这些依赖所蕴含的语义，并避免仅在单一控制路径上引入可观察的副作用。\n\n考虑该 ISA 中的以下基本块，其中分支目标标记为 $L$，后续的汇合点标记为 $J$。寄存器表示为 $r_i$，内存操作数使用“基址+偏移量”寻址方式 $o(r_b)$，且所有指令都是单周期的：\n\n- $I_0$: $add\\ r_{22}, r_{23}, r_{24}$\n- $I_1$: $load\\ r_{3}, 8(r_{2})$\n- $I_2$: $add\\ r_{1}, r_{3}, r_{4}$\n- $I_3$: $beq\\ r_{1}, r_{0}, L$\n- $I_4$: $store\\ r_{5}, 0(r_{6})$\n- $I_5$: $L:\\ sub\\ r_{10}, r_{11}, r_{12}$\n- $I_6$: $J:\\ xor\\ r_{25}, r_{22}, r_{26}$\n\n假设以下程序语义约束成立：\n- $I_3$ 中的分支读取 $r_{1}$，并且必须看到按程序顺序由 $I_2$ 计算出的值。\n- 在 $I_0$ 和 $I_3$ 之间没有指令读取 $r_{22}$，并且在 $I_3$ 和 $J$ 之间的任一控制路径上，在到达 $J$ 之前都没有指令读取 $r_{22}$；$r_{22}$ 在 $J$ 点首次被 $I_6$ 读取。\n- 在跳转路径上执行 $I_4$ 会错误地改变程序可见的内存状态；因此，当分支发生跳转时，$I_4$ 绝不能被执行。\n- 像 $add$、$sub$ 和 $xor$ 这样的算术指令没有异常，除了写入其目标寄存器外也没有可观察的副作用；$store$ 具有可观察的副作用，必须保持其对分支结果的控制依赖性。\n\n您的任务是，在存在单个分支延迟槽的情况下，围绕分支指令 $I_3$ 进行调度，通过将最多一条现有指令移动到延迟槽中，以在保证正确性的前提下，最小化插入的 $NOP$ 指令数量。如果没有任何现有指令可以合法地填充该延迟槽，您必须插入一个 $NOP$。\n\n请确定一个遵循上述约束的正确调度所需插入的 $NOP$ 指令的最小数量。请用整数表示您的最终答案；无需四舍五入。", "solution": "用户想要解决一个计算机体系结构问题。用户希望响应采用两个 XML 样式的标签，并且所有数学公式都必须使用 LaTeX 格式。\n\n### 步骤 1：提取已知条件\n- **ISA 与处理器**：该指令集架构 (ISA) 有一个分支延迟槽，意味着紧随分支指令之后的那条指令总会被执行。处理器是按序、单发射的。所有指令都是单周期的。\n- **指令属性**：\n  - 算术和逻辑的寄存器-寄存器指令是纯粹的（除了写入其目标寄存器外没有其他副作用）。\n  - 内存存储写入是可观察的副作用。\n  - 分支条件求值依赖于分支指令在程序顺序中的操作数值。\n- **数据依赖**：必须遵循写后读 (RAW)、读后写 (WAR) 和写后写 (WAW) 依赖。\n- **代码序列**：\n  - $I_0$: $add\\ r_{22}, r_{23}, r_{24}$\n  - $I_1$: $load\\ r_{3}, 8(r_{2})$\n  - $I_2$: $add\\ r_{1}, r_{3}, r_{4}$\n  - $I_3$: $beq\\ r_{1}, r_{0}, L$\n  - $I_4$: $store\\ r_{5}, 0(r_{6})$\n  - $I_5$: $L:\\ sub\\ r_{10}, r_{11}, r_{12}$\n  - $I_6$: $J:\\ xor\\ r_{25}, r_{22}, r_{26}$\n- **约束条件**：\n  1. $I_3$ 中的分支读取 $r_{1}$，并且必须看到由 $I_2$ 计算出的值。这在 $I_2$ 和 $I_3$ 之间建立了一个写后读 (RAW) 依赖。\n  2. $r_{22}$ 由 $I_0$ 写入，并首次由 $I_6$ 读取。在 $I_0$ 和 $I_6$ 之间（不包括 $I_0$ 和 $I_6$）没有指令读取或写入 $r_{22}$。\n  3. 当分支发生跳转时，$I_4$ 绝不能执行。这确定了 $I_4$ 控制依赖于分支 $I_3$ 的*非跳转*路径。\n  4. 算术指令是纯粹的；`store` 指令具有可观察的副作用。\n- **任务**：为了最小化插入的 $NOP$（空操作）指令，确定是否有现有指令可以合法地移动到 $I_3$ 的分支延迟槽中。找出所需 $NOP$ 的最小数量。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题陈述在计算机组成与体系结构原理方面具有科学依据，特别是涉及指令级并行、流水线和分支冒险。分支延迟槽、数据依赖（RAW、WAR、WAW）和指令调度的概念是该领域的标准。问题定义明确，提供了一套清晰的指令、架构约束和语义规则，以推导出一个单一的逻辑解。语言客观、正式。所有必要信息均已提供，且没有矛盾。该问题是有效的。\n\n### 步骤 3：进行求解\n目标是填充分支指令 $I_3: beq\\ r_{1}, r_{0}, L$ 后面的单个分支延迟槽。放入该槽中的指令会无条件执行，无论分支结果如何。如果一条有用的指令可以被移入该槽，则插入的 $NOP$ 数量为 $0$。否则，必须插入一个 $NOP$，数量为 $1$。\n\n我们可以从三个可能的位置选择一条指令来填充延迟槽：\n1.  从分支之前。该指令必须独立于分支指令。\n2.  从分支的目标（跳转路径）。该指令在非跳转路径上执行必须是安全的。\n3.  从分支后的顺序执行路径（非跳转路径）。该指令在跳转路径上执行必须是安全的。\n\n分支周围的原始序列是：\n...\n$I_2$: $add\\ r_{1}, r_{3}, r_{4}$\n$I_3$: $beq\\ r_{1}, r_{0}, L$\n（延迟槽）\n$I_4$: $store\\ r_{5}, 0(r_{6})$  （顺序执行路径）\n...\n$L$: $I_5$: $sub\\ r_{10}, r_{11}, r_{12}$ （跳转路径目标）\n...\n$J$: $I_6$: $xor\\ r_{25}, r_{22}, r_{26}$ （汇合点）\n\n**候选指令分析：**\n\n1.  **来自顺序执行路径的候选指令：$I_4: store\\ r_{5}, 0(r_{6})$**\n    - 要将 $I_4$ 移动到延迟槽中，它在分支发生跳转时执行必须是安全的。\n    - 问题明确指出：“在跳转路径上执行 $I_4$ 会错误地改变程序可见的内存状态；因此，当分支发生跳转时，$I_4$ 绝不能被执行。”\n    - 将 $I_4$ 放入延迟槽会导致它无条件执行，包括在分支跳转时。这违反了一个主要约束。\n    - **结论**：移动 $I_4$ 是非法的。\n\n2.  **来自分支目标的候选指令：$I_5: sub\\ r_{10}, r_{11}, r_{12}$**\n    - 要将 $I_5$ 移动到延迟槽中，它在分支*不*发生跳转时执行必须是安全的。\n    - `sub` 指令被定义为“纯粹的”，其唯一的副作用是写入目标寄存器 $r_{10}$。\n    - 在非跳转路径上执行 $I_5$ 是安全的，当且仅当覆盖 $r_{10}$ 不会破坏该路径上稍后在汇合点 $J$ 之前所需的某个值。\n    - 问题没有提供寄存器 $r_{10}$ 在顺序执行路径上的活跃性信息。虽然这种移动在某些情况下可能是合法的，但仅从所提供的信息无法明确证明其合法性。我们应该寻找一个可以确定其合法性的候选指令。\n\n3.  **来自分支之前的候选指令：$I_2, I_1, I_0$**\n\n    - **候选指令 $I_2: add\\ r_{1}, r_{3}, r_{4}$**\n      - 该指令写入 $r_{1}$。分支指令 $I_3$ 读取 $r_{1}$。\n      - 在 $r_{1}$ 上存在一个 RAW 依赖（$I_2 \\rightarrow I_3$）。\n      - 如果将 $I_2$ 移动到 $I_3$ 之后的延迟槽中，分支将在 $I_2$ 之前执行，从而读取一个旧的 $r_{1}$ 值。这违反了依赖关系。\n      - **结论**：移动 $I_2$ 是非法的。\n\n    - **候选指令 $I_1: load\\ r_{3}, 8(r_{2})$**\n      - 该指令写入 $r_{3}$，而 $I_2$ 读取 $r_{3}$。存在一个 RAW 依赖（$I_1 \\rightarrow I_2$）。\n      - 如前所述，$I_2$ 不能移动到 $I_3$ 之后。因此，为了维持 $I_1 \\rightarrow I_2$ 的依赖关系，$I_1$ 不能移动到 $I_2$ 之后，因此也不能移动到 $I_3$ 之后。\n      - **结论**：移动 $I_1$ 是非法的。\n\n    - **候选指令 $I_0: add\\ r_{22}, r_{23}, r_{24}$**\n      - 要将 $I_0$ 移动到延迟槽，它的执行必须独立于它所越过的指令（$I_1$, $I_2$, $I_3$）。\n      - 让我们分析依赖关系：\n        - $I_0$ 写入 $r_{22}$。$I_1, I_2, I_3$ 是否读取或写入 $r_{22}$？问题陈述：“在 $I_0$ 和 $I_3$ 之间没有指令读取 $r_{22}$”。这保证了延迟对 $r_{22}$ 的写入不会违反 RAW 或 WAW 依赖。\n        - $I_0$ 读取 $r_{23}$ 和 $r_{24}$。$I_1, I_2, I_3$ 是否写入 $r_{23}$ 或 $r_{24}$？这些指令是 $load\\ r_3, ...$，$add\\ r_1, ...$ 和 $beq\\ r_1, ...$。它们都不写入 $r_{23}$ 或 $r_{24}$。这保证了不会违反 WAR 依赖。\n      - 指令 $I_0$ 与 $I_1$、$I_2$ 和 $I_3$ 完全独立。\n      - 此外，$r_{22}$ 的新值首次被汇合点 $J$ 处的 $I_6$ 需要。通过将 $I_0$ 移动到延迟槽中，它仍然在跳转和非跳转两条路径上都在 $I_6$ 之前执行。\n      - 这种移动是将分支前的独立指令调度到延迟槽中的经典示例。调度变为：\n        $I_1: load\\ r_{3}, 8(r_{2})$\n        $I_2: add\\ r_{1}, r_{3}, r_{4}$\n        $I_3: beq\\ r_{1}, r_{0}, L$\n        $I_0: add\\ r_{22}, r_{23}, r_{24}$ （在延迟槽中）\n      - 这个调度是正确的，并保留了所有程序语义。\n      - **结论**：移动 $I_0$ 是合法的。\n\n既然我们找到了一个可以移动到分支延迟槽的合法指令 $I_0$，我们就不需要插入 $NOP$。因此，所需插入的 $NOP$ 指令的最小数量为 $0$。", "answer": "$$\\boxed{0}$$", "id": "3650325"}]}