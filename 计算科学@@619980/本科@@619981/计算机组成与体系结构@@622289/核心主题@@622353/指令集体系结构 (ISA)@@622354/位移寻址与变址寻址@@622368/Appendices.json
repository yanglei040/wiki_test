{"hands_on_practices": [{"introduction": "在计算机体系结构中，不同的寻址表达式可能会计算出相同的内存地址，这种现象被称为地址别名（aliasing）。本练习将帮助你从根本上理解，编译器如何通过组合不同的索引和位移值来灵活地访问数组元素，这也是理解指针运算的关键。通过推导两个不同表达式 [@problem_id:3636086] 指向同一地址的条件，你将深入掌握变址寻址模式的代数本质。", "problem": "一种具有位移寻址和变址寻址的指令集架构 (ISA) 计算内存操作数的有效地址，其定义为有效地址等于基址寄存器内容、一个由元素大小决定的因子缩放的变址寄存器，以及一个立即数位移之和。形式上，对于引用一个定长元素数组的内存操作数，其有效地址由 $R_b$、由元素大小因子 $S$ 缩放的 $R_i$ 和位移 $d$ 的总和给出，其中 $R_b$ 表示基址寄存器值，$R_i$ 表示变址寄存器值，$S$ 表示由元素大小（以字节为单位）决定的缩放因子，$d$ 表示位移（以字节为单位）。考虑一个 $32$ 位整数数组，因此缩放因子为 $S = 4$。两个不同的地址表达式指向该数组中的同一位置，但使用不同的变址和位移值：第一个使用变址寄存器 $R_i$ 和位移 $d_1$，第二个使用变址寄存器 $R_i + 1$ 和位移 $d_2$，两者都使用相同的基址寄存器 $R_b$。仅使用上述有效地址的基本定义以及当两个表达式计算出相同有效地址时发生别名这一概念，推导出当 $S = 4$ 时，对于任意的 $R_b$ 和 $R_i$，使得这两个不同的地址表达式产生别名的位移的充要条件，并计算 $d_2 - d_1$ 的值（以字节为单位）。仅报告 $d_2 - d_1$ 的值作为你的最终答案，以字节为单位的整数。", "solution": "问题陈述经评估是有效且定义明确的。它在科学上基于计算机组成与体系结构的原理，特别是关于内存寻址模式。所有必要的数据和条件都已提供，以推导出唯一且有意义的解。\n\n问题将使用位移和变址寻址的内存操作数的有效地址（$EA$）定义为基址寄存器值（$R_b$）、由元素大小因子（$S$）缩放的变址寄存器值（$R_i$）和位移（$d$）之和。公式为：\n$$ EA = R_b + S \\cdot R_i + d $$\n问题指定内存操作数是 $32$ 位整数。由于1字节有 $8$ 位，一个 $32$ 位整数占用 $\\frac{32}{8} = 4$ 字节。缩放因子 $S$ 由元素大小（以字节为单位）决定，因此在这种情况下，$S = 4$。\n\n我们有两个产生别名的不同地址表达式，这意味着它们计算出相同的有效地址。让我们将第一个和第二个表达式的有效地址分别表示为 $EA_1$ 和 $EA_2$。\n\n对于第一个地址表达式：\n变址寄存器值被指定为 $R_i$。\n位移为 $d_1$。\n基址寄存器为 $R_b$，缩放因子为 $S=4$。\n因此，第一个有效地址 $EA_1$ 由以下公式给出：\n$$ EA_1 = R_b + 4 \\cdot R_i + d_1 $$\n\n对于第二个地址表达式：\n变址寄存器值被指定为 $R_i + 1$。这被解释为变址寄存器 $R_i$ 的值增加了 $1$。\n位移为 $d_2$。\n基址寄存器与第一个表达式相同，为 $R_b$，缩放因子也为 $S=4$。\n因此，第二个有效地址 $EA_2$ 由以下公式给出：\n$$ EA_2 = R_b + 4 \\cdot (R_i + 1) + d_2 $$\n\n别名条件要求这两个表达式产生相同的地址：\n$$ EA_1 = EA_2 $$\n代入 $EA_1$ 和 $EA_2$ 的表达式：\n$$ R_b + 4 R_i + d_1 = R_b + 4(R_i + 1) + d_2 $$\n\n问题指出，此条件必须对基址寄存器 $R_b$ 和变址寄存器 $R_i$ 的任意值都成立。我们可以简化该方程，以找到满足此要求的 $d_1$ 和 $d_2$ 之间的关系。\n\n首先，将右侧的缩放因子 $4$ 展开：\n$$ R_b + 4 R_i + d_1 = R_b + 4 R_i + 4 \\cdot 1 + d_2 $$\n$$ R_b + 4 R_i + d_1 = R_b + 4 R_i + 4 + d_2 $$\n\n$R_b$ 项出现在等式两侧，可以通过从两侧减去 $R_b$ 来抵消。这与条件对任意 $R_b$ 均成立是一致的。\n$$ 4 R_i + d_1 = 4 R_i + 4 + d_2 $$\n\n类似地，$4 R_i$ 项出现在等式两侧。从两侧减去 $4 R_i$ 表明该条件对任意 $R_i$ 均成立。\n$$ d_1 = 4 + d_2 $$\n\n这个方程 $d_1 = 4 + d_2$ 是使得两个地址表达式产生别名的位移 $d_1$ 和 $d_2$ 的充要条件，且与 $R_b$ 和 $R_i$ 的值无关。\n\n问题要求计算 $d_2 - d_1$ 的值。我们可以重新整理推导出的条件来求解这个差值。\n从 $d_1 = 4 + d_2$ 开始，我们从等式两边同时减去 $d_1$ 和 $4$：\n$$ d_1 - d_1 - 4 = 4 - 4 + d_2 - d_1 $$\n$$ -4 = d_2 - d_1 $$\n\n因此，$d_2 - d_1$ 的值为 $-4$。位移以字节为单位，所以结果是 $-4$ 字节。这个结果是合乎逻辑的：将数组索引增加 $1$ 会将地址向前移动 $S = 4$ 字节；为了保持最终地址相同，位移必须减少 $4$ 字节，即 $d_2 = d_1 - 4$。", "answer": "$$ \\boxed{-4} $$", "id": "3636086"}, {"introduction": "计算出有效地址只是第一步；该地址的属性同样至关重要，尤其是在性能方面。本练习 [@problem_id:3636147] 将向你展示，当访问未对齐的地址时，系统可能会因触发操作系统陷阱而产生巨大的性能开销。你将需要分析有效地址的奇偶性，并将其与具体的系统行为和周期成本联系起来，从而量化这种性能惩罚。", "problem": "一个 $64$ 位中央处理器（CPU）中的加载/存储单元实现了位移寻址和变址寻址。对于字访问，该单元首先通过基址寄存器 $b$ 和索引寄存器 $i$ 乘以一个比例因子 $\\sigma$ 形成基址-索引和 $s$，然后加上一个位移量 $d$ 来计算有效地址（EA）。具体来说，该单元计算 $$EA = s + d,$$ 其中 $$s = b + \\sigma \\cdot i.$$ 在这台机器中，一个字是 $2$ 字节，内存系统要求字访问与 $2$ 字节边界对齐，这意味着当且仅当 $$EA \\bmod 2 = 0$$ 时，访问是对齐的。\n\n考虑一个使用此寻址模式的循环，其中包含 $14$ 次字加载，每次迭代具有固定的基址-索引和 $s$ 和变化的位移量 $d$。给定的基址-索引和为 $$s = 16384,$$ 这是一个偶数。每次迭代的位移序列为 $$D = \\{1, 4, 5, 8, 11, 14, 15, 18, 21, 22, 25, 30, 31, 34\\}.$$\n\n该 CPU 使用对齐陷阱模型：当字访问未对齐时，会触发一个对齐陷阱，并由操作系统（OS）处理。对齐陷阱引入了以下周期成本：\n- 陷阱进入成本 $t_{e} = 20$ 个周期，\n- 处理程序模拟成本 $t_{h} = 12$ 个周期，\n- 陷阱退出成本 $t_{x} = 10$ 个周期，\n- 流水线重填成本 $t_{p} = 6$ 个周期。\n\n相比之下，一个对齐的字加载在 $c_{a} = 3$ 个周期内完成，并且不产生任何陷阱成本。对于此问题，将未对齐访问的惩罚定义为由陷阱引起的、超出对齐情况的额外周期数，即 $$P = t_{e} + t_{h} + t_{x} + t_{p}.$$\n\n假设没有其他停顿或冒险，确定该序列中 $14$ 次加载所产生的总惩罚（以周期为单位）。将最终结果表示为精确的整数周期数；无需四舍五入。此外，请利用 $s$ 和 $d$ 的奇偶性以及对齐规则，简要说明为什么当 $d$ 为奇数且 $s$ 为偶数时，字访问会出现未对齐的有效地址情况。", "solution": "该问题经评估为有效，因为它科学地基于计算机体系结构的原理，问题提出得当，数据充分且一致，语言客观。我们可以进行正式求解。\n\n该问题要求两件事：首先，证明内存访问在何种条件下会变得未对齐；其次，计算给定内存加载序列的总周期惩罚。\n\n首先，我们来论证未对齐的条件。在此体系结构中，一个字是 $2$ 字节。字内存访问必须与 $2$ 字节边界对齐。这意味着访问的有效地址（$EA$）必须是 $2$ 的倍数。在数学上，这个条件表示为：\n$$EA \\bmod 2 = 0$$\n如果此条件不满足，即 $EA \\bmod 2 \\neq 0$，则访问是未对齐的，对于整数而言，这等同于 $EA \\bmod 2 = 1$。这意味着未对齐的有效地址必须是一个奇数。\n\n有效地址计算为 $EA = s + d$，其中 $s$ 是基址-索引和，$d$ 是位移量。我们已知 $s = 16384$。为了确定 $s$ 的奇偶性，我们可以检查它是否能被 $2$ 整除。因为 $16384 = 2 \\times 8192$，所以 $s$ 是一个偶数。\n\n我们现在可以使用模运算来分析 $EA$ 的奇偶性。一个和的奇偶性由其操作数的奇偶性决定。让我们考虑 $EA$ 对 $2$ 取模的方程：\n$$EA \\pmod 2 = (s + d) \\pmod 2$$\n利用模运算的性质，这可以写成：\n$$EA \\pmod 2 = (s \\pmod 2 + d \\pmod 2) \\pmod 2$$\n因为 $s$ 是偶数，所以 $s \\pmod 2 = 0$。将此代入方程中得到：\n$$EA \\pmod 2 = (0 + d \\pmod 2) \\pmod 2 = d \\pmod 2$$\n这个结果表明，有效地址 $EA$ 的奇偶性与位移量 $d$ 的奇偶性相同。因此，当且仅当位移量 $d$ 也是奇数（$d \\pmod 2 = 1$）时，访问是未对齐的（$EA$ 是奇数，所以 $EA \\pmod 2 = 1$）。这就完成了所要求的论证。\n\n接下来，我们计算这 $14$ 次加载序列所产生的总惩罚。\n单次未对齐访问的惩罚 $P$ 定义为与对齐陷阱相关的周期成本之和：\n$$P = t_{e} + t_{h} + t_{x} + t_{p}$$\n代入给定值：\n$t_{e} = 20$ 个周期\n$t_{h} = 12$ 个周期\n$t_{x} = 10$ 个周期\n$t_{p} = 6$ 个周期\n$$P = 20 + 12 + 10 + 6 = 48 \\text{ 个周期}$$\n这是每次未对齐访问的惩罚。对齐的访问不产生此类惩罚。\n\n现在，我们必须确定这 $14$ 次加载操作中有多少次是未对齐的。根据我们之前的分析，如果对应的位移量 $d$ 是一个奇数，那么访问就是未对齐的。位移序列如下：\n$$D = \\{1, 4, 5, 8, 11, 14, 15, 18, 21, 22, 25, 30, 31, 34\\}$$\n我们识别出这个序列中的奇数：\n- $1$ (奇数)\n- $4$ (偶数)\n- $5$ (奇数)\n- $8$ (偶数)\n- $11$ (奇数)\n- $14$ (偶数)\n- $15$ (奇数)\n- $18$ (偶数)\n- $21$ (奇数)\n- $22$ (偶数)\n- $25$ (奇数)\n- $30$ (偶数)\n- $31$ (奇数)\n- $34$ (偶数)\n\n奇数位移量的集合是 $\\{1, 5, 11, 15, 21, 25, 31\\}$。通过计算该集合中的元素数量，我们得到未对齐访问的总次数 $N_{\\text{misaligned}}$。\n$$N_{\\text{misaligned}} = 7$$\n总惩罚是未对齐访问次数与每次访问的惩罚的乘积。\n$$\\text{总惩罚} = N_{\\text{misaligned}} \\times P$$\n代入我们找到的值：\n$$\\text{总惩罚} = 7 \\times 48$$\n进行乘法运算：\n$$7 \\times 48 = 7 \\times (40 + 8) = 280 + 56 = 336$$\n因此，这 $14$ 次加载序列所产生的总惩罚为 $336$ 个周期。", "answer": "$$\\boxed{336}$$", "id": "3636147"}, {"introduction": "如果处理器硬件本身不支持复杂的寻址模式（例如，带比例因子的变址寻址），我们该怎么办？这个练习 [@problem_id:3636068] 模拟了一个常见场景：在只有简单寻址模式的机器上，如何通过一系列基本指令来合成一个复杂的地址计算。这揭示了精简指令集（RISC）的核心思想，并让你亲手体验在硬件复杂性与软件实现（以及由此带来的性能开销）之间的权衡。", "problem": "考虑一个加载操作，其概念上需要一个由基址寄存器、变址因子和位移构成的有效地址（EA），而这台机器只实现了位移寻址模式。位移寻址的基本定义是，有效地址计算为 $EA = R_{b} + d$，其中 $R_{b}$ 是任意通用寄存器，而 $d$ 是一个符号扩展的立即数位移。形如 $EA = R_{b} + R_{i} \\cdot 8 + d$ 的变址寻址模式不被该机器的硬件直接支持。您必须依赖算术逻辑单元（ALU）提供的整数运算和位移寻址模式来达到相同的效果。\n\n假设采用以下经过良好测试的标准执行时间模型和指令集：\n- 机器可以按程序顺序每个周期发射一条指令，并且没有冒险或重叠；一个序列的总周期数等于每个指令的周期数之和。\n- ALU 支持寄存器到寄存器移动（$\\mathrm{MOV}$）、加法（$\\mathrm{ADD}$）和立即数逻辑左移（$\\mathrm{SHL}$）。这些 ALU 指令中的每一个都在1个周期内完成。\n- 加载指令 $\\mathrm{LD}\\ R_{x}, [R + d]$ 使用位移寻址（$EA = R + d$），在4个周期内完成，其中包括地址生成和内存访问。\n- 如果硬件支持变址寻址，相应的单指令加载 $\\mathrm{LD}\\ R_{x}, [R_{b} + R_{i} \\cdot 8 + d]$ 也将在4个周期内完成。\n\n给定寄存器 $R_{i}$ 的值在此序列中不得被修改（其值必须被保留），并且有一个可用的暂存寄存器 $R_{t}$，其初始值未指定。请设计一个仅使用 $\\mathrm{MOV}$、$\\mathrm{SHL}$、$\\mathrm{ADD}$ 和 $\\mathrm{LD}$ 的最小指令序列，以在不破坏 $R_{i}$ 的情况下执行与 $\\mathrm{LD}\\ R_{x}, [R_{b} + R_{i} \\cdot 8 + d]$ 等效的操作。然后，计算您的序列相对于假设的单指令变址加载所需的额外周期数。将您的最终答案表示为单个整数周期数。无需四舍五入，最终答案不应包含单位。", "solution": "首先对问题进行验证过程。\n\n### 步骤 1：提取已知条件\n- **目标操作**：使用有效地址（EA）进行加载，其定义为 $EA = R_{b} + R_{i} \\cdot 8 + d$。\n- **硬件寻址模式**：仅限位移寻址，$EA = R_{\\text{base}} + d$，其中 $R_{\\text{base}}$ 是一个通用寄存器，$d$ 是一个符号扩展的立即数位移。\n- **不支持的寻址模式**：变址寻址，$EA = R_{b} + R_{i} \\cdot 8 + d$，不被直接支持。\n- **执行模型**：单发射、顺序执行，无冒险。总周期数是各指令周期数之和。\n- **指令集和延迟**：\n  - $\\mathrm{MOV}$ （寄存器到寄存器）：$1$ 周期。\n  - $\\mathrm{ADD}$ （寄存器到寄存器）：$1$ 周期。\n  - $\\mathrm{SHL}$ （立即数逻辑左移）：$1$ 周期。\n  - $\\mathrm{LD}\\ R_{x}, [R + d]$ （使用位移寻址的加载）：$4$ 周期。\n- **假设指令延迟**：一个假设的 $\\mathrm{LD}\\ R_{x}, [R_{b} + R_{i} \\cdot 8 + d]$ 指令将耗时 $4$ 周期。\n- **约束条件**：\n  1. 寄存器 $R_{i}$ 中的值必须被保留。\n  2. 一个暂存寄存器 $R_{t}$ 可用。\n  3. 解决方案必须仅使用提供的指令：$\\mathrm{MOV}$、$\\mathrm{SHL}$、$\\mathrm{ADD}$ 和 $\\mathrm{LD}$。\n- **目标**：\n  1. 构建一个最小指令序列来执行与目标加载操作等效的功能。\n  2. 计算此序列相比于假设的单指令实现所需的额外周期数。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学依据**：该问题是计算机组成与体系结构中的一个经典练习，涉及指令集架构（ISA）、寻址模式和性能分析（周期计数）。这些概念是该领域的基础。简化的执行模型（无冒险）是一种标准的教学简化方法。\n- **问题定义良好**：目标明确定义，可用资源（$\\mathrm{MOV}$、$\\mathrm{ADD}$、$\\mathrm{SHL}$、$\\mathrm{LD}$、一个暂存寄存器）已明确列出，约束条件（保留 $R_{i}$）清晰明确。目标度量（额外周期数）已精确说明。可以逻辑推导出一个最小序列，从而得到唯一解。\n- **客观性**：问题使用计算机体系结构的标准、客观术语进行陈述。没有使用主观或模糊的语言。\n- **缺陷分析**：问题陈述没有科学上的不健全、不完整、矛盾以及验证标准中列出的其他缺陷。它提出了一个可解的、自包含的场景，与计算机体系结构的主题直接相关。\n\n### 步骤 3：结论与行动\n问题被判定为**有效**。将构建一个解决方案。\n\n### 解决方案推导\n\n目标是从有效地址 $EA = R_{b} + R_{i} \\cdot 8 + d$ 加载数据。硬件的原生加载指令 $\\mathrm{LD}\\ R_{x}, [R + d]$ 只能通过将单个寄存器 $R$ 的内容与一个立即数位移 $d$ 相加来计算有效地址。\n\n为了实现目标寻址模式，我们必须首先计算硬件无法处理的那部分地址，即基址与变址因子之和 $R_{b} + R_{i} \\cdot 8$。这个计算出的值必须被放入一个寄存器中，该寄存器将作为最终 $\\mathrm{LD}$ 指令的基址寄存器。问题为此提供了一个暂存寄存器 $R_{t}$。\n\n计算必须使用可用的 ALU 指令按步骤序列执行，同时要遵守寄存器 $R_{i}$ 不得被修改的约束。\n\n1.  **保留寄存器 $R_{i}$**：由于计算需要 $R_{i}$ 的值，但寄存器本身不得被改变，我们必须首先将其内容复制到暂存寄存器 $R_{t}$。\n    - 指令：$\\mathrm{MOV}\\ R_{t}, R_{i}$\n    - 此操作需要 $1$ 个周期。此后，$R_{t}$ 保存 $R_{i}$ 的初始值。\n\n2.  **计算变址因子**：必须计算 $R_{i} \\cdot 8$ 这一项。乘以 $8$ 等于 $2^3$，相当于逻辑左移 $3$ 个比特位。我们在当前保存着 $R_{i}$ 值的 $R_{t}$ 上执行此操作。\n    - 指令：$\\mathrm{SHL}\\ R_{t}, 3$\n    - 此操作需要 $1$ 个周期。此后，$R_{t}$ 包含值 $(R_{i} \\cdot 8)$。\n\n3.  **加上基址寄存器**：必须将基址寄存器 $R_{b}$ 的内容加到变址因子上。\n    - 指令：$\\mathrm{ADD}\\ R_{t}, R_{b}$\n    - 此操作需要 $1$ 个周期。此后，$R_{t}$ 包含值 $(R_{b} + R_{i} \\cdot 8)$。\n\n4.  **执行加载**：现在，寄存器 $R_{t}$ 保存了地址中基址加变址因子的部分。我们可以使用 $R_{t}$ 作为原生位移模式加载指令中的基址寄存器。硬件将计算最终的有效地址为 $EA = R_{t} + d$，这解析为 $(R_{b} + R_{i} \\cdot 8) + d$，正是目标地址。\n    - 指令：$\\mathrm{LD}\\ R_{x}, [R_{t} + d]$\n    - 此操作需要 $4$ 个周期。\n\n最终的最小指令序列是：\n- $\\mathrm{MOV}\\ R_{t}, R_{i}$\n- $\\mathrm{SHL}\\ R_{t}, 3$\n- $\\mathrm{ADD}\\ R_{t}, R_{b}$\n- $\\mathrm{LD}\\ R_{x}, [R_{t} + d]$\n\n这个序列是最小的，因为前三个指令中的每一个对于在不违反 $R_{i}$ 保留约束的情况下在 $R_{t}$ 中计算所需的地址分量 $(R_{b} + R_{i} \\cdot 8)$ 都是必需的，而最后的 `LD` 指令是执行内存访问所必需的。\n\n这个合成操作的总周期数 $C_{\\text{sequence}}$ 是序列中每个指令的周期数之和：\n$$C_{\\text{sequence}} = C_{\\text{MOV}} + C_{\\text{SHL}} + C_{\\text{ADD}} + C_{\\text{LD}}$$\n$$C_{\\text{sequence}} = 1 + 1 + 1 + 4 = 7 \\text{ 周期}$$\n\n问题陈述，如果存在用于变址寻址的假设单指令，它将在 $C_{\\text{hypothetical}} = 4$ 个周期内完成。\n\n合成指令序列所需的额外周期数是两个周期数之差：\n$$\\text{Extra Cycles} = C_{\\text{sequence}} - C_{\\text{hypothetical}}$$\n$$\\text{Extra Cycles} = 7 - 4 = 3$$\n\n因此，与假设的硬件实现相比，合成方法需要额外 $3$ 个周期。", "answer": "$$\n\\boxed{3}\n$$", "id": "3636068"}]}