{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。本节将通过一系列动手实践，加深你对过程调用机制的理解。第一个练习将过程调用的抽象概念具体化。我们将基于一个真实世界的应用程序二进制接口（ABI），精确计算函数调用过程中所涉及的栈操作数量。这个练习将帮助你量化理解函数序言（prologue）和结语（epilogue）的开销，并阐明调用者保存（caller-saved）和被调用者保存（callee-saved）寄存器的管理职责。[@problem_id:3669284]", "problem": "考虑一个遵循 System V 应用程序二进制接口 (ABI) 的 $64$ 位架构，其中以下广泛使用的寄存器分配规则适用于整数参数和通用寄存器：\n\n- 前 $6$ 个整数参数通过寄存器传递 $(R = 6)$，任何额外的整数参数都通过运行时堆栈传递。\n- 有 $10$ 个调用者保存的寄存器 $(S = 10)$，如果调用者在调用后需要它们的值，则必须由调用者保存。\n- 有 $6$ 个被调用者保存的寄存器 $(C = 6)$，如果被调用者使用它们，则必须由被调用者保存。\n- 过程调用指令会隐式地将返回地址推入堆栈，而返回指令会隐式地将其弹出。\n\n假设一个从调用者到被调用者的单次调用的具体且现实的场景，其中被调用者使用 $l$ 个局部变量并接收 $a$ 个整数参数：\n\n1. 调用者在调用点处于最坏情况，即所有 $S$ 个调用者保存的寄存器都持有必须在调用期间保留的值；因此，它在调用前将它们保存在堆栈上，并在返回后恢复它们。\n2. 被调用者最多使用 $C$ 个被调用者保存的寄存器，具体来说是 $\\min(l, C)$ 个，用于存放必须在多次调用间保持活动状态的局部变量；因此，它在入口处保存这 $\\min(l, C)$ 个寄存器，并在出口处恢复它们。\n3. 调用者将超出前 $R$ 个的任何参数通过堆栈传递；将此建模为调用者为每个此类参数执行的一系列堆栈推入操作。调用之后，调用者通过调整堆栈指针来释放参数堆栈区域（没有显式的弹出指令）。\n4. 计算等效于堆栈推入和堆栈弹出的操作，包括由调用和返回指令隐式执行的操作。只计算离散的推入和弹出操作；不要将批量的堆栈指针调整计为弹出操作。\n\n从 ABI 下调用者保存和被调用者保存的职责定义以及调用和返回的语义出发，推导一个关于 $a$ 和 $l$ 的封闭形式表达式，表示在一次完整的调用-返回对中，调用者和被调用者共同执行的推入操作总数和弹出操作总数。将你的最终答案表示为一个二元行向量 $\\begin{pmatrix}\\text{pushes}  \\text{pops}\\end{pmatrix}$。不需要四舍五入，也不涉及单位。提供精确的解析表达式。", "solution": "首先对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- 架构：$64$位，System V 应用程序二进制接口 (ABI)。\n- 用于整数参数的寄存器数量：$R = 6$。\n- 调用者保存的寄存器数量：$S = 10$。\n- 被调用者保存的寄存器数量：$C = 6$。\n- `call` 指令：隐式地将返回地址推入堆栈。\n- `return` 指令：隐式地从堆栈中弹出返回地址。\n- 调用者行为：在调用前保存所有 $S$ 个调用者保存的寄存器，并在调用后恢复它们。将超出前 $R$ 个的参数推入堆栈。通过调整堆栈指针而非弹出操作来释放堆栈参数。\n- 被调用者行为：在入口处保存 $\\min(l, C)$ 个被调用者保存的寄存器，并在出口处恢复它们，其中 $l$ 是局部变量的数量。\n- 输入变量：$a$（整数参数的数量），$l$（局部变量的数量）。\n- 目标：推导单次调用-返回对中推入和弹出操作总数的封闭形式表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题牢固地植根于计算机组成和体系结构的原理。System V ABI 是一个真实世界的标准，而调用者保存/被调用者保存的寄存器、运行时堆栈以及过程调用链接约定等概念是该学科的基础。指定的寄存器数量（$R=6$，$S=10$，$C=6$）与 x86-64 System V ABI 中用于通用整数寄存器的数量一致。\n- **适定性：** 该问题是适定的。它提供了一套完整的规则和参数（$a$，$l$），以唯一确定我们感兴趣的量（推入和弹出的次数）。定义是精确的（例如，区分了弹出操作和堆栈指针调整）。\n- **客观性：** 语言技术性强且明确，没有主观或基于意见的陈述。\n\n### 步骤 3：结论与行动\n问题是有效的，因为它具有科学合理性、适定性和客观性。下面将推导解决方案。\n\n在单个调用-返回序列中，推入操作的总数 $N_{\\text{push}}$ 和弹出操作的总数 $N_{\\text{pop}}$ 是调用者和被调用者执行的操作之和。我们将按照规定系统地计算每个操作。\n\n**1. 推入操作分析 ($N_{\\text{push}}$)**\n\n我们对所有将值推入堆栈的操作求和。\n\n- **调用者保存的寄存器：** 问题陈述指出，调用者处于最坏情况，必须保留所有 $S$ 个调用者保存的寄存器。它通过在调用前将它们推入堆栈来实现这一点。这贡献了 $S$ 次推入操作。\n- **参数传递：** 前 $R$ 个参数通过寄存器传递。任何超出此范围的参数都通过堆栈传递。对于总共 $a$ 个参数，被推入堆栈的参数数量为 $a - R$。由于此计数不能为负，所以推入次数为 $\\max(0, a - R)$。\n- **`call` 指令：** `call` 指令本身会隐式地将返回地址推入堆栈。这贡献了 $1$ 次推入操作。\n- **被调用者保存的寄存器：** 被调用者使用 $l$ 个局部变量，并保存等于 $\\min(l, C)$ 数量的被调用者保存寄存器，以在它可能进行的任何潜在嵌套调用中保留它们的值。这是在进入过程时完成的。这贡献了 $\\min(l, C)$ 次推入操作。\n\n将这些贡献相加，得到推入操作的总数：\n$$N_{\\text{push}} = (\\text{调用者保存}) + (\\text{参数}) + (\\text{返回地址}) + (\\text{被调用者保存})$$\n$$N_{\\text{push}} = S + \\max(0, a - R) + 1 + \\min(l, C)$$\n\n**2. 弹出操作分析 ($N_{\\text{pop}}$)**\n\n我们对所有从堆栈中弹出值的操作求和。\n\n- **被调用者保存的寄存器：** 在被调用者返回之前，它必须恢复之前保存的被调用者保存的寄存器。这需要 $\\min(l, C)$ 次弹出操作。\n- **`return` 指令：** `return` 指令会隐式地从堆栈中弹出返回地址，以在调用者中恢复执行。这贡献了 $1$ 次弹出操作。\n- **调用者保存的寄存器：** 在被调用者返回后，调用者会恢复其保存的寄存器。这需要 $S$ 次弹出操作。\n- **参数清理：** 问题明确指出，调用者通过调整堆栈指针来释放用于参数的堆栈空间，而不是通过显式的弹出指令。因此，这贡献了 $0$ 次弹出操作。\n\n将这些贡献相加，得到弹出操作的总数：\n$$N_{\\text{pop}} = (\\text{被调用者保存}) + (\\text{返回地址}) + (\\text{调用者保存}) + (\\text{参数})$$\n$$N_{\\text{pop}} = \\min(l, C) + 1 + S + 0$$\n$$N_{\\text{pop}} = S + 1 + \\min(l, C)$$\n\n**3. 最终表达式**\n\n我们现在代入给定的常量值：$R=6$，$S=10$ 和 $C=6$。\n\n对于推入操作的总数：\n$$N_{\\text{push}} = 10 + \\max(0, a - 6) + 1 + \\min(l, 6)$$\n$$N_{\\text{push}} = 11 + \\max(0, a - 6) + \\min(l, 6)$$\n\n对于弹出操作的总数：\n$$N_{\\text{pop}} = 10 + 1 + \\min(l, 6)$$\n$$N_{\\text{pop}} = 11 + \\min(l, 6)$$\n\n结果表示为一个二元行向量 $\\begin{pmatrix} N_{\\text{push}}  N_{\\text{pop}} \\end{pmatrix}$。\n最终的表达式是：\n- 推入总数：$11 + \\max(0, a - 6) + \\min(l, 6)$\n- 弹出总数：$11 + \\min(l, 6)$", "answer": "$$\\boxed{\\begin{pmatrix} 11 + \\max(0, a - 6) + \\min(l, 6)  11 + \\min(l, 6) \\end{pmatrix}}$$", "id": "3669284"}, {"introduction": "在掌握了单次调用的栈开销分析后，让我们将这一技能应用于一个对资源极其敏感的真实场景：内存有限的嵌入式系统。在这个实践中，你将扮演一名系统程序员，面对防止灾难性栈溢出的挑战。通过综合考虑栈帧大小、对齐要求以及不可预测的系统中断，你将计算出递归函数的最大安全深度，确保程序在最坏情况下也能稳定运行。[@problem_id:3669359]", "problem": "一个微控制器使用随机存取存储器中由硬件支持的栈来实现子程序调用和返回。栈向低地址方向增长，并具有 $S$ 字节的固定连续容量。子程序调用会将一个返回地址压入栈中，而被调用者的序言（prologue）会为其局部变量和任何保存的寄存器分配栈帧。中断处理是向量化和抢占式的；进入中断时，硬件和中断处理程序的序言会将一个固定的上下文压入同一个栈中。应用程序二进制接口（ABI）在调用边界处对栈指针强制执行固定对齐，编译器通过按需填充每个被调用者的分配空间来满足此要求。\n\n基于这些基本原理，确定在最坏情况下保证不发生栈溢出的最大安全递归深度。对于一个特定的32位微控制器和编译后的代码，请使用以下具体参数：\n\n- 随机存取存储器中可用的总栈容量：$S = 2048$ 字节。\n- 调用指令压入的返回地址大小：$r = 4$ 字节。\n- 递归函数的软件分配帧大小（局部变量加保存的寄存器，不包括返回地址）：$f = 44$ 字节。\n- 调用边界处的栈对齐要求：$a = 8$ 字节。编译器将每次调用的总分配空间 $r + f$ 向上填充到不小于 $r + f$ 的最小 $a$ 的倍数。\n- 最大嵌套中断深度：$i = 3$。每个中断级别在栈上总共消耗 $h = 40$ 字节（硬件压入的上下文加上处理程序的序言/尾声保存的数据），与被中断代码的状态无关。\n- 在任何递归调用之前，C 运行时和主线程的非递归基线栈使用量：$b = 112$ 字节。\n- 必须始终保留 $g = 32$ 字节的保护裕量未使用，以应对异步潜在效应并满足安全认证要求。\n\n假设中断可以在递归过程中的任意点发生，并且最坏情况下的中断嵌套可能发生在递归的最深点。中断处理程序不调用该递归函数。不存在其他栈使用者。\n\n根据调用/返回和中断进入的栈语义，推导出一个递归深度 $d$ 为保证栈安全必须满足的不等式。从该不等式中，得出一个关于给定参数的最大安全递归深度 $d_{\\max}$ 的精确闭式表达式（作为整数函数），然后使用上述数值进行计算。将您的最终答案表示为单个整数。无需进行四舍五入。", "solution": "首先对问题陈述进行严格的验证过程，以确保其科学合理、提法得当且客观。\n\n逐字提取所提供的参数和条件如下：\n- 总栈容量：$S = 2048$ 字节。\n- 返回地址大小：$r = 4$ 字节。\n- 递归函数的软件分配帧大小：$f = 44$ 字节。\n- 栈对齐要求：$a = 8$ 字节。\n- 填充规则：每次调用的分配空间 $r + f$ 被向上填充到不小于 $r + f$ 的 $a$ 的最小倍数。\n- 最大嵌套中断深度：$i = 3$。\n- 每次中断的栈使用量：$h = 40$ 字节。\n- 递归前的基线栈使用量：$b = 112$ 字节。\n- 安全保护裕量：$g = 32$ 字节。\n- 架构字长：32位。\n- 最坏情况假设：最大中断嵌套发生在递归的最深点。\n\n该问题是有效的。它在科学上基于计算机体系结构和系统编程的原理，特别是关于过程调用和中断处理的栈管理。参数定义明确、内部一致，并且对于现代微控制器而言是切合实际的。目标陈述清晰，问题提法得当，根据给定约束可以得到一个唯一的整数解。它不违反任何无效性标准。\n\n解决方案通过对指定最坏情况下的总栈消耗进行建模来展开。其基本原则是，总栈使用量不得超过可用栈容量。\n\n首先，我们定义总可用栈空间。物理容量为 $S$，但必须保留 $g$ 字节的保护裕量不被使用。因此，最大可用栈空间 $S_{usable}$ 为：\n$$S_{usable} = S - g$$\n\n接下来，我们必须计算所有栈消耗的来源。总栈使用量 $U_{total}$ 是基线使用量、深度为 $d$ 的递归使用量以及嵌套中断的最坏情况使用量之和。\n\n基线使用量 $U_{base}$ 包括在进行任何递归调用之前C运行时和主线程上下文所占用的空间。这由下式给出：\n$$U_{base} = b$$\n\n必须计算单次递归调用的栈使用量 $s_{call}$。每次调用都涉及压入大小为 $r$ 的返回地址和分配大小为 $f$ 的函数帧。总的未对齐大小为 $r + f$。根据应用程序二进制接口（ABI），这个总和必须被填充以满足 $a$ 字节的对齐要求。每次调用实际消耗的栈空间是不小于 $r+f$ 的 $a$ 的最小倍数。这可以用向上取整函数表示：\n$$s_{call} = a \\times \\left\\lceil \\frac{r + f}{a} \\right\\rceil$$\n对于深度为 $d$ 的递归，递归调用所消耗的总栈空间 $U_{rec}(d)$ 为：\n$$U_{rec}(d) = d \\times s_{call}$$\n\n中断处理的最坏情况是，最大数量的嵌套中断 $i$ 发生在递归的最深点。每次中断消耗固定量的栈空间 $h$。因此，最坏情况下的中断栈使用量 $U_{int}$ 为：\n$$U_{int} = i \\times h$$\n\n在最坏中断条件下，深度为 $d$ 的递归的总栈使用量是这些组成部分的总和：\n$$U_{total}(d) = U_{base} + U_{rec}(d) + U_{int} = b + d \\times s_{call} + i \\times h$$\n\n为确保系统安全（即防止栈溢出），总使用量不得超过可用栈空间：\n$$U_{total}(d) \\le S_{usable}$$\n$$b + d \\times s_{call} + i \\times h \\le S - g$$\n\n我们需要找到满足此不等式的最大整数递归深度 $d_{\\max}$。我们首先分离出包含 $d$ 的项：\n$$d \\times s_{call} \\le S - g - b - i \\times h$$\n$$d \\le \\frac{S - g - b - i \\times h}{s_{call}}$$\n\n由于 $d$ 必须是整数，最大安全深度 $d_{\\max}$ 是右侧表达式的向下取整。代入 $s_{call}$ 的表达式，我们得到 $d_{\\max}$ 的通用闭式解：\n$$d_{\\max} = \\left\\lfloor \\frac{S - g - b - i \\times h}{a \\times \\left\\lceil \\frac{r+f}{a} \\right\\rceil} \\right\\rfloor$$\n\n现在，我们将给定的数值代入此表达式。\n参数如下：\n$S = 2048$, $g = 32$, $b = 112$, $i = 3$, $h = 40$, $r = 4$, $f = 44$, $a = 8$。\n\n首先，计算每次递归调用的栈消耗量 $s_{call}$：\n未对齐的大小为 $r + f = 4 + 44 = 48$ 字节。\n$$s_{call} = 8 \\times \\left\\lceil \\frac{48}{8} \\right\\rceil = 8 \\times \\lceil 6 \\rceil = 8 \\times 6 = 48 \\text{ 字节}$$\n在这种情况下，未对齐的大小已经是定对齐值 $a$ 的倍数，所以没有添加填充。\n\n接下来，计算可用于递归调用的总栈空间。这是可用栈空间减去基线使用量和最坏情况下的中断使用量。我们称之为 $S_{rec}$：\n$$S_{rec} = S - g - b - i \\times h = 2048 - 32 - 112 - (3 \\times 40)$$\n$$S_{rec} = 2048 - 32 - 112 - 120$$\n$$S_{rec} = 2048 - (32 + 112 + 120) = 2048 - 264 = 1784 \\text{ 字节}$$\n\n最后，我们确定可以容纳在此可用空间中的最大递归调用次数：\n$$d_{\\max} = \\left\\lfloor \\frac{S_{rec}}{s_{call}} \\right\\rfloor = \\left\\lfloor \\frac{1784}{48} \\right\\rfloor$$\n进行除法运算：\n$$\\frac{1784}{48} = \\frac{446}{12} = \\frac{223}{6} = 37.1666...$$\n最大整数深度是该值的向下取整：\n$$d_{\\max} = \\lfloor 37.1666... \\rfloor = 37$$\n\n因此，保证不发生栈溢出的最大安全递归深度是 $37$。", "answer": "$$\n\\boxed{37}\n$$", "id": "3669359"}, {"introduction": "在确保程序正确性的基础上，性能优化是软件工程的永恒主题。本练习将探讨一个精巧的ABI优化技术——“红区”（red zone），它允许叶函数（leaf function）在不显式移动栈指针的情况下使用栈空间。要安全地利用此特性，必须深刻理解同步代码流（如函数调用）与异步事件（如中断和信号）之间的本质区别。这个练习将挑战你对编译器、操作系统和硬件之间隐式约定的理解，揭示高级优化背后的安全边界。[@problem_id:3669339]", "problem": "考虑一个遵循 System V Advanced Micro Devices 64位 (AMD64) 应用程序二进制接口 (ABI) 的平台。指令集架构 (ISA) 指定了常规的过程调用和返回指令。在此 ISA 上，栈指针寄存器表示为 $RSP$，栈向低地址方向增长，过程调用指令 $CALL$ 会将 $RSP$ 减少 $8$ 字节并将返回地址存储在新的栈顶，而过程返回指令 $RET$ 会读取返回地址并将 $RSP$ 增加 $8$ 字节。ABI 额外定义了一个称为“红色区域”(red zone) 的区域，该区域位于 $RSP$ 下方 $128$ 字节处，在特定约束下可用于临时存储。信号由操作系统传递，硬件中断异步发生；两者都可以抢占用户模式代码。在某些环境中（例如，操作系统内核代码），中断可能在与被中断上下文相同的栈上执行；在此 ABI 的用户模式下，信号和中断不会写入被中断线程当前 $RSP$ 正下方的 $128$ 字节区域。\n\n一个叶函数 $f$ 完全在用户模式下执行，不调整 $RSP$，并且可能执行也可能不执行诸如 $CALL$ 和 $PUSH$ 之类的指令。另一种环境是内核模式代码，其中中断处理程序在与被中断代码相同的栈上执行。可以通过诸如 $sigaltstack$ 之类的机制建立一个备用信号栈，这会使信号处理程序在与被中断线程不同的栈上运行。\n\n以下哪个陈述正确地描述了何时可以安全使用红色区域，以及何时异步事件会使其相关假设失效？\n\nA. 在用户模式下，一个既不执行 $PUSH$ 也不执行 $CALL$ 且不调整 $RSP$ 的叶函数，可以安全地在地址 $[RSP - 128, RSP)$ 范围内存储最多 $128$ 字节，并且异步信号或中断不会破坏此存储。\n\nB. 在用户模式下，任何函数，即使在执行 $CALL$ 之后，都可以安全地依赖红色区域，因为中断和信号永远不会覆盖它。\n\nC. 在内核模式代码中，如果中断使用与被中断上下文相同的栈，那么依赖红色区域是不安全的，因为中断处理程序可能会将数据推入栈中，从而破坏 $RSP$ 下方的内存。\n\nD. 一个执行单个 $PUSH$ 但没有执行 $CALL$ 的用户模式函数仍然可以安全地使用红色区域，因为 $PUSH$ 只在 $RSP - 8$ 处写入，而红色区域是被保留的。\n\nE. 在用户模式下，通过 $sigaltstack$ 使用备用信号栈会使针对被中断函数原始栈的红色区域保证失效，从而使红色区域变得不安全。", "solution": "用户需要对问题陈述进行批判性验证，然后是详细的解决方案和对所提供选项的评估。\n\n### 问题验证\n\n**第1步：提取已知条件**\n- 平台：System V Advanced Micro Devices 64位 (AMD64) 应用程序二进制接口 (ABI)。\n- 指令集架构 (ISA)：包含常规的过程调用和返回指令。\n- 栈指针寄存器：$RSP$。\n- 栈增长方向：向低地址方向。\n- `CALL` 指令：将 $RSP$ 减少 $8$ 字节，并将返回地址存储在新的栈顶。\n- `RET` 指令：读取返回地址，并将 $RSP$ 增加 $8$ 字节。\n- 红色区域：$RSP$ 下方 $128$ 字节的一个区域（地址在 $[RSP - 128, RSP)$），可用于临时存储。\n- 用户模式异步事件：信号和中断不会写入被中断线程当前 $RSP$ 正下方的 $128$ 字节区域。\n- 内核模式异步事件：中断可能在与被中断上下文相同的栈上执行。\n- 叶函数 $f$ 的定义：在用户模式下执行，不调整 $RSP$，并且可能执行也可能不执行诸如 $CALL$ 和 $PUSH$ 之类的指令。\n- 备用信号栈：一种如 `sigaltstack` 的机制，使信号处理程序在不同的栈上运行。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据**：该问题在现实世界的计算机体系结构和操作系统原理（由 System V AMD64 ABI 体现）中有充分的依据。栈、调用/返回指令以及红色区域的定义是准确的。\n- **适定性**：该问题是适定的。它要求根据特定 ABI 的一组给定规则来评估几个陈述的正确性。所提供的信息足以确定每个选项的有效性。\n- **客观性**：该问题以客观、技术性的语言陈述。\n- **缺陷清单**：\n  1.  **科学或事实不健全**：所提供的规则与实际的 ABI 规范一致。\n  2.  **不可形式化或不相关**：该问题与计算机组织中的过程调用约定和栈管理主题直接相关。\n  3.  **不完整或矛盾的设定**：在提供的定义中存在一个微小的不一致之处：“一个叶函数 `$f$` ... 可能执行也可能不执行诸如 `$CALL$` 之类的指令”。在 ABI 的上下文中，一个进行 `$CALL$` 的函数根据定义就不是叶函数，因为作为叶函数的主要好处（避免栈帧设置）是建立在不调用其他会覆盖栈区域（包括红色区域）的函数的基础上的。然而，这似乎只是背景描述文字，因为选项本身定义了具体、不矛盾的场景（“一个既不执行 `$PUSH$` 也不执行 `$CALL$` 的叶函数”、“任何在用户模式下，即使在执行 `$CALL$` 之后的函数”等）。关于红色区域、信号和中断的核心、关键规则都陈述得清晰且一致。这个有缺陷的定义并不妨碍基于其他有效前提对选项进行严格分析。\n  4.  **不现实或不可行**：该场景是现实的。\n  5.  **不适定或结构不良**：除了上面提到的微小不一致之外，该问题结构良好。\n  6.  **伪深刻、琐碎或同义反复**：该问题并非琐碎；它要求对同步代码（如函数调用）和异步事件（如中断）在栈管理方面的责任划分有精确的理解。\n  7.  **超出科学可验证性**：这些声明可以对照官方 ABI 文档进行验证。\n\n**第3步：结论与行动**\n该问题是**有效的**。关于“叶函数”定义的微小不一致性被选项中提供的具体上下文所取代，这使得可以基于问题陈述中同样阐述的可靠原则进行严格评估。\n\n### 解决方案推导\n\n需要理解的核心原则是 System V AMD64 ABI 中“红色区域”保证的性质。红色区域是栈指针 `$RSP$` 正下方的 $128$ 字节内存区域。其保证是，该区域不会被操作系统分派的信号处理程序或中断处理程序*异步*地修改。这允许函数使用此空间来存储临时数据，而无需显式递减栈指针（即分配栈帧）的开销。\n\n这个保证有两个关键限制：\n1.  **它只针对异步事件。** 它不保护红色区域免受通过 `CALL` 指令进行的*同步*函数调用所覆盖。被调用的函数可以自由使用栈，这样做会覆盖其调用者的红色区域。\n2.  **它特定于用户模式代码。** ABI 规定内核在中断用户代码时必须遵守此约定。内核自身的内部代码不一定有此保证。如果在内核模式下发生中断，中断处理程序可能会使用相同的栈并覆盖 `$RSP$` 下方的区域。\n\n基于这些原则，我们可以评估每个选项。\n\n### 逐项选项分析\n\n**A. 在用户模式下，一个既不执行 $PUSH$ 也不执行 $CALL$ 且不调整 $RSP$ 的叶函数，可以安全地在地址 $[RSP - 128, RSP)$ 范围内存储最多 $128$ 字节，并且异步信号或中断不会破坏此存储。**\n- **分析**：这个陈述描述了红色区域优化的确切预期用例。该函数是一个`叶`函数（它不`CALL`其他函数）。它不执行`PUSH`或以其他方式修改`$RSP$`。因此，它的栈指针保持不变。问题明确指出了 ABI 的保证：“在此 ABI 的用户模式下，信号和中断不会写入被中断线程当前 `$RSP$` 正下方的 $128$ 字节区域。” 由于该函数不执行任何会使红色区域失效的操作（如`CALL`或修改`$RSP$`），它可以安全地使用这个 $128$ 字节的区域，并确信它不会被异步的硬件中断或操作系统信号所破坏。\n- **结论**：**正确**。\n\n**B. 在用户模式下，任何函数，即使在执行 $CALL$ 之后，都可以安全地依赖红色区域，因为中断和信号永远不会覆盖它。**\n- **分析**：这个陈述是错误的，因为它忽略了同步`CALL`指令的影响。当一个函数`F1`调用另一个函数`F2`时，`CALL`指令本身会将返回地址推入栈中，写入`$RSP - 8$`，这位于`F1`的红色区域内。随后，被调用者`F2`可以自由地分配自己的栈帧或使用自己的红色区域，这将覆盖`F1`放置在其红色区域中的数据。关于中断和信号的保证与同步调用的函数的操作无关。因此，一个函数依赖其红色区域内容在`CALL`调用后仍被保留是不安全的。\n- **结论**：**错误**。\n\n**C. 在内核模式代码中，如果中断使用与被中断上下文相同的栈，那么依赖红色区域是不安全的，因为中断处理程序可能会将数据推入栈中，从而破坏 $RSP$ 下方的内存。**\n- **分析**：红色区域是*用户模式* ABI 的一个约定，内核在从用户模式转换到内核模式时被设计为遵守这个约定。问题指出，在内核模式下，“中断可能在与被中断上下文相同的栈上执行”。在这样的环境中，当硬件中断发生时，CPU 和初始中断处理代码会将寄存器和状态推入当前栈以保存上下文。这些推栈操作会递减 `$RSP$` 并写入到中断前 `$RSP$` 正下方的内存位置。这正是红色区域所在的位置。因此，内核代码自身没有红色区域保护。\n- **结论**：**正确**。\n\n**D. 一个执行单个 $PUSH$ 但没有执行 $CALL$ 的用户模式函数仍然可以安全地使用红色区域，因为 $PUSH$ 只在 $RSP - 8$ 处写入，而红色区域是被保留的。**\n- **分析**：这个陈述是错误的。红色区域被定义为地址`[$RSP - 128, $RSP)`范围内的 $128$ 字节。它是一个相对于栈指针*当前*值的区域。`PUSH`指令会将`$RSP$`递减 $8$ 字节。如果一个函数相对于其初始`$RSP$`在红色区域中存储数据，比如在地址 `$RSP_{initial} - 100$`，然后执行一个`PUSH`，栈指针会变为 `$RSP_{new} = $RSP_{initial} - 8$。此时受保护的红色区域是 `[$RSP_{new} - 128, $RSP_{new})`，即 `[$RSP_{initial} - 136, $RSP_{initial} - 8)`。最初存储在 `$RSP_{initial} - 100` 的数据仍然在这个新的红色区域内。然而，`PUSH`指令本身会写入地址 `$RSP_{initial} - 8`，这位于原始红色区域 `[$RSP_{initial} - 128, $RSP_{initial})` 内。因此，`PUSH`操作本身就破坏了红色区域的一部分。在红色区域中管理数据同时又修改`$RSP$`是充满风险的，并且违反了该优化的简单契约。给出的理由是幼稚的，这种做法也是不安全的。\n- **结论**：**错误**。\n\n**E. 在用户模式下，通过 $sigaltstack$ 使用备用信号栈会使针对被中断函数原始栈的红色区域保证失效，从而使红色区域变得不安全。**\n- **分析**：这个陈述的说法与事实正好相反。`sigaltstack`机制使信号处理程序在一个独立的、预先配置的栈上执行。当一个信号被传递给使用备用栈的线程时，操作系统在调用处理程序之前会切换到那个备用栈。结果是，信号处理程序的栈操作（推入寄存器、分配局部变量）完全不影响被中断函数的原始栈。这将被中断函数的原始栈与信号处理程序完全隔离，使得红色区域（以及栈的其余部分）*更安全*，而不是更不安全。这个保证没有失效；相反，它通过一个更强的隔离机制得到了维护。\n- **结论**：**错误**。", "answer": "$$\\boxed{AC}$$", "id": "3669339"}]}