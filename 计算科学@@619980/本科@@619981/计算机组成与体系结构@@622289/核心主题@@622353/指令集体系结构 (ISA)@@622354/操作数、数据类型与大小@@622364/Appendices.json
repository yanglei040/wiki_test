{"hands_on_practices": [{"introduction": "在计算机科学中，高效地利用内存是至关重要的，尤其是在处理硬件寄存器或网络协议时。本练习将指导你亲手将多个小数据字段（称为位域）封装到一个32位字中，这是一个在底层编程中非常常见的任务。通过这个过程，你将掌握位掩码和位移操作的核心技能，并理解字节序（endianness）如何影响数据在内存中的存储方式。[@problem_id:3662512]", "problem": "一个计算机系统使用一个大小为 $32$ 位的固定宽度无符号字。位的编号从 $0$ (最低有效位 (LSB)) 到 $31$ (最高有效位 (MSB))。你需要为一个包含四个大小分别为 $3$、$5$、$6$ 和 $10$ 位的无符号字段设计一个紧凑布局，其余位保留并设置为零。该布局必须满足以下约束：\n\n- $3$ 位字段占据位 $[2:0]$。\n- $5$ 位字段紧随其后，占据位 $[7:3]$。\n- $6$ 位字段紧随其后，占据位 $[13:8]$。\n- $10$ 位字段紧随其后，占据位 $[23:14]$。\n- 位 $[31:24]$ 是保留位，必须设置为零。\n\n从二进制位置表示法以及位掩码和逻辑移位的定义等基本原理出发，推导每个字段和保留区域的位掩码。然后，使用你的掩码和移位操作，将以下无符号字段值打包到一个遵循上述布局的 $32$ 位字中：\n- $3$ 位字段值 $= 5$，\n- $5$ 位字段值 $= 17$，\n- $6$ 位字段值 $= 42$，\n- $10$ 位字段值 $= 777$。\n\n最后，解释如何将得到的 $32$ 位字在一个大端和一个小端机器上序列化到一个连续的 $4$ 字节内存缓冲区中，并明确指出每种情况下的四个序列化字节值。将最终打包的字表示为十进制无符号整数。无需四舍五入；请提供确切值。", "solution": "根据指定标准评估问题陈述的有效性。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 计算机系统字长：$32$ 位，无符号。\n- 位编号：$0$ (LSB) 到 $31$ (MSB)。\n- 字段 1：$3$ 位，占据位 $[2:0]$。值 $= 5$。\n- 字段 2：$5$ 位，占据位 $[7:3]$。值 $= 17$。\n- 字段 3：$6$ 位，占据位 $[13:8]$。值 $= 42$。\n- 字段 4：$10$ 位，占据位 $[23:14]$。值 $= 777$。\n- 保留字段：位 $[31:24]$ 是保留位，必须设置为零。\n- 任务 1：推导每个字段和保留区域的位掩码。\n- 任务 2：将给定的字段值打包到一个 $32$ 位字中。\n- 任务 3：解释如何将得到的字在一个大端和一个小端机器上序列化到一个 $4$ 字节缓冲区中，并指出每种情况下的序列化字节值。\n- 任务 4：将最终打包的字表示为十进制无符号整数。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学性：** 该问题牢固地植根于计算机组成和体系结构的基本原理，特别是整数表示、位运算（掩码、移位）和数据序列化（字节序）。这些都是该领域的标准概念。\n- **适定性：** 问题定义清晰，提供了所有必要的信息。\n    - 字段大小之和等于总字长：$3 + 5 + 6 + 10 + 8 = 32$ 位。\n    - 位范围是连续且不重叠的：$[2:0]$、$[7:3]$、$[13:8]$、$[23:14]$、$[31:24]$。它们共同覆盖了从 $0$ 到 $31$ 的所有位。\n    - 给定的字段值在字段的容量范围内：\n        - 字段 1（$3$ 位）：值 $5$。$5  2^3 = 8$。有效。\n        - 字段 2（$5$ 位）：值 $17$。$17  2^5 = 32$。有效。\n        - 字段 3（$6$ 位）：值 $42$。$42  2^6 = 64$。有效。\n        - 字段 4（$10$ 位）：值 $777$。$777  2^{10} = 1024$。有效。\n    - 这些约束的组合导出了一个唯一且可计算的解。\n- **客观性：** 问题以精确、客观的语言陈述，没有歧义或主观论断。\n\n**步骤 3：结论与行动**\n该问题是有效的，因为它科学合理、适定、客观，并且包含一个完整且一致的设置。将提供完整的解答。\n\n### 解答\n\n将数据打包到字段结构中的过程依赖于位置数字系统和位逻辑运算的原理。一个无符号 $32$ 位整数 $W$ 由总和 $W = \\sum_{i=0}^{31} b_i 2^i$ 表示，其中 $b_i \\in \\{0, 1\\}$ 是位置 $i$ 上的位的值。打包的核心操作是按位左移 (``) 和按位或 (`|`)。\n\n**1. 位掩码的推导**\n\n一个宽度为 $w$ 位、起始位位置为 $s$（字段的最低有效位）的位掩码，可以通过表达式 $(2^w - 1)  s$ 生成。项 $(2^w - 1)$ 创建了一个由 $w$ 个 1 组成的序列。左移 ` s` 将此序列移动到正确的位位置。\n\n- **字段 1 掩码 ($[2:0]$)**：宽度 $w=3$，起始位置 $s=0$。\n  掩码 $= (2^3 - 1)  0 = 7  0 = 7$。\n  十六进制表示：$0x7$。\n  二进制表示：$0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0111_2$。\n\n- **字段 2 掩码 ($[7:3]$)**：宽度 $w=5$，起始位置 $s=3$。\n  掩码 $= (2^5 - 1)  3 = 31  3 = 248$。\n  十六进制表示：$0xF8$。\n  二进制表示：$0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 1111\\ 1000_2$。\n\n- **字段 3 掩码 ($[13:8]$)**：宽度 $w=6$，起始位置 $s=8$。\n  掩码 $= (2^6 - 1)  8 = 63  8 = 16128$。\n  十六进制表示：$0x3F00$。\n  二进制表示：$0000\\ 0000\\ 0000\\ 0000\\ 0011\\ 1111\\ 0000\\ 0000_2$。\n\n- **字段 4 掩码 ($[23:14]$)**：宽度 $w=10$，起始位置 $s=14$。\n  掩码 $= (2^{10} - 1)  14 = 1023  14 = 16760832$。\n  十六进制表示：$0xFFC000$。\n  二进制表示：$0000\\ 0000\\ 1111\\ 1111\\ 1100\\ 0000\\ 0000\\ 0000_2$。\n\n- **保留字段掩码 ($[31:24]$)**：宽度 $w=8$，起始位置 $s=24$。\n  掩码 $= (2^8 - 1)  24 = 255  24 = 4278190080$。\n  十六进制表示：$0xFF000000$。\n  二进制表示：$1111\\ 1111\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000_2$。\n\n**2. 打包字段值**\n\n为了打包这些值，每个字段值都左移到其起始位位置。由于字段不重叠且输入值保证能容纳，最终打包的字 $W$ 是所有移位后分量的按位或。\n\n需要打包的值是：\n- $v_1 = 5$ ($101_2$) 用于字段 1 (起始位 $s_1=0$)。\n- $v_2 = 17$ ($10001_2$) 用于字段 2 (起始位 $s_2=3$)。\n- $v_3 = 42$ ($101010_2$) 用于字段 3 (起始位 $s_3=8$)。\n- $v_4 = 777$ ($1100001001_2$) 用于字段 4 (起始位 $s_4=14$)。\n- $v_5 = 0$ ($0_2$) 用于保留字段 (起始位 $s_5=24$)。\n\n打包后的字 $W$ 计算如下：\n$W = (v_1  s_1) | (v_2  s_2) | (v_3  s_3) | (v_4  s_4) | (v_5  s_5)$\n$W = (5  0) | (17  3) | (42  8) | (777  14) | (0  24)$\n\n我们来计算每个分量：\n- $(5  0) = 5 \\times 2^0 = 5$\n- $(17  3) = 17 \\times 2^3 = 17 \\times 8 = 136$\n- $(42  8) = 42 \\times 2^8 = 42 \\times 256 = 10752$\n- $(777  14) = 777 \\times 2^{14} = 777 \\times 16384 = 12730368$\n- $(0  24) = 0$\n\n将这些值相加得到最终打包字的十进制表示：\n$W = 5 + 136 + 10752 + 12730368 + 0 = 12741261$\n\n为了验证，我们通过在各自位置上连接字段的二进制值来构建 $W$ 的二进制表示：\n- 位 $[31:24]$ (保留): $00000000_2$\n- 位 $[23:14]$ (字段 4): $1100001001_2$\n- 位 $[13:8]$ (字段 3): $101010_2$\n- 位 $[7:3]$ (字段 2): $10001_2$\n- 位 $[2:0]$ (字段 1): $101_2$\n\n组装成一个 $32$ 位的字（从 MSB 到 LSB）：\n$W_{bin} = \\underbrace{00000000}_{[31:24]} \\underbrace{1100001001}_{[23:14]} \\underbrace{101010}_{[13:8]} \\underbrace{10001}_{[7:3]} \\underbrace{101}_{[2:0]}$\n\n为清晰起见，按字节分组：\n$W_{bin} = 00000000\\ 11000010\\ 01101010\\ 10001101_2$\n\n通过按半字节（4位组）分组转换为十六进制：\n$W_{hex} = \\underbrace{0000}_0 \\underbrace{0000}_0\\ \\underbrace{1100}_C \\underbrace{0010}_2\\ \\underbrace{0110}_6 \\underbrace{1010}_A\\ \\underbrace{1000}_8 \\underbrace{1101}_D$\n所以，$W = 0x00C26A8D$。\n\n将此十六进制值转换为十进制以确认我们的结果：\n$W = 12 \\times 16^5 + 2 \\times 16^4 + 6 \\times 16^3 + 10 \\times 16^2 + 8 \\times 16^1 + 13 \\times 16^0 = 12741261$。\n\n**3. 字节序和内存序列化**\n\n$32$ 位的打包字 $W = 0x00C26A8D$ 由四个 $8$ 位字节组成。我们从最高有效到最低有效标记它们：\n- 最高有效字节 (MSB): $0x00$\n- 字节 2: $0xC2$\n- 字节 1: $0x6A$\n- 最低有效字节 (LSB): $0x8D$\n\n字节序决定了这些字节在连续内存缓冲区中的存储顺序。\n\n- **大端序列化**：“大端”（最高有效字节）首先存储在最低的内存地址。对于一个从地址 $A$ 开始的缓冲区，字节顺序是：\n  - 地址 $A$: $0x00$\n  - 地址 $A+1$: $0xC2$\n  - 地址 $A+2$: $0x6A$\n  - 地址 $A+3$: $0x8D$\n  $4$ 字节的序列化序列是：$00, C2, 6A, 8D$。\n\n- **小端序列化**：“小端”（最低有效字节）首先存储在最低的内存地址。对于一个从地址 $A$ 开始的缓冲区，字节顺序是：\n  - 地址 $A$: $0x8D$\n  - 地址 $A+1$: $0x6A$\n  - 地址 $A+2$: $0xC2$\n  - 地址 $A+3$: $0x00$\n  $4$ 字节的序列化序列是：$8D, 6A, C2, 00$。\n\n要求的最终结果是打包后的字以十进制无符号整数表示。\n$W = 12741261$。", "answer": "$$\\boxed{12741261}$$", "id": "3662512"}, {"introduction": "处理器的指令集架构（ISA）定义了其可以执行的基本操作，但有时这些操作的细微差别会对程序的行为产生巨大影响，尤其是在处理有符号数时。本练习是一个思想实验，挑战你设计一个单一测试来区分算术右移和逻辑右移这两种不同的移位操作。这个过程将加深你对二进制补码表示法以及它如何与CPU的基本指令相互作用的理解。[@problem_id:3662568]", "problem": "一个黑盒算术逻辑单元 (ALU) 对一个 $n$ 位操作数执行右移操作。您不知道该移位是算术右移（符号扩展）还是逻辑右移（补零）。您可以提供一个以标准二进制补码形式编码的任意 $n$ 位操作数和一个移位计数 $k$，其中 $1 \\leq k  n$。该 ALU 返回一个 $n$ 位的结果，并将一个符号标志位设置为结果的最高有效位 (MSB)。设计一个单次测试，通过选择一个操作数，使其移位后的符号行为在两种可能性之间产生符号标志位的差异，从而区分这两种移位。然后，仅使用二进制补码编码以及算术和逻辑右移的标准定义，推导出此测试产生的逻辑右移结果与算术右移结果之间的精确有符号整数差值，并以 $n$ 和 $k$ 的函数闭式形式表示。您的最终答案必须是关于 $n$ 和 $k$ 的单个解析表达式。无需四舍五入。", "solution": "问题要求我们设计一个单次测试，以区分黑盒 ALU 执行的逻辑右移 (LSR) 和算术右移 (ASR)，然后为所选的测试用例推导这两种操作结果之间的有符号整数差值。\n\n首先，我们分析针对 $n$ 位操作数的两种移位操作的定义。逻辑右移 $k$ 位（表示为 LSR）将所有位向右移动 $k$ 个位置，丢弃 $k$ 个最低有效位，并在 $k$ 个最高有效位位置上填充零。算术右移 $k$ 位（表示为 ASR）也将所有位向右移动 $k$ 个位置，但它会用原始最高有效位 (MSB) 的副本填充 $k$ 个最高有效位位置，在二进制补码表示中，MSB 就是符号位。\n\n关键区别在于最高有效位位置的填充位。对于非负操作数，MSB 为 $0$。LSR 和 ASR 都会用 $0$ 填充空出的位。因此，对于任何非负操作数，LSR 和 ASR 的结果是相同的。为了区分它们，我们必须选择一个填充位不同的操作数。这就需要选择一个负操作数，其 MSB 为 $1$。\n\n对于负操作数，LSR 将用 $0$ 填充，导致新的 MSB 为 $0$（一个正数），因此符号标志位为 $0$。相反，ASR 将用 $1$ 填充（符号扩展），导致新的 MSB 为 $1$（一个负数），符号标志位为 $1$。符号标志位的差异提供了一个明确的测试。\n\n我们必须选择一个特定的 $n$ 位负操作数。一个典型且简单的选择是 $n$ 位二进制补码可表示的最小负数，即 $X_0 = -2^{n-1}$。$X_0$ 的二进制表示是一个 $1$ 后跟 $n-1$ 个零：\n$$\nX_0 = (100...0)_2\n$$\n让我们将逻辑移位结果的值表示为 $V_{LSR}$，算术移位结果的值表示为 $V_{ASR}$。我们需要求出差值 $V_{LSR} - V_{ASR}$。\n\n**1. 逻辑右移 (LSR) 结果**\n对 $X_0 = (100...0)_2$ 执行移位计数为 $k$（其中 $1 \\le k  n$）的 LSR 操作，会将各位向右移动，并在 $k$ 个最高有效位位置上填充 $0$。原始的 MSB，即位位置 $n-1$ 上的 $1$，被移到位置 $n-1-k$。所有其他位都是 $0$。\n我们称之为 $R_{LSR}$ 的结果 $n$ 位模式是：\n$$\nR_{LSR} = (\\underbrace{00...0}_{k \\text{ 个零}}1\\underbrace{00...0}_{n-k-1 \\text{ 个零}})_2\n$$\n$R_{LSR}$ 的 MSB 是 $0$，所以它表示一个正整数。其值由单个 '1' 位的位置决定，该位在索引 $n-k-1$ 处（LSB 的索引为 $0$）。因此，有符号整数值 $V_{LSR}$ 是：\n$$\nV_{LSR} = 1 \\times 2^{n-k-1} = 2^{n-k-1}\n$$\n此操作的符号标志位为 $0$。\n\n**2. 算术右移 (ASR) 结果**\n对 $X_0 = (100...0)_2$ 执行 $k$ 位的 ASR 操作，会将各位向右移动，并通过复制原始的 MSB（即 $1$）来填充 $k$ 个最高有效位。用二进制补码的算术定义来计算其值更简单：算术右移 $k$ 位等效于对有符号数进行向下取整的除法（floor division）$2^k$。\n因此，有符号整数值 $V_{ASR}$ 是：\n$$\nV_{ASR} = \\text{floor}\\left(\\frac{-2^{n-1}}{2^k}\\right) = \\text{floor}(-2^{n-1-k}) = -2^{n-1-k}\n$$\n此操作的符号标志位为 $1$。\n\n**3. 差值计算**\n现在我们可以计算两种操作结果之间的有符号整数差值：\n$$\nV_{LSR} - V_{ASR} = (2^{n-k-1}) - (-2^{n-1-k})\n$$\n$$\nV_{LSR} - V_{ASR} = 2^{n-k-1} + 2^{n-1-k} = 2 \\times 2^{n-1-k}\n$$\n$$\nV_{LSR} - V_{ASR} = 2^{n-k}\n$$", "answer": "$$\n\\boxed{2^{n-k}}\n$$", "id": "3662568"}, {"introduction": "从单个操作到完整的算法，理解数据在计算过程中的演变至关重要。本练习以一个常见的并行“位数统计”（population count）算法为例，要求你分析在算法的每个阶段需要多大的存储空间（累加器位宽）来保证中间结果不会溢出。这个实践将数据类型的“大小”这一概念与算法设计和硬件资源规划直接联系起来，展示了理论知识在解决实际工程问题中的应用。[@problem_id:3662552]", "problem": "一个处理器设计需要计算一个 $64$ 位寄存器操作数的置位计数 (population count)（即值为 $1$ 的位的数量），该计算通过一个平衡归约树完成。该树由 $8$ 位、$16$ 位和 $32$ 位段上的部分和组成，最终汇总成一个 $64$ 位的总和。该树的操作方式如下：$64$ 个输入位被划分为 $8$ 个连续的 $8$ 位组；每个 $8$ 位组被归约为其局部置位计数；然后将相邻的局部计数相加以形成 $16$ 位段计数；再将相邻的 $16$ 位段计数相加以形成 $32$ 位段计数；最后，将两个 $32$ 位段计数相加以获得 $64$ 位的置位计数。\n\n假设在树的每个节点，部分和都保存在一个无符号累加器寄存器中，该寄存器的大小恰好足以表示该部分和所有可能值的完整范围而不会溢出。你可以假设每个组合步骤都进行理想、精确的加法，并将每个部分和视为其所覆盖的输入段上置位位的精确计数。\n\n仅使用关于整数范围和二进制表示的基本原理（例如，$k$ 个独立单比特值的和在 $[0,k]$ 区间内，以及一个宽度为 $w$ 的无符号二进制寄存器可以精确表示从 $0$ 到 $2^{w}-1$ 的 $2^{w}$ 个不同值），确定如果在每个阶段的每个部分和都存储一次（即，计算 $8$ 位阶段的所有累加器、$16$ 位阶段的所有累加器、$32$ 位阶段的所有累加器以及最终的 $64$ 位和），整个树所需的累加器比特总数的最小值。\n\n请以精确整数形式提供最终答案，不带单位。", "solution": "该问题要求计算在指定的归约树中所有累加器所需的总比特数，该树用于计算一个 $64$ 位操作数的置位计数。核心原理是，对于表示一个 $k$ 比特段的置位计数的部分和，其最大可能值为 $k$。一个宽度为 $w$ 的无符号二进制累加器可以表示从 $0$ 到 $2^w-1$ 的整数。因此，为了无溢出地存储一个 $k$ 比特段的置位计数，累加器宽度 $w$ 必须是满足不等式 $2^w - 1 \\ge k$ 的最小整数。这等价于找到使 $2^w  k$ 成立的最小整数 $w$，可以正式写作 $w = \\lfloor \\log_2(k) \\rfloor + 1$。我们将把这个原理应用到所描述的归约树的每个阶段。\n\n该归约树有四个累加阶段：\n1.  $8$ 位段的部分和。\n2.  $16$ 位段的部分和。\n3.  $32$ 位段的部分和。\n4.  $64$ 位操作数的最终和。\n\n我们将计算每个阶段所需的累加器数量及其比特宽度。\n\n阶段 1：$8$ 位段的置位计数。\n$64$ 位操作数被划分为 $N_1 = \\frac{64}{8} = 8$ 个连续的 $8$ 位组。对每个组，计算其局部置位计数。\n一个 $8$ 位段的置位计数的最大值为 $k_1 = 8$。\n最小累加器宽度 $w_1$ 必须满足 $2^{w_1} - 1 \\ge 8$。\n对于 $w=3$，$2^3 - 1 = 7$，这不够。\n对于 $w=4$，$2^4 - 1 = 15$，这足够了。\n因此，此阶段的 $8$ 个累加器每个都必须有 $w_1 = 4$ 比特的宽度。\n此阶段的总比特数为 $B_1 = N_1 \\times w_1 = 8 \\times 4 = 32$。\n\n阶段 2：$16$ 位段的置位计数。\n这 $8$ 个局部计数两两组合，产生 $N_2 = \\frac{8}{2} = 4$ 个累加器。每个累加器表示原始操作数的一个 $16$ 位段的置位计数。\n一个 $16$ 位段的置位计数的最大值为 $k_2 = 16$。\n最小累加器宽度 $w_2$ 必须满足 $2^{w_2} - 1 \\ge 16$。\n对于 $w=4$，$2^4 - 1 = 15$，这不够。\n对于 $w=5$，$2^5 - 1 = 31$，这足够了。\n因此，此阶段的 $4$ 个累加器每个都必须有 $w_2 = 5$ 比特的宽度。\n此阶段的总比特数为 $B_2 = N_2 \\times w_2 = 4 \\times 5 = 20$。\n\n阶段 3：$32$ 位段的置位计数。\n前一阶段的 $4$ 个计数两两组合，产生 $N_3 = \\frac{4}{2} = 2$ 个累加器。每个累加器表示一个 $32$ 位段的置位计数。\n一个 $32$ 位段的置位计数的最大值为 $k_3 = 32$。\n最小累加器宽度 $w_3$ 必须满足 $2^{w_3} - 1 \\ge 32$。\n对于 $w=5$，$2^5 - 1 = 31$，这不够。\n对于 $w=6$，$2^6 - 1 = 63$，这足够了。\n因此，此阶段的 $2$ 个累加器每个都必须有 $w_3 = 6$ 比特的宽度。\n此阶段的总比特数为 $B_3 = N_3 \\times w_3 = 2 \\times 6 = 12$。\n\n阶段 4：$64$ 位总置位计数。\n前一阶段的 $2$ 个计数相加以产生最终结果，该结果存储在 $N_4 = \\frac{2}{2} = 1$ 个最终累加器中。这表示 $64$ 位操作数的总置位计数。\n这个最终计数的最大值为 $k_4 = 64$。\n最小累加器宽度 $w_4$ 必须满足 $2^{w_4} - 1 \\ge 64$。\n对于 $w=6$，$2^6 - 1 = 63$，这不够。\n对于 $w=7$，$2^7 - 1 = 127$，这足够了。\n因此，最终的累加器必须有 $w_4 = 7$ 比特的宽度。\n此阶段的总比特数为 $B_4 = N_4 \\times w_4 = 1 \\times 7 = 7$。\n\n为求得整个树所需的累加器比特总数的最小值，我们将各阶段的比特数相加。\n$B_{total} = B_1 + B_2 + B_3 + B_4$\n$B_{total} = 32 + 20 + 12 + 7$\n$B_{total} = 71$\n\n树中所有累加器所需的最小总比特数为 $71$。", "answer": "$$\\boxed{71}$$", "id": "3662552"}]}