{"hands_on_practices": [{"introduction": "链接器不仅是代码的合并者，更是内存布局的设计师。本练习将让你扮演链接器的角色，负责在内存中排列不同的程序段。你将学习如何满足每个段的对齐要求——这是影响性能和正确性的关键因素——同时通过策略性地排序来最小化空间浪费。[@problem_id:3654643]", "problem": "静态链接器接收多个输入节，这些节必须在内存中被连续地打包成一个单一的可加载段。对于每个节，链接器必须遵守其对齐约束：该节在内存中的起始地址必须是其对齐值的整数倍（即模其对齐值为零）。该段的基加载地址由操作系统（OS）加载器选择，并设为一个页面边界。在此场景中，假设可执行与可链接格式（ELF）段的基地址 $A_{0}$ 为 $0$，且 $A_{0}$ 已对齐到 $2^{12}$ 字节（即 $4096$ 字节）。链接器可以任意重排这些节。\n\n此背景下的基本定义和事实：\n- 一个对齐值为 $a$ 的节必须始于一个满足 $x \\equiv 0 \\pmod{a}$ 的地址 $x$。\n- 如果当前段尾偏移量为 $o$，下一个节的对齐值为 $a$，链接器可以插入 $p \\ge 0$ 字节的填充，使得 $o + p \\equiv 0 \\pmod{a}$；然后该节从 $o + p$ 开始放置，新的段尾偏移量变为 $o + p + s$，其中 $s$ 是该节的大小。\n- 本问题中所有的对齐值都是2的幂，并且都能整除 $4096$，因此对于所有给定的对齐值，$A_{0} \\equiv 0 \\pmod{a}$ 均成立。\n\n给定以下六个节；每个节 $i$ 都有大小 $s_{i}$ 和对齐要求 $a_{i}$，单位均为字节：\n- 节 $\\mathsf{X}$：$a_{\\mathsf{X}} = 1024$，$s_{\\mathsf{X}} = 1500$。\n- 节 $\\mathsf{Y}$：$a_{\\mathsf{Y}} = 512$，$s_{\\mathsf{Y}} = 2048$。\n- 节 $\\mathsf{Z}$：$a_{\\mathsf{Z}} = 256$，$s_{\\mathsf{Z}} = 700$。\n- 节 $\\mathsf{U}$：$a_{\\mathsf{U}} = 128$，$s_{\\mathsf{U}} = 512$。\n- 节 $\\mathsf{V}$：$a_{\\mathsf{V}} = 64$，$s_{\\mathsf{V}} = 1300$。\n- 节 $\\mathsf{W}$：$a_{\\mathsf{W}} = 32$，$s_{\\mathsf{W}} = 1100$。\n\n从 $A_{0} = 0$ 开始，计算一个最终的段布局，使得在满足对齐约束的条件下，插入的总填充量最小。您必须确定一个节的排序方式，以及该排序所隐含的偏移量和填充。然后计算最小可能总填充量（插入在各节之间的所有填充字节的总和）。最终答案以字节为单位表示。无需四舍五入。最终答案必须是单个数字。", "solution": "问题在于确定一组内存节的顺序，以最小化满足对齐约束所需的总填充量。目标是找到最小的可能总填充量。\n\n假设有 $n$ 个节。对于每个节 $i \\in \\{1, 2, \\dots, n\\}$，我们给定其大小 $s_i$ 和对齐值 $a_i$。节 $i$ 必须放置在内存地址 $addr_i$ 处，使得 $addr_i \\equiv 0 \\pmod{a_i}$。段的初始基地址为 $A_0 = 0$。\n\n当按顺序布局这些节时，设当前偏移量（前一个放置的节的结束地址）为 $o_{k-1}$。要放置下一个节 $k$，我们必须找到最小的起始地址 $addr_k$，使得 $addr_k \\ge o_{k-1}$ 且 $addr_k \\equiv 0 \\pmod{a_k}$。所需的填充 $p_k$ 为 $p_k = addr_k - o_{k-1}$。新的偏移量变为 $o_k = addr_k + s_k = o_{k-1} + p_k + s_k$。填充量可以通过模运算计算得出：\n$$p_k = (a_k - (o_{k-1} \\pmod{a_k})) \\pmod{a_k}$$\n对于给定的 $n$ 个节的排序，总填充量为 $P_{\\text{total}} = \\sum_{k=1}^{n} p_k$。\n\n问题要求找到一个使 $P_{\\text{total}}$ 最小化的排序。由于所有对齐值 $a_i$ 都是2的幂，一个已知的最优方法是使用贪心算法。该算法按对齐值降序排列这些节。其直觉是，具有更严格对齐要求（即更大的 $a_i$）的节被优先放置。这样做是有利的，因为初始偏移量为 $0$，它满足任何对齐约束，而后续的偏移量更有可能“自然地”对齐到较小的对齐值，从而最小化填充。一个对齐到 $2^N$ 的地址，对于任何 $M  N$，其本身也对齐到 $2^M$。\n\n给定的节如下：\n- 节 $\\mathsf{X}$：$a_{\\mathsf{X}} = 1024$，$s_{\\mathsf{X}} = 1500$。\n- 节 $\\mathsf{Y}$：$a_{\\mathsf{Y}} = 512$，$s_{\\mathsf{Y}} = 2048$。\n- 节 $\\mathsf{Z}$：$a_{\\mathsf{Z}} = 256$，$s_{\\mathsf{Z}} = 700$。\n- 节 $\\mathsf{U}$：$a_{\\mathsf{U}} = 128$，$s_{\\mathsf{U}} = 512$。\n- 节 $\\mathsf{V}$：$a_{\\mathsf{V}} = 64$，$s_{\\mathsf{V}} = 1300$。\n- 节 $\\mathsf{W}$：$a_{\\mathsf{W}} = 32$，$s_{\\mathsf{W}} = 1100$。\n\n按对齐值降序排列这些节，得到序列：$\\mathsf{X}$、$\\mathsf{Y}$、$\\mathsf{Z}$、$\\mathsf{U}$、$\\mathsf{V}$、$\\mathsf{W}$。我们现在来计算这个最优排序的总填充量。初始偏移量为 $o_0 = A_0 = 0$。总填充量初始化为 $P = 0$。\n\n1.  **放置节 $\\mathsf{X}$**：\n    -   当前偏移量 $o_{\\text{prev}} = 0$。\n    -   对齐值 $a_{\\mathsf{X}} = 1024$。大小 $s_{\\mathsf{X}} = 1500$。\n    -   填充 $p_{\\mathsf{X}} = (1024 - (0 \\pmod{1024})) \\pmod{1024} = 0$。\n    -   $\\mathsf{X}$ 的起始地址是 $0 + 0 = 0$。\n    -   新偏移量 $o_1 = 0 + 0 + 1500 = 1500$。\n    -   总填充量 $P = 0 + 0 = 0$。\n\n2.  **放置节 $\\mathsf{Y}$**：\n    -   当前偏移量 $o_{\\text{prev}} = o_1 = 1500$。\n    -   对齐值 $a_{\\mathsf{Y}} = 512$。大小 $s_{\\mathsf{Y}} = 2048$。\n    -   $1500 \\pmod{512} = 476$。\n    -   填充 $p_{\\mathsf{Y}} = (512 - 476) \\pmod{512} = 36$。\n    -   $\\mathsf{Y}$ 的起始地址是 $1500 + 36 = 1536$。（$1536 = 3 \\times 512$）。\n    -   新偏移量 $o_2 = 1536 + 2048 = 3584$。\n    -   总填充量 $P = 0 + 36 = 36$。\n\n3.  **放置节 $\\mathsf{Z}$**：\n    -   当前偏移量 $o_{\\text{prev}} = o_2 = 3584$。\n    -   对齐值 $a_{\\mathsf{Z}} = 256$。大小 $s_{\\mathsf{Z}} = 700$。\n    -   $3584 \\pmod{256} = 0$ 因为 $3584 = 14 \\times 256$。\n    -   填充 $p_{\\mathsf{Z}} = (256 - 0) \\pmod{256} = 0$。\n    -   $\\mathsf{Z}$ 的起始地址是 $3584 + 0 = 3584$。\n    -   新偏移量 $o_3 = 3584 + 700 = 4284$。\n    -   总填充量 $P = 36 + 0 = 36$。\n\n4.  **放置节 $\\mathsf{U}$**：\n    -   当前偏移量 $o_{\\text{prev}} = o_3 = 4284$。\n    -   对齐值 $a_{\\mathsf{U}} = 128$。大小 $s_{\\mathsf{U}} = 512$。\n    -   $4284 \\pmod{128} = 60$ 因为 $4284 = 33 \\times 128 + 60$。\n    -   填充 $p_{\\mathsf{U}} = (128 - 60) \\pmod{128} = 68$。\n    -   $\\mathsf{U}$ 的起始地址是 $4284 + 68 = 4352$。（$4352 = 34 \\times 128$）。\n    -   新偏移量 $o_4 = 4352 + 512 = 4864$。\n    -   总填充量 $P = 36 + 68 = 104$。\n\n5.  **放置节 $\\mathsf{V}$**：\n    -   当前偏移量 $o_{\\text{prev}} = o_4 = 4864$。\n    -   对齐值 $a_{\\mathsf{V}} = 64$。大小 $s_{\\mathsf{V}} = 1300$。\n    -   $4864 \\pmod{64} = 0$ 因为 $4864 = 76 \\times 64$。\n    -   填充 $p_{\\mathsf{V}} = (64 - 0) \\pmod{64} = 0$。\n    -   $\\mathsf{V}$ 的起始地址是 $4864 + 0 = 4864$。\n    -   新偏移量 $o_5 = 4864 + 1300 = 6164$。\n    -   总填充量 $P = 104 + 0 = 104$。\n\n6.  **放置节 $\\mathsf{W}$**：\n    -   当前偏移量 $o_{\\text{prev}} = o_5 = 6164$。\n    -   对齐值 $a_{\\mathsf{W}} = 32$。大小 $s_{\\mathsf{W}} = 1100$。\n    -   $6164 \\pmod{32} = 20$ 因为 $6164 = 192 \\times 32 + 20$。\n    -   填充 $p_{\\mathsf{W}} = (32 - 20) \\pmod{32} = 12$。\n    -   $\\mathsf{W}$ 的起始地址是 $6164 + 12 = 6176$。（$6176 = 193 \\times 32$）。\n    -   新偏移量 $o_6 = 6176 + 1100 = 7276$。\n    -   总填充量 $P = 104 + 12 = 116$。\n\n最终布局的总大小为 $7276$ 字节。各节大小之和为 $1500+2048+700+512+1300+1100 = 7160$ 字节。总填充量为 $7276 - 7160 = 116$ 字节，这与单独计算的填充值之和相符：$0 + 36 + 0 + 68 + 0 + 12 = 116$。\n\n最小可能总填充量为 $116$ 字节。", "answer": "$$\\boxed{116}$$", "id": "3654643"}, {"introduction": "一旦布局确定，链接器的下一个关键任务是重定位：用最终的内存地址填补代码和数据中的占位符。这个动手编码实践将精确模拟这一过程。通过计算绝对地址和PC相对地址的重定位，你将具体理解符号引用是如何被转换成可执行的机器码的。[@problem_id:3654640]", "problem": "你必须编写一个完整、可运行的程序，该程序根据自定义的链接器脚本模拟链接器执行的地址分配和重定位值计算。程序将根据可执行与可链接格式（ELF）中使用的节、符号和重定位的公认含义，纯粹基于整数地址算术进行操作。该脚本固定了代码节（$TEXT$）和数据节（$DATA$）的基地址，任务是计算绝对符号地址和重定位补丁值。你还必须验证某些重定位值是否适合预期的机器字长，并验证对齐约束。\n\n计算基础必须遵循系统链接器中使用的核心定义：\n- 节的基地址由链接器脚本规定。\n- 符号带有相对于节的偏移量。\n- 重定位描述了如何计算一个补丁值，该值将被写入特定的引用位置。对于绝对重定位，目标符号的绝对地址与一个加数组合。对于程序计数器相对重定位，目标符号的绝对地址与一个引用地址进行比较，并考虑一个加数和一个（依赖于架构的）偏差，以产生一个旨在适应指定字宽的有符号值。\n\n使用以下参数。\n\n节基地址和对齐：\n- $B_{\\text{text}} = 0x400000$。\n- $B_{\\text{data}} = 0x600000$。\n- 两个节的对齐要求：$A_{\\text{align}} = 0x1000$。\n\n符号（每个都由一个节和一个节相对偏移量给出）：\n- $s_{\\text{foo}}$：在 $TEXT$ 中，偏移量 $0x120$。\n- $s_{\\text{bar}}$：在 $TEXT$ 中，偏移量 $0x1FFE$。\n- $s_{\\text{baz}}$：在 $DATA$ 中，偏移量 $0x30$。\n- $s_{\\text{qux}}$：在 $DATA$ 中，偏移量 $0x10010$。\n\n重定位（每个都指定一个类型、一个目标符号、引用位置的节和偏移量、一个偏差 $b$ 和一个加数 $a$）：\n- $R_1$：类型 $REL32$（有符号 $32$ 位相对），目标 $s_{\\text{foo}}$，引用在 $TEXT$ 中，偏移量 $0x200$，偏差 $b=4$，加数 $a=0$。\n- $R_2$：类型 $REL32$，目标 $s_{\\text{bar}}$，引用在 $TEXT$ 中，偏移量 $0x1FF0$，偏差 $b=4$，加数 $a$ 的选择使得最终计算出的重定位值等于 $2^{31}-1$。\n- $R_3$：类型 $ABS64$（绝对 $64$ 位），目标 $s_{\\text{baz}}$，引用在 $DATA$ 中，偏移量 $0x8$（引用位置不影响绝对计算），加数 $a=0x10$。\n- $R_4$：类型 $REL32$，目标 $s_{\\text{baz}}$，引用在 $TEXT$ 中，偏移量 $0x300$，偏差 $b=4$，加数 $a=0$。\n- $R_5$：类型 $REL32$，目标 $s_{\\text{qux}}$，引用在 $TEXT$ 中，偏移量 $0x10$，偏差 $b=4$，加数 $a$ 的选择使得最终计算出的重定位值等于 $2^{31}$。\n- $R_6$：类型 $REL32$，目标 $s_{\\text{foo}}$，引用在 $TEXT$ 中，偏移量 $0x11C$，偏差 $b=4$，加数 $a=0$。\n\n计算目标：\n1. 计算符号 $s_{\\text{foo}}, s_{\\text{bar}}, s_{\\text{baz}}, s_{\\text{qux}}$ 的绝对地址。\n2. 对于每个重定位 $R_i$，计算其补丁值并验证该值是否适合其预定宽度。\n   - 对于 $REL32$，该值必须在有符号 $32$ 位范围内，即必须满足 $-2^{31} \\le V \\le 2^{31}-1$。\n   - 对于 $ABS64$，将计算视为一个无符号 $64$ 位绝对地址加上加数；对于此测试套件，如果计算出的值可以用 $64$ 位算术表示，则认为适配检查为真。\n\n3. 验证节对齐：报告 $B_{\\text{text}}$ 和 $B_{\\text{data}}$ 是否是 $A_{\\text{align}}$ 的倍数。\n\n测试套件覆盖要求：\n- 一般情况：$R_1$ 和 $R_4$ 覆盖跨节和节内的典型相对重定位。\n- 边界条件：$R_2$ 必须精确产生 $2^{31}-1$。\n- 边缘情况溢出：$R_5$ 必须精确产生 $2^{31}$，这个值不适合有符号 $32$ 位字，并且必须被标记为不适配。\n- 零值情况：$R_6$ 必须精确产生 $0$。\n- 绝对重定位：$R_3$ 覆盖带有非零加数的 $ABS64$。\n- 对齐检查确保基地址遵循 $A_{\\text{align}}$。\n\n要求的最终输出格式：\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，没有空格，顺序完全如下：\n$[A_{\\text{foo}},A_{\\text{bar}},A_{\\text{baz}},A_{\\text{qux}},V_1,F_1,V_2,F_2,V_3,F_3,V_4,F_4,V_5,F_5,V_6,F_6,Align_{\\text{text}},Align_{\\text{data}}]$\n其中每个 $A_{\\cdot}$ 是符号的绝对地址（整数），每个 $V_i$ 是计算出的重定位值（整数），每个 $F_i$ 是重定位的布尔适配指示符（$1$ 表示真，$0$ 表示假），$Align_{\\text{text}}$ 和 $Align_{\\text{data}}$ 是指示 $B_{\\text{text}}$ 和 $B_{\\text{data}}$ 是否是 $A_{\\text{align}}$ 倍数的布尔值。\n\n不允许用户输入；程序必须嵌入上述参数并产生唯一的必需输出行。", "solution": "该问题要求根据一组给定的节基址、符号偏移和重定位条目，计算符号地址和重定位补丁值，就像链接器所做的那样。还必须检查节对齐的有效性以及重定位值在指定整数宽度内的适配性。该问题定义明确，并基于计算机体系结构和系统编程的标准原则。\n\n控制计算的基本公式如下：\n\n1.  **绝对符号地址**：符号的绝对地址，表示为 $A_{\\text{symbol}}$，是通过将其节相对偏移量 $O_{\\text{symbol}}$ 与其所在节的基地址 $B_{\\text{section}}$ 相加来计算的。\n    $$A_{\\text{symbol}} = B_{\\text{section}} + O_{\\text{symbol}}$$\n\n2.  **绝对重定位值（$ABS$ 类型）**：绝对重定位的补丁值 $V$ 是目标符号的绝对地址 $A_{\\text{target}}$ 加上一个常量加数 $a$。\n    $$V = A_{\\text{target}} + a$$\n\n3.  **相对重定位值（$REL$ 类型）**：程序计数器（PC）相对重定位的补丁值 $V$ 是目标符号的绝对地址 $A_{\\text{target}}$ 与引用位置的绝对地址 $P_{\\text{ref}}$ 之间的差，并由一个加数 $a$ 和一个架构偏差 $b$ 进行调整。引用地址 $P_{\\text{ref}}$ 是引用节的基地址 $B_{\\text{ref\\_section}}$ 和引用偏移量 $O_{\\text{ref}}$ 的和。\n    $$P_{\\text{ref}} = B_{\\text{ref\\_section}} + O_{\\text{ref}}$$\n    $$V = A_{\\text{target}} - P_{\\text{ref}} + a - b$$\n\n问题陈述中提供的参数如下：\n\n**节参数：**\n-   $TEXT$ 节的基地址：$B_{\\text{text}} = 0x400000$\n-   $DATA$ 节的基地址：$B_{\\text{data}} = 0x600000$\n-   对齐要求：$A_{\\text{align}} = 0x1000$\n\n**符号定义（符号：节，偏移量）：**\n-   $s_{\\text{foo}}$: $TEXT$, $O_{\\text{foo}} = 0x120$\n-   $s_{\\text{bar}}$: $TEXT$, $O_{\\text{bar}} = 0x1FFE$\n-   $s_{\\text{baz}}$: $DATA$, $O_{\\text{baz}} = 0x30$\n-   $s_{\\text{qux}}$: $DATA$, $O_{\\text{qux}} = 0x10010$\n\n**重定位定义：** 对于 $REL32$ 重定位，要求值 $V$ 在范围 $[-2^{31}, 2^{31}-1]$ 内。\n\n---\n\n**第 1 步：计算绝对符号地址**\n\n使用公式 $A = B + O$：\n-   $A_{\\text{foo}} = B_{\\text{text}} + O_{\\text{foo}} = 0x400000 + 0x120 = 0x400120 = 4,194,592$\n-   $A_{\\text{bar}} = B_{\\text{text}} + O_{\\text{bar}} = 0x400000 + 0x1FFE = 0x401FFE = 4,202,494$\n-   $A_{\\text{baz}} = B_{\\text{data}} + O_{\\text{baz}} = 0x600000 + 0x30 = 0x600030 = 6,291,504$\n-   $A_{\\text{qux}} = B_{\\text{data}} + O_{\\text{qux}} = 0x600000 + 0x10010 = 0x610010 = 6,357,008$\n\n---\n\n**第 2 步：计算重定位值并检查适配性**\n\n-   **重定位 $R_1$ ($REL32$):**\n    -   目标：$s_{\\text{foo}}$，因此 $A_{\\text{target}} = A_{\\text{foo}} = 0x400120$。\n    -   引用：$TEXT$ 节，偏移量 $0x200$，因此 $P_{\\text{ref}} = B_{\\text{text}} + 0x200 = 0x400200$。\n    -   参数：$a_1=0$, $b_1=4$。\n    -   值：$V_1 = A_{\\text{foo}} - P_{\\text{ref}} + a_1 - b_1 = 0x400120 - 0x400200 - 4 = -0xE0 - 4 = -224 - 4 = -228$。\n    -   适配性 ($F_1$): $-2^{31} \\le -228 \\le 2^{31}-1$。这是真的。$F_1 = 1$。\n\n-   **重定位 $R_2$ ($REL32$):**\n    -   问题陈述指明，选择的加数使得最终值 $V_2$ 为 $2^{31} - 1$。\n    -   值：$V_2 = 2^{31} - 1 = 2,147,483,647$。\n    -   适配性 ($F_2$): $-2^{31} \\le 2^{31}-1 \\le 2^{31}-1$。这是真的。$F_2 = 1$。\n\n-   **重定位 $R_3$ ($ABS64$):**\n    -   目标：$s_{\\text{baz}}$，因此 $A_{\\text{target}} = A_{\\text{baz}} = 0x600030$。\n    -   参数：$a_3=0x10$。\n    -   值：$V_3 = A_{\\text{baz}} + a_3 = 0x600030 + 0x10 = 0x600040 = 6,291,520$。\n    -   适配性 ($F_3$)：该值可以表示为无符号 $64$ 位整数。这是真的。$F_3 = 1$。\n\n-   **重定位 $R_4$ ($REL32$):**\n    -   目标：$s_{\\text{baz}}$，因此 $A_{\\text{target}} = A_{\\text{baz}} = 0x600030$。\n    -   引用：$TEXT$ 节，偏移量 $0x300$，因此 $P_{\\text{ref}} = B_{\\text{text}} + 0x300 = 0x400300$。\n    -   参数：$a_4=0$, $b_4=4$。\n    -   值：$V_4 = A_{\\text{baz}} - P_{\\text{ref}} + a_4 - b_4 = 0x600030 - 0x400300 - 4 = 0x1FFD30 - 4 = 2,096,432 - 4 = 2,096,428$。\n    -   适配性 ($F_4$): $-2^{31} \\le 2,096,428 \\le 2^{31}-1$。这是真的。$F_4 = 1$。\n\n-   **重定位 $R_5$ ($REL32$):**\n    -   问题陈述指明，选择的加数使得最终值 $V_5$ 为 $2^{31}$。\n    -   值：$V_5 = 2^{31} = 2,147,483,648$。\n    -   适配性 ($F_5$)：条件是 $-2^{31} \\le 2^{31} \\le 2^{31}-1$。这是假的，因为 $2^{31} > 2^{31}-1$。$F_5 = 0$。\n\n-   **重定位 $R_6$ ($REL32$):**\n    -   目标：$s_{\\text{foo}}$，因此 $A_{\\text{target}} = A_{\\text{foo}} = 0x400120$。\n    -   引用：$TEXT$ 节，偏移量 $0x11C$，因此 $P_{\\text{ref}} = B_{\\text{text}} + 0x11C = 0x40011C$。\n    -   参数：$a_6=0$, $b_6=4$。\n    -   值：$V_6 = A_{\\text{foo}} - P_{\\text{ref}} + a_6 - b_6 = 0x400120 - 0x40011C - 4 = 0x4 - 4 = 0$。\n    -   适配性 ($F_6$): $-2^{31} \\le 0 \\le 2^{31}-1$。这是真的。$F_6 = 1$。\n\n---\n\n**第 3 步：验证节对齐**\n\n对齐要求是每个节的基地址必须是 $A_{\\text{align}} = 0x1000$ 的倍数。\n\n-   **$TEXT$ 节对齐 ($Align_{\\text{text}}$):**\n    -   检查 $B_{\\text{text}}$ 是否是 $A_{\\text{align}}$ 的倍数。\n    -   $0x400000 \\pmod{0x1000} = 0$。条件满足。$Align_{\\text{text}} = 1$。\n\n-   **$DATA$ 节对齐 ($Align_{\\text{data}}$):**\n    -   检查 $B_{\\text{data}}$ 是否是 $A_{\\text{align}}$ 的倍数。\n    -   $0x600000 \\pmod{0x1000} = 0$。条件满足。$Align_{\\text{data}} = 1$。\n\n---\n\n**综合结果**\n\n计算出的值是：\n-   $A_{\\text{foo}} = 4,194,592$\n-   $A_{\\text{bar}} = 4,202,494$\n-   $A_{\\text{baz}} = 6,291,504$\n-   $A_{\\text{qux}} = 6,357,008$\n-   $V_1 = -228$, $F_1 = 1$\n-   $V_2 = 2,147,483,647$, $F_2 = 1$\n-   $V_3 = 6,291,520$, $F_3 = 1$\n-   $V_4 = 2,096,428$, $F_4 = 1$\n-   $V_5 = 2,147,483,648$, $F_5 = 0$\n-   $V_6 = 0$, $F_6 = 1$\n-   $Align_{\\text{text}} = 1$\n-   $Align_{\\text{data}} = 1$", "answer": "[4194592,4202494,6291504,6357008,-228,1,2147483647,1,6291520,1,2096428,1,2147483648,0,0,1,1,1]", "id": "3654640"}, {"introduction": "现代软件严重依赖共享库，动态加载器必须在运行时将它们组装起来。这会形成一个复杂的依赖网络，其中甚至可能包含循环。本练习挑战你分析这样一个依赖图，并追踪一个复杂的加载器如何检测和处理这些循环依赖，以确保程序能正确加载。[@problem_id:3654576]", "problem": "一个可执行与可链接格式（ELF）的进程加载器必须通过查询主可执行文件以及每个已加载的共享对象的动态表条目标签 $DT\\_NEEDED$ 来决定加载和初始化共享对象的顺序。考虑一个基于以下核心定义和事实的简化但现实的加载器模型：构建一个有向图，其中每个对象是一个顶点，如果对象 $u$ 在其 $DT\\_NEEDED$ 数组中列出了对象 $v$，则存在一条有向边 $u \\rightarrow v$；拓扑序是一种顶点的线性排序，使得对于每条有向边 $u \\rightarrow v$，顶点 $u$ 都排在顶点 $v$ 之前；有向环的存在使得无法对所有顶点进行严格的拓扑排序；强连通分量（SCC）是顶点的一个最大子集，其中每个顶点都可以从该子集中的任何其他顶点到达；将每个SCC收缩成一个节点会产生一个有向无环图（DAG），该图允许进行拓扑排序。\n\n假设存在以下场景。有一个可执行文件 $X$ 和共享对象 $A$、$B$、$C$、$D$、$E$。$DT\\_NEEDED$ 列表按如下所示从左到右读取和处理：\n- $X : [A, B]$\n- $A : [C, E]$\n- $B : [C, D]$\n- $C : [D]$\n- $D : [A]$\n- $E : [\\ ]$ (空)\n\n加载器实现了两个变体：\n- 变体 $L\\_0$ 仅基于共享对象构建有向图（忽略从 $X$ 出发的边），尝试使用 Kahn 算法基于顶点的入度进行拓扑排序，并且如果在所有顶点都被输出之前的任何时刻，不再存在入度为 $0$ 的顶点，则因检测到循环而中止。\n- 变体 $L\\_1$ 从 $X$ 开始构建完整的有向图，在沿着 $DT\\_NEEDED$ 边进行遍历时，通过带有颜色标记（白/灰/黑）的深度优先搜索（DFS）来检测循环，将每个强连通分量（SCC）收缩成一个单一节点，对收缩后的有向无环图（DAG）进行拓扑排序，并在每个SCC内部，按照从 $X$ 开始并从左到右扫描每个 $DT\\_NEEDED$ 列表的DFS过程中首次发现的顺序来排列其成员。\n\n哪个选项正确地描述了由循环的 $DT\\_NEEDED$ 依赖关系引起的失败情况、检测方法，以及由变体 $L\\_1$ 生成的一个有效的共享对象加载/初始化顺序？\n\nA. 共享对象中唯一的有向环是 $\\{A, C, D\\}$。变体 $L\\_0$ 将首先移除 $B$（唯一入度为 $0$ 的顶点），然后因为所有剩余顶点的入度都大于 $0$ 而因循环错误停止。变体 $L\\_1$ 在探索 $D \\rightarrow A$ 时通过一个DFS后向边检测到该循环，收缩 $\\{A, C, D\\}$，并为共享对象输出一个有效的顺序 $[B, A, C, D, E]$。\n\nB. 共享对象中唯一的有向环是 $\\{B, C, D\\}$。变体 $L\\_0$ 成功运行且无错误，一个有效的顺序是 $[A, B, C, D, E]$。变体 $L\\_1$ 报告没有循环并生成相同的顺序。\n\nC. 存在一个有向环 $\\{A, C, D\\}$，但变体 $L\\_0$ 会在输出任何顶点之前立即中止，因为没有顶点的入度为 $0$。变体 $L\\_1$ 必须将 $E$ 放在 $A$ 之前以打破循环，从而产生顺序 $[E, B, A, C, D]$。\n\nD. 唯一的循环是 $\\{A, D\\}$。变体 $L\\_0$ 在中止前输出 $[E, C]$。变体 $L\\_1$ 收缩 $\\{A, D\\}$ 并且为了遵循 $DT\\_NEEDED$ 从左到右的扫描顺序，必须输出 $[A, D, C, B, E]$。", "solution": "为了解决这个问题，我们需要分步分析两个加载器变体的行为。\n\n首先，我们根据给定的依赖关系构建共享对象的依赖图。边表示“需要”的关系：\n- $A \\rightarrow C$\n- $A \\rightarrow E$\n- $B \\rightarrow C$\n- $B \\rightarrow D$\n- $C \\rightarrow D$\n- $D \\rightarrow A$\n\n通过观察这些边，我们可以识别出路径 $A \\rightarrow C \\rightarrow D \\rightarrow A$，这构成了一个有向环。这个环中的顶点 $\\{A, C, D\\}$ 形成一个强连通分量 (SCC)。\n\n**分析加载器变体 $L_0$：**\n\n$L_0$ 使用 Kahn 算法在仅包含共享对象的图 $\\{A, B, C, D, E\\}$ 上进行拓扑排序。\n1.  **计算初始入度**：\n    -   入度($A$) = 1 (来自 $D$)\n    -   入度($B$) = 0\n    -   入度($C$) = 2 (来自 $A$, $B$)\n    -   入度($D$) = 2 (来自 $B$, $C$)\n    -   入度($E$) = 1 (来自 $A$)\n2.  **算法执行**：\n    -   算法从入度为 0 的顶点开始。在我们的图中，只有顶点 $B$ 的入度为 0。\n    -   $L_0$ 将 $B$ 加入排序列表，并“移除” $B$ 及其出边 ($B \\rightarrow C$, $B \\rightarrow D$)。\n    -   更新 $C$ 和 $D$ 的入度：入度($C$) 变为 $2-1=1$，入度($D$) 变为 $2-1=1$。\n    -   此时，剩余顶点 $\\{A, C, D, E\\}$ 的入度分别为：入度($A$)=1, 入度($C$)=1, 入度($D$)=1, 入度($E$)=1。\n    -   没有顶点的入度为 0，但图中仍有未排序的顶点。因此，Kahn 算法检测到循环并中止。\n\n这个分析与选项 A 中对 $L_0$ 的描述相符：它首先处理 $B$，然后因循环而停止。\n\n**分析加载器变体 $L_1$：**\n\n$L_1$ 从可执行文件 $X$ 开始执行深度优先搜索 (DFS)，并处理循环。\n1.  **DFS 遍历和循环检测**：\n    -   从 $X$ 开始，按顺序处理其依赖 $[A, B]$。\n    -   首先探索 $A$。路径为 $X \\rightarrow A \\rightarrow C \\rightarrow D$。\n    -   当从 $D$ 探索其依赖 $[A]$ 时，发现 $A$ 正在被访问（在 DFS 的递归栈上，即为“灰色”节点）。这形成了一条后向边 $D \\rightarrow A$，从而检测到循环。\n    -   这个循环涉及的顶点 $\\{A, C, D\\}$ 构成一个强连通分量 (SCC)。\n2.  **收缩图的拓扑排序**：\n    -   我们将 SCC $\\{A, C, D\\}$ 收缩成一个超节点，记为 $S_{ACD}$。\n    -   依赖关系现在变为：$X \\rightarrow S_{ACD}$, $X \\rightarrow B$, $B \\rightarrow S_{ACD}$, $S_{ACD} \\rightarrow E$。\n    -   在收缩后的共享对象图上，依赖关系为 $B \\rightarrow S_{ACD}$ 和 $S_{ACD} \\rightarrow E$。\n    -   对这个有向无环图 (DAG) 进行拓扑排序，得到顺序 $(B, S_{ACD}, E)$。\n3.  **最终加载顺序**：\n    -   根据规则，我们将拓扑排序的结果展开。SCC 内部的成员按照 DFS 首次发现的顺序排列。\n    -   在我们的 DFS 遍历 $X \\rightarrow A \\rightarrow C \\rightarrow D$ 中，发现顺序是 $A$, then $C$, then $D$。\n    -   将超节点展开，得到最终的加载顺序：首先是 $B$，然后是 $S_{ACD}$ 的成员 (按发现顺序 $A, C, D$)，最后是 $E$。\n    -   最终顺序为：$[B, A, C, D, E]$。\n\n**评估选项：**\n\n-   **选项 A**：正确地指出了循环为 $\\{A, C, D\\}$，正确描述了 $L_0$ 的行为（处理 $B$ 然后中止），并且正确推导出了 $L_1$ 的加载顺序 $[B, A, C, D, E]$。\n-   **选项 B**：错误地识别了循环，并错误地声称 $L_0$ 会成功。\n-   **选项 C**：对 $L_0$ 行为的描述不准确（它没有立即中止），且 $L_1$ 的顺序是无效的（$A$ 必须在 $E$ 之前）。\n-   **选项 D**：错误地识别了循环，错误地描述了 $L_0$ 的输出，并且 $L_1$ 的顺序是无效的（$B$ 必须在 $C$ 之前）。\n\n因此，选项 A 是唯一完全正确的描述。", "answer": "$$\\boxed{A}$$", "id": "3654576"}]}