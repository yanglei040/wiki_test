{"hands_on_practices": [{"introduction": "一条指令能够访问内存的范围，受其寻址模式和指令字段位宽的限制。本练习将探讨目标内存地址、寄存器值和所需位移量之间的关系，揭示指令编码中有限的位移字段如何从根本上限制了访存指令的“可达范围”。通过解决这个问题，你将具体理解如何计算必要的位移量并确定编码它所需的最小位数，这是指令集架构（ISA）设计和分析中的一项关键技能 [@problem_id:3618990]。", "problem": "在某个指令集架构（ISA）中，一条加载指令使用基址加变址带偏移量的寻址模式。根据定义，该模式产生的有效地址（EA）是两个通用寄存器内容和一个符号扩展的立即数偏移量之和，即有效地址等于寄存器 $R1$ 中的值、寄存器 $R2$ 中的值以及一个立即数偏移量 $disp$ 的和。该偏移量以 $w$ 位二进制补码形式编码，并在相加前符号扩展到机器字长。所有量都表示字节地址，并且仅在偏移量编码时被视为有符号整数。一个 $w$ 位有符号整数的二进制补码范围是 $\\left[-2^{w-1},\\,2^{w-1}-1\\right]$。\n\n仅使用这些定义和事实，依次解决以下问题：\n- 推导偏移量 $disp$ 的必要和充分条件，使得指令的有效地址等于给定的绝对目标地址 $C$。你的条件应完全用 $R1$、$R2$ 和 $C$ 表示，并且暂时不要假设任何特定的 $w$。\n- 将你的条件具体化为 $w$ 位偏移量的二进制补码可表示性约束。\n- 现在用具体值 $R1 = 0x0000000010000100$、$R2 = 0x0000000000000200$ 和 $C = 0x0000000010008901$ 实例化这些符号。确定最小整数 $w$，使得偏移量可以用二进制补码编码，并且指令可以使用此寻址模式精确达到目标地址 $C$。\n\n你的最终答案必须是所需的最小整数位数 $w$。答案无需四舍五入，也无需单位。", "solution": "首先验证问题，以确保其科学性、严谨性和客观性。\n\n### 步骤1：提取已知条件\n- **寻址模式**：基址加变址带偏移量。\n- **有效地址（EA）公式**：有效地址 $EA$ 是寄存器 $R1$ 中的值、寄存器 $R2$ 中的值和一个符号扩展的立即数偏移量 $disp$ 的和。$EA = R1 + R2 + disp$。\n- **偏移量编码**：$disp$ 被编码为一个 $w$ 位的二进制补码整数。在相加之前，它被符号扩展到机器字长。\n- **二进制补码范围**：一个 $w$ 位有符号整数的范围为 $\\left[-2^{w-1}, 2^{w-1}-1\\right]$。\n- **目标地址**：给定的绝对目标地址 $C$。\n- **具体值**：\n  - $R1 = 0\\text{x}0000000010000100$\n  - $R2 = 0\\text{x}0000000000000200$\n  - $C = 0\\text{x}0000000010008901$\n- **目标**：求 $w$ 的最小整数值。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题设定在计算机组成和体系结构的标准框架内。寻址模式、有效地址计算和二进制补码表示的定义都是标准的且事实正确。问题是自包含的，提供了所有必要的定义和数据以得出唯一解。语言精确且客观。没有科学缺陷、歧义或矛盾。\n\n### 步骤3：结论与行动\n该问题被判定为**有效**。将推导解答过程。\n\n### 解答推导\n\n解答过程按顺序处理问题陈述中指定的三个任务。\n\n**1. 推导偏移量 $disp$ 的必要和充分条件。**\n\n有效地址（$EA$）定义为两个寄存器 $R1$ 和 $R2$ 的内容与一个立即数偏移量 $disp$ 的和。\n$$EA = R1 + R2 + disp$$\n问题要求有效地址等于一个特定的目标地址 $C$。\n$$EA = C$$\n将 $EA$ 的两个表达式相等，得到以下关系：\n$$C = R1 + R2 + disp$$\n为了找到关于 $disp$ 的必要和充分条件，我们解这个方程求 $disp$。这就得出了使指令能够达到目标地址 $C$ 所需的偏移量值。\n$$disp = C - (R1 + R2)$$\n这个方程就是完全用 $R1$、$R2$ 和 $C$ 表示的关于 $disp$ 的条件。\n\n**2. 将条件具体化为二进制补码的可表示性约束。**\n\n偏移量 $disp$ 必须能表示为一个 $w$ 位的二进制补码整数。问题给出了这种整数的有效范围为：\n$$-2^{w-1} \\le disp \\le 2^{w-1} - 1$$\n代入第一部分中 $disp$ 的表达式，我们得到包含了可表示性约束的具体化条件：\n$$-2^{w-1} \\le C - (R1 + R2) \\le 2^{w-1} - 1$$\n必须满足这个不等式，偏移量才能用 $w$ 位宽度进行编码。\n\n**3. 对于给定的具体值，确定最小整数 $w$。**\n\n首先，我们使用提供的 $R1$、$R2$ 和 $C$ 的十六进制值计算偏移量 $disp$ 所需的数值。在算术运算中，这些地址被当作无符号整数处理。\n$$R1 = 0\\text{x}10000100$$\n$$R2 = 0\\text{x}00000200$$\n$$C = 0\\text{x}10008901$$\n我们首先计算寄存器内容的总和：\n$$R1 + R2 = 0\\text{x}10000100 + 0\\text{x}00000200 = 0\\text{x}10000300$$\n接下来，我们计算偏移量 $disp$：\n$$disp = C - (R1 + R2) = 0\\text{x}10008901 - 0\\text{x}10000300 = 0\\text{x}8601$$\n为了找到最小位数 $w$，我们将十六进制偏移量 $0\\text{x}8601$ 转换为其十进制等价值：\n$$disp = 8 \\times 16^3 + 6 \\times 16^2 + 0 \\times 16^1 + 1 \\times 16^0$$\n$$disp = 8 \\times 4096 + 6 \\times 256 + 0 + 1$$\n$$disp = 32768 + 1536 + 1 = 34305$$\n现在我们必须找到最小整数 $w$，使得 $disp = 34305$ 满足二进制补码的范围条件：\n$$-2^{w-1} \\le 34305 \\le 2^{w-1} - 1$$\n由于 $disp$ 是一个正数，左侧不等式 $-2^{w-1} \\le 34305$ 对任何 $w \\ge 2$ 都成立。决定性约束是右侧不等式：\n$$34305 \\le 2^{w-1} - 1$$\n整理不等式得到：\n$$34306 \\le 2^{w-1}$$\n为了找到满足此条件的最小整数 $w$，我们可以考察 2 的幂：\n$$2^{14} = 16384$$\n$$2^{15} = 32768$$\n$$2^{16} = 65536$$\n我们需要 $2^{w-1}$ 大于或等于 $34306$。从上面的值可以看出，$2^{15}$ 太小，但 $2^{16}$ 足够。因此，指数 $w-1$ 的最小整数值必须是 $16$。\n$$w-1 \\ge 16$$\n这意味着 $w$ 的最小整数值为：\n$$w = 16 + 1 = 17$$\n为了验证，当 $w=17$ 时，范围是 $[-2^{16}, 2^{16}-1]$，即 $[-65536, 65535]$。值 $34305$ 在此范围内。当 $w=16$ 时，范围是 $[-2^{15}, 2^{15}-1]$，即 $[-32768, 32767]$。值 $34305$ 超出此范围。因此，所需的最小整数位数为 $17$。", "answer": "$$\\boxed{17}$$", "id": "3618990"}, {"introduction": "正确解释指令的二进制位是处理器运行的基础，其中一个常见的错误源于将较短的数值字段（如位移量）扩展到算术逻辑单元（ALU）的全宽度。本练习深入探讨了对二进制补码数进行符号扩展和零扩展的关键区别。你将通过分析一个假设的硬件错误，了解这个看似微小的细节如何导致可预测的、显著的内存地址计算错误 [@problem_id:3618965]。", "problem": "一个处理器对内存操作数使用基址加偏移量寻址模式。在此模式下，有效地址 (EA) 计算为 $EA = R5 + \\text{disp}$，其中 $R5$ 是一个通用基址寄存器，而 $\\text{disp}$ 是包含在指令编码中的一个立即数偏移量字段。该架构规定 $\\text{disp}$ 是一个 $k$ 位的二进制补码值，在与 $R5$ 相加之前，必须将其符号扩展到机器字长。假设机器字长为 $32$ 位，且内存是按字节寻址的。一个有错误的实现错误地将 $\\text{disp}$ 零扩展到 $32$ 位，而不是进行符号扩展。\n\n从基址加偏移量寻址和二进制补码符号扩展的核心定义出发，分析这个错误的影响。具体来说，确定在哪种情况下，错误的零扩展会导致计算出的 $EA$ 与正确的 $EA$ 相差正好 $2^k$ 字节。对于每个选项，将 `0x...` 视为 $k$ 位偏移量字段的字面位模式，并假设像通常对 $32$ 位地址那样，算术运算在模 $2^{32}$ 下进行。\n\n选择所有导致偏差为 $2^k$ 的错误的选项（即，错误的 $EA$ 等于正确的 $EA$ 加上 $2^k$）。\n\nA. $k = 12$, $R5 = 0x1000$, `disp` = `0x800`\n\nB. $k = 12$, $R5 = 0x1000$, `disp` = `0x7FF`\n\nC. $k = 12$, $R5 = 0x2000$, `disp` = `0xF20`\n\nD. $k = 10$, $R5 = 0xFF00$, `disp` = `0x120`\n\nE. $k = 16$, $R5 = 0x0000$, `disp` = `0x8000`", "solution": "该问题陈述经证实具有科学依据、提法明确且客观。它基于计算机体系结构的标准原理，包括寻址模式和二进制补码算术。其设定是自洽的，没有矛盾，允许进行严谨的形式化分析。\n\n问题的核心在于对一个 $k$ 位二进制补码偏移量 $\\text{disp}$ 进行正确的符号扩展与错误的零扩展之间的差异。我们需要找出这种错误何时会导致计算出的有效地址 ($EA$) 恰好偏差 $2^k$。\n\n令 $\\text{disp}_k$ 表示 $k$ 位的偏移量字段。令其无符号整数值为 $D_k$。机器字长为 $32$ 位。\n\n正确的有效地址 $EA_{\\text{correct}}$ 是通过将 $\\text{disp}_k$ 符号扩展到 $32$ 位，然后与基址寄存器 $R5$ 相加来计算的。\n$EA_{\\text{correct}} = R5 + \\text{sign_extend}(\\text{disp}_k)$\n\n有错误的有效地址 $EA_{\\text{buggy}}$ 是通过将 $\\text{disp}_k$ 零扩展到 $32$ 位来计算的。\n$EA_{\\text{buggy}} = R5 + \\text{zero_extend}(\\text{disp}_k)$\n\n让我们分析两种情况下扩展后偏移量的值。\n通过对 $\\text{disp}_k$ 进行零扩展得到的 $32$ 位数的值就是其无符号值 $D_k$。\n$\\text{zero_extend}(\\text{disp}_k)$ 的值为 $D_k$。\n\n通过对 $\\text{disp}_k$ 进行符号扩展得到的 $32$ 位数的值取决于其最高有效位 (MSB)，即第 $k-1$ 位。\n情况1：$\\text{disp}_k$ 的 MSB 为 $0$。这表示一个非负数。\n符号扩展用 $0$ 填充高位的 $32-k$ 位。这与零扩展相同。\n$\\text{sign_extend}(\\text{disp}_k)$ 的值为 $D_k$。\n\n情况2：$\\text{disp}_k$ 的 MSB 为 $1$。这在二进制补码表示法中表示一个负数。\n一个 MSB 被置位的 $k$ 位二进制补码数的值是 $D_k - 2^k$。符号扩展必须保留这个值。\n为了进行符号扩展，高位的 $32-k$ 位用 $1$ 填充。得到的 $32$ 位模式的无符号值为 $D_k + \\sum_{i=k}^{31} 2^i = D_k + (2^{32}-2^k)$。\n作为一个 $32$ 位的二进制补码数，其值为 $(D_k + 2^{32}-2^k) - 2^{32} = D_k - 2^k$。\n所以，$\\text{sign_extend}(\\text{disp}_k)$ 的值为 $D_k - 2^k$。\n\n我们需要找到错误 $EA$ 等于正确 $EA$ 加上 $2^k$ 的情况。\n$EA_{\\text{buggy}} = EA_{\\text{correct}} + 2^k$\n$(R5 + \\text{Value}(\\text{zero_extend}(\\text{disp}_k))) = (R5 + \\text{Value}(\\text{sign_extend}(\\text{disp}_k))) + 2^k$\n\n从两边减去 $R5$，条件简化为：\n$\\text{Value}(\\text{zero_extend}(\\text{disp}_k)) = \\text{Value}(\\text{sign_extend}(\\text{disp}_k)) + 2^k$\n\n让我们针对这两种情况检查此条件：\n情况1（$\\text{disp}_k$ 的 MSB 为 $0$）：\n$D_k = D_k + 2^k$，简化为 $0 = 2^k$。对于任何 $k > 0$ 这都是错误的。\n\n情况2（$\\text{disp}_k$ 的 MSB 为 $1$）：\n$D_k = (D_k - 2^k) + 2^k$，简化为 $D_k = D_k$。这永远成立。\n\n因此，当且仅当 $k$ 位偏移量字段 $\\text{disp}_k$ 的最高有效位为 $1$ 时，该错误才会导致偏差为 $2^k$ 的错误。基址寄存器 $R5$ 的值与此条件无关。我们现在根据这个原则分析每个选项。\n\n**A. $k = 12$, $R5 = 0x1000$, `disp` = `0x800`**\n偏移量是一个 $k=12$ 位的字段。值为 `disp` = `0x800`。\n在二进制中，`0x800` 是 $1000\\ 0000\\ 0000_2$。\n这是一个 $12$ 位的模式。最高有效位（第 $11$ 位）是 $1$。\n根据我们的推导，这种情况将产生指定的错误。\n为了验证：\n- 正确的值（符号扩展）：在一个 $12$ 位字段中，`disp` 表示值 $2^{11}$，这被解释为 $2^{11} - 2^{12} = 2048 - 4096 = -2048$。\n- 错误的值（零扩展）：`disp` 被解释为无符号值 $2048$。\n- 差值：$2048 - (-2048) = 4096$。\n- 这个差值等于 $2^k = 2^{12} = 4096$。\n结论：**正确**。\n\n**B. $k = 12$, $R5 = 0x1000$, `disp` = `0x7FF`**\n偏移量是一个 $k=12$ 位的字段。值为 `disp` = `0x7FF`。\n在二进制中，`0x7FF` 是 $0111\\ 1111\\ 1111_2$。\n这是一个 $12$ 位的模式。最高有效位（第 $11$ 位）是 $0$。\n根据我们的推导，这个错误将导致差值为 $0$，而不是 $2^{12}$。符号扩展和零扩展产生相同的结果。\n结论：**错误**。\n\n**C. $k = 12$, $R5 = 0x2000$, `disp` = `0xF20`**\n偏移量是一个 $k=12$ 位的字段。值为 `disp` = `0xF20`。\n在二进制中，`0xF20` 是 $1111\\ 0010\\ 0000_2$。\n这是一个 $12$ 位的模式。最高有效位（第 $11$ 位）是 $1$。\n根据我们的推导，这种情况将产生指定的错误。\n为了验证：\n- 无符号值 $D_{12} = \\text{0xF20} = 3872$。\n- 正确的值（符号扩展）：$3872 - 2^{12} = 3872 - 4096 = -224$。\n- 错误的值（零扩展）：$3872$。\n- 差值：$3872 - (-224) = 4096$。\n- 这个差值等于 $2^k = 2^{12} = 4096$。\n结论：**正确**。\n\n**D. $k = 10$, $R5 = 0xFF00$, `disp` = `0x120`**\n偏移量是一个 $k=10$ 位的字段。问题陈述要求将 `0x120` 视为“$k$ 位偏移量字段的字面位模式”。\n十六进制字面量 `0x120` 对应于 $12$ 位模式 $0001\\ 0010\\ 0000_2$。\n一个 $10$ 位的字段无法包含一个 $12$ 位的字面模式。这个选项的前提是矛盾的，描述了一个不可能的情景。由于这种情况不可能存在，因此它不可能是该错误产生指定偏差的一个实例。\n结论：**错误**。\n\n**E. $k = 16$, $R5 = 0x0000$, `disp` = `0x8000`**\n偏移量是一个 $k=16$ 位的字段。值为 `disp` = `0x8000`。\n在二进制中，`0x8000` 是 $1000\\ 0000\\ 0000\\ 0000_2$。\n这是一个 $16$ 位的模式。最高有效位（第 $15$ 位）是 $1$。\n根据我们的推导，这种情况将产生指定的错误。\n为了验证：\n- 无符号值 $D_{16} = \\text{0x8000} = 32768$。\n- 正确的值（符号扩展）：$32768 - 2^{16} = 32768 - 65536 = -32768$。\n- 错误的值（零扩展）：$32768$。\n- 差值：$32768 - (-32768) = 65536$。\n- 这个差值等于 $2^k = 2^{16} = 65536$。\n结论：**正确**。", "answer": "$$\\boxed{ACE}$$", "id": "3618965"}, {"introduction": "寻址模式不仅用于计算单个地址，它们的设计初衷更是为了支持常见编程模式，例如遍历数据结构。本练习模拟了一段使用自增寻址模式来扫描内存中字符串的代码。通过追踪循环中每一步的有效地址计算和基址寄存器更新，你将体验到这种模式的高效性，并加深对字节序和操作数大小等概念的理解 [@problem_id:3619064]。", "problem": "一种指令集架构（ISA）提供了一种自增寻址模式，表示为将基址寄存器放在括号内，后跟一个加号，以及一个指示操作数大小的大小后缀。有效地址（EA）定义为用于访问内存中操作数的值；在自增模式下，会访问位于 $EA$ 的内存操作数，然后基址寄存器会增加操作数的大小（以字节为单位）。该机器是字节寻址的，并使用一个 $4$ 字节的字。带大小后缀的操作应用于指定大小寄存器的低位部分。假设多字节加载采用小端序表示，因此在从地址 $A$ 加载一个字时，地址 $A$ 处的字节会映射到目标寄存器的低位字节。\n\n考虑一个存储在内存中、从地址 $B = 0x4000$ 开始的空字符终止字符串。在 $B$ 及其后的内存内容如下：\n- 在 $0x4000$：字节 $0x41$（ASCII ‘A’）\n- 在 $0x4001$：字节 $0x42$（ASCII ‘B’）\n- 在 $0x4002$：字节 $0x43$（ASCII ‘C’）\n- 在 $0x4003$：字节 $0x00$（空终止符）\n- 在 $0x4004$：字节 $0x5E$\n- 在 $0x4005$：字节 $0x99$\n- 在 $0x4006$：字节 $0x77$\n- 在 $0x4007$：字节 $0x88$\n- 在 $0x4008$：字节 $0x00$\n- 在 $0x4009$：字节 $0x11$\n\n两个循环尝试扫描直到找到空终止符。基址寄存器 $R_0$ 初始化为 $B$。循环如下：\n\n- 字节循环 $S_b$：\n  - 循环体：`LD.B ($R_0$)+, $R_1$; CMP.B $R_1$, #$0$; BNE back_to_loop`\n  - 语义：LD.B 使用 $EA = R_0$，加载一个字节，然后更新 $R_0 \\leftarrow R_0 + 1$。\n\n- 字循环 $S_w$：\n  - 循环体：`LD.W ($R_0$)+, $R_2$; CMP.B $R_2$, #$0$; BNE back_to_loop`\n  - 语义：LD.W 使用 $EA = R_0$，加载四个字节到 $R_2$，其中 $EA$ 处的字节位于 $R_2$ 的低位字节，然后更新 $R_0 \\leftarrow R_0 + 4$。CMP.B 仅将 $R_2$ 的低位字节与 $0$ 进行比较。\n\n对于这些特定的内存内容和初始 $R_0 = 0x4000$，哪个选项正确描述了每个循环在退出前使用的 $EA$ 值序列以及退出时 $R_0$ 的最终值？\n\nA. $S_b$: $EA$ 序列 $0x4000, 0x4001, 0x4002, 0x4003$; 最终 $R_0 = 0x4004$。$S_w$: $EA$ 序列 $0x4000, 0x4004, 0x4008$; 最终 $R_0 = 0x400C$。\n\nB. $S_b$: $EA$ 序列 $0x4001, 0x4002, 0x4003$; 最终 $R_0 = 0x4003$。$S_w$: $EA$ 序列 $0x4004, 0x4008$; 最终 $R_0 = 0x4008$。\n\nC. $S_b$: $EA$ 序列 $0x4000, 0x4001, 0x4002, 0x4003$; 最终 $R_0 = 0x4004$。$S_w$: $EA$ 序列 $0x4000, 0x4002, 0x4004$; 最终 $R_0 = 0x4006$。\n\nD. $S_b$: $EA$ 序列 $0x4000, 0x4001, 0x4002$; 最终 $R_0 = 0x4003$。$S_w$: $EA$ 序列 $0x4000$; 最终 $R_0 = 0x4004$，因为字中存在任何零字节都会导致立即退出。", "solution": "题目陈述已经过严格验证，并被认定为有效。它在科学上基于计算机组成与体系结构的原理，问题设定良好，具有唯一且可确定的解，并以客观、明确的语言表达。所有必要信息，包括初始内存状态、寄存器值和精确的指令语义，都已提供。该问题是在一个假设但现实的处理器架构上追踪程序执行的标准练习。\n\n我们将通过模拟每个循环的执行来继续，在每一步中跟踪相关的寄存器值和内存访问。\n\n### 字节循环（$S_b$）分析\n\n字节循环的循环体是：`LD.B ($R_0$)+, $R_1$; CMP.B $R_1$, #0; BNE back_to_loop`。初始状态为 $R_0 = 0x4000$。\n\n- **迭代 1：**\n  - `LD.B ($R_0$)+, $R_1$`: 有效地址（$EA$）是 $R_0$ 的当前值，即 $0x4000$。从内存地址 $0x4000$ 加载一个字节。该值为 $0x41$（ASCII 'A'）。此值被放置在 $R_1$ 的低位字节中。加载后，$R_0$ 增加操作数大小，即 $1$ 字节。\n    - $EA_1 = 0x4000$\n    - $R_1 \\leftarrow 0x...0041$\n    - $R_0 \\leftarrow 0x4000 + 1 = 0x4001$\n  - `CMP.B $R_1$, #0`: 将 $R_1$ 的低位字节（$0x41$）与 $0$ 进行比较。它们不相等。\n  - `BNE back_to_loop`: 条件（不相等）为真，因此执行分支。\n\n- **迭代 2：**\n  - `LD.B ($R_0$)+, $R_1$`: $EA$ 是 $R_0$ 的当前值 $0x4001$。位于此地址的字节 $0x42$ 被加载到 $R_1$ 中。$R_0$ 自增。\n    - $EA_2 = 0x4001$\n    - $R_1 \\leftarrow 0x...0042$\n    - $R_0 \\leftarrow 0x4001 + 1 = 0x4002$\n  - `CMP.B $R_1$, #0`: 将 $0x42$ 与 $0$ 进行比较。它们不相等。\n  - `BNE back_to_loop`: 执行分支。\n\n- **迭代 3：**\n  - `LD.B ($R_0$)+, $R_1$`: $EA$ 是 $0x4002$。位于此地址的字节 $0x43$ 被加载到 $R_1$ 中。$R_0$ 自增。\n    - $EA_3 = 0x4002$\n    - $R_1 \\leftarrow 0x...0043$\n    - $R_0 \\leftarrow 0x4002 + 1 = 0x4003$\n  - `CMP.B $R_1$, #0`: 将 $0x43$ 与 $0$ 进行比较。它们不相等。\n  - `BNE back_to_loop`: 执行分支。\n\n- **迭代 4：**\n  - `LD.B ($R_0$)+, $R_1$`: $EA$ 是 $0x4003$。位于此地址的字节，即空终止符 $0x00$，被加载到 $R_1$ 中。$R_0$ 自增。\n    - $EA_4 = 0x4003$\n    - $R_1 \\leftarrow 0x...0000$\n    - $R_0 \\leftarrow 0x4003 + 1 = 0x4004$\n  - `CMP.B $R_1$, #0`: 将 $0x00$ 与 $0$ 进行比较。它们相等。\n  - `BNE back_to_loop`: 条件（不相等）为假，因此不执行分支。循环终止。\n\n**$S_b$ 总结：**\n- 使用的有效地址序列为：$0x4000, 0x4001, 0x4002, 0x4003$。\n- 循环退出时 $R_0$ 的最终值为 $0x4004$。\n\n### 字循环（$S_w$）分析\n\n字循环的循环体是：`LD.W ($R_0$)+, $R_2$; CMP.B $R_2$, #0; BNE back_to_loop`。字大小为 $4$ 字节。初始状态为 $R_0 = 0x4000$。\n\n- **迭代 1：**\n  - `LD.W ($R_0$)+, $R_2$`: $EA$ 是 $0x4000$。从内存地址 $0x4000$ 开始加载一个 $4$ 字节的字。地址 $0x4000, 0x4001, 0x4002, 0x4003$ 处的字节分别为 $0x41, 0x42, 0x43, 0x00$。由于是小端序表示，最低地址（$0x4000$）的字节映射到寄存器的低位字节。因此，加载到 $R_2$ 的 $4$ 字节字是 $0x00434241$。加载后，$R_0$ 增加字的大小，即 $4$ 字节。\n    - $EA_1 = 0x4000$\n    - $R_2 \\leftarrow 0x00434241$\n    - $R_0 \\leftarrow 0x4000 + 4 = 0x4004$\n  - `CMP.B $R_2$, #0`: 这仅将 $R_2$ 的低位字节与 $0$ 进行比较。$R_2$ 的低位字节是 $0x41$。这不等于 $0$。\n  - `BNE back_to_loop`: 条件为真，因此执行分支。\n\n- **迭代 2：**\n  - `LD.W ($R_0$)+, $R_2$`: $EA$ 是 $0x4004$。从内存地址 $0x4004$ 开始加载一个 $4$ 字节的字。地址 $0x4004, 0x4005, 0x4006, 0x4007$ 处的字节是 $0x5E, 0x99, 0x77, 0x88$。加载到 $R_2$ 的 $4$ 字节字（小端序）是 $0x8877995E$。$R_0$ 自增。\n    - $EA_2 = 0x4004$\n    - $R_2 \\leftarrow 0x8877995E$\n    - $R_0 \\leftarrow 0x4004 + 4 = 0x4008$\n  - `CMP.B $R_2$, #0`: 将 $R_2$ 的低位字节，即 $0x5E$，与 $0$ 进行比较。它们不相等。\n  - `BNE back_to_loop`: 执行分支。\n\n- **迭代 3：**\n  - `LD.W ($R_0$)+, $R_2$`: $EA$ 是 $0x4008$。从内存地址 $0x4008$ 开始加载一个 $4$ 字节的字。地址 $0x4008, 0x4009, ...$ 处的字节是 $0x00, 0x11, ...$。位于 $0x4008$ 的字节，即 $0x00$，成为 $R_2$ 的低位字节。完整的字是 $0x...1100$。$R_0$ 自增。\n    - $EA_3 = 0x4008$\n    - $R_2 \\leftarrow$ 一个低位字节为 $0x00$ 的值。\n    - $R_0 \\leftarrow 0x4008 + 4 = 0x400C$\n  - `CMP.B $R_2$, #0`: 将 $R_2$ 的低位字节，即 $0x00$，与 $0$ 进行比较。它们相等。\n  - `BNE back_to_loop`: 条件为假，因此不执行分支。循环终止。\n\n**$S_w$ 总结：**\n- 使用的有效地址序列为：$0x4000, 0x4004, 0x4008$。\n- 循环退出时 $R_0$ 的最终值为 $0x400C$。\n\n### 选项评估\n\n- **选项 A：** $S_b$: $EA$ 序列 $0x4000, 0x4001, 0x4002, 0x4003$; 最终 $R_0 = 0x4004$。$S_w$: $EA$ 序列 $0x4000, 0x4004, 0x4008$; 最终 $R_0 = 0x400C$。\n  - 此选项与我们为 $S_b$ 和 $S_w$ 推导出的结果相符。\n  - **结论：正确**\n\n- **选项 B：** $S_b$: $EA$ 序列 $0x4001, 0x4002, 0x4003$; 最终 $R_0 = 0x4003$。$S_w$: $EA$ 序列 $0x4004, 0x4008$; 最终 $R_0 = 0x4008$。\n  - 对于 $S_b$，$EA$ 序列不正确；它必须从 $R_0$ 的初始值 $0x4000$ 开始。最终的 $R_0$ 不正确；它应该是 $0x4004$。\n  - 对于 $S_w$，$EA$ 序列同样不正确，缺少了在 $0x4000$ 的初始访问。最终的 $R_0$ 不正确；它应该是 $0x400C$。\n  - **结论：不正确**\n\n- **选项 C：** $S_b$: $EA$ 序列 $0x4000, 0x4001, 0x4002, 0x4003$; 最终 $R_0 = 0x4004$。$S_w$: $EA$ 序列 $0x4000, 0x4002, 0x4004$; 最终 $R_0 = 0x4006$。\n  - 对 $S_b$ 的描述是正确的。\n  - 对于 $S_w$，$EA$ 序列不正确。自增量是操作数大小（字，即 $4$ 字节），所以地址应该增加 $4$（$0x4000, 0x4004, ...$），而不是 $2$。因此，最终的 $R_0$ 值也是不正确的。\n  - **结论：不正确**\n\n- **选项 D：** $S_b$: $EA$ 序列 $0x4000, 0x4001, 0x4002$; 最终 $R_0 = 0x4003$。$S_w$: $EA$ 序列 $0x4000$; 最终 $R_0 = 0x4004$，因为字中存在任何零字节都会导致立即退出。\n  - 对于 $S_b$，$EA$ 序列不完整；它没有包括在 $0x4003$ 处找到空终止符的访问。最终的 $R_0$ 不正确，因为没有计算最后的自增。\n  - 对于 $S_w$，其推理是有缺陷的。问题明确指出 `CMP.B` *仅*比较 $R_2$ 的低位字节。加载的第一个字（$0x00434241$）包含一个零字节，但其低位字节是 $0x41$。因此，循环不会在第一次迭代后退出。\n  - **结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3619064"}]}