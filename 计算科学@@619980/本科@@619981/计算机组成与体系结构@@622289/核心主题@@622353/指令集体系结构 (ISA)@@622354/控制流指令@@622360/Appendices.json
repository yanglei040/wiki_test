{"hands_on_practices": [{"introduction": "分支指令的核心是计算其目标地址。本练习将通过让你手动计算分支偏移量来揭开这个过程的神秘面纱，就像汇编器所做的那样 [@problem_id:3629897]。它将高级语言中的标签与底层的二进制编码联系起来，同时考虑了程序计数器（$PC$）相对寻址和指令大小等现实细节。通过这个实践，你将深入理解编译器和加载器如何协同工作，将符号地址转换为可执行的机器指令。", "problem": "一个计算机系统实现了一种类 MIPS 的指令集架构 (ISA)，其中每条指令的大小为 $4$ 字节，条件分支使用一个 $16$ 位有符号偏移量字段，该字段以指令为单位进行解释。硬件计算分支目标地址的公式为 $PC + 4 + (\\text{offset} \\ll 2)$，其中 $PC$ 是指向分支指令的程序计数器 (PC)，$+4$ 表示在加上偏移量之前 PC 前进了 $+4$，而 $\\text{offset}$ 在形成目标地址时会符号扩展到 $32$ 位并乘以 $4$。\n\n一个可重定位目标文件包含一个代码段 (text)，其中记录了汇编器标签相对于该段的字节偏移量。在加载时，操作系统加载器将整个 text 段映射到一个绝对基地址 $B_{\\text{text}}$，并应用一个进程范围的加载偏置 $\\Delta$，因此 text 段在内存中的绝对基地址为 $\\tilde{B} = B_{\\text{text}} + \\Delta$。text 段中所有标签的地址都通过将其段相对偏移量加上 $\\tilde{B}$ 来进行重定位。\n\n考虑以下具体实例：\n- 映射后 text 段的绝对基地址为 $\\tilde{B} = B_{\\text{text}} + \\Delta$，其中 $B_{\\text{text}} = 0x0001\\,8000$ 且 $\\Delta = 0x0000\\,4000$。\n- 一条分支指令在段相对偏移量 $o_b = 0x0000\\,012C$ 处被汇编，其目标汇编器标签名为 $\\text{target}$，位于段相对偏移量 $o_t = 0x0000\\,00D8$ 处。\n\n计算要放入 $16$ 位分支偏移量字段中的确切有符号整数值，使得在重定位并使用该架构的 $+4$ 的 $PC$ 偏置后，分支能够到达 $\\text{target}$。将你的最终答案表示为单个整数。不需要四舍五入，答案中也不应包含单位。", "solution": "该问题指定了类 MIPS 的分支语义：硬件计算分支目标地址的方式如下\n$$\nA_{\\text{branch-target}} = PC + 4 + (\\text{offset} \\ll 2).\n$$\n这里，$\\text{offset}$ 是指令中的 $16$ 位有符号立即数，它被符号扩展到 $32$ 位，并且左移 $2$ 位相当于乘以 $4$，因为指令是 $4$ 字节。\n\n我们已知重定位的细节。text 段被放置在一个绝对基地址 $\\tilde{B}$ 处，定义为\n$$\n\\tilde{B} = B_{\\text{text}} + \\Delta,\n$$\n其中 $B_{\\text{text}} = 0x0001\\,8000$ 且 $\\Delta = 0x0000\\,4000$。因此，绝对基地址 $\\tilde{B}$ 为\n$$\n\\tilde{B} = 0x0001\\,8000 + 0x0000\\,4000 = 0x0001\\,C000.\n$$\n然而，对于在同一重定位段内的 PC 相对分支，计算偏移量时绝对基地址会相互抵消。我们将明确地展示这一点。\n\n设 $o_b$ 为分支指令的段相对字节偏移量，$o_t$ 为目标标签的段相对字节偏移量。绝对地址为\n$$\nA_b = \\tilde{B} + o_b,\\quad A_t = \\tilde{B} + o_t.\n$$\n由于 PC 指向分支指令，因此在分支计算中使用的 PC 是 $PC = A_b$。硬件首先加上偏置 $+4$，所以\n$$\nPC + 4 = A_b + 4 = \\tilde{B} + o_b + 4.\n$$\n我们需要分支跳转到 $A_t$。将硬件计算的目标地址设为等于 $A_t$ 可得\n$$\nA_t = (PC + 4) + (\\text{offset} \\ll 2) = (\\tilde{B} + o_b + 4) + (\\text{offset} \\cdot 4).\n$$\n求解 $\\text{offset}$：\n$$\n\\text{offset} \\cdot 4 = A_t - (\\tilde{B} + o_b + 4) = (\\tilde{B} + o_t) - (\\tilde{B} + o_b + 4) = o_t - (o_b + 4),\n$$\n所以\n$$\n\\text{offset} = \\frac{o_t - (o_b + 4)}{4}.\n$$\n正如预期的那样，重定位基地址 $\\tilde{B}$ 被消掉了，只留下由 $+4$ 偏置调整过的段相对偏移量之差。\n\n现在代入给定的偏移量，$o_b = 0x0000\\,012C$ 和 $o_t = 0x0000\\,00D8$。转换为十进制进行计算：\n$$\no_b = 0x012C = 300,\\quad o_t = 0x00D8 = 216.\n$$\n计算 $o_t - (o_b + 4)$：\n$$\no_t - (o_b + 4) = 216 - (300 + 4) = 216 - 304 = -88.\n$$\n除以 $4$ 以获得以指令为单位的偏移量：\n$$\n\\text{offset} = \\frac{-88}{4} = -22.\n$$\n检查其范围是否在 $16$ 位有符号立即数的范围内：$-22$ 在 $[-32768, 32767]$ 之内，因此可以表示而不会溢出。这就是要在分支偏移量字段中编码的确切整数。", "answer": "$$\\boxed{-22}$$", "id": "3629897"}, {"introduction": "现代处理器为了追求高性能，不能在确定分支结果之后才执行后续指令，因此必须对其进行预测。本练习旨在探讨两种基本动态分支预测器的性能 [@problem_id:3629826]。通过模拟它们在典型循环结构上的行为，你将直观地理解为什么需要更复杂的预测器（如2位饱和计数器），并认识到其预测效率如何依赖于程序的实际行为模式。", "problem": "中央处理器（CPU）中的一个静态条件分支控制着一个循环的后向边。在这样的循环中，分支在连续固定次数的迭代中被执行（taken），然后有一次不被执行（not taken）以退出循环，之后循环重复。考虑两个代码区域，它们都使用这同一个静态分支，但具有不同的“执行偏向”（taken biases），该偏向定义为长期来看分支被执行结果的比例。\n\n- 循环 A 的执行偏向为 $p_{A} = 0.9$。\n- 循环 B 的执行偏向为 $p_{B} = 0.5$。\n\n假设分支预测器是局部的、动态的，并使用以下两种之一：\n- 一个 $1$ 位内存预测器，它预测下一次的结果与该静态分支最近一次的结果相同，或者\n- 一个 $2$ 位饱和计数器预测器，它有四种状态，其中在高两位状态下预测为执行（taken），在低两位状态下预测为不执行（not taken），状态转换在分支执行时递增，在分支不执行时递减，且不会超出范围。\n\n假设测量窗口在执行偏向（taken-biased）机制的热身（warm-up）后开始：$1$ 位预测器最初为该分支的第一个测量结果预测为执行，$2$ 位预测器最初处于最强的执行状态。仅使用循环分支的基本语义（每次迭代都执行，除了最后一次）和上述定义，从第一性原理出发，推导每个预测器在每个循环上每 $1000$ 次分支结果的预期错误预测数。以单行矩阵的形式提供最终结果，顺序为 $(M_{1\\text{-bit},\\,A},\\,M_{2\\text{-bit},\\,A},\\,M_{1\\text{-bit},\\,B},\\,M_{2\\text{-bit},\\,B})$，其中 $M_{\\cdot}$ 表示在 $1000$ 次结果中计数的错误预测数。无需四舍五-入，并报告原始计数，不带任何单位。", "solution": "该问题是有效的，因为它科学地基于计算机体系结构的原理，特别是分支预测，并且问题定义良好，具有唯一的、可推导的解。所有术语都有正式定义，数据也是一致的。\n\n问题的核心是确定两种类型的分支预测器在两个不同循环上的预期错误预测数。分析分两个阶段进行：首先，根据给定的执行偏向，描述每个循环的分支结果模式；其次，在这些模式上模拟每个预测器的行为，以找出错误预测率。\n\n**1. 推导循环分支模式**\n\n问题指出，一个静态条件分支控制循环的后向边。这意味着一个重复的结果模式：分支在固定次数的迭代中（比如 $N$ 次）被执行，然后有一次不被执行以退出循环。因此，循环分支结果的一个完整周期由 $N$ 次执行（taken）分支和 $1$ 次不执行（not-taken）分支组成。一个周期内的分支总数为 $N+1$。\n\n执行偏向 $p$ 定义为长期来看被执行结果的比例。对于这种循环结构，该偏向由一个周期内执行的分支数与分支总数的比率给出：\n$$p = \\frac{N}{N+1}$$\n我们可以根据 $p$ 解出 $N$：\n$$p(N+1) = N$$\n$$pN + p = N$$\n$$p = N - pN = N(1-p)$$\n$$N = \\frac{p}{1-p}$$\n\n使用这个公式，我们可以确定每个循环的 $N$ 值。\n\n*   **循环 A**：执行偏向为 $p_A = 0.9$。连续执行的分支次数 $N_A$ 为：\n    $$N_A = \\frac{p_A}{1-p_A} = \\frac{0.9}{1-0.9} = \\frac{0.9}{0.1} = 9$$\n    因此，循环 A 的分支模式是一个周期，包含 $9$ 次执行结果（T）和 $1$ 次不执行结果（NT）。周期长度为 $N_A + 1 = 10$ 次分支。\n\n*   **循环 B**：执行偏向为 $p_B = 0.5$。连续执行的分支次数 $N_B$ 为：\n    $$N_B = \\frac{p_B}{1-p_B} = \\frac{0.5}{1-0.5} = \\frac{0.5}{0.5} = 1$$\n    因此，循环 B 的分支模式是一个周期，包含 $1$ 次执行结果（T）和 $1$ 次不执行结果（NT）。周期长度为 $N_B + 1 = 2$ 次分支。\n\n**2. 预测器性能分析**\n\n我们现在分析每个预测器在每个循环模式下的稳态性能，以确定每 $1000$ 次结果的预期错误预测数。术语“预期数”意味着使用长期错误预测率。\n\n**情况 1：1 位预测器**\n\n该预测器使用 1 位历史记录，预测下一次结果将与最近一次结果相同。\n\n*   **在循环 A 上（9 次 T，1 次 NT）**：重复的结果序列是 T, T, T, T, T, T, T, T, T, NT。\n    让我们追踪一个稳态周期。前一个周期的最后一次分支结果是 NT。所以，进入新周期时预测器的状态是‘预测不执行’。\n    1.  分支 1 (结果 T)：预测为 NT。**错误预测**。预测器状态更新为 T。\n    2.  分支 2-9 (结果 T)：预测为 T。所有 $8$ 次都正确。状态保持为 T。\n    3.  分支 10 (结果 NT)：预测为 T。**错误预测**。预测器状态更新为 NT。\n    在每个包含 $10$ 次分支的周期中，有 $2$ 次错误预测。\n    错误预测率为 $\\frac{2}{10} = 0.2$。\n    每 $1000$ 次结果的预期错误预测数是 $M_{1\\text{-bit},\\,A} = 1000 \\times 0.2 = 200$。\n\n*   **在循环 B 上（1 次 T，1 次 NT）**：重复的结果序列是 T, NT。\n    让我们追踪一个稳态周期。在前一次 NT 之后，进入该周期时预测器的状态是‘预测不执行’。\n    1.  分支 1 (结果 T)：预测为 NT。**错误预测**。状态更新为 T。\n    2.  分支 2 (结果 NT)：预测为 T。**错误预测**。状态更新为 NT。\n    每次分支都被错误预测。在每个包含 $2$ 次分支的周期中，有 $2$ 次错误预测。\n    错误预测率为 $\\frac{2}{2} = 1.0$。\n    每 $1000$ 次结果的预期错误预测数是 $M_{1\\text{-bit},\\,B} = 1000 \\times 1.0 = 1000$。\n\n**情况 2：2 位饱和计数器预测器**\n\n该预测器使用一个 4 状态计数器：{3: 强执行, 2: 弱执行, 1: 弱不执行, 0: 强不执行}。它在状态 3 和 2 时预测‘执行’，在状态 1 和 0 时预测‘不执行’。当分支结果为执行时，计数器递增（在 3 处饱和），当结果为不执行时，计数器递减（在 0 处饱和）。给定的初始状态是状态 3。\n\n*   **在循环 A 上（9 次 T，1 次 NT）**：\n    1.  分支 1-9 (结果 T)：初始状态为 3。预测为 T。这是正确的。对于 $9$ 次执行的分支中的每一次，计数器都试图递增，但已在 3 处饱和。所有 $9$ 次分支的预测都是正确的。\n    2.  分支 10 (结果 NT)：状态为 3。预测为 T。**错误预测**。状态递减到 2。\n    下一个周期开始时，预测器处于状态 2。\n    3.  下一个周期的分支 1 (结果 T)：状态为 2。预测为 T。这是正确的。状态递增到 3。\n    预测器迅速返回到强执行状态。在每个包含 $10$ 次分支的周期中，只有那一次不执行的分支被错误预测。\n    错误预测率为 $\\frac{1}{10} = 0.1$。\n    每 $1000$ 次结果的预期错误预测数是 $M_{2\\text{-bit},\\,A} = 1000 \\times 0.1 = 100$。\n\n*   **在循环 B 上（1 次 T，1 次 NT）**：\n    1.  分支 1 (结果 T)：初始状态为 3。预测为 T。这是正确的。状态保持为 3（饱和）。\n    2.  分支 2 (结果 NT)：状态为 3。预测为 T。**错误预测**。状态递减到 2。\n    下一个周期开始时，预测器处于状态 2。\n    3.  下一个周期的分支 1 (结果 T)：状态为 2。预测为 T。这是正确的。状态递增到 3。\n    4.  下一个周期的分支 2 (结果 NT)：状态为 3。预测为 T。**错误预测**。状态递减到 2。\n    在稳态下，预测器的状态在 3 和 2 之间交替。由于这两种状态都预测‘执行’，所以预测总是 T。结果序列在 T 和 NT 之间交替。因此，每个 T 分支都被正确预测，而每个 NT 分支都被错误预测。\n    在每个包含 $2$ 次分支的周期中，有 $1$ 次错误预测。\n    错误预测率为 $\\frac{1}{2} = 0.5$。\n    每 $1000$ 次结果的预期错误预测数是 $M_{2\\text{-bit},\\,B} = 1000 \\times 0.5 = 500$。\n\n**结果总结**\n\n计算出的每种情况下每 $1000$ 次结果的错误预测数如下：\n*   $M_{1\\text{-bit},\\,A} = 200$\n*   $M_{2\\text{-bit},\\,A} = 100$\n*   $M_{1\\text{-bit},\\,B} = 1000$\n*   $M_{2\\text{-bit},\\,B} = 500$\n\n这些结果将以单行矩阵的形式提供。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n200  100  1000  500\n\\end{pmatrix}\n}\n$$", "id": "3629826"}, {"introduction": "确保控制流的正确性可能非常微妙，尤其是在处理非整型数据时。这个问题提出了一个涉及浮点数比较和棘手的“非数值”（NaN）值的难题 [@problem_id:3629890]。它挑战你超越简单的分支逻辑，构建一个能正确实现高级语言语义（遵循 IEEE 754 标准）的指令序列，这是编译器开发者和系统程序员必须掌握的一项关键技能。", "problem": "一个处理器实现了一条浮点比较指令，该指令会写入条件码，其后是读取这些条件码的条件分支指令。当比较可能遇到非数值 (Not-a-Number, NaN) 值时，你需要判断几个分支序列的正确性。所期望的高级语义与 C 语言在电气与电子工程师协会 (Institute of Electrical and Electronics Engineers, IEEE) $754$ 二进制浮点标准下的语义相同：对于诸如 $\\leq$ 的关系运算符，如果任一操作数为 NaN，则结果为假（比较是无序的）。\n\n基本依据和定义：\n- 根据 IEEE $754$ 标准，如果两个操作数都不是 NaN，则比较称为有序比较；如果至少一个操作数是 NaN，则称为无序比较。对于关系运算符如 $$、$\\leq$、$$、$\\geq$，如果关系在有序比较中成立，则结果为真，如果比较是无序的，则结果为假；对于相等运算符 $==$，如果比较是无序的，则结果为假；对于不等运算符 $\\neq$，如果比较是无序的，则结果为真。\n- 处理器的指令 $\\text{FCMP.S}\\;R_{x},R_{y}$ 比较 $R_{x}$ 和 $R_{y}$ 中的单精度浮点值，并设置三个条件码标志位：零 (zero) $Z$、进位 (carry) $C$ 和奇偶 (parity) $P$，其含义与众所周知的约定一致：\n  - 如果 $R_{x}  R_{y}$：$C=1$, $Z=0$, $P=0$。\n  - 如果 $R_{x} = R_{y}$：$C=0$, $Z=1$, $P=0$。\n  - 如果 $R_{x} > R_{y}$：$C=0$, $Z=0$, $P=0$。\n  - 如果无序（至少一个操作数是 NaN）：$C=1$, $Z=1$, $P=1$。\n- 条件分支按如下方式解释标志位：\n  - $\\text{JBE}\\;L$：如果小于或等于则跳转，即如果 $(C=1)\\lor(Z=1)$。\n  - $\\text{JA}\\;L$：如果大于则跳转，即如果 $(C=0)\\land(Z=0)$。\n  - $\\text{JP}\\;L$：如果奇偶位为1则跳转，即如果 $P=1$（无序）。\n  - $\\text{JNP}\\;L$：如果奇偶位为0则跳转，即如果 $P=0$（有序）。\n  - $\\text{JE}\\;L$：如果等于则跳转，即如果 $Z=1$。\n  - $\\text{JNE}\\;L$：如果不等于则跳转，即如果 $Z=0$。\n\n目标：\n实现 C 风格条件语句“如果 $(R_{x} \\leq R_{y})$ 则跳转到标签 $L_{\\text{true}}$，否则跳转到标签 $L_{\\text{false}}$”的控制流，并遵循 IEEE $754$ 规则，即无序比较的结果为假。假设代码序列总是以 $\\text{FCMP.S}\\;R_{x},R_{y}$ 开始，并且允许最后使用一条无条件跳转指令跳转到剩余的标签。选择下面所有能为所有情况（包括任一输入为 NaN 的情况）正确实现所需控制流的选项。\n\n考虑以下候选序列（每个序列都紧跟在 $\\text{FCMP.S}\\;R_{x},R_{y}$ 之后）：\n- A.\n  - $\\text{JBE}\\;L_{\\text{true}}$\n  - $\\text{JMP}\\;L_{\\text{false}}$\n\n- B.\n  - $\\text{JP}\\;L_{\\text{false}}$\n  - $\\text{JBE}\\;L_{\\text{true}}$\n  - $\\text{JMP}\\;L_{\\text{false}}$\n\n- C.\n  - $\\text{JNP}\\;L_{\\text{ordered}}$\n  - $\\text{JMP}\\;L_{\\text{false}}$\n  - $L_{\\text{ordered}}$:\n  - $\\text{JBE}\\;L_{\\text{true}}$\n  - $\\text{JMP}\\;L_{\\text{false}}$\n\n- D.\n  - $\\text{JA}\\;L_{\\text{false}}$\n  - $\\text{JP}\\;L_{\\text{false}}$\n  - $\\text{JMP}\\;L_{\\text{true}}$\n\n选择所有正确的选项。干扰项反映了关于在浮点比较后直接使用“小于或等于”以及未能明确排除无序情况的常见误解。", "solution": "### 问题验证\n\n本节在进行求解之前验证问题陈述。\n\n#### 步骤 1：提取已知条件\n\n问题提供了以下定义和条件：\n\n*   **目标：** 实现 C 语言条件语句“如果 ($R_{x} \\leq R_{y}$) 则跳转到标签 $L_{\\text{true}}$，否则跳转到标签 $L_{\\text{false}}$”的控制流。\n*   **IEEE 754 语义：** 对于像 $\\leq$ 这样的 C 风格关系运算符，如果任一操作数是 Not-a-Number (NaN)，则结果为 `false`。这被称为 `unordered`（无序）比较。\n*   **比较指令：** $\\text{FCMP.S}\\;R_{x},R_{y}$ 比较两个单精度浮点寄存器 $R_{x}$ 和 $R_{y}$，并设置三个条件码标志位：零 ($Z$)、进位 ($C$) 和奇偶 ($P$)。\n*   **$\\text{FCMP.S}\\;R_{x},R_{y}$ 后的标志位设置：**\n    *   如果 $R_{x}  R_{y}$：$C=1$, $Z=0$, $P=0$。\n    *   如果 $R_{x} = R_{y}$：$C=0$, $Z=1$, $P=0$。\n    *   如果 $R_{x} > R_{y}$：$C=0$, $Z=0$, $P=0$。\n    *   如果无序（至少一个操作数是 NaN）：$C=1$, $Z=1$, $P=1$。\n*   **条件分支指令：** 问题根据标志位的值定义了几种分支指令的行为：\n    *   $\\text{JBE}\\;L$：如果小于或等于则跳转，在 $(C=1)\\lor(Z=1)$ 时执行。\n    *   $\\text{JA}\\;L$：如果大于则跳转，在 $(C=0)\\land(Z=0)$ 时执行。\n    *   $\\text{JP}\\;L$：如果奇偶位为1则跳转，在 $P=1$ 时执行。\n    *   $\\text{JNP}\\;L$：如果奇偶位为0则跳转，在 $P=0$ 时执行。\n    *   $\\text{JE}\\;L$：如果等于则跳转，在 $Z=1$ 时执行。\n    *   $\\text{JNE}\\;L$：如果不等于则跳转，在 $Z=0$ 时执行。\n*   **假设：** 每个候选代码序列都紧跟在 $\\text{FCMP.S}\\;R_{x},R_{y}$ 指令之后。允许使用无条件跳转指令 $\\text{JMP}$。\n\n#### 步骤 2：使用提取的已知条件进行验证\n\n1.  **科学性：** 这个问题牢固地建立在计算机组成和体系结构的标准概念之上，即 IEEE $754$ 浮点标准和条件码与条件分支的使用。特定的标志位设置 ($C, Z, P$) 是一个合理且一致的模型，其原理类似于现实世界指令集架构（例如 x86 FPU 或 ARM VFP）中的设置。该问题在科学和技术上是合理的。\n2.  **适定性：** 问题提供了一个清晰明确的目标，一套完整的规则来管理指令和标志位的行为，以及一组有限的测试用例（比较的四种结果）。这使得对每个提议的代码序列进行确定性评估成为可能。\n3.  **客观性：** 问题陈述使用精确、客观和技术的语言表达。在指令或结果的定义中没有主观因素或模糊之处。\n4.  **完整性和一致性：** 信息充分且自洽。为浮点比较的所有可能结果（$, =, >, \\text{无序}$）都定义了标志位设置。每个条件跳转的逻辑都明确提供。没有矛盾之处。\n\n#### 步骤 3：结论和行动\n\n问题陈述是**有效的**。这是一个定义明确、有科学依据的计算机体系结构问题。可以继续进行求解过程。\n\n### 求解推导\n\n目标是实现 `如果 ($R_{x} \\leq R_{y}$) 则跳转到 $L_{\\text{true}}$ 否则跳转到 $L_{\\text{false}}$` 的逻辑。根据指定的 IEEE $754$ 语义，条件 ($R_{x} \\leq R_{y}$) 为真，当且仅当比较是有序的且关系成立。如果比较是无序的（即涉及 NaN）或者 $R_{x} > R_{y}$，则条件为假。\n\n我们可以根据 $\\text{FCMP.S}\\;R_{x},R_{y}$ 的结果总结出期望的控制流：\n\n| 比较结果 | 标志位 ($C, Z, P$) | 期望目标 |\n| :---------------- | :------------------ | :------------- |\n| $R_x  R_y$       | $C=1, Z=0, P=0$     | $L_{\\text{true}}$     |\n| $R_x = R_y$       | $C=0, Z=1, P=0$     | $L_{\\text{true}}$     |\n| $R_x > R_y$       | $C=0, Z=0, P=0$     | $L_{\\text{false}}$    |\n| 无序 (NaN)   | $C=1, Z=1, P=1$     | $L_{\\text{false}}$    |\n\n任务是根据此表评估每个提议的指令序列。\n\n### 逐项分析\n\n#### 选项 A\n序列：\n```\nJBE  L_{\\text{true}}\nJMP  L_{\\text{false}}\n```\n$\\text{JBE}$ 指令在 $(C=1) \\lor (Z=1)$ 时跳转。\n*   **情况 $R_{x}  R_{y}$ ($C=1, Z=0$)：** 条件 $(1=1) \\lor (0=1)$ 为真。代码跳转到 $L_{\\text{true}}$。**正确。**\n*   **情况 $R_{x} = R_{y}$ ($C=0, Z=1$)：** 条件 $(0=1) \\lor (1=1)$ 为真。代码跳转到 $L_{\\text{true}}$。**正确。**\n*   **情况 $R_{x} > R_{y}$ ($C=0, Z=0$)：** 条件 $(0=1) \\lor (0=1)$ 为假。代码顺序执行到 $\\text{JMP}\\;L_{\\text{false}}$。**正确。**\n*   **情况 无序 ($C=1, Z=1$)：** 条件 $(1=1) \\lor (1=1)$ 为真。代码跳转到 $L_{\\text{true}}$。这是**不正确的**，因为期望的结果是跳转到 $L_{\\text{false}}$。\n\n**选项 A 的结论：** **不正确**。此序列未能正确处理无序 (NaN) 情况，这是将浮点比较映射到整数式分支时常见的错误。\n\n#### 选项 B\n序列：\n```\nJP   L_{\\text{false}}\nJBE  L_{\\text{true}}\nJMP  L_{\\text{false}}\n```\n$\\text{JP}$ 指令在 $P=1$ 时跳转，这专门针对无序情况。\n*   **情况 无序 ($P=1$)：** 条件 $P=1$ 为真。代码跳转到 $L_{\\text{false}}$。**正确。**\n*   对于所有其他情况（$R_{x}  R_{y}$、$R_{x} = R_{y}$、$R_{x} > R_{y}$），$P=0$，因此不执行 $\\text{JP}$ 跳转。控制流继续到 $\\text{JBE}$ 指令。\n*   **情况 $R_{x}  R_{y}$ ($C=1, Z=0$)：** $\\text{JBE}$ 的条件 $(1=1) \\lor (0=1)$ 为真。代码跳转到 $L_{\\text{true}}$。**正确。**\n*   **情况 $R_{x} = R_{y}$ ($C=0, Z=1$)：** $\\text{JBE}$ 的条件 $(0=1) \\lor (1=1)$ 为真。代码跳转到 $L_{\\text{true}}$。**正确。**\n*   **情况 $R_{x} > R_{y}$ ($C=0, Z=0$)：** $\\text{JBE}$ 的条件 $(0=1) \\lor (0=1)$ 为假。代码顺序执行到 $\\text{JMP}\\;L_{\\text{false}}$。**正确。**\n\n**选项 B 的结论：** **正确**。此序列通过首先显式检查无序条件并进行分支，正确处理了所有四种情况。\n\n#### 选项 C\n序列：\n```\nJNP  L_{\\text{ordered}}\nJMP  L_{\\text{false}}\nL_{\\text{ordered}}:\nJBE  L_{\\text{true}}\nJMP  L_{\\text{false}}\n```\n$\\text{JNP}$ 指令在 $P=0$ 时跳转，这针对所有有序情况。\n*   **情况 无序 ($P=1$)：** 条件 $P=0$ 为假。不执行 $\\text{JNP}$ 跳转。代码顺序执行到 $\\text{JMP}\\;L_{\\text{false}}$。**正确。**\n*   对于所有其他情况（$R_{x}  R_{y}$、$R_{x} = R_{y}$、$R_{x} > R_{y}$），$P=0$，因此执行 $\\text{JNP}$ 跳转，控制转移到标签 $L_{\\text{ordered}}$。\n*   在 $L_{\\text{ordered}}$ 处，我们有序列 `JBE L_true; JMP L_false`，我们之前在选项 A 中已经分析过它对于有序情况的处理。\n    *   **情况 $R_{x}  R_{y}$ ($C=1, Z=0$)：** 执行 $\\text{JBE}$ 跳转。跳转到 $L_{\\text{true}}$。**正确。**\n    *   **情况 $R_{x} = R_{y}$ ($C=0, Z=1$)：** 执行 $\\text{JBE}$ 跳转。跳转到 $L_{\\text{true}}$。**正确。**\n    *   **情况 $R_{x} > R_{y}$ ($C=0, Z=0$)：** 不执行 $\\text{JBE}$ 跳转。顺序执行到 $\\text{JMP}\\;L_{\\text{false}}$。**正确。**\n\n**选项 C 的结论：** **正确**。此序列在逻辑上等同于选项 B。它将有序情况的逻辑与无序情况明确地分离开来。\n\n#### 选项 D\n序列：\n```\nJA   L_{\\text{false}}\nJP   L_{\\text{false}}\nJMP  L_{\\text{true}}\n```\n此序列使用了不同的策略：它识别出所有应导致 `false` 结果的条件并跳转到 $L_{\\text{false}}$，让 `true` 的结果顺序执行，最终通过无条件跳转到达 $L_{\\text{true}}$。\n条件在 ($R_{x} > R_{y}$) 和 (无序) 的情况下应为假。\n*   **情况 $R_{x} > R_{y}$ ($C=0, Z=0, P=0$)：** $\\text{JA}$ 指令检查是否 $(C=0) \\land (Z=0)$。这里，$(0=0) \\land (0=0)$ 为真。代码跳转到 $L_{\\text{false}}$。**正确。**\n*   **情况 无序 ($C=1, Z=1, P=1$)：** $\\text{JA}$ 的条件 $(1=0) \\land (1=0)$ 为假。不执行 $\\text{JA}$ 跳转。控制流继续到 $\\text{JP}$。$\\text{JP}$ 的条件 $P=1$ 为真。代码跳转到 $L_{\\text{false}}$。**正确。**\n*   **情况 $R_{x}  R_{y}$ ($C=1, Z=0, P=0$)：** $\\text{JA}$ 的条件 $(1=0) \\land (0=0)$ 为假。代码顺序执行。$\\text{JP}$ 的条件 $P=1$ 为假。代码顺序执行到 $\\text{JMP}\\;L_{\\text{true}}$。**正确。**\n*   **情况 $R_{x} = R_{y}$ ($C=0, Z=1, P=0$)：** $\\text{JA}$ 的条件 $(0=0) \\land (1=0)$ 为假。代码顺序执行。$\\text{JP}$ 的条件 $P=1$ 为假。代码顺序执行到 $\\text{JMP}\\;L_{\\text{true}}$。**正确。**\n\n**选项 D 的结论：** **正确**。此序列通过筛选出假条件并默认处理为真，正确地实现了逻辑。", "answer": "$$\\boxed{BCD}$$", "id": "3629890"}]}