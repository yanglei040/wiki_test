{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。要真正理解冒险检测单元的工作原理，最好的方法莫过于亲手计算其造成的影响。本节的第一个练习将引导你分析最基本的数据冒险类型——“写后读”（RAW）冒险，并量化流水线为解决此冒险而必须插入的停顿周期。通过推导在有和没有数据转发两种情况下的停顿总数，你将清晰地看到转发技术在提升流水线效率方面的巨大价值。[@problem_id:3647250]", "problem": "考虑一个按序、五级流水线，由指令提取 (IF)、指令解码与寄存器读取 (ID)、执行 (EX)、内存访问 (MEM) 和写回 (WB) 组成。该流水线包含一个冒险检测单元 (HDU)，它会阻塞前端以防止写后读数据冒险。假设每个阶段恰好花费一个时钟周期，并且没有控制冒险和结构冒险。假设本问题中的所有指令都是算术逻辑指令，读取单个源寄存器并写入单个目的寄存器。\n\n给定一个参数，称为生产者-消费者数据延迟，记为 $L \\in \\mathbb{Z}_{\\ge 1}$。将 $L$ 解释为，当没有结果前递时（即消费者只能看到值被写回到寄存器文件之后），一个消费者指令相对于其所依赖的紧邻的前一个生产者指令必须延迟的时钟周期数，以便观察到正确的值。通过完全单周期结果前递（也称为旁路），消费者可以比寄存器文件写回路径允许的时间提早一个流水线阶段捕获生产者的结果，从而使每个生产者-消费者对所需的延迟恰好减少1个周期。\n\n构造一个长度为 $N \\in \\mathbb{Z}_{\\ge 1}$、依赖距离为1的病态相关指令流，如下所示。设序列为 $\\{I_{1}, I_{2}, \\ldots, I_{N}\\}$，其中对于一个固定的体系结构寄存器 $R$ 和某个纯函数 $g$，每个指令的形式为\n$I_{k}: R \\leftarrow g(R)$\n因此，对于每个 $k \\in \\{1,2,\\ldots,N-1\\}$，指令 $I_{k+1}$ 是由 $I_{k}$ 产生的值的消费者，并且在程序顺序上紧邻（依赖距离为1）。\n\n从流水线分段和写后读顺序的核心定义出发，推导以下各项的闭式表达式：\n1) 在没有前递的情况下，冒险检测单元在整个流中插入的停顿周期总数，\n2) 在有完全单周期前递的情况下，冒险检测单元在整个流中插入的停顿周期总数，以及\n3) 前递所带来的停顿周期总数的绝对减少量。\n\n将你的最终答案表示为关于 $N$ 和 $L$ 的单个行向量 $\\big[T_{\\text{no fwd}}, T_{\\text{fwd}}, \\Delta\\big]$。无需数值近似；请提供闭式解析表达式。", "solution": "我们从与流水线执行和数据冒险相关的基本定义开始：\n- 写后读 (RAW) 冒险发生于一条指令（消费者）需要读取一个由更早的指令（生产者）产生的操作数，而该生产者的结果尚未在消费者的使用点可用。\n- 在按序流水线中，冒险检测单元 (HDU) 通过阻塞消费者来强制执行正确的顺序，直到生产者的值在消费者的操作数输入端可用。\n- 在没有前递的情况下，消费者只有在值被写回到寄存器文件后才能观察到该值。有了前递，消费者可以比写回早一个阶段直接从流水线寄存器中捕获生产者的结果，从而从生产者到消费者的等待中移除一个周期。\n\n根据构造，指令流 $\\{I_{1}, I_{2}, \\ldots, I_{N}\\}$ 是一个依赖距离为1的依赖链：对于每个 $k \\in \\{1,\\ldots,N-1\\}$，指令 $I_{k+1}$ 消费由 $I_{k}$ 产生的值。让我们用 $L \\in \\mathbb{Z}_{\\ge 1}$ 表示在没有前递的情况下给定的生产者-消费者数据延迟。根据问题中给出的定义，这个 $L$ 是 HDU 必须延迟每个消费者的周期数，以使其在指令解码 (ID) 阶段和随后的执行 (EX) 阶段的读取能够通过寄存器文件路径观察到正确的值，当前递不可用时。\n\n我们现在推断 HDU 在整个流中引入的总停顿。\n\n1) 没有前递。因为每对 $\\big(I_{k}, I_{k+1}\\big)$ 的依赖距离为1，在没有冒险的情况下，消费者 $I_{k+1}$ 会在 $I_{k}$ 之后一个周期进入其 ID 阶段。然而，在这种没有前递的流水线配置中，根据 $L$ 的含义，HDU 必须将 $I_{k+1}$ 延迟恰好 $L$ 个周期，以便将消费者的操作数读取与生产者的值通过寄存器文件可用的周期对齐。因此，对于每个相邻的生产者-消费者对，HDU 插入 $L$ 个停顿周期。\n\n在一个包含 $N$ 条指令的链中，恰好有 $N-1$ 个这样的相邻依赖对，因为 $I_{1}$ 在序列中没有前驱，而每个后续指令都依赖于其直接前驱。由于每对所需的停顿随着流水线在链中推进而发生在不同的时间点，因此停顿周期的总数是所有对的总和：\n$$\nT_{\\text{no fwd}} \\;=\\; L \\cdot (N - 1).\n$$\n\n2) 完全单周期前递。通过完全单周期前递，消费者可以比依赖寄存器文件写回路径时提早一个流水线阶段捕获生产者的结果。这为每个生产者-消费者对所需的等待恰好移除了一个周期。因此，对于每个相邻的依赖对，所需的停顿从 $L$ 减少到 $L-1$。对 $N-1$ 对求和得出\n$$\nT_{\\text{fwd}} \\;=\\; (L - 1) \\cdot (N - 1).\n$$\n\n3) 绝对减少量。由于前递导致的停顿周期总数的绝对减少量是没有前递和有前递情况下总数的差值：\n$$\n\\Delta \\;=\\; T_{\\text{no fwd}} - T_{\\text{fwd}} \\;=\\; \\big[L \\cdot (N - 1)\\big] - \\big[(L - 1) \\cdot (N - 1)\\big] \\;=\\; (N - 1).\n$$\n\n因此，关于 $N$ 和 $L$ 的闭式表达式为\n$$\nT_{\\text{no fwd}} = L(N-1), \\quad T_{\\text{fwd}} = (L-1)(N-1), \\quad \\Delta = (N-1).\n$$\n\n我们按要求将最终答案表示为单个行向量。", "answer": "$$\n\\boxed{\\begin{pmatrix} L(N-1)  (L-1)(N-1)  (N-1) \\end{pmatrix}}\n$$", "id": "3647250"}, {"introduction": "在所有数据冒险中，“加载-使用”冒险尤为关键，因为它涉及相对较慢的内存访问。这个练习将带你从抽象的停顿计算深入到具体的硬件设计层面。你将为流水线的冒险检测单元设计核心的布尔逻辑表达式，用于精确识别加载-使用冒险，然后在一个实际的指令序列上跟踪并计算因此产生的停顿周期，从而将理论与硬件实现紧密联系起来。[@problem_id:3647216]", "problem": "考虑一个经典的五级顺序单发射流水线，其阶段包括：指令提取 (IF)、指令解码和寄存器读取 (ID)、执行 (EX)、内存访问 (MEM) 和写回 (WB)。该处理器为算术逻辑单元的输出实现了完整的旁路（前递）路径，因此在执行阶段结束时产生的算术结果可以前递到下一条指令的执行阶段，而无需引入停顿。加载指令在内存访问阶段从内存读取数据，并在写回阶段将值写入目的寄存器。将加载-使用延迟 $L$ 定义为生产者指令的执行阶段开始，到加载的值可以通过前递呈现给消费者指令的执行阶段输入的最早周期之间的周期数；假设在此流水线中，加载指令的 $L=2$。\n\n当指令解码和寄存器读取阶段的指令读取的源寄存器 $rs$ 或源寄存器 $rt$ 等于执行阶段指令的目的寄存器 $rd$，且执行阶段的指令是加载指令时，冒险检测单元必须产生一个停顿信号。零寄存器 $r0$ 在体系结构上硬连线为零，对 $r0$ 的写入无效；冒险检测单元应忽略作为目的寄存器的 $r0$。\n\n仅使用关于结果何时可用以及加载-使用延迟 $L$ 定义的成熟流水线知识，完成以下任务：\n\n1. 根据信号 $EX\\_\\mathrm{isLoad}$、$EX\\_rd$、$ID\\_rs$ 和 $ID\\_rt$，推导出一个停顿信号的最小布尔表达式，并包括 $r0$ 的特殊情况。您的表达式相对于当前周期的流水线寄存器内容必须是纯组合逻辑的（没有计数器或计时器）。\n\n2. 然后，从空流水线开始，在上述假设和算术逻辑单元结果完全前递的情况下，估算执行以下连续的三条相关指令序列时将插入的总停顿周期数：\n   - $I1$: $\\mathrm{LW}\\ r1,\\ 0(r2)$\n   - $I2$: $\\mathrm{LW}\\ r3,\\ 0(r1)$\n   - $I3$: $\\mathrm{ADD}\\ r4,\\ r3,\\ r5$\n\n产生最终答案，该答案为一个实数值，等于为该三指令序列插入的总停顿周期数。无需四舍五入。最终答案无需单位。", "solution": "该问题经评估有效，因为它在科学上基于计算机体系结构原理，问题阐述清晰且内部一致。因此，我们可以着手解决。\n\n问题分为两部分。首先，我们推导停顿信号的布尔表达式。其次，我们计算给定指令序列的总停顿周期数。\n\n**第1部分：布尔停顿信号表达式的推导**\n\n问题指明了冒险检测单元必须产生停頓信号的条件。如果指令解码（ID）阶段的指令与当前处于执行（EX）阶段的加载指令存在源寄存器依赖关系，则需要停顿。让我们将这些条件形式化。\n\n逻辑表达式的已知条件是：\n- $EX\\_\\mathrm{isLoad}$：一个信号，如果EX阶段的指令是加载指令，则为真（$1$）。\n- $EX\\_rd$: EX阶段指令的目的寄存器索引。\n- $ID\\_rs$: ID阶段指令的第一个源寄存器索引。\n- $ID\\_rt$: ID阶段指令的第二个源寄存器索引。\n\n停顿的条件是：\n1. EX阶段的指令是加载指令。这对应于条件 $EX\\_\\mathrm{isLoad} = 1$。\n2. EX阶段加载指令的目的寄存器不是零寄存器 $r0$。寄存器 $r0$ 对应索引 $0$。因此，此条件为 $EX\\_rd \\neq 0$。\n3. ID阶段的指令使用了加载的结果。这意味着它的至少一个源寄存器（$ID\\_rs$ 或 $ID\\_rt$）与EX阶段加载指令的目的寄存器（$EX\\_rd$）相同。这表示为 $(ID\\_rs = EX\\_rd) \\lor (ID\\_rt = EX\\_rd)$。\n\n将这三个条件通过逻辑与运算结合起来，得到停顿信号的完整表达式，我们将其表示为 $S$。当且仅当所有三个条件都满足时，才会发生停顿。\n\n因此，停顿信号 $S$ 的最小布尔表达式为：\n$$S = EX\\_\\mathrm{isLoad} \\land (EX\\_rd \\neq 0) \\land ((ID\\_rs = EX\\_rd) \\lor (ID\\_rt = EX\\_rd))$$\n这个表达式是最小的，因为它直接表示了问题陈述中描述的必要和充分条件，没有任何冗余项。\n\n**第2部分：总停顿周期数的计算**\n\n我们需要计算以下指令序列的总停顿周期数：\n- $I1: \\mathrm{LW}\\ r1, 0(r2)$\n- $I2: \\mathrm{LW}\\ r3, 0(r1)$\n- $I3: \\mathrm{ADD}\\ r4, r3, r5$\n\n流水线对ALU结果有完全前递，这意味着ALU-ALU依赖不会产生停顿（$0$个停顿周期）。问题定义了加载-使用延迟 $L=2$。加载-使用依赖的停顿周期数为 $L-1$。在本例中，$L-1 = 2-1 = 1$ 个停顿周期。我们可以通过跟踪流水线执行来验证这一点。\n\n让我们分析指令之间的依赖关系。\n\n**依赖关系1：$I1 \\rightarrow I2$**\n- $I1$ 是 $\\mathrm{LW}\\ r1, 0(r2)$，它会写入寄存器 $r1$。\n- $I2$ 是 $\\mathrm{LW}\\ r3, 0(r1)$，它会读取寄存器 $r1$ 来计算其内存地址。\n这是一个经典的加载-使用数据冒险。我们跟踪流水线，看看何时检测到冒险并插入停顿。\n\n| 周期 | $I1: \\mathrm{LW}\\ r1,..$ | $I2: \\mathrm{LW}\\ r3, 0(r1)$ | $I3: \\mathrm{ADD}\\ r4, r3,..$ | 注释 |\n|---:|:---|:---|:---|:---|\n| $1$ | IF | | | 获取 $I1$。 |\n| $2$ | ID | IF | | 获取 $I2$。 |\n| $3$ | EX | ID | IF | 获取 $I3$。检测到冒险：$I2$ 需要 $r1$，而 $r1$ 将由 $I1$ 产生。 |\n| $4$ | MEM | ID (停顿) | IF (停顿) | $I1$（加载指令）在EX阶段，其目的寄存器是 $r1$。$I2$ 在ID阶段，其源寄存器之一是 $r1$。产生停顿信号。插入一个气泡。 |\n| $5$ | WB | EX | ID | 停顿结束。$I1$ 的结果从MEM/WB寄存器前递到 $I2$ 的EX阶段。 |\n\n在周期 $3$，$I1$ 处于EX阶段，$I2$ 处于ID阶段。冒险检测逻辑适用：\n- 对于 $I1$，$EX\\_\\mathrm{isLoad}$ 为真。\n- $EX\\_rd$ 是 $r1$（不是 $r0$）。\n- $I2$ 的 $ID\\_rs$ 是 $r1$。\n条件 $(ID\\_rs = EX\\_rd)$ 为真。\n因此，停顿信号 $S$ 被置位。这引入了1个周期的停顿。流水线插入一个气泡，因此 $I2$ 在周期4保持在ID阶段，$I1$ 则进入MEM阶段。\n\n**依赖关系2：$I2 \\rightarrow I3$**\n- $I2$ 是 $\\mathrm{LW}\\ r3, 0(r1)$，它会写入寄存器 $r3$。\n- $I3$ 是 $\\mathrm{ADD}\\ r4, r3, r5$，它会读取寄存器 $r3$ 用于加法运算。\n这是另一个加载-使用数据冒险。我们从上次中断的地方继续跟踪流水线。\n\n| 周期 | $I1: \\mathrm{LW}\\ r1,..$ | $I2: \\mathrm{LW}\\ r3, 0(r1)$ | $I3: \\mathrm{ADD}\\ r4, r3,..$ | 注释 |\n|---:|:---|:---|:---|:---|\n| $5$ | WB | EX | ID | 检测到冒险：$I3$ 需要 $r3$，而 $r3$ 将由 $I2$ 产生。 |\n| $6$ | | MEM | ID (停顿) | $I2$（加载指令）在EX阶段，其目的寄存器是 $r3$。$I3$ 在ID阶段，其源寄存器之一是 $r3$。产生停顿信号。插入一个气泡。 |\n| $7$ | | WB | EX | 停顿结束。$I2$ 的结果从MEM/WB寄存器前递到 $I3$ 的EX阶段。 |\n| $8$ | | | MEM | $I3$ 继续执行。 |\n| $9$ | | | WB | $I3$ 完成。 |\n\n在周期 $5$，$I2$ 处于EX阶段，$I3$ 处于ID阶段。冒险检测逻辑再次被触发：\n- 对于 $I2$，$EX\\_\\mathrm{isLoad}$ 为真。\n- $EX\\_rd$ 是 $r3$（不是 $r0$）。\n- $I3$ 的 $ID\\_rs$ 是 $r3$。\n条件 $(ID\\_rs = EX\\_rd)$ 为真。\n停顿信号 $S$ 被置位，导致了第二次为期1个周期的停顿。\n\n总停頓周期数是每次检测到的冒险所引起的停頓之和。\n- 依赖关系 $I1 \\rightarrow I2$ 导致了 1 个停頓周期。\n- 依赖关系 $I2 \\rightarrow I3$ 导致了 1 个停頓周期。\n\n总停頓周期 = $1 + 1 = 2$。", "answer": "$$\\boxed{2}$$", "id": "3647216"}, {"introduction": "真实的指令流中常常包含复杂的依赖关系，这要求冒险检测单元具备精准的判断能力。本练习模拟了一个微妙但常见的场景：在一条指令读取某个寄存器之前，有多条指令都对该寄存器进行了写入。你需要分析并决定，冒险检测单元应该基于哪一条生产指令来触发停顿，这直接关系到程序执行的正确性。通过这个练习，你将掌握处理多重依赖和确保数据流正确性的关键原则。[@problem_id:3647243]", "problem": "考虑一个单发射、顺序执行的五级流水线，其阶段包括指令提取（IF）、指令解码与寄存器读取（ID）、执行（EX）、内存访问（MEM）和写回（WB）。该机器实现了从生成阶段到后续周期中较新指令的 EX 阶段的完全转发（也称为旁路）。以下基本事实成立：\n\n- EX 阶段在其执行周期的开始时需要源操作数。\n- 算术或逻辑生产者在 EX 阶段计算其结果，该值在 EX 周期结束时可用于转发。\n- 加载生产者在 MEM 周期结束时获取其数据，并且该值只能在下一周期中较新指令的 EX 阶段用于转发。\n- 寄存器文件写操作发生在 WB 阶段，读操作发生在 ID 阶段；顺序完成保证了写的程序顺序可见性，寄存器文件中没有写后写冒险。\n\nID 阶段的冒险检测单元（HDU）通过比较 ID 阶段指令的源寄存器与流水线中更早的正在执行指令的目标寄存器，来决定是否暂停当前在 ID 阶段的指令，以避免写后读（RAW）冒险。当多个更早的正在执行的指令将写入同一个目标寄存器 $rd$ 时，只有程序顺序中最近（最新）的生产者才能决定消费者必须接收的正确值。\n\n假设指令序列如下：\n- $I_1$: $LW\\; r_d, 0(r_a)$\n- $I_2$: $LW\\; r_d, 8(r_a)$\n- $I_3$: $ADD\\; r_t, r_d, r_b$\n\n这三条指令在程序顺序中是连续的。当 $I_3$ 首次进入 $ID$ 阶段的那个周期，流水线各阶段包含：\n- $I_1$ 在 $MEM$ 阶段，\n- $I_2$ 在 $EX$ 阶段，\n- $I_3$ 在 $ID$ 阶段。\n\n假设实现了从 $MEM$ 和 $WB$ 到后续周期的 $EX$ 阶段的转发，但在一个阶段结束时产生的值不能被另一条指令在同一周期的 $EX$ 阶段开始时使用。\n\nHDU 应该采用哪种策略来正确防止冒险，并对上述场景中对 $rd$ 的多个匹配进行优先级排序？\n\nA. 暂停 $I_3$ 直到 $I_1$ 完成，因为 $I_1$ 是 $r_d$ 最早的匹配生产者。为安全起见，优先考虑流水线中最早的匹配 $rd$。\n\nB. 仅基于 $I_2$ 暂停 $I_3$，因为它是 $r_d$ 最近的匹配生产者。优先考虑最新的匹配 $rd$（程序顺序上最接近的），并精确插入 $1$ 个周期的暂停，以便 $I_3$ 的 $EX$ 阶段在 $I_2$ 的 $MEM$ 数据可转发之后发生。\n\nC. 暂停 $I_3$ 直到 $I_1$ 和 $I_2$ 都已写回寄存器文件，以保证 $ID$ 阶段获取最新值。当存在到同一个 $rd$ 的多个生产者时，要求两者都完成后才允许消费者继续。\n\nD. 不暂停 $I_3$，因为从 $MEM$ 的转发允许 $I_3$ 在 $I_2$ 处于 $MEM$ 阶段的同一周期接收 $r_d$。优先考虑任何可用的匹配 $rd$，并依赖同一周期转发来避免暂停。", "solution": "首先验证问题陈述的科学性、一致性和完整性。\n\n### 步骤 1：提取已知条件\n\n- 流水线架构：单发射、顺序执行的 $5$ 级流水线，其阶段包括指令提取（IF）、指令解码与寄存器读取（ID）、执行（EX）、内存访问（MEM）和写回（WB）。\n- 转发：从生成阶段到较新指令的 EX 阶段的完全转发。\n- 操作数时序：EX 阶段在周期的开始时需要源操作数。\n- ALU 生产者时序：算术/逻辑生产者在 EX 阶段计算其结果，该值在那个 EX 周期结束时可用于转发。\n- 加载生产者时序：加载生产者在 MEM 周期结束时获取其数据，并且该值只能在下一周期中较新指令的 EX 阶段用于转发。\n- 寄存器文件时序：写操作发生在 WB 阶段；读操作发生在 ID 阶段。\n- 冒险处理：ID 阶段的冒险检测单元（HDU）暂停当前在 ID 阶段的指令，以避免写后读（RAW）冒险。\n- 多生产者规则：对于多个写入同一目标寄存器 $r_d$ 的旧指令，消费者必须使用来自最近（最新）生产者的值。\n- 指令序列：\n    - $I_1$: $LW\\; r_d, 0(r_a)$\n    - $I_2$: $LW\\; r_d, 8(r_a)$\n    - $I_3$: $ADD\\; r_t, r_d, r_b$\n- 流水线状态快照：当 $I_3$ 首次进入 ID 阶段的那个周期，$I_1$ 在 MEM 阶段，$I_2$ 在 EX 阶段，$I_3$ 在 ID 阶段。\n- 转发约束：在一个阶段结束时产生的值不能被另一条指令在同一周期的 EX 阶段开始时使用。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n问题陈述具有科学依据且定义明确。它描述了一个典型的 $5$ 级 RISC 流水线，这是计算机组成和体系结构中的一个经典模型。所有提供的规则——数据转发路径、冒险检测和指令时序——都是标准的且内部一致的。所呈现的场景是一个教科书级别的加载-使用数据冒险的例子，并且因输出依赖而变得复杂，这是流水线设计中一个常见且实际的问题。问题的说明足够详细和清晰，可以得出一个唯一的逻辑解。给定的流水线状态与顺序流水线执行给定指令序列的行为是一致的。语言客观且明确。问题没有违反任何基本原则，也不是不完整或矛盾的。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。将推导解决方案。\n\n### 基于原则的推导\n\n冒险检测单元（HDU）的核心任务是通过强制执行数据依赖来确保正确执行。我们必须分析给定指令序列的依赖关系，并应用流水线时序规则。\n\n1.  **数据依赖性分析**：\n    指令 $I_3: ADD\\; r_t, r_d, r_b$ 使用寄存器 $r_d$ 作为源操作数。前面的两条指令 $I_1$ 和 $I_2$ 都写入同一个寄存器 $r_d$。这造成了写后读（RAW）冒险。问题指明了解决这种多生产者场景的规则：“只有程序顺序中最近（最新）的生产者才能决定消费者必须接收的正确值。” 在序列 $I_1$、$I_2$、$I_3$ 中，相对于消费者 $I_3$ 而言，$r_d$ 的最新生产者是 $I_2$。因此，$I_3$ 对 $I_2$ 有真正的数据依赖。$I_1$ 的结果在 $I_3$ 执行前被 $I_2$ 覆盖，所以 HDU 必须强制执行依赖关系 $I_2 \\rightarrow I_3$，并且可以忽略依赖关系 $I_1 \\rightarrow I_3$。HDU 的逻辑必须基于为 $I_2$ 进行暂停。\n\n2.  **流水线时序与暂停计算**：\n    我们将给定流水线状态发生的周期表示为周期 $k$。\n    - **周期 $k$ 的状态**：\n        - $I_1$ (LW): MEM\n        - $I_2$ (LW): EX\n        - $I_3$ (ADD): ID\n    ID 阶段的 HDU 检测到 $I_3$ 读取 $r_d$，并且在 EX 阶段的 $I_2$ 写入 $r_d$。由于 $I_2$ 是一条加载指令（LW），因此适用于加载-使用冒险的特定时序。\n\n    为了确定是否需要暂停，我们追踪在不插入暂停的情况下流水线的进展。\n    - **周期 $k+1$ 开始时（无暂停）**：\n        - $I_2$ 前进到 MEM 阶段。\n        - $I_3$ 前进到 EX 阶段。\n        - 根据问题规则，$I_3$ 在其 EX 阶段的*开始*时需要 $r_d$ 的值，即在周期 $k+1$ 的开始时。\n    - **来自 $I_2$ 的数据可用性**：\n        - $I_2$ 是一条加载指令。其数据在它的 MEM 阶段（周期 $k+1$）从内存中获取。\n        - 根据规则，“加载生产者在 MEM 周期结束时获取其数据”。因此，来自 $I_2$ 的 $r_d$ 的值仅在周期 $k+1$ 的*结束*时可用。\n\n    这里存在冲突：$I_3$ 在周期 $k+1$ 的开始时需要该值，但 $I_2$ 在周期 $k+1$ 的结束时才提供该值。这是一个经典的加载-使用冒险。转发硬件无法在没有暂停的情况下解决这个问题，正如明确说明的：“在一个阶段结束时产生的值不能被另一条指令在同一周期的 EX 阶段开始时使用。”\n\n    因此，HDU 必须暂停 $I_3$。让我们确定所需的暂停持续时间。一个 $1$ 周期的暂停是标准解决方案。我们来验证一下。\n    - **在周期 $k$**：HDU 检测到冒险并使流水线暂停 $1$ 个周期。这意味着 $I_3$ 被保持在 ID 阶段，一个气泡（空操作）被注入到 EX 阶段。\n    - **周期 $k+1$ 的状态（有 $1$ 个暂停周期）**：\n        - $I_1$ 前进到 WB。\n        - $I_2$ 前进到 MEM。\n        - $I_3$ 仍留在 ID。\n        - 一个气泡进入 EX 阶段。\n    - **周期 $k+2$ 的状态**：暂停完成，流水线正常前进。\n        - $I_2$ 前进到 WB。\n        - $I_3$ 前进到 EX。\n        - 气泡前进到 MEM。\n    - **周期 $k+2$ 中 $I_3$ 的数据可用性**：\n        - $I_3$ 在其 EX 阶段的开始时（周期 $k+2$）需要 $r_d$ 的值。\n        - 来自 $I_2$ 的值在其 MEM 阶段结束时（周期 $k+1$ 结束时）变得可用。\n        - 规则规定：“值只能在下一周期的 EX 阶段用于转发”。$I_2$ 的 MEM 阶段（周期 $k+1$）之后的周期是周期 $k+2$。因此，MEM 到 EX 的转发路径可以将值从周期 $k+1$ 的末尾提供给周期 $k+2$ 的开始。\n\n    通过精确地 $1$ 个暂停周期，执行是正确的。HDU 的策略必须是优先考虑最新的生产者（$I_2$）并插入一个 $1$ 周期的暂停。\n\n### 逐项分析选项\n\n**A. 暂停 $I_3$ 直到 $I_1$ 完成，因为 $I_1$ 是 $r_d$ 最早的匹配生产者。为安全起见，优先考虑流水线中最早的匹配 $rd$。**\n此策略不正确。它违反了顺序一致性的基本要求，这一点在问题中明确说明：“只有程序顺序中最近（最新）的生产者才能决定正确的值”。优先考虑最早的生产者 $I_1$ 会导致 $I_3$ 接收到错误的 $r_d$ 值（由 $I_1$ 加载的值，该值本应被 $I_2$ 覆盖）。\n**结论：不正确。**\n\n**B. 仅基于 $I_2$ 暂停 $I_3$，因为它是 $r_d$ 最近的匹配生产者。优先考虑最新的匹配 $rd$（程序顺序上最接近的），并精确插入 $1$ 个周期的暂停，以便 $I_3$ 的 $EX$ 阶段在 $I_2$ 的 $MEM$ 数据可转发之后发生。**\n此策略与我们的推导完全一致。\n1.  它正确地识别了对最近生产者 $I_2$ 的依赖。\n2.  它正确地确定了为解决加载-使用冒险需要进行暂停。\n3.  它正确地计算出暂停持续时间恰好为 $1$ 个周期。\n4.  给出的理由——允许 $I_3$ 的 EX 阶段延迟到 $I_2$ 来自 MEM 阶段的数据可用于转发之后——正是解决此类流水线中加载-使用冒险的精确逻辑。\n**结论：正确。**\n\n**C. 暂停 $I_3$ 直到 $I_1$ 和 $I_2$ 都已写回寄存器文件，以保证 $ID$ 阶段获取最新值。当存在到同一个 $rd$ 的多个生产者时，要求两者都完成后才允许消费者继续。**\n此策略极其低效且不正确。它描述了一个没有任何数据转发的流水线，其中消费者必须等待生产者完成 WB 阶段。问题明确指出实现了“完全转发”。等待两个生产者也是错误的；只需要来自 $I_2$ 的值。此策略会引入许多不必要的暂停周期，并违背了带转发的流水线架构的目的。\n**结论：不正确。**\n\n**D. 不暂停 $I_3$，因为从 $MEM$ 的转发允许 $I_3$ 在 $I_2$ 处于 $MEM$ 阶段的同一周期接收 $r_d$。优先考虑任何可用的匹配 $rd$，并依赖同一周期转发来避免暂停。**\n此策略不正确，因为它误解了数据可用的时序。如推导所示，如果 $I_2$ 在周期 $k+1$ 期间处于 MEM 阶段，其数据仅在该周期结束时才可用。如果 $I_3$ 不暂停继续进行，它将在周期 $k+1$ 期间处于其 EX 阶段，并在该周期开始时需要数据。这种“同一周期”转发是不可能的，并且被问题的约束明确禁止：“在一个阶段结束时产生的值不能被另一条指令在同一周期的 EX 阶段开始时使用。” 暂停是绝对必要的。此外，优先考虑“任何可用的”生产者是不正确的；为了正确性，必须是最新一个。\n**结论：不正确。**", "answer": "$$\\boxed{B}$$", "id": "3647243"}]}