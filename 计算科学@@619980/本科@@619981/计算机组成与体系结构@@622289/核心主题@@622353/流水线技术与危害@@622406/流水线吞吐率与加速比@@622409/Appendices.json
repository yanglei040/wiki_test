{"hands_on_practices": [{"introduction": "理想的流水线加速在现实中很少能完全实现，主要是因为存在各种冒险（hazards）。本练习旨在量化数据冒险对性能的实际影响[@problem_id:3666173]。通过一个基础模型，我们将推导出一个包含随机停顿的流水线的预期每指令周期数（CPI），并计算其相对于非流水线设计的实际加速比，从而将抽象的性能损失转化为具体的数学表达式。", "problem": "一个标量、顺序执行的处理器实现了一个具有 $s$ 级的平衡流水线，并采用了操作数前推（也称为旁路）技术。每个阶段的延迟为 $t$，因此流水线时钟周期为 $t$。不存在结构冒险和控制冒险。数据冒险可能会发生：在一个包含 $N$ 条指令的长循环中，对于每条动态指令，存在一个独立的概率 $p_d$，即写后读依赖无法完全通过前推解决，从而导致相关指令在发射前产生恰好一个停顿周期。\n\n请仅使用平均性能指标和极限的基本定义，完成以下任务：\n\n- 从第一性原理出发，推导流水线处理器的期望每指令周期数 (CPI)，用 $p_d$ 表示。\n- 以一个非流水线基准作为参照，该基准是同一数据通路的多周期实现，它在 $s$ 个持续时间为 $t$ 的周期内完成每条指令（即其 CPI 为 $s$，周期时间为 $t$）。计算当 $N \\to \\infty$ 时，该非流水线机器与流水线机器对于该循环的总执行时间之比所定义的加速比 $S$。\n\n将最终加速比 $S$ 表示为关于 $s$ 和 $p_d$ 的封闭形式解析表达式。仅报告加速比 $S$ 作为最终答案。无需四舍五入。", "solution": "该问题被评估为有效。它在科学上基于计算机体系结构的原理，问题设定良好，信息充分且一致，陈述客观。该问题要求从第一性原理推导处理器性能指标，这是该领域中一个标准且可形式化的任务。\n\n分析按要求分两部分进行：首先，推导流水线处理器的期望每指令周期数 (CPI)；其次，计算加速比 $S$。\n\n首先，我们推导流水线处理器的期望 CPI，记为 $CPI_{pipe}$。CPI 定义为执行一条指令所需的平均时钟周期数。它可以表示为理想流水线的 CPI 与每条指令的平均停顿周期数之和。\n$$\nCPI_{pipe} = CPI_{ideal} + CPI_{stalls}\n$$\n对于一个在稳态下运行的理想标量流水线（考虑到问题中 $N \\to \\infty$ 的长循环条件，这是一个有效的假设），每个时钟周期完成一条指令。因此，理想 CPI 为 $1$。\n$$\nCPI_{ideal} = 1\n$$\n问题指出，性能下降的唯一来源是导致停顿的数据冒险。对于任何给定的指令，有 $p_d$ 的概率会引起恰好一个停顿周期。其他指令则不会引起停顿周期。停顿对 CPI 的贡献 $CPI_{stalls}$ 是每条指令的期望停顿周期数。其计算方法是停顿事件的概率乘以每次停顿的周期数。\n$$\nCPI_{stalls} = (\\text{Probability of stall}) \\times (\\text{Stall cycles per event})\n$$\n给定停顿概率为 $p_d$，持续时间为 $1$ 个周期，我们得到：\n$$\nCPI_{stalls} = p_d \\times 1 = p_d\n$$\n结合这些结果，流水线处理器的期望 CPI 为：\n$$\nCPI_{pipe} = CPI_{ideal} + CPI_{stalls} = 1 + p_d\n$$\n接下来，我们计算加速比 $S$。加速比定义为非流水线基准机器的总执行时间与流水线机器的总执行时间之比。\n$$\nS = \\frac{T_{unpipelined}}{T_{pipelined}}\n$$\n对于一个包含 $N$ 条指令的程序，其总执行时间 ($T$) 由通用性能公式给出：\n$$\nT = N \\times CPI \\times \\tau\n$$\n其中 $N$ 是指令数，CPI 是每条指令的周期数，$\\tau$ 是时钟周期时间。我们考虑 $N \\to \\infty$ 的极限情况，这使我们能够忽略填充和排空流水线的瞬态效应，因为与随 $N$ 线性增长的项相比，这些常数项变得可以忽略不计。\n\n对于非流水线基准机器：\n指令数为 $N$。\n给定 CPI 为 $s$，因此 $CPI_{unpipe} = s$。\n给定周期时间为 $t$，因此 $\\tau_{unpipe} = t$。\n因此，执行时间为：\n$$\nT_{unpipelined} = N \\times CPI_{unpipe} \\times \\tau_{unpipe} = N \\times s \\times t\n$$\n\n对于流水线机器：\n指令数为 $N$。\n上面已推导出 CPI 为 $CPI_{pipe} = 1 + p_d$。\n给定周期时间为 $t$，因此 $\\tau_{pipe} = t$。\n因此，执行时间为：\n$$\nT_{pipelined} = N \\times CPI_{pipe} \\times \\tau_{pipe} = N \\times (1 + p_d) \\times t\n$$\n\n现在，我们可以将这些执行时间表达式代入加速比公式来计算加速比 $S$：\n$$\nS = \\frac{T_{unpipelined}}{T_{pipelined}} = \\frac{N \\times s \\times t}{N \\times (1 + p_d) \\times t}\n$$\n指令数 $N$ 和时钟周期时间 $t$ 这两项在分子和分母中被消去。这就得到了加速比的最终表达式：\n$$\nS = \\frac{s}{1 + p_d}\n$$\n该表达式表示了加速比是关于流水线级数 $s$ 和数据冒险停顿概率 $p_d$ 的函数。流水线的理想加速比为 $s$，这在没有停顿 ($p_d = 0$) 时可以达到。分母中的项 $1 + p_d$ 代表了由停顿引起的性能惩罚因子。", "answer": "$$\n\\boxed{\\frac{s}{1 + p_d}}\n$$", "id": "3666173"}, {"introduction": "理解了冒险如何导致性能损失后，一个自然的问题是：我们能做些什么来避免这些停顿？本练习将带你从硬件分析转向软件优化[@problem_id:3666138]。我们将探讨一种关键的编译器技术——指令调度，通过巧妙地重排指令顺序来隐藏加载指令（load）带来的延迟，从而在不改变硬件的情况下消除停顿，提升流水线效率。", "problem": "一个 $5$ 级精简指令集计算机 (RISC) 流水线按顺序实现以下阶段：指令提取 (IF)、指令解码和寄存器读取 (ID)、执行或地址计算 (EX)、内存访问 (MEM) 和写回 (WB)。该处理器是单发射和按序执行的。每个流水线阶段恰好占用 $1$ 个周期。数据路径支持从 EX/MEM 和 MEM/WB 流水线寄存器到 EX 的完全前推（也称为旁路），并且冒险检测仅在为保证正确性所必需时才插入停顿。所有数据内存访问都是缓存命中，并在 MEM 阶段用 $1$ 个周期完成。没有结构冒险和控制冒险。加载指令产生的值仅在其 MEM 阶段完成后才可用于前推；因此，紧跟在加载指令之后的相关算术指令将需要恰好 $1$ 个停顿周期，而在加载指令与其相关的算术指令之间放置至少 $1$ 条无关指令则可以消除该停顿。\n\n考虑一个线性基本块，它由 $M$ 次重复（其中 $M \\ge 2$）的交替加载和使用模式组成，且配对之间没有依赖关系。对于每个 $i \\in \\{1,2,\\dots,M\\}$，该配对为：\n- 加载：$\\mathrm{LD}\\ r_i \\leftarrow \\mathrm{Mem}[a_i]$，\n- 使用：$\\mathrm{ADD}\\ u_i \\leftarrow r_i + c_i$，\n其中对于不同的 $i$，所有的 $r_i, u_i$ 都是不同的，所有地址 $a_i$ 也都不同，并且每个 $c_i$ 都与所有的 $r_j$ 无关。只要对于每个 $i$，使用 $r_i$ 的 $\\mathrm{ADD}$ 指令出现在其对应的 $\\mathrm{LD}$ 指令之后，编译器就可以任意重排指令。\n\n从每指令周期数 (CPI) 的定义和单发射 k 级流水线的基本行为出发，推导当使用最佳软件调度和完全前推时，该基本块可实现的最小平均 CPI。您的推导过程必须明确考虑流水线填充和排空效应。将您的最终答案表示为一个仅包含 $M$ 的单一封闭形式表达式。无需四舍五入，CPI 是无单位的。", "solution": "该问题要求计算在一个特定的 $5$ 级 RISC 流水线上，对于一个给定的代码块，可实现的最小平均每指令周期数 (CPI)。\n\n平均 CPI 的定义是总执行周期数除以总指令数。\n$$\n\\text{CPI} = \\frac{\\text{总周期数}}{\\text{总指令数}}\n$$\n该代码块由 $M$ 对加载 ($\\mathrm{LD}$) 指令和相关的加法 ($\\mathrm{ADD}$) 指令组成。因此，总指令数 $N_{\\text{instr}}$ 为 $2M$。\n$$\nN_{\\text{instr}} = 2M\n$$\n为了找到最小 CPI，我们必须找到执行这 $2M$ 条指令所需的最少总周期数。这可以通过找到一个能最小化流水线停顿的最佳指令调度来实现。\n\n该流水线有 $k=5$ 个阶段：IF、ID、EX、MEM、WB。每个阶段耗时 $1$ 个周期。该流水线是单发射和按序执行的。支持完全前推。关键的性能限制是在加载指令和使用其结果的指令之间的数据冒险。问题陈述，加载指令的值仅在其 MEM 阶段完成后才可用于前推。像 $\\mathrm{ADD}$ 这样的算术指令在其 EX 阶段需要其操作数。\n\n让我们在没有任何调度的情况下分析一个加载-使用对的时序：\n$\\mathrm{LD}\\ r_i, \\dots$\n$\\mathrm{ADD}\\ u_i, r_i, \\dots$\n\n假设 $\\mathrm{LD}$ 指令在周期 $t$ 进入 IF 阶段。\n- 周期 $t$：$\\mathrm{LD}$ 在 IF 阶段\n- 周期 $t+1$：$\\mathrm{LD}$ 在 ID 阶段，$\\mathrm{ADD}$ 在 IF 阶段\n- 周期 $t+2$：$\\mathrm{LD}$ 在 EX 阶段，$\\mathrm{ADD}$ 在 ID 阶段\n- 周期 $t+3$：$\\mathrm{LD}$ 在 MEM 阶段，$\\mathrm{ADD}$ 在 EX 阶段\n\n在周期 $t+3$ 开始时，$\\mathrm{ADD}$ 指令处于其 EX 阶段，需要寄存器 $r_i$ 的值。$\\mathrm{LD}$ 指令处于其 MEM 阶段，并且只会在周期 $t+3$ 结束时产生这个值。该值被写入 MEM/WB 流水线寄存器，并在周期 $t+4$ 开始时可用于前推。因此，存在数据冒险。冒险检测逻辑必须将流水线中的 $\\mathrm{ADD}$ 指令停顿一个周期。\n\n带停顿的正确执行过程：\n- 周期 $t+3$：$\\mathrm{LD}$ 在 MEM 阶段，$\\mathrm{ADD}$ 被停顿（保留在 ID 阶段）。\n- 周期 $t+4$：$\\mathrm{LD}$ 在 WB 阶段，$\\mathrm{ADD}$ 进入 EX 阶段。$r_i$ 的值从现已填充的 MEM/WB 寄存器前推到 EX 阶段。\n这证实了问题的陈述，即紧跟在加载指令之后的相关指令需要 $1$ 个周期的停顿。\n\n问题还指出，在加载指令和相关的“使用”指令之间放置至少 $1$ 条无关指令可以消除这种停顿。编译器被允许重排指令，唯一的约束是对于每一对 $i$，$\\mathrm{LD}_i$ 必须在其对应的 $\\mathrm{ADD}_i$ 之前。\n\n为了最小化总周期数，我们必须找到一个能消除所有这类停顿的调度。一种最佳策略是重排指令，以最大化每个 $\\mathrm{LD}_i$ 与其相关的 $\\mathrm{ADD}_i$ 之间的距离。由于所有加载指令彼此独立（它们写入不同的寄存器 $r_i$），并且所有加法指令也彼此独立（它们写入不同的寄存器 $u_i$），一个有效且高效的调度是先将所有加载指令分组，然后是所有加法指令。\n\n提出的最佳调度是：\n$L_1, L_2, \\dots, L_M, A_1, A_2, \\dots, A_M$\n其中 $L_i$ 表示 $\\mathrm{LD}\\ r_i \\leftarrow \\mathrm{Mem}[a_i]$，$A_i$ 表示 $\\mathrm{ADD}\\ u_i \\leftarrow r_i + c_i$。\n\n让我们验证当 $M \\ge 2$ 时此调度是无停顿的。在此序列中，前 $M$ 条加载指令之间没有数据依赖关系，因此它们可以背靠背地发射而无需停顿。随后的加法指令可能对加载指令有依赖。考虑第 $i$ 条加法指令 $A_i$。它是序列中的第 $(M+i)$ 条指令。它依赖于第 $i$ 条加载指令 $L_i$ 的结果。\n\n- 指令 $L_i$ 在周期 $i$ 进入流水线。它的值在其 MEM 阶段结束时产生，这发生在周期 $i + (4-1) = i+3$。结果从周期 $i+4$ 开始可用于前推。\n- 指令 $A_i$ 在周期 $M+i$ 进入流水线。它在周期 $(M+i) + (3-1) = M+i+2$ 到达其 EX 阶段。\n\n为了让 $A_i$ 无停顿地执行，它的 EX 阶段开始的时间不能早于 $L_i$ 的结果可用于前推的时间。这给出了条件：\n$$\nA_i \\text{ 的 EX 阶段开始时间} \\ge L_i \\text{ 的结果可用时的周期开始时间}\n$$\n$$\nM + i + 2 \\ge i + 4\n$$\n$$\nM \\ge 2\n$$\n问题指定 $M \\ge 2$。因此，对于所有配对 $(L_i, A_i)$，此条件都得到满足。这证明了所提出的先执行所有加载再执行所有加法的调度是完全无停顿的。\n\n由于我们找到了一个零停顿的调度，这代表了最短的执行时间。在一个 $k$ 级流水线上执行一个包含 $N_{\\text{instr}}$ 条指令且无停顿的序列所需的总周期数由填充流水线所需的周期数与发射剩余指令所需的周期数之和给出。第一条指令需要 $k$ 个周期才能完成。随后的 $N_{\\text{instr}}-1$ 条指令以每周期一条的速率完成。\n$$\n\\text{总周期数} = k + (N_{\\text{instr}} - 1) = k - 1 + N_{\\text{instr}}\n$$\n对于这个问题，流水线深度为 $k=5$，总指令数为 $N_{\\text{instr}} = 2M$。\n代入这些值，最小总周期数为：\n$$\n\\text{总周期数}_{\\text{min}} = (5 - 1) + 2M = 4 + 2M\n$$\n现在我们可以使用其定义来计算最小平均 CPI：\n$$\n\\text{CPI}_{\\text{min}} = \\frac{\\text{总周期数}_{\\text{min}}}{N_{\\text{instr}}} = \\frac{4 + 2M}{2M}\n$$\n化简该表达式得到：\n$$\n\\text{CPI}_{\\text{min}} = \\frac{4}{2M} + \\frac{2M}{2M} = \\frac{2}{M} + 1\n$$\n这是用 $M$ 表示的最小平均 CPI 的最终封闭形式表达式。", "answer": "$$\n\\boxed{1 + \\frac{2}{M}}\n$$", "id": "3666138"}, {"introduction": "现代处理器远比简单的五级流水线复杂，它们是超标量（superscalar）的，并且面临着结构冒险等更多类型的瓶颈。本练习让你扮演一名性能分析工程师，通过分析一段真实的微操作执行迹象，来诊断性能问题[@problem_id:3666121]。你将从具体数据出发，推断处理器关键的发射宽度，识别限制吞吐率的主要瓶颈，并量化通过硬件升级（例如增加功能单元）可能带来的性能提升。", "problem": "一个超标量处理器实现了一个动态调度流水线，该流水线具有以下阶段：取指 (Fetch)、解码 (Decode)、重命名 (Rename)、分派 (Dispatch)、发射 (Issue)、执行 (Execute)、写回 (Writeback) 和提交 (Commit)。在关注的时间区间内，前端维持一个非空的指令窗口，分支预测被假定为完美的，并且提交阶段每个周期可以引退的微操作数量与发射阶段在稳态下可以启动的数量相同。功能单元及其每周期发射能力如下：整数算术和逻辑单元（两个相同的端口，处理简单整数算术和整数乘法），以及一个单独的内存发射端口，处理加载和存储操作。所有的发射决策都以周期为单位进行记录，每个记录条目都记载了哪些微操作被发射了，以及当发射数量少于最大可能数量时，下一个候选操作无法发射的原因。\n\n给定以下从周期 $0$ 到 $11$（含）的发射追踪片段。在每个要点中，微操作类型由 `A` 表示整数算术或逻辑，`M` 表示整数乘法，`L` 表示内存（加载或存储）。\n\n- 周期 $0$：发射了 `A`, `A`, `L`。\n- 周期 $1$：发射了 `A`, `A`, `L`。\n- 周期 $2$：发射了 `A`, `M`, `L`。\n- 周期 $3$：发射了 `A`, `L`；一个额外的就绪 `L` 操作无法发射，因为本周期唯一的内存发射端口已被使用。\n- 周期 $4$：发射了 `A`, `A`, `L`。\n- 周期 $5$：发射了 `A`, `A`, `L`。\n- 周期 $6$：发射了 `A`, `M`, `L`。\n- 周期 $7$：发射了 `A`, `L`；一个额外的就绪 `L` 操作无法发射，因为本周期唯一的内存发射端口已被使用。\n- 周期 $8$：发射了 `A`, `L`；一个额外的就绪 `L` 操作无法发射，因为本周期唯一的内存发射端口已被使用。\n- 周期 $9$：发射了 `A`, `A`；一个额外的就绪 `A` 操作无法发射，因为每个周期只有 $2$ 个整数端口可用。\n- 周期 $10$：发射了 `A`, `L`；一个额外的就绪 `L` 操作无法发射，因为本周期唯一的内存发射端口已被使用。\n- 周期 $11$：发射了 `A`, `A`, `L`。\n\n任务：\n- 从基本原理出发，重构此时间区间内发射阶段的有效流水线宽度。\n- 识别导致发射数量低于重构宽度的主要瓶颈。\n- 根据给定假设下发射和提交吞吐率在稳态下相等的原则，推断周期 $0$ 到 $11$ 的每周期指令数 (IPC)。\n- 假设通过增加第二个内存发射端口来优化已识别的瓶颈阶段，所有其他方面保持不变，且前端仍然保持指令窗口非空。在此修改下，任何先前仅因内存端口不可用而无法发射的就绪 `L` 操作现在都将发射。计算由此产生的吞吐率加速比，定义为在相同的 $12$ 周期区间内，新 IPC 与原始 IPC 的比率。\n\n将最终的加速比表示为一个精确分数。", "solution": "首先根据指定标准验证问题陈述。\n\n### 步骤 1：提取已知条件\n- **处理器架构**：超标量，动态调度流水线。\n- **流水线阶段**：取指、解码、重命名、分派、发射、执行、写回和提交。\n- **处理器状态**：非空指令窗口，完美的分支预测。\n- **提交率**：在稳态下等于发射率。\n- **功能单元和发射能力（原始配置）**：\n    - 两个相同的端口用于整数算术 (`A`) 和整数乘法 (`M`)。\n    - 一个单独的端口用于内存操作（加载和存储，`L`）。\n- **发射追踪数据（周期 $0$ 至 $11$）**：\n    - 周期 $0$：发射了 `A`, `A`, `L`。\n    - 周期 $1$：发射了 `A`, `A`, `L`。\n    - 周期 $2$：发射了 `A`, `M`, `L`。\n    - 周期 $3$：发射了 `A`, `L`；一个额外的就绪 `L` 无法发射（内存端口饱和）。\n    - 周期 $4$：发射了 `A`, `A`, `L`。\n    - 周期 $5$：发射了 `A`, `A`, `L`。\n    - 周期 $6$：发射了 `A`, `M`, `L`。\n    - 周期 $7$：发射了 `A`, `L`；一个额外的就绪 `L` 无法发射（内存端口饱和）。\n    - 周期 $8$：发射了 `A`, `L`；一个额外的就绪 `L` 无法发射（内存端口饱和）。\n    - 周期 $9$：发射了 `A`, `A`；一个额外的就绪 `A` 无法发射（整数端口饱和）。\n    - 周期 $10$：发射了 `A`, `L`；一个额外的就绪 `L` 无法发射（内存端口饱和）。\n    - 周期 $11$：发射了 `A`, `A`, `L`。\n- **提议的修改**：增加第二个内存发射端口。\n- **任务要求**：\n    1. 重构发射阶段的有效流水线宽度。\n    2. 识别主要瓶颈。\n    3. 推断原始配置的每周期指令数 (IPC)。\n    4. 计算修改后的吞吐率加速比。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题是科学严谨、定义明确且客观的。它描述了一个传统的超标量处理器模型，并提供了一致的数据集进行分析。发射宽度、结构性冒险和 IPC 的概念是计算机体系结构的基础。所做的假设（例如，完美的分支预测、非空的指令窗口）是性能分析中用于隔离特定效应的标准简化，在本例中是发射阶段的限制。数据是自洽的；例如，在周期 $3$ 中未能发射第三个微操作的原因（内存端口不可用）与所陈述的单个内存端口的配置相符。该问题是可形式化的，并与主题直接相关。它不包含矛盾、歧义或科学上不合理的 premises。\n\n### 步骤 3：结论与行动\n该问题有效。将提供完整的解答。\n\n### 解题过程\n\n**1. 重构发射阶段的有效流水线宽度。**\n发射阶段的有效流水线宽度，也称为发射宽度或机器宽度，由单个周期内可以发射的最大微操作数量定义。这取决于可用于功能单元的发射端口数量。\n该处理器有：\n- $2$ 个用于整数操作（`A` 或 `M`）的发射端口。\n- $1$ 个用于内存操作（`L`）的发射端口。\n一个周期内可以并发发射的最大微操作总数是这些端口能力的总和。\n$$ \\text{Issue Width} = (\\text{Integer Ports}) + (\\text{Memory Ports}) = 2 + 1 = 3 $$\n因此，发射阶段的有效流水线宽度为 $3$。这一点由追踪数据证实，因为没有一个周期发射超过 $3$ 个微操作，并且有几个周期（例如，周期 $0, 1, 2$）达到了这个最大值。\n\n**2. 识别主要瓶颈。**\n瓶颈是限制整体吞吐率的资源。在此背景下，它是一种结构性冒险，阻止处理器在每个周期都达到其 $3$ 的最大发射宽度。我们分析那些因资源饱和而发射少于 $3$ 个微操作的周期。\n追踪数据为发射数量减少提供了以下原因：\n- 周期 $3$：$1$ 个就绪的 `L` 操作因唯一的内存端口被占用而无法发射。\n- 周期 $7$：$1$ 个就绪的 `L` 操作因唯一的内存端口被占用而无法发射。\n- 周期 $8$：$1$ 个就绪的 `L` 操作因唯一的内存端口被占用而无法发射。\n- 周期 $9$：$1$ 个就绪的 `A` 操作因两个整数端口均被占用而无法发射。\n- 周期 $10$：$1$ 个就绪的 `L` 操作因唯一的内存端口被占用而无法发射。\n\n我们来统计每种资源导致停顿的次数：\n- 因内存端口饱和导致的停顿：$4$ 个周期 ($3, 7, 8, 10$)。\n- 因整数端口饱和导致的停顿：$1$ 个周期 ($9$)。\n\n内存端口在 $12$ 个周期中的 $4$ 个周期内限制了性能，而整数端口仅在 $1$ 个周期内成为限制因素。因此，单一的内存发射端口是主要瓶颈。\n\n**3. 推断此时间区间的每周期指令数 (IPC)。**\n问题陈述指出，发射和提交的吞吐率是相等的。因此，我们可以通过计算发射的微操作总数并除以周期数来计算平均吞吐率。在这种情况下，我们将这个指标称为 IPC，这是常见的做法。该区间从周期 $0$ 到 $11$，总共是 $11 - 0 + 1 = 12$ 个周期。\n\n发射的微操作总数（$N_{\\text{ops, original}}$）：\n- 周期 $0$：$3$ 个操作\n- 周期 $1$：$3$ 个操作\n- 周期 $2$：$3$ 个操作\n- 周期 $3$：$2$ 个操作\n- 周期 $4$：$3$ 个操作\n- 周期 $5$：$3$ 个操作\n- 周期 $6$：$3$ 个操作\n-周期 $7$：$2$ 个操作\n- 周期 $8$：$2$ 个操作\n- 周期 $9$：$2$ 个操作\n- 周期 $10$：$2$ 个操作\n- 周期 $11$：$3$ 个操作\n\n$$ N_{\\text{ops, original}} = 3+3+3+2+3+3+3+2+2+2+2+3 = 31 $$\n原始 IPC 是每个周期发射的平均微操作数。\n$$ \\mathrm{IPC}_{\\text{original}} = \\frac{N_{\\text{ops, original}}}{\\text{Total Cycles}} = \\frac{31}{12} $$\n\n**4. 计算吞吐率加速比。**\n提议的修改是增加第二个内存发射端口。新配置为：\n- $2$ 个整数端口\n- $2$ 个内存端口\n现在的最大发射宽度是 $2+2=4$。问题陈述说，任何先前因内存端口饱和而停顿的就绪 `L` 操作现在都将发射。我们重新评估修改后机器的发射计数（$N_{\\text{ops, new}}$）。\n\n- 周期 $0, 1, 2, 4, 5, 6, 11$：发射计数为 $3$，没有停顿。计数保持为 $3$。\n- 周期 $3$：原来发射了 $2$ 个操作。一个就绪的 `L` 操作被停顿。有了第二个内存端口，这个 `L` 操作可以发射。新的发射计数：$2+1=3$。\n- 周期 $7$：原来发射了 $2$ 个操作。一个就绪的 `L` 操作被停顿。有了第二个内存端口，这个 `L` 操作可以发射。新的发射计数：$2+1=3$。\n- 周期 $8$：原来发射了 $2$ 个操作。一个就绪的 `L` 操作被停顿。有了第二个内存端口，这个 `L` 操作可以发射。新的发射计数：$2+1=3$。\n- 周期 $9$：原来发射了 $2$ 个操作。一个就绪的 `A` 操作因整数端口饱和而停顿。增加一个内存端口不能解决这个问题。新的发射计数保持为 $2$。\n- 周期 $10$：原来发射了 $2$ 个操作。一个就绪的 `L` 操作被停顿。有了第二个内存端口，这个 `L` 操作可以发射。新的发射计数：$2+1=3$。\n\n新配置下发射的微操作总数是：\n$$ N_{\\text{ops, new}} = (3 \\times 7) + 3 + 3 + 3 + 2 + 3 = 21 + 14 = 35 $$\n或者，我们可以计算比原始计数的增加量。四个内存端口停顿被消除，增加了 $4$ 个发射的操作。\n$$ N_{\\text{ops, new}} = N_{\\text{ops, original}} + 4 = 31 + 4 = 35 $$\n在相同的 $12$ 周期区间内，新的 IPC 是：\n$$ \\mathrm{IPC}_{\\text{new}} = \\frac{N_{\\text{ops, new}}}{\\text{Total Cycles}} = \\frac{35}{12} $$\n加速比是新 IPC 与原始 IPC 的比率。\n$$ \\text{Speedup} = \\frac{\\mathrm{IPC}_{\\text{new}}}{\\mathrm{IPC}_{\\text{original}}} = \\frac{35/12}{31/12} = \\frac{35}{31} $$\n加速比，作为一个精确分数，是 $\\frac{35}{31}$。", "answer": "$$\\boxed{\\frac{35}{31}}$$", "id": "3666121"}]}