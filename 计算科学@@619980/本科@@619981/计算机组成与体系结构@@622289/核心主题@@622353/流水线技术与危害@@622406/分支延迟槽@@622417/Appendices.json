{"hands_on_practices": [{"introduction": "理论是根基，但真正的理解源于实践。本节练习旨在将分支延迟槽的抽象概念转化为具体的性能提升。你将通过构建一个简单的代码示例，并推导出一个通用的加速比公式，来亲手量化编译器优化对程序执行时间的影响 [@problem_id:3629849]。这个练习将帮助你建立起连接底层硬件特性与宏观性能表现的分析思维。", "problem": "考虑一个经典的五级、单发射精简指令集计算机 (RISC) 流水线，该流水线每个控制转移指令都有一个架构可见的分支延迟槽，如同 MIPS (无内部互锁流水线级微处理器) 的设计。分支延迟槽的语义是：紧跟在分支指令后的指令总是会执行，无论分支是否跳转。如果编译器或手动调度器无法找到一个有用的、安全的指令来放置在延迟槽中，那么该槽将由一个空操作 (NOP) 指令占据。假设以下基线事实作为推理的基本依据：\n- 程序的执行时间可以建模为执行的指令数乘以每条指令的平均周期数 (CPI)。对于一个除了分支延迟效应外没有其他停顿的理想单发射流水线，每条指令的周期数为 $1$。\n- 加速比定义为 $S = T_{\\text{baseline}} / T_{\\text{improved}}$，其中 $T$ 表示总执行时间（或者等效地，在固定频率机器上的总周期数）。\n- 令 $I_u$ 表示原始程序语义中有用指令的动态计数（不包括为填充延迟槽而引入的任何 NOP）。\n- 令 $f_b$ 表示在 $I_u$ 条有用指令中，分支指令所占的动态比例，因此分支指令的动态数量为 $N_b = f_b I_u$。\n\n构建一个最小示例（以伪代码或类 MIPS 风格），其中一个分支的延迟槽可以通过移动分支之前或之后的一条安全指令（即在数据依赖和异常行为方面保持正确性的指令）来填充。说明您选择放置在延迟槽中的是哪条指令，并证明其安全性。\n\n现在，对指令调度进行建模，该调度将一部分比例为 $r$ 的延迟槽用有用的指令填充，其中 $r \\in [0,1]$ 是动态执行过程中的填充率。假设：\n- 每个未填充的延迟槽执行一个 NOP，恰好花费 $1$ 个周期。\n- 用一条有用的指令填充延迟槽，并不会相对于该指令在其原始位置执行时增加总周期数；这纯粹是一种重新排序，它保持了有用指令的总数 $I_u$ 不变。\n- 除了所描述的情况外，没有额外的停顿或冒险，并且该机器仍然是单发射的，每个周期引退一条指令。\n\n根据上述定义，推导出加速比 $S$ 作为填充率 $r$ 和分支比例 $f_b$ 的函数的封闭形式符号表达式。您的最终答案必须是仅包含 $r$ 和 $f_b$ 的单一解析表达式。不需要进行数值近似或四舍五入。请将您的最终答案表示为单一的封闭形式表达式。", "solution": "该问题陈述已经过分析，并被认为是有效的。它在科学上基于计算机体系结构的原理，特别是 RISC 流水线设计和指令调度。该问题提法明确，提供了一套清晰的定义和约束（$I_u$, $f_b$, $r$, CPI=$1$，加速比定义），从而可以推导出一个唯一的、有意义的符号表达式。其语言客观且无歧义。该问题是可形式化的，并且与控制流指令的主题直接相关。\n\n该问题包含两个部分：首先，提供一个填充分支延迟槽的最小示例；其次，推导通过这种优化获得的加速比的公式。\n\n首先，我们将构建一个最小示例。考虑以下类 MIPS 指令序列：\n\n原始代码序列：\n1. `add r3, r1, r2`  // An instruction that determines the branch condition.\n2. `sub r4, r5, r6`  // An independent instruction.\n3. `beq r3, r0, Target` // Branch if `r3` equals `r0`.\n4. `...`             // Instruction at the fall-through path.\n\n在具有分支延迟槽的类 MIPS 流水线中，紧跟在分支指令后的那条指令总是会被执行。为了在不进行调度的情况下确保正确性，会在分支指令后放置一条 `NOP` (空操作) 指令：\n\n延迟槽中包含NOP的代码：\n`add r3, r1, r2`\n`sub r4, r5, r6`\n`beq r3, r0, Target`\n`NOP`                // The NOP in the delay slot is always executed.\n\n指令调度可以通过用一条有用的指令替换 `NOP` 来提高性能。这类指令有三个主要来源：\n1.  来自于分支之前：可以将分支前的一条独立指令移动到延迟槽中。\n2.  来自于分支目标：可以移动来自目标地址的一条指令，但它必须在分支不跳转时也能安全执行。\n3.  来自于顺序执行路径：可以移动来自顺序路径的一条指令，但它必须在分支跳转时也能安全执行。\n\n最安全且最常见的优化是从分支之前移动指令。在我们的例子中，`sub r4, r5, r6` 指令不影响分支条件（分支条件依赖于 `r3`），并且其目标寄存器（`r4`）没有被分支指令使用。因此，可以安全地将其移动到延迟槽中。而 `add r3, r1, r2` 指令不能移动，因为它产生的值是 `beq` 指令需要消耗的。\n\n填充了延迟槽的调度后代码：\n`add r3, r1, r2`\n`beq r3, r0, Target`\n`sub r4, r5, r6`  // Moved into the delay slot.\n\n这段经过调度的代码是正确的，因为 `sub` 指令在原始序列中保证会被执行，并且它在延迟槽中的执行不会改变程序逻辑或分支的结果。有用指令的总数保持不变，但消除一个 `NOP` 周期。\n\n接下来，我们推导加速比 $S$ 作为分支比例 $f_b$ 和延迟槽填充率 $r$ 的函数的一般表达式。\n\n加速比定义为 $S = T_{\\text{baseline}} / T_{\\text{improved}}$。由于问题指出，对于所有执行的指令（包括 `NOP`），每条指令的平均周期数 (CPI) 为 $1$，且时钟频率固定，因此执行时间 $T$ 与执行的指令总数成正比。\n令 $I_{\\text{total}}$ 为动态执行的指令总数。\n则 $T \\propto I_{\\text{total}}$。\n\n令 $I_u$ 为程序中有用指令的动态计数。此计数是恒定的。\n令 $f_b$ 为有用指令中分支指令的比例。\n分支指令的数量为 $N_b = f_b I_u$。\n每条分支指令产生一个延迟槽。\n\n我们必须定义一个用于比较的基线。一个自然且合乎逻辑的基线是未执行任何优化的场景，即每个分支延迟槽都用 `NOP` 填充。这对应于填充率 $r=0$。\n\n在基线场景中 ($T_{\\text{baseline}}$)：\n`NOP` 指令的数量等于分支指令的数量，因为没有延迟槽被有用的指令填充。\n$N_{\\text{NOP, baseline}} = N_b = f_b I_u$。\n执行的指令总数是有用指令和 `NOP` 的总和。\n$I_{\\text{total, baseline}} = I_u + N_{\\text{NOP, baseline}} = I_u + f_b I_u = I_u(1 + f_b)$。\n执行时间（或周期数）为 $T_{\\text{baseline}} = I_{\\text{total, baseline}} \\cdot 1 = I_u(1 + f_b)$。\n\n现在，考虑改进后的场景 ($T_{\\text{improved}}$)，其中一部分比例为 $r$ 的延迟槽被有用的指令填充。\n分支指令的总数仍然是 $N_b = f_b I_u$。\n被有用指令填充的延迟槽数量为 $r \\cdot N_b = r f_b I_u$。\n仍然未被填充并因此由 `NOP` 占据的延迟槽数量为 $(1-r) \\cdot N_b = (1-r) f_b I_u$。\n执行的指令总数是恒定的有用指令数 $I_u$ 与 `NOP` 数量之和。移动到延迟槽中的有用指令不会增加指令总数，因为它们只是被重新排序了。\n$I_{\\text{total, improved}} = I_u + N_{\\text{NOP, improved}} = I_u + (1-r)f_b I_u = I_u(1 + (1-r)f_b)$。\n执行时间（或周期数）为 $T_{\\text{improved}} = I_{\\text{total, improved}} \\cdot 1 = I_u(1 + (1-r)f_b)$。\n\n最后，我们计算加速比 $S$：\n$$S = \\frac{T_{\\text{baseline}}}{T_{\\text{improved}}} = \\frac{I_u(1 + f_b)}{I_u(1 + (1-r)f_b)}$$\n$I_u$ 项相互抵消，得到加速比作为 $f_b$ 和 $r$ 的函数的最终表达式：\n$$S(f_b, r) = \\frac{1 + f_b}{1 + (1-r)f_b}$$\n这也可以写成：\n$$S(f_b, r) = \\frac{1 + f_b}{1 + f_b - r f_b}$$\n这个表达式正确地捕捉了性能的提升。如果 $r=0$（没有延迟槽被填充），则 $S=1$，表示相对于基线没有加速。如果 $r=1$（所有延迟槽都被填充），则 $S = \\frac{1+f_b}{1} = 1+f_b$，代表了所有分支惩罚都被消除时的最大可能加速比。", "answer": "$$\n\\boxed{\\frac{1 + f_b}{1 + (1-r)f_b}}\n$$", "id": "3629849"}, {"introduction": "在上一节练习中，我们看到了填充延迟槽带来的性能优势，但这必须以保证程序正确性为前提。本练习将引导你扮演编译器的角色，深入探讨“安全”填充延迟槽的关键问题 [@problem_id:3623700]。通过分析一个具体的优化提议，你将学会如何在分支的“跳转”与“不跳转”两种路径下都维持程序语义的一致性，这是编译器优化中至关重要的一环。", "problem": "一个精简指令集计算机（RISC）处理器采用经典的五级流水线——取指（IF）、译码（ID）、执行（EX）、访存（MEM）和写回（WB），并实现了一个分支延迟槽。在此指令集架构（ISA）下，紧随分支指令的下一条指令总是会执行完毕，无论分支是否跳转；也就是说，在控制权转移之前，位于 $\\mathrm{PC}+4$ 的指令会按照程序顺序提交。分支解析发生在执行（EX）阶段，并且异常是精确的：架构状态精确地反映了与顺序执行规范中完全相同的已提交指令序列。此 ISA 中的算术指令不会引发异常，而内存存储和加载操作可能会引发异常并产生外部可见的副作用。\n\n考虑以下使用分支折叠（顺序执行）的汇编代码片段，其中顺序执行块在分支指令之后开始。标签 $\\texttt{L1}$ 和 $\\texttt{L2}$ 分别标记了分支跳转的目标和重新汇合点；寄存器 $r_z$ 表示架构零寄存器，而 $r_i$ 表示通用寄存器 $i$：\n- $\\texttt{beq } r_1, r_z, \\texttt{L1}$    ; 如果 $r_1 = 0$ 则分支到 $\\texttt{L1}$（当前延迟槽为 $\\texttt{nop}$）\n- $\\texttt{nop}$                           ; 延迟槽当前未填充\n- $\\texttt{mul } r_3, r_3, r_4$           ; 顺序执行块的第一条指令（无异常）\n- $\\texttt{sw } r_3, 0(r_5)$              ; 将结果存入内存（可能引发异常或产生副作用）\n- $\\texttt{j } \\texttt{L2}$               ; 跳转到汇合点\n- $\\texttt{L1: mov } r_3, r_6$            ; 跳转路径：在使用 $r_3$ 之前覆盖它\n- $\\texttt{L2: add } r_9, r_3, r_7$       ; 汇合后 $r_3$ 的使用\n\n一个编译器优化遍（pass）提议将顺序执行块的第一条指令（$\\texttt{mul } r_3, r_3, r_4$）移入延迟槽来填充它，从而得到：\n- $\\texttt{beq } r_1, r_z, \\texttt{L1}$\n- $\\texttt{mul } r_3, r_3, r_4$           ; 现在位于延迟槽中\n- $\\texttt{sw } r_3, 0(r_5)$\n- $\\texttt{j } \\texttt{L2}$\n- $\\texttt{L1: mov } r_3, r_6$\n- $\\texttt{L2: add } r_9, r_3, r_7$\n\n假设如下：\n- 乘法指令 $\\texttt{mul}$ 没有异常或外部可见的副作用。\n- 存储指令 $\\texttt{sw}$ 有外部可见的副作用，并可能引发异常。\n- 零寄存器 $r_z$ 的值总是读取为 $0$。\n- 在跳转路径上，$\\texttt{L1}$ 处的 $r_3$ 的值在任何使用之前被 $\\texttt{mov } r_3, r_6$ 完全覆盖，并且在两条路径汇合后首次使用 $r_3$ 是在 $\\texttt{L2}$ 处的 $\\texttt{add } r_9, r_3, r_7$。\n\n根据该 ISA 的分支延迟槽语义，哪项陈述最能描述所提议的转换是否保留了程序的可观察行为？\n\nA. 该转换是正确的，因为延迟槽中的 $\\texttt{mul}$ 指令在两种分支结果下都会执行，但在跳转路径上，$r_3$ 在任何使用前被覆盖，并且 $\\texttt{mul}$ 指令无副作用且不产生陷阱（non-trapping）。\n\nB. 该转换是不正确的，因为延迟槽指令仅在分支不跳转时执行，因此将顺序执行的 $\\texttt{mul}$ 指令放在那里会导致它在不跳转的路径上被跳过。\n\nC. 该转换仅在硬件分支预测器倾向于“不跳转”时才是正确的，因为预测决定了延迟槽指令是否运行。\n\nD. 该转换是不正确的，因为将任何指令移入延迟槽都会改变流水线冒险，因此无论有无副作用，都会违反数据依赖性。\n\nE. 该转换是当且仅当被移动的指令使用的寄存器与分支条件中的寄存器（这里是 $r_1$ 和 $r_z$）不相交时才正确，而不管其副作用或异常行为如何。", "solution": "该问题陈述已经过验证，被认定为计算机体系结构中一个定义明确的问题。它具有科学依据，提法恰当，并且客观。\n\n问题的核心是确定一种称为延迟槽填充的编译器优化的正确性。该转换将一条指令从条件分支的顺序执行路径移动到分支的延迟槽中。为了确保正确性，此转换必须在所有可能的执行路径（分支跳转和不跳转）上都保留程序的可观察行为。可观察行为由寄存器和内存的最终状态，以及任何外部可见的副作用或异常决定。\n\n该 ISA 规定，延迟槽中的指令（位于 $\\mathrm{PC}+4$ 的指令）“无论分支是否跳转，总是会执行完毕”。我们来分析转换前后的程序行为。\n\n**原始程序行为**\n\n1.  **分支不跳转（如果 $r_1 \\neq r_z$）：**\n    处理器按顺序执行指令。\n    - `beq r_1, r_z, L1`：条件为假。\n    - `nop`：在延迟槽中执行。无效果。\n    - `mul r_3, r_3, r_4`: 更新寄存器 $r_3$。\n    - `sw r_3, 0(r_5)`: 将 $r_3$ 的新值存入内存。\n    - `j L2`: 跳转到 `L2`。\n    - `add r_9, r_3, r_7`: 使用由 `mul` 指令计算出的 $r_3$ 的值。\n    影响程序状态的操作序列是：`mul`，然后 `sw`，然后 `add`。\n\n2.  **分支跳转（如果 $r_1 = r_z$）：**\n    到 `L1` 的分支发生跳转，但延迟槽指令会先执行。\n    - `beq r_1, r_z, L1`：条件为真。\n    - `nop`：在延迟槽中执行。无效果。\n    - `nop` 执行后，控制权转移到 `L1`。`mul` 和 `sw` 指令被跳过。\n    - `mov r_3, r_6`: 覆盖寄存器 $r_3$。\n    - `add r_9, r_3, r_7`: 使用来自 `mov` 指令的 $r_3$ 的值。\n    影响程序状态的操作序列是：`mov`，然后 `add`。\n\n**转换后的程序行为**\n\n`mul r_3, r_3, r_4` 指令被移入延迟槽。\n\n1.  **分支不跳转（如果 $r_1 \\neq r_z$）：**\n    处理器按顺序执行指令。延迟槽中的 `mul` 是这个序列的一部分。\n    - `beq r_1, r_z, L1`：条件为假。\n    - `mul r_3, r_3, r_4`: 在延迟槽中执行。更新寄存器 $r_3$。\n    - `sw r_3, 0(r_5)`: 将 $r_3$ 的新值存入内存。\n    - `j L2`: 跳转到 `L2`。\n    - `add r_9, r_3, r_7`: 使用由 `mul` 指令计算出的 $r_3$ 的值。\n    此行为与原始程序的不跳转路径完全相同。\n\n2.  **分支跳转（如果 $r_1 = r_z$）：**\n    到 `L1` 的分支发生跳转，延迟槽指令（`mul`）执行。\n    - `beq r_1, r_z, L1`：条件为真。\n    - `mul r_3, r_3, r_4`: 在延迟槽中执行，更新 $r_3$。\n    - `mul` 执行后，控制权转移到 `L1`。\n    - `mov r_3, r_6`: 覆盖寄存器 $r_3$。由 `mul` 计算出的值被丢弃。\n    - `add r_9, r_3, r_7`: 使用来自 `mov` 指令的 $r_3$ 的值。\n    关键的观察点是，虽然 `mul` 指令执行了，但它对 $r_3$ 的影响在 $r_3$ 被使用之前就被后续的 `mov` 指令抵消了。问题陈述保证了这一点（“在跳转路径上......$r_3$ 的值......在任何使用之前被完全覆盖”）。此外，问题陈述指出 `mul` 没有异常或副作用。因此，它在这条路径上的执行对最终程序状态没有可观察的影响。最终的寄存器值与原始程序的跳转路径相同。\n\n**关于转换的结论**\n由于在跳转和不跳转路径上，可观察的程序行为都是相同的，因此该转换是正确的。这种类型的优化在三个条件下是有效的，这里所有条件都满足了：\n1. 在原始程序中，被移动的指令在顺序执行（fall-through）路径上执行。\n2. 被移动的指令没有副作用或异常，不会在跳转路径上改变程序状态。\n3. 在跳转路径上，被移动指令对寄存器状态的任何修改，在该寄存器下一次使用前被撤销或变得无关紧要。\n\n**逐项分析选项**\n\nA. 该转换是正确的，因为延迟槽中的 `mul` 指令在两种分支结果下都会执行，但在跳转路径上，$r_3$ 在任何使用前被覆盖，并且 `mul` 指令无副作用且不产生陷阱（non-trapping）。\n这个陈述准确地总结了我们的推导。它正确地指出了此优化有效的三个关键要求：延迟槽指令在两条路径上都执行，其在跳转路径上的架构效果被后续指令抵消，并且它不会引入任何其他不正确的可见行为（副作用或异常）。\n**结论：正确**\n\nB. 该转换是不正确的，因为延迟槽指令仅在分支不跳转时执行，因此将顺序执行的 `mul` 指令放在那里会导致它在不跳转的路径上被跳过。\n这在事实上是错误的。它误解了指定分支延迟槽的基本语义。问题明确指出这种类型的延迟槽“无论分支是否跳转，总是会执行完毕”。\n**结论：不正确**\n\nC. 该转换仅在硬件分支预测器倾向于“不跳转”时才是正确的，因为预测决定了延迟槽指令是否运行。\n这是不正确的。分支预测是一种通过猜测分支结果来提高性能的微体系结构技术。然而，程序的架构正确性取决于 ISA 定义的语义，而不是预测器的行为。ISA 强制要求延迟槽指令必须执行；处理器必须确保这是最终提交的行为，即使它必须刷新错误的路径推测。\n**结论：不正确**\n\nD. 该转换是不正确的，因为将任何指令移入延迟槽都会改变流水线冒险，因此无论有无副作用，都会违反数据依赖性。\n这是一个过于绝对且不正确的概括。像延迟槽填充这样的编译器优化的全部目的就是以一种在保留程序语义的同时提高性能的方式来管理和解决流水线冒险和依赖性。它本身并不会违反它们。在这种情况下，数据依赖性被正确地保留了。\n**结论：不正确**\n\nE. 该转换是当且仅当被移动的指令使用的寄存器与分支条件中的寄存器（这里是 $r_1$ 和 $r_z$）不相交时才正确，而不管其副作用或异常行为如何。\n这个陈述是有缺陷的。虽然寄存器不相交是一个好的实践，但它不是这里的核心问题。更重要的是，声称该转换“不管其副作用或异常行为如何”都是正确的，这是根本错误的。如果 `mul` 指令可能导致异常或有副作用（如写入内存），在跳转路径上执行它会引入原始程序中不存在的可观察行为，从而使转换不正确。没有副作用和异常是此项优化的关键条件。\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3623700"}, {"introduction": "完美的优化在现实中很少存在，编译器常常需要在收益和风险之间做出权衡。这个高级练习将你带入基于概率的性能优化领域，这在现代编译器设计中非常普遍 [@problem_id:3623696]。你将利用程序运行的统计信息（profile-guided data），通过建立期望收益模型来推导出一个最佳决策阈值，从而决定何时进行可能带来风险的推测性填充。这个过程将让你体会到，在不确定性下如何做出最优的工程决策。", "problem": "一个中央处理器（CPU）中的五级标量流水线实现了一个单分支延迟槽：无论分支是否跳转，紧随分支指令的下一条指令总会被执行。编译器被允许用来自预测跳转路径的一条指令来填充这个延迟槽，即使该指令在不跳转路径上是不安全的。剖析引导编译为每个分支提供了一个分支跳转概率 $p = \\Pr(\\text{taken})$。考虑以下用于描述填充延迟槽性能影响的模型：\n\n- 如果编译器将延迟槽留空（即插入一个空操作），则该分支实例会浪费恰好 $1$ 个周期。\n- 如果编译器用来自跳转路径的指令填充延迟槽且分支发生跳转，则相对于将延迟槽留空，该填充操作可以恢复恰好 $1$ 个周期。\n- 如果编译器用来自跳转路径的指令填充延迟槽但分支未发生跳转，则该填充会导致需要恢复的错误预测。相对于将延迟槽留空，此错误填充的净性能影响是 $m$ 个周期的额外开销，其中 $m > 0$ 是目标指令集架构（ISA）和微架构的一个已知常数。\n\n编译器使用一个简单的启发式方法：当且仅当 $p > T$ 时，用一条跳转路径指令填充延迟槽，其中 $T$ 是一个待选的阈值。使用最大化每个分支实例的期望节省周期数原则，推导出最优阈值 $T$ 关于 $m$ 的封闭形式表达式。你的最终答案必须是一个解析表达式。不需要四舍五入，且最终答案中不应包含任何单位。", "solution": "题目要求我们为一个编译器启发式方法求解最优阈值 $T$，该方法用于决定是否填充分支延迟槽。决策规则是：如果分支跳转概率 $p$ 超过阈值 $T$，则用来自跳转路径的指令填充该槽。优化标准是最大化每个分支实例的期望节省周期数。\n\n让我们为编译器针对每个分支可用的两种操作进行定义：\n1.  操作 $A_{\\text{empty}}$：通过插入一个空操作（NOP）指令，将延迟槽留空。\n2.  操作 $A_{\\text{fill}}$：用来自预测跳转路径的一条指令填充延迟槽。\n\n性能影响是相对于基准操作 $A_{\\text{empty}}$ 所节省的周期数来衡量的。\n根据定义，操作 $A_{\\text{empty}}$ 节省的周期数（记为 $S_{\\text{empty}}$）为 $0$。\n$$\nS_{\\text{empty}} = 0\n$$\n由于这个结果是确定的，该操作的期望节省周期数也为 $0$。\n$$\nE[S_{\\text{empty}}] = 0\n$$\n\n现在，考虑操作 $A_{\\text{fill}}$。节省的周期数 $S_{\\text{fill}}$ 取决于分支是否实际跳转。\n题目提供了以下信息：\n-   分支跳转的概率为 $p = \\Pr(\\text{taken})$。\n-   因此，分支不跳转的概率为 $1-p = \\Pr(\\text{not taken})$。\n-   如果分支跳转，填充操作相对于留空延迟槽能恢复 $1$ 个周期。因此，这种情况下节省的周期数为 $S_{\\text{fill, taken}} = 1$。\n-   如果分支不跳转，错误预测会带来 $m$ 个周期的开销（其中 $m > 0$），这是相对于留空延迟槽而言的。这对应于负的节省量。因此，这种情况下节省的周期数为 $S_{\\text{fill, not\\_taken}} = -m$。\n\n操作 $A_{\\text{fill}}$ 的期望节省周期数，记为 $E[S_{\\text{fill}}]$，是各种结果的加权平均值，其中权重是这些结果发生的概率。\n$$\nE[S_{\\text{fill}}] = S_{\\text{fill, taken}} \\cdot \\Pr(\\text{taken}) + S_{\\text{fill, not\\_taken}} \\cdot \\Pr(\\text{not taken})\n$$\n代入给定值：\n$$\nE[S_{\\text{fill}}] = (1) \\cdot p + (-m) \\cdot (1-p)\n$$\n简化此表达式，我们得到：\n$$\nE[S_{\\text{fill}}] = p - m(1-p) = p - m + mp = p(1+m) - m\n$$\n\n为了最大化期望节省周期数，编译器必须选择具有更高期望节省值的操作。当且仅当填充延迟槽（$A_{\\text{fill}}$）的期望节省大于将其留空（$A_{\\text{empty}}$）的期望节省时，编译器才应选择填充。\n$$\nE[S_{\\text{fill}}] > E[S_{\\text{empty}}]\n$$\n代入期望节省的表达式：\n$$\np(1+m) - m > 0\n$$\n我们需要对 $p$ 求解这个不等式，以找出填充延迟槽为最优选择的条件。\n$$\np(1+m) > m\n$$\n因为给定 $m > 0$，所以项 $1+m$ 严格为正。因此，我们可以在不等式两边同时除以 $1+m$ 而不改变不等号的方向。\n$$\np > \\frac{m}{1+m}\n$$\n这个不等式代表了最优决策规则：如果一个分支跳转的概率 $p$ 大于 $\\frac{m}{1+m}$，那么填充延迟槽会产生更高的期望节省周期数。\n\n题目指出编译器使用的启发式方法是：当且仅当 $p > T$ 时填充延迟槽。为了使这个启发式方法最优，我们必须选择一个阈值 $T$，使其与我们刚刚推导出的最优决策规则相匹配。\n通过将启发式规则 $p > T$ 与推导出的条件 $p > \\frac{m}{1+m}$ 进行比较，我们可以确定最优阈值 $T$。最优阈值是两种操作的期望节省相等的边界点。\n$$\nT = \\frac{m}{1+m}\n$$\n如果 $p = T$，则期望节省相等，因此两种选择是等效的。启发式规则 $p > T$ 中的严格不等式意味着，当 $p$ 恰好等于阈值时，编译器将选择不填充，这对于边界情况是一种有效的约定。推导出的 $T$ 值代表了无差异点，这正是此决策规则下最优阈值的定义。", "answer": "$$\n\\boxed{\\frac{m}{1+m}}\n$$", "id": "3623696"}]}