{"hands_on_practices": [{"introduction": "理解结构性冒险最直接的方法，是观察单一、超负荷的资源如何决定整个流水线的性能。本练习聚焦于寄存器文件这一通用资源，展示如何根据资源限制直接计算其对性能（即每指令周期数 $CPI$）的最终影响。通过这个基础练习 [@problem_id:3682639]，你将学会识别流水线中的瓶颈，并量化其对吞吐率的限制。", "problem": "考虑一个中央处理器 (CPU) 中的标量五级流水线，其流水级如下：指令提取 (IF)、指令译码和寄存器读取 (ID)、执行 (EX)、内存访问 (MEM) 和写回 (WB)。在没有冒险的情况下，每个流水级处理每条指令恰好占用 $1$ 个时钟周期，且流水线每个周期最多发射一条指令。寄存器文件每个周期最多可服务 $R$ 个读端口和 $W$ 个写端口。一条三元指令需要读取 $3$ 个源寄存器并写入 $1$ 个目的寄存器。读取操作仅在 ID 阶段执行，写入操作仅在 WB 阶段执行。寄存器文件在同一周期内不能执行超过 $R$ 次读取或超过 $W$ 次写入，并且在指令所需的所有寄存器读取完成之前，ID 阶段不能进入 EX 阶段。冒险的解决完全通过停顿来执行：一个无法在当前周期完成其所需工作的流水级会保持其指令，并阻止上游流水级前进。\n\n考虑一个由这类三元指令组成的长的稳态序列，其中没有数据依赖、没有控制冒险，且在 MEM 阶段没有内存操作，因此唯一潜在的冒险是由寄存器文件端口引起的结构冒险。设 $R=2$ 且 $W=1$。在满足给定约束的最佳调度下，该流水线的稳态平均每指令周期数 (CPI) 是多少？\n\n将您的最终答案表示为单个实数。无需四舍五入。", "solution": "基本定义如下。当一个周期内所需的硬件资源超过其可用容量时，就会出现结构冒险。在流水线 CPU 中，如果一个流水级由于资源不足而无法完成其所需的操作，该流水级必须停顿，这会阻止上游流水级前进并可能降低吞吐率。对于一个具有平衡流水级且无冒险的标量流水线，其稳态平均每指令周期数 (CPI) 为 $1$。如果由于资源限制，某个流水级处理每条指令需要超过 $1$ 个周期，那么该流水级就成为吞吐率瓶颈：流水线发射新指令的速度不能快于该流水级接收指令的速度，且稳态 CPI 等于瓶颈流水级处理每条指令所需的周期数。\n\n将这些原则应用于给定场景。每条三元指令在指令译码和寄存器读取 (ID) 阶段需要 $3$ 次寄存器读取，在写回 (WB) 阶段需要 $1$ 次寄存器写入。寄存器文件有 $R=2$ 个读端口和 $W=1$ 个写端口。对于一个 $W=1$ 的单发射流水线，WB 阶段每个周期最多能处理 $1$ 次写入，但由于在任何时候 WB 阶段只有一条指令（单发射），所以对于这种指令组合，WB 阶段不是瓶颈。关键资源是 ID 阶段的读端口。\n\n在 ID 阶段，每个周期最多可以读取 $R=2$ 个寄存器。一条三元指令需要 $3$ 次读取，这无法在单个周期内完成，因为 $3 > R=2$。因此，ID 阶段必须将指令保留多个周期。具体来说，在第一个 ID 周期，指令可以读取 $2$ 个操作数，在第二个 ID 周期，它可以读取剩下的 $1$ 个操作数。因此，每条指令在 ID 阶段的占用时间为\n$$\n\\left\\lceil \\frac{3}{R} \\right\\rceil = \\left\\lceil \\frac{3}{2} \\right\\rceil = 2 \\text{ 个周期}。\n$$\n因为冒险的解决完全通过停顿来执行，且流水线是单发射的，所以 ID 阶段将一条指令保持 $2$ 个周期的行为会阻止下一条指令进入 ID 阶段，直到这些读取操作完成。相对于 ID 阶段在 $1$ 个周期内完成的无冒险情况，这会给每条指令带来 $1$ 个周期的停顿。\n\n我们可以通过概述一条指令（记为 $I_1$）的调度来明确这一点：\n- 周期 $1$：$I_1$ 在 IF 阶段。\n- 周期 $2$：$I_1$ 在 ID 阶段（读取 $2$ 个寄存器）。\n- 周期 $3$：$I_1$ 在 ID 阶段（读取 $1$ 个寄存器，完成读取）。\n- 周期 $4$：$I_1$ 在 EX 阶段。\n- 周期 $5$：$I_1$ 在 MEM 阶段。\n- 周期 $6$：$I_1$ 在 WB 阶段（执行 $1$ 次写操作，在 $W=1$ 的限制内）。\n\n对于下一条指令 $I_2$，它最早能在周期 $3$ 之后进入 ID 阶段，因为 ID 阶段在周期 $2$ 和周期 $3$ 被 $I_1$ 占用。因此，即使在由这类指令组成的长的稳态序列中且没有其他冒险，ID 阶段处理指令的速率也是每 $2$ 个周期 $1$ 条指令。由于所有其他流水级都占用 $1$ 个周期，ID 阶段是限制吞吐率的瓶颈。\n\n因此，稳态吞吐率为每周期 $0.5$ 条指令，稳态平均每指令周期数为\n$$\n\\mathrm{CPI} = 2。\n$$\n无需四舍五入，因为这是从整数资源约束和流水级占用时间推导出的精确值。", "answer": "$$\\boxed{2}$$", "id": "3682639"}, {"introduction": "在真实的处理器中，不同类型的冒险可能同时存在，有时甚至会被混淆。本练习 [@problem_id:3682664] 将挑战你对冒险类型的精确理解，它在一个双发射处理器上构建了一个看似存在数据相关的指令序列。然而，真正的性能瓶颈实际上是地址生成单元（AGU）上的结构性冒险，这要求我们必须严格运用定义来做出区分。", "problem": "考虑一个执行整数和内存指令的顺序、双发射流水线。该机器具有以下特性：\n\n- 前端每个周期最多可以取指和译码 $2$ 条指令，并尝试按程序顺序将它们作为一对进行发射。\n- 有一个地址生成单元（AGU）资源。任何加载或存储指令在执行有效地址计算时都需要占用 AGU 整整 $1$ 个周期。AGU 在同一周期内不能共享，因此每个周期最多只能有一条内存指令使用 AGU。\n- 算术逻辑单元（ALU）执行整数算术/逻辑指令，每个周期最多执行 $1$ 条 ALU 指令。ALU 指令不使用 AGU。\n- 加载和存储没有缓存未命中；忽略内存延迟，只需考虑加载和存储指令各需要一个 AGU 使用周期来计算其有效地址。当检测到结构冲突时，发射逻辑会停顿一对指令中的第二条指令，让第一条指令继续执行。\n- 冒险检测是标准的：仅当存在对一个值的真相关（写后读）时，才存在数据冒险。在没有中间写操作的情况下，连续两条指令读取同一个寄存器不构成数据冒险。\n\n通过为两个连续的内存操作使用相同的基址寄存器，构建一个看似是数据冒险但实际上由于共享 AGU 而成为结构冒险的指令序列。然后，针对下面的特定循环体，解释这种区别，并量化纯粹由 AGU 争用引起的停顿。\n\n循环体（一次迭代），以寄存器传输风格编写：\n\n- 指令 $1$：加载 R4 ← Mem[R1 + 0]。\n- 指令 $2$：存储 Mem[R1 + 8] ← R5。\n- 指令 $3$：整数加法 R6 ← R6 + R9。\n- 指令 $4$：整数减法 R10 ← R11 - R12。\n\n假设前端在迭代的第一个周期尝试同时发射指令 $1$ 和 $2$，然后按程序顺序继续，在满足上述资源约束的条件下，尝试填满每个周期的两个发射槽。\n\n任务：\n\n1.  使用结构冒险和数据冒险的基本定义，论证为什么指令 $1$ 和 $2$ 之间的交互是结构冒险而不是数据冒险。\n2.  确定每次循环迭代中仅因共享 AGU 而产生的停顿周期数。\n3.  对于该循环体的 $N = 100$ 次迭代，计算由 AGU 争用引起的总停顿周期数。将最终结果表示为停顿周期的数量。无需四舍五入。", "solution": "用户的问题将被验证，如果被认为是有效的，将通过一个严谨的、分步的推理过程来解决。\n\n### 步骤 1：提取已知条件\n- **机器架构**：用于整数和内存指令的顺序、双发射流水线。\n- **前端**：每个周期最多取指和译码 $2$ 条指令。尝试按程序顺序将它们作为一对进行发射。\n- **功能单元与资源**：\n    - $1$ 个地址生成单元（AGU）。\n    - 任何加载或存储指令进行有效地址计算时，都需要占用 AGU 整整 $1$ 个周期。\n    - AGU 不是流水线化的或共享的；每个周期最多只有一条指令可以使用它。\n    - $1$ 个用于整数指令的算术逻辑单元（ALU）。\n    - 每个周期最多可以执行 $1$ 条 ALU 指令。\n    - ALU 指令不使用 AGU。\n- **停顿策略**：如果指令对中发生结构冲突，第二条指令将被停顿，第一条指令继续执行。然后流水线按程序顺序继续。\n- **冒险定义**：数据冒险是真相关（写后读）。在没有中间写操作的情况下，两条指令读取同一个寄存器不构成数据冒险。\n- **循环体（1 次迭代）**：\n    - 指令 $1$ ($I_1$)：`load R4 ← Mem[R1 + 0]`\n    - 指令 $2$ ($I_2$)：`store Mem[R1 + 8] ← R5`\n    - 指令 $3$ ($I_3$)：`integer add R6 ← R6 + R9`\n    - 指令 $4$ ($I_4$)：`integer subtract R10 ← R11 - R12`\n- **执行假设**：前端在每次迭代的第一个周期尝试同时发射 $I_1$ 和 $I_2$。\n- **任务**：\n    1.  论证为什么 $I_1$ 和 $I_2$ 之间的交互是结构冒险，而非数据冒险。\n    2.  确定由于 AGU 争用，每次循环迭代产生的停顿周期数。\n    3.  计算 $N = 100$ 次迭代中由 AGU 争用引起的总停顿周期。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行分析。\n\n- **科学性**：该问题基于计算机组成和体系结构的标准、基本概念，包括流水线、发射宽度、结构冒险和数据冒险。该模型是用于教学目的的常规表示。\n- **良构性**：问题定义清晰。它明确了硬件资源（$1$ 个 AGU，$1$ 个 ALU）、发射策略（顺序、双发射、配对）、指令序列以及要回答的具体问题。这些约束足以确定唯一的解决方案。\n- **客观性**：问题使用计算机体系结构领域通用的精确、客观术语进行陈述。它没有歧义和主观性。\n- **缺陷清单**：问题没有违反任何指定的无效条件。它在其领域内是一个可形式化的问题，设置完整且一致，参数对于模型系统是现实的，并且它探讨了一个非平凡的概念点（区分结构冒险和数据冒险）。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供详细的解决方案。\n\n### 解题推导\n\n#### 任务 1：冒险类型的论证\n**数据冒险**发生于一条指令的执行依赖于前一条尚未完成指令的结果。最常见的形式，也是问题中指定的形式，是真相关或写后读（RAW）冒险。当一条指令读取一个由先前指令写入的寄存器或内存位置时，就会发生这种情况。\n\n让我们检查指令 $I_1$ 和 $I_2$：\n- $I_1$：`load R4 ← Mem[R1 + 0]`\n  - 读取：寄存器 $R1$，内存位置 `Mem[R1 + 0]`\n  - 写入：寄存器 $R4$\n- $I_2$：`store Mem[R1 + 8] ← R5`\n  - 读取：寄存器 $R1$ 和 $R5$\n  - 写入：内存位置 `Mem[R1 + 8]`\n\n要在 $I_1$ 和 $I_2$ 之间产生 RAW 数据冒险，$I_2$ 必须读取 $I_1$ 的一个目标。$I_1$ 的目标是寄存器 $R4$。$I_2$ 不读取 $R4$。因此，不存在 RAW 数据冒险。两条指令都读取寄存器 $R1$，但这是一个输入相关，而不是数据流相关。如问题所述，没有中间写操作的情况下读取同一个寄存器不构成数据冒险。\n\n**结构冒险**发生于两条或多条指令在同一个时钟周期内同时需要同一个硬件资源。\n\n让我们分析 $I_1$ 和 $I_2$ 的资源需求：\n- $I_1$ 是一条 `load` 指令。它需要地址生成单元（AGU）来计算其有效地址 `R1 + 0`。\n- $I_2$ 是一条 `store` 指令。它也需要 AGU 来计算其有效地址 `R1 + 8`。\n- 处理器尝试在同一个周期内同时发射 $I_1$ 和 $I_2$。\n- 机器只有一个 AGU。\n\n由于 $I_1$ 和 $I_2$ 都需要在同一个时钟周期内使用唯一的 AGU，它们对该资源产生了争用。这种对共享硬件单元的争用正是结构冒险的定义。\n\n因此，这种交互是由于单一 AGU 资源而产生的结构冒险，而不是数据冒险。使用相同的基址寄存器 $R1$ 使其看起来像是一种相关，但冲突是关于硬件，而不是数据。\n\n#### 任务 2：每次迭代因 AGU 争用产生的停顿周期\n问题指出，前端“尝试按程序顺序将它们作为一对进行发射”。这意味着指令流按获取时的固定配对进行处理：($I_1, I_2$)，然后是 ($I_3, I_4$)。\n\n让我们逐周期分析一次循环迭代的发射过程。\n\n**分析第一对指令 ($I_1, I_2$)：**\n- **周期 1**：发射逻辑尝试发射指令对 ($I_1, I_2$)。\n    - $I_1$ 需要 AGU。\n    - $I_2$ 需要 AGU。\n    - 这是一个结构冒险。根据停顿策略，$I_1$ 被发射，$I_2$ 被停顿。\n    - 在这个周期中只发射了 $1$ 条指令。第二个发射槽未使用，代表一个气泡或一个损失的机会。\n\n- **周期 2**：发射逻辑现在必须发射被停顿的指令 $I_2$。\n    - $I_2$ 被发射并使用 AGU。\n    - 在这个简单的顺序模型中，流水线正在解决来自固定配对的停顿指令，假设第二个发射槽不能通过前瞻到下一对指令来填充。因此，只发射了 $1$ 条指令。\n\n指令对 ($I_1, I_2$)，在具有足够资源的双发射机器上理想情况下可以在 $1$ 个周期内发射，现在需要 $2$ 个周期来发射。延迟是由 AGU 冲突引起的。停顿周期数是实际时间减去理想时间：$2 - 1 = 1$ 个周期。这 $1$ 个周期的停顿纯粹是由于共享 AGU 造成的。\n\n为了完整起见，让我们分析第二对指令 ($I_3, I_4$)：\n- **周期 3**：发射逻辑尝试发射指令对 ($I_3, I_4$)。\n    - $I_3$ (`add`) 需要 ALU。\n    - $I_4$ (`subtract`) 需要 ALU。\n    - 机器只有一个 ALU（“每个周期最多 $1$ 条 ALU 指令”）。这也是一个结构冒险。\n    - $I_3$ 被发射，$I_4$ 被停顿。只发射了 $1$ 条指令。\n\n- **周期 4**：发射逻辑发射被停顿的指令 $I_4$。\n    - $I_4$ 被发射并使用 ALU。只发射了 $1$ 条指令。\n\n指令对 ($I_3, I_4$) 也需要 $2$ 个周期而不是理想的 $1$ 个周期来发射，导致了另一个停顿周期，但这一个是由 ALU 争用引起的。\n\n问题明确要求的是*仅因共享 AGU*而产生的停顿周期数。根据我们对 ($I_1, I_2$) 对的分析，每次迭代这是 $1$ 个停顿周期。\n\n#### 任务 3：$N=100$ 次迭代的总停顿周期\n每次循环迭代的停顿行为都是相同的，因为相同的指令序列和相同的资源冲突会重复执行。\n\n- 每次迭代因 AGU 争用产生的停顿周期数 = $1$。\n- 总迭代次数, $N = 100$。\n\n因 AGU 争用产生的总停顿周期 = (每次迭代的停顿周期) $\\times$ (迭代次数)\n总 AGU 停顿周期 = $1 \\times 100 = 100$。\n\n对于 $N = 100$ 次迭代，仅由 AGU 争用引起的总停顿周期数为 $100$。", "answer": "$$\n\\boxed{100}\n$$", "id": "3682664"}, {"introduction": "将视角从单一核心资源扩展到系统级的共享资源。当多个核心或流水线共享一个资源（如总线）时，资源竞争就变成了一个概率性问题。本练习 [@problem_id:3682652] 将应用排队论这一强大的性能分析工具，来为一个共享的回写总线建模，并量化其竞争概率和预期停顿时间等关键性能指标。", "problem": "一个共享的 $64$ 位写回数据总线被 $M$ 个相同的流水线使用。每个流水线在完成一次存储或脏驱逐时，可能会生成一个写回请求。在每个周期，每个流水线独立地以概率 $\\alpha$ 产生一个写回请求，并且请求被排入一个单一的总线仲裁器队列中，该仲裁器以先来先服务（FCFS）的顺序为它们服务。总线每个周期可以传输 $B$ 个对齐的 $64$ 位字，并且每次写回平均传输 $s$ 个对齐的 $64$ 位字。如果一个写回请求到达时总线正忙，那么发起请求的流水线的写回阶段將停顿，直到服务开始。\n\n假设参数如下：$M = 16$，$\\alpha = 0.01$，$B = 2$ （字/周期），以及 $s = 8$ （字/写回）。将所有流水线的聚合到达过程视为足够稀疏，可以近似为每个周期的泊松过程，并将每次写回的服务时间视为其均值下的确定性时间。从结构性冒险作为共享资源冲突的基本定义出发，并使用适用于计算机系统中内存和互连仲裁的、经过充分检验的排队论结果，推导出新到达的写回请求发现总线繁忙的竞争概率，以及一个写回请求在开始服务前所经历的预期停顿时间（以周期为单位）。\n\n请以无量纲小数形式提供竞争概率的最终数值答案，并以周期为单位提供停顿时间。将两个量都四舍五入到四位有效数字。以周期为单位表示停顿时间。", "solution": "该问题要求分析多流水线计算机系统中的结构性冒险。当多条指令在同一个时钟周期内需要相同的硬件资源时，就会发生结构性冒险。在这里，共享资源是写回数据总线，当多个流水线试图同时执行写回操作时，就会产生冲突。该问题可以建模为单服务器排队系统，其中写回请求是顾客，总线是服务器。问题陈述提供了具体的假设，使我们能够形式化这个模型。\n\n首先，我们验证问题陈述的有效性。\n- **给定条件**：流水线数量 $M = 16$；每个流水线每个周期的请求概率 $\\alpha = 0.01$；总线带宽 $B = 2$ 字/周期；平均写回大小 $s = 8$ 字；排队规则为 FCFS。\n- **假设**：聚合到达过程近似为泊松过程。服务时间在其均值下是确定性的。\n- **验证结论**：该问题在计算机体系结构和排队论方面有科学依据，问题设定良好，数据充分，且是客观的。使用 M/D/1 排队模型是对此类性能分析的标准且适当的技术。因此，该问题是有效的。\n\n我们通过描述排队系统的特征来继续解答。该模型是一个 M/D/1 队列，表示马尔可夫（泊松）到达、确定性服务时间以及单个服务器。\n\n**1. 到达率 ($\\lambda$)**\n有 $M = 16$ 个独立的流水线，每个流水线在每个周期内以概率 $\\alpha = 0.01$ 生成一个请求。问题陈述中说明，将聚合到达过程近似为泊松过程。平均到达率 $\\lambda$ 是每个周期的总请求数的期望值。\n$$ \\lambda = M \\times \\alpha $$\n代入给定值：\n$$ \\lambda = 16 \\times 0.01 = 0.16 \\text{ 请求/周期} $$\n\n**2. 服务时间 ($T_s$)**\n每个写回请求涉及传输 $s = 8$ 个字。总线每个周期可以传输 $B = 2$ 个字。问题指定服务时间在其均值下是确定性的。服务时间 $T_s$ 是为单个请求传输所有字所需的时间。\n$$ T_s = \\frac{s}{B} $$\n代入给定值：\n$$ T_s = \\frac{8 \\text{ 字}}{2 \\text{ 字/周期}} = 4 \\text{ 周期/请求} $$\n此服务时间对所有请求都是恒定的。\n\n**3. 服务器利用率 ($\\rho$)**\n服务器利用率 $\\rho$ 是总线繁忙时间的比例。它是到达率和平均服务时间的乘积。\n$$ \\rho = \\lambda \\times T_s $$\n代入计算出的值：\n$$ \\rho = 0.16 \\text{ 请求/周期} \\times 4 \\text{ 周期/请求} = 0.64 $$\n由于 $\\rho  1$，队列是稳定的，并将达到稳态。\n\n**4. 竞争概率 ($P_{\\text{busy}}$)**\n竞争概率是新到达的写回请求发现总线繁忙的概率。对于具有泊松到达的系统，PASTA（泊松到达看到时间平均）属性适用。该属性指出，发现系统处于给定状态的到达比例等于系统处于该状态的长期时间比例。因此，到达请求发现总线繁忙的概率等于总线繁忙的稳态概率，即服务器利用率 $\\rho$。\n$$ P_{\\text{busy}} = \\rho = 0.64 $$\n\n**5. 预期停顿时间 ($E[T_q]$)**\n停顿时间是请求在开始服务前在队列中等待的时间。我们需要求出在队列中的预期等待时间 $E[T_q]$。对于一个通用的 M/G/1 队列（马尔可夫到达，通用服务分布，1个服务器），平均等待时间的 Pollaczek-Khinchine 公式为：\n$$ E[T_q] = \\frac{\\lambda E[T_s^2]}{2(1-\\rho)} $$\n其中 $E[T_s^2]$ 是服务时间分布的二阶矩。对于我们的 M/D/1 情况，服务时间是确定性的，$T_s = 4$ 周期。确定性值的方差为 $0$。因此，二阶矩为：\n$$ E[T_s^2] = \\text{Var}(T_s) + (E[T_s])^2 = 0 + T_s^2 = T_s^2 $$\n将此代入 $E[T_q]$ 的公式，得到 M/D/1 队列的特定结果：\n$$ E[T_q] = \\frac{\\lambda T_s^2}{2(1-\\rho)} $$\n现在，我们代入数值：$\\lambda = 0.16$，$T_s = 4$，以及 $\\rho = 0.64$。\n$$ E[T_q] = \\frac{0.16 \\times 4^2}{2(1 - 0.64)} = \\frac{0.16 \\times 16}{2 \\times 0.36} = \\frac{2.56}{0.72} $$\n确切值为：\n$$ E[T_q] = \\frac{256}{72} = \\frac{32}{9} \\approx 3.555... \\text{ 周期} $$\n\n**6. 最终数值答案**\n问题要求答案四舍五入到四位有效数字。\n- 竞争概率：$P_{\\text{busy}} = 0.64$。保留四位有效数字，结果是 $0.6400$。\n- 预期停顿时间：$E[T_q] = \\frac{32}{9} \\approx 3.5555...$ 周期。四舍五入到四位有效数字，结果是 $3.556$ 周期。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.6400  3.556\n\\end{pmatrix}\n}\n$$", "id": "3682652"}]}