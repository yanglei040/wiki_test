{"hands_on_practices": [{"introduction": "理想流水线的吞吐率为每个周期一条指令，但现实中的流水线会因为各种“冒险”而产生停顿，从而影响实际性能。本练习 [@problem_id:3629296] 旨在通过一个综合性问题，让你掌握量化流水线实际性能的方法。你将学习计算一个关键指标——平均每指令周期数 (CPI)，其方法是系统地核算来自数据冒险、内存系统延迟和分支预测错误的性能损失。", "problem": "一个五级、顺序、单发射流水线执行一个由四类指令组成的指令流：算术逻辑单元（ALU）操作、加载、存储和条件分支。流水线阶段包括取指、译码、执行、访存和写回。该处理器使用独立的指令和数据存储器，从而消除了取指和数据访问之间的结构冒险。ALU结果实现了完全的数据前推，但从内存加载的值仅在访存阶段后才可用，因此紧跟在加载指令之后并使用其结果的指令无法通过前推完全解决。分支在执行阶段被解析，动态预测器在每个周期提供一个方向预测。指令混合比例分别为 $f_{ALU}$、$f_{LOAD}$、$f_{STORE}$ 和 $f_{BR}$，且 $f_{ALU} + f_{LOAD} + f_{STORE} + f_{BR} = 1$。\n\n假设以下经过充分测试、广泛使用的事实和建模假设：\n- 在一个没有冒险的完全流水线化、单发射机器中，理想的每指令周期数（CPI）为$1$，因为在稳态下每个周期完成一条指令。\n- 平均CPI等于理想基线CPI加上由冒险引起的每条指令的预期停顿周期数，其中期望是基于整个指令流计算的。假设冒险事件在不同指令类别之间是独立的，并且由不同类型冒险引起的停顿在时间上不重叠。\n- ALU操作不产生停顿，因为在此设计中数据前推消除了它们的互锁。\n- 一条加载指令紧跟着一条使用其结果的指令会引起恰好$1$个停顿周期。设$r$表示加载指令紧随其后的是一条依赖它的指令的概率。\n- 一级（L1）数据缓存对加载指令的未命中率为$m$，每次加载未命中会使流水线在命中情况的基础上额外停顿$L$个周期。\n- 存储指令使用一个写缓冲器，对于此工作负载，该缓冲器完全隐藏了写命中和写未命中的影响，因此存储指令不会使流水线停顿。\n- 动态分支预测器对条件分支的错误预测率为$b$，每次错误预测会使流水线清空$C$个周期，而正确预测的分支不产生惩罚。\n\n对于一个特定的工作负载，指令混合和微体系结构参数如下：\n- $f_{ALU} = 0.45$, $f_{LOAD} = 0.25$, $f_{STORE} = 0.10$, $f_{BR} = 0.20$。\n- $r = 0.30$。\n- $m = 0.04$, $L = 12$。\n- $b = 0.10$, $C = 2$。\n\n仅使用上述定义和期望的第一性原理，计算在此假设下该流水线的预期每指令周期数。将你的最终答案表示为一个无单位的实数，并四舍五入到四位有效数字。", "solution": "本题要求计算一个五级流水线处理器的预期每指令周期数（CPI）。解决方案将通过将期望原理应用于所提供的流水线执行模型来推导，该模型包括了各种冒险的惩罚。\n\n所提供的平均CPI基本方程是理想CPI与因冒险导致的每指令平均停顿周期数之和。\n$$\n\\text{CPI} = \\text{CPI}_{\\text{ideal}} + \\Delta\\text{CPI}_{\\text{hazards}}\n$$\n题目指出，对于一个没有冒险的完全流水线化机器，理想CPI为$1$。\n$$\n\\text{CPI}_{\\text{ideal}} = 1\n$$\n每指令总停顿周期数 $\\Delta\\text{CPI}_{\\text{hazards}}$ 是每种冒险类型的贡献之和。题目明确指出，不同类型冒险导致的停顿在时间上不重叠，因此它们的贡献可以直接相加。已确定的潜在停顿来源包括加载-使用数据冒险、数据缓存未命中和分支错误预测。题目说明其他类型的指令（ALU和存储）不产生停顿。\n\n因此，每指令总停顿周期数为：\n$$\n\\Delta\\text{CPI}_{\\text{hazards}} = \\Delta\\text{CPI}_{\\text{load-use}} + \\Delta\\text{CPI}_{\\text{cache-miss}} + \\Delta\\text{CPI}_{\\text{branch-mispredict}}\n$$\n我们现在将计算停顿惩罚的每个组成部分。特定事件贡献的惩罚是可能导致该事件的指令频率、该指令发生该事件的概率以及该事件所产生的停顿周期数的乘积。\n\n1.  **加载-使用数据冒险停顿 ($\\Delta\\text{CPI}_{\\text{load-use}}$)**\n    当一条依赖于前一条加载指令结果的指令紧随其后执行时，就会发生加载-使用冒险。题目指出，这种情况会引起恰好$1$个停顿周期。\n    - 加载指令占所有指令的比例为 $f_{\\text{LOAD}}$。\n    - 加载指令紧随其后的是一条依赖它的指令的概率为 $r$。\n    - 此事件的惩罚是 $1$ 个周期。\n    由此冒险导致的每指令预期停顿周期数为：\n    $$\n    \\Delta\\text{CPI}_{\\text{load-use}} = f_{\\text{LOAD}} \\times r \\times 1\n    $$\n    使用给定的值，$f_{\\text{LOAD}} = 0.25$ 和 $r = 0.30$：\n    $$\n    \\Delta\\text{CPI}_{\\text{load-use}} = 0.25 \\times 0.30 \\times 1 = 0.075\n    $$\n\n2.  **数据缓存未命中停顿 ($\\Delta\\text{CPI}_{\\text{cache-miss}}$)**\n    当加载指令在一级（L1）数据缓存中未命中时，会发生停顿。\n    - 加载指令占所有指令的比例为 $f_{\\text{LOAD}}$。\n    - 加载指令的L1数据缓存未命中率为 $m$。\n    - 缓存未命中的惩罚是额外的 $L$ 个周期。\n    由数据缓存未命中导致的每指令预期停顿周期数为：\n    $$\n    \\Delta\\text{CPI}_{\\text{cache-miss}} = f_{\\text{LOAD}} \\times m \\times L\n    $$\n    使用给定的值，$f_{\\text{LOAD}} = 0.25$, $m = 0.04$, 和 $L = 12$：\n    $$\n    \\Delta\\text{CPI}_{\\text{cache-miss}} = 0.25 \\times 0.04 \\times 12 = 0.01 \\times 12 = 0.12\n    $$\n\n3.  **分支错误预测停顿 ($\\Delta\\text{CPI}_{\\text{branch-mispredict}}$)**\n    当动态分支预测器做出错误预测，导致流水线被清空时，会发生停顿。\n    - 条件分支指令占所有指令的比例为 $f_{\\text{BR}}$。\n    - 分支错误预测率为 $b$。\n    - 错误预测的惩罚是 $C$ 个周期。\n    由分支错误预测导致的每指令预期停顿周期数为：\n    $$\n    \\Delta\\text{CPI}_{\\text{branch-mispredict}} = f_{\\text{BR}} \\times b \\times C\n    $$\n    使用给定的值，$f_{\\text{BR}} = 0.20$, $b = 0.10$, 和 $C = 2$：\n    $$\n    \\Delta\\text{CPI}_{\\text{branch-mispredict}} = 0.20 \\times 0.10 \\times 2 = 0.02 \\times 2 = 0.04\n    $$\n\n最后，我们将理想CPI和所有停顿部分相加，以求得总的预期CPI。\n$$\n\\text{CPI} = \\text{CPI}_{\\text{ideal}} + \\Delta\\text{CPI}_{\\text{load-use}} + \\Delta\\text{CPI}_{\\text{cache-miss}} + \\Delta\\text{CPI}_{\\text{branch-mispredict}}\n$$\n代入计算出的值：\n$$\n\\text{CPI} = 1 + 0.075 + 0.12 + 0.04\n$$\n$$\n\\text{CPI} = 1 + 0.235\n$$\n$$\n\\text{CPI} = 1.235\n$$\n题目要求答案四舍五入到四位有效数字。计算出的值$1.235$已经有四位有效数字。", "answer": "$$\\boxed{1.235}$$", "id": "3629296"}, {"introduction": "在理解了流水线停顿的来源后，我们将聚焦于最常见的数据冒险。本练习 [@problem_id:3629331] 通过一个具体的代码片段，让你深入对比解决数据冒险的两种核心策略：复杂的硬件（数据转发）与更简单的硬件结合编译器辅助（插入空操作指令 NOP）。通过逐周期地追踪指令执行，你将直观地理解数据如何在流水线中流动，以及不同设计哲学所带来的直接后果。", "problem": "一个加载/存储精简指令集计算（RISC）设计中的五级流水线包含取指令（IF）、指令译码和寄存器读取（ID）、执行（EX）、内存访问（MEM）和写回（WB）五个阶段，每个阶段恰好占用一个周期。寄存器堆在ID阶段被读取，在WB阶段被写入。当一条指令需要一个尚未被前序指令写入的寄存器值时，会发生写后读（RAW）数据冒险。假设存在以下两种硬件配置：\n\n1. 无转发：流水线不转发中间结果。消费指令只能在一个严格晚于生产指令的WB阶段完成后的ID阶段读取生产指令的目标寄存器。\n2. 具有硬件冒险检测的全转发：算术结果可以在紧邻的下一个周期从生产指令的EX阶段转发到消费指令的EX阶段。加载结果可以在紧邻的下一个周期从生产指令的MEM阶段转发到消费指令的EX阶段。当需要时，冒险检测单元会在加载-使用依赖上自动暂停一个周期；否则，它不会暂停。\n\n考虑以下指令序列：\n- $I_1$: $LW\\ R_1,\\ 0(R_2)$\n- $I_2$: $ADD\\ R_3,\\ R_1,\\ R_4$\n- $I_3$: $SUB\\ R_5,\\ R_3,\\ R_6$\n\n没有缓存未命中或控制冒险，流水线开始时为空，指令$I_1$在周期1被取出。用于无转发配置的编译器可以插入空操作（NOP）指令以避免冒险；每个NOP像正常指令一样占据流水线。\n\n根据上述定义，确定：\n- 在无转发配置中，编译器必须在$I_1$和$I_2$之间以及$I_2$和$I_3$之间插入的最小NOP数量，以防止所有RAW冒险。\n- 在无转发配置下，使用您找到的最小NOP数量，完成这三条指令序列所需的总周期数。\n- 在具有硬件冒险检测且无编译器插入NOP的全转发配置下，完成相同序列所需的总周期数。\n\n最后，计算无转发配置（插入了最小数量的NOP）下的总周期数与全转发配置（具有硬件冒险检测）下的总周期数之比。将您的最终答案表示为单个最简分数。无需四舍五入。", "solution": "该问题要求在两种不同的硬件配置下，对一个三指令序列在五级RISC流水线上的执行情况进行分析。流水线阶段包括取指令（IF）、指令译码和寄存器读取（ID）、执行（EX）、内存访问（MEM）和写回（WB），每个阶段占用一个周期。该指令序列表现出写后读（RAW）数据冒险。\n\n指令序列如下：\n- $I_1$: $LW\\ R_1,\\ 0(R_2)$（$R_1$的生产者）\n- $I_2$: $ADD\\ R_3,\\ R_1,\\ R_4$（$R_1$的消费者，$R_3$的生产者）\n- $I_3$: $SUB\\ R_5,\\ R_3,\\ R_6$（$R_3$的消费者）\n\n我们分别分析这两种硬件配置。\n\n### 配置1：无转发\n在此配置中，只有当值在寄存器堆中可用时，RAW冒险才能得到解决。由生产指令在其WB阶段写入的值，只有当消费指令的ID阶段在生产指令的WB阶段完成后的周期开始时，才能被消费指令在其ID阶段读取。通过编译器插入空操作（NOP）指令来解决冒险。\n\n**$I_1$和$I_2$之间的冒险：**\n$I_1$（$LW$）为寄存器$R_1$生成一个值。$I_2$（$ADD$）消费这个值。\n让我们确定$I_1$的时间线，它在周期1被取指。\n- $I_1$ IF: 周期 $1$\n- $I_1$ ID: 周期 $2$\n- $I_1$ EX: 周期 $3$\n- $I_1$ MEM: 周期 $4$\n- $I_1$ WB: 周期 $5$\n$R_1$的值在周期5结束时被写入寄存器堆。因此，任何读取$R_1$的指令的ID阶段必须不早于周期6开始。\n\n在没有任何NOP的情况下，$I_2$将在周期2被取指，并在周期3进入其ID阶段。这太早了，会读到$R_1$的旧值。为了将$I_2$的ID阶段延迟到周期6，我们必须延迟其取指。ID阶段是流水线的第二阶段，因此要使$ID(I_2)$在周期6，那么$IF(I_2)$必须在周期5。\n由于指令是每个周期顺序取指的，并且$I_1$在周期1取指，那么在周期5取指$I_2$意味着必须在周期2、3和4取其他三条指令。这些就是编译器插入的NOP。\n- 周期 $1$：取指 $I_1$\n- 周期 $2$：取指 $NOP_1$\n- 周期 $3$：取指 $NOP_2$\n- 周期 $4$：取指 $NOP_3$\n- 周期 $5$：取指 $I_2$\n因此，在$I_1$和$I_2$之间必须插入最少$3$个NOP。\n\n**$I_2$和$I_3$之间的冒险：**\n$I_2$（$ADD$）为寄存器$R_3$生成一个值。$I_3$（$SUB$）消费这个值。\n在$I_1$和$I_2$之间插入3个NOP后，$I_2$的时间线如下：\n- $I_2$ IF: 周期 $5$\n- $I_2$ ID: 周期 $6$\n- $I_2$ EX: 周期 $7$\n- $I_2$ MEM: 周期 $8$\n- $I_2$ WB: 周期 $9$\n$R_3$的值在周期9结束时被写入寄存器堆。因此，$I_3$的ID阶段必须不早于周期10开始。\n\n要使$ID(I_3)$在周期10，那么$IF(I_3)$必须在周期9。\n我们知道$I_2$在周期5被取指。在周期9取指$I_3$意味着必须在周期6、7和8取其他三条指令。\n- 周期 $5$：取指 $I_2$\n- 周期 $6$：取指 $NOP_4$\n- 周期 $7$：取指 $NOP_5$\n- 周期 $8$：取指 $NOP_6$\n- 周期 $9$：取指 $I_3$\n因此，在$I_2$和$I_3$之间必须插入最少$3$个NOP。\n\n**无转发配置的总周期数：**\n流水线执行的完整指令序列是：$I_1, NOP, NOP, NOP, I_2, NOP, NOP, NOP, I_3$。\n这总共有$N=9$条指令。对于一个$k=5$级的流水线，执行$N$条指令所需的总周期数为$k + (N-1)$。\n总周期数 = $5 + (9-1) = 5 + 8 = 13$。\n或者，最后一条指令$I_3$在周期9被取指。它的WB阶段将在4个周期后完成。\n- $I_3$ IF: 周期 $9$\n- $I_3$ ID: 周期 $10$\n- $I_3$ EX: 周期 $11$\n- $I_3$ MEM: 周期 $12$\n- $I_3$ WB: 周期 $13$\n整个序列在周期13结束时完成。\n\n### 配置2：具有硬件冒险检测的全转发\n在此配置中，不插入NOP。硬件通过转发和暂停来处理冒险。\n指令在连续的周期内被取指：$I_1$在周期1，$I_2$在周期2，$I_3$在周期3。\n\n**$I_1$和$I_2$之间的冒险（加载-使用）：**\n- $I_1$（$LW$）的数据在其MEM阶段结束时从内存中获得。\n- $I_2$（$ADD$）需要$R_1$的值用于其EX阶段。\n让我们画出未暂停的流水线：\n| 周期 | 1    | 2    | 3    | 4    | 5    |\n|-------|------|------|------|------|------|\n| $I_1$   | IF   | ID   | EX   | MEM  | WB   |\n| $I_2$   |      | IF   | ID   | EX   | MEM  |\n$I_1$在周期4结束时数据准备就绪。$I_2$在其EX阶段开始时需要它，也就是周期4的开始。数据来得太晚了。\n加载指令的转发规则是从生产者的MEM阶段到消费者的EX阶段，在*下一个*周期（即，周期$t$的MEM可以转发到周期$t+1$的EX）。为了实现这一点，$I_2$的EX阶段必须延迟到周期5。这需要一个周期的暂停。\n问题陈述证实了这一点：“冒险检测单元会在加载-使用依赖上自动暂停一个周期”。\n当冒险在周期3被检测到时（当$I_2$处于ID阶段），暂停被引入。流水线暂停一个周期（周期4），然后恢复执行。\n\n**$I_2$和$I_3$之间的冒险（ALU-ALU）：**\n- $I_2$（$ADD$）的结果在其EX阶段结束时可用。\n- $I_3$（$SUB$）需要这个结果用于其EX阶段。\n算术运算的转发规则是从生产者的EX阶段到消费者的EX阶段，在*下一个*周期（周期$t$的EX到周期$t+1$的EX）。\n让我们构建完整的流水线图，包括第一个冒险产生的一周期暂停。\n| 周期 | 1    | 2    | 3    | 4 (暂停) | 5    | 6    | 7    | 8    |\n|-------|------|------|------|-----------|------|------|------|------|\n| $I_1$   | IF   | ID   | EX   | MEM       | WB   |      |      |      |\n| $I_2$   |      | IF   | ID   | ID        | EX   | MEM  | WB   |      |\n| $I_3$   |      |      | IF   | IF        | ID   | EX   | MEM  | WB   |\n\n在周期4，$I_2$和$I_3$在它们当前的阶段（分别是ID和IF）暂停，而$I_1$继续前进。一个气泡被有效地插入到流水线中。\n- $I_2$的EX阶段现在在周期5。从$I_1$（周期4的MEM）到$I_2$（周期5的EX）的MEM到EX转发按要求工作。\n- $I_3$的EX阶段在周期6。\n- $I_2$（生产者）的EX阶段在周期5。$I_3$（消费者）的EX阶段在周期6。EX到EX的转发路径完美工作，因此不需要额外的暂停。\n\n**全转发配置的总周期数：**\n最后一条指令$I_3$在周期8结束时完成其WB阶段。\n因此，完成该序列的总周期数为$8$。\n\n### 最终计算：周期比\n问题要求无转发配置下的总周期数与全转发配置下的总周期数之比。\n\n- 总周期数（无转发），$C_{NF} = 13$\n- 总周期数（全转发），$C_{F} = 8$\n\n比率为 $\\frac{C_{NF}}{C_{F}} = \\frac{13}{8}$。\n这是一个最简分数。\n对于无转发情况，最小NOP数量是在$I_1$和$I_2$之间插入3个，在$I_2$和$I_3$之间插入3个。无转发的总周期数为13，全转发的总周期数为8。最终的比率为$\\frac{13}{8}$。", "answer": "$$\\boxed{\\frac{13}{8}}$$", "id": "3629331"}, {"introduction": "掌握了分析现有流水线的方法后，我们更进一步，开始思考如何优化其设计。本练习 [@problem_id:3629255] 提出了一个典型的性能优化场景：一个存在明显瓶颈的流水线以及一个改进方案——切分过慢的流水线阶段。这个挑战的关键在于，你不仅要分析指令层面的效率 (CPI)，还要考虑这对时钟周期时间的影响，最终通过计算“加速比”来评估设计更改的整体效益。", "problem": "一个五级顺序流水线由指令提取 (IF)、指令解码和寄存器读取 (ID)、执行 (EX)、内存访问 (MEM) 和写回 (WB) 组成，该流水线实现了完全的数据前递，但经典的加载-使用情况除外。每个阶段的逻辑延迟如下：IF 延迟为 $180\\,\\text{ps}$，ID 延迟为 $170\\,\\text{ps}$，EX 延迟为 $160\\,\\text{ps}$，MEM 延迟为 $360\\,\\text{ps}$，WB 延迟为 $140\\,\\text{ps}$。每个流水线寄存器为周期时间增加了 $40\\,\\text{ps}$ 的锁存器开销。假设一级数据内存总是命中，且分支惩罚可以忽略不计。\n\n一个工作负载是冒险主导的：在一个包含 $N \\gg 1$ 条指令的长动态指令流中，有 $f = 0.70$ 的指令边界是加载-使用冒险，即一条加载指令紧跟着一条依赖于它的指令。在基准流水线中，即使有完全的数据前递，每个这样的加载-使用冒险都会导致一个停顿周期，因为加载的数据仅在 MEM 阶段结束时才可用，若不插入一个气泡，就无法满足相关指令 EX 阶段的时序要求。\n\n一个增强设计通过将 MEM 阶段拆分为两个相等的逻辑阶段 MEM1 和 MEM2，增加了一个额外的流水线阶段，每个阶段的逻辑延迟是原 MEM 阶段的一半。每个阶段的锁存器开销保持为 $40\\,\\text{ps}$。内存的组织方式使得加载的值在 MEM1 阶段结束时即可用，从而能够正确地前递到下一周期相关指令的 EX 阶段，无需任何停顿。机器和工作负载的所有其他方面保持不变，并且没有引入新的结构性冒险。\n\n仅使用基本原理，如每指令周期数 (CPI) 的定义、执行时间、CPI 和时钟周期之间的关系，以及加速比作为执行时间之比的定义，推导并计算此工作负载下增强设计相对于基准设计的总体加速比。将最终加速比表示为单个实数，并将答案四舍五入到四位有效数字。", "solution": "此问题被视为有效，因为它在科学上基于计算机体系结构原理，问题阐述清晰，数据充分，可得出唯一解，并以客观、正式的语言表达。我们可以继续进行分析。\n\n增强设计相对于基准设计的总体加速比定义为它们各自执行时间之比。一个程序的执行时间（$T_{exec}$）由处理器性能的铁律给出：\n$$T_{exec} = N \\times \\text{CPI} \\times T_{clk}$$\n其中 $N$ 是动态指令数，CPI 是每条指令的平均时钟周期数，而 $T_{clk}$ 是时钟周期时间（或周期）。\n\n因此，加速比（$S$）可以表示为：\n$$S = \\frac{T_{exec, base}}{T_{exec, enh}} = \\frac{N \\times \\text{CPI}_{base} \\times T_{clk, base}}{N \\times \\text{CPI}_{enh} \\times T_{clk, enh}}$$\n由于两种设计的工作负载相同，指令数 $N$ 是常数，可以消去：\n$$S = \\frac{\\text{CPI}_{base} \\times T_{clk, base}}{\\text{CPI}_{enh} \\times T_{clk, enh}}$$\n为了计算加速比，我们必须首先确定每种设计的时钟周期和 CPI。\n\n首先，我们分析基准设计。\n流水线处理器的时钟周期（$T_{clk}$）由其最慢阶段的延迟加上流水线寄存器（锁存器）的开销决定。基准五级流水线的阶段延迟如下：\n$T_{IF} = 180\\,\\text{ps}$\n$T_{ID} = 170\\,\\text{ps}$\n$T_{EX} = 160\\,\\text{ps}$\n$T_{MEM} = 360\\,\\text{ps}$\n$T_{WB} = 140\\,\\text{ps}$\n锁存器开销为 $T_{latch} = 40\\,\\text{ps}$。\n\n基准设计的时钟周期 $T_{clk, base}$ 为：\n$$T_{clk, base} = \\max(T_{IF}, T_{ID}, T_{EX}, T_{MEM}, T_{WB}) + T_{latch}$$\n$$T_{clk, base} = \\max(180, 170, 160, 360, 140)\\,\\text{ps} + 40\\,\\text{ps}$$\n$$T_{clk, base} = 360\\,\\text{ps} + 40\\,\\text{ps} = 400\\,\\text{ps}$$\n\n接下来，我们确定基准设计的 CPI，即 $\\text{CPI}_{base}$。CPI 是理想 CPI（对于流水线为 $1$）与每条指令的停顿周期数之和。\n$$\\text{CPI} = 1 + \\text{每条指令的停顿周期数}$$\n停顿是由加载-使用冒险引起的。有 $f = 0.70$ 的指令依赖于紧邻其前的加载指令，并且每个此类冒险会引起 $1$ 个周期的停顿。\n$$\\text{每条指令的停顿周期数} = (\\text{导致停顿的指令比例}) \\times (\\text{每次发生时的停顿周期数})$$\n$$\\text{每条指令的停顿周期数}_{base} = f \\times 1 = 0.70 \\times 1 = 0.70$$\n因此，基准设计的 CPI 为：\n$$\\text{CPI}_{base} = 1 + 0.70 = 1.70$$\n\n现在，我们分析增强设计。\nMEM 阶段被拆分为两个相等的阶段，MEM1 和 MEM2。新的流水线有六个阶段：IF、ID、EX、MEM1、MEM2、WB。延迟分别为：\n$T_{IF} = 180\\,\\text{ps}$\n$T_{ID} = 170\\,\\text{ps}$\n$T_{EX} = 160\\,\\text{ps}$\n$T_{MEM1} = \\frac{T_{MEM}}{2} = \\frac{360}{2}\\,\\text{ps} = 180\\,\\text{ps}$\n$T_{MEM2} = \\frac{T_{MEM}}{2} = \\frac{360}{2}\\,\\text{ps} = 180\\,\\text{ps}$\n$T_{WB} = 140\\,\\text{ps}$\n\n增强设计的时钟周期 $T_{clk, enh}$ 由新的阶段延迟集合和相同的锁存器开销 $T_{latch} = 40\\,\\text{ps}$ 决定。\n$$T_{clk, enh} = \\max(180, 170, 160, 180, 180, 140)\\,\\text{ps} + 40\\,\\text{ps}$$\n$$T_{clk, enh} = 180\\,\\text{ps} + 40\\,\\text{ps} = 220\\,\\text{ps}$$\n\n接下来，我们确定增强设计的 CPI，即 $\\text{CPI}_{enh}$。在这种设计中，内存的组织方式使得加载的值在 MEM1 阶段结束时即可用，这解决了加载-使用冒险，无需任何停顿。\n$$\\text{每条指令的停顿周期数}_{enh} = f \\times 0 = 0.70 \\times 0 = 0$$\n因此，增强设计的 CPI 是理想的：\n$$\\text{CPI}_{enh} = 1 + 0 = 1.00$$\n\n最后，我们可以计算总体加速比 $S$。\n$$S = \\frac{\\text{CPI}_{base} \\times T_{clk, base}}{\\text{CPI}_{enh} \\times T_{clk, enh}} = \\frac{1.70 \\times 400\\,\\text{ps}}{1.00 \\times 220\\,\\text{ps}}$$\n$$S = \\frac{680}{220} = \\frac{68}{22} = \\frac{34}{11}$$\n$$S \\approx 3.090909...$$\n将结果四舍五入到四位有效数字，得到：\n$$S = 3.091$$", "answer": "$$\\boxed{3.091}$$", "id": "3629255"}]}