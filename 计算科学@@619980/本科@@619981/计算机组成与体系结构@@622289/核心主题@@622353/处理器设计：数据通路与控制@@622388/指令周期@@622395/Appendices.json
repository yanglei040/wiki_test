{"hands_on_practices": [{"introduction": "指令周期的第一步是取指阶段，处理器从内存中获取一条指令。这个过程并非单一的原子步骤，而是一系列精心编排的微操作序列。本练习要求你将取指阶段分解为其基本的硬件行为，并考虑现实世界中的约束，如数据总线宽度和字节序，这些约束决定了指令如何从原始字节中组装而成。[@problem_id:3649590]", "problem": "一个处理器以常规的取指-解码-执行序列来实现指令周期。内存系统是字节可寻址的，外部数据总线宽度为 $8$ 位，每条指令恰好为 $16$ 位（即 $2$ 字节）。程序计数器 (PC) 保存字节地址。指令寄存器 (IR) 为 $16$ 位，用于在解码前存储取出的指令。系统使用小端指令编码：指令的低地址字节是最低有效字节 (LSB)，高地址字节是最高有效字节 (MSB)。控制单元 (CU) 向内存地址寄存器 (MAR) 和内存数据寄存器 (MDR) 发出微操作以执行内存访问。\n\n从以下基本定义出发：(i) 字节可寻址的内存在通过 $8$ 位总线进行读取时，每次返回恰好 $8$ 位数据；(ii) 一条 $16$ 位的指令必须由两次连续的字节地址读取来组合而成；(iii) 在小端编码下，低地址字节是 $16$ 位指令的 LSB，请确定哪个控制序列使用两步取指方案正确地实现了取指阶段，包括正确的 PC 增量和将字节正确地组装到 IR 中。假设每次内存读取占用一个总线周期，$MAR \\leftarrow PC$ 将当前字节地址置于内存接口上，并且在内存读取后，$MDR$ 保存返回的字节。使用常规的位片表示法 $IR[7:0]$ 表示低字节，$IR[15:8]$ 表示高字节。\n\n哪个选项指定了取指阶段正确的微操作序列？\n\n- A. 周期 $t_0$：$MAR \\leftarrow PC$；内存读取；$MDR \\leftarrow \\text{Mem}[MAR]$；$IR[7:0] \\leftarrow MDR$；$PC \\leftarrow PC + 1$。周期 $t_1$：$MAR \\leftarrow PC$；内存读取；$MDR \\leftarrow \\text{Mem}[MAR]$；$IR[15:8] \\leftarrow MDR$；$PC \\leftarrow PC + 1$。\n\n- B. 周期 $t_0$：$MAR \\leftarrow PC$；内存读取；$MDR \\leftarrow \\text{Mem}[MAR]$；$IR[15:8] \\leftarrow MDR$；$PC \\leftarrow PC + 1$。周期 $t_1$：$MAR \\leftarrow PC$；内存读取；$MDR \\leftarrow \\text{Mem}[MAR]$；$IR[7:0] \\leftarrow MDR$；$PC \\leftarrow PC + 1$。\n\n- C. 周期 $t_0$：$MAR \\leftarrow PC$；内存读取；$MDR \\leftarrow \\text{Mem}[MAR]$；$IR[7:0] \\leftarrow MDR$；$PC \\leftarrow PC + 2$。周期 $t_1$：$MAR \\leftarrow PC$；内存读取；$MDR \\leftarrow \\text{Mem}[MAR]$；$IR[15:8] \\leftarrow MDR$；$PC \\leftarrow PC + 2$。\n\n- D. 周期 $t_0$：$MAR \\leftarrow PC$；内存读取；$MDR \\leftarrow \\text{Mem}[MAR \\ldots MAR+1]$；$IR \\leftarrow MDR$；$PC \\leftarrow PC + 2$。\n\n选择唯一最佳的选项，该选项既符合 $8$ 位总线约束，又能在两次字节取指过程中正确处理小端字节组装和 PC 的推进。", "solution": "在进行解答之前，首先对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 处理器指令周期：取指-解码-执行。\n- 内存：字节可寻址。\n- 外部数据总线：$8$ 位宽。\n- 指令大小：$16$ 位（$2$ 字节）。\n- 程序计数器 (PC)：保存字节地址。\n- 指令寄存器 (IR)：$16$ 位。\n- 指令编码：小端（低地址字节为最低有效字节 (LSB)；高地址字节为最高有效字节 (MSB)）。\n- 微操作：$MAR \\leftarrow PC$ 将 PC 内容放入内存地址寄存器；内存读取后，内存数据寄存器 (MDR) 保存返回的字节。\n- 表示法：$IR[7:0]$ 是 IR 的低字节；$IR[15:8]$ 是 IR 的高字节。\n- 基本定义：\n    - (i) 在 $8$ 位总线上的内存读取每次返回恰好 $8$ 位。\n    - (ii) 一条 $16$ 位的指令必须由两次连续的字节地址读取来组合而成。\n    - (iii) 小端意味着低地址处的字节是 LSB。\n- 取指阶段使用两步取指方案。\n- 每次内存读取占用一个总线周期。\n\n**步骤 2：使用提取的已知条件进行验证**\n问题陈述具有科学依据，定义明确且客观。\n1.  **科学/事实合理性**：所描述的体系结构是计算机组成原理教学中使用的标准（尽管简化了）模型。字节可寻址性、数据总线宽度、字节序以及 PC、MAR、MDR 和 IR 的作用等概念都是基础性的，并且表述正确。\n2.  **完整性和一致性**：问题提供了推导微操作序列所需的所有必要信息。$8$ 位总线、$16$ 位指令和小端编码这些约束条件是一致的，并共同明确地定义了问题。关于 $16$ 位指令需要从 $8$ 位总线进行两次读取的陈述是该设置的逻辑结果，而非矛盾。\n3.  **问题的适定性**：问题要求根据给定规则推导出一个特定的操作序列。存在一个唯一的、逻辑的解决方案。术语是计算机体系结构领域的标准术语。\n\n**步骤 3：结论与行动**\n问题是**有效的**。将推导解决方案。\n\n**正确取指序列的推导**\n\n任务是将一条 $16$ 位指令取入 $16$ 位的 IR。系统的数据总线为 $8$ 位宽，因此这必须分两个独立的内存读取周期完成。设指令的初始地址包含在程序计数器中，即 $PC = P$。\n\n1.  **第一个取指周期（用于 LSB）：**\n    - 处理器必须首先从地址 $P$ 取出字节。该地址从 PC 传输到内存地址寄存器 (MAR)：$MAR \\leftarrow PC$。\n    - 启动内存读取操作。内存控制器从地址 $P$ 取出 $8$ 位字节，并将其放入内存数据寄存器 (MDR)。这可以写为 $MDR \\leftarrow \\text{Mem}[MAR]$。\n    - 根据小端规范，位于较低地址 ($P$) 的字节是 $16$ 位指令的最低有效字节 (LSB)。\n    - 这个 LSB 必须加载到指令寄存器的低半部分，表示为 $IR[7:0]$。该微操作是：$IR[7:0] \\leftarrow MDR$。\n    - 为了准备取下一个字节，必须更新 PC，使其指向指令第二个字节的地址，即 $P+1$。该微操作是：$PC \\leftarrow PC + 1$。\n\n2.  **第二个取指周期（用于 MSB）：**\n    - PC 现在持有地址 $P+1$。该地址被传输到 MAR 以取出第二个字节：$MAR \\leftarrow PC$。\n    - 对地址 $P+1$ 执行内存读取操作，并将得到的 $8$ 位字节加载到 MDR 中：$MDR \\leftarrow \\text{Mem}[MAR]$。\n    - 这第二个字节，来自较高的地址 ($P+1$)，是指令的最高有效字节 (MSB)。\n    - MSB 被加载到指令寄存器的高半部分，表示为 $IR[15:8]$。该微操作是：$IR[15:8] \\leftarrow MDR$。\n    - 在整个 $16$ 位指令被取出后，PC 必须指向*下一条*指令的地址。由于每条指令长 $2$ 字节，下一条指令位于地址 $P+2$。PC 当前持有 $P+1$，因此必须再次递增：$PC \\leftarrow PC + 1$。PC 的最终值将是 $(P+1)+1 = P+2$。\n\n**组合后的正确序列：**\n- 周期 $t_0$：$MAR \\leftarrow PC$；内存读取 ($MDR \\leftarrow \\text{Mem}[MAR]$)；$IR[7:0] \\leftarrow MDR$；$PC \\leftarrow PC + 1$。\n- 周期 $t_1$：$MAR \\leftarrow PC$；内存读取 ($MDR \\leftarrow \\text{Mem}[MAR]$)；$IR[15:8] \\leftarrow MDR$；$PC \\leftarrow PC + 1$。\n\n现在将使用这个推导出的序列来评估给定的选项。\n\n**逐项分析选项**\n\n- **A. 周期 $t_0$：$MAR \\leftarrow PC$；内存读取；$MDR \\leftarrow \\text{Mem}[MAR]$；$IR[7:0] \\leftarrow MDR$；$PC \\leftarrow PC + 1$。周期 $t_1$：$MAR \\leftarrow PC$；内存读取；$MDR \\leftarrow \\text{Mem}[MAR]$；$IR[15:8] \\leftarrow MDR$；$PC \\leftarrow PC + 1$。**\n  - 该选项与推导出的序列完全匹配。在 $t_0$ 周期，它从 PC 中的地址取出第一个字节，由于是小端编码，正确地将其识别为 LSB ($IR[7:0]$)，并将 PC 增加 $1$。在 $t_1$ 周期，它使用新的 PC 值取出第二个字节，正确地将其放入 MSB 位置 ($IR[15:8]$)，并再次增加 PC 以指向下一条指令。\n  - **结论：正确。**\n\n- **B. 周期 $t_0$：$MAR \\leftarrow PC$；内存读取；$MDR \\leftarrow \\text{Mem}[MAR]$；$IR[15:8] \\leftarrow MDR$；$PC \\leftarrow PC + 1$。周期 $t_1$：$MAR \\leftarrow PC$；内存读取；$MDR \\leftarrow \\text{Mem}[MAR]$；$IR[7:0] \\leftarrow MDR$；$PC \\leftarrow PC + 1$。**\n  - 该选项错误地处理了字节序。在 $t_0$ 周期，它从较低地址取出字节，但将其放入 IR 的 MSB 部分 ($IR[15:8]$)。这描述的是大端取指，与问题明确说明系统是小端的陈述相矛盾。\n  - **结论：错误。**\n\n- **C. 周期 $t_0$：$MAR \\leftarrow PC$；内存读取；$MDR \\leftarrow \\text{Mem}[MAR]$；$IR[7:0] \\leftarrow MDR$；$PC \\leftarrow PC + 2$。周期 $t_1$：$MAR \\leftarrow PC$；内存读取；$MDR \\leftarrow \\text{Mem}[MAR]$；$IR[15:8] \\leftarrow MDR$；$PC \\leftarrow PC + 2$。**\n  - 该选项的 PC 更新逻辑不正确。在 $t_0$ 周期，从地址 $P$ 取出第一个字节后，它将 PC 增加 $2$，因此 PC 变为 $P+2$。在 $t_1$ 周期，操作 $MAR \\leftarrow PC$ 将尝试从地址 $P+2$ 读取，这是下一条指令的开始，而不是当前指令的第二个字节。位于 $P+1$ 的第二个字节被完全跳过。\n  - **结论：错误。**\n\n- **D. 周期 $t_0$：$MAR \\leftarrow PC$；内存读取；$MDR \\leftarrow \\text{Mem}[MAR \\ldots MAR+1]$；$IR \\leftarrow MDR$；$PC \\leftarrow PC + 2$。**\n  - 该选项违反了问题陈述中指定的几个基本约束。\n    1.  操作 $MDR \\leftarrow \\text{Mem}[MAR \\ldots MAR+1]$ 意味着一次内存读取就取出了 $16$ 位数据。根据前提 (i)，这对于 $8$ 位数据总线是不可能的。\n    2.  它与前提 (ii) 相矛盾，前提 (ii) 要求从两次连续的字节读取中组装。此选项描述的是单次读取。\n    3.  问题指出，在一次内存读取后，“MDR 保存返回的字节”（$8$ 位），但此选项暗示 MDR 可以容纳 $16$ 位（$IR \\leftarrow MDR$）。\n  - **结论：错误。**", "answer": "$$\\boxed{A}$$", "id": "3649590"}, {"introduction": "指令被取回后，其操作码必须经过译码，以生成指导数据路径工作的控制信号。本练习将指令译码的体系结构概念与其在数字逻辑中的实现联系起来。通过最小化一个控制信号的布尔函数，你不仅将实践逻辑设计技能，还将直接量化此类优化如何减少关键路径延迟并提高处理器的最高时钟频率。[@problem_id:3649528]", "problem": "您正在分析单周期数据通路中指令周期（取指-译码-执行）的译码阶段。指令寄存器（IR）持有一个4位操作码 $\\left(i_3,i_2,i_1,i_0\\right)$，该操作码输入到组合译码逻辑中，为算术逻辑单元（ALU）和存储器接口生成控制信号。目标是为一个主控制信号最小化布尔译码，并量化由此带来的时钟关键路径的改进。\n\n本问题的基本原理：\n- 布尔代数（结合律、分配律、De Morgan定律）以及诸如“积之和”等范式。\n- 组合逻辑门延迟的构成：传播延迟沿着从一个寄存器输出、经过组合逻辑门到下一个寄存器输入建立的串行路径累积，而并行扇入不会在到达一个门的最晚输入之外增加串行延迟。\n- 最大时钟频率等于关键路径上最长的寄存器到寄存器传播时间的倒数。\n\n假设 `RegWrite` 控制信号 $C_{RW}$ 的操作码到控制映射如下，该信号在执行阶段启用目标寄存器的写入操作：\n- $C_{RW}=1$ 对应的操作码为 $\\{0001,0010,0100,1000,1001\\}$。\n- 其他情况下 $C_{RW}=0$。\n\n使用布尔最小化方法，从布尔代数的基本原理出发，推导 $C_{RW}$ 关于IR位 $\\left(i_3,i_2,i_1,i_0\\right)$ 的最小“积之和”表达式。然后，使用与或逻辑（AND-OR logic）实现最小化表达式，并对补文字（complemented literals）使用输入反相器。假设以下实际的门延迟：\n- 反相器延迟 $t_{\\mathrm{INV}}=0.03~\\mathrm{ns}$。\n- 三输入与门延迟 $t_{\\mathrm{AND3}}=0.07~\\mathrm{ns}$。\n- 四输入与门延迟 $t_{\\mathrm{AND4}}=0.09~\\mathrm{ns}$。\n- 四输入或门延迟 $t_{\\mathrm{OR4}}=0.09~\\mathrm{ns}$。\n\n译码输出 $C_{RW}$ 驱动一个延迟为 $t_{\\mathrm{MUX4}}=0.12~\\mathrm{ns}$ 的4到1 ALU操作多路复用器（MUX），然后是延迟为 $t_{\\mathrm{ALU}}=0.41~\\mathrm{ns}$ 的ALU，最后是目标寄存器，其建立时间为 $t_{\\mathrm{setup}}=0.07~\\mathrm{ns}$。指令寄存器的时钟到Q端延迟 $t_{CQ}=0.08~\\mathrm{ns}$。\n\n作为背景，最小化之前的实现使用了一个延迟为 $t_{\\mathrm{DEC16}}=0.25~\\mathrm{ns}$ 的16线译码器，后接一个延迟为 $t_{\\mathrm{OR5}}=0.13~\\mathrm{ns}$ 的5输入或门，以最小项之和的形式实现 $C_{RW}$；所有其他下游延迟保持不变。\n\n任务：\n1. 从“积之和”形式的布尔代数定义出发，推导 $C_{RW}$ 的最小化表达式。\n2. 使用给定的门延迟，计算最小化后由控制路径（从IR经过译码、ALU操作MUX、ALU到目标寄存器）主导的寄存器到寄存器关键路径时间。\n3. 据此计算新的最大时钟频率。将最终数值结果四舍五入到四位有效数字，并以 $\\mathrm{MHz}$ 为单位表示频率。\n\n您的最终答案必须是一个实数值，代表最小化后的最大时钟频率，单位由题目说明隐含。", "solution": "我们从布尔代数的基础知识开始。设操作码位为 $\\left(i_3,i_2,i_1,i_0\\right)$，其中每个 $i_k \\in \\{0,1\\}$，设 `RegWrite` 控制信号为 $C_{RW}$。根据“积之和”的定义，对于指定的操作码，其值为1的规范表达式是 $C_{RW}=1$ 所在行对应的最小项的逻辑和。\n\n指定的集合是 $\\{0001,0010,0100,1000,1001\\}$。写出最小项（其中补文字表示 $\\neg i_k$，原文字表示 $i_k$）：\n- 对于 $0001$: $\\neg i_3 \\land \\neg i_2 \\land \\neg i_1 \\land i_0$。\n- 对于 $0010$: $\\neg i_3 \\land \\neg i_2 \\land i_1 \\land \\neg i_0$。\n- 对于 $0100$: $\\neg i_3 \\land i_2 \\land \\neg i_1 \\land \\neg i_0$。\n- 对于 $1000$: $i_3 \\land \\neg i_2 \\land \\neg i_1 \\land \\neg i_0$。\n- 对于 $1001$: $i_3 \\land \\neg i_2 \\land \\neg i_1 \\land i_0$。\n\n因此，规范的“积之和”表达式为\n$$\nC_{RW} = (\\neg i_3 \\land \\neg i_2 \\land \\neg i_1 \\land i_0)\\ \\lor\\ (\\neg i_3 \\land \\neg i_2 \\land i_1 \\land \\neg i_0)\\ \\lor\\ (\\neg i_3 \\land i_2 \\land \\neg i_1 \\land \\neg i_0)\\ \\lor\\ (i_3 \\land \\neg i_2 \\land \\neg i_1 \\land \\neg i_0)\\ \\lor\\ (i_3 \\land \\neg i_2 \\land \\neg i_1 \\land i_0).\n$$\n\n我们使用 Karnaugh 图的邻接特性或直接布尔因式分解来进行最小化。观察到最后两个最小项 $1000$ 和 $1001$ 仅在 $i_0$ 位上不同。将它们组合产生蕴含项\n$$\ni_3 \\land \\neg i_2 \\land \\neg i_1,\n$$\n该项覆盖了 $1000$ 和 $1001$。剩下的三个最小项 $\\{0001,0010,0100\\}$ 在 $\\left(i_3,i_2,i_1,i_0\\right)$ 图上两两不相邻，无法在不包含不期望的状态（没有指定“无关”项）的情况下进行组合。因此，最小“积之和”表达式为\n$$\nC_{RW} = (i_3 \\land \\neg i_2 \\land \\neg i_1)\\ \\lor\\ (\\neg i_3 \\land \\neg i_2 \\land \\neg i_1 \\land i_0)\\ \\lor\\ (\\neg i_3 \\land \\neg i_2 \\land i_1 \\land \\neg i_0)\\ \\lor\\ (\\neg i_3 \\land i_2 \\land \\neg i_1 \\land \\neg i_0).\n$$\n\n我们现在使用与或逻辑（AND-OR logic）实现 $C_{RW}$，并对补文字使用输入反相器。四个乘积项由一个三输入与门和三个四输入与门组成，它们的输出送入一个四输入或门。根据组合逻辑门的传播延迟构成，译码路径延迟由到达或门的最晚输入决定，该输入源自最慢的乘积项。对于每个乘积项，到达其与门输入的最慢信号发生在经过反相器的补文字路径上；原文字路径更快。因此，最坏情况下的译码路径时间是\n$$\nt_{\\mathrm{decode}} = t_{\\mathrm{INV}} + t_{\\mathrm{AND4}} + t_{\\mathrm{OR4}}.\n$$\n我们选择四输入项作为最坏情况，因为 $t_{\\mathrm{AND4}} > t_{\\mathrm{AND3}}$。\n\n代入给定值：\n$$\nt_{\\mathrm{decode}} = 0.03\\ \\mathrm{ns} + 0.09\\ \\mathrm{ns} + 0.09\\ \\mathrm{ns} = 0.21\\ \\mathrm{ns}.\n$$\n\n沿控制到执行路径的完整寄存器到寄存器关键路径包括指令寄存器的时钟到Q端延迟、译码网络延迟、ALU操作多路复用器延迟、ALU延迟和目标寄存器的建立时间：\n$$\nt_{\\mathrm{path}} = t_{CQ} + t_{\\mathrm{decode}} + t_{\\mathrm{MUX4}} + t_{\\mathrm{ALU}} + t_{\\mathrm{setup}}.\n$$\n代入数值：\n$$\nt_{\\mathrm{path}} = 0.08\\ \\mathrm{ns} + 0.21\\ \\mathrm{ns} + 0.12\\ \\mathrm{ns} + 0.41\\ \\mathrm{ns} + 0.07\\ \\mathrm{ns} = 0.89\\ \\mathrm{ns}.\n$$\n\n最大时钟频率是关键路径时间的倒数。使用 $1\\ \\mathrm{ns}^{-1} = 10^3\\ \\mathrm{MHz}$ 转换为 $\\mathrm{MHz}$：\n$$\nf_{\\max} = \\frac{10^3}{t_{\\mathrm{path}}\\ \\mathrm{(ns)}} = \\frac{10^3}{0.89} \\ \\mathrm{MHz} \\approx 1123.5955056179776\\ \\mathrm{MHz}.\n$$\n四舍五入到四位有效数字，结果是\n$$\n1124\\ \\mathrm{MHz}.\n$$\n\n关于时钟关键路径缩减的讨论：最小化前的译码使用了一个16线译码器和一个5输入或门，得到\n$$\nt_{\\mathrm{decode,pre}} = t_{\\mathrm{DEC16}} + t_{\\mathrm{OR5}} = 0.25\\ \\mathrm{ns} + 0.13\\ \\mathrm{ns} = 0.38\\ \\mathrm{ns},\n$$\n因此\n$$\nt_{\\mathrm{path,pre}} = 0.08\\ \\mathrm{ns} + 0.38\\ \\mathrm{ns} + 0.12\\ \\mathrm{ns} + 0.41\\ \\mathrm{ns} + 0.07\\ \\mathrm{ns} = 1.06\\ \\mathrm{ns},\n$$\n且\n$$\nf_{\\max,\\mathrm{pre}} = \\frac{10^3}{1.06} \\ \\mathrm{MHz} \\approx 943.396226\\ \\mathrm{MHz}.\n$$\n最小化减少了译码的扇入和门级深度，将译码部分的延迟从 $0.38\\ \\mathrm{ns}$ 降低到 $0.21\\ \\mathrm{ns}$，并将 $f_{\\max}$ 从约 $943.4\\ \\mathrm{MHz}$ 提高到约 $1124\\ \\mathrm{MHz}$。最终要求的数值结果是最小化后的最大时钟频率。", "answer": "$$\\boxed{1124}$$", "id": "3649528"}, {"introduction": "为提升性能，现代处理器使用流水线技术来重叠执行多条指令。这个动手模拟练习要求你手动追踪一个程序在五级流水线中的执行过程，让你具体理解数据和控制冒险是如何产生的，以及像转发、停顿和冲刷等机制是如何解决这些问题的。这种逐周期的详细分析对于掌握流水线数据路径的复杂动态至关重要。[@problem_id:3649602]", "problem": "一个玩具精简指令集计算机 (RISC) 使用经典的五级指令流水线，该流水线实现了取指-译码-执行模式，包含以下阶段：取指 (IF)、指令译码/寄存器读取 (ID)、执行/地址计算 (EX)、内存访问 (MEM) 和寄存器写回 (WB)。该处理器具有以下属性和规则：\n\n- 程序计数器 (PC) 保存字节地址，并在顺序取指时递增 $4$。\n- 指令寄存器 (IR) 指的是在给定周期中锁存到 ID 阶段的指令。\n- 寄存器堆有 $32$ 个整数寄存器。寄存器 $R0$ 硬连线为 $0$。\n- 在没有停顿时，每个周期发射一条指令。\n- 从 EX/MEM 和 MEM/WB 流水线寄存器到 EX 阶段的输入有转发功能，这消除了除加载-使用冒险之外的所有算术数据冒险。\n- 当 ID 阶段的指令需要一个寄存器，而该寄存器是当前处于 EX 或 MEM 阶段的加载指令的目标寄存器时，会发生加载-使用冒险；在这种情况下，冒险单元会插入一个气泡（在 EX 阶段的一个空操作）并将 IF 和 ID 阶段停顿一个周期。停顿之后，转发功能会提供所需的值。\n- 分支在 EX 阶段进行解析。没有分支预测；流水线总是取顺序路径。对于一个被采纳的分支（跳转成功的分支），在分支解析时刻处于 IF 和 ID 阶段的指令将被冲刷（转换为空操作），并且 PC 将在下一个周期开始时重定向到目标地址。分支指令本身不写入寄存器。\n- 指令内存和数据内存均在一个周期内响应；没有缓存未命中。\n- 所有算术和逻辑操作都在 EX 阶段完成，延迟为一个周期。\n\n指令集包括以下操作及其语义：\n- 加载字：$\\text{LW } R_d, \\text{offset}(R_s)$ 从内存地址 $R[R_s] + \\text{offset}$ 加载 $32$ 位字到 WB 阶段的寄存器 $R_d$ 中。\n- 加法：$\\text{ADD } R_d, R_s, R_t$ 在 WB 阶段写入 $R_d \\leftarrow R[R_s] + R[R_t]$。\n- 减法：$\\text{SUB } R_d, R_s, R_t$ 在 WB 阶段写入 $R_d \\leftarrow R[R_s] - R[R_t]$。\n- 按位或：$\\text{OR } R_d, R_s, R_t$ 在 WB 阶段写入 $R_d \\leftarrow R[R_s] \\,|\\, R[R_t]$。\n- 相等则分支：$\\text{BEQ } R_s, R_t, \\text{imm}$ 比较 $R[R_s]$ 和 $R[R_t]$；如果相等，下一个 PC 变为 $\\text{PC} + 4 + 4 \\times \\text{imm}$；否则，保持为 $\\text{PC} + 4$。\n\n考虑以下从字节地址 $\\text{PC} = 0$ 开始的程序（每条指令为 $4$ 字节）：\n- 地址 $0$ 处：$\\text{LW } R1, 0(R0)$\n- 地址 $4$ 处：$\\text{ADD } R2, R1, R0$\n- 地址 $8$ 处：$\\text{SUB } R3, R2, R1$\n- 地址 $12$ 处：$\\text{BEQ } R3, R0, +1$\n- 地址 $16$ 处：$\\text{ADD } R4, R4, R1$\n- 地址 $20$ 处：$\\text{OR } R5, R2, R3$\n\n周期 $1$ 时的初始架构状态（在任何流水线活动之前）：\n- 寄存器：$R0 = 0$（硬连线），$R4 = 7$，所有其他通用寄存器均为 $0$。\n- 内存：字节地址 $0$ 处的 $32$ 位字等于 $5$；其他内存位置不相关。\n\n任务：\n- 根据上述规则，在五级流水线下逐周期手动执行程序。对于每个周期，记录：\n  - 该周期中 IF 使用的 PC 值，以字节地址表示。\n  - 该周期中 ID 的 IR 内容（写出 ID 中指令的助记符和操作数，如果没有则表示为气泡）。\n  - 该周期中 WB 之后寄存器 $R1$, $R2$, $R3$, $R4$, $R5$ 的架构寄存器状态。\n- 精确解释任何停顿或冲刷在何处以及为何发生，需参考取指-译码-执行流程和冒险规则。\n\n答案规范：\n- 完成手动分步执行和解释后，报告从第一次取指（周期 1）开始，到程序最后一条提交的指令完成其 WB 阶段的周期（包含该周期）所经过的总周期数。仅提供此总数作为最终数值答案。无需四舍五入。最终数值答案中不要包含任何单位。", "solution": "我们从指令周期和五级流水线规则的定义开始：每条指令依次通过 IF、ID（指令寄存器在此阶段保存当前指令）、EX（进行算术或地址计算以及分支条件评估）、MEM（用于加载和存储）和 WB（进行寄存器写入）阶段。除了加载-使用冒险外，通过完全转发，算术依赖关系可以无需停顿地解决，但紧随其后的指令若要使用加载结果，则需要一次停顿。分支在 EX 阶段解析，没有分支预测；如果分支被采纳，该时刻处于 IF 和 ID 阶段的指令将被冲刷，导致两个指令的惩罚。\n\n为便于参考，我们标记这些指令：\n- $I_1$: $\\text{LW } R1, 0(R0)$ 于地址 $0$。\n- $I_2$: $\\text{ADD } R2, R1, R0$ 于地址 $4$。\n- $I_3$: $\\text{SUB } R3, R2, R1$ 于地址 $8$。\n- $I_4$: $\\text{BEQ } R3, R0, +1$ 于地址 $12$。\n- $I_5$: $\\text{ADD } R4, R4, R1$ 于地址 $16$。\n- $I_6$: $\\text{OR } R5, R2, R3$ 于地址 $20$。\n\n周期 $1$ 之前的初始状态：\n- 寄存器：$R0 = 0$, $R1 = 0$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$。\n- 内存：$\\text{Mem}[0] = 5$。\n\n我们逐周期进行模拟，每个周期跟踪三个项目：IF 中的 PC，ID 中的 IR，以及 WB 后的寄存器状态。\n\n周期 $1$:\n- IF: 在 $\\text{PC} = 0$ 处取指 $I_1$；下一个顺序 PC 变为 $4$。\n- ID: 空（流水线填充）。\n- EX/MEM/WB: 空。\n- ID 中的 IR: $\\varnothing$。\n- WB 效果：无。\n- WB 后的寄存器: $R1 = 0$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$。\n\n周期 $2$:\n- IF: 在 $\\text{PC} = 4$ 处取指 $I_2$；下一个 PC 变为 $8$。\n- ID: $I_1$；读取 $R0 = 0$ 以备后续地址计算。\n- EX/MEM/WB: 空。\n- ID 中的 IR: $I_1$ 在 ID 阶段。\n- WB 效果：无。\n- WB 后的寄存器: $R1 = 0$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$。\n\n周期 $3$:\n- IF: 在 $\\text{PC} = 8$ 处取指 $I_3$；下一个 PC 变为 $12$。\n- ID: $I_2$；$I_2$ 需要 $R1$ 和 $R0$。\n- EX: $I_1$ 计算有效地址 $R[R0] + 0 = 0$。\n- MEM/WB: 空。\n- ID 中的 IR: $I_2$。\n- WB 效果：无。\n- WB 后的寄存器: $R1 = 0$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$。\n\n周期 $4$:\n- 冒险分析：ID 阶段的 $I_2$ 需要 $R1$，而 $R1$ 是本周期处于 MEM 阶段的加载指令 $I_1$ 的目标寄存器。这是一个经典的加载-使用冒险。根据规则，在 EX 阶段插入一个气泡，并将 IF/ID 停顿一个周期。\n- IF: 停顿；PC 保持为 $\\text{PC} = 8$，已取指的 $I_3$ 被暂存。\n- ID: $I_2$ 停留在 ID 阶段（停顿）。\n- EX: 气泡（无指令）。\n- MEM: $I_1$ 从地址 $0$ 执行内存读取。\n- WB: 空。\n- ID 中的 IR: $I_2$（停顿）。\n- WB 效果：无。\n- WB 后的寄存器: $R1 = 0$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$。\n- 停顿解释：$I_1$ 的加载结果在本周期内无法用于 $I_2$ 的 EX 阶段；直到 MEM 完成后，转发才能提供该值。因此，流水线将 $I_2$ 保持在 ID 阶段，并在 EX 阶段插入一个气泡。\n\n周期 $5$:\n- IF: 在 $\\text{PC} = 12$ 处取指 $I_4$（之前被暂存的 $I_3$ 进入 ID 阶段）。\n- ID: $I_3$；读取 $R2$ 和 $R1$。\n- EX: $I_2$ 执行，使用转发的 $R1 = 5$（在周期 4 中加载完成 MEM 阶段后可用，并在本周期 WB 阶段写入或通过 MEM/WB 转发）和 $R0 = 0$；计算 $R2 = 5 + 0 = 5$。\n- MEM: 对于 $I_2$ 为空（ALU 指令通过）。\n- WB: $I_1$ 写回 $R1 \\leftarrow \\text{Mem}[0] = 5$。\n- ID 中的 IR: $I_3$。\n- WB 效果: $R1 \\leftarrow 5$。\n- WB 后的寄存器: $R1 = 5$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$。\n\n周期 $6$:\n- IF: 在 $\\text{PC} = 16$ 处取指 $I_5$。\n- ID: $I_4$。\n- EX: $I_3$ 执行，操作数为 $R2$ 和 $R1$。通过转发，$R2 = 5$ 从 $I_2$ 的 EX/MEM 流水线寄存器转发而来（在周期 5 计算），而 $R1 = 5$ 已通过 $I_1$ 在周期 5 的 WB 阶段写入寄存器堆。计算 $R3 = 5 - 5 = 0$。\n- MEM: $I_2$ 在 MEM 阶段（ALU 操作通过）。\n- WB: 空。\n- ID 中的 IR: $I_4$。\n- WB 效果：本周期无。\n- WB 后的寄存器: $R1 = 5$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$。\n\n周期 $7$:\n- IF: 在 $\\text{PC} = 20$ 处取指 $I_6$。\n- ID: $I_5$（此指令将受到分支控制冒险的影响）。\n- EX: $I_4$ 评估分支条件。它需要 $R3$ 和 $R0$；$R3 = 0$ 从 $I_3$ 的 EX/MEM 寄存器转发而来（在周期 6 计算），而 $R0 = 0$。条件为相等，因此分支被采纳；分支目标是 $\\text{PC}_{I_4} + 4 + 4 \\times 1 = 12 + 4 + 4 = 20$。\n- MEM: $I_3$ 在 MEM 阶段（ALU 操作通过）。\n- WB: $I_2$ 写回 $R2 \\leftarrow 5$。\n- ID 中的 IR: $I_5$。\n- WB 效果：$R2 \\leftarrow 5$。\n- WB 后的寄存器: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 0$。\n- 分支冲刷解释：因为分支在 EX 阶段被解析为采纳，当前处于 IF（地址 20 的 $I_6$）和 ID（地址 16 的 $I_5$）阶段的指令位于错误预测的顺序路径上。这两条指令都在本周期末被冲刷，导致两个指令的控制冒险惩罚。PC 被重定向到 $20$ 用于下一周期的取指。\n\n周期 $8$:\n- IF: 从分支目标地址 $\\text{PC} = 20$ 取指，即 $I_6$。\n- ID: 气泡（被冲刷的 $I_5$）。\n- EX: 气泡（从 ID 推进的被冲刷的气泡）。\n- MEM: $I_4$ 在 MEM 阶段（分支占用阶段但不写入寄存器）。\n- WB: $I_3$ 写回 $R3 \\leftarrow 0$。\n- ID 中的 IR: $\\varnothing$（气泡）。\n- WB 效果：$R3 \\leftarrow 0$（值未改变，但发生了架构性写入）。\n- WB 后的寄存器: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 0$。\n\n周期 $9$:\n- IF: 取下一个顺序地址 $\\text{PC} = 24$（内容不相关；程序的最后一条提交指令是 $I_6$）。\n- ID: $I_6$。\n- EX: 气泡。\n- MEM: 气泡。\n- WB: $I_4$（分支）在 WB 阶段不写入。\n- ID 中的 IR: $I_6$。\n- WB 效果：无。\n- WB 后的寄存器: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 0$。\n\n周期 $10$:\n- IF: 取指 $\\text{PC} = 28$（不相关）。\n- ID: 气泡（因为 $I_6$ 移至 EX）。\n- EX: $I_6$ 执行：计算 $R5 = R2 \\,|\\, R3 = 5 \\,|\\, 0 = 5$。\n- MEM: 气泡。\n- WB: 气泡。\n- ID 中的 IR: $\\varnothing$（气泡）。\n- WB 效果：无。\n- WB 后的寄存器: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 0$。\n\n周期 $11$:\n- IF: 取指 $\\text{PC} = 32$（不相关）。\n- ID: 气泡。\n- EX: 气泡。\n- MEM: $I_6$。\n- WB: 气泡。\n- ID 中的 IR: $\\varnothing$。\n- WB 效果：无。\n- WB 后的寄存器: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 0$。\n\n周期 $12$:\n- IF: 取指 $\\text{PC} = 36$（不相关）。\n- ID: 气泡。\n- EX: 气泡。\n- MEM: 气泡。\n- WB: $I_6$ 写回 $R5 \\leftarrow 5$。\n- ID 中的 IR: $\\varnothing$。\n- WB 效果：$R5 \\leftarrow 5$。\n- WB 后的寄存器: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 5$。\n\n停顿和冲刷解释：\n- 唯一的加载-使用停顿发生在周期 $4$，因为 $I_2$ 依赖于 $I_1$ 的结果，而加载的数据在 $I_1$ 完成 MEM 阶段之前对 EX 阶段是不可用的。冒险单元在 EX 阶段插入一个气泡并暂停 IF/ID，这反映在周期 $4$ 中重复的 $\\text{PC} = 8$ 和 $I_2$ 停留在 ID 阶段。\n- $I_4$ 中的被采纳分支在周期 $7$ 的 EX 阶段解析，冲刷了 IF 和 ID 中的指令（$I_6$ 和 $I_5$）并将 PC 重定向到目标地址（$20$）。这产生了两个气泡，分别出现在周期 $8$ 的 ID 和 EX 阶段，流水线从正确的目标地址重新取指 $I_6$。\n\n最终提交的指令和总周期数：\n- 最后一条提交的指令是位于地址 $20$ 的 $I_6$，它在周期 $12$ 完成其 WB 阶段。\n- 从周期 $1$ 的初始取指开始，到 $I_6$ 完成 WB 阶段，总周期数为 $12$。\n\n因此，所需的总周期数为 $12$。", "answer": "$$\\boxed{12}$$", "id": "3649602"}]}