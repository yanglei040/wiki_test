{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。在深入探讨了微程序控制器的设计原理之后，我们必须亲手设计一个。本练习将指导您完成微程序控制单元中最核心部分——控制存储器的设计。通过为一个具体的数据通路和指令集架构（ISA）确定控制信号的编码方式，您将计算出控制存储器的宽度和深度，从而直观地理解数据通路的复杂性与微程序控制器物理规模之间的直接联系 [@problem_id:3660292]。", "problem": "要求你为一个实现了$32$条指令的指令集架构（ISA）的多周期处理器数据通路设计一个微程序控制存储器。微码编码必须确保所有多路选择器的选择都采用独热控制，并且加载和写入操作采用显式的单比特选通信号。请使用以下关于微程序控制和多周期数据通路的科学基本假设：微指令是一个固定宽度的字，其比特位直接门控控制信号；一个$k$路选择器的独热编码使用$k$条不同的控制线，其中有且仅有一条被置为有效以选择一个源；控制存储器的深度等于在所选微码组织下实现指令序列所需的独立微指令的数量。\n\n数据通路具有以下控制点，每个控制点必须按照指定的独热或选通约定在微指令中表示：\n\n- 内存地址源选择器 $\\mathrm{IorD}$：$2$个选项 $\\{ \\mathrm{PC}, \\mathrm{ALUOut} \\}$，使用$2$条线进行独热编码。\n- 算术逻辑单元（ALU）输入A选择器 $\\mathrm{ALUSrcA}$：$2$个选项 $\\{ \\mathrm{PC}, \\mathrm{A} \\}$，使用$2$条线进行独热编码。\n- 算术逻辑单元（ALU）输入B选择器 $\\mathrm{ALUSrcB}$：$4$个选项 $\\{ \\mathrm{B}, \\text{const } 4, \\mathrm{Imm}, \\mathrm{Imm}  2 \\}$，使用$4$条线进行独热编码。\n- 程序计数器源选择器 $\\mathrm{PCSource}$：$3$个选项 $\\{ \\mathrm{ALUResult}, \\mathrm{ALUOut}, \\mathrm{JumpAddr} \\}$，使用$3$条线进行独热编码。\n- 寄存器目标选择器 $\\mathrm{RegDst}$：$3$个选项 $\\{ rt, rd, r_{31} \\}$，使用$3$条线进行独热编码。\n- 寄存器写回数据选择器 $\\mathrm{MemtoReg}$：$3$个选项 $\\{ \\mathrm{ALUResult}, \\mathrm{MDR}, \\mathrm{PC} + 4 \\}$，使用$3$条线进行独热编码。\n- ALU操作控制 $\\mathrm{ALUOp}$：用于已实现的ALU功能的$8$条独热线。\n- 立即数扩展选择器 $\\mathrm{ExtOp}$：$2$个选项 $\\{ \\mathrm{sign\\ extend}, \\mathrm{zero\\ extend} \\}$，使用$2$条线进行独热编码。\n- 单比特选通信号：$\\mathrm{IRWrite}$、$\\mathrm{PCWrite}$、$\\mathrm{PCWriteCond}$、$\\mathrm{MemRead}$、$\\mathrm{MemWrite}$、$\\mathrm{RegWrite}$、$\\mathrm{MDRWrite}$、$\\mathrm{AWrite}$、$\\mathrm{BWrite}$、$\\mathrm{ALUOutWrite}$，每个都是一个单独的控制位，总共$10$位。\n\n假设采用一种简单的微程序组织，其中每条指令都有其自己的微序列，包括其取指和译码步骤（没有子程序共享或压缩）。该ISA被划分为多个类别，各类别的指令数量和每条指令的周期要求如下：\n\n- $10$条寄存器型ALU指令：每条$4$个周期。\n- $6$条立即数型ALU指令：每条$3$个周期。\n- $5$条加载指令：每条$5$个周期。\n- $3$条存储指令：每条$4$个周期。\n- $4$条条件分支指令：每条$3$个周期。\n- $3$条跳转指令（无链接）：每条$2$个周期。\n- $1$条跳转并链接指令：$3$个周期。\n\n任务：\n\n1. 通过列出字段及其位宽，提出一个与上述控制点和独热要求一致的具体微指令格式。\n2. 使用微程序控制的基本原理，确定控制存储器的宽度（以比特为单位）和深度（以微指令为单位）。\n3. 计算控制存储器中存储的总比特数，即宽度和深度的乘积。\n\n将最终的控制存储器总大小表示为单个比特数。无需四舍五入。最终答案必须是单个实值数。将所有符号放在$...$中，并确保每个数字都以LaTeX格式显示。不要在加框的最终答案中包含单位；但应将该值解释为比特。", "solution": "在尝试给出解决方案之前，对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n-   指令集架构（ISA）大小：$32$条指令。\n-   控制信号编码：所有多路选择器选择采用独热编码，加载和写入采用单比特选通信号。\n-   微程序组织：每条指令都有其自己的微序列，包括取指和译码。无子程序共享或压缩。\n-   控制存储器深度是不同微指令的总数。\n-   控制点和编码：\n    -   $\\mathrm{IorD}$（内存地址选择器）：$2$个选项，独热编码（$2$位）。\n    -   $\\mathrm{ALUSrcA}$（ALU输入A选择器）：$2$个选项，独热编码（$2$位）。\n    -   $\\mathrm{ALUSrcB}$（ALU输入B选择器）：$4$个选项，独热编码（$4$位）。\n    -   $\\mathrm{PCSource}$（PC源选择器）：$3$个选项，独热编码（$3$位）。\n    -   $\\mathrm{RegDst}$（寄存器目标选择器）：$3$个选项，独热编码（$3$位）。\n    -   $\\mathrm{MemtoReg}$（寄存器写回数据选择器）：$3$个选项，独热编码（$3$位）。\n    -   $\\mathrm{ALUOp}$（ALU操作控制）：$8$条独热线（$8$位）。\n    -   $\\mathrm{ExtOp}$（立即数扩展选择器）：$2$个选项，独热编码（$2$位）。\n    -   选通信号：$\\mathrm{IRWrite}$、$\\mathrm{PCWrite}$、$\\mathrm{PCWriteCond}$、$\\mathrm{MemRead}$、$\\mathrm{MemWrite}$、$\\mathrm{RegWrite}$、$\\mathrm{MDRWrite}$、$\\mathrm{AWrite}$、$\\mathrm{BWrite}$、$\\mathrm{ALUOutWrite}$。总共$10$个单比特选通信号（$10$位）。\n-   ISA划分和周期计数：\n    -   $10$条寄存器型ALU指令，每条$4$个周期。\n    -   $6$条立即数型ALU指令，每条$3$个周期。\n    -   $5$条加载指令，每条$5$个周期。\n    -   $3$条存储指令，每条$4$个周期。\n    -   $4$条条件分支指令，每条$3$个周期。\n    -   $3$条跳转指令，每条$2$个周期。\n    -   $1$条跳转并链接指令，$3$个周期。\n-   指令总数为 $10 + 6 + 5 + 3 + 4 + 3 + 1 = 32$，与所述的ISA大小一致。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n-   **科学性**：该问题是计算机组成与体系结构中的一个标准练习，涉及为多周期数据通路设计微程序控制器。所有概念，如独热编码、控制存储器和多周期执行，都是该领域的基础。其设置在科学和技术上是合理的。\n-   **良构性**：该问题提供了一套完整且一致的规范，可以唯一地确定控制存储器的宽度、深度和总大小。任务定义清晰，可以从给定的条件中推导出唯一的解决方案。\n-   **客观性**：该问题以精确的技术语言陈述，没有主观性或歧义。编码方案和数据通路组件都得到了明确的定义。\n-   **完整性**：提供了所有必要的信息。每个多路选择器的选项数量、编码方案、所有控制信号的列表，以及带有周期计数的指令分解都已明确给出。除了作为设计基础明确提供的假设外，该问题不需要任何外部信息或未说明的假设。“不共享”微码序列的假设虽然是一种简化，但已明确说明，并使问题易于处理。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。这是一个定义明确、自成体系且科学合理的计算机体系结构问题。可以继续进行求解过程。\n\n### 求解推导\n\n解决方案通过按顺序完成三个任务来推导：计算微指令宽度、控制存储器深度，最后是它们的乘积。\n\n**任务 1 和 2：控制存储器宽度和深度**\n\n首先，确定控制存储器的宽度，它等于单个微指令的宽度。问题规定微指令字的比特位直接门控数据通路控制信号。总宽度是每个控制字段所需比特数的总和。\n\n-   $\\mathrm{IorD}$（2路MUX，独热）：$2$ 位\n-   $\\mathrm{ALUSrcA}$（2路MUX，独热）：$2$ 位\n-   $\\mathrm{ALUSrcB}$（4路MUX，独热）：$4$ 位\n-   $\\mathrm{PCSource}$（3路MUX，独热）：$3$ 位\n-   $\\mathrm{RegDst}$（3路MUX，独热）：$3$ 位\n-   $\\mathrm{MemtoReg}$（3路MUX，独热）：$3$ 位\n-   $\\mathrm{ALUOp}$（8个功能，独热）：$8$ 位\n-   $\\mathrm{ExtOp}$（2路MUX，独热）：$2$ 位\n-   选通信号（$10$个独立信号）：$10 \\times 1 = 10$ 位\n\n微指令的总宽度 $W$ 是这些位宽的总和：\n$$W = 2 + 2 + 4 + 3 + 3 + 3 + 8 + 2 + 10 = 37 \\text{ bits}$$\n\n接下来，确定控制存储器的深度。深度是唯一微指令的总数。问题规定了“一种简单的微程序组织，其中每条指令都有其自己的微序列，包括其取指和译码步骤（没有子程序共享或压缩）。”这意味着状态（微指令）的总数是ISA中每条指令的周期数之和。\n\n-   寄存器型ALU指令：$10 \\text{ 条指令} \\times 4 \\text{ 周期/指令} = 40$ 条微指令。\n-   立即数型ALU指令：$6 \\text{ 条指令} \\times 3 \\text{ 周期/指令} = 18$ 条微指令。\n-   加载指令：$5 \\text{ 条指令} \\times 5 \\text{ 周期/指令} = 25$ 条微指令。\n-   存储指令：$3 \\text{ 条指令} \\times 4 \\text{ 周期/指令} = 12$ 条微指令。\n-   条件分支指令：$4 \\text{ 条指令} \\times 3 \\text{ 周期/指令} = 12$ 条微指令。\n-   跳转指令：$3 \\text{ 条指令} \\times 2 \\text{ 周期/指令} = 6$ 条微指令。\n-   跳转并链接指令：$1 \\text{ 条指令} \\times 3 \\text{ 周期/指令} = 3$ 条微指令。\n\n控制存储器的总深度 $D$ 是这些微指令数量的总和：\n$$D = 40 + 18 + 25 + 12 + 12 + 6 + 3 = 116 \\text{ microinstructions}$$\n\n**任务 3：控制存储器总大小**\n\n控制存储器中的总比特数是其宽度（$W$）和深度（$D$）的乘积。\n\n$$ \\text{Total Size} = W \\times D $$\n$$ \\text{Total Size} = 37 \\text{ bits} \\times 116 $$\n$$ \\text{Total Size} = 4292 \\text{ bits} $$\n\n因此，控制存储器总共需要 $4292$ 比特。\n微指令格式由用于`IorD`（$2$位）、`ALUSrcA`（$2$位）、`ALUSrcB`（$4$位）、`PCSource`（$3$位）、`RegDst`（$3$位）、`MemtoReg`（$3$位）、`ALUOp`（$8$位）、`ExtOp`（$2$位）的字段和$10$个选通位组成，总宽度为$37$位。控制存储器深度为$116$条微指令。总大小是这两个值的乘积。", "answer": "$$ \\boxed{4292} $$", "id": "3660292"}, {"introduction": "循环是所有计算中最基本的控制流结构之一，在微程序层面也不例外。这些微循环是由更原始的微指令构建的。本练习 [@problem_id:3659426] 深入探讨了一种常见的循环控制原语（“减一并分支”）的性能，您将分析硬件参数（如计数器宽度 $c$）和流水线行为（如分支罚时 $p$）如何共同影响微循环的执行效率与开销。", "problem": "一个微程序控制器 (MCU) 实现了一种称为“减一非零则分支”（decrement-and-branch-if-not-zero）的单周期循环原语，记为 DBNZ。该 MCU 有一个宽度为 $c$ 位的专用循环计数器寄存器，用于存储一个无符号整数。DBNZ 微指令在循环底部执行时具有以下语义：它将循环计数器减 $1$，将结果写回同一个 $c$ 位寄存器，并且当且仅当减一后的值不等于 $0$ 时，将控制权转移到一个指定的目标微地址；否则，控制权将顺序执行到下一个连续的微地址。在稳态下，该 MCU 每个微周期执行一条微指令（每条微指令一个微周期）。一次发生跳转的微分支（即下一个微地址不是顺序后继地址），会因控制存储器流水线重新填充而产生 $p$ 个额外微周期的固定分支惩罚。顺序执行（即执行顺序后继指令）不产生分支惩罚。假设 $p \\ge 0$ 是一个整数，并且 DBNZ 微指令本身总是恰好占用 $1$ 个微周期。循环体由一系列微指令组成，这些微指令不影响循环计数器，并且除了由 DBNZ 控制的循环返回边之外，不包含任何其他分支。\n\n循环计数器由微码初始化为某个非零值 $N$，然后循环一直执行，直到 DBNZ 指令顺序执行（即不发生分支跳转）为止。请仅使用关于 $c$ 位无符号表示法的基本定义和所述的执行语义来推导以下量：\n\n1) 该循环原语所支持的最大循环迭代次数，表示为 $c$ 的函数。\n\n2) 每次迭代的平均循环控制开销，以微周期为单位。该开销定义为：在循环计数器初始化为其可表示的最大非零值的特定情况下，整个循环执行过程中花在 DBNZ 微指令及其相关分支惩罚上的总微周期数，除以总迭代次数。\n\n请将你的最终答案表示为两个关于 $c$ 和 $p$ 的闭式表达式，不带单位。最终答案中不要提供中间步骤。不需要进行数值取整。", "solution": "在进行求解之前，需要对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- 一个微程序控制器 (MCU) 具有“减一非零则分支”(DBNZ) 微指令。\n- 有一个宽度为 $c$ 位的专用循环计数器寄存器，用于存储一个无符号整数。\n- DBNZ 语义：\n    1. 将循环计数器减 $1$。\n    2. 将结果写回寄存器。\n    3. 如果减一后的值不为 $0$，则将控制权转移到目标微地址（发生分支跳转）。\n    4. 如果减一后的值等于 $0$，则控制权顺序执行到下一个连续的微地址。\n- 每条微指令在一个微周期内执行。\n- 一次发生跳转的微分支会产生 $p$ 个额外微周期的惩罚。\n- 顺序执行不产生分支惩罚（$0$ 个额外微周期）。\n- DBNZ 微指令本身需要 $1$ 个微周期。\n- $p$ 是一个整数，且 $p \\ge 0$。\n- 循环计数器被初始化为一个非零值 $N$。\n- 循环执行直到 DBNZ 顺序执行。\n- 循环体不包含其他分支。\n- 待求量：\n    1. 最大循环迭代次数，作为 $c$ 的函数。\n    2. 每次迭代的平均循环控制开销（定义为 DBNZ 及其惩罚的总微周期数除以总迭代次数），在计数器初始化为最大可表示非零值的情况下，作为 $c$ 和 $p$ 的函数。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n\n- **科学基础**：该问题基于计算机组成与体系结构的基本原理。微程序控制、指令语义、循环计数器、分支惩罚和无符号整数运算等概念在该领域是标准且成熟的。\n- **适定性**：该问题是适定的。给定的条件充分且一致，待求的量定义清晰，可以通过逻辑推导得出一个唯一且有意义的解。\n- **客观性**：该问题使用计算机工程领域常见的精确、客观的语言进行陈述。它不含主观或模棱两可的说法。\n- **其他缺陷**：该问题没有表现出任何列出的缺陷，如不完整、矛盾、不切实际、结构不良或过于简单。\n\n### 步骤 3：结论与行动\n问题被判定为**有效**。将制定一个合理的解决方案。\n\n### 解题推导\n\n这个问题要求分析微程序控制器中的一种循环控制机制。我们根据 DBNZ 指令的指定语义和无符号整数表示的属性来推导所要求的两个量。\n\n**1) 最大循环迭代次数**\n\n循环计数器是一个 $c$ 位的无符号整数寄存器。这样一个寄存器可以存储的值的范围是从 $0$ 到 $2^c - 1$。可表示的值的总数是 $2^c$。\n\nDBNZ 指令的行为是关键。由 DBNZ 控制的循环将一直执行，只要满足分支条件（减一后的值不等于 $0$）。当条件为假时，即减一后的值为 $0$ 时，循环终止。这种情况发生在 DBNZ 指令执行前计数器中的值为 $1$ 时。减法操作将该值变为 $0$，导致顺序执行。\n\n设循环计数器初始化为一个非零值 $N$。循环将按以下方式进行：\n- **迭代 1**：执行循环体。在末尾，执行 DBNZ。计数器值原为 $N$，递减为 $N-1$。如果 $N  1$，则 $N-1 \\neq 0$，分支发生跳转。\n- **迭代 2**：执行循环体。在末尾，执行 DBNZ。计数器值原为 $N-1$，递减为 $N-2$。如果 $N  2$，则 $N-2 \\neq 0$，分支发生跳转。\n- ...\n- **迭代 $N-1$**：执行循环体。在末尾，执行 DBNZ。计数器值原为 $2$，递减为 $1$。因为 $1 \\neq 0$，分支发生跳转。\n- **迭代 $N$**：执行循环体。在末尾，执行 DBNZ。计数器值原为 $1$，递减为 $0$。因为减一后的值为 $0$，分支不发生跳转（顺序执行），循环终止。\n\n从这个序列可以清楚地看出，如果循环计数器初始化为值 $N$，循环体将恰好执行 $N$ 次。因此，迭代次数等于计数器的初始值 $N$。\n\n为了找到最大循环迭代次数，我们必须找到计数器的最大有效初始值。问题陈述中指出，计数器被初始化为一个*非零*值。一个 $c$ 位无符号寄存器可以存储的最大值是 $2^c - 1$。对于任何 $c \\ge 1$，这个值都是非零的。因此，最大循环迭代次数对应于将初始计数器值 $N$ 设置为其最大值 $N_{max}$。\n\n最大迭代次数 = $N_{max} = 2^c - 1$。\n\n**2) 每次迭代的平均循环控制开销**\n\n问题的这一部分涉及循环计数器被初始化为其可表示的最大非零值的特定情况，我们已经发现该值为 $N = 2^c - 1$。因此，总迭代次数为 $N = 2^c - 1$。\n\n循环控制开销定义为花在 DBNZ 微指令及其相关分支惩罚上的总微周期数。每次迭代的平均开销是这个总成本除以总迭代次数。\n\nDBNZ 指令在每次迭代中执行一次，总共执行 $N$ 次。我们必须计算这 $N$ 次执行的总成本。\n- 一条 DBNZ 微指令的基本成本是 $1$ 个微周期。\n- 一次发生跳转的分支会增加 $p$ 个微周期的惩罚，因此该次执行的总成本为 $1+p$。\n- 一次顺序执行不增加惩罚，因此该次执行的总成本为 $1+0=1$。\n\n根据第 1 部分的分析，一个运行 $N$ 次迭代的循环包含 $N-1$ 次发生跳转的分支和 $1$ 次最终的顺序执行。\n- 发生跳转的分支次数 = $N - 1$。\n- 顺序执行次数 = $1$。\n\n循环控制的总微周期成本 $C_{total}$ 是所有 DBNZ 执行成本的总和：\n$$C_{total} = (\\text{Number of taken branches} \\times \\text{Cost per taken branch}) + (\\text{Number of fall-throughs} \\times \\text{Cost per fall-through})$$\n$$C_{total} = (N - 1)(1 + p) + (1)(1)$$\n\n每次迭代的平均循环控制开销 $O_{avg}$ 是这个总成本除以总迭代次数 $N$。\n$$O_{avg} = \\frac{C_{total}}{N} = \\frac{(N - 1)(1 + p) + 1}{N}$$\n\n我们可以简化这个表达式：\n$$O_{avg} = \\frac{N(1+p) - (1+p) + 1}{N} = \\frac{N(1+p) - p}{N} = 1 + p - \\frac{p}{N}$$\n\n现在，我们代入此情况下的特定值 $N$，即 $N = 2^c - 1$。\n$$O_{avg} = 1 + p - \\frac{p}{2^c - 1}$$\n\n这就是每次迭代平均开销的最终闭式表达式，用 $c$ 和 $p$ 表示。\n\n最终答案需要两个表达式。\n1. 最大迭代次数：$2^c - 1$。\n2. 每次迭代的平均循环控制开销：$1 + p - \\frac{p}{2^c - 1}$。", "answer": "$$ \\boxed{ \\begin{pmatrix} 2^c - 1 \\\\ 1 + p - \\frac{p}{2^c - 1} \\end{pmatrix} } $$", "id": "3659426"}, {"introduction": "编写出功能正确的微代码只是第一步，而让它运行得更快则是工程师追求的艺术。本练习 [@problem_id:3659448] 引入了一种经典的优化技术——循环展开，并将其应用于微操作层面。您将面临一个典型的工程权衡：为了减少复杂指令的动态执行周期（即降低 $CPI$），我们是否愿意接受控制存储器静态容量的增加。通过这个实践，您将学会如何在性能和成本之间做出量化决策。", "problem": "一个微程序控制器实现了一条单一的复杂指令集计算机 (CISC) 机器指令，该指令使用微操作循环来复制一个固定大小的内存块。控制存储器包含一个由控制器执行的微指令序列，每条微指令恰好消耗一个处理器时钟周期。因此，该机器指令的每指令周期数 (CPI) 等于该指令运行一次动态执行的微指令总数。此微代码的静态控制存储器大小等于微指令字长乘以存储的微指令数量。\n\n考虑以下基于循环的微代码实现的基准：\n- 微指令字长为 $w = 64$ 位。\n- 循环体每次迭代执行 $p = 5$ 条微指令，用于数据移动和地址更新工作。\n- 每次迭代的循环控制开销（计数器递减、测试和分支）为 $h = 3$ 条微指令。\n- 循环前的固定设置开销为 $s = 12$ 条微指令，循环后的固定拆卸开销为 $f = 8$ 条微指令。\n- 完成块移动所需的总迭代次数为 $T = 240$。\n\n为了减少动态循环控制开销，微操作循环以因子 $u$ 进行展开，这意味着循环体的 $u$ 个副本在控制存储器中连续排列，并且每次循环控制检查执行一次。在这种展开下：\n- 每 $u$ 个连续的循环体副本产生一次循环控制开销 $h$。\n- 展开后循环组的静态代码大小等于 $u$ 个复制的循环体副本加上一组循环控制微指令。\n\n假设该指令的微代码必须适应专用的控制存储器预算 $M_{\\max} = 64 \\times 83$ 位。展开因子 $u$ 必须是一个正整数，并且必须能整除 $T$，以便循环执行整数个展开组而没有剩余迭代。\n\n从上述定义和每微指令单周期的模型出发，推导执行一次该指令的动态微指令计数 $D(u)$ 和静态控制存储器大小 $M(u)$（以位为单位）。然后，在约束条件 $M(u) \\leq M_{\\max}$ 和 $u \\mid T$ 下，选择最小化 $D(u)$ 的 $u$ 值，并计算：\n- 所选的展开因子 $u$，\n- 指令的最终CPI（等于$D(u)$），\n- 最终的控制存储器大小 $M(u)$。\n\n以位为单位表示控制存储器大小。无需四舍五入。按 $u$、CPI 和控制存储器大小 $M(u)$ 的顺序提供最终答案的三个值。", "solution": "该问题提法明确，科学上基于计算机体系结构原理，并包含获得唯一解所需的所有信息。因此，它是有效的。\n\n目标是找到最佳的循环展开因子 $u$，以最小化块移动指令的动态微指令计数 $D(u)$，同时满足对静态控制存储器大小 $M(u)$ 和 $u$ 自身属性的约束。\n\n首先，我们推导动态微指令计数 $D(u)$ 和静态控制存储器大小 $M(u)$ 的表达式。\n\n动态微指令计数等价于每指令周期数 (CPI)，是用于设置、循环执行和拆卸的微指令之和。\n给定的参数是：\n- 设置开销：$s = 12$ 条微指令\n- 拆卸开销：$f = 8$ 条微指令\n- 原始总迭代次数：$T = 240$\n- 每个循环体的微操作数：$p = 5$\n- 循环控制的微操作数：$h = 3$\n- 展开因子：$u$\n\n动态微指令总数 $D(u)$ 由以下公式给出：\n$$D(u) = s + (\\text{循环执行}) + f$$\n循环以因子 $u$ 展开。这意味着循环体被复制 $u$ 次，而循环控制逻辑（递减、测试、分支）每 $u$ 次数据移动仅执行一次。由于数据移动总数为 $T$，展开的循环组执行的次数为 $\\frac{T}{u}$。每次执行展开的循环组包含 $u$ 个循环体工作的副本和一次循环控制开销。\n一个展开循环组的微指令数为 $(u \\cdot p + h)$。\n因此，循环执行部分的总微指令数为：\n$$(\\text{循环执行}) = \\left(\\frac{T}{u}\\right) \\cdot (u \\cdot p + h)$$\n展开此项，我们得到：\n$$(\\text{循环执行}) = \\frac{T}{u} \\cdot u \\cdot p + \\frac{T \\cdot h}{u} = T \\cdot p + \\frac{T \\cdot h}{u}$$\n将此代入 $D(u)$ 的表达式：\n$$D(u) = s + f + T \\cdot p + \\frac{T \\cdot h}{u}$$\n为了最小化 $D(u)$，我们观察到 $s$、$f$、$T$、$p$ 和 $h$ 都是正常数。项 $(s + f + T \\cdot p)$ 相对于 $u$ 是一个常数。因此，最小化 $D(u)$ 等价于最小化项 $\\frac{T \\cdot h}{u}$，这要求最大化展开因子 $u$。\n\n接下来，我们推导静态控制存储器大小 $M(u)$ 的表达式。该大小是静态微指令总数乘以字宽 $w = 64$ 位。整条指令的静态微代码包括设置代码、单个展开的循环体和拆卸代码。\n静态微指令的数量是以下各项的总和：\n- 设置微指令：$s$\n- 展开的循环微指令：$u \\cdot p + h$\n- 拆卸微指令：$f$\n静态微指令总数 = $s + f + u \\cdot p + h$。\n静态控制存储器大小 $M(u)$（以位为单位）为：\n$$M(u) = w \\cdot (s + f + u \\cdot p + h)$$\n这是 $u$ 的一个线性函数。\n\n问题对 $u$ 规定了两个约束条件：\n1. $u$ 必须是能整除总迭代次数 $T=240$ 的正整数。所以，$u \\in \\{1, 2, 3, 4, 5, 6, 8, 10, 12, 15, 16, 20, 24, 30, 40, 48, 60, 80, 120, 240\\}$。\n2. 静态控制存储器大小 $M(u)$ 不得超过预算 $M_{\\max} = 64 \\times 83$ 位。\n$$M(u) \\leq M_{\\max}$$\n$$w \\cdot (s + f + u \\cdot p + h) \\leq M_{\\max}$$\n我们代入给定值：$w=64$, $s=12$, $f=8$, $p=5$, $h=3$ 以及 $M_{\\max} = 64 \\times 83 = 5312$。\n$$64 \\cdot (12 + 8 + u \\cdot 5 + 3) \\leq 5312$$\n$$64 \\cdot (23 + 5u) \\leq 5312$$\n两边同除以 $64$：\n$$23 + 5u \\leq 83$$\n$$5u \\leq 83 - 23$$\n$$5u \\leq 60$$\n$$u \\leq 12$$\n\n为了最小化 $D(u)$，我们必须找到满足两个约束条件的最大可能 $u$ 值：\n1. $u$ 是 $240$ 的因子。\n2. $u \\leq 12$。\n\n在 $240$ 的因子列表中，小于或等于 $12$ 的最大值是 $u=12$。\n因此，选择的展开因子是 $u = 12$。\n\n现在我们计算当 $u=12$ 时的最终 CPI ($D(u)$) 和控制存储器大小 ($M(u)$)。\n\nCPI 为 $D(12)$：\n$$D(u) = s + f + T \\cdot p + \\frac{T \\cdot h}{u}$$\n$$D(12) = 12 + 8 + 240 \\cdot 5 + \\frac{240 \\cdot 3}{12}$$\n$$D(12) = 20 + 1200 + \\frac{720}{12}$$\n$$D(12) = 1220 + 60 = 1280$$\n最终的 CPI 是 $1280$。\n\n控制存储器大小为 $M(12)$：\n$$M(u) = w \\cdot (s + f + u \\cdot p + h)$$\n$$M(12) = 64 \\cdot (12 + 8 + 12 \\cdot 5 + 3)$$\n$$M(12) = 64 \\cdot (20 + 60 + 3)$$\n$$M(12) = 64 \\cdot (83)$$\n$$M(12) = 5312$$\n最终的控制存储器大小是 $5312$ 位。\n\n要求的三个值是展开因子 $u$、CPI 和控制存储器大小 $M(u)$。\n- 所选展开因子 $u = 12$。\n- 指令的最终 CPI $D(12) = 1280$。\n- 最终的控制存储器大小 $M(12) = 5312$ 位。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n12  1280  5312\n\\end{pmatrix}\n}\n$$", "id": "3659448"}]}