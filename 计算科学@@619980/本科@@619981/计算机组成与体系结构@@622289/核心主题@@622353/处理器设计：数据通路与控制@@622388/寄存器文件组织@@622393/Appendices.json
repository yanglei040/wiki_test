{"hands_on_practices": [{"introduction": "处理器设计需要在性能（例如每周期发射多条指令）与硬件成本及复杂性之间取得平衡。寄存器堆是体现这一权衡的核心部件。本练习让你通过计算单发射与双发射配置下的端口需求，具体量化地理解这一核心设计权衡。你将学习到架构决策如何直接转化为硬件规格，以及巧妙的指令调度策略又如何能帮助我们降低硬件成本。", "problem": "一个处理器拥有一个中央寄存器文件 (RF)，该文件具有 $P_r$ 个读端口和 $P_w$ 个写端口。每条指令在单个操作数获取阶段访问 RF：已发射指令的所有源寄存器在该阶段被并发读取，结果在单个写回阶段被写入。假设功能单元具有固定延迟，因此任何写入其目标寄存器的指令都会在发射后恰好 $1$ 个周期执行写回操作。该核心可配置为单发射（发射宽度为 $1$）或双发射（发射宽度为 $2$）。\n\n考虑一个包含两类指令的指令集：\n- 算术逻辑单元 (ALU) 的寄存器-寄存器操作，记为 $\\mathcal{A}$ 类，每条指令读取 $2$ 个源寄存器并写入 $1$ 个目标寄存器。\n- 加载操作，记为 $\\mathcal{L}$ 类，每条指令读取 $1$ 个基址寄存器并写入 $1$ 个目标寄存器（假设地址形成使用一个基址寄存器加一个立即数，并且内存在最小的缓存中命中，因此写回以固定的 $1$ 周期延迟发生）。\n\n要执行的代码片段恰好包含 $4$ 个 $\\mathcal{A}$ 类的实例和 $4$ 个 $\\mathcal{L}$ 类的实例，它们之间没有数据依赖关系会禁止类间的任意重排序（忽略控制冒险；所有分支都已解决且不在此片段中）。在双发射模式下，处理器每周期最多可发射 $2$ 条指令；在单发射模式下，每周期最多可发射 $1$ 条指令。\n\n仅使用 RF 端口的核心定义和上面给出的每条指令的操作数计数，并将端口需求视为保证不发生停顿而继续执行所需的每周期最大并发 RF 访问次数：\n1. 推导单发射核心在最坏情况下的每周期需求下的最小 RF 端口要求 $(P_r, P_w)$。\n2. 如果在一个周期内发射的两条指令在类别上不受约束（即，来自 $\\{\\mathcal{A}, \\mathcal{L}\\}$ 的任意一对都可以一起发射），推导双发射核心的最小 RF 端口要求 $(P_r, P_w)$。\n3. 为此代码片段提出一种双发射调度策略，与不受约束的双发射情况相比，该策略能将所需的 RF 端口数减少 $1$ 个，同时仍能每周期发射 $2$ 条指令，并计算在该策略下 RF 端口的最小总数 $P_r + P_w$。\n\n将最终答案表示为一个整数，等于您提出的调度策略下的最小 $P_r + P_w$ 值。无需四舍五入，也无物理单位。", "solution": "问题要求计算在不同发射宽度配置和调度策略下，处理器所需的最小寄存器文件 (RF) 端口数。端口需求定义为在任何单个周期内，为保证无停顿执行所需的最大并发 RF 访问次数。分析分为三个部分。\n\n设 $R(\\mathcal{I})$ 为 $\\mathcal{I}$ 类指令读取的源寄存器数量， $W(\\mathcal{I})$ 为 $\\mathcal{I}$ 类指令写入的目标寄存器数量。\n根据题目描述：\n- 对于 $\\mathcal{A}$ 类 (ALU): $R(\\mathcal{A}) = 2$, $W(\\mathcal{A}) = 1$。\n- 对于 $\\mathcal{L}$ 类 (加载): $R(\\mathcal{L}) = 1$, $W(\\mathcal{L}) = 1$。\n\n处理器的流水线有一个关键的时序特性：在周期 $t$ 发射的指令在周期 $t$ 读取其源操作数，并在周期 $t+1$ 写入其结果。\n最小读端口数 $P_r$ 是在任何单个周期内读取的最大寄存器数量。这由正在*发射*的指令决定。\n最小写端口数 $P_w$ 是在任何单个周期内写入的最大寄存器数量。这由正在*写回*的指令决定，这些指令是在前一个周期发射的。\n\n第一部分：单发射核心\n单发射核心每周期最多可以发射 $1$ 条指令。\n为了找到最坏情况下的读端口需求，我们必须考虑读取寄存器数量最多的指令类别。\n- 发射一条 $\\mathcal{A}$ 指令需要 $R(\\mathcal{A}) = 2$ 个读端口。\n- 发射一条 $\\mathcal{L}$ 指令需要 $R(\\mathcal{L}) = 1$ 个读端口。\n在任何发射周期中，对读端口的最大需求是 $\\max(R(\\mathcal{A}), R(\\mathcal{L})) = \\max(2, 1) = 2$。\n因此，最小读端口数为 $P_r = 2$。\n\n为了找到写端口需求，我们考虑写回阶段。由于每周期最多发射 $1$ 条指令，所以在任何后续周期中，最多只有 $1$ 条指令处于其写回阶段。两种指令类别都写入 $1$ 个寄存器。\n因此，在任何写回周期中，对写端口的最大需求是 $1$。\n因此，最小写端口数为 $P_w = 1$。\n对于单发射核心，最小端口要求是 $(P_r, P_w) = (2, 1)$。\n\n第二部分：双发射核心（不受约束）\n双发射核心每周期最多可以发射 $2$ 条指令。在不受约束的调度下，任何一对指令都可以并发发射。\n为了找到最坏情况下的读端口需求，我们必须考虑同时发射时需要最多读取操作的指令对。可能的指令对是 $(\\mathcal{A}, \\mathcal{A})$、$(\\mathcal{A}, \\mathcal{L})$ 和 $(\\mathcal{L}, \\mathcal{L})$。\n- 发射 $(\\mathcal{A}, \\mathcal{A})$：总读端口数 = $R(\\mathcal{A}) + R(\\mathcal{A}) = 2 + 2 = 4$。\n- 发射 $(\\mathcal{A}, \\mathcal{L})$：总读端口数 = $R(\\mathcal{A}) + R(\\mathcal{L}) = 2 + 1 = 3$。\n- 发射 $(\\mathcal{L}, \\mathcal{L})$：总读端口数 = $R(\\mathcal{L}) + R(\\mathcal{L}) = 1 + 1 = 2$。\n读端口的最大需求是由发射两条 $\\mathcal{A}$ 指令驱动的，需要 $4$ 个读端口。\n因此，最小读端口数为 $P_r = 4$。\n\n对于写端口需求，由于在周期 $t$ 最多可以发射 $2$ 条指令，这两条指令都将尝试在周期 $t+1$ 写回其结果。每条指令写入 $1$ 个寄存器。\n因此，对写端口的最大需求是 $1 + 1 = 2$。\n因此，最小写端口数为 $P_w = 2$。\n对于不受约束的双发射核心，最小端口要求是 $(P_r, P_w) = (4, 2)$。端口总数为 $P_r + P_w = 4 + 2 = 6$。\n\n第三部分：双发射核心（受约束的策略）\n目标是提出一种双发射调度策略，与不受约束的情况相比，该策略能将 RF 端口总数减少 $1$ 个（即从 $6$ 个减少到 $5$ 个），同时对于给定的代码片段（包含 $4$ 个 $\\mathcal{A}$ 实例和 $4$ 个 $\\mathcal{L}$ 实例）仍能每周期发射 $2$ 条指令。\n\n不受约束的需求是 $(P_r, P_w) = (4, 2)$。要将端口总数减少到 $5$，我们必须减少 $P_r$ 或 $P_w$。\n- 将 $P_w$ 减少到 $1$：这意味着在任何周期内，最多只有一条指令可以处于写回阶段。由于周期 $t+1$ 的写回对应于周期 $t$ 的发射，这将限制处理器每周期只能发射 $1$ 条指令，违反了保持双发射率的条件。因此，$P_w$ 必须保持为 $2$。\n- 将 $P_r$ 减少到 $3$：$P_r = 4$ 的峰值需求仅在同一周期内发射两条 $\\mathcal{A}$ 指令时出现。如果我们禁止这种特定的配对，最大读端口需求将会降低。\n\n提出的调度策略：在任何给定的周期内，处理器最多可以发射一条 $\\mathcal{A}$ 类的指令。\n该策略禁止了 $(\\mathcal{A}, \\mathcal{A})$ 发射对。我们必须验证该策略对于由 $4$ 条 $\\mathcal{A}$ 指令和 $4$ 条 $\\mathcal{L}$ 指令组成的代码片段，仍然能够维持每周期 $2$ 条指令的发射率。我们可以通过在每个周期将一条 $\\mathcal{A}$ 指令与一条 $\\mathcal{L}$ 指令配对，将执行安排在 $4$ 个周期内：\n- 周期 1：发射 $(\\mathcal{A}_1, \\mathcal{L}_1)$\n- 周期 2：发射 $(\\mathcal{A}_2, \\mathcal{L}_2)$\n- 周期 3：发射 $(\\mathcal{A}_3, \\mathcal{L}_3)$\n- 周期 4：发射 $(\\mathcal{A}_4, \\mathcal{L}_4)$\n此调度在 $4$ 个周期内成功完成了代码片段，保持了每周期平均发射 $2$ 条指令的速率。因此，该策略是有效且可行的。\n\n现在，我们计算在这种新的受约束策略下的最小端口需求。\n产生最大需求的允许发射对是 $(\\mathcal{A}, \\mathcal{L})$ 和 $(\\mathcal{L}, \\mathcal{L})$。\n- 发射 $(\\mathcal{A}, \\mathcal{L})$：总读端口数 = $R(\\mathcal{A}) + R(\\mathcal{L}) = 2 + 1 = 3$。\n- 发射 $(\\mathcal{L}, \\mathcal{L})$：总读端口数 = $R(\\mathcal{L}) + R(\\mathcal{L}) = 1 + 1 = 2$。\n对读端口的新的最大需求是 $3$。\n因此，在该策略下，最小读端口数为 $P_r = 3$。\n\n写端口需求不变，因为我们仍然每周期发射 $2$ 条指令，这将导致在下一个周期有 $2$ 次并发写回。\n因此，最小写端口数仍为 $P_w = 2$。\n\n在所提出的策略下，最小端口要求是 $(P_r, P_w) = (3, 2)$。\n所需的 RF 端口总数为 $P_r + P_w = 3 + 2 = 5$。\n与不受约束情况下的总数 $6$ 相比，这减少了 $1$ 个端口，满足了问题的条件。在所提出的调度下，RF 端口的最小总数是 $5$。", "answer": "$$\\boxed{5}$$", "id": "3672090"}, {"introduction": "确定了寄存器堆的逻辑需求（如端口数量）后，我们必须确保它能在处理器的时钟周期内正确工作。本练习将带你深入分析一个高性能寄存器堆所面临的现实物理约束。通过计算允许的最大寄存器访问时间 $t_{\\text{RF}}$，你将亲身体会到时钟抖动、建立时间等物理现实如何限制设计，并决定一些高级微架构技术（如在单个周期内解决数据依赖）是否可行。", "problem": "一个同步流水线使用单周期寄存器文件 (RF)，以支持无需旁路即可执行的背靠背写后读 (RAW) 相关操作。该 RF 的结构设计为在每个时钟周期的前半部分执行写操作，在同一时钟周期的后半部分执行读操作。假设时钟的占空比为 $50\\%$，且存在占空比失真和时钟不确定性。写数据在上升沿从写回流水线寄存器发出，读数据在下一个上升沿被译码级输入寄存器捕获。\n\n使用以下参数：\n- 时钟周期 $T_{\\text{clk}} = 1.2\\,\\text{ns}$。\n- 最坏情况下的占空比失真幅值 $\\varepsilon = 0.08\\,\\text{ns}$，使得较短半周期的持续时间为 $T_{\\text{clk}}/2 - \\varepsilon$。\n- 总时钟不确定性（偏移加抖动）$u = 0.03\\,\\text{ns}$，需从任何半周期预算中减去。\n- 在半周期边界处的保护时间 $\\gamma = 0.015\\,\\text{ns}$，用以避免在写操作完成期间进行采样。\n- 写回寄存器的时钟到Q端延迟 $t_{\\text{cq}} = 0.07\\,\\text{ns}$。\n- RF 阵列之前的非 RF 写路径驱动器和外围延迟 $t_{\\text{wdrv}} = 0.04\\,\\text{ns}$。\n- RF 阵列之后的非 RF 读路径驱动器和外围延迟 $t_{\\text{rdrv}} = 0.05\\,\\text{ns}$。\n- 译码级输入寄存器的建立时间 $t_{\\text{setup}} = 0.04\\,\\text{ns}$。\n\n假设固有 RF 访问时间 $t_{\\text{RF}}$ 对于写和读是对称的，并定义为从 RF 阵列边界处的稳定输入（写操作的地址和数据，读操作的地址）到相应的稳定效应（单元被写入或读数据在 RF 边界处有效）之间的时间。\n\n仅从建立约束的基本同步时序定义以及任何时序预算都必须使用最坏情况下的半周期（由于占空比失真导致的较短半周期）减去不确定性和保护时间这一概念出发，推导出最大允许的 $t_{\\text{RF}}$，以保证相关指令可以在同一周期内（前半周期写，后半周期读）无需转发就能读取先前写入的值。将最终答案表示为以皮秒为单位的实数，并四舍五入到三位有效数字。", "solution": "该问题要求确定一个具有特殊 RF 结构的同步流水线中最大允许的固有寄存器文件 (RF) 访问时间，记为 $t_{\\text{RF}}$。这种结构允许一条相关指令在时钟周期的后半部分读取同一周期前半部分写入的值，从而避免了为解决写后读 (RAW) 冒险而需要数据转发逻辑。\n\n分析的关键在于满足两条不同路径的建立时序约束，这两条路径都受半周期时序预算的限制：前半周期的写路径和后半周期的读路径。问题为计算时序预算提供了一个明确的方法。\n\n首先，我们定义必须在单个半周期内完成的操作的可用时序预算。总时钟周期为 $T_{\\text{clk}} = 1.2\\,\\text{ns}$。半周期的标称持续时间为 $T_{\\text{clk}}/2 = 0.6\\,\\text{ns}$。然而，时钟存在幅值为 $\\varepsilon = 0.08\\,\\text{ns}$ 的占空比失真。这意味着半周期的持续时间可能会变化。最坏情况（最短）的半周期持续时间由下式给出：\n$$T_{\\text{short}} = \\frac{T_{\\text{clk}}}{2} - \\varepsilon$$\n问题明确指出，“任何时序预算都必须使用最坏情况下的半周期（由于占空比失真导致的较短半周期）减去不确定性和保护时间”。总时钟不确定性为 $u = 0.03\\,\\text{ns}$，保护时间为 $\\gamma = 0.015\\,\\text{ns}$。因此，对于任何必须在半周期内执行的路径，其有效时序预算 $T_{\\text{budget}}$ 为：\n$$T_{\\text{budget}} = T_{\\text{short}} - u - \\gamma = \\left(\\frac{T_{\\text{clk}}}{2} - \\varepsilon\\right) - u - \\gamma$$\n代入给定值：\n$$T_{\\text{budget}} = \\left(\\frac{1.2\\,\\text{ns}}{2} - 0.08\\,\\text{ns}\\right) - 0.03\\,\\text{ns} - 0.015\\,\\text{ns}$$\n$$T_{\\text{budget}} = (0.6 - 0.08)\\,\\text{ns} - 0.03\\,\\text{ns} - 0.015\\,\\text{ns}$$\n$$T_{\\text{budget}} = 0.52\\,\\text{ns} - 0.03\\,\\text{ns} - 0.015\\,\\text{ns} = 0.475\\,\\text{ns}$$\n该预算代表了在最坏情况下，信号在一个半周期内传播并被正确处理的最大可用时间。我们现在将此预算应用于写路径和读路径的约束。\n\n**1. 写路径约束**\n写操作发生在时钟周期的前半部分。数据在上升沿从写回流水线寄存器发出。写路径的总延迟 $T_{\\text{write}}$ 包括该寄存器的时钟到Q端延迟 ($t_{\\text{cq}}$)、通过非 RF 写路径逻辑的延迟 ($t_{\\text{wdrv}}$) 和固有 RF 写入时间 ($t_{\\text{RF}}$)。整个操作必须在计算出的预算时间内完成。\n$$T_{\\text{write}} = t_{\\text{cq}} + t_{\\text{wdrv}} + t_{\\text{RF}}$$\n时序约束为：\n$$T_{\\text{write}} \\le T_{\\text{budget}}$$\n$$t_{\\text{cq}} + t_{\\text{wdrv}} + t_{\\text{RF}} \\le T_{\\text{budget}}$$\n我们可以从这个不等式中解出 $t_{\\text{RF}}$ 的一个上界：\n$$t_{\\text{RF}} \\le T_{\\text{budget}} - t_{\\text{cq}} - t_{\\text{wdrv}}$$\n代入数值：\n$$t_{\\text{RF}} \\le 0.475\\,\\text{ns} - 0.07\\,\\text{ns} - 0.04\\,\\text{ns}$$\n$$t_{\\text{RF}} \\le 0.475\\,\\text{ns} - 0.11\\,\\text{ns}$$\n$$t_{\\text{RF}} \\le 0.365\\,\\text{ns}$$\n\n**2. 读路径约束**\n读操作发生在时钟周期的后半部分。数据从 RF 中读出，并且必须在下一个时钟上升沿被译码级输入寄存器捕获。读路径延迟 $T_{\\text{read}}$ 是固有 RF 读取时间 ($t_{\\text{RF}}$) 和通过非 RF 读路径逻辑的延迟 ($t_{\\text{rdrv}}$) 的总和。为了成功捕获，数据必须在捕获时钟沿到达之前，在寄存器输入端稳定至少一个建立时间 $t_{\\text{setup}}$。因此，读路径延迟与建立时间的总和必须在时序预算之内。\n$$T_{\\text{read}} = t_{\\text{RF}} + t_{\\text{rdrv}}$$\n时序约束为：\n$$T_{\\text{read}} + t_{\\text{setup}} \\le T_{\\text{budget}}$$\n$$t_{\\text{RF}} + t_{\\text{rdrv}} + t_{\\text{setup}} \\le T_{\\text{budget}}$$\n从此约束中解出 $t_{\\text{RF}}$ 的上界：\n$$t_{\\text{RF}} \\le T_{\\text{budget}} - t_{\\text{rdrv}} - t_{\\text{setup}}$$\n代入数值：\n$$t_{\\text{RF}} \\le 0.475\\,\\text{ns} - 0.05\\,\\text{ns} - 0.04\\,\\text{ns}$$\n$$t_{\\text{RF}} \\le 0.475\\,\\text{ns} - 0.09\\,\\text{ns}$$\n$$t_{\\text{RF}} \\le 0.385\\,\\text{ns}$$\n\n**3. 最终确定最大 $t_{\\text{RF}}$**\n假设固有 RF 访问时间 $t_{\\text{RF}}$ 对于写操作和读操作是相同的。为了使 RF 正常工作，$t_{\\text{RF}}$ 必须同时满足写路径和读路径的约束。\n$$t_{\\text{RF}} \\le 0.365\\,\\text{ns} \\quad (\\text{来自写路径})$$\n$$t_{\\text{RF}} \\le 0.385\\,\\text{ns} \\quad (\\text{来自读路径})$$\n满足这两个条件的最大 $t_{\\text{RF}}$ 值是两个上界中的最小值。写路径是限制更强的那个。\n$$t_{\\text{RF,max}} = \\min(0.365\\,\\text{ns}, 0.385\\,\\text{ns}) = 0.365\\,\\text{ns}$$\n问题要求答案以皮秒 ($ps$) 表示，并四舍五入到三位有效数字。\n$$t_{\\text{RF,max}} = 0.365 \\times 10^{-9}\\,\\text{s} = 365 \\times 10^{-12}\\,\\text{s} = 365\\,\\text{ps}$$\n值 $365$ 有三位有效数字，因此无需进一步四舍五入。", "answer": "$$ \\boxed{365} $$", "id": "3672114"}, {"introduction": "现代乱序执行处理器使用寄存器重命名和大型物理寄存器堆（PRF）来消除伪数据依赖，从而发掘更多指令级并行性。然而，物理寄存器堆是有限资源，必须被高效管理。本练习探讨了一种通过推测性地回收物理寄存器来提升资源利用率的先进技术。通过应用条件概率和期望值等数学工具，你将量化评估一个推测性回收策略的性能影响，从而理解架构师如何基于程序的统计行为和预测错误的代价来做出设计决策。", "problem": "一个超标量乱序中央处理器 (CPU) 实现了一个使用物理寄存器文件的寄存器重命名机制。为了增加有效的空闲列表可用性，该微架构使用了一个推测性存活预测器，它可以在逻辑寄存器先前映射的值在架构上被证明是死的之前，回收绑定到该映射的物理寄存器。该预测器在重命名阶段运行：当一条定义了目标逻辑寄存器的指令到达时，该逻辑寄存器旧的物理寄存器成为推测性回收的候选者。只有当预测器宣布旧值为死时，微架构才会立即回收该候选寄存器。\n\n假设在一个长的动态执行窗口中，具有以下稳态统计数据，并且指令之间相互独立：\n- 动态指令中比例为 $f$ 的指令会产生一个目标，因此会创建一个推测性回收候选者。\n- 在预测时，一个候选旧值实际上是死的基本率为 $p_{\\text{dead}}$。\n- 存活预测器具有真阳性率 (TPR) 和假阳性率 (FPR)，定义为 $\\text{TPR} = \\mathbb{P}(\\text{预测为死} \\mid \\text{实际上是死的})$ 和 $\\text{FPR} = \\mathbb{P}(\\text{预测为死} \\mid \\text{实际上是存活的})$。\n- 如果一个被回收的值后来被一个消费者指令需要（即预测器出错，被回收的值实际上是存活的），机器会在读取时检测到此违规，并启动一次完全回滚，耗费 $R$ 个周期的无效工作。否则，与该回收事件相关的没有回滚代价。\n\n你的任务是从条件概率和 Bayes 定理的定义出发：\n1) 推导一次推测性回收操作导致违规的概率，即 $\\mathbb{P}(\\text{实际上是存活的} \\mid \\text{预测为死})$。\n2) 使用此结果计算每 $N$ 条退休指令的期望回滚周期数，其中 $N = 10^{6}$。\n\n使用以下参数值：$f = 0.55$，$p_{\\text{dead}} = 0.65$，$\\text{TPR} = 0.92$，$\\text{FPR} = 0.06$，$R = 18$ 以及 $N = 10^{6}$。将你的最终结果表示为每 $10^{6}$ 条退休指令的期望回滚周期数。将最终答案四舍五入到四位有效数字。", "solution": "让我们为一个推测性回收候选者定义以下事件：\n- $L$：旧的寄存器值实际上是存活的。\n- $D$：旧的寄存器值实际上是死的。这是 $L$ 的补集。\n- $P_D$：预测器预测旧的寄存器值为死。\n- $P_L$：预测器预测旧的寄存器值为存活。这是 $P_D$ 的补集。\n\n根据问题陈述，我们有以下给定的概率和参数：\n- 创建候选者的指令比例：$f = 0.55$。\n- 一个候选者实际上是死的基本率：$p_{\\text{dead}} = \\mathbb{P}(D) = 0.65$。\n- 真阳性率：$\\text{TPR} = \\mathbb{P}(P_D \\mid D) = 0.92$。一个“阳性”情况是指一个实际上是死的寄存器，“真阳性”意味着将其预测为死。\n- 假阳性率：$\\text{FPR} = \\mathbb{P}(P_D \\mid L) = 0.06$。一个“阴性”情况是指一个实际上是存活的寄存器，“假阳性”意味着错误地将其预测为死。\n- 回滚代价：$R = 18$ 个周期。\n- 指令总数：$N = 10^6$。\n\n一个候选者实际上是存活的概率是它是死的的补集：\n$$ \\mathbb{P}(L) = 1 - \\mathbb{P}(D) = 1 - p_{\\text{dead}} $$\n\n### 第 1 部分：违规概率的推导\n\n第一个任务是推导一次推测性回收操作导致违规的概率。当预测器宣布一个候选者为死时（事件 $P_D$），回收操作发生。如果这个预测是错误的，即该值实际上是存活的（事件 $L$），则发生违规。因此，我们必须找到条件概率 $\\mathbb{P}(L \\mid P_D)$。\n\n我们应用 Bayes 定理：\n$$ \\mathbb{P}(L \\mid P_D) = \\frac{\\mathbb{P}(P_D \\mid L) \\mathbb{P}(L)}{\\mathbb{P}(P_D)} $$\n\n为了使用这个公式，我们首先需要找到预测器宣布一个候选者为死的总概率 $\\mathbb{P}(P_D)$。我们可以使用全概率定律，以寄存器实际上是存活还是死为条件来找到这个概率：\n$$ \\mathbb{P}(P_D) = \\mathbb{P}(P_D \\mid L) \\mathbb{P}(L) + \\mathbb{P}(P_D \\mid D) \\mathbb{P}(D) $$\n\n代入给定的定义和推导出的概率：\n$$ \\mathbb{P}(P_D) = \\text{FPR} \\cdot (1 - p_{\\text{dead}}) + \\text{TPR} \\cdot p_{\\text{dead}} $$\n\n现在，我们可以将这个表达式代回到 Bayes 定理中：\n$$ \\mathbb{P}(L \\mid P_D) = \\frac{\\mathbb{P}(P_D \\mid L) \\mathbb{P}(L)}{\\mathbb{P}(P_D \\mid L) \\mathbb{P}(L) + \\mathbb{P}(P_D \\mid D) \\mathbb{P}(D)} $$\n$$ \\mathbb{P}(L \\mid P_D) = \\frac{\\text{FPR} \\cdot (1 - p_{\\text{dead}})}{\\text{FPR} \\cdot (1 - p_{\\text{dead}}) + \\text{TPR} \\cdot p_{\\text{dead}}} $$\n这是在已采取推测性回收操作的条件下，发生违规的概率的符号表达式。\n\n### 第 2 部分：期望回滚周期数的计算\n\n第二个任务是计算每 $N$ 条退休指令的期望回滚周期数。设其为 $E[C_N]$。对于一条给定的指令，只有当满足以下三个条件序列时，才会发生回滚并耗费 $R$ 个周期：\n1. 该指令创建了一个推测性回收候选者。\n2. 该候选者对应一个实际上是存活的旧寄存器值。\n3. 预测器错误地将此存活值预测为死。\n\n让我们计算在 $N$ 条指令中此类回滚事件的期望数量。\n指令总数为 $N$。\n创建回收候选者的指令的期望数量是：\n$$ E[N_{\\text{cand}}] = N \\cdot f $$\n在这些候选者中，实际上是存活的期望数量是：\n$$ E[N_{\\text{live}}] = E[N_{\\text{cand}}] \\cdot \\mathbb{P}(L) = N \\cdot f \\cdot (1 - p_{\\text{dead}}) $$\n如果预测器做出假阳性预测（预测为死），则会为这些存活的候选者之一触发回滚。此事件的概率是 $\\text{FPR} = \\mathbb{P}(P_D \\mid L)$。\n所以，在 $N$ 条指令中回滚的期望数量是：\n$$ E[N_{\\text{rollback}}] = E[N_{\\text{live}}] \\cdot \\text{FPR} = N \\cdot f \\cdot (1 - p_{\\text{dead}}) \\cdot \\text{FPR} $$\n每次回滚产生 $R$ 个周期的代价。在 $N$ 条指令上的总期望回滚代价是期望的回滚次数乘以每次回滚的代价：\n$$ E[C_N] = E[N_{\\text{rollback}}] \\cdot R = N \\cdot f \\cdot (1 - p_{\\text{dead}}) \\cdot \\text{FPR} \\cdot R $$\n\n现在，我们将给定的数值代入此表达式：\n- $N = 10^6$\n- $f = 0.55$\n- $p_{\\text{dead}} = 0.65$\n- $\\text{FPR} = 0.06$\n- $R = 18$\n\n$$ E[C_{10^6}] = 10^6 \\cdot 0.55 \\cdot (1 - 0.65) \\cdot 0.06 \\cdot 18 $$\n$$ E[C_{10^6}] = 10^6 \\cdot 0.55 \\cdot 0.35 \\cdot 0.06 \\cdot 18 $$\n让我们计算这些项的乘积：\n$$ 0.55 \\cdot 0.35 = 0.1925 $$\n$$ 0.1925 \\cdot 0.06 = 0.01155 $$\n$$ 0.01155 \\cdot 18 = 0.2079 $$\n所以，总的期望代价是：\n$$ E[C_{10^6}] = 10^6 \\cdot 0.2079 = 207900 $$\n题目要求答案四舍五入到四位有效数字。数字 $207900$ 可以用科学记数法写成 $2.079 \\times 10^5$，这已经包含了四位有效数字。", "answer": "$$\n\\boxed{2.079 \\times 10^5}\n$$", "id": "3672059"}]}