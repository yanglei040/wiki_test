{"hands_on_practices": [{"introduction": "理论学习了硬布线控制单元如何将指令解码为控制信号，现在我们将这一过程付诸实践。这个练习将指导你如何将定义控制逻辑的布尔表达式，仅使用与非门（$NAND$ gates）这种通用逻辑门来实现，这是半导体制造中的常见做法。通过这个练习，你将深入理解从抽象逻辑到具体硬件电路的转换过程，并掌握逻辑优化的基本技能。[@problem_id:3646582]", "problem": "一个简化精简指令集计算机（RISC）的硬布线控制单元，为寄存器类型指令使用一个 $4$ 位操作码字段 $\\{I_3,I_2,I_1,I_0\\}$ 和一个 $3$ 位功能字段 $\\{F_2,F_1,F_0\\}$。该控制单元的输出包括寄存器写使能信号 $\\text{RegWrite}$ 和一个单位算术逻辑单元（ALU）操作选择信号 $\\text{ALUop}_{\\text{sub}}$，当其有效时选择减法运算。控制逻辑设计者已经仅使用指令位将控制逻辑最小化为以下积之和形式的布尔规范：\n- 令 $R = \\overline{I_3}\\,\\overline{I_2}\\,\\overline{I_1}\\,\\overline{I_0}$ 表示寄存器类型操作码。\n- 令 $\\text{ADDI} = I_3\\,\\overline{I_2}\\,\\overline{I_1}\\,\\overline{I_0}$ 表示立即数加法。\n- 令 $\\text{LW} = \\overline{I_3}\\,\\overline{I_2}\\,I_1\\,I_0$ 表示加载字。\n- 令 $\\text{BEQ} = \\overline{I_3}\\,I_2\\,\\overline{I_1}\\,\\overline{I_0}$ 表示相等则分支。\n\n需要实现的输出是：\n- $\\text{RegWrite} = R \\cdot \\big(F_2 + F_1 + \\overline{F_0}\\big) + \\text{ADDI} + \\text{LW}$，该信号对除跳转寄存器（编码为 $F_2 F_1 F_0 = 0\\,0\\,1$）外的所有寄存器类型算术功能，以及立即数加法和加载字指令有效。\n- $\\text{ALUop}_{\\text{sub}} = \\text{BEQ} + \\big(R \\cdot \\overline{F_2} \\cdot F_1 \\cdot \\overline{F_0}\\big)$，该信号对相等则分支指令和寄存器类型减法功能（编码为 $F_2 F_1 F_0 = 0\\,1\\,0$）有效。\n\n使用一个仅由双输入与非门（NAND gate）组成的网络来实现 $\\text{RegWrite}$ 和 $\\text{ALUop}_{\\text{sub}}$。唯一可用的主输入是非反相（non-complemented）位 $I_3,I_2,I_1,I_0,F_2,F_1,F_0$。你可以使用输入端相连的双输入与非门来创建反相字面量。允许无限扇出。你可以在两个输出之间共享任何中间的与非门子网络；每个物理双输入与非门即使驱动多个地方也只计数一次。你的目标是在给定规范的约束下，通过适当地进行逻辑因式分解和共享中间信号，来最小化双输入与非门的总数。\n\n仅从布尔代数的基本定律和与非门的通用性（即任何布尔函数都可以通过使用反相、合取和德摩根变换，用与非门实现）出发，推导出一个门级实现方案，并计算在所述约束下同时实现 $\\text{RegWrite}$ 和 $\\text{ALUop}_{\\text{sub}}$ 所需的双输入与非门的最少总数。将你的最终答案表示为等于此最小总双输入与非门数量的单个整数。无需四舍五入。", "solution": "用户希望仅使用双输入与非门来实现两个布尔逻辑函数 $\\text{RegWrite}$ 和 $\\text{ALUop}_{\\text{sub}}$，目标是最小化总门数。\n\n首先，我们必须验证问题。\n**步骤1：提取已知条件**\n- **输入：** $I_3, I_2, I_1, I_0, F_2, F_1, F_0$（均为单位比特）。\n- **中间定义：**\n  - $R = \\overline{I_3}\\,\\overline{I_2}\\,\\overline{I_1}\\,\\overline{I_0}$\n  - $\\text{ADDI} = I_3\\,\\overline{I_2}\\,\\overline{I_1}\\,\\overline{I_0}$\n  - $\\text{LW} = \\overline{I_3}\\,\\overline{I_2}\\,I_1\\,I_0$\n  - $\\text{BEQ} = \\overline{I_3}\\,I_2\\,\\overline{I_1}\\,\\overline{I_0}$\n- **输出函数：**\n  - $\\text{RegWrite} = R \\cdot \\big(F_2 + F_1 + \\overline{F_0}\\big) + \\text{ADDI} + \\text{LW}$\n  - $\\text{ALUop}_{\\text{sub}} = \\text{BEQ} + \\big(R \\cdot \\overline{F_2} \\cdot F_1 \\cdot \\overline{F_0}\\big)$\n- **约束条件：**\n  - 实现必须仅使用双输入与非门。\n  - 反相器由输入端相连的双输入与非门构成。\n  - 允许无限扇出。\n  - 中间逻辑网络可以共享。\n- **目标：** 最小化双输入与非门的总数。\n\n**步骤2：使用提取的已知条件进行验证**\n这是一个标准的数字逻辑设计和优化任务。它在科学上基于布尔代数和计算机体系结构原理。定义清晰，目标明确，没有明显的矛盾、歧义或违反科学原理之处。因此，该问题被认定为有效。\n\n**步骤3：结论与行动**\n问题有效。现在开始解决过程。\n\n**最小与非门实现的推导**\n我们的策略是在一个典型的两级与非-与非结构中实现这些函数，这对应于积之和（SOP）形式。我们将首先将函数展开为最小SOP形式，然后识别公共子表达式以共享门电路。\n\n布尔方程为：\n$\\text{RegWrite} = R \\cdot (F_2 + F_1 + \\overline{F_0}) + \\text{ADDI} + \\text{LW}$\n$\\text{ALUop}_{\\text{sub}} = \\text{BEQ} + (R \\cdot \\overline{F_2} \\cdot F_1 \\cdot \\overline{F_0})$\n\n让我们通过分配 $R$ 将 $\\text{RegWrite}$ 展开为其完整的SOP形式：\n$\\text{RegWrite} = (R \\cdot F_2) + (R \\cdot F_1) + (R \\cdot \\overline{F_0}) + \\text{ADDI} + \\text{LW}$\n\n两个函数中的完整乘积项（$P_i$）集合是：\n$P_1 = R \\cdot F_2 = \\overline{I_3}\\,\\overline{I_2}\\,\\overline{I_1}\\,\\overline{I_0}\\,F_2$\n$P_2 = R \\cdot F_1 = \\overline{I_3}\\,\\overline{I_2}\\,\\overline{I_1}\\,\\overline{I_0}\\,F_1$\n$P_3 = R \\cdot \\overline{F_0} = \\overline{I_3}\\,\\overline{I_2}\\,\\overline{I_1}\\,\\overline{I_0}\\,\\overline{F_0}$\n$P_4 = \\text{ADDI} = I_3\\,\\overline{I_2}\\,\\overline{I_1}\\,\\overline{I_0}$\n$P_5 = \\text{LW} = \\overline{I_3}\\,\\overline{I_2}\\,I_1\\,I_0$\n$P_6 = \\text{BEQ} = \\overline{I_3}\\,I_2\\,\\overline{I_1}\\,\\overline{I_0}$\n$P_7 = R \\cdot \\overline{F_2} \\cdot F_1 \\cdot \\overline{F_0} = \\overline{I_3}\\,\\overline{I_2}\\,\\overline{I_1}\\,\\overline{I_0}\\,\\overline{F_2}\\,F_1\\,\\overline{F_0}$\n\n实现将基于SOP表达式 $F = \\sum_i P_i = \\overline{\\prod_i \\overline{P_i}} = \\text{NAND}(\\overline{P_1}, \\overline{P_2}, \\dots)$ 的与非-与非实现。这需要在第一级生成反相的乘积项（$\\overline{P_i}$），然后在第二级用一个最终的与非门将它们组合起来。\n\n**逐门构造与计数**\n我们将逐步构建电路，每个独特的双输入与非门只计数一次。\n\n**1. 输入反相器（6个门）**\n这些函数需要 $I_3, I_2, I_1, I_0, F_2, F_0$ 的反相版本。每次反相花费一个双输入与非门。\n- $\\overline{I_3}, \\overline{I_2}, \\overline{I_1}, \\overline{I_0}, \\overline{F_2}, \\overline{F_0}$\n- 门数（GC）：$6$\n\n**2. 共享的双输入与门子表达式（4个门）**\n许多乘积项共享公共的字面量对。我们首先构建这些共享的与项。\n- 令 $A_1 = \\overline{I_3}\\overline{I_2}$。这需要一个与非门用于 $\\text{NAND}(\\overline{I_3},\\overline{I_2})$ 和第二个用于反相。总共：$2$ 个门。现在 $A_1$ 可用。\n- 令 $A_2 = \\overline{I_1}\\overline{I_0}$。这同样需要 $2$ 个门。现在 $A_2$ 可用。\n- 门数：$6 + 4 = 10$。\n\n**3. R类型信号（2个门）**\n信号 $R = \\overline{I_3}\\overline{I_2}\\overline{I_1}\\overline{I_0}$ 可以构建为 $R=A_1 \\cdot A_2$。\n- 这个双输入与运算花费 $2$ 个门。现在信号 $R$ 可用。\n- 门数：$10 + 2 = 12$。\n\n**4. 用于 $\\text{RegWrite}$ 项的第一级与非门（第1部分 - 基于R）（3个门）**\n这些是反相的乘积项 $\\overline{P_1}, \\overline{P_2}, \\overline{P_3}$。\n- $\\overline{P_1} = \\overline{R \\cdot F_2} = \\text{NAND}(R, F_2)$。（1个门）\n- $\\overline{P_2} = \\overline{R \\cdot F_1} = \\text{NAND}(R, F_1)$。（1个门）\n- $\\overline{P_3} = \\overline{R \\cdot \\overline{F_0}} = \\text{NAND}(R, \\overline{F_0})$。（1个门）\n- 门数：$12 + 3 = 15$。$\\overline{P_1}, \\overline{P_2}, \\overline{P_3}$ 可用。\n\n**5. 用于 $\\text{RegWrite}$ 项的第一级与非门（第2部分 - ADDI, LW）（6个门）**\n- 要创建 $\\overline{P_4} = \\overline{I_3\\,\\overline{I_2}\\,\\overline{I_1}\\,\\overline{I_0}} = \\overline{(I_3\\,\\overline{I_2}) \\cdot A_2}$：\n  - 构建 $T_4 = I_3\\,\\overline{I_2}$（2个门）。\n  - $\\overline{P_4} = \\text{NAND}(T_4, A_2)$（1个门）。总共：$3$ 个门。\n- 要创建 $\\overline{P_5} = \\overline{\\overline{I_3}\\,\\overline{I_2}\\,I_1\\,I_0} = \\overline{A_1 \\cdot (I_1\\,I_0)}$：\n  - 构建 $T_5 = I_1\\,I_0$（2个门）。\n  - $\\overline{P_5} = \\text{NAND}(A_1, T_5)$（1个门）。总共：$3$ 个门。\n- 门数：$15 + 3 + 3 = 21$。$\\overline{P_4}, \\overline{P_5}$ 可用。\n\n**6. 用于 $\\text{ALUop}_{\\text{sub}}$ 项的第一级与非门（BEQ）（3个门）**\n- 要创建 $\\overline{P_6} = \\overline{\\overline{I_3}\\,I_2\\,\\overline{I_1}\\,\\overline{I_0}} = \\overline{(\\overline{I_3}\\,I_2) \\cdot A_2}$：\n  - 构建 $T_6 = \\overline{I_3}\\,I_2$（2个门）。\n  - $\\overline{P_6} = \\text{NAND}(T_6, A_2)$（1个门）。总共：$3$ 个门。\n- 门数：$21 + 3 = 24$。$\\overline{P_6}$ 可用。\n\n**7. 用于 $\\text{ALUop}_{\\text{sub}}$ 项的第一级与非门（SUB）（4个门）**\n- 该项为 $P_7 = R \\cdot \\overline{F_2} \\cdot F_1 \\cdot \\overline{F_0}$。我们可以将其因式分解为 $P_7 = (R \\cdot F_1) \\cdot (\\overline{F_2} \\cdot \\overline{F_0}) = P_2 \\cdot (\\overline{F_2} \\cdot \\overline{F_0})$。\n- 要创建 $\\overline{P_7} = \\overline{P_2 \\cdot (\\overline{F_2} \\cdot \\overline{F_0})}$：\n  - 我们从步骤4中得到了 $\\overline{P_2}$。将其反相得到 $P_2$：$\\text{NAND}(\\overline{P_2}, \\overline{P_2})$（1个门）。\n  - 构建 $T_7 = \\overline{F_2} \\cdot \\overline{F_0}$（2个门）。\n  - $\\overline{P_7} = \\text{NAND}(P_2, T_7)$（1个门）。总共：$4$ 个门。\n- 门数：$24 + 4 = 28$。$\\overline{P_7}$ 可用。\n\n**8. 用于最终输出的第二级与非门（5个门）**\n- $\\text{RegWrite} = \\text{NAND}(\\overline{P_1}, \\overline{P_2}, \\overline{P_3}, \\overline{P_4}, \\overline{P_5})$。这是一个 $5$ 输入与非门。\n  - 用双输入与非门以树形结构实现的 $k$ 输入与非门需要 $k-1$ 个门。\n  - 对于 $k=5$，成本是 $5-1=4$ 个门。\n- $\\text{ALUop}_{\\text{sub}} = \\text{NAND}(\\overline{P_6}, \\overline{P_7})$。这是一个双输入与非门。\n  - 对于 $k=2$，成本是 $2-1=1$ 个门。\n- 门数：$28 + 4 + 1 = 33$。\n\n在系统地构建电路并共享公共子表达式后，总门数为 $33$。\n\n**门数总结**\n- 反相器：$6$\n- 共享的双输入与门 ($A_1, A_2$)：$4$\n- 信号 R：$2$\n- 反相项 $\\overline{P_1}, \\overline{P_2}, \\overline{P_3}$：$3$\n- 反相项 $\\overline{P_4}$：$3$\n- 反相项 $\\overline{P_5}$：$3$\n- 反相项 $\\overline{P_6}$：$3$\n- 反相项 $\\overline{P_7}$：$4$\n- 最终 $\\text{RegWrite}$ 输出逻辑：$4$\n- 最终 $\\text{ALUop}_{\\text{sub}}$ 输出逻辑：$1$\n- **总计**：$6+4+2+3+3+3+3+4+4+1 = 33$ 个门。\n\n这代表了在指定约束下的一个完整且优化的实现。", "answer": "$$\\boxed{33}$$", "id": "3646582"}, {"introduction": "设计出控制逻辑电路后，下一个关键问题是：“它能运行多快？”处理器的时钟频率并非随意设定，而是受电路中最长延迟路径（即关键路径）的限制。本练习将带你深入分析同步时序，通过计算寄存器延迟、逻辑延迟和时钟偏斜，来确定处理器的最高可行时钟频率。这是连接逻辑设计与物理现实的关键一步。[@problem_id:3646600]", "problem": "一个同步、边沿触发的硬布线控制单元负责协调一个经典的 $5$ 级流水线（取指(Instruction Fetch)、指令译码(Instruction Decode)、执行(Execute)、访存(Memory)、写回(Write Back)）。为保证算术逻辑单元（ALU）的标志位——零、进位和溢出——在被分支决策网络使用时是稳定的，设计规范要求这些标志位在执行阶段结束时被锁存到一个专用的标志寄存器中，然后才能被分支决策逻辑使用。分支决策逻辑根据解码后的分支条件、锁存的标志位以及计算出的分支目标，通过一个多路选择器来选择下一个程序计数器（PC）的值。\n\n假设存在一个具有时钟偏斜 $t_{\\mathrm{skew}}$ 的全局时钟，以及具有指定 clock-to-$Q$ 时间和建立时间的边沿触发触发器。考虑以下测得的延迟（除非标有“min”，否则均为最坏情况）：\n\n- 从执行阶段输入寄存器（ID/EX）到标志寄存器：\n  - ID/EX 寄存器的 clock-to-$Q$ 时间：$t_{\\mathrm{cq}}^{\\mathrm{ID/EX}} = 0.15\\,\\mathrm{ns}$，最小值为 $t_{\\mathrm{cq,min}}^{\\mathrm{ID/EX}} = 0.08\\,\\mathrm{ns}$。\n  - ALU 传播延迟：$t_{\\mathrm{ALU}} = 2.60\\,\\mathrm{ns}$，最小值为 $t_{\\mathrm{ALU,min}} = 1.00\\,\\mathrm{ns}$。\n  - 标志位生成逻辑延迟：$t_{\\mathrm{flag}} = 0.25\\,\\mathrm{ns}$，最小值为 $t_{\\mathrm{flag,min}} = 0.10\\,\\mathrm{ns}$。\n  - 标志寄存器建立时间：$t_{\\mathrm{setup}}^{\\mathrm{Flag}} = 0.09\\,\\mathrm{ns}$，保持时间为 $t_{\\mathrm{hold}}^{\\mathrm{Flag}} = 0.02\\,\\mathrm{ns}$。\n\n- 从标志寄存器到 PC 寄存器：\n  - 标志寄存器的 clock-to-$Q$ 时间：$t_{\\mathrm{cq}}^{\\mathrm{Flag}} = 0.12\\,\\mathrm{ns}$。\n  - 分支决策组合逻辑延迟：$t_{\\mathrm{branch}} = 0.50\\,\\mathrm{ns}$。\n  - 分支目标加法器延迟：$t_{\\mathrm{add}} = 0.85\\,\\mathrm{ns}$。\n  - PC 选择多路选择器延迟：$t_{\\mathrm{mux}} = 0.28\\,\\mathrm{ns}$。\n  - PC 寄存器建立时间：$t_{\\mathrm{setup}}^{\\mathrm{PC}} = 0.10\\,\\mathrm{ns}$。\n\n- 全局时钟偏斜：$t_{\\mathrm{skew}} = 0.04\\,\\mathrm{ns}$。\n\n- 流水线中所有其他级间寄存器到寄存器的最坏情况路径延迟小于或等于 $1.80\\,\\mathrm{ns}$，因此与上述的“执行到标志位”和“标志位到PC”路径相比，它们不是关键路径。\n\n从边沿触发系统的基本同步时序约束（寄存器到寄存器的建立和保持要求）出发，并认识到标志位必须在被控制逻辑使用前锁存，推导出能同时满足以下条件的最小可行时钟周期 $T_{\\mathrm{clk}}$：\n- “执行到标志位”的锁存路径（以确保标志位被正确锁存），以及\n- 下一个周期中“标志位到PC”的控制路径（以确保基于锁存标志位的的分支决策能及时到达 PC 寄存器）。\n\n然后计算最大时钟频率 $f_{\\max} = 1/T_{\\mathrm{clk}}$。最终答案以 $\\mathrm{MHz}$ 为单位表示，并四舍五入到四位有效数字。", "solution": "问题要求确定同步流水线处理器的最小可行时钟周期 $T_{\\mathrm{clk}}$，该周期由其关键路径的时序约束决定。最大时钟频率 $f_{\\max}$ 是该最小周期的倒数。分析必须遵循同步数字电路中边沿触发寄存器的基本时序原则，特别是建立时间和保持时间的约束。\n\n建立时间约束规定，在一个触发器的数据输入端，数据必须在有效时钟沿到达之前的最小持续时间（即建立时间 $t_{\\mathrm{setup}}$）内保持稳定。对于源寄存器（Reg1）和目标寄存器（Reg2）之间的数据路径，此约束决定了最小的时钟周期。数据从 Reg1 的输出端传播，经过中间的组合逻辑，到达 Reg2 输入端的总延迟，必须小于时钟周期，同时要考虑 Reg2 的建立时间以及寄存器之间的任何时钟偏斜（$t_{\\mathrm{skew}}$）。在建立时间的最坏情况下，时钟比源寄存器更早到达目标寄存器，这减少了可用于数据传播的时间。其约束不等式为：\n$$T_{\\mathrm{clk}} \\ge t_{\\mathrm{cq,max}}^{\\mathrm{Reg1}} + t_{\\mathrm{logic,max}} + t_{\\mathrm{setup}}^{\\mathrm{Reg2}} + t_{\\mathrm{skew}}$$\n其中 $t_{\\mathrm{cq,max}}^{\\mathrm{Reg1}}$ 是源寄存器的最大 clock-to-Q 延迟，$t_{\\mathrm{logic,max}}$ 是组合逻辑路径的最大传播延迟。\n\n系统的总体最小周期是所有单个寄存器到寄存器路径所需最小周期的最大值。问题指出了两个特定的关注路径，以及对所有其他路径的一般约束。我们将依次分析每个路径。\n\n1.  “执行到标志位”的锁存路径：\n该路径将数据从 ID/EX 流水线寄存器，经过 ALU 和标志位生成逻辑，传播到专用标志寄存器的输入端。\n源寄存器是 ID/EX 寄存器，目标寄存器是标志寄存器。\n组合逻辑延迟是 ALU 延迟和标志位生成逻辑延迟之和：\n$t_{\\mathrm{logic,1}} = t_{\\mathrm{ALU}} + t_{\\mathrm{flag}} = 2.60\\,\\mathrm{ns} + 0.25\\,\\mathrm{ns} = 2.85\\,\\mathrm{ns}$。\n此路径所需的最小周期 $T_{\\mathrm{clk,1}}$ 可通过应用建立时间约束得出：\n$$T_{\\mathrm{clk,1}} \\ge t_{\\mathrm{cq}}^{\\mathrm{ID/EX}} + (t_{\\mathrm{ALU}} + t_{\\mathrm{flag}}) + t_{\\mathrm{setup}}^{\\mathrm{Flag}} + t_{\\mathrm{skew}}$$\n代入给定的最大延迟值：\n$$T_{\\mathrm{clk,1}} \\ge 0.15\\,\\mathrm{ns} + (2.60\\,\\mathrm{ns} + 0.25\\,\\mathrm{ns}) + 0.09\\,\\mathrm{ns} + 0.04\\,\\mathrm{ns}$$\n$$T_{\\mathrm{clk,1}} \\ge 0.15\\,\\mathrm{ns} + 2.85\\,\\mathrm{ns} + 0.09\\,\\mathrm{ns} + 0.04\\,\\mathrm{ns}$$\n$$T_{\\mathrm{clk,1}} \\ge 3.13\\,\\mathrm{ns}$$\n\n2.  “标志位到PC”的控制路径（及相关的PC更新逻辑）：\n该路径决定了要加载到程序计数器（PC）寄存器中的地址。该逻辑涉及多个信号汇聚到 PC 选择多路选择器上。PC 寄存器输入端的最终值取决于最晚到达 MUX 逻辑的信号。\nPC 选择 MUX 的输入是计算出的分支目标地址和其他可能的下一 PC 值（例如 PC+$4$）。MUX 的选择信号来自自分支决策逻辑。\n- 分支目标地址路径始于 ID/EX 寄存器（持有 PC 和立即数偏移量），并经过分支目标加法器。从时钟沿开始，该信号在 MUX 数据输入端稳定所需的时间为 $t_{\\mathrm{cq}}^{\\mathrm{ID/EX}} + t_{\\mathrm{add}}$。\n- 分支决策路径始于标志寄存器，并经过分支决策逻辑。从时钟沿开始，该信号在 MUX 选择输入端稳定所需的时间为 $t_{\\mathrm{cq}}^{\\mathrm{Flag}} + t_{\\mathrm{branch}}$。\n\nMUX 的输出只有在这些输入信号中最晚的一个到达并传播通过 MUX 后才会稳定。从触发时钟沿到 PC 寄存器 D 输入端的总传播延迟 $T_{\\mathrm{prop,2}}$ 为：\n$$T_{\\mathrm{prop,2}} = \\max(t_{\\mathrm{cq}}^{\\mathrm{ID/EX}} + t_{\\mathrm{add}}, t_{\\mathrm{cq}}^{\\mathrm{Flag}} + t_{\\mathrm{branch}}) + t_{\\mathrm{mux}}$$\n计算 $\\max$ 函数中的两项：\n$$t_{\\mathrm{cq}}^{\\mathrm{ID/EX}} + t_{\\mathrm{add}} = 0.15\\,\\mathrm{ns} + 0.85\\,\\mathrm{ns} = 1.00\\,\\mathrm{ns}$$\n$$t_{\\mathrm{cq}}^{\\mathrm{Flag}} + t_{\\mathrm{branch}} = 0.12\\,\\mathrm{ns} + 0.50\\,\\mathrm{ns} = 0.62\\,\\mathrm{ns}$$\n较长的路径是分支目标的计算路径。因此：\n$$T_{\\mathrm{prop,2}} = \\max(1.00\\,\\mathrm{ns}, 0.62\\,\\mathrm{ns}) + 0.28\\,\\mathrm{ns} = 1.00\\,\\mathrm{ns} + 0.28\\,\\mathrm{ns} = 1.28\\,\\mathrm{ns}$$\n此路径所需的最小周期 $T_{\\mathrm{clk,2}}$ 由 PC 寄存器的建立时间约束给出：\n$$T_{\\mathrm{clk,2}} \\ge T_{\\mathrm{prop,2}} + t_{\\mathrm{setup}}^{\\mathrm{PC}} + t_{\\mathrm{skew}}$$\n$$T_{\\mathrm{clk,2}} \\ge 1.28\\,\\mathrm{ns} + 0.10\\,\\mathrm{ns} + 0.04\\,\\mathrm{ns}$$\n$$T_{\\mathrm{clk,2}} \\ge 1.42\\,\\mathrm{ns}$$\n\n3.  其他流水线路径：\n问题指出，所有其他寄存器到寄存器的路径施加的时序约束小于或等于 $1.80\\,\\mathrm{ns}$。这为时钟周期提供了第三个约束：\n$$T_{\\mathrm{clk,3}} \\ge 1.80\\,\\mathrm{ns}$$\n该值被解释为这些其他路径中最慢一条路径所需的最小周期。\n\n为确保整个流水线的正确运行，系统的时钟周期 $T_{\\mathrm{clk}}$ 必须足够长，以同时满足所有路径的要求。因此，最小可行时钟周期是各单个路径要求的最大值：\n$$T_{\\mathrm{clk,min}} = \\max(T_{\\mathrm{clk,1}}, T_{\\mathrm{clk,2}}, T_{\\mathrm{clk,3}})$$\n$$T_{\\mathrm{clk,min}} = \\max(3.13\\,\\mathrm{ns}, 1.42\\,\\mathrm{ns}, 1.80\\,\\mathrm{ns}) = 3.13\\,\\mathrm{ns}$$\n限制时钟速度的关键路径是“执行到标志位”的锁存路径。\n\n作为尽职调查，我们应该验证关键路径的保持时间约束没有被违反，因为保持时间违例会使设计无效。保持时间约束要求触发器输入端的数据在时钟沿之后保持稳定的时间为 $t_{\\mathrm{hold}}$。这会受到短路径的威胁。其条件是：\n$$t_{\\mathrm{cq,min}}^{\\mathrm{Reg1}} + t_{\\mathrm{logic,min}} \\ge t_{\\mathrm{hold}}^{\\mathrm{Reg2}} + t_{\\mathrm{skew}}$$\n对于“执行到标志位”路径：\n$t_{\\mathrm{logic,min}} = t_{\\mathrm{ALU,min}} + t_{\\mathrm{flag,min}} = 1.00\\,\\mathrm{ns} + 0.10\\,\\mathrm{ns} = 1.10\\,\\mathrm{ns}$。\n检查不等式：\n$$t_{\\mathrm{cq,min}}^{\\mathrm{ID/EX}} + t_{\\mathrm{logic,min}} \\ge t_{\\mathrm{hold}}^{\\mathrm{Flag}} + t_{\\mathrm{skew}}$$\n$$0.08\\,\\mathrm{ns} + 1.10\\,\\mathrm{ns} \\ge 0.02\\,\\mathrm{ns} + 0.04\\,\\mathrm{ns}$$\n$$1.18\\,\\mathrm{ns} \\ge 0.06\\,\\mathrm{ns}$$\n保持条件被满足，且有相当大的裕量。设计是有效的。\n\n最后，最大时钟频率 $f_{\\max}$ 是最小周期的倒数：\n$$f_{\\max} = \\frac{1}{T_{\\mathrm{clk,min}}} = \\frac{1}{3.13\\,\\mathrm{ns}} = \\frac{1}{3.13 \\times 10^{-9}\\,\\mathrm{s}} \\approx 319.4888... \\times 10^{6}\\,\\mathrm{Hz} = 319.4888...\\,\\mathrm{MHz}$$\n根据要求四舍五入到四位有效数字，我们得到 $319.5\\,\\mathrm{MHz}$。", "answer": "$$\\boxed{319.5}$$", "id": "3646600"}, {"introduction": "一个优秀的控制单元不仅要能正确执行有效指令，还必须能安全地处理无效或非法的指令。本练习挑战你设计一个关键的系统安全特性：检测非法操作码并触发异常处理。你将学习如何通过严格的同步设计，确保即使在发生错误时，系统也能保持稳定和可预测的行为，并正确地清空流水线以防止错误状态的传播。[@problem_id:3646662]", "problem": "一个硬布线控制单元用于一个经典的 $5$ 级流水线，该流水线包含取指 (Fetch)、译码 (Decode)、执行 (Execute)、访存 (Memory) 和写回 (Writeback) 阶段。指令寄存器 (IR) 在系统时钟的上升沿捕获当前指令，其操作码字段 $Opcode$ 的宽度为 $w$ 位。该控制单元使用组合逻辑将 $Opcode$ 译码为一组控制信号。存在一个受支持的操作码的有限集合 $S$。系统有一个同步复位输入 $Reset$，当其在时钟上升沿被置为高电平时，必须将所有流水线寄存器清除到一个已知的空操作 (NOP) 状态，并清除所有内部控制标志。异常由一个独立的异常处理有限状态机处理，该状态机在时钟边沿采样一个 $Exception$ 输入。\n\n设计要求：\n- 在硬件中检测任何非法操作码（即任何 $Opcode \\notin S$），并置位一个由异常处理逻辑采样的 $Exception$ 信号。\n- 确保引发异常的指令被冲刷 (squashed)，以便在执行、访存或写回阶段不会发生任何架构副作用。这包括防止寄存器文件写入、内存写入以及超出架构为异常入口定义的程序计数器更新。\n- 保持同步复位行为：$Reset$ 必须始终是状态元件的纯同步控制，并且异常的出现不能将 $Reset$ 转换为异步信号，也不能导致 $Reset$ 被非复位事件置位。\n\n在硬布线控制单元中，以下哪种设计选择能正确实现这些目标？\n\nA. 在译码阶段，使用纯组合逻辑实现非法操作码检测，该检测逻辑的输入仅由寄存后的信号提供，其逻辑为所有有效译码项（针对集合 $S$）的析取的补；将检测结果寄存到一个带同步复位的 $Exception$ 触发器中，以便在时钟上升沿，如果 $Reset=1$，则清除 $Exception$，否则它将捕获检测结果；使用寄存后的 $Exception$ 信号驱动一个单周期的流水线冲刷，将下一周期的控制束转换为空操作 (NOP) 并关断所有写使能信号，同时在所有状态更新中，$Reset$ 的优先级高于 $Exception$。\n\nB. 将 $Exception$ 直接作为译码器的组合逻辑输出，并将其与 $Reset$ 进行或运算，以便任何非法操作码都能立即清除流水线，而无需考虑时钟；使用这个或运算后的信号异步复位流水线寄存器以确保无副作用。\n\nC. 在 $Opcode$ 上附加一个奇偶校验器，并将任何奇偶校验不匹配都声明为非法操作码，从奇偶校验器的输出置位 $Exception$；当 $Exception=1$ 时，通过禁用译码阶段的时钟来暂停该阶段以避免副作用，同时保持其他阶段不变。\n\nD. 在通过组合逻辑检测到非法操作码后，将 $Reset$ 置为高电平一个周期以清除流水线并通知异常处理逻辑；通过复用全局复位树来避免添加任何新的触发器。\n\nE. 在译码阶段检测到非法操作码，但不进行冲刷，而是通过撤销取指和译码阶段的使能信号来暂停它们，同时允许下游阶段继续进行；一旦异常处理器采样到 $Exception$，就解除暂停并继续执行。\n\n选择最佳选项。", "solution": "用户希望我扮演一名 STEM 教授，解决一个关于流水线处理器中硬连线控制单元的问题。\n\n### 步骤 1：提取已知条件\n\n- **流水线结构：** 经典的 $5$ 级流水线：取指 (Fetch)、译码 (Decode)、执行 (Execute)、访存 (Memory)、写回 (Writeback)。\n- **控制单元：** 硬布线。\n- **指令取指/译码：** 指令寄存器 ($IR$) 在系统时钟的上升沿捕获一条指令。其操作码字段表示为 $Opcode$，宽度为 $w$ 位。\n- **操作码集合：** 存在一个受支持的操作码的有限集合 $S$。\n- **控制信号生成：** 组合逻辑将 $Opcode$ 译码为控制信号。\n- **复位：** 提供一个同步输入 $Reset$。当在时钟上升沿置为高电平 ($Reset=1$) 时，它必须将所有流水线寄存器清除为空操作 (NOP) 状态，并清除内部控制标志。\n- **异常：** 一个异常处理有限状态机 (FSM) 在时钟边沿采样一个 $Exception$ 输入。\n\n### 设计要求：\n\n1.  **非法操作码检测：** 在硬件中检测任何 $Opcode \\notin S$。\n2.  **异常置位：** 检测必须置位 $Exception$ 信号。\n3.  **指令冲刷：** 引发异常的指令必须被冲刷，以防止在执行、访存或写回阶段产生任何架构副作用（例如，无寄存器文件写入、内存写入或不正确的程序计数器更新）。\n4.  **保持同步复位：** $Reset$ 输入必须保持为纯同步控制。异常的发生不能导致 $Reset$ 被置位或将其行为变为异步。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n问题陈述是科学严谨、定义明确且客观的。\n-   **科学严谨性：** 问题描述了一个标准的冯·诺依曼架构，带有一个 5 级 RISC 风格的流水线。硬布线控制、操作码译码、同步设计、异常处理和流水线冲刷等概念是计算机体系结构和数字逻辑设计中基本且成熟的原则。没有违反科学原理之处。\n-   **定义明确性：** 问题提供了一个清晰的背景（一个 5 级流水线）、一组组件以及一个具体的、不矛盾的设计要求列表。问题要求选择满足所有这些要求的设计选项，这使得问题定义明确且可解。\n-   **客观性：** 使用的语言是技术性和精确的。要求被表述为设计的客观约束（例如，“防止架构副作用”，“保持同步复位行为”）。\n\n问题陈述被认定为**有效**。\n\n### 步骤 3：推导与选项分析\n\n我们必须找到一个满足所有四个要求的设计。让我们分析其中涉及的核心任务。\n\n1.  **检测非法操作码：** 在译码阶段，可以从指令寄存器中获得 $Opcode$ 字段。由于存在一个有限的有效操作码集合 $S$，可以设计一个组合逻辑电路来识别当前的 $w$ 位 $Opcode$ 模式是否是 $S$ 的成员。令 $V_i$ 是一个布尔项，当 $Opcode$ 匹配 $S$ 中的第 $i$ 个有效操作码时为真。有效操作码的条件是所有此类项的析取（OR）：$ValidOpcode = \\bigvee_{i \\in S} V_i$。当此条件为假时，检测到非法操作码，因此检测逻辑为 $IllegalOpcode = \\neg(ValidOpcode)$。此检测逻辑必须是纯组合逻辑，并且对来自为译码阶段供电的流水线寄存器的稳定 $Opcode$ 值进行操作。\n\n2.  **处理异常信号：** $Exception$ 信号由另一个同步模块采样。为确保可靠操作并避免来自组合逻辑 $IllegalOpcode$ 中毛刺的时序风险，该信号必须被寄存。一个触发器，我们称之为 $Exception\\_FF$，应该捕获 $IllegalOpcode$ 信号的状态。此寄存发生在时钟上升沿。为了满足同步复位要求，此触发器必须有一个同步复位输入。逻辑将是：在时钟上升沿，如果 $Reset=1$，则 $Exception\\_FF$ 被清除为 $0$；否则，$Exception\\_FF$ 捕获 $IllegalOpcode$ 信号的值。此触发器的输出是稳定、同步的 $Exception$ 信号。\n\n3.  **冲刷指令：** 当在译码阶段检测到非法指令时，必须阻止其改变架构状态（寄存器、内存）。到 $Exception$ 信号被寄存并变为有效时（在下一个时钟周期的开始），有故障的指令已经前进到译码和执行阶段之间的流水线寄存器（ID/EX 寄存器）。要冲刷它，与此指令相关的控制信号必须被强制为对应于 NOP 的值。这意味着像 $RegWrite$（寄存器写使能）和 $MemWrite$（内存写使能）这样的信号必须被撤销（设置为 $0$）。这个动作，通常称为流水线冲刷或废弃，有效地将非法指令在其通过 EX、MEM 和 WB 阶段时转换为空操作。寄存后的 $Exception$ 信号是此多路复用逻辑的理想控制信号，因为其时序与废止故障指令的控制位完全对齐。\n\n4.  **保持复位完整性：** 设计不得将异常机制与系统复位混淆。使用异常触发全局复位，或使复位信号异步，都直接违反了要求 4。复位是系统级的初始化；异常是控制流的改变。它们必须由独立的机制处理，其中复位具有最高优先级。\n\n现在，让我们根据这个 V-ALIDated 框架评估每个选项。\n\n**A. 在译码阶段，使用纯组合逻辑实现非法操作码检测，该检测逻辑的输入仅由寄存后的信号提供，其逻辑为所有有效译码项（针对集合 $S$）的析取的补；将检测结果寄存到一个带同步复位的 $Exception$ 触发器中，以便在时钟上升沿，如果 $Reset=1$，则清除 $Exception$，否则它将捕获检测结果；使用寄存后的 $Exception$ 信号驱动一个单周期的流水线冲刷，将下一周期的控制束转换为空操作 (NOP) 并关断所有写使能信号，同时在所有状态更新中，$Reset$ 的优先级高于 $Exception$。**\n-   该选项正确地描述了检测的组合逻辑 ($IllegalOpcode = \\neg(\\bigvee V_i)$)。\n-   它正确地提议将检测信号寄存到一个带同步复位的触发器中，这满足了要求 4 并提供了一个稳定的信号。逻辑 `if Reset=1 then ... else ...` 正确地实现了复位优先级。\n-   它正确地使用寄存后的异常信号通过修改*下一周期*的控制信号来冲刷流水线，这是在故障指令进入执行阶段时将其冲刷的正确时序。这满足了要求 3。\n-   它明确提到 $Reset$ 具有优先级，满足了要求 4。\n此设计稳健，遵循标准的同步设计原则，并满足所有规定的要求。\n**结论：正确**\n\n**B. 将 $Exception$ 直接作为译码器的组合逻辑输出，并将其与 $Reset$ 进行或运算，以便任何非法操作码都能立即清除流水线，而无需考虑时钟；使用这个或运算后的信号异步复位流水线寄存器以确保无副作用。**\n-   此设计使用原始的组合逻辑信号作为 $Exception$，容易产生毛刺。\n-   它将异常检测与 $Reset$ 进行或运算，并使用结果异步复位流水线。这在两方面违反了要求 4：它导致异常置位一个类似复位的信号，并且它使复位变为异步。问题明确指出 `Reset` 必须保持为 `纯同步控制`。\n**结论：不正确**\n\n**C. 在 $Opcode$ 上附加一个奇偶校验器，并将任何奇偶校验不匹配都声明为非法操作码，从奇偶校验器的输出置位 $Exception$；当 $Exception=1$ 时，通过禁用译码阶段的时钟来暂停该阶段以避免副作用，同时保持其他阶段不变。**\n-   检测机制有缺陷。奇偶校验用于检测数据传输过程中的位翻转错误，而不是用于根据定义的集合 $S$ 验证操作码。一个有效的操作码可能有“错误”的奇偶性，而一个无效的操作码可能有“正确”的奇偶性。这不满足要求 1。\n-   响应机制是暂停，而不是冲刷。暂停译码阶段并不能从流水线中移除故障指令，也不能将控制权转移给异常处理程序。它只是暂停了机器的一部分，这不满足要求 3。\n**结论：不正确**\n\n**D. 在通过组合逻辑检测到非法操作码后，将 $Reset$ 置为高电平一个周期以清除流水线并通知异常处理逻辑；通过复用全局复位树来避免添加任何新的触发器。**\n-   此设计劫持了全局 $Reset$ 机制来处理异常。这严重且直接地违反了要求 4，该要求规定异常不得 `导致 Reset 被非复位事件置位`。系统复位和异常是根本不同的事件，绝不能混淆。\n-   从译码阶段的组合逻辑驱动全局复位树是一种危险的设计实践，可能导致灾难性的时序故障。\n**结论：不正确**\n\n**E. 在译码阶段检测到非法操作码，但不进行冲刷，而是通过撤销取指和译码阶段的使能信号来暂停它们，同时允许下游阶段继续进行；一旦异常处理器采样到 $Exception$，就解除暂停并继续执行。**\n-   该选项提出了暂停，类似于选项 C。暂停只是插入一个气泡，并不能冲刷掉违规指令，该指令仍保留在 ID/EX 流水线寄存器中。这未能满足要求 3。\n-   “解除暂停并继续”的建议是无意义的。非法指令无法执行。正确的程序是丢弃该指令并将控制权转移给异常处理程序，该处理程序通常会终止违规程序。\n**结论：不正确**\n\n基于以上分析，只有选项 A 描述了一个正确且稳健的实现方案，它满足了问题陈述中列出的所有设计要求。", "answer": "$$\\boxed{A}$$", "id": "3646662"}]}