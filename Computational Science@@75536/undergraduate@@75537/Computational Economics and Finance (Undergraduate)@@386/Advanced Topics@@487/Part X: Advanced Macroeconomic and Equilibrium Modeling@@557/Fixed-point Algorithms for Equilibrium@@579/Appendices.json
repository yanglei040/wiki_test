{"hands_on_practices": [{"introduction": "The Bellman equation is a cornerstone of modern economics, allowing us to model complex decision-making over time. The solution to this equation, the value function, represents the maximum utility an agent can achieve. This value function is the unique fixed point of an operator, and we can find it using a powerful algorithm called value function iteration. This practice guides you through implementing this algorithm, which is a direct computational application of the Contraction Mapping Theorem and a fundamental tool for solving dynamic programming problems [@problem_id:2393445].", "id": "2393445", "problem": "Consider a discrete-time dynamic programming problem on a finite grid for the state variable $k \\in \\mathcal{K} \\subset \\mathbb{R}_{+}$. The decision variable is the next-period state $k' \\in \\mathcal{K}$. The resource constraint is\n$$\nc + k' = A k^{\\alpha} + (1-\\delta) k + \\bar{y},\n$$\nwith $A > 0$, $\\alpha \\in (0,1)$, $\\delta \\in (0,1)$, and an exogenous endowment $\\bar{y} \\ge 0$. Instantaneous utility is constant relative risk aversion (CRRA),\n$$\nu(c) = \\begin{cases}\n\\log(c) & \\text{if } \\sigma = 1,\\\\\n\\dfrac{c^{1-\\sigma}}{1-\\sigma} & \\text{if } \\sigma \\ne 1,\n\\end{cases}\n$$\nwith risk-aversion parameter $\\sigma > 0$ and $c \\ge c_{\\min} > 0$. The Bellman operator $\\mathcal{T}$ on the space of bounded functions $V:\\mathcal{K} \\to \\mathbb{R}$ is\n$$\n(\\mathcal{T}V)(k) = \\max_{k' \\in \\mathcal{K}} \\left\\{ u\\!\\left(A k^{\\alpha} + (1-\\delta) k + \\bar{y} - k' \\right) + \\beta V(k') \\right\\},\n$$\nwith discount factor $\\beta \\in (0,1)$. The value function $V$ is a fixed point of $\\mathcal{T}$, that is, it satisfies $V = \\mathcal{T}V$. On a finite grid $\\mathcal{K} = \\{k_{1},\\dots,k_{N}\\}$ with $N \\in \\mathbb{N}$, represent $V$ as a vector in $\\mathbb{R}^{N}$. Assume $c \\ge c_{\\min}$ is enforced by restricting feasible choices $k'$ for each $k$.\n\nFundamental base: you may use the following facts. First, the existence of a fixed point of a continuous self-map on a compact convex set is guaranteed by Brouwer’s fixed point theorem. Second, the contraction mapping theorem (Banach fixed point theorem) ensures uniqueness and convergence of successive approximations when $\\mathcal{T}$ is a contraction under the supremum norm. In this finite-grid setting with $\\beta \\in (0,1)$ and bounded returns, $\\mathcal{T}$ is a contraction with modulus $\\beta$ under the supremum norm.\n\nTask: Implement a fixed-point algorithm (value function iteration) to compute the fixed point of $\\mathcal{T}$ on a finite grid by successive approximations starting from an initial guess $V_{0}(k) = 0$ for all $k \\in \\mathcal{K}$. At each iteration $n$, compute $V_{n+1} = \\mathcal{T}V_{n}$ and the supremum norm difference $\\Delta_{n} = \\lVert V_{n+1} - V_{n} \\rVert_{\\infty}$. Stop when $\\Delta_{n} \\le \\text{tol}$ for a specified tolerance $\\text{tol} > 0$ or when a specified maximum number of iterations is reached. Additionally, for a designated iteration index $m \\ge 1$, compute whether the contraction inequality $\\Delta_{m} \\le \\beta \\Delta_{m-1}$ holds up to numerical slack.\n\nUse a discrete action set equal to the state grid $\\mathcal{K}$, so that $k' \\in \\mathcal{K}$. Enforce feasibility by excluding any $k'$ that violates $c \\ge c_{\\min}$ for the current state $k$. For numerical stability, you may assign a very large negative utility to infeasible $(k,k')$ pairs. You must implement your program so that it works for the following test suite of parameter values.\n\nTest suite. For each case below, construct an evenly spaced grid $\\mathcal{K} = \\{k_{1},\\dots,k_{N}\\}$ with $k_{1} = k_{\\min}$ and $k_{N} = k_{\\max}$, and report the requested scalar quantity. All numbers are dimensionless and should be treated as pure numbers.\n\n- Case $1$ (baseline, happy path):\n  - $A = 1$, $\\alpha = 0.35$, $\\delta = 0.10$, $\\beta = 0.95$, $\\sigma = 1$, $\\bar{y} = 0$,\n  - $N = 200$, $k_{\\min} = 10^{-4}$, $k_{\\max} = 5$, $c_{\\min} = 10^{-8}$,\n  - $\\text{tol} = 10^{-6}$, $\\text{max\\_iter} = 10000$.\n  - Output: the integer number of iterations taken to satisfy $\\Delta_{n} \\le \\text{tol}$.\n\n- Case $2$ (high patience and curvature, coarser grid):\n  - $A = 1$, $\\alpha = 0.30$, $\\delta = 0.05$, $\\beta = 0.99$, $\\sigma = 2$, $\\bar{y} = 0.02$,\n  - $N = 150$, $k_{\\min} = 10^{-4}$, $k_{\\max} = 2$, $c_{\\min} = 10^{-8}$,\n  - $\\text{tol} = 10^{-6}$, $\\text{max\\_iter} = 10000$.\n  - Output: the floating-point value $V(k_{j})$ at index $j = \\left\\lfloor 0.6 \\cdot (N-1) \\right\\rfloor + 1$ (that is, the state whose index is $1$-based and equals the smallest integer greater than or equal to $0.6 (N-1) + 1$).\n\n- Case $3$ (contraction check):\n  - $A = 1$, $\\alpha = 0.40$, $\\delta = 0.08$, $\\beta = 0.90$, $\\sigma = 3$, $\\bar{y} = 0.10$,\n  - $N = 120$, $k_{\\min} = 10^{-4}$, $k_{\\max} = 3$, $c_{\\min} = 10^{-8}$,\n  - $\\text{tol} = 10^{-8}$, $\\text{max\\_iter} = 10000$.\n  - Let $m = 4$. Output: the boolean truth value of the statement $\\Delta_{m} \\le \\beta \\Delta_{m-1} + \\varepsilon$ with numerical slack $\\varepsilon = 10^{-12}$.\n\n- Case $4$ (residual at fixed point):\n  - $A = 0.80$, $\\alpha = 0.25$, $\\delta = 0.07$, $\\beta = 0.97$, $\\sigma = 1.5$, $\\bar{y} = 0.05$,\n  - $N = 100$, $k_{\\min} = 10^{-4}$, $k_{\\max} = 4$, $c_{\\min} = 10^{-8}$,\n  - $\\text{tol} = 10^{-6}$, $\\text{max\\_iter} = 10000$.\n  - Output: the floating-point Bellman residual at convergence, defined as $\\lVert V^{*} - \\mathcal{T}V^{*} \\rVert_{\\infty}$, where $V^{*}$ is the converged value function from your algorithm.\n\nFinal output format. Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, in the order of cases $1$ through $4$. For example, the printed line must look like $[r_{1},r_{2},r_{3},r_{4}]$ where $r_{1}$ is an integer, $r_{2}$ is a float, $r_{3}$ is a boolean, and $r_{4}$ is a float. No other text should be printed.", "solution": "The posed problem is to find a numerical solution to a standard discrete-time neoclassical growth model. The model is defined by a Bellman equation, which characterizes the value function $V$ as a fixed point of a Bellman operator $\\mathcal{T}$. The problem is scientifically valid, well-posed, and all necessary parameters for its computational solution are provided. The existence and uniqueness of the solution, as well as the convergence of the proposed algorithm, are guaranteed by the Contraction Mapping Theorem (also known as the Banach fixed-point theorem), as correctly noted in the problem statement. The task is to implement the value function iteration (VFI) algorithm, which is the direct computational counterpart to the successive approximations method used in the proof of the theorem.\n\nThe core of the problem lies in the Bellman operator $\\mathcal{T}$, which maps a function $V$ to a new function $\\mathcal{T}V$:\n$$\n(\\mathcal{T}V)(k) = \\max_{k' \\in \\mathcal{K}} \\left\\{ u\\left(A k^{\\alpha} + (1-\\delta) k + \\bar{y} - k' \\right) + \\beta V(k') \\right\\}\n$$\nA solution, or fixed point, is a function $V^*$ such that $V^* = \\mathcal{T}V^*$. The VFI algorithm constructs a sequence of functions $\\{V_n\\}_{n=0}^{\\infty}$ starting from an initial guess $V_0$ (here, $V_0(k)=0$ for all $k$) and iterating according to the rule $V_{n+1} = \\mathcal{T}V_n$. Because $\\mathcal{T}$ is a contraction mapping with modulus $\\beta \\in (0,1)$ under the supremum norm, this sequence is guaranteed to converge to the unique fixed point $V^*$.\n\nFor numerical implementation, the continuous state space for capital $k$ is discretized onto a finite, evenly spaced grid $\\mathcal{K} = \\{k_1, k_2, \\dots, k_N\\}$. Consequently, the value function $V:\\mathcal{K} \\to \\mathbb{R}$ is represented as a vector $\\mathbf{V} \\in \\mathbb{R}^N$, where the $i$-th component, $\\mathbf{V}_i$, corresponds to the value $V(k_i)$. The action space, which consists of choices for next-period capital $k'$, is also restricted to the same grid $\\mathcal{K}$.\n\nThe iterative update $V_{n+1} = \\mathcal{T}V_n$ is performed for each point $k_i \\in \\mathcal{K}$ on the grid. The $i$-th component of the new value function vector $\\mathbf{V}_{n+1}$ is computed as:\n$$\n(\\mathbf{V}_{n+1})_i = \\max_{j \\in \\{1, \\dots, N\\}} \\left\\{ u(c_{ij}) + \\beta (\\mathbf{V}_n)_j \\right\\}\n$$\nHere, $(\\mathbf{V}_n)_j$ is the value of the function from the previous iteration at state $k_j$, and $c_{ij}$ is the consumption resulting from choosing state $k_j$ when the current state is $k_i$. From the resource constraint:\n$$\nc_{ij} = A k_i^{\\alpha} + (1-\\delta) k_i + \\bar{y} - k_j\n$$\nA crucial step is to enforce the feasibility constraint $c_{ij} \\ge c_{\\min}$. Any choice of $k_j$ that violates this constraint is inadmissible. In the maximization procedure, this is handled by assigning an infinitely negative utility (computationally, a very large negative number) to such choices, ensuring they are never selected. The utility function $u(c)$ is defined as $\\log(c)$ for $\\sigma=1$ and $\\frac{c^{1-\\sigma}}{1-\\sigma}$ for $\\sigma \\ne 1$.\n\nThe algorithm proceeds as follows:\n1.  Initialize $\\mathbf{V}_0$ as a vector of zeros of size $N$.\n2.  For each iteration $n=0, 1, 2, \\dots$:\n    a. For each current state $k_i$, $i=1, \\dots, N$:\n        i.  For each possible next state $k_j$, $j=1, \\dots, N$:\n            -   Calculate consumption $c_{ij} = A k_i^{\\alpha} + (1 - \\delta)k_i + \\bar{y} - k_j$.\n            -   If $c_{ij} < c_{\\min}$, the value for this choice is $-\\infty$.\n            -   Otherwise, the value is $u(c_{ij}) + \\beta (\\mathbf{V}_n)_j$.\n        ii. Set $(\\mathbf{V}_{n+1})_i$ to the maximum value found over all choices of $j$.\n    b. Calculate the supremum norm of the difference: $\\Delta_n = \\lVert \\mathbf{V}_{n+1} - \\mathbf{V}_n \\rVert_{\\infty} = \\max_i |(\\mathbf{V}_{n+1})_i - (\\mathbf{V}_n)_i|$.\n    c. If $\\Delta_n \\le \\text{tol}$ or the maximum number of iterations is reached, terminate. Otherwise, set $\\mathbf{V}_n = \\mathbf{V}_{n+1}$ and continue to the next iteration.\n\nThis process is computationally implemented using vectorized operations for efficiency. A matrix of consumption values $C$ with entries $C_{ij} = c_{ij}$ is constructed. A corresponding utility matrix $U$ is then calculated, with entries $U_{ij} = u(C_{ij})$ for feasible consumption and $U_{ij} = -\\infty$ otherwise. The Bellman operator can then be applied in a single vectorized step:\n$$\n\\mathbf{V}_{n+1} = \\max_{\\text{axis}=1} \\left( U + \\beta \\mathbf{V}_n^T \\right)\n$$\nwhere $\\mathbf{V}_n^T$ is broadcast across the rows of the matrix $U$.\n\nThe specific outputs for each case are determined as follows:\n-   Case 1: The total number of iterations performed until convergence.\n-   Case 2: The value of the converged function $\\mathbf{V}^*$ at a specific index. It is noted that the problem description contains an ambiguity in defining this index: the formula $j = \\lfloor 0.6 \\cdot (N-1) \\rfloor + 1$ (floor) is contradicted by the parenthetical text which implies a ceiling function. The formal mathematical expression using the floor function is a more reliable instruction and will be followed. For $N=150$, this yields $j = \\lfloor 0.6 \\cdot 149 \\rfloor + 1 = 89+1 = 90$. The required value is the $90$-th element of the value function vector, which corresponds to index $89$ in a $0$-based array.\n-   Case 3: At iteration $m=4$, the inequality $\\Delta_4 \\le \\beta \\Delta_3 + \\varepsilon$ is checked. This verifies the contraction property of the operator.\n-   Case 4: The final Bellman residual $\\lVert V^* - \\mathcal{T}V^* \\rVert_{\\infty}$ is calculated after the algorithm has converged to $V^*$. This is found by applying the operator one final time to the converged solution $V^*$ and computing the supremum norm difference between the result $\\mathcal{T}V^*$ and $V^*$.\n\nThe implementation will systematically execute this procedure for the four provided test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the dynamic programming problem for four distinct test cases\n    using value function iteration and prints the results.\n    \"\"\"\n\n    def run_vfi(params):\n        \"\"\"\n        Performs value function iteration for a given set of parameters.\n        \"\"\"\n        A = params['A']\n        alpha = params['alpha']\n        delta = params['delta']\n        beta = params['beta']\n        sigma = params['sigma']\n        y_bar = params['y_bar']\n        N = params['N']\n        k_min = params['k_min']\n        k_max = params['k_max']\n        c_min = params['c_min']\n        tol = params['tol']\n        max_iter = params['max_iter']\n        case_id = params['case_id']\n\n        # 1. Grid setup\n        k_grid = np.linspace(k_min, k_max, N)\n        \n        # 2. VFI Initialization\n        V = np.zeros(N)\n        \n        # Iteration-specific storage for Case 3\n        delta_m_minus_1 = np.nan\n        delta_m = np.nan\n        \n        # 3. VFI Main Loop\n        for n in range(max_iter):\n            V_old = V.copy()\n            \n            # Vectorized Bellman operator application\n            k_current = k_grid.reshape((N, 1))\n            k_next = k_grid.reshape((1, N))\n            \n            resources = A * k_current**alpha + (1 - delta) * k_current + y_bar\n            consumption = resources - k_next\n            \n            # Utility calculation with feasibility check\n            utility = np.full((N, N), -np.inf)\n            feasible_mask = consumption >= c_min\n            \n            c_feasible = consumption[feasible_mask]\n            \n            if sigma == 1.0:\n                utility[feasible_mask] = np.log(c_feasible)\n            else:\n                utility[feasible_mask] = (c_feasible**(1 - sigma)) / (1 - sigma)\n            \n            T_V = utility + beta * V_old\n            V = np.max(T_V, axis=1)\n            \n            # Convergence check\n            diff = np.max(np.abs(V - V_old))\n\n            if case_id == 3:\n                m = params['m']\n                if n == m - 2: # Iteration m-1 (0-indexed)\n                    delta_m_minus_1 = diff\n                if n == m - 1: # Iteration m (0-indexed)\n                    delta_m = diff\n\n            if diff < tol:\n                break\n        \n        num_iterations = n + 1\n\n        # 4. Return the requested result based on the case\n        if case_id == 1:\n            return num_iterations\n        elif case_id == 2:\n            # 1-based index j from formula, convert to 0-based for numpy\n            j_one_based = int(np.floor(0.6 * (N - 1))) + 1\n            j_zero_based = j_one_based - 1\n            return V[j_zero_based]\n        elif case_id == 3:\n            epsilon = params['epsilon']\n            return delta_m <= beta * delta_m_minus_1 + epsilon\n        elif case_id == 4:\n            # Calculate the Bellman residual at the converged point V\n            k_current = k_grid.reshape((N, 1))\n            k_next = k_grid.reshape((1, N))\n            resources = A * k_current**alpha + (1 - delta) * k_current + y_bar\n            consumption = resources - k_next\n            utility = np.full((N, N), -np.inf)\n            feasible_mask = consumption >= c_min\n            c_feasible = consumption[feasible_mask]\n            \n            if sigma == 1.0:\n                utility[feasible_mask] = np.log(c_feasible)\n            else:\n                utility[feasible_mask] = (c_feasible**(1 - sigma)) / (1 - sigma)\n                \n            TV_star = np.max(utility + beta * V, axis=1)\n            residual = np.max(np.abs(TV_star - V))\n            return residual\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'case_id': 1, 'A': 1, 'alpha': 0.35, 'delta': 0.10, 'beta': 0.95, 'sigma': 1, 'y_bar': 0,\n            'N': 200, 'k_min': 1e-4, 'k_max': 5, 'c_min': 1e-8,\n            'tol': 1e-6, 'max_iter': 10000\n        },\n        {\n            'case_id': 2, 'A': 1, 'alpha': 0.30, 'delta': 0.05, 'beta': 0.99, 'sigma': 2, 'y_bar': 0.02,\n            'N': 150, 'k_min': 1e-4, 'k_max': 2, 'c_min': 1e-8,\n            'tol': 1e-6, 'max_iter': 10000\n        },\n        {\n            'case_id': 3, 'A': 1, 'alpha': 0.40, 'delta': 0.08, 'beta': 0.90, 'sigma': 3, 'y_bar': 0.10,\n            'N': 120, 'k_min': 1e-4, 'k_max': 3, 'c_min': 1e-8,\n            'tol': 1e-8, 'max_iter': 10000, 'm': 4, 'epsilon': 1e-12\n        },\n        {\n            'case_id': 4, 'A': 0.80, 'alpha': 0.25, 'delta': 0.07, 'beta': 0.97, 'sigma': 1.5, 'y_bar': 0.05,\n            'N': 100, 'k_min': 1e-4, 'k_max': 4, 'c_min': 1e-8,\n            'tol': 1e-6, 'max_iter': 10000\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_vfi(case_params)\n        results.append(result)\n\n    # Format the results into the required string format.\n    # Booleans need to be lowercased as 'true'/'false'.\n    formatted_results = []\n    for r in results:\n        if isinstance(r, bool) or isinstance(r, np.bool_):\n            formatted_results.append(str(r).lower())\n        else:\n            formatted_results.append(str(r))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "Many systems in economics and finance evolve unpredictably, from stock prices to a country's economic state. Markov chains provide a powerful framework for modeling these random processes. A key concept is the stationary distribution, which describes the long-run probability of the system being in any particular state. This equilibrium distribution is the solution to the fixed-point equation $\\pi = \\pi P$, where $\\pi$ is the probability vector and $P$ is the transition matrix. This exercise will have you compute this steady state, a crucial skill for long-term forecasting and risk analysis [@problem_id:2393467].", "id": "2393467", "problem": "Consider a finite-state Markov chain with a row-stochastic transition matrix $P \\in \\mathbb{R}^{n \\times n}$, where each entry $P_{ij} \\geq 0$ and each row sums to $1$. A stationary distribution is any probability vector $\\pi \\in \\mathbb{R}^n$ with nonnegative components that satisfy $\\sum_{i=1}^n \\pi_i = 1$ and the fixed-point equation $\\pi = \\pi P$. For each test case below, compute the stationary distribution that solves $\\pi = \\pi P$ and $\\sum_i \\pi_i = 1$ with $\\pi_i \\geq 0$ for all $i$. Express each component of each stationary distribution as a real number rounded to exactly six decimal places using standard rounding to nearest.\n\nTest suite (each $P^{(k)}$ is row-stochastic):\n- Test case $1$ (dimension $2$):\n  $$P^{(1)} = \\begin{bmatrix}\n  0.9 & 0.1 \\\\\n  0.5 & 0.5\n  \\end{bmatrix}.$$\n- Test case $2$ (dimension $2$):\n  $$P^{(2)} = \\begin{bmatrix}\n  0.999 & 0.001 \\\\\n  0.01 & 0.99\n  \\end{bmatrix}.$$\n- Test case $3$ (dimension $3$):\n  $$P^{(3)} = \\begin{bmatrix}\n  0.7 & 0.2 & 0.1 \\\\\n  0.4 & 0.4 & 0.2 \\\\\n  0.3 & 0.3 & 0.4\n  \\end{bmatrix}.$$\n- Test case $4$ (dimension $4$):\n  $$P^{(4)} = \\begin{bmatrix}\n  0.25 & 0.25 & 0.25 & 0.25 \\\\\n  0.25 & 0.25 & 0.25 & 0.25 \\\\\n  0.25 & 0.25 & 0.25 & 0.25 \\\\\n  0.25 & 0.25 & 0.25 & 0.25\n  \\end{bmatrix}.$$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list of real numbers rounded to six decimals, with no additional text. For example, an output with two test cases could look like $[[0.500000,0.500000],[0.333333,0.333333,0.333334]]$.", "solution": "The problem requires finding the stationary distribution $\\pi$ for a given finite-state Markov chain defined by a row-stochastic transition matrix $P \\in \\mathbb{R}^{n \\times n}$.\n\nA stationary distribution is a probability vector $\\pi = [\\pi_1, \\pi_2, \\dots, \\pi_n]$ satisfying three conditions:\n$1$. $\\pi_i \\ge 0$ for all $i \\in \\{1, \\dots, n\\}$.\n$2$. $\\sum_{i=1}^n \\pi_i = 1$.\n$3$. The fixed-point equation: $\\pi = \\pi P$.\n\nThe fixed-point equation $\\pi = \\pi P$ can be rewritten as a homogeneous system of linear equations:\n$$ \\pi P - \\pi = \\mathbf{0} $$\n$$ \\pi (P - I) = \\mathbf{0} $$\nwhere $I$ is the $n \\times n$ identity matrix and $\\mathbf{0}$ is the $n$-dimensional zero row vector.\n\nThis equation signifies that $\\pi$ is a left eigenvector of the matrix $P$ corresponding to the eigenvalue $\\lambda = 1$. Equivalently, by transposing the equation, we get:\n$$ (P^T - I^T) \\pi^T = \\mathbf{0}^T $$\n$$ (P^T - I) \\pi^T = \\mathbf{0} $$\nThis shows that the column vector $\\pi^T$ is a right eigenvector of the transpose matrix $P^T$ corresponding to the eigenvalue $\\lambda = 1$.\n\nFor any row-stochastic matrix $P$, the sum of each row is $1$. This implies that $P \\mathbf{1} = \\mathbf{1}$, where $\\mathbf{1}$ is the column vector of all ones. Thus, $\\lambda=1$ is always an eigenvalue of $P$. Since a matrix and its transpose share the same set of eigenvalues, $\\lambda=1$ is also an eigenvalue of $P^T$.\n\nThe problem of finding $\\pi$ is therefore reduced to finding the eigenspace of $P^T$ for $\\lambda=1$. The given matrices correspond to irreducible Markov chains (every state is accessible from every other state). For such chains, the Perron-Frobenius theorem guarantees that the eigenvalue $\\lambda=1$ has an algebraic multiplicity of $1$. Consequently, its corresponding eigenspace is one-dimensional.\n\nThis means that any non-zero solution to $(P^T - I)\\pi^T = \\mathbf{0}$ is unique up to a scalar multiple. We find one such non-zero eigenvector, let us call it $v$. By the same theorem, for an irreducible non-negative matrix like $P^T$, the eigenvector $v$ corresponding to the dominant eigenvalue (here $\\lambda=1$) can be chosen to have all non-negative components.\n\nThe final step is to enforce the normalization condition $\\sum_{i=1}^n \\pi_i = 1$. We take the found eigenvector $v$ and normalize it by dividing by the sum of its components:\n$$ \\pi^T = \\frac{v}{\\sum_{i=1}^n v_i} $$\nThe resulting vector $\\pi$ is the unique stationary distribution.\n\nThe computational procedure is as follows:\n$1$. For a given matrix $P$, construct the matrix $A = P^T - I$.\n$2$. Find a basis for the null space of $A$. For the given problems, this will be a single vector $v$.\n$3$. Ensure all components of $v$ are non-negative, taking the absolute value if necessary.\n$4$. Normalize $v$ to obtain the probability vector $\\pi^T$.\n$5$. The components of the resulting vector are then rounded to six decimal places as required.\nThis method is applied to each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Computes the stationary distribution for a set of Markov chain transition matrices.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([\n            [0.9, 0.1],\n            [0.5, 0.5]\n        ]),\n        np.array([\n            [0.999, 0.001],\n            [0.01, 0.99]\n        ]),\n        np.array([\n            [0.7, 0.2, 0.1],\n            [0.4, 0.4, 0.2],\n            [0.3, 0.3, 0.4]\n        ]),\n        np.array([\n            [0.25, 0.25, 0.25, 0.25],\n            [0.25, 0.25, 0.25, 0.25],\n            [0.25, 0.25, 0.25, 0.25],\n            [0.25, 0.25, 0.25, 0.25]\n        ])\n    ]\n\n    all_results_str = []\n    \n    for P in test_cases:\n        # The stationary distribution pi is the left eigenvector of P for eigenvalue 1.\n        # This is equivalent to the right eigenvector of P.T for eigenvalue 1.\n        # We solve the system (P.T - I) * pi.T = 0.\n        \n        n = P.shape[0]\n        I = np.identity(n)\n        A = P.T - I\n\n        # Find the null space of A. For an irreducible Markov chain, this space\n        # is one-dimensional and spanned by the stationary distribution vector.\n        # The result is a basis for the null space, with basis vectors as columns.\n        v = null_space(A)\n\n        # By Perron-Frobenius theorem, the stationary distribution for an\n        # irreducible chain has all positive components. The eigenvector is\n        # unique up to a scalar, so we take the absolute value to ensure non-negativity.\n        pi_vec = np.abs(v[:, 0])\n        \n        # Normalize the vector to make it a probability distribution.\n        pi = pi_vec / np.sum(pi_vec)\n        \n        # Format results to six decimal places.\n        pi_str_list = [f\"{x:.6f}\" for x in pi]\n        all_results_str.append(f\"[{','.join(pi_str_list)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"}, {"introduction": "In real-world financial markets, trading isn't frictionless. Transaction costs and diverse beliefs among traders can create a \"no-trade zone\"—a range of prices where no one has an incentive to either buy or sell. This state of inactivity is a type of market equilibrium, representing a fixed point in trading dynamics. In this problem, you will not iterate to find a point, but instead determine the conditions under which such an equilibrium can exist by calculating the boundaries of this no-trade price region for different assets [@problem_id:2393466].", "id": "2393466", "problem": "Consider a one-period economy with a finite set of states $S=\\{1,\\dots,L\\}$ and a finite set of assets $J=\\{1,\\dots,K\\}$. There are $N$ risk-neutral agents indexed by $i \\in \\{1,\\dots,N\\}$. Each agent $i$ has a subjective probability vector $q_i \\in \\mathbb{R}^L$ with nonnegative components that sum to $1$. Each asset $j$ has a dividend vector $x_j \\in \\mathbb{R}^L_{\\ge 0}$, representing the nonnegative payoff in each state. Let the price vector be $p \\in \\mathbb{R}^K_{\\ge 0}$.\n\nTrading each asset $j$ incurs proportional transaction costs: a buy cost $\\kappa_b^j \\in [0,1)$ and a sell cost $\\kappa_s^j \\in [0,1)$. If an agent buys one unit of asset $j$, the monetary outlay is $p_j(1+\\kappa_b^j)$; if the agent sells one unit, the monetary inflow is $p_j(1-\\kappa_s^j)$.\n\nDefine a no-trade equilibrium price vector as any $p \\in \\mathbb{R}^K_{\\ge 0}$ such that, for every agent $i$ and every asset $j$, neither buying nor selling one unit yields a strictly positive expected gain given agent $i$’s beliefs. Denote $v_{ij} = q_i \\cdot x_j$. Under risk-neutrality, the no-trade conditions for each asset $j$ and agent $i$ are the pair of inequalities\n$q_i \\cdot x_j \\le p_j(1+\\kappa_b^j)$ and $q_i \\cdot x_j \\ge p_j(1-\\kappa_s^j)$,\nwhich are equivalent to the interval constraint\n$p_j \\in \\left[\\max_{i} \\frac{v_{ij}}{1+\\kappa_b^j},\\ \\min_{i} \\frac{v_{ij}}{1-\\kappa_s^j}\\right]$.\nIf the interval for any asset $j$ is empty (i.e., the lower bound exceeds the upper bound), then a no-trade equilibrium price vector does not exist.\n\nYour task is to compute, for each of the test cases below, the following:\n- If all $K$ intervals are nonempty, return the coordinate-wise midpoint of these intervals as the selected no-trade equilibrium price vector. For asset $j$, this midpoint is $\\frac{1}{2}\\left(\\max_{i} \\frac{v_{ij}}{1+\\kappa_b^j}+\\min_{i} \\frac{v_{ij}}{1-\\kappa_s^j}\\right)$.\n- If any asset interval is empty, return an empty list to indicate that a no-trade equilibrium price vector does not exist for that test case.\n\nRound each reported price coordinate to $6$ decimal places and print with exactly $6$ digits after the decimal point.\n\nTest suite (all probabilities and costs are expressed as decimals; all dividends are dimensionless and nonnegative):\n1) Case A:\n- $N=3$, $L=3$, $K=2$.\n- Beliefs:\n  $q_1=(0.2,0.5,0.3)$, $q_2=(0.3,0.4,0.3)$, $q_3=(0.4,0.2,0.4)$.\n- Dividends:\n  $x_1=(1.0,0.0,2.0)$, $x_2=(0.0,1.0,1.0)$.\n- Costs:\n  $\\kappa_b^1=\\kappa_s^1=0.25$, $\\kappa_b^2=\\kappa_s^2=0.25$.\n\n2) Case B:\n- $N=2$, $L=2$, $K=2$.\n- Beliefs:\n  $q_1=(0.5,0.5)$, $q_2=(0.5,0.5)$.\n- Dividends:\n  $x_1=(1.0,1.0)$, $x_2=(2.0,0.0)$.\n- Costs:\n  $\\kappa_b^1=\\kappa_s^1=0.0$, $\\kappa_b^2=\\kappa_s^2=0.0$.\n\n3) Case C:\n- $N=2$, $L=2$, $K=1$.\n- Beliefs:\n  $q_1=(1.0,0.0)$, $q_2=(0.0,1.0)$.\n- Dividends:\n  $x_1=(0.0,2.0)$.\n- Costs:\n  $\\kappa_b^1=\\kappa_s^1=0.01$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to a test case, and is either an empty list (if no equilibrium exists) or a list of $K$ floats rounded to $6$ decimal places with exactly $6$ digits after the decimal point. There must be no whitespace characters in the output. For example, a valid overall output could look like:\n\"[[p11,p12],[p21,p22],[]]\"\nwhere $p11$ and $p12$ are the two coordinates for Case A, $p21$ and $p22$ for Case B, and an empty list for Case C.", "solution": "The problem requires the validation of its premises before a solution is attempted.\n\n### Step 1: Extract Givens\n\nThe provided information is as follows:\n- A set of states $S=\\{1,\\dots,L\\}$, assets $J=\\{1,\\dots,K\\}$, and risk-neutral agents $i \\in \\{1,\\dots,N\\}$.\n- Each agent $i$ has a subjective probability vector $q_i \\in \\mathbb{R}^L$ where components are non-negative and sum to $1$.\n- Each asset $j$ has a non-negative dividend vector $x_j \\in \\mathbb{R}^L_{\\ge 0}$.\n- The price vector is $p \\in \\mathbb{R}^K_{\\ge 0}$.\n- Proportional transaction costs for buying, $\\kappa_b^j \\in [0,1)$, and selling, $\\kappa_s^j \\in [0,1)$.\n- Agent $i$'s expected value for asset $j$ is $v_{ij} = q_i \\cdot x_j$.\n- A no-trade equilibrium exists if for every agent $i$ and asset $j$, the following conditions hold:\n  - $v_{ij} \\le p_j(1+\\kappa_b^j)$\n  - $v_{ij} \\ge p_j(1-\\kappa_s^j)$\n- These conditions define a price interval for each asset $j$: $p_j \\in \\left[\\max_{i} \\frac{v_{ij}}{1+\\kappa_b^j},\\ \\min_{i} \\frac{v_{ij}}{1-\\kappa_s^j}\\right]$.\n- A no-trade equilibrium price vector exists if and only if this interval is non-empty for all assets $j$.\n- The task is to compute the coordinate-wise midpoint of these intervals if they exist for all assets. If any interval is empty, no equilibrium exists for that test case.\n- The midpoint for asset $j$ is $\\frac{1}{2}\\left(\\max_{i} \\frac{v_{ij}}{1+\\kappa_b^j}+\\min_{i} \\frac{v_{ij}}{1-\\kappa_s^j}\\right)$.\n- Results must be rounded to $6$ decimal places.\n- Test cases provide specific values for $N$, $L$, $K$, $q_i$, $x_j$, $\\kappa_b^j$, and $\\kappa_s^j$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is subjected to validation against the established criteria.\n\n- **Scientifically Grounded**: The model is a standard representation of a financial market with heterogeneous beliefs and transaction costs. The concept of a no-trade equilibrium, where no agent has an incentive to marginally change their portfolio, is a fundamental concept in asset pricing theory. The assumptions, including risk-neutrality, are common simplifications used to derive tractable results. The problem is firmly grounded in computational economics and financial theory.\n- **Well-Posed**: The problem is well-posed. It provides an explicit and unambiguous procedure for determining the existence of a solution and for calculating it if it exists. For each test case, the inputs are fully specified, and the required output is a unique, deterministically computable result.\n- **Objective**: The problem is stated in precise mathematical language, free of any subjective or ambiguous terminology.\n\nThe problem does not exhibit any of the flaws listed in the validation instructions. It is scientifically sound, formalizable, complete, and well-structured.\n\n### Step 3: Verdict and Action\n\nThe problem is deemed **valid**. A solution will be provided.\n\n### Solution\n\nThe solution requires computing, for each asset $j$, the lower and upper bounds of the no-trade price interval and then checking for the existence of an equilibrium. Let the lower bound be $L_j$ and the upper bound be $U_j$.\n$$L_j = \\max_{i=1,\\dots,N} \\left\\{ \\frac{q_i \\cdot x_j}{1+\\kappa_b^j} \\right\\}$$\n$$U_j = \\min_{i=1,\\dots,N} \\left\\{ \\frac{q_i \\cdot x_j}{1-\\kappa_s^j} \\right\\}$$\nA no-trade equilibrium price vector exists if and only if $L_j \\le U_j$ for all assets $j \\in \\{1, \\dots, K\\}$. If this condition is met, the reported equilibrium price for asset $j$ is the midpoint of the interval $[L_j, U_j]$, which is given by:\n$$p_j^* = \\frac{1}{2}(L_j + U_j)$$\nIf for any asset $j$ the condition $L_j > U_j$ holds, the interval is empty, and no such equilibrium exists for the entire economy.\n\nWe now apply this procedure to each test case.\n\n**Case A:**\n- $N=3$, $L=3$, $K=2$.\n- $q_1=(0.2, 0.5, 0.3)$, $q_2=(0.3, 0.4, 0.3)$, $q_3=(0.4, 0.2, 0.4)$.\n- $x_1=(1.0, 0.0, 2.0)$, $x_2=(0.0, 1.0, 1.0)$.\n- $\\kappa_b^1=\\kappa_s^1=0.25$, $\\kappa_b^2=\\kappa_s^2=0.25$.\n\nFor asset $j=1$:\n- $v_{11} = 0.2 \\cdot 1.0 + 0.5 \\cdot 0.0 + 0.3 \\cdot 2.0 = 0.8$.\n- $v_{21} = 0.3 \\cdot 1.0 + 0.4 \\cdot 0.0 + 0.3 \\cdot 2.0 = 0.9$.\n- $v_{31} = 0.4 \\cdot 1.0 + 0.2 \\cdot 0.0 + 0.4 \\cdot 2.0 = 1.2$.\n- The transaction cost factors are $1+\\kappa_b^1=1.25$ and $1-\\kappa_s^1=0.75$.\n- $L_1 = \\max\\left(\\frac{0.8}{1.25}, \\frac{0.9}{1.25}, \\frac{1.2}{1.25}\\right) = \\max(0.64, 0.72, 0.96) = 0.96$.\n- $U_1 = \\min\\left(\\frac{0.8}{0.75}, \\frac{0.9}{0.75}, \\frac{1.2}{0.75}\\right) = \\min(1.066\\dots, 1.2, 1.6) = 1.066\\dots$.\n- Since $L_1 \\le U_1$, the interval is valid.\n- $p_1^* = \\frac{1}{2}(0.96 + 1.066\\dots) = \\frac{1}{2}(2.026\\dots) = 1.013333\\dots$.\n\nFor asset $j=2$:\n- $v_{12} = 0.2 \\cdot 0.0 + 0.5 \\cdot 1.0 + 0.3 \\cdot 1.0 = 0.8$.\n- $v_{22} = 0.3 \\cdot 0.0 + 0.4 \\cdot 1.0 + 0.3 \\cdot 1.0 = 0.7$.\n- $v_{32} = 0.4 \\cdot 0.0 + 0.2 \\cdot 1.0 + 0.4 \\cdot 1.0 = 0.6$.\n- The transaction cost factors are $1+\\kappa_b^2=1.25$ and $1-\\kappa_s^2=0.75$.\n- $L_2 = \\max\\left(\\frac{0.8}{1.25}, \\frac{0.7}{1.25}, \\frac{0.6}{1.25}\\right) = \\max(0.64, 0.56, 0.48) = 0.64$.\n- $U_2 = \\min\\left(\\frac{0.8}{0.75}, \\frac{0.7}{0.75}, \\frac{0.6}{0.75}\\right) = \\min(1.066\\dots, 0.933\\dots, 0.8) = 0.8$.\n- Since $L_2 \\le U_2$, the interval is valid.\n- $p_2^* = \\frac{1}{2}(0.64 + 0.8) = \\frac{1}{2}(1.44) = 0.72$.\n\nThe equilibrium price vector for Case A is approximately $(1.013333, 0.720000)$.\n\n**Case B:**\n- $N=2$, $L=2$, $K=2$.\n- $q_1=(0.5, 0.5)$, $q_2=(0.5, 0.5)$. Beliefs are homogeneous.\n- $x_1=(1.0, 1.0)$, $x_2=(2.0, 0.0)$.\n- $\\kappa_b^1=\\kappa_s^1=0.0$, $\\kappa_b^2=\\kappa_s^2=0.0$. No transaction costs.\n\nFor asset $j=1$:\n- $v_{11} = v_{21} = 0.5 \\cdot 1.0 + 0.5 \\cdot 1.0 = 1.0$.\n- $1+\\kappa_b^1=1.0$, $1-\\kappa_s^1=1.0$.\n- $L_1 = \\max\\left(\\frac{1.0}{1.0}, \\frac{1.0}{1.0}\\right) = 1.0$.\n- $U_1 = \\min\\left(\\frac{1.0}{1.0}, \\frac{1.0}{1.0}\\right) = 1.0$.\n- Interval is $[1.0, 1.0]$, which is valid.\n- $p_1^* = \\frac{1}{2}(1.0 + 1.0) = 1.0$.\n\nFor asset $j=2$:\n- $v_{12} = v_{22} = 0.5 \\cdot 2.0 + 0.5 \\cdot 0.0 = 1.0$.\n- $1+\\kappa_b^2=1.0$, $1-\\kappa_s^2=1.0$.\n- $L_2 = \\max\\left(\\frac{1.0}{1.0}, \\frac{1.0}{1.0}\\right) = 1.0$.\n- $U_2 = \\min\\left(\\frac{1.0}{1.0}, \\frac{1.0}{1.0}\\right) = 1.0$.\n- Interval is $[1.0, 1.0]$, which is valid.\n- $p_2^* = \\frac{1}{2}(1.0 + 1.0) = 1.0$.\n\nThe equilibrium price vector for Case B is $(1.000000, 1.000000)$.\n\n**Case C:**\n- $N=2$, $L=2$, $K=1$.\n- $q_1=(1.0, 0.0)$, $q_2=(0.0, 1.0)$.\n- $x_1=(0.0, 2.0)$.\n- $\\kappa_b^1=\\kappa_s^1=0.01$.\n\nFor asset $j=1$:\n- $v_{11} = 1.0 \\cdot 0.0 + 0.0 \\cdot 2.0 = 0.0$.\n- $v_{21} = 0.0 \\cdot 0.0 + 1.0 \\cdot 2.0 = 2.0$.\n- $1+\\kappa_b^1=1.01$, $1-\\kappa_s^1=0.99$.\n- $L_1 = \\max\\left(\\frac{0.0}{1.01}, \\frac{2.0}{1.01}\\right) = \\frac{2.0}{1.01} \\approx 1.980198$.\n- $U_1 = \\min\\left(\\frac{0.0}{0.99}, \\frac{2.0}{0.99}\\right) = \\frac{0.0}{0.99} = 0.0$.\n- Since $L_1 > U_1$, the interval is empty.\n\nA no-trade equilibrium does not exist for Case C.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the no-trade equilibrium price vector for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"q\": np.array([[0.2, 0.5, 0.3], [0.3, 0.4, 0.3], [0.4, 0.2, 0.4]]),\n            \"x\": np.array([[1.0, 0.0, 2.0], [0.0, 1.0, 1.0]]),\n            \"kappa_b\": np.array([0.25, 0.25]),\n            \"kappa_s\": np.array([0.25, 0.25]),\n        },\n        {\n            \"q\": np.array([[0.5, 0.5], [0.5, 0.5]]),\n            \"x\": np.array([[1.0, 1.0], [2.0, 0.0]]),\n            \"kappa_b\": np.array([0.0, 0.0]),\n            \"kappa_s\": np.array([0.0, 0.0]),\n        },\n        {\n            \"q\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"x\": np.array([[0.0, 2.0]]),\n            \"kappa_b\": np.array([0.01]),\n            \"kappa_s\": np.array([0.01]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        Q = case[\"q\"]\n        X = case[\"x\"]\n        kappa_b = case[\"kappa_b\"]\n        kappa_s = case[\"kappa_s\"]\n        \n        # N = number of agents, K = number of assets\n        N, _ = Q.shape\n        K, _ = X.shape\n\n        # Calculate subjective values v_ij = q_i . x_j\n        # V is an (N x K) matrix\n        V = Q @ X.T\n        \n        equilibrium_prices = []\n        equilibrium_exists = True\n        \n        for j in range(K):\n            v_j = V[:, j] # Subjective values for asset j across all agents\n            \n            # Lower bound of the price interval for asset j\n            lower_bound = np.max(v_j / (1.0 + kappa_b[j]))\n            \n            # Upper bound of the price interval for asset j\n            upper_bound = np.min(v_j / (1.0 - kappa_s[j]))\n            \n            # Check if the interval is non-empty\n            if lower_bound > upper_bound:\n                equilibrium_exists = False\n                break\n            \n            # Calculate the midpoint price\n            midpoint_price = 0.5 * (lower_bound + upper_bound)\n            equilibrium_prices.append(midpoint_price)\n            \n        if equilibrium_exists:\n            results.append(equilibrium_prices)\n        else:\n            results.append([])\n\n    # Format the final output string as per the problem specification.\n    # e.g., \"[[p11,p12],[p21,p22],[]]\"\n    output_parts = []\n    for result_case in results:\n        if not result_case:\n            output_parts.append(\"[]\")\n        else:\n            # Format each price to 6 decimal places.\n            formatted_prices = [f\"{p:.6f}\" for p in result_case]\n            output_parts.append(f\"[{','.join(formatted_prices)}]\")\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"}]}