{
    "hands_on_practices": [
        {
            "introduction": "在实施任何数值方案之前，从理论上理解其固有的精度限制至关重要。本练习引导您通过一项基本的理论分析，揭示为何两种经典的投影法——Chorin法和Temam法——在压力精度上表现出显著差异。通过推导，您将发现分裂误差（splitting error）以及施加在压力泊松方程上的人为边界条件是如何深刻影响数值解的收敛阶的 。",
            "id": "3435342",
            "problem": "考虑在单位平方域 $\\Omega=(0,1)^{2}$ 上定义的、带有齐次无滑移边界条件的非定常不可压缩 Stokes 方程：\n$$\n\\partial_{t}\\boldsymbol{u} - \\nu \\Delta \\boldsymbol{u} + \\nabla p = \\boldsymbol{f}, \\qquad \\nabla \\cdot \\boldsymbol{u} = 0 \\quad \\text{in } \\Omega \\times (0,T], \\qquad \\boldsymbol{u}|_{\\partial\\Omega}=\\boldsymbol{0},\n$$\n其中 $\\boldsymbol{u}(\\boldsymbol{x},t)$ 是速度场，$p(\\boldsymbol{x},t)$ 是压力，$\\nu>0$ 是运动粘度，$\\boldsymbol{f}$ 是一个足够光滑的体积力，其选择使得精确解 $(\\boldsymbol{u},p)$ 在 $\\overline{\\Omega}\\times[0,T]$ 上是光滑的。假设我们进行半离散（时间上）分析，其中空间算子和边界条件被精确施加（即没有空间离散误差）。设 $\\Delta t>0$ 为均匀时间步长，并定义 $t^{n}=n\\Delta t$。\n\n考虑两种使用一阶时间步长的经典投影方法：\n\n1. 非增量压力修正法 (Chorin)。该方法通过以下步骤从 $\\boldsymbol{u}^{n}$ 推进到 $\\boldsymbol{u}^{n+1}$：首先，通过一个不含压力的向后欧拉粘性步计算中间速度 $\\boldsymbol{v}^{n+1}$，\n$$\n\\frac{\\boldsymbol{v}^{n+1}-\\boldsymbol{u}^{n}}{\\Delta t} - \\nu \\Delta \\boldsymbol{v}^{n+1} = \\boldsymbol{f}^{n+1}, \\qquad \\boldsymbol{v}^{n+1}|_{\\partial\\Omega}=\\boldsymbol{0},\n$$\n然后求解一个关于投影势 $\\phi^{n+1}$ 的标量泊松方程，\n$$\n\\Delta \\phi^{n+1} = \\frac{1}{\\Delta t} \\nabla \\cdot \\boldsymbol{v}^{n+1} \\quad \\text{in } \\Omega, \\qquad \\frac{\\partial \\phi^{n+1}}{\\partial n}\\Big|_{\\partial\\Omega}=0,\n$$\n并更新\n$$\n\\boldsymbol{u}^{n+1} = \\boldsymbol{v}^{n+1} - \\Delta t \\nabla \\phi^{n+1}, \\qquad p^{n+1} = \\phi^{n+1}.\n$$\n\n2. 增量压力修正法 (Temam)。该方法通过以下步骤从 $(\\boldsymbol{u}^{n},p^{n})$ 推进：首先，通过一个带有前一时刻压力的向后欧拉粘性步计算 $\\boldsymbol{v}^{n+1}$，\n$$\n\\frac{\\boldsymbol{v}^{n+1}-\\boldsymbol{u}^{n}}{\\Delta t} - \\nu \\Delta \\boldsymbol{v}^{n+1} + \\nabla p^{n} = \\boldsymbol{f}^{n+1}, \\qquad \\boldsymbol{v}^{n+1}|_{\\partial\\Omega}=\\boldsymbol{0},\n$$\n然后求解 $\\phi^{n+1}$，\n$$\n\\Delta \\phi^{n+1} = \\frac{1}{\\Delta t} \\nabla \\cdot \\boldsymbol{v}^{n+1} \\quad \\text{in } \\Omega, \\qquad \\frac{\\partial \\phi^{n+1}}{\\partial n}\\Big|_{\\partial\\Omega}=0,\n$$\n并更新\n$$\n\\boldsymbol{u}^{n+1} = \\boldsymbol{v}^{n+1} - \\Delta t \\nabla \\phi^{n+1}, \\qquad p^{n+1} = p^{n} + \\phi^{n+1}.\n$$\n\n假设 $\\boldsymbol{u}$ 和 $p$ 在时间和空间上足够光滑，并且边界数据与 Stokes 问题一致，其中 $\\boldsymbol{u}|_{\\partial\\Omega}=\\boldsymbol{0}$ 精确成立。\n\n对每种格式，使用第一性原理的一致性和稳定性推理，确定当 $\\Delta t \\to 0$ 时，速度和压力在 $L^{2}(\\Omega)$ 范数下的预期时间精度阶。令 $\\alpha_{C}$ 和 $\\beta_{C}$ 分别表示 Chorin 方法下速度 $\\boldsymbol{u}$ 和压力 $p$ 的时间阶，令 $\\alpha_{T}$ 和 $\\beta_{T}$ 表示 Temam 方法下对应的阶。将你的最终答案表示为行矩阵 $(\\alpha_{C},\\beta_{C},\\alpha_{T},\\beta_{T})$。不需要四舍五入，最终答案中也不应包含任何物理单位。",
            "solution": "每种投影方法的速度和压力的时间精度阶是通过一致性分析确定的，这涉及到计算每种格式的局部截断误差。我们假设这些一阶投影方法的稳定性成立，根据 Lax-Richtmyer 等价定理，这意味着全局误差的阶数与局部截断误差的阶数相同。\n\n**1. 非增量压力修正法 (Chorin)**\n\n该格式包括三个步骤：\n1.  粘性步： $\\frac{\\boldsymbol{v}^{n+1}-\\boldsymbol{u}^{n}}{\\Delta t} - \\nu \\Delta \\boldsymbol{v}^{n+1} = \\boldsymbol{f}^{n+1}, \\quad \\boldsymbol{v}^{n+1}|_{\\partial\\Omega}=\\boldsymbol{0}.$\n2.  泊松方程： $\\Delta \\phi^{n+1} = \\frac{1}{\\Delta t} \\nabla \\cdot \\boldsymbol{v}^{n+1}, \\quad \\frac{\\partial \\phi^{n+1}}{\\partial n}\\Big|_{\\partial\\Omega}=0.$\n3.  更新： $\\boldsymbol{u}^{n+1} = \\boldsymbol{v}^{n+1} - \\Delta t \\nabla \\phi^{n+1}, \\quad p^{n+1} = \\phi^{n+1}.$\n\n该格式的关键在于对压力的处理。数值压力 $p^{n+1}$ 被设为势 $\\phi^{n+1}$。$\\phi^{n+1}$ 的边界条件是通过在边界上强制施加无穿透条件 ($\\boldsymbol{u}^{n+1}\\cdot\\boldsymbol{n}=0$) 推导出来的。从更新步骤可知，$\\boldsymbol{u}^{n+1}\\cdot\\boldsymbol{n} = \\boldsymbol{v}^{n+1}\\cdot\\boldsymbol{n} - \\Delta t \\nabla\\phi^{n+1}\\cdot\\boldsymbol{n}$。由于 $\\boldsymbol{u}^{n+1}$ 和 $\\boldsymbol{v}^{n+1}$ 在边界上均为零，它们的法向分量也为零。这导致 $\\Delta t \\nabla\\phi^{n+1}\\cdot\\boldsymbol{n} = 0$，即意味着人为的边界条件 $\\frac{\\partial \\phi^{n+1}}{\\partial n} = 0$。由于 $p^{n+1} = \\phi^{n+1}$，该格式隐式地施加了 $\\frac{\\partial p^{n+1}}{\\partial n}\\Big|_{\\partial\\Omega}=0$。\n\n让我们将此与精确压力 $p(\\boldsymbol{x},t)$ 满足的边界条件进行比较。通过在边界 $\\partial\\Omega$ 上（其中 $\\boldsymbol{u}=\\boldsymbol{0}$，因此 $\\partial_t \\boldsymbol{u} = \\boldsymbol{0}$）评估精确的动量方程，我们得到：\n$$-\\nu \\Delta \\boldsymbol{u} + \\nabla p = \\boldsymbol{f} \\quad \\text{on } \\partial\\Omega.$$\n与外法向向量 $\\boldsymbol{n}$ 作点积，得到压力的精确诺伊曼边界条件：\n$$\\frac{\\partial p}{\\partial n} = \\boldsymbol{n} \\cdot (\\boldsymbol{f} + \\nu \\Delta \\boldsymbol{u}) \\quad \\text{on } \\partial\\Omega.$$\n这个表达式通常不为零。因此，该格式对压力施加的边界条件与精确压力的边界条件不一致。诺伊曼数据中的误差是 $O(1)$。这种 $O(1)$ 的不一致性在压力解中产生了一个数值边界层。严格的分析表明，该边界层的厚度为 $O(\\sqrt{\\nu\\Delta t})$，并导致 $L^2(\\Omega)$ 范数下的全局误差尺度为 $O(\\sqrt{\\Delta t})$。因此，压力的精度阶为 $\\beta_C = 1/2$。\n\n现在，我们来分析速度误差。速度的局部截断误差 $\\boldsymbol{e}_{u}^{n+1} = \\boldsymbol{u}_{num}^{n+1} - \\boldsymbol{u}_{exact}(t^{n+1})$ 可以通过将精确解代入格式中进行分析。分析表明，中间速度误差为 $\\boldsymbol{v}^{n+1} - \\boldsymbol{u}(t^{n+1}) = \\Delta t \\nabla p(t^{n+1}) + O((\\Delta t)^2)$。速度更新为 $\\boldsymbol{u}^{n+1} = \\boldsymbol{v}^{n+1} - \\Delta t\\nabla \\phi^{n+1}$。于是局部误差为：\n$$\\boldsymbol{u}^{n+1} - \\boldsymbol{u}(t^{n+1}) = (\\boldsymbol{v}^{n+1} - \\boldsymbol{u}(t^{n+1})) - \\Delta t \\nabla \\phi^{n+1} \\approx \\Delta t \\nabla p(t^{n+1}) - \\Delta t \\nabla \\phi^{n+1} = \\Delta t \\nabla (p(t^{n+1}) - \\phi^{n+1}).$$\n项 $\\nabla(p(t^{n+1}) - \\phi^{n+1})$ 是压力误差的梯度。尽管压力误差本身在边界附近很大，但其梯度在 $L^2$ 范数下被发现是有界的，即 $\\|\\nabla(p - \\phi)\\|_{L^2} = O(1)$。因此，速度的局部截断误差为 $O(\\Delta t)$。对于一个稳定的格式，这会产生一阶的全局速度精度。因此，$\\alpha_C = 1$。\n\n总而言之，对于非增量 Chorin 方法，我们有 $(\\alpha_C, \\beta_C) = (1, 1/2)$。\n\n**2. 增量压力修正法 (Temam)**\n\n该格式包括三个步骤：\n1.  粘性步：$\\frac{\\boldsymbol{v}^{n+1}-\\boldsymbol{u}^{n}}{\\Delta t} - \\nu \\Delta \\boldsymbol{v}^{n+1} + \\nabla p^{n} = \\boldsymbol{f}^{n+1}, \\quad \\boldsymbol{v}^{n+1}|_{\\partial\\Omega}=\\boldsymbol{0}.$\n2.  泊松方程：$\\Delta \\phi^{n+1} = \\frac{1}{\\Delta t} \\nabla \\cdot \\boldsymbol{v}^{n+1}, \\quad \\frac{\\partial \\phi^{n+1}}{\\partial n}\\Big|_{\\partial\\Omega}=0.$\n3.  更新：$\\boldsymbol{u}^{n+1} = \\boldsymbol{v}^{n+1} - \\Delta t \\nabla \\phi^{n+1}, \\quad p^{n+1} = p^{n} + \\phi^{n+1}.$\n\n关键的区别在于粘性步中包含了 $\\nabla p^n$ 项以及对压力的增量式更新。我们来分析压力 $p^{n+1}$ 的边界条件。和之前一样，投影需要 $\\frac{\\partial\\phi^{n+1}}{\\partial n}=0$。从压力更新步骤可知，这意味着：\n$$\\frac{\\partial p^{n+1}}{\\partial n}\\Big|_{\\partial\\Omega} = \\frac{\\partial p^{n}}{\\partial n}\\Big|_{\\partial\\Omega} + \\frac{\\partial \\phi^{n+1}}{\\partial n}\\Big|_{\\partial\\Omega} = \\frac{\\partial p^{n}}{\\partial n}\\Big|_{\\partial\\Omega}.$$\n该格式对压力施加了一个滞后的边界条件。让我们在时间 $t^{n+1}$ 评估这个边界条件的误差。假设在时间 $t^n$ 时数值解是准确的，即 $\\frac{\\partial p^n}{\\partial n} \\approx \\frac{\\partial p(t^n)}{\\partial n}$，则诺伊曼数据中的误差为：\n$$\\frac{\\partial p^n}{\\partial n} - \\frac{\\partial p(t^{n+1})}{\\partial n} \\approx \\frac{\\partial p(t^n)}{\\partial n} - \\frac{\\partial p(t^{n+1})}{\\partial n} = -\\left( \\frac{\\partial p(t^{n+1})}{\\partial n} - \\frac{\\partial p(t^n)}{\\partial n} \\right) = - \\Delta t \\frac{\\partial}{\\partial t}\\left(\\frac{\\partial p}{\\partial n}\\right) + O((\\Delta t)^2).$$\n压力边界条件的误差是 $O(\\Delta t)$。对于像压力泊松方程这样的椭圆方程，诺伊曼数据中 $O(\\Delta t)$ 的误差会导致在整个区域上的解有 $O(\\Delta t)$ 的误差。因此，压力的局部截断误差是 $O(\\Delta t)$，全局精度是一阶的。所以，$\\beta_T = 1$。\n\n对于速度，我们可以结合格式的方程来找出其內在的一致性误差。结果是，增量格式等价于一个完全耦合的 Stokes 方程向后欧拉离散化，外加一个分裂误差项。这个分裂误差的形式为 $\\nu \\Delta t \\Delta(\\nabla(p^{n+1}-p^n))$。由于 $p^{n+1}-p^n \\approx \\Delta t \\frac{\\partial p}{\\partial t}$，这个分裂误差是 $O((\\Delta t)^2)$。主要的时间误差来自于对 $\\partial_t\\boldsymbol{u}$ 的一阶向后欧拉离散化，其截断误差为 $O(\\Delta t)$。因此，速度的总局部截断误差为 $O(\\Delta t)$，从而得到一阶精度的速度解。因此，$\\alpha_T = 1$。\n\n总而言之，对于增量 Temam 方法，我们有 $(\\alpha_T, \\beta_T) = (1, 1)$。\n\n**结论**\n\n结合两种格式的结果，时间精度阶为：\n-   Chorin 的非增量方法： $(\\alpha_C, \\beta_C) = (1, 1/2)$。\n-   Temam 的增量方法： $(\\alpha_T, \\beta_T) = (1, 1)$。\n\n最终答案是行矩阵 $(\\alpha_{C}, \\beta_{C}, \\alpha_{T}, \\beta_{T})$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  \\frac{1}{2}  1  1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "将理论知识转化为实际代码是掌握计算方法的关键一步。本练习要求您为一个周期性域上的斯托克斯流（Stokes flow）问题，实现增量和非增量两种投影方法的核心算法步骤 。通过在傅里叶空间中进行计算，空间导数的处理被大大简化，使您能更专注于理解预测-校正（predictor-corrector）的逻辑以及泊松方程在强制执行无散度约束中的核心作用。",
            "id": "3322008",
            "problem": "考虑二维不可压缩 Stokes 方程，其定义在一个边长为 $L$ 的周期性方形区域上，空间坐标为 $(x,y)$，所有物理量均为无量纲：\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} = -\\nabla p + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{f}, \\quad \\nabla \\cdot \\mathbf{u} = 0,\n$$\n其中 $\\mathbf{u}(x,y,t)$ 为速度，$p(x,y,t)$ 为压力，$\\nu$ 为运动粘度，$\\mathbf{f}(x,y,t)$ 为体积力。目标是设计并实现两种不同的分数步长投影法的一个时间步：\n1. 一种速度修正（增量压力投影）方案。\n2. 一种标准压力修正（非增量）方案。\n\n两种方案都必须从上述控制方程的基本原理和向量场的 Helmholtz 分解（分解为无散度部分和梯度部分）出发进行推导和实现，确保在时间步结束时满足无散度约束。该区域是周期性的，因此空间离散化應遵循周期性边界条件。使用 Fourier 谱表示（在均匀网格上的离散 Fourier 变换）来计算空间导数、梯度、散度，并求解投影步骤中出现的标量 Poisson 问题。\n\n在单个程序中实现以下内容：\n- 对每个测试用例，将区域表示为 $[0,2\\pi] \\times [0,2\\pi]$，并使用均匀的 $N \\times N$ 网格。\n- 使用从 $t^n$ 到 $t^{n+1} = t^n + \\Delta t$ 的单个显式时间步。\n- 对于速度修正方案，通过显式地包含旧的压力梯度来构造中间速度，然后通过标量势修正来强制实现不可压缩性。增量更新压力。\n- 对于标准压力修正方案，构造不含任何压力项的中间速度，然后通过求解标量压力来强制实现不可压缩性，并以非增量方式更新压力。\n- 通过对压力施加零均值约束（将压力的零波数分量设置为零），在 Fourier 空间中求解所需的周期性 Poisson 问题。\n- 对每个测试用例，量化以下指标：\n  1. 在 $t^{n+1}$ 时刻，速度修正方案得到的修正后速度的散度的 $L^2$ 范数。\n  2. 在 $t^{n+1}$ 时刻，压力修正方案得到的修正后速度的散度的 $L^2$ 范数。\n  3. 对于速度修正方案，更新后的压力与旧压力加上标量修正之和之间的差值的 $L^2$ 范数（此项用于评估增量方法所使用的压力更新公式）。\n  4. 对于压力修正方案，更新后的压力与标量修正之间的差值的 $L^2$ 范数（此项用于评估非增量方法所使用的压力更新公式）。\n  5. 两种方案产生的更新后压力之间的差值的 $L^2$ 范数。\n\n从时间 $t^n$ 时的以下解析场（所有量均为无量纲）开始，并在网格上进行求值：\n- 初始速度分量：\n  $$\n  u_x^n(x,y) = \\sin(x)\\cos(y) + 0.25 \\sin(3x)\\sin(2y), \\quad\n  u_y^n(x,y) = -\\cos(x)\\sin(y) + 0.25 \\cos(2x)\\sin(3y).\n  $$\n- 初始压力（对于非零初始压力的情形）：\n  $$\n  p^n(x,y) = \\cos(2x)\\sin(y).\n  $$\n  对于零初始压力的情形，使用 $p^n(x,y) = 0$。\n- 体积力：\n  $$\n  f_x(x,y) = 0.1 \\cos(2x)\\cos(2y), \\quad\n  f_y(x,y) = -0.1 \\sin(2x)\\sin(2y).\n  $$\n  对于零体积力的情形，使用 $\\mathbf{f}(x,y) = \\mathbf{0}$。\n\n使用离散 Fourier 变换计算空间算子。令 $k_x$ 和 $k_y$ 为与网格上离散 Fourier 模式相关的角波数，并在整个周期域上一致地使用 Fourier 关系式计算梯度、散度和拉普拉斯算子。通过将零波数处的 Fourier 系数设置为0来对压力强制施加零均值。\n\n测试套件：\n为以下四个测试用例实现程序，每个用例由元组 $(N, \\Delta t, \\nu, p\\_zero, f\\_zero)$ 指定：\n1. $(32, 0.05, 0.1, \\text{False}, \\text{False})$。\n2. $(32, 0.001, 0.5, \\text{False}, \\text{False})$。\n3. $(32, 0.2, 0.01, \\text{False}, \\text{True})$。\n4. $(32, 0.1, 0.1, \\text{True}, \\text{False})$。\n\n对于每个测试用例：\n- 构建场 $u_x^n$、$u_y^n$、$p^n$（按指定为非零或零）和 $\\mathbf{f}$（按指定为非零或零）。\n- 使用两种方案执行一个时间步，通过投影强制实现不可压缩性。\n- 将上述枚举的量计算为实数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，输出一个包含五个浮点数的列表，顺序如下：\n$[ \\| \\nabla \\cdot \\mathbf{u}^{n+1}\\|_{2,\\text{速度修正}}, \\| \\nabla \\cdot \\mathbf{u}^{n+1}\\|_{2,\\text{压力修正}}, \\| p^{n+1} - (p^n + \\phi)\\|_{2,\\text{速度修正}}, \\| p^{n+1} - \\phi\\|_{2,\\text{压力修正}}, \\| p^{n+1}_{\\text{速度修正}} - p^{n+1}_{\\text{压力修正}} \\|_{2} ]$,\n然后将所有测试用例的结果顺序聚合到一个扁平列表中。例如，输出格式为\n$[r_{1,1}, r_{1,2}, r_{1,3}, r_{1,4}, r_{1,5}, r_{2,1}, \\dots, r_{4,5}]$,\n其中每个 $r_{i,j}$ 都是一个浮点数。由于问题是无量纲的，因此不需要物理单位；由于域 $[0,2\\pi]^2$ 上的周期性三角函数，角度以弧度为单位。",
            "solution": "该问题要求在双周期域上实现并比较两种用于二维不可压缩 Stokes 方程的分数步长投影法。空间离散化将使用 Fourier 谱方法处理，这对于周期性问题是很自然的方法。我们将使用粘性项显式的公式来执行单个时间步。\n\n控制 Stokes 方程为：\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} = -\\nabla p + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{f} \\quad (1)\n$$\n$$\n\\nabla \\cdot \\mathbf{u} = 0 \\quad (2)\n$$\n其中 $\\mathbf{u}$ 是速度，$p$ 是压力，$\\nu$ 是运动粘度，$\\mathbf{f}$ 是体积力。区域为 $[0, 2\\pi] \\times [0, 2\\pi]$。\n\n使用对粘性项和力项采用显式 Euler 方法以及对压力梯度采用隐式方法的半离散形式为：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = -\\nabla p^{n+1} + \\nu \\nabla^2 \\mathbf{u}^n + \\mathbf{f}^n\n$$\n$$\n\\nabla \\cdot \\mathbf{u}^{n+1} = 0\n$$\n这个耦合系统使用投影法求解，该方法将速度和压力的更新解耦。\n\n**空间离散化：Fourier 谱方法**\n对于 $N \\times N$ 网格上的周期函数，我们使用离散 Fourier 变换 (DFT)。在 Fourier 空间中，空间微分算子变成代数乘法。令 $\\hat{g}(\\mathbf{k}) = \\mathcal{F}(g(\\mathbf{x}))$ 为场 $g$ 的 DFT，其中 $\\mathbf{k} = (k_x, k_y)$ 是波数向量。\n- 梯度：$\\mathcal{F}(\\nabla g) = i\\mathbf{k} \\hat{g}$\n- 散度：$\\mathcal{F}(\\nabla \\cdot \\mathbf{v}) = i\\mathbf{k} \\cdot \\hat{\\mathbf{v}}$\n- 拉普拉斯算子：$\\mathcal{F}(\\nabla^2 g) = -|\\mathbf{k}|^2 \\hat{g} = -(k_x^2 + k_y^2) \\hat{g}$\n\n投影步的核心是求解一个形如 $\\nabla^2 \\phi = S$ 的 Poisson 方程。在 Fourier 空间中，这变成 $-|\\mathbf{k}|^2 \\hat{\\phi} = \\hat{S}$，其解为 $\\hat{\\phi} = -\\hat{S} / |\\mathbf{k}|^2$。对于直流分量（$k_x=k_y=0$），$|\\mathbf{k}|^2=0$。通过对 $\\phi$ 施加零均值约束来获得唯一解，这等同于将其直流 Fourier 系数 $\\hat{\\phi}(0,0)$ 设置为0。这是自洽的，因为对于一个周期域上向量场的散度作为源项 $S$ 时，其 $\\hat{S}(0,0)$ 也将为零。\n\n**1. 速度修正（增量压力）方案**\n\n该方案将前一时间步的压力梯度納入中间速度场 $\\mathbf{u}^*$ 的预测中。\n\n**步骤 1：预测步。** 通过使用旧压力 $p^n$ 对完整动量方程进行时间步进，计算出中间速度 $\\mathbf{u}^*$：\n$$\n\\frac{\\mathbf{u}^* - \\mathbf{u}^n}{\\Delta t} = -\\nabla p^n + \\nu \\nabla^2 \\mathbf{u}^n + \\mathbf{f}^n\n$$\n在 Fourier 空间中，这表示为：\n$$\n\\hat{\\mathbf{u}}^* = \\hat{\\mathbf{u}}^n + \\Delta t (-i\\mathbf{k}\\hat{p}^n - \\nu |\\mathbf{k}|^2\\hat{\\mathbf{u}}^n + \\hat{\\mathbf{f}}^n)\n$$\n\n**步骤 2：投影步。** 场 $\\mathbf{u}^*$ 通常不是无散度的。它被投影到无散度场的空间上。这是通过找到一个标量势 $\\phi$ 来实现的，减去它的梯度可以修正速度。修正是由以下公式定义的：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^*}{\\Delta t} = -\\nabla \\phi\n$$\n对此方程强制施加不可压缩约束 $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$ 会得到关于 $\\phi$ 的一个 Poisson 方程：\n$$\n\\nabla^2 \\phi = \\frac{1}{\\Delta t} \\nabla \\cdot \\mathbf{u}^*\n$$\n我们在 Fourier 空间中求解此方程：\n$$\n\\hat{\\phi} = -\\frac{1}{\\Delta t |\\mathbf{k}|^2} (i\\mathbf{k} \\cdot \\hat{\\mathbf{u}}^*)\n$$\n其中 $\\hat{\\phi}(0,0) = 0$。\n\n**步骤 3：速度修正与压力更新。** 最终速度通过应用该修正来计算：\n$$\n\\hat{\\mathbf{u}}^{n+1} = \\hat{\\mathbf{u}}^* - \\Delta t (i\\mathbf{k}\\hat{\\phi})\n$$\n压力是增量更新的：\n$$\np^{n+1} = p^n + \\phi\n$$\n问题要求通过计算 $\\| p^{n+1} - (p^n + \\phi) \\|_{2}$ 来验证这个定义，其结果应为机器精度级别的零。\n\n**2. 标准压力修正（非增量）方案**\n\n这种经典方案在预测步中省略了压力梯度。\n\n**步骤 1：预测步。** 计算一个不含任何压力项的中间速度 $\\mathbf{u}^*$：\n$$\n\\frac{\\mathbf{u}^* - \\mathbf{u}^n}{\\Delta t} = \\nu \\nabla^2 \\mathbf{u}^n + \\mathbf{f}^n\n$$\n在 Fourier 空间中：\n$$\n\\hat{\\mathbf{u}}^* = \\hat{\\mathbf{u}}^n + \\Delta t (-\\nu |\\mathbf{k}|^2\\hat{\\mathbf{u}}^n + \\hat{\\mathbf{f}}^n)\n$$\n\n**步骤 2：投影步。** 修正步使用一个标量势，现在该势被视为新的压力 $p^{n+1}$（或其缩放版本）。该步骤的控制方程是：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^*}{\\Delta t} = -\\nabla p^{n+1}, \\quad \\nabla \\cdot \\mathbf{u}^{n+1} = 0\n$$\n这导致了在时间 $t^{n+1}$ 时的压力 Poisson 方程：\n$$\n\\nabla^2 p^{n+1} = \\frac{1}{\\Delta t} \\nabla \\cdot \\mathbf{u}^*\n$$\n在问题的表示法中，我们求解一个标量 $\\phi$，然后令 $p^{n+1}=\\phi$。在 Fourier 空间中的解是：\n$$\n\\hat{\\phi} = \\hat{p}^{n+1} = -\\frac{1}{\\Delta t |\\mathbf{k}|^2} (i\\mathbf{k} \\cdot \\hat{\\mathbf{u}}^*)\n$$\n其中 $\\hat{\\phi}(0,0) = 0$。\n\n**步骤 3：速度修正与压力更新。** 最终速度是：\n$$\n\\hat{\\mathbf{u}}^{n+1} = \\hat{\\mathbf{u}}^* - \\Delta t (i\\mathbf{k}\\hat{p}^{n+1})\n$$\n压力更新是非增量的；新的压力就是投影步中找到的势 $\\phi$：\n$$\np^{n+1} = \\phi\n$$\n问题通过要求计算 $\\| p^{n+1} - \\phi \\|_{2}$ 来验证这一点。\n\n**对于 Stokes 流动的方案等价性**\n此问题的一个关键见解是，对于采用这种显式时间步长的线性 Stokes 方程，只要初始压力场 $p^n$ 的均值为零，这两种方案对速度和压力都会产生相同的结果。指定的 $p^n(x,y) = \\cos(2x)\\sin(y)$ 在周期域上的均值为零。因此，所有计算出的范数预计仅由于浮点数值误差而非零，并且应该在机器精度的数量级上。根据构造，两种方案得到的最终速度场都将在机器精度内是无散度的。\n\n**实现摘要**\n对于每个测试用例：\n1. 构建 $N \\times N$ 网格、初始场 $\\mathbf{u}^n$、$p^n$、$\\mathbf{f}^n$ 以及波数数组 $k_x, k_y$。\n2. 计算所有初始场的二维 DFT。\n3. 如上所述，为两种方案执行预测、投影和修正步骤，在 Fourier 空间中执行所有微积分运算。\n4. 计算所需的五个 $L^2$ 范数。在边长为 $L=2\\pi$ 的域上，$N \\times N$ 网格上的离散场 $g_{ij}$ 的 $L^2$ 范数计算公式为 $\\|g\\|_{2} = (L/N)\\sqrt{\\sum_{i,j} |g_{ij}|^2}$。\n5. 收集结果并将其格式化为单个扁平列表。",
            "answer": "```python\nimport numpy as np\n\ndef l2_norm(field, L, N):\n    \"\"\"\n    Computes the discrete L2 norm of a 2D field on a periodic domain of side L.\n    \"\"\"\n    return (L / N) * np.linalg.norm(field)\n\ndef solve_for_test_case(N, dt, nu, p_zero, f_zero):\n    \"\"\"\n    Performs one time step of two projection methods for the 2D Stokes equations.\n    \"\"\"\n    L = 2.0 * np.pi\n    h = L / N\n    \n    # Create grid and wavenumbers\n    x = np.arange(N) * h\n    xx, yy = np.meshgrid(x, x, indexing='ij')\n    \n    k = np.fft.fftfreq(N, d=1.0/N) # Angular wavenumbers\n    kx, ky = np.meshgrid(k, k, indexing='ij')\n    k_sq = kx**2 + ky**2\n    \n    # Inverse Laplacian operator in Fourier space (k_sq_inv)\n    # Handle the k=0 case to prevent division by zero, enforcing zero-mean for phi.\n    k_sq_inv = np.zeros_like(k_sq)\n    k_sq_inv[k_sq > 0] = 1.0 / k_sq[k_sq > 0]\n\n    # --- Initial fields ---\n    ux_n = np.sin(xx) * np.cos(yy) + 0.25 * np.sin(3 * xx) * np.sin(2 * yy)\n    uy_n = -np.cos(xx) * np.sin(yy) + 0.25 * np.cos(2 * xx) * np.sin(3 * yy)\n    \n    if p_zero:\n        p_n = np.zeros((N, N))\n    else:\n        p_n = np.cos(2 * xx) * np.sin(yy)\n        \n    if f_zero:\n        fx = np.zeros((N, N))\n        fy = np.zeros((N, N))\n    else:\n        fx = 0.1 * np.cos(2 * xx) * np.cos(2 * yy)\n        fy = -0.1 * np.sin(2 * xx) * np.sin(2 * yy)\n\n    # FFT of initial fields\n    ux_hat_n = np.fft.fft2(ux_n)\n    uy_hat_n = np.fft.fft2(uy_n)\n    p_hat_n = np.fft.fft2(p_n)\n    fx_hat = np.fft.fft2(fx)\n    fy_hat = np.fft.fft2(fy)\n\n    # --- 1. Velocity-Correction (Incremental) Scheme ---\n    \n    # Predictor step\n    rhs_x_hat = -1j * kx * p_hat_n - nu * k_sq * ux_hat_n + fx_hat\n    rhs_y_hat = -1j * ky * p_hat_n - nu * k_sq * uy_hat_n + fy_hat\n    ux_star_hat_vc = ux_hat_n + dt * rhs_x_hat\n    uy_star_hat_vc = uy_hat_n + dt * rhs_y_hat\n    \n    # Poisson solve for phi\n    div_u_star_hat_vc = 1j * kx * ux_star_hat_vc + 1j * ky * uy_star_hat_vc\n    phi_hat_vc = (-1.0 / dt) * div_u_star_hat_vc * k_sq_inv\n    \n    # Velocity correction\n    ux_hat_n1_vc = ux_star_hat_vc - dt * (1j * kx * phi_hat_vc)\n    uy_hat_n1_vc = uy_star_hat_vc - dt * (1j * ky * phi_hat_vc)\n    \n    # Pressure update\n    p_hat_n1_vc = p_hat_n + phi_hat_vc\n    \n    # --- 2. Standard Pressure-Correction (Non-Incremental) Scheme ---\n\n    # Predictor step\n    rhs_x_hat_pc = -nu * k_sq * ux_hat_n + fx_hat\n    rhs_y_hat_pc = -nu * k_sq * uy_hat_n + fy_hat\n    ux_star_hat_pc = ux_hat_n + dt * rhs_x_hat_pc\n    uy_star_hat_pc = uy_hat_n + dt * rhs_y_hat_pc\n    \n    # Poisson solve for phi (which is p^{n+1})\n    div_u_star_hat_pc = 1j * kx * ux_star_hat_pc + 1j * ky * uy_star_hat_pc\n    p_hat_n1_pc = (-1.0 / dt) * div_u_star_hat_pc * k_sq_inv\n    phi_hat_pc = p_hat_n1_pc\n    \n    # Velocity correction\n    ux_hat_n1_pc = ux_star_hat_pc - dt * (1j * kx * p_hat_n1_pc)\n    uy_hat_n1_pc = uy_star_hat_pc - dt * (1j * ky * p_hat_n1_pc)\n    \n    # --- Calculate Metrics ---\n    \n    # 1. Divergence norm for velocity-correction\n    div_u_n1_hat_vc = 1j * kx * ux_hat_n1_vc + 1j * ky * uy_hat_n1_vc\n    div_u_n1_vc = np.fft.ifft2(div_u_n1_hat_vc).real\n    norm1 = l2_norm(div_u_n1_vc, L, N)\n\n    # 2. Divergence norm for pressure-correction\n    div_u_n1_hat_pc = 1j * kx * ux_hat_n1_pc + 1j * ky * uy_hat_n1_pc\n    div_u_n1_pc = np.fft.ifft2(div_u_n1_hat_pc).real\n    norm2 = l2_norm(div_u_n1_pc, L, N)\n    \n    # 3. Pressure update consistency for velocity-correction\n    p_n1_vc = np.fft.ifft2(p_hat_n1_vc).real\n    phi_vc = np.fft.ifft2(phi_hat_vc).real\n    diff3 = p_n1_vc - (p_n + phi_vc)\n    norm3 = l2_norm(diff3, L, N)\n    \n    # 4. Pressure update consistency for pressure-correction\n    p_n1_pc = np.fft.ifft2(p_hat_n1_pc).real\n    phi_pc = np.fft.ifft2(phi_hat_pc).real\n    diff4 = p_n1_pc - phi_pc\n    norm4 = l2_norm(diff4, L, N)\n    \n    # 5. L2 norm of difference between final pressures\n    diff5 = p_n1_vc - p_n1_pc\n    norm5 = l2_norm(diff5, L, N)\n    \n    return [norm1, norm2, norm3, norm4, norm5]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # (N, dt, nu, p_zero, f_zero)\n        (32, 0.05, 0.1, False, False),\n        (32, 0.001, 0.5, False, False),\n        (32, 0.2, 0.01, False, True),\n        (32, 0.1, 0.1, True, False)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, dt, nu, p_zero, f_zero = case\n        case_results = solve_for_test_case(N, dt, nu, p_zero, f_zero)\n        all_results.extend(case_results)\n\n    # Format the final output string\n    # Using 'g' format for concise representation of very small numbers\n    result_str = ','.join(f\"{r:.16g}\" for r in all_results)\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在真实的计算流体动力学（CFD）应用中，压力泊松方程通常通过迭代法求解，这必然会引入求解误差。本项高级练习旨在解决一个关键的实际问题：迭代求解的“不精确”程度可以被接受到什么地步？您将推导线性求解器残差与质量守恒误差之间的精确数学关系，并基于此设计一种自适应容差策略，以在计算成本和物理精度之间取得平衡 。",
            "id": "3435356",
            "problem": "考虑一种标准的不可压缩流离散化速度投影法，该方法在每个时间步通过求解一个辅助标量场的标量泊松方程来解耦速度和压力。令 $u^{n}$ 表示时间 $t^{n}$ 的离散速度，并令中间速度 $u^{\\star}$ 通过一个不强制执行不可压缩性的动量步计算得出。投影步通过求解一个离散泊松方程来计算标量势 $\\phi$，然后通过减去一个缩放后的离散梯度来校正速度。\n\n假设以下基本前提，这在投影法中是标准的：\n- 其底层的连续模型是不可压缩Navier-Stokes方程，但此处的推导仅依赖于不可压缩性约束和投影步的结构。\n- 离散散度算子记为 $D$，离散梯度记为 $G$，离散拉普拉斯算子记为 $A := D G$。这些是一致性算子，由在规则网格上的有限差分、有限体积或有限元离散化产生，并带有适当的边界处理，使得 $A$ 在压力空间上是对称正定的。\n- 密度 $\\rho$ 是正常数，且所有量都被理解为无量纲的。\n\n在时间 $t^{n+1}$ 的离散投影步通过以下方式更新速度：\n$$\nu^{n+1} = u^{\\star} - \\frac{\\Delta t}{\\rho}\\, G \\phi,\n$$\n其中 $\\phi$ 求解线性系统\n$$\nA \\phi = \\frac{\\rho}{\\Delta t}\\, D u^{\\star}.\n$$\n在实践中，该线性系统通过迭代法近似求解，迭代法根据以下停止准则之一终止：\n1. 相对残差准则：残差 $r := b - A \\tilde{\\phi}$ 的欧几里得范数满足 $\\|r\\|_2 \\le \\varepsilon_{\\text{lin}} \\,\\|b\\|_2$，其中 $b := \\frac{\\rho}{\\Delta t} D u^{\\star}$。\n2. 绝对残差准则：残差的欧几里得范数满足 $\\|r\\|_2 \\le \\tau_{\\text{abs}}$。\n\n任务A（推导）：从上述定义出发，并且不援引任何未经证实的捷径，推导出一个先验界。对于两种停止准则，该界都将投影后离散散度的范数 $\\|D u^{n+1}\\|_2$ 与线性求解器残差容限联系起来。推导必须仅使用上述事实以及线性系统和范数的标准性质。\n\n任务B（容限设计）：提出一种线性求解器容限的自适应选择策略，该策略旨在平衡求解器引起的散度误差与空间和时间上的离散化误差。假设主阶离散化误差在散度上按 $C_s h^{k} + C_t \\Delta t^{q}$ 的比例缩放，其中 $h$ 是网格尺寸，$\\Delta t$ 是时间步长，$k$ 是空间阶数，$q$ 是时间阶数，$C_s, C_t$ 是正常数。设求解器引起的散度的目标水平为该估计值的一部分 $\\theta \\in (0,1]$：\n$$\n\\tau_{\\text{div}} := \\theta \\left( C_s h^{k} + C_t \\Delta t^{q} \\right).\n$$\n为相对容限 $\\varepsilon_{\\textlin}$ 和绝对容限 $\\tau_{\\text{abs}}$ 设计规则，以实现 $\\|D u^{n+1}\\|_2 \\lesssim \\tau_{\\text{div}}$，同时受限于实际的上限 $\\varepsilon_{\\max}$ 和 $\\tau_{\\max}$，以及一项安全措施，即在适当情况下通过将其替换为一个下限值 $u_{\\star,\\min} > 0$ 来避免除以一个很小的 $\\|D u^{\\star}\\|_2$。\n\n任务C（实现）：实现一个程序，为下面的每个测试用例计算以下三个量：\n1. 在该情况下，由非精确泊松求解引起的 $\\|D u^{n+1}\\|_2$ 的先验上界，使用与所提供的停止准则相对应的规则。\n2. 基于任务B中自适应策略的推荐相对容限 $\\varepsilon_{\\text{lin}}$。\n3. 基于任务B中自适应策略的推荐绝对容限 $\\tau_{\\text{abs}}$。\n\n所有量都是无量纲的；不需要物理单位。对所有向量范数使用欧几里得范数。\n\n所有测试通用的数值参数：\n- 空间阶数 $k = 2$ 和时间阶数 $q = 2$。\n- 常数 $C_s = 1$ 和 $C_t = 1$。\n- 分数 $\\theta = 0.5$。\n- 密度 $\\rho = 1$。\n- 实际限制：$\\varepsilon_{\\max} = 10^{-1}$，$\\tau_{\\max} = 10^{-2}$。\n- 安全下限 $u_{\\star,\\min} = 10^{-8}$。\n\n每个测试用例提供元组 $(\\Delta t, h, \\|D u^{\\star}\\|_2, \\text{mode}, \\text{tol})$，其中：\n- $\\Delta t$ 是时间步长，\n- $h$ 是网格尺寸，\n- $\\|D u^{\\star}\\|_2$ 是中间散度的欧几里得范数，\n- $\\text{mode}$ 为 $0$ 表示相对残差准则，为 $1$ 表示绝对残差准则，\n- $\\text{tol}$ 在 $\\text{mode}=0$ 时是 $\\varepsilon_{\\text{lin}}$，在 $\\text{mode}=1$ 时是 $\\tau_{\\text{abs}}$。\n\n测试套件：\n- 测试 1: $(10^{-2}, 1/64, 10^{-1}, 0, 10^{-6})$。\n- 测试 2: $(10^{-2}, 1/128, 5 \\times 10^{-2}, 1, 10^{-8})$。\n- 测试 3: $(10^{-4}, 1/32, 2 \\times 10^{-2}, 0, 10^{-3})$。\n- 测试 4: $(5 \\times 10^{-3}, 1/16, 10^{-12}, 0, 10^{-8})$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表，每个测试用例对应一个子列表。每个子列表必须按顺序包含三个浮点数：$[\\text{bound}, \\varepsilon_{\\text{lin,recommended}}, \\tau_{\\text{abs,recommended}}]$。总体格式是这些子列表的单个列表，例如：[[b1,e1,a1],[b2,e2,a2],...]。",
            "solution": "在进行求解之前，解析和验证问题陈述是一个强制性的预备步骤。\n\n### 第1步：提取已知条件\n- **离散速度更新：** $u^{n+1} = u^{\\star} - \\frac{\\Delta t}{\\rho}\\, G \\phi$\n- **$\\phi$ 的泊松系统：** $A \\phi = \\frac{\\rho}{\\Delta t}\\, D u^{\\star}$\n- **离散算子：** 散度 $D$，梯度 $G$，拉普拉斯算子 $A := D G$。$A$ 是对称正定的。\n- **物理常数：** 密度 $\\rho > 0$ 是常数。\n- **线性求解器停止准则1（相对）：** 残差 $r := b - A \\tilde{\\phi}$ 满足 $\\|r\\|_2 \\le \\varepsilon_{\\text{lin}} \\,\\|b\\|_2$，其中 $b := \\frac{\\rho}{\\Delta t} D u^{\\star}$。$\\tilde{\\phi}$ 是近似解。\n- **线性求解器停止准则2（绝对）：** $\\|r\\|_2 \\le \\tau_{\\text{abs}}$。\n- **离散化误差估计：** 主阶散度误差按 $C_s h^{k} + C_t \\Delta t^{q}$ 的比例缩放。\n- **目标散度水平：** $\\tau_{\\text{div}} := \\theta \\left( C_s h^{k} + C_t \\Delta t^{q} \\right)$，其中 $\\theta \\in (0,1]$。\n- **自适应容限安全措施：** 最大容限 $\\varepsilon_{\\max}$，$\\tau_{\\max}$；最小中间散度范数下限 $u_{\\star,\\min} > 0$。\n- **数值参数：**\n    - 空间阶数 $k = 2$。\n    - 时间阶数 $q = 2$。\n    - 常数 $C_s = 1$, $C_t = 1$。\n    - 分数 $\\theta = 0.5$。\n    - 密度 $\\rho = 1$。\n    - 上限：$\\varepsilon_{\\max} = 10^{-1}$，$\\tau_{\\max} = 10^{-2}$。\n    - 安全下限：$u_{\\star,\\min} = 10^{-8}$。\n- **测试用例：**\n    - 测试 1: $(\\Delta t, h, \\|D u^{\\star}\\|_2, \\text{mode}, \\text{tol}) = (10^{-2}, 1/64, 10^{-1}, 0, 10^{-6})$。\n    - 测试 2: $(\\Delta t, h, \\|D u^{\\star}\\|_2, \\text{mode}, \\text{tol}) = (10^{-2}, 1/128, 5 \\times 10^{-2}, 1, 10^{-8})$。\n    - 测试 3: $(\\Delta t, h, \\|D u^{\\star}\\|_2, \\text{mode}, \\text{tol}) = (10^{-4}, 1/32, 2 \\times 10^{-2}, 0, 10^{-3})$。\n    - 测试 4: $(\\Delta t, h, \\|D u^{\\star}\\|_2, \\text{mode}, \\text{tol}) = (5 \\times 10^{-3}, 1/16, 10^{-12}, 0, 10^{-8})$。\n\n### 第2步：使用提取的已知条件进行验证\n基于提供的已知条件对问题进行严格评估。\n- **科学依据：** 该问题设置在用于不可压缩Navier-Stokes方程数值解的投影法的标准、完善框架内。其 formulation 基于矢量微积分和数值线性代数的基本原理。它是科学上合理的。\n- **适定性：**各项任务都是基于已知条件明确定义的数学推导和设计问题。每个任务都有一个唯一的、有意义的解。\n- **客观性：** 问题使用精确、客观的数学语言陈述。没有主观或基于意见的陈述。\n- **完整性与一致性：** 提供了推导和计算所需的所有必要定义、参数和数据。没有内部矛盾。\n\n### 第3步：结论与行动\n问题被判定为**有效**。它是自洽的、科学上合理的且适定的。将提供完整的解决方案。\n\n### 任务A：先验界的推导\n\n目标是将最终速度场的散度 $\\|D u^{n+1}\\|_2$ 与非精确泊松求解的残差联系起来。速度使用近似势 $\\tilde{\\phi}$进行更新：\n$$\nu^{n+1} = u^{\\star} - \\frac{\\Delta t}{\\rho}\\, G \\tilde{\\phi}.\n$$\n对该方程应用离散散度算子 $D$ 可得：\n$$\nD u^{n+1} = D u^{\\star} - D \\left( \\frac{\\Delta t}{\\rho}\\, G \\tilde{\\phi} \\right).\n$$\n由于 $D$ 是线性算子，而 $\\Delta t$ 和 $\\rho$ 是标量，这变为：\n$$\nD u^{n+1} = D u^{\\star} - \\frac{\\Delta t}{\\rho}\\, (D G) \\tilde{\\phi}.\n$$\n使用离散拉普拉斯算子的定义 $A := D G$，我们有：\n$$\nD u^{n+1} = D u^{\\star} - \\frac{\\Delta t}{\\rho}\\, A \\tilde{\\phi}.\n$$\n线性系统求解 $\\phi$ 的残差定义为 $r = b - A \\tilde{\\phi}$，其中右侧项为 $b = \\frac{\\rho}{\\Delta t}\\, D u^{\\star}$。根据这个定义，我们可以将 $A \\tilde{\\phi}$ 表示为 $A \\tilde{\\phi} = b - r$。将此代入 $D u^{n+1}$ 的方程中：\n$$\nD u^{n+1} = D u^{\\star} - \\frac{\\Delta t}{\\rho}\\, (b - r).\n$$\n现在，代入 $b$ 的表达式：\n$$\nD u^{n+1} = D u^{\\star} - \\frac{\\Delta t}{\\rho}\\, \\left( \\frac{\\rho}{\\Delta t}\\, D u^{\\star} - r \\right).\n$$\n分配 $\\frac{\\Delta t}{\\rho}$ 项可得：\n$$\nD u^{n+1} = D u^{\\star} - \\left( \\frac{\\Delta t}{\\rho} \\frac{\\rho}{\\Delta t} \\right) D u^{\\star} + \\frac{\\Delta t}{\\rho} r.\n$$\n前两项相消，从而得到投影后散度与线性求解器残差之间的直接关系：\n$$\nD u^{n+1} = \\frac{\\Delta t}{\\rho} r.\n$$\n取两边的欧几里得范数可得：\n$$\n\\|D u^{n+1}\\|_2 = \\left\\| \\frac{\\Delta t}{\\rho} r \\right\\|_2 = \\frac{\\Delta t}{\\rho} \\|r\\|_2.\n$$\n我们现在针对两种停止准则分析此结果。\n\n**1. 相对残差准则：** 停止准则是 $\\|r\\|_2 \\le \\varepsilon_{\\text{lin}} \\|b\\|_2$。\n右侧向量 $b$ 的范数是：\n$$\n\\|b\\|_2 = \\left\\| \\frac{\\rho}{\\Delta t} D u^{\\star} \\right\\|_2 = \\frac{\\rho}{\\Delta t} \\|D u^{\\star}\\|_2.\n$$\n将此代入停止准则，得到残差范数的上界：\n$$\n\\|r\\|_2 \\le \\varepsilon_{\\text{lin}} \\frac{\\rho}{\\Delta t} \\|D u^{\\star}\\|_2.\n$$\n最后，将此不等式代入 $\\|D u^{n+1}\\|_2$ 的表达式中：\n$$\n\\|D u^{n+1}\\|_2 \\le \\frac{\\Delta t}{\\rho} \\left( \\varepsilon_{\\text{lin}} \\frac{\\rho}{\\Delta t} \\|D u^{\\star}\\|_2 \\right).\n$$\n这简化为相对残差准则的先验界：\n$$\n\\|D u^{n+1}\\|_2 \\le \\varepsilon_{\\text{lin}} \\|D u^{\\star}\\|_2.\n$$\n\n**2. 绝对残差准则：** 停止准则是 $\\|r\\|_2 \\le \\tau_{\\text{abs}}$。\n将此直接代入 $\\|D u^{n+1}\\|_2$ 的表达式中，得到绝对残差准则的先验界：\n$$\n\\|D u^{n+1}\\|_2 \\le \\frac{\\Delta t}{\\rho} \\tau_{\\text{abs}}.\n$$\n\n### 任务B：自适应容限设计\n\n目标是选择线性求解器容限 $\\varepsilon_{\\text{lin}}$ 和 $\\tau_{\\text{abs}}$，使得求解器引起的散度误差与估计的离散化误差相平衡。求解器引起的散度的目标水平由下式给出：\n$$\n\\tau_{\\text{div}} := \\theta \\left( C_s h^{k} + C_t \\Delta t^{q} \\right).\n$$\n我们希望通过将推導出的先验界设置为等于此目标水平来强制执行 $\\|D u^{n+1}\\|_2 \\lesssim \\tau_{\\text{div}}$。\n\n**1. 相对容限 $\\varepsilon_{\\text{lin}}$ 的设计：**\n我们从任务A中推导出的界开始：$\\|D u^{n+1}\\|_2 \\le \\varepsilon_{\\text{lin}} \\|D u^{\\star}\\|_2$。\n将此界设置为等于目标散度 $\\tau_{\\text{div}}$：\n$$\n\\varepsilon_{\\text{lin}} \\|D u^{\\star}\\|_2 = \\tau_{\\text{div}}.\n$$\n解出 $\\varepsilon_{\\text{lin}}$ 可得：\n$$\n\\varepsilon_{\\text{lin}} = \\frac{\\tau_{\\text{div}}}{\\|D u^{\\star}\\|_2}.\n$$\n为防止当 $\\|D u^{\\star}\\|_2$ 接近零时（当解收敛时可能发生）除以一个非常小的数，我们使用提供的安全措施。分母被替换为 $\\max(\\|D u^{\\star}\\|_2, u_{\\star,\\min})$。因此，建议的容限是：\n$$\n\\varepsilon_{\\text{lin, proposed}} = \\frac{\\tau_{\\text{div}}}{\\max(\\|D u^{\\star}\\|_2, u_{\\star,\\min})}.\n$$\n然后，该值受限于实际最大值 $\\varepsilon_{\\max}$。推荐的相对容限的最终规则是：\n$$\n\\varepsilon_{\\text{lin, recommended}} = \\min \\left( \\frac{\\theta (C_s h^k + C_t \\Delta t^q)}{\\max(\\|D u^{\\star}\\|_2, u_{\\star,\\min})}, \\varepsilon_{\\max} \\right).\n$$\n\n**2. 绝对容限 $\\tau_{\\text{abs}}$ 的设计：**\n我们从任务A中推导出的界开始：$\\|D u^{n+1}\\|_2 \\le \\frac{\\Delta t}{\\rho} \\tau_{\\text{abs}}$。\n将此界设置为等于目标散度 $\\tau_{\\text{div}}$：\n$$\n\\frac{\\Delta t}{\\rho} \\tau_{\\text{abs}} = \\tau_{\\text{div}}.\n$$\n解出 $\\tau_{\\text{abs}}$ 可得：\n$$\n\\tau_{\\text{abs}} = \\frac{\\rho}{\\Delta t} \\tau_{\\text{div}}.\n$$\n该值受限于实际最大值 $\\tau_{\\max}$。推荐的绝对容限的最终规则是：\n$$\n\\tau_{\\text{abs, recommended}} = \\min \\left( \\frac{\\rho}{\\Delta t} \\theta (C_s h^k + C_t \\Delta t^q), \\tau_{\\max} \\right).\n$$\n\n### 任务C：实现\n任务A和B的推导提供了为每个测试用例计算所需量的必要公式。\n- $\\|D u^{n+1}\\|_2$ 的先验上界是使用 $\\|D u^{n+1}\\|_2 \\le \\varepsilon_{\\text{lin}} \\|D u^{\\star}\\|_2$（对于 $\\text{mode}=0$）或 $\\|D u^{n+1}\\|_2 \\le \\frac{\\Delta t}{\\rho} \\tau_{\\text{abs}}$（对于 $\\text{mode}=1$）来计算的，使用测试用例中的特定 `tol` 值。\n- 推荐的相对容限 $\\varepsilon_{\\text{lin,recommended}}$ 是使用任务B中的公式计算的。\n- 推荐的绝对容限 $\\tau_{\\text{abs,recommended}}$ 是使用任务B中的公式计算的。\n这些计算将在提供的Python代码块中执行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating the divergence bound and recommended\n    tolerances for a suite of test cases related to a projection method.\n    \"\"\"\n    \n    # Numerical parameters common to all tests, as specified in the problem statement.\n    k = 2.0  # Spatial order\n    q = 2.0  # Temporal order\n    C_s = 1.0\n    C_t = 1.0\n    theta = 0.5\n    rho = 1.0\n    epsilon_max = 1e-1\n    tau_max = 1e-2\n    u_star_min = 1e-8\n\n    # Test suite from the problem statement.\n    # Each tuple is (delta_t, h, norm_Du_star, mode, tol).\n    # mode=0: relative residual rule, tol is epsilon_lin.\n    # mode=1: absolute residual rule, tol is tau_abs.\n    test_cases = [\n        (1e-2, 1/64, 1e-1, 0, 1e-6),\n        (1e-2, 1/128, 5e-2, 1, 1e-8),\n        (1e-4, 1/32, 2e-2, 0, 1e-3),\n        (5e-3, 1/16, 1e-12, 0, 1e-8),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_t, h, norm_Du_star, mode, tol = case\n\n        # 1. Compute the a priori upper bound on ||D u^(n+1)||_2\n        # This uses the derivation from Task A.\n        if mode == 0:  # Relative residual rule\n            epsilon_lin = tol\n            bound = epsilon_lin * norm_Du_star\n        elif mode == 1:  # Absolute residual rule\n            tau_abs_given = tol\n            bound = (delta_t / rho) * tau_abs_given\n        else:\n            raise ValueError(\"Invalid mode specified in test case.\")\n\n        # 2. Compute the recommended tolerances based on the adaptive strategy from Task B.\n        \n        # First, calculate the target divergence level tau_div\n        tau_div = theta * (C_s * h**k + C_t * delta_t**q)\n\n        # Recommended relative tolerance epsilon_lin\n        denominator = max(norm_Du_star, u_star_min)\n        epsilon_lin_proposed = tau_div / denominator\n        epsilon_lin_recommended = min(epsilon_lin_proposed, epsilon_max)\n\n        # Recommended absolute tolerance tau_abs\n        tau_abs_proposed = (rho / delta_t) * tau_div\n        tau_abs_recommended = min(tau_abs_proposed, tau_max)\n        \n        # Store the three required quantities for this test case.\n        results.append([bound, epsilon_lin_recommended, tau_abs_recommended])\n    \n    # Final print statement in the exact required format.\n    # The str() of a list includes brackets and spaces, which, when joined by a comma,\n    # produces the requested list-of-lists format: [[...],[...],...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}