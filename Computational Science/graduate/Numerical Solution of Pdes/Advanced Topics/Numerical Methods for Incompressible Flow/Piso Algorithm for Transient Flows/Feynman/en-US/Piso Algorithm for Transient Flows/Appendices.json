{
    "hands_on_practices": [
        {
            "introduction": "To truly master the PISO algorithm, one must first understand its core mechanism: the projection of the velocity field onto a divergence-free space. This analytical exercise  provides a rigorous way to visualize this process by using Fourier analysis on a model error. You will derive precisely how the pressure-correction step filters out the non-physical, compressible components of numerical error, providing a fundamental insight into why the algorithm is effective at enforcing mass conservation.",
            "id": "3432037",
            "problem": "Consider a transient, incompressible flow of constant density $\\rho$ in a triply periodic domain, advanced in time by the Pressure-Implicit with Splitting of Operators (PISO) algorithm. Let the time step be $\\Delta t$, and denote by $\\mathbf{u}^{*}$ the velocity after the predictor step at time level $n+1$, which differs from the exact divergence-free velocity $\\mathbf{u}^{n+1}$ due to truncation error. Define the predictor truncation error field $\\mathbf{e}_{\\mathrm{pred}}$ by $\\mathbf{u}^{*} = \\mathbf{u}^{n+1} + \\mathbf{e}_{\\mathrm{pred}}$. The pressure correction step updates the velocity by subtracting a pressure-gradient increment to enforce incompressibility at time level $n+1$. Assume viscosity is neglected during the correction step and that the pressure increment is chosen to enforce the divergence-free constraint.\n\nUsing only the incompressibility constraint $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$, the definition of the pressure correction step as a velocity update by a gradient field, and Fourier analysis in a periodic domain, perform an error transport analysis for a single Fourier mode of the predictor truncation error. Specifically, consider $\\mathbf{e}_{\\mathrm{pred}}(\\mathbf{x}) = \\mathbf{a} \\exp(i \\mathbf{k} \\cdot \\mathbf{x})$ with constant amplitude vector $\\mathbf{a} \\in \\mathbb{C}^{3}$ and wavevector $\\mathbf{k} \\in \\mathbb{R}^{3} \\setminus \\{\\mathbf{0}\\}$. Derive the redistribution of $\\mathbf{e}_{\\mathrm{pred}}$ caused by the pressure correction and compute the fraction of the kinetic energy of the error mode that remains in the corrected velocity after the first pressure correction. Express your final answer as a closed-form analytic expression in terms of the angle $\\theta$ between $\\mathbf{a}$ and $\\mathbf{k}$, defined by $\\cos \\theta = \\dfrac{\\mathbf{k} \\cdot \\mathbf{a}}{\\|\\mathbf{k}\\| \\, \\|\\mathbf{a}\\|}$. No numerical approximation is required; provide an exact expression. The final answer should have no units.",
            "solution": "The user wants me to analyze the effect of the PISO algorithm's first pressure correction step on a single Fourier mode of the predictor-step truncation error.\n\n### Step 1: Extract Givens\n- Flow is transient, incompressible, with constant density $\\rho$.\n- The domain is triply periodic.\n- The time step is $\\Delta t$.\n- The predicted velocity at time level $n+1$ is $\\mathbf{u}^{*}$.\n- The exact, divergence-free velocity at time level $n+1$ is $\\mathbf{u}^{n+1}$.\n- The predictor truncation error is $\\mathbf{e}_{\\mathrm{pred}}$, defined by $\\mathbf{u}^{*} = \\mathbf{u}^{n+1} + \\mathbf{e}_{\\mathrm{pred}}$.\n- The incompressibility constraint is $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$.\n- The pressure correction step updates the velocity by subtracting a pressure-gradient increment to enforce incompressibility. Viscosity is neglected in this step.\n- The predictor truncation error is a single Fourier mode: $\\mathbf{e}_{\\mathrm{pred}}(\\mathbf{x}) = \\mathbf{a} \\exp(i \\mathbf{k} \\cdot \\mathbf{x})$, with $\\mathbf{a} \\in \\mathbb{C}^{3}$ and $\\mathbf{k} \\in \\mathbb{R}^{3} \\setminus \\{\\mathbf{0}\\}$.\n- The angle $\\theta$ between $\\mathbf{a}$ and $\\mathbf{k}$ is defined by $\\cos \\theta = \\dfrac{\\mathbf{k} \\cdot \\mathbf{a}}{\\|\\mathbf{k}\\| \\, \\|\\mathbf{a}\\|}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the principles of computational fluid dynamics, specifically the analysis of projection methods like PISO. The use of Fourier analysis in a periodic domain is a standard technique for studying the properties of numerical schemes. The problem is well-posed, objective, and self-contained, providing all necessary definitions to proceed.\n\nThere is a minor ambiguity in the problem statement. It specifies the amplitude vector $\\mathbf{a} \\in \\mathbb{C}^{3}$ but defines the angle $\\theta$ using a formula, $\\cos \\theta = \\frac{\\mathbf{k} \\cdot \\mathbf{a}}{\\|\\mathbf{k}\\| \\|\\mathbf{a}\\|}$, which is standard for real vectors. If $\\mathbf{a}$ is a general complex vector, the term $\\mathbf{k} \\cdot \\mathbf{a}$ is complex, which implies a complex angle $\\theta$, and the physical interpretation is less direct. However, the structure of the problem strongly suggests a geometric interpretation based on real-vector projection. This ambiguity can be resolved by interpreting the problem as either a case where $\\mathbf{a}$ is a real vector (a subset of $\\mathbb{C}^3$) or by recognizing that the final energy ratio depends on $|\\mathbf{k} \\cdot \\mathbf{a}|^2$. Under the assumption that $\\mathbf{k} \\cdot \\mathbf{a}$ is real, which is necessary for $\\theta$ to be a real angle, the problem is perfectly consistent. This is a reasonable interpretation that aligns with the physical context. Thus, the problem is deemed valid.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\n### Solution Derivation\nThe PISO algorithm's pressure correction step is designed to project a velocity field onto the space of divergence-free fields. Let the velocity field after the predictor step be $\\mathbf{u}^{*}$. The first correction step computes a corrected velocity, let's call it $\\mathbf{u}^{**}$, by removing the gradient part of $\\mathbf{u}^{*}$. This is achieved by subtracting the gradient of a scalar field, which we can denote as $\\phi$.\n$$\n\\mathbf{u}^{**} = \\mathbf{u}^{*} - \\nabla\\phi\n$$\nThe scalar field $\\phi$ (proportional to the pressure correction) is determined by enforcing the divergence-free condition on the corrected velocity, $\\nabla \\cdot \\mathbf{u}^{**} = 0$.\n$$\n\\nabla \\cdot (\\mathbf{u}^{*} - \\nabla\\phi) = 0\n$$\nThis leads to a Poisson-type equation for $\\phi$:\n$$\n\\nabla^2\\phi = \\nabla \\cdot \\mathbf{u}^{*}\n$$\nThe problem states the relationship between the predicted velocity $\\mathbf{u}^{*}$, the exact divergence-free velocity $\\mathbf{u}^{n+1}$, and the predictor error $\\mathbf{e}_{\\mathrm{pred}}$:\n$$\n\\mathbf{u}^{*} = \\mathbf{u}^{n+1} + \\mathbf{e}_{\\mathrm{pred}}\n$$\nGiven that the exact velocity is divergence-free, $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$, we can express the divergence of the predicted velocity entirely in terms of the error:\n$$\n\\nabla \\cdot \\mathbf{u}^{*} = \\nabla \\cdot (\\mathbf{u}^{n+1} + \\mathbf{e}_{\\mathrm{pred}}) = \\nabla \\cdot \\mathbf{u}^{n+1} + \\nabla \\cdot \\mathbf{e}_{\\mathrm{pred}} = \\nabla \\cdot \\mathbf{e}_{\\mathrm{pred}}\n$$\nThe Poisson equation for $\\phi$ is thus driven by the divergence of the predictor error:\n$$\n\\nabla^2\\phi = \\nabla \\cdot \\mathbf{e}_{\\mathrm{pred}}\n$$\nThe error in the corrected velocity field, $\\mathbf{e}_{\\mathrm{corr}} = \\mathbf{u}^{**} - \\mathbf{u}^{n+1}$, is found by substituting the expressions for $\\mathbf{u}^{**}$ and $\\mathbf{u}^{*}$:\n$$\n\\mathbf{e}_{\\mathrm{corr}} = (\\mathbf{u}^{*} - \\nabla\\phi) - \\mathbf{u}^{n+1} = (\\mathbf{u}^{n+1} + \\mathbf{e}_{\\mathrm{pred}} - \\nabla\\phi) - \\mathbf{u}^{n+1} = \\mathbf{e}_{\\mathrm{pred}} - \\nabla\\phi\n$$\nThis demonstrates that the pressure correction step modifies the error field by removing its gradient component. We now analyze this process for the given single Fourier mode error, $\\mathbf{e}_{\\mathrm{pred}}(\\mathbf{x}) = \\mathbf{a} \\exp(i \\mathbf{k} \\cdot \\mathbf{x})$.\n\nFirst, we compute the divergence of the error mode:\n$$\n\\nabla \\cdot \\mathbf{e}_{\\mathrm{pred}} = \\nabla \\cdot (\\mathbf{a} \\exp(i \\mathbf{k} \\cdot \\mathbf{x})) = \\mathbf{a} \\cdot \\nabla(\\exp(i \\mathbf{k} \\cdot \\mathbf{x})) = \\mathbf{a} \\cdot (i\\mathbf{k}) \\exp(i \\mathbf{k} \\cdot \\mathbf{x}) = i(\\mathbf{k} \\cdot \\mathbf{a})\\exp(i \\mathbf{k} \\cdot \\mathbf{x})\n$$\nThe Poisson equation becomes:\n$$\n\\nabla^2\\phi = i(\\mathbf{k} \\cdot \\mathbf{a})\\exp(i \\mathbf{k} \\cdot \\mathbf{x})\n$$\nAssuming a solution of the form $\\phi(\\mathbf{x}) = \\hat{\\phi} \\exp(i \\mathbf{k} \\cdot \\mathbf{x})$, where $\\hat{\\phi}$ is the Fourier coefficient, we apply the Laplacian operator:\n$$\n\\nabla^2 (\\hat{\\phi} \\exp(i \\mathbf{k} \\cdot \\mathbf{x})) = \\hat{\\phi} (i\\mathbf{k}) \\cdot (i\\mathbf{k}) \\exp(i \\mathbf{k} \\cdot \\mathbf{x}) = -\\hat{\\phi} \\|\\mathbf{k}\\|^2 \\exp(i \\mathbf{k} \\cdot \\mathbf{x})\n$$\nSubstituting this into the Poisson equation and solving for $\\hat{\\phi}$:\n$$\n-\\hat{\\phi} \\|\\mathbf{k}\\|^2 \\exp(i \\mathbf{k} \\cdot \\mathbf{x}) = i(\\mathbf{k} \\cdot \\mathbf{a})\\exp(i \\mathbf{k} \\cdot \\mathbf{x}) \\implies \\hat{\\phi} = -\\frac{i(\\mathbf{k} \\cdot \\mathbf{a})}{\\|\\mathbf{k}\\|^2}\n$$\nNow we find the gradient term $\\nabla\\phi$ that is removed from the error:\n$$\n\\nabla\\phi = \\nabla(\\hat{\\phi} \\exp(i \\mathbf{k} \\cdot \\mathbf{x})) = i\\mathbf{k} \\hat{\\phi} \\exp(i \\mathbf{k} \\cdot \\mathbf{x}) = i\\mathbf{k} \\left( -\\frac{i(\\mathbf{k} \\cdot \\mathbf{a})}{\\|\\mathbf{k}\\|^2} \\right) \\exp(i \\mathbf{k} \\cdot \\mathbf{x}) = \\frac{(\\mathbf{k} \\cdot \\mathbf{a})}{\\|\\mathbf{k}\\|^2} \\mathbf{k} \\exp(i \\mathbf{k} \\cdot \\mathbf{x})\n$$\nThe corrected error field $\\mathbf{e}_{\\mathrm{corr}}$ is:\n$$\n\\mathbf{e}_{\\mathrm{corr}} = \\mathbf{e}_{\\mathrm{pred}} - \\nabla\\phi = \\mathbf{a} \\exp(i \\mathbf{k} \\cdot \\mathbf{x}) - \\frac{(\\mathbf{k} \\cdot \\mathbf{a})}{\\|\\mathbf{k}\\|^2} \\mathbf{k} \\exp(i \\mathbf{k} \\cdot \\mathbf{x})\n$$\nFactoring out the exponential term, we get the amplitude of the corrected error:\n$$\n\\mathbf{e}_{\\mathrm{corr}} = \\left( \\mathbf{a} - \\frac{(\\mathbf{k} \\cdot \\mathbf{a})}{\\|\\mathbf{k}\\|^2} \\mathbf{k} \\right) \\exp(i \\mathbf{k} \\cdot \\mathbf{x})\n$$\nThe term in parentheses is the original amplitude vector $\\mathbf{a}$ minus its projection onto the wavevector $\\mathbf{k}$. This is the component of $\\mathbf{a}$ orthogonal to $\\mathbf{k}$.\n\nThe kinetic energy of a velocity field represented by a single Fourier mode $\\mathbf{v}(\\mathbf{x}) = \\mathbf{c} \\exp(i \\mathbf{k} \\cdot \\mathbf{x})$ in a periodic domain of volume $V$ is proportional to the integral of its squared norm, $E \\propto \\int_V \\|\\mathbf{v}(\\mathbf{x})\\|^2 dV$. Since $\\|\\mathbf{v}(\\mathbf{x})\\|^2 = (\\mathbf{c}e^{i\\mathbf{k}\\cdot\\mathbf{x}}) \\cdot (\\mathbf{c}^*e^{-i\\mathbf{k}\\cdot\\mathbf{x}}) = \\|\\mathbf{c}\\|^2$, the energy is $E \\propto \\|\\mathbf{c}\\|^2 V$. Therefore, the ratio of kinetic energies is the ratio of the squared norms of their respective amplitude vectors.\n\nThe energy of the predictor error is $E_{\\mathrm{pred}} \\propto \\|\\mathbf{a}\\|^2$.\nThe amplitude of the corrected error is $\\mathbf{a}_{\\perp} = \\mathbf{a} - \\frac{(\\mathbf{k} \\cdot \\mathbf{a})}{\\|\\mathbf{k}\\|^2} \\mathbf{k}$. The energy of the corrected error is $E_{\\mathrm{corr}} \\propto \\|\\mathbf{a}_{\\perp}\\|^2$.\nThe fraction of remaining kinetic energy is:\n$$\n\\frac{E_{\\mathrm{corr}}}{E_{\\mathrm{pred}}} = \\frac{\\|\\mathbf{a}_{\\perp}\\|^2}{\\|\\mathbf{a}\\|^2}\n$$\nThe vector $\\mathbf{a}$ can be decomposed into components parallel and perpendicular to $\\mathbf{k}$: $\\mathbf{a} = \\mathbf{a}_{\\|} + \\mathbf{a}_{\\perp}$, where $\\mathbf{a}_{\\|} = \\frac{(\\mathbf{k} \\cdot \\mathbf{a})}{\\|\\mathbf{k}\\|^2} \\mathbf{k}$. These components are orthogonal. By the Pythagorean theorem, $\\|\\mathbf{a}\\|^2 = \\|\\mathbf{a}_{\\|}\\|^2 + \\|\\mathbf{a}_{\\perp}\\|^2$.\nThus, $\\|\\mathbf{a}_{\\perp}\\|^2 = \\|\\mathbf{a}\\|^2 - \\|\\mathbf{a}_{\\|}\\|^2$.\nWe compute the squared norm of the parallel component. Based on the reasoning in the validation step, we treat $\\mathbf{a}$ as a real vector to be consistent with the definition of $\\theta$.\n$$\n\\|\\mathbf{a}_{\\|}\\|^2 = \\left\\| \\frac{(\\mathbf{k} \\cdot \\mathbf{a})}{\\|\\mathbf{k}\\|^2} \\mathbf{k} \\right\\|^2 = \\frac{(\\mathbf{k} \\cdot \\mathbf{a})^2}{\\|\\mathbf{k}\\|^4} \\|\\mathbf{k}\\|^2 = \\frac{(\\mathbf{k} \\cdot \\mathbf{a})^2}{\\|\\mathbf{k}\\|^2}\n$$\nThe fraction of remaining energy is:\n$$\n\\frac{E_{\\mathrm{corr}}}{E_{\\mathrm{pred}}} = \\frac{\\|\\mathbf{a}\\|^2 - \\|\\mathbf{a}_{\\|}\\|^2}{\\|\\mathbf{a}\\|^2} = 1 - \\frac{\\|\\mathbf{a}_{\\|}\\|^2}{\\|\\mathbf{a}\\|^2} = 1 - \\frac{(\\mathbf{k} \\cdot \\mathbf{a})^2}{\\|\\mathbf{k}\\|^2 \\|\\mathbf{a}\\|^2}\n$$\nThe problem defines $\\cos\\theta = \\dfrac{\\mathbf{k} \\cdot \\mathbf{a}}{\\|\\mathbf{k}\\| \\, \\|\\mathbf{a}\\|}$. Substituting this definition:\n$$\n\\frac{E_{\\mathrm{corr}}}{E_{\\mathrm{pred}}} = 1 - (\\cos\\theta)^2 = 1 - \\cos^2\\theta\n$$\nUsing the fundamental trigonometric identity $\\sin^2\\theta + \\cos^2\\theta = 1$, the fraction simplifies to:\n$$\n\\frac{E_{\\mathrm{corr}}}{E_{\\mathrm{pred}}} = \\sin^2\\theta\n$$\nThis result shows that the pressure-correction projection eliminates the longitudinal part of the error mode (for which $\\theta = 0$) and preserves the transverse, or solenoidal, part of the error mode (for which $\\theta = \\pi/2$).",
            "answer": "$$\n\\boxed{\\sin^2(\\theta)}\n$$"
        },
        {
            "introduction": "Theoretical knowledge is essential, but practical success in CFD often comes from debugging complex, interacting problems. This diagnostic exercise  moves from the ideal theory to messy reality, placing you in a realistic scenario where a PISO simulation fails spectacularly. By dissecting the setup and symptoms, you will learn to identify and remedy a cascade of critical implementation errors involving boundary conditions, numerical stability, and pressure-velocity coupling—skills that every CFD practitioner must possess.",
            "id": "3432034",
            "problem": "Consider an incompressible, constant-density transient flow governed by the incompressible Navier–Stokes equations in a two-dimensional ($2\\mathrm{D}$) channel of length $L$ and height $H$, with density $\\rho$ and kinematic viscosity $\\nu$. The governing equations are\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + \\nabla \\cdot (\\mathbf{u}\\mathbf{u}) = -\\nabla p + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{f}, \\qquad \\nabla \\cdot \\mathbf{u} = 0,\n$$\nwhere $\\mathbf{u}$ is the velocity field, $p$ is the kinematic pressure (pressure divided by density), and $\\mathbf{f}$ is a body force. The flow is solved numerically by the Pressure-Implicit with Splitting of Operators (PISO) algorithm within a finite volume method (FVM) framework on a non-orthogonal mesh.\n\nBoundary conditions are prescribed as follows: at $x=0$ (inlet), a time-dependent velocity profile $\\mathbf{u}_{\\text{in}}(t)$ is imposed with zero normal pressure gradient; at $x=L$ (outlet), the kinematic pressure is fixed to $p=p_0$; at $y=0$ and $y=H$ (walls), no-slip and impermeability are enforced, i.e., $\\mathbf{u}=\\mathbf{0}$ and $\\mathbf{u}\\cdot \\mathbf{n}=0$. The inlet velocity is $\\mathbf{u}_{\\text{in}}(t)=\\left(U_0\\sin(\\omega t),\\,0\\right)$ with given $U_0$ and $\\omega$. The Courant number is defined as\n$$\nCo \\equiv \\max\\left(\\frac{|\\mathbf{u}|\\Delta t}{\\Delta x}\\right),\n$$\nwhere $\\Delta t$ is the time step and $\\Delta x$ a characteristic cell size.\n\nA Computational Fluid Dynamics (CFD) practitioner sets up the PISO algorithm as follows: a momentum predictor yields an intermediate velocity $\\mathbf{u}^*$, face fluxes are computed without Rhie–Chow interpolation, and the pressure correction equation is assembled with a homogeneous Neumann condition (zero normal gradient) for the pressure correction at the outlet (where $p=p_0$ is fixed), with no global pressure reference prescribed; central differencing is used for convection, and the time step is chosen such that $Co \\approx 3$. The linear solver for pressure uses a Preconditioned Conjugate Gradient (PCG) method with a simple diagonal preconditioner and a loose tolerance. The PISO corrector count is low. The simulation exhibits divergence characterized by growing pressure correction residuals and unbounded oscillations in $\\mathbf{u}$ and $p$.\n\nStarting from the incompressibility constraint and the definition of the pressure correction equation as it arises in the PISO algorithm, diagnose the primary reason for divergence in terms of boundary condition inconsistency and operator singularity. Then select the set of corrective measures that are necessary and sufficient to restore robust convergence for this transient problem. Your answer should be based on first principles and defensible reasoning regarding discrete continuity, pressure–velocity coupling, temporal stability, and linear solver behavior.\n\nWhich option correctly identifies and remedies the issue?\n\nA. Increase the number of PISO pressure correctors and switch the pressure solver to Algebraic Multigrid (AMG), leaving boundary conditions and time step unchanged. This improves the correction strength and multigrid convergence and will resolve the divergence.\n\nB. Impose a Dirichlet condition for the pressure correction $p'$ at the fixed-pressure outlet ($p'=0$ on the boundary where $p=p_0$), set a single pressure reference to remove the null space, enable Rhie–Chow interpolation for face fluxes, reduce the time step to ensure $Co \\le 0.5$, use a bounded upwind or Total Variation Diminishing scheme for convection, and increase non-orthogonal pressure correctors to ensure consistency on the non-orthogonal mesh. With these changes, the discrete pressure equation is well-posed and the transient coupling is stabilized.\n\nC. Apply strong under-relaxation to pressure in transient PISO, retain the homogeneous Neumann boundary for the pressure correction at the outlet, do not set a pressure reference, and use second-order central differencing for convection to minimize diffusion. The extra accuracy and relaxation will eliminate divergence.\n\nD. Impose zero normal velocity at the outlet to prevent backflow, add an artificial compressibility term $\\beta \\,\\partial p/\\partial t$ with $\\beta>0$ to the pressure equation, and increase $\\Delta t$ to average transients. This will regularize the system and stabilize the transient evolution.\n\nE. Add a divergence damping term $\\epsilon \\nabla^2 p$ directly into the momentum equations with $\\epsilon>0$, set zero-gradient pressure boundary conditions at all boundaries, and keep $Co \\approx 3$ to avoid excessive computational cost. The added diffusion of pressure will remove oscillations and allow convergence.",
            "solution": "The user wants me to analyze a Computational Fluid Dynamics (CFD) problem concerning the failure of a PISO simulation for a transient, incompressible flow and to identify the correct set of remedial actions.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n-   **Governing Equations**: Incompressible Navier–Stokes and continuity equations.\n    $$\n    \\frac{\\partial \\mathbf{u}}{\\partial t} + \\nabla \\cdot (\\mathbf{u}\\mathbf{u}) = -\\frac{1}{\\rho}\\nabla p + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{f}\n    $$\n    $$\n    \\nabla \\cdot \\mathbf{u} = 0\n    $$\n-   **Flow Parameters**: Incompressible, constant density $\\rho$, kinematic viscosity $\\nu$.\n-   **Geometry and BCs**: $2\\mathrm{D}$ channel of length $L$, height $H$.\n    -   Inlet ($x=0$): Time-dependent velocity $\\mathbf{u}_{\\text{in}}(t)=\\left(U_0\\sin(\\omega t),\\,0\\right)$, zero normal pressure gradient ($\\partial p / \\partial n = 0$).\n    -   Outlet ($x=L$): Fixed kinematic pressure $p=p_0$.\n    -   Walls ($y=0$, $y=H$): No-slip ($\\mathbf{u}=\\mathbf{0}$).\n-   **Numerical Scheme**: Pressure-Implicit with Splitting of Operators (PISO) algorithm, Finite Volume Method (FVM), non-orthogonal mesh.\n-   **Courant number**: $Co \\equiv \\max\\left(\\frac{|\\mathbf{u}|\\Delta t}{\\Delta x}\\right)$.\n-   **Flawed Simulation Setup**:\n    1.  Face fluxes computed without Rhie–Chow interpolation.\n    2.  The pressure correction equation for $p'$ is solved with a homogeneous Neumann boundary condition ($\\partial p' / \\partial n = 0$) at the outlet ($x=L$).\n    3.  No global pressure reference is prescribed.\n    4.  Central differencing is used for the convection term.\n    5.  Time step is chosen such that $Co \\approx 3$.\n    6.  The linear solver for pressure is a Preconditioned Conjugate Gradient (PCG) method with a diagonal preconditioner and a loose tolerance.\n    7.  The PISO corrector loop count is low.\n-   **Observed Behavior**: Simulation divergence, characterized by growing pressure correction residuals and unbounded oscillations in velocity $\\mathbf{u}$ and pressure $p$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem statement describes a faulty numerical setup for a well-defined physical problem and asks for a diagnosis and correction. The description of the setup and the resulting numerical failure modes are consistent with known pitfalls in CFD. The purpose of the problem is to test the understanding of these pitfalls. The problem is therefore scientifically grounded, well-posed (in its request), and objective. It does not violate any of the invalidity criteria. The inconsistencies are part of the scenario to be analyzed, not flaws in the problem statement itself.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. I will proceed with the derivation and analysis.\n\n### Derivation and Analysis\n\nThe PISO algorithm is a non-iterative method for time-marching solutions of the incompressible Navier–Stokes equations. It involves a predictor step followed by one or more corrector steps.\n\n1.  **Momentum Predictor**: An intermediate velocity field, $\\mathbf{u}^*$, is calculated by solving the momentum equation using the pressure field from the previous time step, $p^n$. The discretized momentum equation is of the form:\n    $$ a_P \\mathbf{u}^*_P = \\sum_{nb} a_{nb} \\mathbf{u}^*_{nb} - V \\frac{\\nabla p^n}{\\rho} + \\mathbf{b} $$\n    Here, $a_P$ and $a_{nb}$ are matrix coefficients, $V$ is the cell volume, and $\\mathbf{b}$ contains source terms and transient terms.\n\n2.  **Pressure Correction**: The predicted velocity $\\mathbf{u}^*$ does not satisfy the continuity constraint $\\nabla \\cdot \\mathbf{u} = 0$. The velocity and pressure are corrected as:\n    $$ \\mathbf{u}^{n+1} = \\mathbf{u}^* + \\mathbf{u}' $$\n    $$ p^{n+1} = p^n + p' $$\n    A simplified relation from the momentum equation links the velocity correction $\\mathbf{u}'$ to the pressure correction gradient $\\nabla p'$:\n    $$ \\mathbf{u}' \\approx -\\frac{\\Delta t}{\\rho a_P} \\nabla p' $$\n    (Note: In a more rigorous FVM context, the term is a discrete gradient operator).\n    By enforcing continuity on the corrected velocity, $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$, we obtain a Poisson equation for the pressure correction, $p'$:\n    $$ \\nabla \\cdot \\left( \\frac{\\Delta t}{\\rho a_P} \\nabla p' \\right) = \\nabla \\cdot \\mathbf{u}^* $$\n    This is the pressure correction equation that must be solved.\n\nNow, let us diagnose the flaws in the practitioner's setup based on this framework.\n\n**Flaw 1: Boundary Condition Inconsistency and Matrix Singularity**\nAt the outlet, the physical boundary condition is for the absolute pressure: $p=p_0$ (a Dirichlet condition). The corrected pressure at the new time step, $p^{n+1}$, must satisfy this condition. From the update formula $p^{n+1} = p^n + p'$, we must enforce $p^{n+1}|_{\\text{outlet}} = p_0$. This implies the boundary condition for the pressure correction $p'$ should be $p'|_{\\text{outlet}} = p_0 - p^n|_{\\text{outlet}}$. This is a **Dirichlet boundary condition** for $p'$. A common and acceptable simplification is to set $p'=0$ at the fixed-pressure boundary.\nThe practitioner, however, imposes a **homogeneous Neumann condition** ($\\partial p' / \\partial n = 0$) at the outlet. This is incorrect and inconsistent with the primary boundary condition. At the inlet and walls, the pressure boundary condition is Neumann, which translates to a Neumann condition for $p'$. By incorrectly specifying a Neumann condition for $p'$ at the outlet as well, the practitioner has set up a Poisson problem for $p'$ with pure Neumann conditions on all boundaries. The resulting linear system is **singular**: its solution is unique only up to an additive constant, and a solution exists only if the source term (the divergence of $\\mathbf{u}^*$) integrates to zero over the domain, a condition not generally met. To solve such a singular system, one must remove the null space, typically by setting the pressure correction value at a reference cell ($p'_{ref}=0$). The problem states \"no global pressure reference prescribed\". This combination is the principal cause of the divergence of the pressure solver and the \"growing pressure correction residuals\".\n\n**Flaw 2: Pressure–Velocity Decoupling**\nOn a collocated grid (where pressure and velocity components are stored at the same location, i.e., cell centers), naive interpolation of cell-center velocities to faces to compute mass fluxes can lead to a loss of coupling between adjacent pressure nodes. This allows for non-physical, high-frequency \"checkerboard\" oscillations to appear in the pressure field without being seen by the momentum equation. **Rhie–Chow interpolation** is the standard remedy. It modifies the face velocity calculation to include a term proportional to the pressure difference across the face, effectively introducing a pressure-smoothing dissipation that prevents these oscillations. The failure to use Rhie-Chow interpolation is a direct cause of the observed \"unbounded oscillations\".\n\n**Flaw 3: Convective and Temporal Instability**\n-   **Central Differencing**: This scheme is second-order accurate but is non-dissipative. For convection-dominated flows (high cell Peclet number, $Pe = |\\mathbf{u}|\\Delta x / \\nu > 2$), it notoriously generates unphysical oscillations.\n-   **Courant Number $Co \\approx 3$**: While PISO is semi-implicit and can be stable for $Co > 1$, a high Courant number introduces large temporal truncation errors. More critically, when combined with a non-dissipative spatial scheme like central differencing, it creates an unstable formulation where any small perturbation can grow. For robust and accurate transient simulations, especially with complex dynamics, $Co \\le 1$ is a standard guideline. Bounded, high-resolution schemes (e.g., TVD, NVD) or blended/upwind schemes are required to control oscillations when central differencing is not appropriate.\n\n**Flaw 4: Non-Orthogonal Corrections**\nOn non-orthogonal meshes, the discretization of the pressure Laplacian generates cross-derivative terms that are typically treated explicitly as a source term. The PISO algorithm's multiple corrector steps are designed to iteratively account for these terms and other implicitness errors. A \"low PISO corrector count\" is insufficient to achieve this, leading to a violation of discrete mass conservation and contributing to instability.\n\n### Option-by-Option Analysis\n\n**A. Increase the number of PISO pressure correctors and switch the pressure solver to Algebraic Multigrid (AMG), leaving boundary conditions and time step unchanged. This improves the correction strength and multigrid convergence and will resolve the divergence.**\n-   Increasing PISO correctors and using AMG are good practices. AMG is a powerful solver. However, this option fails to address the fundamental flaws: the inconsistent boundary condition for $p'$ (which makes the system singular), the lack of Rhie-Chow interpolation, and the use of an unstable convection scheme at a high Courant number. A better solver cannot fix a fundamentally ill-posed problem; it may just find the non-unique, garbage solution more quickly or diverge more spectacularly.\n-   Verdict: **Incorrect**.\n\n**B. Impose a Dirichlet condition for the pressure correction $p'$ at the fixed-pressure outlet ($p'=0$ on the boundary where $p=p_0$), set a single pressure reference to remove the null space, enable Rhie–Chow interpolation for face fluxes, reduce the time step to ensure $Co \\le 0.5$, use a bounded upwind or Total Variation Diminishing scheme for convection, and increase non-orthogonal pressure correctors to ensure consistency on the non-orthogonal mesh. With these changes, the discrete pressure equation is well-posed and the transient coupling is stabilized.**\n-   This option presents a comprehensive and correct set of remedies.\n    -   `Impose a Dirichlet condition for p'`: Fixes the inconsistent BC and makes the $p'$ matrix non-singular.\n    -   `set a single pressure reference`: While applying the Dirichlet BC for $p'$ makes a reference point redundant, this statement correctly acknowledges the need to address the singularity that existed in the original faulty setup.\n    -   `enable Rhie–Chow interpolation`: Fixes the pressure-velocity decoupling.\n    -   `reduce the time step to ensure Co <= 0.5` and `use a bounded ... scheme for convection`: These two actions work together to ensure both temporal accuracy and stability by controlling convective instabilities.\n    -   `increase non-orthogonal pressure correctors`: Addresses the errors on the non-orthogonal mesh.\n-   This set of measures is both necessary and sufficient to ensure a robust and stable simulation.\n-   Verdict: **Correct**.\n\n**C. Apply strong under-relaxation to pressure in transient PISO, retain the homogeneous Neumann boundary for the pressure correction at the outlet, do not set a pressure reference, and use second-order central differencing for convection to minimize diffusion. The extra accuracy and relaxation will eliminate divergence.**\n-   Applying strong under-relaxation to pressure in PISO effectively turns it into a SIMPLE-family algorithm and destroys its transient accuracy, as it is designed to be non-iterative within a time step.\n-   Retaining the Neumann BC for $p'$ and no pressure reference leaves the fatal matrix singularity unresolved.\n-   Retaining central differencing leaves the convective instability issue unresolved. This option is a collection of bad advice.\n-   Verdict: **Incorrect**.\n\n**D. Impose zero normal velocity at the outlet to prevent backflow, add an artificial compressibility term $\\beta \\,\\partial p/\\partial t$ with $\\beta>0$ to the pressure equation, and increase $\\Delta t$ to average transients. This will regularize the system and stabilize the transient evolution.**\n-   Imposing zero normal velocity at the outlet fundamentally changes the physical problem from a channel flow to something else and conflicts with the fixed-pressure outlet.\n-   Adding an artificial compressibility term is a valid technique for *certain classes* of methods, but it is not a fix for the PISO algorithm; it changes the system of equations entirely.\n-   Increasing $\\Delta t$ will likely worsen, not improve, stability.\n-   This option proposes abandoning the problem for a different one and using techniques unrelated to fixing PISO.\n-   Verdict: **Incorrect**.\n\n**E. Add a divergence damping term $\\epsilon \\nabla^2 p$ directly into the momentum equations with $\\epsilon>0$, set zero-gradient pressure boundary conditions at all boundaries, and keep $Co \\approx 3$ to avoid excessive computational cost. The added diffusion of pressure will remove oscillations and allow convergence.**\n-   Adding an arbitrary $\\epsilon \\nabla^2 p$ term is an ad-hoc, non-physical modification.\n-   Setting zero-gradient pressure on all boundaries for a flow with a net inlet creates an ill-posed physical problem where mass conservation cannot be satisfied globally. It also guarantees a singular pressure matrix.\n-   Keeping $Co \\approx 3$ retains a source of instability. This option is physically and numerically nonsensical.\n-   Verdict: **Incorrect**.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "After understanding the theory and potential pitfalls, the final step is to learn how to control the simulation's accuracy. This hands-on numerical experiment  explores the concept of \"acoustic contamination\"—the residual divergence, $\\lVert \\nabla \\cdot \\mathbf{u}^{n+1} \\rVert$, left by an inexact pressure solve. By implementing a test case, you will directly measure how the choice of the solver tolerance $\\epsilon$ must be linked to the time step $\\Delta t$ to preserve the overall temporal accuracy of the scheme, learning a principled approach to setting tolerances for high-fidelity transient simulations.",
            "id": "3432041",
            "problem": "Consider the two-dimensional incompressible transient flow modeled on a periodic unit square domain with coordinates $(x,y) \\in [0,1]\\times[0,1]$. The Incompressible Navier–Stokes equations in the limit of negligible inertia reduce to the unsteady Stokes equations, which enforce mass conservation through $\\nabla \\cdot \\mathbf{u} = 0$ and balance of momentum through $\\partial_t \\mathbf{u} = -\\nabla p + \\nu \\Delta \\mathbf{u} + \\mathbf{f}$, where $\\mathbf{u}$ is the velocity field, $p$ is the kinematic pressure, $\\nu$ is the kinematic viscosity, and $\\mathbf{f}$ is the body force. A commonly used decoupling strategy for transient incompressible flows is the Pressure-Implicit with Splitting of Operators (PISO) algorithm, which uses a predictor for the momentum equation followed by iterative pressure corrections to approximate the divergence-free constraint at the next time level. In practice, the inner pressure-correction loop is terminated by a tolerance on the divergence of the corrected velocity, which can introduce residual \"acoustic contamination\" quantified by $\\lVert \\nabla \\cdot \\mathbf{u}^{n+1} \\rVert_2$.\n\nYour task is to design and implement a numerical experiment that isolates and measures how the residual $\\lVert \\nabla \\cdot \\mathbf{u}^{n+1} \\rVert_2$ scales with the time step $\\Delta t$ under a PISO-like inner correction process with a divergence-based stopping criterion. Use the following principled setup:\n\n- Use a periodic unit square grid with $N \\times N$ uniformly spaced points and grid spacing $\\Delta x = \\Delta y = 1/N$. All fields are dimensionless, so no physical units need to be reported.\n- Define a divergence-free base flow at the next time level $t^{n+1}$ by the Taylor–Green vortex\n  $\\mathbf{u}_{\\mathrm{base}}(x,y) = \\big(\\sin(2\\pi x)\\cos(2\\pi y), -\\cos(2\\pi x)\\sin(2\\pi y)\\big)$.\n- Mimic a PISO momentum predictor that yields a compressible provisional velocity by adding a gradient perturbation proportional to $\\Delta t$:\n  $\\mathbf{u}^{\\star}(x,y;\\Delta t) = \\mathbf{u}_{\\mathrm{base}}(x,y) + \\Delta t \\nabla \\chi(x,y)$ with $\\chi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$.\n- Compute the discrete divergence $\\nabla \\cdot \\mathbf{u}^{\\star}$ using second-order central differences on the periodic grid, and its discrete $L^2$-norm defined as $\\lVert \\phi \\rVert_2 = \\sqrt{\\sum_{i,j} \\phi_{i,j}^2 \\, \\Delta x \\, \\Delta y}$.\n- Model the inner PISO pressure-correction loop as a sequence of linear corrections that geometrically reduce the divergence norm by a fixed contraction factor $\\theta \\in (0,1)$ per iteration, independent of $\\Delta t$. If $R_0(\\Delta t) = \\lVert \\nabla \\cdot \\mathbf{u}^{\\star} \\rVert_2$ denotes the initial divergence norm, then after $k$ corrections the divergence norm is $R_k(\\Delta t) = \\theta^k R_0(\\Delta t)$. Terminate the loop at the smallest $k$ such that $R_k(\\Delta t) \\le \\epsilon(\\Delta t)$, where $\\epsilon(\\Delta t)$ is a user-specified tolerance schedule.\n\nYour program must implement the above with the following fixed numerical choices:\n- Use $N = 64$, $\\nu$ arbitrary but not used explicitly in this simplified experiment, $\\theta = 0.5$.\n- Discretize derivatives with second-order central differences and periodic wrapping.\n- Use the discrete $L^2$-norm with $\\Delta x = \\Delta y = 1/N$.\n\nYou must study the scaling of the final divergence norm with respect to $\\Delta t$ for two families of tolerances $\\epsilon(\\Delta t) = C \\Delta t^{\\alpha}$:\n- Family A (candidate second-order): $\\alpha = 2$ with $C = 10^{-2}$.\n- Family B (candidate first-order): $\\alpha = 1$ with $C = 10^{-2}$.\n\nFor each family, run the simulation for the time-step test suite $\\Delta t \\in \\{0.2, 0.1, 0.05\\}$:\n- For each $\\Delta t$, construct $\\mathbf{u}^{\\star}$, compute $R_0(\\Delta t)$, determine the minimal integer $k$ satisfying $R_k(\\Delta t) \\le \\epsilon(\\Delta t)$, and return the final divergence norm $R_k(\\Delta t)$.\n- From the resulting three values of $R_k(\\Delta t)$, compute the observed order $p$ between consecutive pairs by\n  $p = \\dfrac{\\log\\big(R_k(\\Delta t_i)/R_k(\\Delta t_{i+1})\\big)}{\\log\\big(\\Delta t_i/\\Delta t_{i+1}\\big)}$ for the pairs $(\\Delta t_i,\\Delta t_{i+1}) = (0.2,0.1)$ and $(0.1,0.05)$.\n\nYour program must output a single line containing a list with four floating-point numbers in the following order:\n- The two observed orders $p$ for Family A (with $\\alpha = 2$) for the pairs $(0.2,0.1)$ and $(0.1,0.05)$.\n- The two observed orders $p$ for Family B (with $\\alpha = 1)$ for the same pairs.\n\nScientific and numerical requirements:\n- All derivative computations must be implemented explicitly using the specified finite-difference operators; do not use any spectral or analytical identities for norms.\n- All calculations are dimensionless. No physical units are required.\n- The final output must be a single line in the exact format described below.\n\nTest suite and final output format:\n- Use the fixed parameter sets described above, which together form the test suite over $\\Delta t \\in \\{0.2, 0.1, 0.05\\}$ for each tolerance family.\n- Your program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4]\"), where each $r_i$ is a floating-point number computed as specified above.",
            "solution": "The problem posed is a numerical experiment designed to investigate the scaling properties of the residual mass conservation error in a simplified model of the Pressure-Implicit with Splitting of Operators (PISO) algorithm for transient incompressible flows. The primary objective is to determine the observed order of convergence, $p$, of the final divergence norm, $\\lVert \\nabla \\cdot \\mathbf{u}^{n+1} \\rVert_2$, with respect to the time step size, $\\Delta t$, under two different tolerance schedules for the inner pressure-correction loop.\n\nThe theoretical foundation of this problem lies in projection methods for the incompressible Navier-Stokes equations. These methods decouple the computation of velocity and pressure. A typical time step involves first predicting a provisional velocity field, $\\mathbf{u}^\\star$, by solving a momentum equation without strictly enforcing the divergence-free constraint. This $\\mathbf{u}^\\star$ generally has a non-zero divergence, $\\nabla \\cdot \\mathbf{u}^\\star \\neq 0$. Subsequently, a pressure correction, $\\phi$, is computed by solving a pressure Poisson equation, $\\Delta \\phi \\propto \\nabla \\cdot \\mathbf{u}^\\star$, which is then used to correct both the velocity and pressure fields to satisfy the constraint, i.e., $\\mathbf{u}^{n+1} = \\mathbf{u}^\\star - \\tau \\nabla \\phi$, where $\\tau$ is related to $\\Delta t$. The PISO algorithm repeats this correction step multiple times within a single time step to improve the approximation of the divergence-free condition.\n\nThis problem provides a well-defined abstraction of this process.\n1.  A known divergence-free flow, the Taylor-Green vortex $\\mathbf{u}_{\\mathrm{base}}$, represents the exact solution at the new time level $t^{n+1}$.\n2.  The provisional velocity, $\\mathbf{u}^{\\star} = \\mathbf{u}_{\\mathrm{base}} + \\Delta t \\nabla \\chi$, mimics the outcome of a momentum predictor. The term $\\Delta t \\nabla \\chi$ introduces a non-zero divergence, $\\nabla \\cdot \\mathbf{u}^{\\star} = \\Delta t \\Delta \\chi$, which is proportional to the time step $\\Delta t$, a characteristic feature of many splitting schemes.\n3.  The PISO inner loop is modeled as an iterative process that reduces the norm of the divergence, $R_k = \\lVert \\nabla \\cdot \\mathbf{u}_k \\rVert_2$, by a constant factor $\\theta$ at each iteration: $R_{k+1} = \\theta R_k$. This represents the convergence of a stationary iterative solver (like Jacobi or Gauss-Seidel) for the pressure Poisson equation.\n4.  The loop terminates based on a tolerance $\\epsilon(\\Delta t)$ that depends on the time step. This is a crucial aspect, as the choice of tolerance balancing accuracy and computational cost is a key practical consideration.\n\nWe will now detail the numerical procedure.\n\nFirst, we define the computational grid. The domain is a periodic unit square $[0,1] \\times [0,1]$ discretized by $N \\times N$ points, with $N=64$. The grid coordinates are $(x_i, y_j)$, where $x_i = i \\Delta x$ and $y_j = j \\Delta y$ for $i, j \\in \\{0, 1, \\dots, N-1\\}$. The grid spacing is uniform, $\\Delta x = \\Delta y = 1/N$.\n\nThe analytical fields are evaluated on this grid:\n-   Base velocity components: $u_{\\mathrm{base}, i,j} = \\sin(2\\pi x_i)\\cos(2\\pi y_j)$ and $v_{\\mathrm{base}, i,j} = -\\cos(2\\pi x_i)\\sin(2\\pi y_j)$.\n-   Perturbation potential: $\\chi_{i,j} = \\sin(2\\pi x_i)\\sin(2\\pi y_j)$.\n\nThe core of the numerical calculation involves discrete differential operators. We use second-order central differences with periodic wrapping. For any grid function $\\phi_{i,j}$, the partial derivatives are approximated as:\n$$ (\\delta_x \\phi)_{i,j} = \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2\\Delta x} $$\n$$ (\\delta_y \\phi)_{i,j} = \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2\\Delta y} $$\nwhere indices are taken modulo $N$ to enforce periodicity.\n\nThe computational procedure for each given $\\Delta t$ is as follows:\n\n1.  **Compute the provisional velocity $\\mathbf{u}^{\\star}$**:\n    The components of the provisional velocity, $\\mathbf{u}^{\\star} = (u^\\star, v^\\star)$, are constructed by adding the discretized gradient of the perturbation potential to the base flow:\n    $$ u^\\star_{i,j} = u_{\\mathrm{base}, i,j} + \\Delta t (\\delta_x \\chi)_{i,j} $$\n    $$ v^\\star_{i,j} = v_{\\mathrm{base}, i,j} + \\Delta t (\\delta_y \\chi)_{i,j} $$\n\n2.  **Compute the divergence of $\\mathbf{u}^{\\star}$**:\n    The discrete divergence of the provisional velocity field, $D_{i,j} = (\\nabla_h \\cdot \\mathbf{u}^\\star)_{i,j}$, is computed at each grid point:\n    $$ D_{i,j} = (\\delta_x u^\\star)_{i,j} + (\\delta_y v^\\star)_{i,j} $$\n\n3.  **Calculate the initial divergence norm $R_0(\\Delta t)$**:\n    The initial error is quantified by the discrete $L^2$-norm of the divergence field:\n    $$ R_0(\\Delta t) = \\left\\| \\nabla_h \\cdot \\mathbf{u}^\\star \\right\\|_2 = \\sqrt{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} D_{i,j}^2 \\, \\Delta x \\, \\Delta y} $$\n\n4.  **Determine the number of corrections $k$**:\n    For a given tolerance family defined by $C$ and $\\alpha$, the tolerance is $\\epsilon(\\Delta t) = C \\Delta t^\\alpha$. We find the minimum integer $k \\ge 0$ such that the corrected divergence norm, $R_k(\\Delta t) = \\theta^k R_0(\\Delta t)$, meets the tolerance:\n    $$ \\theta^k R_0(\\Delta t) \\le \\epsilon(\\Delta t) $$\n    If $R_0(\\Delta t) \\le \\epsilon(\\Delta t)$, then $k=0$. Otherwise, taking the logarithm (and noting $\\log(\\theta) < 0$ since $\\theta=0.5$), we find $k \\ge \\frac{\\log(\\epsilon(\\Delta t) / R_0(\\Delta t))}{\\log(\\theta)}$. The smallest integer $k$ is therefore:\n    $$ k = \\left\\lceil \\frac{\\log(\\epsilon(\\Delta t) / R_0(\\Delta t))}{\\log(\\theta)} \\right\\rceil $$\n\n5.  **Compute the final divergence norm $R_k(\\Delta t)$**:\n    The final residual divergence after $k$ corrections is simply $R_k(\\Delta t) = \\theta^k R_0(\\Delta t)$. This value is stored for each $\\Delta t$ in the test suite.\n\nThis procedure is executed for each time step $\\Delta t \\in \\{0.2, 0.1, 0.05\\}$ and for both tolerance families: Family A ($\\alpha=2, C=10^{-2}$) and Family B ($\\alpha=1, C=10^{-2}$).\n\nFinally, we compute the observed order of convergence, $p$. Given a set of three final norms $\\{R_k(\\Delta t_1), R_k(\\Delta t_2), R_k(\\Delta t_3)\\}$ corresponding to time steps $\\{\\Delta t_1, \\Delta t_2, \\Delta t_3\\}$, the order $p$ is estimated between consecutive pairs using the formula:\n$$ p = \\frac{\\log(R_k(\\Delta t_i) / R_k(\\Delta t_{i+1}))}{\\log(\\Delta t_i / \\Delta t_{i+1})} $$\nFor our time step suite, the ratio $\\Delta t_i / \\Delta t_{i+1}$ is always $2$, so the denominator simplifies to $\\log(2)$.\n\nThe expected result is that the final divergence norm $R_k(\\Delta t)$ will scale similarly to the tolerance $\\epsilon(\\Delta t)$, because the iterative process stops when the norm is approximately on the order of the tolerance. Therefore, we anticipate that the observed order $p$ for Family A will be close to $\\alpha=2$, and for Family B it will be close to $\\alpha=1$. The implementation will precisely calculate these orders.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Implements a numerical experiment to measure the scaling of residual divergence\n    in a simplified PISO-like algorithm for two different tolerance schedules.\n    \"\"\"\n    # Fixed numerical choices from the problem statement\n    N = 64\n    theta = 0.5\n    delta_t_suite = [0.2, 0.1, 0.05]\n\n    # Define the two families of tolerances epsilon(dt) = C * dt^alpha\n    families = [\n        {'C': 1e-2, 'alpha': 2, 'name': 'A'},\n        {'C': 1e-2, 'alpha': 1, 'name': 'B'}\n    ]\n\n    all_orders = []\n\n    # Setup computational grid\n    dx = 1.0 / N\n    dy = 1.0 / N\n    # Create coordinate arrays. endpoint=False for periodic domain [0, 1)\n    x = np.linspace(0, 1, N, endpoint=False)\n    y = np.linspace(0, 1, N, endpoint=False)\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # Define helper functions for discrete derivatives\n    def central_diff_x(field, hx):\n        # Second-order central difference in x-direction with periodic boundaries\n        return (np.roll(field, -1, axis=1) - np.roll(field, 1, axis=1)) / (2.0 * hx)\n\n    def central_diff_y(field, hy):\n        # Second-order central difference in y-direction with periodic boundaries\n        return (np.roll(field, -1, axis=0) - np.roll(field, 1, axis=0)) / (2.0 * hy)\n\n    # Evaluate analytical fields on the grid\n    u_base = np.sin(2 * np.pi * xx) * np.cos(2 * np.pi * yy)\n    v_base = -np.cos(2 * np.pi * xx) * np.sin(2 * np.pi * yy)\n    chi = np.sin(2 * np.pi * xx) * np.sin(2 * np.pi * yy)\n\n    # Pre-compute gradient of chi\n    grad_chi_x = central_diff_x(chi, dx)\n    grad_chi_y = central_diff_y(chi, dy)\n\n    # --- Main loop over tolerance families ---\n    for family in families:\n        C = family['C']\n        alpha = family['alpha']\n        final_norms = []\n\n        # --- Loop over the time-step suite ---\n        for delta_t in delta_t_suite:\n            # 1. Construct the provisional velocity field u_star\n            u_star = u_base + delta_t * grad_chi_x\n            v_star = v_base + delta_t * grad_chi_y\n\n            # 2. Compute the discrete divergence of u_star\n            div_u_star = central_diff_x(u_star, dx) + central_diff_y(v_star, dy)\n\n            # 3. Compute the initial divergence L2-norm, R0\n            R0 = np.sqrt(np.sum(div_u_star**2) * dx * dy)\n\n            # 4. Determine the number of corrections, k\n            epsilon = C * (delta_t**alpha)\n            \n            if R0 <= epsilon:\n                k = 0\n            else:\n                # Calculate smallest integer k s.t. theta^k * R0 <= epsilon\n                k_float = math.log(epsilon / R0) / math.log(theta)\n                k = math.ceil(k_float)\n\n            # 5. Compute the final divergence norm, Rk\n            Rk = (theta**k) * R0\n            final_norms.append(Rk)\n\n        # --- Compute observed orders for the current family ---\n        # Order for pair (dt_1, dt_2) = (0.2, 0.1)\n        p1 = (math.log(final_norms[0] / final_norms[1]) /\n              math.log(delta_t_suite[0] / delta_t_suite[1]))\n        \n        # Order for pair (dt_2, dt_3) = (0.1, 0.05)\n        p2 = (math.log(final_norms[1] / final_norms[2]) /\n              math.log(delta_t_suite[1] / delta_t_suite[2]))\n        \n        all_orders.extend([p1, p2])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_orders))}]\")\n\nsolve()\n\n```"
        }
    ]
}