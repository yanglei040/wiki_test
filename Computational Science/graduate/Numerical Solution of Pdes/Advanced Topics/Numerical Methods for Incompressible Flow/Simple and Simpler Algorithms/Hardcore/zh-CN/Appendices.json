{
    "hands_on_practices": [
        {
            "introduction": "在计算流体动力学中，验证数值方法的正确实施是至关重要的一步。制造解方法（Method of Manufactured Solutions, MMS）是用于此目的的严谨技术，它允许我们精确量化离散化误差。此练习  将指导您应用MMS来验证SIMPLE族算法核心部分——压力修正方程的空间收敛阶，从而加深您对离散化精度和代码验证的理解。",
            "id": "3362285",
            "problem": "考虑在单位正方形 $\\Omega = (0,1)\\times(0,1)$ 上，具有恒定密度 $\\rho$ 和运动粘度 $\\nu$ 的牛顿流体的二维稳态不可压缩流动。控制方程为稳态不可压缩 Navier–Stokes 方程，\n$$\n\\nabla\\cdot \\mathbf{u} = 0,\\quad\n\\rho\\,(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\rho\\,\\nu\\,\\nabla^2 \\mathbf{u} + \\mathbf{f},\n$$\n速度边界条件为无滑移条件，压力修正的狄利克雷边界条件在 $\\partial\\Omega$ 上如下文所述。此处 $\\mathbf{u} = (u,v)$ 是速度场，$p$ 是压力。\n\n您将采用“人造解方法”（Method of Manufactured Solutions）来构造一个精确的解析解，并用它来验证三种压力-速度耦合算法计算出的压力修正 $p'$ 的空间收敛阶：SIMPLE（Semi-Implicit Method for Pressure-Linked Equations，半隐式压力耦合方程算法）、SIMPLER（Semi-Implicit Method for Pressure-Linked Equations Revised，修正的半隐式压力耦合方程算法）和 SIMPLEC（Semi-Implicit Method for Pressure-Linked Equations Consistent，一致的半隐式压力耦合方程算法）。\n\n人造解析解：\n- 选择速度场\n$$\nu(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y),\\qquad v(x,y) = -\\cos(\\pi x)\\,\\sin(\\pi y),\n$$\n对所有 $(x,y)\\in\\Omega$ 都满足 $\\nabla\\cdot\\mathbf{u}=0$。选择压力场\n$$\np(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n在 $\\partial\\Omega$ 上满足 $p(x,y)=0$。利用这些，可以构造一个体积力 $\\mathbf{f}(x,y)$，使得 $(\\mathbf{u},p)$ 成为稳态方程的精确解。\n\nSIMPLE 族算法中的压力修正方程：\n- 在压力-速度耦合框架中，压力修正 $p'$ 满足一个泊松型压力修正方程，该方程源于在预测的质量通量上强制执行质量守恒。在均匀网格上，使用中心差分且动量方程对角线系数为常数时，压力修正方程简化为\n$$\n\\nabla^2 p'(x,y) = s(x,y),\n$$\n边界条件为 $\\partial\\Omega$ 上的齐次狄利克雷条件 $p'(x,y)=0$。为验证目的，设人造压力修正为 $p'(x,y) = p(x,y)$，并假设猜测压力为零，源项则相应地定义为\n$$\ns(x,y) = -\\nabla^2 p'(x,y) = 2\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n使得压力修正方程的精确解为 $p'(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y)$。\n\n您的任务：\n- 从稳态不可压缩 Navier–Stokes 方程和 SIMPLE 族算法中压力修正方程的定义出发，证明在给定的人造解假设（均匀网格、常系数、中心差分、狄利克雷边界数据）下，SIMPLE、SIMPLER 和 SIMPLEC 的离散压力修正方程均可简化为关于 $p'(x,y)$ 的标量泊松问题的相同二阶中心差分近似。\n\n- 实现一个求解器，在一系列覆盖 $\\Omega$ 的均匀笛卡尔网格上使用二阶中心差分来近似 $p'(x,y)$。网格由每个坐标方向上的等分数量 $N\\in\\{8,16,32,64\\}$ 指定，因此网格间距为 $h=1/N$，未知量位于每个方向的 $N-1$ 个内点上，边界上 $p'=0$。对每个 $N$ 值，组装标准的五点离散拉普拉斯算子，并求解得到的线性系统。\n\n- 对于每个 $N$，计算数值解 $p'_h$ 相对于精确人造解 $p'(x,y)$ 的离散 $\\ell^2$ 误差。离散 $\\ell^2$ 误差必须定义为\n$$\nE(h) = \\left(\\sum_{i=1}^{N-1}\\sum_{j=1}^{N-1} \\left(p'_h(x_i,y_j) - p'(x_i,y_j)\\right)^2\\right)^{1/2}\\,h,\n$$\n其中 $x_i=i\\,h$，$y_j=j\\,h$，对于 $i=1,\\dots,N-1$ 和 $j=1,\\dots,N-1$。\n\n- 对于每种算法变体（SIMPLE、SIMPLER、SIMPLEC），使用两个最细的网格计算 $p'$ 的观测收敛阶 $r$，公式为\n$$\nr = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)},\n$$\n其中 $h=1/32$ 且 $h/2=1/64$。在此人造解设置中，三种算法对压力修正方程使用相同的空间离散化，因此观测到的 $r$ 值应该相等且接近 2。\n\n测试套件和输出规范：\n- 使用网格尺寸 $N\\in\\{8,16,32,64\\}$ 作为测试套件，以覆盖一个粗网格边缘情况和逐渐加密的网格。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序为 $[\\text{SIMPLE},\\text{SIMPLER},\\text{SIMPLEC}]$，每个条目是如上计算的浮点值 $r$，例如 $[r_{\\text{SIMPLE}},r_{\\text{SIMPLER}},r_{\\text{SIMPLEC}}]$。",
            "solution": "控制方程为稳态不可压缩 Navier–Stokes 方程，\n$$\n\\nabla\\cdot \\mathbf{u} = 0,\\qquad\n\\rho\\,(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\rho\\,\\nu\\,\\nabla^2 \\mathbf{u} + \\mathbf{f}.\n$$\n我们选择人造场\n$$\nu(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y),\\quad v(x,y) = -\\cos(\\pi x)\\,\\sin(\\pi y),\\quad p(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n它们满足不可压缩性条件，因为\n$$\n\\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}\n= \\pi\\cos(\\pi x)\\,\\cos(\\pi y) - \\pi\\cos(\\pi x)\\,\\cos(\\pi y) = 0.\n$$\n给定 $\\rho$ 和 $\\nu$，可将 $(\\mathbf{u},p)$ 代入动量方程，并计算出使 $(\\mathbf{u},p)$ 成为精确解的体积力 $\\mathbf{f}(x,y)$；这利用了控制定律的基本原理。\n\nSIMPLE（Semi-Implicit Method for Pressure-Linked Equations）族算法中的压力-速度耦合引入了根据猜测压力计算的中间速度 $\\mathbf{u}^*$，随后使用压力修正 $p'$ 来校正质量通量以满足连续性方程。修正步骤满足一个压力修正方程，该方程由离散的连续性方程和离散的动量方程推导而来。在一般的有限体积形式下，离散压力修正方程可写为\n$$\n\\sum_{f\\in \\text{faces}} \\rho\\,d_f\\,\\left(p'_N - p'_P\\right) = \\sum_{f\\in \\text{faces}} \\dot{m}^*_f,\n$$\n其中 $d_f$ 是代表动量方程对角线系数的倒数和几何因子的系数，$P$ 表示当前单元，$N$ 表示相邻单元，$\\dot{m}^*_f$ 是违反连续性方程的预测质量通量。在具有恒定属性和中心差分的均匀网格上，动量方程的对角线系数 $a_P$ 在所有单元中是常数，面系数 $d_f$ 也变为常数，预测质量通量的离散散度简化为 $p'$ 的离散拉普拉斯算子的一个均匀缩放。因此，当猜测压力为零且精确压力在边界上为零时，修正方程简化为标量泊松问题\n$$\n\\nabla^2 p'(x,y) = s(x,y)\n$$\n且在 $\\partial\\Omega$ 上有 $p'$ 的齐次狄利克雷边界条件。这种简化仅使用了算法的核心定义和结构，而没有调用捷径公式。SIMPLE（Semi-Implicit Method for Pressure-Linked Equations）、SIMPLER（Semi-Implicit Method for Pressure-Linked Equations Revised）和 SIMPLEC（Semi-Implicit Method for Pressure-Linked Equations Consistent）之间的区别在于中间速度 $\\mathbf{u}^*$ 和耦合系数的形成方式，但在人造的均匀系数设定下，它们对压力修正方程的空间离散化是相同的。\n\n为了构造源项，我们取 $p'(x,y) = p(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y)$（这与猜测压力为零一致），因此\n$$\n\\nabla^2 p'(x,y) = \\frac{\\partial^2}{\\partial x^2}\\sin(\\pi x)\\,\\sin(\\pi y) + \\frac{\\partial^2}{\\partial y^2}\\sin(\\pi x)\\,\\sin(\\pi y)\n= -\\pi^2\\sin(\\pi x)\\,\\sin(\\pi y) - \\pi^2\\sin(\\pi x)\\,\\sin(\\pi y) = -2\\pi^2\\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n因而\n$$\ns(x,y) = -\\nabla^2 p'(x,y) = 2\\pi^2\\sin(\\pi x)\\,\\sin(\\pi y).\n$$\n\n我们在间距为 $h=1/N$、内点为 $(x_i,y_j) = (i h, j h)$（其中 $i=1,\\dots,N-1$ 且 $j=1,\\dots,N-1$）的均匀网格上离散化泊松方程。在笛卡尔网格上对 $\\nabla^2 p'$ 的标准二阶中心差分近似得到五点模板，\n$$\n\\left(\\nabla^2 p'\\right)_{i,j} \\approx \\frac{p'_{i+1,j} - 2 p'_{i,j} + p'_{i-1,j}}{h^2} + \\frac{p'_{i,j+1} - 2 p'_{i,j} + p'_{i,j-1}}{h^2},\n$$\n这提供了关于 $h$ 的二阶近似。在 $\\partial\\Omega$ 上应用齐次狄利克雷边界条件 $p'=0$，离散系统可写为矩阵形式\n$$\n\\mathbf{L}\\,\\mathbf{p} = h^2\\,\\mathbf{s},\n$$\n其中 $\\mathbf{L}$ 是具有五点模板的离散二维拉普拉斯算子，$\\mathbf{p}$ 和 $\\mathbf{s}$ 是内节点上未知数和源项值的向量。\n\n离散 $\\ell^2$ 误差定义为\n$$\nE(h) = \\left(\\sum_{i=1}^{N-1}\\sum_{j=1}^{N-1} \\left(p'_h(x_i,y_j) - p'(x_i,y_j)\\right)^2\\right)^{1/2}\\,h,\n$$\n这是对连续 $L^2$ 范数的一致求积。对于二阶中心差分，截断误差为 $\\mathcal{O}(h^2)$，对于均匀网格上的光滑解，在狄利克雷边界条件下，离散解以 $h$ 的 2 阶收敛，因此我们期望\n$$\nE(h) \\approx C\\,h^2\n$$\n对于某个常数 $C$，这导致观测到的收敛阶\n$$\nr = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)} \\approx 2.\n$$\n\n在所描述的人造解设置中，SIMPLE（Semi-Implicit Method for Pressure-Linked Equations）、SIMPLER（Semi-Implicit Method for Pressure-Linked Equations Revised）和 SIMPLEC（Semi-Implicit Method for Pressure-Linked Equations Consistent）对压力修正方程共享相同的空间离散化，因此当线性系统求解至收敛时，会产生相同的 $p'$ 解。因此，计算 $h=1/32$ 和 $h/2=1/64$ 时的 $E(h)$ 并如上构造 $r$，应得到三个相等且接近 2 的值。该实现使用二维离散拉普拉斯算子的克罗内克和（Kronecker-sum）构造以及一个直接稀疏线性求解器，以消除迭代效应并分离出空间离散化误差，这与基于原理的推导和验证任务相一致。\n\n程序评估了 $N\\in\\{8,16,32,64\\}$ 时的误差，并报告了从两个最细网格计算出的三个观测阶数 $[r_{\\text{SIMPLE}}, r_{\\text{SIMPLER}}, r_{\\text{SIMPLEC}}]$，从而验证了在此人造、均匀系数的极限情况下，所有三种算法的 $p'$ 在网格加密下的二阶收敛性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, kron, identity\nfrom scipy.sparse.linalg import spsolve\n\ndef build_poisson_matrix(m):\n    \"\"\"\n    Build the 2D Poisson matrix with Dirichlet boundary conditions\n    on an m x m interior grid using the 5-point Laplacian.\n    \"\"\"\n    # 1D Laplacian (Dirichlet interior nodes): tridiagonal [-1, 2, -1]\n    main = -2.0 * np.ones(m)\n    off = 1.0 * np.ones(m - 1)\n    L1 = diags([off, main, off], offsets=[-1, 0, 1], format='csr')\n    I = identity(m, format='csr')\n    # 2D Laplacian via Kronecker sum\n    L2 = kron(I, L1) + kron(L1, I)\n    return L2\n\ndef manufactured_source_and_exact(N):\n    \"\"\"\n    Compute source term s(x,y) = 2*pi^2*sin(pi*x)*sin(pi*y)\n    and exact p'(x,y) at interior points for grid size N (spacing h=1/N).\n    Returns (s_flat, p_exact_flat).\n    \"\"\"\n    h = 1.0 / N\n    m = N - 1\n    x = np.linspace(h, 1.0 - h, m)\n    y = np.linspace(h, 1.0 - h, m)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    p_exact = np.sin(np.pi * X) * np.sin(np.pi * Y)\n    s = 2.0 * (np.pi ** 2) * p_exact\n    return s.ravel(), p_exact.ravel()\n\ndef solve_poisson(N):\n    \"\"\"\n    Solve L p = h^2 * s for p on interior grid for given N,\n    with exact source manufactured from p'(x,y) = sin(pi*x)*sin(pi*y).\n    Returns L2 error E(h) with discrete quadrature.\n    \"\"\"\n    h = 1.0 / N\n    m = N - 1\n    L = build_poisson_matrix(m)\n    s_flat, p_exact_flat = manufactured_source_and_exact(N)\n    rhs = (h ** 2) * s_flat\n    p_num = spsolve(L, rhs)\n    # Discrete L2 error: sqrt(sum((error)^2)) * h\n    err = p_num - p_exact_flat\n    E = np.sqrt(np.sum(err ** 2)) * h\n    return E\n\ndef observed_order(e_h, e_h2):\n    \"\"\"\n    Compute observed order r = log(e_h/e_h2)/log(2),\n    where h2 = h/2 (i.e., N doubled).\n    \"\"\"\n    return np.log(e_h / e_h2) / np.log(2.0)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    grid_sizes = [8, 16, 32, 64]\n\n    # Compute errors for each grid size.\n    errors = {}\n    for N in grid_sizes:\n        errors[N] = solve_poisson(N)\n\n    # Compute observed order using the two finest grids N=32 and N=64.\n    e32 = errors[32]\n    e64 = errors[64]\n    r = observed_order(e32, e64)\n\n    # In this manufactured uniform-coefficient setting, SIMPLE, SIMPLER, and SIMPLEC\n    # produce identical spatial discretizations for the pressure correction equation,\n    # hence identical observed orders.\n    results = [r, r, r]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在求解不可压缩流动的压力泊松方程时，所形成的线性系统常常是奇异的，这意味着其解并非唯一。正确识别并处理压力矩阵的零空间（nullspace）对于保证求解器的鲁棒性至关重要。本练习  旨在通过奇异值分解（Singular Value Decomposition, SVD）这一强大的线性代数工具，以编程方式诊断并区分由物理边界条件（如诺伊曼边界）引起的常数模式和由离散格式（如同位网格）产生的伪棋盘模式，并提出相应的修正策略。",
            "id": "3443047",
            "problem": "考虑使用压力耦合方程组的半隐式方法（SIMPLE）及其变体——修正的 SIMPLE（SIMPLER）方法来求解不可压缩流。其底层的数学基础是不可压缩的纳维-斯托克斯方程和质量守恒方程，写为 $ \\rho \\left( \\frac{\\partial \\mathbf{u}}{\\partial t} + \\mathbf{u}\\cdot\\nabla \\mathbf{u} \\right) = -\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} $ 和 $ \\nabla \\cdot \\mathbf{u} = 0 $，其中 $ \\rho $ 是密度，$ \\mathbf{u} $ 是速度，$ p $ 是压力，$ \\mu $ 是动力粘度，$ \\mathbf{f} $ 代表体力。在 SIMPLE 方法中，通过使用离散化的连续性方程和动量方程得到的临时速度来强制执行质量守恒，从而产生一个压力修正方程。该压力修正方程可以写成关于压力未知数 $ p $ 的稀疏线性系统 $ A \\, p = b $，其中矩阵 $ A $ 由离散的通量系数组装而成。在许多实际情况下，例如对于齐次诺伊曼边界条件，矩阵 $ A $ 是奇异的，其零空间包含常数向量，这反映了压力仅能定义到一个附加常数。在没有进行适当动量插值的同位网格布置中，零空间中可能还会泄漏一种虚假的“棋盘格”压力模式。\n\n您的任务是构建一个程序化测试，以检测组装后的压力系统 $ A $ 中无意的零空间泄漏，并根据约束强制执行提出补救措施。检测必须基于第一性原理：通过奇异值分解，利用 $ A $ 的谱来识别奇异性，使用结构诊断方法对零空间模式的类型进行分类，并根据诊断结果返回一个可操作的补救代码。\n\n您必须使用的基本原理包括：\n- 不可压缩条件 $ \\nabla \\cdot \\mathbf{u} = 0 $ 意味着存在一个压力修正方程，该方程通常等价于一个作用在 $ p $ 上的、受边界条件约束的离散泊松算子，从而产生一个线性系统 $ A \\, p = b $。\n- 对于代表连通域上具有齐次诺伊曼边界条件的离散泊松算子的图拉普拉斯算子，其性质为 $ A \\, \\mathbf{1} = 0 $，其中 $ \\mathbf{1} $ 是常数向量，这使得矩阵奇异，并具有一维零空间。\n- 在没有进行动量插值的同位网格布置中，离散化过程可能允许压力中出现符号交替的“棋盘格”模式。这可以通过接近于零的奇异值来揭示，其对应的奇异向量与笛卡尔网格上的奇偶模式 $ (-1)^{i+j} $ 具有强相关性。\n\n设计并实现一个单一程序，该程序：\n1. 使用图拉普拉斯算子模型为二维 $ m \\times n $ 网格组装代表性的压力系统矩阵 $ A $。本问题中所有量均为无量纲量。\n2. 对每个组装的 $ A $ 执行奇异值分解，并通过计算低于数值上有意义的容差的奇异值数量来检测零空间泄漏。\n3. 通过检查行和属性，并将最小奇异值对应的右奇异向量与奇偶模式 $ p_{i,j} = (-1)^{i+j} $ 进行相关性分析，来诊断零空间的性质。\n4. 为每个测试用例返回一个包含四个数字的列表 $ [\\text{nullity}, s_{\\min}, \\text{is\\_singular}, \\text{remedy\\_code}] $，其中 $ \\text{nullity} $ 是检测到的零空间的整数维度，$ s_{\\min} $ 是最小奇异值的浮点数，$ \\text{is\\_singular} $ 是一个布尔值，指示是否有任何奇异值低于容差，$ \\text{remedy\\_code} $ 是一个整数，指示推荐的补救措施。\n\n使用以下补救代码定义：\n- $ 0 $: 无需操作。\n- $ 1 $: 强制施加单个参考压力（钉扎一个自由度）以消除常数零空间。\n- $ 2 $: 通过拉格朗日乘子或一致性罚函数强制施加零均值压力约束，以消除常数零空间同时保持守恒性。\n- $ 3 $: 为每个连通分量施加约束（例如，每个分量钉扎一个点或分块零均值约束）以消除多分量零空间。\n- $ 4 $: 应用与 Rhie–Chow 一致的动量插值，或使用交错网格，以抑制棋盘格压力模式。\n\n基于基本原理的检测逻辑要求：\n- 使用奇异值分解计算 $ A $ 的奇异值 $ s_k $。定义一个容差 $ \\tau $，并通过计算奇异值 $ s_k \\le \\tau $ 的数量来检测零空间泄漏。\n- 通过验证 $ A $ 的行和的绝对无穷范数相对于特征对角线幅值非常小，来诊断常数模式零空间，这表示 $ A \\mathbf{1} \\approx \\mathbf{0} $。\n- 通过计算归一化奇偶向量 $ q $（其分量为 $ q_{i,j} = (-1)^{i+j}/\\|q\\|_2 $），并检查最小右奇异向量 $ v_{\\min} $ 是否满足 $ |\\langle v_{\\min}, q \\rangle| \\ge 0.9 $，来诊断棋盘格模式。\n- 通过计算 $ \\text{nullity} > 1 $ 来诊断多分量零空间。\n\n使用无量纲参数构建以下测试套件，以强调不同的失效模式和补救措施：\n- 测试用例 1（连通的齐次诺伊曼边界）：$ m=6 $，$ n=6 $。将 $ A $ 组装为具有单位权重且无钉扎或罚函数的 $ 6 \\times 6 $ 网格的图拉普拉斯算子。预期：一维常数零空间，根据约束偏好推荐补救代码 $ 1 $ 或 $ 2 $。\n- 测试用例 2（参考压力钉扎）：$ m=6 $，$ n=6 $。如测试用例 1 中组装 $ A $，然后通过将坐标 $ (0,0) $ 处节点对应的行和列设置为零，并在该位置的对角线上放置一个 $ 1 $ 来钉扎该节点。预期：无零空间泄漏。\n- 测试用例 3（非连通域）：$ m=6 $，$ n=6 $。组装 $ A $ 作为图拉普拉斯算子，但移除列 $ 2 $ 和列 $ 3 $（从零开始的索引）之间的垂直切割线上的边，从而产生两个非连通的分量。预期：由每个分量上的常数张成的二维零空间，推荐补救代码 $ 3 $。\n- 测试用例 4（棋盘格零空间）：$ m=6 $，$ n=6 $。组装一个非奇异的基底矩阵 $ A_{\\text{base}} $（通过像测试用例 2 那样钉扎 $ (0,0) $），然后使用归一化的奇偶向量 $ q $ 构建 $ A = A_{\\text{base}} - (A_{\\text{base}} q) q^{\\top} $，这会在棋盘格方向上引入一个精确的零空间。预期：具有强奇偶相关性的一维零空间，推荐补救代码 $ 4 $。\n- 测试用例 5（零均值罚函数）：$ m=6 $，$ n=6 $。如测试用例 1 中组装 $ A $，然后添加一个秩为一的均值罚函数 $ A \\leftarrow A + \\alpha \\,\\mathbf{1}\\mathbf{1}^{\\top} $，其中 $ \\alpha = 10^{-2} $。预期：无零空间泄漏。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的列表形式的结果，每个元素是对应测试用例的四元列表。例如，输出格式必须为 $ [\\text{case1\\_result},\\text{case2\\_result},\\dots] $，并且每个 $ \\text{caseX\\_result} $ 必须为 $ [\\text{nullity}, s_{\\min}, \\text{is\\_singular}, \\text{remedy\\_code}] $ 的形式。本问题中所有量均为无量纲量，不使用物理单位或角度单位。程序必须是自包含的，不需要用户输入，并且只使用指定的库。",
            "solution": "推导始于不可压缩条件 $ \\nabla \\cdot \\mathbf{u} = 0 $ 和动量方程 $ \\rho \\left( \\frac{\\partial \\mathbf{u}}{\\partial t} + \\mathbf{u}\\cdot\\nabla \\mathbf{u} \\right) = -\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} $。在压力耦合方程组的半隐式方法（SIMPLE）中，通过使用猜测的压力场 $ p^{*} $ 对动量方程进行离散化，可以得到临时速度 $ \\mathbf{u}^{*} $。然后通过求解一个压力修正方程，将连续性方程的残差 $ r = \\nabla \\cdot \\mathbf{u}^{*} $ 驱动至零。其代数形式源于对质量守恒和动量耦合的离散化，从而产生一个关于压力修正量 $ p' $ 的稀疏线性系统 $ A \\, p' = b $，其中 $ A $ 由通量耦合系数组装而成，$ b $ 来自临时速度的散度和边界项。修正的 SIMPLE（SIMPLER）算法修改了耦合方式以改进压力和速度的更新，但仍然需要求解一个类压力方程。\n\n对于压力修正量具有齐次诺伊曼边界条件的连通域，得到的算子 $ A $ 是具有零法向导数边界条件的拉普拉斯算子的离散模拟。其离散结构可以表示为图拉普拉斯算子：对于每个内部节点，$ A_{ii} $ 等于邻居连接的数量，$ A_{ij} = -1 $ 表示每个邻居 $ j $。这种构造满足 $ A \\mathbf{1} = \\mathbf{0} $，因为每一行的和都为零，这揭示了一个由常数向量 $ \\mathbf{1} $ 张成的一维零空间。因此，该矩阵是奇异的，这与压力仅能定义到一个附加常数的物理陈述相一致。\n\n约束以不同的方式消除奇异性。钉扎单个压力自由度，即将其对应的行和列设置为零并在对角线上置一，这会破坏常数模式的零空间，从而产生一个非奇异系统。施加零均值约束可以通过引入一个增广的鞍点系统的拉格朗日乘子，或通过添加一个小的秩一罚函数 $ \\alpha \\, \\mathbf{1} \\mathbf{1}^{\\top} $ 来实现；两种方法都会导致 $ A \\mathbf{1} \\ne \\mathbf{0} $。对于具有多个非连通分量的域，图拉普拉斯算子的零空间由每个分量上的常数张成，导致零空间的维度大于一。这需要对每个分量施加约束，例如每个块钉扎一个点或分块零均值约束。在没有适当动量插值的同位网格布置中，SIMPLE 方法中组装的压力方程可能会容纳一个虚假的棋盘格模式。由 $ q_{i,j} = (-1)^{i+j} $ 定义的奇偶模式 $ q $ 捕捉了通常与这种虚假模式相关的双色交替现象。一个在其零空间中容纳 $ q $ 的矩阵可以通过从一个非奇异的基底 $ A_{\\text{base}} $（例如，带有一个钉扎点）出发，并应用秩一修正 $ A = A_{\\text{base}} - (A_{\\text{base}} q) q^{\\top} $ 来构造，这确保了 $ A q = \\mathbf{0} $，因为对于归一化的 $ q $，$ A q = A_{\\text{base}} q - (A_{\\text{base}} q) (q^{\\top} q) = \\mathbf{0} $。\n\n通过奇异值分解（SVD）进行检测是有原理依据的。计算 $ U \\Sigma V^{\\top} = A $，其中 $ \\Sigma $ 包含奇异值 $ s_1 \\ge s_2 \\ge \\dots \\ge s_N \\ge 0 $。定义一个数值容差 $ \\tau $ 来将奇异值分类为有效零，例如 $ \\tau = \\max( \\epsilon \\, s_{\\max} \\, N \\, c, \\tau_{\\min} ) $，其中 $ \\epsilon $ 是机器精度（对于双精度 $ \\epsilon \\approx 2.22 \\times 10^{-16} $），$ s_{\\max} = s_1 $，$ N $ 是维度，$ c $ 是一个适中的常数（如 $ 10 $），$ \\tau_{\\min} $ 是一个下限（如 $ 10^{-14} $）。零度（nullity）是奇异值 $ s_k \\le \\tau $ 的数量。最小奇异值 $ s_{\\min} = s_N $ 指示了奇异程度。\n\n为了对零空间模式进行分类，使用了两种诊断方法。首先，检查行和属性：计算 $ r_i = \\sum_j A_{ij} $ 及其无穷范数 $ \\| r \\|_{\\infty} $。如果 $ \\| r \\|_{\\infty} $ 相对于特征对角线幅值 $ d = \\frac{1}{N} \\sum_i |A_{ii}| $ 极小，则 $ A \\mathbf{1} \\approx \\mathbf{0} $，奇异性反映了齐次诺伊曼边界典型的常数模式零空间。其次，通过构建归一化的奇偶向量 $ q $ 并测量相关性 $ \\gamma = |\\langle v_{\\min}, q \\rangle| $ 来检查棋盘格模式，其中 $ v_{\\min} $ 是与 $ s_{\\min} $ 相关联的右奇异向量。如果 $ \\gamma \\ge 0.9 $，则最小模式与奇偶模式高度对齐，推荐的补救措施是应用如 Rhie–Chow 的动量插值或采用交错网格。\n\n补救措施由诊断结果建议：\n- 如果矩阵非奇异（$ \\text{nullity} = 0 $），建议代码 $ 0 $。\n- 如果行和指示存在常数零空间且 $ \\text{nullity} = 1 $，建议代码 $ 1 $（参考压力钉扎）或代码 $ 2 $（零均值约束）；此处我们选择代码 $ 1 $ 作为最小修复。\n- 如果 $ \\text{nullity} > 1 $ 且行和指示每个分量存在常数模式（如非连通图），建议代码 $ 3 $。\n- 如果奇偶相关性超过阈值，即使其他诊断也适用，也建议使用代码 $ 4 $，因为抑制棋盘格模式至关重要。\n\n该测试套件检验了不同的情况：\n- 连通的齐次诺伊曼压力算子产生 $ \\text{nullity} = 1 $ 并建议钉扎。\n- 钉扎一个节点产生一个非奇异系统并建议无操作。\n- 非连通域产生 $ \\text{nullity} = 2 $ 并建议分量级约束。\n- 棋盘格零空间产生 $ \\text{nullity} = 1 $ 且具有强奇偶相关性，并建议采用 Rhie–Chow 风格的插值。\n- 零均值罚函数产生一个非奇异系统并建议无操作。\n\n程序使用图拉普拉斯算子模型为 $ m \\times n $ 网格组装矩阵，应用指定的修改，运行 SVD 计算 $ s_{\\min} $ 和零度，通过行和与奇偶相关性诊断模式，并为每个案例以所需格式 $ [\\text{nullity}, s_{\\min}, \\text{is\\_singular}, \\text{remedy\\_code}] $ 输出一个列表，并聚合成一个由方括号括起来的、逗号分隔的列表组成的单行。所有变量均为无量纲，输出包含无单位的布尔值和浮点数，满足要求。",
            "answer": "```python\nimport numpy as np\n\ndef grid_index(i, j, n_cols):\n    return i * n_cols + j\n\ndef build_graph_laplacian(m, n, disconnected=False):\n    \"\"\"\n    Build the graph Laplacian for an m x n grid with unit weights.\n    If disconnected=True, remove edges across a vertical cut between columns c and c+1,\n    where c = n//2 - 1, to create two disconnected components.\n    \"\"\"\n    N = m * n\n    A = np.zeros((N, N), dtype=float)\n    cut_col = n // 2 - 1  # vertical cut between cut_col and cut_col+1\n    for i in range(m):\n        for j in range(n):\n            idx = grid_index(i, j, n)\n            degree = 0\n            # Up\n            if i - 1 >= 0:\n                nidx = grid_index(i - 1, j, n)\n                A[idx, nidx] -= 1.0\n                degree += 1\n            # Down\n            if i + 1  m:\n                nidx = grid_index(i + 1, j, n)\n                A[idx, nidx] -= 1.0\n                degree += 1\n            # Left\n            if j - 1 >= 0:\n                # Edge across cut between cut_col and cut_col+1\n                if not (disconnected and j - 1 == cut_col and j == cut_col + 1):\n                    nidx = grid_index(i, j - 1, n)\n                    A[idx, nidx] -= 1.0\n                    degree += 1\n            # Right\n            if j + 1  n:\n                # Edge across cut between cut_col and cut_col+1\n                if not (disconnected and j == cut_col and j + 1 == cut_col + 1):\n                    nidx = grid_index(i, j + 1, n)\n                    A[idx, nidx] -= 1.0\n                    degree += 1\n            A[idx, idx] = degree\n    return A\n\ndef apply_pin(A, pin_idx):\n    \"\"\"\n    Enforce a reference pressure at index pin_idx by zeroing its row and column\n    and setting the diagonal to 1.\n    \"\"\"\n    Ap = A.copy()\n    Ap[pin_idx, :] = 0.0\n    Ap[:, pin_idx] = 0.0\n    Ap[pin_idx, pin_idx] = 1.0\n    return Ap\n\ndef parity_vector(m, n):\n    \"\"\"\n    Construct the normalized parity vector q with entries q_{i,j} = (-1)^{i+j}.\n    \"\"\"\n    N = m * n\n    q = np.zeros(N, dtype=float)\n    for i in range(m):\n        for j in range(n):\n            idx = grid_index(i, j, n)\n            q[idx] = 1.0 if ((i + j) % 2 == 0) else -1.0\n    norm = np.linalg.norm(q)\n    if norm == 0:\n        return q\n    return q / norm\n\ndef induce_checkerboard_nullspace(A_base, m, n):\n    \"\"\"\n    Construct A = A_base - (A_base q) q^T so that A q = 0 exactly,\n    where q is the normalized parity vector.\n    \"\"\"\n    q = parity_vector(m, n)\n    y = A_base @ q\n    # A_new = A_base - y q^T\n    A_new = A_base - np.outer(y, q)\n    return A_new\n\ndef add_mean_zero_penalty(A, alpha):\n    \"\"\"\n    Add a rank-one penalty alpha * 11^T to enforce mean-zero pressure weakly.\n    \"\"\"\n    N = A.shape[0]\n    ones = np.ones((N, N), dtype=float)\n    return A + alpha * ones\n\ndef detect_nullspace_and_remedy(A, m, n):\n    \"\"\"\n    Detect nullspace leakage via SVD, diagnose mode, and suggest remedies.\n    Returns [nullity, s_min, is_singular, remedy_code].\n    \"\"\"\n    # Compute full SVD for diagnostics\n    U, S, Vh = np.linalg.svd(A, full_matrices=False)\n    s_max = S[0] if S.size > 0 else 0.0\n    s_min = S[-1] if S.size > 0 else 0.0\n    # Numerical tolerance for singular values\n    eps = np.finfo(float).eps\n    N = A.shape[0]\n    tau = max(eps * s_max * N * 10.0, 1e-14)\n    nullity = int(np.sum(S = tau))\n    is_singular = nullity > 0\n\n    # Default remedy\n    remedy_code = 0\n\n    if is_singular:\n        # Row-sum diagnostic for constant-mode nullspace\n        row_sums = np.sum(A, axis=1)\n        rs_norm_inf = np.linalg.norm(row_sums, ord=np.inf)\n        diag_mean = float(np.mean(np.abs(np.diag(A))))\n        approx_zero_rowsum = (rs_norm_inf = 1e-12) or (diag_mean > 0 and rs_norm_inf / diag_mean  1e-8)\n\n        # Checkerboard diagnostic via correlation with smallest right-singular vector\n        q = parity_vector(m, n)\n        vmin = Vh[-1, :]\n        vmin_norm = np.linalg.norm(vmin)\n        corr = 0.0\n        if vmin_norm > 0:\n            vmin_unit = vmin / vmin_norm\n            corr = abs(float(np.dot(vmin_unit, q)))\n\n        # Decision logic\n        if corr >= 0.9:\n            remedy_code = 4\n        elif approx_zero_rowsum:\n            if nullity == 1:\n                remedy_code = 1  # single reference pressure\n            else:\n                remedy_code = 3  # per-component constraints\n        else:\n            # Fallback: suggest pinning a degree of freedom\n            remedy_code = 1\n\n    return [nullity, float(s_min), bool(is_singular), int(remedy_code)]\n\ndef solve():\n    # Define test cases (dimensionless)\n    m, n = 6, 6\n    test_cases = [\n        (\"connected_neumann\",),              # Test case 1\n        (\"pinned_reference\",),               # Test case 2\n        (\"disconnected_neumann\",),           # Test case 3\n        (\"checkerboard_nullspace\",),         # Test case 4\n        (\"mean_zero_penalty\",),              # Test case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        kind = case[0]\n        if kind == \"connected_neumann\":\n            A = build_graph_laplacian(m, n, disconnected=False)\n            res = detect_nullspace_and_remedy(A, m, n)\n        elif kind == \"pinned_reference\":\n            A = build_graph_laplacian(m, n, disconnected=False)\n            pin_idx = grid_index(0, 0, n)\n            A = apply_pin(A, pin_idx)\n            res = detect_nullspace_and_remedy(A, m, n)\n        elif kind == \"disconnected_neumann\":\n            A = build_graph_laplacian(m, n, disconnected=True)\n            res = detect_nullspace_and_remedy(A, m, n)\n        elif kind == \"checkerboard_nullspace\":\n            A_base = build_graph_laplacian(m, n, disconnected=False)\n            pin_idx = grid_index(0, 0, n)\n            A_base = apply_pin(A_base, pin_idx)\n            A = induce_checkerboard_nullspace(A_base, m, n)\n            res = detect_nullspace_and_remedy(A, m, n)\n        elif kind == \"mean_zero_penalty\":\n            A = build_graph_laplacian(m, n, disconnected=False)\n            A = add_mean_zero_penalty(A, alpha=1e-2)\n            res = detect_nullspace_and_remedy(A, m, n)\n        else:\n            res = [0, 0.0, False, 0]\n        results.append(res)\n\n    # Final print statement in the exact required format: single line, comma-separated list enclosed in brackets.\n    print(\"[\" + \",\".join(str(r) for r in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在保证了数值格式的准确性和稳定性之后，评估不同算法的收敛性能便成为关键。SIMPLE与SIMPLER算法在迭代效率和鲁棒性方面各有千秋，而直接比较它们在真实流动问题中的表现可能会受到多种因素的干扰。本练习  通过一个受控的合成残差历史模型，巧妙地剥离了离散格式和线性求解器等因素的影响，让您能够专注于算法本身耦合策略的差异，并定量地比较它们的迭代次数和渐近收敛速率。",
            "id": "3442976",
            "problem": "考虑一个单位方形域上的稳态、不可压缩、层流顶盖驱动方腔问题。其控制方程为不可压缩的纳维-斯托克斯方程：质量守恒方程，由 $\\nabla \\cdot \\mathbf{u} = 0$ 给出；以及动量守恒方程，由 $\\rho (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} = -\\nabla p + \\mu \\nabla^2 \\mathbf{u}$ 给出，其中 $\\mathbf{u}$ 是速度场，$p$ 是压力场。在诸如压力关联方程的半隐式方法 (SIMPLE) 和修正的 SIMPLE (SIMPLER) 等迭代式压力-速度耦合方案中，外层不动点过程会产生与离散方程相关的一系列残差向量 $\\{\\mathbf{r}_k\\}_{k \\geq 0}$，其中每个 $\\mathbf{r}_k$ 是耦合的动量和连续性方程的堆叠残差。在一致的线性化和欠松弛条件下，外层迭代可以被建模为一个不动点迭代 $\\mathbf{r}_{k+1} \\approx \\mathbf{M} \\mathbf{r}_k$，其迭代矩阵 $\\mathbf{M}$ 取决于算法的耦合策略。对于足够大的 $k$，残差的范数通常表现出几何衰减，其特征是与谱半径 $\\rho(\\mathbf{M})$ 相关的渐近收敛因子。\n\n要求您实现一个诊断方案，给定在相同的离散化选择、线性求解器和松弛参数下为顶盖驱动方腔问题构建的合成但科学上合理的残差历史，比较压力关联方程的半隐式方法 (SIMPLE) 和修正的 SIMPLE (SIMPLER) 在迭代次数和残差衰减方面的表现。设计的合成历史旨在使任何观察到的差异仅归因于算法耦合的差异，同时保持离散化和线性求解器选择的固定。\n\n为确保普适性和纯数学规范，每种算法 $A \\in \\{\\text{SIMPLE}, \\text{SIMPLER}\\}$ 的残差范数历史由一个受控的参数模型定义：\n$$\nr_k^{(A)} \\;=\\; r_0 \\,\\frac{\\left(c_A\\right)^k \\left(1 + a \\cos(\\pi k)\\right)}{1+a}, \\quad k = 0,1,2,\\dots,K,\n$$\n其中 $r_0  0$ 是初始残差范数（两种算法相同），$c_A \\in (0,1)$ 是模拟渐近线性收敛率的基本收缩因子，$a \\in [0,1)$ 是一个振荡幅度，用于模拟在相同的空间离散化和线性求解器选择下的瞬态非正规效应和可能的棋盘状压力-速度耦合伪影，$K \\in \\mathbb{N}$ 是存储的最大迭代次数。通过 $(1+a)$ 进行归一化可确保 $r_0^{(A)} = r_0$。该模型与具有温和瞬态调制的线性定常迭代的不动点理论一致，并且只要 $a  1$，就能保持所有 $k$ 的 $r_k^{(A)}$ 的正性。\n\n您的程序必须为每种算法和每个测试用例实现以下诊断：\n\n- 达到目标的迭代次数 $N_\\tau^{(A)}$：使 $r_k^{(A)} \\le r_0 \\,\\tau$ 成立的最小 $k \\in \\{0,1,\\dots,K\\}$，其中 $\\tau \\in (0,1)$ 是一个预设的缩减目标。如果在 $\\{0,1,\\dots,K\\}$ 内不存在这样的 $k$，则报告 $N_\\tau^{(A)} = K+1$。\n\n- 估计的渐近收敛因子 $\\widehat{c}^{(A)}$：定义 $\\Delta_k^{(A)} = \\log r_{k+1}^{(A)} - \\log r_k^{(A)}$ 并估计\n$$\n\\widehat{c}^{(A)} \\;=\\; \\exp\\!\\left( \\frac{1}{m} \\sum_{k=K-m}^{K-1} \\Delta_k^{(A)} \\right),\n$$\n其中 $m = \\min\\{M, K\\}$ 且 $M \\in \\mathbb{N}$ 是一个预设的窗口长度。该估计器旨在计算最后 $m$ 步的几何平均收缩因子，并在标准不动点假设下收敛到渐近因子。\n\n- 单调性违例计数 $V^{(A)}$：使得 $r_{k+1}^{(A)}  r_k^{(A)}$ 成立的索引 $k \\in \\{0,1,\\dots,K-1\\}$ 的数量。\n\n使用这些诊断，将 SIMPLER 相对于 SIMPLE 的优越性谓词定义为一个布尔值：\n$$\n\\text{Dominates} \\;=\\; \\Big( N_\\tau^{(\\text{SIMPLER})}  N_\\tau^{(\\text{SIMPLE})} \\Big) \\;\\wedge\\; \\Big( \\widehat{c}^{(\\text{SIMPLER})}  \\widehat{c}^{(\\text{SIMPLE})} - \\delta \\Big),\n$$\n其中 $\\delta  0$ 是一个预设的裕度，用于确保估计的渐近因子之间存在有意义的差距。该谓词可操作地论证了在所有其他条件保持不变的情况下，SIMPLER 在有限的达到目标迭代次数和渐近收敛行为方面都比 SIMPLE 更快地减少残差。\n\n实现一个完整的、可运行的程序，该程序：\n- 对于两种算法和每个测试用例，根据上述参数模型生成残差历史。\n- 对于 $A \\in \\{\\text{SIMPLE}, \\text{SIMPLER}\\}$，计算 $N_\\tau^{(A)}$、$\\widehat{c}^{(A)}$ 和 $V^{(A)}$。\n- 使用裕度 $\\delta$ 评估 SIMPLER 的优越性谓词。\n- 生成最终输出，对每个测试用例，包含列表\n$$\n\\left[\\, N_\\tau^{(\\text{SIMPLE})},\\; N_\\tau^{(\\text{SIMPLER})},\\; \\widehat{c}^{(\\text{SIMPLE})},\\; \\widehat{c}^{(\\text{SIMPLER})},\\; V^{(\\text{SIMPLE})},\\; V^{(\\text{SIMPLER})},\\; \\text{Dominates} \\,\\right],\n$$\n并严格按此顺序。\n\n所有测试用例共用的全局参数：\n- 目标缩减因子 $\\tau = 10^{-6}$。\n- 估计窗口长度 $M = 20$。\n- 渐近差距裕度 $\\delta = 10^{-2}$。\n\n测试套件规范，涵盖一般情况、边界情况、振荡情况和接近停滞的边缘情况：\n- 情况 1 (一般情况): $r_0 = 1.0$, $K = 200$, $a = 0.0$, $c_{\\text{SIMPLE}} = 0.85$, $c_{\\text{SIMPLER}} = 0.65$。\n- 情况 2 (边界情况，速率相等): $r_0 = 1.0$, $K = 200$, $a = 0.0$, $c_{\\text{SIMPLE}} = 0.70$, $c_{\\text{SIMPLER}} = 0.70$。\n- 情况 3 (振荡瞬态): $r_0 = 1.0$, $K = 200$, $a = 0.15$, $c_{\\text{SIMPLE}} = 0.80$, $c_{\\text{SIMPLER}} = 0.75$。\n- 情况 4 (SIMPLE 接近停滞): $r_0 = 1.0$, $K = 500$, $a = 0.02$, $c_{\\text{SIMPLE}} = 0.99$, $c_{\\text{SIMPLER}} = 0.90$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的、按案例划分的列表的逗号分隔列表，例如\n$[ [\\dots], [\\dots], [\\dots], [\\dots] ]$。",
            "solution": "该问题陈述已经过仔细验证，并被确定为是合理的。它在科学上基于计算流体动力学和数值分析的原理，特别是关于不可压缩纳维-斯托克斯方程的迭代求解。该问题是适定的，提供了一套完整且一致的定义、参数和目标。所有术语都经过了形式化定义，从而能够得出唯一且可验证的解。使用参数模型来描述残差历史是一种有效且常见的技术，用于创建一个受控的、合成的环境来测试和比较数值算法的性能。\n\n任务是实现一组诊断程序，以基于合成的残差历史比较 SIMPLE 和 SIMPLER 算法的收敛行为。该比较通过三个度量指标和一个最终的优越性谓词来形式化。解决方案将对四个指定的测试用例分别实施这些诊断。\n\n问题的核心是算法 $A \\in \\{\\text{SIMPLE}, \\text{SIMPLER}\\}$ 在迭代 $k$ 时的残差范数历史 $r_k^{(A)}$ 的参数模型：\n$$\nr_k^{(A)} \\;=\\; r_0 \\,\\frac{\\left(c_A\\right)^k \\left(1 + a \\cos(\\pi k)\\right)}{1+a}, \\quad k = 0,1,2,\\dots,K\n$$\n这里，$r_0$ 是初始残差，$c_A$ 是渐近收敛因子，而涉及振荡幅度 $a$ 和 $\\cos(\\pi k) = (-1)^k$ 的项模拟了实践中经常观察到的瞬态、非单调行为。分母 $1+a$ 确保了归一化 $r_0^{(A)} = r_0$。对于每种算法和每个测试用例，我们首先生成一个残差范数向量 $\\{r_k^{(A)}\\}_{k=0}^K$。\n\n基于这个历史，我们计算以下诊断指标：\n\n1.  **达到目标的迭代次数 $N_\\tau^{(A)}$**：该指标量化了实际的收敛速度。它定义为残差范数降至目标阈值以下所需的最小迭代次数 $k$，即 $r_k^{(A)} \\le r_0 \\tau$。目标缩减因子给定为 $\\tau = 10^{-6}$。我们搜索满足此条件的最小 $k \\in \\{0, 1, \\dots, K\\}$。如果在最多 $K$ 次迭代内未满足条件，则报告次数为 $K+1$。\n\n2.  **估计的渐近收敛因子 $\\widehat{c}^{(A)}$**：该指标估计算法的潜在线性收敛率，它决定了算法的长期行为。它使用残差历史的最后 $m = \\min\\{M, K\\}$ 次迭代进行计算，其中 $M=20$ 是估计窗口长度。公式为：\n    $$\n    \\widehat{c}^{(A)} \\;=\\; \\exp\\!\\left( \\frac{1}{m} \\sum_{k=K-m}^{K-1} \\left( \\log r_{k+1}^{(A)} - \\log r_k^{(A)} \\right) \\right)\n    $$\n    这是指定窗口内单步缩减因子 $r_{k+1}^{(A)}/r_k^{(A)}$ 的几何平均值。对于给定的残差模型，项 $\\log r_{k+1}^{(A)} - \\log r_k^{(A)}$ 可以展开为 $\\log(c_A) + \\log((1+a(-1)^{k+1})/(1+a(-1)^k))$。当窗口大小 $m$ 为偶数时（此处情况如此，因为 $M=20$ 且所有 $K \\ge 20$），振荡项形成一个求值为 $1$ 的伸缩积，其对数为 $0$。因此，该估计器被设计为在这些特定条件下精确地恢复真实的基本收缩因子，即 $\\widehat{c}^{(A)} = c_A$。\n\n3.  **单调性违例计数 $V^{(A)}$**：该指标计算残差从一次迭代到下一次迭代增加的次数，即对于 $k \\in \\{0, 1, \\dots, K-1\\}$，有 $r_{k+1}^{(A)}  r_k^{(A)}$。这可作为收敛过程非单调性或振荡性质的度量。当振荡幅度 $a$ 相对于收缩因子 $c_A$ 足够大时，预期会出现非零值。\n\n最后，这些诊断被合成为一个单一的布尔值**优越性谓词**：\n$$\n\\text{Dominates} \\;=\\; \\Big( N_\\tau^{(\\text{SIMPLER})}  N_\\tau^{(\\text{SIMPLE})} \\Big) \\;\\wedge\\; \\Big( \\widehat{c}^{(\\text{SIMPLER})}  \\widehat{c}^{(\\text{SIMPLE})} - \\delta \\Big)\n$$\n当且仅当 SIMPLER 算法在达到目标残差所需的迭代次数上更少，并且其渐近收敛因子显著更小时，该谓词为真。裕度 $\\delta = 10^{-2}$ 确保了渐近率的差异是有意义的。\n\n实现将处理四个测试用例中的每一个，方法是生成两个残差历史（一个用于 SIMPLE，一个用于 SIMPLER），为每个历史计算三个诊断指标，评估优越性谓词，并按规定收集结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the diagnostic plan for all test cases and print results.\n    \"\"\"\n    \n    # Global parameters common to all test cases\n    tau = 1e-6\n    M = 20\n    delta = 1e-2\n\n    # Test suite specification\n    test_cases = [\n        # Case 1 (general)\n        {'r0': 1.0, 'K': 200, 'a': 0.0, 'c_simple': 0.85, 'c_simpler': 0.65},\n        # Case 2 (boundary equal rates)\n        {'r0': 1.0, 'K': 200, 'a': 0.0, 'c_simple': 0.70, 'c_simpler': 0.70},\n        # Case 3 (oscillatory transients)\n        {'r0': 1.0, 'K': 200, 'a': 0.15, 'c_simple': 0.80, 'c_simpler': 0.75},\n        # Case 4 (near-stagnation for SIMPLE)\n        {'r0': 1.0, 'K': 500, 'a': 0.02, 'c_simple': 0.99, 'c_simpler': 0.90},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        r0 = case['r0']\n        K = case['K']\n        a = case['a']\n        c_simple = case['c_simple']\n        c_simpler = case['c_simpler']\n        \n        params = {\n            'SIMPLE': c_simple,\n            'SIMPLER': c_simpler,\n        }\n        \n        results_per_algo = {}\n\n        for algo_name, c_A in params.items():\n            # Generate residual history\n            k_range = np.arange(K + 1)\n            # The term cos(pi*k) is equivalent to (-1)^k\n            oscillation_term = 1 + a * (-1)**k_range\n            r_k = r0 * (c_A**k_range * oscillation_term) / (1 + a)\n            \n            # --- Diagnostic 1: Iteration-to-target count N_tau ---\n            target_residual = r0 * tau\n            indices_below_target = np.where(r_k = target_residual)[0]\n            if indices_below_target.size > 0:\n                N_tau = indices_below_target[0]\n            else:\n                N_tau = K + 1\n\n            # --- Diagnostic 2: Estimated asymptotic convergence factor c_hat ---\n            m = min(M, K)\n            if m > 0:\n                # Log of residuals in the estimation window [K-m, K]\n                log_r_window = np.log(r_k[K - m : K + 1])\n                # Differences of consecutive log residuals\n                delta_k = log_r_window[1:] - log_r_window[:-1]\n                c_hat = np.exp(np.mean(delta_k))\n            else: # Edge case for K=0, although problem constraints imply K>=1\n                c_hat = np.nan\n\n            # --- Diagnostic 3: Monotonicity violation count V ---\n            # Count where r_{k+1} > r_k for k in [0, K-1]\n            V = np.sum(r_k[1:] > r_k[:-1])\n\n            results_per_algo[algo_name] = {\n                'N_tau': N_tau,\n                'c_hat': c_hat,\n                'V': V,\n            }\n\n        # --- Dominance Predicate ---\n        N_tau_simple = results_per_algo['SIMPLE']['N_tau']\n        N_tau_simpler = results_per_algo['SIMPLER']['N_tau']\n        c_hat_simple = results_per_algo['SIMPLE']['c_hat']\n        c_hat_simpler = results_per_algo['SIMPLER']['c_hat']\n        \n        dominates = (N_tau_simpler  N_tau_simple) and \\\n                    (c_hat_simpler  c_hat_simple - delta)\n\n        # Assemble final list for the case\n        case_result = [\n            N_tau_simple,\n            N_tau_simpler,\n            c_hat_simple,\n            c_hat_simpler,\n            results_per_algo['SIMPLE']['V'],\n            results_per_algo['SIMPLER']['V'],\n            dominates\n        ]\n        all_results.append(case_result)\n\n    # Format the final output string as specified\n    # The str() of a list automatically includes spaces, e.g., '[1, 2, 3]'\n    # Joining these with a comma produces '...,[...],[...],...'\n    # The final wrapping brackets gives '[[...],[...],...]'\n    final_output_string = f\"[{','.join(map(str, all_results))}]\"\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}