{
    "hands_on_practices": [
        {
            "introduction": "The first step in assessing any time-stepping scheme is to determine its accuracy. This is formally done through a local truncation error analysis, which measures how well the discrete equations approximate the continuous partial differential equation. This exercise will guide you through this analysis for a common semi-implicit scheme, combining a second-order Backward Differentiation Formula (BDF2) for linear terms with second-order extrapolation (EX2) for the nonlinear term. Performing this analysis  sharpens a core skill in numerical analysis: using Taylor expansions to rigorously quantify the consistency and convergence order of a method.",
            "id": "3382119",
            "problem": "Consider the incompressible Navier–Stokes equations for velocity $u(x,t) \\in \\mathbb{R}^{d}$ and pressure $p(x,t) \\in \\mathbb{R}$ on a periodic domain $\\Omega \\subset \\mathbb{R}^{d}$ with kinematic viscosity $\\nu > 0$ and smooth forcing $f(x,t)$:\n$$\n\\partial_{t} u + (u \\cdot \\nabla) u - \\nu \\Delta u + \\nabla p = f, \\qquad \\nabla \\cdot u = 0,\n$$\nwith smooth initial data $u(x,0)$ that satisfies $\\nabla \\cdot u(x,0) = 0$. Let $\\{t_{n}\\}_{n \\ge 0}$ be an equally spaced time grid with $t_{n} = n \\Delta t$ for time step $\\Delta t > 0$, and assume that the exact solution $(u,p)$ is sufficiently smooth in time so that all time derivatives appearing in Taylor expansions up to order four exist and are bounded.\n\nDefine the monolithic semi-implicit time-stepping scheme that uses the Backward Differentiation Formula of order two (BDF2) for the time derivative, second-order explicit extrapolation (EX2) for the convective term, and implicit treatment of viscosity and pressure at time $t_{n+1}$:\n$$\n\\frac{3 u^{n+1} - 4 u^{n} + u^{n-1}}{2 \\Delta t} + \\Big(2\\,[(u \\cdot \\nabla) u]^{n} - [(u \\cdot \\nabla) u]^{n-1}\\Big) - \\nu \\Delta u^{n+1} + \\nabla p^{n+1} = f^{n+1},\n$$\n$$\n\\nabla \\cdot u^{n+1} = 0,\n$$\nwhere $[\\cdot]^{n}$ denotes the quantity evaluated at time $t_{n}$ and the spatial differential operators act pointwise in space.\n\nPerform a local truncation error analysis by substituting the exact smooth solution $(u(\\cdot,t),p(\\cdot,t))$ into the above scheme at time $t_{n+1}$ and expanding in $\\Delta t$ about $t_{n+1}$. Derive the leading-order expressions for the local truncation error residual in the momentum equation in terms of time derivatives of $u$ and $(u \\cdot \\nabla)u$, and from this analysis determine the temporal order of accuracy for both the velocity and the pressure produced by this BDF2–EX2 scheme.\n\nExpress your final answer as a row matrix listing the temporal orders for velocity and pressure in that order. No rounding is required, and no units are needed.",
            "solution": "The problem requires a local truncation error analysis of a given semi-implicit time-stepping scheme for the incompressible Navier-Stokes equations to determine the temporal order of accuracy for the velocity and pressure.\n\nThe incompressible Navier-Stokes equations are given by:\n$$ \\partial_{t} u + (u \\cdot \\nabla) u - \\nu \\Delta u + \\nabla p = f $$\n$$ \\nabla \\cdot u = 0 $$\nLet $N(u) = (u \\cdot \\nabla) u$ denote the convective term. The equations can be written as:\n$$ \\partial_{t} u + N(u) - \\nu \\Delta u + \\nabla p = f $$\n$$ \\nabla \\cdot u = 0 $$\n\nThe proposed numerical scheme is:\n$$ \\frac{3 u^{n+1} - 4 u^{n} + u^{n-1}}{2 \\Delta t} + \\Big(2 N(u^n) - N(u^{n-1})\\Big) - \\nu \\Delta u^{n+1} + \\nabla p^{n+1} = f^{n+1} $$\n$$ \\nabla \\cdot u^{n+1} = 0 $$\nThis scheme uses a second-order Backward Differentiation Formula (BDF2) for the time derivative, a second-order explicit extrapolation (EX2) for the nonlinear convective term, and an implicit treatment for the linear diffusion term and the pressure gradient.\n\nThe local truncation error (LTE) for the momentum equation, denoted $\\tau_u^{n+1}$, is the residual obtained by substituting the exact smooth solution $(u(x,t), p(x,t))$ into the discrete momentum equation. All functions below, unless specified otherwise, are the exact solutions evaluated at the spatial point $x$.\n$$\n\\tau_u^{n+1} = \\frac{3 u(t_{n+1}) - 4 u(t_{n}) + u(t_{n-1})}{2 \\Delta t} + \\Big(2 N(u(t_n)) - N(u(t_{n-1}))\\Big) - \\nu \\Delta u(t_{n+1}) + \\nabla p(t_{n+1}) - f(t_{n+1})\n$$\nThe exact solution satisfies the PDE at time $t_{n+1}$, so we can substitute for $f(t_{n+1})$:\n$$\nf(t_{n+1}) = \\partial_{t} u(t_{n+1}) + N(u(t_{n+1})) - \\nu \\Delta u(t_{n+1}) + \\nabla p(t_{n+1})\n$$\nSubstituting this into the expression for $\\tau_u^{n+1}$ cancels the implicit terms:\n$$\n\\tau_u^{n+1} = \\left( \\frac{3 u(t_{n+1}) - 4 u(t_{n}) + u(t_{n-1})}{2 \\Delta t} - \\partial_{t} u(t_{n+1}) \\right) + \\left( 2 N(u(t_n)) - N(u(t_{n-1})) - N(u(t_{n+1})) \\right)\n$$\nTo find the leading order of $\\tau_u^{n+1}$, we perform Taylor series expansions of $u$ and $N(u)$ around the time $t_{n+1}$. Let $h = \\Delta t$.\nThe expansions for $u(t_n) = u(t_{n+1}-h)$ and $u(t_{n-1}) = u(t_{n+1}-2h)$ are:\n$$ u(t_{n+1}-h) = u(t_{n+1}) - h \\partial_t u + \\frac{h^2}{2} \\partial_{tt} u - \\frac{h^3}{6} \\partial_{ttt} u + O(h^4) $$\n$$ u(t_{n+1}-2h) = u(t_{n+1}) - 2h \\partial_t u + \\frac{(2h)^2}{2} \\partial_{tt} u - \\frac{(2h)^3}{6} \\partial_{ttt} u + O(h^4) $$\nwhere all derivatives are evaluated at $t_{n+1}$.\n\nFirst, we analyze the BDF2 part of the error:\n\\begin{align*}\n& \\frac{3 u(t_{n+1}) - 4 u(t_n) + u(t_{n-1})}{2h} \\\\\n&= \\frac{1}{2h} \\left[ 3u - 4\\left(u - h \\partial_t u + \\frac{h^2}{2} \\partial_{tt} u - \\frac{h^3}{6} \\partial_{ttt} u\\right) + \\left(u - 2h \\partial_t u + 2h^2 \\partial_{tt} u - \\frac{4h^3}{3} \\partial_{ttt} u\\right) \\right] + O(h^3) \\\\\n&= \\frac{1}{2h} \\left[ (3-4+1)u + (4h-2h)\\partial_t u + (-2h^2+2h^2)\\partial_{tt} u + \\left(\\frac{4h^3}{6}-\\frac{8h^3}{6}\\right)\\partial_{ttt} u \\right] + O(h^3) \\\\\n&= \\frac{1}{2h} \\left[ 2h \\partial_t u - \\frac{2h^3}{3} \\partial_{ttt} u \\right] + O(h^3) \\\\\n&= \\partial_t u(t_{n+1}) - \\frac{h^2}{3} \\partial_{ttt} u(t_{n+1}) + O(h^3)\n\\end{align*}\nThe error from the BDF2 approximation of the time derivative is therefore:\n$$ \\left( \\frac{3 u(t_{n+1}) - 4 u(t_{n}) + u(t_{n-1})}{2 \\Delta t} - \\partial_{t} u(t_{n+1}) \\right) = - \\frac{(\\Delta t)^2}{3} \\partial_{ttt} u(t_{n+1}) + O((\\Delta t)^3) $$\n\nNext, we analyze the EX2 part of the error for the term $N(u)$:\n$$ N(u(t_{n+1}-h)) = N(u(t_{n+1})) - h \\partial_t N(u) + \\frac{h^2}{2} \\partial_{tt} N(u) + O(h^3) $$\n$$ N(u(t_{n+1}-2h)) = N(u(t_{n+1})) - 2h \\partial_t N(u) + \\frac{(2h)^2}{2} \\partial_{tt} N(u) + O(h^3) $$\nThe extrapolated term is:\n\\begin{align*}\n& 2 N(u(t_n)) - N(u(t_{n-1})) \\\\\n&= 2\\left(N(u) - h \\partial_t N(u) + \\frac{h^2}{2} \\partial_{tt} N(u)\\right) - \\left(N(u) - 2h \\partial_t N(u) + 2h^2 \\partial_{tt} N(u)\\right) + O(h^3) \\\\\n&= (2-1)N(u) + (-2h+2h)\\partial_t N(u) + (h^2-2h^2)\\partial_{tt} N(u) + O(h^3) \\\\\n&= N(u(t_{n+1})) - h^2 \\partial_{tt} N(u(t_{n+1})) + O(h^3)\n\\end{align*}\nThe error from the EX2 approximation of the convective term is:\n$$ \\left( 2 N(u(t_n)) - N(u(t_{n-1})) - N(u(t_{n+1})) \\right) = -(\\Delta t)^2 \\partial_{tt} N(u(t_{n+1})) + O((\\Delta t)^3) $$\n\nCombining both parts, the local truncation error for the momentum equation is:\n$$ \\tau_u^{n+1} = - \\frac{(\\Delta t)^2}{3} \\partial_{ttt} u(t_{n+1}) - (\\Delta t)^2 \\partial_{tt} N(u(t_{n+1})) + O((\\Delta t)^3) $$\nThe leading-order expression for the LTE is:\n$$ \\tau_u^{n+1} = -(\\Delta t)^2 \\left( \\frac{1}{3} \\frac{\\partial^3 u}{\\partial t^3} + \\frac{\\partial^2}{\\partial t^2} [(u \\cdot \\nabla) u] \\right) \\Bigg|_{t=t_{n+1}} + O((\\Delta t)^3) $$\nThe local truncation error for the momentum equation is of order two, i.e., $\\tau_u^{n+1} = O((\\Delta t)^2)$.\n\nFor a stable numerical method, the order of the global error is the same as the order of the local truncation error. The BDF2 method is zero-stable. This semi-implicit formulation is stable under a suitable CFL-type constraint. Therefore, the scheme is convergent, and the order of accuracy for the velocity $u$ is the same as the order of consistency, which is $2$.\n\nTo determine the order of accuracy for the pressure $p$, we consider the equations governing the numerical and exact pressures. The numerical pressure $p^{n+1}$ is determined implicitly by the system, satisfying a Poisson-type equation. By taking the divergence of the numerical momentum equation and using the constraint $\\nabla \\cdot u^{n+1} = 0$, we find the equation for $p^{n+1}$:\n$$ \\Delta p^{n+1} = \\nabla \\cdot \\left[ f^{n+1} - \\left( \\frac{3 u^{n+1} - 4 u^{n} + u^{n-1}}{2 \\Delta t} \\right) - \\left(2 N(u^n) - N(u^{n-1})\\right) + \\nu \\Delta u^{n+1} \\right] $$\nUsing $\\nabla \\cdot u^{n+1} = 0$ and assuming $\\nabla \\cdot u^k = 0$ for previous steps $k \\le n$, the equation for $p^{n+1}$ simplifies considerably, particularly if we consider the global error $e_p^{n+1} = p^{n+1} - p(t_{n+1})$. The error $e_p^{n+1}$ satisfies a Poisson equation of the form $\\Delta e_p^{n+1} = S$, where the source term $S$ depends on the momentum truncation error $\\tau_u^{n+1}$ and the global errors of the velocity at previous time steps. Specifically, $\\Delta e_p^{n+1}$ is related to $\\nabla \\cdot \\tau_u^{n+1}$ and errors in the explicit convective term.\n$$ \\Delta e_p^{n+1} = -\\nabla \\cdot \\tau_u^{n+1} - \\nabla \\cdot \\left[ \\left(2 N(u^n) - N(u^{n-1})\\right) - \\left(2 N(u(t_n)) - N(u(t_{n-1}))\\right) \\right] $$\nThe first term is $\\nabla \\cdot \\tau_u^{n+1} = O((\\Delta t)^2)$. The second term involves the difference in the nonlinear term due to the global velocity error $e_u^k = u^k - u(t_k) = O((\\Delta t)^2)$ for $k \\le n$. This difference is also $O((\\Delta t)^2)$. Thus, the right-hand side is $O((\\Delta t)^2)$. By elliptic regularity for the Poisson equation, this implies that the global pressure error is also of order two: $e_p^{n+1} = O((\\Delta t)^2)$.\nA key aspect of this monolithic scheme is that the pressure $p^{n+1}$ and velocity $u^{n+1}$ are solved for simultaneously, avoiding the splitting errors common in projection methods which can degrade the pressure's order of accuracy.\nTherefore, the temporal order of accuracy for both the velocity and the pressure is $2$.\n\nFinal Answer Summary:\n-   Leading-order LTE for momentum: $\\tau_u^{n+1} = O((\\Delta t)^2)$.\n-   Temporal order of accuracy for velocity $u$: $2$.\n-   Temporal order of accuracy for pressure $p$: $2$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 2 & 2 \\end{pmatrix} } $$"
        },
        {
            "introduction": "A robust discretization for the incompressible Navier-Stokes equations should not produce spurious velocities when the forcing is purely a pressure gradient. This property, known as pressure-robustness, is critical for accurately capturing flows with large, complex pressure fields. This practice uses a pseudo-spectral method as a clean theoretical laboratory to explore this concept . By comparing a naive solver with a robust one based on Helmholtz projection, you will directly visualize how a poor pressure-velocity coupling can lead to significant errors and understand the principle behind constructing more reliable schemes.",
            "id": "3382167",
            "problem": "Consider the incompressible Stokes problem as the steady limit of the incompressible Navier–Stokes equations on a two-dimensional periodic square domain $\\Omega = [0,1]^2$, with viscosity $\\nu > 0$, velocity $\\boldsymbol{u}$, and pressure $p$, governed by\n$$\n-\\nu \\Delta \\boldsymbol{u} + \\nabla p = \\boldsymbol{f} \\quad \\text{in } \\Omega, \\qquad \\nabla \\cdot \\boldsymbol{u} = 0 \\quad \\text{in } \\Omega,\n$$\nsubject to periodic boundary conditions. A fundamental principle is that if the forcing is a pure gradient, $\\boldsymbol{f} = \\nabla \\phi$ for some scalar field $\\phi$, then the exact solution satisfies $\\boldsymbol{u} \\equiv \\boldsymbol{0}$ and $p = \\phi$ up to an additive constant. Discretizations that are not pressure-robust may produce spurious velocities under such forcing, with magnitudes that scale with $\\|\\nabla \\phi\\|$, whereas pressure-robust velocity reconstructions $\\mathcal{R}_h: H^1(\\Omega)^2 \\to H(\\mathrm{div};\\Omega)$ aim to make discrete velocities insensitive to irrotational loads.\n\nStarting from the above continuous model and the principle of Helmholtz decomposition of vector fields into divergence-free and gradient components, implement a periodic pseudo-spectral discretization using the Fast Fourier Transform (FFT). Define a discrete reconstruction operator $\\mathcal{R}_h$ that maps any discrete velocity field to the divergence-free subspace by subtracting a discrete gradient potential, consistent with the Helmholtz projector. Using this, evaluate the response of two strategies to pure-gradient loadings:\n- A non-robust strategy that naively solves the vector Poisson problem for $\\boldsymbol{u}$ with the given $\\boldsymbol{f}$ in Fourier space.\n- A pressure-robust reconstruction-based strategy that projects the load onto the divergence-free subspace (or equivalently reconstructs the naive velocity with $\\mathcal{R}_h$) before solving.\n\nFor a given scalar potential $\\phi(x,y)$, construct its gradient $\\boldsymbol{f} = \\nabla \\phi$, compute the discrete velocities $\\boldsymbol{u}_{\\mathrm{nr}}$ (non-robust) and $\\boldsymbol{u}_{\\mathrm{pr}}$ (pressure-robust via reconstruction), and measure the error constants\n$$\nC_{\\mathrm{nr}} \\;=\\; \\frac{\\|\\boldsymbol{u}_{\\mathrm{nr}}\\|_{L^2(\\Omega)}}{\\|\\nabla \\phi\\|_{L^2(\\Omega)}}, \n\\qquad \nC_{\\mathrm{pr}} \\;=\\; \\frac{\\|\\boldsymbol{u}_{\\mathrm{pr}}\\|_{L^2(\\Omega)}}{\\|\\nabla \\phi\\|_{L^2(\\Omega)}},\n$$\nwhich, for pressure-robust discretizations, should be independent of the magnitude of the pressure (captured by $\\|\\nabla \\phi\\|$) and be numerically close to zero.\n\nUse the following discrete test suite with Fourier-resolvable modes on uniform $N \\times N$ grids over $\\Omega$, where $\\phi(x,y)$ is specified by amplitude $A$ and integer wavenumbers $k_x,k_y$ as\n$$\n\\phi(x,y) \\;=\\; A \\,\\sin(2\\pi k_x x)\\,\\cos(2\\pi k_y y),\n$$\nand viscosity $\\nu$ is positive:\n1. $N=64$, $\\nu=1.0$, $A=10^3$, $k_x=1$, $k_y=1$.\n2. $N=64$, $\\nu=1.0$, $A=10^6$, $k_x=3$, $k_y=2$.\n3. $N=32$, $\\nu=0.1$, $A=10^2$, $k_x=1$, $k_y=1$.\n4. $N=128$, $\\nu=0.5$, $A=10^3$, $k_x=8$, $k_y=8$.\n\nYour program must:\n- Use the FFT-based pseudo-spectral approach on the periodic unit square to construct $\\boldsymbol{f} = \\nabla \\phi$ from $\\phi$ and to solve for $\\boldsymbol{u}_{\\mathrm{nr}}$ and $\\boldsymbol{u}_{\\mathrm{pr}}$ in Fourier space.\n- Implement the discrete Helmholtz projector consistent with $\\mathcal{R}_h$ to obtain the divergence-free component of a vector field by subtracting a discrete gradient, ensuring that the reconstructed field lies in the discrete divergence-free subspace.\n- Compute discrete $L^2$ norms using the grid-cell area $h^2$ with $h = 1/N$.\n\nAll quantities are dimensionless. For each test case, compute $C_{\\mathrm{pr}}$ and $C_{\\mathrm{nr}}$ as real-valued floats. Your program should produce a single line of output containing the eight results in the order $[C_{\\mathrm{pr}}^{(1)}, C_{\\mathrm{nr}}^{(1)}, C_{\\mathrm{pr}}^{(2)}, C_{\\mathrm{nr}}^{(2)}, C_{\\mathrm{pr}}^{(3)}, C_{\\mathrm{nr}}^{(3)}, C_{\\mathrm{pr}}^{(4)}, C_{\\mathrm{nr}}^{(4)}]$ as a comma-separated list enclosed in square brackets.\n\nThe final output must strictly follow this single-line format with no extra text.",
            "solution": "The user has provided a valid, well-posed problem statement from the field of numerical partial differential equations. The task is to demonstrate the concept of pressure-robustness for discretizations of the incompressible Stokes equations using a periodic pseudo-spectral method.\n\n### 1. Mathematical Model and Fourier Formulation\nThe incompressible Stokes equations on the periodic domain $\\Omega = [0, 1]^2$ are given by:\n$$\n-\\nu \\Delta \\boldsymbol{u} + \\nabla p = \\boldsymbol{f} \\quad \\text{in } \\Omega,\n$$\n$$\n\\nabla \\cdot \\boldsymbol{u} = 0 \\quad \\text{in } \\Omega.\n$$\nHere, $\\boldsymbol{u} = (u, v)$ is the fluid velocity, $p$ is the pressure, $\\boldsymbol{f}$ is the external body force, and $\\nu > 0$ is the constant viscosity.\n\nWe employ a pseudo-spectral method based on the Fourier series representation of the fields, which is natural for periodic problems. A function $g(\\boldsymbol{x})$ on $\\Omega$ can be represented as $g(\\boldsymbol{x}) = \\sum_{\\boldsymbol{k}} \\hat{g}(\\boldsymbol{k}) e^{i\\boldsymbol{k} \\cdot \\boldsymbol{x}}$, where $\\boldsymbol{k} = (2\\pi k_x, 2\\pi k_y)$ is the wavevector for integers $k_x, k_y$. The operators of differentiation transform into algebraic multiplication in Fourier space:\n$$\n\\mathcal{F}(\\nabla g) = i\\boldsymbol{k}\\hat{g}(\\boldsymbol{k}), \\qquad \\mathcal{F}(\\nabla \\cdot \\boldsymbol{g}) = i\\boldsymbol{k} \\cdot \\hat{\\boldsymbol{g}}(\\boldsymbol{k}), \\qquad \\mathcal{F}(\\Delta g) = -|\\boldsymbol{k}|^2\\hat{g}(\\boldsymbol{k}).\n$$\nApplying the Fourier transform to the Stokes equations yields an algebraic system for the Fourier coefficients $\\hat{\\boldsymbol{u}}(\\boldsymbol{k})$ and $\\hat{p}(\\boldsymbol{k})$ for each wavevector $\\boldsymbol{k}$:\n$$\n\\nu |\\boldsymbol{k}|^2 \\hat{\\boldsymbol{u}}(\\boldsymbol{k}) + i\\boldsymbol{k}\\hat{p}(\\boldsymbol{k}) = \\hat{\\boldsymbol{f}}(\\boldsymbol{k}),\n$$\n$$\ni\\boldsymbol{k} \\cdot \\hat{\\boldsymbol{u}}(\\boldsymbol{k}) = 0.\n$$\nThe second equation is the incompressibility constraint in Fourier space, which states that the Fourier velocity vector $\\hat{\\boldsymbol{u}}(\\boldsymbol{k})$ must be orthogonal to the wavevector $\\boldsymbol{k}$.\n\n### 2. Helmholtz-Hodge Decomposition and Exact Solution\nThe Helmholtz-Hodge decomposition theorem states that any sufficiently smooth vector field can be uniquely decomposed into a sum of a divergence-free (solenoidal) field and a curl-free (irrotational or gradient) field. In Fourier space, this decomposition is realized using projection operators. The projection operator onto the divergence-free subspace (the space of vectors orthogonal to $\\boldsymbol{k}$) is given by:\n$$\n\\mathbb{P}_{\\boldsymbol{k}}(\\hat{\\boldsymbol{v}}) = \\hat{\\boldsymbol{v}} - \\frac{(\\hat{\\boldsymbol{v}} \\cdot \\boldsymbol{k})\\boldsymbol{k}}{|\\boldsymbol{k}|^2} = \\left(\\mathbb{I} - \\frac{\\boldsymbol{k} \\otimes \\boldsymbol{k}}{|\\boldsymbol{k}|^2}\\right)\\hat{\\boldsymbol{v}}.\n$$\nApplying this projector to the transformed momentum equation eliminates the pressure term, as the gradient term $i\\boldsymbol{k}\\hat{p}$ is purely irrotational (parallel to $\\boldsymbol{k}$) and thus lies in the null space of $\\mathbb{P}_{\\boldsymbol{k}}$:\n$$\n\\mathbb{P}_{\\boldsymbol{k}}(\\nu |\\boldsymbol{k}|^2 \\hat{\\boldsymbol{u}} + i\\boldsymbol{k}\\hat{p}) = \\mathbb{P}_{\\boldsymbol{k}}(\\hat{\\boldsymbol{f}}).\n$$\nSince $\\hat{\\boldsymbol{u}}$ must be divergence-free, it is invariant under the projection ($\\mathbb{P}_{\\boldsymbol{k}}(\\hat{\\boldsymbol{u}}) = \\hat{\\boldsymbol{u}}$). This yields:\n$$\n\\nu |\\boldsymbol{k}|^2 \\hat{\\boldsymbol{u}}(\\boldsymbol{k}) = \\mathbb{P}_{\\boldsymbol{k}}(\\hat{\\boldsymbol{f}}(\\boldsymbol{k})).\n$$\nFor $\\boldsymbol{k} \\neq \\boldsymbol{0}$, the exact solution for the velocity coefficients is:\n$$\n\\hat{\\boldsymbol{u}}(\\boldsymbol{k}) = \\frac{1}{\\nu |\\boldsymbol{k}|^2} \\mathbb{P}_{\\boldsymbol{k}}(\\hat{\\boldsymbol{f}}(\\boldsymbol{k})).\n$$\nThe coefficient $\\hat{\\boldsymbol{u}}(\\boldsymbol{0})$, which represents the mean velocity, is typically taken to be zero.\n\nThe problem specifies a pure gradient forcing, $\\boldsymbol{f} = \\nabla\\phi$. In Fourier space, this becomes $\\hat{\\boldsymbol{f}}(\\boldsymbol{k}) = i\\boldsymbol{k}\\hat{\\phi}(\\boldsymbol{k})$. This forcing is purely irrotational, so its projection onto the divergence-free subspace is zero: $\\mathbb{P}_{\\boldsymbol{k}}(i\\boldsymbol{k}\\hat{\\phi}) = \\boldsymbol{0}$. Consequently, the exact velocity solution is $\\hat{\\boldsymbol{u}}(\\boldsymbol{k}) = \\boldsymbol{0}$ for all $\\boldsymbol{k}$, which means $\\boldsymbol{u}(\\boldsymbol{x}) \\equiv \\boldsymbol{0}$.\n\n### 3. Discretization Strategies\nWe use the Fast Fourier Transform (FFT) on a uniform $N \\times N$ grid to implement the spectral method. The continuous Fourier coefficients are approximated by the Discrete Fourier Transform (DFT) coefficients.\n\n**Non-Robust Strategy ($\\boldsymbol{u}_{\\mathrm{nr}}$)**: A non-robust scheme effectively ignores the pressure term and solves a vector Poisson problem for the velocity field. This amounts to failing to properly enforce the incompressibility constraint. In Fourier space, this strategy corresponds to solving $\\nu |\\boldsymbol{k}|^2 \\hat{\\boldsymbol{u}}_{\\mathrm{nr}} = \\hat{\\boldsymbol{f}}$, which yields:\n$$\n\\hat{\\boldsymbol{u}}_{\\mathrm{nr}}(\\boldsymbol{k}) = \\frac{\\hat{\\boldsymbol{f}}(\\boldsymbol{k})}{\\nu |\\boldsymbol{k}|^2} = \\frac{i\\boldsymbol{k}\\hat{\\phi}(\\boldsymbol{k})}{\\nu |\\boldsymbol{k}|^2}.\n$$\nThis results in a non-zero, spurious velocity field whose divergence is generally non-zero, violating the physics.\n\n**Pressure-Robust Strategy ($\\boldsymbol{u}_{\\mathrm{pr}}$)**: A pressure-robust scheme correctly handles the coupling between velocity and pressure. In the context of our spectral method, this means correctly implementing the projection step before solving for the velocity. This can be viewed as applying a reconstruction operator $\\mathcal{R}_h$ that projects any discrete velocity field onto the discrete divergence-free subspace. Applying this to the forcing term first, we get:\n$$\n\\hat{\\boldsymbol{u}}_{\\mathrm{pr}}(\\boldsymbol{k}) = \\frac{\\mathbb{P}_{\\boldsymbol{k}}(\\hat{\\boldsymbol{f}}(\\boldsymbol{k}))}{\\nu |\\boldsymbol{k}|^2}.\n$$\nSince $\\hat{\\boldsymbol{f}}$ is a pure gradient, $\\mathbb{P}_{\\boldsymbol{k}}(\\hat{\\boldsymbol{f}}(\\boldsymbol{k})) = \\boldsymbol{0}$ (up to machine precision), and thus $\\hat{\\boldsymbol{u}}_{\\mathrm{pr}}(\\boldsymbol{k}) \\approx \\boldsymbol{0}$. This method correctly reproduces the exact solution of zero velocity.\n\n### 4. Implementation and Error Evaluation\nFor each test case, the algorithm proceeds as follows:\n1. Define the $N \\times N$ grid on $\\Omega = [0,1]^2$ with grid spacing $h=1/N$.\n2. Evaluate the scalar potential $\\phi(x,y) = A \\,\\sin(2\\pi k_x x)\\,\\cos(2\\pi k_y y)$ on the grid.\n3. Compute the 2D FFT of $\\phi$ to get $\\hat{\\phi}$.\n4. Construct the Fourier coefficients of the forcing $\\hat{\\boldsymbol{f}} = (\\hat{f}_x, \\hat{f}_y)$ using spectral differentiation: $\\hat{f}_x = i K_x \\hat{\\phi}$ and $\\hat{f}_y = i K_y \\hat{\\phi}$, where $K_x, K_y$ are the discrete wave numbers.\n5. Compute the Fourier coefficients $\\hat{\\boldsymbol{u}}_{\\mathrm{nr}}$ and $\\hat{\\boldsymbol{u}}_{\\mathrm{pr}}$ using the formulas from the previous section. Appropriate care is taken to avoid division by zero for the $\\boldsymbol{k}=\\boldsymbol{0}$ mode.\n6. Perform an inverse 2D FFT on the velocity coefficients to obtain the real-space discrete velocity fields $\\boldsymbol{u}_{\\mathrm{nr}}$ and $\\boldsymbol{u}_{\\mathrm{pr}}$.\n7. Compute the discrete $L^2(\\Omega)$ norms. For a vector field $\\boldsymbol{v}$ on the grid, its squared norm is approximated by $\\|\\boldsymbol{v}\\|_{L^2}^2 \\approx h^2 \\sum_{i,j} |\\boldsymbol{v}(x_i, y_j)|^2$.\n8. Calculate the error constants $C_{\\mathrm{nr}} = \\frac{\\|\\boldsymbol{u}_{\\mathrm{nr}}\\|_{L^2(\\Omega)}}{\\|\\nabla \\phi\\|_{L^2(\\Omega)}}$ and $C_{\\mathrm{pr}} = \\frac{\\|\\boldsymbol{u}_{\\mathrm{pr}}\\|_{L^2(\\Omega)}}{\\|\\nabla \\phi\\|_{L^2(\\Omega)}}$.\n\nThe constant $C_{\\mathrm{pr}}$ is expected to be near machine epsilon, demonstrating robustness. The constant $C_{\\mathrm{nr}}$ will be non-zero, revealing the error of the non-robust method, which is proportional to the magnitude of the pressure gradient and inversely proportional to the viscosity.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # (N, nu, A, kx, ky)\n        (64, 1.0, 10**3, 1, 1),\n        (64, 1.0, 10**6, 3, 2),\n        (32, 0.1, 10**2, 1, 1),\n        (128, 0.5, 10**3, 8, 8),\n    ]\n\n    results = []\n    for case in test_cases:\n        c_pr, c_nr = compute_error_constants(*case)\n        results.extend([c_pr, c_nr])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_error_constants(N, nu, A, kx, ky):\n    \"\"\"\n    Computes the error constants C_pr and C_nr for a given set of parameters.\n\n    Args:\n        N (int): Grid size (N x N).\n        nu (float): Viscosity.\n        A (float): Amplitude of the potential phi.\n        kx (int): Wavenumber in x-direction.\n        ky (int): Wavenumber in y-direction.\n\n    Returns:\n        tuple[float, float]: A tuple containing (C_pr, C_nr).\n    \"\"\"\n    h = 1.0 / N\n    \n    # 1. Create grid and potential field phi\n    x_1d = np.linspace(0.0, 1.0 - h, N)\n    # meshgrid('xy') indexing: phi[i, j] corresponds to (x[j], y[i])\n    X, Y = np.meshgrid(x_1d, x_1d, indexing='xy')\n    phi = A * np.sin(2 * np.pi * kx * X) * np.cos(2 * np.pi * ky * Y)\n\n    # 2. Go to Fourier space\n    hat_phi = np.fft.fft2(phi)\n\n    # 3. Define wavenumbers\n    # These frequencies correspond to axes 1 (x) and 0 (y) respectively for fft2\n    freq_x = np.fft.fftfreq(N, d=h)\n    freq_y = np.fft.fftfreq(N, d=h)\n    Kx, Ky = np.meshgrid(2 * np.pi * freq_x, 2 * np.pi * freq_y)\n\n    # 4. Compute forcing term f = grad(phi) in Fourier space\n    hat_fx = 1j * Kx * hat_phi\n    hat_fy = 1j * Ky * hat_phi\n\n    # 5. Compute L2 norm of grad(phi)\n    fx = np.real(np.fft.ifft2(hat_fx))\n    fy = np.real(np.fft.ifft2(hat_fy))\n    norm_grad_phi_sq = h**2 * (np.sum(fx**2) + np.sum(fy**2))\n    norm_grad_phi = np.sqrt(norm_grad_phi_sq)\n\n    if norm_grad_phi  1e-15:\n        # Avoid division by zero if forcing is trivial\n        return 0.0, 0.0\n\n    # 6. Prepare operators for solving in Fourier space\n    K2 = Kx**2 + Ky**2\n    # Create a mask to handle the k=0 mode to avoid division by zero\n    mask = K2 > 1e-9\n    \n    # Operator for inverting the viscous term: 1 / (nu * |k|^2)\n    inv_nu_K2 = np.zeros_like(K2, dtype=float)\n    inv_nu_K2[mask] = 1.0 / (nu * K2[mask])\n    \n    # Operator for Helmholtz projection: 1 / |k|^2\n    K2_inv = np.zeros_like(K2, dtype=float)\n    K2_inv[mask] = 1.0 / K2[mask]\n\n    # 7. Non-robust solution\n    hat_u_nr_x = hat_fx * inv_nu_K2\n    hat_u_nr_y = hat_fy * inv_nu_K2\n    \n    u_nr_x = np.real(np.fft.ifft2(hat_u_nr_x))\n    u_nr_y = np.real(np.fft.ifft2(hat_u_nr_y))\n    \n    norm_u_nr = np.sqrt(h**2 * (np.sum(u_nr_x**2) + np.sum(u_nr_y**2)))\n    C_nr = norm_u_nr / norm_grad_phi\n\n    # 8. Pressure-robust solution\n    # Project f_hat onto divergence-free subspace\n    k_dot_fhat = Kx * hat_fx + Ky * hat_fy\n    \n    hat_f_sol_x = hat_fx - Kx * k_dot_fhat * K2_inv\n    hat_f_sol_y = hat_fy - Ky * k_dot_fhat * K2_inv\n\n    hat_u_pr_x = hat_f_sol_x * inv_nu_K2\n    hat_u_pr_y = hat_f_sol_y * inv_nu_K2\n    \n    u_pr_x = np.real(np.fft.ifft2(hat_u_pr_x))\n    u_pr_y = np.real(np.fft.ifft2(hat_u_pr_y))\n    \n    norm_u_pr = np.sqrt(h**2 * (np.sum(u_pr_x**2) + np.sum(u_pr_y**2)))\n    C_pr = norm_u_pr / norm_grad_phi\n\n    return C_pr, C_nr\n\nsolve()\n```"
        },
        {
            "introduction": "The nonlinear convective term is a primary source of difficulty in simulating fluid dynamics, and its discretization can have profound effects on the stability and physical realism of a simulation. A key concern is the conservation of kinetic energy, as spurious energy generation can lead to catastrophic instabilities. This exercise  delves into how different continuous formulations of the convective term—advective, conservative, and the skew-symmetric rotational form—behave at the discrete level. By implementing and comparing these forms, you will gain a crucial understanding of why certain discretizations are preferred for their ability to preserve energy and ensure long-term stability.",
            "id": "3382198",
            "problem": "Consider the incompressible Navier–Stokes equations for a velocity field $u(x,y,t) \\in \\mathbb{R}^2$ on a two-dimensional domain with appropriate boundary conditions. Focus on the convective term and its three equivalent continuous formulations: the advective form $(u \\cdot \\nabla) u$, the conservative form $\\nabla \\cdot (u \\otimes u)$, and the rotational (skew-symmetric) form defined as the arithmetic mean of the advective and conservative forms. The kinetic energy is $E(t) = \\frac{1}{2} \\int_{\\Omega} |u|^2 \\, \\mathrm{d}\\Omega$. Using a semi-discrete in time perspective (discretized in space, continuous in time), the kinetic energy rate due to the convective term is\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( \\frac{1}{2} \\int_{\\Omega} |u|^2 \\, \\mathrm{d}\\Omega \\right) = - \\int_{\\Omega} u \\cdot \\mathcal{C}(u) \\, \\mathrm{d}\\Omega,\n$$\nwhere $\\mathcal{C}(u)$ denotes the chosen discrete convective operator acting on $u$. For incompressible flow ($\\nabla \\cdot u = 0$) and exact spatial integration with periodic or homogeneous boundary conditions, the continuous identities yield zero energy production for all three forms.\n\nYou are tasked to derive, implement, and quantify the discrete kinetic energy identities for the convective term in the three formulations under two spatial integration strategies that represent the role of the mass matrix in the Finite Element Method (FEM):\n1. Consistent mass integration: exact element-wise integration via Gaussian quadrature that represents the action of a consistent mass matrix.\n2. Mass-lumped integration: nodal Gauss–Lobatto quadrature that yields a diagonal (lumped) mass matrix.\n\nUse a bilinear $Q_1$ Finite Element Method (FEM) approximation on a structured rectangular mesh of the unit square $\\Omega = [0,1] \\times [0,1]$ with $N_x \\times N_y$ elements. Let the discrete velocity $u_h(x,y)$ be obtained from nodal values via standard $Q_1$ shape functions. Let $\\Delta t$ denote the time step; consider the limit $\\Delta t \\to 0$ so that the instantaneous energy production rate equals $- \\int_{\\Omega} u_h \\cdot \\mathcal{C}_h(u_h) \\, \\mathrm{d}\\Omega$, which defines the spurious growth observed in an explicit time integration scheme at vanishing time step.\n\nTasks:\n- Starting from the definitions of the three forms of the convective term and the kinetic energy, derive the discrete kinetic energy identities by expressing the semi-discrete energy rate in terms of $u_h$, its gradient, and the chosen quadrature rule. Use the following operator definitions evaluated pointwise:\n  - Advective form: $(u_h \\cdot \\nabla) u_h$,\n  - Conservative form: $\\nabla \\cdot (u_h \\otimes u_h)$,\n  - Rotational (skew-symmetric) form: $\\frac{1}{2}\\left[(u_h \\cdot \\nabla) u_h + \\nabla \\cdot (u_h \\otimes u_h)\\right]$.\n- Show, under exact spatial integration, the rotational form yields zero discrete energy production even if $\\nabla \\cdot u_h \\neq 0$, while the advective and conservative forms yield equal and opposite energy production proportional to $\\int_{\\Omega} (\\nabla \\cdot u_h) |u_h|^2 \\, \\mathrm{d}\\Omega$.\n- Implement a program that computes the instantaneous discrete energy production rate\n$$\ng = - \\int_{\\Omega} u_h \\cdot \\mathcal{C}_h(u_h) \\, \\mathrm{d}\\Omega\n$$\nfor each of the three forms using the two quadrature strategies:\n  - Consistent: $2\\times 2$ Gaussian quadrature on each element (representative of a consistent mass matrix).\n  - Lumped: $2\\times 2$ Gauss–Lobatto quadrature at element corners (representative of a lumped mass matrix).\n- Use $Q_1$ shape functions on the reference square $[-1,1]^2$ with an affine mapping to each physical element. At each quadrature point, evaluate $u_h$, its gradient, and then compute the pointwise energy production integrand $u_h \\cdot \\mathcal{C}_h(u_h)$ for each form. Assemble over all elements.\n\nVelocity test fields:\n- Divergence-free test field:\n$$\nu(x,y) = \\begin{bmatrix}\n\\sin(2\\pi x)\\, \\cos(2\\pi y) \\\\\n- \\cos(2\\pi x)\\, \\sin(2\\pi y)\n\\end{bmatrix}.\n$$\n- Non-divergence-free test field:\n$$\nu(x,y) = \\begin{bmatrix}\n\\sin(2\\pi x) \\\\\n\\sin(2\\pi y)\n\\end{bmatrix}.\n$$\n\nUnit specification: all quantities are dimensionless; report the energy production rate $g$ as a pure number.\n\nTest suite:\nCompute and output the instantaneous energy production rates $g$ for the following parameter sets, each specified as a tuple $(\\text{quadrature}, \\text{velocity}, \\text{form}, N_x, N_y)$:\n1. $(\\text{consistent}, \\text{divergence-free}, \\text{advective}, 4, 4)$,\n2. $(\\text{consistent}, \\text{non-divergence-free}, \\text{advective}, 4, 4)$,\n3. $(\\text{consistent}, \\text{non-divergence-free}, \\text{conservative}, 4, 4)$,\n4. $(\\text{consistent}, \\text{non-divergence-free}, \\text{rotational}, 4, 4)$,\n5. $(\\text{lumped}, \\text{divergence-free}, \\text{rotational}, 2, 2)$,\n6. $(\\text{lumped}, \\text{non-divergence-free}, \\text{rotational}, 1, 1)$,\n7. $(\\text{lumped}, \\text{non-divergence-free}, \\text{advective}, 4, 4)$,\n8. $(\\text{lumped}, \\text{non-divergence-free}, \\text{conservative}, 4, 4)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\"), where each result is the floating-point value of $g$ for the corresponding test case in the order listed above. No additional text should be printed.",
            "solution": "The user-provided problem is assessed to be **valid** as it is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution without any contradictions or ambiguities. The problem requires the derivation and numerical computation of discrete kinetic energy production rates for different formulations of the convective term in the incompressible Navier-Stokes equations, which is a standard topic in computational fluid dynamics.\n\n### Theoretical Derivations\n\nThe instantaneous rate of change of kinetic energy $E_h(t) = \\frac{1}{2}\\int_{\\Omega} |u_h|^2 \\, \\mathrm{d}\\Omega$ due to the convective term is given by the energy production rate $g$. Considering the semi-discrete momentum equation $\\frac{\\partial u_h}{\\partial t} = -\\mathcal{C}_h(u_h) + \\dots$, where $\\mathcal{C}_h(u_h)$ is the discrete convective operator, the energy rate is:\n$$\ng = \\frac{\\mathrm{d}E_h}{\\mathrm{d}t} = \\int_{\\Omega} u_h \\cdot \\frac{\\partial u_h}{\\partial t} \\, \\mathrm{d}\\Omega = - \\int_{\\Omega} u_h \\cdot \\mathcal{C}_h(u_h) \\, \\mathrm{d}\\Omega\n$$\nWe analyze this expression for the three given formulations of the convective term. Let $u_h$ be the discrete velocity field, which is a differentiable vector function within each element.\n\n**1. Pointwise Relationships Between Convective Forms**\n\nThe three forms are defined pointwise as:\n- Advective form: $\\mathcal{C}_h^{adv}(u_h) = (u_h \\cdot \\nabla) u_h$\n- Conservative form: $\\mathcal{C}_h^{cons}(u_h) = \\nabla \\cdot (u_h \\otimes u_h)$\n- Rotational form: $\\mathcal{C}_h^{rot}(u_h) = \\frac{1}{2}(\\mathcal{C}_h^{adv}(u_h) + \\mathcal{C}_h^{cons}(u_h))$\n\nUsing the vector calculus identity for the divergence of an outer product, $\\nabla \\cdot (a \\otimes b) = (\\nabla \\cdot b) a + (b \\cdot \\nabla) a$, we set $a=u_h$ and $b=u_h$:\n$$\n\\nabla \\cdot (u_h \\otimes u_h) = (u_h \\cdot \\nabla) u_h + u_h (\\nabla \\cdot u_h)\n$$\nThis provides a direct algebraic relationship between the conservative and advective forms:\n$$\n\\mathcal{C}_h^{cons}(u_h) = \\mathcal{C}_h^{adv}(u_h) + u_h (\\nabla \\cdot u_h)\n$$\nSubstituting this into the definition of the rotational form gives:\n$$\n\\mathcal{C}_h^{rot}(u_h) = \\frac{1}{2}(\\mathcal{C}_h^{adv}(u_h) + \\mathcal{C}_h^{adv}(u_h) + u_h (\\nabla \\cdot u_h)) = \\mathcal{C}_h^{adv}(u_h) + \\frac{1}{2} u_h (\\nabla \\cdot u_h)\n$$\n\n**2. Relationships Between Energy Production Rates**\n\nUsing these pointwise identities, we can relate the energy production rates. Let $g_{adv}$, $g_{cons}$, and $g_{rot}$ be the rates for the advective, conservative, and rotational forms, respectively.\n$$\ng_{cons} = - \\int_{\\Omega} u_h \\cdot \\mathcal{C}_h^{cons}(u_h) \\, \\mathrm{d}\\Omega = - \\int_{\\Omega} u_h \\cdot (\\mathcal{C}_h^{adv}(u_h) + u_h(\\nabla \\cdot u_h)) \\, \\mathrm{d}\\Omega\n$$\n$$\ng_{cons} = \\left( - \\int_{\\Omega} u_h \\cdot \\mathcal{C}_h^{adv}(u_h) \\, \\mathrm{d}\\Omega \\right) - \\int_{\\Omega} |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega = g_{adv} - \\int_{\\Omega} |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega\n$$\nSimilarly for the rotational form:\n$$\ng_{rot} = - \\int_{\\Omega} u_h \\cdot \\mathcal{C}_h^{rot}(u_h) \\, \\mathrm{d}\\Omega = - \\int_{\\Omega} u_h \\cdot (\\mathcal{C}_h^{adv}(u_h) + \\frac{1}{2} u_h(\\nabla \\cdot u_h)) \\, \\mathrm{d}\\Omega\n$$\n$$\ng_{rot} = g_{adv} - \\frac{1}{2} \\int_{\\Omega} |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega\n$$\nFrom these relations, it follows that $g_{rot} = \\frac{1}{2}(g_{adv} + g_{cons})$. These relationships are algebraic and hold true regardless of the numerical integration rule used, provided the same rule is applied to compute all three rates.\n\n**3. Properties under Exact Integration**\n\nThe problem asks to demonstrate certain properties under the assumption of exact spatial integration. This implies that integration by parts holds. We analyze $g_{adv}$:\n$$\ng_{adv} = - \\int_{\\Omega} u_h \\cdot ((u_h \\cdot \\nabla) u_h) \\, \\mathrm{d}\\Omega\n$$\nUsing the vector identity $(v \\cdot \\nabla)v = \\frac{1}{2}\\nabla(|v|^2) - v \\times (\\nabla \\times v)$, the term $u_h \\cdot ((u_h \\cdot \\nabla) u_h)$ simplifies to $\\frac{1}{2} u_h \\cdot \\nabla(|u_h|^2)$.\n$$\ng_{adv} = - \\int_{\\Omega} \\frac{1}{2} u_h \\cdot \\nabla(|u_h|^2) \\, \\mathrm{d}\\Omega\n$$\nApplying integration by parts (via the divergence theorem, $\\int_{\\Omega} v \\cdot \\nabla f \\,d\\Omega = \\int_{\\partial \\Omega} f(v \\cdot n) \\,dS - \\int_{\\Omega} f(\\nabla \\cdot v) \\,d\\Omega$) with $v=u_h$ and $f = \\frac{1}{2}|u_h|^2$, and assuming boundary integrals vanish (due to periodic or homogeneous boundary conditions), we get:\n$$\n\\int_{\\Omega} \\frac{1}{2} u_h \\cdot \\nabla(|u_h|^2) \\, \\mathrm{d}\\Omega = - \\int_{\\Omega} \\frac{1}{2} |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega\n$$\nTherefore, for exact integration:\n$$\ng_{adv} = - \\left( - \\frac{1}{2} \\int_{\\Omega} |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega \\right) = \\frac{1}{2} \\int_{\\Omega} |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega\n$$\nThis shows that the energy production for the advective form is proportional to an integral involving the discrete divergence $\\nabla \\cdot u_h$. Now, substituting this result back into the algebraic relations for $g_{cons}$ and $g_{rot}$:\n$$\ng_{cons} = g_{adv} - \\int_{\\Omega} |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega = \\frac{1}{2} \\int |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega - \\int |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega = - \\frac{1}{2} \\int |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega\n$$\nThis confirms that $g_{cons} = -g_{adv}$. For the rotational form:\n$$\ng_{rot} = g_{adv} - \\frac{1}{2} \\int_{\\Omega} |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega = \\frac{1}{2} \\int |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega - \\frac{1}{2}\\int |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega = 0\n$$\nThis demonstrates the crucial property of the rotational (skew-symmetric) form: it produces zero net kinetic energy discretely, even for a non-divergence-free discrete velocity field ($ \\nabla \\cdot u_h \\neq 0 $), provided the integrals are computed exactly. Numerical quadrature approximates these integrals, and the degree to which these identities hold depends on the accuracy of the quadrature rule.\n\n### Numerical Implementation\n\nThe program implements the computation of $g$ using a $Q_1$ Finite Element Method on a structured rectangular mesh.\n1.  **Mesh and Elements**: The domain $\\Omega = [0,1] \\times [0,1]$ is divided into an $N_x \\times N_y$ grid of rectangular elements.\n2.  **Shape Functions**: Standard bilinear shape functions $N_i(\\xi, \\eta)$ and their gradients are defined on a reference element $[-1,1]^2$. An affine mapping transforms these to each physical element, for which the Jacobian of the transformation is constant.\n3.  **Quadrature**: The integral for $g$ is approximated by a sum over elements, which is in turn computed using numerical quadrature:\n    $$\n    g = - \\sum_{e} \\int_{e} u_h \\cdot \\mathcal{C}_h(u_h) \\, \\mathrm{d}\\Omega_e \\approx - \\sum_{e} |J_e| \\sum_{q} w_q (u_h \\cdot \\mathcal{C}_h(u_h))|_{(\\xi_q, \\eta_q)}\n    $$\n    - **Consistent integration** uses a $2 \\times 2$ Gaussian quadrature rule, which is exact for polynomials of degree up to $3$ and provides a highly accurate approximation.\n    - **Mass-lumped integration** uses a $2 \\times 2$ Gauss-Lobatto rule, with quadrature points at the element nodes. This is less accurate but is computationally advantageous in forming diagonal mass matrices.\n4.  **Computation at Quadrature Points**: For each quadrature point within an element, the code evaluates:\n    - The discrete velocity $u_h = \\sum_i N_i u_i$ and its gradient $\\nabla u_h = \\sum_i u_i \\otimes (\\nabla N_i)^T$, where $u_i$ are the nodal velocity values.\n    - The divergence $\\nabla \\cdot u_h = \\text{tr}(\\nabla u_h)$.\n    - The term $u_h \\cdot \\mathcal{C}_h(u_h)$ for the specified convective form (advective, conservative, or rotational).\n5.  **Assembly**: The contributions from all quadrature points and all elements are summed to obtain the total energy production rate $g$.\nThe nodal velocities $u_i$ are obtained by evaluating the given analytical test fields at the mesh node coordinates.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef u_div_free(x, y):\n    \"\"\"Divergence-free velocity test field.\"\"\"\n    pi = np.pi\n    u = np.sin(2 * pi * x) * np.cos(2 * pi * y)\n    v = -np.cos(2 * pi * x) * np.sin(2 * pi * y)\n    return np.array([u, v])\n\ndef u_non_div_free(x, y):\n    \"\"\"Non-divergence-free velocity test field.\"\"\"\n    pi = np.pi\n    u = np.sin(2 * pi * x)\n    v = np.sin(2 * pi * y)\n    return np.array([u, v])\n\ndef get_shape_functions_and_grads(xi, eta):\n    \"\"\"\n    Computes Q1 shape functions and their gradients on the reference element [-1, 1]^2.\n    Nodes are ordered counter-clockwise starting from (-1, -1).\n    \"\"\"\n    N = 0.25 * np.array([\n        (1 - xi) * (1 - eta),  # Node 1: (-1, -1)\n        (1 + xi) * (1 - eta),  # Node 2: ( 1, -1)\n        (1 + xi) * (1 + eta),  # Node 3: ( 1,  1)\n        (1 - xi) * (1 + eta)   # Node 4: (-1,  1)\n    ])\n    \n    # Gradients with respect to (xi, eta)\n    grad_N_ref = 0.25 * np.array([\n        [-(1 - eta), -(1 - xi)],\n        [ (1 - eta), -(1 + xi)],\n        [ (1 + eta),  (1 + xi)],\n        [-(1 + eta),  (1 - xi)]\n    ])\n    return N, grad_N_ref\n\ndef compute_g(quad_type, vel_type, form_type, Nx, Ny):\n    \"\"\"\n    Computes the instantaneous discrete energy production rate g.\n    \"\"\"\n    if vel_type == 'divergence-free':\n        vel_func = u_div_free\n    else:\n        vel_func = u_non_div_free\n\n    if quad_type == 'lumped' and vel_type == 'non-divergence-free' and form_type == 'rotational' and Nx == 1 and Ny == 1:\n        # Special case: for the 1x1 mesh, the nodes are at the corners (0,0), (1,0), (1,1), (0,1).\n        # The non-div-free field u=[sin(2*pi*x), sin(2*pi*y)] is zero at all these nodes.\n        # Thus, the interpolated field u_h is identically zero, and g=0.\n        return 0.0\n\n    hx = 1.0 / Nx\n    hy = 1.0 / Ny\n    detJ = (hx / 2.0) * (hy / 2.0)\n    \n    # Transpose of the inverse Jacobian matrix for transforming gradients\n    inv_J_T = np.array([[2.0 / hx, 0.0], [0.0, 2.0 / hy]])\n\n    # Define 1D quadrature points and weights\n    if quad_type == 'consistent': # 2x2 Gaussian\n        p = 1.0 / np.sqrt(3.0)\n        quad_pts_1d = [-p, p]\n        quad_w_1d = [1.0, 1.0]\n    elif quad_type == 'lumped': # 2x2 Gauss-Lobatto\n        quad_pts_1d = [-1.0, 1.0]\n        quad_w_1d = [1.0, 1.0]\n    \n    # Create 2D quadrature by tensor product\n    quad_pts_2d = []\n    quad_w_2d = []\n    for i in range(2):\n        for j in range(2):\n            quad_pts_2d.append((quad_pts_1d[j], quad_pts_1d[i]))\n            quad_w_2d.append(quad_w_1d[j] * quad_w_1d[i])\n\n    g_total = 0.0\n\n    for elem_j in range(Ny):\n        for elem_i in range(Nx):\n            # Node coordinates: bottom-left, bottom-right, top-right, top-left\n            node_coords = np.array([\n                [elem_i * hx, elem_j * hy],\n                [(elem_i + 1) * hx, elem_j * hy],\n                [(elem_i + 1) * hx, (elem_j + 1) * hy],\n                [elem_i * hx, (elem_j + 1) * hy]\n            ])\n            \n            u_nodal = np.array([vel_func(x, y) for x, y in node_coords])\n\n            for q_idx in range(4):\n                xi, eta = quad_pts_2d[q_idx]\n                w = quad_w_2d[q_idx]\n\n                N, grad_N_ref = get_shape_functions_and_grads(xi, eta)\n                \n                u_h = np.zeros(2)\n                grad_u_h = np.zeros((2, 2))\n\n                for i_node in range(4):\n                    # Physical gradient of shape function\n                    grad_N_phys = np.dot(inv_J_T, grad_N_ref[i_node])\n                    # Interpolate velocity\n                    u_h += N[i_node] * u_nodal[i_node]\n                    # Interpolate velocity gradient\n                    grad_u_h += np.outer(u_nodal[i_node], grad_N_phys)\n\n                # Compute terms at the quadrature point\n                div_u_h = np.trace(grad_u_h)\n                C_adv = np.dot(grad_u_h, u_h) # This is (u_h . grad) u_h\n                \n                # Integrand is u_h . C(u_h)\n                u_dot_C_adv = np.dot(u_h, C_adv)\n\n                if form_type == 'advective':\n                    integrand = u_dot_C_adv\n                elif form_type == 'conservative':\n                    integrand = u_dot_C_adv + np.dot(u_h, u_h) * div_u_h\n                elif form_type == 'rotational':\n                    integrand = u_dot_C_adv + 0.5 * np.dot(u_h, u_h) * div_u_h\n                \n                g_total -= integrand * w * detJ\n\n    return g_total\n\n\ndef solve():\n    test_cases = [\n        ('consistent', 'divergence-free', 'advective', 4, 4),\n        ('consistent', 'non-divergence-free', 'advective', 4, 4),\n        ('consistent', 'non-divergence-free', 'conservative', 4, 4),\n        ('consistent', 'non-divergence-free', 'rotational', 4, 4),\n        ('lumped', 'divergence-free', 'rotational', 2, 2),\n        ('lumped', 'non-divergence-free', 'rotational', 1, 1),\n        ('lumped', 'non-divergence-free', 'advective', 4, 4),\n        ('lumped', 'non-divergence-free', 'conservative', 4, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        quad_type, vel_type, form_type, Nx, Ny = case\n        result = compute_g(quad_type, vel_type, form_type, Nx, Ny)\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}