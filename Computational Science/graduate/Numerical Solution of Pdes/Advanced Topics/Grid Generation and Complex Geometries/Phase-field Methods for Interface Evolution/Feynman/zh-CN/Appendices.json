{
    "hands_on_practices": [
        {
            "introduction": "要通过计算来研究相场模型，第一步是构建一个可用的求解器。本练习将指导您使用高效的傅里叶谱方法，为 Allen-Cahn 和 Cahn-Hilliard 方程实现求解器。您将不仅仅通过运行代码来验证您的实现，更重要的是通过检验模型的能量耗散和质量守恒等基本物理特性，来确保您的数值模型在物理上是自洽的。",
            "id": "3430539",
            "problem": "实现并验证基于 Allen–Cahn 和 Cahn–Hilliard 方程的相场界面演化数值求解器，该求解器在二维方形域上使用周期性边界条件。实现必须是一个完整、可运行的程序，使用谱精确的空间离散化和与梯度流结构一致的一阶、稳定化的半隐式时间离散化。所需的检查重点关注一致性属性：梯度流的自由能衰减、Cahn–Hilliard 方程的精确质量守恒，以及时间步进格式的时间阶估计。\n\n基本理论如下。Allen–Cahn 方程是 Ginzburg–Landau 能量的 $L^{2}$ 梯度流，而 Cahn–Hilliard 方程是同一能量的 $H^{-1}$ 梯度流。设自由能泛函为\n$$\n\\mathcal{E}(u) = \\int_{\\Omega} \\left( \\frac{\\varepsilon^{2}}{2} \\lvert \\nabla u \\rvert^{2} + F(u) \\right) \\, \\mathrm{d}x,\n$$\n其双阱势为\n$$\nF(u) = \\frac{(u^{2} - 1)^{2}}{4}.\n$$\n一阶变分给出化学势\n$$\n\\mu = \\frac{\\delta \\mathcal{E}}{\\delta u} = -\\varepsilon^{2} \\Delta u + F'(u),\n\\quad F'(u) = u^{3} - u.\n$$\n梯度流为\n$$\n\\text{Allen–Cahn:} \\quad \\frac{\\partial u}{\\partial t} = - M \\mu\n= \\varepsilon^{2} \\Delta u - F'(u),\n$$\n$$\n\\text{Cahn–Hilliard:} \\quad \\frac{\\partial u}{\\partial t} = \\nabla \\cdot ( M \\nabla \\mu )\n= \\Delta \\mu = -\\varepsilon^{2} \\Delta^{2} u + \\Delta F'(u),\n$$\n其中 $M$ 是迁移率，为简化起见设为 $M=1$。两个问题都在 $\\Omega = [0,L] \\times [0,L]$ 上设定，并采用周期性边界条件。空间离散化必须使用快速傅里叶变换 (FFT)，其波数与域大小一致；时间离散化必须是一阶、稳定化的半隐式格式，对线性刚性项采用隐式处理，对非线性项采用显式处理，并增加一个系数为 $S > 0$ 的线性稳定化项，以确保所处理线性部分的无条件稳定性，同时不破坏梯度流结构。\n\n需要监控的离散自由能是与梯度项的谱表示一致的梯形黎曼和。记 $\\widehat{u}$ 为 $u$ 的离散傅里叶变换，并使用物理波数 $\\boldsymbol{k} = (k_{x}, k_{y})$，其中 $k_{x}, k_{y} \\in \\frac{2\\pi}{L} \\mathbb{Z}$，离散能量必须计算为\n$$\n\\mathcal{E}_{h}(u) = \\frac{\\varepsilon^{2}}{2} \\, \\Delta x^{2} \\, \\frac{1}{N^{2}} \\sum_{\\boldsymbol{k}} \\lvert \\boldsymbol{k} \\rvert^{2} \\lvert \\widehat{u}(\\boldsymbol{k}) \\rvert^{2}\n\\;+\\; \\Delta x^{2} \\sum_{i,j} F\\big(u(x_{i},y_{j})\\big),\n$$\n其中 $N \\times N$ 是网格点数，$\\Delta x = L/N$，离散傅里叶变换是未归一化的，因此离散形式的 Parseval's identity 为 $\\sum_{i,j} \\lvert u_{ij} \\rvert^{2} = \\frac{1}{N^{2}} \\sum_{\\boldsymbol{k}} \\lvert \\widehat{u}(\\boldsymbol{k}) \\rvert^{2}$。离散质量为\n$$\nm_{h}(u) = \\Delta x^{2} \\sum_{i,j} u(x_{i},y_{j}).\n$$\n\n您的实现必须：\n\n1. 在均匀网格和周期性边界条件下，使用二维傅里叶谱离散化，每个维度在 $[0,L]$ 上有 $N$ 个点，并根据域大小计算物理波数。\n\n2. 对两个方程实现一个与梯度流结构兼容的一阶稳定化半隐式格式。稳定化系数 $S$ 必须为正，非线性项 $F'(u)$ 必须显式处理，而线性刚性项则隐式处理。对于 Cahn–Hilliard 的更新，该格式必须将零波数模式精确保持到机器精度，从而守恒质量。\n\n3. 在每个时间步计算并监控离散自由能 $\\mathcal{E}_{h}(u^{n})$ 以进行能量衰减检查，并计算 $m_{h}(u^{n})$ 以进行质量守恒检查。\n\n4. 为了进行时间收敛性分析，通过使用三个不同的时间步长 $\\Delta t$、$\\Delta t/2$ 和 $\\Delta t/4$ 运行 Allen–Cahn 求解器直到相同的最终时间，来估计观测阶 $p$。计算\n$$\ne_{12} = \\left( \\Delta x^{2} \\sum_{i,j} \\big(u_{\\Delta t}(x_{i},y_{j},T) - u_{\\Delta t/2}(x_{i},y_{j},T)\\big)^{2} \\right)^{1/2}, \\quad\ne_{23} = \\left( \\Delta x^{2} \\sum_{i,j} \\big(u_{\\Delta t/2}(x_{i},y_{j},T) - u_{\\Delta t/4}(x_{i},y_{j},T)\\big)^{2} \\right)^{1/2},\n$$\n并报告\n$$\np = \\frac{\\log(e_{12}/e_{23})}{\\log(2)}.\n$$\n\n使用以下测试套件，其参数经过精心选择以测试所需属性。在所有情况下，域长度均为 $L=1.0$。如果使用角度，则必须以弧度为单位。除了无量纲设置外，不需要其他物理单位。\n\n- 测试用例 1 (Allen–Cahn 能量单调性)：$N=64$，$\\varepsilon=0.02$，$S=2.0$，$\\Delta t=10^{-3}$，最终时间 $T=0.2$，初始条件 $u_{0}(x,y) = 0.3 \\cos(2\\pi x/L) \\cos(2\\pi y/L)$。输出一个布尔值，指示 $\\mathcal{E}_{h}(u^{n})$ 在所有步长内是否在 $10^{-10}\\,\\mathcal{E}_{h}(u^{0})$ 的容差范围内单调非增。\n\n- 测试用例 2 (Cahn–Hilliard 质量守恒)：$N=64$，$\\varepsilon=0.02$，$S=2.0$，$\\Delta t=10^{-3}$，最终时间 $T=0.2$，初始条件 $u_{0}(x,y) = 0.2 \\cos(2\\pi x/L) \\cos(2\\pi y/L) + 0.1$。输出绝对漂移 $\\lvert m_{h}(u^{T}) - m_{h}(u^{0}) \\rvert$ 作为浮点数。\n\n- 测试用例 3 (Allen–Cahn 时间阶估计)：$N=32$，$\\varepsilon=0.02$，$S=2.0$，三个时间步长 $\\Delta t=2\\times 10^{-3}$、$\\Delta t/2=10^{-3}$ 和 $\\Delta t/4=5\\times 10^{-4}$，最终时间 $T=0.2$，初始条件 $u_{0}(x,y) = 0.3 \\cos(2\\pi x/L) \\cos(2\\pi y/L)$。输出估计的观测阶 $p$ 作为浮点数。\n\n- 测试用例 4 (Cahn–Hilliard 能量单调性)：$N=64$，$\\varepsilon=0.02$，$S=2.0$，$\\Delta t=10^{-3}$，最终时间 $T=0.2$，初始条件 $u_{0}(x,y) = 0.2 \\cos(2\\pi x/L) \\cos(2\\pi y/L)$。输出一个布尔值，指示 $\\mathcal{E}_{h}(u^{n})$ 在所有步长内是否在 $10^{-10}\\,\\mathcal{E}_{h}(u^{0})$ 的容差范围内单调非增。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔结果列表（例如，\"[result1,result2,result3,result4]\"）。这四个结果必须按顺序是：测试用例 1 的布尔值，测试用例 2 的浮点数，测试用例 3 的浮点数，以及测试用例 4 的布尔值。",
            "solution": "用户要求在二维周期性域上实现并验证 Allen-Cahn (AC) 和 Cahn-Hilliard (CH) 方程的数值求解器。验证将重点关注能量单调性、质量守恒和时间收敛阶。\n\n控制方程是 Ginzburg-Landau 自由能泛函的梯度流：\n$$\n\\mathcal{E}(u) = \\int_{\\Omega} \\left( \\frac{\\varepsilon^{2}}{2} \\lvert \\nabla u \\rvert^{2} + F(u) \\right) \\, \\mathrm{d}x,\n$$\n其中 $F(u) = \\frac{1}{4}(u^2-1)^2$ 是一个双阱势。化学势是能量的变分导数，$\\mu = \\delta \\mathcal{E} / \\delta u = -\\varepsilon^2 \\Delta u + F'(u)$，其中 $F'(u) = u^3-u$。\n\nAllen-Cahn 方程是 $L^2$ 梯度流，$\\partial_t u = -\\mu$：\n$$\n\\frac{\\partial u}{\\partial t} = \\varepsilon^{2} \\Delta u - (u^3 - u)\n$$\nCahn-Hilliard 方程是 $H^{-1}$ 梯度流，$\\partial_t u = \\Delta \\mu$：\n$$\n\\frac{\\partial u}{\\partial t} = \\Delta(-\\varepsilon^2 \\Delta u + u^3-u) = -\\varepsilon^2 \\Delta^2 u + \\Delta(u^3-u)\n$$\n\n该解决方案采用傅里叶谱方法在域 $\\Omega = [0,L] \\times [0,L]$ 上的均匀 $N \\times N$ 网格上进行空间离散化。使用快速傅里叶变换 (FFT) 是处理周期性边界条件的理想选择，因为它能对角化常系数微分算子（如 $\\Delta$ 和 $\\Delta^2$），从而将偏微分方程转化为傅里叶空间中的常微分方程组。拉普拉斯算子 $\\Delta$ 对应于对每个波数向量 $\\boldsymbol{k}$ 乘以 $-|\\boldsymbol{k}|^2 = -(k_x^2 + k_y^2)$。类似地，双调和算子 $\\Delta^2$ 对应于乘以 $|\\boldsymbol{k}|^4$。\n\n对于时间离散化，要求采用一阶、稳定化的半隐式格式。这类格式为了稳定性而隐式处理刚性线性项，同时为了简便而显式处理非线性项。为保证任何时间步长下的能量稳定性（无条件稳定性），增加了一个线性稳定化项。一种常用且稳健的方法是线性稳定化格式，其在时间离散域中的一般形式为：\n$$\n\\frac{u^{n+1}-u^n}{\\Delta t} = \\mathcal{L}u^{n+1} + \\mathcal{N}(u^n) - \\mathcal{S}(u^{n+1}-u^n)\n$$\n其中 $\\mathcal{L}$ 是线性微分算子，$\\mathcal{N}$ 是非线性项，$\\mathcal{S}$ 是稳定化算子。对于 AC 和 CH 方程，这导致了以下傅里叶空间中的格式，其中 $\\widehat{u}$ 是 $u$ 的离散傅里叶变换：\n\n对于 Allen-Cahn 方程，$\\mathcal{L}u = \\varepsilon^2 \\Delta u$，$\\mathcal{N}(u) = -F'(u)$，稳定化项为 $\\mathcal{S} = S \\cdot I$（单位算子）。傅里叶空间中的更新公式为：\n$$\n\\widehat{u}^{n+1} = \\frac{(1 + S \\Delta t) \\widehat{u}^n - \\Delta t \\widehat{F'(u^n)}}{1 + S \\Delta t + \\varepsilon^2 |\\boldsymbol{k}|^2 \\Delta t}\n$$\n对于任何 $S>0$，此格式都是无条件能量稳定的。\n\n对于 Cahn-Hilliard 方程，$\\mathcal{L}u = -\\varepsilon^2 \\Delta^2 u$，$\\mathcal{N}(u) = \\Delta F'(u)$。为保持守恒性质（$H^{-1}$ 结构），稳定化算子选择为 $\\mathcal{S} = -S \\Delta$。格式变为：\n$$\n\\frac{u^{n+1}-u^n}{\\Delta t} = (-\\varepsilon^2\\Delta^2 - S\\Delta) u^{n+1} + \\Delta F'(u^n) + S\\Delta u^n\n$$\n在傅里叶空间中，这产生了更新规则：\n$$\n\\widehat{u}^{n+1} = \\frac{\\widehat{u}^n(1 + S\\Delta t|\\boldsymbol{k}|^2) - \\Delta t |\\boldsymbol{k}|^2 \\widehat{F'(u^n)}}{1 + \\Delta t(\\varepsilon^2|\\boldsymbol{k}|^4 + S|\\boldsymbol{k}|^2)}\n$$\n对于 $S \\ge 0$，此格式是无条件能量稳定的。值得注意的是，对于零波数模式（$\\boldsymbol{k}=\\boldsymbol{0}$），$|\\boldsymbol{k}|=0$，更新简化为 $\\widehat{u}^{n+1}(\\boldsymbol{0}) = \\widehat{u}^n(\\boldsymbol{0})$，这确保了总质量 $\\int u \\, \\mathrm{d}x$ 在机器精度下是精确守恒的。\n\n实现包含一个分派四个测试用例的主求解器函数。一个通用的模拟函数处理两种方程类型的核心逻辑。辅助函数根据问题陈述中的定义计算离散能量和质量。\n\n1.  **能量单调性检查（测试 1 和 4）：** 在每个时间步计算离散能量 $\\mathcal{E}_h(u^n)$。如果在整个模拟过程中，能量在小的数值容差内是非递增的，即 $\\mathcal{E}_h(u^{n+1}) \\le \\mathcal{E}_h(u^n) + \\text{tol}$，则测试通过。\n\n2.  **质量守恒检查（测试 2）：** 对于 Cahn-Hilliard 方程，计算初始和最终状态的总离散质量 $m_h(u) = \\Delta x^2 \\sum_{i,j} u_{ij}$。报告其绝对差值。\n\n3.  **时间阶估计（测试 3）：** 使用三个相继减半的时间步长（$\\Delta t, \\Delta t/2, \\Delta t/4$）求解 Allen-Cahn 方程至时间 $T$。计算解之间的离散 $L^2$ 误差 $e_{12}$ 和 $e_{23}$。然后使用公式 $p = \\log(e_{12}/e_{23})/\\log(2)$ 估计观测到的收敛阶 $p$。对于一阶格式，预计 $p$ 约等于 $1$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies numerical solvers for Allen-Cahn and Cahn-Hilliard equations\n    based on the specified test suite.\n    \"\"\"\n\n    def compute_energy(u, K2, epsilon, dx, N):\n        \"\"\"\n        Computes the discrete Ginzburg-Landau free energy according to the problem specification.\n        \n        Args:\n            u (np.ndarray): The field variable on a 2D grid.\n            K2 (np.ndarray): The squared magnitudes of the wavenumbers.\n            epsilon (float): The interface width parameter.\n            dx (float): The grid spacing.\n            N (int): The number of grid points in one dimension.\n            \n        Returns:\n            float: The total discrete free energy.\n        \"\"\"\n        u_hat = np.fft.fftn(u)\n        \n        # Gradient term, consistent with the specified Parseval's identity.\n        grad_energy_term = (epsilon**2 / 2.0) * dx**2 * (1.0 / (N**2)) * np.sum(K2 * np.abs(u_hat)**2)\n        \n        # Potential term.\n        potential_F = (u**2 - 1.0)**2 / 4.0\n        potential_energy_term = dx**2 * np.sum(potential_F)\n        \n        return grad_energy_term + potential_energy_term\n\n    def compute_mass(u, dx):\n        \"\"\"\n        Computes the discrete total mass.\n        \n        Args:\n            u (np.ndarray): The field variable on a 2D grid.\n            dx (float): The grid spacing.\n        \n        Returns:\n            float: The total discrete mass.\n        \"\"\"\n        return dx**2 * np.sum(u)\n\n    def run_simulation(eq_type, N, L, epsilon, S, dt, T, u0_func, track_energy=False):\n        \"\"\"\n        Runs a simulation for either the Allen-Cahn or Cahn-Hilliard equation.\n        \n        Args:\n            eq_type (str): 'AC' for Allen-Cahn, 'CH' for Cahn-Hilliard.\n            N (int): Grid points per dimension.\n            L (float): Domain size.\n            epsilon (float): Interface width parameter.\n            S (float): Stabilization coefficient.\n            dt (float): Time step size.\n            T (float): Final time.\n            u0_func (callable): Function to generate the initial condition u0(X, Y).\n            track_energy (bool): If True, computes and returns the energy at each step.\n            \n        Returns:\n            tuple: A tuple containing the final field u (np.ndarray) and a list of energies.\n        \"\"\"\n        dx = L / N\n        \n        # Set up grid and wavenumbers. `indexing='ij'` ensures (row, col) consistency.\n        x_1d = np.arange(N) * dx\n        X, Y = np.meshgrid(x_1d, x_1d, indexing='ij')\n        \n        k_1d = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n        KX, KY = np.meshgrid(k_1d, k_1d, indexing='ij')\n        K2 = KX**2 + KY**2\n\n        u = u0_func(X, Y)\n\n        # Precompute denominators for Fourier-space updates.\n        if eq_type == 'AC':\n            denom = 1.0 + S * dt + epsilon**2 * K2 * dt\n        elif eq_type == 'CH':\n            K4 = K2**2\n            denom = 1.0 + dt * (epsilon**2 * K4 + S * K2)\n        else:\n            raise ValueError(\"Unknown equation type\")\n\n        num_steps = int(round(T / dt))\n        \n        energies = []\n        if track_energy:\n            energies.append(compute_energy(u, K2, epsilon, dx, N))\n\n        for _ in range(num_steps):\n            Fprime = u**3 - u\n            \n            u_hat = np.fft.fftn(u)\n            Fprime_hat = np.fft.fftn(Fprime)\n\n            if eq_type == 'AC':\n                u_hat_new = ((1.0 + S * dt) * u_hat - dt * Fprime_hat) / denom\n            else:  # CH\n                u_hat_new = (u_hat * (1.0 + S * dt * K2) - dt * K2 * Fprime_hat) / denom\n\n            u = np.fft.ifftn(u_hat_new).real\n\n            if track_energy:\n                energies.append(compute_energy(u, K2, epsilon, dx, N))\n\n        return u, energies\n\n    # Set common domain size\n    L = 1.0\n    \n    # Test cases defined in the problem statement\n    test_cases = [\n        # (1) Allen-Cahn energy monotonicity check\n        {\n            \"id\": 1, \"type\": \"AC\", \"N\": 64, \"epsilon\": 0.02, \"S\": 2.0,\n            \"dt\": 1e-3, \"T\": 0.2,\n            \"u0_func\": lambda X, Y: 0.3 * np.cos(2*np.pi*X/L) * np.cos(2*np.pi*Y/L)\n        },\n        # (2) Cahn-Hilliard mass conservation check\n        {\n            \"id\": 2, \"type\": \"CH\", \"N\": 64, \"epsilon\": 0.02, \"S\": 2.0,\n            \"dt\": 1e-3, \"T\": 0.2,\n            \"u0_func\": lambda X, Y: 0.2 * np.cos(2*np.pi*X/L) * np.cos(2*np.pi*Y/L) + 0.1\n        },\n        # (3) Allen-Cahn temporal order estimation\n        {\n            \"id\": 3, \"type\": \"AC\", \"N\": 32, \"epsilon\": 0.02, \"S\": 2.0,\n            \"dts\": [2e-3, 1e-3, 5e-4], \"T\": 0.2,\n            \"u0_func\": lambda X, Y: 0.3 * np.cos(2*np.pi*X/L) * np.cos(2*np.pi*Y/L)\n        },\n        # (4) Cahn-Hilliard energy monotonicity check\n        {\n            \"id\": 4, \"type\": \"CH\", \"N\": 64, \"epsilon\": 0.02, \"S\": 2.0,\n            \"dt\": 1e-3, \"T\": 0.2,\n            \"u0_func\": lambda X, Y: 0.2 * np.cos(2*np.pi*X/L) * np.cos(2*np.pi*Y/L)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[\"id\"] == 1:\n            p = case\n            _, energies = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dt\"], p[\"T\"], p[\"u0_func\"], track_energy=True)\n            \n            is_monotonic = True\n            E0 = energies[0]\n            tolerance = 1e-10 * abs(E0) if E0 != 0 else 1e-10\n            for i in range(len(energies) - 1):\n                if energies[i+1]  energies[i] + tolerance:\n                    is_monotonic = False\n                    break\n            results.append(is_monotonic)\n\n        elif case[\"id\"] == 2:\n            p = case\n            dx = L / p[\"N\"]\n            x_1d = np.arange(p[\"N\"]) * dx\n            X, Y = np.meshgrid(x_1d, x_1d, indexing='ij')\n            u_initial = p[\"u0_func\"](X, Y)\n            m0 = compute_mass(u_initial, dx)\n            \n            u_final, _ = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dt\"], p[\"T\"], p[\"u0_func\"])\n            \n            mf = compute_mass(u_final, dx)\n            results.append(abs(mf - m0))\n\n        elif case[\"id\"] == 3:\n            p = case\n            u_final_dt1, _ = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dts\"][0], p[\"T\"], p[\"u0_func\"])\n            u_final_dt2, _ = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dts\"][1], p[\"T\"], p[\"u0_func\"])\n            u_final_dt3, _ = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dts\"][2], p[\"T\"], p[\"u0_func\"])\n            \n            dx = L / p[\"N\"]\n            e12 = dx * np.sqrt(np.sum((u_final_dt1 - u_final_dt2)**2))\n            e23 = dx * np.sqrt(np.sum((u_final_dt2 - u_final_dt3)**2))\n            \n            if e12  0 and e23  0 and e12 / e23  0:\n                order = np.log(e12 / e23) / np.log(2.0)\n            else:\n                order = 0.0 # Indicate failure or no convergence\n            results.append(order)\n\n        elif case[\"id\"] == 4:\n            p = case\n            _, energies = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dt\"], p[\"T\"], p[\"u0_func\"], track_energy=True)\n            \n            is_monotonic = True\n            E0 = energies[0]\n            tolerance = 1e-10 * abs(E0) if E0 != 0 else 1e-10\n            for i in range(len(energies) - 1):\n                if energies[i+1]  energies[i] + tolerance:\n                    is_monotonic = False\n                    break\n            results.append(is_monotonic)\n\n    # Format output as specified: comma-separated list in brackets, booleans as lowercase\n    formatted_results = []\n    for r in results:\n        if isinstance(r, (bool, np.bool_)):\n            formatted_results.append(str(r).lower())\n        else:\n            formatted_results.append(f\"{r:.15g}\")\n            \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "开发出数值求解器后，以数学的严谨性来验证其正确性至关重要。本实践将介绍一种代码验证的黄金标准——“人造解方法”(Method of Manufactured Solutions, MMS)，通过该方法，我们强制一个已知的解析函数成为我们方程的精确解。通过衡量我们的离散算子满足该条件的程度，我们可以精确地量化代码实现的准确性和收敛阶。",
            "id": "3430574",
            "problem": "要求您使用制造解方法 (MMS) 为相场界面演化方程设计、推导并实现一个数值代码验证实验。目标方程是 Allen-Cahn 方程和 Cahn-Hilliard 方程，这是两个由 Ginzburg-Landau 自由能的梯度流推导出的标准相场模型。您的任务是从方程的基本定义出发，推导出使制造场成为所得强迫方程精确解的强迫函数（源项），然后通过测量将精确强迫项代入离散方程后所余的残差，来量化周期域上二阶中心差分算子的空间离散误差。\n\n对于一维周期域 $\\,x\\in[0,1]\\,$（周期为 $\\,1\\,$）上的标量序参量场 $\\,\\phi(x,t)\\,$，其控制方程为：\n\n- 带有附加源项 $\\,S_{\\mathrm{AC}}(x,t)\\,$ 的 Allen-Cahn (AC) 方程：\n$$\n\\partial_t \\phi \\;=\\; \\varepsilon^2 \\,\\partial_{xx}\\phi \\;-\\; W'(\\phi)\\;+\\; S_{\\mathrm{AC}}(x,t),\n$$\n- 带有附加源项 $\\,S_{\\mathrm{CH}}(x,t)\\,$ 的 Cahn-Hilliard (CH) 方程，写作具有恒定迁移率 $\\,M=1\\,$ 的等效四阶形式：\n$$\n\\partial_t \\phi \\;=\\; -\\,\\varepsilon^2\\,\\partial_{xxxx}\\phi \\;+\\;\\partial_{xx}\\!\\big(W'(\\phi)\\big)\\;+\\; S_{\\mathrm{CH}}(x,t).\n$$\n\n这里 $\\,\\varepsilon0\\,$ 是弥散界面厚度参数，$\\,W(\\phi)\\,$ 是经典的双阱势\n$$\nW(\\phi) \\;=\\; \\tfrac{1}{4}\\,\\big(\\phi^2-1\\big)^2,\n$$\n因此\n$$\nW'(\\phi) \\;=\\; \\phi^3\\;-\\;\\phi.\n$$\n\n采用以下具有混合时空频率的制造光滑解：\n$$\n\\phi(x,t) \\;=\\; A\\,\\cos\\!\\big(2\\pi k\\,x\\big)\\,\\cos\\!\\big(\\omega\\,t\\big)\\;+\\; B\\,\\sin\\!\\big(2\\pi q\\,x\\big)\\,\\sin\\!\\big(\\omega\\,t\\big),\n$$\n其中常数为 $\\,A=0.6\\,$，$\\,B=0.2\\,$，$\\,k=1\\,$，$\\,q=2\\,$，以及 $\\,\\omega=1.7\\,$。空间域是周期性的，周期为 $\\,1\\,$，所有关于 $\\,x\\,$ 的导数都应满足周期性边界条件。将评估时间固定在 $\\,t_0=0.37\\,$。\n\n任务1（从第一性原理推导）：使用制造解方法 (MMS)，推导源项 $\\,S_{\\mathrm{AC}}(x,t)\\,$ 和 $\\,S_{\\mathrm{CH}}(x,t)\\,$，使得上述 $\\,\\phi(x,t)\\,$ 分别是各自强迫方程的精确解。您的出发点必须是给定的控制方程和链式法则，以及制造场的精确空间和时间导数。您必须完全用 $\\,\\phi\\,$ 及其精确导数和 $\\,W'(\\phi)\\,$ 来表示 $\\,S_{\\mathrm{AC}}(x,t)\\,$ 和 $\\,S_{\\mathrm{CH}}(x,t)\\,$，在此阶段不引入任何离散化。\n\n任务2（用于验证的离散残差设计）：考虑在 $\\,x\\in[0,1]\\,$ 上的一个有 $\\,N\\,$ 个点的均匀网格，网格间距为 $\\,\\Delta x = 1/N\\,$，并令 $\\,x_i=i\\,\\Delta x\\,$，其中 $\\,i=0,1,\\dots,N-1\\,$。定义带有周期性边界条件的二阶导数的二阶中心差分近似：\n$$\n\\mathcal{D}_2[\\psi]_i \\;=\\; \\frac{\\psi_{i-1} - 2\\,\\psi_i + \\psi_{i+1}}{(\\Delta x)^2},\n$$\n其中下标对 $\\,N\\,$ 取模。将相应的离散四阶导数定义为 $\\,\\mathcal{D}_4[\\psi]\\equiv \\mathcal{D}_2\\!\\big[\\mathcal{D}_2[\\psi]\\big]\\,$。那么，在每个网格点 $\\,x_i\\,$ 的离散验证残差定义如下：\n\n- 对于 Allen-Cahn 情况，\n$$\n\\mathcal{R}_{\\mathrm{AC},i} \\;=\\; \\big(\\partial_t\\phi\\big)(x_i,t_0)\\;-\\;\\Big(\\varepsilon^2\\,\\mathcal{D}_2[\\phi]_i \\;-\\; W'\\big(\\phi(x_i,t_0)\\big) \\;+\\; S_{\\mathrm{AC}}(x_i,t_0)\\Big).\n$$\n\n- 对于 Cahn-Hilliard 情况（使用四阶形式），\n$$\n\\mathcal{R}_{\\mathrm{CH},i} \\;=\\; \\big(\\partial_t\\phi\\big)(x_i,t_0)\\;-\\;\\Big(\\,-\\varepsilon^2\\,\\mathcal{D}_4[\\phi]_i \\;+\\; \\mathcal{D}_2\\big[W'(\\phi)\\big]_i \\;+\\; S_{\\mathrm{CH}}(x_i,t_0)\\Big).\n$$\n\n因为源项是用精确导数推导的，而残差使用的是离散空间算子，所以非零残差直接度量了空间离散误差。使用 $[0,1]$ 上的离散 $\\,L^2\\,$ 范数量化此误差，\n$$\n\\|\\mathcal{R}\\|_{L^2_h} \\;=\\; \\sqrt{\\,\\sum_{i=0}^{N-1} \\big(\\mathcal{R}_i\\big)^2\\,\\Delta x\\,}.\n$$\n\n任务3（实现与测试套件）：实现一个程序，该程序能够\n- 计算 $\\,\\phi(x_i,t_0)\\,$ 以及 $\\,S_{\\mathrm{AC}}\\,$ 和 $\\,S_{\\mathrm{CH}}\\,$ 所需的其精确导数，\n- 构建带有周期性边界条件的离散算子 $\\,\\mathcal{D}_2\\,$ 和 $\\,\\mathcal{D}_4\\,$，\n- 在时间 $\\,t_0\\,$ 形成离散残差 $\\,\\mathcal{R}_{\\mathrm{AC}}\\,$ 和 $\\,\\mathcal{R}_{\\mathrm{CH}}\\,$，以及\n- 对每个指定的测试案例返回离散 $\\,L^2\\,$ 范数。\n\n使用以下四个测试案例，每个案例由元组 $\\,(\\text{方程},\\,N,\\,\\varepsilon)\\,$ 定义，制造解常数如上所述为 $\\,A=0.6\\,$，$\\,B=0.2\\,$，$\\,k=1\\,$，$\\,q=2\\,$，$\\,\\omega=1.7\\,$，以及 $\\,t_0=0.37\\,$：\n\n- 测试 $\\,1\\,$：$\\,(\\text{AC},\\,N=64,\\,\\varepsilon=0.05)\\,$，\n- 测试 $\\,2\\,$：$\\,(\\text{AC},\\,N=128,\\,\\varepsilon=0.05)\\,$，\n- 测试 $\\,3\\,$：$\\,(\\text{CH},\\,N=64,\\,\\varepsilon=0.03)\\,$，\n- 测试 $\\,4\\,$：$\\,(\\text{CH},\\,N=128,\\,\\varepsilon=0.03)\\,$。\n\n您的程序应生成单行输出，其中包含四个残差范数，格式为方括号括起来的逗号分隔列表（例如，$[\\text{r}_1,\\text{r}_2,\\text{r}_3,\\text{r}_4]$）。每个条目必须是浮点数。不允许用户输入，也不得读取或写入任何外部文件。域长度是无量纲的且等于 $\\,1\\,$，因此答案中不需要物理单位。通过三角函数，角度被隐式地以弧度为单位。",
            "solution": "该问题是有效的。它是偏微分方程数值分析领域中一个适定的、有科学依据的、客观的问题。它要求使用标准的制造解方法 (MMS) 为 Allen-Cahn 和 Cahn-Hilliard 方程推导并实现一个代码验证测试。所有必要的信息都已提供，任务也已明确定义。\n\n根据要求，解答过程分两个阶段进行。首先，我们对源项和由此产生的离散残差进行解析推导。其次，我们在 Python 程序中实现这些推导，以计算指定的残差范数。\n\n### 任务1：源项的推导\n\n制造解方法 (MMS) 的过程是，假定一个光滑的解析函数作为控制偏微分方程 (PDE) 修改版本的精确解。修改之处在于增加一个源项，该源项通过将制造解代入原始 PDE 推导得出。\n\n给定的制造解为：\n$$\n\\phi(x,t) \\;=\\; A\\,\\cos\\!\\big(2\\pi k\\,x\\big)\\,\\cos\\!\\big(\\omega\\,t\\big)\\;+\\; B\\,\\sin\\!\\big(2\\pi q\\,x\\big)\\,\\sin\\!\\big(\\omega\\,t\\big)\n$$\n常数为 $A=0.6$，$B=0.2$，$k=1$，$q=2$ 和 $\\omega=1.7$。势函数为 $W(\\phi) = \\tfrac{1}{4}(\\phi^2-1)^2$，其导数为 $W'(\\phi) = \\phi^3 - \\phi$。\n\n为了推导源项，我们重排控制方程以求解 $S_{\\mathrm{AC}}(x,t)$ 和 $S_{\\mathrm{CH}}(x,t)$，并假设 $\\phi(x,t)$ 是一个解。\n\n**Allen-Cahn (AC) 源项：**\n强迫 AC 方程为：\n$$\n\\partial_t \\phi \\;=\\; \\varepsilon^2 \\,\\partial_{xx}\\phi \\;-\\; W'(\\phi)\\;+\\; S_{\\mathrm{AC}}(x,t)\n$$\n求解源项 $S_{\\mathrm{AC}}(x,t)$ 可得：\n$$\nS_{\\mathrm{AC}}(x,t) \\;=\\; \\partial_t \\phi(x,t) \\;-\\; \\varepsilon^2 \\,\\partial_{xx}\\phi(x,t) \\;+\\; W'(\\phi(x,t))\n$$\n这里，$\\partial_t \\phi$ 和 $\\partial_{xx}\\phi$ 是制造解 $\\phi(x,t)$ 的精确解析时间导数和二阶空间导数。\n\n**Cahn-Hilliard (CH) 源项：**\n强迫 CH 方程为：\n$$\n\\partial_t \\phi \\;=\\; -\\,\\varepsilon^2\\,\\partial_{xxxx}\\phi \\;+\\;\\partial_{xx}\\!\\big(W'(\\phi)\\big)\\;+\\; S_{\\mathrm{CH}}(x,t)\n$$\n求解源项 $S_{\\mathrm{CH}}(x,t)$ 可得：\n$$\nS_{\\mathrm{CH}}(x,t) \\;=\\; \\partial_t \\phi(x,t) \\;+\\; \\varepsilon^2\\,\\partial_{xxxx}\\phi(x,t) \\;-\\; \\partial_{xx}\\!\\big(W'(\\phi(x,t))\\big)\n$$\n这里，$\\partial_t \\phi$ 和 $\\partial_{xxxx}\\phi$ 是 $\\phi(x,t)$ 的精确解析导数。项 $\\partial_{xx}(W'(\\phi))$ 使用链式法则计算。首先，$W'(\\phi)$ 对 $\\phi$ 的导数是 $W''(\\phi) = 3\\phi^2-1$。\n一阶空间导数为：\n$$\n\\partial_x(W'(\\phi)) = W''(\\phi) \\, \\partial_x\\phi = (3\\phi^2-1)\\,\\partial_x\\phi\n$$\n二阶空间导数为：\n$$\n\\partial_{xx}(W'(\\phi)) = \\partial_x\\left( (3\\phi^2-1)\\,\\partial_x\\phi \\right) = (6\\phi\\,\\partial_x\\phi)\\,\\partial_x\\phi + (3\\phi^2-1)\\,\\partial_{xx}\\phi = 6\\phi(\\partial_x\\phi)^2 + (3\\phi^2-1)\\,\\partial_{xx}\\phi\n$$\n这些关于 $S_{\\mathrm{AC}}$ 和 $S_{\\mathrm{CH}}$ 的表达式是精确的，并在所有点 $(x,t)$ 上都有定义。\n\n### 任务2：离散残差设计\n\n离散验证残差衡量了在使用精确源项时，制造解在多大程度上不满足*离散化*的控制方程。这个非零残差是空间算子离散误差的直接度量。\n\n**AC 残差：**\n在网格点 $x_i$ 和时间 $t_0$ 上的 AC 残差定义为：\n$$\n\\mathcal{R}_{\\mathrm{AC},i} \\;=\\; \\big(\\partial_t\\phi\\big)(x_i,t_0)\\;-\\;\\Big(\\varepsilon^2\\,\\mathcal{D}_2[\\phi]_i \\;-\\; W'\\big(\\phi(x_i,t_0)\\big) \\;+\\; S_{\\mathrm{AC}}(x_i,t_0)\\Big)\n$$\n代入 $S_{\\mathrm{AC}}(x_i,t_0) = (\\partial_t\\phi - \\varepsilon^2\\,\\partial_{xx}\\phi + W'(\\phi))|_{x_i,t_0}$ 的表达式：\n$$\n\\mathcal{R}_{\\mathrm{AC},i} \\;=\\; \\partial_t\\phi \\;-\\; \\Big(\\varepsilon^2\\,\\mathcal{D}_2[\\phi]_i \\;-\\; W'(\\phi) \\;+\\; (\\partial_t\\phi - \\varepsilon^2\\,\\partial_{xx}\\phi + W'(\\phi))\\Big)\n$$\n$$\n\\mathcal{R}_{\\mathrm{AC},i} \\;=\\; \\partial_t\\phi - \\varepsilon^2\\,\\mathcal{D}_2[\\phi]_i + W'(\\phi) - \\partial_t\\phi + \\varepsilon^2\\,\\partial_{xx}\\phi - W'(\\phi)\n$$\n化简后，我们得到：\n$$\n\\mathcal{R}_{\\mathrm{AC},i} \\;=\\; \\varepsilon^2\\left(\\partial_{xx}\\phi(x_i,t_0) - \\mathcal{D}_2[\\phi]_i\\right)\n$$\n这表明，当用二阶中心差分算子 $\\mathcal{D}_2$ 近似二阶导数 $\\partial_{xx}\\phi$ 时，残差恰好是其截断误差的 $\\varepsilon^2$ 倍。\n\n**CH 残差：**\n在网格点 $x_i$ 和时间 $t_0$ 上的 CH 残差定义为：\n$$\n\\mathcal{R}_{\\mathrm{CH},i} \\;=\\; \\big(\\partial_t\\phi\\big)(x_i,t_0)\\;-\\;\\Big(\\!-\\varepsilon^2\\,\\mathcal{D}_4[\\phi]_i \\;+\\; \\mathcal{D}_2\\big[W'(\\phi)\\big]_i \\;+\\; S_{\\mathrm{CH}}(x_i,t_0)\\Big)\n$$\n代入 $S_{\\mathrm{CH}}(x_i,t_0) = (\\partial_t\\phi + \\varepsilon^2\\,\\partial_{xxxx}\\phi - \\partial_{xx}(W'(\\phi)))|_{x_i,t_0}$ 的表达式：\n$$\n\\mathcal{R}_{\\mathrm{CH},i} \\;=\\; \\partial_t\\phi \\;-\\; \\Big(\\!-\\varepsilon^2\\,\\mathcal{D}_4[\\phi]_i \\;+\\; \\mathcal{D}_2\\big[W'(\\phi)\\big]_i \\;+\\; (\\partial_t\\phi + \\varepsilon^2\\,\\partial_{xxxx}\\phi - \\partial_{xx}(W'(\\phi)))\\Big)\n$$\n$$\n\\mathcal{R}_{\\mathrm{CH},i} \\;=\\; \\partial_t\\phi + \\varepsilon^2\\,\\mathcal{D}_4[\\phi]_i - \\mathcal{D}_2[W'(\\phi)]_i - \\partial_t\\phi - \\varepsilon^2\\,\\partial_{xxxx}\\phi + \\partial_{xx}(W'(\\phi))\n$$\n化简后，我们得到：\n$$\n\\mathcal{R}_{\\mathrm{CH},i} \\;=\\; \\varepsilon^2\\big(\\mathcal{D}_4[\\phi]_i - \\partial_{xxxx}\\phi(x_i, t_0)\\big) \\;+\\; \\big(\\partial_{xx}(W'(\\phi))(x_i,t_0) - \\mathcal{D}_2[W'(\\phi)]_i\\big)\n$$\n该残差由两项组成，每一项都代表一个截断误差。第一项是离散双调和算子 $\\mathcal{D}_4$ 截断误差的 $\\varepsilon^2$ 倍。第二项是作用于非线性量 $W'(\\phi)$ 的离散拉普拉斯算子 $\\mathcal{D}_2$ 的截断误差。离散算子 $\\mathcal{D}_2$ 和 $\\mathcal{D}_4$ 都是二阶精度的，因此预计总残差范数会以 $O((\\Delta x)^2)$ 的阶数收敛到零。\n\n我们将实现这些关于 $\\mathcal{R}_{\\mathrm{AC},i}$ 和 $\\mathcal{R}_{\\mathrm{CH},i}$ 的简化表达式，以计算残差范数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs, derives, and implements a code verification experiment for\n    Allen-Cahn and Cahn-Hilliard equations using MMS.\n    \"\"\"\n    # Define constants from the problem statement.\n    A = 0.6\n    B = 0.2\n    k = 1.0\n    q = 2.0\n    omega = 1.7\n    t0 = 0.37\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('AC', 64, 0.05),\n        ('AC', 128, 0.05),\n        ('CH', 64, 0.03),\n        ('CH', 128, 0.03),\n    ]\n\n    # Pre-calculate angular frequencies for efficiency\n    K = 2.0 * np.pi * k\n    Q = 2.0 * np.pi * q\n\n    # --- Analytical functions for the manufactured solution and its derivatives ---\n\n    def phi_fn(x, t):\n        \"\"\"Manufactured solution phi(x,t).\"\"\"\n        term1 = A * np.cos(K * x) * np.cos(omega * t)\n        term2 = B * np.sin(Q * x) * np.sin(omega * t)\n        return term1 + term2\n\n    def dt_phi_fn(x, t):\n        \"\"\"Temporal derivative d(phi)/dt.\"\"\"\n        term1 = -A * omega * np.cos(K * x) * np.sin(omega * t)\n        term2 = B * omega * np.sin(Q * x) * np.cos(omega * t)\n        return term1 + term2\n\n    def dx_phi_fn(x, t):\n        \"\"\"First spatial derivative d(phi)/dx.\"\"\"\n        term1 = -A * K * np.sin(K * x) * np.cos(omega * t)\n        term2 = B * Q * np.cos(Q * x) * np.sin(omega * t)\n        return term1 + term2\n\n    def dxx_phi_fn(x, t):\n        \"\"\"Second spatial derivative d^2(phi)/dx^2.\"\"\"\n        term1 = -A * K**2 * np.cos(K * x) * np.cos(omega * t)\n        term2 = -B * Q**2 * np.sin(Q * x) * np.sin(omega * t)\n        return term1 + term2\n        \n    def dxxxx_phi_fn(x, t):\n        \"\"\"Fourth spatial derivative d^4(phi)/dx^4.\"\"\"\n        term1 = A * K**4 * np.cos(K * x) * np.cos(omega * t)\n        term2 = B * Q**4 * np.sin(Q * x) * np.sin(omega * t)\n        return term1 + term2\n\n    def w_prime_fn(p):\n        \"\"\"Derivative of the double-well potential W'(phi) = phi^3 - phi.\"\"\"\n        return p**3 - p\n\n    def dxx_w_prime_fn(p, dx_p, dxx_p):\n        \"\"\"Analytical second spatial derivative of W'(phi(x,t)).\"\"\"\n        # d/dx(W'(p)) = (3p^2 - 1) * dx_p\n        # d^2/dx^2(W'(p)) = 6p*(dx_p)^2 + (3p^2 - 1)*dxx_p\n        return 6.0 * p * dx_p**2 + (3.0 * p**2 - 1.0) * dxx_p\n\n    # --- Discrete operators with periodic boundary conditions ----\n\n    def d2_op(f, dx):\n        \"\"\"Second-order central difference for the second derivative.\"\"\"\n        f_im1 = np.roll(f, 1)  # f_{i-1}\n        f_ip1 = np.roll(f, -1) # f_{i+1}\n        return (f_im1 - 2.0 * f + f_ip1) / dx**2\n\n    def d4_op(f, dx):\n        \"\"\"Second-order central difference for the fourth derivative (biharmonic).\"\"\"\n        return d2_op(d2_op(f, dx), dx)\n\n    results = []\n    for eq_type, N, eps in test_cases:\n        dx = 1.0 / N\n        x = np.arange(N) * dx  # Grid points x_i = i * dx for i=0,...,N-1\n\n        # Evaluate the manufactured solution and its derivatives on the grid at t0\n        phi_vals = phi_fn(x, t0)\n\n        if eq_type == 'AC':\n            # Calculate the AC residual: R_AC = eps^2 * (exact_dxx - discrete_dxx)\n            exact_dxx_phi = dxx_phi_fn(x, t0)\n            discrete_dxx_phi = d2_op(phi_vals, dx)\n            residual = eps**2 * (exact_dxx_phi - discrete_dxx_phi)\n        \n        elif eq_type == 'CH':\n            # Calculate CH residual: R_CH = eps^2(D4[p]-d4p) + (d2(W') - D2[W'])\n            # Term 1: Discretization error of the biharmonic operator\n            exact_dxxxx_phi = dxxxx_phi_fn(x, t0)\n            discrete_d4_phi = d4_op(phi_vals, dx)\n            term1 = eps**2 * (discrete_d4_phi - exact_dxxxx_phi)\n            \n            # Term 2: Discretization error of the Laplacian on W'(phi)\n            w_prime_vals = w_prime_fn(phi_vals)\n            discrete_d2_w_prime = d2_op(w_prime_vals, dx)\n            \n            # For exact dxx(W'), we need exact phi, dx_phi, and dxx_phi\n            dx_phi_vals = dx_phi_fn(x, t0)\n            dxx_phi_vals = dxx_phi_fn(x, t0)\n            exact_dxx_w_prime_vals = dxx_w_prime_fn(phi_vals, dx_phi_vals, dxx_phi_vals)\n            \n            term2 = exact_dxx_w_prime_vals - discrete_d2_w_prime\n            \n            residual = term1 + term2\n\n        # Calculate the discrete L2 norm of the residual\n        # ||R||_h = sqrt( sum(R_i^2 * dx) )\n        norm = np.sqrt(np.sum(residual**2) * dx)\n        results.append(norm)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了模拟更复杂的物理现象，我们必须超越简单的模型和方法。本练习将处理带有“简并迁移率”的 Cahn-Hilliard 方程，该特性会引入如界面钉扎 (interface pinning) 等新的物理行为。您将使用功能强大的有限元方法 (Finite Element Method, FEM) 来构建一个稳健的求解器，该求解器能正确处理迁移率的非负性，并能够对这些高级界面动力学行为进行定量研究。",
            "id": "3430598",
            "problem": "考虑在周期性一维域 $[0,1]$ 上具有退化迁移率的 Cahn–Hilliard 方程，\n$$\n\\partial_t \\phi = \\partial_x \\left( M(\\phi)\\, \\partial_x \\mu \\right), \\qquad \\mu = -\\varepsilon^2 \\partial_{xx} \\phi + W'(\\phi),\n$$\n其中 $W(\\phi) = \\frac{1}{4}(\\phi^2 - 1)^2$ 是对称双阱势，$M(\\phi) = (1 - \\phi^2)_+$ 是退化迁移率，$(\\cdot)_+$ 表示正部。未知量 $\\phi(x,t)$ 代表一个相场序参数，在体相中取值接近 $-1$ 和 $+1$，而 $\\varepsilon  0$ 控制界面厚度。\n\n您的任务是设计并实现一个线性有限元离散化方案，该方案在构造上能逐点保持迁移率的非负性，并允许您在 $\\varepsilon \\to 0$ 时定量评估界面钉扎和人工扩散之间的竞争。\n\n从通过将方程乘以测试函数并在 $[0,1]$ 上使用周期性边界条件积分得到的变分形式出发，按以下步骤进行：\n\n- 在具有周期性边界条件的 $N$ 个节点的均匀网格上，使用连续分片线性有限元，并对 $L^2$ 内积应用质量集中，使质量矩阵成为对角矩阵。\n- 以逐点保持非负性的方式离散化迁移率：在节点处计算 $M(\\phi)$，并将每个网格边上的单元系数定义为相邻节点迁移率的算术平均值。组装相应的迁移率加权刚度算子，使其对于任何非负单元系数都是对称半正定的。\n- 使用从梯度流结构推导出的线性半隐式时间离散格式，其中隐式处理界面项，显式处理非线性体相项，并通过添加一个与 $\\phi^{n+1}-\\phi^n$ 成正比的线性项（稳定化参数 $s0$）来进行稳定化。选择一个固定的、足够大的 $s$，以确保线性的适定性和数值稳定性，同时不破坏空间上的退化迁移率结构。\n\n对于几个参数值，在最终时刻定量计算两个诊断量：\n\n1. 非负迁移率保持：计算最终时刻的最小单元迁移率，其定义为 $M(\\phi)$ 的两个相邻节点值的算术平均值在所有单元上的最小值，并将其报告为一个非负浮点数。\n2. 界面宽度与 $\\varepsilon$ 的关系：对于一个由 -1 背景中的 +1 相光滑液滴组成的初始条件，\n$$\n\\phi(x,0) = -\\tanh\\!\\left(\\frac{x-x_L}{\\sqrt{2}\\,\\varepsilon}\\right)\\tanh\\!\\left(\\frac{x-x_R}{\\sqrt{2}\\,\\varepsilon}\\right),\n$$\n其中 $x_L = 0.3$，$x_R = 0.7$，将在最终时刻的界面区域总长度近似为集合 $\\{x: |\\phi(x,t_{\\text{final}})|  0.9\\}$ 的测度，并在网格上进行计算。将此长度除以 $2$（因为有两个界面）以获得单个界面的宽度估计，然后用 $\\varepsilon$ 进行归一化，得到无量纲的宽度比。对于精细解析的界面，该比率预计近似恒定；当界面随着 $\\varepsilon/h \\to 0$（其中 $h$ 是网格尺寸）而钉扎到网格上时，该比率会下降；而过度的人工扩散会使其增加。\n\n使用以下时间步进和网格参数作为测试套件，在 $[0,1]$ 上采用周期性边界条件，稳定化参数 $s$ 设置为固定值：\n\n- 测试用例 1（精细解析的界面）：$(N, \\varepsilon, \\Delta t, n_{\\mathrm{steps}}) = (256, 0.05, 2\\times 10^{-4}, 60)$。\n- 测试用例 2（中等解析的界面）：$(N, \\varepsilon, \\Delta t, n_{\\mathrm{steps}}) = (256, 0.01, 2\\times 10^{-4}, 60)$。\n- 测试用例 3（易于钉扎的解析不足的界面）：$(N, \\varepsilon, \\Delta t, n_{\\mathrm{steps}}) = (256, 0.002, 2\\times 10^{-4}, 60)$。\n\n对于每个测试用例，运行离散化直到指定的最终时刻，并计算：\n- 最终时刻的归一化单个界面宽度比，如上定义，为一个浮点数。\n- 最终时刻的最小单元迁移率，为一个浮点数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容按测试用例排序，每个测试用例包含两个浮点数，顺序为 $[\\text{width\\_ratio}_1,\\text{min\\_mobility}_1,\\text{width\\_ratio}_2,\\text{min\\_mobility}_2,\\text{width\\_ratio}_3,\\text{min\\_mobility}_3]$。此问题中没有物理单位；所有量均为无量纲。不涉及角度。所有数字均表示为标准十进制浮点数，不带百分号。",
            "solution": "该问题要求为一维周期域上的具有退化迁移率的 Cahn-Hilliard 方程设计并实现一个基于有限元的数值格式。目标是模拟相演化，并计算与迁移率保持和界面钉扎相关的特定诊断量。\n\n控制 Cahn-Hilliard 方程组由以下公式给出：\n$$\n\\partial_t \\phi = \\partial_x \\left( M(\\phi)\\, \\partial_x \\mu \\right)\n$$\n$$\n\\mu = -\\varepsilon^2 \\partial_{xx} \\phi + W'(\\phi)\n$$\n其中 $\\phi(x,t)$ 是相场变量，$\\mu(x,t)$ 是化学势，$\\varepsilon$ 是界面宽度参数，$W(\\phi) = \\frac{1}{4}(\\phi^2-1)^2$ 是双阱势，而 $M(\\phi) = (1-\\phi^2)_+$ 是退化迁移率。区域为 $[0,1]$，具有周期性边界条件。\n\n首先，我们推导弱形式。我们将方程乘以合适的测试函数，第一个方程乘以 $v(x)$，第二个方程乘以 $q(x)$，并在区域 $[0,1]$ 上积分。利用分部积分和周期性边界条件（这会使边界项消失），我们得到：\n$$\n\\int_0^1 \\partial_t \\phi \\, v \\, dx = - \\int_0^1 M(\\phi) (\\partial_x \\mu) (\\partial_x v) \\, dx\n$$\n$$\n\\int_0^1 \\mu \\, q \\, dx = \\varepsilon^2 \\int_0^1 (\\partial_x \\phi) (\\partial_x q) \\, dx + \\int_0^1 W'(\\phi) \\, q \\, dx\n$$\n\n我们使用连续分片线性（P1）有限元在具有 $N$ 个节点 $x_j=j h$（其中 $j=0, \\ldots, N-1$，网格尺寸 $h=1/N$）的均匀网格上进行空间离散化。解 $\\phi(x,t)$ 被近似为 $\\phi_h(x,t) = \\sum_{j=0}^{N-1} \\phi_j(t) N_j(x)$，其中 $N_j(x)$ 是 P1 基函数（帽函数）。我们将此展开应用于 $\\phi$、$\\mu$ 以及测试函数 $v, q$。问题指定使用质量集中，它将质量矩阵 $\\mathbf{M}$（其元素为 $M_{ij} = \\int_0^1 N_i N_j dx$）对角化。对于均匀的一维网格，集中质量矩阵为 $\\mathbf{M}_{\\text{lump}} = h \\mathbf{I}$，其中 $\\mathbf{I}$ 是单位矩阵。\n\n空间离散化导出一个常微分方程组（ODEs）：\n$$\nh \\frac{d\\boldsymbol{\\phi}}{dt} = -\\mathbf{K}_M \\boldsymbol{\\mu}\n$$\n$$\nh \\boldsymbol{\\mu} = \\varepsilon^2 \\mathbf{K} \\boldsymbol{\\phi} + h \\mathbf{W}'(\\boldsymbol{\\phi})\n$$\n其中 $\\boldsymbol{\\phi}(t)$ 和 $\\boldsymbol{\\mu}(t)$ 是节点值的向量。\n刚度矩阵 $\\mathbf{K}$ 的元素为 $K_{ij} = \\int_0^1 N_i'(x) N_j'(x) dx$。对于均匀周期性网格，它是一个对称、循环、三对角矩阵，其模板为 $\\frac{1}{h}[-1, 2, -1]$。\n迁移率加权刚度矩阵 $\\mathbf{K}_M$ 按规定组装。迁移率 $M(\\phi)$ 在节点处计算，即 $M_j = M(\\phi_j)$。在每个单元（边）$[x_j, x_{j+1}]$ 上，迁移率由常数算术平均值 $M_{j+1/2} = (M_j + M_{j+1})/2$ 近似。矩阵元素为 $(\\mathbf{K}_M)_{ij} = \\int_0^1 M_h(x) N_i'(x) N_j'(x) dx$，其中 $M_h(x)$ 是分片常数近似。这将产生一个对称、循环、三对角矩阵，其元素依赖于节点迁移率值。例如，对角元素 $(\\mathbf{K}_M)_{jj}$ 是 $\\frac{1}{h}(M_{j-1/2} + M_{j+1/2})$，非对角元素 $(\\mathbf{K}_M)_{j,j+1}$ 是 $-\\frac{1}{h}M_{j+1/2}$。由于 $M(\\phi) \\ge 0$，$\\mathbf{K}_M$ 是对称半正定的。向量 $\\mathbf{W}'(\\boldsymbol{\\phi})$ 包含势函数导数的节点值，$W'(\\phi_j) = \\phi_j^3 - \\phi_j$。\n\n对于时间离散化，我们使用指定的线性半隐式格式。涉及 $\\varepsilon^2$ 的高度刚性项被隐式处理，而非线性势项 $W'(\\phi)$ 则被显式处理。添加一个稳定项 $s(\\phi^{n+1}-\\phi^n)$。必须为稳定化参数 $s$ 选择一个合适的值。势函数 $W(\\phi)$ 是一个凸部和一个凹部的和。通过添加和减去一个二次项 $\\frac{s}{2}\\phi^2$，该格式针对凹部进行了稳定化处理。该格式的稳定性通常要求在 $\\phi$ 的相关范围内 $s \\ge \\max|W''(\\phi)|$。由于 $W''(\\phi) = 3\\phi^2 - 1$，其最小值为 $-1$（在 $\\phi=0$ 处）。因此，选择 $s=1.0$ 足以确保线性稳定性。从时间 $t_n$ 到 $t_{n+1}=t_n+\\Delta t$ 的最终时间推进格式为：\n$$\nh \\frac{\\boldsymbol{\\phi}^{n+1} - \\boldsymbol{\\phi}^n}{\\Delta t} = - \\mathbf{K}_{M^n} \\boldsymbol{\\mu}^{n+1}\n$$\n$$\nh \\boldsymbol{\\mu}^{n+1} = \\varepsilon^2 \\mathbf{K} \\boldsymbol{\\phi}^{n+1} + h \\mathbf{W}'(\\boldsymbol{\\phi}^n) + s h(\\boldsymbol{\\phi}^{n+1} - \\boldsymbol{\\phi}^n)\n$$\n其中 $\\mathbf{K}_{M^n}$ 是使用 $\\boldsymbol{\\phi}^n$ 计算的迁移率矩阵。\n\n我们通过结合这两个方程来求解 $\\boldsymbol{\\phi}^{n+1}$。首先，我们从第二个方程中表示出 $\\boldsymbol{\\mu}^{n+1}$：\n$$\n\\boldsymbol{\\mu}^{n+1} = \\left(\\frac{\\varepsilon^2}{h}\\mathbf{K} + s\\mathbf{I}\\right) \\boldsymbol{\\phi}^{n+1} + \\left(\\mathbf{W}'(\\boldsymbol{\\phi}^n) - s\\boldsymbol{\\phi}^n\\right)\n$$\n将此代入第一个方程，得到：\n$$\nh \\frac{\\boldsymbol{\\phi}^{n+1} - \\boldsymbol{\\phi}^n}{\\Delta t} = - \\mathbf{K}_{M^n} \\left[ \\left(\\frac{\\varepsilon^2}{h}\\mathbf{K} + s\\mathbf{I}\\right) \\boldsymbol{\\phi}^{n+1} + \\left(\\mathbf{W}'(\\boldsymbol{\\phi}^n) - s\\boldsymbol{\\phi}^n\\right) \\right]\n$$\n重新整理该方程，得到一个形式为 $\\mathbf{A} \\boldsymbol{\\phi}^{n+1} = \\mathbf{b}$ 的线性系统：\n$$\n\\left( h\\mathbf{I} + \\frac{\\Delta t \\varepsilon^2}{h} \\mathbf{K}_{M^n} \\mathbf{K} + s \\Delta t \\mathbf{K}_{M^n} \\right) \\boldsymbol{\\phi}^{n+1} = h\\boldsymbol{\\phi}^n - \\Delta t \\mathbf{K}_{M^n} \\left( \\mathbf{W}'(\\boldsymbol{\\phi}^n) - s\\boldsymbol{\\phi}^n \\right)\n$$\n系统矩阵 $\\mathbf{A} = h\\mathbf{I} + \\frac{\\Delta t \\varepsilon^2}{h} \\mathbf{K}_{M^n} \\mathbf{K} + s \\Delta t \\mathbf{K}_{M^n}$ 是一个稀疏的五对角矩阵，由于周期性，还带有额外的角点元素。右端向量为 $\\mathbf{b} = h\\boldsymbol{\\phi}^n - \\Delta t \\mathbf{K}_{M^n} \\left( \\mathbf{W}'(\\boldsymbol{\\phi}^n) - s\\boldsymbol{\\phi}^n \\right)$。在每个时间步，这个线性系统被组装并求解以得到 $\\boldsymbol{\\phi}^{n+1}$。\n\n在运行了指定步数的模拟之后，我们从最终状态 $\\boldsymbol{\\phi}_{\\text{final}}$ 计算两个所需的诊断量：\n1.  最小单元迁移率：首先，计算节点迁移率 $M_j = (1-\\phi_j^2)_+$。然后，对于每个单元/边 $j$（从 $0$ 到 $N-1$），计算平均迁移率 $M_{j+1/2} = (M_j + M_{j+1})/2$（为了周期性，取 $M_N=M_0$）。最小单元迁移率是所有这些平均值中的最小值。\n2.  归一化的单个界面宽度比：我们将界面区域定义为点集 $\\{x: |\\phi(x,t_{\\text{final}})|  0.9\\}$。在离散网格上，其总长度近似为 $L_{\\text{int}} = h \\times (\\text{节点 } j \\text{ 的数量，其中 } |\\phi_j|  0.9)$。由于初始条件创建了两个界面，因此每个界面的宽度为 $W_{\\text{int}} = L_{\\text{int}}/2$。最终的归一化比率是该宽度除以参数 $\\varepsilon$，即 $W_{\\text{int}}/\\varepsilon$。\n\n该实现将使用 `scipy.sparse` 的稀疏矩阵表示来高效地构建和处理矩阵 $\\mathbf{K}$、$\\mathbf{K}_{M^n}$ 和 $\\mathbf{A}$，并使用 `scipy.sparse.linalg.spsolve` 在每个时间步求解线性系统。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags, identity\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the Cahn-Hilliard equation with degenerate mobility using a\n    semi-implicit finite element method and computes specified diagnostics.\n    \"\"\"\n    test_cases = [\n        # (N, epsilon, dt, n_steps)\n        (256, 0.05, 2e-4, 60),\n        (256, 0.01, 2e-4, 60),\n        (256, 0.002, 2e-4, 60),\n    ]\n\n    # Parameters from the problem statement\n    x_L = 0.3\n    x_R = 0.7\n    s = 1.0  # Stabilization parameter, chosen as per the theory\n\n    results = []\n\n    for N, eps, dt, n_steps in test_cases:\n        h = 1.0 / N\n        x = np.linspace(0, 1, N, endpoint=False)\n\n        # Initial condition\n        arg1 = (x - x_L) / (np.sqrt(2.0) * eps)\n        arg2 = (x - x_R) / (np.sqrt(2.0) * eps)\n        phi = -np.tanh(arg1) * np.tanh(arg2)\n\n        # Stiffness matrix K (circulant tridiagonal for periodic BCs)\n        # Corresponds to operator -d^2/dx^2, weak form gives K_ij = int(N_i' N_j')\n        diag_K = np.full(N, 2.0 / h)\n        off_diag_K = np.full(N - 1, -1.0 / h)\n        K = diags([off_diag_K, diag_K, off_diag_K], [-1, 0, 1], shape=(N, N), format='csc')\n        K[0, N - 1] = -1.0 / h\n        K[N - 1, 0] = -1.0 / h\n\n        # Time stepping loop\n        for _ in range(n_steps):\n            # Compute nonlinear potential term W'(phi) = phi^3 - phi\n            w_prime = phi**3 - phi\n\n            # Compute nodal mobilities M(phi) = (1 - phi^2)_+\n            m_nodes = np.maximum(0, 1.0 - phi**2)\n\n            # Assemble mobility-weighted stiffness matrix KM\n            # Average mobility on edges\n            m_edges = (m_nodes + np.roll(m_nodes, -1)) / 2.0\n            \n            diag_KM = (m_edges + np.roll(m_edges, 1)) / h\n            off_diag_KM = -m_edges[:-1] / h\n            \n            KM = diags([off_diag_KM, diag_KM, off_diag_KM], [-1, 0, 1], shape=(N, N), format='csc')\n            KM[0, N - 1] = -m_edges[-1] / h\n            KM[N - 1, 0] = -m_edges[-1] / h\n            \n            # Assemble the linear system A * phi_new = b\n            # A = h*I + (dt*eps^2/h)*KM*K + s*dt*KM\n            # b = h*phi - dt*KM*(w_prime - s*phi)\n            \n            A = (h * identity(N, format='csc') +\n                 (dt * eps**2 / h) * (KM @ K) +\n                 (s * dt) * KM)\n            \n            rhs_term = w_prime - s * phi\n            b = h * phi - dt * (KM @ rhs_term)\n\n            # Solve for the next time step\n            phi = spsolve(A, b)\n\n        # Post-processing: compute diagnostics at final time\n        phi_final = phi\n\n        # 1. Minimal element mobility\n        m_nodes_final = np.maximum(0, 1.0 - phi_final**2)\n        m_edges_final = (m_nodes_final + np.roll(m_nodes_final, -1)) / 2.0\n        min_mobility = np.min(m_edges_final)\n\n        # 2. Normalized per-interface width ratio\n        # Number of nodes where |phi|  0.9\n        interface_nodes_count = np.sum(np.abs(phi_final)  0.9)\n        total_interface_length = interface_nodes_count * h\n        # Two interfaces are present\n        width_per_interface = total_interface_length / 2.0\n        width_ratio = width_per_interface / eps\n\n        results.extend([width_ratio, min_mobility])\n\n    # Format the final output string\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}