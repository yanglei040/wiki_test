{
    "hands_on_practices": [
        {
            "introduction": "Before writing a single line of code, it is crucial to understand the stability properties of the numerical scheme you intend to use. Phase-field equations are stiff, and the Implicit-Explicit (IMEX) schemes used to solve them require careful design to avoid numerical blow-up. This foundational exercise guides you through a von Neumann stability analysis to determine the minimal stabilization parameter $\\alpha$ needed to ensure an IMEX scheme for the Allen-Cahn equation is unconditionally stable, a core theoretical skill for any practitioner in the field .",
            "id": "3430555",
            "problem": "Consider the Allen–Cahn equation, a gradient flow for the Ginzburg–Landau energy, given by the partial differential equation\n$$\n\\frac{\\partial \\phi}{\\partial t} \\;=\\; -\\,\\epsilon^{2}\\,\\Delta \\phi \\;-\\; W'(\\phi),\n$$\non a periodic domain in $d$ dimensions, where $\\epsilon0$, $\\Delta$ is the Laplacian, and $W(\\phi)$ is a smooth double-well potential. A stabilized first-order Implicit–Explicit (IMEX) time discretization is defined by\n$$\n\\frac{\\phi^{n+1}-\\phi^{n}}{\\Delta t} \\;=\\; -\\,\\epsilon^{2}\\,\\Delta \\phi^{n+1} \\;-\\; \\Big( W'(\\phi^{n}) \\;+\\; \\alpha\\big(\\phi^{n+1}-\\phi^{n}\\big) \\Big),\n$$\nwhere $\\Delta t0$ is the time step and $\\alpha\\ge 0$ is a constant linear stabilization parameter. Take the double-well potential\n$$\nW(\\phi) \\;=\\; \\frac{1}{4}\\big(\\phi^{2}-1\\big)^{2}.\n$$\nAssume a homogeneous equilibrium $\\bar{\\phi}$ for which $W'(\\bar{\\phi})=0$, and consider small perturbations $\\eta^{n}$ defined by $\\phi^{n}=\\bar{\\phi}+\\eta^{n}$. Perform a von Neumann analysis of the resulting linearized update for the spatially uniform Fourier mode (i.e., wavenumber $\\boldsymbol{k}=\\boldsymbol{0}$) and require unconditional stability with respect to the time step, meaning that the magnitude of the amplification factor for this mode is less than or equal to $1$ for all $\\Delta t0$. Determine the minimal value of the stabilization parameter $\\alpha$ that achieves this, evaluated at a stable homogeneous equilibrium of $W(\\phi)$.\n\nYour final answer must be a single real number. No units are required.",
            "solution": "The problem as stated is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. It is a standard problem in the numerical analysis of phase-field models. Therefore, the problem is deemed valid and a full solution is warranted.\n\nThe primary task is to determine the minimal stabilization parameter $\\alpha$ that ensures unconditional stability for the spatially uniform Fourier mode (wavenumber $\\boldsymbol{k}=\\boldsymbol{0}$) of the given Implicit-Explicit (IMEX) scheme for the Allen-Cahn equation.\n\nThe Allen-Cahn equation is given as:\n$$\n\\frac{\\partial \\phi}{\\partial t} = -\\epsilon^{2}\\Delta \\phi - W'(\\phi)\n$$\nThe provided IMEX time discretization is:\n$$\n\\frac{\\phi^{n+1}-\\phi^{n}}{\\Delta t} = -\\epsilon^{2}\\Delta \\phi^{n+1} - \\Big( W'(\\phi^{n}) + \\alpha(\\phi^{n+1}-\\phi^{n}) \\Big)\n$$\nThe analysis is restricted to the spatially uniform Fourier mode, corresponding to wavenumber $\\boldsymbol{k}=\\boldsymbol{0}$. For this mode, any spatial dependence vanishes, and the field $\\phi$ is simply a function of time. Consequently, the Laplacian term $\\Delta\\phi$ is zero. The PDE and the numerical scheme simplify significantly for this mode. The term $-\\epsilon^{2}\\Delta \\phi^{n+1}$ in the scheme becomes zero. Thus, the analysis is independent of the sign of the Laplacian term, which is unusual for an Allen-Cahn equation but irrelevant for the question posed.\n\nFor the $\\boldsymbol{k}=\\boldsymbol{0}$ mode, the scheme reduces to an ordinary difference equation:\n$$\n\\frac{\\phi^{n+1}-\\phi^{n}}{\\Delta t} = -W'(\\phi^{n}) - \\alpha(\\phi^{n+1}-\\phi^{n})\n$$\nWe perform a linear stability analysis around a homogeneous equilibrium $\\bar{\\phi}$, which satisfies $W'(\\bar{\\phi})=0$. We introduce a small perturbation $\\eta^{n}$ such that $\\phi^{n} = \\bar{\\phi} + \\eta^{n}$. Substituting this into the simplified scheme gives:\n$$\n\\frac{(\\bar{\\phi}+\\eta^{n+1}) - (\\bar{\\phi}+\\eta^{n})}{\\Delta t} = -W'(\\bar{\\phi}+\\eta^{n}) - \\alpha\\big((\\bar{\\phi}+\\eta^{n+1}) - (\\bar{\\phi}+\\eta^{n})\\big)\n$$\n$$\n\\frac{\\eta^{n+1}-\\eta^{n}}{\\Delta t} = -W'(\\bar{\\phi}+\\eta^{n}) - \\alpha(\\eta^{n+1}-\\eta^{n})\n$$\nWe linearize the term $W'(\\bar{\\phi}+\\eta^{n})$ by performing a Taylor expansion around $\\bar{\\phi}$ and retaining only the first-order term in $\\eta^{n}$:\n$$\nW'(\\bar{\\phi}+\\eta^{n}) \\approx W'(\\bar{\\phi}) + W''(\\bar{\\phi})\\eta^{n}\n$$\nSince $W'(\\bar{\\phi})=0$ at equilibrium, this simplifies to $W'(\\bar{\\phi}+\\eta^{n}) \\approx W''(\\bar{\\phi})\\eta^{n}$. The linearized update for the perturbation is:\n$$\n\\frac{\\eta^{n+1}-\\eta^{n}}{\\Delta t} = -W''(\\bar{\\phi})\\eta^{n} - \\alpha(\\eta^{n+1}-\\eta^{n})\n$$\nTo find the amplification factor $G = \\eta^{n+1}/\\eta^{n}$, we rearrange the equation to solve for $\\eta^{n+1}$:\n$$\n\\eta^{n+1}\\left(\\frac{1}{\\Delta t} + \\alpha\\right) = \\eta^{n}\\left(\\frac{1}{\\Delta t} + \\alpha - W''(\\bar{\\phi})\\right)\n$$\nMultiplying by $\\Delta t$ yields:\n$$\n\\eta^{n+1}(1 + \\alpha\\Delta t) = \\eta^{n}(1 + \\alpha\\Delta t - W''(\\bar{\\phi})\\Delta t)\n$$\nThe amplification factor $G$ is therefore:\n$$\nG(\\Delta t) = \\frac{\\eta^{n+1}}{\\eta^{n}} = \\frac{1 + (\\alpha - W''(\\bar{\\phi}))\\Delta t}{1 + \\alpha\\Delta t} = 1 - \\frac{W''(\\bar{\\phi})\\Delta t}{1 + \\alpha\\Delta t}\n$$\nFor unconditional stability, the magnitude of the amplification factor must be less than or equal to $1$ for all time steps $\\Delta t0$. This means $|G(\\Delta t)| \\le 1$, which is equivalent to the two inequalities:\n$$\n-1 \\le 1 - \\frac{W''(\\bar{\\phi})\\Delta t}{1 + \\alpha\\Delta t} \\le 1\n$$\nFirst, consider the right inequality:\n$$\n1 - \\frac{W''(\\bar{\\phi})\\Delta t}{1 + \\alpha\\Delta t} \\le 1 \\quad \\implies \\quad -\\frac{W''(\\bar{\\phi})\\Delta t}{1 + \\alpha\\Delta t} \\le 0\n$$\nSince $\\Delta t  0$ and $\\alpha \\ge 0$, the denominator $1+\\alpha\\Delta t$ is strictly positive. Thus, this inequality simplifies to $-W''(\\bar{\\phi}) \\le 0$, or $W''(\\bar{\\phi}) \\ge 0$. This is the condition for the equilibrium $\\bar{\\phi}$ to be linearly stable in the original continuous problem $\\frac{d\\phi}{dt}=-W'(\\phi)$. The problem specifies analysis at a stable equilibrium, so this condition is satisfied.\n\nNext, consider the left inequality:\n$$\n-1 \\le 1 - \\frac{W''(\\bar{\\phi})\\Delta t}{1 + \\alpha\\Delta t} \\quad \\implies \\quad \\frac{W''(\\bar{\\phi})\\Delta t}{1 + \\alpha\\Delta t} \\le 2\n$$\nSince $1+\\alpha\\Delta t  0$, we can multiply both sides by it:\n$$\nW''(\\bar{\\phi})\\Delta t \\le 2(1 + \\alpha\\Delta t) = 2 + 2\\alpha\\Delta t\n$$\nRearranging the terms:\n$$\n(W''(\\bar{\\phi}) - 2\\alpha)\\Delta t \\le 2\n$$\nThis inequality must hold for all $\\Delta t  0$. If the coefficient of $\\Delta t$, which is $(W''(\\bar{\\phi}) - 2\\alpha)$, were positive, then the left side would grow linearly with $\\Delta t$ and would eventually violate the inequality for a sufficiently large $\\Delta t$. Therefore, to ensure the inequality holds for all $\\Delta t  0$, the coefficient must be non-positive:\n$$\nW''(\\bar{\\phi}) - 2\\alpha \\le 0 \\quad \\implies \\quad \\alpha \\ge \\frac{1}{2}W''(\\bar{\\phi})\n$$\nThis gives the condition on the stabilization parameter $\\alpha$ for unconditional stability. The minimal value of $\\alpha$ is thus $\\alpha_{\\min} = \\frac{1}{2}W''(\\bar{\\phi})$.\n\nNow, we must evaluate this at a stable homogeneous equilibrium of the given potential $W(\\phi) = \\frac{1}{4}(\\phi^{2}-1)^{2}$.\nFirst, we find the equilibria by solving $W'(\\phi)=0$:\n$$\nW'(\\phi) = \\frac{d}{d\\phi}\\left(\\frac{1}{4}(\\phi^{2}-1)^{2}\\right) = \\frac{1}{4} \\cdot 2(\\phi^{2}-1) \\cdot (2\\phi) = \\phi(\\phi^{2}-1)\n$$\nSetting $W'(\\bar{\\phi})=0$ gives $\\bar{\\phi}(\\bar{\\phi}^{2}-1)=0$, so the equilibria are $\\bar{\\phi}=0$, $\\bar{\\phi}=1$, and $\\bar{\\phi}=-1$.\n\nNext, we determine the stability of these equilibria by examining the sign of the second derivative, $W''(\\phi)$:\n$$\nW''(\\phi) = \\frac{d}{d\\phi}(\\phi^{3}-\\phi) = 3\\phi^{2}-1\n$$\n- At $\\bar{\\phi}=0$: $W''(0) = 3(0)^{2}-1 = -1$. Since $W''(0)0$, this is an unstable equilibrium.\n- At $\\bar{\\phi}=1$: $W''(1) = 3(1)^{2}-1 = 2$. Since $W''(1)0$, this is a stable equilibrium.\n- At $\\bar{\\phi}=-1$: $W''(-1) = 3(-1)^{2}-1 = 2$. Since $W''(-1)0$, this is also a stable equilibrium.\n\nThe problem requires evaluation at a stable homogeneous equilibrium. We can choose either $\\bar{\\phi}=1$ or $\\bar{\\phi}=-1$. In both cases, $W''(\\bar{\\phi}) = 2$.\nSubstituting this value into the expression for the minimal $\\alpha$:\n$$\n\\alpha_{\\min} = \\frac{1}{2}W''(\\bar{\\phi}) = \\frac{1}{2}(2) = 1\n$$\nTherefore, the minimal value of the stabilization parameter $\\alpha$ that ensures unconditional stability for the spatially uniform mode at a stable equilibrium is $1$.",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "A working simulation begins with correctly implemented mathematical operators. This practice introduces a gold-standard technique, the Method of Manufactured Solutions (MMS), for rigorously verifying your code. You will derive the analytical source terms that force a chosen \"manufactured\" function to be an exact solution to the Allen-Cahn and Cahn-Hilliard equations, and then use these terms to precisely quantify the error of your discrete spatial operators, ensuring your implementation is verifiably correct before you move on to physical simulations .",
            "id": "3430574",
            "problem": "You are asked to design, derive, and implement a numerical code-verification experiment for phase-field interface evolution equations using the Method of Manufactured Solutions (MMS). The target equations are the Allen–Cahn equation and the Cahn–Hilliard equation, two standard phase-field models derived as gradient flows of the Ginzburg–Landau free energy. Your task is to start from fundamental definitions of the equations, derive the forcing functions that make a manufactured field an exact solution of the resulting forced equations, and then quantify the spatial discretization error of a second-order central-difference operator on a periodic domain by measuring the residuals that remain when the exact forcing is inserted into the discretized equations.\n\nThe governing equations are, for a scalar order parameter field $\\,\\phi(x,t)\\,$ on the one-dimensional periodic domain $\\,x\\in[0,1]\\,$ with period $\\,1\\,$:\n\n- Allen–Cahn (AC) equation with an added source $\\,S_{\\mathrm{AC}}(x,t)\\,$:\n$$\n\\partial_t \\phi \\;=\\; \\varepsilon^2 \\,\\partial_{xx}\\phi \\;-\\; W'(\\phi)\\;+\\; S_{\\mathrm{AC}}(x,t),\n$$\n- Cahn–Hilliard (CH) equation with an added source $\\,S_{\\mathrm{CH}}(x,t)\\,$, written in the equivalent fourth-order form with constant mobility $\\,M=1\\,$:\n$$\n\\partial_t \\phi \\;=\\; -\\,\\varepsilon^2\\,\\partial_{xxxx}\\phi \\;+\\;\\partial_{xx}\\!\\big(W'(\\phi)\\big)\\;+\\; S_{\\mathrm{CH}}(x,t).\n$$\n\nHere $\\,\\varepsilon0\\,$ is the diffuse-interface thickness parameter, $\\,W(\\phi)\\,$ is the classical double-well potential\n$$\nW(\\phi) \\;=\\; \\tfrac{1}{4}\\,\\big(\\phi^2-1\\big)^2,\n$$\nand hence\n$$\nW'(\\phi) \\;=\\; \\phi^3\\;-\\;\\phi.\n$$\n\nAdopt the following manufactured smooth solution with mixed spatial and temporal frequencies:\n$$\n\\phi(x,t) \\;=\\; A\\,\\cos\\!\\big(2\\pi k\\,x\\big)\\,\\cos\\!\\big(\\omega\\,t\\big)\\;+\\; B\\,\\sin\\!\\big(2\\pi q\\,x\\big)\\,\\sin\\!\\big(\\omega\\,t\\big),\n$$\nwhere the constants are $\\,A=0.6\\,$, $\\,B=0.2\\,$, $\\,k=1\\,$, $\\,q=2\\,$, and $\\,\\omega=1.7\\,$. The spatial domain is periodic with period $\\,1\\,$, and all derivatives with respect to $\\,x\\,$ should satisfy periodic boundary conditions. Fix the evaluation time at $\\,t_0=0.37\\,$.\n\nTask 1 (derivation from first principles): Using the Method of Manufactured Solutions (MMS), derive the source terms $\\,S_{\\mathrm{AC}}(x,t)\\,$ and $\\,S_{\\mathrm{CH}}(x,t)\\,$ so that the above $\\,\\phi(x,t)\\,$ is an exact solution of the respective forced equations. Your starting point must be the given governing equations and the chain rule, together with exact spatial and temporal derivatives of the manufactured field. You must express $\\,S_{\\mathrm{AC}}(x,t)\\,$ and $\\,S_{\\mathrm{CH}}(x,t)\\,$ entirely in terms of $\\,\\phi\\,$ and its exact derivatives, and $\\,W'(\\phi)\\,$, without introducing any discretization at this stage.\n\nTask 2 (discrete residual design for verification): Consider a uniform grid with $\\,N\\,$ points on $\\,x\\in[0,1]\\,$ with grid spacing $\\,\\Delta x = 1/N\\,$, and let $\\,x_i=i\\,\\Delta x\\,$ for $\\,i=0,1,\\dots,N-1\\,$. Define the second-order central-difference approximation to the second derivative with periodic boundary conditions:\n$$\n\\mathcal{D}_2[\\psi]_i \\;=\\; \\frac{\\psi_{i-1} - 2\\,\\psi_i + \\psi_{i+1}}{(\\Delta x)^2},\n$$\nwhere indices are taken modulo $\\,N\\,$. Define the corresponding discrete fourth derivative as $\\,\\mathcal{D}_4[\\psi]\\equiv \\mathcal{D}_2\\!\\big[\\mathcal{D}_2[\\psi]\\big]\\,$. The discrete verification residuals at each grid point $\\,x_i\\,$ are then defined as follows:\n\n- For the Allen–Cahn case,\n$$\n\\mathcal{R}_{\\mathrm{AC},i} \\;=\\; \\big(\\partial_t\\phi\\big)(x_i,t_0)\\;-\\;\\Big(\\varepsilon^2\\,\\mathcal{D}_2[\\phi]_i \\;-\\; W'\\big(\\phi(x_i,t_0)\\big) \\;+\\; S_{\\mathrm{AC}}(x_i,t_0)\\Big).\n$$\n\n- For the Cahn–Hilliard case (using the fourth-order form),\n$$\n\\mathcal{R}_{\\mathrm{CH},i} \\;=\\; \\big(\\partial_t\\phi\\big)(x_i,t_0)\\;-\\;\\Big(\\,-\\varepsilon^2\\,\\mathcal{D}_4[\\phi]_i \\;+\\; \\mathcal{D}_2\\big[W'(\\phi)\\big]_i \\;+\\; S_{\\mathrm{CH}}(x_i,t_0)\\Big).\n$$\n\nBecause the sources are derived with exact derivatives but the residual uses discrete spatial operators, the nonzero residual directly measures the spatial discretization error. Quantify this error with the discrete $\\,L^2\\,$ norm on $[0,1]$,\n$$\n\\|\\mathcal{R}\\|_{L^2_h} \\;=\\; \\sqrt{\\,\\sum_{i=0}^{N-1} \\big(\\mathcal{R}_i\\big)^2\\,\\Delta x\\,}.\n$$\n\nTask 3 (implementation and test suite): Implement a program that\n- evaluates $\\,\\phi(x_i,t_0)\\,$ and its exact derivatives needed for $\\,S_{\\mathrm{AC}}\\,$ and $\\,S_{\\mathrm{CH}}\\,$,\n- constructs the discrete operators $\\,\\mathcal{D}_2\\,$ and $\\,\\mathcal{D}_4\\,$ with periodic boundary conditions,\n- forms the discrete residuals $\\,\\mathcal{R}_{\\mathrm{AC}}\\,$ and $\\,\\mathcal{R}_{\\mathrm{CH}}\\,$ at time $\\,t_0\\,$, and\n- returns the discrete $\\,L^2\\,$ norms for each specified test case.\n\nUse the following four test cases, each defined by the tuple $\\,(\\text{equation},\\,N,\\,\\varepsilon)\\,$ with the manufactured constants $\\,A=0.6\\,$, $\\,B=0.2\\,$, $\\,k=1\\,$, $\\,q=2\\,$, $\\,\\omega=1.7\\,$, and $\\,t_0=0.37\\,$ as above:\n\n- Test $\\,1\\,$: $\\,(\\text{AC},\\,N=64,\\,\\varepsilon=0.05)\\,$,\n- Test $\\,2\\,$: $\\,(\\text{AC},\\,N=128,\\,\\varepsilon=0.05)\\,$,\n- Test $\\,3\\,$: $\\,(\\text{CH},\\,N=64,\\,\\varepsilon=0.03)\\,$,\n- Test $\\,4\\,$: $\\,(\\text{CH},\\,N=128,\\,\\varepsilon=0.03)\\,$.\n\nYour program should produce a single line of output containing the four residual norms as a comma-separated list enclosed in square brackets (e.g., $[\\text{r}_1,\\text{r}_2,\\text{r}_3,\\text{r}_4]$). Each entry must be a floating-point number. No user input is allowed, and no external files may be read or written. The domain length is nondimensional and equal to $\\,1\\,$, so no physical units are required in the answer. Angles are implicitly in radians via the trigonometric functions.",
            "solution": "The problem is valid. It is a well-posed, scientifically grounded, and objective problem in the field of numerical analysis for partial differential equations. It asks for the derivation and implementation of a code verification test for the Allen–Cahn and Cahn–Hilliard equations using the standard Method of Manufactured Solutions (MMS). All necessary information is provided, and the tasks are clearly defined.\n\nThe solution proceeds in two stages as requested. First, we perform the analytical derivations for the source terms and the resulting discrete residuals. Second, we implement these derivations in a Python program to compute the specified residual norms.\n\n### Task 1: Derivation of Source Terms\n\nThe Method of Manufactured Solutions (MMS) involves positing a smooth analytical function as an exact solution to a modified version of the governing partial differential equation (PDE). The modification consists of adding a source term, which is derived by substituting the manufactured solution into the original PDE.\n\nThe given manufactured solution is:\n$$\n\\phi(x,t) \\;=\\; A\\,\\cos\\!\\big(2\\pi k\\,x\\big)\\,\\cos\\!\\big(\\omega\\,t\\big)\\;+\\; B\\,\\sin\\!\\big(2\\pi q\\,x\\big)\\,\\sin\\!\\big(\\omega\\,t\\big)\n$$\nwith constants $A=0.6$, $B=0.2$, $k=1$, $q=2$, and $\\omega=1.7$. The potential is $W(\\phi) = \\tfrac{1}{4}(\\phi^2-1)^2$, with derivative $W'(\\phi) = \\phi^3 - \\phi$.\n\nTo derive the source terms, we rearrange the governing equations to solve for $S_{\\mathrm{AC}}(x,t)$ and $S_{\\mathrm{CH}}(x,t)$, assuming $\\phi(x,t)$ is a solution.\n\n**Allen–Cahn (AC) Source Term:**\nThe forced AC equation is:\n$$\n\\partial_t \\phi \\;=\\; \\varepsilon^2 \\,\\partial_{xx}\\phi \\;-\\; W'(\\phi)\\;+\\; S_{\\mathrm{AC}}(x,t)\n$$\nSolving for the source term $S_{\\mathrm{AC}}(x,t)$ gives:\n$$\nS_{\\mathrm{AC}}(x,t) \\;=\\; \\partial_t \\phi(x,t) \\;-\\; \\varepsilon^2 \\,\\partial_{xx}\\phi(x,t) \\;+\\; W'(\\phi(x,t))\n$$\nHere, $\\partial_t \\phi$ and $\\partial_{xx}\\phi$ are the exact analytical temporal and second spatial derivatives of the manufactured solution $\\phi(x,t)$.\n\n**Cahn–Hilliard (CH) Source Term:**\nThe forced CH equation is:\n$$\n\\partial_t \\phi \\;=\\; -\\,\\varepsilon^2\\,\\partial_{xxxx}\\phi \\;+\\;\\partial_{xx}\\!\\big(W'(\\phi)\\big)\\;+\\; S_{\\mathrm{CH}}(x,t)\n$$\nSolving for the source term $S_{\\mathrm{CH}}(x,t)$ gives:\n$$\nS_{\\mathrm{CH}}(x,t) \\;=\\; \\partial_t \\phi(x,t) \\;+\\; \\varepsilon^2\\,\\partial_{xxxx}\\phi(x,t) \\;-\\; \\partial_{xx}\\!\\big(W'(\\phi(x,t))\\big)\n$$\nHere, $\\partial_t \\phi$ and $\\partial_{xxxx}\\phi$ are exact analytical derivatives of $\\phi(x,t)$. The term $\\partial_{xx}(W'(\\phi))$ is computed using the chain rule. First, the derivative of $W'(\\phi)$ with respect to $\\phi$ is $W''(\\phi) = 3\\phi^2-1$.\nThe first spatial derivative is:\n$$\n\\partial_x(W'(\\phi)) = W''(\\phi) \\, \\partial_x\\phi = (3\\phi^2-1)\\,\\partial_x\\phi\n$$\nThe second spatial derivative is:\n$$\n\\partial_{xx}(W'(\\phi)) = \\partial_x\\left( (3\\phi^2-1)\\,\\partial_x\\phi \\right) = (6\\phi\\,\\partial_x\\phi)\\,\\partial_x\\phi + (3\\phi^2-1)\\,\\partial_{xx}\\phi = 6\\phi(\\partial_x\\phi)^2 + (3\\phi^2-1)\\,\\partial_{xx}\\phi\n$$\nThese expressions for $S_{\\mathrm{AC}}$ and $S_{\\mathrm{CH}}$ are exact and defined at all points $(x,t)$.\n\n### Task 2: Discrete Residual Design\n\nThe discrete verification residual measures the extent to which the manufactured solution fails to satisfy the *discretized* governing equation when the exact source term is used. This nonzero residual is a direct measure of the discretization error of the spatial operators.\n\n**AC Residual:**\nThe definition of the AC residual at grid point $x_i$ and time $t_0$ is:\n$$\n\\mathcal{R}_{\\mathrm{AC},i} \\;=\\; \\big(\\partial_t\\phi\\big)(x_i,t_0)\\;-\\;\\Big(\\varepsilon^2\\,\\mathcal{D}_2[\\phi]_i \\;-\\; W'\\big(\\phi(x_i,t_0)\\big) \\;+\\; S_{\\mathrm{AC}}(x_i,t_0)\\Big)\n$$\nSubstituting the expression for $S_{\\mathrm{AC}}(x_i,t_0) = (\\partial_t\\phi - \\varepsilon^2\\,\\partial_{xx}\\phi + W'(\\phi))|_{x_i,t_0}$:\n$$\n\\mathcal{R}_{\\mathrm{AC},i} \\;=\\; \\partial_t\\phi \\;-\\; \\Big(\\varepsilon^2\\,\\mathcal{D}_2[\\phi]_i \\;-\\; W'(\\phi) \\;+\\; (\\partial_t\\phi - \\varepsilon^2\\,\\partial_{xx}\\phi + W'(\\phi))\\Big)\n$$\n$$\n\\mathcal{R}_{\\mathrm{AC},i} \\;=\\; \\partial_t\\phi - \\varepsilon^2\\,\\mathcal{D}_2[\\phi]_i + W'(\\phi) - \\partial_t\\phi + \\varepsilon^2\\,\\partial_{xx}\\phi - W'(\\phi)\n$$\nSimplifying, we obtain:\n$$\n\\mathcal{R}_{\\mathrm{AC},i} \\;=\\; \\varepsilon^2\\left(\\partial_{xx}\\phi(x_i,t_0) - \\mathcal{D}_2[\\phi]_i\\right)\n$$\nThis shows that the residual is precisely $\\varepsilon^2$ times the truncation error of the second-order central difference operator $\\mathcal{D}_2$ when approximating the second derivative $\\partial_{xx}\\phi$.\n\n**CH Residual:**\nThe definition of the CH residual at grid point $x_i$ and time $t_0$ is:\n$$\n\\mathcal{R}_{\\mathrm{CH},i} \\;=\\; \\big(\\partial_t\\phi\\big)(x_i,t_0)\\;-\\;\\Big(\\!-\\varepsilon^2\\,\\mathcal{D}_4[\\phi]_i \\;+\\; \\mathcal{D}_2\\big[W'(\\phi)\\big]_i \\;+\\; S_{\\mathrm{CH}}(x_i,t_0)\\Big)\n$$\nSubstitute the expression for $S_{\\mathrm{CH}}(x_i,t_0) = (\\partial_t\\phi + \\varepsilon^2\\,\\partial_{xxxx}\\phi - \\partial_{xx}(W'(\\phi)))|_{x_i,t_0}$:\n$$\n\\mathcal{R}_{\\mathrm{CH},i} \\;=\\; \\partial_t\\phi \\;-\\; \\Big(\\!-\\varepsilon^2\\,\\mathcal{D}_4[\\phi]_i \\;+\\; \\mathcal{D}_2\\big[W'(\\phi)\\big]_i \\;+\\; (\\partial_t\\phi + \\varepsilon^2\\,\\partial_{xxxx}\\phi - \\partial_{xx}(W'(\\phi)))\\Big)\n$$\n$$\n\\mathcal{R}_{\\mathrm{CH},i} \\;=\\; \\partial_t\\phi + \\varepsilon^2\\,\\mathcal{D}_4[\\phi]_i - \\mathcal{D}_2[W'(\\phi)]_i - \\partial_t\\phi - \\varepsilon^2\\,\\partial_{xxxx}\\phi + \\partial_{xx}(W'(\\phi))\n$$\nSimplifying, we obtain:\n$$\n\\mathcal{R}_{\\mathrm{CH},i} \\;=\\; \\varepsilon^2\\big(\\mathcal{D}_4[\\phi]_i - \\partial_{xxxx}\\phi(x_i, t_0)\\big) \\;+\\; \\big(\\partial_{xx}(W'(\\phi))(x_i,t_0) - \\mathcal{D}_2[W'(\\phi)]_i\\big)\n$$\nThis residual consists of two terms, each representing a truncation error. The first term is $\\varepsilon^2$ times the truncation error of the discrete biharmonic operator $\\mathcal{D}_4$. The second term is the truncation error of the discrete Laplacian $\\mathcal{D}_2$ acting on the nonlinear quantity $W'(\\phi)$. Both discrete operators $\\mathcal{D}_2$ and $\\mathcal{D}_4$ are second-order accurate, so the overall residual norm is expected to converge to zero as $O((\\Delta x)^2)$.\n\nThese simplified expressions for $\\mathcal{R}_{\\mathrm{AC},i}$ and $\\mathcal{R}_{\\mathrm{CH},i}$ will be implemented to compute the residual norms.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs, derives, and implements a code verification experiment for\n    Allen-Cahn and Cahn-Hilliard equations using MMS.\n    \"\"\"\n    # Define constants from the problem statement.\n    A = 0.6\n    B = 0.2\n    k = 1.0\n    q = 2.0\n    omega = 1.7\n    t0 = 0.37\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('AC', 64, 0.05),\n        ('AC', 128, 0.05),\n        ('CH', 64, 0.03),\n        ('CH', 128, 0.03),\n    ]\n\n    # Pre-calculate angular frequencies for efficiency\n    K = 2.0 * np.pi * k\n    Q = 2.0 * np.pi * q\n\n    # --- Analytical functions for the manufactured solution and its derivatives ---\n\n    def phi_fn(x, t):\n        \"\"\"Manufactured solution phi(x,t).\"\"\"\n        term1 = A * np.cos(K * x) * np.cos(omega * t)\n        term2 = B * np.sin(Q * x) * np.sin(omega * t)\n        return term1 + term2\n\n    def dt_phi_fn(x, t):\n        \"\"\"Temporal derivative d(phi)/dt.\"\"\"\n        term1 = -A * omega * np.cos(K * x) * np.sin(omega * t)\n        term2 = B * omega * np.sin(Q * x) * np.cos(omega * t)\n        return term1 + term2\n\n    def dx_phi_fn(x, t):\n        \"\"\"First spatial derivative d(phi)/dx.\"\"\"\n        term1 = -A * K * np.sin(K * x) * np.cos(omega * t)\n        term2 = B * Q * np.cos(Q * x) * np.sin(omega * t)\n        return term1 + term2\n\n    def dxx_phi_fn(x, t):\n        \"\"\"Second spatial derivative d^2(phi)/dx^2.\"\"\"\n        term1 = -A * K**2 * np.cos(K * x) * np.cos(omega * t)\n        term2 = -B * Q**2 * np.sin(Q * x) * np.sin(omega * t)\n        return term1 + term2\n        \n    def dxxxx_phi_fn(x, t):\n        \"\"\"Fourth spatial derivative d^4(phi)/dx^4.\"\"\"\n        term1 = A * K**4 * np.cos(K * x) * np.cos(omega * t)\n        term2 = B * Q**4 * np.sin(Q * x) * np.sin(omega * t)\n        return term1 + term2\n\n    def w_prime_fn(p):\n        \"\"\"Derivative of the double-well potential W'(phi) = phi^3 - phi.\"\"\"\n        return p**3 - p\n\n    def dxx_w_prime_fn(p, dx_p, dxx_p):\n        \"\"\"Analytical second spatial derivative of W'(phi(x,t)).\"\"\"\n        # d/dx(W'(p)) = (3p^2 - 1) * dx_p\n        # d^2/dx^2(W'(p)) = 6p*(dx_p)^2 + (3p^2 - 1)*dxx_p\n        return 6.0 * p * dx_p**2 + (3.0 * p**2 - 1.0) * dxx_p\n\n    # --- Discrete operators with periodic boundary conditions ----\n\n    def d2_op(f, dx):\n        \"\"\"Second-order central difference for the second derivative.\"\"\"\n        f_im1 = np.roll(f, 1)  # f_{i-1}\n        f_ip1 = np.roll(f, -1) # f_{i+1}\n        return (f_im1 - 2.0 * f + f_ip1) / dx**2\n\n    def d4_op(f, dx):\n        \"\"\"Second-order central difference for the fourth derivative (biharmonic).\"\"\"\n        return d2_op(d2_op(f, dx), dx)\n\n    results = []\n    for eq_type, N, eps in test_cases:\n        dx = 1.0 / N\n        x = np.arange(N) * dx  # Grid points x_i = i * dx for i=0,...,N-1\n\n        # Evaluate the manufactured solution and its derivatives on the grid at t0\n        phi_vals = phi_fn(x, t0)\n\n        if eq_type == 'AC':\n            # Calculate the AC residual: R_AC = eps^2 * (exact_dxx - discrete_dxx)\n            exact_dxx_phi = dxx_phi_fn(x, t0)\n            discrete_dxx_phi = d2_op(phi_vals, dx)\n            residual = eps**2 * (exact_dxx_phi - discrete_dxx_phi)\n        \n        elif eq_type == 'CH':\n            # Calculate CH residual: R_CH = eps^2(D4[p]-d4p) + (d2(W') - D2[W'])\n            # Term 1: Discretization error of the biharmonic operator\n            exact_dxxxx_phi = dxxxx_phi_fn(x, t0)\n            discrete_d4_phi = d4_op(phi_vals, dx)\n            term1 = eps**2 * (discrete_d4_phi - exact_dxxxx_phi)\n            \n            # Term 2: Discretization error of the Laplacian on W'(phi)\n            w_prime_vals = w_prime_fn(phi_vals)\n            discrete_d2_w_prime = d2_op(w_prime_vals, dx)\n            \n            # For exact dxx(W'), we need exact phi, dx_phi, and dxx_phi\n            dx_phi_vals = dx_phi_fn(x, t0)\n            dxx_phi_vals = dxx_phi_fn(x, t0)\n            exact_dxx_w_prime_vals = dxx_w_prime_fn(phi_vals, dx_phi_vals, dxx_phi_vals)\n            \n            term2 = exact_dxx_w_prime_vals - discrete_d2_w_prime\n            \n            residual = term1 + term2\n\n        # Calculate the discrete L2 norm of the residual\n        # ||R||_h = sqrt( sum(R_i^2 * dx) )\n        norm = np.sqrt(np.sum(residual**2) * dx)\n        results.append(norm)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "We now assemble the pieces into a powerful 2D simulator to study interface dynamics. This practice involves building a spectral solver for both the Allen-Cahn and Cahn-Hilliard equations, leveraging the efficiency of the Fast Fourier Transform on periodic domains. The focus here shifts from low-level verification to high-level physical consistency, as you will implement checks to confirm that your simulation respects the fundamental properties of gradient flows: monotonic energy decay for both equations and exact mass conservation for the Cahn-Hilliard equation .",
            "id": "3430539",
            "problem": "Implement and verify numerical solvers for phase-field interface evolution based on the Allen–Cahn and Cahn–Hilliard equations under periodic boundary conditions on a two-dimensional square domain. The implementation must be a complete, runnable program that uses a spectrally accurate spatial discretization and a first-order, stabilized, semi-implicit time discretization consistent with the gradient-flow structure. The required checks focus on consistency properties: free-energy decay for gradient flows, exact mass conservation for Cahn–Hilliard, and temporal-order estimation for the time-stepping scheme.\n\nThe fundamental base is as follows. The Allen–Cahn equation is the $L^{2}$ gradient flow of the Ginzburg–Landau energy, and the Cahn–Hilliard equation is the $H^{-1}$ gradient flow of the same energy. Let the free energy functional be\n$$\n\\mathcal{E}(u) = \\int_{\\Omega} \\left( \\frac{\\varepsilon^{2}}{2} \\lvert \\nabla u \\rvert^{2} + F(u) \\right) \\, \\mathrm{d}x,\n$$\nwith double-well potential\n$$\nF(u) = \\frac{(u^{2} - 1)^{2}}{4}.\n$$\nThe first variation gives the chemical potential\n$$\n\\mu = \\frac{\\delta \\mathcal{E}}{\\delta u} = -\\varepsilon^{2} \\Delta u + F'(u),\n\\quad F'(u) = u^{3} - u.\n$$\nThe gradient flows are\n$$\n\\text{Allen–Cahn:} \\quad \\frac{\\partial u}{\\partial t} = - M \\mu\n= \\varepsilon^{2} \\Delta u - F'(u),\n$$\n$$\n\\text{Cahn–Hilliard:} \\quad \\frac{\\partial u}{\\partial t} = \\nabla \\cdot ( M \\nabla \\mu )\n= \\Delta \\mu = -\\varepsilon^{2} \\Delta^{2} u + \\Delta F'(u),\n$$\nwhere $M$ is the mobility, set to $M=1$ for simplicity. Both problems are posed on $\\Omega = [0,L] \\times [0,L]$ with periodic boundary conditions. The spatial discretization must use the Fast Fourier Transform (FFT) with wavenumbers consistent with the domain size, and the time discretization must be first-order, stabilized, semi-implicit in the linear stiff terms and explicit in the nonlinear terms, adding a linear stabilization term with coefficient $S  0$ to ensure unconditional stability of the treated linear part without violating the gradient-flow structure.\n\nThe discrete free energy to monitor is the trapezoidal Riemann sum consistent with the spectral representation of the gradient term. Denoting by $\\widehat{u}$ the discrete Fourier transform of $u$, and using physical wavenumbers $\\boldsymbol{k} = (k_{x}, k_{y})$ with $k_{x}, k_{y} \\in \\frac{2\\pi}{L} \\mathbb{Z}$, the discrete energy must be computed as\n$$\n\\mathcal{E}_{h}(u) = \\frac{\\varepsilon^{2}}{2} \\, \\Delta x^{2} \\, \\frac{1}{N^{2}} \\sum_{\\boldsymbol{k}} \\lvert \\boldsymbol{k} \\rvert^{2} \\lvert \\widehat{u}(\\boldsymbol{k}) \\rvert^{2}\n\\;+\\; \\Delta x^{2} \\sum_{i,j} F\\big(u(x_{i},y_{j})\\big),\n$$\nwhere $N \\times N$ is the number of grid points, $\\Delta x = L/N$, and the discrete Fourier transform is unnormalized so that Parseval's identity in discrete form is $\\sum_{i,j} \\lvert u_{ij} \\rvert^{2} = \\frac{1}{N^{2}} \\sum_{\\boldsymbol{k}} \\lvert \\widehat{u}(\\boldsymbol{k}) \\rvert^{2}$. The discrete mass is\n$$\nm_{h}(u) = \\Delta x^{2} \\sum_{i,j} u(x_{i},y_{j}).\n$$\n\nYour implementation must:\n\n1. Use a two-dimensional Fourier spectral discretization on a uniform grid and periodic boundary conditions, with $N$ points per dimension over $[0,L]$ and physical wavenumbers computed from the domain size.\n\n2. Implement a first-order stabilized semi-implicit scheme compatible with the gradient-flow structure for both equations. The stabilization coefficient $S$ must be positive, and the nonlinear term $F'(u)$ must be treated explicitly, while the linear stiff terms are treated implicitly. The scheme must preserve the zero-wavenumber mode for the Cahn–Hilliard update exactly to machine precision, thus conserving mass.\n\n3. Compute and monitor the discrete free energy $\\mathcal{E}_{h}(u^{n})$ at every time step for the energy decay checks, and compute $m_{h}(u^{n})$ for the mass conservation check.\n\n4. For temporal convergence, estimate the observed order $p$ by running the Allen–Cahn solver with three different time steps $\\Delta t$, $\\Delta t/2$, and $\\Delta t/4$ up to the same final time and computing\n$$\ne_{12} = \\left( \\Delta x^{2} \\sum_{i,j} \\big(u_{\\Delta t}(x_{i},y_{j},T) - u_{\\Delta t/2}(x_{i},y_{j},T)\\big)^{2} \\right)^{1/2}, \\quad\ne_{23} = \\left( \\Delta x^{2} \\sum_{i,j} \\big(u_{\\Delta t/2}(x_{i},y_{j},T) - u_{\\Delta t/4}(x_{i},y_{j},T)\\big)^{2} \\right)^{1/2},\n$$\nand reporting\n$$\np = \\frac{\\log(e_{12}/e_{23})}{\\log(2)}.\n$$\n\nUse the following test suite with parameters carefully chosen to test the required properties. The domain length is $L=1.0$ in all cases. Angles, if used, must be in radians. No physical units beyond the dimensionless setup are required.\n\n- Test case $1$ (Allen–Cahn energy monotonicity): $N=64$, $\\varepsilon=0.02$, $S=2.0$, $\\Delta t=10^{-3}$, final time $T=0.2$, initial condition $u_{0}(x,y) = 0.3 \\cos(2\\pi x/L) \\cos(2\\pi y/L)$. Output a boolean indicating whether $\\mathcal{E}_{h}(u^{n})$ is monotonically nonincreasing for all steps within a tolerance of $10^{-10}\\,\\mathcal{E}_{h}(u^{0})$.\n\n- Test case $2$ (Cahn–Hilliard mass conservation): $N=64$, $\\varepsilon=0.02$, $S=2.0$, $\\Delta t=10^{-3}$, final time $T=0.2$, initial condition $u_{0}(x,y) = 0.2 \\cos(2\\pi x/L) \\cos(2\\pi y/L) + 0.1$. Output the absolute drift $\\lvert m_{h}(u^{T}) - m_{h}(u^{0}) \\rvert$ as a float.\n\n- Test case $3$ (Allen–Cahn temporal order estimate): $N=32$, $\\varepsilon=0.02$, $S=2.0$, three time steps $\\Delta t=2\\times 10^{-3}$, $\\Delta t/2=10^{-3}$, and $\\Delta t/4=5\\times 10^{-4}$, final time $T=0.2$, initial condition $u_{0}(x,y) = 0.3 \\cos(2\\pi x/L) \\cos(2\\pi y/L)$. Output the estimated observed order $p$ as a float.\n\n- Test case $4$ (Cahn–Hilliard energy monotonicity): $N=64$, $\\varepsilon=0.02$, $S=2.0$, $\\Delta t=10^{-3}$, final time $T=0.2$, initial condition $u_{0}(x,y) = 0.2 \\cos(2\\pi x/L) \\cos(2\\pi y/L)$. Output a boolean indicating whether $\\mathcal{E}_{h}(u^{n})$ is monotonically nonincreasing for all steps within a tolerance of $10^{-10}\\,\\mathcal{E}_{h}(u^{0})$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). The four results must be, in order, the boolean from test case $1$, the float from test case $2$, the float from test case $3$, and the boolean from test case $4$.",
            "solution": "The user requests the implementation and verification of numerical solvers for the Allen-Cahn (AC) and Cahn-Hilliard (CH) equations on a two-dimensional periodic domain. The verification will focus on energy monotonicity, mass conservation, and temporal convergence order.\n\nThe governing equations are gradient flows of the Ginzburg-Landau free energy functional:\n$$\n\\mathcal{E}(u) = \\int_{\\Omega} \\left( \\frac{\\varepsilon^{2}}{2} \\lvert \\nabla u \\rvert^{2} + F(u) \\right) \\, \\mathrm{d}x,\n$$\nwhere $F(u) = \\frac{1}{4}(u^2-1)^2$ is a double-well potential. The chemical potential is the variational derivative of the energy, $\\mu = \\delta \\mathcal{E} / \\delta u = -\\varepsilon^2 \\Delta u + F'(u)$, with $F'(u) = u^3-u$.\n\nThe Allen-Cahn equation is the $L^2$ gradient flow, $\\partial_t u = -\\mu$:\n$$\n\\frac{\\partial u}{\\partial t} = \\varepsilon^{2} \\Delta u - (u^3 - u)\n$$\nThe Cahn-Hilliard equation is the $H^{-1}$ gradient flow, $\\partial_t u = \\Delta \\mu$:\n$$\n\\frac{\\partial u}{\\partial t} = \\Delta(-\\varepsilon^2 \\Delta u + u^3-u) = -\\varepsilon^2 \\Delta^2 u + \\Delta(u^3-u)\n$$\n\nThe solution employs a Fourier spectral method for spatial discretization on a uniform $N \\times N$ grid over the domain $\\Omega = [0,L] \\times [0,L]$. The use of the Fast Fourier Transform (FFT) is ideal for periodic boundary conditions, as it diagonalizes the constant-coefficient differential operators (like $\\Delta$ and $\\Delta^2$), turning the partial differential equations into a system of ordinary differential equations in Fourier space. The Laplacian $\\Delta$ corresponds to multiplication by $-|\\boldsymbol{k}|^2 = -(k_x^2 + k_y^2)$ for each wavenumber vector $\\boldsymbol{k}$. Similarly, the biharmonic operator $\\Delta^2$ corresponds to multiplication by $|\\boldsymbol{k}|^4$.\n\nFor time discretization, a first-order, stabilized, semi-implicit scheme is required. This class of schemes treats stiff linear terms implicitly for stability while handling nonlinear terms explicitly for simplicity. To guarantee energy stability for any time step size (unconditional stability), a linear stabilization term is added. A common and robust approach is the linearly stabilized scheme, which has the general form in the time-discrete domain:\n$$\n\\frac{u^{n+1}-u^n}{\\Delta t} = \\mathcal{L}u^{n+1} + \\mathcal{N}(u^n) - \\mathcal{S}(u^{n+1}-u^n)\n$$\nwhere $\\mathcal{L}$ is the linear differential operator, $\\mathcal{N}$ is the nonlinear term, and $\\mathcal{S}$ is the stabilization operator. For the AC and CH equations, this leads to the following schemes in Fourier space, where $\\widehat{u}$ is the discrete Fourier transform of $u$:\n\nFor Allen-Cahn, $\\mathcal{L}u = \\varepsilon^2 \\Delta u$, $\\mathcal{N}(u) = -F'(u)$, and the stabilization is $\\mathcal{S} = S \\cdot I$ (identity operator). The Fourier-space update is:\n$$\n\\widehat{u}^{n+1} = \\frac{(1 + S \\Delta t) \\widehat{u}^n - \\Delta t \\widehat{F'(u^n)}}{1 + S \\Delta t + \\varepsilon^2 |\\boldsymbol{k}|^2 \\Delta t}\n$$\nThis scheme is unconditionally energy-stable for any $S0$.\n\nFor Cahn-Hilliard, $\\mathcal{L}u = -\\varepsilon^2 \\Delta^2 u$, $\\mathcal{N}(u) = \\Delta F'(u)$. To maintain the conservative nature ($H^{-1}$ structure), the stabilization operator is chosen as $\\mathcal{S} = -S \\Delta$. The scheme becomes:\n$$\n\\frac{u^{n+1}-u^n}{\\Delta t} = (-\\varepsilon^2\\Delta^2 - S\\Delta) u^{n+1} + \\Delta F'(u^n) + S\\Delta u^n\n$$\nIn Fourier space, this yields the update rule:\n$$\n\\widehat{u}^{n+1} = \\frac{\\widehat{u}^n(1 + S\\Delta t|\\boldsymbol{k}|^2) - \\Delta t |\\boldsymbol{k}|^2 \\widehat{F'(u^n)}}{1 + \\Delta t(\\varepsilon^2|\\boldsymbol{k}|^4 + S|\\boldsymbol{k}|^2)}\n$$\nThis scheme is unconditionally energy-stable for $S \\ge 0$. Notably, for the zero-wavenumber mode ($\\boldsymbol{k}=\\boldsymbol{0}$), $|\\boldsymbol{k}|=0$, the update simplifies to $\\widehat{u}^{n+1}(\\boldsymbol{0}) = \\widehat{u}^n(\\boldsymbol{0})$, which ensures exact conservation of the total mass, $\\int u \\, \\mathrm{d}x$, to machine precision.\n\nThe implementation consists of a main solver function that dispatches four test cases. A general-purpose simulation function handles the core logic for both equation types. Helper functions compute the discrete energy and mass as defined in the problem statement.\n\n1.  **Energy Monotonicity Checks (Tests 1  4):** The discrete energy $\\mathcal{E}_h(u^n)$ is computed at each time step. The test passes if the energy is non-increasing throughout the simulation, within a small numerical tolerance, i.e., $\\mathcal{E}_h(u^{n+1}) \\le \\mathcal{E}_h(u^n) + \\text{tol}$.\n\n2.  **Mass Conservation Check (Test 2):** For the Cahn-Hilliard equation, the total discrete mass $m_h(u) = \\Delta x^2 \\sum_{i,j} u_{ij}$ is computed for the initial and final states. The absolute difference is reported.\n\n3.  **Temporal Order Estimation (Test 3):** The Allen-Cahn equation is solved up to time $T$ using three successively halved time steps ($\\Delta t, \\Delta t/2, \\Delta t/4$). The discrete $L^2$ errors between the solutions, $e_{12}$ and $e_{23}$, are computed. The observed order of convergence $p$ is then estimated using the formula $p = \\log(e_{12}/e_{23})/\\log(2)$. For a first-order scheme, $p$ is expected to be approximately $1$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies numerical solvers for Allen-Cahn and Cahn-Hilliard equations\n    based on the specified test suite.\n    \"\"\"\n\n    def compute_energy(u, K2, epsilon, dx, N):\n        \"\"\"\n        Computes the discrete Ginzburg-Landau free energy according to the problem specification.\n        \n        Args:\n            u (np.ndarray): The field variable on a 2D grid.\n            K2 (np.ndarray): The squared magnitudes of the wavenumbers.\n            epsilon (float): The interface width parameter.\n            dx (float): The grid spacing.\n            N (int): The number of grid points in one dimension.\n            \n        Returns:\n            float: The total discrete free energy.\n        \"\"\"\n        u_hat = np.fft.fftn(u)\n        \n        # Gradient term, consistent with the specified Parseval's identity.\n        grad_energy_term = (epsilon**2 / 2.0) * dx**2 * (1.0 / (N**2)) * np.sum(K2 * np.abs(u_hat)**2)\n        \n        # Potential term.\n        potential_F = (u**2 - 1.0)**2 / 4.0\n        potential_energy_term = dx**2 * np.sum(potential_F)\n        \n        return grad_energy_term + potential_energy_term\n\n    def compute_mass(u, dx):\n        \"\"\"\n        Computes the discrete total mass.\n        \n        Args:\n            u (np.ndarray): The field variable on a 2D grid.\n            dx (float): The grid spacing.\n        \n        Returns:\n            float: The total discrete mass.\n        \"\"\"\n        return dx**2 * np.sum(u)\n\n    def run_simulation(eq_type, N, L, epsilon, S, dt, T, u0_func, track_energy=False):\n        \"\"\"\n        Runs a simulation for either the Allen-Cahn or Cahn-Hilliard equation.\n        \n        Args:\n            eq_type (str): 'AC' for Allen-Cahn, 'CH' for Cahn-Hilliard.\n            N (int): Grid points per dimension.\n            L (float): Domain size.\n            epsilon (float): Interface width parameter.\n            S (float): Stabilization coefficient.\n            dt (float): Time step size.\n            T (float): Final time.\n            u0_func (callable): Function to generate the initial condition u0(X, Y).\n            track_energy (bool): If True, computes and returns the energy at each step.\n            \n        Returns:\n            tuple: A tuple containing the final field u (np.ndarray) and a list of energies.\n        \"\"\"\n        dx = L / N\n        \n        # Set up grid and wavenumbers. `indexing='ij'` ensures (row, col) consistency.\n        x_1d = np.arange(N) * dx\n        X, Y = np.meshgrid(x_1d, x_1d, indexing='ij')\n        \n        k_1d = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n        KX, KY = np.meshgrid(k_1d, k_1d, indexing='ij')\n        K2 = KX**2 + KY**2\n\n        u = u0_func(X, Y)\n\n        # Precompute denominators for Fourier-space updates.\n        if eq_type == 'AC':\n            denom = 1.0 + S * dt + epsilon**2 * K2 * dt\n        elif eq_type == 'CH':\n            K4 = K2**2\n            denom = 1.0 + dt * (epsilon**2 * K4 + S * K2)\n        else:\n            raise ValueError(\"Unknown equation type\")\n\n        num_steps = int(round(T / dt))\n        \n        energies = []\n        if track_energy:\n            energies.append(compute_energy(u, K2, epsilon, dx, N))\n\n        for _ in range(num_steps):\n            Fprime = u**3 - u\n            \n            u_hat = np.fft.fftn(u)\n            Fprime_hat = np.fft.fftn(Fprime)\n\n            if eq_type == 'AC':\n                u_hat_new = ((1.0 + S * dt) * u_hat - dt * Fprime_hat) / denom\n            else:  # CH\n                u_hat_new = (u_hat * (1.0 + S * dt * K2) - dt * K2 * Fprime_hat) / denom\n\n            u = np.fft.ifftn(u_hat_new).real\n\n            if track_energy:\n                energies.append(compute_energy(u, K2, epsilon, dx, N))\n\n        return u, energies\n\n    # Set common domain size\n    L = 1.0\n    \n    # Test cases defined in the problem statement\n    test_cases = [\n        # (1) Allen-Cahn energy monotonicity check\n        {\n            \"id\": 1, \"type\": \"AC\", \"N\": 64, \"epsilon\": 0.02, \"S\": 2.0,\n            \"dt\": 1e-3, \"T\": 0.2,\n            \"u0_func\": lambda X, Y: 0.3 * np.cos(2*np.pi*X/L) * np.cos(2*np.pi*Y/L)\n        },\n        # (2) Cahn-Hilliard mass conservation check\n        {\n            \"id\": 2, \"type\": \"CH\", \"N\": 64, \"epsilon\": 0.02, \"S\": 2.0,\n            \"dt\": 1e-3, \"T\": 0.2,\n            \"u0_func\": lambda X, Y: 0.2 * np.cos(2*np.pi*X/L) * np.cos(2*np.pi*Y/L) + 0.1\n        },\n        # (3) Allen-Cahn temporal order estimation\n        {\n            \"id\": 3, \"type\": \"AC\", \"N\": 32, \"epsilon\": 0.02, \"S\": 2.0,\n            \"dts\": [2e-3, 1e-3, 5e-4], \"T\": 0.2,\n            \"u0_func\": lambda X, Y: 0.3 * np.cos(2*np.pi*X/L) * np.cos(2*np.pi*Y/L)\n        },\n        # (4) Cahn-Hilliard energy monotonicity check\n        {\n            \"id\": 4, \"type\": \"CH\", \"N\": 64, \"epsilon\": 0.02, \"S\": 2.0,\n            \"dt\": 1e-3, \"T\": 0.2,\n            \"u0_func\": lambda X, Y: 0.2 * np.cos(2*np.pi*X/L) * np.cos(2*np.pi*Y/L)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[\"id\"] == 1:\n            p = case\n            _, energies = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dt\"], p[\"T\"], p[\"u0_func\"], track_energy=True)\n            \n            is_monotonic = True\n            E0 = energies[0]\n            tolerance = 1e-10 * abs(E0) if E0 != 0 else 1e-10\n            for i in range(len(energies) - 1):\n                if energies[i+1] > energies[i] + tolerance:\n                    is_monotonic = False\n                    break\n            results.append(is_monotonic)\n\n        elif case[\"id\"] == 2:\n            p = case\n            dx = L / p[\"N\"]\n            x_1d = np.arange(p[\"N\"]) * dx\n            X, Y = np.meshgrid(x_1d, x_1d, indexing='ij')\n            u_initial = p[\"u0_func\"](X, Y)\n            m0 = compute_mass(u_initial, dx)\n            \n            u_final, _ = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dt\"], p[\"T\"], p[\"u0_func\"])\n            \n            mf = compute_mass(u_final, dx)\n            results.append(abs(mf - m0))\n\n        elif case[\"id\"] == 3:\n            p = case\n            u_final_dt1, _ = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dts\"][0], p[\"T\"], p[\"u0_func\"])\n            u_final_dt2, _ = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dts\"][1], p[\"T\"], p[\"u0_func\"])\n            u_final_dt3, _ = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dts\"][2], p[\"T\"], p[\"u0_func\"])\n            \n            dx = L / p[\"N\"]\n            e12 = dx * np.sqrt(np.sum((u_final_dt1 - u_final_dt2)**2))\n            e23 = dx * np.sqrt(np.sum((u_final_dt2 - u_final_dt3)**2))\n            \n            if e12 > 0 and e23 > 0 and e12 / e23 > 0:\n                order = np.log(e12 / e23) / np.log(2.0)\n            else:\n                order = 0.0 # Indicate failure or no convergence\n            results.append(order)\n\n        elif case[\"id\"] == 4:\n            p = case\n            _, energies = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dt\"], p[\"T\"], p[\"u0_func\"], track_energy=True)\n            \n            is_monotonic = True\n            E0 = energies[0]\n            tolerance = 1e-10 * abs(E0) if E0 != 0 else 1e-10\n            for i in range(len(energies) - 1):\n                if energies[i+1] > energies[i] + tolerance:\n                    is_monotonic = False\n                    break\n            results.append(is_monotonic)\n\n    # Format output as specified: comma-separated list in brackets, booleans as lowercase\n    formatted_results = []\n    for r in results:\n        if isinstance(r, (bool, np.bool_)):\n            formatted_results.append(str(r).lower())\n        else:\n            formatted_results.append(f\"{r:.15g}\")\n            \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}