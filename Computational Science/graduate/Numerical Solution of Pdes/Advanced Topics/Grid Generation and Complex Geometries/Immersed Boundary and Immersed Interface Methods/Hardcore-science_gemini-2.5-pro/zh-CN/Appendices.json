{
    "hands_on_practices": [
        {
            "introduction": "在模拟流体与结构的相互作用之前，我们必须首先能够精确地在数值上描述结构的几何形状。本练习聚焦于这基础性的第一步。你将从一组离散的拉格朗日点出发，推导用于计算切向量、法向量和曲率等几何量的有限差分公式，并深入分析这些点之间的非均匀间距如何影响计算的精度。这项实践对于培养处理复杂几何形状的能力，以及理解浸入边界模拟中误差的来源至关重要。 ",
            "id": "3405640",
            "problem": "考虑一个闭合、光滑的平面界面，由弧长 $s$ 参数化的曲线 $\\boldsymbol{X}(s) \\in \\mathbb{R}^{2}$ 表示，使得 $|\\boldsymbol{X}'(s)|=1$。在 Immersed Boundary (IB) 法和 Immersed Interface Methods (IIM) 中，该界面通过参数为 $s_j$ 的拉格朗日点进行离散化，其间距通常为非均匀的 $h_{j+\\frac{1}{2}} := s_{j+1}-s_j$。设局部基本步长为 $h>0$，并假设非均匀性是微小且光滑的，即\n$$\nh_{j+\\frac{1}{2}} = h\\bigl(1+\\epsilon\\,\\phi(s_{j+\\frac{1}{2}})\\bigr), \\qquad |\\epsilon|\\ll 1,\n$$\n其中 $\\phi$ 是一个有界光滑函数。记 $a:=h_{j-\\frac{1}{2}}$ 和 $b:=h_{j+\\frac{1}{2}}$。\n\n从单位切向量 $\\boldsymbol{t}(s)=\\boldsymbol{X}'(s)$、单位法向量 $\\boldsymbol{n}(s)=\\boldsymbol{R}\\,\\boldsymbol{t}(s)$、曲率 $\\kappa(s)=\\boldsymbol{n}(s)\\cdot \\boldsymbol{X}''(s)$ 的几何定义出发（其中 $\\boldsymbol{R}$ 是逆时针旋转 $\\pi/2$），并利用弧长增量 $\\Delta s=\\int |\\boldsymbol{X}'(s)|\\,ds$，完成以下任务。\n\n(1) 推导在 $s_j$ 处的三点非均匀有限差分公式，用于计算：\n- 一阶导数 $\\boldsymbol{X}'(s_j)$（用于近似切向量），使用步长为 $a$ 和 $b$ 的点 $\\boldsymbol{X}_{j-1},\\boldsymbol{X}_j,\\boldsymbol{X}_{j+1}$，\n- 二阶导数 $\\boldsymbol{X}''(s_j)$（用于计算曲率），\n- 通过对离散一阶导数进行归一化得到的单位切向量 $\\boldsymbol{t}_j$，\n- 单位法向量 $\\boldsymbol{n}_j=\\boldsymbol{R}\\,\\boldsymbol{t}_j$，\n- 局部弧长增量 $\\Delta s_{j+\\frac{1}{2}}\\approx |\\boldsymbol{X}_{j+1}-\\boldsymbol{X}_j|$。\n\n您的推导必须从 $\\boldsymbol{X}(s)$ 的泰勒展开和定义的几何恒等式出发，并且必须给出截断误差展开式，直至并包含以 $h$ 和 $\\epsilon$ 的幂表示的首个非零项。\n\n(2) 使用您的公式，为曲率估计量\n$$\n\\kappa_j := \\boldsymbol{n}_j \\cdot \\boldsymbol{D}^{(2)}\\boldsymbol{X}_j,\n$$\n得到一个渐近表达式，精确到 $h$ 和 $\\epsilon$ 的首个非零阶，其中 $\\boldsymbol{D}^{(2)}$ 是您推导的非均匀三点二阶导数算子。通过用 $a$、$b$ 以及在 $s_j$ 处求值的 $\\boldsymbol{X}(s)$ 的导数来表示首项曲率偏差，从而分离出非均匀间距的贡献，然后用 $h$ 和 $\\epsilon\\,\\phi$ 重新表示结果。\n\n(3) 将问题特殊化到半径为 $R_0>0$ 的圆，其由弧长参数化为 $\\boldsymbol{X}(s)=\\bigl(R_0\\cos(s/R_0),\\,R_0\\sin(s/R_0)\\bigr)$，其精确曲率为 $\\kappa\\equiv 1/R_0$。假设非均匀模式为 $\\phi(s)=\\cos(s/R_0)$。使用您在 (2) 中得到的渐近式，确定当 $h\\to 0$ 且 $|\\epsilon|\\ll 1$ 时，在所有 $j$ 上 $\\kappa_j$ 的最大绝对相对误差的主阶表达式。\n\n最后，对 $R_0=1.3$、$h=0.08$ 和 $\\epsilon=0.10$ 计算这个预测的最大绝对相对误差。将您的答案四舍五入到四位有效数字。最终答案以纯数字形式表示，不带单位。",
            "solution": "该问题是数值分析领域的一个有效练习，具体涉及光滑曲线上几何量的有限差分公式的推导和分析。该问题在数学上是适定的，有科学依据，并且没有任何在验证协议中列出的可能使其无效的缺陷。我们开始解答。\n\n按要求，解答分为三个部分。我们将 $\\boldsymbol{X}$ 相对于弧长参数 $s$ 的导数记为 $\\boldsymbol{X}', \\boldsymbol{X}'', \\dots$，并将其在点 $s_j$ 处的值记为 $\\boldsymbol{X}'_j, \\boldsymbol{X}''_j, \\dots$。离散点为 $\\boldsymbol{X}_j = \\boldsymbol{X}(s_j)$、$\\boldsymbol{X}_{j-1} = \\boldsymbol{X}(s_j-a)$ 和 $\\boldsymbol{X}_{j+1} = \\boldsymbol{X}(s_j+b)$，其中 $a=s_j-s_{j-1}$，$b=s_{j+1}-s_j$。\n\n### 第 (1) 部分：有限差分公式和截断误差\n\n我们从 $\\boldsymbol{X}(s)$ 在 $s_j$ 附近的泰勒级数展开开始：\n$$ \\boldsymbol{X}_{j+1} = \\boldsymbol{X}(s_j+b) = \\boldsymbol{X}_j + b\\boldsymbol{X}'_j + \\frac{b^2}{2}\\boldsymbol{X}''_j + \\frac{b^3}{6}\\boldsymbol{X}'''_j + \\frac{b^4}{24}\\boldsymbol{X}^{(4)}_j + O(b^5) $$\n$$ \\boldsymbol{X}_{j-1} = \\boldsymbol{X}(s_j-a) = \\boldsymbol{X}_j - a\\boldsymbol{X}'_j + \\frac{a^2}{2}\\boldsymbol{X}''_j - \\frac{a^3}{6}\\boldsymbol{X}'''_j + \\frac{a^4}{24}\\boldsymbol{X}^{(4)}_j + O(a^5) $$\n\n**一阶导数 $\\boldsymbol{X}'(s_j)$**\n为了找到 $\\boldsymbol{X}'_j$ 的一个二阶精度公式，我们消去 $\\boldsymbol{X}''_j$ 项。我们将第一个展开式乘以 $a^2$，第二个展开式乘以 $b^2$，然后相减：\n$$ a^2\\boldsymbol{X}_{j+1} - b^2\\boldsymbol{X}_{j-1} = (a^2-b^2)\\boldsymbol{X}_j + (a^2b+ab^2)\\boldsymbol{X}'_j + \\frac{a^2b^3-b^2(-a^3)}{6}\\boldsymbol{X}'''_j + O(h^5) $$\n$$ a^2\\boldsymbol{X}_{j+1} - b^2\\boldsymbol{X}_{j-1} = (a^2-b^2)\\boldsymbol{X}_j + ab(a+b)\\boldsymbol{X}'_j + \\frac{a^2b^2(a+b)}{6}\\boldsymbol{X}'''_j + O(h^5) $$\n整理得到 $\\boldsymbol{X}'_j$ 的三点非均匀公式 $\\boldsymbol{D}^{(1)}\\boldsymbol{X}_j$：\n$$ \\boldsymbol{D}^{(1)}\\boldsymbol{X}_j := \\frac{a^2\\boldsymbol{X}_{j+1} + (b^2-a^2)\\boldsymbol{X}_j - b^2\\boldsymbol{X}_{j-1}}{ab(a+b)} $$\n通过整理展开式可得到截断误差：\n$$ \\boldsymbol{D}^{(1)}\\boldsymbol{X}_j = \\boldsymbol{X}'_j + \\frac{ab}{6}\\boldsymbol{X}'''_j + O(h^3) $$\n由于 $a,b=O(h)$，主误差项为 $O(h^2)$。\n\n**二阶导数 $\\boldsymbol{X}''(s_j)$**\n为了找到 $\\boldsymbol{X}''_j$ 的公式，我们消去 $\\boldsymbol{X}'_j$ 项。我们将第一个展开式乘以 $a$，第二个展开式乘以 $b$，然后相加：\n$$ a\\boldsymbol{X}_{j+1} + b\\boldsymbol{X}_{j-1} = (a+b)\\boldsymbol{X}_j + \\frac{ab^2+ba^2}{2}\\boldsymbol{X}''_j + \\frac{ab^3-ba^3}{6}\\boldsymbol{X}'''_j + \\frac{ab^4+ba^4}{24}\\boldsymbolX^{(4)}_j + O(h^5) $$\n$$ a\\boldsymbol{X}_{j+1} + b\\boldsymbol{X}_{j-1} = (a+b)\\boldsymbol{X}_j + \\frac{ab(a+b)}{2}\\boldsymbol{X}''_j + \\frac{ab(b-a)}{6}\\boldsymbol{X}'''_j + \\frac{ab(a^3+b^3)}{24(a+b)}(a+b)\\boldsymbol{X}^{(4)}_j + \\dots $$\n这给出了二阶导数的公式 $\\boldsymbol{D}^{(2)}\\boldsymbol{X}_j$：\n$$ \\boldsymbol{D}^{(2)}\\boldsymbol{X}_j := \\frac{2\\left(a\\boldsymbol{X}_{j+1} - (a+b)\\boldsymbol{X}_j + b\\boldsymbol{X}_{j-1}\\right)}{ab(a+b)} $$\n截断误差为：\n$$ \\boldsymbol{D}^{(2)}\\boldsymbol{X}_j = \\boldsymbol{X}''_j + \\frac{b-a}{3}\\boldsymbol{X}'''_j + \\frac{a^2-ab+b^2}{12}\\boldsymbol{X}^{(4)}_j + O((a,b)^3) $$\n对于一般的非均匀网格，主误差通常为 $O(b-a)=O(h)$，但在给定的光滑变化条件下，$b-a = O(\\epsilon h^2)$，使得主误差为 $O(h^2)$。\n\n**单位切向量 $\\boldsymbol{t}_j$ 和法向量 $\\boldsymbol{n}_j$**\n单位切向量通过对离散一阶导数进行归一化来近似：$\\boldsymbol{t}_j^{approx} = \\frac{\\boldsymbol{D}^{(1)}\\boldsymbol{X}_j}{|\\boldsymbol{D}^{(1)}\\boldsymbol{X}_j|}$。首先，我们求 $\\boldsymbol{D}^{(1)}\\boldsymbol{X}_j$ 的模：\n$$ |\\boldsymbol{D}^{(1)}\\boldsymbol{X}_j|^2 = |\\boldsymbol{X}'_j + \\frac{ab}{6}\\boldsymbol{X}'''_j + O(h^3)|^2 = |\\boldsymbol{X}'_j|^2 + 2\\frac{ab}{6} \\boldsymbol{X}'_j \\cdot \\boldsymbol{X}'''_j + O(h^4) $$\n因为 $s$ 是弧长，所以 $\\boldsymbol{X}'=\\boldsymbol{t}$ 且 $|\\boldsymbol{t}|=1$。平面曲线的弗勒内-塞雷公式 (Frenet-Serret relations) 为 $\\boldsymbol{t}'=\\kappa\\boldsymbol{n}$ 和 $\\boldsymbol{n}'=-\\kappa\\boldsymbol{t}$。因此 $\\boldsymbol{X}''=\\kappa\\boldsymbol{n}$ 且 $\\boldsymbol{X}''' = \\kappa'\\boldsymbol{n} - \\kappa^2\\boldsymbol{t}$。所以，$\\boldsymbol{t}\\cdot\\boldsymbol{X}''' = -\\kappa^2$。\n$$ |\\boldsymbol{D}^{(1)}\\boldsymbol{X}_j|^2 = 1 - \\frac{ab}{3}\\kappa_j^2 + O(h^4) \\implies |\\boldsymbol{D}^{(1)}\\boldsymbol{X}_j| = 1 - \\frac{ab}{6}\\kappa_j^2 + O(h^4) $$\n那么近似切向量为：\n$$ \\boldsymbol{t}_j^{approx} = (\\boldsymbol{X}'_j + \\frac{ab}{6}\\boldsymbol{X}'''_j)(1 + \\frac{ab}{6}\\kappa_j^2 + O(h^4)) = \\boldsymbol{t}_j + \\frac{ab}{6}(\\boldsymbol{X}'''_j + \\kappa_j^2\\boldsymbol{t}_j) + O(h^4) $$\n$$ \\boldsymbol{t}_j^{approx} = \\boldsymbol{t}_j + \\frac{ab}{6}(\\kappa'_j\\boldsymbol{n}_j - \\kappa_j^2\\boldsymbol{t}_j + \\kappa_j^2\\boldsymbol{t}_j) + O(h^4) = \\boldsymbol{t}_j + \\frac{ab}{6}\\kappa'_j\\boldsymbol{n}_j + O(h^4) $$\n近似法向量 $\\boldsymbol{n}_j^{approx} = \\boldsymbol{R}\\boldsymbol{t}_j^{approx}$ 为：\n$$ \\boldsymbol{n}_j^{approx} = \\boldsymbol{R}(\\boldsymbol{t}_j + \\frac{ab}{6}\\kappa'_j\\boldsymbol{n}_j) + O(h^4) = \\boldsymbol{n}_j + \\frac{ab}{6}\\kappa'_j(-\\boldsymbol{t}_j) + O(h^4) = \\boldsymbol{n}_j - \\frac{ab}{6}\\kappa'_j\\boldsymbol{t}_j + O(h^4) $$\n$\\boldsymbol{t}_j^{approx}$ 和 $\\boldsymbol{n}_j^{approx}$ 的主误差项均为 $O(h^2)$。\n\n**弧长增量 $\\Delta s_{j+\\frac{1}{2}}$**\n精确的弧长增量为 $\\Delta s_{j+\\frac{1}{2}} = s_{j+1}-s_j=b$。其近似值为弦长 $|\\boldsymbol{X}_{j+1}-\\boldsymbol{X}_j|$。\n$$ \\boldsymbol{X}_{j+1}-\\boldsymbol{X}_j = b\\boldsymbol{X}'_j + \\frac{b^2}{2}\\boldsymbol{X}''_j + \\frac{b^3}{6}\\boldsymbol{X}'''_j + \\frac{b^4}{24}\\boldsymbol{X}^{(4)}_j + O(b^5) $$\n使用弗勒内-塞雷公式：$\\boldsymbol{X}'=\\boldsymbol{t}$, $\\boldsymbol{X}''=\\kappa\\boldsymbol{n}$, $\\boldsymbol{X}'''=-\\kappa^2\\boldsymbol{t}+\\kappa'\\boldsymbol{n}$, $\\boldsymbol{X}^{(4)}=-3\\kappa\\kappa'\\boldsymbol{t}+(\\kappa''-\\kappa^3)\\boldsymbol{n}$。\n$$ |\\boldsymbol{X}_{j+1}-\\boldsymbol{X}_j|^2 = \\left(b - \\frac{b^3\\kappa^2}{6}\\right)^2 + \\left(\\frac{b^2\\kappa}{2} + \\frac{b^3\\kappa'}{6}\\right)^2 + O(b^6) = b^2 - \\frac{b^4\\kappa^2}{3} + \\frac{b^4\\kappa^2}{4} + O(b^5) = b^2 - \\frac{b^4\\kappa^2}{12} + O(b^5) $$\n$$ |\\boldsymbol{X}_{j+1}-\\boldsymbol{X}_j| = b\\sqrt{1-\\frac{b^2\\kappa^2}{12}+O(b^3)} = b\\left(1-\\frac{b^2\\kappa^2}{24}+O(b^4)\\right) = b - \\frac{b^3\\kappa^2}{24} + O(b^5) $$\n误差为 $|\\boldsymbol{X}_{j+1}-\\boldsymbol{X}_j| - b = -\\frac{b^3\\kappa_j^2}{24} + O(b^5)$。\n\n### 第 (2) 部分：曲率估计量的渐近分析\n\n曲率估计量为 $\\kappa_j^{approx} := \\boldsymbol{n}_j^{approx} \\cdot \\boldsymbol{D}^{(2)}\\boldsymbol{X}_j$。我们使用第 (1) 部分中的表达式：\n$$ \\kappa_j^{approx} = \\left(\\boldsymbol{n}_j - \\frac{ab}{6}\\kappa'_j\\boldsymbol{t}_j + O(h^4)\\right) \\cdot \\left(\\boldsymbol{X}''_j + \\frac{b-a}{3}\\boldsymbol{X}'''_j + \\frac{a^2-ab+b^2}{12}\\boldsymbol{X}^{(4)}_j + O(h^3)\\right) $$\n展开并保留主项：\n$$ \\kappa_j^{approx} = \\boldsymbol{n}_j\\cdot\\boldsymbol{X}''_j + \\frac{b-a}{3}\\boldsymbol{n}_j\\cdot\\boldsymbol{X}'''_j + \\frac{a^2-ab+b^2}{12}\\boldsymbol{n}_j\\cdot\\boldsymbol{X}^{(4)}_j - \\frac{ab}{6}\\kappa'_j(\\boldsymbol{t}_j\\cdot\\boldsymbol{X}''_j) + \\dots $$\n我们计算点积：\n- $\\boldsymbol{n}_j\\cdot\\boldsymbol{X}''_j = \\boldsymbol{n}_j\\cdot(\\kappa_j\\boldsymbol{n}_j) = \\kappa_j$。\n- $\\boldsymbol{n}_j\\cdot\\boldsymbol{X}'''_j = \\boldsymbol{n}_j\\cdot(\\kappa'_j\\boldsymbol{n}_j-\\kappa_j^2\\boldsymbol{t}_j) = \\kappa'_j$。\n- $\\boldsymbol{n}_j\\cdot\\boldsymbol{X}^{(4)}_j = \\boldsymbol{n}_j\\cdot(-3\\kappa_j\\kappa'_j\\boldsymbol{t}_j + (\\kappa''_j-\\kappa_j^3)\\boldsymbol{n}_j) = \\kappa''_j-\\kappa_j^3$。\n- $\\boldsymbol{t}_j\\cdot\\boldsymbol{X}''_j = \\boldsymbol{t}_j\\cdot(\\kappa_j\\boldsymbol{n}_j) = 0$。\n\n将这些代回，我们得到估计曲率的渐近表达式：\n$$ \\kappa_j^{approx} = \\kappa_j + \\frac{b-a}{3}\\kappa'_j + \\frac{a^2-ab+b^2}{12}(\\kappa''_j - \\kappa_j^3) + O(\\epsilon h^3, h^3) $$\n误差为 $\\kappa_j^{approx} - \\kappa_j$。来自非均匀间距的贡献是当 $a=b=h$ 时误差中消失的部分。总误差是上述表达式减去 $\\kappa_j$。非均匀性对主误差的贡献是 $\\frac{b-a}{3}\\kappa'_j$。这是第一个要求的表达式，用 $a, b$ 和导数表示。\n\n为了用 $h$ 和 $\\epsilon\\phi$ 表示，我们使用 $b = h(1+\\epsilon\\phi(s_{j+1/2}))$ 和 $a=h(1+\\epsilon\\phi(s_{j-1/2}))$。假设 $s_{j\\pm 1/2}$ 是弧长中点，则 $s_{j\\pm 1/2} \\approx s_j \\pm h/2$。\n$$ b-a \\approx h\\epsilon(\\phi(s_j+h/2)-\\phi(s_j-h/2)) \\approx h\\epsilon(h\\phi'(s_j)) = \\epsilon h^2 \\phi'(s_j) $$\n因此，由非均匀性引起的主曲率偏差为 $\\frac{\\epsilon h^2 \\phi'(s_j)}{3}\\kappa'_j$。\n\n### 第 (3) 部分：圆的例子和误差评估\n\n对于半径为 $R_0$ 的圆，我们有 $\\boldsymbol{X}(s)=\\bigl(R_0\\cos(s/R_0),\\,R_0\\sin(s/R_0)\\bigr)$。曲率为常数 $\\kappa \\equiv 1/R_0$。因此，其导数为零：$\\kappa'=0$ 和 $\\kappa''=0$。\n\n使用第 (2) 部分的误差表达式：\n$$ \\kappa_j^{approx} - \\kappa_j = \\frac{b-a}{3}(0) + \\frac{a^2-ab+b^2}{12}(0 - \\kappa_j^3) = -\\frac{a^2-ab+b^2}{12}\\kappa^3 $$\n现在我们用 $h$ 和 $\\epsilon$ 展开 $a^2-ab+b^2$。令 $\\phi_a = \\phi(s_{j-1/2})$ 和 $\\phi_b=\\phi(s_{j+1/2})$。\n$$ a^2-ab+b^2 = h^2\\left[(1+\\epsilon\\phi_a)^2 - (1+\\epsilon\\phi_a)(1+\\epsilon\\phi_b) + (1+\\epsilon\\phi_b)^2\\right] $$\n$$ = h^2\\left[1+\\epsilon(\\phi_a+\\phi_b) + \\epsilon^2(\\phi_a^2-\\phi_a\\phi_b+\\phi_b^2)\\right] $$\n对于 $h$ 和 $\\epsilon$ 的主阶项，我们需要 $\\phi_a+\\phi_b$。当 $\\phi(s)=\\cos(s/R_0)$ 且 $s_{j\\pm1/2}\\approx s_j\\pm h/2$ 时：\n$$ \\phi_a+\\phi_b \\approx \\phi(s_j-h/2)+\\phi(s_j+h/2) = \\cos(\\frac{s_j-h/2}{R_0}) + \\cos(\\frac{s_j+h/2}{R_0}) $$\n$$ = 2\\cos(s_j/R_0)\\cos(h/2R_0) \\approx 2\\cos(s_j/R_0)(1-O(h^2)) \\approx 2\\phi(s_j) $$\n因此，$a^2-ab+b^2 \\approx h^2(1+2\\epsilon\\phi(s_j))$。\n曲率误差为：\n$$ \\kappa_j^{approx} - \\kappa \\approx -\\frac{h^2(1+2\\epsilon\\phi(s_j))}{12}\\kappa^3 = -\\frac{h^2(1+2\\epsilon\\cos(s_j/R_0))}{12 R_0^3} $$\n相对误差为：\n$$ \\frac{\\kappa_j^{approx} - \\kappa}{\\kappa} \\approx -\\frac{h^2(1+2\\epsilon\\cos(s_j/R_0))}{12 R_0^2} $$\n为了找到最大绝对相对误差，我们在所有点 $j$ 上最大化此表达式的绝对值，这对应于在角度 $\\theta_j=s_j/R_0 \\in [0, 2\\pi)$ 上最大化。我们需要最大化 $|1+2\\epsilon\\cos(\\theta_j)|$。由于 $\\epsilon=0.10$ 是一个小的正数，当 $\\cos(\\theta_j)=1$ 时达到最大值：\n$$ \\max |1+2\\epsilon\\cos(\\theta_j)| = 1+2\\epsilon $$\n因此，最大绝对相对误差为：\n$$ E_{max} = \\frac{h^2(1+2\\epsilon)}{12 R_0^2} $$\n最后，我们用给定的值计算这个表达式：$R_0 = 1.3$，$h = 0.08$ 和 $\\epsilon = 0.10$。\n$$ E_{max} = \\frac{(0.08)^2(1+2 \\cdot 0.10)}{12 \\cdot (1.3)^2} = \\frac{0.0064 \\cdot (1.2)}{12 \\cdot 1.69} = \\frac{0.00768}{20.28} $$\n$$ E_{max} \\approx 0.000378703155... $$\n四舍五入到四位有效数字，预测的最大绝对相对误差为 $0.0003787$。",
            "answer": "$$\\boxed{0.0003787}$$"
        },
        {
            "introduction": "浸入边界方法的核心是将拉格朗日边界与欧拉流体网格连接起来的数学“粘合剂”：正则化的狄拉克核函数。这项计算练习要求你通过施加被称为矩条件的关键数学性质，从第一性原理出发构建这些核函数。你将探索调整核函数的参数（例如其宽度）如何在不同类型的数值误差之间进行权衡，从而深入理解该方法的精度和守恒特性。 ",
            "id": "3405625",
            "problem": "本题要求您为浸入边界法 (IBM) 形式化并实现一种一维离散正则化 delta 核函数的构造方法，该核函数具有可调的紧支撑和指定的二阶矩。然后，量化该核函数的一阶矩和二阶矩如何控制两个关键的浸入边界误差：体积泄漏和无滑移（滑移速度）误差。请在无量纲设置下进行，网格间距归一化为 $h = 1$，且无需考虑角度。所有最终数值答案均应报告为无量纲实数。\n\n从以下基本定义和原理开始：\n\n- 在浸入边界法 (IBM) 中，拉格朗日变量和欧拉变量之间的耦合是通过一个正则化的 Dirac delta 核函数实现的。在一维情况下，对于位于 $X$ 处的点，插值和散布通过与网格节点 $x_k = k$ 相关联的权重 $w_k(s)$ 来定义，其中 $s \\in [0,1)$ 是将 $X$ 定位在两个网格节点之间的分数偏移（对于多维问题，使用一维核函数的张量积，但本问题是一维的）。\n- 支撑半宽为 $m \\in \\mathbb{N}$ 的离散正则化 delta 核函数是一组依赖于偏移量 $s \\in [0,1)$ 的权重 $\\{w_k(s)\\}_{k=-m}^{m}$，其必须满足以下关于局部坐标 $r_k(s) = k - s$ 的、最高到二阶的离散矩条件：\n  1. 零阶矩（单位分解）：$\\sum_{k=-m}^{m} w_k(s) = 1$。\n  2. 一阶矩（线性一致性）：$\\sum_{k=-m}^{m} r_k(s)\\, w_k(s) = 0$。\n  3. 二阶矩（指定平滑宽度）：$\\sum_{k=-m}^{m} r_k(s)^2\\, w_k(s) = c_2$，其中 $c_2 > 0$ 是一个给定参数，用于控制核函数的二阶中心矩（也即其平滑宽度）。\n\n您的构造要求是：\n\n- 对于任意选择的支撑半宽 $m$ 和目标二阶矩 $c_2$，以及任意偏移量 $s \\in [0,1)$，构造权重向量 $w(s) \\in \\mathbb{R}^{2m+1}$，使其在所有满足上述三个线性约束的向量中具有最小欧几里得范数。用符号表示，即对每个 $s$ 求解\n  $\n  \\min_{w \\in \\mathbb{R}^{2m+1}} \\tfrac{1}{2}\\Vert w \\Vert_2^2 \\quad \\text{subject to} \\quad\n  \\sum_{k=-m}^{m} w_k = 1, \\;\n  \\sum_{k=-m}^{m} (k - s) w_k = 0, \\;\n  \\sum_{k=-m}^{m} (k - s)^2 w_k = c_2.\n  $\n  这定义了一个由 $(m, c_2)$ 参数化的核函数族 $\\{w_k(s; m, c_2)\\}$。\n\n仅使用所构造核函数的矩信息，定义用于量化两种 IBM 误差的诊断指标：\n\n- 体积泄漏代理指标：对于一个在连续统中保持不可压缩性的离散格式，由核函数引起的离散体积泄漏源于在插值/散布过程中对一阶矩条件的违反。将在偏移量 $s$ 处的一阶矩缺陷定义为\n  $\n  M_1(s; m, c_2) = \\sum_{k=-m}^{m} (k - s)\\, w_k(s; m, c_2).\n  $\n  泄漏诊断指标是一组代表性偏移量 $\\mathcal{S}$ 上的逐偏移最坏情况下的幅值：\n  $\n  L(m, c_2) = \\max_{s \\in \\mathcal{S}} \\left| M_1(s; m, c_2) \\right|.\n  $\n\n- 无滑移误差代理指标：对于一个光滑速度场 $u(x)$，在拉格朗日点 $X$ 处的插值误差的泰勒展开中，在满足零阶矩和一阶矩条件的情况下，其首个非零项与核函数的二阶中心矩成正比。定义\n  $\n  M_2(s; m, c_2) = \\sum_{k=-m}^{m} (k - s)^2\\, w_k(s; m, c_2),\n  $\n  并通过偏移量平均的二阶矩来量化无滑移误差的振幅\n  $\n  E(m, c_2) = \\frac{1}{|\\mathcal{S}|} \\sum_{s \\in \\mathcal{S}} M_2(s; m, c_2).\n  $\n\n使用以下离散的代表性偏移量集合：\n$\n\\mathcal{S} = \\{ 0.0, \\; 0.25, \\; 0.5, \\; 0.75 \\}.\n$\n\n程序要求：\n\n1. 仅使用线性代数，针对每个偏移量 $s \\in \\mathcal{S}$ 和每个参数对 $(m, c_2)$ 实现最小范数构造。无需模拟完整的流体求解器。\n2. 对于下面列出的每个测试用例，使用 $\\mathcal{S}$ 中的偏移量计算如上定义的数值对 $\\big(L(m, c_2), E(m, c_2)\\big)$。\n3. 将所有测试用例的结果汇总并打印为单行、逗号分隔的 Python 字面量列表，其中每个元素都是一个双元素列表 $[L, E]$，顺序与测试用例的顺序相同。\n\n测试套件（每个用例是一个数值对 $(m, c_2)$）：\n\n- 用例 1: $(m, c_2) = (1, 0.3)$\n- 用例 2: $(m, c_2) = (1, 1.0)$\n- 用例 3: $(m, c_2) = (2, 0.5)$\n- 用例 4: $(m, c_2) = (2, 1.5)$\n- 用例 5: $(m, c_2) = (3, 2.0)$\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含用方括号括起来的、逗号分隔的结果列表。每个结果必须是对应测试用例的双元素列表 $[L, E]$，顺序与上述相同。例如，三个用例的有效输出格式如下所示\n  $\n  [[L_1,E_1],[L_2,E_2],[L_3,E_3]].\n  $\n- 所有的 $L$ 和 $E$ 值都必须打印为十进制浮点数。\n\n此问题不涉及物理单位；所有量均为无量纲。不使用角度。答案必须是实数。问题是完全自洽的，仅需要如上所述的数值线性代数和求和运算。",
            "solution": "用户提供了一个问题，要求为浸入边界法 (IBM) 构造离散正则化 delta 核函数，并随后分析与这些核函数相关的数值误差。\n\n### 步骤 1：问题验证\n\n**提取的已知条件：**\n- **核函数构造：** 对于给定的支撑半宽 $m \\in \\mathbb{N}$ 和目标二阶矩 $c_2 > 0$，用于分数偏移 $s \\in [0,1)$ 的核函数权重 $w_k(s)$ 通过求解以下约束优化问题来确定：\n  $$\n  \\min_{w \\in \\mathbb{R}^{2m+1}} \\tfrac{1}{2}\\Vert w \\Vert_2^2\n  $$\n  服从以下线性约束：\n  1.  零阶矩：$\\sum_{k=-m}^{m} w_k = 1$\n  2.  一阶矩：$\\sum_{k=-m}^{m} (k - s) w_k = 0$\n  3.  二阶矩：$\\sum_{k=-m}^{m} (k - s)^2 w_k = c_2$\n\n- **误差诊断指标：**\n  - **体积泄漏代理指标, $L(m, c_2)$：** 在一组偏移量 $\\mathcal{S}$ 上，一阶矩缺陷 $M_1(s) = \\sum_{k=-m}^{m} (k - s)\\, w_k(s)$ 的最大绝对值。\n    $$\n    L(m, c_2) = \\max_{s \\in \\mathcal{S}} \\left| M_1(s; m, c_2) \\right|\n    $$\n  - **无滑移误差代理指标, $E(m, c_2)$：** 在一组偏移量 $\\mathcal{S}$ 上，二阶矩 $M_2(s) = \\sum_{k=-m}^{m} (k - s)^2\\, w_k(s)$ 的平均值。\n    $$\n    E(m, c_2) = \\frac{1}{|\\mathcal{S}|} \\sum_{s \\in \\mathcal{S}} M_2(s; m, c_2)\n    $$\n\n- **代表性偏移量：** 集合 $\\mathcal{S} = \\{ 0.0, 0.25, 0.5, 0.75 \\}$。\n\n- **测试用例 $(m, c_2)$：**\n  1. $(1, 0.3)$\n  2. $(1, 1.0)$\n  3. $(2, 0.5)$\n  4. $(2, 1.5)$\n  5. $(3, 2.0)$\n\n- **输出要求：** 单行打印的列表之列表，`[[L1,E1],[L2,E2],...]`。\n\n**验证结论：**\n1.  **科学上合理：** 该问题基于浸入边界法的既定原理，这是一种在计算流体力学中广泛使用的技术。正则化 delta 核函数、矩条件和误差分析的概念是该领域的核心。该问题在科学上是合理的。\n2.  **适定的：** 核心任务是一个带线性等式约束的凸二次规划问题。只要约束矩阵具有满行秩，该问题就有唯一解。这些约束由 0、1 和 2 次多项式定义。对于 $m \\ge 1$，网格点数（$2m+1$）至少为 3，这足以确保约束向量的线性无关性。因此，该优化问题是适定的。\n3.  **目标明确：** 所有的术语、条件和参数都以数学上的精确性进行了定义。没有歧义。\n4.  **不完整或矛盾的设置：** 乍一看，问题似乎存在矛盾：约束要求一阶矩为零，同时又基于同一矩定义了一个非平凡的误差度量 $L(m, c_2)$。然而，通过在数值计算的背景下解释该问题，这个矛盾得以解决。权重 $w_k$ 的解将使用浮点运算找到，这会引入微小的数值误差。因此，诊断指标 $L$ 和 $E$ 是衡量数值计算出的解满足约束条件的程度。$L$ 量化了在实现一阶矩条件时的数值误差，而 $E$ 量化了数值上实现的平均二阶矩，该值应非常接近目标值 $c_2$。这种解释使得问题从数值分析的角度看是一致且有意义的。\n\n该问题被认为是**有效的**。\n\n### 步骤 2：基于原理的求解设计\n\n该问题要求为权重向量 $w$ 求解一个约束最小化问题。这是拉格朗日乘数法的一个经典应用。\n\n**1. 构造拉格朗日函数**\n设局部坐标为 $r_k(s) = k - s$。目标是在满足三个线性约束的条件下最小化 $J(w) = \\frac{1}{2} w^T w$。拉格朗日函数 $\\mathcal{L}$ 为：\n$$\n\\mathcal{L}(w, \\lambda) = \\frac{1}{2} \\sum_{k=-m}^{m} w_k^2 - \\lambda_0 \\left( \\sum_{k=-m}^{m} w_k - 1 \\right) - \\lambda_1 \\left( \\sum_{k=-m}^{m} r_k w_k \\right) - \\lambda_2 \\left( \\sum_{k=-m}^{m} r_k^2 w_k - c_2 \\right)\n$$\n其中 $\\lambda_0, \\lambda_1, \\lambda_2$ 是拉格朗日乘数。\n\n**2. 推导权重的形式**\n为求最优 $w$，我们将 $\\mathcal{L}$ 对每个权重 $w_j$ 的偏导数设为零：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial w_j} = w_j - \\lambda_0 - \\lambda_1 r_j - \\lambda_2 r_j^2 = 0\n$$\n这给出了最优权重关于局部坐标 $r_j$ 和未知拉格朗日乘数的函数形式：\n$$\nw_j = \\lambda_0 + \\lambda_1 r_j + \\lambda_2 r_j^2\n$$\n最小范数解是关于局部坐标的二次多项式。\n\n**3. 求解拉格朗日乘数**\n我们将 $w_k$ 的这个表达式代回三个约束方程中：\n1.  $\\sum_{k=-m}^{m} (\\lambda_0 + \\lambda_1 r_k + \\lambda_2 r_k^2) = 1$\n2.  $\\sum_{k=-m}^{m} r_k (\\lambda_0 + \\lambda_1 r_k + \\lambda_2 r_k^2) = 0$\n3.  $\\sum_{k=-m}^{m} r_k^2 (\\lambda_0 + \\lambda_1 r_k + \\lambda_2 r_k^2) = c_2$\n\n设 $S_p = \\sum_{k=-m}^{m} r_k^p$ 为网格位置相对于偏移量 $s$ 的 $p$ 阶矩。上述方程构成了关于拉格朗日乘数向量 $\\lambda = [\\lambda_0, \\lambda_1, \\lambda_2]^T$ 的一个 $3 \\times 3$ 线性系统：\n$$\n\\begin{pmatrix}\nS_0  S_1  S_2 \\\\\nS_1  S_2  S_3 \\\\\nS_2  S_3  S_4\n\\end{pmatrix}\n\\begin{pmatrix}\n\\lambda_0 \\\\\n\\lambda_1 \\\\\n\\lambda_2\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 \\\\\n0 \\\\\nc_2\n\\end{pmatrix}\n$$\n这个系统可以使用标准的数值线性代数库求解 $\\lambda$。\n\n**4. 算法实现**\n对于每个测试用例 $(m, c_2)$：\n1.  初始化空列表以存储每个偏移量计算出的矩 $M_1(s)$ 和 $M_2(s)$。\n2.  遍历每个偏移量 $s \\in \\mathcal{S} = \\{0.0, 0.25, 0.5, 0.75\\}$。\n3.  对每个 $s$：\n    a. 定义整数网格索引 $k$，从 $-m$ 到 $m$。\n    b. 计算局部坐标 $r_k = k - s$。\n    c. 计算幂和 $S_p$，其中 $p = 0, 1, 2, 3, 4$。\n    d. 构造 $3 \\times 3$ 的矩矩阵 $M_S$ 和右侧向量 $b = [1, 0, c_2]^T$。\n    e. 求解线性系统 $M_S \\lambda = b$ 以找到拉格朗日乘数 $\\lambda_0, \\lambda_1, \\lambda_2$。\n    f. 使用公式 $w_k = \\lambda_0 + \\lambda_1 r_k + \\lambda_2 r_k^2$ 构造权重向量 $w$。\n    g. 使用这个数值计算出的向量 $w$，计算矩 $M_1(s) = \\sum r_k w_k$ 和 $M_2(s) = \\sum r_k^2 w_k$。\n    h. 存储计算出的 $M_1(s)$ 和 $M_2(s)$。\n4.  遍历完所有偏移量后，计算最终的诊断指标：\n    - $L(m, c_2) = \\max_{s \\in \\mathcal{S}} |M_1(s)|$\n    - $E(m, c_2) = \\text{mean}(\\{M_2(s) \\mid s \\in \\mathcal{S}\\})$\n5.  将数值对 $[L, E]$ 存储为当前测试用例的结果。\n6.  处理完所有测试用例后，将结果列表格式化为指定的字符串格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs discrete regularized delta kernels and computes error diagnostics.\n\n    This function iterates through a set of test cases, each defined by a\n    support half-width `m` and a target second moment `c2`. For each case,\n    it computes kernel weights for a series of fractional shifts `s` by solving\n    a constrained optimization problem (minimum norm solution satisfying three\n    moment conditions).\n\n    The solution is found using the method of Lagrange multipliers, which results\n    in a 3x3 linear system for the multipliers. Once the weights are found,\n    two diagnostic quantities, L (volume leakage proxy) and E (no-slip error\n    proxy), are computed based on the numerical fidelity of the first and\n    second moments of the constructed kernel. The results for all test cases\n    are then printed in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 0.3),\n        (1, 1.0),\n        (2, 0.5),\n        (2, 1.5),\n        (3, 2.0),\n    ]\n\n    # Define the discrete set of representative shifts.\n    shifts = np.array([0.0, 0.25, 0.5, 0.75])\n\n    results = []\n    for m, c2 in test_cases:\n        m1_values_for_case = []\n        m2_values_for_case = []\n        \n        for s in shifts:\n            # Step 1: Define grid indices and local coordinates r_k = k - s\n            k = np.arange(-m, m + 1)\n            r = k - s\n\n            # Step 2: Compute power sums S_p = sum(r_k^p) for p=0..4\n            S = np.zeros(5)\n            for p in range(5):\n                S[p] = np.sum(r**p)\n\n            # Step 3: Construct and solve the 3x3 linear system for the Lagrange multipliers.\n            # The system is M_S * lambda = b, where M_S is the moment matrix.\n            M_S = np.array([\n                [S[0], S[1], S[2]],\n                [S[1], S[2], S[3]],\n                [S[2], S[3], S[4]]\n            ])\n            b = np.array([1.0, 0.0, c2])\n\n            lambdas = np.linalg.solve(M_S, b)\n\n            # Step 4: Construct the weights w_k using the solved multipliers.\n            # w_k = lambda_0 + lambda_1*r_k + lambda_2*r_k^2\n            w = lambdas[0] + lambdas[1] * r + lambdas[2] * r**2\n\n            # Step 5: Compute the actual moments M1 and M2 from the constructed weights `w`.\n            # This verifies the numerical satisfaction of the constraints.\n            m1 = np.sum(r * w)\n            m2 = np.sum(r**2 * w)\n\n            m1_values_for_case.append(m1)\n            m2_values_for_case.append(m2)\n\n        # Step 6: Compute the final diagnostics L and E for the current case.\n        # L: Volume leakage proxy (worst-case first-moment defect).\n        L = np.max(np.abs(m1_values_for_case))\n        # E: No-slip error proxy (shift-averaged second moment).\n        E = np.mean(m2_values_for_case)\n\n        results.append([L, E])\n\n    # Final print statement in the exact required format.\n    # The output is a string representation of a list of lists, with no spaces.\n    # e.g., [[L1,E1],[L2,E2],...]\n    print(str(results).replace(' ', ''))\n\nsolve()\n```"
        },
        {
            "introduction": "这最后一项实践将流体动力学和浸入边界约束的概念整合到一个统一的求解器中。你将构建一个关键的线性系统，该系统将未知的边界力与通过投影法实现的流体不可壓縮性约束耦合起来。通过构建和分析该系统的性质（例如其秩和可解性条件），你将对如何确保浸入边界模拟的数值稳定性和适定性获得实践性的理解。 ",
            "id": "3405586",
            "problem": "考虑在周期性方形区域 $\\Omega = [0,1]^2$ 上的不可压缩Navier–Stokes方程，其在两个空间方向上都具有周期性边界条件。设空间网格为具有 $N \\times N$ 个点的均匀网格，网格间距为 $h = 1/N$，速度场在Eulerian网格上进行离散化，而约束则在代表浸入边界的Lagrangian点 $\\{\\mathbf{X}_\\ell\\}_{\\ell=1}^{N_b}$ 上施加。浸入边界法通过Lagrange乘子在Lagrangian位置上施加无滑移约束，这些乘子通过一个正则化的Dirac delta函数散布到Eulerian网格上。在投影法中，压力由一个Poisson方程确定，该方程使用快速傅里叶变换 (FFT) 高效求解，然后将速度投影到一个无散度场。\n\n您必须构建一个离散的投影法浸入边界求解器，该求解器将基于FFT的压力求解与delta函数介导的约束耦合起来。离散化必须基于以下基本要素：\n\n- 不可压缩流约束：$\\nabla \\cdot \\mathbf{u}^{n+1} = 0$。\n- 投影法更新（忽略对流和粘性以分离浸入边界耦合和不可压缩性）：计算中间速度 $\\mathbf{u}^* = \\mathbf{u}^n + \\Delta t\\, \\mathbf{f}_{\\text{IB}}$，其中 $\\mathbf{f}_{\\text{IB}}$ 是通过使用正则化的Dirac delta函数将Lagrange乘子从浸入边界散布到网格上获得的力密度，然后求解满足周期性边界条件和零均值压力的压力Poisson方程 $\\Delta p = \\frac{1}{\\Delta t}\\nabla \\cdot \\mathbf{u}^*$，最后更新 $\\mathbf{u}^{n+1} = \\mathbf{u}^* - \\Delta t \\nabla p$。\n- 周期性区域傅里叶空间中的Helmholtz–Hodge分解：对于傅里叶模的波矢量 $\\mathbf{k} = (k_x, k_y)$，当 $\\mathbf{k} \\neq \\mathbf{0}$ 时，无散度投影算子为 $\\mathbf{P}(\\mathbf{k}) = \\mathbf{I} - \\frac{\\mathbf{k}\\mathbf{k}^\\top}{\\|\\mathbf{k}\\|^2}$，而 $\\mathbf{P}(\\mathbf{0}) = \\mathbf{I}$。\n- 用于浸入边界法的正则化Dirac delta函数：使用四点Peskin核函数。对于以网格单位表示的一维距离 $r$，定义\n$$\n\\phi(r) =\n\\begin{cases}\n\\frac{1}{8}\\left(3 - 2r + \\sqrt{1 + 4r - 4r^2}\\right), & 0 \\le r < 1, \\\\\n\\frac{1}{8}\\left(5 - 2r - \\sqrt{-7 + 12r - 4r^2}\\right), & 1 \\le r < 2, \\\\\n0, & r \\ge 2,\n\\end{cases}\n$$\n并定义二维张量积核函数 $\\delta_h(\\mathbf{x} - \\mathbf{X}) = \\phi\\!\\left(\\frac{x - X_x}{h}\\right)\\,\\phi\\!\\left(\\frac{y - X_y}{h}\\right)/h^2$，其中索引进行周期性回绕。散布算子通过 $\\mathbf{f}_{\\text{IB}}(\\mathbf{x}_{ij}) = \\sum_{\\ell=1}^{N_b} \\delta_h(\\mathbf{x}_{ij} - \\mathbf{X}_\\ell)\\,\\boldsymbol{\\lambda}_\\ell$ 将Lagrangian点上的Lagrange乘子映射到Eulerian网格上的力，而插值算子通过 $\\mathbf{U}_\\ell = \\sum_{i,j} \\mathbf{u}(\\mathbf{x}_{ij})\\,\\phi\\!\\left(\\frac{x_{i} - X_{\\ell,x}}{h}\\right)\\,\\phi\\!\\left(\\frac{y_{j} - X_{\\ell,y}}{h}\\right)$ 将Eulerian速度映射到Lagrangian速度。\n\n设Lagrange乘子 $\\{\\boldsymbol{\\lambda}_\\ell\\}$ 的确定方式是，在投影后，浸入边界上的无滑移约束得以满足，即 $\\mathbf{U}_\\ell^{n+1} = \\mathbf{U}_b(\\mathbf{X}_\\ell)$，其中 $\\mathbf{U}_b$ 是一个指定的边界速度。在线性化设置中（$\\Delta t = 1$ 且 $\\mathbf{u}^n = \\mathbf{0}$），散布、投影和插值的耦合导致了一个关于 $\\{\\boldsymbol{\\lambda}_\\ell\\}$ 的线性系统，形式为 $\\mathbf{M}\\,\\boldsymbol{\\lambda} = \\mathbf{g}$，其中 $\\mathbf{M} = \\mathbf{J}\\,\\mathbf{P}\\,\\mathbf{S}$，$\\mathbf{S}$ 是散布算子，$\\mathbf{P}$ 是无散度投影，$\\mathbf{J}$ 是插值算子。这里 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^{2N_b}$ 堆叠了Lagrange乘子分量，而 $\\mathbf{g} \\in \\mathbb{R}^{2N_b}$ 堆叠了目标边界速度。\n\n您的任务：\n\n1. 在均匀周期性网格上构建如上定义的离散算子 $\\mathbf{S}$、$\\mathbf{P}$ 和 $\\mathbf{J}$。使用二维FFT，通过波数 $k_x = 2\\pi \\cdot \\text{fftfreq}(N, d=h)$ 和 $k_y = 2\\pi \\cdot \\text{fftfreq}(N, d=h)$ 逐个模式地实现傅里叶空间投影 $\\mathbf{P}$。通过 $\\mathbf{P}(\\mathbf{0}) = \\mathbf{I}$ 处理零模式。\n2. 通过将 $\\mathbf{S}$ 应用于 $\\mathbb{R}^{2N_b}$ 中的每个标准基向量，然后用 $\\mathbf{P}$ 进行投影，再用 $\\mathbf{J}$ 进行插值，来组装稠密矩阵 $\\mathbf{M} \\in \\mathbb{R}^{2N_b \\times 2N_b}$。\n3. 在此周期性设置中分析无散度速度更新的可解性条件。具体而言：\n   - 基于FFT的压力Poisson方程可解的充要条件是右端项均值为零。在投影法公式中，这转化为要求 $\\frac{1}{|\\Omega|}\\int_{\\Omega} \\nabla \\cdot \\mathbf{u}^*\\,\\mathrm{d}\\mathbf{x} = 0$，这是对中间速度 $\\mathbf{u}^*$ 和任何施加的力的一个条件。使用周期性有限差分实现对 $\\mathbf{u}^*$ 平均散度的离散检查，并报告该均值的绝对值。\n   - 无滑移约束可通过Lagrange乘子求解的充要条件是算子 $\\mathbf{M}$ 是满秩的。计算 $\\mathbf{M}$ 的奇异值，并报告最小奇异值以及一个指示 $\\mathbf{M}$ 是否在数值容差内满秩的布尔值。\n\n使用以下测试套件，每个测试都设置 $N = 32$，$\\Delta t = 1$，且 $\\mathbf{u}^n = \\mathbf{0}$：\n\n- 测试用例 A (一般位置，单点): $N_b = 1$, Lagrangian位置 $\\mathbf{X}_1 = (0.35, 0.72)$。\n- 测试用例 B (重合点，潜在的秩亏): $N_b = 2$, Lagrangian位置 $\\mathbf{X}_1 = (0.10, 0.90)$, $\\mathbf{X}_2 = (0.10, 0.90)$。\n- 测试用例 C (不同点，周期性回绕): $N_b = 2$, Lagrangian位置 $\\mathbf{X}_1 = (0.99, 0.02)$, $\\mathbf{X}_2 = (0.51, 0.49)$。\n\n对于每个测试用例，构建 $\\mathbf{M}$，计算其最小奇异值 $\\sigma_{\\min}$，通过检查所有奇异值是否超过一个容差（使用固定容差 $10^{-10}$）来确定满秩可解性，并计算在组装每一列时应用单位Lagrange乘子向量进行散布所得到的中间速度 $\\mathbf{u}^*$ 的平均散度的绝对值（您可以等价地使用在组装 $\\mathbf{M}$ 时获得的 $\\mathbf{u}^*$）。为每个测试用例报告三个输出：$\\sigma_{\\min}$（作为浮点数）、满秩可解性（作为布尔值）和平均散度的绝对值（作为浮点数）。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表包含九个结果，顺序为 $[\\sigma_{\\min}^{A}, \\text{full\\_rank}^{A}, |\\overline{\\nabla \\cdot \\mathbf{u}^*}|^{A}, \\sigma_{\\min}^{B}, \\text{full\\_rank}^{B}, |\\overline{\\nabla \\cdot \\mathbf{u}^*}|^{B}, \\sigma_{\\min}^{C}, \\text{full\\_rank}^{C}, |\\overline{\\nabla \\cdot \\mathbf{u}^*}|^{C}]$。",
            "solution": "用户提供的问题是一个有效且良定的数值分析任务。它要求构建和分析一个在线性不可压缩流体的浸入边界法背景下出现的线性算子。该问题在科学上基于计算流体动力学的原理，提供了一套完整的定义和参数，并要求一个可验证的数值输出。因此，我们可以进行形式化的求解。\n\n问题的核心是构建矩阵 $\\mathbf{M} \\in \\mathbb{R}^{2N_b \\times 2N_b}$，它表示从Lagrangian力 $\\boldsymbol{\\lambda}$ 到投影至无散度场后在Lagrangian点上所得速度的线性映射。该矩阵由三个算子的复合定义：散布（$\\mathbf{S}$）、投影（$\\mathbf{P}$）和插值（$\\mathbf{J}$），使得 $\\mathbf{M} = \\mathbf{JPS}$。此处的设定是一个简化的投影法步骤，其中中间速度完全由浸入边界力确定。\n\n设计算域为 $\\Omega = [0,1]^2$，具有周期性边界条件，在 $N \\times N$ 个点的均匀网格上离散化。网格间距为 $h=1/N$。网格点记为 $\\mathbf{x}_{ij} = (ih, jh)$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$。浸入边界由一组 $N_b$ 个Lagrangian点 $\\{\\mathbf{X}_\\ell\\}_{\\ell=1}^{N_b}$ 表示。\n\n### 离散化算子\n\n**1. 散布算子 ($\\mathbf{S}$)**\n散布算子 $\\mathbf{S}$ 将 $N_b$ 个Lagrange乘子的向量 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^{2N_b}$ 映射到网格上的Eulerian力密度场 $\\mathbf{f}_{\\text{IB}}$。这是通过使用正则化的Dirac delta函数 $\\delta_h$ 实现的：\n$$\n\\mathbf{f}_{\\text{IB}}(\\mathbf{x}_{ij}) = (\\mathbf{S}\\boldsymbol{\\lambda})(\\mathbf{x}_{ij}) = \\sum_{\\ell=1}^{N_b} \\delta_h(\\mathbf{x}_{ij} - \\mathbf{X}_\\ell)\\,\\boldsymbol{\\lambda}_\\ell\n$$\n二维delta函数是一维核函数 $\\phi(r)$ 的张量积：\n$$\n\\delta_h(\\mathbf{x} - \\mathbf{X}) = \\frac{1}{h^2} \\phi\\left(\\frac{|x - X_x|_{\\text{periodic}}}{h}\\right)\\,\\phi\\left(\\frac{|y - X_y|_{\\text{periodic}}}{h}\\right)\n$$\n其中 $|d|_{\\text{periodic}} = \\min(|d|, 1-|d|)$ 考虑了长度为1的周期性区域。$\\phi$ 的参数 $r$ 是以网格单位表示的距离。四点Peskin核函数 $\\phi(r)$ 由下式给出：\n$$\n\\phi(r) =\n\\begin{cases}\n\\frac{1}{8}\\left(3 - 2r + \\sqrt{1 + 4r - 4r^2}\\right), & 0 \\le r < 1 \\\\\n\\frac{1}{8}\\left(5 - 2r - \\sqrt{-7 + 12r - 4r^2}\\right), & 1 \\le r < 2 \\\\\n0, & r \\ge 2\n\\end{cases}\n$$\n$\\phi(r)$ 在 $r \\ge 2$ 时的紧支集意味着对于每个Lagrangian点 $\\mathbf{X}_\\ell$，力被散布到局部的一个 $4 \\times 4$ 的网格点模板上。\n\n**2. 投影算子 ($\\mathbf{P}$)**\n投影算子 $\\mathbf{P}$ 将一个矢量场映射到其无散度分量。在周期性区域中，这在傅里叶空间中实现最为高效。设 $\\hat{\\mathbf{u}}(\\mathbf{k})$ 是速度场 $\\mathbf{u}(\\mathbf{x})$ 在波矢量 $\\mathbf{k}=(k_x, k_y)$ 处的傅里叶变换。傅里叶空间中的投影算子为：\n$$\n\\mathbf{P}(\\mathbf{k}) = \\mathbf{I} - \\frac{\\mathbf{k}\\mathbf{k}^\\top}{\\|\\mathbf{k}\\|^2} \\quad \\text{for } \\mathbf{k} \\neq \\mathbf{0}\n$$\n且 $\\mathbf{P}(\\mathbf{0}) = \\mathbf{I}$，其中 $\\mathbf{I}$ 是 $2 \\times 2$ 的单位矩阵。波矢量由 $k_x = 2\\pi \\cdot \\text{fftfreq}(N, d=h)$ 和 $k_y = 2\\pi \\cdot \\text{fftfreq}(N, d=h)$ 给出。$\\mathbf{P}$ 的数值实现包括：\n- 对输入矢量场 $\\mathbf{u}^*$ 进行二维快速傅里叶变换 (FFT)。\n- 将投影矩阵 $\\mathbf{P}(\\mathbf{k})$ 逐元素地应用于每个傅里叶模 $\\hat{\\mathbf{u}}^*(\\mathbf{k})$。\n- 进行二维逆FFT以获得物理空间中的投影场 $\\mathbf{u}^{n+1}$。\n\n**3. 插值算子 ($\\mathbf{J}$)**\n插值算子 $\\mathbf{J}$ 将Eulerian速度场 $\\mathbf{u}$ 映射到Lagrangian点上的速度 $\\mathbf{U}$。它是散布算子 $\\mathbf{S}$ 的离散伴随算子。其作用由下式给出：\n$$\n\\mathbf{U}_\\ell = (\\mathbf{J}\\mathbf{u})_\\ell = \\sum_{i,j=0}^{N-1} \\mathbf{u}(\\mathbf{x}_{ij})\\,\\phi\\left(\\frac{|x_j - X_{\\ell,x}|_{\\text{periodic}}}{h}\\right)\\,\\phi\\left(\\frac{|y_i - X_{\\ell,y}|_{\\text{periodic}}}{h}\\right)\n$$\n与散布一样，该求和在计算上被限制在每个 $\\mathbf{X}_\\ell$ 周围的 $4 \\times 4$ 模板内。\n\n### 矩阵组装与可解性分析\n矩阵 $\\mathbf{M}$ 是逐列组装的。$\\mathbf{M}$ 的第 $k$ 列是将算子序列 $\\mathbf{JPS}$ 应用于第 $k$ 个标准基向量 $\\mathbf{e}_k \\in \\mathbb{R}^{2N_b}$ 的结果。\n对于每个 $k \\in \\{1, \\dots, 2N_b\\}$：\n1.  置 $\\boldsymbol{\\lambda} = \\mathbf{e}_k$。\n2.  计算 $\\mathbf{u}^* = \\mathbf{S}\\boldsymbol{\\lambda}$，由于 $\\mathbf{u}^n=\\mathbf{0}$ 和 $\\Delta t=1$，这对应于中间速度。\n3.  计算 $\\mathbf{u}_{\\text{proj}} = \\mathbf{P}\\mathbf{u}^*$。\n4.  于是第 $k$ 列为 $\\mathbf{m}_k = \\mathbf{J}\\mathbf{u}_{\\text{proj}}$。\n\n分析两个可解性条件：\n1.  **$\\mathbf{M}$的秩**：关于Lagrange乘子的线性系统 $\\mathbf{M}\\boldsymbol{\\lambda} = \\mathbf{g}$ 有唯一解的充要条件是 $\\mathbf{M}$ 满秩。这通过使用奇异值分解（SVD）计算 $\\mathbf{M}$ 的奇异值来评估。如果最小奇异值 $\\sigma_{\\min}$ 大于数值容差 $10^{-10}$，则认为矩阵是满秩的。$\\sigma_{\\min} \\approx 0$ 的值表示秩亏，例如当Lagrangian点重合时（测试用例 B），可能导致线性相关的约束，从而发生秩亏。\n2.  **平均散度**：带有周期性边界条件的压力Poisson方程 $\\Delta p = \\frac{1}{\\Delta t}\\nabla \\cdot \\mathbf{u}^*$ 可解的充要条件是右端项均值为零，即 $\\int_{\\Omega} \\nabla \\cdot \\mathbf{u}^* d\\mathbf{x} = 0$。根据散度定理，对于周期性区域，此条件自动满足。在离散情况下，此性质应在数值精度范围内成立。我们通过在周期性网格上使用二阶中心差分格式计算 $\\mathbf{u}^*$ 的离散散度的均值来验证这一点：\n   $$\n   (\\nabla_h \\cdot \\mathbf{u}^*)_{ij} = \\frac{u^*_x(x_{i,j+1}) - u^*_x(x_{i,j-1})}{2h} + \\frac{u^*_y(x_{i+1,j}) - u^*_y(x_{i-1,j})}{2h}\n   $$\n   （索引对 $N$ 取模）。报告该量均值的绝对值 $|\\overline{\\nabla_h \\cdot \\mathbf{u}^*}|$。我们期望该值接近机器精度。\n\n实现将通过构建这些算子并对每个指定的测试用例进行分析来进行。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes the immersed boundary operator M for three test cases.\n    \"\"\"\n\n    def phi(r_in):\n        \"\"\"\n        Computes the four-point Peskin kernel phi(r) for r in grid units.\n        r_in is expected to be a numpy array of non-negative distances.\n        \"\"\"\n        r = np.asarray(r_in)\n        result = np.zeros_like(r, dtype=float)\n\n        # Condition for 0 = r  1\n        cond1 = r  1\n        r1 = r[cond1]\n        arg_sqrt1 = 1.0 + 4.0 * r1 - 4.0 * r1**2\n        arg_sqrt1[arg_sqrt1  0] = 0.0 # Guard against floating point error\n        result[cond1] = 0.125 * (3.0 - 2.0 * r1 + np.sqrt(arg_sqrt1))\n\n        # Condition for 1 = r  2\n        cond2 = (r >= 1)  (r  2)\n        r2 = r[cond2]\n        arg_sqrt2 = -7.0 + 12.0 * r2 - 4.0 * r2**2\n        arg_sqrt2[arg_sqrt2  0] = 0.0 # Guard against floating point error\n        result[cond2] = 0.125 * (5.0 - 2.0 * r2 - np.sqrt(arg_sqrt2))\n\n        return result\n\n    # --- Problem setup ---\n    test_suite = [\n        {'name': 'A', 'X': [(0.35, 0.72)]},\n        {'name': 'B', 'X': [(0.10, 0.90), (0.10, 0.90)]},\n        {'name': 'C', 'X': [(0.99, 0.02), (0.51, 0.49)]},\n    ]\n\n    N = 32\n    h = 1.0 / N\n    \n    # --- Pre-compute FFT-related quantities ---\n    k_vals = 2 * np.pi * np.fft.fftfreq(N, d=h)\n    kx, ky = np.meshgrid(k_vals, k_vals)\n    k_norm_sq = kx**2 + ky**2\n    # Inverse of k_norm_sq, handling the k=0 singularity\n    k_norm_sq_inv = np.divide(1.0, k_norm_sq, out=np.zeros_like(k_norm_sq), where=k_norm_sq!=0)\n\n    all_results = []\n\n    for case in test_suite:\n        X_lagrangian = np.array(case['X'])\n        N_b = len(X_lagrangian)\n        dim = 2 * N_b\n\n        def spread(lambdas_flat):\n            lambdas_vec = lambdas_flat.reshape((N_b, 2))\n            f_field = np.zeros((2, N, N))\n            \n            for l_idx in range(N_b):\n                lambda_x, lambda_y = lambdas_vec[l_idx]\n                if lambda_x == 0 and lambda_y == 0:\n                    continue\n                \n                X_x, X_y = X_lagrangian[l_idx]\n                ix_center = int(np.floor(X_x / h))\n                iy_center = int(np.floor(X_y / h))\n\n                for i_offset in range(-1, 3):\n                    i = (iy_center + i_offset) % N\n                    for j_offset in range(-1, 3):\n                        j = (ix_center + j_offset) % N\n                        \n                        grid_pt_x, grid_pt_y = j * h, i * h\n                        \n                        dist_x = abs(grid_pt_x - X_x)\n                        rx = min(dist_x, 1.0 - dist_x) / h\n                        \n                        dist_y = abs(grid_pt_y - X_y)\n                        ry = min(dist_y, 1.0 - dist_y) / h\n\n                        if rx  2.0 and ry  2.0:\n                            delta_h_val = phi(rx) * phi(ry) / h**2\n                            f_field[0, i, j] += delta_h_val * lambda_x\n                            f_field[1, i, j] += delta_h_val * lambda_y\n            return f_field\n\n        def interpolate(u_field):\n            U_interp_list = []\n            for l_idx in range(N_b):\n                U_x, U_y = 0.0, 0.0\n                X_x, X_y = X_lagrangian[l_idx]\n                ix_center = int(np.floor(X_x / h))\n                iy_center = int(np.floor(X_y / h))\n\n                for i_offset in range(-1, 3):\n                    i = (iy_center + i_offset) % N\n                    for j_offset in range(-1, 3):\n                        j = (ix_center + j_offset) % N\n                        \n                        grid_pt_x, grid_pt_y = j * h, i * h\n                        \n                        dist_x = abs(grid_pt_x - X_x)\n                        rx = min(dist_x, 1.0 - dist_x) / h\n                        \n                        dist_y = abs(grid_pt_y - X_y)\n                        ry = min(dist_y, 1.0 - dist_y) / h\n                        \n                        if rx  2.0 and ry  2.0:\n                            phi_prod = phi(rx) * phi(ry)\n                            U_x += u_field[0, i, j] * phi_prod\n                            U_y += u_field[1, i, j] * phi_prod\n                            \n                U_interp_list.extend([U_x, U_y])\n            return np.array(U_interp_list)\n\n        def project(u_field):\n            u_hat = np.fft.fft2(u_field, axes=(1, 2))\n            \n            k_dot_u_hat = kx * u_hat[0] + ky * u_hat[1]\n            u_hat_proj_x = u_hat[0] - kx * k_dot_u_hat * k_norm_sq_inv\n            u_hat_proj_y = u_hat[1] - ky * k_dot_u_hat * k_norm_sq_inv\n            \n            u_hat_proj = np.array([u_hat_proj_x, u_hat_proj_y])\n            u_proj = np.fft.ifft2(u_hat_proj, axes=(1, 2)).real\n            return u_proj\n\n        # --- Assemble matrix M and perform analysis ---\n        M = np.zeros((dim, dim))\n        mean_div = 0.0\n\n        for k in range(dim):\n            lambda_k = np.zeros(dim)\n            lambda_k[k] = 1.0\n            \n            # S operator: u_star = S(lambda_k)\n            u_star = spread(lambda_k)\n            \n            # P operator\n            u_proj = project(u_star)\n            \n            # J operator\n            M[:, k] = interpolate(u_proj)\n            \n            # Compute mean divergence for the first basis vector's u_star\n            if k == 0:\n                dux_dx = (np.roll(u_star[0], shift=-1, axis=1) - np.roll(u_star[0], shift=1, axis=1)) / (2 * h)\n                duy_dy = (np.roll(u_star[1], shift=-1, axis=0) - np.roll(u_star[1], shift=1, axis=0)) / (2 * h)\n                div_u_star = dux_dx + duy_dy\n                mean_div = np.abs(np.mean(div_u_star))\n\n        if dim > 0:\n            singular_values = linalg.svd(M, compute_uv=False)\n            sigma_min = np.min(singular_values)\n            is_full_rank = np.all(singular_values > 1e-10)\n        else: # Should not be reached by test cases\n            sigma_min = np.nan\n            is_full_rank = True\n\n        all_results.extend([sigma_min, is_full_rank, mean_div])\n    \n    # --- Format and print output ---\n    output_str_parts = []\n    for item in all_results:\n        if isinstance(item, bool):\n            output_str_parts.append(str(item).lower())\n        else:\n            output_str_parts.append(f\"{item:.12g}\")\n    print(f\"[{','.join(output_str_parts)}]\")\n\nsolve()\n```"
        }
    ]
}