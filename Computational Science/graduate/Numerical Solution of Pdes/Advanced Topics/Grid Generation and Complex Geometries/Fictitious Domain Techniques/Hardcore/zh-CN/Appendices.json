{
    "hands_on_practices": [
        {
            "introduction": "数值求解任何偏微分方程的第一步是建立一个正确的弱形式。对于材料属性不连续的界面问题，这一步尤为关键。本练习将指导您推导一个带尖锐界面的扩散问题的变分形式，然后构建一个对称的Nitsche型公式，这是像切割有限元法(CutFEM)这类现代虚拟区域方法的重要基石，它允许网格与几何边界不重合。",
            "id": "3392239",
            "problem": "考虑一个背景域$\\tilde{\\Omega} = (0,1)^{2}$，其中嵌入了一个光滑界面$\\Gamma = \\{(x,y)\\in \\tilde{\\Omega}: x=\\alpha\\}$，$\\alpha \\in (0,1)$是一个固定值。物理介质由两个子域构成：$\\Omega_{1}=\\{(x,y)\\in \\tilde{\\Omega}: x\\alpha\\}$和$\\Omega_{2}=\\{(x,y)\\in \\tilde{\\Omega}: x\\alpha\\}$，它们分别被具有分片常数扩散系数的材料占据，$\\Omega_{1}$中的扩散系数为$\\kappa_{1}0$，$\\Omega_{2}$中的为$\\kappa_{2}0$。考虑以下椭圆界面问题：\n$$\n-\\nabla\\cdot(\\kappa \\nabla u)=f \\quad \\text{在 } \\Omega_{1}\\cup \\Omega_{2} \\text{ 中}, \\qquad \\kappa|_{\\Omega_{i}}=\\kappa_{i},\n$$\n在$\\partial \\tilde{\\Omega}$上有齐次诺伊曼(Neumann)边界条件，在$\\Gamma$上有界面条件：\n$$\n[u]=0, \\qquad [\\kappa \\partial_{n} u]=0,\n$$\n其中$[w]=w_{1}-w_{2}$表示从$\\Omega_{1}$侧到$\\Omega_{2}$侧的迹的跳跃，$\\partial_{n}$是相对于$\\Omega_{1}$的单位外法向量的法向导数。\n\n任务 A. 从强形式以及跳跃和法向迹的定义出发，通过在每个$\\Omega_{i}$上进行分部积分并引入界面条件，推导出一个一致的弱（变分）形式。您必须明确指出函数空间以及双线性和线性形式。\n\n任务 B. 指出如何在切割有限元法（CutFEM）中实现此形式，即在不贴合界面$\\Gamma$的网格上。具体来说，写出一个对称的 Nitsche 型非贴合双线性形式，该形式通过以下方式弱施加界面条件：\n- 通量的加权平均$\\{\\kappa \\partial_{n} w\\}_{\\omega}=\\omega_{1}\\kappa_{1}\\partial_{n} w_{1}+\\omega_{2}\\kappa_{2}\\partial_{n} w_{2}$，其中包含界面法向导数$\\partial_{n} w_{i}$和满足$\\omega_{1}+\\omega_{2}=1$的权重$\\omega_{1},\\omega_{2}$，\n- 一个罚项，其形式为调和平均$\\kappa_{H}=\\dfrac{2\\kappa_{1}\\kappa_{2}}{\\kappa_{1}+\\kappa_{2}}$除以局部网格尺寸$h$，并乘以一个正常数$\\gamma$，以及\n- 一个作用于被$\\Gamma$切割的单元面上的鬼点罚（ghost-penalty）稳定项$g_{h}(\\cdot,\\cdot)$。\n\n您必须根据$\\kappa_{1},\\kappa_{2}$指定权重$\\omega_{1},\\omega_{2}$的一个鲁棒选择，并指出罚项的尺度。假设$f\\in L^{2}(\\tilde{\\Omega})$，并在背景网格上使用标准连续分片仿射试探和检验空间。\n\n任务 C. 令$\\varphi(x,y)=x$。在任务 B 中 CutFEM 使用的不连续有限元空间中，令试探函数和检验函数均等于$\\varphi$。在对称 Nitsche 选择、调和加权以及惩罚$\\Gamma$邻域内内部面法向导数跳跃的标准鬼点罚条件下，计算您在任务 B 中写出的离散双线性形式$a_{h}(\\varphi,\\varphi)$的值，并将其表示为一个仅依赖于$\\kappa_{1}$、$\\kappa_{2}$和$\\alpha$的闭式表达式。请将您的最终答案表述为单个简化的解析表达式。不需要四舍五入，也无需报告物理单位。",
            "solution": "该问题是适定的，包含三个关于椭圆界面问题的变分形式和数值处理的相关任务。我们将按顺序处理每个任务。\n\n## 任务 A：弱形式的推导\n\n问题的强形式由下式给出：\n$$\n-\\nabla\\cdot(\\kappa \\nabla u)=f \\quad \\text{在 } \\Omega_{1}\\cup \\Omega_{2} \\text{ 中}\n$$\n在$\\partial\\tilde{\\Omega}$上有齐次诺伊曼(Neumann)边界条件，在$\\Gamma$上有界面条件：\n$$\n[u] = u_{1}-u_{2}=0, \\qquad [\\kappa \\partial_{n} u] = \\kappa_{1} \\partial_{n} u_{1} - \\kappa_{2} \\partial_{n} u_{2}=0\n$$\n为了推导弱形式，我们从一个尚待确定的函数空间$V$中选择一个合适的检验函数$v$。我们将偏微分方程（PDE）乘以$v$并在域$\\tilde{\\Omega}=\\Omega_{1} \\cup \\Omega_{2}$上积分：\n$$\n-\\int_{\\Omega_{1} \\cup \\Omega_{2}} (\\nabla\\cdot(\\kappa \\nabla u)) v \\, d\\mathbf{x} = \\int_{\\Omega_{1} \\cup \\Omega_{2}} f v \\, d\\mathbf{x}\n$$\n我们对左侧应用格林(Green)第一恒等式（分部积分）。由于扩散系数$\\kappa$在界面$\\Gamma$上是不连续的，我们必须在每个子域$\\Omega_{1}$和$\\Omega_{2}$上分别进行积分：\n$$\n-\\int_{\\Omega_{1}} (\\nabla\\cdot(\\kappa_{1} \\nabla u)) v \\, d\\mathbf{x} - \\int_{\\Omega_{2}} (\\nabla\\cdot(\\kappa_{2} \\nabla u)) v \\, d\\mathbf{x} = \\int_{\\tilde{\\Omega}} f v \\, d\\mathbf{x}\n$$\n对每个子域应用恒等式$\\int_{\\Omega} (\\nabla \\cdot \\mathbf{F}) \\phi \\, d\\mathbf{x} = -\\int_{\\Omega} \\mathbf{F} \\cdot \\nabla\\phi \\, d\\mathbf{x} + \\int_{\\partial\\Omega} (\\mathbf{F} \\cdot \\mathbf{n}) \\phi \\, dS$，其中$\\mathbf{F} = \\kappa \\nabla u$：\n$$\n\\int_{\\Omega_{1}} \\kappa_{1} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} - \\int_{\\partial\\Omega_{1}} \\kappa_{1} (\\nabla u \\cdot \\mathbf{n}_{1}) v \\, dS + \\int_{\\Omega_{2}} \\kappa_{2} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} - \\int_{\\partial\\Omega_{2}} \\kappa_{2} (\\nabla u \\cdot \\mathbf{n}_{2}) v \\, dS = \\int_{\\tilde{\\Omega}} f v \\, d\\mathbf{x}\n$$\n此处，$\\mathbf{n}_{i}$是$\\Omega_i$的单位外法向量。子域的边界为$\\partial\\Omega_{1} = (\\partial\\tilde{\\Omega} \\cap \\partial\\Omega_{1}) \\cup \\Gamma$和$\\partial\\Omega_{2} = (\\partial\\tilde{\\Omega} \\cap \\partial\\Omega_{2}) \\cup \\Gamma$。$\\Gamma$上的法向量$\\mathbf{n}$定义为$\\Omega_1$的外法向量，因此在$\\Gamma$上我们有$\\mathbf{n}_{1}=\\mathbf{n}$和$\\mathbf{n}_{2}=-\\mathbf{n}$。\n边界积分可以拆分为：\n$$\n\\int_{\\partial\\Omega_{1}} \\dots + \\int_{\\partial\\Omega_{2}} \\dots = \\int_{\\partial\\tilde{\\Omega}} \\kappa \\partial_{n}u v \\, dS + \\int_{\\Gamma} \\kappa_{1} \\partial_{n_{1}}u_{1} v_{1} \\, dS + \\int_{\\Gamma} \\kappa_{2} \\partial_{n_{2}}u_{2} v_{2} \\, dS\n$$\n在$\\Gamma$上使用$\\partial_{n_1} = \\partial_n$和$\\partial_{n_2} = -\\partial_n$，界面积分部分变为：\n$$\n\\int_{\\Gamma} (\\kappa_{1} \\partial_{n} u_{1} v_{1} - \\kappa_{2} \\partial_{n} u_{2} v_{2}) \\, dS\n$$\n问题指定了在外部边界$\\partial\\tilde{\\Omega}$上的齐次诺伊曼边界条件，这意味着在$\\partial\\tilde{\\Omega}$上$\\kappa \\partial_{n}u = 0$。因此，$\\int_{\\partial\\tilde{\\Omega}} \\kappa \\partial_{n}u v \\, dS = 0$。\n方程现在变为：\n$$\n\\int_{\\tilde{\\Omega}} \\kappa \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} - \\int_{\\Gamma} (\\kappa_{1} \\partial_{n} u_{1} v_{1} - \\kappa_{2} \\partial_{n} u_{2} v_{2}) \\, dS = \\int_{\\tilde{\\Omega}} f v \\, d\\mathbf{x}\n$$\n我们现在选择函数空间$V$来处理界面条件。对于协调方法，一个自然的选择是函数在界面上连续的空间，例如$V=H^{1}(\\tilde{\\Omega})$。对于任何函数$w \\in H^{1}(\\tilde{\\Omega})$，其在$\\Gamma$两侧的迹是相等的，即$w_1 = w_2$。因此，对于我们的解$u$和检验函数$v$，我们自然地施加了$[u]=0$并有$[v]=0$。界面积分简化为：\n$$\n- \\int_{\\Gamma} (\\kappa_{1} \\partial_{n} u_{1} - \\kappa_{2} \\partial_{n} u_{2}) v \\, dS = - \\int_{\\Gamma} [\\kappa \\partial_n u] v \\, dS\n$$\n使用第二个界面条件$[\\kappa \\partial_{n} u] = 0$，该积分为零。\n我们得到最终的弱形式：求$u \\in V = H^{1}(\\tilde{\\Omega})$，使得\n$$\n\\int_{\\tilde{\\Omega}} \\kappa \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = \\int_{\\tilde{\\Omega}} f v \\, d\\mathbf{x} \\quad \\forall v \\in V\n$$\n函数空间为$V=H^{1}(\\tilde{\\Omega})$。\n双线性形式为$a(u,v) = \\int_{\\tilde{\\Omega}} \\kappa \\nabla u \\cdot \\nabla v \\, d\\mathbf{x}$。\n线性形式为$l(v) = \\int_{\\tilde{\\Omega}} f v \\, d\\mathbf{x}$。\n对于纯诺伊曼问题，若$\\int_{\\tilde{\\Omega}} f \\, d\\mathbf{x} = 0$，则解存在，且解在相差一个加性常数的意义下唯一。为确保唯一性，可以将空间$V$限制为零均值函数，即$V = \\{ v \\in H^1(\\tilde{\\Omega}) : \\int_{\\tilde{\\Omega}} v \\, d\\mathbf{x} = 0 \\}$。\n\n## 任务 B：CutFEM Nitsche 型形式\n\n在切割有限元法（CutFEM）中，有限元网格$\\mathcal{T}_{h}$并不贴合界面$\\Gamma$。试探函数和检验函数$u_h, v_h$取自$\\mathcal{T}_h$上的标准有限元空间$V_h$（例如，连续分片仿射函数），但在形式中它们被视为在$\\Gamma$上是不连续的。界面条件通过 Nitsche 的方法弱施加。\n\n一个对称的 Nitsche 型双线性形式$a_h(u,v)$弱施加$\\Gamma$上的条件$[u]=0$和$[\\kappa \\partial_n u]=0$，其构造如下：\n$$\na_{h}(u,v) = \\int_{\\Omega_{1} \\cup \\Omega_{2}} \\kappa \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} - \\int_{\\Gamma} \\{\\kappa \\partial_{n} u\\}_{\\omega} [v] \\, dS - \\int_{\\Gamma} \\{\\kappa \\partial_{n} v\\}_{\\omega} [u] \\, dS + \\int_{\\Gamma} \\frac{\\gamma \\kappa_{H}}{h} [u][v] \\, dS + g_{h}(u,v)\n$$\n此形式的组成部分为：\n1.  **体项：** $\\int_{\\Omega_{1} \\cup \\Omega_{2}} \\kappa \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = \\int_{\\Omega_{1}} \\kappa_{1} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} + \\int_{\\Omega_{2}} \\kappa_{2} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x}$。这是标准的能量项，在被界面切割的单元部分上积分。\n2.  **一致性项：** 两个涉及加权平均通量的积分，$-\\int_{\\Gamma} \\{\\kappa \\partial_{n} u\\}_{\\omega} [v] \\, dS$ 和 $-\\int_{\\Gamma} \\{\\kappa \\partial_{n} v\\}_{\\omega} [u] \\, dS$。这些项施加了界面条件。通过这种配对构造，形式是对称的。\n    *   跳跃定义为$[w] = w_1 - w_2$。\n    *   加权平均通量为$\\{\\kappa \\partial_{n} w\\}_{\\omega} = \\omega_{1}\\kappa_{1}\\partial_{n} w_{1}+\\omega_{2}\\kappa_{2}\\partial_{n} w_{2}$，其中权重$\\omega_1, \\omega_2$满足$\\omega_1 + \\omega_2 = 1$。\n3.  **罚项：** $\\int_{\\Gamma} \\frac{\\gamma \\kappa_{H}}{h} [u][v] \\, dS$。此项惩罚解的跳跃$[u]$，对方法的稳定性和矫顽性至关重要。\n    *   $\\gamma > 0$是一个用户定义的、足够大的罚参数。\n    *   $h$是界面处的局部网格尺寸。罚项的尺度为$h^{-1}$。\n    *   $\\kappa_{H} = \\dfrac{2\\kappa_{1}\\kappa_{2}}{\\kappa_{1}+\\kappa_{2}}$是扩散系数的调和平均。\n4.  **鬼点罚（Ghost-penalty）稳定项：** $g_{h}(u,v)$。此项用于控制由小单元切割引起的不稳定性。它作用于被$\\Gamma$切割的单元的面，通常惩罚梯度的跳跃。例如，$g_h(u,v) = \\sum_{F \\in \\mathcal{F}_h^\\Gamma} \\int_F \\beta h^\\sigma [[\\nabla u \\cdot \\mathbf{n}_F]] [[\\nabla v \\cdot \\mathbf{n}_F]] dS$，其中$\\beta, \\sigma$是常数，$\\mathcal{F}_h^\\Gamma$是被$\\Gamma$切割的单元的内部面集合。\n\n对于权重$\\omega_1, \\omega_2$的一个鲁棒选择，特别是对于高对比度系数，是**调和加权**：\n$$\n\\omega_{1} = \\frac{\\kappa_{2}}{\\kappa_{1}+\\kappa_{2}}, \\qquad \\omega_{2} = \\frac{\\kappa_{1}}{\\kappa_{1}+\\kappa_{2}}\n$$\n这种选择确保了方法的稳定性与比率$\\kappa_1/\\kappa_2$无关。\n\n## 任务 C：$a_{h}(\\varphi,\\varphi)$ 的计算\n\n我们被要求计算$a_{h}(\\varphi,\\varphi)$，其中试探函数和检验函数为$\\varphi(x,y) = x$。我们使用$u=v=\\varphi$来分析任务 B 中双线性形式$a_{h}$的每一项。\n\n首先，我们计算与$\\varphi(x,y)=x$相关的量：\n*   梯度是一个常向量：$\\nabla \\varphi = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。\n*   界面$\\Gamma$是直线$x=\\alpha$，其中$y \\in (0,1)$。$\\Omega_1$在$\\Gamma$上的单位外法向量是$\\mathbf{n} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。\n*   $\\varphi$在$\\Gamma$的$\\Omega_1$侧的迹是$\\varphi_1 = \\varphi(\\alpha,y) = \\alpha$。\n*   $\\varphi$在$\\Gamma$的$\\Omega_2$侧的迹是$\\varphi_2 = \\varphi(\\alpha,y) = \\alpha$。\n*   $\\varphi$跨越$\\Gamma$的跳跃是$[\\varphi] = \\varphi_1 - \\varphi_2 = \\alpha - \\alpha = 0$。\n*   $\\Gamma$上的法向导数是$\\partial_n \\varphi = \\nabla \\varphi \\cdot \\mathbf{n} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\cdot \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = 1$。这个值对于两侧的迹都是相同的：$\\partial_n \\varphi_1 = 1$和$\\partial_n \\varphi_2 = 1$。\n\n现在我们计算$a_{h}(\\varphi,\\varphi)$中的五个项：\n1.  **体项：**\n    $$\n    \\int_{\\Omega_{1} \\cup \\Omega_{2}} \\kappa \\nabla \\varphi \\cdot \\nabla \\varphi \\, d\\mathbf{x} = \\int_{\\Omega_{1}} \\kappa_{1} |\\nabla \\varphi|^2 \\, d\\mathbf{x} + \\int_{\\Omega_{2}} \\kappa_{2} |\\nabla \\varphi|^2 \\, d\\mathbf{x}\n    $$\n    由于$|\\nabla \\varphi|^2 = 1^2 + 0^2 = 1$，积分变为：\n    $$\n    \\kappa_{1} \\int_{\\Omega_{1}} 1 \\, d\\mathbf{x} + \\kappa_{2} \\int_{\\Omega_{2}} 1 \\, d\\mathbf{x} = \\kappa_{1} \\cdot \\text{Area}(\\Omega_{1}) + \\kappa_{2} \\cdot \\text{Area}(\\Omega_{2})\n    $$\n    域$\\Omega_1 = (0,\\alpha) \\times (0,1)$的面积为$\\alpha$。域$\\Omega_2 = (\\alpha, 1) \\times (0,1)$的面积为$1-\\alpha$。所以体项的计算结果为：\n    $$\n    \\kappa_{1}\\alpha + \\kappa_{2}(1-\\alpha)\n    $$\n2.  **一致性项：** 形式中包含两个这样的项$-\\int_{\\Gamma} \\{\\kappa \\partial_{n} \\varphi\\}_{\\omega} [\\varphi] \\, dS$。因为我们计算出跳跃$[\\varphi] = 0$，所以这两项都为零：\n    $$\n    - \\int_{\\Gamma} \\{\\kappa \\partial_{n} \\varphi\\}_{\\omega} [\\varphi] \\, dS = - \\int_{\\Gamma} \\{\\kappa \\partial_{n} \\varphi\\}_{\\omega} \\cdot 0 \\, dS = 0\n    $$\n3.  **罚项：** 罚项是$\\int_{\\Gamma} \\frac{\\gamma \\kappa_{H}}{h} [\\varphi][\\varphi] \\, dS = \\int_{\\Gamma} \\frac{\\gamma \\kappa_{H}}{h} [\\varphi]^2 \\, dS$。同样，由于$[\\varphi]=0$，此项为零：\n    $$\n    \\int_{\\Gamma} \\frac{\\gamma \\kappa_{H}}{h} (0)^2 \\, dS = 0\n    $$\n4.  **鬼点罚（Ghost-penalty）稳定项：** $g_h(\\varphi,\\varphi)$项惩罚$\\varphi$的法向导数在内部单元面上的跳跃。由于$\\varphi(x,y)=x$是一个全局线性函数，其梯度$\\nabla\\varphi = (1,0)$处处为常数。因此，其梯度（以及其法向导数）在任何面上的跳跃都为零。这意味着$g_{h}(\\varphi,\\varphi) = 0$。\n\n综合所有项，双线性形式的总值仅为体项的值：\n$$\na_{h}(\\varphi,\\varphi) = (\\kappa_{1}\\alpha + \\kappa_{2}(1-\\alpha)) + 0 + 0 + 0 + 0 = \\kappa_{1}\\alpha + \\kappa_{2}(1-\\alpha)\n$$\n这个结果表明，基于 Nitsche 的 CutFEM 形式对线性函数是精确的，因为所有特定于方法的界面项和稳定项都消失了，从而恢复了原始连续双线性形式的值。",
            "answer": "$$\\boxed{\\kappa_{1} \\alpha + \\kappa_{2} (1 - \\alpha)}$$"
        },
        {
            "introduction": "虽然像Nitsche方法这样的理论公式提供了严谨的基础，但它们的实际重要性最好通过实践来理解。这个动手编程问题将挑战您求解一个一维高对比度界面问题，通过比较一个朴素的、直观的格式和一个基于物理的、稳定的格式。通过分析误差，您将具体地理解为什么在虚拟区域模拟中，谨慎的界面处理对于获得稳健和准确的解是至关重要的。",
            "id": "3392223",
            "problem": "考虑设定在区间$[-1,1]$上的单空间维度标量椭圆界面问题：求$u:[-1,1]\\to\\mathbb{R}$使得\n$$\n-\\frac{d}{dx}\\left(\\kappa(x)\\,\\frac{du}{dx}\\right)=0 \\quad \\text{for } x\\in(-1,1),\n$$\n其中狄利克雷边界条件为$u(-1)=-1$和$u(1)=1$，传导系数$\\kappa(x)$为分段常数，在预设的界面点$\\xi\\in(-1,1)$处有单次跳跃，即\n$$\n\\kappa(x)=\n\\begin{cases}\n\\kappa_1,  x  \\xi,\\\\\n\\kappa_2,  x \\ge \\xi,\n\\end{cases}\n$$\n$\\kappa_1$和$\\kappa_2$是给定的正常数。界面条件为$u$在$x=\\xi$处的连续性和法向通量的连续性，\n$$\nu(\\xi^-)=u(\\xi^+),\\qquad \\kappa_1\\,\\frac{du}{dx}(\\xi^-)=\\kappa_2\\,\\frac{du}{dx}(\\xi^+).\n$$\n此公式是用于分析偏微分方程数值解中虚构域技术的典范模型，其中界面切割位置$\\xi$通常与离散网格无关。\n\n从弱形式和标准守恒原理出发，您的目标是为此界面问题在均匀网格上设计并实现两种数值格式：\n\n- 一种非稳定格式，使用一个对切割位置$\\xi$不敏感的简单面传导系数模型；\n- 一种稳定格式，它在切割面上采用了一致的通量模型，利用了沿界面分割的面区间上传导率的串联叠加特性。\n\n稳定格式必须在$\\kappa_1\\ll \\kappa_2$的高对比度下具有鲁棒性，并且无论切割位置$\\xi$在何处，都应能捕捉到界面处正确的通量连续性。非稳定格式应通过使用一个简单的、位置不敏感的平均法则来建模面传导系数，从而刻意地缺乏这种鲁棒性。两种格式都必须在内部节点上组装一个三对角对称正定（SPD）线性系统，并强施加狄利克雷边界条件。\n\n为使研究可进行定量测试，请按以下步骤操作：\n\n1. 在给定的边界和界面条件下，针对通用的$\\xi\\in(-1,1)$和正的$\\kappa_1, \\kappa_2$，推导精确解$u_{\\text{ex}}(x)$。精确解是分段线性的，在$(-1,\\xi)$和$(\\xi,1)$上具有不同的斜率，并受通量连续性约束。\n\n2. 在$[-1,1]$上包含$N$个节点（包括端点）的均匀网格上实现这两种数值格式，网格间距为$h=2/(N-1)$。虚构域的特性源于界面$\\xi$可以位于$(-1,1)$内的任何位置，而与网格无关；如果界面严格位于区间$[x_{i-1},x_i]$内部，稳定格式必须能反映出跨越此切割区间的正确守恒性。\n\n3. 对于每种格式，计算离散解$u_h$，并使用梯度误差的单元积分来评估$H^1$半范数下的误差。具体来说，对于每个长度为$h$的单元$[x_{i-1},x_i]$，将离散解的单元梯度定义为\n$$\ng_h^{(i)}=\\frac{u_h(x_i)-u_h(x_{i-1})}{h}.\n$$\n精确梯度是分段常数，在$[x_{i-1},x_i]\\subset(-1,\\xi)$上等于左侧斜率，在$[x_{i-1},x_i]\\subset(\\xi,1)$上等于右侧斜率；如果界面严格位于单元内部，则将积分分割为左右两个子区间。通过以下方式近似误差的$H^1$半范数\n$$\n\\|u_h-u_{\\text{ex}}\\|_{H^1( -1,1)} \\approx \\left(\\sum_{i=1}^{N-1}\\int_{x_{i-1}}^{x_i}\\big(g_h^{(i)}-u_{\\text{ex}}'(x)\\big)^2\\,dx\\right)^{1/2}.\n$$\n\n4. 通过将误差用此界面限制问题的理论预期收敛率进行归一化，来为每种格式定义$H^1$误差常数。由于主要贡献局限在单个切割单元附近，且精确解具有斜率不连续性，假设$H^1$半范数下的预期收敛率与$h^{1/2}$成正比，并计算\n$$\nC_{H^1} = \\frac{\\|u_h-u_{\\text{ex}}\\|_{H^1(-1,1)}}{\\sqrt{h}}.\n$$\n分别报告非稳定格式和稳定格式的$C_{H^1}$。分析$C_{H^1}$如何依赖于对比度参数$\\kappa_1$和$\\kappa_2$。\n\n您的程序必须实现上述内容，并为以下参数值$(\\kappa_1,\\kappa_2,\\xi,N)$的测试套件生成定量结果：\n\n- 测试 1（基准等传导系数）：$(\\kappa_1,\\kappa_2,\\xi,N)=(1,1,0.3,501)$。\n- 测试 2（中度高对比度）：$(\\kappa_1,\\kappa_2,\\xi,N)=(10^{-3},1,0.3,501)$。\n- 测试 3（极端高对比度）：$(\\kappa_1,\\kappa_2,\\xi,N)=(10^{-6},1,0.3,501)$。\n- 测试 4（界面对齐的边缘情况）：$(\\kappa_1,\\kappa_2,\\xi,N)=(10^{-6},1,0.0,501)$。\n\n对于每个测试用例，您的程序必须计算并输出一个包含两个浮点数的列表$[C_{H^1}^{\\text{unstab}}, C_{H^1}^{\\text{stab}}]$，其中$C_{H^1}^{\\text{unstab}}$是非稳定格式的误差常数，$C_{H^1}^{\\text{stab}}$是稳定格式的误差常数。最终输出必须将所有测试用例的结果聚合到单行文本中，该文本包含一个列表的列表，格式完全如下：\n\n\"您的程序应生成单行输出，其中包含结果，格式为一个由逗号分隔的、每个测试用例的双方括号浮点数列表组成的列表（例如，[[c11,c12],[c21,c22],[c31,c32],[c41,c42]]）。\"\n\n此问题不涉及物理单位或角度单位。输出中的浮点数应以数值形式表示（十进制或科学记数法均可接受）。该问题侧重于在虚构域方法的背景下进行推导、鲁棒性分析以及对比度依赖性研究。",
            "solution": "用户提供的问题是偏微分方程数值分析中一个有效、适定且具有科学依据的练习。所有必要的数据和条件都已提供，可用于推导解析解、实现两种不同的数值格式并定量评估其性能。该问题是客观的，并直接探讨了虚构域方法的核心概念，特别是对与计算网格不对齐的界面的处理方法。\n\n### 1. 解析解\n该问题由一维稳态扩散方程描述：\n$$\n-\\frac{d}{dx}\\left(\\kappa(x)\\,\\frac{du}{dx}\\right)=0 \\quad \\text{for } x\\in(-1,1)\n$$\n对$x$积分一次表明，通量$J(x) = -\\kappa(x) \\frac{du}{dx}$必须是一个常数，记为$J_0$。因此，$\\frac{du}{dx} = -J_0/\\kappa(x)$。再次积分得到一个分段线性解。我们定义$C = -J_0$。\n$$\nu'(x) = \\frac{C}{\\kappa(x)} =\n\\begin{cases}\nC/\\kappa_1,  x  \\xi \\\\\nC/\\kappa_2,  x \\ge\\xi\n\\end{cases}\n$$\n积分并应用边界条件$u(-1)=-1$和$u(1)=1$，同时强制解$u(x)$在界面$x=\\xi$处的连续性，我们得到解：\n$$\nu_{\\text{ex}}(x) =\n\\begin{cases}\n\\frac{C}{\\kappa_1}(x+1) - 1,  x \\in [-1, \\xi) \\\\\n\\frac{C}{\\kappa_2}(x-1) + 1,  x \\in [\\xi, 1]\n\\end{cases}\n$$\n常数$C$由连续性条件$u(\\xi^-)=u(\\xi^+)$确定：\n$$\n\\frac{C}{\\kappa_1}(\\xi+1) - 1 = \\frac{C}{\\kappa_2}(\\xi-1) + 1\n$$\n求解$C$可得：\n$$\nC = \\frac{2 \\kappa_1 \\kappa_2}{\\kappa_2(\\xi+1) - \\kappa_1(\\xi-1)}\n$$\n该解析解提供了误差计算所需的精确梯度$u_{\\text{ex}}'(x)$，它是分段常数：当$x  \\xi$时，$u_{\\text{ex}}'(x) = C/\\kappa_1$；当$x \\ge \\xi$时，$u_{\\text{ex}}'(x) = C/\\kappa_2$。\n\n### 2. 数值离散化\n我们采用有限体积法在均匀网格$x_i = -1 + ih$（$i=0, \\dots, N-1$）上进行计算，网格间距为$h=2/(N-1)$。将偏微分方程在以每个内部节点$x_i$为中心的控制体$[x_{i-1/2}, x_{i+1/2}]$上积分，可得到守恒律：\n$$\n\\left(-\\kappa\\frac{du}{dx}\\right)_{x_{i+1/2}} - \\left(-\\kappa\\frac{du}{dx}\\right)_{x_{i-1/2}} = 0\n$$\n这表明进入控制体的通量等于离开它的通量。我们将单元面$x_{i-1/2}$（$x_{i-1}$和$x_i$之间的中点）处的通量近似为：\n$$\nJ_{i-1/2} = -\\kappa_{i-1/2} \\frac{u_i - u_{i-1}}{h}\n$$\n其中$u_i \\approx u(x_i)$，$\\kappa_{i-1/2}$是区间$[x_{i-1}, x_i]$的有效传导系数。每个内部节点$i=1, \\dots, N-2$的离散方程为：\n$$\n-\\kappa_{i+1/2}\\frac{u_{i+1}-u_i}{h} + \\kappa_{i-1/2}\\frac{u_i-u_{i-1}}{h} = 0\n$$\n重新整理，我们得到三对角系统的计算模板：\n$$\n-\\kappa_{i-1/2} u_{i-1} + (\\kappa_{i-1/2} + \\kappa_{i+1/2}) u_i - \\kappa_{i+1/2} u_{i+1} = 0\n$$\n两种所需格式之间的区别在于面传导系数$\\kappa_{i-1/2}$的定义。\n\n### 3. 非稳定格式\n该格式使用一种简单的、对位置不敏感的平均法则。一个标准的选择是相邻节点处传导系数的算术平均值：\n$$\n\\kappa_{i-1/2}^{\\text{unstab}} = \\frac{\\kappa(x_{i-1}) + \\kappa(x_i)}{2}\n$$\n其中，若$x_j  \\xi$，则$\\kappa(x_j) = \\kappa_1$；若$x_j \\ge \\xi$，则$\\kappa(x_j) = \\kappa_2$。该模型易于实现，但无法正确表示流体通过分层介质的物理过程，尤其是在高对比度下，因为它只对哪些节点落在界面的哪一侧敏感，而对其在单元内的精确位置不敏感。\n\n### 4. 稳定格式\n该格式使用物理上一致的有效传导系数模型，反映了电阻的串联叠加特性。对于长度为$L$、传导系数为$\\kappa$的一维段，其热阻/电阻为$R=L/\\kappa$。对于两个串联的段，电阻相加。区间$[x_{i-1}, x_i]$（长度为$h$）的有效传导系数$\\kappa_{i-1/2}$由其总电阻导出：\n$$\nR_{\\text{cell}} = \\int_{x_{i-1}}^{x_i} \\frac{dx'}{\\kappa(x')} = \\frac{h}{\\kappa_{i-1/2}}\n$$\n这给出了传导系数的调和平均值。\n如果界面$\\xi$不在$(x_{i-1}, x_i)$内，则$\\kappa(x)$是常数，$\\kappa_{i-1/2}^{\\text{stab}}$为$\\kappa_1$或$\\kappa_2$。\n如果界面位于单元内，$x_{i-1}  \\xi  x_i$，则积分被拆分：\n$$\n\\int_{x_{i-1}}^{x_i} \\frac{dx'}{\\kappa(x')} = \\int_{x_{i-1}}^{\\xi} \\frac{dx'}{\\kappa_1} + \\int_{\\xi}^{x_i} \\frac{dx'}{\\kappa_2} = \\frac{\\xi-x_{i-1}}{\\kappa_1} + \\frac{x_i-\\xi}{\\kappa_2}\n$$\n因此，稳定格式的面传导系数为：\n$$\n\\kappa_{i-1/2}^{\\text{stab}} = \\frac{h}{\\frac{\\xi-x_{i-1}}{\\kappa_1} + \\frac{x_i-\\xi}{\\kappa_2}}\n$$\n该公式是鲁棒的，因为它能正确捕捉低传导系数材料的通量限制行为，而无论$\\xi$的子网格位置或对比度比$\\kappa_2/\\kappa_1$如何。\n\n### 5. 线性系统和边界条件\n对于两种格式，都为未知内部节点值的向量$\\mathbf{u} = [u_1, \\dots, u_{N-2}]^T$组装一个线性系统$A\\mathbf{u}=\\mathbf{b}$。矩阵$A$是一个$(N-2)\\times(N-2)$的对称正定（SPD）三对角矩阵。狄利克雷边界条件$u_0 = u(-1) = -1$和$u_{N-1} = u(1) = 1$通过将其贡献移至右侧向量$\\mathbf{b}$来并入系统。\n对于第一个方程（$i=1$）：\n$$\n(\\kappa_{1/2} + \\kappa_{3/2})u_1 - \\kappa_{3/2}u_2 = -\\kappa_{1/2}u_0 = \\kappa_{1/2}\n$$\n对于最后一个方程（$i=N-2$）：\n$$\n-\\kappa_{N-5/2}u_{N-3} + (\\kappa_{N-5/2} + \\kappa_{N-3/2})u_{N-2} = \\kappa_{N-3/2}u_{N-1} = \\kappa_{N-3/2}\n$$\n得到的 SPD 系统可以使用标准的带状矩阵求解器高效求解。\n\n### 6. 误差范数计算\n误差在$H^1$半范数下进行评估，通过网格单元上的总和来近似：\n$$\n\\|u_h-u_{\\text{ex}}\\|_{H^1(-1,1)}^2 \\approx \\sum_{i=1}^{N-1}\\int_{x_{i-1}}^{x_i}\\big(g_h^{(i)}-u_{\\text{ex}}'(x)\\big)^2\\,dx\n$$\n其中$g_h^{(i)} = (u_h(x_i) - u_h(x_{i-1})) / h$是数值解的分段常数梯度。每个单元$[x_{i-1}, x_i]$的积分通过考虑两种情况来计算：\n1.  **未被切割的单元**：如果$\\xi \\notin (x_{i-1}, x_i)$，$u_{\\text{ex}}'(x)$在该单元内是常数，积分值为$(g_h^{(i)} - u_{\\text{ex}}')^2 h$。\n2.  **被切割的单元**：如果$x_{i-1}  \\xi  x_i$，积分在$\\xi$处被拆分：\n    $$\n    (g_h^{(i)} - C/\\kappa_1)^2(\\xi-x_{i-1}) + (g_h^{(i)} - C/\\kappa_2)^2(x_i-\\xi)\n    $$\n最后，误差常数$C_{H^1}$通过将误差用$h^{1/2}$的预期收敛率进行归一化来计算：\n$$\nC_{H^1} = \\frac{\\|u_h-u_{\\text{ex}}\\|_{H^1(-1,1)}}{\\sqrt{h}}\n$$\n该常数提供了一种衡量方法精度的指标，该指标与网格大小$N$无关，从而可以对格式对参数变化（特别是传导系数对比度）的鲁棒性进行公平比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (k1, k2, xi, N)\n        (1.0, 1.0, 0.3, 501),\n        (1e-3, 1.0, 0.3, 501),\n        (1e-6, 1.0, 0.3, 501),\n        (1e-6, 1.0, 0.0, 501),\n    ]\n\n    all_results = []\n\n    for k1, k2, xi, N in test_cases:\n        h = 2.0 / (N - 1)\n        x = np.linspace(-1.0, 1.0, N)\n        \n        # Boundary conditions\n        u_left_bc = -1.0\n        u_right_bc = 1.0\n        \n        # Exact solution constant\n        denominator = k2 * (xi + 1.0) - k1 * (xi - 1.0)\n        # Avoid division by zero if conductivities are zero, though problem states positive.\n        if abs(denominator)  1e-15:\n            C_exact = 0.0 # Should not happen with positive k1,k2\n        else:\n            C_exact = (2.0 * k1 * k2) / denominator\n\n        u_prime_left = C_exact / k1 if k1 > 0 else 0\n        u_prime_right = C_exact / k2 if k2 > 0 else 0\n\n        case_results = []\n        for scheme in ['unstabilized', 'stabilized']:\n            # 1. Assemble face conductivities\n            num_faces = N - 1\n            k_face = np.zeros(num_faces)\n            \n            if scheme == 'unstabilized':\n                kappa_node = np.where(x  xi, k1, k2)\n                # Handle the case where xi is exactly on a node\n                # The rule is k(x)=k2 for x >= xi\n                for i in range(N):\n                    if x[i] >= xi:\n                        kappa_node[i] = k2\n                \n                for i in range(num_faces):\n                    k_face[i] = (kappa_node[i] + kappa_node[i+1]) / 2.0\n            \n            else: # stabilized\n                for i in range(num_faces):\n                    x_l, x_r = x[i], x[i+1]\n                    if xi = x_l + 1e-15: # Cell is in a region of k2\n                        k_face[i] = k2\n                    elif xi >= x_r - 1e-15: # Cell is in a region of k1\n                        k_face[i] = k1\n                    else: # Cell is cut by the interface\n                        resist_1 = (xi - x_l) / k1\n                        resist_2 = (x_r - xi) / k2\n                        k_face[i] = h / (resist_1 + resist_2)\n            \n            # 2. Assemble the linear system A*u = b for interior nodes\n            num_interior_nodes = N - 2\n            # Scipy's banded solver format: (l+u+1, M)\n            # Here: l=1, u=1, M = N-2. Matrix is (3, N-2)\n            # ab[0,:] = super-diagonal, ab[1,:] = main-diagonal, ab[2,:] = sub-diagonal\n            ab = np.zeros((3, num_interior_nodes))\n            b = np.zeros(num_interior_nodes)\n\n            # Main diagonal\n            ab[1, :] = k_face[:-1] + k_face[1:]\n            # Off-diagonals\n            ab[0, 1:] = -k_face[1:-1]\n            ab[2, :-1] = -k_face[1:-1]\n            \n            # Incorporate boundary conditions into RHS vector b\n            b[0] = k_face[0] * u_left_bc\n            b[-1] = k_face[-1] * u_right_bc\n\n            # 3. Solve the system\n            u_interior = solve_banded((1, 1), ab, b)\n            u_h = np.concatenate(([u_left_bc], u_interior, [u_right_bc]))\n\n            # 4. Compute H^1 seminorm error\n            error_sq_sum = 0.0\n            for i in range(1, N):\n                x_l, x_r = x[i-1], x[i]\n                g_h_i = (u_h[i] - u_h[i-1]) / h\n                \n                cell_error_sq = 0.0\n                if xi = x_l + 1e-15: # Cell is entirely in right part\n                    cell_error_sq = (g_h_i - u_prime_right)**2 * h\n                elif xi >= x_r - 1e-15: # Cell is entirely in left part\n                    cell_error_sq = (g_h_i - u_prime_left)**2 * h\n                else: # Cell is cut by interface\n                    err_left_part = (g_h_i - u_prime_left)**2 * (xi - x_l)\n                    err_right_part = (g_h_i - u_prime_right)**2 * (x_r - xi)\n                    cell_error_sq = err_left_part + err_right_part\n                \n                error_sq_sum += cell_error_sq\n\n            h1_seminorm_error = np.sqrt(error_sq_sum)\n            C_H1 = h1_seminorm_error / np.sqrt(h)\n            case_results.append(C_H1)\n            \n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'[{res[0]},{res[1]}]' for res in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虚拟区域技术以其在流固耦合问题中的高效性而著称。本实践将介绍经典的浸入边界法(IBM)，用于模拟由弹性膜驱动的流动。您将实现一个用于斯托克斯(Stokes)方程的谱求解器，并使用正则化的$\\delta$函数来耦合流体和结构，这是一种与Nitsche方法不同的途径。本练习的一个关键部分是量化数值“泄漏”，它能让您深入了解离散化选择如何影响模拟中的质量守恒。",
            "id": "3510140",
            "problem": "考虑一个二维周期性方形域，由区间$[0,1]\\times[0,1]$描述，该域在每个方向上有$N$个点的均匀笛卡尔网格上进行离散化，网格间距为$h=1/N$。一个封闭的弹性边界由一个半径为$R$，中心在$(0.5,0.5)$的圆形膜表示，该膜通过$N_{\\mathrm{L}}$个等间距的拉格朗日点进行离散化，其角度参数化为$\\theta_i = 2\\pi i/N_{\\mathrm{L}}$（角度以弧度为单位）。假设膜两侧存在均匀的压力跳跃$\\Delta p$，在膜上产生一个单位长度的法向牵引力，大小等于$\\Delta p\\,\\mathbf{n}$，其中$\\mathbf{n}$是向外的单位法向量。\n\n在沉浸边界法（IBM）中，拉格朗日-欧拉耦合使用一个正则化的狄拉克δ函数，将膜的牵引力从拉格朗日点（$X_i$）散开到欧拉网格上，并将欧拉速度插值回拉格朗日点。具体来说，正则化δ函数定义为\n$$\n\\delta_h(\\mathbf{x})=\\frac{1}{h^2}\\,\\phi\\left(\\frac{x}{h}\\right)\\,\\phi\\left(\\frac{y}{h}\\right),\n$$\n其中一维核函数$\\phi(\\cdot)$是从一组候选函数中选择的紧支集函数。欧拉力密度则为\n$$\n\\mathbf{F}(\\mathbf{x})=\\sum_{i=0}^{N_{\\mathrm{L}}-1} \\Delta p\\,\\mathbf{n}_i\\,\\delta_h(\\mathbf{x}-\\mathbf{X}_i)\\,ds,\n$$\n其中$ds = 2\\pi R/N_{\\mathrm{L}}$是线段长度。在忽略惯性效应的情况下，欧拉速度$\\mathbf{u}$由稳态斯托克斯方程控制，\n$$\n-\\nabla p + \\mu \\Delta \\mathbf{u} + \\mathbf{F} = \\mathbf{0},\\qquad \\nabla\\cdot\\mathbf{u} = 0,\n$$\n其中$\\mu$是动力粘度，边界条件为周期性。对于所有非零波数，该周期域上唯一的无散度解$\\mathbf{u}$可以通过快速傅里叶变换（FFT）以谱方法表示，即将作用力投影到无散度子空间上，然后除以拉普拉斯算子的特征值。\n\n拉格朗日速度$\\mathbf{U}_i$通过插值获得，\n$$\n\\mathbf{U}_i = \\sum_{\\text{grid }\\mathbf{x}} \\mathbf{u}(\\mathbf{x}) \\,\\delta_h(\\mathbf{X}_i - \\mathbf{x})\\,h^2,\n$$\n穿过膜的面积通量（在二维中，对应于单位深度的体积变化率）通过法向速度的线积分计算，\n$$\n\\frac{dA}{dt} = \\oint_{\\Gamma} \\mathbf{u}\\cdot\\mathbf{n}\\,ds \\approx \\sum_{i=0}^{N_{\\mathrm{L}}-1} \\mathbf{U}_i\\cdot\\mathbf{n}_i\\,ds.\n$$\n在连续介质中，对于一个包围着物质体积的不可压缩流（$\\nabla\\cdot\\mathbf{u}=0$），根据散度定理，面积变化率$dA/dt$将恒为零。然而，在离散的沉浸边界法中，由于核函数$\\phi(\\cdot)$的选择以及拉格朗日间距相对于欧拉网格的配置，导致散开和插值操作之间存在不匹配，$dA/dt$可能不为零。这种虚假的非零$dA/dt$被称为泄漏（leakage）。\n\n您的任务是实现一个程序，用于：\n- 如上所述离散化膜。\n- 使用选定的正则化δ核函数散开均匀的压力牵引力。\n- 使用谱投影法在周期域上求解稳态斯托克斯方程。\n- 将速度插值回膜上。\n- 如上所述计算面积变化率$dA/dt$。\n\n您必须以无量纲形式处理所有物理量。角度必须以弧度为单位。对于核函数$\\phi(\\cdot)$，您必须至少支持以下选择：\n- Peskin 四点核函数（沉浸边界法核函数）：\n$$\n\\phi(r)=\\begin{cases}\n\\frac{1}{8}\\left(3-2|r|+\\sqrt{1+4|r|-4r^2}\\right),  |r|  1, \\\\[6pt]\n\\frac{1}{8}\\left(5-2|r|-\\sqrt{-7+12|r|-4r^2}\\right),  1 \\le |r|  2, \\\\[6pt]\n0,  \\text{其他情况}\n\\end{cases}\n$$\n- 三次基本B样条：\n$$\n\\phi(r)=\\begin{cases}\n\\frac{1}{6}\\left(4-6|r|^2+3|r|^3\\right),  |r| \\le 1, \\\\[6pt]\n\\frac{1}{6}\\left(2-|r|\\right)^3,  1  |r| \\le 2, \\\\[6pt]\n0,  \\text{其他情况}\n\\end{cases}\n$$\n\n对于所有计算，设置$N=64$，$h=1/N$，$R=0.25$，$\\mu=1$。定义拉格朗日间距比$s=ds/h$，并通过$N_{\\mathrm{L}} = \\left\\lfloor \\frac{2\\pi R}{s\\,h} \\right\\rfloor$确定$N_{\\mathrm{L}}$，约束条件为$N_{\\mathrm{L}}\\ge 8$。使用向外法向量$\\mathbf{n}_i=[\\cos\\theta_i,\\sin\\theta_i]$。用于基于FFT的微分的波数必须是$k_x=2\\pi\\,\\mathrm{freq}_x$和$k_y=2\\pi\\,\\mathrm{freq}_y$，其中$\\mathrm{freq}$是对应于间距$h$的标准离散傅里叶频率。\n\n设计您的代码，为以下由参数对$(\\text{kernel},s)$和压力跳跃$\\Delta p$指定的测试用例集计算$dA/dt$：\n- 情况 1：$(\\text{peskin4},\\,s=1.0)$，$\\Delta p=1$。\n- 情况 2：$(\\text{peskin4},\\,s=0.5)$，$\\Delta p=1$。\n- 情况 3：$(\\text{peskin4},\\,s=2.0)$，$\\Delta p=1$。\n- 情况 4：$(\\text{bspline3},\\,s=1.0)$，$\\Delta p=1$。\n- 情况 5：$(\\text{bspline3},\\,s=0.5)$，$\\Delta p=1$。\n- 情况 6：$(\\text{bspline3},\\,s=2.0)$，$\\Delta p=1$。\n- 情况 7（边界情况）：$(\\text{peskin4},\\,s=1.0)$，$\\Delta p=0$。\n\n您的程序必须生成单行输出，其中包含按情况1到7的顺序排列的结果，形式为方括号内以逗号分隔的列表，每个结果是计算出的$dA/dt$的浮点数值。因为所有量都是无量纲的，所以不要在输出中附加任何物理单位。角度单位是弧度；所有输出都必须是十进制浮点数。输出格式必须严格为\n$$\n[\\text{result}_1,\\text{result}_2,\\ldots,\\text{result}_7],\n$$\n其中每个$\\text{result}_i$是一个浮点数值。",
            "solution": "该问题被认为是有效的，因为它在科学上基于计算流体动力学的原理，特别是沉浸边界法（IBM），并且是一个具有完整且一致给定条件的、设定良好的数值问题。该任务涉及模拟流固耦合，以量化一个已知的数值伪影“泄漏”，这种伪影源于离散化以及耦合核函数的选择。\n\n解决方案通过为每个测试用lie逐步实现所述数值方法来展开。\n\n**1. 域和边界的离散化**\n\n物理设置包括一个二维周期域$\\Omega = [0,1] \\times [0,1]$和一个半径为$R=0.25$、中心在$(0.5, 0.5)$的圆形膜$\\Gamma$。\n\n- **欧拉网格**：域$\\Omega$被离散化为一个$N \\times N$点的均匀笛卡尔网格，其中$N=64$。网格间距为$h = 1/N = 1/64$。网格点位于$\\mathbf{x}_{j,k} = (j h, k h)$，其中$j,k \\in \\{0, 1, \\dots, N-1\\}$。\n\n- **拉格朗日网格**：膜$\\Gamma$被离散化为$N_{\\mathrm{L}}$个拉格朗日点。点的数量$N_{\\mathrm{L}}$由拉格朗日间距比$s = ds/h$决定，其中$ds$是相邻拉格朗日点之间的弧长。计算公式为$N_{\\mathrm{L}} = \\lfloor \\frac{2\\pi R}{s h} \\rfloor$。然后重新计算弧长为$ds = 2\\pi R/N_{\\mathrm{L}}$，以确保离散化的环是闭合的。拉格朗日点的位置由角度$\\theta_i = 2\\pi i/N_{\\mathrm{L}}$（其中$i \\in \\{0, 1, \\dots, N_{\\mathrm{L}}-1\\}$）参数化给出：\n$$\n\\mathbf{X}_i = (0.5 + R\\cos\\theta_i, 0.5 + R\\sin\\theta_i)\n$$\n每个点$\\mathbf{X}_i$处的向外单位法向量为$\\mathbf{n}_i = (\\cos\\theta_i, \\sin\\theta_i)$。\n\n**2. 核函数与正则化Delta函数**\n\n流体（欧拉）和结构（拉格朗日）之间的相互作用由一个正则化的狄拉克δ函数$\\delta_h(\\mathbf{x})$介导，该函数由一维核函数$\\phi(r)$构建。根据其分段定义，实现了两个指定的核函数：Peskin 4点核函数和三次B样条核函数。两个核函数都具有$4h$的紧支集，意味着当$|r| \\ge 2$时$\\phi(r)=0$。\n\n**3. 散布：从拉格朗日力到欧拉力密度**\n\n膜两侧的均匀压力跳跃$\\Delta p$产生了一个单位长度上的法向力（牵引力），大小为$\\Delta p \\, \\mathbf{n}$。每个拉格朗日点$\\mathbf{X}_i$上的离散力为$\\mathbf{f}_i = \\Delta p \\, \\mathbf{n}_i \\, ds$。\n\n这个拉格朗日力被“散布”到周围的欧拉网格点上，以获得欧拉力密度场$\\mathbf{F}(\\mathbf{x})$。该散布操作的公式为：\n$$\n\\mathbf{F}(\\mathbf{x}) = \\sum_{i=0}^{N_{\\mathrm{L}}-1} \\mathbf{f}_i \\, \\delta_h(\\mathbf{x} - \\mathbf{X}_i) = \\frac{1}{h^2} \\sum_{i=0}^{N_{\\mathrm{L}}-1} (\\Delta p \\, \\mathbf{n}_i \\, ds) \\, \\phi\\left(\\frac{x-X_{i,x}}{h}\\right) \\phi\\left(\\frac{y-X_{i,y}}{h}\\right)\n$$\n在数值上，对于每个拉格朗日点$\\mathbf{X}_i$，我们识别出落在核函数支集范围内的邻近欧拉网格点$\\mathbf{x}_{j,k}$。然后计算力的贡献并加到欧拉力数组 `Fx` 和 `Fy` 的相应元素上。由于域是周期性的，距离计算考虑了网格的环绕特性。\n\n**4. 求解稳态斯托克斯方程**\n\n流体速度$\\mathbf{u}$和压力$p$由带有周期性边界条件的稳态斯托克斯方程控制：\n$$\n-\\nabla p + \\mu \\Delta \\mathbf{u} + \\mathbf{F} = \\mathbf{0}, \\qquad \\nabla\\cdot\\mathbf{u} = 0\n$$\n鉴于周期性，这些方程在傅里叶空间中可以被高效求解。对这些方程应用快速傅里叶变换（FFT），得到：\n$$\n-i\\mathbf{k}\\hat{p} - \\mu |\\mathbf{k}|^2 \\hat{\\mathbf{u}} + \\hat{\\mathbf{F}} = \\mathbf{0}, \\qquad i\\mathbf{k}\\cdot\\hat{\\mathbf{u}} = 0\n$$\n其中$\\hat{\\cdot}$表示傅里叶变换，$\\mathbf{k}=(k_x, k_y)$是波矢量，$|\\mathbf{k}|^2=k_x^2+k_y^2$。波数由$k = 2\\pi f$决定，其中$f$是来自 `scipy.fft.fftfreq` 的离散频率。\n\n不可压缩条件（$i\\mathbf{k}\\cdot\\hat{\\mathbf{u}} = 0$）意味着速度矢量$\\hat{\\mathbf{u}}$与波矢量$\\mathbf{k}$正交。通过将动量方程投影到无散度子空间上，我们可以直接求解$\\hat{\\mathbf{u}}$：\n$$\n\\hat{\\mathbf{u}}(\\mathbf{k}) = \\frac{1}{\\mu |\\mathbf{k}|^2} \\left( \\hat{\\mathbf{F}} - \\frac{(\\mathbf{k} \\cdot \\hat{\\mathbf{F}})\\mathbf{k}}{|\\mathbf{k}|^2} \\right) \\quad \\text{对于 } \\mathbf{k} \\neq \\mathbf{0}\n$$\n对于零波数模式（$\\mathbf{k}=\\mathbf{0}$），$\\hat{\\mathbf{u}}(\\mathbf{0})$被设为零，对应于零平均速度。得到的傅里叶空间中的速度场$(\\hat{u}_x, \\hat{u}_y)$通过逆FFT变换回实空间，得到欧拉速度场$(u_x, u_y)$。\n\n**5. 插值：从欧拉速度到拉格朗日速度**\n\n膜上各点的速度$\\mathbf{U}_i$是通过在拉格朗日位置$\\mathbf{X}_i$处插值欧拉速度场$\\mathbf{u}(\\mathbf{x})$得到的。此操作是散布操作的伴随操作：\n$$\n\\mathbf{U}_i = \\sum_{\\text{grid }\\mathbf{x}} \\mathbf{u}(\\mathbf{x}) \\, \\delta_h(\\mathbf{X}_i - \\mathbf{x}) \\, h^2 = \\sum_{\\text{grid }\\mathbf{x}} \\mathbf{u}(\\mathbf{x}) \\, \\phi\\left(\\frac{X_{i,x}-x}{h}\\right) \\phi\\left(\\frac{Y_{i,y}-y}{h}\\right)\n$$\n在数值上，对于每个拉格朗日点$\\mathbf{X}_i$，我们再次识别出邻近的欧拉网格点，并计算其速度的加权和以求得$\\mathbf{U}_i$。\n\n**6. 计算面积变化率（$dA/dt$）**\n\n最后，通过近似计算沿边界的法向速度的线积分，来计算由膜包围的面积的变化率，这是衡量数值泄漏的指标：\n$$\n\\frac{dA}{dt} = \\oint_{\\Gamma} \\mathbf{u}\\cdot\\mathbf{n}\\,ds \\approx \\sum_{i=0}^{N_{\\mathrm{L}}-1} \\mathbf{U}_i\\cdot\\mathbf{n}_i\\,ds\n$$\n对问题中指定的每个测试用例计算此值。$\\Delta p = 0$的情况用作一个空检验，因为它应该产生零力、零速度，因此泄漏为零，从而证实了基础实现的线性性和正确性。",
            "answer": "```python\nimport numpy as np\nimport scipy.fft\n\ndef peskin4_kernel(r):\n    \"\"\"\n    Computes the Peskin 4-point regularized delta function kernel.\n    \"\"\"\n    r_abs = np.abs(r)\n    val = np.zeros_like(r_abs)\n    \n    # |r|  1\n    mask1 = r_abs  1\n    r1 = r_abs[mask1]\n    val[mask1] = (1/8) * (3 - 2*r1 + np.sqrt(1 + 4*r1 - 4*r1**2))\n    \n    # 1 = |r|  2\n    mask2 = (r_abs >= 1)  (r_abs  2)\n    r2 = r_abs[mask2]\n    # Ensure argument of sqrt is non-negative due to float precision issues\n    sqrt_arg = -7 + 12*r2 - 4*r2**2\n    sqrt_arg[sqrt_arg  0] = 0.0\n    val[mask2] = (1/8) * (5 - 2*r2 - np.sqrt(sqrt_arg))\n\n    return val\n\ndef bspline3_kernel(r):\n    \"\"\"\n    Computes the cardinal cubic B-spline kernel.\n    \"\"\"\n    r_abs = np.abs(r)\n    val = np.zeros_like(r_abs)\n    \n    # |r| = 1\n    mask1 = r_abs = 1\n    r1 = r_abs[mask1]\n    val[mask1] = (1/6) * (4 - 6*r1**2 + 3*r1**3)\n\n    # 1  |r| = 2\n    mask2 = (r_abs > 1)  (r_abs = 2)\n    r2 = r_abs[mask2]\n    val[mask2] = (1/6) * (2 - r2)**3\n    \n    return val\n\ndef compute_leakage(kernel_name, s, dp):\n    \"\"\"\n    Computes the area change rate (dA/dt) for the given parameters.\n    \"\"\"\n    # System parameters\n    N = 64\n    R = 0.25\n    mu = 1.0\n    h = 1.0 / N\n\n    # Select the kernel function\n    kernels = {'peskin4': peskin4_kernel, 'bspline3': bspline3_kernel}\n    kernel_func = kernels[kernel_name]\n\n    # Lagrangian boundary discretization\n    N_L = int(np.floor(2 * np.pi * R / (s * h)))\n    if N_L  8: N_L = 8\n    ds = 2 * np.pi * R / N_L\n    theta = 2 * np.pi * np.arange(N_L) / N_L\n    \n    X_lag = 0.5 + R * np.cos(theta)\n    Y_lag = 0.5 + R * np.sin(theta)\n    nx = np.cos(theta)\n    ny = np.sin(theta)\n\n    # Sanity check: if pressure jump is zero, leakage must be zero\n    if dp == 0:\n        return 0.0\n\n    # --- Step 1: Spreading (Lagrangian force to Eulerian grid) ---\n    Fx = np.zeros((N, N))\n    Fy = np.zeros((N, N))\n    \n    for i in range(N_L):\n        lag_force_x = dp * nx[i] * ds\n        lag_force_y = dp * ny[i] * ds\n        \n        sx = X_lag[i] / h\n        sy = Y_lag[i] / h\n        \n        j_base = int(np.floor(sx))\n        k_base = int(np.floor(sy))\n\n        for dj in range(-1, 3):\n            for dk in range(-1, 3):\n                j = j_base + dj\n                k = k_base + dk\n                \n                rx = sx - j\n                ry = sy - k\n                \n                j_idx, k_idx = j % N, k % N\n                \n                weight = kernel_func(rx) * kernel_func(ry) / h**2\n                \n                Fx[k_idx, j_idx] += lag_force_x * weight\n                Fy[k_idx, j_idx] += lag_force_y * weight\n\n    # --- Step 2: Solve steady Stokes equations in Fourier space ---\n    Fx_hat = scipy.fft.fft2(Fx)\n    Fy_hat = scipy.fft.fft2(Fy)\n\n    freq = scipy.fft.fftfreq(N, h)\n    kx_1d = 2 * np.pi * freq\n    Ky, Kx = np.meshgrid(kx_1d, kx_1d, indexing='ij')\n\n    Ksq = Kx**2 + Ky**2\n    \n    inv_Ksq = np.zeros_like(Ksq)\n    nonzero_mask = Ksq != 0\n    inv_Ksq[nonzero_mask] = 1.0 / Ksq[nonzero_mask]\n    \n    k_dot_Fhat = Kx * Fx_hat + Ky * Fy_hat\n    \n    Fx_hat_solenoidal = Fx_hat - Kx * k_dot_Fhat * inv_Ksq\n    Fy_hat_solenoidal = Fy_hat - Ky * k_dot_Fhat * inv_Ksq\n    \n    ux_hat = Fx_hat_solenoidal * inv_Ksq / mu\n    uy_hat = Fy_hat_solenoidal * inv_Ksq / mu\n\n    ux = np.real(scipy.fft.ifft2(ux_hat))\n    uy = np.real(scipy.fft.ifft2(uy_hat))\n\n    # --- Step 3: Interpolation (Eulerian velocity to Lagrangian points) ---\n    Ux = np.zeros(N_L)\n    Uy = np.zeros(N_L)\n\n    for i in range(N_L):\n        sx = X_lag[i] / h\n        sy = Y_lag[i] / h\n        \n        j_base = int(np.floor(sx))\n        k_base = int(np.floor(sy))\n\n        for dj in range(-1, 3):\n            for dk in range(-1, 3):\n                j = j_base + dj\n                k = k_base + dk\n                \n                rx = sx - j\n                ry = sy - k\n                \n                j_idx, k_idx = j % N, k % N\n                \n                weight = kernel_func(rx) * kernel_func(ry)\n                \n                Ux[i] += ux[k_idx, j_idx] * weight\n                Uy[i] += uy[k_idx, j_idx] * weight\n                \n    # --- Step 4: Calculate Area Change Rate (Leakage) ---\n    dAdt = np.sum((Ux * nx + Uy * ny)) * ds\n    \n    return dAdt\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (kernel_name, spacing_ratio_s, pressure_jump_dp)\n        ('peskin4', 1.0, 1.0),\n        ('peskin4', 0.5, 1.0),\n        ('peskin4', 2.0, 1.0),\n        ('bspline3', 1.0, 1.0),\n        ('bspline3', 0.5, 1.0),\n        ('bspline3', 2.0, 1.0),\n        ('peskin4', 1.0, 0.0), # Edge case\n    ]\n\n    results = []\n    for kernel_name, s, dp in test_cases:\n        result = compute_leakage(kernel_name, s, dp)\n        results.append(result)\n\n    # Format output as a comma-separated list of floats in brackets\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}