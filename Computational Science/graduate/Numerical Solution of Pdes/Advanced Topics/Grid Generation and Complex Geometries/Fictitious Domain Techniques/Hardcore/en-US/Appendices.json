{
    "hands_on_practices": [
        {
            "introduction": "The power of fictitious domain techniques often lies in their ability to handle sharp material interfaces without requiring a complex, body-fitted mesh. This practice provides a foundational understanding of this capability by exploring a one-dimensional diffusion problem with a piecewise-constant coefficient. You will implement and compare a naive discretization against a physically-consistent \"stabilized\" scheme, allowing you to quantitatively observe how a simple arithmetic average for interface conductivity fails under high contrast, while a harmonic average remains robust. This exercise  is a crucial first step in appreciating the subtleties of designing accurate and stable numerical methods for interface problems.",
            "id": "3392223",
            "problem": "Consider the scalar elliptic interface problem in one spatial dimension posed on the interval $[-1,1]$: find $u:[-1,1]\\to\\mathbb{R}$ such that\n$$\n-\\frac{d}{dx}\\left(\\kappa(x)\\,\\frac{du}{dx}\\right)=0 \\quad \\text{for } x\\in(-1,1),\n$$\nwith Dirichlet boundary conditions $u(-1)=-1$ and $u(1)=1$, where the conductivity $\\kappa(x)$ is piecewise constant with a single jump located at a prescribed interface point $\\xi\\in(-1,1)$, namely\n$$\n\\kappa(x)=\n\\begin{cases}\n\\kappa_1, & x<\\xi,\\\\\n\\kappa_2, & x\\ge \\xi,\n\\end{cases}\n$$\nfor given positive constants $\\kappa_1$ and $\\kappa_2$. The interface conditions are the continuity of $u$ at $x=\\xi$ and the continuity of the normal flux,\n$$\nu(\\xi^-)=u(\\xi^+),\\qquad \\kappa_1\\,\\frac{du}{dx}(\\xi^-)=\\kappa_2\\,\\frac{du}{dx}(\\xi^+).\n$$\nThis formulation is a canonical model for the analysis of fictitious domain techniques in the numerical solution of partial differential equations, where the interface cut position $\\xi$ is generally independent of the discretization grid.\n\nStarting from the weak formulation and standard conservation principles, your goal is to design and implement two numerical schemes on a uniform grid for this interface problem:\n\n- an unstabilized scheme that uses a naive face conductivity model insensitive to the cut position $\\xi$;\n- a stabilized scheme that incorporates a consistent flux model across the cut face, using the series-limiting behavior of conductances along the face interval split by the interface.\n\nThe stabilized scheme must be robust under high contrast $\\kappa_1\\ll \\kappa_2$ and should capture the correct flux continuity at the interface irrespective of the cut position $\\xi$. The unstabilized scheme should intentionally lack this robustness by modeling the face conductivity using a simple position-insensitive averaging rule. Both schemes must assemble a tridiagonal Symmetric Positive Definite (SPD) linear system on the interior nodes and enforce the Dirichlet boundary conditions strongly.\n\nTo make the study quantitatively testable, proceed as follows.\n\n1. Derive the exact solution $u_{\\text{ex}}(x)$ for general $\\xi\\in(-1,1)$ and positive $\\kappa_1,\\kappa_2$ under the stated boundary and interface conditions. The exact solution is piecewise linear, with different slopes on $(-1,\\xi)$ and $(\\xi,1)$ constrained by flux continuity.\n\n2. Implement both numerical schemes on a uniform grid of $N$ nodes on $[-1,1]$ (including endpoints), with spacing $h=2/(N-1)$. The fictitious domain aspect arises from the fact that the interface $\\xi$ can be located anywhere in $(-1,1)$ independently of the grid; if the interface lies strictly inside an interval $[x_{i-1},x_i]$, the stabilized scheme must reflect the correct conservation across this cut interval.\n\n3. For each scheme, compute the discrete solution $u_h$ and evaluate the error in the $H^1$ seminorm using a cellwise integral of the gradient error. Specifically, for each cell $[x_{i-1},x_i]$ with length $h$, define the cell gradient of the discrete solution by\n$$\ng_h^{(i)}=\\frac{u_h(x_i)-u_h(x_{i-1})}{h}.\n$$\nThe exact gradient is piecewise constant, equal to the left slope on $[x_{i-1},x_i]\\subset(-1,\\xi)$ and the right slope on $[x_{i-1},x_i]\\subset(\\xi,1)$; if the interface lies strictly inside the cell, split the integral into the left and right subintervals. Approximate the $H^1$ seminorm of the error by\n$$\n\\|u_h-u_{\\text{ex}}\\|_{H^1( -1,1)} \\approx \\left(\\sum_{i=1}^{N-1}\\int_{x_{i-1}}^{x_i}\\big(g_h^{(i)}-u_{\\text{ex}}'(x)\\big)^2\\,dx\\right)^{1/2}.\n$$\n\n4. Define the $H^1$ error constant for each scheme by normalizing the error with the theoretically expected convergence rate for this interface-limited problem. Since the dominant contribution is localized near the single cut cell and the exact solution has a slope discontinuity, assume the expected rate in the $H^1$ seminorm is proportional to $h^{1/2}$ and compute\n$$\nC_{H^1} = \\frac{\\|u_h-u_{\\text{ex}}\\|_{H^1(-1,1)}}{\\sqrt{h}}.\n$$\nReport $C_{H^1}$ for the unstabilized and stabilized schemes separately. Analyze how $C_{H^1}$ depends on the contrast parameters $\\kappa_1$ and $\\kappa_2$.\n\nYour program must implement the above and produce quantitative results for the following test suite of parameter values $(\\kappa_1,\\kappa_2,\\xi,N)$:\n\n- Test 1 (baseline equal conductivities): $(\\kappa_1,\\kappa_2,\\xi,N)=(1,1,0.3,501)$.\n- Test 2 (moderate high contrast): $(\\kappa_1,\\kappa_2,\\xi,N)=(10^{-3},1,0.3,501)$.\n- Test 3 (extreme high contrast): $(\\kappa_1,\\kappa_2,\\xi,N)=(10^{-6},1,0.3,501)$.\n- Test 4 (aligned interface edge case): $(\\kappa_1,\\kappa_2,\\xi,N)=(10^{-6},1,0.0,501)$.\n\nFor each test case, your program must compute and output a list of two floats $[C_{H^1}^{\\text{unstab}}, C_{H^1}^{\\text{stab}}]$, where $C_{H^1}^{\\text{unstab}}$ is the error constant for the unstabilized scheme and $C_{H^1}^{\\text{stab}}$ is the error constant for the stabilized scheme. The final output must aggregate all test case results into a single line of text containing the list of lists in the following exact format:\n\n\"Your program should produce a single line of output containing the results as a comma-separated list of per-test-case two-float lists enclosed in square brackets (e.g., [[c11,c12],[c21,c22],[c31,c32],[c41,c42]]).\"\n\nNo physical units or angle units are involved in this problem. The floats in the output should be represented numerically (decimal or scientific notation is acceptable). The problem focuses on the derivation, robustness analysis, and contrast dependence in the context of fictitious domain techniques.",
            "solution": "The user-provided problem is a valid, well-posed, and scientifically grounded exercise in numerical analysis for partial differential equations. All necessary data and conditions are provided to derive an analytical solution, implement two distinct numerical schemes, and quantitatively evaluate their performance. The problem is objective and directly addresses the core concepts of fictitious domain techniques, specifically the treatment of interfaces that do not align with the computational grid.\n\n### 1. Analytical Solution\nThe problem is governed by the one-dimensional steady-state diffusion equation:\n$$\n-\\frac{d}{dx}\\left(\\kappa(x)\\,\\frac{du}{dx}\\right)=0 \\quad \\text{for } x\\in(-1,1)\n$$\nIntegrating once with respect to $x$ shows that the flux, $J(x) = -\\kappa(x) \\frac{du}{dx}$, must be a constant, say $J_0$. Thus, $\\frac{du}{dx} = -J_0/\\kappa(x)$. Integrating a second time gives a piecewise linear solution. Let's define $C = -J_0$.\n$$\nu'(x) = \\frac{C}{\\kappa(x)} =\n\\begin{cases}\nC/\\kappa_1, & x<\\xi \\\\\nC/\\kappa_2, & x\\ge\\xi\n\\end{cases}\n$$\nIntegrating and applying the boundary conditions $u(-1)=-1$ and $u(1)=1$, and enforcing continuity of the solution $u(x)$ at the interface $x=\\xi$, we obtain the solution:\n$$\nu_{\\text{ex}}(x) =\n\\begin{cases}\n\\frac{C}{\\kappa_1}(x+1) - 1, & x \\in [-1, \\xi) \\\\\n\\frac{C}{\\kappa_2}(x-1) + 1, & x \\in [\\xi, 1]\n\\end{cases}\n$$\nThe constant $C$ is determined by the continuity condition $u(\\xi^-)=u(\\xi^+)$:\n$$\n\\frac{C}{\\kappa_1}(\\xi+1) - 1 = \\frac{C}{\\kappa_2}(\\xi-1) + 1\n$$\nSolving for $C$ yields:\n$$\nC = \\frac{2 \\kappa_1 \\kappa_2}{\\kappa_2(\\xi+1) - \\kappa_1(\\xi-1)}\n$$\nThis analytical solution provides the exact gradient $u_{\\text{ex}}'(x)$ needed for the error computation, which is piecewise constant: $u_{\\text{ex}}'(x) = C/\\kappa_1$ for $x < \\xi$ and $u_{\\text{ex}}'(x) = C/\\kappa_2$ for $x \\ge \\xi$.\n\n### 2. Numerical Discretization\nWe employ a finite volume method on a uniform grid $x_i = -1 + ih$ for $i=0, \\dots, N-1$, with mesh spacing $h=2/(N-1)$. Integrating the PDE over a control volume $[x_{i-1/2}, x_{i+1/2}]$ centered at each interior node $x_i$ leads to the conservation law:\n$$\n\\left(-\\kappa\\frac{du}{dx}\\right)_{x_{i+1/2}} - \\left(-\\kappa\\frac{du}{dx}\\right)_{x_{i-1/2}} = 0\n$$\nThis states that the flux entering the control volume equals the flux leaving it. We approximate the flux at the cell face $x_{i-1/2}$ (midpoint between $x_{i-1}$ and $x_i$) as:\n$$\nJ_{i-1/2} = -\\kappa_{i-1/2} \\frac{u_i - u_{i-1}}{h}\n$$\nwhere $u_i \\approx u(x_i)$ and $\\kappa_{i-1/2}$ is an effective conductivity for the interval $[x_{i-1}, x_i]$. The discrete equation for each interior node $i=1, \\dots, N-2$ is:\n$$\n-\\kappa_{i+1/2}\\frac{u_{i+1}-u_i}{h} + \\kappa_{i-1/2}\\frac{u_i-u_{i-1}}{h} = 0\n$$\nRearranging, we get the stencil for a tridiagonal system:\n$$\n-\\kappa_{i-1/2} u_{i-1} + (\\kappa_{i-1/2} + \\kappa_{i+1/2}) u_i - \\kappa_{i+1/2} u_{i+1} = 0\n$$\nThe distinction between the two required schemes lies in the definition of the face conductivity $\\kappa_{i-1/2}$.\n\n### 3. Unstabilized Scheme\nThis scheme uses a naive, position-insensitive averaging rule. A standard choice is the arithmetic mean of the conductivity values at the adjacent nodes:\n$$\n\\kappa_{i-1/2}^{\\text{unstab}} = \\frac{\\kappa(x_{i-1}) + \\kappa(x_i)}{2}\n$$\nwhere $\\kappa(x_j) = \\kappa_1$ if $x_j < \\xi$ and $\\kappa_2$ if $x_j \\ge \\xi$. This model is easy to implement but fails to correctly represent the physics of flow through a layered medium, especially under high contrast, as it is only sensitive to which nodes fall on either side of the interface, not its precise location within a cell.\n\n### 4. Stabilized Scheme\nThis scheme uses a physically consistent model for effective conductivity, reflecting the series-limiting behavior of resistances. The thermal/electrical resistance of a 1D segment of length $L$ and conductivity $\\kappa$ is $R=L/\\kappa$. For two segments in series, resistances add. The effective conductivity $\\kappa_{i-1/2}$ for the interval $[x_{i-1}, x_i]$ of length $h$ is derived from its total resistance:\n$$\nR_{\\text{cell}} = \\int_{x_{i-1}}^{x_i} \\frac{dx'}{\\kappa(x')} = \\frac{h}{\\kappa_{i-1/2}}\n$$\nThis gives the harmonic average of conductivities.\nIf the interface $\\xi$ is not in $(x_{i-1}, x_i)$, $\\kappa(x)$ is constant, and $\\kappa_{i-1/2}^{\\text{stab}}$ is either $\\kappa_1$ or $\\kappa_2$.\nIf the interface lies in the cell, $x_{i-1} < \\xi < x_i$, the integral is split:\n$$\n\\int_{x_{i-1}}^{x_i} \\frac{dx'}{\\kappa(x')} = \\int_{x_{i-1}}^{\\xi} \\frac{dx'}{\\kappa_1} + \\int_{\\xi}^{x_i} \\frac{dx'}{\\kappa_2} = \\frac{\\xi-x_{i-1}}{\\kappa_1} + \\frac{x_i-\\xi}{\\kappa_2}\n$$\nThe stabilized face conductivity is thus:\n$$\n\\kappa_{i-1/2}^{\\text{stab}} = \\frac{h}{\\frac{\\xi-x_{i-1}}{\\kappa_1} + \\frac{x_i-\\xi}{\\kappa_2}}\n$$\nThis formulation is robust as it correctly captures the flux-limiting behavior of the low-conductivity material, regardless of the sub-grid location of $\\xi$ or the contrast ratio $\\kappa_2/\\kappa_1$.\n\n### 5. Linear System and Boundary Conditions\nFor both schemes, a linear system $A\\mathbf{u}=\\mathbf{b}$ is assembled for the vector of unknown interior nodal values $\\mathbf{u} = [u_1, \\dots, u_{N-2}]^T$. The matrix $A$ is an $(N-2)\\times(N-2)$ symmetric positive-definite (SPD) tridiagonal matrix. The Dirichlet boundary conditions $u_0 = u(-1) = -1$ and $u_{N-1} = u(1) = 1$ are incorporated by moving their contributions to the right-hand side vector $\\mathbf{b}$.\nFor the first equation ($i=1$):\n$$\n(\\kappa_{1/2} + \\kappa_{3/2})u_1 - \\kappa_{3/2}u_2 = -\\kappa_{1/2}u_0 = \\kappa_{1/2}\n$$\nFor the last equation ($i=N-2$):\n$$\n-\\kappa_{N-5/2}u_{N-3} + (\\kappa_{N-5/2} + \\kappa_{N-3/2})u_{N-2} = \\kappa_{N-3/2}u_{N-1} = \\kappa_{N-3/2}\n$$\nThe resulting SPD system is efficiently solved using a standard banded matrix solver.\n\n### 6. Error Norm Calculation\nThe error is evaluated in the $H^1$ seminorm, approximated by a sum over grid cells:\n$$\n\\|u_h-u_{\\text{ex}}\\|_{H^1(-1,1)}^2 \\approx \\sum_{i=1}^{N-1}\\int_{x_{i-1}}^{x_i}\\big(g_h^{(i)}-u_{\\text{ex}}'(x)\\big)^2\\,dx\n$$\nwhere $g_h^{(i)} = (u_h(x_i) - u_h(x_{i-1})) / h$ is the piecewise constant gradient of the numerical solution. The integral for each cell $[x_{i-1}, x_i]$ is computed by considering two cases:\n1.  **Non-cut cell**: If $\\xi \\notin (x_{i-1}, x_i)$, $u_{\\text{ex}}'(x)$ is constant in the cell, and the integral is $(g_h^{(i)} - u_{\\text{ex}}')^2 h$.\n2.  **Cut cell**: If $x_{i-1} < \\xi < x_i$, the integral is split at $\\xi$:\n    $$\n    (g_h^{(i)} - C/\\kappa_1)^2(\\xi-x_{i-1}) + (g_h^{(i)} - C/\\kappa_2)^2(x_i-\\xi)\n    $$\nFinally, the error constant $C_{H^1}$ is calculated by normalizing the error with the expected convergence rate of $h^{1/2}$:\n$$\nC_{H^1} = \\frac{\\|u_h-u_{\\text{ex}}\\|_{H^1(-1,1)}}{\\sqrt{h}}\n$$\nThis constant provides a measure of the method's accuracy that is independent of the grid size $N$, allowing for a fair comparison of the schemes' robustness to parameter changes, particularly the conductivity contrast.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (k1, k2, xi, N)\n        (1.0, 1.0, 0.3, 501),\n        (1e-3, 1.0, 0.3, 501),\n        (1e-6, 1.0, 0.3, 501),\n        (1e-6, 1.0, 0.0, 501),\n    ]\n\n    all_results = []\n\n    for k1, k2, xi, N in test_cases:\n        h = 2.0 / (N - 1)\n        x = np.linspace(-1.0, 1.0, N)\n        \n        # Boundary conditions\n        u_left_bc = -1.0\n        u_right_bc = 1.0\n        \n        # Exact solution constant\n        denominator = k2 * (xi + 1.0) - k1 * (xi - 1.0)\n        # Avoid division by zero if conductivities are zero, though problem states positive.\n        if abs(denominator) < 1e-15:\n            C_exact = 0.0 # Should not happen with positive k1,k2\n        else:\n            C_exact = (2.0 * k1 * k2) / denominator\n\n        u_prime_left = C_exact / k1 if k1 > 0 else 0\n        u_prime_right = C_exact / k2 if k2 > 0 else 0\n\n        case_results = []\n        for scheme in ['unstabilized', 'stabilized']:\n            # 1. Assemble face conductivities\n            num_faces = N - 1\n            k_face = np.zeros(num_faces)\n            \n            if scheme == 'unstabilized':\n                kappa_node = np.where(x < xi, k1, k2)\n                # Handle the case where xi is exactly on a node\n                # The rule is k(x)=k2 for x >= xi\n                for i in range(N):\n                    if x[i] >= xi:\n                        kappa_node[i] = k2\n                \n                for i in range(num_faces):\n                    k_face[i] = (kappa_node[i] + kappa_node[i+1]) / 2.0\n            \n            else: # stabilized\n                for i in range(num_faces):\n                    x_l, x_r = x[i], x[i+1]\n                    if xi <= x_l + 1e-15: # Cell is in a region of k2\n                        k_face[i] = k2\n                    elif xi >= x_r - 1e-15: # Cell is in a region of k1\n                        k_face[i] = k1\n                    else: # Cell is cut by the interface\n                        resist_1 = (xi - x_l) / k1\n                        resist_2 = (x_r - xi) / k2\n                        k_face[i] = h / (resist_1 + resist_2)\n            \n            # 2. Assemble the linear system A*u = b for interior nodes\n            num_interior_nodes = N - 2\n            # Scipy's banded solver format: (l+u+1, M)\n            # Here: l=1, u=1, M = N-2. Matrix is (3, N-2)\n            # ab[0,:] = super-diagonal, ab[1,:] = main-diagonal, ab[2,:] = sub-diagonal\n            ab = np.zeros((3, num_interior_nodes))\n            b = np.zeros(num_interior_nodes)\n\n            # Main diagonal\n            ab[1, :] = k_face[:-1] + k_face[1:]\n            # Off-diagonals\n            ab[0, 1:] = -k_face[1:-1]\n            ab[2, :-1] = -k_face[1:-1]\n            \n            # Incorporate boundary conditions into RHS vector b\n            b[0] = k_face[0] * u_left_bc\n            b[-1] = k_face[-1] * u_right_bc\n\n            # 3. Solve the system\n            u_interior = solve_banded((1, 1), ab, b)\n            u_h = np.concatenate(([u_left_bc], u_interior, [u_right_bc]))\n\n            # 4. Compute H^1 seminorm error\n            error_sq_sum = 0.0\n            for i in range(1, N):\n                x_l, x_r = x[i-1], x[i]\n                g_h_i = (u_h[i] - u_h[i-1]) / h\n                \n                cell_error_sq = 0.0\n                if xi <= x_l + 1e-15: # Cell is entirely in right part\n                    cell_error_sq = (g_h_i - u_prime_right)**2 * h\n                elif xi >= x_r - 1e-15: # Cell is entirely in left part\n                    cell_error_sq = (g_h_i - u_prime_left)**2 * h\n                else: # Cell is cut by interface\n                    err_left_part = (g_h_i - u_prime_left)**2 * (xi - x_l)\n                    err_right_part = (g_h_i - u_prime_right)**2 * (x_r - xi)\n                    cell_error_sq = err_left_part + err_right_part\n                \n                error_sq_sum += cell_error_sq\n\n            h1_seminorm_error = np.sqrt(error_sq_sum)\n            C_H1 = h1_seminorm_error / np.sqrt(h)\n            case_results.append(C_H1)\n            \n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'[{res[0]},{res[1]}]' for res in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The Immersed Boundary Method (IBM) is a classic fictitious domain approach widely used for simulating fluid-structure interactions, from biological systems to engineering applications. A key feature of IBM is the use of a regularized Dirac delta function to communicate forces and velocities between the fluid grid and the immersed structure. This practice  guides you through a 2D simulation of an elastic membrane under pressure, focusing on a critical numerical artifact known as \"leakage\"â€”a spurious flow across the boundary that violates mass conservation. By computing this leakage, you will gain hands-on experience with the core components of an IBM solver and learn how discretization choices, such as the kernel function and point spacing, impact the physical fidelity of the simulation.",
            "id": "3510140",
            "problem": "Consider a two-dimensional, periodic square domain described by the interval $[0,1]\\times[0,1]$ discretized on a uniform Cartesian grid with $N$ points per direction and grid spacing $h=1/N$. A closed elastic boundary is represented by a circular membrane of radius $R$ centered at $(0.5,0.5)$, discretized by $N_{\\mathrm{L}}$ equally spaced Lagrangian points with angular parametrization $\\theta_i = 2\\pi i/N_{\\mathrm{L}}$ (angles specified in radians). Assume a uniform pressure jump $\\Delta p$ across the membrane, causing a normal traction per unit length equal to $\\Delta p\\,\\mathbf{n}$ on the membrane, where $\\mathbf{n}$ is the outward unit normal.\n\nIn the Immersed Boundary Method (IBM), Lagrangian-to-Eulerian coupling uses a regularized Dirac delta to spread the membrane traction from Lagrangian points $(X_i)$ to the Eulerian grid, and to interpolate the Eulerian velocity back to the Lagrangian points. Specifically, define the regularized delta as\n$$\n\\delta_h(\\mathbf{x})=\\frac{1}{h^2}\\,\\phi\\left(\\frac{x}{h}\\right)\\,\\phi\\left(\\frac{y}{h}\\right),\n$$\nwith a compactly supported one-dimensional kernel $\\phi(\\cdot)$ chosen from a set of candidates. The Eulerian force density is then\n$$\n\\mathbf{F}(\\mathbf{x})=\\sum_{i=0}^{N_{\\mathrm{L}}-1} \\Delta p\\,\\mathbf{n}_i\\,\\delta_h(\\mathbf{x}-\\mathbf{X}_i)\\,ds,\n$$\nwhere $ds = 2\\pi R/N_{\\mathrm{L}}$ is the segment length. The Eulerian velocity $\\mathbf{u}$ is governed by the steady Stokes equations in the absence of inertial effects,\n$$\n-\\nabla p + \\mu \\Delta \\mathbf{u} + \\mathbf{F} = \\mathbf{0},\\qquad \\nabla\\cdot\\mathbf{u} = 0,\n$$\nwith dynamic viscosity $\\mu$ and periodic boundary conditions. The unique solenoidal solution for $\\mathbf{u}$ on this periodic domain can be expressed spectrally using the Fast Fourier Transform (FFT), projecting the forcing onto the divergence-free subspace and dividing by the Laplacian eigenvalue, for all nonzero wavenumbers.\n\nThe Lagrangian velocity $\\mathbf{U}_i$ is obtained by interpolation,\n$$\n\\mathbf{U}_i = \\sum_{\\text{grid }\\mathbf{x}} \\mathbf{u}(\\mathbf{x}) \\,\\delta_h(\\mathbf{X}_i - \\mathbf{x})\\,h^2,\n$$\nand the area flux across the membrane (which, in two dimensions, corresponds to the volumetric rate of change per unit depth) is computed by the line integral of the normal velocity,\n$$\n\\frac{dA}{dt} = \\oint_{\\Gamma} \\mathbf{u}\\cdot\\mathbf{n}\\,ds \\approx \\sum_{i=0}^{N_{\\mathrm{L}}-1} \\mathbf{U}_i\\cdot\\mathbf{n}_i\\,ds.\n$$\nIn the continuum, for an incompressible flow ($\\nabla\\cdot\\mathbf{u}=0$) enclosing a material volume, the area change rate $dA/dt$ would be identically zero by the divergence theorem. However, in the discrete Immersed Boundary Method, $dA/dt$ may be nonzero due to the mismatch between spreading and interpolation induced by the choice of kernel $\\phi(\\cdot)$ and the Lagrangian spacing relative to the Eulerian grid. This spurious nonzero $dA/dt$ is known as leakage.\n\nYour task is to implement a program that:\n- Discretizes the membrane as described.\n- Spreads the uniform pressure traction using a selected regularized delta kernel.\n- Solves the steady Stokes equations on the periodic domain using spectral projection.\n- Interpolates velocities back to the membrane.\n- Computes the area change rate $dA/dt$ as described.\n\nYou must treat all quantities in dimensionless form. Angles must be in radians. For kernel $\\phi(\\cdot)$, you must support at least the following choices:\n- Peskin four-point kernel (Immersed Boundary Method kernel):\n$$\n\\phi(r)=\\begin{cases}\n\\frac{1}{8}\\left(3-2|r|+\\sqrt{1+4|r|-4r^2}\\right), & |r|<1,\\\\\n\\frac{1}{8}\\left(5-2|r|-\\sqrt{-7+12|r|-4r^2}\\right), & 1\\le |r|<2,\\\\\n0, & \\text{otherwise,}\n\\end{cases}\n$$\n- Cardinal cubic B-spline:\n$$\n\\phi(r)=\\begin{cases}\n\\frac{1}{6}\\left(4-6|r|^2+3|r|^3\\right), & |r|<1,\\\\\n\\frac{1}{6}\\left(2-|r|\\right)^3, & 1\\le |r|<2,\\\\\n0, & \\text{otherwise.}\n\\end{cases}\n$$\n\nFor all computations, set $N=64$, $h=1/N$, $R=0.25$, $\\mu=1$. Define the Lagrangian spacing ratio $s=ds/h$ and determine $N_{\\mathrm{L}}$ from $s$ via $N_{\\mathrm{L}} = \\left\\lfloor \\frac{2\\pi R}{s\\,h} \\right\\rfloor$, with the constraint $N_{\\mathrm{L}}\\ge 8$. Use the outward normal $\\mathbf{n}_i=[\\cos\\theta_i,\\sin\\theta_i]$. The wavenumbers for FFT-based differentiation must be $k_x=2\\pi\\,\\mathrm{freq}_x$ and $k_y=2\\pi\\,\\mathrm{freq}_y$, where $\\mathrm{freq}$ are the standard discrete Fourier frequencies for spacing $h$.\n\nDesign your code to compute $dA/dt$ for the following test suite of parameter sets, each specified by the pair $(\\text{kernel},s)$ and the pressure jump $\\Delta p$:\n- Case $1$: $(\\text{peskin4},\\,s=1.0)$ with $\\Delta p=1$.\n- Case $2$: $(\\text{peskin4},\\,s=0.5)$ with $\\Delta p=1$.\n- Case $3$: $(\\text{peskin4},\\,s=2.0)$ with $\\Delta p=1$.\n- Case $4$: $(\\text{bspline3},\\,s=1.0)$ with $\\Delta p=1$.\n- Case $5$: $(\\text{bspline3},\\,s=0.5)$ with $\\Delta p=1$.\n- Case $6$: $(\\text{bspline3},\\,s=2.0)$ with $\\Delta p=1$.\n- Case $7$ (edge case): $(\\text{peskin4},\\,s=1.0)$ with $\\Delta p=0$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases $1$ through $7$, where each result is the computed $dA/dt$ as a float. Because all quantities are dimensionless, do not attach any physical units to the outputs. The angle unit is radians; all outputs must be decimal floats. The output format must be exactly\n$$\n[\\text{result}_1,\\text{result}_2,\\ldots,\\text{result}_7],\n$$\nwith each $\\text{result}_i$ a float value.",
            "solution": "The problem is deemed valid as it is scientifically grounded in the principles of computational fluid dynamics, specifically the Immersed Boundary Method (IBM), and is a well-posed numerical problem with a complete and consistent set of givens. The task involves simulating fluid-structure interaction to quantify a known numerical artifact, \"leakage,\" which arises from the discretization and choice of coupling kernels.\n\nThe solution proceeds by implementing the described numerical method step-by-step for each test case.\n\n**1. Discretization of Domain and Boundary**\n\nThe physical setup consists of a two-dimensional periodic domain $\\Omega = [0,1] \\times [0,1]$ and a circular membrane $\\Gamma$ of radius $R=0.25$ centered at $(0.5, 0.5)$.\n\n- **Eulerian Grid**: The domain $\\Omega$ is discretized into a uniform Cartesian grid of $N \\times N$ points, with $N=64$. The grid spacing is $h = 1/N = 1/64$. The grid points are located at $\\mathbf{x}_{j,k} = (j h, k h)$ for $j,k \\in \\{0, 1, \\dots, N-1\\}$.\n\n- **Lagrangian Grid**: The membrane $\\Gamma$ is discretized into $N_{\\mathrm{L}}$ Lagrangian points. The number of points, $N_{\\mathrm{L}}$, is determined by the Lagrangian spacing ratio $s = ds/h$, where $ds$ is the arc length between adjacent Lagrangian points. The formula is $N_{\\mathrm{L}} = \\lfloor \\frac{2\\pi R}{s h} \\rfloor$. The arc length is then re-calculated as $ds = 2\\pi R/N_{\\mathrm{L}}$ to ensure the discretized loop is closed. The positions of the Lagrangian points are given by a parametrization in terms of angle $\\theta_i = 2\\pi i/N_{\\mathrm{L}}$ for $i \\in \\{0, 1, \\dots, N_{\\mathrm{L}}-1\\}$:\n$$\n\\mathbf{X}_i = (0.5 + R\\cos\\theta_i, 0.5 + R\\sin\\theta_i)\n$$\nThe outward unit normal vector at each point $\\mathbf{X}_i$ is $\\mathbf{n}_i = (\\cos\\theta_i, \\sin\\theta_i)$.\n\n**2. Kernels and Regularized Delta Function**\n\nThe interaction between the fluid (Eulerian) and the structure (Lagrangian) is mediated by a regularized Dirac delta function, $\\delta_h(\\mathbf{x})$, constructed from a one-dimensional kernel $\\phi(r)$. Two specified kernels, the Peskin 4-point kernel and the cubic B-spline, are implemented according to their piecewise definitions. Both kernels have a compact support of $4h$, meaning $\\phi(r)=0$ for $|r| \\ge 2$.\n\n**3. Spreading: From Lagrangian Force to Eulerian Force Density**\n\nA uniform pressure jump $\\Delta p$ across the membrane generates a normal force per unit length (traction) equal to $\\Delta p \\, \\mathbf{n}$. The discrete force at each Lagrangian point $\\mathbf{X}_i$ is $\\mathbf{f}_i = \\Delta p \\, \\mathbf{n}_i \\, ds$.\n\nThis Lagrangian force is \"spread\" onto the surrounding Eulerian grid points to obtain the Eulerian force density field, $\\mathbf{F}(\\mathbf{x})$. The formula for this spreading operation is:\n$$\n\\mathbf{F}(\\mathbf{x}) = \\sum_{i=0}^{N_{\\mathrm{L}}-1} \\mathbf{f}_i \\, \\delta_h(\\mathbf{x} - \\mathbf{X}_i) = \\frac{1}{h^2} \\sum_{i=0}^{N_{\\mathrm{L}}-1} (\\Delta p \\, \\mathbf{n}_i \\, ds) \\, \\phi\\left(\\frac{x-X_{i,x}}{h}\\right) \\phi\\left(\\frac{y-X_{i,y}}{h}\\right)\n$$\nNumerically, for each Lagrangian point $\\mathbf{X}_i$, we identify the nearby Eulerian grid points $\\mathbf{x}_{j,k}$ that fall within the kernel's support. The force contribution is then calculated and added to the corresponding elements of the Eulerian force arrays, `Fx` and `Fy`. Due to the periodic domain, distances are computed considering the wrap-around nature of the grid.\n\n**4. Solving the Steady Stokes Equations**\n\nThe fluid velocity $\\mathbf{u}$ and pressure $p$ are governed by the steady Stokes equations with periodic boundary conditions:\n$$\n-\\nabla p + \\mu \\Delta \\mathbf{u} + \\mathbf{F} = \\mathbf{0}, \\qquad \\nabla\\cdot\\mathbf{u} = 0\n$$\nGiven the periodicity, these equations are efficiently solved in Fourier space. Applying the Fast Fourier Transform (FFT) to the equations yields:\n$$\n-i\\mathbf{k}\\hat{p} - \\mu |\\mathbf{k}|^2 \\hat{\\mathbf{u}} + \\hat{\\mathbf{F}} = \\mathbf{0}, \\qquad i\\mathbf{k}\\cdot\\hat{\\mathbf{u}} = 0\n$$\nwhere $\\hat{\\cdot}$ denotes the Fourier transform, $\\mathbf{k}=(k_x, k_y)$ is the wavevector, and $|\\mathbf{k}|^2=k_x^2+k_y^2$. The wavenumbers are determined by $k = 2\\pi f$, where $f$ are the discrete frequencies from `scipy.fft.fftfreq`.\n\nThe incompressibility condition ($i\\mathbf{k}\\cdot\\hat{\\mathbf{u}} = 0$) implies that the velocity vector $\\hat{\\mathbf{u}}$ is orthogonal to the wavevector $\\mathbf{k}$. By projecting the momentum equation onto the divergence-free subspace, we can solve for $\\hat{\\mathbf{u}}$ directly:\n$$\n\\hat{\\mathbf{u}}(\\mathbf{k}) = \\frac{1}{\\mu |\\mathbf{k}|^2} \\left( \\hat{\\mathbf{F}} - \\frac{(\\mathbf{k} \\cdot \\hat{\\mathbf{F}})\\mathbf{k}}{|\\mathbf{k}|^2} \\right) \\quad \\text{for } \\mathbf{k} \\neq \\mathbf{0}\n$$\nFor the zero-wavenumber mode ($\\mathbf{k}=\\mathbf{0}$), $\\hat{\\mathbf{u}}(\\mathbf{0})$ is set to zero, corresponding to zero mean velocity. The resulting velocity field in Fourier space, $(\\hat{u}_x, \\hat{u}_y)$, is transformed back to real space using the inverse FFT to obtain the Eulerian velocity field $(u_x, u_y)$.\n\n**5. Interpolation: From Eulerian Velocity to Lagrangian Velocity**\n\nThe velocity of the membrane points, $\\mathbf{U}_i$, is obtained by interpolating the Eulerian velocity field $\\mathbf{u}(\\mathbf{x})$ at the Lagrangian locations $\\mathbf{X}_i$. This operation is the adjoint of the spreading operation:\n$$\n\\mathbf{U}_i = \\sum_{\\text{grid }\\mathbf{x}} \\mathbf{u}(\\mathbf{x}) \\, \\delta_h(\\mathbf{X}_i - \\mathbf{x}) \\, h^2 = \\sum_{\\text{grid }\\mathbf{x}} \\mathbf{u}(\\mathbf{x}) \\, \\phi\\left(\\frac{X_{i,x}-x}{h}\\right) \\phi\\left(\\frac{Y_{i,y}-y}{h}\\right)\n$$\nNumerically, for each Lagrangian point $\\mathbf{X}_i$, we again identify the nearby Eulerian grid points and compute a weighted sum of their velocities to find $\\mathbf{U}_i$.\n\n**6. Computation of Area Change Rate ($dA/dt$)**\n\nFinally, the rate of change of the area enclosed by the membrane, a measure of numerical leakage, is computed by approximating the line integral of the normal velocity along the boundary:\n$$\n\\frac{dA}{dt} = \\oint_{\\Gamma} \\mathbf{u}\\cdot\\mathbf{n}\\,ds \\approx \\sum_{i=0}^{N_{\\mathrm{L}}-1} \\mathbf{U}_i\\cdot\\mathbf{n}_i\\,ds\n$$\nThis value is computed for each test case specified in the problem. The case with $\\Delta p = 0$ serves as a null test, as it should yield zero force, zero velocity, and therefore zero leakage, confirming the linearity and correctness of the base implementation.",
            "answer": "```python\nimport numpy as np\nimport scipy.fft\n\ndef peskin4_kernel(r):\n    \"\"\"\n    Computes the Peskin 4-point regularized delta function kernel.\n    \"\"\"\n    r_abs = np.abs(r)\n    val = np.zeros_like(r_abs)\n    \n    # |r| < 1\n    mask1 = r_abs < 1\n    r1 = r_abs[mask1]\n    val[mask1] = (1/8) * (3 - 2*r1 + np.sqrt(1 + 4*r1 - 4*r1**2))\n    \n    # 1 <= |r| < 2\n    mask2 = (r_abs >= 1) & (r_abs < 2)\n    r2 = r_abs[mask2]\n    # Ensure argument of sqrt is non-negative due to float precision issues\n    sqrt_arg = -7 + 12*r2 - 4*r2**2\n    sqrt_arg[sqrt_arg < 0] = 0.0\n    val[mask2] = (1/8) * (5 - 2*r2 - np.sqrt(sqrt_arg))\n\n    return val\n\ndef bspline3_kernel(r):\n    \"\"\"\n    Computes the cardinal cubic B-spline kernel.\n    \"\"\"\n    r_abs = np.abs(r)\n    val = np.zeros_like(r_abs)\n    \n    # |r| < 1\n    mask1 = r_abs < 1\n    r1 = r_abs[mask1]\n    val[mask1] = (1/6) * (4 - 6*r1**2 + 3*r1**3)\n\n    # 1 <= |r| < 2\n    mask2 = (r_abs >= 1) & (r_abs < 2)\n    r2 = r_abs[mask2]\n    val[mask2] = (1/6) * (2 - r2)**3\n    \n    return val\n\ndef compute_leakage(kernel_name, s, dp):\n    \"\"\"\n    Computes the area change rate (dA/dt) for the given parameters.\n    \"\"\"\n    # System parameters\n    N = 64\n    R = 0.25\n    mu = 1.0\n    h = 1.0 / N\n\n    # Select the kernel function\n    kernels = {'peskin4': peskin4_kernel, 'bspline3': bspline3_kernel}\n    kernel_func = kernels[kernel_name]\n\n    # Lagrangian boundary discretization\n    N_L = int(np.floor(2 * np.pi * R / (s * h)))\n    ds = 2 * np.pi * R / N_L\n    theta = 2 * np.pi * np.arange(N_L) / N_L\n    \n    X_lag = 0.5 + R * np.cos(theta)\n    Y_lag = 0.5 + R * np.sin(theta)\n    nx = np.cos(theta)\n    ny = np.sin(theta)\n\n    # Sanity check: if pressure jump is zero, leakage must be zero\n    if dp == 0:\n        return 0.0\n\n    # --- Step 1: Spreading (Lagrangian force to Eulerian grid) ---\n    Fx = np.zeros((N, N))\n    Fy = np.zeros((N, N))\n    \n    for i in range(N_L):\n        lag_force_x = dp * nx[i] * ds\n        lag_force_y = dp * ny[i] * ds\n        \n        sx = X_lag[i] / h\n        sy = Y_lag[i] / h\n        \n        j_base = int(np.floor(sx))\n        k_base = int(np.floor(sy))\n\n        for dj in range(-1, 3):\n            for dk in range(-1, 3):\n                j = j_base + dj\n                k = k_base + dk\n                \n                rx = sx - j\n                ry = sy - k\n                \n                j_idx, k_idx = j % N, k % N\n                \n                weight = kernel_func(rx) * kernel_func(ry) / h**2\n                \n                Fx[k_idx, j_idx] += lag_force_x * weight\n                Fy[k_idx, j_idx] += lag_force_y * weight\n\n    # --- Step 2: Solve steady Stokes equations in Fourier space ---\n    Fx_hat = scipy.fft.fft2(Fx)\n    Fy_hat = scipy.fft.fft2(Fy)\n\n    freq = scipy.fft.fftfreq(N, h)\n    kx = 2 * np.pi * freq\n    Ky, Kx = np.meshgrid(kx, kx, indexing='ij')\n\n    Ksq = Kx**2 + Ky**2\n    \n    inv_Ksq = np.zeros_like(Ksq)\n    nonzero_mask = Ksq != 0\n    inv_Ksq[nonzero_mask] = 1.0 / Ksq[nonzero_mask]\n    \n    k_dot_Fhat = Kx * Fx_hat + Ky * Fy_hat\n    \n    Fx_hat_solenoidal = Fx_hat - Kx * k_dot_Fhat * inv_Ksq\n    Fy_hat_solenoidal = Fy_hat - Ky * k_dot_Fhat * inv_Ksq\n    \n    ux_hat = Fx_hat_solenoidal * inv_Ksq / mu\n    uy_hat = Fy_hat_solenoidal * inv_Ksq / mu\n\n    ux = np.real(scipy.fft.ifft2(ux_hat))\n    uy = np.real(scipy.fft.ifft2(uy_hat))\n\n    # --- Step 3: Interpolation (Eulerian velocity to Lagrangian points) ---\n    Ux = np.zeros(N_L)\n    Uy = np.zeros(N_L)\n\n    for i in range(N_L):\n        sx = X_lag[i] / h\n        sy = Y_lag[i] / h\n        \n        j_base = int(np.floor(sx))\n        k_base = int(np.floor(sy))\n\n        for dj in range(-1, 3):\n            for dk in range(-1, 3):\n                j = j_base + dj\n                k = k_base + dk\n                \n                rx = sx - j\n                ry = sy - k\n                \n                j_idx, k_idx = j % N, k % N\n                \n                weight = kernel_func(rx) * kernel_func(ry)\n                \n                Ux[i] += ux[k_idx, j_idx] * weight\n                Uy[i] += uy[k_idx, j_idx] * weight\n                \n    # --- Step 4: Calculate Area Change Rate (Leakage) ---\n    dAdt = np.sum((Ux * nx + Uy * ny)) * ds\n    \n    return dAdt\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (kernel_name, spacing_ratio_s, pressure_jump_dp)\n        ('peskin4', 1.0, 1.0),\n        ('peskin4', 0.5, 1.0),\n        ('peskin4', 2.0, 1.0),\n        ('bspline3', 1.0, 1.0),\n        ('bspline3', 0.5, 1.0),\n        ('bspline3', 2.0, 1.0),\n        ('peskin4', 1.0, 0.0), # Edge case\n    ]\n\n    results = []\n    for kernel_name, s, dp in test_cases:\n        result = compute_leakage(kernel_name, s, dp)\n        results.append(result)\n\n    # Format output as a comma-separated list of floats in brackets\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond the force-spreading approach of the Immersed Boundary Method, another powerful class of fictitious domain techniques involves modifying the variational, or weak, formulation of the governing partial differential equation. Methods like the Cut Finite Element Method (CutFEM) use Nitsche's formulation to weakly enforce boundary or interface conditions directly on the non-conforming mesh. This practice  bridges theory and implementation by tasking you with deriving the weak formulation for an elliptic interface problem and then constructing the corresponding symmetric Nitsche-type discrete form. By working through the consistency and penalty terms, you will build a robust theoretical understanding of how these methods elegantly handle complex geometries.",
            "id": "3392239",
            "problem": "Consider a background domain $\\tilde{\\Omega} = (0,1)^{2}$ with an embedded smooth interface $\\Gamma = \\{(x,y)\\in \\tilde{\\Omega}: x=\\alpha\\}$ for a fixed $\\alpha \\in (0,1)$. The physical medium consists of two subdomains $\\Omega_{1}=\\{(x,y)\\in \\tilde{\\Omega}: x<\\alpha\\}$ and $\\Omega_{2}=\\{(x,y)\\in \\tilde{\\Omega}: x>\\alpha\\}$ occupied by materials with piecewise constant diffusion coefficients $\\kappa_{1}>0$ in $\\Omega_{1}$ and $\\kappa_{2}>0$ in $\\Omega_{2}$. Consider the elliptic interface problem\n$$\n-\\nabla\\cdot(\\kappa \\nabla u)=f \\quad \\text{in } \\Omega_{1}\\cup \\Omega_{2}, \\qquad \\kappa|_{\\Omega_{i}}=\\kappa_{i},\n$$\nwith homogeneous Neumann boundary condition on $\\partial \\tilde{\\Omega}$ and interface conditions on $\\Gamma$\n$$\n[u]=0, \\qquad [\\kappa \\partial_{n} u]=0,\n$$\nwhere $[w]=w_{1}-w_{2}$ denotes the jump of the trace from the $\\Omega_{1}$-side to the $\\Omega_{2}$-side, and $\\partial_{n}$ is the normal derivative taken with respect to the outward unit normal of $\\Omega_{1}$. \n\nTask A. Starting from the strong form and the definitions of the jump and normal traces, derive a consistent weak (variational) formulation by integrating by parts on each $\\Omega_{i}$ and incorporating the interface conditions. You must clearly identify the function space and the bilinear and linear forms.\n\nTask B. Indicate how to realize this formulation in a Cut Finite Element Method (CutFEM), i.e., on meshes that do not fit the interface $\\Gamma$. Specifically, write down a symmetric Nitsche-type unfitted bilinear form that weakly enforces the interface conditions using:\n- a weighted average of fluxes $\\{\\kappa \\partial_{n} w\\}_{\\omega}=\\omega_{1}\\kappa_{1}\\partial_{n} w_{1}+\\omega_{2}\\kappa_{2}\\partial_{n} w_{2}$ with interface-normal derivatives $\\partial_{n} w_{i}$, and weights $\\omega_{1},\\omega_{2}$ satisfying $\\omega_{1}+\\omega_{2}=1$,\n- a penalty term with harmonic mean $\\kappa_{H}=\\dfrac{2\\kappa_{1}\\kappa_{2}}{\\kappa_{1}+\\kappa_{2}}$ scaled by the local mesh size $h$ and a positive constant $\\gamma$, and\n- a ghost-penalty stabilization term $g_{h}(\\cdot,\\cdot)$ acting on faces of elements cut by $\\Gamma$.\n\nYou must specify a robust choice of the weights $\\omega_{1},\\omega_{2}$ in terms of $\\kappa_{1},\\kappa_{2}$ and indicate the scaling of the penalty. Assume $f\\in L^{2}(\\tilde{\\Omega})$ and standard continuous, piecewise affine trial and test spaces on the background mesh.\n\nTask C. Let $\\varphi(x,y)=x$. Take the trial and test functions equal to $\\varphi$ in the broken finite element space used by CutFEM in Task B. Under the symmetric Nitsche choice, with harmonic weighting and with a standard ghost-penalty that penalizes jumps of normal derivatives across interior faces in a neighborhood of $\\Gamma$, compute the value of the discrete bilinear form $a_{h}(\\varphi,\\varphi)$ you wrote in Task B as a closed-form expression depending only on $\\kappa_{1}$, $\\kappa_{2}$, and $\\alpha$. State your final answer as a single simplified analytic expression. No rounding is required and no physical units need be reported.",
            "solution": "The problem is well-posed and consists of three related tasks concerning the variational formulation and numerical treatment of an elliptic interface problem. We will address each task in sequence.\n\n## Task A: Derivation of the Weak Formulation\n\nThe strong form of the problem is given by:\n$$\n-\\nabla\\cdot(\\kappa \\nabla u)=f \\quad \\text{in } \\Omega_{1}\\cup \\Omega_{2}\n$$\nwith homogeneous Neumann boundary conditions on $\\partial\\tilde{\\Omega}$ and interface conditions on $\\Gamma$:\n$$\n[u] = u_{1}-u_{2}=0, \\qquad [\\kappa \\partial_{n} u] = \\kappa_{1} \\partial_{n} u_{1} - \\kappa_{2} \\partial_{n} u_{2}=0\n$$\nTo derive the weak formulation, we choose a suitable test function $v$ from a function space $V$ yet to be determined. We multiply the partial differential equation (PDE) by $v$ and integrate over the domain $\\tilde{\\Omega}=\\Omega_{1} \\cup \\Omega_{2}$:\n$$\n-\\int_{\\Omega_{1} \\cup \\Omega_{2}} (\\nabla\\cdot(\\kappa \\nabla u)) v \\, d\\mathbf{x} = \\int_{\\Omega_{1} \\cup \\Omega_{2}} f v \\, d\\mathbf{x}\n$$\nWe apply Green's first identity (integration by parts) to the left-hand side. Since the diffusion coefficient $\\kappa$ is discontinuous across the interface $\\Gamma$, we must perform the integration separately on each subdomain $\\Omega_{1}$ and $\\Omega_{2}$:\n$$\n-\\int_{\\Omega_{1}} (\\nabla\\cdot(\\kappa_{1} \\nabla u)) v \\, d\\mathbf{x} - \\int_{\\Omega_{2}} (\\nabla\\cdot(\\kappa_{2} \\nabla u)) v \\, d\\mathbf{x} = \\int_{\\tilde{\\Omega}} f v \\, d\\mathbf{x}\n$$\nApplying the identity $\\int_{\\Omega} (\\nabla \\cdot \\mathbf{F}) \\phi \\, d\\mathbf{x} = -\\int_{\\Omega} \\mathbf{F} \\cdot \\nabla\\phi \\, d\\mathbf{x} + \\int_{\\partial\\Omega} (\\mathbf{F} \\cdot \\mathbf{n}) \\phi \\, dS$ to each subdomain with $\\mathbf{F} = \\kappa \\nabla u$:\n$$\n\\int_{\\Omega_{1}} \\kappa_{1} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} - \\int_{\\partial\\Omega_{1}} \\kappa_{1} (\\nabla u \\cdot \\mathbf{n}_{1}) v \\, dS + \\int_{\\Omega_{2}} \\kappa_{2} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} - \\int_{\\partial\\Omega_{2}} \\kappa_{2} (\\nabla u \\cdot \\mathbf{n}_{2}) v \\, dS = \\int_{\\tilde{\\Omega}} f v \\, d\\mathbf{x}\n$$\nHere, $\\mathbf{n}_{i}$ is the outward unit normal to $\\Omega_i$. The boundaries of the subdomains are $\\partial\\Omega_{1} = (\\partial\\tilde{\\Omega} \\cap \\partial\\Omega_{1}) \\cup \\Gamma$ and $\\partial\\Omega_{2} = (\\partial\\tilde{\\Omega} \\cap \\partial\\Omega_{2}) \\cup \\Gamma$. The normal $\\mathbf{n}$ on $\\Gamma$ is defined as the outward normal to $\\Omega_1$, so on $\\Gamma$ we have $\\mathbf{n}_{1}=\\mathbf{n}$ and $\\mathbf{n}_{2}=-\\mathbf{n}$.\nThe boundary integrals can be split:\n$$\n\\int_{\\partial\\Omega_{1}} \\dots + \\int_{\\partial\\Omega_{2}} \\dots = \\int_{\\partial\\tilde{\\Omega}} \\kappa \\partial_{n}u v \\, dS + \\int_{\\Gamma} \\kappa_{1} \\partial_{n_{1}}u_{1} v_{1} \\, dS + \\int_{\\Gamma} \\kappa_{2} \\partial_{n_{2}}u_{2} v_{2} \\, dS\n$$\nUsing $\\partial_{n_1} = \\partial_n$ and $\\partial_{n_2} = -\\partial_n$ on $\\Gamma$, the interface integral part becomes:\n$$\n\\int_{\\Gamma} (\\kappa_{1} \\partial_{n} u_{1} v_{1} - \\kappa_{2} \\partial_{n} u_{2} v_{2}) \\, dS\n$$\nThe problem specifies a homogeneous Neumann boundary condition on the outer boundary $\\partial\\tilde{\\Omega}$, which means $\\kappa \\partial_{n}u = 0$ on $\\partial\\tilde{\\Omega}$. Thus, $\\int_{\\partial\\tilde{\\Omega}} \\kappa \\partial_{n}u v \\, dS = 0$.\nThe equation is now:\n$$\n\\int_{\\tilde{\\Omega}} \\kappa \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} - \\int_{\\Gamma} (\\kappa_{1} \\partial_{n} u_{1} v_{1} - \\kappa_{2} \\partial_{n} u_{2} v_{2}) \\, dS = \\int_{\\tilde{\\Omega}} f v \\, d\\mathbf{x}\n$$\nWe now choose the function space $V$ such that the interface conditions are handled. A natural choice for a conforming method is a space where functions are continuous across the interface, such as $V=H^{1}(\\tilde{\\Omega})$. For any function $w \\in H^{1}(\\tilde{\\Omega})$, the traces on both sides of $\\Gamma$ are equal, i.e., $w_1 = w_2$. Thus for our solution $u$ and test function $v$, we naturally enforce $[u]=0$ and have $[v]=0$. The interface integral simplifies to:\n$$\n- \\int_{\\Gamma} (\\kappa_{1} \\partial_{n} u_{1} - \\kappa_{2} \\partial_{n} u_{2}) v \\, dS = - \\int_{\\Gamma} [\\kappa \\partial_n u] v \\, dS\n$$\nUsing the second interface condition, $[\\kappa \\partial_{n} u] = 0$, this integral vanishes.\nWe are left with the final weak formulation: Find $u \\in V = H^{1}(\\tilde{\\Omega})$ such that\n$$\n\\int_{\\tilde{\\Omega}} \\kappa \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = \\int_{\\tilde{\\Omega}} f v \\, d\\mathbf{x} \\quad \\forall v \\in V\n$$\nThe function space is $V=H^{1}(\\tilde{\\Omega})$.\nThe bilinear form is $a(u,v) = \\int_{\\tilde{\\Omega}} \\kappa \\nabla u \\cdot \\nabla v \\, d\\mathbf{x}$.\nThe linear form is $l(v) = \\int_{\\tilde{\\Omega}} f v \\, d\\mathbf{x}$.\nFor the pure Neumann problem, a solution exists if $\\int_{\\tilde{\\Omega}} f \\, d\\mathbf{x} = 0$, and the solution is unique up to an additive constant. To ensure uniqueness, one can restrict the space $V$ to functions with zero mean, i.e., $V = \\{ v \\in H^1(\\tilde{\\Omega}) : \\int_{\\tilde{\\Omega}} v \\, d\\mathbf{x} = 0 \\}$.\n\n## Task B: CutFEM Nitsche-type Formulation\n\nIn a Cut Finite Element Method (CutFEM), the finite element mesh $\\mathcal{T}_{h}$ is not fitted to the interface $\\Gamma$. The trial and test functions $u_h, v_h$ are taken from a standard finite element space $V_h$ on $\\mathcal{T}_h$ (e.g., continuous piecewise affine functions), but they are treated as discontinuous across $\\Gamma$ in the formulation. The interface conditions are enforced weakly using Nitsche's method.\n\nA symmetric Nitsche-type bilinear form $a_h(u,v)$ that weakly enforces the conditions $[u]=0$ and $[\\kappa \\partial_n u]=0$ on $\\Gamma$ is constructed as follows:\n$$\na_{h}(u,v) = \\int_{\\Omega_{1} \\cup \\Omega_{2}} \\kappa \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} - \\int_{\\Gamma} \\{\\kappa \\partial_{n} u\\}_{\\omega} [v] \\, dS - \\int_{\\Gamma} \\{\\kappa \\partial_{n} v\\}_{\\omega} [u] \\, dS + \\int_{\\Gamma} \\frac{\\gamma \\kappa_{H}}{h} [u][v] \\, dS + g_{h}(u,v)\n$$\nThe components of this form are:\n1.  **Bulk term:** $\\int_{\\Omega_{1} \\cup \\Omega_{2}} \\kappa \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = \\int_{\\Omega_{1}} \\kappa_{1} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} + \\int_{\\Omega_{2}} \\kappa_{2} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x}$. This is the standard energy term, integrated over the parts of the elements cut by the interface.\n2.  **Consistency terms:** The two integrals involving the weighted average flux, $-\\int_{\\Gamma} \\{\\kappa \\partial_{n} u\\}_{\\omega} [v] \\, dS$ and $-\\int_{\\Gamma} \\{\\kappa \\partial_{n} v\\}_{\\omega} [u] \\, dS$. These terms enforce the interface conditions. By construction, this pairing makes the form symmetric.\n    *   The jump is defined as $[w] = w_1 - w_2$.\n    *   The weighted average flux is $\\{\\kappa \\partial_{n} w\\}_{\\omega} = \\omega_{1}\\kappa_{1}\\partial_{n} w_{1}+\\omega_{2}\\kappa_{2}\\partial_{n} w_{2}$, with weights $\\omega_1, \\omega_2$ satisfying $\\omega_1 + \\omega_2 = 1$.\n3.  **Penalty term:** $\\int_{\\Gamma} \\frac{\\gamma \\kappa_{H}}{h} [u][v] \\, dS$. This term penalizes the jump in the solution $[u]$ and is essential for the stability and coercivity of the method.\n    *   $\\gamma > 0$ is a user-defined, sufficiently large penalty parameter.\n    *   $h$ is the local mesh size at the interface. The penalty scaling is $h^{-1}$.\n    *   $\\kappa_{H} = \\dfrac{2\\kappa_{1}\\kappa_{2}}{\\kappa_{1}+\\kappa_{2}}$ is the harmonic mean of the diffusion coefficients.\n4.  **Ghost-penalty stabilization:** $g_{h}(u,v)$. This term is added to control instabilities arising from small element cuts. It acts on faces of elements cut by $\\Gamma$ and typically penalizes the jump of the gradient. For example, $g_h(u,v) = \\sum_{F \\in \\mathcal{F}_h^\\Gamma} \\int_F \\beta h^\\sigma [[\\nabla u \\cdot \\mathbf{n}_F]] [[\\nabla v \\cdot \\mathbf{n}_F]] dS$ for some constants $\\beta, \\sigma$, where $\\mathcal{F}_h^\\Gamma$ is the set of interior faces of elements cut by $\\Gamma$.\n\nA robust choice for the weights $\\omega_1, \\omega_2$, particularly for high-contrast coefficients, is the **harmonic weighting**:\n$$\n\\omega_{1} = \\frac{\\kappa_{2}}{\\kappa_{1}+\\kappa_{2}}, \\qquad \\omega_{2} = \\frac{\\kappa_{1}}{\\kappa_{1}+\\kappa_{2}}\n$$\nThis choice ensures that the method is stable independently of the ratio $\\kappa_1/\\kappa_2$.\n\n## Task C: Computation of $a_{h}(\\varphi,\\varphi)$\n\nWe are asked to compute $a_{h}(\\varphi,\\varphi)$ where the trial and test function is $\\varphi(x,y) = x$. We analyze each term of the bilinear form $a_{h}$ from Task B using $u=v=\\varphi$.\n\nFirst, we compute quantities related to $\\varphi(x,y)=x$:\n*   The gradient is a constant vector: $\\nabla \\varphi = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$.\n*   The interface $\\Gamma$ is the line $x=\\alpha$, for $y \\in (0,1)$. The outward unit normal of $\\Omega_1$ on $\\Gamma$ is $\\mathbf{n} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$.\n*   The trace of $\\varphi$ on the $\\Omega_1$-side of $\\Gamma$ is $\\varphi_1 = \\varphi(\\alpha,y) = \\alpha$.\n*   The trace of $\\varphi$ on the $\\Omega_2$-side of $\\Gamma$ is $\\varphi_2 = \\varphi(\\alpha,y) = \\alpha$.\n*   The jump of $\\varphi$ across $\\Gamma$ is $[\\varphi] = \\varphi_1 - \\varphi_2 = \\alpha - \\alpha = 0$.\n*   The normal derivative on $\\Gamma$ is $\\partial_n \\varphi = \\nabla \\varphi \\cdot \\mathbf{n} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\cdot \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = 1$. This value is the same for the trace from either side: $\\partial_n \\varphi_1 = 1$ and $\\partial_n \\varphi_2 = 1$.\n\nNow we evaluate the five terms in $a_{h}(\\varphi,\\varphi)$:\n1.  **Bulk term:**\n    $$\n    \\int_{\\Omega_{1} \\cup \\Omega_{2}} \\kappa \\nabla \\varphi \\cdot \\nabla \\varphi \\, d\\mathbf{x} = \\int_{\\Omega_{1}} \\kappa_{1} |\\nabla \\varphi|^2 \\, d\\mathbf{x} + \\int_{\\Omega_{2}} \\kappa_{2} |\\nabla \\varphi|^2 \\, d\\mathbf{x}\n    $$\n    Since $|\\nabla \\varphi|^2 = 1^2 + 0^2 = 1$, the integral becomes:\n    $$\n    \\kappa_{1} \\int_{\\Omega_{1}} 1 \\, d\\mathbf{x} + \\kappa_{2} \\int_{\\Omega_{2}} 1 \\, d\\mathbf{x} = \\kappa_{1} \\cdot \\text{Area}(\\Omega_{1}) + \\kappa_{2} \\cdot \\text{Area}(\\Omega_{2})\n    $$\n    The domain $\\Omega_1 = (0,\\alpha) \\times (0,1)$ has area $\\alpha$. The domain $\\Omega_2 = (\\alpha, 1) \\times (0,1)$ has area $1-\\alpha$. So the bulk term evaluates to:\n    $$\n    \\kappa_{1}\\alpha + \\kappa_{2}(1-\\alpha)\n    $$\n2.  **Consistency terms:** The form contains two such terms $- \\int_{\\Gamma} \\{\\kappa \\partial_{n} \\varphi\\}_{\\omega} [\\varphi] \\, dS$. Since we calculated that the jump $[\\varphi] = 0$, both of these terms are zero:\n    $$\n    - \\int_{\\Gamma} \\{\\kappa \\partial_{n} \\varphi\\}_{\\omega} [\\varphi] \\, dS = - \\int_{\\Gamma} \\{\\kappa \\partial_{n} \\varphi\\}_{\\omega} \\cdot 0 \\, dS = 0\n    $$\n3.  **Penalty term:** The penalty term is $\\int_{\\Gamma} \\frac{\\gamma \\kappa_{H}}{h} [\\varphi][\\varphi] \\, dS = \\int_{\\Gamma} \\frac{\\gamma \\kappa_{H}}{h} [\\varphi]^2 \\, dS$. Again, since $[\\varphi]=0$, this term is zero:\n    $$\n    \\int_{\\Gamma} \\frac{\\gamma \\kappa_{H}}{h} (0)^2 \\, dS = 0\n    $$\n4.  **Ghost-penalty stabilization:** The term $g_h(\\varphi,\\varphi)$ penalizes jumps of normal derivatives of $\\varphi$ across interior element faces. Since $\\varphi(x,y)=x$ is a globally linear function, its gradient $\\nabla\\varphi = (1,0)$ is constant everywhere. Therefore, the jump of its gradient (and thus its normal derivative) across any face is zero. This means $g_{h}(\\varphi,\\varphi) = 0$.\n\nCombining all terms, the total value of the bilinear form is the value of the bulk term alone:\n$$\na_{h}(\\varphi,\\varphi) = (\\kappa_{1}\\alpha + \\kappa_{2}(1-\\alpha)) + 0 + 0 + 0 + 0 = \\kappa_{1}\\alpha + \\kappa_{2}(1-\\alpha)\n$$\nThis result demonstrates that the Nitsche-based CutFEM formulation is exact for linear functions, as all the method-specific interface and stabilization terms vanish, recovering the value from the original continuous bilinear form.",
            "answer": "$$\\boxed{\\kappa_{1} \\alpha + \\kappa_{2} (1 - \\alpha)}$$"
        }
    ]
}