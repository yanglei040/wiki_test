{
    "hands_on_practices": [
        {
            "introduction": "The core challenge of fictitious domain methods is to accurately represent boundary or interface conditions on a grid that does not conform to the geometry. This hands-on exercise provides a concrete, one-dimensional test case to explore this fundamental issue . By implementing and comparing a naive discretization with a physically-motivated stabilized scheme, you will directly observe the critical importance of correctly modeling sub-grid physics, particularly in scenarios involving high-contrast material properties.",
            "id": "3392223",
            "problem": "Consider the scalar elliptic interface problem in one spatial dimension posed on the interval $[-1,1]$: find $u:[-1,1]\\to\\mathbb{R}$ such that\n$$\n-\\frac{d}{dx}\\left(\\kappa(x)\\,\\frac{du}{dx}\\right)=0 \\quad \\text{for } x\\in(-1,1),\n$$\nwith Dirichlet boundary conditions $u(-1)=-1$ and $u(1)=1$, where the conductivity $\\kappa(x)$ is piecewise constant with a single jump located at a prescribed interface point $\\xi\\in(-1,1)$, namely\n$$\n\\kappa(x)=\n\\begin{cases}\n\\kappa_1, & x<\\xi,\\\\\n\\kappa_2, & x\\ge \\xi,\n\\end{cases}\n$$\nfor given positive constants $\\kappa_1$ and $\\kappa_2$. The interface conditions are the continuity of $u$ at $x=\\xi$ and the continuity of the normal flux,\n$$\nu(\\xi^-)=u(\\xi^+),\\qquad \\kappa_1\\,\\frac{du}{dx}(\\xi^-)=\\kappa_2\\,\\frac{du}{dx}(\\xi^+).\n$$\nThis formulation is a canonical model for the analysis of fictitious domain techniques in the numerical solution of partial differential equations, where the interface cut position $\\xi$ is generally independent of the discretization grid.\n\nStarting from the weak formulation and standard conservation principles, your goal is to design and implement two numerical schemes on a uniform grid for this interface problem:\n\n- an unstabilized scheme that uses a naive face conductivity model insensitive to the cut position $\\xi$;\n- a stabilized scheme that incorporates a consistent flux model across the cut face, using the series-limiting behavior of conductances along the face interval split by the interface.\n\nThe stabilized scheme must be robust under high contrast $\\kappa_1\\ll \\kappa_2$ and should capture the correct flux continuity at the interface irrespective of the cut position $\\xi$. The unstabilized scheme should intentionally lack this robustness by modeling the face conductivity using a simple position-insensitive averaging rule. Both schemes must assemble a tridiagonal Symmetric Positive Definite (SPD) linear system on the interior nodes and enforce the Dirichlet boundary conditions strongly.\n\nTo make the study quantitatively testable, proceed as follows.\n\n1. Derive the exact solution $u_{\\text{ex}}(x)$ for general $\\xi\\in(-1,1)$ and positive $\\kappa_1,\\kappa_2$ under the stated boundary and interface conditions. The exact solution is piecewise linear, with different slopes on $(-1,\\xi)$ and $(\\xi,1)$ constrained by flux continuity.\n\n2. Implement both numerical schemes on a uniform grid of $N$ nodes on $[-1,1]$ (including endpoints), with spacing $h=2/(N-1)$. The fictitious domain aspect arises from the fact that the interface $\\xi$ can be located anywhere in $(-1,1)$ independently of the grid; if the interface lies strictly inside an interval $[x_{i-1},x_i]$, the stabilized scheme must reflect the correct conservation across this cut interval.\n\n3. For each scheme, compute the discrete solution $u_h$ and evaluate the error in the $H^1$ seminorm using a cellwise integral of the gradient error. Specifically, for each cell $[x_{i-1},x_i]$ with length $h$, define the cell gradient of the discrete solution by\n$$\ng_h^{(i)}=\\frac{u_h(x_i)-u_h(x_{i-1})}{h}.\n$$\nThe exact gradient is piecewise constant, equal to the left slope on $[x_{i-1},x_i]\\subset(-1,\\xi)$ and the right slope on $[x_{i-1},x_i]\\subset(\\xi,1)$; if the interface lies strictly inside the cell, split the integral into the left and right subintervals. Approximate the $H^1$ seminorm of the error by\n$$\n\\|u_h-u_{\\text{ex}}\\|_{H^1( -1,1)} \\approx \\left(\\sum_{i=1}^{N-1}\\int_{x_{i-1}}^{x_i}\\big(g_h^{(i)}-u_{\\text{ex}}'(x)\\big)^2\\,dx\\right)^{1/2}.\n$$\n\n4. Define the $H^1$ error constant for each scheme by normalizing the error with the theoretically expected convergence rate for this interface-limited problem. Since the dominant contribution is localized near the single cut cell and the exact solution has a slope discontinuity, assume the expected rate in the $H^1$ seminorm is proportional to $h^{1/2}$ and compute\n$$\nC_{H^1} = \\frac{\\|u_h-u_{\\text{ex}}\\|_{H^1(-1,1)}}{\\sqrt{h}}.\n$$\nReport $C_{H^1}$ for the unstabilized and stabilized schemes separately. Analyze how $C_{H^1}$ depends on the contrast parameters $\\kappa_1$ and $\\kappa_2$.\n\nYour program must implement the above and produce quantitative results for the following test suite of parameter values $(\\kappa_1,\\kappa_2,\\xi,N)$:\n\n- Test 1 (baseline equal conductivities): $(\\kappa_1,\\kappa_2,\\xi,N)=(1,1,0.3,501)$.\n- Test 2 (moderate high contrast): $(\\kappa_1,\\kappa_2,\\xi,N)=(10^{-3},1,0.3,501)$.\n- Test 3 (extreme high contrast): $(\\kappa_1,\\kappa_2,\\xi,N)=(10^{-6},1,0.3,501)$.\n- Test 4 (aligned interface edge case): $(\\kappa_1,\\kappa_2,\\xi,N)=(10^{-6},1,0.0,501)$.\n\nFor each test case, your program must compute and output a list of two floats $[C_{H^1}^{\\text{unstab}}, C_{H^1}^{\\text{stab}}]$, where $C_{H^1}^{\\text{unstab}}$ is the error constant for the unstabilized scheme and $C_{H^1}^{\\text{stab}}$ is the error constant for the stabilized scheme. The final output must aggregate all test case results into a single line of text containing the list of lists in the following exact format:\n\n\"Your program should produce a single line of output containing the results as a comma-separated list of per-test-case two-float lists enclosed in square brackets (e.g., [[c11,c12],[c21,c22],[c31,c32],[c41,c42]]).\"\n\nNo physical units or angle units are involved in this problem. The floats in the output should be represented numerically (decimal or scientific notation is acceptable). The problem focuses on the derivation, robustness analysis, and contrast dependence in the context of fictitious domain techniques.",
            "solution": "The user-provided problem is a valid, well-posed, and scientifically grounded exercise in numerical analysis for partial differential equations. All necessary data and conditions are provided to derive an analytical solution, implement two distinct numerical schemes, and quantitatively evaluate their performance. The problem is objective and directly addresses the core concepts of fictitious domain techniques, specifically the treatment of interfaces that do not align with the computational grid.\n\n### 1. Analytical Solution\nThe problem is governed by the one-dimensional steady-state diffusion equation:\n$$\n-\\frac{d}{dx}\\left(\\kappa(x)\\,\\frac{du}{dx}\\right)=0 \\quad \\text{for } x\\in(-1,1)\n$$\nIntegrating once with respect to $x$ shows that the flux, $J(x) = -\\kappa(x) \\frac{du}{dx}$, must be a constant, say $J_0$. Thus, $\\frac{du}{dx} = -J_0/\\kappa(x)$. Integrating a second time gives a piecewise linear solution. Let's define $C = -J_0$.\n$$\nu'(x) = \\frac{C}{\\kappa(x)} =\n\\begin{cases}\nC/\\kappa_1, & x<\\xi \\\\\nC/\\kappa_2, & x\\ge\\xi\n\\end{cases}\n$$\nIntegrating and applying the boundary conditions $u(-1)=-1$ and $u(1)=1$, and enforcing continuity of the solution $u(x)$ at the interface $x=\\xi$, we obtain the solution:\n$$\nu_{\\text{ex}}(x) =\n\\begin{cases}\n\\frac{C}{\\kappa_1}(x+1) - 1, & x \\in [-1, \\xi) \\\\\n\\frac{C}{\\kappa_2}(x-1) + 1, & x \\in [\\xi, 1]\n\\end{cases}\n$$\nThe constant $C$ is determined by the continuity condition $u(\\xi^-)=u(\\xi^+)$:\n$$\n\\frac{C}{\\kappa_1}(\\xi+1) - 1 = \\frac{C}{\\kappa_2}(\\xi-1) + 1\n$$\nSolving for $C$ yields:\n$$\nC = \\frac{2 \\kappa_1 \\kappa_2}{\\kappa_2(\\xi+1) - \\kappa_1(\\xi-1)}\n$$\nThis analytical solution provides the exact gradient $u_{\\text{ex}}'(x)$ needed for the error computation, which is piecewise constant: $u_{\\text{ex}}'(x) = C/\\kappa_1$ for $x < \\xi$ and $u_{\\text{ex}}'(x) = C/\\kappa_2$ for $x \\ge \\xi$.\n\n### 2. Numerical Discretization\nWe employ a finite volume method on a uniform grid $x_i = -1 + ih$ for $i=0, \\dots, N-1$, with mesh spacing $h=2/(N-1)$. Integrating the PDE over a control volume $[x_{i-1/2}, x_{i+1/2}]$ centered at each interior node $x_i$ leads to the conservation law:\n$$\n\\left(-\\kappa\\frac{du}{dx}\\right)_{x_{i+1/2}} - \\left(-\\kappa\\frac{du}{dx}\\right)_{x_{i-1/2}} = 0\n$$\nThis states that the flux entering the control volume equals the flux leaving it. We approximate the flux at the cell face $x_{i-1/2}$ (midpoint between $x_{i-1}$ and $x_i$) as:\n$$\nJ_{i-1/2} = -\\kappa_{i-1/2} \\frac{u_i - u_{i-1}}{h}\n$$\nwhere $u_i \\approx u(x_i)$ and $\\kappa_{i-1/2}$ is an effective conductivity for the interval $[x_{i-1}, x_i]$. The discrete equation for each interior node $i=1, \\dots, N-2$ is:\n$$\n-\\kappa_{i+1/2}\\frac{u_{i+1}-u_i}{h} + \\kappa_{i-1/2}\\frac{u_i-u_{i-1}}{h} = 0\n$$\nRearranging, we get the stencil for a tridiagonal system:\n$$\n-\\kappa_{i-1/2} u_{i-1} + (\\kappa_{i-1/2} + \\kappa_{i+1/2}) u_i - \\kappa_{i+1/2} u_{i+1} = 0\n$$\nThe distinction between the two required schemes lies in the definition of the face conductivity $\\kappa_{i-1/2}$.\n\n### 3. Unstabilized Scheme\nThis scheme uses a naive, position-insensitive averaging rule. A standard choice is the arithmetic mean of the conductivity values at the adjacent nodes:\n$$\n\\kappa_{i-1/2}^{\\text{unstab}} = \\frac{\\kappa(x_{i-1}) + \\kappa(x_i)}{2}\n$$\nwhere $\\kappa(x_j) = \\kappa_1$ if $x_j < \\xi$ and $\\kappa_2$ if $x_j \\ge \\xi$. This model is easy to implement but fails to correctly represent the physics of flow through a layered medium, especially under high contrast, as it is only sensitive to which nodes fall on either side of the interface, not its precise location within a cell.\n\n### 4. Stabilized Scheme\nThis scheme uses a physically consistent model for effective conductivity, reflecting the series-limiting behavior of resistances. The thermal/electrical resistance of a 1D segment of length $L$ and conductivity $\\kappa$ is $R=L/\\kappa$. For two segments in series, resistances add. The effective conductivity $\\kappa_{i-1/2}$ for the interval $[x_{i-1}, x_i]$ of length $h$ is derived from its total resistance:\n$$\nR_{\\text{cell}} = \\int_{x_{i-1}}^{x_i} \\frac{dx'}{\\kappa(x')} = \\frac{h}{\\kappa_{i-1/2}}\n$$\nThis gives the harmonic average of conductivities.\nIf the interface $\\xi$ is not in $(x_{i-1}, x_i)$, $\\kappa(x)$ is constant, and $\\kappa_{i-1/2}^{\\text{stab}}$ is either $\\kappa_1$ or $\\kappa_2$.\nIf the interface lies in the cell, $x_{i-1} < \\xi < x_i$, the integral is split:\n$$\n\\int_{x_{i-1}}^{x_i} \\frac{dx'}{\\kappa(x')} = \\int_{x_{i-1}}^{\\xi} \\frac{dx'}{\\kappa_1} + \\int_{\\xi}^{x_i} \\frac{dx'}{\\kappa_2} = \\frac{\\xi-x_{i-1}}{\\kappa_1} + \\frac{x_i-\\xi}{\\kappa_2}\n$$\nThe stabilized face conductivity is thus:\n$$\n\\kappa_{i-1/2}^{\\text{stab}} = \\frac{h}{\\frac{\\xi-x_{i-1}}{\\kappa_1} + \\frac{x_i-\\xi}{\\kappa_2}}\n$$\nThis formulation is robust as it correctly captures the flux-limiting behavior of the low-conductivity material, regardless of the sub-grid location of $\\xi$ or the contrast ratio $\\kappa_2/\\kappa_1$.\n\n### 5. Linear System and Boundary Conditions\nFor both schemes, a linear system $A\\mathbf{u}=\\mathbf{b}$ is assembled for the vector of unknown interior nodal values $\\mathbf{u} = [u_1, \\dots, u_{N-2}]^T$. The matrix $A$ is an $(N-2)\\times(N-2)$ symmetric positive-definite (SPD) tridiagonal matrix. The Dirichlet boundary conditions $u_0 = u(-1) = -1$ and $u_{N-1} = u(1) = 1$ are incorporated by moving their contributions to the right-hand side vector $\\mathbf{b}$.\nFor the first equation ($i=1$):\n$$\n(\\kappa_{1/2} + \\kappa_{3/2})u_1 - \\kappa_{3/2}u_2 = -\\kappa_{1/2}u_0 = \\kappa_{1/2}\n$$\nFor the last equation ($i=N-2$):\n$$\n-\\kappa_{N-5/2}u_{N-3} + (\\kappa_{N-5/2} + \\kappa_{N-3/2})u_{N-2} = \\kappa_{N-3/2}u_{N-1} = \\kappa_{N-3/2}\n$$\nThe resulting SPD system is efficiently solved using a standard banded matrix solver.\n\n### 6. Error Norm Calculation\nThe error is evaluated in the $H^1$ seminorm, approximated by a sum over grid cells:\n$$\n\\|u_h-u_{\\text{ex}}\\|_{H^1(-1,1)}^2 \\approx \\sum_{i=1}^{N-1}\\int_{x_{i-1}}^{x_i}\\big(g_h^{(i)}-u_{\\text{ex}}'(x)\\big)^2\\,dx\n$$\nwhere $g_h^{(i)} = (u_h(x_i) - u_h(x_{i-1})) / h$ is the piecewise constant gradient of the numerical solution. The integral for each cell $[x_{i-1}, x_i]$ is computed by considering two cases:\n1.  **Non-cut cell**: If $\\xi \\notin (x_{i-1}, x_i)$, $u_{\\text{ex}}'(x)$ is constant in the cell, and the integral is $(g_h^{(i)} - u_{\\text{ex}}')^2 h$.\n2.  **Cut cell**: If $x_{i-1} < \\xi < x_i$, the integral is split at $\\xi$:\n    $$\n    (g_h^{(i)} - C/\\kappa_1)^2(\\xi-x_{i-1}) + (g_h^{(i)} - C/\\kappa_2)^2(x_i-\\xi)\n    $$\nFinally, the error constant $C_{H^1}$ is calculated by normalizing the error with the expected convergence rate of $h^{1/2}$:\n$$\nC_{H^1} = \\frac{\\|u_h-u_{\\text{ex}}\\|_{H^1(-1,1)}}{\\sqrt{h}}\n$$\nThis constant provides a measure of the method's accuracy that is independent of the grid size $N$, allowing for a fair comparison of the schemes' robustness to parameter changes, particularly the conductivity contrast.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (k1, k2, xi, N)\n        (1.0, 1.0, 0.3, 501),\n        (1e-3, 1.0, 0.3, 501),\n        (1e-6, 1.0, 0.3, 501),\n        (1e-6, 1.0, 0.0, 501),\n    ]\n\n    all_results = []\n\n    for k1, k2, xi, N in test_cases:\n        h = 2.0 / (N - 1)\n        x = np.linspace(-1.0, 1.0, N)\n        \n        # Boundary conditions\n        u_left_bc = -1.0\n        u_right_bc = 1.0\n        \n        # Exact solution constant\n        denominator = k2 * (xi + 1.0) - k1 * (xi - 1.0)\n        # Avoid division by zero if conductivities are zero, though problem states positive.\n        if abs(denominator) < 1e-15:\n            C_exact = 0.0 # Should not happen with positive k1,k2\n        else:\n            C_exact = (2.0 * k1 * k2) / denominator\n\n        u_prime_left = C_exact / k1 if k1 > 0 else 0\n        u_prime_right = C_exact / k2 if k2 > 0 else 0\n\n        case_results = []\n        for scheme in ['unstabilized', 'stabilized']:\n            # 1. Assemble face conductivities\n            num_faces = N - 1\n            k_face = np.zeros(num_faces)\n            \n            if scheme == 'unstabilized':\n                kappa_node = np.where(x < xi, k1, k2)\n                # Handle the case where xi is exactly on a node\n                # The rule is k(x)=k2 for x >= xi\n                for i in range(N):\n                    if x[i] >= xi:\n                        kappa_node[i] = k2\n                \n                for i in range(num_faces):\n                    k_face[i] = (kappa_node[i] + kappa_node[i+1]) / 2.0\n            \n            else: # stabilized\n                for i in range(num_faces):\n                    x_l, x_r = x[i], x[i+1]\n                    if xi <= x_l + 1e-15: # Cell is in a region of k2\n                        k_face[i] = k2\n                    elif xi >= x_r - 1e-15: # Cell is in a region of k1\n                        k_face[i] = k1\n                    else: # Cell is cut by the interface\n                        resist_1 = (xi - x_l) / k1\n                        resist_2 = (x_r - xi) / k2\n                        k_face[i] = h / (resist_1 + resist_2)\n            \n            # 2. Assemble the linear system A*u = b for interior nodes\n            num_interior_nodes = N - 2\n            # Scipy's banded solver format: (l+u+1, M)\n            # Here: l=1, u=1, M = N-2. Matrix is (3, N-2)\n            # ab[0,:] = super-diagonal, ab[1,:] = main-diagonal, ab[2,:] = sub-diagonal\n            ab = np.zeros((3, num_interior_nodes))\n            b = np.zeros(num_interior_nodes)\n\n            # Main diagonal\n            ab[1, :] = k_face[:-1] + k_face[1:]\n            # Off-diagonals\n            ab[0, 1:] = -k_face[1:-1]\n            ab[2, :-1] = -k_face[1:-1]\n            \n            # Incorporate boundary conditions into RHS vector b\n            b[0] = k_face[0] * u_left_bc\n            b[-1] = k_face[-1] * u_right_bc\n\n            # 3. Solve the system\n            u_interior = solve_banded((1, 1), ab, b)\n            u_h = np.concatenate(([u_left_bc], u_interior, [u_right_bc]))\n\n            # 4. Compute H^1 seminorm error\n            error_sq_sum = 0.0\n            for i in range(1, N):\n                x_l, x_r = x[i-1], x[i]\n                g_h_i = (u_h[i] - u_h[i-1]) / h\n                \n                cell_error_sq = 0.0\n                if xi <= x_l + 1e-15: # Cell is entirely in right part\n                    cell_error_sq = (g_h_i - u_prime_right)**2 * h\n                elif xi >= x_r - 1e-15: # Cell is entirely in left part\n                    cell_error_sq = (g_h_i - u_prime_left)**2 * h\n                else: # Cell is cut by interface\n                    err_left_part = (g_h_i - u_prime_left)**2 * (xi - x_l)\n                    err_right_part = (g_h_i - u_prime_right)**2 * (x_r - xi)\n                    cell_error_sq = err_left_part + err_right_part\n                \n                error_sq_sum += cell_error_sq\n\n            h1_seminorm_error = np.sqrt(error_sq_sum)\n            C_H1 = h1_seminorm_error / np.sqrt(h)\n            case_results.append(C_H1)\n            \n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'[{res[0]},{res[1]}]' for res in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the foundational concepts of interface handling, we now apply fictitious domain principles to a dynamic fluid-structure interaction problem using the popular Immersed Boundary Method (IBM) . This practice focuses on a critical numerical artifact known as \"leakage,\" where the discretized fluid appears to pass through a supposedly impermeable boundary. By simulating a pressurized membrane in a 2D fluid and quantifying this leakage, you will gain practical insight into how the choice of coupling kernels and discretization parameters affects the mass conservation properties and overall fidelity of the simulation.",
            "id": "3510140",
            "problem": "Consider a two-dimensional, periodic square domain described by the interval $[0,1]\\times[0,1]$ discretized on a uniform Cartesian grid with $N$ points per direction and grid spacing $h=1/N$. A closed elastic boundary is represented by a circular membrane of radius $R$ centered at $(0.5,0.5)$, discretized by $N_{\\mathrm{L}}$ equally spaced Lagrangian points with angular parametrization $\\theta_i = 2\\pi i/N_{\\mathrm{L}}$ (angles specified in radians). Assume a uniform pressure jump $\\Delta p$ across the membrane, causing a normal traction per unit length equal to $\\Delta p\\,\\mathbf{n}$ on the membrane, where $\\mathbf{n}$ is the outward unit normal.\n\nIn the Immersed Boundary Method (IBM), Lagrangian-to-Eulerian coupling uses a regularized Dirac delta to spread the membrane traction from Lagrangian points $(X_i)$ to the Eulerian grid, and to interpolate the Eulerian velocity back to the Lagrangian points. Specifically, define the regularized delta as\n$$\n\\delta_h(\\mathbf{x})=\\frac{1}{h^2}\\,\\phi\\left(\\frac{x}{h}\\right)\\,\\phi\\left(\\frac{y}{h}\\right),\n$$\nwith a compactly supported one-dimensional kernel $\\phi(\\cdot)$ chosen from a set of candidates. The Eulerian force density is then\n$$\n\\mathbf{F}(\\mathbf{x})=\\sum_{i=0}^{N_{\\mathrm{L}}-1} \\Delta p\\,\\mathbf{n}_i\\,\\delta_h(\\mathbf{x}-\\mathbf{X}_i)\\,ds,\n$$\nwhere $ds = 2\\pi R/N_{\\mathrm{L}}$ is the segment length. The Eulerian velocity $\\mathbf{u}$ is governed by the steady Stokes equations in the absence of inertial effects,\n$$\n-\\nabla p + \\mu \\Delta \\mathbf{u} + \\mathbf{F} = \\mathbf{0},\\qquad \\nabla\\cdot\\mathbf{u} = 0,\n$$\nwith dynamic viscosity $\\mu$ and periodic boundary conditions. The unique solenoidal solution for $\\mathbf{u}$ on this periodic domain can be expressed spectrally using the Fast Fourier Transform (FFT), projecting the forcing onto the divergence-free subspace and dividing by the Laplacian eigenvalue, for all nonzero wavenumbers.\n\nThe Lagrangian velocity $\\mathbf{U}_i$ is obtained by interpolation,\n$$\n\\mathbf{U}_i = \\sum_{\\text{grid }\\mathbf{x}} \\mathbf{u}(\\mathbf{x}) \\,\\delta_h(\\mathbf{X}_i - \\mathbf{x})\\,h^2,\n$$\nand the area flux across the membrane (which, in two dimensions, corresponds to the volumetric rate of change per unit depth) is computed by the line integral of the normal velocity,\n$$\n\\frac{dA}{dt} = \\oint_{\\Gamma} \\mathbf{u}\\cdot\\mathbf{n}\\,ds \\approx \\sum_{i=0}^{N_{\\mathrm{L}}-1} \\mathbf{U}_i\\cdot\\mathbf{n}_i\\,ds.\n$$\nIn the continuum, for an incompressible flow ($\\nabla\\cdot\\mathbf{u}=0$) enclosing a material volume, the area change rate $dA/dt$ would be identically zero by the divergence theorem. However, in the discrete Immersed Boundary Method, $dA/dt$ may be nonzero due to the mismatch between spreading and interpolation induced by the choice of kernel $\\phi(\\cdot)$ and the Lagrangian spacing relative to the Eulerian grid. This spurious nonzero $dA/dt$ is known as leakage.\n\nYour task is to implement a program that:\n- Discretizes the membrane as described.\n- Spreads the uniform pressure traction using a selected regularized delta kernel.\n- Solves the steady Stokes equations on the periodic domain using spectral projection.\n- Interpolates velocities back to the membrane.\n- Computes the area change rate $dA/dt$ as described.\n\nYou must treat all quantities in dimensionless form. Angles must be in radians. For kernel $\\phi(\\cdot)$, you must support at least the following choices:\n- Peskin four-point kernel (Immersed Boundary Method kernel):\n$$\n\\phi(r)=\\begin{cases}\n\\frac{1}{8}\\left(3-2|r|+\\sqrt{1+4|r|-4r^2}\\right),  |r|1, \\\\\n\\frac{1}{8}\\left(5-2|r|-\\sqrt{-7+12|r|-4r^2}\\right),  1\\le |r|2, \\\\\n0,  \\text{otherwise,}\n\\end{cases}\n$$\n- Cardinal cubic B-spline:\n$$\n\\phi(r)=\\begin{cases}\n\\frac{1}{6}\\left(4-6|r|^2+3|r|^3\\right),  |r|1, \\\\\n\\frac{1}{6}\\left(2-|r|\\right)^3,  1\\le |r|2, \\\\\n0,  \\text{otherwise.}\n\\end{cases}\n$$\n\nFor all computations, set $N=64$, $h=1/N$, $R=0.25$, $\\mu=1$. Define the Lagrangian spacing ratio $s=ds/h$ and determine $N_{\\mathrm{L}}$ from $s$ via $N_{\\mathrm{L}} = \\left\\lfloor \\frac{2\\pi R}{s\\,h} \\right\\rfloor$, with the constraint $N_{\\mathrm{L}}\\ge 8$. Use the outward normal $\\mathbf{n}_i=[\\cos\\theta_i,\\sin\\theta_i]$. The wavenumbers for FFT-based differentiation must be $k_x=2\\pi\\,\\mathrm{freq}_x$ and $k_y=2\\pi\\,\\mathrm{freq}_y$, where $\\mathrm{freq}$ are the standard discrete Fourier frequencies for spacing $h$.\n\nDesign your code to compute $dA/dt$ for the following test suite of parameter sets, each specified by the pair $(\\text{kernel},s)$ and the pressure jump $\\Delta p$:\n- Case $1$: $(\\text{peskin4},\\,s=1.0)$ with $\\Delta p=1$.\n- Case $2$: $(\\text{peskin4},\\,s=0.5)$ with $\\Delta p=1$.\n- Case $3$: $(\\text{peskin4},\\,s=2.0)$ with $\\Delta p=1$.\n- Case $4$: $(\\text{bspline3},\\,s=1.0)$ with $\\Delta p=1$.\n- Case $5$: $(\\text{bspline3},\\,s=0.5)$ with $\\Delta p=1$.\n- Case $6$: $(\\text{bspline3},\\,s=2.0)$ with $\\Delta p=1$.\n- Case $7$ (edge case): $(\\text{peskin4},\\,s=1.0)$ with $\\Delta p=0$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases $1$ through $7$, where each result is the computed $dA/dt$ as a float. Because all quantities are dimensionless, do not attach any physical units to the outputs. The angle unit is radians; all outputs must be decimal floats. The output format must be exactly\n$$\n[\\text{result}_1,\\text{result}_2,\\ldots,\\text{result}_7],\n$$\nwith each $\\text{result}_i$ a float value.",
            "solution": "The problem is deemed valid as it is scientifically grounded in the principles of computational fluid dynamics, specifically the Immersed Boundary Method (IBM), and is a well-posed numerical problem with a complete and consistent set of givens. The task involves simulating fluid-structure interaction to quantify a known numerical artifact, \"leakage,\" which arises from the discretization and choice of coupling kernels.\n\nThe solution proceeds by implementing the described numerical method step-by-step for each test case.\n\n**1. Discretization of Domain and Boundary**\n\nThe physical setup consists of a two-dimensional periodic domain $\\Omega = [0,1] \\times [0,1]$ and a circular membrane $\\Gamma$ of radius $R=0.25$ centered at $(0.5, 0.5)$.\n\n- **Eulerian Grid**: The domain $\\Omega$ is discretized into a uniform Cartesian grid of $N \\times N$ points, with $N=64$. The grid spacing is $h = 1/N = 1/64$. The grid points are located at $\\mathbf{x}_{j,k} = (j h, k h)$ for $j,k \\in \\{0, 1, \\dots, N-1\\}$.\n\n- **Lagrangian Grid**: The membrane $\\Gamma$ is discretized into $N_{\\mathrm{L}}$ Lagrangian points. The number of points, $N_{\\mathrm{L}}$, is determined by the Lagrangian spacing ratio $s = ds/h$, where $ds$ is the arc length between adjacent Lagrangian points. The formula is $N_{\\mathrm{L}} = \\lfloor \\frac{2\\pi R}{s h} \\rfloor$. The arc length is then re-calculated as $ds = 2\\pi R/N_{\\mathrm{L}}$ to ensure the discretized loop is closed. The positions of the Lagrangian points are given by a parametrization in terms of angle $\\theta_i = 2\\pi i/N_{\\mathrm{L}}$ for $i \\in \\{0, 1, \\dots, N_{\\mathrm{L}}-1\\}$:\n$$\n\\mathbf{X}_i = (0.5 + R\\cos\\theta_i, 0.5 + R\\sin\\theta_i)\n$$\nThe outward unit normal vector at each point $\\mathbf{X}_i$ is $\\mathbf{n}_i = (\\cos\\theta_i, \\sin\\theta_i)$.\n\n**2. Kernels and Regularized Delta Function**\n\nThe interaction between the fluid (Eulerian) and the structure (Lagrangian) is mediated by a regularized Dirac delta function, $\\delta_h(\\mathbf{x})$, constructed from a one-dimensional kernel $\\phi(r)$. Two specified kernels, the Peskin 4-point kernel and the cubic B-spline, are implemented according to their piecewise definitions. Both kernels have a compact support of $4h$, meaning $\\phi(r)=0$ for $|r| \\ge 2$.\n\n**3. Spreading: From Lagrangian Force to Eulerian Force Density**\n\nA uniform pressure jump $\\Delta p$ across the membrane generates a normal force per unit length (traction) equal to $\\Delta p \\, \\mathbf{n}$. The discrete force at each Lagrangian point $\\mathbf{X}_i$ is $\\mathbf{f}_i = \\Delta p \\, \\mathbf{n}_i \\, ds$.\n\nThis Lagrangian force is \"spread\" onto the surrounding Eulerian grid points to obtain the Eulerian force density field, $\\mathbf{F}(\\mathbf{x})$. The formula for this spreading operation is:\n$$\n\\mathbf{F}(\\mathbf{x}) = \\sum_{i=0}^{N_{\\mathrm{L}}-1} \\mathbf{f}_i \\, \\delta_h(\\mathbf{x} - \\mathbf{X}_i) = \\frac{1}{h^2} \\sum_{i=0}^{N_{\\mathrm{L}}-1} (\\Delta p \\, \\mathbf{n}_i \\, ds) \\, \\phi\\left(\\frac{x-X_{i,x}}{h}\\right) \\phi\\left(\\frac{y-X_{i,y}}{h}\\right)\n$$\nNumerically, for each Lagrangian point $\\mathbf{X}_i$, we identify the nearby Eulerian grid points $\\mathbf{x}_{j,k}$ that fall within the kernel's support. The force contribution is then calculated and added to the corresponding elements of the Eulerian force arrays, `Fx` and `Fy`. Due to the periodic domain, distances are computed considering the wrap-around nature of the grid.\n\n**4. Solving the Steady Stokes Equations**\n\nThe fluid velocity $\\mathbf{u}$ and pressure $p$ are governed by the steady Stokes equations with periodic boundary conditions:\n$$\n-\\nabla p + \\mu \\Delta \\mathbf{u} + \\mathbf{F} = \\mathbf{0}, \\qquad \\nabla\\cdot\\mathbf{u} = 0\n$$\nGiven the periodicity, these equations are efficiently solved in Fourier space. Applying the Fast Fourier Transform (FFT) to the equations yields:\n$$\n-i\\mathbf{k}\\hat{p} - \\mu |\\mathbf{k}|^2 \\hat{\\mathbf{u}} + \\hat{\\mathbf{F}} = \\mathbf{0}, \\qquad i\\mathbf{k}\\cdot\\hat{\\mathbf{u}} = 0\n$$\nwhere $\\hat{\\cdot}$ denotes the Fourier transform, $\\mathbf{k}=(k_x, k_y)$ is the wavevector, and $|\\mathbf{k}|^2=k_x^2+k_y^2$. The wavenumbers are determined by $k = 2\\pi f$, where $f$ are the discrete frequencies from `scipy.fft.fftfreq`.\n\nThe incompressibility condition ($i\\mathbf{k}\\cdot\\hat{\\mathbf{u}} = 0$) implies that the velocity vector $\\hat{\\mathbf{u}}$ is orthogonal to the wavevector $\\mathbf{k}$. By projecting the momentum equation onto the divergence-free subspace, we can solve for $\\hat{\\mathbf{u}}$ directly:\n$$\n\\hat{\\mathbf{u}}(\\mathbf{k}) = \\frac{1}{\\mu |\\mathbf{k}|^2} \\left( \\hat{\\mathbf{F}} - \\frac{(\\mathbf{k} \\cdot \\hat{\\mathbf{F}})\\mathbf{k}}{|\\mathbf{k}|^2} \\right) \\quad \\text{for } \\mathbf{k} \\neq \\mathbf{0}\n$$\nFor the zero-wavenumber mode ($\\mathbf{k}=\\mathbf{0}$), $\\hat{\\mathbf{u}}(\\mathbf{0})$ is set to zero, corresponding to zero mean velocity. The resulting velocity field in Fourier space, $(\\hat{u}_x, \\hat{u}_y)$, is transformed back to real space using the inverse FFT to obtain the Eulerian velocity field $(u_x, u_y)$.\n\n**5. Interpolation: From Eulerian Velocity to Lagrangian Velocity**\n\nThe velocity of the membrane points, $\\mathbf{U}_i$, is obtained by interpolating the Eulerian velocity field $\\mathbf{u}(\\mathbf{x})$ at the Lagrangian locations $\\mathbf{X}_i$. This operation is the adjoint of the spreading operation:\n$$\n\\mathbf{U}_i = \\sum_{\\text{grid }\\mathbf{x}} \\mathbf{u}(\\mathbf{x}) \\, \\delta_h(\\mathbf{X}_i - \\mathbf{x}) \\, h^2 = \\sum_{\\text{grid }\\mathbf{x}} \\mathbf{u}(\\mathbf{x}) \\, \\phi\\left(\\frac{X_{i,x}-x}{h}\\right) \\phi\\left(\\frac{Y_{i,y}-y}{h}\\right)\n$$\nNumerically, for each Lagrangian point $\\mathbf{X}_i$, we again identify the nearby Eulerian grid points and compute a weighted sum of their velocities to find $\\mathbf{U}_i$.\n\n**6. Computation of Area Change Rate ($dA/dt$)**\n\nFinally, the rate of change of the area enclosed by the membrane, a measure of numerical leakage, is computed by approximating the line integral of the normal velocity along the boundary:\n$$\n\\frac{dA}{dt} = \\oint_{\\Gamma} \\mathbf{u}\\cdot\\mathbf{n}\\,ds \\approx \\sum_{i=0}^{N_{\\mathrm{L}}-1} \\mathbf{U}_i\\cdot\\mathbf{n}_i\\,ds\n$$\nThis value is computed for each test case specified in the problem. The case with $\\Delta p = 0$ serves as a null test, as it should yield zero force, zero velocity, and therefore zero leakage, confirming the linearity and correctness of the base implementation.",
            "answer": "```python\nimport numpy as np\nimport scipy.fft\n\ndef peskin4_kernel(r):\n    \"\"\"\n    Computes the Peskin 4-point regularized delta function kernel.\n    \"\"\"\n    r_abs = np.abs(r)\n    val = np.zeros_like(r_abs)\n    \n    # |r|  1\n    mask1 = r_abs  1\n    r1 = r_abs[mask1]\n    val[mask1] = (1/8) * (3 - 2*r1 + np.sqrt(1 + 4*r1 - 4*r1**2))\n    \n    # 1 = |r|  2\n    mask2 = (r_abs = 1)  (r_abs  2)\n    r2 = r_abs[mask2]\n    # Ensure argument of sqrt is non-negative due to float precision issues\n    sqrt_arg = -7 + 12*r2 - 4*r2**2\n    sqrt_arg[sqrt_arg  0] = 0.0\n    val[mask2] = (1/8) * (5 - 2*r2 - np.sqrt(sqrt_arg))\n\n    return val\n\ndef bspline3_kernel(r):\n    \"\"\"\n    Computes the cardinal cubic B-spline kernel.\n    \"\"\"\n    r_abs = np.abs(r)\n    val = np.zeros_like(r_abs)\n    \n    # |r|  1\n    mask1 = r_abs  1\n    r1 = r_abs[mask1]\n    val[mask1] = (1/6) * (4 - 6*r1**2 + 3*r1**3)\n\n    # 1 = |r|  2\n    mask2 = (r_abs = 1)  (r_abs  2)\n    r2 = r_abs[mask2]\n    val[mask2] = (1/6) * (2 - r2)**3\n    \n    return val\n\ndef compute_leakage(kernel_name, s, dp):\n    \"\"\"\n    Computes the area change rate (dA/dt) for the given parameters.\n    \"\"\"\n    # System parameters\n    N = 64\n    R = 0.25\n    mu = 1.0\n    h = 1.0 / N\n\n    # Select the kernel function\n    kernels = {'peskin4': peskin4_kernel, 'bspline3': bspline3_kernel}\n    kernel_func = kernels[kernel_name]\n\n    # Lagrangian boundary discretization\n    N_L = int(np.floor(2 * np.pi * R / (s * h)))\n    ds = 2 * np.pi * R / N_L\n    theta = 2 * np.pi * np.arange(N_L) / N_L\n    \n    X_lag = 0.5 + R * np.cos(theta)\n    Y_lag = 0.5 + R * np.sin(theta)\n    nx = np.cos(theta)\n    ny = np.sin(theta)\n\n    # Sanity check: if pressure jump is zero, leakage must be zero\n    if dp == 0:\n        return 0.0\n\n    # --- Step 1: Spreading (Lagrangian force to Eulerian grid) ---\n    Fx = np.zeros((N, N))\n    Fy = np.zeros((N, N))\n    \n    for i in range(N_L):\n        lag_force_x = dp * nx[i] * ds\n        lag_force_y = dp * ny[i] * ds\n        \n        sx = X_lag[i] / h\n        sy = Y_lag[i] / h\n        \n        j_base = int(np.floor(sx))\n        k_base = int(np.floor(sy))\n\n        for dj in range(-1, 3):\n            for dk in range(-1, 3):\n                j = j_base + dj\n                k = k_base + dk\n                \n                rx = sx - j\n                ry = sy - k\n                \n                j_idx, k_idx = j % N, k % N\n                \n                weight = kernel_func(rx) * kernel_func(ry) / h**2\n                \n                Fx[k_idx, j_idx] += lag_force_x * weight\n                Fy[k_idx, j_idx] += lag_force_y * weight\n\n    # --- Step 2: Solve steady Stokes equations in Fourier space ---\n    Fx_hat = scipy.fft.fft2(Fx)\n    Fy_hat = scipy.fft.fft2(Fy)\n\n    freq = scipy.fft.fftfreq(N, h)\n    kx = 2 * np.pi * freq\n    Ky, Kx = np.meshgrid(kx, kx, indexing='ij')\n\n    Ksq = Kx**2 + Ky**2\n    \n    inv_Ksq = np.zeros_like(Ksq)\n    nonzero_mask = Ksq != 0\n    inv_Ksq[nonzero_mask] = 1.0 / Ksq[nonzero_mask]\n    \n    k_dot_Fhat = Kx * Fx_hat + Ky * Fy_hat\n    \n    Fx_hat_solenoidal = Fx_hat - Kx * k_dot_Fhat * inv_Ksq\n    Fy_hat_solenoidal = Fy_hat - Ky * k_dot_Fhat * inv_Ksq\n    \n    ux_hat = Fx_hat_solenoidal * inv_Ksq / mu\n    uy_hat = Fy_hat_solenoidal * inv_Ksq / mu\n\n    ux = np.real(scipy.fft.ifft2(ux_hat))\n    uy = np.real(scipy.fft.ifft2(uy_hat))\n\n    # --- Step 3: Interpolation (Eulerian velocity to Lagrangian points) ---\n    Ux = np.zeros(N_L)\n    Uy = np.zeros(N_L)\n\n    for i in range(N_L):\n        sx = X_lag[i] / h\n        sy = Y_lag[i] / h\n        \n        j_base = int(np.floor(sx))\n        k_base = int(np.floor(sy))\n\n        for dj in range(-1, 3):\n            for dk in range(-1, 3):\n                j = j_base + dj\n                k = k_base + dk\n                \n                rx = sx - j\n                ry = sy - k\n                \n                j_idx, k_idx = j % N, k % N\n                \n                weight = kernel_func(rx) * kernel_func(ry)\n                \n                Ux[i] += ux[k_idx, j_idx] * weight\n                Uy[i] += uy[k_idx, j_idx] * weight\n                \n    # --- Step 4: Calculate Area Change Rate (Leakage) ---\n    dAdt = np.sum((Ux * nx + Uy * ny)) * ds\n    \n    return dAdt\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (kernel_name, spacing_ratio_s, pressure_jump_dp)\n        ('peskin4', 1.0, 1.0),\n        ('peskin4', 0.5, 1.0),\n        ('peskin4', 2.0, 1.0),\n        ('bspline3', 1.0, 1.0),\n        ('bspline3', 0.5, 1.0),\n        ('bspline3', 2.0, 1.0),\n        ('peskin4', 1.0, 0.0), # Edge case\n    ]\n\n    results = []\n    for kernel_name, s, dp in test_cases:\n        result = compute_leakage(kernel_name, s, dp)\n        results.append(result)\n\n    # Format output as a comma-separated list of floats in brackets\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Developing reliable numerical solvers requires rigorous verification of their fundamental components. This final practice guides you through a standard verification technique—the Method of Manufactured Solutions—to test the accuracy and convergence of the discrete delta function, a cornerstone of many immersed boundary methods . By implementing moment-correction procedures on a challenging non-uniform grid, you will learn how to formally ensure that your numerical operators possess the necessary mathematical properties to deliver robust and accurate results in complex simulations.",
            "id": "3510132",
            "problem": "Design and implement a manufactured-solution verification for an Immersed Boundary (IB) discretization that spreads from a Lagrangian point to a non-uniform Eulerian mesh using a discrete regularized delta kernel. The goal is to verify consistency and study convergence behavior of the discrete convolution as the kernel width $ \\varepsilon $ and local grid spacing $ h $ vary on a strongly non-uniform mesh.\n\nThe test is based on the fundamental property of the Dirac delta distribution that for a smooth function $ f $, one has\n$$\n\\int_{0}^{1} f(x)\\,\\delta(x - X)\\,dx = f(X).\n$$\nWe replace the singular Dirac delta $ \\delta $ by a regularized delta $ \\delta_{\\varepsilon} $ that satisfies the zeroth-moment and first-moment conditions,\n$$\n\\int_{0}^{1} \\delta_{\\varepsilon}(x - X)\\,dx = 1,\\quad \\int_{0}^{1} (x - X)\\,\\delta_{\\varepsilon}(x - X)\\,dx = 0,\n$$\nand we approximate the integral on a non-uniform grid by a discrete convolution.\n\nUse the Peskin four-point regularized delta kernel $ \\phi $ with compact support, defined by\n$$\n\\phi(s) = \\begin{cases}\n\\dfrac{1}{8}\\left(3 - 2|s| + \\sqrt{1 + 4|s| - 4 s^2}\\right),  \\text{if } |s| \\le 1, \\\\\n\\dfrac{1}{8}\\left(5 - 2|s| - \\sqrt{-7 + 12|s| - 4 s^2}\\right),  \\text{if } 1  |s| \\le 2, \\\\\n0,  \\text{if } |s|  2.\n\\end{cases}\n$$\nDefine the regularized delta as\n$$\n\\delta_{\\varepsilon}(x - X) = \\frac{1}{\\varepsilon}\\,\\phi\\!\\left(\\frac{x - X}{\\varepsilon}\\right).\n$$\n\nConstruct a strongly non-uniform mesh on the domain $ x \\in [0,1] $ with nodes\n$$\nx_i = \\left(\\frac{i}{N}\\right)^3,\\quad i = 0,1,2,\\ldots,N,\n$$\nwhere $ N $ is the number of intervals. Use composite trapezoidal-rule weights $ \\Delta x_i $ to approximate integrals on this mesh, defined by\n$$\n\\Delta x_0 = \\frac{x_1 - x_0}{2},\\quad \\Delta x_N = \\frac{x_N - x_{N-1}}{2},\\quad \\Delta x_i = \\frac{x_{i+1} - x_{i-1}}{2}\\ \\text{for}\\ i = 1,2,\\ldots,N-1.\n$$\n\nLet the manufactured smooth function be\n$$\nf(x) = \\sin(2\\pi x) + x^2,\n$$\nwith Lagrangian point $ X \\in (0,1) $. Approximate $ f(X) $ by the discrete convolution\n$$\nI_f \\approx \\sum_{i=0}^{N} f(x_i)\\,W_i\\,\\Delta x_i,\n$$\nwhere $ W_i $ are discrete delta weights constructed from the regularized kernel and corrected to enforce discrete moment conditions under quadrature. Specifically:\n- Compute raw weights\n$$\nw_i = \\delta_{\\varepsilon}(x_i - X) = \\frac{1}{\\varepsilon}\\,\\phi\\!\\left(\\frac{x_i - X}{\\varepsilon}\\right).\n$$\n- Normalize the zeroth moment via\n$$\nc_0 = \\sum_{i=0}^{N} w_i\\,\\Delta x_i,\\quad W_i^{(0)} = \\frac{w_i}{c_0}.\n$$\n- Enforce the discrete first-moment condition by introducing a linear correction factor $ \\alpha $:\n$$\nm_1 = \\sum_{i=0}^{N} (x_i - X)\\,W_i^{(0)}\\,\\Delta x_i,\\quad \\mu_2 = \\sum_{i=0}^{N} (x_i - X)^2\\,W_i^{(0)}\\,\\Delta x_i,\\quad \\alpha = -\\frac{m_1}{\\mu_2},\n$$\nand define corrected weights\n$$\n\\widetilde{W}_i = W_i^{(0)}\\left(1 + \\alpha\\,(x_i - X)\\right).\n$$\n- Renormalize the corrected weights to preserve the zeroth moment:\n$$\n\\widetilde{c}_0 = \\sum_{i=0}^{N} \\widetilde{W}_i\\,\\Delta x_i,\\quad W_i = \\frac{\\widetilde{W}_i}{\\widetilde{c}_0}.\n$$\n\nThe local grid spacing $ h $ at the Lagrangian point $ X $ is defined as the composite trapezoidal weight $ \\Delta x_j $ corresponding to the node $ x_j $ nearest to $ X $ in $ \\ell^{\\infty} $ norm. Set the kernel width as $ \\varepsilon = \\kappa\\,h $, where $ \\kappa $ is a dimensionless factor.\n\nFor each test case, compute the following quantities:\n- The absolute interpolation error\n$$\nE = \\left|\\,\\sum_{i=0}^{N} f(x_i)\\,W_i\\,\\Delta x_i - f(X)\\,\\right|.\n$$\n- The zeroth-moment error\n$$\nE_0 = \\left|\\,1 - \\sum_{i=0}^{N} W_i\\,\\Delta x_i\\,\\right|.\n$$\n- The first-moment error\n$$\nE_1 = \\left|\\,\\sum_{i=0}^{N} (x_i - X)\\,W_i\\,\\Delta x_i\\,\\right|.\n$$\n\nYour program must implement the above construction and compute $ E $, $ E_0 $, and $ E_1 $ for the specified test suite. In addition, quantify convergence by computing observed orders:\n- For fixed $ \\kappa = 2.5 $ and fixed $ X \\in \\{0.05,\\,0.5,\\,0.95\\} $, compare cases $ N = 64 $ and $ N = 256 $ to compute the observed order with respect to the local grid spacing $ h $. Let $ E_{64,X} $ and $ E_{256,X} $ be the interpolation errors and $ h_{64,X} $ and $ h_{256,X} $ the corresponding local spacings. Define\n$$\np_X = \\frac{\\log(E_{64,X} / E_{256,X})}{\\log(h_{64,X} / h_{256,X})}.\n$$\n- For fixed $ N = 128 $ and $ X = 0.5 $, use $ \\kappa \\in \\{1.5,\\,2.5,\\,3.5\\} $ to estimate the scaling of $ E $ with respect to $ \\varepsilon $ via linear regression in $ \\log$-$\\log $ space. Let $ \\varepsilon_j $ and $ E_j $ be the three values; fit $ \\log(E_j) \\approx a + q\\,\\log(\\varepsilon_j) $ to obtain the slope $ q $.\n\nTest Suite:\n- Case $ 1 $: $ N = 64 $, $ X = 0.05 $, $ \\kappa = 2.5 $.\n- Case $ 2 $: $ N = 64 $, $ X = 0.5 $, $ \\kappa = 2.5 $.\n- Case $ 3 $: $ N = 64 $, $ X = 0.95 $, $ \\kappa = 2.5 $.\n- Case $ 4 $: $ N = 256 $, $ X = 0.05 $, $ \\kappa = 2.5 $.\n- Case $ 5 $: $ N = 256 $, $ X = 0.5 $, $ \\kappa = 2.5 $.\n- Case $ 6 $: $ N = 256 $, $ X = 0.95 $, $ \\kappa = 2.5 $.\n- Case $ 7 $: $ N = 128 $, $ X = 0.5 $, $ \\kappa = 1.5 $.\n- Case $ 8 $: $ N = 128 $, $ X = 0.5 $, $ \\kappa = 2.5 $.\n- Case $ 9 $: $ N = 128 $, $ X = 0.5 $, $ \\kappa = 3.5 $.\n\nFinal Output Format:\nYour program should produce a single line of output containing a list. The first nine entries are lists $ [E, E_0, E_1] $ for each of the nine cases. These are followed by four floats $ p_{0.05} $, $ p_{0.5} $, $ p_{0.95} $ and $ q $ in that order. For example,\n$$\n[\\,[E_1,E_{0,1},E_{1,1}],\\,[E_2,E_{0,2},E_{1,2}],\\,\\ldots,\\,[E_9,E_{0,9},E_{1,9}],\\,p_{0.05},\\,p_{0.5},\\,p_{0.95},\\,q\\,].\n$$\nAll reported values must be dimensionless real numbers. Angles are not used. Percentages are not used. Express all values as standard decimal floats.",
            "solution": "The user has provided a well-defined problem in the domain of numerical analysis for verifying an Immersed Boundary (IB) method discretization. The validation confirms that the problem is scientifically sound, well-posed, and all necessary components for a solution are provided. The task requires implementing a specific algorithm and performing a convergence study.\n\nThe solution is structured as follows:\n1.  **Methodology Overview**: A summary of the method of manufactured solutions as applied to the discrete convolution operator central to IB methods.\n2.  **Discretization of Domain and Integrals**: Description of the non-uniform Eulerian grid and the composite trapezoidal rule used for numerical quadrature.\n3.  **Discrete Delta Function Construction**: An explanation of the process for constructing discrete delta function weights, $W_i$, including the use of a regularized kernel and the essential moment-correction steps.\n4.  **Error Analysis and Convergence Metrics**: Definition of the error quantities ($E, E_0, E_1$) and the convergence metrics ($p_X, q$) used to assess the accuracy and behavior of the numerical scheme.\n5.  **Algorithmic Implementation**: A brief on how these mathematical steps are translated into a computational algorithm to solve the problem for the given test suite.\n\n**1. Methodology Overview**\nThe problem employs the method of manufactured solutions to verify the implementation of a discrete convolution operator. This operator is fundamental to Immersed Boundary (IB) and other fictitious domain methods, where it is used to transfer quantities (e.g., forces, velocities) between Lagrangian markers and an Eulerian grid. The verification is based on a key property of the Dirac delta distribution, $\\int f(x)\\delta(x-X)dx = f(X)$. In the numerical context, we replace the singular $\\delta$ with a regularized kernel $\\delta_{\\varepsilon}$ and the integral with a discrete summation on a computational grid:\n$$\n\\sum_{i=0}^{N} f(x_i) W_i \\Delta x_i \\approx f(X)\n$$\nHere, $f(x)$ is a known smooth \"manufactured\" function, $x_i$ are the grid points, $\\Delta x_i$ are the quadrature weights, and $W_i$ are the discrete delta function weights. The accuracy of this approximation is a direct measure of the discretization's consistency.\n\n**2. Discretization of Domain and Integrals**\nThe problem specifies a one-dimensional domain $x \\in [0,1]$. This domain is discretized using a strongly non-uniform grid. The grid nodes $x_i$ are defined for $i=0, 1, \\ldots, N$ as:\n$$\nx_i = \\left(\\frac{i}{N}\\right)^3\n$$\nThis choice of grid leads to a high concentration of points near $x=0$ and a sparse distribution near $x=1$, providing a challenging test for the robustness of the numerical scheme.\n\nIntegrals on this non-uniform grid are approximated using a discrete sum with weights derived from the composite trapezoidal rule. For a function $g(x)$, the integral $\\int g(x) dx$ is approximated by $\\sum_i g(x_i) \\Delta x_i$, where the weights $\\Delta x_i$ are:\n$$\n\\Delta x_0 = \\frac{x_1 - x_0}{2}, \\quad \\Delta x_N = \\frac{x_N - x_{N-1}}{2}, \\quad \\Delta x_i = \\frac{x_{i+1} - x_{i-1}}{2} \\text{ for } i=1, \\ldots, N-1.\n$$\nThese weights represent the volume element associated with each grid node $x_i$.\n\n**3. Discrete Delta Function Construction**\nThe discrete delta weights $W_i$ are constructed from the continuous four-point Peskin kernel $\\phi(s)$. The regularized delta function $\\delta_{\\varepsilon}(x-X)$ is defined as $\\frac{1}{\\varepsilon}\\phi(\\frac{x-X}{\\varepsilon})$, where $\\varepsilon$ is the kernel width that controls its support.\n\nA naive discretization by simply sampling the kernel, $w_i = \\delta_{\\varepsilon}(x_i-X)$, does not guarantee that the resulting discrete operator satisfies the crucial moment conditions on a non-uniform grid. That is, $\\sum_i w_i \\Delta x_i \\neq 1$ and $\\sum_i (x_i-X)w_i \\Delta x_i \\neq 0$ in general. To ensure the scheme has the desired accuracy and conservation properties, a correction procedure is applied:\n1.  **Raw Weights**: The kernel is sampled at grid points to get raw weights, $w_i = \\frac{1}{\\varepsilon}\\phi(\\frac{x_i - X}{\\varepsilon})$.\n2.  **Zeroth-Moment Correction**: The weights are normalized to ensure the discrete sum is unity (i.e., it integrates a constant function exactly). The normalization constant is $c_0 = \\sum_{i} w_i \\Delta x_i$, and the corrected weights are $W_i^{(0)} = w_i / c_0$.\n3.  **First-Moment Correction**: A linear correction term, $1 + \\alpha(x_i-X)$, is introduced to enforce the discrete first-moment condition. The first moment of $W^{(0)}$ is calculated as $m_1 = \\sum_{i} (x_i-X)W_i^{(0)}\\Delta x_i$. The coefficient $\\alpha$ is chosen to cancel this moment, leading to $\\alpha = -m_1/\\mu_2$, where $\\mu_2 = \\sum_i (x_i-X)^2 W_i^{(0)} \\Delta x_i$ is the second moment. The new weights are $\\widetilde{W}_i = W_i^{(0)}(1+\\alpha(x_i-X))$.\n4.  **Renormalization**: The first-moment correction alters the zeroth moment. A final renormalization is applied to restore it. The final weights are $W_i = \\widetilde{W}_i / \\sum_j \\widetilde{W}_j \\Delta x_j$. These final weights $W_i$ satisfy the discrete zeroth and first moment conditions up to machine precision.\n\n**4. Error Analysis and Convergence Metrics**\nThe quality of the approximation is assessed through several metrics:\n-   **Interpolation Error ($E$)**: The primary measure of accuracy is the absolute error $E = \\left|\\sum_{i=0}^{N} f(x_i)W_i\\Delta x_i - f(X)\\right|$.\n-   **Moment Errors ($E_0, E_1$)**: To verify the success of the correction procedure, we compute the zeroth-moment error $E_0 = \\left|1 - \\sum_i W_i \\Delta x_i\\right|$ and the first-moment error $E_1 = \\left|\\sum_i (x_i - X) W_i \\Delta x_i\\right|$. These should be close to floating-point zero.\n\nThe convergence study investigates how the error $E$ behaves as the discretization parameters are refined.\n-   **Local Grid Spacing ($h$)**: The error is expected to decrease as the grid becomes finer. A local grid spacing $h$ is defined at the Lagrangian point $X$ as the trapezoidal weight $\\Delta x_j$ of the nearest grid node $x_j$. For a fixed ratio $\\kappa = \\varepsilon/h$, the convergence order $p_X$ is computed as $p_X = \\frac{\\log(E_{\\text{coarse}}/E_{\\text{fine}})}{\\log(h_{\\text{coarse}}/h_{\\text{fine}})}$, which determines the rate at which error decreases with $h$.\n-   **Kernel Width ($\\varepsilon$)**: For a fixed grid, the error also depends on the kernel width $\\varepsilon = \\kappa h$. The problem investigates the scaling of the error with $\\varepsilon$ by assuming a power-law relationship $E \\propto \\varepsilon^q$. The exponent $q$ is determined by a linear regression on a log-log plot of $E$ versus $\\varepsilon$.\n\n**5. Algorithmic Implementation**\nThe solution is implemented as a Python script. A main function orchestrates the process for each of the nine test cases. For each case, it constructs the grid, computes quadrature and kernel weights, performs the moment corrections, and calculates the errors $E, E_0,$ and $E_1$. The results are stored. After processing all cases, the convergence metrics ($p_{0.05}, p_{0.5}, p_{0.95}, q$) are computed from the stored results. Finally, the collected data is formatted into a single list and printed as specified.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the manufactured solution verification for an Immersed Boundary discretization\n    as specified in the problem statement.\n    \"\"\"\n\n    def phi(s: np.ndarray) - np.ndarray:\n        \"\"\"\n        Computes the Peskin four-point regularized delta kernel.\n        \"\"\"\n        s_abs = np.abs(s)\n        result = np.zeros_like(s, dtype=float)\n\n        # Case 1: |s| = 1\n        mask1 = s_abs = 1\n        s_abs_1 = s_abs[mask1]\n        arg_sqrt1 = 1 + 4 * s_abs_1 - 4 * s_abs_1**2\n        arg_sqrt1[arg_sqrt1  0] = 0  # Avoid numerical issues\n        result[mask1] = (1/8) * (3 - 2 * s_abs_1 + np.sqrt(arg_sqrt1))\n\n        # Case 2: 1  |s| = 2\n        mask2 = (s_abs  1)  (s_abs = 2)\n        s_abs_2 = s_abs[mask2]\n        arg_sqrt2 = -7 + 12 * s_abs_2 - 4 * s_abs_2**2\n        arg_sqrt2[arg_sqrt2  0] = 0  # Avoid numerical issues\n        result[mask2] = (1/8) * (5 - 2 * s_abs_2 - np.sqrt(arg_sqrt2))\n\n        return result\n\n    def manufactured_f(x: float or np.ndarray) - float or np.ndarray:\n        \"\"\"\n        Computes the manufactured smooth function.\n        \"\"\"\n        return np.sin(2 * np.pi * x) + x**2\n\n    def calculate_errors_and_h(N: int, X: float, kappa: float) - tuple:\n        \"\"\"\n        Performs the main calculation for a given test case.\n        \"\"\"\n        # 1. Generate non-uniform mesh\n        i_indices = np.arange(N + 1)\n        x_nodes = (i_indices / N)**3\n\n        # 2. Compute composite trapezoidal-rule weights\n        delta_x = np.zeros(N + 1)\n        delta_x[0] = (x_nodes[1] - x_nodes[0]) / 2\n        delta_x[N] = (x_nodes[N] - x_nodes[N-1]) / 2\n        delta_x[1:N] = (x_nodes[2:] - x_nodes[:-2]) / 2\n\n        # 3. Define local grid spacing h and kernel width epsilon\n        j_nearest = np.argmin(np.abs(x_nodes - X))\n        h = delta_x[j_nearest]\n        epsilon = kappa * h\n\n        # 4. Compute raw weights\n        s = (x_nodes - X) / epsilon\n        w_raw = (1 / epsilon) * phi(s)\n\n        # 5. Normalize zeroth moment\n        c0 = np.sum(w_raw * delta_x)\n        W0 = w_raw / c0 if c0 != 0 else np.zeros_like(w_raw)\n\n        # 6. Enforce first-moment condition\n        x_minus_X = x_nodes - X\n        m1 = np.sum(x_minus_X * W0 * delta_x)\n        mu2 = np.sum(x_minus_X**2 * W0 * delta_x)\n        alpha = -m1 / mu2 if mu2 != 0 else 0\n        W_tilde = W0 * (1 + alpha * x_minus_X)\n\n        # 7. Renormalize to preserve zeroth moment\n        c0_tilde = np.sum(W_tilde * delta_x)\n        W_final = W_tilde / c0_tilde if c0_tilde != 0 else np.zeros_like(W_tilde)\n\n        # 8. Compute errors\n        I_f = np.sum(manufactured_f(x_nodes) * W_final * delta_x)\n        f_at_X = manufactured_f(X)\n        E = np.abs(I_f - f_at_X)\n        \n        E0 = np.abs(1 - np.sum(W_final * delta_x))\n        \n        E1 = np.abs(np.sum(x_minus_X * W_final * delta_x))\n        \n        return E, E0, E1, h\n\n    test_cases = [\n        (64, 0.05, 2.5), (64, 0.5, 2.5), (64, 0.95, 2.5),\n        (256, 0.05, 2.5), (256, 0.5, 2.5), (256, 0.95, 2.5),\n        (128, 0.5, 1.5), (128, 0.5, 2.5), (128, 0.5, 3.5),\n    ]\n\n    all_case_results = []\n    # A dictionary to store results for convergence analysis, keyed by (N, X, kappa)\n    analysis_data = {}\n\n    for N, X, kappa in test_cases:\n        E, E0, E1, h = calculate_errors_and_h(N, X, kappa)\n        all_case_results.append([E, E0, E1])\n        analysis_data[(N, X, kappa)] = {'E': E, 'h': h}\n\n    # --- Convergence Analysis ---\n\n    # Calculate observed order p_X for X in {0.05, 0.5, 0.95}\n    p_values = []\n    for X_val in [0.05, 0.5, 0.95]:\n        kappa_val = 2.5\n        E_64 = analysis_data[(64, X_val, kappa_val)]['E']\n        h_64 = analysis_data[(64, X_val, kappa_val)]['h']\n        E_256 = analysis_data[(256, X_val, kappa_val)]['E']\n        h_256 = analysis_data[(256, X_val, kappa_val)]['h']\n        \n        p = np.log(E_64 / E_256) / np.log(h_64 / h_256)\n        p_values.append(p)\n    \n    p_005, p_05, p_095 = p_values\n\n    # Calculate scaling exponent q\n    N_q, X_q = 128, 0.5\n    kappas_q = np.array([1.5, 2.5, 3.5])\n    errors_q = np.array([analysis_data[(N_q, X_q, k)]['E'] for k in kappas_q])\n    \n    # h is constant for fixed N and X\n    h_q = analysis_data[(N_q, X_q, kappas_q[0])]['h']\n    epsilons_q = kappas_q * h_q\n    \n    log_E = np.log(errors_q)\n    log_eps = np.log(epsilons_q)\n    \n    # Linear regression: log(E) = a + q*log(eps)\n    # np.polyfit returns [slope, intercept] for degree 1\n    q = np.polyfit(log_eps, log_E, 1)[0]\n    \n    # --- Final Output Formatting ---\n    final_output_list = all_case_results + [p_005, p_05, p_095, q]\n    \n    # Using repr() and then removing spaces creates a compact string representation\n    # that matches the implied format. Using str() directly adds spaces which\n    # might not be desired. For robustness, we build the string manually.\n    \n    def format_item(item):\n        if isinstance(item, list):\n            return \"[\" + \",\".join(f\"{x:.15e}\" for x in item) + \"]\"\n        elif isinstance(item, float):\n            return f\"{item:.15e}\"\n        return str(item)\n\n    # The problem asks for standard decimal floats. Default str formatting is fine.\n    # Re-evaluating the printing logic based on \"standard decimal floats\"\n    # The default str() for a list already does this well.\n    print(final_output_list)\n\nsolve()\n```"
        }
    ]
}