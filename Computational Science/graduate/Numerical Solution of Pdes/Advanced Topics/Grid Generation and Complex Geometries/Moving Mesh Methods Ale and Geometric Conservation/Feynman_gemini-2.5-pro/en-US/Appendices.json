{
    "hands_on_practices": [
        {
            "introduction": "This exercise is fundamental, stripping away the complexity of a full PDE solver to focus purely on the geometric consistency required by all stable Arbitrary Lagrangian-Eulerian (ALE) methods. By analyzing a finite volume scheme on a moving interval, you will derive the specific condition on the time discretization—the Geometric Conservation Law (GCL)—that is necessary to exactly preserve a uniform flow. This practice builds core intuition about why the GCL is essential and how it constrains the design of numerical schemes on moving meshes. ",
            "id": "3423641",
            "problem": "Consider the one-dimensional conservation law $\\partial_{t} u + \\partial_{x} f(u) = 0$ on a moving interval $K(t) = [x_{L}(t), x_{R}(t)]$. Let the Arbitrary Lagrangian-Eulerian (ALE) map be linear in the reference coordinate $\\xi \\in [0,1]$, given by $x(\\xi,t) = x_{L}(t) + \\big(x_{R}(t) - x_{L}(t)\\big)\\,\\xi$. Define the face velocities by $w_{L}(t) = \\partial_{t} x_{L}(t)$ and $w_{R}(t) = \\partial_{t} x_{R}(t)$, and let the cell volume be $V(t) = x_{R}(t) - x_{L}(t)$. Consider one time step from $t^{n}$ to $t^{n+1}$ with $\\Delta t = t^{n+1} - t^{n}$.\n\nA second-order finite volume scheme is constructed from a space–time control volume over $[t^{n}, t^{n+1}]$ and approximates the space–time flux of mesh advection across each spatial face by a two-point time approximation of the form\n$$\nw_{\\star}^{\\text{disc}} = \\theta\\, w_{\\star}^{n+1} + (1 - \\theta)\\, w_{\\star}^{n},\n$$\nwhere $\\star \\in \\{L, R\\}$ denotes the left or right face, and $w_{\\star}^{n} = w_{\\star}(t^{n})$, $w_{\\star}^{n+1} = w_{\\star}(t^{n+1})$. The same time discretization is used for both faces, with the same unknown weight $\\theta \\in \\mathbb{R}$.\n\nThe Geometric Conservation Law (GCL) requires that a spatially uniform solution $u(x,t) \\equiv u_{0}$ be preserved exactly by the fully discrete scheme. Assume that each face trajectory is linear in time over the step, i.e., $x_{\\star}(t)$ is an affine function of $t$ on $[t^{n}, t^{n+1}]$. Under these assumptions, enforce the discrete GCL for the above space–time finite volume formulation and determine the unique value of the weight $\\theta$ that guarantees exact preservation of $u(x,t) \\equiv u_{0}$ for arbitrary $u_{0}$ and arbitrary linear-in-time face motions over the step.\n\nYour final answer must be the value of $\\theta$ as a single number. No units are required, and no rounding is needed.",
            "solution": "The problem requires finding the unique value of a weight $\\theta$ in a semi-discrete finite volume scheme that guarantees the Geometric Conservation Law (GCL) is satisfied. The GCL ensures that a uniform state $u(x,t) = u_0$ is preserved exactly by the numerical scheme on a moving mesh.\n\nThe one-dimensional conservation law is given by\n$$\n\\partial_{t} u + \\partial_{x} f(u) = 0\n$$\non a moving cell $K(t) = [x_L(t), x_R(t)]$.\n\nLet's start by formulating the exact integral form of the conservation law over the space-time control volume defined by the cell $K(t)$ moving from time $t^n$ to $t^{n+1}$. Using the Leibniz integral rule (or Reynolds transport theorem in one dimension), the time evolution of the integral of $u$ over $K(t)$ is:\n$$\n\\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} u(x,t) \\,dx = \\int_{x_L(t)}^{x_R(t)} \\partial_t u \\,dx + u(x_R(t), t) \\frac{dx_R}{dt} - u(x_L(t), t) \\frac{dx_L}{dt}\n$$\nSubstituting $\\partial_t u = -\\partial_x f(u)$ and the definitions of the face velocities $w_L(t) = \\partial_t x_L(t)$ and $w_R(t) = \\partial_t x_R(t)$:\n$$\n\\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} u \\,dx = \\int_{x_L(t)}^{x_R(t)} (-\\partial_x f(u)) \\,dx + u_R w_R - u_L w_L\n$$\n$$\n\\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} u \\,dx = -[f(u_R) - f(u_L)] + u_R w_R - u_L w_L\n$$\nwhere $u_L = u(x_L(t), t)$ and $u_R = u(x_R(t), t)$. This is the Arbitrary Lagrangian-Eulerian (ALE) form of the conservation law.\n\nThe GCL is a condition on the numerical scheme's handling of geometry. It is derived by considering the case of a uniform flow, $u(x,t) = u_0$, where $u_0$ is a constant. In this case, $f(u) = f(u_0)$ is also constant, and the physical flux term $\\partial_x f(u)$ is zero. The conservation law simplifies to $\\partial_t u = 0$. The ALE form becomes:\n$$\n\\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} u_0 \\,dx = u_0 w_R - u_0 w_L\n$$\nSince $u_0$ is constant, we can factor it out:\n$$\nu_0 \\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} 1 \\,dx = u_0 (w_R - w_L)\n$$\nThe integral is the volume (length) of the cell, $V(t) = x_R(t) - x_L(t)$. So, we have:\n$$\nu_0 \\frac{dV(t)}{dt} = u_0 (w_R - w_L)\n$$\nSince $\\frac{dV}{dt} = \\frac{d}{dt}(x_R - x_L) = w_R - w_L$, this equation is an identity. Now, we integrate this identity over the time step $[t^n, t^{n+1}]$:\n$$\n\\int_{t^n}^{t^{n+1}} \\frac{dV(t)}{dt} \\,dt = \\int_{t^n}^{t^{n+1}} (w_R(t) - w_L(t)) \\,dt\n$$\n$$\nV(t^{n+1}) - V(t^n) = \\int_{t^n}^{t^{n+1}} w_R(t) \\,dt - \\int_{t^n}^{t^{n+1}} w_L(t) \\,dt\n$$\nLetting $V^n = V(t^n)$, this is the exact integral form of the GCL:\n$$\nV^{n+1} - V^{n} = \\int_{t^n}^{t^{n+1}} (w_R(t) - w_L(t)) \\,dt\n$$\nThe discrete scheme must satisfy this geometric relation exactly.\n\nA finite volume scheme updates the cell average $\\bar{u}$ from time $t^n$ to $t^{n+1}$. The general form for the update is:\n$$\nV^{n+1}\\bar{u}^{n+1} - V^n \\bar{u}^n + \\Delta t (\\hat{F}_R - \\hat{F}_L) = 0\n$$\nwhere $\\hat{F}_\\star$ is the numerical flux at face $\\star \\in \\{L, R\\}$. The numerical flux includes a physical part and a grid-motion part. For the GCL test with $u=u_0$, the physical fluxes cancel, and the update equation simplifies. The condition that $\\bar{u}^{n+1} = \\bar{u}^n = u_0$ leads to the discrete GCL.\nThe problem specifies that the geometric part of the flux is approximated using a discrete mesh velocity $w_\\star^{\\text{disc}}$. The discrete GCL derived from the scheme is:\n$$\n\\frac{V^{n+1} - V^n}{\\Delta t} = w_R^{\\text{disc}} - w_L^{\\text{disc}}\n$$\nwhere $w_{\\star}^{\\text{disc}} = \\theta\\, w_{\\star}^{n+1} + (1 - \\theta)\\, w_{\\star}^{n}$.\n\nFor the discrete scheme to satisfy the GCL, its representation of volume change must match the exact integral form. By equating the exact and discrete GCL expressions, we obtain the condition on $\\theta$:\n$$\nw_R^{\\text{disc}} - w_L^{\\text{disc}} = \\frac{1}{\\Delta t} \\int_{t^n}^{t^{n+1}} (w_R(t) - w_L(t)) \\,dt\n$$\nSubstituting the definition of $w^{\\text{disc}}$:\n$$\n\\theta(w_R^{n+1} - w_L^{n+1}) + (1-\\theta)(w_R^n - w_L^n) = \\frac{1}{\\Delta t} \\int_{t^n}^{t^{n+1}} (w_R(t) - w_L(t)) \\,dt\n$$\nThe problem states to enforce this for \"arbitrary linear-in-time face motions,\" i.e., where $x_\\star(t)$ is an affine function. If $x_\\star(t)$ is linear in time, $x_\\star(t) = a_\\star t + b_\\star$, then the velocity $w_\\star(t) = \\partial_t x_\\star(t) = a_\\star$ is constant over the interval. Thus, $w_\\star^n = w_\\star(t^n)$ equals $w_\\star^{n+1} = w_\\star(t^{n+1})$, and the integral $\\int_{t^n}^{t^{n+1}} w_\\star(t)\\,dt$ is simply $w_\\star \\Delta t$. For constant velocities, the equation becomes an identity, $(w_R - w_L) = (w_R - w_L)$, which is true for any value of $\\theta$. This contradicts the problem's requirement to find a *unique* value of $\\theta$.\n\nThis contradiction stems from an imprecise problem statement. The phrase \"A second-order finite volume scheme\" is critical. A numerical scheme's temporal order of accuracy is determined by the accuracy of its time integration. The expression $\\theta G^{n+1} + (1-\\theta)G^n$ is a weighted average of the values of a function $G(t)$ at the start and end of a time step, used to approximate the time average $\\frac{1}{\\Delta t}\\int_{t^n}^{t^{n+1}} G(t) \\,dt$. This quadrature rule is second-order accurate (i.e., the error is $O(\\Delta t^2)$) only for a specific choice of $\\theta$. A second-order accurate scheme must, at a minimum, be exact for integrands that are linear in time. Therefore, the proper test for determining $\\theta$ for a second-order scheme is to require that the GCL holds exactly for motions where the face velocities $w_\\star(t)$ are linear functions of time (which corresponds to quadratic trajectories $x_\\star(t)$).\n\nLet's proceed by adopting this physically and numerically sound interpretation. We test the GCL condition for an arbitrary linear velocity profile for each face. Let $g_\\star(t) = w_\\star(t)$ be linear functions. Then their difference $g(t) = w_R(t) - w_L(t)$ is also a linear function of time.\n\nFor any function $g(t)$ that is linear in time, the exact value of its integral over $[t^n, t^{n+1}]$ is given by the trapezoidal rule:\n$$\n\\int_{t^n}^{t^{n+1}} g(t) \\,dt = \\frac{g(t^n) + g(t^{n+1})}{2} \\Delta t\n$$\nThus, the time-averaged value is:\n$$\n\\frac{1}{\\Delta t} \\int_{t^n}^{t^{n+1}} g(t) \\,dt = \\frac{g(t^n) + g(t^{n+1})}{2}\n$$\nLet's substitute this into our GCL consistency condition, with $g(t) = w_R(t) - w_L(t)$:\n$$\n\\theta g(t^{n+1}) + (1-\\theta)g(t^n) = \\frac{g(t^n) + g(t^{n+1})}{2}\n$$\nThis equation must hold for any arbitrary linear function $g(t)$, which means it must hold for any choice of initial and final values, $g(t^n)$ and $g(t^{n+1})$.\nLet's collect terms based on $g(t^n)$ and $g(t^{n+1})$:\n$$\n\\left(\\theta - \\frac{1}{2}\\right) g(t^{n+1}) + \\left(1 - \\theta - \\frac{1}{2}\\right) g(t^n) = 0\n$$\n$$\n\\left(\\theta - \\frac{1}{2}\\right) g(t^{n+1}) + \\left(\\frac{1}{2} - \\theta\\right) g(t^n) = 0\n$$\n$$\n\\left(\\theta - \\frac{1}{2}\\right) (g(t^{n+1}) - g(t^n)) = 0\n$$\nSince this relation must be satisfied for *arbitrary* linear velocity profiles, we can choose a motion for which $g(t^{n+1}) \\neq g(t^n)$ (e.g., a cell that is accelerating its expansion). For the equation to hold in such general cases, the coefficient must be zero:\n$$\n\\theta - \\frac{1}{2} = 0\n$$\nThis determines the unique value of the weight:\n$$\n\\theta = \\frac{1}{2}\n$$\nThis value corresponds to the Crank-Nicolson method (or trapezoidal rule), which is consistent with the requirement of constructing a second-order scheme.",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "Building on the foundational principle, this practice applies the GCL concept to a high-order Discontinuous Galerkin (DG) method on curved, moving elements, where satisfying the GCL requires careful implementation. You will explore how the continuous identity $\\partial_t J = \\partial_\\xi v$ can be broken at the discrete level by inconsistent numerical approximations, leading to spurious errors. This hands-on implementation will demonstrate how to enforce a discrete GCL to restore exact free-stream preservation, a critical technique for developing accurate, high-order ALE simulations. ",
            "id": "3423630",
            "problem": "Consider a one-dimensional scalar conservation law in conservation form with constant advection speed $a$,\n$$\n\\partial_t u + \\partial_x \\left(a u\\right) = 0,\n$$\nposed on a spatial domain partitioned into a finite number of curvilinear elements. Let $x = x(\\xi,t)$ denote an isoparametric mapping from the reference coordinate $\\xi \\in [-1,1]$ to the physical coordinate $x$ for each element, where $t$ denotes time. Define the Jacobian $J(\\xi,t) := \\partial_\\xi x(\\xi,t)$ and the mesh velocity $v(\\xi,t) := \\partial_t x(\\xi,t)$.\n\nThe Arbitrary Lagrangian–Eulerian (ALE) conservative form of the scalar conservation law is\n$$\n\\partial_t \\left(J u \\right) + \\partial_\\xi \\left( a u - v u \\right) = 0.\n$$\nFor the special case of a constant solution $u \\equiv c$ (a free stream), the continuous geometric conservation law (GCL) states that\n$$\n\\partial_t J - \\partial_\\xi v = 0,\n$$\nwhich implies that the free stream is preserved exactly by the continuous ALE formulation: if the GCL holds, then $\\partial_t(J c) + \\partial_\\xi(a c - v c) = c(\\partial_t J - \\partial_\\xi v) = 0$.\n\nIn a high-order Discontinuous Galerkin (DG) discretization on curved elements, we approximate over each element by polynomials in the reference coordinate and construct a semi-discrete system by testing the ALE equation against a set of basis functions. For a nodal DG scheme, let $\\{ \\ell_i(\\xi) \\}_{i=1}^{N}$ denote the Lagrange polynomial basis associated with $N$ distinct reference nodes $\\{\\xi_i\\}_{i=1}^N \\subset [-1,1]$. The semi-discrete equation for the degrees of freedom $\\mathbf{U}(t) \\in \\mathbb{R}^N$, representing the expansion coefficients of $u(\\xi,t)$ in the nodal basis, takes the generic form\n$$\n\\mathbf{M}_J(t) \\frac{d\\mathbf{U}}{dt} + \\mathbf{R}(t) = \\mathbf{0},\n$$\nwhere $\\mathbf{M}_J(t)$ is the time-dependent mass matrix with entries\n$$\n\\left(\\mathbf{M}_J(t)\\right)_{ij} = \\int_{-1}^{1} J(\\xi,t)\\, \\ell_i(\\xi)\\, \\ell_j(\\xi)\\, d\\xi,\n$$\nand $\\mathbf{R}(t)$ is the residual vector assembling the flux and metric terms. For the free-stream case $u \\equiv c$, the only nontrivial contribution to $\\mathbf{R}(t)$ comes from the mismatch between the two metric terms,\n$$\n\\mathbf{R}_i(t) = c\\left[ \\int_{-1}^{1} \\partial_t J(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi - \\int_{-1}^{1} \\partial_\\xi v(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi \\right].\n$$\nIf the discrete geometric conservation law holds, namely\n$$\n\\int_{-1}^{1} \\partial_t J(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi = \\int_{-1}^{1} \\partial_\\xi v(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi \\quad \\text{for all } i,\n$$\nthen $\\mathbf{R}(t) = \\mathbf{0}$ and the free-stream $u \\equiv c$ is preserved exactly by the semi-discrete scheme.\n\nHowever, when the integral of $\\partial_t J$ is evaluated with an inconsistent or under-integrated quadrature rule (or with an inconsistent approximation in time), the cancellation with the $\\partial_\\xi v$ term fails, and the free-stream is not preserved. This problem asks you to construct a high-order nodal DG-ALE discretization over curved elements, demonstrate the degradation of free-stream preservation due to quadrature/time-approximation errors in $\\partial_t J$, and implement a correction that restores exact free-stream preservation by enforcing a discrete geometric conservation law.\n\nYou must:\n- Derive from first principles the discrete residual for the free-stream case from the ALE conservation law and explain the role of the geometric conservation law in ensuring exactness.\n- Implement a program that:\n  1. Builds a one-dimensional nodal DG discretization on multiple curved elements with an isoparametric mapping of the form\n     $$\n     x(\\xi,t) = A(t) + B(t)\\,\\xi + C(t)\\,\\xi^2 + D(t)\\,\\xi^3\n     $$\n     for each element, where $A(t)$, $B(t)$, $C(t)$, and $D(t)$ are smooth, time-dependent coefficients, and $J(\\xi,t) = B(t) + 2C(t)\\xi + 3D(t)\\xi^2$ and $v(\\xi,t) = \\partial_t x(\\xi,t)$ are induced.\n  2. Assembles the time-dependent mass matrix $\\mathbf{M}_J(t)$ using Gauss–Legendre quadrature with a specified number of quadrature points.\n  3. Computes the residual vector $\\mathbf{R}(t)$ for $u \\equiv c$ in two ways:\n     - An uncorrected residual that integrates $\\partial_t J$ using an under-integrated quadrature and approximates $\\partial_t J$ by a forward finite difference in time, while integrating $\\partial_\\xi v$ accurately using higher-order quadrature and exact time derivatives. This simulates quadrature/time-approximation error that breaks free-stream preservation.\n     - A corrected residual that enforces the discrete geometric conservation law by replacing the integral of $\\partial_t J$ with the same quadrature-based projection used for the integral of $\\partial_\\xi v$, ensuring\n       $$\n       \\int_{-1}^{1} \\partial_t J(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi \\equiv \\int_{-1}^{1} \\partial_\\xi v(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi\n       $$\n       in the discrete sense for each test function $\\ell_i$.\n  4. Advances the semi-discrete system in time for the free-stream case using forward Euler time stepping,\n     $$\n     \\mathbf{M}_J(t^n)\\, \\frac{\\mathbf{U}^{n+1} - \\mathbf{U}^n}{\\Delta t} = - \\mathbf{R}(t^n),\n     $$\n     with $\\mathbf{U}^0$ initialized to the constant $c$ at all nodes.\n  5. Computes the final root-mean-square error of $u(\\xi,t)$ relative to the constant $c$ at the final time $T$, measured in the $L^2$ norm weighted by the final Jacobian:\n     $$\n     \\mathrm{Err} = \\left( \\frac{\\sum_{e} \\int_{-1}^{1} J_e(\\xi, T)\\, \\left(u_e(\\xi,T) - c\\right)^2\\, d\\xi}{\\sum_{e} \\int_{-1}^{1} J_e(\\xi, T)\\, d\\xi} \\right)^{1/2},\n     $$\n     where the integrals are evaluated using a high-order Gauss–Legendre quadrature.\n\nDesign your implementation to run three test cases that collectively exercise the scheme:\n- Test Case 1 (general curved, moving mesh, happy path): Two elements, polynomial degree $p=4$ (thus $N=p+1=5$ nodes per element), final time $T=1.0$, time step $\\Delta t=10^{-2}$, constant solution $c=2.0$. Let\n  $$\n  \\begin{aligned}\n  A_1(t) = 0.3\\sin(1.5 t),  B_1(t) = 1 + 0.2\\sin(2 t),  C_1(t) = 0.1\\cos(t),  D_1(t) = 0.05\\sin(3 t), \\\\\n  A_2(t) = 0.25\\sin(1.3 t),  B_2(t) = 1 + 0.15\\sin(1.7 t),  C_2(t) = 0.08\\cos(0.9 t),  D_2(t) = 0.04\\sin(2.5 t).\n  \\end{aligned}\n  $$\n  Use $6$-point Gauss–Legendre quadrature for the mass matrix and corrected residual integrals, $3$-point Gauss–Legendre quadrature for the uncorrected $\\partial_t J$ integral, and $10$-point Gauss–Legendre quadrature for the final error evaluation and the accurate $\\partial_\\xi v$ integral. Report two floats: the uncorrected error and the corrected error.\n- Test Case 2 (static mesh, boundary condition case): Two elements, same polynomial degree and constant $c=2.0$, $T=1.0$, $\\Delta t=10^{-2}$, but a static mapping\n  $$\n  A_e(t) \\equiv 0, \\quad B_e(t) \\equiv 1, \\quad C_e(t) \\equiv 0, \\quad D_e(t) \\equiv 0,\n  $$\n  for both elements $e=1,2$. Use the same quadrature orders as Test Case 1. Report two floats: the uncorrected error and the corrected error.\n- Test Case 3 (aggressive curved motion, edge case): Two elements, $p=4$, $c=2.0$, $T=1.0$, $\\Delta t=5\\times 10^{-2}$. Let\n  $$\n  \\begin{aligned}\n  A_1(t) = 0.3\\sin(1.8 t),  B_1(t) = 1 + 0.25\\sin(2.2 t),  C_1(t) = 0.3\\cos(1.1 t),  D_1(t) = 0.2\\sin(3.1 t), \\\\\n  A_2(t) = 0.28\\sin(1.4 t),  B_2(t) = 1 + 0.22\\sin(1.9 t),  C_2(t) = 0.27\\cos(0.95 t),  D_2(t) = 0.18\\sin(2.7 t).\n  \\end{aligned}\n  $$\n  Use $6$-point Gauss–Legendre quadrature for the mass matrix and corrected residual integrals, $2$-point Gauss–Legendre quadrature for the uncorrected $\\partial_t J$ integral, and $16$-point Gauss–Legendre quadrature for the final error evaluation and the accurate $\\partial_\\xi v$ integral. Report two floats: the uncorrected error and the corrected error.\n\nNo physical units are required; angles in the trigonometric functions are to be interpreted in radians. Your program should produce a single line of output containing the results for all test cases as a comma-separated list of six floats enclosed in square brackets in the following order:\n$$\n[\\text{uncorrected}_1, \\text{corrected}_1, \\text{uncorrected}_2, \\text{corrected}_2, \\text{uncorrected}_3, \\text{corrected}_3].\n$$",
            "solution": "The problem requires an analysis and implementation of a high-order Discontinuous Galerkin (DG) scheme for a scalar advection equation on a moving, curved mesh, focusing on the role of the Geometric Conservation Law (GCL) in preserving a constant-flow solution (free-stream).\n\n### Principle-Based Derivation\n\nWe begin with the one-dimensional scalar conservation law with a constant advection speed $a$:\n$$\n\\partial_t u + \\partial_x (a u) = 0\n$$\nThe problem is posed on a domain with time-dependent, curved elements. We use an isoparametric mapping $x = x(\\xi, t)$ for each element, transforming from a fixed reference element with coordinate $\\xi \\in [-1, 1]$ to the physical element. The key geometric quantities are the Jacobian of this transformation, $J(\\xi, t) = \\partial_\\xi x(\\xi, t)$, and the mesh velocity, $v(\\xi, t) = \\partial_t x(\\xi, t)$.\n\nUsing the chain rule, we can transform the conservation law into the Arbitrary Lagrangian-Eulerian (ALE) frame on the reference element. The resulting conservative ALE formulation is:\n$$\n\\partial_t (J u) + \\partial_\\xi (a u - v u) = 0\n$$\n\nA fundamental requirement for any valid numerical scheme is its ability to preserve a constant solution, often referred to as a \"free-stream\" or \"uniform flow\". Let's test the continuous ALE equation with a constant solution $u(\\xi, t) \\equiv c$. Substituting $u=c$ into the ALE equation yields:\n$$\n\\partial_t (J c) + \\partial_\\xi (a c - v c) = c\\, \\partial_t J + c\\, \\partial_\\xi a - c\\, \\partial_\\xi v\n$$\nSince the advection speed $a$ is constant, $\\partial_\\xi a = 0$. The equation simplifies to:\n$$\nc \\left( \\partial_t J - \\partial_\\xi v \\right) = 0\n$$\nThis implies that for a free-stream solution to be preserved, the geometric quantities must satisfy the **continuous Geometric Conservation Law (GCL)**:\n$$\n\\partial_t J - \\partial_\\xi v = 0\n$$\nThis identity can be confirmed by noting that for a smooth mapping $x(\\xi, t)$, mixed partial derivatives are equal: $\\partial_t \\partial_\\xi x = \\partial_\\xi \\partial_t x$, which is precisely $\\partial_t J = \\partial_\\xi v$. Thus, the continuous ALE formulation exactly preserves the free stream.\n\nThe challenge arises in the discretization. For a high-order nodal DG scheme, we approximate the solution $u$ within each element using a basis of Lagrange polynomials $\\{ \\ell_i(\\xi) \\}_{i=1}^{N}$ associated with $N$ solution nodes $\\{\\xi_i\\}_{i=1}^N$. The semi-discrete form is obtained by multiplying the ALE equation by a test function $\\ell_i(\\xi)$ and integrating over the reference element:\n$$\n\\int_{-1}^{1} \\left( \\partial_t (J u) + \\partial_\\xi ((a-v)u) \\right) \\ell_i(\\xi)\\,d\\xi = 0\n$$\nExpanding the time derivative term $\\partial_t(Ju) = (\\partial_t J)u + J(\\partial_t u)$ and separating the terms involving time derivatives of the solution coefficients $\\mathbf{U}(t)$ gives the matrix system:\n$$\n\\mathbf{M}_J(t) \\frac{d\\mathbf{U}}{dt} + \\mathbf{R}(t) = \\mathbf{0}\n$$\nwhere $\\mathbf{M}_J(t)$ is the mass matrix and $\\mathbf{R}(t)$ is the residual vector. For the free-stream case $u=c$, the solution coefficients are constant, $\\mathbf{U}(t) = c \\cdot \\mathbf{1}$, so their time derivative is zero: $d\\mathbf{U}/dt = \\mathbf{0}$. For the semi-discrete scheme to preserve this solution, the residual vector $\\mathbf{R}(t)$ must be identically zero when $u=c$.\n\nThe $i$-th component of the residual for $u=c$ is:\n$$\nR_i(t) = \\int_{-1}^{1} \\left( (\\partial_t J)c + \\partial_\\xi ((a-v)c) \\right) \\ell_i(\\xi)\\,d\\xi = c \\left[ \\int_{-1}^{1} \\partial_t J\\, \\ell_i\\,d\\xi - \\int_{-1}^{1} \\partial_\\xi v\\, \\ell_i\\,d\\xi \\right]\n$$\n(The contribution from the constant $a$ term vanishes after integration by parts and assuming periodic or consistent inter-element fluxes for a constant state). For the free-stream to be preserved, we must have $R_i(t) = 0$ for all $i$, which leads to the **discrete Geometric Conservation Law (GCL)**:\n$$\n\\int_{-1}^{1} \\partial_t J(\\xi,t)\\,\\ell_i(\\xi)\\,d\\xi = \\int_{-1}^{1} \\partial_\\xi v(\\xi,t)\\,\\ell_i(\\xi)\\,d\\xi \\quad \\forall i\n$$\n\nThe core of the problem lies in the numerical evaluation of these two integrals.\n1.  **Uncorrected Scheme**: The term $\\partial_t J$ arises from the time derivative operator. In a time-stepping scheme, it is natural to approximate it with a finite difference, e.g., $\\partial_t J(\\xi, t^n) \\approx (J(\\xi, t^{n+1}) - J(\\xi, t^n))/\\Delta t$. The mesh velocity $v$, however, is an explicit part of the flux function and is typically evaluated at time $t^n$. The two integrals in the discrete GCL are thus computed in fundamentally different ways: one with a numerical time derivative and often a low-order quadrature rule for efficiency (under-integration), and the other with an analytical spatial derivative and a high-order quadrature rule for accuracy. This mismatch leads to a non-zero residual $\\mathbf{R}(t) \\neq \\mathbf{0}$, which introduces errors and causes the numerical scheme to fail to preserve the free-stream.\n\n2.  **Corrected Scheme**: To restore free-stream preservation, the discrete GCL must be strictly enforced. This is achieved by ensuring that the numerical evaluation of the two integrals yields identical results. The standard correction is to compute both integrals using the *same procedure*. Since $\\partial_t J = \\partial_\\xi v$ analytically, we can use the analytical expressions for both integrands and evaluate both integrals using the same quadrature rule (e.g., the one used for the mass matrix). This consistency guarantees that the two discrete terms cancel each other to machine precision, making the residual $\\mathbf{R}(t)$ for the free-stream case a zero vector. Consequently, $d\\mathbf{U}/dt = \\mathbf{0}$, and the free-stream is preserved exactly by the semi-discrete scheme.\n\nThe following implementation will demonstrate this principle by simulating the evolution of a constant solution with both the uncorrected and corrected schemes and measuring the resulting error.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi\nfrom numpy.polynomial.legendre import leggauss\n\ndef get_gauss_lobatto_nodes(N):\n    \"\"\"Computes the N-point Gauss-Lobatto-Legendre nodes on [-1, 1].\"\"\"\n    if N == 1:\n        return np.array([0.0])\n    if N == 2:\n        return np.array([-1.0, 1.0])\n    # Interior nodes are roots of P'_{N-1}(x), which are roots of Jacobi polynomial P_{N-2}^{(1,1)}(x)\n    interior_nodes = roots_jacobi(N - 2, 1, 1)[0]\n    return np.r_[-1.0, interior_nodes, 1.0]\n\ndef lagrange_basis(solution_nodes, evaluation_points):\n    \"\"\"\n    Computes the values of the Lagrange basis polynomials.\n    Rows correspond to basis functions, columns to evaluation points.\n    \"\"\"\n    N = len(solution_nodes)\n    M = len(evaluation_points)\n    L = np.ones((N, M))\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                L[i, :] *= (evaluation_points - solution_nodes[j]) / (solution_nodes[i] - solution_nodes[j])\n    return L\n\nclass Element:\n    \"\"\"Represents a single DG element with moving geometry.\"\"\"\n    def __init__(self, p, c, dt, mapping_coeffs, quad_orders):\n        self.p = p\n        self.N = p + 1\n        self.c = c\n        self.dt = dt\n        self.coeffs = mapping_coeffs\n        \n        nq_mass, nq_uncorr, nq_high, nq_error = quad_orders\n        \n        # Solution nodes (Gauss-Lobatto) and quadrature rules\n        self.sol_nodes = get_gauss_lobatto_nodes(self.N)\n        self.q_mass_nodes, self.q_mass_weights = leggauss(nq_mass)\n        self.q_uncorr_nodes, self.q_uncorr_weights = leggauss(nq_uncorr)\n        self.q_high_nodes, self.q_high_weights = leggauss(nq_high)\n        self.q_error_nodes, self.q_error_weights = leggauss(nq_error)\n        \n        # Pre-compute basis functions at quadrature nodes\n        self.L_mass = lagrange_basis(self.sol_nodes, self.q_mass_nodes)\n        self.L_uncorr = lagrange_basis(self.sol_nodes, self.q_uncorr_nodes)\n        self.L_high = lagrange_basis(self.sol_nodes, self.q_high_nodes)\n        self.L_error = lagrange_basis(self.sol_nodes, self.q_error_nodes)\n\n    def get_geometry(self, t, xi, derivatives=True):\n        \"\"\"Computes geometric quantities J, v, and their derivatives.\"\"\"\n        A, B, C, D = self.coeffs['A'](t), self.coeffs['B'](t), self.coeffs['C'](t), self.coeffs['D'](t)\n        J = B + 2 * C * xi + 3 * D * xi**2\n        if not derivatives:\n            return J, None, None, None\n            \n        Ad, Bd, Cd, Dd = self.coeffs['Ad'](t), self.coeffs['Bd'](t), self.coeffs['Cd'](t), self.coeffs['Dd'](t)\n        v = Ad + Bd * xi + Cd * xi**2 + Dd * xi**3\n        dJdt_exact = Bd + 2 * Cd * xi + 3 * Dd * xi**2\n        dvdxi_exact = Bd + 2 * Cd * xi + 3 * Dd * xi**2\n        \n        return J, v, dJdt_exact, dvdxi_exact\n\n    def get_mass_matrix(self, t):\n        \"\"\"Assembles the time-dependent mass matrix M_J.\"\"\"\n        J_at_mass_nodes, _, _, _ = self.get_geometry(t, self.q_mass_nodes, derivatives=False)\n        # M_ij = integral(J * l_i * l_j dxi)\n        M_J = self.L_mass @ (np.diag(self.q_mass_weights * J_at_mass_nodes)) @ self.L_mass.T\n        return M_J\n\n    def get_residuals(self, t):\n        \"\"\"Computes both uncorrected and corrected residuals for the free-stream case.\"\"\"\n        # Uncorrected Residual\n        J_t, _, _, _ = self.get_geometry(t, self.q_uncorr_nodes, derivatives=False)\n        J_t_plus_dt, _, _, _ = self.get_geometry(t + self.dt, self.q_uncorr_nodes, derivatives=False)\n        dJdt_approx = (J_t_plus_dt - J_t) / self.dt\n        \n        _, _, _, dvdxi_exact_high = self.get_geometry(t, self.q_high_nodes)\n        \n        term1_uncorr = self.L_uncorr @ (self.q_uncorr_weights * dJdt_approx)\n        term2_uncorr = self.L_high @ (self.q_high_weights * dvdxi_exact_high)\n        R_uncorr = self.c * (term1_uncorr - term2_uncorr)\n\n        # Corrected Residual (should be zero to machine precision)\n        _, _, dJdt_exact_mass, dvdxi_exact_mass = self.get_geometry(t, self.q_mass_nodes)\n        term1_corr = self.L_mass @ (self.q_mass_weights * dJdt_exact_mass)\n        term2_corr = self.L_mass @ (self.q_mass_weights * dvdxi_exact_mass)\n        R_corr = self.c * (term1_corr - term2_corr)\n            \n        return R_uncorr, R_corr\n\n    def compute_element_error(self, U, t_final):\n        \"\"\"Computes the L2 error contribution from this element.\"\"\"\n        u_at_error_nodes = self.L_error.T @ U\n        J_final, _, _, _ = self.get_geometry(t_final, self.q_error_nodes, derivatives=False)\n        \n        sq_err_integrand = J_final * (u_at_error_nodes - self.c)**2\n        element_sq_err = np.sum(self.q_error_weights * sq_err_integrand)\n        element_vol = np.sum(self.q_error_weights * J_final)\n\n        return element_sq_err, element_vol\n\nclass DGSolver:\n    \"\"\"Manages the DG-ALE simulation over multiple elements.\"\"\"\n    def __init__(self, p, num_elements, T, dt, c, all_mappings_coeffs, quad_orders):\n        self.T = T\n        self.dt = dt\n        self.num_elements = num_elements\n        self.N = p + 1\n        \n        self.elements = [Element(p, c, dt, all_mappings_coeffs[e], quad_orders) for e in range(num_elements)]\n        \n        self.U_uncorr = np.full((num_elements, self.N), c)\n        self.U_corr = np.full((num_elements, self.N), c)\n\n    def run_simulation(self):\n        \"\"\"Executes the time-stepping loop and returns final errors.\"\"\"\n        num_steps = int(round(self.T / self.dt))\n        for n in range(num_steps):\n            t = n * self.dt\n            for e in range(self.num_elements):\n                elem = self.elements[e]\n                M_J = elem.get_mass_matrix(t)\n                R_uncorr, R_corr = elem.get_residuals(t)\n                M_J_inv = np.linalg.inv(M_J)\n                \n                # Forward Euler Step\n                self.U_uncorr[e, :] -= self.dt * (M_J_inv @ R_uncorr)\n                self.U_corr[e, :] -= self.dt * (M_J_inv @ R_corr)\n        \n        t_final = num_steps * self.dt\n        err_uncorr = self._calculate_final_error(self.U_uncorr, t_final)\n        err_corr = self._calculate_final_error(self.U_corr, t_final)\n        \n        return err_uncorr, err_corr\n\n    def _calculate_final_error(self, U_final, t_final):\n        \"\"\"Calculates the root-mean-square error over all elements.\"\"\"\n        total_sq_err, total_volume = 0.0, 0.0\n        for e in range(self.num_elements):\n            sq_err, vol = self.elements[e].compute_element_error(U_final[e, :], t_final)\n            total_sq_err += sq_err\n            total_volume += vol\n        return np.sqrt(total_sq_err / total_volume) if total_volume > 0 else 0.0\n\ndef solve():\n    \"\"\"Sets up and runs the test cases.\"\"\"\n    test_cases = [\n        {\n            \"p\": 4, \"T\": 1.0, \"dt\": 1e-2, \"c\": 2.0, \"num_elements\": 2,\n            \"quad_orders\": (6, 3, 10, 10),\n            \"mappings\": [\n                {\n                    'A': lambda t: 0.3*np.sin(1.5*t), 'Ad': lambda t: 0.3*1.5*np.cos(1.5*t),\n                    'B': lambda t: 1 + 0.2*np.sin(2*t), 'Bd': lambda t: 0.2*2*np.cos(2*t),\n                    'C': lambda t: 0.1*np.cos(t), 'Cd': lambda t: -0.1*np.sin(t),\n                    'D': lambda t: 0.05*np.sin(3*t), 'Dd': lambda t: 0.05*3*np.cos(3*t),\n                },\n                {\n                    'A': lambda t: 0.25*np.sin(1.3*t), 'Ad': lambda t: 0.25*1.3*np.cos(1.3*t),\n                    'B': lambda t: 1 + 0.15*np.sin(1.7*t), 'Bd': lambda t: 0.15*1.7*np.cos(1.7*t),\n                    'C': lambda t: 0.08*np.cos(0.9*t), 'Cd': lambda t: -0.08*0.9*np.sin(0.9*t),\n                    'D': lambda t: 0.04*np.sin(2.5*t), 'Dd': lambda t: 0.04*2.5*np.cos(2.5*t),\n                }\n            ]\n        },\n        {\n            \"p\": 4, \"T\": 1.0, \"dt\": 1e-2, \"c\": 2.0, \"num_elements\": 2,\n            \"quad_orders\": (6, 3, 10, 10),\n            \"mappings\": [\n                {\n                    'A': lambda t: 0.0, 'Ad': lambda t: 0.0, 'B': lambda t: 1.0, 'Bd': lambda t: 0.0,\n                    'C': lambda t: 0.0, 'Cd': lambda t: 0.0, 'D': lambda t: 0.0, 'Dd': lambda t: 0.0,\n                },\n                {\n                    'A': lambda t: 0.0, 'Ad': lambda t: 0.0, 'B': lambda t: 1.0, 'Bd': lambda t: 0.0,\n                    'C': lambda t: 0.0, 'Cd': lambda t: 0.0, 'D': lambda t: 0.0, 'Dd': lambda t: 0.0,\n                }\n            ]\n        },\n        {\n            \"p\": 4, \"T\": 1.0, \"dt\": 5e-2, \"c\": 2.0, \"num_elements\": 2,\n            \"quad_orders\": (6, 2, 16, 16),\n            \"mappings\": [\n                {\n                    'A': lambda t: 0.3*np.sin(1.8*t), 'Ad': lambda t: 0.3*1.8*np.cos(1.8*t),\n                    'B': lambda t: 1 + 0.25*np.sin(2.2*t), 'Bd': lambda t: 0.25*2.2*np.cos(2.2*t),\n                    'C': lambda t: 0.3*np.cos(1.1*t), 'Cd': lambda t: -0.3*1.1*np.sin(1.1*t),\n                    'D': lambda t: 0.2*np.sin(3.1*t), 'Dd': lambda t: 0.2*3.1*np.cos(3.1*t),\n                },\n                {\n                    'A': lambda t: 0.28*np.sin(1.4*t), 'Ad': lambda t: 0.28*1.4*np.cos(1.4*t),\n                    'B': lambda t: 1 + 0.22*np.sin(1.9*t), 'Bd': lambda t: 0.22*1.9*np.cos(1.9*t),\n                    'C': lambda t: 0.27*np.cos(0.95*t), 'Cd': lambda t: -0.27*0.95*np.sin(0.95*t),\n                    'D': lambda t: 0.18*np.sin(2.7*t), 'Dd': lambda t: 0.18*2.7*np.cos(2.7*t),\n                }\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        solver = DGSolver(\n            p=case[\"p\"], num_elements=case[\"num_elements\"], T=case[\"T\"],\n            dt=case[\"dt\"], c=case[\"c\"], all_mappings_coeffs=case[\"mappings\"],\n            quad_orders=case[\"quad_orders\"]\n        )\n        err_uncorr, err_corr = solver.run_simulation()\n        results.extend([err_uncorr, err_corr])\n    \n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A complete ALE simulation often involves two stages: a Lagrangian evolution step and a remapping step to transfer the solution onto a new mesh. This exercise focuses on the remapping stage, where simple methods can be overly diffusive. You will implement an advanced remapping technique based on constrained optimization, which enforces the conservation of not just mass (the $k=0$ moment) but also higher-order moments ($k=1, 2$) of the solution. By implementing this approach, you will learn how to actively combat numerical diffusion and better preserve the shape of complex solution features during the remapping process. ",
            "id": "3423581",
            "problem": "Consider a one-dimensional Arbitrary Lagrangian-Eulerian (ALE) remapping step on the domain $\\Omega = [0,1]$. Let the old mesh be a uniform partition with $N$ cells and edges $x_i^{\\mathrm{old}} = i/N$ for $i = 0,\\dots,N$. Let the new mesh be defined by a smooth, strictly monotone mesh mapping $\\chi(\\xi) = \\xi + \\frac{\\alpha}{2\\pi}\\sin(2\\pi \\xi)$, applied to the same reference edge coordinates $\\xi_i = i/N$ so that $x_i^{\\mathrm{new}} = \\chi(\\xi_i)$ for $i=0,\\dots,N$. Assume $0 \\le \\alpha  1$ so that $\\chi$ is invertible and the mesh does not fold.\n\nYou are given a scalar field $u(x)$ on $\\Omega$. On the old mesh, define the cell-averaged piecewise-constant representation by $u_i^{\\mathrm{old}} = \\frac{1}{|C_i^{\\mathrm{old}}|}\\int_{C_i^{\\mathrm{old}}} u(x)\\,\\mathrm{d}x$, where $C_i^{\\mathrm{old}} = [x_{i-1}^{\\mathrm{old}}, x_i^{\\mathrm{old}}]$ and $|C_i^{\\mathrm{old}}|$ is its length. A conservative overlap (donor-cell) remap from the old mesh to the new mesh is defined by\n$$\nu_j^{\\mathrm{ovlp}} = \\frac{1}{|C_j^{\\mathrm{new}}|}\\sum_{i=1}^{N} \\left|C_i^{\\mathrm{old}} \\cap C_j^{\\mathrm{new}}\\right|\\, u_i^{\\mathrm{old}},\n$$\nwhere $C_j^{\\mathrm{new}} = [x_{j-1}^{\\mathrm{new}}, x_j^{\\mathrm{new}}]$. This overlap remap exactly preserves total mass.\n\nTo reduce numerical diffusion while enforcing conservation and geometric consistency, develop a constrained optimization-based remapping that selects new cell values $u_j^{\\mathrm{new}}$ by solving\n$$\n\\min_{\\{u_j\\}_{j=1}^N} \\;\\; \\frac{1}{2}\\sum_{j=1}^N |C_j^{\\mathrm{new}}|\\left(u_j - u_j^{\\mathrm{ovlp}}\\right)^2\n$$\nsubject to the linear equality constraints\n$$\n\\sum_{j=1}^{N} u_j \\int_{C_j^{\\mathrm{new}}} x^k\\,\\mathrm{d}x \\;=\\; \\sum_{i=1}^{N} u_i^{\\mathrm{old}} \\int_{C_i^{\\mathrm{old}}} x^k\\,\\mathrm{d}x, \\quad k = 0,1,2.\n$$\nThe constraint for $k=0$ enforces mass conservation, and the constraints for $k=1,2$ enforce preservation of the first two higher moments of the piecewise-constant old solution. The integrals $\\int_{[a,b]} x^k \\,\\mathrm{d}x$ are to be evaluated exactly in one dimension using the formula $\\int_a^b x^k\\,\\mathrm{d}x = \\frac{b^{k+1}-a^{k+1}}{k+1}$.\n\nDefine the numerical diffusion metric as the relative loss of the discrete $L^2$ energy across the remap,\n$$\n\\mathcal{D}(u^{\\mathrm{old}}\\to u^{\\star}) \\;=\\; \\frac{\\int_{\\Omega} \\left(u^{\\mathrm{pc,old}}(x)\\right)^2 \\,\\mathrm{d}x - \\int_{\\Omega} \\left(u^{\\mathrm{pc,\\star}}(x)\\right)^2 \\,\\mathrm{d}x}{\\int_{\\Omega} \\left(u^{\\mathrm{pc,old}}(x)\\right)^2 \\,\\mathrm{d}x},\n$$\nwhere $u^{\\mathrm{pc,old}}$ is the piecewise-constant function taking value $u_i^{\\mathrm{old}}$ on $C_i^{\\mathrm{old}}$, and $u^{\\mathrm{pc,\\star}}$ is the piecewise-constant function on the new mesh with cell values $u_j^{\\star}$, with $\\star \\in \\{\\mathrm{ovlp}, \\mathrm{new}\\}$ corresponding to the overlap remap and the optimized remap, respectively. The discrete integrals are computed exactly for piecewise-constant fields via $\\int_{C} (u^{\\mathrm{pc}})^2 \\,\\mathrm{d}x = |C|\\,u^2$ and summed over cells.\n\nYour program must:\n- Assemble $u_i^{\\mathrm{old}}$ by accurate numerical quadrature of $\\int_{C_i^{\\mathrm{old}}} u(x)\\,\\mathrm{d}x$ and division by $|C_i^{\\mathrm{old}}|$.\n- Construct the conservative overlap remap $u_j^{\\mathrm{ovlp}}$ using interval overlap lengths.\n- Solve the quadratic program with linear equality constraints above (with $k=0,1,2$) using the Karush-Kuhn-Tucker optimality conditions to obtain $u_j^{\\mathrm{new}}$.\n- Compute the absolute mass error for the optimized remap, $E_{\\mathrm{mass}} = \\left|\\sum_j |C_j^{\\mathrm{new}}|\\,u_j^{\\mathrm{new}} - \\sum_i |C_i^{\\mathrm{old}}|\\,u_i^{\\mathrm{old}}\\right|$.\n- Compute the normalized diffusion reduction achieved by the optimization relative to the overlap baseline,\n$$\nR = \\mathcal{D}(u^{\\mathrm{old}}\\to u^{\\mathrm{ovlp}}) - \\mathcal{D}(u^{\\mathrm{old}}\\to u^{\\mathrm{new}}).\n$$\n\nUse $N = 200$ cells. Use Gaussian-Legendre quadrature with at least $4$ points per old cell to compute $\\int_{C_i^{\\mathrm{old}}} u(x)\\,\\mathrm{d}x$. Use the mesh mapping parameter $\\alpha$ and initial data $u(x)$ as specified in the test suite below.\n\nTest Suite:\n- Case $1$: $u(x) \\equiv 1$ (uniform), $\\alpha = 0.4$.\n- Case $2$: $u(x) = \\exp\\!\\left(-\\left(\\frac{x - 0.3}{0.05}\\right)^2\\right)$ (smooth Gaussian), $\\alpha = 0.1$.\n- Case $3$: $u(x) = \\exp\\!\\left(-\\left(\\frac{x - 0.3}{0.05}\\right)^2\\right)$ (smooth Gaussian), $\\alpha = 0.4$.\n- Case $4$: $u(x) = 1$ on $[0.25,0.45]$ and $u(x) = 0$ otherwise (discontinuous square pulse), $\\alpha = 0.1$.\n- Case $5$: $u(x) = 1$ on $[0.25,0.45]$ and $u(x) = 0$ otherwise (discontinuous square pulse), $\\alpha = 0.4$.\n\nFor each case, output two numbers:\n- The absolute mass error $E_{\\mathrm{mass}}$ for the optimized remap.\n- The normalized diffusion reduction $R$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[E_{\\mathrm{mass}}^{(1)}, R^{(1)}, E_{\\mathrm{mass}}^{(2)}, R^{(2)}, \\dots, E_{\\mathrm{mass}}^{(5)}, R^{(5)}]$ for the five cases listed above.\n- Each number must be rounded to $8$ decimal places.\n- No other text should be printed.",
            "solution": "The problem requires the development and analysis of a constrained optimization-based remapping scheme for an Arbitrary Lagrangian-Eulerian (ALE) numerical method. The goal is to remap a scalar field, represented as piecewise-constant cell averages on an old mesh, onto a new, distorted mesh. The optimization seeks to find new cell-average values $u_j^{\\mathrm{new}}$ that are minimally different in a weighted $L^2$ sense from a simple, diffusive first-order overlap remap, while simultaneously enforcing conservation of mass and the first two spatial moments of the field.\n\nThe problem is formulated as a quadratic program with linear equality constraints (QP-LEC). Let $\\mathbf{u} = (u_1, \\dots, u_N)^T$ be the vector of unknown cell averages on the new mesh $\\{C_j^{\\mathrm{new}}\\}_{j=1}^N$. The objective is to minimize the function:\n$$\nJ(\\mathbf{u}) = \\frac{1}{2}\\sum_{j=1}^N |C_j^{\\mathrm{new}}|\\left(u_j - u_j^{\\mathrm{ovlp}}\\right)^2\n$$\nwhere $u_j^{\\mathrm{ovlp}}$ are the cell averages from the first-order overlap (donor-cell) remap. This objective can be written in matrix form as $J(\\mathbf{u}) = \\frac{1}{2}(\\mathbf{u} - \\mathbf{u}_{\\mathrm{ovlp}})^T W (\\mathbf{u} - \\mathbf{u}_{\\mathrm{ovlp}})$, where $W$ is a diagonal matrix with entries $W_{jj} = |C_j^{\\mathrm{new}}|$.\n\nThe minimization is subject to three linear equality constraints corresponding to the conservation of the zeroth, first, and second moments of the solution:\n$$\n\\sum_{j=1}^{N} u_j \\int_{C_j^{\\mathrm{new}}} x^k\\,\\mathrm{d}x = \\sum_{i=1}^{N} u_i^{\\mathrm{old}} \\int_{C_i^{\\mathrm{old}}} x^k\\,\\mathrm{d}x, \\quad \\text{for } k = 0,1,2.\n$$\nLet $M_{j,k} = \\int_{C_j^{\\mathrm{new}}} x^k\\,\\mathrm{d}x$ and $d_k = \\sum_{i=1}^{N} u_i^{\\mathrm{old}} \\int_{C_i^{\\mathrm{old}}} x^k\\,\\mathrm{d}x$. We can express the constraints in matrix form as $A\\mathbf{u} = \\mathbf{d}$, where $A$ is a $3 \\times N$ matrix with entries $A_{kj} = M_{j,k}$ and $\\mathbf{d}$ is a $3 \\times 1$ vector of the target total moments.\n\nThis QP-LEC problem is solved using the method of Lagrange multipliers. The Lagrangian is:\n$$\n\\mathcal{L}(\\mathbf{u}, \\boldsymbol{\\lambda}) = J(\\mathbf{u}) + \\boldsymbol{\\lambda}^T (A\\mathbf{u} - \\mathbf{d})\n$$\nwhere $\\boldsymbol{\\lambda} = (\\lambda_0, \\lambda_1, \\lambda_2)^T$ is the vector of Lagrange multipliers. The Karush-Kuhn-Tucker (KKT) optimality conditions are found by setting the gradients of $\\mathcal{L}$ to zero:\n$$\n\\nabla_{\\mathbf{u}}\\mathcal{L} = W(\\mathbf{u} - \\mathbf{u}_{\\mathrm{ovlp}}) + A^T \\boldsymbol{\\lambda} = \\mathbf{0}\n$$\n$$\n\\nabla_{\\boldsymbol{\\lambda}}\\mathcal{L} = A\\mathbf{u} - \\mathbf{d} = \\mathbf{0}\n$$\nFrom the first equation, we can express the optimal solution $\\mathbf{u}$ in terms of the unknown multipliers $\\boldsymbol{\\lambda}$:\n$$\n\\mathbf{u} = \\mathbf{u}_{\\mathrm{ovlp}} - W^{-1}A^T\\boldsymbol{\\lambda}\n$$\nThis equation shows that the optimized solution is a correction to the first-order overlap solution. The correction is a linear combination of the moment basis functions, weighted by the Lagrange multipliers. Substituting this expression for $\\mathbf{u}$ into the constraint equation yields:\n$$\nA(\\mathbf{u}_{\\mathrm{ovlp}} - W^{-1}A^T\\boldsymbol{\\lambda}) = \\mathbf{d}\n$$\nRearranging gives a $3 \\times 3$ linear system for $\\boldsymbol{\\lambda}$, known as the Schur complement system:\n$$\n(AW^{-1}A^T)\\boldsymbol{\\lambda} = A\\mathbf{u}_{\\mathrm{ovlp}} - \\mathbf{d}\n$$\nThe implementation proceeds as follows:\n1.  **Setup**: The old mesh $\\{C_i^{\\mathrm{old}}\\}$ and new mesh $\\{C_j^{\\mathrm{new}}\\}$ are constructed. Cell-averaged old data $u_i^{\\mathrm{old}}$ are computed using Gaussian-Legendre quadrature for smooth initial functions and exact analytical integration for the discontinuous pulse.\n2.  **Overlap Remap**: The first-order values $u_j^{\\mathrm{ovlp}}$ are calculated by determining the intersection lengths $|C_i^{\\mathrm{old}} \\cap C_j^{\\mathrm{new}}|$ and performing the weighted sum.\n3.  **Optimization**: The moment integrals $M_{j,k}$ and $d_k$ are computed. The $3 \\times 3$ matrix $H=AW^{-1}A^T$ and the right-hand side vector $\\mathbf{b} = A\\mathbf{u}_{\\mathrm{ovlp}} - \\mathbf{d}$ are assembled. The system $H\\boldsymbol{\\lambda}=\\mathbf{b}$ is solved for $\\boldsymbol{\\lambda}$. The final solution $\\mathbf{u}_{\\mathrm{new}}$ is then computed by applying the correction to $\\mathbf{u}_{\\mathrm{ovlp}}$.\n4.  **Analysis**: The absolute mass error $E_{\\mathrm{mass}} = |\\text{mass}_{\\mathrm{new}} - \\text{mass}_{\\mathrm{old}}|$ is calculated to verify a core constraint. The diffusion reduction $R = \\mathcal{D}_{\\mathrm{ovlp}} - \\mathcal{D}_{\\mathrm{new}}$ is computed to quantify the improvement. This simplifies to $R = (\\text{Energy}_{\\mathrm{new}} - \\text{Energy}_{\\mathrm{ovlp}}) / \\text{Energy}_{\\mathrm{old}}$, where energy is the discrete $L^2$ norm squared. A positive $R$ signifies that the optimization successfully restored some of the energy lost to numerical diffusion in the first-order remap.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import fixed_quad\n\ndef run_case(u_func, alpha, is_discontinuous):\n    \"\"\"\n    Executes the remapping and analysis for a single test case.\n\n    Args:\n        u_func (callable): The initial scalar field u(x).\n        alpha (float): The mesh mapping parameter.\n        is_discontinuous (bool): Flag for the discontinuous pulse case.\n\n    Returns:\n        tuple: A tuple containing the absolute mass error (E_mass) and the\n               normalized diffusion reduction (R).\n    \"\"\"\n    N = 200\n    N_QUAD_POINTS = 5\n\n    # --- 1. Mesh and Initial Data Generation ---\n    # Old mesh is a uniform partition of [0, 1]\n    x_old = np.linspace(0, 1, N + 1)\n    C_old_len = 1.0 / N\n\n    # New mesh is created by applying the chi mapping to an underlying uniform grid\n    xi = np.linspace(0, 1, N + 1)\n    def chi(xi_vals):\n        return xi_vals + (alpha / (2 * np.pi)) * np.sin(2 * np.pi * xi_vals)\n    x_new = chi(xi)\n    C_new_len = np.diff(x_new)\n\n    # --- 2. Compute old cell averages u_old ---\n    u_old = np.zeros(N)\n    if is_discontinuous:\n        # For the square pulse, integrate analytically for exact u_old\n        pulse_start, pulse_end = 0.25, 0.45\n        for i in range(N):\n            cell_start, cell_end = x_old[i], x_old[i + 1]\n            intersect_start = max(cell_start, pulse_start)\n            intersect_end = min(cell_end, pulse_end)\n            intersect_len = max(0, intersect_end - intersect_start)\n            u_old[i] = intersect_len / C_old_len if C_old_len > 0 else 0.0\n    else:\n        # For smooth functions, use Gaussian-Legendre quadrature\n        for i in range(N):\n            integral_u, _ = fixed_quad(u_func, x_old[i], x_old[i + 1], n=N_QUAD_POINTS)\n            u_old[i] = integral_u / C_old_len if C_old_len > 0 else 0.0\n\n    # --- 3. Compute overlap remap u_ovlp ---\n    # Intersection matrix stores |C_i^old intersect C_j^new|\n    # rows: old cells (i), cols: new cells (j)\n    intersection_matrix = np.zeros((N, N))\n    for i in range(N):\n        for j in range(N):\n            intersect_start = max(x_old[i], x_new[j])\n            intersect_end = min(x_old[i + 1], x_new[j + 1])\n            intersection_matrix[i, j] = max(0, intersect_end - intersect_start)\n            \n    # u_j^ovlp = (1/|C_j^new|) * sum_i |C_i^old intersect C_j^new| * u_i^old\n    u_ovlp_numerator = np.dot(intersection_matrix.T, u_old)\n    u_ovlp = np.divide(u_ovlp_numerator, C_new_len, out=np.zeros_like(C_new_len), where=C_new_len!=0)\n\n    # --- 4. Solve the Constrained Optimization Problem ---\n    def moment_integral(a, b, k):\n        return (b**(k + 1) - a**(k + 1)) / (k + 1)\n\n    # A_kj = moment_k on new cell j; m_ki = moment_k on old cell i\n    A = np.zeros((3, N))\n    m = np.zeros((3, N))\n    for k in range(3):\n        for j in range(N):\n            A[k, j] = moment_integral(x_new[j], x_new[j + 1], k)\n        for i in range(N):\n            m[k, i] = moment_integral(x_old[i], x_old[i + 1], k)\n            \n    # RHS of constraints: d_k = sum_i u_i^old * m_ik\n    d = np.array([np.dot(u_old, m[k, :]) for k in range(3)])\n\n    # Assemble and solve the 3x3 system for Lagrange multipliers lambda\n    # H = A * diag(1/|C_new|) * A.T\n    H = np.zeros((3, 3))\n    for k in range(3):\n        for l in range(3):\n            H[k, l] = np.sum(A[k, :] * A[l, :] / C_new_len)\n    \n    # b = A * u_ovlp - d\n    b = np.dot(A, u_ovlp) - d\n    \n    lambdas = np.linalg.solve(H, b)\n\n    # Compute the final optimized solution u_new\n    # u_new = u_ovlp - W^-1 * A.T * lambdas\n    correction = np.dot(A.T, lambdas) / C_new_len\n    u_new = u_ovlp - correction\n\n    # --- 5. Compute Output Metrics ---\n    # Mass Error E_mass\n    mass_old_total = d[0]\n    mass_new_total = np.sum(u_new * C_new_len)\n    E_mass = np.abs(mass_new_total - mass_old_total)\n\n    # Diffusion Reduction R\n    energy_old = np.sum(u_old**2 * C_old_len)\n    \n    if energy_old  1e-15:\n        R = 0.0\n    else:\n        energy_ovlp = np.sum(u_ovlp**2 * C_new_len)\n        energy_new = np.sum(u_new**2 * C_new_len)\n        # R = (D_ovlp - D_new) = ((E_old - E_ovlp)/E_old) - ((E_old - E_new)/E_old)\n        R = (energy_new - energy_ovlp) / energy_old\n        \n    return E_mass, R\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the results.\n    \"\"\"\n    \n    test_cases = [\n        (lambda x: np.ones_like(x, dtype=float), 0.4, False), # Case 1\n        (lambda x: np.exp(-((x - 0.3) / 0.05)**2), 0.1, False), # Case 2\n        (lambda x: np.exp(-((x - 0.3) / 0.05)**2), 0.4, False), # Case 3\n        (lambda x: np.where((x >= 0.25)  (x = 0.45), 1.0, 0.0), 0.1, True), # Case 4\n        (lambda x: np.where((x >= 0.25)  (x = 0.45), 1.0, 0.0), 0.4, True), # Case 5\n    ]\n\n    results = []\n    for u_func, alpha, is_discontinuous in test_cases:\n        E_mass, R = run_case(u_func, alpha, is_discontinuous)\n        results.extend([E_mass, R])\n\n    # Format the final output string as specified\n    formatted_results = [f\"{val:.8f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}