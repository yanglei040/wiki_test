{
    "hands_on_practices": [
        {
            "introduction": "To build reliable numerical schemes on moving domains, we must first ensure they can correctly handle the most basic case: a uniform flow. This foundational exercise  takes you to the heart of this requirement by asking you to derive the discrete Geometric Conservation Law (GCL) for a one-dimensional finite volume scheme. By working through this derivation, you will uncover the precise mathematical condition linking the time integration of mesh velocities to the scheme's ability to exactly preserve a constant state, a non-negotiable property for any valid Arbitrary Lagrangian-Eulerian (ALE) method.",
            "id": "3423641",
            "problem": "Consider the one-dimensional conservation law $\\partial_{t} u + \\partial_{x} f(u) = 0$ on a moving interval $K(t) = [x_{L}(t), x_{R}(t)]$. Let the Arbitrary Lagrangian-Eulerian (ALE) map be linear in the reference coordinate $\\xi \\in [0,1]$, given by $x(\\xi,t) = x_{L}(t) + \\big(x_{R}(t) - x_{L}(t)\\big)\\,\\xi$. Define the face velocities by $w_{L}(t) = \\partial_{t} x_{L}(t)$ and $w_{R}(t) = \\partial_{t} x_{R}(t)$, and let the cell volume be $V(t) = x_{R}(t) - x_{L}(t)$. Consider one time step from $t^{n}$ to $t^{n+1}$ with $\\Delta t = t^{n+1} - t^{n}$.\n\nA second-order finite volume scheme is constructed from a space–time control volume over $[t^{n}, t^{n+1}]$ and approximates the space–time flux of mesh advection across each spatial face by a two-point time approximation of the form\n$$\nw_{\\star}^{\\text{disc}} = \\theta\\, w_{\\star}^{n+1} + (1 - \\theta)\\, w_{\\star}^{n},\n$$\nwhere $\\star \\in \\{L, R\\}$ denotes the left or right face, and $w_{\\star}^{n} = w_{\\star}(t^{n})$, $w_{\\star}^{n+1} = w_{\\star}(t^{n+1})$. The same time discretization is used for both faces, with the same unknown weight $\\theta \\in \\mathbb{R}$.\n\nThe Geometric Conservation Law (GCL) requires that a spatially uniform solution $u(x,t) \\equiv u_{0}$ be preserved exactly by the fully discrete scheme. Assume that each face trajectory is linear in time over the step, i.e., $x_{\\star}(t)$ is an affine function of $t$ on $[t^{n}, t^{n+1}]$. Under these assumptions, enforce the discrete GCL for the above space–time finite volume formulation and determine the unique value of the weight $\\theta$ that guarantees exact preservation of $u(x,t) \\equiv u_{0}$ for arbitrary $u_{0}$ and arbitrary linear-in-time face motions over the step.\n\nYour final answer must be the value of $\\theta$ as a single number. No units are required, and no rounding is needed.",
            "solution": "The problem requires finding the unique value of a weight $\\theta$ in a semi-discrete finite volume scheme that guarantees the Geometric Conservation Law (GCL) is satisfied. The GCL ensures that a uniform state $u(x,t) = u_0$ is preserved exactly by the numerical scheme on a moving mesh.\n\nThe one-dimensional conservation law is given by\n$$\n\\partial_{t} u + \\partial_{x} f(u) = 0\n$$\non a moving cell $K(t) = [x_L(t), x_R(t)]$.\n\nLet's start by formulating the exact integral form of the conservation law over the space-time control volume defined by the cell $K(t)$ moving from time $t^n$ to $t^{n+1}$. Using the Leibniz integral rule (or Reynolds transport theorem in one dimension), the time evolution of the integral of $u$ over $K(t)$ is:\n$$\n\\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} u(x,t) \\,dx = \\int_{x_L(t)}^{x_R(t)} \\partial_t u \\,dx + u(x_R(t), t) \\frac{dx_R}{dt} - u(x_L(t), t) \\frac{dx_L}{dt}\n$$\nSubstituting $\\partial_t u = -\\partial_x f(u)$ and the definitions of the face velocities $w_L(t) = \\partial_t x_L(t)$ and $w_R(t) = \\partial_t x_R(t)$:\n$$\n\\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} u \\,dx = \\int_{x_L(t)}^{x_R(t)} (-\\partial_x f(u)) \\,dx + u_R w_R - u_L w_L\n$$\n$$\n\\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} u \\,dx = -[f(u_R) - f(u_L)] + u_R w_R - u_L w_L\n$$\nwhere $u_L = u(x_L(t), t)$ and $u_R = u(x_R(t), t)$. This is the Arbitrary Lagrangian-Eulerian (ALE) form of the conservation law.\n\nThe GCL is a condition on the numerical scheme's handling of geometry. It is derived by considering the case of a uniform flow, $u(x,t) = u_0$, where $u_0$ is a constant. In this case, $f(u) = f(u_0)$ is also constant, so $\\partial_x f(u) = 0$. The ALE form becomes:\n$$\n\\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} u_0 \\,dx = u_0 w_R - u_0 w_L\n$$\nSince $u_0$ is constant, we can factor it out:\n$$\nu_0 \\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} 1 \\,dx = u_0 (w_R - w_L)\n$$\nThe integral is the volume (length) of the cell, $V(t) = x_R(t) - x_L(t)$. So, we have:\n$$\nu_0 \\frac{dV(t)}{dt} = u_0 (w_R - w_L)\n$$\nSince $\\frac{dV}{dt} = \\frac{d}{dt}(x_R - x_L) = w_R - w_L$, this equation is an identity. Now, we integrate this identity over the time step $[t^n, t^{n+1}]$:\n$$\n\\int_{t^n}^{t^{n+1}} \\frac{dV(t)}{dt} \\,dt = \\int_{t^n}^{t^{n+1}} (w_R(t) - w_L(t)) \\,dt\n$$\n$$\nV(t^{n+1}) - V(t^n) = \\int_{t^n}^{t^{n+1}} w_R(t) \\,dt - \\int_{t^n}^{t^{n+1}} w_L(t) \\,dt\n$$\nLetting $V^n = V(t^n)$, this is the exact integral form of the GCL:\n$$\nV^{n+1} - V^{n} = \\int_{t^n}^{t^{n+1}} (w_R(t) - w_L(t)) \\,dt\n$$\nThe discrete scheme must satisfy this geometric relation exactly.\n\nThe problem requires finding a unique $\\theta$ for a scheme described as \"second-order\". For the temporal discretization to be second-order accurate, the quadrature rule used to approximate time integrals must be exact for integrands that are at least linear in time. The condition for \"arbitrary linear-in-time face motions\" implies constant face velocities, for which any $\\theta$ works, contradicting the search for a unique value. A more robust interpretation consistent with a second-order scheme is to require the GCL to hold for arbitrary motions where face velocities $w_\\star(t)$ are *linear* functions of time (corresponding to quadratic trajectories $x_\\star(t)$). This ensures the scheme handles accelerating grid motion correctly.\n\nLet $g(t) = w_R(t) - w_L(t)$. If the face velocities are linear in time, so is $g(t)$. For any function $g(t)$ that is linear in time, the exact value of its integral over $[t^n, t^{n+1}]$ is given by the trapezoidal rule:\n$$\n\\int_{t^n}^{t^{n+1}} g(t) \\,dt = \\frac{g(t^n) + g(t^{n+1})}{2} \\Delta t\n$$\nThus, the time-averaged value is:\n$$\n\\frac{1}{\\Delta t} \\int_{t^n}^{t^{n+1}} g(t) \\,dt = \\frac{g(t^n) + g(t^{n+1})}{2}\n$$\nThe discrete GCL from the scheme is $\\frac{V^{n+1} - V^n}{\\Delta t} = w_R^{\\text{disc}} - w_L^{\\text{disc}}$. For the scheme to satisfy the GCL, its representation of the net velocity flux must match the exact time-averaged flux.\n$$\nw_R^{\\text{disc}} - w_L^{\\text{disc}} = \\frac{1}{\\Delta t} \\int_{t^n}^{t^{n+1}} (w_R(t) - w_L(t)) \\,dt\n$$\nSubstituting the definition of $w^{\\text{disc}}$ and the exact integral for linear velocity profiles:\n$$\n\\theta(w_R^{n+1} - w_L^{n+1}) + (1-\\theta)(w_R^n - w_L^n) = \\frac{(w_R^{n+1} - w_L^{n+1}) + (w_R^n - w_L^n)}{2}\n$$\nLet $G^{n+1} = w_R^{n+1} - w_L^{n+1}$ and $G^n = w_R^n - w_L^n$. The equation becomes:\n$$\n\\theta G^{n+1} + (1-\\theta) G^n = \\frac{1}{2} G^{n+1} + \\frac{1}{2} G^n\n$$\nThis equation must hold for any arbitrary linear velocity profiles, which means it must hold for any choice of $G^n$ and $G^{n+1}$.\nCollecting terms:\n$$\n\\left(\\theta - \\frac{1}{2}\\right) G^{n+1} + \\left(1 - \\theta - \\frac{1}{2}\\right) G^n = 0\n$$\n$$\n\\left(\\theta - \\frac{1}{2}\\right) G^{n+1} + \\left(\\frac{1}{2} - \\theta\\right) G^n = 0\n$$\n$$\n\\left(\\theta - \\frac{1}{2}\\right) (G^{n+1} - G^n) = 0\n$$\nSince this relation must be satisfied for *arbitrary* linear velocity profiles, we can choose a motion for which $G^{n+1} \\neq G^n$ (e.g., a cell that is accelerating its expansion). For the equation to hold in such general cases, the coefficient must be zero:\n$$\n\\theta - \\frac{1}{2} = 0\n$$\nThis determines the unique value of the weight:\n$$\n\\theta = \\frac{1}{2}\n$$\nThis value corresponds to the Crank-Nicolson method (or trapezoidal rule), which is consistent with the requirement of constructing a second-order scheme.",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "Moving from foundational principles to high-order methods introduces new complexities. In advanced frameworks like the Discontinuous Galerkin (DG) method, maintaining accuracy requires a careful balancing act between the polynomial degree of the solution, the complexity of the mesh motion, and the precision of numerical integration. This practice  provides a quantitative toolkit to explore these trade-offs, asking you to analyze how choices in quadrature rules and the temporal treatment of geometric terms can impact, and even degrade, the formal order of accuracy.",
            "id": "3423615",
            "problem": "Consider a one-dimensional Arbitrary Lagrangian-Eulerian (ALE) formulation of a linear scalar conservation law discretized by a Discontinuous Galerkin (DG) method. Let the reference coordinate be $X$ and the physical coordinate be $x(X,t)$. Define the Jacobian of the mapping as $J(X,t) = \\partial x / \\partial X$ and the grid velocity as $w(X,t) = \\partial x / \\partial t$. The conservative ALE form of the partial differential equation is\n$$\n\\partial_t \\big(J\\,u\\big) + \\partial_X \\big(F(u) - u\\,w\\big) = 0,\n$$\nwhere $u(X,t)$ is the reference-space solution and $F(u)$ is the physical flux. Assume a linear flux $F(u) = c\\,u$ with constant speed $c \\in \\mathbb{R}$, which does not affect polynomial degrees in the analysis when $c$ is nonzero. The DG discretization uses element-wise polynomials of degree $p$ for the trial and test functions, and volume and surface integrals are evaluated by Gauss-Legendre quadrature with $N_v$ points for volume integrals and $N_s$ points for surface integrals.\n\nAssume that along each element the Jacobian $J(X,t)$ is a polynomial of degree $q_J$ in $X$, and the grid velocity $w(X,t)$ is a polynomial of degree $q_w$ in $X$. Consider a $r$-th order accurate explicit Runge-Kutta time integrator. The mesh is smoothly deforming, meaning $J$ and $w$ are sufficiently differentiable in time and space.\n\nFrom first principles, the DG weak form implies the following integrands:\n- The volume term involves products of the form $J\\,u\\,v$ where $u$ and $v$ are degree-$p$ polynomials. The polynomial degree of the volume integrand is $D_v = 2p + q_J$.\n- The surface term involves $F(u) - u\\,w$, multiplied by the test function trace at element boundaries; for polynomial degree counting of the integrand on faces in one dimension, one may bound the degree by $D_s = p + q_w$ when $F$ is linear.\n\nGauss-Legendre quadrature with $N$ points integrates polynomials of degree up to $2N - 1$ exactly. To maintain $p$-th order spatial accuracy, exact integration of the weak-form polynomials is required. Therefore, minimal quadrature point counts that guarantee exactness are\n$$\nN_v^{\\min} = \\left\\lceil \\frac{D_v + 1}{2} \\right\\rceil = \\left\\lceil \\frac{2p + q_J + 1}{2} \\right\\rceil,\\quad\nN_s^{\\min} = \\left\\lceil \\frac{D_s + 1}{2} \\right\\rceil = \\left\\lceil \\frac{p + q_w + 1}{2} \\right\\rceil.\n$$\n\nWhen the chosen quadrature counts $N_v$ and $N_s$ are lower than the minimal values required for exactness, the guaranteed spatial accuracy is limited by the exactness degrees:\n- For the volume term, exactness up to degree $2N_v - 1$ implies a maximal trial degree $p_v^{\\mathrm{eff}}$ satisfying $2p_v^{\\mathrm{eff}} + q_J \\le 2N_v - 1$, yielding\n$$\np_v^{\\mathrm{eff}} = \\min\\!\\left(p,\\, \\left\\lfloor \\frac{2N_v - 1 - q_J}{2} \\right\\rfloor \\right),\n$$\nwith the convention that negative values are clamped to $0$.\n- For the surface term, exactness up to degree $2N_s - 1$ implies a maximal trial degree $p_s^{\\mathrm{eff}}$ satisfying $p_s^{\\mathrm{eff}} + q_w \\le 2N_s - 1$, yielding\n$$\np_s^{\\mathrm{eff}} = \\min\\!\\left(p,\\, 2N_s - 1 - q_w \\right),\n$$\nwith the convention that negative values are clamped to $0$.\n\nA guaranteed spatial convergence order (with respect to mesh size in a smooth regime) is then\n$$\nP_{\\mathrm{space}} = \\min\\!\\big(p_v^{\\mathrm{eff}} + 1,\\; p_s^{\\mathrm{eff}} + 1\\big).\n$$\n\nFor time accuracy, the Geometric Conservation Law (GCL) requires\n$$\n\\partial_t J = \\partial_X (J\\,w),\n$$\ndiscretely to preserve constant solutions. If the metric terms ($J$ and $w$) are lagged in time, i.e., evaluated using their values from a previous time step rather than at the current Runge-Kutta stages, then the function evaluations in time are contaminated by an $\\mathcal{O}(\\Delta t)$ error arising from the missing update, which reduces the effective temporal order to first order for nontrivial mesh motion. In particular, define a mesh-motion amplitude parameter $A_w \\ge 0$ which is zero if and only if the mesh is stationary. Under full lagging of metric terms:\n- If $A_w = 0$, then $r_{\\mathrm{eff}} = r$.\n- If $A_w > 0$, then $r_{\\mathrm{eff}} = 1$.\n\nThe overall scheme order is limited by the minimum of spatial and temporal orders:\n$$\nP_{\\mathrm{total}} = \\min\\!\\big(P_{\\mathrm{space}},\\, r_{\\mathrm{eff}}\\big).\n$$\nThe temporal order loss induced by lagging is quantified by\n$$\nL_{\\mathrm{time}} = r - r_{\\mathrm{eff}}.\n$$\n\nImplement a program that, for each test case, computes the following outputs as integers:\n- $N_v^{\\min}$,\n- $N_s^{\\min}$,\n- $P_{\\mathrm{space}}$,\n- $r_{\\mathrm{eff}}$,\n- $P_{\\mathrm{total}}$,\n- $L_{\\mathrm{time}}$.\n\nUse the formulas above. For negative intermediate $p_v^{\\mathrm{eff}}$ or $p_s^{\\mathrm{eff}}$, clamp to $0$ before adding $1$ in $P_{\\mathrm{space}}$. The final output should aggregate the results for all test cases into a single line as a comma-separated list enclosed in square brackets, where each test case result is a list in the order described above.\n\nTest suite (each tuple is $(p, q_J, q_w, r, N_v, N_s, A_w)$):\n- Case $1$ (general under-integration on volume, adequate surface): $(3, 2, 2, 3, 4, 3, 0.1)$.\n- Case $2$ (stationary mesh, adequate quadrature): $(1, 1, 1, 2, 2, 2, 0.0)$.\n- Case $3$ (piecewise constants with high-degree geometry, under-integrated surface): $(0, 3, 3, 1, 2, 1, 0.5)$.\n- Case $4$ (higher $p$ with stationary mesh, under-integrated both): $(4, 1, 0, 4, 4, 2, 0.0)$.\n- Case $5$ (adequate volume, under-integrated surface with moving mesh): $(2, 0, 2, 3, 3, 2, 0.2)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$), where each $result_i$ is a list $[N_v^{\\min},N_s^{\\min},P_{\\mathrm{space}},r_{\\mathrm{eff}},P_{\\mathrm{total}},L_{\\mathrm{time}}]$ for the $i$-th test case. No physical units are required and angles are not involved; all outputs are pure integers.",
            "solution": "The objective is to compute a set of six performance and accuracy metrics for a DG-ALE numerical scheme under various parameter configurations. These metrics are: the minimum required quadrature points for volume ($N_v^{\\min}$) and surface ($N_s^{\\min}$) integrals, the effective spatial order of convergence ($P_{\\mathrm{space}}$), the effective temporal order of convergence ($r_{\\mathrm{eff}}$), the total scheme order ($P_{\\mathrm{total}}$), and the temporal order loss due to lagging ($L_{\\mathrm{time}}$).\n\nThe calculation proceeds by applying the provided formulas for each test case. Let us demonstrate the procedure with the first test case, where the parameters are $(p, q_J, q_w, r, N_v, N_s, A_w) = (3, 2, 2, 3, 4, 3, 0.1)$.\n\n1.  **Minimum Volume Quadrature Points, $N_v^{\\min}$**:\n    The polynomial degree of the volume integrand is $D_v = 2p + q_J$. For exact integration using Gauss-Legendre quadrature, the number of points $N_v$ must satisfy $2N_v - 1 \\ge D_v$. The minimal number of points is thus $N_v^{\\min} = \\lceil (D_v + 1)/2 \\rceil$.\n    $$D_v = 2(3) + 2 = 8$$\n    $$N_v^{\\min} = \\left\\lceil \\frac{8 + 1}{2} \\right\\rceil = \\lceil 4.5 \\rceil = 5$$\n\n2.  **Minimum Surface Quadrature Points, $N_s^{\\min}$**:\n    Similarly, the polynomial degree of the surface integrand is bounded by $D_s = p + q_w$. The minimal number of points is $N_s^{\\min} = \\lceil (D_s + 1)/2 \\rceil$.\n    $$D_s = 3 + 2 = 5$$\n    $$N_s^{\\min} = \\left\\lceil \\frac{5 + 1}{2} \\right\\rceil = \\lceil 3 \\rceil = 3$$\n\n3.  **Effective Spatial Order, $P_{\\mathrm{space}}$**:\n    When quadrature is inexact, the order of accuracy is limited. We first compute the effective polynomial degrees supported by the chosen quadrature rules, $N_v=4$ and $N_s=3$.\n    *   For the volume term, the effective polynomial degree $p_v^{\\mathrm{eff}}$ is found from the condition $2p_v^{\\mathrm{eff}} + q_J \\le 2N_v - 1$.\n    $$p_v^{\\mathrm{eff, raw}} = \\min\\!\\left(p,\\, \\left\\lfloor \\frac{2N_v - 1 - q_J}{2} \\right\\rfloor \\right) = \\min\\!\\left(3,\\, \\left\\lfloor \\frac{2(4) - 1 - 2}{2} \\right\\rfloor \\right) = \\min\\!\\left(3,\\, \\left\\lfloor \\frac{5}{2} \\right\\rfloor \\right) = \\min(3, 2) = 2$$\n    The value is non-negative, so $p_v^{\\mathrm{eff}} = 2$.\n    *   For the surface term, the effective polynomial degree $p_s^{\\mathrm{eff}}$ is found from $p_s^{\\mathrm{eff}} + q_w \\le 2N_s - 1$.\n    $$p_s^{\\mathrm{eff, raw}} = \\min\\!\\left(p,\\, 2N_s - 1 - q_w \\right) = \\min(3,\\, 2(3) - 1 - 2) = \\min(3,\\, 3) = 3$$\n    The value is non-negative, so $p_s^{\\mathrm{eff}} = 3$.\n    The guaranteed spatial order of convergence is $P_{\\mathrm{space}} = p+1$ for a DG method with polynomials of degree $p$, provided all integrals are exact. With under-integration, this is reduced to $P_{\\mathrm{space}} = \\min(p_v^{\\mathrm{eff}} + 1, p_s^{\\mathrm{eff}} + 1)$.\n    $$P_{\\mathrm{space}} = \\min(2 + 1,\\, 3 + 1) = \\min(3, 4) = 3$$\n\n4.  **Effective Temporal Order, $r_{\\mathrm{eff}}$**:\n    The problem states that lagging the metric terms ($J$ and $w$) in time reduces the temporal order to first order for a moving mesh. The mesh motion is determined by the amplitude $A_w$. Since $A_w = 0.1 > 0$, the mesh is moving.\n    $$r_{\\mathrm{eff}} = 1$$\n\n5.  **Total Scheme Order, $P_{\\mathrm{total}}$**:\n    The overall order of the numerical scheme is the minimum of the spatial and temporal orders.\n    $$P_{\\mathrm{total}} = \\min(P_{\\mathrm{space}},\\, r_{\\mathrm{eff}}) = \\min(3, 1) = 1$$\n\n6.  **Temporal Order Loss, $L_{\\mathrm{time}}$**:\n    The loss in temporal order is the difference between the native order of the Runge-Kutta integrator, $r=3$, and the effective order.\n    $$L_{\\mathrm{time}} = r - r_{\\mathrm{eff}} = 3 - 1 = 2$$\n\nThe results for Case $1$ are therefore $[5, 3, 3, 1, 1, 2]$. This same systematic procedure is applied to the remaining four test cases. The aggregated results are as follows:\n\n-   **Case 1**: $(p, q_J, q_w, r, N_v, N_s, A_w) = (3, 2, 2, 3, 4, 3, 0.1) \\rightarrow [5, 3, 3, 1, 1, 2]$\n-   **Case 2**: $(p, q_J, q_w, r, N_v, N_s, A_w) = (1, 1, 1, 2, 2, 2, 0.0) \\rightarrow [2, 2, 2, 2, 2, 0]$\n-   **Case 3**: $(p, q_J, q_w, r, N_v, N_s, A_w) = (0, 3, 3, 1, 2, 1, 0.5) \\rightarrow [2, 2, 1, 1, 1, 0]$\n-   **Case 4**: $(p, q_J, q_w, r, N_v, N_s, A_w) = (4, 1, 0, 4, 4, 2, 0.0) \\rightarrow [5, 3, 4, 4, 4, 0]$\n-   **Case 5**: $(p, q_J, q_w, r, N_v, N_s, A_w) = (2, 0, 2, 3, 3, 2, 0.2) \\rightarrow [3, 3, 2, 1, 1, 2]$\n\nThe final implementation will programmatically perform these calculations for the entire test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes accuracy and quadrature metrics for a DG-ALE scheme.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (p, q_J, q_w, r, N_v, N_s, A_w)\n    test_cases = [\n        (3, 2, 2, 3, 4, 3, 0.1),  # Case 1\n        (1, 1, 1, 2, 2, 2, 0.0),  # Case 2\n        (0, 3, 3, 1, 2, 1, 0.5),  # Case 3\n        (4, 1, 0, 4, 4, 2, 0.0),  # Case 4\n        (2, 0, 2, 3, 3, 2, 0.2),  # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        p, q_J, q_w, r, N_v, N_s, A_w = case\n\n        # 1. Minimum Volume Quadrature Points, N_v_min\n        D_v = 2 * p + q_J\n        N_v_min = int(np.ceil((D_v + 1) / 2))\n\n        # 2. Minimum Surface Quadrature Points, N_s_min\n        D_s = p + q_w\n        N_s_min = int(np.ceil((D_s + 1) / 2))\n\n        # 3. Effective Spatial Order, P_space\n        # Calculate effective polynomial degree for volume integrals\n        p_v_eff_raw = min(p, np.floor((2 * N_v - 1 - q_J) / 2))\n        # Clamp to 0 if negative\n        p_v_eff = max(0, int(p_v_eff_raw))\n\n        # Calculate effective polynomial degree for surface integrals\n        p_s_eff_raw = min(p, 2 * N_s - 1 - q_w)\n        # Clamp to 0 if negative\n        p_s_eff = max(0, int(p_s_eff_raw))\n\n        # Calculate guaranteed spatial convergence order\n        P_space = min(p_v_eff + 1, p_s_eff + 1)\n\n        # 4. Effective Temporal Order, r_eff\n        # Order drops to 1 if mesh is moving (A_w > 0) and metrics are lagged\n        r_eff = 1 if A_w > 0 else r\n\n        # 5. Total Scheme Order, P_total\n        # Overall order is the minimum of spatial and temporal orders\n        P_total = min(P_space, r_eff)\n\n        # 6. Temporal Order Loss, L_time\n        # Loss due to lagging\n        L_time = r - r_eff\n\n        results.append([N_v_min, N_s_min, P_space, r_eff, P_total, L_time])\n\n    # Format the final output string to exactly match the required format.\n    # The format is a list of lists, represented as a string without spaces.\n    inner_results_str = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(inner_results_str)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice solidifies your understanding by putting the GCL to a practical test in a full simulation environment. You will construct a high-order DG-ALE solver and witness firsthand the consequences of respecting versus violating the discrete GCL on a moving, curved mesh . By comparing a simulation that uses an inconsistent numerical approximation with one that enforces the GCL, you will see how a seemingly minor implementation detail can lead to catastrophic errors, while a correct approach preserves a uniform flow to machine precision.",
            "id": "3423630",
            "problem": "Consider a one-dimensional scalar conservation law in conservation form with constant advection speed $a$,\n$$\n\\partial_t u + \\partial_x \\left(a u\\right) = 0,\n$$\nposed on a spatial domain partitioned into a finite number of curvilinear elements. Let $x = x(\\xi,t)$ denote an isoparametric mapping from the reference coordinate $\\xi \\in [-1,1]$ to the physical coordinate $x$ for each element, where $t$ denotes time. Define the Jacobian $J(\\xi,t) := \\partial_\\xi x(\\xi,t)$ and the mesh velocity $v(\\xi,t) := \\partial_t x(\\xi,t)$.\n\nThe Arbitrary Lagrangian–Eulerian (ALE) conservative form of the scalar conservation law is\n$$\n\\partial_t \\left(J u \\right) + \\partial_\\xi \\left( a u - v u \\right) = 0.\n$$\nFor the special case of a constant solution $u \\equiv c$ (a free stream), the continuous geometric conservation law (GCL) states that\n$$\n\\partial_t J - \\partial_\\xi v = 0,\n$$\nwhich implies that the free stream is preserved exactly by the continuous ALE formulation: if the GCL holds, then $\\partial_t(J c) + \\partial_\\xi(a c - v c) = c(\\partial_t J - \\partial_\\xi v) = 0$.\n\nIn a high-order Discontinuous Galerkin (DG) discretization on curved elements, we approximate over each element by polynomials in the reference coordinate and construct a semi-discrete system by testing the ALE equation against a set of basis functions. For a nodal DG scheme, let $\\{ \\ell_i(\\xi) \\}_{i=1}^{N}$ denote the Lagrange polynomial basis associated with $N$ distinct reference nodes $\\{\\xi_i\\}_{i=1}^N \\subset [-1,1]$. The semi-discrete equation for the degrees of freedom $\\mathbf{U}(t) \\in \\mathbb{R}^N$, representing the expansion coefficients of $u(\\xi,t)$ in the nodal basis, takes the generic form\n$$\n\\mathbf{M}_J(t) \\frac{d\\mathbf{U}}{dt} + \\mathbf{R}(t) = \\mathbf{0},\n$$\nwhere $\\mathbf{M}_J(t)$ is the time-dependent mass matrix with entries\n$$\n\\left(\\mathbf{M}_J(t)\\right)_{ij} = \\int_{-1}^{1} J(\\xi,t)\\, \\ell_i(\\xi)\\, \\ell_j(\\xi)\\, d\\xi,\n$$\nand $\\mathbf{R}(t)$ is the residual vector assembling the flux and metric terms. For the free-stream case $u \\equiv c$, the only nontrivial contribution to $\\mathbf{R}(t)$ comes from the mismatch between the two metric terms,\n$$\n\\mathbf{R}_i(t) = c\\left[ \\int_{-1}^{1} \\partial_t J(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi - \\int_{-1}^{1} \\partial_\\xi v(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi \\right].\n$$\nIf the discrete geometric conservation law holds, namely\n$$\n\\int_{-1}^{1} \\partial_t J(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi = \\int_{-1}^{1} \\partial_\\xi v(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi \\quad \\text{for all } i,\n$$\nthen $\\mathbf{R}(t) = \\mathbf{0}$ and the free-stream $u \\equiv c$ is preserved exactly by the semi-discrete scheme.\n\nHowever, when the integral of $\\partial_t J$ is evaluated with an inconsistent or under-integrated quadrature rule (or with an inconsistent approximation in time), the cancellation with the $\\partial_\\xi v$ term fails, and the free-stream is not preserved. This problem asks you to construct a high-order nodal DG-ALE discretization over curved elements, demonstrate the degradation of free-stream preservation due to quadrature/time-approximation errors in $\\partial_t J$, and implement a correction that restores exact free-stream preservation by enforcing a discrete geometric conservation law.\n\nYou must:\n- Derive from first principles the discrete residual for the free-stream case from the ALE conservation law and explain the role of the geometric conservation law in ensuring exactness.\n- Implement a program that:\n  1. Builds a one-dimensional nodal DG discretization on multiple curved elements with an isoparametric mapping of the form\n     $$\n     x(\\xi,t) = A(t) + B(t)\\,\\xi + C(t)\\,\\xi^2 + D(t)\\,\\xi^3\n     $$\n     for each element, where $A(t)$, $B(t)$, $C(t)$, and $D(t)$ are smooth, time-dependent coefficients, and $J(\\xi,t) = B(t) + 2C(t)\\xi + 3D(t)\\xi^2$ and $v(\\xi,t) = \\partial_t x(\\xi,t)$ are induced.\n  2. Assembles the time-dependent mass matrix $\\mathbf{M}_J(t)$ using Gauss–Legendre quadrature with a specified number of quadrature points.\n  3. Computes the residual vector $\\mathbf{R}(t)$ for $u \\equiv c$ in two ways:\n     - An uncorrected residual that integrates $\\partial_t J$ using an under-integrated quadrature and approximates $\\partial_t J$ by a forward finite difference in time, while integrating $\\partial_\\xi v$ accurately using higher-order quadrature and exact time derivatives. This simulates quadrature/time-approximation error that breaks free-stream preservation.\n     - A corrected residual that enforces the discrete geometric conservation law by replacing the integral of $\\partial_t J$ with the same quadrature-based projection used for the integral of $\\partial_\\xi v$, ensuring\n       $$\n       \\int_{-1}^{1} \\partial_t J(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi \\equiv \\int_{-1}^{1} \\partial_\\xi v(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi\n       $$\n       in the discrete sense for each test function $\\ell_i$.\n  4. Advances the semi-discrete system in time for the free-stream case using forward Euler time stepping,\n     $$\n     \\mathbf{M}_J(t^n)\\, \\frac{\\mathbf{U}^{n+1} - \\mathbf{U}^n}{\\Delta t} = - \\mathbf{R}(t^n),\n     $$\n     with $\\mathbf{U}^0$ initialized to the constant $c$ at all nodes.\n  5. Computes the final root-mean-square error of $u(\\xi,t)$ relative to the constant $c$ at the final time $T$, measured in the $L^2$ norm weighted by the final Jacobian:\n     $$\n     \\mathrm{Err} = \\left( \\frac{\\sum_{e} \\int_{-1}^{1} J_e(\\xi, T)\\, \\left(u_e(\\xi,T) - c\\right)^2\\, d\\xi}{\\sum_{e} \\int_{-1}^{1} J_e(\\xi, T)\\, d\\xi} \\right)^{1/2},\n     $$\n     where the integrals are evaluated using a high-order Gauss–Legendre quadrature.\n\nDesign your implementation to run three test cases that collectively exercise the scheme:\n- Test Case 1 (general curved, moving mesh, happy path): Two elements, polynomial degree $p=4$ (thus $N=p+1=5$ nodes per element), final time $T=1.0$, time step $\\Delta t=10^{-2}$, constant solution $c=2.0$. Let\n  $$\n  \\begin{aligned}\n  A_1(t) &= 0.3\\sin(1.5 t), & B_1(t) &= 1 + 0.2\\sin(2 t), & C_1(t) &= 0.1\\cos(t), & D_1(t) &= 0.05\\sin(3 t), \\\\\n  A_2(t) &= 0.25\\sin(1.3 t), & B_2(t) &= 1 + 0.15\\sin(1.7 t), & C_2(t) &= 0.08\\cos(0.9 t), & D_2(t) &= 0.04\\sin(2.5 t).\n  \\end{aligned}\n  $$\n  Use $6$-point Gauss–Legendre quadrature for the mass matrix and corrected residual integrals, $3$-point Gauss–Legendre quadrature for the uncorrected $\\partial_t J$ integral, and $10$-point Gauss–Legendre quadrature for the final error evaluation and the accurate $\\partial_\\xi v$ integral. Report two floats: the uncorrected error and the corrected error.\n- Test Case 2 (static mesh, boundary condition case): Two elements, same polynomial degree and constant $c=2.0$, $T=1.0$, $\\Delta t=10^{-2}$, but a static mapping\n  $$\n  A_e(t) \\equiv 0, \\quad B_e(t) \\equiv 1, \\quad C_e(t) \\equiv 0, \\quad D_e(t) \\equiv 0,\n  $$\n  for both elements $e=1,2$. Use the same quadrature orders as Test Case 1. Report two floats: the uncorrected error and the corrected error.\n- Test Case 3 (aggressive curved motion, edge case): Two elements, $p=4$, $c=2.0$, $T=1.0$, $\\Delta t=5\\times 10^{-2}$. Let\n  $$\n  \\begin{aligned}\n  A_1(t) &= 0.3\\sin(1.8 t), & B_1(t) &= 1 + 0.25\\sin(2.2 t), & C_1(t) &= 0.3\\cos(1.1 t), & D_1(t) &= 0.2\\sin(3.1 t), \\\\\n  A_2(t) &= 0.28\\sin(1.4 t), & B_2(t) &= 1 + 0.22\\sin(1.9 t), & C_2(t) &= 0.27\\cos(0.95 t), & D_2(t) &= 0.18\\sin(2.7 t).\n  \\end{aligned}\n  $$\n  Use $6$-point Gauss–Legendre quadrature for the mass matrix and corrected residual integrals, $2$-point Gauss–Legendre quadrature for the uncorrected $\\partial_t J$ integral, and $16$-point Gauss–Legendre quadrature for the final error evaluation and the accurate $\\partial_\\xi v$ integral. Report two floats: the uncorrected error and the corrected error.\n\nNo physical units are required; angles in the trigonometric functions are to be interpreted in radians. Your program should produce a single line of output containing the results for all test cases as a comma-separated list of six floats enclosed in square brackets in the following order:\n$$\n[\\text{uncorrected}_1, \\text{corrected}_1, \\text{uncorrected}_2, \\text{corrected}_2, \\text{uncorrected}_3, \\text{corrected}_3].\n$$",
            "solution": "The problem requires an analysis and implementation of a high-order Discontinuous Galerkin (DG) scheme for a scalar advection equation on a moving, curved mesh, focusing on the role of the Geometric Conservation Law (GCL) in preserving a constant-flow solution (free-stream).\n\n### Principle-Based Derivation\n\nWe begin with the one-dimensional scalar conservation law with a constant advection speed $a$:\n$$\n\\partial_t u + \\partial_x (a u) = 0\n$$\nThe problem is posed on a domain with time-dependent, curved elements. We use an isoparametric mapping $x = x(\\xi, t)$ for each element, transforming from a fixed reference element with coordinate $\\xi \\in [-1, 1]$ to the physical element. The key geometric quantities are the Jacobian of this transformation, $J(\\xi, t) = \\partial_\\xi x(\\xi, t)$, and the mesh velocity, $v(\\xi, t) = \\partial_t x(\\xi, t)$.\n\nUsing the chain rule, we can transform the conservation law into the Arbitrary Lagrangian-Eulerian (ALE) frame on the reference element. The resulting conservative ALE formulation is:\n$$\n\\partial_t (J u) + \\partial_\\xi (a u - v u) = 0\n$$\n\nA fundamental requirement for any valid numerical scheme is its ability to preserve a constant solution, often referred to as a \"free-stream\" or \"uniform flow\". Let's test the continuous ALE equation with a constant solution $u(\\xi, t) \\equiv c$. Substituting $u=c$ into the ALE equation yields:\n$$\n\\partial_t (J c) + \\partial_\\xi (a c - v c) = c\\, \\partial_t J + c\\, \\partial_\\xi a - c\\, \\partial_\\xi v\n$$\nSince the advection speed $a$ is constant, $\\partial_\\xi a = 0$. The equation simplifies to:\n$$\nc \\left( \\partial_t J - \\partial_\\xi v \\right) = 0\n$$\nThis implies that for a free-stream solution to be preserved, the geometric quantities must satisfy the **continuous Geometric Conservation Law (GCL)**:\n$$\n\\partial_t J - \\partial_\\xi v = 0\n$$\nThis identity can be confirmed by noting that for a smooth mapping $x(\\xi, t)$, mixed partial derivatives are equal: $\\partial_t \\partial_\\xi x = \\partial_\\xi \\partial_t x$, which is precisely $\\partial_t J = \\partial_\\xi v$. Thus, the continuous ALE formulation exactly preserves the free stream.\n\nThe challenge arises in the discretization. For a high-order nodal DG scheme, we approximate the solution $u$ within each element using a basis of Lagrange polynomials $\\{ \\ell_i(\\xi) \\}_{i=1}^{N}$ associated with $N$ solution nodes $\\{\\xi_i\\}_{i=1}^N$. The semi-discrete form is obtained by multiplying the ALE equation by a test function $\\ell_i(\\xi)$ and integrating over the reference element:\n$$\n\\int_{-1}^{1} \\left( \\partial_t (J u) + \\partial_\\xi ((a-v)u) \\right) \\ell_i(\\xi)\\,d\\xi = 0\n$$\nExpanding the time derivative term $\\partial_t(Ju) = (\\partial_t J)u + J(\\partial_t u)$ and separating the terms involving time derivatives of the solution coefficients $\\mathbf{U}(t)$ gives the matrix system:\n$$\n\\mathbf{M}_J(t) \\frac{d\\mathbf{U}}{dt} + \\mathbf{R}(t) = \\mathbf{0}\n$$\nwhere $\\mathbf{M}_J(t)$ is the mass matrix and $\\mathbf{R}(t)$ is the residual vector. For the free-stream case $u=c$, the solution coefficients are constant, $\\mathbf{U}(t) = c \\cdot \\mathbf{1}$, so their time derivative is zero: $d\\mathbf{U}/dt = \\mathbf{0}$. For the semi-discrete scheme to preserve this solution, the residual vector $\\mathbf{R}(t)$ must be identically zero when $u=c$.\n\nThe $i$-th component of the residual for $u=c$ is:\n$$\nR_i(t) = \\int_{-1}^{1} \\left( (\\partial_t J)c + \\partial_\\xi ((a-v)c) \\right) \\ell_i(\\xi)\\,d\\xi = c \\left[ \\int_{-1}^{1} \\partial_t J\\, \\ell_i\\,d\\xi - \\int_{-1}^{1} \\partial_\\xi v\\, \\ell_i\\,d\\xi \\right]\n$$\n(The contribution from the constant $a$ term vanishes after integration by parts and assuming periodic or consistent inter-element fluxes for a constant state). For the free-stream to be preserved, we must have $R_i(t) = 0$ for all $i$, which leads to the **discrete Geometric Conservation Law (GCL)**:\n$$\n\\int_{-1}^{1} \\partial_t J(\\xi,t)\\,\\ell_i(\\xi)\\,d\\xi = \\int_{-1}^{1} \\partial_\\xi v(\\xi,t)\\,\\ell_i(\\xi)\\,d\\xi \\quad \\forall i\n$$\n\nThe core of the problem lies in the numerical evaluation of these two integrals.\n1.  **Uncorrected Scheme**: The term $\\partial_t J$ arises from the time derivative operator. In a time-stepping scheme, it is natural to approximate it with a finite difference, e.g., $\\partial_t J(\\xi, t^n) \\approx (J(\\xi, t^{n+1}) - J(\\xi, t^n))/\\Delta t$. The mesh velocity $v$, however, is an explicit part of the flux function and is typically evaluated at time $t^n$. The two integrals in the discrete GCL are thus computed in fundamentally different ways: one with a numerical time derivative and often a low-order quadrature rule for efficiency (under-integration), and the other with an analytical spatial derivative and a high-order quadrature rule for accuracy. This mismatch leads to a non-zero residual $\\mathbf{R}(t) \\neq \\mathbf{0}$, which introduces errors and causes the numerical scheme to fail to preserve the free-stream.\n\n2.  **Corrected Scheme**: To restore free-stream preservation, the discrete GCL must be strictly enforced. This is achieved by ensuring that the numerical evaluation of the two integrals yields identical results. The standard correction is to compute both integrals using the *same procedure*. Since $\\partial_t J = \\partial_\\xi v$ analytically, we can use the analytical expressions for both integrands and evaluate both integrals using the same quadrature rule (e.g., the one used for the mass matrix). This consistency guarantees that the two discrete terms cancel each other to machine precision, making the residual $\\mathbf{R}(t)$ for the free-stream case a zero vector. Consequently, $d\\mathbf{U}/dt = \\mathbf{0}$, and the free-stream is preserved exactly by the semi-discrete scheme.\n\nThe following implementation will demonstrate this principle by simulating the evolution of a constant solution with both the uncorrected and corrected schemes and measuring the resulting error.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi\nfrom numpy.polynomial.legendre import leggauss\n\ndef get_gauss_lobatto_nodes(N):\n    \"\"\"Computes the N-point Gauss-Lobatto-Legendre nodes on [-1, 1].\"\"\"\n    if N == 1:\n        return np.array([0.0])\n    if N == 2:\n        return np.array([-1.0, 1.0])\n    # Interior nodes are roots of P'_{N-1}(x), which are roots of Jacobi polynomial P_{N-2}^{(1,1)}(x)\n    interior_nodes = roots_jacobi(N - 2, 1, 1)[0]\n    return np.r_[-1.0, interior_nodes, 1.0]\n\ndef lagrange_basis(solution_nodes, evaluation_points):\n    \"\"\"\n    Computes the values of the Lagrange basis polynomials.\n    Rows correspond to basis functions, columns to evaluation points.\n    \"\"\"\n    N = len(solution_nodes)\n    M = len(evaluation_points)\n    L = np.ones((N, M))\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                L[i, :] *= (evaluation_points - solution_nodes[j]) / (solution_nodes[i] - solution_nodes[j])\n    return L\n\nclass Element:\n    \"\"\"Represents a single DG element with moving geometry.\"\"\"\n    def __init__(self, p, c, dt, mapping_coeffs, quad_orders):\n        self.p = p\n        self.N = p + 1\n        self.c = c\n        self.dt = dt\n        self.coeffs = mapping_coeffs\n        \n        nq_mass, nq_uncorr, nq_high, nq_error = quad_orders\n        \n        # Solution nodes (Gauss-Lobatto) and quadrature rules\n        self.sol_nodes = get_gauss_lobatto_nodes(self.N)\n        self.q_mass_nodes, self.q_mass_weights = leggauss(nq_mass)\n        self.q_uncorr_nodes, self.q_uncorr_weights = leggauss(nq_uncorr)\n        self.q_high_nodes, self.q_high_weights = leggauss(nq_high)\n        self.q_error_nodes, self.q_error_weights = leggauss(nq_error)\n        \n        # Pre-compute basis functions at quadrature nodes\n        self.L_mass = lagrange_basis(self.sol_nodes, self.q_mass_nodes)\n        self.L_uncorr = lagrange_basis(self.sol_nodes, self.q_uncorr_nodes)\n        self.L_high = lagrange_basis(self.sol_nodes, self.q_high_nodes)\n        self.L_error = lagrange_basis(self.sol_nodes, self.q_error_nodes)\n\n    def get_geometry(self, t, xi, derivatives=True):\n        \"\"\"Computes geometric quantities J, v, and their derivatives.\"\"\"\n        A, B, C, D = self.coeffs['A'](t), self.coeffs['B'](t), self.coeffs['C'](t), self.coeffs['D'](t)\n        J = B + 2 * C * xi + 3 * D * xi**2\n        if not derivatives:\n            return J, None, None, None\n            \n        Ad, Bd, Cd, Dd = self.coeffs['Ad'](t), self.coeffs['Bd'](t), self.coeffs['Cd'](t), self.coeffs['Dd'](t)\n        v = Ad + Bd * xi + Cd * xi**2 + Dd * xi**3\n        dJdt_exact = Bd + 2 * Cd * xi + 3 * Dd * xi**2\n        dvdxi_exact = Bd + 2 * Cd * xi + 3 * Dd * xi**2\n        \n        return J, v, dJdt_exact, dvdxi_exact\n\n    def get_mass_matrix(self, t):\n        \"\"\"Assembles the time-dependent mass matrix M_J.\"\"\"\n        J_at_mass_nodes, _, _, _ = self.get_geometry(t, self.q_mass_nodes, derivatives=False)\n        # M_ij = integral(J * l_i * l_j dxi)\n        M_J = self.L_mass @ (np.diag(self.q_mass_weights * J_at_mass_nodes)) @ self.L_mass.T\n        return M_J\n\n    def get_residuals(self, t):\n        \"\"\"Computes both uncorrected and corrected residuals for the free-stream case.\"\"\"\n        # Uncorrected Residual\n        J_t, _, _, _ = self.get_geometry(t, self.q_uncorr_nodes, derivatives=False)\n        J_t_plus_dt, _, _, _ = self.get_geometry(t + self.dt, self.q_uncorr_nodes, derivatives=False)\n        dJdt_approx = (J_t_plus_dt - J_t) / self.dt\n        \n        _, _, _, dvdxi_exact_high = self.get_geometry(t, self.q_high_nodes)\n        \n        term1_uncorr = self.L_uncorr @ (self.q_uncorr_weights * dJdt_approx)\n        term2_uncorr = self.L_high @ (self.q_high_weights * dvdxi_exact_high)\n        R_uncorr = self.c * (term1_uncorr - term2_uncorr)\n\n        # Corrected Residual (should be zero to machine precision)\n        _, _, dJdt_exact_mass, dvdxi_exact_mass = self.get_geometry(t, self.q_mass_nodes)\n        term1_corr = self.L_mass @ (self.q_mass_weights * dJdt_exact_mass)\n        term2_corr = self.L_mass @ (self.q_mass_weights * dvdxi_exact_mass)\n        R_corr = self.c * (term1_corr - term2_corr)\n            \n        return R_uncorr, R_corr\n\n    def compute_element_error(self, U, t_final):\n        \"\"\"Computes the L2 error contribution from this element.\"\"\"\n        u_at_error_nodes = self.L_error.T @ U\n        J_final, _, _, _ = self.get_geometry(t_final, self.q_error_nodes, derivatives=False)\n        \n        sq_err_integrand = J_final * (u_at_error_nodes - self.c)**2\n        element_sq_err = np.sum(self.q_error_weights * sq_err_integrand)\n        element_vol = np.sum(self.q_error_weights * J_final)\n\n        return element_sq_err, element_vol\n\nclass DGSolver:\n    \"\"\"Manages the DG-ALE simulation over multiple elements.\"\"\"\n    def __init__(self, p, num_elements, T, dt, c, all_mappings_coeffs, quad_orders):\n        self.T = T\n        self.dt = dt\n        self.num_elements = num_elements\n        self.N = p + 1\n        \n        self.elements = [Element(p, c, dt, all_mappings_coeffs[e], quad_orders) for e in range(num_elements)]\n        \n        self.U_uncorr = np.full((num_elements, self.N), c)\n        self.U_corr = np.full((num_elements, self.N), c)\n\n    def run_simulation(self):\n        \"\"\"Executes the time-stepping loop and returns final errors.\"\"\"\n        num_steps = int(round(self.T / self.dt))\n        for n in range(num_steps):\n            t = n * self.dt\n            for e in range(self.num_elements):\n                elem = self.elements[e]\n                M_J = elem.get_mass_matrix(t)\n                R_uncorr, R_corr = elem.get_residuals(t)\n                M_J_inv = np.linalg.inv(M_J)\n                \n                # Forward Euler Step\n                self.U_uncorr[e, :] -= self.dt * (M_J_inv @ R_uncorr)\n                self.U_corr[e, :] -= self.dt * (M_J_inv @ R_corr)\n        \n        t_final = num_steps * self.dt\n        err_uncorr = self._calculate_final_error(self.U_uncorr, t_final)\n        err_corr = self._calculate_final_error(self.U_corr, t_final)\n        \n        return err_uncorr, err_corr\n\n    def _calculate_final_error(self, U_final, t_final):\n        \"\"\"Calculates the root-mean-square error over all elements.\"\"\"\n        total_sq_err, total_volume = 0.0, 0.0\n        for e in range(self.num_elements):\n            sq_err, vol = self.elements[e].compute_element_error(U_final[e, :], t_final)\n            total_sq_err += sq_err\n            total_volume += vol\n        return np.sqrt(total_sq_err / total_volume) if total_volume > 0 else 0.0\n\ndef solve():\n    \"\"\"Sets up and runs the test cases.\"\"\"\n    test_cases = [\n        {\n            \"p\": 4, \"T\": 1.0, \"dt\": 1e-2, \"c\": 2.0, \"num_elements\": 2,\n            \"quad_orders\": (6, 3, 10, 10),\n            \"mappings\": [\n                {\n                    'A': lambda t: 0.3*np.sin(1.5*t), 'Ad': lambda t: 0.3*1.5*np.cos(1.5*t),\n                    'B': lambda t: 1 + 0.2*np.sin(2*t), 'Bd': lambda t: 0.2*2*np.cos(2*t),\n                    'C': lambda t: 0.1*np.cos(t), 'Cd': lambda t: -0.1*np.sin(t),\n                    'D': lambda t: 0.05*np.sin(3*t), 'Dd': lambda t: 0.05*3*np.cos(3*t),\n                },\n                {\n                    'A': lambda t: 0.25*np.sin(1.3*t), 'Ad': lambda t: 0.25*1.3*np.cos(1.3*t),\n                    'B': lambda t: 1 + 0.15*np.sin(1.7*t), 'Bd': lambda t: 0.15*1.7*np.cos(1.7*t),\n                    'C': lambda t: 0.08*np.cos(0.9*t), 'Cd': lambda t: -0.08*0.9*np.sin(0.9*t),\n                    'D': lambda t: 0.04*np.sin(2.5*t), 'Dd': lambda t: 0.04*2.5*np.cos(2.5*t),\n                }\n            ]\n        },\n        {\n            \"p\": 4, \"T\": 1.0, \"dt\": 1e-2, \"c\": 2.0, \"num_elements\": 2,\n            \"quad_orders\": (6, 3, 10, 10),\n            \"mappings\": [\n                {\n                    'A': lambda t: 0.0, 'Ad': lambda t: 0.0, 'B': lambda t: 1.0, 'Bd': lambda t: 0.0,\n                    'C': lambda t: 0.0, 'Cd': lambda t: 0.0, 'D': lambda t: 0.0, 'Dd': lambda t: 0.0,\n                },\n                {\n                    'A': lambda t: 0.0, 'Ad': lambda t: 0.0, 'B': lambda t: 1.0, 'Bd': lambda t: 0.0,\n                    'C': lambda t: 0.0, 'Cd': lambda t: 0.0, 'D': lambda t: 0.0, 'Dd': lambda t: 0.0,\n                }\n            ]\n        },\n        {\n            \"p\": 4, \"T\": 1.0, \"dt\": 5e-2, \"c\": 2.0, \"num_elements\": 2,\n            \"quad_orders\": (6, 2, 16, 16),\n            \"mappings\": [\n                {\n                    'A': lambda t: 0.3*np.sin(1.8*t), 'Ad': lambda t: 0.3*1.8*np.cos(1.8*t),\n                    'B': lambda t: 1 + 0.25*np.sin(2.2*t), 'Bd': lambda t: 0.25*2.2*np.cos(2.2*t),\n                    'C': lambda t: 0.3*np.cos(1.1*t), 'Cd': lambda t: -0.3*1.1*np.sin(1.1*t),\n                    'D': lambda t: 0.2*np.sin(3.1*t), 'Dd': lambda t: 0.2*3.1*np.cos(3.1*t),\n                },\n                {\n                    'A': lambda t: 0.28*np.sin(1.4*t), 'Ad': lambda t: 0.28*1.4*np.cos(1.4*t),\n                    'B': lambda t: 1 + 0.22*np.sin(1.9*t), 'Bd': lambda t: 0.22*1.9*np.cos(1.9*t),\n                    'C': lambda t: 0.27*np.cos(0.95*t), 'Cd': lambda t: -0.27*0.95*np.sin(0.95*t),\n                    'D': lambda t: 0.18*np.sin(2.7*t), 'Dd': lambda t: 0.18*2.7*np.cos(2.7*t),\n                }\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        solver = DGSolver(\n            p=case[\"p\"], num_elements=case[\"num_elements\"], T=case[\"T\"],\n            dt=case[\"dt\"], c=case[\"c\"], all_mappings_coeffs=case[\"mappings\"],\n            quad_orders=case[\"quad_orders\"]\n        )\n        err_uncorr, err_corr = solver.run_simulation()\n        results.extend([err_uncorr, err_corr])\n    \n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}