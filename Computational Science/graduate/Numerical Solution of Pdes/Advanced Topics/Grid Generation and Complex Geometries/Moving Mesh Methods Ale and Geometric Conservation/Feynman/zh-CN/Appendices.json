{
    "hands_on_practices": [
        {
            "introduction": "几何守恒律（GCL）是任意拉格朗日-欧拉（ALE）方法成功的基石，它保证了数值格式在移动网格上能够精确地保持均匀流场。本练习旨在通过一个基础推导，揭示离散GCL的本质。在一个一维有限体积法的简化模型中，您将亲自推导出时间积分格式必须满足的特定条件，以确保在网格运动时物理守恒律得到精确满足，从而深刻理解几何守恒与数值精度之间的内在联系 。",
            "id": "3423641",
            "problem": "考虑移动区间 $K(t) = [x_{L}(t), x_{R}(t)]$ 上的一维守恒律 $\\partial_{t} u + \\partial_{x} f(u) = 0$。设任意拉格朗日-欧拉（ALE）映射在参考坐标 $\\xi \\in [0,1]$ 上是线性的，由 $x(\\xi,t) = x_{L}(t) + \\big(x_{R}(t) - x_{L}(t)\\big)\\,\\xi$ 给出。定义面速度为 $w_{L}(t) = \\partial_{t} x_{L}(t)$ 和 $w_{R}(t) = \\partial_{t} x_{R}(t)$，并令单元体积为 $V(t) = x_{R}(t) - x_{L}(t)$。考虑从 $t^{n}$ 到 $t^{n+1}$ 的一个时间步，步长为 $\\Delta t = t^{n+1} - t^{n}$。\n\n一个二阶有限体积格式是基于 $[t^{n}, t^{n+1}]$ 上的时空控制体构建的，并且通过以下形式的两点时间近似来逼近穿过每个空间面的网格平流的时空通量\n$$\nw_{\\star}^{\\text{disc}} = \\theta\\, w_{\\star}^{n+1} + (1 - \\theta)\\, w_{\\star}^{n},\n$$\n其中 $\\star \\in \\{L, R\\}$ 表示左或右面，且 $w_{\\star}^{n} = w_{\\star}(t^{n})$，$w_{\\star}^{n+1} = w_{\\star}(t^{n+1})$。两个面使用相同的时间离散化，具有相同的未知权重 $\\theta \\in \\mathbb{R}$。\n\n几何守恒律（GCL）要求空间均匀解 $u(x,t) \\equiv u_{0}$ 被全离散格式精确保持。假设在该时间步内，每个面轨迹 $x_{\\star}(t)$ 都是 $t$ 的仿射函数（即时间线性）。在这些假设下，对上述时空有限体积公式强制执行离散GCL，并确定权重 $\\theta$ 的唯一值，该值保证了对于任意 $u_{0}$ 和该时间步内任意时间线性的面运动，都能精确保持 $u(x,t) \\equiv u_{0}$。\n\n你的最终答案必须是 $\\theta$ 的值，以单个数字表示。不需要单位，也无需四舍五入。",
            "solution": "该问题要求找到权重 $\\theta$ 的唯一值，该值保证半离散有限体积格式满足几何守恒律（GCL）。GCL确保了均匀状态 $u(x,t) = u_0$ 在移动网格上被数值格式精确保持。\n\n一维守恒律由下式给出\n$$\n\\partial_{t} u + \\partial_{x} f(u) = 0\n$$\n在一个移动单元 $K(t) = [x_L(t), x_R(t)]$ 上。\n\n让我们首先构建守恒律在由单元 $K(t)$ 从时间 $t^n$ 移动到 $t^{n+1}$ 所定义的时空控制体上的精确积分形式。使用莱布尼茨积分法则（或一维下的雷诺输运定理），$u$ 在 $K(t)$ 上的积分随时间的演化为：\n$$\n\\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} u(x,t) \\,dx = \\int_{x_L(t)}^{x_R(t)} \\partial_t u \\,dx + u(x_R(t), t) \\frac{dx_R}{dt} - u(x_L(t), t) \\frac{dx_L}{dt}\n$$\n代入 $\\partial_t u = -\\partial_x f(u)$ 以及面速度的定义 $w_L(t) = \\partial_t x_L(t)$ 和 $w_R(t) = \\partial_t x_R(t)$：\n$$\n\\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} u \\,dx = \\int_{x_L(t)}^{x_R(t)} (-\\partial_x f(u)) \\,dx + u_R w_R - u_L w_L\n$$\n$$\n\\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} u \\,dx = -[f(u_R) - f(u_L)] + u_R w_R - u_L w_L\n$$\n其中 $u_L = u(x_L(t), t)$ 和 $u_R = u(x_R(t), t)$。这就是守恒律的任意拉格朗日-欧拉（ALE）形式。\n\nGCL是关于数值格式如何处理几何的条件。它通过考虑均匀流 $u(x,t) = u_0$ 的情况导出，其中 $u_0$ 是一个常数。在这种情况下，$f(u) = f(u_0)$ 也是常数，物理通量项 $\\partial_x f(u)$ 为零。守恒律简化为 $\\partial_t u = 0$。ALE形式变为：\n$$\n\\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} u_0 \\,dx = u_0 w_R - u_0 w_L\n$$\n由于 $u_0$ 是常数，我们可以将其提出：\n$$\nu_0 \\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} 1 \\,dx = u_0 (w_R - w_L)\n$$\n该积分是单元的体积（长度），$V(t) = x_R(t) - x_L(t)$。所以，我们有：\n$$\nu_0 \\frac{dV(t)}{dt} = u_0 (w_R - w_L)\n$$\n由于 $\\frac{dV}{dt} = \\frac{d}{dt}(x_R - x_L) = w_R - w_L$，该方程是一个恒等式。现在，我们将这个恒等式在时间步 $[t^n, t^{n+1}]$ 上积分：\n$$\n\\int_{t^n}^{t^{n+1}} \\frac{dV(t)}{dt} \\,dt = \\int_{t^n}^{t^{n+1}} (w_R(t) - w_L(t)) \\,dt\n$$\n$$\nV(t^{n+1}) - V(t^n) = \\int_{t^n}^{t^{n+1}} w_R(t) \\,dt - \\int_{t^n}^{t^{n+1}} w_L(t) \\,dt\n$$\n令 $V^n = V(t^n)$，这就是GCL的精确积分形式：\n$$\nV^{n+1} - V^{n} = \\int_{t^n}^{t^{n+1}} (w_R(t) - w_L(t)) \\,dt\n$$\n离散格式必须精确满足这个几何关系。\n\n有限体积格式将单元平均值 $\\bar{u}$ 从时间 $t^n$ 更新到 $t^{n+1}$。更新的一般形式为：\n$$\nV^{n+1}\\bar{u}^{n+1} - V^n \\bar{u}^n + \\Delta t (\\hat{F}_R - \\hat{F}_L) = 0\n$$\n其中 $\\hat{F}_\\star$ 是面 $\\star \\in \\{L, R\\}$ 上的数值通量。数值通量包括物理部分和网格运动部分。对于 $u=u_0$ 的GCL测试，物理通量相消，更新方程简化。条件 $\\bar{u}^{n+1} = \\bar{u}^n = u_0$ 导致离散GCL。\n问题指明，通量的几何部分使用离散网格速度 $w_\\star^{\\text{disc}}$ 进行近似。从格式中导出的离散GCL是：\n$$\n\\frac{V^{n+1} - V^n}{\\Delta t} = w_R^{\\text{disc}} - w_L^{\\text{disc}}\n$$\n其中 $w_{\\star}^{\\text{disc}} = \\theta\\, w_{\\star}^{n+1} + (1 - \\theta)\\, w_{\\star}^{n}$。\n\n为了使离散格式满足GCL，其对体积变化的表示必须与精确积分形式相匹配。通过令精确和离散的GCL表达式相等，我们得到关于 $\\theta$ 的条件：\n$$\nw_R^{\\text{disc}} - w_L^{\\text{disc}} = \\frac{1}{\\Delta t} \\int_{t^n}^{t^{n+1}} (w_R(t) - w_L(t)) \\,dt\n$$\n代入 $w^{\\text{disc}}$ 的定义：\n$$\n\\theta(w_R^{n+1} - w_L^{n+1}) + (1-\\theta)(w_R^n - w_L^n) = \\frac{1}{\\Delta t} \\int_{t^n}^{t^{n+1}} (w_R(t) - w_L(t)) \\,dt\n$$\n问题陈述要求对“任意时间线性的面运动”强制执行此条件，即 $x_\\star(t)$ 是仿射函数。如果 $x_\\star(t)$ 是时间线性的，那么速度 $w_\\star(t)$ 在该区间上是恒定的。因此，$w_\\star^n$ 等于 $w_\\star^{n+1}$，积分 $\\int_{t^n}^{t^{n+1}} w_\\star(t)\\,dt$ 简单地为 $w_\\star \\Delta t$。对于恒定速度，方程变为一个恒等式，这对任何 $\\theta$ 值都成立，但这与问题要求找到 $\\theta$ 的*唯一*值的要求相矛盾。\n\n这个矛盾源于对问题中“二阶有限体积格式”这一要求的解释。一个数值格式的时间精度阶数由其时间积分的精度决定。表达式 $\\theta G^{n+1} + (1-\\theta)G^n$ 是一个函数 $G(t)$ 在时间步开始和结束时值的加权平均，用于近似时间平均 $\\frac{1}{\\Delta t}\\int_{t^n}^{t^{n+1}} G(t) \\,dt$。一个二阶精度的格式，最低要求是对于时间线性的被积函数，其积分是精确的。因此，我们要求GCL对于面速度 $w_\\star(t)$ 是时间线性函数的运动精确成立。\n\n设 $g(t) = w_R(t) - w_L(t)$ 为任意时间线性函数。其在 $[t^n, t^{n+1}]$ 上的积分精确值由梯形法则给出：\n$$\n\\int_{t^n}^{t^{n+1}} g(t) \\,dt = \\frac{g(t^n) + g(t^{n+1})}{2} \\Delta t\n$$\n因此，时间平均值为：\n$$\n\\frac{1}{\\Delta t} \\int_{t^n}^{t^{n+1}} g(t) \\,dt = \\frac{g(t^n) + g(t^{n+1})}{2}\n$$\n将此代入我们的GCL相容性条件：\n$$\n\\theta g(t^{n+1}) + (1-\\theta)g(t^n) = \\frac{g(t^n) + g(t^{n+1})}{2}\n$$\n这个方程必须对任意线性函数 $g(t)$ 成立，这意味着它必须对任意初值和终值 $g(t^n)$ 和 $g(t^{n+1})$ 成立。\n让我们根据 $g(t^n)$ 和 $g(t^{n+1})$ 来收集项：\n$$\n\\left(\\theta - \\frac{1}{2}\\right) g(t^{n+1}) + \\left(1 - \\theta - \\frac{1}{2}\\right) g(t^n) = 0\n$$\n$$\n\\left(\\theta - \\frac{1}{2}\\right) g(t^{n+1}) + \\left(\\frac{1}{2} - \\theta\\right) g(t^n) = 0\n$$\n$$\n\\left(\\theta - \\frac{1}{2}\\right) (g(t^{n+1}) - g(t^n)) = 0\n$$\n由于这个关系必须对*任意*线性速度剖面都满足，我们可以选择一个运动，使得 $g(t^{n+1}) \\neq g(t^n)$（例如，一个正在加速膨胀的单元）。为了使方程在这种一般情况下成立，系数必须为零：\n$$\n\\theta - \\frac{1}{2} = 0\n$$\n这就确定了权重的唯一值：\n$$\n\\theta = \\frac{1}{2}\n$$\n这个值对应于Crank-Nicolson方法（或梯形法则），这与构建二阶格式的要求是一致的。",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "在掌握了离散GCL的基本原理后，我们将挑战一个更接近实际应用的复杂场景。本编程练习将带领您在移动的曲线单元上，探索高阶间断伽辽金（DG）方法中的GCL问题。您将通过亲手编程来数值地验证，离散化过程中看似微小的几何不一致性将如何破坏自由流保持特性并产生伪解，并进一步实现一种关键的修正方法以严格执行离散GCL，从而确保数值格式的健壮性 。",
            "id": "3423630",
            "problem": "考虑一个一维标量守恒律，其守恒形式具有恒定的平流速度 $a$，\n$$\n\\partial_t u + \\partial_x \\left(a u\\right) = 0,\n$$\n该守恒律定义在一个空间域上，此域被划分为有限数量的曲线单元。令 $x = x(\\xi,t)$ 表示一个等参映射，对于每个单元，该映射将参考坐标 $\\xi \\in [-1,1]$ 映射到物理坐标 $x$，$t$ 表示时间。定义雅可比行列式 $J(\\xi,t) := \\partial_\\xi x(\\xi,t)$ 和网格速度 $v(\\xi,t) := \\partial_t x(\\xi,t)$。\n\n该标量守恒律的任意拉格朗日-欧拉（ALE）守恒形式为\n$$\n\\partial_t \\left(J u \\right) + \\partial_\\xi \\left( a u - v u \\right) = 0.\n$$\n对于常数解 $u \\equiv c$（自由流）的特殊情况，连续几何守恒律（GCL）表明\n$$\n\\partial_t J - \\partial_\\xi v = 0,\n$$\n这意味着连续 ALE 公式可以精确地保持自由流：如果 GCL 成立，则 $\\partial_t(J c) + \\partial_\\xi(a c - v c) = c(\\partial_t J - \\partial_\\xi v) = 0$。\n\n在曲线单元上的高阶间断 Galerkin（DG）离散化中，我们在每个单元上使用参考坐标系中的多项式进行逼近，并通过将 ALE 方程与一组基函数进行检验来构建半离散系统。对于节点 DG 格式，令 $\\{ \\ell_i(\\xi) \\}_{i=1}^{N}$ 表示与 $N$ 个不同的参考节点 $\\{\\xi_i\\}_{i=1}^N \\subset [-1,1]$ 相关联的 Lagrange 多项式基。代表 $u(\\xi,t)$ 在节点基中展开系数的自由度 $\\mathbf{U}(t) \\in \\mathbb{R}^N$ 的半离散方程具有以下通用形式\n$$\n\\mathbf{M}_J(t) \\frac{d\\mathbf{U}}{dt} + \\mathbf{R}(t) = \\mathbf{0},\n$$\n其中 $\\mathbf{M}_J(t)$ 是随时间变化的质量矩阵，其元素为\n$$\n\\left(\\mathbf{M}_J(t)\\right)_{ij} = \\int_{-1}^{1} J(\\xi,t)\\, \\ell_i(\\xi)\\, \\ell_j(\\xi)\\, d\\xi,\n$$\n$\\mathbf{R}(t)$ 是汇集了通量项和度量项的残差向量。对于自由流情况 $u \\equiv c$，对 $\\mathbf{R}(t)$ 的唯一非平凡贡献来自于两个度量项之间的不匹配，\n$$\n\\mathbf{R}_i(t) = c\\left[ \\int_{-1}^{1} \\partial_t J(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi - \\int_{-1}^{1} \\partial_\\xi v(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi \\right].\n$$\n如果离散几何守恒律成立，即\n$$\n\\int_{-1}^{1} \\partial_t J(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi = \\int_{-1}^{1} \\partial_\\xi v(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi \\quad \\text{对所有 } i,\n$$\n则 $\\mathbf{R}(t) = \\mathbf{0}$，并且半离散格式可以精确地保持自由流 $u \\equiv c$。\n\n然而，当使用不一致或欠积分的求积法则计算 $\\partial_t J$ 的积分时（或在时间上使用不一致的逼近时），与 $\\partial_\\xi v$ 项的抵消会失败，自由流也因此无法保持。本问题要求您在曲线单元上构建一个高阶节点 DG-ALE 离散格式，展示由于 $\\partial_t J$ 中的求积/时间逼近误差导致的自由流保持性退化，并实现一个通过强制执行离散几何守恒律来恢复精确自由流保持性的修正方法。\n\n您必须：\n- 从第一性原理出发，推导自由流情况下的离散残差，并解释几何守恒律在确保精确性中的作用。\n- 实现一个程序，该程序：\n  1. 在多个曲线单元上构建一个一维节点 DG 离散，其等参映射形式为\n     $$\n     x(\\xi,t) = A(t) + B(t)\\,\\xi + C(t)\\,\\xi^2 + D(t)\\,\\xi^3\n     $$\n     每个单元的 $A(t)$、$B(t)$、$C(t)$ 和 $D(t)$ 是光滑的、随时间变化的系数，并由此导出 $J(\\xi,t) = B(t) + 2C(t)\\xi + 3D(t)\\xi^2$ 和 $v(\\xi,t) = \\partial_t x(\\xi,t)$。\n  2. 使用具有指定求积点数的 Gauss-Legendre 求积法组装随时间变化的质量矩阵 $\\mathbf{M}_J(t)$。\n  3. 以两种方式计算 $u \\equiv c$ 的残差向量 $\\mathbf{R}(t)$：\n     - 一种未修正的残差，它使用欠积分的求积法对 $\\partial_t J$ 进行积分，并用前向有限差分来逼近 $\\partial_t J$ 的时间导数，同时使用更高阶的求积法和精确的时间导数来精确地积分 $\\partial_\\xi v$。这模拟了破坏自由流保持性的求积/时间逼近误差。\n     - 一种修正后的残差，它通过将 $\\partial_t J$ 的积分替换为与 $\\partial_\\xi v$ 积分所用的相同的基于求积的投影来强制执行离散几何守恒律，从而确保\n       $$\n       \\int_{-1}^{1} \\partial_t J(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi \\equiv \\int_{-1}^{1} \\partial_\\xi v(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi\n       $$\n       在离散意义上对每个测试函数 $\\ell_i$ 成立。\n  4. 使用前向 Euler 时间步进法对自由流情况下的半离散系统进行时间推进，\n     $$\n     \\mathbf{M}_J(t^n)\\, \\frac{\\mathbf{U}^{n+1} - \\mathbf{U}^n}{\\Delta t} = - \\mathbf{R}(t^n),\n     $$\n     其中 $\\mathbf{U}^0$ 在所有节点上初始化为常数 $c$。\n  5. 计算最终时刻 $T$ 时 $u(\\xi,t)$ 相对于常数 $c$ 的最终均方根误差，该误差在由最终雅可比行列式加权的 $L^2$ 范数下度量：\n     $$\n     \\mathrm{Err} = \\left( \\frac{\\sum_{e} \\int_{-1}^{1} J_e(\\xi, T)\\, \\left(u_e(\\xi,T) - c\\right)^2\\, d\\xi}{\\sum_{e} \\int_{-1}^{1} J_e(\\xi, T)\\, d\\xi} \\right)^{1/2},\n     $$\n     其中积分使用高阶 Gauss-Legendre 求积法进行计算。\n\n设计您的实现以运行三个测试用例，这些用例共同检验该格式：\n- 测试用例 1（通用曲线、移动网格、理想情况）：两个单元，多项式阶数 $p=4$（因此每个单元有 $N=p+1=5$ 个节点），最终时间 $T=1.0$，时间步长 $\\Delta t=10^{-2}$，常数解 $c=2.0$。令\n  $$\n  \\begin{aligned}\n  A_1(t) = 0.3\\sin(1.5 t),  B_1(t) = 1 + 0.2\\sin(2 t),  C_1(t) = 0.1\\cos(t),  D_1(t) = 0.05\\sin(3 t), \\\\\n  A_2(t) = 0.25\\sin(1.3 t),  B_2(t) = 1 + 0.15\\sin(1.7 t),  C_2(t) = 0.08\\cos(0.9 t),  D_2(t) = 0.04\\sin(2.5 t).\n  \\end{aligned}\n  $$\n  质量矩阵和修正后残差积分使用 $6$ 点 Gauss-Legendre 求积，未修正的 $\\partial_t J$ 积分使用 $3$ 点 Gauss-Legendre 求积，最终误差评估和精确的 $\\partial_\\xi v$ 积分使用 $10$ 点 Gauss-Legendre 求积。报告两个浮点数：未修正的误差和修正后的误差。\n- 测试用例 2（静态网格、边界条件情况）：两个单元，相同的多项式阶数和常数 $c=2.0$，$T=1.0$，$\\Delta t=10^{-2}$，但使用静态映射\n  $$\n  A_e(t) \\equiv 0, \\quad B_e(t) \\equiv 1, \\quad C_e(t) \\equiv 0, \\quad D_e(t) \\equiv 0,\n  $$\n  对两个单元 $e=1,2$ 均如此。使用与测试用例 1 相同的求积阶数。报告两个浮点数：未修正的误差和修正后的误差。\n- 测试用例 3（剧烈曲线运动、边缘情况）：两个单元，$p=4$，$c=2.0$，$T=1.0$，$\\Delta t=5\\times 10^{-2}$。令\n  $$\n  \\begin{aligned}\n  A_1(t) = 0.3\\sin(1.8 t),  B_1(t) = 1 + 0.25\\sin(2.2 t),  C_1(t) = 0.3\\cos(1.1 t),  D_1(t) = 0.2\\sin(3.1 t), \\\\\n  A_2(t) = 0.28\\sin(1.4 t),  B_2(t) = 1 + 0.22\\sin(1.9 t),  C_2(t) = 0.27\\cos(0.95 t),  D_2(t) = 0.18\\sin(2.7 t).\n  \\end{aligned}\n  $$\n  质量矩阵和修正后残差积分使用 $6$ 点 Gauss-Legendre 求积，未修正的 $\\partial_t J$ 积分使用 $2$ 点 Gauss-Legendre 求积，最终误差评估和精确的 $\\partial_\\xi v$ 积分使用 $16$ 点 Gauss-Legendre 求积。报告两个浮点数：未修正的误差和修正后的误差。\n\n不需要物理单位；三角函数中的角度应解释为弧度。您的程序应产生单行输出，其中包含所有测试用例的结果，格式为一个逗号分隔的六个浮点数列表，并用方括号括起，顺序如下：\n$$\n[\\text{uncorrected}_1, \\text{corrected}_1, \\text{uncorrected}_2, \\text{corrected}_2, \\text{uncorrected}_3, \\text{corrected}_3].\n$$",
            "solution": "该问题要求对标量平流方程在高阶间断 Galerkin (DG) 格式下进行分析和实现，该方程定义在移动的曲线网格上，重点关注几何守恒律 (GCL) 在保持恒定流解（自由流）中的作用。\n\n### 基于原理的推导\n\n我们从具有恒定平流速度 $a$ 的一维标量守恒律开始：\n$$\n\\partial_t u + \\partial_x (a u) = 0\n$$\n该问题定义在一个具有随时间变化的曲线单元的域上。我们对每个单元使用一个等参映射 $x = x(\\xi, t)$，将坐标为 $\\xi \\in [-1, 1]$ 的固定参考单元变换到物理单元。关键的几何量是此变换的雅可比行列式 $J(\\xi, t) = \\partial_\\xi x(\\xi, t)$ 和网格速度 $v(\\xi, t) = \\partial_t x(\\xi, t)$。\n\n使用链式法则，我们可以将守恒律变换到参考单元上的任意拉格朗日-欧拉 (ALE) 框架中。得到的守恒型 ALE 公式为：\n$$\n\\partial_t (J u) + \\partial_\\xi (a u - v u) = 0\n$$\n\n任何有效数值格式的一个基本要求是其能够保持常数解，这通常被称为“自由流”或“均匀流”。让我们用常数解 $u(\\xi, t) \\equiv c$ 来检验连续 ALE 方程。将 $u=c$ 代入 ALE 方程得到：\n$$\n\\partial_t (J c) + \\partial_\\xi (a c - v c) = c\\, \\partial_t J + c\\, \\partial_\\xi a - c\\, \\partial_\\xi v\n$$\n由于平流速度 $a$ 是恒定的，$\\partial_\\xi a = 0$。方程简化为：\n$$\nc \\left( \\partial_t J - \\partial_\\xi v \\right) = 0\n$$\n这意味着要保持自由流解，几何量必须满足**连续几何守恒律 (GCL)**：\n$$\n\\partial_t J - \\partial_\\xi v = 0\n$$\n这个恒等式可以通过注意到对于光滑映射 $x(\\xi, t)$，混合偏导数相等来确认：$\\partial_t \\partial_\\xi x = \\partial_\\xi \\partial_t x$，这恰好是 $\\partial_t J = \\partial_\\xi v$。因此，连续 ALE 公式可以精确地保持自由流。\n\n挑战出现在离散化过程中。对于高阶节点 DG 格式，我们在每个单元内使用与 $N$ 个解节点 $\\{\\xi_i\\}_{i=1}^N$ 相关联的 Lagrange 多项式基 $\\{ \\ell_i(\\xi) \\}_{i=1}^{N}$ 来逼近解 $u$。通过将 ALE 方程乘以一个测试函数 $\\ell_i(\\xi)$ 并在参考单元上积分来获得半离散形式：\n$$\n\\int_{-1}^{1} \\left( \\partial_t (J u) + \\partial_\\xi ((a-v)u) \\right) \\ell_i(\\xi)\\,d\\xi = 0\n$$\n展开时间导数项 $\\partial_t(Ju) = (\\partial_t J)u + J(\\partial_t u)$ 并分离出涉及解系数 $\\mathbf{U}(t)$ 时间导数的项，得到矩阵系统：\n$$\n\\mathbf{M}_J(t) \\frac{d\\mathbf{U}}{dt} + \\mathbf{R}(t) = \\mathbf{0}\n$$\n其中 $\\mathbf{M}_J(t)$ 是质量矩阵，$\\mathbf{R}(t)$ 是残差向量。对于自由流情况 $u=c$，解系数是常数，$\\mathbf{U}(t) = c \\cdot \\mathbf{1}$，因此其时间导数为零：$d\\mathbf{U}/dt = \\mathbf{0}$。为使半离散格式能够保持此解，当 $u=c$ 时，残差向量 $\\mathbf{R}(t)$ 必须恒等于零。\n\n当 $u=c$ 时，残差的第 $i$ 个分量是：\n$$\nR_i(t) = \\int_{-1}^{1} \\left( (\\partial_t J)c + \\partial_\\xi ((a-v)c) \\right) \\ell_i(\\xi)\\,d\\xi = c \\left[ \\int_{-1}^{1} \\partial_t J\\, \\ell_i\\,d\\xi - \\int_{-1}^{1} \\partial_\\xi v\\, \\ell_i\\,d\\xi \\right]\n$$\n（来自常数 $a$ 项的贡献在分部积分后，并假设对于常数状态具有周期性或一致的单元间通量时，会消失）。为了保持自由流，我们必须对所有 $i$ 都有 $R_i(t) = 0$，这引出了**离散几何守恒律 (GCL)**：\n$$\n\\int_{-1}^{1} \\partial_t J(\\xi,t)\\,\\ell_i(\\xi)\\,d\\xi = \\int_{-1}^{1} \\partial_\\xi v(\\xi,t)\\,\\ell_i(\\xi)\\,d\\xi \\quad \\forall i\n$$\n\n问题的核心在于这两个积分的数值计算。\n1.  **未修正格式**：$\\partial_t J$ 项源于时间导数算子。在时间步进格式中，很自然地会用有限差分来逼近它，例如 $\\partial_t J(\\xi, t^n) \\approx (J(\\xi, t^{n+1}) - J(\\xi, t^n))/\\Delta t$。然而，网格速度 $v$ 是通量函数的显式部分，通常在时间 $t^n$ 进行计算。因此，离散 GCL 中的两个积分是以根本不同的方式计算的：一个使用数值时间导数，并且通常为了效率而使用低阶求积法则（欠积分）；另一个则使用解析空间导数和高阶求积法则以保证精度。这种不匹配导致非零残差 $\\mathbf{R}(t) \\neq \\mathbf{0}$，从而引入误差，并导致数值格式无法保持自由流。\n\n2.  **修正格式**：为了恢复自由流保持性，必须严格执行离散 GCL。这可以通过确保两个积分的数值计算产生相同的结果来实现。标准的修正方法是使用*相同的过程*来计算这两个积分。由于 $\\partial_t J = \\partial_\\xi v$ 在解析上成立，我们可以对两个被积函数使用解析表达式，并使用相同的求积法则（例如，用于质量矩阵的求积法则）来计算这两个积分。这种一致性保证了两个离散项能够相互抵消至机器精度，使得自由流情况下的残差 $\\mathbf{R}(t)$ 成为一个零向量。因此，$d\\mathbf{U}/dt = \\mathbf{0}$，半离散格式能够精确地保持自由流。\n\n下面的实现将通过模拟常数解在未修正和修正两种格式下的演化过程，并测量由此产生的误差，来展示这一原理。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi\nfrom numpy.polynomial.legendre import leggauss\n\ndef get_gauss_lobatto_nodes(N):\n    \"\"\"Computes the N-point Gauss-Lobatto-Legendre nodes on [-1, 1].\"\"\"\n    if N == 1:\n        return np.array([0.0])\n    if N == 2:\n        return np.array([-1.0, 1.0])\n    # Interior nodes are roots of P'_{N-1}(x), which are roots of Jacobi polynomial P_{N-2}^{(1,1)}(x)\n    interior_nodes = roots_jacobi(N - 2, 1, 1)[0]\n    return np.r_[-1.0, interior_nodes, 1.0]\n\ndef lagrange_basis(solution_nodes, evaluation_points):\n    \"\"\"\n    Computes the values of the Lagrange basis polynomials.\n    Rows correspond to basis functions, columns to evaluation points.\n    \"\"\"\n    N = len(solution_nodes)\n    M = len(evaluation_points)\n    L = np.ones((N, M))\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                L[i, :] *= (evaluation_points - solution_nodes[j]) / (solution_nodes[i] - solution_nodes[j])\n    return L\n\nclass Element:\n    \"\"\"Represents a single DG element with moving geometry.\"\"\"\n    def __init__(self, p, c, dt, mapping_coeffs, quad_orders):\n        self.p = p\n        self.N = p + 1\n        self.c = c\n        self.dt = dt\n        self.coeffs = mapping_coeffs\n        \n        nq_mass, nq_uncorr, nq_high, nq_error = quad_orders\n        \n        # Solution nodes (Gauss-Lobatto) and quadrature rules\n        self.sol_nodes = get_gauss_lobatto_nodes(self.N)\n        self.q_mass_nodes, self.q_mass_weights = leggauss(nq_mass)\n        self.q_uncorr_nodes, self.q_uncorr_weights = leggauss(nq_uncorr)\n        self.q_high_nodes, self.q_high_weights = leggauss(nq_high)\n        self.q_error_nodes, self.q_error_weights = leggauss(nq_error)\n        \n        # Pre-compute basis functions at quadrature nodes\n        self.L_mass = lagrange_basis(self.sol_nodes, self.q_mass_nodes)\n        self.L_uncorr = lagrange_basis(self.sol_nodes, self.q_uncorr_nodes)\n        self.L_high = lagrange_basis(self.sol_nodes, self.q_high_nodes)\n        self.L_error = lagrange_basis(self.sol_nodes, self.q_error_nodes)\n\n    def get_geometry(self, t, xi, derivatives=True):\n        \"\"\"Computes geometric quantities J, v, and their derivatives.\"\"\"\n        A, B, C, D = self.coeffs['A'](t), self.coeffs['B'](t), self.coeffs['C'](t), self.coeffs['D'](t)\n        J = B + 2 * C * xi + 3 * D * xi**2\n        if not derivatives:\n            return J, None, None, None\n            \n        Ad, Bd, Cd, Dd = self.coeffs['Ad'](t), self.coeffs['Bd'](t), self.coeffs['Cd'](t), self.coeffs['Dd'](t)\n        v = Ad + Bd * xi + Cd * xi**2 + Dd * xi**3\n        dJdt_exact = Bd + 2 * Cd * xi + 3 * Dd * xi**2\n        dvdxi_exact = Bd + 2 * Cd * xi + 3 * Dd * xi**2\n        \n        return J, v, dJdt_exact, dvdxi_exact\n\n    def get_mass_matrix(self, t):\n        \"\"\"Assembles the time-dependent mass matrix M_J.\"\"\"\n        J_at_mass_nodes, _, _, _ = self.get_geometry(t, self.q_mass_nodes)\n        # M_ij = integral(J * l_i * l_j dxi)\n        M_J = self.L_mass @ (np.diag(self.q_mass_weights * J_at_mass_nodes)) @ self.L_mass.T\n        return M_J\n\n    def get_residuals(self, t):\n        \"\"\"Computes both uncorrected and corrected residuals for the free-stream case.\"\"\"\n        # Uncorrected Residual\n        J_t, _, _, _ = self.get_geometry(t, self.q_uncorr_nodes, derivatives=False)\n        J_t_plus_dt, _, _, _ = self.get_geometry(t + self.dt, self.q_uncorr_nodes, derivatives=False)\n        dJdt_approx = (J_t_plus_dt - J_t) / self.dt\n        \n        _, _, _, dvdxi_exact_high = self.get_geometry(t, self.q_high_nodes)\n        \n        term1_uncorr = self.L_uncorr @ (self.q_uncorr_weights * dJdt_approx)\n        term2_uncorr = self.L_high @ (self.q_high_weights * dvdxi_exact_high)\n        R_uncorr = self.c * (term1_uncorr - term2_uncorr)\n\n        # Corrected Residual (should be zero to machine precision)\n        _, _, dJdt_exact_mass, dvdxi_exact_mass = self.get_geometry(t, self.q_mass_nodes)\n        term1_corr = self.L_mass @ (self.q_mass_weights * dJdt_exact_mass)\n        term2_corr = self.L_mass @ (self.q_mass_weights * dvdxi_exact_mass)\n        R_corr = self.c * (term1_corr - term2_corr)\n            \n        return R_uncorr, R_corr\n\n    def compute_element_error(self, U, t_final):\n        \"\"\"Computes the L2 error contribution from this element.\"\"\"\n        u_at_error_nodes = self.L_error.T @ U\n        J_final, _, _, _ = self.get_geometry(t_final, self.q_error_nodes, derivatives=False)\n        \n        sq_err_integrand = J_final * (u_at_error_nodes - self.c)**2\n        element_sq_err = np.sum(self.q_error_weights * sq_err_integrand)\n        element_vol = np.sum(self.q_error_weights * J_final)\n\n        return element_sq_err, element_vol\n\nclass DGSolver:\n    \"\"\"Manages the DG-ALE simulation over multiple elements.\"\"\"\n    def __init__(self, p, num_elements, T, dt, c, all_mappings_coeffs, quad_orders):\n        self.T = T\n        self.dt = dt\n        self.num_elements = num_elements\n        self.N = p + 1\n        \n        self.elements = [Element(p, c, dt, all_mappings_coeffs[e], quad_orders) for e in range(num_elements)]\n        \n        self.U_uncorr = np.full((num_elements, self.N), c)\n        self.U_corr = np.full((num_elements, self.N), c)\n\n    def run_simulation(self):\n        \"\"\"Executes the time-stepping loop and returns final errors.\"\"\"\n        num_steps = int(round(self.T / self.dt))\n        for n in range(num_steps):\n            t = n * self.dt\n            for e in range(self.num_elements):\n                elem = self.elements[e]\n                M_J = elem.get_mass_matrix(t)\n                R_uncorr, R_corr = elem.get_residuals(t)\n                M_J_inv = np.linalg.inv(M_J)\n                \n                # Forward Euler Step\n                self.U_uncorr[e, :] -= self.dt * (M_J_inv @ R_uncorr)\n                self.U_corr[e, :] -= self.dt * (M_J_inv @ R_corr)\n        \n        t_final = num_steps * self.dt\n        err_uncorr = self._calculate_final_error(self.U_uncorr, t_final)\n        err_corr = self._calculate_final_error(self.U_corr, t_final)\n        \n        return err_uncorr, err_corr\n\n    def _calculate_final_error(self, U_final, t_final):\n        \"\"\"Calculates the root-mean-square error over all elements.\"\"\"\n        total_sq_err, total_volume = 0.0, 0.0\n        for e in range(self.num_elements):\n            sq_err, vol = self.elements[e].compute_element_error(U_final[e, :], t_final)\n            total_sq_err += sq_err\n            total_volume += vol\n        return np.sqrt(total_sq_err / total_volume) if total_volume > 0 else 0.0\n\ndef solve():\n    \"\"\"Sets up and runs the test cases.\"\"\"\n    test_cases = [\n        {\n            \"p\": 4, \"T\": 1.0, \"dt\": 1e-2, \"c\": 2.0, \"num_elements\": 2,\n            \"quad_orders\": (6, 3, 10, 10),\n            \"mappings\": [\n                {\n                    'A': lambda t: 0.3*np.sin(1.5*t), 'Ad': lambda t: 0.3*1.5*np.cos(1.5*t),\n                    'B': lambda t: 1 + 0.2*np.sin(2*t), 'Bd': lambda t: 0.2*2*np.cos(2*t),\n                    'C': lambda t: 0.1*np.cos(t), 'Cd': lambda t: -0.1*np.sin(t),\n                    'D': lambda t: 0.05*np.sin(3*t), 'Dd': lambda t: 0.05*3*np.cos(3*t),\n                },\n                {\n                    'A': lambda t: 0.25*np.sin(1.3*t), 'Ad': lambda t: 0.25*1.3*np.cos(1.3*t),\n                    'B': lambda t: 1 + 0.15*np.sin(1.7*t), 'Bd': lambda t: 0.15*1.7*np.cos(1.7*t),\n                    'C': lambda t: 0.08*np.cos(0.9*t), 'Cd': lambda t: -0.08*0.9*np.sin(0.9*t),\n                    'D': lambda t: 0.04*np.sin(2.5*t), 'Dd': lambda t: 0.04*2.5*np.cos(2.5*t),\n                }\n            ]\n        },\n        {\n            \"p\": 4, \"T\": 1.0, \"dt\": 1e-2, \"c\": 2.0, \"num_elements\": 2,\n            \"quad_orders\": (6, 3, 10, 10),\n            \"mappings\": [\n                {\n                    'A': lambda t: 0.0, 'Ad': lambda t: 0.0, 'B': lambda t: 1.0, 'Bd': lambda t: 0.0,\n                    'C': lambda t: 0.0, 'Cd': lambda t: 0.0, 'D': lambda t: 0.0, 'Dd': lambda t: 0.0,\n                },\n                {\n                    'A': lambda t: 0.0, 'Ad': lambda t: 0.0, 'B': lambda t: 1.0, 'Bd': lambda t: 0.0,\n                    'C': lambda t: 0.0, 'Cd': lambda t: 0.0, 'D': lambda t: 0.0, 'Dd': lambda t: 0.0,\n                }\n            ]\n        },\n        {\n            \"p\": 4, \"T\": 1.0, \"dt\": 5e-2, \"c\": 2.0, \"num_elements\": 2,\n            \"quad_orders\": (6, 2, 16, 16),\n            \"mappings\": [\n                {\n                    'A': lambda t: 0.3*np.sin(1.8*t), 'Ad': lambda t: 0.3*1.8*np.cos(1.8*t),\n                    'B': lambda t: 1 + 0.25*np.sin(2.2*t), 'Bd': lambda t: 0.25*2.2*np.cos(2.2*t),\n                    'C': lambda t: 0.3*np.cos(1.1*t), 'Cd': lambda t: -0.3*1.1*np.sin(1.1*t),\n                    'D': lambda t: 0.2*np.sin(3.1*t), 'Dd': lambda t: 0.2*3.1*np.cos(3.1*t),\n                },\n                {\n                    'A': lambda t: 0.28*np.sin(1.4*t), 'Ad': lambda t: 0.28*1.4*np.cos(1.4*t),\n                    'B': lambda t: 1 + 0.22*np.sin(1.9*t), 'Bd': lambda t: 0.22*1.9*np.cos(1.9*t),\n                    'C': lambda t: 0.27*np.cos(0.95*t), 'Cd': lambda t: -0.27*0.95*np.sin(0.95*t),\n                    'D': lambda t: 0.18*np.sin(2.7*t), 'Dd': lambda t: 0.18*2.7*np.cos(2.7*t),\n                }\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        solver = DGSolver(\n            p=case[\"p\"], num_elements=case[\"num_elements\"], T=case[\"T\"],\n            dt=case[\"dt\"], c=case[\"c\"], all_mappings_coeffs=case[\"mappings\"],\n            quad_orders=case[\"quad_orders\"]\n        )\n        err_uncorr, err_corr = solver.run_simulation()\n        results.extend([err_uncorr, err_corr])\n    \n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "构建精确可靠的高阶ALE格式，不仅需要理解守恒律，还需要对各种误差来源进行系统性的分析。本练习提供了一个定量的分析框架，用于评估在设计DG-ALE格式时，不同的选择（如数值积分的精度和几何项的时间处理方式）将如何影响最终的数值精度。通过这个实践，您将掌握从一开始就设计出健壮数值格式所必需的分析工具，而不是在事后修复问题 。",
            "id": "3423615",
            "problem": "考虑一个一维任意拉格朗日-欧拉 (ALE) 格式，用于求解通过间断伽辽金 (DG) 方法离散化的线性标量守恒律。令参考坐标为 $X$，物理坐标为 $x(X,t)$。定义映射的雅可比为 $J(X,t) = \\partial x / \\partial X$，网格速度为 $w(X,t) = \\partial x / \\partial t$。偏微分方程的守恒 ALE 形式为\n$$\n\\partial_t \\big(J\\,u\\big) + \\partial_X \\big(F(u) - u\\,w\\big) = 0,\n$$\n其中 $u(X,t)$ 是参考空间解，$F(u)$ 是物理通量。假设物理通量是线性的，$F(u) = c\\,u$，其中速度 $c \\in \\mathbb{R}$ 为常数，当 $c$ 非零时，它在分析中不影响多项式次数。DG 离散化对试探函数和检验函数使用次数为 $p$ 的单元多项式，体积分和面积分分别通过具有 $N_v$ 个点和 $N_s$ 个点的高斯-勒让德求积法进行计算。\n\n假设在每个单元上，雅可比 $J(X,t)$ 是关于 $X$ 的次数为 $q_J$ 的多项式，网格速度 $w(X,t)$ 是关于 $X$ 的次数为 $q_w$ 的多项式。考虑一个 $r$ 阶精度的显式龙格-库塔时间积分器。网格是平滑变形的，这意味着 $J$ 和 $w$ 在时间和空间上足够可微。\n\n从第一性原理出发，DG 弱形式包含以下被积函数：\n- 体积分项涉及 $J\\,u\\,v$ 形式的乘积，其中 $u$ 和 $v$ 是次数为 $p$ 的多项式。体积分被积函数的多项式次数为 $D_v = 2p + q_J$。\n- 面积分项涉及 $F(u) - u\\,w$，乘以单元边界处的检验函数迹；对于一维情况下积分面上被积函数的多项式次数计算，当 $F$ 是线性的，可将其次数上限定为 $D_s = p + q_w$。\n\n具有 $N$ 个点的高斯-勒让德求积法可以精确积分次数最高为 $2N - 1$ 的多项式。为保持 $p$ 阶空间精度，需要对弱形式中的多项式进行精确积分。因此，保证精确性的最小求积点数为\n$$\nN_v^{\\min} = \\left\\lceil \\frac{D_v + 1}{2} \\right\\rceil = \\left\\lceil \\frac{2p + q_J + 1}{2} \\right\\rceil,\\quad\nN_s^{\\min} = \\left\\lceil \\frac{D_s + 1}{2} \\right\\rceil = \\left\\lceil \\frac{p + q_w + 1}{2} \\right\\rceil.\n$$\n\n当选择的求积点数 $N_v$ 和 $N_s$ 低于保证精确性所需的最小值时，保证的空间精度受限于积分的精确次数：\n- 对于体积分项，精确到次数 $2N_v - 1$ 意味着最大试探次数 $p_v^{\\mathrm{eff}}$ 满足 $2p_v^{\\mathrm{eff}} + q_J \\le 2N_v - 1$，得出\n$$\np_v^{\\mathrm{eff}} = \\min\\!\\left(p,\\, \\left\\lfloor \\frac{2N_v - 1 - q_J}{2} \\right\\rfloor \\right),\n$$\n约定负值截断为 $0$。\n- 对于面积分项，精确到次数 $2N_s - 1$ 意味着最大试探次数 $p_s^{\\mathrm{eff}}$ 满足 $p_s^{\\mathrm{eff}} + q_w \\le 2N_s - 1$，得出\n$$\np_s^{\\mathrm{eff}} = \\min\\!\\left(p,\\, 2N_s - 1 - q_w \\right),\n$$\n约定负值截断为 $0$。\n\n那么，保证的空间收敛阶（在光滑区域相对于网格尺寸）为\n$$\nP_{\\mathrm{space}} = \\min\\!\\big(p_v^{\\mathrm{eff}} + 1,\\; p_s^{\\mathrm{eff}} + 1\\big).\n$$\n\n对于时间精度，几何守恒律 (GCL) 要求\n$$\n\\partial_t J = \\partial_X w,\n$$\n在离散层面成立，以保持常数解。如果度量项（$J$ 和 $w$）在时间上滞后，即使用前一个时间步的值而不是当前龙格-库塔阶段的值进行计算，那么时间上的函数求值会因缺少更新而引入 $\\mathcal{O}(\\Delta t)$ 的误差，这对于非平凡的网格运动，会将有效时间阶降至一阶。特别地，定义一个网格運動振幅参数 $A_w \\ge 0$，当且仅当网格静止时该参数为零。在度量项完全滞后的情况下：\n- 如果 $A_w = 0$，则 $r_{\\mathrm{eff}} = r$。\n- 如果 $A_w  0$，则 $r_{\\mathrm{eff}} = 1$。\n\n总体格式阶受空间和时间阶的最小值限制：\n$$\nP_{\\mathrm{total}} = \\min\\!\\big(P_{\\mathrm{space}},\\, r_{\\mathrm{eff}}\\big).\n$$\n由滞后引起的时间阶损失量化为\n$$\nL_{\\mathrm{time}} = r - r_{\\mathrm{eff}}.\n$$\n\n实现一个程序，对每个测试用例计算以下整数输出：\n- $N_v^{\\min}$,\n- $N_s^{\\min}$,\n- $P_{\\mathrm{space}}$,\n- $r_{\\mathrm{eff}}$,\n- $P_{\\mathrm{total}}$,\n- $L_{\\mathrm{time}}$.\n\n使用上述公式。对于中间计算出的负值 $p_v^{\\mathrm{eff}}$ 或 $p_s^{\\mathrm{eff}}$，在计算 $P_{\\mathrm{space}}$ 中加 $1$ 之前将其截断为 $0$。最终输出应将所有测试用例的结果聚合到单行中，形式为一个用方括号括起来的逗号分隔列表，其中每个测试用例的结果是按上述顺序排列的列表。\n\n测试套件（每个元组为 $(p, q_J, q_w, r, N_v, N_s, A_w)$）：\n- 情况 1 (体积分普遍欠积分，面积分足够): $(3, 2, 2, 3, 4, 3, 0.1)$。\n- 情况 2 (网格静止，求积足够): $(1, 1, 1, 2, 2, 2, 0.0)$。\n- 情况 3 (分片常数与高次几何，面积分欠积分): $(0, 3, 3, 1, 2, 1, 0.5)$。\n- 情况 4 (网格静止时较高的 $p$，体积分和面积分均欠积分): $(4, 1, 0, 4, 4, 2, 0.0)$。\n- 情况 5 (体积分足够，面积分在移动网格下欠积分): $(2, 0, 2, 3, 3, 2, 0.2)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,\\dots]$），其中每个 $result_i$ 是第 $i$ 个测试用例的列表 $[N_v^{\\min},N_s^{\\min},P_{\\mathrm{space}},r_{\\mathrm{eff}},P_{\\mathrm{total}},L_{\\mathrm{time}}]$。不需要物理单位，也不涉及角度；所有输出都是纯整数。",
            "solution": "此问题要求为在各种参数配置下的 DG-ALE 数值格式计算一组六个性能和精度指标。这些指标是：体积分 ($N_v^{\\min}$) 和面积分 ($N_s^{\\min}$) 所需的最小求积点数、有效空间收敛阶 ($P_{\\mathrm{space}}$)、有效时间收敛阶 ($r_{\\mathrm{eff}}$)、总格式阶 ($P_{\\mathrm{total}}$) 以及由滞后引起的时间阶损失 ($L_{\\mathrm{time}}$)。\n\n计算过程是系统地对每个测试用例应用所提供的公式。\n\n1.  **最小求积点数计算** ($N_v^{\\min}, N_s^{\\min}$):\n    -   体积分被积函数的多项式次数为 $D_v = 2p + q_J$。最小高斯求积点数为 $N_v^{\\min} = \\lceil (D_v + 1)/2 \\rceil$。\n    -   面积分被积函数的多项式次数为 $D_s = p + q_w$。最小高斯求积点数为 $N_s^{\\min} = \\lceil (D_s + 1)/2 \\rceil$。\n\n2.  **有效空间阶计算** ($P_{\\mathrm{space}}$):\n    -   当求积不精确时（即 $N_v  N_v^{\\min}$ 或 $N_s  N_s^{\\min}$），精度阶会受限。\n    -   体积分支持的有效多项式次数为 $p_v^{\\mathrm{eff}} = \\max(0, \\lfloor (2N_v - 1 - q_J) / 2 \\rfloor)$。\n    -   面积分支持的有效多项式次数为 $p_s^{\\mathrm{eff}} = \\max(0, 2N_s - 1 - q_w)$。\n    -   保证的空间收敛阶为 $P_{\\mathrm{space}} = \\min(p_v^{\\mathrm{eff}} + 1, p_s^{\\mathrm{eff}} + 1)$。\n\n3.  **有效时间阶计算** ($r_{\\mathrm{eff}}$):\n    -   如果网格是静止的 ($A_w = 0$)，则有效时间阶等于龙格-库塔积分器的原始阶 $r$。\n    -   如果网格是移动的 ($A_w > 0$) 并且度量项被滞后处理，则有效时间阶降至一阶，$r_{\\mathrm{eff}} = 1$。\n\n4.  **总格式阶和时间阶损失计算** ($P_{\\mathrm{total}}, L_{\\mathrm{time}}$):\n    -   总格式阶是空间阶和时间阶的最小值：$P_{\\mathrm{total}} = \\min(P_{\\mathrm{space}}, r_{\\mathrm{eff}})$。\n    -   时间阶损失是原始阶与有效阶之差：$L_{\\mathrm{time}} = r - r_{\\mathrm{eff}}$。\n\n对每个测试用例应用这些公式，得到以下结果：\n\n-   **情况 1**: $(p, q_J, q_w, r, N_v, N_s, A_w) = (3, 2, 2, 3, 4, 3, 0.1)$\n    -   $N_v^{\\min} = \\lceil (2\\cdot3+2+1)/2 \\rceil = 5$\n    -   $N_s^{\\min} = \\lceil (3+2+1)/2 \\rceil = 3$\n    -   $p_v^{\\mathrm{eff}} = \\min(3, \\lfloor (2\\cdot4-1-2)/2 \\rfloor) = 2$\n    -   $p_s^{\\mathrm{eff}} = \\min(3, 2\\cdot3-1-2) = 3$\n    -   $P_{\\mathrm{space}} = \\min(2+1, 3+1) = 3$\n    -   $r_{\\mathrm{eff}} = 1$ (因为 $A_w > 0$)\n    -   $P_{\\mathrm{total}} = \\min(3, 1) = 1$\n    -   $L_{\\mathrm{time}} = 3 - 1 = 2$\n    -   结果: $[5, 3, 3, 1, 1, 2]$\n\n-   **情况 2**: $(p, q_J, q_w, r, N_v, N_s, A_w) = (1, 1, 1, 2, 2, 2, 0.0)$\n    -   $N_v^{\\min} = \\lceil (2\\cdot1+1+1)/2 \\rceil = 2$\n    -   $N_s^{\\min} = \\lceil (1+1+1)/2 \\rceil = 2$\n    -   $p_v^{\\mathrm{eff}} = \\min(1, \\lfloor (2\\cdot2-1-1)/2 \\rfloor) = 1$\n    -   $p_s^{\\mathrm{eff}} = \\min(1, 2\\cdot2-1-1) = 1$\n    -   $P_{\\mathrm{space}} = \\min(1+1, 1+1) = 2$\n    -   $r_{\\mathrm{eff}} = 2$ (因为 $A_w = 0$)\n    -   $P_{\\mathrm{total}} = \\min(2, 2) = 2$\n    -   $L_{\\mathrm{time}} = 2 - 2 = 0$\n    -   结果: $[2, 2, 2, 2, 2, 0]$\n\n-   **情况 3**: $(p, q_J, q_w, r, N_v, N_s, A_w) = (0, 3, 3, 1, 2, 1, 0.5)$\n    -   $N_v^{\\min} = \\lceil (2\\cdot0+3+1)/2 \\rceil = 2$\n    -   $N_s^{\\min} = \\lceil (0+3+1)/2 \\rceil = 2$\n    -   $p_v^{\\mathrm{eff}} = \\max(0, \\min(0, \\lfloor (2\\cdot2-1-3)/2 \\rfloor)) = 0$\n    -   $p_s^{\\mathrm{eff}} = \\max(0, \\min(0, 2\\cdot1-1-3)) = 0$\n    -   $P_{\\mathrm{space}} = \\min(0+1, 0+1) = 1$\n    -   $r_{\\mathrm{eff}} = 1$ (因为 $A_w > 0$)\n    -   $P_{\\mathrm{total}} = \\min(1, 1) = 1$\n    -   $L_{\\mathrm{time}} = 1 - 1 = 0$\n    -   结果: $[2, 2, 1, 1, 1, 0]$\n\n-   **情况 4**: $(p, q_J, q_w, r, N_v, N_s, A_w) = (4, 1, 0, 4, 4, 2, 0.0)$\n    -   $N_v^{\\min} = \\lceil (2\\cdot4+1+1)/2 \\rceil = 5$\n    -   $N_s^{\\min} = \\lceil (4+0+1)/2 \\rceil = 3$\n    -   $p_v^{\\mathrm{eff}} = \\min(4, \\lfloor (2\\cdot4-1-1)/2 \\rfloor) = 3$\n    -   $p_s^{\\mathrm{eff}} = \\min(4, 2\\cdot2-1-0) = 3$\n    -   $P_{\\mathrm{space}} = \\min(3+1, 3+1) = 4$\n    -   $r_{\\mathrm{eff}} = 4$ (因为 $A_w = 0$)\n    -   $P_{\\mathrm{total}} = \\min(4, 4) = 4$\n    -   $L_{\\mathrm{time}} = 4 - 4 = 0$\n    -   结果: $[5, 3, 4, 4, 4, 0]$\n\n-   **情况 5**: $(p, q_J, q_w, r, N_v, N_s, A_w) = (2, 0, 2, 3, 3, 2, 0.2)$\n    -   $N_v^{\\min} = \\lceil (2\\cdot2+0+1)/2 \\rceil = 3$\n    -   $N_s^{\\min} = \\lceil (2+2+1)/2 \\rceil = 3$\n    -   $p_v^{\\mathrm{eff}} = \\min(2, \\lfloor (2\\cdot3-1-0)/2 \\rfloor) = 2$\n    -   $p_s^{\\mathrm{eff}} = \\min(2, 2\\cdot2-1-2) = 1$\n    -   $P_{\\mathrm{space}} = \\min(2+1, 1+1) = 2$\n    -   $r_{\\mathrm{eff}} = 1$ (因为 $A_w > 0$)\n    -   $P_{\\mathrm{total}} = \\min(2, 1) = 1$\n    -   $L_{\\mathrm{time}} = 3 - 1 = 2$\n    -   结果: $[3, 3, 2, 1, 1, 2]$\n\n以下是生成这些结果的实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes accuracy and quadrature metrics for a DG-ALE scheme.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (p, q_J, q_w, r, N_v, N_s, A_w)\n    test_cases = [\n        (3, 2, 2, 3, 4, 3, 0.1),  # Case 1\n        (1, 1, 1, 2, 2, 2, 0.0),  # Case 2\n        (0, 3, 3, 1, 2, 1, 0.5),  # Case 3\n        (4, 1, 0, 4, 4, 2, 0.0),  # Case 4\n        (2, 0, 2, 3, 3, 2, 0.2),  # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        p, q_J, q_w, r, N_v, N_s, A_w = case\n\n        # 1. Minimum Volume Quadrature Points, N_v_min\n        D_v = 2 * p + q_J\n        N_v_min = int(np.ceil((D_v + 1) / 2))\n\n        # 2. Minimum Surface Quadrature Points, N_s_min\n        D_s = p + q_w\n        N_s_min = int(np.ceil((D_s + 1) / 2))\n\n        # 3. Effective Spatial Order, P_space\n        # Calculate effective polynomial degree for volume integrals\n        p_v_eff_raw = min(p, np.floor((2 * N_v - 1 - q_J) / 2))\n        # Clamp to 0 if negative\n        p_v_eff = max(0, int(p_v_eff_raw))\n\n        # Calculate effective polynomial degree for surface integrals\n        p_s_eff_raw = min(p, 2 * N_s - 1 - q_w)\n        # Clamp to 0 if negative\n        p_s_eff = max(0, int(p_s_eff_raw))\n\n        # Calculate guaranteed spatial convergence order\n        P_space = min(p_v_eff + 1, p_s_eff + 1)\n\n        # 4. Effective Temporal Order, r_eff\n        # Order drops to 1 if mesh is moving (A_w > 0) and metrics are lagged\n        r_eff = 1 if A_w > 0 else r\n\n        # 5. Total Scheme Order, P_total\n        # Overall order is the minimum of spatial and temporal orders\n        P_total = min(P_space, r_eff)\n\n        # 6. Temporal Order Loss, L_time\n        # Loss due to lagging\n        L_time = r - r_eff\n\n        results.append([N_v_min, N_s_min, P_space, r_eff, P_total, L_time])\n\n    # Format the final output string to exactly match the required format.\n    # The format is a list of lists, represented as a string without spaces.\n    inner_results_str = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(inner_results_str)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}