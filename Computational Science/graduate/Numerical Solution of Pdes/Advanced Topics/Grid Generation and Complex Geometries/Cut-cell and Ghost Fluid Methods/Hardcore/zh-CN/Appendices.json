{
    "hands_on_practices": [
        {
            "introduction": "在显式时间积分方案中，著名的“小单元问题”是一个核心挑战。由于时间步长必须满足CFL稳定性条件，而该条件与网格单元的体积成正比，因此微小的切割单元会迫使时间步长缩减到不切实际的程度。本练习通过一个一维热传导方程的例子，让您亲手量化这个问题，并探索一种经典的稳定化技术——单元合并法（cell merging）。您将对比一个朴素的、不稳定的更新步骤和一个经过稳定化处理的更新步骤，从而直观地理解稳定化方法在克服数值刚性方面的巨大威力。",
            "id": "3376330",
            "problem": "考虑一维无量纲热方程 $u_{t}=\\kappa\\,u_{xx}$，其扩散系数 $\\kappa0$ 为常数。该方程定义在一个由两个有限体积单元表示的短段上，其中一个浸入式固体边界将左侧单元切割成一个与常规流体单元相邻的微小流体子单元。左侧单元 $C_{0}$ 名义上跨越 $[0,\\Delta x]$，右侧单元 $C_{1}$ 跨越 $[\\Delta x,2\\Delta x]$，网格间距 $\\Delta x$ 均匀。一个浸入式边界在位置 $x_{L}=\\Delta x-\\varepsilon\\,\\Delta x$ 处与 $C_{0}$ 相交，在 $x=\\Delta x$ 处留下一个长度为 $\\ell=\\varepsilon\\,\\Delta x$ 的流体子单元。位于 $x=2\\Delta x$ 的外部右边界服从齐次诺伊曼条件。浸入式边界上的 $u$ 值由狄利克雷条件 $u(x_{L},t)=u_{b}$ 指定，该条件通过虚拟流体法（GFM）强制施加，其中切割面处的扩散通量根据单元代表值与边界值之间基于到切割面的几何距离的单侧线性梯度计算得出。\n\n给定以下无量纲参数和初始数据：\n- $\\Delta x=1$,\n- $\\varepsilon=0.1$ (因此 $\\ell=0.1$),\n- $\\kappa=1$,\n- 时间步长 $\\Delta t=0.2$ (前向欧拉法),\n- 在 $x=x_{L}$ 处 $u_{b}=0$,\n- $C_{0}$ 中的初始单元平均值 $U_{0}^{n}=1$，$C_{1}$ 中的初始单元平均值 $U_{1}^{n}=1$。\n\n几何数据：\n- $C_{0}$ 的流体部分占据 $[x_{L},\\Delta x]=[0.9,1]$，因此其形心位于 $x_{c,0}=0.95$，体积（长度）为 $V_{0}=\\ell=0.1$。\n- 常规单元 $C_{1}$ 占据 $[1,2]$，其形心为 $x_{c,1}=1.5$，体积为 $V_{1}=1$。\n- 形心到 $x=1$ 处界面的距离为 $d_{0}=1-x_{c,0}=0.05$ 和 $d_{1}=x_{c,1}-1=0.5$。$x_{c,0}$ 到 $x_{L}$ 处切割面的距离为 $d_{L}=x_{c,0}-x_{L}=0.05$。\n\n任务 A（对切割单元进行朴素显式更新）：使用从守恒律 $u_{t}=\\kappa u_{xx}$ 推导出的有限体积法，用与非均匀距离相符的线性两点公式来近似面上的梯度。对于 $x=1$ 处的内界面，使用常用的两点近似 $\\partial u/\\partial x\\big|_{1} \\approx (U_{1}^{n}-U_{0}^{n})/(d_{0}+d_{1})$。对于 $x=x_{L}$ 处的浸入边界面，通过取 $\\partial u/\\partial x\\big|_{x_{L}^{+}} \\approx (U_{0}^{n}-u_{b})/d_{L}$ 来通过 GFM 施加狄利克雷边界。对 $C_{0}$ 执行单步前向欧拉法，以计算 $U_{0,\\text{naive}}^{n+1}$。\n\n任务 B（单元合并稳定更新）：将 $C_{0}$ 和 $C_{1}$ 合并成一个长度为 $V_{m}=V_{0}+V_{1}=1.1$ 的单一控制体积。令合并后的平均值为 $U_{m}^{n}=(V_{0}U_{0}^{n}+V_{1}U_{1}^{n})/V_{m}$。合并后的形心为 $x_{c,m}=(V_{0}x_{c,0}+V_{1}x_{c,1})/V_{m}$，且 $x_{c,m}$ 到切割面的距离为 $d_{m}=x_{c,m}-x_{L}$。通过仅使用外部边界面，对合并后的平均值执行单步前向欧拉法进行更新：\n- 在 $x=2$ 处，施加 $\\partial u/\\partial x=0$。\n- 在 $x=x_{L}$ 处，近似 $\\partial u/\\partial x\\big|_{x_{L}^{+}} \\approx (U_{m}^{n}-u_{b})/d_{m}$。\n设 $U_{0,\\text{merge}}^{n+1}:=U_{m}^{n+1}$ 为合并后稳定化的切割单元值。\n\n计算标量差\n$$\\delta \\;=\\; U_{0,\\text{merge}}^{n+1}\\;-\\;U_{0,\\text{naive}}^{n+1}.$$\n将 $\\delta$ 报告为一个无量纲数，四舍五入到四位有效数字。",
            "solution": "我们发现问题陈述是有效的，因为它科学上基于偏微分方程数值方法的原理，是适定的，提供了所有必要信息，并且以客观、无歧义的语言表述。因此，我们可以着手求解。\n\n问题要求计算一个切割单元的两个更新值之差，一个是用朴素显式方法计算的，另一个是用稳定化的单元合并方法计算的。我们按顺序处理每个任务。\n\n首先，我们处理任务 A：对切割单元 $C_{0}$ 进行朴素显式更新。一维热方程为 $u_{t}=\\kappa u_{xx}$。对单元 $C_{0}$ 的流体部分应用有限体积法，该部分体积（长度）为 $V_{0}$，占据区间 $[x_{L}, \\Delta x]$，我们将偏微分方程在该体积上积分：\n$$ \\int_{V_0} u_t \\,dx = \\int_{V_0} \\kappa u_{xx} \\,dx $$\n假设单元平均值为 $U_{0}(t) = \\frac{1}{V_{0}} \\int_{V_0} u(x,t) \\,dx$，则左侧变为 $V_{0}\\frac{dU_{0}}{dt}$。根据微积分基本定理，右侧变为 $\\kappa u_{x}|_{\\Delta x} - \\kappa u_{x}|_{x_{L}}$。这得到半离散方程：\n$$ V_{0} \\frac{dU_{0}}{dt} = \\kappa \\left( \\frac{\\partial u}{\\partial x}\\bigg|_{x=\\Delta x} - \\frac{\\partial u}{\\partial x}\\bigg|_{x=x_{L}} \\right) $$\n应用时间步长为 $\\Delta t$ 的前向欧拉时间积分格式，我们得到全离散更新公式：\n$$ U_{0}^{n+1} = U_{0}^{n} + \\frac{\\Delta t \\kappa}{V_{0}} \\left( \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=\\Delta x}^{n} - \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=x_{L}}^{n} \\right) $$\n问题指明了空间导数（通量）的近似方法：\n- 在内界面 $x=\\Delta x=1$ 处：$\\left(\\frac{\\partial u}{\\partial x}\\right)\\big|_{x=\\Delta x}^{n} \\approx \\frac{U_{1}^{n}-U_{0}^{n}}{d_{0}+d_{1}}$\n- 在浸入边界面 $x=x_{L}$ 处：$\\left(\\frac{\\partial u}{\\partial x}\\right)\\big|_{x=x_{L}^{+}}^{n} \\approx \\frac{U_{0}^{n}-u_{b}}{d_{L}}$\n\n我们代入给定的数值：$\\Delta x=1$, $\\varepsilon=0.1$, $\\kappa=1$, $\\Delta t=0.2$, $u_{b}=0$, $U_{0}^{n}=1$, $U_{1}^{n}=1$。\n几何数据：$V_{0}=0.1$, $x_{L}=0.9$, $x_{c,0}=0.95$, $d_{0}=1-x_{c,0}=0.05$, $d_{1}=x_{c,1}-1=0.5$, 以及 $d_{L}=x_{c,0}-x_{L}=0.05$。\n\n首先，我们计算步骤 $n$ 处的近似梯度：\n$$ \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=1}^{n} \\approx \\frac{1-1}{0.05+0.5} = \\frac{0}{0.55} = 0 $$\n$$ \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=0.9}^{n} \\approx \\frac{1-0}{0.05} = 20 $$\n现在，我们将这些代入 $U_{0,\\text{naive}}^{n+1}$ 的更新公式中：\n$$ U_{0,\\text{naive}}^{n+1} = U_{0}^{n} + \\frac{\\Delta t \\kappa}{V_{0}} \\left( 0 - 20 \\right) = 1 + \\frac{0.2 \\times 1}{0.1} \\left(-20\\right) = 1 + 2(-20) = 1 - 40 = -39 $$\n所以，$U_{0,\\text{naive}}^{n+1} = -39$。巨大的量值和负号表明存在数值不稳定性，这对于在此时间步长下对小切割单元使用显式格式是预料之中的。\n\n接下来，我们处理任务 B：单元合并稳定更新。将切割单元 $C_{0}$ 与其邻近单元 $C_{1}$ 合并，形成一个更大的单一控制体积 $C_{m}$。\n首先，我们确定合并后单元的属性。\n- 合并后体积：$V_{m} = V_{0} + V_{1} = 0.1 + 1 = 1.1$。\n- 时间 $n$ 时的合并单元平均值：$U_{m}^{n} = \\frac{V_{0}U_{0}^{n} + V_{1}U_{1}^{n}}{V_{m}} = \\frac{0.1 \\times 1 + 1 \\times 1}{1.1} = \\frac{1.1}{1.1} = 1$。\n- 合并单元形心：$x_{c,m} = \\frac{V_{0}x_{c,0} + V_{1}x_{c,1}}{V_{m}} = \\frac{0.1 \\times 0.95 + 1 \\times 1.5}{1.1} = \\frac{0.095 + 1.5}{1.1} = \\frac{1.595}{1.1} = 1.45$。\n- 合并后形心到切割面的距离：$d_{m} = x_{c,m} - x_{L} = 1.45 - 0.9 = 0.55$。\n\n合并后的控制体积占据区间 $[x_{L}, 2\\Delta x] = [0.9, 2]$。有限体积更新是在这个更大的单元上进行的，仅使用其外部边界（$x=x_{L}$ 和 $x=2$）上的通量。\n$$ U_{m}^{n+1} = U_{m}^{n} + \\frac{\\Delta t \\kappa}{V_{m}} \\left( \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=2}^{n} - \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=x_{L}}^{n} \\right) $$\n合并单元更新的边界条件是：\n- 在 $x=2$ 处：齐次诺伊曼条件，$\\frac{\\partial u}{\\partial x} = 0$。\n- 在 $x=x_{L}$ 处：虚拟流体法近似，$\\left(\\frac{\\partial u}{\\partial x}\\right)\\big|_{x=x_{L}^{+}}^{n} \\approx \\frac{U_{m}^{n} - u_{b}}{d_{m}}$。\n\n我们计算在 $x=x_{L}$ 处所需的梯度：\n$$ \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=0.9}^{n} \\approx \\frac{1 - 0}{0.55} = \\frac{1}{0.55} $$\n代入 $U_{m}^{n+1}$ 的更新公式中：\n$$ U_{m}^{n+1} = U_{m}^{n} + \\frac{\\Delta t \\kappa}{V_{m}} \\left( 0 - \\frac{1}{0.55} \\right) = 1 + \\frac{0.2 \\times 1}{1.1} \\left( -\\frac{1}{0.55} \\right) = 1 - \\frac{0.2}{1.1 \\times 0.55} = 1 - \\frac{0.2}{0.605} $$\n$$ U_{m}^{n+1} = 1 - \\frac{200}{605} = 1 - \\frac{40}{121} = \\frac{121 - 40}{121} = \\frac{81}{121} $$\n稳定化的切割单元值被设置为该合并值：$U_{0,\\text{merge}}^{n+1} = U_{m}^{n+1} = \\frac{81}{121}$。\n数值上，这约等于 $0.6694214876$。\n\n最后，我们计算标量差 $\\delta$：\n$$ \\delta = U_{0,\\text{merge}}^{n+1} - U_{0,\\text{naive}}^{n+1} $$\n$$ \\delta = \\frac{81}{121} - (-39) = 39 + \\frac{81}{121} \\approx 39 + 0.6694214876 = 39.6694214876 $$\n问题要求将此值四舍五入到四位有效数字。该数为 $39.6694...$。前四位有效数字是 $3$、$9$、$6$、$6$。第五位数字是 $9$，它 $\\ge 5$，所以我们将第四位数字向上取整。\n$$ \\delta \\approx 39.67 $$\n这个结果凸显了在显式时间步进格式中，处理小切割单元时，不稳定的朴素更新与稳定的单元合并方法之间的巨大差异。",
            "answer": "$$\n\\boxed{39.67}\n$$"
        },
        {
            "introduction": "切割单元和鬼点法的应用远不止于处理稳定性问题，它们在精确施加复杂物理边界条件方面也至关重要。例如，在两相流模拟中，界面上的表面张力会引起压力跳跃，其大小由Young-Laplace方程 $\\Delta p = \\sigma \\kappa$ 决定，这要求我们必须精确计算界面的曲率 $\\kappa$。本编码练习将引导您探究界面几何重构的精度如何直接影响物理模型的保真度。通过比较线性重构与二次重构在计算曲率和压力跳跃时的误差，您将深刻体会到为特定物理问题选择合适重构阶数的重要性。",
            "id": "3376339",
            "problem": "考虑一个由流体体积（VOF）方法捕捉的二维不可压缩两相界面，其压力通过鬼影流体法（GFM）进行耦合。GFM根据毛细压力跳跃在界面上施加一个压力不连续性。该跳跃由拉普拉斯定律给出，该定律指出压力跳跃等于表面张力乘以界面曲率。界面是光滑的，局部曲率是通过在均匀网格内重建界面形状来计算的。\n\n基本原理：\n- 拉普拉斯压力跳跃：如果界面曲率为 $\\,\\kappa\\,$，表面张力系数为 $\\,\\sigma\\,$，则界面上的压力跳跃为 $\\,\\Delta p = \\sigma \\kappa\\,$。\n- 参数化为 $\\,y(x)\\,$ 的平面曲线的曲率由下式给出\n$$\n\\kappa(x) = \\frac{y''(x)}{\\left(1 + \\left(y'(x)\\right)^2\\right)^{3/2}}.\n$$\n\n界面配置：\n- 界面解析地表示为一个正弦函数，\n$$\ny(x) = a \\sin\\left( \\frac{2\\pi}{\\lambda} x \\right),\n$$\n其中 $\\,a\\,$ 是振幅（单位：米），$\\,\\lambda\\,$ 是波长（单位：米）。\n- 空间域在 $\\,x\\,$ 方向上以一个波长 $\\,\\lambda\\,$ 为周期。\n- 一个由 $\\,N_x\\,$ 个点组成的均匀网格在位置 $\\,x_i = i \\Delta x\\,$（对于 $\\,i=0,1,\\dots,N_x-1\\,$）处对界面进行采样，其中 $\\,\\Delta x = \\lambda/N_x\\,$。\n\n重建策略：\n- 线性界面重建：用一阶多项式逼近 $\\,x_i\\,$ 附近的局部界面，\n$$\ny(x) \\approx \\alpha_i + \\beta_i (x - x_i),\n$$\n这得出 $\\,y''(x_i) \\approx 0\\,$，因此 $\\,\\kappa_{\\text{lin}}(x_i) \\approx 0\\,$。\n- 二次界面重建：使用最小二乘法，在五个点的对称模板 $\\,\\{x_{i-2}, x_{i-1}, x_{i}, x_{i+1}, x_{i+2}\\}\\,$ 上用二阶多项式逼近 $\\,x_i\\,$ 附近的局部界面，\n$$\ny(x) \\approx a_{0,i} + a_{1,i} (x - x_i) + a_{2,i} (x - x_i)^2,\n$$\n由此可得\n$$\ny'(x_i) \\approx a_{1,i}, \\quad y''(x_i) \\approx 2 a_{2,i}, \\quad \\kappa_{\\text{quad}}(x_i) \\approx \\frac{2 a_{2,i}}{\\left( 1 + a_{1,i}^2 \\right)^{3/2}}.\n$$\n\n精确曲率：\n从解析界面计算 $\\,y'(x) = a \\left(\\frac{2\\pi}{\\lambda}\\right) \\cos\\left(\\frac{2\\pi}{\\lambda}x\\right)\\,$ 和 $\\,y''(x) = -a \\left(\\frac{2\\pi}{\\lambda}\\right)^2 \\sin\\left(\\frac{2\\pi}{\\lambda}x\\right)\\,$，以获得精确曲率\n$$\n\\kappa_{\\text{exact}}(x) = \\frac{-a \\left( \\frac{2\\pi}{\\lambda} \\right)^2 \\sin\\left( \\frac{2\\pi}{\\lambda} x \\right)}{\\left(1 + a^2 \\left( \\frac{2\\pi}{\\lambda} \\right)^2 \\cos^2\\left( \\frac{2\\pi}{\\lambda} x \\right) \\right)^{3/2}}.\n$$\n\n压力跳跃误差量化：\n- 对于每个网格位置 $\\,x_i\\,$，计算精确的压力跳跃 $\\,\\Delta p_{\\text{exact}}(x_i) = \\sigma \\kappa_{\\text{exact}}(x_i)\\,$（单位：帕斯卡）。\n- 根据重建计算估计的压力跳跃：\n$$\n\\Delta p_{\\text{lin}}(x_i) = \\sigma \\kappa_{\\text{lin}}(x_i), \\quad \\Delta p_{\\text{quad}}(x_i) = \\sigma \\kappa_{\\text{quad}}(x_i).\n$$\n- 通过周期域上的均方根误差（RMSE）来量化误差，\n$$\n\\text{RMSE}_{\\text{lin}} = \\sqrt{\\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left( \\Delta p_{\\text{lin}}(x_i) - \\Delta p_{\\text{exact}}(x_i) \\right)^2 },\n$$\n$$\n\\text{RMSE}_{\\text{quad}} = \\sqrt{\\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left( \\Delta p_{\\text{quad}}(x_i) - \\Delta p_{\\text{exact}}(x_i) \\right)^2 }.\n$$\n\n科学真实性：\n此设置模拟了鬼影流体法在VOF重建的界面上施加的由曲率引起的压力跳跃。线性重建虽然是分段线性界面计算（PLIC）的标准方法，但无法在主阶上表示曲率，而二次重建则能捕捉到计算曲率所需的二阶导数。由此产生的误差直接量化了以帕斯卡为单位的错误施加的毛细压力，这会影响控制两相不可压缩流动的偏微分方程的数值解。\n\n测试套件：\n对于每个测试用例，程序应计算以帕斯卡为单位的 $\\,\\text{RMSE}_{\\text{lin}}\\,$ 和 $\\,\\text{RMSE}_{\\text{quad}}\\,$。\n\n- 测试用例 $\\,1\\,$ (正常路径): $\\,\\sigma = 0.072\\,$ N/m, $\\,\\lambda = 1.0\\,$ m, $\\,a = 0.05\\,$ m, $\\,N_x = 128\\,$。\n- 测试用例 $\\,2\\,$ (更高曲率振幅): $\\,\\sigma = 0.072\\,$ N/m, $\\,\\lambda = 1.0\\,$ m, $\\,a = 0.20\\,$ m, $\\,N_x = 128\\,$。\n- 测试用例 $\\,3\\,$ (更高频率): $\\,\\sigma = 0.072\\,$ N/m, $\\,\\lambda = 0.25\\,$ m, $\\,a = 0.05\\,$ m, $\\,N_x = 128\\,$。\n- 测试用例 $\\,4\\,$ (更粗的网格分辨率): $\\,\\sigma = 0.072\\,$ N/m, $\\,\\lambda = 1.0\\,$ m, $\\,a = 0.05\\,$ m, $\\,N_x = 32\\,$。\n\n角度单位隐含在定义于弧度的三角函数中。所有长度单位为米，压力单位为帕斯卡。您的程序必须计算并报告每个测试用例的 $\\,\\text{RMSE}_{\\text{lin}}\\,$ 和 $\\,\\text{RMSE}_{\\text{quad}}\\,$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序如下\n$$\n\\left[ \\text{RMSE}_{\\text{lin}}^{(1)}, \\text{RMSE}_{\\text{quad}}^{(1)}, \\text{RMSE}_{\\text{lin}}^{(2)}, \\text{RMSE}_{\\text{quad}}^{(2)}, \\text{RMSE}_{\\text{lin}}^{(3)}, \\text{RMSE}_{\\text{quad}}^{(3)}, \\text{RMSE}_{\\text{lin}}^{(4)}, \\text{RMSE}_{\\text{quad}}^{(4)} \\right],\n$$\n其中上标表示测试用例编号。每个值都必须是帕斯卡单位的浮点数。",
            "solution": "问题陈述已经过严格审查，并被确定为**有效**。它在科学上基于计算流体动力学原理，在数学上是适定的、自洽的，并且没有歧义或矛盾。它提出了一个数值分析中严谨且有意义的任务，特别是关于界面曲率估计的准确性，这是模拟具有表面张力的两相流数值计算中的一个关键组成部分。\n\n任务是计算两种不同界面重建方法（线性和二次）下，正弦界面上毛细压力跳跃的均方根误差（RMSE）。解决方案首先对解析界面进行离散化，然后在每个网格点计算精确的曲率和压力跳跃。随后，使用每种重建方法估计压力跳跃，并通过将这些估计值与精确值进行比较来计算RMSE。\n\n**1. 离散化与精确解**\n\n计算域是正弦曲线的一个波长 $\\,\\lambda\\,$，由 $\\,N_x\\,$ 个等距点采样。网格间距为 $\\,\\Delta x = \\lambda/N_x\\,$，网格点为 $\\,x_i = i \\Delta x\\,$，其中 $\\,i=0, 1, \\dots, N_x-1\\,$。\n\n界面由 $\\,y(x) = a \\sin(kx)\\,$ 定义，其中 $\\,k = 2\\pi/\\lambda\\,$。精确的一阶和二阶导数是：\n$$\ny'(x) = ak \\cos(kx)\n$$\n$$\ny''(x) = -ak^2 \\sin(kx)\n$$\n每个网格点 $\\,x_i\\,$ 处的精确曲率 $\\,\\kappa_{\\text{exact}}(x_i)\\,$ 使用提供的公式计算：\n$$\n\\kappa_{\\text{exact}}(x_i) = \\frac{y''(x_i)}{\\left(1 + \\left(y'(x_i)\\right)^2\\right)^{3/2}} = \\frac{-ak^2 \\sin(kx_i)}{\\left(1 + (ak)^2 \\cos^2(kx_i)\\right)^{3/2}}\n$$\n然后，精确的压力跳跃为 $\\,\\Delta p_{\\text{exact}}(x_i) = \\sigma \\kappa_{\\text{exact}}(x_i)\\,$，其中 $\\,\\sigma\\,$ 是表面张力系数。\n\n**2. 线性重建误差 ($\\,\\text{RMSE}_{\\text{lin}}\\,$)**\n\n线性界面重建用一条直线在局部逼近界面。这意味着二阶导数以及曲率均为零。\n$$\n\\kappa_{\\text{lin}}(x_i) = 0 \\implies \\Delta p_{\\text{lin}}(x_i) = \\sigma \\kappa_{\\text{lin}}(x_i) = 0\n$$\n因此，线性重建在每个点上的误差是 $\\,\\Delta p_{\\text{lin}}(x_i) - \\Delta p_{\\text{exact}}(x_i) = -\\Delta p_{\\text{exact}}(x_i)\\,$。RMSE因此是精确压力跳跃本身的均方根：\n$$\n\\text{RMSE}_{\\text{lin}} = \\sqrt{\\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left(0 - \\Delta p_{\\text{exact}}(x_i)\\right)^2} = \\sqrt{\\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left(\\Delta p_{\\text{exact}}(x_i)\\right)^2}\n$$\n\n**3. 二次重建误差 ($\\,\\text{RMSE}_{\\text{quad}}\\,$)**\n\n对于二次重建，$\\,x_i\\,$ 附近的界面由一个抛物线逼近，$\\,y(x) \\approx P_i(x) = a_{0,i} + a_{1,i}(x-x_i) + a_{2,i}(x-x_i)^2\\,$。系数 $\\,a_{0,i}\\,$, $\\,a_{1,i}\\,$ 和 $\\,a_{2,i}\\,$ 通过对一个对称的 $\\,5\\,$ 点模板 $\\,\\{x_{i-2}, x_{i-1}, x_i, x_{i+1}, x_{i+2}\\}\\,$ 上的真实界面值 $\\,y_j = y(x_j)\\,$ 进行最小二乘拟合来确定。问题是周期性的，因此索引对 $\\,N_x\\,$ 取模。\n\n我们寻求找到最小化残差平方和的系数向量 $\\,\\mathbf{c}_i = [a_{0,i}, a_{1,i}, a_{2,i}]^T\\,$。这是一个线性最小二乘问题，可通过正规方程 $\\,\\mathbf{A}^T\\mathbf{A}\\mathbf{c}_i = \\mathbf{A}^T\\mathbf{y}_{\\text{stencil},i}\\,$ 求解，其中 $\\,\\mathbf{y}_{\\text{stencil},i} = [y_{i-2}, y_{i-1}, y_i, y_{i+1}, y_{i+2}]^T\\,$，而 $\\,\\mathbf{A}\\,$ 是设计矩阵：\n$$\n\\mathbf{A} = \\begin{pmatrix}\n1  (x_{i-2}-x_i)  (x_{i-2}-x_i)^2 \\\\\n1  (x_{i-1}-x_i)  (x_{i-1}-x_i)^2 \\\\\n1  (x_{i}-x_i)    (x_{i}-x_i)^2 \\\\\n1  (x_{i+1}-x_i)  (x_{i+1}-x_i)^2 \\\\\n1  (x_{i+2}-x_i)  (x_{i+2}-x_i)^2\n\\end{pmatrix} = \\begin{pmatrix}\n1  -2\\Delta x  4(\\Delta x)^2 \\\\\n1  -\\Delta x  (\\Delta x)^2 \\\\\n1  0  0 \\\\\n1  \\Delta x  (\\Delta x)^2 \\\\\n1  2\\Delta x  4(\\Delta x)^2\n\\end{pmatrix}\n$$\n解是 $\\,\\mathbf{c}_i = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T \\mathbf{y}_{\\text{stencil},i}\\,$。算子矩阵 $\\,\\mathbf{P} = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T\\,$ 可以预先计算，因为它只依赖于 $\\,\\Delta x\\,$。我们感兴趣的是 $\\,a_{1,i}\\,$ 和 $\\,a_{2,i}\\,$，它们对应于 $\\,\\mathbf{P}\\,$ 的第二行和第三行。计算得出：\n$$\na_{1,i} = \\frac{1}{10\\Delta x}(-2y_{i-2} - y_{i-1} + y_{i+1} + 2y_{i+2})\n$$\n$$\na_{2,i} = \\frac{1}{14(\\Delta x)^2}(2y_{i-2} - y_{i-1} - 2y_i - y_{i+1} + 2y_{i+2})\n$$\n这些模板应用于整个 $\\,y_i\\,$ 值网格，以获得所有网格点上的系数向量 $\\,a_{1}\\,$ 和 $\\,a_{2}\\,$。在计算上，这可以通过使用带有周期性边界条件的矢量化操作（例如，使用 `numpy.roll`）来高效地执行。\n\n根据二次逼近，在 $\\,x_i\\,$ 处的导数估计为 $\\,y'(x_i) \\approx a_{1,i}\\,$ 和 $\\,y''(x_i) \\approx 2a_{2,i}\\,$。那么曲率是：\n$$\n\\kappa_{\\text{quad}}(x_i) = \\frac{2a_{2,i}}{\\left(1 + a_{1,i}^2\\right)^{3/2}}\n$$\n相应的压力跳跃是 $\\,\\Delta p_{\\text{quad}}(x_i) = \\sigma \\kappa_{\\text{quad}}(x_i)\\,$。\n\n最后，计算二次重建的RMSE：\n$$\n\\text{RMSE}_{\\text{quad}} = \\sqrt{\\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left( \\Delta p_{\\text{quad}}(x_i) - \\Delta p_{\\text{exact}}(x_i) \\right)^2 }\n$$\n实现将为四个指定的测试用例中的每一个计算这些量。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_errors(sigma, lam, a, Nx):\n    \"\"\"\n    Calculates the RMSE for pressure jump estimation using linear and quadratic reconstructions.\n\n    Args:\n        sigma (float): Surface tension coefficient (N/m).\n        lam (float): Wavelength of the sinusoid (m).\n        a (float): Amplitude of the sinusoid (m).\n        Nx (int): Number of grid points.\n\n    Returns:\n        tuple[float, float]: A tuple containing (RMSE_lin, RMSE_quad) in Pascals.\n    \"\"\"\n    # 1. Setup Grid\n    dx = lam / Nx\n    x = np.arange(Nx) * dx\n\n    # 2. Exact Interface, Derivatives, and Curvature\n    k = 2.0 * np.pi / lam\n    y = a * np.sin(k * x)\n    y_prime_exact = a * k * np.cos(k * x)\n    y_prime_prime_exact = -a * k**2 * np.sin(k * x)\n    \n    # Denominator for the exact curvature formula\n    denom_exact = (1.0 + y_prime_exact**2)**1.5\n    kappa_exact = y_prime_prime_exact / denom_exact\n\n    # 3. Exact Pressure Jump\n    dp_exact = sigma * kappa_exact\n\n    # 4. Linear Reconstruction Error\n    # For linear reconstruction, kappa_lin = 0, so dp_lin = 0.\n    # The error is the difference between 0 and dp_exact.\n    rmse_lin = np.sqrt(np.mean(dp_exact**2))\n\n    # 5. Quadratic Reconstruction Curvature\n    # The coefficients a_{1,i} and a_{2,i} are computed using stencils derived\n    # from a 5-point least-squares fit.\n    # We use np.roll to handle periodic boundary conditions efficiently.\n    # A positive shift k in np.roll corresponds to index i-k.\n    y_m2 = np.roll(y, 2)  # y_{i-2}\n    y_m1 = np.roll(y, 1)  # y_{i-1}\n    y_p1 = np.roll(y, -1) # y_{i+1}\n    y_p2 = np.roll(y, -2) # y_{i+2}\n\n    # Stencil for a_{1,i}, which approximates y'(x_i)\n    a1_quad = (1.0 / (10.0 * dx)) * (-2.0 * y_m2 - y_m1 + y_p1 + 2.0 * y_p2)\n\n    # Stencil for a_{2,i}, where 2*a_{2,i} approximates y''(x_i)\n    a2_quad = (1.0 / (14.0 * dx**2)) * (2.0 * y_m2 - y_m1 - 2.0 * y - y_p1 + 2.0 * y_p2)\n\n    y_prime_quad = a1_quad\n    y_prime_prime_quad = 2.0 * a2_quad\n    \n    # Denominator for the quadratic curvature formula\n    denom_quad = (1.0 + y_prime_quad**2)**1.5\n    kappa_quad = y_prime_prime_quad / denom_quad\n    dp_quad = sigma * kappa_quad\n    \n    # 6. Quadratic Reconstruction Error\n    rmse_quad = np.sqrt(np.mean((dp_quad - dp_exact)**2))\n\n    return rmse_lin, rmse_quad\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (sigma, lambda, a, Nx)\n        (0.072, 1.0, 0.05, 128),  # Test Case 1\n        (0.072, 1.0, 0.20, 128),  # Test Case 2\n        (0.072, 0.25, 0.05, 128), # Test Case 3\n        (0.072, 1.0, 0.05, 32),   # Test Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        sigma, lam, a, Nx = case\n        rmse_lin, rmse_quad = calculate_errors(sigma, lam, a, Nx)\n        results.append(rmse_lin)\n        results.append(rmse_quad)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "回到稳定性问题，我们可以从一个更高级的角度来解决它：采用隐式时间积分方法。虽然隐式方法在理论上是无条件稳定的，可以绕过CFL条件的限制，但当系统中存在小切割单元时，直接求解会面临一个巨大的挑战：线性系统会变得严重病态（ill-conditioned），难以高效、精确地求解。本练习将指导您实现一种精妙且强大的解决方案，即通过舒尔补（Schur complement）方法代数地消去与切割单元相关的刚性自由度。这种方法最终会得到一个规模更小且条件数良好的线性系统，完美结合了隐式格式的稳定性和求解良态系统的计算效率。",
            "id": "3376340",
            "problem": "考虑单位区间上具有狄利克雷（Dirichlet）边界条件的一维热方程。设场由 $u(x,t)$ 表示，满足 $u_t = \\kappa u_{xx}$，其中 $x \\in (0,1)$，$t \\ge 0$，边界条件为 $u(0,t)=0$，$u(1,t)=0$，初始条件为 $u(x,0) = \\sin(\\pi x)$。使用 $N$ 个内部点对空间域进行离散化，这些点的位置为 $x_i = i h$，$i=1,\\dots,N$，其中 $h = \\frac{1}{N+1}$。使用时间步长为 $\\Delta t  0$ 的一阶后向欧拉时间积分器。将半离散更新以矩阵形式表示为\n$$\n(M - \\Delta t\\, \\kappa\\, L)\\, u^{n+1} = M\\, u^n,\n$$\n其中 $u^n \\in \\mathbb{R}^N$，$M \\in \\mathbb{R}^{N \\times N}$ 是一个对角质量矩阵，$L \\in \\mathbb{R}^{N \\times N}$ 是与狄利克雷边界条件相关的标准二阶差分算子，即 $(L u)_i = \\frac{u_{i-1} - 2 u_i + u_{i+1}}{h^2}$，$i=1,\\dots,N$，其中 $u_0 = 0$ 且 $u_{N+1}=0$。设扩散系数 $\\kappa = 1$。矩阵 $M$ 通过为选定的条目分配一个小的体积分数来模拟切割单元：对于常规单元，设置 $M_{ii} = 1$；对于切割单元，设置 $M_{ii} = \\alpha_i \\in (0,1]$。小的体积分数 $0  \\alpha_i \\ll 1$ 会在显式格式中引发小单元刚度问题；隐式格式避免了时间步长的限制，但如果试图直接耦合小单元的未知数，可能会遭受病态条件和局部刚度的困扰。\n\n您的任务是开发并实现一个隐式时间积分器，通过对切割单元未知数进行舒尔补（Schur complement）消元来消除小单元刚度。请按照以下步骤进行，除了上述定义外，不使用任何预先推导的公式：\n- 从后向欧拉离散化、线性系统的基本性质和块高斯消元出发。将未知数划分为两组：常规单元集 $A$ 和体积分数为 $\\{\\alpha_i\\}_{i \\in B}$ 的切割单元集 $B$。将线性系统按对应于 $A$ 和 $B$ 的块进行划分。\n- 通过舒尔补消去 $B$ 的未知数，推导出关于 $A$ 的简化系统。仔细论证代数步骤，并说明消元有效的条件。解释在求解简化系统后如何重构被消元的未知数。\n- 设计一个算法来组装 $M$、$L$、完整系统矩阵 $A = M - \\Delta t\\, L$ 和右端项，然后分别通过完整系统和舒尔补约简求解一个隐式时间步。证明两种方法在数值误差范围内产生相同的数值解。\n- 比较简化系统与完整系统在谱条件数方面的条件性质。将谱条件数定义为相应矩阵的 $2$-范数条件数。\n\n初始条件：设置 $u^0_i = \\sin(\\pi x_i)$，$i=1,\\dots,N$。\n\n您必须实现一个完整的、可运行的程序，该程序：\n- 为每个测试用例构建 $M$、$L$ 和 $A$。\n- 通过求解完整系统和通过舒尔补约简系统来从 $u^0$ 计算 $u^1$，然后重构被消元的切割单元未知数。\n- 为每个测试用例计算两个量：\n  1. 两种 $u^1$ 解（完整系统与舒尔补）之间的最大绝对差，定义为 $\\max_i |u^{1,\\text{full}}_i - u^{1,\\text{schur}}_i|$，以浮点数形式表示。\n  2. 条件数缩减因子，定义为 $\\frac{\\kappa_2(A)}{\\kappa_2(S)}$，其中 $\\kappa_2(\\cdot)$ 表示 $2$-范数条件数，$A$ 是完整系统矩阵，$S$ 是被消元块的舒尔补。如果没有切割单元（即集合 $B$ 为空），则将缩减因子定义为 $1$。\n\n您的程序必须使用以下测试套件，它涵盖了典型、边界和边缘情况。在每种情况下，$\\kappa = 1$，$u^0_i = \\sin(\\pi x_i)$，狄利克雷边界值为 $0$：\n- 测试用例 1：$N=50$，$\\Delta t = 0.5$，切割单元集 $B = \\{25\\}$，其中 $\\alpha_{25} = 10^{-3}$。\n- 测试用例 2：$N=50$，$\\Delta t = 0.5$，无切割单元，即 $B = \\emptyset$。\n- 测试用例 3：$N=80$，$\\Delta t = 2.0$，切割单元集 $B = \\{10,40,70\\}$，其中 $\\alpha_{10} = \\alpha_{40} = \\alpha_{70} = 10^{-4}$。\n- 测试用例 4：$N=100$，$\\Delta t = 10.0$，切割单元集 $B = \\{1\\}$，其中 $\\alpha_{1} = 10^{-8}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的扁平列表形式的结果，并用方括号括起来，顺序为 $[\\text{err}_1,\\text{ratio}_1,\\text{err}_2,\\text{ratio}_2,\\text{err}_3,\\text{ratio}_3,\\text{err}_4,\\text{ratio}_4]$，其中 $\\text{err}_k$ 是测试用例 $k$ 的最大绝对差，$\\text{ratio}_k$ 是测试用例 $k$ 的条件数缩减因子。所有值都必须是浮点数。不应打印任何附加文本。",
            "solution": "用户提供的问题被评估为有效。它在数值分析和线性代数领域有科学依据，问题陈述清晰，目标明确，且没有任何使其无效的缺陷。因此，提供一个完整的解决方案。\n\n该问题要求推导并实现一种基于舒尔补的隐式时间步进方法，用于求解在带有切割单元的域上的一维热方程 $u_t = \\kappa u_{xx}$。目标是减轻由小体积切割单元引入的病态条件。\n\n热方程的后向欧拉离散化在每个时间步 $n+1$ 产生一个待解的线性系统：\n$$\n(M - \\Delta t\\, \\kappa\\, L)\\, u^{n+1} = M\\, u^n\n$$\n其中 $u^{n+1}$ 是新时间步的未知温度向量，$u^n$ 是上一步的解，$\\Delta t$ 是时间步长，$\\kappa$ 是热扩散系数。矩阵 $M$ 是质量矩阵，它是一个对角矩阵。对于常规网格单元，其对角线元素为 $1$；对于切割单元，它们是小的体积分数 $\\alpha_i \\in (0,1)$。矩阵 $L$ 是拉普拉斯算子 $u_{xx}$ 在齐次狄利克雷边界条件下的标准二阶有限差分近似。我们将系统矩阵定义为 $A = M - \\Delta t\\, \\kappa\\, L$，右端项定义为 $b = M u^n$。待解的系统是 $A u^{n+1} = b$。\n\n**舒尔补方法的推导**\n\n为了解决由切割单元的 $M$ 的小对角元素引入的刚度问题，我们对系统的自由度进行划分。设所有单元索引的集合被划分为两个不相交的集合：$A$，常规（“活动”）单元的集合，以及 $B$，我们希望消元的切割单元的集合。\n\n通过对未知数向量 $u^{n+1}$ 及相应的方程重新排序，我们可以将线性系统 $A u^{n+1} = b$ 写成 $2 \\times 2$ 的块形式：\n$$\n\\begin{pmatrix} A_{AA}  A_{AB} \\\\ A_{BA}  A_{BB} \\end{pmatrix}\n\\begin{pmatrix} u_A \\\\ u_B \\end{pmatrix} =\n\\begin{pmatrix} b_A \\\\ b_B \\end{pmatrix}\n$$\n这里，$u_A$ 和 $u_B$ 分别是 $u^{n+1}$ 中对应于单元集 $A$ 和 $B$ 的子向量。矩阵 $A_{AA}$、$A_{AB}$、$A_{BA}$ 和 $A_{BB}$ 是系统矩阵 $A$ 的相应块，而 $b_A$ 和 $b_B$ 是右端项向量 $b$ 的划分块。\n\n该块系统等价于以下两个方程：\n1. $A_{AA} u_A + A_{AB} u_B = b_A$\n2. $A_{BA} u_A + A_{BB} u_B = b_B$\n\n舒尔补方法的核心思想是通过代数方法从系统中消去未知数 $u_B$。我们可以从第二个方程中解出 $u_B$：\n$$\nA_{BB} u_B = b_B - A_{BA} u_A\n$$\n$$\nu_B = A_{BB}^{-1} (b_B - A_{BA} u_A)\n$$\n此步骤当且仅当矩阵块 $A_{BB}$ 可逆时有效。我们来分析 $A_{BB}$：\n$A_{BB} = M_{BB} - \\Delta t\\, \\kappa\\, L_{BB}$。\n质量矩阵块 $M_{BB}$ 是一个对角矩阵，其正元素为 $\\{\\alpha_i\\}_{i \\in B}$。\n拉普拉斯矩阵块 $L_{BB}$ 是 $L$ 的一个主子矩阵。矩阵 $-L$ 是对称正定（SPD）的。任何对称正定矩阵的主子矩阵也是对称正定的。因此，$-L_{BB}$ 是对称正定的。\n对于本问题中的特定测试用例，切割单元彼此不相邻。这使得 $L_{BB}$ 简化为一个对角矩阵，其元素为 $-2/h^2$，而 $L_{AB}, L_{BA}$ 具有稀疏结构。因此，$A_{BB}$ 是一个对角矩阵，其元素为 $(\\alpha_i + 2\\Delta t \\kappa / h^2)$。由于 $\\alpha_i  0$，$\\Delta t  0$，$\\kappa  0$ 且 $h^2  0$，所以 $A_{BB}$ 的所有对角元素都严格为正。因此，$A_{BB}$ 是可逆的。\n\n将 $u_B$ 的表达式代入第一个方程得到：\n$$\nA_{AA} u_A + A_{AB} \\left( A_{BB}^{-1} (b_B - A_{BA} u_A) \\right) = b_A\n$$\n重新整理各项以分离 $u_A$，我们得到简化系统：\n$$\n(A_{AA} - A_{AB} A_{BB}^{-1} A_{BA}) u_A = b_A - A_{AB} A_{BB}^{-1} b_B\n$$\n这就是舒尔补系统。我们定义：\n- 舒尔补矩阵：$S = A_{AA} - A_{AB} A_{BB}^{-1} A_{BA}$\n- 修正后的右端项：$\\hat{b}_A = b_A - A_{AB} A_{BB}^{-1} b_B$\n\n待求解的关于常规单元未知数 $u_A$ 的简化系统是 $S u_A = \\hat{b}_A$。\n\n**被消元未知数的重构**\n\n在求解简化系统得到 $u_A$ 之后，可以通过回代到之前推导的表达式中来恢复被消元的切割单元未知数 $u_B$ 的解：\n$$\nu_B = A_{BB}^{-1} (b_B - A_{BA} u_A)\n$$\n将 $u_A$ 和 $u_B$ 结合起来，得到完整的解向量 $u^{n+1}$。\n\n**算法与条件数总结**\n\n算法流程如下：\n1. 组装完整系统矩阵 $M$、$L$ 和 $A = M - \\Delta t \\kappa L$。计算右端项 $b = M u^0$。\n2. 求解完整系统 $A u^{1,\\text{full}} = b$ 作为基准。\n3. 如果存在切割单元，将 $A$ 和 $b$ 划分为对应于常规（$A$）和切割（$B$）单元的块。\n4. 构建舒尔补矩阵 $S$ 和修正后的右端项 $\\hat{b}_A$。\n5. 求解简化系统 $S u_A = \\hat{b}_A$。\n6. 重构 $u_B$ 以获得完整的解向量 $u^{1,\\text{schur}}$。\n7. 比较结果和条件数。\n\n小体积分数 $\\alpha_i \\ll 1$ 的存在使得质量矩阵 $M$ 近乎奇异。这种病态条件会转移到完整系统矩阵 $A$，其谱条件数 $\\kappa_2(A)$ 可能变得非常大。舒尔补方法隔离了这种刚度。$A_{BB}$ 的求逆在数值上是稳定的，因为其元素主要由表现良好的项 $2\\Delta t \\kappa / h^2$ 主导。得到的简化系统矩阵 $S$ 仅作用于常规自由度，通常比 $A$ 的条件好得多。因此，当存在小切割单元时，我们期望条件数缩减因子 $\\kappa_2(A)/\\kappa_2(S)$ 远大于 $1$，这证明了该方法的有效性。两种方法的数值解在机器精度范围内应是相同的，因为舒尔补方法是一种精确的代数重排。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n    test_cases = [\n        # Test case 1: N=50, dt=0.5, B={25} with alpha=1e-3\n        (50, 0.5, {25: 1e-3}),\n        # Test case 2: N=50, dt=0.5, no cut-cells\n        (50, 0.5, {}),\n        # Test case 3: N=80, dt=2.0, B={10,40,70} with alpha=1e-4\n        (80, 2.0, {10: 1e-4, 40: 1e-4, 70: 1e-4}),\n        # Test case 4: N=100, dt=10.0, B={1} with alpha=1e-8\n        (100, 10.0, {1: 1e-8}),\n    ]\n\n    results = []\n    for N, dt, cut_cells_dict in test_cases:\n        error, ratio = run_case(N, dt, cut_cells_dict)\n        results.extend([error, ratio])\n\n    print(f\"[{','.join(f'{val:.8e}' for val in results)}]\")\n\ndef run_case(N, dt, cut_cells_dict):\n    \"\"\"\n    Solves the problem for a single test case.\n\n    Args:\n        N (int): Number of interior grid points.\n        dt (float): Time step size.\n        cut_cells_dict (dict): A dictionary mapping 1-based cut-cell indices\n                               to their volume fractions (alpha).\n\n    Returns:\n        tuple: A tuple containing:\n            - error (float): The max absolute difference between full and Schur solutions.\n            - ratio (float): The condition number reduction factor.\n    \"\"\"\n    kappa = 1.0\n    h = 1.0 / (N + 1)\n\n    # Grid and Initial Condition\n    x = np.arange(1, N + 1) * h\n    u0 = np.sin(np.pi * x)\n\n    # Assemble matrices\n    # Mass Matrix M\n    M = np.identity(N)\n    for i_1based, alpha in cut_cells_dict.items():\n        M[i_1based - 1, i_1based - 1] = alpha\n\n    # Laplacian Matrix L\n    diag_L = np.full(N, -2.0 / h**2)\n    off_diag_L = np.full(N - 1, 1.0 / h**2)\n    L = np.diag(diag_L) + np.diag(off_diag_L, k=1) + np.diag(off_diag_L, k=-1)\n\n    # Full system matrix and RHS\n    A_full = M - dt * kappa * L\n    b_full = M @ u0\n\n    # 1. Solve the full system\n    u1_full = np.linalg.solve(A_full, b_full)\n\n    # Handle the case with no cut-cells\n    if not cut_cells_dict:\n        # The Schur complement method is not applied.\n        # The \"reduced\" system is the full system.\n        return 0.0, 1.0\n\n    # 2. Solve using Schur complement\n    # Define partitions for regular (A) and cut (B) cells\n    indices_0based = np.arange(N)\n    B_idx = np.array(sorted([i - 1 for i in cut_cells_dict.keys()]), dtype=int)\n    A_idx = np.setdiff1d(indices_0based, B_idx, assume_unique=True)\n\n    # Extract matrix and vector blocks\n    A_AA = A_full[np.ix_(A_idx, A_idx)]\n    A_AB = A_full[np.ix_(A_idx, B_idx)]\n    A_BA = A_full[np.ix_(B_idx, A_idx)]\n    A_BB = A_full[np.ix_(B_idx, B_idx)]\n    \n    b_A = b_full[A_idx]\n    b_B = b_full[B_idx]\n\n    # Form and solve the Schur complement system\n    # Since A_BB is small, direct inversion is fine.\n    A_BB_inv = np.linalg.inv(A_BB)\n    S = A_AA - A_AB @ A_BB_inv @ A_BA\n    b_hat_A = b_A - A_AB @ A_BB_inv @ b_B\n    u_A_schur = np.linalg.solve(S, b_hat_A)\n\n    # Reconstruct the eliminated unknowns\n    u_B_schur = A_BB_inv @ (b_B - A_BA @ u_A_schur)\n\n    # Assemble the full solution vector from Schur method\n    u1_schur = np.zeros(N)\n    u1_schur[A_idx] = u_A_schur\n    u1_schur[B_idx] = u_B_schur\n\n    # 3. Compute metrics\n    # Maximum absolute difference between the two solutions\n    error = np.max(np.abs(u1_full - u1_schur))\n\n    # Condition number reduction factor\n    cond_A_full = np.linalg.cond(A_full, 2)\n    cond_S = np.linalg.cond(S, 2)\n    ratio = cond_A_full / cond_S\n\n    return error, ratio\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}