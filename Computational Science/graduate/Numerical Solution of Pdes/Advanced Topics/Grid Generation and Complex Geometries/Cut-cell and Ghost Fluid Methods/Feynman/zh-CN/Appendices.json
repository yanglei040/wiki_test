{
    "hands_on_practices": [
        {
            "introduction": "在显式时间推进格式中，小切割单元的存在会带来严重的时间步长限制，这是所谓的“小单元刚度”问题。本练习通过一个具体的一维热方程算例，清晰地揭示了朴素显式格式在这种情况下如何产生数值不稳定性。通过将不稳定结果与一种简单而有效的单元合并（cell-merging）稳定化方法进行对比，你将亲手验证并理解解决这一核心挑战的策略。",
            "id": "3376330",
            "problem": "考虑一维无量纲热方程 $u_{t}=\\kappa\\,u_{xx}$，其中扩散系数 $\\kappa>0$ 为常数。该方程定义在一个由两个有限体积单元表示的短段上，其中一个浸入式固体边界将左侧单元切割成一个与常规流体单元相邻的微小流体子单元。左侧单元 $C_{0}$ 名义上跨越 $[0,\\Delta x]$，右侧单元 $C_{1}$ 跨越 $[\\Delta x,2\\Delta x]$，网格间距 $\\Delta x$ 均匀。一个浸入式边界在位置 $x_{L}=\\Delta x-\\varepsilon\\,\\Delta x$ 处与 $C_{0}$ 相交，留下一个长度为 $\\ell=\\varepsilon\\,\\Delta x$ 的流体子单元，该子单元与 $x=\\Delta x$ 处的面相邻。位于 $x=2\\Delta x$ 处的外部右边界满足齐次诺伊曼(Neumann)条件。浸入式边界上的 $u$ 值由狄利克雷(Dirichlet)条件 $u(x_{L},t)=u_{b}$ 指定，并使用幽灵流体方法（GFM）强制施加。在该方法中，切割面上的扩散通量是根据单元代表值与边界值之间在到切割面的几何距离上的单侧线性梯度计算的。\n\n给定以下无量纲参数和初始数据：\n- $\\Delta x=1$,\n- $\\varepsilon=0.1$ (所以 $\\ell=0.1$),\n- $\\kappa=1$,\n- 时间步长 $\\Delta t=0.2$ (前向欧拉法),\n- 在 $x=x_{L}$ 处 $u_{b}=0$,\n- 初始单元平均值 $U_{0}^{n}=1$ (在 $C_{0}$ 中) 和 $U_{1}^{n}=1$ (在 $C_{1}$ 中)。\n\n几何数据：\n- $C_{0}$ 的流体部分占据 $[x_{L},\\Delta x]=[0.9,1]$，因此其形心位于 $x_{c,0}=0.95$，体积（长度）为 $V_{0}=\\ell=0.1$。\n- 常规单元 $C_{1}$ 占据 $[1,2]$，形心为 $x_{c,1}=1.5$，体积为 $V_{1}=1$。\n- 从形心到 $x=1$ 处界面的距离为 $d_{0}=1-x_{c,0}=0.05$ 和 $d_{1}=x_{c,1}-1=0.5$。从 $x_{c,0}$ 到 $x_{L}$ 处切割面的距离为 $d_{L}=x_{c,0}-x_{L}=0.05$。\n\n任务 A（切割单元上的朴素显式更新）：使用从 $u_{t}=\\kappa u_{xx}$ 的守恒形式推导出的有限体积法，用与非均匀距离相符的线性两点公式近似面上的梯度。对于 $x=1$ 处的内部面，使用常用两点近似 $\\partial u/\\partial x\\big|_{1} \\approx (U_{1}^{n}-U_{0}^{n})/(d_{0}+d_{1})$。对于 $x=x_{L}$ 处的浸入式边界面，通过取值 $\\partial u/\\partial x\\big|_{x_{L}^{+}} \\approx (U_{0}^{n}-u_{b})/d_{L}$ 来通过 GFM 施加狄利克雷边界。对 $C_{0}$ 执行单步前向欧拉法来计算 $U_{0,\\text{naive}}^{n+1}$。\n\n任务 B（单元合并稳定化更新）：将 $C_{0}$ 和 $C_{1}$ 合并成一个长度为 $V_{m}=V_{0}+V_{1}=1.1$ 的单一控制体积。令合并后的平均值为 $U_{m}^{n}=(V_{0}U_{0}^{n}+V_{1}U_{1}^{n})/V_{m}$。合并后的形心为 $x_{c,m}=(V_{0}x_{c,0}+V_{1}x_{c,1})/V_{m}$，从 $x_{c,m}$ 到切割面的距离为 $d_{m}=x_{c,m}-x_{L}$。仅使用外部边界面，通过单步前向欧拉法更新合并后的平均值：\n- 在 $x=2$ 处，施加 $\\partial u/\\partial x=0$。\n- 在 $x=x_{L}$ 处，近似 $\\partial u/\\partial x\\big|_{x_{L}^{+}} \\approx (U_{m}^{n}-u_{b})/d_{m}$。\n将 $U_{0,\\text{merge}}^{n+1}:=U_{m}^{n+1}$ 设为合并后的稳定化切割单元值。\n\n计算标量差\n$$\\delta \\;=\\; U_{0,\\text{merge}}^{n+1}\\;-\\;U_{0,\\text{naive}}^{n+1}.$$\n将 $\\delta$ 报告为一个无量纲数，四舍五入到四位有效数字。",
            "solution": "问题陈述是有效的，因为它基于偏微分方程数值方法的原理，具有科学依据；所有必要信息都已提供，问题是适定的；并且其表述语言客观、无歧义。因此，我们可以着手求解。\n\n该问题要求计算一个切割单元的两个更新值之差，一个是用朴素显式方法计算的，另一个是用稳定化的单元合并方法计算的。我们依次处理每个任务。\n\n首先，我们处理任务 A：对切割单元 $C_{0}$ 进行朴素显式更新。一维热方程为 $u_{t}=\\kappa u_{xx}$。将有限体积法应用于单元 $C_{0}$ 的流体部分，其体积（长度）为 $V_{0}$，占据区间 $[x_{L}, \\Delta x]$，我们在此体积上对偏微分方程进行积分：\n$$ \\int_{V_0} u_t \\,dx = \\int_{V_0} \\kappa u_{xx} \\,dx $$\n假设单元平均值为 $U_{0}(t) = \\frac{1}{V_{0}} \\int_{V_0} u(x,t) \\,dx$，则左边项变为 $V_{0}\\frac{dU_{0}}{dt}$。根据微积分基本定理，右边项变为 $\\kappa u_{x}|_{\\Delta x} - \\kappa u_{x}|_{x_{L}}$。由此得到半离散方程：\n$$ V_{0} \\frac{dU_{0}}{dt} = \\kappa \\left( \\frac{\\partial u}{\\partial x}\\bigg|_{x=\\Delta x} - \\frac{\\partial u}{\\partial x}\\bigg|_{x=x_{L}} \\right) $$\n应用时间步长为 $\\Delta t$ 的前向欧拉时间积分格式，我们得到全离散更新公式：\n$$ U_{0}^{n+1} = U_{0}^{n} + \\frac{\\Delta t \\kappa}{V_{0}} \\left( \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=\\Delta x}^{n} - \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=x_{L}}^{n} \\right) $$\n问题指定了空间导数（通量）的近似公式：\n- 在内部面 $x=\\Delta x=1$ 处：$\\left(\\frac{\\partial u}{\\partial x}\\right)\\big|_{x=\\Delta x}^{n} \\approx \\frac{U_{1}^{n}-U_{0}^{n}}{d_{0}+d_{1}}$\n- 在浸入式边界面 $x=x_{L}$ 处：$\\left(\\frac{\\partial u}{\\partial x}\\right)\\big|_{x=x_{L}^{+}}^{n} \\approx \\frac{U_{0}^{n}-u_{b}}{d_{L}}$\n\n我们代入给定的数值：$\\Delta x=1$，$\\varepsilon=0.1$，$\\kappa=1$，$\\Delta t=0.2$， $u_{b}=0$，$U_{0}^{n}=1$，$U_{1}^{n}=1$。\n几何数据：$V_{0}=0.1$，$x_{L}=0.9$，$x_{c,0}=0.95$，$d_{0}=1-x_{c,0}=0.05$，$d_{1}=x_{c,1}-1=0.5$ 以及 $d_{L}=x_{c,0}-x_{L}=0.05$。\n\n首先，我们计算在时间步 $n$ 的近似梯度：\n$$ \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=1}^{n} \\approx \\frac{1-1}{0.05+0.5} = \\frac{0}{0.55} = 0 $$\n$$ \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=0.9}^{n} \\approx \\frac{1-0}{0.05} = 20 $$\n现在，我们将这些值代入 $U_{0,\\text{naive}}^{n+1}$ 的更新公式：\n$$ U_{0,\\text{naive}}^{n+1} = U_{0}^{n} + \\frac{\\Delta t \\kappa}{V_{0}} \\left( 0 - 20 \\right) = 1 + \\frac{0.2 \\times 1}{0.1} \\left(-20\\right) = 1 + 2(-20) = 1 - 40 = -39 $$\n所以，$U_{0,\\text{naive}}^{n+1} = -39$。其巨大的量值和负号表明存在数值不稳定性，这对于在具有此时间步长的小切割单元上使用显式格式是预料之中的。\n\n接下来，我们处理任务 B：单元合并稳定化更新。将切割单元 $C_{0}$ 与其相邻单元 $C_{1}$ 合并，形成一个更大的单一控制体积 $C_{m}$。\n首先，我们确定合并后单元的属性。\n- 合并后体积：$V_{m} = V_{0} + V_{1} = 0.1 + 1 = 1.1$。\n- 时间 $n$ 的合并后单元平均值：$U_{m}^{n} = \\frac{V_{0}U_{0}^{n} + V_{1}U_{1}^{n}}{V_{m}} = \\frac{0.1 \\times 1 + 1 \\times 1}{1.1} = \\frac{1.1}{1.1} = 1$。\n- 合并后的单元形心：$x_{c,m} = \\frac{V_{0}x_{c,0} + V_{1}x_{c,1}}{V_{m}} = \\frac{0.1 \\times 0.95 + 1 \\times 1.5}{1.1} = \\frac{0.095 + 1.5}{1.1} = \\frac{1.595}{1.1} = 1.45$。\n- 从合并后的形心到切割面的距离：$d_{m} = x_{c,m} - x_{L} = 1.45 - 0.9 = 0.55$。\n\n合并后的控制体积占据区间 $[x_{L}, 2\\Delta x] = [0.9, 2]$。有限体积更新是在这个更大的单元上执行的，仅使用其外部边界（$x=x_{L}$ 和 $x=2$）上的通量。\n$$ U_{m}^{n+1} = U_{m}^{n} + \\frac{\\Delta t \\kappa}{V_{m}} \\left( \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=2}^{n} - \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=x_{L}}^{n} \\right) $$\n合并后单元更新的边界条件为：\n- 在 $x=2$ 处：齐次诺伊曼条件，$\\frac{\\partial u}{\\partial x} = 0$。\n- 在 $x=x_{L}$ 处：虚拟流体法近似，$\\left(\\frac{\\partial u}{\\partial x}\\right)\\big|_{x_{L}^{+}}^{n} \\approx \\frac{U_{m}^{n} - u_{b}}{d_{m}}$。\n\n我们计算在 $x=x_{L}$ 处所需的梯度：\n$$ \\left(\\frac{\\partial u}{\\partial x}\\right)\\bigg|_{x=0.9}^{n} \\approx \\frac{1 - 0}{0.55} = \\frac{1}{0.55} $$\n代入 $U_{m}^{n+1}$ 的更新公式：\n$$ U_{m}^{n+1} = U_{m}^{n} + \\frac{\\Delta t \\kappa}{V_{m}} \\left( 0 - \\frac{1}{0.55} \\right) = 1 + \\frac{0.2 \\times 1}{1.1} \\left( -\\frac{1}{0.55} \\right) = 1 - \\frac{0.2}{1.1 \\times 0.55} = 1 - \\frac{0.2}{0.605} $$\n$$ U_{m}^{n+1} = 1 - \\frac{200}{605} = 1 - \\frac{40}{121} = \\frac{121 - 40}{121} = \\frac{81}{121} $$\n稳定化的切割单元值被设为这个合并后的值：$U_{0,\\text{merge}}^{n+1} = U_{m}^{n+1} = \\frac{81}{121}$。\n数值上，这约等于 $0.6694214876$。\n\n最后，我们计算标量差 $\\delta$：\n$$ \\delta = U_{0,\\text{merge}}^{n+1} - U_{0,\\text{naive}}^{n+1} $$\n$$ \\delta = \\frac{81}{121} - (-39) = 39 + \\frac{81}{121} \\approx 39 + 0.6694214876 = 39.6694214876 $$\n问题要求将此值四舍五入到四位有效数字。这个数是 $39.6694...$。前四位有效数字是 $3$、$9$、$6$、$6$。第五位数字是 $9$，大于等于 $5$，所以我们将第四位数字向上取整。\n$$ \\delta \\approx 39.67 $$\n这个结果突显了在显式时间步进格式中，用于处理小切割单元的不稳定朴素更新方法与稳定的单元合并方法之间的巨大差异。",
            "answer": "$$\n\\boxed{39.67}\n$$"
        },
        {
            "introduction": "将理论付诸实践的关键一步是处理与网格不一致的复杂几何边界。本练习将挑战你为一个二维泊松问题实现幽灵流体方法（Ghost Fluid Method, GFM），以在嵌入的复杂多边形边界上施加狄利克雷（Dirichlet）条件。你将需要开发鲁棒的几何判断逻辑，并特别处理边界与网格线相交时可能产生的角点奇点和多重切割单元，这对于开发通用的嵌入边界求解器至关重要。",
            "id": "3376303",
            "problem": "考虑一个带有嵌入式内部狄利克雷边界的二维泊松方程。计算区域为 $\\Omega = [0,1] \\times [0,1]$，并设 $\\Gamma \\subset \\Omega$ 表示一条简单、闭合、凸的多边形曲线（嵌入边界），该曲线将 $\\Omega$ 分为一个流体区域 $\\Omega_f = \\Omega \\setminus K$ 和一个固体区域 $K$（$\\Gamma$的内部）。我们研究以下边值问题\n$$\n-\\Delta u = f \\quad \\text{in } \\Omega_f,\n$$\n其狄利克雷边界条件为\n$$\nu = 0 \\quad \\text{on } \\partial \\Omega, \\qquad u = g \\quad \\text{on } \\Gamma.\n$$\n为实现精确验证，使用制造解方法，并采用以下光滑目标解\n$$\nu^\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y),\n$$\n这意味着\n$$\nf(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y), \\quad g(x,y) = u^\\star(x,y).\n$$\n在均匀笛卡尔网格上进行离散化，网格间距为 $h = 1/N$，网格节点为 $(x_i,y_j) = (i h, j h)$，其中整数 $i,j \\in \\{0,1,\\dots,N\\}$。在 $\\Omega_f$ 的内部，使用拉普拉斯算子的五点有限差分近似。对于邻近节点跨越嵌入边界 $\\Gamma$ 的边，应用一种基于沿网格连线到界面交点的线性插值推导出的幽灵流体方法（Ghost Fluid Method, GFM）来处理（GFM是一种界面方法，它使用从物理侧外推的幽灵值来施加边界/界面条件）。具体而言，如果 $(x_i,y_j)$ 是一个流体节点，而其邻近节点 $(x_{i\\pm1},y_j)$ 或 $(x_i,y_{j\\pm1})$ 位于 $K$ 内，则定义 $\\alpha \\in (0,1]$ 为网格线段与 $\\Gamma$ 相交点处的分数（从流体节点朝邻近节点方向测量），并用 $g^\\star$ 表示在交点处计算的狄利克雷值 $g$。通过将标准的邻近差分项替换为以下形式，来施加穿过该切割面的离散通量\n$$\n\\frac{u_g - u_{i,j}}{h^2} = \\frac{g^\\star - u_{i,j}}{\\alpha h^2},\n$$\n这是通过要求流体节点值与鬼点值 $u_g$ 之间呈线性变化，使得界面上的插值等于 $g^\\star$ 而得出的。对于被切割的连线，这产生对角线贡献 $1/(\\alpha h^2)$ 和右端项贡献 $g^\\star/(\\alpha h^2)$。对于未被切割且连接到流体邻近节点的连线，使用标准的 $1/h^2$ 模板耦合。对于连接到 $\\partial \\Omega$ 上的节点或恰好位于 $\\Gamma$ 上的网格节点的连线，将这些邻近节点视为具有已知值的狄利克雷节点。为了稳健地处理 $\\Gamma$ 穿过网格节点或与网格线相交以产生多重切割单元时的角点奇异性，请实施以下规则：\n- 如果一个网格节点位于 $\\Gamma$ 上（在与 $h$ 成正比的几何容差内），则将其视为一个狄利克雷节点，其值取该节点处的 $u^\\star$。\n- 如果一个单元有多个被切割的面，则简单地将各切割面的贡献相加；当局部变化被视为线性时，这对应于一种多约束处理，等效于沿每个相交面对界面条件进行最小二乘强制。\n- 为避免当 $\\alpha$ 极小但非零时出现的小单元病态问题，将 $\\alpha$ 的下限钳制在一个与 $h$ 无关且与机器精度成比例的小阈值（例如 $\\alpha_{\\min} = 10^{-3}$），这是一种通量重分布正则化形式；如果一个节点处的 $\\alpha$ 精确为零，则该节点被标记为位于 $\\Gamma$ 上，并被视为狄利克雷节点。\n\n为不在 $\\Gamma$ 上且不在 $\\partial \\Omega$ 上的流体网格节点处的未知数构建稀疏线性系统，并求解该系统。计算所有流体节点（包括通过取其指定值而包含在内的 $\\Gamma$ 上的狄利克雷节点）上的离散 $\\ell^2$ 误差范数，公式如下\n$$\nE_{L^2} = \\left( h^2 \\sum_{(i,j)\\in \\mathcal{F}} \\left(u_{i,j}^{\\text{num}} - u^\\star(x_i,y_j)\\right)^2 \\right)^{1/2},\n$$\n其中 $\\mathcal{F}$ 是所有流体网格节点的集合（内部未知数以及位于 $\\Gamma$ 和 $\\partial \\Omega$ 上的流体狄利克雷节点）。\n\n您的任务是实现一个完整的程序，该程序：\n- 构建三个凸多边形嵌入边界（每个 $\\Gamma$ 由一个有序的顶点列表指定），这些边界相对于网格会引发角点奇异性和多重切割单元：\n  1. 在 $N=40$ 的网格上，一个顶点为 $(0.2,0.5)$, $(0.5,0.2)$, $(0.8,0.5)$, $(0.5,0.8)$ 的菱形。\n  2. 在 $N=41$ 的网格上，同样的菱形。\n  3. 在 $N=64$ 的网格上，一个顶点为 $(0.2,0.52)$, $(0.52,0.2)$, $(0.8,0.48)$, $(0.48,0.8)$ 的平移菱形。\n- 对每种情况，使用上述的GFM处理方法组装并求解线性系统，并按规定稳健地处理角点奇异性。\n- 为每种情况计算 $E_{L^2}$。\n\n最终输出必须是单行，包含一个按此顺序排列的包含三个误差值的Python列表，格式化为实数。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，\"[result1,result2,result3]\"）。\n\n仅使用无量纲量。如果代码或推理中出现任何角度，均应以弧度处理。测试套件是上述三种情况，每个答案都必须是实数（浮点数）。不需要用户输入；所有参数都在程序中硬编码。该程序必须是在指定环境中的一个完整、可运行的脚本。",
            "solution": "用户希望我求解一个在方形域上带有嵌入式狄利克雷边界的二维泊松方程。\n\n以下是任务分解：\n\n1.  **角色**：我需要扮演一位一丝不苟、要求严格的STEM教授。\n2.  **任务**：\n    *   首先，验证问题陈述。\n    *   如果有效，则解决它。如果无效，则解释原因。\n    *   问题涉及在笛卡尔网格上使用有限差分法求解泊松方程。\n    *   主要挑战是处理内部边界 $\\Gamma$，它是一个简单、闭合、凸的多边形。\n    *   要使用的方法是幽灵流体方法（Ghost Fluid Method, GFM）。\n3.  **验证**：我需要遵循严格的程序。\n    *   **步骤1：提取已知条件**：逐字列出所有提供的信息。\n    *   **步骤2：验证**：检查科学合理性、适定性、客观性、完整性、一致性等。\n    *   **步骤3：裁决**：判断问题是有效还是无效，并相应地进行处理。\n4.  **解决方案（如果有效）**：\n    *   问题是：$-\\Delta u = f$ 在 $\\Omega_f$ 中，边界条件为 $u=0$ 在 $\\partial\\Omega$ 上，$u=g$ 在 $\\Gamma$ 上。\n    *   域：$\\Omega = [0,1] \\times [0,1]$。\n    *   嵌入边界：$\\Gamma$ 是一个凸多边形。\n    *   制造解方法：\n        *   目标解：$u^\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。\n        *   源项：$f(x,y) = -\\Delta u^\\star = -(\\frac{\\partial^2 u^\\star}{\\partial x^2} + \\frac{\\partial^2 u^\\star}{\\partial y^2}) = -(-\\pi^2 \\sin(\\pi x)\\sin(\\pi y) - \\pi^2 \\sin(\\pi x)\\sin(\\pi y)) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$。这与问题陈述相符。\n        *   $\\Gamma$ 上的边界条件：$g(x,y) = u^\\star(x,y)$。\n        *   $\\partial\\Omega$ 上的边界条件：$u=0$。然而，$u^\\star$ 在 $\\Omega$ 的整个边界上并不为零。例如，$u^\\star(x,1) = \\sin(\\pi x)\\sin(\\pi) = 0$，$u^\\star(1,y) = \\sin(\\pi)\\sin(\\pi y) = 0$。但是 $u^\\star(0,y) = \\sin(0)\\sin(\\pi y) = 0$ 且 $u^\\star(x,0) = \\sin(\\pi x)\\sin(0) = 0$。所以，$u^\\star$ 确实在 $\\partial\\Omega$ 上为0。设置是一致的。\n    *   离散化：\n        *   均匀笛卡尔网格，$(x_i, y_j) = (ih, jh)$，其中 $h = 1/N$，对于 $i,j \\in \\{0, 1, \\dots, N\\}$。\n        *   内部节点的标准5点拉普拉斯算子。\n        *   不规则节点（邻近节点跨越 $\\Gamma$）的GFM。\n    *   GFM 细节：\n        *   如果从流体节点 $(x_i, y_j)$ 到邻近节点的连线跨越 $\\Gamma$，则找到交点。\n        *   设 $\\alpha \\in (0, 1]$ 是从流体节点到交点的分数距离。\n        *   标准项 $\\frac{u_{neighbor} - u_{i,j}}{h^2}$ 被一个由 GFM 推导出的项所取代。\n        *   问题指明了这种替换的结果：“对于被切割的连线，对角线贡献 $1/(\\alpha h^2)$ 和右端项贡献 $g^\\star/(\\alpha h^2)$。”\n    *   让我们验证这个规则。有限差分/体积法近似 $-\\Delta u = f$。节点 $(i,j)$ 处的算子 $-\\Delta$ 可视为其四个邻近节点贡献的总和。\n        $$ -\\Delta u |_{(i,j)} \\approx \\sum_{k \\in \\text{neighbors}} \\frac{u_{i,j} - u_k}{h^2} = \\frac{4u_{i,j} - \\sum_k u_k}{h^2} = f_{i,j} $$\n        这种表述将离散算子的对角元素看作是基于连线贡献的总和。对于连接到邻近节点 $k$ 的常规连线，其对 $(i,j)$ 处对角线的贡献为 $1/h^2$。对于具有4条常规连线的网格单元，对角线元素为 $4/h^2$。\n        如果一条连线被边界 $\\Gamma$ “切割”，则该连线的贡献会改变。问题指定了一阶鬼点法，其中边界条件被转移到一个鬼点上。这导致用一个基于边界数据的新贡献来替换标准贡献。\n        如果一个流体节点 $(i,j)$ 的邻近节点在固体区域内，它们之间的连线就被切割了。设从 $(i,j)$ 到与 $\\Gamma$ 交点的分数距离为 $\\alpha$。解在交点处的值为 $g^\\star$。线性插值对位于固体邻近节点位置的“鬼”值 $u_g$ 施加了一个条件。由此产生的模板修改确实可以表示为替换标准连线贡献。\n        问题给出了一个明确的指令：对于一条被切割的连线，移除标准的非对角项，并按如下方式修改矩阵和右端项：\n        1.  为节点 $(i,j)$ 的对角线元素增加 $1/(\\alpha h^2)$。\n        2.  为右端向量的相应元素增加 $g^\\star/(\\alpha h^2)$。\n        这个规则是明确的，并且与鬼点法的一种特定形式一致。对于一个具有 $n_r$ 条常规邻近连线和 $n_c$ 条被切割邻近连线的单元，节点 $u_{i,j}$ 的离散方程变为：\n        $$ \\left( \\sum_{k=1}^{n_r} \\frac{1}{h^2} + \\sum_{l=1}^{n_c} \\frac{1}{\\alpha_l h^2} \\right) u_{i,j} - \\sum_{k=1}^{n_r} \\frac{1}{h^2} u_{k} = f_{i,j} + \\sum_{l=1}^{n_c} \\frac{g^\\star_l}{\\alpha_l h^2} $$\n        其中 $u_k$ 是邻近的未知流体值。这构成一个线性系统 $A\\mathbf{u}=\\mathbf{b}$，可以求解未知向量 $\\mathbf{u}$。\n\n### 步骤1：提取已知条件\n- **PDE**：$-\\Delta u = f$ 在 $\\Omega_f$ 中，其中 $\\Omega_f = (\\Omega \\setminus K)$。\n- **域**：$\\Omega = [0,1] \\times [0,1]$。\n- **嵌入边界**：$\\Gamma = \\partial K$ 是一条简单、闭合、凸的多边形曲线。\n- **边界条件**：$u = 0$ 在 $\\partial \\Omega$ 上，$u = g$ 在 $\\Gamma$ 上。\n- **制造解**：$u^\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。\n- **源项**：$f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$。\n- **界面条件**：$g(x,y) = u^\\star(x,y)$。\n- **网格**：均匀笛卡尔网格，间距为 $h = 1/N$，节点为 $(x_i,y_j) = (i h, j h)$，对于 $i,j \\in \\{0,1,\\dots,N\\}$。\n- **离散化**：常规内部节点的五点有限差分。\n- **GFM规则**：对于被 $\\Gamma$ 以分数距离 $\\alpha$ 切割的流体节点-固体邻近节点连线，对离散系统的贡献是对角线项 $1/(\\alpha h^2)$ 和右端项 $g^\\star/(\\alpha h^2)$。对未切割的流体连线使用标准的 $1/h^2$ 耦合。\n- **特殊情况**：\n    - 如果一个网格节点位于 $\\Gamma$ 上（在几何容差内），它就是一个狄利克雷节点，值为该位置的 $u^\\star$。\n    - 对于多重切割单元，将每个切割面的贡献相加。\n    - 小单元正则化：$\\alpha$ 的下限被钳制为 $\\alpha_{\\min} = 10^{-3}$。如果 $\\alpha=0$，则节点位于 $\\Gamma$ 上。\n- **系统**：为不在 $\\partial\\Omega$ 或 $\\Gamma$ 上的未知流体网格节点构建的稀疏线性系统。\n- **误差度量**：离散 $\\ell^2$ 误差范数 $E_{L^2} = \\left( h^2 \\sum_{(i,j)\\in \\mathcal{F}} \\left(u_{i,j}^{\\text{num}} - u^\\star(x_i,y_j)\\right)^2 \\right)^{1/2}$，计算范围为所有流体节点 $\\mathcal{F}$。\n- **测试用例**：\n    1. 在 $N=40$ 的网格上，顶点为 $(0.2,0.5)$, $(0.5,0.2)$, $(0.8,0.5)$, $(0.5,0.8)$ 的菱形。\n    2. 同样的菱形，$N=41$。\n    3. 在 $N=64$ 的网格上，顶点为 $(0.2,0.52)$, $(0.52,0.2)$, $(0.8,0.48)$, $(0.48,0.8)$ 的平移菱形。\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学或事实不健全性**：问题是科学上健全的。它描述了泊松方程的一个标准边值问题及其使用既定方法（有限差分，鬼点法）和验证技术（制造解方法）的数值解。指定的GFM模板是一种有效的一阶方法。\n2.  **非形式化或不相关**：问题定义良好，是数学性的，并且与使用切割单元/鬼点法数值求解偏微分方程直接相关。\n3.  **不完整或矛盾的设置**：问题是自洽的。PDE、域、边界条件、离散化方案以及嵌入边界的具体处理方式都已提供。制造解与PDE和边界条件一致。\n4.  **不切实际或不可行**：问题是一个数学构造；物理真实性不是主要关注点。所有数据在量纲上都是一致的。\n5.  **不适定或结构不良**：底层的BVP是适定的。所描述的离散化方法会产生一个稀疏、对角占优的线性系统（一个M-矩阵），该系统非奇异，保证有唯一解。为避免病态问题，提供了处理边界节点和小单元等特殊情况的规则。\n6.  **伪深刻、琐碎或同义反复**：问题不琐碎。它需要实现一个非平凡的几何引擎，组装带有自定义模板的稀疏线性系统，并进行验证研究。测试用例旨在探测实现对网格对齐的稳健性。\n7.  **超出科学可验证范围**：问题是完全可验证的。实现的正确性可以通过比较计算出的误差并观察预期的收敛行为（虽然未明确要求）来检查。\n\n### 步骤3：裁决与行动\n问题被判定为**有效**。将提供完整的解决方案。\n\n### 基于原则的解决方案设计\n实现将围绕以下原则构建：\n\n1.  **几何分类**：第一步是对计算网格上的每个节点进行分类。每个节点 $(x_i, y_j)$ 根据其相对于域边界 $\\partial\\Omega$ 和嵌入边界 $\\Gamma$ 的位置进行分类。类别有：\n    - `NODE_BOUNDARY`：位于外边界 $\\partial\\Omega$ 上的节点。其值为已知的狄利克雷值 ($0$)。\n    - `NODE_GAMMA`：直接位于嵌入边界 $\\Gamma$ 上的网格节点（在小容差内）。其值为已知的狄利克雷值，$g(x_i, y_j) = u^\\star(x_i, y_j)$。\n    - `NODE_SOLID`：位于固体区域 $K$ 内部，且不在 $\\Gamma$ 上的节点。这些节点不参与计算。\n    - `NODE_FLUID`：所有其他节点，位于流体域 $\\Omega_f$ 中但不在任何边界上。这些是 $u$ 值未知的位置。\n    一个稳健的几何谓词 `is_inside_convex` 将用于分类 `SOLID` 节点，`is_on_gamma` 用于分类 `GAMMA` 节点。\n\n2.  **系统组装**：为 `NODE_FLUID` 位置的未知值组装一个稀疏线性系统 $A\\mathbf{u}=\\mathbf{b}$。我们遍历每个 `FLUID` 节点 $(i,j)$ 来构造矩阵的一行。该节点的方程基于负拉普拉斯算子的五点近似，$-\\Delta u|_{i,j} \\approx \\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2} = f_{i,j}$。每个邻近项的处理取决于邻近节点的分类：\n    - **流体邻近节点**：使用标准耦合。这为对角线元素 $A_{k,k}$ 贡献 $1/h^2$，并创建一个非对角线元素 $A_{k,l} = -1/h^2$，其中 $l$ 是邻近未知数的索引。\n    - **狄利克雷邻近节点**（`BOUNDARY` 或 `GAMMA`）：邻近节点的值是已知的。这为对角线 $A_{k,k}$ 贡献 $1/h^2$，已知值被移到右端向量 $\\mathbf{b}$。对于值为 $u_{\\text{known}}$ 的邻近节点，这会为 $b_k$ 增加 $u_{\\text{known}}/h^2$。\n    - **固体邻近节点**：这是一个由 GFM 处理的“切割连线”。我们计算交点和分数距离 $\\alpha$。根据问题陈述，这为对角线 $A_{k,k}$ 贡献 $1/(\\alpha_{clamped} h^2)$，并为右端项 $b_k$ 增加 $g^\\star/(\\alpha_{clamped} h^2)$，其中 $\\alpha_{clamped} = \\max(\\alpha, 10^{-3})$，$g^\\star$ 是在交点处计算的 $u^\\star$。\n\n3.  **求解和误差计算**：使用直接求解器（`scipy.sparse.linalg.spsolve`）求解组装好的稀疏系统。得到的解向量包含所有 `FLUID` 节点的数值近似值 $u_{i,j}^{\\text{num}}$。然后根据提供的公式计算离散 $\\ell^2$ 误差。由于狄利克雷节点（`BOUNDARY` 和 `GAMMA`）的误差贡献根据定义为零（因为 $u_{i,j}^{\\text{num}}$ 被设置为精确值 $u^\\star(x_i, y_j)$），所以求和只需在计算解的 `FLUID` 节点上进行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\n# Suppress potential harmless floating point warnings in geometry calculations.\nnp.seterr(divide='ignore', invalid='ignore')\n\ndef u_star(x, y):\n    \"\"\"\n    The exact manufactured solution u*(x,y).\n    \"\"\"\n    return np.sin(math.pi * x) * np.sin(math.pi * y)\n\ndef f_source(x, y):\n    \"\"\"\n    The corresponding source term f = -Delta u*.\n    \"\"\"\n    return 2 * math.pi**2 * np.sin(math.pi * x) * np.sin(math.pi * y)\n\ndef get_polygon_orientation(poly):\n    \"\"\"\n    Determines if polygon vertices are ordered CW or CCW using the shoelace formula.\n    Returns \"ccw\" for counter-clockwise, \"cw\" for clockwise.\n    \"\"\"\n    area = 0.0\n    for i in range(len(poly)):\n        p1 = poly[i]\n        p2 = poly[(i + 1) % len(poly)]\n        area += (p1[0] * p2[1]) - (p2[0] * p1[1])\n    return \"ccw\" if area > 0 else \"cw\"\n\ndef is_inside_convex(p, ccw_poly, tol=1e-12):\n    \"\"\"\n    Checks if a point p is inside a convex polygon with CCW vertices.\n    A point is inside if it is to the left of all directed edges.\n    \"\"\"\n    for i in range(len(ccw_poly)):\n        p1 = ccw_poly[i]\n        p2 = ccw_poly[(i + 1) % len(ccw_poly)]\n        cross_product = (p2[0] - p1[0]) * (p[1] - p1[1]) - (p2[1] - p1[1]) * (p[0] - p1[0])\n        if cross_product < -tol:\n            return False\n    return True\n\ndef dist_point_to_line_segment(p, a, b):\n    \"\"\"\n    Calculates the shortest distance from a point p to a line segment ab.\n    \"\"\"\n    px, py = p[0] - a[0], p[1] - a[1]\n    bx, by = b[0] - a[0], b[1] - a[1]\n    \n    len_sq_b = bx * bx + by * by\n    if len_sq_b == 0:\n        return np.sqrt(px * px + py * py)\n\n    t = (px * bx + py * by) / len_sq_b\n    \n    if t < 0:\n        return np.sqrt((p[0] - a[0])**2 + (p[1] - a[1])**2)\n    elif t > 1:\n        return np.sqrt((p[0] - b[0])**2 + (p[1] - b[1])**2)\n    \n    closest_x, closest_y = a[0] + t * bx, a[1] + t * by\n    return np.sqrt((p[0] - closest_x)**2 + (p[1] - closest_y)**2)\n\ndef is_on_gamma(p, poly, tol=1e-9):\n    \"\"\"\n    Checks if a point p lies on the polygonal boundary Gamma.\n    \"\"\"\n    for i in range(len(poly)):\n        p1 = poly[i]\n        p2 = poly[(i + 1) % len(poly)]\n        if dist_point_to_line_segment(p, p1, p2) < tol:\n            return True\n    return False\n\ndef find_intersection(p_fluid, p_solid, ccw_poly):\n    \"\"\"\n    Finds the unique intersection of a line segment (from an exterior fluid point\n    to an interior solid point) with a convex polygon.\n    Returns the intersection point and the fractional distance alpha from the fluid point.\n    \"\"\"\n    x1, y1 = p_fluid\n    x2, y2 = p_solid\n    \n    min_alpha = float('inf')\n    intersect_pt = None\n\n    for i in range(len(ccw_poly)):\n        x3, y3 = ccw_poly[i]\n        x4, y4 = ccw_poly[(i + 1) % len(ccw_poly)]\n        \n        den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if abs(den) < 1e-12: continue\n            \n        t_num = (x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)\n        u_num = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3))\n        \n        t = t_num / den\n        u = u_num / den\n        \n        if 0 <= t <= 1 and 0 <= u <= 1:\n            if t < min_alpha:\n                min_alpha = t\n                intersect_pt = (x1 + t * (x2 - x1), y1 + t * (y2 - y1))\n    \n    if intersect_pt is None:\n        raise RuntimeError(f\"No intersection found for segment {p_fluid} to {p_solid}. This indicates a logic or floating point issue.\")\n\n    return intersect_pt, min_alpha\n\ndef solve_poisson_gfm(N, poly_verts):\n    \"\"\"\n    Assembles and solves the Poisson problem for a given grid size N and polygon.\n    \"\"\"\n    h = 1.0 / N\n    alpha_min = 1e-3\n\n    if get_polygon_orientation(poly_verts) == \"cw\":\n        poly_verts_ccw = poly_verts[::-1]\n    else:\n        poly_verts_ccw = poly_verts\n\n    NODE_FLUID, NODE_SOLID, NODE_BOUNDARY, NODE_GAMMA = 0, 1, 2, 3\n    node_type = np.full((N + 1, N + 1), NODE_FLUID, dtype=int)\n    coords = np.linspace(0, 1, N + 1)\n    \n    for i in range(N + 1):\n        for j in range(N + 1):\n            p = (coords[i], coords[j])\n            if i == 0 or i == N or j == 0 or j == N:\n                node_type[i, j] = NODE_BOUNDARY\n            elif is_on_gamma(p, poly_verts_ccw):\n                node_type[i, j] = NODE_GAMMA\n            elif is_inside_convex(p, poly_verts_ccw):\n                node_type[i, j] = NODE_SOLID\n\n    fluid_nodes_ij = np.argwhere(node_type == NODE_FLUID)\n    num_unknowns = len(fluid_nodes_ij)\n    ij_to_k = {tuple(ij): k for k, ij in enumerate(fluid_nodes_ij)}\n\n    A = lil_matrix((num_unknowns, num_unknowns), dtype=float)\n    b = np.zeros(num_unknowns, dtype=float)\n    inv_h2 = 1.0 / (h * h)\n    \n    for k, (i, j) in enumerate(fluid_nodes_ij):\n        x, y = coords[i], coords[j]\n        b[k] = f_source(x, y)\n        diag_val = 0.0\n        \n        neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\n        \n        for ni, nj in neighbors:\n            ntype = node_type[ni, nj]\n            \n            if ntype == NODE_FLUID:\n                diag_val += inv_h2\n                A[k, ij_to_k[(ni, nj)]] = -inv_h2\n            elif ntype == NODE_BOUNDARY:\n                diag_val += inv_h2\n                # RHS contribution is 0 since u=0 on boundary\n            elif ntype == NODE_GAMMA:\n                diag_val += inv_h2\n                nx, ny = coords[ni], coords[nj]\n                g_val = u_star(nx, ny)\n                b[k] += g_val * inv_h2\n            elif ntype == NODE_SOLID:\n                p_star, alpha = find_intersection((x, y), (coords[ni], coords[nj]), poly_verts_ccw)\n                alpha_clamped = max(alpha, alpha_min)\n                g_star = u_star(p_star[0], p_star[1])\n                \n                contrib_diag = 1.0 / (alpha_clamped * h * h)\n                contrib_rhs = g_star / (alpha_clamped * h * h)\n                \n                diag_val += contrib_diag\n                b[k] += contrib_rhs\n        A[k, k] = diag_val\n\n    u_sol = spsolve(A.tocsr(), b)\n\n    total_error_sq = 0.0\n    for k, (i, j) in enumerate(fluid_nodes_ij):\n        x, y = coords[i], coords[j]\n        error = u_sol[k] - u_star(x, y)\n        total_error_sq += error * error\n    \n    l2_error = np.sqrt((h * h) * total_error_sq)\n    return l2_error\n\ndef solve():\n    \"\"\"\n    Main entry point to run all test cases and print results in the specified format.\n    \"\"\"\n    test_cases = [\n        {\"N\": 40, \"poly\": [(0.2, 0.5), (0.5, 0.2), (0.8, 0.5), (0.5, 0.8)]},\n        {\"N\": 41, \"poly\": [(0.2, 0.5), (0.5, 0.2), (0.8, 0.5), (0.5, 0.8)]},\n        {\"N\": 64, \"poly\": [(0.2, 0.52), (0.52, 0.2), (0.8, 0.48), (0.48, 0.8)]},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_poisson_gfm(case[\"N\"], case[\"poly\"])\n        results.append(error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "幽灵流体方法的一个关键应用是模拟包含表面张力的两相流。在此类模拟中，物理上至关重要的毛细压力跳跃直接取决于界面曲率 $\\kappa$ 的精确计算。本练习将引导你量化界面重构精度对曲率计算误差的影响，让你通过编程实践，深刻理解几何近似（例如线性和二次重构）如何直接影响关键物理量 $\\Delta p = \\sigma \\kappa$ 的数值表示。",
            "id": "3376339",
            "problem": "考虑一个通过流体体积（VOF）方法捕捉的二维不可压缩两相界面，压力耦合通过幽灵流体方法（GFM）实现。GFM 根据毛细压力跃变在界面上施加一个压力不连续。该跃变由拉普拉斯定律给出，该定律指出压力跃变等于表面张力乘以界面曲率。界面是光滑的，局部曲率由均匀网格内界面形状的重构计算得出。\n\n基础原理：\n- 拉普拉斯压力跃变：如果界面曲率为 $\\,\\kappa\\,$，表面张力系数为 $\\,\\sigma\\,$，则界面上的压力跃变为 $\\,\\Delta p = \\sigma \\kappa\\,$。\n- 参数化为 $\\,y(x)\\,$ 的平面曲线的曲率由下式给出\n$$\n\\kappa(x) = \\frac{y''(x)}{\\left(1 + \\left(y'(x)\\right)^2\\right)^{3/2}}.\n$$\n\n界面配置：\n- 界面由正弦函数解析给出，\n$$\ny(x) = a \\sin\\left( \\frac{2\\pi}{\\lambda} x \\right),\n$$\n其中 $\\,a\\,$ 是振幅（单位：米），$\\,\\lambda\\,$ 是波长（单位：米）。\n- 空间域在 $\\,x\\,$ 方向上以一个波长 $\\,\\lambda\\,$ 为周期。\n- 一个由 $\\,N_x\\,$ 个点组成的均匀网格在位置 $\\,x_i = i \\Delta x\\,$（对于 $\\,i=0,1,\\dots,N_x-1\\,$，其中 $\\,\\Delta x = \\lambda/N_x\\,$）处对界面进行采样。\n\n重构策略：\n- 线性界面重构：在 $\\,x_i\\,$ 附近用一阶多项式逼近局部界面，\n$$\ny(x) \\approx \\alpha_i + \\beta_i (x - x_i),\n$$\n这导致 $\\,y''(x_i) \\approx 0\\,$，因此 $\\,\\kappa_{\\text{lin}}(x_i) \\approx 0\\,$.\n- 二次界面重构：使用最小二乘法，在五个点的对称模板 $\\,\\{x_{i-2}, x_{i-1}, x_{i}, x_{i+1}, x_{i+2}\\}\\,$ 上，用二阶多项式逼近 $\\,x_i\\,$ 附近的局部界面，\n$$\ny(x) \\approx a_{0,i} + a_{1,i} (x - x_i) + a_{2,i} (x - x_i)^2,\n$$\n由此可得\n$$\ny'(x_i) \\approx a_{1,i}, \\quad y''(x_i) \\approx 2 a_{2,i}, \\quad \\kappa_{\\text{quad}}(x_i) \\approx \\frac{2 a_{2,i}}{\\left( 1 + a_{1,i}^2 \\right)^{3/2}}.\n$$\n\n精确曲率：\n从解析界面计算 $\\,y'(x) = a \\left(\\frac{2\\pi}{\\lambda}\\right) \\cos\\left(\\frac{2\\pi}{\\lambda}x\\right)\\,$ 和 $\\,y''(x) = -a \\left(\\frac{2\\pi}{\\lambda}\\right)^2 \\sin\\left(\\frac{2\\pi}{\\lambda}x\\right)\\,$，以获得精确曲率\n$$\n\\kappa_{\\text{exact}}(x) = \\frac{-a \\left( \\frac{2\\pi}{\\lambda} \\right)^2 \\sin\\left( \\frac{2\\pi}{\\lambda} x \\right)}{\\left(1 + a^2 \\left( \\frac{2\\pi}{\\lambda} \\right)^2 \\cos^2\\left( \\frac{2\\pi}{\\lambda} x \\right) \\right)^{3/2}}.\n$$\n\n压力跃变误差量化：\n- 对于每个网格位置 $\\,x_i\\,$，计算精确压力跃变 $\\,\\Delta p_{\\text{exact}}(x_i) = \\sigma \\kappa_{\\text{exact}}(x_i)\\,$（单位：帕斯卡）。\n- 基于重构计算估算的压力跃变：\n$$\n\\Delta p_{\\text{lin}}(x_i) = \\sigma \\kappa_{\\text{lin}}(x_i), \\quad \\Delta p_{\\text{quad}}(x_i) = \\sigma \\kappa_{\\text{quad}}(x_i).\n$$\n- 通过周期域上的均方根误差（RMSE）来量化误差，\n$$\n\\text{RMSE}_{\\text{lin}} = \\sqrt{\\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left( \\Delta p_{\\text{lin}}(x_i) - \\Delta p_{\\text{exact}}(x_i) \\right)^2 },\n$$\n$$\n\\text{RMSE}_{\\text{quad}} = \\sqrt{\\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left( \\Delta p_{\\text{quad}}(x_i) - \\Delta p_{\\text{exact}}(x_i) \\right)^2 }.\n$$\n\n科学真实性：\n此设置模拟了幽灵流体方法（Ghost Fluid Method）在通过流体体积法（VOF）重构的界面上施加的由曲率引起的压力跃变。线性重构虽然是分段线性界面计算（PLIC）的标准方法，但无法在主阶上表示曲率，而二次重构则能捕捉曲率所需的二阶导数。产生的误差直接量化了错误施加的毛细压力（单位：帕斯卡），这会影响控制两相不可压缩流动的偏微分方程的数值解。\n\n测试套件：\n对于每个测试用例，程序应计算 $\\,\\text{RMSE}_{\\text{lin}}\\,$ 和 $\\,\\text{RMSE}_{\\text{quad}}\\,$（单位：帕斯卡）。\n\n- 测试用例 $\\,1\\,$ (常规路径): $\\,\\sigma = 0.072\\,$ N/m, $\\,\\lambda = 1.0\\,$ m, $\\,a = 0.05\\,$ m, $\\,N_x = 128\\,$.\n- 测试用例 $\\,2\\,$ (更大幅度): $\\,\\sigma = 0.072\\,$ N/m, $\\,\\lambda = 1.0\\,$ m, $\\,a = 0.20\\,$ m, $\\,N_x = 128\\,$.\n- 测试用例 $\\,3\\,$ (更高频率): $\\,\\sigma = 0.072\\,$ N/m, $\\,\\lambda = 0.25\\,$ m, $\\,a = 0.05\\,$ m, $\\,N_x = 128\\,$.\n- 测试用例 $\\,4\\,$ (更粗网格分辨率): $\\,\\sigma = 0.072\\,$ N/m, $\\,\\lambda = 1.0\\,$ m, $\\,a = 0.05\\,$ m, $\\,N_x = 32\\,$.\n\n在基于弧度定义的三角函数中，角度单位是隐式的。所有长度单位为米，压力单位为帕斯卡。您的程序必须计算并报告每个测试用例的 $\\,\\text{RMSE}_{\\text{lin}}\\,$ 和 $\\,\\text{RMSE}_{\\text{quad}}\\,$。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，顺序如下：\n$$\n\\left[ \\text{RMSE}_{\\text{lin}}^{(1)}, \\text{RMSE}_{\\text{quad}}^{(1)}, \\text{RMSE}_{\\text{lin}}^{(2)}, \\text{RMSE}_{\\text{quad}}^{(2)}, \\text{RMSE}_{\\text{lin}}^{(3)}, \\text{RMSE}_{\\text{quad}}^{(3)}, \\text{RMSE}_{\\text{lin}}^{(4)}, \\text{RMSE}_{\\text{quad}}^{(4)} \\right],\n$$\n其中上标表示测试用例编号。每个值必须是浮点数，单位为帕斯卡。",
            "solution": "问题陈述已经过严格审查，并被确定为**有效**。它在科学上基于计算流体动力学的原理，数学上是适定的、自洽的，并且没有歧义或矛盾。它提出了一个数值分析领域的严谨而有意义的任务，特别是有关于界面曲率估计的准确性，这是模拟具有表面张力的两相流中的一个关键组成部分。\n\n任务是计算两种不同界面重构方法（线性和二次）下，正弦界面上毛细压力跃变的均方根误差（RMSE）。解决方案首先对解析界面进行离散化，然后在每个网格点上计算精确的曲率和压力跃变。随后，使用每种重构方法估算压力跃变，并通过将这些估算值与精确值进行比较来计算 RMSE。\n\n**1. 离散化与精确解**\n\n域是正弦波的一个波长 $\\,\\lambda\\,$，由 $\\,N_x\\,$ 个等距点采样。网格间距为 $\\,\\Delta x = \\lambda/N_x\\,$，网格点为 $\\,x_i = i \\Delta x\\,$，其中 $\\,i=0, 1, \\dots, N_x-1\\,$.\n\n界面由 $\\,y(x) = a \\sin(kx)\\,$ 定义，其中 $\\,k = 2\\pi/\\lambda\\,$. 精确的一阶和二阶导数为：\n$$\ny'(x) = ak \\cos(kx)\n$$\n$$\ny''(x) = -ak^2 \\sin(kx)\n$$\n使用提供的公式计算每个网格点 $\\,x_i\\,$ 上的精确曲率 $\\,\\kappa_{\\text{exact}}(x_i)\\,$：\n$$\n\\kappa_{\\text{exact}}(x_i) = \\frac{y''(x_i)}{\\left(1 + \\left(y'(x_i)\\right)^2\\right)^{3/2}} = \\frac{-ak^2 \\sin(kx_i)}{\\left(1 + (ak)^2 \\cos^2(kx_i)\\right)^{3/2}}\n$$\n那么精确的压力跃变为 $\\,\\Delta p_{\\text{exact}}(x_i) = \\sigma \\kappa_{\\text{exact}}(x_i)\\,$，其中 $\\,\\sigma\\,$ 是表面张力系数。\n\n**2. 线性重构误差（$\\,\\text{RMSE}_{\\text{lin}}\\,$）**\n\n线性界面重构用一条直线来局部逼近界面。这意味着二阶导数以及曲率都为零。\n$$\n\\kappa_{\\text{lin}}(x_i) = 0 \\implies \\Delta p_{\\text{lin}}(x_i) = \\sigma \\kappa_{\\text{lin}}(x_i) = 0\n$$\n线性重构在每个点上的误差是 $\\,\\Delta p_{\\text{lin}}(x_i) - \\Delta p_{\\text{exact}}(x_i) = -\\Delta p_{\\text{exact}}(x_i)\\,$。因此，RMSE 是精确压力跃变本身的均方根：\n$$\n\\text{RMSE}_{\\text{lin}} = \\sqrt{\\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left(0 - \\Delta p_{\\text{exact}}(x_i)\\right)^2} = \\sqrt{\\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left(\\Delta p_{\\text{exact}}(x_i)\\right)^2}\n$$\n\n**3. 二次重构误差（$\\,\\text{RMSE}_{\\text{quad}}\\,$）**\n\n对于二次重构，$\\,x_i\\,$ 附近的界面由抛物线 $\\,y(x) \\approx P_i(x) = a_{0,i} + a_{1,i}(x-x_i) + a_{2,i}(x-x_i)^2\\,$ 逼近。系数 $\\,a_{0,i}\\,$, $\\,a_{1,i}\\,$ 和 $\\,a_{2,i}\\,$ 是通过对对称的 $\\,5\\,$ 点模板 $\\,\\{x_{i-2}, x_{i-1}, x_i, x_{i+1}, x_{i+2}\\}\\,$ 上的真实界面值 $\\,y_j = y(x_j)\\,$ 进行最小二乘拟合来确定的。问题是周期性的，因此索引对 $\\,N_x\\,$ 取模。\n\n我们寻求找到系数向量 $\\,\\mathbf{c}_i = [a_{0,i}, a_{1,i}, a_{2,i}]^T\\,$，以最小化残差平方和。这是一个线性最小二乘问题，通过正规方程 $\\,\\mathbf{A}^T\\mathbf{A}\\mathbf{c}_i = \\mathbf{A}^T\\mathbf{y}_{\\text{stencil},i}\\,$ 求解，其中 $\\,\\mathbf{y}_{\\text{stencil},i} = [y_{i-2}, y_{i-1}, y_i, y_{i+1}, y_{i+2}]^T\\,$ 且 $\\,\\mathbf{A}\\,$ 是设计矩阵：\n$$\n\\mathbf{A} = \\begin{pmatrix}\n1  -2\\Delta x  4(\\Delta x)^2 \\\\\n1  -\\Delta x  (\\Delta x)^2 \\\\\n1  0  0 \\\\\n1  \\Delta x  (\\Delta x)^2 \\\\\n1  2\\Delta x  4(\\Delta x)^2\n\\end{pmatrix}\n$$\n解为 $\\,\\mathbf{c}_i = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T \\mathbf{y}_{\\text{stencil},i}\\,$。算子矩阵 $\\,\\mathbf{P} = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T\\,$ 可以预先计算，因为它只依赖于 $\\,\\Delta x\\,$。我们感兴趣的是 $\\,a_{1,i}\\,$ 和 $\\,a_{2,i}\\,$，它们对应于 $\\,\\mathbf{P}\\,$ 的第二行和第三行。计算得出：\n$$\na_{1,i} = \\frac{1}{10\\Delta x}(-2y_{i-2} - y_{i-1} + y_{i+1} + 2y_{i+2})\n$$\n$$\na_{2,i} = \\frac{1}{14(\\Delta x)^2}(2y_{i-2} - y_{i-1} - 2y_i - y_{i+1} + 2y_{i+2})\n$$\n将这些模板应用于整个 $\\,y_i\\,$ 值网格，以获得所有网格点的系数向量 $\\,a_{1}\\,$ 和 $\\,a_{2}\\,$。在计算上，这可以通过使用带有周期性边界条件的向量化操作（例如，使用 `numpy.roll`）来高效地执行。\n\n从二次逼近中，$\\,x_i\\,$ 处的导数被估算为 $\\,y'(x_i) \\approx a_{1,i}\\,$ 和 $\\,y''(x_i) \\approx 2a_{2,i}\\,$。曲率则为：\n$$\n\\kappa_{\\text{quad}}(x_i) = \\frac{2a_{2,i}}{\\left(1 + a_{1,i}^2\\right)^{3/2}}\n$$\n相应的压力跃变为 $\\,\\Delta p_{\\text{quad}}(x_i) = \\sigma \\kappa_{\\text{quad}}(x_i)\\,$。\n\n最后，计算二次重构的 RMSE：\n$$\n\\text{RMSE}_{\\text{quad}} = \\sqrt{\\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left( \\Delta p_{\\text{quad}}(x_i) - \\Delta p_{\\text{exact}}(x_i) \\right)^2 }\n$$\n该实现将为四个指定的测试用例中的每一个计算这些量。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_errors(sigma, lam, a, Nx):\n    \"\"\"\n    Calculates the RMSE for pressure jump estimation using linear and quadratic reconstructions.\n\n    Args:\n        sigma (float): Surface tension coefficient (N/m).\n        lam (float): Wavelength of the sinusoid (m).\n        a (float): Amplitude of the sinusoid (m).\n        Nx (int): Number of grid points.\n\n    Returns:\n        tuple[float, float]: A tuple containing (RMSE_lin, RMSE_quad) in Pascals.\n    \"\"\"\n    # 1. Setup Grid\n    dx = lam / Nx\n    x = np.arange(Nx) * dx\n\n    # 2. Exact Interface, Derivatives, and Curvature\n    k = 2.0 * np.pi / lam\n    y = a * np.sin(k * x)\n    y_prime_exact = a * k * np.cos(k * x)\n    y_prime_prime_exact = -a * k**2 * np.sin(k * x)\n    \n    # Denominator for the exact curvature formula\n    denom_exact = (1.0 + y_prime_exact**2)**1.5\n    kappa_exact = y_prime_prime_exact / denom_exact\n\n    # 3. Exact Pressure Jump\n    dp_exact = sigma * kappa_exact\n\n    # 4. Linear Reconstruction Error\n    # For linear reconstruction, kappa_lin = 0, so dp_lin = 0.\n    # The error is the difference between 0 and dp_exact.\n    rmse_lin = np.sqrt(np.mean(dp_exact**2))\n\n    # 5. Quadratic Reconstruction Curvature\n    # The coefficients a_{1,i} and a_{2,i} are computed using stencils derived\n    # from a 5-point least-squares fit.\n    # We use np.roll to handle periodic boundary conditions efficiently.\n    # A positive shift k in np.roll corresponds to index i-k.\n    y_m2 = np.roll(y, 2)  # y_{i-2}\n    y_m1 = np.roll(y, 1)  # y_{i-1}\n    y_p1 = np.roll(y, -1) # y_{i+1}\n    y_p2 = np.roll(y, -2) # y_{i+2}\n\n    # Stencil for a_{1,i}, which approximates y'(x_i)\n    a1_quad = (1.0 / (10.0 * dx)) * (-2.0 * y_m2 - y_m1 + y_p1 + 2.0 * y_p2)\n\n    # Stencil for a_{2,i}, where 2*a_{2,i} approximates y''(x_i)\n    a2_quad = (1.0 / (14.0 * dx**2)) * (2.0 * y_m2 - y_m1 - 2.0 * y - y_p1 + 2.0 * y_p2)\n\n    y_prime_quad = a1_quad\n    y_prime_prime_quad = 2.0 * a2_quad\n    \n    # Denominator for the quadratic curvature formula\n    denom_quad = (1.0 + y_prime_quad**2)**1.5\n    kappa_quad = y_prime_prime_quad / denom_quad\n    dp_quad = sigma * kappa_quad\n    \n    # 6. Quadratic Reconstruction Error\n    rmse_quad = np.sqrt(np.mean((dp_quad - dp_exact)**2))\n\n    return rmse_lin, rmse_quad\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (sigma, lambda, a, Nx)\n        (0.072, 1.0, 0.05, 128),  # Test Case 1\n        (0.072, 1.0, 0.20, 128),  # Test Case 2\n        (0.072, 0.25, 0.05, 128), # Test Case 3\n        (0.072, 1.0, 0.05, 32),   # Test Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        sigma, lam, a, Nx = case\n        rmse_lin, rmse_quad = calculate_errors(sigma, lam, a, Nx)\n        results.append(rmse_lin)\n        results.append(rmse_quad)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}