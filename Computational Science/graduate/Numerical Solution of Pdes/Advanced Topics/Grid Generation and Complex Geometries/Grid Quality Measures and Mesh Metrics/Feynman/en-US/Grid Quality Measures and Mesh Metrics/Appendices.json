{
    "hands_on_practices": [
        {
            "introduction": "Understanding grid quality begins at the most fundamental level: the geometry of a single cell and its faces. Before we can assess an entire mesh of millions of elements, we must be able to quantify the properties that determine accuracy and stability on a local scale. This first exercise  provides a hands-on opportunity to calculate two of the most critical metrics in finite volume methods—orthogonality and skewness—directly from coordinate data, connecting abstract definitions to concrete vector algebra.",
            "id": "3402357",
            "problem": "Consider the steady diffusion of a scalar field $\\phi$ governed by the conservation law $\\nabla \\cdot \\left( \\Gamma \\nabla \\phi \\right) = 0$, where $\\Gamma$ is a positive constant diffusivity. In a cell-centered Finite Volume (FV) discretization, the diffusive flux across an internal face $f$ shared by two adjacent control volumes $P$ and $N$ is obtained from the surface integral of $\\Gamma \\nabla \\phi \\cdot \\boldsymbol{n}_f$ over the face, with face area vector $\\boldsymbol{S}_f = \\boldsymbol{n}_f \\, |\\boldsymbol{S}_f|$. On non-orthogonal meshes, the canonical two-point approximation can be understood by decomposing $\\boldsymbol{S}_f$ into components parallel and perpendicular to the line joining cell centers, which directly motivates mesh quality metrics associated with orthogonality and skewness.\n\nStart from the following fundamental bases:\n- The diffusive flux definition, the divergence theorem, and the dot product, without assuming any specific discrete formula.\n- The vector decomposition identity $\\boldsymbol{a} = \\left( \\boldsymbol{a} \\cdot \\hat{\\boldsymbol{e}} \\right) \\hat{\\boldsymbol{e}} + \\left[ \\boldsymbol{a} - \\left( \\boldsymbol{a} \\cdot \\hat{\\boldsymbol{e}} \\right) \\hat{\\boldsymbol{e}} \\right]$ for any vector $\\boldsymbol{a}$ and unit vector $\\hat{\\boldsymbol{e}}$.\n\nFor a particular internal face $f$ in two space dimensions, you are given:\n- Cell-center positions $\\boldsymbol{x}_P = (0, 0)$ and $\\boldsymbol{x}_N = \\left(1, \\frac{1}{\\sqrt{3}}\\right)$.\n- Face unit normal $\\boldsymbol{n}_f = (1, 0)$ and face area magnitude $|\\boldsymbol{S}_f| = 1$, so $\\boldsymbol{S}_f = (1, 0)$.\n- Face center $\\boldsymbol{x}_f = \\left(\\frac{1}{2}, \\frac{1}{10}\\right)$.\n- Let $\\boldsymbol{d} = \\boldsymbol{x}_N - \\boldsymbol{x}_P$ and $\\hat{\\boldsymbol{d}} = \\boldsymbol{d} / |\\boldsymbol{d}|$.\n\nUsing only the above bases and the geometry provided, do the following:\n1) Define the orthogonality factor $O$ for face $f$ as the cosine of the angle between $\\boldsymbol{n}_f$ and $\\hat{\\boldsymbol{d}}$, i.e., $O = \\left| \\boldsymbol{n}_f \\cdot \\hat{\\boldsymbol{d}} \\right|$, and derive its value from the data.\n2) Define the skewness vector $\\boldsymbol{s}$ as the vector from the orthogonal intersection point of the line through $\\boldsymbol{x}_P$ and $\\boldsymbol{x}_N$ with the face to the actual face center $\\boldsymbol{x}_f$. Precisely, let $\\boldsymbol{x}_I$ be the unique point on the line segment connecting $\\boldsymbol{x}_P$ and $\\boldsymbol{x}_N$ with the same face-normal coordinate as $\\boldsymbol{x}_f$; then $\\boldsymbol{s} = \\boldsymbol{x}_f - \\boldsymbol{x}_I$. Define the normalized skewness measure $K = \\frac{|\\boldsymbol{s}|}{|\\boldsymbol{d}|}$, and derive its value from the data.\n3) Combine these to form the dimensionless mesh quality index\n$$\nM \\;=\\; \\frac{O^2}{\\,1 + K^2\\,}.\n$$\nCompute $M$ from first principles using your results from steps $1$–$2$.\n\nReport the final value of $M$ as a single dimensionless number, rounded to four significant figures. Do not include any units in your final answer.",
            "solution": "The problem is first subject to validation based on the provided criteria.\n\n**Step 1: Extract Givens**\n-   Governing equation: $\\nabla \\cdot \\left( \\Gamma \\nabla \\phi \\right) = 0$.\n-   Discretization method: Cell-centered Finite Volume (FV).\n-   Cell-center positions: $\\boldsymbol{x}_P = (0, 0)$ and $\\boldsymbol{x}_N = \\left(1, \\frac{1}{\\sqrt{3}}\\right)$.\n-   Face unit normal: $\\boldsymbol{n}_f = (1, 0)$.\n-   Face area magnitude: $|\\boldsymbol{S}_f| = 1$.\n-   Face area vector: $\\boldsymbol{S}_f = (1, 0)$.\n-   Face center: $\\boldsymbol{x}_f = \\left(\\frac{1}{2}, \\frac{1}{10}\\right)$.\n-   Vector between cell centers: $\\boldsymbol{d} = \\boldsymbol{x}_N - \\boldsymbol{x}_P$.\n-   Unit vector along $\\boldsymbol{d}$: $\\hat{\\boldsymbol{d}} = \\boldsymbol{d} / |\\boldsymbol{d}|$.\n-   Orthogonality factor: $O = \\left| \\boldsymbol{n}_f \\cdot \\hat{\\boldsymbol{d}} \\right|$.\n-   Skewness vector: $\\boldsymbol{s} = \\boldsymbol{x}_f - \\boldsymbol{x}_I$, where $\\boldsymbol{x}_I$ is the point on the line segment $\\overline{\\boldsymbol{x}_P \\boldsymbol{x}_N}$ such that $(\\boldsymbol{x}_I - \\boldsymbol{x}_f) \\cdot \\boldsymbol{n}_f = 0$.\n-   Normalized skewness measure: $K = \\frac{|\\boldsymbol{s}|}{|\\boldsymbol{d}|}$.\n-   Mesh quality index: $M = \\frac{O^2}{\\,1 + K^2\\,}$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is well-defined within the field of computational fluid dynamics and numerical methods for PDEs. The concepts of orthogonality and skewness are standard mesh quality metrics. All required data are provided, and the definitions of the quantities to be computed ($O$, $K$, $M$) are mathematically precise and unambiguous. The problem is scientifically grounded, objective, complete, and well-posed. There are no contradictions or unrealistic assumptions.\n\n**Step 3: Verdict and Action**\nThe problem is deemed valid. A complete solution will be provided.\n\n**Solution Derivation**\n\nThe solution proceeds in three parts as requested: calculation of the orthogonality factor $O$, the normalized skewness measure $K$, and finally the mesh quality index $M$.\n\n**1. Calculation of the Orthogonality Factor $O$**\n\nFirst, we determine the vector $\\boldsymbol{d}$ connecting the cell centers $\\boldsymbol{x}_P$ and $\\boldsymbol{x}_N$:\n$$\n\\boldsymbol{d} = \\boldsymbol{x}_N - \\boldsymbol{x}_P = \\left(1, \\frac{1}{\\sqrt{3}}\\right) - (0, 0) = \\left(1, \\frac{1}{\\sqrt{3}}\\right)\n$$\nNext, we compute the magnitude of $\\boldsymbol{d}$:\n$$\n|\\boldsymbol{d}| = \\sqrt{1^2 + \\left(\\frac{1}{\\sqrt{3}}\\right)^2} = \\sqrt{1 + \\frac{1}{3}} = \\sqrt{\\frac{4}{3}} = \\frac{2}{\\sqrt{3}}\n$$\nThe unit vector $\\hat{\\boldsymbol{d}}$ in the direction of $\\boldsymbol{d}$ is then:\n$$\n\\hat{\\boldsymbol{d}} = \\frac{\\boldsymbol{d}}{|\\boldsymbol{d}|} = \\frac{\\left(1, \\frac{1}{\\sqrt{3}}\\right)}{\\frac{2}{\\sqrt{3}}} = \\frac{\\sqrt{3}}{2} \\left(1, \\frac{1}{\\sqrt{3}}\\right) = \\left(\\frac{\\sqrt{3}}{2}, \\frac{1}{2}\\right)\n$$\nThe orthogonality factor $O$ is defined as the absolute value of the dot product of the face unit normal $\\boldsymbol{n}_f$ and the unit vector $\\hat{\\boldsymbol{d}}$:\n$$\nO = |\\boldsymbol{n}_f \\cdot \\hat{\\boldsymbol{d}}| = \\left| (1, 0) \\cdot \\left(\\frac{\\sqrt{3}}{2}, \\frac{1}{2}\\right) \\right| = \\left| 1 \\cdot \\frac{\\sqrt{3}}{2} + 0 \\cdot \\frac{1}{2} \\right| = \\frac{\\sqrt{3}}{2}\n$$\n\n**2. Calculation of the Normalized Skewness Measure $K$**\n\nThe point $\\boldsymbol{x}_I$ lies on the line passing through $\\boldsymbol{x}_P$ and $\\boldsymbol{x}_N$. Any point on this line can be parameterized as $\\boldsymbol{x}(t) = \\boldsymbol{x}_P + t(\\boldsymbol{x}_N - \\boldsymbol{x}_P) = t \\boldsymbol{d}$ for a scalar parameter $t$. Thus, $\\boldsymbol{x}_I = t_I \\boldsymbol{d}$ for some specific value $t_I$.\n\nThe defining condition for $\\boldsymbol{x}_I$ is that it has the same face-normal coordinate as the face center $\\boldsymbol{x}_f$. Mathematically, this is expressed as $\\boldsymbol{x}_I \\cdot \\boldsymbol{n}_f = \\boldsymbol{x}_f \\cdot \\boldsymbol{n}_f$. We substitute the expressions for $\\boldsymbol{x}_I$ and the given vectors:\n$$\n(t_I \\boldsymbol{d}) \\cdot \\boldsymbol{n}_f = \\boldsymbol{x}_f \\cdot \\boldsymbol{n}_f\n$$\n$$\nt_I (\\boldsymbol{d} \\cdot \\boldsymbol{n}_f) = \\boldsymbol{x}_f \\cdot \\boldsymbol{n}_f\n$$\nWe compute the necessary dot products:\n$$\n\\boldsymbol{d} \\cdot \\boldsymbol{n}_f = \\left(1, \\frac{1}{\\sqrt{3}}\\right) \\cdot (1, 0) = 1\n$$\n$$\n\\boldsymbol{x}_f \\cdot \\boldsymbol{n}_f = \\left(\\frac{1}{2}, \\frac{1}{10}\\right) \\cdot (1, 0) = \\frac{1}{2}\n$$\nSubstituting these values back into the equation for $t_I$:\n$$\nt_I (1) = \\frac{1}{2} \\implies t_I = \\frac{1}{2}\n$$\nSince $t_I = \\frac{1}{2}$ is between $0$ and $1$, the point $\\boldsymbol{x}_I$ lies on the line segment $\\overline{\\boldsymbol{x}_P \\boldsymbol{x}_N}$ as required. Now we find the coordinates of $\\boldsymbol{x}_I$:\n$$\n\\boldsymbol{x}_I = \\frac{1}{2} \\boldsymbol{d} = \\frac{1}{2} \\left(1, \\frac{1}{\\sqrt{3}}\\right) = \\left(\\frac{1}{2}, \\frac{1}{2\\sqrt{3}}\\right)\n$$\nThe skewness vector $\\boldsymbol{s}$ is the difference between the face center $\\boldsymbol{x}_f$ and the intersection point $\\boldsymbol{x}_I$:\n$$\n\\boldsymbol{s} = \\boldsymbol{x}_f - \\boldsymbol{x}_I = \\left(\\frac{1}{2}, \\frac{1}{10}\\right) - \\left(\\frac{1}{2}, \\frac{1}{2\\sqrt{3}}\\right) = \\left(0, \\frac{1}{10} - \\frac{1}{2\\sqrt{3}}\\right)\n$$\nThe magnitude of the skewness vector is:\n$$\n|\\boldsymbol{s}| = \\left| \\frac{1}{10} - \\frac{1}{2\\sqrt{3}} \\right| = \\left| \\frac{\\sqrt{3} - 5}{10\\sqrt{3}} \\right|\n$$\nSince $\\sqrt{3} \\approx 1.732  5$, the term inside the absolute value is negative. Therefore:\n$$\n|\\boldsymbol{s}| = \\frac{5 - \\sqrt{3}}{10\\sqrt{3}} = \\frac{\\sqrt{3}(5 - \\sqrt{3})}{10 \\cdot 3} = \\frac{5\\sqrt{3} - 3}{30}\n$$\nThe normalized skewness measure $K$ is the ratio of $|\\boldsymbol{s}|$ to $|\\boldsymbol{d}|$:\n$$\nK = \\frac{|\\boldsymbol{s}|}{|\\boldsymbol{d}|} = \\frac{\\frac{5\\sqrt{3} - 3}{30}}{\\frac{2}{\\sqrt{3}}} = \\frac{(5\\sqrt{3} - 3)\\sqrt{3}}{30 \\cdot 2} = \\frac{5 \\cdot 3 - 3\\sqrt{3}}{60} = \\frac{15 - 3\\sqrt{3}}{60} = \\frac{5 - \\sqrt{3}}{20}\n$$\n\n**3. Calculation of the Mesh Quality Index $M$**\n\nThe mesh quality index $M$ is given by the formula $M = \\frac{O^2}{1 + K^2}$.\nWe have $O = \\frac{\\sqrt{3}}{2}$, so $O^2 = \\left(\\frac{\\sqrt{3}}{2}\\right)^2 = \\frac{3}{4}$.\nWe have $K = \\frac{5 - \\sqrt{3}}{20}$, so $K^2$ is:\n$$\nK^2 = \\left(\\frac{5 - \\sqrt{3}}{20}\\right)^2 = \\frac{5^2 - 2(5)\\sqrt{3} + (\\sqrt{3})^2}{20^2} = \\frac{25 - 10\\sqrt{3} + 3}{400} = \\frac{28 - 10\\sqrt{3}}{400} = \\frac{14 - 5\\sqrt{3}}{200}\n$$\nNow we compute $1 + K^2$:\n$$\n1 + K^2 = 1 + \\frac{14 - 5\\sqrt{3}}{200} = \\frac{200 + 14 - 5\\sqrt{3}}{200} = \\frac{214 - 5\\sqrt{3}}{200}\n$$\nFinally, we substitute these expressions into the formula for $M$:\n$$\nM = \\frac{O^2}{1 + K^2} = \\frac{\\frac{3}{4}}{\\frac{214 - 5\\sqrt{3}}{200}} = \\frac{3}{4} \\cdot \\frac{200}{214 - 5\\sqrt{3}} = \\frac{3 \\cdot 50}{214 - 5\\sqrt{3}} = \\frac{150}{214 - 5\\sqrt{3}}\n$$\nTo obtain the final numerical value, we use the approximation $\\sqrt{3} \\approx 1.73205$:\n$$\nM \\approx \\frac{150}{214 - 5(1.73205)} = \\frac{150}{214 - 8.66025} = \\frac{150}{205.33975} \\approx 0.730504\n$$\nRounding to four significant figures, we get $M = 0.7305$.",
            "answer": "$$\n\\boxed{0.7305}\n$$"
        },
        {
            "introduction": "A good mesh is not just geometrically sound; it is also efficient, delivering the required accuracy at the minimum computational cost. This principle leads to the concept of anisotropic adaptation, where mesh elements are stretched and oriented to match the features of the solution. This practice problem  presents a classic optimization challenge, asking you to derive the ideal element aspect ratio that perfectly balances interpolation error against the number of elements. The exercise reveals a core principle of adaptive meshing: for optimal efficiency, the grid's anisotropy should reflect the solution's anisotropy.",
            "id": "3402345",
            "problem": "Consider a scalar field $u(x,y)$ on a rectangular domain $\\Omega \\subset \\mathbb{R}^{2}$ with side lengths $L_x > 0$ and $L_y > 0$, where $u$ is the solution of a second-order elliptic Partial Differential Equation (PDE). Assume that the Hessian of $u$ is spatially constant and diagonal in the coordinate basis, $\\nabla^{2} u = \\operatorname{diag}(\\alpha, \\beta)$, with $\\alpha > 0$ and $\\beta > 0$. You will design a structured, axis-aligned, rectangular mesh with $n_x$ subdivisions in the $x$-direction and $n_y$ subdivisions in the $y$-direction. The element edge lengths are $h_x = L_x/n_x$ and $h_y = L_y/n_y$, and the total number of elements is $N = n_x n_y = A/(h_x h_y)$, where $A = L_x L_y$ is the domain area. \n\nAs a grid quality measure, consider the leading-order interpolation error surrogate for piecewise linear finite elements on rectangles aligned with the axes, obtained from the Taylor remainder for $u$ with constant Hessian. This surrogate takes the form\n$E(h_{x}, h_{y}) = c A (\\alpha h_{x}^{2} + \\beta h_{y}^{2})$,\nwhere $c > 0$ is a constant that depends only on the choice of norm and reference-element scaling. As a computational cost model, consider the element count,\n$C(h_{x}, h_{y}) = N = \\frac{A}{h_{x} h_{y}}$.\nTo articulate quality–cost trade-offs in adaptive meshing, define the composite objective\n$J(h_{x}, h_{y}) = E(h_{x}, h_{y}) + \\mu C(h_{x}, h_{y}) = c A (\\alpha h_{x}^{2} + \\beta h_{y}^{2}) + \\mu \\frac{A}{h_{x} h_{y}}$,\nwith $\\mu > 0$ a fixed parameter that represents computational cost per element measured in consistent units with $E$. \n\nStarting from the Taylor remainder characterization of interpolation error on rectangles, the relation between discrete element sizes and element count on structured grids, and the definition of the composite objective above, derive the optimal anisotropy ratio\n$$\nr^{\\star} = \\frac{h_{y}}{h_{x}},\n$$\nthat minimizes $J(h_{x}, h_{y})$ over $h_{x} > 0$ and $h_{y} > 0$. Express your final answer as a closed-form analytic expression in terms of $\\alpha$ and $\\beta$ only. No numerical rounding is required. Provide your final answer as the formula for $r^{\\star}$ with no units.",
            "solution": "The objective is to find the values of $h_x > 0$ and $h_y > 0$ that minimize the composite objective function:\n$$ J(h_x, h_y) = c A (\\alpha h_x^2 + \\beta h_y^2) + \\mu \\frac{A}{h_x h_y} $$\nTo find the minimum, we compute the partial derivatives of $J$ with respect to $h_x$ and $h_y$ and set them to zero. This is the first-order necessary condition for a minimum.\n\nFirst, the partial derivative with respect to $h_x$:\n$$ \\frac{\\partial J}{\\partial h_x} = \\frac{\\partial}{\\partial h_x} \\left( c A (\\alpha h_x^2 + \\beta h_y^2) + \\mu A h_x^{-1} h_y^{-1} \\right) = c A (2 \\alpha h_x) - \\mu A h_x^{-2} h_y^{-1} $$\nSetting this to zero:\n$$ 2 c A \\alpha h_x = \\frac{\\mu A}{h_x^2 h_y} \\implies 2 c \\alpha h_x^3 h_y = \\mu \\quad (1) $$\n\nNext, the partial derivative with respect to $h_y$:\n$$ \\frac{\\partial J}{\\partial h_y} = \\frac{\\partial}{\\partial h_y} \\left( c A (\\alpha h_x^2 + \\beta h_y^2) + \\mu A h_x^{-1} h_y^{-1} \\right) = c A (2 \\beta h_y) - \\mu A h_x^{-1} h_y^{-2} $$\nSetting this to zero:\n$$ 2 c A \\beta h_y = \\frac{\\mu A}{h_x h_y^2} \\implies 2 c \\beta h_x h_y^3 = \\mu \\quad (2) $$\n\nSince both equations (1) and (2) equal $\\mu$, we can equate their left-hand sides:\n$$ 2 c \\alpha h_x^3 h_y = 2 c \\beta h_x h_y^3 $$\nSince $h_x, h_y, c, \\alpha, \\beta$ are all positive, we can safely divide by $2c h_x h_y$:\n$$ \\alpha h_x^2 = \\beta h_y^2 $$\nWe are asked for the optimal anisotropy ratio $r^\\star = h_y / h_x$. Rearranging the equation above gives:\n$$ \\frac{h_y^2}{h_x^2} = \\frac{\\alpha}{\\beta} $$\n$$ \\left(\\frac{h_y}{h_x}\\right)^2 = \\frac{\\alpha}{\\beta} $$\nTaking the square root of both sides (and since $h_x, h_y$ are positive lengths, their ratio is positive):\n$$ r^\\star = \\frac{h_y}{h_x} = \\sqrt{\\frac{\\alpha}{\\beta}} $$\nThis result shows that the optimal aspect ratio of the mesh elements depends directly on the ratio of the solution's second derivatives, confirming the principle that the mesh anisotropy should mirror the solution's anisotropy for optimal efficiency.",
            "answer": "$$\n\\boxed{\\sqrt{\\frac{\\alpha}{\\beta}}}\n$$"
        },
        {
            "introduction": "Our final practice moves into the realm of advanced, solution-aware mesh adaptation for nonlinear partial differential equations. While metrics based on the solution's Hessian are powerful, they only tell part of the story when the PDE itself is nonlinear. This exercise  challenges you to design a metric for the $p$-Laplacian, where the material properties effectively change with the solution gradient. You will derive a metric that accounts not only for the solution's curvature but also for the local sensitivity of the nonlinear flux, representing a crucial step towards creating truly intelligent and efficient meshes for complex multiphysics simulations.",
            "id": "3402352",
            "problem": "You are to design and implement a mesh metric for anisotropic mesh adaptation in the numerical solution of partial differential equations (PDEs), specifically for the $p$-Laplacian $-\\nabla \\cdot \\left(|\\nabla u|^{p-2} \\nabla u\\right) = f$ on the unit square $\\Omega = [0,1]^2$ with an analytically known smooth solution $u(x,y)$. The goal is to enforce equal interpolation error in the principal directions defined by the Hessian of $u$, while consistently accounting for the nonlinear coupling introduced by the flux nonlinearity in the $p$-Laplacian.\n\nStart from the following foundational base:\n- The interpolation error of a piecewise linear finite element approximation of a twice continuously differentiable function $u$ along a direction aligned with an eigenvector of the Hessian $\\nabla^2 u$ scales as the product of the squared mesh size in that direction and the corresponding eigenvalue magnitude. Specifically, if $\\lambda_i$ is an eigenvalue of $\\nabla^2 u$ with associated unit eigenvector $v_i$, then the directional interpolation error magnitude behaves like a constant times $|\\lambda_i| h_i^2$, where $h_i$ is the physical mesh spacing along $v_i$.\n- The flux of the $p$-Laplacian is $F(\\nabla u) = |\\nabla u|^{p-2} \\nabla u$. For small perturbations of $u$, the sensitivity of the flux to changes in $\\nabla u$ is governed by the Jacobian matrix $\\partial F / \\partial (\\nabla u)$ evaluated at the current state.\n\nDesign a symmetric positive definite mesh metric tensor $M(x)$ such that the interpolation error is equalized along the principal Hessian directions after accounting for the nonlinear coupling with the $p$-Laplacian flux. The equalization should be enforced relative to a prescribed local error tolerance $\\varepsilon > 0$. Use the following requirements:\n- The principal directions are defined by the eigenvectors of the Hessian $\\nabla^2 u(x)$.\n- The nonlinear coupling must be incorporated by weighting the contribution of each principal direction according to the local sensitivity of the flux to perturbations in that direction, which depends on $p$ and the gradient $\\nabla u(x)$.\n- The metric should determine, for each principal direction, a local mesh spacing that equalizes the predicted interpolation error with the tolerance $\\varepsilon$; i.e., the predicted directional errors should match $\\varepsilon$.\n- Angle-dependent quantities must be treated consistently. If an angle $\\theta$ between vectors is introduced, it must be understood to be measured in radians.\n\nTo make the problem self-contained and implementable without solving a PDE numerically, use the analytic function $u(x,y) = \\sin(\\pi x) \\sin(\\pi y)$ on the domain $\\Omega = [0,1]^2$. This function is smooth and its gradient and Hessian can be computed exactly. Your task is to:\n1. Derive, from first principles, a directional sensitivity to be used for weighting the principal Hessian directions, based on the local Jacobian of the $p$-Laplacian flux and the alignment between the gradient direction and the Hessian eigenvectors.\n2. Derive the anisotropic metric $M(x)$ that enforces equal interpolation error along the principal Hessian directions, relative to a given error tolerance $\\varepsilon$.\n3. Implement a program that computes the metric eigenvalues and eigenvectors at a point $(x,y)$, and reports the anisotropy ratio $\\kappa(x,y)$ defined as the square root of the ratio of the largest to the smallest metric eigenvalue at that point. Use a small regularization parameter $\\delta > 0$ to avoid degeneracy when $|\\nabla u|$ vanishes by replacing $|\\nabla u|$ with $\\sqrt{|\\nabla u|^2 + \\delta^2}$ wherever needed.\n4. Demonstrate the nonlinear coupling by evaluating how the anisotropy changes with $p$ and the alignment between $\\nabla u$ and the principal Hessian directions.\n\nUnits: This problem is dimensionless and requires no physical units.\n\nAngle unit: When an angle $\\theta$ is used, it must be measured in radians.\n\nYour program must use the analytic $u(x,y)$ above and compute, for each specified test case, the anisotropy ratio $\\kappa$ at the given point or over the domain. The test suite is:\n\n- Case A (happy path): $p = 2$, $\\varepsilon = 10^{-2}$, $\\delta = 10^{-8}$, evaluated at $(x,y) = (0.3,0.4)$.\n- Case B (nonlinear, stronger coupling): $p = 3$, $\\varepsilon = 10^{-2}$, $\\delta = 10^{-8}$, evaluated at $(x,y) = (0.7,0.2)$.\n- Case C (edge case, near-zero gradient): $p = 1.5$, $\\varepsilon = 10^{-2}$, $\\delta = 10^{-6}$, evaluated at $(x,y) = (0.5,0.5)$.\n- Case D (domain-wide statistics to explore coupling variability): $p = 3$, $\\varepsilon = 10^{-2}$, $\\delta = 10^{-8}$, compute the average anisotropy ratio over a uniform $50 \\times 50$ grid of points covering $\\Omega$ and also compute the maximum anisotropy ratio over the same grid.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\kappa_{\\text{A}}, \\kappa_{\\text{B}}, \\kappa_{\\text{C}}, \\overline{\\kappa}_{\\text{D}}, \\kappa_{\\max,\\text{D}}]$, where $\\kappa_{\\text{A}}$, $\\kappa_{\\text{B}}$, $\\kappa_{\\text{C}}$ are the anisotropy ratios for Cases A, B, C respectively, $\\overline{\\kappa}_{\\text{D}}$ is the average anisotropy over the grid for Case D, and $\\kappa_{\\max,\\text{D}}$ is the maximum anisotropy over the grid for Case D. All outputs must be floating-point numbers.",
            "solution": "The problem requires the derivation and implementation of an anisotropic mesh metric tensor $M(x)$ for the numerical solution of the $p$-Laplacian equation. The metric aims to equidistribute the interpolation error, weighted by the nonlinearity of the PDE, across the principal directions of the solution's Hessian.\n\n### Step 1: Foundational Principles\n\nWe begin with the provided principles:\n1.  **Interpolation Error:** For a function $u(x,y)$ with Hessian $\\nabla^2 u$, the interpolation error for a piecewise linear approximation along a principal direction $v_i$ (an eigenvector of $\\nabla^2 u$) is proportional to the curvature in that direction and the square of the mesh size $h_i$. Let $\\lambda_i$ be the eigenvalue corresponding to $v_i$. The directional error $E_i$ is given by:\n    $$E_i \\propto |\\lambda_i| h_i^2$$\n2.  **PDE Flux:** The PDE is the $p$-Laplacian, $-\\nabla \\cdot F(\\nabla u) = f$, where the flux is $F(\\nabla u) = |\\nabla u|^{p-2} \\nabla u$. The problem's physics is encapsulated in this flux term.\n\n### Step 2: Derivation of the Nonlinear Flux Sensitivity Weight\n\nTo account for the nonlinear coupling, we must weigh the interpolation error by the sensitivity of the flux to gradient perturbations in each principal direction. This sensitivity is captured by the Jacobian of the flux, $J_F$. Let $g = \\nabla u = (u_x, u_y)^T$. The flux is $F(g) = |g|^{p-2} g$.\n\nThe Jacobian $J_F = \\frac{\\partial F}{\\partial g}$ is a $2 \\times 2$ matrix. Using the product rule for differentiation on the vector function $F(g)$:\n$$J_F = \\frac{\\partial}{\\partial g} \\left( |g|^{p-2} g \\right) = \\left( \\frac{\\partial}{\\partial g} |g|^{p-2} \\right) \\otimes g + |g|^{p-2} \\frac{\\partial g}{\\partial g}$$\nwhere $\\otimes$ is the outer product and $\\frac{\\partial g}{\\partial g}$ is the identity matrix $I$. The derivative of the magnitude term is:\n$$\\frac{\\partial}{\\partial g} |g|^{p-2} = (p-2)|g|^{p-3} \\frac{\\partial |g|}{\\partial g} = (p-2)|g|^{p-3} \\frac{g^T}{|g|} = (p-2)|g|^{p-4} g^T$$\nSubstituting this back, we get:\n$$J_F = (p-2)|g|^{p-4} g g^T + |g|^{p-2} I$$\nThis Jacobian describes how a small perturbation $\\delta g$ in the gradient is transformed into a perturbation in the flux, $\\delta F \\approx J_F \\delta g$.\n\nThe directional sensitivity $S_i$ in a principal direction $v_i$ of the Hessian can be quantified by how much the flux changes in response to a gradient perturbation along $v_i$. A suitable measure is the Rayleigh quotient of $J_F$ with respect to $v_i$:\n$$S_i = v_i^T J_F v_i$$\nAssuming $v_i$ are unit eigenvectors:\n$$S_i = v_i^T \\left( (p-2)|g|^{p-4} g g^T + |g|^{p-2} I \\right) v_i$$\n$$S_i = (p-2)|g|^{p-4} (v_i^T g)(g^T v_i) + |g|^{p-2} (v_i^T I v_i)$$\n$$S_i = (p-2)|g|^{p-4} (g \\cdot v_i)^2 + |g|^{p-2}$$\nTo handle cases where the gradient magnitude $|\\nabla u| = |g|$ might be zero (e.g., at critical points of $u$), we introduce the specified regularization. We replace $|g|$ with $|g|_{\\delta} = \\sqrt{|g|^2 + \\delta^2}$ for a small $\\delta > 0$. The regularized sensitivity weight is:\n$$S_i = (p-2)|g|_{\\delta}^{p-4} (g \\cdot v_i)^2 + |g|_{\\delta}^{p-2}$$\nThis expression is numerically stable and well-defined for all $g$, provided $\\delta > 0$.\n\n### Step 3: Derivation of the Anisotropic Mesh Metric Tensor\n\nThe goal is to create a mesh where the *weighted* interpolation error is constant and equal to a prescribed tolerance $\\varepsilon$ in every principal direction. The weighted error is the product of the sensitivity $S_i$ and the interpolation error $E_i$:\n$$E_i^{\\text{eff}} \\propto S_i E_i \\propto S_i |\\lambda_i| h_i^2$$\nWe enforce the equalization condition:\n$$S_i |\\lambda_i| h_i^2 = \\varepsilon \\quad \\text{for } i=1,2$$\nThis equation determines the desired local mesh spacing $h_i$ in each principal direction $v_i$:\n$$h_i^2 = \\frac{\\varepsilon}{S_i |\\lambda_i|}$$\nA metric tensor $M$ is defined by the property that for any vector $w$, the value $w^T M w$ gives the squared length of $w$ in the metric space. We want an edge of physical length $h_i$ aligned with $v_i$ to have a length of $1$ in the metric space. This implies:\n$$v_i^T M v_i = \\frac{1}{h_i^2}$$\nThis shows that the eigenvalues of the metric tensor $M$, which we denote $\\lambda_{M,i}$, are precisely $1/h_i^2$. Therefore:\n$$\\lambda_{M,i} = \\frac{S_i |\\lambda_i|}{\\varepsilon}$$\nSubstituting the expression for $S_i$:\n$$\\lambda_{M,i} = \\frac{|\\lambda_i|}{\\varepsilon} \\left( |g|_{\\delta}^{p-2} + (p-2)|g|_{\\delta}^{p-4} (g \\cdot v_i)^2 \\right)$$\nThe full metric tensor $M$ is constructed from its spectral decomposition:\n$$M = \\sum_{i=1}^2 \\lambda_{M,i} v_i v_i^T = \\lambda_{M,1} v_1 v_1^T + \\lambda_{M,2} v_2 v_2^T$$\nwhere $\\{v_1, v_2\\}$ are the orthonormal eigenvectors of the Hessian $\\nabla^2 u$. Since $M$ is constructed from real eigenvalues and orthogonal eigenvectors, it is symmetric. The eigenvalues $\\lambda_{M,i}$ are positive (since $|\\lambda_i| \\ge 0$, $\\varepsilon > 0$, and the term in parentheses is strictly positive for $\\delta>0$), so $M$ is positive definite, as required for a valid metric tensor.\n\n### Step 4: Anisotropy Ratio Calculation\n\nThe anisotropy of the mesh is a measure of how stretched the elements should be. It is defined by the ratio of the eigenvalues of the metric tensor $M$. The anisotropy ratio $\\kappa$ is:\n$$\\kappa = \\sqrt{\\frac{\\lambda_{M, \\max}}{\\lambda_{M, \\min}}}$$\nwhere $\\lambda_{M, \\max} = \\max(\\lambda_{M,1}, \\lambda_{M,2})$ and $\\lambda_{M, \\min} = \\min(\\lambda_{M,1}, \\lambda_{M,2})$. This value represents the desired aspect ratio of the local mesh elements.\n\n### Step 5: Analytic Expressions for Implementation\n\nFor the given solution $u(x,y) = \\sin(\\pi x) \\sin(\\pi y)$, we need its gradient and Hessian:\n- **Gradient** $g = \\nabla u$:\n$$g(x,y) = \\begin{pmatrix} \\pi \\cos(\\pi x) \\sin(\\pi y) \\\\ \\pi \\sin(\\pi x) \\cos(\\pi y) \\end{pmatrix}$$\n- **Hessian** $H = \\nabla^2 u$:\n$$H(x,y) = \\begin{pmatrix} -\\pi^2 \\sin(\\pi x) \\sin(\\pi y)  \\pi^2 \\cos(\\pi x) \\cos(\\pi y) \\\\ \\pi^2 \\cos(\\pi x) \\cos(\\pi y)  -\\pi^2 \\sin(\\pi x) \\sin(\\pi y) \\end{pmatrix}$$\nThese analytic forms are used to compute the required quantities ($g$, $H$, its eigenvalues $\\lambda_i$, and its eigenvectors $v_i$) at any point $(x,y)$ in the domain. The implementation will compute these values, then the metric eigenvalues $\\lambda_{M,i}$, and finally the anisotropy ratio $\\kappa$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the computation for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: Happy path with p=2 (standard Laplacian)\n        {'name': 'A', 'p': 2.0, 'eps': 1e-2, 'delta': 1e-8, 'point': (0.3, 0.4)},\n        # Case B: Nonlinear coupling with p=3\n        {'name': 'B', 'p': 3.0, 'eps': 1e-2, 'delta': 1e-8, 'point': (0.7, 0.2)},\n        # Case C: Edge case with near-zero gradient\n        {'name': 'C', 'p': 1.5, 'eps': 1e-2, 'delta': 1e-6, 'point': (0.5, 0.5)},\n        # Case D: Domain-wide statistics\n        {'name': 'D', 'p': 3.0, 'eps': 1e-2, 'delta': 1e-8, 'grid_size': 50}\n    ]\n\n    results = []\n\n    # --- Analytic function definitions ---\n    def get_gradient(x, y):\n        \"\"\"Computes the gradient of u(x,y) = sin(pi*x)sin(pi*y).\"\"\"\n        gx = np.pi * np.cos(np.pi * x) * np.sin(np.pi * y)\n        gy = np.pi * np.sin(np.pi * x) * np.cos(np.pi * y)\n        return np.array([gx, gy])\n\n    def get_hessian(x, y):\n        \"\"\"Computes the Hessian of u(x,y).\"\"\"\n        u = np.sin(np.pi * x) * np.sin(np.pi * y)\n        d2udx2 = -np.pi**2 * u\n        d2udy2 = -np.pi**2 * u\n        d2udxdy = np.pi**2 * np.cos(np.pi * x) * np.cos(np.pi * y)\n        return np.array([[d2udx2, d2udxdy], [d2udxdy, d2udy2]])\n\n    def compute_anisotropy(x, y, p, eps, delta):\n        \"\"\"\n        Computes the anisotropy ratio kappa at a given point (x,y).\n        \"\"\"\n        # 1. Compute gradient and Hessian at the point\n        g = get_gradient(x, y)\n        H = get_hessian(x, y)\n\n        # 2. Compute eigenvalues and eigenvectors of the Hessian\n        # np.linalg.eigh is suitable for symmetric matrices\n        h_eigvals, h_eigvecs = np.linalg.eigh(H)\n        abs_h_eigvals = np.abs(h_eigvals)\n\n        # 3. Compute regularized gradient magnitude\n        g_norm_sq = g[0]**2 + g[1]**2\n        g_norm_delta = np.sqrt(g_norm_sq + delta**2)\n\n        # 4. Compute metric eigenvalues\n        metric_eigvals = np.zeros(2)\n        for i in range(2):\n            v_i = h_eigvecs[:, i]\n            g_dot_vi_sq = (g[0] * v_i[0] + g[1] * v_i[1])**2\n            \n            # Sensitivity term S_i\n            # S_i = g_norm_delta**(p-2) + (p-2) * g_norm_delta**(p-4) * g_dot_vi_sq\n            # Avoid direct computation of large negative powers if g_norm_delta is small\n            if p == 2.0:\n                sensitivity = 1.0\n            else:\n                g_term1 = g_norm_delta**(p-2)\n                g_term2 = (p-2) * g_dot_vi_sq / (g_norm_delta**2)  # Corresponds to g_norm_delta**(p-4) * g_dot_vi_sq\n                sensitivity = g_term1 * (1 + g_term2)\n\n            metric_eigvals[i] = (abs_h_eigvals[i] / eps) * sensitivity\n\n        # 5. Compute anisotropy ratio kappa\n        lambda_M_max = np.max(metric_eigvals)\n        lambda_M_min = np.min(metric_eigvals)\n\n        if lambda_M_min  1e-15: # Use a tolerance for floating point comparison\n            # If one Hessian eigenvalue is zero, one metric eigenvalue is zero.\n            # This implies infinite anisotropy if the other is non-zero.\n            return np.inf if lambda_M_max > 1e-15 else 1.0\n\n        kappa = np.sqrt(lambda_M_max / lambda_M_min)\n        return kappa\n\n    # Process all cases\n    for case in test_cases:\n        if case['name'] in ['A', 'B', 'C']:\n            kappa = compute_anisotropy(case['point'][0], case['point'][1], case['p'], case['eps'], case['delta'])\n            results.append(kappa)\n        elif case['name'] == 'D':\n            p, eps, delta = case['p'], case['eps'], case['delta']\n            N = case['grid_size']\n            \n            # Create a uniform grid including boundaries\n            x_coords = np.linspace(0.0, 1.0, N)\n            y_coords = np.linspace(0.0, 1.0, N)\n            \n            kappas_grid = []\n            for x in x_coords:\n                for y in y_coords:\n                    kappa = compute_anisotropy(x, y, p, eps, delta)\n                    kappas_grid.append(kappa)\n\n            kappas_grid = np.array(kappas_grid)\n            \n            # np.mean and np.max handle np.inf correctly\n            avg_kappa = np.mean(kappas_grid[np.isfinite(kappas_grid)])\n            max_kappa = np.max(kappas_grid)\n            \n            results.append(avg_kappa)\n            results.append(max_kappa)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}