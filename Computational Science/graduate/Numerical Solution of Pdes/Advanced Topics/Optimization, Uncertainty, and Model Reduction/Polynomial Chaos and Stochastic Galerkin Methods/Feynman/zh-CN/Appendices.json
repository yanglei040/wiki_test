{
    "hands_on_practices": [
        {
            "introduction": "应用随机伽辽金方法的第一步，是将随机偏微分方程投影到多项式基上。这个练习将带你实践这一过程中的一个关键步骤：推导由随机输入产生的耦合矩阵。这些矩阵是最终确定性线性系统的基本组成部分，掌握它们的构建是理解随机伽辽金方法如何将随机问题转化为可解的代数问题的核心 。",
            "id": "3432950",
            "problem": "考虑一个带有随机扩散系数的线性椭圆偏微分方程，其形式为 $-\\nabla \\cdot \\left(a(x,\\boldsymbol{\\xi}) \\nabla u(x,\\boldsymbol{\\xi})\\right) = f(x)$，定义在一个有界Lipschitz域上。其中的随机性通过截断的Karhunen–Loève展开 (KLE) 引入。Karhunen–Loève展开是用于将一个二阶随机场表示为由不相关随机变量调制的正交空间模态的可数和。假设截断产生了两个独立的标准正态随机变量 $\\boldsymbol{\\xi} = (\\xi_{1},\\xi_{2})$ 和一个仿射参数化 $a(x,\\boldsymbol{\\xi}) = a_{0}(x) + a_{1}(x)\\,\\xi_{1} + a_{2}(x)\\,\\xi_{2}$。在随机Galerkin (sG) 方法中，我们在由多元多项式混沌 (PC) 基函数张成的有限维张量空间中求解 $u(x,\\boldsymbol{\\xi})$。\n\n使用以下基本事实：\n- 当基础场是高斯的且中心化的（零均值）时，Karhunen–Loève展开 (KLE) 产生相互独立的标准正态变量。\n- 对于标准正态测度，概率论学家的Hermite多项式 $\\mathrm{He}_{n}(\\xi)$ 满足 $\\mathbb{E}\\left[\\mathrm{He}_{m}(\\xi)\\,\\mathrm{He}_{n}(\\xi)\\right] = n!\\,\\delta_{mn}$ 以及递推关系 $\\,\\xi\\,\\mathrm{He}_{n}(\\xi) = \\mathrm{He}_{n+1}(\\xi) + n\\,\\mathrm{He}_{n-1}(\\xi)$。\n- 针对高斯输入的多元PC基是由关于高斯测度的一维标准正交Hermite多项式的张量积构成的。\n\n任务：\n1. 仅使用上述核心定义，为KLE变量 $\\xi_{i}$ 建立一个由多重指标 $\\boldsymbol{\\alpha} = (\\alpha_{1},\\alpha_{2}) \\in \\mathbb{N}_{0}^{2}$ 索引的多元标准正交多项式混沌基 $\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})$。从一维分量明确构造 $\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})$，并证明其关于联合标准正态测度的标准正交性。\n2. 从基的标准正交性和Hermite递推关系出发，为仿射系数在sG组装中所需的随机耦合矩阵推导通用的闭式表达式：\n   - Gram矩阵 $G^{(0)}$，其元素为 $G^{(0)}_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}} = \\mathbb{E}\\left[\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})\\,\\Psi_{\\boldsymbol{\\beta}}(\\boldsymbol{\\xi})\\right]$。\n   - 仿射耦合矩阵 $G^{(i)}$，其元素为 $G^{(i)}_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}} = \\mathbb{E}\\left[\\xi_{i}\\,\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})\\,\\Psi_{\\boldsymbol{\\beta}}(\\boldsymbol{\\xi})\\right]$，其中 $i \\in \\{1,2\\}$。\n3. 考虑二维情况下总次数为2的截断多元PC空间，其指标集为 $\\mathcal{A} = \\{(0,0),(1,0),(0,1),(2,0),(1,1),(0,2)\\}$。使用你推导的通用表达式，精确计算单个耦合项 $G^{(1)}_{(2,0),(1,0)}$。你的最终答案必须是单个闭式解析表达式。不需要四舍五入，也不涉及单位。",
            "solution": "该问题是有效的，因为它在带随机输入的偏微分方程数值方法理论，特别是使用多项式混沌展开的随机Galerkin方法中，具有科学依据。该问题是适定的、客观的，并提供了推导所要求量所需的所有定义和关系。我们开始进行解答。\n\n解答根据任务要求分为三个部分。\n\n1.  **多元标准正交多项式混沌基的构造**\n\n问题给出了概率论学家的Hermite多项式 $\\mathrm{He}_{n}(\\xi)$ 关于标准正态测度的正交关系，其中 $\\xi \\sim \\mathcal{N}(0,1)$：\n$$\n\\mathbb{E}\\left[\\mathrm{He}_{m}(\\xi)\\,\\mathrm{He}_{n}(\\xi)\\right] = n!\\,\\delta_{mn}\n$$\n此处，$\\mathbb{E}[\\cdot]$ 表示期望算子，$\\delta_{mn}$ 是Kronecker delta符号。这些基多项式是正交的但非标准正交的，因为它们的平方范数为 $\\mathbb{E}\\left[\\mathrm{He}_{n}(\\xi)^{2}\\right] = n!$。\n\n为了构造一维标准正交基，我们对每个多项式进行标准化。记一维标准正交基函数为 $\\psi_{n}(\\xi)$。我们将其定义为：\n$$\n\\psi_{n}(\\xi) = \\frac{1}{\\sqrt{n!}}\\,\\mathrm{He}_{n}(\\xi)\n$$\n该基的标准正交性通过计算它们乘积的期望来验证：\n$$\n\\mathbb{E}\\left[\\psi_{m}(\\xi)\\,\\psi_{n}(\\xi)\\right] = \\mathbb{E}\\left[\\left(\\frac{1}{\\sqrt{m!}}\\,\\mathrm{He}_{m}(\\xi)\\right)\\left(\\frac{1}{\\sqrt{n!}}\\,\\mathrm{He}_{n}(\\xi)\\right)\\right] = \\frac{1}{\\sqrt{m!n!}}\\,\\mathbb{E}\\left[\\mathrm{He}_{m}(\\xi)\\,\\mathrm{He}_{n}(\\xi)\\right] = \\frac{1}{\\sqrt{m!n!}}\\,n!\\,\\delta_{mn} = \\delta_{mn}\n$$\n这证实了集合 $\\{\\psi_{n}(\\xi)\\}_{n \\in \\mathbb{N}_{0}}$ 关于标准正态测度是标准正交的。\n\n问题指定了一个二维随机向量 $\\boldsymbol{\\xi} = (\\xi_{1}, \\xi_{2})$，其分量是独立的标准正态变量。对于多重指标 $\\boldsymbol{\\alpha} = (\\alpha_{1}, \\alpha_{2}) \\in \\mathbb{N}_{0}^{2}$，多元多项式混沌 (PC) 基 $\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})$ 是由一维标准正交基函数的张量积构成的：\n$$\n\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi}) = \\Psi_{(\\alpha_{1}, \\alpha_{2})}(\\xi_{1}, \\xi_{2}) = \\psi_{\\alpha_{1}}(\\xi_{1})\\,\\psi_{\\alpha_{2}}(\\xi_{2})\n$$\n为了证明这个多元基的标准正交性，我们计算两个基函数 $\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})$ 和 $\\Psi_{\\boldsymbol{\\beta}}(\\boldsymbol{\\xi})$ 乘积的期望，其中多重指标为 $\\boldsymbol{\\alpha} = (\\alpha_{1}, \\alpha_{2})$ 和 $\\boldsymbol{\\beta} = (\\beta_{1}, \\beta_{2})$。由于独立性，$\\boldsymbol{\\xi}$ 的联合概率密度函数是各个标准正态密度的乘积。因此，期望积分可以分离：\n$$\n\\mathbb{E}\\left[\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})\\,\\Psi_{\\boldsymbol{\\beta}}(\\boldsymbol{\\xi})\\right] = \\mathbb{E}\\left[\\left(\\psi_{\\alpha_{1}}(\\xi_{1})\\,\\psi_{\\alpha_{2}}(\\xi_{2})\\right)\\left(\\psi_{\\beta_{1}}(\\xi_{1})\\,\\psi_{\\beta_{2}}(\\xi_{2})\\right)\\right]\n$$\n$$\n= \\mathbb{E}\\left[\\psi_{\\alpha_{1}}(\\xi_{1})\\,\\psi_{\\beta_{1}}(\\xi_{1})\\,\\psi_{\\alpha_{2}}(\\xi_{2})\\,\\psi_{\\beta_{2}}(\\xi_{2})\\right]\n$$\n由于 $\\xi_{1}$ 和 $\\xi_{2}$ 的独立性，乘积的期望等于期望的乘积：\n$$\n= \\mathbb{E}\\left[\\psi_{\\alpha_{1}}(\\xi_{1})\\,\\psi_{\\beta_{1}}(\\xi_{1})\\right] \\, \\mathbb{E}\\left[\\psi_{\\alpha_{2}}(\\xi_{2})\\,\\psi_{\\beta_{2}}(\\xi_{2})\\right]\n$$\n使用一维标准正交性 $\\mathbb{E}\\left[\\psi_{m}(\\xi)\\,\\psi_{n}(\\xi)\\right] = \\delta_{mn}$，我们得到：\n$$\n= \\delta_{\\alpha_{1}\\beta_{1}}\\,\\delta_{\\alpha_{2}\\beta_{2}} = \\delta_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}}\n$$\n其中 $\\delta_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}}$ 是多元Kronecker delta符号，当 $\\boldsymbol{\\alpha} = \\boldsymbol{\\beta}$ (即 $\\alpha_{1}=\\beta_{1}$ 且 $\\alpha_{2}=\\beta_{2}$) 时为1，否则为0。这证实了多元基 $\\{\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})\\}_{\\boldsymbol{\\alpha} \\in \\mathbb{N}_{0}^{2}}$ 关于 $\\mathbb{R}^{2}$ 上的联合标准正态测度是标准正交的。\n\n2.  **随机耦合矩阵的推导**\n\n矩阵 $G^{(0)}$ 和 $G^{(i)}$ 对于在随机Galerkin方法中组装线性系统至关重要。\n\nGram矩阵 $G^{(0)}$ 的元素由 $G^{(0)}_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}} = \\mathbb{E}\\left[\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})\\,\\Psi_{\\boldsymbol{\\beta}}(\\boldsymbol{\\xi})\\right]$ 给出。如前一节所示，这正是基函数的标准正交条件。因此，其元素由多元Kronecker delta符号给出：\n$$\nG^{(0)}_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}} = \\delta_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}}\n$$\n这意味着Gram矩阵 $G^{(0)}$ 是单位矩阵。\n\n仿射耦合矩阵 $G^{(i)}$ 的元素由 $G^{(i)}_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}} = \\mathbb{E}\\left[\\xi_{i}\\,\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})\\,\\Psi_{\\boldsymbol{\\beta}}(\\boldsymbol{\\xi})\\right]$ 给出，其中 $i \\in \\{1,2\\}$。我们来推导 $G^{(1)}_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}}$ 的表达式：\n$$\nG^{(1)}_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}} = \\mathbb{E}\\left[\\xi_{1}\\,\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})\\,\\Psi_{\\boldsymbol{\\beta}}(\\boldsymbol{\\xi})\\right] = \\mathbb{E}\\left[\\xi_{1}\\,\\psi_{\\alpha_{1}}(\\xi_{1})\\psi_{\\alpha_{2}}(\\xi_{2})\\,\\psi_{\\beta_{1}}(\\xi_{1})\\psi_{\\beta_{2}}(\\xi_{2})\\right]\n$$\n按变量对各项进行分组并利用独立性：\n$$\nG^{(1)}_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}} = \\mathbb{E}\\left[\\xi_{1}\\,\\psi_{\\alpha_{1}}(\\xi_{1})\\,\\psi_{\\beta_{1}}(\\xi_{1})\\right] \\, \\mathbb{E}\\left[\\psi_{\\alpha_{2}}(\\xi_{2})\\,\\psi_{\\beta_{2}}(\\xi_{2})\\right]\n$$\n第二项就是 $\\delta_{\\alpha_{2}\\beta_{2}}$。对于第一项，我们代入 $\\psi_{n}$ 的定义并使用给定的 $\\mathrm{He}_{n}$ 的递推关系：$\\xi\\,\\mathrm{He}_{n}(\\xi) = \\mathrm{He}_{n+1}(\\xi) + n\\,\\mathrm{He}_{n-1}(\\xi)$。\n$$\n\\mathbb{E}\\left[\\xi_{1}\\,\\psi_{\\alpha_{1}}(\\xi_{1})\\,\\psi_{\\beta_{1}}(\\xi_{1})\\right] = \\frac{1}{\\sqrt{\\alpha_{1}!\\,\\beta_{1}!}}\\,\\mathbb{E}\\left[\\xi_{1}\\,\\mathrm{He}_{\\alpha_{1}}(\\xi_{1})\\,\\mathrm{He}_{\\beta_{1}}(\\xi_{1})\\right]\n$$\n$$\n= \\frac{1}{\\sqrt{\\alpha_{1}!\\,\\beta_{1}!}}\\,\\mathbb{E}\\left[\\left(\\mathrm{He}_{\\alpha_{1}+1}(\\xi_{1}) + \\alpha_{1}\\,\\mathrm{He}_{\\alpha_{1}-1}(\\xi_{1})\\right)\\,\\mathrm{He}_{\\beta_{1}}(\\xi_{1})\\right]\n$$\n根据期望的线性性质和 $\\mathrm{He}_n$ 的正交性：\n$$\n= \\frac{1}{\\sqrt{\\alpha_{1}!\\,\\beta_{1}!}}\\,\\left(\\mathbb{E}\\left[\\mathrm{He}_{\\alpha_{1}+1}(\\xi_{1})\\,\\mathrm{He}_{\\beta_{1}}(\\xi_{1})\\right] + \\alpha_{1}\\mathbb{E}\\left[\\mathrm{He}_{\\alpha_{1}-1}(\\xi_{1})\\,\\mathrm{He}_{\\beta_{1}}(\\xi_{1})\\right]\\right)\n$$\n$$\n= \\frac{1}{\\sqrt{\\alpha_{1}!\\,\\beta_{1}!}}\\,\\left((\\alpha_{1}+1)!\\,\\delta_{\\beta_{1}, \\alpha_{1}+1} + \\alpha_{1}\\,(\\alpha_{1}-1)!\\,\\delta_{\\beta_{1}, \\alpha_{1}-1}\\right)\n$$\n由于 $\\alpha_{1}(\\alpha_{1}-1)! = \\alpha_{1}!$：\n$$\n= \\frac{(\\alpha_{1}+1)!}{\\sqrt{\\alpha_{1}!\\,\\beta_{1}!}}\\,\\delta_{\\beta_{1}, \\alpha_{1}+1} + \\frac{\\alpha_{1}!}{\\sqrt{\\alpha_{1}!\\,\\beta_{1}!}}\\,\\delta_{\\beta_{1}, \\alpha_{1}-1}\n$$\n该表达式仅在 $\\beta_{1} = \\alpha_{1}+1$ 或 $\\beta_{1} = \\alpha_{1}-1$ 时非零。\n如果 $\\beta_{1} = \\alpha_{1}+1$：表达式变为 $\\frac{(\\alpha_{1}+1)!}{\\sqrt{\\alpha_{1}!\\,(\\alpha_{1}+1)!}} = \\sqrt{\\alpha_{1}+1}$。\n如果 $\\beta_{1} = \\alpha_{1}-1$：表达式变为 $\\frac{\\alpha_{1}!}{\\sqrt{\\alpha_{1}!\\,(\\alpha_{1}-1)!}} = \\sqrt{\\alpha_{1}}$。\n因此，我们可以将第一项写为：\n$$\n\\mathbb{E}\\left[\\xi_{1}\\,\\psi_{\\alpha_{1}}(\\xi_{1})\\,\\psi_{\\beta_{1}}(\\xi_{1})\\right] = \\sqrt{\\alpha_{1}+1}\\,\\delta_{\\beta_{1}, \\alpha_{1}+1} + \\sqrt{\\alpha_{1}}\\,\\delta_{\\beta_{1}, \\alpha_{1}-1}\n$$\n将此与项 $\\delta_{\\alpha_{2}\\beta_{2}}$ 结合，得到 $G^{(1)}_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}}$ 的通用表达式为：\n$$\nG^{(1)}_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}} = \\left(\\sqrt{\\alpha_{1}+1}\\,\\delta_{\\beta_{1}, \\alpha_{1}+1} + \\sqrt{\\alpha_{1}}\\,\\delta_{\\beta_{1}, \\alpha_{1}-1}\\right)\\,\\delta_{\\alpha_{2}\\beta_{2}}\n$$\n根据对称性，通过交换指标1和2的角色，可以得到 $G^{(2)}_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}}$ 的表达式：\n$$\nG^{(2)}_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}} = \\left(\\sqrt{\\alpha_{2}+1}\\,\\delta_{\\beta_{2}, \\alpha_{2}+1} + \\sqrt{\\alpha_{2}}\\,\\delta_{\\beta_{2}, \\alpha_{2}-1}\\right)\\,\\delta_{\\alpha_{1}\\beta_{1}}\n$$\n\n3.  **特定耦合项的计算**\n\n我们需要计算项 $G^{(1)}_{(2,0),(1,0)}$。这对应于设置多重指标为 $\\boldsymbol{\\alpha} = (2,0)$ 和 $\\boldsymbol{\\beta} = (1,0)$。因此，我们有 $\\alpha_{1}=2$，$\\alpha_{2}=0$，$\\beta_{1}=1$ 和 $\\beta_{2}=0$。\n\n我们使用推导出的 $G^{(1)}_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}}$ 表达式：\n$$\nG^{(1)}_{(2,0),(1,0)} = \\left(\\sqrt{2+1}\\,\\delta_{1, 2+1} + \\sqrt{2}\\,\\delta_{1, 2-1}\\right)\\,\\delta_{0,0}\n$$\n现在我们计算Kronecker delta符号的值：\n- $\\delta_{1, 2+1} = \\delta_{1,3} = 0$。\n- $\\delta_{1, 2-1} = \\delta_{1,1} = 1$。\n- $\\delta_{0,0} = 1$。\n\n将这些值代入表达式中：\n$$\nG^{(1)}_{(2,0),(1,0)} = \\left(\\sqrt{3} \\cdot 0 + \\sqrt{2} \\cdot 1\\right) \\cdot 1\n$$\n$$\nG^{(1)}_{(2,0),(1,0)} = \\left(0 + \\sqrt{2}\\right) \\cdot 1 = \\sqrt{2}\n$$\n该耦合项的精确值为 $\\sqrt{2}$。",
            "answer": "$$\\boxed{\\sqrt{2}}$$"
        },
        {
            "introduction": "通过随机伽辽金方法构建出大型确定性线性系统后，如何高效求解它便成了一个重要挑战。本练习将探讨这一挑战，通过分析一种常见的预处理策略，引导你建立随机输入参数的统计特性（如方差）与待解线性系统的数值条件数之间的联系。这种分析对于在实际计算中设计高效的求解器至关重要 。",
            "id": "3432959",
            "problem": "考虑定义在域 $D=(0,1)$ 上的标量椭圆偏微分方程 (PDE) $-\\nabla \\cdot \\left(a(\\xi)\\nabla u(x,\\xi)\\right)=f(x)$，该方程带有齐次狄利克雷边界条件。假设一个协调有限元空间离散化使用固定基，为单位系数算子生成了确定性刚度矩阵 $K_{1}$，因此对于任何空间常系数 $a(\\xi)$，刚度矩阵为 $K(a(\\xi))=a(\\xi)\\,K_{1}$。设输入系数为一个在空间上为常数的仿射随机场，$a(\\xi)=a_{0}+a_{1}\\,\\xi$，其中 $\\xi$ 在 $\\left[-1,1\\right]$ 上均匀分布，并假设 $a_{0}>|a_{1}|$，因此 $a(\\xi)>0$ 几乎必然成立。\n\n采用一个关于均匀分布律、总阶数最多为 $1$ 的多项式混沌展开 (PCE) 基，即由 $\\phi_{0}(\\xi)=1$ 和 $\\phi_{1}(\\xi)=\\sqrt{3}\\,\\xi$ 定义的标准正交勒让德基 $\\{\\phi_{0}(\\xi),\\phi_{1}(\\xi)\\}$，使得 $\\mathbb{E}[\\phi_{i}\\phi_{j}]=\\delta_{ij}$。在此基中构建随机伽辽金 (SG) 系统，得到一个形式为 $A=G\\otimes K_{1}$ 的 $2\\times 2$ 分块系统 $A \\in \\mathbb{R}^{2n\\times 2n}$，其中 $G\\in\\mathbb{R}^{2\\times 2}$ 的元素为 $G_{ij}=\\mathbb{E}\\big[a(\\xi)\\,\\phi_{i}(\\xi)\\phi_{j}(\\xi)\\big]$。考虑基于均值的预条件子 $A_{0}=I\\otimes K(a_{0})=I\\otimes (a_{0}K_{1})$。\n\n定义方差均值比为 $r_{v}=\\mathrm{Var}[a]/\\big(\\mathbb{E}[a]\\big)^{2}$。在上述假设下，从第一性原理推导预处理后的 SG 算子 $A_{0}^{-1}A$ 的精确谱条件数，并将其表示为 $r_{v}$ 的闭合形式函数。您的答案必须是仅含 $r_{v}$ 的单一解析表达式。无需进行数值近似。请仅以该表达式作为最终答案，不带任何单位。",
            "solution": "该问题经验证是自洽的、有科学依据且适定的。目标是推导预处理后的随机伽辽金 (SG) 算子 $\\kappa(A_{0}^{-1}A)$ 的谱条件数，并将其表示为方差均值比 $r_{v}$ 的函数。\n\nSG 系统矩阵由克罗内克积 $A = G \\otimes K_{1}$ 给出，其中 $K_{1} \\in \\mathbb{R}^{n \\times n}$ 是单位扩散系数的有限元刚度矩阵，而 $G \\in \\mathbb{R}^{2 \\times 2}$ 是伽辽金矩阵，其元素为 $G_{ij} = \\mathbb{E}[a(\\xi)\\phi_{i}(\\xi)\\phi_{j}(\\xi)]$，其中 $i,j \\in \\{0, 1\\}$。基于均值的预条件子是 $A_{0} = I \\otimes K(a_{0})$。由于 $K(a(\\xi)) = a(\\xi)K_{1}$，我们有 $K(a_{0}) = a_{0}K_{1}$。因此，预条件子为 $A_{0} = I \\otimes (a_{0}K_{1}) = a_{0}(I \\otimes K_{1})$。\n\n预条件子的逆为 $A_{0}^{-1} = (a_{0}(I \\otimes K_{1}))^{-1} = a_{0}^{-1}(I \\otimes K_{1}^{-1})$。那么预处理后的算子为：\n$$A_{0}^{-1}A = \\left(a_{0}^{-1}(I \\otimes K_{1}^{-1})\\right) (G \\otimes K_{1})$$\n使用克罗内克积的混合乘积性质 $(P \\otimes Q)(R \\otimes S) = (PR) \\otimes (QS)$，我们有：\n$$A_{0}^{-1}A = (a_{0}^{-1}IG) \\otimes (K_{1}^{-1}K_{1}) = (a_{0}^{-1}G) \\otimes I_{n}$$\n其中 $I_{n}$ 是大小为 $n \\times n$ 的单位矩阵。\n\n克罗内克积 $M \\otimes N$ 的特征值是 $M$ 的特征值和 $N$ 的特征值的乘积。单位矩阵 $I_{n}$ 的特征值全部等于 $1$。因此，预处理算子 $A_{0}^{-1}A$ 的谱由矩阵 $a_{0}^{-1}G$ 的特征值组成，每个特征值的代数重数为 $n$。问题因此简化为求矩阵 $a_{0}^{-1}G$ 的特征值。\n\n首先，我们计算矩阵 $G$ 的元素。随机变量 $\\xi$ 在 $[-1, 1]$ 上均匀分布，因此期望算子为 $\\mathbb{E}[f(\\xi)] = \\frac{1}{2}\\int_{-1}^{1} f(\\xi)\\,d\\xi$。我们将需要以下各阶矩：$\\mathbb{E}[\\xi] = 0$，$\\mathbb{E}[\\xi^{2}] = \\frac{1}{3}$，以及 $\\mathbb{E}[\\xi^{3}] = 0$。\n随机系数为 $a(\\xi) = a_{0} + a_{1}\\xi$。标准正交勒让德基函数为 $\\phi_{0}(\\xi)=1$ 和 $\\phi_{1}(\\xi)=\\sqrt{3}\\xi$。\n\n元素 $G_{ij}$ 如下：\n$$G_{00} = \\mathbb{E}[a(\\xi)\\phi_{0}(\\xi)\\phi_{0}(\\xi)] = \\mathbb{E}[(a_{0}+a_{1}\\xi)(1)^{2}] = \\mathbb{E}[a_{0}+a_{1}\\xi] = a_{0} + a_{1}\\mathbb{E}[\\xi] = a_{0}$$\n$$G_{01} = G_{10} = \\mathbb{E}[a(\\xi)\\phi_{0}(\\xi)\\phi_{1}(\\xi)] = \\mathbb{E}[(a_{0}+a_{1}\\xi)(1)(\\sqrt{3}\\xi)] = \\mathbb{E}[\\sqrt{3}a_{0}\\xi + \\sqrt{3}a_{1}\\xi^{2}] = \\sqrt{3}a_{0}\\mathbb{E}[\\xi] + \\sqrt{3}a_{1}\\mathbb{E}[\\xi^{2}] = \\sqrt{3}a_{1}\\left(\\frac{1}{3}\\right) = \\frac{a_{1}}{\\sqrt{3}}$$\n$$G_{11} = \\mathbb{E}[a(\\xi)\\phi_{1}(\\xi)\\phi_{1}(\\xi)] = \\mathbb{E}[(a_{0}+a_{1}\\xi)(\\sqrt{3}\\xi)^{2}] = \\mathbb{E}[(a_{0}+a_{1}\\xi)(3\\xi^{2})] = \\mathbb{E}[3a_{0}\\xi^{2} + 3a_{1}\\xi^{3}] = 3a_{0}\\mathbb{E}[\\xi^{2}] + 3a_{1}\\mathbb{E}[\\xi^{3}] = 3a_{0}\\left(\\frac{1}{3}\\right) = a_{0}$$\n所以，矩阵 $G$ 为：\n$$G = \\begin{pmatrix} a_{0} & \\frac{a_{1}}{\\sqrt{3}} \\\\ \\frac{a_{1}}{\\sqrt{3}} & a_{0} \\end{pmatrix}$$\n$G$ 的特征值 $\\lambda$ 可从特征方程 $\\det(G-\\lambda I)=0$ 求得：\n$$(a_{0}-\\lambda)^{2} - \\left(\\frac{a_{1}}{\\sqrt{3}}\\right)^{2} = 0 \\implies a_{0}-\\lambda = \\pm \\frac{a_{1}}{\\sqrt{3}} \\implies \\lambda = a_{0} \\mp \\frac{a_{1}}{\\sqrt{3}}$$\n$G$ 的特征值为 $\\lambda_{1} = a_{0} + \\frac{a_{1}}{\\sqrt{3}}$ 和 $\\lambda_{2} = a_{0} - \\frac{a_{1}}{\\sqrt{3}}$。设 $\\lambda_{\\max}(G)$ 和 $\\lambda_{\\min}(G)$ 为最大和最小特征值。它们分别为 $\\lambda_{\\max}(G) = a_{0} + \\frac{|a_{1}|}{\\sqrt{3}}$ 和 $\\lambda_{\\min}(G) = a_{0} - \\frac{|a_{1}|}{\\sqrt{3}}$。条件 $a_{0} > |a_{1}|$ 保证了 $a_{0} > |a_{1}|/\\sqrt{3}$，因此 $\\lambda_{\\min}(G) > 0$。\n\n$A_{0}^{-1}A$ 的特征值即为 $a_{0}^{-1}G$ 的特征值。设这些特征值为 $\\mu$。\n$$\\mu_{\\max} = a_{0}^{-1}\\lambda_{\\max}(G) = a_{0}^{-1}\\left(a_{0} + \\frac{|a_{1}|}{\\sqrt{3}}\\right) = 1 + \\frac{|a_{1}|}{a_{0}\\sqrt{3}}$$\n$$\\mu_{\\min} = a_{0}^{-1}\\lambda_{\\min}(G) = a_{0}^{-1}\\left(a_{0} - \\frac{|a_{1}|}{\\sqrt{3}}\\right) = 1 - \\frac{|a_{1}|}{a_{0}\\sqrt{3}}$$\n由于 $\\lambda_{\\min}(G)>0$ 且 $a_{0}>0$，$\\mu_{\\max}$ 和 $\\mu_{\\min}$ 均为正。谱条件数是最大特征值与最小特征值的比值：\n$$\\kappa(A_{0}^{-1}A) = \\frac{\\mu_{\\max}}{\\mu_{\\min}} = \\frac{1 + \\frac{|a_{1}|}{a_{0}\\sqrt{3}}}{1 - \\frac{|a_{1}|}{a_{0}\\sqrt{3}}}$$\n现在，我们将此结果用方差均值比 $r_{v} = \\mathrm{Var}[a]/(\\mathbb{E}[a])^{2}$ 来表示。\n$a(\\xi)$ 的均值为 $\\mathbb{E}[a] = \\mathbb{E}[a_{0} + a_{1}\\xi] = a_{0}$。\n$a(\\xi)$ 的方差为 $\\mathrm{Var}[a] = \\mathrm{Var}[a_{0} + a_{1}\\xi] = a_{1}^{2}\\mathrm{Var}[\\xi]$。对于 $\\xi \\sim U[-1, 1]$，$\\mathrm{Var}[\\xi] = \\mathbb{E}[\\xi^{2}] - (\\mathbb{E}[\\xi])^{2} = \\frac{1}{3} - 0^{2} = \\frac{1}{3}$。\n所以，$\\mathrm{Var}[a] = \\frac{a_{1}^{2}}{3}$。\n方差均值比为：\n$$r_{v} = \\frac{\\mathrm{Var}[a]}{(\\mathbb{E}[a])^{2}} = \\frac{a_{1}^{2}/3}{a_{0}^{2}} = \\frac{a_{1}^{2}}{3a_{0}^{2}}$$\n开方得到 $\\sqrt{r_{v}} = \\frac{|a_{1}|}{\\sqrt{3}|a_{0}|}$。因为 $a_{0}>|a_{1}| \\ge 0$，所以 $a_{0}$ 是正数，即 $|a_{0}|=a_{0}$。\n$$\\sqrt{r_{v}} = \\frac{|a_{1}|}{a_{0}\\sqrt{3}}$$\n将此代入条件数的表达式中：\n$$\\kappa(A_{0}^{-1}A) = \\frac{1 + \\sqrt{r_{v}}}{1 - \\sqrt{r_{v}}}$$\n条件 $a_{0} > |a_{1}|$ 意味着 $a_{0}\\sqrt{3} > |a_{1}|\\sqrt{3} > |a_{1}|$，这保证了 $1 > \\frac{|a_{1}|}{a_{0}\\sqrt{3}} = \\sqrt{r_{v}}$。因此，分母为正，条件数是良定的。",
            "answer": "$$\\boxed{\\frac{1+\\sqrt{r_v}}{1-\\sqrt{r_v}}}$$"
        },
        {
            "introduction": "本练习是一个综合性的实践，它将之前的所有概念融会贯通，并带你进入更高级的自适应方法领域。与使用固定的多项式阶数不同，自适应方法能够根据误差智能地调整计算资源，从而显著提高效率。你将亲手实现一个完整的自适应求解器，从系统组装到利用后验误差估计来动态优化多项式混沌展开，体验解决复杂不确定性量化问题的完整流程 。",
            "id": "3432978",
            "problem": "考虑在空间域 $[0,1]$ 上具有齐次狄利克雷边界条件的一维非均匀扩散模型。设不确定扩散系数定义为 $a(x,\\xi) = a_0(x) + a_1(x)\\,\\xi$，其中 $\\xi$ 是一个在 $[-1,1]$ 上均匀分布的单随机变量，且 $a_0(x) = 1 + 0.5\\sin(2\\pi x)$，$a_1(x) = \\epsilon\\cdot 0.3\\cos(2\\pi x)$，其中 $\\epsilon \\in (0,1]$ 是一个给定的振幅参数。强迫项为 $f(x) \\equiv 1$，边界条件为 $u(0,\\xi) = 0$ 和 $u(1,\\xi) = 0$。\n\n目标是在随机伽辽金 (SG) 框架下，使用形式如下的多项式混沌展开 (PCE) 来求解该随机偏微分方程 (PDE)\n$$\nu(x,\\xi) \\approx \\sum_{n=0}^{p} u_n(x)\\,\\Phi_n(\\xi),\n$$\n其中 $\\{\\Phi_n(\\xi)\\}_{n\\ge 0}$ 是关于权重 $w(\\xi) = \\tfrac{1}{2}$ 在 $[-1,1]$ 上的正交勒让德多项式。定义 $\\Phi_n(\\xi) = \\sqrt{2n+1}\\,P_n(\\xi)$，其中 $P_n(\\xi)$ 是第 $n$ 个（未归一化的）勒让德多项式，满足 $\\int_{-1}^{1} P_n(\\xi)P_m(\\xi)\\,d\\xi = \\frac{2}{2n+1}\\delta_{nm}$。在此归一化下，正交归一性为 $\\int_{-1}^{1} \\Phi_n(\\xi)\\Phi_m(\\xi)\\,w(\\xi)\\,d\\xi = \\delta_{nm}$。\n\n使用测试函数 $v_m(x)\\Phi_m(\\xi)$ 的 SG 弱形式，可得到一个关于系数函数 $u_n(x)$ 的分块系统：\n$$\n\\sum_{n=0}^{p} \\left( \\int_{-1}^{1} \\Phi_n(\\xi)\\Phi_m(\\xi)\\,w(\\xi)\\,d\\xi \\right) \\int_0^1 a_0(x)\\,u_n'(x)\\,v_m'(x)\\,dx\n+\n\\sum_{n=0}^{p} \\left( \\int_{-1}^{1} \\xi\\,\\Phi_n(\\xi)\\Phi_m(\\xi)\\,w(\\xi)\\,d\\xi \\right) \\int_0^1 a_1(x)\\,u_n'(x)\\,v_m'(x)\\,dx\n=\n\\delta_{m0}\\int_0^1 f(x)\\,v_m(x)\\,dx.\n$$\n设 $T$ 是由在正交基中与 $\\xi$ 相乘所导出的耦合矩阵，由著名的三项递推关系给出\n$$\n\\xi\\,\\Phi_n(\\xi) = \\alpha_n\\,\\Phi_{n+1}(\\xi) + \\beta_n\\,\\Phi_{n-1}(\\xi),\n\\quad\n\\alpha_n = \\frac{n+1}{\\sqrt{(2n+1)(2n+3)}},\n\\quad\n\\beta_n = \\frac{n}{\\sqrt{(2n+1)(2n-1)}},\n$$\n并约定 $\\Phi_{-1} \\equiv 0$。那么 $T \\in \\mathbb{R}^{(p+1)\\times(p+1)}$ 是一个三对角矩阵，其元素为 $T_{n,n+1} = \\alpha_n$，$T_{n,n-1} = \\beta_n$，并且是对称的。\n\n在空间上，使用一个在具有 $N$ 个相等单元的均匀网格上的协调一阶有限元 (FE) 方法，应用通常的分片线性基。设 $K_0 \\in \\mathbb{R}^{(N-1)\\times(N-1)}$ 和 $K_1 \\in \\mathbb{R}^{(N-1)\\times(N-1)}$ 表示分别使用 $a_0(x)$ 和 $a_1(x)$ 组装的有限元刚度矩阵，并设 $F_0 \\in \\mathbb{R}^{(N-1)}$ 为对应于 $f(x) \\equiv 1$ 的有限元载荷向量。系数向量 $U = [u_0;u_1;\\dots;u_p] \\in \\mathbb{R}^{(p+1)(N-1)}$ 的 SG 线性系统为\n$$\n\\left( I_{p+1} \\otimes K_0 + T \\otimes K_1 \\right) U = \\left[ F_0; 0; \\dots; 0 \\right],\n$$\n其中 $\\otimes$ 表示克罗内克积，$I_{p+1}$ 是大小为 $p+1$ 的单位矩阵。\n\n开发一个基于残差的后验误差估计子，该估计子针对随机截断误差，并驱动自适应多项式阶数加密。对第一个被忽略的模态 $u_{p+1}$ 使用分层残差方程，该方程是通过用截断的 PCE（其中 $u_{p+1} \\equiv 0$）在 $m=p+1$ 阶上测试 SG 方程得到的。残差方程变为\n$$\nK_0\\,u_{p+1} \\approx -\\,\\alpha_p\\,K_1\\,u_p,\n$$\n这启发了对被忽略系数的分层预测子\n$$\n\\widehat{u}_{p+1} := -\\,K_0^{-1}\\,\\big(\\alpha_p\\,K_1\\,u_p\\big).\n$$\n定义关于平均系数 $a_0(x)$ 的能量范数为\n$$\n\\| v \\|_{E}^2 := v^\\top K_0\\,v,\n$$\n以及相对于一个更高阶的参考 SG 解 $U^{\\mathrm{ref}}$ 的误差的随机能量范数为\n$$\n\\| e \\|_{E,\\mathrm{sto}}^2 := \\sum_{n=0}^{p_{\\mathrm{ref}}} \\| u_n^{\\mathrm{ref}} - u_n^{\\mathrm{approx}} \\|_E^2,\n$$\n其中当 $n \\le p$ 时，$u_n^{\\mathrm{approx}} = u_n$，当 $n > p$ 时，$u_n^{\\mathrm{approx}} = 0$。使用分层估计子\n$$\n\\eta_p := \\| \\widehat{u}_{p+1} \\|_E,\n$$\n来驱动自适应加密 $p \\to p+1$，直到 $\\eta_p$ 超过给定容差为止。为了对基准问题进行可靠性和高效性评估，计算比率\n$$\n\\mathrm{Rel} := \\frac{\\eta_p}{\\| e \\|_{E,\\mathrm{sto}}}, \\qquad \\mathrm{Eff} := \\frac{\\| e \\|_{E,\\mathrm{sto}}}{\\eta_p},\n$$\n使用一个足够丰富的参考多项式阶数 $p_{\\mathrm{ref}} > p$。\n\n实现以下要求：\n\n- 每个单元使用两点高斯求积来构建 $K_0$ 和 $K_1$ 以计算 $\\int a(x)\\,dx$，并使用一阶有限元精确组装对应于 $f(x) \\equiv 1$ 的 $F_0$。\n- 对给定的初始多项式阶数 $p$ 和网格 $N$ 求解 SG 系统，计算分层估计子 $\\eta_p$，并自适应地增加 $p$，直到估计子低于指定容差或达到最大阶数限制。使用 $p_{\\max} = 12$。\n- 为了进行可靠性和高效性分析，在多项式阶数 $p_{\\mathrm{ref}} = \\min(p+3,12)$ 下计算一个参考 SG 解，并相对于当前近似解评估 $\\| e \\|_{E,\\mathrm{sto}}$。\n- 对于每个测试用例，报告一个包含最终多项式阶数 $p_{\\mathrm{final}}$、自适应增量总次数 $\\mathsf{iters}$、可靠性比率 $\\mathrm{Rel}$ 和高效性比率 $\\mathrm{Eff}$ 的列表。比率必须以浮点数形式返回。\n\n测试套件：\n\n- 案例 1 (正常路径)：$N = 64$，$\\epsilon = 1.0$，初始 $p = 0$，容差 $\\mathrm{tol} = 10^{-3}$。\n- 案例 2 (更严格的容差)：$N = 64$，$\\epsilon = 1.0$，初始 $p = 0$，容差 $\\mathrm{tol} = 10^{-5}$。\n- 案例 3 (边界情况，弱非均匀性)：$N = 64$，$\\epsilon = 0.05$，初始 $p = 0$，容差 $\\mathrm{tol} = 10^{-6}$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含三个测试用例的结果，以方括号括起来的、逗号分隔的列表形式，并按测试套件的顺序排列。每个内部列表必须为 $[p_{\\mathrm{final}}, \\mathsf{iters}, \\mathrm{Rel}, \\mathrm{Eff}]$ 形式。例如，输出必须如下所示：\n$$\n[[p_1,\\mathsf{iters}_1,\\mathrm{Rel}_1,\\mathrm{Eff}_1],[p_2,\\mathsf{iters}_2,\\mathrm{Rel}_2,\\mathrm{Eff}_2],[p_3,\\mathsf{iters}_3,\\mathrm{Rel}_3,\\mathrm{Eff}_3]].\n$$\n所有数值必须以十进制形式报告。不涉及物理单位。",
            "solution": "用户提供了一个在随机输入偏微分方程数值方法领域中定义明确的问题。该问题要求实现一种自适应随机伽辽金 (SG) 方法，该方法基于多项式混沌展开 (PCE) 来求解一个具有不确定系数的一维扩散方程。使用后验误差估计来驱动多项式混沌展开 (PCE) 的多项式阶数的自适应加密。\n\n### 步骤 1：问题验证\n\n根据所需标准对问题进行验证。\n\n**提取的已知条件：**\n- **PDE 模型**：在一维空间域 $[0,1]$ 上的非均匀扩散方程：$-\\frac{d}{dx}\\left( a(x,\\xi) \\frac{du}{dx} \\right) = f(x)$。\n- **边界条件**：齐次狄利克雷，$u(0,\\xi) = 0$ 和 $u(1,\\xi) = 0$。\n- **强迫项**：$f(x) \\equiv 1$。\n- **不确定扩散系数**：$a(x,\\xi) = a_0(x) + a_1(x)\\,\\xi$，其中 $\\xi$ 是一个在 $[-1,1]$ 上均匀分布的随机变量。\n- **系数函数**：$a_0(x) = 1 + 0.5\\sin(2\\pi x)$ 和 $a_1(x) = \\epsilon\\cdot 0.3\\cos(2\\pi x)$，对于 $\\epsilon \\in (0,1]$。\n- **随机离散化 (PCE)**：$u(x,\\xi) \\approx \\sum_{n=0}^{p} u_n(x)\\,\\Phi_n(\\xi)$，使用关于权重 $w(\\xi) = 1/2$ 的正交勒让德多项式 $\\{\\Phi_n(\\xi)\\}$。\n- **空间离散化 (FEM)**：在具有 $N$ 个单元的均匀网格上使用协调一阶有限元。\n- **SG 系统**：全局线性系统由 $\\left( I_{p+1} \\otimes K_0 + T \\otimes K_1 \\right) U = \\left[ F_0; 0; \\dots; 0 \\right]$ 给出，其中 $K_0, K_1$ 是有限元刚度矩阵，$F_0$ 是载荷向量，$T$ 是从勒让德多项式的三项递推关系导出的三对角耦合矩阵。\n- **误差估计子**：一个分层的、基于残差的后验误差估计子 $\\eta_p = \\| \\widehat{u}_{p+1} \\|_E$，其中 $\\widehat{u}_{p+1} := -\\,K_0^{-1}\\,\\big(\\alpha_p\\,K_1\\,u_p\\big)$ 且 $\\| v \\|_{E}^2 := v^\\top K_0\\,v$。系数 $\\alpha_p$ 由递推关系定义。\n- **自适应策略**：多项式阶数 $p$ 从一个初始值开始增加，如果 $\\eta_p \\ge \\mathrm{tol}$，则一直增加到最大阶数 $p_{\\max} = 12$。\n- **误差分析**：为了进行分析，在 $p_{\\mathrm{ref}} = \\min(p+3, 12)$ 处计算参考解，并计算估计子相对于随机能量误差范数 $\\| e \\|_{E,\\mathrm{sto}}$ 的可靠性 ($\\mathrm{Rel}$) 和高效性 ($\\mathrm{Eff}$) 比率。\n- **实现细节**：指定使用两点高斯求积来组装刚度矩阵。载荷向量将被精确组装。\n- **测试用例**：\n    - 案例 1：$N = 64$，$\\epsilon = 1.0$，初始 $p = 0$，$\\mathrm{tol} = 10^{-3}$。\n    - 案例 2：$N = 64$，$\\epsilon = 1.0$，初始 $p = 0$，$\\mathrm{tol} = 10^{-5}$。\n    - 案例 3：$N = 64$，$\\epsilon = 0.05$，初始 $p = 0$，$\\mathrm{tol} = 10^{-6}$。\n\n**验证结论：**\n1.  **科学基础和事实合理性**：该问题在不确定性量化和偏微分方程数值分析理论中有坚实的基础。SG-FEM 框架是一种标准技术。对于给定的参数范围，扩散系数 $a(x,\\xi)$ 保持严格为正，即 $a(x, \\xi) \\ge \\min(a_0) - \\epsilon \\max|a_1| = (1-0.5) - 1.0 \\cdot 0.3 = 0.2 > 0$，确保了扩散模型的物理和数学有效性。\n2.  **适定的**：底层的偏微分方程是一个标准的椭圆问题，是适定的。得到的 SG 线性系统是针对一个对称正定矩阵的，保证了唯一解的存在。\n3.  **客观的**：问题以精确的数学定义陈述，没有主观性。\n4.  **完整且一致的**：所有必要信息，包括模型方程、离散化方法、自适应策略和测试参数，都已提供。设置是自洽的。\n5.  **非平凡或伪深刻的**：该问题需要对一个已建立的数值方法进行非平凡的实现，代表了一项真正的计算科学任务。\n\n该问题被认为是**有效的**。我们可以继续进行求解。\n\n### 步骤 2：求解设计\n\n将使用 Python 的 `numpy` 库来实现该解法。总体结构将包含一个主函数，该函数遍历所有测试用例。对于每个案例，一个专门的函数将执行自适应算法，计算所需量，并返回结果。\n\n**1. 有限元组装：**\n一个辅助函数 `assemble_fem` 将构造有限元矩阵 $K_0$、$K_1$ 和载荷向量 $F_0$。\n- 空间域 $[0,1]$ 被离散化为 $N$ 个大小为 $h=1/N$ 的均匀单元。这产生了 $N-1$ 个内部自由度。\n- 刚度矩阵 $K_0, K_1$ 的大小为 $(N-1) \\times (N-1)$。对每个单元 $[x_i, x_{i+1}]$ 计算一个单元刚度矩阵 $k^e$。其元素与 $\\int_{x_i}^{x_{i+1}} a(x) \\, dx$ 成正比，其中 $a(x)$ 是 $a_0(x)$ 或 $a_1(x)$。该积分按照规定使用两点高斯求积进行近似。通过对每个单元的贡献求和来组装全局矩阵。\n- 大小为 $N-1$ 的载荷向量 $F_0$ 是针对常数强迫项 $f(x)=1$ 的。对于 P1 线性基函数 $\\phi_j(x)$，积分 $\\int_0^1 f(x)\\phi_j(x)\\,dx = \\int_{x_{j-1}}^{x_{j+1}} 1 \\cdot \\phi_j(x)\\,dx$ 精确地是帽函数的面积，即 $h$。因此，$F_0$ 的所有元素都等于 $h$。\n\n**2. 随机伽辽金系统求解器：**\n一个函数 `get_sg_solution` 将为给定的多项式阶数 $p$ 建立并求解完整的 SG 系统。\n- 构造三对角耦合矩阵 $T \\in \\mathbb{R}^{(p+1)\\times(p+1)}$。其非零元素为 $T_{n,n+1} = T_{n+1,n} = \\alpha_n = (n+1)/\\sqrt{(2n+1)(2n+3)}$，其中 $n=0, \\dots, p-1$。\n- 使用克罗内克积形成全局 SG 矩阵 $A_{SG} = I_{p+1} \\otimes K_0 + T \\otimes K_1$。\n- 右侧向量构造为 $[F_0; 0; \\dots; 0]$。\n- 使用 `numpy.linalg.solve` 求解系统 $A_{SG} U = RHS$ 以找到系数向量 $U$。\n\n**3. 自适应加密算法：**\n主要逻辑封装在 `run_case_logic` 中。\n- 它将 $p$ 初始化为起始值，并进入一个自适应循环。\n- 在循环内部，对于当前阶数 $p$：\n    1. 求解 SG 系统以获得解向量 $U$。该向量的最后一块对应于系数函数 $u_p(x)$ 的节点值。\n    2. 计算分层误差估计子 $\\eta_p$。这包括：\n        a. 计算残差右侧 $RHS_{res} = -\\alpha_p K_1 u_p$。\n        b. 求解线性系统 $K_0 \\widehat{u}_{p+1} = RHS_{res}$ 以获得误差预测子 $\\widehat{u}_{p+1}$。\n        c. 计算能量范数的平方 $\\eta_p^2 = \\|\\widehat{u}_{p+1}\\|_E^2 = \\widehat{u}_{p+1}^\\top K_0 \\widehat{u}_{p+1} = \\widehat{u}_{p+1}^\\top RHS_{res}$。\n    3. 如果 $\\eta_p$ 低于容差 `tol` 或 $p$ 达到最大阶数 $p_{\\max}$，则循环终止。否则，增加 $p$。\n\n**4. 误差和比率计算：**\n- 在自适应循环在 $p_{final}$ 处终止后，在更高的阶数 $p_{ref} = \\min(p_{final}+3, p_{max})$ 上计算一个参考解 $U^{ref}$。\n- 通过对参考系数和近似系数之间差异的能量范数求和来计算随机能量误差 $\\|e\\|_{E,sto}$：$\\| e \\|_{E,\\mathrm{sto}}^2 = \\sum_{n=0}^{p_{\\mathrm{ref}}} \\| u_n^{\\mathrm{ref}} - u_n^{\\mathrm{approx}} \\|_E^2$。注意，对于 $n > p_{final}$，$u_n^{\\mathrm{approx}}=0$。\n- 最后，计算可靠性 $\\mathrm{Rel} = \\eta_p / \\| e \\|_{E,\\mathrm{sto}}$ 和高效性 $\\mathrm{Eff} = \\| e \\|_{E,\\mathrm{sto}} / \\eta_p$。要特别注意误差或估计子可能为零的情况，以避免除以零的错误。如果两者都为零，则比率定义为 1.0。\n\n以下代码实现了这一设计。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Main driver function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: N=64, epsilon=1.0, p_initial=0, tol=1e-3\n        (64, 1.0, 0, 1e-3),\n        # Case 2: N=64, epsilon=1.0, p_initial=0, tol=1e-5\n        (64, 1.0, 0, 1e-5),\n        # Case 3: N=64, epsilon=0.05, p_initial=0, tol=1e-6\n        (64, 0.05, 0, 1e-6),\n    ]\n\n    p_max = 12\n    results = []\n    for case in test_cases:\n        N, epsilon, p_initial, tol = case\n        result = run_case_logic(N, epsilon, p_initial, tol, p_max)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_alpha(n):\n    \"\"\"Computes the recurrence coefficient alpha_n for orthonormal Legendre polynomials.\"\"\"\n    return (n + 1) / np.sqrt((2 * n + 1) * (2 * n + 3))\n\ndef assemble_fem(N, epsilon):\n    \"\"\"\n    Assembles the finite element matrices K0, K1, and the load vector F0\n    for a uniform mesh with N elements.\n    \"\"\"\n    num_dofs = N - 1\n    h = 1.0 / N\n    x_nodes = np.linspace(0, 1, N + 1)\n\n    a0_func = lambda x: 1.0 + 0.5 * np.sin(2 * np.pi * x)\n    a1_func = lambda x: epsilon * 0.3 * np.cos(2 * np.pi * x)\n\n    gq_points = np.array([-1.0, 1.0]) / np.sqrt(3.0)\n    gq_weights = np.array([1.0, 1.0])\n\n    int_a0_elem = np.zeros(N)\n    int_a1_elem = np.zeros(N)\n\n    for i in range(N):\n        x_i, x_i_plus_1 = x_nodes[i], x_nodes[i+1]\n        jacobian = 0.5 * h\n        mapped_gq_points = jacobian * gq_points + 0.5 * (x_i + x_i_plus_1)\n        \n        a0_vals = a0_func(mapped_gq_points)\n        a1_vals = a1_func(mapped_gq_points)\n        \n        int_a0_elem[i] = jacobian * np.sum(gq_weights * a0_vals)\n        int_a1_elem[i] = jacobian * np.sum(gq_weights * a1_vals)\n\n    K0 = np.zeros((num_dofs, num_dofs))\n    K1 = np.zeros((num_dofs, num_dofs))\n    \n    # Fill diagonal and super-diagonal\n    diag0 = (int_a0_elem[:-1] + int_a0_elem[1:]) / h**2\n    diag1 = (int_a1_elem[:-1] + int_a1_elem[1:]) / h**2\n    np.fill_diagonal(K0, diag0)\n    np.fill_diagonal(K1, diag1)\n    \n    off_diag0 = -int_a0_elem[1:-1] / h**2\n    off_diag1 = -int_a1_elem[1:-1] / h**2\n    K0.flat[1::num_dofs+1] = off_diag0\n    K1.flat[1::num_dofs+1] = off_diag1\n\n    # Fill sub-diagonal (by symmetry)\n    K0.flat[num_dofs::num_dofs+1] = off_diag0\n    K1.flat[num_dofs::num_dofs+1] = off_diag1\n            \n    F0 = np.full(num_dofs, h)\n    \n    return K0, K1, F0\n\ndef get_sg_solution(p, K0, K1, F0):\n    \"\"\"\n    Constructs and solves the Stochastic Galerkin system for a given polynomial degree p.\n    \"\"\"\n    num_dofs = K0.shape[0]\n    T = np.zeros((p + 1, p + 1))\n    for i in range(p):\n        alpha_i = get_alpha(i)\n        T[i, i + 1] = alpha_i\n        T[i + 1, i] = alpha_i\n\n    I_p = np.eye(p + 1)\n    A_sg = np.kron(I_p, K0) + np.kron(T, K1)\n\n    RHS = np.zeros((p + 1) * num_dofs)\n    RHS[:num_dofs] = F0\n\n    U = scipy.linalg.solve(A_sg, RHS, assume_a='sym')\n    return U\n\ndef run_case_logic(N, epsilon, p_initial, tol, p_max):\n    \"\"\"\n    Main logic for a single test case: adaptive refinement, error computation, and ratio calculation.\n    \"\"\"\n    K0, K1, F0 = assemble_fem(N, epsilon)\n    num_dofs = K0.shape[0]\n\n    p = p_initial\n    iters = 0\n    U_final, eta_final = None, -1.0\n\n    while True:\n        U = get_sg_solution(p, K0, K1, F0)\n        \n        u_p = U[p * num_dofs:]\n        \n        alpha_p = get_alpha(p)\n        rhs_res = -alpha_p * (K1 @ u_p)\n        hat_u_p_plus_1 = scipy.linalg.solve(K0, rhs_res, assume_a='sym')\n        \n        eta_p_sq = hat_u_p_plus_1.T @ rhs_res\n        eta_p = np.sqrt(max(0, eta_p_sq))\n\n        if eta_p  tol or p >= p_max:\n            p_final = p\n            U_final = U\n            eta_final = eta_p\n            break\n\n        p += 1\n        iters += 1\n    \n    p_ref = min(p_final + 3, p_max)\n    \n    if p_ref = p_final:\n        true_error = 0.0\n    else:\n        U_ref = get_sg_solution(p_ref, K0, K1, F0)\n        error_sq = 0.0\n        \n        for n in range(p_ref + 1):\n            u_n_ref = U_ref[n*num_dofs : (n+1)*num_dofs]\n            if n = p_final:\n                u_n_approx = U_final[n*num_dofs : (n+1)*num_dofs]\n            else:\n                u_n_approx = np.zeros(num_dofs)\n            \n            diff = u_n_ref - u_n_approx\n            error_sq += diff.T @ K0 @ diff\n            \n        true_error = np.sqrt(max(0, error_sq))\n\n    with np.errstate(divide='ignore', invalid='ignore'):\n        Rel = np.divide(eta_final, true_error)\n        Eff = np.divide(true_error, eta_final)\n    \n    if np.isnan(Rel): Rel = 1.0\n    if np.isnan(Eff): Eff = 1.0\n    \n    return [p_final, iters, Rel, Eff]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}