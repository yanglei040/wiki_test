{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，通过一个具体的计算练习来巩固理解是至关重要的。这个练习将引导您在一维椭圆问题的背景下，从第一性原理出发，手动计算对偶加权残差（DWR）误差估计量的核心组成部分——单元内部残差和单元间跳跃残差。通过这个过程，您将直观地看到原始解的误差（例如，导数在单元边界上的不连续性）是如何通过对偶解的加权，最终量化为目标泛函的误差贡献的 。",
            "id": "3400751",
            "problem": "考虑一维空间中的二阶椭圆模型问题。设域为 $\\Omega=(0,1)$，考虑如下原始边值问题\n$$-u'' = f \\quad \\text{in } \\Omega,\\qquad u(0)=0,\\quad u(1)=0,$$\n其中载荷 $f(x)=1$。令 $V:=H^{1}_{0}(\\Omega)$，并设 $V_{h}\\subset V$ 是与均匀剖分 $\\mathcal{T}_{h}=\\{[0,\\tfrac{1}{3}],[\\tfrac{1}{3},\\tfrac{2}{3}],[\\tfrac{2}{3},1]\\}$ 相关联的协调分片线性有限元空间，其节点位于 $x_{0}=0$, $x_{1}=\\tfrac{1}{3}$, $x_{2}=\\tfrac{2}{3}$, $x_{3}=1$。用 $\\mathcal{E}_{h}$ 表示内部面（在一维情况下为内部节点）的集合 $\\{\\tfrac{1}{3},\\tfrac{2}{3}\\}$。设 $u_{h}\\in V_{h}$ 是原始问题的 Galerkin 有限元解。\n\n定义目标泛函 $J:V\\to\\mathbb{R}$ 为 $J(v)=v(\\tfrac{1}{2})$。考虑伴随（对偶）问题：寻找 $z\\in V$ 使得\n$$\\int_{0}^{1} w'(x)\\,z'(x)\\,dx=J(w)\\quad\\text{对所有 } w\\in V.$$\n该伴随问题具有强形式 $-z''=\\delta_{\\tfrac{1}{2}}$（在 $\\Omega$ 中），且满足 $z(0)=0$ 和 $z(1)=0$，其中 $\\delta_{\\tfrac{1}{2}}$ 是位于 $x=\\tfrac{1}{2}$ 处的 Dirac 分布。\n\n根据第一性原理，使用网格 $\\mathcal{T}_{h}$ 上的残差和跳跃分解，定义限制在单元和面上的局部对偶权重 $\\tilde{z}_{h}$ 如下：\n- 对于每个单元 $K\\in\\mathcal{T}_{h}$，取 $\\tilde{z}_{h}|_{K}:=z|_{K}$。\n- 对于每个内部面 $E\\in\\mathcal{E}_{h}$，取 $\\tilde{z}_{h}|_{E}:=z(E)$。\n\n使用对偶加权残差（DWR）原理，为单元和面构造局部目标导向的指示子：\n- 对于每个单元 $K\\in\\mathcal{T}_{h}$，设 $\\eta_{K}:=\\int_{K}\\left(f+u_{h}''\\right)\\,\\tilde{z}_{h}\\,dx$。\n- 对于每个内部面 $E\\in\\mathcal{E}_{h}$，设 $\\eta_{E}:=-\\left[\\!\\left[u_{h}'\\right]\\!\\right]_{E}\\,\\tilde{z}_{h}|_{E}$，其中 $\\left[\\!\\left[u_{h}'\\right]\\!\\right]_{E}$ 表示导数跨越面 $E$ 的跳跃，其方向由相邻单元的外法线确定。\n\n假设使用精确对偶解 $z$ 来如上定义局部对偶权重，计算全局估计子\n$$\\eta:=\\sum_{K\\in\\mathcal{T}_{h}}\\eta_{K}+\\sum_{E\\in\\mathcal{E}_{h}}\\eta_{E},$$\n完全根据给定数据，并以单个实数形式给出其精确值。无需四舍五入；请提供精确结果。",
            "solution": "用户要求我计算一个用有限元法求解的一维椭圆边值问题的目标导向误差估计子 $\\eta$ 的值。\n\n该问题被认为是有效的，因为它在科学上基于偏微分方程数值分析的理论，特别是使用对偶加权残差（DWR）的后验误差估计。该问题是适定的、客观的，并包含计算唯一解所需的所有信息。\n\n全局估计子 $\\eta$ 定义为局部单元指示子 $\\eta_K$ 和局部面指示子 $\\eta_E$ 的和：\n$$\n\\eta = \\sum_{K\\in\\mathcal{T}_{h}}\\eta_{K}+\\sum_{E\\in\\mathcal{E}_{h}}\\eta_{E}\n$$\n其中\n$$\n\\eta_{K}:=\\int_{K}\\left(f+u_{h}''\\right)\\,\\tilde{z}_{h}\\,dx \\quad \\text{和} \\quad \\eta_{E}:=-\\left[\\!\\left[u_{h}'\\right]\\!\\right]_{E}\\,\\tilde{z}_{h}|_{E}\n$$\n计算过程分为几个步骤：\n1.  求出精确对偶解 $z(x)$。\n2.  求出有限元解 $u_h(x)$。\n3.  计算单元指示子 $\\eta_K$。\n4.  计算面指示子 $\\eta_E$。\n5.  将所有指示子相加得到 $\\eta$。\n\n**步骤1：确定精确对偶解 $z(x)$**\n对偶问题以强形式给出：\n$$\n-z'' = \\delta_{\\frac{1}{2}} \\quad \\text{in } \\Omega=(0,1), \\qquad z(0)=0, \\quad z(1)=0\n$$\n其中 $\\delta_{\\frac{1}{2}}$ 是以 $x=\\frac{1}{2}$ 为中心的 Dirac 分布。这是在 $(0,1)$ 上具有齐次 Dirichlet 边界条件的负二阶导数算子的格林函数。解是连续且分片线性的。\n\n对于 $x \\neq \\frac{1}{2}$，我们有 $z''(x)=0$，因此 $z(x)$ 在每个子区间 $(0, \\frac{1}{2})$ 和 $(\\frac{1}{2}, 1)$ 上是线性的。\n应用边界条件：\n-   对于 $x \\in [0, \\frac{1}{2}]$，$z(x) = C_1 x$。\n-   对于 $x \\in [\\frac{1}{2}, 1]$，$z(x) = C_2(1-x)$。\n\n在 $x=\\frac{1}{2}$ 处的连续性要求 $C_1(\\frac{1}{2}) = C_2(1-\\frac{1}{2})$，这意味着 $C_1=C_2$。\n\n通过在小区间 $[\\frac{1}{2}-\\epsilon, \\frac{1}{2}+\\epsilon]$ 上对 $-z''=\\delta_{\\frac{1}{2}}$ 积分，可以得到一阶导数在 $x=\\frac{1}{2}$ 处的跳跃条件：\n$$\n\\int_{\\frac{1}{2}-\\epsilon}^{\\frac{1}{2}+\\epsilon} -z'' dx = 1 \\implies [-z']_{\\frac{1}{2}-\\epsilon}^{\\frac{1}{2}+\\epsilon} = 1 \\implies z'(\\tfrac{1}{2}^{-}) - z'(\\tfrac{1}{2}^{+}) = 1\n$$\n导数为 $z'(x) = C_1$（对于 $x < \\frac{1}{2}$）和 $z'(x) = -C_2$（对于 $x > \\frac{1}{2}$）。\n跳跃条件变为 $C_1 - (-C_2) = 1$，所以 $C_1 + C_2 = 1$。\n由于 $C_1=C_2$，我们得到 $2C_1 = 1$，因此 $C_1=C_2=\\frac{1}{2}$。\n对偶解为：\n$$\nz(x) = \\begin{cases} \\frac{1}{2}x & \\text{if } 0 \\le x \\le \\frac{1}{2} \\\\ \\frac{1}{2}(1-x) & \\text{if } \\frac{1}{2} \\le x \\le 1 \\end{cases}\n$$\n\n**步骤2：确定有限元解 $u_h(x)$**\n空间 $V_h$ 由均匀网格上的连续分片线性函数组成，节点为 $x_0=0$, $x_1=\\frac{1}{3}$, $x_2=\\frac{2}{3}$, $x_3=1$。解为 $u_h(x) = U_1\\phi_1(x) + U_2\\phi_2(x)$，其中 $\\phi_1, \\phi_2$ 是内部节点 $x_1, x_2$ 处的帽状基函数，且 $U_i = u_h(x_i)$。Galerkin 系统为 $A\\mathbf{U}=\\mathbf{b}$，其中网格尺寸 $h = \\frac{1}{3}$。\n刚度矩阵 $A$ 和载荷向量 $\\mathbf{b}$ 为：\n$$\nA = \\frac{1}{h}\\begin{pmatrix} 2 & -1 \\\\ -1 & 2 \\end{pmatrix} = 3\\begin{pmatrix} 2 & -1 \\\\ -1 & 2 \\end{pmatrix} = \\begin{pmatrix} 6 & -3 \\\\ -3 & 6 \\end{pmatrix}\n$$\n$$\nb_i = \\int_0^1 f(x)\\phi_i(x) dx = \\int_0^1 \\phi_i(x) dx = \\text{Area}(\\phi_i) = h = \\frac{1}{3}\n$$\n需要求解的系统是：\n$$\n\\begin{pmatrix} 6 & -3 \\\\ -3 & 6 \\end{pmatrix} \\begin{pmatrix} U_1 \\\\ U_2 \\end{pmatrix} = \\begin{pmatrix} 1/3 \\\\ 1/3 \\end{pmatrix}\n$$\n根据对称性，$U_1=U_2$。第一个方程给出 $6U_1 - 3U_1 = \\frac{1}{3}$，所以 $3U_1 = \\frac{1}{3}$，从而得到 $U_1 = \\frac{1}{9}$。\n因此，$u_h(\\frac{1}{3})=\\frac{1}{9}$ 且 $u_h(\\frac{2}{3})=\\frac{1}{9}$。\n有限元解 $u_h(x)$ 由点 $(0,0), (\\frac{1}{3}, \\frac{1}{9}), (\\frac{2}{3}, \\frac{1}{9}), (1,0)$ 给出。其一阶导数 $u_h'(x)$ 是分片常数：\n$$\nu_h'(x) = \\begin{cases} \\frac{1/9}{1/3} = \\frac{1}{3} & \\text{if } x \\in (0, 1/3) \\\\ \\frac{1/9 - 1/9}{1/3} = 0 & \\text{if } x \\in (1/3, 2/3) \\\\ \\frac{0 - 1/9}{1/3} = -\\frac{1}{3} & \\text{if } x \\in (2/3, 1) \\end{cases}\n$$\n\n**步骤3：计算单元指示子 $\\eta_K$**\n单元上的局部对偶权重为 $\\tilde{z}_h|_K = z|_K$。由于 $u_h$ 在每个单元 $K$ 上是线性的，因此在 $K$ 内部 $u_h''=0$。当 $f=1$ 时，单元指示子为：\n$$\n\\eta_{K} = \\int_{K} (1+0) z(x) dx = \\int_K z(x) dx\n$$\n-   对于 $K_1=[0, \\frac{1}{3}]$：\n    $\\eta_{K_1} = \\int_0^{1/3} \\frac{1}{2}x dx = \\left[\\frac{x^2}{4}\\right]_0^{1/3} = \\frac{1}{4}\\left(\\frac{1}{3}\\right)^2 = \\frac{1}{36}$。\n-   对于 $K_2=[\\frac{1}{3}, \\frac{2}{3}]$：\n    $\\eta_{K_2} = \\int_{1/3}^{2/3} z(x) dx = \\int_{1/3}^{1/2} \\frac{1}{2}x dx + \\int_{1/2}^{2/3} \\frac{1}{2}(1-x) dx$\n    $= \\left[\\frac{x^2}{4}\\right]_{1/3}^{1/2} + \\left[\\frac{x}{2}-\\frac{x^2}{4}\\right]_{1/2}^{2/3}$\n    $= \\left(\\frac{1}{16}-\\frac{1}{36}\\right) + \\left(\\left(\\frac{1}{3}-\\frac{1}{9}\\right) - \\left(\\frac{1}{4}-\\frac{1}{16}\\right)\\right)$\n    $= \\frac{5}{144} + \\left(\\frac{2}{9} - \\frac{3}{16}\\right) = \\frac{5}{144} + \\frac{32-27}{144} = \\frac{5}{144} + \\frac{5}{144} = \\frac{10}{144} = \\frac{5}{72}$。\n-   对于 $K_3=[\\frac{2}{3}, 1]$：根据与 $K_1$ 的对称性，$\\eta_{K_3}=\\eta_{K_1}=\\frac{1}{36}$。\n\n单元指示子之和为：\n$$\n\\sum_{K\\in\\mathcal{T}_{h}}\\eta_K = \\frac{1}{36} + \\frac{5}{72} + \\frac{1}{36} = \\frac{2}{72} + \\frac{5}{72} + \\frac{2}{72} = \\frac{9}{72} = \\frac{1}{8}\n$$\n\n**步骤4：计算面指示子 $\\eta_E$**\n内部面为 $E_1=\\{\\frac{1}{3}\\}$ 和 $E_2=\\{\\frac{2}{3}\\}$。面上的局部对偶权重为 $\\tilde{z}_h|_E = z(E)$。跳跃 $\\left[\\!\\left[u_h'\\right]\\!\\right]_{E}$ 被指定为‘由外法线定向’。对于位于单元 $K_L$ 和 $K_R$ 之间的面 $E=x_i$，这定义了跳跃为 $\\left[\\!\\left[v\\right]\\!\\right]_{x_i} = v(x_i^-)n_L + v(x_i^+)n_R = v(x_i^-)(+1) + v(x_i^+)(-1) = v(x_i^-) - v(x_i^+)$。\n\n-   对于 $E_1=\\{\\frac{1}{3}\\}$：\n    $z(\\frac{1}{3}) = \\frac{1}{2}(\\frac{1}{3}) = \\frac{1}{6}$。\n    $\\left[\\!\\left[u_h'\\right]\\!\\right]_{1/3} = u_h'(\\tfrac{1}{3}^-) - u_h'(\\tfrac{1}{3}^+) = \\frac{1}{3} - 0 = \\frac{1}{3}$。\n    $\\eta_{E_1} = - \\left[\\!\\left[u_h'\\right]\\!\\right]_{1/3} z(\\tfrac{1}{3}) = -\\left(\\frac{1}{3}\\right)\\left(\\frac{1}{6}\\right) = -\\frac{1}{18}$。\n-   对于 $E_2=\\{\\frac{2}{3}\\}$：\n    $z(\\frac{2}{3}) = \\frac{1}{2}(1-\\frac{2}{3}) = \\frac{1}{6}$。\n    $\\left[\\!\\left[u_h'\\right]\\!\\right]_{2/3} = u_h'(\\tfrac{2}{3}^-) - u_h'(\\tfrac{2}{3}^+) = 0 - (-\\frac{1}{3}) = \\frac{1}{3}$。\n    $\\eta_{E_2} = - \\left[\\!\\left[u_h'\\right]\\!\\right]_{2/3} z(\\tfrac{2}{3}) = -\\left(\\frac{1}{3}\\right)\\left(\\frac{1}{6}\\right) = -\\frac{1}{18}$。\n\n面指示子之和为：\n$$\n\\sum_{E\\in\\mathcal{E}_{h}}\\eta_E = -\\frac{1}{18} - \\frac{1}{18} = -\\frac{2}{18} = -\\frac{1}{9}\n$$\n\n**步骤5：计算全局估计子 $\\eta$**\n全局估计子是单元和面贡献的总和：\n$$\n\\eta = \\sum_{K\\in\\mathcal{T}_{h}}\\eta_K + \\sum_{E\\in\\mathcal{E}_{h}}\\eta_E = \\frac{1}{8} + \\left(-\\frac{1}{9}\\right) = \\frac{1}{8} - \\frac{1}{9} = \\frac{9-8}{72} = \\frac{1}{72}\n$$\n这个结果与 DWR 恒等式一致，该恒等式指出，对于此权重选择，估计子 $\\eta$ 等于目标泛函中的误差 $J(u) - J(u_h)$。精确解为 $u(x)=\\frac{1}{2}x(1-x)$，因此 $J(u)=u(\\frac{1}{2})=\\frac{1}{8}$。在中间单元上，有限元解为 $u_h(x)=\\frac{1}{9}$，因此 $J(u_h)=u_h(\\frac{1}{2})=\\frac{1}{9}$。误差为 $J(u)-J(u_h) = \\frac{1}{8}-\\frac{1}{9}=\\frac{1}{72}$。",
            "answer": "$$\\boxed{\\frac{1}{72}}$$"
        },
        {
            "introduction": "除了用于估计离散误差，对偶方法在更广泛的领域（如灵敏度分析和不确定性量化）中也扮演着核心角色。这个练习旨在揭示对偶解的一个深刻物理意义：它衡量了目标泛函对于方程中源项扰动的敏感度。您将通过推导和计算，学习如何利用对偶解$z$来量化输入数据$f$中的不确定性对目标泛函$J(u)$造成的影响，这在工程设计和模型校准中是一个极其强大的工具 。",
            "id": "3400748",
            "problem": "考虑区间 $\\Omega=(0,1)$ 上的标量扩散模型问题，其带有齐次狄利克雷边界条件：求 $u(f) \\in V := H_{0}^{1}(0,1)$ 使得\n$$\n\\int_{0}^{1} u'(x)\\, v'(x)\\, dx \\;=\\; \\int_{0}^{1} f(x)\\, v(x)\\, dx\n\\quad \\text{对所有 } v \\in V.\n$$\n设目标泛函为状态的空间平均值，\n$$\nJ(u) \\;=\\; \\int_{0}^{1} u(x)\\, dx,\n$$\n并假设右端数据 $f$ 是不确定的，可以写为 $f = \\widehat{f} + \\delta f$，其中 $\\widehat{f}$ 是一个固定的参考值，数据扰动 $\\delta f$ 由下式给出\n$$\n\\delta f(x) \\;=\\; \\beta \\;+\\; \\eta \\, \\sin(\\pi x),\n$$\n其中 $\\beta,\\eta \\in \\mathbb{R}$。\n\n使用线性化第一原理，通过状态方程将 $J(u(f))$ 视为 $f$ 的泛函，并推导目标关于数据扰动 $\\delta f$ 的一阶变分 $\\delta J_{\\mathrm{data}}$。通过变分恒等式\n$$\n\\int_{0}^{1} v'(x)\\, z'(x)\\, dx \\;=\\; J'(u(\\widehat{f}))[v]\n\\quad \\text{对所有 } v \\in V,\n$$\n引入伴随 $z \\in V$，并通过伴随系统地消去状态变分，从而用 $\\delta f$ 和 $z$ 来表示 $\\delta J_{\\mathrm{data}}$。然后，通过显式求解伴随问题，为指定的 $\\delta f(x) = \\beta + \\eta \\sin(\\pi x)$ 计算 $\\delta J_{\\mathrm{data}}$ 的闭式解。\n\n请以 $\\beta$ 和 $\\eta$ 表示的单个闭式解析表达式的形式提供您的最终答案。不包含单位。无需四舍五入。",
            "solution": "用户希望我严格验证并解决一个来自偏微分方程数值分析领域的问题，具体是关于使用对偶加权残差的目标导向误差控制。\n\n### 第一步：提取已知条件\n- **定义域**: $\\Omega=(0,1)$。\n- **函数空间**: $V := H_{0}^{1}(0,1)$，索博列夫空间，其函数的一阶弱导数是平方可积的，并且在边界上为零。\n- **状态方程（弱形式）**: 求 $u(f) \\in V$ 使得对所有 $v \\in V$ 都有 $\\int_{0}^{1} u'(x)\\, v'(x)\\, dx = \\int_{0}^{1} f(x)\\, v(x)\\, dx$。\n- **目标泛函**: $J(u) = \\int_{0}^{1} u(x)\\, dx$。\n- **数据扰动**: 右端数据为 $f = \\widehat{f} + \\delta f$，其中 $\\widehat{f}$ 是一个参考值，数据扰动为 $\\delta f(x) = \\beta + \\eta \\sin(\\pi x)$，且 $\\beta, \\eta \\in \\mathbb{R}$。\n- **伴随方程（弱形式）**: 求 $z \\in V$ 使得对所有 $v \\in V$ 都有 $\\int_{0}^{1} v'(x)\\, z'(x)\\, dx = J'(u(\\widehat{f}))[v]$。\n\n### 第二步：使用提取的已知条件进行验证\n1.  **科学性或事实性错误**：该问题在科学上和数学上都是合理的。它描述了伴随方法（具体来说是对偶加权残差法）的一个标准应用，用于确定一个泛函输出（目标）对于边值问题输入数据扰动的敏感度。所提供的方程是原问题（泊松方程）和相应对偶（伴随）问题的标准弱形式。\n2.  **不可形式化或不相关**：该问题是高度形式化的，直接关系到偏微分方程数值解领域内“使用对偶加权残差的目标导向误差控制”这一主题。\n3.  **不完整或矛盾的设置**：该问题是自洽的。它提供了状态方程、目标泛函、数据扰动的具体形式以及推导所需的伴随问题的定义。不存在矛盾。\n4.  **不切实际或不可行**：该问题是偏微分方程分析中的一个标准模型问题，完全可以求解。\n5.  **不适定或结构不良**：该问题是适定的。带有齐次狄利克雷条件的泊松问题是适定的，伴随问题也是如此。所要求的推导会得出一个唯一且有意义的结果。\n6.  **伪深刻、琐碎或同义反复**：该问题并非琐碎。它需要一个多步骤的推导，涉及泛函分析（Fréchet导数、弱形式）和变分法的概念，然后求解一个微分方程并计算定积分。这些步骤考验了对伴随方法的核心理解。\n7.  **超出科学可验证性**：推导过程和最终结果在数学上都是可验证的。\n\n### 第三步：结论与行动\n该问题是有效的。我将继续提供一个完整、合理的解答。\n\n该问题要求计算由于数据中的扰动 $\\delta f$ 引起的目标泛函的一阶变分 $\\delta J_{\\mathrm{data}}$。求解过程包括三个主要步骤：\n1.  推导 $\\delta J_{\\mathrm{data}}$ 关于伴随状态 $z$ 和数据扰动 $\\delta f$ 的一般表达式。\n2.  显式求解伴随问题以找到伴随状态 $z(x)$。\n3.  将 $z(x)$ 的解和给定的 $\\delta f(x)$ 代入一般表达式并计算结果。\n\n让我们定义与状态方程的弱形式相对应的双线性形式 $a: V \\times V \\to \\mathbb{R}$ 和线性泛函 $L_f: V \\to \\mathbb{R}$：\n$$\na(w, v) := \\int_{0}^{1} w'(x)\\, v'(x)\\, dx\n$$\n$$\nL_f(v) := \\int_{0}^{1} f(x)\\, v(x)\\, dx\n$$\n对于给定的源 $f$，状态方程为：求 $u(f) \\in V$ 使得对所有 $v \\in V$ 都有 $a(u(f), v) = L_f(v)$。\n\n设 $\\widehat{u} = u(\\widehat{f})$ 是对应于参考数据 $\\widehat{f}$ 的解，而 $u = u(\\widehat{f} + \\delta f)$ 是对应于扰动数据的解。状态的一阶变分 $\\delta u$ 由近似式 $u \\approx \\widehat{u} + \\delta u$ 定义。我们可以通过线性化状态方程来找到控制 $\\delta u$ 的方程。\n$$\na(\\widehat{u} + \\delta u, v) = L_{\\widehat{f} + \\delta f}(v)\n$$\n根据 $a(\\cdot, \\cdot)$ 在其第一个参数上的线性以及 $L_{(\\cdot)}(v)$ 的线性，我们有：\n$$\na(\\widehat{u}, v) + a(\\delta u, v) = L_{\\widehat{f}}(v) + L_{\\delta f}(v)\n$$\n由于 $\\widehat{u}$ 满足数据为 $\\widehat{f}$ 的状态方程，即 $a(\\widehat{u}, v) = L_{\\widehat{f}}(v)$，我们可以从上一个方程中减去此式，以获得状态变分 $\\delta u$ 的线性化状态方程：\n$$\na(\\delta u, v) = L_{\\delta f}(v) \\quad \\text{对所有 } v \\in V.\n$$\n目标泛函的一阶变分 $\\delta J_{\\mathrm{data}}$ 由 $J(u)$ 在 $\\widehat{u}$ 附近的线性化给出：\n$$\n\\delta J_{\\mathrm{data}} = J(u) - J(\\widehat{u}) \\approx J'(\\widehat{u})[\\delta u]\n$$\n目标泛函为 $J(u) = \\int_{0}^{1} u(x) dx$。这是一个线性泛函，所以它的Fréchet导数 $J'(u)$ 与 $u$ 无关，并由 $J'(u)[v] = \\int_{0}^{1} v(x) dx = J(v)$ 给出。因此，目标的变分精确地为：\n$$\n\\delta J_{\\mathrm{data}} = J(\\delta u) = \\int_{0}^{1} \\delta u(x) dx = J'(\\widehat{u})[\\delta u]\n$$\n伴随问题定义为：寻找 $z \\in V$ 使得对所有 $v \\in V$ 都有 $a(v, z) = J'(\\widehat{u})[v]$。双线性形式 $a(\\cdot, \\cdot)$ 是对称的，即 $a(w,v) = a(v,w)$，所以伴随方程可以写为 $a(z, v) = J'(\\widehat{u})[v]$。\n\n现在，我们使用伴随解 $z$ 来用数据扰动 $\\delta f$ 表示 $\\delta J_{\\mathrm{data}}$。\n我们从目标的变分表达式开始，并将伴随方程中的检验函数 $v$ 设为状态变分 $\\delta u \\in V$：\n$$\n\\delta J_{\\mathrm{data}} = J'(\\widehat{u})[\\delta u] = a(\\delta u, z)\n$$\n接下来，我们使用 $\\delta u$ 的线性化状态方程，并将其检验函数 $v$ 设为伴随解 $z \\in V$：\n$$\na(\\delta u, z) = L_{\\delta f}(z)\n$$\n结合这两个结果，得到所需的关系式：\n$$\n\\delta J_{\\mathrm{data}} = L_{\\delta f}(z) = \\int_{0}^{1} \\delta f(x) z(x) dx\n$$\n该表达式将输出泛函的变分与输入数据扰动直接联系起来，其间的媒介是伴随解 $z$，它充当了敏感度函数。\n\n为了计算 $\\delta J_{\\mathrm{data}}$ 的值，我们必须找到 $z(x)$ 的显式形式。伴随问题的弱形式是：\n$$\n\\int_{0}^{1} z'(x)\\, v'(x)\\, dx = \\int_{0}^{1} v(x)\\, dx \\quad \\text{对所有 } v \\in V=H_0^1(0,1).\n$$\n这是强形式两点边值问题的弱形式：\n$$\n-z''(x) = 1, \\quad x \\in (0,1)\n$$\n$$\nz(0) = 0, \\quad z(1) = 0\n$$\n对微分方程积分两次，得到：\n$$\n-z'(x) = x + C_1\n$$\n$$\n-z(x) = \\frac{1}{2}x^2 + C_1 x + C_2\n$$\n应用边界条件求出常数 $C_1$ 和 $C_2$：\n$z(0) = 0 \\implies -(\\frac{1}{2}(0)^2 + C_1(0) + C_2) = 0 \\implies C_2=0$。\n$z(1) = 0 \\implies -(\\frac{1}{2}(1)^2 + C_1(1) + 0) = 0 \\implies -\\frac{1}{2} - C_1 = 0 \\implies C_1 = -\\frac{1}{2}$。\n将常数代回，得到伴随解：\n$$\nz(x) = -\\left(\\frac{1}{2}x^2 - \\frac{1}{2}x\\right) = \\frac{1}{2}(x - x^2)\n$$\n最后，我们将 $z(x) = \\frac{1}{2}(x - x^2)$ 和 $\\delta f(x) = \\beta + \\eta \\sin(\\pi x)$ 代入积分表达式来计算 $\\delta J_{\\mathrm{data}}$：\n$$\n\\delta J_{\\mathrm{data}} = \\int_{0}^{1} \\left(\\beta + \\eta \\sin(\\pi x)\\right) \\left(\\frac{1}{2}(x - x^2)\\right) dx\n$$\n我们可以将积分分成两部分：\n$$\n\\delta J_{\\mathrm{data}} = \\frac{\\beta}{2} \\int_{0}^{1} (x - x^2) dx + \\frac{\\eta}{2} \\int_{0}^{1} (x - x^2) \\sin(\\pi x) dx\n$$\n第一个积分是：\n$$\n\\int_{0}^{1} (x - x^2) dx = \\left[ \\frac{x^2}{2} - \\frac{x^3}{3} \\right]_{0}^{1} = \\frac{1}{2} - \\frac{1}{3} = \\frac{1}{6}\n$$\n第二个积分需要两次分部积分。设 $I = \\int_{0}^{1} (x - x^2) \\sin(\\pi x) dx$。\n第一次分部积分：设 $u_1 = x - x^2$ 且 $dv_1 = \\sin(\\pi x) dx$。则 $du_1 = (1 - 2x) dx$ 且 $v_1 = -\\frac{1}{\\pi}\\cos(\\pi x)$。\n$$\nI = \\left[ -\\frac{1}{\\pi}(x - x^2)\\cos(\\pi x) \\right]_{0}^{1} - \\int_{0}^{1} \\left(-\\frac{1}{\\pi}\\cos(\\pi x)\\right)(1 - 2x) dx\n$$\n边界项在 $x=0$ 和 $x=1$ 处都为零。\n$$\nI = \\frac{1}{\\pi} \\int_{0}^{1} (1 - 2x)\\cos(\\pi x) dx\n$$\n第二次分部积分：设 $u_2 = 1 - 2x$ 且 $dv_2 = \\cos(\\pi x) dx$。则 $du_2 = -2 dx$ 且 $v_2 = \\frac{1}{\\pi}\\sin(\\pi x)$。\n$$\nI = \\frac{1}{\\pi} \\left( \\left[ \\frac{1}{\\pi}(1 - 2x)\\sin(\\pi x) \\right]_{0}^{1} - \\int_{0}^{1} \\frac{1}{\\pi}\\sin(\\pi x)(-2) dx \\right)\n$$\n由于 $\\sin(0) = \\sin(\\pi) = 0$，边界项在两个极限处也为零。\n$$\nI = \\frac{1}{\\pi} \\left( \\frac{2}{\\pi} \\int_{0}^{1} \\sin(\\pi x) dx \\right) = \\frac{2}{\\pi^2} \\left[ -\\frac{1}{\\pi}\\cos(\\pi x) \\right]_{0}^{1}\n$$\n$$\nI = -\\frac{2}{\\pi^3} [\\cos(\\pi x)]_{0}^{1} = -\\frac{2}{\\pi^3} (\\cos(\\pi) - \\cos(0)) = -\\frac{2}{\\pi^3} (-1 - 1) = \\frac{4}{\\pi^3}\n$$\n现在，我们合并 $\\delta J_{\\mathrm{data}}$ 两部分的结果：\n$$\n\\delta J_{\\mathrm{data}} = \\frac{\\beta}{2} \\left(\\frac{1}{6}\\right) + \\frac{\\eta}{2} \\left(\\frac{4}{\\pi^3}\\right) = \\frac{\\beta}{12} + \\frac{2\\eta}{\\pi^3}\n$$\n这就是目标关于指定数据扰动的一阶变分的闭式形式。",
            "answer": "$$\\boxed{\\frac{\\beta}{12} + \\frac{2\\eta}{\\pi^3}}$$"
        },
        {
            "introduction": "目标导向误差控制的最终目标之一是为我们关心的物理量提供可靠的保证。这个综合性的编程练习将指导您实现一个完整的“认证”程序，即利用DWR估计量来构造目标泛函$J(u)$的严格上下界。通过在不同尺度的网格上计算误差估计量，并结合一个合理的饱和假设，我们可以从单纯的误差估计走向误差认证，确保计算结果在给定的容许区间内，这在可靠性要求高的科学与工程应用中具有无可替代的价值 。",
            "id": "3400752",
            "problem": "考虑单位区间上具有齐次 Dirichlet 边界条件的一维、线性、二阶、强制边值问题：寻找 $u \\in H_0^1(0,1)$ 使得\n$$\n\\int_0^1 u'(x)\\,v'(x)\\,dx = \\int_0^1 f(x)\\,v(x)\\,dx \\quad \\text{对所有 } v \\in H_0^1(0,1).\n$$\n设目标泛函在 $H_0^1(0,1)$ 上是线性的且有界的，由下式给出\n$$\nJ(u) = \\int_0^1 g(x)\\,u(x)\\,dx.\n$$\n引入对偶（伴随）问题：寻找 $z \\in H_0^1(0,1)$ 使得\n$$\n\\int_0^1 w'(x)\\,z'(x)\\,dx = \\int_0^1 g(x)\\,w(x)\\,dx \\quad \\text{对所有 } w \\in H_0^1(0,1).\n$$\n使用连续分片线性有限元，在包含 $N$ 个单元的均匀网格（网格尺寸 $h = 1/N$）上对原始问题和对偶问题进行离散化，并将网格尺寸为 $h$ 和 $h/2$ 上的相应有限元近似解分别记为 $u_h$, $u_{h/2}$（对于原始问题）和 $z_{h/2}$, $z_{h/4}$（对于对偶问题）。对单元积分使用标准高斯求积（两点高斯法则）。对于离散原始解 $u_h$ 的残差，定义\n$$\nR(u_h)(v) := \\int_0^1 f(x)\\,v(x)\\,dx - \\int_0^1 u_h'(x)\\,v'(x)\\,dx,\n$$\n该式对 $v \\in H_0^1(0,1)$ 是良定的。\n\n一位用户要求认证精确目标值 $J(u)$ 位于预设区间 $[L,U]$ 内。您的任务是制定并实现一个基于对偶加权残差的可计算认证程序，该程序能够得出 $J(u)$ 的双边、目标导向的界，并判断约束 $J(u) \\in [L,U]$ 是否得到保证。\n\n您的程序必须从上述基本变分定义出发，并遵循以下原则：\n\n1. 在网格层级上构建一个实用的对偶加权残差估计子，方法是在相对于原始离散化是加密的对偶权函数上评估原始残差（即用 $z_{h/2}$ 对应 $u_h$，用 $z_{h/4}$ 对应 $u_{h/2}$），并通过减去到相应原始空间上的节点插值来消除离散对偶空间的污染。\n2. 针对高阶余项，采用一个数学上明确的饱和模型，这是目标导向后验误差分析中的标准做法。该模型必须使用一个用户指定的饱和因子 $q \\in (0,1)$，该因子应用于从网格尺寸 $h$ 过渡到 $h/2$ 时的余项。因子 $q$ 必须明确地出现在您最终的可计算双边界中。\n3. 根据这些要素，推导出两个可计算的数 $\\underline{J}$ 和 $\\overline{J}$（下界和上界），它们在饱和模型下满足 $J(u) \\in [\\underline{J}, \\overline{J}]$，并且仅基于 $u_h$、$u_{h/2}$、$z_{h/2}$、$z_{h/4}$、数据 $f$、$g$ 和 $q$。\n4. 基于计算出的 $\\underline{J}$ 和 $\\overline{J}$，通过返回一个布尔值来认证该约束，如果 $[\\underline{J}, \\overline{J}] \\subseteq [L, U]$，则该值为 $ \\text{True}$，否则为 $ \\text{False}$。\n\n实现要求：\n- 使用均匀网格和标准的连续分片线性有限元。\n- 在 $x=0$ 和 $x=1$ 处施加齐次 Dirichlet 边界条件。\n- 对于所有单元级积分，在映射到每个单元的参考段上使用两点高斯求积法则。\n- 数值程序必须是自包含的，并且不需要用户输入。\n\n测试套件：\n对以下四个测试用例实现并运行您的认证程序。对每个用例，都指定了函数 $f$ 和 $g$、粗网格尺寸 $N$、饱和因子 $q$ 以及目标区间 $[L,U]$。使用 $x \\in [0,1]$。三角函数使用弧度作为角度单位。\n\n- 案例 A（常规成功路径）：\n  - $f(x) = 1$,\n  - $g(x) = x(1-x)$,\n  - $N = 16$,\n  - $q = 0.5$,\n  - 区间 $[L,U] = [0.03, 0.06]$。\n\n- 案例 B（较大饱和因子的影响）：\n  - $f(x) = 1$,\n  - $g(x) = x(1-x)$,\n  - $N = 16$,\n  - $q = 0.9$,\n  - 区间 $[L,U] = [0.03, 0.06]$。\n\n- 案例 C（具有振荡解和目标的不同数据）：\n  - $f(x) = \\pi^2 \\sin(\\pi x)$,\n  - $g(x) = \\sin(\\pi x)$,\n  - $N = 24$,\n  - $q = 0.5$,\n  - 区间 $[L,U] = [0.3, 0.7]$。\n\n- 案例 D（不太可能被认证的窄区间）：\n  - $f(x) = \\pi^2 \\sin(\\pi x)$,\n  - $g(x) = x(1-x)$,\n  - $N = 24$,\n  - $q = 0.5$,\n  - 区间 $[L,U] = [0.0, 0.01]$。\n\n最终输出规范：\n- 对每个案例，计算认证布尔值。如果您的基于 DWR 的程序产生的认证界完全位于目标区间内，则为 $ \\text{True}$，否则为 $ \\text{False}$。\n- 您的程序应生成单行输出，其中包含四个布尔值，格式为用方括号括起来的逗号分隔列表，例如：“[True,False,True,False]”。\n- 不涉及物理单位。\n\n您的推导必须从上述变分形式和残差的定义开始。除了从这些基础和饱和模型可以推导出的内容外，不要假设或引用任何专门的、现成的目标误差界公式。在您的推导中，所有数学实体（包括数字）都必须用 LaTeX 书写。",
            "solution": "该问题要求针对一个一维边值问题，使用对偶加权残差（DWR）方法，制定并实现一个目标导向的误差认证程序。该程序必须在指定的饱和假设下，为一个线性目标泛函 $J(u)$ 计算有保证的双边界 $[\\underline{J}, \\overline{J}]$，然后验证这些界是否位于给定的目标区间 $[L, U]$ 内。\n\n我们首先为可计算的界建立理论基础。\n\n原始问题是寻找 $u \\in H_0^1(0,1)$，使得对所有测试函数 $v \\in H_0^1(0,1)$，都有 $a(u, v) = \\ell(v)$，其中双线性形式 $a(\\cdot, \\cdot)$ 和线性形式 $\\ell(\\cdot)$ 由下式给出：\n$$\na(w, v) = \\int_0^1 w'(x) v'(x) dx\n$$\n$$\n\\ell(v) = \\int_0^1 f(x) v(x) dx\n$$\n我们关注的目标泛函是 $J(u) = \\int_0^1 g(x) u(x) dx$。相关的对偶问题寻求一个解 $z \\in H_0^1(0,1)$，使得对所有 $w \\in H_0^1(0,1)$，都有 $a(w, z) = J(w)$。由于 $a(\\cdot, \\cdot)$ 的对称性，我们可以将其写为 $a(z, w) = J(w)$。\n\n对于一个有限元近似解 $u_h \\in V_h \\subset H_0^1(0,1)$，目标泛函的误差为 $J(u) - J(u_h) = J(u-u_h)$。设 $e_u = u - u_h$ 为原始误差。使用对偶解 $z$ 的定义，我们得到基本误差恒等式：\n$$\nJ(u) - J(u_h) = J(e_u) = a(e_u, z) = a(u-u_h, z)\n$$\n利用 $a(\\cdot, \\cdot)$ 的线性和对所有 $v$ 都有 $a(u,v)=\\ell(v)$ 这一事实，我们令 $v=z$ 得到 $a(u,z) = \\ell(z)$。这就得出了 DWR 误差表示公式：\n$$\nJ(u) - J(u_h) = a(u,z) - a(u_h, z) = \\ell(z) - a(u_h, z) =: R(u_h)(z)\n$$\n其中 $R(u_h)(v) = \\ell(v) - a(u_h, v)$ 是原始残差。这个公式是精确的但不可计算，因为它依赖于未知的对偶解 $z$。\n\n为了推导一个可计算的估计子，我们用一个更精确但可计算的近似值来代替 $z$。问题指定使用尺寸为 $h$、$h/2$ 和 $h/4$ 的网格层级。设 $u_h, u_{h/2}$ 是尺寸为 $h$ 和 $h/2$ 网格上的原始解，$z_{h/2}, z_{h/4}$ 是尺寸为 $h/2$ 和 $h/4$ 网格上的对偶解。设 $V_H$ 是尺寸为 $H$ 的网格上的有限元空间。\n\n根据伽辽金正交性，对任何 $v_h \\in V_h$ 都有 $R(u_h)(v_h) = 0$。因此我们可以写出：\n$$\nJ(u) - J(u_h) = R(u_h)(z) = R(u_h)(z - v_h) \\quad \\text{对任何 } v_h \\in V_h\n$$\n问题陈述我们应该使用一个加密的对偶近似，并减去其节点插值以避免污染。设 $I_h: V_{h/2} \\to V_h$ 为节点插值算子。选择 $v_h = I_h z_{h/2}$，我们得到：\n$$\nJ(u) - J(u_h) = R(u_h)(z - I_h z_{h/2}) = R(u_h)(z_{h/2} - I_h z_{h/2}) + R(u_h)(z - z_{h/2})\n$$\n第一项 $\\eta_h := R(u_h)(z_{h/2} - I_h z_{h/2})$ 是一个完全可计算的误差估计子。第二项 $R(u_h)(z-z_{h/2})$ 涉及未知的 $z$，并构成近似的余项。\n\n让我们在两个连续的网格层级上定义目标泛函的误差：\n$$\n\\mathcal{E}_h = J(u) - J(u_h)\n$$\n$$\n\\mathcal{E}_{h/2} = J(u) - J(u_{h/2})\n$$\n使用估计子 $\\eta$ 和一个余项 $\\mathcal{R}$，我们可以将这些误差写为：\n$$\n\\mathcal{E}_h = \\eta_h + \\mathcal{R}_h \\quad \\text{其中 } \\eta_h = R(u_h)(z_{h/2} - I_h z_{h/2})\n$$\n$$\n\\mathcal{E}_{h/2} = \\eta_{h/2} + \\mathcal{R}_{h/2} \\quad \\text{其中 } \\eta_{h/2} = R(u_{h/2})(z_{h/4} - I_{h/2} z_{h/4})\n$$\n余项 $\\mathcal{R}_h$ 和 $\\mathcal{R}_{h/2}$ 代表高阶效应。将两个误差表示式相减得到：\n$$\n\\mathcal{E}_h - \\mathcal{E}_{h/2} = (\\eta_h - \\eta_{h/2}) + (\\mathcal{R}_h - \\mathcal{R}_{h/2})\n$$\n左边也等于 $(J(u) - J(u_h)) - (J(u) - J(u_{h/2})) = J(u_{h/2}) - J(u_h)$。因此，我们可以为余项写出一个方程：\n$$\n\\mathcal{R}_h - \\mathcal{R}_{h/2} = (J(u_{h/2}) - J(u_h)) - (\\eta_h - \\eta_{h/2})\n$$\n设 $\\Delta = (J(u_{h/2}) - J(u_h)) - (\\eta_h - \\eta_{h/2})$。量 $\\Delta$ 可以从离散解完全计算得出。\n\n我们现在根据问题要求，援引饱和假设。我们假设当网格加密时，余项的量级至少减小一个因子 $q \\in (0,1)$：\n$$\n|\\mathcal{R}_{h/2}| \\le q |\\mathcal{R}_h|\n$$\n从 $\\mathcal{R}_h - \\mathcal{R}_{h/2} = \\Delta$ 可得 $\\mathcal{R}_h = \\mathcal{R}_{h/2} + \\Delta$。将此代入饱和不等式：\n$$\n|\\mathcal{R}_{h/2}| \\le q |\\mathcal{R}_{h/2} + \\Delta| \\le q (|\\mathcal{R}_{h/2}| + |\\Delta|)\n$$\n对 $|\\mathcal{R}_{h/2}|$ 整理这个不等式：\n$$\n|\\mathcal{R}_{h/2}| (1-q) \\le q |\\Delta| \\implies |\\mathcal{R}_{h/2}| \\le \\frac{q}{1-q} |\\Delta|\n$$\n这为更细网格上的余项提供了一个可计算的界，我们将其记为 $E_{bound} = \\frac{q}{1-q} |\\Delta|$。\n\n我们现在可以建立真实误差 $\\mathcal{E}_{h/2} = J(u) - J(u_{h/2})$ 的界。由于 $\\mathcal{E}_{h/2} = \\eta_{h/2} + \\mathcal{R}_{h/2}$，我们有：\n$$\n\\eta_{h/2} - |\\mathcal{R}_{h/2}| \\le \\mathcal{E}_{h/2} \\le \\eta_{h/2} + |\\mathcal{R}_{h/2}|\n$$\n代入 $|\\mathcal{R}_{h/2}|$ 的界：\n$$\n\\eta_{h/2} - E_{bound} \\le J(u) - J(u_{h/2}) \\le \\eta_{h/2} + E_{bound}\n$$\n最后，通过将不等式各部分都加上 $J(u_{h/2})$，我们得到精确目标泛函值 $J(u)$ 的所需双边界 $[\\underline{J}, \\overline{J}]$：\n$$\n\\underline{J} = J(u_{h/2}) + \\eta_{h/2} - E_{bound}\n$$\n$$\n\\overline{J} = J(u_{h/2}) + \\eta_{h/2} + E_{bound}\n$$\n其中 $E_{bound} = \\frac{q}{1-q} |(J(u_{h/2}) - J(u_h)) - (\\eta_h - \\eta_{h/2})|$。\n\n那么，认证过程就是计算 $\\underline{J}$ 和 $\\overline{J}$，并检查 $[\\underline{J}, \\overline{J}] \\subseteq [L, U]$ 是否成立，这等价于检验 $\\underline{J} \\ge L$ 和 $\\overline{J} \\le U$ 是否成立。\n\n实现将包括：\n1. 一个有限元求解器，用于在均匀网格上求解原始问题和对偶问题，使用分片线性基函数并处理齐次 Dirichlet 边界条件。\n2. 用于计算目标泛函 $J(\\cdot)$ 和基于残差的估计子 $\\eta_h$ 与 $\\eta_{h/2}$ 的函数。所有积分必须使用两点高斯求积法则。\n3. 一个主程序，用于协调所有所需离散解（$u_h, u_{h/2}, z_{h/2}, z_{h/4}$）的计算，计算界 $[\\underline{J}, \\overline{J}]$，并对每个测试用例执行认证。",
            "answer": "```python\nimport numpy as np\n\ndef solve_bvp(N_elements, rhs_func):\n    \"\"\"\n    Solves the 1D Poisson problem -u'' = f on [0,1] with u(0)=u(1)=0\n    using piecewise linear finite elements on a uniform mesh.\n\n    Args:\n        N_elements (int): Number of elements in the mesh.\n        rhs_func (callable): The function f(x) on the right-hand side.\n\n    Returns:\n        A tuple (coeffs, nodes) where:\n        - coeffs (np.ndarray): Nodal solution values, including boundaries.\n        - nodes (np.ndarray): Coordinates of the mesh nodes.\n    \"\"\"\n    h = 1.0 / N_elements\n    num_nodes = N_elements + 1\n    num_unknowns = num_nodes - 2\n    nodes = np.linspace(0.0, 1.0, num_nodes)\n\n    # Assemble stiffness matrix A (tridiagonal)\n    A = np.zeros((num_unknowns, num_unknowns))\n    diag = 2.0 / h\n    off_diag = -1.0 / h\n    np.fill_diagonal(A, diag)\n    if num_unknowns > 1:\n        np.fill_diagonal(A[1:], off_diag)\n        np.fill_diagonal(A[:, 1:], off_diag)\n\n    # Assemble load vector b using 2-point Gaussian quadrature\n    b = np.zeros(num_unknowns)\n    # Gauss points and weights for reference interval [0, 1]\n    gauss_pts = 0.5 * (1.0 + np.array([-1.0, 1.0]) / np.sqrt(3.0))\n    gauss_wts = np.array([0.5, 0.5])\n    \n    basis_vals = np.array([1.0 - gauss_pts, gauss_pts]) # Shape (2, 2): [phi_i(xi_k)]\n\n    for i in range(N_elements):\n        x_i, x_i1 = nodes[i], nodes[i+1]\n        \n        # Quadrature points in physical element\n        quad_pts_phys = x_i + h * gauss_pts\n        f_vals = rhs_func(quad_pts_phys)\n\n        # Contribution to local load vector [b_i, b_{i+1}]\n        local_b = h * np.sum(gauss_wts * f_vals * basis_vals, axis=1)\n\n        if i > 0:\n            b[i - 1] += local_b[0]\n        if i < N_elements - 1:\n            b[i] += local_b[1]\n\n    # Solve linear system Au = b\n    if num_unknowns > 0:\n        u_internal = np.linalg.solve(A, b)\n    else:\n        u_internal = np.array([])\n        \n    # Combine with boundary values\n    coeffs = np.concatenate(([0.0], u_internal, [0.0]))\n    return coeffs, nodes\n\ndef calculate_J(solution, g_func):\n    \"\"\"Computes J(u) = integral(g(x) * u(x) dx).\"\"\"\n    u_coeffs, u_nodes = solution\n    N_elements = len(u_nodes) - 1\n    total_integral = 0.0\n\n    gauss_pts = 0.5 * (1.0 + np.array([-1.0, 1.0]) / np.sqrt(3.0))\n    gauss_wts = np.array([0.5, 0.5])\n    basis_vals = np.array([1.0 - gauss_pts, gauss_pts])\n\n    for i in range(N_elements):\n        h = u_nodes[i+1] - u_nodes[i]\n        local_u_coeffs = u_coeffs[i:i+2]\n        \n        quad_pts_phys = u_nodes[i] + h * gauss_pts\n        g_vals = g_func(quad_pts_phys)\n        u_vals_at_quad = local_u_coeffs @ basis_vals\n\n        elem_integral = h * np.sum(gauss_wts * g_vals * u_vals_at_quad)\n        total_integral += elem_integral\n        \n    return total_integral\n\ndef calculate_residual(u_sol, z_fine_sol, f_func):\n    \"\"\"Computes eta = R(u)(z_fine - I(z_fine)).\"\"\"\n    u_coeffs, u_nodes = u_sol\n    z_coeffs_fine, z_nodes_fine = z_fine_sol\n    \n    N_coarse = len(u_nodes) - 1\n    N_fine = len(z_nodes_fine) - 1\n\n    # Nodal interpolant of z_fine onto coarse mesh\n    Iz_coeffs = z_coeffs_fine[::(N_fine // N_coarse)]\n\n    # 1. Compute a(u, z_fine - Iz)\n    a_term = 0.0\n    h_coarse = 1.0 / N_coarse\n    h_fine = 1.0 / N_fine\n\n    for i in range(N_coarse):\n        u_deriv = (u_coeffs[i+1] - u_coeffs[i]) / h_coarse\n        Iz_deriv_coarse = (Iz_coeffs[i+1] - Iz_coeffs[i]) / h_coarse\n        \n        # Loop over the sub-elements of the coarse element\n        for j_sub in range(N_fine // N_coarse):\n            j_fine = i * (N_fine // N_coarse) + j_sub\n            z_deriv_fine = (z_coeffs_fine[j_fine+1] - z_coeffs_fine[j_fine]) / h_fine\n            h_deriv = z_deriv_fine - Iz_deriv_coarse\n            a_term += u_deriv * h_deriv * h_fine\n\n    # 2. Compute l(z_fine - Iz) = integral(f * (z_fine - Iz))\n    l_term = 0.0\n    gauss_pts = 0.5 * (1.0 + np.array([-1.0, 1.0]) / np.sqrt(3.0))\n    gauss_wts = np.array([0.5, 0.5])\n    basis_vals_fine = np.array([1.0 - gauss_pts, gauss_pts])\n\n    for j in range(N_fine):\n        # Fine element info\n        h_fine = z_nodes_fine[j+1] - z_nodes_fine[j]\n        local_z_coeffs = z_coeffs_fine[j:j+2]\n        \n        # Corresponding coarse element info\n        i_coarse = j // (N_fine // N_coarse)\n        h_coarse = u_nodes[i_coarse+1] - u_nodes[i_coarse]\n        local_Iz_coeffs = Iz_coeffs[i_coarse:i_coarse+2]\n\n        # Quadrature points\n        quad_pts_phys = z_nodes_fine[j] + h_fine * gauss_pts\n        f_vals = f_func(quad_pts_phys)\n        \n        # Evaluate z_fine at quad points\n        z_vals_at_quad = local_z_coeffs @ basis_vals_fine\n        \n        # Evaluate Iz at quad points\n        xi_coarse = (quad_pts_phys - u_nodes[i_coarse]) / h_coarse\n        basis_vals_coarse_at_quad = np.array([1.0 - xi_coarse, xi_coarse])\n        Iz_vals_at_quad = local_Iz_coeffs @ basis_vals_coarse_at_quad\n\n        h_vals_at_quad = z_vals_at_quad - Iz_vals_at_quad\n        elem_integral = h_fine * np.sum(gauss_wts * f_vals * h_vals_at_quad)\n        l_term += elem_integral\n\n    return l_term - a_term\n\ndef run_certification(f_func, g_func, N, q, L, U):\n    \"\"\"\n    Performs the full DWR certification procedure for one case.\n    \"\"\"\n    # 1. Solve for all required discrete solutions\n    u_h = solve_bvp(N, f_func)\n    u_h2 = solve_bvp(2 * N, f_func)\n    z_h2 = solve_bvp(2 * N, g_func)\n    z_h4 = solve_bvp(4 * N, g_func)\n\n    # 2. Compute goal functional values\n    J_uh = calculate_J(u_h, g_func)\n    J_uh2 = calculate_J(u_h2, g_func)\n\n    # 3. Compute DWR error estimators\n    eta_h = calculate_residual(u_h, z_h2, f_func)\n    eta_h2 = calculate_residual(u_h2, z_h4, f_func)\n\n    # 4. Compute bounds\n    delta = (J_uh2 - J_uh) - (eta_h - eta_h2)\n    e_bound = (q / (1.0 - q)) * np.abs(delta)\n\n    # Improved goal value from the fine mesh\n    J_improved = J_uh2 + eta_h2\n    \n    J_lower = J_improved - e_bound\n    J_upper = J_improved + e_bound\n\n    # 5. Certify\n    is_certified = (J_lower >= L) and (J_upper <= U)\n    return is_certified\n    \ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    # Definition of test cases\n    def f_A(x): return np.ones_like(x) if isinstance(x, np.ndarray) else 1.0\n    def g_A(x): return x * (1.0 - x)\n    def f_C(x): return np.pi**2 * np.sin(np.pi * x)\n    def g_C(x): return np.sin(np.pi * x)\n\n    test_cases = [\n        {'f': f_A, 'g': g_A, 'N': 16, 'q': 0.5, 'L': 0.03, 'U': 0.06},\n        {'f': f_A, 'g': g_A, 'N': 16, 'q': 0.9, 'L': 0.03, 'U': 0.06},\n        {'f': f_C, 'g': g_C, 'N': 24, 'q': 0.5, 'L': 0.3, 'U': 0.7},\n        {'f': f_C, 'g': g_A, 'N': 24, 'q': 0.5, 'L': 0.0, 'U': 0.01},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_certification(case['f'], case['g'], case['N'], case['q'], case['L'], case['U'])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}