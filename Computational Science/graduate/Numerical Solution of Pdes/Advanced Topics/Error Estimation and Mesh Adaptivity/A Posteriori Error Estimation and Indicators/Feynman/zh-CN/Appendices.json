{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的检验方式就是亲自动手计算。此实践旨在为椭圆问题的后验误差估计奠定坚实的基础。其核心科学原理在于，有限元解的误差与将近似解代入偏微分方程后所“剩余”的部分（即残差）密切相关。这个残差可以分解为两部分：一部分存在于单元内部，另一部分则体现在单元边界上不连续的通量（即“跳跃”）。通过为一个简单的泊松方程问题  推导和计算这些基本分量——单元残差和边界跳跃残差，您将为后验误差估计的来源及其如何量化局部误差建立起坚实的直觉。",
            "id": "3359755",
            "problem": "考虑单位正方形区域 $\\Omega = (0,1)^2$ 上的模型椭圆偏微分方程 (PDE) $-\\Delta u = f$，其边界 $\\partial \\Omega$ 上具有齐次狄利克雷边界条件 $u=0$。设 $\\mathcal{T}_h$ 是 $\\Omega$ 的一个协调三角剖分，它由沿对角线从 $(0,0)$ 到 $(1,1)$ 分割正方形得到的两个三角形组成：\n- $K_1 = \\operatorname{conv}\\{(0,0),(1,0),(1,1)\\}$,\n- $K_2 = \\operatorname{conv}\\{(0,0),(1,1),(0,1)\\}$.\n内部边（面）为 $F = \\operatorname{conv}\\{(0,0),(1,1)\\}$。\n\n设 $u_h \\in V_h$ 是一个协调 $\\mathbb{P}_1$（分片线性）有限元函数，由节点值\n$u_h(0,0)=0$，$u_h(1,0)=1$，$u_h(1,1)=2$，$u_h(0,1)=0.7$ 确定，并且设在 $\\Omega$ 中 $f \\equiv 1$。假设对称扩散张量为单位矩阵，因此算子为 $-\\Delta$。对于每个单元 $K \\in \\mathcal{T}_h$，用 $h_K$ 表示其直径（$K$ 的任意两个顶点之间的最大距离），对于每条边 $F$，用 $h_F$ 表示其长度。对于任意子区域 $D \\subset \\mathbb{R}^2$，将 $L^2$ 范数写作 $\\|g\\|_{0,D}^2 = \\int_D |g|^2$。\n\n从弱形式和 Green 恒等式出发，为单元指标 $\\eta_K$ 和内部边指标 $\\eta_F$ 推导出仅依赖于局部积分和已知的片常数梯度 $\\nabla u_h|_K$ 的显式残差公式。然后，使用这些公式：\n- 在单元 $K_1$ 上计算 $\\eta_{K_1}$，其中 $h_{K_1}$ 选为其直径，\n- 在内部边 $F$ 上计算 $\\eta_F$，其中 $h_F$ 选为边长，\n并通过下式定义 $K_1$ 的组合局部指标：\n$$\n\\Theta(K_1) = \\sqrt{\\eta_{K_1}^{2} + \\frac{1}{2}\\,\\eta_{F}^{2}}.\n$$\n\n将 $\\Theta(K_1)$ 的最终值表示为单一的简化解析表达式。不需要进行数值舍入，也不涉及物理单位。",
            "solution": "该问题要求针对泊松问题 $-\\Delta u = f$，在单位正方形 $\\Omega = (0,1)^2$ 的一个特定三角剖分上，为一个给定的分片线性函数 $u_h$ 计算局部后验误差指标。\n\n首先，我们必须推导基于残差的误差指标公式。出发点是问题的弱形式：求 $u \\in H_0^1(\\Omega)$，使得对于所有测试函数 $v \\in H_0^1(\\Omega)$，\n$$\n\\int_\\Omega \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = \\int_\\Omega f v \\, d\\mathbf{x}.\n$$\n令 $e = u - u_h$ 为误差，其中 $u_h \\in V_h$ 是给定的有限元函数。对于任意 $v \\in H_0^1(\\Omega)$，误差方程为\n$$\n\\int_\\Omega \\nabla e \\cdot \\nabla v \\, d\\mathbf{x} = \\int_\\Omega f v \\, d\\mathbf{x} - \\int_\\Omega \\nabla u_h \\cdot \\nabla v \\, d\\mathbf{x}.\n$$\n我们对包含 $u_h$ 的项逐单元应用分部积分（Green 恒等式）：\n$$\n\\int_\\Omega \\nabla u_h \\cdot \\nabla v \\, d\\mathbf{x} = \\sum_{K \\in \\mathcal{T}_h} \\int_K \\nabla u_h \\cdot \\nabla v \\, d\\mathbf{x} = \\sum_{K \\in \\mathcal{T}_h} \\left( \\int_K (-\\Delta u_h) v \\, d\\mathbf{x} + \\int_{\\partial K} (\\nabla u_h \\cdot \\mathbf{n}_K) v \\, ds \\right),\n$$\n其中 $\\mathbf{n}_K$ 是单元 $K$ 边界 $\\partial K$ 上的外向单位法向量。将此代入误差方程可得：\n$$\n\\int_\\Omega \\nabla e \\cdot \\nabla v \\, d\\mathbf{x} = \\sum_{K \\in \\mathcal{T}_h} \\int_K (f + \\Delta u_h) v \\, d\\mathbf{x} - \\sum_{K \\in \\mathcal{T}_h} \\int_{\\partial K} (\\nabla u_h \\cdot \\mathbf{n}_K) v \\, ds.\n$$\n对单元边界的求和可以重组为对三角剖分的所有边（或面）$\\mathcal{F}_h$ 的求和。对于两个单元 $K_1$ 和 $K_2$ 共享的内部边 $F$，其贡献为 $\\int_F (\\nabla u_h|_{K_1} \\cdot \\mathbf{n}_1 + \\nabla u_h|_{K_2} \\cdot \\mathbf{n}_2) v \\, ds$。括号中的项定义为穿过 $F$ 的法向通量跳跃，记作 $\\llbracket \\nabla u_h \\cdot \\mathbf{n} \\rrbracket_F$。由于在 $\\partial\\Omega$ 上 $v=0$，边界边上的项消失。误差方程变为：\n$$\n\\int_\\Omega \\nabla e \\cdot \\nabla v \\, d\\mathbf{x} = \\sum_{K \\in \\mathcal{T}_h} \\int_K (f + \\Delta u_h) v \\, d\\mathbf{x} - \\sum_{F \\in \\mathcal{F}_h^i} \\int_F \\llbracket \\nabla u_h \\cdot \\mathbf{n} \\rrbracket_F v \\, ds,\n$$\n其中 $\\mathcal{F}_h^i$ 是内部边集。后验误差分析通过一个量（误差估计量）来界定误差范数 $\\| \\nabla e \\|_{0,\\Omega}$，该估计量依赖于单元残差 $R_K = f + \\Delta u_h$ 和边跳跃残差 $J_F = \\llbracket \\nabla u_h \\cdot \\mathbf{n} \\rrbracket_F$。\n\n我们在此采用的局部误差指标的标准定义是：\n- 单元 $K$ 的单元指标：$\\eta_K = h_K \\| R_K \\|_{0,K} = h_K \\| f + \\Delta u_h \\|_{0,K}$。\n- 内部边 $F$ 的边指标：$\\eta_F = h_F^{1/2} \\| J_F \\|_{0,F} = h_F^{1/2} \\| \\llbracket \\nabla u_h \\cdot \\mathbf{n} \\rrbracket \\|_{0,F}$。\n\n问题提供了一个协调的 $\\mathbb{P}_1$ 有限元函数 $u_h$，它是分片线性的。因此，其拉普拉斯算子 $\\Delta u_h$ 在每个单元 $K$ 的内部为零。公式简化为：\n- $\\eta_K = h_K \\| f \\|_{0,K}$。\n- $\\eta_F = h_F^{1/2} \\| \\llbracket \\nabla u_h \\cdot \\mathbf{n} \\rrbracket \\|_{0,F}$。\n\n现在我们为给定的设置计算这些量。\n三角剖分由两个三角形组成：\n- $K_1 = \\operatorname{conv}\\{(0,0),(1,0),(1,1)\\}$，一个面积为 $|K_1| = 1/2$ 的直角三角形。\n- $K_2 = \\operatorname{conv}\\{(0,0),(1,1),(0,1)\\}$，一个面积为 $|K_2| = 1/2$ 的直角三角形。\n内部边为 $F = \\operatorname{conv}\\{(0,0),(1,1)\\}$。\n\n函数 $u_h$ 在每个单元上是线性的。\n在 $K_1$ 上，$u_h(x,y) = a_1 x + b_1 y + c_1$。使用节点值 $u_h(0,0)=0$，$u_h(1,0)=1$，$u_h(1,1)=2$：\n- $u_h(0,0) = c_1 = 0$。\n- $u_h(1,0) = a_1 = 1$。\n- $u_h(1,1) = a_1 + b_1 = 2 \\implies 1 + b_1 = 2 \\implies b_1 = 1$。\n所以，$u_h|_{K_1}(x,y) = x+y$。在 $K_1$ 上的梯度是常数：$\\nabla u_h|_{K_1} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$。\n\n在 $K_2$ 上，$u_h(x,y) = a_2 x + b_2 y + c_2$。使用节点值 $u_h(0,0)=0$，$u_h(0,1)=0.7$，$u_h(1,1)=2$：\n- $u_h(0,0) = c_2 = 0$。\n- $u_h(0,1) = b_2 = 0.7$。\n- $u_h(1,1) = a_2 + b_2 = 2 \\implies a_2 + 0.7 = 2 \\implies a_2 = 1.3$。\n所以，$u_h|_{K_2}(x,y) = 1.3x + 0.7y$。在 $K_2$ 上的梯度是常数：$\\nabla u_h|_{K_2} = \\begin{pmatrix} 1.3 \\\\ 0.7 \\end{pmatrix}$。\n\n接下来，我们计算指标 $\\eta_{K_1}$ 和 $\\eta_F$。\n\n**$\\eta_{K_1}$ 的计算**：\n- $K_1$ 的直径 $h_{K_1}$ 是其最长边的长度。边长分别为 $1$，$1$ 和 $\\sqrt{(1-0)^2 + (1-0)^2} = \\sqrt{2}$。因此，$h_{K_1} = \\sqrt{2}$。\n- 源函数为 $f \\equiv 1$。\n- $\\|f\\|_{0,K_1}^2 = \\int_{K_1} f^2 d\\mathbf{x} = \\int_{K_1} 1^2 d\\mathbf{x} = |K_1| = \\frac{1}{2}$。\n- $\\|f\\|_{0,K_1} = \\sqrt{1/2} = 1/\\sqrt{2}$。\n- $\\eta_{K_1} = h_{K_1} \\|f\\|_{0,K_1} = \\sqrt{2} \\cdot \\frac{1}{\\sqrt{2}} = 1$。\n\n**$\\eta_F$ 的计算**：\n- 边 $F$ 是从 $(0,0)$ 到 $(1,1)$ 的线段。其长度为 $h_F = \\sqrt{1^2+1^2} = \\sqrt{2}$。\n- 穿过 $F$ 的法向通量跳跃为 $J_F = \\llbracket \\nabla u_h \\cdot \\mathbf{n} \\rrbracket = (\\nabla u_h|_{K_1} - \\nabla u_h|_{K_2}) \\cdot \\mathbf{n}$，其中 $\\mathbf{n}$ 是 $F$ 上的单位法向量。我们选择从 $K_1$ 指向 $K_2$ 的法向量。边 $F$ 位于直线 $y=x$ 上。$K_1$ 在区域 $y \\le x$ 中，$K_2$ 在区域 $y \\ge x$ 中。从 $K_1$ 到 $K_2$ 的法向量为 $\\mathbf{n} = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix}$。\n- 梯度之差为 $\\nabla u_h|_{K_1} - \\nabla u_h|_{K_2} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} - \\begin{pmatrix} 1.3 \\\\ 0.7 \\end{pmatrix} = \\begin{pmatrix} -0.3 \\\\ 0.3 \\end{pmatrix}$。\n- 跳跃 $J_F$ 沿着 $F$ 是一个常数：\n$J_F = \\begin{pmatrix} -0.3 \\\\ 0.3 \\end{pmatrix} \\cdot \\frac{1}{\\sqrt{2}}\\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\frac{1}{\\sqrt{2}}((-0.3)(-1) + (0.3)(1)) = \\frac{0.3+0.3}{\\sqrt{2}} = \\frac{0.6}{\\sqrt{2}}$。\n- 现在我们计算 $J_F$ 在边 $F$ 上的 $L^2$ 范数：\n$\\|J_F\\|_{0,F}^2 = \\int_F |J_F|^2 ds = |J_F|^2 \\int_F ds = |J_F|^2 h_F = \\left(\\frac{0.6}{\\sqrt{2}}\\right)^2 \\sqrt{2} = \\frac{0.36}{2}\\sqrt{2} = 0.18\\sqrt{2}$。\n- 指标 $\\eta_F$ 为：\n$\\eta_F^2 = h_F \\|J_F\\|_{0,F}^2 = \\sqrt{2} \\cdot (0.18\\sqrt{2}) = 0.18 \\cdot 2 = 0.36$。\n因此，$\\eta_F = \\sqrt{0.36} = 0.6 = \\frac{3}{5}$。\n\n最后，我们计算 $K_1$ 的组合局部指标：\n$$\n\\Theta(K_1) = \\sqrt{\\eta_{K_1}^{2} + \\frac{1}{2}\\,\\eta_{F}^{2}}.\n$$\n代入计算出的值：\n$$\n\\Theta(K_1) = \\sqrt{1^2 + \\frac{1}{2}(0.6)^2} = \\sqrt{1 + \\frac{1}{2}(0.36)} = \\sqrt{1 + 0.18} = \\sqrt{1.18}.\n$$\n为了将其表示为简化的解析表达式，我们使用分数：\n$$\n\\Theta(K_1) = \\sqrt{\\frac{118}{100}} = \\frac{\\sqrt{118}}{\\sqrt{100}} = \\frac{\\sqrt{118}}{10}.\n$$\n数字 $118$ 分解为 $2 \\times 59$，因此平方根无法进一步简化。",
            "answer": "$$\n\\boxed{\\frac{\\sqrt{118}}{10}}\n$$"
        },
        {
            "introduction": "在解决了线性问题后，我们将注意力转向更常见也更复杂的非线性问题，这通常需要像牛顿法这样的迭代求解器。在求解非线性偏微分方程的自适应方法中，我们面临两个主要的误差来源：由网格剖分引起的离散误差，以及由代数迭代求解器未完全收敛引起的线性化误差。一个高效的算法必须在这两种误差之间取得平衡，避免在粗糙的网格上进行不必要的精确代数求解（即“过求解”）。这个练习  将挑战您的算法思维，通过分析牛顿法的不同停止准则，您将学习如何运用后验误差估计量不仅指导网格加密，还用以控制代数求解器，从而实现一个更高效、更均衡的整体自适应策略。",
            "id": "3359724",
            "problem": "考虑一个强单调、利普希茨（Lipschitz）非线性椭圆边值问题：在变分意义下，求 $u \\in V$ 使得 $A(u)=f$。其中，$V$ 是一个连续嵌入到 $H^{1}_{0}(\\Omega)$ 的希尔伯特空间（Hilbert space），$A:V \\to V'$ 是一个非线性算子，其 Gâteaux 导数为 $A'(w)$，且存在常数 $0  \\alpha \\le L  \\infty$ 使得对于所有 $w,v \\in V$，满足强单调性和利普希茨连续性条件\n$$\\langle A(w)-A(v), w-v \\rangle \\ge \\alpha \\|w-v\\|_{E}^{2}, \\qquad \\|A(w)-A(v)\\|_{V'} \\le L \\|w-v\\|_{E},$$\n其中 $\\|\\cdot\\|_{E}$ 是与 $H^{1}_{0}(\\Omega)$ 范数等价的能量范数，$\\langle \\cdot,\\cdot \\rangle$ 是 $V' \\times V$ 上的对偶配对。设 $V_{h} \\subset V$ 是有限元方法（Finite Element Method, FEM）意义下的一个协调有限元空间，并设 $u_{h}^{\\star} \\in V_{h}$ 表示满足离散残差方程 $F_{h}(u_{h}^{\\star})=0$ 的精确离散解，其中 $F_{h}(w_{h}) \\in V_{h}'$ 由 $F_{h}(w_{h})[v_{h}] := \\langle A(w_{h}), v_{h} \\rangle - \\langle f, v_{h} \\rangle$ 对所有 $v_{h} \\in V_{h}$ 定义。假设有一个残差型后验误差估计子 $\\eta_{h}(w_{h}) \\ge 0$ 可用，使得对于某个网格无关的可靠性常数 $C_{\\mathrm{rel}} \\ge 1$ 以及所有足够接近 $u_{h}^{\\star}$ 的 $w_{h} \\in V_{h}$，有\n$$\\|u - u_{h}^{\\star}\\|_{E} \\le C_{\\mathrm{rel}} \\,\\eta_{h}(u_{h}^{\\star}) \\approx C_{\\mathrm{rel}} \\,\\eta_{h}(w_{h}),$$\n其中近似表示估计子在接近 $u_{h}^{\\star}$ 的迭代点处具有稳定性。假设使用牛顿法（Newton’s method）求解该离散非线性系统：给定 $u_{h}^{k} \\in V_{h}$，求 $\\delta u_{h}^{k} \\in V_{h}$ 解\n$$\\langle A'(u_{h}^{k}) \\,\\delta u_{h}^{k}, v_{h} \\rangle = - F_{h}(u_{h}^{k})[v_{h}] \\quad \\text{对所有 } v_{h} \\in V_{h}, \\qquad u_{h}^{k+1} := u_{h}^{k} + \\delta u_{h}^{k}.$$\n设线性化误差为 $e_{\\mathrm{lin}}^{k} := u_{h}^{\\star} - u_{h}^{k}$，离散化误差为 $e_{\\mathrm{disc}} := u - u_{h}^{\\star}$。一个实际的目标是，在每个网格上，当线性化误差与由 $\\eta_{h}$ 指示的离散化误差相平衡时，停止牛顿迭代，这样在进行网格加密之前，进一步的非线性迭代将不具成本效益。\n\n对于一个独立于 $h$ 和 $k$ 的固定参数 $0  \\theta  1$，以下哪些停止准则是实现这种平衡的合适的实用法则？\n\nA. 在第一个满足 $\\|\\delta u_{h}^{k}\\|_{E} \\le \\theta \\,\\eta_{h}(u_{h}^{k})$ 的 $k$ 处停止。\n\nB. 在第一个满足 $\\|F_{h}(u_{h}^{k})\\|_{V_{h}'} \\le \\theta \\,\\eta_{h}(u_{h}^{k})$ 的 $k$ 处停止。\n\nC. 在第一个满足 $\\|\\delta u_{h}^{k}\\|_{E} \\le \\theta \\,\\eta_{h}(u_{h}^{k})^{2}$ 的 $k$ 处停止。\n\nD. 在第一个满足 $\\|F_{h}(u_{h}^{k})\\|_{V_{h}'} \\le \\theta \\,\\|F_{h}(u_{h}^{k-1})\\|_{V_{h}'}$ 的 $k$ 处停止。\n\nE. 在第一个满足 $\\eta_{h}(u_{h}^{k}) \\le \\theta \\,\\|\\delta u_{h}^{k}\\|_{E}$ 的 $k$ 处停止。",
            "solution": "该问题旨在为求解非线性有限元问题的牛顿法确定一个合适的停止准则，其目标是平衡线性化误差与离散化误差。\n\n### 分析\n目标是在迭代求解（例如，牛顿法）非线性离散问题时，设计一个实用的停止准则。核心思想是，当由不精确的代数求解所引入的误差（线性化误差）与由网格离散化本身所固有的误差（离散化误差）相比变得足够小时，就应该停止迭代。继续迭代以减小线性化误差是没有意义的，因为总误差将由离散化误差主导。\n\n我们将误差分量定义如下：\n- **总误差**: $u - u_h^k$\n- **离散化误差**: $e_{\\text{disc}} = u - u_h^\\star$，其中 $u_h^\\star$ 是精确的离散解。\n- **线性化误差**: $e_{\\text{lin}}^k = u_h^\\star - u_h^k$，其中 $u_h^k$ 是第 $k$ 次迭代的代数近似解。\n\n通过三角不等式，我们有 $\\|u - u_h^k\\|_E \\le \\|u - u_h^\\star\\|_E + \\|u_h^\\star - u_h^k\\|_E = \\|e_{\\text{disc}}\\|_E + \\|e_{\\text{lin}}^k\\|_E$。\n平衡这两部分误差的策略是，当线性化误差是离散化误差的一个小部分时停止，即：\n$$ \\|e_{\\text{lin}}^k\\|_E \\le \\theta \\|e_{\\text{disc}}\\|_E $$\n其中 $0  \\theta  1$ 是一个用户定义的参数。\n\n然而，这两个误差项都无法直接计算。我们需要使用可计算的量来估计它们：\n1.  **估计离散化误差**: 问题假设我们有一个可靠且有效的后验误差估计子 $\\eta_h(u_h^k)$，它近似于 $\\|e_{\\text{disc}}\\|_E$。因此，我们可以用 $\\eta_h(u_h^k)$ 作为 $\\|e_{\\text{disc}}\\|_E$ 的代理。\n2.  **估计线性化误差**: 我们需要一个 $\\|e_{\\text{lin}}^k\\|_E$ 的可计算代理。\n    -   在牛顿法的收敛域内，可以证明第 $k$ 次迭代的更新量 $\\|\\delta u_h^k\\|_E$ 是线性化误差 $\\|e_{\\text{lin}}^k\\|_E$ 的一个良好且计算简便的估计。\n    -   另外，非线性残差的范数 $\\|F_h(u_h^k)\\|_{V_h'}$ 与线性化误差是范数等价的（即 $\\|e_{\\text{lin}}^k\\|_E \\approx C \\|F_h(u_h^k)\\|_{V_h'}$），因此它也可以作为代理，尽管其计算可能更昂贵。\n\n基于以上分析，我们的实用停止准则应具有以下形式：\n$$ (\\text{线性化误差的代理}) \\le \\theta \\cdot (\\text{离散化误差的代理}) $$\n\n### 评估选项\n\n- **A. 在第一个满足 $\\|\\delta u_{h}^{k}\\|_{E} \\le \\theta \\,\\eta_{h}(u_{h}^{k})$ 的 $k$ 处停止。**\n  此准则将线性化误差的代理（牛顿更新量 $\\|\\delta u_h^k\\|_E$）与离散化误差的代理（后验估计子 $\\eta_h(u_h^k)$）进行比较。这精确地实现了我们所期望的平衡策略。这是在自适应有限元实践中广泛使用的标准准则。因此，该选项是正确的。\n\n- **B. 在第一个满足 $\\|F_{h}(u_{h}^{k})\\|_{V_{h}'} \\le \\theta \\,\\eta_{h}(u_{h}^{k})$ 的 $k$ 处停止。**\n  此准则使用非线性残差的范数作为线性化误差的代理。如上所述，这也是一个有效的代理。因此，该准则在理论上也是正确的，它同样实现了误差分量之间的平衡。\n\n- **C. 在第一个满足 $\\|\\delta u_{h}^{k}\\|_{E} \\le \\theta \\,\\eta_{h}(u_{h}^{k})^{2}$ 的 $k$ 处停止。**\n  此准则要求线性化误差相对于离散化误差的平方要小。这是一种过度求解（over-solving）策略，它会强制牛顿法进行不必要的迭代，直到线性化误差变得可以忽略不计。这在计算上是低效的，违背了平衡误差的原则。因此，该选项不正确。\n\n- **D. 在第一个满足 $\\|F_{h}(u_{h}^{k})\\|_{V_{h}'} \\le \\theta \\,\\|F_{h}(u_{h}^{k-1})\\|_{V_{h}'}$ 的 $k$ 处停止。**\n  这是一个标准的相对残差减小准则，用于检查任何迭代求解器的收敛性。然而，它只关注求解器自身的进展，而没有将线性化误差与离散化误差联系起来。它完全忽略了误差估计子 $\\eta_h$，因此未能实现所要求的平衡。因此，该选项不正确。\n\n- **E. 在第一个满足 $\\eta_{h}(u_{h}^{k}) \\le \\theta \\,\\|\\delta u_{h}^{k}\\|_{E}$ 的 $k$ 处停止。**\n  此准则要求当离散化误差的估计值小于线性化误差的估计值时停止。这与我们的目标恰恰相反。它会导致迭代过早终止，此时线性化误差仍然是总误差的主导部分。因此，该选项不正确。\n\n结论：选项 A 和 B 都是实现线性化误差与离散化误差之间平衡的合适准则。",
            "answer": "$$\n\\boxed{AB}\n$$"
        },
        {
            "introduction": "现在，我们将迎接一个真正复杂的挑战：Allen-Cahn 方程。该方程用于模拟相分离过程，其解包含宽度为 $\\varepsilon$ 的极薄界面层。对于这类问题，标准的后验误差估计量可能效果不佳。其背后的科学原理是，对于复杂的物理问题，有效的误差指示子必须经过精心设计，以捕捉驱动解行为的关键物理特征。对于 Allen-Cahn 方程而言，这意味着估计量必须对界面宽度 $\\varepsilon$、界面的局部曲率以及网格是否足够精细以解析该界面等因素保持敏感。这项编程练习  代表了后验误差估计领域的前沿实践，它要求您超越通用公式，实现一个为特定物理“量身定制”的、复杂的多分量指示子。这项实践将向您展示如何构建能够为解析复杂多尺度现象提供有意义指导的误差估计量。",
            "id": "3359770",
            "problem": "为稳态 Allen–Cahn 算子构建一个后验误差指示子，该指示子能随弥散界面宽度正确缩放，捕捉曲率驱动的界面误差，并强制执行界面分辨率准则。考虑一维（空间维度为 $1$）的 Allen–Cahn 偏微分方程 (PDE)：\n$$u_t = \\varepsilon^2 u_{xx} - f(u), \\quad f(u) = u^3 - u,$$ \n在域 $[-L,L]$ 上，其中 $L0$ 且界面宽度参数 $\\varepsilon \\in (0,1)$。其稳态方程为\n$$\\varepsilon^2 u_{xx} - f(u) = 0.$$\n一个经典的稳态前缘剖面是\n$$u(x) = \\tanh\\!\\left(\\frac{x}{\\sqrt{2}\\,\\varepsilon}\\right),$$ \n其过渡层的厚度量级为 $\\mathcal{O}(\\varepsilon)$。\n\n你将使用函数 $u_h$，它是一个协调、连续的分片线性有限元函数（也可解释为在均匀网格上的分片线性节点插值），通过在 $[-L,L]$ 上具有 $N$ 个单元的均匀网格上对精确剖面进行节点插值得到。令 $h = 2L/N$ 表示单元尺寸。你的任务是推导并实现每个单元 $K$ 上的可计算残差型后验误差指示子 $\\eta_K$，以及一个全局估计子 $\\mathcal{E}$，它们需满足以下所有条件：\n\n- 它们仅由从 $u_h$ 可获取的量构建（在估计子计算过程中，除了用于定义 $u_h$ 的节点值外，不依赖于精确解 $u$ 的任何信息）。\n- 它们随 $\\varepsilon$ 正确缩放，以反映界面附近扩散与反应之间的平衡。\n- 它们包含一个曲率驱动的代理项，该项反映了界面运动和几何误差随曲率缩放的事实，并且在锐利界面极限下，Allen–Cahn 动力学已知是曲率驱动的。\n- 它们包含一个界面分辨率指示子，当 $h$ 相对于 $\\varepsilon$ 和局部梯度幅值不够小时，该指示子会对分辨率不足进行惩罚。\n\n从稳态算子\n$$\\mathcal{L}(u) := \\varepsilon^2 u_{xx} - f(u),$$ \n的变分结构，以及针对带非线性的反应-扩散算子的标准基于残差的后验估计出发，推导、论证并实现以下在 $[-L,L]$ 均匀网格上的可计算单元量：\n\n1. 一个单元残差贡献项 $I_{1,K}$，其灵感来自于强残差 $R_K(x) := \\mathcal{L}(u_h)|_K(x)$ 和局部气泡函数稳定性界。在每个单元内部，对于分片线性的 $u_h$，有 $u_h'' \\equiv 0$ 且 $R_K(x) = - f(u_h(x))$。使用基于求积的近似来计算\n$$I_{1,K} := h_K \\,\\Big\\|\\; f(u_h)\\;\\Big\\|_{L^2(K)} \\approx h_K \\,\\sqrt{\\frac{1}{h_K}\\int_K \\big(f(u_h(x))\\big)^2 \\,dx}.$$\n\n2. 一个边跳跃贡献项 $I_{2,K}$，它将内部节点通量跳跃\n$$J_i := \\varepsilon\\,\\big|\\,\\llbracket u_h'\\rrbracket(x_i)\\,\\big|,$$ \n分配到两个相邻单元，其中 $\\llbracket u_h'\\rrbracket(x_i)$ 是导数跨内部节点 $x_i$ 的跳跃。对于均匀网格和分片线性的 $u_h$，单元斜率是常数，跳跃由相邻斜率计算。将每个 $J_i$ 平均分配给其左右相邻的单元，以便每个单元（如果是内部单元）从其两个端点各累积一半。\n\n3. 一个界面分辨率贡献项 $I_{3,K}$，当局部无量纲比率\n$$\\rho_K := \\frac{h_K \\,\\max_{x\\in K}|u_h'(x)|}{\\varepsilon}$$ \n超过阈值 $\\rho_0$ 时，该项对分辨率不足进行惩罚。使用\n$$I_{3,K} := \\max\\!\\big(0, \\rho_K - \\rho_0\\big),$$ \n并设定固定阈值 $\\rho_0 = 0.5$。\n\n4. 一个曲率代理贡献项 $I_{4,K}$，其灵感来自于曲率驱动的界面运动以及将界面几何误差与 $\\varepsilon\\,\\kappa$（其中 $\\kappa$ 是曲率）联系起来的匹配渐近缩放。在一维中，水平集曲率代理可近似为\n$$\\kappa(x_i) \\approx \\frac{|u_{xx}(x_i)|}{|u_x(x_i)| + \\delta},$$ \n其中 $\\delta0$ 是一个小数，用于避免除以零；在节点处使用 $u_h$ 节点值的中心有限差分来近似 $u_{xx}$ 和 $u_x$。定义单元贡献为\n$$I_{4,K} := \\varepsilon\\, h_K \\,\\max_{x_i \\in \\partial K} \\kappa(x_i).$$\n\n将以上各项组合成单个单元指示子\n$$\\eta_K := \\sqrt{ I_{1,K}^2 + I_{2,K}^2 + I_{4,K}^2 } \\;+\\; I_{3,K},$$ \n并定义全局估计子\n$$\\mathcal{E} := \\Big(\\sum_{K} \\eta_K^2 \\Big)^{1/2}.$$\n\n为精确前缘\n$$u(x) = \\tanh\\!\\left(\\frac{x}{\\sqrt{2}\\,\\varepsilon}\\right)$$ \n在 $[-L,L]$（其中 $L=1$）上具有 $N$ 个单元的均匀网格上的插值函数 $u_h$ 实现上述指示子。使用两点 Gaussian 求积来近似 $I_{1,K}$ 中的 $L^2$ 项。对节点曲率代理使用中心差分，并按规定分配跳跃项。设置 $\\rho_0 = 0.5$ 并在曲率代理中使用 $\\delta = 10^{-12}$。\n\n你的程序必须对以下每个测试用例（即测试套件）计算 $\\mathcal{E}$：\n\n- A 用例（界面分辨率良好）：$\\varepsilon = 0.05$，$L = 1$，$N = 200$。\n- B 用例（临界分辨率）：$\\varepsilon = 0.05$，$L = 1$，$N = 40$。\n- C 用例（薄界面，临界分辨率）：$\\varepsilon = 0.01$，$L = 1$，$N = 200$。\n- D 用例（分辨率不足）：$\\varepsilon = 0.02$，$L = 1$，$N = 20$。\n\n最终输出格式要求：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的实数列表，每个数字四舍五入到小数点后恰好六位，顺序为 [A 用例, B 用例, C 用例, D 用例]。例如：\n\"[0.123456,0.234567,0.345678,0.456789]\"。不应打印任何额外文本。\n\n在此设置中，所有量都是纯数学的且无量纲；不需要物理单位。不涉及角度。不使用百分比。要求的输出是实数。",
            "solution": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the a posteriori error estimator for the stationary Allen-Cahn\n    equation based on the provided formulas and test parameters.\n    \"\"\"\n\n    test_cases = [\n        # Case A (well-resolved interface)\n        {'eps': 0.05, 'L': 1, 'N': 200},\n        # Case B (marginal resolution)\n        {'eps': 0.05, 'L': 1, 'N': 40},\n        # Case C (thin interface, borderline resolution)\n        {'eps': 0.01, 'L': 1, 'N': 200},\n        # Case D (under-resolved)\n        {'eps': 0.02, 'L': 1, 'N': 20},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_estimator(case['eps'], case['L'], case['N'])\n        results.append(result)\n\n    # Format the final output as a comma-separated list of numbers with 6 decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\ndef compute_estimator(eps, L, N):\n    \"\"\"\n    Computes the global a posteriori error estimator E for a given set of\n    parameters (eps, L, N).\n    \"\"\"\n\n    # --- 1. Setup Mesh and Nodal Solution ---\n    h = 2 * L / N\n    # Node coordinates (N+1 nodes, indexed 0 to N)\n    x_nodes = np.linspace(-L, L, N + 1)\n    \n    # Nodal values of u_h (interpolant of exact solution u(x))\n    u_nodal = np.tanh(x_nodes / (np.sqrt(2) * eps))\n    \n    # --- 2. Pre-compute Quantities for All Elements/Nodes ---\n    \n    # Slopes s_j on each element K_j.\n    # slopes[j] is the slope on element [x_j, x_{j+1}] (i.e., K_{j+1}).\n    slopes = (u_nodal[1:] - u_nodal[:-1]) / h\n    \n    # Curvature surrogate kappa_i at each node x_i.\n    # We use centered differences for interior nodes (i=1 to N-1).\n    delta = 1e-12\n    # Nodal derivatives at interior nodes\n    u_h_deriv_approx = (u_nodal[2:] - u_nodal[:-2]) / (2 * h)\n    u_h_deriv2_approx = (u_nodal[2:] - 2 * u_nodal[1:-1] + u_nodal[:-2]) / (h**2)\n    \n    # Compute kappa for interior nodes\n    kappa_interior = np.abs(u_h_deriv2_approx) / (np.abs(u_h_deriv_approx) + delta)\n    \n    # Full kappa array for all nodes (0 to N). Set to 0 at boundaries.\n    kappa = np.zeros(N + 1)\n    kappa[1:-1] = kappa_interior\n\n    eta_K_squared_list = []\n    \n    # --- 3. Loop over Elements to Compute Local Indicators ---\n    # The loop variable 'j' corresponds to the element [x_j, x_{j+1}], or K_{j+1}.\n    for j in range(N):\n        # Nodal values for the current element\n        u_elem_left, u_elem_right = u_nodal[j], u_nodal[j+1]\n        \n        # --- Component I_1,K (Element Residual) ---\n        # Two-point Gaussian quadrature for the integral of f(u_h)^2.\n        # u_h values at quadrature points based on linear interpolation.\n        sqrt3_inv = 1.0 / np.sqrt(3.0)\n        u_q1 = u_elem_left * 0.5 * (1 + sqrt3_inv) + u_elem_right * 0.5 * (1 - sqrt3_inv)\n        u_q2 = u_elem_left * 0.5 * (1 - sqrt3_inv) + u_elem_right * 0.5 * (1 + sqrt3_inv)\n        \n        f = lambda u: u**3 - u\n        \n        # Quadrature integral approx: (h/2) * (w1*f(u_q1)^2 + w2*f(u_q2)^2) with w1=w2=1\n        integral_approx = (h / 2.0) * (f(u_q1)**2 + f(u_q2)**2)\n        # I_1,K^2 = h * integral\n        I_1_K_squared = h * integral_approx\n\n        # --- Component I_2,K (Edge Jump) ---\n        # The jump J_i at an interior node x_i is distributed to elements K_i and K_{i+1}.\n        # Element j ([x_j, x_{j+1}]) gets contributions from nodes x_j and x_{j+1}.\n        \n        # Contribution from left node x_j (if it's an interior node)\n        J_left_node = 0.0\n        if j > 0:\n            # Jump at x_j involves slopes on element j-1 and j\n            # which are slopes[j-1] and slopes[j]\n            jump_at_x_j = eps * np.abs(slopes[j] - slopes[j-1])\n            J_left_node = jump_at_x_j\n            \n        # Contribution from right node x_{j+1} (if it's an interior node)\n        J_right_node = 0.0\n        if j  N - 1:\n            # Jump at x_{j+1} involves slopes on element j and j+1\n            # which are slopes[j] and slopes[j+1]\n            jump_at_x_j_plus_1 = eps * np.abs(slopes[j+1] - slopes[j])\n            J_right_node = jump_at_x_j_plus_1\n            \n        I_2_K = 0.5 * (J_left_node + J_right_node)\n        I_2_K_squared = I_2_K**2\n        \n        # --- Component I_3,K (Interface Resolution) ---\n        rho_0 = 0.5\n        # Slope on current element j is slopes[j]\n        rho_K = (h * np.abs(slopes[j])) / eps\n        I_3_K = np.maximum(0, rho_K - rho_0)\n        \n        # --- Component I_4,K (Curvature Surrogate) ---\n        # Element j has nodes j and j+1. Check max kappa at these two nodes.\n        kappa_max_on_elem = np.maximum(kappa[j], kappa[j+1])\n        I_4_K = eps * h * kappa_max_on_elem\n        I_4_K_squared = I_4_K**2\n        \n        # --- 4. Combine Components for Element Indicator eta_K ---\n        # Formula: eta_K = sqrt(I_1^2 + I_2^2 + I_4^2) + I_3\n        eta_K = np.sqrt(I_1_K_squared + I_2_K_squared + I_4_K_squared) + I_3_K\n        eta_K_squared_list.append(eta_K**2)\n        \n    # --- 5. Compute Global Estimator E ---\n    E_squared = np.sum(eta_K_squared_list)\n    E = np.sqrt(E_squared)\n    \n    return E\n\n# The main function is not called here, but it defines the logic to be executed.\n# solve()\n```",
            "answer": "$$ \\boxed{\\text{[0.068390,0.597818,0.174781,3.483134]}} $$"
        }
    ]
}