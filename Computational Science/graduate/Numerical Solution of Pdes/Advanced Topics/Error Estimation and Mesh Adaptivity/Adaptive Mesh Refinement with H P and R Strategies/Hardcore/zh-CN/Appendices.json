{
    "hands_on_practices": [
        {
            "introduction": "自适应网格加密的核心在于一个基本问题：在计算资源的约束下，如何最有效地减少误差？这个练习将带你直面这一挑战，通过构建一个成本效益模型，来量化比较 $h$、$p$ 和 $r$ 三种加密策略的优劣。通过对一个给定单元进行操作，你将学习如何基于“单位成本带来的误差减少量”这一关键指标，为具有不同平滑度的函数选择最优的加密方式，从而掌握自适应决策的精髓。",
            "id": "3360869",
            "problem": "构建一个考虑成本的一维空间自适应网格加密决策模型，该模型针对三种加密策略评估每自由度的边际误差减少量：$h$-加密（在固定多项式阶次下对单元进行二等分）、$p$-加密（局部提升多项式阶次）和$r$-加密（局部节点重定位以收缩单元）。在一个区间上，使用连续分片多项式有限元来逼近已知函数$u(x)$，并通过$H^1$半范数下的最佳逼近误差来度量单个单元上的局部离散误差。使用此决策模型，为每个指定的测试用例选择能够最大化单位成本下估计边际误差减少量的单一加密操作。\n\n将您的推导和算法建立在以下基本定义和事实上：\n- 函数$v$在区间$I = [a,b]$上的$H^1$半范数为$\\|v\\|_{H^1(I)} := \\left(\\int_a^b |v'(x)|^2 \\, dx \\right)^{1/2}$。\n- 对于固定的单元$I=[a,b]$和多项式阶次$p \\in \\mathbb{N}$， $I$上的局部有限元空间由至多$p$次的多项式组成。其导数张成了$I$上所有至多$p-1$次的多项式空间。\n- $I$上$H^1$半范数下的最佳逼近误差等于$u'(x)$在$I$上至多$p-1$次多项式子空间上的$L^2(I)$投影误差。\n- 希尔伯特空间中的正交投影最小化了在子空间上的残差范数。\n\n您必须：\n1. 对于给定的单元$I=[a,b]$和阶次$p$，计算当前局部误差$E_0(I,p)$，其为$\\int_a^b |u'(x)-q(x)|^2\\,dx$在所有至多$p-1$次多项式$q$上的最小值。\n2. 对于$h$-加密，将$I$替换为两个子单元$I_1=[a,(a+b)/2]$和$I_2=[(a+b)/2,b]$，阶次$p$保持不变。计算$E_h(I,p) := E_0(I_1,p) + E_0(I_2,p)$。\n3. 对于$p$-加密，将单元$I$上的阶次提升到$p+1$，并计算$E_p(I,p) := E_0(I,p+1)$。\n4. 对于$r$-加密，将单元长度缩小一个因子$s \\in (0,1)$，同时保持其左端点固定，即$I_r = [a, a + s(b-a)]$，阶次$p$保持不变。计算$E_r(I,p,s) := E_0(I_r,p)$。\n\n将每个操作的单位成本边际误差减少量定义为\n- $G_h := \\dfrac{\\max\\{E_0(I,p) - E_h(I,p), 0\\}}{C_h(p)}$，\n- $G_p := \\dfrac{\\max\\{E_0(I,p) - E_p(I,p), 0\\}}{C_p}$，\n- $G_r := \\dfrac{\\max\\{E_0(I,p) - E_r(I,p,s), 0\\}}{C_r}$，\n\n采用以下成本模型（以等效自由度计算）：\n- $C_h(p) := p$ 用于二等分一个阶次为$p$的单元，\n- $C_p := 1$ 用于将一个单元上的阶次$p$提升到$p+1$，\n- $C_r := c_r$ 用于重定位节点以将单元按给定因子$s$收缩，其中$c_r > 0$是给定的。\n\n使用高斯-勒让德求积法以足够高的阶数计算所需的积分以确保数值稳定性，并使用参考区间上的正交多项式来构建$L^2$投影，而不依赖任何预先计算的简化公式。所有单元、变量、算子和常数都必须以数学精度处理。\n\n决策规则：对于每个测试用例，计算$G_h$、$G_p$和$G_r$。选择使增益最大化的操作。如果在增益的数值容差$10^{-12}$内出现平局，则按照$h \\rightarrow p \\rightarrow r$的顺序，选择索引最小的操作来打破平局。\n\n用于验证不同正则性区域的基准函数$u(x)$：\n- 光滑解析函数：$u(x) = \\sin(\\pi x)$，在$[0,1]$上。\n- 端点奇异函数（但$H^1$-可容许）：$u(x) = x^{\\alpha}$，在$[0,1]$上，其中$\\alpha = 0.6$。\n\n不涉及角度单位。没有物理单位；所有量纲均为无量纲。\n\n测试套件：\n对于每个测试用例，将给定一个元组，指定基准类型、单元区间$[a,b]$、多项式阶次$p$、$r$-收缩因子$s$以及$r$-成本$c_r$。对于奇异情况，使用$\\alpha = 0.6$。测试用例如下：\n- 用例1：光滑, $[a,b]=[0,0.5]$, $p=2$, $s=0.7$, $c_r=1.0$。\n- 用例2：光滑, $[a,b]=[0.5,1]$, $p=2$, $s=0.7$, $c_r=1.0$。\n- 用例3：奇异, $[a,b]=[0,0.5]$, $p=2$, $s=0.7$, $c_r=1.0$。\n- 用例4：奇异, $[a,b]=[0.5,1]$, $p=2$, $s=0.7$, $c_r=1.0$。\n\n您的程序应：\n- 按规定实现模型。\n- 对于每个用例，输出一个整数来编码所选操作，$0$代表$h$-加密，$1$代表$p$-加密，$2$代表$r$-加密。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如$[r_1,r_2,r_3,r_4]$，其中每个$r_i$是按上述顺序排列的用例$i$的整数决策。不应产生任何其他输出。",
            "solution": "用户提供的问题是数值分析领域中一个有效且适定的练习，特别是在自适应有限元方法领域。它要求构建并应用一个决策模型，以在$h$-、$p$-和$r$-加密中选择最优的网格加密策略。决策基于最大化单位计算成本下的边际误差减少量。问题的所有组成部分——误差度量、加密策略、成本模型和决策规则——都经过了精确的数学定义，使其成为一个基于既定科学原理的可解问题。\n\n解决方案首先规范局部误差的计算，然后详细说明每种加密策略的增益计算，最后指定决策逻辑。\n\n### 1. 局部误差计算\n\n模型的核心是计算在单个单元$I = [a,b]$上，对于一个$p$阶多项式逼近的局部离散误差。问题将此误差定义为$H^1$半范数下的最佳逼近误差。一个关键的已知事实简化了这一点：有限元逼近的$H^1$半范数误差的平方等于其导数的$L^2$范数误差的平方。\n\n具体来说，我们要计算$E_0(I, p)$，它是函数导数$u'(x)$被一个至多$p-1$次的多项式$q(x)$最佳逼近时的平方$L^2(I)$误差。令$\\mathcal{P}_{k}(I)$表示区间$I$上至多$k$次的多项式空间。该误差由下式给出：\n$$\nE_0(I, p) = \\min_{q \\in \\mathcal{P}_{p-1}(I)} \\int_a^b |u'(x) - q(x)|^2 \\, dx\n$$\n根据希尔伯特空间理论，当$q$是$u'$到$\\mathcal{P}_{p-1}(I)$上的正交$L^2$投影时，达到最小值。设此投影为$\\Pi_{p-1} u'$。则误差为残差范数的平方：\n$$\nE_0(I, p) = \\|u' - \\Pi_{p-1} u'\\|_{L^2(I)}^2\n$$\n为了进行数值计算，我们采用一种标准技术，通过仿射变换$x(\\xi) = a + \\frac{b-a}{2}(\\xi+1)$将物理单元$I = [a,b]$映射到参考单元$\\hat{I} = [-1,1]$。此映射的雅可比行列式为$J = \\frac{b-a}{2}$。积分变换如下：$\\int_a^b f(x) \\, dx = \\int_{-1}^1 f(x(\\xi)) J \\, d\\xi$。\n\n在参考单元上，我们使用勒让德多项式基$\\{\\hat{L}_k(\\xi)\\}_{k=0}^{\\infty}$，它们在$[-1,1]$上关于标准$L^2$内积是正交的：\n$$\n\\int_{-1}^1 \\hat{L}_i(\\xi) \\hat{L}_j(\\xi) \\, d\\xi = \\frac{2}{2i+1}\\delta_{ij}\n$$\n其中$\\delta_{ij}$是克罗内克δ。变换后的导数$\\hat{u}'(\\xi) = u'(x(\\xi))$到$\\mathcal{P}_{p-1}(\\hat{I})$上的投影是$\\Pi_{p-1}\\hat{u}' = \\sum_{k=0}^{p-1} c_k \\hat{L}_k(\\xi)$，其系数为$c_k = \\frac{\\langle \\hat{u}', \\hat{L}_k \\rangle}{\\langle \\hat{L}_k, \\hat{L}_k \\rangle}$。\n\n根据正交投影的勾股定理，物理单元上的误差可以计算为：\n$$\nE_0(I, p) = J \\left( \\|\\hat{u}'\\|_{L^2(\\hat{I})}^2 - \\|\\Pi_{p-1}\\hat{u}'\\|_{L^2(\\hat{I})}^2 \\right)\n$$\n其中$\\|\\hat{u}'\\|_{L^2(\\hat{I})}^2 = \\int_{-1}^1 |\\hat{u}'(\\xi)|^2 \\, d\\xi$且$\\|\\Pi_{p-1}\\hat{u}'\\|_{L^2(\\hat{I})}^2 = \\sum_{k=0}^{p-1} \\frac{\\left( \\int_{-1}^1 \\hat{u}'(\\xi)\\hat{L}_k(\\xi) \\, d\\xi \\right)^2}{\\int_{-1}^1 |\\hat{L}_k(\\xi)|^2 \\, d\\xi}$。\n所有积分都使用高阶高斯-勒让德求积法进行数值计算，以确保准确性。\n\n### 2. 加密策略与增益计算\n\n在建立了误差计算方法之后，我们对给定单元$I=[a,b]$和阶次$p$的三种加密策略进行评估。\n\n**当前状态：** 初始误差为$E_{current} = E_0(I, p)$。\n\n**a) $h$-加密：** 单元$I$被二等分为两个子单元$I_1 = [a, (a+b)/2]$和$I_2 = [(a+b)/2, b]$，多项式阶次$p$保持不变。加密后的总误差是子单元上误差之和：\n$$\nE_h(I, p) = E_0(I_1, p) + E_0(I_2, p)\n$$\n成本给定为$C_h(p) = p$。增益为：\n$$\nG_h = \\frac{\\max\\{0, E_{current} - E_h(I, p)\\}}{C_h(p)}\n$$\n\n**b) $p$-加密：** 原始单元$I$上的多项式阶次增加到$p+1$。加密后的误差为：\n$$\nE_p(I, p) = E_0(I, p+1)\n$$\n成本为$C_p = 1$。增益为：\n$$\nG_p = \\frac{\\max\\{0, E_{current} - E_p(I, p)\\}}{C_p}\n$$\n\n**c) $r$-加密：** 单元$I$以给定因子$s$收缩为$I_r = [a, a + s(b-a)]$，而阶次$p$保持不变。所得误差在此较小单元上计算：\n$$\nE_r(I, p, s) = E_0(I_r, p)\n$$\n成本为给定常数$C_r = c_r$。根据问题定义，增益为：\n$$\nG_r = \\frac{\\max\\{0, E_{current} - E_r(I, p, s)\\}}{C_r}\n$$\n\n### 3. 决策模型\n\n对于每个测试用例，计算增益$G_h$、$G_p$和$G_r$。决策规则是选择与最大增益相对应的加密策略。如果出现平局，即两个或多个增益之差小于$10^{-12}$的容差，则按照预定顺序选择索引最小的策略来打破平局：$h$-加密（索引$0$）、$p$-加密（索引$1$）和$r$-加密（索引$2$）。此过程应用于每个测试用例以确定最优操作。该实现将处理指定的基准函数，一个光滑函数和一个具有端点奇异性的函数，以测试模型在不同函数正则性条件下的行为。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\n\ndef compute_error_squared(u_prime_func, interval, p_degree, n_quad=100):\n    \"\"\"\n    Computes the squared H^1-seminorm best-approximation error on an element.\n\n    This is equivalent to the L^2 projection error of the derivative u' onto\n    the space of polynomials of degree p-1.\n\n    Args:\n        u_prime_func (callable): The derivative of the function to approximate, u'(x).\n        interval (list or tuple): The element interval [a, b].\n        p_degree (int): The polynomial degree of the finite element space. Projection is onto P_{p-1}.\n        n_quad (int): The number of Gauss-Legendre quadrature points.\n\n    Returns:\n        float: The computed squared error E_0(I, p).\n    \"\"\"\n    k_proj = p_degree - 1\n    a, b = interval\n\n    if abs(a - b)  1e-15:\n        return 0.0\n\n    nodes, weights = np.polynomial.legendre.leggauss(n_quad)\n    \n    jac = (b - a) / 2.0\n    x_phys = jac * nodes + (a + b) / 2.0\n    \n    u_prime_vals_at_ref_nodes = u_prime_func(x_phys)\n    \n    # Compute the squared L2 norm of u' on the reference interval\n    norm_u_prime_sq = np.sum(weights * u_prime_vals_at_ref_nodes**2)\n    \n    # Compute the squared L2 norm of the projection of u'\n    sum_of_proj_coeffs_sq_norm = 0.0\n    if k_proj >= 0:\n        for j in range(k_proj + 1):\n            # Evaluate j-th Legendre polynomial at quadrature nodes\n            L_j_vals = special.eval_legendre(j, nodes)\n            \n            # Compute inner product"
        },
        {
            "introduction": "一个强大的自适应算法不仅应能评估加密后的效果，更应能预测何种策略将是有效的。这个练习将引导你从一个更理论的视角——复分析——来设计 $hp$ 自适应规则。你将利用解在复平面上的奇点信息来预测多项式逼近的收敛率，从而先验地判断一个单元是更适合进行 $p$ 加密（指数收敛）还是必须进行 $h$ 加密（代数收敛），深刻理解解的解析性与加密策略选择之间的内在联系。",
            "id": "3360857",
            "problem": "您的任务是设计、实现并测试一个算法，该算法用于一维情况下，基于解析延拓估计信息进行$hp$-自适应，以多项式逼近有界区间上偏微分方程的解。其目标是根据从复平面中解的最近奇点推断出的解析性信息，确定在每个网格单元上是优先采用$p$-加密、$h$-加密，还是建议对网格节点进行$r$-移动。该方法必须是有原则的，并且源于解析函数的基本逼近理论。\n\n从以下基础且经过充分检验的事实开始：\n\n- 如果一个函数在一个包含给定闭区间的开区域内是解析的，特别是在一个以该区间端点为焦点、参数$\\rho > 1$的Bernstein椭圆内部，那么在该区间上的最佳多项式逼近误差会随着多项式次数$p$的增加以$\\mathcal{O}(\\rho^{-p})$的速率几何衰减。这是多项式逼近理论中的一个经典结果，也是谱方法和有限元法（FEM）中的标准工具。缩写$FEM$指有限元法，$hp$-加密表示网格尺寸（$h$）和多项式次数（$p$）相结合的自适应策略。\n- 复平面奇点与实轴子区间上的Bernstein椭圆参数$\\rho$之间的关系由Joukowsky逆变换给出，该变换将物理坐标中的解析延拓域与辅助复平面中的圆联系起来。在将区间映射到参考区间并应用Joukowsky逆变换后，椭圆参数$\\rho$由离区间最近的奇点确定。\n- 当一个奇点位于某个单元内部的实轴上时，跨该区间的解析延拓无法延伸到区间之外，这意味着有效$\\rho$最多为$1$，并且纯粹的$p$-加密无法实现指数收敛。这促使我们采用$h$-加密或$r$-移动策略。\n\n您的程序必须基于这些原则实现一个$hp$决策过程，并附带定量的$r$-移动建议。考虑一个被划分为$N$个均匀单元的一维域$[0,1]$。给定一组复奇点$\\{s_k\\}$（在物理坐标中）、目标单元误差容限$\\tau$、表示值得利用的指数$p$-收敛开始的最小解析性阈值$\\rho_{\\min} > 1$、最大允许的多项式次数$p_{\\max} \\in \\mathbb{N}$，以及一个$r$-移动激进性参数$\\theta \\in (0,1)$。\n\n对于每个单元$I_j = [a_j,b_j]$，仅使用上述基本原则和定义执行以下操作：\n\n- 在从$[a_j,b_j]$到参考区间的仿射映射和Joukowsky逆变换下，确定由最近奇点引起的局部Bernstein椭圆参数$\\rho_j$。如果一个奇点位于$[a_j,b_j]$内部的实轴上，则取$\\rho_j = 1$。\n- 根据几何收敛原理，确定最小次数$p_j^\\star$，使得最佳多项式逼近误差满足$C \\rho_j^{-p_j^\\star} \\le \\tau$形式的界。为了计算方便，您可以将良性常数$C$归一化为$C=1$。如果$\\rho_j \\le 1$，则设$p_j^\\star = +\\infty$。\n- 分类规则：\n  - 如果$\\rho_j > \\rho_{\\min}$且$p_j^\\star \\le p_{\\max}$，则将该单元分类为$p$-适用（在该单元上优先采用$p$-加密）。\n  - 否则，将其分类为$h$-候选（在该单元上优先采用$h$-加密）。\n- $r$-移动建议：对于相邻单元之间的每个内部界面，如果两个相邻单元中恰好一个是$h$-候选单元，另一个是$p$-适用单元，则计算一个建议的界面位移量$\\delta$。该位移量与局部解析性对比度成正比。使用一个基于$1/\\rho$的对比度、并由两个相邻单元的并集长度和$\\theta$缩放的、量纲一致的替代指标。将所有内部界面上的这些贡献相加，然后除以域长度，以汇总总的归一化$r$-移动建议。\n\n您的程序不得读取任何输入，而应精确实现以下测试套件，每个测试用例由$[N, \\{s_k\\}, \\tau, p_{\\max}, \\rho_{\\min}, \\theta]$定义：\n\n- 测试用例 1（一般情况，解析函数远离实轴）：$N = 4$, $\\{s_k\\} = \\{0.5 + 1.0\\,\\mathrm{i}\\}$, $\\tau = 10^{-6}$, $p_{\\max} = 12$, $\\rho_{\\min} = 1.05$, $\\theta = 0.25$。\n- 测试用例 2（实轴上的分支点）：$N = 4$, $\\{s_k\\} = \\{0.3 + 0.0\\,\\mathrm{i}\\}$, $\\tau = 10^{-3}$, $p_{\\max} = 10$, $\\rho_{\\min} = 1.02$, $\\theta = 0.25$。\n- 测试用例 3（混合奇点）：$N = 8$, $\\{s_k\\} = \\{0.25 + 0.2\\,\\mathrm{i},\\, 0.75 + 0.0\\,\\mathrm{i}\\}$, $\\tau = 10^{-4}$, $p_{\\max} = 10$, $\\rho_{\\min} = 1.05$, $\\theta = 0.30$。\n- 测试用例 4（邻近的复奇点）：$N = 4$, $\\{s_k\\} = \\{0.5 + 0.05\\,\\mathrm{i}\\}$, $\\tau = 10^{-2}$, $p_{\\max} = 8$, $\\rho_{\\min} = 1.10$, $\\theta = 0.20$。\n\n对于每个测试用例，您的程序必须输出一个包含三个值的列表：\n\n- $H$：被分类为$h$-候选单元的数量（一个整数）。\n- $P_{\\max}^{\\mathrm{sel}}$：在被分类为$p$-适用的单元中$p_j^\\star$的最大值（一个整数；如果没有$p$-适用单元，则输出$0$）。\n- $\\mathcal{R}$：按上述方法计算的总归一化$r$-移动建议，四舍五入到$6$位小数（一个浮点数）。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个逗号分隔的列表，并用方括号括起来。其中每个条目本身就是对应测试用例的列表$[H, P_{\\max}^{\\mathrm{sel}}, \\mathcal{R}]$。例如，一个包含两个假设用例的输出可能看起来像$[[2,7,0.031415],[0,5,0.0]]$。\n\n在此问题中，所有量均为无量纲量；不使用物理单位。在复数辐角中隐含的角度，按惯例以弧度为单位，但您不会直接操作角度。\n\n您的实现必须是自包含的，并且不得需要任何用户输入、外部文件或网络访问。指定测试套件的数值结果必须是可复现的。",
            "solution": "该问题要求设计并实现一种用于一维数值方法的自适应网格加密策略。具体来说，它要求建立一个决策过程，以便将网格单元分类，用于多项式阶数加密（$p$-加密）、网格尺寸加密（$h$-加密）或网格顶点重分布（$r$-移动）。此决策基于关于解析函数多项式逼近的逼近理论原则。\n\n基本原理是，一个函数在区间$[a, b]$上的最佳多项式逼近的收敛率由该函数在复平面上的解析性决定。如果一个函数在一个以$a$和$b$为焦点的Bernstein椭圆内是解析的，那么对于一个$p$次多项式，其在最大范数下的逼近误差会以与该椭圆大小相关的速率呈指数衰减。椭圆的大小由参数$\\rho$（椭圆半长轴与半短轴之和，此时焦点间距被归一化）来参数化。误差有界于$\\mathcal{O}(\\rho^{-p})$。更大的$\\rho$意味着更大的解析域和更快的收敛速度。函数在区间$[a, b]$附近的奇点会限制可能的最大Bernstein椭圆的大小，从而降低收敛率。\n\n该算法主要分三个阶段进行：单元分析、用于$r$-移动的界面分析和结果汇总。\n\n**1. 单元分析**\n\n域，即区间$[0, 1]$，被划分为$N$个均匀单元$I_j = [a_j, b_j]$，其中$j=0, 1, \\dots, N-1$。对于均匀划分，顶点位于$x_j = j/N$，因此$a_j = j/N$，$b_j = (j+1)/N$。每个单元的长度为$h = 1/N$。对于每个单元$I_j$，我们执行以下步骤：\n\n**a. 解析性参数$\\rho_j$的确定**\n\n参数$\\rho_j$量化了函数在单元$I_j$上的局部解析性。它对应于该单元上包含解的至少一个奇点$\\{s_k\\}$的最小Bernstein椭圆。\n\ni. **映射到参考区间：** 我们首先将物理单元$I_j = [a_j, b_j]$映射到规范参考区间$\\Xi = [-1, 1]$。仿射映射为$z(\\xi) = \\frac{2\\xi - (a_j+b_j)}{b_j-a_j}$。物理域中的每个奇点$s_k$都被映射到相对于参考区间的复平面中的$z_k = z(s_k)$。\n\nii. **Joukowsky逆变换：** 区间$\\Xi = [-1, 1]$的外部可以通过Joukowsky逆变换$w(z)$映射到辅助复平面中单位圆盘$|w|>1$的外部。$|w(z)| = \\rho > 1$的水平集恰好是焦点在$\\pm 1$的Bernstein椭圆。穿过点$z$的椭圆的参数$\\rho$由$|w(z)|$给出。该变换是$z = \\frac{1}{2}(w+w^{-1})$的解，即$w^2 - 2zw + 1 = 0$。其根为$w = z \\pm \\sqrt{z^2-1}$。为了映射到单位圆盘的外部，我们必须选择模长大于或等于$1$的根。一种稳健的计算方法是找到两个根并取绝对值较大的那个。对于每个映射后的奇点$z_k$，我们计算相应的参数$\\rho_j^{(k)} = \\max(|z_k + \\sqrt{z_k^2-1}|, |z_k - \\sqrt{z_k^2-1}|)$。\n\niii. **单元参数$\\rho_j$：** 函数在单元$I_j$上的解析性受限于“最近”的奇点。因此，该单元的有效$\\rho_j$是与所有奇点相关的参数中的最小值：$\\rho_j = \\min_k \\rho_j^{(k)}$。\n\niv. **特殊情况（实奇点）：** 如果一个奇点$s_k$是实数（即$\\text{Im}(s_k)=0$）并且严格位于单元内部，$s_k \\in (a_j, b_j)$，那么无法在不包围该奇点的情况下围绕该区间绘制Bernstein椭圆。在这种情况下，指数收敛性会丧失，我们设置$\\rho_j = 1$。如果一个实奇点位于单元边界点上，它会映射到$\\Xi$的一个端点（$-1$或$1$），通过Joukowsky变换同样得到$\\rho=1$，这正确地捕捉了局部解析性的丧失。\n\n**b. 所需多项式次数$p_j^\\star$的估计**\n\n$p$次最佳多项式逼近误差$E_p$有界于$E_p \\le C \\rho_j^{-p}$。为达到目标容限$\\tau$，我们需要$C \\rho_j^{-p} \\le \\tau$。根据问题陈述，我们将常数归一化为$C=1$，得到条件$\\rho_j^{-p} \\le \\tau$。\n\n- 如果$\\rho_j > 1$，我们可以解出$p$：$-p \\ln(\\rho_j) \\le \\ln(\\tau)$，这意味着$p \\ge -\\frac{\\ln(\\tau)}{\\ln(\\rho_j)}$。所需的最小整数次数是$p_j^\\star = \\lceil -\\frac{\\ln(\\tau)}{\\ln(\\rho_j)} \\rceil$。\n- 如果$\\rho_j \\le 1$，对于任何有限的$p$都无法满足该条件（假设$\\tau  1$），这表明最多是代数收敛。在这种情况下，我们设置$p_j^\\star = +\\infty$。\n\n**c. 单元分类**\n\n基于$\\rho_j$和$p_j^\\star$，每个单元被分类以指导自适应策略。\n\n- **$p$-适用：** 如果解析性足够强且所需次数是实际可行的，则该单元适合进行$p$-加密。这在$\\rho_j > \\rho_{\\min}$且$p_j^\\star \\le p_{\\max}$时成立。\n- **$h$-候选：** 否则，该单元被标记为进行$h$-加密。当收敛太慢（$\\rho_j \\le \\rho_{\\min}$）或达到容限所需的次数过高（$p_j^\\star > p_{\\max}$）时，会发生这种情况。\n\n**2. 用于$r$-移动的界面分析**\n\n网格重分布（$r$-自适应）旨在移动网格顶点以更好地解析解的特征，例如低正则性区域。当相邻单元的预测加密类型存在强烈对比时，会生成移动界面的建议。\n\n我们检查每个内部界面$x_{j}$（对于$j=1, \\dots, N-1$），它分隔单元$I_{j-1}$和$I_j$。当且仅当相邻单元中一个为$h$-候选而另一个为$p$-适用时，计算界面$x_j$的位移量$\\delta_j$。如果满足此条件，位移为：\n$$ \\delta_j = \\theta \\cdot L_{j-1, j} \\cdot \\left|\\frac{1}{\\rho_{j-1}} - \\frac{1}{\\rho_j}\\right| $$\n这里，$\\theta \\in (0, 1)$是一个激进性参数，$L_{j-1, j}$是两个单元的组合长度（对于均匀网格，$L_{j-1, j} = 2/N$），项$|\\frac{1}{\\rho_{j-1}} - \\frac{1}{\\rho_j}|$量化了几何收敛因子的对比度。如果不满足条件，则$\\delta_j=0$。\n\n**3. 测试用例结果的汇总**\n\n最后，对于每个测试用例，我们计算三个汇总统计量：\n\n- $H$：被分类为$h$-候选的单元总数。\n- $P_{\\max}^{\\mathrm{sel}}$：所有$p$-适用单元中所需的最大次数，即$P_{\\max}^{\\mathrm{sel}} = \\max(\\{ p_j^\\star \\mid I_j \\text{ is } p\\text{-admissible} \\} \\cup \\{0\\})$。我们在集合中包含$0$以处理没有$p$-适用单元的情况。\n- $\\mathcal{R}$：总的归一化$r$-移动建议。这是所有单个界面位移建议的总和，$\\mathcal{R} = \\sum_{j=1}^{N-1} \\delta_j$，并由域长度（即$1$）进行归一化。\n\n此过程为在$hp-r$自适应算法中做出局部决策提供了定量的、有理论依据的基础。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests an hp-r adaptation decision algorithm based on\n    analytic continuation estimates.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        (4, {0.5 + 1.0j}, 1e-6, 12, 1.05, 0.25),\n        # Test case 2\n        (4, {0.3 + 0.0j}, 1e-3, 10, 1.02, 0.25),\n        # Test case 3\n        (8, {0.25 + 0.2j, 0.75 + 0.0j}, 1e-4, 10, 1.05, 0.30),\n        # Test case 4\n        (4, {0.5 + 0.05j}, 1e-2, 8, 1.10, 0.20),\n    ]\n\n    all_results = []\n\n    for N, singularities, tau, p_max, rho_min, theta in test_cases:\n        h = 1.0 / N\n        elements_data = []\n\n        # 1. Element-wise Analysis\n        for j in range(N):\n            a_j, b_j = j * h, (j + 1) * h\n            \n            rho_j = np.inf\n            \n            # Check for real singularity inside the element\n            has_real_singularity_inside = False\n            for s in singularities:\n                if np.isreal(s) and a_j  s.real  b_j:\n                    has_real_singularity_inside = True\n                    break\n            \n            if has_real_singularity_inside:\n                rho_j = 1.0\n            else:\n                rho_contributions = []\n                for s_k in singularities:\n                    # Map singularity to reference element coords\n                    z_k = (2 * s_k - (a_j + b_j)) / (b_j - a_j)\n                    \n                    # Handle case where z_k^2 - 1 is negative real\n                    sqrt_val = np.sqrt(z_k**2 - 1)\n                    \n                    # Find the root of w^2 - 2*z_k*w + 1 = 0 with |w| >= 1\n                    w_plus = z_k + sqrt_val\n                    w_minus = z_k - sqrt_val\n                    \n                    # In theory, one has |w|>=1, other |w|=1.\n                    # Taking max handles branch choice implicitly.\n                    rho_k = max(np.abs(w_plus), np.abs(w_minus))\n                    rho_contributions.append(rho_k)\n                \n                if rho_contributions:\n                    rho_j = min(rho_contributions)\n\n            # Determine required polynomial degree p_star\n            p_star_j = np.inf\n            if rho_j > 1:\n                # Need p >= -log(tau) / log(rho_j)\n                p_star_j = np.ceil(-np.log(tau) / np.log(rho_j))\n            \n            # Classify element\n            is_p_admissible = (rho_j > rho_min) and (p_star_j = p_max)\n            classification = 'p' if is_p_admissible else 'h'\n            \n            elements_data.append({\n                'rho': rho_j,\n                'p_star': int(p_star_j) if np.isfinite(p_star_j) else np.inf,\n                'class': classification\n            })\n\n        # 2. Aggregation for H and P_max_sel\n        H = sum(1 for el in elements_data if el['class'] == 'h')\n        \n        p_admissible_degrees = [el['p_star'] for el in elements_data if el['class'] == 'p']\n        P_max_sel = max(p_admissible_degrees) if p_admissible_degrees else 0\n\n        # 3. Interface Analysis for r-movement\n        total_delta = 0.0\n        union_length = 2 * h\n        for j in range(1, N):\n            class_left = elements_data[j-1]['class']\n            class_right = elements_data[j]['class']\n            \n            # Check for mismatch in classification\n            if (class_left == 'h' and class_right == 'p') or \\\n               (class_left == 'p' and class_right == 'h'):\n                rho_left = elements_data[j-1]['rho']\n                rho_right = elements_data[j]['rho']\n                \n                # Prevent division by zero if rho can be zero (not possible here)\n                if rho_left > 0 and rho_right > 0:\n                    contrast = abs(1/rho_left - 1/rho_right)\n                    delta_j = theta * union_length * contrast\n                    total_delta += delta_j\n        \n        R = round(total_delta, 6)\n        \n        all_results.append(f\"[{H},{P_max_sel},{R:.6f}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当我们将多种自适应策略（如 $p$ 和 $r$ 加密）结合使用时，它们之间可能产生意想不到的相互影响。本练习聚焦于一个在实践中至关重要但又十分微妙的问题：由 $r$ 加密（节点移动）引起的单元几何畸变，如何“污染”用于指导 $p$ 加密的误差指示器。通过分析一个从参考单元到受挤压物理单元的映射，你将亲手揭示传统误差指示器的脆弱性，并探索如何设计出能够解耦几何效应与逼近误差的、更为稳健的指示器。",
            "id": "3360876",
            "problem": "考虑一个通过从参考方形映射得到的单...等参四边形有限元。设参考方形为 $\\hat{\\Omega} = [-1,1] \\times [-1,1]$，其坐标为 $(\\xi,\\eta)$，物理单元为 $\\Omega_\\varepsilon$，其坐标为 $(x,y)$，通过 $r$-移动映射 $F_\\varepsilon : \\hat{\\Omega} \\to \\Omega_\\varepsilon$ 得到，该映射定义为\n$$\nx = \\xi,\\quad y = \\varepsilon\\,\\eta,\n$$\n其中 $\\varepsilon > 0$ 控制几何畸变，雅可比行列式等于 $\\det(J_{F_\\varepsilon}) = \\varepsilon$。设 $u:\\Omega_\\varepsilon \\to \\mathbb{R}$ 为一个光滑目标场。在标准的 $p$-加密误差指示中，分层 $p$-基指示子由 $p$ 阶和 $p+1$ 阶之间增加的多项式展开的尾项构成。然而，在近奇异雅可比（小 $\\varepsilon$）情况下，误差指示子可能会因几何映射而失真，而不是反映逼近质量。目标是分析这类指示子的鲁棒性，并设计出将逼近误差与几何畸变解耦的修正指示子。\n\n使用以下基本基底和定义：\n- 光滑映射 $F$ 下的梯度链式法则：如果 $v = \\hat{v} \\circ F^{-1}$，则\n$$\n\\nabla_x v = J_{F}^{-T} \\,\\nabla_{\\xi} \\hat{v},\n$$\n其中 $J_{F}$ 是 $F$ 的雅可比矩阵，物理积分变换为\n$$\n\\int_{\\Omega} g(x)\\,dx = \\int_{\\hat{\\Omega}} g\\big(F(\\xi)\\big)\\,\\det(J_{F})\\,d\\xi.\n$$\n- 物理单元中的 $H^1$ 半范数为\n$$\n|v|_{H^1(\\Omega)}^2 = \\int_{\\Omega} \\|\\nabla_x v\\|_2^2\\,dx.\n$$\n- 在参考单元上，使用由归一化勒让德多项式 $\\{L_i(\\xi)\\}_{i=0}^{\\infty}$ 和 $\\{L_j(\\eta)\\}_{j=0}^{\\infty}$ 构成的张量积层次正交基，其中 $L_n(t) = \\sqrt{\\frac{2n+1}{2}}\\,P_n(t)$，$P_n$ 是 $n$ 阶勒让德多项式。p-加密尾项 $\\delta_{p\\to p+1}$ 是在该基上 $(p+1)$ 阶投影与 $p$ 阶投影之间的差。\n\n定义一个由整数 $n_y \\ge 0$ 参数化的目标场族：\n$$\nu_{n_y}(x,y) = \\begin{cases}\n\\sin(\\pi x), & n_y = 0, \\\\\n\\sin(\\pi x)\\sin(\\pi n_y y), & n_y \\ge 1\n\\end{cases}\n$$\n对于任何 $\\varepsilon > 0$，所有这些场在 $\\Omega_\\varepsilon$ 上都是光滑的。\n\n任务：\n1. 在 $\\hat{\\Omega}$ 上，为每个坐标构建最高到 $p+1$ 阶的正交勒让德张量积基。\n2. 计算 $u_{n_y}\\circ F_\\varepsilon$ 在最高 $p+1$ 阶和最高 $p$ 阶基上的 $L^2$ 正交投影系数，并在 $\\hat{\\Omega}$ 上构成层次尾项函数 $\\delta_{p\\to p+1}$。\n3. 从上述基本映射恒等式出发，分析以下两个指示子相对于几何畸变参数 $\\varepsilon$ 的行为（鲁棒性）：\n   - 一个朴素的基于 $p$ 的 $H^1$ 半范数指示子，它在物理空间中度量尾项，\n     $$\n     \\mathcal{E}^{\\text{naive}}_{H^1}(\\varepsilon) = \\int_{\\Omega_\\varepsilon} \\|\\nabla_x \\delta_{p\\to p+1}\\|_2^2\\,dx.\n     $$\n   - 一个旨在通过在参考空间中度量尾项来将逼近误差与几何畸变解耦的修正指示子，\n     $$\n     \\mathcal{E}^{\\text{mod}}_{\\hat{H}^1} = \\int_{\\hat{\\Omega}} \\|\\nabla_{\\xi} \\delta_{p\\to p+1}\\|_2^2\\,d\\xi d\\eta.\n     $$\n4. 此外，度量物理空间和参考空间中尾项的 $L^2$ 能量，\n   $$\n   \\mathcal{E}^{\\text{phys}}_{L^2}(\\varepsilon) = \\int_{\\Omega_\\varepsilon} |\\delta_{p\\to p+1}|^2\\,dx,\\quad\n   \\mathcal{E}^{\\text{ref}}_{L^2} = \\int_{\\hat{\\Omega}} |\\delta_{p\\to p+1}|^2\\,d\\xi d\\eta,\n   $$\n   并检验比率 $\\mathcal{R}_{L^2}(\\varepsilon) = \\frac{\\mathcal{E}^{\\text{phys}}_{L^2}(\\varepsilon)}{\\mathcal{E}^{\\text{ref}}_{L^2}}$ 如何随 $\\varepsilon$ 变化。\n\n实现细节：\n- 对所有积分，在 $\\hat{\\Omega}$ 上使用高斯求积；选择足够高的阶数以精确解析展开式。\n- 通过三项递推关系实现勒让德多项式，并计算它们的导数以进行梯度计算。\n- 利用正交基的性质，通过在 $\\hat{\\Omega}$ 上的内积来获得投影系数。\n\n测试套件：\n- 固定 $p = 4$ 并使用以下 $(\\varepsilon, n_y)$ 参数对：\n  1. $(1.0, 1)$，无畸变的一般情况，\n  2. $(0.1, 1)$，中等畸变，\n  3. $(0.01, 1)$，近奇异雅可比，\n  4. $(0.01, 0)$，无 y 方向变化的边界情况，\n  5. $(0.01, 5)$，近奇异雅可比下的强 y 方向变化。\n\n对于每个测试用例，计算两个浮点数：\n- 比率 $\\mathcal{R}_{H^1}(\\varepsilon) = \\dfrac{\\mathcal{E}^{\\text{naive}}_{H^1}(\\varepsilon)}{\\mathcal{E}^{\\text{mod}}_{\\hat{H}^1}}$，\n- 比率 $\\mathcal{R}_{L^2}(\\varepsilon) = \\dfrac{\\mathcal{E}^{\\text{phys}}_{L^2}(\\varepsilon)}{\\mathcal{E}^{\\text{ref}}_{L^2}}$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，按测试用例顺序展平。即\n$$\n[\\mathcal{R}_{H^1}(\\varepsilon_1),\\mathcal{R}_{L^2}(\\varepsilon_1),\\ldots,\\mathcal{R}_{H^1}(\\varepsilon_5),\\mathcal{R}_{L^2}(\\varepsilon_5)]\n$$\n其中每个条目都是一个浮点数。不涉及单位；所有量纲均为无量纲。程序必须完全自包含且不需要任何输入。",
            "solution": "该问题要求分析当有限元方法受到几何畸变时，其 $p$-加密误差指示子的鲁棒性。问题的核心是比较一个“朴素”的误差指示子（直接在畸变的物理空间中评估）和一个“修正”的指示子（在无畸变的参考空间中评估）。这种比较揭示了几何因素如何污染误差估计，而理想情况下，误差估计应仅反映多项式基对解的逼近误差。\n\n分析在物理 $(x,y)$ 坐标系中的单个四边形单元 $\\Omega_\\varepsilon$ 上进行。该单元源自于 $(\\xi,\\eta)$ 坐标系中的一个正则参考方形 $\\hat{\\Omega} = [-1,1] \\times [-1,1]$，通过映射 $F_\\varepsilon: (\\xi,\\eta) \\mapsto (x,y)$ 得到：\n$$\nx = \\xi, \\quad y = \\varepsilon\\eta\n$$\n参数 $\\varepsilon > 0$ 控制单元的长宽比。当 $\\varepsilon \\to 0$ 时，单元变得越来越畸变或“被压扁”。该映射的雅可比矩阵、其行列式及其逆转置是分析的基础：\n$$\nJ_{F_\\varepsilon} = \\begin{pmatrix} 1  0 \\\\ 0  \\varepsilon \\end{pmatrix}, \\quad \\det(J_{F_\\varepsilon}) = \\varepsilon, \\quad J_{F_\\varepsilon}^{-T} = \\begin{pmatrix} 1  0 \\\\ 0  1/\\varepsilon \\end{pmatrix}\n$$\n物理空间和参考空间中梯度之间的关系由链式法则给出：$\\nabla_x v = J_{F_\\varepsilon}^{-T} \\nabla_\\xi \\hat{v}$，其中 $\\hat{v} = v \\circ F_\\varepsilon$。\n\n待逼近的目标函数是 $u_{n_y}(x,y)$，它被拉回到参考单元上以定义 $\\hat{u}_{n_y}(\\xi,\\eta) = u_{n_y}(F_\\varepsilon(\\xi,\\eta))$：\n$$\n\\hat{u}_{n_y}(\\xi,\\eta) =\n\\begin{cases}\n\\sin(\\pi\\xi)  \\text{if } n_y = 0 \\\\\n\\sin(\\pi\\xi)\\sin(\\pi n_y \\varepsilon \\eta)  \\text{if } n_y \\ge 1\n\\end{cases}\n$$\n逼近使用正交勒让德多项式的张量积基 $\\phi_{ij}(\\xi,\\eta) = L_i(\\xi)L_j(\\eta)$ 进行。误差指示子基于展开的“尾项” $\\delta_{p\\to p+1}$，它表示投影函数在从 $p$ 阶到 $p+1$ 阶多项式中的分量。该尾项函数在参考单元 $\\hat{\\Omega}$ 上定义为\n$$\n\\delta_{p\\to p+1} = \\hat{u}_{p+1} - \\hat{u}_p = \\sum_{i=0}^{p+1}\\sum_{j=0}^{p+1} c_{ij} \\phi_{ij} - \\sum_{i=0}^{p}\\sum_{j=0}^{p} c_{ij} \\phi_{ij} = \\sum_{(i,j) \\in \\text{tail set}} c_{ij} \\phi_{ij}\n$$\n其中 $p=4$，系数 $c_{ij}$ 是 $\\hat{u}_{n_y}$ 的 $L^2(\\hat{\\Omega})$ 投影系数：\n$$\nc_{ij} = \\int_{\\hat{\\Omega}} \\hat{u}_{n_y}(\\xi,\\eta) \\phi_{ij}(\\xi,\\eta) \\,d\\xi d\\eta\n$$\n这些积分以及所有后续积分，都使用高阶 Gauss-Legendre 求积法进行数值计算。\n\n我们分析四个量：\n1.  **参考 $L^2$ 能量**：$\\mathcal{E}^{\\text{ref}}_{L^2} = \\int_{\\hat{\\Omega}} |\\delta_{p\\to p+1}|^2\\,d\\xi d\\eta$。由于基 $\\{\\phi_{ij}\\}$ 的正交性，这简化为尾项中系数的平方和：\n    $$\n    \\mathcal{E}^{\\text{ref}}_{L^2} = \\sum_{(i,j) \\in \\text{tail set}} c_{ij}^2\n    $$\n2.  **物理 $L^2$ 能量**：$\\mathcal{E}^{\\text{phys}}_{L^2}(\\varepsilon) = \\int_{\\Omega_\\varepsilon} |\\delta_{p\\to p+1}|^2\\,dx dy$。通过将积分变换到参考单元，我们发现它与参考能量有直接关系：\n    $$\n    \\mathcal{E}^{\\text{phys}}_{L^2}(\\varepsilon) = \\int_{\\hat{\\Omega}} |\\delta_{p\\to p+1}|^2 \\det(J_{F_\\varepsilon})\\,d\\xi d\\eta = \\varepsilon \\int_{\\hat{\\Omega}} |\\delta_{p\\to p+1}|^2\\,d\\xi d\\eta = \\varepsilon \\mathcal{E}^{\\text{ref}}_{L^2}\n    $$\n    这为第一个比率提供了一个解析结果：$\\mathcal{R}_{L^2}(\\varepsilon) = \\mathcal{E}^{\\text{phys}}_{L^2}(\\varepsilon) / \\mathcal{E}^{\\text{ref}}_{L^2} = \\varepsilon$。这为数值实现提供了一个有价值的健全性检查。\n\n3.  **修正 $H^1$ 指示子**：$\\mathcal{E}^{\\text{mod}}_{\\hat{H}^1} = \\int_{\\hat{\\Omega}} \\|\\nabla_{\\xi} \\delta_{p\\to p+1}\\|_2^2\\,d\\xi d\\eta$。该指示子度量了参考单元原始几何中尾项函数的梯度，从而将逼近误差与几何效应分离开来。它通过求积计算：\n    $$\n    \\mathcal{E}^{\\text{mod}}_{\\hat{H}^1} = \\int_{-1}^1\\int_{-1}^1 \\left( \\left(\\frac{\\partial \\delta_{p\\to p+1}}{\\partial\\xi}\\right)^2 + \\left(\\frac{\\partial \\delta_{p\\to p+1}}{\\partial\\eta}\\right)^2 \\right) \\,d\\xi d\\eta\n    $$\n4.  **朴素 $H^1$ 指示子**：$\\mathcal{E}^{\\text{naive}}_{H^1}(\\varepsilon) = \\int_{\\Omega_\\varepsilon} \\|\\nabla_x \\delta_{p\\to p+1}\\|_2^2\\,dx dy$。该指示子受到几何形状的污染。将其变换到参考单元揭示了这种依赖性：\n    $$\n    \\mathcal{E}^{\\text{naive}}_{H^1}(\\varepsilon) = \\int_{\\hat{\\Omega}} \\|J_{F_\\varepsilon}^{-T} \\nabla_\\xi \\delta_{p\\to p+1}\\|_2^2 \\det(J_{F_\\varepsilon}) \\,d\\xi d\\eta\n    $$\n    代入我们映射的具体雅可比项得到：\n    $$\n    \\nabla_x \\delta \\leftrightarrow \\begin{pmatrix} \\partial_\\xi \\delta \\\\ \\varepsilon^{-1} \\partial_\\eta \\delta \\end{pmatrix}, \\quad \\| \\nabla_x \\delta \\|_2^2 \\leftrightarrow (\\partial_\\xi \\delta)^2 + \\varepsilon^{-2}(\\partial_\\eta \\delta)^2\n    $$\n    积分变为：\n    $$\n    \\mathcal{E}^{\\text{naive}}_{H^1}(\\varepsilon) = \\int_{\\hat{\\Omega}} \\left( (\\partial_\\xi \\delta)^2 + \\frac{1}{\\varepsilon^2}(\\partial_\\eta \\delta)^2 \\right) \\varepsilon \\,d\\xi d\\eta = \\int_{\\hat{\\Omega}} \\left( \\varepsilon(\\partial_\\xi \\delta)^2 + \\frac{1}{\\varepsilon}(\\partial_\\eta \\delta)^2 \\right) \\,d\\xi d\\eta\n    $$\n    项 $1/\\varepsilon$ 明确表明，朴素指示子对几何畸变是敏感的。当 $\\varepsilon \\to 0$ 时，该项可能导致 $\\mathcal{E}^{\\text{naive}}_{H^1}$ 的行为与 $\\mathcal{E}^{\\text{mod}}_{\\hat{H}^1}$ 大相径庭，这正是我们旨在通过比率 $\\mathcal{R}_{H^1}(\\varepsilon) = \\mathcal{E}^{\\text{naive}}_{H^1}(\\varepsilon) / \\mathcal{E}^{\\text{mod}}_{\\hat{H}^1}$ 来量化的。\n\n当 $n_y=0$ 时出现一个特殊情况，此时 $\\hat{u}_0(\\xi,\\eta) = \\sin(\\pi\\xi)$。该函数与 $\\eta$ 无关，因此其投影系数 $c_{ij}$ 仅在 $j=0$ 时非零。尾项函数 $\\delta_{p\\to p+1}$ 也将与 $\\eta$ 无关，使其导数 $\\partial_\\eta \\delta_{p\\to p+1} = 0$。在这种情况下，$H^1$ 指示子的表达式简化为：\n$$\n\\mathcal{E}^{\\text{mod}}_{\\hat{H}^1} = \\int_{\\hat{\\Omega}} (\\partial_\\xi \\delta)^2 \\, d\\xi d\\eta \\quad \\text{和} \\quad \\mathcal{E}^{\\text{naive}}_{H^1}(\\varepsilon) = \\int_{\\hat{\\Omega}} \\varepsilon (\\partial_\\xi \\delta)^2 \\, d\\xi d\\eta = \\varepsilon \\mathcal{E}^{\\text{mod}}_{\\hat{H}^1}\n$$\n因此，对于 $n_y=0$ 的情况，我们期望 $\\mathcal{R}_{H^1}(\\varepsilon) = \\varepsilon$。这为实现提供了另一个关键的验证点。对于 $n_y \\ge 1$ 和小 $\\varepsilon$，预计项 $(\\partial_\\eta \\delta)^2/\\varepsilon$ 将占主导地位，导致 $\\mathcal{R}_{H^1}(\\varepsilon)$ 变得很大，从而证明了朴素指示子的非鲁棒性。\n\n实现过程首先在 $\\hat{\\Omega}$ 上建立一个高阶二维高斯求积法则。在求积点处预先计算正交勒让德基函数及其导数。对于每个测试用例，计算投影系数 $c_{ij}$，然后在求积网格上计算尾项函数 $\\delta_{p\\to p+1}$ 及其梯度分量。最后，通过数值积分计算四个能量值，以求得所需比率。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre, roots_legendre\n\ndef legendre_basis_and_derivs(max_deg, x):\n    \"\"\"\n    Computes orthonormal Legendre basis functions L_n(x) and their derivatives L'_n(x).\n    L_n(t) = sqrt((2n+1)/2) * P_n(t), where P_n is the standard Legendre polynomial.\n\n    Args:\n        max_deg (int): Maximum degree of polynomials to compute.\n        x (np.ndarray): 1D array of points in [-1, 1] to evaluate the functions at.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]:\n            - L_vals: (max_deg+1, num_pts) array of L_n(x) values.\n            - L_prime_vals: (max_deg+1, num_pts) array of L'_n(x) values.\n    \"\"\"\n    num_pts = len(x)\n    L_vals = np.zeros((max_deg + 1, num_pts))\n    L_prime_vals = np.zeros((max_deg + 1, num_pts))\n\n    for n in range(max_deg + 1):\n        Pn = legendre(n)\n        Pn_prime = Pn.deriv(1)\n        \n        norm_const = np.sqrt((2 * n + 1) / 2.0)\n        \n        L_vals[n, :] = norm_const * Pn(x)\n        L_prime_vals[n, :] = norm_const * Pn_prime(x)\n        \n    return L_vals, L_prime_vals\n\ndef solve():\n    \"\"\"\n    Solves the problem of analyzing error indicator robustness for a distorted finite element.\n    \"\"\"\n    p = 4\n    test_cases = [\n        (1.0, 1),\n        (0.1, 1),\n        (0.01, 1),\n        (0.01, 0),\n        (0.01, 5),\n    ]\n\n    # Use a quadrature rule that is sufficiently accurate for the integrands.\n    # The integrands involve products of polynomials and transcendental functions.\n    # A high order is chosen for safety.\n    Nq = 32\n    xi_q, w_q = roots_legendre(Nq)\n    \n    # Pre-compute basis function values and derivatives at quadrature points\n    max_deg = p + 1\n    L_vals, L_prime_vals = legendre_basis_and_derivs(max_deg, xi_q)\n    \n    # 2D quadrature points and weights\n    XI, ETA = np.meshgrid(xi_q, xi_q)\n    W_2D = np.outer(w_q, w_q)\n    \n    results = []\n    \n    for eps, ny in test_cases:\n        # Define the target function on the reference element's quadrature grid\n        if ny == 0:\n            u_hat_vals = np.sin(np.pi * XI)\n        else:\n            u_hat_vals = np.sin(np.pi * XI) * np.sin(np.pi * ny * eps * ETA)\n            \n        # Compute L2 projection coefficients C_ij\n        C = np.zeros((max_deg + 1, max_deg + 1))\n        for i in range(max_deg + 1):\n            L_i_vals_2D = np.tile(L_vals[i, :], (Nq, 1))\n            for j in range(max_deg + 1):\n                L_j_vals_2D = np.tile(L_vals[j, :], (Nq, 1)).T\n                phi_ij_vals = L_i_vals_2D * L_j_vals_2D\n                C[i, j] = np.sum(W_2D * u_hat_vals * phi_ij_vals)\n\n        # Compute reference L^2 energy from coefficients (more accurate)\n        # Tail indices: (i,j) where i=p+1 or j=p+1\n        c_tail_sq = np.sum(C[p + 1, :]**2) + np.sum(C[:p + 1, p + 1]**2)\n        E_ref_L2 = c_tail_sq\n        \n        # Compute physical L^2 energy using the analytical relation\n        E_phys_L2 = eps * E_ref_L2\n        \n        # Compute tail function and its gradient on the grid\n        delta = np.zeros((Nq, Nq))\n        delta_xi = np.zeros((Nq, Nq))\n        delta_eta = np.zeros((Nq, Nq))\n        \n        for i in range(max_deg + 1):\n            L_i_vals_2D = np.tile(L_vals[i, :], (Nq, 1))\n            L_prime_i_vals_2D = np.tile(L_prime_vals[i, :], (Nq, 1))\n            for j in range(max_deg + 1):\n                if i > p or j > p:\n                    L_j_vals_2D = np.tile(L_vals[j, :], (Nq, 1)).T\n                    L_prime_j_vals_2D = np.tile(L_prime_vals[j, :], (Nq, 1)).T\n                    \n                    phi_ij = L_i_vals_2D * L_j_vals_2D\n                    grad_phi_ij_xi = L_prime_i_vals_2D * L_j_vals_2D\n                    grad_phi_ij_eta = L_i_vals_2D * L_prime_j_vals_2D\n                    \n                    delta += C[i, j] * phi_ij\n                    delta_xi += C[i, j] * grad_phi_ij_xi\n                    delta_eta += C[i, j] * grad_phi_ij_eta\n\n        # Compute H^1 seminorm indicators using quadrature\n        integrand_mod = delta_xi**2 + delta_eta**2\n        E_mod_H1 = np.sum(W_2D * integrand_mod)\n        \n        integrand_naive = eps * delta_xi**2 + (1/eps) * delta_eta**2\n        E_naive_H1 = np.sum(W_2D * integrand_naive)\n\n        # Compute ratios\n        if np.isclose(E_mod_H1, 0.0):\n            R_H1 = E_naive_H1 # Should be 0 if E_mod_H1 is 0, unless of numerical error\n        else:\n            R_H1 = E_naive_H1 / E_mod_H1\n\n        if np.isclose(E_ref_L2, 0.0):\n            R_L2 = E_phys_L2 # Should be 0 if E_ref_L2 is 0\n        else:\n            R_L2 = E_phys_L2 / E_ref_L2\n        \n        results.extend([R_H1, R_L2])\n        \n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}