{
    "hands_on_practices": [
        {
            "introduction": "理论学习的最终目的是解决实际问题。为了深刻理解稳定化方法的必要性，最好的方式莫过于亲眼见证标准伽辽金有限元法在对流占优问题中的“失效”。本练习将引导你通过编码实践，直观地观察和量化标准方法产生的非物理振荡，并实现流线迎风/彼得罗夫-伽辽金 (SUPG) 方法来有效抑制这些振荡，从而掌握稳定化方法的核心思想。",
            "id": "3447423",
            "problem": "考虑单位区间上的稳态一维对流扩散偏微分方程 (PDE)，其边界条件为齐次和非齐次狄利克雷边界条件：求 $u(x)$ 使得\n$$\n- \\epsilon \\, u''(x) + \\beta \\, u'(x) = f(x), \\quad x \\in (0,1),\n$$\n边界条件为 $u(0)=0$ 和 $u(1)=1$。假设参数 $\\epsilon > 0$、$\\beta \\in \\mathbb{R}$ 为常数，且 $f(x)=0$。从强形式出发，通过乘以检验函数 $v(x)$、在定义域上积分以及在适当之处使用分部积分的标准流程，推导出弱形式。使用有限元法 (FEM)，在均匀网格上采用连续分片线性基函数，以获得离散的伽辽金系统。讨论为什么在对流主导的情况下，所得的伽辽金离散化会变得数值不稳定，并根据网格尺寸 $h$、对流速度 $\\beta$ 和扩散系数 $\\epsilon$ 定义单元佩克莱数。佩克莱数应定义为一个无量纲比率，用于量化单元级别上对流与扩散的相对强度。\n\n为解决不稳定性问题，使用流线迎风/彼得罗夫-伽辽金 (SUPG) 方法构建一种稳定化格式。从基于残差的思想出发，沿流线方向富集检验空间，并说明这将如何产生一个额外的相容稳定项。推导稳定化参数的表达式，该表达式应以局部佩克莱数表示，并且在扩散主导和对流主导的极限情况下渐近正确。你的推导必须从弱形式和基于残差的富集机制的第一性原理出发，不得引用或假设任何现成的公式。\n\n在包含 $N$ 个单元的均匀网格上实现两个求解器：\n- 标准的伽辽金有限元求解器。\n- 使用你推导出的稳定化参数和沿流线的相容附加项的 SUPG 稳定化有限元求解器。\n\n对于每个求解器，组装全局线性系统，强加狄利克雷边界条件，并求解节点值 $u_i$。\n\n为离散解定义一个单调性检查，如下所示：如果对于所有内部节点索引 $i$，都有 $u_{i+1}-u_i \\ge 0$，则解是单调不减的。使用 $10^{-12}$ 的数值容差来考虑浮点效应，即，将 $u_{i+1}-u_i \\ge -10^{-12}$ 视为单调不减。对于每个测试用例，计算：\n- 网格上的最大单元佩克莱数 $Pe_{\\max}$，表示为浮点数。\n- 一个布尔值，指示伽辽金解是否单调。\n- 一个布尔值，指示 SUPG 解是否单调。\n\n使用以下参数值 $(N,\\beta,\\epsilon)$ 的测试套件，它涵盖了一系列不同的情况：\n1. $(100, 1.0, 10^{-2})$ 代表中等扩散主导行为。\n2. $(40, 1.0, 5 \\times 10^{-3})$ 代表对流开始占主导地位的情况。\n3. $(50, 1.0, 10^{-4})$ 代表强对流主导行为。\n4. $(50, 0.0, 10^{-2})$ 代表纯扩散（无对流）。\n\n此处所有量均为无量纲。你的程序应生成单行输出，其中包含结果，格式为一个包含四个内部列表的逗号分隔列表，每个内部列表对应一个测试用例，形式为 $[Pe_{\\max}, M_G, M_S]$，其中 $Pe_{\\max}$ 为浮点数，$M_G$ 和 $M_S$ 分别为伽辽金解和 SUPG 解的单调性布尔值。例如，最终输出格式必须是\n$$\n\\texttt{[[Pe1,MG1,MS1],[Pe2,MG2,MS2],[Pe3,MG3,MS3],[Pe4,MG4,MS4]]}.\n$$",
            "solution": "此解题报告的结构分为四个主要部分：对问题陈述的严格验证、所需数值方法的详细理论推导、最终 Python 代码的实现架构以及最终的程序本身。\n\n### 问题验证\n\n**第一步：提取已知条件**\n\n- **控制方程：** 稳态一维对流扩散偏微分方程为 $- \\epsilon \\, u''(x) + \\beta \\, u'(x) = f(x)$，$x \\in (0,1)$。\n- **参数：** 扩散系数 $\\epsilon$ 为正 ($\\epsilon > 0$)，对流速度 $\\beta$ 为实数 ($\\beta \\in \\mathbb{R}$)，源项 $f(x)$ 为零 ($f(x)=0$)。\n- **边界条件：** 给定非齐次狄利克雷条件：$u(0)=0$ 和 $u(1)=1$。\n- **数值方法：** 使用有限元法 (FEM)，在具有 $N$ 个单元的均匀网格上采用连续分片线性基函数。\n- **任务：**\n    1.  推导 PDE 的弱形式。\n    2.  构建标准的伽辽金离散系统。\n    3.  分析伽辽金方法在对流主导区域的数值不稳定性，并定义单元佩克莱数。\n    4.  推导流线迎风/彼得罗夫-伽辽金 (SUPG) 稳定化格式，包括稳定化参数 $\\tau$ 的表达式。\n    5.  实现伽辽金和 SUPG 两种求解器。\n    6.  对于一组给定的测试用例，计算最大单元佩克莱数 ($Pe_{\\max}$)，并检查伽辽金解 ($M_G$) 和 SUPG 解 ($M_S$) 的单调性。\n- **单调性准则：** 如果对于所有相邻节点对，都有 $u_{i+1} - u_i \\ge -10^{-12}$，则离散解 $\\{u_i\\}$ 被认为是单调不减的。\n- **测试用例：** 需要对四组参数集 $(N, \\beta, \\epsilon)$ 进行分析：\n    1. $(100, 1.0, 10^{-2})$\n    2. $(40, 1.0, 5 \\times 10^{-3})$\n    3. $(50, 1.0, 10^{-4})$\n    4. $(50, 0.0, 10^{-2})$\n\n**第二步：使用提取的已知条件进行验证**\n\n- **科学依据：** 该问题在根本上是合理的。对流扩散方程是输运现象中的一个典型模型。伽辽金有限元法和 SUPG 稳定化是偏微分方程数值方法领域的基石技术。所有概念在科学文献中都已得到充分确立。\n- **适定性和完整性：** 该问题是适定的。偏微分方程与狄利克雷边界条件相结合，构成了一个具有唯一解的有效边值问题。任务具体，并且提供了所有必要的信息（方程、参数、边界条件、数值方法）。\n- **客观性和可行性：** 问题以客观的数学术语陈述。所需的推导和实现是计算科学与工程领域的标准练习，所提供的测试用例在计算上是可行的。\n\n**第三步：结论与行动**\n\n该问题被判定为**有效**。这是一个定义明确且标准的数值分析问题，需要推导和实现基本的有限元技术。现在开始解题过程。\n\n### 理论推导与公式构建\n\n#### 1. 弱形式\n我们从定义域 $\\Omega = (0,1)$ 上的偏微分方程的强形式开始：\n$$\n- \\epsilon u''(x) + \\beta u'(x) = 0, \\quad x \\in (0,1)\n$$\n边界条件为 $u(0)=0$ 和 $u(1)=1$。\n\n为了推导弱形式，我们将方程乘以一个来自合适函数空间的检验函数 $v(x)$，并在定义域 $\\Omega$ 上进行积分。检验函数选自空间 $H^1_0(\\Omega)$，该空间由平方可积、一阶导数平方可积且在指定了狄利克雷条件的边界上值为零的函数组成。在本例中，$H^1_0(\\Omega) = \\{v \\in H^1(\\Omega) \\mid v(0)=0, v(1)=0\\}$。\n\n$$\n\\int_0^1 \\left( - \\epsilon u''(x) + \\beta u'(x) \\right) v(x) \\, dx = 0\n$$\n\n含有二阶导数的项通过分部积分来处理：\n$$\n\\int_0^1 - \\epsilon u''(x) v(x) \\, dx = - \\epsilon \\left[ u'(x) v(x) \\right]_0^1 + \\int_0^1 \\epsilon u'(x) v'(x) \\, dx\n$$\n由于 $v \\in H^1_0(\\Omega)$，我们有 $v(0)=0$ 和 $v(1)=0$。因此，边界项 $- \\epsilon [u'(x)v(x)]_0^1$ 为零。\n\n将此代入积分方程，得到弱形式：求一个函数 $u \\in H^1(\\Omega)$，满足狄利克雷边界条件 $u(0)=0$ 和 $u(1)=1$，使得对于所有检验函数 $v \\in H^1_0(\\Omega)$，下式成立：\n$$\n\\int_0^1 \\left( \\epsilon u'(x) v'(x) + \\beta u'(x) v(x) \\right) \\, dx = 0\n$$\n这可以简写为 $B(u, v) = 0$，其中 $B(u, v)$ 是与算子相关的双线性形式。\n\n#### 2. 伽辽金有限元离散化\n我们将定义域 $\\Omega=[0,1]$ 用一个包含 $N$ 个单元的均匀网格进行离散化，得到 $N+1$ 个节点 $x_i = i h$，$i \\in \\{0, 1, \\dots, N\\}$，其中网格尺寸为 $h = 1/N$。\n\n我们使用连续的分片线性基函数 $\\phi_i(x)$（帽函数）来近似解 $u(x)$：\n$$\nu_h(x) = \\sum_{j=0}^{N} U_j \\phi_j(x)\n$$\n其中 $U_j$ 是解在节点 $x_j$ 处的未知节点值，即 $U_j \\approx u(x_j)$。基函数 $\\phi_j(x)$ 具有性质 $\\phi_j(x_i) = \\delta_{ij}$（克罗内克符号）。\n\n离散伽辽金格式要求弱形式对有限维子空间 $V_h \\subset H^1_0(\\Omega)$ 中的所有检验函数都成立。该子空间由与内部节点相对应的基函数张成：$V_h = \\text{span}\\{\\phi_1, \\phi_2, \\dots, \\phi_{N-1}\\}$。\n\n伽辽金问题是：求 $u_h(x)$，其节点值为 $U_0=0$ 和 $U_N=1$，使得\n$$\n\\int_0^1 \\left( \\epsilon u_h'(x) v_h'(x) + \\beta u_h'(x) v_h(x) \\right) \\, dx = 0 \\quad \\forall v_h \\in V_h\n$$\n根据线性性质，此式必须对每个基函数 $v_h = \\phi_i(x)$（$i \\in \\{1, \\dots, N-1\\}$）都成立。代入 $u_h(x)$ 的展开式，得到一个线性方程组：\n$$\n\\sum_{j=0}^{N} U_j \\left( \\int_0^1 \\left( \\epsilon \\phi_j'(x) \\phi_i'(x) + \\beta \\phi_j'(x) \\phi_i(x) \\right) \\, dx \\right) = 0 \\quad \\text{for } i=1, \\dots, N-1\n$$\n这定义了一个线性系统 $A \\mathbf{U} = \\mathbf{F}$，其中 $\\mathbf{U} = [U_1, \\dots, U_{N-1}]^T$ 是未知内部节点值的向量。系统矩阵和右端项的条目是通过组装每个单元 $K_e = [x_{e-1}, x_e]$ 的贡献来构建的。在一个通用单元 $K_e$ 上，解由两个局部基函数 $N_1(\\xi) = 1 - \\xi/h$ 和 $N_2(\\xi) = \\xi/h$ 进行插值，其中 $\\xi = x-x_{e-1}$。单元矩阵 $A^e$ 的条目为 $A^e_{ij} = B(\\phi_j, \\phi_i)|_{K_e}$。局部导数为 $N_1' = -1/h$ 和 $N_2' = 1/h$。\n\n单元扩散（刚度）矩阵为：\n$$\nK^e = \\int_{K_e} \\epsilon N_i' N_j' \\, dx = \\frac{\\epsilon}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\n单元对流矩阵为：\n$$\nC^e = \\int_{K_e} \\beta N_j' N_i \\, dx = \\frac{\\beta}{2} \\begin{pmatrix} -1  1 \\\\ -1  1 \\end{pmatrix}\n$$\n伽辽金单元矩阵为 $A^e_{Gal} = K^e + C^e$：\n$$\nA^e_{Gal} = \\begin{pmatrix} \\frac{\\epsilon}{h} - \\frac{\\beta}{2}  -\\frac{\\epsilon}{h} + \\frac{\\beta}{2} \\\\ -\\frac{\\epsilon}{h} - \\frac{\\beta}{2}  \\frac{\\epsilon}{h} + \\frac{\\beta}{2} \\end{pmatrix}\n$$\n\n#### 3. 数值不稳定性与佩克莱数\n伽辽金方法，在本一维案例中等价于中心差分格式，在对流主导扩散时，容易产生非物理的、虚假的振荡。这是因为中心化模板与对流输运的方向性不一致。\n\n在单元级别，对流与扩散的相对强度由无量纲的**单元佩克莱数**来量化，其定义为：\n$$\nPe_h = \\frac{|\\beta| h}{2 \\epsilon}\n$$\n该数比较了单元对流“时间” ($h/|\\beta|$) 与单元扩散“时间” ($h^2/(2\\epsilon)$)。当 $Pe_h \\gg 1$ 时，对流占主导地位，伽辽金解变得不稳定，表现出违反物理单调性原则的振荡。通常只有在 $Pe_h \\le 1$ 时才能保证稳定性。\n\n#### 4. 流线迎风/彼得罗夫-伽辽金 (SUPG) 格式\n为了抵消这些振荡，在伽辽金格式中加入了一个稳定项。SUPG 方法通过富集检验空间来实现这一点。具体来说，每个检验函数 $v_h$ 都会受到一个与其在流线（对流）方向上的导数成比例的项的扰动。修改后的检验函数为 $\\tilde{v}_h = v_h + \\tau_e \\beta v_h'$，其中 $\\tau_e$ 是在每个单元 $K_e$ 上定义的稳定化参数。\n\n这种形式的动机来自基于残差的论证。精确解 $u$ 满足偏微分方程，因此其残差 $R(u) = -\\epsilon u'' + \\beta u' = 0$。离散解 $u_h$ 不满足，因此其单元残差非零。对于分片线性单元，在每个单元内部 $u_h''=0$，因此残差简化为 $R(u_h)|_{K_e} = \\beta u_h'$。SUPG 方法在弱形式中增加了一项，该项是此残差与检验函数扰动项相乘的积分：\n$$\nB_{SUPG}(u_h, v_h) = B_{Gal}(u_h, v_h) + \\sum_{e=1}^N \\int_{K_e} (\\beta u_h')(\\tau_e \\beta v_h') \\, dx = 0\n$$\n完整的稳定化弱形式是：\n$$\n\\int_0^1 \\left( \\epsilon u_h' v_h' + \\beta u_h' v_h \\right) \\, dx + \\sum_{e=1}^N \\int_{K_e} \\tau_e \\beta^2 u_h' v_h' \\, dx = 0\n$$\n稳定项引入了一个人工扩散 $\\tau_e \\beta^2$，它仅沿流线方向作用，因此常被称为流线扩散。该方法是相容的，因为附加项依赖于残差，而残差对于精确解来说为零。\n\n单元稳定化矩阵为：\n$$\nS^e = \\int_{K_e} \\tau_e \\beta^2 N_i' N_j' \\, dx = \\frac{\\tau_e \\beta^2}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\nSUPG 单元矩阵为 $A^e_{SUPG} = A^e_{Gal} + S^e$。\n\n稳定化参数 $\\tau_e$ 必须仔细选择。在一维情况下，一个能够产生节点精确解的最优选择被推导为单元佩克莱数的函数：\n$$\n\\tau_e = \\frac{h}{2|\\beta|} \\xi(Pe_h) \\quad \\text{其中} \\quad \\xi(Pe_h) = \\coth(Pe_h) - \\frac{1}{Pe_h}\n$$\n该形式具有正确的渐近行为：\n- **对流主导极限 ($Pe_h \\to \\infty$)：** $\\coth(Pe_h) \\to 1$，因此 $\\xi(Pe_h) \\to 1$。这得到 $\\tau_e \\to \\frac{h}{2|\\beta|}$。人工扩散变为 $\\tau_e \\beta^2 = \\frac{|\\beta|h}{2}$，这恢复了一阶迎风格式。\n- **扩散主导极限 ($Pe_h \\to 0$)：** 使用泰勒展开 $\\coth(x) \\approx 1/x + x/3$，我们得到 $\\xi(Pe_h) \\approx Pe_h/3$。这得到 $\\tau_e \\approx \\frac{h}{2|\\beta|} \\frac{Pe_h}{3} = \\frac{h^2}{12\\epsilon}$。人工扩散 $\\tau_e \\beta^2 = \\frac{h^2 \\beta^2}{12\\epsilon}$ 在 $Pe_h \\to 0$ 时趋于零，恢复为标准的伽辽金方法。\n对于 $\\beta=0$ 的情况，佩克莱数为 $0$，稳定项 $\\tau_e\\beta^2$ 显然为零，因此 SUPG 正确地退化为伽辽金方法。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection-diffusion problem using Galerkin FEM and SUPG-FEM,\n    and analyzes the monotonicity of the solutions for different regimes.\n    \"\"\"\n\n    test_cases = [\n        # (N, beta, epsilon)\n        (100, 1.0, 1e-2),\n        (40, 1.0, 5e-3),\n        (50, 1.0, 1e-4),\n        (50, 0.0, 1e-2),\n    ]\n\n    results = []\n    for N, beta, epsilon in test_cases:\n        # 1. Calculate problem parameters\n        h = 1.0 / N\n        # The Peclet number is constant over the uniform mesh\n        # Handle the case epsilon > 0 but beta=0, where Pe=0.\n        if abs(beta) < 1e-12 or epsilon == 0:\n            pe_max = 0.0\n        else:\n            pe_max = abs(beta) * h / (2 * epsilon)\n\n        # 2. Solve using Galerkin and SUPG methods\n        sol_galerkin = run_fem_solver(N, beta, epsilon, supg=False)\n        sol_supg = run_fem_solver(N, beta, epsilon, supg=True)\n\n        # 3. Perform monotonicity check\n        tol = -1e-12\n        mono_galerkin = np.all(np.diff(sol_galerkin) >= tol)\n        mono_supg = np.all(np.diff(sol_supg) >= tol)\n\n        # 4. Store results\n        results.append([pe_max, bool(mono_galerkin), bool(mono_supg)])\n    \n    # Final output formatting\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_fem_solver(N, beta, epsilon, supg):\n    \"\"\"\n    Assembles and solves the linear system for the 1D advection-diffusion\n    equation using either standard Galerkin or SUPG stabilization.\n\n    Args:\n        N (int): Number of elements.\n        beta (float): Advection coefficient.\n        epsilon (float): Diffusion coefficient.\n        supg (bool): If True, use SUPG stabilization.\n\n    Returns:\n        np.array: The full solution vector of nodal values, including boundaries.\n    \"\"\"\n    h = 1.0 / N\n    \n    # Calculate stabilization parameter tau for SUPG\n    tau = 0.0\n    if supg and abs(beta) > 1e-12:\n        pe_h = abs(beta) * h / (2.0 * epsilon)\n        # Use Taylor expansion for coth(x) - 1/x for small x to avoid overflow/underflow\n        if pe_h < 1e-8:\n            xi_pe = pe_h / 3.0\n        else:\n            xi_pe = 1.0 / np.tanh(pe_h) - 1.0 / pe_h\n\n        tau = (h / (2.0 * abs(beta))) * xi_pe\n        \n    # Element matrix coefficients\n    # A_e = [[a11, a12], [a21, a22]]\n    # Diffusion part\n    k11 = epsilon / h\n    k12 = -epsilon / h\n    # Advection part\n    c11 = -beta / 2.0\n    c12 = beta / 2.0\n    # Stabilization part (artificial diffusion)\n    s11 = tau * beta**2 / h\n    s12 = -tau * beta**2 / h\n    \n    # Assemble element matrix A_e\n    a11 = k11 + c11 + s11\n    a12 = k12 + c12 + s12\n    a21 = k12 - c12 + s12 # Uses symmetry in diffusion and stab, anti-symm in advection\n    a22 = k11 - c11 + s11\n\n    # Assemble the (N-1)x(N-1) global system for interior nodes\n    num_unknowns = N - 1\n    if num_unknowns == 0:\n        return np.array([0.0, 1.0])\n\n    A_glob = np.zeros((num_unknowns, num_unknowns))\n\n    # Diagonal entries\n    diag_val = a22 + a11\n    np.fill_diagonal(A_glob, diag_val)\n\n    # Super-diagonal entries\n    if num_unknowns > 1:\n        super_diag_val = a12\n        np.fill_diagonal(A_glob[0:, 1:], super_diag_val)\n\n    # Sub-diagonal entries\n    if num_unknowns > 1:\n        sub_diag_val = a21\n        np.fill_diagonal(A_glob[1:, 0:], sub_diag_val)\n\n    # Construct the right-hand side vector F\n    # F is zero everywhere except for the last entry due to u(1)=1 BC\n    F_glob = np.zeros(num_unknowns)\n    F_glob[-1] = -a12 * 1.0 # u(N) = 1\n\n    # Solve the linear system A*U_int = F for interior nodes U_int\n    try:\n        U_interior = np.linalg.solve(A_glob, F_glob)\n    except np.linalg.LinAlgError:\n        # In extreme cases, the matrix might be singular. Return a non-monotone array.\n        U_interior = np.full(num_unknowns, np.nan)\n\n    # Combine with boundary conditions to form the full solution vector\n    U_full = np.concatenate(([0.0], U_interior, [1.0]))\n\n    return U_full\n\n\nsolve()\n```"
        },
        {
            "introduction": "在第一个练习中，我们看到了 SUPG 方法的有效性，但其稳定化参数 $\\tau$ 的形式似乎有些“从天而降”。本练习旨在揭示其深刻的理论根源。你将从伴随算子的格林函数出发，一步步推导出“最优”的稳定化参数，并将其与经典的简化版 SUPG 参数进行比较，从而理解理论推导如何为设计更精确、更鲁棒的数值格式提供指导。",
            "id": "3447447",
            "problem": "考虑单位区间上的稳态一维对流-扩散边界值问题，其带有狄利克雷边界条件：\n$$\n-\\varepsilon\\,u''(x) + \\beta\\,u'(x) = f(x)\\quad\\text{for }x\\in(0,1),\\qquad u(0)=0,\\quad u(1)=1,\n$$\n其中 $\\varepsilon>0$ 是扩散系数，$\\beta>0$ 是恒定的对流速度，且 $f(x)=0$。令 $\\mathcal{L}u=-\\varepsilon u''+\\beta u'$ 表示微分算子，$\\mathcal{L}^\\ast w=-\\varepsilon w''-\\beta w'$ 为其在平方可积函数空间的标准内积下的形式伴随算子。\n\n您将使用 $[0,1]$ 上包含 $N$ 个单元的均匀网格、分片线性试验函数以及彼得罗夫-伽辽金方法。目标是基于伴随算子的精确单元格林函数，在每个单元上推导并使用一个彼得罗夫-伽辽金检验函数，并将所得的离散方法与边界层问题上的经典流线迎风彼得罗夫-伽辽金 (SUPG) 稳定化方法进行比较。\n\n从以下基本概念和事实出发：\n- 弱形式是通过将微分方程乘以一个检验函数并在整个区域上积分得到的。\n- 一个算子的格林函数 $G(x,\\xi)$ 求解 $\\mathcal{L}^\\ast_x G(x,\\xi)=\\delta(x-\\xi)$ 并满足适当的齐次边界条件，它表示在 $x$ 点对位于 $\\xi$ 点的点源的响应。\n- 在均匀网格的每个单元上，对于常数 $\\varepsilon$ 和 $\\beta$，限制在该单元上的伴随算子的格林函数是一个指数函数的线性组合，它满足由delta分布决定的连续性和跳跃条件。\n- 在彼得罗夫-伽辽金方法中，最优局部检验函数可以通过将试验基与伴随算子的局部格林函数进行卷积来构造。\n\n任务：\n1. 在一个长度为 $h$ 的通用单元上，推导伴随算子 $\\mathcal{L}^\\ast w=-\\varepsilon w''-\\beta w'$ 在单元端点处具有齐次狄利克雷边界条件下的精确单元格林函数。然后，使用此格林函数构造与分片线性试验函数 $\\phi$ 相关联的相应彼得罗夫-伽辽金检验函数 $\\tilde{w}$。证明这将对标准伽辽金双线性形式产生一个修正，该修正可表示为一个逐单元的附加项，形式如下\n$$\n\\sum_{e} \\tau_e\\,\\beta^2 \\int_{e} u'(x)\\,v'(x)\\,dx,\n$$\n其中 $u$ 是试验函数，$v$ 是标准检验函数，$\\tau_e$ 是一个标量稳定化参数，它依赖于局部网格佩克莱数 $Pe_e=\\dfrac{\\beta h}{2\\varepsilon}$。\n2. 确定由这种基于精确格林函数的彼得罗夫-伽辽金构造所产生的稳定化参数 $\\tau_e$ 的显式公式，用 $h$、$\\beta$、$\\varepsilon$ 和 $Pe_e$ 表示。您的推导应从单元上的精确格林函数出发，并且不得假定任何已知的稳定化公式。\n3. 在均匀网格上使用分片线性试验函数实现两种数值格式：\n   - 方案A (格林-彼得罗夫-伽辽金)：使用任务1中的稳定化形式，以及您在任务2中推导出的 $\\tau_e$。\n   - 方案B (经典SUPG)：使用相同的离散形式，但采用启发式的经典选择 $\\tau_e=\\dfrac{h}{2\\beta}$，这对应于大佩克莱数极限，并在实践中常用。\n4. 对于每种方案，组装全局线性系统，施加狄利克雷边界条件 $u(0)=0$ 和 $u(1)=1$，并求解 $u$ 的节点值。\n5. 为了评估，使用 $f(x)=0$ 和 $\\beta>0$ 时的精确解\n$$\nu_{\\mathrm{exact}}(x)=\\frac{e^{\\beta x/\\varepsilon}-1}{e^{\\beta/\\varepsilon}-1},\n$$\n并在网格节点上计算均方根误差\n$$\nE_{\\mathrm{RMS}} = \\left(\\frac{1}{M}\\sum_{i=0}^{M-1}\\big(u_i - u_{\\mathrm{exact}}(x_i)\\big)^2\\right)^{1/2},\n$$\n其中 $M=N+1$ 是节点数，$x_i$ 是节点坐标，$u_i$ 是节点上的数值解。同时计算狄利克雷界限的违背量\n$$\nV = \\max\\{0,\\ \\max_i u_i - 1\\} + \\max\\{0,\\ 0 - \\min_i u_i\\}.\n$$\n这个 $V$ 度量了节点处任何超过 $1$ 的上冲和低于 $0$ 的下冲。\n\n测试套件：\n- 案例1：$\\varepsilon=10^{-2}$，$\\beta=1$，$N=50$。\n- 案例2：$\\varepsilon=10^{-4}$，$\\beta=1$，$N=100$。\n- 案例3：$\\varepsilon=10^{-2}$，$\\beta=1$，$N=10$。\n- 案例4：$\\varepsilon=1$，$\\beta=1$，$N=10$。\n\n您的程序必须为每个案例按顺序计算四个数 $[E_{\\mathrm{RMS}}^{\\mathrm{Green}}, E_{\\mathrm{RMS}}^{\\mathrm{SUPG}}, V^{\\mathrm{Green}}, V^{\\mathrm{SUPG}}]$，并将所有案例的结果汇总到单行输出中，格式为逗号分隔的列表的列表，并用方括号括起，例如 $[[a,b,c,d],[\\dots],\\dots]$。\n\n所有量均为无量纲；输出中不包含任何单位。不涉及角度。不涉及百分比。\n\n您的最终提交必须是一个单一、完整、可运行的程序，该程序实现两种方案，评估测试套件，并以指定的确切格式打印最终结果。",
            "solution": "该问题是有效的，因为它提出了一个在偏微分方程数值方法领域中适定且有科学依据的问题。所有必要的数据和定义都已提供，并且各项任务构成了从理论推导到数值实现和评估的逻辑递进。\n\n我们首先按照任务1和任务2的规定，为彼得罗夫-伽辽金方法推导稳定化参数 $\\tau_e$。后续部分将详细介绍数值实现和评估。\n\n### 稳定化参数 $\\tau_e$ 的推导\n\n一维对流-扩散问题由下式给出：\n$$ \\mathcal{L}u = -\\varepsilon u''(x) + \\beta u'(x) = 0 \\quad \\text{for } x \\in (0,1) $$\n边界条件为 $u(0)=0$ 和 $u(1)=1$。标准的弱形式通过乘以一个检验函数 $v$ 并进行分部积分得到，其要求找到 $u \\in H^1_E$，使得对于所有 $v \\in H^1_0$：\n$$ B(u, v) = \\int_0^1 (\\varepsilon u'(x)v'(x) + \\beta u'(x)v(x))\\,dx = 0 $$\n在使用分片线性基函数 $\\{\\phi_i\\}$ 的标准伽辽金有限元方法中，试验函数 $u_h$ 和检验函数 $v_h$ 都取自同一空间 $V_h = \\text{span}\\{\\phi_i\\}$。已知这种方法在处理对流占优问题（即 $\\varepsilon$ 相对于 $\\beta h$ 很小）时会产生伪振荡。\n\n彼得罗夫-伽辽金方法使用一个与试验空间 $V_h$ 不同的检验空间 $W_h$。稳定化方法的一种常见构造是将检验函数定义为 $w = v + \\delta_v$，其中 $v \\in V_h$，而 $\\delta_v$ 是一个为增加稳定性而设计的修正项。弱形式变为 $B(u_h, w_h) = B(u_h, v_h) + B(u_h, \\delta_v) = 0$。附加项 $B(u_h, \\delta_v)$ 提供了稳定化效果。\n\n在像SUPG或GGLS这样基于残差的方法中，修正项 $\\delta_v$ 被构造成作用于强形式方程的残差 $\\mathcal{L}u_h$。对于分片线性试验函数 $u_h$，其二阶导数 $u_h''$ 在每个单元内部为零，因此单元残差就是 $\\mathcal{L}u_h = \\beta u_h'$。添加到弱形式中的稳定化项通常是 $\\sum_e \\int_e \\delta_v (\\mathcal{L}u_h) dx$，其中修正项选择为 $\\delta_v = \\tau_e \\mathcal{L}v = \\tau_e \\beta v'$。这产生附加项：\n$$ \\sum_{e} \\int_{e} (\\tau_e \\beta v'(x)) (\\beta u'(x)) \\,dx = \\sum_{e} \\tau_e\\,\\beta^2 \\int_{e} u'(x)\\,v'(x)\\,dx $$\n这与问题陈述中给出的形式相符。我们的目标是使用伴随算子 $\\mathcal{L}^\\ast w = -\\varepsilon w'' - \\beta w'$ 的单元格林函数来推导“最优”稳定化参数 $\\tau_e$。\n\n最优检验函数理论（与无残差气泡函数相关）指出，单元 $K_e$ 上的修正项 $\\delta_v$ 应该是以检验函数 $v$ 的单元残差为源项的局部伴随问题的解：\n$$ \\mathcal{L}^\\ast \\delta_v = \\mathcal{L}v \\quad \\text{on } K_e, \\qquad \\delta_v = 0 \\quad \\text{on } \\partial K_e $$\n该问题的解可以使用算子 $\\mathcal{L}^\\ast$ 在单元 $K_e$ 上的单元格林函数 $G_e(x, \\xi)$ 来表示：\n$$ \\delta_v(x) = \\int_{K_e} G_e(x, \\xi) (\\mathcal{L}v)(\\xi) \\,d\\xi $$\n对于长度为 $h$ 的单元上的线性检验函数 $v$，$v''=0$ 且 $v'$ 是一个常数。因此，$\\mathcal{L}v = \\beta v'$。稳定化项变为：\n$$ \\int_{K_e} (\\mathcal{L}u_h) \\delta_v(x) \\,dx = \\int_{K_e} (\\beta u') \\left( \\int_{K_e} G_e(x, \\xi) (\\beta v') \\,d\\xi \\right) \\,dx $$\n由于对于分片线性函数，$u'$ 和 $v'$ 在单元上是常数，我们可以写出：\n$$ \\beta^2 u' v' \\int_{K_e} \\int_{K_e} G_e(x, \\xi) \\,d\\xi \\,dx = \\tau_e \\beta^2 \\int_{K_e} u' v' \\,dx = \\tau_e \\beta^2 u' v' h $$\n由此，我们将稳定化参数 $\\tau_e$ 确定为：\n$$ \\tau_e = \\frac{1}{h} \\int_{K_e} \\int_{K_e} G_e(x, \\xi) \\,d\\xi \\,dx $$\n为了找到 $\\tau_e$，我们可以避免对 $G_e(x, \\xi)$ 的二重积分进行直接而繁琐的计算。令 $I(x) = \\int_{K_e} G_e(x, \\xi) \\,d\\xi$。将算子 $\\mathcal{L}^\\ast$ 应用于 $I(x)$ 得到：\n$$ \\mathcal{L}^\\ast I(x) = \\int_{K_e} \\mathcal{L}^\\ast_x G_e(x, \\xi) \\,d\\xi = \\int_{K_e} \\delta(x-\\xi) \\,d\\xi = 1 \\quad \\text{for } x \\in K_e $$\n$G_e$ 的边界条件意味着 $I(x)$ 在单元边界处也必须为零。设单元为 $[0, h]$。我们求解以下辅助边界值问题：\n$$ -\\varepsilon I''(x) - \\beta I'(x) = 1 \\quad \\text{for } x \\in (0,h), \\qquad I(0)=0,\\quad I(h)=0 $$\n齐次方程 $-\\varepsilon w'' - \\beta w' = 0$ 的通解是 $w_h(x) = C_1 + C_2 e^{-\\beta x/\\varepsilon}$。完整方程的一个特解是 $w_p(x) = -x/\\beta$。因此，$I(x)$ 的通解是 $I(x) = C_1 + C_2 e^{-\\beta x/\\varepsilon} - x/\\beta$。\n应用边界条件：\n$I(0) = 0 \\implies C_1 + C_2 = 0 \\implies C_1 = -C_2$。\n$I(h) = 0 \\implies C_1 + C_2 e^{-\\beta h/\\varepsilon} - h/\\beta = 0$。\n代入 $C_1 = -C_2$ 得到 $C_2(e^{-\\beta h/\\varepsilon} - 1) = h/\\beta$，所以 $C_2 = \\frac{h/\\beta}{e^{-\\beta h/\\varepsilon}-1}$。\n这得到 $I(x) = \\frac{h/\\beta}{1-e^{-\\beta h/\\varepsilon}}(1 - e^{-\\beta x/\\varepsilon}) - x/\\beta$。\n\n现在，我们计算 $\\tau_e = \\frac{1}{h} \\int_0^h I(x)\\,dx$：\n$$ \\tau_e h = \\int_0^h \\left( \\frac{h/\\beta}{1-e^{-\\beta h/\\varepsilon}}(1 - e^{-\\beta x/\\varepsilon}) - \\frac{x}{\\beta} \\right) dx $$\n$$ \\tau_e h = \\frac{h/\\beta}{1-e^{-\\beta h/\\varepsilon}} \\left[x + \\frac{\\varepsilon}{\\beta}e^{-\\beta x/\\varepsilon}\\right]_0^h - \\frac{1}{\\beta}\\left[\\frac{x^2}{2}\\right]_0^h $$\n$$ \\tau_e h = \\frac{h/\\beta}{1-e^{-\\beta h/\\varepsilon}} \\left( \\left(h+\\frac{\\varepsilon}{\\beta}e^{-\\beta h/\\varepsilon}\\right) - \\left(0+\\frac{\\varepsilon}{\\beta}\\right) \\right) - \\frac{h^2}{2\\beta} $$\n$$ \\tau_e h = \\frac{h/\\beta}{1-e^{-\\beta h/\\varepsilon}} \\left( h - \\frac{\\varepsilon}{\\beta}(1-e^{-\\beta h/\\varepsilon}) \\right) - \\frac{h^2}{2\\beta} $$\n$$ \\tau_e h = \\frac{h^2/\\beta}{1-e^{-\\beta h/\\varepsilon}} - \\frac{h\\varepsilon}{\\beta^2} - \\frac{h^2}{2\\beta} = \\frac{h^2}{2\\beta} \\left( \\frac{2}{1-e^{-\\beta h/\\varepsilon}} - 1 \\right) - \\frac{h\\varepsilon}{\\beta^2} $$\n令 $s = \\beta h/\\varepsilon = 2Pe_e$，其中 $Pe_e$ 是单元佩克莱数。\n$$ \\tau_e = \\frac{h}{2\\beta} \\left( \\frac{2}{1-e^{-s}} - 1 \\right) - \\frac{\\varepsilon}{\\beta^2} = \\frac{h}{2\\beta} \\left( \\frac{2 - (1-e^{-s})}{1-e^{-s}} \\right) - \\frac{\\varepsilon}{\\beta^2} = \\frac{h}{2\\beta} \\frac{1+e^{-s}}{1-e^{-s}} - \\frac{\\varepsilon}{\\beta^2} $$\n使用恒等式 $\\coth(y) = \\frac{e^y+e^{-y}}{e^y-e^{-y}} = \\frac{1+e^{-2y}}{1-e^{-2y}}$，我们有 $\\frac{1+e^{-s}}{1-e^{-s}} = \\coth(s/2) = \\coth(Pe_e)$。\n所以，$\\tau_e = \\frac{h}{2\\beta}\\coth(Pe_e) - \\frac{\\varepsilon}{\\beta^2}$。\n为了匹配标准形式，我们注意到 $\\frac{1}{Pe_e} = \\frac{2\\varepsilon}{\\beta h}$。那么 $\\frac{\\varepsilon}{\\beta^2} = \\frac{h}{2\\beta} \\frac{2\\varepsilon}{h\\beta} = \\frac{h}{2\\beta} \\frac{1}{Pe_e}$。\n最终，我们得到稳定化参数的显式公式：\n$$ \\tau_e = \\frac{h}{2\\beta} \\left( \\coth(Pe_e) - \\frac{1}{Pe_e} \\right) $$\n这个表达式被称为Hughes参数。当 $Pe_e \\to \\infty$（对流占优极限）时，$\\coth(Pe_e) \\to 1$ 且 $1/Pe_e \\to 0$，因此 $\\tau_e \\to \\frac{h}{2\\beta}$。这正是方案B中使用的经典SUPG参数，该参数仅在大佩克莱数极限下是最优的。对于小的 $Pe_e$，泰勒展开给出 $\\coth(Pe_e) - 1/Pe_e \\approx Pe_e/3$，因此 $\\tau_e \\approx \\frac{h}{2\\beta} \\frac{Pe_e}{3} = \\frac{h^2}{12\\varepsilon}$，这适当地缩减了人工扩散。\n\n### 数值实现细节\n\n有限元方法在包含 $N$ 个单元的均匀网格上实现，单元尺寸为 $h=1/N$。解由分片线性基函数的线性组合近似，$u_h(x) = \\sum_{j=0}^{N} U_j \\phi_j(x)$，其中 $U_j$ 是待确定的节点值。\n\n单元上的局部 $2 \\times 2$ 单元矩阵 $A^e$ 是标准扩散、对流和稳定化矩阵的总和：\n$A^e = K^e + C^e + S^e$，其中\n$$ K^e = \\frac{\\varepsilon}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}, \\quad C^e = \\frac{\\beta}{2} \\begin{pmatrix} -1  1 \\\\ -1  1 \\end{pmatrix}, \\quad S^e = \\frac{\\tau_e \\beta^2}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} $$\n这些矩阵被组装成一个全局 $(N+1) \\times (N+1)$ 矩阵 $A$。由于源项 $f(x)=0$，右端向量 $F$ 初始为零。\n\n狄利克雷边界条件 $u(0)=U_0=0$ 和 $u(1)=U_N=1$ 通过修改线性系统来施加。我们求解 $N-1$ 个内部未知数 $U_1, \\dots, U_{N-1}$。该系统由全局矩阵的子矩阵 $A_{1:N, 1:N}$ 构成。调整右端向量以考虑已知值 $U_N=1$，这会影响 $U_{N-1}$ 的方程。内部节点的系统变为 $A_{int} U_{int} = F_{int}$，使用标准线性求解器求解。最终的解向量通过组合计算出的内部值和已知的边界值来构造。\n\n实现了两种方案：方案A使用推导出的“最优”$\\tau_e$，而方案B使用经典的SUPG参数 $\\tau_e = h/(2\\beta)$。误差是相对于提供的精确解计算的。在实现中要特别注意处理数值问题，例如在非常小的 $Pe_e$ 处对 $\\tau_e$ 使用泰勒级数近似，以及在非常大的全局佩克莱数下对精确解使用渐近形式以防止浮点溢出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not used as per the problem constraints.\n\ndef coth(x: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the hyperbolic cotangent element-wise.\n    \n    Args:\n        x: Input array.\n\n    Returns:\n        The hyperbolic cotangent of the input.\n    \"\"\"\n    return np.cosh(x) / np.sinh(x)\n\ndef solve_fem(eps: float, beta: float, N: int, tau: float) -> np.ndarray:\n    \"\"\"\n    Solves the 1D advection-diffusion problem using the Finite Element Method\n    with a given stabilization parameter tau.\n\n    Args:\n        eps: Diffusion coefficient.\n        beta: Advection speed.\n        N: Number of elements.\n        tau: Stabilization parameter.\n\n    Returns:\n        The numerical solution at the mesh nodes.\n    \"\"\"\n    h = 1.0 / N\n    M = N + 1  # Number of nodes\n\n    # --- Element Stiffness Matrix ---\n    # Standard diffusion matrix component\n    K_e = (eps / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n    # Standard advection matrix component\n    C_e = (beta / 2.0) * np.array([[-1.0, 1.0], [-1.0, 1.0]])\n    # Stabilization matrix component\n    S_e = (tau * beta**2 / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n    \n    # Total element stiffness matrix\n    A_e = K_e + C_e + S_e\n\n    # --- Assembly ---\n    # Assemble the global stiffness matrix A\n    A = np.zeros((M, M))\n    for k in range(N):  # Iterate through elements 0 to N-1\n        # Global indices for the element are k and k+1\n        i, j = k, k + 1\n        A[i, i] += A_e[0, 0]\n        A[i, j] += A_e[0, 1]\n        A[j, i] += A_e[1, 0]\n        A[j, j] += A_e[1, 1]\n\n    # --- Boundary Conditions and Solution ---\n    # We solve for the N-1 interior nodes U_1, ..., U_{N-1}.\n    # The linear system is defined by the interior part of the global matrix.\n    A_internal = A[1:N, 1:N]\n    F_internal = np.zeros(N - 1)\n    \n    # Boundary conditions: u(0) = 0 and u(1) = 1.\n    # The equation for U_1: A[1,0]U_0 + A[1,1]U_1 + A[1,2]U_2 = 0.\n    # Since U_0=0, the RHS is not modified.\n    #\n    # The equation for U_{N-1}: A[N-1,N-2]U_{N-2} + A[N-1,N-1]U_{N-1} + A[N-1,N]U_N = 0.\n    # Since U_N=1, this becomes: A[N-1,N-2]U_{N-2} + A[N-1,N-1]U_{N-1} = -A[N-1,N].\n    # So, we modify the last entry of the internal RHS vector.\n    F_internal[-1] -= A[N - 1, N] * 1.0\n    \n    # Solve the linear system for interior nodes\n    try:\n        U_internal = np.linalg.solve(A_internal, F_internal)\n    except np.linalg.LinAlgError:\n        return np.full(M, np.nan)\n\n    # Reconstruct the full solution vector U including boundaries\n    U = np.zeros(M)\n    U[0] = 0.0\n    U[N] = 1.0\n    U[1:N] = U_internal\n    \n    return U\n\ndef solve_case(eps: float, beta: float, N: int) -> list[float]:\n    \"\"\"\n    Computes the specified error metrics for a given test case for both\n    Green-Petrov-Galerkin and classic SUPG schemes.\n\n    Args:\n        eps: Diffusion coefficient.\n        beta: Advection speed.\n        N: Number of elements.\n\n    Returns:\n        A list containing [E_rms_Green, E_rms_SUPG, V_Green, V_SUPG].\n    \"\"\"\n    h = 1.0 / N\n    M = N + 1  # Number of nodes\n    nodes = np.linspace(0.0, 1.0, M)\n\n    # --- Scheme A: Green-Petrov-Galerkin (Optimal tau) ---\n    Pe = (beta * h) / (2.0 * eps)\n    # Use Taylor expansion for small Pe to avoid numerical instability of coth(x) - 1/x\n    if Pe < 1e-8:\n        # For small x, coth(x) - 1/x ≈ x/3\n        tau_A = (h / (2.0 * beta)) * (Pe / 3.0) \n    else:\n        tau_A = (h / (2.0 * beta)) * (coth(Pe) - 1.0 / Pe)\n    \n    U_A = solve_fem(eps, beta, N, tau_A)\n\n    # --- Scheme B: Classic SUPG (High-Pe limit tau) ---\n    tau_B = h / (2.0 * beta)\n    U_B = solve_fem(eps, beta, N, tau_B)\n\n    # --- Error Calculation ---\n    # Exact solution\n    Peclet_global = beta / eps\n    # Use asymptotic approximation for large Peclet_global to avoid np.exp overflow\n    if Peclet_global > 700: \n        u_exact = np.exp(Peclet_global * (nodes - 1.0))\n        u_exact[-1] = 1.0  # Ensure BC is met exactly\n    else:\n        num = np.exp(Peclet_global * nodes) - 1.0\n        den = np.exp(Peclet_global) - 1.0\n        if den == 0: den = 1e-16 # Avoid division by zero for very small Peclet_global\n        u_exact = num / den\n\n    # Root Mean Square Error\n    E_rms_A = np.sqrt(np.mean((U_A - u_exact)**2))\n    E_rms_B = np.sqrt(np.mean((U_B - u_exact)**2))\n\n    # Violation of discrete maximum principle (overshoot/undershoot)\n    V_A = max(0.0, np.max(U_A) - 1.0) + max(0.0, 0.0 - np.min(U_A))\n    V_B = max(0.0, np.max(U_B) - 1.0) + max(0.0, 0.0 - np.min(U_B))\n    \n    return [E_rms_A, E_rms_B, V_A, V_B]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results in the specified format.\n    \"\"\"\n    test_cases = [\n        (1e-2, 1.0, 50),\n        (1e-4, 1.0, 100),\n        (1e-2, 1.0, 10),\n        (1.0, 1.0, 10)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        eps, beta, N = case\n        results_case = solve_case(eps, beta, N)\n        all_results.append(results_case)\n\n    # Format the output string as a list of lists of numbers.\n    list_of_strings = [f\"[{','.join(f'{x:.6e}' for x in item)}]\" for item in all_results]\n    final_output = f\"[{','.join(list_of_strings)}]\"\n    \n    # The final print statement must produce ONLY the specified output string.\n    print(final_output)\n\nsolve()\n\n```"
        },
        {
            "introduction": "一维问题上的成功并不能完全保证在更复杂的多维情况下的有效性。当流动方向与网格轴线不一致时，标准的 SUPG 方法会产生新的问题，即“交叉风”方向上的伪振荡。本练习将带你进入二维世界，通过量化交叉风伪影，比较 SUPG 和伽辽金/最小二乘 (GLS) 方法的性能，并探索添加人工交叉风扩散的效果，从而对多维问题中稳定化方法的挑战与策略有更深入的认识。",
            "id": "3447460",
            "problem": "考虑在单位正方形区域 $[0,1]\\times[0,1]$ 上设定的稳态线性平流-扩散方程，\n$$ \\boldsymbol{b}\\cdot\\nabla u - \\varepsilon \\Delta u = 0 \\quad \\text{in } \\Omega, $$\n其本质边界条件选择如下：在边界的流入部分（其中外单位法向量 $\\boldsymbol{n}$ 满足 $\\boldsymbol{b}\\cdot \\boldsymbol{n} < 0$），规定 $u=1$；在流出部分（$\\boldsymbol{b}\\cdot \\boldsymbol{n} \\ge 0$），规定 $u=0$。向量 $\\boldsymbol{b}$ 是一个与网格轴不对齐的常数，扩散系数 $\\varepsilon > 0$ 很小。\n\n您将使用标准的连续 Galerkin 有限元方法，在轴对齐矩形的结构化各向异性网格上，采用二次 Lagrange 基函数对该问题进行离散化，并比较两种稳定化格式：流线迎风/Petrov-Galerkin (SUPG) 和 Galerkin/最小二乘 (GLS) 方法。此外，您还将量化添加横风扩散（垂直于流动方向的人工扩散）对横风振荡的影响。\n\n变分基础始于弱形式：寻找满足条件的 $u \\in H^1(\\Omega)$\n$$ a(u,v) = 0 \\quad \\forall v \\in H^1_0(\\Omega), $$\n其中\n$$ a(u,v) = \\int_{\\Omega} \\varepsilon \\nabla u \\cdot \\nabla v \\, d\\Omega + \\int_{\\Omega} (\\boldsymbol{b}\\cdot \\nabla u) v \\, d\\Omega. $$\n\n稳定化格式通过在每个网格单元 $\\Omega_e$ 上逐单元地添加项来修正 $a(u,v)$：\n- 流线迎风/Petrov-Galerkin (SUPG)：添加\n$$ s_{\\mathrm{SUPG}}(u,v) = \\sum_{e} \\int_{\\Omega_e} \\tau_e \\, (\\boldsymbol{b}\\cdot \\nabla u)\\, (\\boldsymbol{b}\\cdot \\nabla v) \\, d\\Omega. $$\n- Galerkin/最小二乘 (GLS)：添加\n$$ s_{\\mathrm{GLS}}(u,v) = \\sum_{e} \\int_{\\Omega_e} \\tau_e \\, r(u)\\, r(v)\\, d\\Omega, \\quad r(w) := \\boldsymbol{b}\\cdot \\nabla w - \\varepsilon \\Delta w. $$\n\n横风扩散通过一个垂直于流动方向的张量项来增强物理扩散。令 $\\widehat{\\boldsymbol{b}} = \\boldsymbol{b}/\\|\\boldsymbol{b}\\|$，并定义到横风子空间上的正交投影算子\n$$ \\mathbf{P}_{\\perp} = \\mathbf{I} - \\widehat{\\boldsymbol{b}}\\, \\widehat{\\boldsymbol{b}}^\\top. $$\n对于横风扩散系数 $\\mu_{\\perp} \\ge 0$，添加\n$$ d_{\\perp}(u,v) = \\int_{\\Omega} \\mu_{\\perp}\\, (\\nabla u)^\\top \\mathbf{P}_{\\perp}\\, \\nabla v \\, d\\Omega. $$\n\n在矩形上使用二次 ($Q_2$) Lagrange 有限元，其标准参考节点位于 $\\xi, \\eta \\in \\{-1, 0, 1\\}$，一维基函数为\n$$ \\ell_{-1}(\\xi) = \\tfrac{1}{2}\\xi(\\xi - 1), \\quad \\ell_0(\\xi) = 1 - \\xi^2, \\quad \\ell_{+1}(\\xi) = \\tfrac{1}{2}\\xi(\\xi + 1), $$\n其导数为 $\\ell'_{-1}(\\xi) = \\xi - \\tfrac{1}{2}$、$\\ell'_0(\\xi) = -2\\xi$、$\\ell'_{+1}(\\xi) = \\xi + \\tfrac{1}{2}$，二阶导数为 $\\ell''_{-1}(\\xi) = 1$、$\\ell''_0(\\xi) = -2$、$\\ell''_{+1}(\\xi) = 1$。在每个物理尺寸为 $h_x$ 和 $h_y$ 的单元上，形函数的梯度和拉普拉斯算子通过仿射映射 $(\\xi,\\eta)\\mapsto (x,y)$ 获得：\n$$ \\nabla N(\\xi,\\eta) = \\begin{bmatrix} \\tfrac{2}{h_x}\\,\\partial_{\\xi} N \\\\ \\tfrac{2}{h_y}\\,\\partial_{\\eta} N \\end{bmatrix}, \\quad \\Delta N(\\xi,\\eta) = \\left(\\tfrac{2}{h_x}\\right)^2 \\partial_{\\xi\\xi} N + \\left(\\tfrac{2}{h_y}\\right)^2 \\partial_{\\eta\\eta} N. $$\n\n根据沿流动方向的网格尺寸和 Peclet 数，为每个单元选择一个稳定化参数 $\\tau_e$。令 $\\widehat{\\boldsymbol{b}}=(\\cos\\theta,\\sin\\theta)$，并定义单元流线长度\n$$ h_{\\parallel} = \\sqrt{(h_x \\cos\\theta)^2 + (h_y \\sin\\theta)^2}, \\quad \\mathrm{Pe} = \\frac{\\|\\boldsymbol{b}\\|\\, h_{\\parallel}}{2\\varepsilon}. $$\n设置\n$$ \\tau_e = \\frac{h_{\\parallel}}{2\\|\\boldsymbol{b}\\|} \\left(\\coth(\\mathrm{Pe}) - \\frac{1}{\\mathrm{Pe}}\\right), $$\n并约定对于非常小的 $\\mathrm{Pe}$，使用级数近似 $\\coth(\\mathrm{Pe}) - 1/\\mathrm{Pe} \\approx \\mathrm{Pe}/3$。\n\n为量化横风振荡，计算两个指标：\n1. 横风梯度指数，\n$$ I_{\\perp} = \\frac{\\left\\| \\mathbf{P}_{\\perp} \\nabla u \\right\\|_{L^2(\\Omega)}^2}{\\left\\| \\nabla u \\right\\|_{L^2(\\Omega)}^2} = \\frac{\\int_{\\Omega} \\left( \\mathbf{P}_{\\perp} \\nabla u \\right)\\cdot \\left( \\mathbf{P}_{\\perp} \\nabla u \\right)\\, d\\Omega}{\\int_{\\Omega} \\nabla u \\cdot \\nabla u \\, d\\Omega}, $$\n它表示垂直于流动方向的梯度能量所占的比例。\n2. 内部过冲/下冲幅值，\n$$ A_{\\mathrm{osc}} = \\max\\{0, \\max_{\\Omega^\\circ} u - 1\\} + \\max\\{0, -\\min_{\\Omega^\\circ} u\\}, $$\n其中 $\\Omega^\\circ$ 表示内部自由度（不包括 Dirichlet 边界节点）。该指标衡量了高于流入值 $1$ 和低于流出值 $0$ 的非物理振荡。\n\n在参考正方形上，于每个维度使用三点高斯求积法，以精确计算最高五次多项式的单元积分。组装全局线性系统，强施加本质边界条件，并求解得到的非对称系统。\n\n测试套件：\n除非特别指定，所有测试均使用以下固定参数：\n- 网格：$x$ 方向 18 个单元，$y$ 方向 6 个单元（各向异性，其中 $h_x = 1/N_x, h_y = 1/N_y$）。\n- 平流：$\\boldsymbol{b}$ 的大小为 $\\|\\boldsymbol{b}\\|=1$，与 $x$ 轴夹角为 $\\theta = 33^\\circ$，即 $\\boldsymbol{b}=(\\cos\\theta,\\sin\\theta)$（角度使用弧度）。\n- 扩散：$\\varepsilon = 10^{-4}$。\n- 横风扩散系数：$\\mu_{\\perp} = \\alpha_{\\perp} \\, \\|\\boldsymbol{b}\\|\\, h_{\\perp}$，其中 $h_{\\perp} = \\sqrt{(h_x \\sin\\theta)^2 + (h_y \\cos\\theta)^2}$ 且 $\\alpha_{\\perp}$ 在每个测试中切换；关闭时设置 $\\alpha_{\\perp}=0$，开启时设置 $\\alpha_{\\perp}=0.05$。\n\n定义四个测试用例以比较不同方法和横风扩散的效果：\n- 测试 1：SUPG 稳定化，关闭横风扩散（$\\alpha_{\\perp}=0$）。\n- 测试 2：GLS 稳定化，关闭横风扩散（$\\alpha_{\\perp}=0$）。\n- 测试 3：SUPG 稳定化，开启横风扩散（$\\alpha_{\\perp}=0.05$）。\n- 测试 4：GLS 稳定化，开启横风扩散（$\\alpha_{\\perp}=0.05$）。\n\n您的程序应生成单行输出，其中包含这四个测试的结果，格式为方括号内以逗号分隔的列表。对于每个测试，输出两个浮点数：首先是横风梯度指数 $I_{\\perp}$，其次是过冲/下冲幅值 $A_{\\mathrm{osc}}$。最终输出格式必须为\n$$ [I_{\\perp}^{(1)},A_{\\mathrm{osc}}^{(1)},I_{\\perp}^{(2)},A_{\\mathrm{osc}}^{(2)},I_{\\perp}^{(3)},A_{\\mathrm{osc}}^{(3)},I_{\\perp}^{(4)},A_{\\mathrm{osc}}^{(4)}], $$\n其中上标表示按上文所列顺序的测试编号。所有浮点数都应以标准十进制表示法打印。",
            "solution": "用户希望解决一个稳态平流-扩散问题，并比较不同的有限元稳定化技术。该解决方案将使用 Python 和 NumPy 库实现。\n\n### 1. 问题描述与离散化\n\n控制方程是在单位正方形 $\\Omega = [0,1]^2$ 上的稳态线性平流-扩散方程：\n$$ \\boldsymbol{b}\\cdot\\nabla u - \\varepsilon \\Delta u = 0 $$\n其中 $\\boldsymbol{b}$ 是一个恒定的平流速度，$\\varepsilon > 0$ 是一个小的扩散系数。此设置模拟了一个平流主导的输运过程。边界条件为：在流入边界（其中 $\\boldsymbol{b}\\cdot\\boldsymbol{n} < 0$，$\\boldsymbol{n}$ 为外法线）上 $u=1$，在流出边界（$\\boldsymbol{b}\\cdot\\boldsymbol{n} \\ge 0$）上 $u=0$。\n\n采用标准的 Galerkin 有限元方法 (FEM) 进行离散化。将偏微分方程乘以一个测试函数 $v \\in H^1_0(\\Omega)$，并在扩散项上进行分部积分，得到弱形式：找到 $u \\in H^1(\\Omega)$，使得 $u$ 满足本质边界条件且\n$$ a(u,v) = \\int_{\\Omega} (\\boldsymbol{b}\\cdot \\nabla u) v \\, d\\Omega + \\int_{\\Omega} \\varepsilon \\nabla u \\cdot \\nabla v \\, d\\Omega = 0 \\quad \\forall v \\in H^1_0(\\Omega). $$\n对于平流主导问题（小 $\\varepsilon$），标准的 Galerkin 方法已知会在数值解中产生非物理的伪振荡。这使得稳定化技术的使用成为必要。\n\n该区域使用 $N_x \\times N_y$ 个矩形单元的结构化网格进行离散化，解使用连续二次 ($Q_2$) Lagrange 基函数进行近似。每个矩形单元有 $9$ 个节点。\n\n### 2. 稳定化方法\n\n考虑两种稳定化方法：流线迎风/Petrov-Galerkin (SUPG) 和 Galerkin/最小二乘 (GLS)。两种方法都向弱形式中添加了沿流线方向作用的项，以抵消不稳定性。\n\n**SUPG 稳定化：**\nSUPG 方法将测试函数修改为 $v + \\tau_e \\boldsymbol{b}\\cdot\\nabla v$。在修改双线性形式的背景下，这等同于添加以下项：\n$$ s_{\\mathrm{SUPG}}(u,v) = \\sum_{e} \\int_{\\Omega_e} \\tau_e \\, (\\boldsymbol{b}\\cdot \\nabla u)\\, (\\boldsymbol{b}\\cdot \\nabla v) \\, d\\Omega $$\n该项仅在流动方向（流线方向）引入人工扩散，从而抑制沿流线形成的振荡。\n\n**GLS 稳定化：**\nGLS 方法更为全面，它添加了一个与偏微分方程残差成正比的项，该项同时作用于试验函数和测试函数。添加的项为：\n$$ s_{\\mathrm{GLS}}(u,v) = \\sum_{e} \\int_{\\Omega_e} \\tau_e \\, r(u)\\, r(v)\\, d\\Omega, \\quad \\text{where } r(w) := \\boldsymbol{b}\\cdot \\nabla w - \\varepsilon \\Delta w. $$\n由于对于精确解，残差 $r(u)$ 为零，因此该方法是一致的。展开后，GLS 项包含 SUPG 项以及涉及拉普拉斯算子的附加项，从而提供更强的稳定性。\n\n稳定化参数 $\\tau_e$至关重要，它根据单元尺寸和局部 Péclet 数 $\\mathrm{Pe} = \\|\\boldsymbol{b}\\| h_{\\parallel} / (2\\varepsilon)$ 定义，其中 $h_\\parallel$ 是沿流线的有效网格尺寸。所提供的公式是提供最优稳定性的标准选择。\n\n### 3. 横风扩散\n\n虽然 SUPG 和 GLS 能有效处理沿流线的振荡，但它们不能解决可能在横风方向出现的振荡，尤其是在陡峭梯度或内部层附近。为缓解此问题，引入了人工横风扩散。这是通过添加一个仅在垂直于流动方向上作用的扩散项来实现的。该项为：\n$$ d_{\\perp}(u,v) = \\int_{\\Omega} \\mu_{\\perp}\\, (\\nabla u)^\\top \\mathbf{P}_{\\perp}\\, \\nabla v \\, d\\Omega. $$\n此处，$\\mathbf{P}_{\\perp} = \\mathbf{I} - \\widehat{\\boldsymbol{b}}\\, \\widehat{\\boldsymbol{b}}^\\top$ 是到与归一化流动方向 $\\widehat{\\boldsymbol{b}}$ 正交的子空间上的投影矩阵。系数 $\\mu_{\\perp}$ 控制添加的扩散量。\n\n### 4. 实现策略\n\n- **逐单元计算：** 求解器的核心是遍历网格中所有单元的循环。对每个单元，计算一个 $9 \\times 9$ 的局部刚度矩阵。\n- **数值积分：** 单元上的积分使用参考正方形 $[-1,1]^2$ 上的 $3 \\times 3$ 高斯求积法则进行近似。这足以精确地对生成的多项式进行积分。\n- **基函数：** 在每个求积点，使用所提供的公式和仿射单元映射的链式法则，计算 $9$ 个二次基函数 $N_i$ 的值及其梯度 $\\nabla N_i$ 和拉普拉斯算子 $\\Delta N_i$。\n- **矩阵组装：** 对于每对试验函数 $N_j$ 和测试函数 $N_i$，在求积点计算完整弱形式（包括稳定化和横风项）的被积函数，并乘以求积权重和雅可比行列式。该值被加到局部刚度矩阵中。然后将局部矩阵组装成全局系统矩阵 $K$。\n- **边界条件：** 强施加本质 (Dirichlet) 边界条件。将全局方程组 $KU=F$ 划分为已知（Dirichlet）和未知（内部）自由度。求解一个针对内部节点的简化系统，然后重构完整的解向量。\n- **求解：** 得到的线性系统是非对称的，使用直接求解器 `numpy.linalg.solve` 进行求解。\n\n### 5. 评估指标\n\n在获得离散解向量 $U$ 后，计算两个指标来量化每种方法的性能。\n\n1.  **横风梯度指数 ($I_{\\perp}$):** 该指标衡量解的梯度能量中垂直于流动方向的分量所占的比例。高值表示显著的横风振荡或涂抹。它计算为两个 $L^2$ 范数的比值，使用相同的高斯求积方案进行评估：\n    $$ I_{\\perp} = \\frac{\\int_{\\Omega} \\|\\mathbf{P}_{\\perp} \\nabla u_h \\|^2 \\, d\\Omega}{\\int_{\\Omega} \\|\\nabla u_h\\|^2 \\, d\\Omega} $$\n2.  **过冲/下冲幅值 ($A_{\\mathrm{osc}}$):** 该指标量化了对离散极值原理的违反程度。精确解受其边界值 $[0, 1]$ 的限制。数值解可能会出现非物理振荡，其值大于 $1$（过冲）或小于 $0$（下冲）。该指标对在任何内部节点处发现的最大过冲和最大下冲的幅度求和：\n    $$ A_{\\mathrm{osc}} = \\max\\{0, \\max_{\\Omega^\\circ} u_h - 1\\} + \\max\\{0, -\\min_{\\Omega^\\circ} u_h\\} $$\n\n通过为四个指定的测试用例（SUPG vs GLS，带和不带横风扩散）计算这些指标，可以对这些方法在减轻数值振荡方面的有效性进行定量比较。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the four test cases and print the results.\n    \"\"\"\n\n    def coth(x):\n        \"\"\"Hyperbolic cotangent, with guards for large arguments.\"\"\"\n        # For large |x|, coth(x) approaches +/-1.\n        # This avoids overflow/underflow issues in np.exp.\n        if x > 50:\n            return 1.0\n        if x < -50:\n            return -1.0\n        return np.cosh(x) / np.sinh(x)\n\n    def run_fem_solver(stabilization, alpha_perp):\n        \"\"\"\n        Solves the advection-diffusion problem for a given stabilization method\n        and crosswind diffusion parameter.\n        \"\"\"\n        # --- 1. Define Parameters ---\n        # Fixed parameters from problem statement\n        Nx, Ny = 18, 6\n        theta_deg = 33.0\n        epsilon = 1e-4\n\n        # Derived parameters\n        hx, hy = 1.0 / Nx, 1.0 / Ny\n        theta_rad = np.deg2rad(theta_deg)\n        b = np.array([np.cos(theta_rad), np.sin(theta_rad)])\n        b_norm = np.linalg.norm(b)\n        b_hat = b / b_norm\n\n        # Mesh-dependent lengths for stabilization parameters\n        h_parallel = np.sqrt((hx * np.cos(theta_rad))**2 + (hy * np.sin(theta_rad))**2)\n        h_perp = np.sqrt((hx * np.sin(theta_rad))**2 + (hy * np.cos(theta_rad))**2)\n        \n        # Péclet number and stabilization parameter tau\n        Pe = b_norm * h_parallel / (2.0 * epsilon)\n        if np.abs(Pe) < 1e-6:\n            coth_pe_minus_1_pe = Pe / 3.0\n        else:\n            coth_pe_minus_1_pe = coth(Pe) - 1.0 / Pe\n        tau = (h_parallel / (2.0 * b_norm)) * coth_pe_minus_1_pe\n        \n        # Crosswind diffusion coefficient\n        mu_perp = alpha_perp * b_norm * h_perp\n\n        # --- 2. FEM Discretization Setup ---\n        num_nodes_x = 2 * Nx + 1\n        num_nodes_y = 2 * Ny + 1\n        total_nodes = num_nodes_x * num_nodes_y\n\n        # 1D Q2 Lagrange basis functions and their derivatives\n        def l_vals(xi): return np.array([0.5 * xi * (xi - 1), 1 - xi**2, 0.5 * xi * (xi + 1)])\n        def l_derivs(xi): return np.array([xi - 0.5, -2 * xi, xi + 0.5])\n        def l_derivs2(xi): return np.array([1.0, -2.0, 1.0])\n\n        # 3-point Gaussian quadrature nodes and weights\n        gp_loc = np.array([-np.sqrt(3.0/5.0), 0.0, np.sqrt(3.0/5.0)])\n        gp_w = np.array([5.0/9.0, 8.0/9.0, 5.0/9.0])\n        \n        K = np.zeros((total_nodes, total_nodes))\n\n        # --- 3. Assemble Global Stiffness Matrix K ---\n        for ey in range(Ny):\n            for ex in range(Nx):\n                Ke = np.zeros((9, 9))\n                \n                # Element-to-global node mapping\n                local_to_global = np.array(\n                    [ (2*ey+dy) * num_nodes_x + (2*ex+dx) \n                      for dy in range(3) for dx in range(3) ], dtype=int\n                )\n\n                # Loop over Gauss points for numerical integration\n                d_vol_factor = (hx / 2.0) * (hy / 2.0)\n                for i_eta, eta in enumerate(gp_loc):\n                    for i_xi, xi in enumerate(gp_loc):\n                        weight = gp_w[i_eta] * gp_w[i_xi]\n                        d_vol = d_vol_factor * weight\n\n                        # Evaluate 1D basis functions at the current Gauss point\n                        vals_xi, d_vals_xi, d2_vals_xi = l_vals(xi), l_derivs(xi), l_derivs2(xi)\n                        vals_eta, d_vals_eta, d2_vals_eta = l_vals(eta), l_derivs(eta), l_derivs2(eta)\n                        \n                        N, grad_N, lap_N = np.zeros(9), np.zeros((9, 2)), np.zeros(9)\n                        for k in range(9):\n                            k_xi, k_eta = k % 3, k // 3\n                            N[k] = vals_xi[k_xi] * vals_eta[k_eta]\n                            grad_N[k, 0] = d_vals_xi[k_xi] * vals_eta[k_eta] * (2 / hx)\n                            grad_N[k, 1] = vals_xi[k_xi] * d_vals_eta[k_eta] * (2 / hy)\n                            lap_N[k] = (d2_vals_xi[k_xi] * vals_eta[k_eta] * (2 / hx)**2 +\n                                        vals_xi[k_xi] * d2_vals_eta[k_eta] * (2 / hy)**2)\n\n                        # Compute contributions to element stiffness matrix Ke\n                        for i in range(9):  # Test function index\n                            for j in range(9):  # Trial function index\n                                term_diff = epsilon * np.dot(grad_N[j], grad_N[i])\n                                term_adv = np.dot(b, grad_N[j]) * N[i]\n                                integrand = term_diff + term_adv\n                                \n                                if stabilization == 'SUPG':\n                                    term_supg = tau * np.dot(b, grad_N[j]) * np.dot(b, grad_N[i])\n                                    integrand += term_supg\n                                elif stabilization == 'GLS':\n                                    res_j = np.dot(b, grad_N[j]) - epsilon * lap_N[j]\n                                    res_i = np.dot(b, grad_N[i]) - epsilon * lap_N[i]\n                                    term_gls = tau * res_j * res_i\n                                    integrand += term_gls\n\n                                if alpha_perp > 0:\n                                    P_perp_g_j = grad_N[j] - np.dot(grad_N[j], b_hat) * b_hat\n                                    term_crosswind = mu_perp * np.dot(P_perp_g_j, grad_N[i])\n                                    integrand += term_crosswind\n                                \n                                Ke[i, j] += integrand * d_vol\n                \n                # Assemble local matrix into global matrix\n                K[np.ix_(local_to_global, local_to_global)] += Ke\n\n        # --- 4. Apply Boundary Conditions and Solve ---\n        dirichlet_dofs, interior_dofs = [], []\n        U = np.zeros(total_nodes)\n        for iy in range(num_nodes_y):\n            for ix in range(num_nodes_x):\n                g_idx = iy * num_nodes_x + ix\n                if ix == 0 or iy == 0:  # Inflow boundaries\n                    U[g_idx] = 1.0\n                    dirichlet_dofs.append(g_idx)\n                elif ix == num_nodes_x - 1 or iy == num_nodes_y - 1:  # Outflow boundaries\n                    U[g_idx] = 0.0\n                    dirichlet_dofs.append(g_idx)\n                else:\n                    interior_dofs.append(g_idx)\n        \n        F_interior = -K[np.ix_(interior_dofs, dirichlet_dofs)] @ U[dirichlet_dofs]\n        K_interior = K[np.ix_(interior_dofs, interior_dofs)]\n        \n        U_interior = np.linalg.solve(K_interior, F_interior)\n        U[interior_dofs] = U_interior\n\n        # --- 5. Post-Processing: Compute Metrics ---\n        # Metric 1: Crosswind Gradient Index (I_perp)\n        num_integral, den_integral = 0.0, 0.0\n        for ey in range(Ny):\n            for ex in range(Nx):\n                local_to_global = np.array(\n                    [ (2*ey+dy) * num_nodes_x + (2*ex+dx)\n                      for dy in range(3) for dx in range(3) ], dtype=int\n                )\n                U_local = U[local_to_global]\n\n                d_vol_factor = (hx / 2.0) * (hy / 2.0)\n                for i_eta, eta in enumerate(gp_loc):\n                    for i_xi, xi in enumerate(gp_loc):\n                        weight = gp_w[i_eta] * gp_w[i_xi]\n                        d_vol = d_vol_factor * weight\n                        \n                        vals_xi, d_vals_xi = l_vals(xi), l_derivs(xi)\n                        vals_eta, d_vals_eta = l_vals(eta), l_derivs(eta)\n                        \n                        grad_u = np.zeros(2)\n                        for k in range(9):\n                            k_xi, k_eta = k % 3, k // 3\n                            grad_u[0] += U_local[k] * (d_vals_xi[k_xi] * vals_eta[k_eta] * (2 / hx))\n                            grad_u[1] += U_local[k] * (vals_xi[k_xi] * d_vals_eta[k_eta] * (2 / hy))\n                        \n                        P_perp_grad_u = grad_u - np.dot(grad_u, b_hat) * b_hat\n                        num_integral += np.dot(P_perp_grad_u, P_perp_grad_u) * d_vol\n                        den_integral += np.dot(grad_u, grad_u) * d_vol\n        \n        I_perp = num_integral / den_integral if den_integral > 1e-12 else 0.0\n\n        # Metric 2: Overshoot/Undershoot Amplitude (A_osc)\n        U_interior_only = U[interior_dofs]\n        max_u = np.max(U_interior_only) if U_interior_only.size > 0 else 0.0\n        min_u = np.min(U_interior_only) if U_interior_only.size > 0 else 0.0\n        A_osc = max(0, max_u - 1.0) + max(0, -min_u)\n\n        return I_perp, A_osc\n\n    # Define test cases\n    test_cases = [\n        {'stabilization': 'SUPG', 'alpha_perp': 0.0},\n        {'stabilization': 'GLS', 'alpha_perp': 0.0},\n        {'stabilization': 'SUPG', 'alpha_perp': 0.05},\n        {'stabilization': 'GLS', 'alpha_perp': 0.05}\n    ]\n\n    results = []\n    for case in test_cases:\n        I_perp, A_osc = run_fem_solver(case['stabilization'], case['alpha_perp'])\n        results.extend([I_perp, A_osc])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}