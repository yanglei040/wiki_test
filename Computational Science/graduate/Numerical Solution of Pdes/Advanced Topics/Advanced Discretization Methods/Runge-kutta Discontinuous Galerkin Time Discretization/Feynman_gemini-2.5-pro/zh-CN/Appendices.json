{
    "hands_on_practices": [
        {
            "introduction": "龙格-库塔(RK)法是求解常微分方程(ODEs)的基石，而其“精度阶”是衡量其性能的核心指标。通过亲自验证一个方法的阶条件，我们不仅能巩固对泰勒展开和误差分析的理解，还能深入洞悉高阶方法设计的精妙之处。本练习将指导你对经典的四阶龙格-库塔法(RK4)进行代数阶条件的验证，这是理解更复杂的RKDG方法时间离散化性质的重要一步 。",
            "id": "3441463",
            "problem": "考虑由线性守恒律的间断伽辽金 (DG) 空间离散产生的半离散系统，其形式为 $y^{\\prime}(t)=F(y(t))$，其中 $y(t)\\in\\mathbb{R}^{N}$ 且 $F:\\mathbb{R}^{N}\\to\\mathbb{R}^{N}$ 足够光滑。在 Runge–Kutta 间断伽辽金 (RKDG) 格式中，时间积分通过一个显式 $s$ 阶 Runge–Kutta (RK) 方法进行，该方法由其 Butcher 表系数 $\\{A,b,c\\}$ 表征，其中 $A\\in\\mathbb{R}^{s\\times s}$ 是严格下三角矩阵， $b\\in\\mathbb{R}^{s}$，并且 $c\\in\\mathbb{R}^{s}$ 满足 $c=A\\boldsymbol{1}$，其中 $\\boldsymbol{1}\\in\\mathbb{R}^{s}$ 是全1向量。具有 $s=4$ 级的经典 Runge–Kutta 方法（记为 RK$4$）在 RKDG 时间离散中被广泛使用。\n\n从显式 Runge–Kutta 方法的基本定义以及通过 Butcher 的根树理论和 B-级数的阶的概念出发，执行以下操作：\n\n- 写出经典 RK$4$ 方法的 Butcher 表系数 $\\{A,b,c\\}$。\n- 使用直到4阶的基本根树阶条件（这些条件通过将方法的 B-级数与精确流的 B-级数进行匹配推导得出），验证所有直到4阶的代数阶条件。特别地，使用包含 $A$、$b$ 和 $c$ 的标准代数形式，即\n  $$b^{\\top}\\boldsymbol{1},\\quad b^{\\top}c,\\quad b^{\\top}(c.\\!^{2}),\\quad b^{\\top}Ac,\\quad b^{\\top}(c.\\!^{3}),\\quad b^{\\top}A(c.\\!^{2}),\\quad b^{\\top}\\big(c\\!.\\!(Ac)\\big),\\quad b^{\\top}AAc,$$\n  其中 $c.\\!^{k}$ 表示逐分量求幂，而 $c\\!.\\!(Ac)$ 表示逐分量相乘。\n- 定义验证残差\n  $$S \\;=\\; \\big(b^{\\top}\\boldsymbol{1}-1\\big)^{2} \\;+\\; \\big(b^{\\top}c-\\tfrac{1}{2}\\big)^{2} \\;+\\; \\big(b^{\\top}(c.\\!^{2})-\\tfrac{1}{3}\\big)^{2} \\;+\\; \\big(b^{\\top}Ac-\\tfrac{1}{6}\\big)^{2} \\;+\\; \\big(b^{\\top}(c.\\!^{3})-\\tfrac{1}{4}\\big)^{2} \\;+\\; \\big(b^{\\top}A(c.\\!^{2})-\\tfrac{1}{12}\\big)^{2} \\;+\\; \\big(b^{\\top}\\big(c\\!.\\!(Ac)\\big)-\\tfrac{1}{8}\\big)^{2} \\;+\\; \\big(b^{\\top}AAc-\\tfrac{1}{24}\\big)^{2}.$$\n\n计算 $S$ 的精确值，结果为一个实数。无需四舍五入，也不涉及单位。你的最终答案必须是一个实数。",
            "solution": "该问题要求我们执行一系列与经典四阶 Runge-Kutta 方法（RK$4$）相关的计算，具体来说是验证其直到4阶的阶条件，然后计算验证残差 $S$。\n\n首先，我们给出经典 RK$4$ 方法的 Butcher 表系数 $\\{A, b, c\\}$。这是一个 $s=4$ 级的显式 Runge-Kutta 方法。其 Butcher 表如下：\n$$\n\\begin{array}{c|c}\nc & A \\\\\n\\hline\n & b^{\\top}\n\\end{array}\n=\n\\begin{array}{c|cccc}\n0 & 0 & 0 & 0 & 0 \\\\\n\\frac{1}{2} & \\frac{1}{2} & 0 & 0 & 0 \\\\\n\\frac{1}{2} & 0 & \\frac{1}{2} & 0 & 0 \\\\\n1 & 0 & 0 & 1 & 0 \\\\\n\\hline\n & \\frac{1}{6} & \\frac{1}{3} & \\frac{1}{3} & \\frac{1}{6}\n\\end{array}\n$$\n从此表中，我们提取矩阵 $A$ 以及向量 $b$ 和 $c$：\n$$ A = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ \\frac{1}{2} & 0 & 0 & 0 \\\\ 0 & \\frac{1}{2} & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix}, \\quad b = \\begin{pmatrix} \\frac{1}{6} \\\\ \\frac{1}{3} \\\\ \\frac{1}{3} \\\\ \\frac{1}{6} \\end{pmatrix}, \\quad c = \\begin{pmatrix} 0 \\\\ \\frac{1}{2} \\\\ \\frac{1}{2} \\\\ 1 \\end{pmatrix} $$\n全1向量 $\\boldsymbol{1}$ 为 $\\boldsymbol{1} = [1, 1, 1, 1]^{\\top}$。我们可以验证简化假设 $c = A\\boldsymbol{1}$：\n$$ A\\boldsymbol{1} = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ \\frac{1}{2} & 0 & 0 & 0 \\\\ 0 & \\frac{1}{2} & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ \\frac{1}{2} \\\\ \\frac{1}{2} \\\\ 1 \\end{pmatrix} = c $$\n此条件得到满足。\n\n接下来，我们继续验证八个代数阶条件。\n\n1阶条件：$b^{\\top}\\boldsymbol{1} = 1$\n$$ b^{\\top}\\boldsymbol{1} = \\begin{pmatrix} \\frac{1}{6} & \\frac{1}{3} & \\frac{1}{3} & \\frac{1}{6} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\frac{1}{6} + \\frac{1}{3} + \\frac{1}{3} + \\frac{1}{6} = \\frac{1+2+2+1}{6} = \\frac{6}{6} = 1 $$\n该条件得到满足。\n\n2阶条件：$b^{\\top}c = \\frac{1}{2}$\n$$ b^{\\top}c = \\begin{pmatrix} \\frac{1}{6} & \\frac{1}{3} & \\frac{1}{3} & \\frac{1}{6} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ \\frac{1}{2} \\\\ \\frac{1}{2} \\\\ 1 \\end{pmatrix} = \\frac{1}{6}(0) + \\frac{1}{3}\\left(\\frac{1}{2}\\right) + \\frac{1}{3}\\left(\\frac{1}{2}\\right) + \\frac{1}{6}(1) = 0 + \\frac{1}{6} + \\frac{1}{6} + \\frac{1}{6} = \\frac{3}{6} = \\frac{1}{2} $$\n该条件得到满足。\n\n3阶条件：\n1. $b^{\\top}(c.\\!^{2}) = \\frac{1}{3}$\n$c$ 的逐分量平方为 $c.\\!^{2} = [0^2, (\\frac{1}{2})^2, (\\frac{1}{2})^2, 1^2]^{\\top} = [0, \\frac{1}{4}, \\frac{1}{4}, 1]^{\\top}$。\n$$ b^{\\top}(c.\\!^{2}) = \\begin{pmatrix} \\frac{1}{6} & \\frac{1}{3} & \\frac{1}{3} & \\frac{1}{6} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ \\frac{1}{4} \\\\ \\frac{1}{4} \\\\ 1 \\end{pmatrix} = \\frac{1}{6}(0) + \\frac{1}{3}\\left(\\frac{1}{4}\\right) + \\frac{1}{3}\\left(\\frac{1}{4}\\right) + \\frac{1}{6}(1) = 0 + \\frac{1}{12} + \\frac{1}{12} + \\frac{1}{6} = \\frac{2}{12} + \\frac{2}{12} = \\frac{4}{12} = \\frac{1}{3} $$\n该条件得到满足。\n\n2. $b^{\\top}Ac = \\frac{1}{6}$\n首先，我们计算向量 $Ac$：\n$$ Ac = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ \\frac{1}{2} & 0 & 0 & 0 \\\\ 0 & \\frac{1}{2} & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ \\frac{1}{2} \\\\ \\frac{1}{2} \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{1}{4} \\\\ \\frac{1}{2} \\end{pmatrix} $$\n然后，我们计算点积：\n$$ b^{\\top}Ac = \\begin{pmatrix} \\frac{1}{6} & \\frac{1}{3} & \\frac{1}{3} & \\frac{1}{6} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{1}{4} \\\\ \\frac{1}{2} \\end{pmatrix} = \\frac{1}{3}\\left(\\frac{1}{4}\\right) + \\frac{1}{6}\\left(\\frac{1}{2}\\right) = \\frac{1}{12} + \\frac{1}{12} = \\frac{2}{12} = \\frac{1}{6} $$\n该条件得到满足。\n\n4阶条件：\n1. $b^{\\top}(c.\\!^{3}) = \\frac{1}{4}$\n$c$ 的逐分量立方为 $c.\\!^{3} = [0^3, (\\frac{1}{2})^3, (\\frac{1}{2})^3, 1^3]^{\\top} = [0, \\frac{1}{8}, \\frac{1}{8}, 1]^{\\top}$。\n$$ b^{\\top}(c.\\!^{3}) = \\begin{pmatrix} \\frac{1}{6} & \\frac{1}{3} & \\frac{1}{3} & \\frac{1}{6} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ \\frac{1}{8} \\\\ \\frac{1}{8} \\\\ 1 \\end{pmatrix} = \\frac{1}{3}\\left(\\frac{1}{8}\\right) + \\frac{1}{3}\\left(\\frac{1}{8}\\right) + \\frac{1}{6}(1) = \\frac{1}{24} + \\frac{1}{24} + \\frac{1}{6} = \\frac{2}{24} + \\frac{4}{24} = \\frac{6}{24} = \\frac{1}{4} $$\n该条件得到满足。\n\n2. $b^{\\top}A(c.\\!^{2}) = \\frac{1}{12}$\n我们有 $c.\\!^{2} = [0, \\frac{1}{4}, \\frac{1}{4}, 1]^{\\top}$。首先，计算 $A(c.\\!^{2})$：\n$$ A(c.\\!^{2}) = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ \\frac{1}{2} & 0 & 0 & 0 \\\\ 0 & \\frac{1}{2} & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ \\frac{1}{4} \\\\ \\frac{1}{4} \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{1}{8} \\\\ \\frac{1}{4} \\end{pmatrix} $$\n然后，我们计算点积：\n$$ b^{\\top}A(c.\\!^{2}) = \\begin{pmatrix} \\frac{1}{6} & \\frac{1}{3} & \\frac{1}{3} & \\frac{1}{6} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{1}{8} \\\\ \\frac{1}{4} \\end{pmatrix} = \\frac{1}{3}\\left(\\frac{1}{8}\\right) + \\frac{1}{6}\\left(\\frac{1}{4}\\right) = \\frac{1}{24} + \\frac{1}{24} = \\frac{2}{24} = \\frac{1}{12} $$\n该条件得到满足。\n\n3. $b^{\\top}\\big(c\\!.\\!(Ac)\\big) = \\frac{1}{8}$\n我们有 $Ac = [0, 0, \\frac{1}{4}, \\frac{1}{2}]^{\\top}$。逐分量乘积 $c\\!.\\!(Ac)$ 为：\n$$ c\\!.\\!(Ac) = \\begin{pmatrix} 0 \\\\ \\frac{1}{2} \\\\ \\frac{1}{2} \\\\ 1 \\end{pmatrix} .\\!* \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{1}{4} \\\\ \\frac{1}{2} \\end{pmatrix} = \\begin{pmatrix} 0 \\cdot 0 \\\\ \\frac{1}{2} \\cdot 0 \\\\ \\frac{1}{2} \\cdot \\frac{1}{4} \\\\ 1 \\cdot \\frac{1}{2} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{1}{8} \\\\ \\frac{1}{2} \\end{pmatrix} $$\n然后，我们计算点积：\n$$ b^{\\top}\\big(c\\!.\\!(Ac)\\big) = \\begin{pmatrix} \\frac{1}{6} & \\frac{1}{3} & \\frac{1}{3} & \\frac{1}{6} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{1}{8} \\\\ \\frac{1}{2} \\end{pmatrix} = \\frac{1}{3}\\left(\\frac{1}{8}\\right) + \\frac{1}{6}\\left(\\frac{1}{2}\\right) = \\frac{1}{24} + \\frac{1}{12} = \\frac{1+2}{24} = \\frac{3}{24} = \\frac{1}{8} $$\n该条件得到满足。\n\n4. $b^{\\top}AAc = \\frac{1}{24}$\n我们有 $Ac = [0, 0, \\frac{1}{4}, \\frac{1}{2}]^{\\top}$。首先，计算 $AAc = A(Ac)$：\n$$ A(Ac) = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ \\frac{1}{2} & 0 & 0 & 0 \\\\ 0 & \\frac{1}{2} & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{1}{4} \\\\ \\frac{1}{2} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ \\frac{1}{4} \\end{pmatrix} $$\n然后，我们计算点积：\n$$ b^{\\top}AAc = \\begin{pmatrix} \\frac{1}{6} & \\frac{1}{3} & \\frac{1}{3} & \\frac{1}{6} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ \\frac{1}{4} \\end{pmatrix} = \\frac{1}{6}\\left(\\frac{1}{4}\\right) = \\frac{1}{24} $$\n该条件得到满足。\n\n最后，我们计算验证残差 $S$：\n$$ S \\;=\\; \\big(b^{\\top}\\boldsymbol{1}-1\\big)^{2} \\;+\\; \\big(b^{\\top}c-\\tfrac{1}{2}\\big)^{2} \\;+\\; \\big(b^{\\top}(c.\\!^{2})-\\tfrac{1}{3}\\big)^{2} \\;+\\; \\big(b^{\\top}Ac-\\tfrac{1}{6}\\big)^{2} \\;+\\; \\big(b^{\\top}(c.\\!^{3})-\\tfrac{1}{4}\\big)^{2} \\;+\\; \\big(b^{\\top}A(c.\\!^{2})-\\tfrac{1}{12}\\big)^{2} \\;+\\; \\big(b^{\\top}\\big(c\\!.\\!(Ac)\\big)-\\tfrac{1}{8}\\big)^{2} \\;+\\; \\big(b^{\\top}AAc-\\tfrac{1}{24}\\big)^{2} $$\n如上所示，对于经典的 RK$4$ 方法，每个阶条件都得到精确满足。因此，求和中的每一项都为零：\n\\begin{itemize}\n    \\item $\\big(b^{\\top}\\boldsymbol{1}-1\\big)^{2} = (1-1)^2 = 0$\n    \\item $\\big(b^{\\top}c-\\tfrac{1}{2}\\big)^{2} = (\\frac{1}{2}-\\frac{1}{2})^2 = 0$\n    \\item $\\big(b^{\\top}(c.\\!^{2})-\\tfrac{1}{3}\\big)^{2} = (\\frac{1}{3}-\\frac{1}{3})^2 = 0$\n    \\item $\\big(b^{\\top}Ac-\\tfrac{1}{6}\\big)^{2} = (\\frac{1}{6}-\\frac{1}{6})^2 = 0$\n    \\item $\\big(b^{\\top}(c.\\!^{3})-\\tfrac{1}{4}\\big)^{2} = (\\frac{1}{4}-\\frac{1}{4})^2 = 0$\n    \\item $\\big(b^{\\top}A(c.\\!^{2})-\\tfrac{1}{12}\\big)^{2} = (\\frac{1}{12}-\\frac{1}{12})^2 = 0$\n    \\item $\\big(b^{\\top}\\big(c\\!.\\!(Ac)\\big)-\\tfrac{1}{8}\\big)^{2} = (\\frac{1}{8}-\\frac{1}{8})^2 = 0$\n    \\item $\\big(b^{\\top}AAc-\\tfrac{1}{24}\\big)^{2} = (\\frac{1}{24}-\\frac{1}{24})^2 = 0$\n\\end{itemize}\n将这些项相加得到 $S$ 的值：\n$$ S = 0+0+0+0+0+0+0+0 = 0 $$\n验证残差 $S$ 的精确值为 $0$。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "在求解双曲守恒律时，仅有高阶精度是不够的；我们还需要保证解的稳定性，例如保持总变差不增(TVD)等性质。强稳定性保持(SSP)龙格-库塔方法应运而生，它通过一种巧妙的结构来保证在满足一定CFL条件下，高阶格式继承底层一阶欧拉步的稳定性。本练习将引导你推导一个著名SSPRK方法的“Shu–Osher表示”，即将其分解为一系列凸组合的前向欧拉步，从而揭示其稳定性来源并计算出关键的SSP系数 。",
            "id": "3441464",
            "problem": "考虑一个一维标量守恒律，其空间离散采用间断Galerkin (DG) 方法，并使用单调数值通量和稳定的斜率限制器，由此得到形如 $u^{\\prime}(t)=L(u(t))$ 的常微分方程组。假设存在一个范数或半范数 $\\|\\cdot\\|$ 和一个前向欧拉时间步长阈值 $\\Delta t_{\\mathrm{FE}}>0$，使得对于所有的 $u$，只要满足 $0\\le \\Delta t\\le \\Delta t_{\\mathrm{FE}}$，前向欧拉步 $u^{+}=u+\\Delta t\\,L(u)$ 在该范数下就是非扩张的。\n\n设时间离散方法为 Shu 和 Osher 提出的三阶段三阶强稳定性保持Runge–Kutta (SSPRK) 方法，记为 SSPRK($3,3$)，其 Butcher 形式由以下系数给出：\n- $c_1=0, c_2=1, c_3=\\frac{1}{2}$，\n- $a_{21}=1, a_{31}=\\frac{1}{4}, a_{32}=\\frac{1}{4}$，所有其他的 $a_{ij}=0$，\n- $b_1=\\frac{1}{6}, b_2=\\frac{1}{6}, b_3=\\frac{2}{3}$。\n\n从与这些 Butcher 系数相关的显式 Runge–Kutta 阶段定义和更新出发，推导每个阶段的 Shu–Osher 凸组合表示，即，将每个内部阶段和最终更新表示为形如 $Y+\\Delta t\\,L(Y)$ 的项的凸组合，也就是前向欧拉步的凸组合。然后，利用强稳定性保持 (SSP) 的定义——如果一个方法可以写成有效前向欧拉子步长最大为 $\\Delta t$ 的前向欧拉步的凸组合（当 $0\\le \\Delta t \\le C\\,\\Delta t_{\\mathrm{FE}}$ 时），则该方法是 SSP 的，其系数为 $C>0$——从你得到的凸组合中计算 SSPRK($3,3$) 的最优 SSP 系数 $C$。\n\n最终答案只提供 $C$ 的值。不包含任何单位。无需四舍五入。",
            "solution": "本问题要求推导三阶段三阶强稳定性保持Runge–Kutta方法 SSPRK($3,3$) 的 Shu–Osher 凸组合表示，并随后计算其最优 SSP 系数 $C$。\n\n常微分方程组由 $u^{\\prime}(t)=L(u(t))$ 给出。前向欧拉方法 $u^{+} = u + \\Delta t\\,L(u)$ 被假设在范数 $\\|\\cdot\\|$ 下是非扩张的，即 $\\|u^{+}\\| \\le \\|u\\|$，条件是时间步长 $\\Delta t$ 满足 $0 \\le \\Delta t \\le \\Delta t_{\\mathrm{FE}}$。\n\nSSPRK($3,3$) 方法由以下 Butcher 系数定义：\n$c_1=0, c_2=1, c_3=\\frac{1}{2}$\n$a_{21}=1$\n$a_{31}=\\frac{1}{4}, a_{32}=\\frac{1}{4}$\n$b_1=\\frac{1}{6}, b_2=\\frac{1}{6}, b_3=\\frac{2}{3}$\n\n设 $u_n$ 表示在时间 $t_n$ 的数值解。一个显式Runge-Kutta方法通过在中间阶段计算函数 $L$ 的值来计算在 $t_{n+1} = t_n + \\Delta t$ 时的解。我们将 $L$ 的参数记为 $Y_i$。\n\n一个通用的3阶段RK方法的标准公式为：\n$k_1 = L(Y_1)$ 其中 $Y_1 = u_n$\n$k_2 = L(Y_2)$ 其中 $Y_2 = u_n + \\Delta t \\, a_{21} k_1$\n$k_3 = L(Y_3)$ 其中 $Y_3 = u_n + \\Delta t (a_{31} k_1 + a_{32} k_2)$\n$u_{n+1} = u_n + \\Delta t (b_1 k_1 + b_2 k_2 + b_3 k_3)$\n\n使用 SSPRK($3,3$) 给定的系数：\n$Y_1 = u_n$\n$Y_2 = u_n + \\Delta t L(Y_1)$\n$Y_3 = u_n + \\frac{\\Delta t}{4} L(Y_1) + \\frac{\\Delta t}{4} L(Y_2)$\n$u_{n+1} = u_n + \\frac{\\Delta t}{6} L(Y_1) + \\frac{\\Delta t}{6} L(Y_2) + \\frac{2\\Delta t}{3} L(Y_3)$\n\n任务是把这个方法改写成 Shu–Osher 凸组合形式，其中每个阶段都表示为先前阶段值和类前向欧拉步的凸组合。我们如下定义中间解 $u^{(i)}$，从 $u^{(0)} = u_n$ 开始。\n\n**阶段 1：**\n第一阶段更新，通常记为 $u^{(1)}$，是由 $u_n$ 进行一个前向欧拉步形成的：\n$u^{(1)} = u_n + \\Delta t L(u_n) = u^{(0)} + \\Delta t L(u^{(0)})$\n这显然是一个凸组合（只有一项）。注意到 $u^{(1)}$ 与用于计算 $k_2$ 的阶段值 $Y_2$ 相同。因此，$L(Y_2) = L(u^{(1)})$。\n\n**阶段 2：**\n计算的下一个阶段，我们称之为 $u^{(2)}$，对应于阶段值 $Y_3$。我们必须将 $Y_3$ 表示为一个凸组合。\n$u^{(2)} \\equiv Y_3 = u_n + \\frac{\\Delta t}{4} L(u_n) + \\frac{\\Delta t}{4} L(u^{(1)})$\n根据 $u^{(1)}$ 的定义，我们可以写出 $L(u_n) = \\frac{u^{(1)} - u_n}{\\Delta t}$。将此代入 $u^{(2)}$ 的表达式中：\n$u^{(2)} = u_n + \\frac{\\Delta t}{4} \\left( \\frac{u^{(1)} - u_n}{\\Delta t} \\right) + \\frac{\\Delta t}{4} L(u^{(1)})$\n$u^{(2)} = u_n + \\frac{1}{4}(u^{(1)} - u_n) + \\frac{\\Delta t}{4} L(u^{(1)})$\n$u^{(2)} = \\frac{3}{4} u_n + \\frac{1}{4} u^{(1)} + \\frac{1}{4} \\Delta t L(u^{(1)})$\n这可以被组合为：\n$u^{(2)} = \\frac{3}{4} u_n + \\frac{1}{4} \\left( u^{(1)} + \\Delta t L(u^{(1)}) \\right)$\n这将 $u^{(2)}$ 表示为 $u_n$（即 $u^{(0)}$）和项 $u^{(1)} + \\Delta t L(u^{(1)})$ 的凸组合。这一项是从 $u^{(1)}$ 开始，步长为 $\\Delta t$ 的一个前向欧拉步。系数 $\\frac{3}{4}$ 和 $\\frac{1}{4}$ 是正的，且和为1。\n\n**阶段 3 (最终更新):**\n最后，我们将解 $u_{n+1}$ 表示为涉及 $u_n$、$u^{(1)}$ 和 $u^{(2)}$ 的凸组合。SSPRK($3,3$)最后阶段的规范 Shu-Osher 形式是：\n$u_{n+1} = \\frac{1}{3} u_n + \\frac{2}{3} \\left( u^{(2)} + \\Delta t L(u^{(2)}) \\right)$\n这是 $u_n$ 和一个从 $u^{(2)}$ 开始，步长为 $\\Delta t$ 的前向欧拉步的凸组合。系数是 $\\frac{1}{3}$ 和 $\\frac{2}{3}$。\n我们来验证这个形式等价于 Butcher 公式：\n$u_{n+1} = \\frac{1}{3} u_n + \\frac{2}{3} u^{(2)} + \\frac{2}{3} \\Delta t L(u^{(2)})$\n代入 $u^{(2)} = u_n + \\frac{\\Delta t}{4} L(u_n) + \\frac{\\Delta t}{4} L(u^{(1)})$ 的表达式：\n$u_{n+1} = \\frac{1}{3} u_n + \\frac{2}{3} \\left( u_n + \\frac{\\Delta t}{4} L(u_n) + \\frac{\\Delta t}{4} L(u^{(1)}) \\right) + \\frac{2}{3} \\Delta t L(u^{(2)})$\n$u_{n+1} = \\left(\\frac{1}{3} + \\frac{2}{3}\\right) u_n + \\frac{2}{12} \\Delta t L(u_n) + \\frac{2}{12} \\Delta t L(u^{(1)}) + \\frac{2}{3} \\Delta t L(u^{(2)})$\n$u_{n+1} = u_n + \\frac{1}{6} \\Delta t L(u_n) + \\frac{1}{6} \\Delta t L(u^{(1)}) + \\frac{2}{3} \\Delta t L(u^{(2)})$\n这与 Butcher 更新公式相匹配，因为 $L(u_n)$、$L(u^{(1)})$ 和 $L(u^{(2)})$ 分别对应于 $k_1$、$k_2$ 和 $k_3$。\n\n完整的 Shu–Osher 表示为：\n1. $u^{(0)} = u_n$\n2. $u^{(1)} = u^{(0)} + \\Delta t L(u^{(0)})$\n3. $u^{(2)} = \\frac{3}{4} u^{(0)} + \\frac{1}{4} \\left( u^{(1)} + \\Delta t L(u^{(1)}) \\right)$\n4. $u_{n+1} = \\frac{1}{3} u^{(0)} + \\frac{2}{3} \\left( u^{(2)} + \\Delta t L(u^{(2)}) \\right)$\n\n现在，我们确定最优的SSP系数 $C$。如果一个方法在时间步长限制 $\\Delta t \\le C \\Delta t_{\\mathrm{FE}}$ 下，解的范数不增加，即 $\\|u_{n+1}\\| \\le \\|u_n\\|$，则该方法是SSP的。如果 Shu-Osher 表示的每个阶段本身都是一个非扩张操作，那么这个性质就可以实现。\n\n我们把前向欧拉算子记为 $FE(y, \\delta t) = y + \\delta t L(y)$。给定条件是，如果 $\\delta t \\le \\Delta t_{\\mathrm{FE}}$，则 $\\|FE(y, \\delta t)\\| \\le \\|y\\|$。\n\n这些阶段可以写成：\n1. $u^{(1)} = FE(u^{(0)}, \\Delta t)$\n2. $u^{(2)} = \\frac{3}{4} u^{(0)} + \\frac{1}{4} FE(u^{(1)}, \\Delta t)$\n3. $u_{n+1} = \\frac{1}{3} u^{(0)} + \\frac{2}{3} FE(u^{(2)}, \\Delta t)$\n\n为了使该方法是非扩张的，即 $\\|u_{n+1}\\| \\le \\|u_n\\| = \\|u^{(0)}\\|$，我们必须确保每一步都保持这个性质。\n1. 为了使 $\\|u^{(1)}\\| \\le \\|u^{(0)}\\|$ 成立，我们需要在 $FE(u^{(0)}, \\Delta t)$ 中使用的步长不超过 $\\Delta t_{\\mathrm{FE}}$。这给出了条件 $\\Delta t \\le \\Delta t_{\\mathrm{FE}}$。\n\n2. 假设 $\\|u^{(1)}\\| \\le \\|u^{(0)}\\|$，我们分析 $u^{(2)}$。\n$\\|u^{(2)}\\| = \\left\\| \\frac{3}{4} u^{(0)} + \\frac{1}{4} FE(u^{(1)}, \\Delta t) \\right\\|$\n根据三角不等式和凸组合的性质：\n$\\|u^{(2)}\\| \\le \\frac{3}{4} \\|u^{(0)}\\| + \\frac{1}{4} \\|FE(u^{(1)}, \\Delta t)\\|$\n为了使 $\\|FE(u^{(1)}, \\Delta t)\\| \\le \\|u^{(1)}\\|$ 成立，我们要求其步长 $\\Delta t$ 满足 $\\Delta t \\le \\Delta t_{\\mathrm{FE}}$。\n如果这个条件成立，$\\|u^{(2)}\\| \\le \\frac{3}{4} \\|u^{(0)}\\| + \\frac{1}{4} \\|u^{(1)}\\| \\le \\frac{3}{4} \\|u^{(0)}\\| + \\frac{1}{4} \\|u^{(0)}\\| = \\|u^{(0)}\\|$。所以 $\\|u^{(2)}\\| \\le \\|u_n\\|$。\n\n3. 假设 $\\|u^{(2)}\\| \\le \\|u^{(0)}\\|$，我们分析 $u_{n+1}$。\n$\\|u_{n+1}\\| = \\left\\| \\frac{1}{3} u^{(0)} + \\frac{2}{3} FE(u^{(2)}, \\Delta t) \\right\\|$\n$\\|u_{n+1}\\| \\le \\frac{1}{3} \\|u^{(0)}\\| + \\frac{2}{3} \\|FE(u^{(2)}, \\Delta t)\\|$\n为了使 $\\|FE(u^{(2)}, \\Delta t)\\| \\le \\|u^{(2)}\\|$ 成立，我们要求 $\\Delta t \\le \\Delta t_{\\mathrm{FE}}$。\n如果这个条件成立，$\\|u_{n+1}\\| \\le \\frac{1}{3} \\|u^{(0)}\\| + \\frac{2}{3} \\|u^{(2)}\\| \\le \\frac{1}{3} \\|u^{(0)}\\| + \\frac{2}{3} \\|u^{(0)}\\| = \\|u^{(0)}\\|$。所以 $\\|u_{n+1}\\| \\le \\|u_n\\|$。\n\n所有三个阶段都要求前向欧拉步是非扩张的，而它们的有效步长都是 $\\Delta t$。对此的条件始终是 $\\Delta t \\le \\Delta t_{\\mathrm{FE}}$。因此，为使 SSPRK($3,3$) 方法是SSP的，总的时间步长限制是 $\\Delta t \\le 1 \\cdot \\Delta t_{\\mathrm{FE}}$。\n\n将此结果与定义 $\\Delta t \\le C \\Delta t_{\\mathrm{FE}}$ 进行比较，最优（可能的最大）SSP系数为 $C=1$。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "理论与实践的结合是数值分析的魅力所在，而“超收敛”则是间断伽辽金(DG)方法中一个令人惊喜的现象。在某些特定条件下，DG解的某些量（例如单元平均值）的收敛速度会高于理论上对整个解所预测的阶数。本练习是一个完整的计算项目，你将从零开始构建一个RKDG求解器，通过数值实验亲自观测并验证这一超收敛现象，从而深刻体会时间积分格式的选择如何影响空间离散的精度特性 。",
            "id": "3441447",
            "problem": "考虑标量线性平流偏微分方程 (PDE) $u_t + a u_x = 0$，定义在周期性域 $x \\in [0,1]$ 上，其中 $a=1$，初始数据为光滑函数 $u(x,0) = \\sin(2\\pi x) + \\frac{1}{4}\\cos(6\\pi x)$。半离散近似将使用间断 Galerkin (DG) 方法构建，其中多项式次数为 $p=1$，网格为包含 $N$ 个单元的均匀网格，对 $a>0$ 使用标准的迎风数值通量，并在参考单元 $\\xi \\in [-1,1]$ 上使用张成 $\\{1, \\xi\\}$ 的局部基。时间演化将通过显式 Runge–Kutta (RK) 时间步进执行，从而得到 Runge–Kutta 间断 Galerkin (RKDG) 方法。\n\n从弱形式定义和周期性边界条件出发，DG 半离散系统可以通过将 PDE 与测试函数相乘并积分，然后应用分部积分法推导得出。初始条件必须通过 $L^2$-投影被投影到 DG 空间上。对于每个网格单元，在时间 $t$ 的单元平均值定义为 $\\bar{u}_j(t) = \\frac{1}{h}\\int_{I_j}u(x,t)\\,\\mathrm{d}x$，其中 $h=1/N$ 且 $I_j$ 是第 $j$ 个单元。\n\n你需要研究 RKDG 单元平均值的超收敛性，具体来说，是在时间 $t = \\theta h$（其中 $\\theta = 0.8$）时，单元平均值的观测收敛阶是否相对于 $p=1$ 的标称设计阶表现出空间超收敛性。为进行此研究：\n\n- 使用与在参考单元上选择基函数 $\\{1,\\xi\\}$、到物理坐标的映射 $x = x_j + \\frac{h}{2}(\\xi+1)$ 以及在周期性边界条件下对 $a>0$ 使用的标准迎风数值通量一致的半离散 DG 公式。\n- 使用由其 Butcher 表和级横坐标指定的显式 Runge–Kutta 方法进行时间积分。待测试的显式 RK 方法如下：\n  1. 1 阶向前欧拉法，其系数为 $A=[0]$, $b=[1]$, $c=[0]$。\n  2. 2 阶 Heun 方法（显式梯形法），其系数为 $A = \\begin{pmatrix}0 & 0 \\\\ 1 & 0\\end{pmatrix}$, $b = [\\frac{1}{2}, \\frac{1}{2}]$, $c = [0,1]$。\n  3. 3 阶强稳定性保持 Runge–Kutta 方法 (SSPRK3)，其系数为 $A = \\begin{pmatrix}0 & 0 & 0 \\\\ 1 & 0 & 0 \\\\ \\frac{1}{4} & \\frac{1}{4} & 0\\end{pmatrix}$, $b = [\\frac{1}{6}, \\frac{1}{6}, \\frac{2}{3}]$, $c = [0,1,\\frac{1}{2}]$。\n  4. 3 阶 Kutta 经典 3 级方法，其系数为 $A = \\begin{pmatrix}0 & 0 & 0 \\\\ \\frac{1}{2} & 0 & 0 \\\\ -1 & 2 & 0\\end{pmatrix}$, $b = [\\frac{1}{6}, \\frac{2}{3}, \\frac{1}{6}]$, $c = [0,\\frac{1}{2},1]$。\n  5. 4 阶经典 4 级 Runge–Kutta 方法，其系数为 $A = \\begin{pmatrix}0 & 0 & 0 & 0 \\\\ \\frac{1}{2} & 0 & 0 & 0 \\\\ 0 & \\frac{1}{2} & 0 & 0 \\\\ 0 & 0 & 1 & 0\\end{pmatrix}$, $b = [\\frac{1}{6}, \\frac{1}{3}, \\frac{1}{3}, \\frac{1}{6}]$, $c = [0,\\frac{1}{2},\\frac{1}{2},1]$。\n- 对于每种方法，选择一个稳定的时间步长 $\\Delta t$，使其满足一个统一的 Courant–Friedrichs–Lewy (CFL) 约束 $\\Delta t = \\mathrm{CFL}\\cdot \\frac{h}{(2p+1)a}$（其中 $\\mathrm{CFL} = 0.1$），并使用所需的步数达到时间 $t=\\theta h$。确保在所有测试的网格分辨率下都具有精确的周期性和数值稳定性。\n\n对于多项式次数 $p=1$，在时间 $t=\\theta h$ 的单元平均值的空间超收敛性定义如下：使用网格上的 $L^2$-范数计算单元平均值的离散误差，在一系列加密的网格尺寸上比较误差，并通过对数-对数斜率估计观测到的空间收敛阶 $r$。如果 $r \\geq r_{\\mathrm{thr}}$（其中 $r_{\\mathrm{thr}} = 2.7$），则宣布该方法在 $t=\\mathcal{O}(h)$ 时表现出单元平均值的空间超收敛性。\n\n程序要求：\n\n- 根据第一性原理实现 $p=1$ 的 DG 半离散算子，该算子由在参考单元上使用测试函数 $1$ 和 $\\xi$ 的弱形式所隐含，包括正确的导数映射以及在周期性边界条件下对 $a>0$ 使用的迎风通量。\n- 在参考单元上使用足够精确的求积法则，通过 $L^2$-投影将初始条件 $u(x,0)$ 投影到 DG 空间中。\n- 对于每个网格尺寸，使用上面列出的每种显式 Runge–Kutta 方法将 DG 自由度推进到最终时间 $t=\\theta h$。\n- 对于网格尺寸 $N \\in \\{50, 100, 200\\}$，通过计算单元平均值相对于精确解 $u(x,t) = \\sin(2\\pi(x-t)) + \\frac{1}{4}\\cos(6\\pi(x-t))$ 的 $L^2$-误差，并取成对斜率的平均值，来估计单元平均值的观测空间收敛阶 $r$。\n- 当 $r \\geq r_{\\mathrm{thr}}$ 时，宣布为超收敛。\n\n测试套件：\n\n- 程序必须测试上面列出的五种显式 Runge–Kutta 方法，使用的网格尺寸为 $N \\in \\{50, 100, 200\\}$，参数为 $p=1$、$a=1$、$\\theta = 0.8$ 和 $\\mathrm{CFL} = 0.1$。\n\n答案规范和最终输出格式：\n\n- 对于这五种方法中的每一种，程序必须计算并以浮点数形式报告单元平均值的观测空间收敛阶 $r$。\n- 使用超收敛准则 $r \\geq r_{\\mathrm{thr}}$，在测试的方法中确定在 $t=\\theta h$ 时能实现单元平均值空间超收敛的最低 Runge–Kutta 阶数。\n- 对于确定的最低阶方法，确定其级横坐标是否同时包含 $c=\\frac{1}{2}$ 和 $c=1$（级配置属性）。\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序如下：\n  1. 分别为向前欧拉法、Heun RK2、SSPRK3、Kutta RK3 和 RK4 的观测收敛阶，格式为浮点数。\n  2. 实现空间超收敛的最低 Runge–Kutta 阶数，格式为整数。\n  3. 一个布尔值，表示所选最低阶方法的级横坐标是否同时包含 $c=\\frac{1}{2}$ 和 $c=1$。",
            "solution": "用户希望研究应用于线性平流方程的 Runge-Kutta 间断 Galerkin (RKDG) 方法的单元平均值的空间超收敛性。\n\n### 问题验证\n该问题是有效的。它描述了偏微分方程 (PDE) 数值分析领域中的一个标准数值实验。所有组成部分——PDE、域、初始条件、空间离散化 (DG) 和时间离散化（显式 RK 方法）——都定义明确且是标准的。参数（$p, a, \\theta, \\mathrm{CFL}$）、网格加密序列、误差度量（单元平均值误差的 $L^2$-范数）以及超收敛准则（$r \\geq 2.7$）都已精确指定。该问题具有科学依据、适定且客观。\n\n### 方法描述\n\n问题是求解在域 $x \\in [0,1]$ 上，具有周期性边界条件、平流速度为 $a=1$、初始数据为 $u(x,0) = \\sin(2\\pi x) + \\frac{1}{4}\\cos(6\\pi x)$ 的标量线性平流方程 $u_t + a u_x = 0$。其精确解为 $u(x,t) = u(x-at, 0)$。\n\n#### 1. 间断 Galerkin (DG) 半离散化\n\n我们将空间域离散为 $N$ 个均匀单元 $I_j = [x_j, x_{j+1}]$，宽度为 $h=1/N$，其中 $j=0, \\dots, N-1$。在每个单元内，解 $u_h(x,t)$ 由一个次数为 $p=1$ 的多项式近似。\n\n弱形式通过将 PDE 乘以来自同一多项式空间的测试函数 $v_h$ 并在一个单元 $I_j$ 上积分得到：\n$$ \\int_{I_j} (u_h)_t v_h \\,dx + \\int_{I_j} a (u_h)_x v_h \\,dx = 0 $$\n对平流项应用分部积分法得到：\n$$ \\int_{I_j} (u_h)_t v_h \\,dx + [a u_h v_h]_{x_j}^{x_{j+1}} - \\int_{I_j} a u_h (v_h)_x \\,dx = 0 $$\n由于 $u_h$ 在单元边界处是不连续的，项 $a u_h$ 被数值通量 $\\hat{f}(u_h^-, u_h^+)$ 替换，其中 $u_h^-$ 和 $u_h^+$ 分别是界面左侧和右侧的解的值。对于 $a > 0$，迎风通量为 $\\hat{f}(u_L, u_R) = a u_L$。弱形式变为：\n$$ \\int_{I_j} (u_h)_t v_h \\,dx + \\hat{f}(x_{j+1}) v_h(x_{j+1}^-) - \\hat{f}(x_j) v_h(x_j^+) - \\int_{I_j} a u_h(v_h)_x \\,dx = 0 $$\n其中 $\\hat{f}(x_{j+1}) = a u_h(x_{j+1}^-)$ 以及 $\\hat{f}(x_j) = a u_h(x_j^-) = a u_h(x_{j-1, \\text{right}})$。\n\n我们在参考单元 $\\xi \\in [-1,1]$ 上使用一个张成 $\\{1, \\xi\\}$ 的局部基。令基函数为 $\\phi_0(\\xi)=1$ 和 $\\phi_1(\\xi)=\\xi$。单元 $I_j$ 上的解表示为 $u_h(x(\\xi), t) = U_j^0(t)\\phi_0(\\xi) + U_j^1(t)\\phi_1(\\xi)$。从参考坐标到物理坐标的映射为 $x(\\xi) = x_j + \\frac{h}{2}(1+\\xi)$，其中 $x_j=jh$。雅可比行列式为 $dx/d\\xi = h/2$。\n\n代入 $u_h$ 的展开式并选择 $v_h$ 为每个基函数 $\\phi_k$，我们得到一个关于自由度 $\\vec{U}_j(t) = [U_j^0(t), U_j^1(t)]^T$ 的常微分方程组 (ODE)：\n$$ \\frac{h}{2} M \\frac{d\\vec{U}_j}{dt} = a S \\vec{U}_j - a \\begin{pmatrix} u_h(x_{j+1}^-) \\phi_0(1) - u_h(x_j^-) \\phi_0(-1) \\\\ u_h(x_{j+1}^-) \\phi_1(1) - u_h(x_j^-) \\phi_1(-1) \\end{pmatrix} $$\n质量矩阵 $M$ 和刚度矩阵 $S$（在参考单元上）为：\n$$ M_{kl} = \\int_{-1}^1 \\phi_l \\phi_k \\,d\\xi = \\begin{pmatrix} 2 & 0 \\\\ 0 & 2/3 \\end{pmatrix}, \\quad S_{kl} = \\int_{-1}^1 \\phi_l \\frac{d\\phi_k}{d\\xi} \\,d\\xi = \\begin{pmatrix} 0 & 0 \\\\ 2 & 0 \\end{pmatrix} $$\n边界值为 $u_h(x_{j+1}^-) = u_h(\\xi=1) = U_j^0 + U_j^1$，并且，由于周期性和迎风格式，$u_h(x_j^-) = u_h(x_{j-1, \\text{right}}) = U_{j-1}^0 + U_{j-1}^1$。\n这导出了每个单元 $j$ 的半离散系统：\n$$ \\frac{d U_j^0}{dt} = -\\frac{a}{h} \\left[ (U_j^0+U_j^1) - (U_{j-1}^0+U_{j-1}^1) \\right] $$\n$$ \\frac{d U_j^1}{dt} = \\frac{3a}{h} \\left[ U_j^0 - U_j^1 - (U_{j-1}^0+U_{j-1}^1) \\right] $$\n系数 $U_j^0$ 是单元平均值，$\\bar{u}_{h,j}(t) = \\frac{1}{h}\\int_{I_j} u_h(x,t) dx = U_j^0(t)$。\n\n#### 2. 初始条件投影\n\n初始条件 $u(x,0)$ 使用 $L^2$-投影投影到 DG 空间上。对于每个单元 $I_j$，我们找到 $(U_j^0(0), U_j^1(0))$ 使得：\n$$ \\int_{I_j} u_h(x,0) v_h(x) \\,dx = \\int_{I_j} u(x,0) v_h(x) \\,dx \\quad \\forall v_h \\in P^1(I_j) $$\n这得到 $\\vec{U}_j(0) = M^{-1} \\int_{-1}^1 u(x(\\xi),0) [\\phi_0(\\xi), \\phi_1(\\xi)]^T \\,d\\xi$。为了保证足够的精度，积分使用 4 点 Gauss-Legendre 求积法则计算。\n\n#### 3. 时间积分\n\n半离散系统 $\\frac{d\\vec{U}}{dt} = L_h(\\vec{U})$ 使用五种指定的显式 Runge-Kutta (RK) 方法之一进行时间推进。给定一个由其 Butcher 表 $(A,b,c)$ 定义的 $s$ 级 RK 方法，从 $t_n$ 到 $t_{n+1}=t_n+\\Delta t$ 的一个时间步计算如下：\n$$ \\vec{k}_i = L_h\\left(\\vec{U}_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} \\vec{k}_j\\right), \\quad i=1, \\dots, s $$\n$$ \\vec{U}_{n+1} = \\vec{U}_n + \\Delta t \\sum_{i=1}^s b_i \\vec{k}_i $$\n时间步长为 $\\Delta t = \\mathrm{CFL} \\cdot h / (a(2p+1))$，其中 $\\mathrm{CFL}=0.1$。为达到最终时间 $t = \\theta h = 0.8h$，需要走固定的步数 $n_{\\text{steps}} = t/\\Delta t = 24$。\n\n#### 4. 误差计算与收敛性分析\n\n在最终时间 $t$，单元平均值的 $L^2$-误差计算如下：\n$$ E_N = \\left( h \\sum_{j=0}^{N-1} (\\bar{u}_{h,j}(t) - \\bar{u}_j(t))^2 \\right)^{1/2} $$\n其中 $\\bar{u}_{h,j}(t) = U_j^0(t)$ 是数值单元平均值，而 $\\bar{u}_j(t) = \\frac{1}{h}\\int_{I_j} u(x,t) \\,dx$ 是通过解析计算得到的精确单元平均值。\n通过对一系列网格尺寸 $N \\in \\{50, 100, 200\\}$ 进行模拟来估计观测到的空间收敛阶 $r$。该收敛阶是成对的对数-对数斜率的平均值：\n$$ r_{12} = \\frac{\\log(E_{50}/E_{100})}{\\log(100/50)}, \\quad r_{23} = \\frac{\\log(E_{100}/E_{200})}{\\log(200/100)}, \\quad r = \\frac{r_{12}+r_{23}}{2} $$\n如果一个方法的观测收敛阶 $r$ 至少为 $r_{\\mathrm{thr}} = 2.7$，则宣布其表现出空间超收敛性。$p=1$ 时的标称阶为 $p+1=2$，因此任何显著大于 2 的收敛阶都可视为超收敛。\n\n最后，我们在测试的方法中找出满足此标准的最低 RK 阶数，并检查其级横坐标向量 $c$ 是否同时包含 $1/2$ 和 $1$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RKDG superconvergence problem as specified.\n    \"\"\"\n    # Problem parameters\n    p = 1\n    a = 1.0\n    theta = 0.8\n    CFL = 0.1\n    r_thr = 2.7\n    Ns = [50, 100, 200]\n\n    # Butcher tableaux for the Runge-Kutta methods\n    rk_methods = {\n        'FE1': {'A': np.array([[0.0]]), 'b': np.array([1.0]), 'c': np.array([0.0]), 'order': 1},\n        'Heun2': {'A': np.array([[0.0, 0.0], [1.0, 0.0]]), 'b': np.array([0.5, 0.5]), 'c': np.array([0.0, 1.0]), 'order': 2},\n        'SSPRK3': {'A': np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.25, 0.25, 0.0]]), 'b': np.array([1.0/6.0, 1.0/6.0, 2.0/3.0]), 'c': np.array([0.0, 1.0, 0.5]), 'order': 3},\n        'Kutta3': {'A': np.array([[0.0, 0.0, 0.0], [0.5, 0.0, 0.0], [-1.0, 2.0, 0.0]]), 'b': np.array([1.0/6.0, 2.0/3.0, 1.0/6.0]), 'c': np.array([0.0, 0.5, 1.0]), 'order': 3},\n        'RK4': {'A': np.array([[0.0, 0.0, 0.0, 0.0], [0.5, 0.0, 0.0, 0.0], [0.0, 0.5, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0]]), 'b': np.array([1.0/6.0, 1.0/3.0, 1.0/3.0, 1.0/6.0]), 'c': np.array([0.0, 0.5, 0.5, 1.0]), 'order': 4}\n    }\n    method_keys = ['FE1', 'Heun2', 'SSPRK3', 'Kutta3', 'RK4']\n\n    # Initial condition and exact solution\n    def u_initial(x):\n        return np.sin(2 * np.pi * x) + 0.25 * np.cos(6 * np.pi * x)\n\n    def exact_cell_average(j, h, t):\n        x1 = j * h\n        x2 = (j + 1) * h\n        val1 = -np.cos(2*np.pi*(x2 - a*t))/(2*np.pi) + np.sin(6*np.pi*(x2 - a*t))/(24*np.pi)\n        val2 = -np.cos(2*np.pi*(x1 - a*t))/(2*np.pi) + np.sin(6*np.pi*(x1 - a*t))/(24*np.pi)\n        return (val1 - val2) / h\n\n    # 4-point Gauss-Legendre quadrature for the interval [-1, 1]\n    w_quad = np.array([(18+np.sqrt(30))/36, (18+np.sqrt(30))/36, (18-np.sqrt(30))/36, (18-np.sqrt(30))/36])\n    xi_quad = np.array([-np.sqrt(3/7 - 2/7 * np.sqrt(6/5)), np.sqrt(3/7 - 2/7 * np.sqrt(6/5)), -np.sqrt(3/7 + 2/7 * np.sqrt(6/5)), np.sqrt(3/7 + 2/7 * np.sqrt(6/5))])\n\n    def project_ic(N, h):\n        dofs = np.zeros((N, 2))\n        for j in range(N):\n            x_j = j * h\n            x_vals = x_j + h/2.0 * (1.0 + xi_quad)\n            u_vals = u_initial(x_vals)\n            \n            I0 = np.sum(w_quad * u_vals)\n            I1 = np.sum(w_quad * u_vals * xi_quad)\n\n            dofs[j, 0] = I0 / 2.0\n            dofs[j, 1] = 3.0 * I1 / 2.0\n        return dofs.flatten()\n\n    def dg_rhs(dofs_flat, N, h, a_val):\n        dofs = dofs_flat.reshape((N, 2))\n        d_dofs_dt = np.zeros_like(dofs)\n        \n        u_right = dofs[:, 0] + dofs[:, 1]\n        \n        # Periodic boundary condition: u_right for cell j-1, where j=0 is `u_right[N-1]`\n        u_prev_right = np.roll(u_right, 1)\n\n        d_dofs_dt[:, 0] = -a_val / h * (u_right - u_prev_right)\n        d_dofs_dt[:, 1] = 3.0 * a_val / h * (dofs[:, 0] - dofs[:, 1] - u_prev_right)\n        \n        return d_dofs_dt.flatten()\n\n    def rk_stepper(dofs0, N, h, dt, n_steps, method):\n        dofs = dofs0.copy()\n        s = len(method['b'])\n        k_stages = np.zeros((s, len(dofs)))\n        \n        for _ in range(n_steps):\n            temp_dofs = dofs.copy() # Use state at beginning of step for all stages\n            for i in range(s):\n                stage_dofs = temp_dofs + dt * np.dot(method['A'][i, :i], k_stages[:i, :])\n                k_stages[i, :] = dg_rhs(stage_dofs, N, h, a)\n            dofs += dt * np.dot(method['b'], k_stages)\n        return dofs\n\n    # Main loop for convergence study\n    rates = []\n    for key in method_keys:\n        method = rk_methods[key]\n        errors = []\n        for N in Ns:\n            h = 1.0 / N\n            final_time = theta * h\n            dt = CFL * h / ((2 * p + 1) * a)\n            n_steps = int(np.round(final_time / dt))\n            \n            dofs0 = project_ic(N, h)\n            dofs_final_flat = rk_stepper(dofs0, N, h, dt, n_steps, method)\n            dofs_final = dofs_final_flat.reshape((N, 2))\n            \n            numeric_cell_avg = dofs_final[:, 0]\n            exact_avg = np.array([exact_cell_average(j, h, final_time) for j in range(N)])\n            \n            error_sq_sum = np.sum((numeric_cell_avg - exact_avg)**2)\n            l2_error = np.sqrt(h * error_sq_sum)\n            errors.append(l2_error)\n        \n        log_h_ratio = np.log(float(Ns[1]) / Ns[0])\n        r12 = np.log(errors[0] / errors[1]) / log_h_ratio\n        r23 = np.log(errors[1] / errors[2]) / log_h_ratio\n        rate = (r12 + r23) / 2.0\n        rates.append(rate)\n\n    # Analyze results for superconvergence\n    min_order = -1\n    has_property = False\n    \n    # Check methods in increasing order of their theoretical order\n    indexed_rates = list(enumerate(rates))\n    # Sort by order of the method, then by original index to keep it stable\n    sorted_indices = sorted(range(len(method_keys)), key=lambda k: (rk_methods[method_keys[k]]['order'], k))\n    \n    found_min = False\n    for idx in sorted_indices:\n        if rates[idx] >= r_thr and not found_min:\n            key = method_keys[idx]\n            method = rk_methods[key]\n            min_order = method['order']\n            c_vec = method['c']\n            has_half = any(np.isclose(val, 0.5) for val in c_vec)\n            has_one = any(np.isclose(val, 1.0) for val in c_vec)\n            has_property = has_half and has_one\n            found_min = True\n    \n    # Assembling final result list\n    final_results = rates.copy()\n    final_results.append(min_order)\n    final_results.append(has_property)\n\n    # Formatting output\n    formatted_results = []\n    for item in final_results:\n        if isinstance(item, bool):\n            formatted_results.append(str(item).lower())\n        elif isinstance(item, int):\n            formatted_results.append(f\"{item}\")\n        else:\n            formatted_results.append(f\"{item:.14f}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}