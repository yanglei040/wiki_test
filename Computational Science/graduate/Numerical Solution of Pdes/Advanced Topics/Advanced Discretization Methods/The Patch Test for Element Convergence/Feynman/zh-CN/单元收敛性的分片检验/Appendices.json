{
    "hands_on_practices": [
        {
            "introduction": "有限元分析的准确性不仅取决于单元表示多项式解的能力，还取决于用于计算单元矩阵的数值积分的精度。此练习  提供了一个具体的计算实践，要求您确定高阶单元 ($P_2$) 为正确再现二次解场所需的最低求积精度。它将分片检验的理论要求与选择求积规则的实际实现细节联系起来。",
            "id": "3456368",
            "problem": "考虑在多边形区域 $\\Omega \\subset \\mathbb{R}^{2}$ 上的具有常数各向同性传导系数的标量泊松方程，\n$$\n-\\nabla \\cdot \\left( \\kappa \\nabla u \\right) = f \\quad \\text{in } \\Omega, \\qquad u = g \\quad \\text{on } \\partial \\Omega,\n$$\n其中 $\\kappa > 0$ 为常数。设 $\\mathcal{T}_{h}$ 是 $\\Omega$ 的一个形状规则的单纯剖分，由通过对一个固定的参考三角形 $\\widehat{T}$ 进行仿射映射得到的直边三角形组成。考虑在 $\\mathcal{T}_{h}$ 上的协调二次拉格朗日有限元空间（通常记作 $P_{2}$）。有限元方法 (FEM) 使用标准的弱形式：\n$$\na(u_{h}, v_{h}) = \\ell(v_{h}) \\quad \\text{for all } v_{h} \\in V_{h,0},\n$$\n其中\n$$\na(u_{h}, v_{h}) = \\sum_{T \\in \\mathcal{T}_{h}} \\int_{T} \\kappa \\, \\nabla u_{h} \\cdot \\nabla v_{h} \\, \\mathrm{d}x, \n\\qquad \n\\ell(v_{h}) = \\sum_{T \\in \\mathcal{T}_{h}} \\int_{T} f \\, v_{h} \\, \\mathrm{d}x,\n$$\n且 $V_{h,0}$ 是具有齐次本质边界数据的子空间。在泊松方程的二次 ($P_{2}$) 检验单元测试中，我们指定边界数据和体力，使得精确解 $u^{\\star}$ 是 $\\Omega$ 上的一个总次数为 2 的多项式，然后检查离散解 $u_{h}$ 是否在精确代数下在一个单元片上精确地再现 $u^{\\star}$。\n\n假设单元矩阵和向量是通过在每个三角形上应用相同的多项式求积法则（具有正权重）来组装的，该法则是通过仿射单元映射从 $\\widehat{T}$ 拉回的。仅从以下几点出发：\n- 上述标准弱形式，\n- $P_{2}$ 形函数在每个三角形上是总次数为 2 的多项式，其梯度是总次数为 1 的多项式，\n- 以及对于二次多项式 $u^{\\star}$，$f = -\\kappa \\Delta u^{\\star}$ 是一个总次数为 0 的常数多项式，\n\n推导三角形求积（在每个单元上）必须具备的最小多项式精确度 $q$，以保证 $P_{2}$ 方法在仿射网格上通过泊松方程的二次检验单元测试。然后，在顶点为 $(0,0)$, $(1,0)$, $(0,1)$ 的参考三角形上，指定一个达到此精确度 $q$ 的具体对称三角形求积法则，给出其重心坐标求值点和权重，并通过验证它能精确再现所有总次数不超过 $q$ 的单项式的精确积分来证明其精确度阶。\n\n在你的最终答案中，只报告最小多项式精确度 $q$（作为一个不带单位的整数）。无需四舍五入。",
            "solution": "我们从具有常数各向同性传导系数的标量泊松方程的弱形式开始：\n$$\na(u_{h}, v_{h}) = \\sum_{T \\in \\mathcal{T}_{h}} \\int_{T} \\kappa \\, \\nabla u_{h} \\cdot \\nabla v_{h} \\, \\mathrm{d}x, \n\\qquad \n\\ell(v_{h}) = \\sum_{T \\in \\mathcal{T}_{h}} \\int_{T} f \\, v_{h} \\, \\mathrm{d}x,\n$$\n其中 $\\kappa$ 是常数，$f$ 是体力。二次检验单元测试要求，如果精确解 $u^{\\star}$ 是一个总次数为 2 的多项式，那么在一致的本质边界条件和匹配的 $f = -\\kappa \\Delta u^{\\star}$下，通过有限元方法计算出的离散解能够精确地再现 $u^{\\star}$。在仿射网格上，从参考三角形 $\\widehat{T}$ 到物理单元三角形 $T$ 的单元映射是仿射的，因此物理三角形 $T$ 上的多项式对应于 $\\widehat{T}$ 上相同总次数的多项式（最多相差面积元素的常数雅可比行列式乘积和梯度的常数矩阵乘积）。因此，$T$ 上多项式求积的精确性等价于 $\\widehat{T}$ 上相同总次数的精确性。\n\n我们通过检查在使用二次拉格朗日 ($P_{2}$) 形函数时，单元级双线性和线性形式中出现的被积函数的次数来确定所需的精确度 $q$。\n\n首先，考虑单元刚度的贡献。设 $\\{\\varphi_{i}\\}$ 表示单元 $T$ 上的局部 $P_{2}$ 形函数。每个形函数 $\\varphi_{i}$ 是一个总次数为 2 的多项式，因此其梯度 $\\nabla \\varphi_{i}$ 是一个总次数为 1 的多项式向量。单元刚度矩阵项为\n$$\nK_{ij}^{(T)} = \\int_{T} \\kappa \\, \\nabla \\varphi_{i} \\cdot \\nabla \\varphi_{j} \\, \\mathrm{d}x.\n$$\n因为 $\\kappa$ 是常数，且 $\\nabla \\varphi_{i}$ 和 $\\nabla \\varphi_{j}$ 都是总次数为 1 的多项式，所以点积 $\\nabla \\varphi_{i} \\cdot \\nabla \\varphi_{j}$ 是一个总次数为 2 的多项式。因此，为了在 $T$ 上通过求积精确计算 $K_{ij}^{(T)}$，该求积法则必须对所有总次数不超过 2 的多项式都是精确的。\n\n其次，考虑单元载荷的贡献。对于检验函数 $\\varphi_{i}$，单元载荷项为\n$$\nF_{i}^{(T)} = \\int_{T} f \\, \\varphi_{i} \\, \\mathrm{d}x.\n$$\n对于二次检验单元测试，$u^{\\star}$ 是一个总次数为 2 的多项式，且 $\\kappa$ 为常数，强迫项为 $f = - \\kappa \\Delta u^{\\star}$。由于二次多项式的拉普拉斯 $\\Delta u^{\\star}$ 是一个常数，所以 $f$ 是一个总次数为 0 的常数多项式。将 $f$ 乘以 $\\varphi_{i}$（次数为 2）得到的被积函数总次数为 2。因此，通过求积精确计算 $F_{i}^{(T)}$ 同样要求对总次数不超过 2 的多项式是精确的。\n\n在当前的本质边界值设定中，没有诺伊曼边界项，因此精确性所要求的最大多项式次数由上述体积分决定。因此，在仿射网格上使用 $P_{2}$ 形函数求解常系数泊松方程时，为通过二次检验单元测试，三角形求积所需的最小多项式精确度为\n$$\nq = 2.\n$$\n\n我们现在在顶点为 $(0,0)$, $(1,0)$, $(0,1)$ 的参考三角形 $\\widehat{T} = \\{ (\\xi,\\eta) \\in \\mathbb{R}^{2} : \\xi \\ge 0, \\, \\eta \\ge 0, \\, \\xi + \\eta \\le 1 \\}$ 上指定一个达到精确度 $q = 2$ 的具体对称三角形求积法则。一个标准的选择是三点对称法则，其求值点由重心坐标给出\n$$\n(\\lambda_{1}, \\lambda_{2}, \\lambda_{3}) \\in \\left\\{ \\left( \\tfrac{2}{3}, \\tfrac{1}{6}, \\tfrac{1}{6} \\right), \\left( \\tfrac{1}{6}, \\tfrac{2}{3}, \\tfrac{1}{6} \\right), \\left( \\tfrac{1}{6}, \\tfrac{1}{6}, \\tfrac{2}{3} \\right) \\right\\},\n$$\n权重相等\n$$\nw_{1} = w_{2} = w_{3} = \\tfrac{1}{3}.\n$$\n将求积写成面积归一化形式，对于 $\\widehat{T}$ 上任何足够光滑的函数 $f$，\n$$\n\\int_{\\widehat{T}} f(\\xi,\\eta) \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta \\approx |\\widehat{T}| \\sum_{i=1}^{3} w_{i} \\, f(\\xi_{i}, \\eta_{i}),\n$$\n其中 $|\\widehat{T}| = \\tfrac{1}{2}$ 是 $\\widehat{T}$ 的面积，$(\\xi_{i}, \\eta_{i})$ 是上述重心点相对于顶点 $(0,0)$, $(1,0)$, $(0,1)$ 的笛卡尔坐标。在这些坐标中，$\\xi = \\lambda_{2}$ 且 $\\eta = \\lambda_{3}$，所以这三个点是\n$$\n(\\xi,\\eta) \\in \\left\\{ \\left( \\tfrac{1}{6}, \\tfrac{1}{6} \\right), \\left( \\tfrac{2}{3}, \\tfrac{1}{6} \\right), \\left( \\tfrac{1}{6}, \\tfrac{2}{3} \\right) \\right\\}.\n$$\n\n我们通过在单项式基 $\\{ 1, \\xi, \\eta, \\xi^{2}, \\xi \\eta, \\eta^{2} \\}$ 上验证其精确性，来证明该法则对所有总次数不超过 2 的多项式都是精确的。在 $\\widehat{T}$ 上的精确积分是已知的：\n$$\n\\int_{\\widehat{T}} 1 \\, \\mathrm{d}A = \\tfrac{1}{2}, \n\\quad \n\\int_{\\widehat{T}} \\xi \\, \\mathrm{d}A = \\tfrac{1}{6}, \n\\quad \n\\int_{\\widehat{T}} \\eta \\, \\mathrm{d}A = \\tfrac{1}{6},\n$$\n$$\n\\int_{\\widehat{T}} \\xi^{2} \\, \\mathrm{d}A = \\tfrac{1}{12}, \n\\quad \n\\int_{\\widehat{T}} \\xi \\eta \\, \\mathrm{d}A = \\tfrac{1}{24}, \n\\quad \n\\int_{\\widehat{T}} \\eta^{2} \\, \\mathrm{d}A = \\tfrac{1}{12}.\n$$\n使用 $|\\widehat{T}| = \\tfrac{1}{2}$ 和 $w_{i} = \\tfrac{1}{3}$，求积近似得到：\n\n- 对于 $f \\equiv 1$: \n$$\n\\tfrac{1}{2} \\sum_{i=1}^{3} \\tfrac{1}{3} \\cdot 1 = \\tfrac{1}{2} \\cdot 1 = \\tfrac{1}{2}.\n$$\n\n- 对于 $f(\\xi,\\eta) = \\xi$: \n$$\n\\tfrac{1}{2} \\cdot \\tfrac{1}{3} \\left( \\tfrac{1}{6} + \\tfrac{2}{3} + \\tfrac{1}{6} \\right) = \\tfrac{1}{2} \\cdot \\tfrac{1}{3} \\cdot 1 = \\tfrac{1}{6}.\n$$\n\n- 对于 $f(\\xi,\\eta) = \\eta$：根据对称性，与 $\\xi$ 的情况相同，等于 $\\tfrac{1}{6}$。\n\n- 对于 $f(\\xi,\\eta) = \\xi^{2}$:\n$$\n\\tfrac{1}{2} \\cdot \\tfrac{1}{3} \\left( \\left( \\tfrac{1}{6} \\right)^{2} + \\left( \\tfrac{2}{3} \\right)^{2} + \\left( \\tfrac{1}{6} \\right)^{2} \\right)\n= \\tfrac{1}{2} \\cdot \\tfrac{1}{3} \\left( \\tfrac{1}{36} + \\tfrac{4}{9} + \\tfrac{1}{36} \\right)\n= \\tfrac{1}{2} \\cdot \\tfrac{1}{3} \\cdot \\tfrac{1}{2}\n= \\tfrac{1}{12}.\n$$\n\n- 对于 $f(\\xi,\\eta) = \\xi \\eta$:\n$$\n\\tfrac{1}{2} \\cdot \\tfrac{1}{3} \\left( \\tfrac{1}{6} \\cdot \\tfrac{1}{6} + \\tfrac{2}{3} \\cdot \\tfrac{1}{6} + \\tfrac{1}{6} \\cdot \\tfrac{2}{3} \\right)\n= \\tfrac{1}{2} \\cdot \\tfrac{1}{3} \\left( \\tfrac{1}{36} + \\tfrac{2}{18} + \\tfrac{2}{18} \\right)\n= \\tfrac{1}{2} \\cdot \\tfrac{1}{3} \\cdot \\tfrac{1}{4}\n= \\tfrac{1}{24}.\n$$\n\n- 对于 $f(\\xi,\\eta) = \\eta^{2}$：根据对称性，与 $\\xi^{2}$ 的情况相同，等于 $\\tfrac{1}{12}$。\n\n因此，该法则对所有总次数不超过 2 的多项式都是精确的，即其精确度为 $q = 2$。\n\n总之，对于在仿射三角形网格上使用 $P_{2}$ 单元求解常系数泊松方程，当且仅当单元求积对总次数不超过 $q = 2$ 的多项式精确时，才能保证通过二次检验单元测试。实现这一点的一个方便的对称法则是重心坐标为 $\\left( \\tfrac{2}{3}, \\tfrac{1}{6}, \\tfrac{1}{6} \\right)$ 及其排列的三点法则，其权重均为 $\\tfrac{1}{3}$。\n\n因此，所需的最小多项式精确度为 $q = 2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "虽然通过分片检验是收敛的必要条件，但它并不能保证单元的整体稳健性。一些单元公式即使通过了检验，仍可能存在被称为伪零能模式的不稳定性。本练习  通过分析广泛使用的减缩积分双线性四边形单元，探讨了这一微妙之处。您将证明，虽然该单元通过了常应变分片检验，但这种欠积分方案引入了非物理的“沙漏”模式，从而强调了分片检验主要验证的是一致性，而非稳定性。",
            "id": "3456382",
            "problem": "考虑一个二维小应变、线性弹性边界值问题，该问题由无体力作用下物体的平衡所支配。本构关系是线性和各向同性的，在采用工程剪应变的 Voigt 记法中，应力-应变关系写作 $\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}$，其中 $\\boldsymbol{\\varepsilon} = \\begin{pmatrix} \\varepsilon_{xx}  \\varepsilon_{yy}  \\gamma_{xy} \\end{pmatrix}^{\\mathsf{T}}$ 且 $\\mathbf{D}$ 是正定的。离散化采用等参四节点双线性四边形 ($Q_1$) 有限元。设母单元的坐标为 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$，并通过非奇异雅可比矩阵的仿射映射到物理坐标：$x = \\alpha_0 + \\alpha_1\\,\\xi + \\alpha_2\\,\\eta$ 和 $y = \\beta_0 + \\beta_1\\,\\xi + \\beta_2\\,\\eta$。\n\n母单元上的四个双线性形函数为\n$$\nN_1(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1-\\eta),\\\\\nN_3(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1+\\eta).\n$$\n设节点位移自由度为 $\\{u_i,v_i\\}_{i=1}^{4}$，因此插值位移场为 $u(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,u_i$ 和 $v(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,v_i$。应变-位移矩阵 $\\mathbf{B}(\\xi,\\eta)$ 的定义使得 $\\boldsymbol{\\varepsilon}(\\xi,\\eta) = \\mathbf{B}(\\xi,\\eta)\\,\\mathbf{d}$，其中节点向量为 $\\mathbf{d} = \\begin{pmatrix} u_1  v_1  u_2  v_2  u_3  v_3  u_4  v_4 \\end{pmatrix}^{\\mathsf{T}}$。单点减缩积分在母单元中心 $(\\xi,\\eta)=(0,0)$ 处使用单个高斯点，得到单元刚度 $\\mathbf{K}_e = w\\,\\det(\\mathbf{J})\\,\\mathbf{B}(0,0)^{\\mathsf{T}}\\mathbf{D}\\,\\mathbf{B}(0,0)$，其中 $w$ 是高斯权重，$\\mathbf{J}$ 是映射的雅可比矩阵。\n\n从这些定义和最小势能原理出发，完成以下任务：\n1. 显式地推导应变-位移矩阵 $\\mathbf{B}(0,0)$，用形函数的导数和中心点的逆雅可比矩阵表示，并论证其在非奇异仿射映射下的秩。\n2. 利用物理坐标中的仿射位移场 $u(x,y) = c_0 + c_1\\,x + c_2\\,y$ 和 $v(x,y) = d_0 + d_1\\,x + d_2\\,y$ 会产生常应变这一事实，证明 $Q_1$ 单元的单点减缩积分在 $(\\xi,\\eta)=(0,0)$ 处精确地再现了常应变，从而通过了常应变片检验 (patch test)。\n3. 确定对于单个 $Q_1$ 单元，单点减缩积分引入的独立的非刚体零能模式（沙漏模式）的数量。将最终答案表示为单个整数。不需要单位。",
            "solution": "题目要求分析单点高斯求积下的四节点双线性四边形 ($Q_1$) 单元，特别关注应变-位移矩阵、片检验以及由此产生的零能模式。分析按要求分三部分进行。\n\n应变 $\\boldsymbol{\\varepsilon}$ 和节点位移 $\\mathbf{d}$ 之间的基本关系由 $\\boldsymbol{\\varepsilon} = \\mathbf{B}\\,\\mathbf{d}$ 给出，其中 $\\mathbf{B}$ 是应变-位移矩阵。Voigt 记法中的小应变为 $\\boldsymbol{\\varepsilon} = \\begin{pmatrix} \\varepsilon_{xx}  \\varepsilon_{yy}  \\gamma_{xy} \\end{pmatrix}^{\\mathsf{T}}$，其中 $\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x}$，$\\varepsilon_{yy} = \\frac{\\partial v}{\\partial y}$，工程剪应变为 $\\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}$。位移场 $(u, v)$ 是使用形函数 $N_i(\\xi, \\eta)$ 从节点值 $\\{u_i, v_i\\}_{i=1}^4$ 插值得到的。\n\n插值位移关于物理坐标 $(x,y)$ 的导数通过链式法则与关于母单元坐标 $(\\xi,\\eta)$ 的导数相关联：\n$$\n\\begin{pmatrix} \\frac{\\partial f}{\\partial x} \\\\ \\frac{\\partial f}{\\partial y} \\end{pmatrix} = \\mathbf{J}^{-1} \\begin{pmatrix} \\frac{\\partial f}{\\partial \\xi} \\\\ \\frac{\\partial f}{\\partial \\eta} \\end{pmatrix}\n$$\n其中 $\\mathbf{J}$ 是坐标映射的雅可比矩阵：\n$$\n\\mathbf{J} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}\n$$\n题目说明映射是仿射的：$x = \\alpha_0 + \\alpha_1\\,\\xi + \\alpha_2\\,\\eta$ 和 $y = \\beta_0 + \\beta_1\\,\\xi + \\beta_2\\,\\eta$。对于此映射，雅可比矩阵是常数：\n$$\n\\mathbf{J} = \\begin{pmatrix} \\alpha_1  \\alpha_2 \\\\ \\beta_1  \\beta_2 \\end{pmatrix}\n$$\n题目指定了非奇异的雅可比矩阵，因此 $\\det(\\mathbf{J}) \\neq 0$，$\\mathbf{J}^{-1}$ 存在且也是常数。\n\n应变-位移矩阵 $\\mathbf{B}$ 是一个 $3 \\times 8$ 的矩阵，由每个节点 $i=1, ..., 4$ 的子矩阵 $\\mathbf{B}_i$ 构成：\n$$\n\\mathbf{B} = \\begin{pmatrix} \\mathbf{B}_1  \\mathbf{B}_2  \\mathbf{B}_3  \\mathbf{B}_4 \\end{pmatrix}, \\quad \\text{其中} \\quad \\mathbf{B}_i = \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x}  0 \\\\ 0  \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y}  \\frac{\\partial N_i}{\\partial x} \\end{pmatrix}\n$$\n形函数在物理空间中的导数计算如下：\n$$\n\\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\mathbf{J}^{-1} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{pmatrix}\n$$\n\n**1. $\\mathbf{B}(0,0)$ 的推导及其秩**\n\n我们在母单元的中心 $(\\xi,\\eta)=(0,0)$ 处计算应变-位移矩阵。这需要形函数在该点的导数。\n$N_1 = \\tfrac{1}{4}(1-\\xi)(1-\\eta) \\implies \\frac{\\partial N_1}{\\partial \\xi}|_{(0,0)}=-\\tfrac{1}{4}, \\frac{\\partial N_1}{\\partial \\eta}|_{(0,0)}=-\\tfrac{1}{4}$\n$N_2 = \\tfrac{1}{4}(1+\\xi)(1-\\eta) \\implies \\frac{\\partial N_2}{\\partial \\xi}|_{(0,0)}=\\tfrac{1}{4}, \\frac{\\partial N_2}{\\partial \\eta}|_{(0,0)}=-\\tfrac{1}{4}$\n$N_3 = \\tfrac{1}{4}(1+\\xi)(1+\\eta) \\implies \\frac{\\partial N_3}{\\partial \\xi}|_{(0,0)}=\\tfrac{1}{4}, \\frac{\\partial N_3}{\\partial \\eta}|_{(0,0)}=\\tfrac{1}{4}$\n$N_4 = \\tfrac{1}{4}(1-\\xi)(1+\\eta) \\implies \\frac{\\partial N_4}{\\partial \\xi}|_{(0,0)}=-\\tfrac{1}{4}, \\frac{\\partial N_4}{\\partial \\eta}|_{(0,0)}=\\tfrac{1}{4}$\n\n设 $\\mathbf{J}^{-1} = \\begin{pmatrix} J^{-1}_{11}  J^{-1}_{12} \\\\ J^{-1}_{21}  J^{-1}_{22} \\end{pmatrix}$。$N_i$ 关于 $x, y$ 在 $(0,0)$ 处的导数，以节点1为例：\n$\\frac{\\partial N_1}{\\partial x}|_{(0,0)} = J^{-1}_{11}(-\\tfrac{1}{4}) + J^{-1}_{12}(-\\tfrac{1}{4}) = -\\tfrac{1}{4}(J^{-1}_{11} + J^{-1}_{12})$\n$\\frac{\\partial N_1}{\\partial y}|_{(0,0)} = J^{-1}_{21}(-\\tfrac{1}{4}) + J^{-1}_{22}(-\\tfrac{1}{4}) = -\\tfrac{1}{4}(J^{-1}_{21} + J^{-1}_{22})$\n然后通过组合 $i=1, \\dots, 4$ 的 $\\mathbf{B}_i(0,0)$ 块来构建完整的矩阵 $\\mathbf{B}(0,0)$。对于 $\\mathbf{B}_1(0,0)$：\n$$\n\\mathbf{B}_1(0,0) = -\\frac{1}{4}\\begin{pmatrix} J^{-1}_{11} + J^{-1}_{12}  0 \\\\ 0  J^{-1}_{21} + J^{-1}_{22} \\\\ J^{-1}_{21} + J^{-1}_{22}  J^{-1}_{11} + J^{-1}_{12} \\end{pmatrix}\n$$\n其他的 $\\mathbf{B}_i$ 块使用它们各自的梯度以类似的方式构成。\n\n为了确定 $3 \\times 8$ 矩阵 $\\mathbf{B}(0,0)$ 的秩，我们评估其将节点位移向量 $\\mathbf{d} \\in \\mathbb{R}^8$ 映射到应变向量 $\\boldsymbol{\\varepsilon} \\in \\mathbb{R}^3$ 的能力。秩是这个线性映射的像的维数。一个仿射位移场 $u(x,y) = c_0 + c_1 x + c_2 y$ 和 $v(x,y) = d_0 + d_1 x + d_2 y$ 对应于一个常应变状态：$\\varepsilon_{xx} = c_1$, $\\varepsilon_{yy} = d_2$, $\\gamma_{xy} = c_2 + d_1$。由于 $Q_1$ 单元可以精确地再现任何仿射场（如第2部分将要展示的），因此可以选择与任意常应变状态相对应的节点位移 $\\mathbf{d}$。在 $(0,0)$ 处进行单点积分的公式将精确计算出这个应变状态。这意味着对于任何目标应变向量 $\\boldsymbol{\\varepsilon}^* \\in \\mathbb{R}^3$，都存在一个节点位移向量 $\\mathbf{d}$，使得 $\\mathbf{B}(0,0)\\mathbf{d} = \\boldsymbol{\\varepsilon}^*$。该映射是满射的，因此像的维数是 $3$。$\\mathbf{B}(0,0)$ 的秩是 $3$。\n\n**2. 常应变片检验**\n\n片检验 (patch test) 验证了单元公式能否精确地再现常应变状态。为此，我们考虑一个任意的仿射位移场，它会产生常应变：\n$u(x,y) = c_0 + c_1 x + c_2 y$\n$v(x,y) = d_0 + d_1 x + d_2 y$\n相应的应变为 $\\varepsilon_{xx} = c_1$, $\\varepsilon_{yy} = d_2$, 以及 $\\gamma_{xy} = c_2 + d_1$。\n\n单元的节点位移被设置为该场在节点处的值：$u_i = u(x_i,y_i)$ 和 $v_i = v(x_i,y_i)$。\n单元内的插值位移场为 $u_h(\\xi,\\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta) u_i$。\n关键的是，题目指出从母单元到物理空间存在一个仿射映射：$x(\\xi,\\eta) = \\alpha_0 + \\alpha_1\\xi + \\alpha_2\\eta$ 和 $y(\\xi,\\eta) = \\beta_0 + \\beta_1\\xi + \\beta_2\\eta$。将其代入仿射位移场可得：\n$u(x(\\xi,\\eta), y(\\xi,\\eta)) = c_0 + c_1(\\alpha_0 + \\alpha_1\\xi + \\alpha_2\\eta) + c_2(\\beta_0 + \\beta_1\\xi + \\beta_2\\eta)$。\n这个表达式是关于 $\\xi$ 和 $\\eta$ 的线性多项式。由双线性形函数 $\\{N_i\\}_{i=1}^4$ 张成的函数空间是 $\\{1, \\xi, \\eta, \\xi\\eta\\}$，它包含了所有线性多项式。拉格朗日插值的一个基本性质是，如果被插值的函数位于基函数的生成空间内，那么插值是精确的。因此，插值位移场与精确位移场是相同的：\n$u_h(\\xi,\\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta) u_i = u(x(\\xi,\\eta), y(\\xi,\\eta))$。\n对于 $v_h(\\xi,\\eta) = v(x(\\xi,\\eta), y(\\xi,\\eta))$ 也是如此。\n\n应变由该插值场计算得出。由于 $u_h$ 和 $v_h$ 与原始仿射场相同，它们的导数必然也相同：\n$\\frac{\\partial u_h}{\\partial x} = \\frac{\\partial u}{\\partial x} = c_1$\n$\\frac{\\partial v_h}{\\partial y} = \\frac{\\partial v}{\\partial y} = d_2$\n$\\frac{\\partial u_h}{\\partial y} + \\frac{\\partial v_h}{\\partial x} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x} = c_2+d_1$\n计算出的应变场在整个单元内是恒定的，并且与精确的目标应变相同。单点积分方案在 $(\\xi,\\eta)=(0,0)$ 处计算应变。由于应变是恒定的，这个单点的值就是精确的、恒定的应变。因此，该单元公式通过了常应变片检验。\n\n**3. 沙漏模式的数量**\n\n零能模式是指导致应变能为零的非零节点位移向量 $\\mathbf{d}$。对于单个单元，应变能正比于 $\\mathbf{d}^{\\mathsf{T}}\\mathbf{K}_e\\mathbf{d}$。单元刚度矩阵由 $\\mathbf{K}_e = w\\,\\det(\\mathbf{J})\\,\\mathbf{B}(0,0)^{\\mathsf{T}}\\mathbf{D}\\,\\mathbf{B}(0,0)$ 给出。由于 $w>0$，$\\det(\\mathbf{J}) \\neq 0$，且材料矩阵 $\\mathbf{D}$ 是正定的，条件 $\\mathbf{d}^{\\mathsf{T}}\\mathbf{K}_e\\mathbf{d}=0$ 等价于 $\\mathbf{B}(0,0)\\mathbf{d} = \\mathbf{0}$。\n这意味着零能模式是矩阵 $\\mathbf{B}(0,0)$ 的零空间中的向量。\n\n秩-零度定理指出，对于由矩阵 $\\mathbf{A}: V \\to W$ 表示的线性映射，$\\text{dim}(\\text{ker}(\\mathbf{A})) + \\text{rank}(\\mathbf{A}) = \\text{dim}(V)$。\n在我们的情况下，矩阵是 $\\mathbf{B}(0,0)$，它将节点位移空间 $\\mathbb{R}^8$ 映射到应变空间 $\\mathbb{R}^3$。\n- 定义域（节点位移空间）的维数是 $8$（$4$ 个节点 $\\times$ $2$ 个自由度/节点）。\n- 根据第 1 部分，$\\mathbf{B}(0,0)$ 的秩是 $3$。\n\n应用该定理：\n$\\text{dim}(\\text{ker}(\\mathbf{B}(0,0))) + \\text{rank}(\\mathbf{B}(0,0)) = 8$\n$\\text{dim}(\\text{ker}(\\mathbf{B}(0,0))) + 3 = 8$\n$\\text{dim}(\\text{ker}(\\mathbf{B}(0,0))) = 5$\n\n存在 $5$ 个线性独立的零能模式。这些模式由刚体运动和称为沙漏模式的伪、非物理模式组成。\n- **刚体运动**：这些是物理上导致零应变的位移模式。对于一个二维物体，有 $3$ 种这样的模式：\n  1. $x$ 方向的平移。\n  2. $y$ 方向的平移。\n  3. $xy$ 平面内的无穷小转动。\n- **沙漏模式**：这些是除刚体运动之外的剩余零能模式。它们对应于这样的变形：由于数值积分方案的巧合，在(高斯点)处产生零应变，但在其他地方会产生非零应变。\n沙漏模式的数量是零能模式的总数减去刚体运动的数量。\n\n沙漏模式的数量 = $\\text{dim}(\\ker(\\mathbf{B}(0,0))) - (\\text{刚体运动的数量})$\n沙漏模式的数量 = $5 - 3 = 2$。\n\n这两种模式分别对应于单元在 $u$ 和 $v$ 方向上的“领结”形或“桶”形变形。例如，一个与 $\\{1, -1, 1, -1\\}$ 成比例的节点位移模式 $u_i$ 和 $v_i=0$ 会插值成一个场 $u(\\xi, \\eta) \\propto \\xi\\eta$，其梯度在 $(\\xi,\\eta)=(0,0)$ 处为零，因此在积分点产生零应变。",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "在开发任何可靠的有限元软件时，一个强大的验证与确认套件是必不可少的，而分片检验是此类套件的基石。这个总结性练习  将理论付诸实践，要求您设计并实现一个基于分片检验的自动化回归测试程序。您将构建一个工具，该工具能系统地验证单元在不同多项式阶次、网格扭曲和求积规则下的性能，从而将您的理论理解固化为一项实用的工程技能。",
            "id": "3456391",
            "problem": "设计并实现一个自动化回归测试程序，该程序基于多项式阶次递增的补丁测试，用于二维标量椭圆边值问题。其目的是检测有限元代码中单元格式或求积例程的意外更改。其基本框架必须是带有狄利克雷边界数据的标量泊松问题的标准弱形式、Galerkin 方法以及等参双线性四边形单元。该程序必须是自包含的，并为每个测试用例产生可量化的通过/失败结果。\n\n设模型问题为泊松方程\n$$\n- \\nabla \\cdot (k \\nabla u) = f \\quad \\text{in } \\Omega,\n$$\n附带狄利克雷边界条件\n$$\nu = g \\quad \\text{on } \\partial \\Omega,\n$$\n其中 $k$ 是一个常数标量传导率，取 $k=1$，$\\Omega$ 是单位正方形域 $[0,1] \\times [0,1]$。其弱形式为：求 $u \\in H^1(\\Omega)$ 且在 $\\partial \\Omega$ 上满足 $u=g$，使得对于所有 $v \\in H^1_0(\\Omega)$\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\Omega} f \\, v \\, d\\Omega \\quad \\text{成立}。\n$$\n一个 p 阶补丁测试要求在一致的载荷和边界数据下，能够精确再现（在数值容差范围内）一个总次数为 p 的多项式解。具体来说，使用次数为 $p=0,1,2$ 的构造精确解 $u_{\\text{ex}}(x,y)$，并设置 $f = -\\Delta u_{\\text{ex}}$ 和 $g = u_{\\text{ex}}|_{\\partial \\Omega}$。对于 $p=0$ 和 $p=1$，$f$ 等于 $0$；对于 $p=2$，$f$ 是一个非零常数，由二次多项式的拉普拉斯算子确定。回归测试应检查使用等参双线性四边形单元获得的离散解 $u_h$，在采用合适的求积方法时，能够通过 $p \\le 1$ 的补丁测试，而在 $p=2$ 时失败。此外，对于 $p=1$ 的测试，它们应能检测出在网格扭曲下对求积方法的敏感性。\n\n使用以下基本框架：\n\n- 每个单元四个节点的等参双线性四边形有限元。父域坐标 $(\\xi,\\eta) \\in [-1,1]^2$，形函数 $N_i(\\xi,\\eta)$（$i=1,\\dots,4$）是标准的双线性函数。通过 $x(\\xi,\\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta) x_i$ 和 $y(\\xi,\\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta) y_i$ 映射到物理单元，其中 $(x_i,y_i)$ 是角节点的坐标。\n- 通过数值求积计算的单元刚度矩阵项：\n$$\nK^e_{ij} = \\int_{\\Omega_e} \\nabla N_i \\cdot \\nabla N_j \\, d\\Omega = \\int_{-1}^1 \\int_{-1}^1 \\left( \\left[J(\\xi,\\eta)^{-T} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta}\\end{pmatrix}\\right] \\cdot \\left[J(\\xi,\\eta)^{-T} \\begin{pmatrix} \\frac{\\partial N_j}{\\partial \\xi} \\\\ \\frac{\\partial N_j}{\\partial \\eta}\\end{pmatrix}\\right] \\right) \\det J(\\xi,\\eta) \\, d\\xi \\, d\\eta,\n$$\n其中 $J(\\xi,\\eta)$ 是等参映射的雅可比矩阵。\n- 通过数值求积计算的单元载荷向量项：\n$$\nF^e_i = \\int_{\\Omega_e} N_i \\, f \\, d\\Omega = \\int_{-1}^1 \\int_{-1}^1 N_i(\\xi,\\eta) \\, f(x(\\xi,\\eta), y(\\xi,\\eta)) \\, \\det J(\\xi,\\eta) \\, d\\xi \\, d\\eta.\n$$\n- 在父正方形上使用 q 阶高斯-勒让德求积，求积点为 $(\\xi_k,\\eta_\\ell)$，权重为 $w_k w_\\ell$。使用 $q=1$（单点），求积点为 $(\\xi,\\eta)=(0,0)$，总权重为 $4$；以及 $q=2$（两点），求积点位于 $\\xi,\\eta=\\pm 1/\\sqrt{3}$，权重为单位权重。\n- 通过将边界节点值设置为 $g$ 并相应地修改全局系统来强施加狄利克雷边界条件。\n\n网格构建：\n\n- 在 $[0,1]\\times[0,1]$ 上使用具有 $n_x \\times n_y$ 个矩形单元的结构化网格。对于仿射单元，节点坐标为笛卡尔网格点 $(x_i,y_j)$，其中 $x_i = i/n_x$，$y_j = j/n_y$。为生成扭曲单元同时保持边界不变，使用光滑映射扭曲内部节点\n$$\nx' = x + \\alpha \\, x (1-x) \\sin(\\pi y), \\quad y' = y + \\alpha \\, y(1-y) \\sin(\\pi x),\n$$\n扭曲振幅 $\\alpha$ 满足 $0 \\le \\alpha \\le 1$，以便对于小到中等的 $\\alpha$ 值，雅可比行列式保持为正。\n\n构造的精确解：\n\n- $p=0$ 阶（常数）：$u_{\\text{ex}}(x,y) = a_0$，其中 $a_0$ 为选定的常数，且 $f(x,y) = 0$。\n- $p=1$ 阶（线性）：$u_{\\text{ex}}(x,y) = a_0 + a_1 x + a_2 y$，其中 $a_0$、$a_1$、$a_2$ 为选定的常数，且 $f(x,y) = 0$。\n- $p=2$ 阶（二次）：$u_{\\text{ex}}(x,y) = a_0 + a_1 x + a_2 y + a_3 x^2 + a_4 x y + a_5 y^2$，其中 $a_0,\\dots,a_5$ 为选定的常数，且\n$$\n\\Delta u_{\\text{ex}}(x,y) = 2 a_3 + 2 a_5 \\quad \\Rightarrow \\quad f(x,y) = - (2 a_3 + 2 a_5).\n$$\n\n误差测量：\n\n- $L^2$ 误差范数为\n$$\n\\| u_h - u_{\\text{ex}} \\|_{L^2(\\Omega)} = \\left( \\int_{\\Omega} (u_h - u_{\\text{ex}})^2 \\, d\\Omega \\right)^{1/2},\n$$\n通过逐单元的数值求积计算。\n- 误差的 $H^1$ 半范数为\n$$\n| u_h - u_{\\text{ex}} |_{H^1(\\Omega)} = \\left( \\int_{\\Omega} \\| \\nabla u_h - \\nabla u_{\\text{ex}} \\|^2 \\, d\\Omega \\right)^{1/2},\n$$\n也通过数值求积计算。\n\n通过/失败准则：\n\n- 如果 $L^2$ 误差和误差的 $H^1$ 半范数都严格小于容差 $\\varepsilon$（$\\varepsilon = 10^{-8}$），则认为测试通过。\n\n确保覆盖率的测试套件：\n\n- 案例 1：仿射网格，$n_x = 4$，$n_y = 4$，求积阶次 $q=2$，$p=1$ 阶线性精确解；预期通过。\n- 案例 2：扭曲网格，$n_x = 4$，$n_y = 4$，扭曲振幅 $\\alpha = 0.3$，求积阶次 $q=1$，$p=1$ 阶线性精确解；预期失败（检测扭曲下对求积的敏感性）。\n- 案例 3：扭曲网格，$n_x = 4$，$n_y = 4$，扭曲振幅 $\\alpha = 0.3$，求积阶次 $q=2$，$p=1$ 阶线性精确解；预期通过（当积分充分时，对扭曲具有鲁棒性）。\n- 案例 4：仿射网格，$n_x = 4$，$n_y = 4$，求积阶次 $q=2$，$p=0$ 阶常数精确解；预期通过。\n- 案例 5：仿射网格，$n_x = 4$，$n_y = 4$，求积阶次 $q=2$，$p=2$ 阶二次精确解；预期失败（双线性单元的再现阶次被超过）。\n\n要求的最终输出格式：\n\n- 您的程序应产生一行输出，其中包含这五个测试用例的结果，格式为方括号内以逗号分隔的列表，每个条目都是一个布尔值，表示通过或失败，例如，`[{\\tt True},{\\tt False},{\\tt True},{\\tt True},{\\tt False}]`。\n\n此问题不涉及物理单位。不出现角度。所有数值答案均为布尔值。",
            "solution": "该问题要求为有限元方法 (FEM) 代码设计并实现一个自动化回归测试程序。该程序基于一套旨在验证二维标量泊松问题的单元格式和数值求积正确性的补丁测试。\n\n### 1. 数学和数值基础\n\n模型问题是定义在域 $\\Omega$ 上的泊松方程，由下式给出：\n$$\n- \\nabla \\cdot (k \\nabla u) = f \\quad \\text{in } \\Omega\n$$\n其中传导率 $k=1$ 为常数，边界 $\\partial \\Omega$ 上施加狄利克雷边界条件 $u = g$。域 $\\Omega$ 被指定为单位正方形 $[0,1] \\times [0,1]$。\n\n有限元实现基于应用于方程弱形式的 Galerkin 方法。弱形式是通过将偏微分方程 (PDE) 乘以一个来自合适空间（$H^1_0(\\Omega)$，即在狄利克雷边界上值为 0 的函数空间）的测试函数 $v$，在域 $\\Omega$ 上积分，并应用分部积分（格林第一恒等式）推导出来的。这就得到了问题：求 $u$（满足狄利克雷条件），使得对于所有有效的测试函数 $v$：\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\Omega} f v \\, d\\Omega\n$$\n域 $\\Omega$ 被离散化为不重叠的四边形单元网格。在每个单元 $\\Omega_e$ 内，未知解 $u$ 由一个近似函数 $u_h$ 表示，该函数由称为形函数 $N_i$ 的基函数的线性组合构成：\n$$\nu_h(x,y) = \\sum_{i=1}^{4} u_i N_i(x,y)\n$$\n其中 $u_i$ 是单元四个节点上的未知解值。对于此问题，使用标准的等参双线性形函数。“等参”一词意味着用于插值求解场的形函数也同样用于将单元几何从标准父单元（$(\\xi, \\eta)$ 坐标系中的正方形 $[-1,1] \\times [-1,1]$）映射到 $(x,y)$ 坐标系中的物理单元。\n\n将近似解 $u_h$ 代入弱形式，并选择测试函数 $v$ 为形函数 $N_j$（Galerkin 方法），从而为每个单元导出一个线性代数方程组，即单元刚度矩阵 $K^e$ 和单元载荷向量 $F^e$：\n$$\nK^e_{ij} = \\int_{\\Omega_e} \\nabla N_i \\cdot \\nabla N_j \\, d\\Omega\n$$\n$$\nF^e_i = \\int_{\\Omega_e} f N_i \\, d\\Omega\n$$\n这些积分在物理单元域上进行计算。通过变换到父单元域，它们变得适合进行数值求积：\n$$\nK^e_{ij} = \\int_{-1}^1 \\int_{-1}^1 (\\nabla_x N_i \\cdot \\nabla_x N_j) \\det J(\\xi, \\eta) \\, d\\xi d\\eta\n$$\n$$\nF^e_i = \\int_{-1}^1 \\int_{-1}^1 f(x(\\xi,\\eta), y(\\xi,\\eta)) N_i(\\xi, \\eta) \\det J(\\xi, \\eta) \\, d\\xi d\\eta\n$$\n其中 $J(\\xi, \\eta)$ 是几何变换的雅可比矩阵，$\\nabla_x N_i$ 是形函数相对于物理坐标的梯度，通过链式法则和雅可比矩阵的逆矩阵计算得出。这些积分使用阶次为 $q=1$（单点）或 $q=2$（$2 \\times 2=4$ 点）的高斯-勒让德求积法则来近似计算。\n\n各个单元矩阵和向量被组装成一个全局系统 $K u_h = F$。通过修改该系统以在边界上强制施加已知的节点值来强施加狄利克雷边界条件。然后求解得到的线性系统，以获得未知节点值的向量 $u_h$。\n\n### 2. 补丁测试原理\n\n补丁测试是有限元方法中一个基本的验证工具。它测试有限元格式能否精确地（达到机器精度）再现一个简单的、已知的多项式解。如果一个单元格式通过了补丁测试，这是其收敛的必要条件。\n\n该测试使用构造解法来构建。选择一个次数为 $p$ 的精确多项式解 $u_{\\text{ex}}$。然后从 $u_{\\text{ex}}$ 推导出一致的源项 $f$ 和边界条件 $g$：$f = -\\Delta u_{\\text{ex}}$ 和 $g = u_{\\text{ex}}|_{\\partial \\Omega}$。在一个单元片上运行有限元代码，并将计算出的数值解 $u_h$ 与 $u_{\\text{ex}}$进行比较。\n\n- **对于 $p \\le 1$**：双线性单元可以精确表示任何线性多项式。因此，在仿射（平行四边形）单元的网格上，使用精确积分，有限元解应与精确解完全相同。对于扭曲单元，积分中的几何项不再是常数，因此需要充分的求积。一个 $2 \\times 2$ 的高斯法则 ($q=2$) 通常足以通过线性解的补丁测试，而单点法则 ($q=1$) 则不足够。\n- **对于 $p = 2$**：双线性单元不能精确表示一般的二次多项式。插值误差是固有的。因此，任何使用这些单元的有限元实现都预期会因 $p=2$ 的补丁测试而失败，因为 $u_h$ 无法匹配 $u_{\\text{ex}}$。\n\n### 3. 实现设计和测试套件\n\n程序被构造成系统地执行五个指定的测试用例。一个主函数协调这些测试，每个测试都由一个例程处理，该例程为给定的参数集执行完整的有限元分析。\n\n- **网格生成**：一个函数生成节点的结构化网格并定义单元连接性。它可以根据指定，通过对内部节点应用光滑扭曲函数来创建仿射（矩形）网格和扭曲网格。\n- **构造解**：为 $p=0, 1, 2$ 阶的精确解 $u_{\\text{ex}}$、它们的梯度 $\\nabla u_{\\text{ex}}$ 以及相应的源项 $f$ 定义了函数。选择非平凡的系数以确保测试具有一般性。\n- **有限元分析**：程序的核心部分通过遍历每个单元并执行数值求积来组装全局刚度矩阵和载荷向量。然后，它强施加狄利克雷边界条件，并使用 `numpy.linalg.solve` 求解最终的线性系统。\n- **误差计算**：$L^2$ 误差范数和 $H^1$ 误差半范数是通过在域上数值积分数值解与精确解（及其梯度）之间差的平方来计算的。用于组装的求积法则也同样用于误差计算。\n- **测试套件执行**：主 `solve` 例程遍历五个测试用例：\n    1.  **案例 1 ($p = 1$，仿射网格，$q=2$)**：预期通过。验证了公式对线性场的基本正确性。\n    2.  **案例 2 ($p = 1$，扭曲网格，$q=1$)**：预期失败。表明减缩积分 ($q=1$) 对扭曲单元来说是不充分的，这是对求积敏感性的一个关键回归测试。\n    3.  **案例 3 ($p = 1$，扭曲网格，$q=2$)**：预期通过。显示了在有足够积分 ($q=2$) 的情况下，该公式对线性场的网格扭曲具有鲁棒性。\n    4.  **案例 4 ($p = 0$，仿射网格，$q=2$)**：预期通过。案例 1 的一个更简单版本，验证常数场的再现能力。\n    5.  **案例 5 ($p = 2$，仿射网格，$q=2$)**：预期失败。证实了双线性单元无法再现二次场的已知理论局限性。\n\n每个案例的通过/失败结果是通过将计算出的两个误差范数与 $\\varepsilon = 10^{-8}$ 的严格容差进行比较来确定的。最终输出是表示此测试套件结果的布尔值列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_manufactured_solution(p_order, coeffs):\n    \"\"\"Returns functions for the manufactured solution, its gradient, and the source term.\"\"\"\n    a0, a1, a2, a3, a4, a5 = coeffs\n    if p_order == 0:\n        u_ex = lambda x, y: a0\n        grad_u_ex = lambda x, y: np.array([0.0, 0.0])\n        f = lambda x, y: 0.0\n    elif p_order == 1:\n        u_ex = lambda x, y: a0 + a1 * x + a2 * y\n        grad_u_ex = lambda x, y: np.array([a1, a2])\n        f = lambda x, y: 0.0\n    elif p_order == 2:\n        u_ex = lambda x, y: a0 + a1 * x + a2 * y + a3 * x**2 + a4 * x * y + a5 * y**2\n        grad_u_ex = lambda x, y: np.array([a1 + 2 * a3 * x + a4 * y, a2 + a4 * x + 2 * a5 * y])\n        f = lambda x, y: -(2 * a3 + 2 * a5)\n    else:\n        raise ValueError(\"Unsupported polynomial order.\")\n    return u_ex, grad_u_ex, f\n\ndef get_quadrature(q_order):\n    \"\"\"Returns Gauss-Legendre quadrature points and weights for the reference square.\"\"\"\n    if q_order == 1:\n        points = np.array([[0.0, 0.0]])\n        weights = np.array([4.0])\n    elif q_order == 2:\n        p = 1.0 / np.sqrt(3)\n        points = np.array([[-p, -p], [p, -p], [p, p], [-p, p]])\n        weights = np.array([1.0, 1.0, 1.0, 1.0])\n    else:\n        raise ValueError(\"Unsupported quadrature order.\")\n    return points, weights\n\ndef get_shape_functions():\n    \"\"\"Returns bilinear shape functions and their derivatives on the parent element.\"\"\"\n    N = [\n        lambda xi, eta: 0.25 * (1 - xi) * (1 - eta),\n        lambda xi, eta: 0.25 * (1 + xi) * (1 - eta),\n        lambda xi, eta: 0.25 * (1 + xi) * (1 + eta),\n        lambda xi, eta: 0.25 * (1 - xi) * (1 + eta),\n    ]\n    dN_dxi = [\n        lambda xi, eta: -0.25 * (1 - eta),\n        lambda xi, eta: 0.25 * (1 - eta),\n        lambda xi, eta: 0.25 * (1 + eta),\n        lambda xi, eta: -0.25 * (1 + eta),\n    ]\n    dN_deta = [\n        lambda xi, eta: -0.25 * (1 - xi),\n        lambda xi, eta: -0.25 * (1 + xi),\n        lambda xi, eta: 0.25 * (1 + xi),\n        lambda xi, eta: 0.25 * (1 - xi),\n    ]\n    return N, dN_dxi, dN_deta\n\ndef generate_mesh(nx, ny, alpha):\n    \"\"\"Generates a structured quadrilateral mesh, possibly distorted.\"\"\"\n    n_nodes_x, n_nodes_y = nx + 1, ny + 1\n    num_nodes = n_nodes_x * n_nodes_y\n    nodes = np.zeros((num_nodes, 2))\n    \n    x_coords = np.linspace(0, 1, n_nodes_x)\n    y_coords = np.linspace(0, 1, n_nodes_y)\n    \n    for j in range(n_nodes_y):\n        for i in range(n_nodes_x):\n            idx = j * n_nodes_x + i\n            x, y = x_coords[i], y_coords[j]\n            # Warp interior nodes only\n            if i > 0 and i  nx and j > 0 and j  ny:\n                xp = x + alpha * x * (1 - x) * np.sin(np.pi * y)\n                yp = y + alpha * y * (1 - y) * np.sin(np.pi * x)\n                nodes[idx] = [xp, yp]\n            else:\n                nodes[idx] = [x, y]\n\n    num_elements = nx * ny\n    elements = np.zeros((num_elements, 4), dtype=int)\n    for j in range(ny):\n        for i in range(nx):\n            e_idx = j * nx + i\n            n1 = j * n_nodes_x + i\n            n2 = j * n_nodes_x + (i + 1)\n            n3 = (j + 1) * n_nodes_x + (i + 1)\n            n4 = (j + 1) * n_nodes_x + i\n            elements[e_idx] = [n1, n2, n3, n4]\n\n    boundary_nodes = {j * n_nodes_x + i for j in range(n_nodes_y) for i in range(n_nodes_x) if i == 0 or i == nx or j == 0 or j == ny}\n    return {'nodes': nodes, 'elements': elements, 'boundary_nodes': boundary_nodes}\n\ndef run_test_case(nx, ny, alpha, q_order, p_order, coeffs, tolerance):\n    mesh = generate_mesh(nx, ny, alpha)\n    u_ex, grad_u_ex, f_func = get_manufactured_solution(p_order, coeffs)\n    quad_pts, quad_w = get_quadrature(q_order)\n    N_funcs, dN_dxi_funcs, dN_deta_funcs = get_shape_functions()\n\n    num_nodes = mesh['nodes'].shape[0]\n    K = np.zeros((num_nodes, num_nodes))\n    F = np.zeros(num_nodes)\n\n    for el_nodes_idx in mesh['elements']:\n        el_nodes_coords = mesh['nodes'][el_nodes_idx]\n        Ke = np.zeros((4, 4))\n        Fe = np.zeros(4)\n\n        for qp, qw in zip(quad_pts, quad_w):\n            xi, eta = qp\n            N_vals = np.array([N(xi, eta) for N in N_funcs])\n            dN_dxi_vals = np.array([dNdxi(xi, eta) for dNdxi in dN_dxi_funcs])\n            dN_deta_vals = np.array([dNdeta(xi, eta) for dNdeta in dN_deta_funcs])\n            \n            J = np.array([\n                [np.dot(dN_dxi_vals, el_nodes_coords[:, 0]), np.dot(dN_deta_vals, el_nodes_coords[:, 0])],\n                [np.dot(dN_dxi_vals, el_nodes_coords[:, 1]), np.dot(dN_deta_vals, el_nodes_coords[:, 1])]\n            ])\n\n            detJ = np.linalg.det(J)\n            if detJ = 0: raise ValueError(\"Non-positive Jacobian determinant.\")\n            invJ = np.linalg.inv(J)\n            grad_N_parent = np.vstack((dN_dxi_vals, dN_deta_vals))\n            grad_N_phys = invJ.T @ grad_N_parent\n\n            Ke += (grad_N_phys.T @ grad_N_phys) * detJ * qw\n            \n            x_q, y_q = N_vals @ el_nodes_coords\n            f_q = f_func(x_q, y_q)\n            Fe += N_vals * f_q * detJ * qw\n        \n        ix = np.ix_(el_nodes_idx, el_nodes_idx)\n        K[ix] += Ke\n        F[el_nodes_idx] += Fe\n\n    prescribed_dofs = {node_idx: u_ex(*mesh['nodes'][node_idx]) for node_idx in mesh['boundary_nodes']}\n    \n    F_bc = np.copy(F)\n    K_bc = np.copy(K)\n    \n    for dof, val in prescribed_dofs.items():\n        for i in range(num_nodes):\n            if i not in prescribed_dofs:\n                F_bc[i] -= K_bc[i, dof] * val\n    \n    for dof, val in prescribed_dofs.items():\n        K_bc[dof, :] = 0\n        K_bc[:, dof] = 0\n        K_bc[dof, dof] = 1.0\n        F_bc[dof] = val\n\n    u_h = np.linalg.solve(K_bc, F_bc)\n\n    l2_err_sq, h1_err_sq = 0.0, 0.0\n    for el_nodes_idx in mesh['elements']:\n        el_nodes_coords = mesh['nodes'][el_nodes_idx]\n        el_u_h = u_h[el_nodes_idx]\n\n        for qp, qw in zip(quad_pts, quad_w):\n            xi, eta = qp\n            N_vals = np.array([N(xi, eta) for N in N_funcs])\n            dN_dxi_vals = np.array([dNdxi(xi, eta) for dNdxi in dN_dxi_funcs])\n            dN_deta_vals = np.array([dNdeta(xi, eta) for dNdeta in dN_deta_funcs])\n            \n            J = np.array([\n                [np.dot(dN_dxi_vals, el_nodes_coords[:, 0]), np.dot(dN_deta_vals, el_nodes_coords[:, 0])],\n                [np.dot(dN_dxi_vals, el_nodes_coords[:, 1]), np.dot(dN_deta_vals, el_nodes_coords[:, 1])]\n            ])\n            detJ = np.linalg.det(J)\n            invJ = np.linalg.inv(J)\n            grad_N_parent = np.vstack((dN_dxi_vals, dN_deta_vals))\n            grad_N_phys = invJ.T @ grad_N_parent\n\n            x_q, y_q = N_vals @ el_nodes_coords\n            u_h_q = np.dot(N_vals, el_u_h)\n            grad_u_h_q = grad_N_phys @ el_u_h\n            \n            u_ex_q = u_ex(x_q, y_q)\n            grad_u_ex_q = grad_u_ex(x_q, y_q)\n\n            l2_err_sq += (u_h_q - u_ex_q)**2 * detJ * qw\n            h1_err_sq += np.sum((grad_u_h_q - grad_u_ex_q)**2) * detJ * qw\n\n    l2_err = np.sqrt(l2_err_sq)\n    h1_err = np.sqrt(h1_err_sq)\n    \n    return l2_err  tolerance and h1_err  tolerance\n\ndef solve():\n    test_cases = [\n        # Case 1: p=1, affine, q=2. Expected: Pass\n        {'nx': 4, 'ny': 4, 'alpha': 0.0, 'q_order': 2, 'p_order': 1},\n        # Case 2: p=1, distorted, q=1. Expected: Fail\n        {'nx': 4, 'ny': 4, 'alpha': 0.3, 'q_order': 1, 'p_order': 1},\n        # Case 3: p=1, distorted, q=2. Expected: Pass\n        {'nx': 4, 'ny': 4, 'alpha': 0.3, 'q_order': 2, 'p_order': 1},\n        # Case 4: p=0, affine, q=2. Expected: Pass\n        {'nx': 4, 'ny': 4, 'alpha': 0.0, 'q_order': 2, 'p_order': 0},\n        # Case 5: p=2, affine, q=2. Expected: Fail\n        {'nx': 4, 'ny': 4, 'alpha': 0.0, 'q_order': 2, 'p_order': 2},\n    ]\n\n    coeffs = (0.5, 1.2, 0.8, 0.3, 0.4, 0.5) \n    tolerance = 1e-8\n\n    results = []\n    for case in test_cases:\n        is_pass = run_test_case(**case, coeffs=coeffs, tolerance=tolerance)\n        results.append(is_pass)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}