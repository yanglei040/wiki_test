{
    "hands_on_practices": [
        {
            "introduction": "A critical aspect of any numerical scheme is its ability to dissipate non-physical, high-frequency oscillations. This practice provides a direct, analytical comparison of the dissipative properties of the Bassi-Rebay 2 (BR2) and Local Discontinuous Galerkin (LDG) formulations . By performing an eigen-decomposition on a simplified 1D heat equation problem, you will quantify the difference in high-frequency damping and gain fundamental insight into the inherent numerical character of these two popular methods.",
            "id": "3417382",
            "problem": "Consider the one-dimensional heat equation $u_{t} = \\nu u_{xx}$ on the periodic domain $x \\in [0,2]$ with constant diffusivity $\\nu = 1$. Discretize the domain with a uniform mesh of two elements of size $h=1$, and use a polynomial degree $p=2$ Gauss–Lobatto–Legendre basis $\\{\\phi_{0},\\phi_{1},\\phi_{2}\\}$ on each element with nodal points at $\\xi=-1,0,1$ (mapped to the physical element) and standard $3$-point Gauss–Lobatto weights $\\{w_{1},w_{2},w_{3}\\}=\\{\\tfrac{1}{3},\\tfrac{4}{3},\\tfrac{1}{3}\\}$. With diagonal mass-lumping, the per-element mass matrix is $M_{e}=\\tfrac{h}{2}\\operatorname{diag}(w_{1},w_{2},w_{3})$, and the global mass is block-diagonal.\n\nStart from the weak form and the definitions of the Local Discontinuous Galerkin (LDG) and Bassi–Rebay 2 (BR2) formulations for diffusion. For BR2, adopt the symmetric interior penalty representation with stabilization parameter $\\sigma_{\\mathrm{BR2}}$ and interface bilinear form\n$$\na_{e}(u,v) \\;=\\; - \\nu \\left\\{ \\partial_{n} u \\right\\} [v] \\;-\\; \\nu \\left\\{ \\partial_{n} v \\right\\} [u] \\;+\\; \\nu \\,\\frac{\\sigma_{\\mathrm{BR2}}}{h}\\,[u]\\,[v],\n$$\nwhere $[u]=u^{-}-u^{+}$ denotes the jump at the interface and $\\{\\partial_{n} u\\}=\\tfrac{1}{2}(\\partial_{n}u^{-}+\\partial_{n}u^{+})$ is the average normal derivative. For LDG, use the alternating-flux LDG scheme and statically condense the auxiliary gradient variable to obtain a condensed bilinear form of the same structural type with a stabilization parameter $\\sigma_{\\mathrm{LDG}}$.\n\nOn the given mesh and basis, explicitly write the BR2 global stiffness contribution restricted to the high-frequency interface subspace in which only the endpoint degrees of freedom at the element boundaries are active (that is, nodal values at $\\xi= \\pm 1$ are possibly nonzero while interior nodal values at $\\xi=0$ are zero). In this subspace, the BR2 stiffness reduces to the sum of two $2\\times 2$ interface blocks of the form\n$$\nK^{(\\mathrm{int})}_{\\mathrm{BR2}} \\;=\\; \\nu \\,\\frac{\\sigma_{\\mathrm{BR2}}}{h}\n\\begin{pmatrix}\n1 & -1\\\\\n-1 & 1\n\\end{pmatrix}\n$$\nat each of the two interfaces, assembled into the appropriate $6\\times 6$ global layout corresponding to the ordering of degrees of freedom $(u_{0,1},u_{0,2},u_{0,3},u_{1,1},u_{1,2},u_{1,3})$ where $u_{e,i}$ denotes the $i$-th nodal value on element $e$. Using the diagonal global mass matrix with entries $\\tfrac{h}{2} w_{i}$ per node, perform the eigen-decomposition of the semi-discrete operator $A_{\\mathrm{BR2}} = M^{-1} K_{\\mathrm{BR2}}$ restricted to the interface subspace and identify the largest damping rate (largest eigenvalue of $A_{\\mathrm{BR2}}$), which characterizes the high-frequency dissipation.\n\nSimilarly, form the LDG condensed interface stiffness $K^{(\\mathrm{int})}_{\\mathrm{LDG}}$ with stabilization parameter $\\sigma_{\\mathrm{LDG}}$ and compute the corresponding largest eigenvalue of $A_{\\mathrm{LDG}}=M^{-1}K_{\\mathrm{LDG}}$ on the same interface subspace. Take $\\sigma_{\\mathrm{BR2}}=6$ for the Bassi–Rebay 2 scheme and $\\sigma_{\\mathrm{LDG}}=2$ for the Local Discontinuous Galerkin scheme with alternating flux and standard choices leading to the condensed operator.\n\nFinally, quantify the difference in high-frequency damping by computing the ratio of the largest eigenvalues,\n$$\n\\mathcal{R} \\;=\\; \\frac{\\lambda_{\\max}(A_{\\mathrm{BR2}})}{\\lambda_{\\max}(A_{\\mathrm{LDG}})}.\n$$\nExpress your final answer as a single real number. No units are required, and no rounding is necessary.",
            "solution": "The problem requires analyzing the semi-discrete operator $A = M^{-1}K$ restricted to a specific subspace. Let us first define this subspace and the corresponding matrices.\n\nThe mesh consists of two elements, $E_0 = [0,1]$ and $E_1 = [1,2]$. For each element, we use $p=2$ basis functions with nodes at $\\xi=-1,0,1$.\n- For element $E_0$: the nodes correspond to physical coordinates $x=0, 0.5, 1$. The DoFs are $u_{0,1}, u_{0,2}, u_{0,3}$.\n- For element $E_1$: the nodes correspond to physical coordinates $x=1, 1.5, 2$. The DoFs are $u_{1,1}, u_{1,2}, u_{1,3}$.\n\nThe analysis is restricted to the \"high-frequency interface subspace,\" where interior nodal values are zero. This implies only degrees of freedom at the element boundaries ($\\xi = \\pm 1$) are non-zero.\nThe active degrees of freedom are the nodal values at the element boundaries:\n- $u_{0,1}$ at $x=0$\n- $u_{0,3}$ at $x=1$\n- $u_{1,1}$ at $x=1$\n- $u_{1,3}$ at $x=2$\n\nThe domain is periodic, so the interface at $x=2$ connects to $x=0$. We have two interfaces: one at $x=1$ and one at $x=0 \\equiv 2$.\nThe vector of unknowns in our restricted $4$-dimensional subspace, ordered corresponding to the global indices, is $U_{sub} = (u_{0,1}, u_{0,3}, u_{1,1}, u_{1,3})^T$.\n\nFirst, we construct the mass matrix for this subspace, $M_{sub}$. The problem states a lumped mass matrix is used, with $M_e = \\frac{h}{2}\\operatorname{diag}(w_{1},w_{2},w_{3})$. With $h=1$ and weights $\\{w_1, w_2, w_3\\} = \\{\\frac{1}{3}, \\frac{4}{3}, \\frac{1}{3}\\}$, the element mass matrix is $M_e = \\frac{1}{2}\\operatorname{diag}(\\frac{1}{3}, \\frac{4}{3}, \\frac{1}{3}) = \\operatorname{diag}(\\frac{1}{6}, \\frac{2}{3}, \\frac{1}{6})$.\nThe active DoFs ($u_{0,1}, u_{0,3}, u_{1,1}, u_{1,3}$) correspond to the endpoints of the elements ($\\xi = \\pm 1$), which have the weight $w_1 = w_3 = \\frac{1}{3}$. The mass matrix entry for each of these DoFs is $\\frac{h}{2}w_1 = \\frac{1}{2} \\cdot \\frac{1}{3} = \\frac{1}{6}$.\nThe subspace mass matrix $M_{sub}$ is therefore a $4 \\times 4$ diagonal matrix:\n$$\nM_{sub} = \\frac{1}{6} \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix} = \\frac{1}{6} I_4\n$$\nIts inverse is $M_{sub}^{-1} = 6 I_4$.\n\nNext, we construct the stiffness matrix in the subspace, $K_{sub}$. The problem states this is formed by the sum of interface contributions. The contribution from a single interface is given by $K^{(\\mathrm{int})} = \\nu \\frac{\\sigma}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$.\n\nFor the Bassi-Rebay 2 (BR2) scheme, we have $\\nu=1$, $h=1$, and $\\sigma_{\\mathrm{BR2}}=6$.\n$$\nK^{(\\mathrm{int})}_{\\mathrm{BR2}} = 1 \\cdot \\frac{6}{1} \\begin{pmatrix} 1 & -1\\\\ -1 & 1 \\end{pmatrix} = 6 \\begin{pmatrix} 1 & -1\\\\ -1 & 1 \\end{pmatrix}\n$$\nWe assemble the global subspace stiffness matrix $K_{\\mathrm{BR2}, sub}$ from the two interfaces:\n1. Interface at $x=1$: This connects DoFs $u_{0,3}$ and $u_{1,1}$.\n2. Interface at $x=0 \\equiv 2$ (periodicity): This connects $u_{1,3}$ (at $x=2$) and $u_{0,1}$ (at $x=0$).\n\nAssembling these contributions into the $4 \\times 4$ matrix corresponding to $U_{sub} = (u_{0,1}, u_{0,3}, u_{1,1}, u_{1,3})^T$:\n$$\nK_{\\mathrm{BR2}, sub} = \\begin{pmatrix}\n6 & 0 & 0 & -6 \\\\\n0 & 6 & -6 & 0 \\\\\n0 & -6 & 6 & 0 \\\\\n-6 & 0 & 0 & 6\n\\end{pmatrix} = 6 \\begin{pmatrix}\n1 & 0 & 0 & -1 \\\\\n0 & 1 & -1 & 0 \\\\\n0 & -1 & 1 & 0 \\\\\n-1 & 0 & 0 & 1\n\\end{pmatrix}\n$$\nThe operator for the BR2 scheme is $A_{\\mathrm{BR2}} = M_{sub}^{-1} K_{\\mathrm{BR2}, sub}$:\n$$\nA_{\\mathrm{BR2}} = (6 I_4) \\left( 6 \\begin{pmatrix}\n1 & 0 & 0 & -1 \\\\\n0 & 1 & -1 & 0 \\\\\n0 & -1 & 1 & 0 \\\\\n-1 & 0 & 0 & 1\n\\end{pmatrix} \\right) = 36 \\begin{pmatrix}\n1 & 0 & 0 & -1 \\\\\n0 & 1 & -1 & 0 \\\\\n0 & -1 & 1 & 0 \\\\\n-1 & 0 & 0 & 1\n\\end{pmatrix}\n$$\nTo find the eigenvalues of $A_{\\mathrm{BR2}}$, we find the eigenvalues of the matrix part. By permuting rows and columns, this matrix is similar to a block-diagonal matrix:\n$$\n\\begin{pmatrix}\n1 & -1 & 0 & 0 \\\\\n-1 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & -1 \\\\\n0 & 0 & -1 & 1\n\\end{pmatrix}\n$$\nEach block is $J = \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$. The eigenvalues of $J$ are given by $\\det(J - \\lambda I) = (1-\\lambda)^2 - 1 = \\lambda^2 - 2\\lambda = \\lambda(\\lambda-2) = 0$. The eigenvalues of $J$ are $0$ and $2$.\nTherefore, the eigenvalues of the matrix part of $A_{\\mathrm{BR2}}$ are $\\{0, 2, 0, 2\\}$.\nThe eigenvalues of $A_{\\mathrm{BR2}}$ are $36 \\times \\{0, 2, 0, 2\\} = \\{0, 72, 0, 72\\}$.\nThe largest eigenvalue is $\\lambda_{\\max}(A_{\\mathrm{BR2}}) = 72$.\n\nWe repeat the process for the Local Discontinuous Galerkin (LDG) scheme. The problem states it has the same structural form, but with $\\sigma_{\\mathrm{LDG}} = 2$.\nThe interface stiffness block for LDG is:\n$$\nK^{(\\mathrm{int})}_{\\mathrm{LDG}} = \\nu \\frac{\\sigma_{\\mathrm{LDG}}}{h} \\begin{pmatrix} 1 & -1\\\\ -1 & 1 \\end{pmatrix} = 1 \\cdot \\frac{2}{1} \\begin{pmatrix} 1 & -1\\\\ -1 & 1 \\end{pmatrix} = 2 \\begin{pmatrix} 1 & -1\\\\ -1 & 1 \\end{pmatrix}\n$$\nThe subspace stiffness matrix $K_{\\mathrm{LDG}, sub}$ is:\n$$\nK_{\\mathrm{LDG}, sub} = 2 \\begin{pmatrix}\n1 & 0 & 0 & -1 \\\\\n0 & 1 & -1 & 0 \\\\\n0 & -1 & 1 & 0 \\\\\n-1 & 0 & 0 & 1\n\\end{pmatrix}\n$$\nThe operator for the LDG scheme is $A_{\\mathrm{LDG}} = M_{sub}^{-1} K_{\\mathrm{LDG}, sub}$:\n$$\nA_{\\mathrm{LDG}} = (6 I_4) \\left( 2 \\begin{pmatrix}\n1 & 0 & 0 & -1 \\\\\n0 & 1 & -1 & 0 \\\\\n0 & -1 & 1 & 0 \\\\\n-1 & 0 & 0 & 1\n\\end{pmatrix} \\right) = 12 \\begin{pmatrix}\n1 & 0 & 0 & -1 \\\\\n0 & 1 & -1 & 0 \\\\\n0 & -1 & 1 & 0 \\\\\n-1 & 0 & 0 & 1\n\\end{pmatrix}\n$$\nThe eigenvalues of $A_{\\mathrm{LDG}}$ are $12 \\times \\{0, 2, 0, 2\\} = \\{0, 24, 0, 24\\}$.\nThe largest eigenvalue is $\\lambda_{\\max}(A_{\\mathrm{LDG}}) = 24$.\n\nFinally, we compute the ratio $\\mathcal{R}$:\n$$\n\\mathcal{R} = \\frac{\\lambda_{\\max}(A_{\\mathrm{BR2}})}{\\lambda_{\\max}(A_{\\mathrm{LDG}})} = \\frac{72}{24} = 3\n$$\nThis ratio quantifies the difference in high-frequency damping between the two schemes for the given parameters, with BR2 providing three times the damping of LDG for the highest-frequency mode on this grid.",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "Building on the theme of numerical dissipation, this hands-on coding exercise explores the flexibility of the LDG formulation for the more challenging convection-diffusion equation . You will investigate how tuning the numerical flux with an upwind bias—a common technique for enhancing stability—affects both the stability margin and the accuracy of the scheme. By implementing the semi-discrete operator and analyzing its properties, you will directly observe the critical trade-off between stabilizing the method and avoiding excessive damping of physically relevant, smooth solution modes.",
            "id": "3417437",
            "problem": "Consider the one-dimensional linear convection–diffusion equation on a periodic domain, written in first-order form by introducing an auxiliary gradient variable: find a scalar field $u(x,t)$ and an auxiliary field $q(x,t)$ such that\n$$\nu_t + b\\,u_x = \\nu\\,u_{xx}, \\quad x \\in [0,L], \\ t \\ge 0,\n$$\nequivalently,\n$$\nu_t + b\\,u_x = \\nu\\,q_x, \\qquad q - u_x = 0,\n$$\nwith periodic boundary conditions $u(0,t) = u(L,t)$ and $q(0,t) = q(L,t)$. Here $b$ is a constant convection speed and $\\nu$ is a constant diffusivity. The goal is to investigate, within a Local Discontinuous Galerkin (LDG) family of fluxes, whether introducing a mild upwind bias in the numerical flux used to define the auxiliary gradient variable can improve stability in the diffusion–dominated regime without overdamping smooth modes. For context, the Bassi–Rebay (BR) class of formulations, such as Bassi–Rebay 2 (BR2), are widely used alternatives to LDG for diffusive terms; we will include a simple interior-penalty-like baseline reflective of this class for comparison.\n\nYou will work with a piecewise-constant approximation (polynomial degree zero) on a uniform mesh of $N$ cells of equal length $h = L/N$, with cell centers $x_i = (i+\\tfrac{1}{2})h$ for $i=0,\\dots,N-1$. Denote by $u_i(t)$ the approximation of $u$ on cell $i$, and by $q_i(t)$ the approximation of $q$ on cell $i$, both taken as constants on each cell. Let the interface between cell $i$ and cell $i+1$ be indexed by $i+\\tfrac{1}{2}$, with periodic wrap-around.\n\nThe semi-discrete LDG scheme for the above system in conservative form, specialized to piecewise constants, reads:\n- For the auxiliary equation, for each cell $i$:\n$$\nh\\, q_i - \\big(\\widehat{u}^{\\text{diff}}_{i+\\frac{1}{2}} - \\widehat{u}^{\\text{diff}}_{i-\\frac{1}{2}}\\big) = 0,\n$$\nwhere $\\widehat{u}^{\\text{diff}}_{i+\\frac{1}{2}}$ is a single-valued numerical flux for $u$ at the interface that is used only in the $q$-equation.\n- For the primary equation, for each cell $i$:\n$$\nh\\, \\frac{d u_i}{d t} + \\Big( b\\,\\widehat{u}^{\\text{conv}}_{i+\\frac{1}{2}} - \\nu\\,\\widehat{q}_{i+\\frac{1}{2}} \\Big) - \\Big( b\\,\\widehat{u}^{\\text{conv}}_{i-\\frac{1}{2}} - \\nu\\,\\widehat{q}_{i-\\frac{1}{2}} \\Big) = 0,\n$$\nwhere $\\widehat{u}^{\\text{conv}}_{i+\\frac{1}{2}}$ is the standard upwind numerical flux for convection and $\\widehat{q}_{i+\\frac{1}{2}}$ is the single-valued numerical flux for $q$ used in the $u$-equation.\n\nDefine the convective numerical flux by the upwind rule\n$$\n\\widehat{u}^{\\text{conv}}_{i+\\frac{1}{2}} =\n\\begin{cases}\nu_i, & b \\ge 0,\\\\\nu_{i+1}, & b < 0,\n\\end{cases}\n$$\nand define the diffusive $q$-flux as the central average\n$$\n\\widehat{q}_{i+\\frac{1}{2}} = \\tfrac{1}{2}(q_i + q_{i+1}).\n$$\nIntroduce an upwind-bias parameter $\\theta \\in [0,1]$ in the $u$-flux used in the $q$-equation by setting\n$$\n\\widehat{u}^{\\text{diff}}_{i+\\frac{1}{2}} = (1-\\theta)\\,\\tfrac{1}{2}\\,(u_i + u_{i+1}) + \\theta\\,u_i,\n$$\nwhich corresponds to a convex combination of the central average and the left trace (a fixed orientation), thereby biasing the discrete gradient in a mild upwind sense when $\\theta$ is small and positive. Eliminating $q_i$ from the semi-discrete system yields a closed linear system of ordinary differential equations of the form\n$$\n\\frac{d\\mathbf{u}}{dt} = A\\,\\mathbf{u},\n$$\nwith $\\mathbf{u} \\in \\mathbb{R}^{N}$ the vector of cell averages and $A \\in \\mathbb{R}^{N \\times N}$ the semi-discrete operator that depends on $b$, $\\nu$, $L$, $N$, and $\\theta$.\n\nFor comparison to a Bassi–Rebay-like baseline, consider an interior-penalty-like scheme (reflective of the Bassi–Rebay class in one spatial dimension with piecewise constants) defined directly on the $u$-unknown by\n$$\n\\frac{d u_i}{dt} = -\\frac{b}{h}\\,\\Big(\\widehat{u}^{\\text{conv}}_{i+\\frac{1}{2}} - \\widehat{u}^{\\text{conv}}_{i-\\frac{1}{2}}\\Big) + \\nu\\,\\frac{u_{i+1} - 2 u_i + u_{i-1}}{h^2},\n$$\nagain with periodic wrap-around and with the same upwind convective flux $\\widehat{u}^{\\text{conv}}_{i+\\frac{1}{2}}$ as above. This yields another linear system of the form\n$$\n\\frac{d\\mathbf{u}}{dt} = A\\,\\mathbf{u},\n$$\nwith a different matrix $A$.\n\nYour tasks:\n1. From the above integral forms, derive and implement a function that assembles the matrix $A$ for the LDG scheme as a function of the parameters $N$, $L$, $b$, $\\nu$, and $\\theta$, by eliminating the auxiliary variable $q$ at the semi-discrete level. Use periodic boundary conditions.\n2. Implement the interior-penalty-like baseline operator $A$ corresponding to the Bassi–Rebay class as specified above.\n3. For any given operator $A$, define the following diagnostics:\n   - The spectral abscissa margin $m = -\\max\\{\\Re(\\lambda): \\lambda \\in \\sigma(A)\\}$, where $\\sigma(A)$ denotes the spectrum. Report the scheme as stable if and only if $\\max\\{\\Re(\\lambda)\\} \\le 10^{-10}$, and report $m$ as a nonnegative float.\n   - The smooth-mode damping ratio $r = \\frac{-\\Re(\\lambda_{\\text{eff}})}{\\nu\\,k^2}$, where $k=1$ is the fundamental wavenumber on the periodic interval of length $L = 2\\pi$, and $\\lambda_{\\text{eff}}$ is the Rayleigh quotient of $A$ with respect to the discrete sinusoidal mode $v_i = \\sin(k x_i)$ using the Euclidean inner product, i.e., $\\lambda_{\\text{eff}} = \\frac{v^\\top (A v)}{v^\\top v}$. This ratio quantifies overdamping of the smoothest nontrivial mode relative to the continuum rate $-\\nu k^2$.\n4. Your program must construct $A$, compute the eigenvalues, and return the boolean stability verdict, the margin $m$, and the ratio $r$ for each test case in the suite specified below.\n\nUse the following test suite (all parameters are dimensionless, with $L$ given in the same units as $x$ and $b$ in units of $x$ per unit time, $\\nu$ in units of $x^2$ per unit time):\n- Case $1$: LDG with $N=40$, $L=2\\pi$, $b=0.2$, $\\nu=1.0$, $\\theta=0.0$.\n- Case $2$: LDG with $N=40$, $L=2\\pi$, $b=0.2$, $\\nu=1.0$, $\\theta=0.1$.\n- Case $3$: LDG with $N=40$, $L=2\\pi$, $b=0.2$, $\\nu=1.0$, $\\theta=0.5$.\n- Case $4$: LDG with $N=40$, $L=2\\pi$, $b=0.2$, $\\nu=1.0$, $\\theta=1.0$.\n- Case $5$: LDG with $N=10$, $L=2\\pi$, $b=-0.2$, $\\nu=1.0$, $\\theta=0.1$.\n- Case $6$: BR-like baseline with $N=40$, $L=2\\pi$, $b=0.2$, $\\nu=1.0$ (ignore $\\theta$).\n- Case $7$: LDG with $N=4$, $L=2\\pi$, $b=0.2$, $\\nu=1.0$, $\\theta=0.1$.\n\nYour program should produce, in order for Cases $1$ through $7$, a single line of output containing a list of lists\n$$\n\\big[\\,[\\text{stable}_1, m_1, r_1], \\ [\\text{stable}_2, m_2, r_2], \\ \\dots, \\ [\\text{stable}_7, m_7, r_7]\\,\\big],\n$$\nwhere each $\\text{stable}_j$ is a boolean and each $m_j$ and $r_j$ are floating-point numbers. The entire list must be printed on one line, formatted as a comma-separated list enclosed in square brackets, with the inner lists each containing three entries in the order described.",
            "solution": "The core of this problem is to derive and implement the semi-discrete operators for the LDG and BR-like schemes, and then analyze their properties.\n\n**Operator Derivation**\n\nFor the LDG scheme, the auxiliary variable $q$ must first be eliminated. The auxiliary equation $h\\, q_i = \\widehat{u}^{\\text{diff}}_{i+\\frac{1}{2}} - \\widehat{u}^{\\text{diff}}_{i-\\frac{1}{2}}$ is used to express each cell-average $q_i$ as a linear combination of its neighboring $u$ values ($u_{i-1}, u_i, u_{i+1}$). This relationship is then substituted into the numerical flux for $q$, $\\widehat{q}_{i+\\frac{1}{2}} = \\frac{1}{2}(q_i + q_{i+1})$, which appears in the primary equation for $u_i$. Combining this diffusive flux term with the standard upwind flux for the convective term results in a closed system for the vector of unknowns $\\mathbf{u}$. For a uniform periodic grid, this system takes the form $\\frac{d\\mathbf{u}}{dt} = A^{\\text{LDG}}\\mathbf{u}$, where the operator $A^{\\text{LDG}}$ is a circulant matrix defined by a five-point stencil.\n\nFor the BR-like baseline scheme, the operator is given more directly. The convective part uses the same upwind stencil as the LDG scheme. The diffusive part corresponds to the standard three-point central finite difference approximation of the second derivative, $\\nu(u_{i+1} - 2u_i + u_{i-1})/h^2$. Combining these terms yields a three-point stencil, which defines the circulant matrix $A^{\\text{BR}}$.\n\n**Implementation and Analysis**\n\nThe implementation involves constructing these sparse circulant matrices for each test case. Once an operator matrix $A$ is assembled, the required diagnostics are computed:\n- The **spectral abscissa margin** $m$ is found by computing all eigenvalues of $A$ and taking the negative of the maximum real part: $m = -\\max\\{\\Re(\\lambda)\\}$. The scheme is considered stable if this maximum real part is non-positive (within a small tolerance).\n- The **smooth-mode damping ratio** $r$ is calculated to assess accuracy on the smoothest modes. This involves defining the discrete sinusoidal mode vector $\\mathbf{v}$ with components $v_i = \\sin(k x_i)$ (with $k=1$), computing the Rayleigh quotient $\\lambda_{\\text{eff}} = (\\mathbf{v}^\\top A \\mathbf{v}) / (\\mathbf{v}^\\top \\mathbf{v})$, and finally normalizing by the continuum damping rate: $r = -\\Re(\\lambda_{\\text{eff}})/(\\nu k^2)$.\n\nThe provided Python code implements these steps. It contains functions to assemble each matrix based on the derived stencils and another function to compute the diagnostics for any given operator. The main script iterates through the specified test suite, calls these functions, and formats the final output as a list of lists.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import circulant\n\ndef assemble_A_LDG(N, L, b, nu, theta):\n    \"\"\"Assembles the LDG operator matrix A.\"\"\"\n    h = L / N\n    h2 = h * h\n\n    if b >= 0:\n        s_m2 = nu * (1 + theta) / (4 * h2)\n        s_m1 = b / h - nu * theta / (2 * h2)\n        s_0 = -b / h - nu / (2 * h2)\n        s_p1 = nu * theta / (2 * h2)\n        s_p2 = nu * (1 - theta) / (4 * h2)\n    else:  # b < 0\n        s_m2 = nu * (1 + theta) / (4 * h2)\n        s_m1 = -nu * theta / (2 * h2)\n        s_0 = b / h - nu / (2 * h2)\n        s_p1 = -b / h + nu * theta / (2 * h2)\n        s_p2 = nu * (1 - theta) / (4 * h2)\n\n    A = np.zeros((N, N), dtype=float)\n    # Applying the 5-point stencil with periodic wrap-around\n    for i in range(N):\n        A[i, (i - 2 + N) % N] += s_m2\n        A[i, (i - 1 + N) % N] += s_m1\n        A[i, i] += s_0\n        A[i, (i + 1) % N] += s_p1\n        A[i, (i + 2) % N] += s_p2\n        \n    return A\n\ndef assemble_A_BR(N, L, b, nu):\n    \"\"\"Assembles the Bassi-Rebay-like operator matrix A.\"\"\"\n    h = L / N\n    h2 = h * h\n\n    if b >= 0:\n        s_m1 = b / h + nu / h2\n        s_0 = -b / h - 2 * nu / h2\n        s_p1 = nu / h2\n    else:  # b < 0\n        s_m1 = nu / h2\n        s_0 = b / h - 2 * nu / h2\n        s_p1 = -b / h + nu / h2\n        \n    A = np.zeros((N, N), dtype=float)\n    # Applying the 3-point stencil with periodic wrap-around\n    for i in range(N):\n        A[i, (i - 1 + N) % N] += s_m1\n        A[i, i] += s_0\n        A[i, (i + 1) % N] += s_p1\n        \n    return A\n\ndef analyze_scheme(A, N, L, b, nu):\n    \"\"\"Computes stability, margin, and damping ratio for a given operator A.\"\"\"\n    # 1. Stability and margin m\n    eigvals = np.linalg.eigvals(A)\n    max_re = np.max(np.real(eigvals))\n    stable = bool(max_re <= 1e-10)\n    m = -max_re\n\n    # 2. Smooth-mode damping ratio r\n    h = L / N\n    k = 1.0\n    x = (np.arange(N) + 0.5) * h\n    v = np.sin(k * x)\n    \n    lambda_eff = (v.T @ A @ v) / (v.T @ v)\n    \n    # Continuum damping rate for denominator\n    continuum_damping = nu * k**2\n    r = -np.real(lambda_eff) / continuum_damping\n    \n    return [stable, m, r]\n\ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        # Case 1: LDG, N=40, L=2pi, b=0.2, nu=1.0, theta=0.0\n        ('LDG', 40, 2 * np.pi, 0.2, 1.0, 0.0),\n        # Case 2: LDG, N=40, L=2pi, b=0.2, nu=1.0, theta=0.1\n        ('LDG', 40, 2 * np.pi, 0.2, 1.0, 0.1),\n        # Case 3: LDG, N=40, L=2pi, b=0.2, nu=1.0, theta=0.5\n        ('LDG', 40, 2 * np.pi, 0.2, 1.0, 0.5),\n        # Case 4: LDG, N=40, L=2pi, b=0.2, nu=1.0, theta=1.0\n        ('LDG', 40, 2 * np.pi, 0.2, 1.0, 1.0),\n        # Case 5: LDG, N=10, L=2pi, b=-0.2, nu=1.0, theta=0.1\n        ('LDG', 10, 2 * np.pi, -0.2, 1.0, 0.1),\n        # Case 6: BR-like, N=40, L=2pi, b=0.2, nu=1.0\n        ('BR', 40, 2 * np.pi, 0.2, 1.0, None),\n        # Case 7: LDG, N=4, L=2pi, b=0.2, nu=1.0, theta=0.1\n        ('LDG', 4, 2 * np.pi, 0.2, 1.0, 0.1),\n    ]\n\n    results = []\n    for case in test_cases:\n        scheme_type, N, L, b, nu, theta = case\n        \n        if scheme_type == 'LDG':\n            A = assemble_A_LDG(N, L, b, nu, theta)\n        elif scheme_type == 'BR':\n            A = assemble_A_BR(N, L, b, nu)\n        else:\n            raise ValueError(f\"Unknown scheme type: {scheme_type}\")\n\n        analysis_result = analyze_scheme(A, N, L, b, nu)\n        results.append(analysis_result)\n    \n    # Format the final output string as a list of lists.\n    # The str() representation of a list includes the required spaces.\n    # Joining with ',' gives a compact representation.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "The structure of a numerical scheme's discrete operator directly impacts the qualitative properties of its solution. This computational practice extends our comparison of LDG and BR2 to two dimensions by examining the discrete Green's function—the system's fundamental response to a localized source . By implementing both a symmetric BR2-like scheme and a non-symmetric, directionally-biased LDG scheme, you will investigate how the formulation choice can induce numerical anisotropy in the solution, a crucial consideration for accuracy in multi-dimensional simulations.",
            "id": "3417428",
            "problem": "Consider the scalar diffusion partial differential equation on the unit square domain with homogeneous Dirichlet boundary conditions, given by\n$$\n-\\nabla \\cdot \\left( \\mathbf{K} \\, \\nabla u(x,y) \\right) = f(x,y), \\quad (x,y) \\in (0,1) \\times (0,1), \\quad u|_{\\partial \\Omega} = 0,\n$$\nwhere $\\mathbf{K} = \\mathrm{diag}(k_x, k_y)$ is a constant symmetric positive definite diffusion tensor with entries $k_x > 0$ and $k_y > 0$. Let the domain be partitioned into a uniform Cartesian mesh with $N_x$ elements in the $x$-direction and $N_y$ elements in the $y$-direction, each element being a rectangle of sizes $h_x = 1/N_x$ and $h_y = 1/N_y$. Consider piecewise constant basis functions per element. Define the discrete Green's function as the solution $\\mathbf{g}$ of the discrete linear system\n$$\n\\mathbf{A} \\, \\mathbf{g} = \\mathbf{e}_{i_0,j_0},\n$$\nwhere $\\mathbf{A}$ is the global stiffness matrix arising from a discontinuous Galerkin discretization, and $\\mathbf{e}_{i_0,j_0}$ is the Kronecker delta vector that is zero everywhere except at the index corresponding to the element $(i_0,j_0)$, where it equals one. The discrete Green's function represents the discrete response to a point source located at the element $(i_0,j_0)$.\n\nYou must compute and compare discrete Green's functions for two discontinuous Galerkin formulations:\n\n- The Local Discontinuous Galerkin (LDG) method, implemented through a face-based penalty operator with directional flux bias controlled by a parameter $\\alpha \\in [0,1)$ and a global orientation vector $\\boldsymbol{\\beta} \\in \\mathbb{R}^2$. For each interior face with unit normal $\\mathbf{n}$ pointing from the left element $\\mathcal{L}$ to the right element $\\mathcal{R}$, define the face stabilization coefficient\n$$\ns(\\mathbf{n}) = \\tau \\, \\frac{\\mathbf{n}^\\top \\mathbf{K} \\, \\mathbf{n}}{h_n},\n$$\nwhere $\\tau > 0$ is a stabilization parameter and $h_n$ is the mesh size in the direction normal to the face, equal to $h_x$ for vertical faces (normals $\\pm(1,0)$) and $h_y$ for horizontal faces (normals $\\pm(0,1)$). The LDG directional splitting assigns a fraction of $s(\\mathbf{n})$ to each side depending on $\\mathrm{sign}(\\boldsymbol{\\beta} \\cdot \\mathbf{n})$, specifically\n$$\ns_{\\mathcal{L}}(\\mathbf{n}) = \\frac{1+\\alpha}{2} \\, s(\\mathbf{n}) \\quad \\text{and} \\quad s_{\\mathcal{R}}(\\mathbf{n}) = \\frac{1-\\alpha}{2} \\, s(\\mathbf{n}) \\quad \\text{if } \\boldsymbol{\\beta} \\cdot \\mathbf{n} \\ge 0,\n$$\nand swapped if $\\boldsymbol{\\beta} \\cdot \\mathbf{n}  0$. The local assembly for an interior face contributes\n$$\n\\begin{aligned}\n\\mathbf{A}_{\\mathcal{L},\\mathcal{L}} \\mathrel{+}= s_{\\mathcal{L}}(\\mathbf{n}), \\quad \\mathbf{A}_{\\mathcal{L},\\mathcal{R}} \\mathrel{-}= s_{\\mathcal{L}}(\\mathbf{n}),\\\\\n\\mathbf{A}_{\\mathcal{R},\\mathcal{R}} \\mathrel{+}= s_{\\mathcal{R}}(\\mathbf{n}), \\quad \\mathbf{A}_{\\mathcal{R},\\mathcal{L}} \\mathrel{-}= s_{\\mathcal{R}}(\\mathbf{n}),\n\\end{aligned}\n$$\nwhile for boundary faces the assembly reduces to\n$$\n\\mathbf{A}_{\\mathcal{E},\\mathcal{E}} \\mathrel{+}= s(\\mathbf{n}),\n$$\nenforcing homogeneous Dirichlet boundary conditions. This LDG variant yields a generally nonsymmetric operator for $\\alpha \\ne 0$ and introduces directional bias through $\\boldsymbol{\\beta}$.\n\n- The Bassi-Rebay 2 (BR2) method, implemented as a symmetric interior penalty-like face operator for piecewise constant basis functions. For each interior face with the same $s(\\mathbf{n})$ as above, the symmetric assembly contributes\n$$\n\\mathbf{A}_{\\mathcal{L},\\mathcal{L}} \\mathrel{+}= s(\\mathbf{n}), \\quad \\mathbf{A}_{\\mathcal{R},\\mathcal{R}} \\mathrel{+}= s(\\mathbf{n}), \\quad \\mathbf{A}_{\\mathcal{L},\\mathcal{R}} \\mathrel{-}= s(\\mathbf{n}), \\quad \\mathbf{A}_{\\mathcal{R},\\mathcal{L}} \\mathrel{-}= s(\\mathbf{n}),\n$$\nand for boundary faces\n$$\n\\mathbf{A}_{\\mathcal{E},\\mathcal{E}} \\mathrel{+}= s(\\mathbf{n}).\n$$\nThis BR2 variant yields a symmetric positive definite operator for $\\tau$ sufficiently large, which on uniform meshes coincides with a consistent five-point discretization of the anisotropic Laplacian when $k_x$ and $k_y$ are the principal diffusivities.\n\nGiven a point source at $(i_0,j_0)$, compute the discrete Green's functions $\\mathbf{g}^{\\mathrm{LDG}}$ and $\\mathbf{g}^{\\mathrm{BR2}}$ by solving the corresponding linear systems. Investigate their decay and directional anisotropy via the following quantitative metrics, defined in terms of the values of the discrete Green's function on neighboring cells:\n\n- Define the axis-aligned first neighbors as $(i_0+1,j_0)$, $(i_0-1,j_0)$, $(i_0,j_0+1)$, $(i_0,j_0-1)$, and the second neighbor along the positive $x$-axis as $(i_0+2,j_0)$. Define the first diagonal neighbor as $(i_0+1,j_0+1)$. Let $\\mathbf{g}$ denote a discrete Green's function vector and $g_{i,j}$ its value in cell $(i,j)$. Then compute:\n    - The left-right anisotropy index\n    $$\n    \\mathrm{AI}_{\\mathrm{LR}}(\\mathbf{g}) = \\frac{\\left| g_{i_0+1,j_0} - g_{i_0-1,j_0} \\right|}{\\max\\left( \\left| g_{i_0+1,j_0} \\right|, \\left| g_{i_0-1,j_0} \\right| \\right)}.\n    $$\n    - The top-bottom anisotropy index\n    $$\n    \\mathrm{AI}_{\\mathrm{TB}}(\\mathbf{g}) = \\frac{\\left| g_{i_0,j_0+1} - g_{i_0,j_0-1} \\right|}{\\max\\left( \\left| g_{i_0,j_0+1} \\right|, \\left| g_{i_0,j_0-1} \\right| \\right)}.\n    $$\n    - The axis decay ratio\n    $$\n    \\mathrm{DR}_{\\mathrm{axis}}(\\mathbf{g}) = \\frac{\\left| g_{i_0+1,j_0} \\right|}{\\left| g_{i_0+2,j_0} \\right|},\n    $$\n    provided all indices are within bounds.\n    - The diagonal over axis ratio\n    $$\n    \\mathrm{RAR}_{\\mathrm{diag/axis}}(\\mathbf{g}) = \\frac{\\left| g_{i_0+1,j_0+1} \\right|}{\\left| g_{i_0+1,j_0} \\right|}.\n    $$\n\nFor each test case, compute the above four metrics for $\\mathbf{g}^{\\mathrm{LDG}}$ and for $\\mathbf{g}^{\\mathrm{BR2}}$, yielding eight floats per test case in the fixed order\n$$\n\\left[ \\mathrm{AI}_{\\mathrm{LR}}(\\mathbf{g}^{\\mathrm{LDG}}), \\mathrm{AI}_{\\mathrm{LR}}(\\mathbf{g}^{\\mathrm{BR2}}), \\mathrm{AI}_{\\mathrm{TB}}(\\mathbf{g}^{\\mathrm{LDG}}), \\mathrm{AI}_{\\mathrm{TB}}(\\mathbf{g}^{\\mathrm{BR2}}), \\mathrm{DR}_{\\mathrm{axis}}(\\mathbf{g}^{\\mathrm{LDG}}), \\mathrm{DR}_{\\mathrm{axis}}(\\mathbf{g}^{\\mathrm{BR2}}), \\mathrm{RAR}_{\\mathrm{diag/axis}}(\\mathbf{g}^{\\mathrm{LDG}}), \\mathrm{RAR}_{\\mathrm{diag/axis}}(\\mathbf{g}^{\\mathrm{BR2}}) \\right].\n$$\n\nYour program must implement the assembly of $\\mathbf{A}^{\\mathrm{LDG}}$ and $\\mathbf{A}^{\\mathrm{BR2}}$ as specified above, solve the linear systems for the discrete Green's functions using a direct sparse solver, and compute the metrics.\n\nTest Suite:\nUse the following test cases with parameters covering a general case, a boundary-influenced case, and a physically anisotropic case:\n\n1. Test Case $1$ (general, isotropic physics, directional LDG bias):\n   - $N_x = 25$, $N_y = 25$, $i_0 = 12$, $j_0 = 12$, $k_x = 1$, $k_y = 1$, $\\tau = 1$, $\\alpha = 0.8$, $\\boldsymbol{\\beta} = (1,1)$.\n\n2. Test Case $2$ (smaller mesh, source near boundary, stronger LDG bias in $x$):\n   - $N_x = 9$, $N_y = 9$, $i_0 = 2$, $j_0 = 2$, $k_x = 1$, $k_y = 1$, $\\tau = 1.2$, $\\alpha = 0.9$, $\\boldsymbol{\\beta} = (1,0)$.\n\n3. Test Case $3$ (physically anisotropic diffusion tensor):\n   - $N_x = 33$, $N_y = 33$, $i_0 = 16$, $j_0 = 16$, $k_x = 10$, $k_y = 1$, $\\tau = 1$, $\\alpha = 0.5$, $\\boldsymbol{\\beta} = (1,1)$.\n\nAll quantities are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by concatenating the eight metrics from each test case in the order $1$, $2$, $3$, for a total of $24$ floats:\n$$\n\\left[ \\text{metrics}_{\\text{TC1}}, \\text{metrics}_{\\text{TC2}}, \\text{metrics}_{\\text{TC3}} \\right].\n$$",
            "solution": "The problem requires the computation and analysis of discrete Green's functions for a scalar diffusion equation on a unit square. This is achieved by solving the governing linear system arising from two distinct discontinuous Galerkin (DG) formulations: a non-symmetric Local Discontinuous Galerkin (LDG) method and a symmetric Bassi-Rebay 2 (BR2) method. The basis functions are chosen to be piecewise constant on a uniform Cartesian mesh.\n\nThe overall procedure involves three main stages for each test case:\n$1$. Assembly of the global stiffness matrices $\\mathbf{A}^{\\mathrm{LDG}}$ and $\\mathbf{A}^{\\mathrm{BR2}}$.\n$2$. Solution of the linear systems $\\mathbf{A}^{\\mathrm{LDG}} \\mathbf{g}^{\\mathrm{LDG}} = \\mathbf{e}_{i_0,j_0}$ and $\\mathbf{A}^{\\mathrm{BR2}} \\mathbf{g}^{\\mathrm{BR2}} = \\mathbf{e}_{i_0,j_0}$ to find the discrete Green's functions $\\mathbf{g}^{\\mathrm{LDG}}$ and $\\mathbf{g}^{\\mathrm{BR2}}$.\n$3$. Computation of specified metrics to quantify the anisotropy and decay of the computed Green's functions.\n\nA pivotal step is the construction of the global stiffness matrix $\\mathbf{A}$. The domain $\\Omega = (0,1) \\times (0,1)$ is discretized into a grid of $N_x \\times N_y$ rectangular elements. The total number of degrees of freedom is $N = N_x N_y$. The elements are indexed by $(i,j)$, with $i \\in \\{0, \\dots, N_x-1\\}$ and $j \\in \\{0, \\dots, N_y-1\\}$, which are mapped to a single linear index $k = i N_y + j$. The matrix $\\mathbf{A}$ is an $N \\times N$ sparse matrix.\n\nThe matrix assembly is performed by iterating over all element faces. The contributions from each face are added to the corresponding entries of $\\mathbf{A}$.\n\nLet's consider an interior vertical face separating two elements, $\\mathcal{L}$ at $(i,j)$ and $\\mathcal{R}$ at $(i+1,j)$. The unit normal vector pointing from $\\mathcal{L}$ to $\\mathcal{R}$ is $\\mathbf{n} = (1,0)^\\top$. The mesh size in the normal direction is $h_n = h_x = 1/N_x$. The face stabilization coefficient is defined as:\n$$\ns(\\mathbf{n}) = \\tau \\frac{\\mathbf{n}^\\top \\mathbf{K} \\, \\mathbf{n}}{h_n} = \\tau \\frac{k_x}{h_x}\n$$\nSimilarly, for a horizontal face between $(i,j)$ and $(i,j+1)$, the normal is $\\mathbf{n} = (0,1)^\\top$ and the coefficient is $s(\\mathbf{n}) = \\tau k_y / h_y$.\n\nFor the BR2 method, which is a symmetric interior penalty method, the contributions for the face between $\\mathcal{L}$ and $\\mathcal{R}$ are:\n$$\n\\mathbf{A}_{\\mathcal{L},\\mathcal{L}} \\mathrel{+}= s(\\mathbf{n}), \\quad \\mathbf{A}_{\\mathcal{R},\\mathcal{R}} \\mathrel{+}= s(\\mathbf{n}), \\quad \\mathbf{A}_{\\mathcal{L},\\mathcal{R}} \\mathrel{-}= s(\\mathbf{n}), \\quad \\mathbf{A}_{\\mathcal{R},\\mathcal{L}} \\mathrel{-}= s(\\mathbf{n})\n$$\nThis assembly rule is symmetric, resulting in a symmetric matrix $\\mathbf{A}^{\\mathrm{BR2}}$.\n\nFor the LDG method, the formulation introduces non-symmetric, directional biasing. The stabilization coefficient $s(\\mathbf{n})$ is split into two parts, $s_{\\mathcal{L}}(\\mathbf{n})$ and $s_{\\mathcal{R}}(\\mathbf{n})$, depending on the sign of the dot product $\\boldsymbol{\\beta} \\cdot \\mathbf{n}$, where $\\boldsymbol{\\beta}$ is the global orientation vector and $\\alpha \\in [0,1)$ is the biasing parameter.\nIf $\\boldsymbol{\\beta} \\cdot \\mathbf{n} \\ge 0$:\n$$\ns_{\\mathcal{L}}(\\mathbf{n}) = \\frac{1+\\alpha}{2} s(\\mathbf{n}), \\quad s_{\\mathcal{R}}(\\mathbf{n}) = \\frac{1-\\alpha}{2} s(\\mathbf{n})\n$$\nIf $\\boldsymbol{\\beta} \\cdot \\mathbf{n}  0$, the roles of $\\mathcal{L}$ and $\\mathcal{R}$ are swapped, meaning:\n$$\ns_{\\mathcal{L}}(\\mathbf{n}) = \\frac{1-\\alpha}{2} s(\\mathbf{n}), \\quad s_{\\mathcal{R}}(\\mathbf{n}) = \\frac{1+\\alpha}{2} s(\\mathbf{n})\n$$\nThe matrix assembly contributions for the LDG method are:\n$$\n\\begin{aligned}\n\\mathbf{A}_{\\mathcal{L},\\mathcal{L}} \\mathrel{+}= s_{\\mathcal{L}}(\\mathbf{n}), \\quad \\mathbf{A}_{\\mathcal{L},\\mathcal{R}} \\mathrel{-}= s_{\\mathcal{L}}(\\mathbf{n}),\\\\\n\\mathbf{A}_{\\mathcal{R},\\mathcal{R}} \\mathrel{+}= s_{\\mathcal{R}}(\\mathbf{n}), \\quad \\mathbf{A}_{\\mathcal{R},\\mathcal{L}} \\mathrel{-}= s_{\\mathcal{R}}(\\mathbf{n})\n\\end{aligned}\n$$\nSince $s_{\\mathcal{L}} \\ne s_{\\mathcal{R}}$ for $\\alpha \\ne 0$, the resulting matrix $\\mathbf{A}^{\\mathrm{LDG}}$ is generally non-symmetric.\n\nFor faces on the boundary of the domain $\\partial\\Omega$, homogeneous Dirichlet conditions are enforced weakly. For an element $\\mathcal{E}$ with a boundary face, a penalty term is added to its diagonal entry:\n$$\n\\mathbf{A}_{\\mathcal{E},\\mathcal{E}} \\mathrel{+}= s(\\mathbf{n})\n$$\nThis applies to both BR2 and LDG methods, where $\\mathbf{n}$ is the outward-pointing normal of the boundary face.\n\nThe right-hand side of the linear system, $\\mathbf{e}_{i_0,j_0}$, is a vector of all zeros except for a value of $1$ at the linear index corresponding to the source element $(i_0,j_0)$. This represents a discrete Dirac delta function.\n\nThe matrices $\\mathbf{A}^{\\mathrm{LDG}}$ and $\\mathbf{A}^{\\mathrm{BR2}}$ are assembled as sparse matrices, specifically using `scipy.sparse.lil_matrix` for efficient construction and then converted to `scipy.sparse.csr_matrix` for fast arithmetic and solving. The linear systems are solved using the direct sparse solver `scipy.sparse.linalg.spsolve`.\n\nThe resulting solution vectors, $\\mathbf{g}^{\\mathrm{LDG}}$ and $\\mathbf{g}^{\\mathrm{BR2}}$, are reshaped into $N_x \\times N_y$ arrays. Using the values $g_{i,j}$ from these arrays, the following four metrics are computed for each method:\n- Left-right anisotropy index: $\\mathrm{AI}_{\\mathrm{LR}}(\\mathbf{g}) = \\frac{\\left| g_{i_0+1,j_0} - g_{i_0-1,j_0} \\right|}{\\max\\left( \\left| g_{i_0+1,j_0} \\right|, \\left| g_{i_0-1,j_0} \\right| \\right)}$\n- Top-bottom anisotropy index: $\\mathrm{AI}_{\\mathrm{TB}}(\\mathbf{g}) = \\frac{\\left| g_{i_0,j_0+1} - g_{i_0,j_0-1} \\right|}{\\max\\left( \\left| g_{i_0,j_0+1} \\right|, \\left| g_{i_0,j_0-1} \\right| \\right)}$\n- Axis decay ratio: $\\mathrm{DR}_{\\mathrm{axis}}(\\mathbf{g}) = \\frac{\\left| g_{i_0+1,j_0} \\right|}{\\left| g_{i_0+2,j_0} \\right|}$\n- Diagonal over axis ratio: $\\mathrm{RAR}_{\\mathrm{diag/axis}}(\\mathbf{g}) = \\frac{\\left| g_{i_0+1,j_0+1} \\right|}{\\left| g_{i_0+1,j_0} \\right|}$\n\nThese metrics provide quantitative insight into how the numerical dissipation and directional biases of each DG scheme, as well as the physical anisotropy of the diffusion tensor $\\mathbf{K}$, manifest in the discrete solution. The final output is a flattened list of these eight metrics for each of the three test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef assemble_matrix(Nx, Ny, kx, ky, tau, alpha, beta, method):\n    \"\"\"\n    Assembles the sparse stiffness matrix for the given DG method.\n    \"\"\"\n    N = Nx * Ny\n    hx = 1.0 / Nx\n    hy = 1.0 / Ny\n    A = lil_matrix((N, N), dtype=np.float64)\n\n    def idx(i, j):\n        # Maps 2D element index (i, j) to 1D linear index.\n        return i * Ny + j\n\n    # Process vertical interior faces\n    sx = tau * kx / hx\n    for i in range(Nx - 1):\n        for j in range(Ny):\n            kL = idx(i, j)\n            kR = idx(i + 1, j)\n\n            if method == 'BR2':\n                A[kL, kL] += sx\n                A[kR, kR] += sx\n                A[kL, kR] -= sx\n                A[kR, kL] -= sx\n            elif method == 'LDG':\n                n = np.array([1.0, 0.0])\n                beta_dot_n = np.dot(beta, n)\n                if beta_dot_n >= 0:\n                    sL = 0.5 * (1.0 + alpha) * sx\n                    sR = 0.5 * (1.0 - alpha) * sx\n                else:\n                    sL = 0.5 * (1.0 - alpha) * sx\n                    sR = 0.5 * (1.0 + alpha) * sx\n                \n                A[kL, kL] += sL\n                A[kL, kR] -= sL\n                A[kR, kR] += sR\n                A[kR, kL] -= sR\n\n    # Process horizontal interior faces\n    sy = tau * ky / hy\n    for i in range(Nx):\n        for j in range(Ny - 1):\n            kL = idx(i, j)      # Bottom element\n            kR = idx(i, j + 1)  # Top element\n\n            if method == 'BR2':\n                A[kL, kL] += sy\n                A[kR, kR] += sy\n                A[kL, kR] -= sy\n                A[kR, kL] -= sy\n            elif method == 'LDG':\n                n = np.array([0.0, 1.0])\n                beta_dot_n = np.dot(beta, n)\n                if beta_dot_n >= 0:\n                    sL = 0.5 * (1.0 + alpha) * sy\n                    sR = 0.5 * (1.0 - alpha) * sy\n                else:\n                    sL = 0.5 * (1.0 - alpha) * sy\n                    sR = 0.5 * (1.0 + alpha) * sy\n                \n                A[kL, kL] += sL\n                A[kL, kR] -= sL\n                A[kR, kR] += sR\n                A[kR, kL] -= sR\n\n    # Process boundary faces (penalty enforcement)\n    # Left boundary (i=0)\n    for j in range(Ny):\n        A[idx(0, j), idx(0, j)] += sx\n    # Right boundary (i=Nx-1)\n    for j in range(Ny):\n        A[idx(Nx - 1, j), idx(Nx - 1, j)] += sx\n    # Bottom boundary (j=0)\n    for i in range(Nx):\n        A[idx(i, 0), idx(i, 0)] += sy\n    # Top boundary (j=Ny-1)\n    for i in range(Ny):\n        A[idx(i, Ny - 1), idx(i, Ny - 1)] += sy\n\n    return A.tocsr()\n\ndef compute_metrics(g, i0, j0):\n    \"\"\"\n    Computes the four specified metrics from the discrete Green's function.\n    \"\"\"\n    g_ip1_j0 = g[i0 + 1, j0]\n    g_im1_j0 = g[i0 - 1, j0]\n    g_i0_jp1 = g[i0, j0 + 1]\n    g_i0_jm1 = g[i0, j0 - 1]\n    g_ip2_j0 = g[i0 + 2, j0]\n    g_ip1_jp1 = g[i0 + 1, j0 + 1]\n\n    # AI_LR\n    num_lr = np.abs(g_ip1_j0 - g_im1_j0)\n    den_lr = np.max([np.abs(g_ip1_j0), np.abs(g_im1_j0)])\n    ai_lr = num_lr / den_lr if den_lr > 1e-15 else 0.0\n\n    # AI_TB\n    num_tb = np.abs(g_i0_jp1 - g_i0_jm1)\n    den_tb = np.max([np.abs(g_i0_jp1), np.abs(g_i0_jm1)])\n    ai_tb = num_tb / den_tb if den_tb > 1e-15 else 0.0\n\n    # DR_axis\n    num_dr = np.abs(g_ip1_j0)\n    den_dr = np.abs(g_ip2_j0)\n    dr_axis = num_dr / den_dr if den_dr > 1e-15 else 0.0\n\n    # RAR_diag/axis\n    num_rar = np.abs(g_ip1_jp1)\n    den_rar = np.abs(g_ip1_j0)\n    rar_diag_axis = num_rar / den_rar if den_rar > 1e-15 else 0.0\n\n    return {\n        'AI_LR': ai_lr, 'AI_TB': ai_tb, \n        'DR_axis': dr_axis, 'RAR_diag/axis': rar_diag_axis\n    }\n\ndef solve_case(case_params):\n    \"\"\"\n    Solves one test case: assembles matrices, solves systems, computes metrics.\n    \"\"\"\n    Nx, Ny, i0, j0, kx, ky, tau, alpha, beta_tuple = case_params\n    beta = np.array(beta_tuple, dtype=np.float64)\n    \n    A_ldg = assemble_matrix(Nx, Ny, kx, ky, tau, alpha, beta, 'LDG')\n    A_br2 = assemble_matrix(Nx, Ny, kx, ky, tau, alpha, beta, 'BR2')\n\n    N = Nx * Ny\n    rhs = np.zeros(N)\n    source_idx = i0 * Ny + j0\n    rhs[source_idx] = 1.0\n\n    g_ldg_flat = spsolve(A_ldg, rhs)\n    g_br2_flat = spsolve(A_br2, rhs)\n\n    g_ldg = g_ldg_flat.reshape((Nx, Ny))\n    g_br2 = g_br2_flat.reshape((Nx, Ny))\n\n    metrics_ldg = compute_metrics(g_ldg, i0, j0)\n    metrics_br2 = compute_metrics(g_br2, i0, j0)\n\n    results = [\n        metrics_ldg['AI_LR'], metrics_br2['AI_LR'],\n        metrics_ldg['AI_TB'], metrics_br2['AI_TB'],\n        metrics_ldg['DR_axis'], metrics_br2['DR_axis'],\n        metrics_ldg['RAR_diag/axis'], metrics_br2['RAR_diag/axis']\n    ]\n    return results\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Nx, Ny, i0, j0, kx, ky, tau, alpha, beta)\n        (25, 25, 12, 12, 1.0, 1.0, 1.0, 0.8, (1.0, 1.0)),\n        (9, 9, 2, 2, 1.0, 1.0, 1.2, 0.9, (1.0, 0.0)),\n        (33, 33, 16, 16, 10.0, 1.0, 1.0, 0.5, (1.0, 1.0)),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_results = solve_case(case)\n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}