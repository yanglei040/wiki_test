{
    "hands_on_practices": [
        {
            "introduction": "本实践提供了一个基础的解析练习。通过对一个特定变形下的单个有限元手动计算其应变能，你将直接比较全积分和选择性积分得到的结果。这个练习能让你在最基础的层面上具体理解不同的数值求积方案如何影响单元刚度，并阐明了分离应变能并对各部分应用不同积分规则的力学原理 。",
            "id": "3439222",
            "problem": "考虑在单个等参双线性四边形 ($Q_1$) 有限元上的平面应变各向同性线性弹性问题。该单元占据物理正方形区域 $\\Omega_e = [0,L] \\times [0,L]$，其中 $L>0$。使用标准参考正方形 $(\\xi,\\eta) \\in [-1,1] \\times [-1,1]$ 和仿射映射 $x = \\frac{L}{2}(\\xi+1)$，$y = \\frac{L}{2}(\\eta+1)$，因此雅可比行列式为 $|J| = \\frac{L^2}{4}$。\n\n令四个 $Q_1$ 形函数为\n$$\nN_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta).\n$$\n假设位移场插值为 $u(x,y) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,u_i$ 和 $v(x,y) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,v_i$，其中 $(u_i,v_i)$ 分别是 $x$ 和 $y$ 方向上的节点值。考虑一个特定的节点向量，其中只有节点1的 $x$ 方向位移不为零：$u_1=1$, $v_1=0$，且 $u_2=u_3=u_4=v_2=v_3=v_4=0$。\n\n使用小应变定义 $\\varepsilon = \\frac{1}{2}(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\top})$，因此 $\\varepsilon_{xx} = \\partial u/\\partial x$，$\\varepsilon_{yy} = \\partial v/\\partial y$，且 $\\varepsilon_{xy} = \\frac{1}{2}(\\partial u/\\partial y + \\partial v/\\partial x)$。在二维情况下采用体积-偏应力分解：$\\varepsilon_{\\text{dev}} = \\varepsilon - \\frac{1}{2}(\\operatorname{tr}\\varepsilon)\\,\\mathbf{I}$，其能量密度为\n$$\nw(\\varepsilon) = \\mu\\,\\varepsilon_{\\text{dev}}:\\varepsilon_{\\text{dev}} + \\frac{\\kappa}{2}\\,(\\operatorname{tr}\\varepsilon)^2,\n$$\n其中 $\\mu>0$ 是剪切模量，$\\kappa = \\lambda + \\mu$ 是用拉梅参数 $\\lambda>0$ 和 $\\mu$ 表示的二维体积模量。\n\n将给定学位移场的单元能量定义为 $E = \\int_{\\Omega_e} w(\\varepsilon)\\, d\\Omega$。计算给定节点向量的以下两种能量：\n- $E_{\\text{full}}$，对偏量和体积贡献均在参考单元上使用标准的完全 $2\\times 2$ 高斯求积。\n- $E_{\\text{sel}}$，使用选择积分：对偏量贡献应用完全 $2\\times 2$ 高斯求积，对体积贡献应用缩减 $1\\times 1$ 高斯求积（在参考单元上的 $(\\xi,\\eta)=(0,0)$ 点求值，权重为 $4$）。\n\n根据第一性原理和以上定义，推导出 $E_{\\text{full}}$ 和 $E_{\\text{sel}}$，并给出比值 $r$ 的单一闭式解析表达式：\n$$\nr \\equiv \\frac{E_{\\text{sel}}}{E_{\\text{full}}}\n$$\n该表达式是 $\\lambda$ 和 $\\mu$ 的函数。不需要进行数值舍入。将最终答案表示为单一的解析表达式。",
            "solution": "用户希望计算在特定变形下单个有限元的弹性势能之比，该能量通过两种不同的数值积分方案计算：完全求积和选择性缩减求积。\n\n首先，我们必须验证问题陈述。\n1.  **提取已知条件**：问题提供了双线性四边形单元的几何形状、从参考单元的映射、形函数 $N_i$、特定的节点位移向量、应变和应变能密度的体积-偏应力分解的定义、材料参数 $\\mu$ 和 $\\kappa = \\lambda + \\mu$，以及两种积分方案的定义（完全 $2 \\times 2$ 高斯求积和选择性 $2 \\times 2 / 1 \\times 1$ 求积）。\n2.  **验证**：该问题在科学上基于线性弹性理论和有限元方法。所有定义和常数在该领域都是标准的。问题是适定的，目标明确，并提供了所有必要的信息。没有矛盾、歧义或伪科学的主张。\n3.  **结论**：问题有效。\n\n我们现在开始推导解答。\n\n单元内的位移场 $(\\,u(\\xi,\\eta), v(\\xi,\\eta)\\,)$ 是使用形函数 $N_i(\\xi,\\eta)$ 从节点值 $(u_i,v_i)$ 插值得到的。给定节点位移向量 $u_1=1$ 且所有其他 $u_i, v_i$ 均为零，位移场简化为：\n$$\nu(\\xi,\\eta) = N_1(\\xi,\\eta) \\cdot u_1 = N_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)\n$$\n$$\nv(\\xi,\\eta) = 0\n$$\n\n为了计算应变张量 $\\varepsilon$，我们需要位移场的空间导数。从参考坐标 $(\\xi,\\eta)$到物理坐标 $(x,y)$ 的映射由 $x = \\frac{L}{2}(\\xi+1)$ 和 $y = \\frac{L}{2}(\\eta+1)$ 给出。该变换的雅可比矩阵为：\n$$\n\\mathbf{J} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} \\frac{L}{2} & 0 \\\\ 0 & \\frac{L}{2} \\end{pmatrix}\n$$\n雅可比行列式为 $|J| = \\frac{L^2}{4}$，是一个常数。逆雅可比矩阵为：\n$$\n\\mathbf{J}^{-1} = \\begin{pmatrix} \\frac{2}{L} & 0 \\\\ 0 & \\frac{2}{L} \\end{pmatrix}\n$$\n物理坐标系中的梯度算子通过 $\\begin{pmatrix} \\partial/\\partial x \\\\ \\partial/\\partial y \\end{pmatrix} = \\mathbf{J}^{-1} \\begin{pmatrix} \\partial/\\partial \\xi \\\\ \\partial/\\partial \\eta \\end{pmatrix}$ 与参考坐标系中的梯度相关。位移分量的导数为：\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{2}{L} \\frac{\\partial u}{\\partial \\xi} = \\frac{2}{L} \\left( -\\frac{1}{4}(1-\\eta) \\right) = -\\frac{1}{2L}(1-\\eta) = \\frac{1}{2L}(\\eta-1)\n$$\n$$\n\\frac{\\partial u}{\\partial y} = \\frac{2}{L} \\frac{\\partial u}{\\partial \\eta} = \\frac{2}{L} \\left( -\\frac{1}{4}(1-\\xi) \\right) = -\\frac{1}{2L}(1-\\xi) = \\frac{1}{2L}(\\xi-1)\n$$\n$$\n\\frac{\\partial v}{\\partial x} = 0, \\quad \\frac{\\partial v}{\\partial y} = 0\n$$\n小应变张量 $\\varepsilon$ 的分量为：\n$$\n\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x} = \\frac{1}{2L}(\\eta-1)\n$$\n$$\n\\varepsilon_{yy} = \\frac{\\partial v}{\\partial y} = 0\n$$\n$$\n\\varepsilon_{xy} = \\frac{1}{2}\\left(\\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}\\right) = \\frac{1}{2} \\frac{1}{2L}(\\xi-1) = \\frac{1}{4L}(\\xi-1)\n$$\n应变张量的迹为 $\\operatorname{tr}\\varepsilon = \\varepsilon_{xx} + \\varepsilon_{yy} = \\frac{1}{2L}(\\eta-1)$。\n\n单元的总应变能 $E$ 是能量密度 $w(\\varepsilon)$ 在单元面积 $\\Omega_e$ 上的积分。能量密度分为偏量和体积部分：$w(\\varepsilon) = w_{\\text{dev}} + w_{\\text{vol}}$。\n$$\nw_{\\text{vol}} = \\frac{\\kappa}{2}(\\operatorname{tr}\\varepsilon)^2 = \\frac{\\kappa}{2} \\left(\\frac{1}{2L}(\\eta-1)\\right)^2 = \\frac{\\kappa}{8L^2}(1-\\eta)^2\n$$\n偏应变张量的分量为 $\\varepsilon_{\\text{dev}} = \\varepsilon - \\frac{1}{2}(\\operatorname{tr}\\varepsilon)\\mathbf{I}$：\n$$\n\\varepsilon_{\\text{dev},xx} = \\varepsilon_{xx} - \\frac{1}{2}\\operatorname{tr}\\varepsilon = \\frac{1}{2L}(\\eta-1) - \\frac{1}{4L}(\\eta-1) = \\frac{1}{4L}(\\eta-1)\n$$\n$$\n\\varepsilon_{\\text{dev},yy} = \\varepsilon_{yy} - \\frac{1}{2}\\operatorname{tr}\\varepsilon = 0 - \\frac{1}{4L}(\\eta-1) = -\\frac{1}{4L}(\\eta-1)\n$$\n$$\n\\varepsilon_{\\text{dev},xy} = \\varepsilon_{xy} = \\frac{1}{4L}(\\xi-1)\n$$\n偏应变能量密度为 $w_{\\text{dev}} = \\mu\\,\\varepsilon_{\\text{dev}}:\\varepsilon_{\\text{dev}} = \\mu ((\\varepsilon_{\\text{dev},xx})^2 + (\\varepsilon_{\\text{dev},yy})^2 + 2(\\varepsilon_{\\text{dev},xy})^2)$：\n$$\nw_{\\text{dev}} = \\mu \\left[ \\left(\\frac{\\eta-1}{4L}\\right)^2 + \\left(-\\frac{\\eta-1}{4L}\\right)^2 + 2\\left(\\frac{\\xi-1}{4L}\\right)^2 \\right] = \\frac{\\mu}{16L^2} \\left[ 2(1-\\eta)^2 + 2(1-\\xi)^2 \\right] = \\frac{\\mu}{8L^2} \\left[ (1-\\xi)^2 + (1-\\eta)^2 \\right]\n$$\n总能量为 $E = \\int_{\\Omega_e} w(\\varepsilon) d\\Omega = \\int_{-1}^{1}\\int_{-1}^{1} w(\\varepsilon(\\xi,\\eta)) |J| d\\xi d\\eta$。我们在参考单元上定义被积函数：\n$$\nI_{\\text{dev}}(\\xi,\\eta) = w_{\\text{dev}} |J| = \\frac{\\mu}{8L^2} \\left[ (1-\\xi)^2 + (1-\\eta)^2 \\right] \\frac{L^2}{4} = \\frac{\\mu}{32} \\left[ (1-\\xi)^2 + (1-\\eta)^2 \\right]\n$$\n$$\nI_{\\text{vol}}(\\xi,\\eta) = w_{\\text{vol}} |J| = \\frac{\\kappa}{8L^2}(1-\\eta)^2 \\frac{L^2}{4} = \\frac{\\kappa}{32}(1-\\eta)^2\n$$\n由于被积函数是二次多项式，因此 $2 \\times 2$ 高斯求积是精确的。我们来计算精确积分，这将对应于完全积分方案。\n偏能量为：\n$$\nE_{\\text{dev}} = \\int_{-1}^{1}\\int_{-1}^{1} I_{\\text{dev}}(\\xi,\\eta) d\\xi d\\eta = \\frac{\\mu}{32} \\int_{-1}^{1}\\int_{-1}^{1} \\left[ (1-\\xi)^2 + (1-\\eta)^2 \\right] d\\xi d\\eta\n$$\n我们使用这个事实：$\\int_{-1}^{1} (1-t)^2 dt = \\left[-\\frac{(1-t)^3}{3}\\right]_{-1}^{1} = 0 - (-\\frac{8}{3}) = \\frac{8}{3}$。\n$$\nE_{\\text{dev}} = \\frac{\\mu}{32} \\left[ \\left(\\frac{8}{3}\\right) \\cdot \\int_{-1}^1 d\\eta + \\left(\\frac{8}{3}\\right) \\cdot \\int_{-1}^1 d\\xi \\right] = \\frac{\\mu}{32} \\left[ \\frac{8}{3} \\cdot 2 + \\frac{8}{3} \\cdot 2 \\right] = \\frac{\\mu}{32} \\left(\\frac{32}{3}\\right) = \\frac{\\mu}{3}\n$$\n在完全积分下的体积能量为：\n$$\nE_{\\text{vol,full}} = \\int_{-1}^{1}\\int_{-1}^{1} I_{\\text{vol}}(\\xi,\\eta) d\\xi d\\eta = \\frac{\\kappa}{32} \\int_{-1}^{1}\\int_{-1}^{1} (1-\\eta)^2 d\\xi d\\eta = \\frac{\\kappa}{32} \\left(\\frac{8}{3}\\right) \\cdot 2 = \\frac{\\kappa}{32} \\left(\\frac{16}{3}\\right) = \\frac{\\kappa}{6}\n$$\n因此，使用完全积分的总能量为：\n$$\nE_{\\text{full}} = E_{\\text{dev}} + E_{\\text{vol,full}} = \\frac{\\mu}{3} + \\frac{\\kappa}{6} = \\frac{2\\mu+\\kappa}{6}\n$$\n现在我们使用选择积分计算能量 $E_{\\text{sel}}$。偏量部分使用完全 $2 \\times 2$ 求积，因此 $E_{\\text{sel,dev}} = E_{\\text{dev}} = \\frac{\\mu}{3}$。体积部分使用缩减 $1 \\times 1$ 求积（点 $(\\xi,\\eta)=(0,0)$，权重 $w=4$）。\n$$\nE_{\\text{sel,vol}} = w \\cdot I_{\\text{vol}}(0,0) = 4 \\cdot \\left[ \\frac{\\kappa}{32}(1-0)^2 \\right] = \\frac{4\\kappa}{32} = \\frac{\\kappa}{8}\n$$\n使用选择积分的总能量为：\n$$\nE_{\\text{sel}} = E_{\\text{sel,dev}} + E_{\\text{sel,vol}} = \\frac{\\mu}{3} + \\frac{\\kappa}{8} = \\frac{8\\mu+3\\kappa}{24}\n$$\n最后，我们计算比值 $r = E_{\\text{sel}} / E_{\\text{full}}$。\n$$\nr = \\frac{\\frac{8\\mu+3\\kappa}{24}}{\\frac{2\\mu+\\kappa}{6}} = \\frac{8\\mu+3\\kappa}{24} \\cdot \\frac{6}{2\\mu+\\kappa} = \\frac{8\\mu+3\\kappa}{4(2\\mu+\\kappa)}\n$$\n问题要求答案用拉梅参数 $\\lambda$ 和 $\\mu$ 表示。我们代入 $\\kappa = \\lambda + \\mu$：\n$$\nr = \\frac{8\\mu+3(\\lambda+\\mu)}{4(2\\mu+(\\lambda+\\mu))} = \\frac{8\\mu+3\\lambda+3\\mu}{4(3\\mu+\\lambda)} = \\frac{11\\mu+3\\lambda}{4(3\\mu+\\lambda)}\n$$",
            "answer": "$$\n\\boxed{\\frac{3\\lambda + 11\\mu}{4(\\lambda + 3\\mu)}}\n$$"
        },
        {
            "introduction": "在单元素分析的基础上，本实践旨在展示使用选择性积分的主要动机：缓解体积锁定。通过一个涉及近不可压缩材料的数值实验，你将实现并比较使用全积分和选择性积分方案的有限元解。这项练习将使你能够定量地观察到，在近不可压条件下，全积分如何导致数值“锁定”现象，而选择性积分又是如何有效克服这一问题的 。",
            "id": "3439252",
            "problem": "考虑在单位正方形域 $\\Omega = [0,1] \\times [0,1]$ 上的二维、静态、小应变、均匀、各向同性线性弹性力学问题，Lamé 参数为 $(\\lambda,\\mu)$，处于平面应变状态。设位移场为 $u: \\Omega \\to \\mathbb{R}^2$，其分量为 $u_1$ 和 $u_2$。控制方程为平衡定律 $-\\nabla \\cdot \\sigma = f$ 和本构关系 $\\sigma = 2\\mu\\,\\nabla^s u + \\lambda\\,(\\nabla \\cdot u)\\,I$，其中 $\\nabla^s u = \\tfrac{1}{2}(\\nabla u + \\nabla u^\\top)$ 是对称梯度。在标准的 Sobolev 空间中考虑其弱形式，其中位移场 $u$ 在整个边界 $\\partial\\Omega$ 上受 Dirichlet 边界条件约束。\n\n为研究在近不可压缩状态下减缩积分和选择性积分的数值效应，请在单位正方形的结构化网格上使用带有双线性（四节点）四边形单元 ($Q_1$) 的有限元法 (FEM)。采用位移场的构造解，\n$$\nu_{\\text{exact}}(x,y) = \\begin{bmatrix}\n\\sin(\\pi x)\\sin(\\pi y) \\\\\n\\sin(\\pi x)\\sin(\\pi y)\n\\end{bmatrix},\n$$\n并在边界 $\\partial\\Omega$ 上施加 Dirichlet 边界条件 $u = u_{\\text{exact}}$。推导与偏微分方程一致的相应体力 $f$，使得 $u_{\\text{exact}}$ 是强形式的精确解。对以下两种格式，组装并求解离散线性系统：\n- 完全积分：在参考正方形上使用 $2\\times 2$ Gaussian 求积法对偏量项 $\\int_{\\Omega} 2\\mu\\,\\nabla^s u : \\nabla^s v\\,\\mathrm{d}\\Omega$ 和体积项 $\\int_{\\Omega} \\lambda\\,(\\nabla \\cdot u)(\\nabla \\cdot v)\\,\\mathrm{d}\\Omega$ 进行积分。\n- 选择性积分：偏量项使用 $2\\times 2$ Gaussian 求积法积分，但体积项在参考正方形上使用单元中心的单点 Gaussian 求积法积分。\n\n从平衡定律和本构关系推导出的弱形式出发，利用双线性形函数和标准等参映射构建离散系统。对于这两种格式，计算数值解 $u_h$ 并量化：\n1. 位移的 $L^2$-范数误差，\n$$\nE_u = \\left( \\int_{\\Omega} \\|u_h - u_{\\text{exact}}\\|^2 \\,\\mathrm{d}\\Omega \\right)^{1/2}.\n$$\n2. 体积的 $L^2$-范数误差，\n$$\nE_{\\nabla\\cdot u} = \\left( \\int_{\\Omega} \\left( \\nabla \\cdot u_h - \\nabla \\cdot u_{\\text{exact}} \\right)^2 \\,\\mathrm{d}\\Omega \\right)^{1/2}.\n$$\n\n使用 $2\\times 2$ Gaussian 求积法计算这些误差。定义闭锁缓解因子为比率 $R_{\\text{lock}} = E_u^{\\text{full}} / E_u^{\\text{sel}}$；大于 1 的值表示选择性积分相对于完全积分减小了位移误差（缓解了闭锁）。定义体积误差因子为 $R_{\\text{vol}} = E_{\\nabla\\cdot u}^{\\text{sel}} / E_{\\nabla\\cdot u}^{\\text{full}}$；大于 1 的值表示选择性积分相对于完全积分增加了体积误差。\n\n您的程序必须：\n- 使用强形式 $-\\nabla\\cdot\\sigma=f$（其中 $\\sigma = 2\\mu\\,\\nabla^s u + \\lambda(\\nabla\\cdot u) I$）推导并实现与 $u_{\\text{exact}}$ 一致的体力 $f$。\n- 严格按照描述为完全积分和选择性积分方案组装刚度矩阵。\n- 使用 $2\\times 2$ Gaussian 求积法组装载荷向量。\n- 在 $\\partial\\Omega$ 上施加 Dirichlet 边界条件 $u=u_{\\text{exact}}$。\n- 求解两个离散系统并为每个系统计算 $E_u$ 和 $E_{\\nabla\\cdot u}$。\n\n测试套件：\n提供四个测试用例，形式为元组 $(N_x,N_y,\\lambda,\\mu)$，其中 $N_x$ 和 $N_y$ 分别是 $x$ 和 $y$ 方向上的单元数量：\n1. $(8,8,1,1)$: 可压缩基线。\n2. $(8,8,10^3,1)$: 中度近不可压缩。\n3. $(8,8,10^6,1)$: 强度近不可压缩。\n4. $(4,4,10^6,1)$: 强度近不可压缩条件下的粗网格。\n\n对于每个测试用例，计算并返回列表\n$$\n\\left[ E_u^{\\text{full}},\\, E_u^{\\text{sel}},\\, R_{\\text{lock}},\\, E_{\\nabla\\cdot u}^{\\text{full}},\\, E_{\\nabla\\cdot u}^{\\text{sel}},\\, R_{\\text{vol}} \\right].\n$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的结果，格式为方括号括起来的逗号分隔的列表的列表，例如，\n$[ [\\text{case1\\_results}], [\\text{case2\\_results}], [\\text{case3\\_results}], [\\text{case4\\_results}] ]$。\n此问题不涉及物理单位。如果出现角度，必须以弧度为单位。所有数值答案必须是浮点数。",
            "solution": "用户提供的问题经验证具有科学依据、是良态的且客观。这是计算固体力学中的一个标准验证问题，旨在分析有限元法 (FEM) 中的体积闭锁现象以及选择性积分作为补救措施的有效性。求解过程如下。\n\n### 1. 控制方程和弱形式\n该问题涉及在单位正方形域 $\\Omega = [0,1] \\times [0,1]$ 上，平面应变条件下的二维、静态、线性弹性力学：\n$$-\\nabla \\cdot \\sigma = f \\quad \\text{在 } \\Omega$$\n$$\\sigma = 2\\mu\\,\\nabla^s u + \\lambda\\,(\\nabla \\cdot u)\\,I$$\n其中 $u$ 是位移场，$f$ 是单位体积的体力，$\\sigma$ 是 Cauchy 应力张量，$\\lambda$ 和 $\\mu$ 是 Lamé 参数，$\\nabla^s u = \\frac{1}{2}(\\nabla u + (\\nabla u)^T)$ 是对称梯度（工程应变张量），$I$ 是单位张量。\n\n将平衡方程与一个向量值测试函数 $v$（来自一个合适的函数空间，其中 $v$ 在 Dirichlet 边界上为 0）相乘，并在 $\\Omega$ 上积分，即可推导出弱形式。应用分部积分（Green 恒等式）并代入本构关系，得到双线性形式 $a(u,v)$ 和线性形式 $L(v)$：\n$$a(u,v) = \\int_{\\Omega} \\sigma(u) : \\nabla^s v \\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\left( 2\\mu\\,\\nabla^s u : \\nabla^s v + \\lambda\\,(\\nabla \\cdot u)(\\nabla \\cdot v) \\right) \\mathrm{d}\\Omega$$\n$$L(v) = \\int_{\\Omega} f \\cdot v \\, \\mathrm{d}\\Omega$$\n任务是找到满足 Dirichlet 边界条件的试探函数 $u$，使得对于所有容许的测试函数 $v$，都有 $a(u,v) = L(v)$。双线性形式 $a(u,v)$ 自然地分解为一个偏量部分（与恒定体积下的形状变化相关）和一个体积部分（与体积变化相关）：\n$$a_{dev}(u,v) = \\int_{\\Omega} 2\\mu\\,\\nabla^s u : \\nabla^s v \\,\\mathrm{d}\\Omega$$\n$$a_{vol}(u,v) = \\int_{\\Omega} \\lambda\\,(\\nabla \\cdot u)(\\nabla \\cdot v)\\,\\mathrm{d}\\Omega$$\n\n### 2. 体力推导\n一个构造解 $u_{\\text{exact}}(x,y) = [\\sin(\\pi x)\\sin(\\pi y), \\sin(\\pi x)\\sin(\\pi y)]^T$ 用于验证。通过将 $u_{\\text{exact}}$ 代入平衡方程的强形式 $f = -\\nabla \\cdot \\sigma(u_{\\text{exact}})$，可以推导出相应的体力 $f$。\n\n首先，我们计算 $u_{\\text{exact}}$ 的梯度和散度：\n$$\\nabla u_{\\text{exact}} = \\pi \\begin{bmatrix} \\cos(\\pi x)\\sin(\\pi y) & \\sin(\\pi x)\\cos(\\pi y) \\\\ \\cos(\\pi x)\\sin(\\pi y) & \\sin(\\pi x)\\cos(\\pi y) \\end{bmatrix}$$\n$$\\nabla \\cdot u_{\\text{exact}} = \\pi\\cos(\\pi x)\\sin(\\pi y) + \\pi\\sin(\\pi x)\\cos(\\pi y) = \\pi\\sin(\\pi(x+y))$$\n于是应力张量的分量为：\n$$\\sigma_{11} = (\\lambda+2\\mu)\\frac{\\partial u_1}{\\partial x} + \\lambda\\frac{\\partial u_2}{\\partial y} = (\\lambda+2\\mu)\\pi\\cos(\\pi x)\\sin(\\pi y) + \\lambda\\pi\\sin(\\pi x)\\cos(\\pi y)$$\n不对，问题陈述为 $\\sigma = 2\\mu\\,\\nabla^s u + \\lambda\\,(\\nabla \\cdot u)\\,I$。这个定义略有不同。使用给定形式重新推导：\n$$ \\sigma_{11} = 2\\mu (\\nabla^s u)_{11} + \\lambda (\\nabla \\cdot u) = 2\\mu \\frac{\\partial u_1}{\\partial x} + \\lambda (\\nabla \\cdot u) = 2\\mu\\pi\\cos(\\pi x)\\sin(\\pi y) + \\lambda\\pi\\sin(\\pi(x+y)) $$\n$$ \\sigma_{22} = 2\\mu (\\nabla^s u)_{22} + \\lambda (\\nabla \\cdot u) = 2\\mu \\frac{\\partial u_2}{\\partial y} + \\lambda (\\nabla \\cdot u) = 2\\mu\\pi\\sin(\\pi x)\\cos(\\pi y) + \\lambda\\pi\\sin(\\pi(x+y)) $$\n$$ \\sigma_{12} = 2\\mu (\\nabla^s u)_{12} = \\mu \\left( \\frac{\\partial u_1}{\\partial y} + \\frac{\\partial u_2}{\\partial x} \\right) = \\mu\\pi(\\sin(\\pi x)\\cos(\\pi y) + \\cos(\\pi x)\\sin(\\pi y)) = \\mu\\pi\\sin(\\pi(x+y))$$\n最后，取应力张量 $\\sigma$ 的负散度：\n$$f_1 = -(\\frac{\\partial\\sigma_{11}}{\\partial x} + \\frac{\\partial\\sigma_{12}}{\\partial y}) = 2\\mu\\pi^2\\sin(\\pi x)\\sin(\\pi y) - (\\lambda+\\mu)\\pi^2\\cos(\\pi(x+y))$$\n$$f_2 = -(\\frac{\\partial\\sigma_{21}}{\\partial x} + \\frac{\\partial\\sigma_{22}}{\\partial y}) = 2\\mu\\pi^2\\sin(\\pi x)\\sin(\\pi y) - (\\lambda+\\mu)\\pi^2\\cos(\\pi(x+y))$$\n体力为 $f = [f_1, f_2]^T$。\n\n### 3. 有限元离散化\n区域 $\\Omega$ 被离散化为 $N_x \\times N_y$ 个双线性四边形 ($Q_1$) 单元的结构化网格。在每个单元内，位移场被近似为 $u_h(x,y) = \\sum_{a=1}^{4} N_a(\\xi,\\eta) d_a$，其中 $d_a$ 是节点 $a$ 的节点位移向量，$N_a$ 是参考正方形 $[-1,1] \\times [-1,1]$ 上的双线性形函数。\n\n离散方程组为 $Kd=F$，其中 $K$ 是全局刚度矩阵，$F$ 是全局力向量，$d$ 是所有节点位移的向量。单元刚度矩阵 $K^e$ 和力向量 $F^e$ 是通过在单元域 $\\Omega_e$ 上进行数值积分（Gaussian 求积）来计算的：\n$$K^e_{ij} = a(v_j, v_i)|_{\\Omega_e}, \\quad F^e_i = L(v_i)|_{\\Omega_e}$$\n其中 $v_i$ 是与单元自由度相关的基函数。使用应变的 Voigt 记法 $\\varepsilon = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$，单元刚度矩阵可以写为 $K^e = \\int_{\\Omega_e} B^T D B \\, \\mathrm{d}\\Omega$，其中 $B$ 是标准的应变-位移矩阵，$D$ 是平面应变的本构矩阵。\n\n这个问题的关键在于 $K^e$ 的积分方案。刚度矩阵被加性分解为 $K^e = K^e_{dev} + K^e_{vol}$，对应于弱形式的偏量部分和体积部分。\n- $K^e_{dev}$ 来自 $a_{dev}(u,v)$，并使用 $2\\mu \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1/2 \\end{pmatrix}$ 作为本构矩阵的偏量部分进行积分。\n- $K^e_{vol}$ 来自 $a_{vol}(u,v)$，并从 $\\lambda \\begin{pmatrix} 1 & 1 & 0 \\\\ 1 & 1 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}$ 作为体积部分进行积分。\n\n实现了两种积分方案：\n1.  **完全积分**：$K^e_{dev}$ 和 $K^e_{vol}$ 都是通过在参考单元上使用 $2 \\times 2$ Gaussian 求积法则对其各自的被积函数进行数值积分来计算的。\n2.  **选择性积分**：$K^e_{dev}$ 使用 $2 \\times 2$ Gaussian 求积法计算，但 $K^e_{vol}$ 在单元中心 $(\\xi=0, \\eta=0)$ 使用单点 ($1 \\times 1$) Gaussian 求积法计算。对体积项的这种欠积分是缓解近不可压缩材料（$\\lambda \\gg \\mu$）中体积闭锁的标准技术。\n\n在所有情况下，载荷向量 $F$ 都是使用 $2 \\times 2$ Gaussian 求积法组装的。\n\n### 4. 系统求解和误差计算\n对边界 $\\partial\\Omega$ 上的所有节点施加 Dirichlet 边界条件 $u_h = u_{\\text{exact}}$。全局系统 $Kd=F$ 被划分为内部自由度和边界自由度。修改该系统以求解未知的内部位移，之后再重建完整的解向量。\n\n获得两种积分方案的数值解 $u_h$ 后，使用 $2 \\times 2$ Gaussian 求积法计算以下误差：\n-   位移 $L^2$-范数误差：$E_u = \\left( \\sum_e \\int_{\\Omega_e} \\|u_h - u_{\\text{exact}}\\|^2 \\,\\mathrm{d}\\Omega \\right)^{1/2}$\n-   体积 $L^2$-范数误差：$E_{\\nabla\\cdot u} = \\left( \\sum_e \\int_{\\Omega_e} \\left( \\nabla \\cdot u_h - \\nabla \\cdot u_{\\text{exact}} \\right)^2 \\,\\mathrm{d}\\Omega \\right)^{1/2}$\n\n最后，计算闭锁缓解因子 $R_{\\text{lock}} = E_u^{\\text{full}} / E_u^{\\text{sel}}$ 和体积误差因子 $R_{\\text{vol}} = E_{\\nabla\\cdot u}^{\\text{sel}} / E_{\\nabla\\cdot u}^{\\text{full}}$ 以量化选择性积分的性能。",
            "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Main function to solve the specified FEM problem for all test cases.\n    \"\"\"\n    # Test cases: (Nx, Ny, lambda, mu)\n    test_cases = [\n        (8, 8, 1.0, 1.0),\n        (8, 8, 1e3, 1.0),\n        (8, 8, 1e6, 1.0),\n        (4, 4, 1e6, 1.0)\n    ]\n\n    # Gauss quadrature points and weights\n    # 2x2 Gauss quadrature\n    gp_2x2_coords = np.array([-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)])\n    gp_2x2_weights = np.array([1.0, 1.0])\n\n    # 1-point Gauss quadrature (at center)\n    gp_1x1_coords = np.array([0.0])\n    gp_1x1_weights = np.array([2.0])\n\n    def shape_functions_quad4(xi, eta):\n        \"\"\"\n        Computes shape functions and their derivatives for a 4-node quad element.\n        N: shape function values (4,)\n        dNdxi_eta: derivatives w.r.t. xi, eta (2, 4)\n        \"\"\"\n        N = 0.25 * np.array([\n            (1.0 - xi) * (1.0 - eta),\n            (1.0 + xi) * (1.0 - eta),\n            (1.0 + xi) * (1.0 + eta),\n            (1.0 - xi) * (1.0 + eta)\n        ])\n        \n        dNdxi_eta = 0.25 * np.array([\n            [-(1.0 - eta), (1.0 - eta), (1.0 + eta), -(1.0 + eta)],  # d/dxi\n            [-(1.0 - xi), -(1.0 + xi), (1.0 + xi), (1.0 - xi)]   # d/deta\n        ])\n        \n        return N, dNdxi_eta\n\n    def get_b_matrix_and_jacobian_det(dNdxi_eta, el_nodes_coords):\n        \"\"\"\n        Computes the Jacobian, its determinant, and the B matrix.\n        \"\"\"\n        J = dNdxi_eta @ el_nodes_coords # Jacobian matrix (2, 2)\n        detJ = np.linalg.det(J)\n        \n        if detJ = 0.0:\n            raise ValueError(\"Jacobian determinant is non-positive.\")\n        \n        J_inv = np.linalg.inv(J)\n        dNdx_dy = J_inv @ dNdxi_eta # (2, 4)\n        \n        B = np.zeros((3, 8))\n        for i in range(4):\n            B[0, 2*i] = dNdx_dy[0, i]\n            B[1, 2*i+1] = dNdx_dy[1, i]\n            B[2, 2*i] = dNdx_dy[1, i]\n            B[2, 2*i+1] = dNdx_dy[0, i]\n            \n        return B, detJ\n\n    def u_exact(x, y):\n        val = np.sin(np.pi * x) * np.sin(np.pi * y)\n        return np.array([val, val])\n\n    def div_u_exact(x, y):\n        return np.pi * np.sin(np.pi * (x + y))\n\n    def body_force(x, y, lam, mu):\n        pi2 = np.pi**2\n        sxy = np.sin(np.pi * x) * np.sin(np.pi * y)\n        cxy_sum = np.cos(np.pi * (x + y))\n        f_val = 2.0 * mu * pi2 * sxy - (lam + mu) * pi2 * cxy_sum\n        return np.array([f_val, f_val])\n\n    def run_fem_analysis(Nx, Ny, lam, mu):\n        # 1. Mesh Generation\n        num_nodes_x = Nx + 1\n        num_nodes_y = Ny + 1\n        num_nodes = num_nodes_x * num_nodes_y\n        num_elements = Nx * Ny\n        \n        x_coords = np.linspace(0.0, 1.0, num_nodes_x)\n        y_coords = np.linspace(0.0, 1.0, num_nodes_y)\n        \n        nodes = np.array([[x, y] for y in y_coords for x in x_coords])\n        \n        elements = np.zeros((num_elements, 4), dtype=int)\n        for ey in range(Ny):\n            for ex in range(Nx):\n                el_idx = ey * Nx + ex\n                n1 = ey * num_nodes_x + ex             # Bottom-left\n                n2 = ey * num_nodes_x + (ex + 1)       # Bottom-right\n                n3 = (ey + 1) * num_nodes_x + (ex + 1) # Top-right\n                n4 = (ey + 1) * num_nodes_x + ex       # Top-left\n                elements[el_idx] = [n1, n2, n3, n4]\n                \n        # 2. Constitutive Matrices (for integration)\n        D_vol = lam * np.array([[1.0, 1.0, 0.0], [1.0, 1.0, 0.0], [0.0, 0.0, 0.0]])\n        D_dev = 2.0 * mu * np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 0.5]])\n        \n        # 3. Assembly\n        num_dofs = 2 * num_nodes\n        K_full = np.zeros((num_dofs, num_dofs))\n        K_sel = np.zeros((num_dofs, num_dofs))\n        F = np.zeros(num_dofs)\n        \n        for el_idx in range(num_elements):\n            el_node_indices = elements[el_idx]\n            el_nodes_coords = nodes[el_node_indices]\n            dofs = np.ravel([[2*n, 2*n+1] for n in el_node_indices])\n            \n            Ke_dev = np.zeros((8, 8))\n            Ke_vol_full = np.zeros((8, 8))\n            \n            # 2x2 Quadrature for dev, vol_full and Force\n            for w_eta, eta in zip(gp_2x2_weights, gp_2x2_coords):\n                for w_xi, xi in zip(gp_2x2_weights, gp_2x2_coords):\n                    N, dNdxi_eta = shape_functions_quad4(xi, eta)\n                    B, detJ = get_b_matrix_and_jacobian_det(dNdxi_eta, el_nodes_coords)\n                    weight = w_xi * w_eta * detJ\n                    \n                    Ke_dev += B.T @ D_dev @ B * weight\n                    Ke_vol_full += B.T @ D_vol @ B * weight\n                    \n                    x_gp, y_gp = N @ el_nodes_coords\n                    f_gp = body_force(x_gp, y_gp, lam, mu)\n                    for i in range(4):\n                        F[dofs[2*i]]   += N[i] * f_gp[0] * weight\n                        F[dofs[2*i+1]] += N[i] * f_gp[1] * weight\n            \n            # 1-point Quadrature for vol_sel\n            xi_c, eta_c = gp_1x1_coords[0], gp_1x1_coords[0]\n            w_c = gp_1x1_weights[0] * gp_1x1_weights[0]\n            N_c, dNdxi_eta_c = shape_functions_quad4(xi_c, eta_c)\n            B_c, detJ_c = get_b_matrix_and_jacobian_det(dNdxi_eta_c, el_nodes_coords)\n            Ke_vol_sel = B_c.T @ D_vol @ B_c * (w_c * detJ_c)\n            \n            ix = np.ix_(dofs, dofs)\n            K_full[ix] += Ke_dev + Ke_vol_full\n            K_sel[ix] += Ke_dev + Ke_vol_sel\n\n        # 4. Boundary Conditions\n        b_nodes = set(np.concatenate([\n            np.arange(num_nodes_x), # Bottom\n            np.arange(num_nodes - num_nodes_x, num_nodes), # Top\n            np.arange(0, num_nodes, num_nodes_x), # Left\n            np.arange(num_nodes_x - 1, num_nodes, num_nodes_x) # Right\n        ]))\n        \n        boundary_dofs = np.ravel([[2*n, 2*n+1] for n in sorted(list(b_nodes))])\n        interior_dofs = np.setdiff1d(np.arange(num_dofs), boundary_dofs)\n        \n        d_B = np.array([u_exact(nodes[dof//2, 0], nodes[dof//2, 1])[dof%2] for dof in boundary_dofs])\n        \n        def solve_system(K):\n            K_II = K[np.ix_(interior_dofs, interior_dofs)]\n            K_IB = K[np.ix_(interior_dofs, boundary_dofs)]\n            F_I = F[interior_dofs]\n            F_mod = F_I - K_IB @ d_B\n            d_I = scipy.linalg.solve(K_II, F_mod, assume_a='sym')\n            d = np.zeros(num_dofs)\n            d[interior_dofs] = d_I\n            d[boundary_dofs] = d_B\n            return d\n\n        d_full = solve_system(K_full)\n        d_sel = solve_system(K_sel)\n\n        # 5. Error Calculation\n        def calculate_errors(d_sol):\n            err_u_sq, err_div_u_sq = 0.0, 0.0\n            for el_idx in range(num_elements):\n                el_node_indices, el_nodes_coords = elements[el_idx], nodes[elements[el_idx]]\n                d_elem = d_sol[np.ravel([[2*n, 2*n+1] for n in el_node_indices])]\n                \n                for w_eta, eta in zip(gp_2x2_weights, gp_2x2_coords):\n                    for w_xi, xi in zip(gp_2x2_weights, gp_2x2_coords):\n                        N, dNdxi_eta = shape_functions_quad4(xi, eta)\n                        B, detJ = get_b_matrix_and_jacobian_det(dNdxi_eta, el_nodes_coords)\n                        weight = w_xi * w_eta * detJ\n                        \n                        x_gp, y_gp = N @ el_nodes_coords\n                        u_h_gp = np.array([N @ d_elem[0::2], N @ d_elem[1::2]])\n                        err_u_sq += np.sum((u_h_gp - u_exact(x_gp, y_gp))**2) * weight\n                        \n                        strain_h_gp = B @ d_elem\n                        err_div_u_sq += (strain_h_gp[0] + strain_h_gp[1] - div_u_exact(x_gp, y_gp))**2 * weight\n            return np.sqrt(err_u_sq), np.sqrt(err_div_u_sq)\n\n        Eu_full, Edivu_full = calculate_errors(d_full)\n        Eu_sel, Edivu_sel = calculate_errors(d_sel)\n        \n        R_lock = Eu_full / Eu_sel if Eu_sel > 1e-15 else 0.0\n        R_vol = Edivu_sel / Edivu_full if Edivu_full > 1e-15 else 0.0\n        \n        return [Eu_full, Eu_sel, R_lock, Edivu_full, Edivu_sel, R_vol]\n\n    all_results = [run_fem_analysis(*case) for case in test_cases]\n    \n    # Format the final output string\n    result_str = \"[\" + \", \".join([str(res) for res in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这项实践将探讨一种更彻底的减积分形式及其必要的补救措施。你将为一个双线性四边形单元实现一种对所有项都使用单点求积的方案，这种方案计算效率高，但易产生虚假的零能“沙漏”模式。本练习的核心是实现并验证经典的 Flanagan–Belytschko 沙漏控制方法，该技术旨在稳定单元，同时确保其仍然通过针对恒应变状态的基本检验——“单元检验” (patch test) 。",
            "id": "3439243",
            "problem": "你需要为小应变线弹性中的欠积分双线性四边形单元实现并通过 Flanagan–Belytschko 沙漏控制进行稳定性验证。其基本基础是小应变平衡方程和标准的等参双线性四边形有限元列式。控制方程是在平面应力条件下，对于无体力、准静态、杨氏模量为 $E$、泊松比为 $\\nu$ 的均质各向同性材料的线动量平衡方程。小应变张量为 $\\boldsymbol{\\varepsilon} = \\nabla^{s} \\mathbf{u}$，本构关系为 $\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}$，其中 $\\mathbf{D}$ 是平面应力弹性张量。在单点（减缩）高斯积分下，双线性四边形（$Q4$）单元的单元刚度可能会出现称为沙漏模式的伪零能模式。Flanagan–Belytschko 沙漏控制通过增强单元刚度来惩罚这些模式，同时保持在常应变场下的精确性能。\n\n你的程序必须：\n- 为一个 $Q4$ 单元在单元中心使用单个高斯点，构造单元级的减缩积分刚度矩阵 $K_e^{\\mathrm{RI}}$。设标准双线性形函数为 $N_i(\\xi,\\eta)$，并使用在中心的雅可比矩阵 $\\mathbf{J}$ 的等参映射，计算在 $(\\xi,\\eta)=(0,0)$ 处的应变-位移矩阵 $\\mathbf{B}$。取积分权重 $w=4$（自然坐标中正方形的面积）和厚度 $t$。平面应力弹性矩阵为\n$$\n\\mathbf{D} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1  \\nu  0\\\\\n\\nu  1  0\\\\\n0  0  \\frac{1-\\nu}{2}\n\\end{bmatrix}.\n$$\n则\n$$\nK_e^{\\mathrm{RI}} = t\\,w\\,\\det(\\mathbf{J}) \\,\\mathbf{B}^\\top \\mathbf{D}\\,\\mathbf{B}.\n$$\n- 实现一个能够消除线性位移场的 Flanagan–Belytschko 沙漏控制项 $K_e^{\\mathrm{HG}}$。设节点位移向量为 $d_e \\in \\mathbb{R}^{8}$，按 $(u_1,v_1,u_2,v_2,u_3,v_3,u_4,v_4)^\\top$ 顺序排列，其中 $(u_i,v_i)$ 是节点 $i$ 的位移。定义由六个基向量张成的线性场子空间，这六个基向量对应于位移场 $u=a+b\\,x+c\\,y$ 和 $v=d+e\\,x+f\\,y$（其中 $a,b,c,d,e,f$ 为标量系数），即 $u$-平移、$v$-平移、$u=x$、$u=y$、$v=x$、$v=y$。构成该子空间的正交基矩阵 $\\mathbf{Q}_\\ell \\in \\mathbb{R}^{8\\times 6}$，并定义沙漏投影算子\n$$\n\\mathbf{P}_{\\mathrm{hg}} = \\mathbf{I}_{8} - \\mathbf{Q}_\\ell \\mathbf{Q}_\\ell^\\top.\n$$\n将沙漏刚度设置为\n$$\nK_e^{\\mathrm{HG}} = \\alpha\\,\\mathbf{P}_{\\mathrm{hg}},\n$$\n其稳定化尺度为\n$$\n\\alpha = c_{\\mathrm{hg}}\\,\\mu\\,t\\,\\frac{A}{L_c},\n$$\n其中 $c_{\\mathrm{hg}}$ 是一个无量纲控制系数，$\\mu = \\frac{E}{2(1+\\nu)}$ 是剪切模量， $A = w\\,\\det(\\mathbf{J})$ 是单元面积，而 $L_c$ 是一个特征长度，取为物理四边形的平均边长。稳定化后的单元刚度为\n$$\nK_e = K_e^{\\mathrm{RI}} + K_e^{\\mathrm{HG}}.\n$$\n- 在减缩积分下，通过数值证明稳定化单元通过了分片检验：对于任意线性位移场参数 $(a,b,c,d,e,f)$，附加的沙漏控制不对应内力产生贡献，且在高斯点计算出的应变等于精确的常应变。具体来说，对每个测试用例，使用单元节点坐标 $(x_i,y_i)$ 从指定的线性场构造 $d_e$：\n$$\nu_i = a + b\\,x_i + c\\,y_i,\\quad v_i = d + e\\,x_i + f\\,y_i,\n$$\n并验证以下两个条件\n$$\n\\text{(i)}\\quad d_e^\\top K_e^{\\mathrm{HG}}\\,d_e = 0 \\quad\\text{（在数值容差范围内）},\\qquad\n\\text{(ii)}\\quad \\mathbf{B}\\,d_e = \\begin{bmatrix} b \\\\ f \\\\ c+e \\end{bmatrix} \\quad\\text{（在数值容差范围内）}.\n$$\n稳定化单元必须同时满足这两个条件才能通过分片检验。\n\n物理单位：几何形状和厚度使用米（m），材料刚度使用帕斯卡（Pa）。应变为无量纲。以无单位的浮点数报告数值容差和误差。\n\n角度单位：不适用。\n\n测试套件：\n提供三个测试用例，每个用例指定单元节点坐标（单位：米）、材料参数（单位：帕斯卡）、厚度（单位：米）、沙漏系数 $c_{\\mathrm{hg}}$ 以及线性位移参数 $(a,b,c,d,e,f)$：\n\n- 用例1（正常情况，规则单元）：节点 $(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$；$E=1000$, $\\nu=0.3$, $t=1$, $c_{\\mathrm{hg}}=0.1$；线性场 $(a,b,c,d,e,f)=(0,0.01,0,0,0,0)$，预期 $\\boldsymbol{\\varepsilon}=[0.01,0,0]^\\top$。\n\n- 用例2（畸变单元，倾斜几何）：节点 $(0,0)$, $(1.2,-0.1)$, $(1.1,1.05)$, $(-0.05,1.1)$；$E=1000$, $\\nu=0.3$, $t=1$, $c_{\\mathrm{hg}}=0.1$；线性场 $(a,b,c,d,e,f)=(0,0.01,0,0,0,0)$，预期 $\\boldsymbol{\\varepsilon}=[0.01,0,0]^\\top$。\n\n- 用例3（边界情况，高纵横比和纯剪切）：节点 $(0,0)$, $(2,0)$, $(2,0.5)$, $(0,0.5)$；$E=1000$, $\\nu=0.3$, $t=1$, $c_{\\mathrm{hg}}=0.1$；线性场 $(a,b,c,d,e,f)=(0,0,0.01,0,0.01,0)$，预期 $\\boldsymbol{\\varepsilon}=[0,0,0.02]^\\top$。\n\n容差规定：\n- 设能量容差为 $\\tau_E = 10^{-12}\\,\\alpha$，若 $|d_e^\\top K_e^{\\mathrm{HG}}\\,d_e| \\le \\tau_E$ 则条件 (i) 成立。\n- 设应变容差为 $\\tau_\\varepsilon = 10^{-12}$，若应变差的欧几里得范数 $\\le \\tau_\\varepsilon$ 则条件 (ii) 成立。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个条目都是一个布尔值，表示相应测试用例是否同时满足条件 (i) 和 (ii)（例如，“[True,False,True]”）。",
            "solution": "用户要求为在减缩单点积分下的双线性四边形单元（$Q4$）实现 Flanagan–Belytschko 沙漏控制方案，并进行数值验证。验证将通过分片检验（patch test）进行，这是有限元分析中的一个基本准则，它确保单元能够精确地再现常应变状态。一个导致常应变场的线性位移场必须被精确表示。\n\n问题的核心在于对任何施加的线性位移场证明两个性质：\n1.  沙漏稳定项不能产生任何伪力。这意味着沙漏对内力向量的贡献，进而对虚功的贡献，必须为零。\n2.  在单元的单个积分点（中心）计算出的应变必须与所施加的线性位移场对应的常应变完全匹配。\n\n我们将系统地构造所需的矩阵和向量，然后对指定的测试用例进行验证。所有数学实体都按要求使用 LaTeX 渲染。\n\n**1. 双线性四边形（$Q4$）的单元列式**\n\n一个 $Q4$ 单元的几何形状通过等参映射从自然坐标 $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$ 中的正方形母单元映射到物理坐标 $(x, y)$：\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i \\quad , \\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\n其中 $(x_i, y_i)$ 是第 $i$ 个节点的坐标，$N_i$ 是双线性形函数：\n$$\n\\begin{aligned}\nN_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta) \\\\\nN_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta) \\\\\nN_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta) \\\\\nN_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n\\end{aligned}\n$$\n同样的形函数用于从节点位移 $(u_i, v_i)$ 插值位移场 $(u, v)$。\n\n物理坐标和自然坐标中导数之间的关系由雅可比矩阵 $\\mathbf{J}$ 给出：\n$$\n\\begin{Bmatrix} \\frac{\\partial}{\\partial \\xi} \\\\ \\frac{\\partial}{\\partial \\eta} \\end{Bmatrix} = \\mathbf{J} \\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix} \\quad \\text{其中} \\quad \\mathbf{J} = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta}  \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix}\n$$\n对于单点积分方案，所有单元级量都在中心点 $(\\xi, \\eta) = (0, 0)$ 处求值。在该点，雅可比矩阵为：\n$$\n\\mathbf{J}|_{(0,0)} = \\sum_{i=1}^{4} \\begin{bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{bmatrix} [x_i, y_i] \\Bigg|_{(\\xi, \\eta)=(0,0)} = \\frac{1}{4} \\begin{bmatrix} -x_1+x_2+x_3-x_4  -y_1+y_2+y_3-y_4 \\\\ -x_1-x_2+x_3+x_4  -y_1-y_2+y_3+y_4 \\end{bmatrix}\n$$\n\n应变-位移矩阵 $\\mathbf{B}$ 将应变向量 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\top$ 与单元节点位移向量 $d_e = [u_1, v_1, \\dots, u_4, v_4]^\\top$ 关联起来，即 $\\boldsymbol{\\varepsilon} = \\mathbf{B} d_e$。矩阵 $\\mathbf{B}$ 由形函数的物理导数构造而成：\n$$\n\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4] \\quad \\text{其中} \\quad \\mathbf{B}_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x}  0 \\\\ 0  \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y}  \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}\n$$\n物理导数通过雅可比矩阵的逆获得： $\\begin{Bmatrix} \\partial N_i/\\partial x \\\\ \\partial N_i/\\partial y \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\partial N_i/\\partial \\xi \\\\ \\partial N_i/\\partial \\eta \\end{Bmatrix}$。\n\n**2. Flanagan–Belytschko 沙漏控制**\n\n单点积分的刚度矩阵 $K_e^{\\mathrm{RI}} = t\\,w\\,\\det(\\mathbf{J}) \\,\\mathbf{B}^\\top \\mathbf{D}\\,\\mathbf{B}$（其中 $w=4$）是秩亏的，并会产生非物理的零能模式，即所谓的沙漏模式。Flanagan–Belytschko 方法增加了一个稳定刚度 $K_e^{\\mathrm{HG}}$ 来惩罚这些模式。\n\n其关键思想是将任何位移场投影到“沙漏子空间”上，该子空间是线性位移场子空间的正交补空间。任何物理上有意义的常应变变形都不应受到惩罚。形式为 $u=a+b\\,x+c\\,y$ 和 $v=d+e\\,x+f\\,y$ 的线性位移场必须产生零沙漏抗力。\n\n线性位移场子空间由在节点上定义的六个基向量张成：\n1.  $u=1, v=0$（$x$ 方向的刚体平移）\n2.  $u=0, v=1$（$y$ 方向的刚体平移）\n3.  $u=x, v=0$（常应变 $\\varepsilon_{xx}$）\n4.  $u=y, v=0$（常应变 $\\gamma_{xy}$ 和刚体旋转）\n5.  $u=0, v=x$（常应变 $\\gamma_{xy}$ 和刚体旋转）\n6.  $u=0, v=y$（常应变 $\\varepsilon_{yy}$）\n\n这六个由单元节点坐标 $(x_i, y_i)$ 构成的节点位移向量，组成了矩阵 $\\mathbf{L} \\in \\mathbb{R}^{8 \\times 6}$ 的列。例如，通过 QR 分解可以得到 $\\mathbf{L}$ 的列空间的一个正交基 $\\mathbf{Q}_\\ell \\in \\mathbb{R}^{8 \\times 6}$。\n\n沙漏投影算子 $\\mathbf{P}_{\\mathrm{hg}}$ 将一个位移向量映射到沙漏子空间，该子空间与线性场子空间正交：\n$$\n\\mathbf{P}_{\\mathrm{hg}} = \\mathbf{I}_{8} - \\mathbf{Q}_\\ell \\mathbf{Q}_\\ell^\\top\n$$\n其中 $\\mathbf{I}_{8}$ 是 $8 \\times 8$ 的单位矩阵。根据构造，如果 $d_e$ 表示一个线性位移场，它就位于 $\\mathbf{Q}_\\ell$ 的列空间中，因此 $\\mathbf{P}_{\\mathrm{hg}} d_e = \\mathbf{0}$。\n\n沙漏刚度矩阵则定义为：\n$$\nK_e^{\\mathrm{HG}} = \\alpha\\,\\mathbf{P}_{\\mathrm{hg}}\n$$\n其中 $\\alpha$ 是一个缩放惩罚的稳定化参数。问题将该尺度指定为：\n$$\n\\alpha = c_{\\mathrm{hg}}\\,\\mu\\,t\\,\\frac{A}{L_c}\n$$\n在这里，$c_{\\mathrm{hg}}$ 是用户定义的系数，$\\mu = \\frac{E}{2(1+\\nu)}$ 是剪切模量，$t$ 是单元厚度，$A = w\\,\\det(\\mathbf{J}) = 4\\,\\det(\\mathbf{J})$ 是由单点积分计算的单元面积，而 $L_c$ 是一个特征长度，取为四个边长的平均值。\n\n**3. 分片检验验证**\n\n分片检验验证了稳定化方案是一致的。对于从任何线性场导出的节点位移向量 $d_e$，必须满足两个条件。\n\n**条件 (i)：零沙漏能**\n一个线性位移向量 $d_e$ 必须产生零沙漏力。这等同于证明其相关能量为零。由于 $K_e^{\\mathrm{HG}}$ 是半正定的，我们验证：\n$$\nd_e^\\top K_e^{\\mathrm{HG}}\\,d_e = \\alpha \\, d_e^\\top \\mathbf{P}_{\\mathrm{hg}} d_e = 0\n$$\n如上所述，这在数值精度范围内必须成立，因为 $d_e$ 位于 $\\mathbf{P}_{\\mathrm{hg}}$ 的零空间中。我们检查是否有 $|d_e^\\top K_e^{\\mathrm{HG}}\\,d_e| \\le \\tau_E$，其中 $\\tau_E = 10^{-12}\\,\\alpha$。\n\n**条件 (ii)：精确的应变表示**\n对于一个线性位移场 $u(\\text{x,y}) = a+bx+cy$ 和 $v(\\text{x,y}) = d+ex+fy$，产生的应变场是恒定的：\n$$\n\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x} = b, \\quad \\varepsilon_{yy} = \\frac{\\partial v}{\\partial y} = f, \\quad \\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x} = c+e\n$$\n分片检验的第二个条件验证了使用 B 矩阵在特殊积分点 $(\\xi, \\eta)=(0,0)$ 计算出的应变与这个理论常应变完全匹配：\n$$\n\\mathbf{B}\\,d_e = \\begin{bmatrix} b \\\\ f \\\\ c+e \\end{bmatrix}\n$$\n这是双线性单元中心高斯点的一个众所周知的特性。我们检查计算出的应变向量与精确应变向量之差的欧几里得范数是否低于容差 $\\tau_\\varepsilon = 10^{-12}$。\n\n**实现策略**\n程序将遍历每个测试用例。对于每个用例，它将：\n1.  定义单元几何形状以及材料/控制参数。\n2.  在 $(\\xi,\\eta)=(0,0)$ 处计算雅可比矩阵 $\\mathbf{J}$ 和应变-位移矩阵 $\\mathbf{B}$。\n3.  构造线性位移模式矩阵 $\\mathbf{L}$ 并找到其正交基 $\\mathbf{Q}_\\ell$。\n4.  计算稳定化参数 $\\alpha$ 和沙漏刚度 $K_e^{\\mathrm{HG}} = \\alpha(\\mathbf{I}_{8} - \\mathbf{Q}_\\ell \\mathbf{Q}_\\ell^\\top)$。\n5.  生成与指定线性场对应的节点位移向量 $d_e$。\n6.  根据各自的容差对条件 (i) 和 (ii) 进行数值验证。\n7.  返回一个布尔值，指示是否两个条件都得到满足。\n所有测试用例的结果将被收集并格式化为所需的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import orth\n\ndef verify_patch_test(nodes, E, nu, t, chg, field_params):\n    \"\"\"\n    Performs the patch test for a single Q4 element with hourglass control.\n\n    Args:\n        nodes (np.ndarray): 4x2 array of nodal coordinates (x, y).\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        t (float): Element thickness.\n        chg (float): Hourglass control coefficient.\n        field_params (tuple): Parameters (a,b,c,d,e,f) for the linear displacement field.\n\n    Returns:\n        bool: True if both patch test conditions are met, False otherwise.\n    \"\"\"\n    # 1. Element Formulation (at center xi=0, eta=0)\n    # Derivatives of shape functions w.r.t. natural coordinates at center\n    GN_nat = 0.25 * np.array([[-1., -1.], [1., -1.], [1., 1.], [-1., 1.]])\n    \n    # Jacobian matrix (Note: problem statement uses J_ij = d(x_i)/d(xi_j), this code uses J_ij = d(x_j)/d(xi_i))\n    # Let's stick to a common convention where J_ij = dx_i / d_xi_j\n    J = nodes.T @ GN_nat\n    det_J = np.linalg.det(J)\n    \n    # Check for degenerate element\n    if np.abs(det_J)  1e-15:\n        return False\n        \n    J_inv = np.linalg.inv(J)\n    \n    # Derivatives of shape functions w.r.t. physical coordinates\n    GN_phys = GN_nat @ J_inv.T\n    \n    # Strain-displacement matrix (B-matrix)\n    B = np.zeros((3, 8))\n    for i in range(4):\n        # GN_phys[i, 0] is dN_i/dx, GN_phys[i, 1] is dN_i/dy\n        B[0, 2 * i] = GN_phys[i, 0]\n        B[1, 2 * i + 1] = GN_phys[i, 1]\n        B[2, 2 * i] = GN_phys[i, 1]\n        B[2, 2 * i + 1] = GN_phys[i, 0]\n\n    # 2. Flanagan-Belytschko Hourglass Control\n    # 2.1. Basis for the linear displacement subspace (L)\n    L = np.zeros((8, 6))\n    x_coords = nodes[:, 0]\n    y_coords = nodes[:, 1]\n    \n    L[:, 0] = np.tile([1, 0], 4)      # u=1, v=0 (u-translation)\n    L[:, 1] = np.tile([0, 1], 4)      # u=0, v=1 (v-translation)\n    L[0::2, 2] = x_coords             # u=x, v=0\n    L[0::2, 3] = y_coords             # u=y, v=0\n    L[1::2, 4] = x_coords             # u=0, v=x\n    L[1::2, 5] = y_coords             # u=0, v=y\n    \n    # 2.2. Orthonormal basis Ql\n    Ql = orth(L)\n    \n    # 2.3. Hourglass projector Phg\n    Phg = np.eye(8) - Ql @ Ql.T\n    \n    # 2.4. Stabilization scale alpha\n    mu = E / (2. * (1. + nu))\n    A = 4. * det_J # Area from 1-point quadrature\n    \n    # Characteristic length Lc (average edge length)\n    p1, p2, p3, p4 = nodes\n    l1 = np.linalg.norm(p2 - p1)\n    l2 = np.linalg.norm(p3 - p2)\n    l3 = np.linalg.norm(p4 - p3)\n    l4 = np.linalg.norm(p1 - p4)\n    Lc = (l1 + l2 + l3 + l4) / 4.\n    \n    if Lc  1e-15: # Degenerate geometry (e.g., all nodes at same point)\n        return False\n        \n    alpha = chg * mu * t * A / Lc\n    \n    # 2.5. Hourglass stiffness matrix\n    Ke_HG = alpha * Phg\n    \n    # 3. Nodal displacements from linear field\n    a, b, c, d, e, f = field_params\n    u = a + b * x_coords + c * y_coords\n    v = d + e * x_coords + f * y_coords\n    d_e = np.empty(8)\n    d_e[0::2] = u\n    d_e[1::2] = v\n    \n    # 4. Patch Test Verification\n    # 4.1. Condition (i): Zero hourglass energy\n    E_hg = d_e.T @ Ke_HG @ d_e\n    \n    # alpha can't be zero for valid inputs, so tau_E will be a small positive number\n    tau_E = 1.0e-12 * abs(alpha) \n    cond1 = np.abs(E_hg) = tau_E\n\n    # 4.2. Condition (ii): Exact strain at center\n    eps_computed = B @ d_e\n    eps_exact = np.array([b, f, c + e])\n    \n    strain_error = np.linalg.norm(eps_computed - eps_exact)\n    tau_eps = 1.0e-12\n    cond2 = strain_error = tau_eps\n\n    return cond1 and cond2\n\ndef solve():\n    \"\"\"\n    Main function to run the patch test verification for all specified test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: Happy path, regular square element\n        {\n            \"nodes\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"E\": 1000.0, \"nu\": 0.3, \"t\": 1.0, \"chg\": 0.1,\n            \"field_params\": (0, 0.01, 0, 0, 0, 0)\n        },\n        # Case 2: Distorted element, skewed geometry\n        {\n            \"nodes\": np.array([[0.0, 0.0], [1.2, -0.1], [1.1, 1.05], [-0.05, 1.1]]),\n            \"E\": 1000.0, \"nu\": 0.3, \"t\": 1.0, \"chg\": 0.1,\n            \"field_params\": (0, 0.01, 0, 0, 0, 0)\n        },\n        # Case 3: Edge case, high aspect ratio and pure shear\n        {\n            \"nodes\": np.array([[0.0, 0.0], [2.0, 0.0], [2.0, 0.5], [0.0, 0.5]]),\n            \"E\": 1000.0, \"nu\": 0.3, \"t\": 1.0, \"chg\": 0.1,\n            \"field_params\": (0, 0, 0.01, 0, 0.01, 0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = verify_patch_test(\n            case[\"nodes\"],\n            case[\"E\"],\n            case[\"nu\"],\n            case[\"t\"],\n            case[\"chg\"],\n            case[\"field_params\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}