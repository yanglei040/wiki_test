{
    "hands_on_practices": [
        {
            "introduction": "质量矩阵是在离散设定中表示内积的基本算子，在谱元法中至关重要。使用定义在勒让德-高斯-洛巴托（Legendre-Gauss-Lobatto, LGL）节点上的节点基函数的一个关键特性是，相应的基于求积的质量矩阵会变成对角矩阵。本练习 () 将引导您从第一性原理出发，计算LGL节点和权重，然后用它们来组装质量矩阵，从而亲手验证这一关键的对角结构，这对计算效率至关重要。",
            "id": "3446203",
            "problem": "考虑参考单元 $[-1,1]$ 和在勒让德-高斯-洛巴托（LGL）节点上进行节点插值的 $N=4$ 次谱元。设 $\\{x_i\\}_{i=0}^{N}$ 表示 LGL 节点，$\\{w_i\\}_{i=0}^{N}$ 表示相关的 LGL 求积权重。设 $\\{\\ell_i(x)\\}_{i=0}^{N}$ 为 $[-1,1]$ 上的节点拉格朗日基，满足 $\\ell_i(x_j)=\\delta_{ij}$。LGL 求积通过以下方式定义了基于求积的质量矩阵 $M \\in \\mathbb{R}^{(N+1)\\times(N+1)}$：\n$$\nM_{ij} \\equiv \\sum_{k=0}^{N} w_k\\, \\ell_i(x_k)\\,\\ell_j(x_k).\n$$\n任务：\n- 仅使用勒让德多项式的基本定义和 LGL 构造方法，确定 $N=4$ 时的 LGL 节点 $\\{x_i\\}_{i=0}^{4}$ 和 LGL 权重 $\\{w_i\\}_{i=0}^{4}$，并报告其数值，保留至少四位有效数字。\n- 使用上述求积和节点拉格朗日基组装矩阵 $M$。从第一性原理证明，为什么对于节点基，在 LGL 求积下所有非对角线元素 $M_{ij}$（其中 $i\\neq j$）都为零。\n- 根据您组装的 $M$，精确计算其行列式。\n\n请以单一简化解析表达式的形式提供 $\\det(M)$ 的精确值作为最终答案（无单位，无小数近似）。",
            "solution": "该问题要求我们确定 $N=4$ 次谱元的勒让德-高斯-洛巴托（LGL）节点和权重，分析基于求积的质量矩阵 $M$ 的结构，并计算其精确行列式。我们将系统地处理问题的每个部分。\n\n首先，我们确定 $N=4$ 时的 LGL 节点和权重。区间 $[-1,1]$ 上的 LGL 节点 $\\{x_i\\}_{i=0}^{N}$ 是方程 $(1-x^2)P_N'(x) = 0$ 的根，其中 $P_N(x)$ 是 $N$ 次勒让德多项式。对于 $N=4$，节点是 $(1-x^2)P_4'(x)=0$ 的根。端点 $x_0=-1$ 和 $x_4=1$ 立即可确定为节点。内部节点是 $P_4'(x)=0$ 的根。\n\n我们使用勒让德多项式递推关系来求 $P_4(x)$：\n$(n+1)P_{n+1}(x) = (2n+1)xP_n(x) - nP_{n-1}(x)$，其中基例为 $P_0(x)=1$ 和 $P_1(x)=x$。\n对于 $n=1$：$2P_2(x) = 3xP_1(x) - 1P_0(x) = 3x^2 - 1 \\implies P_2(x) = \\frac{1}{2}(3x^2-1)$。\n对于 $n=2$：$3P_3(x) = 5xP_2(x) - 2P_1(x) = \\frac{5}{2}x(3x^2-1) - 2x = \\frac{1}{2}(15x^3-9x) \\implies P_3(x) = \\frac{1}{2}(5x^3-3x)$。\n对于 $n=3$：$4P_4(x) = 7xP_3(x) - 3P_2(x) = \\frac{7}{2}x(5x^3-3x) - \\frac{3}{2}(3x^2-1) = \\frac{1}{2}(35x^4 - 21x^2 - 9x^2 + 3) = \\frac{1}{2}(35x^4 - 30x^2 + 3)$。\n因此，$P_4(x) = \\frac{1}{8}(35x^4 - 30x^2 + 3)$。\n\n导数是 $P_4'(x) = \\frac{1}{8}(140x^3 - 60x) = \\frac{5}{2}(7x^3 - 3x) = \\frac{5}{2}x(7x^2 - 3)$。\n$P_4'(x)=0$ 的根通过令 $x(7x^2 - 3)=0$ 求得，这得出 $x=0$ 和 $x=\\pm\\sqrt{\\frac{3}{7}}$。\n\n对于 $N=4$，LGL 节点从小到大排序为：\n$x_0 = -1$\n$x_1 = -\\sqrt{\\frac{3}{7}}$\n$x_2 = 0$\n$x_3 = \\sqrt{\\frac{3}{7}}$\n$x_4 = 1$\n\n这些节点的数值近似为：\n$x_0 = -1.0000$\n$x_1 \\approx -0.6547$\n$x_2 = 0.0000$\n$x_3 \\approx 0.6547$\n$x_4 = 1.0000$\n\nLGL 求积权重 $\\{w_i\\}_{i=0}^{N}$ 由公式 $w_i = \\frac{2}{N(N+1)[P_N(x_i)]^2}$ 给出。对于 $N=4$，这变为 $w_i = \\frac{2}{4(5)[P_4(x_i)]^2} = \\frac{1}{10[P_4(x_i)]^2}$。\n\n- 对于端点 $x_0=-1$ 和 $x_4=1$，我们使用 $P_4(-1) = (-1)^4 = 1$ 和 $P_4(1) = 1$。\n$w_0 = w_4 = \\frac{1}{10[P_4(1)]^2} = \\frac{1}{10(1)^2} = \\frac{1}{10}$。\n\n- 对于节点 $x_2=0$，我们计算 $P_4(0) = \\frac{1}{8}(3) = \\frac{3}{8}$。\n$w_2 = \\frac{1}{10[P_4(0)]^2} = \\frac{1}{10(\\frac{3}{8})^2} = \\frac{1}{10 \\cdot \\frac{9}{64}} = \\frac{64}{90} = \\frac{32}{45}$。\n\n- 对于内部节点 $x_1=-\\sqrt{\\frac{3}{7}}$ 和 $x_3=\\sqrt{\\frac{3}{7}}$，我们在 $x^2 = \\frac{3}{7}$ 处计算 $P_4(x)$。\n$P_4(\\pm\\sqrt{\\frac{3}{7}}) = \\frac{1}{8}\\left(35\\left(\\frac{3}{7}\\right)^2 - 30\\left(\\frac{3}{7}\\right) + 3\\right) = \\frac{1}{8}\\left(35\\frac{9}{49} - \\frac{90}{7} + 3\\right) = \\frac{1}{8}\\left(\\frac{45}{7} - \\frac{90}{7} + \\frac{21}{7}\\right) = \\frac{1}{8}\\left(\\frac{-24}{7}\\right) = -\\frac{3}{7}$。\n$w_1 = w_3 = \\frac{1}{10[P_4(\\sqrt{3/7})]^2} = \\frac{1}{10(-\\frac{3}{7})^2} = \\frac{1}{10 \\cdot \\frac{9}{49}} = \\frac{49}{90}$。\n\n$N=4$ 时的 LGL 权重为：\n$w_0 = \\frac{1}{10}$ (约 $0.1000$)\n$w_1 = \\frac{49}{90}$ (约 $0.5444$)\n$w_2 = \\frac{32}{45}$ (约 $0.7111$)\n$w_3 = \\frac{49}{90}$ (约 $0.5444$)\n$w_4 = \\frac{1}{10}$ (约 $0.1000$)\n\n接下来，我们讨论质量矩阵 $M$ 的结构。问题将基于求积的质量矩阵元素定义为 $M_{ij} = \\sum_{k=0}^{N} w_k\\, \\ell_i(x_k)\\,\\ell_j(x_k)$。基函数 $\\{\\ell_i(x)\\}_{i=0}^{N}$ 是节点拉格朗日基多项式，由性质 $\\ell_i(x_j) = \\delta_{ij}$ 定义，其中 $\\delta_{ij}$ 是克罗内克δ函数。\n\n将此性质应用于 $M_{ij}$ 的定义：\n项 $\\ell_i(x_k)$ 在 $k=i$ 时为 $1$，否则为 $0$。因此，我们可以写成 $\\ell_i(x_k) = \\delta_{ik}$。\n类似地，$\\ell_j(x_k) = \\delta_{jk}$。\n将这些代入求和式中：\n$M_{ij} = \\sum_{k=0}^{N} w_k \\delta_{ik} \\delta_{jk}$。\n\n为了证明非对角线元素为零，考虑 $i \\neq j$ 的情况。对于和式中的任何一项（由 $k$ 索引），乘积 $\\delta_{ik}\\delta_{jk}$ 只有在 $\\delta_{ik}=1$ 和 $\\delta_{jk}=1$ 同时成立时才非零。这将要求 $k=i$ 和 $k=j$ 同时成立。由于我们假设了 $i \\neq j$，这是不可能的。因此，对于任何 $k \\in \\{0, 1, \\dots, N\\}$，当 $i \\neq j$ 时，乘积 $\\delta_{ik}\\delta_{jk}$ 总是 $0$。\n这导致：\n当 $i \\neq j$ 时，$M_{ij} = \\sum_{k=0}^{N} w_k \\cdot 0 = 0$。\n这从第一性原理证明了 $M$ 的所有非对角线元素都为零。\n\n对于对角线元素，考虑 $i = j$ 的情况。表达式变为：\n$M_{ii} = \\sum_{k=0}^{N} w_k \\delta_{ik} \\delta_{ik} = \\sum_{k=0}^{N} w_k (\\delta_{ik})^2$。\n由于 $\\delta_{ik}$ 是 $0$ 或 $1$，所以 $(\\delta_{ik})^2 = \\delta_{ik}$。\n$M_{ii} = \\sum_{k=0}^{N} w_k \\delta_{ik}$。\n这个和式只包含一个非零项，它在 $k=i$ 时出现。该项的值是 $w_i \\cdot \\delta_{ii} = w_i \\cdot 1 = w_i$。\n所以，$M_{ii} = w_i$。\n\n矩阵 $M$ 是一个对角矩阵，其对角线元素是 LGL 求积权重：\n$M = \\text{diag}(w_0, w_1, w_2, w_3, w_4)$。\n\n使用为 $N=4$ 计算出的权重组装矩阵 $M$：\n$$\nM = \\begin{pmatrix} \\frac{1}{10} & 0 & 0 & 0 & 0 \\\\ 0 & \\frac{49}{90} & 0 & 0 & 0 \\\\ 0 & 0 & \\frac{32}{45} & 0 & 0 \\\\ 0 & 0 & 0 & \\frac{49}{90} & 0 \\\\ 0 & 0 & 0 & 0 & \\frac{1}{10} \\end{pmatrix}\n$$\n\n最后，我们计算 $M$ 的行列式。对角矩阵的行列式是其对角元素的乘积。\n$\\det(M) = w_0 \\cdot w_1 \\cdot w_2 \\cdot w_3 \\cdot w_4$。\n代入权重的精确分数值：\n$\\det(M) = \\left(\\frac{1}{10}\\right) \\cdot \\left(\\frac{49}{90}\\right) \\cdot \\left(\\frac{32}{45}\\right) \\cdot \\left(\\frac{49}{90}\\right) \\cdot \\left(\\frac{1}{10}\\right)$。\n我们使用质因数分解来简化这个乘积。\n$10 = 2 \\cdot 5$\n$49 = 7^2$\n$90 = 9 \\cdot 10 = 3^2 \\cdot 2 \\cdot 5$\n$32 = 2^5$\n$45 = 9 \\cdot 5 = 3^2 \\cdot 5$\n\n$\\det(M) = \\frac{1}{2 \\cdot 5} \\cdot \\frac{7^2}{3^2 \\cdot 2 \\cdot 5} \\cdot \\frac{2^5}{3^2 \\cdot 5} \\cdot \\frac{7^2}{3^2 \\cdot 2 \\cdot 5} \\cdot \\frac{1}{2 \\cdot 5}$\n\n合并分子和分母中的项：\n分子：$1 \\cdot 7^2 \\cdot 2^5 \\cdot 7^2 \\cdot 1 = 2^5 \\cdot 7^4$。\n分母：$(2\\cdot5) \\cdot (3^2\\cdot2\\cdot5) \\cdot (3^2\\cdot5) \\cdot (3^2\\cdot2\\cdot5) \\cdot (2\\cdot5) = 2^{1+1+1+1} \\cdot 3^{2+2+2} \\cdot 5^{1+1+1+1+1} = 2^4 \\cdot 3^6 \\cdot 5^5$。\n\n$\\det(M) = \\frac{2^5 \\cdot 7^4}{2^4 \\cdot 3^6 \\cdot 5^5} = \\frac{2 \\cdot 7^4}{3^6 \\cdot 5^5}$。\n这就是行列式的精确简化解析表达式。为了便于展示，我们计算其整数值：$7^4=2401$，$3^6=729$，$5^5=3125$。\n$\\det(M) = \\frac{2 \\cdot 2401}{729 \\cdot 3125} = \\frac{4802}{2278125}$。使用素数幂的形式更为基本。\n最终答案是 $\\frac{2 \\cdot 7^4}{3^6 \\cdot 5^5}$。",
            "answer": "$$\n\\boxed{\\frac{2 \\cdot 7^4}{3^6 \\cdot 5^5}}\n$$"
        },
        {
            "introduction": "谱方法可以使用不同的多项式基底来构建，其中最常见的是模式基（如Legendre多项式）和节点基（如Lagrange多项式）。本练习 () 通过基变换，深入探讨了这兩種表示之间的内在联系。通过变换刚度算子并分析相应的广义特征值问题，您将证明一个基本原理：算子的內在物理属性（如其谱）在基底的选择下是不变的。",
            "id": "3446146",
            "problem": "在一维参考单元 $[-1,1]$ 上，考虑一个最高次数为 $N$ 的多项式空间 $\\mathbb{P}_N$，其中 $N=3$。令 $\\{\\phi_k\\}_{k=0}^{3}$ 为 Legendre 多项式基 $\\phi_k(x)=P_k(x)$，其归一化条件为 $P_k(1)=1$。定义刚度双线性形式 $a(u,v)=\\int_{-1}^{1} u'(x)\\,v'(x)\\,dx$ 和质量双线性形式 $m(u,v)=\\int_{-1}^{1} u(x)\\,v(x)\\,dx$。\n\n1. 使用相对于基 $\\{\\phi_k\\}_{k=0}^{3}$ 的精确积分，组装模态刚度矩阵 $K_{\\mathrm{modal}}\\in\\mathbb{R}^{4\\times 4}$ 和模态质量矩阵 $M_{\\mathrm{modal}}\\in\\mathbb{R}^{4\\times 4}$。\n\n2. 令 $\\{x_i\\}_{i=0}^{3}$ 为 $N=3$ 时的 Legendre–Gauss–Lobatto (LGL) 节点，并令 $\\{\\ell_i\\}_{i=0}^{3}$ 表示满足 $\\ell_i(x_j)=\\delta_{ij}$ 的相应节点 Lagrange 多项式。定义 Vandermonde 矩阵 $V\\in\\mathbb{R}^{4\\times 4}$，其元素为 $V_{ij}=\\phi_j(x_i)$，其中模态系数 $\\mathbf{c}$ 和节点值 $\\mathbf{u}$ 通过关系 $\\mathbf{u}=V\\,\\mathbf{c}$ 相关联。\n\n3. 仅使用基变换下的系数基本映射，将 $K_{\\mathrm{modal}}$ 变换到节点 LGL 基，以获得 $K_{\\mathrm{nodal}}=V^{-T}K_{\\mathrm{modal}}V^{-1}$，并显式计算这个稠密的 $4\\times 4$ 矩阵。\n\n4. 考虑在每个基中表示的连续算子的广义特征值问题：找到 $\\lambda$ 和一个非零向量 $\\mathbf{z}$，使得 $K\\,\\mathbf{z}=\\lambda\\,M\\,\\mathbf{z}$。从第一性原理出发，证明算子的谱在模态表示和节点表示之间的基变换下是不变的（即，$(K_{\\mathrm{modal}},M_{\\mathrm{modal}})$ 和 $(K_{\\mathrm{nodal}},M_{\\mathrm{nodal}})$ 的广义特征值重合）。然后显式计算 $N=3$ 时的三个正广义特征值。\n\n报告一个等于这三个正广义特征值之和的精确表达式作为你的最终答案。不要对你的答案进行四舍五入。",
            "solution": "这个问题要求我们探讨模态基和节点基之间的关系，特别是在一维拉普拉斯算子的离散化背景下。我们将逐步完成所有任务。\n\n### 第 1 部分：组装模态矩阵\n\n模态基由前四个勒让德多项式 $\\phi_k(x) = P_k(x)$ 给出：\n$$ \\phi_0(x) = 1, \\quad \\phi_1(x) = x, \\quad \\phi_2(x) = \\frac{1}{2}(3x^2 - 1), \\quad \\phi_3(x) = \\frac{1}{2}(5x^3 - 3x) $$\n模态质量矩阵 $M_{\\mathrm{modal}}$ 的元素为 $(M_{\\mathrm{modal}})_{ij} = \\int_{-1}^{1} \\phi_j(x)\\phi_i(x) dx$。利用勒让德多项式的正交性 $\\int_{-1}^{1} P_i(x)P_j(x) dx = \\frac{2}{2i+1}\\delta_{ij}$，该矩阵是对角的：\n$$ M_{\\mathrm{modal}} = \\mathrm{diag}\\left(2, \\frac{2}{3}, \\frac{2}{5}, \\frac{2}{7}\\right) = \\begin{pmatrix} 2 & 0 & 0 & 0 \\\\ 0 & 2/3 & 0 & 0 \\\\ 0 & 0 & 2/5 & 0 \\\\ 0 & 0 & 0 & 2/7 \\end{pmatrix} $$\n模态刚度矩阵 $K_{\\mathrm{modal}}$ 的元素为 $(K_{\\mathrm{modal}})_{ij} = \\int_{-1}^{1} \\phi_j'(x)\\phi_i'(x) dx$。基函数的导数为：\n$$ \\phi_0'(x) = 0, \\quad \\phi_1'(x) = 1, \\quad \\phi_2'(x) = 3x, \\quad \\phi_3'(x) = \\frac{1}{2}(15x^2 - 3) $$\n由于 $\\phi_0'(x)=0$，$K_{\\mathrm{modal}}$ 的第一行和第一列均为零。其他元素通过直接积分计算得出，利用对称性 $K_{ij}=K_{ji}$：\n$K_{11} = \\int_{-1}^{1} (1)^2 dx = 2$\n$K_{12} = \\int_{-1}^{1} (1)(3x) dx = 0$\n$K_{13} = \\int_{-1}^{1} (1)\\left(\\frac{15}{2}x^2 - \\frac{3}{2}\\right) dx = 2$\n$K_{22} = \\int_{-1}^{1} (3x)^2 dx = 6$\n$K_{23} = \\int_{-1}^{1} (3x)\\left(\\frac{15}{2}x^2 - \\frac{3}{2}\\right) dx = 0$\n$K_{33} = \\int_{-1}^{1} \\left(\\frac{15}{2}x^2 - \\frac{3}{2}\\right)^2 dx = 12$\n因此，模态刚度矩阵为：\n$$ K_{\\mathrm{modal}} = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 2 & 0 & 2 \\\\ 0 & 0 & 6 & 0 \\\\ 0 & 2 & 0 & 12 \\end{pmatrix} $$\n\n### 第 2 部分：LGL 节点和范德蒙德矩阵\n\n对于 $N=3$，Legendre-Gauss-Lobatto (LGL) 节点是方程 $(1-x^2)P_3'(x)=0$ 的根。端点是 $x_0=-1$ 和 $x_3=1$。内部节点是 $P_3'(x) = \\frac{1}{2}(15x^2 - 3) = 0$ 的根，即 $x=\\pm 1/\\sqrt{5}$。因此，LGL 节点为：\n$$ \\{x_0, x_1, x_2, x_3\\} = \\left\\{-1, -\\frac{1}{\\sqrt{5}}, \\frac{1}{\\sqrt{5}}, 1\\right\\} $$\n范德蒙德矩阵 $V$ 定义为 $V_{ij} = \\phi_j(x_i)$。将 LGL 节点代入勒让德多项式，我们得到：\n$$ V = \\begin{pmatrix}\n1 & -1 & 1 & -1 \\\\\n1 & -1/\\sqrt{5} & -1/5 & 1/\\sqrt{5} \\\\\n1 & 1/\\sqrt{5} & -1/5 & -1/\\sqrt{5} \\\\\n1 & 1 & 1 & 1\n\\end{pmatrix} $$\n\n### 第 3 部分：节点刚度矩阵变换\n\n节点刚度矩阵由变换 $K_{\\mathrm{nodal}} = V^{-T}K_{\\mathrm{modal}}V^{-1}$ 给出。为了显式计算该矩阵，需要计算 $V^{-1}$ 并执行矩阵乘法。这个代数过程虽然直接，但计算量较大，它清晰地展示了从稀疏的模态矩阵到稠密的节点矩阵的变换。经过计算可得：\n$$ K_{\\mathrm{nodal}} = \\frac{1}{24} \\begin{pmatrix}\n52 & -25-15\\sqrt{5} & -25+15\\sqrt{5} & -2 \\\\\n-25-15\\sqrt{5} & 100 & -50 & -25+15\\sqrt{5} \\\\\n-25+15\\sqrt{5} & -50 & 100 & -25-15\\sqrt{5} \\\\\n-2 & -25+15\\sqrt{5} & -25-15\\sqrt{5} & 52\n\\end{pmatrix} $$\n这个稠密矩阵与对角形式的模态刚度矩阵形成鲜明对比，验证了在节点基下算子矩阵的稠密性。\n\n### 第 4 部分：广义特征值问题\n\n首先，我们证明谱（特征值集合）在基变换下是不变的。模态和节点广义特征值问题分别为：\n$$ K_{\\mathrm{modal}}\\mathbf{c} = \\lambda M_{\\mathrm{modal}}\\mathbf{c} $$\n$$ K_{\\mathrm{nodal}}\\mathbf{u} = \\lambda' M_{\\mathrm{nodal}}\\mathbf{u} $$\n我们将基变换关系（$K_{\\mathrm{nodal}} = V^{-T}K_{\\mathrm{modal}}V^{-1}$，$M_{\\mathrm{nodal}} = V^{-T}M_{\\mathrm{modal}}V^{-1}$，以及 $\\mathbf{u} = V\\mathbf{c}$）代入节点问题：\n$$ (V^{-T}K_{\\mathrm{modal}}V^{-1})(V\\mathbf{c}) = \\lambda' (V^{-T}M_{\\mathrm{modal}}V^{-1})(V\\mathbf{c}) $$\n由于 $V$ 是可逆的，$V^{-1}V = I$。左乘 $V^T$ 得到：\n$$ K_{\\mathrm{modal}}\\mathbf{c} = \\lambda' M_{\\mathrm{modal}}\\mathbf{c} $$\n这与模态特征值问题完全相同，因此它们的特征值必须相同，即 $\\lambda' = \\lambda$。\n\n接下来，我们求解特征值。在模态基中求解要简单得多。\n第一个方程 $0 = \\lambda(2c_0)$ 给出对应于常数模态 $\\phi_0$ 的零特征值 $\\lambda_0=0$。我们只关心正特征值，所以对于非零解，必须有 $c_0=0$。\n系统由于基函数的奇偶性而解耦。\n- 对于偶次模态 ($c_2$):\n  $6c_2 = \\lambda(2/5)c_2 \\implies \\lambda_A = 6 \\cdot \\frac{5}{2} = 15$。这是一个正特征值。\n- 对于奇次模态 ($c_1, c_3$):\n  $$ \\begin{pmatrix} 2 & 2 \\\\ 2 & 12 \\end{pmatrix} \\begin{pmatrix} c_1 \\\\ c_3 \\end{pmatrix} = \\lambda \\begin{pmatrix} 2/3 & 0 \\\\ 0 & 2/7 \\end{pmatrix} \\begin{pmatrix} c_1 \\\\ c_3 \\end{pmatrix} $$\n  特征方程为 $\\det(K' - \\lambda M')=0$：\n  $$ \\det \\begin{pmatrix} 2 - \\frac{2\\lambda}{3} & 2 \\\\ 2 & 12 - \\frac{2\\lambda}{7} \\end{pmatrix} = 0 $$\n  $$ \\left(2 - \\frac{2\\lambda}{3}\\right)\\left(12 - \\frac{2\\lambda}{7}\\right) - 4 = 0 \\implies \\left(1 - \\frac{\\lambda}{3}\\right)\\left(6 - \\frac{\\lambda}{7}\\right) = 1 $$\n  展开并整理得：\n  $$ \\lambda^2 - 45\\lambda + 105 = 0 $$\n这个二次方程的两个根 $\\lambda_B$ 和 $\\lambda_C$ 是另外两个正特征值。根据韦达定理，它们的和为 $\\lambda_B + \\lambda_C = 45$。\n\n因此，三个正广义特征值的和是：\n$$ \\text{Sum} = \\lambda_A + (\\lambda_B + \\lambda_C) = 15 + 45 = 60 $$",
            "answer": "$$\\boxed{60}$$"
        },
        {
            "introduction": "一种数值方法的真正威力体现在其应对挑战性问题的能力上。本练习 () 将从理论走向实践应用：求解一个具有尖锐边界层的对流主导问题，这对许多数值格式来说都是一个出了名的难题。您将实现一种谱方法，利用Jacobi多项式的灵活性将节点聚集在边界层内，从而显著提高精度。这个编程练习生动地展示了谱基底的理论适应性如何转化为解决复杂物理现象的卓越性能。",
            "id": "3446182",
            "problem": "考虑区间 $[0,1]$ 上对流扩散算子的一维边值问题，\n$$\n-\\varepsilon\\,u_{xx}(x) + b\\,u_{x}(x) = 0,\\quad x\\in(0,1),\n$$\n其狄利克雷边界条件为 $u(0)=0$ 和 $u(1)=1$，其中 $\\varepsilon>0$ 是扩散系数，$b\\in\\mathbb{R}$ 是对流系数。当 $0<\\varepsilon\\ll 1$ 且 $b\\neq 0$ 时，解在流出边界上会形成一个指数级薄的边界层：对于 $b>0$，边界层位于 $x=1$；对于 $b<0$，边界层位于 $x=0$。\n\n在单个单元上的一维谱元法 (SEM) 可简化为全局高阶谱离散，通常使用高斯-洛巴托节点上的拉格朗日多项式实现。节点分布的选择对于解析薄边界层至关重要。一类节点集由参考区间 $\\xi\\in[-1,1]$ 上的雅可比多项式 $P_n^{(\\alpha,\\beta)}(\\xi)$（参数 $\\alpha>-1$ 和 $\\beta>-1$）以及相关的高斯-洛巴托-雅可比节点导出。通过调整 $(\\alpha,\\beta)$，可以使节点在 $\\xi=-1$ 或 $\\xi=+1$ 附近聚集，从而在经过仿射映射 $x=(\\xi+1)/2$ 后，使节点在 $x=0$ 或 $x=1$ 附近聚集。\n\n您的任务是编写一个完整的程序，该程序能够：\n- 使用多项式次数为 $p$、参数为 $(\\alpha,\\beta)$ 的高斯-洛巴托-雅可比节点上的拉格朗日基，在单个单元上实现谱配置谱元法 (SEM)。\n- 使用重心拉格朗日微分矩阵在配置点处逼近 $u_x$ 和 $u_{xx}$。\n- 在端点处强施加狄利克雷边界条件，并在内部节点处满足微分方程。\n- 对于多个 $p$ 值，计算数值解及其与精确解在配置点上的上确界范数误差。\n\n使用的基本依据：\n- 如上所述的微分方程和边界条件。\n- 从参考区间到物理区间的仿射映射 $x=(\\xi+1)/2$ 以及链式法则 $u_x=2\\,u_\\xi$ 和 $u_{xx}=4\\,u_{\\xi\\xi}$。\n- 雅可比多项式 $P_n^{(\\alpha,\\beta)}(\\xi)$ 的定义，以及高斯-洛巴托-雅可比内部节点是 $P_{p-1}^{(\\alpha+1,\\beta+1)}(\\xi)$ 的零点（并包含端点）这一事实。\n- 重心拉格朗日插值及其由节点和重心权重构建的微分矩阵。\n\n用于验证的精确解：\n- 对于 $b>0$，精确解为\n$$\nu(x)=\\frac{e^{x/\\varepsilon}-1}{e^{1/\\varepsilon}-1}.\n$$\n- 对于 $b<0$，精确解为\n$$\nu(x)=\\frac{1-e^{-x/\\varepsilon}}{1-e^{-1/\\varepsilon}}.\n$$\n\n您必须通过比较基准选择 $(\\alpha,\\beta)=(0,0)$（对应于勒让德-高斯-洛巴托节点）与一个将节点聚集在边界层所在边界的调优选择，来研究雅可比参数对边界层解析的影响：\n- 若 $b>0$（边界层位于 $x=1$），使用调优选择 $(\\alpha,\\beta)=(0,3)$。\n- 若 $b<0$（边界层位于 $x=0$），使用调优选择 $(\\alpha,\\beta)=(3,0)$。\n\n对于每个测试用例，计算多项式次数 $p$ 列表在配置点上的最大绝对误差。为每个测试用例报告一个浮点数，该浮点数等于列表中最大次数下基准误差与调优误差的比率。大于 $1$ 的比率表示通过调优得到了改善。\n\n测试套件：\n- 情况 1（正常路径，中等边界层）：$\\varepsilon=0.1$, $b=+1$, 次数 $p\\in\\{4,8,12,16\\}$。\n- 情况 2（薄边界层，右边界解析困难）：$\\varepsilon=0.01$, $b=+1$, 次数 $p\\in\\{8,16,24,32\\}$。\n- 情况 3（薄边界层，左边界解析困难）：$\\varepsilon=0.01$, $b=-1$, 次数 $p\\in\\{8,16,24,32\\}$。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含三个测试用例的结果比率，格式为方括号内以逗号分隔的列表，例如，“[ratio_case1,ratio_case2,ratio_case3]”。\n- 所有数字必须以普通小数形式打印。不涉及单位。\n- 无需用户输入；所有参数均如上所述固定并嵌入程序中。\n\n科学真实性和约束条件：\n- 确保所有使用的雅可比参数满足 $\\alpha>-1$ 和 $\\beta>-1$。\n- 对于指定的参数范围，算法必须是自洽的且数值上一致。\n- 不要使用任何外部数据文件或网络。",
            "solution": "该问题在应用数学和数值分析领域具有科学依据，具体涉及偏微分方程 (PDE) 边值问题的求解。任务是实现一种谱配置法来求解一维对流扩散方程，并分析节点分布在解析边界层中的作用。\n\n求解过程的结构如下：\n\n**1. 数学公式化与变换**\n\n控制方程是物理域 $x \\in [0, 1]$ 上的一维稳态对流扩散方程：\n$$\n-\\varepsilon\\,u_{xx}(x) + b\\,u_{x}(x) = 0\n$$\n服从狄利克雷边界条件 $u(0)=0$ 和 $u(1)=1$。此处，$\\varepsilon > 0$ 是扩散系数，$b \\in \\mathbb{R}$ 是对流速度。\n\n谱方法最便于在标准参考区间 $\\xi \\in [-1, 1]$ 上构建。我们使用仿射映射 $x(\\xi) = (\\xi+1)/2$ 将物理域变换到参考域。导数根据链式法则进行变换：\n$$\n\\frac{d}{dx} = \\frac{d\\xi}{dx} \\frac{d}{d\\xi} = 2 \\frac{d}{d\\xi}\n$$\n$$\n\\frac{d^2}{dx^2} = \\frac{d}{dx}\\left(2 \\frac{d}{d\\xi}\\right) = 2 \\frac{d\\xi}{dx} \\frac{d}{d\\xi}\\left(\\frac{d}{d\\xi}\\right) = 4 \\frac{d^2}{d\\xi^2}\n$$\n将这些代入原方程，得到参考区间上的变换后偏微分方程：\n$$\n-4\\varepsilon\\,u_{\\xi\\xi}(\\xi) + 2b\\,u_{\\xi}(\\xi) = 0, \\quad \\xi \\in (-1, 1)\n$$\n边界条件变换为 $u(\\xi=-1) = u(x=0) = 0$ 和 $u(\\xi=1) = u(x=1) = 1$。\n\n**2. 离散化与配置点**\n\n谱配置法寻求一个近似解 $U(\\xi)$，它是一个 $p$ 次多项式，由其在一组 $p+1$ 个不同配置点 $\\{\\xi_j\\}_{j=0}^p$ 上的值表示。这些节点的选择对方法的准确性和稳定性至关重要。我们使用高斯-洛巴托-雅可比 (GLJ) 节点，其中包括端点 $\\xi_0 = -1$ 和 $\\xi_p = 1$。$p-1$ 个内部节点是雅可比多项式 $P_p^{(\\alpha,\\beta)}(\\xi)$ 导数的零点，这等价于 $P_{p-1}^{(\\alpha+1,\\beta+1)}(\\xi)$ 的零点。参数 $\\alpha, \\beta > -1$ 控制节点的分布。选择 $(\\alpha,\\beta) = (0,0)$ 会得到标准的高斯-洛巴托-勒让德节点，这些节点在某种意义上是大致均匀分布的。通过选择 $\\alpha > \\beta$，节点会向 $\\xi = -1$（即 $x=0$）聚集；通过选择 $\\beta > \\alpha$，节点会向 $\\xi = 1$（即 $x=1$）聚集。当 $\\varepsilon \\ll |b|$ 时，利用此性质来解析解中存在的尖锐边界层。\n\n**3. 通过重心微分矩阵进行导数近似**\n\n解多项式 $U(\\xi)$ 在配置点处的导数通过矩阵向量乘积 $U' = DU$ 和 $U'' = D^2U$ 计算，其中 $D$ 是 $(p+1) \\times (p+1)$ 的谱微分矩阵。我们使用重心拉格朗日插值公式来构造 $D$，该公式对任何一组不同的节点都具有鲁棒性。微分矩阵 $D$ 的元素由下式给出：\n$$\nD_{ij} = \\begin{cases}\n\\frac{w_j/w_i}{\\xi_i - \\xi_j} & \\text{若 } i \\neq j \\\\\n-\\sum_{k \\neq i} D_{ik} & \\text{若 } i = j\n\\end{cases}\n$$\n其中重心权重 $w_j$ 定义为：\n$$\nw_j = \\frac{1}{\\prod_{k=0, k \\neq j}^p (\\xi_j - \\xi_k)}\n$$\n对角线元素这样计算是为了强制执行常数导数为零的属性，这增强了数值稳定性。\n\n**4. 线性系统的组装与求解**\n\n我们在 $p-1$ 个内部配置点 $(\\xi_1, \\dots, \\xi_{p-1})$ 处强制执行变换后的微分方程。这产生一个线性方程组。设 $U$ 为节点处未知解值 $[U_0, U_1, \\dots, U_p]^T$ 的向量。离散化后的系统是：\n$$\n(-4\\varepsilon D^2 + 2b D) U = \\mathbf{0}\n$$\n通过设置 $U_0 = 0$ 和 $U_p = 1$ 来强施加边界条件。关于 $p-1$ 个内部未知量 $\\tilde{U} = [U_1, \\dots, U_{p-1}]^T$ 的方程组可以写成：\n$$\n\\sum_{k=1}^{p-1} L_{jk} U_k = -L_{j0}U_0 - L_{jp}U_p, \\quad \\text{对于 } j=1, \\dots, p-1\n$$\n其中 $L = -4\\varepsilon D^2 + 2b D$。代入已知的边界值：\n$$\n\\sum_{k=1}^{p-1} L_{jk} U_k = -L_{jp}, \\quad \\text{对于 } j=1, \\dots, p-1\n$$\n然后求解这个 $(p-1) \\times (p-1)$ 的线性系统以获得内部节点值 $\\tilde{U}$，例如，使用 LU 分解。\n\n**5. 误差分析与参数调优**\n\n一旦组装好完整的数值解值向量 $U$，就将其与精确解析解进行比较来衡量误差。该边值问题的精确解为：\n$$\nu(x) = \\frac{e^{(b/\\varepsilon)x} - 1}{e^{b/\\varepsilon} - 1}\n$$\n误差在配置点集上以最大范数计算：\n$$\nE = \\max_{j=0, \\dots, p} |U_j - u(x_j)|\n$$\n为了展示节点聚集的有效性，我们将标准勒让德节点 $(\\alpha, \\beta) = (0,0)$ 产生的误差与一组调优的雅可比节点产生的误差进行比较。对于 $x=1$ ($b>0$) 处的边界层，我们使用 $(\\alpha,\\beta) = (0,3)$ 使节点在 $\\xi=1$ 附近聚集。对于 $x=0$ ($b<0$) 处的边界层，我们使用 $(\\alpha,\\beta) = (3,0)$ 使节点在 $\\xi=-1$ 附近聚集。基准情况的误差与调优情况的误差之比量化了这种针对特定问题的谱方法调优所带来的改进。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_jacobi\n\ndef barycentric_diff_matrix(nodes):\n    \"\"\"\n    Computes the barycentric differentiation matrix for a given set of nodes.\n    \n    Args:\n        nodes (np.ndarray): A 1D array of collocation nodes.\n        \n    Returns:\n        np.ndarray: The differentiation matrix.\n    \"\"\"\n    p = len(nodes) - 1\n    dtype = np.float64\n    nodes = np.array(nodes, dtype=dtype)\n    weights = np.ones(p + 1, dtype=dtype)\n\n    # Calculate barycentric weights using the direct product formula.\n    for j in range(p + 1):\n        prod = 1.0\n        for k in range(p + 1):\n            if k != j:\n                prod *= (nodes[j] - nodes[k])\n        if prod == 0:\n            raise ValueError(\"Product in weight calculation is zero, likely due to duplicate nodes.\")\n        weights[j] = 1.0 / prod\n    \n    D = np.zeros((p + 1, p + 1), dtype=dtype)\n    \n    # Off-diagonal entries\n    for i in range(p + 1):\n        for j in range(p + 1):\n            if i != j:\n                D[i, j] = (weights[j] / weights[i]) / (nodes[i] - nodes[j])\n\n    # Diagonal entries are computed to ensure the sum of each row is zero.\n    for i in range(p + 1):\n        D[i, i] = -np.sum(D[i, :])\n        \n    return D\n\ndef solve_bvp(p, epsilon, b, alpha, beta):\n    \"\"\"\n    Solves the 1D convection-diffusion BVP using spectral collocation.\n    \n    Args:\n        p (int): Polynomial degree.\n        epsilon (float): Diffusion coefficient.\n        b (float): Convection coefficient.\n        alpha (float): Jacobi polynomial parameter.\n        beta (float): Jacobi polynomial parameter.\n        \n    Returns:\n        float: Maximum absolute error at collocation nodes.\n    \"\"\"\n    # 1. Compute Gauss-Lobatto-Jacobi nodes on the reference interval [-1, 1].\n    # Interior nodes are the roots of P_{p-1}^{alpha+1, beta+1}.\n    if p > 1:\n        interior_nodes, _ = roots_jacobi(p - 1, alpha + 1, beta + 1)\n    else: # For p=1, there are no interior nodes.\n        interior_nodes = np.array([])\n    \n    # The full set of nodes includes the endpoints.\n    xi_nodes = np.concatenate(([-1.0], np.sort(interior_nodes), [1.0]))\n    \n    # Map nodes to the physical domain [0, 1].\n    x_nodes = (xi_nodes + 1.0) / 2.0\n\n    # 2. Compute differentiation matrices on the reference interval.\n    D_xi = barycentric_diff_matrix(xi_nodes)\n    D2_xi = np.dot(D_xi, D_xi)\n\n    # 3. Assemble and solve the linear system for interior nodes.\n    # The ODE in xi is: -4*epsilon*u_xixi + 2*b*u_xi = 0.\n    L = -4.0 * epsilon * D2_xi + 2.0 * b * D_xi\n\n    # Enforce Dirichlet BCs u(0)=0 (at xi=-1) and u(1)=1 (at xi=1) strongly.\n    # We solve for the p-1 unknown values at the interior nodes.\n    if p > 1:\n        interior_indices = np.arange(1, p)\n        # Construct the (p-1)x(p-1) submatrix for the interior.\n        L_interior = L[np.ix_(interior_indices, interior_indices)]\n        \n        # The right-hand side comes from the known boundary values U_0=0 and U_p=1.\n        # sum_{k=1}^{p-1} L_jk U_k = -L_{j,0}*U_0 - L_{j,p}*U_p = -L_{j,p}\n        rhs = -L[interior_indices, p]\n        \n        U_interior = np.linalg.solve(L_interior, rhs)\n    else:\n        U_interior = np.array([])\n        \n    # Assemble the full solution vector.\n    U = np.concatenate(([0.0], U_interior, [1.0]))\n\n    # 4. Compute error against the exact solution.\n    # The exact solution is u(x) = (exp(b*x/eps) - 1) / (exp(b/eps) - 1).\n    term = b / epsilon\n    u_exact_vals = (np.exp(x_nodes * term) - 1.0) / (np.exp(term) - 1.0)\n    \n    error = np.max(np.abs(U - u_exact_vals))\n    \n    return error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'epsilon': 0.1, 'b': 1, 'p_list': [4, 8, 12, 16]},\n        {'epsilon': 0.01, 'b': 1, 'p_list': [8, 16, 24, 32]},\n        {'epsilon': 0.01, 'b': -1, 'p_list': [8, 16, 24, 32]},\n    ]\n\n    results = []\n    for case in test_cases:\n        epsilon = case['epsilon']\n        b = case['b']\n        p_max = max(case['p_list'])\n\n        # Baseline case: Gauss-Lobatto-Legendre nodes\n        alpha_base, beta_base = 0.0, 0.0\n        error_base = solve_bvp(p_max, epsilon, b, alpha_base, beta_base)\n\n        # Tuned case: Gauss-Lobatto-Jacobi nodes clustered at the boundary layer\n        if b > 0: # Layer at x=1 (xi=1), so increase beta\n            alpha_tuned, beta_tuned = 0.0, 3.0\n        else: # b  0, layer at x=0 (xi=-1), so increase alpha\n            alpha_tuned, beta_tuned = 3.0, 0.0\n        \n        error_tuned = solve_bvp(p_max, epsilon, b, alpha_tuned, beta_tuned)\n\n        # Compute the ratio of errors; a ratio > 1 indicates improvement.\n        if error_tuned > 0:\n            ratio = error_base / error_tuned\n        else:\n            # Handle case where tuned error is zero (or near-zero) to avoid division by zero\n            # If base error is also zero, ratio is 1. Otherwise, improvement is effectively infinite.\n            ratio = 1.0 if error_base == 0 else np.inf\n        results.append(ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}