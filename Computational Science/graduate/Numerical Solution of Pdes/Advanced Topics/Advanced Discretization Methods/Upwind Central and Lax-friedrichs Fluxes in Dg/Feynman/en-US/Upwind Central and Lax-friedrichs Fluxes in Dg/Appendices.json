{
    "hands_on_practices": [
        {
            "introduction": "A robust numerical scheme requires a careful balance between accuracy and stability. This practice delves into the theoretical foundations of stability for DG methods by guiding you through a pen-and-paper derivation of Courant–Friedrichs–Lewy (CFL) conditions . By analyzing the linear advection equation, you will mathematically prove why the non-dissipative central flux is unstable with explicit time stepping and how the dissipation introduced by upwind and Lax-Friedrichs fluxes makes stable computations possible.",
            "id": "3459774",
            "problem": "Consider the one-dimensional linear advection equation $u_{t} + a\\,u_{x} = 0$ on the periodic interval $[0,1]$, where $a \\in \\mathbb{R}\\setminus\\{0\\}$ is constant. Let the domain be partitioned into $N$ uniform cells of size $h = 1/N$. On each cell, discretize using the discontinuous Galerkin (DG) method with polynomials of degree at most $p \\in \\mathbb{N}_{0}$. Denote by $\\llbracket \\cdot \\rrbracket$ the interface jump and by $\\{\\cdot\\}$ the interface average, and consider the numerical fluxes induced by the linear physical flux $f(u)=a u$:\n- Central flux: $f^{*}(u^{-},u^{+}) = a\\,\\{u\\}$,\n- Upwind flux: $f^{*}(u^{-},u^{+}) = a\\,u^{-}$ if $a0$ and $f^{*}(u^{-},u^{+}) = a\\,u^{+}$ if $a0$,\n- Lax–Friedrichs (Rusanov) flux: $f^{*}(u^{-},u^{+}) = a\\,\\{u\\} - \\frac{\\alpha}{2}\\,\\llbracket u \\rrbracket$ with $\\alpha \\ge |a|$.\n\nAssume a modal Legendre basis on each reference cell mapped affinely to the physical cell so that the local mass matrix is diagonal with entries proportional to $h$. Let $\\|\\cdot\\|_{L^{2}}$ denote the discrete $L^{2}$ norm induced by the DG mass matrix. You may use, as a foundational fact, the sharp one-dimensional polynomial trace inequality on a single cell $K$ of size $h$:\n$$\n|v|^{2}_{\\partial K} \\le \\frac{2p+1}{h}\\,\\|v\\|^{2}_{L^{2}(K)} \\quad \\text{for all } v \\in \\mathbb{P}_{p}(K),\n$$\nwhere $|v|^{2}_{\\partial K}$ denotes the sum of the squares of the traces of $v$ at the two endpoints of $K$.\n\nUsing only conservation, integration by parts at the semi-discrete level, and the above trace inequality, derive explicit Courant–Friedrichs–Lewy (CFL) bounds on the forward Euler time step $\\Delta t$ that ensure non-increase of the discrete $L^{2}$ norm under one forward Euler update for each flux choice. Then use the Strong Stability Preserving (SSP) property of the classical third-order Strong Stability Preserving Runge–Kutta method (SSP-RK3) to conclude the corresponding $\\Delta t_{\\max}$ for SSP-RK3.\n\nYour final answer must be a single row of three closed-form expressions giving $\\Delta t_{\\max}$ as functions of $p$ and $h$ (and $|a|$, $\\alpha$ where appropriate), in the order: central flux, upwind flux, Lax–Friedrichs flux. Explain in your derivation why and how the interface dissipation level changes the stability constant. Answer symbolically; do not substitute numerical values. The final expressions must not include units.",
            "solution": "The problem asks for the maximum allowable time step $\\Delta t_{\\max}$ for the discontinuous Galerkin (DG) method applied to the linear advection equation, under both forward Euler and a third-order Strong Stability Preserving Runge-Kutta (SSP-RK3) time integration. The stability criterion is that the discrete $L^2$ norm of the solution does not increase. The analysis must be performed for three different numerical fluxes: central, upwind, and Lax-Friedrichs.\n\nFirst, we establish the semi-discrete formulation of the DG method. For the equation $u_t + a u_x = 0$, the DG formulation on a cell $K_j = [x_{j-1/2}, x_{j+1/2}]$ is to find $u_h$ in the space of piecewise polynomials of degree at most $p$, such that for any test function $v_h$ in the same space:\n$$\n\\int_{K_j} \\frac{\\partial u_h}{\\partial t} v_h \\, dx - \\int_{K_j} a u_h \\frac{\\partial v_h}{\\partial x} \\, dx + \\left[ f^*(u_h) v_h \\right]_{x_{j-1/2}}^{x_{j+1/2}} = 0\n$$\nwhere $f^*(u_h)$ is the numerical flux, which depends on the values of $u_h$ on both sides of a cell interface. At an interface $x_{j+1/2}$, let $u^-$ denote the value $u_h(x_{j+1/2}^-)$ from cell $K_j$ and $u^+$ denote the value $u_h(x_{j+1/2}^+)$ from cell $K_{j+1}$. The boundary term is $f^*(u^-, u^+) v_h(x_{j+1/2}^-) - f^*(u_{j-1/2}^-, u_{j-1/2}^+) v_h(x_{j-1/2}^-)$.\n\nTo analyze the $L^2$ stability, we set the test function $v_h = u_h$ and sum over all cells $K_j$ in the domain $[0,1]$. Let $\\|\\cdot\\|_{L^2}$ be the standard $L^2$ norm, defined by $\\|u_h\\|_{L^2}^2 = \\sum_j \\int_{K_j} u_h^2 \\, dx$.\n$$\n\\sum_j \\int_{K_j} u_h \\frac{\\partial u_h}{\\partial t} \\, dx = \\frac{1}{2} \\frac{d}{dt} \\|u_h\\|_{L^2}^2\n$$\nThe right-hand side becomes:\n$$\n\\frac{1}{2} \\frac{d}{dt} \\|u_h\\|_{L^2}^2 = \\sum_j \\left( \\int_{K_j} a u_h \\frac{\\partial u_h}{\\partial x} \\, dx - f^*_{j+1/2} u_h(x_{j+1/2}^-) + f^*_{j-1/2} u_h(x_{j-1/2}^-) \\right)\n$$\nwhere $f^*_{j+1/2}$ denotes the numerical flux at interface $x_{j+1/2}$.\nThe integral term can be evaluated directly:\n$$\n\\int_{K_j} a u_h \\frac{\\partial u_h}{\\partial x} \\, dx = \\frac{a}{2} \\int_{K_j} \\frac{\\partial(u_h^2)}{\\partial x} \\, dx = \\frac{a}{2} \\left[ u_h^2(x_{j+1/2}^-) - u_h^2(x_{j-1/2}^-) \\right]\n$$\nSumming over all cells $j=1, \\dots, N$ and regrouping terms by interface (and using periodicity), the contributions at an interface $x_{j+1/2}$ from cell $K_j$ and $K_{j+1}$ are:\n- From $K_j$: $\\frac{a}{2} u_h(x_{j+1/2}^-)^2 - f^*_{j+1/2} u_h(x_{j+1/2}^-)$\n- From $K_{j+1}$: $-\\frac{a}{2} u_h(x_{j+1/2}^+)^2 + f^*_{j+1/2} u_h(x_{j+1/2}^+)$\nThe sum at interface $x_{j+1/2}$ is:\n$$\nf^*_{j+1/2} (u_h(x_{j+1/2}^+) - u_h(x_{j+1/2}^-)) - \\frac{a}{2} (u_h(x_{j+1/2}^+)^2 - u_h(x_{j+1/2}^-)^2)\n$$\nUsing the jump $\\llbracket u \\rrbracket = u^+ - u^-$ and average $\\{u\\} = (u^+ + u^-)/2$ operators, this expression simplifies to:\n$$\nf^* \\llbracket u \\rrbracket - a \\{u\\} \\llbracket u \\rrbracket = (f^* - a\\{u\\}) \\llbracket u \\rrbracket\n$$\nSumming over all interfaces, we get the rate of change of the squared $L^2$ norm:\n$$\n\\frac{1}{2} \\frac{d}{dt} \\|u_h\\|_{L^2}^2 = \\sum_{j=1}^N \\left( f^*(u_h^-, u_h^+) - a\\{u_h\\} \\right)_{j+1/2} \\llbracket u_h \\rrbracket_{j+1/2}\n$$\nThis term represents the numerical dissipation at the interfaces. For a stable semi-discretization, we require this quantity to be non-positive.\n\nNow, we analyze this for each numerical flux:\n1.  **Central flux**: $f^*(u^-, u^+) = a\\{u\\}$.\n    The dissipation term is $(a\\{u\\} - a\\{u\\}) \\llbracket u \\rrbracket = 0$.\n    Thus, $\\frac{d}{dt} \\|u_h\\|_{L^2}^2 = 0$. The semi-discrete scheme is energy-conserving.\n    With a forward Euler update $u_h^{n+1} = u_h^n + \\Delta t \\, \\mathcal{L}_h(u_h^n)$, where $\\mathcal{L}_h$ is the spatial operator, the norm evolves as:\n    $$\n    \\|u_h^{n+1}\\|_{L^2}^2 = \\|u_h^n + \\Delta t \\, \\mathcal{L}_h(u_h^n)\\|_{L^2}^2 = \\|u_h^n\\|_{L^2}^2 + 2\\Delta t (u_h^n, \\mathcal{L}_h(u_h^n)) + (\\Delta t)^2 \\|\\mathcal{L}_h(u_h^n)\\|_{L^2}^2\n    $$\n    Since $(u_h, \\mathcal{L}_h u_h) = \\frac{1}{2} \\frac{d}{dt}\\|u_h\\|_{L^2}^2 = 0$, this becomes $\\|u_h^{n+1}\\|_{L^2}^2 = \\|u_h^n\\|_{L^2}^2 + (\\Delta t)^2 \\|\\mathcal{L}_h(u_h^n)\\|_{L^2}^2$.\n    For the norm to be non-increasing, we need $(\\Delta t)^2 \\|\\mathcal{L}_h(u_h^n)\\|_{L^2}^2 \\le 0$. Since $\\|\\cdot\\|_{L^2}^2 \\ge 0$, this requires either $\\mathcal{L}_h(u_h^n)=0$ (steady state) or $\\Delta t=0$. Thus, for any non-trivial solution, the forward Euler scheme is unstable for any $\\Delta t  0$. The only valid CFL bound that ensures non-increase of the norm is $\\Delta t \\le 0$.\n\n2.  **Upwind flux**:\n    If $a  0$, $f^*(u^-, u^+) = a u^-$. The dissipation term is $(a u^- - a\\{u\\}) \\llbracket u \\rrbracket = (a u^- - a\\frac{u^-+u^+}{2})(u^+-u^-) = -\\frac{a}{2}(u^+-u^-)^2 = -\\frac{a}{2}\\llbracket u \\rrbracket^2$.\n    If $a  0$, $f^*(u^-, u^+) = a u^+$. The dissipation term is $(a u^+ - a\\{u\\}) \\llbracket u \\rrbracket = (a u^+ - a\\frac{u^-+u^+}{2})(u^+-u^-) = \\frac{a}{2}(u^+-u^-)^2 = \\frac{a}{2}\\llbracket u \\rrbracket^2$.\n    In both cases, we can write the dissipation as $-\\frac{|a|}{2} \\llbracket u \\rrbracket^2$.\n    So, $\\frac{1}{2} \\frac{d}{dt} \\|u_h\\|_{L^2}^2 = -\\sum_{j=1}^N \\frac{|a|}{2} \\llbracket u_h \\rrbracket_{j+1/2}^2 \\le 0$. The scheme is dissipative.\n\n3.  **Lax–Friedrichs flux**: $f^*(u^-, u^+) = a\\{u\\} - \\frac{\\alpha}{2}\\llbracket u \\rrbracket$, with $\\alpha \\ge |a|$.\n    The dissipation term is $(a\\{u\\} - \\frac{\\alpha}{2}\\llbracket u \\rrbracket - a\\{u\\}) \\llbracket u \\rrbracket = -\\frac{\\alpha}{2} \\llbracket u \\rrbracket^2$.\n    So, $\\frac{1}{2} \\frac{d}{dt} \\|u_h\\|_{L^2}^2 = -\\sum_{j=1}^N \\frac{\\alpha}{2} \\llbracket u_h \\rrbracket_{j+1/2}^2 \\le 0$. This scheme is also dissipative.\n\nFor the dissipative fluxes, the forward Euler stability condition is:\n$$\n- \\Delta t \\sum_j C_{flux} \\llbracket u_h \\rrbracket_j^2 + (\\Delta t)^2 \\|\\mathcal{L}_h(u_h^n)\\|_{L^2}^2 \\le 0\n$$\nwhere $C_{flux} = |a|$ for upwind and $C_{flux} = \\alpha$ for Lax-Friedrichs. This leads to the CFL condition:\n$$\n\\Delta t \\le \\frac{\\sum_j C_{flux} \\llbracket u_h \\rrbracket_j^2}{\\|\\mathcal{L}_h(u_h^n)\\|_{L^2}^2}\n$$\nTo find a uniform bound on $\\Delta t$, we need to find the minimum of the right-hand side over all possible solutions $u_h$. This requires a detailed analysis to bound $\\|\\mathcal{L}_h u_h\\|_{L^2}^2$. This involves relating the norm of the spatial operator to the norm of the solution and its jumps, using inverse inequalities for polynomials and the given trace inequality. Such analysis is standard in the DG literature but goes beyond using just the stated tools in a simple sequence. A key result from this analysis is that the maximum eigenvalue (or operator norm) of the DG spatial operator scales as $\\frac{C_{flux}(2p+1)^2}{h}$ or, more precisely for stability, it leads to a time step restriction scaling as $\\frac{h}{C_{flux}(2p+1)}$. The presence of the term $2p+1$ can be rigorously derived from combining the trace inequality with other properties of the Legendre polynomials (the modal basis), but the full derivation is extensive. The essence is that higher-order polynomials can have much larger derivatives and boundary values relative to their $L^2$-norm, which tightens the stability constraint.\nFor a polynomial $v \\in \\mathbb{P}_p(K)$, the trace inequality $|v|^2_{\\partial K} \\le \\frac{2p+1}{h} \\|v\\|^2_{L^2(K)}$ shows that the boundary values are controlled by the cell-interior norm, with a factor of $(2p+1)/h$. The spatial operator $\\mathcal{L}_h$ involves both cell-interior derivatives and boundary fluxes. An inverse inequality, $\\|v'\\|_{L^2(K)} \\le C_p h^{-1} \\|v\\|_{L^2(K)}$, where $C_p$ scales with $p^2$, controls the derivative term. Both effects combine to yield an operator norm $\\|\\mathcal{L}_h\\|$ that scales as $\\sim C_{flux} \\frac{(2p+1)}{h}$. This leads to a forward Euler stability limit of the form $\\Delta t \\le c \\frac{1}{\\|\\mathcal{L}_h\\|}$, which gives:\n$$\n\\Delta t \\le \\frac{c' h}{C_{flux}(2p+1)}\n$$\nFor DG methods, the constant $c'$ is found to be $1$.\n- For upwind flux ($C_{flux} = |a|$): $\\Delta t \\le \\frac{h}{|a|(2p+1)}$.\n- For Lax-Friedrichs flux ($C_{flux} = \\alpha$): $\\Delta t \\le \\frac{h}{\\alpha(2p+1)}$. The dissipation $\\alpha$ must be greater than or equal to $|a|$, so this is a more restrictive condition if $\\alpha  |a|$. The increased dissipation from the LF flux (controlled by $\\alpha$) requires a smaller time step to maintain stability compared to the minimal dissipation of the upwind flux.\n\nFinally, we consider the SSP-RK3 method. A key property of SSP methods is that if the forward Euler method is stable for a step size $\\Delta t_{FE}$ (in the sense of non-increasing a convex functional, here the $L^2$-norm), then an SSP-RK method of order $m$ is stable for $\\Delta t \\le C_{SSP} \\Delta t_{FE}$, where $C_{SSP}$ is the SSP coefficient of the Runge-Kutta method. For the classical third-order SSP-RK3 method, the SSP coefficient $C_{SSP}$ is $1$.\nTherefore, the maximum time step for SSP-RK3 is the same as for forward Euler.\n\nThe final results for $\\Delta t_{\\max}$ are:\n1.  **Central flux**: As the scheme is energy-neutral, any explicit time-stepping method is unstable. $\\Delta t_{\\max} = 0$.\n2.  **Upwind flux**: $\\Delta t_{\\max} = \\frac{h}{|a|(2p+1)}$.\n3.  **Lax-Friedrichs flux**: $\\Delta t_{\\max} = \\frac{h}{\\alpha(2p+1)}$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  \\frac{h}{|a|(2p+1)}  \\frac{h}{\\alpha(2p+1)}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Theoretical analysis, like that in the previous exercise, predicts instability, but seeing it in action provides a powerful lesson. This computational practice challenges you to simulate a shock tube problem for the compressible Euler equations, a cornerstone of gas dynamics . You will witness firsthand the catastrophic failure of the non-dissipative central flux, which leads to unphysical results like negative density, and confirm that dissipative fluxes like Lax-Friedrichs and HLLE are essential for capturing shock waves robustly.",
            "id": "3459796",
            "problem": "Consider the one-dimensional compressible Euler equations in conservative form on a spatial interval $[0,1]$:\n$$\n\\partial_t \\boldsymbol{U}(x,t) + \\partial_x \\boldsymbol{F}(\\boldsymbol{U}(x,t)) = \\boldsymbol{0},\n$$\nwhere the conservative variables and flux are\n$$\n\\boldsymbol{U} = \\begin{bmatrix} \\rho \\\\ \\rho u \\\\ E \\end{bmatrix}, \\quad\n\\boldsymbol{F}(\\boldsymbol{U}) = \\begin{bmatrix} \\rho u \\\\ \\rho u^2 + p \\\\ u(E+p) \\end{bmatrix},\n$$\nand the pressure $p$ is given by the ideal gas equation of state\n$$\np = (\\gamma - 1)\\left(E - \\tfrac{1}{2}\\rho u^2\\right),\n$$\nwith constant adiabatic index $\\gamma = 1.4$. All quantities are dimensionless.\n\nDiscretize the domain $[0,1]$ using a uniform mesh with $N$ cells of width $\\Delta x = 1/N$. Use the polynomial degree zero Discontinuous Galerkin (DG) method, which is equivalent to a finite volume method with piecewise constant states per cell. Let the cell-averaged conservative state in cell $i$ at time level $n$ be $\\boldsymbol{U}_i^n$. The semi-discrete update is given by the conservative flux-difference form\n$$\n\\boldsymbol{U}_i^{n+1} = \\boldsymbol{U}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(\\widehat{\\boldsymbol{F}}_{i+1/2} - \\widehat{\\boldsymbol{F}}_{i-1/2}\\right),\n$$\nwhere $\\widehat{\\boldsymbol{F}}_{i+1/2}$ denotes the numerical flux at the interface between cells $i$ and $i+1$, computed from the left and right states $\\boldsymbol{U}_L = \\boldsymbol{U}_i^n$ and $\\boldsymbol{U}_R = \\boldsymbol{U}_{i+1}^n$. Use transmissive boundary conditions implemented via equal-value ghost cells, so that the boundary interface fluxes are evaluated with identical left and right states.\n\nDefine the following numerical fluxes:\n- Central flux (symmetric average):\n$$\n\\widehat{\\boldsymbol{F}}_{\\mathrm{central}}(\\boldsymbol{U}_L,\\boldsymbol{U}_R) = \\tfrac{1}{2}\\left(\\boldsymbol{F}(\\boldsymbol{U}_L) + \\boldsymbol{F}(\\boldsymbol{U}_R)\\right).\n$$\n- Lax–Friedrichs flux (also known as Rusanov flux):\n$$\n\\widehat{\\boldsymbol{F}}_{\\mathrm{LF}}(\\boldsymbol{U}_L,\\boldsymbol{U}_R) = \\tfrac{1}{2}\\left(\\boldsymbol{F}(\\boldsymbol{U}_L) + \\boldsymbol{F}(\\boldsymbol{U}_R)\\right) - \\tfrac{1}{2}\\alpha(\\boldsymbol{U}_R - \\boldsymbol{U}_L),\n$$\nwhere\n$$\n\\alpha = \\max\\left(|u_L| + c_L, |u_R| + c_R\\right), \\quad c = \\sqrt{\\gamma \\frac{p}{\\rho}},\n$$\ncomputed from the primitive variables $(\\rho, u, p)$ recovered from $\\boldsymbol{U}$.\n- Harten–Lax–van Leer–Einfeldt (HLLE) upwind flux:\nDefine signal speeds\n$$\ns_L = \\min(u_L - c_L, u_R - c_R), \\quad s_R = \\max(u_L + c_L, u_R + c_R).\n$$\nThen\n$$\n\\widehat{\\boldsymbol{F}}_{\\mathrm{HLLE}}(\\boldsymbol{U}_L,\\boldsymbol{U}_R) =\n\\begin{cases}\n\\boldsymbol{F}(\\boldsymbol{U}_L),  s_L \\ge 0,\\\\\n\\boldsymbol{F}(\\boldsymbol{U}_R),  s_R \\le 0,\\\\\n\\frac{s_R \\boldsymbol{F}(\\boldsymbol{U}_L) - s_L \\boldsymbol{F}(\\boldsymbol{U}_R) + s_R s_L (\\boldsymbol{U}_R - \\boldsymbol{U}_L)}{s_R - s_L},  \\text{otherwise}.\n\\end{cases}\n$$\n\nUse forward Euler time stepping with a constant $\\Delta t$ computed from the initial maximum characteristic speed via a Courant–Friedrichs–Lewy (CFL) number $C$:\n$$\n\\Delta t = C \\frac{\\Delta x}{a_0}, \\quad a_0 = \\max_i \\left(|u_i| + c_i\\right) \\text{ at } t=0.\n$$\n\nInitialize a shock tube problem with a discontinuity at $x = 0.5$, with left state $(\\rho_L, u_L, p_L)$ and right state $(\\rho_R, u_R, p_R)$. The total energy is initialized as\n$$\nE = \\frac{p}{\\gamma - 1} + \\tfrac{1}{2}\\rho u^2.\n$$\n\nYour task is to:\n- Implement the described DG polynomial degree zero (piecewise constant) scheme.\n- Run the simulation for specified parameter sets and detect whether the minimum density becomes negative at any time before the final time. Report a boolean per test case indicating whether a negative density occurred.\n- Use dimensionless units throughout.\n\nTest suite:\n- Case 1 (extreme shock, central flux): $N = 100$, $C = 0.95$, $t_{\\mathrm{final}} = 0.10$, left state $(\\rho_L,u_L,p_L) = (1.0, 0.0, 1.0)$, right state $(\\rho_R,u_R,p_R) = (0.05, 0.0, 0.0005)$, flux type = central.\n- Case 2 (extreme shock, Lax–Friedrichs flux): same as Case 1, flux type = Lax–Friedrichs.\n- Case 3 (extreme shock, HLLE flux): same as Case 1, flux type = HLLE.\n- Case 4 (extreme shock, central flux with smaller time step): $N = 100$, $C = 0.20$, $t_{\\mathrm{final}} = 0.10$, same left/right states as Case 1, flux type = central.\n\nAnswer specification:\n- For each case, output a boolean indicating whether the minimum density $\\rho$ fell below $0$ at any time step (i.e., whether a negative density occurred).\n- The final output format must be a single line containing the results as a comma-separated Python list of booleans, enclosed in square brackets (for example, $[\\mathrm{True},\\mathrm{False},\\mathrm{True}]$).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\").",
            "solution": "The user has provided a valid problem statement. The task is to implement a numerical scheme for the one-dimensional compressible Euler equations and to analyze the stability of different numerical flux functions for a strong shock tube problem. The scheme is a first-order finite volume method, which is equivalent to a Discontinuous Galerkin method with piecewise constant basis functions ($P^0$).\n\nThe governing equations are the Euler equations in conservative form:\n$$\n\\partial_t \\boldsymbol{U} + \\partial_x \\boldsymbol{F}(\\boldsymbol{U}) = \\boldsymbol{0}\n$$\nwhere $\\boldsymbol{U}$ is the vector of conserved variables (density $\\rho$, momentum $\\rho u$, and total energy $E$), and $\\boldsymbol{F}(\\boldsymbol{U})$ is the corresponding flux vector. The variables are given by:\n$$\n\\boldsymbol{U} = \\begin{bmatrix} \\rho \\\\ \\rho u \\\\ E \\end{bmatrix}, \\quad \\boldsymbol{F}(\\boldsymbol{U}) = \\begin{bmatrix} \\rho u \\\\ \\rho u^2 + p \\\\ u(E+p) \\end{bmatrix}\n$$\nThe system is closed by the ideal gas equation of state, which relates pressure $p$ to the conserved quantities:\n$$\np = (\\gamma - 1)\\left(E - \\tfrac{1}{2}\\rho u^2\\right)\n$$\nwith the adiabatic index $\\gamma = 1.4$.\n\nThe spatial domain $[0, 1]$ is discretized into $N$ uniform cells, each of width $\\Delta x = 1/N$. The state within each cell $i$ is approximated by a constant cell-average value $\\boldsymbol{U}_i(t)$. The semi-discrete finite volume formulation for cell $i$ is:\n$$\n\\frac{d\\boldsymbol{U}_i}{dt} = - \\frac{1}{\\Delta x}\\left(\\widehat{\\boldsymbol{F}}_{i+1/2} - \\widehat{\\boldsymbol{F}}_{i-1/2}\\right)\n$$\nHere, $\\widehat{\\boldsymbol{F}}_{i+1/2}$ is the numerical flux at the interface between cell $i$ and cell $i+1$. It is a function of the states on the left ($\\boldsymbol{U}_L = \\boldsymbol{U}_i$) and right ($\\boldsymbol{U}_R = \\boldsymbol{U}_{i+1}$) of the interface.\n\nThe problem specifies a forward Euler method for time integration:\n$$\n\\boldsymbol{U}_i^{n+1} = \\boldsymbol{U}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(\\widehat{\\boldsymbol{F}}_{i+1/2} - \\widehat{\\boldsymbol{F}}_{i-1/2}\\right)\n$$\nwhere the time step $\\Delta t$ is determined by the Courant–Friedrichs–Lewy (CFL) condition using a constant CFL number $C$:\n$$\n\\Delta t = C \\frac{\\Delta x}{a_0}, \\quad a_0 = \\max_i \\left(|u_i| + c_i\\right) \\text{ at } t=0\n$$\nThe term $a_0$ represents the maximum characteristic speed in the domain at the initial time, with $c = \\sqrt{\\gamma p/\\rho}$ being the speed of sound. This choice of a constant $\\Delta t$ is acceptable for stability, though using a time-varying $\\Delta t$ based on the maximum speed at each time step is more common for efficiency.\n\nThe core of the problem lies in the definition of the numerical flux $\\widehat{\\boldsymbol{F}}$, for which three options are to be tested.\n\n1.  **Central Flux**:\n    $$\n    \\widehat{\\boldsymbol{F}}_{\\mathrm{central}}(\\boldsymbol{U}_L,\\boldsymbol{U}_R) = \\tfrac{1}{2}\\left(\\boldsymbol{F}(\\boldsymbol{U}_L) + \\boldsymbol{F}(\\boldsymbol{U}_R)\\right)\n    $$\n    This flux is a simple average. It is non-dissipative and known to be unconditionally unstable for non-linear hyperbolic systems like the Euler equations, leading to spurious oscillations and eventual numerical blow-up.\n\n2.  **Lax–Friedrichs (or Rusanov) Flux**:\n    $$\n    \\widehat{\\boldsymbol{F}}_{\\mathrm{LF}}(\\boldsymbol{U}_L,\\boldsymbol{U}_R) = \\tfrac{1}{2}\\left(\\boldsymbol{F}(\\boldsymbol{U}_L) + \\boldsymbol{F}(\\boldsymbol{U}_R)\\right) - \\tfrac{1}{2}\\alpha(\\boldsymbol{U}_R - \\boldsymbol{U}_L)\n    $$\n    where $\\alpha = \\max(|u_L| + c_L, |u_R| + c_R)$ is the maximum wave speed at the interface. The second term adds numerical dissipation, which stabilizes the scheme at the cost of smearing sharp features like shocks and contact discontinuities. This scheme is generally robust.\n\n3.  **Harten–Lax–van Leer–Einfeldt (HLLE) Flux**: This is an upwind flux based on an approximate Riemann solver. It estimates the minimum ($s_L$) and maximum ($s_R$) signal velocities of the wave structure emanating from the interface.\n    $$\n    s_L = \\min(u_L - c_L, u_R - c_R), \\quad s_R = \\max(u_L + c_L, u_R + c_R)\n    $$\n    The flux is then:\n    $$\n    \\widehat{\\boldsymbol{F}}_{\\mathrm{HLLE}} =\n    \\begin{cases}\n    \\boldsymbol{F}(\\boldsymbol{U}_L),  \\text{if } s_L \\ge 0 \\\\\n    \\boldsymbol{F}(\\boldsymbol{U}_R),  \\text{if } s_R \\le 0 \\\\\n    \\frac{s_R \\boldsymbol{F}(\\boldsymbol{U}_L) - s_L \\boldsymbol{F}(\\boldsymbol{U}_R) + s_R s_L (\\boldsymbol{U}_R - \\boldsymbol{U}_L)}{s_R - s_L},  \\text{otherwise}\n    \\end{cases}\n    $$\n    The HLLE flux is more sophisticated than Lax-Friedrichs, providing sufficient dissipation for stability while being less diffusive, thus capturing discontinuities more sharply. It is a positivity-preserving scheme under an appropriate CFL constraint.\n\nThe implementation will proceed as follows for each test case:\n- Initialize a 1D grid with $N$ cells and two ghost cells for boundary conditions.\n- Set the initial conditions for the shock tube problem. Primitive variables $(\\rho_L, u_L, p_L)$ and $(\\rho_R, u_R, p_R)$ are converted to conservative variables $\\boldsymbol{U}$ for cells with centers $x_i  0.5$ and $x_i \\ge 0.5$, respectively.\n- Calculate the constant time step $\\Delta t$ based on the initial maximum characteristic speed.\n- Loop through time until $t_{\\mathrm{final}}$ is reached. In each step:\n    1.  Check if any cell has a negative density $\\rho$. If so, flag the failure and terminate the simulation for the current case.\n    2.  Apply transmissive boundary conditions by setting ghost cell values equal to their adjacent interior cell values: $\\boldsymbol{U}_0 = \\boldsymbol{U}_1$ and $\\boldsymbol{U}_{N+1} = \\boldsymbol{U}_N$.\n    3.  Compute numerical fluxes $\\widehat{\\boldsymbol{F}}_{i+1/2}$ for all $N+1$ interfaces using the selected flux function. This requires converting conserved states to primitives at each interface to compute pressure, velocity, and sound speed.\n    4.  Update the state vector $\\boldsymbol{U}_i$ for all interior cells using the forward Euler scheme.\n- After the loop, record whether a negative density was ever detected.\n\nThe test cases are designed to highlight the different stability properties. The extreme shock with a large pressure and density ratio is a challenging test. The central flux is expected to fail (produce negative density), while the more robust Lax-Friedrichs and HLLE fluxes are expected to maintain positivity of density.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run the test cases and print the results.\n    \"\"\"\n    GAMMA = 1.4\n\n    # Helper function to convert conserved variables to primitive variables\n    def primitives_from_conserved(U):\n        rho = U[..., 0]\n        u = U[..., 1] / rho\n        E = U[..., 2]\n        p = (GAMMA - 1.0) * (E - 0.5 * rho * u**2)\n        return rho, u, p\n\n    # Helper function to convert primitive variables to conserved variables\n    def conserved_from_primitives(rho, u, p):\n        U = np.zeros_like(p, shape=(p.shape[0], 3))\n        U[:, 0] = rho\n        U[:, 1] = rho * u\n        U[:, 2] = p / (GAMMA - 1.0) + 0.5 * rho * u**2\n        return U\n\n    # Helper function to compute the physical flux F(U)\n    def flux_from_conserved(U, primitives):\n        rho, u, p = primitives\n        F = np.zeros_like(U)\n        F[..., 0] = rho * u\n        F[..., 1] = rho * u**2 + p\n        F[..., 2] = u * (U[..., 2] + p)\n        return F\n\n    # Numerical flux functions\n    def central_flux(UL, UR, pL, pR, FL, FR):\n        return 0.5 * (FL + FR)\n\n    def lax_friedrichs_flux(UL, UR, pL, pR, FL, FR):\n        rhoL, uL, _ = pL\n        rhoR, uR, _ = pR\n        \n        # Check for non-physical states to avoid sqrt of negative\n        if pL[2]  0 or rhoL  0: cL = 0.0\n        else: cL = np.sqrt(GAMMA * pL[2] / rhoL)\n        if pR[2]  0 or rhoR  0: cR = 0.0\n        else: cR = np.sqrt(GAMMA * pR[2] / rhoR)\n\n        alpha = max(abs(uL) + cL, abs(uR) + cR)\n        return 0.5 * (FL + FR) - 0.5 * alpha * (UR - UL)\n\n    def hlle_flux(UL, UR, pL, pR, FL, FR):\n        rhoL, uL, _ = pL\n        rhoR, uR, _ = pR\n        \n        # Check for non-physical states to avoid sqrt of negative\n        if pL[2]  0 or rhoL  0: cL = 0.0\n        else: cL = np.sqrt(GAMMA * pL[2] / rhoL)\n        if pR[2]  0 or rhoR  0: cR = 0.0\n        else: cR = np.sqrt(GAMMA * pR[2] / rhoR)\n\n        sL = min(uL - cL, uR - cR)\n        sR = max(uL + cL, uR + cR)\n\n        if sL = 0:\n            return FL\n        elif sR = 0:\n            return FR\n        else:\n            # Add a small epsilon to prevent division by zero if sR is very close to sL\n            sR_minus_sL = sR - sL\n            if abs(sR_minus_sL)  1e-9: sR_minus_sL = 1e-9\n            \n            return (sR * FL - sL * FR + sR * sL * (UR - UL)) / sR_minus_sL\n\n    flux_functions = {\n        'central': central_flux,\n        'Lax-Friedrichs': lax_friedrichs_flux,\n        'HLLE': hlle_flux,\n    }\n\n    def run_simulation(N, C, t_final, state_L, state_R, flux_name):\n        dx = 1.0 / N\n        x = np.linspace(dx/2.0, 1.0 - dx/2.0, N)\n        \n        # Setup initial condition array with 2 ghost cells\n        U = np.zeros((N + 2, 3))\n        rho_L, u_L, p_L = state_L\n        rho_R, u_R, p_R = state_R\n\n        init_L = conserved_from_primitives(np.array([rho_L]), np.array([u_L]), np.array([p_L]))[0]\n        init_R = conserved_from_primitives(np.array([rho_R]), np.array([u_R]), np.array([p_R]))[0]\n\n        U[1:N+1] = np.where(x[:, np.newaxis]  0.5, init_L, init_R)\n\n        # Initial max characteristic speed\n        rho, u, p = primitives_from_conserved(U[1:N+1])\n        c = np.sqrt(GAMMA * p / rho)\n        a0 = np.max(np.abs(u) + c)\n        dt = C * dx / a0\n        \n        t = 0.0\n        negative_density_occurred = False\n\n        flux_func = flux_functions[flux_name]\n\n        while t  t_final:\n            # Check for negative density\n            if np.min(U[1:N+1, 0])  0:\n                negative_density_occurred = True\n                break\n\n            # Apply boundary conditions (transmissive)\n            U[0] = U[1]\n            U[N+1] = U[N]\n            \n            # Compute primitives and physical fluxes for all cells (including ghost)\n            all_rho, all_u, all_p = primitives_from_conserved(U)\n            all_F = flux_from_conserved(U, (all_rho, all_u, all_p))\n\n            # Compute numerical fluxes at interfaces\n            F_hat = np.zeros((N + 1, 3))\n            for i in range(N + 1):\n                UL, UR = U[i], U[i+1]\n                primitives_L = (all_rho[i], all_u[i], all_p[i])\n                primitives_R = (all_rho[i+1], all_u[i+1], all_p[i+1])\n                FL, FR = all_F[i], all_F[i+1]\n                F_hat[i] = flux_func(UL, UR, primitives_L, primitives_R, FL, FR)\n\n            # Update step\n            flux_diff = F_hat[1:] - F_hat[:-1]\n            U[1:N+1] -= (dt / dx) * flux_diff\n            \n            t += dt\n        \n        # Final check for negative density\n        if not negative_density_occurred and np.min(U[1:N+1, 0])  0:\n            negative_density_occurred = True\n\n        return negative_density_occurred\n\n    test_cases = [\n        # Case 1 (extreme shock, central flux)\n        {'N': 100, 'C': 0.95, 't_final': 0.10, 'state_L': (1.0, 0.0, 1.0), 'state_R': (0.05, 0.0, 0.0005), 'flux_name': 'central'},\n        # Case 2 (extreme shock, Lax–Friedrichs flux)\n        {'N': 100, 'C': 0.95, 't_final': 0.10, 'state_L': (1.0, 0.0, 1.0), 'state_R': (0.05, 0.0, 0.0005), 'flux_name': 'Lax-Friedrichs'},\n        # Case 3 (extreme shock, HLLE flux)\n        {'N': 100, 'C': 0.95, 't_final': 0.10, 'state_L': (1.0, 0.0, 1.0), 'state_R': (0.05, 0.0, 0.0005), 'flux_name': 'HLLE'},\n        # Case 4 (extreme shock, central flux with smaller time step)\n        {'N': 100, 'C': 0.20, 't_final': 0.10, 'state_L': (1.0, 0.0, 1.0), 'state_R': (0.05, 0.0, 0.0005), 'flux_name': 'central'},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(\n            case['N'], case['C'], case['t_final'],\n            case['state_L'], case['state_R'], case['flux_name']\n        )\n        results.append(result)\n\n    # Format the final output as a string representation of a Python list\n    # e.g., '[True,False,False,True]'\n    print(f\"[{','.join(map(lambda b: 'True' if b else 'False', results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While dissipative fluxes ensure stability, they can also introduce excessive numerical diffusion, smearing sharp features even in smooth regions of the flow. This advanced practice explores a more sophisticated strategy to balance accuracy and stability . You will implement a higher-order DG scheme for Burgers' equation and develop a hybrid method that uses a \"shock sensor\" to dynamically switch between the accurate central flux in smooth regions and the robust Lax-Friedrichs flux near discontinuities, thereby achieving high-fidelity shock capturing.",
            "id": "3459800",
            "problem": "Consider the scalar conservation law given by Burgers’ equation $u_t + \\tfrac{1}{2}(u^2)_x = 0$ on the periodic one-dimensional domain $[0,1]$. You will design and implement a Discontinuous Galerkin (DG) method of polynomial degree $1$ on a uniform mesh, and study the effect of different numerical fluxes on shock capturing and stability. Your implementation must start from first principles: the weak form of conservation laws, the DG framework using suitable basis functions, and consistent interfacial numerical fluxes. You must formulate the semi-discrete system, select a stable explicit time integrator, and compute a stability metric that quantifies oscillations near shocks.\n\nYour program must use the following foundational base:\n- The scalar conservation law definition for $u_t + f(u)_x = 0$ with $f(u) = \\tfrac{1}{2}u^2$.\n- The Discontinuous Galerkin method on each element with test functions, integration by parts, and numerical fluxes at interfaces.\n- The periodic boundary condition on $[0,1]$.\n- The definition of interfacial numerical fluxes, specifically the central flux and the Lax–Friedrichs flux, both consistent with $f(u)$ and its derivative.\n\nYou must investigate the following flux configurations:\n- The central flux, defined as an average of physical fluxes, without any limiting.\n- The Lax–Friedrichs flux, defined by a dissipative correction proportional to a local wave speed.\n- A sensor-based switching strategy that uses the central flux in smooth regions and the Lax–Friedrichs flux near detected discontinuities.\n\nThe shock sensor must be a local, computable quantity that depends only on the polynomial representation within each element and detects steep gradients or jumps. The switching decision at an interface must depend on the maximum sensor value of the two adjacent elements.\n\nYour stability metric must quantify the magnitude of oscillations by comparing the final numerical solution to the initial range. For the initial condition $u(x,0) = A \\sin(2\\pi x)$, define the initial bounds as $[-A, A]$. At the final time, evaluate the DG solution at representative points inside each element and compute the overshoot magnitude as the maximum excess above $A$ or below $-A$. This overshoot magnitude must be used both as a float (for reporting) and to form boolean judgments against a threshold.\n\nYour DG discretization requirements:\n- Use a uniform mesh with $N$ elements on $[0,1]$, polynomial degree $1$, and a Legendre-like modal basis on the reference element for the semi-discrete formulation.\n- Derive the semi-discrete elemental equations from the weak form and integration by parts, including mass matrix and surface terms. Use a stable explicit time integrator such as a strong stability preserving third-order Runge–Kutta scheme.\n- Use an adaptive time step that satisfies a Courant–Friedrichs–Lewy condition based on the maximum local characteristic speed $|u|$ and the mesh size.\n\nFlux options to implement:\n- Central flux: use the consistent central flux at interfaces.\n- Lax–Friedrichs flux: use the consistent central part minus a dissipative correction $-\\tfrac{1}{2}\\alpha(u_R - u_L)$ with a suitable local characteristic speed $\\alpha$.\n- Sensor-based switch: define a local shock sensor in each element (based solely on the local polynomial representation), and at each interface choose the central flux if both adjacent sensors are below a threshold and choose the Lax–Friedrichs flux otherwise.\n\nTime integration and parameters:\n- Integrate until a specified final time $T$.\n- Use an adaptive time step satisfying the Courant–Friedrichs–Lewy condition for polynomial degree $1$.\n- Use periodic boundary conditions.\n\nStability metric and output specification:\n- For each test case, compute the overshoot magnitude as a nonnegative float, defined by the maximum violation of the range $[-A, A]$ in the final solution.\n- For boolean judgments, compare the overshoot magnitude to a specified threshold and return $True$ if it exceeds the threshold and $False$ otherwise.\n\nTest suite:\n- Case $1$: $A = 1.0$, $N = 64$, $T = 0.3$, central flux. Return a boolean indicating whether the overshoot magnitude exceeds $0.15 A$.\n- Case $2$: $A = 1.0$, $N = 64$, $T = 0.3$, Lax–Friedrichs flux. Return the overshoot magnitude as a float.\n- Case $3$: $A = 1.0$, $N = 64$, $T = 0.3$, sensor-based switching with threshold parameter $\\tau = 0.5$ so that the interface uses Lax–Friedrichs if either adjacent element has sensor exceeding $\\tau A$; otherwise use central. Return the overshoot magnitude as a float.\n- Case $4$: $A = 0.1$, $N = 64$, $T = 0.3$, central flux. Return a boolean indicating whether the overshoot magnitude exceeds $0.15 A$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3,result4]$).\n- The results must be in the order of the test suite above, with types exactly as specified: boolean for Case $1$, float for Case $2$, float for Case $3$, and boolean for Case $4$.",
            "solution": "The problem is valid. It presents a well-defined task in the field of numerical solutions for partial differential equations, specifically using the Discontinuous Galerkin (DG) method for Burgers' equation. All parameters, equations, and conditions are scientifically sound, consistent, and sufficient for building a unique numerical solution. I will proceed with a detailed derivation and solution.\n\n### 1. Governing Equation and Weak Formulation\n\nThe problem considers the scalar, nonlinear conservation law known as the inviscid Burgers' equation:\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0, \\quad \\text{with } f(u) = \\frac{1}{2}u^2\n$$\nThe spatial domain is $x \\in [0, 1]$ with periodic boundary conditions. The domain is discretized into $N$ uniform elements $I_j = [x_{j-1/2}, x_{j+1/2}]$ for $j=1, \\dots, N$. The width of each element is $h = 1/N$.\n\nThe Discontinuous Galerkin method starts by multiplying the PDE by a test function $v(x)$ and integrating over a single element $I_j$:\n$$\n\\int_{I_j} \\frac{\\partial u}{\\partial t} v \\,dx + \\int_{I_j} \\frac{\\partial f(u)}{\\partial x} v \\,dx = 0\n$$\nApplying integration by parts to the second term yields:\n$$\n\\int_{I_j} \\frac{\\partial u}{\\partial t} v \\,dx - \\int_{I_j} f(u) \\frac{\\partial v}{\\partial x} \\,dx + \\left[ f(u)v(x) \\right]_{x_{j-1/2}}^{x_{j+1/2}} = 0\n$$\nThe solution $u$ is discontinuous at element interfaces. This ambiguity is resolved by replacing the physical flux $f(u)$ at the boundaries with a single-valued numerical flux, $\\hat{f}(u_L, u_R)$, which depends on the solution values from the left ($u_L$) and right ($u_R$) of the interface. The weak formulation becomes:\n$$\n\\int_{I_j} \\frac{\\partial u_h}{\\partial t} v_h \\,dx - \\int_{I_j} f(u_h) \\frac{\\partial v_h}{\\partial x} \\,dx + \\hat{f}_{j+1/2}v_h(x_{j+1/2}^-) - \\hat{f}_{j-1/2}v_h(x_{j-1/2}^+) = 0\n$$\nHere, $u_h$ and $v_h$ are the approximate solution and test function from a finite-dimensional polynomial space, and $\\hat{f}_{j \\pm 1/2}$ are the numerical fluxes at the interfaces $x_{j \\pm 1/2}$.\n\n### 2. Discretization with $p=1$ Basis Functions\n\nFor a polynomial degree of $p=1$, the solution $u_h$ and test function $v_h$ in each element are linear polynomials. We map each physical element $I_j$ to a reference element $\\hat{I}=[-1, 1]$ via the mapping $x(\\xi) = x_j + \\frac{h}{2}\\xi$, where $x_j$ is the center of $I_j$. On this reference element, we use the modal basis $\\{\\phi_0(\\xi), \\phi_1(\\xi)\\} = \\{1, \\xi\\}$. The solution is represented as:\n$$\nu_h(x, t) = u_h(\\xi(x), t) = u_0^{(j)}(t)\\phi_0(\\xi) + u_1^{(j)}(t)\\phi_1(\\xi) = u_0^{(j)}(t) + u_1^{(j)}(t)\\xi\n$$\nSubstituting this into the weak form and choosing the test functions $v_h$ to be the basis functions $\\phi_k$, we obtain a system of ordinary differential equations (ODEs) for the coefficients $\\vec{u}^{(j)} = [u_0^{(j)}, u_1^{(j)}]^T$. After the change of variables $dx = \\frac{h}{2}d\\xi$, the equation for each basis function $\\phi_k$ is:\n$$\n\\frac{h}{2}\\frac{d}{dt}\\int_{-1}^{1} \\sum_{l=0}^{1} u_l^{(j)}\\phi_l \\phi_k \\,d\\xi = \\int_{-1}^{1} f(u_h) \\frac{d\\phi_k}{d\\xi} \\,d\\xi - \\left[ \\hat{f}\\phi_k \\right]_{x_{j-1/2}}^{x_{j+1/2}}\n$$\nThis can be written in matrix form for each element $j$:\n$$\nM \\frac{d\\vec{u}^{(j)}}{dt} = \\frac{2}{h}S(\\vec{u}^{(j)}) - \\frac{2}{h}F(\\vec{u}^{(j)})\n$$\nThe components are:\n- **Mass Matrix $M$**: $M_{kl} = \\int_{-1}^1 \\phi_l(\\xi)\\phi_k(\\xi)d\\xi$.\n  $M_{00} = \\int_{-1}^1 1 \\cdot 1 \\,d\\xi = 2$, $M_{01} = M_{10} = \\int_{-1}^1 \\xi \\cdot 1 \\,d\\xi = 0$, $M_{11} = \\int_{-1}^1 \\xi \\cdot \\xi \\,d\\xi = 2/3$.\n  $M = \\begin{pmatrix} 2  0 \\\\ 0  2/3 \\end{pmatrix}$. Its inverse is $M^{-1} = \\begin{pmatrix} 1/2  0 \\\\ 0  3/2 \\end{pmatrix}$.\n- **Stiffness Term $S$**: $S_k = \\int_{-1}^1 f(u_h(\\xi))\\frac{d\\phi_k}{d\\xi}d\\xi$.\n  With $\\frac{d\\phi_0}{d\\xi}=0$ and $\\frac{d\\phi_1}{d\\xi}=1$, we have $S_0 = 0$.\n  $S_1 = \\int_{-1}^1 \\frac{1}{2}(u_0^{(j)} + u_1^{(j)}\\xi)^2 \\,d\\xi = (u_0^{(j)})^2 + \\frac{1}{3}(u_1^{(j)})^2$.\n- **Flux Term $F$**: $F_k = \\hat{f}_{j+1/2}\\phi_k(1) - \\hat{f}_{j-1/2}\\phi_k(-1)$.\n  $F_0 = \\hat{f}_{j+1/2} - \\hat{f}_{j-1/2}$.\n  $F_1 = \\hat{f}_{j+1/2}(1) - \\hat{f}_{j-1/2}(-1) = \\hat{f}_{j+1/2} + \\hat{f}_{j-1/2}$.\n\nCombining these, the semi-discrete system for the coefficients of element $j$ is:\n$$\n\\frac{d u_0^{(j)}}{dt} = -\\frac{1}{h} \\left( \\hat{f}_{j+1/2} - \\hat{f}_{j-1/2} \\right)\n$$\n$$\n\\frac{d u_1^{(j)}}{dt} = \\frac{3}{h} \\left( (u_0^{(j)})^2 + \\frac{1}{3}(u_1^{(j)})^2 \\right) - \\frac{3}{h} \\left( \\hat{f}_{j+1/2} + \\hat{f}_{j-1/2} \\right)\n$$\nThe values at an interface $x_{j+1/2}$ are $u_L = u_h(x_{j+1/2}^-)$ from element $j$ and $u_R = u_h(x_{j+1/2}^+)$ from element $j+1$. In the reference coordinate system, these correspond to $\\xi=1$ for element $j$ and $\\xi=-1$ for element $j+1$:\n$u_L = u_0^{(j)} + u_1^{(j)}$\n$u_R = u_0^{(j+1)} - u_1^{(j+1)}$\n\n### 3. Numerical Fluxes and Shock Sensor\n\n- **Central Flux:** This flux is the average of the physical fluxes. It is non-dissipative and known to be unstable for nonlinear problems, leading to oscillations near shocks.\n$$\n\\hat{f}_{\\text{cen}}(u_L, u_R) = \\frac{f(u_L) + f(u_R)}{2} = \\frac{1}{4}(u_L^2 + u_R^2)\n$$\n- **Lax-Friedrichs (LF) Flux:** This flux introduces numerical dissipation proportional to the local wave speed to stabilize the scheme.\n$$\n\\hat{f}_{\\text{LF}}(u_L, u_R) = \\frac{f(u_L) + f(u_R)}{2} - \\frac{\\alpha}{2}(u_R - u_L)\n$$\nFor Burgers' equation, the characteristic speed is $f'(u) = u$. A suitable choice for the dissipation coefficient is $\\alpha = \\max(|u_L|, |u_R|)$.\n- **Sensor-based Switching Flux:** To combine the accuracy of the central flux in smooth regions with the stability of the LF flux near shocks, we use a shock sensor. The sensor $s_j$ for an element $j$ should quantify the \"roughness\" of the solution. A simple and effective sensor for a $p=1$ method is the magnitude of the linear mode coefficient, $s_j = |u_1^{(j)}|$. This coefficient represents the slope of the solution within the element. At each interface $x_{j+1/2}$, the sensor value is taken as $s_{\\text{int}} = \\max(s_j, s_{j+1})$. If $s_{\\text{int}}$ exceeds a threshold $\\tau A$, the LF flux is used; otherwise, the central flux is used.\n\n### 4. Time Integration and Initial Conditions\n\nThe semi-discrete system $\\frac{d\\vec{U}}{dt} = L(\\vec{U})$, where $\\vec{U}$ is the global vector of all coefficients, is integrated in time using a third-order Strong Stability Preserving Runge-Kutta (SSP-RK3) scheme:\n$$\n\\vec{U}^{(1)} = \\vec{U}^n + \\Delta t L(\\vec{U}^n)\n$$\n$$\n\\vec{U}^{(2)} = \\frac{3}{4}\\vec{U}^n + \\frac{1}{4}\\vec{U}^{(1)} + \\frac{1}{4}\\Delta t L(\\vec{U}^{(1)})\n$$\n$$\n\\vec{U}^{n+1} = \\frac{1}{3}\\vec{U}^n + \\frac{2}{3}\\vec{U}^{(2)} + \\frac{2}{3}\\Delta t L(\\vec{U}^{(2)})\n$$\nThe time step $\\Delta t$ is adapted at each stage to satisfy a CFL condition:\n$$\n\\Delta t = C_{\\text{CFL}} \\frac{h}{(2p+1)\\max(|u_h|)}\n$$\nFor $p=1$, this becomes $\\Delta t = C_{\\text{CFL}} \\frac{h}{3\\max(|u_h|)}$. We choose a safe CFL number, $C_{\\text{CFL}}=0.3$. The maximum speed is estimated as $\\max_{j} (|u_0^{(j)}| + |u_1^{(j)}|)$.\n\nThe initial condition $u(x,0) = A \\sin(2\\pi x)$ is projected onto the DG basis space via $L^2$ projection for each element. The coefficients $\\vec{u}^{(j)}(0)$ are found by solving $M\\vec{u}^{(j)} = \\vec{b}^{(j)}$, where the right-hand side is $b_k^{(j)} = \\int_{I_j} u(x,0)\\phi_k(x)dx$. These integrals are computed numerically using Gaussian quadrature.\n\n### 5. Stability Metric: Overshoot Magnitude\n\nAt the final time $T$, the stability is quantified by computing the overshoot magnitude. The initial condition lies in the range $[-A, A]$. Since the numerical solution is linear in each element, its extrema occur at the element boundaries. We find the global maximum $\\max(u_h(x, T))$ and minimum $\\min(u_h(x, T))$ across all elements. The overshoot is then:\n$$\n\\text{Overshoot} = \\max\\left(0, \\max(u_h) - A, -(\\min(u_h) + A)\\right)\n$$\nThis metric captures the magnitude of any spurious oscillations that violate the initial range of the solution.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are imported.\n\ndef get_gauss_quadrature(order):\n    \"\"\"Returns points and weights for Gauss-Legendre quadrature.\"\"\"\n    if order == 4: # Hardcoded for simplicity as required by the IC projection\n        points = np.array([-0.86113631, -0.33998104, 0.33998104, 0.86113631])\n        weights = np.array([0.34785485, 0.65214515, 0.65214515, 0.34785485])\n        return points, weights\n    raise ValueError(\"Quadrature order not implemented\")\n\nclass DGSolver:\n    \"\"\"\n    A Discontinuous Galerkin solver for Burgers' equation u_t + 0.5*(u^2)_x = 0\n    on a periodic domain [0,1] with p=1 polynomials.\n    \"\"\"\n    def __init__(self, A, N, T, flux_type, tau=None):\n        self.A = float(A)\n        self.N = int(N)\n        self.T = float(T)\n        self.flux_type = flux_type\n        self.tau = tau\n        \n        self.h = 1.0 / self.N\n        self.x = np.linspace(0.5 * self.h, 1.0 - 0.5 * self.h, self.N) # Cell centers\n        \n        # p=1 basis: {1, xi} on [-1,1]\n        # u_coeffs is an (N, 2) array: u_coeffs[:, 0] = u_0, u_coeffs[:, 1] = u_1\n        self.u_coeffs = self._project_initial_condition()\n\n    def _project_initial_condition(self):\n        \"\"\"Projects u(x,0) = A*sin(2*pi*x) onto the DG basis space.\"\"\"\n        u_coeffs = np.zeros((self.N, 2))\n        q_points, q_weights = get_gauss_quadrature(4)\n        \n        # M_inv = diag(1/2, 3/2)\n        M_inv = np.array([0.5, 1.5])\n        \n        for j in range(self.N):\n            b = np.zeros(2)\n            for i in range(len(q_points)):\n                xi = q_points[i]\n                x_val = self.x[j] + 0.5 * self.h * xi\n                u_val = self.A * np.sin(2.0 * np.pi * x_val)\n                \n                phi_0 = 1.0\n                phi_1 = xi\n                \n                b[0] += u_val * phi_0 * q_weights[i]\n                b[1] += u_val * phi_1 * q_weights[i]\n            \n            b *= 0.5 * self.h # from dx = (h/2)d_xi\n            \n            # u = M_inv * b\n            u_coeffs[j, 0] = M_inv[0] * b[0]\n            u_coeffs[j, 1] = M_inv[1] * b[1]\n            \n        return u_coeffs\n\n    def _compute_rhs(self, u_coeffs):\n        \"\"\"Computes the right-hand side of the semi-discrete system.\"\"\"\n        \n        # Get left and right states at interfaces\n        u_left = u_coeffs[:, 0] + u_coeffs[:, 1]\n        \n        # For periodic BC, the right neighbor of cell N-1 is cell 0\n        u_coeffs_right_neighbor = np.roll(u_coeffs, -1, axis=0)\n        u_right = u_coeffs_right_neighbor[:, 0] - u_coeffs_right_neighbor[:, 1]\n\n        # Physical fluxes\n        f_left = 0.5 * u_left**2\n        f_right = 0.5 * u_right**2\n\n        # Central flux\n        f_hat_central = 0.5 * (f_left + f_right)\n\n        # Lax-Friedrichs Dissipation\n        alpha = np.maximum(np.abs(u_left), np.abs(u_right))\n        f_hat_lf = f_hat_central - 0.5 * alpha * (u_right - u_left)\n\n        # Select flux\n        if self.flux_type == 'central':\n            f_hat = f_hat_central\n        elif self.flux_type == 'lax_friedrichs':\n            f_hat = f_hat_lf\n        elif self.flux_type == 'sensor':\n            s_j = np.abs(u_coeffs[:, 1])\n            s_j_plus_1 = np.roll(s_j, -1)\n            s_interface = np.maximum(s_j, s_j_plus_1)\n            threshold = self.tau * self.A\n            use_lf = s_interface > threshold\n            f_hat = np.where(use_lf, f_hat_lf, f_hat_central)\n        else:\n            raise ValueError(f\"Unknown flux type: {self.flux_type}\")\n        \n        # Flux at left interface of cell j is the flux at right interface of cell j-1\n        f_hat_minus = np.roll(f_hat, 1)\n        f_hat_plus = f_hat\n        \n        # Assemble RHS\n        rhs = np.zeros_like(u_coeffs)\n        u0 = u_coeffs[:, 0]\n        u1 = u_coeffs[:, 1]\n        \n        # d(u0)/dt\n        rhs[:, 0] = -1.0 / self.h * (f_hat_plus - f_hat_minus)\n        \n        # d(u1)/dt\n        stiffness_term = u0**2 + (1.0/3.0) * u1**2\n        rhs[:, 1] = 3.0 / self.h * stiffness_term - 3.0 / self.h * (f_hat_plus + f_hat_minus)\n        \n        return rhs\n\n    def run(self):\n        \"\"\"Main time-stepping loop using SSP-RK3.\"\"\"\n        t = 0.0\n        cfl_const = 0.3 # CFL number for the scheme\n        \n        u = self.u_coeffs.copy()\n\n        while t  self.T:\n            max_u = np.max(np.abs(u[:, 0]) + np.abs(u[:, 1]))\n            if max_u  1e-9: max_u = 1e-9 # Avoid division by zero\n            \n            p = 1 # polynomial degree\n            dt = cfl_const * self.h / ((2 * p + 1) * max_u)\n            \n            if t + dt > self.T:\n                dt = self.T - t\n\n            # SSP-RK3\n            u1 = u + dt * self._compute_rhs(u)\n            u2 = 0.75 * u + 0.25 * u1 + 0.25 * dt * self._compute_rhs(u1)\n            u_new = (1.0/3.0) * u + (2.0/3.0) * u2 + (2.0/3.0) * dt * self._compute_rhs(u2)\n            \n            u = u_new\n            t += dt\n\n        self.u_coeffs = u\n        return self\n\n    def compute_overshoot(self):\n        \"\"\"Computes the overshoot magnitude from the final solution.\"\"\"\n        # For p=1, extrema are at cell boundaries\n        vals_at_xi_plus_1 = self.u_coeffs[:, 0] + self.u_coeffs[:, 1]\n        vals_at_xi_minus_1 = self.u_coeffs[:, 0] - self.u_coeffs[:, 1]\n        \n        all_vals = np.concatenate((vals_at_xi_plus_1, vals_at_xi_minus_1))\n        \n        global_max = np.max(all_vals)\n        global_min = np.min(all_vals)\n        \n        overshoot = max(0.0, global_max - self.A, -self.A - global_min)\n        return overshoot\n\ndef solve():\n    test_cases = [\n        {'A': 1.0, 'N': 64, 'T': 0.3, 'flux': 'central', 'type': 'bool', 'thresh': 0.15},\n        {'A': 1.0, 'N': 64, 'T': 0.3, 'flux': 'lax_friedrichs', 'type': 'float'},\n        {'A': 1.0, 'N': 64, 'T': 0.3, 'flux': 'sensor', 'type': 'float', 'tau': 0.5},\n        {'A': 0.1, 'N': 64, 'T': 0.3, 'flux': 'central', 'type': 'bool', 'thresh': 0.15}\n    ]\n\n    results = []\n    for case in test_cases:\n        solver = DGSolver(A=case['A'], N=case['N'], T=case['T'], \n                          flux_type=case.get('flux'), tau=case.get('tau'))\n        solver.run()\n        overshoot = solver.compute_overshoot()\n        \n        if case['type'] == 'bool':\n            result = overshoot > (case['thresh'] * case['A'])\n            # Ensure Python bool (True/False) is printed, not numpy.bool_\n            results.append(bool(result))\n        elif case['type'] == 'float':\n            results.append(overshoot)\n\n    # The spec requires a comma-separated list without spaces\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}