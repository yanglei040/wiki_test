{
    "hands_on_practices": [
        {
            "introduction": "Before relying on automated software to generate differentiation matrices, it's crucial to understand their construction from first principles. This exercise provides a hands-on, pencil-and-paper walkthrough of building a Legendre-Gauss-Lobatto differentiation matrix for a small grid. By calculating the nodes, barycentric weights, and matrix entries yourself, you will gain a concrete understanding of the theory behind these powerful numerical tools.",
            "id": "3437283",
            "problem": "Consider the construction of the first-derivative pseudospectral differentiation matrix for the Legendre–Gauss–Lobatto (LGL) grid associated with the Legendre polynomial of degree $N=4$. This matrix underpins the pseudospectral method for the numerical solution of partial differential equations (PDEs) on the interval $[-1,1]$.\n\nStarting only from the following foundational elements:\n- The definition of the Legendre polynomials $\\{P_n(x)\\}_{n \\ge 0}$ as the unique polynomials orthogonal on $[-1,1]$ with respect to the unit weight and normalized by $P_n(1)=1$.\n- The definition of the LGL nodes $\\{x_j\\}_{j=0}^{N}$ as the union of the endpoints $\\{-1,1\\}$ and the zeros of $P_N'(x)$.\n- The nodal polynomial $\\phi(x)$ associated with the LGL grid as $\\phi(x) \\propto (1-x^2)P_N'(x)$ (up to a nonzero multiplicative constant), and the barycentric weights $\\{\\lambda_j\\}_{j=0}^{N}$ defined, up to a common nonzero factor, by $\\lambda_j = 1/\\phi'(x_j)$.\n- The barycentric first-derivative differentiation matrix $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ defined by\n  $$\n  D_{ij}=\\frac{\\lambda_j}{\\lambda_i(x_i-x_j)} \\quad \\text{for } i\\neq j, \n  \\qquad \n  D_{ii}=-\\sum_{\\substack{j=0\\\\ j\\neq i}}^{N} D_{ij},\n  $$\nderive and carry out the following steps for $N=4$:\n\n1. Compute explicitly the nodes $x_j$ (with the ordering $x_0=-1$, $x_4=1$ and increasing in between), and evaluate $P_4'(x_j)$ at each node.\n2. Compute $\\phi'(x)$ and then $\\{\\lambda_j\\}_{j=0}^{4}$ up to a common nonzero multiplicative constant by evaluating $\\lambda_j=1/\\phi'(x_j)$.\n3. Using the barycentric formula for $D$, verify numerically (by exact arithmetic on your computed quantities) that $D\\mathbf{1}=\\mathbf{0}$ and $D\\mathbf{x}=\\mathbf{1}$, where $\\mathbf{1}=(1,1,1,1,1)^{\\top}$ and $\\mathbf{x}=(x_0,x_1,x_2,x_3,x_4)^{\\top}$.\n4. With the node indexing $i,j\\in\\{0,1,2,3,4\\}$ as above, determine the single entry $D_{2,4}$ exactly.\n\nProvide your final result as the exact value of $D_{2,4}$; no rounding is required, and no physical units are involved. Express angles, if any arise, in radians (though none are expected here).",
            "solution": "The solution process follows the four steps outlined in the problem statement.\n\n#### 1. Compute nodes $x_j$ and evaluate $P_4'(x_j)$\n\nFirst, we require the Legendre polynomial of degree $N=4$, denoted $P_4(x)$. The Legendre polynomials can be generated by various means; a common form is $P_4(x) = \\frac{1}{8}(35x^4 - 30x^2 + 3)$. This polynomial satisfies the normalization condition $P_4(1) = \\frac{1}{8}(35-30+3) = 1$.\n\nThe derivative, $P_4'(x)$, is:\n$$\nP_4'(x) = \\frac{d}{dx} \\left[ \\frac{1}{8}(35x^4 - 30x^2 + 3) \\right] = \\frac{1}{8}(140x^3 - 60x) = \\frac{5}{2}(7x^3 - 3x) = \\frac{5}{2}x(7x^2 - 3)\n$$\nThe LGL nodes for $N=4$ are the endpoints $x=-1$ and $x=1$, along with the zeros of $P_4'(x)$. We find the zeros by setting $P_4'(x)=0$:\n$$\n\\frac{5}{2}x(7x^2 - 3) = 0\n$$\nThis gives $x=0$ and $7x^2-3=0$, which implies $x^2 = 3/7$, or $x = \\pm\\sqrt{\\frac{3}{7}}$.\nThe set of five LGL nodes $\\{x_j\\}_{j=0}^4$, sorted in increasing order, is:\n$$\nx_0 = -1, \\quad x_1 = -\\sqrt{\\frac{3}{7}}, \\quad x_2 = 0, \\quad x_3 = \\sqrt{\\frac{3}{7}}, \\quad x_4 = 1\n$$\nNext, we evaluate $P_4'(x)$ at these nodes:\n- $P_4'(x_0) = P_4'(-1) = \\frac{5}{2}(-1)(7(-1)^2 - 3) = \\frac{5}{2}(-1)(4) = -10$.\n- $P_4'(x_1) = P_4'(-\\sqrt{3/7}) = 0$, since $x_1$ is a root of $P_4'(x)$.\n- $P_4'(x_2) = P_4'(0) = 0$, since $x_2$ is a root of $P_4'(x)$.\n- $P_4'(x_3) = P_4'(\\sqrt{3/7}) = 0$, since $x_3$ is a root of $P_4'(x)$.\n- $P_4'(x_4) = P_4'(1) = \\frac{5}{2}(1)(7(1)^2 - 3) = \\frac{5}{2}(1)(4) = 10$.\n\n#### 2. Compute $\\phi'(x)$ and weights $\\lambda_j$\n\nThe nodal polynomial is $\\phi(x) \\propto (1-x^2)P_N'(x)$. Let's choose the constant of proportionality to be $1$, so $\\phi(x) = (1-x^2)P_4'(x)$. The derivative $\\phi'(x)$ is required. A key property related to Legendre polynomials, derivable from the Legendre differential equation $(1-x^2)y'' - 2xy' + n(n+1)y=0$ with $y=P_n(x)$, is that $\\frac{d}{dx}[(1-x^2)P_n'(x)] = -n(n+1)P_n(x)$.\nTherefore, for $N=4$:\n$$\n\\phi'(x) = \\frac{d}{dx}[(1-x^2)P_4'(x)] = -4(4+1)P_4(x) = -20P_4(x)\n$$\nThe barycentric weights are $\\lambda_j = 1/\\phi'(x_j) = 1/(-20P_4(x_j))$, up to a multiplicative constant. For simplicity, we can choose a constant such that the weights are simpler. Let's choose the constant to be $-20$, which gives $\\lambda_j = 1/P_4(x_j)$. We now evaluate $P_4(x)$ at the LGL nodes:\n- $P_4(x_0) = P_4(-1) = 1$ (by property of Legendre polynomials).\n- $P_4(x_4) = P_4(1) = 1$ (by normalization).\n- $P_4(x_2) = P_4(0) = \\frac{1}{8}(35(0)^4 - 30(0)^2 + 3) = \\frac{3}{8}$.\n- For $x_{1,3} = \\mp\\sqrt{3/7}$, we have $x^2 = 3/7$.\n  $P_4(x_{1,3}) = \\frac{1}{8}\\left(35\\left(\\frac{3}{7}\\right)^2 - 30\\left(\\frac{3}{7}\\right) + 3\\right) = \\frac{1}{8}\\left(35\\frac{9}{49} - \\frac{90}{7} + 3\\right) = \\frac{1}{8}\\left(\\frac{45}{7} - \\frac{90}{7} + \\frac{21}{7}\\right) = \\frac{1}{8}\\left(\\frac{-24}{7}\\right) = -\\frac{3}{7}$.\nSo, $P_4(x_1) = P_4(x_3) = -3/7$.\n\nUsing our choice $\\lambda_j = 1/P_4(x_j)$, the weights are:\n- $\\lambda_0 = \\frac{1}{P_4(x_0)} = \\frac{1}{1} = 1$.\n- $\\lambda_1 = \\frac{1}{P_4(x_1)} = \\frac{1}{-3/7} = -\\frac{7}{3}$.\n- $\\lambda_2 = \\frac{1}{P_4(x_2)} = \\frac{1}{3/8} = \\frac{8}{3}$.\n- $\\lambda_3 = \\frac{1}{P_4(x_3)} = \\frac{1}{-3/7} = -\\frac{7}{3}$.\n- $\\lambda_4 = \\frac{1}{P_4(x_4)} = \\frac{1}{1} = 1$.\n\n#### 3. Verify $D\\mathbf{1}=\\mathbf{0}$ and $D\\mathbf{x}=\\mathbf{1}$\n\nFirst, we verify $D\\mathbf{1}=\\mathbf{0}$, where $\\mathbf{1}=(1,1,1,1,1)^{\\top}$. The $i$-th component of the vector $D\\mathbf{1}$ is $\\sum_{j=0}^4 D_{ij}$.\n$$\n(D\\mathbf{1})_i = \\sum_{j=0}^{4} D_{ij} = D_{ii} + \\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} D_{ij}\n$$\nBy definition, $D_{ii} = -\\sum_{j \\neq i} D_{ij}$. Substituting this into the sum gives:\n$$\n(D\\mathbf{1})_i = \\left(-\\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} D_{ij}\\right) + \\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} D_{ij} = 0\n$$\nThis holds for any $i \\in \\{0, 1, 2, 3, 4\\}$, so $D\\mathbf{1}=\\mathbf{0}$. This identity is true by construction of the matrix $D$ and does not depend on the specific values of $x_j$ or $\\lambda_j$.\n\nSecond, we verify $D\\mathbf{x}=\\mathbf{1}$, where $\\mathbf{x}=(x_0,x_1,x_2,x_3,x_4)^{\\top}$. This property holds if the differentiation matrix exactly differentiates polynomials of degree $1$. The vector $\\mathbf{x}$ represents the function $f(x)=x$ sampled at the nodes, and $\\mathbf{1}$ represents its derivative $f'(x)=1$ sampled at the nodes.\nThe $i$-th component of $D\\mathbf{x}$ is:\n$$\n(D\\mathbf{x})_i = \\sum_{j=0}^{4} D_{ij}x_j = D_{ii}x_i + \\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} D_{ij}x_j\n$$\nUsing the definition of $D_{ii}$:\n$$\n(D\\mathbf{x})_i = \\left(-\\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} D_{ij}\\right)x_i + \\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} D_{ij}x_j = \\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} D_{ij}(x_j - x_i)\n$$\nNow, substitute the definition of the off-diagonal entries, $D_{ij} = \\frac{\\lambda_j}{\\lambda_i(x_i-x_j)}$ for $i \\neq j$:\n$$\n(D\\mathbf{x})_i = \\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} \\frac{\\lambda_j}{\\lambda_i(x_i-x_j)}(x_j - x_i) = \\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} \\frac{\\lambda_j}{\\lambda_i}(-1) = -\\frac{1}{\\lambda_i} \\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} \\lambda_j\n$$\nFor $(D\\mathbf{x})_i$ to be equal to $1$, we must have $-\\frac{1}{\\lambda_i} \\sum_{j \\neq i} \\lambda_j = 1$, which implies $\\sum_{j \\neq i} \\lambda_j = -\\lambda_i$. This is equivalent to requiring that the sum of all weights is zero: $\\sum_{j=0}^4 \\lambda_j = 0$.\nLet's verify this numerically with our computed weights:\n$$\n\\sum_{j=0}^{4} \\lambda_j = \\lambda_0 + \\lambda_1 + \\lambda_2 + \\lambda_3 + \\lambda_4 = 1 + \\left(-\\frac{7}{3}\\right) + \\frac{8}{3} + \\left(-\\frac{7}{3}\\right) + 1 = 2 + \\frac{-7+8-7}{3} = 2 + \\frac{-6}{3} = 2 - 2 = 0\n$$\nThe sum is indeed zero, which verifies that $D\\mathbf{x}=\\mathbf{1}$.\n\n#### 4. Determine the single entry $D_{2,4}$\n\nWe need to compute the entry $D_{ij}$ of the differentiation matrix for row index $i=2$ and column index $j=4$. The formula for an off-diagonal entry is:\n$$\nD_{ij} = \\frac{\\lambda_j}{\\lambda_i(x_i - x_j)}\n$$\nFor $i=2$ and $j=4$, we use the corresponding nodes and weights:\n- $x_2 = 0$\n- $x_4 = 1$\n- $\\lambda_2 = 8/3$\n- $\\lambda_4 = 1$\n\nPlugging these values into the formula:\n$$\nD_{2,4} = \\frac{\\lambda_4}{\\lambda_2(x_2 - x_4)} = \\frac{1}{\\frac{8}{3}(0 - 1)} = \\frac{1}{-\\frac{8}{3}} = -\\frac{3}{8}\n$$\nThe exact value of the entry $D_{2,4}$ is $-3/8$.",
            "answer": "$$\n\\boxed{-\\frac{3}{8}}\n$$"
        },
        {
            "introduction": "We now move from manual construction to computational implementation, exploring the properties of the Fourier pseudospectral method. This practice guides you to build a differentiation matrix in code and apply it to various periodic functions. You will witness the remarkable 'spectral accuracy' for well-resolved functions and also investigate critical limitations, such as aliasing at the Nyquist frequency, which are essential to understand for robust numerical work.",
            "id": "3437316",
            "problem": "Consider the periodic interval $[0,2\\pi)$ with angles measured in radians. Let $N$ be the number of equispaced collocation points, and define the grid $x_j = \\frac{2\\pi j}{N}$ for $j=0,1,\\dots,N-1$. The Fourier pseudospectral differentiation matrix is the linear operator that maps sampled values of a sufficiently smooth $2\\pi$-periodic function at $\\{x_j\\}$ to the sampled values of its derivative at the same points. Starting from the definitions of the trigonometric interpolant and the Discrete Fourier Transform (DFT), and using the well-tested fact that differentiation in Fourier space corresponds to multiplication of each Fourier mode $e^{\\mathrm{i} m x}$ by $\\mathrm{i} m$, derive the Fourier pseudospectral first-derivative differentiation matrix $D \\in \\mathbb{C}^{N \\times N}$ for equispaced nodes on $[0,2\\pi)$.\n\nImplement this matrix for $N=32$ and use it to approximate $u'(x)$ on the grid for the function $u(x)=\\sin(7x)$. Quantify the exactness due to spectral collocation by computing the maximum absolute error\n$$\nE = \\max_{0 \\le j \\le N-1} \\left| (D \\mathbf{u})_j - u'(x_j) \\right|,\n$$\nwhere $\\mathbf{u} \\in \\mathbb{R}^N$ is the vector of samples $\\mathbf{u}_j = u(x_j)$ and $u'(x)=7\\cos(7x)$ is the exact derivative. The angle unit is radians.\n\nYour program must construct $D$ from first principles of the trigonometric interpolant and the DFT, then evaluate $E$ for several test functions to assess general behavior, boundary conditions, and edge cases. Use the following test suite, all on $[0,2\\pi)$ with $N=32$:\n\n- Test $1$ (happy path): $u(x) = \\sin(7x)$.\n- Test $2$ (near-Nyquist resolvable integer mode): $u(x) = \\sin(15x)$.\n- Test $3$ (Nyquist pathology for even $N$): $u(x) = \\sin(16x)$.\n- Test $4$ (non-integer mode): $u(x) = \\sin(7.3\\,x)$.\n\nFor each test, compute the single float $E$ as defined above. Your program should produce a single line of output containing the four errors as a comma-separated list enclosed in square brackets in the order $[E_1,E_2,E_3,E_4]$, where $E_1$ corresponds to Test $1$, $E_2$ to Test $2$, $E_3$ to Test $3$, and $E_4$ to Test $4$.",
            "solution": "The derivation and implementation of the Fourier pseudospectral differentiation matrix proceed from first principles as follows.\n\nThe core principle of a pseudospectral method is to approximate a function $u(x)$ by a global interpolant $p(x)$ that coincides with $u(x)$ at a set of collocation points. For a $2\\pi$-periodic function on the interval $[0, 2\\pi)$, the natural choice for the interpolant is a trigonometric polynomial, and for the collocation points, an equispaced grid.\n\nLet the grid consist of $N$ points $x_j = \\frac{2\\pi j}{N}$ for $j=0, 1, \\dots, N-1$. We seek an approximation to the derivative $u'(x)$ at these same grid points.\n\nFor an even number of points $N$, the unique trigonometric interpolant $p(x)$ of degree $N/2$ that satisfies $p(x_j) = u(x_j) \\equiv u_j$ is given by:\n$$\np(x) = \\sum_{m=-N/2}^{N/2} ' c_m e^{\\mathrm{i} m x}\n$$\nwhere the prime on the summation indicates that the terms for $m=-N/2$ and $m=N/2$ are weighted by $\\frac{1}{2}$. The coefficients $c_m$ are the discrete Fourier coefficients of the data $\\{u_j\\}$, given by:\n$$\nc_m = \\frac{1}{N} \\sum_{j=0}^{N-1} u_j e^{-\\mathrm{i} m x_j} = \\frac{1}{N} \\sum_{j=0}^{N-1} u_j e^{-2\\pi \\mathrm{i} m j / N} \\quad \\text{for } m = -N/2, \\dots, N/2.\n$$\nThis expression relates the interpolant's coefficients to the grid values via the Discrete Fourier Transform (DFT). Specifically, if $\\hat{\\mathbf{u}}$ is the vector of DFT coefficients of the vector $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$, defined as $\\hat{u}_k = \\sum_{j=0}^{N-1} u_j e^{-2\\pi \\mathrm{i} j k / N}$, then the coefficients $c_m$ are simply $\\frac{1}{N}\\hat{u}_m$.\n\nThe derivative of the function $u(x)$ is approximated by the derivative of its interpolant, $p'(x)$:\n$$\np'(x) = \\frac{d}{dx} \\left( \\sum_{m=-N/2}^{N/2} ' c_m e^{\\mathrm{i} m x} \\right) = \\sum_{m=-N/2}^{N/2} ' (\\mathrm{i} m) c_m e^{\\mathrm{i} m x}.\n$$\nThis demonstrates the fundamental property of Fourier spectral methods: differentiation in physical space becomes simple multiplication by $\\mathrm{i}m$ in Fourier space, where $m$ is the wavenumber.\n\nLet $\\mathbf{v}$ be the vector of approximate derivative values at the grid points, $v_j = p'(x_j)$. Evaluating $p'(x)$ at $x_j$ gives:\n$$\nv_j = p'(x_j) = \\sum_{m=-N/2}^{N/2} ' (\\mathrm{i} m) c_m e^{\\mathrm{i} m x_j}.\n$$\nThis expression has the form of an Inverse Discrete Fourier Transform (IDFT). Let $\\hat{v}_m$ be the DFT coefficients of the derivative vector $\\mathbf{v}$. The relationship is $\\hat{v}_m = N c'_m$, where $c'_m$ are the Fourier series coefficients of $p'(x)$, i.e., $c'_m = (\\mathrm{i} m) c_m$. Therefore, $\\hat{v}_m = (\\mathrm{i} m) (N c_m) = (\\mathrm{i} m) \\hat{u}_m$.\n\nThis process defines a linear transformation from the vector of function values $\\mathbf{u}$ to the vector of derivative values $\\mathbf{v}$. This transformation is the differentiation matrix $D$: $\\mathbf{v} = D\\mathbf{u}$. The operation can be algorithmically described in three steps:\n1.  Transform the function values $\\mathbf{u}$ into Fourier space: $\\hat{\\mathbf{u}} = \\text{DFT}(\\mathbf{u})$.\n2.  Multiply by the effective wavenumbers: $\\hat{\\mathbf{v}}_m = (\\mathrm{i} k_m) \\hat{\\mathbf{u}}_m$ for each corresponding wavenumber $k_m$.\n3.  Transform back to physical space: $\\mathbf{v} = \\text{IDFT}(\\hat{\\mathbf{v}})$.\n\nA critical detail arises for even $N$ at the Nyquist frequency, corresponding to the wavenumber $m=N/2$. The basis functions $e^{\\mathrm{i}(N/2)x}$ and $e^{-\\mathrm{i}(N/2)x}$ are not independent on the grid; both evaluate to $e^{\\mathrm{i} \\pi j} = (-1)^j$. The interpolant contains a term proportional to $\\cos(N/2 x)$, which is real-valued on the grid. Its derivative, $-(N/2)\\sin(N/2 x)$, is zero at all grid points $x_j$. Attempting to differentiate the $m=N/2$ mode by multiplying by $\\mathrm{i}N/2$ would produce a non-real result from a real function's interpolant, which is inconsistent. Therefore, to maintain correctness for real-valued functions, the effective differentiation multiplier for the Nyquist frequency is set to $0$.\n\nThe vector of wavenumbers $\\mathbf{k}$ corresponding to the output of a standard FFT algorithm for an input of length $N$ is typically ordered as $[0, 1, \\dots, N/2-1, -N/2, \\dots, -1]$. For differentiation, we modify this vector, let's call it $\\mathbf{k}'$, by setting the element corresponding to the Nyquist frequency (which is $-N/2$ at index $N/2$ in this convention) to $0$.\n\nThe differentiation matrix $D$ can be formally expressed using the DFT matrix $F$ and its inverse $F^{-1}$. The DFT matrix has entries $F_{kj} = e^{-2\\pi\\mathrm{i}jk/N}$, and the IDFT matrix is $F^{-1} = \\frac{1}{N}F^*$, where $F^*$ is the conjugate transpose. The operation becomes $\\mathbf{v} = F^{-1} M F \\mathbf{u}$, where $M$ is the diagonal matrix with entries $M_{mm} = \\mathrm{i}k'_m$. Thus, the differentiation matrix is $D = F^{-1} M F$.\n\nThis matrix can be constructed numerically by applying the differentiation procedure to the columns of the identity matrix $I$. That is, the $j$-th column of $D$ is the result of differentiating the $j$-th standard basis vector $\\mathbf{e}_j$.\n\nThe test cases are chosen to evaluate specific properties of the method:\n-   **Test 1 & 2 ($u(x) = \\sin(7x), \\sin(15x)$)**: These functions are band-limited, with integer wavenumbers ($7$ and $15$) well below the Nyquist frequency of $N/2=16$. The pseudospectral derivative should be exact up to machine precision, demonstrating spectral accuracy.\n-   **Test 3 ($u(x) = \\sin(16x)$)**: This function's wavenumber is exactly the Nyquist frequency. On the grid $x_j = \\pi j/16$, the function samples to $\\sin(\\pi j) = 0$ for all $j$. The numerical method will differentiate a zero vector, yielding zero. However, the exact derivative $16\\cos(16x)$ evaluates to $16(-1)^j$ on the grid. The error will thus be exactly $16$, illustrating the aliasing pathology at the Nyquist frequency.\n-   **Test 4 ($u(x) = \\sin(7.3x)$)**: This function is not $2\\pi$-periodic. The DFT assumes a periodic extension of the sampled data, introducing a discontinuity at the boundary endpoints (since $u(0) \\ne u(2\\pi)$). This leads to the Gibbs phenomenon, polluting the accuracy of the Fourier representation and resulting in a significantly larger error compared to the periodic cases. The convergence is degraded from spectral to algebraic.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives the Fourier pseudospectral differentiation matrix and uses it\n    to calculate the derivative of several test functions.\n    \"\"\"\n    \n    # Define parameters from the problem statement\n    N = 32\n    \n    # Define the equispaced grid on [0, 2*pi)\n    # x_j = (2 * pi * j) / N for j = 0, 1, ..., N-1\n    x_j = 2 * np.pi * np.arange(0, N) / N\n    \n    # Construct the Fourier pseudospectral differentiation matrix D\n    \n    # 1. Get the wavenumbers corresponding to the DFT.\n    # For a signal of length N and sample spacing d, fftfreq(N, d) gives\n    # the cycle frequencies. Here, our \"length\" is 2*pi, so sample\n    # spacing is d = 2*pi/N. The wavenumbers m for e^(i*m*x) are what\n    # we need. A simpler way is to get frequencies in cycles per interval\n    # (d=1) and multiply by N, which corresponds to the integer mode numbers.\n    k = np.fft.fftfreq(N) * N\n    \n    # 2. For differentiation, the multiplier for the k-th mode is i*k.\n    # A special case for even N: the Nyquist frequency k = N/2. For a real\n    # function, its derivative must be real. This requires setting the\n    # differentiator for the Nyquist mode to 0. In numpy's fftfreq\n    # convention, this frequency is at index N/2.\n    k_deriv = 1j * k\n    if N % 2 == 0:\n        k_deriv[N // 2] = 0.0\n    \n    # 3. Construct D = F^-1 * M * F, where F is the DFT matrix and M is the\n    # diagonal matrix of multipliers (i*k').\n    # We can do this by applying the differentiation process to the\n    # columns of the identity matrix.\n    I = np.eye(N)\n    D_matrix = np.fft.ifft(k_deriv[:, np.newaxis] * np.fft.fft(I, axis=0), axis=0)\n    \n    # The matrix for a real-to-real differentiation should be real.\n    # Small imaginary parts may exist due to floating-point inaccuracies.\n    D_matrix = D_matrix.real\n    \n    # Define the test suite\n    test_cases = [\n        {'u': lambda x: np.sin(7 * x),   'u_prime': lambda x: 7 * np.cos(7 * x)},\n        {'u': lambda x: np.sin(15 * x),  'u_prime': lambda x: 15 * np.cos(15 * x)},\n        {'u': lambda x: np.sin(16 * x),  'u_prime': lambda x: 16 * np.cos(16 * x)},\n        {'u': lambda x: np.sin(7.3 * x), 'u_prime': lambda x: 7.3 * np.cos(7.3 * x)}\n    ]\n    \n    results = []\n    for case in test_cases:\n        # Sample the function and its exact derivative on the grid\n        u_vec = case['u'](x_j)\n        u_prime_exact = case['u_prime'](x_j)\n        \n        # Approximate the derivative using the differentiation matrix\n        u_prime_approx = D_matrix @ u_vec\n        \n        # Compute the maximum absolute error\n        E = np.max(np.abs(u_prime_approx - u_prime_exact))\n        results.append(E)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice integrates the concepts of matrix construction and application to solve a complete boundary value problem, a core task in scientific computing. Using a Chebyshev grid, which is ideal for non-periodic problems, you will discretize the Poisson equation and implement Dirichlet boundary conditions. This exercise demonstrates how to correctly form the second-derivative operator as $D^{(2)} = D^2$  and assemble the full linear system to achieve a highly accurate solution.",
            "id": "3417568",
            "problem": "Consider the boundary value problem given by the Poisson equation $-u''(x) = f(x)$ on the closed interval $[-1,1]$ with Dirichlet boundary conditions $u(-1) = g_{-}$ and $u(1) = g_{+}$. The task is to implement a pseudospectral collocation method using differentiation matrices to approximate the solution $u(x)$ at a set of collocation nodes, and then to assess the accuracy for several smooth right-hand sides.\n\nYou must use the following fundamental numerical analysis base:\n- Spectral collocation on Chebyshev-Lobatto (CL) nodes. The CL nodes are defined by $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$ for $j = 0,1,\\dots,N$.\n- The spectral derivative of an interpolating polynomial in the Lagrange basis. If $p(x)$ is the unique polynomial interpolant through samples $u(x_j)$ at nodes $\\{x_j\\}$, then its derivative at nodes can be represented as a matrix-vector product, $p'(x_i) = \\sum_{j=0}^{N} D_{ij} u(x_j)$, where $D$ is the first differentiation matrix constructed from the Lagrange basis at the chosen nodes. The second derivative at nodes is then represented by $D^{(2)} = D^2$ and $p''(x_i) = \\sum_{j=0}^{N} D^{(2)}_{ij} u(x_j)$.\n\nYour program must:\n1. Construct the Chebyshev-Lobatto nodes $\\{x_j\\}_{j=0}^{N}$.\n2. Derive and implement the spectral first differentiation matrix $D$ for these nodes based on the Lagrange interpolation polynomials at the nodes (do not use any external precomputed matrices). Then form the second differentiation matrix by $D^{(2)} = D^2$.\n3. Discretize the Poisson equation at the nodes using the pseudospectral approximation: enforce $-D^{(2)} u = f$ at all interior nodes. Impose Dirichlet boundary conditions by replacing the first and last rows of the linear system to enforce $u(x_0) = g_{-}$ and $u(x_N) = g_{+}$ exactly.\n4. Solve the resulting linear system for the nodal values of $u$.\n5. For each test case, compute the maximum absolute error between the numerical solution and a manufactured smooth exact solution $u_{\\text{exact}}(x)$ at the CL nodes: $\\max_{j} |u_{\\text{num}}(x_j) - u_{\\text{exact}}(x_j)|$.\n\nAngle unit specification: whenever a trigonometric function is used, angles must be interpreted in radians.\n\nTest suite specification:\n- Test case 1 (happy path): $N = 16$, $u_{\\text{exact}}(x) = \\sin(3 x)$, $f(x) = -u_{\\text{exact}}''(x)$, and Dirichlet boundary data $g_{-} = u_{\\text{exact}}(-1)$, $g_{+} = u_{\\text{exact}}(1)$.\n- Test case 2 (higher resolution smooth exponential): $N = 64$, $u_{\\text{exact}}(x) = e^{x}$, $f(x) = -u_{\\text{exact}}''(x)$, $g_{-} = u_{\\text{exact}}(-1)$, $g_{+} = u_{\\text{exact}}(1)$.\n- Test case 3 (polynomial edge case): $N = 8$, $u_{\\text{exact}}(x) = x^{5} - x$, $f(x) = -u_{\\text{exact}}''(x)$, $g_{-} = u_{\\text{exact}}(-1)$, $g_{+} = u_{\\text{exact}}(1)$.\n- Test case 4 (higher frequency smooth trigonometric): $N = 80$, $u_{\\text{exact}}(x) = \\cos(10 x)$, $f(x) = -u_{\\text{exact}}''(x)$, $g_{-} = u_{\\text{exact}}(-1)$, $g_{+} = u_{\\text{exact}}(1)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with the maximum absolute error for each test case in the order listed above. For example, the output format must be exactly of the form $[e_1,e_2,e_3,e_4]$, where each $e_k$ is a floating-point number.",
            "solution": "The problem requires the numerical solution of the one-dimensional Poisson equation with Dirichlet boundary conditions using a pseudospectral collocation method. The specific methodology involves Chebyshev-Lobatto collocation points and the associated spectral differentiation matrices. The validity and correctness of the approach will be demonstrated by applying it to a series of test cases with known smooth solutions, a process known as the method of manufactured solutions.\n\nThe problem is stated as:\n$$\n-u''(x) = f(x), \\quad x \\in [-1, 1]\n$$\nwith boundary conditions\n$$\nu(-1) = g_{-}, \\quad u(1) = g_{+}\n$$\n\nThe solution proceeds through the following steps: discretization using Chebyshev-Lobatto nodes, construction of the spectral differentiation matrices, assembly of the linear system, imposition of boundary conditions, solution of the system, and evaluation of the numerical error.\n\n**1. Pseudospectral Collocation on Chebyshev-Lobatto Nodes**\nThe core principle of a pseudospectral (or collocation) method is to approximate the continuous solution $u(x)$ by a single global polynomial, $p(x)$, of degree $N$ or less. This polynomial is constrained to satisfy the differential equation exactly at a set of $N+1$ prescribed collocation points, $\\{x_j\\}_{j=0}^N$. For this problem, we use the Chebyshev-Lobatto nodes, which are the extrema of the $N$-th degree Chebyshev polynomial $T_N(x)$ and are given by:\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N}\\right), \\quad j = 0, 1, \\dots, N\n$$\nThese points are ordered such that $1 = x_0 > x_1 > \\dots > x_N = -1$. The function $u(x)$ is represented by its values at these nodes, forming a vector $\\mathbf{u} = [u(x_0), u(x_1), \\dots, u(x_N)]^T$.\n\n**2. Spectral Differentiation**\nThe unique polynomial interpolant $p(x)$ passing through the points $(x_j, u_j)$ can be written in the Lagrange basis as $p(x) = \\sum_{j=0}^N u_j L_j(x)$, where $L_j(x)$ are the Lagrange cardinal polynomials. The derivatives of $u(x)$ at the collocation nodes are approximated by the derivatives of $p(x)$. The first derivative vector, $\\mathbf{u}'$, is computed via a matrix-vector product:\n$$\n\\mathbf{u}' = D\\mathbf{u}\n$$\nHere, $D$ is the $(N+1) \\times (N+1)$ first spectral differentiation matrix. Its entries are given by $(D)_{ij} = L'_j(x_i)$. For the Chebyshev-Lobatto nodes, these entries have well-known explicit formulas:\n$$\n(D)_{ij} = \\frac{c_i}{c_j} \\frac{(-1)^{i+j}}{x_i - x_j}, \\quad \\text{for } i \\neq j\n$$\n$$\n(D)_{00} = \\frac{2N^2+1}{6}, \\quad (D)_{NN} = -\\frac{2N^2+1}{6}\n$$\n$$\n(D)_{ii} = -\\frac{x_i}{2(1-x_i^2)}, \\quad \\text{for } i=1, \\dots, N-1\n$$\nwhere the constants $c_j$ are defined as $c_0 = c_N = 2$ and $c_j = 1$ for $j=1, \\dots, N-1$. A more robust way to compute the diagonal entries is to use the property that the derivative of a constant function is zero, which implies that the rows of $D$ must sum to zero: $(D)_{ii} = -\\sum_{j\\neq i} (D)_{ij}$.\n\nThe second derivative is approximated by applying the first differentiation matrix twice. The second spectral differentiation matrix is thus $D^{(2)} = D^2$. The vector of second derivatives at the nodes, $\\mathbf{u}''$, is given by:\n$$\n\\mathbf{u}'' = D^{(2)}\\mathbf{u}\n$$\n\n**3. Discretization and Linear System Assembly**\nWe enforce the Poisson equation, $-u''(x) = f(x)$, at the **interior** collocation nodes, $x_i$, for $i = 1, \\dots, N-1$. Substituting the spectral approximation for the second derivative, we obtain a system of $N-1$ linear algebraic equations:\n$$\n-\\sum_{j=0}^{N} (D^{(2)})_{ij} u_j = f(x_i), \\quad \\text{for } i = 1, \\dots, N-1\n$$\nLet $A = -D^{(2)}$ be the $(N+1) \\times (N+1)$ operator matrix, $\\mathbf{u} = [u_0, u_1, \\dots, u_N]^T$ be the vector of unknown nodal values, and $\\mathbf{b} = [f(x_0), f(x_1), \\dots, f(x_N)]^T$ be the vector of the right-hand side function evaluated at all nodes. The system of equations can be written as $A \\mathbf{u} = \\mathbf{b}$, though this system is not yet fully determined as boundary conditions have not been applied.\n\n**4. Imposition of Boundary Conditions**\nThe Dirichlet boundary conditions provide the values of the solution at the boundaries of the domain: $u(1) = g_+$ and $u(-1) = g_-$. In terms of our nodal representation, since $x_0 = 1$ and $x_N = -1$, these conditions fix the first and last elements of the solution vector:\n$$\nu_0 = g_+\n$$\n$$\nu_N = g_-\n$$\nTo incorporate these known values into the $(N+1) \\times (N+1)$ linear system, we modify the matrix $A$ and the vector $\\mathbf{b}$. The first row of the system is replaced by the equation $u_0 = g_+$, and the last row is replaced by $u_N = g_-$. The interior rows remain the discretized Poisson equation.\n\nThe modified system, let's call it $A_{mod} \\mathbf{u} = \\mathbf{b}_{mod}$, is constructed as follows:\n- For the first row ($i=0$): Set $(A_{mod})_{0,j} = \\delta_{0j}$ (i.e., $1$ at $j=0$ and $0$ otherwise) and $(b_{mod})_0 = g_+$. This enforces $1 \\cdot u_0 + 0 \\cdot u_1 + \\dots = g_+$.\n- For the interior rows ($i=1, \\dots, N-1$): Keep the original rows from the operator, i.e., $(A_{mod})_{i,j} = A_{ij}$ and $(b_{mod})_i = b_i = f(x_i)$.\n- For the last row ($i=N$): Set $(A_{mod})_{N,j} = \\delta_{Nj}$ (i.e., $1$ at $j=N$ and $0$ otherwise) and $(b_{mod})_N = g_-$. This enforces $0 \\cdot u_0 + \\dots + 1 \\cdot u_N = g_-$.\n\n**5. Solution and Error Evaluation**\nThe modified linear system $A_{mod} \\mathbf{u} = \\mathbf{b}_{mod}$ is non-singular and can be solved for the vector of unknown nodal values $\\mathbf{u}_{\\text{num}}$. The accuracy of this numerical solution is then assessed by comparing it to the known exact solution, $u_{\\text{exact}}(x)$, from which the problem data ($f(x)$, $g_+$, $g_-$) were manufactured. The error is computed as the maximum absolute difference at the collocation nodes:\n$$\n\\text{Error} = \\max_{j=0, \\dots, N} | (u_{\\text{num}})_j - u_{\\text{exact}}(x_j) |\n$$\nThis procedure is repeated for each test case specified in the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef chebyshev_lobatto_nodes(N):\n    \"\"\"\n    Computes the N+1 Chebyshev-Lobatto nodes on the interval [-1, 1].\n    The nodes are ordered from 1 down to -1.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0])\n    j = np.arange(N + 1)\n    x = np.cos(np.pi * j / N)\n    return x\n\ndef chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the first-order Chebyshev spectral differentiation matrix \n    on the Chebyshev-Lobatto nodes.\n    \n    Returns:\n        D (np.ndarray): The (N+1)x(N+1) differentiation matrix.\n        x (np.ndarray): The (N+1) Chebyshev-Lobatto nodes.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.]]), np.array([0.])\n    \n    x = chebyshev_lobatto_nodes(N)\n    D = np.zeros((N + 1, N + 1))\n    \n    # Coefficients c_i\n    c = np.ones(N + 1)\n    c[0] = 2.0\n    c[-1] = 2.0\n    \n    # vectorized computation of off-diagonal elements\n    X = np.tile(x, (N + 1, 1))\n    dX = X - X.T\n    # Add identity to avoid division by zero on diagonal, which is handled later\n    np.fill_diagonal(dX, 1.0)\n\n    # c_i/c_j * (-1)^{i+j}\n    C = np.tile(c, (N + 1, 1))\n    C_ratio = C.T / C\n    \n    I_plus_J = np.add.outer(np.arange(N+1), np.arange(N+1))\n    Sign_matrix = (-1)**I_plus_J\n    \n    D = C_ratio * Sign_matrix / dX\n    np.fill_diagonal(D, 0.0) # Zero out diagonal before computing row sums\n    \n    # Diagonal entries using sum-to-zero property: D_ii = -sum(D_ij for j!=i)\n    row_sums = np.sum(D, axis=1)\n    np.fill_diagonal(D, -row_sums)\n    \n    return D, x\n\ndef solve_poisson_spectral(N, u_exact, f_rhs):\n    \"\"\"\n    Solves the Poisson equation -u'' = f on [-1, 1] using a spectral method.\n    \n    Args:\n        N (int): The degree of the interpolating polynomial. The number of nodes is N+1.\n        u_exact (callable): The exact solution function u(x).\n        f_rhs (callable): The right-hand side function f(x) of the Poisson eq.\n\n    Returns:\n        float: The maximum absolute error between the numerical and exact solutions.\n    \"\"\"\n    # 1. Get differentiation matrix D and nodes x\n    D, x = chebyshev_diff_matrix(N)\n    \n    # 2. Compute second differentiation matrix D2 = D^2\n    D2 = np.dot(D, D)\n    \n    # 3. Assemble the linear system operator A = -D2\n    A = -D2\n    \n    # 4. Assemble the right-hand side vector b\n    b = f_rhs(x)\n    \n    # 5. Define and impose Dirichlet boundary conditions\n    g_plus = u_exact(1.0)  # u(1)\n    g_minus = u_exact(-1.0) # u(-1)\n    \n    # Node ordering is x_0=1, x_N=-1.\n    # Modify first row for u(1) = g_plus\n    A[0, :] = 0.0\n    A[0, 0] = 1.0\n    b[0] = g_plus\n    \n    # Modify last row for u(-1) = g_minus\n    A[-1, :] = 0.0\n    A[-1, -1] = 1.0\n    b[-1] = g_minus\n    \n    # 6. Solve the linear system A * u_num = b\n    u_num = np.linalg.solve(A, b)\n    \n    # 7. Evaluate exact solution at nodes\n    u_exact_vals = u_exact(x)\n    \n    # 8. Compute maximum absolute error\n    max_error = np.max(np.abs(u_num - u_exact_vals))\n    \n    return max_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite specification\n    test_cases = [\n        {\n            \"N\": 16,\n            \"u_exact\": lambda x: np.sin(3 * x),\n            \"f_rhs\": lambda x: 9 * np.sin(3 * x) # f = -u''\n        },\n        {\n            \"N\": 64,\n            \"u_exact\": lambda x: np.exp(x),\n            \"f_rhs\": lambda x: -np.exp(x) # f = -u''\n        },\n        {\n            \"N\": 8,\n            \"u_exact\": lambda x: x**5 - x,\n            \"f_rhs\": lambda x: -20 * x**3 # f = -u''\n        },\n        {\n            \"N\": 80,\n            \"u_exact\": lambda x: np.cos(10 * x),\n            \"f_rhs\": lambda x: 100 * np.cos(10 * x) # f = -u''\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_poisson_spectral(\n            N=case[\"N\"],\n            u_exact=case[\"u_exact\"],\n            f_rhs=case[\"f_rhs\"]\n        )\n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}