{
    "hands_on_practices": [
        {
            "introduction": "理论必须通过实践来巩固。本练习旨在通过手动计算一个阶数较低的勒让德-高斯-洛巴托（LGL）微分矩阵，从根本上理解其构造过程。通过从勒让德多项式及其导数的性质出发，确定节点、计算重心权重，并最终组装矩阵的一部分，您可以亲身体验伪谱方法的核心构件是如何从第一性原理中产生的 。这个“纸笔”练习对于揭示这些强大数值工具背后的数学机制至关重要。",
            "id": "3437283",
            "problem": "考虑构建与 $N=4$ 阶勒让德多项式相关的勒让德-高斯-洛巴托 (LGL) 格点的一阶伪谱微分矩阵。该矩阵是区间 $[-1,1]$ 上偏微分方程 (PDE) 数值解的伪谱法的基础。\n\n仅从以下基本要素出发：\n- 勒让德多项式 $\\{P_n(x)\\}_{n \\ge 0}$ 的定义为在 $[-1,1]$ 上关于单位权重正交且由 $P_n(1)=1$ 归一化的唯一多项式。\n- LGL 节点 $\\{x_j\\}_{j=0}^{N}$ 的定义为端点 $\\{-1,1\\}$ 与 $P_N'(x)$ 的零点的并集。\n- 与 LGL 格点相关的节点多项式 $\\phi(x)$ 为 $\\phi(x) \\propto (1-x^2)P_N'(x)$（相差一个非零乘法常数），以及重心权重 $\\{\\lambda_j\\}_{j=0}^{N}$ 定义为 $\\lambda_j = 1/\\phi'(x_j)$（相差一个公共非零因子）。\n- 重心一阶微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 定义为\n  $$\n  D_{ij}=\\frac{\\lambda_j}{\\lambda_i(x_i-x_j)} \\quad \\text{for } i\\neq j, \n  \\qquad \n  D_{ii}=-\\sum_{\\substack{j=0\\\\ j\\neq i}}^{N} D_{ij},\n  $$\n针对 $N=4$ 推导并执行以下步骤：\n\n1. 显式计算节点 $x_j$（排序为 $x_0  x_1  \\dots  x_4$），并在每个节点上计算 $P_4'(x_j)$ 的值。\n2. 计算 $\\phi'(x)$，然后通过计算 $\\lambda_j=1/\\phi'(x_j)$ 来求出 $\\{\\lambda_j\\}_{j=0}^{4}$（相差一个公共非零乘法常数）。\n3. 使用 $D$ 的重心公式，通过对您计算出的量进行精确算术运算来数值验证 $D\\mathbf{1}=\\mathbf{0}$ 和 $D\\mathbf{x}=\\mathbf{1}$，其中 $\\mathbf{1}=(1,1,1,1,1)^{\\top}$ 且 $\\mathbf{x}=(x_0,x_1,x_2,x_3,x_4)^{\\top}$。\n4. 使用上述节点索引 $i,j\\in\\{0,1,2,3,4\\}$，精确确定单个矩阵元 $D_{2,4}$。\n\n请提供您的最终结果，即 $D_{2,4}$ 的精确值；无需四舍五入，不涉及物理单位。如果出现任何角度，请以弧度表示（虽然此处预计不会出现）。",
            "solution": "### 解题步骤\n\n求解过程遵循问题陈述中概述的四个步骤。\n\n#### 1. 计算节点 $x_j$ 并求 $P_4'(x_j)$ 的值\n\n首先，我们需要阶数为 $N=4$ 的勒让德多项式，记为 $P_4(x)$。勒让德多项式可以通过多种方式生成；一种常见的形式是 $P_4(x) = \\frac{1}{8}(35x^4 - 30x^2 + 3)$。该多项式满足归一化条件 $P_4(1) = \\frac{1}{8}(35-30+3) = 1$。\n\n其导数 $P_4'(x)$ 为：\n$$\nP_4'(x) = \\frac{d}{dx} \\left[ \\frac{1}{8}(35x^4 - 30x^2 + 3) \\right] = \\frac{1}{8}(140x^3 - 60x) = \\frac{5}{2}(7x^3 - 3x) = \\frac{5}{2}x(7x^2 - 3)\n$$\n对于 $N=4$，LGL 节点是端点 $x=-1$ 和 $x=1$，以及 $P_4'(x)$ 的零点。我们通过令 $P_4'(x)=0$ 来找到零点：\n$$\n\\frac{5}{2}x(7x^2 - 3) = 0\n$$\n这给出 $x=0$ 和 $7x^2-3=0$，即 $x^2 = 3/7$，或 $x = \\pm\\sqrt{\\frac{3}{7}}$。\n按升序排列的五个 LGL 节点集合 $\\{x_j\\}_{j=0}^4$ 是：\n$$\nx_0 = -1, \\quad x_1 = -\\sqrt{\\frac{3}{7}}, \\quad x_2 = 0, \\quad x_3 = \\sqrt{\\frac{3}{7}}, \\quad x_4 = 1\n$$\n接下来，我们在这些节点上计算 $P_4'(x)$ 的值：\n- $P_4'(x_0) = P_4'(-1) = \\frac{5}{2}(-1)(7(-1)^2 - 3) = \\frac{5}{2}(-1)(4) = -10$。\n- $P_4'(x_1) = P_4'(-\\sqrt{3/7}) = 0$，因为 $x_1$ 是 $P_4'(x)$ 的一个根。\n- $P_4'(x_2) = P_4'(0) = 0$，因为 $x_2$ 是 $P_4'(x)$ 的一个根。\n- $P_4'(x_3) = P_4'(\\sqrt{3/7}) = 0$，因为 $x_3$ 是 $P_4'(x)$ 的一个根。\n- $P_4'(x_4) = P_4'(1) = \\frac{5}{2}(1)(7(1)^2 - 3) = \\frac{5}{2}(1)(4) = 10$。\n\n#### 2. 计算 $\\phi'(x)$ 和权重 $\\lambda_j$\n\n节点多项式为 $\\phi(x) \\propto (1-x^2)P_N'(x)$。我们选择比例常数为1，因此 $\\phi(x) = (1-x^2)P_4'(x)$。需要计算导数 $\\phi'(x)$。一个与勒让德多项式相关的关键性质，可以从勒让德微分方程 $(1-x^2)y'' - 2xy' + n(n+1)y=0$（其中 $y=P_n(x)$）推导得出，即 $\\frac{d}{dx}[(1-x^2)P_n'(x)] = -n(n+1)P_n(x)$。\n因此，对于 $N=4$：\n$$\n\\phi'(x) = \\frac{d}{dx}[(1-x^2)P_4'(x)] = -4(4+1)P_4(x) = -20P_4(x)\n$$\n重心权重为 $\\lambda_j = 1/\\phi'(x_j) = 1/(-20P_4(x_j))$，相差一个乘法常数。为简便起见，我们可以选择一个常数使得权重更简单。我们选择常数为 $-20$，这给出 $\\lambda_j = 1/P_4(x_j)$。现在我们在 LGL 节点上计算 $P_4(x)$ 的值：\n- $P_4(x_0) = P_4(-1) = 1$（根据勒让德多项式的性质）。\n- $P_4(x_4) = P_4(1) = 1$（根据归一化）。\n- $P_4(x_2) = P_4(0) = \\frac{1}{8}(35(0)^4 - 30(0)^2 + 3) = \\frac{3}{8}$。\n- 对于 $x_{1,3} = \\mp\\sqrt{3/7}$，我们有 $x^2 = 3/7$。\n  $P_4(x_{1,3}) = \\frac{1}{8}\\left(35\\left(\\frac{3}{7}\\right)^2 - 30\\left(\\frac{3}{7}\\right) + 3\\right) = \\frac{1}{8}\\left(35\\frac{9}{49} - \\frac{90}{7} + 3\\right) = \\frac{1}{8}\\left(\\frac{45}{7} - \\frac{90}{7} + \\frac{21}{7}\\right) = \\frac{1}{8}\\left(\\frac{-24}{7}\\right) = -\\frac{3}{7}$。\n所以，$P_4(x_1) = P_4(x_3) = -3/7$。\n\n使用我们的选择 $\\lambda_j = 1/P_4(x_j)$，权重为：\n- $\\lambda_0 = \\frac{1}{P_4(x_0)} = \\frac{1}{1} = 1$。\n- $\\lambda_1 = \\frac{1}{P_4(x_1)} = \\frac{1}{-3/7} = -\\frac{7}{3}$。\n- $\\lambda_2 = \\frac{1}{P_4(x_2)} = \\frac{1}{3/8} = \\frac{8}{3}$。\n- $\\lambda_3 = \\frac{1}{P_4(x_3)} = \\frac{1}{-3/7} = -\\frac{7}{3}$。\n- $\\lambda_4 = \\frac{1}{P_4(x_4)} = \\frac{1}{1} = 1$。\n\n#### 3. 验证 $D\\mathbf{1}=\\mathbf{0}$ 和 $D\\mathbf{x}=\\mathbf{1}$\n\n首先，我们验证 $D\\mathbf{1}=\\mathbf{0}$，其中 $\\mathbf{1}=(1,1,1,1,1)^{\\top}$。向量 $D\\mathbf{1}$ 的第 $i$ 个分量是 $\\sum_{j=0}^4 D_{ij}$。\n$$\n(D\\mathbf{1})_i = \\sum_{j=0}^{4} D_{ij} = D_{ii} + \\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} D_{ij}\n$$\n根据定义，$D_{ii} = -\\sum_{j \\neq i} D_{ij}$。将此代入求和式中得到：\n$$\n(D\\mathbf{1})_i = \\left(-\\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} D_{ij}\\right) + \\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} D_{ij} = 0\n$$\n这对任何 $i \\in \\{0, 1, 2, 3, 4\\}$ 都成立，因此 $D\\mathbf{1}=\\mathbf{0}$。该恒等式根据矩阵 $D$ 的构造为真，并且不依赖于 $x_j$ 或 $\\lambda_j$ 的具体值。\n\n其次，我们验证 $D\\mathbf{x}=\\mathbf{1}$，其中 $\\mathbf{x}=(x_0,x_1,x_2,x_3,x_4)^{\\top}$。如果微分矩阵能够精确地对1次多项式求导，则此性质成立。向量 $\\mathbf{x}$ 表示在节点上采样的函数 $f(x)=x$，而 $\\mathbf{1}$ 表示在节点上采样的其导数 $f'(x)=1$。\n$D\\mathbf{x}$ 的第 $i$ 个分量是：\n$$\n(D\\mathbf{x})_i = \\sum_{j=0}^{4} D_{ij}x_j = D_{ii}x_i + \\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} D_{ij}x_j\n$$\n使用 $D_{ii}$ 的定义：\n$$\n(D\\mathbf{x})_i = \\left(-\\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} D_{ij}\\right)x_i + \\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} D_{ij}x_j = \\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} D_{ij}(x_j - x_i)\n$$\n现在，代入非对角元的定义，$D_{ij} = \\frac{\\lambda_j}{\\lambda_i(x_i-x_j)}$ 对于 $i \\neq j$：\n$$\n(D\\mathbf{x})_i = \\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} \\frac{\\lambda_j}{\\lambda_i(x_i-x_j)}(x_j - x_i) = \\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} \\frac{\\lambda_j}{\\lambda_i}(-1) = -\\frac{1}{\\lambda_i} \\sum_{\\substack{j=0 \\\\ j\\neq i}}^{4} \\lambda_j\n$$\n要使 $(D\\mathbf{x})_i$ 等于 1，我们必须有 $-\\frac{1}{\\lambda_i} \\sum_{j \\neq i} \\lambda_j = 1$，这意味着 $\\sum_{j \\neq i} \\lambda_j = -\\lambda_i$。这等价于要求所有权重的总和为零：$\\sum_{j=0}^4 \\lambda_j = 0$。\n让我们用我们计算出的权重来数值验证这一点：\n$$\n\\sum_{j=0}^{4} \\lambda_j = \\lambda_0 + \\lambda_1 + \\lambda_2 + \\lambda_3 + \\lambda_4 = 1 + \\left(-\\frac{7}{3}\\right) + \\frac{8}{3} + \\left(-\\frac{7}{3}\\right) + 1 = 2 + \\frac{-7+8-7}{3} = 2 + \\frac{-6}{3} = 2 - 2 = 0\n$$\n总和确实为零，这验证了 $D\\mathbf{x}=\\mathbf{1}$。\n\n#### 4. 确定单个矩阵元 $D_{2,4}$\n\n我们需要计算微分矩阵中行索引 $i=2$ 和列索引 $j=4$ 的矩阵元 $D_{ij}$。非对角元的公式是：\n$$\nD_{ij} = \\frac{\\lambda_j}{\\lambda_i(x_i - x_j)}\n$$\n对于 $i=2$ 和 $j=4$，我们使用相应的节点和权重：\n- $x_2 = 0$\n- $x_4 = 1$\n- $\\lambda_2 = 8/3$\n- $\\lambda_4 = 1$\n\n将这些值代入公式：\n$$\nD_{2,4} = \\frac{\\lambda_4}{\\lambda_2(x_2 - x_4)} = \\frac{1}{\\frac{8}{3}(0 - 1)} = \\frac{1}{-\\frac{8}{3}} = -\\frac{3}{8}\n$$\n矩阵元 $D_{2,4}$ 的精确值是 $-3/8$。",
            "answer": "$$\n\\boxed{-\\frac{3}{8}}\n$$"
        },
        {
            "introduction": "在掌握了基于多项式的微分矩阵的基本构造之后，我们转向周期性问题中极为重要的傅里叶伪谱方法。本练习通过编写代码实现傅里叶微分矩阵，并将其应用于一系列测试函数，从而将理论付诸实践 。通过这个过程，您将直接观察到谱方法的标志性特征：对于解析周期函数的光谱精度，以及当函数的频率超过网格分辨率时出现的混叠误差的关键现象。",
            "id": "3437316",
            "problem": "考虑周期区间 $[0,2\\pi)$，角度以弧度为单位。令 $N$ 为等距配置点的数量，并定义网格点 $x_j = \\frac{2\\pi j}{N}$，其中 $j=0,1,\\dots,N-1$。傅里叶伪谱微分矩阵是一个线性算子，它将一个足够光滑的 $2\\pi$ 周期函数在点 $\\{x_j\\}$ 上的采样值映射到其导数在相同点上的采样值。从三角插值和离散傅里叶变换（DFT）的定义出发，并利用傅里叶空间中的微分对应于将每个傅里叶模式 $e^{\\mathrm{i} m x}$ 乘以 $\\mathrm{i} m$ 这一公认事实，推导出在 $[0,2\\pi)$ 上等距节点的傅里叶伪谱一阶微分矩阵 $D \\in \\mathbb{C}^{N \\times N}$。\n\n为 $N=32$ 实现此矩阵，并用它在网格上近似函数 $u(x)=\\sin(7x)$ 的导数 $u'(x)$。通过计算最大绝对误差来量化谱配置法的精确性：\n$$\nE = \\max_{0 \\le j \\le N-1} \\left| (D \\mathbf{u})_j - u'(x_j) \\right|,\n$$\n其中 $\\mathbf{u} \\in \\mathbb{R}^N$ 是采样值向量 $\\mathbf{u}_j = u(x_j)$，$u'(x)=7\\cos(7x)$ 是精确导数。角度单位为弧度。\n\n你的程序必须根据三角插值和DFT的基本原理构造 $D$，然后对几个测试函数计算 $E$，以评估其一般行为、边界条件和边缘情况。使用以下测试套件，所有测试均在 $[0,2\\pi)$ 上进行，且 $N=32$：\n\n- 测试 1（理想情况）：$u(x) = \\sin(7x)$。\n- 测试 2（接近奈奎斯特频率的可分辨整数模式）：$u(x) = \\sin(15x)$。\n- 测试 3（偶数 $N$ 的奈奎斯特病态问题）：$u(x) = \\sin(16x)$。\n- 测试 4（非整数模式）：$u(x) = \\sin(7.3\\,x)$。\n\n对于每个测试，计算如上定义的单个浮点数 $E$。你的程序应生成单行输出，其中包含四个误差值，格式为用方括号括起来的逗号分隔列表，顺序为 $[E_1,E_2,E_3,E_4]$，其中 $E_1$ 对应测试 1，$E_2$ 对应测试 2，$E_3$ 对应测试 3，$E_4$ 对应测试 4。",
            "solution": "傅里叶伪谱微分矩阵的推导和实现遵循以下第一性原理。\n\n伪谱方法的核心原理是用一个全局插值函数 $p(x)$ 来近似函数 $u(x)$，该插值函数在一组配置点上与 $u(x)$ 的值相等。对于区间 $[0, 2\\pi)$ 上的一个 $2\\pi$ 周期函数，插值函数的自然选择是三角多项式，配置点的自然选择是等距网格。\n\n设网格由 $N$ 个点 $x_j = \\frac{2\\pi j}{N}$ 组成，其中 $j=0, 1, \\dots, N-1$。我们寻求在这些相同的网格点上对导数 $u'(x)$ 的近似。\n\n对于偶数个点 $N$，满足 $p(x_j) = u(x_j) \\equiv u_j$ 的唯一的 $N/2$ 次三角插值函数 $p(x)$ 由下式给出：\n$$\np(x) = \\sum_{m=-N/2}^{N/2} ' c_m e^{\\mathrm{i} m x}\n$$\n其中求和符号上的撇号表示 $m=-N/2$ 和 $m=N/2$ 的项权重为 $\\frac{1}{2}$。系数 $c_m$ 是数据 $\\{u_j\\}$ 的离散傅里叶系数，由下式给出：\n$$\nc_m = \\frac{1}{N} \\sum_{j=0}^{N-1} u_j e^{-\\mathrm{i} m x_j} = \\frac{1}{N} \\sum_{j=0}^{N-1} u_j e^{-2\\pi \\mathrm{i} m j / N} \\quad \\text{for } m = -N/2, \\dots, N/2.\n$$\n此表达式通过离散傅里叶变换（DFT）将插值系数与网格点上的值联系起来。具体来说，如果 $\\hat{\\mathbf{u}}$ 是向量 $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$ 的DFT系数向量，定义为 $\\hat{u}_k = \\sum_{j=0}^{N-1} u_j e^{-2\\pi \\mathrm{i} j k / N}$，那么系数 $c_m$ 就是 $\\frac{1}{N}\\hat{u}_m$。\n\n函数 $u(x)$ 的导数由其插值函数 $p'(x)$ 的导数来近似：\n$$\np'(x) = \\frac{d}{dx} \\left( \\sum_{m=-N/2}^{N/2} ' c_m e^{\\mathrm{i} m x} \\right) = \\sum_{m=-N/2}^{N/2} ' (\\mathrm{i} m) c_m e^{\\mathrm{i} m x}.\n$$\n这展示了傅里叶谱方法的一个基本特性：物理空间中的微分在傅里叶空间中变成了简单的乘以 $\\mathrm{i}m$，其中 $m$ 是波数。\n\n令 $\\mathbf{v}$ 为网格点上近似导数值的向量，$v_j = p'(x_j)$。在 $x_j$ 处计算 $p'(x)$ 可得：\n$$\nv_j = p'(x_j) = \\sum_{m=-N/2}^{N/2} ' (\\mathrm{i} m) c_m e^{\\mathrm{i} m x_j}.\n$$\n此表达式具有逆离散傅里叶变换（IDFT）的形式。令 $\\hat{v}_m$ 为导数向量 $\\mathbf{v}$ 的DFT系数。其关系为 $\\hat{v}_m = N c'_m$，其中 $c'_m$ 是 $p'(x)$ 的傅里叶级数系数，即 $c'_m = (\\mathrm{i} m) c_m$。因此，$\\hat{v}_m = (\\mathrm{i} m) (N c_m) = (\\mathrm{i} m) \\hat{u}_m$。\n\n这个过程定义了一个从函数值向量 $\\mathbf{u}$ 到导数值向量 $\\mathbf{v}$ 的线性变换。这个变换就是微分矩阵 $D$：$\\mathbf{v} = D\\mathbf{u}$。该操作可以用算法描述为三个步骤：\n1.  将函数值 $\\mathbf{u}$ 变换到傅里叶空间：$\\hat{\\mathbf{u}} = \\text{DFT}(\\mathbf{u})$。\n2.  乘以有效波数：对每个对应的波数 $k_m$，有 $\\hat{\\mathbf{v}}_m = (\\mathrm{i} k_m) \\hat{\\mathbf{u}}_m$。\n3.  变换回物理空间：$\\mathbf{v} = \\text{IDFT}(\\hat{\\mathbf{v}})$。\n\n对于偶数 $N$，在奈奎斯特频率（对应于波数 $m=N/2$）处会出现一个关键细节。基函数 $e^{\\mathrm{i}(N/2)x}$ 和 $e^{-\\mathrm{i}(N/2)x}$ 在网格上不是独立的；它们在网格点上的值均为 $e^{\\mathrm{i} \\pi j} = (-1)^j$。插值函数包含一个与 $\\cos(N/2 x)$ 成正比的项，它在网格上是实值的。其导数 $-(N/2)\\sin(N/2 x)$ 在所有网格点 $x_j$ 上均为零。试图通过乘以 $\\mathrm{i}N/2$ 来对 $m=N/2$ 模式进行微分，会从一个实函数的插值中产生一个非实数的结果，这是不一致的。因此，为了保持对实值函数的正确性，奈奎斯特频率的有效微分乘数被设置为 $0$。\n\n对于长度为 $N$ 的输入，标准FFT算法输出对应的波数向量 $\\mathbf{k}$ 通常按 $[0, 1, \\dots, N/2-1, -N/2, \\dots, -1]$ 的顺序排列。为了进行微分，我们修改这个向量，称之为 $\\mathbf{k}'$，方法是将对应于奈奎斯特频率的元素（在此约定中，它是在索引 $N/2$ 处的 $-N/2$）设置为 $0$。\n\n微分矩阵 $D$ 可以用DFT矩阵 $F$ 及其逆矩阵 $F^{-1}$ 来正式表示。DFT矩阵的元素为 $F_{kj} = e^{-2\\pi\\mathrm{i}jk/N}$，IDFT矩阵为 $F^{-1} = \\frac{1}{N}F^*$，其中 $F^*$ 是共轭转置。该操作变为 $\\mathbf{v} = F^{-1} M F \\mathbf{u}$，其中 $M$ 是对角矩阵，其元素为 $M_{mm} = \\mathrm{i}k'_m$。因此，微分矩阵为 $D = F^{-1} M F$。\n\n这个矩阵可以通过将微分过程应用于单位矩阵 $I$ 的各列来数值构造。也就是说，$D$ 的第 $j$ 列是对第 $j$ 个标准基向量 $\\mathbf{e}_j$ 进行微分的结果。\n\n选择这些测试用例是为了评估该方法的特定属性：\n-   **测试 1 和 2 ($u(x) = \\sin(7x), \\sin(15x)$)**：这些函数是带限的，其整数波数（$7$ 和 $15$）远低于奈奎斯特频率 $N/2=16$。伪谱导数应该精确到机器精度，展示了谱精度。\n-   **测试 3 ($u(x) = \\sin(16x)$)**：此函数的波数恰好是奈奎斯特频率。在网格 $x_j = \\pi j/16$ 上，该函数的采样值为 $\\sin(\\pi j) = 0$（对所有 $j$）。数值方法将对一个零向量进行微分，得到零。然而，精确导数 $16\\cos(16x)$ 在网格上的值为 $16(-1)^j$。因此，误差将恰好是 $16$，这说明了在奈奎斯特频率处的混叠病态问题。\n-   **测试 4 ($u(x) = \\sin(7.3x)$)**：此函数不是 $2\\pi$ 周期的。DFT假定采样数据是周期性延拓的，这在边界端点处引入了不连续性（因为 $u(0) \\ne u(2\\pi)$）。这会导致吉布斯现象，污染了傅里叶表示的准确性，并导致与周期情况相比误差显著增大。收敛阶从谱收敛降级为代数收敛。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives the Fourier pseudospectral differentiation matrix and uses it\n    to calculate the derivative of several test functions.\n    \"\"\"\n    \n    # Define parameters from the problem statement\n    N = 32\n    \n    # Define the equispaced grid on [0, 2*pi)\n    # x_j = (2 * pi * j) / N for j = 0, 1, ..., N-1\n    x_j = 2 * np.pi * np.arange(0, N) / N\n    \n    # Construct the Fourier pseudospectral differentiation matrix D\n    \n    # 1. Get the wavenumbers corresponding to the DFT.\n    # For a signal of length N and sample spacing d, fftfreq(N, d) gives\n    # the cycle frequencies. Here, our \"length\" is 2*pi, so sample\n    # spacing is d = 2*pi/N. The wavenumbers m for e^(i*m*x) are what\n    # we need. A simpler way is to get frequencies in cycles per interval\n    # (d=1) and multiply by N, which corresponds to the integer mode numbers.\n    k = np.fft.fftfreq(N) * N\n    \n    # 2. For differentiation, the multiplier for the k-th mode is i*k.\n    # A special case for even N: the Nyquist frequency k = N/2. For a real\n    # function, its derivative must be real. This requires setting the\n    # differentiator for the Nyquist mode to 0. In numpy's fftfreq\n    # convention, this frequency is at index N/2.\n    k_deriv = 1j * k\n    if N % 2 == 0:\n        k_deriv[N // 2] = 0.0\n    \n    # 3. Construct D = F^-1 * M * F, where F is the DFT matrix and M is the\n    # diagonal matrix of multipliers (i*k').\n    # We can do this by applying the differentiation process to the\n    # columns of the identity matrix.\n    I = np.eye(N)\n    D_matrix = np.fft.ifft(k_deriv[:, np.newaxis] * np.fft.fft(I, axis=0), axis=0)\n    \n    # The matrix for a real-to-real differentiation should be real.\n    # Small imaginary parts may exist due to floating-point inaccuracies.\n    D_matrix = D_matrix.real\n    \n    # Define the test suite\n    test_cases = [\n        {'u': lambda x: np.sin(7 * x),   'u_prime': lambda x: 7 * np.cos(7 * x)},\n        {'u': lambda x: np.sin(15 * x),  'u_prime': lambda x: 15 * np.cos(15 * x)},\n        {'u': lambda x: np.sin(16 * x),  'u_prime': lambda x: 16 * np.cos(16 * x)},\n        {'u': lambda x: np.sin(7.3 * x), 'u_prime': lambda x: 7.3 * np.cos(7.3 * x)}\n    ]\n    \n    results = []\n    for case in test_cases:\n        # Sample the function and its exact derivative on the grid\n        u_vec = case['u'](x_j)\n        u_prime_exact = case['u_prime'](x_j)\n        \n        # Approximate the derivative using the differentiation matrix\n        u_prime_approx = D_matrix @ u_vec\n        \n        # Compute the maximum absolute error\n        E = np.max(np.abs(u_prime_approx - u_prime_exact))\n        results.append(E)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "构建微分矩阵的最终目的是为了高效、精确地求解微分方程。本综合练习将引导您应用切比雪夫伪谱方法来解决一个经典的边值问题——泊松方程 。您将构建切比雪夫微分矩阵，将其用于离散化微分算子，并通过替换系统矩阵的特定行来施加狄利克雷边界条件，最终将一个连续的微分方程转化为一个可解的线性代数系统。这个练习完美地展示了伪谱矩阵在科学与工程计算中的实际应用价值。",
            "id": "3417568",
            "problem": "考虑在闭区间 $[-1,1]$ 上的Poisson方程 $-u''(x) = f(x)$，其带有Dirichlet边界条件 $u(-1) = g_{-}$ 和 $u(1) = g_{+}$ 的边值问题。任务是实现一种使用微分矩阵的伪谱配置法，以在一组配置节点上近似解 $u(x)$，然后针对几个光滑的右端项评估其精度。\n\n您必须使用以下基础数值分析方法：\n- 基于Chebyshev-Lobatto (CL) 节点的谱配置法。CL节点定义为 $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j = 0,1,\\dots,N$。\n- 在Lagrange基中的插值多项式的谱导数。如果 $p(x)$ 是通过节点 $\\{x_j\\}$ 上的样本 $u(x_j)$ 的唯一多项式插值，则其在节点处的导数可以表示为矩阵向量积，$p'(x_i) = \\sum_{j=0}^{N} D_{ij} u(x_j)$，其中 $D$ 是根据所选节点上的Lagrange基构造的一阶微分矩阵。节点上的二阶导数则由 $D^{(2)} = D^2$ 表示，且 $p''(x_i) = \\sum_{j=0}^{N} D^{(2)}_{ij} u(x_j)$。\n\n您的程序必须：\n1. 构建Chebyshev-Lobatto节点 $\\{x_j\\}_{j=0}^{N}$。\n2. 基于节点上的Lagrange插值多项式，推导并实现这些节点的一阶谱微分矩阵 $D$（不要使用任何外部预计算矩阵）。然后通过 $D^{(2)} = D^2$ 形成二阶微分矩阵。\n3. 使用伪谱近似在节点上离散化Poisson方程：在所有内部节点上强制执行 $-D^{(2)} u = f$。通过替换线性系统的第一行和最后一行来施加Dirichlet边界条件，以精确强制 $u(x_0) = g_{+}$ 和 $u(x_N) = g_{-}$。\n4. 求解得到的线性系统，以获得 $u$ 的节点值。\n5. 对于每个测试用例，计算数值解与构造的光滑精确解 $u_{\\text{exact}}(x)$ 在CL节点上的最大绝对误差：$\\max_{j} |u_{\\text{num}}(x_j) - u_{\\text{exact}}(x_j)|$。\n\n角度单位规定：凡是使用三角函数时，角度必须以弧度为单位进行解释。\n\n测试套件规格：\n- 测试用例1（正常路径）：$N = 16$, $u_{\\text{exact}}(x) = \\sin(3 x)$, $f(x) = -u_{\\text{exact}}''(x)$，以及Dirichlet边界数据 $g_{-} = u_{\\text{exact}}(-1)$, $g_{+} = u_{\\text{exact}}(1)$。\n- 测试用例2（更高分辨率的光滑指数函数）：$N = 64$, $u_{\\text{exact}}(x) = e^{x}$, $f(x) = -u_{\\text{exact}}''(x)$, $g_{-} = u_{\\text{exact}}(-1)$, $g_{+} = u_{\\text{exact}}(1)$。\n- 测试用例3（多项式边缘情况）：$N = 8$, $u_{\\text{exact}}(x) = x^{5} - x$, $f(x) = -u_{\\text{exact}}''(x)$, $g_{-} = u_{\\text{exact}}(-1)$, $g_{+} = u_{\\text{exact}}(1)$。\n- 测试用例4（更高频率的光滑三角函数）：$N = 80$, $u_{\\text{exact}}(x) = \\cos(10 x)$, $f(x) = -u_{\\text{exact}}''(x)$, $g_{-} = u_{\\text{exact}}(-1)$, $g_{+} = u_{\\text{exact}}(1)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按上述顺序列出的每个测试用例的最大绝对误差。例如，输出格式必须严格为 $[e_1,e_2,e_3,e_4]$ 的形式，其中每个 $e_k$ 是一个浮点数。",
            "solution": "该问题要求使用伪谱配置法，对带有一维Dirichlet边界条件的Poisson方程进行数值求解。具体方法涉及Chebyshev-Lobatto配置点及相关的谱微分矩阵。该方法的有效性和正确性将通过将其应用于一系列具有已知光滑解的测试用例来验证，此过程称为人造解方法。\n\n问题表述为：\n$$\n-u''(x) = f(x), \\quad x \\in [-1, 1]\n$$\n边界条件为\n$$\nu(-1) = g_{-}, \\quad u(1) = g_{+}\n$$\n\n求解过程包括以下步骤：使用Chebyshev-Lobatto节点进行离散化，构造谱微分矩阵，组装线性系统，施加边界条件，求解系统，以及评估数值误差。\n\n**1. 基于Chebyshev-Lobatto节点的伪谱配置法**\n伪谱（或配置）方法的核心原理是用一个次数为 $N$ 或更低的全局多项式 $p(x)$ 来近似连续解 $u(x)$。该多项式被约束在一组预设的 $N+1$ 个配置点 $\\{x_j\\}_{j=0}^N$ 上精确满足微分方程。对于本问题，我们使用Chebyshev-Lobatto节点，它们是 $N$ 次Chebyshev多项式 $T_N(x)$ 的极值点，由下式给出：\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N}\\right), \\quad j = 0, 1, \\dots, N\n$$\n这些点的排序方式为 $1 = x_0 > x_1 > \\dots > x_N = -1$。函数 $u(x)$ 由其在这些节点上的值表示，形成一个向量 $\\mathbf{u} = [u(x_0), u(x_1), \\dots, u(x_N)]^T$。\n\n**2. 谱微分**\n通过点 $(x_j, u_j)$ 的唯一插值多项式 $p(x)$ 可以在Lagrange基中写作 $p(x) = \\sum_{j=0}^N u_j L_j(x)$，其中 $L_j(x)$ 是Lagrange基数多项式。$u(x)$ 在配置节点处的导数由 $p(x)$ 的导数近似。一阶导数向量 $\\mathbf{u}'$ 通过矩阵向量积计算得出：\n$$\n\\mathbf{u}' = D\\mathbf{u}\n$$\n此处，$D$ 是 $(N+1) \\times (N+1)$ 的一阶谱微分矩阵。其元素由 $(D)_{ij} = L'_j(x_i)$ 给出。对于Chebyshev-Lobatto节点，这些元素有众所周知的显式公式：\n$$\n(D)_{ij} = \\frac{c_i}{c_j} \\frac{(-1)^{i+j}}{x_i - x_j}, \\quad \\text{for } i \\neq j\n$$\n$$\n(D)_{00} = \\frac{2N^2+1}{6}, \\quad (D)_{NN} = -\\frac{2N^2+1}{6}\n$$\n$$\n(D)_{ii} = -\\frac{x_i}{2(1-x_i^2)}, \\quad \\text{for } i=1, \\dots, N-1\n$$\n其中常数 $c_j$ 定义为 $c_0 = c_N = 2$ 且当 $j=1, \\dots, N-1$ 时 $c_j = 1$。一种更稳健的计算对角线元素的方法是利用常数函数的导数为零这一性质，这意味着 $D$ 的行和必须为零：$(D)_{ii} = -\\sum_{j\\neq i} (D)_{ij}$。\n\n二阶导数通过两次应用一阶微分矩阵来近似。因此，二阶谱微分矩阵为 $D^{(2)} = D^2$。节点上的二阶导数向量 $\\mathbf{u}''$ 由下式给出：\n$$\n\\mathbf{u}'' = D^{(2)}\\mathbf{u}\n$$\n\n**3. 离散化与线性系统组装**\n我们在**内部**配置节点 $x_i$（其中 $i = 1, \\dots, N-1$）上强制执行Poisson方程 $-u''(x) = f(x)$。将二阶导数的谱近似代入，我们得到一个包含 $N-1$ 个线性代数方程的系统：\n$$\n-\\sum_{j=0}^{N} (D^{(2)})_{ij} u_j = f(x_i), \\quad \\text{for } i = 1, \\dots, N-1\n$$\n令 $A = -D^{(2)}$ 为 $(N+1) \\times (N+1)$ 的算子矩阵，$\\mathbf{u} = [u_0, u_1, \\dots, u_N]^T$ 为未知节点值的向量，$\\mathbf{b} = [f(x_0), f(x_1), \\dots, f(x_N)]^T$ 为在所有节点上求值的右端项函数向量。该方程组可以写作 $A \\mathbf{u} = \\mathbf{b}$，但由于尚未应用边界条件，该系统尚未完全确定。\n\n**4. 施加边界条件**\nDirichlet边界条件提供了解在定义域边界上的值：$u(1) = g_+$ 和 $u(-1) = g_-$。在我们的节点表示中，由于 $x_0 = 1$ 和 $x_N = -1$，这些条件固定了解向量的第一个和最后一个元素：\n$$\nu_0 = g_+\n$$\n$$\nu_N = g_-\n$$\n为了将这些已知值并入 $(N+1) \\times (N+1)$ 线性系统中，我们修改矩阵 $A$ 和向量 $\\mathbf{b}$。系统的第一行被替换为方程 $u_0 = g_+$，最后一行被替换为 $u_N = g_-$。内部行保持为离散化的Poisson方程。\n\n修改后的系统，我们称之为 $A_{mod} \\mathbf{u} = \\mathbf{b}_{mod}$，其构造如下：\n- 对于第一行 ($i=0$)：设置 $(A_{mod})_{0,j} = \\delta_{0j}$ (即，在 $j=0$ 处为 $1$，其他位置为 $0$) 且 $(b_{mod})_0 = g_+$。这强制执行 $1 \\cdot u_0 + 0 \\cdot u_1 + \\dots = g_+$。\n- 对于内部行 ($i=1, \\dots, N-1$)：保留算子的原始行，即 $(A_{mod})_{i,j} = A_{ij}$ 且 $(b_{mod})_i = b_i = f(x_i)$。\n- 对于最后一行 ($i=N$)：设置 $(A_{mod})_{N,j} = \\delta_{Nj}$ (即，在 $j=N$ 处为 $1$，其他位置为 $0$) 且 $(b_{mod})_N = g_-$。这强制执行 $0 \\cdot u_0 + \\dots + 1 \\cdot u_N = g_-$。\n\n**5. 求解与误差评估**\n修改后的线性系统 $A_{mod} \\mathbf{u} = \\mathbf{b}_{mod}$ 是非奇异的，可以求解得到未知节点值的向量 $\\mathbf{u}_{\\text{num}}$。然后，通过将该数值解与已知的精确解 $u_{\\text{exact}}(x)$ 进行比较来评估其精度，问题数据（$f(x)$, $g_+$, $g_-$）正是由该精确解构造的。误差计算为配置节点上的最大绝对差：\n$$\n\\text{Error} = \\max_{j=0, \\dots, N} | (u_{\\text{num}})_j - u_{\\text{exact}}(x_j) |\n$$\n对问题陈述中指定的每个测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef chebyshev_lobatto_nodes(N):\n    \"\"\"\n    Computes the N+1 Chebyshev-Lobatto nodes on the interval [-1, 1].\n    The nodes are ordered from 1 down to -1.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0])\n    j = np.arange(N + 1)\n    x = np.cos(np.pi * j / N)\n    return x\n\ndef chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the first-order Chebyshev spectral differentiation matrix \n    on the Chebyshev-Lobatto nodes.\n    \n    Returns:\n        D (np.ndarray): The (N+1)x(N+1) differentiation matrix.\n        x (np.ndarray): The (N+1) Chebyshev-Lobatto nodes.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.]]), np.array([0.])\n    \n    x = chebyshev_lobatto_nodes(N)\n    D = np.zeros((N + 1, N + 1))\n    \n    # Coefficients c_i\n    c = np.ones(N + 1)\n    c[0] = 2.0\n    c[-1] = 2.0\n    \n    # vectorized computation of off-diagonal elements\n    X = np.tile(x, (N + 1, 1))\n    dX = X - X.T\n    # Add identity to avoid division by zero on diagonal, which is handled later\n    np.fill_diagonal(dX, 1.0)\n\n    # c_i/c_j * (-1)^{i+j}\n    C = np.tile(c, (N + 1, 1))\n    C_ratio = C.T / C\n    \n    I_plus_J = np.add.outer(np.arange(N+1), np.arange(N+1))\n    Sign_matrix = (-1)**I_plus_J\n    \n    D = C_ratio * Sign_matrix / dX\n    np.fill_diagonal(D, 0.0) # Zero out diagonal before computing row sums\n    \n    # Diagonal entries using sum-to-zero property: D_ii = -sum(D_ij for j!=i)\n    row_sums = np.sum(D, axis=1)\n    np.fill_diagonal(D, -row_sums)\n    \n    return D, x\n\ndef solve_poisson_spectral(N, u_exact, f_rhs):\n    \"\"\"\n    Solves the Poisson equation -u'' = f on [-1, 1] using a spectral method.\n    \n    Args:\n        N (int): The degree of the interpolating polynomial. The number of nodes is N+1.\n        u_exact (callable): The exact solution function u(x).\n        f_rhs (callable): The right-hand side function f(x) of the Poisson eq.\n\n    Returns:\n        float: The maximum absolute error between the numerical and exact solutions.\n    \"\"\"\n    # 1. Get differentiation matrix D and nodes x\n    D, x = chebyshev_diff_matrix(N)\n    \n    # 2. Compute second differentiation matrix D2 = D^2\n    D2 = np.dot(D, D)\n    \n    # 3. Assemble the linear system operator A = -D2\n    A = -D2\n    \n    # 4. Assemble the right-hand side vector b\n    b = f_rhs(x)\n    \n    # 5. Define and impose Dirichlet boundary conditions\n    g_plus = u_exact(1.0)  # u(1)\n    g_minus = u_exact(-1.0) # u(-1)\n    \n    # Node ordering is x_0=1, x_N=-1.\n    # Modify first row for u(1) = g_plus\n    A[0, :] = 0.0\n    A[0, 0] = 1.0\n    b[0] = g_plus\n    \n    # Modify last row for u(-1) = g_minus\n    A[-1, :] = 0.0\n    A[-1, -1] = 1.0\n    b[-1] = g_minus\n    \n    # 6. Solve the linear system A * u_num = b\n    u_num = np.linalg.solve(A, b)\n    \n    # 7. Evaluate exact solution at nodes\n    u_exact_vals = u_exact(x)\n    \n    # 8. Compute maximum absolute error\n    max_error = np.max(np.abs(u_num - u_exact_vals))\n    \n    return max_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite specification\n    test_cases = [\n        {\n            \"N\": 16,\n            \"u_exact\": lambda x: np.sin(3 * x),\n            \"f_rhs\": lambda x: 9 * np.sin(3 * x) # f = -u''\n        },\n        {\n            \"N\": 64,\n            \"u_exact\": lambda x: np.exp(x),\n            \"f_rhs\": lambda x: -np.exp(x) # f = -u''\n        },\n        {\n            \"N\": 8,\n            \"u_exact\": lambda x: x**5 - x,\n            \"f_rhs\": lambda x: -20 * x**3 # f = -u''\n        },\n        {\n            \"N\": 80,\n            \"u_exact\": lambda x: np.cos(10 * x),\n            \"f_rhs\": lambda x: 100 * np.cos(10 * x) # f = -u''\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_poisson_spectral(\n            N=case[\"N\"],\n            u_exact=case[\"u_exact\"],\n            f_rhs=case[\"f_rhs\"]\n        )\n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}