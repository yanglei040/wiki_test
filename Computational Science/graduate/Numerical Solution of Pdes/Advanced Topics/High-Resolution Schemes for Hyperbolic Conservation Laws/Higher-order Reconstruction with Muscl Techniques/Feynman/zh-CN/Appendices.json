{
    "hands_on_practices": [
        {
            "introduction": "在验证任何高阶数值格式时，首要步骤是确认其在光滑解上的理论收敛阶。本练习  提供了一个具体的方法，通过对一个光滑的正弦波进行 MUSCL 重构，并测量重构误差如何随网格尺寸减小而变化。这不仅能验证您实现的正确性，还能加深对收敛阶分析这一核心概念的理解。",
            "id": "3403631",
            "problem": "考虑周期性域 $[0,L]$（其中 $L=2\\pi$）上光滑标量场 $u(x)$ 的一维重构问题。设 $u(x)=\\sin(kx)$，其中波数 $k>0$ 为固定值。在一个包含 $N$ 个单元、网格宽度为 $\\Delta x = L/N$ 的均匀有限体积网格中，将单元 $i$ 表示为区间 $[x_{i-\\frac{1}{2}},x_{i+\\frac{1}{2}}]$，其中心为 $x_i=\\left(i+\\frac{1}{2}\\right)\\Delta x$，其中 $i\\in\\{0,1,\\dots,N-1\\}$ 且采用周期性索引。单元平均值定义为 $u_i=\\frac{1}{\\Delta x}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}}u(x)\\,\\mathrm{d}x$。在守恒律的单调上游中心格式 (Monotone Upstream-centered Schemes for Conservation Laws, MUSCL) 框架中，使用一个限制斜率 $s_i$ 在每个单元内建立分段线性重构，使得左右界面状态 $u_{i+\\frac{1}{2}}^{-}$ 和 $u_{i+\\frac{1}{2}}^{+}$ 为\n$$\nu_{i+\\frac{1}{2}}^{-} = u_i + \\frac{\\Delta x}{2}\\,s_i,\\qquad\nu_{i+\\frac{1}{2}}^{+} = u_{i+1} - \\frac{\\Delta x}{2}\\,s_{i+1},\n$$\n其中对 $i+1$ 采用周期性索引。使用 Monotonized Central 限制器，该限制器对于光滑的 $u$ 是总变差递减 (Total Variation Diminishing, TVD) 的，并通过 minmod 函数定义。设单边和中心离散斜率为\n$$\n\\delta^-_i = \\frac{u_i - u_{i-1}}{\\Delta x},\\quad\n\\delta^+_i = \\frac{u_{i+1} - u_{i}}{\\Delta x},\\quad\n\\delta^c_i = \\frac{u_{i+1} - u_{i-1}}{2\\,\\Delta x},\n$$\n并将限制斜率 $s_i$ 定义为\n$$\ns_i = \\operatorname{minmod}\\!\\left(\\delta^c_i,\\,2\\,\\delta^-_i,\\,2\\,\\delta^+_i\\right),\n$$\n其中，三参数 minmod 函数为\n$$\n\\operatorname{minmod}(a,b,c)=\n\\begin{cases}\n\\operatorname{sign}(a)\\,\\min\\{|a|,|b|,|c|\\},  \\text{if } \\operatorname{sign}(a)=\\operatorname{sign}(b)=\\operatorname{sign}(c),\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n定义精确的界面位置为 $x_{i+\\frac{1}{2}} = (i+1)\\Delta x$。界面重构误差通过将左右重构状态与精确的界面点值 $u(x_{i+\\frac{1}{2}})$ 进行比较，在离散 $L^2$ 意义下进行度量：\n$$\nE(\\Delta x) = \\left( \\frac{1}{N}\\sum_{i=0}^{N-1}\\frac{1}{2}\\left[\\left(u_{i+\\frac{1}{2}}^{-}-u(x_{i+\\frac{1}{2}})\\right)^2 + \\left(u_{i+\\frac{1}{2}}^{+}-u(x_{i+\\frac{1}{2}})\\right)^2\\right] \\right)^{\\frac{1}{2}}.\n$$\n您的任务是执行一致性检验，即使用上述 MUSCL 过程重构 $u(x)=\\sin(kx)$，并在固定的 $k$ 值下针对多个网格宽度 $\\Delta x$ 计算 $E(\\Delta x)$。然后，通过拟合模型 $E(\\Delta x)\\approx C\\,\\Delta x^{p}$ 来估计观测到的精度阶 $p$，即对 $\\log(E(\\Delta x))$ 与 $\\log(\\Delta x)$ 进行最小二乘拟合，并报告斜率 $p$。\n\n从基本定义开始：有限体积单元平均值和带有 TVD 限制器的 MUSCL 重构。除了这些定义和给定的 $u(x)$ 所蕴含的公式外，不要使用任何其他公式来推导预期的缩放关系。在需要时，使用周期性边界条件来定义 $u_{-1}=u_{N-1}$ 和 $u_N=u_0$。程序应根据 $u(x)=\\sin(kx)$ 解析地计算精确的单元平均值。\n\n测试套件：\n- 案例 1：$k=3$, $N\\in\\{16,32,64,128\\}$。\n- 案例 2：$k=1$, $N\\in\\{20,40,80,160\\}$。\n- 案例 3：$k=8$, $N\\in\\{64,128,256,512\\}$。\n\n对于每个案例，计算所列 $N$ 值对应的 $E(\\Delta x)$，拟合精度阶 $p$，并返回对应于三个案例的列表 $[p_1,p_2,p_3]$。最终答案必须表示为单行输出，包含用方括号括起来并以逗号分隔的结果（例如，$[p_1,p_2,p_3]$）。所有量都是无量纲的；不涉及物理单位，也无需指定角度单位。$p_1$、$p_2$ 和 $p_3$ 的输出值必须是浮点数。",
            "solution": "本问题的目标是进行一个数值实验，以确定守恒律的单调上游中心格式 (MUSCL) 空间重构过程的观测精度阶。该重构应用于一维周期性域上的光滑标量场 $u(x)=\\sin(kx)$。精度阶 $p$ 是通过将计算出的重构误差 $E$ 拟合到幂律模型 $E(\\Delta x) \\approx C(\\Delta x)^p$ 来确定的，其中 $\\Delta x$ 是网格间距。分析过程将首先推导必要的解析表达式，然后概述重构和误差计算的算法步骤，最后描述估计 $p$ 的方法。\n\n**1. 解析单元平均值**\n\n有限体积法的基础是单元平均值。对于由区间 $[x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$ 定义的单元 $i$，场 $u(x)$ 的单元平均值 $u_i$ 由下式给出\n$$u_i = \\frac{1}{\\Delta x} \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x) \\, \\mathrm{d}x.$$\n问题在域 $[0, L]$（其中 $L=2\\pi$）上定义了一个包含 $N$ 个单元的均匀网格，因此网格宽度为 $\\Delta x = L/N = 2\\pi/N$。单元界面位于 $x_{i+\\frac{1}{2}} = (i+1)\\Delta x$，其中 $i \\in \\{-1, 0, \\dots, N-1\\}$。因此，单元 $i$ 跨越区间 $[i\\Delta x, (i+1)\\Delta x]$。单元中心为 $x_i = (i+\\frac{1}{2})\\Delta x$。\n\n代入 $u(x) = \\sin(kx)$ 和积分限，我们解析地计算该积分：\n$$u_i = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} \\sin(kx) \\, \\mathrm{d}x = \\frac{1}{\\Delta x} \\left[ -\\frac{1}{k} \\cos(kx) \\right]_{i\\Delta x}^{(i+1)\\Delta x}.$$\n在积分限上计算该表达式可得\n$$u_i = -\\frac{1}{k\\Delta x} \\left[ \\cos(k(i+1)\\Delta x) - \\cos(ki\\Delta x) \\right].$$\n使用三角恒等式 $\\cos(A) - \\cos(B) = -2\\sin\\left(\\frac{A+B}{2}\\right)\\sin\\left(\\frac{A-B}{2}\\right)$，我们可以简化此表达式。设 $A=k(i+1)\\Delta x$ 和 $B=ki\\Delta x$。则 $\\frac{A+B}{2} = k(i+\\frac{1}{2})\\Delta x = kx_i$ 且 $\\frac{A-B}{2} = \\frac{k\\Delta x}{2}$。\n将这些代入 $u_i$ 的公式中可得\n$$u_i = -\\frac{1}{k\\Delta x} \\left[ -2\\sin(kx_i)\\sin\\left(\\frac{k\\Delta x}{2}\\right) \\right] = \\sin(kx_i) \\cdot \\frac{\\sin(k\\Delta x/2)}{k\\Delta x/2}.$$\n对于任何给定的 $k$ 和 $N$，这个精确的单元平均值 $u_i$ 公式将用于初始化重构过程的离散数据。\n\n**2. 使用 Monotonized Central 限制器的 MUSCL 重构**\n\nMUSCL 格式在每个单元 $i$ 内构造 $u(x)$ 的分段线性近似，形式为 $u_i(x) = u_i + s_i(x-x_i)$。关键部分是限制斜率 $s_i$，其设计目的是防止伪振荡。计算 $s_i$ 和重构界面值的步骤如下。\n\n首先，对于每个单元 $i \\in \\{0, 1, \\dots, N-1\\}$，我们使用单元平均值 $\\{u_j\\}$ 计算斜率的三种不同有限差分近似：\n- 后向差分：$\\delta^-_i = \\frac{u_i - u_{i-1}}{\\Delta x}$\n- 前向差分：$\\delta^+_i = \\frac{u_{i+1} - u_i}{\\Delta x}$\n- 中心差分：$\\delta^c_i = \\frac{u_{i+1} - u_{i-1}}{2\\Delta x}$\n施加周期性边界条件，使得 $u_{-1}=u_{N-1}$ 且 $u_N=u_0$。\n\n接下来，将 Monotonized Central (MC) 限制器应用于这些斜率，以获得最终的限制斜率 $s_i$：\n$$s_i = \\operatorname{minmod}\\!\\left(\\delta^c_i,\\,2\\,\\delta^-_i,\\,2\\,\\delta^+_i\\right).$$\n三参数 $\\operatorname{minmod}$ 函数定义为\n$$\n\\operatorname{minmod}(a,b,c)=\n\\begin{cases}\n\\operatorname{sign}(a)\\,\\min\\{|a|,|b|,|c|\\},  \\text{if } \\operatorname{sign}(a)=\\operatorname{sign}(b)=\\operatorname{sign}(c),\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n在解的光滑区域，该限制器通常选择中心差分斜率，从而产生二阶精度。然而，在局部极值附近，单边差分的符号可能相反，导致 $\\operatorname{minmod}$ 函数返回 $0$。这种斜率的“平坦化”确保了总变差递减 (TVD) 属性，但会局部降低精度。\n\n在计算出所有单元的限制斜率 $\\{s_i\\}$ 后，解的状态在每个单元界面 $x_{i+\\frac{1}{2}}$ 的左右两侧被重构。从单元 $i$ 重构到其右界面的值记为 $u_{i+\\frac{1}{2}}^{-}$，从单元 $i+1$ 重构到其左界面的值记为 $u_{i+\\frac{1}{2}}^{+}$：\n$$u_{i+\\frac{1}{2}}^{-} = u_i + \\frac{\\Delta x}{2}\\,s_i$$\n$$u_{i+\\frac{1}{2}}^{+} = u_{i+1} - \\frac{\\Delta x}{2}\\,s_{i+1}$$\n同样，在计算界面 $i=N-1$ 的表达式时，周期性索引意味着 $u_{N} = u_0$ 和 $s_{N} = s_0$。\n\n**3. 误差计算**\n\n重构的精度是通过将重构的界面值与函数 $u(x)$ 在界面处的精确点值 $u(x_{i+\\frac{1}{2}})$ 进行比较来量化的。误差使用离散 $L^2$ 范数来度量，定义如下：\n$$\nE(\\Delta x) = \\left( \\frac{1}{N}\\sum_{i=0}^{N-1}\\frac{1}{2}\\left[\\left(u_{i+\\frac{1}{2}}^{-}-u(x_{i+\\frac{1}{2}})\\right)^2 + \\left(u_{i+\\frac{1}{2}}^{+}-u(x_{i+\\frac{1}{2}})\\right)^2\\right] \\right)^{\\frac{1}{2}}.\n$$\n对于每个测试案例，我们为一系列递减的网格尺寸 $\\Delta x = 2\\pi/N$ 计算 $E(\\Delta x)$。\n\n**4. 精度阶的估计**\n\n如果一个数值格式的误差 $E$ 随着网格尺寸 $\\Delta x$ 按照幂律 $E(\\Delta x) \\approx C(\\Delta x)^p$ 减小（其中 $C$ 为某个常数，且 $\\Delta x \\to 0$），则称该格式为 $p$ 阶。为了估计 $p$，我们可以对这个关系式取对数：\n$$\\log(E(\\Delta x)) \\approx \\log(C) + p \\log(\\Delta x).$$\n这显示了 $\\log(E)$ 和 $\\log(\\Delta x)$ 之间的线性关系，其斜率即为精度阶 $p$。对于每个测试案例，我们都给定了一组 $N$ 值。我们将计算相应的点对 $(\\Delta x_j, E_j)$，将其转换为 $(\\log(\\Delta x_j), \\log(E_j))$，然后执行线性最小二乘回归以找到最佳拟合线的斜率。这个斜率提供了估计的数值精度阶 $p$。对于光滑函数 $u(x)=\\sin(kx)$，MC 限制器预期具有二阶精度，因此我们预计 $p \\approx 2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the order of accuracy for MUSCL reconstruction on a sine wave\n    for three different test cases.\n    \"\"\"\n    \n    test_cases = [\n        {'k': 3, 'N_values': [16, 32, 64, 128]},\n        {'k': 1, 'N_values': [20, 40, 80, 160]},\n        {'k': 8, 'N_values': [64, 128, 256, 512]},\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        k = case['k']\n        N_values = case['N_values']\n        \n        errors = []\n        dx_values = []\n        \n        for N in N_values:\n            L = 2.0 * np.pi\n            dx = L / N\n            dx_values.append(dx)\n            \n            # --- 1. Compute Analytical Cell Averages ---\n            i = np.arange(N)\n            x_i = (i + 0.5) * dx\n            \n            # Formula: u_i = sin(k*x_i) * (sin(k*dx/2) / (k*dx/2))\n            arg = k * dx / 2.0\n            if arg == 0:\n                sinc_term = 1.0\n            else:\n                sinc_term = np.sin(arg) / arg\n            u = np.sin(k * x_i) * sinc_term\n            \n            # --- 2. Compute Limited Slopes ---\n            # Create padded array for periodic boundaries\n            # u_padded = [u_{N-1}, u_0, ..., u_{N-1}, u_0]\n            u_im1 = np.roll(u, 1)\n            u_ip1 = np.roll(u, -1)\n            \n            # One-sided and centered slopes\n            delta_minus = (u - u_im1) / dx\n            delta_plus = (u_ip1 - u) / dx\n            delta_center = (u_ip1 - u_im1) / (2.0 * dx)\n            \n            # Vectorized minmod function for s_i\n            slopes_stack = np.stack((delta_center, 2 * delta_minus, 2 * delta_plus), axis=0)\n            signs = np.sign(slopes_stack)\n            all_same_sign = np.all(signs == signs[0, :], axis=0)\n            \n            min_mags = np.min(np.abs(slopes_stack), axis=0)\n\n            s = np.zeros(N)\n            # Apply minmod rule where signs are the same\n            s[all_same_sign] = np.sign(delta_center[all_same_sign]) * min_mags[all_same_sign]\n\n            # --- 3. Compute Interface Reconstruction and Error ---\n            # Reconstructed values at interface x_{i+1/2}\n            # u_iph_minus from cell i, u_iph_plus from cell i+1\n            u_i = u\n            s_i = s\n            s_ip1 = np.roll(s_i, -1)\n            u_ip1 = np.roll(u_i, -1)\n\n            u_iph_minus = u_i + (dx / 2.0) * s_i\n            u_iph_plus = u_ip1 - (dx / 2.0) * s_ip1\n\n            # Exact values at interfaces x_{i+1/2} = (i+1)*dx\n            x_iph = (i + 1.0) * dx\n            u_exact_iph = np.sin(k * x_iph)\n            \n            # Error calculation\n            err_sq = 0.5 * ((u_iph_minus - u_exact_iph)**2 + (u_iph_plus - u_exact_iph)**2)\n            E = np.sqrt(np.mean(err_sq))\n            errors.append(E)\n\n        # --- 4. Estimate Order of Accuracy ---\n        log_dx = np.log(np.array(dx_values))\n        log_E = np.log(np.array(errors))\n        \n        # Fit a line (polynomial of degree 1) to the log-log data\n        p, _ = np.polyfit(log_dx, log_E, 1)\n        results.append(p)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将 MUSCL 方法从标量方程推广到欧拉这样的方程组时，会遇到一个关键的挑战：应该对哪些变量进行限制？本练习  通过一个代数示例，清晰地揭示了直接对守恒变量进行限制可能在接触间断面上引入虚假的压力振荡。通过对比，它强调了基于物理波分解的特征变量限制为何是保持解结构和鲁棒性的更优选择。",
            "id": "3403607",
            "problem": "考虑理想气体的一维可压缩欧拉方程，\n$$\n\\partial_t U + \\partial_x F(U) = 0,\n$$\n其中守恒变量为 $U = [\\rho, m, E]^\\top$，包含质量密度 $\\rho$、动量 $m = \\rho u$ 和总能量 $E$。通量为\n$$\nF(U) = \\begin{bmatrix}\nm \\\\\n\\frac{m^2}{\\rho} + p \\\\\n\\left(E + p\\right)\\frac{m}{\\rho}\n\\end{bmatrix},\n$$\n热力学封闭关系为\n$$\np = (\\gamma - 1)\\left(E - \\frac{m^2}{2 \\rho}\\right),\n$$\n其中比热比 $\\gamma > 1$ 为常数。压力平衡的接触间断是一种两态结构，其左右原始状态 $W_L = [\\rho_L, u_L, p_L]$ 和 $W_R = [\\rho_R, u_R, p_R]$ 满足 $u_L = u_R$ 和 $p_L = p_R$，但 $\\rho_L \\ne \\rho_R$。\n\n守恒律的单调上游中心格式（Monotone Upstream-centered Schemes for Conservation Laws, MUSCL）通过使用限制斜率来重构界面值以保持单调性，从而实现更高阶的空间精度。一个关键的设计选择是在守恒变量空间 $U$ 中进行限制，还是在与雅可比矩阵 $\\partial F/\\partial U$ 相关的特征空间中进行限制。在特征空间中，跳跃量会沿着特征场进行分解，从而可以专门对接触场进行限制，而对于压力平衡的接触间断，接触场的压力和速度跳跃量为零。\n\n你的任务是，通过纯代数的单界面重构，证明在守恒变量空间中进行限制可能会在接触间断上引入非零的压力跳跃，而仅作用于接触场的特征逐元限制则能保持压力平衡。你必须使用以下两种MUSCL风格的重构方法，将其应用于单个左右状态对 $(U_L, U_R)$ 来构造界面值：\n\n1. 守恒变量重构：对每个守恒分量 $k \\in \\{\\rho, m, E\\}$，定义一个限制混合系数 $\\phi_k \\in [0,1]$ 并设置\n$$\nU^{\\text{cons}} = U_L + \\begin{bmatrix}\n\\phi_\\rho \\\\\n\\phi_m \\\\\n\\phi_E\n\\end{bmatrix} \\odot \\left(U_R - U_L\\right),\n$$\n其中 $\\odot$ 表示逐元素相乘。计算重构后的压力\n$$\np^{\\text{cons}} = (\\gamma - 1) \\left(E^{\\text{cons}} - \\frac{\\left(m^{\\text{cons}}\\right)^2}{2 \\rho^{\\text{cons}}}\\right).\n$$\n报告绝对压力跳跃 $|p^{\\text{cons}} - p_L|$。\n\n2. 特征场重构：将跳跃量 $dU = U_R - U_L$ 投影到在 $U_L$ 处线性化的 $\\partial F/\\partial U$ 的特征场上。令 $u = m_L/\\rho_L$，$p = p_L$，声速为 $a = \\sqrt{\\gamma p/\\rho_L}$，比焓为 $H = (E_L + p)/\\rho_L$。定义右特征向量\n$$\nr_1 = \\begin{bmatrix} 1 \\\\ u - a \\\\ H - u a \\end{bmatrix},\\quad\nr_2 = \\begin{bmatrix} 1 \\\\ u \\\\ \\tfrac{1}{2} u^2 \\end{bmatrix},\\quad\nr_3 = \\begin{bmatrix} 1 \\\\ u + a \\\\ H + u a \\end{bmatrix}.\n$$\n令原始变量差为\n$$\nd\\rho = \\rho_R - \\rho_L,\\quad du = \\frac{m_R - m_L - u(\\rho_R - \\rho_L)}{\\rho_L},\\quad dp = (\\gamma - 1)\\left(E_R - E_L - u(m_R - m_L) + \\tfrac{1}{2} u^2(\\rho_R - \\rho_L)\\right).\n$$\n计算特征振幅\n$$\n\\alpha_1 = \\frac{dp - \\rho_L a\\, du}{2 a^2},\\quad\n\\alpha_2 = d\\rho - \\frac{dp}{a^2},\\quad\n\\alpha_3 = \\frac{dp + \\rho_L a\\, du}{2 a^2}.\n$$\n对于压力平衡的接触间断，$dp = 0$ 且 $du = 0$，所以只有接触场振幅 $\\alpha_2$ 非零。定义一个单一的接触场限制器 $\\phi_c \\in [0,1]$ 并重构\n$$\nU^{\\text{char}} = U_L + \\phi_c\\, \\alpha_2\\, r_2,\n$$\n然后计算\n$$\np^{\\text{char}} = (\\gamma - 1) \\left(E^{\\text{char}} - \\frac{\\left(m^{\\text{char}}\\right)^2}{2 \\rho^{\\text{char}}}\\right).\n$$\n报告绝对压力跳跃 $|p^{\\text{char}} - p_L|$。\n\n使用以下包含三个案例的测试套件，这些案例通过改变气体、接触强度和混合系数来覆盖不同的工况。对于每个案例，提供 $(\\gamma, \\rho_L, \\rho_R, u, p)$ 和守恒变量混合系数 $(\\phi_\\rho, \\phi_m, \\phi_E)$ 以及特征接触场限制器 $\\phi_c$：\n\n- 案例A（一般接触）：$(\\gamma, \\rho_L, \\rho_R, u, p) = (1.4, 1.0, 0.125, 1.0, 1.0)$，$(\\phi_\\rho, \\phi_m, \\phi_E) = (0.5, 0.55, 0.5)$，$\\phi_c = 0.5$。\n- 案例B（低速下的中等强度接触）：$(\\gamma, \\rho_L, \\rho_R, u, p) = (1.4, 0.5, 2.0, 0.5, 2.0)$，$(\\phi_\\rho, \\phi_m, \\phi_E) = (0.4, 0.44, 0.4)$，$\\phi_c = 0.5$。\n- 案例C（单原子气体的强接触）：$(\\gamma, \\rho_L, \\rho_R, u, p) = (1.667, 1.0, 10.0, 0.2, 5.0)$，$(\\phi_\\rho, \\phi_m, \\phi_E) = (0.6, 0.62, 0.6)$，$\\phi_c = 0.5$。\n\n你的程序必须为每个案例计算两个绝对压力跳跃 $|p^{\\text{cons}} - p|$ 和 $|p^{\\text{char}} - p|$，并生成单行输出，其中包含六个结果，以逗号分隔列表的形式并用方括号括起来，顺序如下\n$$\n\\big[ |p^{\\text{cons}} - p|_{\\text{A}}, |p^{\\text{char}} - p|_{\\text{A}}, |p^{\\text{cons}} - p|_{\\text{B}}, |p^{\\text{char}} - p|_{\\text{B}}, |p^{\\text{cons}} - p|_{\\text{C}}, |p^{\\text{char}} - p|_{\\text{C}} \\big].\n$$\n所有输出必须是十进制形式，不带单位。不涉及角度或百分比。\n\n为确保普遍适用性，请勿使用任何特定领域的单位；将所有量视为无量纲量。程序必须是自包含的，并且不需要用户输入。\n\n该问题是科学上现实的：它在单个界面上分离出MUSCL重构，并比较了在压力平衡接触间断下，分量逐元（守恒变量）限制与特征场限制。测试套件探究了一个一般情况、一个低速工况和一个具有不同 $\\gamma$ 值的强接触情况，以覆盖代表性条件。答案是可量化的浮点数，适合自动验证，并且最终输出格式如上所述是明确无误的。",
            "solution": "守恒形式的一维可压缩欧拉方程为\n$$\n\\partial_t U + \\partial_x F(U) = 0,\\quad U = [\\rho, m, E]^\\top,\\quad F(U) = \\begin{bmatrix}\nm \\\\\n\\frac{m^2}{\\rho} + p \\\\\n\\left(E + p\\right)\\frac{m}{\\rho}\n\\end{bmatrix},\n$$\n压力由理想气体封闭关系给出\n$$\np = (\\gamma - 1)\\left(E - \\frac{m^2}{2 \\rho}\\right).\n$$\n压力平衡的接触间断的特征是其左右原始状态 $W_L = [\\rho_L, u_L, p_L]$ 和 $W_R = [\\rho_R, u_R, p_R]$ 满足 $u_L = u_R = u$ 和 $p_L = p_R = p$，但 $\\rho_L \\ne \\rho_R$。对应的守恒状态为\n$$\nU_L = \\begin{bmatrix} \\rho_L \\\\ \\rho_L u \\\\ \\frac{p}{\\gamma - 1} + \\frac{1}{2} \\rho_L u^2 \\end{bmatrix},\\quad\nU_R = \\begin{bmatrix} \\rho_R \\\\ \\rho_R u \\\\ \\frac{p}{\\gamma - 1} + \\frac{1}{2} \\rho_R u^2 \\end{bmatrix}.\n$$\n我们关注一种典型的守恒律单调上游中心格式（MUSCL）的单界面重构，其中界面值是通过将左右单元状态与限制斜率混合得到的。核心问题是，在守恒变量中进行逐分量限制，还是限制特征振幅，能够得到一个在接触间断上保持压力 $p$ 不变的界面值。\n\n基于原理的分析始于观察到从守恒变量到压力的映射\n$$\np(U) = (\\gamma - 1)\\left(E - \\frac{m^2}{2 \\rho}\\right),\n$$\n是非线性的。因此，在 $U$ 中的逐分量线性混合通常会在 $p$ 中产生非线性变化。相比之下，在给定状态下，雅可比矩阵 $\\partial F/\\partial U$ 的特征场提供了能够分离物理波属性的方向。对于压力平衡的接触间断，跳跃完全位于接触场（中间特征）中，其压力和速度增量为零。仅限制接触振幅能够精确地保持 $p$ 不变。\n\n我们为具有左右状态 $(U_L, U_R)$ 的单个界面将这些思想形式化：\n\n1. 守恒变量 MUSCL 重构对各分量应用独立的限制混合系数，\n$$\nU^{\\text{cons}} = U_L + \\begin{bmatrix}\n\\phi_\\rho \\\\\n\\phi_m \\\\\n\\phi_E\n\\end{bmatrix} \\odot \\left(U_R - U_L\\right),\\quad \\phi_\\rho,\\,\\phi_m,\\,\\phi_E \\in [0,1],\n$$\n其中 $\\odot$ 表示逐元素相乘。重构后的压力为\n$$\np^{\\text{cons}} = (\\gamma - 1)\\left(E^{\\text{cons}} - \\frac{\\left(m^{\\text{cons}}\\right)^2}{2 \\rho^{\\text{cons}}}\\right).\n$$\n由于 $p(U)$ 是非线性的，相对于约束 $m = \\rho u$，动量和质量的限制混合之间的任何不匹配，或者相对于约束 $E = \\frac{p}{\\gamma - 1} + \\frac{1}{2} \\rho u^2$，能量和动能部分之间的任何不匹配，通常都会导致 $p^{\\text{cons}} \\ne p$。这表现为重构的接触间断上出现虚假的压力跳跃 $|p^{\\text{cons}} - p|$。\n\n为了从第一性原理理解这一点，考虑混合后的压力：\n$$\np^{\\text{cons}} = (\\gamma - 1)\\left( E_L + \\phi_E (E_R - E_L) - \\frac{\\left(m_L + \\phi_m (m_R - m_L)\\right)^2}{2\\left(\\rho_L + \\phi_\\rho (\\rho_R - \\rho_L)\\right)} \\right).\n$$\n即使 $u_L = u_R$ 且 $p_L = p_R$，除非 $\\phi_m$ 和 $\\phi_\\rho$ 满足精确约束 $\\phi_m (m_R - m_L) = u\\,\\phi_\\rho (\\rho_R - \\rho_L)$ 且 $\\phi_E (E_R - E_L) = \\frac{1}{2} u^2 \\phi_\\rho (\\rho_R - \\rho_L)$，否则动能项中的非线性将导致 $p^{\\text{cons}} \\ne p$。\n\n2. 特征场 MUSCL 重构分离了波的内容。在 $U_L$ 处 $\\partial F/\\partial U$ 的右特征向量是\n$$\nr_1 = \\begin{bmatrix} 1 \\\\ u - a \\\\ H - u a \\end{bmatrix},\\quad\nr_2 = \\begin{bmatrix} 1 \\\\ u \\\\ \\tfrac{1}{2} u^2 \\end{bmatrix},\\quad\nr_3 = \\begin{bmatrix} 1 \\\\ u + a \\\\ H + u a \\end{bmatrix},\n$$\n其中声速为 $a = \\sqrt{\\gamma p / \\rho_L}$，比焓为 $H = (E_L + p)/\\rho_L$。跳跃量 $dU = U_R - U_L$ 可以使用原始变量差 $d\\rho = \\rho_R - \\rho_L$、$du = \\frac{m_R - m_L - u(\\rho_R - \\rho_L)}{\\rho_L}$ 和\n$$\ndp = (\\gamma - 1)\\left( E_R - E_L - u (m_R - m_L) + \\tfrac{1}{2} u^2 (\\rho_R - \\rho_L) \\right)\n$$\n分解为特征振幅。标准分解得出\n$$\n\\alpha_1 = \\frac{dp - \\rho_L a\\, du}{2 a^2},\\quad\n\\alpha_2 = d\\rho - \\frac{dp}{a^2},\\quad\n\\alpha_3 = \\frac{dp + \\rho_L a\\, du}{2 a^2}.\n$$\n对于压力平衡的接触间断，$dp = 0$ 且 $du = 0$，因此\n$$\n\\alpha_1 = 0,\\quad \\alpha_2 = d\\rho,\\quad \\alpha_3 = 0.\n$$\n仅用 $\\phi_c \\in [0,1]$ 限制接触振幅可得\n$$\nU^{\\text{char}} = U_L + \\phi_c\\, \\alpha_2\\, r_2 = U_L + \\phi_c\\, d\\rho\\begin{bmatrix} 1 \\\\ u \\\\ \\tfrac{1}{2} u^2 \\end{bmatrix}.\n$$\n计算重构后的压力：\n$$\np^{\\text{char}} = (\\gamma - 1)\\left( E_L + \\phi_c\\, d\\rho\\, \\tfrac{1}{2} u^2 - \\frac{\\left(m_L + \\phi_c\\, d\\rho\\, u\\right)^2}{2\\left(\\rho_L + \\phi_c\\, d\\rho\\right)} \\right).\n$$\n因为 $m_L = \\rho_L u$，动能项简化为：\n$$\n\\frac{\\left(m_L + \\phi_c\\, d\\rho\\, u\\right)^2}{2\\left(\\rho_L + \\phi_c\\, d\\rho\\right)} = \\frac{\\left(u(\\rho_L + \\phi_c\\, d\\rho)\\right)^2}{2\\left(\\rho_L + \\phi_c\\, d\\rho\\right)} = \\frac{1}{2} u^2 \\left(\\rho_L + \\phi_c\\, d\\rho\\right).\n$$\n因此\n$$\np^{\\text{char}} = (\\gamma - 1)\\left( E_L + \\phi_c\\, d\\rho\\, \\tfrac{1}{2} u^2 - \\tfrac{1}{2} u^2 \\left(\\rho_L + \\phi_c\\, d\\rho\\right) \\right) = (\\gamma - 1)\\left( E_L - \\tfrac{1}{2} u^2 \\rho_L \\right) = p_L = p.\n$$\n因此，仅限制接触场的特征场重构对于压力平衡的接触间断能够精确保持压力不变，这与 $\\phi_c$ 无关。\n\n程序的算法设计：\n\n- 对每个测试案例，使用以下公式从 $(\\gamma, \\rho_L, \\rho_R, u, p)$ 构造 $U_L$ 和 $U_R$：\n$$\nU_L = \\left[\\rho_L,\\, \\rho_L u,\\, \\frac{p}{\\gamma - 1} + \\frac{1}{2} \\rho_L u^2\\right],\\quad U_R = \\left[\\rho_R,\\, \\rho_R u,\\, \\frac{p}{\\gamma - 1} + \\frac{1}{2} \\rho_R u^2\\right].\n$$\n- 守恒变量重构：将 $(\\phi_\\rho, \\phi_m, \\phi_E)$ 逐分量应用于 $dU = U_R - U_L$ 以获得 $U^{\\text{cons}}$，然后用 $p(U)$ 计算 $p^{\\text{cons}}$ 并存储 $|p^{\\text{cons}} - p|$。\n- 特征场重构：计算 $a = \\sqrt{\\gamma p/\\rho_L}$ 和 $H = (E_L + p)/\\rho_L$，通过计算 $d\\rho, du, dp$ 和 $\\alpha_1, \\alpha_2, \\alpha_3$ 来分解 $dU$。对于纯接触间断，只有 $\\alpha_2$ 非零。使用 $r_2 = [1, u, \\tfrac{1}{2} u^2]^\\top$ 重构 $U^{\\text{char}} = U_L + \\phi_c\\, \\alpha_2\\, r_2$，计算 $p^{\\text{char}}$ 并存储 $|p^{\\text{char}} - p|$。\n- 按指定顺序将三个案例的六个浮点数输出为单行：$[|p^{\\text{cons}} - p|_{\\text{A}}, |p^{\\text{char}} - p|_{\\text{A}}, |p^{\\text{cons}} - p|_{\\text{B}}, |p^{\\text{char}} - p|_{\\text{B}}, |p^{\\text{cons}} - p|_{\\text{C}}, |p^{\\text{char}} - p|_{\\text{C}}]$。\n\n科学现实性和覆盖范围：\n- 测试案例通过改变 $\\gamma$、接触强度 $(\\rho_L, \\rho_R)$ 和速度 $u$，在不同工况下检验非线性压力映射和特征分解。\n- 守恒变量混合系数被有意设置为不相等，这反映了实际中逐分量限制不一定能精确保持原始变量约束的情况；这会在重构状态中产生虚假的压力偏差。\n- 特征场重构仅限制接触振幅，根据推导，这对于压力平衡的接触间断能精确保持压力。\n- 最终输出是可量化的浮点数，适合自动检查，且程序是自包含的。\n\n这从第一性原理证明了为什么在守恒变量中进行限制会在接触间断处产生虚假振荡，而与波物理学对齐的特征逐元限制则可以避免它们。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef primitive_to_conserved(rho, u, p, gamma):\n    E = p / (gamma - 1.0) + 0.5 * rho * u**2\n    m = rho * u\n    return np.array([rho, m, E], dtype=float)\n\ndef pressure_from_conserved(U, gamma):\n    rho, m, E = U\n    return (gamma - 1.0) * (E - 0.5 * (m**2) / rho)\n\ndef characteristic_contact_reconstruction(U_L, U_R, gamma, phi_c):\n    # Left primitive quantities\n    rho_L, m_L, E_L = U_L\n    # Compute left pressure using closure (should match given p, but we recompute for robustness)\n    p_L = pressure_from_conserved(U_L, gamma)\n    u = m_L / rho_L\n    a = np.sqrt(gamma * p_L / rho_L)\n    H = (E_L + p_L) / rho_L\n\n    # Jump in conserved variables\n    dU = U_R - U_L\n    drho = dU[0]\n    # primitive increments linearized about left state\n    du = (dU[1] - u * drho) / rho_L\n    dp = (gamma - 1.0) * (dU[2] - u * dU[1] + 0.5 * u**2 * drho)\n\n    # Characteristic amplitudes\n    alpha1 = (dp - rho_L * a * du) / (2.0 * a**2)\n    alpha2 = drho - dp / (a**2)\n    alpha3 = (dp + rho_L * a * du) / (2.0 * a**2)\n\n    # For a pressure-equilibrium contact, dp=0 and du=0 -> alpha1=alpha3=0, alpha2=drho.\n    # Limit only the contact amplitude.\n    alpha1_l = 0.0\n    alpha2_l = phi_c * alpha2\n    alpha3_l = 0.0\n\n    # Right eigenvectors at U_L\n    r1 = np.array([1.0, u - a, H - u * a], dtype=float)\n    r2 = np.array([1.0, u, 0.5 * u**2], dtype=float)\n    r3 = np.array([1.0, u + a, H + u * a], dtype=float)\n\n    dU_limited = alpha1_l * r1 + alpha2_l * r2 + alpha3_l * r3\n    U_face = U_L + dU_limited\n    return U_face\n\ndef conserved_component_reconstruction(U_L, U_R, phi_rho, phi_m, phi_E):\n    dU = U_R - U_L\n    # Apply component-wise mixing coefficients\n    mix = np.array([phi_rho, phi_m, phi_E], dtype=float) * dU\n    U_face = U_L + mix\n    return U_face\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (gamma, rho_L, rho_R, u, p, phi_rho, phi_m, phi_E, phi_c)\n    test_cases = [\n        (1.4,   1.0,   0.125, 1.0, 1.0, 0.5, 0.55, 0.5, 0.5),     # Case A\n        (1.4,   0.5,   2.0,   0.5, 2.0, 0.4, 0.44, 0.4, 0.5),     # Case B\n        (1.667, 1.0,   10.0,  0.2, 5.0, 0.6, 0.62, 0.6, 0.5),     # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        gamma, rho_L, rho_R, u, p, phi_rho, phi_m, phi_E, phi_c = case\n\n        # Build conserved left and right states from primitives\n        U_L = primitive_to_conserved(rho_L, u, p, gamma)\n        U_R = primitive_to_conserved(rho_R, u, p, gamma)\n\n        # Conserved-variable reconstruction and pressure jump\n        U_cons = conserved_component_reconstruction(U_L, U_R, phi_rho, phi_m, phi_E)\n        p_cons = pressure_from_conserved(U_cons, gamma)\n        p_jump_cons = abs(p_cons - p)\n\n        # Characteristic-field reconstruction and pressure jump\n        U_char = characteristic_contact_reconstruction(U_L, U_R, gamma, phi_c)\n        p_char = pressure_from_conserved(U_char, gamma)\n        p_jump_char = abs(p_char - p)\n\n        # Append both results for this case\n        results.append(p_jump_cons)\n        results.append(p_jump_char)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.12g}', results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论上，不同的斜率限制器在精度和单调性之间存在不同的权衡。本综合练习  将带领您实现一个完整的 MUSCL-Hancock 格式，并在一系列经典测试问题（光滑波、接触间断和激波）上系统地评估限制器参数的影响。通过量化精度和鲁棒性指标，您将学会如何在实际应用中分析和选择最适合特定问题的数值方案。",
            "id": "3403590",
            "problem": "您的任务是设计并实现一个程序，该程序评估高阶守恒律单调上游中心格式 (MUSCL) 解对限制器参数的敏感性，测试对象为一组标量守恒律的初始数据。重点是量化当限制器参数变化时，精度和鲁棒性之间的权衡。\n\n基本原理与问题设置：\n- 考虑一维空间中的标量守恒律，写作 $u_t + f(u)_x = 0$，其中 $u(x,t)$ 是守恒量，$f(u)$ 是通量函数。\n- 实现一个二阶、总变差递减 (TVD) 的 MUSCL-Hancock 有限体积格式，该格式在每个单元中使用斜率限制器重构分段线性剖面。限制器由广义 minmod 族中的一个实数 $\\theta \\in [1,2]$ 参数化，用于控制重构的压缩性。\n- 使用一个鲁棒的近似黎曼求解器，基于半时间步的左右重构状态来计算单元间的数值通量；例如，使用与守恒律和特征速度相一致的局部 Lax–Friedrichs (Rusanov) 通量。\n- 通过选择时间步长 $\\Delta t$ 来强制执行 Courant–Friedrichs–Lewy (CFL) 稳定性，使得 $\\mathrm{CFL} \\le 1$。该选择基于最大特征速度 $|f'(u)|$。\n\n初始数据组与控制方程：\n- 案例1（平滑波，线性平流）：在周期性域 $x \\in [0,1]$ 上演化 $u_t + a\\,u_x = 0$（其中 $a = 1$），从 $u(x,0) = \\sin(2\\pi x)$ 开始，直到最终时间 $T = 1.0$。精确解是平流波 $u(x,T) = \\sin\\big(2\\pi(x - aT)\\big)$。\n- 案例2（接触间断，线性平流）：在周期性域 $x \\in [0,1]$ 上演化 $u_t + a\\,u_x = 0$（其中 $a = 1$），从一个阶跃函数 $u(x,0) = 1$（对于 $x < 0.5$）和 $u(x,0) = 0$（对于 $x \\ge 0.5$）开始，直到最终时间 $T = 0.25$。精确解是平移后的阶跃函数：如果 $(x - aT) \\bmod 1 < 0.5$，则 $u(x,T) = 1$，否则 $u(x,T) = 0$。\n- 案例3（激波，无粘性 Burgers 方程）：在非周期性域 $x \\in [-1,1]$ 上演化 $u_t + \\left(\\tfrac{1}{2}u^2\\right)_x = 0$，从一个黎曼型阶跃函数 $u(x,0) = 1$（对于 $x < 0$）和 $u(x,0) = 0$（对于 $x \\ge 0$）开始，使用透射（零梯度）边界条件，直到最终时间 $T = 0.5$。精确解是一个以速度 $s = \\frac{f(1)-f(0)}{1-0} = \\tfrac{1}{2}$ 传播的激波，得到 $u(x,T) = 1$（对于 $x < sT$），否则 $u(x,T) = 0$。\n\n限制器参数敏感性：\n- 使用广义 minmod 限制器参数 $\\theta \\in \\{1.0, 1.5, 2.0\\}$，其范围在 Sweby 族特征内，从最耗散到更具压缩性的重构。对于每个案例和每个 $\\theta$ 值，使用合适的 CFL 数运行 MUSCL-Hancock 格式直到时间 $T$。\n\n量化精度与鲁棒性的度量指标：\n- 精度度量指标：\n  - 最终时间的离散 $L^1$ 误差：通过网格间距为 $\\Delta x$ 的网格求和来近似 $\\int |u_{\\text{num}}(x,T) - u_{\\text{exact}}(x,T)|\\,dx$。\n  - 最终时间的离散 $L^\\infty$ 误差：所有网格点上绝对差值的最大值。\n- 鲁棒性度量指标：\n  - 总变差比率 $\\mathrm{TV}(u(\\cdot,T))/\\mathrm{TV}(u(\\cdot,0))$，其中总变差计算为相邻点绝对跳跃值的总和，在周期性情况下使用周期性包裹，在非周期性情况下不包裹。\n  - 相对于已知边界的过冲幅度，定义为最终时间点的 $\\max\\{0, \\max(u) - u_{\\max}^{\\text{bound}}\\} + \\max\\{0, u_{\\min}^{\\text{bound}} - \\min(u)\\}$。对于案例1，使用边界 $[-1,1]$；对于案例2和3，使用边界 $[0,1]$。\n\n离散化与参数：\n- 对于案例1和2，在 $[0,1]$ 上使用 $N = 400$ 个单元的均匀网格；对于案例3，在 $[-1,1]$ 上使用 $N = 800$ 个单元的均匀网格。\n- 使用 Courant 数 $\\mathrm{CFL} = 0.45$。\n- 对于线性平流案例，采用周期性边界条件；对于 Burgers 方程，采用透射（零梯度）边界条件。\n\n测试组：\n- 测试组由上述三个案例与三个限制器参数值 $\\theta \\in \\{1.0, 1.5, 2.0\\}$ 组合而成，总共九次运行。对于每次运行，计算四个度量指标，结果为无单位浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。最外层列表必须有三个条目（每个案例一个），每个条目是一个包含三个条目（每个限制器参数一个）的列表，每个条目又是一个包含四个浮点数的列表，顺序为 $[L^1, L^\\infty, \\mathrm{TV\\ ratio}, \\mathrm{overshoot}]$。例如，输出的形状将是\n$[[[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot]],[[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot]],[[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot]]]$。\n\n所有答案都是无单位的，并且必须以浮点数形式报告。不涉及角度。不要使用百分号；比率应为普通小数。",
            "solution": "用户提供了一个在偏微分方程数值解领域中适定且具有科学依据的问题。任务是实现一种特定的数值格式，并用它来研究参数对一组典型测试案例解的质量的影响。该问题是有效的，并且可以构建完整的解决方案。\n\n该问题要求实现一个二阶、总变差递减 (TVD) 的 MUSCL-Hancock 有限体积格式来求解一维标量守恒律：\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0\n$$\n其中 $u(x,t)$ 是守恒量，$f(u)$ 是通量函数。\n\n有限体积法将计算域离散为单元，并对单元平均量 $U_i(t) \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$ 进行演化。守恒律的半离散形式为：\n$$\n\\frac{dU_i}{dt} = -\\frac{1}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\n其中 $F_{i+1/2}$ 是单元 $i$ 和单元 $i+1$ 之间界面上的数值通量。\n\nMUSCL-Hancock 格式通过预测-校正方法在空间和时间上都达到二阶精度。\n\n**1. 空间重构（二阶空间精度）**\n\n在每个单元 $i$ 内部，从时间 $t_n$ 的单元平均值 $U_i^n$ 重构一个分段线性函数：\n$$\nu_i(x, t_n) = U_i^n + \\frac{s_i}{\\Delta x}(x - x_i)\n$$\n其中 $x_i$ 是单元 $i$ 的中心，$s_i$ 是一个受限斜率（或者更准确地说，是一个受限差分）。为了保持 TVD 属性并防止在间断附近产生伪振荡，必须对斜率进行限制。问题指定了一个由 $\\theta \\in [1,2]$ 参数化的广义 minmod 限制器。受限差分 $s_i$ 计算如下：\n$$\ns_i = \\text{minmod}\\left(\\theta \\Delta U_{i-\\frac{1}{2}}, \\frac{1}{2}(\\Delta U_{i-\\frac{1}{2}} + \\Delta U_{i+\\frac{1}{2}}), \\theta \\Delta U_{i+\\frac{1}{2}}\\right)\n$$\n其中 $\\Delta U_{i-\\frac{1}{2}} = U_i^n - U_{i-1}^n$ 和 $\\Delta U_{i+\\frac{1}{2}} = U_{i+1}^n - U_i^n$ 分别是后向和前向差分。$\\text{minmod}$ 函数在所有参数同号时返回其中绝对值最小的参数，否则返回零。$\\theta=1$ 对应最耗散的标准 minmod 限制器，而 $\\theta=2$（对应 SUPERBEE 限制器）则更具压缩性，旨在锐化间断。\n\n**2. 预测步（半时间步演化）**\n\nMUSCL-Hancock 方法使用一个预测步，将单元边界上的重构状态演化到半时间层 $t_{n+1/2} = t_n + \\Delta t/2$。对于每个单元 $i$，我们在时间 $t_n$ 定义其边界上的左右状态：\n$$\nu_{i, L}^n = U_i^n - \\frac{s_i}{2} \\quad \\text{和} \\quad u_{i, R}^n = U_i^n + \\frac{s_i}{2}\n$$\n然后，使用守恒律本身作为预测器，将这些状态在 $\\Delta t/2$ 时间内进行演化：\n$$\nu_{i, L/R}^* = u_{i, L/R}^n - \\frac{\\Delta t}{2\\Delta x} \\left( f(u_{i, R}^n) - f(u_{i, L}^n) \\right)\n$$\n这些预测状态 $u_{i, L}^*$ 和 $u_{i, R}^*$ 是半时间层上单元边界处解的二阶精确近似。\n\n**3. 通量计算与校正步**\n\n现在，每个界面上的数值通量 $F_{i+1/2}$ 是使用一个黎曼求解器计算的，其输入为相邻单元的预测状态。在界面 $x_{i+1/2}$ 处，左状态是 $u_{i, R}^*$（来自单元 $i$），右状态是 $u_{i+1, L}^*$（来自单元 $i+1$）。\n\n问题指定了局部 Lax-Friedrichs（或 Rusanov）通量：\n$$\nF(u_L, u_R) = \\frac{1}{2} \\left[ f(u_L) + f(u_R) \\right] - \\frac{1}{2} \\alpha(u_R - u_L)\n$$\n其中耗散系数 $\\alpha$ 是最大局部特征速度，$\\alpha = \\max(|f'(u_L)|, |f'(u_R)|)$。\n因此，界面 $x_{i+1/2}$ 处的通量为：\n$$\nF_{i+1/2} = F(u_{i, R}^*, u_{i+1, L}^*)\n$$\n最后，校正步将单元平均值更新到新的时间层 $t_{n+1} = t_n + \\Delta t$：\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\n时间步长 $\\Delta t$ 在每一步中动态选择，以满足 Courant-Friedrichs-Lewy (CFL) 条件：\n$$\n\\Delta t = \\text{CFL} \\frac{\\Delta x}{\\max_j |f'(U_j^n)|}\n$$\n按照规定，$\\text{CFL} = 0.45$。\n\n**4. 边界条件**\n\n- **周期性：**对于案例1和2，使用幽灵单元来包裹计算域。对于一个索引为 $0, \\ldots, N-1$ 的 $N$ 单元网格，单元 $0$ 的邻居是单元 $N-1$ 和单元 $1$。单元 $N-1$ 的邻居是单元 $N-2$ 和单元 $0$。\n- **透射（零梯度）：**对于案例3，计算域外的幽灵单元被设置为最近的内部单元的值。在左边界，$U_{-1} = U_0$；在右边界，$U_N = U_{N-1}$。这种选择导致边界单元的斜率为零，从而防止伪波反射回计算域。\n\n**5. 测试案例与度量指标**\n\n该实现将在三个案例上进行测试：光滑剖面的线性平流、间断的线性平流以及无粘性 Burgers 方程中激波的形成。对于每个案例和每个 $\\theta \\in \\{1.0, 1.5, 2.0\\}$ 值，计算四个度量指标：\n1.  **$L^1$ 误差：** $\\sum_i |U_i(T) - u_{\\text{exact}}(x_i, T)| \\Delta x$。\n2.  **$L^\\infty$ 误差：** $\\max_i |U_i(T) - u_{\\text{exact}}(x_i, T)|$。\n3.  **总变差比率：** $\\mathrm{TV}(U(T)) / \\mathrm{TV}(U(0))$，其中 $\\mathrm{TV}(U) = \\sum_i |U_{i+1} - U_i|$（在适用时进行周期性包裹）。\n4.  **过冲：** 超出已知精确解物理边界的总量。\n\n这个全面的评估框架允许对精度（更低的误差）、锐度（TV 比率更接近 1）和鲁棒性（无过冲）之间的权衡进行定量分析，作为限制器参数 $\\theta$ 的函数。",
            "answer": "```python\nimport numpy as np\nimport sys\n\n# Ensure platform-independent floating point representation\nif sys.version_info  (3, 9):\n    # This is a fallback for older Python versions, though problem states 3.12\n    # Standard repr might be sufficient, but this can help with cross-platform consistency\n    pass \nnp.set_printoptions(precision=16)\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation suite and generate the final output.\n    \"\"\"\n\n    test_cases_params = [\n        {\n            \"case_id\": 1,\n            \"N\": 400,\n            \"domain\": (0.0, 1.0),\n            \"T\": 1.0,\n            \"bc\": \"periodic\",\n            \"bounds\": (-1.0, 1.0),\n            \"ic_func\": lambda x: np.sin(2 * np.pi * x),\n            \"exact_sol_func\": lambda x, t: np.sin(2 * np.pi * (x - 1.0 * t)),\n            \"flux_func\": lambda u: 1.0 * u,\n            \"flux_prime_func\": lambda u: np.ones_like(u) if isinstance(u, np.ndarray) else 1.0,\n        },\n        {\n            \"case_id\": 2,\n            \"N\": 400,\n            \"domain\": (0.0, 1.0),\n            \"T\": 0.25,\n            \"bc\": \"periodic\",\n            \"bounds\": (0.0, 1.0),\n            \"ic_func\": lambda x: (x  0.5).astype(float),\n            \"exact_sol_func\": lambda x, t: (((x - 1.0 * t) % 1.0)  0.5).astype(float),\n            \"flux_func\": lambda u: 1.0 * u,\n            \"flux_prime_func\": lambda u: np.ones_like(u) if isinstance(u, np.ndarray) else 1.0,\n        },\n        {\n            \"case_id\": 3,\n            \"N\": 800,\n            \"domain\": (-1.0, 1.0),\n            \"T\": 0.5,\n            \"bc\": \"transmissive\",\n            \"bounds\": (0.0, 1.0),\n            \"ic_func\": lambda x: (x  0.0).astype(float),\n            \"exact_sol_func\": lambda x, t: (x  0.5 * t).astype(float),\n            \"flux_func\": lambda u: 0.5 * u**2,\n            \"flux_prime_func\": lambda u: u,\n        },\n    ]\n\n    thetas = [1.0, 1.5, 2.0]\n    CFL = 0.45\n    all_results = []\n\n    for params in test_cases_params:\n        case_results = []\n        for theta in thetas:\n            metrics = run_simulation(params, theta, CFL)\n            case_results.append(metrics)\n        all_results.append(case_results)\n\n    # Format the output string to match the problem specification\n    output_str = repr(all_results).replace(\" \", \"\")\n    print(output_str)\n\ndef minmod_vec(a, b, c):\n    \"\"\"\n    Vectorized minmod function for three numpy arrays.\n    \"\"\"\n    # Stack arrays for vectorized min/max operations\n    stacked = np.stack([a, b, c], axis=0)\n    min_vals = np.min(stacked, axis=0)\n    max_vals = np.max(stacked, axis=0)\n    \n    # Mask for where all arguments have the same sign (or are zero)\n    same_sign_mask = (min_vals * max_vals) >= 0\n    \n    res = np.zeros_like(a, dtype=float)\n    \n    # All positive or zero case\n    pos_mask = same_sign_mask  (min_vals >= 0)\n    res[pos_mask] = min_vals[pos_mask]\n    \n    # All negative or zero case\n    neg_mask = same_sign_mask  (max_vals = 0)\n    res[neg_mask] = max_vals[neg_mask]\n    \n    return res\n\n\ndef run_simulation(params, theta, CFL):\n    \"\"\"\n    Runs a single simulation for a given case and limiter parameter.\n    \"\"\"\n    N = params[\"N\"]\n    x_min, x_max = params[\"domain\"]\n    dx = (x_max - x_min) / N\n    x = np.linspace(x_min + dx / 2, x_max - dx / 2, N)\n\n    U = params[\"ic_func\"](x)\n    U_initial = U.copy()\n    t = 0.0\n\n    flux_func = params[\"flux_func\"]\n    flux_prime_func = params[\"flux_prime_func\"]\n\n    while t  params[\"T\"]:\n        # Determine max wave speed for CFL condition\n        max_speed = np.max(np.abs(flux_prime_func(U)))\n        if max_speed == 0:\n            max_speed = 1.0 # Avoid division by zero in static cases\n            \n        dt = CFL * dx / max_speed\n        if t + dt > params[\"T\"]:\n            dt = params[\"T\"] - t\n        dtdx = dt/dx\n        \n        # Apply boundary conditions using ghost cells\n        if params[\"bc\"] == \"periodic\":\n            U_ext = np.concatenate(([U[-1]], U, [U[0]]))\n        else: # transmissive\n            U_ext = np.concatenate(([U[0]], U, [U[-1]]))\n\n        # 1. Slope reconstruction\n        delta_m = U_ext[1:-1] - U_ext[:-2]\n        delta_p = U_ext[2:] - U_ext[1:-1]\n        delta_c = 0.5 * (delta_m + delta_p)\n        s = minmod_vec(theta * delta_m, delta_c, theta * delta_p)\n\n        # 2. Predictor Step\n        u_L_in_cell = U - s / 2\n        u_R_in_cell = U + s / 2\n        \n        evol_term = 0.5 * dtdx * (flux_func(u_R_in_cell) - flux_func(u_L_in_cell))\n        \n        u_L_star = u_L_in_cell - evol_term\n        u_R_star = u_R_in_cell - evol_term\n\n        # 3. Flux Calculation at interfaces\n        # Form arrays of left and right states for all N+1 interfaces\n        u_L_at_iface = np.zeros(N + 1)\n        u_R_at_iface = np.zeros(N + 1)\n        \n        # Internal interfaces\n        u_L_at_iface[1:N] = u_R_star[:-1]\n        u_R_at_iface[1:N] = u_L_star[1:]\n\n        # Boundary interfaces\n        if params[\"bc\"] == \"periodic\":\n            u_L_at_iface[0] = u_R_star[-1]\n            u_R_at_iface[0] = u_L_star[0]\n            u_L_at_iface[-1] = u_L_at_iface[0]\n            u_R_at_iface[-1] = u_R_at_iface[0]\n        else: # transmissive BC logic\n            # Left boundary: slope is 0 in ghost cell -> u_star = U[0]\n            u_L_at_iface[0] = U[0]\n            u_R_at_iface[0] = u_L_star[0]\n            # Right boundary: slope is 0 in ghost cell -> u_star = U[-1]\n            u_L_at_iface[-1] = u_R_star[-1]\n            u_R_at_iface[-1] = U[-1]\n\n        # Rusanov flux\n        alpha = np.maximum(np.abs(flux_prime_func(u_L_at_iface)), \n                           np.abs(flux_prime_func(u_R_at_iface)))\n        F_iface = 0.5 * (flux_func(u_L_at_iface) + flux_func(u_R_at_iface)) \\\n                  - 0.5 * alpha * (u_R_at_iface - u_L_at_iface)\n        \n        # 4. Corrector Step (update)\n        U = U - dtdx * (F_iface[1:] - F_iface[:-1])\n        t += dt\n\n    # Calculate metrics\n    U_exact_final = params[\"exact_sol_func\"](x, params[\"T\"])\n    \n    # L1 and L-infinity errors\n    l1_error = np.sum(np.abs(U - U_exact_final)) * dx\n    linf_error = np.max(np.abs(U - U_exact_final))\n\n    # Total variation ratio\n    if params[\"bc\"] == \"periodic\":\n        tv_initial = np.sum(np.abs(np.diff(np.append(U_initial, U_initial[0]))))\n        tv_final = np.sum(np.abs(np.diff(np.append(U, U[0]))))\n    else:\n        tv_initial = np.sum(np.abs(np.diff(U_initial)))\n        tv_final = np.sum(np.abs(np.diff(U)))\n\n    tv_ratio = tv_final / tv_initial if tv_initial > 1e-12 else 1.0\n\n    # Overshoot\n    u_min_bound, u_max_bound = params[\"bounds\"]\n    overshoot = max(0, U.max() - u_max_bound) + max(0, u_min_bound - U.min())\n\n    return [l1_error, linf_error, tv_ratio, overshoot]\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}