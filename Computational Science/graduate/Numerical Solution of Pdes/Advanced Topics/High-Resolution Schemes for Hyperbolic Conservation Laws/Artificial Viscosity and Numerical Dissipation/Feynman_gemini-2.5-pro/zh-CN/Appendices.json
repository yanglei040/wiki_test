{
    "hands_on_practices": [
        {
            "introduction": "本练习提供了一个基础的分析工具，用于揭示数值格式的内在耗散特性。我们将运用修正方程分析，从一个简单的一阶迎风格式中“挖掘”出其等效的粘性项，并用它来预测数值模拟中激波的厚度。这个实践将数值误差这一抽象概念与一个具体、可测量的物理量联系起来，帮助你理解为什么即使是无粘方程的数值解也会表现出类似粘性的行为。",
            "id": "3364595",
            "problem": "考虑实直线上的无量纲无粘性伯格斯方程 $u_{t} + \\left(\\frac{1}{2} u^{2}\\right)_{x} = 0$，其黎曼初值数据为：当 $x<0$ 时，$u(x,0) = u_{L}$；当 $x>0$ 时，$u(x,0)=u_{R}$，其中 $u_{L} > u_{R} > 0$。该解包含一个满足熵条件的激波，其朗金-雨果尼奥速度为 $s$。该方程在一个间距为 $\\Delta x$ 的均匀网格上，使用一阶迎风（施主单元）守恒格式进行离散化，并选择前向欧拉时间步长 $\\Delta t$ 以满足基于最大特征速度的柯朗-弗里德里希斯-列维（CFL）数 $C$，即 $C = \\max_{x} |u(x,t)| \\, \\Delta t / \\Delta x$。\n\n假设数值参数和状态如下：$u_{L} = 2$，$u_{R} = 1$，$\\Delta x = 0.005$，$C = 0.8$。使用主阶修正方程分析，该分析在激波中心处的常数状态附近对格式进行局部线性化，然后匹配到粘性伯格斯方程 $u_{t} + u u_{x} = \\nu u_{xx}$ 的稳态行波约化形式，估计完全由格式的数值耗散引起的内在激波厚度 $\\delta$。将 $\\delta$ 定义为从激波附着坐标系中的行波剖面获得的特征长度尺度，即双曲正切剖面中乘以相似变量的系数的倒数。说明您引入的任何中间符号，在最终数值计算前保持其符号形式，并假设时间步长 $\\Delta t$ 是由 $C$ 使用最大特征速度 $u_{L}$ 设定的。\n\n计算 $\\delta$ 的最终数值，并将您的答案四舍五入到四位有效数字。将最终值表示为一个纯数（无量纲）。",
            "solution": "我们从守恒型无粘性伯格斯方程 $u_{t} + f(u)_{x} = 0$ 开始，其中 $f(u) = \\frac{1}{2} u^{2}$。在一阶迎风（施主单元）格式中，对于间距为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格 $\\{x_{i}\\}$，在特征速度 $f'(u)$ 为正的区域，可以写为\n$$\nu_{i}^{n+1} = u_{i}^{n} - \\lambda \\left(f(u_{i}^{n}) - f(u_{i-1}^{n})\\right), \\quad \\lambda := \\frac{\\Delta t}{\\Delta x}.\n$$\n我们通过在局部常数状态 $u_{0}$ 附近对格式进行泰勒展开，并保留 $\\Delta x$ 的主阶项来分析修正方程。关键的基础步骤是：\n- 在 $u_{0}$ 附近线性化通量：$f(u) \\approx f(u_{0}) + f'(u_{0}) (u - u_{0})$。\n- 在这种局部线性化中，该格式简化为线性平流方程 $v_{t} + a v_{x} = 0$ 的迎风格式，其中 $a = f'(u_{0})$。\n- 应用于 $v_{t} + a v_{x} = 0$ 的一阶迎风格式的经典修正方程是（通过对光滑解在空间和时间上进行泰勒展开得到）\n$$\nv_{t} + a v_{x} = \\frac{a \\, \\Delta x}{2} \\left(1 - a \\lambda \\right) v_{xx} + \\mathcal{O}(\\Delta x^{2}).\n$$\n回到非线性问题，这确定了在局部常数状态 $u_{0}$（其中 $a = f'(u_{0}) = u_{0}$）处求值时的主阶数值粘性系数为\n$$\n\\nu_{\\text{num}}(u_{0}) = \\frac{1}{2} \\, u_{0} \\, \\Delta x \\, \\left(1 - u_{0} \\lambda\\right).\n$$\n\n接下来，为了估计由该数值粘性引起的激波厚度，我们将其与粘性伯格斯方程进行匹配\n$$\nu_{t} + u \\, u_{x} = \\nu \\, u_{xx},\n$$\n其中我们设定 $\\nu = \\nu_{\\text{num}}$ 在激波中心处的值。在以激波速度 $s$ 移动的坐标系中，行波约化使用相似变量 $\\xi = x - s t$，得到满足以下条件的稳态剖面 $u(\\xi)$\n$$\n- s \\, \\frac{d u}{d \\xi} + u \\, \\frac{d u}{d \\xi} = \\nu \\, \\frac{d^{2} u}{d \\xi^{2}} \\quad \\Rightarrow \\quad \\nu \\, \\frac{d^{2} u}{d \\xi^{2}} = \\left(u - s\\right) \\frac{d u}{d \\xi}.\n$$\n假设端点状态 $u_{L}$ 和 $u_{R}$ 之间存在单调连接，使用链式法则 $\\frac{d^{2} u}{d \\xi^{2}} = \\frac{d}{d \\xi}\\left(\\frac{d u}{d \\xi}\\right) = \\frac{d}{d u}\\left(\\frac{d u}{d \\xi}\\right) \\frac{d u}{d \\xi}$ 积分一次得到\n$$\n\\nu \\, \\frac{d}{d u}\\left(\\frac{d u}{d \\xi}\\right) = u - s.\n$$\n对 $u$ 积分，并使用远场条件 $u'(\\xi) \\to 0$（当 $\\xi \\to \\pm \\infty$ 时）确定积分常数，可以得到标准的第一积分\n$$\n\\nu \\, \\frac{d u}{d \\xi} = \\frac{1}{2} \\left(u - u_{L}\\right) \\left(u - u_{R}\\right),\n$$\n其中朗金-雨果尼奥速度为 $s = \\frac{f(u_{L}) - f(u_{R})}{u_{L} - u_{R}} = \\frac{u_{L} + u_{R}}{2}$。变量分离法表明剖面是一个双曲正切函数，\n$$\nu(\\xi) = s - \\frac{\\Delta u}{2} \\, \\tanh\\!\\left( \\frac{\\Delta u}{4 \\nu} \\left(\\xi - \\xi_{0}\\right)\\right), \\quad \\Delta u := u_{L} - u_{R},\n$$\n因此在 $\\tanh$ 的自变量中乘以 $\\xi$ 的系数是 $K = \\frac{\\Delta u}{4 \\nu}$。根据给定的定义，内在激波厚度是该系数的倒数，\n$$\n\\delta := \\frac{1}{K} = \\frac{4 \\nu}{\\Delta u}.\n$$\n\n我们现在将此应用于激波中心的数值粘性。行波的对称性意味着激波中心的状态等于伯格斯方程的朗金-雨果尼奥速度，即，\n$$\nu_{0} = s = \\frac{u_{L} + u_{R}}{2}.\n$$\n时间步长由基于最大特征速度 $u_{L}$ 的柯朗-弗里德里希斯-列维（CFL）条件选择：\n$$\nC = \\max |u| \\, \\frac{\\Delta t}{\\Delta x} = u_{L} \\, \\frac{\\Delta t}{\\Delta x} \\quad \\Rightarrow \\quad \\lambda = \\frac{\\Delta t}{\\Delta x} = \\frac{C}{u_{L}}.\n$$\n因此，\n$$\n\\nu_{\\text{num}}(u_{0}) = \\frac{1}{2} \\, u_{0} \\, \\Delta x \\, \\left(1 - u_{0} \\lambda \\right) \n= \\frac{1}{2} \\, s \\, \\Delta x \\left(1 - s \\, \\frac{C}{u_{L}}\\right).\n$$\n因此，内在厚度的估计值为\n$$\n\\delta = \\frac{4 \\, \\nu_{\\text{num}}(u_{0})}{\\Delta u} \n= \\frac{4}{\\Delta u} \\cdot \\frac{1}{2} \\, s \\, \\Delta x \\left(1 - s \\, \\frac{C}{u_{L}}\\right)\n= \\frac{2 s \\, \\Delta x}{\\Delta u} \\left(1 - \\frac{s C}{u_{L}}\\right).\n$$\n\n代入给定值 $u_{L} = 2$，$u_{R} = 1$，$\\Delta x = 0.005$ 和 $C = 0.8$：\n- $\\Delta u = u_{L} - u_{R} = 2 - 1 = 1$,\n- $s = \\frac{u_{L} + u_{R}}{2} = \\frac{2 + 1}{2} = \\frac{3}{2} = 1.5$,\n- $\\lambda = \\frac{C}{u_{L}} = \\frac{0.8}{2} = 0.4$,\n- $s \\lambda = 1.5 \\times 0.4 = 0.6$,\n- $\\nu_{\\text{num}} = \\frac{1}{2} \\times 1.5 \\times 0.005 \\times (1 - 0.6) = 0.75 \\times 0.005 \\times 0.4 = 0.00375 \\times 0.4 = 0.0015$,\n- $\\delta = \\frac{4 \\times 0.0015}{1} = 0.006$.\n\n四舍五入到四位有效数字，我们得到 $\\delta = 0.006000$，我们用科学记数法表示为 $6.000 \\times 10^{-3}$。",
            "answer": "$$\\boxed{6.000 \\times 10^{-3}}$$"
        },
        {
            "introduction": "超越简单的数值格式，本动手编程练习将探索现代高分辨率方法如何精确控制耗散。你将亲手实现一个MUSCL（Monotonic Upstream-centered Scheme for Conservation Laws）类型的格式，并通过比较不同斜率限制器（如minmod和Superbee）对解的精度的影响，来量化它们的耗散特性。通过测量正弦波振幅的衰减，你将直观地看到理论与实践的结合，理解在保持解的单调性和减少耗散之间的权衡。",
            "id": "3364647",
            "problem": "考虑线性平流方程 $\\partial_t u + a \\,\\partial_x u = 0$，其中速度为常数 $a>0$，定义在长度为 $L$ 的周期性域上，并用 $N$ 个点的均匀网格进行离散。设 $\\Delta x = L/N$，并选择时间步长 $\\Delta t$，使得库朗-弗里德里希斯-列维（CFL）数 $\\nu = a \\Delta t / \\Delta x$ 是固定的。考虑一个基于单元中心的有限体积更新方法，该方法由带斜率限制器的分段线性重构和守恒律的单调上游中心格式（MUSCL）预测步构建。离散更新通过以下基于原理的步骤获得：\n\n1. 积分形式的守恒律和有限体积更新：对于表示在时间 $t^n$ 时第 $i$ 个单元上的平均值的单元平均值 $u_i^n$，使用迎风数值通量来强制守恒。对于 $a>0$，迎风通量在每个界面处使用左侧状态。\n\n2. 斜率限制的分段线性重构：对于每个单元 $i$，定义后向差分 $\\Delta_- u_i = u_i^n - u_{i-1}^n$ 和前向差分 $\\Delta_+ u_i = u_{i+1}^n - u_i^n$，使用周期性索引。斜率 $s_i$ 通过以下斜率限制器之一计算：\n   - Minmod 限制器：$s_i = \\operatorname{minmod}(\\Delta_- u_i, \\Delta_+ u_i)$，其中，如果 $xy \\le 0$，则 $\\operatorname{minmod}(x,y) = 0$，否则 $\\operatorname{minmod}(x,y) = \\operatorname{sign}(x)\\,\\min(|x|,|y|)$。\n   - Superbee 限制器：$s_i = \\operatorname{maxmod}\\!\\left(\\operatorname{minmod}(2\\Delta_- u_i,\\Delta_+ u_i), \\operatorname{minmod}(\\Delta_- u_i,2\\Delta_+ u_i)\\right)$，其中，如果 $xy \\le 0$，则 $\\operatorname{maxmod}(x,y) = 0$，否则 $\\operatorname{maxmod}(x,y)=\\operatorname{sign}(x)\\,\\max(|x|,|y|)$。\n   - Monotonized Central (MC) 限制器：$s_i = \\operatorname{minmod}\\!\\left(\\tfrac{1}{2}(\\Delta_- u_i + \\Delta_+ u_i), 2\\Delta_- u_i, 2\\Delta_+ u_i\\right)$，其中，三参数的 $\\operatorname{minmod}$ 在参数符号不同时返回 $0$，否则对于参数 $x,y,z$ 返回 $\\operatorname{sign}(x)\\,\\min(|x|,|y|,|z|)$。\n\n3. MUSCL 预测到半个时间层和迎风通量：通过将重构数据为线性平流平移半个时间步来定义界面 $x_{i+1/2}$ 处的预测左状态，得到 $u_{i+1/2}^{L,*} = u_i^n + \\left(\\tfrac{1}{2} - \\tfrac{\\nu}{2}\\right) s_i$。对于 $a>0$，在 $x_{i+1/2}$ 处的数值通量为 $F_{i+1/2} = a\\, u_{i+1/2}^{L,*}$。\n\n4. 守恒更新：一个完整时间步长的有限体积更新为\n$$\nu_i^{n+1} = u_i^n - \\nu \\left(u_{i+1/2}^{L,*} - u_{i-1/2}^{L,*}\\right),\n$$\n其中界面使用周期性索引。\n\n设初始数据为单个离散傅里叶模式 $u_j^0 = \\sin(k x_j)$，其中 $x_j = j \\,\\Delta x$，$j=0,1,\\dots,N-1$，波数为 $k = \\tfrac{2\\pi m}{L}$，其中 $m$ 是 $\\{1,2,\\dots,\\tfrac{N}{2}-1\\}$ 中的一个整数。用 $\\widehat{u}^n(m)$ 表示网格函数 $\\{u_j^n\\}_{j=0}^{N-1}$ 在索引 $m$ 处的离散傅里叶变换系数。将模式 $m$ 的每步振幅衰减因子定义为\n$$\n\\alpha = \\frac{\\left|\\widehat{u}^{\\,n+1}(m)\\right|}{\\left|\\widehat{u}^{\\,n}(m)\\right|}.\n$$\n由于精确解保持振幅不变，任何偏离 $\\alpha = 1$ 的情况都反映了由限制器和离散化引入的数值耗散。\n\n任务：编写一个完整的程序，对于所述的离散化方法，在周期性网格上构建初始条件 $u_j^0 = \\sin\\!\\left(\\tfrac{2\\pi m}{N} j\\right)$，使用三种限制器（minmod、Superbee 和 Monotonized Central）中的每一种应用 MUSCL 格式恰好一个时间步，并使用步进前后索引为 $m$ 的离散傅里叶变换系数的模之比来计算模式 $m$ 的单步衰减因子 $\\alpha$。\n\n使用以下固定参数和测试套件：\n- 域长 $L = 2\\pi$。\n- 平流速度 $a = 1$。\n- 网格大小 $N = 256$。\n- 模式索引 $m \\in \\{1, 16, 64, 127\\}$。\n- 库朗数 $\\nu \\in \\{0.2, 0.5, 0.9\\}$。\n- 限制器顺序：minmod、Superbee、Monotonized Central。\n\n对于每对 $(m,\\nu)$ 和给定顺序中的每个限制器，使用周期性边界条件和上述格式计算单个时间步后的衰减因子 $\\alpha$。最终输出必须将所有结果聚合到一行，作为方括号括起来的逗号分隔列表。结果必须按 $m$ 递增、$\\nu$ 递增排序，在每对 $(m,\\nu)$ 内，按限制器顺序 [minmod、Superbee、Monotonized Central] 排序。输出不需要物理单位。根据构造，角度以弧度为单位。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如 $[r_1,r_2,\\dots,r_K]$），其中每个 $r_k$ 是一个浮点衰减因子 $\\alpha$，对应于指定的 $(m,\\nu)$ 和限制器组合之一，并按指定顺序展开。输出必须是十进制形式的数值。",
            "solution": "该问题要求分析应用于线性平流方程的二阶守恒律单调上游中心格式（MUSCL）有限体积法的数值耗散。耗散通过测量单个傅里叶模式在一个时间步后的振幅衰减来量化。该问题是适定的、科学上合理的，并为获得唯一解提供了所有必要信息。\n\n我们首先将数值格式和分析过程形式化。\n\n控制偏微分方程（PDE）是线性平流方程：\n$$\n\\partial_t u + a \\,\\partial_x u = 0\n$$\n其中 $u(x,t)$ 是守恒量，$a > 0$ 是恒定的平流速度。空间域是周期性的，长度为 $L$。域被离散为 $N$ 个均匀单元，单元宽度为 $\\Delta x = L/N$。在时间 $t^n$ 时，单元 $i$ 内的单元平均值表示为 $u_i^n$。时间步长 $\\Delta t$ 通过库朗-弗里德里希斯-列维（CFL）数 $\\nu = a \\Delta t / \\Delta x$ 与空间步长耦合。\n\n有限体积法根据积分形式的守恒律更新单元平均值：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\n其中 $F_{i+1/2}$ 是单元 $i$ 和单元 $i+1$ 之间界面处的数值通量。由于 $a > 0$，我们使用迎风通量，其中通量是界面左侧状态的函数，表示为 $u_{i+1/2}^{L,*}$。对于线性平流，物理通量为 $F(u)=au$，因此数值通量为 $F_{i+1/2} = a u_{i+1/2}^{L,*}$。将此式和 $\\nu$ 的定义代入更新方程，得到：\n$$\nu_i^{n+1} = u_i^n - \\nu \\left( u_{i+1/2}^{L,*} - u_{i-1/2}^{L,*} \\right)\n$$\nMUSCL 格式的核心在于计算随时间演化的界面状态 $u_{i+1/2}^{L,*}$。这是一个两步过程：\n\n1.  **带斜率限制的分段线性重构：**\n    在每个单元 $i$ 内，数据被重构为线性函数 $u_i(x) = u_i^n + \\frac{s_i}{\\Delta x}(x - x_i)$，其中 $x_i$ 是单元 $i$ 的中心。项 $s_i$ 是单元间差分的受限版本，它近似于按 $\\Delta x$ 缩放的斜率。它由后向差分 $\\Delta_- u_i = u_i^n - u_{i-1}^n$ 和前向差分 $\\Delta_+ u_i = u_{i+1}^n - u_i^n$ 使用斜率限制器函数计算得出。问题指定了三个这样的限制器：\n    -   **Minmod：** $s_i = \\operatorname{minmod}(\\Delta_- u_i, \\Delta_+ u_i)$\n    -   **Superbee：** $s_i = \\operatorname{maxmod}\\!\\left(\\operatorname{minmod}(2\\Delta_- u_i,\\Delta_+ u_i), \\operatorname{minmod}(\\Delta_- u_i,2\\Delta_+ u_i)\\right)$\n    -   **Monotonized Central (MC)：** $s_i = \\operatorname{minmod}\\!\\left(\\tfrac{1}{2}(\\Delta_- u_i + \\Delta_+ u_i), 2\\Delta_- u_i, 2\\Delta_+ u_i\\right)$\n    限制器函数 $\\operatorname{minmod}$ 和 $\\operatorname{maxmod}$ 被定义为当其参数符号相反时返回零，从而防止引入新的极值（全变差递减属性）。在计算域边界（即 $i=0$ 和 $i=N-1$）处的差分时，应用周期性边界条件。\n\n2.  **预测步（演化至半个时间步）：**\n    重构的数据演化半个时间步长 $\\Delta t/2$。对于线性平流，这对应于沿特征线回溯时间。在时间 $t^n$ 时，从左侧（单元 $i$）在界面 $x_{i+1/2}$ 处的预测值是在位置 $x_{i+1/2} - a \\Delta t/2$ 处计算的。该位置距离单元中心 $x_i$ 为 $(\\Delta x/2 - a \\Delta t/2)$。将此代入重构公式，得到：\n    $$\n    u_{i+1/2}^{L,*} = u_i^n + \\frac{s_i}{\\Delta x}\\left(\\frac{\\Delta x}{2} - \\frac{a \\Delta t}{2}\\right) = u_i^n + s_i \\left(\\frac{1}{2} - \\frac{a \\Delta t}{2 \\Delta x}\\right) = u_i^n + \\left(\\frac{1 - \\nu}{2}\\right) s_i\n    $$\n    这与问题陈述中给出的公式相符。然后，此值 $u_{i+1/2}^{L,*}$ 用于守恒更新公式以计算 $u_i^{n+1}$。\n\n数值耗散的分析过程如下。对于初始条件 $u(x,0) = \\sin(kx)$，平流方程的精确解为 $u(x,t) = \\sin(k(x-at))$。波的振幅保持不变。因此，任何由数值格式引起的振幅减小都是一种被称为数值耗散的人为现象。\n\n我们用单个傅里叶模式的值初始化网格：\n$$\nu_j^0 = \\sin(k x_j) = \\sin\\left(\\frac{2\\pi m}{L} j \\frac{L}{N}\\right) = \\sin\\left(\\frac{2\\pi m j}{N}\\right)\n$$\n对于 $j=0, 1, \\dots, N-1$。我们执行上述 MUSCL 格式的单个时间步，以获得新状态 $u_j^1$。\n\n为了测量振幅变化，我们使用离散傅里叶变换（DFT）。设 $\\widehat{u}^0(p)$ 和 $\\widehat{u}^1(p)$ 分别为状态 $u^0$ 和 $u^1$ 在模式索引 $p$ 处的 DFT 系数。初始模式 $m$ 的单步振幅衰减因子定义为相应 DFT 系数模的比值：\n$$\n\\alpha = \\frac{\\left|\\widehat{u}^{\\,1}(m)\\right|}{\\left|\\widehat{u}^{\\,0}(m)\\right|}\n$$\n$\\alpha < 1$ 的值表示耗散，而 $\\alpha = 1$ 表示该模式没有耗散。\n\n计算过程通过遍历指定的参数空间来实现。对于模式索引 $m \\in \\{1, 16, 64, 127\\}$ 和 CFL 数 $\\nu \\in \\{0.2, 0.5, 0.9\\}$ 的每种组合，以及三种限制器（minmod、Superbee、MC）中的每一种，我们执行以下步骤：\n1.  在长度为 $L=2\\pi$ 的域上设置 $N=256$ 个点的网格，并为给定的模式 $m$ 生成初始状态 $u^0$。平流速度为 $a=1$。\n2.  计算 $u^0$ 的 DFT，并存储索引 $m$ 处系数的模 $|\\widehat{u}^0(m)|$。\n3.  使用给定的限制器和 CFL 数 $\\nu$ 应用 MUSCL 格式的一个时间步来计算状态 $u^1$。这包括：\n    a. 计算带周期性边界条件的前向和后向差分。\n    b. 应用所选的斜率限制器来找到所有单元的斜率相关项 $s_i$。\n    c. 计算所有界面的预测界面状态 $u_{i+1/2}^{L,*}$。\n    d. 执行最终的守恒更新以获得向量 $u^1$。\n4.  计算 $u^1$ 的 DFT，并找到索引 $m$ 处系数的模 $|\\widehat{u}^1(m)|$。\n5.  计算衰减因子 $\\alpha = |\\widehat{u}^1(m)| / |\\widehat{u}^0(m)|$。\n计算出的 $\\alpha$ 值被收集并按指定顺序呈现。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the single-step amplitude attenuation factor for a MUSCL finite volume scheme\n    applied to the linear advection equation.\n    \"\"\"\n    # Fixed parameters\n    N = 256\n    L = 2.0 * np.pi\n    a = 1.0\n\n    # Test suite parameters\n    m_vals = [1, 16, 64, 127]\n    nu_vals = [0.2, 0.5, 0.9]\n    limiters = [\"minmod\", \"superbee\", \"mc\"]\n\n    results = []\n\n    # Define limiter functions\n    def minmod(x, y):\n        \"\"\"Vectorized minmod function.\"\"\"\n        return 0.5 * (np.sign(x) + np.sign(y)) * np.minimum(np.abs(x), np.abs(y))\n\n    def maxmod(x, y):\n        \"\"\"Vectorized maxmod function.\"\"\"\n        return 0.5 * (np.sign(x) + np.sign(y)) * np.maximum(np.abs(x), np.abs(y))\n\n    def get_slope(u, limiter_name):\n        \"\"\"Computes the limited slope term s_i for all cells.\"\"\"\n        u_minus_1 = np.roll(u, 1)\n        u_plus_1 = np.roll(u, -1)\n        \n        delta_minus = u - u_minus_1\n        delta_plus = u_plus_1 - u\n\n        if limiter_name == \"minmod\":\n            return minmod(delta_minus, delta_plus)\n        elif limiter_name == \"superbee\":\n            s1 = minmod(2 * delta_minus, delta_plus)\n            s2 = minmod(delta_minus, 2 * delta_plus)\n            return maxmod(s1, s2)\n        elif limiter_name == \"mc\":\n            # 3-argument minmod can be implemented by nesting the 2-argument version\n            central_diff = 0.5 * (delta_minus + delta_plus)\n            s1 = minmod(central_diff, 2 * delta_minus)\n            return minmod(s1, 2 * delta_plus)\n        else:\n            raise ValueError(\"Unknown limiter\")\n\n    def take_step(u0, nu, limiter_name):\n        \"\"\"Applies one time step of the MUSCL scheme.\"\"\"\n        # 1. Slope Calculation\n        s = get_slope(u0, limiter_name)\n\n        # 2. Predictor Step\n        # The term u_{i+1/2}^{L,*} is computed for all i.\n        c = 0.5 * (1.0 - nu)\n        u_interface_L_star = u0 + c * s\n\n        # 3. Conservative Update\n        # The update needs the difference u_{i+1/2}^{L,*} - u_{i-1/2}^{L,*}.\n        # u_{i-1/2}^{L,*} for cell i is found by rolling u_interface_L_star.\n        flux_diff = u_interface_L_star - np.roll(u_interface_L_star, 1)\n        u1 = u0 - nu * flux_diff\n        \n        return u1\n\n    # Main loop over test cases\n    for m in m_vals:\n        # Define initial condition for the current mode m\n        x = np.linspace(0, L, N, endpoint=False)\n        k = 2.0 * np.pi * m / L\n        # In this problem setup, L=2pi, so k=m.\n        u0 = np.sin(m * x)\n\n        # Compute DFT of initial condition\n        u0_hat = np.fft.fft(u0)\n        mag_u0_hat_m = np.abs(u0_hat[m])\n\n        for nu in nu_vals:\n            for limiter_name in limiters:\n                # Apply one time step\n                u1 = take_step(u0, nu, limiter_name)\n                \n                # Compute DFT of the new state\n                u1_hat = np.fft.fft(u1)\n                mag_u1_hat_m = np.abs(u1_hat[m])\n                \n                # Calculate attenuation factor\n                if mag_u0_hat_m > 1e-12:\n                    alpha = mag_u1_hat_m / mag_u0_hat_m\n                else:\n                    # Should not happen for the given modes but good practice\n                    alpha = 1.0 \n                \n                results.append(alpha)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "人工粘性的最终目标是仅在需要的地方（即激波处）选择性地施加它。这个高级设计挑战要求你改进一个常见的、但在稀疏波中会失效的压力基激波传感器。通过引入流体压缩（即速度散度为负）这一物理原理，你将开发并测试一个更稳健的传感器，这是开发先进计算流体动力学（CFD）代码的一项关键技能。",
            "id": "3364614",
            "problem": "考虑一维可压缩欧拉方程，该方程组描述了质量、动量和能量的守恒，形式如下\n$$\n\\partial_t \\rho + \\partial_x (\\rho u) = 0,\\quad\n\\partial_t (\\rho u) + \\partial_x (\\rho u^2 + p) = 0,\\quad\n\\partial_t E + \\partial_x \\left( (E + p) u \\right) = 0,\n$$\n其中 $\\rho$ 是密度，$u$ 是速度，$p$ 是压力，$E$ 是单位体积的总能量。在由这些方程控制的无粘流中，激波产生于以负速度散度为特征的压缩运动学，而稀疏波则产生于以正速度散度为特征的膨胀运动学。人工粘性（AV）和激波传感器通常用于稳定偏微分方程（PDEs）的数值解，通过在激波附近选择性地增加耗散，同时避免在光滑区域或稀疏波中产生耗散。\n\n假设我们在一个间距为 $\\Delta x$ 的均匀网格上，使用中心差分和周期性边界条件，定义一个离散的、基于压力梯度的激波传感器。设 $p_i$ 表示单元索引 $i$ 处的离散压力。考虑该传感器\n$$\nS_i = \\frac{\\left| p_{i+1} - 2 p_i + p_{i-1} \\right|}{\\left| p_{i+1} - p_{i-1} \\right| + \\epsilon},\n$$\n其中 $\\epsilon$ 是一个小的正常数，以防止除以零。这个 $S_i$ 是一个基于离散二阶导数与离散一阶导数之比的光滑度指示器。众所周知，它可以检测到陡峭的梯度，但当分母 $\\left| p_{i+1} - p_{i-1} \\right|$ 变得很小，而分子由于光滑的曲率保持有限值时，它可能会在稀疏扇内部被虚假激活。\n\n从激波在压缩（负速度散度）下形成、稀疏波在膨胀（正速度散度）下形成的基本特征出发，设计一个修正的传感器，使其在稀疏波中抑制激活，在压缩中保留激活。具体来说，通过中心差分定义离散速度散度为\n$$\nD^{(u)}_i = \\frac{u_{i+1} - u_{i-1}}{2 \\Delta x},\n$$\n并构建一个在压缩时值较大、在膨胀时值较小的门控因子。您的修正传感器应具有以下乘法形式\n$$\nS^{\\mathrm{corr}}_i = S_i \\cdot G_i,\n$$\n其中 $G_i$ 是一个关于 $D^{(u)}_i$ 和一个小的正常数 $\\eta$ 的无量纲函数，$\\eta$ 用于正则化 $G_i$ 以使其保持有限。您构建 $G_i$ 时必须基于激波与压缩相关、稀疏波与膨胀相关的运动学原理，并且必须在您的解决方案中证明该构建的合理性。\n\n您的程序必须在均匀网格上使用周期性边界条件和中心差分来实现原始传感器 $S_i$ 和您的修正传感器 $S^{\\mathrm{corr}}_i$，然后在几个综合测试场中定量评估其激活和失效模式。当 $S_i > T$ 或 $S^{\\mathrm{corr}}_i > T$ 时，在索引 $i$ 处发生激活，其中 $T$ 是一个预设的阈值。评估必须包括以下指标：\n1. 对于类激波的压缩剖面，计算激活的真阳性率（一个小数），该计算仅限于被识别为激波域索引的索引。将激波域索引定义为那些满足 $\\left| \\partial_x p \\right|$ 超过指定阈值且 $D^{(u)}_i < 0$ 的索引。使用中心差分计算 $\\partial_x p$，并将激波域压力梯度阈值设为最大绝对压力梯度的一半，即\n$$\nG_{\\mathrm{shock}} = \\frac{1}{2} \\max_i \\left| \\frac{p_{i+1} - p_{i-1}}{2 \\Delta x} \\right|.\n$$\n报告 $S_i$ 和 $S^{\\mathrm{corr}}_i$ 的真阳性率。\n2. 对于类稀疏波的膨胀剖面，计算假激活率（一个小数），该计算仅限于满足 $D^{(u)}_i > 0$ 的膨胀域索引。报告 $S_i$ 和 $S^{\\mathrm{corr}}_i$ 的假激活率。\n3. 对于压力恒定且某个非压力变量存在间断的类接触间断剖面，计算 $S_i$ 和 $S^{\\mathrm{corr}}_i$ 在整个域上的总体激活分数（一个小数）。\n4. 对于一个光滑的类声学正弦压力场，计算 $S_i$ 和 $S^{\\mathrm{corr}}_i$ 在整个域上的总体激活分数（一个小数）。\n\n在具有周期性边界条件、 $N$ 个网格点、总域长 $L$ 和间距 $\\Delta x = L / N$ 的均匀网格上，构建以下综合测试场。对于激波和稀疏波情况，使用双曲正切函数进行过渡；对于声学情况，使用正弦波。使用下面列出的参数，所有中心差分通过周期性邻居索引实现：\n- 网格参数：$N = 400$, $L = 1.0$, $\\Delta x = L/N$。\n- 正则化常数：$\\epsilon = 10^{-12}$, $\\eta = 10^{-8}$。\n- 激活阈值：$T = 0.8$。\n- 类激波压缩剖面：中心位于 $x_0 = 0.5$，过渡宽度 $w_{\\mathrm{shock}} = 0.005$，左右压力状态 $p_L = 1.0$, $p_R = 0.1$，左右速度状态 $u_L = 0.5$, $u_R = 0.0$。定义\n$$\np(x) = p_L - (p_L - p_R)\\, \\frac{1 + \\tanh\\left(\\frac{x - x_0}{w_{\\mathrm{shock}}}\\right)}{2},\\quad\nu(x) = u_L - (u_L - u_R)\\, \\frac{1 + \\tanh\\left(\\frac{x - x_0}{w_{\\mathrm{shock}}}\\right)}{2}.\n$$\n- 类稀疏波膨胀剖面：中心位于 $x_0 = 0.5$，宽度 $w_{\\mathrm{raf}} = 0.05$，左右压力状态 $p_L = 1.0$, $p_R = 0.2$，左右速度状态 $u_L = 0.0$, $u_R = 0.6$。定义\n$$\np(x) = p_L - (p_L - p_R)\\, \\frac{1 + \\tanh\\left(\\frac{x - x_0}{w_{\\mathrm{raf}}}\\right)}{2},\\quad\nu(x) = u_L + (u_R - u_L)\\, \\frac{1 + \\tanh\\left(\\frac{x - x_0}{w_{\\mathrm{raf}}}\\right)}{2}.\n$$\n- 类接触间断剖面：恒定压力 $p(x) = p_0$，$p_0 = 1.0$，此评估不需要速度上的间断，但选择一个温和的恒定速度 $u(x) = u_0$，$u_0 = 0.2$，以使 $D^{(u)}_i \\approx 0$。\n- 类声学正弦剖面：$p(x) = p_0 + A_p \\sin(k x)$，$p_0 = 1.0$, $A_p = 0.01$, $k = 2 \\pi \\cdot 10$；以及 $u(x) = u_0 + A_u \\sin(k x)$，$u_0 = 0.2$, $A_u = 0.02$。\n\n您的程序必须：\n- 使用上述离散化方法实现原始传感器 $S_i$ 和您的修正传感器 $S^{\\mathrm{corr}}_i$。\n- 对于每个测试场，计算指定的指标，并生成一行输出，其中包含按以下顺序排列的八个小数：\n1. 激波情况下 $S_i$ 的真阳性率，\n2. 激波情况下 $S^{\\mathrm{corr}}_i$ 的真阳性率，\n3. 稀疏波情况下 $S_i$ 的假激活率，\n4. 稀疏波情况下 $S^{\\mathrm{corr}}_i$ 的假激活率，\n5. 接触间断情况下 $S_i$ 的总体激活分数，\n6. 接触间断情况下 $S^{\\mathrm{corr}}_i$ 的总体激活分数，\n7. 声学情况下 $S_i$ 的总体激活分数，\n8. 声学情况下 $S^{\\mathrm{corr}}_i$ 的总体激活分数。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$\\left[ \\mathrm{result1}, \\mathrm{result2}, \\mathrm{result3}, \\ldots \\right]$）。所有报告的量都必须是小数。",
            "solution": "问题陈述已经过分析，并被确定为有效。它在科学上基于计算流体动力学的原理，问题设定清晰，定义和目标明确，没有矛盾或含糊之处。我们可以继续进行求解。\n\n主要任务是设计一个修正的激波传感器 $S^{\\mathrm{corr}}_i$，以减轻标准压力梯度传感器 $S_i$ 的已知失效模式，即在光滑的稀疏波中可能被错误激活。修正必须采用乘法门控因子的形式，$S^{\\mathrm{corr}}_i = S_i \\cdot G_i$。此门控因子 $G_i$ 的构建必须基于一个基本的运动学原理：激波与流体压缩（负速度散度，$\\partial_x u < 0$）相关，而稀疏波与流体膨胀（正速度散度，$\\partial_x u > 0$）相关。\n\n原始传感器由下式给出\n$$\nS_i = \\frac{\\left| p_{i+1} - 2 p_i + p_{i-1} \\right|}{\\left| p_{i+1} - p_{i-1} \\right| + \\epsilon},\n$$\n其中 $p_i$ 是网格索引 $i$ 处的压力，$\\epsilon$ 是一个小的正则化常数。该传感器通过测量压力场的二阶差分与一阶差分之比来检测压力的急剧变化。\n\n速度散度使用中心差分进行离散化，如下所示\n$$\nD^{(u)}_i = \\frac{u_{i+1} - u_{i-1}}{2 \\Delta x},\n$$\n其中 $u_i$ 是网格索引 $i$ 处的速度，$\\Delta x$ 是网格间距。\n\n为了构建门控因子 $G_i$，我们需要一个函数，它在压缩区域（$D^{(u)}_i < 0$）接近 $1$，在膨胀区域（$D^{(u)}_i > 0$）接近 $0$。这将确保修正后的传感器 $S^{\\mathrm{corr}}_i = S_i \\cdot G_i$ 对激波“开启”，对稀疏波“关闭”。\n\n我们将 $G_i$ 定义为 $D^{(u)}_i$ 和一个小的正常数正则化常数 $\\eta$ 的函数。这样一个门控函数的合适形式是：\n$$\nG_i = \\frac{\\max(0, -D^{(u)}_i)}{|D^{(u)}_i| + \\eta}.\n$$\n让我们分析一下这个提议的函数 $G_i$ 的行为：\n1.  **在压缩区域**，$D^{(u)}_i < 0$。设 $D^{(u)}_i = -c$，其中 $c > 0$ 表示压缩率的大小。门控因子变为\n    $$\n    G_i = \\frac{\\max(0, c)}{|-c| + \\eta} = \\frac{c}{c + \\eta}.\n    $$\n    当压缩变强时（$c \\gg \\eta$），该比值接近 $1$。对于弱压缩（$c \\ll \\eta$），该因子很小。这提供了一个平滑的过渡。\n2.  **在膨胀区域**，$D^{(u)}_i > 0$。分子变为 $\\max(0, -D^{(u)}_i) = 0$。因此，对于任何正的速度散度，\n    $$\n    G_i = 0.\n    $$\n    这完全抑制了传感器在膨胀流中的激活，符合要求。\n3.  **在零散度区域**，$D^{(u)}_i = 0$。门控因子也是 $G_i = 0$。\n4.  **性质**：该函数是无量纲的，因为它是具有相同时间倒数单位的量之比（假设 $\\eta$ 的单位与 $D^{(u)}_i$ 一致）。对于 $\\eta > 0$，分母 $|D^{(u)}_i| + \\eta$ 始终为正，确保表达式定义良好且有限。\n\n$G_i$ 的这种构造直接实现了问题中指定的运动学原理。因此，最终的修正传感器定义为\n$$\nS^{\\mathrm{corr}}_i = S_i \\cdot G_i = \\frac{\\left| p_{i+1} - 2 p_i + p_{i-1} \\right|}{\\left| p_{i+1} - p_{i-1} \\right| + \\epsilon} \\cdot \\frac{\\max(0, -D^{(u)}_i)}{|D^{(u)}_i| + \\eta}.\n$$\n\n问题的后续部分要求进行数值实现，以评估 $S_i$ 和 $S^{\\mathrm{corr}}_i$ 在四个综合测试场中的性能：类激波剖面、类稀疏波剖面、类接触间断剖面和类声学剖面。评估使用特定的指标：激波情况下的真阳性率，稀疏波情况下的假激活率，以及接触间断和声学情况下的总体激活分数。实现将在一个具有 $N=400$ 个点的均匀周期性网格上进行，域长为 $L=1.0$，使用提供的参数 $\\epsilon = 10^{-12}$，$\\eta = 10^{-8}$ 和激活阈值 $T = 0.8$。所有空间差分将使用中心差分格式和周期性边界条件计算。最终程序将计算并输出指定的八个指标。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and evaluates an original and a corrected shock sensor\n    on four synthetic test fields, reporting eight performance metrics.\n    \"\"\"\n    # Global parameters\n    N = 400\n    L = 1.0\n    dx = L / N\n    epsilon = 1e-12\n    eta = 1e-8\n    T = 0.8\n    x = np.linspace(0, L, N, endpoint=False)\n\n    def compute_sensors(p, u):\n        \"\"\"\n        Computes the original sensor S, the corrected sensor Scorr,\n        and the discrete velocity divergence Du.\n        \"\"\"\n        # Periodic boundary conditions are handled by np.roll\n        p_plus_1 = np.roll(p, -1)\n        p_minus_1 = np.roll(p, 1)\n        u_plus_1 = np.roll(u, -1)\n        u_minus_1 = np.roll(u, 1)\n\n        # Original sensor S_i\n        num_S = np.abs(p_plus_1 - 2 * p + p_minus_1)\n        den_S = np.abs(p_plus_1 - p_minus_1) + epsilon\n        S = num_S / den_S\n\n        # Discrete velocity divergence D^(u)_i\n        Du = (u_plus_1 - u_minus_1) / (2 * dx)\n        \n        # Gating factor G_i\n        G = np.maximum(0, -Du) / (np.abs(Du) + eta)\n        \n        # Corrected sensor S^corr_i\n        Scorr = S * G\n        \n        return S, Scorr, Du\n\n    results = []\n\n    # Case 1: Shock-like compressive profile\n    x0_s, w_shock, pL_s, pR_s, uL_s, uR_s = 0.5, 0.005, 1.0, 0.1, 0.5, 0.0\n    trans_s = (1 + np.tanh((x - x0_s) / w_shock)) / 2\n    p_shock = pL_s - (pL_s - pR_s) * trans_s\n    u_shock = uL_s - (uL_s - uR_s) * trans_s\n    S_s, Scorr_s, Du_s = compute_sensors(p_shock, u_shock)\n    \n    activations_S = S_s > T\n    activations_Scorr = Scorr_s > T\n    \n    dp_dx = (np.roll(p_shock, -1) - np.roll(p_shock, 1)) / (2 * dx)\n    G_shock = 0.5 * np.max(np.abs(dp_dx))\n    shock_domain_mask = (np.abs(dp_dx) > G_shock) & (Du_s < 0)\n    num_shock_domain = np.sum(shock_domain_mask)\n    \n    tpr_S = np.sum(activations_S[shock_domain_mask]) / num_shock_domain if num_shock_domain > 0 else 0.0\n    tpr_Scorr = np.sum(activations_Scorr[shock_domain_mask]) / num_shock_domain if num_shock_domain > 0 else 0.0\n    results.extend([tpr_S, tpr_Scorr])\n\n    # Case 2: Rarefaction-like expansive profile\n    x0_r, w_raf, pL_r, pR_r, uL_r, uR_r = 0.5, 0.05, 1.0, 0.2, 0.0, 0.6\n    trans_r = (1 + np.tanh((x - x0_r) / w_raf)) / 2\n    p_raf = pL_r - (pL_r - pR_r) * trans_r\n    u_raf = uL_r + (uR_r - uL_r) * trans_r\n    S_r, Scorr_r, Du_r = compute_sensors(p_raf, u_raf)\n\n    activations_S = S_r > T\n    activations_Scorr = Scorr_r > T\n\n    expansion_domain_mask = Du_r > 0\n    num_expansion_domain = np.sum(expansion_domain_mask)\n    \n    far_S = np.sum(activations_S[expansion_domain_mask]) / num_expansion_domain if num_expansion_domain > 0 else 0.0\n    far_Scorr = np.sum(activations_Scorr[expansion_domain_mask]) / num_expansion_domain if num_expansion_domain > 0 else 0.0\n    results.extend([far_S, far_Scorr])\n\n    # Case 3: Contact-like profile\n    p_contact = np.full(N, 1.0)\n    u_contact = np.full(N, 0.2)\n    S_c, Scorr_c, _ = compute_sensors(p_contact, u_contact)\n    \n    activations_S = S_c > T\n    activations_Scorr = Scorr_c > T\n    \n    af_S = np.sum(activations_S) / N\n    af_Scorr = np.sum(activations_Scorr) / N\n    results.extend([af_S, af_Scorr])\n\n    # Case 4: Acoustic-like sinusoidal profile\n    p0_a, Ap, k = 1.0, 0.01, 2 * np.pi * 10\n    u0_a, Au = 0.2, 0.02\n    p_acoustic = p0_a + Ap * np.sin(k * x)\n    u_acoustic = u0_a + Au * np.sin(k * x)\n    S_a, Scorr_a, _ = compute_sensors(p_acoustic, u_acoustic)\n\n    activations_S = S_a > T\n    activations_Scorr = Scorr_a > T\n\n    af_S = np.sum(activations_S) / N\n    af_Scorr = np.sum(activations_Scorr) / N\n    results.extend([af_S, af_Scorr])\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}