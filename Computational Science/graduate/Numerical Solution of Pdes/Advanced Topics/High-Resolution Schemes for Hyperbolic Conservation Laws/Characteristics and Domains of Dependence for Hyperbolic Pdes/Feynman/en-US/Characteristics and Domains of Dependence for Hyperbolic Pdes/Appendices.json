{
    "hands_on_practices": [
        {
            "introduction": "The method of characteristics provides the fundamental framework for analyzing hyperbolic PDEs. This first practice applies this method to the inviscid Burgers' equation, a prototypical nonlinear conservation law, to predict the exact moment a smooth solution breaks down to form a shock wave. By tracking how characteristics evolve and intersect, you will gain a concrete understanding of how nonlinearity leads to the formation of discontinuities from perfectly smooth initial conditions .",
            "id": "3369909",
            "problem": "Consider the scalar conservation law known as the inviscid Burgers' Partial Differential Equation (PDE),\n$$u_{t} + \\left(\\frac{u^{2}}{2}\\right)_{x} = 0 \\quad \\text{for} \\quad x \\in \\mathbb{R}, \\ t \\ge 0,$$\nwith smooth initial data\n$$u(x,0) = u_{0}(x) = -A \\tanh(K x),$$\nwhere $A0$ and $K0$ are constants. Using the method of characteristics as the context-appropriate fundamental base, justify the relationship between the domain of dependence of a point $(x,t)$ and the characteristic flow, and then determine the earliest time $t_{s}0$ at which the classical solution loses regularity due to characteristic intersection (shock formation). Provide $t_{s}$ in closed form in terms of $A$ and $K$. The final answer must be a single analytic expression. No rounding is required.",
            "solution": "The problem is to analyze the solution to the inviscid Burgers' equation, a scalar conservation law, and determine the time of shock formation for a specific initial condition.\n\nThe governing Partial Differential Equation (PDE) is:\n$$u_{t} + \\left(\\frac{u^{2}}{2}\\right)_{x} = 0 \\quad \\text{for} \\quad x \\in \\mathbb{R}, \\ t \\ge 0$$\nUsing the chain rule, we can write the flux term as $(\\frac{u^2}{2})_x = \\frac{d}{du}(\\frac{u^2}{2}) \\frac{\\partial u}{\\partial x} = u u_x$. This transforms the PDE into its quasilinear form:\n$$u_{t} + u u_{x} = 0$$\nThe initial condition is given as a smooth function:\n$$u(x,0) = u_{0}(x) = -A \\tanh(K x)$$\nwhere $A$ and $K$ are positive constants, $A0$ and $K0$.\n\nThe method of characteristics is the fundamental tool for solving such first-order hyperbolic PDEs. The quasilinear form $u_t + c(u) u_x = 0$, where here the wave speed is $c(u) = u$, states that the total derivative of $u$ with respect to time along curves defined by $\\frac{dx}{dt} = c(u)$ is zero. That is,\n$$\\frac{d}{dt} u(x(t), t) = u_{t} + u_{x} \\frac{dx}{dt} = u_{t} + u u_{x} = 0$$\nThis implies that the solution $u$ is constant along the characteristic curves, which are defined by the ordinary differential equation $\\frac{dx}{dt} = u$.\nSince $u$ is constant along each characteristic, the speed of propagation for each characteristic is constant. Therefore, the characteristic curves are straight lines in the $(x,t)$-plane.\n\nLet a characteristic curve originate from a point $(x_0, 0)$ on the initial line. The value of the solution along this entire curve is fixed by the initial data at $x_0$, i.e., $u(x(t), t) = u(x_0, 0) = u_0(x_0)$. The equation for the characteristic line is then:\n$$\\frac{dx}{dt} = u_{0}(x_0)$$\nIntegrating this with respect to time from $0$ to $t$ yields the explicit equation for the characteristic line:\n$$x(t) = x_{0} + u_{0}(x_0) t$$\nThis equation implicitly defines the solution $u(x,t)$. To find the value of $u$ at a point $(x,t)$, one must solve the equation $x = x_0 + u_0(x_0) t$ for the starting point $x_0$. The solution is then $u(x,t) = u_0(x_0)$.\n\nThe domain of dependence of a point $(x,t)$ is the set of points on the initial data surface (at $t=0$) that influence the solution at $(x,t)$. From the characteristic equation, it is evident that the solution $u(x,t)$ is determined exclusively by the value of the initial data at the single point $x_0$ which is the foot of the characteristic passing through $(x,t)$. Therefore, for this first-order hyperbolic problem, the domain of dependence of $(x,t)$ is the single point set $\\{x_0\\}$ on the initial line $t=0$.\n\nA classical solution exists as long as the mapping from $x_0$ to $x$ at a given time $t$ is one-to-one. This fails when characteristics intersect, leading to a multi-valued solution, which is physically impossible. This breakdown of the classical solution is known as shock formation.\nAn intersection occurs when two distinct characteristics, starting from $x_{0,1}$ and $x_{0,2}$, meet at the same point $(x,t)$. For infinitesimally close characteristics starting at $x_0$ and $x_0 + dx_0$, their intersection time $t$ can be found by setting their positions equal:\n$$x_0 + u_0(x_0)t = (x_0 + dx_0) + u_0(x_0 + dx_0)t$$\nRearranging gives:\n$$[u_0(x_0) - u_0(x_0 + dx_0)]t = dx_0$$\n$$t = \\frac{dx_0}{u_0(x_0) - u_0(x_0 + dx_0)} = -\\frac{1}{\\frac{u_0(x_0 + dx_0) - u_0(x_0)}{dx_0}}$$\nTaking the limit as $dx_0 \\to 0$, the time to intersection for characteristics originating from the neighborhood of $x_0$ is:\n$$t(x_0) = -\\frac{1}{u_0'(x_0)}$$\nA shock can only form for $t0$, which requires that $u_0'(x_0)  0$. This condition signifies that characteristics are converging: a characteristic starting at a slightly larger initial position $x_0+dx_0$ has a smaller (or more negative) velocity $u_0(x_0+dx_0)$ than the characteristic starting at $x_0$, causing them to approach each other.\n\nThe first time a shock appears, denoted by $t_s$, is the minimum of these intersection times over all possible starting points $x_0$ where the derivative is negative:\n$$t_{s} = \\min_{x_0 : u_{0}'(x_0)0} \\left( -\\frac{1}{u_{0}'(x_0)} \\right)$$\nThis is equivalent to finding the overall minimum of $u_0'(x_0)$, as minimizing the positive quantity $-\\frac{1}{u_0'(x_0)}$ is the same as maximizing the denominator $u_0'(x_0)$ (i.e., making it as \"least negative\" as possible) or minimizing the positive quantity $|u_0'(x_0)|$. Let's recheck this. We want to find the smallest positive $t$. This means we want the largest negative value for $u_0'(x_0)$. So we need to find the minimum of $u_0'(x_0)$.\n$$t_s = \\frac{-1}{\\min_{x_0 \\in \\mathbb{R}} u_{0}'(x_0)}$$\nWe are given the initial condition $u_{0}(x) = -A \\tanh(K x)$. We must compute its derivative, $u_0'(x)$.\n$$u_{0}'(x) = \\frac{d}{dx} \\left( -A \\tanh(K x) \\right)$$\nUsing the chain rule and the fact that $\\frac{d}{dz}\\tanh(z) = \\operatorname{sech}^2(z)$, we get:\n$$u_{0}'(x) = -A \\cdot (\\operatorname{sech}^2(K x)) \\cdot K = -AK \\operatorname{sech}^2(K x)$$\nSince $A0$ and $K0$, the product $-AK$ is negative. The function $\\operatorname{sech}^2(y)$ is always non-negative. Therefore, $u_0'(x) \\le 0$ for all $x \\in \\mathbb{R}$, which confirms that characteristics are always converging or are parallel (at infinity).\nTo find the shock time $t_s$, we must find the minimum value of $u_0'(x)$. The minimum of $u_0'(x)$ will occur when the positive term $\\operatorname{sech}^2(Kx)$ is at its maximum.\nThe hyperbolic secant function, $\\operatorname{sech}(z) = \\frac{1}{\\cosh(z)}$, has its maximum value when $\\cosh(z)$ is at its minimum. The minimum value of $\\cosh(z)$ is $1$, which occurs at $z=0$.\nThus, the maximum value of $\\operatorname{sech}(Kx)$ is $1$, occurring at $Kx=0$, or $x=0$. The maximum value of $\\operatorname{sech}^2(Kx)$ is also $1$, occurring at $x=0$.\nThe minimum value of the derivative is therefore:\n$$\\min_{x \\in \\mathbb{R}} u_{0}'(x) = -AK \\cdot \\max_{x \\in \\mathbb{R}}(\\operatorname{sech}^2(K x)) = -AK \\cdot 1 = -AK$$\nThis minimum occurs at $x_0=0$. This is the point of steepest negative slope in the initial profile, where the rate of convergence of characteristics is highest.\n\nSubstituting this minimum value into the formula for the shock formation time:\n$$t_{s} = \\frac{-1}{\\min_{x_0 \\in \\mathbb{R}} u_{0}'(x_0)} = \\frac{-1}{-AK} = \\frac{1}{AK}$$\nSince $A0$ and $K0$, the shock time $t_s$ is positive, as expected.",
            "answer": "$$\\boxed{\\frac{1}{AK}}$$"
        },
        {
            "introduction": "Bridging the gap between continuous theory and discrete computation is a critical skill in the numerical analysis of PDEs. This exercise demonstrates how the concept of the domain of dependence directly gives rise to the celebrated Courant-Friedrichs-Lewy (CFL) condition, which is the cornerstone of stability for explicit numerical schemes. You will derive this condition from first principles and compare how different numerical stencils affect the numerical domain of dependence, providing insight into the design and limitations of finite difference methods .",
            "id": "3369972",
            "problem": "Consider the scalar linear hyperbolic partial differential equation $u_t + a\\,u_x = 0$ with constant characteristic speed $a \\in \\mathbb{R}$ on a uniform grid with spacing $\\Delta x  0$ and explicit time stepping with step size $\\Delta t  0$. The continuum domain of dependence of a point $(x_i, t_N)$ with $t_N = N\\,\\Delta t$ is the single point $(x_i - a\\,t_N, 0)$, determined by the characteristic curve $x(t) = x_i - a\\,t$. In a linear explicit finite-difference method, the numerical update can be written as\n$$\nu_i^{n+1} = \\sum_{s \\in \\mathcal{S}} \\alpha_s\\,u_{i+s}^n,\n$$\nwhere $\\mathcal{S}$ is the set of integer offsets defining the stencil and $\\alpha_s$ are method-dependent coefficients that satisfy consistency constraints. The numerical domain of dependence of $u_0^N$ is the set of all grid indices at time level $n=0$ whose values can influence $u_0^N$ by repeated application of the update relation for $N$ steps. This set is generated by all $N$-fold sums of elements of $\\mathcal{S}$, and its extremal indices after $N$ steps are\n$$\ni_{\\min}(N) = N\\,\\min(\\mathcal{S}),\\qquad i_{\\max}(N) = N\\,\\max(\\mathcal{S}).\n$$\nThe numerical influence envelope after $N$ steps is the spatial span from $i_{\\min}(N)$ to $i_{\\max}(N)$, whose physical width is\n$$\nW_{\\text{num}}(N) = \\left(i_{\\max}(N) - i_{\\min}(N)\\right)\\,\\Delta x.\n$$\nThe Courant–Friedrichs–Lewy (CFL) condition is the requirement that $\\Delta t \\le C\\,\\Delta x/\\max|\\lambda|$, where $\\lambda$ denotes the characteristic speeds of the hyperbolic system and $C$ is a method-dependent constant. For the scalar equation above, $\\max|\\lambda| = |a|$. Your task is to:\n- Derive from first principles how the CFL condition bounds the numerical domain of dependence, in the sense that the continuum domain-of-dependence point $(x_0 - a\\,t_N, 0)$ lies inside the numerical influence envelope whenever a scheme-dependent bound on $C$ is respected.\n- Construct and compare two explicit schemes with equal CFL parameter $C$ but different stencils:\n  1. A compact upwind stencil $\\mathcal{S}_{\\mathrm{c}} = \\{0,-1\\}$.\n  2. A wide upwind stencil $\\mathcal{S}_{\\mathrm{w}} = \\{0,-1,-2,-3\\}$.\n- For each scheme, quantify its effective numerical domain width $W_{\\text{num}}(N)$ after $N$ steps, and compare it to the continuum domain-of-dependence travel distance $D_{\\text{cont}}(N) = |a|\\,N\\,\\Delta t$.\n\nWork in non-dimensional units so that all quantities are pure numbers. Use the following test suite of parameter values, which explores a typical case, boundary conditions, and an edge case:\n1. $(a,\\Delta x,C,N) = (1.0,\\,1.0,\\,0.8,\\,10)$.\n2. $(a,\\Delta x,C,N) = (0.5,\\,0.5,\\,1.0,\\,1)$.\n3. $(a,\\Delta x,C,N) = (1.0,\\,1.0,\\,1.0,\\,5)$.\n4. $(a,\\Delta x,C,N) = (1.0,\\,1.0,\\,1.2,\\,5)$.\n5. $(a,\\Delta x,C,N) = (1.0,\\,1.0,\\,0.7,\\,0)$.\n\nFor each test case, compute:\n- The compact scheme width $W_{\\text{num,c}}(N)$.\n- The wide scheme width $W_{\\text{num,w}}(N)$.\n- The continuum travel distance $D_{\\text{cont}}(N)$.\n- A boolean flag for each scheme indicating whether the continuum domain-of-dependence location lies within that scheme’s numerical influence envelope (for $a0$, this reduces to checking if the left reach $R_{\\text{left}}(N) = -i_{\\min}(N)\\,\\Delta x$ satisfies $R_{\\text{left}}(N) \\ge D_{\\text{cont}}(N)$).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes an inner list in the form\n$$\n[W_{\\text{num,c}},W_{\\text{num,w}},D_{\\text{cont}},\\text{inside\\_compact},\\text{inside\\_wide}],\n$$\nand the final aggregated output must be a single list of these inner lists, with no spaces inside lists. For example, an output with two test cases would look like\n$$\n[[w_c^{(1)},w_w^{(1)},d^{(1)},b_c^{(1)},b_w^{(1)}],[w_c^{(2)},w_w^{(2)},d^{(2)},b_c^{(2)},b_w^{(2)}]].\n$$",
            "solution": "The problem requires a derivation of the relationship between the Courant-Friedrichs-Lewy (CFL) condition and the domain of dependence for a linear hyperbolic PDE, followed by a quantitative analysis of two specific finite-difference schemes.\n\n**1. Derivation of the Geometric CFL Condition**\n\nThe given partial differential equation (PDE) is the scalar linear advection equation:\n$$\nu_t + a\\,u_x = 0\n$$\nwhere $a \\in \\mathbb{R}$ is the constant characteristic speed. The characteristics are lines in the $(x,t)$ plane along which the solution $u$ is constant. They are defined by the ordinary differential equation $\\frac{dx}{dt} = a$. The solution is $x(t) = x(0) + a\\,t$. This means a signal at position $x(0)$ at time $t=0$ propagates to position $x(t)$ at time $t$.\n\nThe **continuum domain of dependence** of a point $(x_i, t_N)$ is the set of points at time $t=0$ that influence the solution at $(x_i, t_N)$. Following the characteristic backward in time from $(x_i, t_N)$, we find the influencing point at $t=0$ to be at position $x_0 = x_i - a\\,t_N$. The travel distance of the characteristic information over a time interval $t_N$ is $D_{\\text{cont}} = |a\\,t_N|$.\n\nA linear explicit finite-difference scheme approximates the solution on a grid with spacing $\\Delta x$ and time step $\\Delta t$. The update rule is given as:\n$$\nu_i^{n+1} = \\sum_{s \\in \\mathcal{S}} \\alpha_s\\,u_{i+s}^n\n$$\nwhere $\\mathcal{S}$ is the stencil. After one time step, the value at grid point $i$ depends on points in the set $\\{i+s \\mid s \\in \\mathcal{S}\\}$ at the previous time level. After $N$ steps, the value $u_i^N$ depends on the initial values $u_j^0$ where the index $j$ is in the range $[i + N\\min(\\mathcal{S}), i + N\\max(\\mathcal{S})]$.\n\nThe **numerical domain of dependence** of the point $(x_i, t_N)$ is the spatial interval at $t=0$ that contains all grid points influencing $u_i^N$. Relative to $x_i$, this interval is $[i_{\\min}(N)\\Delta x, i_{\\max}(N)\\Delta x]$, where $i_{\\min}(N) = N\\min(\\mathcal{S})$ and $i_{\\max}(N) = N\\max(\\mathcal{S})$. The width of this numerical influence envelope is $W_{\\text{num}}(N) = (i_{\\max}(N) - i_{\\min}(N))\\Delta x$.\n\nThe fundamental Courant-Friedrichs-Lewy (CFL) condition stipulates that for a convergent numerical scheme, the continuum domain of dependence must be contained within the numerical domain of dependence. For the point $(x_i, t_N)$, this means the physical point $x_i - a\\,t_N$ must lie within the physical interval $[x_i + i_{\\min}(N)\\Delta x, x_i + i_{\\max}(N)\\Delta x]$.\n$$\nx_i + N\\min(\\mathcal{S})\\Delta x \\le x_i - a\\,t_N \\le x_i + N\\max(\\mathcal{S})\\Delta x\n$$\nSubtracting $x_i$ and substituting $t_N = N\\Delta t$:\n$$\nN\\min(\\mathcal{S})\\Delta x \\le -a\\,N\\Delta t \\le N\\max(\\mathcal{S})\\Delta x\n$$\nFor $N0$, we can divide by $N\\Delta x$:\n$$\n\\min(\\mathcal{S}) \\le -a\\,\\frac{\\Delta t}{\\Delta x} \\le \\max(\\mathcal{S})\n$$\nLet the Courant number be $\\nu = a\\frac{\\Delta t}{\\Delta x}$. The condition becomes $\\min(\\mathcal{S}) \\le -\\nu \\le \\max(\\mathcal{S})$, or equivalently, $-\\max(\\mathcal{S}) \\le \\nu \\le -\\min(\\mathcal{S})$.\n\nAll test cases have $a0$, and the problem specifies \"upwind\" stencils which are biased towards negative indices. This implies $\\max(\\mathcal{S})=0$. The CFL condition thus simplifies to:\n$$\n0 \\le \\nu \\le -\\min(\\mathcal{S})\n$$\nThe first inequality, $0 \\le \\nu$, is always satisfied for $a0$, $\\Delta t0$, and $\\Delta x0$. The crucial part is the second inequality, $\\nu \\le -\\min(\\mathcal{S})$. The problem defines the CFL condition using a parameter $C$ as $\\Delta t \\le C\\,\\Delta x/|a|$, which is equivalent to $\\nu \\le C$ for $a0$. Therefore, the geometric inclusion condition is met if and only if the chosen parameter $C$ satisfies $C \\le -\\min(\\mathcal{S})$.\n\n**2. Analysis of the Specified Schemes**\n\nFor both schemes, we use the maximal time step allowed by the given parameter $C$, so $\\Delta t = C\\,\\Delta x/|a|$. For $a0$, this is $\\Delta t = C\\,\\Delta x/a$. The continuum travel distance is $D_{\\text{cont}}(N) = |a|\\,N\\,\\Delta t = a\\,N(C\\,\\Delta x/a) = NC\\Delta x$.\n\n**Scheme 1: Compact Upwind Stencil**\n- Stencil: $\\mathcal{S}_{\\mathrm{c}} = \\{0, -1\\}$.\n- Stencil bounds: $\\min(\\mathcal{S}_{\\mathrm{c}}) = -1$, $\\max(\\mathcal{S}_{\\mathrm{c}}) = 0$.\n- Extremal indices after $N$ steps: $i_{\\min,c}(N) = -N$, $i_{\\max,c}(N) = 0$.\n- Numerical width: $W_{\\text{num,c}}(N) = (i_{\\max,c}(N) - i_{\\min,c}(N))\\Delta x = (0 - (-N))\\Delta x = N\\Delta x$.\n- Inclusion condition: The continuum point $x_i - a\\,t_N$ must be in the numerical envelope. For $a0$, we check if the leftward reach of the numerical scheme is sufficient. The left reach is $R_{\\text{left,c}}(N) = -i_{\\min,c}(N)\\Delta x = N\\Delta x$. The condition is $R_{\\text{left,c}}(N) \\ge D_{\\text{cont}}(N)$, which becomes $N\\Delta x \\ge NC\\Delta x$, or $1 \\ge C$.\n\n**Scheme 2: Wide Upwind Stencil**\n- Stencil: $\\mathcal{S}_{\\mathrm{w}} = \\{0, -1, -2, -3\\}$.\n- Stencil bounds: $\\min(\\mathcal{S}_{\\mathrm{w}}) = -3$, $\\max(\\mathcal{S}_{\\mathrm{w}}) = 0$.\n- Extremal indices after $N$ steps: $i_{\\min,w}(N) = -3N$, $i_{\\max,w}(N) = 0$.\n- Numerical width: $W_{\\text{num,w}}(N) = (i_{\\max,w}(N) - i_{\\min,w}(N))\\Delta x = (0 - (-3N))\\Delta x = 3N\\Delta x$.\n- Inclusion condition: The left reach is $R_{\\text{left,w}}(N) = -i_{\\min,w}(N)\\Delta x = 3N\\Delta x$. The condition $R_{\\text{left,w}}(N) \\ge D_{\\text{cont}}(N)$ becomes $3N\\Delta x \\ge NC\\Delta x$, or $3 \\ge C$.\n\n**3. Computation for Test Cases**\n\nFor each test case $(a, \\Delta x, C, N)$, we calculate the following quantities:\n1.  $W_{\\text{num,c}}(N) = N\\Delta x$\n2.  $W_{\\text{num,w}}(N) = 3N\\Delta x$\n3.  $D_{\\text{cont}}(N) = NC\\Delta x$\n4.  `inside_compact`: A boolean flag, `True` if $C \\le 1$, `False` otherwise.\n5.  `inside_wide`: A boolean flag, `True` if $C \\le 3$, `False` otherwise.\n\nThese formulae are implemented in the provided Python script to generate the final results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating numerical domain widths and\n    checking CFL inclusion for two finite difference schemes.\n    \"\"\"\n    # Define the test cases from the problem statement:\n    # Each case is a tuple (a, delta_x, C, N).\n    test_cases = [\n        (1.0, 1.0, 0.8, 10),\n        (0.5, 0.5, 1.0, 1),\n        (1.0, 1.0, 1.0, 5),\n        (1.0, 1.0, 1.2, 5),\n        (1.0, 1.0, 0.7, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, delta_x, C, N = case\n\n        # For the compact upwind scheme, S_c = {0, -1}\n        # min(S_c) = -1, max(S_c) = 0\n        # The numerical domain width is (max - min) * N * delta_x\n        # W_num_c = (0 - (-1)) * N * delta_x = N * delta_x\n        w_num_c = float(N * delta_x)\n\n        # For the wide upwind scheme, S_w = {0, -1, -2, -3}\n        # min(S_w) = -3, max(S_w) = 0\n        # The numerical domain width is (max - min) * N * delta_x\n        # W_num_w = (0 - (-3)) * N * delta_x = 3 * N * delta_x\n        w_num_w = float(3 * N * delta_x)\n\n        # The continuum travel distance is D_cont = |a| * N * delta_t.\n        # We use delta_t = C * delta_x / |a|.\n        # So, D_cont = |a| * N * (C * delta_x / |a|) = N * C * delta_x\n        d_cont = float(N * C * delta_x)\n\n        # The CFL inclusion condition is that the continuum domain of dependence\n        # must lie within the numerical domain of dependence.\n        # As derived, this is equivalent to C = -min(S).\n\n        # For the compact scheme, -min(S_c) = 1. Condition: C = 1.\n        inside_compact = (C = 1.0)\n\n        # For the wide scheme, -min(S_w) = 3. Condition: C = 3.\n        inside_wide = (C = 3.0)\n\n        # Assemble the results for the current test case.\n        case_result = [w_num_c, w_num_w, d_cont, inside_compact, inside_wide]\n        results.append(case_result)\n\n    # The final output must be a single string representing a list of lists,\n    # with no spaces.\n    final_output_string = str(results).replace(\" \", \"\")\n\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "While the CFL condition ensures stability, it does not guarantee perfect accuracy, and numerical solutions often exhibit non-physical behaviors. This practice explores the concept of numerical diffusion, a common artifact in first-order schemes where the solution profile artificially spreads out over time. By computing the discrete Green’s function for an upwind scheme, you will quantify how much of the numerical solution \"spills\" beyond the true characteristic cone, offering a tangible measure of the scheme's dissipative error .",
            "id": "3369903",
            "problem": "You are asked to build a program that computes and analyzes the discrete Green’s function of a first-order linear upwind Finite Difference Method (FDM) for the constant-coefficient linear advection equation. Work entirely in a dimensionless setting; no physical units are required.\n\nThe governing partial differential equation is the linear advection equation\n$$\nu_t + c\\,u_x = 0,\n$$\nwith constant advection speed $c \\in \\mathbb{R}$. Consider a uniform spatial grid with spacing $\\Delta x  0$ and a uniform time step $\\Delta t  0$. Let the Courant–Friedrichs–Lewy (CFL) number be $\\lambda = \\dfrac{c\\,\\Delta t}{\\Delta x}$. Assume the standard monotone upwind FDM:\n- If $c  0$, the update is\n$$\nu_j^{n+1} = u_j^n - \\lambda\\left(u_j^n - u_{j-1}^n\\right) = (1-\\lambda)u_j^n + \\lambda u_{j-1}^n.\n$$\n- If $c  0$, the update is\n$$\nu_j^{n+1} = u_j^n - \\lambda\\left(u_{j+1}^n - u_j^n\\right) = (1-|\\lambda|)u_j^n + |\\lambda| u_{j+1}^n.\n$$\nAssume $|\\lambda| \\le 1$ to ensure stability and monotonicity. The discrete Green’s function $G_j^n$ is defined as the numerical solution obtained from the impulse initial data $u_j^0 = \\delta_{j,j_0}$, where $\\delta_{j,j_0}$ is the Kronecker delta and $j_0$ is a fixed grid index.\n\nFor the continuous equation, the finite speed of propagation yields an analytic forward cone constraint: from an initial point $x_0 = j_0 \\Delta x$, the set of points reachable at time $t^n = n\\,\\Delta t$ is constrained by $s\\,(x-x_0) \\le |c|\\,t^n$, where $s = \\mathrm{sign}(c)$ and $|\\cdot|$ denotes the absolute value. On the grid, this analytic forward cone translates to the index constraint\n$$\ns\\,(j - j_0) \\le |\\lambda|\\,n.\n$$\nIntroduce the Heaviside function $H(z)$ by $H(z)=1$ if $z0$ and $H(z)=0$ otherwise. Define the discrete “spillover beyond the analytic cone boundary” at time level $n$ by\n$$\nE(n) \\equiv \\sum_{j \\in \\mathbb{Z}} G_j^n\\, H\\!\\left( s\\,(j - j_0) - |\\lambda|\\,n \\right).\n$$\nThis $E(n)$ is a nonnegative real number that measures the violation of the analytic speed-of-propagation constraint by the discrete Green’s function, in the sense of mass fraction that resides strictly beyond the analytic cone boundary at time $t^n$.\n\nYour task is to:\n- Construct $G_j^n$ numerically via the given upwind scheme on a sufficiently large one-dimensional grid with $N$ points, using zero values outside the computational domain. Use $N = 2048$ and $j_0 = N/2$. Ensure that the chosen test cases keep the evolving support sufficiently far from the boundaries so that boundary truncation does not affect the discrete solution.\n- For each test case, compute and return the single scalar value $E(n)$ at the final time level $n$.\n\nThe program must be self-contained and produce, with no user input, the results for the following test suite. Each test case is a quadruple $(c,\\Delta x,\\Delta t,n)$:\n- Test A (general “happy path” with nontrivial diffusion): $(c,\\Delta x,\\Delta t,n) = (\\,1,\\;1,\\;\\frac{1}{4},\\;40\\,)$.\n- Test B (boundary case with exact shift, no numerical diffusion): $(c,\\Delta x,\\Delta t,n) = (\\,1,\\;1,\\;1,\\;40\\,)$.\n- Test C (negative advection speed, nontrivial diffusion): $(c,\\Delta x,\\Delta t,n) = (\\,-\\frac{1}{2},\\;1,\\;0.6,\\;50\\,)$.\n- Test D (longer evolution with moderate CFL): $(c,\\Delta x,\\Delta t,n) = (\\,2,\\;1,\\;0.2,\\;100\\,)$.\n\nYour program should produce a single line of output containing the values of $E(n)$ for Tests A, B, C, and D, in that order, as a comma-separated list enclosed in square brackets (e.g., $[result\\_A,result\\_B,result\\_C,result\\_D]$). The answers must be real numbers.\n\nDesign requirements and constraints:\n- Use the definition of $G_j^n$ as the numerical impulse response obtained by evolving the discrete scheme for $n$ steps starting from $u_j^0 = \\delta_{j,j_0}$.\n- Use the definition of $E(n)$ given above, with $s = \\mathrm{sign}(c)$ and $|\\lambda| = \\left|\\dfrac{c\\,\\Delta t}{\\Delta x}\\right|$.\n- The computation must be deterministic and not rely on any external data or user input.",
            "solution": "The problem is scientifically grounded, well-posed, and all its parameters are fully specified. The governing equation, the numerical scheme, and the metric to be calculated are all standard concepts in the numerical analysis of partial differential equations. The stability condition $|\\lambda| \\le 1$ is satisfied for all test cases. The computational domain is sufficiently large to prevent boundary effects from influencing the result, as requested. The problem is therefore deemed valid.\n\nThe core of the problem is to compute the discrete Green's function, $G_j^n$, for the first-order upwind scheme and then use it to evaluate a specific metric, $E(n)$, which quantifies the numerical diffusion.\n\nThe governing equation is the linear advection equation, $u_t + c\\,u_x = 0$, where $u(x,t)$ is a scalar quantity and $c \\in \\mathbb{R}$ is the constant advection speed. We discretize this equation on a uniform grid with spatial step $\\Delta x$ and time step $\\Delta t$. The numerical solution at grid point $j$ and time level $n$ is denoted $u_j^n$. The Courant–Friedrichs–Lewy (CFL) number is $\\lambda = \\frac{c\\,\\Delta t}{\\Delta x}$.\n\nThe upwind finite difference method is specified as follows:\nIf the advection speed is positive ($c  0$), information flows from left to right. The scheme is:\n$$\nu_j^{n+1} = u_j^n - \\lambda\\left(u_j^n - u_{j-1}^n\\right) = (1-\\lambda)u_j^n + \\lambda u_{j-1}^n\n$$\nIf the advection speed is negative ($c  0$), information flows from right to left. The scheme is:\n$$\nu_j^{n+1} = u_j^n - \\lambda\\left(u_{j+1}^n - u_j^n\\right)\n$$\nNoting that for $c  0$, $\\lambda  0$, we can write $\\lambda = -|\\lambda|$, so the scheme becomes:\n$$\nu_j^{n+1} = (1+\\lambda)u_j^n - \\lambda u_{j+1}^n = (1-|\\lambda|)u_j^n + |\\lambda| u_{j+1}^n\n$$\nThese schemes are stable and monotone under the condition $|\\lambda| \\le 1$.\n\nThe discrete Green’s function, $G_j^n$, is the response of this numerical scheme to an initial impulse. We start with the initial condition $u_j^0 = \\delta_{j,j_0}$, where $\\delta_{j,j_0}$ is the Kronecker delta, which is $1$ at a specific index $j_0$ and $0$ everywhere else. The computational domain is a finite grid of $N=2048$ points, indexed from $j=0$ to $N-1$. The initial impulse is placed at the center, $j_0 = N/2 = 1024$. The problem specifies using zero values for grid points outside this domain, which translates to a zero-Dirichlet boundary condition when implementing the scheme. For example, when updating the value at $j=0$ for a $c0$ case, the value $u_{-1}^n$ is taken as $0$.\n\nThe solution algorithm proceeds by iteratively applying the appropriate upwind scheme for a total of $n$ time steps, starting from the initial impulse $u_j^0 = \\delta_{j,1024}$. At each step, a new state vector $u^{n+1}$ is computed from the current state $u^n$. A temporary copy of the current state is used to ensure that all updates for the new time level are based on the same, complete old time level. After $n$ steps, the resulting grid function $u_j^n$ is the desired discrete Green's function $G_j^n$.\n\nOnce $G_j^n$ is computed, the final step is to calculate the spillover metric $E(n)$. This metric is defined as:\n$$\nE(n) \\equiv \\sum_{j=0}^{N-1} G_j^n\\, H\\!\\left( s\\,(j - j_0) - |\\lambda|\\,n \\right)\n$$\nHere, $s = \\mathrm{sign}(c)$ is the sign of the advection speed. The argument of the Heaviside function, $z = s\\,(j - j_0) - |\\lambda|\\,n$, determines whether a grid point $j$ lies strictly beyond the analytic characteristic line originating from $x_0 = j_0 \\Delta x$. The analytic solution propagates at speed $c$, so at time $t^n = n\\,\\Delta t$, the front of the wave should be at $x = x_0 + c t^n$, which on the grid corresponds to an index shift of $\\frac{c t^n}{\\Delta x} = \\frac{c (n \\Delta t)}{\\Delta x} = \\lambda n = s |\\lambda| n$. The condition for spillover, $s(j - j_0)  |\\lambda| n$, thus identifies all grid points $j$ that are \"ahead\" of this characteristic front.\n\nThe Heaviside function $H(z)$ is defined as $1$ for $z0$ and $0$ otherwise. This acts as a filter, so the summation for $E(n)$ only includes the \"mass\" (values of $G_j^n$) at these spillover grid points. The procedure is executed for each of the four test cases provided, and the resulting values of $E(n)$ are collected.\n\nFor implementation, a vectorized approach using `numpy` is efficient. The time-stepping for $c0$ can be implemented by operating on array slices `u[1:]` and `u[:-1]`, with a separate update for the boundary point `u[0]`. A similar approach applies for the $c0$ case. The final computation of $E(n)$ involves creating a boolean mask from the Heaviside function's argument and performing a dot product with the final $G_j^n$ vector.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_spillover(c, delta_x, delta_t, n_final):\n    \"\"\"\n    Computes the discrete Green's function and the spillover metric E(n).\n\n    Args:\n        c (float): Advection speed.\n        delta_x (float): Spatial grid spacing.\n        delta_t (float): Time step.\n        n_final (int): Number of time steps to evolve.\n\n    Returns:\n        float: The spillover metric E(n) at the final time step.\n    \"\"\"\n    N = 2048\n    j0 = N // 2\n\n    # Initialize the grid with the discrete impulse (Kronecker delta).\n    u = np.zeros(N, dtype=np.float64)\n    u[j0] = 1.0\n\n    # Calculate CFL number and sign of c.\n    lambda_val = c * delta_t / delta_x\n    s = np.sign(c)\n\n    # Time-stepping loop to construct the Green's function G_j^n.\n    for _ in range(n_final):\n        # Use a copy of u to ensure updates are based on the complete state at time n.\n        u_old = u.copy()\n        \n        if c  0:\n            # Upwind scheme for c  0: u_j^{n+1} = (1-lambda)u_j^n + lambda*u_{j-1}^n\n            # Update interior points j=1,...,N-1\n            u[1:] = (1.0 - lambda_val) * u_old[1:] + lambda_val * u_old[:-1]\n            # Update boundary point j=0, where u_{-1}^n is 0.\n            u[0] = (1.0 - lambda_val) * u_old[0]\n        elif c  0:\n            abs_lambda = abs(lambda_val)\n            # Upwind scheme for c  0: u_j^{n+1} = (1-|lambda|)u_j^n + |lambda|*u_{j+1}^n\n            # Update interior points j=0,...,N-2\n            u[:-1] = (1.0 - abs_lambda) * u_old[:-1] + abs_lambda * u_old[1:]\n            # Update boundary point j=N-1, where u_{N}^n is 0.\n            u[-1] = (1.0 - abs_lambda) * u_old[-1]\n        # If c = 0, lambda = 0, u remains unchanged, which is the correct behavior.\n\n    # At this point, u contains the values of the discrete Green's function G_j^n\n    # at the final time step n_final.\n\n    # Compute the spillover metric E(n).\n    j_indices = np.arange(N)\n    abs_lambda = abs(lambda_val)\n\n    # Calculate the argument of the Heaviside function for all j.\n    # z = s*(j - j0) - |lambda|*n\n    heaviside_arg = s * (j_indices - j0) - abs_lambda * n_final\n\n    # Create the Heaviside mask. H(z)=1 if z0, and 0 otherwise.\n    heaviside_mask = (heaviside_arg  0).astype(np.float64)\n\n    # E(n) is the sum of G_j^n over the indices where the mask is 1.\n    E_n = np.sum(u * heaviside_mask)\n\n    return E_n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (c, delta_x, delta_t, n_final)\n    test_cases = [\n        (1.0, 1.0, 0.25, 40),      # Test A\n        (1.0, 1.0, 1.0, 40),       # Test B\n        (-0.5, 1.0, 0.6, 50),      # Test C\n        (2.0, 1.0, 0.2, 100),      # Test D\n    ]\n\n    results = []\n    for case in test_cases:\n        c, delta_x, delta_t, n_final = case\n        result = compute_spillover(c, delta_x, delta_t, n_final)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}