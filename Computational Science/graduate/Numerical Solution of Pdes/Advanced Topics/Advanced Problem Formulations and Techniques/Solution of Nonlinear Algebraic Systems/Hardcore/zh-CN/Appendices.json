{
    "hands_on_practices": [
        {
            "introduction": "本练习将带您从一个非线性偏微分方程出发，通过应用伽辽金有限元法，亲手推导出求解时所需的核心构件：残差向量和雅可比矩阵。在单元层面理解这一过程，对于深入领会大规模仿真软件的内部工作原理至关重要。通过这个练习，您将掌握将连续问题转化为离散非线性代数系统的关键技能。",
            "id": "3444537",
            "problem": "考虑在一维（$1$D）空间区间 $[x_1,x_2]$ 上的稳态非线性扩散偏微分方程（PDE）：\n$$-\\frac{d}{dx}\\left(k(u)\\frac{du}{dx}\\right)=0,$$\n其本构关系为 $k(u)=1+u^2$，并在 $x_1$ 和 $x_2$ 处具有自然（零通量）边界条件。使用标准的伽辽金有限元法（FEM），在覆盖 $[x_1,x_2]$ 区间、长度为 $h=x_2-x_1$ 的单个单元上，采用线性拉格朗日基函数，令有限维近似解为 $u_h(x)=N_1(x)u_1+N_2(x)u_2$，其中 $N_1$ 和 $N_2$ 分别是与 $x_1$ 和 $x_2$ 处节点相关的单元形函数，而 $u_1, u_2$ 是节点未知数。\n\n从弱形式和伽辽金残差的定义出发，推导与非线性代数系统的牛顿线性化相对应的单元级残差向量和单元级雅可比矩阵。将所有积分精确表示（不引入求积公式），并将其简化为以 $u_1$、$u_2$ 和 $h$ 表示的闭式解析表达式。然后，明确描述对于单单元网格，这些单元级的贡献是如何组装成全局残差和全局雅可比矩阵的（即，局部自由度如何映射到全局自由度）。\n\n最后，计算此单单元网格的组装后全局雅可比矩阵的行列式，并将其作为一个简化的精确表达式给出。无需进行数值舍入。",
            "solution": "问题陈述在科学上是合理的、适定的、客观的且自洽的。它提出了一个将有限元法应用于非线性边值问题的标准练习。所有必要的数据和定义都已提供，不存在内部矛盾或违反科学原理的情况。该问题是有效的，并且可以构建一个解。\n\n过程始于推导偏微分方程（PDE）的弱形式。给定的强形式为：\n$$-\\frac{d}{dx}\\left(k(u)\\frac{du}{dx}\\right) = 0 \\quad \\text{for } x \\in [x_1, x_2]$$\n其中 $k(u) = 1+u^2$。为了得到弱形式，我们乘以一个测试函数 $v(x)$ 并在定义域 $[x_1, x_2]$ 上积分：\n$$ \\int_{x_1}^{x_2} -v \\frac{d}{dx}\\left(k(u)\\frac{du}{dx}\\right) dx = 0 $$\n分部积分得到：\n$$ \\left[ -v \\cdot k(u)\\frac{du}{dx} \\right]_{x_1}^{x_2} + \\int_{x_1}^{x_2} \\frac{dv}{dx} k(u)\\frac{du}{dx} dx = 0 $$\n项 $-k(u) \\frac{du}{dx}$ 代表通量。问题指定了在 $x=x_1$ 和 $x=x_2$ 处的自然（零通量）边界条件。这意味着边界项 $\\left[ -v \\cdot k(u)\\frac{du}{dx} \\right]_{x_1}^{x_2}$ 为零。因此，弱形式为：寻找一个试验函数 $u$，使得对于所有容许的测试函数 $v$：\n$$ \\int_{x_1}^{x_2} k(u) \\frac{du}{dx} \\frac{dv}{dx} dx = 0 $$\n在伽辽金有限元法中，试验函数 $u$ 和测试函数 $v$ 选自同一个有限维空间。我们用 $u_h(x) = \\sum_{j} u_j N_j(x)$ 来近似 $u$，其中 $u_j$ 是节点未知数，$N_j(x)$ 是基（形）函数。弱形式必须对空间中的任何测试函数 $v$ 都成立，因此我们对每个基函数索引 $i$ 选择 $v(x) = N_i(x)$。这导出一个非线性代数方程组，其中第 $i$ 个方程由残差分量 $R_i$ 给出：\n$$ R_i(\\mathbf{u}) = \\int_{x_1}^{x_2} k(u_h) \\frac{du_h}{dx} \\frac{dN_i}{dx} dx = 0 $$\n对于指定的长度为 $h=x_2-x_1$ 的单个单元，使用线性拉格朗日基函数，近似解为 $u_h(x) = N_1(x)u_1 + N_2(x)u_2$。在局部坐标系 $\\xi \\in [0, 1]$ 中进行计算会很方便，其中 $x(\\xi) = x_1 + \\xi h$。根据链式法则，我们有 $\\frac{d}{dx} = \\frac{d\\xi}{dx}\\frac{d}{d\\xi} = \\frac{1}{h}\\frac{d}{d\\xi}$。局部坐标系中的线性基函数为：\n$$ N_1(\\xi) = 1-\\xi, \\quad N_2(\\xi) = \\xi $$\n它们关于 $\\xi$ 和 $x$ 的导数是：\n$$ \\frac{dN_1}{d\\xi} = -1, \\quad \\frac{dN_2}{d\\xi} = 1 $$\n$$ \\frac{dN_1}{dx} = -\\frac{1}{h}, \\quad \\frac{dN_2}{dx} = \\frac{1}{h} $$\n近似解 $u_h$ 及其导数可以表示为：\n$$ u_h(\\xi) = (1-\\xi)u_1 + \\xi u_2 = u_1 + (u_2-u_1)\\xi $$\n$$ \\frac{du_h}{dx} = \\frac{1}{h}\\frac{du_h}{d\\xi} = \\frac{u_2-u_1}{h} $$\n现在，我们可以计算单元级残差向量 $\\mathbf{R}^{(e)} = [R_1, R_2]^T$ 的分量。将积分变换到局部坐标系，其中 $dx = h d\\xi$：\n$$ R_i(\\mathbf{u}) = \\int_{0}^{1} k(u_h(\\xi)) \\left(\\frac{u_2-u_1}{h}\\right) \\left(\\frac{1}{h}\\frac{dN_i}{d\\xi}\\right) h d\\xi = \\frac{u_2-u_1}{h} \\frac{dN_i}{d\\xi} \\int_{0}^{1} (1 + u_h(\\xi)^2) d\\xi $$\n我们来计算这个积分：\n$$ \\int_{0}^{1} \\left(1 + (u_1 + (u_2-u_1)\\xi)^2\\right) d\\xi = \\left[\\xi + \\frac{(u_1 + (u_2-u_1)\\xi)^3}{3(u_2-u_1)}\\right]_0^1 $$\n$$ = 1 + \\frac{u_2^3}{3(u_2-u_1)} - \\frac{u_1^3}{3(u_2-u_1)} = 1 + \\frac{u_2^3-u_1^3}{3(u_2-u_1)} = 1 + \\frac{(u_2-u_1)(u_2^2+u_1u_2+u_1^2)}{3(u_2-u_1)} $$\n$$ = 1 + \\frac{1}{3}(u_1^2 + u_1u_2 + u_2^2) = \\frac{1}{3}(3 + u_1^2 + u_1u_2 + u_2^2) $$\n使用此结果来求残差分量：\n对于 $i=1$, $\\frac{dN_1}{d\\xi}=-1$：\n$$ R_1 = \\frac{u_2-u_1}{h} (-1) \\left(\\frac{1}{3}(3 + u_1^2 + u_1u_2 + u_2^2)\\right) = -\\frac{u_2-u_1}{3h}(3 + u_1^2 + u_1u_2 + u_2^2) $$\n对于 $i=2$, $\\frac{dN_2}{d\\xi}=1$：\n$$ R_2 = \\frac{u_2-u_1}{h} (1) \\left(\\frac{1}{3}(3 + u_1^2 + u_1u_2 + u_2^2)\\right) = \\frac{u_2-u_1}{3h}(3 + u_1^2 + u_1u_2 + u_2^2) $$\n单元级残差向量为：\n$$ \\mathbf{R}^{(e)}(\\mathbf{u}) = \\frac{u_2-u_1}{3h}(3 + u_1^2 + u_1u_2 + u_2^2) \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} $$\n接下来，我们通过对残差分量关于节点未知数求导来推导单元级雅可比矩阵 $\\mathbf{J}^{(e)}$：$J_{ij}^{(e)} = \\frac{\\partial R_i}{\\partial u_j}$。\n很明显 $R_2 = -R_1$。因此，雅可比矩阵的第二行将是第一行的负数：$J_{2j} = -J_{1j}$。\n设 $A = u_2-u_1$ 且 $B = 3 + u_1^2 + u_1u_2 + u_2^2$。则 $R_1 = -\\frac{1}{3h}AB$。\n$$ J_{11} = \\frac{\\partial R_1}{\\partial u_1} = -\\frac{1}{3h} \\left( \\frac{\\partial A}{\\partial u_1}B + A\\frac{\\partial B}{\\partial u_1} \\right) = -\\frac{1}{3h} \\left( (-1)B + (u_2-u_1)(2u_1+u_2) \\right) $$\n$$ J_{11} = -\\frac{1}{3h} \\left( -(3 + u_1^2 + u_1u_2 + u_2^2) + (2u_1u_2+u_2^2-2u_1^2-u_1u_2) \\right) $$\n$$ J_{11} = -\\frac{1}{3h} \\left( -3 - u_1^2 - u_1u_2 - u_2^2 + u_1u_2+u_2^2-2u_1^2 \\right) = -\\frac{1}{3h}(-3 - 3u_1^2) = \\frac{1}{h}(1+u_1^2) $$\n$$ J_{12} = \\frac{\\partial R_1}{\\partial u_2} = -\\frac{1}{3h} \\left( \\frac{\\partial A}{\\partial u_2}B + A\\frac{\\partial B}{\\partial u_2} \\right) = -\\frac{1}{3h} \\left( (1)B + (u_2-u_1)(u_1+2u_2) \\right) $$\n$$ J_{12} = -\\frac{1}{3h} \\left( (3 + u_1^2 + u_1u_2 + u_2^2) + (u_1u_2+2u_2^2-u_1^2-2u_1u_2) \\right) $$\n$$ J_{12} = -\\frac{1}{3h} \\left( 3 + u_1^2 + u_1u_2 + u_2^2 - u_1^2 - u_1u_2 + 2u_2^2 \\right) = -\\frac{1}{3h}(3 + 3u_2^2) = -\\frac{1}{h}(1+u_2^2) $$\n单元级雅可比矩阵为：\n$$ \\mathbf{J}^{(e)}(\\mathbf{u}) = \\begin{pmatrix} J_{11}  J_{12} \\\\ J_{21}  J_{22} \\end{pmatrix} = \\begin{pmatrix} J_{11}  J_{12} \\\\ -J_{11}  -J_{12} \\end{pmatrix} = \\frac{1}{h} \\begin{pmatrix} 1+u_1^2  -(1+u_2^2) \\\\ -(1+u_1^2)  1+u_2^2 \\end{pmatrix} $$\n对于仅由单个单元组成的网格，全局自由度与单元的局部自由度相同。映射是恒等映射：局部节点 $1$ 对应全局节点 $1$，局部节点 $2$ 对应全局节点 $2$。因此，全局残差向量和全局雅可比矩阵与其单元级对应物相同。\n$$ \\mathbf{R}_{global} = \\mathbf{R}^{(e)}, \\quad \\mathbf{J}_{global} = \\mathbf{J}^{(e)} $$\n最后的任务是计算组装后的全局雅可比矩阵的行列式：\n$$ \\det(\\mathbf{J}_{global}) = \\det\\left( \\frac{1}{h} \\begin{pmatrix} 1+u_1^2  -(1+u_2^2) \\\\ -(1+u_1^2)  1+u_2^2 \\end{pmatrix} \\right) $$\n使用 $n \\times n$ 矩阵的性质 $\\det(c \\mathbf{A}) = c^n \\det(\\mathbf{A})$：\n$$ \\det(\\mathbf{J}_{global}) = \\left(\\frac{1}{h}\\right)^2 \\det \\begin{pmatrix} 1+u_1^2  -(1+u_2^2) \\\\ -(1+u_1^2)  1+u_2^2 \\end{pmatrix} $$\n$$ \\det(\\mathbf{J}_{global}) = \\frac{1}{h^2} \\left[ (1+u_1^2)(1+u_2^2) - (-(1+u_2^2))(-(1+u_1^2)) \\right] $$\n$$ \\det(\\mathbf{J}_{global}) = \\frac{1}{h^2} \\left[ (1+u_1^2)(1+u_2^2) - (1+u_1^2)(1+u_2^2) \\right] $$\n$$ \\det(\\mathbf{J}_{global}) = \\frac{1}{h^2} [0] = 0 $$\n对于任意 $u_1$ 和 $u_2$ 的值，全局雅可比矩阵的行列式都为零。这种奇异性是预料之中的。带有纯诺伊曼边界条件的原始偏微分方程有一个解 $u(x)=C$（一个常数），但 $C$ 的值是不确定的。这导致代数系统有非唯一解，表现为奇异的雅可比矩阵。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "经典牛顿法虽然具有理想的二次收敛速度，但其在每次迭代中都需要计算并分解精确的雅可比矩阵，这对于大规模问题而言计算成本可能过高。本练习将引导您探索一种强大的替代方案——拟牛顿法，特别是Broyden秩一更新。您将通过亲手实现并比较这两种方法，直观地体验在单次迭代成本与总迭代次数之间的权衡，这是设计高效非线性求解器时的一个核心考量。",
            "id": "3444521",
            "problem": "实现并比较两种牛顿类方法，用于求解一个非线性代数方程组。该方程组源于一个一维半线性偏微分方程（PDE）的有限差分格式。从以下基本事实出发：(i) 通过中心有限差分进行离散化的稳态偏微分方程会产生一个非线性代数方程组；(ii) 求解非线性系统 $\\mathbf{F}(\\mathbf{u})=\\mathbf{0}$ 的牛顿法需要求解涉及雅可比矩阵的线性系统；以及 (iii) 多维割线条件通过对 $\\mathbf{s}_k=\\mathbf{u}_{k+1}-\\mathbf{u}_k$ 和 $\\mathbf{y}_k=\\mathbf{F}(\\mathbf{u}_{k+1})-\\mathbf{F}(\\mathbf{u}_k)$ 强制执行 $\\mathbf{J}_{k+1}\\mathbf{s}_k=\\mathbf{y}_k$ 来推广标量割线更新。设计一个雅可比矩阵的秩一更新，在满足割线条件的同时，在弗罗贝尼乌斯范数下尽可能小地改变 $\\mathbf{J}_k$，并利用它来减少精确雅可比矩阵的组装次数。\n\n考虑在单位区间上的边值问题，其具有齐次狄利克雷边界条件，\n$$-u''(x)+\\alpha u(x)^3=g(x),\\quad x\\in(0,1),\\quad u(0)=0,\\quad u(1)=0,$$\n其中 $\\alpha0$。使用一个包含 $n$ 个内部点的均匀网格进行离散化，网格间距为 $h=1/(n+1)$，并对 $-u''$ 使用标准的二阶中心差分，即对于内部节点 $i$，\n$$-u''(x_i)\\approx -\\frac{u_{i-1}-2u_i+u_{i+1}}{h^2}.$$\n令 $\\mathbf{u}\\in\\mathbb{R}^n$ 为内部节点值的集合，并定义非线性残差向量 $\\mathbf{F}(\\mathbf{u})\\in\\mathbb{R}^n$，其分量为\n$$F_i(\\mathbf{u})=-\\frac{u_{i-1}-2u_i+u_{i+1}}{h^2}+\\alpha u_i^3-g_i,$$\n其中边界值为 $u_0=u_{n+1}=0$。使用应用于离散残差的基本微分法则，组装精确的雅可比矩阵 $\\mathbf{J}(\\mathbf{u})\\in\\mathbb{R}^{n\\times n}$。您还必须根据多维割线条件和弗罗贝尼乌斯范数下的最小变化原则，推导出一个唯一的秩一更新映射 $\\mathbf{J}_k\\mapsto\\mathbf{J}_{k+1}$，该映射保持割线条件。\n\n算法要求：\n- 实现两种求解器用于 $\\mathbf{F}(\\mathbf{u})=\\mathbf{0}$：\n  - 方法 A（基准）：经典牛顿法，在每次迭代时都组装精确的雅可比矩阵。对优值函数 $\\phi(\\mathbf{u})=\\tfrac{1}{2}\\|\\mathbf{F}(\\mathbf{u})\\|_2^2$ 使用回溯线搜索，并采用阿米霍型条件、初始试探步长 $t=1$、充分下降常数 $c_1\\in(0,1)$ 以及回溯乘法因子 $\\tau\\in(0,1)$。\n  - 方法 B（近似雅可比矩阵）：从一次精确的雅可比矩阵组装开始，然后在每个接受的步长后，通过您从割线条件和最小变化原则推导出的秩一更新来更新雅可比矩阵。为促进稳健收敛，每隔 $m$ 个接受的步长（其中 $m$ 是一个正整数）重新组装一次精确的雅可比矩阵以进行刷新。\n- 使用构造解 $u^\\star(x)=\\sin(\\pi x)$，通过您实现的相同离散算子来设置离散的右端项 $g_i$。也就是说，计算 $g_i$ 使得对于所选的 $\\alpha$，离散的 $\\mathbf{u}^\\star$ 能精确满足 $\\mathbf{F}(\\mathbf{u}^\\star)=\\mathbf{0}$。这消除了建模误差，并确保对代数求解器进行独立评估。\n- 停止准则：当 $\\|\\mathbf{F}(\\mathbf{u})\\|_2\\le \\varepsilon$（对于给定的容差 $\\varepsilon0$）或达到最大迭代次数时终止。使用测试 $\\phi(\\mathbf{u})$ 下降的阿米霍回溯法，并采用与定义步长所用雅可比矩阵一致计算出的方向导数。\n- 成本度量：计算精确雅可比矩阵的组装次数。对于方法 A，这等于执行的迭代次数。对于方法 B，仅计算初始组装和周期性刷新；不要将秩一更新计为组装。\n\n您必须推导并实现给定离散化的半线性问题的精确雅可比矩阵项，并且必须推导并实现由多维割线条件和最小弗罗贝尼乌斯范数变化定义的唯一秩一更新。\n\n测试套件：\n对以下四种情况运行这两种方法。每种情况由 $(n,\\alpha,m,\\varepsilon,\\text{max\\_iter})$ 指定：\n- 情况 1：$(n,\\alpha,m,\\varepsilon,\\text{max\\_iter})=(64,1,3,10^{-10},50)$。\n- 情况 2：$(n,\\alpha,m,\\varepsilon,\\text{max\\_iter})=(64,10,5,10^{-10},50)$。\n- 情况 3：$(n,\\alpha,m,\\varepsilon,\\text{max\\_iter})=(16,1,1000,10^{-10},50)$。\n- 情况 4：$(n,\\alpha,m,\\varepsilon,\\text{max\\_iter})=(128,1,2,10^{-10},50)$。\n\n对于每种情况，使用零向量作为初始猜测进行初始化。对于线搜索，使用 $c_1=10^{-4}$，$\\tau=1/2$，以及最小步长 $t_{\\min}=10^{-8}$。\n\n要求的最终输出：\n- 对于每种情况，按以下顺序生成一个包含八个值的列表：\n  $[\\text{convB},\\text{itB},\\text{assmB},\\|\\mathbf{F}\\|_B,\\text{convA},\\text{itA},\\text{assmA},\\|\\mathbf{F}\\|_A]$，其中：\n  - $\\text{convB}$ 和 $\\text{convA}$ 是布尔值，分别表示方法 B 和方法 A 是否在迭代限制内满足 $\\|\\mathbf{F}(\\mathbf{u})\\|_2\\le\\varepsilon$，\n  - $\\text{itB}$ 和 $\\text{itA}$ 是执行的迭代次数，\n  - $\\text{assmB}$ 和 $\\text{assmA}$ 是精确雅可比矩阵的组装次数，\n  - $\\|\\mathbf{F}\\|_B$ 和 $\\|\\mathbf{F}\\|_A$ 是作为浮点数的最终残差范数。\n- 您的程序应生成单行输出，其中包含这些按案例排列的列表的列表，无空白，且浮点数采用小数点后六位的科学记数法。例如，单个案例将显示为 $[[\\dots]]$，所有四个案例将显示为 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。\n\n角度单位不适用。不存在物理单位。所有数值答案必须遵循最终输出的格式规则。",
            "solution": "用户提供了一个定义明确的数值分析问题。任务是实现并比较两种牛顿类方法，用于求解一个由一维半线性偏微分方程的有限差分格式产生的非线性代数方程组。\n\n### 步骤 1：问题表述与离散化\n\n给定的边值问题是：\n$$ -u''(x)+\\alpha u(x)^3=g(x), \\quad x\\in(0,1) $$\n具有齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。域 $(0,1)$ 使用 $n$ 个内部点 $x_i = i h$（对于 $i=1, \\dots, n$）进行离散化，其中网格间距为 $h=1/(n+1)$。点 $x_i$ 处的二阶导数 $-u''$ 使用二阶中心差分公式近似：\n$$ -u''(x_i) \\approx \\frac{-u(x_{i-1}) + 2u(x_i) - u(x_{i+1})}{h^2} $$\n令 $\\mathbf{u} = [u_1, u_2, \\dots, u_n]^T$ 为内部网格点上未知值的向量，其中 $u_i \\approx u(x_i)$。每个内部节点 $x_i$ 处的离散化方程构成了非线性系统 $\\mathbf{F}(\\mathbf{u})=\\mathbf{0}$ 的一个分量。残差向量 $\\mathbf{F}(\\mathbf{u})$ 的第 $i$ 个分量是：\n$$ F_i(\\mathbf{u}) = \\frac{-u_{i-1} + 2u_i - u_{i+1}}{h^2} + \\alpha u_i^3 - g_i $$\n边界条件 $u_0=0$ 和 $u_{n+1}=0$ 分别用于 $i=1$ 和 $i=n$ 的方程。\n\n该系统可以写成向量形式：\n$$ \\mathbf{F}(\\mathbf{u}) = \\mathbf{A}\\mathbf{u} + \\alpha \\mathbf{u}^{\\circ 3} - \\mathbf{g} = \\mathbf{0} $$\n其中 $\\mathbf{u}^{\\circ 3} = [u_1^3, u_2^3, \\dots, u_n^3]^T$ 是向量 $\\mathbf{u}$ 的逐元素立方，$\\mathbf{A}$ 是表示离散负拉普拉斯算子的 $n \\times n$ 矩阵：\n$$ \\mathbf{A} = \\frac{1}{h^2} \\begin{pmatrix}\n2  -1  0  \\dots  0 \\\\\n-1  2  -1  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  \\vdots \\\\\n\\vdots    -1  2  -1 \\\\\n0  \\dots  0  -1  2\n\\end{pmatrix} $$\n为了创建一个可验证的问题，使用了一个构造解 $u^\\star(x) = \\sin(\\pi x)$。离散版本 $\\mathbf{u}^\\star_i = \\sin(\\pi i h)$ 用于定义右端向量 $\\mathbf{g}$，使得 $\\mathbf{F}(\\mathbf{u}^\\star) = \\mathbf{0}$。因此，$\\mathbf{g}$ 计算如下：\n$$ \\mathbf{g} = \\mathbf{A}\\mathbf{u}^\\star + \\alpha (\\mathbf{u}^\\star)^{\\circ 3} $$\n\n### 步骤 2：精确雅可比矩阵的推导\n\n牛顿法需要雅可比矩阵 $\\mathbf{J}(\\mathbf{u})$，其元素为 $J_{ij}(\\mathbf{u}) = \\frac{\\partial F_i}{\\partial u_j}$。我们对 $F_i(\\mathbf{u})$ 关于 $u_j$ 求导：\n$$ F_i(\\mathbf{u}) = \\frac{1}{h^2}(-u_{i-1} + 2u_i - u_{i+1}) + \\alpha u_i^3 - g_i $$\n偏导数如下：\n-   对于 $j=i$：$\\frac{\\partial F_i}{\\partial u_i} = \\frac{2}{h^2} + 3\\alpha u_i^2$。\n-   对于 $j=i-1$：$\\frac{\\partial F_i}{\\partial u_{i-1}} = -\\frac{1}{h^2}$。\n-   对于 $j=i+1$：$\\frac{\\partial F_i}{\\partial u_{i+1}} = -\\frac{1}{h^2}$。\n-   对于 $|i-j|  1$：$\\frac{\\partial F_i}{\\partial u_j} = 0$。\n\n因此，雅可比矩阵 $\\mathbf{J}(\\mathbf{u})$ 是一个三对角矩阵，由常数矩阵 $\\mathbf{A}$ 和一个来自非线性项的对角矩阵组成：\n$$ \\mathbf{J}(\\mathbf{u}) = \\mathbf{A} + 3\\alpha \\cdot \\text{diag}(u_1^2, u_2^2, \\dots, u_n^2) = \\mathbf{A} + 3\\alpha \\cdot \\text{diag}(\\mathbf{u}^{\\circ 2}) $$\n该矩阵是对称的，并且由于 $\\mathbf{A}$ 是对称正定的，且对角线上的加项是非负的，所以 $\\mathbf{J}(\\mathbf{u})$ 也是对称正定的。\n\n### 步骤 3：秩一雅可比更新的推导\n\n方法 B 使用拟牛顿法，用矩阵 $\\mathbf{B}_k$ 来近似雅可比矩阵 $\\mathbf{J}_k = \\mathbf{J}(\\mathbf{u}_k)$。在从 $\\mathbf{u}_k$ 到 $\\mathbf{u}_{k+1}$ 的更新步骤之后，新的近似 $\\mathbf{B}_{k+1}$ 需要满足割线条件：\n$$ \\mathbf{B}_{k+1}\\mathbf{s}_k = \\mathbf{y}_k, \\quad \\text{其中 } \\mathbf{s}_k = \\mathbf{u}_{k+1} - \\mathbf{u}_k \\text{ 且 } \\mathbf{y}_k = \\mathbf{F}(\\mathbf{u}_{k+1}) - \\mathbf{F}(\\mathbf{u}_k) $$\n具体的更新是通过找到满足此条件同时“最接近” $\\mathbf{B}_k$ 的 $\\mathbf{B}_{k+1}$ 来推导的。这被表述为一个约束优化问题：\n$$ \\min_{\\mathbf{B} \\in \\mathbb{R}^{n\\times n}} \\|\\mathbf{B} - \\mathbf{B}_k\\|_F \\quad \\text{受限于} \\quad \\mathbf{B}\\mathbf{s}_k = \\mathbf{y}_k $$\n其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。最小化范数等价于最小化其平方 $\\frac{1}{2}\\|\\mathbf{B} - \\mathbf{B}_k\\|_F^2$。我们使用拉格朗日乘数法。拉格朗日函数为：\n$$ \\mathcal{L}(\\mathbf{B}, \\boldsymbol{\\lambda}) = \\frac{1}{2}\\text{tr}((\\mathbf{B}-\\mathbf{B}_k)^T(\\mathbf{B}-\\mathbf{B}_k)) - \\boldsymbol{\\lambda}^T(\\mathbf{B}\\mathbf{s}_k - \\mathbf{y}_k) $$\n将关于 $\\mathbf{B}$ 的梯度设为零，得到：\n$$ \\nabla_{\\mathbf{B}} \\mathcal{L} = \\mathbf{B} - \\mathbf{B}_k - \\boldsymbol{\\lambda}\\mathbf{s}_k^T = \\mathbf{0} \\implies \\mathbf{B}_{k+1} = \\mathbf{B}_k + \\boldsymbol{\\lambda}\\mathbf{s}_k^T $$\n这证实了更新是一个秩一矩阵。为了找到拉格朗日乘子向量 $\\boldsymbol{\\lambda}$，我们强制执行割线约束：\n$$ \\mathbf{B}_{k+1}\\mathbf{s}_k = (\\mathbf{B}_k + \\boldsymbol{\\lambda}\\mathbf{s}_k^T)\\mathbf{s}_k = \\mathbf{B}_k\\mathbf{s}_k + \\boldsymbol{\\lambda}(\\mathbf{s}_k^T\\mathbf{s}_k) = \\mathbf{y}_k $$\n求解 $\\boldsymbol{\\lambda}$（注意 $\\mathbf{s}_k^T\\mathbf{s}_k = \\|\\mathbf{s}_k\\|_2^2$ 是一个标量）：\n$$ \\boldsymbol{\\lambda} = \\frac{\\mathbf{y}_k - \\mathbf{B}_k\\mathbf{s}_k}{\\mathbf{s}_k^T\\mathbf{s}_k} $$\n将此代回 $\\mathbf{B}_{k+1}$ 的表达式中，得到 Broyden 更新公式：\n$$ \\mathbf{B}_{k+1} = \\mathbf{B}_k + \\frac{(\\mathbf{y}_k - \\mathbf{B}_k\\mathbf{s}_k)\\mathbf{s}_k^T}{\\mathbf{s}_k^T\\mathbf{s}_k} $$\n\n### 步骤 4：算法实现\n\n两种方法都从 $\\mathbf{u}_0 = \\mathbf{0}$ 开始，并迭代直到残差的 L2 范数低于容差 $\\varepsilon=10^{-10}$ 或达到最大迭代次数。每次迭代都涉及求解一个线性系统以获得搜索方向 $\\mathbf{p}_k$，并执行回溯线搜索以找到步长 $t_k$。\n\n**牛顿步**：在迭代 $k$ 时，通过求解 $\\mathbf{M}_k \\mathbf{p}_k = -\\mathbf{F}(\\mathbf{u}_k)$ 来找到搜索方向 $\\mathbf{p}_k$，其中 $\\mathbf{M}_k$ 是雅可比矩阵（或其近似）。\n\n**线搜索**：更新公式为 $\\mathbf{u}_{k+1} = \\mathbf{u}_k + t_k \\mathbf{p}_k$。步长 $t_k$ 的确定方法是：从 $t=1$ 开始，并以因子 $\\tau=1/2$ 递减，直到满足关于优值函数 $\\phi(\\mathbf{u})=\\frac{1}{2}\\|\\mathbf{F}(\\mathbf{u})\\|_2^2$ 的阿米霍条件：\n$$ \\phi(\\mathbf{u}_k + t \\mathbf{p}_k) \\le \\phi(\\mathbf{u}_k) + c_1 t \\nabla\\phi(\\mathbf{u}_k)^T \\mathbf{p}_k $$\n充分下降常数为 $c_1=10^{-4}$。方向导数项 $\\nabla\\phi(\\mathbf{u}_k)^T \\mathbf{p}_k$ 的计算与用于求步长的矩阵保持一致，这导致 $\\mathbf{F}(\\mathbf{u}_k)^T \\mathbf{M}_k \\mathbf{p}_k = -\\mathbf{F}(\\mathbf{u}_k)^T \\mathbf{F}(\\mathbf{u}_k) = -\\|\\mathbf{F}(\\mathbf{u}_k)\\|_2^2$。\n\n**方法 A（经典牛顿法）**：\n- 在每次迭代 $k$ 时，组装精确的雅可比矩阵 $\\mathbf{M}_k = \\mathbf{J}(\\mathbf{u}_k)$。\n- 雅可比矩阵的组装次数等于执行的迭代次数。\n\n**方法 B（拟牛顿法）**：\n- 使用雅可比近似矩阵 $\\mathbf{B}_k$，因此 $\\mathbf{M}_k = \\mathbf{B}_k$。\n- 组装初始的精确雅可比矩阵 $\\mathbf{B}_0 = \\mathbf{J}(\\mathbf{u}_0)$。\n- 在每个接受的步长之后，使用推导出的 Broyden 公式将 $\\mathbf{B}_k$ 更新为 $\\mathbf{B}_{k+1}$。\n- 每隔 $m$ 个接受的步长重新组装一次精确的雅可比矩阵，以刷新近似并确保稳健性。组装次数是初始一次加上刷新的次数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to implement and compare Newton-type solvers for a discretized\n    semilinear PDE, and to format the results as specified.\n    \"\"\"\n\n    def _get_system_components(n, alpha):\n        \"\"\"\n        Sets up the discrete system components for a given n and alpha.\n        This includes the grid, the manufactured solution u_star, the sparse\n        matrix A for the Laplacian, and the right-hand-side vector g.\n        \"\"\"\n        h = 1.0 / (n + 1)\n        x = np.linspace(h, 1.0 - h, n)\n        u_star = np.sin(np.pi * x)\n\n        # Construct matrix A for the discrete Laplacian\n        diag_val = 2.0 / h**2\n        offdiag_val = -1.0 / h**2\n        A = np.diag(np.full(n, diag_val)) + \\\n            np.diag(np.full(n - 1, offdiag_val), k=1) + \\\n            np.diag(np.full(n - 1, offdiag_val), k=-1)\n        \n        # Compute g from the manufactured solution\n        g = A @ u_star + alpha * u_star**3\n        \n        # Define F and J functions\n        F_func = lambda u: A @ u + alpha * u**3 - g\n        J_func = lambda u: A + np.diag(3 * alpha * u**2)\n        \n        return F_func, J_func\n\n    def _run_solver(F, J, n, m, epsilon, max_iter, method):\n        \"\"\"\n        Executes a Newton-type method (A or B) to solve F(u)=0.\n        Method 'A' is classical Newton.\n        Method 'B' is a quasi-Newton method with Broyden updates and restarts.\n        \"\"\"\n        # Line search parameters\n        c1 = 1e-4\n        tau = 0.5\n        t_min = 1e-8\n\n        # Initialization\n        u = np.zeros(n)\n        Fu = F(u)\n        norm_F = np.linalg.norm(Fu, 2)\n        \n        it = 0\n        assemblies = 0\n        \n        Jacobian = None\n        if method == 'B':\n            Jacobian = J(u)\n            assemblies += 1\n            accepted_steps_since_refresh = 0\n\n        while norm_F > epsilon and it  max_iter:\n            # Assemble Jacobian for Method A at each step, or for Method B on first step\n            if method == 'A':\n                Jacobian = J(u)\n                assemblies += 1\n\n            # Solve the linear system for the Newton step\n            try:\n                # Use a standard solver; for n = 128 this is acceptable.\n                p = np.linalg.solve(Jacobian, -Fu)\n            except np.linalg.LinAlgError:\n                # Jacobian is singular, can't proceed.\n                break\n\n            # Backtracking line search with Armijo condition\n            t = 1.0\n            phi_u = 0.5 * norm_F**2\n            # Directional derivative approximation consistent with the (approximate) Jacobian\n            slope = -norm_F**2 \n            \n            step_found = False\n            while t > t_min:\n                u_trial = u + t * p\n                Fu_trial = F(u_trial)\n                phi_trial = 0.5 * np.linalg.norm(Fu_trial, 2)**2\n                \n                if phi_trial = phi_u + c1 * t * slope:\n                    step_found = True\n                    break\n                t *= tau\n            \n            if not step_found:\n                # Line search failed to find a suitable step.\n                break\n            \n            # Step accepted, update state\n            it += 1\n            u_prev = u\n            Fu_prev = Fu\n            u = u_trial\n            Fu = Fu_trial\n            norm_F = np.linalg.norm(Fu, 2)\n            \n            # Update Jacobian for Method B\n            if method == 'B':\n                accepted_steps_since_refresh += 1\n                if accepted_steps_since_refresh == m and it  max_iter:\n                    Jacobian = J(u)\n                    assemblies += 1\n                    accepted_steps_since_refresh = 0\n                else:\n                    s = u - u_prev\n                    y = Fu - Fu_prev\n                    s_dot_s = np.dot(s, s)\n                    if abs(s_dot_s) > 1e-12: # Avoid division by zero\n                        update_vec = y - Jacobian @ s\n                        Jacobian += np.outer(update_vec, s) / s_dot_s\n\n        converged = norm_F = epsilon\n        \n        # Per problem statement: For Method A, assembly count equals iteration count.\n        # My implementation for 'A' naturally results in this.\n        \n        return converged, it, assemblies, norm_F\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (64, 1, 3, 10**-10, 50),\n        (64, 10, 5, 10**-10, 50),\n        (16, 1, 1000, 10**-10, 50),\n        (128, 1, 2, 10**-10, 50),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        n, alpha, m, epsilon, max_iter = case\n        \n        F_func, J_func = _get_system_components(n, alpha)\n        \n        # Run Method B\n        convB, itB, assmB, normB = _run_solver(\n            F_func, J_func, n, m, epsilon, max_iter, 'B'\n        )\n        # Run Method A\n        convA, itA, assmA, normA = _run_solver(\n            F_func, J_func, n, m, epsilon, max_iter, 'A'\n        )\n        \n        # Format results for the current case as a list of strings\n        case_result_list = [\n            str(convB), str(itB), str(assmB), f\"{normB:.6e}\",\n            str(convA), str(itA), str(assmA), f\"{normA:.6e}\"\n        ]\n        all_results.append(f\"[{','.join(case_result_list)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[[{','.join(all_results)}]]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多现实世界中的物理问题，如接触力学或相变问题，其数学模型是变分不等式，这会产生非光滑甚至不可微的非线性系统。本练习将介绍一种处理此类问题的高级技术。您需要将一个障碍问题重构为非线性互补问题（NCP），并使用基于Fischer-Burmeister函数的半光滑牛顿法对其进行求解，从而掌握一种应对经典牛顿法失效场景的强大工具。",
            "id": "3444550",
            "problem": "考虑在区间 $[0,1]$ 上，具有齐次 Dirichlet 边界条件的标量场 $u(x)$ 的一维障碍问题。设 $f(x)$ 为给定的源项，$\\psi(x)$ 为给定的障碍函数。刻画该障碍问题的连续变分不等式为：寻找 $u$，使得在 $[0,1]$ 上几乎处处有 $u \\ge \\psi$，并且 $u(0)=u(1)=0$，对于所有满足 $v \\ge \\psi$ 和 $v(0)=v(1)=0$ 的容许变分 $v$，不等式\n$$\n\\int_0^1 \\nabla u \\cdot \\nabla (v - u) \\, dx \\ge \\int_0^1 f(x) (v - u) \\, dx\n$$\n成立。从 Karush–Kuhn–Tucker 框架导出的相应互补条件可以表示为非线性互补问题 (NCP)：对于离散化算子 $F(u)$，寻找 $u$ 使得 $0 \\le u - \\psi \\perp F(u) \\ge 0$。\n\n使用具有 $n$ 个内部点的均匀网格对区间 $[0,1]$ 进行离散化，步长为 $h = 1/(n+1)$，得到节点 $x_i = i h$，$i = 1, 2, \\dots, n$。使用标准的二阶中心有限差分近似算子 $-u''$，得到无约束问题的线性系统 $A u \\approx f$，其中 $A$ 是一个三对角矩阵，其元素为 $A_{ii} = 2/h^2$，$A_{i,i-1} = A_{i,i+1} = -1/h^2$。定义函数 $F(u) = A u - f$，其中 $f$ 是向量 $f_i = f(x_i)$，$\\psi$ 是向量 $\\psi_i = \\psi(x_i)$。\n\n使用 Fischer–Burmeister 函数 $\\phi(a,b) = \\sqrt{a^2 + b^2} - a - b$ 将离散化的障碍问题重构为非线性方程，该函数逐分量地应用于 $a_i = u_i - \\psi_i$ 和 $b_i = F_i(u)$。因此，需求解 $u \\in \\mathbb{R}^n$ 使得 $g(u) = 0$，其中 $g_i(u) = \\phi(u_i - \\psi_i, F_i(u))$。映射 $g$ 是半光滑的，可以使用半光滑牛顿法，其中利用了 Fischer–Burmeister 函数的广义导数。在每次迭代中，根据以下规则为每个分量 $i$ 选择一个广义导数 $(\\alpha_i, \\beta_i)$：\n- 如果对于一个小的 $\\varepsilon  0$，有 $r_i = \\sqrt{a_i^2 + b_i^2}  \\varepsilon$，则设 $\\alpha_i = a_i / r_i - 1$ 且 $\\beta_i = b_i / r_i - 1$。\n- 如果 $r_i \\le \\varepsilon$，则选择 Clarke 次微分的一个对称元素，例如 $\\alpha_i = \\beta_i = 1/\\sqrt{2} - 1$。\n\n$g$ 在 $u$ 处的广义雅可比矩阵即为 $J(u) = \\mathrm{diag}(\\alpha) + \\mathrm{diag}(\\beta) A$。一个半光滑牛顿步长 $\\delta u$ 通过求解 $J(u) \\, \\delta u = - g(u)$ 得到，可以选择性地使用全局化策略（如回溯线搜索）来确保 $\\|g(u)\\|$ 的充分下降。\n\n实现一个完整的程序，该程序：\n- 为每个测试用例构建离散算子 $A$、源向量 $f$ 和障碍向量 $\\psi$。\n- 通过上述基于 Fischer–Burmeister 函数的半光滑牛顿法求解 NCP $0 \\le u - \\psi \\perp F(u) \\ge 0$。\n- 报告每个测试用例在计算出的解处 Fischer–Burmeister 残差的无穷范数 $\\|g(u)\\|_{\\infty}$。\n\n使用以下包含 $n = 64$ 个内部点的测试套件：\n1. 情况 1：对所有 $x$，有 $f(x) = 1$；对所有 $x$，有 $\\psi(x) = 0$。\n2. 情况 2：对所有 $x$，有 $f(x) = 1$；当 $|x - 0.5|  0.2$ 时 $\\psi(x) = 0.15$，否则 $\\psi(x) = 0$。\n3. 情况 3：对所有 $x$，有 $f(x) = 1$；$\\psi$ 等于无约束问题 $A u^* = f$ 的离散解 $u^*$，即 $\\psi_i = u^*_i$，$i = 1, 2, \\dots, n$。\n\n要求的最终输出格式为单行，其中包含一个用方括号括起来的逗号分隔列表，列表中的条目按测试用例索引排序，每个元素等于该用例的 Fischer–Burmeister 残差的无穷范数。例如，输出应如下所示\n$$\n[\\rho_1,\\rho_2,\\rho_3]\n$$\n其中每个 $\\rho_i$ 都是一个浮点数。不涉及物理单位，所有数值均为无量纲。未使用角度。\n\n您的程序必须是自包含的、确定性的，并且不得需要任何用户输入。它应使用指定的运行时环境和库，并且必须仅以所描述的精确格式打印最后一行。",
            "solution": "用户提供了有效的问题陈述。该问题在数值分析和优化领域有坚实的科学基础，特别是关于变分不等式的求解。它适定、客观，并包含构建唯一、可验证解所需的所有必要信息。\n\n该问题要求实现一种半光滑牛顿法来求解一维障碍问题。求解过程分为三个主要阶段：连续问题的离散化，重构为非线性方程组，以及通过广义牛顿法进行迭代求解。\n\n连续障碍问题定义在区间 $[0,1]$上，涉及标量场 $u(x)$、障碍 $\\psi(x)$、源项 $f(x)$ 以及齐次 Dirichlet 边界条件 $u(0)=u(1)=0$。问题是找到一个函数 $u(x)$，它在所有 $x \\in [0,1]$上满足 $u(x) \\ge \\psi(x)$，并在容许函数集上最小化能量泛函 $E(v) = \\frac{1}{2} \\int_0^1 |\\nabla v|^2 \\, dx - \\int_0^1 f v \\, dx$。一阶最优性条件是变分不等式：\n$$\n\\int_0^1 \\nabla u \\cdot \\nabla (v - u) \\, dx \\ge \\int_0^1 f(x) (v - u) \\, dx\n$$\n对于所有满足 $v(x) \\ge \\psi(x)$ 的容许变分 $v$。\n\n第一步是离散化问题。区间 $[0,1]$ 被划分为一个具有 $n$ 个内部点 $x_i = ih$ ($i=1, \\dots, n$) 的均匀网格，其中网格步长为 $h = 1/(n+1)$。函数 $u(x)$ 由一个向量 $u \\in \\mathbb{R}^n$ 近似，其分量为 $u_i \\approx u(x_i)$。微分算子 $-u''$ 使用二阶中心有限差分格式进行近似：\n$$\n-u''(x_i) \\approx \\frac{-u(x_{i-1}) + 2u(x_i) - u(x_{i+1})}{h^2}\n$$\n这导致了无约束问题（其中 $\\psi = -\\infty$）的线性系统 $Au \\approx f$。矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是离散拉普拉斯算子，它是一个稀疏、对称、正定且三对角的矩阵，其元素为 $A_{ii} = 2/h^2$ 和 $A_{i,i+1} = A_{i,i-1} = -1/h^2$。向量 $f$ 和 $\\psi$ 是连续函数的离散化，有 $f_i = f(x_i)$ 和 $\\psi_i = \\psi(x_i)$。\n\n离散化的变分不等式变成一个非线性互补问题 (NCP)。设 $F(u) = Au - f$。NCP 是寻找一个向量 $u \\in \\mathbb{R}^n$，使得对每个分量 $i=1, \\dots, n$ 以下三个条件都成立：\n1. $u_i - \\psi_i \\ge 0$ (解位于障碍物之上)\n2. $(Au - f)_i \\ge 0$ (与保持解在障碍物上方的力的符号有关)\n3. $(u_i - \\psi_i) (Au - f)_i = 0$ (互补性：解要么在障碍物上，要么作用力为零)\n\n这些条件可以紧凑地写成 $0 \\le u - \\psi \\perp Au - f \\ge 0$。\n\n为求解此 NCP，我们使用 Fischer–Burmeister 函数 $\\phi: \\mathbb{R}^2 \\to \\mathbb{R}$ 将其重构为一个非线性方程组，该函数定义为：\n$$\n\\phi(a, b) = \\sqrt{a^2 + b^2} - a - b\n$$\n该函数有一个关键性质，即 $\\phi(a,b) = 0$ 当且仅当 $a \\ge 0$，$b \\ge 0$ 且 $ab = 0$。通过设 $a_i = u_i - \\psi_i$ 和 $b_i = (Au - f)_i$，NCP 等价于求解非线性方程组 $g(u) = 0$，其中 $g$ 的分量由下式给出：\n$$\ng_i(u) = \\phi(u_i - \\psi_i, (Au - f)_i) = 0 \\quad \\text{for } i = 1, \\dots, n\n$$\n函数 $g(u)$ 处处连续，但在 $u_i - \\psi_i = 0$ 和 $(Au-f)_i = 0$ 同时成立时不可微。然而，它是半光滑的，这允许使用一种广义牛顿法，即所谓的半光滑牛顿法。\n\n半光滑牛顿法通过在每次迭代 $k$ 中求解线性系统 $J(u_k) \\delta u_k = -g(u_k)$ 来生成一系列迭代 $u_{k+1} = u_k + \\delta u_k$。这里，$J(u_k)$ 是 $g$ 在 $u_k$ 处的广义雅可比矩阵（或 B-次微分）的一个元素。\n\n为了构造 $J(u)$，我们需要 $\\phi(a,b)$ 的一个广义导数。对于 $(a,b) \\neq (0,0)$，$\\phi$ 是可微的，其梯度为 $\\nabla \\phi(a,b) = (\\alpha, \\beta)$，其中 $\\alpha = \\frac{a}{\\sqrt{a^2+b^2}} - 1$ 且 $\\beta = \\frac{b}{\\sqrt{a^2+b^2}} - 1$。在 $(a,b) = (0,0)$ 处，我们可以从 Clarke 次微分中选择任何元素。问题指定了一种实用方法：对于一个小的容差 $\\varepsilon  0$，我们定义 $a_i = u_i - \\psi_i$，$b_i = (Au-f)_i$ 和 $r_i = \\sqrt{a_i^2+b_i^2}$。广义导数 $(\\alpha_i, \\beta_i)$ 按如下方式选择：\n- 如果 $r_i  \\varepsilon$: $(\\alpha_i, \\beta_i) = \\left( \\frac{a_i}{r_i} - 1, \\frac{b_i}{r_i} - 1 \\right)$\n- 如果 $r_i \\le \\varepsilon$: $(\\alpha_i, \\beta_i) = \\left( \\frac{1}{\\sqrt{2}} - 1, \\frac{1}{\\sqrt{2}} - 1 \\right)$，这是一个来自次微分的对称元素。\n\n根据链式法则，$J(u)$ 的第 $i$ 行由 $\\alpha_i \\nabla_u a_i + \\beta_i \\nabla_u b_i$ 给出。由于 $\\nabla_u a_i = e_i^T$（第 $i$ 个标准基向量）且 $\\nabla_u b_i = A_{i,:}$（$A$ 的第 $i$ 行），矩阵 $J(u)$ 具有以下形式：\n$$\nJ(u) = \\mathrm{diag}(\\alpha) + \\mathrm{diag}(\\beta) A\n$$\n其中 $\\mathrm{diag}(\\alpha)$ 和 $\\mathrm{diag}(\\beta)$ 分别是以 $\\alpha_i$ 和 $\\beta_i$ 为元素的对角矩阵。\n\n算法如下：\n1. 初始化一个估计值 $u_0$，例如 $u_0 = \\psi$。\n2. 对于 $k=0, 1, 2, \\dots$，直到达到最大迭代次数：\n    a. 计算 $a = u_k - \\psi$ 和 $b = A u_k - f$。\n    b. 计算残差向量 $g(u_k)$，其中 $g_i = \\sqrt{a_i^2 + b_i^2} - a_i - b_i$。\n    c. 检查收敛性：如果无穷范数 $\\|g(u_k)\\|_{\\infty}$ 低于某个容差，则停止。\n    d. 根据上述规则逐分量计算向量 $\\alpha$ 和 $\\beta$。\n    e. 构建广义雅可比矩阵 $J(u_k) = \\mathrm{diag}(\\alpha) + \\mathrm{diag}(\\beta) A$。\n    f. 求解稀疏线性系统 $J(u_k) \\delta u_k = -g(u_k)$ 以获得牛顿步长 $\\delta u_k$。\n    g. 更新解：$u_{k+1} = u_k + \\delta u_k$。\n3. 循环终止后，报告 $\\|g(u)\\|_{\\infty}$ 的最终值。该值量化了计算出的解 $u$ 满足互补条件的程度。\n\n在实现中，我们对 $A$ 和 $J(u)$ 使用稀疏矩阵表示，以高效处理 $n=64$ 的问题规模。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags as sp_diags\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to solve the obstacle problem for the three specified test cases.\n    \"\"\"\n\n    def solve_obstacle_problem(n, f_vec, psi_vec):\n        \"\"\"\n        Solves a single instance of the discretized 1D obstacle problem using\n        a semismooth Newton method based on the Fischer-Burmeister function.\n\n        Args:\n            n (int): The number of interior grid points.\n            f_vec (np.ndarray): The discretized source term vector.\n            psi_vec (np.ndarray): The discretized obstacle vector.\n\n        Returns:\n            float: The infinity norm of the Fischer-Burmeister residual at the solution.\n        \"\"\"\n        h = 1.0 / (n + 1)\n        \n        # Construct the discrete Laplacian matrix A\n        main_diag = np.full(n, 2.0 / h**2)\n        off_diag = np.full(n - 1, -1.0 / h**2)\n        A = sp_diags([off_diag, main_diag, off_diag], [-1, 0, 1], format='csr')\n\n        # Semismooth Newton Method parameters\n        u = np.copy(psi_vec)  # Initial guess\n        \n        eps = 1e-14\n        tol = 1e-12\n        max_iter = 50\n\n        g = np.zeros(n)\n        for _ in range(max_iter):\n            a = u - psi_vec\n            b = A @ u - f_vec\n\n            # Fischer-Burmeister residual g(u)\n            r = np.sqrt(a**2 + b**2)\n            g = r - a - b\n            \n            residual_norm = np.linalg.norm(g, np.inf)\n            if residual_norm  tol:\n                break\n                \n            # Generalized derivatives alpha and beta\n            alpha = np.zeros(n)\n            beta = np.zeros(n)\n\n            # Mask for r > eps (differentiable case)\n            mask_large_r = r > eps\n            # Avoid division by zero, although r[mask_large_r] should be safe\n            r_safe = r[mask_large_r]\n            alpha[mask_large_r] = a[mask_large_r] / r_safe - 1.0\n            beta[mask_large_r] = b[mask_large_r] / r_safe - 1.0\n            \n            # Mask for r = eps (non-differentiable case)\n            mask_small_r = ~mask_large_r\n            val_small_r = 1.0 / np.sqrt(2.0) - 1.0\n            alpha[mask_small_r] = val_small_r\n            beta[mask_small_r] = val_small_r\n\n            # Construct generalized Jacobian J = diag(alpha) + diag(beta) * A\n            J = sp_diags(alpha, 0, format='csr') + sp_diags(beta, 0, format='csr') @ A\n\n            # Solve the Newton linear system J * delta_u = -g\n            # A full Newton step is taken as no globalization is specified.\n            try:\n                delta_u = spsolve(J, -g)\n            except: # If solver fails, break\n                break\n\n\n            # Update solution\n            u += delta_u\n            \n        # Recalculate final residual for accurate reporting\n        a_final = u - psi_vec\n        b_final = A @ u - f_vec\n        r_final = np.sqrt(a_final**2 + b_final**2)\n        g_final = r_final - a_final - b_final\n        final_residual = np.linalg.norm(g_final, np.inf)\n        \n        return final_residual\n\n    n = 64\n    h = 1.0 / (n + 1)\n    x = np.linspace(h, 1.0 - h, n)\n    \n    # Define the test cases\n    test_cases = []\n\n    # Case 1: f(x) = 1, psi(x) = 0\n    f1 = np.ones(n)\n    psi1 = np.zeros(n)\n    test_cases.append((n, f1, psi1))\n\n    # Case 2: f(x) = 1, psi(x) is a bump\n    f2 = np.ones(n)\n    psi2 = np.zeros(n)\n    psi2[np.abs(x - 0.5)  0.2] = 0.15\n    test_cases.append((n, f2, psi2))\n\n    # Case 3: f(x) = 1, psi = unconstrained solution\n    f3 = np.ones(n)\n    main_diag_3 = np.full(n, 2.0 / h**2)\n    off_diag_3 = np.full(n - 1, -1.0 / h**2)\n    A3 = sp_diags([off_diag_3, main_diag_3, off_diag_3], [-1, 0, 1], format='csr')\n    psi3 = spsolve(A3, f3)\n    test_cases.append((n, f3, psi3))\n\n    # Run all test cases\n    results = []\n    for case_params in test_cases:\n        res = solve_obstacle_problem(*case_params)\n        results.append(res)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}