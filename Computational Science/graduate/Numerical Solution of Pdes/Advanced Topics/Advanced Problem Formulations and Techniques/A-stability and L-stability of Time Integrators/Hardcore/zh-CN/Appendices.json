{
    "hands_on_practices": [
        {
            "introduction": "掌握时间积分器的稳定性需要从第一性原理出发进行分析。本练习将引导你使用基本的根轨迹法来分析广泛使用的二阶向后差分格式 (BDF2) 。通过推导其稳定性边界，你将深刻地、从解析层面理解为何 BDF2 是 A-稳定的并具有刚性衰减特性，这些都是求解刚性微分方程的关键性质。",
            "id": "3360314",
            "problem": "考虑将二阶两步后向差分格式 (BDF2) 应用于线性测试方程 $u^{\\prime}(t)=\\lambda u(t)$，其中 $\\lambda \\in \\mathbb{C}$，$z=h\\lambda$，$h0$ 为时间步长。使用作用于离散序列 $\\{u_n\\}$ 上的多项式 $\\rho(\\xi)$ 和 $\\sigma(\\xi)$ 的 $k$ 步隐式线性多步法的标准形式，以及 von Neumann ansatz $u_n=\\xi^n$，完成以下任务：\n\n1) 从 BDF2 格式 $(3u_{n+2}-4u_{n+1}+u_n)/(2h)=f(t_{n+2},u_{n+2})$ 出发，推导放大因子 $\\xi$ 的特征方程，其形式为 $a(z)\\,\\xi^{2}+b\\,\\xi+c=0$，其中系数仅用 $z$ 表示。然后通过消去分母将其变换为关于z的首一仿射形式。\n\n2) 应用根轨迹法，通过 $|\\xi|=1$ 参数化稳定性边界，即令 $\\xi=\\exp(i\\theta)$，其中 $\\theta \\in [-\\pi,\\pi]$，并在复 $z$-平面上推导稳定性区域边界曲线的显式闭式参数表达式 $z(\\theta)$。\n\n3) 仅使用第一性原理以及映射 $\\xi \\mapsto z=\\rho(\\xi)/\\sigma(\\xi)$ 在 $|\\xi|=1$ 上的性质，判断 BDF2 方法是否为 A-稳定（即其稳定性区域包含整个左半复平面 $\\{z\\in\\mathbb{C}:\\operatorname{Re}(z)\\le 0\\}$）。通过分析 $\\operatorname{Re}(z(\\theta))$ 和特征多项式根的连续性来证明你的结论。\n\n4) 通过分析沿负实轴 $z\\to -\\infty$ 的极限来研究刚性衰减。确定特征多项式根 $\\xi_j(z)$ 的极限行为，并判断是否满足刚性衰减，即当 $z\\to -\\infty$ 时放大因子趋于零。将你的结论表示为当 $z\\to -\\infty$ 时 $\\max_j|\\xi_j(z)|$ 的极限值。\n\n你的最终答案必须是一个单行矩阵，其中第一项为第 2 部分得到的参数边界 $z(\\theta)$ 的单个闭式解析表达式，第二项为第 4 部分得到的极限值。不需要四舍五入，也不涉及物理单位。角度必须以弧度为单位。",
            "solution": "用户提供了一个关于两步后向差分格式 (BDF2) 分析的问题陈述。验证和求解过程将根据指定规则进行。\n\n### 步骤 1：提取已知条件\n- **测试方程：** $u^{\\prime}(t)=\\lambda u(t)$，其中 $\\lambda \\in \\mathbb{C}$。\n- **时间步长和参数：** $h0$ 是时间步长，$z=h\\lambda$。\n- **方法：** 二阶两步后向差分格式 (BDF2)，由格式 $(3u_{n+2}-4u_{n+1}+u_n)/(2h)=f(t_{n+2},u_{n+2})$ 给出。\n- **假设：** von Neumann ansatz $u_n=\\xi^n$。\n- **任务 1：** 推导 $\\xi$ 的特征方程，形式为 $a(z)\\,\\xi^{2}+b\\,\\xi+c=0$，然后将其表示为分离出 $z$ 的形式。\n- **任务 2：** 应用根轨迹法，通过令 $\\xi=\\exp(i\\theta)$ 来找到稳定性区域边界的参数表达式 $z(\\theta)$。\n- **任务 3：** 通过分析稳定性边界 $z(\\theta)$ 的性质，判断 BDF2 方法是否为 A-稳定。\n- **任务 4：** 通过分析沿负实轴 $z \\to -\\infty$ 时根 $\\xi_j(z)$ 的极限，研究刚性衰减，并找到 $\\max_j|\\xi_j(z)|$ 的极限值。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据指定标准对问题进行验证。\n- **科学性：** 该问题是常微分方程数值分析中的一个标准练习。所有概念，包括 BDF2 方法、线性测试方程、A-稳定性、刚性衰减和根轨迹法，都是该领域公认的原理。该问题在科学上是合理的。\n- **适定性：** 该问题是适定的。它清晰地定义了数值方法和测试方程，任务具体，并能导出一个唯一的、有意义的解。\n- **客观性：** 该问题以精确、客观的数学语言陈述，没有任何主观或偏颇的措辞。\n- **完整性和一致性：** 该问题是自洽的，提供了所有必要信息。在给定的数据或任务中没有矛盾。\n- **其他标准：** 该问题是可形式化的，与时间积分子的稳定性主题相关，在数值分析的背景下是现实的，结构良好，并非无足轻重，并且是科学可验证的。\n\n### 步骤 3：结论与行动\n该问题有效。将提供一个完整的、有理有据的解答。\n\n### 解答\n\n**1) 特征方程的推导**\n\nBDF2 方法由以下公式给出：\n$$\n\\frac{3u_{n+2}-4u_{n+1}+u_n}{2h} = f(t_{n+2}, u_{n+2})\n$$\n我们将此方法应用于线性测试方程 $u'(t) = \\lambda u(t)$，因此 $f(t_{n+2}, u_{n+2}) = \\lambda u_{n+2}$。该格式变为：\n$$\n\\frac{3u_{n+2}-4u_{n+1}+u_n}{2h} = \\lambda u_{n+2}\n$$\n两边乘以 $2h$ 并引入复数 $z = h\\lambda$，我们得到：\n$$\n3u_{n+2}-4u_{n+1}+u_n = 2z u_{n+2}\n$$\n重新整理各项，将序列元素 $\\{u_k\\}$ 组合在一起，得到：\n$$\n(3-2z)u_{n+2} - 4u_{n+1} + u_n = 0\n$$\n为了找到放大因子 $\\xi$ 的特征方程，我们代入 von Neumann ansatz $u_n = \\xi^n$。这得到 $u_{n+1} = \\xi^{n+1}$ 和 $u_{n+2} = \\xi^{n+2}$。代入方程得到：\n$$\n(3-2z)\\xi^{n+2} - 4\\xi^{n+1} + \\xi^n = 0\n$$\n假设 $\\xi \\neq 0$，我们可以将整个方程除以 $\\xi^n$：\n$$\n(3-2z)\\xi^2 - 4\\xi + 1 = 0\n$$\n这就是所需形式 $a(z)\\xi^2 + b\\xi + c = 0$ 的特征方程，其中系数为 $a(z) = 3-2z$，$b = -4$，$c = 1$。\n\n在线性多步法的标准理论中，该方程源于 $\\rho(\\xi) - z\\sigma(\\xi) = 0$。通过观察，特征多项式为 $\\rho(\\xi) = \\frac{3}{2}\\xi^2 - 2\\xi + \\frac{1}{2}$ 和 $\\sigma(\\xi) = \\xi^2$。求解 $z$ 得到关系式：\n$$\nz = \\frac{\\rho(\\xi)}{\\sigma(\\xi)} = \\frac{\\frac{3}{2}\\xi^2 - 2\\xi + \\frac{1}{2}}{\\xi^2} = \\frac{3}{2} - 2\\xi^{-1} + \\frac{1}{2}\\xi^{-2}\n$$\n\n**2) 稳定性边界的推导**\n\n绝对稳定区域的边界由特征多项式的根 $\\xi$ 位于单位圆上（即 $|\\xi|=1$）时的 $z$ 值所描绘。这就是根轨迹法。我们通过 $\\xi = \\exp(i\\theta)$（其中 $\\theta \\in [-\\pi, \\pi]$）来参数化单位圆。将此代入 $z$ 的表达式，得到边界曲线 $z(\\theta)$ 的参数方程：\n$$\nz(\\theta) = \\frac{\\rho(\\exp(i\\theta))}{\\sigma(\\exp(i\\theta))} = \\frac{\\frac{3}{2}\\exp(i2\\theta) - 2\\exp(i\\theta) + \\frac{1}{2}}{\\exp(i2\\theta)}\n$$\n简化此表达式可得到闭式参数方程：\n$$\nz(\\theta) = \\frac{3}{2} - 2\\exp(-i\\theta) + \\frac{1}{2}\\exp(-i2\\theta)\n$$\n\n**3) A-稳定性分析**\n\n如果一个数值方法的绝对稳定区域包含整个左半复平面 $\\{z \\in \\mathbb{C} : \\operatorname{Re}(z) \\le 0\\}$，则该方法是 A-稳定的。\n为验证这一点，我们分析稳定性边界 $z(\\theta)$ 的实部。使用 $\\exp(-i\\phi) = \\cos(\\phi) - i\\sin(\\phi)$，我们将 $z(\\theta)$分解为实部和虚部：\n$$\nz(\\theta) = \\frac{3}{2} - 2(\\cos(\\theta)-i\\sin(\\theta)) + \\frac{1}{2}(\\cos(2\\theta)-i\\sin(2\\theta))\n$$\n$$\n\\operatorname{Re}(z(\\theta)) = \\frac{3}{2} - 2\\cos(\\theta) + \\frac{1}{2}\\cos(2\\theta)\n$$\n使用倍角公式 $\\cos(2\\theta) = 2\\cos^2(\\theta) - 1$：\n$$\n\\operatorname{Re}(z(\\theta)) = \\frac{3}{2} - 2\\cos(\\theta) + \\frac{1}{2}(2\\cos^2(\\theta) - 1) = \\frac{3}{2} - 2\\cos(\\theta) + \\cos^2(\\theta) - \\frac{1}{2} = \\cos^2(\\theta) - 2\\cos(\\theta) + 1\n$$\n这个表达式是一个完全平方：\n$$\n\\operatorname{Re}(z(\\theta)) = (1 - \\cos(\\theta))^2\n$$\n由于 $\\cos(\\theta)$ 是一个实数，对于所有 $\\theta \\in [-\\pi, \\pi]$，都有 $(1 - \\cos(\\theta))^2 \\ge 0$。等式 $\\operatorname{Re}(z(\\theta))=0$ 仅在 $\\cos(\\theta)=1$ 时成立，即 $\\theta=0$。此时，$z(0) = (1-1)^2 = 0$。这意味着稳定性边界完全位于闭合的右半平面，并且仅在原点处与虚轴相切。\n\n接下来，我们必须确定稳定性区域是该边界曲线的内部还是外部。我们通过考虑沿负实轴 $z \\to -\\infty$ 的极限来测试左半平面的一个点。特征方程为 $(3-2z)\\xi^2 - 4\\xi + 1 = 0$。两边除以 $z$ 得到：\n$$\n\\left(\\frac{3}{z} - 2\\right)\\xi^2 - \\frac{4}{z}\\xi + \\frac{1}{z} = 0\n$$\n当 $z \\to -\\infty$ 时，方程趋近于 $-2\\xi^2 = 0$，其根为 $\\xi_1 = \\xi_2 = 0$。由于这些根位于单位圆盘内部（即 $|\\xi_j|1$），因此负实轴上远离原点的点位于稳定性区域内。\n边界曲线是右半平面内的一条简单闭合曲线。由于左半平面的一个点在稳定性区域内，因此该边界曲线的整个外部必为稳定区域。因为边界完全位于右半平面（在 $z=0$ 处相切），其外部必然包含整个开放的左半平面。左半平面的边界（虚轴）也包含在稳定区域内。因此，BDF2 方法是 A-稳定的。\n\n**4) 刚性衰减分析**\n\n刚性衰减要求放大因子 $\\xi_j(z)$ 在 $\\operatorname{Re}(z) \\to -\\infty$ 时趋于零。我们沿负实轴分析 $z \\to -\\infty$ 的情况。我们使用二次公式求解特征方程 $(3 - 2z)\\xi^2 - 4\\xi + 1 = 0$ 的根：\n$$\n\\xi_{1,2}(z) = \\frac{-(-4) \\pm \\sqrt{(-4)^2 - 4(3-2z)(1)}}{2(3-2z)} = \\frac{4 \\pm \\sqrt{16-12+8z}}{2(3-2z)} = \\frac{4 \\pm \\sqrt{4+8z}}{2(3-2z)} = \\frac{2 \\pm \\sqrt{1+2z}}{3-2z}\n$$\n为了计算 $z \\to -\\infty$ 时的极限，我们令 $z=-R$，其中 $R$ 是一个大的正实数。\n$$\n\\xi_{1,2}(-R) = \\frac{2 \\pm \\sqrt{1-2R}}{3+2R} = \\frac{2 \\pm i\\sqrt{2R-1}}{3+2R}\n$$\n我们考察这些根的模：\n$$\n|\\xi_{1,2}(-R)| = \\frac{|2 \\pm i\\sqrt{2R-1}|}{|3+2R|} = \\frac{\\sqrt{2^2 + (\\sqrt{2R-1})^2}}{3+2R} = \\frac{\\sqrt{4 + 2R - 1}}{3+2R} = \\frac{\\sqrt{3+2R}}{3+2R} = \\frac{1}{\\sqrt{3+2R}}\n$$\n当 $z \\to -\\infty$（对应于 $R \\to \\infty$）时，两个根的模都趋于零：\n$$\n\\lim_{z \\to -\\infty} \\max_{j=1,2} |\\xi_j(z)| = \\lim_{R \\to \\infty} \\frac{1}{\\sqrt{3+2R}} = 0\n$$\n这表明 BDF2 方法具有刚性衰减特性。放大因子最大模的极限值为 $0$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{3}{2} - 2\\exp(-i\\theta) + \\frac{1}{2}\\exp(-i2\\theta)  0 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "像 L-稳定性这样的理论性质在数值模拟中会产生非常真实和实际的影响。本练习通过在一个刚性对流扩散问题上对比 L-稳定的后向欧拉法和仅为 A-稳定的 Crank-Nicolson 格式，生动地展示了这一点 。你将通过一个基于傅里叶方法的实现，直接观察和量化因缺乏 L-稳定性而产生的非物理振荡，从而巩固你关于为何此性质对处理陡峭梯度或不连续性问题至关重要的直觉。",
            "id": "3360288",
            "problem": "考虑周期域上的一维线性对流扩散偏微分方程 (PDE)，\n$$\nu_t(x,t) + b\\,u_x(x,t) = \\kappa\\,u_{xx}(x,t),\n$$\n对于 $x \\in [0,L]$，周期为 $L$，常数对流速度 $b \\in \\mathbb{R}$，以及扩散系数 $\\kappa  0$。假设在具有 $N$ 个点的均匀网格上进行空间半离散化，网格间距为 $h = L/N$，采用周期性边界条件，并对空间算子使用以下标准的二阶中心差分：\n- 对于一阶导数，使用 $(u_{j+1} - u_{j-1})/(2h)$，其离散傅里叶符号为 $i\\,\\sin(\\theta)/h$。\n- 对于二阶导数，使用 $(u_{j+1} - 2u_j + u_{j-1})/h^2$，其离散傅里叶符号为 $-4\\,\\sin^2(\\theta/2)/h^2$。\n这里，$\\theta = 2\\pi m/N$，其中傅里叶模态指数 $m \\in \\{0,1,\\dots,N-1\\}$。\n\n因此，半离散系统可以写为 $\\partial_t u = \\mathcal{L} u$，其中 $\\mathcal{L}$ 是离散线性空间算子，其对与 $\\theta$ 对应的离散傅里叶模态的作用具有特征值\n$$\n\\lambda(\\theta) = -i\\,b\\,\\frac{\\sin(\\theta)}{h} - \\kappa\\,\\frac{4\\sin^2(\\theta/2)}{h^2}.\n$$\n\n将对比两种隐式时间积分器：\n1. 后向欧拉法（隐式欧拉法），定义为 $(I - \\Delta t\\,\\mathcal{L})\\,u^{n+1} = u^{n}$。\n2. Crank–Nicolson 方法，定义为 $\\left(I - \\frac{\\Delta t}{2}\\,\\mathcal{L}\\right) u^{n+1} = \\left(I + \\frac{\\Delta t}{2}\\,\\mathcal{L}\\right) u^{n}$。\n\n从广泛使用的线性测试方程 $y'(t) = \\lambda\\,y(t)$ 和上述格式的定义出发，推导后向欧拉法和 Crank–Nicolson 方法对应的标量稳定性函数 $R(z)$，其中 $z = \\Delta t\\,\\lambda$。然后，利用上面指定的 $\\lambda(\\theta)$ 的离散傅里叶符号，为每个格式设计一个单步傅里叶空间传播子，使得 $\\widehat{u}^{n+1}(\\theta) = R\\!\\left(\\Delta t\\,\\lambda(\\theta)\\right)\\,\\widehat{u}^{n}(\\theta)$，其中 $\\widehat{u}$ 表示 $u$ 的离散傅里叶变换。\n\n使用从 $t=0$ 到 $t=\\Delta t$ 的单步更新，如下定义振荡的度量：\n- 考虑初始条件\n$$\nu(x,0) = \n\\begin{cases}\n1,  0 \\le x  L/2, \\\\\n0,  L/2 \\le x  L,\n\\end{cases}\n$$\n在周期性网格上进行解释。这是一个不连续的阶跃函数，它会激发广泛的傅里叶模态谱，包括最刚性的高频分量。\n- 对于每种格式（后向欧拉法和 Crank–Nicolson 方法），通过傅里叶空间单步更新计算 $u(x,\\Delta t)$。\n- 将一个格式的下冲幅度定义为 $u(x,\\Delta t)$ 的最小值，它量化了产生低于 $0$ 的值的振荡。将一个格式的上冲幅度定义为 $\\max\\{u(x,\\Delta t)-1,\\,0\\}$，它量化了高于 $1$ 的值。\n\n此外，为了将振荡与非 $L$-稳定性联系起来，使用在奈奎斯特模态 $\\theta_{\\mathrm{nyq}} = \\pi$（即 $m = N/2$）下评估的稳定性函数的模来量化高频刚性模态的放大，即\n$$\nG_{\\mathrm{nyq}}^{\\mathrm{scheme}} = \\left|R\\big(\\Delta t\\,\\lambda(\\pi)\\big)\\right|.\n$$\n回想一下，对于 $L$-稳定性（刚性衰减），要求 $R(\\infty) = 0$，这意味着无限刚性的模态被完全阻尼；否则，非零的 $R(\\infty)$ 意味着持续的（或交变符号的）高频分量，表现为振荡。\n\n你的任务是：\n- 从应用于 $y'=\\lambda y$ 的格式定义中推导后向欧拉法和 Crank–Nicolson 方法的稳定性函数 $R(z)$。\n- 使用给定的离散符号构建单步傅里叶空间传播子。\n- 实现一个完整的程序，该程序：\n  1. 设置 $L = 2\\pi$，$N = 256$，并在网格上构建阶跃函数初始条件。\n  2. 对于每个指定的测试案例，通过将傅里叶系数与 $R\\!\\left(\\Delta t\\,\\lambda(\\theta)\\right)$ 相乘并变换回物理空间，为两种格式计算单步更新。\n  3. 测量如上定义的下冲和上冲幅度。\n  4. 为两种格式计算 $G_{\\mathrm{nyq}}^{\\mathrm{scheme}}$。\n  5. 对于每个测试案例，按以下顺序输出一个包含六个浮点数的列表\n     $$\n     \\big[\\min(u_{\\mathrm{CN}}),\\,\\min(u_{\\mathrm{BE}}),\\,\\max\\{u_{\\mathrm{CN}}-1,0\\},\\,\\max\\{u_{\\mathrm{BE}}-1,0\\},\\,G_{\\mathrm{nyq}}^{\\mathrm{CN}},\\,G_{\\mathrm{nyq}}^{\\mathrm{BE}}\\big],\n     $$\n\n所有量都是无量纲的；不需要物理单位。\n\n测试套件：\n- 案例 1（刚性扩散，无对流）：$b = 0.0$，$\\kappa = 100.0$，$\\Delta t = 0.5$。\n- 案例 2（带对流的刚性扩散）：$b = 3.0$，$\\kappa = 100.0$，$\\Delta t = 0.5$。\n- 案例 3（中等扩散性，小时间步长）：$b = 0.0$，$\\kappa = 1.0$，$\\Delta t = 10^{-4}$。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是针对一个测试案例的六元素列表，不含空格。例如：\n$$\n[\\,[a_1,b_1,c_1,d_1,e_1,f_1],[a_2,b_2,c_2,d_2,e_2,f_2],[a_3,b_3,c_3,d_3,e_3,f_3]\\,].\n$$",
            "solution": "问题陈述是偏微分方程数值分析中一个适定且有科学依据的练习。它涉及两种常见的时间积分格式——后向欧拉法和 Crank-Nicolson 方法——在应用于半离散化对流扩散方程时的稳定性和振荡性质。所有定义、参数和目标都陈述清晰，并与该领域的标准理论一致。因此，该问题是有效的。\n\n解决方案主要分为两部分：首先，对必要组件（稳定性函数和传播子）进行理论推导；其次，描述为计算所需指标而进行的数值实现。\n\n**1. 稳定性函数和传播子的推导**\n\n为了分析时间积分格式的稳定性，我们将其应用于线性测试方程 $y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$ 是一个满足 $\\text{Re}(\\lambda) \\le 0$ 的复数。数值格式的单步将解从时间 $t_n$ 更新到 $t_{n+1} = t_n + \\Delta t$，形式为 $y^{n+1} = R(z) y^n$，其中 $z = \\lambda \\Delta t$。函数 $R(z)$ 是该格式的标量稳定性函数。\n\n**1.1. 后向欧拉法 (BE)**\n后向欧拉格式由以下隐式关系定义：\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} = \\mathcal{L} u^{n+1}\n$$\n将其应用于测试方程，其中 $\\mathcal{L}$ 对应于乘以 $\\lambda$：\n$$\ny^{n+1} - y^n = \\Delta t \\lambda y^{n+1}\n$$\n求解 $y^{n+1}$：\n$$\ny^{n+1} (1 - \\Delta t \\lambda) = y^n\n$$\n$$\ny^{n+1} = \\frac{1}{1 - \\Delta t \\lambda} y^n\n$$\n因此，后向欧拉法的稳定性函数为：\n$$\nR_{\\mathrm{BE}}(z) = \\frac{1}{1-z}\n$$\n\n**1.2. Crank-Nicolson (CN)**\nCrank-Nicolson 格式由以下隐式关系定义：\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} = \\frac{1}{2} (\\mathcal{L} u^n + \\mathcal{L} u^{n+1})\n$$\n将其应用于测试方程：\n$$\ny^{n+1} - y^n = \\frac{\\Delta t}{2} (\\lambda y^n + \\lambda y^{n+1})\n$$\n求解 $y^{n+1}$：\n$$\ny^{n+1} \\left(1 - \\frac{\\Delta t \\lambda}{2}\\right) = y^n \\left(1 + \\frac{\\Delta t \\lambda}{2}\\right)\n$$\n$$\ny^{n+1} = \\frac{1 + \\Delta t \\lambda / 2}{1 - \\Delta t \\lambda / 2} y^n\n$$\n因此，Crank-Nicolson 方法的稳定性函数为：\n$$\nR_{\\mathrm{CN}}(z) = \\frac{1 + z/2}{1 - z/2}\n$$\n\n**1.3. L-稳定性与振荡的联系**\n如果对于所有满足 $\\text{Re}(z) \\le 0$ 的 $z$，都有 $|R(z)| \\le 1$，则称格式是 $A$-稳定的。如果一个格式是 $A$-稳定的，并且额外满足当 $\\text{Re}(z) \\le 0$ 时 $\\lim_{|z| \\to \\infty} |R(z)| = 0$，则称其为 $L$-稳定的。后一个条件对于阻尼无限刚性的模态至关重要，这些模态对应于高频空间分量，如不连续点。\n- 对于后向欧拉法：$\\lim_{|z| \\to \\infty} |R_{\\mathrm{BE}}(z)| = \\lim_{|z| \\to \\infty} \\left|\\frac{1}{1-z}\\right| = 0$。后向欧拉法是 $L$-稳定的。它能有效地阻尼刚性分量。\n- 对于 Crank-Nicolson 方法：$\\lim_{|z| \\to \\infty} |R_{\\mathrm{CN}}(z)| = \\lim_{|z| \\to \\infty} \\left|\\frac{1+z/2}{1-z/2}\\right| = \\lim_{|z| \\to \\infty} \\left|\\frac{1/z+1/2}{1/z-1/2}\\right| = \\left|\\frac{1/2}{-1/2}\\right| = 1$。Crank-Nicolson 方法是 $A$-稳定的，但不是 $L$-稳定的。它未能阻尼刚性分量，这可能在数值解中表现为持续的、非物理的振荡，尤其是在陡峭梯度附近。\n\n**1.4. 傅里叶空间传播子**\n半离散系统 $\\partial_t u = \\mathcal{L}u$ 是一个关于网格点值 $u_j(t)$ 的耦合常微分方程组 (ODEs)。通过应用离散傅里叶变换 (DFT)，该系统被对角化。每个傅里叶模态 $\\widehat{u}(\\theta)$ 根据以下 ODE 独立演化：\n$$\n\\frac{d}{dt}\\widehat{u}(\\theta, t) = \\lambda(\\theta)\\,\\widehat{u}(\\theta, t)\n$$\n其中 $\\lambda(\\theta)$ 是算子 $\\mathcal{L}$ 对于与 $\\theta = 2\\pi m/N$ 对应的模态的特征值。这是标量测试方程的一个实例。因此，从 $t_n$ 到 $t_{n+1}$ 的单个时间步按如下方式更新每个傅里叶系数：\n$$\n\\widehat{u}^{n+1}(\\theta) = R(\\Delta t\\,\\lambda(\\theta))\\,\\widehat{u}^{n}(\\theta)\n$$\n单步傅里叶传播子是所有离散模态 $\\theta$ 的值 $R(\\Delta t\\,\\lambda(\\theta))$ 构成的数组。\n\n**2. 数值实现和指标**\n\n解决该问题的算法如下：\n1.  设置物理和数值参数：$L=2\\pi$，$N=256$。由此计算网格间距 $h=L/N$。\n2.  定义空间网格 $x_j = j h$，其中 $j=0, 1, \\dots, N-1$。\n3.  构建初始条件数组 $u_0$，表示网格上的阶跃函数。对于 $j=0, \\dots, N/2-1$，有 $u_j(0) = 1$，否则 $u_j(0)=0$。\n4.  构建无量纲波数数组 $\\theta_m = 2\\pi m/N$。为了与 `numpy.fft` 一起使用，有效模态指数 $m$ 的顺序为 $0, 1, \\dots, N/2-1, -N/2, \\dots, -1$。这可以方便地使用 `np.fft.fftfreq` 生成。\n5.  对于每个测试案例 $(b, \\kappa, \\Delta t)$：\n    a. 使用给定公式计算所有模态的特征值数组 $\\lambda(\\theta)$：\n    $$\n    \\lambda(\\theta) = -i\\,b\\,\\frac{\\sin(\\theta)}{h} - \\kappa\\,\\frac{4\\sin^2(\\theta/2)}{h^2}\n    $$\n    b. 计算数组 $z = \\Delta t\\,\\lambda(\\theta)$。\n    c. 计算两种格式的传播子数组：$R_{\\mathrm{BE}}(z)$ 和 $R_{\\mathrm{CN}}(z)$。\n    d. 计算初始条件的 DFT：$\\widehat{u}^0 = \\text{DFT}(u_0)$。\n    e. 在傅里叶空间中传播一步：$\\widehat{u}^1_{\\mathrm{BE}} = R_{\\mathrm{BE}}(z) \\odot \\widehat{u}^0$ 和 $\\widehat{u}^1_{\\mathrm{CN}} = R_{\\mathrm{CN}}(z) \\odot \\widehat{u}^0$，其中 $\\odot$ 是逐元素乘法。\n    f. 通过应用逆 DFT 计算在时间 $\\Delta t$ 的解：$u^1_{\\mathrm{scheme}} = \\text{IDFT}(\\widehat{u}^1_{\\mathrm{scheme}})$。由于初始数据是实数，我们取结果的实部以舍弃由数值舍入误差产生的可忽略的虚部。\n    g. 计算振荡度量：\n        - 下冲：$\\min(u^1_{\\mathrm{scheme}})$。\n        - 上冲：$\\max\\{0, \\max(u^1_{\\mathrm{scheme}}) - 1\\}$。\n    h. 计算在奈奎斯特频率下的刚性模态放大 $G_{\\mathrm{nyq}}$。奈奎斯特模态对应于 $\\theta = \\pi$。其特征值是纯实数且是扩散性的：\n    $$\n    \\lambda(\\pi) = -i\\,b\\,\\frac{\\sin(\\pi)}{h} - \\kappa\\,\\frac{4\\sin^2(\\pi/2)}{h^2} = - \\frac{4\\kappa}{h^2}\n    $$\n    令 $z_{\\mathrm{nyq}} = \\Delta t \\lambda(\\pi) = -4\\kappa\\Delta t/h^2$。则：\n    $$\n    G_{\\mathrm{nyq}}^{\\mathrm{BE}} = |R_{\\mathrm{BE}}(z_{\\mathrm{nyq}})| = \\left|\\frac{1}{1 - z_{\\mathrm{nyq}}}\\right|\n    $$\n    $$\n    G_{\\mathrm{nyq}}^{\\mathrm{CN}} = |R_{\\mathrm{CN}}(z_{\\mathrm{nyq}})| = \\left|\\frac{1 + z_{\\mathrm{nyq}}/2}{1 - z_{\\mathrm{nyq}}/2}\\right|\n    $$\n6.  收集每个测试案例的六个指定浮点数，并将最终输出格式化为列表的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing backward Euler and Crank-Nicolson schemes\n    for a convection-diffusion equation, focusing on stability and oscillations.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (stiff diffusion, no convection)\n        (0.0, 100.0, 0.5),\n        # Case 2 (stiff diffusion with convection)\n        (3.0, 100.0, 0.5),\n        # Case 3 (moderately diffusive, small time step)\n        (0.0, 1.0, 1e-4),\n    ]\n\n    # Global parameters\n    L = 2.0 * np.pi\n    N = 256\n    h = L / N\n\n    # Spatial grid and initial condition\n    x = np.arange(N) * h\n    u0 = np.zeros(N)\n    # The condition is u(x,0)=1 for 0 = x  L/2.\n    # On the grid x_j = j*h, this means j*h  L/2 => j  L/(2*h) = N/2.\n    # Indices are 0, 1, ..., N/2 - 1.\n    u0[0:N//2] = 1.0\n\n    # Fourier space setup\n    # theta = 2*pi*m/N, where m are the DFT mode numbers\n    # np.fft.fftfreq(N) gives m/N for the standard FFT ordering\n    theta = 2.0 * np.pi * np.fft.fftfreq(N)\n    u0_hat = np.fft.fft(u0)\n    \n    results = []\n    for b, kappa, dt in test_cases:\n        # 1. Compute eigenvalues and stability function arguments\n        # Eigenvalue of the semi-discrete operator for each mode theta\n        # lambda(theta) = -i*b*sin(theta)/h - kappa*4*sin^2(theta/2)/h^2\n        # Use 2*(1-cos(theta)) for 4*sin^2(theta/2) to avoid creating theta/2 array\n        lambda_theta = (-1j * b * np.sin(theta) / h\n                        - kappa * 2.0 * (1.0 - np.cos(theta)) / h**2)\n        \n        # Stability function argument z = dt * lambda\n        z = dt * lambda_theta\n\n        # 2. Compute the one-step Fourier propagators (R(z))\n        # Backward Euler: R_BE(z) = 1 / (1 - z)\n        R_BE = 1.0 / (1.0 - z)\n        # Crank-Nicolson: R_CN(z) = (1 + z/2) / (1 - z/2)\n        R_CN = (1.0 + 0.5 * z) / (1.0 - 0.5 * z)\n\n        # 3. Propagate one step in Fourier space\n        u1_hat_BE = R_BE * u0_hat\n        u1_hat_CN = R_CN * u0_hat\n\n        # 4. Transform back to physical space and take the real part\n        u1_BE = np.real(np.fft.ifft(u1_hat_BE))\n        u1_CN = np.real(np.fft.ifft(u1_hat_CN))\n\n        # 5. Measure undershoot and overshoot amplitudes\n        # Undershoot is defined as the minimum value of u\n        min_u_cn = np.min(u1_CN)\n        min_u_be = np.min(u1_BE)\n        \n        # Overshoot is defined as max{u-1, 0}\n        overshoot_cn = np.max([np.max(u1_CN) - 1.0, 0.0])\n        overshoot_be = np.max([np.max(u1_BE) - 1.0, 0.0])\n\n        # 6. Compute stiff-mode amplification at Nyquist mode (theta=pi)\n        # lambda_nyq = -4*kappa/h^2, since sin(pi)=0 and sin(pi/2)=1\n        lambda_nyq = -4.0 * kappa / h**2\n        z_nyq = dt * lambda_nyq\n        \n        # G_nyq for BE\n        g_nyq_be = np.abs(1.0 / (1.0 - z_nyq))\n        \n        # G_nyq for CN\n        g_nyq_cn = np.abs((1.0 + 0.5 * z_nyq) / (1.0 - 0.5 * z_nyq))\n\n        # 7. Collect results for the current case\n        case_results = [\n            min_u_cn,\n            min_u_be,\n            overshoot_cn,\n            overshoot_be,\n            g_nyq_cn,\n            g_nyq_be\n        ]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # Create '[a,b,c],[d,e,f]' string\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    # Enclose in outer '[]'\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "稳定性分析的原理虽然是为线性问题推导的，但它们为处理刚性非线性系统提供了强有力的指导。在最后一个练习中，我们将处理一个刚性非线性反应方程，比较 L-稳定方法与 A-稳定方法的表现 。你将实现一个牛顿求解器来处理隐式非线性步，亲身体会 L-稳定性如何防止数值过冲，并确保即使在面对极端刚性和非线性时也能获得稳健的性能。",
            "id": "3360266",
            "problem": "考虑一个由偏微分方程中的半离散反应项产生的标量初值问题，其抽象形式如下\n$$\n\\frac{du}{dt} = -p\\big(u + f(u)\\big), \\qquad f(u)=u^p, \\qquad p1,\\qquad u(0)=1,\n$$\n其中 $p$ 是一个无量纲的刚度参数，同时也是非线性指数。$u(t)$ 的精确解保持非负，并单调递减至稳定平衡点 $u^\\star=0$。你将研究应用于该问题的两种隐式单步时间积分方法的定性行为：\n- Backward Euler (一种 $L$-稳定方法)，\n- Implicit Midpoint，对于常微分方程也称为 Crank–Nicolson (一种 $A$-稳定但非 $L$-稳定的方法)。\n\n你必须从以下基本原理出发：\n- $A$-稳定性和 $L$-稳定性的定义，这些定义是基于线性测试方程 $\\frac{dy}{dt}=\\lambda y$ 和时间积分方法的相关线性稳定性函数，且不预先假设任何具体公式。\n- 对于刚性问题，在当前状态附近对非线性右端项进行局部线性化，可以在大刚度极限下精确捕捉刚性衰减，这一概念将分析局部地简化为带有大的负实数参数的线性测试方程。\n\n题目描述中不会给出任何特定于方法的稳定性公式。你必须从第一性原理出发进行推理，并使用它们各自的定义性隐式更新方程，直接在非线性问题上实现这两种方法。\n\n对于时间步长 $h0$ 和当前值 $u_n$，这两种方法由求解 $u_{n+1}$ 的以下隐式方程定义：\n- Backward Euler：找到 $u_{n+1}$ 使得\n$$\nu_{n+1} = u_n + h\\Big(-p\\big(u_{n+1} + u_{n+1}^p\\big)\\Big).\n$$\n- Implicit Midpoint：找到 $u_{n+1}$ 使得\n$$\nu_{n+1} = u_n + h\\Big(-p\\big(\\tfrac{1}{2}(u_n+u_{n+1}) + \\big(\\tfrac{1}{2}(u_n+u_{n+1})\\big)^p\\big)\\Big).\n$$\n\n对给定的方法和参数集，定义过冲指示器如下：从 $u_0=1$ 开始模拟 $N$ 步，如果在任何一步数值解变为负数，即 $\\min_{0\\leq n\\leq N} u_n  0$，则声明“过冲”。该指示器是一个布尔值，你必须以整数形式报告，其中 $1$ 表示“发生过冲”，$0$ 表示“未发生过冲”。\n\n设计并实现一个鲁棒的非线性求解器，用于求解每一步的上述隐式方程，并保证收敛到物理相关的解分支。不要作任何绕过求解非线性方程的假设。\n\n测试集。使用以下参数集 $(p, h, N)$：\n- 测试 1：$p=10$, $h=0.5$, $N=3$。\n- 测试 2：$p=10$, $h=0.05$, $N=20$。\n- 测试 3：$p=100$, $h=0.1$, $N=3$。\n- 测试 4：$p=2$, $h=0.9$, $N=3$。\n- 测试 5：$p=1000$, $h=0.01$, $N=3$。\n\n你的程序必须输出单行，其中包含一个用方括号括起来的逗号分隔列表，列表内容为过冲指示器，按每个测试中“Implicit Midpoint 然后 Backward Euler”的顺序展开，即：\n$$\n[\\mathrm{IM}_1,\\mathrm{BE}_1,\\mathrm{IM}_2,\\mathrm{BE}_2,\\mathrm{IM}_3,\\mathrm{BE}_3,\\mathrm{IM}_4,\\mathrm{BE}_4,\\mathrm{IM}_5,\\mathrm{BE}_5],\n$$\n其中每个条目为 $0$ 或 $1$。不应打印任何额外文本。所有量都是无量纲的，因此输出中不需要也不允许使用物理单位。角度单位不适用。不使用百分比；任何分数数量在中间计算中必须表示为十进制数，但最终报告的指示器是 $\\{0,1\\}$ 中的整数。\n\n你的解答必须从第一性原理出发，论证为何 $L$-稳定方法能避免过冲，而仅仅是 $A$-稳定的方法在 $p\\to\\infty$ 时会表现出过冲，并说明所提供的数值实验是如何在不依赖任何简化公式的情况下将这种区别具体化操作的。",
            "solution": "问题的核心在于，当时间积分方法应用于刚性常微分方程(ODE)时，$A$-稳定性与$L$-稳定性之间的区别。我们从第一性原理出发定义这些概念。\n\n**$A$-稳定性与$L$-稳定性**\nODE 数值方法的稳定性是使用 Dahlquist 的线性测试问题来分析的：\n$$\n\\frac{dy}{dt} = \\lambda y, \\qquad y(0)=y_0\n$$\n其中 $\\lambda$ 是一个复数。对于一个稳定的物理系统，$\\text{Re}(\\lambda) \\le 0$。将一个单步数值方法应用于此方程，会得到一个形如 $y_{n+1} = R(z) y_n$ 的递推关系，其中 $z = h\\lambda$，$R(z)$ 是该方法特定的稳定性函数。\n\n- **$A$-稳定性**：如果一个方法的绝对稳定区域 $S = \\{z \\in \\mathbb{C} : |R(z)| \\le 1\\}$ 包含了整个复平面的左半部分 $\\mathbb{C}^- = \\{z \\in \\mathbb{C} : \\text{Re}(z) \\le 0\\}$，则该方法是 $A$-稳定的。这确保了对于任何稳定的线性问题，不论时间步长 $h$ 的大小，数值解都不会增长。\n\n- **$L$-稳定性**：如果一个方法是 $A$-稳定的，并且其稳定性函数额外满足以下条件：\n$$\n\\lim_{|z| \\to \\infty, \\, \\text{Re}(z)  0} |R(z)| = 0\n$$\n对于 $\\lambda$ 是大的负实数的刚性系统，出于实际目的，该条件简化为 $\\lim_{z \\to -\\infty} R(z) = 0$。此性质对刚性问题至关重要，因为它确保了对应于非常大的负特征值的分量在单个时间步内被强阻尼，从而模仿精确解的快速衰减。\n\n**对指定方法的分析**\n\n1.  **Backward Euler (BE)**：将该方法应用于测试方程得到 $y_{n+1} = y_n + h\\lambda y_{n+1}$。求解 $y_{n+1}$ 得 $y_{n+1} = \\frac{1}{1 - h\\lambda} y_n$。其稳定性函数为：\n    $$\n    R_{\\text{BE}}(z) = \\frac{1}{1-z}\n    $$\n    - **$A$-稳定性**：对任何 $z=x+iy$ 且 $x \\le 0$，因为 $1-x \\ge 1$，所以 $|R_{\\text{BE}}(z)|^2 = \\frac{1}{(1-x)^2 + y^2} \\le 1$。因此，BE 是 $A$-稳定的。\n    - **$L$-稳定性**：当 $z \\to -\\infty$ 时，$R_{\\text{BE}}(z) \\to 0$。因此，Backward Euler 方法是 $L$-稳定的。\n\n2.  **Implicit Midpoint (IM)**：将该方法应用于测试方程得到 $y_{n+1} = y_n + h\\lambda \\frac{y_n+y_{n+1}}{2}$。求解 $y_{n+1}$ 得 $y_{n+1} = \\frac{1+h\\lambda/2}{1-h\\lambda/2} y_n$。其稳定性函数为：\n    $$\n    R_{\\text{IM}}(z) = \\frac{1+z/2}{1-z/2}\n    $$\n    - **$A$-稳定性**：对任何 $z=x+iy$ 且 $x \\le 0$，因为 $|1+x/2| \\le |1-x/2|$，所以 $|R_{\\text{IM}}(z)|^2 = \\frac{(1+x/2)^2 + (y/2)^2}{(1-x/2)^2 + (y/2)^2} \\le 1$。因此，IM 是 $A$-稳定的。\n    - **$L$-稳定性**：当 $z \\to -\\infty$ 时，$R_{\\text{IM}}(z) = \\frac{1/z + 1/2}{1/z - 1/2} \\to \\frac{1/2}{-1/2} = -1$。因为极限不为 $0$，所以 Implicit Midpoint 方法不是 $L$-稳定的。\n\n**与非线性刚性问题和过冲的联系**\n给定问题 $\\frac{du}{dt} = -p(u+u^p)$ 在 $p$ 很大时是刚性的。其局部动态由右端项 $F(u)=-p(u+u^p)$ 的雅可比行列式（在此为导数）$J(u) = -p(1+pu^{p-1})$ 决定。对于 $u_0=1$，初始的“特征值”等效为 $\\lambda \\approx J(1) = -p(1+p)$，这是一个大的负数。对于一个粗糙的时间步长 $h$，乘积 $z=h\\lambda$ 可以是大的负数。\n\n- **$L$-稳定**的 Backward Euler 方法，由于当 $z \\to -\\infty$ 时 $R_{\\text{BE}}(z) \\to 0$，会在第一步中强力衰减解，产生一个小的正值 $u_1 \\approx 0$。这种行为避免了非物理振荡和过冲。\n\n- **$A$-稳定但非 $L$-稳定**的 Implicit Midpoint 方法，由于当 $z \\to -\\infty$ 时 $R_{\\text{IM}}(z) \\to -1$，会使解的刚性分量符号反转而没有显著衰减，导致 $u_1 \\approx -u_0 = -1$。这是一种被称为过冲的数值假象，即解变为负数，违背了原始问题的物理原理（其中 $u \\ge 0$）。\n\n**对给定问题的过冲进行严格分析**\n为了从 $u_n$ 求得 $u_{n+1}$（为清晰起见记为 $x$），我们必须求解一个非线性方程 $G(x)=0$。如果计算出的根 $x=u_{n+1}$ 是负数，则发生了从正状态 $u_n  0$ 的过冲。\n\n- **Backward Euler**：残差为 $G_{\\text{BE}}(x) = x - u_n + hp(x+x^p) = 0$。对于 $x \\ge 0$，导数 $G'_{\\text{BE}}(x) = 1+hp+hp^2x^{p-1}$ 严格为正。由于 $G_{\\text{BE}}(0) = -u_n \\le 0$（因为我们从 $u_0=1$ 开始，且解是衰减的），$x$ 的唯一物理相关根必须是非负的。因此，根据归纳法，如果 $u_n \\ge 0$，则 $u_{n+1} \\ge 0$。Backward Euler 不会发生过冲。\n\n- **Implicit Midpoint**：残差为 $G_{\\text{IM}}(x) = x - u_n + hp\\left(\\frac{u_n+x}{2} + \\left(\\frac{u_n+x}{2}\\right)^p\\right) = 0$。对于期望解附近的 $x$，导数 $G'_{\\text{IM}}(x) = 1 + \\frac{hp}{2} + \\frac{hp^2}{2}\\left(\\frac{u_n+x}{2}\\right)^{p-1}$ 是正的。因此函数 $G_{\\text{IM}}(x)$ 是单调的。如果在第一步 ($u_0=1$) 中根 $u_1=x$ 为负，则发生过冲。根据介值定理，如果 $G_{\\text{IM}}(0)  0$，这一点可以得到保证。\n$$\nG_{\\text{IM}}(0) = -1 + hp\\left(\\frac{1}{2} + \\left(\\frac{1}{2}\\right)^p\\right)\n$$\n如果 $hp\\left(\\frac{1}{2} + 2^{-p}\\right)  1$，则发生过冲。对于大的整数 $p$，该条件趋近于 $hp  2$。我们注意到，要发生过冲，可能需要计算负数的幂；测试集中的整数 $p$ 值确保了这种计算是良定义的。\n\n**数值实现**\n在每个时间步，使用牛顿法求解 $u_{n+1}$ 的隐式方程。这需要为每个积分方法定义残差函数 $G(x)$ 及其导数 $G'(x)$。模拟从 $u_0=1$ 开始，进行 $N$ 步，并在每一步检查解是否变为负数。\n\n对 IM 测试条件 $hp\\left(\\frac{1}{2} + 2^{-p}\\right)  1$：\n- T1: $p=10, h=0.5 \\implies hp=5$。$5(0.5+2^{-10}) \\approx 2.5  1$ (过冲)。\n- T2: $p=10, h=0.05 \\implies hp=0.5$。$0.5(0.5+2^{-10}) \\approx 0.25  1$ (无过冲)。\n- T3: $p=100, h=0.1 \\implies hp=10$。$10(0.5+2^{-100}) \\approx 5  1$ (过冲)。\n- T4: $p=2, h=0.9 \\implies hp=1.8$。$1.8(0.5+2^{-2}) = 1.35  1$ (过冲)。\n- T5: $p=1000, h=0.01 \\implies hp=10$。$10(0.5+2^{-1000}) \\approx 5  1$ (过冲)。\n此分析预测，除了测试2，IM 在所有情况下都会发生过冲，而 BE 永远不会过冲。代码实现将证实这一行为。",
            "answer": "```python\nimport numpy as np\n\ndef newton_solver(g, g_prime, x0, tol=1e-12, max_iter=50):\n    \"\"\"\n    Solves the scalar nonlinear equation g(x) = 0 using Newton's method.\n    \"\"\"\n    x = float(x0)\n    for _ in range(max_iter):\n        try:\n            gx = g(x)\n            if abs(gx)  tol:\n                return x\n            gpx = g_prime(x)\n        except (ValueError, OverflowError):\n            # Handles cases like non-integer power of a negative number or overflow\n            return float('nan')\n\n        if gpx == 0:\n            return float('nan')\n        \n        x = x - gx / gpx\n    return x\n\ndef run_simulation(method, p, h, N):\n    \"\"\"\n    Runs a time integration for N steps and reports if overshoot occurs.\n    \n    Returns:\n        1 if overshoot occurred, 0 otherwise.\n    \"\"\"\n    u = 1.0\n    for _ in range(N):\n        u_n = u\n        \n        if method == 'BE':\n            # Residual g(x) = x - u_n - h * F(x) = 0\n            # F(x) = -p * (x + x**p)\n            g = lambda x: x * (1.0 + h * p) + h * p * np.power(x, p) - u_n\n            # Derivative g'(x) = 1 - h * F'(x)\n            # F'(x) = -p * (1 + p * x**(p-1))\n            g_prime = lambda x: 1.0 + h * p + h * p * p * np.power(x, p - 1)\n        \n        elif method == 'IM':\n            # Residual g(x) = x - u_n - h * F((u_n+x)/2) = 0\n            def g(x):\n                mid = (u_n + x) / 2.0\n                return x - u_n + h * p * (mid + np.power(mid, p))\n            \n            # Derivative g'(x) = 1 - h/2 * F'((u_n+x)/2)\n            def g_prime(x):\n                mid = (u_n + x) / 2.0\n                return 1.0 + h * p * (0.5 + 0.5 * p * np.power(mid, p - 1))\n        \n        else:\n            raise ValueError(\"Unknown method specified.\")\n            \n        u_next = newton_solver(g, g_prime, u_n)\n        \n        # Check for overshoot. Also catches solver failure (nan).\n        if not np.isfinite(u_next) or u_next  0:\n            return 1\n        \n        u = u_next\n           \n    return 0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (10, 0.5, 3),    # Test 1\n        (10, 0.05, 20),  # Test 2\n        (100, 0.1, 3),   # Test 3\n        (2, 0.9, 3),     # Test 4\n        (1000, 0.01, 3), # Test 5\n    ]\n\n    results = []\n    for p, h, N in test_cases:\n        # Implicit Midpoint simulation\n        im_res = run_simulation('IM', float(p), float(h), N)\n        results.append(im_res)\n        \n        # Backward Euler simulation\n        be_res = run_simulation('BE', float(p), float(h), N)\n        results.append(be_res)\n        \n    # Format and print the final output as a single line\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}