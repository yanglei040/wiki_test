{
    "hands_on_practices": [
        {
            "introduction": "To build a solid foundation, our first practice involves implementing the most common dimensional splitting techniques for a canonical problem: the two-dimensional heat equation. This exercise will guide you through constructing both first-order Lie splitting and second-order Strang splitting schemes. By using a manufactured solution where the exact answer is known, we can precisely measure the numerical error and empirically verify the theoretical order of accuracy for each method—a fundamental skill in computational code verification and validation .",
            "id": "3377992",
            "problem": "Consider the two-dimensional heat equation on the unit square with homogeneous Dirichlet boundary conditions, where the exact manufactured solution is given by $u(x,y,t)=\\sin(\\pi x)\\sin(\\pi y)\\mathrm{e}^{-2\\pi^2 t}$. The governing partial differential equation is $u_t=u_{xx}+u_{yy}$ for $(x,y)\\in(0,1)\\times(0,1)$ and $t\\ge 0$, with $u(x,y,0)=\\sin(\\pi x)\\sin(\\pi y)$ and $u=0$ on the boundary $\\partial\\Omega$ for all $t\\ge 0$. Your task is to construct a dimensional splitting solver based on alternating one-dimensional evolution subproblems, and to empirically determine the observed order of accuracy in time by halving the time step $\\Delta t$, while ensuring that spatial discretization errors are negligible by taking a sufficiently small spatial grid size $h$.\n\nWork entirely in a purely mathematical and algorithmic setting: discretize $(0,1)^2$ using a uniform Cartesian grid with interior grid size $M\\times M$ and spacing $h=1/(M+1)$. Use $M=128$, which sets $h=1/129$. The dimensional splitting must proceed by alternating one-dimensional solves for the subproblems $v_t=v_{xx}$ and $w_t=w_{yy}$ on the same grid, respecting the homogeneous Dirichlet boundary conditions. Each one-dimensional subproblem must be advanced in time using a second-order accurate and unconditionally stable method applied along the appropriate grid lines. Combine the one-dimensional sub-solvers to produce a full time step using either first-order Lie splitting (apply an $x$-direction step of size $\\Delta t$ followed by a $y$-direction step of size $\\Delta t$) or second-order Strang splitting (apply an $x$-direction step of size $\\Delta t/2$, then a $y$-direction step of size $\\Delta t$, then an $x$-direction step of size $\\Delta t/2$). Initialize the numerical solution at $t=0$ using the exact initial condition, advance to the final time $T$, and compute the discrete $\\ell^2$-error at $t=T$ against the exact manufactured solution, defined as\n$$\nE(\\Delta t):=\\left(h^2\\sum_{i=1}^{M}\\sum_{j=1}^{M}\\left(u_{i,j}^{\\mathrm{num}}(T)-u\\!\\left(x_i,y_j,T\\right)\\right)^2\\right)^{1/2},\n$$\nwhere $x_i=ih$ and $y_j=jh$ denote interior grid points.\n\nTo quantify the observed order of accuracy in time, use a triplet of halved time steps $\\Delta t,\\,\\Delta t/2,\\,\\Delta t/4$ (with $T$ an integer multiple of each of these time steps). Compute the errors $E(\\Delta t)$, $E(\\Delta t/2)$, and $E(\\Delta t/4)$, and then compute two observed orders,\n$$\np_1=\\frac{\\log\\big(E(\\Delta t)/E(\\Delta t/2)\\big)}{\\log(2)},\\quad p_2=\\frac{\\log\\big(E(\\Delta t/2)/E(\\Delta t/4)\\big)}{\\log(2)},\n$$\nand output the average $\\bar{p}=(p_1+p_2)/2$ as a single floating-point number for each test case.\n\nImplement your solver and produce numerical results for the following three test cases, which together form the test suite:\n- Case 1: first-order Lie splitting, final time $T=0.1$, base time step $\\Delta t=0.025$ (so the halved steps are $0.0125$ and $0.00625$).\n- Case 2: second-order Strang splitting, final time $T=0.1$, base time step $\\Delta t=0.025$.\n- Case 3: second-order Strang splitting, final time $T=0.2$, base time step $\\Delta t=0.05$.\n\nIn all cases use $M=128$ interior points per spatial direction, set $h=1/129$, and enforce homogeneous Dirichlet boundary conditions. Angles in trigonometric functions must be in radians. The required final output format is a single line containing a comma-separated Python-style list of the three floating-point averages $\\bar{p}$ for the three cases, in the order listed above, enclosed in square brackets. For example, your program should print something like \"[1.0,2.0,2.0]\" but with the actual computed floating-point values for the three cases.",
            "solution": "The user wants to solve a numerical analysis problem involving the 2D heat equation.\n\n## 1. Mathematical Formulation\n\nThe problem under consideration is the two-dimensional heat equation on the unit square $\\Omega = (0,1) \\times (0,1)$:\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = (\\Delta_x + \\Delta_y) u\n$$\nsubject to the initial condition $u(x,y,0) = \\sin(\\pi x)\\sin(\\pi y)$ and homogeneous Dirichlet boundary conditions $u(x,y,t) = 0$ for $(x,y) \\in \\partial\\Omega$. The provided manufactured solution is $u(x,y,t) = \\sin(\\pi x)\\sin(\\pi y)e^{-2\\pi^2 t}$, which satisfies the PDE and the auxiliary conditions.\n\n## 2. Numerical Method: Operator Splitting\n\nTo solve this equation numerically, we employ an operator splitting (or dimensional splitting) technique. The core idea is to decompose the two-dimensional Laplacian operator $\\Delta = \\Delta_x + \\Delta_y$ into two one-dimensional operators. The evolution of the solution over a time step $\\Delta t$ is then approximated by solving a sequence of simpler one-dimensional problems.\n\nLet $\\mathcal{L}_x = \\Delta_x$ and $\\mathcal{L}_y = \\Delta_y$. The PDE is $u_t = (\\mathcal{L}_x + \\mathcal{L}_y)u$. The formal solution is $u(t) = e^{t(\\mathcal{L}_x + \\mathcal{L}_y)}u(0)$. Operator splitting methods approximate the matrix exponential $e^{\\Delta t(\\mathcal{L}_x + \\mathcal{L}_y)}$.\n\n### 2.1. Lie Splitting (First Order)\n\nThe first-order Lie-Trotter splitting approximates the evolution as a sequential application of the one-dimensional evolution operators:\n$$\ne^{\\Delta t(\\mathcal{L}_x + \\mathcal{L}_y)} \\approx e^{\\Delta t \\mathcal{L}_y} e^{\\Delta t \\mathcal{L}_x}\n$$\nThis approximation introduces a splitting error of order $O(\\Delta t)$. The numerical scheme for advancing the solution $U^n$ at time $t_n$ to $U^{n+1}$ at $t_{n+1} = t_n + \\Delta t$ is a two-stage process:\n1.  Solve $u^*_t = \\mathcal{L}_x u^*$ for one step of size $\\Delta t$, with $u^*(t_n) = U^n$. Let the result be $U^* = \\mathcal{S}_x(\\Delta t) U^n$.\n2.  Solve $u^{**}_t = \\mathcal{L}_y u^{**}$ for one step of size $\\Delta t$, with $u^{**}(t_n) = U^*$. The final result is $U^{n+1} = \\mathcal{S}_y(\\Delta t) U^* = \\mathcal{S}_y(\\Delta t) \\mathcal{S}_x(\\Delta t) U^n$.\n\n### 2.2. Strang Splitting (Second Order)\n\nThe second-order Strang splitting provides a more accurate symmetric approximation:\n$$\ne^{\\Delta t(\\mathcal{L}_x + \\mathcal{L}_y)} \\approx e^{\\frac{\\Delta t}{2} \\mathcal{L}_x} e^{\\Delta t \\mathcal{L}_y} e^{\\frac{\\Delta t}{2} \\mathcal{L}_x}\n$$\nThis introduces a splitting error of order $O(\\Delta t^2)$. The numerical scheme is a three-stage process:\n1.  Solve for a half-step in the $x$-direction: $U^* = \\mathcal{S}_x(\\Delta t/2) U^n$.\n2.  Solve for a full-step in the $y$-direction: $U^{**} = \\mathcal{S}_y(\\Delta t) U^*$.\n3.  Solve for another half-step in the $x$-direction: $U^{n+1} = \\mathcal{S}_x(\\Delta t/2) U^{**}$.\n\n## 3. Discretization and 1D Solver: Crank-Nicolson Method\n\nThe domain is discretized with a uniform grid of $M \\times M$ interior points, where the spatial step is $h = 1/(M+1)$. The grid points are $(x_i, y_j) = (ih, jh)$ for $i,j \\in \\{1, \\dots, M\\}$.\n\nEach one-dimensional subproblem, e.g., $v_t = v_{xx}$, must be solved using a second-order accurate and unconditionally stable method. The Crank-Nicolson method is the canonical choice. For a 1D grid with values $V_i^n \\approx v(x_i, t_n)$, the Crank-Nicolson discretization is:\n$$\n\\frac{V_i^{n+1} - V_i^n}{\\Delta \\tau} = \\frac{1}{2} \\left( \\frac{V_{i+1}^n - 2V_i^n + V_{i-1}^n}{h^2} + \\frac{V_{i+1}^{n+1} - 2V_i^{n+1} + V_{i-1}^{n+1}}{h^2} \\right)\n$$\nwhere $\\Delta \\tau$ is the time step for the 1D solve (which could be $\\Delta t$ or $\\Delta t/2$). Let the diffusion number be $\\alpha = \\frac{\\Delta \\tau}{2h^2}$. Rearranging the terms, we get a system of linear equations for the unknown values $V_i^{n+1}$:\n$$\n-\\alpha V_{i-1}^{n+1} + (1+2\\alpha)V_i^{n+1} - \\alpha V_{i+1}^{n+1} = \\alpha V_{i-1}^n + (1-2\\alpha)V_i^n + \\alpha V_{i+1}^n\n$$\nfor $i=1, \\dots, M$. The boundary conditions $V_0 = V_{M+1} = 0$ are incorporated. This forms a tridiagonal system of equations $A \\mathbf{V}^{n+1} = B \\mathbf{V}^n$, where $\\mathbf{V}^n$ is the vector of values at time $t_n$. The matrix $A$ is tridiagonal with diagonal elements $(1+2\\alpha)$ and off-diagonal elements $-\\alpha$. This system is efficiently solved for $\\mathbf{V}^{n+1}$ using a tridiagonal matrix algorithm (e.g., Thomas algorithm).\n\n## 4. Algorithmic Implementation\n\nFor each of the three test cases, the following procedure is executed:\n1.  Set the parameters: splitting method type, final time $T$, base time step $\\Delta t_{base}$, and grid size $M=128$.\n2.  Define the three time steps for the accuracy test: $\\Delta t_1 = \\Delta t_{base}$, $\\Delta t_2 = \\Delta t_{base}/2$, $\\Delta t_3 = \\Delta t_{base}/4$.\n3.  For each time step $\\Delta t_k$:\n    a. Initialize an $M \\times M$ matrix $U$ with the values of the initial condition $u(x,y,0)$ at the interior grid points.\n    b. Calculate the number of time steps $N_k = T/\\Delta t_k$.\n    c. Evolve the solution from $t=0$ to $t=T$ by iterating $N_k$ times:\n        i. In each iteration, apply the chosen splitting scheme (Lie or Strang).\n        ii. Each application of a 1D solver, $\\mathcal{S}_x(\\tau)$ or $\\mathcal{S}_y(\\tau)$, involves looping through all rows or columns of the current data matrix, respectively, and solving the resulting tridiagonal system using the Crank-Nicolson method. For column-wise operations, the matrix is transposed, the row-wise solver is applied, and the result is transposed back.\n    d. At the final time $T$, compute the exact solution matrix $U_{exact}$ at the grid points.\n    e. Calculate the discrete $\\ell^2$-error:\n       $$\n       E(\\Delta t_k) = \\left(h^2\\sum_{i=1}^{M}\\sum_{j=1}^{M}\\left(U_{ij}^{\\mathrm{num}}(T) - U_{ij}^{\\mathrm{exact}}(T)\\right)^2\\right)^{1/2} = h \\cdot \\|U^{\\mathrm{num}}(T) - U^{\\mathrm{exact}}(T)\\|_{\\text{F}}\n       $$\n       where $\\|\\cdot\\|_{\\text{F}}$ is the Frobenius norm.\n4. With the three errors $E_1, E_2, E_3$ computed, the observed orders of convergence are calculated:\n   $$\n   p_1 = \\frac{\\log(E_1/E_2)}{\\log(2)}, \\quad p_2 = \\frac{\\log(E_2/E_3)}{\\log(2)}\n   $$\n5. The final result for the test case is the average observed order, $\\bar{p} = (p_1+p_2)/2$.\n\nThis process yields one value of $\\bar{p}$ for each of the three specified test cases. Lie splitting is expected to show first-order convergence ($\\bar{p} \\approx 1.0$), while Strang splitting should show second-order convergence ($\\bar{p} \\approx 2.0$), provided the temporal splitting error dominates the spatial discretization error, which is ensured by the small value of $h=1/129$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef cn_step(u_in, dt_1d, h, M):\n    \"\"\"\n    Performs one step of the Crank-Nicolson method for the 1D heat equation.\n    u_t = u_xx with homogeneous Dirichlet boundary conditions. The method solves\n    the tridiagonal system (I - alpha*A_lap) u_new = (I + alpha*A_lap) u_in.\n\n    Args:\n        u_in (np.ndarray): The 1D array of solution values at the current time.\n        dt_1d (float): The time step for this 1D solve.\n        h (float): The spatial grid spacing.\n        M (int): The number of interior grid points.\n\n    Returns:\n        np.ndarray: The updated 1D array of solution values.\n    \"\"\"\n    alpha = dt_1d / (2.0 * h**2)\n\n    # Construct the right-hand side vector: b = (I + alpha*A_lap) * u_in\n    b = np.zeros(M)\n    b[0] = (1.0 - 2.0 * alpha) * u_in[0] + alpha * u_in[1]\n    b[M-1] = alpha * u_in[M-2] + (1.0 - 2.0 * alpha) * u_in[M-1]\n    b[1:-1] = alpha * u_in[:-2] + (1.0 - 2.0 * alpha) * u_in[1:-1] + alpha * u_in[2:]\n\n    # Construct the banded matrix for the left-hand side: A_lhs = (I - alpha*A_lap)\n    # The `ab` matrix for solve_banded has shape (3, M) for a tridiagonal system.\n    ab = np.zeros((3, M))\n    ab[0, 1:] = -alpha          # Super-diagonal\n    ab[1, :] = 1.0 + 2.0 * alpha  # Main diagonal\n    ab[2, :-1] = -alpha         # Sub-diagonal\n\n    # Solve the tridiagonal system A_lhs * u_out = b.\n    # (1, 1) specifies one sub-diagonal and one super-diagonal.\n    u_out = solve_banded((1, 1), ab, b)\n    return u_out\n\ndef run_simulation(splitting_type, T, dt_base, M):\n    \"\"\"\n    Runs the full simulation for a given case to find the order of accuracy.\n    It computes the solution for three time steps (dt_base, dt_base/2, dt_base/4)\n    and uses the resulting errors to calculate the observed order of convergence.\n\n    Args:\n        splitting_type (str): 'Lie' or 'Strang'.\n        T (float): The final simulation time.\n        dt_base (float): The base time step.\n        M (int): The number of interior grid points per dimension.\n\n    Returns:\n        float: The average observed order of accuracy.\n    \"\"\"\n    h = 1.0 / (M + 1.0)\n    x = h * np.arange(1, M + 1)\n    xx, yy = np.meshgrid(x, x, indexing='ij')\n\n    dts = [dt_base, dt_base / 2.0, dt_base / 4.0]\n    errors = []\n\n    for dt in dts:\n        # Initialize the solution matrix with the initial condition\n        U = np.sin(np.pi * xx) * np.sin(np.pi * yy)\n        num_steps = int(round(T / dt))\n\n        for _ in range(num_steps):\n            if splitting_type == 'Lie':\n                # --- Lie Splitting Step ---\n                # X-sweep (full dt)\n                U_star = np.zeros_like(U)\n                for i in range(M):\n                    U_star[i, :] = cn_step(U[i, :], dt, h, M)\n                \n                # Y-sweep (full dt)\n                U_next = np.zeros_like(U)\n                for j in range(M):\n                    U_next[:, j] = cn_step(U_star[:, j], dt, h, M)\n                U = U_next\n\n            elif splitting_type == 'Strang':\n                # --- Strang Splitting Step ---\n                dt_half = dt / 2.0\n                \n                # X-sweep (dt/2)\n                U_star = np.zeros_like(U)\n                for i in range(M):\n                    U_star[i, :] = cn_step(U[i, :], dt_half, h, M)\n\n                # Y-sweep (full dt)\n                U_dstar = np.zeros_like(U)\n                for j in range(M):\n                    U_dstar[:, j] = cn_step(U_star[:, j], dt, h, M)\n\n                # X-sweep (dt/2)\n                U_next = np.zeros_like(U)\n                for i in range(M):\n                    U_next[i, :] = cn_step(U_dstar[i, :], dt_half, h, M)\n                U = U_next\n\n        # Compute the L2 error at the final time T\n        U_exact = np.sin(np.pi * xx) * np.sin(np.pi * yy) * np.exp(-2.0 * np.pi**2 * T)\n        # The error is defined as h * ||U_num - U_exact||_F\n        error = h * np.linalg.norm(U - U_exact)\n        errors.append(error)\n\n    E1, E2, E3 = errors\n    p1 = np.log(E1 / E2) / np.log(2.0)\n    p2 = np.log(E2 / E3) / np.log(2.0)\n\n    p_avg = (p1 + p2) / 2.0\n    return p_avg\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the simulation for all test cases\n    and prints the final result in the specified format.\n    \"\"\"\n    # Define the problem-specific parameters\n    M = 128\n\n    test_cases = [\n        # Case 1: Lie splitting, T=0.1, base dt=0.025\n        {'type': 'Lie', 'T': 0.1, 'dt_base': 0.025, 'M': M},\n        \n        # Case 2: Strang splitting, T=0.1, base dt=0.025\n        {'type': 'Strang', 'T': 0.1, 'dt_base': 0.025, 'M': M},\n        \n        # Case 3: Strang splitting, T=0.2, base dt=0.05\n        {'type': 'Strang', 'T': 0.2, 'dt_base': 0.05, 'M': M}\n    ]\n\n    results = []\n    for case in test_cases:\n        p_avg = run_simulation(case['type'], case['T'], case['dt_base'], case['M'])\n        results.append(p_avg)\n\n    # Print the results in the required format: [p1,p2,p3]\n    result_str = \",\".join(map(str, results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With the mechanics of splitting established, we now turn to a critical subtlety concerning the physics of conservation laws. This practice explores the two-dimensional advection equation with a compressible drift field, where naive splitting of the PDE in its transport form can lead to non-physical results. You will implement and compare a naive, non-conservative scheme with a proper, flux-based conservative scheme to demonstrate how an incorrect formulation can fail to conserve mass, a crucial lesson in developing robust numerical methods for fluid dynamics and related fields .",
            "id": "3377962",
            "problem": "Consider the two-dimensional conservation law $u_t + \\nabla \\cdot (\\mathbf{b}(x,y) u) = 0$ on the periodic square domain $[0,1] \\times [0,1]$, where $\\mathbf{b}(x,y) = (b_x(x,y), b_y(x,y))$ is a compressible drift field and $u(x,y,t)$ is a scalar density. The integral form of conservation over the domain implies that for smooth solutions and periodic boundary conditions, the total mass $M(t) = \\int_0^1 \\int_0^1 u(x,y,t) \\, dx \\, dy$ must satisfy $\\frac{dM}{dt} = -\\int_{\\partial \\Omega} (\\mathbf{b} u) \\cdot \\mathbf{n} \\, ds = 0$, hence $M(t)$ is invariant in time.\n\nDesign and implement two split-step numerical schemes on a uniform Cartesian grid with $N_x$ cells in $x$ and $N_y$ cells in $y$, with periodic boundary conditions:\n- A naive dimensional splitting scheme that treats the PDE in transport form per sweep, updating via $u_t \\approx -b_x u_x$ in the $x$-sweep and $u_t \\approx -b_y u_y$ in the $y$-sweep, using a first-order upwind finite difference based on cell-centered $b_x$ and $b_y$ and ignoring the compressible source $u \\, \\nabla \\cdot \\mathbf{b}$. This scheme must use cell-centered velocities and one-dimensional upwinding as $u_{i,j} \\gets u_{i,j} - \\frac{\\Delta t}{\\Delta x} \\left[a_{i,j}^+ (u_{i,j} - u_{i-1,j}) + a_{i,j}^- (u_{i+1,j} - u_{i,j})\\right]$ in an $x$-sweep, where $a_{i,j} = b_x(x_i,y_j)$, $a^+ = \\max(a,0)$, $a^- = \\min(a,0)$, and analogously for the $y$-sweep.\n- A conservative dimensional splitting scheme that updates in flux form per sweep, $u_{i,j} \\gets u_{i,j} - \\frac{\\Delta t}{\\Delta x} \\left[F_{i+1/2,j} - F_{i-1/2,j}\\right]$ in the $x$-sweep, where $F_{i+1/2,j} = b_x(x_{i+1/2}, y_j) \\, u^{\\text{up}}_{i+1/2,j}$ is the upwinded face flux of the product $b_x u$ at the face $(x_{i+1/2}, y_j)$, and $u^{\\text{up}}_{i+1/2,j}$ is chosen from the left or right neighboring cell according to the sign of $b_x(x_{i+1/2}, y_j)$. Use an analogous flux form for the $y$-sweep with face fluxes $G_{i,j+1/2} = b_y(x_i, y_{j+1/2}) \\, u^{\\text{up}}_{i,j+1/2}$. This scheme must use face-centered velocities and upwind of the product $b u$, ensuring discrete mass conservation per sweep under periodic boundaries.\n\nStart from the fundamental conservation law $u_t + \\nabla \\cdot (\\mathbf{b} u) = 0$ and derive the discrete updates, stating the assumptions needed and clarifying the difference between transport form and conservative form. Demonstrate mathematically why the naive split step can introduce artificial mass sources localized near grid-cell corners when $\\mathbf{b}(x,y)$ varies in space (compressible drift), due to the failure of the discrete product rule in the transport-form split, and derive a correction in the form of flux-based updates that enforces mass conservation per sweep by telescoping flux differences.\n\nImplement both schemes and compare their discrete mass errors after one full time step consisting of one $x$-sweep followed by one $y$-sweep. Use a Courant–Friedrichs–Lewy (CFL) condition to select $\\Delta t$ as $\\Delta t = \\text{CFL} \\cdot \\min\\left(\\frac{\\Delta x}{\\max |b_x|}, \\frac{\\Delta y}{\\max |b_y|}\\right)$, with $\\text{CFL} = 0.4$. Use the initial condition $u(x,y,0) = \\exp\\left(-\\frac{(x-x_0)^2 + (y-y_0)^2}{2 \\sigma^2}\\right)$ with $x_0 = 0.3$, $y_0 = 0.7$, and $\\sigma = 0.05$. The grid is defined by cell centers $x_i = (i + \\frac{1}{2}) \\Delta x$, $y_j = (j + \\frac{1}{2}) \\Delta y$ for $i = 0, \\dots, N_x-1$ and $j = 0, \\dots, N_y-1$, and faces $x_{i+1/2} = (i+1) \\Delta x$, $y_{j+1/2} = (j+1) \\Delta y$.\n\nTest suite:\n- Case 1 (happy path, divergence-free drift): $N_x = 64$, $N_y = 64$, $b_x(x,y) = \\cos(2\\pi y)$, $b_y(x,y) = -\\cos(2\\pi x)$.\n- Case 2 (compressible drift): $N_x = 64$, $N_y = 64$, $b_x(x,y) = 2\\pi \\sin(2\\pi x) \\left[1 + 0.5 \\cos(2\\pi y)\\right]$, $b_y(x,y) = 2\\pi \\sin(2\\pi y) \\left[1 - 0.5 \\cos(2\\pi x)\\right]$.\n- Case 3 (edge case with sharp sign changes and corner artifacts): $N_x = 32$, $N_y = 32$, $b_x(x,y) = 2\\pi \\tanh\\left(4 \\sin(2\\pi x) \\cos(2\\pi y)\\right)$, $b_y(x,y) = 2\\pi \\tanh\\left(4 \\cos(2\\pi x) \\sin(2\\pi y)\\right)$.\n\nFor each case, run one full split step and report two floats:\n- The absolute mass error for the naive scheme, $|M^{\\text{naive}} - M^0|$, where $M^0$ is the initial mass and $M^{\\text{naive}}$ is the mass after the naive split step.\n- The absolute mass error for the conservative scheme, $|M^{\\text{cons}} - M^0|$, where $M^{\\text{cons}}$ is the mass after the conservative split step.\n\nFinal Output Format:\nYour program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets in the order [Case 1 naive error, Case 1 conservative error, Case 2 naive error, Case 2 conservative error, Case 3 naive error, Case 3 conservative error].",
            "solution": "The problem presented is valid. It is a well-posed, scientifically grounded problem in the field of numerical methods for partial differential equations, specifically addressing the critical difference between conservative and non-conservative discretization schemes for conservation laws. It contains all necessary information and definitions for a unique solution.\n\nThe problem centers on the two-dimensional advection equation in conservation form:\n$$\n\\frac{\\partial u}{\\partial t} + \\nabla \\cdot (\\mathbf{b} u) = 0\n$$\nwhere $u(x,y,t)$ is a scalar density and $\\mathbf{b}(x,y) = (b_x(x,y), b_y(x,y))$ is a given velocity field. This equation expresses the conservation of the quantity $u$. The total mass in the domain $\\Omega = [0,1] \\times [0,1]$, defined as $M(t) = \\int_{0}^{1}\\int_{0}^{1} u(x,y,t) \\,dx\\,dy$, is a conserved quantity. Applying the divergence theorem under periodic boundary conditions confirms this:\n$$\n\\frac{dM}{dt} = \\int_{\\Omega} \\frac{\\partial u}{\\partial t} \\,dx\\,dy = -\\int_{\\Omega} \\nabla \\cdot (\\mathbf{b} u) \\,dx\\,dy = -\\int_{\\partial\\Omega} (\\mathbf{b} u) \\cdot \\mathbf{n} \\,ds = 0\n$$\nThe integral over the boundary $\\partial\\Omega$ vanishes due to periodicity. A numerical scheme should, ideally, preserve a discrete analogue of this property.\n\nUsing the product rule, the PDE can be expanded into the so-called \"transport\" or \"non-conservative\" form:\n$$\n\\frac{\\partial u}{\\partial t} + \\mathbf{b} \\cdot \\nabla u + u(\\nabla \\cdot \\mathbf{b}) = 0\n$$\nThe term $u(\\nabla \\cdot \\mathbf{b})$ acts as a source or sink term when the velocity field is compressible, i.e., $\\nabla \\cdot \\mathbf{b} \\neq 0$.\n\nDimensional splitting, or operator splitting, approximates the solution to the $2$D equation by solving a sequence of $1$D equations. For a first-order Lie-Trotter splitting, we solve for a full time step $\\Delta t$ by first solving the $x$-direction PDE for $\\Delta t$ and then using the result as the initial condition for solving the $y$-direction PDE for $\\Delta t$.\n\n**Scheme 1: Naive Dimensional Splitting in Transport Form**\n\nThis scheme is based on an incorrect splitting of the PDE. It splits the advection operator $\\mathbf{b} \\cdot \\nabla u = b_x \\frac{\\partial u}{\\partial x} + b_y \\frac{\\partial u}{\\partial y}$ and ignores the source term $u(\\nabla \\cdot \\mathbf{b})$.\n\nThe $x$-sweep solves: $\\frac{\\partial u}{\\partial t} + b_x \\frac{\\partial u}{\\partial x} = 0$.\nThe $y$-sweep solves: $\\frac{\\partial u}{\\partial t} + b_y \\frac{\\partial u}{\\partial y} = 0$.\n\nThis approach is only valid if $\\nabla \\cdot \\mathbf{b}=0$ (incompressible flow), and additionally, if the splitting is done carefully. For a general compressible field, this formulation is fundamentally incorrect as it omits a physical source term.\n\nThe problem specifies a first-order upwind discretization for the $x$-sweep on a grid with cell centers $(x_i, y_j)$, using cell-centered velocities $a_{i,j} = b_x(x_i, y_j)$:\n$$\n\\frac{u_{i,j}^{*} - u_{i,j}^{n}}{\\Delta t} = - \\left[ a_{i,j}^+ \\frac{u_{i,j}^n - u_{i-1,j}^n}{\\Delta x} + a_{i,j}^- \\frac{u_{i+1,j}^n - u_{i,j}^n}{\\Delta x} \\right]\n$$\nwhere $a^+ = \\max(a,0)$ and $a^- = \\min(a,0)$. This is equivalent to the provided update rule. An analogous step is performed for the $y$-sweep.\n\nTo demonstrate the failure of mass conservation, we sum the change in cell values over all cells $i=0, \\dots, N_x-1$ for a given row $j$. The change in mass for this row is proportional to $\\sum_{i} (u_{i,j}^{*} - u_{i,j}^{n}) \\Delta x$. For simplicity, let's assume $a_{i,j}0$ for all $i$. The update rule simplifies to $u_{i,j}^{*} = u_{i,j}^{n} - \\frac{\\Delta t}{\\Delta x} a_{i,j} (u_{i,j}^{n} - u_{i-1,j}^{n})$. The sum of changes is:\n$$\n\\sum_{i=0}^{N_x-1} (u_{i,j}^{*} - u_{i,j}^{n}) = -\\frac{\\Delta t}{\\Delta x} \\sum_{i=0}^{N_x-1} a_{i,j} (u_{i,j}^{n} - u_{i-1,j}^{n})\n$$\nBy re-indexing the summation (letting $k=i-1$ in the second term) and applying periodic boundary conditions ($u_{-1,j} = u_{N_x-1,j}$, $a_{N_x,j}=a_{0,j}$):\n$$\n\\sum_{i} (u_{i,j}^{*} - u_{i,j}^{n}) = -\\frac{\\Delta t}{\\Delta x} \\left( \\sum_{i} a_{i,j} u_{i,j}^n - \\sum_{i} a_{i,j} u_{i-1,j}^n \\right) = -\\frac{\\Delta t}{\\Delta x} \\sum_{i} (a_{i,j} - a_{i+1,j}) u_{i,j}^n\n$$\nThis sum is non-zero if $a_{i,j} = b_x(x_i, y_j)$ varies with $x$, i.e., if $\\frac{\\partial b_x}{\\partial x} \\neq 0$. This scheme therefore artificially creates or destroys mass, violating the fundamental conservation principle. The same holds for the $y$-sweep if $b_y$ varies with $y$.\n\n**Scheme 2: Conservative Dimensional Splitting in Flux Form**\n\nThis scheme correctly splits the conservative form of the PDE.\nThe $x$-sweep solves: $\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}(b_x u) = 0$.\nThe $y$-sweep solves: $\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial y}(b_y u) = 0$.\n\nThis is a finite volume method. We integrate the $x$-sweep PDE over a control volume $V_{i,j} = [x_{i-1/2}, x_{i+1/2}] \\times [y_{j-1/2}, y_{j+1/2}]$. We can consider this one dimension at a time. The average value in cell $i$ is $u_{i,j}(t) \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x, y_j, t) \\,dx$. The integrated PDE becomes:\n$$\n\\frac{d u_{i,j}}{dt} \\Delta x + \\left[ (b_x u)|_{x_{i+1/2}, y_j} - (b_x u)|_{x_{i-1/2}, y_j} \\right] = 0\n$$\nWe define the numerical flux $F_{i+1/2,j}$ to approximate the true flux $(b_x u)$ at the cell interface $x_{i+1/2}$. A forward Euler time-discretization gives:\n$$\nu_{i,j}^{*} = u_{i,j}^{n} - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2,j}^n - F_{i-1/2,j}^n \\right)\n$$\nFor a first-order upwind scheme, the flux is determined by the sign of the velocity at the face, $b_{x, i+1/2, j} = b_x(x_{i+1/2}, y_j)$:\n$$\nF_{i+1/2,j} = \n\\begin{cases} \nb_{x, i+1/2, j} \\, u_{i,j}  \\text{if } b_{x, i+1/2, j} \\geq 0 \\\\\nb_{x, i+1/2, j} \\, u_{i+1,j}  \\text{if } b_{x, i+1/2, j}  0\n\\end{cases}\n= b_{x, i+1/2, j}^+ u_{i,j} + b_{x, i+1/2, j}^- u_{i+1,j}\n$$\nTo verify discrete mass conservation, we sum the update rule over all $i$:\n$$\n\\sum_{i=0}^{N_x-1} (u_{i,j}^{*} - u_{i,j}^{n}) = -\\frac{\\Delta t}{\\Delta x} \\sum_{i=0}^{N_x-1} (F_{i+1/2,j} - F_{i-1/2,j})\n$$\nThe sum on the right is a telescoping series:\n$$\n\\sum_{i=0}^{N_x-1} (F_{i+1/2,j} - F_{i-1/2,j}) = (F_{1/2,j} - F_{-1/2,j}) + (F_{3/2,j} - F_{1/2,j}) + \\dots + (F_{N_x-1/2,j} - F_{N_x-3/2,j})\n$$\nBecause of periodic boundary conditions, the flux at face $x_{-1/2}$ is identical to the flux at face $x_{N_x-1/2}$. Thus, the sum collapses to zero. The total mass $\\sum_i u_{i,j} \\Delta x$ for each row $j$ is conserved up to machine precision. A similar argument holds for the $y$-sweep.\n\nThe combination of the non-conservative discretization and the splitting error, which is proportional to the commutator of the $x$ and $y$ operators and involves mixed derivatives, can lead to significant error accumulation in the naive scheme, often appearing as artifacts where the velocity field divergence is largest. The conservative scheme, by correctly formulating each split step as a conservation law, avoids the primary error source, leaving only the splitting error which concerns the solution's accuracy but not its total mass.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares a naive and a conservative dimensional splitting scheme\n    for the 2D advection equation, reporting the mass conservation error for each.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"Nx\": 64, \"Ny\": 64,\n            \"bx_func\": lambda x, y: np.cos(2 * np.pi * y),\n            \"by_func\": lambda x, y: -np.cos(2 * np.pi * x)\n        },\n        {\n            \"Nx\": 64, \"Ny\": 64,\n            \"bx_func\": lambda x, y: 2 * np.pi * np.sin(2 * np.pi * x) * (1 + 0.5 * np.cos(2 * np.pi * y)),\n            \"by_func\": lambda x, y: 2 * np.pi * np.sin(2 * np.pi * y) * (1 - 0.5 * np.cos(2 * np.pi * x))\n        },\n        {\n            \"Nx\": 32, \"Ny\": 32,\n            \"bx_func\": lambda x, y: 2 * np.pi * np.tanh(4 * np.sin(2 * np.pi * x) * np.cos(2 * np.pi * y)),\n            \"by_func\": lambda x, y: 2 * np.pi * np.tanh(4 * np.cos(2 * np.pi * x) * np.sin(2 * np.pi * y))\n        }\n    ]\n\n    results = []\n    CFL = 0.4\n    x0, y0, sigma = 0.3, 0.7, 0.05\n\n    for case in test_cases:\n        Nx, Ny = case[\"Nx\"], case[\"Ny\"]\n        bx_func, by_func = case[\"bx_func\"], case[\"by_func\"]\n\n        # Grid setup\n        dx = 1.0 / Nx\n        dy = 1.0 / Ny\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        y_centers = (np.arange(Ny) + 0.5) * dy\n        # Note: problem states faces at (i+1)dx, but meshgrid produces row/col vectors\n        # for XX, YY. This is fine for evaluation, but the coordinates are transposed.\n        # It's easier to think in (row, col) indices, so we use indexing='ij'.\n        XX_cen, YY_cen = np.meshgrid(x_centers, y_centers, indexing='ij')\n\n        x_faces = (np.arange(Nx) + 1.0) * dx\n        y_faces = (np.arange(Ny) + 1.0) * dy\n        XX_xf, YY_xf = np.meshgrid(x_faces, y_centers, indexing='ij')\n        XX_yf, YY_yf = np.meshgrid(x_centers, y_faces, indexing='ij')\n        \n        # Initial condition\n        u0 = np.exp(-((XX_cen - x0)**2 + (YY_cen - y0)**2) / (2 * sigma**2))\n        initial_mass = np.sum(u0) * dx * dy\n\n        # Time step calculation\n        bx_vals = np.concatenate([bx_func(XX_cen, YY_cen).flatten(), bx_func(XX_xf, YY_xf).flatten()])\n        by_vals = np.concatenate([by_func(XX_cen, YY_cen).flatten(), by_func(XX_yf, YY_yf).flatten()])\n        max_bx = np.max(np.abs(bx_vals)) if bx_vals.size > 0 else 0\n        max_by = np.max(np.abs(by_vals)) if by_vals.size > 0 else 0\n        \n        dt = CFL * min(dx / (max_bx + 1e-9), dy / (max_by + 1e-9))\n\n        # --- Scheme 1: Naive Splitting ---\n        u_naive = np.copy(u0)\n\n        # X-sweep (naive) - implements u_t = -b_x u_x\n        bx_center = bx_func(XX_cen, YY_cen)\n        bx_p = np.maximum(bx_center, 0)\n        bx_m = np.minimum(bx_center, 0)\n        u_im1 = np.roll(u_naive, 1, axis=0)\n        u_ip1 = np.roll(u_naive, -1, axis=0)\n        u_star = u_naive - (dt / dx) * (bx_p * (u_naive - u_im1) + bx_m * (u_ip1 - u_naive))\n        \n        # Y-sweep (naive) - implements u_t = -b_y u_y\n        # Note: XX_cen, YY_cen were created with 'ij', so axis 0 is x, axis 1 is y.\n        # But numpy arrays are (row, col) = (y, x). So axis 0 is y, axis 1 is x.\n        # Let's be consistent with numpy's (row, col) convention.\n        # XX_cen.shape is (Nx, Ny). u_naive.shape is (Nx, Ny). Let's assume (i, j) = (x_idx, y_idx).\n        # This is confusing. Let's fix meshgrid to 'xy' indexing and use (row=y, col=x).\n        XX_cen_xy, YY_cen_xy = np.meshgrid(x_centers, y_centers, indexing='xy')\n        u0_xy = np.exp(-((XX_cen_xy - x0)**2 + (YY_cen_xy - y0)**2) / (2 * sigma**2))\n        u_naive = np.copy(u0_xy) # Shape (Ny, Nx)\n        \n        bx_center = bx_func(XX_cen_xy, YY_cen_xy)\n        bx_p = np.maximum(bx_center, 0)\n        bx_m = np.minimum(bx_center, 0)\n        u_im1 = np.roll(u_naive, 1, axis=1) # roll along columns (x-dir)\n        u_ip1 = np.roll(u_naive, -1, axis=1)\n        u_star = u_naive - (dt / dx) * (bx_p * (u_naive - u_im1) + bx_m * (u_ip1 - u_naive))\n\n        by_center = by_func(XX_cen_xy, YY_cen_xy)\n        by_p = np.maximum(by_center, 0)\n        by_m = np.minimum(by_center, 0)\n        u_jm1 = np.roll(u_star, 1, axis=0) # roll along rows (y-dir)\n        u_jp1 = np.roll(u_star, -1, axis=0)\n        u_final_naive = u_star - (dt / dy) * (by_p * (u_star - u_jm1) + by_m * (u_jp1 - u_star))\n        \n        mass_naive = np.sum(u_final_naive) * dx * dy\n        error_naive = np.abs(mass_naive - initial_mass)\n        results.append(error_naive)\n\n        # --- Scheme 2: Conservative Splitting ---\n        u_cons = np.copy(u0_xy)\n\n        # X-sweep (conservative)\n        XX_xf_xy, YY_xf_xy = np.meshgrid(x_faces, y_centers, indexing='xy') # (Ny, Nx)\n        bx_face = bx_func(XX_xf_xy, YY_xf_xy)\n        bx_face_p = np.maximum(bx_face, 0)\n        bx_face_m = np.minimum(bx_face, 0)\n        u_ip1 = np.roll(u_cons, -1, axis=1)\n        flux_x = bx_face_p * u_cons + bx_face_m * u_ip1\n        flux_x_im1 = np.roll(flux_x, 1, axis=1)\n        u_star_cons = u_cons - (dt / dx) * (flux_x - flux_x_im1)\n\n        # Y-sweep (conservative)\n        XX_yf_xy, YY_yf_xy = np.meshgrid(x_centers, y_faces, indexing='xy') # (Ny, Nx)\n        by_face = by_func(XX_yf_xy, YY_yf_xy)\n        by_face_p = np.maximum(by_face, 0)\n        by_face_m = np.minimum(by_face, 0)\n        u_jp1 = np.roll(u_star_cons, -1, axis=0)\n        flux_y = by_face_p * u_star_cons + by_face_m * u_jp1\n        flux_y_jm1 = np.roll(flux_y, 1, axis=0)\n        u_final_cons = u_star_cons - (dt / dy) * (flux_y - flux_y_jm1)\n\n        mass_cons = np.sum(u_final_cons) * dx * dy\n        error_cons = np.abs(mass_cons - initial_mass)\n        results.append(error_cons)\n\n    # Print results in the specified format\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Finally, we explore an advanced and powerful application of dimensional splitting beyond direct time integration: preconditioning. For many complex problems, implicit time-stepping methods are necessary for stability, but they require solving large, ill-conditioned linear systems. This practice demonstrates how an Alternating Direction Implicit (ADI) splitting can be used to construct an efficient preconditioner for an anisotropic diffusion operator, showing how the effectiveness of the preconditioner is linked to the orientation of the physical anisotropy .",
            "id": "3377961",
            "problem": "Consider the anisotropic diffusion operator for porous media flow, given by the divergence-form partial differential equation $-\\nabla\\cdot\\left(K(x,y)\\nabla p(x,y,t)\\right)=q(x,y,t)$ on the unit square domain $[0,1]\\times[0,1]$ with homogeneous Dirichlet boundary conditions $p=0$ on $\\partial\\Omega$. In a backward implicit transient formulation with time step $\\Delta t$, each time step requires solving a linear system of the form $(I-\\Delta t\\,L)\\,p^{n+1}=b^n$, where $I$ is the identity operator, $L$ is the spatial discretization of $-\\nabla\\cdot\\left(K\\nabla\\cdot\\right)$, and $b^n$ is the known right-hand side. Alternating Direction Implicit (ADI) splitting introduces a preconditioner $M$ built from directional components of $L$.\n\nYour task is to construct a dimensional-splitting ADI preconditioner for the elliptic solve inside the transient step and study how the eigenvalue clustering of the preconditioned operator varies with the orientation of the anisotropy tensor. Use the following scientifically standard foundations:\n\n- The anisotropy tensor is constant in space and given by $K=R(\\theta)\\,\\mathrm{diag}(k_\\parallel,k_\\perp)\\,R(\\theta)^\\top$, where $R(\\theta)=\\begin{pmatrix}\\cos\\theta-\\sin\\theta\\\\\\sin\\theta\\cos\\theta\\end{pmatrix}$ is the rotation matrix, $k_\\parallel\\ge k_\\perp0$ are the principal diffusivities, and $\\theta$ is the orientation angle measured in radians.\n- For constant coefficients, the operator reduces to $-\\nabla\\cdot(K\\nabla p)=-(K_{xx}\\,\\partial_{xx}p+2K_{xy}\\,\\partial_{xy}p+K_{yy}\\,\\partial_{yy}p)$, where $K_{xx}$, $K_{xy}$, and $K_{yy}$ are the components of $K$ in the coordinate frame.\n- Use second-order centered finite differences on a uniform grid with $N$ interior points per coordinate direction, grid spacing $h=1/(N+1)$, and homogeneous Dirichlet boundary conditions. Discretize:\n  1. The one-dimensional second derivative as a tridiagonal matrix $D_{xx}\\in\\mathbb{R}^{N\\times N}$ with diagonal entries $-2/h^2$ and off-diagonal entries $1/h^2$.\n  2. The one-dimensional first derivative as a tridiagonal matrix $D_x\\in\\mathbb{R}^{N\\times N}$ with upper diagonal entries $1/(2h)$ and lower diagonal entries $-1/(2h)$ (entries at missing neighbors implicitly multiply boundary values which are zero).\n- Form the two-dimensional discrete operators via Kronecker products:\n  1. $A_{xx}=-K_{xx}\\,(D_{xx}\\otimes I_N)$,\n  2. $A_{yy}=-K_{yy}\\,(I_N\\otimes D_{xx})$,\n  3. $A_{xy}=-2K_{xy}\\,(D_x\\otimes D_x)$,\n  where $I_N$ is the $N\\times N$ identity and $\\otimes$ denotes the Kronecker product. The full discrete operator is $A=A_{xx}+A_{yy}+A_{xy}\\in\\mathbb{R}^{N^2\\times N^2}$.\n- Construct the transient step matrix $S=I_{N^2}-\\Delta t\\,A$, and the ADI split preconditioner $M=(I_{N^2}-\\Delta t\\,A_x)(I_{N^2}-\\Delta t\\,A_y)$, where $A_x=A_{xx}$ and $A_y=A_{yy}$ (exclude the mixed-derivative contribution from the preconditioner).\n- Quantify eigenvalue clustering by computing the generalized eigenvalues $\\{\\lambda_i\\}$ of the pencil $(S,M)$, defined by $(I_{N^2}-\\Delta t\\,A)\\,v_i=\\lambda_i\\,M\\,v_i$, and then reporting the clustering radius $R=\\max_i|\\lambda_i-1|$ as a single scalar.\n\nImplement a complete, runnable program that:\n- Builds $S$ and $M$ according to the above specification.\n- Computes the generalized eigenvalues and the clustering radius $R$.\n- Evaluates $R$ over the following test suite, with angles specified in radians:\n  1. $(N,\\Delta t,k_\\parallel,k_\\perp,\\theta)=(12,10^{-5},10,1,0)$,\n  2. $(12,10^{-5},10,1,\\pi/4)$,\n  3. $(12,10^{-5},1,1,\\pi/6)$,\n  4. $(12,10^{-5},100,1,\\pi/8)$,\n  5. $(12,10^{-5},10,1,\\pi/2)$,\n  6. $(12,10^{-5},10,1,0.01)$.\nYour program should produce a single line of output containing the clustering radius for each test case as a comma-separated list enclosed in square brackets, with each float rounded to six decimal places (unitless).\n\nYour answer must be a complete, runnable program, written in Python, implementing the above algorithm using the specified numerical libraries. The final output format must be exactly \"[r1,r2,r3,r4,r5,r6]\".",
            "solution": "The user has requested the construction and analysis of a dimensional-splitting Alternating Direction Implicit (ADI) preconditioner for an anisotropic diffusion equation. The analysis involves quantifying the clustering of eigenvalues of the preconditioned operator.\n\n### Step 1: Problem Validation\n\nThe problem statement will first be validated against the required criteria.\n\n#### Step 1.1: Extract Givens\n\n-   **PDE**: $-\\nabla\\cdot\\left(K(x,y)\\nabla p(x,y,t)\\right)=q(x,y,t)$ on $[0,1]\\times[0,1]$.\n-   **Boundary Conditions**: Homogeneous Dirichlet, $p=0$ on $\\partial\\Omega$.\n-   **Transient Formulation**: Backward implicit, requires solving $(I-\\Delta t\\,L)\\,p^{n+1}=b^n$.\n-   **Anisotropy Tensor**: $K=R(\\theta)\\,\\mathrm{diag}(k_\\parallel,k_\\perp)\\,R(\\theta)^\\top$, with $R(\\theta)=\\begin{pmatrix}\\cos\\theta-\\sin\\theta\\\\\\sin\\theta\\cos\\theta\\end{pmatrix}$. $K$ is constant in space.\n-   **Spatial Operator Expansion**: $L = -\\nabla\\cdot(K\\nabla\\cdot) = -(K_{xx}\\,\\partial_{xx}+2K_{xy}\\,\\partial_{xy}+K_{yy}\\,\\partial_{yy})$.\n-   **Discretization Grid**: Uniform grid with $N$ interior points per direction, grid spacing $h=1/(N+1)$.\n-   **1D Discrete Operators**:\n    -   Second derivative: $D_{xx} \\in \\mathbb{R}^{N\\times N}$ is tridiagonal with diagonal entries $-2/h^2$ and off-diagonal entries $1/h^2$.\n    -   First derivative: $D_x \\in \\mathbb{R}^{N\\times N}$ is tridiagonal with upper diagonal $1/(2h)$ and lower diagonal $-1/(2h)$.\n-   **2D Discrete Operators**: Formed via Kronecker product $\\otimes$ with $I_N$ (the $N\\times N$ identity).\n    -   $A_{xx}=-K_{xx}\\,(D_{xx}\\otimes I_N)$\n    -   $A_{yy}=-K_{yy}\\,(I_N\\otimes D_{xx})$\n    -   $A_{xy}=-2K_{xy}\\,(D_x\\otimes D_x)$\n    -   Full discrete operator: $A=A_{xx}+A_{yy}+A_{xy} \\in \\mathbb{R}^{N^2\\times N^2}$.\n-   **Transient System Matrix**: $S=I_{N^2}-\\Delta t\\,A$.\n-   **ADI Preconditioner**: $M=(I_{N^2}-\\Delta t\\,A_x)(I_{N^2}-\\Delta t\\,A_y)$, with $A_x=A_{xx}$ and $A_y=A_{yy}$.\n-   **Analysis Metric**: Clustering radius $R=\\max_i|\\lambda_i-1|$, where $\\{\\lambda_i\\}$ are the generalized eigenvalues from the pencil $(S,M)$, solving $(I_{N^2}-\\Delta t\\,A)\\,v_i=\\lambda_i\\,M\\,v_i$.\n-   **Test Suite**:\n    1.  $(N,\\Delta t,k_\\parallel,k_\\perp,\\theta)=(12,10^{-5},10,1,0)$\n    2.  $(12,10^{-5},10,1,\\pi/4)$\n    3.  $(12,10^{-5},1,1,\\pi/6)$\n    4.  $(12,10^{-5},100,1,\\pi/8)$\n    5.  $(12,10^{-5},10,1,\\pi/2)$\n    6.  $(12,10^{-5},10,1,0.01)$\n\n#### Step 1.2: Validate Using Extracted Givens\n\n1.  **Scientifically Grounded**: The problem is firmly based on the standard theory of numerical methods for partial differential equations. The anisotropic diffusion equation, backward Euler time-stepping, finite difference discretization, Kronecker product construction for 2D operators, and ADI preconditioning are all canonical topics in computational science and engineering.\n2.  **Well-Posed**: The problem is well-posed. All parameters, matrices, and procedures are explicitly defined, leading to a unique numerical result for each test case. The matrices involved are well-defined, and for the given parameters, they will be non-singular, ensuring that the generalized eigenvalue problem has a solution.\n3.  **Objective**: The problem is stated using precise, objective mathematical language. There are no subjective or opinion-based claims.\n4.  **Complete and Consistent**: The problem is self-contained. All necessary information, including the mathematical formulation, discretization details, parameter values, and the precise metric for analysis, is provided. There are no contradictions.\n5.  **Topic Relevance**: The problem is squarely within the specified topic of *dimensional splitting for multidimensional PDEs*.\n\n#### Step 1.3: Verdict and Action\n\nThe problem is valid. It is a well-defined, scientifically sound numerical experiment. I will proceed to construct the solution.\n\n### Step 2: Solution Construction\n\nThe solution involves implementing the specified matrix constructions and eigenvalue analysis for each test case. The core of the method is translating the continuous operators into discrete matrix form and then analyzing the spectral properties of the resulting preconditioned system.\n\nFor each test case, specified by the tuple $(N, \\Delta t, k_\\parallel, k_\\perp, \\theta)$:\n\n1.  **Set up Discretization Parameters**: The grid spacing is $h = 1/(N+1)$. The total number of interior grid points is $N^2$.\n\n2.  **Construct 1D Finite Difference Matrices**:\n    -   The matrix $D_{xx}$ discretizes the second derivative $\\partial_{xx}$. For an $N \\times N$ matrix, its entries are $(D_{xx})_{i,j} = (1/h^2)(\\delta_{i,j-1} - 2\\delta_{i,j} + \\delta_{i,j+1})$, where $\\delta$ is the Kronecker delta. This corresponds to the specified tridiagonal matrix.\n    -   The matrix $D_x$ discretizes the first derivative $\\partial_x$ using a central difference scheme. Its entries are $(D_x)_{i,j} = (1/(2h))(\\delta_{i,j-1} - \\delta_{i,j+1})$. This corresponds to the specified bidiagonal matrix (with a zero main diagonal).\n\n3.  **Calculate Anisotropy Tensor Components**: The components of the constant tensor $K$ are computed from the principal diffusivities $k_\\parallel, k_\\perp$ and the orientation angle $\\theta$.\n    $$K=R(\\theta)\\begin{pmatrix}k_\\parallel0\\\\0k_\\perp\\end{pmatrix}R(\\theta)^\\top = \\begin{pmatrix} k_\\parallel c^2 + k_\\perp s^2  (k_\\parallel - k_\\perp) sc \\\\ (k_\\parallel - k_\\perp) sc  k_\\parallel s^2 + k_\\perp c^2 \\end{pmatrix}$$\n    where $c = \\cos\\theta$ and $s = \\sin\\theta$. From this, we identify $K_{xx}$, $K_{yy}$, and $K_{xy}$.\n\n4.  **Construct 2D Operator Matrices**: The 2D operators on the lexicographically ordered grid vector of unknowns are formed using Kronecker products.\n    -   The discrete Laplacian components are $L_{xx} = D_{xx} \\otimes I_N$ and $L_{yy} = I_N \\otimes D_{xx}$.\n    -   The mixed derivative term is $L_{xy} = D_x \\otimes D_x$.\n    -   The full spatial operator matrix is $A = -K_{xx}L_{xx} - K_{yy}L_{yy} - 2K_{xy}L_{xy}$. The signs are negative because the operator $L$ in the transient equation is defined as $L = -\\nabla\\cdot(K\\nabla\\cdot)$.\n\n5.  **Formulate Transient System and Preconditioner**:\n    -   The matrix for the backward implicit step is $S = I_{N^2} - \\Delta t A$.\n    -   The ADI preconditioner is constructed by splitting $A$ into its directional components $A_x = -K_{xx}L_{xx}$ and $A_y = -K_{yy}L_{yy}$, and ignoring the mixed-derivative term $A_{xy}$. The preconditioner is $M = (I_{N^2} - \\Delta t A_x)(I_{N^2} - \\Delta t A_y)$. This factorization is efficient to apply in practice, as it involves solving only tridiagonal systems.\n\n6.  **Analyze Eigenvalue Clustering**: The effectiveness of $M$ as a preconditioner for $S$ is studied by examining the eigenvalues $\\lambda_i$ of the preconditioned operator $M^{-1}S$. These are the solutions to the generalized eigenvalue problem $S v_i = \\lambda_i M v_i$. The clustering radius $R = \\max_i |\\lambda_i-1|$ measures the maximum deviation of these eigenvalues from $1$. A smaller $R$ indicates that the eigenvalues are more tightly clustered around $1$, which typically leads to faster convergence for Krylov subspace solvers like GMRES. The generalized eigenvalues are computed using a standard numerical library function.\n\nThe final Python code implements this procedure for all specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eig\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, Δt, k_parallel, k_perp, θ in radians)\n        (12, 1e-5, 10, 1, 0),\n        (12, 1e-5, 10, 1, np.pi/4),\n        (12, 1e-5, 1, 1, np.pi/6),\n        (12, 1e-5, 100, 1, np.pi/8),\n        (12, 1e-5, 10, 1, np.pi/2),\n        (12, 1e-5, 10, 1, 0.01),\n    ]\n\n    results = []\n    for N, dt, k_parallel, k_perp, theta in test_cases:\n        # ---- Discretization setup ----\n        # Grid spacing h for N interior points on [0,1]\n        h = 1.0 / (N + 1)\n        N_sq = N**2\n\n        # ---- Build 1D finite difference matrices ----\n        # D_xx for second derivative: [1, -2, 1]/h^2\n        diag_xx = -2.0 / h**2 * np.ones(N)\n        offdiag_xx = 1.0 / h**2 * np.ones(N - 1)\n        D_xx = np.diag(diag_xx) + np.diag(offdiag_xx, k=1) + np.diag(offdiag_xx, k=-1)\n\n        # D_x for first derivative: [-1, 0, 1]/(2h)\n        offdiag_x_upper = 1.0 / (2.0 * h) * np.ones(N - 1)\n        offdiag_x_lower = -1.0 / (2.0 * h) * np.ones(N - 1)\n        D_x = np.diag(offdiag_x_upper, k=1) + np.diag(offdiag_x_lower, k=-1)\n\n        I_N = np.eye(N)\n        I_N2 = np.eye(N_sq)\n\n        # ---- Calculate anisotropy tensor K components ----\n        c, s = np.cos(theta), np.sin(theta)\n        K_xx = k_parallel * c**2 + k_perp * s**2\n        K_yy = k_parallel * s**2 + k_perp * c**2\n        K_xy = (k_parallel - k_perp) * s * c\n\n        # ---- Build 2D operator matrices via Kronecker products ----\n        # The operator is L = -(K_xx*d_xx + 2*K_xy*d_xy + K_yy*d_yy)\n        # So A is the discretization of L.\n        A_xx_op = -K_xx * np.kron(D_xx, I_N)\n        A_yy_op = -K_yy * np.kron(I_N, D_xx)\n        A_xy_op = -2 * K_xy * np.kron(D_x, D_x)\n        A = A_xx_op + A_yy_op + A_xy_op\n\n        # ---- Build transient matrix S and ADI preconditioner M ----\n        S = I_N2 - dt * A\n        \n        # M is built from the ADI splitting, ignoring the mixed-derivative term\n        # The split operators Ax and Ay are defined as Axx and Ayy in the prompt.\n        M = (I_N2 - dt * A_xx_op) @ (I_N2 - dt * A_yy_op)\n\n        # ---- Compute generalized eigenvalues and clustering radius ----\n        # Solves the generalized eigenvalue problem S v = λ M v for eigenvalues λ\n        lambdas = eig(S, M, right=False)\n\n        # The clustering radius R = max|λ_i - 1|\n        R = np.max(np.abs(lambdas - 1.0))\n        results.append(R)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}