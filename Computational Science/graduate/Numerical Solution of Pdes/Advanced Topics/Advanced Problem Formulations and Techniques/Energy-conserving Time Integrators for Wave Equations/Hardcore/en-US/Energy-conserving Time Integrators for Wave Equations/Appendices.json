{
    "hands_on_practices": [
        {
            "introduction": "The foundation of many energy-conserving schemes is the discrete gradient method. This first practice challenges you to implement this core engine for a general, separable Hamiltonian system representing a semi-discretized wave equation . By employing a specific discrete gradient for the nonlinear potential energy, you will construct an implicit integrator that guarantees exact conservation of the discrete energy, a crucial skill in geometric numerical integration.",
            "id": "3384894",
            "problem": "Consider the semi-discrete wave equation in canonical form, obtained by introducing the generalized momentum $p$ via $p = M \\dot{q}$, where $M$ is a symmetric positive-definite mass matrix:\n$$\n\\dot{q} = M^{-1} p, \\quad \\dot{p} = -K q - g(q),\n$$\nwith symmetric positive-definite stiffness matrix $K$, and nonlinear restoring force $g(q)$ that is assumed to be the gradient of a scalar potential $G(q)$, i.e., $g(q) = \\nabla G(q)$. The associated Hamiltonian is\n$$\nH(q,p) = \\tfrac{1}{2} q^\\top K q + G(q) + \\tfrac{1}{2} p^\\top M^{-1} p.\n$$\n\nAn energy-conserving time integrator can be constructed by the discrete gradient method for Hamiltonian systems of the form $\\dot{x} = S \\nabla H(x)$, where $S$ is a constant skew-symmetric matrix. For canonical variables $x = (q, p)$, $S$ has block form $S = \\begin{pmatrix} 0  I \\\\ -I  0 \\end{pmatrix}$, with $I$ the identity matrix. A discrete gradient $\\overline{\\nabla} H(x^n, x^{n+1})$ is any map that satisfies the fundamental mean value property\n$$\nH(x^{n+1}) - H(x^n) = \\overline{\\nabla} H(x^n, x^{n+1}) \\cdot (x^{n+1} - x^n),\n$$\nand is consistent with the exact gradient in the limit $x^{n+1} \\to x^n$. Using such a discrete gradient, the implicit one-step method\n$$\n\\frac{x^{n+1} - x^n}{\\Delta t} = S \\, \\overline{\\nabla} H(x^n, x^{n+1})\n$$\nis energy-conserving, because $S$ is skew-symmetric.\n\nYour task is to implement this method using the Gonzalez discrete gradient for the Hamiltonian $H(q,p)$ of the semi-discrete wave equation. For a separable Hamiltonian $H(q,p) = V(q) + T(p)$, with $V(q) = \\tfrac{1}{2} q^\\top K q + G(q)$ and $T(p) = \\tfrac{1}{2} p^\\top M^{-1} p$, you should construct a block discrete gradient that preserves the mean value property\n$$\nH(q^{n+1},p^{n+1}) - H(q^n,p^n) = \\overline{\\nabla}_q V(q^n, q^{n+1}) \\cdot (q^{n+1} - q^n) + \\overline{\\nabla}_p T(p^n, p^{n+1}) \\cdot (p^{n+1} - p^n).\n$$\nThe discrete gradient for the quadratic terms should be consistent with their exact gradients evaluated appropriately to satisfy the mean value property, and the discrete gradient for $G(q)$ should be the Gonzalez discrete gradient constructed to satisfy the mean value property for the scalar function $G$.\n\nStarting from the fundamental laws and core definitions for Hamiltonian systems and the mean value property of discrete gradients, derive and implement a robust Newton-type solver for the implicit update equations in $(q^{n+1}, p^{n+1})$. The implementation must:\n- Accept symmetric positive-definite matrices $M$ and $K$.\n- Accept a polynomial potential $G(q)$ with $g(q) = \\nabla G(q)$.\n- Use the Gonzalez discrete gradient for $G(q)$ to ensure exact discrete energy conservation at the algebraic level.\n- Verify energy conservation numerically by computing the Hamiltonian $H(q,p)$ along the numerical trajectory and reporting the maximum absolute deviation from the initial energy over the integration window.\n\nAll quantities are dimensionless. Angles do not appear. The final numerical results must be floats.\n\nTest Suite:\nImplement the program to run the integrator and report the maximum absolute Hamiltonian deviation $E_{\\max}$ for each of the following four cases with specified parameters:\n\n1. One-dimensional linear oscillator (happy path):\n   - $M = [1.0]$, $K = [1.0]$, $G(q) = 0$.\n   - Initial state: $q(0) = 1.0$, $p(0) = 0.0$.\n   - Time step: $\\Delta t = 0.05$.\n   - Steps: $N = 200$.\n\n2. One-dimensional quartic nonlinearity:\n   - $M = [1.5]$, $K = [0.7]$, $G(q) = \\lambda \\tfrac{q^4}{4}$ with $\\lambda = 0.3$, so $g(q) = \\lambda q^3$.\n   - Initial state: $q(0) = 0.2$, $p(0) = 0.3$.\n   - Time step: $\\Delta t = 0.02$.\n   - Steps: $N = 500$.\n\n3. Two-dimensional coupled polynomial potential:\n   - $M = \\mathrm{diag}(1.0, 2.0)$, $K = \\begin{pmatrix} 2.0  0.3 \\\\ 0.3  1.5 \\end{pmatrix}$.\n   - $G(q) = \\alpha \\tfrac{q_1^4 + q_2^4}{4} + \\beta \\tfrac{q_1^2 q_2^2}{2}$, with $\\alpha = 0.2$, $\\beta = 0.1$.\n   - Thus $g(q) = \\begin{pmatrix} \\alpha q_1^3 + \\beta q_1 q_2^2 \\\\ \\alpha q_2^3 + \\beta q_2 q_1^2 \\end{pmatrix}$.\n   - Initial state: $q(0) = (0.1, -0.2)$, $p(0) = (0.0, 0.25)$.\n   - Time step: $\\Delta t = 0.015$.\n   - Steps: $N = 400$.\n\n4. One-dimensional trivial equilibrium (edge case):\n   - $M = [1.0]$, $K = [2.0]$, $G(q) = \\tfrac{1}{4} q^4$, so $g(q) = q^3$.\n   - Initial state: $q(0) = 0.0$, $p(0) = 0.0$.\n   - Time step: $\\Delta t = 0.1$.\n   - Steps: $N = 10$.\n\nOutput format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is the maximum absolute Hamiltonian deviation $E_{\\max}$ for the corresponding test case in the order listed above. For example, the output format must be exactly:\n$$\n[\\text{E1},\\text{E2},\\text{E3},\\text{E4}]\n$$\nwith each $\\text{E}$ a floating-point number.",
            "solution": "The user has provided a well-defined problem in the field of geometric numerical integration. The task is to implement an energy-conserving time integrator for a canonical Hamiltonian system using the discrete gradient method, specifically with a Gonzalez-type discrete gradient for the nonlinear potential. The problem is scientifically sound, self-contained, and all parameters for the test cases are provided. The problem is deemed valid.\n\nHere follows the derivation and explanation of the numerical method.\n\nThe system is described by the canonical Hamiltonian equations:\n$$\n\\dot{q} = M^{-1} p, \\quad \\dot{p} = -K q - g(q)\n$$\nwhere $q$ are the generalized coordinates, $p$ are the generalized momenta, $M$ is the mass matrix, and $K$ is the stiffness matrix. The force $g(q)$ is the gradient of a potential, $g(q) = \\nabla G(q)$. The Hamiltonian, representing the total energy of the system, is a separable function of $q$ and $p$:\n$$\nH(q,p) = V(q) + T(p) = \\left(\\tfrac{1}{2} q^\\top K q + G(q)\\right) + \\left(\\tfrac{1}{2} p^\\top M^{-1} p\\right)\n$$\nThe system can be written in the compact form $\\dot{x} = S \\nabla H(x)$, with $x=(q, p)$ and $S = \\begin{pmatrix} 0  I \\\\ -I  0 \\end{pmatrix}$.\n\nThe discrete gradient method provides a general framework for constructing energy-conserving schemes. The update from time step $n$ to $n+1$ is given by the implicit rule:\n$$\n\\frac{x^{n+1} - x^n}{\\Delta t} = S \\, \\overline{\\nabla} H(x^n, x^{n+1})\n$$\nwhere $\\Delta t$ is the time step, and $\\overline{\\nabla} H$ is a discrete gradient of the Hamiltonian $H$. A discrete gradient must satisfy the mean value property $H(x^{n+1}) - H(x^n) = \\overline{\\nabla} H(x^n, x^{n+1}) \\cdot (x^{n+1} - x^n)$ and be consistent with the true gradient, $\\overline{\\nabla} H(x, x) = \\nabla H(x)$. The energy conservation of the method follows directly from the mean value property and the skew-symmetry of $S$:\n$$\nH(x^{n+1}) - H(x^n) = (x^{n+1} - x^n)^\\top \\overline{\\nabla} H = (\\Delta t \\, S \\, \\overline{\\nabla} H)^\\top \\overline{\\nabla} H = \\Delta t (\\overline{\\nabla} H)^\\top S^\\top \\overline{\\nabla} H = -\\Delta t (\\overline{\\nabla} H)^\\top S \\overline{\\nabla} H = 0\n$$\nThe last equality holds because for any vector $v$, $v^\\top S v = 0$ if $S$ is skew-symmetric. Thus, $H(x^{n+1}) = H(x^n)$ for all $n$.\n\nFor a separable Hamiltonian, we use a separable discrete gradient:\n$$\n\\overline{\\nabla} H(x^n, x^{n+1}) = \\begin{pmatrix} \\overline{\\nabla}_q V(q^n, q^{n+1}) \\\\ \\overline{\\nabla}_p T(p^n, p^{n+1}) \\end{pmatrix}\n$$\nSubstituting this into the update rule gives a pair of coupled equations:\n$$\n\\frac{q^{n+1} - q^n}{\\Delta t} = \\overline{\\nabla}_p T(p^n, p^{n+1}) \\quad (1)\n$$\n$$\n\\frac{p^{n+1} - p^n}{\\Delta t} = -\\overline{\\nabla}_q V(q^n, q^{n+1}) \\quad (2)\n$$\n\nWe must now define the specific discrete gradients.\nFor the quadratic kinetic energy $T(p) = \\frac{1}{2} p^\\top M^{-1} p$, a suitable discrete gradient that satisfies the mean value property is the midpoint gradient:\n$$\n\\overline{\\nabla}_p T(p^n, p^{n+1}) = \\nabla_p T \\left( \\frac{p^n + p^{n+1}}{2} \\right) = M^{-1} \\left( \\frac{p^n + p^{n+1}}{2} \\right)\n$$\nSimilarly, for the quadratic part of the potential energy, $\\frac{1}{2} q^\\top K q$, we use:\n$$\n\\overline{\\nabla}_q \\left(\\tfrac{1}{2} q^\\top K q\\right)(q^n, q^{n+1}) = K \\left( \\frac{q^n + q^{n+1}}{2} \\right)\n$$\nFor the nonlinear potential $G(q)$, we use the Gonzalez discrete gradient. For potentials that are sums of products of functions of single coordinates, a symmetric form can be derived. For a polynomial potential $G(q)$ with dimension $d$, its components $\\overline{g}_i(q^n, q^{n+1}) = (\\overline{\\nabla}G(q^n, q^{n+1}))_i$ are constructed to satisfy the mean value property. For the potentials in the test suite, this leads to specific algebraic expressions that are implemented directly. For example, for a 1D potential $G(q)$, $\\overline{\\nabla}G(q^n, q^{n+1}) = (G(q^{n+1})-G(q^n))/(q^{n+1}-q^n)$ if $q^{n+1} \\neq q^n$, and $\\nabla G(q^n)$ otherwise. For polynomial potentials, this can be written in a numerically stable polynomial form.\n\nThe full update equations are:\n$$\nq^{n+1} - q^n - \\frac{\\Delta t}{2} M^{-1} (p^n + p^{n+1}) = 0\n$$\n$$\np^{n+1} - p^n + \\frac{\\Delta t}{2} K (q^n + q^{n+1}) + \\Delta t \\, \\overline{\\nabla}G(q^n, q^{n+1}) = 0\n$$\nThis is a system of $2d$ nonlinear algebraic equations for the unknown state $(q^{n+1}, p^{n+1})$. We solve this system using Newton's method. Let the unknowns be $y = (q^{n+1}, p^{n+1})$ and the system of equations be $F(y) = 0$. The Newton iteration is $y_{k+1} = y_k - [J_F(y_k)]^{-1} F(y_k)$, where $J_F$ is the Jacobian of $F$. The iteration starts with an initial guess, e.g., $y_0 = (q^n, p^n)$.\n\nThe residual vector is $F(y_k) = (F_q, F_p)$ where $y_k = (q_k, p_k)$:\n$$\nF_q(q_k, p_k) = q_k - q^n - \\frac{\\Delta t}{2} M^{-1} (p^n + p_k)\n$$\n$$\nF_p(q_k, p_k) = p_k - p^n + \\frac{\\Delta t}{2} K (q^n + q_k) + \\Delta t \\, \\overline{\\nabla}G(q^n, q_k)\n$$\nThe Jacobian matrix $J_F = \\frac{\\partial F}{\\partial y}$ is given by:\n$$\nJ_F = \\begin{pmatrix} \\partial F_q / \\partial q_k  \\partial F_q / \\partial p_k \\\\ \\partial F_p / \\partial q_k  \\partial F_p / \\partial p_k \\end{pmatrix} = \\begin{pmatrix} I  -\\frac{\\Delta t}{2} M^{-1} \\\\ \\frac{\\Delta t}{2} K + \\Delta t J_{\\overline{g}}  I \\end{pmatrix}\n$$\nwhere $J_{\\overline{g}} = \\frac{\\partial}{\\partial q_k} \\overline{\\nabla}G(q^n, q_k)$ is the Jacobian of the discrete gradient of $G$. The Newton update step involves solving the linear system $J_F \\Delta y = -F$ for the update $\\Delta y = (\\Delta q, \\Delta p)$. This $2d \\times 2d$ system can be solved more efficiently by block elimination. We solve for $\\Delta q$ first from the $d \\times d$ system:\n$$\n\\left( \\frac{2}{\\Delta t} M + \\frac{\\Delta t}{2} K + \\Delta t J_{\\overline{g}} \\right) \\Delta q = -F_p - \\frac{2}{\\Delta t} M F_q\n$$\nand then find $\\Delta p$ via substitution:\n$$\n\\Delta p = \\frac{2}{\\Delta t} M (\\Delta q + F_q)\n$$\nThis procedure is repeated until the norm of the residual $F$ or the update $\\Delta y$ is below a chosen tolerance. The implementation will use this Newton-based solver to advance the system in time for each test case and report the maximum deviation in the numerically computed Hamiltonian.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the energy-conserving integrator.\n    \"\"\"\n\n    def get_hamiltonian_func(M, K, G_func):\n        \"\"\"Constructs the Hamiltonian function for a given system.\"\"\"\n        M_inv = np.linalg.inv(M)\n        def hamiltonian(q, p):\n            T = 0.5 * p.T @ M_inv @ p\n            V_lin = 0.5 * q.T @ K @ q\n            V_nonlin = G_func(q)\n            return float(T + V_lin + V_nonlin)\n        return hamiltonian\n\n    def newton_solver(q_n, p_n, M, K, dG_disc_func, J_dG_disc_func, dt, tol=1e-13, max_iter=20):\n        \"\"\"\n        Solves the implicit update equations for one time step using Newton's method.\n        \"\"\"\n        dim = len(q_n)\n        M_inv = np.linalg.inv(M)\n        \n        # Initial guess for (q_{n+1}, p_{n+1})\n        q_k = np.copy(q_n)\n        p_k = np.copy(p_n)\n\n        for _ in range(max_iter):\n            # Evaluate residuals F_q, F_p\n            F_q = q_k - q_n - (dt / 2.0) * M_inv @ (p_n + p_k)\n            \n            dG = dG_disc_func(q_n, q_k)\n            F_p = p_k - p_n + (dt / 2.0) * K @ (q_n + q_k) + dt * dG\n            \n            residual_norm = np.linalg.norm(np.concatenate([F_q, F_p]))\n            if residual_norm  tol:\n                return q_k, p_k\n            \n            # Evaluate Jacobian of the discrete gradient of G\n            J_dG = J_dG_disc_func(q_n, q_k)\n            \n            # Form and solve the linear system for the update (dq, dp)\n            # A * dq = b\n            A = (2.0 / dt) * M + (dt / 2.0) * K + dt * J_dG\n            b = -F_p - (2.0 / dt) * M @ F_q\n            \n            dq = np.linalg.solve(A, b)\n            dp = (2.0 / dt) * M @ (dq + F_q)\n            \n            q_k += dq\n            p_k += dp\n\n        # Return the last computed value if max_iter is reached.\n        # For this problem setup, convergence should be rapid.\n        return q_k, p_k\n\n    def run_simulation(case):\n        \"\"\"\n        Runs a full simulation for a given test case configuration.\n        \"\"\"\n        M, K = case[\"M\"], case[\"K\"]\n        G_func = case[\"G\"]\n        dG_disc_func = case[\"dG_disc\"]\n        J_dG_disc_func = case[\"J_dG_disc\"]\n        q, p = case[\"q0\"], case[\"p0\"]\n        dt, N = case[\"dt\"], case[\"N\"]\n\n        H_func = get_hamiltonian_func(M, K, G_func)    \n        \n        energies = np.zeros(N + 1)\n        energies[0] = H_func(q, p)\n\n        for i in range(N):\n            q, p = newton_solver(q, p, M, K, dG_disc_func, J_dG_disc_func, dt)\n            energies[i+1] = H_func(q, p)\n            \n        initial_energy = energies[0]\n        max_dev = np.max(np.abs(energies - initial_energy))\n        \n        return max_dev\n\n    # --- Test Case Definitions ---\n\n    # Case 1: 1D Linear Oscillator\n    case1 = {\n        \"M\": np.array([[1.0]]), \"K\": np.array([[1.0]]),\n        \"G\": lambda q: 0.0,\n        \"dG_disc\": lambda q0, q1: np.array([0.0]),\n        \"J_dG_disc\": lambda q0, q1: np.array([[0.0]]),\n        \"q0\": np.array([1.0]), \"p0\": np.array([0.0]),\n        \"dt\": 0.05, \"N\": 200,\n    }\n\n    # Case 2: 1D Quartic Nonlinearity\n    lam = 0.3\n    case2 = {\n        \"M\": np.array([[1.5]]), \"K\": np.array([[0.7]]),\n        \"G\": lambda q: lam * q[0]**4 / 4.0,\n        \"dG_disc\": lambda q0, q1: np.array([\n            lam/4.0 * (q1[0]**3 + q1[0]**2*q0[0] + q1[0]*q0[0]**2 + q0[0]**3)\n        ]),\n        \"J_dG_disc\": lambda q0, q1: np.array([[\n            lam/4.0 * (3*q1[0]**2 + 2*q1[0]*q0[0] + q0[0]**2)\n        ]]),\n        \"q0\": np.array([0.2]), \"p0\": np.array([0.3]),\n        \"dt\": 0.02, \"N\": 500,\n    }\n\n    # Case 3: 2D Coupled Polynomial Potential\n    alpha, beta = 0.2, 0.1\n    def G_case3(q):\n        return alpha * (q[0]**4 + q[1]**4) / 4.0 + beta * q[0]**2 * q[1]**2 / 2.0\n\n    def dG_disc_case3(q0, q1):\n        g1 = alpha/4.0 * (q1[0]**3 + q1[0]**2*q0[0] + q1[0]*q0[0]**2 + q0[0]**3) + \\\n             beta/4.0 * (q1[0] + q0[0]) * (q1[1]**2 + q0[1]**2)\n        g2 = alpha/4.0 * (q1[1]**3 + q1[1]**2*q0[1] + q1[1]*q0[1]**2 + q0[1]**3) + \\\n             beta/4.0 * (q1[0]**2 + q0[0]**2) * (q1[1] + q0[1])\n        return np.array([g1, g2])\n\n    def J_dG_disc_case3(q0, q1):\n        J11 = alpha/4.0 * (3*q1[0]**2 + 2*q1[0]*q0[0] + q0[0]**2) + \\\n              beta/4.0 * (q1[1]**2 + q0[1]**2)\n        J12 = beta/2.0 * (q1[0] + q0[0]) * q1[1]\n        J21 = beta/2.0 * q1[0] * (q1[1] + q0[1])\n        J22 = alpha/4.0 * (3*q1[1]**2 + 2*q1[1]*q0[1] + q0[1]**2) + \\\n              beta/4.0 * (q1[0]**2 + q0[0]**2)\n        return np.array([[J11, J12], [J21, J22]])\n\n    case3 = {\n        \"M\": np.diag([1.0, 2.0]),\n        \"K\": np.array([[2.0, 0.3], [0.3, 1.5]]),\n        \"G\": G_case3,\n        \"dG_disc\": dG_disc_case3,\n        \"J_dG_disc\": J_dG_disc_case3,\n        \"q0\": np.array([0.1, -0.2]), \"p0\": np.array([0.0, 0.25]),\n        \"dt\": 0.015, \"N\": 400,\n    }\n\n    # Case 4: 1D Trivial Equilibrium\n    case4 = {\n        \"M\": np.array([[1.0]]), \"K\": np.array([[2.0]]),\n        \"G\": lambda q: q[0]**4 / 4.0,\n        \"dG_disc\": lambda q0, q1: np.array([\n            1.0/4.0 * (q1[0]**3 + q1[0]**2*q0[0] + q1[0]*q0[0]**2 + q0[0]**3)\n        ]),\n        \"J_dG_disc\": lambda q0, q1: np.array([[\n            1.0/4.0 * (3*q1[0]**2 + 2*q1[0]*q0[0] + q0[0]**2)\n        ]]),\n        \"q0\": np.array([0.0]), \"p0\": np.array([0.0]),\n        \"dt\": 0.1, \"N\": 10,\n    }\n\n    test_cases = [case1, case2, case3, case4]\n    results = [run_simulation(case) for case in test_cases]\n    \n    # Format the output string exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Physical models often involve nonsmooth phenomena, such as contact or friction, which pose a challenge to standard numerical methods. This practice extends the discrete gradient framework to handle a nonsmooth potential energy function by incorporating the concept of a subgradient . You will build a robust integrator that maintains perfect energy conservation even as the solution crosses a \"kink\" in the potential, showcasing the power of the geometric approach.",
            "id": "3384885",
            "problem": "Consider the semilinear one-dimensional Partial Differential Equation (PDE) wave model on the spatial interval $[0,1]$ with homogeneous Dirichlet boundary conditions,\n$$u_{tt}(x,t) - c^2 u_{xx}(x,t) + \\partial V(u(x,t)) = 0,$$\nwhere $c0$ is the wave speed and $V(u)=\\lambda |u|$ is a nonsmooth potential with $\\lambda0$. Here $\\partial V$ denotes the subdifferential with respect to $u$, which coincides with the set-valued sign function for the absolute value, namely $\\partial(\\lambda |u|)=\\lambda\\,\\mathrm{sign}(u)$ with $\\mathrm{sign}(0)$ understood as any value in $[-1,1]$.\n\nUsing a standard second-order centered finite difference spatial semi-discretization with $N$ interior grid points and grid spacing $h_x=\\frac{1}{N+1}$, define the vector of nodal values $q(t)\\in\\mathbb{R}^N$ and its velocity $p(t)=\\dot{q}(t)\\in\\mathbb{R}^N$. The semi-discrete dynamics can be written as a Hamiltonian system\n$$\\dot{q}=p,\\quad \\dot{p}=-K q - g(q),$$\nwith discrete energy (Hamiltonian)\n$$H(q,p)=\\frac{1}{2}\\|p\\|^2 + \\frac{1}{2} q^\\top K q + \\lambda \\sum_{i=1}^N |q_i|,$$\nwhere $K\\in\\mathbb{R}^{N\\times N}$ is the symmetric positive definite stiffness matrix corresponding to the discrete Dirichlet Laplacian, scaled by $c^2$, that is, $K=\\frac{c^2}{h_x^2}\\,\\mathrm{tridiag}(-1,2,-1)$, and $g(q)\\in\\partial(\\lambda \\sum_i |q_i|)$ is any selection of subgradients componentwise. This ordinary differential equation system preserves the energy $H$ exactly in time.\n\nYour tasks are:\n1. Starting from the fundamental definition of discrete energy conservation for a separable Hamiltonian $H(q,p)=T(p)+W(q)$, construct a time integrator that preserves the discrete energy $H(q,p)$ exactly for all time steps, using a discrete gradient of $W(q)$ that incorporates the nonsmooth subgradient of the absolute value. Do not assume smoothness of $V$ and do not use formulas that presuppose differentiability at $u=0$. The method must be derived from first principles and must specify how to handle the subgradient at the kink $q_i=0$.\n2. Implement the integrator for the semi-discrete system with the matrix $K$ defined above. Your implementation must robustly handle kinks where $q_i=0$ by employing a consistent subgradient selection that ensures the discrete energy conservation identity is satisfied.\n3. For each time step, solve any implicit equations arising from the energy-preserving construction using a numerically stable approach that does not assume smooth derivatives at the kink. Use a stopping criterion that guarantees sufficient accuracy to assess energy preservation.\n4. Compute the energy $H(q^n,p^n)$ along the numerical trajectory and report the maximum absolute deviation from the initial energy $H(q^0,p^0)$ over the entire simulation, defined as\n$$\\Delta H_{\\max}=\\max_{0\\le n\\le N_{\\mathrm{steps}}} \\left| H(q^n,p^n) - H(q^0,p^0) \\right|.$$\n\nTest suite:\n- Case A (general case, away from kinks): $N=16$, $c=1.0$, $\\lambda=0.8$, time step $h=0.02$, number of steps $N_{\\mathrm{steps}}=200$, initial condition $q_i^0 = 0.5\\sin(\\pi x_i)$, $p^0=0$, where $x_i=i h_x$ for $i=1,\\dots,N$.\n- Case B (robustness near kinks with frequent sign changes): $N=16$, $c=1.0$, $\\lambda=2.0$, time step $h=0.015$, number of steps $N_{\\mathrm{steps}}=300$, initial condition $q_i^0 = 0.05\\sin(6\\pi x_i)$, $p^0=0$.\n- Case C (large time step stress test near kinks): $N=10$, $c=1.5$, $\\lambda=1.0$, time step $h=0.1$, number of steps $N_{\\mathrm{steps}}=120$, initial condition $q_i^0 = 0.2\\sin(2\\pi x_i)$, $p^0=0$.\n\nFor each case, determine whether the integrator achieves energy preservation to within the tolerance $\\varepsilon_{\\mathrm{energy}}=10^{-8}$, that is, whether $\\Delta H_{\\max} \\le \\varepsilon_{\\mathrm{energy}}$. The required final output for the entire program is a single line containing a comma-separated list of three strings corresponding to Cases A, B, and C, enclosed in square brackets. The output format must be exactly of the form\n$$[\\mathrm{result}_A,\\mathrm{result}_B,\\mathrm{result}_C]$$\nwhere each $\\mathrm{result}_\\bullet$ is the lowercase string `true` or `false`.",
            "solution": "The problem requires the construction and implementation of a numerical integrator that exactly preserves the discrete energy of a semi-discretized semilinear wave equation with a nonsmooth potential. The problem is well-posed and scientifically sound, representing a standard task in the field of geometric numerical integration. We proceed with the derivation and implementation.\n\n### 1. Derivation of the Energy-Preserving Integrator\n\nThe semi-discrete system is a separable Hamiltonian system with Hamiltonian $H(q,p) = T(p) + W(q)$, where $T(p) = \\frac{1}{2}\\|p\\|^2$ is the kinetic energy and $W(q) = \\frac{1}{2} q^\\top K q + \\lambda \\sum_{i=1}^N |q_i|$ is the potential energy. The equations of motion are $\\dot{q} = \\nabla_p H = p$ and $\\dot{p} = -\\nabla_q H = -Kq - g(q)$, where $g(q) \\in \\partial_q(\\lambda\\sum_i|q_i|)$ is a subgradient.\n\nAn integrator $(q^n, p^n) \\mapsto (q^{n+1}, p^{n+1})$ is exactly energy-preserving if $H(q^{n+1}, p^{n+1}) = H(q^n, p^n)$ for all steps $n$. This can be achieved using a discrete gradient method. A discrete gradient $\\overline{\\nabla} W(q^a, q^b)$ of a function $W(q)$ is a vector-valued function satisfying two properties:\n1.  Consistency: $\\overline{\\nabla} W(q, q) = \\nabla W(q)$ wherever $W$ is differentiable.\n2.  Energy relation: $W(q^b) - W(q^a) = (\\overline{\\nabla} W(q^a, q^b))^\\top (q^b - q^a)$.\n\nWe employ an energy-preserving scheme based on the average vector field method (a specific discrete gradient integrator), which for a separable Hamiltonian takes the form:\n$$\n\\frac{q^{n+1} - q^n}{h} = \\overline{\\nabla} T(p^n, p^{n+1})\n$$\n$$\n\\frac{p^{n+1} - p^n}{h} = -\\overline{\\nabla} W(q^n, q^{n+1})\n$$\nwhere $h$ is the time step.\n\nFor the kinetic energy $T(p)=\\frac{1}{2}p^\\top p$, its gradient is $\\nabla_p T(p) = p$. A standard choice for the discrete gradient is the midpoint evaluation:\n$$\n\\overline{\\nabla} T(p^n, p^{n+1}) = \\frac{p^n + p^{n+1}}{2}\n$$\nThe first equation of the scheme becomes the familiar trapezoidal rule for the kinematic relation:\n$$\n\\frac{q^{n+1} - q^n}{h} = \\frac{p^n + p^{n+1}}{2} \\quad (*).\n$$\n\nFor the potential energy $W(q) = W_{smooth}(q) + W_{nonsmooth}(q)$, where $W_{smooth}(q) = \\frac{1}{2}q^\\top K q$ and $W_{nonsmooth}(q) = \\lambda \\sum_{i=1}^N |q_i|$, the discrete gradient is constructed additively: $\\overline{\\nabla} W = \\overline{\\nabla} W_{smooth} + \\overline{\\nabla} W_{nonsmooth}$.\n- For the quadratic (smooth) part, the midpoint evaluation of its gradient $\\nabla W_{smooth}(q)=Kq$ gives a valid discrete gradient:\n$$\n\\overline{\\nabla} W_{smooth}(q^n, q^{n+1}) = K\\left(\\frac{q^n + q^{n+1}}{2}\\right)\n$$\n- For the nonsmooth part $W_{nonsmooth}(q)$, which is separable, we define the discrete gradient component-wise. For each component $w_i(q_i) = \\lambda |q_i|$, the discrete gradient property $w_i(q_i^{n+1}) - w_i(q_i^n) = [\\overline{\\nabla} W_{nonsmooth}]_i (q_i^{n+1}-q_i^n)$ leads to the definition:\n$$\n[\\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1})]_i = \\lambda \\frac{|q_i^{n+1}| - |q_i^n|}{q_i^{n+1} - q_i^n}, \\quad \\text{if } q_i^{n+1} \\neq q_i^n\n$$\nIf $q_i^{n+1} = q_i^n$, the discrete gradient must be chosen from the subdifferential $\\partial w_i(q_i^n)$. A consistent choice is $\\lambda\\,\\mathrm{sign}(q_i^n)$ if $q_i^n \\neq 0$, and $0$ if $q_i^n = 0$.\n\nThe second equation of the scheme is:\n$$\n\\frac{p^{n+1} - p^n}{h} = -K\\left(\\frac{q^n + q^{n+1}}{2}\\right) - \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1}) \\quad (**).\n$$\n\nTo prove energy conservation, we sum the inner products of $(*)$ with $(\\overline{\\nabla} W)^\\top h$ and $(**)$ with $(p^n+p^{n+1})^\\top h/2$:\n$W(q^{n+1})-W(q^n) = (\\overline{\\nabla} W)^\\top (q^{n+1}-q^n) = (\\overline{\\nabla} W)^\\top h \\frac{p^n+p^{n+1}}{2}$.\n$T(p^{n+1})-T(p^n) = \\frac{1}{2}(p^{n+1})^\\top p^{n+1} - \\frac{1}{2}(p^n)^\\top p^n = \\frac{1}{2}(p^{n+1}-p^n)^\\top(p^{n+1}+p^n) = -(\\overline{\\nabla} W)^\\top h \\frac{p^n+p^{n+1}}{2}$.\nSumming these two equalities gives $\\Delta H = (W^{n+1}-W^n) + (T^{n+1}-T^n) = 0$. Thus, the scheme is exactly energy-preserving.\n\n### 2. Implicit Solver Formulation\n\nThe scheme is implicit. We derive an equation for $q^{n+1}$. From $(*)$, we express $p^{n+1} = \\frac{2}{h}(q^{n+1}-q^n) - p^n$. Substituting this into $(**)$ yields a nonlinear system for $q^{n+1}$:\n$$\n\\frac{1}{h}\\left(\\frac{2}{h}(q^{n+1}-q^n) - p^n - p^n\\right) = -K\\left(\\frac{q^n + q^{n+1}}{2}\\right) - \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1})\n$$\n$$\n\\frac{2}{h^2}(q^{n+1}-q^n) - \\frac{2}{h}p^n = -K\\left(\\frac{q^n + q^{n+1}}{2}\\right) - \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1})\n$$\nMultiplying by $h^2/2$ and rearranging terms to solve for $q^{n+1}$:\n$$\nq^{n+1} - q^n - h p^n = -\\frac{h^2}{4} K(q^n + q^{n+1}) - \\frac{h^2}{2} \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1})\n$$\n$$\n\\left(I + \\frac{h^2}{4} K\\right) q^{n+1} = q^n + h p^n - \\frac{h^2}{4} K q^n - \\frac{h^2}{2} \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1})\n$$\nThis is a nonlinear vector equation of the form $F(z)=0$ for $z=q^{n+1}$. It must be solved at each time step. Since the problem demands a method that does not assume smoothness, we use a fixed-point iteration:\n$$\n\\left(I + \\frac{h^2}{4} K\\right) q^{n+1}_{(k+1)} = q^n + h p^n - \\frac{h^2}{4} K q^n - \\frac{h^2}{2} \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1}_{(k)}),\n$$\nwhere $q^{n+1}_{(k)}$ is the $k$-th iterate for $q^{n+1}$. We start with an initial guess $q^{n+1}_{(0)} = q^n$. The matrix $A = I + \\frac{h^2}{4} K$ is symmetric, positive-definite, and tridiagonal. The linear system at each iteration step is efficiently solved using a banded matrix solver. The iteration is stopped when the difference between successive iterates is below a tight tolerance (e.g., $10^{-14}$), ensuring the energy conservation property holds to machine precision.\n\n### 3. Implementation and Numerical Stability\n\nThe implementation requires careful handling of the discrete gradient for the absolute value term to avoid numerical instability when $q_i^{n+1} \\approx q_i^n$. The expression $\\lambda(|v|-|u|)/(v-u)$ is evaluated as:\n- $\\lambda\\,\\mathrm{sign}(u)$ if $u$ and $v$ have the same sign (or one is zero).\n- $\\lambda(|v|-|u|)/(v-u)$ if they have different signs.\nNumerically, if $|v-u|$ is smaller than a machine epsilon tolerance, we treat it as the $v=u$ case and select a subgradient. Our consistent choice is $\\lambda\\,\\mathrm{sign}(u)$ for $u \\neq 0$ and $0$ for $u=0$.\n\nOnce the fixed-point iteration converges to a solution $q^{n+1}$, the new momentum $p^{n+1}$ is computed from the kinematic update:\n$$\np^{n+1} = \\frac{2}{h}(q^{n+1} - q^n) - p^n\n$$\nThe energy $H(q^{n+1}, p^{n+1})$ is then computed and its deviation from the initial energy $H(q^0,p^0)$ is tracked. The maximum absolute deviation over all time steps, $\\Delta H_{\\max}$, is compared against the specified tolerance $\\varepsilon_{\\mathrm{energy}}=10^{-8}$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef discrete_gradient_nonsmooth(q_n, q_np1, lam, N):\n    \"\"\"\n    Computes the discrete gradient of the nonsmooth potential W_nonsmooth = lambda * sum(|q_i|).\n    \"\"\"\n    g = np.zeros(N)\n    # Use a small tolerance based on machine epsilon for robust floating point comparison.\n    machine_eps = np.finfo(float).eps * 10.0\n    \n    for i in range(N):\n        q_i_n = q_n[i]\n        q_i_np1 = q_np1[i]\n        diff = q_i_np1 - q_i_n\n        \n        if np.abs(diff)  machine_eps:\n            # Case q_i^{n+1} is numerically equal to q_i^n.\n            # Select a subgradient. A consistent choice is made here.\n            if np.abs(q_i_n)  machine_eps:\n                # Subgradient at q=0. The choice 0 is natural and symmetric.\n                g[i] = 0.0\n            else:\n                # Differentiable region, gradient is sign(q).\n                g[i] = lam * np.sign(q_i_n)\n        else:\n            # Standard discrete gradient formula for |q|.\n            g[i] = lam * (np.abs(q_i_np1) - np.abs(q_i_n)) / diff\n    return g\n\ndef hamiltonian(q, p, K, lam):\n    \"\"\"\n    Computes the total discrete energy (Hamiltonian) of the system.\n    \"\"\"\n    kinetic = 0.5 * np.dot(p, p)\n    potential_smooth = 0.5 * np.dot(q, K @ q)\n    potential_nonsmooth = lam * np.sum(np.abs(q))\n    return kinetic + potential_smooth + potential_nonsmooth\n\ndef run_simulation(N, c, lam, h, N_steps, q0_func):\n    \"\"\"\n    Runs a simulation for one test case and checks for energy preservation.\n    \"\"\"\n    # 1. System setup\n    hx = 1.0 / (N + 1)\n    x = np.array([i * hx for i in range(1, N + 1)])\n\n    # Stiffness matrix K = (c^2/h_x^2) * tridiag(-1, 2, -1)\n    diag_K = np.full(N, 2.0)\n    off_diag_K = np.full(N - 1, -1.0)\n    K = (c**2 / hx**2) * (np.diag(diag_K) + np.diag(off_diag_K, k=1) + np.diag(off_diag_K, k=-1))\n\n    # 2. Initial conditions\n    q = q0_func(x)\n    p = np.zeros(N)\n\n    # Initial energy and tracking variables\n    H0 = hamiltonian(q, p, K, lam)\n    max_energy_deviation = 0.0\n\n    # 3. Setup for the fixed-point solver\n    fixed_point_tol = 1e-14\n    max_fixed_point_iter = 100\n\n    # System matrix A = I + (h^2/4) * K for the implicit solve\n    A_diag = 1.0 + (h**2 / 4.0) * (c**2 / hx**2) * 2.0\n    A_off_diag = -(h**2 / 4.0) * (c**2 / hx**2)\n    \n    A_banded = np.zeros((3, N))\n    A_banded[0, 1:] = A_off_diag  # Super-diagonal\n    A_banded[1, :] = A_diag     # Main diagonal\n    A_banded[2, :-1] = A_off_diag # Sub-diagonal\n    \n    # 4. Time stepping loop\n    for _ in range(N_steps):\n        # --- Solve for q^{n+1} using fixed-point iteration ---\n        rhs_const = q + h * p - (h**2 / 4.0) * (K @ q)\n        q_next_iter = np.copy(q) \n\n        for k in range(max_fixed_point_iter):\n            q_prev_iter = np.copy(q_next_iter)\n            \n            g_nonsmooth = discrete_gradient_nonsmooth(q, q_prev_iter, lam, N)\n            rhs = rhs_const - (h**2 / 2.0) * g_nonsmooth\n            \n            # Solve the banded linear system A * q_next_iter = rhs\n            q_next_iter = solve_banded((1, 1), A_banded, rhs, check_finite=False)\n            \n            if np.linalg.norm(q_next_iter - q_prev_iter, ord=np.inf)  fixed_point_tol:\n                break\n        \n        q_next = q_next_iter\n        \n        # --- Update p^{n+1} ---\n        p_next = (2.0 / h) * (q_next - q) - p\n        \n        # Update state for the next step\n        q, p = q_next, p_next\n        \n        # --- Calculate and record energy deviation ---\n        H_n = hamiltonian(q, p, K, lam)\n        energy_dev = np.abs(H_n - H0)\n        if energy_dev  max_energy_deviation:\n            max_energy_deviation = energy_dev\n            \n    # 5. Final check\n    energy_preservation_tol = 1e-8\n    return max_energy_deviation = energy_preservation_tol\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A: General case, away from kinks\n        {'N': 16, 'c': 1.0, 'lam': 0.8, 'h': 0.02, 'N_steps': 200, 'q0_func': lambda x: 0.5 * np.sin(np.pi * x)},\n        # Case B: Robustness near kinks\n        {'N': 16, 'c': 1.0, 'lam': 2.0, 'h': 0.015, 'N_steps': 300, 'q0_func': lambda x: 0.05 * np.sin(6 * np.pi * x)},\n        # Case C: Large time step stress test\n        {'N': 10, 'c': 1.5, 'lam': 1.0, 'h': 0.1, 'N_steps': 120, 'q0_func': lambda x: 0.2 * np.sin(2 * np.pi * x)},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(\n            N=case['N'],\n            c=case['c'],\n            lam=case['lam'],\n            h=case['h'],\n            N_steps=case['N_steps'],\n            q0_func=case['q0_func']\n        )\n        results.append(result)\n\n    # Format the output as a list of lowercase boolean strings\n    formatted_results = ','.join(map(lambda b: str(b).lower(), results))\n    print(f\"[{formatted_results}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "In many physical applications, energy is not strictly conserved but is exchanged with the environment through boundary interactions. This exercise moves from exact conservation to an exact energy budget, where the change in system energy must precisely match the work done by external boundary forces . You will use the finite element method and design an \"energy-consistent\" integrator that correctly captures this physical power balance, connecting the abstract numerical method to tangible physical principles.",
            "id": "3384928",
            "problem": "Consider the scalar wave equation on a bounded domain with mixed boundary conditions. Let $\\Omega \\subset \\mathbb{R}^d$ be sufficiently regular, partition its boundary $\\partial \\Omega$ into a Dirichlet part $\\partial \\Omega_D$ and a Neumann part $\\partial \\Omega_N$, with $\\partial \\Omega_D \\cap \\partial \\Omega_N = \\emptyset$ and $\\partial \\Omega_D \\cup \\partial \\Omega_N = \\partial \\Omega$. The scalar displacement $u(x,t)$ satisfies the initial-boundary value problem\n$$\nu_{tt}(x,t) = c^2 \\Delta u(x,t) \\quad \\text{for } x \\in \\Omega, \\ t \\ge 0,\n$$\nwith boundary conditions\n$$\nu(x,t) = 0 \\ \\text{on } \\partial \\Omega_D, \\qquad c^2 \\frac{\\partial u}{\\partial n}(x,t) = g(x,t) \\ \\text{on } \\partial \\Omega_N,\n$$\nand initial data $u(x,0) = u_0(x)$, $u_t(x,0) = v_0(x)$. Here $c  0$ is the wave speed, $\\Delta$ is the Laplace operator, and $\\partial u/\\partial n$ is the outward normal derivative. Define the mechanical energy\n$$\nE(t) = \\frac{1}{2} \\int_{\\Omega} \\left( u_t(x,t)^2 + c^2 \\left|\\nabla u(x,t)\\right|^2 \\right) \\, dx.\n$$\n\nTask 1 (Derivation from first principles): Starting from the stated partial differential equation and boundary conditions, derive from first principles an exact expression for the time derivative $\\frac{d}{dt} E(t)$ in terms of boundary fluxes and interior terms. Show how the boundary conditions determine which parts contribute to the energy rate and which do not, and express the final rate only through quantities defined on $\\partial \\Omega_N$.\n\nTask 2 (Discretization design): Specialize to the one-dimensional case with $\\Omega = (0,L)$, Dirichlet at $x=0$ and Neumann at $x=L$. Work in dimensionless units throughout. Use the standard Galerkin finite element method with continuous, piecewise-linear basis functions on a uniform mesh of $N_{\\text{el}}$ elements. Derive the semi-discrete system in first-order form\n$$\n\\mathbf{u}_t = \\mathbf{v}, \\qquad \\mathbf{M} \\mathbf{v}_t + \\mathbf{K} \\mathbf{u} = \\mathbf{f}(t),\n$$\nwhere $\\mathbf{M}$ is the consistent mass matrix, $\\mathbf{K}$ is the stiffness matrix weighted by $c^2$, and $\\mathbf{f}(t)$ is the Neumann load vector assembled from the boundary traction at $x=L$. Define the discrete energy\n$$\nE_d(t) = \\frac{1}{2} \\mathbf{v}(t)^{\\top} \\mathbf{M} \\mathbf{v}(t) + \\frac{1}{2} \\mathbf{u}(t)^{\\top} \\mathbf{K} \\mathbf{u}(t).\n$$\nDerive the semi-discrete energy rate and show its dependence on the discrete boundary traction applied at $x=L$.\n\nTask 3 (Energy-consistent time integrator): Design and implement an energy-consistent time integrator for the semi-discrete system. Use the implicit midpoint rule applied to the first-order form above, with the load vector evaluated at the temporal midpoint. Derive the one-step update equations and the linear system to be solved each step. Show that, in the absence of Neumann boundary traction, the discrete energy is exactly conserved by the method, and in its presence, the discrete energy change over a time step matches the discrete boundary work computed with midpoint quadrature.\n\nTask 4 (Program and test suite): Implement the one-dimensional finite element assembly and the implicit midpoint time integrator to verify the energy budget numerically. All quantities are dimensionless. For each test case below, integrate to time $T$ with time step $\\Delta t$ and compute the absolute discrepancy\n$$\n\\varepsilon = \\left| E_d(T) - E_d(0) - W \\right|,\n$$\nwhere $W$ is the discrete boundary work accumulated as\n$$\nW = \\sum_{n=0}^{N-1} \\Delta t \\, \\mathbf{v}_{n+\\frac{1}{2}}^{\\top} \\mathbf{f}\\!\\left(t_{n+\\frac{1}{2}}\\right),\n$$\nwith $\\mathbf{v}_{n+\\frac{1}{2}}$ and $\\mathbf{f}\\!\\left(t_{n+\\frac{1}{2}}\\right)$ evaluated at the temporal midpoint $t_{n+\\frac{1}{2}} = t_n + \\Delta t/2$. Use the following test suite:\n\n- Test case 1 (no boundary work, energy conservation): $L = 1$, $c = 1$, $N_{\\text{el}} = 50$, $\\Delta t = 10^{-3}$, $T = 0.5$, Neumann traction $g(t) = 0$, initial displacement $u_0(x) = \\sin(\\pi x)$, initial velocity $v_0(x) = 0$.\n- Test case 2 (sinusoidal boundary work injection): $L = 1$, $c = 1$, $N_{\\text{el}} = 50$, $\\Delta t = 10^{-3}$, $T = 0.5$, Neumann traction $g(t) = \\sin(6\\pi t)$, initial displacement $u_0(x) = 0$, initial velocity $v_0(x) = 0$.\n- Test case 3 (ramp boundary work with nonzero initial velocity): $L = 1$, $c = 0.8$, $N_{\\text{el}} = 60$, $\\Delta t = 5 \\times 10^{-4}$, $T = 0.6$, Neumann traction $g(t) = 0.5\\, t$, initial displacement $u_0(x) = 0$, initial velocity $v_0(x) = \\sin(2\\pi x)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Each result must be the floating-point value of $\\varepsilon$ for the corresponding test case, in the order listed above.",
            "solution": "The problem posed is a comprehensive exercise in the numerical analysis of partial differential equations, specifically focusing on energy-conserving integrators for the wave equation. It is scientifically sound, well-posed, and all its components are standard in the field of computational mechanics and geometric numerical integration. The problem is validated as sound and a full solution can be constructed. The solution will proceed by addressing each of the four tasks in order: derivation of the continuous energy balance, finite element semi-discretization, design of an energy-consistent time integrator, and finally, numerical implementation and verification.\n\n### Task 1: Continuous Energy Rate Derivation\n\nThe mechanical energy of the system is defined as\n$$\nE(t) = \\frac{1}{2} \\int_{\\Omega} \\left( u_t(x,t)^2 + c^2 \\left|\\nabla u(x,t)\\right|^2 \\right) \\, dx.\n$$\nTo find its rate of change, we differentiate with respect to time $t$. Since the domain $\\Omega$ is fixed, we can move the derivative inside the integral (Leibniz integral rule):\n$$\n\\frac{dE}{dt} = \\int_{\\Omega} \\left( \\frac{\\partial}{\\partial t} \\left(\\frac{1}{2} u_t^2\\right) + \\frac{\\partial}{\\partial t} \\left(\\frac{c^2}{2} |\\nabla u|^2\\right) \\right) \\, dx = \\int_{\\Omega} \\left( u_t u_{tt} + c^2 \\nabla u \\cdot \\nabla u_t \\right) \\, dx.\n$$\nWe substitute the wave equation, $u_{tt} = c^2 \\Delta u$, into this expression:\n$$\n\\frac{dE}{dt} = \\int_{\\Omega} \\left( u_t (c^2 \\Delta u) + c^2 \\nabla u \\cdot \\nabla u_t \\right) \\, dx = c^2 \\int_{\\Omega} \\left( u_t \\Delta u + \\nabla u_t \\cdot \\nabla u \\right) \\, dx.\n$$\nRecognizing the integrand as the expansion of a divergence, specifically using the product rule $\\nabla \\cdot (\\phi \\mathbf{F}) = (\\nabla \\phi) \\cdot \\mathbf{F} + \\phi (\\nabla \\cdot \\mathbf{F})$, we let $\\phi = u_t$ and $\\mathbf{F} = \\nabla u$. This gives $\\nabla \\cdot (u_t \\nabla u) = \\nabla u_t \\cdot \\nabla u + u_t \\Delta u$. The integrand is precisely this expression. Thus,\n$$\n\\frac{dE}{dt} = c^2 \\int_{\\Omega} \\nabla \\cdot (u_t \\nabla u) \\, dx.\n$$\nApplying the divergence theorem, $\\int_{\\Omega} \\nabla \\cdot \\mathbf{V} \\, dx = \\oint_{\\partial \\Omega} \\mathbf{V} \\cdot \\mathbf{n} \\, ds$, where $\\mathbf{n}$ is the outward unit normal vector, we obtain:\n$$\n\\frac{dE}{dt} = c^2 \\oint_{\\partial \\Omega} (u_t \\nabla u) \\cdot \\mathbf{n} \\, ds = c^2 \\oint_{\\partial \\Omega} u_t \\frac{\\partial u}{\\partial n} \\, ds.\n$$\nThe boundary $\\partial \\Omega$ is partitioned into $\\partial \\Omega_D$ and $\\partial \\Omega_N$. We split the integral accordingly:\n$$\n\\frac{dE}{dt} = c^2 \\int_{\\partial \\Omega_D} u_t \\frac{\\partial u}{\\partial n} \\, ds + c^2 \\int_{\\partial \\Omega_N} u_t \\frac{\\partial u}{\\partial n} \\, ds.\n$$\nOn the Dirichlet boundary $\\partial \\Omega_D$, we have $u(x,t) = 0$ for all $t \\ge 0$. This implies its tangential derivatives are zero, and its time derivative is also zero: $u_t(x,t) = 0$ for $x \\in \\partial \\Omega_D$. Therefore, the first integral vanishes. On the Neumann boundary $\\partial \\Omega_N$, the condition is $c^2 \\frac{\\partial u}{\\partial n}(x,t) = g(x,t)$. Substituting these conditions yields the final expression for the energy rate:\n$$\n\\frac{dE}{dt} = 0 + \\int_{\\partial \\Omega_N} u_t(x,t) \\left( c^2 \\frac{\\partial u}{\\partial n}(x,t) \\right) \\, ds = \\int_{\\partial \\Omega_N} u_t(x,t) g(x,t) \\, ds.\n$$\nThis result shows that the rate of change of the system's mechanical energy is equal to the power supplied by the traction forces $g(x,t)$ on the Neumann boundary. If $g=0$ or $\\partial\\Omega_N$ is empty, energy is conserved.\n\n### Task 2: Semi-Discretization and Discrete Energy Rate\n\nFor the 1D case on $\\Omega = (0,L)$ with $u(0,t)=0$ and $c^2 u_x(L,t) = g(t)$, we use the Galerkin finite element method. The displacement is approximated as $u(x,t) \\approx u^h(x,t) = \\sum_{j=1}^{N} u_j(t) \\phi_j(x)$, where $\\phi_j(x)$ are the standard piecewise-linear \"hat\" basis functions on a uniform mesh of size $h = L/N_{\\text{el}}$ ($N=N_{\\text{el}}$ is the number of free nodes). The basis function $\\phi_j(x)$ is $1$ at node $x_j=j \\cdot h$ and $0$ at all other nodes. The sum starts from $j=1$ to enforce the Dirichlet condition $u(0,t)=0$. The weak form of the PDE is obtained by multiplying by a test function $w^h(x) = \\sum_{i=1}^N w_i \\phi_i(x)$ and integrating over the domain:\n$$\n\\int_0^L w^h u^h_{tt} \\, dx + c^2 \\int_0^L w^h_x u^h_x \\, dx = \\left[ c^2 w^h u^h_x \\right]_0^L.\n$$\nThe boundary term evaluates to $w^h(L) g(t)$ since $w^h(0)=0$ and $c^2 u_x(L,t)=g(t)$. Substituting the FEM expansions for $u^h$ and $w^h$ and requiring the equation to hold for all $w_i$ (i.e., for each basis function $\\phi_i$) yields the semi-discrete system:\n$$\n\\sum_{j=1}^N \\left(\\int_0^L \\phi_i \\phi_j dx\\right) \\ddot{u}_j(t) + c^2 \\sum_{j=1}^N \\left(\\int_0^L \\phi'_i \\phi'_j dx\\right) u_j(t) = \\phi_i(L) g(t), \\quad \\text{for } i=1, \\dots, N.\n$$\nThis is the second-order matrix system $\\mathbf{M} \\ddot{\\mathbf{u}} + \\mathbf{K} \\mathbf{u} = \\mathbf{f}(t)$, with matrix and vector entries:\n- Mass Matrix: $M_{ij} = \\int_0^L \\phi_i(x) \\phi_j(x) \\, dx$.\n- Stiffness Matrix: $K_{ij} = c^2 \\int_0^L \\phi'_i(x) \\phi'_j(x) \\, dx$.\n- Load Vector: $f_i(t) = \\phi_i(L) g(t)$. This vector is zero except for its last component, $f_N(t) = \\phi_N(L) g(t) = g(t)$.\nDefining $\\mathbf{v} = \\dot{\\mathbf{u}}$, we get the first-order system: $\\dot{\\mathbf{u}} = \\mathbf{v}$, $\\mathbf{M} \\dot{\\mathbf{v}} + \\mathbf{K} \\mathbf{u} = \\mathbf{f}(t)$.\nThe discrete energy is $E_d(t) = \\frac{1}{2} \\mathbf{v}^{\\top} \\mathbf{M} \\mathbf{v} + \\frac{1}{2} \\mathbf{u}^{\\top} \\mathbf{K} \\mathbf{u}$. Its time derivative is:\n$$\n\\frac{dE_d}{dt} = \\dot{\\mathbf{v}}^{\\top} \\mathbf{M} \\mathbf{v} + \\dot{\\mathbf{u}}^{\\top} \\mathbf{K} \\mathbf{u}.\n$$\n(using symmetry of $\\mathbf{M}$ and $\\mathbf{K}$). Substituting $\\dot{\\mathbf{u}}=\\mathbf{v}$ and $\\mathbf{M}\\dot{\\mathbf{v}} = \\mathbf{f} - \\mathbf{K}\\mathbf{u}$:\n$$\n\\frac{dE_d}{dt} = (\\mathbf{M}^{-1}(\\mathbf{f} - \\mathbf{K}\\mathbf{u}))^{\\top} \\mathbf{M} \\mathbf{v} + \\mathbf{v}^{\\top} \\mathbf{K} \\mathbf{u} = (\\mathbf{f} - \\mathbf{K}\\mathbf{u})^{\\top} \\mathbf{M}^{-1} \\mathbf{M} \\mathbf{v} + \\mathbf{v}^{\\top} \\mathbf{K} \\mathbf{u} = \\mathbf{f}^{\\top}\\mathbf{v} - \\mathbf{u}^{\\top}\\mathbf{K}\\mathbf{v} + \\mathbf{v}^{\\top}\\mathbf{K}\\mathbf{u}.\n$$\nSince $\\mathbf{u}^{\\top}\\mathbf{K}\\mathbf{v} = (\\mathbf{v}^{\\top}\\mathbf{K}\\mathbf{u})^{\\top}$ is a scalar, it equals $\\mathbf{v}^{\\top}\\mathbf{K}\\mathbf{u}$. The terms involving $\\mathbf{K}$ cancel, leaving:\n$$\n\\frac{dE_d}{dt} = \\mathbf{v}^{\\top} \\mathbf{f}(t).\n$$\nThis is the discrete analogue of the continuous power identity, where the rate of energy change is the inner product of the generalized velocity vector and the external force vector.\n\n### Task 3: Energy-Consistent Time Integrator\n\nThe implicit midpoint rule is applied to the first-order system over a time step $\\Delta t$ from $t_n$ to $t_{n+1}$:\n$$\n\\frac{\\mathbf{u}_{n+1} - \\mathbf{u}_n}{\\Delta t} = \\mathbf{v}_{n+\\frac{1}{2}}, \\qquad \\mathbf{M} \\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{\\Delta t} + \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}} = \\mathbf{f}_{n+\\frac{1}{2}},\n$$\nwhere quantities at the midpoint are defined as averages, e.g., $\\mathbf{u}_{n+\\frac{1}{2}} = (\\mathbf{u}_n + \\mathbf{u}_{n+1})/2$.\nTo derive the one-step update, we eliminate $\\mathbf{v}_{n+1}$ and $\\mathbf{v}_{n+\\frac{1}{2}}$. From the first equation, $\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t \\mathbf{v}_{n+\\frac{1}{2}}$, and $\\mathbf{v}_{n+1} = 2\\mathbf{v}_{n+\\frac{1}{2}} - \\mathbf{v}_n$. Substituting these into the second equation yields a system for the unknown $\\mathbf{u}_{n+1}$. After algebraic manipulation, we arrive at the linear system to be solved for $\\mathbf{u}_{n+1}$ at each time step:\n$$\n\\left(\\mathbf{M} + \\frac{\\Delta t^2}{4}\\mathbf{K}\\right) \\mathbf{u}_{n+1} = \\frac{\\Delta t^2}{2} \\mathbf{f}_{n+\\frac{1}{2}} + \\left(\\mathbf{M} - \\frac{\\Delta t^2}{4}\\mathbf{K}\\right)\\mathbf{u}_n + \\Delta t \\mathbf{M} \\mathbf{v}_n.\n$$\nOnce $\\mathbf{u}_{n+1}$ is computed, $\\mathbf{v}_{n+1}$ is found via $\\mathbf{v}_{n+1} = \\frac{2}{\\Delta t}(\\mathbf{u}_{n+1} - \\mathbf{u}_n) - \\mathbf{v}_n$.\n\nTo demonstrate the energy-consistency property, we examine the change in discrete energy over one step, $E_{d,n+1} - E_{d,n}$:\n$$\nE_{d,n+1} - E_{d,n} = \\frac{1}{2}(\\mathbf{v}_{n+1}^{\\top}\\mathbf{M}\\mathbf{v}_{n+1} - \\mathbf{v}_n^{\\top}\\mathbf{M}\\mathbf{v}_n) + \\frac{1}{2}(\\mathbf{u}_{n+1}^{\\top}\\mathbf{K}\\mathbf{u}_{n+1} - \\mathbf{u}_n^{\\top}\\mathbf{K}\\mathbf{u}_n).\n$$\nUsing the identity $a^2-b^2 = (a-b)(a+b)$, this becomes:\n$$\nE_{d,n+1} - E_{d,n} = (\\mathbf{v}_{n+1} - \\mathbf{v}_n)^{\\top} \\mathbf{M} \\mathbf{v}_{n+\\frac{1}{2}} + (\\mathbf{u}_{n+1} - \\mathbf{u}_n)^{\\top} \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}}.\n$$\nSubstituting the midpoint rule discretizations, $\\mathbf{u}_{n+1} - \\mathbf{u}_n = \\Delta t \\mathbf{v}_{n+\\frac{1}{2}}$ and $\\mathbf{v}_{n+1} - \\mathbf{v}_n = \\Delta t \\mathbf{M}^{-1}(\\mathbf{f}_{n+\\frac{1}{2}} - \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}})$:\n$$\nE_{d,n+1} - E_{d,n} = \\left(\\Delta t \\mathbf{M}^{-1}(\\mathbf{f}_{n+\\frac{1}{2}} - \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}})\\right)^{\\top} \\mathbf{M} \\mathbf{v}_{n+\\frac{1}{2}} + \\left(\\Delta t \\mathbf{v}_{n+\\frac{1}{2}}\\right)^{\\top} \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}}.\n$$\nThis simplifies to:\n$$\nE_{d,n+1} - E_{d,n} = \\Delta t \\left( \\mathbf{f}_{n+\\frac{1}{2}}^{\\top} \\mathbf{v}_{n+\\frac{1}{2}} - \\mathbf{u}_{n+\\frac{1}{2}}^{\\top}\\mathbf{K}\\mathbf{v}_{n+\\frac{1}{2}} \\right) + \\Delta t \\mathbf{v}_{n+\\frac{1}{2}}^{\\top} \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}}.\n$$\nThe terms involving $\\mathbf{K}$ cancel, leaving $E_{d,n+1} - E_{d,n} = \\Delta t \\, \\mathbf{v}_{n+\\frac{1}{2}}^{\\top} \\mathbf{f}_{n+\\frac{1}{2}}$. This equation demonstrates that the change in discrete energy over one step is exactly equal to the work done by the external forces, evaluated with midpoint quadrature. Summing over all time steps gives $E_d(T) - E_d(0) = W$, where $W = \\sum_{n=0}^{N-1} \\Delta t \\, \\mathbf{v}_{n+\\frac{1}{2}}^{\\top} \\mathbf{f}_{n+\\frac{1}{2}}$. Thus, the method exactly balances the discrete energy budget. In the absence of external forces ($\\mathbf{f}=0$), $W=0$ and the discrete energy $E_d$ is exactly conserved.\n\n### Task 4: Program and Test Suite Implementation\n\nThe implementation translates the derived mathematical framework into a computer program. A Python script is developed to perform the following steps for each test case:\n1.  **FEM Assembly**: The consistent mass matrix $\\mathbf{M}$ and stiffness matrix $\\mathbf{K}$ (scaled by $c^2$) are assembled for a 1D uniform mesh with $N_{\\text{el}}$ piecewise-linear elements, corresponding to $N=N_{\\text{el}}$ unconstrained degrees of freedom.\n2.  **Initial Conditions**: The initial displacement $u_0(x)$ and velocity $v_0(x)$ are projected onto the finite element basis by solving the linear systems $\\mathbf{M}\\mathbf{u}_0 = \\mathbf{b}_u$ and $\\mathbf{M}\\mathbf{v}_0 = \\mathbf{b}_v$, where the right-hand sides are computed via $b_i = \\int_0^L f(x)\\phi_i(x)dx$ for $f=u_0, v_0$. This ensures a consistent initialization of the discrete state.\n3.  **Time Integration**: A loop executes the implicit midpoint rule for the specified number of time steps. In each step, the linear system for $\\mathbf{u}_{n+1}$ is formed and solved. The velocity $\\mathbf{v}_{n+1}$ is then updated.\n4.  **Energy and Work Calculation**: The initial energy $E_d(0)$ is computed. During the time-stepping loop, the accumulated boundary work $W$ is updated at each step using the midpoint values of velocity and force. After the loop, the final energy $E_d(T)$ is computed.\n5.  **Discrepancy**: The absolute discrepancy $\\varepsilon = |E_d(T) - E_d(0) - W|$ is calculated. Due to the energy-consistent nature of the scheme, this value is expected to be close to machine precision, confirming the theoretical derivation.\n\nThe program is structured to run the provided test suite and output the resulting discrepancy for each case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef run_simulation(L, c, Nel, dt, T, g_func, u0_func, v0_func):\n    \"\"\"\n    Performs one complete simulation for the 1D wave equation.\n\n    Args:\n        L (float): Length of the domain.\n        c (float): Wave speed.\n        Nel (int): Number of elements.\n        dt (float): Time step.\n        T (float): Final time.\n        g_func (callable): Neumann traction function g(t).\n        u0_func (callable): Initial displacement function u0(x).\n        v0_func (callable): Initial velocity function v0(x).\n\n    Returns:\n        float: The absolute energy discrepancy epsilon.\n    \"\"\"\n    # 1. Mesh and Matrix Assembly\n    N = Nel\n    h = L / float(Nel)\n    nodes = np.linspace(0, L, Nel + 1)\n\n    M = np.zeros((N, N))\n    K = np.zeros((N, N))\n\n    # Assemble tridiagonal M and K matrices for 1D linear elements\n    # Diagonal entries\n    for i in range(N - 1):\n        M[i, i] = 2.0 * h / 3.0\n        K[i, i] = 2.0 * c**2 / h\n    M[N - 1, N - 1] = h / 3.0\n    K[N - 1, N - 1] = c**2 / h\n\n    # Off-diagonal entries\n    for i in range(N - 1):\n        M[i, i + 1] = h / 6.0\n        M[i + 1, i] = h / 6.0\n        K[i, i + 1] = -c**2 / h\n        K[i + 1, i] = -c**2 / h\n    \n    # 2. Initial Conditions (L2 Projection)\n    u = np.zeros(N)\n    v = np.zeros(N)\n\n    # Check if u0 is a non-zero function\n    if np.any(u0_func(np.linspace(0, L, 20)) != 0):\n        b_u = np.zeros(N)\n        for i in range(N):\n            node_idx = i + 1\n            x_center = nodes[node_idx]\n            x_left = nodes[node_idx - 1]\n            \n            # Linear function for the \"up-slope\" part of the hat function\n            def up_slope(x): return (x - x_left) / h\n            integral1 = quad(lambda x: u0_func(x) * up_slope(x), x_left, x_center)[0]\n            \n            if node_idx  N:  # Full hat function\n                x_right = nodes[node_idx + 1]\n                # Linear function for the \"down-slope\"\n                def down_slope(x): return (x_right - x) / h\n                integral2 = quad(lambda x: u0_func(x) * down_slope(x), x_center, x_right)[0]\n                b_u[i] = integral1 + integral2\n            else:  # Half hat function at x=L\n                b_u[i] = integral1\n        u = np.linalg.solve(M, b_u)\n\n    # Check if v0 is a non-zero function\n    if np.any(v0_func(np.linspace(0, L, 20)) != 0):\n        b_v = np.zeros(N)\n        for i in range(N):\n            node_idx = i + 1\n            x_center = nodes[node_idx]\n            x_left = nodes[node_idx - 1]\n            \n            def up_slope(x): return (x - x_left) / h\n            integral1 = quad(lambda x: v0_func(x) * up_slope(x), x_left, x_center)[0]\n\n            if node_idx  N:  # Full hat function\n                x_right = nodes[node_idx + 1]\n                def down_slope(x): return (x_right - x) / h\n                integral2 = quad(lambda x: v0_func(x) * down_slope(x), x_center, x_right)[0]\n                b_v[i] = integral1 + integral2\n            else:  # Half hat function at x=L\n                b_v[i] = integral1\n        v = np.linalg.solve(M, b_v)\n\n    # 3. Energy and Work Calculation\n    def calculate_energy(u_vec, v_vec, M_mat, K_mat):\n        E_kin = 0.5 * v_vec.T @ M_mat @ v_vec\n        E_pot = 0.5 * u_vec.T @ K_mat @ u_vec\n        return E_kin + E_pot\n    \n    E0 = calculate_energy(u, v, M, K)\n    W = 0.0\n\n    # 4. Time Stepping with Implicit Midpoint Rule\n    num_steps = int(round(T / dt))\n    \n    # System matrix for the update equation (constant in time)\n    A_sys = M + (dt**2 / 4.0) * K\n    M_term = M - (dt**2 / 4.0) * K\n    dtM = dt * M\n\n    for n in range(num_steps):\n        t_mid = (n + 0.5) * dt\n        \n        # Neumann force vector\n        f_mid = np.zeros(N)\n        f_mid[-1] = g_func(t_mid)\n\n        # Form the RHS of the linear system\n        b = (dt**2 / 2.0) * f_mid + M_term @ u + dtM @ v\n        \n        # Solve for new displacement\n        u_new = np.linalg.solve(A_sys, b)\n        \n        # Update velocity\n        v_new = (2.0 / dt) * (u_new - u) - v\n        \n        # Midpoint velocity for work calculation\n        v_mid = 0.5 * (v + v_new)\n\n        # Update work\n        work_increment = dt * (v_mid.T @ f_mid)\n        W += work_increment\n        \n        # Update state for next step\n        u, v = u_new, v_new\n        \n    ET = calculate_energy(u, v, M, K)\n    \n    discrepancy = abs(ET - E0 - W)\n    return discrepancy\n\ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        # Test case 1 (L, c, Nel, dt, T, g(t), u0(x), v0(x))\n        (1.0, 1.0, 50, 1e-3, 0.5, \n         lambda t: 0.0, \n         lambda x: np.sin(np.pi * x), \n         lambda x: 0.0),\n        \n        # Test case 2\n        (1.0, 1.0, 50, 1e-3, 0.5, \n         lambda t: np.sin(6 * np.pi * t), \n         lambda x: 0.0, \n         lambda x: 0.0),\n        \n        # Test case 3\n        (1.0, 0.8, 60, 5e-4, 0.6, \n         lambda t: 0.5 * t, \n         lambda x: 0.0, \n         lambda x: np.sin(2 * np.pi * x)),\n    ]\n\n    results = []\n    for params in test_cases:\n        discrepancy = run_simulation(*params)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}