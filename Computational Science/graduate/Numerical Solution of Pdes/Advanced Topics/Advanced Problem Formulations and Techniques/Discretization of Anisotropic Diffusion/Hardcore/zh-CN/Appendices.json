{
    "hands_on_practices": [
        {
            "introduction": "在结构化网格上离散各向异性扩散方程时，即使是标准方法也可能面临挑战。本练习将引导您探索一个包含混合导数项的有限差分格式，该格式如何导致系统矩阵中出现正的非对角元，从而违背 M-矩阵属性和离散极值原理。通过亲手实现这个场景 ()，您将观察到由此产生的非物理解“过冲”现象，并实施一种简单的代数修正来恢复数值稳定性。",
            "id": "3416731",
            "problem": "考虑在单位正方形域 $[0,1]\\times[0,1]$ 上提出的二维各向异性扩散模型，其齐次狄利克雷边界数据由精确解 $u(x,y)=\\sin(\\pi x)\\sin(\\pi y)$ 给出。控制椭圆偏微分方程为 $-\\nabla\\cdot(\\boldsymbol{D}\\nabla u)=f$，其中扩散张量为 $\\boldsymbol{D}=\\begin{pmatrix}1\\beta\\\\ \\beta1\\end{pmatrix}$，$\\beta\\in\\mathbb{R}$ 是一个常数各向异性参数。源项 $f$ 的定义使得 $u$ 为精确解，即 $f(x,y)=-\\nabla\\cdot(\\boldsymbol{D}\\nabla u(x,y))$。离散近似使用均匀笛卡尔网格，每个坐标方向有 $N$ 个内部点，网格间距为 $h=1/(N+1)$，内部节点坐标分别为 $(x_i,y_j)=(ih,jh)$，其中 $i=1,\\dots,N$ 且 $j=1,\\dots,N$。\n\n你必须使用以下模板来组装作用于内部节点未知量向量的离散算子 $\\boldsymbol{A}$：\n- 二阶导数 $u_{xx}$ 和 $u_{yy}$ 各使用标准五点模板的中心差分进行近似，在对角线上给出权重 $4/h^2$，在四个轴对齐的邻点上各给出权重 $-1/h^2$。\n- 混合导数 $u_{xy}$ 由标准的中心差分九点贡献来近似\n$$u_{xy}(x_i,y_j)\\approx \\frac{u_{i+1,j+1}-u_{i+1,j-1}-u_{i-1,j+1}+u_{i-1,j-1}}{4h^2},$$\n这通过 $-2\\beta\\,u_{xy}$ 对 $-\\nabla\\cdot(\\boldsymbol{D}\\nabla u)$ 中的交叉项产生贡献。这会产生符号如上式所示的角点权重 $\\pm \\beta/(2h^2)$。最终得到的 $\\boldsymbol{A}$ 是对称的。\n\n你的推导和算法设计的基本出发点必须始于一致椭圆算子的连续极值原理、离散算子的 M-矩阵概念，以及局部截断误差和全局离散误差的标准定义：\n- 一个对称张量 $\\boldsymbol{D}$，其特征值有正的下界，这意味着一致椭圆性和连续极值原理：如果 $f\\ge 0$ 且边界数据有界，那么内部极大值不会超过边界极大值。\n- 一个稀疏矩阵 $\\boldsymbol{A}$ 如果其非对角元素非正，并且按行弱对角占优且对角线元素为正，则该矩阵是一个 M-矩阵；这足以保证离散极值原理。\n- 网格点上的局部截断误差是将精确解代入离散算子后得到的残差，而全局离散误差是在某种范数（此处为 $L^{\\infty}$ 范数）下度量的离散解与精确解之差。\n\n你必须解决的问题包括三个部分：\n1. 从这些原理出发，清晰地解释为什么各向异性九点模板中存在的局部符号不定的角点权重和过大的负非对角元素会违反 M-矩阵性质，从而违反离散极值原理，进而导致全局过冲，即离散解超过了 $u(x,y)$ 在 $(x,y)=(\\tfrac{1}{2},\\tfrac{1}{2})$ 处达到的连续极大值 $1$。\n2. 提出并实现一个严格局部的代数修正，以恢复 M-矩阵性质，而不改变离散算子中与违规项相关的直接行和列之外的部分：对于任何正的非对角元素 $A_{ij}$（其中 $i\\ne j$），设置 $A_{ij}\\leftarrow 0$ 和 $A_{ji}\\leftarrow 0$，并将对角线元素 $A_{ii}$ 和 $A_{jj}$ 均增加被移除的量，以保持每行的行和一致性。解释为什么这种修正能强制非对角元素为非正，增加对角占优性，从而改善与离散极值原理的一致性。\n3. 量化此局部修正引起的全局 $L^{\\infty}$ 误差的变化。对于下面定义的每个测试用例，计算原始模板和局部修正后模板的 $L^{\\infty}$ 误差 $E_{\\infty}=\\max_{i,j}|u^{h}_{ij}-u(x_i,y_j)|$，并报告改善量 $\\Delta E_{\\infty}=E_{\\infty,\\text{orig}}-E_{\\infty,\\text{fix}}$（以浮点数形式）。同时计算修正前后的过冲幅度 $O=\\max\\{0,\\max_{i,j}u^{h}_{ij}-1\\}$，但只需打印 $\\Delta E_{\\infty}$。不涉及物理单位，如果出现任何角度，必须以弧度为单位。\n\n使用以下测试套件 $(N,\\beta)$ 值来检验不同情况：\n- A 例（理想情况，各向同性）：$(N,\\beta)=(33,0)$。\n- B 例（中等各向异性）：$(N,\\beta)=(33,0.6)$。\n- C 例（强各向异性，粗网格）：$(N,\\beta)=(17,0.95)$。\n- D 例（负交叉各向异性）：$(N,\\beta)=(33,-0.8)$。\n\n你的程序必须：\n- 组装 $\\boldsymbol{A}$ 和右端向量 $\\boldsymbol{b}$，其元素 $b_{ij}=f(x_i,y_j)$ 从 $u$ 和 $\\boldsymbol{D}$ 解析地获得，其中 $f(x,y)=-\\nabla\\cdot(\\boldsymbol{D}\\nabla u(x,y))$。\n- 在应用局部修正前后，求解 $\\boldsymbol{A}\\boldsymbol{u}^{h}=\\boldsymbol{b}$ 以得到内部未知量 $\\boldsymbol{u}^{h}$。\n- 为每个案例计算 $E_{\\infty,\\text{orig}}$、$E_{\\infty,\\text{fix}}$ 和改善量 $\\Delta E_{\\infty}$。\n\n最终输出格式：你的程序应生成一行输出，其中包含四个改善值，形式为方括号内的逗号分隔列表（例如 `[a,b,c,d]`）。每个条目必须是浮点数。不应打印任何其他文本。",
            "solution": "该问题要求对一个各向异性扩散方程的有限差分格式进行三部分分析。我们必须首先验证问题的提法，然后对一个潜在的数值假象提供理论解释，提出并论证一种修正方法，最后通过数值实验来量化该修正的效果。\n\n### 问题验证\n\n该问题被认为是有效的。它在科学上基于偏微分方程数值分析的成熟理论，特别是关于有限差分法、矩阵性质（M-矩阵）和极值原理。问题设定是适定的：它在一个简单域上定义了一个具有已知光滑解的线性椭圆偏微分方程，指定了一个相容的离散格式，并要求对一个已知的数值问题进行可量化的分析。该问题是客观、完整且无矛盾的。所有参数和测试用例在展示特定数值行为的背景下都是物理和数学上合理的。因此，我们可以着手解决。\n\n### 第一部分：离散极值原理的违反\n\n控制偏微分方程（PDE）为 $-\\nabla\\cdot(\\boldsymbol{D}\\nabla u)=f$，定义在域 $[0,1]\\times[0,1]$ 上，其中 $\\boldsymbol{D}=\\begin{pmatrix}1\\beta\\\\ \\beta1\\end{pmatrix}$。展开散度算子，PDE 变为：\n$$ -\\frac{\\partial}{\\partial x}\\left(1 \\cdot \\frac{\\partial u}{\\partial x} + \\beta \\frac{\\partial u}{\\partial y}\\right) - \\frac{\\partial}{\\partial y}\\left(\\beta \\frac{\\partial u}{\\partial x} + 1 \\cdot \\frac{\\partial u}{\\partial y}\\right) = f $$\n$$ - \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\beta \\frac{\\partial^2 u}{\\partial y \\partial x} \\right) - \\left( \\beta \\frac{\\partial^2 u}{\\partial x \\partial y} + \\frac{\\partial^2 u}{\\partial y^2} \\right) = f $$\n假设 $u$ 具有足够的光滑性，使得混合偏导数相等（$u_{xy} = u_{yx}$），则 PDE 为：\n$$ -u_{xx} - u_{yy} - 2\\beta u_{xy} = f $$\n该问题指定了在间距为 $h$ 的均匀网格上的有限差分格式。二阶导数使用标准中心差分进行近似，混合导数按规定进行近似。对于一个通用的内部节点 $(i,j)$，令 $u_{i,j}$ 表示在 $(x_i, y_j)$ 处的近似解。该节点上算子的离散形式为：\n$$ - \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} - \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} - 2\\beta \\frac{u_{i+1,j+1}-u_{i+1,j-1}-u_{i-1,j+1}+u_{i-1,j-1}}{4h^2} = f_{i,j} $$\n按对应的节点值对各项进行分组，我们得到计算模板：\n$$ \\frac{1}{h^2} \\left( 4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} \\right) - \\frac{\\beta}{2h^2} \\left( u_{i+1,j+1}-u_{i+1,j-1}-u_{i-1,j+1}+u_{i-1,j-1} \\right) = f_{i,j} $$\n这个方程定义了线性系统 $\\boldsymbol{A}\\boldsymbol{u}^h = \\boldsymbol{b}$ 中的一行。相邻 $u$ 值的系数成为矩阵 $\\boldsymbol{A}$ 的非对角元素。\n对应于节点 $(i,j)$ 的行的模板权重为：\n- 中心 $(i,j)$：$\\frac{4}{h^2}$（$\\boldsymbol{A}$ 的对角元素）\n- 轴对齐邻点 $(i\\pm1,j)$, $(i,j\\pm1)$：$-\\frac{1}{h^2}$\n- 对角邻点 $(i+1,j+1)$, $(i-1,j-1)$：$-\\frac{\\beta}{2h^2}$\n- 反对角邻点 $(i-1,j+1)$, $(i+1,j-1)$：$+\\frac{\\beta}{2h^2}$\n\n如果一个矩阵 $\\boldsymbol{A}$ 非奇异，其对角元素为正（$A_{kk} > 0$），且所有非对角元素非正（$A_{kl} \\le 0$ for $k \\ne l$），则该矩阵为 M-矩阵。一个充分条件是 $\\boldsymbol{A}$ 是弱对角占优的，且非对角元素非正，对角元素为正。M-矩阵性质保证了离散极值原理（DMP），确保数值解不会出现源项或边界数据中不存在的非物理振荡或极值。\n\n从模板权重中，我们观察到 $\\boldsymbol{A}$ 的非对角元素取决于 $\\beta$ 的符号：\n- 如果 $\\beta > 0$，对应于反对角邻点 $(i-1,j+1)$ 和 $(i+1,j-1)$ 的权重为 $+\\frac{\\beta}{2h^2} > 0$。\n- 如果 $\\beta  0$，令 $\\beta = -|\\beta|$。对角邻点 $(i+1,j+1)$ 和 $(i-1,j-1)$ 的权重变为 $-\\frac{-|\\beta|}{2h^2} = +\\frac{|\\beta|}{2h^2} > 0$。\n\n无论哪种情况，对于任何 $\\beta \\neq 0$，矩阵 $\\boldsymbol{A}$ 都将有正的非对角元素。这违反了 M-矩阵的定义。不满足 M-矩阵性质意味着离散算子不满足离散极值原理。连续解 $u(x,y)=\\sin(\\pi x)\\sin(\\pi y)$ 在 $(0.5, 0.5)$ 处有最大值 $1$，在边界上为零。DMP 的丧失可能导致数值解中出现虚假的“过冲”，即 $\\max_{i,j} u^h_{i,j}$ 可能超过连续最大值 $1$，这是一种非物理的假象。\n\n### 第二部分：恢复 M-矩阵性质\n\n为了恢复 M-矩阵性质，我们对矩阵 $\\boldsymbol{A}$ 应用一个局部的代数修正。目标是消除所有正的非对角元素，同时不显著改变与格式相容性相关的矩阵性质。提出的修正如下：\n\n对于每一对索引 $(k,l)$，其中 $k \\ne l$ 且 $A_{kl} > 0$：\n1. 将正的非对角元素设为零：$A_{kl} \\leftarrow 0$。由于原始矩阵 $\\boldsymbol{A}$ 是对称的，我们也设置 $A_{lk} \\leftarrow 0$。\n2. 为了保持原始的行和（这对于格式的一阶相容性很重要），将被移除的正值加到相应的对角元素上。具体来说，更新 $A_{kk} \\leftarrow A_{kk} + A_{kl, \\text{orig}}$ 和 $A_{ll} \\leftarrow A_{ll} + A_{lk, \\text{orig}}$。\n\n此过程将原始矩阵 $\\boldsymbol{A}_{\\text{orig}}$ 转换为一个新矩阵 $\\boldsymbol{A}_{\\text{fix}}$。让我们分析一下为什么这个修正是有效的：\n- **非正非对角元素：** 该过程系统地识别并清零每一个正的非对角元素。原始为负或零的非对角元素保持不变。通过构造，得到的矩阵 $\\boldsymbol{A}_{\\text{fix}}$ 的非对角元素完全是非正的。\n- **对角占优性：** $\\boldsymbol{A}_{\\text{orig}}$ 的对角元素是正的（$4/h^2 > 0$）。修正过程将一个非负值（原始的正非对角元素）加到每个参与修改的对角元素上。这严格增加了对角元素相对于非对角元素的量级，从而增强了矩阵的对角占优性。通过构造，行和得以保持。\n- **M-矩阵和 DMP：** 最终得到的矩阵 $\\boldsymbol{A}_{\\text{fix}}$ 现在具有正的对角线、非正的非对角线，并且至少与 $\\boldsymbol{A}_{\\text{orig}}$ 一样是对角占优的。这确保了 $\\boldsymbol{A}_{\\text{fix}}$ 是一个 M-矩阵。一个可逆的 M-矩阵具有非负的逆（$\\boldsymbol{A}_{\\text{fix}}^{-1} \\ge 0$），这是离散算子满足极值原理的充分条件。DMP 的恢复抑制了非物理的过冲，并有望产生一个更稳定且在性质上更正确的数值解。\n\n### 第三部分：量化改善效果\n\n恢复 DMP 的理论好处是抑制了数值过冲并提高了稳定性。我们通过测量全局离散误差的变化来量化实际影响。误差在无穷范数（$L^{\\infty}$）下度量，定义为网格节点上数值解 $u^h$ 与精确解 $u$ 之间绝对差的最大值：$E_{\\infty} = \\max_{i,j}|u^{h}_{ij}-u(x_i,y_j)|$。\n\n通过对原始矩阵（$\\boldsymbol{A}_{\\text{orig}}\\boldsymbol{u}^h_{\\text{orig}} = \\boldsymbol{b}$）和修正后矩阵（$\\boldsymbol{A}_{\\text{fix}}\\boldsymbol{u}^h_{\\text{fix}} = \\boldsymbol{b}$）求解线性系统，我们得到两个数值解。然后我们可以计算它们各自的误差 $E_{\\infty,\\text{orig}}$ 和 $E_{\\infty,\\text{fix}}$。改善量定义为 $\\Delta E_{\\infty} = E_{\\infty,\\text{orig}} - E_{\\infty,\\text{fix}}$。$\\Delta E_{\\infty}$ 的正值表示局部代数修正降低了全局误差度量，从而在性质上更正确的同时，也产生了一个更精确的解。所提供的代码为指定的测试用例实现了此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import csr_matrix, dok_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef assemble_system(N, beta):\n    \"\"\"\n    Assembles the sparse matrix A and the right-hand side vector b.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    N2 = N * N\n    \n    # Create grid\n    x = np.linspace(h, 1.0 - h, N)\n    y = np.linspace(h, 1.0 - h, N)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Exact solution\n    u_exact = np.sin(np.pi * X) * np.sin(np.pi * Y)\n    \n    # Source term f(x,y)\n    f = (2.0 * np.pi**2 * np.sin(np.pi * X) * np.sin(np.pi * Y) -\n         2.0 * beta * np.pi**2 * np.cos(np.pi * X) * np.cos(np.pi * Y))\n    b = f.flatten()\n\n    # Stencil weights\n    h2 = h * h\n    w_center = 4.0 / h2\n    w_axis = -1.0 / h2\n    w_diag = -beta / (2.0 * h2)\n    w_anti = beta / (2.0 * h2)\n\n    # Assemble A using COO format\n    rows, cols, data = [], [], []\n\n    for i in range(N):\n        for j in range(N):\n            k = i * N + j\n            \n            # Center\n            rows.append(k)\n            cols.append(k)\n            data.append(w_center)\n            \n            # Axis-aligned neighbors\n            if i > 0:   # (i-1, j)\n                rows.append(k); cols.append(k - N); data.append(w_axis)\n            if i  N-1: # (i+1, j)\n                rows.append(k); cols.append(k + N); data.append(w_axis)\n            if j > 0:   # (i, j-1)\n                rows.append(k); cols.append(k - 1); data.append(w_axis)\n            if j  N-1: # (i, j+1)\n                rows.append(k); cols.append(k + 1); data.append(w_axis)\n                \n            # Mixed-derivative neighbors\n            # (i-1, j-1)\n            if i > 0 and j > 0:\n                rows.append(k); cols.append(k - N - 1); data.append(w_diag)\n            # (i+1, j+1)\n            if i  N-1 and j  N-1:\n                rows.append(k); cols.append(k + N + 1); data.append(w_diag)\n            # (i-1, j+1)\n            if i > 0 and j  N-1:\n                rows.append(k); cols.append(k - N + 1); data.append(w_anti)\n            # (i+1, j-1)\n            if i  N-1 and j > 0:\n                rows.append(k); cols.append(k + N - 1); data.append(w_anti)\n\n    A = csr_matrix((data, (rows, cols)), shape=(N2, N2))\n    return A, b, u_exact.flatten()\n\ndef apply_local_fix(A_orig):\n    \"\"\"\n    Applies the local algebraic fix to restore the M-matrix property.\n    \"\"\"\n    A_fix = A_orig.todok()\n    \n    # Find positive off-diagonal entries. Iterate over a copy of keys.\n    positive_off_diagonals = []\n    for (r, c), v in A_fix.items():\n        if r != c and v > 0:\n            positive_off_diagonals.append((r, c))\n\n    for r, c in positive_off_diagonals:\n        # Check if it hasn't been zeroed out by its symmetric partner\n        if A_fix[r, c] > 0:\n            val = A_fix[r, c]\n            A_fix[r, r] += val\n            A_fix[c, c] += val  # Using symmetry, A[c,r] was also positive\n            A_fix[r, c] = 0\n            A_fix[c, r] = 0\n            \n    return A_fix.tocsr()\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute error improvements.\n    \"\"\"\n    test_cases = [\n        (33, 0.0),      # Case A\n        (33, 0.6),      # Case B\n        (17, 0.95),     # Case C\n        (33, -0.8),     # Case D\n    ]\n\n    results = []\n    for N, beta in test_cases:\n        # 1. Assemble original system\n        A_orig, b, u_exact_flat = assemble_system(N, beta)\n        \n        # 2. Solve original system and compute error\n        u_h_orig = spsolve(A_orig, b)\n        e_inf_orig = np.max(np.abs(u_h_orig - u_exact_flat))\n        \n        # 3. Apply fix\n        A_fix = apply_local_fix(A_orig)\n        \n        # 4. Solve fixed system and compute error\n        u_h_fix = spsolve(A_fix, b)\n        e_inf_fix = np.max(np.abs(u_h_fix - u_exact_flat))\n\n        # 5. Calculate error improvement\n        delta_e_inf = e_inf_orig - e_inf_fix\n        results.append(delta_e_inf)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "稳健的离散格式应建立在坚实的理论基础之上，而不仅仅依赖于代数修正。本练习将视角转向在任意多边形网格上建立的无坐标系有限体积法，并引入其核心性质——线性精确性。您将从第一性原理出发，推导并验证该格式 () 能够精确重构线性解，这一特性确保了即使在扭曲网格上，格式依然能保持一致性与准确性。",
            "id": "3379955",
            "problem": "考虑在 $\\mathbb{R}^d$ 的一个域上的各向异性扩散偏微分方程 (PDE) $-\\nabla \\cdot (A \\nabla u) = f$，其中 $A \\in \\mathbb{R}^{d \\times d}$ 是一个对称正定常数张量。您的任务是：使用重心对偶，在任意多边形网格上推导并实现一种坐标无关的通量有限体积离散化方法，并在具有旋转各向异性的倾斜网格上验证常数 $A$ 的线性精确性属性。\n\n从以下基本依据出发：\n- 散度定理：对于任何足够光滑的向量场 $q$ 和任何具有外向单位法向量 $\\boldsymbol{n}$ 的多胞体 $K$，有 $\\int_K \\nabla \\cdot q \\, dV = \\int_{\\partial K} q \\cdot \\boldsymbol{n} \\, dS$。\n- 对于任何足够光滑的标量场 $u$，在单元 $K$ 上的平均梯度满足 $\\int_K \\nabla u \\, dV = \\int_{\\partial K} u \\boldsymbol{n} \\, dS$。\n- 在多边形网格上的重心对偶构造将一个主单元划分为与低维实体（如面和顶点）相关联的子单元，从而能够基于面的贡献建立控制体积平衡，而无需引入优先坐标系。\n- 一个常数对称正定矩阵 $A$ 在 $\\mathbb{R}^d$ 上定义了一个内积和一个旋转、缩放的扩散，不依赖于任何选定的坐标基。\n\n您的目标：\n1) 在任意凸多边形单元 $K \\subset \\mathbb{R}^2$ 上，使用上述基本陈述和一个与重心对偶一致且不依赖于特定坐标系的面（边）积分求值方法，推导一个坐标无关的单元离散梯度。由此，推导出单元通量和面通量。证明该方法仅使用几何实体，如外向法线和边长，并且独立于特定的分量坐标表示。\n2) 证明常数 $A$ 的线性精确性：如果 $u(\\boldsymbol{x}) = \\boldsymbol{p} \\cdot \\boldsymbol{x} + c$，其中 $\\boldsymbol{p} \\in \\mathbb{R}^2$ 为常数向量，$c \\in \\mathbb{R}$ 为常数，则您在每个单元 $K$ 上的离散梯度等于精确梯度 $\\nabla u = \\boldsymbol{p}$，且使用常数 $A$ 计算的离散面通量等于精确面通量。解释为什么这个结果在任意凸多边形上都成立，以及重心对偶构造如何确保线性场的精确性。\n3) 实现一个程序，该程序：\n- 不接受任何输入，并按如下规定构造测试网格和参数。\n- 对每个单元，使用放置在顶点 $\\boldsymbol{v}_i$ 处的基于顶点的未知数 $u(\\boldsymbol{v}_i)$，通过与重心对偶相关的基于边的贡献，以坐标无关的方式计算单元离散梯度。仅使用几何图元：边向量、外向法线、边度量和单元面积。对于边中点处的 $u$ 值，使用由顶点线性插值所隐含的、与重心对偶一致的选择。\n- 通过将具有特征值 $a_\\parallel$ 和 $a_\\perp$ 的对角矩阵旋转给定角度 $\\theta$ 来构建一个常数各向异性张量 $A$，即 $A = R(\\theta) \\operatorname{diag}(a_\\parallel, a_\\perp) R(\\theta)^\\top$，其中 $R(\\theta)$ 是在 $\\mathbb{R}^2$ 中旋转 $\\theta$ 弧度的旋转矩阵。\n- 对每个测试用例，计算您的方法产生的离散面通量与给定线性场的精确面通量之间在所有单元边上的最大绝对误差。精确通量为 $q_{\\text{exact}} = -A \\boldsymbol{p}$，这是一个常数，通过具有外向法线 $\\boldsymbol{n}$ 和边长 $\\lvert e \\rvert$ 的有向边的精确面通量为 $(q_{\\text{exact}} \\cdot \\boldsymbol{n}) \\lvert e \\rvert$。\n- 将该用例中所有单元的所有面上的最大绝对误差汇总为一个浮点数。\n\n测试套件和参数：\n- 所有网格均为 $\\mathbb{R}^2$ 中的多边形网格，且必须按所述方式构造。您必须确保每个多边形都按逆时针方向定向。\n- 所有角度均以弧度为单位。不涉及物理单位。\n\n构造以下三个测试用例。\n\n测试用例1（理想路径，中度倾斜的多单元网格）：\n- 基础网格：在 $[0,1]^2$ 上的笛卡尔网格，单元尺寸 $h = 1/2$，产生4个四边形单元，顶点分别为 $[(0,0),(1/2,0),(1/2,1/2),(0,1/2)]$， $[(1/2,0),(1,0),(1,1/2),(1/2,1/2)]$， $[(0,1/2),(1/2,1/2),(1/2,1),(0,1)]$， $[(1/2,1/2),(1,1/2),(1,1),(1/2,1)]$。\n- 应用仿射映射 $\\boldsymbol{x} \\mapsto M_1 \\boldsymbol{x} + \\boldsymbol{b}_1$，其中\n$$\nM_1 = \\begin{pmatrix} 1  0.3 \\\\ 0  1 \\end{pmatrix}, \\quad \\boldsymbol{b}_1 = \\begin{pmatrix} 0.05 \\\\ -0.02 \\end{pmatrix}.\n$$\n- 各向异性：$\\theta_1 = \\pi/6$，$a_{\\parallel,1} = 5$，$a_{\\perp,1} = 1$。\n- 线性场：$\\boldsymbol{p}_1 = (0.7,-1.1)$，$c_1 = 0.3$。\n\n测试用例2（单个高阶多边形，全局倾斜和旋转）：\n- 基础多边形：正八边形，顶点为\n$$\n\\boldsymbol{v}_k = \\boldsymbol{c}_0 + r \\begin{pmatrix} \\cos(2\\pi k/8) \\\\ \\sin(2\\pi k/8) \\end{pmatrix}, \\quad k=0,\\dots,7,\n$$\n其中 $\\boldsymbol{c}_0 = (0.2,-0.1)$，$r=0.6$。\n- 应用仿射映射 $\\boldsymbol{x} \\mapsto M_2 \\boldsymbol{x} + \\boldsymbol{b}_2$，其中\n$$\nM_2 = \\begin{pmatrix} 1.2  0.5 \\\\ 0.2  0.9 \\end{pmatrix}, \\quad \\boldsymbol{b}_2 = \\begin{pmatrix} -0.3 \\\\ 0.15 \\end{pmatrix}.\n$$\n- 各向异性：$\\theta_2 = \\pi/3$，$a_{\\parallel,2} = 10$，$a_{\\perp,2} = 1$。\n- 线性场：$\\boldsymbol{p}_2 = (1.0,0.4)$，$c_2 = -0.2$。\n\n测试用例3（边缘情况：高度倾斜的薄平行四边形和强旋转各向异性）：\n- 单个单元：平行四边形，顶点为 $\\boldsymbol{v}_0=(0,0)$，$\\boldsymbol{v}_1=(1,0)$，$\\boldsymbol{v}_2=(1+0.8,0.05)$，$\\boldsymbol{v}_3=(0.8,0.05)$，按逆时针顺序。\n- 各向异性：$\\theta_3 = 5\\pi/12$，$a_{\\parallel,3} = 100$，$a_{\\perp,3} = 1$。\n- 线性场：$\\boldsymbol{p}_3 = (-0.3,2.0)$，$c_3 = 0.1$。\n\n要求的数值输出：\n- 对每个测试用例 $i \\in \\{1,2,3\\}$，计算所有单元所有面上的最大绝对面通量误差：\n$$\nE_i \\equiv \\max_{\\text{cells }K} \\max_{\\text{edges }e \\subset \\partial K} \\left| (q_K \\cdot \\boldsymbol{n}_e) \\lvert e \\rvert - (q_{\\text{exact}} \\cdot \\boldsymbol{n}_e) \\lvert e \\rvert \\right|,\n$$\n其中 $q_K$ 是您在 $K$ 中基于离散梯度计算的离散单元通量，$q_{\\text{exact}} = -A \\boldsymbol{p}_i$。\n- 您的程序必须输出单行结果，形式为方括号内以逗号分隔的列表，顺序为 $[E_1,E_2,E_3]$。\n\n最终答案格式：\n- 您的程序必须精确地产生一行输出，其中包含一个方括号内的逗号分隔列表的结果（例如，$[x_1,x_2,x_3]$），每个 $x_i$ 是一个浮点数。",
            "solution": "问题陈述已经过分析，并被确定为有效。它在科学上是合理的、适定的、客观的，并为偏微分方程数值分析中的一个问题提供了一套完整且一致的要求和数据。任务是推导并实现一种坐标无关的有限体积方法，并验证其线性精确性属性。\n\n## 第一部分：离散梯度和通量的推导\n\n我们的目标是在多边形单元 $K \\subset \\mathbb{R}^2$ 上推导标量场 $u$ 的梯度的离散近似。此推导的基础是平均梯度的恒等式，这是散度定理的直接推论：\n$$\n(\\nabla u)_K \\equiv \\frac{1}{|K|} \\int_K \\nabla u \\, dV = \\frac{1}{|K|} \\int_{\\partial K} u \\boldsymbol{n} \\, dS\n$$\n这里， $|K|$ 是单元 $K$ 的面积，$\\partial K$ 是其边界，$\\boldsymbol{n}$ 是边界上的外向单位法向量，$dV$ 是面积微元，$dS$ 是弧长微元。在 $\\mathbb{R}^2$ 中，我们用 $|K|$ 表示面积，用 $dl$ 表示弧长。\n\n多边形的边界 $\\partial K$ 由有限数量的直边组成，我们将其表示为 $e_j$。因此，边界积分可以写为这些边的总和：\n$$\n\\int_{\\partial K} u \\boldsymbol{n} \\, dl = \\sum_{e_j \\subset \\partial K} \\int_{e_j} u \\boldsymbol{n}_{e_j} \\, dl\n$$\n由于每个边 $e_j$ 都是一条直线段，其外向单位法线 $\\boldsymbol{n}_{e_j}$ 沿该边是恒定的。因此，我们可以将其移到积分之外：\n$$\n\\sum_{e_j \\subset \\partial K} \\int_{e_j} u \\boldsymbol{n}_{e_j} \\, dl = \\sum_{e_j \\subset \\partial K} \\boldsymbol{n}_{e_j} \\int_{e_j} u \\, dl\n$$\n要继续进行，我们必须近似积分 $\\int_{e_j} u \\, dl$。一个常用且有效的选择是中点法则，这与二阶精度和重心对偶方法的原理一致。该法则通过被积函数在边中点 $\\boldsymbol{x}_{e_j}$ 的值乘以边长 $|e_j|$ 来近似积分：\n$$\n\\int_{e_j} u \\, dl \\approx u(\\boldsymbol{x}_{e_j}) |e_j|\n$$\n问题规定，未知数是网格顶点处的 $u$ 值 $u(\\boldsymbol{v}_i)$，边中点的值应从线性插值得出。对于连接顶点 $\\boldsymbol{v}_i$ 和 $\\boldsymbol{v}_k$ 的边 $e_j$，其中点为 $\\boldsymbol{x}_{e_j} = (\\boldsymbol{v}_i + \\boldsymbol{v}_k)/2$。在该中点处的 $u$ 值通过顶点值的平均值来近似：\n$$\nu(\\boldsymbol{x}_{e_j}) \\approx \\frac{u(\\boldsymbol{v}_i) + u(\\boldsymbol{v}_k)}{2}\n$$\n将这些近似代入梯度公式，得到单元 $K$ 的离散梯度：\n$$\n\\nabla_K u = \\frac{1}{|K|} \\sum_{e_{jk} \\subset \\partial K} \\frac{u(\\boldsymbol{v}_j) + u(\\boldsymbol{v}_k)}{2} |e_{jk}| \\boldsymbol{n}_{e_{jk}}\n$$\n其中，求和遍历单元的所有边 $e_{jk}$，连接顶点 $\\boldsymbol{v}_j$ 和 $\\boldsymbol{v}_k$。为方便实现，使用缩放后的外向法向量 $\\boldsymbol{N}_{e_{jk}} = |e_{jk}|\\boldsymbol{n}_{e_{jk}}$。如果单元的顶点按逆时针排序，且边 $e_{jk}$ 连接 $\\boldsymbol{v}_j=(x_j, y_j)$ 和 $\\boldsymbol{v}_k=(x_k, y_k)$，则此缩放法向量就是 $\\boldsymbol{N}_{e_{jk}} = (y_k - y_j, -(x_k - x_j))$。公式变为：\n$$\n\\nabla_K u = \\frac{1}{2|K|} \\sum_{e_{jk} \\subset \\partial K} (u(\\boldsymbol{v}_j) + u(\\boldsymbol{v}_k)) \\boldsymbol{N}_{e_{jk}}\n$$\n此公式是坐标无关的，因为它完全由几何不变量（单元面积、用于导出边向量和法线的顶点坐标）和场 $u$ 的节点值构成。它不依赖于坐标系轴的特定选择。\n\n根据离散梯度，单元常数离散通量向量 $q_K$ 定义为：\n$$\nq_K = -A \\nabla_K u\n$$\n其中 $A$ 是常数扩散张量。从单元 $K$ 穿过边 $e_j$ 的总通量则由下式给出：\n$$\nF_{e_j} = \\int_{e_j} q_K \\cdot \\boldsymbol{n}_{e_j} \\, dl = (q_K \\cdot \\boldsymbol{n}_{e_j}) |e_j| = q_K \\cdot \\boldsymbol{N}_{e_j}\n$$\n\n## 第二部分：线性精确性的证明\n\n高质量离散格式的一个关键特性是线性精确性：能够精确地再现线性场的梯度。我们现在证明所推导的离散梯度 $\\nabla_K u$ 满足此属性。\n\n设标量场 $u$ 是位置 $\\boldsymbol{x}$ 的线性函数：\n$$\nu(\\boldsymbol{x}) = \\boldsymbol{p} \\cdot \\boldsymbol{x} + c\n$$\n对于常数向量 $\\boldsymbol{p} \\in \\mathbb{R}^2$ 和常数标量 $c \\in \\mathbb{R}$。该场的精确梯度为 $\\nabla u = \\boldsymbol{p}$。\n\n在任意顶点 $\\boldsymbol{v}_i$ 处，$u$ 的值为 $u(\\boldsymbol{v}_i) = \\boldsymbol{p} \\cdot \\boldsymbol{v}_i + c$。对于连接 $\\boldsymbol{v}_j$ 和 $\\boldsymbol{v}_k$ 的边 $e_{jk}$ 及其中心点 $\\boldsymbol{x}_{e_{jk}}$，$u$ 在该中点处的精确值为：\n$$\nu(\\boldsymbol{x}_{e_{jk}}) = \\boldsymbol{p} \\cdot \\boldsymbol{x}_{e_{jk}} + c = \\boldsymbol{p} \\cdot \\left(\\frac{\\boldsymbol{v}_j + \\boldsymbol{v}_k}{2}\\right) + c = \\frac{(\\boldsymbol{p} \\cdot \\boldsymbol{v}_j + c) + (\\boldsymbol{p} \\cdot \\boldsymbol{v}_k + c)}{2} = \\frac{u(\\boldsymbol{v}_j) + u(\\boldsymbol{v}_k)}{2}\n$$\n这表明我们对中点值的近似对于任何线性场都是精确的。\n\n此外，中点求积法则对于在区间上积分线性函数是精确的。由于 $u(\\boldsymbol{x})$ 沿任何直边 $e_j$ 线性变化， $u$ 在该边上的积分恰好是中点值乘以边长：\n$$\n\\int_{e_j} u \\, dl = u(\\boldsymbol{x}_{e_j}) |e_j|\n$$\n因此，我们离散梯度公式中的求和对于线性场而言不是近似，而是与连续边界积分完全相同：\n$$\n\\nabla_K u = \\frac{1}{|K|} \\sum_{e_j \\subset \\partial K} u(\\boldsymbol{x}_{e_j}) |e_j| \\boldsymbol{n}_{e_j} = \\frac{1}{|K|} \\int_{\\partial K} u \\boldsymbol{n} \\, dl\n$$\n代入 $u(\\boldsymbol{x}) = \\boldsymbol{p} \\cdot \\boldsymbol{x} + c$：\n$$\n\\nabla_K u = \\frac{1}{|K|} \\int_{\\partial K} (\\boldsymbol{p} \\cdot \\boldsymbol{x} + c) \\boldsymbol{n} \\, dl = \\frac{1}{|K|} \\left( \\int_{\\partial K} (\\boldsymbol{p} \\cdot \\boldsymbol{x}) \\boldsymbol{n} \\, dl + c \\int_{\\partial K} \\boldsymbol{n} \\, dl \\right)\n$$\n我们使用两个关于 $\\mathbb{R}^2$ 中任意闭合边界 $\\partial K$ 的标准几何恒等式：\n1. $\\int_{\\partial K} \\boldsymbol{n} \\, dl = \\int_K \\nabla(1) \\, dA = \\boldsymbol{0}$。\n2. 对于任何常数向量 $\\boldsymbol{p}$，$\\int_{\\partial K} (\\boldsymbol{p} \\cdot \\boldsymbol{x}) \\boldsymbol{n} \\, dl = |K| \\boldsymbol{p}$。这个恒等式可以通过分量方式使用散度定理来证明。积分的第 $i$ 个分量是 $\\int_{\\partial K} (\\sum_j p_j x_j) n_i \\, dl = \\int_K \\nabla \\cdot ((\\sum_j p_j x_j) \\boldsymbol{e}_i) \\, dA = \\int_K \\frac{\\partial}{\\partial x_i}(\\sum_j p_j x_j) \\, dA = \\int_K p_i \\, dA = p_i |K|$。对所有分量求和得到 $|K|\\boldsymbol{p}$。\n\n将这些恒等式应用于我们的 $\\nabla_K u$ 表达式：\n$$\n\\nabla_K u = \\frac{1}{|K|} ( |K| \\boldsymbol{p} + c \\cdot \\boldsymbol{0} ) = \\boldsymbol{p}\n$$\n这证明了对于任何线性场，在任何凸多边形 $K$ 上，离散梯度 $\\nabla_K u$ 都精确等于真实梯度 $\\nabla u = \\boldsymbol{p}$。线性精确性这一属性的成立与单元的形状或由张量 $A$ 定义的各向异性的方向和大小无关。\n\n因为 $\\nabla_K u = \\boldsymbol{p}$，立即可以得出离散通量 $q_K = -A \\nabla_K u$ 等于精确通量 $q_{\\text{exact}} = -A \\boldsymbol{p}$。因此，穿过任何面的离散通量 $(q_K \\cdot \\boldsymbol{n}_e)|e|$ 与精确通量 $(q_{\\text{exact}} \\cdot \\boldsymbol{n}_e)|e|$ 完全相同。因此，问题陈述中定义的误差度量 $E_i$ 必须为零，直至浮点精度的限制。下面的实现将从数值上验证这一点。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and verifies a coordinate-free finite volume discretization\n    of fluxes for the anisotropic diffusion equation, focusing on linear exactness.\n    \"\"\"\n\n    def _calculate_discrete_gradient(cell_verts, vert_values):\n        \"\"\"\n        Calculates the discrete gradient for a single polygonal cell using the\n        coordinate-free formula derived from the Divergence Theorem.\n\n        Args:\n            cell_verts (list of np.ndarray): List of vertex coordinate vectors (CCW order).\n            vert_values (list of float): List of scalar field values at the vertices.\n\n        Returns:\n            np.ndarray: The computed discrete gradient vector for the cell.\n        \"\"\"\n        num_verts = len(cell_verts)\n        area = 0.0\n        grad_sum = np.zeros(2, dtype=np.float64)\n\n        for i in range(num_verts):\n            v_curr = cell_verts[i]\n            v_next = cell_verts[(i + 1) % num_verts]\n            u_curr = vert_values[i]\n            u_next = vert_values[(i + 1) % num_verts]\n\n            # Shoelace formula for signed area. Positive for CCW.\n            area += 0.5 * (v_curr[0] * v_next[1] - v_next[0] * v_curr[1])\n\n            # Edge midpoint value of the field u\n            u_mid = 0.5 * (u_curr + u_next)\n            \n            # Scaled outward normal vector: |e|*n_e = (dy, -dx) for CCW polygons\n            scaled_normal = np.array([v_next[1] - v_curr[1], -(v_next[0] - v_curr[0])], dtype=np.float64)\n            \n            grad_sum += u_mid * scaled_normal\n\n        if abs(area)  1e-15:\n            # Degenerate cell\n            return np.zeros(2, dtype=np.float64)\n            \n        return grad_sum / area\n\n    def _apply_affine_map(mesh, M, b):\n        \"\"\"Applies an affine map to all vertices of a mesh.\"\"\"\n        new_mesh = []\n        for cell in mesh:\n            new_cell = [(M @ v + b) for v in cell]\n            new_mesh.append(new_cell)\n        return new_mesh\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Test Case 1: Moderately skewed multi-cell mesh\",\n            \"mesh_generator\": lambda: _apply_affine_map(\n                [\n                    [np.array([0.0, 0.0]), np.array([0.5, 0.0]), np.array([0.5, 0.5]), np.array([0.0, 0.5])],\n                    [np.array([0.5, 0.0]), np.array([1.0, 0.0]), np.array([1.0, 0.5]), np.array([0.5, 0.5])],\n                    [np.array([0.0, 0.5]), np.array([0.5, 0.5]), np.array([0.5, 1.0]), np.array([0.0, 1.0])],\n                    [np.array([0.5, 0.5]), np.array([1.0, 0.5]), np.array([1.0, 1.0]), np.array([0.5, 1.0])]\n                ],\n                M=np.array([[1.0, 0.3], [0.0, 1.0]]),\n                b=np.array([0.05, -0.02])\n            ),\n            \"anisotropy\": {\"theta\": np.pi / 6, \"a_par\": 5.0, \"a_perp\": 1.0},\n            \"linear_field\": {\"p\": np.array([0.7, -1.1]), \"c\": 0.3},\n        },\n        {\n            \"name\": \"Test Case 2: Single high-order polygon, global skew and rotation\",\n            \"mesh_generator\": lambda: _apply_affine_map(\n                [\n                    [np.array([0.2 + 0.6 * np.cos(2 * np.pi * k / 8), -0.1 + 0.6 * np.sin(2 * np.pi * k / 8)]) for k in range(8)]\n                ],\n                M=np.array([[1.2, 0.5], [0.2, 0.9]]),\n                b=np.array([-0.3, 0.15])\n            ),\n            \"anisotropy\": {\"theta\": np.pi / 3, \"a_par\": 10.0, \"a_perp\": 1.0},\n            \"linear_field\": {\"p\": np.array([1.0, 0.4]), \"c\": -0.2},\n        },\n        {\n            \"name\": \"Test Case 3: Highly skewed thin parallelogram and strong anisotropy\",\n            \"mesh_generator\": lambda: [\n                [np.array([0.0, 0.0]), np.array([1.0, 0.0]), np.array([1.8, 0.05]), np.array([0.8, 0.05])]\n            ],\n            \"anisotropy\": {\"theta\": 5 * np.pi / 12, \"a_par\": 100.0, \"a_perp\": 1.0},\n            \"linear_field\": {\"p\": np.array([-0.3, 2.0]), \"c\": 0.1},\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # 1. Construct mesh for the current test case\n        mesh = case[\"mesh_generator\"]()\n\n        # 2. Construct anisotropy tensor A\n        theta = case[\"anisotropy\"][\"theta\"]\n        a_par = case[\"anisotropy\"][\"a_par\"]\n        a_perp = case[\"anisotropy\"][\"a_perp\"]\n        c, s = np.cos(theta), np.sin(theta)\n        R = np.array([[c, -s], [s, c]])\n        D = np.diag([a_par, a_perp])\n        A = R @ D @ R.T\n\n        # 3. Define linear field and exact flux\n        p = case[\"linear_field\"][\"p\"]\n        c_const = case[\"linear_field\"][\"c\"]\n        q_exact = -A @ p\n\n        max_flux_error = 0.0\n\n        # 4. Iterate over all cells in the mesh\n        for cell_verts in mesh:\n            # Evaluate linear field at vertices\n            vert_values = [(p @ v + c_const) for v in cell_verts]\n            \n            # Compute discrete gradient and flux\n            grad_K_u = _calculate_discrete_gradient(cell_verts, vert_values)\n            q_K = -A @ grad_K_u\n            \n            # 5. Iterate over all edges of the cell\n            num_verts = len(cell_verts)\n            for i in range(num_verts):\n                v_curr = cell_verts[i]\n                v_next = cell_verts[(i + 1) % num_verts]\n\n                # Scaled outward normal vector needed for integrated flux calculation\n                scaled_normal = np.array([v_next[1] - v_curr[1], -(v_next[0] - v_curr[0])])\n                \n                # Compute discrete and exact face fluxes\n                flux_discrete = q_K @ scaled_normal\n                flux_exact = q_exact @ scaled_normal\n                \n                # Update maximum absolute error over all faces\n                error = abs(flux_discrete - flux_exact)\n                if error > max_flux_error:\n                    max_flux_error = error\n        \n        results.append(max_flux_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在建立了稳健的格式之后，具体实现细节的选择对于处理复杂问题至关重要。本练习在一个具有强烈且空间变化的各向异性（其主方向与网格不一致）的严苛场景中，对两种主流的梯度重构方案——高斯梯度法与最小二乘法——进行正面比较。通过量化局部通量的守恒误差 ()，您将深入理解这些高等技术在实际应用中的优缺点，为解决真实世界的研究问题提供实践依据。",
            "id": "3379997",
            "problem": "考虑在单位环面（周期性单位正方形）上的二维空间中的各向异性扩散方程，该方程由标量场 $u(x,y)$ 的守恒律定义：\n$$ -\\nabla \\cdot \\left( \\mathbf{K}(x,y) \\nabla u(x,y) \\right) = 0, \\quad (x,y) \\in [0,1)\\times[0,1). $$\n扩散张量 $\\mathbf{K}(x,y)$ 是对称正定的，其主方向随空间变化。主方向在不同的水平层之间于两个正交方向上交替，从而产生交替的局部主轴。设基础主方向角为 $\\theta_0$（以弧度为单位），并定义层厚度 $t \\in (0,1]$，使得对于任意坐标为 $y$ 的点，其局部主方向角为\n$$ \\theta(y) = \\begin{cases}\n\\theta_0,  \\text{若 } \\left\\lfloor \\dfrac{y \\bmod 1}{t} \\right\\rfloor \\text{ 为偶数},\\\\\n\\theta_0 + \\dfrac{\\pi}{2},  \\text{若 } \\left\\lfloor \\dfrac{y \\bmod 1}{t} \\right\\rfloor \\text{ 为奇数}。\n\\end{cases} $$\n在每个位置，扩散张量由旋转矩阵 $\\mathbf{R}(\\theta)$ 和主扩散率 $k_1$ 和 $k_2$ 构建而成，具体如下：\n$$ \\mathbf{K}(x,y) = \\mathbf{R}(\\theta(y)) \\begin{bmatrix} k_1  0 \\\\ 0  k_2 \\end{bmatrix} \\mathbf{R}(\\theta(y))^\\top, $$\n其中各向异性比 $r = \\dfrac{k_1}{k_2}  1$。为使下文所有测试案例具体化，取 $k_1 = r$ 和 $k_2 = 1$。\n\n为了探究在网格-各向异性错位配置下，仅由梯度重构引起的局部通量守恒性质，我们使用一个人工制造的光滑周期场：\n$$ u(x,y) = \\sin(2\\pi x)\\,\\sin(2\\pi y). $$\n本问题不使用物理单位。角度必须以弧度处理。\n\n用一个 $N_x \\times N_y$ 控制体（有限体积）的均匀笛卡尔网格离散化单位环面，并在 $x$ 和 $y$ 方向上均采用周期性边界条件。设每个控制体由整数对 $(i,j)$ 索引，其中 $i \\in \\{0,1,\\dots,N_x-1\\}$ 且 $j \\in \\{0,1,\\dots,N_y-1\\}$。单元中心坐标为\n$$ x_i = \\dfrac{i+\\tfrac{1}{2}}{N_x}, \\quad y_j = \\dfrac{j+\\tfrac{1}{2}}{N_y}. $$\n定义穿过相邻控制体共享的内部面的面法向通量如下。对于 $(i,j)$ 和 $(i+1,j)$ 之间的水平面，设从 $(i,j)$ 指向 $(i+1,j)$ 的单位法向量为 $\\mathbf{n} = [1,0]^\\top$，面长度为 $A_f = \\dfrac{1}{N_y}$。对于 $(i,j)$ 和 $(i,j+1)$ 之间的垂直面，设从 $(i,j)$ 指向 $(i,j+1)$ 的单位法向量为 $\\mathbf{n} = [0,1]^\\top$，面长度为 $A_f = \\dfrac{1}{N_x}$。在每个面上，通过在面中心的 $y$ 坐标处计算 $\\theta(y)$ 并使用给定的 $r$ 来构造扩散张量 $\\mathbf{K}_f$；这确保了在每一层内张量是恒定的，并且交替的主方向在层与层之间得以实现。为了周期性，索引和坐标以 $N_x$ 和 $N_y$ 为模进行回卷。\n\n需要从第一性原理实现两种单元中心的梯度重构策略：\n- Gauss梯度（Green–Gauss）重构，该方法将散度定理应用于控制体，并使用面上插值的 $u$ 值来近似每个单元中心的 $\\nabla u$。\n- 最小二乘梯度重构，该方法将每个单元中心的 $\\nabla u$ 定义为一个最小化子，该最小化子使 $u$ 的方向增量与候选梯度沿着连接一组相邻单元中心的向量的投影之间的平方差之和最小，并采用基于距离的权重。\n\n对于由单元 $L$ 和 $R$ 共享的任意内部面，其从 $L$ 指向 $R$ 的向外单位法向量为 $\\mathbf{n}$，使用重构的梯度定义两种扩散通量密度的单边近似：\n$$ \\phi_L = -\\, \\mathbf{n}^\\top \\mathbf{K}_f \\left(\\nabla u\\right)_L, \\qquad \\phi_R = -\\, (-\\mathbf{n})^\\top \\mathbf{K}_f \\left(\\nabla u\\right)_R. $$\n跨面的局部守恒要求通量是单值的；其违背程度的一个度量是双边通量不平衡的量级：\n$$ \\Delta_f = \\left| \\phi_L A_f + \\phi_R A_f \\right|. $$\n将一个网格上特定方法的最坏情况下面不平衡定义为\n$$ E = \\max_{f \\in \\mathcal{F}_{\\text{int}}} \\Delta_f, $$\n其中 $\\mathcal{F}_{\\text{int}}$ 表示周期性网格上的所有内部面（包括那些回卷的面）。通过比率比较这两种策略：\n$$ \\rho = \\dfrac{E_{\\text{LS}}}{E_{\\text{GG}} + \\varepsilon}, $$\n其中正则化参数 $\\varepsilon = 10^{-15}$ 用于避免除以零。$\\rho  1$ 的值表明，在给定设置下，最小二乘法产生的最坏情况下面不平衡小于Gauss梯度法。\n\n您的任务是实现一个程序，对于下面的每个测试案例，构建网格，计算所有单元中心的 $u(x_i,y_j)$，通过两种策略重构梯度，在所有面上使用指定的 $\\mathbf{K}_f$ 计算 $\\Delta_f$，并为每个案例输出比率 $\\rho$。\n\n为确保公平性和覆盖范围的实现细节与约束：\n- 在两个方向上都使用周期性边界条件。\n- 对于Gauss梯度重构，应用Green–Gauss思想，使用面上插值的单元值，这在均匀笛卡尔网格上简化为使用两个坐标方向上直接面相邻单元的对称中心差分重构。\n- 对于最小二乘重构，对每个单元使用其周围的8个相邻单元（Moore邻域），权重等于单元中心之间距离的平方的倒数。求解每个单元处的 $2 \\times 2$ 法方程以获得梯度。\n- 对于每个面，取在其面中心 $y$ 坐标处构造的 $\\mathbf{K}_f$（其中 $k_1=r, k_2=1$），使用如上定义的层角度 $\\theta(y)$。\n\n测试套件：\n- 案例 $\\mathrm{A}$ (理想路径，中等各向异性，主方向错位)：$N_x=32$, $N_y=32$, $r=100$, $\\theta_0=\\dfrac{\\pi}{4}$, $t=0.5$。\n- 案例 $\\mathrm{B}$ (强各向异性与薄交替层)：$N_x=31$, $N_y=30$, $r=1000$, $\\theta_0=\\dfrac{\\pi}{4}$, $t=0.1$。\n- 案例 $\\mathrm{C}$ (基线与网格轴对齐但按层交替)：$N_x=32, $N_y=32$, $r=100, \\theta_0=0, $t=0.25$。\n- 案例 $\\mathrm{D}$ (不同的错位和中等各向异性)：$N_x=20$, $N_y=24$, $r=50$, $\\theta_0=\\dfrac{\\pi}{6}$, $t=\\dfrac{1}{6}$。\n\n最终输出规格：\n- 您的程序应生成单行输出，包含案例 $\\mathrm{A}$, $\\mathrm{B}$, $\\mathrm{C}$, 和 $\\mathrm{D}$ 的比率 $\\rho$，按此顺序，以逗号分隔的列表形式，并用方括号括起来，每个值四舍五入到6位小数（例如，$[0.123456,0.654321,1.000000,0.987650]$）。",
            "solution": "### 问题验证\n\n**第一步：提取已知信息**\n\n-   **控制方程**：各向异性扩散 $-\\nabla \\cdot \\left( \\mathbf{K}(x,y) \\nabla u(x,y) \\right) = 0$。\n-   **域**：单位环面 $[0,1) \\times [0,1)$，带有周期性边界。\n-   **人工解**：$u(x,y) = \\sin(2\\pi x)\\,\\sin(2\\pi y)$。\n-   **扩散张量** $\\mathbf{K}(x,y)$：$\\mathbf{K}(x,y) = \\mathbf{R}(\\theta(y)) \\begin{bmatrix} k_1  0 \\\\ 0  k_2 \\end{bmatrix} \\mathbf{R}(\\theta(y))^\\top$。\n-   **主扩散率**：$k_1 = r$, $k_2 = 1$，其中 $r  1$ 是各向异性比。\n-   **主方向角** $\\theta(y)$：\n    $$ \\theta(y) = \\begin{cases} \\theta_0,  \\text{若 } \\left\\lfloor \\dfrac{y \\bmod 1}{t} \\right\\rfloor \\text{ 为偶数},\\\\ \\theta_0 + \\dfrac{\\pi}{2},  \\text{若 } \\left\\lfloor \\dfrac{y \\bmod 1}{t} \\right\\rfloor \\text{ 为奇数}。 \\end{cases} $$\n    其中 $\\theta_0$ 是基础方向， $t$ 是层厚度。\n-   **离散化**：$N_x \\times N_y$ 控制体的均匀笛卡尔网格。\n-   **单元中心**：$x_i = \\dfrac{i+\\tfrac{1}{2}}{N_x}$ (对于 $i \\in \\{0, \\dots, N_x-1\\}$)，以及 $y_j = \\dfrac{j+\\tfrac{1}{2}}{N_y}$ (对于 $j \\in \\{0, \\dots, N_y-1\\}$)。\n-   **面几何**：\n    -   水平面（x-面）：法向量 $\\mathbf{n} = [1,0]^\\top$，面积 $A_f = 1/N_y$。\n    -   垂直面（y-面）：法向量 $\\mathbf{n} = [0,1]^\\top$，面积 $A_f = 1/N_x$。\n-   **面上的张量**：$\\mathbf{K}_f$ 在面中心的 $y$ 坐标处计算。\n-   **梯度重构方法**：\n    1.  **Gauss梯度 (GG)**：在均匀网格上的对称中心差分。\n    2.  **最小二乘 (LS)**：使用8个Moore邻域，权重等于距离的平方倒数。\n-   **通量不平衡**：对于单元 $L$ 和 $R$ 之间，法向量从 $L$ 指向 $R$ 的面：\n    -   单边通量密度：$\\phi_L = -\\mathbf{n}^\\top \\mathbf{K}_f (\\nabla u)_L$, $\\phi_R = -(-\\mathbf{n})^\\top \\mathbf{K}_f (\\nabla u)_R$。\n    -   面不平衡：$\\Delta_f = |\\phi_L A_f + \\phi_R A_f|$。\n-   **误差度量与比较**：\n    -   最坏情况不平衡：$E = \\max_{f \\in \\mathcal{F}_{\\text{int}}} \\Delta_f$。\n    -   比较比率：$\\rho = \\dfrac{E_{\\text{LS}}}{E_{\\text{GG}} + \\varepsilon}$，其中 $\\varepsilon = 10^{-15}$。\n-   **测试案例**：\n    -   A: $N_x=32, N_y=32, r=100, \\theta_0=\\pi/4, t=0.5$。\n    -   B: $N_x=31, N_y=30, r=1000, \\theta_0=\\pi/4, t=0.1$。\n    -   C: $N_x=32, N_y=32, r=100, \\theta_0=0, t=0.25$。\n    -   D: $N_x=20, N_y=24, r=50, \\theta_0=\\pi/6, t=1/6$。\n\n**第二步：使用提取的已知信息进行验证**\n\n该问题具有科学依据。它涉及偏微分方程（PDE）的数值解，特别是各向异性扩散方程，这是许多STEM领域的基础模型。所描述的方法——有限体积离散化、Gauss梯度和最小二乘梯度重构，以及使用人工解方法进行验证——都是计算物理和工程中标准的、成熟的技术。\n\n该问题是适定的、客观的。所有术语、变量和程序都用数学精确地定义。任务是一个定义明确的计算算法，对于每组输入都有唯一的数值输出。语言正式，没有歧义或主观性。\n\n问题设置是完整且一致的。它提供了执行所需计算的所有必要参数、方程和算法约束。使用不一定满足齐次PDE的人工解 $u(x,y)$ 是数值分析中的一个刻意且标准的选择，用于独立于PDE解的离散化误差来测试离散化方案的性质（在这种情况下是局部通量守恒）。\n\n**第三步：结论与行动**\n\n问题有效。我们将继续进行完整求解。\n\n### 解法\n\n任务是为四个不同的测试案例计算比率 $\\rho = E_{\\text{LS}} / (E_{\\text{GG}} + \\varepsilon)$。这需要实现两种不同的梯度重构方案和一个在周期性网格上评估通量不平衡的程序。每个测试案例的总体方法如下：\n\n1.  **网格与场设置**：在域 $[0,1) \\times [0,1)$ 上定义一个大小为 $N_x \\times N_y$ 的均匀笛卡尔网格。计算单元中心坐标 $(x_i, y_j)$，并在这些点上计算人工标量场 $u(x_i, y_j)$。为了处理梯度和通量计算中的周期性，使用带有“幽灵”单元的填充网格是有利的。\n2.  **梯度重构**：使用两种方法在每个单元中心近似 $u$ 的梯度 $\\nabla u$：\n    a. Gauss梯度 (GG) 重构。\n    b. 最小二乘 (LS) 重构。\n3.  **通量不平衡计算**：对于网格中的每个面，使用相邻单元的重构梯度计算单边通量。计算通量不平衡的量级 $\\Delta_f$。\n4.  **误差评估**：为每种方法（$E_{\\text{GG}}$ 和 $E_{\\text{LS}}$）找到所有面上的最大不平衡 $E$。\n5.  **比率计算**：计算最终比率 $\\rho$。\n\n我们现在从数学和算法的角度详细说明每个步骤。\n\n**1. 网格与场设置**\n\n对于一个 $N_x \\times N_y$ 单元的网格，单元尺寸为 $\\Delta x = 1/N_x$ 和 $\\Delta y = 1/N_y$。单元中心的坐标为：\n$$ x_i = (i+0.5)\\Delta x, \\quad y_j = (j+0.5)\\Delta y $$\n对于 $i \\in \\{0, \\dots, N_x-1\\}$ 和 $j \\in \\{0, \\dots, N_y-1\\}$。标量场 $u$ 在这 $N_x \\times N_y$ 个点上被计算。\n构造一个填充的场值数组，以简化周期性边界附近的模板操作。这个填充数组在核心网格周围包含一层“幽灵”单元，其值是域另一侧单元的副本。\n\n**2. 梯度重构**\n\n**a. Gauss梯度 (GG) 重构**\n如规定，在均匀笛卡尔网格上，此方法简化为二阶中心差分公式。对于单元 $(i,j)$，梯度分量为：\n$$ (\\nabla u)_{\\text{GG}, i, j} = \\begin{bmatrix} \\frac{\\partial u}{\\partial x} \\\\ \\frac{\\partial u}{\\partial y} \\end{bmatrix}_{i,j} \\approx \\begin{bmatrix} \\frac{u_{i+1,j} - u_{i-1,j}}{2\\Delta x} \\\\ \\frac{u_{i,j+1} - u_{i,j-1}}{2\\Delta y} \\end{bmatrix} $$\n在这里，索引是周期性处理的（例如，$u_{-1,j} = u_{N_x-1,j}$）。这些计算可以使用填充网格数据的切片进行高效的矢量化。\n\n**b. 最小二乘 (LS) 重构**\n在每个单元中心 $(i,j)$，梯度 $\\nabla u = [g_x, g_y]^\\top$ 是通过最小化 $k=8$ 个Moore邻域上的加权平方误差和来找到的：\n$$ \\underset{g_x, g_y}{\\text{minimize}} \\sum_{k=1}^{8} w_k \\left( (\\nabla u) \\cdot \\mathbf{d}_k - \\Delta u_k \\right)^2 $$\n其中 $\\mathbf{d}_k$ 是到邻居 $k$ 的位移向量，$\\Delta u_k$ 是标量场的差值，而 $w_k = 1/\\|\\mathbf{d}_k\\|^2$ 是权重。这导出了一个 $2 \\times 2$ 的法方程组 $\\mathbf{A} \\nabla u = \\mathbf{b}$，其中：\n$$ \\mathbf{A} = \\sum_{k=1}^{8} w_k \\mathbf{d}_k \\mathbf{d}_k^\\top = \\begin{bmatrix} \\sum w_k d_{x,k}^2  \\sum w_k d_{x,k} d_{y,k} \\\\ \\sum w_k d_{x,k} d_{y,k}  \\sum w_k d_{y,k}^2 \\end{bmatrix} $$\n$$ \\mathbf{b} = \\sum_{k=1}^{8} w_k \\Delta u_k \\mathbf{d}_k = \\begin{bmatrix} \\sum w_k \\Delta u_k d_{x,k} \\\\ \\sum w_k \\Delta u_k d_{y,k} \\end{bmatrix} $$\n由于笛卡尔网格上Moore邻域的对称性，$\\mathbf{A}$ 的非对角项为零（即 $\\sum w_k d_{x,k} d_{y,k} = 0$），使得矩阵是对角阵。解则简化为 $(\\nabla u)_{\\text{LS}} = [b_x/A_{xx}, b_y/A_{yy}]^\\top$。分量 $A_{xx}$, $A_{yy}$, $b_x$, 和 $b_y$ 可以从u的模板值和网格间距 $\\Delta x, \\Delta y$ 计算得出。这些计算也可以在整个网格上完全矢量化。\n\n**3. 通量不平衡计算**\n\n对所有垂直（x-法向）和水平（y-法向）面计算不平衡。让我们考虑一个在单元 $L$ 和单元 $R$ 之间的通用面，单位法向量 $\\mathbf{n}$ 从 $L$ 指向 $R$。不平衡为 $\\Delta_f = |(\\phi_L + \\phi_R) A_f|$，其中：\n$$ \\phi_L = -\\mathbf{n}^\\top \\mathbf{K}_f (\\nabla u)_L \\quad \\text{和} \\quad \\phi_R = -(-\\mathbf{n})^\\top \\mathbf{K}_f (\\nabla u)_R = \\mathbf{n}^\\top \\mathbf{K}_f (\\nabla u)_R $$\n因此，$\\Delta_f = | A_f \\cdot \\mathbf{n}^\\top \\mathbf{K}_f ((\\nabla u)_R - (\\nabla u)_L) |$。\n\n面上的扩散张量 $\\mathbf{K}_f$ 是使用给定的主扩散率 $k_1=r, k_2=1$ 和由面的 $y$ 坐标 $y_f$ 决定的旋转角 $\\theta(y_f)$ 构建的：\n$$ \\mathbf{K}_f = \\begin{bmatrix} c  -s \\\\ s  c \\end{bmatrix} \\begin{bmatrix} k_1  0 \\\\ 0  k_2 \\end{bmatrix} \\begin{bmatrix} c  s \\\\ -s  c \\end{bmatrix} = \\begin{bmatrix} k_1 c^2 + k_2 s^2  (k_1-k_2)cs \\\\ (k_1-k_2)cs  k_1 s^2 + k_2 c^2 \\end{bmatrix} $$\n其中 $c = \\cos(\\theta(y_f))$ 和 $s = \\sin(\\theta(y_f))$。\n\n-   **对于垂直面（x-面）**，在 $(i,j)$ 和 $(i+1,j)$ 之间：$\\mathbf{n}=[1,0]^\\top$，$A_f = \\Delta y$。面的 $y$ 坐标是 $y_f = y_j$。不平衡为：\n    $$ \\Delta_{f,x} = \\left| \\Delta y \\left( K_{11,f} (g_{x,R}-g_{x,L}) + K_{12,f} (g_{y,R}-g_{y,L}) \\right) \\right| $$\n    其中 $\\mathbf{g}_L = (\\nabla u)_L$ 和 $\\mathbf{g}_R = (\\nabla u)_R$。这对GG和LS梯度都进行计算。\n\n-   **对于水平面（y-面）**，在 $(i,j)$ 和 $(i,j+1)$ 之间：$\\mathbf{n}=[0,1]^\\top$，$A_f = \\Delta x$。面的 $y$ 坐标是 $y_f = (j+1)\\Delta y$。不平衡为：\n    $$ \\Delta_{f,y} = \\left| \\Delta x \\left( K_{21,f} (g_{x,R}-g_{x,L}) + K_{22,f} (g_{y,R}-g_{y,L}) \\right) \\right| $$\n    注意 $K_{21,f}=K_{12,f}$。\n\n**4. 误差评估与比率计算**\n\n对于每种梯度方法（GG和LS），在所有面上找到最大不平衡：\n$$ E_{\\text{GG}} = \\max (\\max_{f_x} \\Delta_{f_x, \\text{GG}}, \\max_{f_y} \\Delta_{f_y, \\text{GG}}) $$\n$$ E_{\\text{LS}} = \\max (\\max_{f_x} \\Delta_{f_x, \\text{LS}}, \\max_{f_y} \\Delta_{f_y, \\text{LS}}) $$\n最终比率 $\\rho$ 计算为 $\\rho = E_{\\text{LS}} / (E_{\\text{GG}} + \\varepsilon)$，其中 $\\varepsilon = 10^{-15}$。对四个测试案例中的每一个都重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(Nx, Ny, r, theta_0, t):\n    \"\"\"\n    Computes the flux imbalance ratio for a single test case.\n    \"\"\"\n    # Constants\n    k1 = r\n    k2 = 1.0\n    epsilon = 1e-15\n    PI = np.pi\n\n    # Mesh and field setup\n    dx = 1.0 / Nx\n    dy = 1.0 / Ny\n    x_coords = (np.arange(Nx) + 0.5) * dx\n    y_coords = (np.arange(Ny) + 0.5) * dy\n    # meshgrid uses (row, col) which corresponds to (y, x)\n    x_cc, y_cc = np.meshgrid(x_coords, y_coords) # shape: (Ny, Nx)\n\n    # Manufactured solution at cell centers\n    u_cc = np.sin(2 * PI * x_cc) * np.sin(2 * PI * y_cc)\n\n    # --- Gradient Reconstructions ---\n\n    # Padded array for easier periodic stencil operations\n    u_padded = np.zeros((Ny + 2, Nx + 2))\n    u_padded[1:-1, 1:-1] = u_cc\n    # Periodic BCs in y-direction (rows)\n    u_padded[0, 1:-1] = u_cc[-1, :]\n    u_padded[-1, 1:-1] = u_cc[0, :]\n    # Periodic BCs in x-direction (cols)\n    u_padded[:, 0] = u_padded[:, Nx]\n    u_padded[:, -1] = u_padded[:, 1]\n    \n    # --- 1. Gauss-Gradient (Central Differences) ---\n    grad_u_gg = np.zeros((Ny, Nx, 2))\n    # du/dx: shape (Ny, Nx)\n    grad_u_gg[:, :, 0] = (u_padded[1:-1, 2:] - u_padded[1:-1, :-2]) / (2 * dx)\n    # du/dy: shape (Ny, Nx)\n    grad_u_gg[:, :, 1] = (u_padded[2:, 1:-1] - u_padded[:-2, 1:-1]) / (2 * dy)\n\n    # --- 2. Least-Squares Gradient ---\n    grad_u_ls = np.zeros((Ny, Nx, 2))\n    \n    # Pre-calculate components of the diagonal matrix A (constant for all cells)\n    w_diag = 1.0 / (dx**2 + dy**2)\n    A11 = 2.0 + 4.0 * dx**2 * w_diag\n    A22 = 2.0 + 4.0 * dy**2 * w_diag\n\n    # Stencil values from padded array for vectorizing b vector calculation\n    u_w = u_padded[1:-1, :-2]; u_e = u_padded[1:-1, 2:]\n    u_s = u_padded[:-2, 1:-1]; u_n = u_padded[2:, 1:-1]\n    u_sw = u_padded[:-2, :-2]; u_se = u_padded[:-2, 2:]\n    u_nw = u_padded[2:, :-2];  u_ne = u_padded[2:, 2:]\n    \n    # RHS vector b components\n    b1 = (u_e - u_w) / dx + w_diag * dx * (u_ne + u_se - u_nw - u_sw)\n    b2 = (u_n - u_s) / dy + w_diag * dy * (u_ne + u_nw - u_se - u_sw)\n    \n    grad_u_ls[:, :, 0] = b1 / A11\n    grad_u_ls[:, :, 1] = b2 / A22\n\n    # --- Flux Imbalance Calculation Helper Function ---\n    def calculate_max_imbalance(grad_u):\n        # -- Vertical faces (x-faces, normal [1,0]) --\n        # K tensor is evaluated at face centers. y_f_x is same as y_cc.\n        layer_index_x = np.floor((y_cc % 1.0) / t).astype(int)\n        theta_fx = np.where(layer_index_x % 2 == 0, theta_0, theta_0 + PI / 2)\n        \n        c_x, s_x = np.cos(theta_fx), np.sin(theta_fx)\n        K11_x = k1 * c_x**2 + k2 * s_x**2\n        K12_x = (k1 - k2) * c_x * s_x\n        \n        grad_L = grad_u\n        grad_R = np.roll(grad_u, shift=-1, axis=1)\n        \n        # phi_L = -n.T K grad_L, phi_R = +n.T K grad_R\n        phi_L_x = -(K11_x * grad_L[:, :, 0] + K12_x * grad_L[:, :, 1])\n        phi_R_x =  (K11_x * grad_R[:, :, 0] + K12_x * grad_R[:, :, 1])\n\n        imbalance_x = np.abs(phi_L_x + phi_R_x) * dy # Area is dy\n\n        # -- Horizontal faces (y-faces, normal [0,1]) --\n        # Face y-coords are at (j+1)*dy\n        y_f_coords_1d = (np.arange(Ny) + 1.0) * dy\n        y_fy = y_f_coords_1d.reshape(-1, 1) # Shape (Ny, 1) for broadcasting\n\n        layer_index_y = np.floor((y_fy % 1.0) / t).astype(int)\n        theta_fy = np.where(layer_index_y % 2 == 0, theta_0, theta_0 + PI/2)\n\n        c_y, s_y = np.cos(theta_fy), np.sin(theta_fy)\n        K12_y = (k1 - k2) * c_y * s_y\n        K22_y = k1 * s_y**2 + k2 * c_y**2\n        \n        grad_L = grad_u\n        grad_R = np.roll(grad_u, shift=-1, axis=0) # R is cell (j+1)\n        \n        phi_L_y = -(K12_y * grad_L[:, :, 0] + K22_y * grad_L[:, :, 1])\n        phi_R_y =  (K12_y * grad_R[:, :, 0] + K22_y * grad_R[:, :, 1])\n        \n        imbalance_y = np.abs(phi_L_y + phi_R_y) * dx # Area is dx\n\n        return max(np.max(imbalance_x), np.max(imbalance_y))\n\n    E_gg = calculate_max_imbalance(grad_u_gg)\n    E_ls = calculate_max_imbalance(grad_u_ls)\n    \n    rho = E_ls / (E_gg + epsilon)\n    return rho\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'Nx': 32, 'Ny': 32, 'r': 100, 'theta_0': np.pi / 4, 't': 0.5},\n        {'Nx': 31, 'Ny': 30, 'r': 1000, 'theta_0': np.pi / 4, 't': 0.1},\n        {'Nx': 32, 'Ny': 32, 'r': 100, 'theta_0': 0.0, 't': 0.25},\n        {'Nx': 20, 'Ny': 24, 'r': 50, 'theta_0': np.pi / 6, 't': 1.0/6.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        rho = solve_case(case['Nx'], case['Ny'], case['r'], case['theta_0'], case['t'])\n        results.append(f\"{rho:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}