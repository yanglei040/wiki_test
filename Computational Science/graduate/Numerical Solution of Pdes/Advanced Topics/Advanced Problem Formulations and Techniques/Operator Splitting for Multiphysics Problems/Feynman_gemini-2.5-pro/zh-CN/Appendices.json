{
    "hands_on_practices": [
        {
            "introduction": "要精通算子分裂法，第一步是理解其误差的来源。本练习超越了简单地应用分裂格式，它要求直接计算由Baker-Campbell-Hausdorff (BCH) 公式预测的主阶误差项。通过这个实践，你将具体地理解算子的非对易性（即 $[A,B] \\neq 0$）是如何导致分裂误差的 。",
            "id": "3427806",
            "problem": "考虑一个边长为 $2\\pi$ 的周期性方形区域上的二维无源标量对流-扩散方程：\n$$\n\\frac{\\partial s}{\\partial t} = A(s) + B(s),\n$$\n其中对流算子 $A$ 和扩散算子 $B$ 定义为\n$$\nA(s) = -\\boldsymbol{v}\\cdot\\nabla s,\\qquad B(s) = \\nu \\Delta s.\n$$\n速度场 $\\boldsymbol{v}(x,y)$ 是时间无关的，并由泰勒-格林涡（Taylor–Green vortex）给出：\n$$\n\\boldsymbol{v}(x,y) = \\left(U\\sin(k_v x)\\cos(k_v y),\\,-U\\cos(k_v x)\\sin(k_v y)\\right),\n$$\n初始标量场为\n$$\ns_0(x,y) = \\cos(k_s x)\\cos(k_s y).\n$$\n假设所有量均为无量纲，区域为 $[0,2\\pi]\\times[0,2\\pi]$，并采用周期性边界条件。\n\n你需要：\n- 对上述系统实现一个持续时间为 $\\Delta t$ 的 Strang 分裂步，即计算\n$$\ns^{\\text{Strang}}(\\Delta t) = e^{A \\Delta t/2}\\, e^{B \\Delta t}\\, e^{A \\Delta t/2}\\, s_0,\n$$\n其中，$e^{A \\tau}$ 表示在冻结时间的速度场 $\\boldsymbol{v}$ 下，时间 $\\tau$ 内的精确对流算子；$e^{B \\tau}$ 是时间 $\\tau$ 内的精确扩散算子。\n- 使用 Baker–Campbell–Hausdorff 展开，推导并计算一个时间步后仅由算子分裂（即，不包括空间和时间离散化误差）引起的 $L^2$ 范数下的主阶期望误差。对于时间不变算子 $A$ 和 $B$，Strang 分裂的局部误差阶数为 $\\mathcal{O}(\\Delta t^3)$，其主项由下式给出\n$$\n\\frac{\\Delta t^3}{12}\\left([A,[A,B]] + [B,[B,A]]\\right) s_0,\n$$\n其中作用于函数 $f$ 的对易子 $[X,Y]$ 定义为 $[X,Y]f = X(Yf) - Y(Xf)$。因此，期望的 $L^2$ 误差应计算为\n$$\n\\left\\|\\frac{\\Delta t^3}{12}\\left([A,[A,B]] + [B,[B,A]]\\right) s_0\\right\\|_{L^2},\n$$\n其中 $L^2$ 范数定义为\n$$\n\\|f\\|_{L^2} = \\left(\\int_{0}^{2\\pi}\\int_{0}^{2\\pi} |f(x,y)|^2 \\, dx\\,dy\\right)^{1/2}.\n$$\n\n你的实现必须：\n- 在 $[0,2\\pi]\\times[0,2\\pi]$ 上使用大小为 $N\\times N$ 的均匀网格。\n- 通过快速傅里叶变换（FFT）计算空间导数，以对周期函数一致地计算 $\\nabla s$ 和 $\\Delta s$。\n- 通过半拉格朗日对流法执行 $e^{A \\tau}$，其中对冻结速度场使用四阶龙格-库塔（Runge–Kutta）特征线积分，并对标量场进行周期性双线性插值；在傅里叶空间中，通过乘以 $e^{-\\nu |{\\boldsymbol{k}}|^2 \\tau}$ 来精确执行 $e^{B \\tau}$，其中 ${\\boldsymbol{k}}$ 为傅里叶模式。\n- 使用上述对易子表达式计算期望的 $L^2$ 误差，该计算通过基于 FFT 的导数来数值地组合算子 $A$ 和 $B$ 实现。\n\n设计一个覆盖不同方面的测试套件：\n- 具有非零对流和扩散的一般情况。\n- 对流或扩散其中之一消失的边界情况，此时根据定义，分裂误差应为零。\n- 具有更高波数以强调非对易性的情况。\n- 对流更强的情况。\n\n使用以下测试用例 $(U,k_v,k_s,\\nu,\\Delta t,N)$:\n1. $(1.0,\\,1,\\,1,\\,0.01,\\,0.05,\\,64)$\n2. $(1.0,\\,1,\\,1,\\,0.00,\\,0.05,\\,64)$\n3. $(0.0,\\,1,\\,1,\\,0.01,\\,0.05,\\,64)$\n4. $(2.0,\\,2,\\,3,\\,0.02,\\,0.05,\\,64)$\n5. $(1.0,\\,4,\\,4,\\,0.01,\\,0.10,\\,64)$\n\n你的程序应产生单行输出，其中包含五个用例的期望 $L^2$ 误差值，格式为方括号括起来的逗号分隔列表（例如 $[e_1,e_2,e_3,e_4,e_5]$）。不应打印任何其他文本。所有值必须是无量纲实数。三角函数中的角度以弧度为单位。",
            "solution": "该问题要求计算二维对流-扩散方程的 Strang 分裂格式的主阶误差。解决方案涉及将区域和算子离散化，然后数值计算一个包含这些算子嵌套对易子的复杂表达式。\n\n控制方程为\n$$\n\\frac{\\partial s}{\\partial t} = A(s) + B(s)\n$$\n位于周期性区域 $[0,2\\pi]\\times[0,2\\pi]$ 上，其中 $A(s) = -\\boldsymbol{v}\\cdot\\nabla s$ 是对流算子，$B(s) = \\nu \\Delta s$ 是扩散算子。速度场是一个时间无关的泰勒-格林涡（Taylor-Green vortex），初始标量场为 $s_0(x,y) = \\cos(k_s x)\\cos(k_s y)$。\n\n主要目标是计算持续时间为 $\\Delta t$ 的单个 Strang 分裂步的主阶局部误差项的 $L^2$ 范数。对于时间不变算子，该误差项由 Baker-Campbell-Hausdorff (BCH) 展开给出为：\n$$\nE = \\frac{\\Delta t^3}{12}\\left([A,[A,B]] + [B,[B,A]]\\right) s_0\n$$\n其中 $[X,Y]f = X(Yf) - Y(Xf)$ 是算子 $X$ 和 $Y$ 的对易子。我们的任务是计算 $\\|E\\|_{L^2}$。\n\n计算策略如下：\n1.  将连续区域 $[0,2\\pi]\\times[0,2\\pi]$ 离散化为一个均匀的 $N\\times N$ 网格。\n2.  使用伪谱法（即，通过快速傅里叶变换，FFT）实现微分算子 $A$ 和 $B$ 的数值表示。\n3.  通过将数值算子顺序地应用于初始场 $s_0$ 来计算嵌套的对易子表达式。\n4.  使用数值积分计算所得误差场的 $L^2$ 范数。\n\n**步骤 1：离散化与傅里叶表示**\n该区域被离散化为一个 $N \\times N$ 网格，坐标为 $(x_i, y_j)$，其中 $x_i = i \\frac{2\\pi}{N}$ 且 $y_j = j \\frac{2\\pi}{N}$，对于 $i,j \\in \\{0, 1, \\dots, N-1\\}$。标量场 $s(x,y)$ 表示为一个矩阵 $s_{ij} = s(x_i, y_j)$。\n\n对于此网格上的周期函数，在傅里叶空间中计算空间导数最为精确。$s$ 的二维离散傅里叶变换为 $\\hat{s}(\\boldsymbol{k}) = \\mathcal{F}(s)$，其中 $\\boldsymbol{k}=(k_x, k_y)$ 是波矢。对应于网格的整数波数值为 $k_x, k_y \\in \\{-\\frac{N}{2}, \\dots, \\frac{N}{2}-1\\}$。导数变换如下：\n$$\n\\mathcal{F}\\left(\\frac{\\partial s}{\\partial x}\\right) = i k_x \\hat{s}(\\boldsymbol{k})\n$$\n$$\n\\mathcal{F}\\left(\\frac{\\partial s}{\\partial y}\\right) = i k_y \\hat{s}(\\boldsymbol{k})\n$$\n$$\n\\mathcal{F}(\\Delta s) = \\mathcal{F}\\left(\\frac{\\partial^2 s}{\\partial x^2} + \\frac{\\partial^2 s}{\\partial y^2}\\right) = -(k_x^2 + k_y^2) \\hat{s}(\\boldsymbol{k}) = -|\\boldsymbol{k}|^2 \\hat{s}(\\boldsymbol{k})\n$$\n然后通过应用逆傅里叶变换 $\\mathcal{F}^{-1}$ 来恢复实空间导数。\n\n**步骤 2：算子 $A$ 和 $B$ 的数值实现**\n这些算子被实现为作用于代表标量场的二维数组的函数。\n\n扩散算子 $B(s) = \\nu \\Delta s$ 完全在傅里叶空间中计算。数值步骤如下：\n1.  计算场 $s$ 的二维 FFT：$\\hat{s} = \\text{fft2}(s)$。\n2.  乘以算子的傅里叶符号：$\\widehat{B(s)} = \\nu (-|\\boldsymbol{k}|^2) \\hat{s}$。\n3.  计算结果的二维逆 FFT 并取实部：$B(s) = \\text{real}(\\text{ifft2}(\\widehat{B(s)}))$。\n\n对流算子 $A(s) = -(v_x \\frac{\\partial s}{\\partial x} + v_y \\frac{\\partial s}{\\partial y})$ 使用伪谱法实现：\n1.  如上所述，在傅里叶空间中计算梯度 $\\frac{\\partial s}{\\partial x}$ 和 $\\frac{\\partial s}{\\partial y}$。\n2.  将梯度变换回实空间。\n3.  在网格上计算速度场分量 $v_x$ 和 $v_y$。\n4.  在实空间中执行点积并乘以 $-1$：$A(s) = -(v_x \\frac{\\partial s}{\\partial x} + v_y \\frac{\\partial s}{\\partial y})$。\n\n**步骤 3：对易子表达式的计算**\n表达式 $E = \\frac{\\Delta t^3}{12} \\left( [A,[A,B]]s_0 + [B,[B,A]]s_0 \\right)$ 涉及嵌套对易子。为了进行数值计算，我们展开对易子：\n$$\n[A,[A,B]]s_0 = A(A(B(s_0))) - 2A(B(A(s_0))) + B(A(A(s_0)))\n$$\n$$\n[B,[B,A]]s_0 = B(B(A(s_0))) - 2B(A(B(s_0))) + A(B(B(s_0)))\n$$\n我们将算子 $X$ 应用于场 $f$ 的结果记为 $Xf$。数值计算需要计算初始场 $s_0$ 上的所有六个唯一的三阶算子序列：$AABs_0$、$ABAs_0$、$BAAs_0$、$ABBs_0$、$BABs_0$、$BBAs_0$。\n然后，总的未缩放误差场组合为：\n$$\n_E = (AABs_0 - 2 ABAs_0 + BAAs_0) + (ABBs_0 - 2 BABs_0 + BBAs_0)\n$$\n最后，完整的误差场是 $E = \\frac{\\Delta t^3}{12} {}_E$。注意，如果 $U=0$（因此 $A=0$）或 $\\nu=0$（因此 $B=0$），则对易子为零，如预期般产生零误差。\n\n**步骤 4：$L^2$ 范数的计算**\n域上函数 $f$ 的 $L^2$ 范数为 $\\|f\\|_{L^2} = \\left(\\int_0^{2\\pi}\\int_0^{2\\pi} |f(x,y)|^2 \\, dx\\,dy\\right)^{1/2}$。该积分通过对离散网格点的求和来近似：\n$$\n\\|E\\|_{L^2} \\approx \\left( \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} |E(x_i, y_j)|^2 \\Delta x \\Delta y \\right)^{1/2}\n$$\n其中 $E(x_i, y_j)$ 是在网格上计算出的误差场的值，网格间距为 $\\Delta x = \\Delta y = \\frac{2\\pi}{N}$。\n\n总体算法遍历每个测试用例，设置参数和初始场，然后执行步骤 2 到 4 来计算最终的标量误差值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the leading-order Strang splitting error for the 2D\n    advection-diffusion equation on a periodic domain.\n    \"\"\"\n    test_cases = [\n        (1.0, 1, 1, 0.01, 0.05, 64),\n        (1.0, 1, 1, 0.00, 0.05, 64),\n        (0.0, 1, 1, 0.01, 0.05, 64),\n        (2.0, 2, 3, 0.02, 0.05, 64),\n        (1.0, 4, 4, 0.01, 0.10, 64)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        U, k_v, k_s, nu, dt, N = case\n\n        # If U or nu is zero, one operator is zero, so the commutator is zero,\n        # and the splitting error is zero.\n        if U == 0.0 or nu == 0.0:\n            results.append(0.0)\n            continue\n\n        # 1. Setup Grid, Wavenumbers, and Fields\n        L = 2.0 * np.pi\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        X, Y = np.meshgrid(x, x, indexing='ij')\n\n        # Wavenumbers for FFT on a domain of size L=2*pi\n        k_vec = np.fft.fftfreq(N) * N \n        Kx, Ky = np.meshgrid(k_vec, k_vec, indexing='ij')\n        K2 = Kx**2 + Ky**2\n\n        # Initial scalar field\n        s0 = np.cos(k_s * X) * np.cos(k_s * Y)\n        # Velocity field\n        vx = U * np.sin(k_v * X) * np.cos(k_v * Y)\n        vy = -U * np.cos(k_v * X) * np.sin(k_v * Y)\n\n        # 2. Define numerical operators A and B\n        def apply_A(s_field):\n            \"\"\"Applies advection operator A(s) = -v . grad(s)\"\"\"\n            s_hat = np.fft.fft2(s_field)\n            ds_dx_hat = 1j * Kx * s_hat\n            ds_dy_hat = 1j * Ky * s_hat\n            ds_dx = np.fft.ifft2(ds_dx_hat).real\n            ds_dy = np.fft.ifft2(ds_dy_hat).real\n            return -(vx * ds_dx + vy * ds_dy)\n\n        def apply_B(s_field):\n            \"\"\"Applies diffusion operator B(s) = nu * laplacian(s)\"\"\"\n            s_hat = np.fft.fft2(s_field)\n            lap_s_hat = -K2 * s_hat\n            lap_s = np.fft.ifft2(lap_s_hat).real\n            return nu * lap_s\n\n        # 3. Compute all third-order operator applications\n        \n        # 1st order applications\n        As0 = apply_A(s0)\n        Bs0 = apply_B(s0)\n        \n        # 2nd order applications\n        AAs0 = apply_A(As0)\n        ABs0 = apply_A(Bs0)\n        BAs0 = apply_B(As0)\n        BBs0 = apply_B(Bs0)\n\n        # 3rd order applications\n        # For term [A, [A, B]]s0 = AABs0 - 2*ABAs0 + BAAs0\n        AABs0 = apply_A(ABs0)\n        ABAs0 = apply_A(BAs0)\n        BAAs0 = apply_B(AAs0)\n        \n        # For term [B, [B, A]]s0 = ABBs0 - 2*BABs0 + BBAs0\n        ABBs0 = apply_A(BBs0)\n        BABs0 = apply_B(ABs0)\n        BBAs0 = apply_B(BAs0)\n\n        # 4. Assemble the full error field\n        # term1 = A(A(B(s0))) - 2A(B(A(s0))) + B(A(A(s0)))\n        term1_field = AABs0 - 2.0 * ABAs0 + BAAs0\n        # term2 = B(B(A(s0))) - 2B(A(B(s0))) + A(B(B(s0)))\n        term2_field = BBAs0 - 2.0 * BABs0 + ABBs0\n        \n        unscaled_error_field = term1_field + term2_field\n        error_field = (dt**3 / 12.0) * unscaled_error_field\n\n        # 5. Compute the L2 norm of the error field\n        l2_norm_sq = np.sum(np.abs(error_field)**2) * (dx**2)\n        l2_norm = np.sqrt(l2_norm_sq)\n        \n        results.append(l2_norm)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{val:.15e}' for val in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理解了误差的来源之后，下一步是探索选择分裂方法的“艺术”。对于一个给定的偏微分方程，有多种分裂方式。本练习将针对一个反应扩散问题，比较两种流行的方法：对称的Strang分裂和指数时间差分（ETD）方法 。这将突显出设计数值格式时所涉及的不同理念和权衡。",
            "id": "3427836",
            "problem": "考虑建立在周期性空间域 $x \\in [0,L]$ 上的半线性偏微分方程 (PDE) $u_t = D u_{xx} + \\lambda u^3$，该方程具有周期性边界条件和均匀网格。目标是使用两种基于算子分裂的积分器计算从 $t=0$ 到 $t=\\Delta t$ 的单个时间步，并量化它们在 $t=\\Delta t$ 时的数值解之间的差异。\n\n您必须在一个包含 $N$ 个点的均匀网格上实现以下两种时间积分策略：\n- 一阶指数时间差分 (ETD1)，其中线性扩散算子通过其精确半群处理，非线性项在时间上作一阶处理。\n- 在扩散和三次反应之间进行 Strang 分裂（对称二阶分裂），并对每个算子使用精确子步。\n\n您的程序必须使用傅里叶谱方法（借助快速傅里叶变换）来表示周期性空间离散化。通过与拉普拉斯算子半群相对应的傅里叶乘子来计算精确的线性扩散子步，并使用逐点常微分方程 (ODE) $u_t=\\lambda u^3$ 的精确解来进行反应子步。使用常数变易法原理来构建 ETD1，并且不要引入任何人工稳定化。\n\n初始数据必须在网格上指定为三角函数。对于间距为 $h=L/N$，网格点为 $x_j = j h$（$j=0,1,\\dots,N-1$），以及参数 $(L,N,D,\\lambda,\\Delta t,A_1,A_2)$ 的均匀网格，设置\n$$\nu_0(x) = A_1 \\sin\\left(\\frac{2\\pi x}{L}\\right) + A_2 \\cos\\left(\\frac{4\\pi x}{L}\\right).\n$$\n\n对每个测试用例，计算 ETD1 解 $u^{\\text{ETD1}}(\\Delta t)$ 和 Strang 分裂解 $u^{\\text{Strang}}(\\Delta t)$ 之间的离散 $L^2$ 差异，定义为\n$$\n\\| u^{\\text{ETD1}}(\\Delta t) - u^{\\text{Strang}}(\\Delta t) \\|_{L^2_h}\n\\;=\\;\n\\left( h \\sum_{j=0}^{N-1} \\left( u^{\\text{ETD1}}_j - u^{\\text{Strang}}_j \\right)^2 \\right)^{1/2}.\n$$\n\n所有量均为无量纲；不包含任何物理单位。角度必须以弧度为单位解释。以十进制浮点数形式生成结果。\n\n实现以下参数集测试套件，以测试不同的机制：\n- 测试 $1$（一般情况）：$(L,N,D,\\lambda,\\Delta t,A_1,A_2) = (1,128,0.05,1.0,0.001,0.2,0.05)$。\n- 测试 $2$（无扩散边界情况）：$(L,N,D,\\lambda,\\Delta t,A_1,A_2) = (1,128,0.0,1.0,0.001,0.2,0.05)$。\n- 测试 $3$（无反应边缘情况）：$(L,N,D,\\lambda,\\Delta t,A_1,A_2) = (1,128,0.2,0.0,0.005,0.2,0.05)$。\n- 测试 $4$（强扩散，负反应系数）：$(L,N,D,\\lambda,\\Delta t,A_1,A_2) = (1,64,1.0,-1.0,0.005,0.1,0.05)$。\n\n您的程序应生成单行输出，其中包含所有测试的离散 $L^2$ 差异，以逗号分隔的列表形式并用方括号括起来，顺序与上述测试相同；例如，输出格式必须为\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4].\n$$\n每个 $\\text{result}_i$ 都必须是一个十进制浮点数。",
            "solution": "本问题要求使用两种不同的算子分裂方法，在一个时间步长内对一个半线性反应扩散方程进行数值求解。结果将通过计算其差值的离散 $L^2$ 范数进行比较。\n\n控制偏微分方程 (PDE) 为：\n$$\nu_t = D u_{xx} + \\lambda u^3\n$$\n该方程建立在一维空间域 $x \\in [0, L]$ 上，并具有周期性边界条件。它可以形式上写成一个函数空间中的抽象常微分方程 (ODE)：$u_t = (\\mathcal{L} + \\mathcal{N})u$，其中 $\\mathcal{L}u = D u_{xx}$ 是线性扩散算子，$\\mathcal{N}(u) = \\lambda u^3$ 是非线性反应算子。\n\n首先，我们定义空间离散化。使用一个包含 $N$ 个点的均匀网格，网格间距为 $h = L/N$。网格点为 $x_j = j h$，$j = 0, 1, \\dots, N-1$。在此网格上的解是一个向量 $u_j(t) \\approx u(x_j, t)$。\n\n对于周期性问题，傅里叶谱方法非常有效。一个函数 $u(x)$ 由其离散傅里叶系数 $\\hat{u}_k$ 表示，这些系数通过快速傅里叶变换 (FFT) 计算。该方法的关键特性是，实空间中的空间微分在傅里叶空间中变成了乘法。二阶导数算子 $\\partial_{xx}$ 对应于乘以 $(i k_p)^2 = -k_p^2$，其中 $k_p$ 是物理波数。对应于离散网格的波数由 $k_p = 2\\pi k_s$ 给出，其中空间频率 $k_s$ 由 FFT 算法排列。对于一个有 $N$ 个点且间距为 $h$ 的网格，这些频率由 $k_s = [0, 1/L, 2/L, \\dots, F_{max}, \\dots, -2/L, -1/L]$ 给出，其中 $F_{max}$ 是奈奎斯特频率。因此，傅里叶空间中的线性算子 $\\mathcal{L}$ 表示为与一个对角矩阵相乘，该矩阵的元素为 $\\hat{L}_k = -D k_p^2 = -D (2\\pi k_s)^2$。\n\n初始条件由以下公式给出：\n$$\nu_0(x_j) = A_1 \\sin\\left(\\frac{2\\pi x_j}{L}\\right) + A_2 \\cos\\left(\\frac{4\\pi x_j}{L}\\right)\n$$\n\n现在我们将详细介绍两种用于将解从时间 $t=0$ 推进到 $t=\\Delta t$ 的数值积分方案。\n\n**方法 1：Strang 分裂**\n\nStrang 分裂是一种二阶精确方法，它通过其各自指数的对称组合来近似两个算子之和的指数。对于一个时间步长 $\\Delta t$，从时间 $t_n$ 的解 $u_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的解 $u_{n+1}$ 的更新如下：\n$$\nu_{n+1} \\approx e^{\\frac{\\Delta t}{2}\\mathcal{N}} e^{\\Delta t \\mathcal{L}} e^{\\frac{\\Delta t}{2}\\mathcal{N}} u_n\n$$\n这通过以下三个子步的序列来实现：\n1.  **反应的半步**：在非线性算子 $\\mathcal{N}$ 下演化解，时间为 $\\Delta t/2$。这涉及到对每个网格点独立求解常微分方程 $v_t = \\lambda v^3$。该常微分方程在初始条件 $v(0) = v_0$ 下的精确解可通过分离变量法找到：\n    $$\n    \\int_{v_0}^{v(t)} \\frac{dv}{v^3} = \\int_0^t \\lambda ds \\implies -\\frac{1}{2v(t)^2} + \\frac{1}{2v_0^2} = \\lambda t \\implies v(t) = \\frac{v_0}{\\sqrt{1 - 2\\lambda v_0^2 t}}\n    $$\n    对于持续时间为 $\\tau = \\Delta t/2$ 的时间步，更新为 $v_j \\to v_j / \\sqrt{1 - 2\\lambda v_j^2 (\\Delta t/2)} = v_j / \\sqrt{1 - \\lambda v_j^2 \\Delta t}$。此更新应用于初始数据 $u_0$。\n\n2.  **扩散的全步**：在第一个子步得到的结果上，于线性算子 $\\mathcal{L}$ 下演化一个完整的时间步 $\\Delta t$。$u_t = \\mathcal{L}u = D u_{xx}$ 的解形式上为 $u(t) = e^{t\\mathcal{L}} u(0)$。在傅里叶空间中，这变成一个简单的乘法：$\\hat{u}_k(t) = e^{t\\hat{L}_k} \\hat{u}_k(0)$。具体过程是：对当前状态进行快速傅里叶变换 (FFT)，将每个傅里叶系数 $\\hat{u}_k$ 乘以传播子 $e^{\\hat{L}_k \\Delta t} = e^{-D k_p^2 \\Delta t}$，然后进行逆快速傅里叶变换 (inverse FFT) 以返回到实空间。\n\n3.  **反应的半步**：将扩散步得到的结果在非线性算子 $\\mathcal{N}$ 下再演化 $\\Delta t/2$ 的时间，使用与第一步中相同的精确逐点更新规则。\n\n**方法 2：一阶指数时间差分 (ETD1)**\n\n指数积分器使用 PDE 的常数变易公式：\n$$\nu(t_{n+1}) = e^{\\Delta t \\mathcal{L}} u(t_n) + \\int_0^{\\Delta t} e^{(\\Delta t - s)\\mathcal{L}} \\mathcal{N}(u(t_n+s)) ds\n$$\nETD1 方法通过假设非线性项在时间步内是常数来近似该积分，即 $\\mathcal{N}(u(t_n+s)) \\approx \\mathcal{N}(u(t_n))$。这得到：\n$$\nu_{n+1} \\approx e^{\\Delta t \\mathcal{L}} u_n + \\mathcal{N}(u_n) \\int_0^{\\Delta t} e^{(\\Delta t-s)\\mathcal{L}} ds = e^{\\Delta t \\mathcal{L}} u_n + \\left( e^{\\Delta t \\mathcal{L}} - I \\right) \\mathcal{L}^{-1} \\mathcal{N}(u_n)\n$$\n这通常使用 $\\phi_1$ 函数来表示，其中 $\\phi_1(z) = (e^z-1)/z$：\n$$\nu_{n+1} \\approx e^{\\Delta t \\mathcal{L}} u_n + \\Delta t \\phi_1(\\Delta t \\mathcal{L}) \\mathcal{N}(u_n)\n$$\n实现是在傅里叶空间中进行的：\n1.  在实空间中计算非线性项：$N_0 = \\lambda u_0^3$。\n2.  将初始状态 $u_0$ 和非线性项 $N_0$ 都变换到傅里叶空间，以获得 $\\hat{u}_0$ 和 $\\hat{N}_0$。\n3.  定义傅里叶乘子。令 $z_k = \\hat{L}_k \\Delta t = -D k_p^2 \\Delta t$。第一个乘子是 $E_k = e^{z_k}$。第二个是 $\\phi_1$ 乘子，$\\phi_{1,k} = (e^{z_k}-1)/z_k$。对于 $z_k=0$ 的情况（这发生在 $k=0$ 模式或 $D=0$ 时），使用极限 $\\lim_{z \\to 0} \\phi_1(z) = 1$ 以避免除以零。\n4.  在傅里叶空间中应用更新：$\\hat{u}_{1,k} = E_k \\hat{u}_{0,k} + \\Delta t \\phi_{1,k} \\hat{N}_{0,k}$。\n5.  使用逆 FFT 将 $\\hat{u}_1$ 变换回实空间，以得到解 $u^{\\text{ETD1}}(\\Delta t)$。\n\n**最终比较**\n\n在用两种方法计算出 $t=\\Delta t$ 时的解 $u^{\\text{Strang}}(\\Delta t)$ 和 $u^{\\text{ETD1}}(\\Delta t)$ 之后，我们使用离散 $L^2$ 范数量化它们的差异，定义如下：\n$$\n\\| u^{\\text{ETD1}}(\\Delta t) - u^{\\text{Strang}}(\\Delta t) \\|_{L^2_h} = \\left( h \\sum_{j=0}^{N-1} \\left( u^{\\text{ETD1}}_j - u^{\\text{Strang}}_j \\right)^2 \\right)^{1/2}\n$$\n对所提供的四个测试用例中的每一个都进行此计算。对于反应不存在 ($\\lambda=0$) 的特殊情况，两种方法都简化为线性扩散方程的精确求解，它们的差值在机器精度范围内应为零。对于扩散不存在 ($D=0$) 的情况，Strang 分裂能精确求解剩余的 ODE，而 ETD1 则简化为一阶前向欧拉法，从而导致非零差异。",
            "answer": "```python\nimport numpy as np\nfrom numpy.fft import fft, ifft, fftfreq\n\ndef strang_step(u_n, linear_op_fourier, lam, dt):\n    \"\"\"\n    Performs one Strang splitting step.\n    u_np1 = exp(dt/2 N) exp(dt L) exp(dt/2 N) u_n\n    \"\"\"\n    # First nonlinear substep for dt/2\n    if lam == 0.0:\n        u_star = u_n\n    else:\n        # Exact solution for u_t = lam * u^3 for time dt/2\n        # u(t) = u0 / sqrt(1 - 2*lam*u0^2*t)\n        # Here t = dt/2, so the denominator term is (1 - lam * u_n^2 * dt)\n        denom_sq_term = 1.0 - lam * (u_n**2) * dt\n        if np.any(denom_sq_term = 0):\n            raise ValueError(\"Blow-up detected in Strang splitting nonlinear step.\")\n        u_star = u_n / np.sqrt(denom_sq_term)\n\n    # Linear substep for dt\n    u_star_hat = fft(u_star)\n    propagator = np.exp(linear_op_fourier * dt)\n    u_star_star_hat = propagator * u_star_hat\n    u_star_star = ifft(u_star_star_hat).real\n\n    # Second nonlinear substep for dt/2\n    if lam == 0.0:\n        u_np1 = u_star_star\n    else:\n        denom_sq_term = 1.0 - lam * (u_star_star**2) * dt\n        if np.any(denom_sq_term = 0):\n            raise ValueError(\"Blow-up detected in Strang splitting nonlinear step.\")\n        u_np1 = u_star_star / np.sqrt(denom_sq_term)\n    \n    return u_np1\n\ndef etd1_step(u_n, linear_op_fourier, lam, dt):\n    \"\"\"\n    Performs one first-order Exponential Time Differencing (ETD1) step.\n    u_np1 = exp(dt*L)u_n + dt*phi1(dt*L)N(u_n)\n    \"\"\"\n    # Calculate nonlinear term N(u_n)\n    N_u = lam * u_n**3\n    \n    # FFT of state vector and nonlinear term\n    u_n_hat = fft(u_n)\n    N_u_hat = fft(N_u)\n    \n    # Define z = dt * L_op\n    z = linear_op_fourier * dt\n    \n    # Calculate propagators E = exp(z) and phi1 = (exp(z)-1)/z\n    E = np.exp(z)\n    \n    # Use np.where to handle the z=0 case to avoid division by zero\n    phi1 = np.where(z == 0, 1.0, (E - 1.0) / z)\n    \n    # Update in Fourier space\n    u_np1_hat = E * u_n_hat + dt * phi1 * N_u_hat\n    \n    # Inverse FFT to get the solution in real space\n    u_np1 = ifft(u_np1_hat).real\n    \n    return u_np1\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and compute differences.\n    \"\"\"\n    test_cases = [\n        # (L, N, D, lambda, dt, A1, A2)\n        (1.0, 128, 0.05, 1.0, 0.001, 0.2, 0.05),\n        (1.0, 128, 0.0, 1.0, 0.001, 0.2, 0.05),\n        (1.0, 128, 0.2, 0.0, 0.005, 0.2, 0.05),\n        (1.0, 64, 1.0, -1.0, 0.005, 0.1, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, D, lam, dt, A1, A2 = case\n\n        # 1. Set up grid, initial condition, and Fourier space operator\n        h = L / N\n        x = np.arange(N) * h\n        \n        u0 = A1 * np.sin(2 * np.pi * x / L) + A2 * np.cos(4 * np.pi * x / L)\n\n        # Spatial frequencies (cycles per unit length)\n        k_freq = fftfreq(N, d=h)\n        # Physical wavenumbers\n        k_physical = 2 * np.pi * k_freq\n        \n        # Linear operator in Fourier space (for D*u_xx)\n        linear_op_fourier = -D * (k_physical**2)\n\n        # 2. Compute one step with Strang splitting\n        u_strang = strang_step(u0, linear_op_fourier, lam, dt)\n\n        # 3. Compute one step with ETD1\n        u_etd1 = etd1_step(u0, linear_op_fourier, lam, dt)\n\n        # 4. Compute the discrete L2 difference\n        diff = u_etd1 - u_strang\n        l2_diff = np.sqrt(h * np.sum(diff**2))\n        \n        results.append(l2_diff)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们以一个真实世界的多物理场应用来结束本章。在复杂的耦合系统中，算子顺序这样一个看似简单的选择（例如，先扩散后力学 vs. 先力学后扩散）可能会产生显著且非直观的后果。本练习将研究在电池电极锂化模型中，分裂顺序如何影响关键物理量（如荷电状态和应力）的物理真实性，特别是它们的单调性 。",
            "id": "3427809",
            "problem": "考虑一个一维电极域 $x \\in [0,L]$，其中锂浓度 $c(x,t)$ 发生扩散，并通过与位移 $u(x,t)$ 的化学-力学耦合引致应力。该耦合多物理场模型由一个关于 $c$ 的扩散方程和一个关于 $u$ 的粘弹性力学平衡方程组成，并通过算子分裂在每个时间步内顺序演化这两个物理过程。所有变量均为无量纲；无需物理单位。\n\n基本原理：\n- 质量守恒与菲克扩散：锂浓度 $c$ 根据 $\\partial c/\\partial t = -\\partial J/\\partial x$ 演化，其中 $J$ 为通量。\n- 通量中的化学-力学耦合：采用 Larché–Cahn 精神的应力驱动修正，即 $J = -D\\left(\\partial c/\\partial x - \\chi \\,\\partial \\sigma/\\partial x\\right)$，其中 $D$ 是扩散系数，$\\chi$ 是耦合系数，$\\sigma$ 是应力。\n- 带有 Winkler 地基的线性粘弹性（Kelvin–Voigt 模型）：应力为 $\\sigma = E\\,\\varepsilon + \\eta\\,\\partial \\varepsilon/\\partial t - E\\,\\alpha\\,c$，应变为 $\\varepsilon = \\partial u/\\partial x$，弹性模量为 $E$，粘度为 $\\eta$，化学膨胀系数为 $\\alpha$。力学平衡方程为 $\\partial \\sigma/\\partial x - k_f\\,u = 0$，其中 $k_f$ 是地基刚度。\n\n根据这些原理，耦合的偏微分方程（PDE）为\n$$\n\\frac{\\partial c}{\\partial t} = \\frac{\\partial}{\\partial x}\\left[D\\,\\frac{\\partial c}{\\partial x} - D\\,\\chi\\,\\frac{\\partial \\sigma}{\\partial x}\\right], \\quad 0  x  L,\n$$\n$$\n\\frac{\\partial}{\\partial x}\\left(E\\,\\frac{\\partial u}{\\partial x} + \\eta\\,\\frac{\\partial}{\\partial t}\\left(\\frac{\\partial u}{\\partial x}\\right) - E\\,\\alpha\\,c\\right) - k_f\\,u = 0, \\quad 0  x  L.\n$$\n对完整的粘弹性应力 $\\sigma$ 使用力学平衡关系 $\\partial \\sigma/\\partial x = k_f\\,u$，扩散方程变为\n$$\n\\frac{\\partial c}{\\partial t} = D\\,\\frac{\\partial^2 c}{\\partial x^2} - D\\,\\chi\\,k_f\\,\\frac{\\partial u}{\\partial x}.\n$$\n\n边界和初始条件：\n- $x=0$ 处的浓度边界通量模拟充电过程：$J(0,t) = J_{\\text{in}}$，$J_{\\text{in}}  0$ 为常数；$x=L$ 处通量为零：$J(L,t) = 0$。使用 $J = -D(\\partial c/\\partial x - \\chi\\,\\partial \\sigma/\\partial x)$ 以及下述的力学边界条件，这可以简化为 Neumann 条件 $-D\\,\\partial c/\\partial x(0,t) = J_{\\text{in}}$ 和 $-D\\,\\partial c/\\partial x(L,t) = 0$。\n- 力学边界为夹持：$u(0,t) = 0$ 和 $u(L,t) = 0$。\n- 初始条件：$c(x,0) = 0$ 和 $u(x,0) = 0$。\n\n空间离散化：\n- 在 $[0,L]$ 上使用含 $N$ 个节点的均匀网格，间距为 $\\Delta x = L/(N-1)$。\n- 有限差分：二阶导数采用标准三点模板，一阶导数采用中心差分。对于扩散方程，通过与给定通量一致的虚拟点值来施加关于 $c$ 的 Neumann 边界条件。\n\n时间离散化与算子分裂：\n- 时间步长为 $\\Delta t$，总步数为 $N_t$。\n- 每个时间步 $t^n \\to t^{n+1}$ 有两种 Lie 分裂顺序：\n  1. 扩散-力学 (DM)：首先使用时间 $t^n$ 的 $u$ 显式推进 $c$，然后使用更新后的 $c$ 求解时间 $t^{n+1}$ 的 $u$。\n  2. 力学-扩散 (MD)：首先使用时间 $t^n$ 的 $c$ 求解力学问题，然后使用更新后的 $u$ 显式推进 $c$；步末的应力使用与力学子步浓度 $c^n$ 一致的值进行评估。\n- 扩散子步（显式欧拉法）：\n$$\nc^{n+1} = c^n + \\Delta t\\left( D\\,\\Delta_x c^n - D\\,\\chi\\,k_f\\,\\frac{\\partial u^n}{\\partial x}\\right),\n$$\n其中 $\\Delta_x$ 是带有 Neumann 边界条件的离散拉普拉斯算子，$\\partial u^n/\\partial x$ 是时间 $t^n$ 的离散位移梯度。\n- 力学子步（对粘弹性项采用时间上的后向欧拉法，对内部节点上的 $u$ 采用空间上的有限差分法，并施加齐次狄利克雷边界）：\n$$\n\\left(\\frac{\\eta}{\\Delta t}\\,\\Delta_x + E\\,\\Delta_x - k_f\\,I\\right)u^{n+1} = \\frac{\\eta}{\\Delta t}\\,\\Delta_x u^n + E\\,\\alpha\\,G_x\\,c^{*},\n$$\n其中 $I$ 是内部节点上的单位矩阵，$G_x$ 是离散一阶导数算子，$c^{*}$ 是力学子步使用的浓度：在 DM 顺序中 $c^{*} = c^{n+1}$，在 MD 顺序中 $c^{*} = c^n$。步末的应力计算如下\n$$\n\\sigma^{n+1} = E\\,\\varepsilon^{n+1} + \\eta\\,\\frac{\\varepsilon^{n+1} - \\varepsilon^n}{\\Delta t} - E\\,\\alpha\\,\\tilde{c},\n$$\n其中 $\\varepsilon^n$ 和 $\\varepsilon^{n+1}$ 是离散应变场，$\\tilde{c}$ 是与力学子步一致的浓度：对于 DM 是 $\\tilde{c} = c^{n+1}$，对于 MD 是 $\\tilde{c} = c^n$。\n\n关注量与单调性测试：\n- 荷电状态 (SOC) 是 $c$ 在 $[0,L]$ 上的空间积分，通过复合梯形法则计算。必须测试其离散时间序列是否具有单调非减行为。\n- 应力峰值是每个时间步结束时空间网格上的最大绝对应力。必须测试其离散时间序列是否具有单调非减行为。\n\n你的任务：\n1. 在每个测试案例中，使用所提供的参数实现所述的 DM 和 MD 两种顺序的算子分裂格式。\n2. 对每个测试案例，计算 SOC 单调性的两个布尔结果（先 DM 后 MD）和峰值应力单调性的两个布尔结果（先 DM 后 MD）。\n3. 生成单行输出，包含所有测试案例的结果。结果为逗号分隔的案例结果列表，其中每个案例结果是按 $[\\text{SOC}_{\\text{DM}}, \\text{SOC}_{\\text{MD}}, \\text{Stress}_{\\text{DM}}, \\text{Stress}_{\\text{MD}}]$ 顺序排列的四个布尔值列表。\n\n测试套件：\n- 案例 1 (正常路径)：$N=50$, $L=1$, $D=0.01$, $\\alpha=0.1$, $E=1$, $\\eta=0.05$, $k_f=5$, $\\chi=0.5$, $J_{\\text{in}}=1$, $\\Delta t=5\\times 10^{-4}$, $N_t=200$。\n- 案例 2 (接近稳定性的强耦合)：$N=50$, $L=1$, $D=0.05$, $\\alpha=0.1$, $E=1$, $\\eta=0.2$, $k_f=10$, $\\chi=1.0$, $J_{\\text{in}}=2$, $\\Delta t=2\\times 10^{-3}$, $N_t=200$。\n- 案例 3 (无耦合)：$N=50$, $L=1$, $D=0.02$, $\\alpha=0.1$, $E=1$, $\\eta=0.1$, $k_f=5$, $\\chi=0.0$, $J_{\\text{in}}=1$, $\\Delta t=10^{-3}$, $N_t=200$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含所有结果，格式为逗号分隔的案例结果列表，每个案例结果的格式为 $[\\text{SOC}_{\\text{DM}}, \\text{SOC}_{\\text{MD}}, \\text{Stress}_{\\text{DM}}, \\text{Stress}_{\\text{MD}}]$，条目为布尔值，整个列表用方括号括起来。例如：$[[\\text{True},\\text{True},\\text{True},\\text{True}],[\\dots],[\\dots]]$。",
            "solution": "该模型始于锂浓度的质量守恒和一个包含应力梯度项的修正菲克通量。通量定义为 $J = -D\\left(\\partial c/\\partial x - \\chi\\,\\partial \\sigma/\\partial x\\right)$，因此质量守恒得出\n$$\n\\frac{\\partial c}{\\partial t} = -\\frac{\\partial J}{\\partial x} = \\frac{\\partial}{\\partial x}\\left[D\\,\\frac{\\partial c}{\\partial x} - D\\,\\chi\\,\\frac{\\partial \\sigma}{\\partial x}\\right].\n$$\n力学模型使用包含化学膨胀项和 Winkler 地基的 Kelvin–Voigt 粘弹性模型。应力为 $\\sigma = E\\,\\varepsilon + \\eta\\,\\partial \\varepsilon/\\partial t - E\\,\\alpha\\,c$，力学平衡要求 $\\partial \\sigma/\\partial x - k_f\\,u = 0$。对本构方程求导并应用平衡条件，可得\n$$\n\\frac{\\partial}{\\partial x}\\Big(E\\,\\frac{\\partial u}{\\partial x} + \\eta\\,\\frac{\\partial}{\\partial t}\\left(\\frac{\\partial u}{\\partial x}\\right) - E\\,\\alpha\\,c\\Big) - k_f\\,u = 0,\n$$\n该方程对位移是线性的、空间二阶的，但通过粘性贡献包含了一个时间一阶导数项。重要的是，平衡条件意味着对于完整应力（包括粘性项），有 $\\partial \\sigma/\\partial x = k_f\\,u$。将此代入扩散方程，可将耦合简化为与位移梯度的关系：\n$$\n\\frac{\\partial c}{\\partial t} = D\\,\\frac{\\partial^2 c}{\\partial x^2} - D\\,\\chi\\,k_f\\,\\frac{\\partial u}{\\partial x}.\n$$\n\n浓度的边界条件通过通量定义来表达。在 $x=0$ 处，$J(0,t) = J_{\\text{in}}$；在 $x=L$ 处，$J(L,t) = 0$。在夹持力学条件下，$u(0,t) = 0$ 且 $u(L,t) = 0$，因此 $\\partial \\sigma/\\partial x(0,t) = k_f\\,u(0,t) = 0$ 且 $\\partial \\sigma/\\partial x(L,t) = k_f\\,u(L,t) = 0$。因此，通量条件简化为关于 $c$ 的 Neumann 条件：$-D\\,\\partial c/\\partial x(0,t) = J_{\\text{in}}$ 和 $-D\\,\\partial c/\\partial x(L,t) = 0$。初始条件为 $c(x,0)=0$ 和 $u(x,0)=0$。\n\n空间离散化使用包含 $N$ 个节点的均匀网格，间距为 $\\Delta x = L/(N-1)$。扩散方程的离散拉普拉斯算子通过虚拟点来包含 Neumann 边界条件。在 $x=0$ 处，已知梯度为 $g_0 = \\partial c/\\partial x(0) = -J_{\\text{in}}/D$，虚拟值为 $c_{-1} = c_1 - 2\\,\\Delta x\\,g_0$；在 $x=L$ 处，梯度为 $g_L = 0$，虚拟值为 $c_N = c_{N-2} + 2\\,\\Delta x\\,g_L = c_{N-2}$。节点 $i$ 处的离散拉普拉斯算子则为 $(c_{i-1} - 2 c_i + c_{i+1})/\\Delta x^2$，并在边界处进行虚拟点处理。位移梯度在内部使用中心差分计算，在边界处使用与夹持值一致的单边差分计算。\n\n时间离散化使用算子分裂：\n- 扩散子步是显式欧拉法：\n$$\nc^{n+1} = c^n + \\Delta t\\left( D\\,\\Delta_x c^n - D\\,\\chi\\,k_f\\,\\frac{\\partial u^n}{\\partial x}\\right).\n$$\n这通过 $\\Delta_x c^n$ 中的虚拟点构造来引入 Neumann 边界通量。\n\n- 力学子步是对粘弹性项应用时间上的后向欧拉法和空间上的有限差分法。在内部节点上（不包括指定了 $u$ 的边界），将离散拉普拉斯算子 $\\Delta_x$ 定义为三对角矩阵，其主对角线上的元素为 $-2/\\Delta x^2$，次对角线和超对角线上的元素为 $1/\\Delta x^2$。后向欧拉离散化得到线性系统\n$$\n\\left(\\frac{\\eta}{\\Delta t}\\,\\Delta_x + E\\,\\Delta_x - k_f\\,I\\right)u^{n+1} = \\frac{\\eta}{\\Delta t}\\,\\Delta_x u^n + E\\,\\alpha\\,G_x\\,c^{*},\n$$\n其中 $G_x$ 是内部节点上的中心差分一阶导数算子，$I$ 是单位矩阵。$c^{*}$ 的选择取决于分裂顺序：\n  - 对于扩散-力学 (DM)，$c^{*} = c^{n+1}$，意味着力学响应在同一时间步内更新后的浓度。\n  - 对于力学-扩散 (MD)，$c^{*} = c^n$，意味着力学响应前一时刻的浓度。扩散更新使用新计算出的位移场 $u^{n+1}$。\n\n时间步结束时的应力计算如下\n$$\n\\sigma^{n+1}(x) = E\\,\\varepsilon^{n+1}(x) + \\eta\\,\\frac{\\varepsilon^{n+1}(x) - \\varepsilon^n(x)}{\\Delta t} - E\\,\\alpha\\,\\tilde{c}(x),\n$$\n其中 $\\varepsilon^n = \\partial u^n/\\partial x$ 和 $\\varepsilon^{n+1} = \\partial u^{n+1}/\\partial x$ 通过有限差分计算，$\\tilde{c}$ 的选择与力学子步保持一致：对于 DM 是 $\\tilde{c} = c^{n+1}$，对于 MD 是 $\\tilde{c} = c^n$。这种选择隔离了算子顺序对应力评估的影响，这是评估分裂格式下单调性的关键要素。\n\n荷电状态 (SOC) 是 $c$ 在 $[0,L]$ 上的空间积分，通过梯形法则进行数值计算：\n$$\n\\text{SOC}^{n} \\approx \\int_0^L c(x,t^n)\\,\\mathrm{d}x \\approx \\sum_{i=0}^{N-1} w_i\\,c_i^n\\,\\Delta x,\n$$\n其中 $w_0 = w_{N-1} = \\tfrac{1}{2}$，其他情况下 $w_i = 1$。应力峰值为 $\\max_i |\\sigma_i^n|$。对于离散序列 $\\{y^n\\}$，通过在小的数值容差内验证对所有 $n$ 均有 $y^{n+1} \\ge y^n$ 来检查其单调性。\n\n每个测试案例的算法大纲：\n1. 将 $c$、$u$ 和前一时刻应变场的数组初始化为零。\n2. 对每个时间步：\n   - DM 顺序：\n     a. 计算带有 Neumann 边界条件的 $\\Delta_x c^n$ 和 $\\partial u^n/\\partial x$；更新 $c^{n+1}$。\n     b. 在强迫项中使用 $c^{n+1}$，组装并求解关于 $u^{n+1}$ 的线性系统。\n     c. 使用 $c^{n+1}$ 计算 $\\varepsilon^{n+1}$ 和 $\\sigma^{n+1}$。\n     d. 更新 SOC 和峰值应力序列。\n   - MD 顺序：\n     a. 使用 $c^n$ 组装并求解关于 $u^{n+1}$ 的线性系统。\n     b. 计算 $\\partial u^{n+1}/\\partial x$ 并使用此位移梯度更新 $c^{n+1}$。\n     c. 使用 $c^n$ (与力学子步一致) 计算 $\\varepsilon^{n+1}$ 和 $\\sigma^{n+1}$。\n     d. 更新 SOC 和峰值应力序列。\n3. 在 $N_t$ 步后，测试两种顺序下 SOC 和峰值应力序列的单调性。\n\n设计考虑：\n- 带有耦合项的显式扩散步具有与纯扩散情况类似的稳定性约束，即 $\\Delta t \\lesssim \\Delta x^2/(2D)$；所选的测试案例大致遵循此约束，而案例 2 则在稳定性极限附近探测更强的耦合，以检验对分裂顺序的敏感性。\n- 后向欧拉力学子步通过隐式处理粘性贡献来确保粘弹性模型的数值稳定性。\n- 夹持的力学边界在空间变化的 $c$ 作用下导致非均匀的位移场和应力场，而 Winkler 地基引入了分布式的恢复力，产生非零的应力梯度，从而在扩散方程中实现了化学-力学耦合。\n- 单调性评估时使用一个小的容差，以避免因浮点舍入误差导致的假阴性结果。\n\n最终程序执行三个指定的测试案例，应用 DM 和 MD 两种算子顺序，计算 SOC 和应力峰值的单调性布尔值，并以所需格式打印单行结果。",
            "answer": "```python\nimport numpy as np\n\ndef is_nondecreasing(seq, tol=1e-10):\n    return all(seq[i+1] >= seq[i] - tol for i in range(len(seq)-1))\n\ndef laplacian_c_neumann(c, dx, D, J_in):\n    # Neumann BCs: -D * dc/dx(0) = J_in = dc/dx(0) = -J_in / D\n    # and -D * dc/dx(L) = 0 = dc/dx(L) = 0\n    g0 = -J_in / D\n    gL = 0.0\n    n = len(c)\n    lap = np.zeros_like(c)\n    # Ghost values\n    c_left = c[1] - 2.0 * dx * g0\n    c_right = c[n-2] + 2.0 * dx * gL\n    # Left boundary\n    lap[0] = (c_left - 2.0 * c[0] + c[1]) / (dx * dx)\n    # Interior\n    for i in range(1, n-1):\n        lap[i] = (c[i-1] - 2.0 * c[i] + c[i+1]) / (dx * dx)\n    # Right boundary\n    lap[n-1] = (c[n-2] - 2.0 * c[n-1] + c_right) / (dx * dx)\n    return lap\n\ndef grad_u(u, dx):\n    n = len(u)\n    du_dx = np.zeros_like(u)\n    # Left boundary one-sided (u[0] = 0)\n    du_dx[0] = (u[1] - u[0]) / dx\n    # Interior central difference\n    for i in range(1, n-1):\n        du_dx[i] = (u[i+1] - u[i-1]) / (2.0 * dx)\n    # Right boundary one-sided (u[n-1] = 0)\n    du_dx[n-1] = (u[n-1] - u[n-2]) / dx\n    return du_dx\n\ndef build_mechanics_matrices(N, dx, E, eta, kf, dt):\n    # Interior nodes: indices 1..N-2, size Ni = N-2\n    Ni = N - 2\n    # Discrete Laplacian on interior with homogeneous Dirichlet boundaries\n    main = (-2.0 / (dx*dx)) * np.ones(Ni)\n    off = (1.0 / (dx*dx)) * np.ones(Ni - 1)\n    L = np.zeros((Ni, Ni))\n    np.fill_diagonal(L, main)\n    np.fill_diagonal(L[1:], off)\n    np.fill_diagonal(L[:,1:], off)\n    I = np.eye(Ni)\n    A = (eta / dt) * L + E * L - kf * I\n    return A, L\n\ndef grad_c_interior(c, dx):\n    # Gradient at interior nodes 1..N-2\n    n = len(c)\n    Ni = n - 2\n    gc = np.zeros(Ni)\n    for j in range(1, n-1):\n        gc[j-1] = (c[j+1] - c[j-1]) / (2.0 * dx)\n    return gc\n\ndef trapezoid_integral(y, dx):\n    # Composite trapezoid rule on uniform grid\n    return dx * (0.5 * y[0] + np.sum(y[1:-1]) + 0.5 * y[-1])\n\ndef run_case(N, L, D, alpha, E, eta, kf, chi, J_in, dt, Nt):\n    dx = L / (N - 1)\n    # Prebuild mechanics matrices\n    A, Lmat = build_mechanics_matrices(N, dx, E, eta, kf, dt)\n    # Initialize fields\n    c_DM_n = np.zeros(N)\n    u_DM_n = np.zeros(N)\n    strain_prev_DM = np.zeros(N)\n    soc_series_DM = []\n    stresspeak_series_DM = []\n\n    c_MD_n = np.zeros(N)\n    u_MD_n = np.zeros(N)\n    strain_prev_MD = np.zeros(N)\n    soc_series_MD = []\n    stresspeak_series_MD = []\n\n    # Time stepping\n    for n in range(Nt):\n        # ---------------- DM: Diffusion then Mechanics ----------------\n        # Diffusion update using u at time n\n        du_dx_DM = grad_u(u_DM_n, dx)\n        lap_c_DM = laplacian_c_neumann(c_DM_n, dx, D, J_in)\n        c_DM_np1 = c_DM_n + dt * (D * lap_c_DM - D * chi * kf * du_dx_DM)\n\n        # Mechanics update using updated concentration c_DM_np1\n        u_int_DM_n = u_DM_n[1:-1]\n        rhs_DM = (eta / dt) * (Lmat @ u_int_DM_n) + E * alpha * grad_c_interior(c_DM_np1, dx)\n        u_int_DM_np1 = np.linalg.solve(A, rhs_DM)\n        u_DM_np1 = np.zeros(N)\n        u_DM_np1[1:-1] = u_int_DM_np1\n\n        # Compute strain and stress\n        strain_DM_np1 = grad_u(u_DM_np1, dx)\n        sigma_DM_np1 = E * strain_DM_np1 + eta * (strain_DM_np1 - strain_prev_DM) / dt - E * alpha * c_DM_np1\n        \n        # SOC and stress peak\n        soc_series_DM.append(trapezoid_integral(c_DM_np1, dx))\n        stresspeak_series_DM.append(float(np.max(np.abs(sigma_DM_np1))))\n\n        # Update for next step\n        c_DM_n, u_DM_n, strain_prev_DM = c_DM_np1, u_DM_np1, strain_DM_np1\n\n        # ---------------- MD: Mechanics then Diffusion ----------------\n        # Mechanics update using c_MD_n (at time n)\n        u_int_MD_n = u_MD_n[1:-1]\n        rhs_MD = (eta / dt) * (Lmat @ u_int_MD_n) + E * alpha * grad_c_interior(c_MD_n, dx)\n        u_int_MD_np1 = np.linalg.solve(A, rhs_MD)\n        u_MD_np1 = np.zeros(N)\n        u_MD_np1[1:-1] = u_int_MD_np1\n\n        # Diffusion update using updated displacement u_MD_np1\n        du_dx_MD_np1 = grad_u(u_MD_np1, dx)\n        lap_c_MD_n = laplacian_c_neumann(c_MD_n, dx, D, J_in)\n        c_MD_np1 = c_MD_n + dt * (D * lap_c_MD_n - D * chi * kf * du_dx_MD_np1)\n\n        # Compute strain and stress; stress uses c_MD_n (mechanical substep input)\n        strain_MD_np1 = grad_u(u_MD_np1, dx)\n        sigma_MD_np1 = E * strain_MD_np1 + eta * (strain_MD_np1 - strain_prev_MD) / dt - E * alpha * c_MD_n\n        \n        # SOC and stress peak\n        soc_series_MD.append(trapezoid_integral(c_MD_np1, dx))\n        stresspeak_series_MD.append(float(np.max(np.abs(sigma_MD_np1))))\n        \n        # Update for next step\n        c_MD_n, u_MD_n, strain_prev_MD = c_MD_np1, u_MD_np1, strain_MD_np1\n\n\n    # Monotonicity checks\n    soc_DM_monotone = is_nondecreasing(soc_series_DM)\n    soc_MD_monotone = is_nondecreasing(soc_series_MD)\n    stress_DM_monotone = is_nondecreasing(stresspeak_series_DM)\n    stress_MD_monotone = is_nondecreasing(stresspeak_series_MD)\n\n    return soc_DM_monotone, soc_MD_monotone, stress_DM_monotone, stress_MD_monotone\n\ndef solve():\n    # Define test cases from the problem statement\n    test_cases = [\n        # (N, L, D, alpha, E, eta, kf, chi, J_in, dt, Nt)\n        (50, 1.0, 0.01, 0.1, 1.0, 0.05, 5.0, 0.5, 1.0, 5e-4, 200),\n        (50, 1.0, 0.05, 0.1, 1.0, 0.2, 10.0, 1.0, 2.0, 2e-3, 200),\n        (50, 1.0, 0.02, 0.1, 1.0, 0.1, 5.0, 0.0, 1.0, 1e-3, 200),\n    ]\n\n    results_str_items = []\n    for case in test_cases:\n        socDM, socMD, stressDM, stressMD = run_case(*case)\n        # Build a compact string representation without spaces\n        case_str = f\"[{str(socDM)},{str(socMD)},{str(stressDM)},{str(stressMD)}]\"\n        results_str_items.append(case_str.replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\n    print(f\"[{','.join(results_str_items)}]\")\n\nsolve()\n```"
        }
    ]
}