{
    "hands_on_practices": [
        {
            "introduction": "The accuracy of operator splitting methods hinges on how well the underlying physical operators commute. This practice delves into the mathematical heart of splitting error by tasking you with its direct calculation for a 2D advection-diffusion problem. By numerically implementing the leading-order error term from the Baker-Campbell-Hausdorff expansion, which involves nested commutators like $[A,[A,B]]$, you will gain a concrete understanding of how non-commutativity generates error and how its magnitude depends on the problem parameters .",
            "id": "3427806",
            "problem": "Consider the two-dimensional passive scalar advection–diffusion equation on a periodic square domain with side length $2\\pi$:\n$$\n\\frac{\\partial s}{\\partial t} = A(s) + B(s),\n$$\nwhere the advection operator $A$ and the diffusion operator $B$ are defined by\n$$\nA(s) = -\\boldsymbol{v}\\cdot\\nabla s,\\qquad B(s) = \\nu \\Delta s.\n$$\nThe velocity field $\\boldsymbol{v}(x,y)$ is time-independent and given by the Taylor–Green vortex:\n$$\n\\boldsymbol{v}(x,y) = \\left(U\\sin(k_v x)\\cos(k_v y),\\,-U\\cos(k_v x)\\sin(k_v y)\\right),\n$$\nand the initial scalar field is\n$$\ns_0(x,y) = \\cos(k_s x)\\cos(k_s y).\n$$\nAssume all quantities are dimensionless and the domain is $[0,2\\pi]\\times[0,2\\pi]$ with periodic boundary conditions.\n\nYou are to:\n- Implement one Strang-split step of duration $\\Delta t$ for the above system, namely compute\n$$\ns^{\\text{Strang}}(\\Delta t) = e^{A \\Delta t/2}\\, e^{B \\Delta t}\\, e^{A \\Delta t/2}\\, s_0,\n$$\nwhere $e^{A \\tau}$ denotes the exact advection operator for time $\\tau$ under the frozen-in-time velocity field $\\boldsymbol{v}$, and $e^{B \\tau}$ is the exact diffusion operator for time $\\tau$.\n- Derive and compute the leading-order expected error in the $L^2$ norm after one time step due to operator splitting alone (that is, excluding spatial and temporal discretization errors) using the Baker–Campbell–Hausdorff expansion. For time-invariant operators $A$ and $B$, the local error of Strang splitting is of order $\\mathcal{O}(\\Delta t^3)$ and the leading term is given by\n$$\n\\frac{\\Delta t^3}{12}\\left([A,[A,B]] + [B,[B,A]]\\right) s_0,\n$$\nwhere the commutator $[X,Y]$ acting on a function $f$ is defined by $[X,Y]f = X(Yf) - Y(Xf)$. The expected $L^2$ error should therefore be computed as\n$$\n\\left\\|\\frac{\\Delta t^3}{12}\\left([A,[A,B]] + [B,[B,A]]\\right) s_0\\right\\|_{L^2},\n$$\nwith the $L^2$ norm defined by\n$$\n\\|f\\|_{L^2} = \\left(\\int_{0}^{2\\pi}\\int_{0}^{2\\pi} |f(x,y)|^2 \\, dx\\,dy\\right)^{1/2}.\n$$\n\nYour implementation must:\n- Use a uniform grid of size $N\\times N$ over $[0,2\\pi]\\times[0,2\\pi]$.\n- Compute spatial derivatives via the Fast Fourier Transform (FFT) to evaluate $\\nabla s$ and $\\Delta s$ consistently for periodic functions.\n- Perform $e^{A \\tau}$ via semi-Lagrangian advection with a fourth-order Runge–Kutta characteristic integration for the frozen velocity field and periodic bilinear interpolation of the scalar field; perform $e^{B \\tau}$ exactly in Fourier space as multiplication by $e^{-\\nu |{\\boldsymbol{k}}|^2 \\tau}$ for Fourier mode ${\\boldsymbol{k}}$.\n- Compute the expected $L^2$ error using the commutator expression above, implemented by composing $A$ and $B$ numerically via FFT-based derivatives.\n\nDesign a test suite covering different facets:\n- A general case with nonzero advection and diffusion.\n- Boundary cases where either advection or diffusion vanishes, for which the splitting error should be zero by definition.\n- A case with higher wavenumbers to stress noncommutativity.\n- A case with stronger advection.\n\nUse the following test cases $(U,k_v,k_s,\\nu,\\Delta t,N)$:\n1. $(1.0,\\,1,\\,1,\\,0.01,\\,0.05,\\,64)$\n2. $(1.0,\\,1,\\,1,\\,0.00,\\,0.05,\\,64)$\n3. $(0.0,\\,1,\\,1,\\,0.01,\\,0.05,\\,64)$\n4. $(2.0,\\,2,\\,3,\\,0.02,\\,0.05,\\,64)$\n5. $(1.0,\\,4,\\,4,\\,0.01,\\,0.10,\\,64)$\n\nYour program should produce a single line of output containing the expected $L^2$ error values for the five cases, as a comma-separated list enclosed in square brackets (e.g., $[e_1,e_2,e_3,e_4,e_5]$). No other text should be printed. All values must be dimensionless real numbers. Angles in trigonometric functions are in radians.",
            "solution": "The problem requires the computation of the leading-order error of a Strang-splitting scheme for the two-dimensional advection-diffusion equation. The solution involves discretizing the domain and operators, then numerically evaluating a complex expression involving nested commutators of these operators.\n\nThe governing equation is\n$$\n\\frac{\\partial s}{\\partial t} = A(s) + B(s)\n$$\non a periodic domain $[0,2\\pi]\\times[0,2\\pi]$, where $A(s) = -\\boldsymbol{v}\\cdot\\nabla s$ is the advection operator and $B(s) = \\nu \\Delta s$ is the diffusion operator. The velocity field is a time-independent Taylor-Green vortex, and the initial scalar field is $s_0(x,y) = \\cos(k_s x)\\cos(k_s y)$.\n\nThe primary objective is to calculate the $L^2$ norm of the leading-order local error term for a single Strang-splitting step of duration $\\Delta t$. For time-invariant operators, this error term is given by the Baker-Campbell-Hausdorff (BCH) expansion as:\n$$\nE = \\frac{\\Delta t^3}{12}\\left([A,[A,B]] + [B,[B,A]]\\right) s_0\n$$\nwhere $[X,Y]f = X(Yf) - Y(Xf)$ is the commutator of operators $X$ and $Y$. We are tasked to compute $\\|E\\|_{L^2}$.\n\nThe computational strategy proceeds as follows:\n1.  Discretize the continuous domain $[0,2\\pi]\\times[0,2\\pi]$ into a uniform $N\\times N$ grid.\n2.  Implement numerical representations of the differential operators $A$ and $B$ using pseudospectral methods (i.e., via the Fast Fourier Transform, FFT).\n3.  Evaluate the nested commutator expression by applying the numerical operators sequentially to the initial field $s_0$.\n4.  Compute the $L^2$ norm of the resulting error field using numerical integration.\n\n**Step 1: Discretization and Fourier Representation**\nThe domain is discretized into an $N \\times N$ grid with coordinates $(x_i, y_j)$, where $x_i = i \\frac{2\\pi}{N}$ and $y_j = j \\frac{2\\pi}{N}$ for $i,j \\in \\{0, 1, \\dots, N-1\\}$. A scalar field $s(x,y)$ is represented as a matrix $s_{ij} = s(x_i, y_j)$.\n\nFor a periodic function on this grid, spatial derivatives are most accurately computed in Fourier space. The 2D discrete Fourier transform of $s$ is $\\hat{s}(\\boldsymbol{k}) = \\mathcal{F}(s)$, where $\\boldsymbol{k}=(k_x, k_y)$ is the wavevector. The integer wavenumbers corresponding to the grid are $k_x, k_y \\in \\{-\\frac{N}{2}, \\dots, \\frac{N}{2}-1\\}$. Derivatives transform as:\n$$\n\\mathcal{F}\\left(\\frac{\\partial s}{\\partial x}\\right) = i k_x \\hat{s}(\\boldsymbol{k})\n$$\n$$\n\\mathcal{F}\\left(\\frac{\\partial s}{\\partial y}\\right) = i k_y \\hat{s}(\\boldsymbol{k})\n$$\n$$\n\\mathcal{F}(\\Delta s) = \\mathcal{F}\\left(\\frac{\\partial^2 s}{\\partial x^2} + \\frac{\\partial^2 s}{\\partial y^2}\\right) = -(k_x^2 + k_y^2) \\hat{s}(\\boldsymbol{k}) = -|\\boldsymbol{k}|^2 \\hat{s}(\\boldsymbol{k})\n$$\nThe real-space derivatives are then recovered by applying the inverse Fourier transform $\\mathcal{F}^{-1}$.\n\n**Step 2: Numerical Implementation of Operators $A$ and $B$**\nThe operators are implemented as functions that act on a 2D array representing the scalar field.\n\nThe diffusion operator $B(s) = \\nu \\Delta s$ is computed entirely in Fourier space. The numerical procedure is:\n1.  Compute the 2D FFT of the field $s$: $\\hat{s} = \\text{fft2}(s)$.\n2.  Multiply by the Fourier symbol of the operator: $\\widehat{B(s)} = \\nu (-|\\boldsymbol{k}|^2) \\hat{s}$.\n3.  Compute the 2D inverse FFT of the result and take the real part: $B(s) = \\text{real}(\\text{ifft2}(\\widehat{B(s)}))$.\n\nThe advection operator $A(s) = -(v_x \\frac{\\partial s}{\\partial x} + v_y \\frac{\\partial s}{\\partial y})$ is implemented using the pseudospectral method:\n1.  Compute the gradients $\\frac{\\partial s}{\\partial x}$ and $\\frac{\\partial s}{\\partial y}$ in Fourier space as described above.\n2.  Transform the gradients back to real space.\n3.  Compute the velocity field components $v_x$ and $v_y$ on the grid.\n4.  Perform the dot product and multiplication by $-1$ in real space: $A(s) = -(v_x \\frac{\\partial s}{\\partial x} + v_y \\frac{\\partial s}{\\partial y})$.\n\n**Step 3: Evaluation of the Commutator Expression**\nThe expression $E = \\frac{\\Delta t^3}{12} \\left( [A,[A,B]]s_0 + [B,[B,A]]s_0 \\right)$ involves nested commutators. To compute this numerically, we expand the commutators:\n$$\n[A,[A,B]]s_0 = A(A(B(s_0))) - 2A(B(A(s_0))) + B(A(A(s_0)))\n$$\n$$\n[B,[B,A]]s_0 = A(B(B(s_0))) - 2B(A(B(s_0))) + B(B(A(s_0)))\n$$\nLet's denote the application of an operator $X$ to a field $f$ as $Xf$. The numerical evaluation requires computing all six unique third-order operator sequences on the initial field $s_0$:\n$AABs_0$, $ABAs_0$, $BAAs_0$, $ABBs_0$, $BABs_0$, $BBAs_0$.\nThe total unscaled error field is then assembled as:\n$$\n_E = (AABs_0 - 2 ABAs_0 + BAAs_0) + (ABBs_0 - 2 BABs_0 + BBAs_0)\n$$\nFinally, the full error field is $E = \\frac{\\Delta t^3}{12} {}_E$. Note that if either $U=0$ (so $A=0$) or $\\nu=0$ (so $B=0$), the commutators vanish, yielding an error of zero as expected.\n\n**Step 4: Computation of the $L^2$ Norm**\nThe $L^2$ norm of a function $f$ on the domain is $\\|f\\|_{L^2} = \\left(\\int_0^{2\\pi}\\int_0^{2\\pi} |f(x,y)|^2 \\, dx\\,dy\\right)^{1/2}$. This integral is approximated by a sum over the discrete grid points:\n$$\n\\|E\\|_{L^2} \\approx \\left( \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} |E(x_i, y_j)|^2 \\Delta x \\Delta y \\right)^{1/2}\n$$\nwhere $E(x_i, y_j)$ are the values of the computed error field on the grid, and the grid spacing is $\\Delta x = \\Delta y = \\frac{2\\pi}{N}$.\n\nThe overall algorithm iterates through each test case, sets up the parameters and initial field, and then executes steps 2 through 4 to calculate the final scalar error value.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the leading-order Strang splitting error for the 2D\n    advection-diffusion equation on a periodic domain.\n    \"\"\"\n    test_cases = [\n        (1.0, 1, 1, 0.01, 0.05, 64),\n        (1.0, 1, 1, 0.00, 0.05, 64),\n        (0.0, 1, 1, 0.01, 0.05, 64),\n        (2.0, 2, 3, 0.02, 0.05, 64),\n        (1.0, 4, 4, 0.01, 0.10, 64)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        U, k_v, k_s, nu, dt, N = case\n\n        # If U or nu is zero, one operator is zero, so the commutator is zero,\n        # and the splitting error is zero.\n        if U == 0.0 or nu == 0.0:\n            results.append(0.0)\n            continue\n\n        # 1. Setup Grid, Wavenumbers, and Fields\n        L = 2.0 * np.pi\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        X, Y = np.meshgrid(x, x, indexing='ij')\n\n        # Wavenumbers for FFT on a domain of size L=2*pi\n        k_vec = np.fft.fftfreq(N) * N \n        Kx, Ky = np.meshgrid(k_vec, k_vec, indexing='ij')\n        K2 = Kx**2 + Ky**2\n\n        # Initial scalar field\n        s0 = np.cos(k_s * X) * np.cos(k_s * Y)\n        # Velocity field\n        vx = U * np.sin(k_v * X) * np.cos(k_v * Y)\n        vy = -U * np.cos(k_v * X) * np.sin(k_v * Y)\n\n        # 2. Define numerical operators A and B\n        def apply_A(s_field):\n            \"\"\"Applies advection operator A(s) = -v . grad(s)\"\"\"\n            s_hat = np.fft.fft2(s_field)\n            ds_dx_hat = 1j * Kx * s_hat\n            ds_dy_hat = 1j * Ky * s_hat\n            ds_dx = np.fft.ifft2(ds_dx_hat).real\n            ds_dy = np.fft.ifft2(ds_dy_hat).real\n            return -(vx * ds_dx + vy * ds_dy)\n\n        def apply_B(s_field):\n            \"\"\"Applies diffusion operator B(s) = nu * laplacian(s)\"\"\"\n            s_hat = np.fft.fft2(s_field)\n            lap_s_hat = -K2 * s_hat\n            lap_s = np.fft.ifft2(lap_s_hat).real\n            return nu * lap_s\n\n        # 3. Compute all third-order operator applications\n        \n        # 1st order applications\n        As0 = apply_A(s0)\n        Bs0 = apply_B(s0)\n        \n        # 2nd order applications\n        AAs0 = apply_A(As0)\n        ABs0 = apply_A(Bs0)\n        BAs0 = apply_B(As0)\n        BBs0 = apply_B(Bs0)\n\n        # 3rd order applications\n        # For term [A, [A, B]]s0 = AABs0 - 2*ABAs0 + BAAs0\n        AABs0 = apply_A(ABs0)\n        ABAs0 = apply_A(BAs0)\n        BAAs0 = apply_B(AAs0)\n        \n        # For term [B, [B, A]]s0 = ABBs0 - 2*BABs0 + BBAs0\n        ABBs0 = apply_A(BBs0)\n        BABs0 = apply_B(ABs0)\n        BBAs0 = apply_B(BAs0)\n\n        # 4. Assemble the full error field\n        # term1 = A(A(B(s0))) - 2A(B(A(s0))) + B(A(A(s0)))\n        term1_field = AABs0 - 2.0 * ABAs0 + BAAs0\n        # term2 = A(B(B(s0))) - 2B(A(B(s0))) + B(B(A(s0)))\n        term2_field = ABBs0 - 2.0 * BABs0 + BBAs0\n        \n        unscaled_error_field = term1_field + term2_field\n        error_field = (dt**3 / 12.0) * unscaled_error_field\n\n        # 5. Compute the L2 norm of the error field\n        l2_norm_sq = np.sum(np.abs(error_field)**2) * (dx**2)\n        l2_norm = np.sqrt(l2_norm_sq)\n        \n        results.append(l2_norm)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{val:.15e}' for val in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the theoretical understanding of splitting error, this exercise explores its tangible consequences in a complex multiphysics simulation. You will model the chemo-mechanical behavior of a battery electrode, a system where lithium diffusion and mechanical stress are tightly coupled. By implementing and comparing two different Lie splitting orderings—Diffusion-Mechanics (DM) versus Mechanics-Diffusion (MD)—this practice demonstrates how the abstract choice of operator sequence can impact critical physical predictions, such as the monotonicity of state-of-charge and peak stress during charging .",
            "id": "3427809",
            "problem": "Consider a one-dimensional electrode domain $x \\in [0,L]$ in which lithium concentration $c(x,t)$ diffuses and induces stress through chemo-mechanical coupling with displacement $u(x,t)$. The coupled multiphysics model consists of a diffusion equation for $c$ and a viscoelastic-mechanical equilibrium for $u$, with operator splitting to evolve the two physics sequentially over each time step. All variables are nondimensional; no physical units are required.\n\nFundamental base:\n- Mass conservation and Fickian diffusion: the lithium concentration $c$ evolves according to $\\partial c/\\partial t = -\\partial J/\\partial x$, where $J$ is the flux.\n- Chemo-mechanical coupling in the flux: adopt a stress-driven correction in the Larché–Cahn spirit, $J = -D\\left(\\partial c/\\partial x - \\chi \\,\\partial \\sigma/\\partial x\\right)$, where $D$ is the diffusivity, $\\chi$ is a coupling coefficient, and $\\sigma$ is the stress.\n- Linear viscoelasticity (Kelvin–Voigt) with a Winkler foundation: stress is $\\sigma = E\\,\\varepsilon + \\eta\\,\\partial \\varepsilon/\\partial t - E\\,\\alpha\\,c$, strain is $\\varepsilon = \\partial u/\\partial x$, elastic modulus is $E$, viscosity is $\\eta$, and chemical expansion coefficient is $\\alpha$. The mechanical equilibrium is $\\partial \\sigma/\\partial x - k_f\\,u = 0$, where $k_f$ is the foundation stiffness.\n\nFrom these principles, the coupled partial differential equations (PDEs) are\n$$\n\\frac{\\partial c}{\\partial t} = \\frac{\\partial}{\\partial x}\\left[D\\,\\frac{\\partial c}{\\partial x} - D\\,\\chi\\,\\frac{\\partial \\sigma}{\\partial x}\\right], \\quad 0 < x < L,\n$$\n$$\n\\frac{\\partial}{\\partial x}\\left(E\\,\\frac{\\partial u}{\\partial x} + \\eta\\,\\frac{\\partial}{\\partial t}\\left(\\frac{\\partial u}{\\partial x}\\right) - E\\,\\alpha\\,c\\right) - k_f\\,u = 0, \\quad 0 < x < L.\n$$\nUsing the mechanical equilibrium relation $\\partial \\sigma/\\partial x = k_f\\,u$ for the full viscoelastic stress $\\sigma$, the diffusion equation becomes\n$$\n\\frac{\\partial c}{\\partial t} = D\\,\\frac{\\partial^2 c}{\\partial x^2} - D\\,\\chi\\,k_f\\,\\frac{\\partial u}{\\partial x}.\n$$\n\nBoundary and initial conditions:\n- Concentration boundary flux at $x=0$ models charging: $J(0,t) = J_{\\text{in}}$ with $J_{\\text{in}} > 0$ constant, and zero flux at $x=L$: $J(L,t) = 0$. Using $J = -D(\\partial c/\\partial x - \\chi\\,\\partial \\sigma/\\partial x)$ and the mechanical boundary conditions below, this reduces to Neumann conditions $-D\\,\\partial c/\\partial x(0,t) = J_{\\text{in}}$ and $-D\\,\\partial c/\\partial x(L,t) = 0$.\n- Mechanics are clamped: $u(0,t) = 0$ and $u(L,t) = 0$.\n- Initial conditions: $c(x,0) = 0$ and $u(x,0) = 0$.\n\nSpatial discretization:\n- Uniform grid with $N$ nodes on $[0,L]$ and spacing $\\Delta x = L/(N-1)$.\n- Finite differences: second derivative via a standard three-point stencil and first derivative via central differences. For the diffusion equation, the Neumann boundary conditions for $c$ are enforced via ghost-point values consistent with the prescribed fluxes.\n\nTime discretization and operator splitting:\n- Time step $\\Delta t$ and $N_t$ total steps.\n- Two Lie-splitting orderings per time step $t^n \\to t^{n+1}$:\n  1. Diffusion–Mechanics (DM): first advance $c$ explicitly using $u$ at time $t^n$, then solve mechanics for $u$ at time $t^{n+1}$ using the updated $c$.\n  2. Mechanics–Diffusion (MD): first solve mechanics using $c$ at time $t^n$, then advance $c$ explicitly using the updated $u$; the stress at the end of the step is evaluated consistently with the mechanical substep concentration $c^n$.\n- Diffusion substep (explicit Euler):\n$$\nc^{n+1} = c^n + \\Delta t\\left( D\\,\\Delta_x c^n - D\\,\\chi\\,k_f\\,\\frac{\\partial u^n}{\\partial x}\\right),\n$$\nwhere $\\Delta_x$ is the discrete Laplacian with Neumann boundary conditions, and $\\partial u^n/\\partial x$ is the discrete displacement gradient at time $t^n$.\n- Mechanics substep (backward Euler in time for the viscoelastic term, finite differences in space on the interior nodes with homogeneous Dirichlet boundaries for $u$):\n$$\n\\left(\\frac{\\eta}{\\Delta t}\\,\\Delta_x + E\\,\\Delta_x - k_f\\,I\\right)u^{n+1} = \\frac{\\eta}{\\Delta t}\\,\\Delta_x u^n + E\\,\\alpha\\,G_x\\,c^{*},\n$$\nwhere $I$ is the identity on the interior nodes, $G_x$ is the discrete first-derivative operator, and $c^{*}$ is the concentration used by the mechanical substep: $c^{*} = c^{n+1}$ in the DM ordering and $c^{*} = c^n$ in the MD ordering. The stress at the end of the step is computed as\n$$\n\\sigma^{n+1} = E\\,\\varepsilon^{n+1} + \\eta\\,\\frac{\\varepsilon^{n+1} - \\varepsilon^n}{\\Delta t} - E\\,\\alpha\\,\\tilde{c},\n$$\nwhere $\\varepsilon^n$ and $\\varepsilon^{n+1}$ are the discrete strain fields and $\\tilde{c}$ is the concentration consistent with the mechanical substep: $\\tilde{c} = c^{n+1}$ for DM and $\\tilde{c} = c^n$ for MD.\n\nQuantities of interest and monotonicity tests:\n- State-of-charge (SOC) is the spatial integral of $c$ over $[0,L]$, computed by the composite trapezoid rule. Its discrete time series must be tested for monotonic nondecreasing behavior.\n- Stress peak is the maximum absolute stress over the spatial grid at the end of each time step. Its discrete time series must be tested for monotonic nondecreasing behavior.\n\nYour tasks:\n1. Implement the described operator-splitting scheme for both DM and MD orderings using the provided parameters in each test case.\n2. For each test case, compute two boolean results for SOC monotonicity (DM then MD) and two boolean results for peak stress monotonicity (DM then MD).\n3. Produce a single line of output containing the results for all test cases as a comma-separated list of case results, where each case result is a list of four booleans in the order $[\\text{SOC}_{\\text{DM}}, \\text{SOC}_{\\text{MD}}, \\text{Stress}_{\\text{DM}}, \\text{Stress}_{\\text{MD}}]$.\n\nTest suite:\n- Case 1 (happy path): $N=50$, $L=1$, $D=0.01$, $\\alpha=0.1$, $E=1$, $\\eta=0.05$, $k_f=5$, $\\chi=0.5$, $J_{\\text{in}}=1$, $\\Delta t=5\\times 10^{-4}$, $N_t=200$.\n- Case 2 (aggressive coupling near stability): $N=50$, $L=1$, $D=0.05$, $\\alpha=0.1$, $E=1$, $\\eta=0.2$, $k_f=10$, $\\chi=1.0$, $J_{\\text{in}}=2$, $\\Delta t=2\\times 10^{-3}$, $N_t=200$.\n- Case 3 (no coupling): $N=50$, $L=1$, $D=0.02$, $\\alpha=0.1$, $E=1$, $\\eta=0.1$, $k_f=5$, $\\chi=0.0$, $J_{\\text{in}}=1$, $\\Delta t=10^{-3}$, $N_t=200$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of the case results, each in the format $[\\text{SOC}_{\\text{DM}}, \\text{SOC}_{\\text{MD}}, \\text{Stress}_{\\text{DM}}, \\text{Stress}_{\\text{MD}}]$, with boolean entries, and the overall list enclosed in square brackets. For example: $[[\\text{True},\\text{True},\\text{True},\\text{True}],[\\dots],[\\dots]]$.",
            "solution": "The model starts from mass conservation of the lithium concentration and a modified Fickian flux that includes a stress-gradient term. The flux is defined as $J = -D\\left(\\partial c/\\partial x - \\chi\\,\\partial \\sigma/\\partial x\\right)$, so mass conservation yields\n$$\n\\frac{\\partial c}{\\partial t} = -\\frac{\\partial J}{\\partial x} = \\frac{\\partial}{\\partial x}\\left[D\\,\\frac{\\partial c}{\\partial x} - D\\,\\chi\\,\\frac{\\partial \\sigma}{\\partial x}\\right].\n$$\nThe mechanical model uses Kelvin–Voigt viscoelasticity with a chemical expansion term and a Winkler foundation. Stress is $\\sigma = E\\,\\varepsilon + \\eta\\,\\partial \\varepsilon/\\partial t - E\\,\\alpha\\,c$, and mechanical equilibrium imposes $\\partial \\sigma/\\partial x - k_f\\,u = 0$. Differentiating the constitutive equation and applying equilibrium gives\n$$\n\\frac{\\partial}{\\partial x}\\Big(E\\,\\frac{\\partial u}{\\partial x} + \\eta\\,\\frac{\\partial}{\\partial t}\\left(\\frac{\\partial u}{\\partial x}\\right) - E\\,\\alpha\\,c\\Big) - k_f\\,u = 0,\n$$\nwhich is linear, second order in space for the displacement but includes a first-order time derivative term via the viscous contribution. Importantly, equilibrium implies $\\partial \\sigma/\\partial x = k_f\\,u$ for the full stress (including the viscous term). Substituting this into the diffusion equation simplifies the coupling to the displacement gradient:\n$$\n\\frac{\\partial c}{\\partial t} = D\\,\\frac{\\partial^2 c}{\\partial x^2} - D\\,\\chi\\,k_f\\,\\frac{\\partial u}{\\partial x}.\n$$\n\nBoundary conditions for concentration are expressed via the flux definition. At $x=0$, $J(0,t) = J_{\\text{in}}$ and at $x=L$, $J(L,t) = 0$. With clamped mechanics, $u(0,t) = 0$ and $u(L,t) = 0$, hence $\\partial \\sigma/\\partial x(0,t) = k_f\\,u(0,t) = 0$ and $\\partial \\sigma/\\partial x(L,t) = k_f\\,u(L,t) = 0$. Therefore the flux conditions reduce to Neumann conditions for $c$: $-D\\,\\partial c/\\partial x(0,t) = J_{\\text{in}}$ and $-D\\,\\partial c/\\partial x(L,t) = 0$. Initial conditions are $c(x,0)=0$ and $u(x,0)=0$.\n\nSpatial discretization uses a uniform grid with $N$ nodes and spacing $\\Delta x = L/(N-1)$. The discrete Laplacian for the diffusion equation incorporates Neumann boundary conditions via ghost points. At $x=0$ with known gradient $g_0 = \\partial c/\\partial x(0) = -J_{\\text{in}}/D$, a ghost value is $c_{-1} = c_1 - 2\\,\\Delta x\\,g_0$, and at $x=L$ with $g_L = 0$, a ghost value is $c_N = c_{N-2} + 2\\,\\Delta x\\,g_L = c_{N-2}$. The discrete Laplacian at node $i$ is then $(c_{i-1} - 2 c_i + c_{i+1})/\\Delta x^2$ with ghost handling at the boundaries. The displacement gradient is computed with central differences in the interior and one-sided differences at the boundaries consistent with clamped values.\n\nTime discretization uses operator splitting:\n- Diffusion substep is explicit Euler:\n$$\nc^{n+1} = c^n + \\Delta t\\left( D\\,\\Delta_x c^n - D\\,\\chi\\,k_f\\,\\frac{\\partial u^n}{\\partial x}\\right).\n$$\nThis incorporates the Neumann boundary flux through the ghost-point construction in $\\Delta_x c^n$.\n\n- Mechanics substep is backward Euler in time applied to the viscoelastic term with finite differences in space. On interior nodes (excluding boundaries where $u$ is specified), define the discrete Laplacian operator $\\Delta_x$ as the tri-diagonal matrix with entries $1/\\Delta x^2$ on the sub- and super-diagonals and $-2/\\Delta x^2$ on the main diagonal. The backward Euler discretization yields the linear system\n$$\n\\left(\\frac{\\eta}{\\Delta t}\\,\\Delta_x + E\\,\\Delta_x - k_f\\,I\\right)u^{n+1} = \\frac{\\eta}{\\Delta t}\\,\\Delta_x u^n + E\\,\\alpha\\,G_x\\,c^{*},\n$$\nwhere $G_x$ is the centered-difference first-derivative operator on interior nodes, and $I$ is the identity. The choice of $c^{*}$ depends on the splitting order:\n  - For Diffusion–Mechanics (DM), $c^{*} = c^{n+1}$, meaning mechanics responds to the updated concentration within the time step.\n  - For Mechanics–Diffusion (MD), $c^{*} = c^n$, meaning mechanics responds to the previous concentration. The diffusion update uses the newly computed displacement field $u^{n+1}$.\n\nThe stress at the end of the time step is computed as\n$$\n\\sigma^{n+1}(x) = E\\,\\varepsilon^{n+1}(x) + \\eta\\,\\frac{\\varepsilon^{n+1}(x) - \\varepsilon^n(x)}{\\Delta t} - E\\,\\alpha\\,\\tilde{c}(x),\n$$\nwhere $\\varepsilon^n = \\partial u^n/\\partial x$ and $\\varepsilon^{n+1} = \\partial u^{n+1}/\\partial x$ are computed by finite differences, and $\\tilde{c}$ is chosen consistent with the mechanical substep: $\\tilde{c} = c^{n+1}$ for DM and $\\tilde{c} = c^n$ for MD. This choice isolates the effect of operator ordering on the stress evaluation, which is a key element in assessing monotonicity under splitting.\n\nThe state-of-charge (SOC) is the spatial integral of $c$ over $[0,L]$, computed numerically by the trapezoidal rule:\n$$\n\\text{SOC}^{n} \\approx \\int_0^L c(x,t^n)\\,\\mathrm{d}x \\approx \\sum_{i=0}^{N-1} w_i\\,c_i^n\\,\\Delta x,\n$$\nwhere $w_0 = w_{N-1} = \\tfrac{1}{2}$ and $w_i = 1$ otherwise. The stress peak is $\\max_i |\\sigma_i^n|$. Monotonicity for a discrete sequence $\\{y^n\\}$ is checked by verifying $y^{n+1} \\ge y^n$ within a small numerical tolerance for all $n$.\n\nAlgorithm outline per test case:\n1. Initialize arrays for $c$, $u$, and the previous strain field to zeros.\n2. For each time step:\n   - DM ordering:\n     a. Compute $\\Delta_x c^n$ with Neumann boundary conditions and $\\partial u^n/\\partial x$; update $c^{n+1}$.\n     b. Assemble and solve the linear system for $u^{n+1}$ using $c^{n+1}$ in the forcing term.\n     c. Compute $\\varepsilon^{n+1}$ and $\\sigma^{n+1}$ using $c^{n+1}$.\n     d. Update SOC and peak stress sequences.\n   - MD ordering:\n     a. Assemble and solve the linear system for $u^{n+1}$ using $c^n$.\n     b. Compute $\\partial u^{n+1}/\\partial x$ and update $c^{n+1}$ using this displacement gradient.\n     c. Compute $\\varepsilon^{n+1}$ and $\\sigma^{n+1}$ using $c^n$ (consistent with the mechanical substep).\n     d. Update SOC and peak stress sequences.\n3. After $N_t$ steps, test monotonicity of the SOC and peak stress sequences for both orderings.\n\nDesign considerations:\n- The explicit diffusion step with coupling term has a stability constraint similar to the pure diffusion case, $\\Delta t \\lesssim \\Delta x^2/(2D)$; the chosen test cases respect this approximately, while Case 2 probes stronger coupling near the stability limit to examine sensitivity to ordering.\n- The backward Euler mechanics substep ensures numerical stability for the viscoelastic model by treating the viscous contribution implicitly.\n- Clamped mechanical boundaries lead to nonuniform displacement and stress fields under spatially varying $c$, and the Winkler foundation introduces a distributed restoring force that produces nonzero stress gradients, thereby enabling chemo-mechanical coupling in the diffusion equation.\n- Monotonicity is evaluated with a small tolerance to avoid false negatives due to floating-point roundoff.\n\nThe final program executes the three specified test cases, applies both DM and MD operator orderings, computes the monotonicity booleans for SOC and stress peaks, and prints a single-line result in the required format.",
            "answer": "```python\nimport numpy as np\n\ndef is_nondecreasing(seq, tol=1e-10):\n    return all(seq[i+1] >= seq[i] - tol for i in range(len(seq)-1))\n\ndef laplacian_c_neumann(c, dx, D, J_in):\n    # Neumann BCs: -D * dc/dx(0) = J_in => dc/dx(0) = -J_in / D\n    # and -D * dc/dx(L) = 0 => dc/dx(L) = 0\n    g0 = -J_in / D\n    gL = 0.0\n    n = len(c)\n    lap = np.zeros_like(c)\n    # Ghost values\n    c_left = c[1] - 2.0 * dx * g0\n    c_right = c[n-2] + 2.0 * dx * gL\n    # Left boundary\n    lap[0] = (c_left - 2.0 * c[0] + c[1]) / (dx * dx)\n    # Interior\n    for i in range(1, n-1):\n        lap[i] = (c[i-1] - 2.0 * c[i] + c[i+1]) / (dx * dx)\n    # Right boundary\n    lap[n-1] = (c[n-2] - 2.0 * c[n-1] + c_right) / (dx * dx)\n    return lap\n\ndef grad_u(u, dx):\n    n = len(u)\n    du_dx = np.zeros_like(u)\n    # Left boundary one-sided (u[0] = 0)\n    du_dx[0] = (u[1] - u[0]) / dx\n    # Interior central difference\n    for i in range(1, n-1):\n        du_dx[i] = (u[i+1] - u[i-1]) / (2.0 * dx)\n    # Right boundary one-sided (u[n-1] = 0)\n    du_dx[n-1] = (u[n-1] - u[n-2]) / dx\n    return du_dx\n\ndef build_mechanics_matrices(N, dx, E, eta, kf, dt):\n    # Interior nodes: indices 1..N-2, size Ni = N-2\n    Ni = N - 2\n    # Discrete Laplacian on interior with homogeneous Dirichlet boundaries\n    main = (-2.0 / (dx*dx)) * np.ones(Ni)\n    off = (1.0 / (dx*dx)) * np.ones(Ni - 1)\n    L = np.zeros((Ni, Ni))\n    np.fill_diagonal(L, main)\n    np.fill_diagonal(L[1:], off)\n    np.fill_diagonal(L[:,1:], off)\n    I = np.eye(Ni)\n    A = (eta / dt) * L + E * L - kf * I\n    return A, L\n\ndef grad_c_interior(c, dx):\n    # Gradient at interior nodes 1..N-2\n    n = len(c)\n    Ni = n - 2\n    gc = np.zeros(Ni)\n    for j in range(1, n-1):\n        gc[j-1] = (c[j+1] - c[j-1]) / (2.0 * dx)\n    return gc\n\ndef trapezoid_integral(y, dx):\n    # Composite trapezoid rule on uniform grid\n    return dx * (0.5 * y[0] + np.sum(y[1:-1]) + 0.5 * y[-1])\n\ndef run_case(N, L, D, alpha, E, eta, kf, chi, J_in, dt, Nt):\n    dx = L / (N - 1)\n    # Prebuild mechanics matrices\n    A, Lmat = build_mechanics_matrices(N, dx, E, eta, kf, dt)\n    # Initialize fields\n    c_DM_prev = np.zeros(N)\n    c_DM = np.zeros(N)\n    u_DM = np.zeros(N)\n    strain_prev_DM = np.zeros(N)  # previous strain for viscous term\n    soc_series_DM = []\n    stresspeak_series_DM = []\n\n    c_MD_prev = np.zeros(N)\n    c_MD = np.zeros(N)\n    u_MD = np.zeros(N)\n    strain_prev_MD = np.zeros(N)\n    soc_series_MD = []\n    stresspeak_series_MD = []\n\n    # Time stepping\n    for n in range(Nt):\n        # ---------------- DM: Diffusion then Mechanics ----------------\n        c_DM_prev[:] = c_DM\n        # Diffusion update using u at time n\n        du_dx_DM = grad_u(u_DM, dx)\n        lap_c_DM = laplacian_c_neumann(c_DM_prev, dx, D, J_in)\n        c_DM = c_DM_prev + dt * (D * lap_c_DM - D * chi * kf * du_dx_DM)\n\n        # Mechanics update using updated concentration c_DM\n        # Assemble RHS: (eta/dt) * L * u_n + E * alpha * Gx c_DM\n        u_int_DM = u_DM[1:-1]\n        rhs_DM = (eta / dt) * (Lmat @ u_int_DM) + E * alpha * grad_c_interior(c_DM, dx)\n        # Solve for interior displacement\n        u_int_new_DM = np.linalg.solve(A, rhs_DM)\n        u_DM = np.zeros(N)\n        u_DM[1:-1] = u_int_new_DM\n\n        # Compute strain and stress\n        strain_DM = grad_u(u_DM, dx)\n        sigma_DM = E * strain_DM + eta * (strain_DM - strain_prev_DM) / dt - E * alpha * c_DM\n        strain_prev_DM = strain_DM.copy()\n\n        # SOC and stress peak\n        soc_DM = trapezoid_integral(c_DM, dx)\n        stresspeak_DM = float(np.max(np.abs(sigma_DM)))\n        soc_series_DM.append(soc_DM)\n        stresspeak_series_DM.append(stresspeak_DM)\n\n        # ---------------- MD: Mechanics then Diffusion ----------------\n        c_MD_prev[:] = c_MD\n        # Mechanics update using c_MD (at time n)\n        u_int_MD = u_MD[1:-1]\n        rhs_MD = (eta / dt) * (Lmat @ u_int_MD) + E * alpha * grad_c_interior(c_MD_prev, dx)\n        u_int_new_MD = np.linalg.solve(A, rhs_MD)\n        u_MD = np.zeros(N)\n        u_MD[1:-1] = u_int_new_MD\n\n        # Diffusion update using updated displacement u_MD\n        du_dx_MD = grad_u(u_MD, dx)\n        lap_c_MD = laplacian_c_neumann(c_MD_prev, dx, D, J_in)\n        c_MD = c_MD_prev + dt * (D * lap_c_MD - D * chi * kf * du_dx_MD)\n\n        # Compute strain and stress; stress uses c_MD at time n (mechanical substep input)\n        strain_MD = grad_u(u_MD, dx)\n        sigma_MD = E * strain_MD + eta * (strain_MD - strain_prev_MD) / dt - E * alpha * c_MD_prev\n        # Store current strain for next viscous update\n        strain_prev_MD = strain_MD.copy()\n\n        # SOC and stress peak\n        soc_MD = trapezoid_integral(c_MD, dx)\n        stresspeak_MD = float(np.max(np.abs(sigma_MD)))\n        soc_series_MD.append(soc_MD)\n        stresspeak_series_MD.append(stresspeak_MD)\n\n    # Monotonicity checks\n    soc_DM_monotone = is_nondecreasing(soc_series_DM)\n    soc_MD_monotone = is_nondecreasing(soc_series_MD)\n    stress_DM_monotone = is_nondecreasing(stresspeak_series_DM)\n    stress_MD_monotone = is_nondecreasing(stresspeak_series_MD)\n\n    return soc_DM_monotone, soc_MD_monotone, stress_DM_monotone, stress_MD_monotone\n\ndef solve():\n    # Define test cases from the problem statement\n    test_cases = [\n        # (N, L, D, alpha, E, eta, kf, chi, J_in, dt, Nt)\n        (50, 1.0, 0.01, 0.1, 1.0, 0.05, 5.0, 0.5, 1.0, 5e-4, 200),\n        (50, 1.0, 0.05, 0.1, 1.0, 0.2, 10.0, 1.0, 2.0, 2e-3, 200),\n        (50, 1.0, 0.02, 0.1, 1.0, 0.1, 5.0, 0.0, 1.0, 1e-3, 200),\n    ]\n\n    results_str_items = []\n    for case in test_cases:\n        socDM, socMD, stressDM, stressMD = run_case(*case)\n        # Build a compact string representation without spaces\n        case_str = f\"[{str(socDM)},{str(socMD)},{str(stressDM)},{str(stressMD)}]\"\n        results_str_items.append(case_str)\n\n    print(f\"[{','.join(results_str_items)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having established that operator ordering matters, we now explore an advanced strategy to actively manage splitting error. This practice challenges you to implement an adaptive splitting scheme that dynamically chooses the more accurate operator ordering at each time step. The decision is based on a heuristic that estimates the local commutator error, effectively using the error's theoretical source to guide the simulation and enhance its accuracy, demonstrating a sophisticated approach to building intelligent numerical algorithms .",
            "id": "3427843",
            "problem": "Consider the one-dimensional periodic initial value problem on the spatial interval $[0,1]$,\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) \\;=\\; \\nu\\,\\partial_{xx} u(x,t) \\;+\\; \\kappa\\,(u(x,t) - u(x,t)^3),\n$$\nwith periodic boundary conditions and the smooth initial data\n$$\nu(x,0) = \\sin(2\\pi x) + 0.1\\cos(4\\pi x).\n$$\nDefine two operators on the state $u$:\n$$\nA(u) = -a\\,\\partial_x u,\\qquad B(u) = \\nu\\,\\partial_{xx} u + \\kappa\\,(u - u^3).\n$$\nThe combined evolution is $\\partial_t u = A(u) + B(u)$. Let the domain be discretized with $N$ equispaced points and periodic boundary conditions. Use the Fast Fourier Transform (FFT) for differentiations (Fast Fourier Transform (FFT): a standard method to compute discrete Fourier transforms efficiently), with wavenumbers $k_j = 2\\pi j$ for integer indices consistent with the discrete Fourier grid.\n\nYou will compare three splitting schemes advancing $u^n \\mapsto u^{n+1}$ over a time step $\\Delta t$:\n- Fixed-order $AB$ Lie splitting: apply the $A$-flow over $\\Delta t$ followed by the $B$-flow over $\\Delta t$.\n- Fixed-order $BA$ Lie splitting: apply the $B$-flow over $\\Delta t$ followed by the $A$-flow over $\\Delta t$.\n- Adaptive ordering per step: choose between $AB$ and $BA$ based on an estimator of the commutator norm $\\|[A,B]\\|$, where the commutator of vector fields is defined by $[A,B](u) = \\mathrm{D}A(u)\\cdot B(u) - \\mathrm{D}B(u)\\cdot A(u)$, with $\\mathrm{D}$ denoting the Fréchet derivative.\n\nFor the $A$-flow, use the exact periodic shift\n$$\nu(x,t+\\Delta t) = u(x - a\\Delta t,t),\n$$\nimplemented spectrally by multiplying Fourier modes by $\\exp(-\\mathrm{i}k_j a \\Delta t)$. For the $B$-flow, integrate diffusion exactly spectrally (multiplying Fourier modes by $\\exp(-\\nu k_j^2 \\Delta t)$), and integrate the reaction $\\partial_t u = \\kappa(u - u^3)$ at each grid point by classical fourth-order Runge–Kutta (Runge–Kutta (RK): a family of explicit multi-stage time-stepping schemes) over $\\Delta t$.\n\nDefine the commutator estimator at a state $u$ by directional finite differences with a small parameter $\\varepsilon>0$,\n$$\n\\widehat{[A,B]}(u) \\;=\\; \\frac{A\\big(u + \\varepsilon B(u)\\big) - A(u)}{\\varepsilon} \\;-\\; \\frac{B\\big(u + \\varepsilon A(u)\\big) - B(u)}{\\varepsilon}.\n$$\nForm the drift vector $D(u) = A(u) + B(u)$ and compute the scalar\n$$\ns(u) = \\langle \\widehat{[A,B]}(u),\\, D(u) \\rangle,\n$$\nwhere the inner product is the discrete $L^2$ inner product over the grid. The adaptive rule is:\n- If $s(u) > 0$, choose $BA$ for the current step.\n- If $s(u) \\le 0$, choose $AB$ for the current step.\n\nThis rule is motivated by the Baker–Campbell–Hausdorff (BCH) expansion (Baker–Campbell–Hausdorff (BCH): a series expressing the logarithm of the product of exponentials of operators), which shows that the leading local error of Lie splitting is proportional to $\\pm \\frac{1}{2}\\Delta t^2 [A,B](u)$. Projecting onto $D(u)$ selects the sign to oppose the dominant drift direction.\n\nFor each parameter regime, compare the three schemes against a reference solution computed by second-order Strang splitting with a smaller time step $\\Delta t_{\\mathrm{ref}} = \\Delta t/4$:\n$$\nu \\leftarrow \\text{A-flow over } \\frac{\\Delta t_{\\mathrm{ref}}}{2},\\quad\nu \\leftarrow \\text{B-flow over } \\Delta t_{\\mathrm{ref}},\\quad\nu \\leftarrow \\text{A-flow over } \\frac{\\Delta t_{\\mathrm{ref}}}{2},\n$$\nrepeated until the final time $T$.\n\nUse the discrete $L^2$ error norm at time $T$,\n$$\nE = \\left(\\frac{1}{N}\\sum_{j=0}^{N-1} \\big(u_j^{\\mathrm{scheme}}(T) - u_j^{\\mathrm{ref}}(T)\\big)^2\\right)^{1/2}.\n$$\n\nImplement the program with the following fixed discretization and test suite:\n- Grid: $N=256$ points over $[0,1]$ with periodic boundary conditions.\n- Initial condition: $u(x,0)=\\sin(2\\pi x)+0.1\\cos(4\\pi x)$.\n- Commutator estimator parameter: $\\varepsilon = 10^{-3}$ (dimensionless).\n- Test suite parameter tuples $(a,\\nu,\\kappa,\\Delta t,T)$:\n  1. $(1.0,\\,10^{-3},\\,0.5,\\,8\\times 10^{-4},\\,0.1)$, an advection-dominated regime.\n  2. $(0.1,\\,10^{-1},\\,0.2,\\,8\\times 10^{-4},\\,0.1)$, a diffusion-dominated regime.\n  3. $(0.05,\\,5\\times 10^{-3},\\,5.0,\\,2\\times 10^{-4},\\,0.1)$, a reaction-dominated regime.\n\nFor each test case, compute the three errors $E_{AB}$, $E_{BA}$, and $E_{\\mathrm{ADAPT}}$ against the reference. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order\n$$\n[E_{AB}^{(1)},E_{BA}^{(1)},E_{\\mathrm{ADAPT}}^{(1)},E_{AB}^{(2)},E_{BA}^{(2)},E_{\\mathrm{ADAPT}}^{(2)},E_{AB}^{(3)},E_{BA}^{(3)},E_{\\mathrm{ADAPT}}^{(3)}],\n$$\nwhere superscripts indicate the test case index. Express each entry as a decimal float.",
            "solution": "The problem presented is valid. It is a well-defined computational task in the field of numerical analysis for partial differential equations (PDEs), grounded in established scientific and mathematical principles. All necessary parameters, equations, and methods are provided, allowing for a unique and verifiable solution.\n\nThe problem requires solving the one-dimensional advection-diffusion-reaction equation:\n$$\n\\partial_t u = -a\\,\\partial_x u + \\nu\\,\\partial_{xx} u + \\kappa\\,(u - u^3)\n$$\non a periodic domain $x \\in [0,1]$. This equation can be split into two parts, represented by operators $A(u) = -a\\,\\partial_x u$ (advection) and $B(u) = \\nu\\,\\partial_{xx} u + \\kappa\\,(u - u^3)$ (diffusion-reaction). The task is to compare the accuracy of three first-order operator splitting schemes: Lie $AB$, Lie $BA$, and an adaptive scheme that chooses between $AB$ and $BA$ at each time step.\n\n### 1. Spatial Discretization and Spectral Operators\n\nThe spatial domain $[0,1]$ is discretized using $N$ equispaced points $x_j = j/N$ for $j=0, \\dots, N-1$. A function $u(x,t)$ is represented by its values $u_j(t)$ at these grid points. We use a spectral method based on the Fast Fourier Transform (FFT) for spatial differentiation, which is highly accurate for smooth, periodic functions.\n\nLet $\\hat{u}(k,t) = \\mathcal{F}\\{u(x,t)\\}$ be the discrete Fourier transform of the grid function $u(x,t)$. The derivatives are computed in Fourier space:\n$$\n\\mathcal{F}\\{\\partial_x u\\} = (\\mathrm{i}k)\\,\\hat{u}(k)\n$$\n$$\n\\mathcal{F}\\{\\partial_{xx} u\\} = (\\mathrm{i}k)^2\\,\\hat{u}(k) = -k^2\\,\\hat{u}(k)\n$$\nwhere $k$ are the discrete wavenumbers. For a domain of length $L=1$ with $N$ points, the wavenumbers are given by $k_j = 2\\pi f_j$, where $f_j$ are the frequencies provided by standard FFT libraries (e.g., `numpy.fft.fftfreq`). The operators $A(u)$ and the diffusive part of $B(u)$ are thus implemented by transforming to Fourier space, multiplying by the appropriate spectral symbol ($\\mathrm{i}k$ or $-k^2$), and transforming back to physical space.\n\n### 2. Operator Flows\n\nThe overall evolution $\\partial_t u = A(u) + B(u)$ is approximated by sequentially applying the evolution (flow) corresponding to each operator for a time step $\\Delta t$.\n\n**A-flow (Advection):** The equation $\\partial_t u = -a\\,\\partial_x u$ has the exact solution $u(x, t+\\Delta t) = u(x - a\\Delta t, t)$. This is a pure translation. In Fourier space, a shift in physical space corresponds to a phase multiplication:\n$$\n\\hat{u}(k, t+\\Delta t) = e^{-\\mathrm{i}ka\\Delta t} \\hat{u}(k,t).\n$$\nThe flow $\\Phi_A^{\\Delta t}(u)$ is implemented by FFT, multiplication by the complex exponential factor $e^{-\\mathrm{i}ka\\Delta t}$, and inverse FFT (IFFT).\n\n**B-flow (Diffusion-Reaction):** The operator $B(u) = \\nu\\,\\partial_{xx} u + \\kappa\\,(u - u^3)$ consists of a linear diffusion term and a nonlinear reaction term. We further split this operator. The problem specifies integrating the diffusion part exactly in Fourier space and the reaction part using fourth-order Runge-Kutta (RK4). This implies a splitting of the B-flow itself. We adopt a first-order Lie splitting: first apply the diffusion flow, then the reaction flow.\n\n1.  **Diffusion Flow:** The equation $\\partial_t u = \\nu\\,\\partial_{xx} u$ is solved exactly in Fourier space:\n    $$\n    \\hat{u}(k, t+\\Delta t) = e^{-\\nu k^2 \\Delta t} \\hat{u}(k,t).\n    $$\n    This is implemented by FFT, multiplication by the real exponential factor $e^{-\\nu k^2 \\Delta t}$, and IFFT.\n\n2.  **Reaction Flow:** The system of ordinary differential equations (ODEs) $\\frac{du_j}{dt} = \\kappa(u_j - u_j^3)$ is solved for each grid point $u_j$. We apply one step of the classical RK4 method with step size $\\Delta t$. For an ODE $y' = f(y)$, the formula is:\n    $$\n    k_1 = \\Delta t \\cdot f(y_n) \\\\\n    k_2 = \\Delta t \\cdot f(y_n + k_1/2) \\\\\n    k_3 = \\Delta t \\cdot f(y_n + k_2/2) \\\\\n    k_4 = \\Delta t \\cdot f(y_n + k_3) \\\\\n    y_{n+1} = y_n + (k_1 + 2k_2 + 2k_3 + k_4)/6\n    $$\n    Here, $f(u) = \\kappa(u - u^3)$, and the operations are performed element-wise on the vector of grid values.\n\nThe combined B-flow, $\\Phi_B^{\\Delta t}$, is the composition of the diffusion flow followed by the reaction flow.\n\n### 3. Splitting Schemes\n\nWe compare three schemes for advancing the solution from $u^n$ at time $t_n$ to $u^{n+1}$ at $t_n + \\Delta t$:\n-   **Lie $AB$ splitting:** $u^{n+1} = \\Phi_B^{\\Delta t}(\\Phi_A^{\\Delta t}(u^n))$.\n-   **Lie $BA$ splitting:** $u^{n+1} = \\Phi_A^{\\Delta t}(\\Phi_B^{\\Delta t}(u^n))$.\n-   **Adaptive splitting:** Choose either $AB$ or $BA$ based on a local error indicator.\n\n### 4. Adaptive Splitting Logic\n\nThe choice of ordering in the adaptive scheme is based on an estimate of the operator commutator $[A,B](u) = \\mathrm{D}A(u)\\cdot B(u) - \\mathrm{D}B(u)\\cdot A(u)$, where $\\mathrm{D}$ is the Fréchet derivative. The leading term of the local error for Lie splitting is proportional to this commutator. The idea is to choose the ordering that makes the error term \"oppose\" the direction of the solution's drift, $D(u) = A(u)+B(u)$, aiming to reduce the overall step size and thus the error.\n\nThe commutator is approximated using a finite difference in operator space:\n$$\n\\widehat{[A,B]}(u) = \\frac{A\\big(u + \\varepsilon B(u)\\big) - A(u)}{\\varepsilon} - \\frac{B\\big(u + \\varepsilon A(u)\\big) - B(u)}{\\varepsilon}\n$$\nwith a small parameter $\\varepsilon = 10^{-3}$. Note that computing this requires functions that evaluate the operators $A(u)$ and $B(u)$ themselves (i.e., the right-hand sides of the PDE), not their time-evolution flows.\n\nThe decision is based on the sign of the scalar quantity $s(u) = \\langle \\widehat{[A,B]}(u), D(u) \\rangle$, where the inner product is the discrete $L^2$ inner product $\\langle v, w \\rangle = \\frac{1}{N}\\sum_{j=0}^{N-1} v_j w_j$.\n-   If $s(u) > 0$, the BA scheme ($u^{n+1} = \\Phi_A^{\\Delta t}(\\Phi_B^{\\Delta t}(u^n))$) is chosen.\n-   If $s(u) \\le 0$, the AB scheme ($u^{n+1} = \\Phi_B^{\\Delta t}(\\Phi_A^{\\Delta t}(u^n))$) is chosen.\n\n### 5. Reference Solution and Error Calculation\n\nTo assess the accuracy of these first-order schemes, a more accurate reference solution $u^{\\mathrm{ref}}$ is computed using second-order Strang splitting with a smaller time step $\\Delta t_{\\mathrm{ref}} = \\Delta t/4$. A single Strang step is:\n$$\nu \\leftarrow \\Phi_A^{\\Delta t_{\\mathrm{ref}}/2} \\circ \\Phi_B^{\\Delta t_{\\mathrm{ref}}} \\circ \\Phi_A^{\\Delta t_{\\mathrm{ref}}/2} (u)\n$$\nThis is repeated $T/\\Delta t_{\\mathrm{ref}}$ times to reach the final time $T$. The error of each scheme is then measured against this reference solution using the discrete $L^2$ norm:\n$$\nE = \\sqrt{\\frac{1}{N}\\sum_{j=0}^{N-1} \\left(u_j^{\\mathrm{scheme}}(T) - u_j^{\\mathrm{ref}}(T)\\right)^2}\n$$\n\nThe procedure is executed for three different parameter sets, each highlighting a different physical regime (advection-, diffusion-, or reaction-dominated). The errors $E_{AB}$, $E_{BA}$, and $E_{\\mathrm{ADAPT}}$ are computed for each case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection-diffusion-reaction problem using three\n    different operator splitting schemes and compares their errors.\n    \"\"\"\n    \n    # -- Fixed parameters --\n    N = 256\n    EPSILON = 1e-3\n    x = np.linspace(0, 1, N, endpoint=False)\n    k = 2 * np.pi * np.fft.fftfreq(N, d=1.0/N)\n    u0 = np.sin(2 * np.pi * x) + 0.1 * np.cos(4 * np.pi * x)\n\n    # -- Operators and Flows --\n\n    # Operator A: A(u) = -a * d_x u\n    def op_A(u, a, k):\n        u_hat = np.fft.fft(u)\n        du_dx_hat = 1j * k * u_hat\n        du_dx = np.fft.ifft(du_dx_hat).real\n        return -a * du_dx\n\n    # Operator B: B(u) = nu * d_xx u + kappa * (u - u^3)\n    def op_B(u, nu, kappa, k):\n        u_hat = np.fft.fft(u)\n        d2u_dx2_hat = -(k**2) * u_hat\n        d2u_dx2 = np.fft.ifft(d2u_dx2_hat).real\n        reaction = kappa * (u - u**3)\n        return nu * d2u_dx2 + reaction\n\n    # Flow for A: Exact shift in Fourier space\n    def flow_A(u, dt, a, k):\n        u_hat = np.fft.fft(u)\n        u_hat_new = u_hat * np.exp(-1j * k * a * dt)\n        return np.fft.ifft(u_hat_new).real\n\n    # RK4 step for reaction term d_t u = kappa * (u - u^3)\n    def rk4_step(u, dt, kappa):\n        def f(y):\n            return kappa * (y - y**3)\n        \n        k1 = dt * f(u)\n        k2 = dt * f(u + 0.5 * k1)\n        k3 = dt * f(u + 0.5 * k2)\n        k4 = dt * f(u + k3)\n        return u + (k1 + 2*k2 + 2*k3 + k4) / 6.0\n\n    # Flow for B: Lie split of diffusion (exact) and reaction (RK4)\n    def flow_B(u, dt, nu, kappa, k):\n        # 1. Diffusion part (exact in Fourier space)\n        u_hat = np.fft.fft(u)\n        u_hat_diff = u_hat * np.exp(-nu * k**2 * dt)\n        u_after_diff = np.fft.ifft(u_hat_diff).real\n        \n        # 2. Reaction part (RK4 in physical space)\n        u_final = rk4_step(u_after_diff, dt, kappa)\n        return u_final\n\n    # -- Main Loop for Test Cases --\n    test_cases = [\n        # (a, nu, kappa, dt, T)\n        (1.0, 1e-3, 0.5, 8e-4, 0.1),  # Advection-dominated\n        (0.1, 1e-1, 0.2, 8e-4, 0.1),  # Diffusion-dominated\n        (0.05, 5e-3, 5.0, 2e-4, 0.1), # Reaction-dominated\n    ]\n\n    all_results = []\n    \n    for a, nu, kappa, dt, T in test_cases:\n        \n        # -- 1. Compute Reference Solution (Strang splitting) --\n        dt_ref = dt / 4.0\n        num_steps_ref = int(round(T / dt_ref))\n        u_ref = np.copy(u0)\n\n        for _ in range(num_steps_ref):\n            u_temp = flow_A(u_ref, dt_ref / 2.0, a, k)\n            u_temp = flow_B(u_temp, dt_ref, nu, kappa, k)\n            u_ref = flow_A(u_temp, dt_ref / 2.0, a, k)\n\n        num_steps = int(round(T / dt))\n\n        # -- 2. Compute Lie AB Solution --\n        u_ab = np.copy(u0)\n        for _ in range(num_steps):\n            u_temp = flow_A(u_ab, dt, a, k)\n            u_ab = flow_B(u_temp, dt, nu, kappa, k)\n\n        # -- 3. Compute Lie BA Solution --\n        u_ba = np.copy(u0)\n        for _ in range(num_steps):\n            u_temp = flow_B(u_ba, dt, nu, kappa, k)\n            u_ba = flow_A(u_temp, dt, a, k)\n            \n        # -- 4. Compute Adaptive Solution --\n        u_adapt = np.copy(u0)\n        for _ in range(num_steps):\n            A_u = op_A(u_adapt, a, k)\n            B_u = op_B(u_adapt, nu, kappa, k)\n            \n            # Commutator estimate: (A(u+eB)-A(u))/e - (B(u+eA)-B(u))/e\n            term1 = (op_A(u_adapt + EPSILON * B_u, a, k) - A_u) / EPSILON\n            term2 = (op_B(u_adapt + EPSILON * A_u, nu, kappa, k) - B_u) / EPSILON\n            commutator_est = term1 - term2\n            \n            drift = A_u + B_u\n            \n            # s(u) = <[A,B], D>\n            s = np.mean(commutator_est * drift)\n            \n            if s > 0: # Choose BA\n                u_temp = flow_B(u_adapt, dt, nu, kappa, k)\n                u_adapt = flow_A(u_temp, dt, a, k)\n            else: # Choose AB\n                u_temp = flow_A(u_adapt, dt, a, k)\n                u_adapt = flow_B(u_temp, dt, nu, kappa, k)\n                \n        # -- 5. Calculate Errors --\n        def L2_error(u, u_ref, N):\n            return np.sqrt(np.mean((u - u_ref)**2))\n\n        error_ab = L2_error(u_ab, u_ref, N)\n        error_ba = L2_error(u_ba, u_ref, N)\n        error_adapt = L2_error(u_adapt, u_ref, N)\n        \n        all_results.extend([error_ab, error_ba, error_adapt])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}