{
    "hands_on_practices": [
        {
            "introduction": "第一个练习将为您提供实现交替方向隐式（ADI）方法的基础经验。您将应用 Peaceman-Rachford 格式来求解经典的二维热方程，这是计算科学中的一个基准问题。通过这个实践 ，您将巩固对 ADI 方法如何高效地将一个复杂的二维问题分解为一系列易于处理的一维三对角系统的理解。",
            "id": "2446320",
            "problem": "考虑单位正方形上的二维热方程，其具有齐次狄利克雷边界条件和可分离的解析解。设 $u(x,y,t)$ 满足\n$$\n\\frac{\\partial u}{\\partial t}(x,y,t) \\;=\\; \\kappa \\left( \\frac{\\partial^2 u}{\\partial x^2}(x,y,t) + \\frac{\\partial^2 u}{\\partial y^2}(x,y,t) \\right), \\quad (x,y)\\in (0,1)\\times(0,1), \\; t\\in (0,T],\n$$\n其中，对于边界 $\\partial([0,1]\\times[0,1])$ 上的 $(x,y)$ 和 $t\\ge 0$，$u(x,y,t) = 0$。初始条件为\n$$\nu(x,y,0) \\;=\\; \\sin(m\\pi x)\\,\\sin(n\\pi y),\n$$\n其精确解为\n$$\nu(x,y,t) \\;=\\; \\sin(m\\pi x)\\,\\sin(n\\pi y)\\,\\exp\\!\\left( -\\,\\kappa \\pi^2 (m^2+n^2)\\, t \\right).\n$$\n在 $x$ 和 $y$ 方向上分别使用 $N_x$ 和 $N_y$ 个内部点对空间域进行离散化。令 $h_x = 1/(N_x+1)$ 和 $h_y = 1/(N_y+1)$，内部网格点为 $(x_i,y_j) = (i\\,h_x, j\\,h_y)$，其中 $i\\in\\{1,\\dots,N_x\\}$ 且 $j\\in\\{1,\\dots,N_y\\}$。使用时间步长 $\\Delta t$ 对时间进行离散化，使得 $N_t = T/\\Delta t$ 为整数，且 $t^n = n\\,\\Delta t$，其中 $n\\in\\{0,1,\\dots,N_t\\}$。\n\n使用 Peaceman–Rachford 交替方向隐式 (ADI) 格式，在每个时间步通过两步更新将解从 $t^n$推进到 $t^{n+1}$。定义内部网格函数 $U^n_{i,j} \\approx u(x_i,y_j,t^n)$。设 $\\lambda_x = \\kappa \\Delta t /(2 h_x^2)$ 和 $\\lambda_y = \\kappa \\Delta t /(2 h_y^2)$，则两个半步为：\n$$\n\\text{第1阶段:}\\quad\n\\big(I - \\lambda_x A_x\\big)\\, U^{\\star} \\;=\\; \\big(I + \\lambda_y A_y\\big)\\, U^n,\n$$\n$$\n\\text{第2阶段:}\\quad\n\\big(I - \\lambda_y A_y\\big)\\, U^{n+1} \\;=\\; \\big(I + \\lambda_x A_x\\big)\\, U^{\\star},\n$$\n其中 $A_x$ 和 $A_y$ 是作用于内部点的标准二阶差分算子，分别沿 $x$ 和 $y$ 方向，并在内部区域之外使用齐次狄利克雷边界值。具体来说，对于内部索引，\n$$\n(A_x U)_{i,j} \\;=\\; U_{i-1,j} - 2U_{i,j} + U_{i+1,j},\\qquad\n(A_y U)_{i,j} \\;=\\; U_{i,j-1} - 2U_{i,j} + U_{i,j+1},\n$$\n这里的约定是，任何索引在内部区域之外的 $U$ 值均使用边界值 $0$。\n\n在内部网格上实现此格式，并精确推进 $N_t$ 个完整步长至时间 $T$。对于下方的每个测试用例，计算在时间 $T$ 时的相对离散 $L^2$ 误差，\n$$\n\\varepsilon \\;=\\; \\frac{\\left( \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\big(U^{N_t}_{i,j} - u(x_i,y_j,T)\\big)^2\\, h_x h_y \\right)^{1/2}}{\\left( \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\big(u(x_i,y_j,T)\\big)^2\\, h_x h_y \\right)^{1/2}},\n$$\n该误差是无量纲的。\n\n测试套件：\n- 案例1（一般情况）：$\\kappa = 1$，$m = 1$，$n = 1$，$N_x = 20$，$N_y = 20$，$\\Delta t = 10^{-4}$，$T = 10^{-2}$。\n- 案例2（各向异性空间频率和网格）：$\\kappa = 1$，$m = 2$，$n = 1$，$N_x = 12$，$N_y = 8$，$\\Delta t = 5\\times 10^{-4}$，$T = 2\\times 10^{-2}$。\n- 案例3（粗网格和大时间步长）：$\\kappa = 1$，$m = 1$，$n = 1$，$N_x = 2$，$N_y = 2$，$\\Delta t = 10^{-1}$，$T = 10^{-1}$。\n- 案例4（细网格和小时间步长）：$\\kappa = 1$，$m = 3$，$n = 2$，$N_x = 50$，$N_y = 50$，$\\Delta t = 5\\times 10^{-5}$，$T = 5\\times 10^{-3}$。\n\n所有量均为无量纲。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），列表中的每个 $r_k$ 是按上述顺序为相应测试用例计算的相对离散 $L^2$ 误差 $\\varepsilon$。程序必须完全自包含，并且无需任何用户输入或外部文件即可生成这四个数字。",
            "solution": "问题陈述已经过验证，并被认定为有效。它具有科学依据，是适定的、客观的且内部一致的。它提出了一个计算科学中的标准问题：使用 Peaceman-Rachford 交替方向隐式 (ADI) 格式对二维热方程进行数值求解。唯一数值解所需的所有参数和定义均已提供，任务是直接应用已建立的数值方法。\n\n目标是在单位正方形域 $(x,y)\\in (0,1)\\times(0,1)$上求解具有齐次狄利克雷边界条件的二维热方程\n$$\n\\frac{\\partial u}{\\partial t} \\;=\\; \\kappa \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\right)\n$$\n所提供的初始条件 $u(x,y,0) = \\sin(m\\pi x)\\sin(n\\pi y)$ 对应一个已知的解析解，该解析解可作为验证数值实现准确性的基准。\n\nPeaceman-Rachford ADI 方法是一种有限差分格式，它在空间和时间上都具有二阶精度，并且对于热方程是无条件稳定的。其主要优点在于其计算效率。一个全隐式的二维格式需要求解一个具有块三对角结构的大型稀疏线性系统。ADI 方法通过将时间步长 $\\Delta t$ 分成两个半步来规避此问题。每个半步仅在一个空间方向上是隐式的，这使得方程组仅为三对角系统。\n\n该方法通过一个中间步 $U^{\\star}$ 将网格上 $u(x,y,t^n)$ 的近似离散解 $U^n$ 推进到 $U^{n+1}$。网格由 $N_x \\times N_y$ 个内部点定义，间距为 $h_x = 1/(N_x+1)$ 和 $h_y = 1/(N_y+1)$。\n\nADI 格式的两个阶段是：\n\n第1阶段：在 $x$ 方向上隐式。\n$$\n\\big(I - \\lambda_x A_x\\big)\\, U^{\\star} \\;=\\; \\big(I + \\lambda_y A_y\\big)\\, U^n\n$$\n这里，$\\lambda_x = \\kappa \\Delta t /(2 h_x^2)$ 且 $\\lambda_y = \\kappa \\Delta t /(2 h_y^2)$。算子 $A_x$ 是 $x$ 方向上的一维二阶差分算子，$A_y$ 是 $y$ 方向上对应的算子。对于由 $j \\in \\{1, \\dots, N_y\\}$ 索引的每个网格行，此方程构成一个关于未知数 $U^{\\star}_{1,j}, \\dots, U^{\\star}_{N_x,j}$ 的独立的包含 $N_x$ 个线性方程的三对角系统。对于给定的行 $j$，该系统为：\n$$\n-\\lambda_x U^{\\star}_{i-1,j} + (1 + 2\\lambda_x) U^{\\star}_{i,j} - \\lambda_x U^{\\star}_{i+1,j} \\;=\\; d_{i,j}, \\quad i \\in \\{1, \\dots, N_x\\}\n$$\n其中 $d = (I + \\lambda_y A_y)U^n$ 是右端项，由时间 $t^n$ 的解可知。边界条件意味着 $U^{\\star}_{0,j} = U^{\\star}_{N_x+1,j} = 0$。\n\n第2阶段：在 $y$ 方向上隐式。\n$$\n\\big(I - \\lambda_y A_y\\big)\\, U^{n+1} \\;=\\; \\big(I + \\lambda_x A_x\\big)\\, U^{\\star}\n$$\n在第一阶段之后，求解此方程以得到 $U^{n+1}$。对于由 $i \\in \\{1, \\dots, N_x\\}$ 索引的每个网格列，此方程构成一个关于未知数 $U^{n+1}_{i,1}, \\dots, U^{n+1}_{i,N_y}$ 的独立的包含 $N_y$ 个线性方程的三对角系统。对于给定的列 $i$，该系统为：\n$$\n-\\lambda_y U^{n+1}_{i,j-1} + (1 + 2\\lambda_y) U^{n+1}_{i,j} - \\lambda_y U^{n+1}_{i,j+1} \\;=\\; e_{i,j}, \\quad j \\in \\{1, \\dots, N_y\\}\n$$\n其中 $e = (I + \\lambda_x A_x)U^{\\star}$ 是右端项，由中间解 $U^{\\star}$ 可知。边界条件意味着 $U^{n+1}_{i,0} = U^{n+1}_{i,N_y+1} = 0$。\n\n实现策略如下：\n1.  初始化解。一个大小为 $N_y \\times N_x$ 的二维数组 $U$ 被初始化为在内部网格点 $(x_i, y_j)$ 处计算的初始条件 $u(x,y,0) = \\sin(m\\pi x)\\sin(n\\pi y)$ 的值。\n2.  构造三对角系统矩阵。更准确地说，我们构造数值求解器所需的矩阵 $(I-\\lambda_x A_x)$ 和 $(I-\\lambda_y A_y)$ 的带状表示。\n3.  迭代 $N_t = T/\\Delta t$ 个时间步。在每一步中：\n    a. 计算第1阶段的右端项 $RHS_1 = (I + \\lambda_y A_y)U^n$。这通过对 $U^n$ 进行向量化数组操作来实现，同时考虑零狄利克雷边界条件。\n    b. 求解 $N_y$ 个关于 $U^{\\star}$ 各行的三对角系统。这可以通过对 $RHS_1$ 矩阵进行转置，然后向量化地调用带状线性系统求解器（例如 `scipy.linalg.solve_banded`）来高效完成。\n    c. 计算第2阶段的右端项 $RHS_2 = (I + \\lambda_x A_x)U^{\\star}$，同样通过对中间解 $U^{\\star}$ 进行向量化操作。\n    d. 求解 $N_x$ 个关于 $U^{n+1}$ 各列的三对角系统。这是将带状求解器直接应用于 $RHS_2$ 的各列。\n    e. 更新解：$U \\leftarrow U^{n+1}$。\n4.  在最后一个时间步之后，在相同的网格上计算精确解 $u(x,y,T)$。\n5.  计算相对离散 $L^2$ 误差 $\\varepsilon$。所提供的公式等价于误差矩阵和精确解矩阵的弗罗贝尼乌斯范数之比：\n    $$\n    \\varepsilon = \\frac{|| U^{N_t} - u(\\cdot, \\cdot, T) ||_F}{|| u(\\cdot, \\cdot, T) ||_F}\n    $$\n    其中 $||A||_F = \\left(\\sum_{i,j} |A_{ij}|^2\\right)^{1/2}$。这在计算上是直接的。\n\n此过程被系统地应用于问题陈述中指定的四个测试用例。最终输出包含为每个案例计算的误差 $\\varepsilon$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to solve the 2D heat equation for all test cases\n    using the Peaceman-Rachford ADI method and compute the errors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (kappa, m, n, Nx, Ny, dt, T)\n        (1.0, 1, 1, 20, 20, 1e-4, 1e-2),\n        (1.0, 2, 1, 12, 8, 5e-4, 2e-2),\n        (1.0, 1, 1, 2, 2, 1e-1, 1e-1),\n        (1.0, 3, 2, 50, 50, 5e-5, 5e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_one_case(case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_one_case(params):\n    \"\"\"\n    Solves the 2D heat equation for a single set of parameters.\n    \"\"\"\n    kappa, m, n, Nx, Ny, dt, T = params\n\n    # 1. Calculate derived parameters\n    hx = 1.0 / (Nx + 1)\n    hy = 1.0 / (Ny + 1)\n    Nt = round(T / dt)  # Problem guarantees this is integer\n\n    lx = kappa * dt / (2.0 * hx**2)\n    ly = kappa * dt / (2.0 * hy**2)\n\n    # 2. Create spatial grid\n    x = np.linspace(hx, 1.0 - hx, Nx)\n    y = np.linspace(hy, 1.0 - hy, Ny)\n    X, Y = np.meshgrid(x, y) # X has shape (Ny, Nx), Y has shape (Ny, Nx)\n\n    # 3. Set initial condition\n    U = np.sin(m * np.pi * X) * np.sin(n * np.pi * Y)\n\n    # 4. Construct banded matrices for the tridiagonal solvers\n    # Stage 1: systems in x-direction (size Nx)\n    ab_x = np.zeros((3, Nx))\n    ab_x[0, 1:] = -lx\n    ab_x[1, :] = 1.0 + 2.0 * lx\n    ab_x[2, :-1] = -lx\n\n    # Stage 2: systems in y-direction (size Ny)\n    ab_y = np.zeros((3, Ny))\n    ab_y[0, 1:] = -ly\n    ab_y[1, :] = 1.0 + 2.0 * ly\n    ab_y[2, :-1] = -ly\n\n    # 5. Time-stepping loop\n    for _ in range(Nt):\n        # --- Stage 1: (I - lx*Ax) U_star = (I + ly*Ay) U ---\n\n        # Calculate RHS_1 = (I + ly*Ay) * U\n        # Ay applied to columns of U, with homogeneous Dirichlet BCs\n        RHS1 = np.zeros_like(U)\n        if Ny > 1:\n            RHS1[1:-1, :] = U[1:-1, :] + ly * (U[0:-2, :] - 2.0 * U[1:-1, :] + U[2:, :])\n            RHS1[0, :] = U[0, :] + ly * (-2.0 * U[0, :] + U[1, :])      # j=0\n            RHS1[-1, :] = U[-1, :] + ly * (U[-2, :] - 2.0 * U[-1, :])  # j=Ny-1\n        else: # Ny == 1\n            RHS1[0, :] = U[0, :] + ly * (-2.0 * U[0, :])\n\n        # Solve for U_star (systems are along rows)\n        # We transpose RHS1 to feed rows as columns to solve_banded\n        U_star_T = solve_banded((1, 1), ab_x, RHS1.T, overwrite_ab=False, overwrite_b=False)\n        U_star = U_star_T.T\n\n        # --- Stage 2: (I - ly*Ay) U_np1 = (I + lx*Ax) U_star ---\n        \n        # Calculate RHS_2 = (I + lx*Ax) * U_star\n        # Ax applied to rows of U_star, with homogeneous Dirichlet BCs\n        RHS2 = np.zeros_like(U_star)\n        if Nx > 1:\n            RHS2[:, 1:-1] = U_star[:, 1:-1] + lx * (U_star[:, 0:-2] - 2.0 * U_star[:, 1:-1] + U_star[:, 2:])\n            RHS2[:, 0] = U_star[:, 0] + lx * (-2.0 * U_star[:, 0] + U_star[:, 1])    # i=0\n            RHS2[:, -1] = U_star[:, -1] + lx * (U_star[:, -2] - 2.0 * U_star[:, -1])  # i=Nx-1\n        else: # Nx == 1\n            RHS2[:, 0] = U_star[:, 0] + lx * (-2.0 * U_star[:, 0])\n\n        # Solve for U_np1 (systems are along columns)\n        U_np1 = solve_banded((1, 1), ab_y, RHS2, overwrite_ab=False, overwrite_b=False)\n        \n        # Update solution for next time step\n        U = U_np1\n\n    # 6. Compute exact solution at final time T\n    U_exact = np.sin(m * np.pi * X) * np.sin(n * np.pi * Y) * np.exp(-kappa * np.pi**2 * (m**2 + n**2) * T)\n\n    # 7. Compute relative discrete L2 error\n    # The term sqrt(hx*hy) cancels in numerator and denominator.\n    # So error is ratio of Frobenius norms.\n    norm_diff = np.linalg.norm(U - U_exact)\n    norm_exact = np.linalg.norm(U_exact)\n\n    if norm_exact == 0:\n        return 0.0 if norm_diff == 0 else np.inf\n\n    return norm_diff / norm_exact\n\nsolve()\n```"
        },
        {
            "introduction": "在实现了 ADI 方法之后，是时候理解它为何如此高效了。这个练习将从编程转向理论分析，指导您推导 Peaceman-Rachford 格式的局部截断误差的阶数。通过将 ADI 的推进算子与精确解算子进行比较 ，您将揭示该方法具有二阶精度的数学原理，这也是其强大功能的一个关键特性。",
            "id": "3128240",
            "problem": "考虑方形区域上具有周期性边界条件的二维扩散方程 $u_{t}=\\kappa\\,(u_{xx}+u_{yy})$，其中 $\\kappa>0$ 为常数。使用二阶中心差分在间距为 $h$ 的均匀网格上对空间进行离散化，得到一个线性常微分方程组 $\\dot{\\mathbf{u}}=(A_{h}+B_{h})\\,\\mathbf{u}$，其中 $A_{h}$ 和 $B_{h}$ 分别是沿 $x$ 和 $y$ 方向作用的标准一维离散二阶导数算子（按 $\\kappa$ 缩放），并通过张量积扩展到二维。在此具有周期性边界的网格上，假设 $A_{h}$ 和 $B_{h}$ 可交换。\n\n定义 Peaceman–Rachford 交替方向隐式 (ADI) 方法的一个步长为 $\\Delta t>0$ 的步骤，由以下线性求解对给出：\n$$(I-\\tfrac{\\Delta t}{2}A_{h})\\,\\mathbf{u}^{n+\\frac{1}{2}}=(I+\\tfrac{\\Delta t}{2}B_{h})\\,\\mathbf{u}^{n},\\qquad (I-\\tfrac{\\Delta t}{2}B_{h})\\,\\mathbf{u}^{n+1}=(I+\\tfrac{\\Delta t}{2}A_{h})\\,\\mathbf{u}^{n+\\frac{1}{2}},$$\n并令其单步传播算子为满足 $\\mathbf{u}^{n+1}=S(\\Delta t)\\,\\mathbf{u}^{n}$ 的线性算子 $S(\\Delta t)$。令未分裂的 Crank–Nicolson 传播算子为\n$$R_{\\mathrm{CN}}(\\Delta t)=\\bigl(I+\\tfrac{\\Delta t}{2}(A_{h}+B_{h})\\bigr)\\,\\bigl(I-\\tfrac{\\Delta t}{2}(A_{h}+B_{h})\\bigr)^{-1}。$$\n\n定义每个时间步的局部分裂误差算子为 $E_{\\mathrm{spl}}(\\Delta t)=S(\\Delta t)-R_{\\mathrm{CN}}(\\Delta t)$。从矩阵有理函数的基本级数展开出发，并且仅使用上述定义（不使用未经证明的快捷公式），在 $A_{h}$ 和 $B_{h}$ 可交换的假设下，确定当 $\\Delta t\\to 0$ 时，使得 $E_{\\mathrm{spl}}(\\Delta t)=\\mathcal{O}(\\Delta t^{p})$ 成立的最小整数 $p$。\n\n只需报告整数 $p$ 作为最终答案。不需要单位。",
            "solution": "用户希望确定 Peaceman-Rachford ADI 方法的局部分裂误差的阶。\n\n### 步骤 1：问题验证\n\n**1. 提取已知条件：**\n- 偏微分方程 (PDE): 方形区域上具有周期性边界条件的 $u_{t}=\\kappa\\,(u_{xx}+u_{yy})$，$\\kappa>0$。\n- 离散化: 使用二阶中心差分在间距为 $h$ 的均匀网格上进行空间离散化。\n- 半离散系统: $\\dot{\\mathbf{u}}=(A_{h}+B_{h})\\,\\mathbf{u}$。\n- 算子: $A_{h}$ 和 $B_{h}$ 是沿 $x$ 和 $y$ 方向的一维离散二阶导数算子（按 $\\kappa$ 缩放）。\n- 假设: $A_{h}$ 和 $B_{h}$ 可交换，即 $A_{h}B_{h} = B_{h}A_{h}$。\n- Peaceman-Rachford ADI 方法:\n  - $(I-\\tfrac{\\Delta t}{2}A_{h})\\,\\mathbf{u}^{n+\\frac{1}{2}}=(I+\\tfrac{\\Delta t}{2}B_{h})\\,\\mathbf{u}^{n}$\n  - $(I-\\tfrac{\\Delta t}{2}B_{h})\\,\\mathbf{u}^{n+1}=(I+\\tfrac{\\Delta t}{2}A_{h})\\,\\mathbf{u}^{n+\\frac{1}{2}}$\n- ADI 传播算子: $S(\\Delta t)$ 使得 $\\mathbf{u}^{n+1}=S(\\Delta t)\\,\\mathbf{u}^{n}$。\n- Crank-Nicolson 传播算子: $R_{\\mathrm{CN}}(\\Delta t)=\\bigl(I+\\tfrac{\\Delta t}{2}(A_{h}+B_{h})\\bigr)\\,\\bigl(I-\\tfrac{\\Delta t}{2}(A_{h}+B_{h})\\bigr)^{-1}$。\n- 局部分裂误差算子: $E_{\\mathrm{spl}}(\\Delta t)=S(\\Delta t)-R_{\\mathrm{CN}}(\\Delta t)$。\n- 目标: 求最小整数 $p$ 使得当 $\\Delta t\\to 0$ 时，$E_{\\mathrm{spl}}(\\Delta t)=\\mathcal{O}(\\Delta t^{p})$。\n- 约束: 使用基本级数展开和交换性假设。\n\n**2. 使用提取的已知条件进行验证：**\n- **科学性：** 该问题是对一个著名数值方法 (ADI) 应用于一个基本偏微分方程（扩散方程）的标准分析。所有概念在数值分析领域都是成熟的。\n- **适定性：** 该问题在数学上是适定的。它提供了所有必要的定义和关键的算子交换性假设，这使得可以推导出唯一解。\n- **客观性：** 语言正式、精确，没有主观或含糊的陈述。\n- 问题通过了所有有效性检查。它不是不健全、不完整、不一致或不适定的。\n\n**3. 结论与行动：**\n- 问题有效。将提供详细的解决方案。\n\n### 步骤 2：求解推导\n\n目标是找到最小的整数 $p$，使得局部分裂误差 $E_{\\mathrm{spl}}(\\Delta t) = S(\\Delta t) - R_{\\mathrm{CN}}(\\Delta t)$ 的阶为 $\\mathcal{O}(\\Delta t^p)$。\n\n首先，我们求出 ADI 传播算子 $S(\\Delta t)$ 的显式表达式。根据该方法的定义：\n$$ \\mathbf{u}^{n+\\frac{1}{2}} = \\left(I-\\frac{\\Delta t}{2}A_{h}\\right)^{-1} \\left(I+\\frac{\\Delta t}{2}B_{h}\\right) \\mathbf{u}^{n} $$\n$$ \\mathbf{u}^{n+1} = \\left(I-\\frac{\\Delta t}{2}B_{h}\\right)^{-1} \\left(I+\\frac{\\Delta t}{2}A_{h}\\right) \\mathbf{u}^{n+\\frac{1}{2}} $$\n将 $\\mathbf{u}^{n+\\frac{1}{2}}$ 的表达式代入第二个方程，得到 $\\mathbf{u}^{n+1} = S(\\Delta t) \\mathbf{u}^n$，其中传播算子 $S(\\Delta t)$ 为：\n$$ S(\\Delta t) = \\left(I-\\frac{\\Delta t}{2}B_{h}\\right)^{-1} \\left(I+\\frac{\\Delta t}{2}A_{h}\\right) \\left(I-\\frac{\\Delta t}{2}A_{h}\\right)^{-1} \\left(I+\\frac{\\Delta t}{2}B_{h}\\right) $$\n问题陈述 $A_h$ 和 $B_h$ 可交换。这意味着 $A_h$ 的任何良态函数都与 $B_h$ 的任何良态函数可交换。因此，我们可以重新排列 $S(\\Delta t)$ 表达式中的算子：\n$$ S(\\Delta t) = \\left[ \\left(I+\\frac{\\Delta t}{2}A_{h}\\right) \\left(I-\\frac{\\Delta t}{2}A_{h}\\right)^{-1} \\right] \\left[ \\left(I+\\frac{\\Delta t}{2}B_{h}\\right) \\left(I-\\frac{\\Delta t}{2}B_{h}\\right)^{-1} \\right] $$\n问题要求我们从基本级数展开开始。对于一个通用算子 $Z$，我们定义有理算子函数 $F(Z, \\Delta t) = \\left(I+\\frac{\\Delta t}{2}Z\\right) \\left(I-\\frac{\\Delta t}{2}Z\\right)^{-1}$。我们可以使用矩阵的几何级数 $(I-M)^{-1} = \\sum_{k=0}^{\\infty} M^k$ 来展开它，这在 $\\Delta t$ 很小，使得 $\\frac{\\Delta t}{2}Z$ 的谱半径小于 1 时是有效的。\n$$ F(Z, \\Delta t) = \\left(I+\\frac{\\Delta t}{2}Z\\right) \\sum_{k=0}^{\\infty} \\left(\\frac{\\Delta t}{2}Z\\right)^k $$\n展开这个和式：\n$$ F(Z, \\Delta t) = \\left(I+\\frac{\\Delta t}{2}Z\\right) \\left( I + \\frac{\\Delta t}{2}Z + \\left(\\frac{\\Delta t}{2}\\right)^2 Z^2 + \\left(\\frac{\\Delta t}{2}\\right)^3 Z^3 + \\mathcal{O}(\\Delta t^4) \\right) $$\n乘开各项：\n$$ F(Z, \\Delta t) = \\left( I + \\frac{\\Delta t}{2}Z + \\frac{\\Delta t^2}{4}Z^2 + \\frac{\\Delta t^3}{8}Z^3 \\right) + \\left( \\frac{\\Delta t}{2}Z + \\frac{\\Delta t^2}{4}Z^2 + \\frac{\\Delta t^3}{8}Z^3 \\right) + \\mathcal{O}(\\Delta t^4) $$\n$$ F(Z, \\Delta t) = I + \\Delta t Z + \\frac{\\Delta t^2}{2}Z^2 + \\frac{\\Delta t^3}{4}Z^3 + \\mathcal{O}(\\Delta t^4) $$\n使用这个展开式，ADI 传播算子 $S(\\Delta t)$ 可以写成两个这样的级数的乘积，$S(\\Delta t) = F(A_h, \\Delta t) F(B_h, \\Delta t)$：\n$$ S(\\Delta t) = \\left( I + \\Delta t A_h + \\frac{\\Delta t^2}{2}A_h^2 + \\frac{\\Delta t^3}{4}A_h^3 + \\dots \\right) \\left( I + \\Delta t B_h + \\frac{\\Delta t^2}{2}B_h^2 + \\frac{\\Delta t^3}{4}B_h^3 + \\dots \\right) $$\n由于 $A_h$ 和 $B_h$ 可交换，我们可以将这些级数相乘，并按 $\\Delta t$ 的幂次合并同类项：\n$$ S(\\Delta t) = I + \\Delta t(A_h+B_h) + \\left( \\frac{\\Delta t^2}{2}A_h^2 + \\Delta t^2 A_h B_h + \\frac{\\Delta t^2}{2}B_h^2 \\right) + \\left( \\frac{\\Delta t^3}{4}A_h^3 + \\frac{\\Delta t^3}{2}A_h B_h^2 + \\frac{\\Delta t^3}{2}A_h^2 B_h + \\frac{\\Delta t^3}{4}B_h^3 \\right) + \\mathcal{O}(\\Delta t^4) $$\n$$ S(\\Delta t) = I + \\Delta t(A_h+B_h) + \\frac{\\Delta t^2}{2}(A_h+B_h)^2 + \\frac{\\Delta t^3}{4}(A_h^3 + 2A_h^2 B_h + 2A_h B_h^2 + B_h^3) + \\mathcal{O}(\\Delta t^4) $$\n接下来，我们展开未分裂的 Crank-Nicolson 传播算子 $R_{\\mathrm{CN}}(\\Delta t)$。它具有与 $F(Z, \\Delta t)$ 相同的函数形式，但算子为 $Z = A_h+B_h$：\n$$ R_{\\mathrm{CN}}(\\Delta t) = F(A_h+B_h, \\Delta t) = I + \\Delta t(A_h+B_h) + \\frac{\\Delta t^2}{2}(A_h+B_h)^2 + \\frac{\\Delta t^3}{4}(A_h+B_h)^3 + \\mathcal{O}(\\Delta t^4) $$\n利用 $A_h$ 和 $B_h$ 的可交换性，我们可以展开三次项：\n$$ (A_h+B_h)^3 = A_h^3 + 3A_h^2 B_h + 3A_h B_h^2 + B_h^3 $$\n所以 $R_{\\mathrm{CN}}(\\Delta t)$ 的展开式为：\n$$ R_{\\mathrm{CN}}(\\Delta t) = I + \\Delta t(A_h+B_h) + \\frac{\\Delta t^2}{2}(A_h+B_h)^2 + \\frac{\\Delta t^3}{4}(A_h^3 + 3A_h^2 B_h + 3A_h B_h^2 + B_h^3) + \\mathcal{O}(\\Delta t^4) $$\n最后，我们计算局部分裂误差 $E_{\\mathrm{spl}}(\\Delta t) = S(\\Delta t) - R_{\\mathrm{CN}}(\\Delta t)$。我们减去这两个级数展开。$\\Delta t^0$, $\\Delta t^1$, 和 $\\Delta t^2$ 阶的项是相同的，因此相互抵消。首项误差来自于 $\\mathcal{O}(\\Delta t^3)$ 项的差：\n$$ E_{\\mathrm{spl}}(\\Delta t) = \\frac{\\Delta t^3}{4} \\left[ (A_h^3 + 2A_h^2 B_h + 2A_h B_h^2 + B_h^3) - (A_h^3 + 3A_h^2 B_h + 3A_h B_h^2 + B_h^3) \\right] + \\mathcal{O}(\\Delta t^4) $$\n$$ E_{\\mathrm{spl}}(\\Delta t) = \\frac{\\Delta t^3}{4} \\left[ (2-3)A_h^2 B_h + (2-3)A_h B_h^2 \\right] + \\mathcal{O}(\\Delta t^4) $$\n$$ E_{\\mathrm{spl}}(\\Delta t) = \\frac{\\Delta t^3}{4} \\left[ -A_h^2 B_h - A_h B_h^2 \\right] + \\mathcal{O}(\\Delta t^4) $$\n$$ E_{\\mathrm{spl}}(\\Delta t) = -\\frac{\\Delta t^3}{4} A_h B_h (A_h+B_h) + \\mathcal{O}(\\Delta t^4) $$\n由于 $A_h$ 和 $B_h$ 通常是表示二阶导数的非零算子，$\\Delta t^3$ 的系数不为零。因此，分裂误差中的首项是关于 $\\Delta t$ 的三阶项。\n因此，使得 $E_{\\mathrm{spl}}(\\Delta t) = \\mathcal{O}(\\Delta t^p)$ 成立的最小整数 $p$ 是 $p=3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "最后的这个实践综合了您的实现技巧和理论见解。您将设计并实现一个自适应时间步长控制器，它利用了我们在上一个练习  中分析过的分裂误差概念。这个高级应用展示了如何创建一个更智能、更高效的求解器，它能动态调整时间步长以满足预期的精度容差。",
            "id": "3363234",
            "problem": "你的任务是为一种扩散型偏微分方程设计并实现一个用于线性交替方向隐式 (ADI) 方法的自适应时间步长控制器。出发点是单位正方形上的二维扩散方程，带有齐次狄利克雷边界条件，\n$$\n\\frac{\\partial u}{\\partial t} = k_x \\frac{\\partial^2 u}{\\partial x^2} + k_y \\frac{\\partial^2 u}{\\partial y^2}, \\quad (x,y) \\in (0,1)\\times(0,1), \\quad t \\ge 0,\n$$\n并具有\n$$\nu(0,x,y) = \\sin(\\pi x)\\sin(\\pi y), \\quad u(t,0,y)=u(t,1,y)=u(t,x,0)=u(t,x,1)=0.\n$$\n使用一个在 $x$ 方向有 $N_x$ 个内部点、在 $y$ 方向有 $N_y$ 个内部点的均匀网格来离散化空间域，间距分别为 $h_x = 1/(N_x+1)$ 和 $h_y = 1/(N_y+1)$。令 $u^n \\in \\mathbb{R}^{N_y \\times N_x}$ 表示在时间层 $t^n$ 的网格函数，代表内部网格点上的值。定义沿每个轴作用的一维中心二阶差分算子，并采用齐次狄利克雷边界处理，得到作用于 $u^n$ 的线性算子 $A_x$ 和 $A_y$，其定义为\n$$\nA_x u[i,j] = k_x \\frac{u[i,j-1] - 2u[i,j] + u[i,j+1]}{h_x^2}, \\quad A_y u[i,j] = k_y \\frac{u[i-1,j] - 2u[i,j] + u[i+1,j]}{h_y^2},\n$$\n其中超出范围的索引对应于等于 $0$ 的边界值。考虑分解的隐式欧拉 ADI 更新，\n$$\n(I - \\Delta t A_y) v = u^n, \\quad (I - \\Delta t A_x) u^{n+1} = v,\n$$\n这在代数上等价于 $(I - \\Delta t A_x)(I - \\Delta t A_y)u^{n+1} = u^n$。\n\n在每一步开始时，使用线性化缺陷公式估计分裂缺陷\n$$\nd^{n+1}(\\Delta t; u^n) = \\Big(I - \\Delta t A_x\\Big)\\Big(I - \\Delta t A_y\\Big) u^n - \\Big(I - \\Delta t (A_x + A_y)\\Big) u^n,\n$$\n其精确地简化为\n$$\nd^{n+1}(\\Delta t; u^n) = \\Delta t^2 A_x A_y u^n,\n$$\n并使用其无穷范数 $\\|d^{n+1}\\|_\\infty$ 来自适应地控制 $\\Delta t$，从而使这个分裂误差的代理值保持在目标容差范围内。对于每一步，定义一个局部容差\n$$\n\\mathrm{tol}_n = \\mathrm{atol} + \\mathrm{rtol}\\,\\|u^n\\|_\\infty.\n$$\n如果 $\\|d^{n+1}\\|_\\infty \\le \\mathrm{tol}_n$，则接受该步；否则，拒绝它。无论接受还是拒绝，都使用一个比例控制器来更新下一个时间步长，该控制器基于缺陷相对于时间步长的预期二次缩放关系，\n$$\n\\Delta t_{\\text{new}} = \\Delta t \\cdot \\mathrm{safety} \\cdot \\left(\\frac{\\mathrm{tol}_n}{\\max(\\|d^{n+1}\\|_\\infty,\\varepsilon)}\\right)^{1/2},\n$$\n并受到用户选择的乘性限制 $g_{\\min} \\le \\Delta t_{\\text{new}}/\\Delta t \\le g_{\\max}$ 和一个绝对最大值 $\\Delta t \\le \\Delta t_{\\max}$ 的约束。这里的 $\\varepsilon$ 是一个微小的正数，以避免除以零。在拒绝时，强制 $\\Delta t_{\\text{new}} \\le \\Delta t$；在接受时，允许在所选边界内 $\\Delta t_{\\text{new}} \\ge \\Delta t$。通过根据需要将 $\\Delta t$ 裁剪到剩余时间，确保时间积分恰好在最终时间结束。\n\n实现以上内容时需满足以下要求：\n- 对于每个被接受的步，使用 ADI 分解，并在每个方向上通过三对角求解来解决两个线性系统。\n- 对 $\\|u^n\\|_\\infty$ 和 $\\|d^{n+1}\\|_\\infty$ 均使用无穷范数。\n- 使用在内部网格点 $x_j = (j+1)h_x$，$y_i = (i+1)h_y$ 上采样的初始条件 $u(0,x,y)=\\sin(\\pi x)\\sin(\\pi y)$。\n\n测试套件。在下面三个参数集上运行你的实现。对于每种情况，返回整个积分过程中控制器产生的被拒绝步数（一个整数）。这三种情况是：\n- 情况1（均衡扩散）：$k_x = 1.0$, $k_y = 1.0$, $N_x = 32$, $N_y = 32$, $T = 0.1$, 初始 $\\Delta t_0 = 10^{-4}$, $\\Delta t_{\\max} = 10^{-2}$, $\\mathrm{rtol} = 10^{-3}$, $\\mathrm{atol} = 10^{-8}$。\n- 情况2（各向异性扩散）：$k_x = 1.0$, $k_y = 10.0$, $N_x = 32$, $N_y = 32$, $T = 0.05$, 初始 $\\Delta t_0 = 5 \\cdot 10^{-5}$, $\\Delta t_{\\max} = 5 \\cdot 10^{-3}$, $\\mathrm{rtol} = 5 \\cdot 10^{-4}$, $\\mathrm{atol} = 10^{-8}$。\n- 情况3（在 $y$ 方向上退化）：$k_x = 1.0$, $k_y = 0.0$, $N_x = 32$, $N_y = 32$, $T = 0.1$, 初始 $\\Delta t_0 = 10^{-3}$, $\\Delta t_{\\max} = 2 \\cdot 10^{-2}$, $\\mathrm{rtol} = 10^{-3}$, $\\mathrm{atol} = 10^{-8}$。\n\n所有情况均使用以下控制器常数：$\\mathrm{safety} = 0.9$，$g_{\\min} = 0.2$，$g_{\\max} = 2.5$，以及 $\\varepsilon = 10^{-300}$。\n\n最终输出格式。你的程序应该生成单行输出，其中包含一个逗号分隔的列表，按测试用例的顺序包含三个整数，并用方括号括起来，例如，\n\"[r1,r2,r3]\"。",
            "solution": "用户要求为应用于单位正方形 $[0,1] \\times [0,1]$ 上二维扩散方程的交替方向隐式 (ADI) 方法实现一个自适应时间步长控制器：\n$$\n\\frac{\\partial u}{\\partial t} = k_x \\frac{\\partial^2 u}{\\partial x^2} + k_y \\frac{\\partial^2 u}{\\partial y^2}\n$$\n该方程具有齐次狄利克雷边界条件和给定的初始条件 $u(0,x,y) = \\sin(\\pi x)\\sin(\\pi y)$。\n\n解决方案首先对问题进行离散化，然后实现 ADI 时间步进格式，最后集成自适应控制器逻辑。\n\n### 1. 空间离散化\n连续域被离散化为一个包含 $N_y \\times N_x$ 个内部点的网格。在时间 $t^n$ 的解 $u(t,x,y)$ 由一个矩阵 $u^n \\in \\mathbb{R}^{N_y \\times N_x}$ 表示，其中 $u^n_{i,j}$ 近似了在点 $(x_j, y_i) = ((j+1)h_x, (i+1)h_y)$ 处的解。网格间距为 $h_x = 1/(N_x+1)$ 和 $h_y = 1/(N_y+1)$。\n\n二阶偏导数使用中心有限差分进行近似。这产生了两个作用于网格函数 $u^n$ 的线性算子 $A_x$ 和 $A_y$：\n- $A_x$ 将按 $k_x/h_x^2$ 缩放的一维二阶差分模板应用于矩阵 $u^n$ 的每一行。\n- $A_y$ 将按 $k_y/h_y^2$ 缩放的一维二阶差分模板应用于矩阵 $u^n$ 的每一列。\n齐次狄利克雷边界条件通过假设内部域之外索引处的任何网格函数值都为零来处理。在实现中，这是通过在应用有限差分模板之前用零填充网格函数矩阵来实现的。\n\n### 2. ADI 方法\n时间演化由半离散化方程 $\\frac{du}{dt} = (A_x + A_y)u$ 控制。ADI 方法，特别是指定的分解的隐式欧拉变体，将时间步长 $\\Delta t$ 分为两个子步骤。这种方法将一个大的二维问题转化为一系列较小的、独立的一维问题，这些问题在计算上求解效率很高。\n\n从时间 $t^n$ 到 $t^{n+1} = t^n + \\Delta t$ 的更新分两个阶段进行：\n1.  **Y方向隐式步**：求解中间状态 $v$：\n    $$ (I - \\Delta t A_y) v = u^n $$\n    该方程代表一组 $N_x$ 个独立的三对角线性系统，每个系统对应于网格函数 $v$ 的一列。\n2.  **X方向隐式步**：求解新状态 $u^{n+1}$：\n    $$ (I - \\Delta t A_x) u^{n+1} = v $$\n    该方程代表一组 $N_y$ 个独立的三对角线性系统，每个系统对应于网格函数 $u^{n+1}$ 的一行。\n\n每一组三对角系统都可以通过单次调用 `scipy.linalg.solve_banded` 来高效求解，该函数为此任务进行了优化。对于作用于行的 X 方向步骤，中间矩阵 $v$ 被转置，然后调用求解器，最后将结果转置回来。\n\n### 3. 自适应时间步长控制\n自适应控制器调整时间步长 $\\Delta t$，以将局部误差的度量维持在指定容差以下。这通过在解平滑时允许较大的步长，在解快速变化时允许较小的步长来提高效率。\n\n-   **误差估计**：用于控制的误差是基于 ADI 分裂缺陷的代理，由 $d^{n+1} = \\Delta t^2 A_x A_y u^n$ 给出。其无穷范数 $\\|d^{n+1}\\|_\\infty$ 被用作当前步骤的误差度量。该量通过将已实现的离散算子 $A_y$ 然后是 $A_x$ 顺序应用于当前解 $u^n$ 来计算。\n\n-   **容差**：在每一步，局部容差计算为 $\\mathrm{tol}_n = \\mathrm{atol} + \\mathrm{rtol}\\,\\|u^n\\|_\\infty$，其中 $\\mathrm{atol}$ 和 $\\mathrm{rtol}$ 分别是绝对和相对容差参数。\n\n-   **接受/拒绝机制**：尝试一个大小为 $\\Delta t$ 的步。\n    - 如果 $\\|d^{n+1}\\|_\\infty \\le \\mathrm{tol}_n$，则该步被**接受**。解和时间被更新：计算 $u^{n+1}$ 并使其成为新的 $u^n$，时间 $t$ 前进 $\\Delta t$。\n    - 如果 $\\|d^{n+1}\\|_\\infty > \\mathrm{tol}_n$，则该步被**拒绝**。解和时间不改变，被拒绝的步数增加。\n\n-   **步长更新**：在两种情况（接受或拒绝）下，都使用比例-积分 (PI) 型控制律计算一个新的预期时间步长 $\\Delta t_{\\text{new}}$。该问题指定了一个比例控制器：\n    $$ \\Delta t_{\\text{new}} = \\Delta t \\cdot \\mathrm{safety} \\cdot \\left(\\frac{\\mathrm{tol}_n}{\\max(\\|d^{n+1}\\|_\\infty,\\varepsilon)}\\right)^{1/2} $$\n    微小值 $\\varepsilon$ 防止除以零。产生的步长变化率 $\\Delta t_{\\text{new}}/\\Delta t$ 被限制在 $[g_{\\min}, g_{\\max}]$ 范围内，并且新步长被绝对最大值 $\\Delta t_{\\max}$ 所限制。如果一个步骤被拒绝，新计算出的 $\\Delta t_{\\text{new}}$（将会更小）将用于重试该步骤。如果被接受，$\\Delta t_{\\text{new}}$ 将用于后续的时间步。\n\n### 4. 实现逻辑\n整个过程被封装在一个函数中，该函数为一组给定的参数运行模拟。\n1.  初始化网格、通过采样 $\\sin(\\pi x)\\sin(\\pi y)$ 得到的初始条件 $u^0$、当前时间 $t=0$、初始步长 $\\Delta t = \\Delta t_0$ 以及一个用于被拒绝步数的计数器。\n2.  只要 $t  T$，`while` 循环就会运行。\n3.  在循环内部，首先裁剪当前的 $\\Delta t$，使其不超过 $\\Delta t_{\\max}$，并确保最后一步恰好落在 $t=T$ 上。\n4.  基于当前的 $u^n$ 和尝试的 $\\Delta t$，计算后验误差 $\\|d^{n+1}\\|_\\infty$。\n5.  做出接受或拒绝的决定。\n6.  使用控制公式和相关边界计算新的步长。\n7.  如果该步被接受，则推进时间和解。下一次迭代的 `dt` 设置为新计算出的步长。\n8.  如果该步被拒绝，则增加计数器，下一次迭代（即重试当前步）的 `dt` 设置为新计算出的（较小的）步长。\n9.  此过程重复进行，直到达到最终时间 $T$。返回被拒绝的总步数。此逻辑应用于指定的三个测试用例中的每一个。\n\n当 $k_y = 0$ 时（如情况3），会出现一个特殊情况。此时，$A_y=0$，使得分裂缺陷 $d^{n+1}$ 恒为零。实现正确地处理了这种情况：误差范数始终为零，因此每一步都被接受，步长控制器将以允许的最大速率 $g_{\\max}$ 增加 $\\Delta t$，直到它被 $\\Delta t_{\\max}$ 限制。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef run_simulation(kx, ky, Nx, Ny, T, dt0, dt_max, rtol, atol, safety, g_min, g_max, eps):\n    \"\"\"\n    Runs the adaptive ADI simulation for one parameter set.\n    \"\"\"\n    # 1. Grid and Initial Condition Setup\n    hx = 1.0 / (Nx + 1)\n    hy = 1.0 / (Ny + 1)\n    \n    x = (np.arange(Nx) + 1) * hx\n    y = (np.arange(Ny) + 1) * hy\n    X, Y = np.meshgrid(x, y)\n    \n    u = np.sin(np.pi * X) * np.sin(np.pi * Y)\n\n    t = 0.0\n    dt = dt0\n    rejected_steps = 0\n\n    # Helper functions for applying discrete operators\n    def apply_Ax(u_mat, k, h):\n        padded = np.pad(u_mat, ((0, 0), (1, 1)), 'constant')\n        diff = padded[:, :-2] - 2 * padded[:, 1:-1] + padded[:, 2:]\n        return (k / h**2) * diff\n\n    def apply_Ay(u_mat, k, h):\n        padded = np.pad(u_mat, ((1, 1), (0, 0)), 'constant')\n        diff = padded[:-2, :] - 2 * padded[1:-1, :] + padded[2:, :]\n        return (k / h**2) * diff\n\n    # 2. Main Time-Stepping Loop\n    while t  T:\n        # Clip dt by global max and to land on T\n        dt_attempt = min(dt, dt_max)\n        if t + dt_attempt > T:\n            dt_attempt = T - t\n        \n        # 3. Defect and Tolerance Calculation\n        u_norm = np.max(np.abs(u))\n        tol = atol + rtol * u_norm\n\n        if ky == 0.0 or kx == 0.0:\n            err_norm = 0.0\n        else:\n            d = (dt_attempt**2) * apply_Ax(apply_Ay(u, ky, hy), kx, hx)\n            err_norm = np.max(np.abs(d))\n\n        # 4. Accept/Reject Step\n        accepted = err_norm = tol\n\n        # 5. Calculate new step size\n        if err_norm  eps: # To handle err_norm == 0 or very small\n             factor = g_max\n        else:\n            factor_raw = safety * (tol / err_norm)**0.5\n            factor = max(g_min, min(g_max, factor_raw))\n        \n        dt_new = dt_attempt * factor\n\n        if accepted:\n            # Perform ADI step\n            # Y-sweep: (I - dt*Ay) v = u\n            if ky != 0.0:\n                cy = -dt_attempt * ky / hy**2\n                diag_y = 1.0 - 2.0 * cy\n                ab_y = np.zeros((3, Ny))\n                ab_y[0, 1:] = cy\n                ab_y[1, :] = diag_y\n                ab_y[2, :-1] = cy\n                v = solve_banded((1, 1), ab_y, u, overwrite_ab=True, overwrite_b=False)\n            else:\n                v = u\n\n            # X-sweep: (I - dt*Ax) u_new = v\n            if kx != 0.0:\n                cx = -dt_attempt * kx / hx**2\n                diag_x = 1.0 - 2.0 * cx\n                ab_x = np.zeros((3, Nx))\n                ab_x[0, 1:] = cx\n                ab_x[1, :] = diag_x\n                ab_x[2, :-1] = cx\n                u_new_T = solve_banded((1, 1), ab_x, v.T, overwrite_ab=True, overwrite_b=False)\n                u = u_new_T.T\n            else:\n                u = v\n            \n            t += dt_attempt\n            dt = dt_new\n        else:\n            rejected_steps += 1\n            # Retry with smaller step size\n            dt = dt_new\n            \n    return rejected_steps\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Controller constants\n    safety = 0.9\n    g_min = 0.2\n    g_max = 2.5\n    eps = 1e-300\n\n    test_cases = [\n        # Case 1: balanced diffusion\n        {\"kx\": 1.0, \"ky\": 1.0, \"Nx\": 32, \"Ny\": 32, \"T\": 0.1, \n         \"dt0\": 1e-4, \"dt_max\": 1e-2, \"rtol\": 1e-3, \"atol\": 1e-8},\n        # Case 2: anisotropic diffusion\n        {\"kx\": 1.0, \"ky\": 10.0, \"Nx\": 32, \"Ny\": 32, \"T\": 0.05,\n         \"dt0\": 5e-5, \"dt_max\": 5e-3, \"rtol\": 5e-4, \"atol\": 1e-8},\n        # Case 3: degenerate in y\n        {\"kx\": 1.0, \"ky\": 0.0, \"Nx\": 32, \"Ny\": 32, \"T\": 0.1,\n         \"dt0\": 1e-3, \"dt_max\": 2e-2, \"rtol\": 1e-3, \"atol\": 1e-8}\n    ]\n\n    results = []\n    for params in test_cases:\n        rejections = run_simulation(\n            kx=params[\"kx\"], ky=params[\"ky\"],\n            Nx=params[\"Nx\"], Ny=params[\"Ny\"],\n            T=params[\"T\"], dt0=params[\"dt0\"], dt_max=params[\"dt_max\"],\n            rtol=params[\"rtol\"], atol=params[\"atol\"],\n            safety=safety, g_min=g_min, g_max=g_max, eps=eps\n        )\n        results.append(rejections)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}