{
    "hands_on_practices": [
        {
            "introduction": "We begin with a canonical example from quantum mechanics, the Schrödinger equation, which governs the evolution of a quantum state. In this context, preserving the total probability, represented by the squared $L^2$ norm of the wavefunction, is a fundamental physical requirement. This exercise guides you through implementing the Cayley transform, a time-stepping method that generates a unitary discrete evolution operator, thereby exactly preserving both the norm and the system's energy. You will apply this to dynamics on a graph, a modern setting with applications in network science and quantum computing, and empirically verify these crucial conservation laws. ",
            "id": "3450219",
            "problem": "Consider Schrödinger dynamics on a finite undirected graph with complex amplitude vector $\\psi(t) \\in \\mathbb{C}^n$ governed by the linear equation $i \\,\\dot{\\psi}(t) = L \\,\\psi(t)$, where $L \\in \\mathbb{R}^{n \\times n}$ is a symmetric graph Laplacian. For an undirected graph with symmetric adjacency matrix $A \\in \\mathbb{R}^{n \\times n}$, define two standard Laplacians: the unnormalized Laplacian $L_{\\mathrm{unn}} = D - A$ with $D = \\mathrm{diag}(d_0,\\dots,d_{n-1})$ and $d_j = \\sum_{k=0}^{n-1} A_{jk}$, and the symmetric normalized Laplacian $L_{\\mathrm{sym}} = I - D^{-1/2} A D^{-1/2}$, where the diagonal matrix $D^{-1/2}$ is defined componentwise by $(D^{-1/2})_{jj} = d_j^{-1/2}$ when $d_j > 0$ and $(D^{-1/2})_{jj} = 0$ when $d_j = 0$. The exact continuous-time evolution preserves the discrete Lebesgue space ($L^2$) norm $\\|\\psi(t)\\|_2^2 = \\psi(t)^* \\psi(t)$ and the quadratic energy expectation $E(t) = \\psi(t)^* L \\,\\psi(t)$.\n\nYour task is to construct a unitary time-stepping method using the Cayley transform for the discrete-time update that preserves the discrete $L^2$ norm and to analyze the effect of Laplacian normalization on the energy spectrum. For a fixed time step $h > 0$, consider the Cayley update operator\n$$\nU_h(L) = \\big(I - i \\tfrac{h}{2} L\\big)^{-1} \\big(I + i \\tfrac{h}{2} L\\big),\n$$\nand the associated update $\\psi^{n+1} = U_h(L)\\,\\psi^{n}$ from step $n$ to step $n+1$. The method is known to be norm-preserving when $L$ is self-adjoint. You must implement this scheme for both $L_{\\mathrm{unn}}$ and $L_{\\mathrm{sym}}$ and empirically verify invariants over multiple steps. Additionally, you should compute and compare the minimal and maximal eigenvalues of $L_{\\mathrm{unn}}$ and $L_{\\mathrm{sym}}$ to explore how normalization affects the energy spectrum.\n\nUse the following test suite, with each case specifying an adjacency matrix $A$, a time step $h$, and a number of steps $M$. For each case, initialize $\\psi^0 \\in \\mathbb{C}^n$ by $\\psi^0_j = j + i (n - j)$ for $j = 0,1,\\dots,n-1$, and rescale so that $\\|\\psi^0\\|_2 = 1$. All angles (if any are used) must be in radians. No physical units are required for this problem.\n\nTest suite:\n- Case $\\#1$ (path graph): $n = 5$, adjacency entries $A_{j,j+1} = A_{j+1,j} = 1$ for $j = 0,1,2,3$, all other entries $0$, with $h = 0.2$ and $M = 20$.\n- Case $\\#2$ (star graph): $n = 6$, adjacency entries $A_{0,k} = A_{k,0} = 1$ for $k = 1,2,3,4,5$, all other entries $0$, with $h = 0.05$ and $M = 100$.\n- Case $\\#3$ (weighted cycle): $n = 5$, edges on a ring with weights $w_0 = 1.0$, $w_1 = 2.0$, $w_2 = 0.5$, $w_3 = 1.5$, $w_4 = 1.0$, that is, $A_{j,(j+1)\\bmod 5} = A_{(j+1)\\bmod 5,j} = w_j$ for $j=0,1,2,3,4$, with $h = 1.0$ and $M = 10$.\n- Case $\\#4$ (disconnected with isolated nodes): $n = 4$, adjacency entries $A_{0,1} = A_{1,0} = 1$ and all others $0$, with $h = 0.3$ and $M = 30$.\n\nFor each case and each Laplacian type ($L_{\\mathrm{unn}}$ and $L_{\\mathrm{sym}}$):\n- Compute the maximum absolute deviation of the norm $\\|\\psi^n\\|_2$ from its initial value $\\|\\psi^0\\|_2$ over $n = 1,2,\\dots,M$ and return a boolean indicating whether this deviation is at most $10^{-12}$.\n- Compute the maximum absolute deviation of the energy expectation $\\psi^{n*} L \\psi^n$ from its initial value $\\psi^{0*} L \\psi^0$ over $n = 1,2,\\dots,M$ and return a boolean indicating whether this deviation is at most $10^{-12}$.\n- Compute and return the minimal and maximal eigenvalues (as floats) of $L$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of case results, where each case result is itself a list containing eight values in the following order:\n$[$norm-preserved for $L_{\\mathrm{unn}}$, energy-preserved for $L_{\\mathrm{unn}}$, norm-preserved for $L_{\\mathrm{sym}}$, energy-preserved for $L_{\\mathrm{sym}}$, $\\min \\sigma(L_{\\mathrm{unn}})$, $\\max \\sigma(L_{\\mathrm{unn}})$, $\\min \\sigma(L_{\\mathrm{sym}})$, $\\max \\sigma(L_{\\mathrm{sym}})]$,\nwith booleans for the preserved indicators and floats for the eigenvalue extrema. For example, the output format must be exactly of the form\n$[[$result\\_case\\_1$],[$result\\_case\\_2$],[$result\\_case\\_3$],[$result\\_case\\_4$]]$\nwith no additional text.",
            "solution": "The problem requires the implementation and analysis of a numerical method for the Schrödinger equation on a graph, $i \\,\\dot{\\psi}(t) = L \\,\\psi(t)$, where $\\psi(t)$ is the complex amplitude vector and $L$ is a graph Laplacian matrix. The analysis focuses on the preservation of invariants and the spectral properties of two different types of Laplacians: the unnormalized Laplacian $L_{\\mathrm{unn}}$ and the symmetric normalized Laplacian $L_{\\mathrm{sym}}$.\n\nFirst, let us establish the theoretical properties of the continuous system and the numerical integrator. The graph Laplacian $L$, whether unnormalized or symmetric normalized, is a real, symmetric matrix. In the context of quantum mechanics, it serves as the Hamiltonian operator, which must be self-adjoint. Real symmetric matrices are indeed self-adjoint ($L^* = L^T = L$).\n\nThe time evolution of the system is governed by the operator $e^{-iLt}$, such that $\\psi(t) = e^{-iLt}\\psi(0)$. Since $L$ is self-adjoint, the evolution operator $e^{-iLt}$ is unitary. This property guarantees the conservation of the discrete $L^2$-norm (total probability):\n$$\n\\|\\psi(t)\\|_2^2 = \\psi(t)^* \\psi(t) = (e^{-iLt}\\psi(0))^* (e^{-iLt}\\psi(0)) = \\psi(0)^* (e^{-iLt})^* (e^{-iLt}) \\psi(0) = \\psi(0)^* e^{iLt} e^{-iLt} \\psi(0) = \\psi(0)^* \\psi(0) = \\|\\psi(0)\\|_2^2.\n$$\nThe second invariant is the energy expectation, $E(t) = \\psi(t)^* L \\psi(t)$. Its conservation follows from the Schrödinger equation:\n$$\n\\frac{dE}{dt} = \\dot{\\psi}(t)^* L \\psi(t) + \\psi(t)^* L \\dot{\\psi}(t).\n$$\nSubstituting $\\dot{\\psi} = -iL\\psi$ and $\\dot{\\psi}^* = (-iL\\psi)^* = i\\psi^*L^* = i\\psi^*L$:\n$$\n\\frac{dE}{dt} = (i\\psi^*L) L \\psi(t) + \\psi(t)^* L (-iL\\psi(t)) = i\\psi^*L^2\\psi - i\\psi^*L^2\\psi = 0.\n$$\nThus, both the norm and the energy are exact invariants of the continuous-time dynamics.\n\nThe problem proposes using the Cayley transform for the time-stepping from $\\psi^n$ to $\\psi^{n+1}$:\n$$\n\\psi^{n+1} = U_h(L) \\psi^n, \\quad \\text{where} \\quad U_h(L) = \\big(I - i \\tfrac{h}{2} L\\big)^{-1} \\big(I + i \\tfrac{h}{2} L\\big).\n$$\nThis numerical scheme is an example of a geometric or structure-preserving integrator. We can verify that it preserves the same invariants as the continuous system. The operator $U_h(L)$ is unitary for any self-adjoint $L$. A matrix $U$ is unitary if $U^*U=I$. Let $X = i \\frac{h}{2} L$. Since $L$ is self-adjoint, $X$ is skew-adjoint ($X^* = -X$).\n$$\nU_h(L)^* = \\left( \\big(I - X\\big)^{-1} \\big(I + X\\big) \\right)^* = (I+X)^* ((I-X)^{-1})^* = (I+X^*) (I-X^*)^{-1} = (I-X)(I+X)^{-1}.\n$$\nThen, the product $U_h(L)^* U_h(L)$ is:\n$$\n(I-X)(I+X)^{-1} (I-X)^{-1}(I+X).\n$$\nSince $(I-X)^{-1}$ and $(I+X)^{-1}$ are rational functions of $X$, they commute. Similarly, $(I-X)$ and $(I+X)$ commute. Therefore, we can rearrange the terms:\n$$\nU_h(L)^* U_h(L) = (I-X) (I-X)^{-1} (I+X)^{-1} (I+X) = I \\cdot I = I.\n$$\nThe unitarity of $U_h(L)$ guarantees that the discrete update preserves the $L^2$-norm exactly (up to machine precision):\n$$\n\\|\\psi^{n+1}\\|_2^2 = (\\psi^{n+1})^* \\psi^{n+1} = (U_h \\psi^n)^* (U_h \\psi^n) = (\\psi^n)^* U_h^* U_h \\psi^n = (\\psi^n)^* \\psi^n = \\|\\psi^n\\|_2^2.\n$$\nFurthermore, the discrete energy $E^n = (\\psi^n)^* L \\psi^n$ is also preserved. This is because $L$ commutes with $U_h(L)$, as $U_h(L)$ is a rational function of $L$.\n$$\nE^{n+1} = (\\psi^{n+1})^* L \\psi^{n+1} = (U_h \\psi^n)^* L (U_h \\psi^n) = (\\psi^n)^* U_h^* L U_h \\psi^n.\n$$\nSince $L$ and $U_h$ commute, $L U_h = U_h L$. Taking the adjoint gives $U_h^* L^* = L^* U_h^*$, and since $L=L^*$, we have $U_h^* L = L U_h^*$. So, $L$ also commutes with $U_h^*$.\n$$\nE^{n+1} = (\\psi^n)^* U_h^* U_h L \\psi^n = (\\psi^n)^* I L \\psi^n = (\\psi^n)^* L \\psi^n = E^n.\n$$\nTherefore, the Cayley map integrator exactly preserves both the norm and the energy associated with the chosen Laplacian $L$. The verification in the problem, checking for deviations up to a tolerance of $10^{-12}$, serves as a numerical confirmation of these theoretical properties, accounting for floating-point arithmetic errors.\n\nThe implementation will proceed as follows for each test case:\n1.  Construct the adjacency matrix $A$.\n2.  For both $L_{\\mathrm{unn}}$ and $L_{\\mathrm{sym}}$:\n    a. Construct the Laplacian matrix $L$ from $A$. For $L_{\\mathrm{sym}}$, the definition $(D^{-1/2})_{jj} = d_j^{-1/2}$ for $d_j > 0$ and $0$ for $d_j=0$ must be carefully implemented.\n    b. Compute the minimal and maximal eigenvalues of $L$ using a method suitable for symmetric matrices, such as `numpy.linalg.eigvalsh`.\n    c. Initialize the state vector $\\psi^0$ as specified and normalize it.\n    d. Calculate the initial norm and energy.\n    e. Pre-compute the matrices for the linear system solver: $M_A = I - i \\frac{h}{2} L$ and $M_B = I + i \\frac{h}{2} L$.\n    f. Iterate $M$ times, updating the state vector at each step by solving the linear system $M_A \\psi^{n+1} = M_B \\psi^n$.\n    g. During the iteration, track the maximum absolute deviation of the norm and energy from their initial values.\n    h. After the simulation, determine if the norm and energy were preserved within the given tolerance.\n3.  Collect and format the eight specified results for the final output.\n\nThe eigenvalues of the Laplacians determine the energy spectrum of the system. For the unnormalized Laplacian $L_{\\mathrm{unn}}$, the eigenvalues are non-negative, and the smallest eigenvalue is $0$, with its multiplicity equal to the number of connected components of the graph. The magnitude of the largest eigenvalue is related to the maximum degree. For the symmetric normalized Laplacian $L_{\\mathrm{sym}}$, the eigenvalues are known to be in the range $[0, 2]$. Again, the smallest eigenvalue is $0$ for any graph with at least one edge. An eigenvalue of $2$ occurs if and only if the graph has a bipartite connected component. This normalization procedure maps the spectrum to a fixed interval, which can be advantageous in theoretical analysis and for the stability of certain numerical methods.",
            "answer": "```python\nimport numpy as np\n\ndef process_case(A, h, M):\n    \"\"\"\n    Processes a single test case for both unnormalized and symmetric\n    normalized Laplacians.\n    \"\"\"\n    n = A.shape[0]\n    \n    # --- Initial State ---\n    psi0_unscaled = np.arange(n, dtype=np.complex128) + 1j * (n - np.arange(n, dtype=np.complex128))\n    psi0 = psi0_unscaled / np.linalg.norm(psi0_unscaled)\n    \n    # --- Unnormalized Laplacian: L_unn ---\n    d_unn = np.sum(A, axis=1)\n    D_unn = np.diag(d_unn)\n    L_unn = D_unn - A\n    \n    eigvals_unn = np.linalg.eigvalsh(L_unn)\n    min_eig_unn = np.min(eigvals_unn)\n    max_eig_unn = np.max(eigvals_unn)\n    \n    psi = psi0.copy()\n    initial_norm_unn = np.linalg.norm(psi)\n    initial_energy_unn = np.real(psi.conj().T @ L_unn @ psi)\n    max_norm_dev_unn = 0.0\n    max_energy_dev_unn = 0.0\n    \n    Id = np.eye(n, dtype=np.complex128)\n    mat_A_unn = Id - 0.5j * h * L_unn\n    mat_B_unn = Id + 0.5j * h * L_unn\n    \n    for _ in range(M):\n        b = mat_B_unn @ psi\n        psi = np.linalg.solve(mat_A_unn, b)\n        \n        current_norm = np.linalg.norm(psi)\n        current_energy = np.real(psi.conj().T @ L_unn @ psi)\n        \n        max_norm_dev_unn = max(max_norm_dev_unn, abs(current_norm - initial_norm_unn))\n        max_energy_dev_unn = max(max_energy_dev_unn, abs(current_energy - initial_energy_unn))\n        \n    norm_preserved_unn = max_norm_dev_unn <= 1e-12\n    energy_preserved_unn = max_energy_dev_unn <= 1e-12\n\n    # --- Symmetric Normalized Laplacian: L_sym ---\n    d_sym = np.sum(A, axis=1)\n    d_sqrt_inv_diag = np.zeros_like(d_sym, dtype=float)\n    non_zero_mask = d_sym > 0\n    d_sqrt_inv_diag[non_zero_mask] = 1.0 / np.sqrt(d_sym[non_zero_mask])\n    D_sqrt_inv = np.diag(d_sqrt_inv_diag)\n    \n    L_sym = Id.real - D_sqrt_inv @ A @ D_sqrt_inv\n    \n    eigvals_sym = np.linalg.eigvalsh(L_sym)\n    min_eig_sym = np.min(eigvals_sym)\n    max_eig_sym = np.max(eigvals_sym)\n    \n    psi = psi0.copy()\n    initial_norm_sym = np.linalg.norm(psi)\n    initial_energy_sym = np.real(psi.conj().T @ L_sym @ psi)\n    max_norm_dev_sym = 0.0\n    max_energy_dev_sym = 0.0\n\n    mat_A_sym = Id - 0.5j * h * L_sym\n    mat_B_sym = Id + 0.5j * h * L_sym\n    \n    for _ in range(M):\n        b = mat_B_sym @ psi\n        psi = np.linalg.solve(mat_A_sym, b)\n\n        current_norm = np.linalg.norm(psi)\n        current_energy = np.real(psi.conj().T @ L_sym @ psi)\n\n        max_norm_dev_sym = max(max_norm_dev_sym, abs(current_norm - initial_norm_sym))\n        max_energy_dev_sym = max(max_energy_dev_sym, abs(current_energy - initial_energy_sym))\n\n    norm_preserved_sym = max_norm_dev_sym <= 1e-12\n    energy_preserved_sym = max_energy_dev_sym <= 1e-12\n\n    return [\n        norm_preserved_unn, energy_preserved_unn,\n        norm_preserved_sym, energy_preserved_sym,\n        min_eig_unn, max_eig_unn,\n        min_eig_sym, max_eig_sym\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run simulations, and print results.\n    \"\"\"\n    # Case #1: Path graph\n    n1 = 5\n    A1 = np.zeros((n1, n1))\n    for j in range(n1 - 1):\n        A1[j, j + 1] = A1[j + 1, j] = 1.0\n    h1, M1 = 0.2, 20\n\n    # Case #2: Star graph\n    n2 = 6\n    A2 = np.zeros((n2, n2))\n    for k in range(1, n2):\n        A2[0, k] = A2[k, 0] = 1.0\n    h2, M2 = 0.05, 100\n\n    # Case #3: Weighted cycle\n    n3 = 5\n    A3 = np.zeros((n3, n3))\n    weights = [1.0, 2.0, 0.5, 1.5, 1.0]\n    for j in range(n3):\n        A3[j, (j + 1) % n3] = A3[(j + 1) % n3, j] = weights[j]\n    h3, M3 = 1.0, 10\n\n    # Case #4: Disconnected with isolated nodes\n    n4 = 4\n    A4 = np.zeros((n4, n4))\n    A4[0, 1] = A4[1, 0] = 1.0\n    h4, M4 = 0.3, 30\n    \n    test_cases = [\n        (A1, h1, M1),\n        (A2, h2, M2),\n        (A3, h3, M3),\n        (A4, h4, M4),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, h, M = case\n        case_result = process_case(A, h, M)\n        results.append(case_result)\n\n    case_strings = [str(res) for res in results]\n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving to the realm of fluid dynamics, we tackle the two-dimensional incompressible Euler equations, a model for ideal fluid flow. Beyond energy, these equations conserve an infinite number of invariants, with enstrophy (the integrated squared vorticity) being one of the most important for capturing the correct turbulence dynamics. This practice requires you to construct a numerical scheme that preserves a discrete analogue of enstrophy by carefully designing a skew-symmetric discretization of the nonlinear advection term, a technique pioneered by Arakawa. Combining this spatial scheme with a time integrator that respects quadratic invariants, you will build a solver that correctly models the inviscid cascade of enstrophy. ",
            "id": "3450191",
            "problem": "Design and implement a structure-preserving finite difference solver for the incompressible two-dimensional Euler equations in vorticity–streamfunction form on a periodic square domain. The governing Partial Differential Equation (PDE) is the vorticity transport equation\n$$\n\\frac{\\partial \\omega}{\\partial t} + J(\\psi,\\omega) = 0,\n$$\nwith the streamfunction–vorticity relation\n$$\n\\nabla^2 \\psi = -\\omega,\n$$\nwhere $\\omega(x,y,t)$ is the scalar vorticity, $\\psi(x,y,t)$ is the streamfunction, and $J(\\psi,\\omega) = \\frac{\\partial \\psi}{\\partial x}\\frac{\\partial \\omega}{\\partial y} - \\frac{\\partial \\psi}{\\partial y}\\frac{\\partial \\omega}{\\partial x}$ is the Jacobian. The velocity field is $\\mathbf{u} = \\nabla^\\perp \\psi = \\left(\\frac{\\partial \\psi}{\\partial y}, -\\frac{\\partial \\psi}{\\partial x}\\right)$. Consider the periodic box $\\Omega = [0,2\\pi)\\times[0,2\\pi)$.\n\nYour task is to construct a finite difference semi-discretization in space that preserves the discrete enstrophy at the semi-discrete level and combine it with a time integrator that preserves quadratic invariants. Specifically:\n\n- Use a uniform grid with $N_x$ points in $x$ and $N_y$ points in $y$, grid spacing $h = \\frac{2\\pi}{N_x} = \\frac{2\\pi}{N_y}$, and periodic boundary conditions in both directions.\n- Define the discrete inner product and the discrete enstrophy by\n$$\n\\langle a,b\\rangle_h = h^2 \\sum_{i=0}^{N_y-1} \\sum_{j=0}^{N_x-1} a_{i,j} b_{i,j}, \\qquad Z_h(\\omega) = \\frac{1}{2}\\langle \\omega,\\omega\\rangle_h.\n$$\n- Discretize the Jacobian $J(\\psi,\\omega)$ by a second-order, centered, skew-symmetric bilinear form on the grid that preserves the semi-discrete discrete enstrophy, that is, it must satisfy\n$$\n\\langle \\omega, J_h(\\psi,\\omega)\\rangle_h = 0\n$$\nfor all discrete fields $\\psi,\\omega$ on the grid. The construction must be consistent with the continuous Jacobian and periodic boundary conditions.\n- Advance in time with a method that preserves quadratic invariants for the resulting ordinary differential equation system in time (for example, an implicit midpoint scheme). The nonlinear solve required by the time integrator must be carried out to a tolerance sufficiently small to observe the invariant to within the requested accuracy.\n\nCompute $\\psi$ at each stage by solving the periodic Poisson equation $\\nabla^2 \\psi = -\\omega$ spectrally using the Fast Fourier Transform (FFT), with the zero-mean condition for $\\psi$ enforced.\n\nVerification requirement: Numerically verify the evolution of discrete enstrophy $Z_h$ across multiple time steps for several initial conditions and parameter choices. For each test case, report whether the enstrophy is preserved within a specified tolerance. If the initial enstrophy is nonzero, compare the relative change $\\left|\\frac{Z_h^{\\text{final}} - Z_h^{\\text{initial}}}{Z_h^{\\text{initial}}}\\right|$ to a given tolerance. If the initial enstrophy is zero, compare the absolute change $\\left|Z_h^{\\text{final}} - Z_h^{\\text{initial}}\\right|$ to a given absolute tolerance.\n\nUse the following fixed domain and stencils:\n\n- Domain: $[0,2\\pi)\\times[0,2\\pi)$.\n- Stencil: second-order centered differences on the uniform periodic grid.\n- The discrete Poisson solve must use the FFT-based spectral inversion for the Laplacian with periodic boundary conditions.\n\nTest suite and required outputs:\n\nImplement your program to run the following test cases, each specified as a tuple $(N_x, N_y, \\Delta t, \\text{steps}, \\text{ic}, \\text{rtol}, \\text{atol})$:\n\n- Case $1$ (steady shear, trivial Jacobian): $(32, 32, 0.5, 10, \\text{\"shear\"}, 10^{-10}, 10^{-12})$. Initial vorticity $\\omega_0(x,y) = \\sin(y)$.\n- Case $2$ (nontrivial dynamics): $(40, 40, 0.01, 20, \\text{\"mix\"}, 5\\times 10^{-7}, 10^{-12})$. Initial vorticity $\\omega_0(x,y) = \\sin(x) + \\sin(y) + 0.25\\cos(2x - y)$.\n- Case $3$ (zero vorticity): $(16, 16, 0.2, 5, \\text{\"zero\"}, 10^{-10}, 10^{-14})$. Initial vorticity $\\omega_0(x,y) \\equiv 0$.\n\nAngle arguments in trigonometric functions are in radians.\n\nYour program should produce a single line of output containing the results as a comma-separated list of Python booleans enclosed in square brackets, in the same order as the test cases. For example, the required format is\n\"[result1,result2,result3]\".\n\nNo user input is allowed; all parameters are fixed by this specification. The implementation must be entirely self-contained and must not read or write any external files. The final printed line is the only output your program should produce.",
            "solution": "The solution is constructed by combining a spatially-discrete operator that preserves enstrophy with a time-integrator that preserves quadratic invariants.\n\n### Spatial Discretization\nThe domain $\\Omega = [0,2\\pi) \\times [0,2\\pi)$ is discretized using a uniform grid with $N_x \\times N_y$ points. The grid spacings are $h_x = 2\\pi/N_x$ and $h_y = 2\\pi/N_y$. Discrete fields like vorticity $\\omega$ and streamfunction $\\psi$ are represented as arrays $\\omega_{i,j}$ and $\\psi_{i,j}$ on this grid.\n\n### Spectral Poisson Solver\nThe streamfunction $\\psi$ is obtained from the vorticity $\\omega$ by solving the Poisson equation $\\nabla^2 \\psi = -\\omega$ with periodic boundary conditions. A spectral method using the Fast Fourier Transform (FFT) is employed for this task due to its high accuracy and efficiency.\n1. The 2D Discrete Fourier Transform (DFT) of the equation is taken: $\\widehat{\\nabla^2 \\psi} = -\\hat{\\omega}$.\n2. The symbol of the Laplacian operator $\\nabla^2$ under DFT is $-(k_x^2 + k_y^2)$, where $k_x$ and $k_y$ are the integer wavenumbers. The equation in Fourier space becomes $-(k_x^2+k_y^2)\\hat{\\psi}_{k_x,k_y} = -\\hat{\\omega}_{k_x,k_y}$.\n3. The Fourier coefficients of the streamfunction are then $\\hat{\\psi}_{k_x,k_y} = \\frac{\\hat{\\omega}_{k_x,k_y}}{k_x^2+k_y^2}$.\n4. For the zero-wavenumber mode ($k_x=k_y=0$), the denominator is zero. To handle this, the problem specifies a zero-mean condition for $\\psi$, which sets $\\hat{\\psi}_{0,0} = 0$. This is consistent because the governing equations conserve total vorticity, meaning $\\hat{\\omega}_{0,0}$ (proportional to the mean vorticity) is constant and zero for the given initial conditions.\n5. The streamfunction $\\psi$ in physical space is recovered by applying the inverse 2D DFT to $\\hat{\\psi}$.\n\n### Enstrophy-Conserving Jacobian\nThe vorticity transport equation is $\\frac{\\partial \\omega}{\\partial t} + J(\\psi, \\omega) = 0$. In advective form, using $\\mathbf{u} = \\nabla^\\perp\\psi = (\\partial_y\\psi, -\\partial_x\\psi)$, this is equivalent to $\\frac{\\partial \\omega}{\\partial t} + \\mathbf{u} \\cdot \\nabla\\omega = 0$. To preserve the discrete enstrophy $Z_h = \\frac{1}{2}\\langle \\omega,\\omega\\rangle_h$, the discretization of the advection term, $\\text{Adv}_h(\\psi, \\omega)$, must be skew-symmetric in the sense that $\\langle \\omega, \\text{Adv}_h(\\psi, \\omega) \\rangle_h = 0$.\n\nThis property is achieved by defining $\\text{Adv}_h$ as the average of two second-order centered-difference discretizations: the **advective form** $(\\mathbf{u} \\cdot \\nabla\\omega)_h$ and the **flux form** $(\\nabla \\cdot (\\omega\\mathbf{u}))_h$. Using summation by parts on a periodic grid, one can show that $\\langle \\omega, (\\nabla \\cdot (\\omega\\mathbf{u}))_h \\rangle_h = - \\langle \\omega, (\\mathbf{u} \\cdot \\nabla\\omega)_h \\rangle_h$. Therefore, the operator $\\text{Adv}_h = \\frac{1}{2}[(\\mathbf{u} \\cdot \\nabla\\omega)_h + (\\nabla \\cdot (\\omega\\mathbf{u}))_h]$ satisfies the required skew-symmetry. The semi-discrete system is $\\frac{d\\omega_h}{dt} = -\\text{Adv}_h(\\psi_h(\\omega_h), \\omega_h)$.\n\n### Time Integration\nThe semi-discrete system $\\dot{\\omega} = F(\\omega)$ conserves the quadratic invariant $Z_h$. To preserve this at the fully discrete level, the implicit midpoint rule is used:\n$$\n\\frac{\\omega^{n+1} - \\omega^n}{\\Delta t} = F\\left(\\frac{\\omega^{n+1} + \\omega^n}{2}\\right)\n$$\nThis nonlinear equation for $\\omega^{n+1}$ is solved using a fixed-point iteration, starting with an initial guess $\\omega^{(0)} = \\omega^n$ and iterating until convergence, which ensures accurate preservation of the enstrophy invariant.\n\n### Verification\nThe implementation is verified against three test cases. For each, the discrete enstrophy is calculated at the initial and final times ($Z_h^{\\text{initial}}$ and $Z_h^{\\text{final}}$) and checked against the provided tolerances. The steady shear flow case should conserve enstrophy to machine precision. The nontrivial case should conserve it to high accuracy, limited by the nonlinear solver tolerance. The zero vorticity case should maintain zero enstrophy.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the structure-preserving solver for the 2D Euler equations.\n    \"\"\"\n\n    def solve_poisson_spectral(omega, Nx, Ny):\n        \"\"\"\n        Solves the periodic Poisson equation nabla^2(psi) = -omega using FFTs.\n        Enforces a zero-mean condition on psi.\n        \"\"\"\n        omega_hat = np.fft.fft2(omega)\n        \n        kx = np.fft.fftfreq(Nx) * Nx\n        ky = np.fft.fftfreq(Ny) * Ny\n        KX, KY = np.meshgrid(kx, ky)\n        \n        # In Fourier space: -(KX^2 + KY^2) * psi_hat = -omega_hat\n        # So, psi_hat = omega_hat / (KX^2 + KY^2)\n        lap_denom = KX**2 + KY**2\n        \n        psi_hat = np.zeros_like(omega_hat)\n        \n        # Avoid division by zero at the zero-frequency mode (kx=ky=0)\n        non_zero_k = lap_denom != 0\n        psi_hat[non_zero_k] = omega_hat[non_zero_k] / lap_denom[non_zero_k]\n        \n        # The psi_hat[0, 0] = 0 condition enforces mean(psi) = 0.\n        \n        psi = np.real(np.fft.ifft2(psi_hat))\n        return psi\n\n    def get_advection_operator(psi, omega, hx, hy):\n        \"\"\"\n        Computes the advection term u.grad(omega) using a second-order,\n        enstrophy-conserving finite difference scheme.\n        u = (d(psi)/dy, -d(psi)/dx)\n        \"\"\"\n        # Second-order centered difference operators with periodic boundaries\n        def d_dx(f):\n            return (np.roll(f, -1, axis=1) - np.roll(f, 1, axis=1)) / (2.0 * hx)\n        \n        def d_dy(f):\n            return (np.roll(f, -1, axis=0) - np.roll(f, 1, axis=0)) / (2.0 * hy)\n        \n        u = d_dy(psi)\n        v = -d_dx(psi)\n        \n        # Advective form: A = u * d/dx(omega) + v * d/dy(omega)\n        advective_form = u * d_dx(omega) + v * d_dy(omega)\n        \n        # Flux form: C = d/dx(u*omega) + d/dy(v*omega)\n        flux_form = d_dx(u * omega) + d_dy(v * omega)\n\n        # The skew-symmetric operator is the average of the two forms.\n        return 0.5 * (advective_form + flux_form)\n\n    def take_time_step(omega_n, dt, hx, hy, Nx, Ny):\n        \"\"\"\n        Advances the vorticity field by one time step using the implicit midpoint rule.\n        The nonlinear system is solved using a fixed-point iteration.\n        \"\"\"\n        # ODE: d(omega)/dt = -u.grad(omega) = F(omega)\n        # Implicit Midpoint: (w^{n+1} - w^n)/dt = F((w^{n+1} + w^n)/2)\n        # Fixed point iteration for w^{n+1}:\n        # w_k_new = w^n + dt * F((w_k + w^n)/2)\n        \n        omega_k = np.copy(omega_n)\n        \n        max_iter = 100\n        tol = 1e-15  # Tight tolerance for the nonlinear solve\n\n        for _ in range(max_iter):\n            omega_mid = (omega_k + omega_n) / 2.0\n            psi_mid = solve_poisson_spectral(omega_mid, Nx, Ny)\n            F_mid = -get_advection_operator(psi_mid, omega_mid, hx, hy)\n            \n            omega_k_new = omega_n + dt * F_mid\n            \n            if np.linalg.norm(omega_k_new - omega_k)  tol:\n                return omega_k_new\n            \n            omega_k = omega_k_new\n            \n        return omega_k\n\n    test_cases = [\n        (32, 32, 0.5, 10, \"shear\", 1e-10, 1e-12),\n        (40, 40, 0.01, 20, \"mix\", 5e-7, 1e-12),\n        (16, 16, 0.2, 5, \"zero\", 1e-10, 1e-14),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        Nx, Ny, dt, steps, ic_name, rtol, atol = case\n        \n        L = 2.0 * np.pi\n        hx = L / Nx\n        hy = L / Ny\n        \n        x = np.arange(Nx) * hx\n        y = np.arange(Ny) * hy\n        X, Y = np.meshgrid(x, y)\n        \n        if ic_name == \"shear\":\n            omega0 = np.sin(Y)\n        elif ic_name == \"mix\":\n            omega0 = np.sin(X) + np.sin(Y) + 0.25 * np.cos(2*X - Y)\n        else: # \"zero\"\n            omega0 = np.zeros((Ny, Nx))\n            \n        def get_enstrophy(omega, hx, hy):\n            return 0.5 * hx * hy * np.sum(omega**2)\n\n        Z0 = get_enstrophy(omega0, hx, hy)\n        \n        omega = np.copy(omega0)\n        for _ in range(steps):\n            omega = take_time_step(omega, dt, hx, hy, Nx, Ny)\n            \n        Zf = get_enstrophy(omega, hx, hy)\n        \n        is_preserved = False\n        if np.isclose(Z0, 0.0):\n            is_preserved = np.abs(Zf - Z0) = atol\n        else:\n            relative_change = np.abs((Zf - Z0) / Z0)\n            is_preserved = relative_change = rtol\n            \n        results.append(is_preserved.item())\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Our final practice extends the concept of structure preservation from closed, energy-conserving systems to open systems that exchange energy with their environment. We will model an Euler-Bernoulli beam using the powerful port-Hamiltonian (pH) framework, which explicitly separates the stored energy (Hamiltonian) from the power flowing through boundary ports. Your task is to implement a staggered-grid discretization that satisfies a discrete summation-by-parts property, creating a 'discrete Dirac structure' that guarantees the rate of change of the system's energy is exactly equal to the power supplied at the boundaries. This exercise introduces a cutting-edge methodology for the modeling and simulation of complex engineering systems where energy management is critical. ",
            "id": "3450190",
            "problem": "Design, analyze, and implement a structure-preserving semi-discretization and time discretization for the one-dimensional Euler–Bernoulli beam in a port-Hamiltonian (pH) formulation, such that the discrete power balance identity holds exactly at the semi-discrete level and matches the midpoint boundary work at the fully discrete level. The goal is to ensure that the discrete Hamiltonian satisfies a balance of the form $\\frac{dH}{dt}=\\text{boundary power}$, with exact exchange at the boundaries via a discrete Dirac structure built from staggered-grid operators satisfying a summation-by-parts identity.\n\nStart from the following fundamental base: the Euler–Bernoulli beam can be written in a pH form using the momentum density $p$ and the curvature $\\kappa$ as state variables, with co-energy variables $v$ (transverse velocity) and $m$ (bending moment) related by $v=\\frac{1}{\\rho A}p$ and $m=EI\\,\\kappa$, where $\\rho A$ is the linear mass density and $EI$ is the bending stiffness. The Hamiltonian is\n$$\nH=\\int_0^L \\frac{1}{2\\rho A}\\,p^2 + \\frac{EI}{2}\\,\\kappa^2 \\, dx,\n$$\nand the pH dynamics (in Stokes–Dirac form) can be written equivalently as the first-order spatial system\n$$\n\\partial_t p = -\\partial_x q,\\quad \\partial_t \\kappa = \\partial_x s,\\quad q=\\partial_x m,\\quad s=\\partial_x v,\n$$\nwhich yields the continuous power balance\n$$\n\\frac{dH}{dt} = \\bigl(m\\,s - v\\,q\\bigr)\\big|_{x=L} - \\bigl(m\\,s - v\\,q\\bigr)\\big|_{x=0}.\n$$\nThe quantity $m\\,s - v\\,q$ is the boundary port power density, with two conjugate pairs at each boundary.\n\nConstruct a one-dimensional staggered-grid semi-discretization that preserves this power identity exactly in space. Use a uniform mesh with $N$ control volumes (cells) of width $h=L/N$, with cell centers at $x_i=(i+\\tfrac{1}{2})h$ for $i=0,\\dots,N-1$ and faces at $x_j=jh$ for $j=0,\\dots,N$. Place the energy variables $p_i$ and $\\kappa_i$ at centers and the flows $s_j$ and $q_j$ at faces. Define the discrete gradient acting from centers to interior faces,\n$$\n(G v)_j=\\frac{v_j - v_{j-1}}{h},\\quad j=1,\\dots,N-1,\n$$\nand the discrete divergence acting from faces to centers,\n$$\n(D f)_i=\\frac{f_{i+1}-f_i}{h},\\quad i=0,\\dots,N-1.\n$$\nYou may regard $G$ as an $(N-1)\\times N$ matrix and $D$ as an $N\\times(N+1)$ matrix. Enforce the kinematic and constitutive laws at the discrete level by $v=\\frac{1}{\\rho A}p$, $m=EI\\,\\kappa$, $s_j=(G v)_j$ for $j=1,\\dots,N-1$, and $q_j=(G m)_j$ for $j=1,\\dots,N-1$, while treating the boundary flows $s_0,s_N,q_0,q_N$ at $j=0$ and $j=N$ as external port variables. The semi-discrete dynamics must be\n$$\n\\dot p = -D q,\\qquad \\dot \\kappa = D s,\n$$\nwith the discrete Hamiltonian\n$$\nH_h = \\frac{h}{2}\\sum_{i=0}^{N-1}\\left(\\frac{1}{\\rho A}p_i^2 + EI\\,\\kappa_i^2\\right).\n$$\nShow, using only discrete summation-by-parts and linearity of $G$ and $D$, that\n$$\n\\frac{dH_h}{dt} = \\bigl(m_{N-1}\\,s_N - v_{N-1}\\,q_N\\bigr) + \\bigl(v_0\\,q_0 - m_0\\,s_0\\bigr),\n$$\nthat is, the semi-discrete energy rate equals the discrete boundary power involving only boundary flows and the adjacent co-energy variables at the nearest cell centers. This is the defining property of a discrete Dirac structure in this setting.\n\nNext, design a time discretization that preserves this power exchange at the time-discrete level for quadratic Hamiltonians. Use the implicit midpoint method applied to the linear time-invariant semi-discrete system with midpoint evaluation of the boundary inputs, i.e., for a time step of size $\\Delta t$, define\n$$\ny^{n+1} = y^n + \\Delta t\\,F\\!\\left(\\tfrac{y^{n+1}+y^n}{2},\\,u^{n+\\frac{1}{2}}\\right),\n$$\nwhere $y=[p;\\kappa]$ collects the center variables, $F$ is the right-hand side induced by $D$ and $G$ with boundary flows included as affine terms, and $u^{n+\\frac{1}{2}}$ denotes the boundary flows evaluated at $t^{n+\\frac{1}{2}}$. For a quadratic Hamiltonian and linear dynamics, this method should preserve the discrete power balance in the sense\n$$\nH_h^{n+1}-H_h^n = \\Delta t\\,P_{\\text{bdry}}^{n+\\frac{1}{2}},\n$$\nwhere $P_{\\text{bdry}}^{n+\\frac{1}{2}}$ is the discrete boundary power computed from midpoint co-energy variables and midpoint boundary flows. Implement this method so that the observable discrepancy\n$$\n\\Delta = H_h(T) - H_h(0) - \\int_0^T P_{\\text{bdry}}(t)\\,dt\n$$\nis numerically negligible, when the integral is approximated consistently by the midpoint rule per time step.\n\nImplementation details and test suite requirements:\n- Use $L=1$ so that $h=1/N$.\n- Use the cell-center initial conditions $p_i(0)=\\sin(\\pi x_i)$ and $\\kappa_i(0)=\\cos(2\\pi x_i)$, with $x_i=(i+\\tfrac{1}{2})h$.\n- Use the following three tests. In all tests, report the single scalar discrepancy\n$$\n\\left|\\;H_h(T) - H_h(0) - \\sum_{n=0}^{M-1} \\Delta t\\;P_{\\text{bdry}}^{n+\\frac{1}{2}}\\;\\right|\n$$\nas a floating-point number, where $M=T/\\Delta t$ is an integer. Express the output values as dimensionless decimals.\n  - Test A (closed boundary, happy path): $N=80$, $\\rho A=1$, $EI=1$, $\\Delta t=10^{-3}$, $T=1$ (so $M=1000$). Boundary flows $s_0(t)=0$, $s_N(t)=0$, $q_0(t)=0$, $q_N(t)=0$.\n  - Test B (one-sided actuation): $N=60$, $\\rho A=2$, $EI=3$, $\\Delta t=5\\times 10^{-4}$, $T=1$ (so $M=2000$). Boundary flows $s_0(t)=\\sin(2\\pi t)$, $s_N(t)=0$, $q_0(t)=0$, $q_N(t)=0.7\\cos(2\\pi t)$.\n  - Test C (all ports excited, edge-case frequencies): $N=40$, $\\rho A=1.5$, $EI=0.8$, $\\Delta t=10^{-3}$, $T=1$ (so $M=1000$). Boundary flows $s_0(t)=\\sin(10 t)$, $s_N(t)=0.3\\cos(6 t)$, $q_0(t)=0.5\\sin(5 t)$, $q_N(t)=0.2\\sin(3 t)$.\n- Your program must assemble the staggered operators $G$ and $D$, construct the linear midpoint step for the state $y=[p;\\kappa]$, evaluate the boundary power at midpoints using the co-energy variables $v=\\frac{1}{\\rho A}p$ and $m=EI\\,\\kappa$ at the adjacent cells, accumulate the midpoint boundary work, and return the final discrepancy for each test.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[resultA,resultB,resultC]\"), in the order Test A, Test B, Test C.\n\nYour solution should justify from first principles why the semi-discrete energy identity holds by a discrete summation-by-parts argument and why the implicit midpoint rule with midpoint boundary evaluation preserves the quadratic power balance at the time-discrete level. Keep all mathematical entities, including numbers, in LaTeX notation. No physical units are required since the outputs are dimensionless discrepancies. The final printed values must be decimals.",
            "solution": "### Semi-Discrete Power Balance\n\nWe show that the semi-discrete system preserves the power-balanced structure of the continuous pH system. We start by computing the time derivative of the discrete Hamiltonian, $H_h$.\n$$\n\\frac{dH_h}{dt} = \\frac{h}{2}\\sum_{i=0}^{N-1}\\left(\\frac{2}{\\rho A}p_i\\dot{p_i} + 2EI\\,\\kappa_i\\dot{\\kappa_i}\\right) = h\\sum_{i=0}^{N-1}\\left(\\frac{1}{\\rho A}p_i\\dot{p_i} + EI\\,\\kappa_i\\dot{\\kappa_i}\\right).\n$$\nUsing the discrete co-energy relations $v_i = \\frac{1}{\\rho A}p_i$ and $m_i = EI\\,\\kappa_i$, we have\n$$\n\\frac{dH_h}{dt} = h\\sum_{i=0}^{N-1}\\left(v_i\\dot{p_i} + m_i\\dot{\\kappa_i}\\right).\n$$\nWe substitute the semi-discrete dynamics, $\\dot p = -D q$ and $\\dot \\kappa = D s$:\n$$\n\\frac{dH_h}{dt} = h\\sum_{i=0}^{N-1}\\left(v_i(-Dq)_i + m_i(Ds)_i\\right) = -h\\sum_{i=0}^{N-1}v_i(Dq)_i + h\\sum_{i=0}^{N-1}m_i(Ds)_i.\n$$\nThe core of the proof lies in applying a discrete summation-by-parts (SBP) property. Analyzing the first term involving $Dq$, where $(Dq)_i = \\frac{q_{i+1}-q_i}{h}$:\n$$\nh\\sum_{i=0}^{N-1}v_i(Dq)_i = \\sum_{i=0}^{N-1}v_i(q_{i+1} - q_i) = v_0(q_1-q_0) + \\dots + v_{N-1}(q_N-q_{N-1}).\n$$\nRearranging the terms by the index of $q$:\n$$\n= -v_0q_0 + (v_0-v_1)q_1 + \\dots + (v_{N-2}-v_{N-1})q_{N-1} + v_{N-1}q_N.\n$$\nUsing the discrete gradient $(Gv)_j = \\frac{v_j-v_{j-1}}{h}$, we can write $v_{j-1}-v_j = -h(Gv)_j$. This yields the SBP identity:\n$$\nh\\sum_{i=0}^{N-1}v_i(Dq)_i = v_{N-1}q_N - v_0q_0 - h\\sum_{j=1}^{N-1}(Gv)_j q_j.\n$$\nBy analogy, the SBP identity for the term involving $m_i(Ds)_i$ is:\n$$\nh\\sum_{i=0}^{N-1}m_i(Ds)_i = m_{N-1}s_N - m_0s_0 - h\\sum_{j=1}^{N-1}(Gm)_j s_j.\n$$\nSubstituting these back into the expression for $\\frac{dH_h}{dt}$ and using the interior flow relations $s_j = (Gv)_j$ and $q_j = (Gm)_j$:\n$$\n\\frac{dH_h}{dt} = -\\left(v_{N-1}q_N - v_0q_0 - h\\sum_{j=1}^{N-1}s_j q_j\\right) + \\left(m_{N-1}s_N - m_0s_0 - h\\sum_{j=1}^{N-1}q_j s_j\\right).\n$$\nThe two summation terms are identical and cancel each other out ($h\\sum s_j q_j - h\\sum q_j s_j = 0$), representing internal power conservation. We are left with only the boundary terms:\n$$\n\\frac{dH_h}{dt} = v_0q_0 - v_{N-1}q_N + m_{N-1}s_N - m_0s_0 = \\bigl(m_{N-1}s_N - v_{N-1}q_N\\bigr) + \\bigl(v_0q_0 - m_0s_0\\bigr) = P_{\\text{bdry}}.\n$$\nThis demonstrates that the rate of change of the discrete Hamiltonian is exactly equal to the power supplied at the boundaries.\n\n### Fully-Discrete Power Balance\n\nThe semi-discrete system is a linear ODE $\\dot{y} = Ay + Bu$. The discrete Hamiltonian is a quadratic form $H_h(y) = \\frac{1}{2}y^T Q y$. The system being Hamiltonian implies $A^T Q + Q A = 0$. The implicit midpoint rule is:\n$$\n\\frac{y^{n+1}-y^n}{\\Delta t} = A\\left(\\frac{y^n+y^{n+1}}{2}\\right) + B u^{n+\\frac{1}{2}}.\n$$\nThe change in the discrete Hamiltonian over one time step is:\n$$\nH_h(y^{n+1}) - H_h(y^n) = \\frac{1}{2}(y^{n+1}-y^n)^T Q (y^{n+1}+y^n) = (y^{n+1}-y^n)^T Q y^{n+\\frac{1}{2}}.\n$$\nSubstituting the midpoint rule expression for $y^{n+1}-y^n$:\n$$\nH_h(y^{n+1}) - H_h(y^n) = \\Delta t (Ay^{n+\\frac{1}{2}} + Bu^{n+\\frac{1}{2}})^T Q y^{n+\\frac{1}{2}} = \\Delta t \\left( (y^{n+\\frac{1}{2}})^T A^T Q y^{n+\\frac{1}{2}} + (u^{n+\\frac{1}{2}})^T B^T Q y^{n+\\frac{1}{2}} \\right).\n$$\nThe first term is zero due to the skew-adjoint property of $A$: $(y^{n+\\frac{1}{2}})^T A^T Q y^{n+\\frac{1}{2}} = \\frac{1}{2}(y^{n+\\frac{1}{2}})^T (A^T Q + QA) y^{n+\\frac{1}{2}} = 0$. We are left with the work done by the boundary inputs:\n$$\nH_h(y^{n+1}) - H_h(y^n) = \\Delta t \\, (u^{n+\\frac{1}{2}})^T B^T Q y^{n+\\frac{1}{2}} = \\Delta t P_{\\text{bdry}}^{n+\\frac{1}{2}}.\n$$\nThe term on the right is precisely the discrete boundary power evaluated with midpoint values. Summing this relation from $n=0$ to $M-1$ gives $H_h(T) - H_h(0) = \\sum \\Delta t P_{\\text{bdry}}^{n+\\frac{1}{2}}$. Consequently, the numerical discrepancy must be zero up to machine precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, bmat, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef run_test(N, rhoA, EI, dt, T, s0_func, sN_func, q0_func, qN_func):\n    \"\"\"\n    Runs a single test case for the structure-preserving discretization of the Euler-Bernoulli beam.\n\n    Args:\n        N (int): Number of control volumes.\n        rhoA (float): Linear mass density.\n        EI (float): Bending stiffness.\n        dt (float): Time step size.\n        T (float): Total simulation time.\n        s0_func (callable): Boundary flow s_0(t).\n        sN_func (callable): Boundary flow s_N(t).\n        q0_func (callable): Boundary flow q_0(t).\n        qN_func (callable): Boundary flow q_N(t).\n\n    Returns:\n        float: The absolute numerical discrepancy in the energy balance.\n    \"\"\"\n    # 1. Setup Grid and Parameters\n    L = 1.0\n    h = L / N\n    M = int(round(T / dt))\n\n    # Cell-center coordinates\n    x_centers = (np.arange(N) + 0.5) * h\n\n    # 2. Initial Conditions\n    p_current = np.sin(np.pi * x_centers)\n    kappa_current = np.cos(2 * np.pi * x_centers)\n    \n    # State vector y = [p; kappa]\n    y_current = np.concatenate([p_current, kappa_current])\n\n    def calculate_hamiltonian(p, kappa):\n        energy_p = 0.5 * (1.0 / rhoA) * p**2\n        energy_kappa = 0.5 * EI * kappa**2\n        return h * np.sum(energy_p + energy_kappa)\n\n    H_initial = calculate_hamiltonian(p_current, kappa_current)\n    total_boundary_work = 0.0\n\n    # 3. Assemble System Matrices for Implicit Midpoint Rule\n    # The linear system to be solved at each step is:\n    # [ 2*I    (dt*EI/h^2)*K ] [p_mid] = [RHS_p]\n    # [ -(dt/rhoA/h^2)*K  2*I ] [k_mid] = [RHS_k]\n    # where K is the discrete 2nd derivative operator with Neumann BCs.\n\n    # Construct the NxN matrix K\n    diagonals = [-1 * np.ones(N - 1), 2 * np.ones(N), -1 * np.ones(N - 1)]\n    offsets = [-1, 0, 1]\n    K = diags(diagonals, offsets, shape=(N, N), format='csc')\n    K[0, 0] = 1.0\n    K[0, 1] = -1.0\n    K[N-1, N-2] = -1.0\n    K[N-1, N-1] = 1.0\n\n    # Construct the 2N x 2N LHS matrix for the midpoint solve\n    I_N = csc_matrix(diags([np.ones(N)], [0]))\n    zeros_N = csc_matrix((N, N))\n    \n    A_pk = (dt * EI / h**2) * K\n    A_kp = -(dt / (rhoA * h**2)) * K\n\n    LHS_matrix = bmat([\n        [2 * I_N, A_pk],\n        [A_kp, 2 * I_N]\n    ], format='csc')\n\n    # 4. Time Stepping Loop\n    for n in range(M):\n        t_mid = (n + 0.5) * dt\n\n        # a. Evaluate boundary inputs at midpoint time\n        s0_mid = s0_func(t_mid)\n        sN_mid = sN_func(t_mid)\n        q0_mid = q0_func(t_mid)\n        qN_mid = qN_func(t_mid)\n        \n        # b. Construct RHS vector for the midpoint solve\n        p_n = y_current[:N]\n        kappa_n = y_current[N:]\n        \n        RHS_p = 2 * p_n\n        RHS_p[0] += (dt / h) * q0_mid\n        RHS_p[N - 1] -= (dt / h) * qN_mid\n        \n        RHS_kappa = 2 * kappa_n\n        RHS_kappa[0] -= (dt / h) * s0_mid\n        RHS_kappa[N - 1] += (dt / h) * sN_mid\n        \n        RHS_vector = np.concatenate([RHS_p, RHS_kappa])\n\n        # c. Solve for midpoint state variables y_mid = [p_mid; kappa_mid]\n        y_mid = spsolve(LHS_matrix, RHS_vector)\n        p_mid = y_mid[:N]\n        kappa_mid = y_mid[N:]\n        \n        # d. Calculate co-energy variables at midpoint\n        v_mid = (1.0 / rhoA) * p_mid\n        m_mid = EI * kappa_mid\n        \n        # e. Calculate boundary power at midpoint\n        power_boundary_mid = (m_mid[N-1] * sN_mid - v_mid[N-1] * qN_mid) + \\\n                             (v_mid[0] * q0_mid - m_mid[0] * s0_mid)\n\n        # f. Accumulate boundary work\n        total_boundary_work += dt * power_boundary_mid\n\n        # g. Update state to the next time step y_next = 2*y_mid - y_current\n        y_next = 2 * y_mid - y_current\n        y_current = y_next\n\n    # 5. Final Calculation\n    p_final = y_current[:N]\n    kappa_final = y_current[N:]\n    H_final = calculate_hamiltonian(p_final, kappa_final)\n\n    discrepancy = np.abs(H_final - H_initial - total_boundary_work)\n    \n    return discrepancy\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases specified in the problem statement.\n    \"\"\"\n    # Test cases: (N, rhoA, EI, dt, T, s0, sN, q0, qN)\n    test_cases = [\n        # Test A: Closed boundary\n        (80, 1.0, 1.0, 1e-3, 1.0,\n         lambda t: 0.0, lambda t: 0.0, lambda t: 0.0, lambda t: 0.0),\n        \n        # Test B: One-sided actuation\n        (60, 2.0, 3.0, 5e-4, 1.0,\n         lambda t: np.sin(2 * np.pi * t), lambda t: 0.0,\n         lambda t: 0.0, lambda t: 0.7 * np.cos(2 * np.pi * t)),\n\n        # Test C: All ports excited\n        (40, 1.5, 0.8, 1e-3, 1.0,\n         lambda t: np.sin(10 * t), lambda t: 0.3 * np.cos(6 * t),\n         lambda t: 0.5 * np.sin(5 * t), lambda t: 0.2 * np.sin(3 * t))\n    ]\n\n    results = []\n    for case in test_cases:\n        N, rhoA, EI, dt, T, s0, sN, q0, qN = case\n        discrepancy = run_test(N, rhoA, EI, dt, T, s0, sN, q0, qN)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}