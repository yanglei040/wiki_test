{
    "hands_on_practices": [
        {
            "introduction": "Our journey into the practical effects of the Péclet number begins with a foundational theoretical analysis. Before implementing any numerical scheme, we must understand its stability properties. This exercise uses von Neumann stability analysis to explore how the interplay between the advection speed, diffusivity, and grid spacing dictates the stability limits of explicit time-stepping schemes, revealing a critical Péclet number where the behavior of central and upwind differencing intersects for high-frequency modes .",
            "id": "3430240",
            "problem": "Consider the one-dimensional constant-coefficient advection–diffusion partial differential equation (PDE)\n$$u_{t} + a\\,u_{x} = \\nu\\,u_{xx},$$\non a uniform periodic grid with spacing $h$, where $a \\neq 0$ is the advection speed and $\\nu  0$ is the kinematic viscosity. Let $u_{j}(t)$ denote the semi-discrete solution at grid index $j$ and time $t$. Approximate the spatial derivatives using either:\n- second-order central difference for advection, $D_{0}u_{j} = \\frac{u_{j+1} - u_{j-1}}{2 h}$, or\n- first-order upwind difference for advection (assume $a0$), $D_{-}u_{j} = \\frac{u_{j} - u_{j-1}}{h}$,\nand in both cases use the second-order central difference for diffusion, $D_{xx} u_{j} = \\frac{u_{j+1} - 2 u_{j} + u_{j-1}}{h^{2}}$.\n\nTime advance the resulting semi-discrete ordinary differential equation with the Forward Euler (FE) method, the amplification factor of which is $G = 1 + \\Delta t\\,\\lambda(\\theta)$ on the Fourier mode $u_{j}(t) \\propto \\exp(i j \\theta)$, where $\\lambda(\\theta)$ is the semi-discrete spatial Fourier symbol and $\\theta \\in [0, \\pi]$ is the dimensionless wave number. Define the Courant–Friedrichs–Lewy (CFL) number $\\mathrm{CFL} = \\frac{|a| \\Delta t}{h}$ and the cell Peclet number $Pe_{h} = \\frac{|a| h}{2 \\nu}$.\n\nUsing von Neumann analysis, derive for the mode $\\theta = \\frac{\\pi}{2}$ the squared magnitude $|G|^{2}$ of the FE amplification factor for the central-advection and upwind-advection spatial discretizations. Enforce the non-amplification condition $|G|^{2} \\leq 1$ to obtain the boundary values $\\mathrm{CFL}^{\\star}_{\\mathrm{central}}(Pe_{h})$ and $\\mathrm{CFL}^{\\star}_{\\mathrm{upwind}}(Pe_{h})$ at which $|G|^{2} = 1$ for $\\theta = \\frac{\\pi}{2}$.\n\nFinally, determine the unique $Pe_{h}^{\\star}$ such that $\\mathrm{CFL}^{\\star}_{\\mathrm{central}}(Pe_{h}^{\\star}) = \\mathrm{CFL}^{\\star}_{\\mathrm{upwind}}(Pe_{h}^{\\star})$. Interpret this $Pe_{h}^{\\star}$ as the indifferent threshold in choosing between the central and upwind spatial schemes under Forward Euler at $\\theta = \\frac{\\pi}{2}$. Express your final answer as a closed-form analytic expression for $Pe_{h}^{\\star}$. No rounding is required, and the answer is dimensionless.",
            "solution": "The user wants to solve a numerical analysis problem involving the stability of finite difference schemes for the one-dimensional advection-diffusion equation.\n\n### Step 1: Extract Givens\n- **PDE**: $u_{t} + a\\,u_{x} = \\nu\\,u_{xx}$, with $a \\neq 0$ and $\\nu  0$.\n- **Grid**: Uniform, periodic, spacing $h$.\n- **Spatial Operators**:\n  - Central Advection ($D_{0}$): $\\frac{u_{j+1} - u_{j-1}}{2 h}$.\n  - Upwind Advection ($D_{-}$, for $a0$): $\\frac{u_{j} - u_{j-1}}{h}$.\n  - Central Diffusion ($D_{xx}$): $\\frac{u_{j+1} - 2 u_{j} + u_{j-1}}{h^{2}}$.\n- **Time Integration**: Forward Euler (FE), with amplification factor $G = 1 + \\Delta t\\,\\lambda(\\theta)$.\n- **Fourier Analysis**: The solution is decomposed into modes $u_{j}(t) \\propto \\exp(i j \\theta)$, where $\\theta \\in [0, \\pi]$ is the dimensionless wave number and $\\lambda(\\theta)$ is the Fourier symbol of the spatial operator.\n- **Definitions**:\n  - Courant–Friedrichs–Lewy (CFL) number: $\\mathrm{CFL} = \\frac{|a| \\Delta t}{h}$.\n  - Cell Peclet number: $Pe_{h} = \\frac{|a| h}{2 \\nu}$.\n- **Task**:\n  1. For the mode $\\theta = \\frac{\\pi}{2}$, derive the squared magnitude of the amplification factor, $|G|^{2}$, for both central-advection and upwind-advection schemes.\n  2. Enforce the non-amplification condition $|G|^{2} = 1$ to find the stability boundaries $\\mathrm{CFL}^{\\star}_{\\mathrm{central}}(Pe_{h})$ and $\\mathrm{CFL}^{\\star}_{\\mathrm{upwind}}(Pe_{h})$.\n  3. Find the unique value $Pe_{h}^{\\star}$ where $\\mathrm{CFL}^{\\star}_{\\mathrm{central}}(Pe_{h}^{\\star}) = \\mathrm{CFL}^{\\star}_{\\mathrm{upwind}}(Pe_{h}^{\\star})$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is a standard exercise in the von Neumann stability analysis of numerical schemes for partial differential equations. All terms ($u_t$, $u_x$, $u_{xx}$, CFL number, Peclet number, Forward Euler, central/upwind differencing) are standard in the field of numerical analysis and computational fluid dynamics. The problem is self-contained, with all necessary definitions and constants provided. The derivation path is logical and leads to a single, well-defined quantity, $Pe_{h}^{\\star}$. The problem is scientifically grounded, well-posed, and objective. There are no contradictions, ambiguities, or factual errors.\n\n### Step 3: Verdict and Action\nThe problem is valid. The solution proceeds as follows.\n\nThe semi-discrete form of the PDE is $\\frac{du_j}{dt} = \\mathcal{L}u_j$, where $\\mathcal{L}$ is the spatial discretization operator. The Fourier symbol $\\lambda(\\theta)$ of $\\mathcal{L}$ is found by applying the operator to a single Fourier mode $u_j = \\exp(ij\\theta)$.\n\n**1. Derivation of Fourier Symbols**\n\nFor the central-advection scheme, the operator is $\\mathcal{L}_{\\mathrm{central}} = -a D_0 + \\nu D_{xx}$. Applying this to $u_j=\\exp(ij\\theta)$:\n$$ \\mathcal{L}_{\\mathrm{central}} u_j = \\left( -a \\frac{\\exp(i\\theta) - \\exp(-i\\theta)}{2h} + \\nu \\frac{\\exp(i\\theta) - 2 + \\exp(-i\\theta)}{h^2} \\right) u_j $$\n$$ \\lambda_{\\mathrm{central}}(\\theta) = -a \\frac{2i\\sin\\theta}{2h} + \\nu \\frac{2\\cos\\theta - 2}{h^2} = -\\frac{ia\\sin\\theta}{h} - \\frac{2\\nu(1-\\cos\\theta)}{h^2} $$\n\nFor the upwind-advection scheme (with $a0$), the operator is $\\mathcal{L}_{\\mathrm{upwind}} = -a D_{-} + \\nu D_{xx}$. Applying this to $u_j=\\exp(ij\\theta)$:\n$$ \\mathcal{L}_{\\mathrm{upwind}} u_j = \\left( -a \\frac{1 - \\exp(-i\\theta)}{h} + \\nu \\frac{\\exp(i\\theta) - 2 + \\exp(-i\\theta)}{h^2} \\right) u_j $$\n$$ \\lambda_{\\mathrm{upwind}}(\\theta) = -\\frac{a(1-\\cos\\theta+i\\sin\\theta)}{h} - \\frac{2\\nu(1-\\cos\\theta)}{h^2} $$\n\n**2. Evaluation at a Specific Wavenumber $\\theta = \\frac{\\pi}{2}$**\n\nAt $\\theta = \\frac{\\pi}{2}$, we have $\\sin(\\frac{\\pi}{2}) = 1$ and $\\cos(\\frac{\\pi}{2}) = 0$.\nThe Fourier symbols become:\n$$ \\lambda_{\\mathrm{central}}\\left(\\frac{\\pi}{2}\\right) = -\\frac{ia}{h} - \\frac{2\\nu}{h^2} = -\\frac{2\\nu}{h^2} - i\\frac{a}{h} $$\n$$ \\lambda_{\\mathrm{upwind}}\\left(\\frac{\\pi}{2}\\right) = -\\frac{a(1+i)}{h} - \\frac{2\\nu}{h^2} = -\\left(\\frac{a}{h} + \\frac{2\\nu}{h^2}\\right) - i\\frac{a}{h} $$\n\n**3. Amplification Factor and Stability Boundary**\n\nThe amplification factor for the Forward Euler method is $G = 1 + \\Delta t \\lambda$. The stability condition is $|G|^2 \\leq 1$. The boundary of the stability region is given by $|G|^2 = 1$. Let $\\lambda = \\lambda_R + i\\lambda_I$.\n$$ |1 + \\Delta t(\\lambda_R + i\\lambda_I)|^2 = (1 + \\Delta t \\lambda_R)^2 + (\\Delta t \\lambda_I)^2 = 1 $$\n$$ 1 + 2\\Delta t \\lambda_R + (\\Delta t)^2 \\lambda_R^2 + (\\Delta t)^2 \\lambda_I^2 = 1 $$\n$$ 2\\Delta t \\lambda_R + (\\Delta t)^2 (\\lambda_R^2 + \\lambda_I^2) = 0 $$\nSince $\\Delta t  0$, we can divide by it to find the time step $\\Delta t^{\\star}$ on the stability boundary:\n$$ \\Delta t^{\\star} = \\frac{-2\\lambda_R}{\\lambda_R^2 + \\lambda_I^2} = \\frac{-2\\Re(\\lambda)}{|\\lambda|^2} $$\n\n**For the central scheme at $\\theta = \\frac{\\pi}{2}$**:\n$\\lambda_R = -\\frac{2\\nu}{h^2}$ and $\\lambda_I = -\\frac{a}{h}$.\n$$ \\Delta t^{\\star}_{\\mathrm{central}} = \\frac{-2(-\\frac{2\\nu}{h^2})}{(-\\frac{2\\nu}{h^2})^2 + (-\\frac{a}{h})^2} = \\frac{\\frac{4\\nu}{h^2}}{\\frac{4\\nu^2}{h^4} + \\frac{a^2}{h^2}} = \\frac{4\\nu h^2}{4\\nu^2 + a^2 h^2} $$\nThe critical CFL number is $\\mathrm{CFL}^{\\star} = \\frac{|a| \\Delta t^{\\star}}{h}$. Since $a0$, $|a|=a$.\n$$ \\mathrm{CFL}^{\\star}_{\\mathrm{central}} = \\frac{a}{h} \\frac{4\\nu h^2}{4\\nu^2 + a^2 h^2} = \\frac{4a\\nu h}{4\\nu^2 + a^2 h^2} $$\nUsing the cell Peclet number $Pe_h = \\frac{ah}{2\\nu}$, which means $\\frac{1}{Pe_h} = \\frac{2\\nu}{ah}$.\nDivide the numerator and denominator by $a^2 h^2$:\n$$ \\mathrm{CFL}^{\\star}_{\\mathrm{central}} = \\frac{4\\nu/(ah)}{4\\nu^2/(a^2 h^2) + 1} = \\frac{2 \\cdot (2\\nu/(ah))}{(2\\nu/(ah))^2 + 1} = \\frac{2/Pe_h}{1/Pe_h^2 + 1} = \\frac{2 Pe_h}{1 + Pe_h^2} $$\n\n**For the upwind scheme at $\\theta = \\frac{\\pi}{2}$**:\n$\\lambda_R = -(\\frac{a}{h} + \\frac{2\\nu}{h^2})$ and $\\lambda_I = -\\frac{a}{h}$.\n$$ \\Delta t^{\\star}_{\\mathrm{upwind}} = \\frac{-2(-(\\frac{a}{h} + \\frac{2\\nu}{h^2}))}{(\\frac{a}{h} + \\frac{2\\nu}{h^2})^2 + (\\frac{a}{h})^2} = \\frac{2(\\frac{ah+2\\nu}{h^2})}{\\frac{a^2}{h^2} + \\frac{4a\\nu}{h^3} + \\frac{4\\nu^2}{h^4} + \\frac{a^2}{h^2}} = \\frac{2(ah+2\\nu)}{h^2} \\frac{h^4}{2a^2h^2 + 4a\\nu h + 4\\nu^2} $$\n$$ \\Delta t^{\\star}_{\\mathrm{upwind}} = \\frac{2h^2(ah+2\\nu)}{2a^2h^2 + 4a\\nu h + 4\\nu^2} = \\frac{h^2(ah+2\\nu)}{a^2h^2 + 2a\\nu h + 2\\nu^2} $$\nThe critical CFL number is:\n$$ \\mathrm{CFL}^{\\star}_{\\mathrm{upwind}} = \\frac{a}{h} \\frac{h^2(ah+2\\nu)}{a^2h^2 + 2a\\nu h + 2\\nu^2} = \\frac{ah(ah+2\\nu)}{a^2h^2 + 2a\\nu h + 2\\nu^2} $$\nDivide numerator and denominator by $a^2h^2$:\n$$ \\mathrm{CFL}^{\\star}_{\\mathrm{upwind}} = \\frac{(1+2\\nu/(ah))}{1 + 2\\nu/(ah) + 2\\nu^2/(a^2h^2)} = \\frac{1+1/Pe_h}{1 + 1/Pe_h + \\frac{1}{2}(2\\nu/(ah))^2} = \\frac{1+1/Pe_h}{1 + 1/Pe_h + 1/(2Pe_h^2)} $$\n\n**4. Equating the Critical CFL Numbers**\n\nWe are looking for $Pe_{h}^{\\star}$ such that $\\mathrm{CFL}^{\\star}_{\\mathrm{central}}(Pe_{h}^{\\star}) = \\mathrm{CFL}^{\\star}_{\\mathrm{upwind}}(Pe_{h}^{\\star})$. Let $P = Pe_h$.\n$$ \\frac{2P}{1+P^2} = \\frac{1+1/P}{1+1/P+1/(2P^2)} $$\nSimplify the right-hand side:\n$$ \\frac{1+1/P}{1+1/P+1/(2P^2)} = \\frac{(P+1)/P}{(2P^2+2P+1)/(2P^2)} = \\frac{P+1}{P} \\cdot \\frac{2P^2}{2P^2+2P+1} = \\frac{2P(P+1)}{2P^2+2P+1} $$\nThe equation becomes:\n$$ \\frac{2P}{1+P^2} = \\frac{2P(P+1)}{2P^2+2P+1} $$\nSince $P = Pe_h = \\frac{|a|h}{2\\nu}  0$, we can divide both sides by $2P$:\n$$ \\frac{1}{1+P^2} = \\frac{P+1}{2P^2+2P+1} $$\nCross-multiply:\n$$ 2P^2+2P+1 = (P+1)(1+P^2) = P+P^3+1+P^2 $$\n$$ 2P^2+2P+1 = P^3+P^2+P+1 $$\nRearrange into a polynomial equation:\n$$ P^3 - P^2 - P = 0 $$\nFactor out $P$:\n$$ P(P^2 - P - 1) = 0 $$\nThis equation has solutions $P=0$ and the roots of the quadratic $P^2 - P - 1 = 0$. Since $Pe_h$ must be positive, we discard the $P=0$ solution.\nUsing the quadratic formula for $P^2 - P - 1 = 0$:\n$$ P = \\frac{-(-1) \\pm \\sqrt{(-1)^2 - 4(1)(-1)}}{2(1)} = \\frac{1 \\pm \\sqrt{1+4}}{2} = \\frac{1 \\pm \\sqrt{5}}{2} $$\nAgain, since $P = Pe_h$ must be a positive physical quantity, we take the positive root.\n$$ Pe_{h}^{\\star} = \\frac{1+\\sqrt{5}}{2} $$\nThis value is the golden ratio, often denoted by $\\phi$. This is the unique positive Peclet number at which the stability limits for the $\\theta=\\pi/2$ mode coincide for the two schemes under consideration.",
            "answer": "$$\\boxed{\\frac{1+\\sqrt{5}}{2}}$$"
        },
        {
            "introduction": "Theory predicts a fundamental trade-off: higher-order schemes like central differencing offer better accuracy, but first-order upwind schemes provide superior stability and preserve solution monotonicity in advection-dominated flows. This practice moves from theory to code, challenging you to implement both schemes for a steady-state boundary value problem . By comparing the numerical solutions against the exact solution, you will directly quantify this trade-off using error norms and visually inspect the results for the non-physical oscillations that plague non-robust schemes when the cell Péclet number is large.",
            "id": "3430298",
            "problem": "Consider the steady one-dimensional linear convection-diffusion boundary value problem on the interval $[0,1]$ with constant coefficients,\n$$-\\,\\kappa\\,u''(x) + \\beta\\,u'(x) = 0,\\quad x\\in(0,1),$$\nwith Dirichlet boundary conditions\n$$u(0)=1,\\quad u(1)=0.$$\nAssume $\\kappagt;0$ and $\\beta\\in\\mathbb{R}$. The exact solution for constant $\\kappa$ and $\\beta$ is well-defined and strictly monotone between the boundary values. Define the cell Péclet number (dimensionless) by\n$$Pe = \\frac{\\beta\\,h}{\\kappa},$$\nwhere $h$ is the uniform grid spacing on a uniform partition of $[0,1]$ into $N$ equal subintervals, so $h=1/N$.\n\nYou will implement two consistent finite difference discretizations on a uniform grid with $N$ subintervals (grid nodes $x_i=i\\,h$ for $i=0,1,\\dots,N$), using the following principles:\n- Approximate the diffusion operator $-\\,\\kappa\\,u''(x)$ with the standard second-order central difference on interior nodes.\n- Approximate the convection operator $\\beta\\,u'(x)$ in two ways:\n  - Central differencing (second-order): using the centered difference on interior nodes.\n  - First-order upwind differencing: using one-sided differences aligned with the sign of $\\beta$ on interior nodes.\n\nImpose the boundary conditions strongly at $x_0=0$ and $x_N=1$. Assemble and solve the resulting linear system for the interior unknowns to obtain the grid solution $\\{u_i\\}_{i=0}^N$ for each scheme. Let $u^{\\mathrm{CD}}$ denote the numerical solution computed with central differencing for the convection term, and $u^{\\mathrm{UD}}$ the solution computed with upwind differencing for the convection term.\n\nDefine the following error measures with respect to the exact solution $u(x)$:\n- The discrete $L^2$-norm (using the trapezoidal rule):\n$$\\|e\\|_{L^2_h} \\;=\\;\\bigg(h\\Big(\\tfrac{1}{2}\\,e_0^2 + \\sum_{i=1}^{N-1} e_i^2 + \\tfrac{1}{2}\\,e_N^2\\Big)\\bigg)^{1/2},\\quad e_i = u_i - u(x_i).$$\n- The discrete $H^1$ seminorm (piecewise linear reconstruction):\n$$|e|_{H^1_h} \\;=\\;\\bigg(\\sum_{i=0}^{N-1} h\\,\\Big(\\frac{e_{i+1}-e_i}{h}\\Big)^2\\bigg)^{1/2}\\;=\\;\\bigg(\\frac{1}{h}\\sum_{i=0}^{N-1} (e_{i+1}-e_i)^2\\bigg)^{1/2}.$$\n\nAdditionally, define a monotonicity indicator for a grid function $v_i$ as the boolean value that is true if and only if the sequence is nonincreasing across the grid, that is,\n$$v_{i+1} \\le v_i \\;\\text{ for all } i=0,1,\\dots,N-1,$$\nup to a numerical tolerance of $10^{-10}$.\n\nImplement both schemes and compute $\\|e\\|_{L^2_h}$ and $|e|_{H^1_h}$ for each scheme. Also compute the monotonicity indicator for each scheme.\n\nFinally, implement a local scheme selection rule based solely on the cell Péclet number $Pe$:\n- Choose central differencing if $|Pe|\\le 2$.\n- Choose upwind differencing if $|Pe| gt; 2$.\n\nThe goal is to quantify how $Pe$ influences the appropriateness of the scheme via error norms and monotonicity, and to report which scheme the $Pe$-based rule selects.\n\nTest Suite:\nUse the following $5$ test cases, each specified by $(\\beta,\\kappa,N)$:\n- Case $1$: $(\\beta,\\kappa,N) = (0.2,\\,1.0,\\,50)$.\n- Case $2$: $(\\beta,\\kappa,N) = (1.0,\\,0.02,\\,25)$.\n- Case $3$: $(\\beta,\\kappa,N) = (1.0,\\,0.02,\\,10)$.\n- Case $4$: $(\\beta,\\kappa,N) = (2.0,\\,0.02,\\,20)$.\n- Case $5$: $(\\beta,\\kappa,N) = (-1.0,\\,0.05,\\,10)$.\n\nFor each case, your program must:\n- Compute $u^{\\mathrm{CD}}$ and $u^{\\mathrm{UD}}$ on the grid.\n- Compute $\\|e^{\\mathrm{CD}}\\|_{L^2_h}$, $\\|e^{\\mathrm{UD}}\\|_{L^2_h}$, $|e^{\\mathrm{CD}}|_{H^1_h}$, $|e^{\\mathrm{UD}}|_{H^1_h}$, and the monotonicity indicators for $u^{\\mathrm{CD}}$ and $u^{\\mathrm{UD}}$.\n- Compute the cell Péclet number $Pe=\\beta h/\\kappa$ and apply the selection rule to return a scheme code: $0$ for central differencing and $1$ for upwind differencing.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case in the order listed above, output a sublist with the following $7$ entries:\n- The integer scheme code selected by the $Pe$ rule ($0$ for central, $1$ for upwind).\n- The floating-point value of $\\|e^{\\mathrm{CD}}\\|_{L^2_h}$.\n- The floating-point value of $\\|e^{\\mathrm{UD}}\\|_{L^2_h}$.\n- The floating-point value of $|e^{\\mathrm{CD}}|_{H^1_h}$.\n- The floating-point value of $|e^{\\mathrm{UD}}|_{H^1_h}$.\n- The boolean monotonicity indicator for $u^{\\mathrm{CD}}$.\n- The boolean monotonicity indicator for $u^{\\mathrm{UD}}$.\n\nThus the overall output has the form\n$$[\\,[\\text{scheme},\\,L2_{\\mathrm{CD}},\\,L2_{\\mathrm{UD}},\\,H1_{\\mathrm{CD}},\\,H1_{\\mathrm{UD}},\\,\\text{mono}_{\\mathrm{CD}},\\,\\text{mono}_{\\mathrm{UD}}],\\ \\dots\\ ].$$\nAll quantities are dimensionless. The program must not read input and must hard-code the test cases above. The output must be exactly one line in the specified format.",
            "solution": "The user wants to solve a steady one-dimensional convection-diffusion boundary value problem and analyze the performance of two finite difference schemes.\n\n### Step 1: Problem Validation\n\nThe problem is stated as:\n- **PDE**: $-\\kappa u''(x) + \\beta u'(x) = 0$ on $x \\in (0,1)$.\n- **Boundary Conditions**: $u(0)=1$, $u(1)=0$.\n- **Parameters**: $\\kappa  0$, $\\beta \\in \\mathbb{R}$.\n\nThe task involves:\n1.  Deriving the analytical solution.\n2.  Discretizing the PDE using two schemes on a uniform grid with $N$ intervals and spacing $h=1/N$:\n    -   Central differencing (CD) for both diffusion and convection.\n    -   Central differencing for diffusion and first-order upwind differencing (UD) for convection.\n3.  Solving the resulting linear systems for the nodal values $\\{u_i\\}_{i=0}^N$.\n4.  Calculating specified error norms (discrete $L^2$ and $H^1$ seminorm) and a monotonicity indicator for both schemes.\n5.  Implementing a scheme selection rule based on the cell Péclet number, $Pe = \\frac{\\beta h}{\\kappa}$.\n6.  Running a suite of test cases and reporting the results in a specified format.\n\nThe problem is a classic exercise in the numerical analysis of partial differential equations. It is scientifically sound, well-posed, objective, and fully specified. The differential equation, boundary conditions, numerical methods, and analysis metrics are all standard and well-defined in the field of computational science and engineering. There are no contradictions, ambiguities, or invalid premises.\n\nThe validation verdict is **valid**.\n\n### Step 2: Analytical Solution\n\nThe governing ordinary differential equation is a second-order linear homogeneous equation with constant coefficients:\n$$-\\kappa u'' + \\beta u' = 0$$\nThe characteristic equation is $-\\kappa r^2 + \\beta r = 0$, which gives $r(-\\kappa r + \\beta) = 0$. The roots are $r_1 = 0$ and $r_2 = \\beta/\\kappa$.\n\n-   If $\\beta = 0$, the roots are repeated ($r_1=r_2=0$), and the general solution is $u(x) = C_1 + C_2 x$. Applying the boundary conditions $u(0)=1$ and $u(1)=0$ yields $C_1=1$ and $C_2=-1$, so $u(x) = 1-x$.\n\n-   If $\\beta \\neq 0$, the roots are distinct, and the general solution is $u(x) = C_1 e^{r_1 x} + C_2 e^{r_2 x} = C_1 + C_2 e^{(\\beta/\\kappa)x}$. Applying the boundary conditions:\n    -   $u(0) = C_1 + C_2 = 1$\n    -   $u(1) = C_1 + C_2 e^{\\beta/\\kappa} = 0$\n    Solving this system for $C_1$ and $C_2$ gives:\n    $$C_1 = \\frac{e^{\\beta/\\kappa}}{e^{\\beta/\\kappa} - 1}, \\quad C_2 = -\\frac{1}{e^{\\beta/\\kappa} - 1}$$\n    The exact solution is therefore:\n    $$u(x) = \\frac{e^{\\beta/\\kappa} - e^{(\\beta/\\kappa)x}}{e^{\\beta/\\kappa} - 1}$$\nFor numerical stability when $\\beta/\\kappa$ is a large positive number, this can be rewritten as:\n$$u(x) = \\frac{1 - e^{(\\beta/\\kappa)(x-1)}}{1 - e^{-\\beta/\\kappa}}$$\n\n### Step 3: Finite Difference Discretization\n\nWe discretize the equation at interior grid nodes $x_i = ih$ for $i=1, \\dots, N-1$. The general form of the discretized equation is:\n$$-\\kappa \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} + \\beta (\\text{approx. of } u'(x_i)) = 0$$\nWe rearrange this to form a linear system $A \\mathbf{u_{int}} = \\mathbf{b}$ for the interior unknowns $\\mathbf{u_{int}} = [u_1, \\dots, u_{N-1}]^T$. The boundary values $u_0=1$ and $u_N=0$ are moved to the right-hand side.\n\n**Scheme 1: Central Differencing (CD)**\nThe convection term is approximated by $\\beta u'(x_i) \\approx \\beta \\frac{u_{i+1} - u_{i-1}}{2h}$. The discrete equation becomes:\n$$ \\left(-\\frac{\\kappa}{h^2} - \\frac{\\beta}{2h}\\right)u_{i-1} + \\left(\\frac{2\\kappa}{h^2}\\right)u_i + \\left(-\\frac{\\kappa}{h^2} + \\frac{\\beta}{2h}\\right)u_{i+1} = 0 $$\nMultiplying by $h^2$ gives the coefficients for the tridiagonal system matrix $A_{CD}$:\n-   Lower diagonal: $l_i = -\\kappa - \\frac{\\beta h}{2}$\n-   Main diagonal: $d_i = 2\\kappa$\n-   Upper diagonal: $u_i = -\\kappa + \\frac{\\beta h}{2}$\nThe right-hand side vector $\\mathbf{b}_{CD}$ is zero except for the first entry, which incorporates the $u_0=1$ boundary condition: $b_1 = -l_1 u_0 = \\kappa + \\frac{\\beta h}{2}$.\n\n**Scheme 2: Upwind Differencing (UD)**\nThe convection term approximation depends on the sign of $\\beta$:\n-   If $\\beta \\ge 0$ (flow from left to right), use a backward difference: $\\beta u'(x_i) \\approx \\beta \\frac{u_i - u_{i-1}}{h}$.\n-   If $\\beta  0$ (flow from right to left), use a forward difference: $\\beta u'(x_i) \\approx \\beta \\frac{u_{i+1} - u_i}{h}$.\n\nThis leads to the following coefficients for the tridiagonal system matrix $A_{UD}$:\n-   If $\\beta \\ge 0$:\n    -   $l_i = -\\kappa - \\beta h$\n    -   $d_i = 2\\kappa + \\beta h$\n    -   $u_i = -\\kappa$\n    -   $b_1 = -l_1 u_0 = \\kappa + \\beta h$\n-   If $\\beta  0$:\n    -   $l_i = -\\kappa$\n    -   $d_i = 2\\kappa - \\beta h$\n    -   $u_i = -\\kappa + \\beta h$\n    -   $b_1 = -l_1 u_0 = \\kappa$\n\n### Step 4: Analysis and Implementation\n\nFor each test case $(\\beta, \\kappa, N)$, the following steps are executed:\n1.  Calculate grid parameters $h$ and $x_i$.\n2.  Compute the exact solution $u(x_i)$ on the grid using the numerically stable formula.\n3.  For each scheme (CD and UD):\n    a.  Assemble the $(N-1) \\times (N-1)$ tridiagonal matrix $A$ and the right-hand side vector $\\mathbf{b}$.\n    b.  Solve the linear system $A \\mathbf{u_{int}} = \\mathbf{b}$ to find the interior solution.\n    c.  Construct the full solution vector $u_i$ by including the boundary values $u_0=1$ and $u_N=0$.\n4.  For each numerical solution ($u^{\\mathrm{CD}}$, $u^{\\mathrm{UD}}$):\n    a.  Compute the error vector $e_i = u_i - u(x_i)$.\n    b.  Calculate the discrete $L^2$-norm: $\\|e\\|_{L^2_h} = \\left(h \\sum_{i=1}^{N-1} e_i^2\\right)^{1/2}$. Note: The problem asks for the L2 norm using trapezoidal rule, but the BCs are exact, so $e_0 = e_N = 0$. Thus the sum over interior points is sufficient for the L2 error.\n    c.  Calculate the discrete $H^1$-seminorm: $|e|_{H^1_h} = \\left(h^{-1} \\sum_{i=0}^{N-1} (e_{i+1}-e_i)^2\\right)^{1/2}$.\n    d.  Check for monotonicity: determine if $u_{i+1} \\le u_i$ for all $i=0, \\dots, N-1$. The exact solution is always non-increasing for the given boundary conditions.\n5.  Calculate the cell Péclet number $Pe = \\beta h / \\kappa$ and determine the selected scheme: code $0$ for CD if $|Pe| \\le 2$, and code $1$ for UD if $|Pe|  2$.\n6.  Collect the seven required output values: scheme code, the four error norms, and the two monotonicity booleans.\n\nThis procedure is implemented in the Python code below, which processes all test cases and generates the output in the specified format. The `scipy` library is not required as `numpy` provides sufficient functionality for assembling and solving the tridiagonal linear systems.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        (0.2, 1.0, 50),\n        (1.0, 0.02, 25),\n        (1.0, 0.02, 10),\n        (2.0, 0.02, 20),\n        (-1.0, 0.05, 10),\n    ]\n\n    results = []\n    for case in test_cases:\n        beta, kappa, N = case\n        case_result = solve_bvp_case(beta, kappa, N)\n        results.append(case_result)\n\n    # Format the final output string as a compact list of lists.\n    # str(results) produces '[...], [...]', with spaces.\n    # .replace(\" \", \"\") makes it compact: '[[...],[...]]'\n    final_output = str(results).replace(\" \", \"\")\n    print(final_output)\n\ndef solve_bvp_case(beta, kappa, N):\n    \"\"\"\n    Solves the 1D convection-diffusion BVP for a single case.\n    Returns a list of 7 metrics as specified in the problem.\n    \"\"\"\n    h = 1.0 / N\n    x_grid = np.linspace(0, 1, N + 1)\n\n    # Analytically compute exact solution on the grid.\n    u_exact = get_exact_solution(beta, kappa, x_grid)\n\n    # Solve using Central Differencing for convection.\n    u_cd = solve_finite_difference(beta, kappa, N, scheme='central')\n    \n    # Solve using Upwind Differencing for convection.\n    u_ud = solve_finite_difference(beta, kappa, N, scheme='upwind')\n\n    # Compute errors for both schemes.\n    e_cd = u_cd - u_exact\n    e_ud = u_ud - u_exact\n\n    # L2 norm of error. Since e_0 and e_N are 0, this simplifies.\n    l2_cd = np.sqrt(h * np.dot(e_cd[1:-1], e_cd[1:-1]))\n    l2_ud = np.sqrt(h * np.dot(e_ud[1:-1], e_ud[1:-1]))\n\n    # H1 seminorm of error.\n    h1_cd = np.sqrt(np.sum(np.diff(e_cd)**2) / h)\n    h1_ud = np.sqrt(np.sum(np.diff(e_ud)**2) / h)\n    \n    # Monotonicity check (solution must be non-increasing).\n    mono_cd = bool(np.all(np.diff(u_cd) = 1e-10))\n    mono_ud = bool(np.all(np.diff(u_ud) = 1e-10))\n\n    # Apply scheme selection rule based on cell Peclet number.\n    peclet = beta * h / kappa\n    scheme_code = 1 if abs(peclet) > 2.0 else 0\n    \n    return [scheme_code, l2_cd, l2_ud, h1_cd, h1_ud, mono_cd, mono_ud]\n\ndef get_exact_solution(beta, kappa, x_grid):\n    \"\"\"\n    Computes the exact solution on a given grid, using a numerically\n    stable formulation to avoid floating-point overflow.\n    \"\"\"\n    C = beta / kappa\n    if abs(C)  1e-9: # Essentially beta = 0 case\n        return 1.0 - x_grid\n    \n    if C > 0:\n        # This form avoids exp(C) for a large positive C.\n        if C > 700: # Asymptotic form to avoid 1.0 - exp(-C) becoming 1.0\n             return 1.0 - np.exp(C * (x_grid - 1.0))\n        return (1.0 - np.exp(C * (x_grid - 1.0))) / (1.0 - np.exp(-C))\n    else: # C  0\n        # This form is stable for negative C.\n        return (np.exp(C) - np.exp(C * x_grid)) / (np.exp(C) - 1.0)\n\ndef solve_finite_difference(beta, kappa, N, scheme):\n    \"\"\"\n    Assembles and solves the linear system for a given finite difference scheme.\n    \"\"\"\n    h = 1.0 / N\n    num_interior_pts = N - 1\n\n    if num_interior_pts = 0:\n        return np.array([1.0, 0.0] if N == 1 else [1.0])\n\n    A = np.zeros((num_interior_pts, num_interior_pts))\n    b = np.zeros(num_interior_pts)\n    \n    # Coefficients NOT multiplied by h^2\n    if scheme == 'central':\n        lower_diag = -kappa/h**2 - beta / (2.0*h)\n        main_diag = 2.0 * kappa / h**2\n        upper_diag = -kappa/h**2 + beta / (2.0*h)\n    elif scheme == 'upwind':\n        if beta >= 0:\n            lower_diag = -kappa/h**2 - beta/h\n            main_diag  = 2.0*kappa/h**2 + beta/h\n            upper_diag = -kappa/h**2\n        else: # beta  0\n            lower_diag = -kappa/h**2\n            main_diag  = 2.0*kappa/h**2 - beta/h\n            upper_diag = -kappa/h**2 + beta/h\n    else:\n        raise ValueError(\"Invalid scheme type\")\n\n    # Assemble the tridiagonal matrix A\n    np.fill_diagonal(A, main_diag)\n    if num_interior_pts > 1:\n        np.fill_diagonal(A[1:], lower_diag)\n        np.fill_diagonal(A[:, 1:], upper_diag)\n\n    # Assemble the RHS vector b from the u(0)=1 boundary condition\n    b[0] = -lower_diag * 1.0\n    \n    # Solve the linear system for interior nodes\n    u_int = np.linalg.solve(A, b)\n    \n    # Combine with boundary conditions to get the full solution\n    return np.concatenate(([1.0], u_int, [0.0]))\n\nsolve()\n```"
        },
        {
            "introduction": "The most robust numerical solvers for advection-diffusion problems are not static; they adapt to local flow conditions. This capstone exercise guides you through building a modern, adaptive solver that autonomously switches between centered and upwind fluxes based on the instantaneous Péclet number . The challenge extends beyond mere implementation to the critical task of verification, requiring you to design and pass a test suite that ensures the switching mechanism itself does not introduce spurious oscillations or other numerical artifacts.",
            "id": "3430209",
            "problem": "Consider the one-dimensional linear advection-diffusion equation for a passive scalar field $c(x,t)$ on the periodic domain $x \\in [0,1]$:\n$$\n\\frac{\\partial c}{\\partial t} + u(t)\\,\\frac{\\partial c}{\\partial x} = \\nu\\,\\frac{\\partial^2 c}{\\partial x^2},\n$$\nwith a time-dependent advecting velocity $u(t)$, a constant kinematic diffusivity $\\nu  0$, and periodic boundary conditions. The initial condition is a localized Gaussian layer centered at $x_0$ with standard deviation $\\sigma$:\n$$\nc(x,0) = \\exp\\!\\left(-\\frac{d(x,x_0)^2}{2\\sigma^2}\\right), \\quad d(x,x_0) = \\min\\{|x-x_0|,\\,1-|x-x_0|\\}.\n$$\nThe mesh uses a uniform grid with $N$ points and spacing $\\Delta x = 1/N$.\n\nThe dimensionless local face Péclet number (Péclet number) is defined as\n$$\nPe(t) = \\frac{|u(t)|\\,\\Delta x}{\\nu}.\n$$\nA flux-switching discretization is required for the advective term. The scheme must autonomously select the numerical flux type based on $Pe(t)$ at each time step (global because $u(t)$ is spatially uniform):\n- If $Pe(t)  1$, use the centered flux for advection, i.e., at face $i+\\tfrac{1}{2}$, $F^{\\text{adv}}_{i+\\frac{1}{2}} = u(t)\\,\\frac{c_i + c_{i+1}}{2}$.\n- If $Pe(t) \\ge 1$, use the first-order upwind flux for advection, i.e., $F^{\\text{adv}}_{i+\\frac{1}{2}} = u(t)\\,c_i$ when $u(t) \\ge 0$, and $F^{\\text{adv}}_{i+\\frac{1}{2}} = u(t)\\,c_{i+1}$ when $u(t)  0$.\n\nDiscretize in time by an implicit-explicit (IMEX) step: treat diffusion implicitly with the standard periodic second-difference operator, and treat advection explicitly using the conservative flux difference from the selected flux type. The semi-discrete update from time level $n$ to $n+1$ with time step $\\Delta t$ is\n$$\n\\frac{c^{n+1} - c^n}{\\Delta t} + \\mathcal{A}\\!\\left(u^n, c^n\\right) = \\nu\\,\\mathcal{D}\\,c^{n+1},\n$$\nwhere $\\mathcal{A}$ is the discrete advective divergence formed from the selected face fluxes and $\\mathcal{D}$ is the discrete periodic Laplacian. Use a stable adaptive time step satisfying the Courant-type restriction\n$$\n\\Delta t = C_{\\text{CFL}}\\min\\!\\left\\{\\frac{\\Delta x^2}{\\nu},\\,\\frac{\\Delta x}{\\max(|u(t)|, \\epsilon)}\\right\\},\n$$\nwith a fixed $C_{\\text{CFL}} \\in (0,1)$ and a small positive $\\epsilon$ to avoid division by zero.\n\nImplement the above with the following fixed numerical choices:\n- $N = 256$, $\\nu = 10^{-3}$, $C_{\\text{CFL}} = 0.4$, $x_0 = 0.3$, $\\sigma = 0.03$.\n- The grid is periodic and uniform on $[0,1]$.\n\nVerification objective: create a benchmark with a moving layer where $Pe(t)$ crosses unity and require the scheme to autonomously switch flux types. Verify that switching does not introduce hysteresis or temporal spiking by passing the test suite below.\n\nTest suite specification. Your program must execute the following three test cases and return a Boolean for each:\n\n- Test case $1$ (ramp crossing, overshoot check): Let $T_1 = 1$, $u(t) = U_{\\max}\\,\\sin\\!\\left(2\\pi t/T_1\\right)$ with $U_{\\max} = 0.6$. This choice forces $Pe(t)$ to cross $1$. Evolve to $t=T_1$. Define the overshoot measure\n$$\n\\mathcal{O} = \\max\\!\\{0,\\,\\max_x c(x,T_1) - 1\\} + \\max\\!\\{0,\\, -\\min_x c(x,T_1)\\}.\n$$\nReturn $\\text{True}$ if $\\mathcal{O} \\le 5\\times 10^{-3}$, else $\\text{False}$.\n\n- Test case $2$ (toggle around threshold, no hysteresis or spiking via diffusion-consistency): Let $T_2 = 0.5$. Define $u_{\\text{thr}} = \\nu/\\Delta x$. Define $u_{\\text{low}} = 0.8\\,u_{\\text{thr}}$ and $u_{\\text{high}} = 1.2\\,u_{\\text{thr}}$. Define a piecewise-constant zero-mean toggling velocity that cycles every $\\tau = 0.01$ through the sequence $\\{+u_{\\text{low}},-u_{\\text{low}},+u_{\\text{high}},-u_{\\text{high}}\\}$ and repeats over $[0,T_2]$. This produces repeated crossings of $Pe(t)=1$ with zero net advection. Evolve to $t=T_2$ with autonomous switching. In parallel, evolve a reference solution with the same initial condition but with $u(t)\\equiv 0$ (pure diffusion) up to $t=T_2$. Let $c_{\\text{tog}}(x,T_2)$ be the toggling run and $c_{\\text{diff}}(x,T_2)$ the pure diffusion run. Define the relative $L^2$ discrepancy\n$$\n\\mathcal{E} = \\frac{\\left(\\sum_i \\left[c_{\\text{tog}}(x_i,T_2)-c_{\\text{diff}}(x_i,T_2)\\right]^2\\right)^{1/2}}{\\left(\\sum_i \\left[c_{\\text{diff}}(x_i,T_2)\\right]^2\\right)^{1/2} + 10^{-14}}.\n$$\nReturn $\\text{True}$ if $\\mathcal{E} \\le 2\\times 10^{-2}$, else $\\text{False}$.\n\n- Test case $3$ (always diffusive, equivalence to forced central): Let $T_3 = 0.5$, $u(t)\\equiv U_{\\text{small}}$ with $U_{\\text{small}} = 0.05$ so that $Pe(t)  1$ for all $t$. Evolve to $t=T_3$ with autonomous switching (which should choose the centered flux at all times). Independently, evolve to $t=T_3$ with the centered flux forced for all $t$ (no switching). Let the final states be $c_{\\text{auto}}(x,T_3)$ and $c_{\\text{cent}}(x,T_3)$. Define the infinity-norm discrepancy\n$$\n\\Delta_{\\infty} = \\max_i \\left|c_{\\text{auto}}(x_i,T_3)-c_{\\text{cent}}(x_i,T_3)\\right|.\n$$\nReturn $\\text{True}$ if $\\Delta_{\\infty} \\le 10^{-12}$, else $\\text{False}$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\,\\text{result}_1,\\text{result}_2,\\text{result}_3\\,]$), where each $\\text{result}_k$ is the Boolean outcome for test case $k$ in the order above. All quantities in this problem are dimensionless; no physical units are required in the output.",
            "solution": "The problem requires the numerical solution of the one-dimensional linear advection-diffusion equation,\n$$\n\\frac{\\partial c}{\\partial t} + u(t)\\,\\frac{\\partial c}{\\partial x} = \\nu\\,\\frac{\\partial^2 c}{\\partial x^2},\n$$\non a periodic domain $x \\in [0,1]$. The solution entails implementing a flux-switching scheme for the advection term, guided by the local Péclet number, and an implicit-explicit (IMEX) time integration method.\n\n**Spatial Discretization**\nThe spatial domain $[0,1]$ is discretized into $N$ uniform grid cells, with cell centers at $x_i = i\\Delta x$ for $i=0, \\dots, N-1$, where $\\Delta x = 1/N$. The discrete concentration at $(x_i, t)$ is denoted $c_i(t)$. We employ a finite volume method, where the semi-discrete equation for cell $i$ is:\n$$\n\\frac{d c_i}{dt} = -\\frac{F^{\\text{adv}}_{i+\\frac{1}{2}} - F^{\\text{adv}}_{i-\\frac{1}{2}}}{\\Delta x} + \\frac{F^{\\text{diff}}_{i+\\frac{1}{2}} - F^{\\text{diff}}_{i-\\frac{1}{2}}}{\\Delta x}\n$$\nThe diffusive flux is discretized using a central difference scheme, leading to the familiar discrete Laplacian operator, $\\mathcal{D}$:\n$$\n\\left(\\mathcal{D}c\\right)_i = \\frac{c_{i+1} - 2c_i + c_{i-1}}{\\Delta x^2}\n$$\nThe advective flux $F^{\\text{adv}}$ is handled by a switching scheme dependent on the Péclet number, $Pe(t) = \\frac{|u(t)|\\Delta x}{\\nu}$. This number compares the rate of advection to diffusion over a grid cell.\nIf $Pe(t)  1$, diffusion dominates at the grid scale, and a non-dissipative centered flux is appropriate for accuracy:\n$$\nF^{\\text{adv}}_{i+\\frac{1}{2}} = u(t)\\,\\frac{c_i + c_{i+1}}{2}\n$$\nThis results in the standard second-order central difference for the advective term: $(\\mathcal{A}c)_i = u(t)\\frac{c_{i+1}-c_{i-1}}{2\\Delta x}$.\nIf $Pe(t) \\ge 1$, advection dominates, and a stable first-order upwind flux is required to prevent unphysical oscillations:\n$$\nF^{\\text{adv}}_{i+\\frac{1}{2}} =\n\\begin{cases}\nu(t)\\,c_i  \\text{if } u(t) \\ge 0 \\\\\nu(t)\\,c_{i+1}  \\text{if } u(t)  0\n\\end{cases}\n$$\nThis results in a first-order backward or forward difference for the advective term, $(\\mathcal{A}c)_i = u(t)\\frac{c_i-c_{i-1}}{\\Delta x}$ for $u \\ge 0$ and $(\\mathcal{A}c)_i = u(t)\\frac{c_{i+1}-c_{i}}{\\Delta x}$ for $u  0$, respectively.\nThe periodic boundary conditions are handled by applying all stencil operations with modular arithmetic on the indices.\n\n**Time Discretization and IMEX Scheme**\nThe semi-discrete equation is $ \\frac{dc}{dt} = -\\mathcal{A}(u,c) + \\nu \\mathcal{D}c $. This is a system of ordinary differential equations. The diffusion term often introduces stiffness, requiring prohibitively small time steps for explicit methods. The advection term has a less stringent time-step constraint. An IMEX scheme is therefore ideal, treating advection explicitly and diffusion implicitly.\nApplying a first-order IMEX (Euler) scheme from time $t^n$ to $t^{n+1}=t^n+\\Delta t$:\n$$\n\\frac{c^{n+1} - c^n}{\\Delta t} = -\\mathcal{A}(u(t^n), c^n) + \\nu \\mathcal{D}c^{n+1}\n$$\nRearranging to solve for the unknown state $c^{n+1}$:\n$$\n(I - \\Delta t\\,\\nu\\,\\mathcal{D})c^{n+1} = c^n - \\Delta t\\,\\mathcal{A}(u^n, c^n)\n$$\nwhere $I$ is the identity operator and $u^n = u(t^n)$.\n\n**Solving the Implicit System via FFT**\nThe equation for $c^{n+1}$ is a linear system. Let $M = (I - \\Delta t\\,\\nu\\,D)$ be the system matrix, where $D$ is the matrix representation of the periodic discrete Laplacian $\\mathcal{D}$. Since $D$ is a circulant matrix, $M$ is also circulant. Such systems are efficiently solved in Fourier space.\nLet $\\hat{c} = \\mathcal{F}(c)$ denote the Discrete Fourier Transform (DFT). The convolution theorem states that applying a circulant matrix in real space is equivalent to element-wise multiplication by its eigenvalues in Fourier space.\nThe eigenvalues $\\lambda_k$ of the discrete Laplacian operator $\\mathcal{D}$ for each Fourier mode $k$ are:\n$$\n\\lambda_k = \\frac{2}{\\Delta x^2} \\left(\\cos\\left(\\frac{2\\pi k}{N}\\right) - 1\\right)\n$$\nTransforming the system into Fourier space gives:\n$$\n(1 - \\Delta t\\,\\nu\\,\\lambda_k)\\hat{c}^{n+1}_k = \\mathcal{F}\\left(c^n - \\Delta t\\,\\mathcal{A}(u^n, c^n)\\right)_k\n$$\nThis diagonal system is trivially solved for each Fourier component $\\hat{c}^{n+1}_k$. The solution $c^{n+1}$ is then recovered via an inverse DFT, $c^{n+1} = \\mathcal{F}^{-1}(\\hat{c}^{n+1})$. This spectral approach has a computational complexity of $\\mathcal{O}(N\\log N)$ per time step, which is highly efficient.\n\n**Adaptive Time-Stepping**\nThe stability of the explicit advection treatment requires the time step $\\Delta t$ to satisfy a Courant-Friedrichs-Lewy (CFL) condition, $\\Delta t \\lesssim \\Delta x/|u|$. Although the diffusion is treated implicitly (and is thus unconditionally stable), its timescale $\\Delta t \\lesssim \\Delta x^2/\\nu$ is relevant for accuracy. Following the problem, we use an adaptive time step that respects both timescales:\n$$\n\\Delta t = C_{\\text{CFL}}\\min\\!\\left\\{\\frac{\\Delta x^2}{\\nu},\\,\\frac{\\Delta x}{\\max(|u(t)|, \\epsilon)}\\right\\}\n$$\nwith $C_{\\text{CFL}} = 0.4$. The small parameter $\\epsilon$ prevents division by zero when $u(t)$ is close to zero. The time step is re-evaluated at the beginning of each step. To ensure the final time is reached exactly, the last time step is truncated if necessary.\n\n**Initial Condition**\nThe initial condition is a Gaussian pulse defined with a periodic distance metric to ensure it is smooth across the domain boundary:\n$$\nc(x,0) = \\exp\\!\\left(-\\frac{d(x,x_0)^2}{2\\sigma^2}\\right), \\quad d(x,x_0) = \\min\\{|x-x_0|,\\,1-|x-x_0|\\}.\n$$\n\n**Test Case Implementation**\nA single, robust solver function is implemented based on the principles above. This function accepts the initial condition, a function handle for the velocity profile $u(t)$, and the final integration time $T$. For Test Case 3, a mode is added to force the use of the centered difference scheme, bypassing the Péclet number check. The three test cases are then executed by calling this solver with the specific parameters ($u(t)$, $T$, etc.) and verification logic prescribed for each case. The results are collected and formatted as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.fft import fft, ifft\n\ndef solve():\n    \"\"\"\n    Main function to execute the test suite and print results.\n    \"\"\"\n    # --- Global constants from the problem statement ---\n    N = 256\n    NU = 1e-3\n    C_CFL = 0.4\n    X0 = 0.3\n    SIGMA = 0.03\n    EPSILON = 1e-14\n    DX = 1.0 / N\n\n    class PdeSolver:\n        \"\"\"\n        A solver for the 1D advection-diffusion equation using a flux-switching\n        IMEX scheme.\n        \"\"\"\n        def __init__(self, n_points, nu, cfl, epsilon, flux_mode='auto'):\n            self.N = n_points\n            self.nu = nu\n            self.C_CFL = cfl\n            self.epsilon = epsilon\n            self.dx = 1.0 / self.N\n            self.flux_mode = flux_mode\n\n            # Precompute eigenvalues for the implicit diffusion solver\n            k_freq = np.fft.fftfreq(self.N, d=self.dx)\n            # Eigenvalues of the discrete periodic Laplacian (2nd-order central diff)\n            self.laplacian_eigenvalues = 2 * (np.cos(2 * np.pi * k_freq * self.dx) - 1) / self.dx**2\n\n        def get_advection_divergence(self, c, u_t):\n            \"\"\"\n            Computes the advection term's spatial derivative using a flux-switching scheme.\n            \"\"\"\n            peclet = abs(u_t) * self.dx / self.nu\n            \n            use_centered = (peclet  1.0)\n            if self.flux_mode == 'force_central':\n                use_centered = True\n            \n            c_p1 = np.roll(c, -1)\n            c_m1 = np.roll(c, 1)\n\n            if use_centered:\n                # Centered difference for advection\n                adv_div = u_t * (c_p1 - c_m1) / (2 * self.dx)\n            else:\n                # First-order upwind difference for advection\n                if u_t >= 0:\n                    adv_div = u_t * (c - c_m1) / self.dx\n                else:\n                    adv_div = u_t * (c_p1 - c) / self.dx\n            return adv_div\n\n        def run(self, c0, u_func, T_final):\n            \"\"\"\n            Evolves the PDE from an initial condition c0 to a final time T_final.\n            \"\"\"\n            c = np.copy(c0)\n            t = 0.0\n\n            while t  T_final:\n                u_t = u_func(t)\n                \n                # Adaptive time step based on CFL-like conditions\n                dt_diff = self.dx**2 / self.nu\n                dt_adv = self.dx / max(abs(u_t), self.epsilon)\n                dt = self.C_CFL * min(dt_diff, dt_adv)\n                \n                if t + dt > T_final:\n                    dt = T_final - t\n                \n                if dt = 0:\n                    break\n\n                # Step 1: Explicit advection (forms the RHS of the IMEX scheme)\n                adv_div = self.get_advection_divergence(c, u_t)\n                rhs = c - dt * adv_div\n\n                # Step 2: Implicit diffusion (solved in Fourier space)\n                rhs_hat = fft(rhs)\n                c_hat_new = rhs_hat / (1.0 - self.nu * dt * self.laplacian_eigenvalues)\n                c_new = ifft(c_hat_new).real\n\n                c = c_new\n                t += dt\n                \n            return c\n\n    def setup_initial_condition(n_points, x0, sigma):\n        \"\"\"\n        Generates the periodic Gaussian initial condition.\n        \"\"\"\n        dx = 1.0 / n_points\n        x = np.arange(n_points) * dx\n        d = np.abs(x - x0)\n        d = np.minimum(d, 1.0 - d)\n        return np.exp(-d**2 / (2 * sigma**2))\n\n    def run_test_case_1():\n        \"\"\"\n        Test case 1: Ramp crossing, overshoot check.\n        \"\"\"\n        T1 = 1.0\n        U_max = 0.6\n        def u_func(t):\n            return U_max * np.sin(2 * np.pi * t / T1)\n\n        c0 = setup_initial_condition(N, X0, SIGMA)\n        solver = PdeSolver(N, NU, C_CFL, EPSILON, flux_mode='auto')\n        c_final = solver.run(c0, u_func, T1)\n        \n        overshoot = max(0, np.max(c_final) - 1.0) + max(0, -np.min(c_final))\n        return overshoot = 5e-3\n\n    def run_test_case_2():\n        \"\"\"\n        Test case 2: Toggle around threshold, consistency with pure diffusion.\n        \"\"\"\n        T2 = 0.5\n        tau = 0.01\n        u_thr = NU / DX\n        u_low = 0.8 * u_thr\n        u_high = 1.2 * u_thr\n        \n        def u_toggling_func(t):\n            t_cycle = t % (4 * tau)\n            if t_cycle  tau:\n                return u_low\n            elif t_cycle  2 * tau:\n                return -u_low\n            elif t_cycle  3 * tau:\n                return u_high\n            else:\n                return -u_high\n                \n        def u_zero_func(t):\n            return 0.0\n\n        c0 = setup_initial_condition(N, X0, SIGMA)\n        solver = PdeSolver(N, NU, C_CFL, EPSILON, flux_mode='auto')\n        \n        c_tog = solver.run(c0, u_toggling_func, T2)\n        c_diff = solver.run(c0, u_zero_func, T2)\n        \n        numerator = np.sqrt(np.sum((c_tog - c_diff)**2))\n        denominator = np.sqrt(np.sum(c_diff**2)) + 1e-14\n        error = numerator / denominator\n        \n        return error = 2e-2\n\n    def run_test_case_3():\n        \"\"\"\n        Test case 3: Always diffusive regime, equivalence to forced central scheme.\n        \"\"\"\n        T3 = 0.5\n        U_small = 0.05\n        \n        def u_func(t):\n            return U_small\n\n        c0 = setup_initial_condition(N, X0, SIGMA)\n        solver_auto = PdeSolver(N, NU, C_CFL, EPSILON, flux_mode='auto')\n        solver_central = PdeSolver(N, NU, C_CFL, EPSILON, flux_mode='force_central')\n        \n        c_auto = solver_auto.run(c0, u_func, T3)\n        c_cent = solver_central.run(c0, u_func, T3)\n        \n        discrepancy = np.max(np.abs(c_auto - c_cent))\n        \n        return discrepancy = 1e-12\n\n    test_cases = [\n        run_test_case_1,\n        run_test_case_2,\n        run_test_case_3\n    ]\n    results = [case() for case in test_cases]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}