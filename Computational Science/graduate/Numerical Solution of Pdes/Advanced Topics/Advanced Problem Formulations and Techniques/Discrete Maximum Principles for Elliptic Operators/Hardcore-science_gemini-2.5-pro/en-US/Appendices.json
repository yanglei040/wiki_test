{
    "hands_on_practices": [
        {
            "introduction": "This first exercise cuts to the core of the Discrete Maximum Principle (DMP) by examining its algebraic foundations. We will demonstrate that a matrix being symmetric positive definite (SPD)—a desirable property ensuring a unique solution exists—is not sufficient to guarantee a DMP. By analyzing a simple $3 \\times 3$ matrix , you will see how positive off-diagonal entries can lead to a failure of inverse-positivity, providing a clear counterexample to the comparison principle and building your intuition for the more restrictive conditions of an M-matrix.",
            "id": "3379754",
            "problem": "Consider the linear system arising from a finite difference discretization of a second-order elliptic boundary value problem on a one-dimensional uniform mesh with three interior nodes and homogeneous Dirichlet boundary conditions. Suppose the discrete operator uses the tridiagonal stencil with positive off-diagonal entries, leading to the matrix\n$$\nA \\;=\\; \\begin{pmatrix}\n2  1  0 \\\\\n1  2  1 \\\\\n0  1  2\n\\end{pmatrix}.\n$$\nStart from the fundamental definitions that a matrix is symmetric positive definite (SPD) if and only if all its leading principal minors are positive (Sylvester’s criterion), and that a discrete comparison principle for elliptic operators requires the associated stiffness matrix to be an inverse-positive matrix (for example, an $M$-matrix with nonpositive off-diagonal entries), which guarantees that nonnegative load vectors produce nonnegative discrete solutions. Without invoking any pre-packaged theorems beyond these foundational facts, do the following:\n\n1. Verify that $A$ is symmetric positive definite using Sylvester’s criterion.\n2. Compute enough of $A^{-1}$ to decide whether $A^{-1}$ is entrywise nonnegative.\n3. Interpret your findings in terms of the discrete comparison principle for elliptic operators by exhibiting a nonnegative load vector $f$ such that the discrete solution $u = A^{-1} f$ has a negative component, and explain the mechanism of failure in terms of the sign structure of $A$.\n\nYour final reported answer must be the exact value of the $(1,2)$ entry of $A^{-1}$, written as a single reduced fraction with no units. No rounding is required.",
            "solution": "The problem requires a multi-part analysis of the matrix $A$ in the context of discrete comparison principles for elliptic operators. The analysis will proceed in three steps as requested.\n\nFirst, the given matrix is:\n$$\nA \\;=\\; \\begin{pmatrix}\n2  1  0 \\\\\n1  2  1 \\\\\n0  1  2\n\\end{pmatrix}\n$$\nThe problem statement provides the definitions to be used: a matrix is symmetric positive definite (SPD) if it is symmetric and all its leading principal minors are positive (Sylvester's criterion). A discrete comparison principle holds if the matrix is inverse-positive (all entries of its inverse are nonnegative).\n\n1.  **Verification of Symmetric Positive Definite (SPD) Property**\n\nAccording to Sylvester's criterion, a symmetric matrix is positive definite if and only if all its leading principal minors are positive.\n\nFirst, we observe that $A$ is symmetric, since $A^T = A$.\n\nNext, we compute the leading principal minors of $A$. Let $A_k$ be the $k \\times k$ submatrix in the upper-left corner of $A$.\n\nThe first leading principal minor is the determinant of $A_1$:\n$$\n\\det(A_1) = \\det \\begin{pmatrix} 2 \\end{pmatrix} = 2\n$$\nSince $2  0$, this condition is met.\n\nThe second leading principal minor is the determinant of $A_2$:\n$$\n\\det(A_2) = \\det \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} = (2)(2) - (1)(1) = 4 - 1 = 3\n$$\nSince $3  0$, this condition is met.\n\nThe third leading principal minor is the determinant of $A_3 = A$:\n$$\n\\det(A_3) = \\det(A) = \\det \\begin{pmatrix}\n2  1  0 \\\\\n1  2  1 \\\\\n0  1  2\n\\end{pmatrix}\n$$\nWe can compute this by cofactor expansion along the first row:\n$$\n\\det(A) = 2 \\cdot \\det \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} - 1 \\cdot \\det \\begin{pmatrix} 1  1 \\\\ 0  2 \\end{pmatrix} + 0 = 2(3) - 1((1)(2) - (1)(0)) = 6 - 2 = 4\n$$\nSince $4  0$, this condition is also met.\n\nAll leading principal minors of the symmetric matrix $A$ are positive ($2$, $3$, and $4$). Therefore, by Sylvester's criterion, the matrix $A$ is symmetric positive definite.\n\n2.  **Computation of $A^{-1}$ to Check for Inverse-Positivity**\n\nTo determine if $A$ is inverse-positive, we must compute its inverse, $A^{-1}$. We can use the formula $A^{-1} = \\frac{1}{\\det(A)} \\text{adj}(A)$, where $\\text{adj}(A)$ is the adjugate matrix of $A$, which is the transpose of the cofactor matrix $C$.\n\nFrom the previous step, we know $\\det(A) = 4$.\n\nNow, we compute the cofactor matrix $C$, where $C_{ij} = (-1)^{i+j} M_{ij}$ and $M_{ij}$ is the minor of the entry $a_{ij}$.\n$$\nC_{11} = (-1)^{1+1} \\det \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} = 3\n$$\n$$\nC_{12} = (-1)^{1+2} \\det \\begin{pmatrix} 1  1 \\\\ 0  2 \\end{pmatrix} = -(2-0) = -2\n$$\n$$\nC_{13} = (-1)^{1+3} \\det \\begin{pmatrix} 1  2 \\\\ 0  1 \\end{pmatrix} = 1\n$$\n$$\nC_{21} = (-1)^{2+1} \\det \\begin{pmatrix} 1  0 \\\\ 1  2 \\end{pmatrix} = -(2-0) = -2\n$$\n$$\nC_{22} = (-1)^{2+2} \\det \\begin{pmatrix} 2  0 \\\\ 0  2 \\end{pmatrix} = 4\n$$\n$$\nC_{23} = (-1)^{2+3} \\det \\begin{pmatrix} 2  1 \\\\ 0  1 \\end{pmatrix} = -(2-0) = -2\n$$\n$$\nC_{31} = (-1)^{3+1} \\det \\begin{pmatrix} 1  0 \\\\ 2  1 \\end{pmatrix} = 1\n$$\n$$\nC_{32} = (-1)^{3+2} \\det \\begin{pmatrix} 2  0 \\\\ 1  1 \\end{pmatrix} = -(2-0) = -2\n$$\n$$\nC_{33} = (-1)^{3+3} \\det \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} = 3\n$$\nSo, the cofactor matrix is:\n$$\nC = \\begin{pmatrix}\n3  -2  1 \\\\\n-2  4  -2 \\\\\n1  -2  3\n\\end{pmatrix}\n$$\nThe adjugate matrix is the transpose of $C$. Since $C$ is symmetric, $\\text{adj}(A) = C^T = C$.\n$$\n\\text{adj}(A) = \\begin{pmatrix}\n3  -2  1 \\\\\n-2  4  -2 \\\\\n1  -2  3\n\\end{pmatrix}\n$$\nFinally, the inverse matrix is:\n$$\nA^{-1} = \\frac{1}{4} \\begin{pmatrix}\n3  -2  1 \\\\\n-2  4  -2 \\\\\n1  -2  3\n\\end{pmatrix} = \\begin{pmatrix}\n\\frac{3}{4}  -\\frac{1}{2}  \\frac{1}{4} \\\\\n-\\frac{1}{2}  1  -\\frac{1}{2} \\\\\n\\frac{1}{4}  -\\frac{1}{2}  \\frac{3}{4}\n\\end{pmatrix}\n$$\nThe matrix $A^{-1}$ contains negative entries, for example, $(A^{-1})_{12} = -1/2$. Therefore, $A$ is not an inverse-positive matrix.\n\n3.  **Interpretation and Explanation of Failure**\n\nThe discrete comparison principle requires the discrete operator (matrix) to be inverse-positive. This ensures that for a nonnegative load vector $f \\ge 0$ (component-wise), the solution $u = A^{-1}f$ is also nonnegative, $u \\ge 0$. Since we have shown that $A$ is not inverse-positive, the comparison principle fails for this operator.\n\nTo exhibit this failure, we need to find a nonnegative vector $f$ such that $u = A^{-1}f$ has at least one negative component. The negative entries in $A^{-1}$ guide our choice. Let's choose a load vector $f$ corresponding to a unit load at the second interior node, and zero load elsewhere:\n$$\nf = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}\n$$\nThis vector is clearly nonnegative. The solution $u$ is then given by:\n$$\nu = A^{-1}f = \\begin{pmatrix}\n\\frac{3}{4}  -\\frac{1}{2}  \\frac{1}{4} \\\\\n-\\frac{1}{2}  1  -\\frac{1}{2} \\\\\n\\frac{1}{4}  -\\frac{1}{2}  \\frac{3}{4}\n\\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -\\frac{1}{2} \\\\ 1 \\\\ -\\frac{1}{2} \\end{pmatrix}\n$$\nThe resulting solution vector is $u = (-1/2, 1, -1/2)^T$. The first and third components of $u$ are negative, even though the load vector $f$ was nonnegative. This explicitly demonstrates the failure of the discrete comparison principle.\n\nThe mechanism of this failure lies in the sign structure of the matrix $A$. A sufficient condition for a matrix to be inverse-positive is that it is a non-singular $M$-matrix. A matrix is an $M$-matrix if it is a $Z$-matrix with additional properties (e.g., being SPD). A $Z$-matrix is a matrix whose off-diagonal entries are all non-positive.\nThe given matrix $A$ has positive off-diagonal entries, such as $a_{12} = 1  0$ and $a_{23} = 1  0$. Thus, $A$ is not a $Z$-matrix, and consequently, it cannot be an $M$-matrix.\n\nThe standard finite difference discretization of an elliptic operator like $-u''$ leads to a matrix with positive diagonal entries and negative off-diagonal entries (e.g., the tridiagonal matrix with stencil $[-1, 2, -1]$). Such a matrix is a $Z$-matrix and, being diagonally dominant, is also an $M$-matrix, hence guaranteeing the discrete comparison principle. The matrix $A$ in this problem, with its positive off-diagonal entries, would correspond to a non-elliptic operator (e.g., one related to $+u''$), for which a maximum/comparison principle is not expected to hold. The property of being SPD is not sufficient to guarantee inverse-positivity; the sign structure of the off-diagonal entries is the critical factor that was violated here.\nThe $(1,2)$ entry of $A^{-1}$ is $-\\frac{1}{2}$.",
            "answer": "$$\\boxed{-\\frac{1}{2}}$$"
        },
        {
            "introduction": "Moving from abstract algebra to a practical application, this exercise explores how violations of the Discrete Maximum Principle (DMP) arise in the Finite Element Method (FEM). The geometry of the mesh plays a critical role, and certain configurations can compromise the physical realism of the numerical solution. In this practice , you will construct a stiffness matrix for a simple triangulated domain and discover firsthand how introducing an obtuse angle leads to positive off-diagonal entries, a violation of the M-matrix property, and a telltale \"overshoot\" in the solution.",
            "id": "3379716",
            "problem": "Consider the scalar diffusion equation $-\\nabla \\cdot (\\kappa \\nabla u) = f$ on the unit square domain $\\Omega = [0,1]^2$ with homogeneous Dirichlet boundary conditions $u|_{\\partial \\Omega} = 0$, where $\\kappa(x,y) \\equiv 1$ and $f(x,y)$ is a given source. The weak form is: find $u \\in H_0^1(\\Omega)$ such that for all $v \\in H_0^1(\\Omega)$,\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, dx = \\int_{\\Omega} f v \\, dx.\n$$\nLet $\\mathcal{T}_h$ be a conforming triangulation of $\\Omega$ and let $\\{ \\varphi_i \\}$ be the standard continuous, piecewise linear (hat) basis functions on $\\mathcal{T}_h$ associated with the mesh nodes. The finite element method seeks $u_h \\in V_h \\subset H_0^1(\\Omega)$ such that\n$$\n\\sum_{i,j} K_{ij} U_j \\, \\varphi_i = \\sum_i F_i \\, \\varphi_i, \\quad \\text{with} \\quad K_{ij}=\\int_{\\Omega} \\nabla \\varphi_i \\cdot \\nabla \\varphi_j \\, dx, \\quad F_i=\\int_{\\Omega} f \\varphi_i \\, dx,\n$$\nand $U_j$ the nodal values of $u_h$. For constant $f$, on each triangle $T \\in \\mathcal{T}_h$ with area $|T|$, the local load vector entries are given by $F_i^T = f|_T \\, |T|/3$ for the three local vertices in $T$. The local element stiffness matrix $\\mathbf{K}^T$ can be assembled from the constant gradients of the local basis functions. The global stiffness matrix $\\mathbf{K}$ is symmetric positive definite on the interior degrees of freedom after enforcing Dirichlet conditions.\n\nA discrete maximum principle states, under suitable mesh conditions, that the discrete solution $u_h$ respects the sign constraints implied by the continuous maximum principle. In particular, for $f \\le 0$ and homogeneous Dirichlet boundary conditions, one expects $u_h \\le 0$ at interior nodes when the reduced stiffness matrix is an $M$-matrix (i.e., off-diagonal entries are nonpositive and the matrix is weakly diagonally dominant). On meshes containing obtuse angles, some off-diagonal entries can become positive, violating the $M$-matrix property and potentially leading to interior overshoot (values $u_h  0$ inside the domain despite $u|_{\\partial \\Omega}=0$ and $f \\le 0$).\n\nYour task is to implement a program that:\n- Builds structured triangular meshes on $\\Omega$ by subdividing into $n_x \\times n_y$ rectangles and splitting each rectangle into two triangles by the diagonal from $(i,j)$ to $(i+1,j+1)$ for all integer grid points $(i,j)$.\n- Optionally perturbs specified interior grid nodes by a small displacement vector to create triangulations with obtuse angles while keeping all nodes inside $\\Omega$.\n- Assembles the global stiffness matrix $\\mathbf{K}$ and load vector $\\mathbf{F}$ using the standard piecewise linear finite element method for the operator $-\\Delta$ with $f(x,y) = -1$.\n- Enforces homogeneous Dirichlet boundary conditions at all nodes with $x=0$, $x=1$, $y=0$, or $y=1$ to obtain a reduced linear system $\\mathbf{K}_{II} \\mathbf{U}_I = \\mathbf{F}_I$ for the interior degrees of freedom.\n- Computes two diagnostics on the reduced system for each mesh:\n  1. Whether there exists a strictly positive off-diagonal entry in $\\mathbf{K}_{II}$ exceeding a threshold $\\tau = 10^{-12}$.\n  2. Whether the maximum interior nodal value of the discrete solution $u_h$ exceeds the same threshold $\\tau$, i.e., $\\max_{i \\in I} U_i  \\tau$ (an interior overshoot relative to the boundary data $u=0$).\n- Returns, for each test case, a boolean equal to the logical conjunction of these diagnostics, i.e., it should return $true$ if and only if the reduced stiffness matrix has a positive off-diagonal and the corresponding discrete solution exhibits an interior overshoot.\n\nUse the following finite set of test cases (this constitutes the test suite to evaluate distinct scenarios):\n\n- Case A (baseline mesh with no perturbation; expected to be nonobtuse in aggregate):\n  - Parameters: $(n_x, n_y) = (3,3)$.\n  - Perturbation: none (all node displacements are $(0,0)$).\n\n- Case B (designed to create an obtuse configuration; choose the smallest allowed scale that triggers both diagnostics):\n  - Parameters: $(n_x, n_y) = (3,3)$.\n  - Perturbation pattern is defined on indices $(i,j)$ in grid coordinates with $i \\in \\{0,\\dots,n_x\\}$, $j \\in \\{0,\\dots,n_y\\}$ as:\n    - At $(i,j)=(2,2)$ add base displacement $(\\delta x, \\delta y) = (0.28,-0.15)$.\n    - At $(i,j)=(1,2)$ add base displacement $(\\delta x, \\delta y) = (-0.12,0.09)$.\n    - All other nodes have $(\\delta x, \\delta y)=(0,0)$.\n  - Let $\\mathcal{S} = \\{0.2, 0.4, 0.6, 0.8, 1.0\\}$. Apply the perturbation pattern scaled by a factor $s \\in \\mathcal{S}$ and select the smallest $s$ in $\\mathcal{S}$ for which both diagnostics are satisfied. If no such $s$ exists, use $s = 1.0$.\n  - Report the boolean for this selected mesh.\n\n- Case C (near-threshold perturbation meant to avoid violation):\n  - Parameters: $(n_x, n_y) = (3,3)$.\n  - Perturbation pattern identical to Case B but with fixed scale $s = 0.15$.\n\nIn all cases use $f(x,y) = -1$ and homogeneous Dirichlet boundary data. There are no physical units to report in this problem. Your program should produce a single line of output containing the results for the three cases as a comma-separated list enclosed in square brackets (e.g., \"[true,false,true]\") where each entry is either \"True\" or \"False\" in the exact capitalization of the Python programming language boolean literals. The numerical threshold must be $\\tau = 10^{-12}$ for determining positivity and overshoot. The desired final output format is exactly one line:\n\"[result_A,result_B,result_C]\".",
            "solution": "The user-provided problem is a valid, well-posed, and scientifically rigorous exercise in the numerical solution of partial differential equations. It concerns the finite element analysis of the Poisson equation and its relation to the discrete maximum principle. I will now provide a comprehensive solution.\n\n### 1. Problem Formulation\nThe problem under consideration is the scalar Poisson equation with a constant source term on a two-dimensional domain $\\Omega$:\n$$\n-\\Delta u = f \\quad \\text{in} \\quad \\Omega = [0,1]^2\n$$\nsubject to homogeneous Dirichlet boundary conditions, $u = 0$ on the boundary $\\partial\\Omega$. The source term is given as a constant $f(x,y) = -1$. The continuous weak form of this problem is to find $u \\in H_0^1(\\Omega)$ such that for all test functions $v \\in H_0^1(\\Omega)$:\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = \\int_{\\Omega} f v \\, d\\mathbf{x}\n$$\nThe continuous maximum principle for this operator implies that if $f \\le 0$, the maximum value of $u$ must occur on the boundary $\\partial\\Omega$. Since $u=0$ on $\\partial\\Omega$, this implies $u(\\mathbf{x}) \\le 0$ for all $\\mathbf{x} \\in \\Omega$.\n\n### 2. Finite Element Discretization\n\n#### 2.1. Mesh and Basis Functions\nThe domain $\\Omega$ is discretized using a structured triangular mesh. First, a uniform grid of $(n_x+1) \\times (n_y+1)$ nodes is generated, with initial coordinates $P_{i,j} = (i/n_x, j/n_y)$ for $i \\in \\{0, \\dots, n_x\\}$ and $j \\in \\{0, \\dots, n_y\\}$. These nodes define a set of $n_x \\times n_y$ rectangular cells. Each rectangle, defined by vertices $(i,j)$, $(i+1,j)$, $(i,j+1)$, and $(i+1,j+1)$, is subdivided into two triangles by the diagonal connecting grid points $(i,j)$ and $(i+1,j+1)$. Specific interior nodes may be perturbed from their initial positions.\n\nThe finite element space $V_h$ consists of continuous, piecewise linear functions. The basis for $V_h$ is the set of \"hat\" functions $\\{\\varphi_k\\}$, where $\\varphi_k$ is equal to $1$ at node $k$ and $0$ at all other nodes. The discrete solution $u_h$ is represented as a linear combination of these basis functions:\n$$\nu_h(\\mathbf{x}) = \\sum_{j} U_j \\varphi_j(\\mathbf{x})\n$$\nwhere $U_j$ are the unknown nodal values of the solution.\n\n#### 2.2. Element Stiffness Matrix and Load Vector\nThe finite element method leads to a linear system $\\mathbf{K} \\mathbf{U} = \\mathbf{F}$, where $\\mathbf{K}$ is the global stiffness matrix and $\\mathbf{F}$ is the global load vector. These are assembled from local contributions computed on each triangular element $T \\in \\mathcal{T}_h$.\n\nFor a single triangle $T$ with vertices $\\mathbf{p}_a, \\mathbf{p}_b, \\mathbf{p}_c$, the entries of the $3 \\times 3$ local stiffness matrix $\\mathbf{K}^T$ are given by:\n$$\nK^T_{ij} = \\int_T \\nabla \\varphi_i \\cdot \\nabla \\varphi_j \\, d\\mathbf{x} = (\\nabla \\varphi_i \\cdot \\nabla \\varphi_j) |T|\n$$\nwhere $|T|$ is the area of the triangle. The gradient of a linear basis function $\\varphi_i$ is constant over the triangle. For a triangle with vertices $\\mathbf{p}_1=(x_1, y_1)$, $\\mathbf{p}_2=(x_2, y_2)$, and $\\mathbf{p}_3=(x_3, y_3)$, the gradients of the corresponding local basis functions are:\n$$\n\\nabla \\varphi_1 = \\frac{1}{2|T|} \\begin{pmatrix} y_2 - y_3 \\\\ x_3 - x_2 \\end{pmatrix}, \\quad \\nabla \\varphi_2 = \\frac{1}{2|T|} \\begin{pmatrix} y_3 - y_1 \\\\ x_1 - x_3 \\end{pmatrix}, \\quad \\nabla \\varphi_3 = \\frac{1}{2|T|} \\begin{pmatrix} y_1 - y_2 \\\\ x_2 - x_1 \\end{pmatrix}\n$$\nThe area $|T|$ can be calculated as $|T| = \\frac{1}{2} |x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)|$. An off-diagonal entry, for instance $K^T_{12}$, is related to the angle $\\theta_3$ at vertex $\\mathbf{p}_3$ by the cotangent formula: $K^T_{12} = -\\frac{1}{2}\\cot(\\theta_3)$. This entry becomes positive if the angle $\\theta_3$ is obtuse.\n\nThe local load vector $\\mathbf{F}^T$ has entries $F_i^T = \\int_T f \\varphi_i \\, d\\mathbf{x}$. For a constant source term $f$, this integral evaluates to:\n$$\nF_i^T = f \\frac{|T|}{3}\n$$\nGiven $f=-1$, the entries are $F_i^T = -|T|/3$.\n\n### 3. System Assembly and Boundary Conditions\nThe global stiffness matrix $\\mathbf{K}$ and load vector $\\mathbf{F}$ are constructed by iterating over all triangles in the mesh and adding the local element contributions $\\mathbf{K}^T$ and $\\mathbf{F}^T$ into the global system according to the global indices of the element's vertices.\n\nThe homogeneous Dirichlet boundary condition $u=0$ on $\\partial\\Omega$ means that the nodal values $U_j$ for all boundary nodes $j \\in B$ are fixed to $0$. The linear system is partitioned into interior (I) and boundary (B) degrees of freedom:\n$$\n\\begin{pmatrix} \\mathbf{K}_{II}  \\mathbf{K}_{IB} \\\\ \\mathbf{K}_{BI}  \\mathbf{K}_{BB} \\end{pmatrix}\n\\begin{pmatrix} \\mathbf{U}_I \\\\ \\mathbf{U}_B \\end{pmatrix}\n=\n\\begin{pmatrix} \\mathbf{F}_I \\\\ \\mathbf{F}_B \\end{pmatrix}\n$$\nSetting $\\mathbf{U}_B = \\mathbf{0}$, the system reduces to solving for the unknown interior nodal values $\\mathbf{U}_I$:\n$$\n\\mathbf{K}_{II} \\mathbf{U}_I = \\mathbf{F}_I\n$$\nwhere $\\mathbf{K}_{II}$ is the submatrix corresponding to interior-interior interactions, and $\\mathbf{F}_I$ is the subvector of loads at interior nodes.\n\n### 4. Numerical Diagnostics and Discrete Maximum Principle\nA stiffness matrix is an M-matrix if its off-diagonal entries are all non-positive ($K_{ij} \\le 0$ for $i \\ne j$) and it is weakly diagonally dominant. If the reduced stiffness matrix $\\mathbf{K}_{II}$ is an M-matrix, then $(\\mathbf{K}_{II})^{-1}$ will have non-negative entries. Since $\\mathbf{F}_I$ has non-positive entries (as $f=-1$), the solution $\\mathbf{U}_I = (\\mathbf{K}_{II})^{-1} \\mathbf{F}_I$ will have non-positive entries, thus satisfying a discrete maximum principle ($U_i \\le 0$).\n\nThe presence of obtuse angles in the triangulation can lead to positive off-diagonal entries in $\\mathbf{K}_{II}$, violating the M-matrix property. This may, in turn, lead to a violation of the discrete maximum principle, observed as `overshoot` where some interior nodal values $U_i$ become positive, despite the boundary conditions and forcing suggesting they should be non-positive. The task requires checking for two conditions using a numerical tolerance $\\tau=10^{-12}$:\n1.  **Positive Off-Diagonal Entry**: Whether there exists an entry $(\\mathbf{K}_{II})_{ij}  \\tau$ for $i \\ne j$.\n2.  **Interior Overshoot**: Whether the maximum interior nodal value $\\max(\\mathbf{U}_I)  \\tau$.\n\nThe final boolean result for each test case is the logical conjunction of these two conditions.\n\n### 5. Computational Procedure for Test Cases\nThe implementation will follow these steps for each test case:\n1.  Generate the mesh node coordinates for the given $(n_x, n_y)$, applying any specified perturbations.\n2.  Define the list of triangles based on the structured grid topology.\n3.  Identify the global indices corresponding to interior and boundary nodes.\n4.  Assemble the global stiffness matrix $\\mathbf{K}$ and load vector $\\mathbf{F}$ by looping through all triangles.\n5.  Extract the reduced system $\\mathbf{K}_{II}$ and $\\mathbf{F}_I$.\n6.  Solve the linear system $\\mathbf{K}_{II} \\mathbf{U}_I = \\mathbf{F}_I$ for $\\mathbf{U}_I$.\n7.  Perform the two diagnostic checks on $\\mathbf{K}_{II}$ and $\\mathbf{U}_I$.\n8.  For Case B, this procedure is iterated for specified scaling factors $s \\in \\{0.2, 0.4, 0.6, 0.8, 1.0\\}$, selecting the smallest $s$ that satisfies both diagnostics. If no such $s$ exists, the result for $s=1.0$ is used.\n9.  Return the logical AND of the two diagnostic booleans.\n\nThis procedure is implemented in the following Python code.",
            "answer": "```python\nimport numpy as np\n\ndef assemble_and_solve(nx, ny, perturbations, f_val, tau):\n    \"\"\"\n    Assembles and solves the FEM system for the Poisson equation.\n\n    Args:\n        nx (int): Number of subdivisions in x-direction.\n        ny (int): Number of subdivisions in y-direction.\n        perturbations (dict): A dict mapping (i,j) grid indices to (dx,dy) perturbations.\n        f_val (float): The constant value of the source term f.\n        tau (float): The numerical threshold for positivity checks.\n\n    Returns:\n        tuple: A tuple of two booleans:\n               (has_positive_off_diagonal, has_overshoot)\n    \"\"\"\n    # 1. Generate node coordinates\n    n_nodes_x = nx + 1\n    n_nodes_y = ny + 1\n    num_nodes = n_nodes_x * n_nodes_y\n    \n    xs = np.linspace(0.0, 1.0, n_nodes_x)\n    ys = np.linspace(0.0, 1.0, n_nodes_y)\n    nodes = np.zeros((num_nodes, 2), dtype=float)\n\n    for j in range(n_nodes_y):\n        for i in range(n_nodes_x):\n            k = i + j * n_nodes_x\n            pert = perturbations.get((i, j), (0.0, 0.0))\n            nodes[k, 0] = xs[i] + pert[0]\n            nodes[k, 1] = ys[j] + pert[1]\n\n    # 2. Generate element connectivity\n    elements = []\n    for j in range(ny):\n        for i in range(nx):\n            n00 = i + j * n_nodes_x\n            n10 = (i + 1) + j * n_nodes_x\n            n01 = i + (j + 1) * n_nodes_x\n            n11 = (i + 1) + (j + 1) * n_nodes_x\n            # Split rectangle by diagonal from (i,j) to (i+1,j+1)\n            elements.append((n00, n10, n11))\n            elements.append((n00, n11, n01))\n\n    # 3. Identify interior and boundary nodes\n    interior_nodes_indices = []\n    for j in range(1, ny):\n        for i in range(1, nx):\n            interior_nodes_indices.append(i + j * n_nodes_x)\n    \n    num_interior_nodes = len(interior_nodes_indices)\n\n    # 4. Assemble global stiffness matrix K and load vector F\n    K = np.zeros((num_nodes, num_nodes), dtype=float)\n    F = np.zeros(num_nodes, dtype=float)\n\n    for el_nodes in elements:\n        p1, p2, p3 = nodes[el_nodes[0]], nodes[el_nodes[1]], nodes[el_nodes[2]]\n        \n        # Area of the triangle\n        area = 0.5 * abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n        if area  1e-15: continue\n\n        # Gradients of basis functions\n        b = np.array([p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]])\n        c = np.array([p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]])\n        \n        # Local stiffness matrix\n        K_local = np.zeros((3, 3))\n        for i in range(3):\n            for j in range(3):\n                K_local[i, j] = (b[i] * b[j] + c[i] * c[j]) / (4.0 * area)\n\n        # Local load vector\n        F_local = (f_val * area / 3.0) * np.ones(3)\n\n        # Add to global matrix and vector (assembly)\n        for i in range(3):\n            F[el_nodes[i]] += F_local[i]\n            for j in range(3):\n                K[el_nodes[i], el_nodes[j]] += K_local[i, j]\n\n    # 5. Extract reduced system for interior nodes\n    K_II = K[np.ix_(interior_nodes_indices, interior_nodes_indices)]\n    F_I = F[interior_nodes_indices]\n\n    # 6. Solve the linear system\n    try:\n        U_I = np.linalg.solve(K_II, F_I)\n    except np.linalg.LinAlgError:\n        # Singular matrix, likely due to degenerate elements\n        # For this problem, treat as no overshoot and no positive off-diagonal\n        return (False, False)\n\n    # 7. Perform diagnostics\n    # Diagnostic 1: Check for strictly positive off-diagonal entries in K_II\n    K_II_offdiag = K_II.copy()\n    np.fill_diagonal(K_II_offdiag, 0.0)\n    has_pos_offdiag = np.any(K_II_offdiag  tau)\n    \n    # Diagnostic 2: Check for interior overshoot\n    has_overshoot = np.max(U_I)  tau if U_I.size  0 else False\n\n    return has_pos_offdiag, has_overshoot\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    TAU = 1e-12\n    F_VAL = -1.0\n    NX, NY = 3, 3\n    results = []\n\n    # Case A: Baseline mesh\n    diag1_A, diag2_A = assemble_and_solve(NX, NY, {}, F_VAL, TAU)\n    results.append(diag1_A and diag2_A)\n\n    # Case B: Perturbation with smallest effective scale\n    base_perturbations = {(2, 2): (0.28, -0.15), (1, 2): (-0.12, 0.09)}\n    s_values = [0.2, 0.4, 0.6, 0.8, 1.0]\n    \n    result_B = None\n    result_s1 = None\n\n    for s in s_values:\n        current_perturbations = {\n            node: (s * dx, s * dy) for node, (dx, dy) in base_perturbations.items()\n        }\n        diag1, diag2 = assemble_and_solve(NX, NY, current_perturbations, F_VAL, TAU)\n        \n        current_result_is_true = diag1 and diag2\n        \n        if s == 1.0:\n            result_s1 = current_result_is_true\n        \n        if current_result_is_true and result_B is None:\n            result_B = True # Found smallest s, lock in True\n            \n    if result_B is None: # No s in the list worked\n        result_B = result_s1\n        \n    results.append(result_B)\n\n    # Case C: Near-threshold perturbation\n    s_C = 0.15\n    perturbations_C = {\n        node: (s_C * dx, s_C * dy) for node, (dx, dy) in base_perturbations.items()\n    }\n    diag1_C, diag2_C = assemble_and_solve(NX, NY, perturbations_C, F_VAL, TAU)\n    results.append(diag1_C and diag2_C)\n    \n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After diagnosing the causes of DMP failure, a natural question is: can we fix it? This advanced practice introduces a powerful method to enforce monotonicity while preserving as much accuracy as possible. You will implement an Algebraic Flux-Correction (AFC) scheme , which systematically transforms a high-accuracy but non-monotone system into a low-order M-matrix system, then carefully adds back limited \"antidiffusive\" fluxes to recover accuracy. This exercise highlights the sophisticated engineering involved in designing modern numerical methods that balance mathematical accuracy with physical constraints.",
            "id": "3379775",
            "problem": "Consider the symmetric, second-order, linear diffusion equation in two dimensions, given in strong form by $-\\nabla \\cdot (\\boldsymbol{D} \\nabla u) = 0$ in a polygonal domain, with Dirichlet boundary conditions prescribed by a continuous function $g$ on the boundary. Let $\\boldsymbol{D} \\in \\mathbb{R}^{2 \\times 2}$ be a constant, symmetric, positive definite diffusion tensor. Using continuous, piecewise linear shape functions on a conforming triangulation, the standard Galerkin finite element method yields a global stiffness matrix $\\boldsymbol{K}^{H}$ with entries $K^{H}_{ij} = \\sum_{T \\in \\mathcal{T}} \\int_{T} \\nabla \\phi_{i} \\cdot \\boldsymbol{D} \\nabla \\phi_{j} \\,\\mathrm{d}x$, where $\\{\\phi_{i}\\}$ are the nodal basis functions and $\\mathcal{T}$ is the set of triangles. It is well known that when the triangulation is non-obtuse in the metric induced by $\\boldsymbol{D}$, the off-diagonal entries $K^{H}_{ij}$ are nonpositive, and the matrix satisfies a discrete maximum principle via the $M$-matrix property on the submatrix associated with free (interior) degrees of freedom. However, for anisotropic diffusion and non-Delaunay triangulations, some off-diagonal entries may become positive, compromising monotonicity.\n\nYour task is to construct an algebraic flux-correction scheme that starts from the high-order stiffness $\\boldsymbol{K}^{H}$ and produces a low-order, monotone operator $\\boldsymbol{K}^{L}$ that is an $M$-matrix on the submatrix of free degrees of freedom (in the sense of a $Z$-matrix with off-diagonals $\\le 0$ and symmetric positive definiteness), and then recover accuracy by adding limited antidiffusive fluxes to the right-hand side while solving with $\\boldsymbol{K}^{L}$. The scheme must preserve the discrete maximum principle under Dirichlet boundary conditions by enforcing local bounds during the antidiffusive flux limiting.\n\nStarting from the following fundamental base:\n- The diffusion operator $-\\nabla \\cdot (\\boldsymbol{D} \\nabla u)$ with $\\boldsymbol{D}$ symmetric positive definite.\n- The variational formulation and assembly of the stiffness matrix for linear finite elements on triangles: if $T$ is a triangle with vertices $\\boldsymbol{p}_{0}, \\boldsymbol{p}_{1}, \\boldsymbol{p}_{2}$, area $A_{T}$, and gradients $\\nabla \\phi_{i}$ constant on $T$, then $K^{H}_{ij}|_{T} = A_{T} \\, (\\nabla \\phi_{i})^{\\top} \\boldsymbol{D} \\, \\nabla \\phi_{j}$.\n- The discrete maximum principle and $M$-matrix criteria for the submatrix of free degrees of freedom: a symmetric $Z$-matrix with positive definiteness is sufficient for monotonicity of the discrete solution under Dirichlet boundary data.\n\nDesign an algebraic flux-correction (AFC) procedure that:\n- Constructs $\\boldsymbol{K}^{L}$ by removing all positive off-diagonal entries of $\\boldsymbol{K}^{H}$ and shifting the removed amounts to the diagonal to preserve row sums. That is, set $K^{L}_{ij} = \\min(K^{H}_{ij}, 0)$ for $i \\ne j$, and set $K^{L}_{ii} = K^{H}_{ii} + \\sum_{j \\ne i} \\max(K^{H}_{ij}, 0)$.\n- Solves $\\boldsymbol{K}^{L}$ with Dirichlet boundary conditions to obtain a baseline solution $u^{0}$.\n- Computes pairwise antidiffusive fluxes between free nodes, derived from the difference $\\boldsymbol{F} = \\boldsymbol{K}^{H} - \\boldsymbol{K}^{L}$ on the free-free submatrix, as $\\varphi_{ij} = -F_{ij} \\,(u_{j} - u_{i})$ for $i \\ne j$, and then applies a symmetric bound-preserving limiter $\\alpha_{ij} \\in [0,1]$ to distribute limited fluxes to the right-hand side while continuing to solve with $\\boldsymbol{K}^{L}$. The limiter must ensure that updated interior nodal values remain within the bounds of the Dirichlet data, i.e., $u_{\\min} \\le u_{i} \\le u_{\\max}$ for all interior nodes.\n\nYou must implement the above on a structured mesh of the unit square with a fixed triangulation by splitting each rectangular cell along the diagonal from the lower-left to the upper-right. Let the mesh be defined by a uniform grid of $N_{x}$ by $N_{y}$ points, with $N_{x} = 5$ and $N_{y} = 5$, and triangles formed accordingly. Impose Dirichlet boundary values $g(x,y) = x$ on all boundary nodes, and a homogeneous right-hand side $f \\equiv 0$.\n\nConstruct test cases by varying the anisotropy of $\\boldsymbol{D}$ and the limiter aggressiveness. Specifically, for each test case, let $\\boldsymbol{D} = \\begin{bmatrix} 1  s \\\\ s  1 \\end{bmatrix}$ with $s \\in \\{0.99, 0.99, 0.50\\}$, and the limiter strength parameter $\\theta \\in \\{0.00, 1.00, 1.00\\}$, respectively. The limiter scaling must be applied to the node-based limiting factors so that $\\alpha_{ij}$ is multiplied by $\\theta$, i.e., $\\alpha_{ij}^{\\theta} = \\theta \\alpha_{ij}$.\n\nFor each test case, perform the following steps:\n- Assemble $\\boldsymbol{K}^{H}$ and construct $\\boldsymbol{K}^{L}$.\n- Form the free-free submatrices corresponding to interior nodes after applying Dirichlet boundary conditions, and solve for the high-order solution $u^{H}$ and the AFC-corrected solution $u^{\\mathrm{AFC}}$ starting from $u^{0}$ with a fixed number of nonlinear flux-correction iterations.\n- Verify the $M$-matrix property of $\\boldsymbol{K}^{L}$ on the free-free submatrix by checking that off-diagonal entries are $\\le 0$ and that the matrix is symmetric positive definite.\n- Check the discrete maximum principle for $u^{\\mathrm{AFC}}$ by confirming $u_{\\min} \\le u_{i} \\le u_{\\max}$ for all interior nodes, where $u_{\\min}$ and $u_{\\max}$ are the minimum and maximum of boundary values.\n- Quantify the accuracy-monotonicity balance by computing the relative $\\ell^{2}$-norm error $\\|u^{\\mathrm{AFC}} - u^{H}\\|_{2} / \\max(\\|u^{H}\\|_{2}, \\varepsilon)$ with $\\varepsilon$ a small positive number to avoid division by zero, and the fraction of positive off-diagonals in the high-order free-free matrix $\\boldsymbol{K}^{H}_{\\mathrm{ff}}$.\n\nYour program must produce, for the three test cases specified, a single line of output containing a comma-separated list of the results enclosed in square brackets, where each test case result is a list of the form $[\\text{is\\_M\\_matrix},\\text{dmp\\_holds},\\text{rel\\_error},\\text{pos\\_fraction}]$. The values $\\text{is\\_M\\_matrix}$ and $\\text{dmp\\_holds}$ must be boolean, and $\\text{rel\\_error}$ and $\\text{pos\\_fraction}$ must be floats. No physical units are involved; angles are not required. The final output format must be exactly a single Python list rendered as a single line string, for example, $[[\\text{True},\\text{True},0.012345,0.100000],[\\text{True},\\text{True},0.056789,0.080000],[\\text{True},\\text{True},0.004321,0.000000]]$.",
            "solution": "The user-provided problem statement requires the implementation and analysis of an algebraic flux-correction (AFC) scheme for a two-dimensional, anisotropic diffusion equation. The problem is well-posed, scientifically sound, and contains sufficient detail for a rigorous numerical implementation. I will proceed with a solution.\n\nThe core of the task is to construct a numerical scheme that guarantees a discrete maximum principle (DMP) while attempting to retain the higher accuracy of a standard Galerkin finite element method (FEM). The standard FEM discretization, which we term the high-order method, can produce solutions with unphysical oscillations when the mesh is not aligned with the anisotropy of the diffusion tensor $\\boldsymbol{D}$. This loss of monotonicity corresponds to the appearance of positive off-diagonal entries in the stiffness matrix $\\boldsymbol{K}^{H}$, violating the M-matrix property required for a DMP.\n\nThe AFC scheme addresses this in three main stages:\n1.  **Construction of a Monotone Operator**: A low-order stiffness matrix, $\\boldsymbol{K}^{L}$, is created from the high-order matrix, $\\boldsymbol{K}^{H}$. This is achieved by an algebraic modification: any positive off-diagonal entry $K^{H}_{ij}$ (for $i \\neq j$) is removed (set to zero), and the removed quantity is added to the corresponding diagonal entry $K^{L}_{ii}$. This procedure, defined as $K^{L}_{ij} = \\min(K^{H}_{ij}, 0)$ for $i \\neq j$ and $K^{L}_{ii} = K^{H}_{ii} + \\sum_{j \\neq i} \\max(K^{H}_{ij}, 0)$, ensures that $\\boldsymbol{K}^{L}$ has non-positive off-diagonals (a Z-matrix) and preserves the row sums of $\\boldsymbol{K}^{H}$. If $\\boldsymbol{K}^{H}$ is symmetric positive definite (SPD), $\\boldsymbol{K}^{L}$ is also guaranteed to be SPD, making it an M-matrix. A linear system involving an M-matrix and appropriate right-hand side conditions satisfies a DMP. Solving with $\\boldsymbol{K}^{L}$ yields a non-oscillatory but overly diffusive (low-accuracy) solution, $u^{0}$.\n\n2.  **Definition of Antidiffusive Fluxes**: The difference between the high-order and low-order operators, $\\boldsymbol{F} = \\boldsymbol{K}^{H} - \\boldsymbol{K}^{L}$, represents the artificial diffusion added to create $\\boldsymbol{K}^{L}$. To recover accuracy, we define antidiffusive fluxes based on this difference. For any two free (interior) nodes $i$ and $j$, the raw antidiffusive flux is $\\varphi_{ij} = -F_{ff,ij} (u_{j} - u_{i})$, where $\\boldsymbol{F}_{ff}$ is the submatrix of $\\boldsymbol{F}$ corresponding to free nodes and $u$ is the current solution estimate. The term $(\\boldsymbol{K}^{H} - \\boldsymbol{K}^{L})u$ can be re-interpreted as a vector of these flux sums.\n\n3.  **Flux Limiting and Correction**: The raw fluxes are added back to the right-hand side of the low-order system, but they must be \"limited\" to ensure the resulting solution does not violate the DMP. We perform a fixed number of nonlinear iterations, starting with $u^{(0)} = u^{0}$. At each iteration $k$, we solve the system $\\boldsymbol{K}^{L}_{ff} u^{(k+1)}_{f} = b^{L}_{f} + c_{f}$, where $b^{L}_{f}$ is the right-hand side vector from the boundary conditions for the low-order system, and $c_{f}$ is a vector of limited antidiffusive fluxes computed from the previous solution $u^{(k)}_{f}$. The limiter must ensure that the solution $u^{(k+1)}_{f}$ remains bounded by the minimum and maximum values of the Dirichlet boundary data, $u_{\\min}$ and $u_{\\max}$.\n\nA symmetric, bound-preserving limiter is constructed as follows:\n- The solution $u_f$ to $\\boldsymbol{K}^L_{ff} u_f = b'$ satisfies the DMP if $u_{\\min} \\sum_{j} K^L_{ff,ij} \\le b'_i \\le u_{\\max} \\sum_{j} K^L_{ff,ij}$ for each free node $i$.\n- This provides upper and lower bounds, $C_i^{+}$ and $C_i^{-}$, for the total limited flux correction $c_i$ that can be added to the right-hand side $b^L_i$.\n- We first compute nodal limiting factors $\\beta_i \\in [0,1]$ by comparing the sum of all raw incoming/outgoing fluxes at node $i$ to these bounds.\n- A symmetric pairwise limiting coefficient $\\alpha_{ij} \\in [0,1]$ for the flux between nodes $i$ and $j$ is then computed as $\\alpha_{ij} = \\min(\\beta_i, \\beta_j)$. This ensures conservation, as the amount of flux leaving node $i$ towards $j$ is the same as the amount received by $j$ from $i$.\n- A global limiter strength parameter $\\theta$ is applied, such that the final limiter is $\\alpha^{\\theta}_{ij} = \\theta \\alpha_{ij}$.\n\nThe implementation will proceed by first setting up the mesh and boundary conditions. Then, for each test case, we assemble $\\boldsymbol{K}^{H}$, derive $\\boldsymbol{K}^{L}$, solve for the high-order solution $u^{H}$ and the initial low-order solution $u^{0}$, and then perform $5$ iterations of the flux-correction loop to find the final $u^{\\mathrm{AFC}}$. Finally, we compute the required metrics: M-matrix-ness of $\\boldsymbol{K}^{L}_{ff}$, satisfaction of the DMP by $u^{\\mathrm{AFC}}$, the relative error between $u^{\\mathrm{AFC}}$ and $u^{H}$, and the fraction of positive off-diagonals in $\\boldsymbol{K}^{H}_{ff}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the AFC scheme for the specified test cases.\n    \"\"\"\n    test_cases = [\n        {'s': 0.99, 'theta': 0.00},\n        {'s': 0.99, 'theta': 1.00},\n        {'s': 0.50, 'theta': 1.00},\n    ]\n\n    results = []\n    for case in test_cases:\n        s, theta = case['s'], case['theta']\n        result = run_simulation(s, theta, Nx=5, Ny=5)\n        results.append(result)\n\n    # Format the final output string\n    result_str = \"[\" + \",\".join([\n        f\"[{res[0]},{res[1]},{res[2]:.6f},{res[3]:.6f}]\"\n        for res in results\n    ]).replace(\"True\", \"True\").replace(\"False\", \"False\") + \"]\"\n    print(result_str)\n\ndef run_simulation(s, theta, Nx, Ny, n_afc_iter=5, epsilon=1e-12):\n    \"\"\"\n    Performs the full AFC simulation for a single test case.\n    \"\"\"\n    # --- 1. Mesh Generation and Node Classification ---\n    n_nodes = Nx * Ny\n    coords = np.array([[i / (Nx - 1) for i in range(Nx)] for _ in range(Ny)]).flatten()\n    coords = np.vstack((coords, np.array([[j / (Ny - 1)] * Nx for j in range(Ny)]).flatten())).T\n    \n    node_map_2d_to_1d = lambda i, j: j * Nx + i\n    is_boundary = np.zeros(n_nodes, dtype=bool)\n    for j in range(Ny):\n        for i in range(Nx):\n            idx = node_map_2d_to_1d(i, j)\n            if i == 0 or i == Nx - 1 or j == 0 or j == Ny - 1:\n                is_boundary[idx] = True\n\n    free_nodes = np.where(~is_boundary)[0]\n    bdy_nodes = np.where(is_boundary)[0]\n    \n    elements = []\n    for j in range(Ny - 1):\n        for i in range(Nx - 1):\n            p0, p1, p2, p3 = (\n                node_map_2d_to_1d(i, j), node_map_2d_to_1d(i + 1, j),\n                node_map_2d_to_1d(i, j + 1), node_map_2d_to_1d(i + 1, j + 1)\n            )\n            elements.append([p0, p1, p3])\n            elements.append([p0, p3, p2])\n\n    # --- 2. FEM Assembly ---\n    D = np.array([[1, s], [s, 1]])\n    K_H = np.zeros((n_nodes, n_nodes))\n    for el_nodes in elements:\n        p = coords[el_nodes]\n        # Using properties of barycentric coordinates to find gradients\n        mat = np.array([[1, p[0, 0], p[0, 1]], [1, p[1, 0], p[1, 1]], [1, p[2, 0], p[2, 1]]])\n        area = 0.5 * abs(np.linalg.det(mat))\n        grad_coeffs = np.linalg.inv(mat)[:, 1:]\n        \n        K_el = area * (grad_coeffs @ D @ grad_coeffs.T)\n        \n        for i in range(3):\n            for j in range(3):\n                K_H[el_nodes[i], el_nodes[j]] += K_el[i, j]\n\n    # --- 3. Construct K_L ---\n    K_L = K_H.copy()\n    for i in range(n_nodes):\n        diag_add = 0\n        for j in range(n_nodes):\n            if i == j: continue\n            if K_L[i, j]  0:\n                diag_add += K_L[i, j]\n                K_L[i, j] = 0\n        K_L[i, i] += diag_add\n\n    # --- 4. Apply BC and Partition Matrices ---\n    u = np.zeros(n_nodes)\n    u[bdy_nodes] = coords[bdy_nodes, 0]  # g(x,y) = x\n    u_d = u[bdy_nodes]\n    u_min, u_max = u_d.min(), u_d.max()\n\n    K_H_ff = K_H[np.ix_(free_nodes, free_nodes)]\n    K_H_fd = K_H[np.ix_(free_nodes, bdy_nodes)]\n    K_L_ff = K_L[np.ix_(free_nodes, free_nodes)]\n    K_L_fd = K_L[np.ix_(free_nodes, bdy_nodes)]\n\n    # --- 5. Solve for H, L, and AFC solutions ---\n    b_H = -K_H_fd @ u_d\n    u_H_f = np.linalg.solve(K_H_ff, b_H)\n\n    b_L = -K_L_fd @ u_d\n    u_0_f = np.linalg.solve(K_L_ff, b_L)\n    \n    u_afc_f = u_0_f.copy()\n    num_free = len(free_nodes)\n    F_ff = K_H_ff - K_L_ff\n    \n    for _ in range(n_afc_iter):\n        current_u = u_afc_f\n        \n        flux_ij = np.zeros((num_free, num_free))\n        for i in range(num_free):\n            for j in range(i + 1, num_free):\n                f = -F_ff[i, j] * (current_u[j] - current_u[i])\n                flux_ij[i, j] = f\n                flux_ij[j, i] = -f\n        \n        c_raw = np.sum(flux_ij, axis=1)\n\n        K_L_ff_row_sums = K_L_ff.sum(axis=1)\n        C_plus = u_max * K_L_ff_row_sums - b_L\n        C_minus = u_min * K_L_ff_row_sums - b_L\n\n        beta = np.ones(num_free)\n        for i in range(num_free):\n            if c_raw[i]  epsilon:\n                beta[i] = min(1.0, C_plus[i] / c_raw[i]) if C_plus[i] = 0 else 0.0\n            elif c_raw[i]  -epsilon:\n                beta[i] = min(1.0, C_minus[i] / c_raw[i]) if C_minus[i] = 0 else 0.0\n        \n        c_limited = np.zeros(num_free)\n        for i in range(num_free):\n            for j in range(i + 1, num_free):\n                alpha_ij = theta * min(beta[i], beta[j])\n                limited_flux = alpha_ij * flux_ij[i, j]\n                c_limited[i] += limited_flux\n                c_limited[j] -= limited_flux\n\n        b_afc = b_L + c_limited\n        u_afc_f = np.linalg.solve(K_L_ff, b_afc)\n    \n    # --- 6. Verification ---\n    off_diag_L_ff = K_L_ff - np.diag(np.diag(K_L_ff))\n    is_Z_matrix = np.all(off_diag_L_ff = epsilon)\n    is_spd = np.all(np.linalg.eigvalsh(K_L_ff)  -epsilon)\n    is_M_matrix = bool(is_Z_matrix and is_spd)\n    \n    dmp_holds = bool(np.all(u_afc_f = u_min - epsilon) and np.all(u_afc_f = u_max + epsilon))\n\n    norm_uH = np.linalg.norm(u_H_f)\n    rel_error = np.linalg.norm(u_afc_f - u_H_f) / max(norm_uH, epsilon)\n\n    off_diag_H_ff = K_H_ff - np.diag(np.diag(K_H_ff))\n    pos_count = np.sum(off_diag_H_ff  epsilon)\n    num_off_diag = K_H_ff.shape[0] * (K_H_ff.shape[0] - 1)\n    pos_fraction = pos_count / num_off_diag if num_off_diag  0 else 0.0\n\n    return [is_M_matrix, dmp_holds, rel_error, pos_fraction]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}