{
    "hands_on_practices": [
        {
            "introduction": "快速泊松求解器的基础，尤其是在处理狄利克雷（Dirichlet）问题时，是离散正弦变换（DST）。本练习将超越简单的公式应用，要求你从第一性原理出发，推导离散拉普拉斯算子的特征值。通过分析一个在特征值公式中与奇偶性相关的微妙但关键的错误 ()，你将深入理解该方法的内在机制，并为构建精确可靠的求解器打下坚实的基础。",
            "id": "3391502",
            "problem": "考虑一个矩形域上的狄利克雷-泊松问题，该问题具有齐次边界条件，并在均匀张量积网格上通过二阶中心差分进行离散。设连续问题定义在开放单位正方形上，离散算子为标准的 $5$ 点拉普拉斯算子，在 $x$ 和 $y$ 方向上分别有 $n_x$ 和 $n_y$ 个内部未知数。记 $h_x = 1/(n_x+1)$ 和 $h_y = 1/(n_y+1)$，并设离散网格点为 $x_i = i h_x$ 和 $y_j = j h_y$，其中 $i = 1,\\dots,n_x$ 且 $j=1,\\dots,n_y$。已知在每个坐标方向上的离散狄利克雷特征向量是正弦函数，相应的特征值是网格间距和离散模态指数的函数。矩形域上的快速泊松求解器沿每个轴使用 I 型离散正弦变换 (DST-I) 来对角化离散拉普拉斯算子，并在变换空间中以 $\\mathcal{O}(n_x n_y \\log(n_x n_y))$ 的时间复杂度求解。\n\n你的任务是分析、推导、实现和测试 DST-I 特征值公式中一个与奇偶性相关的微小索引错误（在角度归一化中使用 $n$ 而不是 $n+1$）在 $n$ 为偶数与奇数时对精度降低的不同方式。你必须从有限差分离散和正弦变换对角化的第一性原理出发，不假设任何闭式谱公式；根据需要进行推导。\n\n出发点（基本依据）：\n- 连续问题为 $-\\Delta u = f$，在开放单位正方形上具有齐次狄利克雷边界条件。\n- 在内部点 $\\{x_i\\}$ 上，$-u''$ 的一维二阶中心差分格式为 $(2 u_i - u_{i-1} - u_{i+1})/h^2$，其中 $u_0 = u_{n+1} = 0$。\n- 二维离散拉普拉斯算子是 $x$ 和 $y$ 方向上一维算子的 Kronecker 和。\n- DST-I 对角化了均匀网格上的一维狄利克雷算子。\n\n你必须：\n- 从有限差分算子和正弦基出发，推导一维情况下的正确特征对以及变换空间中导出的二维分离。清晰地说明带有正交归一化的 DST-I 如何对角化算子，并为每个模态产生一个标量求解问题。\n- 定义一个特征值错位变体，其中 $x$ 方向的角度归一化错误地使用 $n_x$ 代替 $n_x+1$ 来计算模态角度，而 $y$ 方向保持正确。解释为什么在编写基于 DST 的求解器时，这是一个合理的实现陷阱。\n- 使用带有正交归一化的 DST-I 实现两个快速泊松求解器：\n  $1$) 一个在两个方向上都使用正确推导的特征值的正确求解器，以及\n  $2$) 一个错位求解器，它使用上述错误的 $x$ 方向角度归一化，同时保持 $h_x$ 和 $h_y$ 分别由 $n_x+1$ 和 $n_y+1$ 定义。\n- 使用这些求解器在内部网格上求解离散泊松方程，数据由制造解法生成。对于制造解，使用 $u(x,y) = \\sin(\\pi x)\\sin(2\\pi y)$ 并解析计算 $f(x,y) = -\\Delta u(x,y)$。在内部网格点上计算 $f$ 和精确解 $u$ 的值。测量无穷范数误差 $e_{\\infty} = \\max_{i,j} |u_{i,j}^{\\text{num}} - u(x_i,y_j)|$。\n\n设计一个揭示奇偶性效应的测试套件：\n- 情况 A (理想路径，正确求解器)：$(n_x,n_y) = (31,31)$ 和 $(n_x,n_y) = (32,32)$，计算正确求解器的 $e_{\\infty}$。\n- 情况 B (奇偶性敏感度，错位求解器)：$(n_x,n_y) = (31,31)$ 和 $(n_x,n_y) = (32,32)$，计算错位求解器的 $e_{\\infty}$。\n- 情况 C (定向谱回归探针)：对于 $(n_x,n_y) = (32,32)$ 和模态指数 $(k,\\ell) = (n_x/2,1)$，以及对于 $(n_x,n_y) = (31,31)$ 和模态指数 $(k,\\ell) = ((n_x-1)/2,1)$，构造一个在变换空间中为单个正交归一化 DST-I 基向量的强迫项，并比较正确求解器和错位求解器返回的标量模态振幅。报告每种奇偶性下的相对振幅差异，这是一个由以下公式定义的无量纲浮点数：\n$$\n\\varepsilon_{\\text{rel}} = \\left|\\frac{1}{\\lambda^{\\text{bug}}_{x}(k)+\\lambda_{y}(\\ell)} - \\frac{1}{\\lambda_{x}(k)+\\lambda_{y}(\\ell)}\\right| \\bigg/ \\left|\\frac{1}{\\lambda_{x}(k)+\\lambda_{y}(\\ell)}\\right|.\n$$\n这将分离出特征值错位在对偶数 $n_x$ 最敏感的特定模态上的影响。\n- 此外，提供错位求解器在偶数尺寸与奇数尺寸下的制造解误差之比，即 $e_{\\infty}^{\\text{bug}}(32,32) / e_{\\infty}^{\\text{bug}}(31,31)$，以量化平滑强迫项上的任何奇偶性偏差。\n- 最后，计算一个布尔回归指标，当且仅当偶数情况下的定向谱差异至少是奇数情况下的 $5$ 倍时，该指标为真。\n\n你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$[e_{\\infty}^{\\text{corr}}(31,31), e_{\\infty}^{\\text{corr}}(32,32), e_{\\infty}^{\\text{bug}}(31,31), e_{\\infty}^{\\text{bug}}(32,32), e_{\\infty}^{\\text{bug}}(32,32)/e_{\\infty}^{\\text{bug}}(31,31), \\varepsilon_{\\text{rel}}^{\\text{even}}, \\varepsilon_{\\text{rel}}^{\\text{odd}}, \\text{flag}]$,\n其中 $\\text{flag}$ 是上面描述的布尔回归指标。所有量都是无量纲的。不报告任何角度；所有三角函数都以弧度计算。输出必须是严格的一行，包含指定顺序的列表，没有其他附加文本。前七个条目应为浮点数类型，最后一个条目应为布尔类型。",
            "solution": "用户提供的问题经评估有效。该问题在科学上是合理的、适定的、客观的且规范完整的。该问题描述了一项标准的数值分析任务，涉及使用谱方法（离散正弦变换）求解泊松方程，并要求对一个具体的、合理的实现错误进行定量分析。所有组成部分都基于数值偏微分方程的既定原理。因此，我们可以继续进行推导和求解。\n\n问题的核心是理解离散泊松算子如何通过离散正弦变换 (DST) 被对角化，以及由此产生的特征值误差如何影响解的精度。\n\n**1. 一维离散拉普拉斯算子及其特征分解**\n\n考虑一维边值问题 $-\\frac{d^2u}{dx^2} = f(x)$，定义在区间 $(0, 1)$ 上，并带有齐次狄利克雷边界条件 $u(0) = u(1) = 0$。我们在一个具有 $n$ 个内部点 $x_i = i h$（其中 $i=1, \\dots, n$）的均匀网格上对此问题进行离散化，网格间距为 $h = 1/(n+1)$。边界点为 $x_0 = 0$ 和 $x_{n+1} = 1$。\n\n在内部点 $x_i$ 处，使用二阶中心有限差分近似二阶导数，算子 $-\\frac{d^2}{dx^2}$ 被近似为\n$$ (-\\nabla_h^2 u)_i = \\frac{-u_{i-1} + 2u_i - u_{i+1}}{h^2} $$\n其中 $u_i \\approx u(x_i)$。边界条件意味着 $u_0 = 0$ 和 $u_{n+1} = 0$。这种离散化产生了一个线性系统 $A_n \\mathbf{u} = \\mathbf{f}$，其中 $\\mathbf{u} = [u_1, \\dots, u_n]^T$，而 $n \\times n$ 矩阵 $A_n$ 是一个对称三对角托普利茨矩阵：\n$$ A_n = \\frac{1}{h^2} \\begin{pmatrix} 2  -1   \\\\ -1  2  -1  \\\\  \\ddots  \\ddots  \\ddots \\\\   -1  2  -1 \\\\    -1  2 \\end{pmatrix} $$\n$A_n$ 的特征向量已知为离散正弦向量。让我们验证这一点并找出相应的特征值。我们假设一个特征向量 $\\mathbf{v}_k$，其分量为 $(v_k)_i = \\sin\\left(\\frac{ik\\pi}{n+1}\\right)$，其中 $i=1, \\dots, n$，$k=1, \\dots, n$ 是模态指数。将 $h^2 A_n$ 的第 $i$ 行作用于 $\\mathbf{v}_k$ 得到：\n$$ (h^2 A_n \\mathbf{v}_k)_i = 2\\sin\\left(\\frac{ik\\pi}{n+1}\\right) - \\sin\\left(\\frac{(i-1)k\\pi}{n+1}\\right) - \\sin\\left(\\frac{(i+1)k\\pi}{n+1}\\right) $$\n使用三角恒等式 $\\sin(\\alpha-\\beta) + \\sin(\\alpha+\\beta) = 2\\sin(\\alpha)\\cos(\\beta)$，我们可以简化第二项和第三项的和：\n$$ \\sin\\left(\\frac{ik\\pi}{n+1} - \\frac{k\\pi}{n+1}\\right) + \\sin\\left(\\frac{ik\\pi}{n+1} + \\frac{k\\pi}{n+1}\\right) = 2\\sin\\left(\\frac{ik\\pi}{n+1}\\right)\\cos\\left(\\frac{k\\pi}{n+1}\\right) $$\n将其代回，我们得到：\n$$ (h^2 A_n \\mathbf{v}_k)_i = 2\\sin\\left(\\frac{ik\\pi}{n+1}\\right) - 2\\sin\\left(\\frac{ik\\pi}{n+1}\\right)\\cos\\left(\\frac{k\\pi}{n+1}\\right) = 2\\left(1 - \\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right)\\sin\\left(\\frac{ik\\pi}{n+1}\\right) $$\n使用半角公式 $1-\\cos(\\theta) = 2\\sin^2(\\theta/2)$，上式变为：\n$$ (h^2 A_n \\mathbf{v}_k)_i = 4\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right)\\sin\\left(\\frac{ik\\pi}{n+1}\\right) = \\left( 4\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right) \\right) (v_k)_i $$\n因此，$\\mathbf{v}_k$ 确实是 $A_n$ 的特征向量，其对应的特征值为：\n$$ \\lambda_k = \\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right) $$\n向量集合 $\\{\\mathbf{v}_k\\}_{k=1}^n$ 构成一个正交基。从标准基到此特征基的向量变换是 I 型离散正弦变换 (DST-I)。\n\n**2. 二维问题与变量分离**\n\n在单位正方形 $(0,1) \\times (0,1)$ 上的连续问题 $-\\Delta u = f$，带有齐次狄利克雷边界条件，在一个 $n_x \\times n_y$ 的内部点网格上进行离散化。作用于网格函数 $U$（一个 $n_y \\times n_x$ 的未知数矩阵）的离散拉普拉斯算子 $A$ 可以用 Kronecker 积写出。如果我们将 $U$ 堆叠成一个长度为 $n_x n_y$ 的向量，矩阵 $A$ 由 Kronecker 和给出：\n$$ A = I_{n_y} \\otimes A_{n_x} + A_{n_y} \\otimes I_{n_x} $$\n其中 $A_{n_x}$ 和 $A_{n_y}$ 分别是 $x$ 和 $y$ 方向上的一维离散拉普拉斯算子，而 $I$ 是单位矩阵。\n\nKronecker 和的特征向量是组成矩阵特征向量的 Kronecker 积。对于二维网格函数，$A$ 的特征向量是一维正弦特征向量的外积：\n$$ E_{k,\\ell}(i,j) = (v_k^x)_i (v_\\ell^y)_j = \\sin\\left(\\frac{ik\\pi}{n_x+1}\\right) \\sin\\left(\\frac{j\\ell\\pi}{n_y+1}\\right) $$\n其中 $i=1,\\dots,n_x$，$j=1,\\dots,n_y$，$k=1,\\dots,n_x$，以及 $\\ell=1,\\dots,n_y$。$A$ 相应的特征值是一维特征值的和：\n$$ \\lambda_{k,\\ell} = \\lambda_x(k) + \\lambda_y(\\ell) = \\frac{4}{h_x^2}\\sin^2\\left(\\frac{k\\pi}{2(n_x+1)}\\right) + \\frac{4}{h_y^2}\\sin^2\\left(\\frac{\\ell\\pi}{2(n_y+1)}\\right) $$\n\n**3. 快速泊松求解器算法**\n\n快速泊松求解器利用了这种特征分解。离散方程是 $A U = F$，其中 $U$ 和 $F$ 是网格函数。该算法分为三个步骤：\n1.  **分析（正变换）：** 将右侧网格函数 $F$ 分解到特征向量基 $\\{E_{k,\\ell}\\}$ 上。这通过对 $F$ 执行二维 DST-I 来完成。设 $\\hat{F}$ 为变换系数矩阵。\n    $$ \\hat{F} = \\text{DST}(F) $$\n2.  **在变换空间中标量求解：** 在特征基中，微分算子是对角化的。解的系数 $\\hat{U}_{k,\\ell}$ 的方程对于每个模态 $(k,\\ell)$ 都变成一个简单的标量除法：\n    $$ \\lambda_{k,\\ell} \\hat{U}_{k,\\ell} = \\hat{F}_{k,\\ell} \\implies \\hat{U}_{k,\\ell} = \\frac{\\hat{F}_{k,\\ell}}{\\lambda_{k,\\ell}} $$\n3.  **合成（逆变换）：** 通过对系数 $\\hat{U}$ 执行二维 DST-I 逆变换来重构解的网格函数 $U$。\n    $$ U = \\text{IDST}(\\hat{U}) $$\nDST-I（及其逆变换）可以使用快速傅里叶变换 (FFT) 算法快速计算，从而使求解器具有“快速”的特性，其复杂度为 $\\mathcal{O}(n_x n_y \\log(n_x n_y))$。\n\n**4. 错位特征值及其与奇偶性相关的影响**\n\n问题指定了一个实现中的错误，即 $x$ 方向的特征值计算在正弦函数的参数中错误地使用了 $n_x$ 而不是 $n_x+1$。这是一个合理的实现错误，源于对网格点数 ($n_x$) 和定义基函数周期的区间数 ($n_x+1$) 的混淆。\n- **正确的 $x$ 方向特征值：** $\\lambda_x(k) = \\frac{4}{h_x^2}\\sin^2\\left(\\frac{k\\pi}{2(n_x+1)}\\right)$\n- **错误的 $x$ 方向特征值：** $\\lambda^{\\text{bug}}_x(k) = \\frac{4}{h_x^2}\\sin^2\\left(\\frac{k\\pi}{2n_x}\\right)$\n\n此错误引入的误差在不同模态或网格尺寸上并非一致。由于奇偶性的原因，会出现显著的差异。\n\n考虑 $n_x$ 为 **偶数** 的情况，$n_x = 2m$。问题引导我们研究模态 $k = m = n_x/2$。\n- 错误公式中正弦函数的参数变为 $\\frac{m\\pi}{2(2m)} = \\frac{\\pi}{4}$。\n- 正确公式中的参数为 $\\frac{m\\pi}{2(2m+1)}$。\n对于这个中心模态，错误的公式计算出 $\\sin^2(\\pi/4) = 1/2$，这是一个不依赖于 $n_x$ 的常数值。正确的公式在一个当 $n_x \\to \\infty$ 时趋近于 $\\pi/4$ 的参数点上计算函数值。对于中等大小的 $n_x$，其差值 $\\sin^2(\\frac{n_x\\pi}{4(n_x+1)}) - \\sin^2(\\frac{\\pi}{4})$ 是显著的。\n\n现在考虑 $n_x$ 为 **奇数** 的情况，$n_x = 2m+1$。我们研究模态 $k = m = (n_x-1)/2$。\n- 错误公式中正弦函数的参数为 $\\frac{m\\pi}{2(2m+1)}$。\n- 正确公式中的参数为 $\\frac{m\\pi}{2(2m+2)}$。\n在这里，两个参数都是 $n_x$ 的函数，并且彼此非常接近，特别是对于大的 $n_x$。其差值 $\\sin^2\\left(\\frac{(n_x-1)\\pi}{4n_x}\\right)$ 和 $\\sin^2\\left(\\frac{(n_x-1)\\pi}{4(n_x+1)}\\right)$ 远小于偶数情况。\n\n这种结构上的差异解释了奇偶性敏感度。在偶数情况下，模态 $n_x/2$ 的误差异常大，因为错误的公式恰好锁定在一个特殊角度 $\\pi/4$ 上，从而与正确的、邻近的角度产生了更显著的偏差。在奇数情况下，对于相应的模态没有出现这种巧合。制造解是平滑的，会激发许多模态，但偶数 $n_x$ 情况下特定模態上被放大的误差会污染整个解，并导致更大的最大误差。单模态强迫项测试直接分离出了这种效应。",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import dst\n\ndef solve():\n    \"\"\"\n    Analyzes the effect of a parity-dependent eigenvalue error in a fast Poisson solver.\n    \"\"\"\n\n    def fast_poisson_solver(nx, ny, f_grid, is_buggy):\n        \"\"\"\n        Solves the Poisson equation on a rectangular grid using a 2D DST-I.\n\n        Args:\n            nx (int): Number of interior grid points in the x-direction.\n            ny (int): Number of interior grid points in the y-direction.\n            f_grid (np.ndarray): The right-hand side function evaluated on the grid.\n            is_buggy (bool): If True, uses the misaligned eigenvalue formula for the x-direction.\n\n        Returns:\n            np.ndarray: The numerical solution on the grid.\n        \"\"\"\n        # Step 1: Analysis (Forward 2D DST-I)\n        # The transform is applied separably.\n        # Scipy's DST with type=1 and norm='ortho' is its own inverse.\n        f_hat = dst(dst(f_grid, axis=1, type=1, norm='ortho'), axis=0, type=1, norm='ortho')\n\n        # Step 2: Define eigenvalues and solve in transform space\n        hx = 1 / (nx + 1)\n        hy = 1 / (ny + 1)\n        \n        # Mode indices k for x-direction, l for y-direction\n        k = np.arange(1, nx + 1)\n        l = np.arange(1, ny + 1)\n\n        # Calculate 1D eigenvalues for the x-direction\n        if is_buggy:\n            # Mistaken formula using n_x instead of n_x+1 in the angle\n            lambda_x = (4 / hx**2) * np.sin(k * np.pi / (2 * nx))**2\n        else:\n            # Correct formula\n            lambda_x = (4 / hx**2) * np.sin(k * np.pi / (2 * (nx + 1)))**2\n        \n        # Calculate 1D eigenvalues for the y-direction (always correct)\n        lambda_y = (4 / hy**2) * np.sin(l * np.pi / (2 * (ny + 1)))**2\n\n        # Create the 2D grid of eigenvalues lambda_k,l = lambda_x(k) + lambda_y(l)\n        # np.add.outer combines the (ny,) and (nx,) arrays into a (ny, nx) grid.\n        eigenvalue_grid = np.add.outer(lambda_y, lambda_x)\n        \n        # Solve for coefficients of the solution\n        u_hat = f_hat / eigenvalue_grid\n\n        # Step 3: Synthesis (Inverse 2D DST-I)\n        u_num = dst(dst(u_hat, axis=1, type=1, norm='ortho'), axis=0, type=1, norm='ortho')\n        \n        return u_num\n\n    def compute_spectral_discrepancy(nx, ny, k_mode, l_mode):\n        \"\"\"\n        Calculates the relative discrepancy in the solution amplitude for a single Fourier mode.\n        \"\"\"\n        hx = 1 / (nx + 1)\n        hy = 1 / (ny + 1)\n\n        # Correct eigenvalues for the specific mode (k_mode, l_mode)\n        lambda_x_corr = (4 / hx**2) * np.sin(k_mode * np.pi / (2 * (nx + 1)))**2\n        lambda_y_corr = (4 / hy**2) * np.sin(l_mode * np.pi / (2 * (ny + 1)))**2\n        \n        # Buggy eigenvalue for the x-direction\n        lambda_x_buggy = (4 / hx**2) * np.sin(k_mode * np.pi / (2 * nx))**2\n\n        # The solution amplitude in Fourier space is 1/lambda_total\n        divisor_corr = lambda_x_corr + lambda_y_corr\n        divisor_buggy = lambda_x_buggy + lambda_y_corr\n\n        # Relative discrepancy formula from the problem statement\n        rel_discrepancy = np.abs(divisor_corr / divisor_buggy - 1.0)\n\n        return rel_discrepancy\n\n    # --- Test Suite ---\n    test_params = [(31, 31), (32, 32)]\n    results = {}\n\n    # Define the manufactured solution and its corresponding forcing term f = -delta(u)\n    u_exact_func = lambda x, y: np.sin(np.pi * x) * np.sin(2 * np.pi * y)\n    f_func = lambda x, y: (np.pi**2 + (2*np.pi)**2) * u_exact_func(x, y)\n\n    # --- Cases A  B: Manufactured Solution Test ---\n    for nx, ny in test_params:\n        # Create grid coordinates\n        hx = 1 / (nx + 1)\n        hy = 1 / (ny + 1)\n        x_pts = np.arange(1, nx + 1) * hx\n        y_pts = np.arange(1, ny + 1) * hy\n        # `indexing='xy'` (default) is crucial for matching array axes to x/y directions\n        X, Y = np.meshgrid(x_pts, y_pts)\n\n        # Evaluate exact solution and forcing term on the grid\n        u_exact_grid = u_exact_func(X, Y)\n        f_grid = f_func(X, Y)\n        \n        # Solve with correct and buggy solvers\n        u_corr = fast_poisson_solver(nx, ny, f_grid, is_buggy=False)\n        u_buggy = fast_poisson_solver(nx, ny, f_grid, is_buggy=True)\n        \n        # Calculate maximum-norm error\n        e_corr = np.max(np.abs(u_corr - u_exact_grid))\n        e_buggy = np.max(np.abs(u_buggy - u_exact_grid))\n        \n        results[f\"e_corr_{nx}\"] = e_corr\n        results[f\"e_buggy_{nx}\"] = e_buggy\n\n    # --- Case C: Targeted Spectral Regression Probe ---\n    # For even n_x=32, probe mode k=n_x/2=16\n    eps_rel_even = compute_spectral_discrepancy(32, 32, k_mode=16, l_mode=1)\n    \n    # For odd n_x=31, probe mode k=(n_x-1)/2=15\n    eps_rel_odd = compute_spectral_discrepancy(31, 31, k_mode=15, l_mode=1)\n\n    # --- Final calculations for output ---\n    # Ratio of errors for the buggy solver\n    error_ratio = results[\"e_buggy_32\"] / results[\"e_buggy_31\"]\n\n    # Boolean flag for regression test\n    regression_flag = eps_rel_even >= 5 * eps_rel_odd\n\n    # Assemble final results in the specified order\n    final_results = [\n        results[\"e_corr_31\"],\n        results[\"e_corr_32\"],\n        results[\"e_buggy_31\"],\n        results[\"e_buggy_32\"],\n        error_ratio,\n        eps_rel_even,\n        eps_rel_odd,\n        regression_flag,\n    ]\n\n    # Print the final result in the exact specified format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了狄利克雷边界条件后，下一个自然的步骤是处理不同的物理场景，例如诺伊曼（Neumann）或零通量边界条件。本练习将你的技能扩展到这类问题，并引入离散余弦变换（DCT）作为在单元中心网格上对角化拉普拉斯算子的恰当工具 ()。通过实现一个完整的求解器和验证程序，你将巩固对边界条件类型与谱变换选择之间深刻联系的理解。",
            "id": "3391525",
            "problem": "考虑矩形域上的二维泊松方程及其齐次诺伊曼边界条件：\n$$\n-\\Delta u(x,y) = f(x,y), \\quad (x,y) \\in (0,L_x) \\times (0,L_y),\n$$\n以及\n$$\n\\frac{\\partial u}{\\partial n} = 0 \\quad \\text{在} \\quad \\partial\\big((0,L_x)\\times(0,L_y)\\big) \\text{上},\n$$\n其中 $\\Delta$ 是拉普拉斯算子，$\\frac{\\partial u}{\\partial n}$ 表示法向导数。在一个均匀的单元中心网格上，x方向有 $N_x$ 个单元，y方向有 $N_y$ 个单元，定义网格间距 $h_x = L_x/N_x$ 和 $h_y = L_y/N_y$，单元中心位于 $x_i = (i+0.5)h_x$（对于 $i = 0,1,\\dots,N_x-1$）和 $y_j = (j+0.5)h_y$（对于 $j = 0,1,\\dots,N_y-1$）。使用标准的拉普拉斯算子五点有限差分格式，并通过在边界处进行偶延拓来施加诺伊曼边界条件。离散泊松算子是奇异的；因此，离散右端项 $f_{i,j}$ 必须具有零离散平均值：\n$$\n\\frac{1}{N_x N_y}\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} f_{i,j} = 0,\n$$\n这是方程在相差一个加性常数下可解的必要相容性条件。\n\n从以下基本事实出发：(i) 均匀网格上的五点拉普拉斯算子是连续拉普拉斯算子的二阶一致近似，(ii) 齐次诺伊曼边界条件在有限差分框架中对应于边界处的偶延拓，以及 (iii) 笛卡尔网格上的可分离线性算子可以通过适当的正交变换进行对角化，推导出一个用于离散泊松问题的快速谱对角化求解器，该求解器使用二维II型离散余弦变换（DCT-II）进行正变换，III型离散余弦变换（DCT-III）进行逆变换，并采用正交归一化。使用与单元中心网格和齐次诺伊曼边界条件相对应的变换对。在变换域中，通过固定规范以产生零均值解的方式，对与算子零空间一致的零频模式进行处理。\n\n您必须实现一个完整的程序，该程序：\n- 为给定的测试套件构建离散右端项 $f_{i,j}$。\n- 应用一个快速泊松求解器，该求解器基于DCT-II正变换、通过单元中心网格上诺伊曼拉普拉斯算子的离散特征值进行对角缩放，以及DCT-III逆变换。\n- 通过计算方程 $-\\Delta_h u = f$ 的离散残差来验证计算出的解 $u_{i,j}$，其中 $\\Delta_h$ 是通过偶延拓施加齐次诺伊曼边界条件的五点有限差分拉普拉斯算子。每个测试用例的验证指标是最大绝对残差：\n$$\n\\max_{i,j} \\left| \\left(-\\Delta_h u\\right)_{i,j} - f_{i,j} \\right|.\n$$\n- 输出一行，其中包含这些残差的列表（每个测试用例一个浮点数），格式为方括号内的逗号分隔列表。\n\n测试套件：\n- 测试用例1（单位正方形上的单余弦模式）：\n  - $L_x = 1.0$, $L_y = 1.0$, $N_x = 64$, $N_y = 64$。\n  - 已知解：$u_{i,j} = \\cos\\!\\left(\\pi k_x \\frac{i+0.5}{N_x}\\right)\\cos\\!\\left(\\pi k_y \\frac{j+0.5}{N_y}\\right)$，其中 $k_x = 3$ 且 $k_y = 5$。\n  - 通过其谱特征值将离散算子 $-\\Delta_h$ 应用于 $u_{i,j}$ 来定义 $f_{i,j}$，从而使精确离散解就是 $u_{i,j}$。\n- 测试用例2（非正方形矩形上的双余弦模式之和）：\n  - $L_x = 2.0$, $L_y = 1.0$, $N_x = 32$, $N_y = 40$。\n  - 已知解：$u_{i,j} = 0.7\\,\\cos\\!\\left(\\pi \\cdot 1 \\cdot \\frac{i+0.5}{N_x}\\right) + (-1.2)\\,\\cos\\!\\left(\\pi \\cdot 2 \\cdot \\frac{i+0.5}{N_x}\\right)\\cos\\!\\left(\\pi \\cdot 3 \\cdot \\frac{j+0.5}{N_y}\\right)$。\n  - 通过将离散算子 $-\\Delta_h$ 谱方法应用于每个模式并求和来定义 $f_{i,j}$，从而使精确离散解就是 $u_{i,j}$。\n- 测试用例3（各向异性矩形上的随机零均值强迫项）：\n  - $L_x = 0.7$, $L_y = 0.9$, $N_x = 50$, $N_y = 45$。\n  - $f_{i,j}$ 是一个固定的伪随机数组，其离散均值为零（减去均值），以确定性方式生成。\n- 测试用例4（用于强调边界处理的小网格）：\n  - $L_x = 3.0$, $L_y = 0.5$, $N_x = 8$, $N_y = 8$。\n  - $f_{i,j}$ 是一个固定的伪随机数组，其离散均值为零（减去均值），以确定性方式生成。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与上述测试用例一致，例如：\n$$\n[\\text{residual\\_case1},\\text{residual\\_case2},\\text{residual\\_case3},\\text{residual\\_case4}],\n$$\n其中每个条目是代表该案例最大绝对残差的浮点数。",
            "solution": "用户要求推导并实现一个用于求解矩形域上带齐次诺伊曼边界条件的二维泊松方程的快速求解器。该解法必须基于使用离散余弦变换（DCT）的谱对角化方法。\n\n### 1. 问题描述与离散化\n\n问题是求解泊松方程：\n$$\n-\\Delta u(x,y) = f(x,y), \\quad \\text{for } (x,y) \\in \\Omega = (0,L_x) \\times (0,L_y)\n$$\n并满足齐次诺伊曼边界条件：\n$$\n\\frac{\\partial u}{\\partial n} = \\vec{n} \\cdot \\nabla u = 0 \\quad \\text{on } \\partial\\Omega\n$$\n其中 $\\vec{n}$ 是指向边界 $\\partial\\Omega$ 外侧的法向量。解存在的必要条件是强迫项 $f$ 必须与边界条件相容。对该方程在整个域上积分并应用散度定理可得：\n$$\n-\\iint_{\\Omega} \\Delta u \\,dA = -\\oint_{\\partial\\Omega} \\nabla u \\cdot \\vec{n} \\,ds = -\\oint_{\\partial\\Omega} \\frac{\\partial u}{\\partial n} \\,ds = 0\n$$\n这意味着 $f$ 上的一个可解性条件：\n$$\n\\iint_{\\Omega} f(x,y) \\,dx\\,dy = 0\n$$\n解 $u$ 仅在相差一个加性常数的情况下是唯一的。可以通过施加一个额外的约束来获得唯一解，例如要求解具有零均值，即 $\\iint_{\\Omega} u(x,y) \\,dx\\,dy = 0$。\n\n我们使用一个包含 $N_x \\times N_y$ 个单元的均匀单元中心网格对域 $\\Omega$ 进行离散化。网格间距为 $h_x = L_x/N_x$ 和 $h_y = L_y/N_y$。单元中心位于 $(x_i, y_j)$，其中 $x_i = (i+0.5)h_x$（对于 $i=0,\\dots,N_x-1$），$y_j = (j+0.5)h_y$（对于 $j=0,\\dots,N_y-1$）。离散解和强迫项分别表示为 $u_{i,j} \\approx u(x_i, y_j)$ 和 $f_{i,j} = f(x_i, y_j)$。\n\n负拉普拉斯算子 $-\\Delta = -\\frac{\\partial^2}{\\partial x^2} - \\frac{\\partial^2}{\\partial y^2}$ 使用二阶精度的有限差分格式进行近似。对于带有齐次诺伊曼边界条件的单元中心网格，离散负拉普拉斯算子 $(-\\Delta_h u)_{i,j}$ 由下式给出：\n$$\n(-\\Delta_h u)_{i,j} = \\left(-\\frac{d^2}{dx^2}\\right)_h u_{i,j} + \\left(-\\frac{d^2}{dy^2}\\right)_h u_{i,j}\n$$\n一维算子定义为：\n$$\n\\left(-\\frac{d^2}{dx^2}\\right)_h u_{i,j} =\n\\begin{cases}\n\\frac{1}{h_x^2}(-u_{i+1,j} + 2u_{i,j} - u_{i-1,j})  \\text{对于 } 0  i  N_x-1 \\\\\n\\frac{1}{h_x^2}(u_{i,j} - u_{i+1,j})  \\text{对于 } i=0 \\\\\n\\frac{1}{h_x^2}(u_{i,j} - u_{i-1,j})  \\text{对于 } i=N_x-1\n\\end{cases}\n$$\n$y$方向的算子也类似。这种特定形式源于有限体积离散化，并正确地模拟了边界上的零通量条件。离散问题即求解以下线性方程组：\n$$\n(-\\Delta_h u)_{i,j} = f_{i,j}, \\quad \\text{对于 } i=0,\\dots,N_x-1, j=0,\\dots,N_y-1\n$$\n与连续情况对应的离散可解性条件是强迫项的离散平均值必须为零：$\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} f_{i,j} = 0$。\n\n### 2. 通过离散余弦变换进行谱对角化\n\n离散拉普拉斯算子 $-\\Delta_h$ 是笛卡尔网格上的一个线性可分离算子。其矩阵表示是对称的。这类算子可以通过基于其特征向量的变换被高效地对角化。对于带齐次诺伊曼边界条件的单元中心网格这一特定情况，其特征向量是II型离散余弦变换（DCT-II）的基向量。\n\n非归一化的二维基函数（特征向量）由一维基函数的张量积给出：\n$$\n\\Phi_{k,l}(i,j) = \\cos\\left(\\frac{\\pi k (i+0.5)}{N_x}\\right) \\cos\\left(\\frac{\\pi l (j+0.5)}{N_y}\\right)\n$$\n对于模式索引 $k=0,\\dots,N_x-1$ 和 $l=0,\\dots,N_y-1$。这些函数构成了 $N_x \\times N_y$ 网格上离散函数的一个正交基。\n\n将离散算子 $-\\Delta_h$ 应用于一个特征函数 $\\Phi_{k,l}$，会得到同一个特征函数，但它被其对应的特征值 $\\lambda_{k,l}$ 缩放了：\n$$\n-\\Delta_h \\Phi_{k,l} = \\lambda_{k,l} \\Phi_{k,l}\n$$\n特征值 $\\lambda_{k,l}$ 是一维特征值的和，$\\lambda_{k,l} = \\lambda_k^{(x)} + \\lambda_l^{(y)}$，其中\n$$\n\\lambda_k^{(x)} = \\frac{4}{h_x^2} \\sin^2\\left(\\frac{\\pi k}{2N_x}\\right), \\quad k=0,\\dots,N_x-1\n$$\n$$\n\\lambda_l^{(y)} = \\frac{4}{h_y^2} \\sin^2\\left(\\frac{\\pi l}{2N_y}\\right), \\quad l=0,\\dots,N_y-1\n$$\n因此，二维特征值为：\n$$\n\\lambda_{k,l} = \\frac{4}{h_x^2} \\sin^2\\left(\\frac{\\pi k}{2N_x}\\right) + \\frac{4}{h_y^2} \\sin^2\\left(\\frac{\\pi l}{2N_y}\\right)\n$$\n该算子有一个对应于常数模式 $(k,l)=(0,0)$ 的零空间，此时 $\\lambda_{0,0}=0$。这种奇异性对应于解只能在相差一个加性常数下被确定。\n\n### 3. 快速泊松求解器算法\n\n上述谱特性引出了一个快速求解器算法：\n1.  **分析（正变换）：** 网格上的任何离散函数，如 $f_{i,j}$ 和 $u_{i,j}$，都可以表示为基函数 $\\Phi_{k,l}$ 的线性组合。这种展开的系数通过执行二维DCT-II来找到。设 $\\hat{f}$ 和 $\\hat{u}$ 为变换后的数组：\n    $$\n    \\hat{f} = \\text{DCT-II}(f), \\quad \\hat{u} = \\text{DCT-II}(u)\n    $$\n    问题要求使用正交归一化变换，像 `scipy.fft` 这样的科学计算库能够正确处理。\n\n2.  **在谱域中求解：** 将离散方程 $(-\\Delta_h u)_{i,j} = f_{i,j}$ 转换到谱域，可以使算子对角化，从而将耦合的线性方程组转化为一组简单的标量方程：\n    $$\n    \\lambda_{k,l} \\hat{u}_{k,l} = \\hat{f}_{k,l}\n    $$\n    因此，谱系数 $\\hat{u}_{k,l}$ 的解为：\n    $$\n    \\hat{u}_{k,l} = \\frac{\\hat{f}_{k,l}}{\\lambda_{k,l}}\n    $$\n\n3.  **处理奇异性：** 对于模式 $(k,l)=(0,0)$，我们有 $\\lambda_{0,0}=0$。可解性条件确保了 $\\hat{f}_{0,0} = 0$，从而导致不定形式 $0/0$。为了获得唯一解，我们对解 $u$ 强制施加零均值条件。$u$ 的均值与其常数模式系数 $\\hat{u}_{0,0}$ 成正比。设置 $\\hat{u}_{0,0}=0$ 会产生唯一的零均值解。\n    谱解的最终规则是：\n    $$\n    \\hat{u}_{k,l} = \\begin{cases}\n    \\frac{\\hat{f}_{k,l}}{\\lambda_{k,l}}  \\text{对于 } (k,l) \\neq (0,0) \\\\\n    0  \\text{对于 } (k,l) = (0,0)\n    \\end{cases}\n    $$\n\n4.  **综合（逆变换）：** 通过对谱系数 $\\hat{u}_{k,l}$ 应用逆变换，可以恢复物理空间中的解 $u_{i,j}$。一个正交归一化II型DCT的逆变换是一个正交归一化III型离散余弦变换（DCT-III）。\n    $$\n    u = \\text{DCT-III}(\\hat{u})\n    $$\n\n这个过程利用基于快速傅里叶变换 (FFT) 的算法来实现DCT，构成了一个“快速泊松求解器”，其计算复杂度为 $O(N_x N_y \\log(N_x N_y))$。\n\n### 4. 残差验证\n\n为了验证计算出的解 $u_{sol}$，我们必须将离散负拉普拉斯算子 $-\\Delta_h$ 应用于它，并将结果与原始右端项 $f$ 进行比较。残差定义为 $r = (-\\Delta_h u_{sol}) - f$。残差的最大绝对值 $\\max_{i,j} |r_{i,j}|$ 用作解精度的度量。一个小的残差表明计算出的解精确地满足了离散方程。用于验证的算子 $-\\Delta_h$ 的实现必须与第1节中指定的有限差分公式精确匹配。",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import dctn, idctn\n\ndef apply_poisson_operator(u, hx, hy):\n    \"\"\"\n    Applies the discrete negative Laplacian operator (-Delta_h) with homogeneous\n    Neumann boundary conditions on a cell-centered grid.\n    \n    Args:\n        u (np.ndarray): The 2D array representing the function on the grid.\n        hx (float): Grid spacing in the x-direction.\n        hy (float): Grid spacing in the y-direction.\n\n    Returns:\n        np.ndarray: The result of applying the operator, (-Delta_h u).\n    \"\"\"\n    Lu = np.zeros_like(u)\n    Nx, Ny = u.shape\n    \n    # x-component of the operator\n    if Nx  1:\n        # Interior points\n        if Nx  2:\n            Lu[1:-1, :] += (-u[2:, :] + 2*u[1:-1, :] - u[:-2, :]) / hx**2\n        # Boundary points (i=0 and i=Nx-1)\n        Lu[0, :] += (u[0, :] - u[1, :]) / hx**2\n        Lu[-1, :] += (u[-1, :] - u[-2, :]) / hx**2\n\n    # y-component of the operator\n    if Ny  1:\n        # Interior points\n        if Ny  2:\n            Lu[:, 1:-1] += (-u[:, 2:] + 2*u[:, 1:-1] - u[:, :-2]) / hy**2\n        # Boundary points (j=0 and j=Ny-1)\n        Lu[:, 0] += (u[:, 0] - u[:, 1]) / hy**2\n        Lu[:, -1] += (u[:, -1] - u[:, -2]) / hy**2\n        \n    return Lu\n\ndef solve_poisson_dct(f, hx, hy):\n    \"\"\"\n    Solves the Poisson equation -Delta u = f using a fast DCT-based solver.\n\n    Args:\n        f (np.ndarray): The right-hand side function array.\n        hx (float): Grid spacing in the x-direction.\n        hy (float): Grid spacing in the y-direction.\n\n    Returns:\n        np.ndarray: The solution array u.\n    \"\"\"\n    Nx, Ny = f.shape\n    \n    # 1. Forward Transform (DCT-II)\n    f_hat = dctn(f, type=2, norm='ortho')\n    \n    # 2. Construct eigenvalues\n    kx = np.arange(Nx)\n    ky = np.arange(Ny)\n    \n    lambda_kx = (4 / hx**2) * np.sin(np.pi * kx / (2 * Nx))**2\n    lambda_ky = (4 / hy**2) * np.sin(np.pi * ky / (2 * Ny))**2\n    \n    # `lambda_kl` are eigenvalues of -Delta_h\n    lambda_kl = lambda_kx[:, np.newaxis] + lambda_ky[np.newaxis, :]\n    \n    # 3. Solve in spectral domain\n    # Avoid division by zero for the (0,0) mode\n    # The solver will set u_hat[0,0] = 0 later, so the value here doesn't matter\n    lambda_kl[0, 0] = 1.0 \n    \n    u_hat = f_hat / lambda_kl\n    \n    # Enforce zero-mean solution by setting the constant mode coefficient to zero\n    u_hat[0, 0] = 0.0\n    \n    # 4. Inverse Transform (DCT-III)\n    # scipy.fft.idctn with type=2 is the inverse of dctn with type=2\n    u_sol = idctn(u_hat, type=2, norm='ortho')\n    \n    return u_sol\n    \ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 64, 'Ny': 64, 'type': 'manufactured', 'params': {'kx': 3, 'ky': 5}},\n        {'Lx': 2.0, 'Ly': 1.0, 'Nx': 32, 'Ny': 40, 'type': 'manufactured', 'params': {}},\n        {'Lx': 0.7, 'Ly': 0.9, 'Nx': 50, 'Ny': 45, 'type': 'random', 'seed': 0},\n        {'Lx': 3.0, 'Ly': 0.5, 'Nx': 8, 'Ny': 8, 'type': 'random', 'seed': 1}\n    ]\n    \n    results = []\n    \n    for i, case in enumerate(test_cases):\n        Lx, Ly = case['Lx'], case['Ly']\n        Nx, Ny = case['Nx'], case['Ny']\n        hx, hy = Lx / Nx, Ly / Ny\n        \n        i_coords, j_coords = np.indices((Nx, Ny))\n        \n        # --- Construct the right-hand side f_ij ---\n        if case['type'] == 'manufactured':\n            # Eigenvalues for construction of f\n            kx_modes = np.arange(Nx)\n            ky_modes = np.arange(Ny)\n            lambda_kx = (4 / hx**2) * np.sin(np.pi * kx_modes / (2 * Nx))**2\n            lambda_ky = (4 / hy**2) * np.sin(np.pi * ky_modes / (2 * Ny))**2\n\n            if i == 0: # Case 1\n                kx, ky = case['params']['kx'], case['params']['ky']\n                u_exact = np.cos(np.pi * kx * (i_coords + 0.5) / Nx) * \\\n                          np.cos(np.pi * ky * (j_coords + 0.5) / Ny)\n                lambda_val = lambda_kx[kx] + lambda_ky[ky]\n                f = lambda_val * u_exact\n            \n            elif i == 1: # Case 2\n                u_mode1 = np.cos(np.pi * 1 * (i_coords + 0.5) / Nx)\n                u_mode2 = np.cos(np.pi * 2 * (i_coords + 0.5) / Nx) * \\\n                          np.cos(np.pi * 3 * (j_coords + 0.5) / Ny)\n                \n                lambda_val1 = lambda_kx[1] + lambda_ky[0]\n                lambda_val2 = lambda_kx[2] + lambda_ky[3]\n\n                f = 0.7 * lambda_val1 * u_mode1 - 1.2 * lambda_val2 * u_mode2\n        \n        elif case['type'] == 'random':\n            rng = np.random.default_rng(case['seed'])\n            f = rng.random((Nx, Ny))\n            f -= np.mean(f) # Enforce compatibility condition\n\n        # --- Solve the problem and validate ---\n        u_solution = solve_poisson_dct(f, hx, hy)\n        \n        # Calculate residual: R = (-Delta_h * u_solution) - f\n        neg_lap_u = apply_poisson_operator(u_solution, hx, hy)\n        residual = neg_lap_u - f\n        \n        max_abs_residual = np.max(np.abs(residual))\n        results.append(max_abs_residual)\n        \n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的问题往往涉及非零的边界值，这无法直接用基本的DST或DCT方法求解。本练习介绍了一种强大的“提升”技术，它能将一个非齐次边界问题转化为我们已有的快速求解器可以处理的齐次问题 ()。通过比较一个基于物理的调和提升和一个更简单的朴素提升，你将分析这一选择如何关键性地影响解的精度，特别是当边界数据包含高频分量时。",
            "id": "3391522",
            "problem": "考虑矩形域 $\\Omega=(0,1)\\times(0,1)$ 上的二维泊松方程，其具有非齐次狄利克雷边界数据，由下式给出：\n$$\n-\\Delta u(x,y) = f(x,y), \\quad (x,y)\\in \\Omega, \\quad u|_{\\partial\\Omega} = g(x,y).\n$$\n使用提升分解 $u=v+w$，其中 $v$ 满足 $v|_{\\partial\\Omega}=g$，使得 $w$ 满足齐次狄利克雷边界条件，因此有：\n$$\n-\\Delta w = f + \\Delta v \\quad \\text{in } \\Omega, \\quad w|_{\\partial\\Omega}=0.\n$$\n你需要设计并实现一个基于离散正弦变换 (DST) 的快速泊松求解器，以在尺寸为 $N_x\\times N_y$ 的均匀内部网格上求解 $w$，步长分别为 $h_x=1/(N_x+1)$ 和 $h_y=1/(N_y+1)$。该求解器必须使用拉普拉斯算子的标准二阶五点有限差分离散格式：\n$$\n\\Delta_h \\phi_{i,j} = \\frac{\\phi_{i-1,j}-2\\phi_{i,j}+\\phi_{i+1,j}}{h_x^2} + \\frac{\\phi_{i,j-1}-2\\phi_{i,j}+\\phi_{i,j+1}}{h_y^2},\n$$\n此格式应用于所有内部索引 $i=1,\\dots,N_x$ 和 $j=1,\\dots,N_y$，边界上的邻近点使用给定的狄利克雷边界值。\n\n为了科学真实性和绝对误差的量化，我们定义一个具有已知 $f$ 和 $g$ 的构造解，如下所示。选择齐次分量：\n$$\nw_{\\text{exact}}(x,y) = \\sin(p\\pi x)\\sin(q\\pi y),\n$$\n于是\n$$\n-\\Delta w_{\\text{exact}}(x,y) = \\pi^2(p^2+q^2)\\sin(p\\pi x)\\sin(q\\pi y),\n$$\n并定义边界数据 $g$ 仅在顶边 $y=1$ 上非零，由下式给出：\n$$\ng(x,1) = \\sin(m\\pi x), \\quad g(x,0)=g(0,y)=g(1,y)=0.\n$$\n令典范连续调和提升为：\n$$\nv_{\\text{harm}}(x,y) = \\sin(m\\pi x)\\frac{\\sinh(m\\pi y)}{\\sinh(m\\pi)},\n$$\n它满足 $\\Delta v_{\\text{harm}}=0$ 在 $\\Omega$ 中以及 $v_{\\text{harm}}|_{\\partial\\Omega}=g$。那么构造解为：\n$$\nu_{\\text{exact}}(x,y) = v_{\\text{harm}}(x,y) + w_{\\text{exact}}(x,y),\n$$\n其中\n$$\nf(x,y) = -\\Delta u_{\\text{exact}}(x,y) = -\\Delta v_{\\text{harm}}(x,y) - \\Delta w_{\\text{exact}}(x,y) = \\pi^2(p^2+q^2)\\sin(p\\pi x)\\sin(q\\pi y).\n$$\n\n用 $v$ 的两种不同离散实现来实施提升方法：\n- 在内部网格上采样的调和提升：对于内部节点为 $v_{\\text{harm}}(x_i,y_j)$，在边界线上使用相同的连续公式得到边界值。使用与边界相邻的有限差分来构建 $\\Delta_h v_{\\text{harm}}$。\n- 在内部网格上采样的朴素y方向线性提升：\n$$\nv_{\\text{naive}}(x,y) = y\\sin(m\\pi x),\n$$\n它满足 $v_{\\text{naive}}|_{\\partial\\Omega}=g$ 但不满足 $\\Delta v_{\\text{naive}}\\neq 0$。\n\n对于每种提升，将 $w$ 的离散右端项组装为：\n$$\n\\text{rhs}_{i,j} = f(x_i,y_j) + \\Delta_h v_{i,j},\n$$\n然后使用基于 I 型离散正弦变换 (DST-I) 和标准正交归一化的快速对角化方法求解 $-\\Delta_h w = \\text{rhs}$。$-\\Delta_h$ 在 DST-I 基下的特征值为：\n$$\n\\lambda_{k,\\ell} = \\frac{4}{h_x^2}\\sin^2\\left(\\frac{\\pi k}{2(N_x+1)}\\right) + \\frac{4}{h_y^2}\\sin^2\\left(\\frac{\\pi \\ell}{2(N_y+1)}\\right), \\quad k=1,\\dots,N_x, \\ \\ell=1,\\dots,N_y.\n$$\n\n你的任务是量化 $v$ 的离散化和边界频率 $m$ 如何影响混叠以及 $w$（并因此影响 $u$）的总体误差。具体来说，计算内部网格上的相对离散 $\\ell^2$ 误差：\n$$\nE = \\frac{\\left\\|u_{\\text{num}} - u_{\\text{exact}}\\right\\|_2}{\\left\\|u_{\\text{exact}}\\right\\|_2},\n$$\n分别针对 $u_{\\text{num}}=v_{\\text{harm}}+w_{\\text{harm}}$ 和 $u_{\\text{num}}=v_{\\text{naive}}+w_{\\text{naive}}$ 进行计算，其中 $w_{\\text{harm}}$ 和 $w_{\\text{naive}}$ 是通过 DST-I 分别求解离散系统 $-\\Delta_h w = f + \\Delta_h v$ 得到的。\n\n为以下参数集测试套件提供结果，这些参数集旨在探测良好解析的频率、接近奈奎斯特频率的内容以及清晰的混叠场景：\n- 测试1（理想情况）：$N_x=64$，$N_y=64$，$m=4$，$p=3$，$q=2$。\n- 测试2（接近奈奎斯特）：$N_x=64$，$N_y=64$，$m=30$，$p=3$，$q=2$。\n- 测试3（超奈奎斯特混叠）：$N_x=32$，$N_y=32$，$m=70$，$p=3$，$q=2$。\n- 测试4（粗网格混叠边缘情况）：$N_x=8$，$N_y=8$，$m=16$，$p=3$，$q=2$。\n\n你的程序必须输出单行，其中包含一个由逗号分隔的八个浮点误差值列表\n$$\n[E_{\\text{harm}}^{(1)}, E_{\\text{naive}}^{(1)}, E_{\\text{harm}}^{(2)}, E_{\\text{naive}}^{(2)}, E_{\\text{harm}}^{(3)}, E_{\\text{naive}}^{(3)}, E_{\\text{harm}}^{(4)}, E_{\\text{naive}}^{(4)}]\n$$\n并用方括号括起来。不得打印任何额外文本。此问题中没有物理单位；所有量均为无量纲。角度以弧度为单位。所有输出均需以指定的单行格式表示为浮点数。",
            "solution": "该问题被验证为具有科学依据、适定且客观。它为快速泊松求解器提供了一个标准的数值验证任务，旨在探究不同提升策略对非齐次狄利克雷边界条件的影响。所有给定的公式和参数都是正确且一致的。该问题是一个精心设计的数值分析练习，特别关注离散误差、混叠及其与求解方法的相互作用。\n\n问题的核心是在单位正方形 $\\Omega=(0,1)\\times(0,1)$ 上求解二维泊松方程\n$$-\\Delta u(x,y) = f(x,y),$$\n其非齐次狄利克雷边界条件为 $u|_{\\partial\\Omega} = g(x,y)$。所选方法是提升分解，即将解 $u$ 分成两个分量 $u = v+w$。“提升”函数 $v$ 的构造旨在满足非齐次边界条件，$v|_{\\partial\\Omega} = g$。这将关于 $u$ 的问题转化为关于新未知函数 $w = u-v$ 的问题，该函数满足齐次边界条件 $w|_{\\partial\\Omega} = 0$。将 $u=v+w$ 代入泊松方程得到：\n$$-\\Delta (v+w) = f \\implies -\\Delta w = f + \\Delta v.$$\n因此，问题被简化为求解一个具有修正右端项和齐次狄利克雷边界条件的关于 $w$ 的泊松方程。\n\n数值解在一个具有 $N_x \\times N_y$ 个内部点的均匀网格上寻求。网格间距为 $h_x=1/(N_x+1)$ 和 $h_y=1/(N_y+1)$，内部网格点为 $(x_i, y_j) = (ih_x, jh_y)$，其中 $i=1,\\dots,N_x$ 且 $j=1,\\dots,N_y$。拉普拉斯算子使用标准的五点有限差分格式进行离散化：\n$$\n\\Delta_h \\phi_{i,j} = \\frac{\\phi_{i-1,j}-2\\phi_{i,j}+\\phi_{i+1,j}}{h_x^2} + \\frac{\\phi_{i,j-1}-2\\phi_{i,j}+\\phi_{i,j+1}}{h_y^2}.\n$$\n关于 $w$ 的离散问题是找到网格函数 $w_{i,j}$，使其对所有内部点 $(i,j)$ 求解：\n$$-\\Delta_h w_{i,j} = f(x_i,y_j) + \\Delta_h v_{i,j},$$\n并在边界上 $w=0$。这个线性系统可以通过基于离散正弦变换 (DST) 的快速泊松求解器高效求解。在具有齐次狄利克雷条件的矩形网格上，代表负离散拉普拉斯算子 $-\\Delta_h$ 的矩阵可被二维 DST 对角化。其特征值 $\\lambda_{k,\\ell}$ 由下式给出：\n$$\n\\lambda_{k,\\ell} = \\frac{4}{h_x^2}\\sin^2\\left(\\frac{\\pi k}{2(N_x+1)}\\right) + \\frac{4}{h_y^2}\\sin^2\\left(\\frac{\\pi \\ell}{2(N_y+1)}\\right),\n$$\n其中 $k=1,\\dots,N_x$ 且 $\\ell=1,\\dots,N_y$。\n\n$w$ 的求解算法如下：\n1.  在内部网格上计算离散右端项，$\\text{RHS}_{i,j} = f(x_i,y_j) + (\\Delta_h v)_{i,j}$。\n2.  使用 I 型二维 DST (DST-I) 将 RHS 变换到频域：$\\widehat{\\text{RHS}} = \\text{DST}(\\text{RHS})$。\n3.  通过除法求解频域中 $w$ 的系数：$\\hat{w}_{k,\\ell} = \\widehat{\\text{RHS}}_{k,\\ell} / \\lambda_{k,\\ell}$。\n4.  变换回空间域以获得解：$w = \\text{IDST}(\\hat{w})$，其中 IDST 是逆 DST。对于采用标准正交归一化的 DST-I，IDST 与 DST 相同。\n\n该问题研究了提升函数 $v$ 的两种不同选择：\n1.  **调和提升**：$v_{\\text{harm}}(x,y) = \\sin(m\\pi x)\\frac{\\sinh(m\\pi y)}{\\sinh(m\\pi)}$。此函数是调和的，即 $\\Delta v_{\\text{harm}} = 0$。因此，离散右端项上的 $\\Delta_h v_{\\text{harm}}$ 项纯粹是由有限差分格式的截断误差造成的，其阶数为 $O(h_x^2, h_y^2)$。\n2.  **朴素提升**：$v_{\\text{naive}}(x,y) = y\\sin(m\\pi x)$。此函数不是调和的；$\\Delta v_{\\text{naive}} = -m^2\\pi^2 y \\sin(m\\pi x)$。因此，$\\Delta_h v_{\\text{naive}}$ 是这个非零函数的一个近似，它为 $w$ 的右端项引入了一个显著且物理上不同的项。\n\n一个构造解 $u_{\\text{exact}}(x,y) = v_{\\text{harm}}(x,y) + w_{\\text{exact}}(x,y)$ 用于验证，其中 $w_{\\text{exact}}(x,y) = \\sin(p\\pi x)\\sin(q\\pi y)$。这意味着源项为 $f(x,y) = -\\Delta u_{\\text{exact}} = -\\Delta w_{\\text{exact}} = \\pi^2(p^2+q^2)\\sin(p\\pi x)\\sin(q\\pi y)$。\n\n总数值解构造为 $u_{\\text{num}} = v + w_{\\text{num}}$，其中 $v$ 是在网格上采样的所选提升函数，$w_{\\text{num}}$ 是相应的数值解。精度通过误差的相对离散 $\\ell^2$-范数来量化，$E = \\|u_{\\text{num}} - u_{\\text{exact}}\\|_2 / \\|u_{\\text{exact}}\\|_2$，在内部网格上计算。测试用例旨在探测边界数据频率 $m$ 被良好解析、接近网格的奈奎斯特极限或超出该极限导致混叠的场景。当高频信号的采样率不足以捕捉它时，就会发生混叠，使其表现为较低频率的信号。这会影响采样后的提升函数 $v$ 及其离散拉普拉斯算子 $\\Delta_h v$，从而影响 $w_{\\text{num}}$ 和整体解 $u_{\\text{num}}$ 的准确性。对于高波数情况（m=70），$\\sinh(m\\pi y)/\\sinh(m\\pi)$ 项通过一个数值稳定的公式 $e^{m\\pi(y-1)} \\frac{1 - e^{-2m\\pi y}}{1-e^{-2m\\pi}}$ 来计算，以防止浮点溢出。\n\n该实现计算了四种指定测试用例下两种提升选择的误差 E。",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import dst\n\ndef solve():\n    \"\"\"\n    Solves the 2D Poisson equation using a fast sine transform-based solver\n    with two different lifting techniques for inhomogeneous boundary conditions,\n    and computes the relative l2-error for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, m, p, q)\n        (64, 64, 4, 3, 2),\n        (64, 64, 30, 3, 2),\n        (32, 32, 70, 3, 2),\n        (8, 8, 16, 3, 2),\n    ]\n\n    results = []\n    for params in test_cases:\n        error_harm = compute_error_for_lifting(*params, lifting_type='harm')\n        error_naive = compute_error_for_lifting(*params, lifting_type='naive')\n        results.extend([error_harm, error_naive])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_v_harm_on_grid(X, Y, m):\n    \"\"\"\n    Computes the harmonic lifting function v_harm on a grid,\n    using a numerically stable formula to avoid overflow for large m.\n    \"\"\"\n    if m == 0:\n        return np.zeros_like(X)\n    \n    m_pi = m * np.pi\n    \n    # sinh(m_pi) can overflow for large m (e.g., m=70).\n    # We use the identity:\n    # sinh(m*pi*y)/sinh(m*pi) = exp(m*pi*(y-1)) * (1-exp(-2*m*pi*y))/(1-exp(-2*m*pi))\n    # This is numerically stable for y in [0, 1].\n    if m_pi  30.0:  # Threshold for using stable formula\n        exp_term = np.exp(m_pi * (Y - 1.0))\n        num_corr = 1.0 - np.exp(-2.0 * m_pi * Y)\n        den_corr = 1.0 - np.exp(-2.0 * m_pi)\n        \n        # Handle den_corr being zero if m_pi is huge\n        if den_corr == 0.0:\n             val = exp_term\n        else:\n             val = exp_term * num_corr / den_corr\n    else:\n        val = np.sinh(m_pi * Y) / np.sinh(m_pi)\n        \n    return np.sin(m_pi * X) * val\n\ndef compute_error_for_lifting(Nx, Ny, m, p, q, lifting_type):\n    \"\"\"\n    Computes the relative l2-error for a single test case and lifting type.\n    \"\"\"\n    # Grid parameters\n    hx = 1.0 / (Nx + 1)\n    hy = 1.0 / (Ny + 1)\n\n    # Interior grid\n    xi = np.arange(1, Nx + 1) * hx\n    yi = np.arange(1, Ny + 1) * hy\n    X_int, Y_int = np.meshgrid(xi, yi, indexing='ij')\n\n    # Padded grid (includes boundaries)\n    x_pad = np.linspace(0, 1, Nx + 2)\n    y_pad = np.linspace(0, 1, Ny + 2)\n    X_pad, Y_pad = np.meshgrid(x_pad, y_pad, indexing='ij')\n\n    # Exact solution components on interior grid\n    w_exact_interior = np.sin(p * np.pi * X_int) * np.sin(q * np.pi * Y_int)\n    v_harm_interior = get_v_harm_on_grid(X_int, Y_int, m)\n    u_exact_interior = v_harm_interior + w_exact_interior\n\n    # Source term f on interior grid\n    f_interior = np.pi**2 * (p**2 + q**2) * np.sin(p * np.pi * X_int) * np.sin(q * np.pi * Y_int)\n\n    # Define and sample the lifting function v on the padded grid\n    if lifting_type == 'harm':\n        v_padded = get_v_harm_ongrid(X_pad, Y_pad, m)\n    elif lifting_type == 'naive':\n        v_padded = Y_pad * np.sin(m * np.pi * X_pad)\n    else:\n        raise ValueError(\"Invalid lifting type\")\n\n    v_interior = v_padded[1:-1, 1:-1]\n    \n    # Compute discrete Laplacian of v on the interior grid\n    term_x = (v_padded[0:-2, 1:-1] - 2 * v_padded[1:-1, 1:-1] + v_padded[2:, 1:-1]) / hx**2\n    term_y = (v_padded[1:-1, 0:-2] - 2 * v_padded[1:-1, 1:-1] + v_padded[1:-1, 2:]) / hy**2\n    delta_h_v = term_x + term_y\n\n    # Assemble the right-hand side for the w-problem\n    rhs_w = f_interior + delta_h_v\n\n    # Solve for w_num using DST-based fast Poisson solver\n    # 1. Transform RHS to frequency domain\n    rhs_w_hat = dst(dst(rhs_w, axis=1, type=1, norm='ortho'), axis=0, type=1, norm='ortho')\n\n    # 2. Define eigenvalues of the discrete negative Laplacian\n    k = np.arange(1, Nx + 1).reshape(-1, 1)\n    l = np.arange(1, Ny + 1).reshape(1, -1)\n    lambda_kl = (4/hx**2) * np.sin(np.pi * k / (2 * (Nx + 1)))**2 + \\\n                (4/hy**2) * np.sin(np.pi * l / (2 * (Ny + 1)))**2\n\n    # 3. Solve in frequency domain\n    w_hat_num = rhs_w_hat / lambda_kl\n\n    # 4. Transform back to spatial domain\n    w_num = dst(dst(w_hat_num, axis=1, type=1, norm='ortho'), axis=0, type=1, norm='ortho')\n\n    # Reconstruct the full numerical solution on the interior grid\n    u_num = v_interior + w_num\n\n    # Compute relative discrete l2 error\n    norm_error = np.linalg.norm(u_num - u_exact_interior)\n    norm_exact = np.linalg.norm(u_exact_interior)\n    \n    if norm_exact == 0:\n        return 0.0\n    \n    return norm_error / norm_exact\n\n# Alias to match local function name inside loop\nget_v_harm_ongrid = get_v_harm_on_grid\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}