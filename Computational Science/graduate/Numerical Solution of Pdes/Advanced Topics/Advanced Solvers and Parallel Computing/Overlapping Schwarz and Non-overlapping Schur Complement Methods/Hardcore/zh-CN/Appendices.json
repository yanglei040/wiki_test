{
    "hands_on_practices": [
        {
            "introduction": "高效的区域分解方法，其核心在于设计能够精确反映偏微分方程（PDE）内在物理特性的传输条件。本练习旨在引导您从基本物理原理出发，为对流扩散方程推导出最优的传输条件。通过将该方程改写为守恒形式并识别其物理通量，您将能确定一种Robin型传输条件，该条件在多维情况下能够自然地包含对流方向的上风偏置，为设计针对复杂流体问题的优化Schwarz方法奠定理论基石。",
            "id": "3428557",
            "problem": "考虑在区间 $[0,L]$ 上的常系数一维对流扩散偏微分方程 (PDE)，\n$$\n-\\epsilon\\,u''(x) + b\\,u'(x) = f(x),\n$$\n其中 $\\epsilon>0$ 且 $b\\in\\mathbb{R}$。该区域被分解为两个重叠的子区域 $\\Omega_1=[0,x_\\star+\\delta]$ 和 $\\Omega_2=[x_\\star-\\delta,L]$，其中 $x_\\star\\in(0,L)$ 且重叠半宽度 $\\delta\\in(0,\\min\\{x_\\star,L-x_\\star\\})$。在重叠 Schwarz 迭代法中，假设子区域解 $u_1$ 和 $u_2$ 在界面点 $x=x_\\star$ 处通过一个形式如下的线性 Robin 型传输算子进行交换\n$$\n-\\epsilon\\,u_1'(x_\\star) + \\alpha\\,u_1(x_\\star) = -\\epsilon\\,u_2'(x_\\star) + \\alpha\\,u_2(x_\\star),\n$$\n其中 $\\alpha\\in\\mathbb{R}$ 为待定参数。请从第一性原理出发，不假设任何已有的界面公式，推导出 $\\alpha$ 的选择，使得在齐次情况 $f\\equiv 0$ 下，能够跨重叠区域实现精确的通量传输，并且该选择与 $\\delta$ 无关。\n\n然后，将您的推导推广到 d 维的常系数对流扩散偏微分方程\n$$\n-\\epsilon\\,\\Delta u(\\boldsymbol{x}) + \\boldsymbol{b}\\cdot\\nabla u(\\boldsymbol{x}) = f(\\boldsymbol{x}),\n$$\n其中 $\\epsilon>0$ 且对流向量 $\\boldsymbol{b}\\in\\mathbb{R}^d$ 为常数。设 $\\Gamma$ 表示两个重叠子区域之间的光滑界面，并设 $\\boldsymbol{n}$ 为 $\\Gamma$ 上从其中一个子区域向外指出的单位法向量。提出一个形式如下的方向偏置 Robin 传输算子\n$$\n-\\epsilon\\,\\partial_{\\boldsymbol{n}}u + \\alpha(\\boldsymbol{n})\\,u,\n$$\n并使用一个植根于该偏微分方程的基本守恒律论证，确定 $\\alpha(\\boldsymbol{n})$ 的唯一闭式表达式，该表达式能退化为您的一维结果，并能捕捉相对于对流方向 $\\boldsymbol{b}$ 的迎风偏置。您的最终答案必须是这个关于 $\\alpha(\\boldsymbol{n})$ 的单一解析表达式。不需要进行数值近似或舍入，最终答案中也不应包含任何物理单位。",
            "solution": "该问题要求为应用于对流扩散方程的重叠 Schwarz 方法推导一个 Robin 型传输算子中的参数 $\\alpha$。推导首先在一维情况下进行，然后推广到 d 维。推导的核心原理是实现独立于重叠区域大小的“精确通量传输”。\n\n首先，我们来分析一维情况。其控制偏微分方程 (PDE) 为\n$$\n-\\epsilon\\,u''(x) + b\\,u'(x) = f(x)\n$$\n其中 $\\epsilon > 0$ 和 $b \\in \\mathbb{R}$ 是常数。问题要求基于齐次情况 $f(x) \\equiv 0$ 进行推导。齐次方程为\n$$\n-\\epsilon\\,u''(x) + b\\,u'(x) = 0.\n$$\n该方程可以写成守恒形式。由于 $b$ 是一个常数，有 $b\\,u'(x) = (b\\,u(x))'$。同时，$-\\epsilon\\,u''(x) = (-\\epsilon\\,u'(x))'$。因此，该偏微分方程可以表示为一个通量的散度（在一维情况下是导数）等于源项：\n$$\n\\frac{d}{dx} \\left( -\\epsilon\\,u'(x) + b\\,u(x) \\right) = f(x).\n$$\n这使我们能够确定与对流扩散过程相关的物理通量 $J(x)$：\n$$\nJ(x) = -\\epsilon\\,u'(x) + b\\,u(x).\n$$\n对于 $f(x) = 0$ 的齐次情况，方程变为 $\\frac{d}{dx}J(x) = 0$，这意味着对于齐次偏微分方程的任何解 $u(x)$，其通量 $J(x)$ 都是一个常数。\n\n问题指明，子区域解 $u_1$ 和 $u_2$ 在界面点 $x=x_\\star$ 处通过一个线性 Robin 型算子的连续性进行耦合：\n$$\n-\\epsilon\\,u_1'(x_\\star) + \\alpha\\,u_1(x_\\star) = -\\epsilon\\,u_2'(x_\\star) + \\alpha\\,u_2(x_\\star).\n$$\n问题指出，$\\alpha$ 的选择必须保证“精确通量传输”。对此要求最直接和最基本的解释是，由传输算子保持连续的量必须是物理通量本身。通过比较传输算子的形式 $\\mathcal{T}_\\alpha u(x) = -\\epsilon\\,u'(x) + \\alpha\\,u(x)$ 与物理通量的表达式 $J(x) = -\\epsilon\\,u'(x) + b\\,u(x)$，我们发现它们当且仅当在以下情况下是相同的：\n$$\n\\alpha = b.\n$$\n这一选择确保了传输条件恰好是物理通量的连续性：$J(u_1)(x_\\star) = J(u_2)(x_\\star)$。\n\n问题还指明，这一选择必须与重叠半宽度 $\\delta$ 无关。如果 $\\alpha=b$，条件就是通量的连续性。对于全域 $[0,L]$ 上齐次方程的任何解 $u(x)$，其通量 $J(u)$ 处处为常数。因此，对于其在子区域上的限制 $u_1$ 和 $u_2$，条件 $J(u_1)(x) = J(u_2)(x)$ 在重叠区域 $[x_\\star-\\delta, x_\\star+\\delta]$ 中的任何点 $x$ 都成立，而不仅仅是在 $x_\\star$ 处成立。因此，这个物理条件的有效性内在地与 $\\delta$ 无关。\n\n现在，我们将此发现推广到 d 维。偏微分方程为\n$$\n-\\epsilon\\,\\Delta u(\\boldsymbol{x}) + \\boldsymbol{b}\\cdot\\nabla u(\\boldsymbol{x}) = f(\\boldsymbol{x}),\n$$\n其中 $\\epsilon > 0$ 且 $\\boldsymbol{b} \\in \\mathbb{R}^d$ 是一个常向量。我们可以将此偏微分方程写成守恒形式，注意到 $\\Delta u = \\nabla \\cdot (\\nabla u)$，并且由于 $\\boldsymbol{b}$ 是一个常向量，$\\boldsymbol{b} \\cdot \\nabla u = \\nabla \\cdot (\\boldsymbol{b}u) - u(\\nabla \\cdot \\boldsymbol{b}) = \\nabla \\cdot (\\boldsymbol{b}u)$。因此，该偏微分方程等价于：\n$$\n\\nabla \\cdot (-\\epsilon\\,\\nabla u(\\boldsymbol{x}) + \\boldsymbol{b}u(\\boldsymbol{x})) = f(\\boldsymbol{x}).\n$$\n此方程的形式为 $\\nabla \\cdot \\boldsymbol{J}(\\boldsymbol{x}) = f(\\boldsymbol{x})$，其中 $\\boldsymbol{J}(\\boldsymbol{x})$ 是向量通量：\n$$\n\\boldsymbol{J}(\\boldsymbol{x}) = -\\epsilon\\,\\nabla u(\\boldsymbol{x}) + \\boldsymbol{b}u(\\boldsymbol{x}).\n$$\n一个基本的守恒律论证是基于此通量的。物理量 $u$ 穿过具有单位法向量 $\\boldsymbol{n}$ 的光滑界面 $\\Gamma$ 的输运率由通量向量的法向分量 $J_{\\boldsymbol{n}} = \\boldsymbol{J} \\cdot \\boldsymbol{n}$ 给出。\n$$\nJ_{\\boldsymbol{n}}(\\boldsymbol{x}) = \\left( -\\epsilon\\,\\nabla u(\\boldsymbol{x}) + \\boldsymbol{b}u(\\boldsymbol{x}) \\right) \\cdot \\boldsymbol{n} = -\\epsilon\\,(\\nabla u \\cdot \\boldsymbol{n}) + (\\boldsymbol{b} \\cdot \\boldsymbol{n}) u(\\boldsymbol{x}).\n$$\n识别出方向导数 $\\partial_{\\boldsymbol{n}}u = \\nabla u \\cdot \\boldsymbol{n}$，法向通量为：\n$$\nJ_{\\boldsymbol{n}}(\\boldsymbol{x}) = -\\epsilon\\,\\partial_{\\boldsymbol{n}}u(\\boldsymbol{x}) + (\\boldsymbol{b} \\cdot \\boldsymbol{n}) u(\\boldsymbol{x}).\n$$\n问题提出了一个形式为 $-\\epsilon\\,\\partial_{\\boldsymbol{n}}u + \\alpha(\\boldsymbol{n})\\,u$ 的方向偏置 Robin 传输算子。为确保“精确通量传输”，与一维情况一样，我们将此算子与物理法向通量 $J_{\\boldsymbol{n}}$ 等同起来。\n$$\n-\\epsilon\\,\\partial_{\\boldsymbol{n}}u + \\alpha(\\boldsymbol{n})\\,u = -\\epsilon\\,\\partial_{\\boldsymbol{n}}u + (\\boldsymbol{b} \\cdot \\boldsymbol{n}) u.\n$$\n为使此等式对任何解 $u$ 都成立，$u$ 的系数必须相等。这就得出了 $\\alpha(\\boldsymbol{n})$ 的唯一闭式表达式：\n$$\n\\alpha(\\boldsymbol{n}) = \\boldsymbol{b} \\cdot \\boldsymbol{n}.\n$$\n这个结果满足所有陈述的要求。它是由一个基本的守恒律论证推导出来的。它能退化到一维结果，因为对于沿 x 轴的一维问题，当 $\\boldsymbol{b}=(b)$ 和 $\\boldsymbol{n}=(1)$ 时，我们有 $\\alpha(1) = b \\cdot 1 = b$。它也捕捉了迎风偏置，因为系数 $\\alpha(\\boldsymbol{n})$ 直接取决于对流向量 $\\boldsymbol{b}$ 与界面法线 $\\boldsymbol{n}$ 的方向关系。如果流动方向与法线方向一致（$\\boldsymbol{b} \\cdot \\boldsymbol{n} > 0$，出流边界），$\\alpha$ 为正。如果流动方向与法线方向相反（$\\boldsymbol{b} \\cdot \\boldsymbol{n}  0$，入流边界），$\\alpha$ 为负。如果流动方向与界面相切（$\\boldsymbol{b} \\cdot \\boldsymbol{n} = 0$），则 Robin 算子中的对流项消失。",
            "answer": "$$\\boxed{\\boldsymbol{b} \\cdot \\boldsymbol{n}}$$"
        },
        {
            "introduction": "理论的价值最终体现在实践中。对于如亥姆霍兹（Helmholtz）方程这类具有挑战性的波动问题，传统的区域分解方法可能会失效，而前述的优化传输条件则变得至关重要。在这个计算实践中，您将通过编程实现并对比两种方法：一种是使用经典狄利克雷（Dirichlet）传输条件的重叠Schwarz方法，另一种是采用复数Robin传输条件的非重叠方法。通过直接计算迭代算子的谱半径，您将亲眼见证并量化为何优化条件能够稳定一个在传统方法下发散的迭代过程。",
            "id": "3428516",
            "problem": "考虑闭区间上带有齐次狄利克雷数据的一维常系数亥姆霍兹边值问题，\n$$\n-\\,u''(x)\\;-\\;k^2\\,u(x)\\;=\\;0,\\quad x\\in(0,L),\\qquad u(0)=0,\\quad u(L)=0,\n$$\n其中给定了 $L0$ 和 $k0$。您将研究齐次误差方程的两种区域分解迭代法，并通过其迭代算子的谱半径来量化它们的收敛性。\n\n方法A（经典的带狄利克雷传输条件的重叠型Schwarz方法）：将全局网格划分为两个重叠的子区域 $\\Omega_1=[0,x_R]$ 和 $\\Omega_2=[x_L,L]$，重叠部分为 $x_R-x_L0$。在对齐次误差方程进行的并行（类雅可比）重叠型Schwarz迭代中，每个子区域问题求解时，其狄利克雷边界条件取自外部物理边界以及重叠区域内人工界面上相邻子区域的前一次迭代值。界面迭代定义在人工界面上的狄利克雷值对 $g=(g_L,g_R)$ 上，其中 $g_L$ 是为 $\\Omega_2$ 在 $x=x_L$ 处施加的值，$g_R$ 是为 $\\Omega_1$ 在 $x=x_R$ 处施加的值。子区域求解的线性性质意味着存在一个形为 $2\\times 2$ 的迭代算子\n$$\ng^{(n+1)} \\;=\\; M_D\\, g^{(n)},\\qquad M_D=\\begin{bmatrix} 0  \\alpha \\\\ \\beta  0 \\end{bmatrix},\n$$\n其中系数 $\\alpha$ 和 $\\beta$ 是由两个子区域的求解引起的狄利克雷-狄利克雷传递。当且仅当谱半径 $\\rho(M_D)1$ 时，迭代收敛。\n\n方法B（带复罗宾传输条件的非重叠优化Schwarz方法）：将区域划分为两个不重叠的子区域 $\\Omega_1=[0,x_\\Gamma]$ 和 $\\Omega_2=[x_\\Gamma,L]$。在公共界面 $x=x_\\Gamma$ 上，施加复罗宾（阻抗）传输算子\n$$\nT_1(u)\\;=\\;\\partial_x u\\;+\\;i\\,\\eta\\,u,\\qquad T_2(u)\\;=\\;-\\partial_x u\\;+\\;i\\,\\eta\\,u,\n$$\n其中 $\\eta0$ 是一个选定的阻抗参数。在对齐次误差方程进行的并行迭代中，每个子区域使用相邻子区域前一次的罗宾迹作为输入，并生成自己的罗宾迹作为输出返回。用 $s=(s_L,s_R)$ 表示在界面上为 $\\Omega_2$（左）和 $\\Omega_1$（右）注入的罗宾数据对，线性性质再次产生一个形为\n$$\ns^{(n+1)} \\;=\\; M_R\\, s^{(n)},\\qquad M_R=\\begin{bmatrix} 0  a \\\\ b  0 \\end{bmatrix},\n$$\n的迭代，其中 $a$ 和 $b$ 是罗宾-罗宾传递。收敛性由 $\\rho(M_R)1$ 来表征。\n\n迭代算子的离散化与构造：使用一个包含 $N+1$ 个节点 $x_j=jh$ 的均匀网格来离散化区间 $[0,L]$，其中 $h=L/N$ 且 $j\\in\\{0,1,\\dots,N\\}$。使用标准的二阶中心有限差分格式来离散化亥姆霍兹算子，\n$$\n\\left(\\frac{2}{h^2}-k^2\\right)u_j - \\frac{1}{h^2}u_{j-1} - \\frac{1}{h^2}u_{j+1} = 0,\n$$\n该式应用于内部节点，并强制执行 $u_0=0$ 和 $u_N=0$。对于方法A，选择界面索引 $i_L$ 和 $i_R$，满足 $1\\le i_L",
            "solution": "我们从有界区间上的线性常系数亥姆霍兹方程与齐次狄利克雷边界条件开始。所需的核心原理是边值问题的线性性、具有两个边界条件的二阶两点边值问题解的唯一性，以及线性定常迭代通过其迭代矩阵的谱表征。\n\n离散化原理：在间距为 $h=L/N$ 的均匀网格上，$-u''(x)$ 在网格点处的标准二阶中心有限差分产生离散算子\n$$\n\\mathcal{A}_h u_j \\;=\\; \\left(\\frac{2}{h^2}-k^2\\right)u_j \\;-\\; \\frac{1}{h^2}\\,u_{j-1} \\;-\\; \\frac{1}{h^2}\\,u_{j+1},\n$$\n对于 $j\\in\\{1,2,\\dots,N-1\\}$。我们强制执行 $u_0=0$ 和 $u_N=0$。\n\n方法A（经典的带狄利克雷传输条件的重叠型Schwarz方法）：重叠子区域由满足 $1\\le i_L",
            "answer": "```python\nimport numpy as np\n\ndef build_tridiag_helmholtz(m, h, k):\n    \"\"\"\n    Build the m x m tridiagonal matrix for the discrete Helmholtz operator\n    on interior nodes with stencil: (2/h^2 - k^2) on diagonal and -1/h^2 on off-diagonals.\n    \"\"\"\n    if m == 0:\n        return np.zeros((0, 0), dtype=float)\n    main = (2.0 / h**2 - k**2) * np.ones(m, dtype=float)\n    off = (-1.0 / h**2) * np.ones(m - 1, dtype=float)\n    A = np.diag(main)\n    if m > 1:\n        A += np.diag(off, k=1) + np.diag(off, k=-1)\n    return A\n\ndef spectral_radius_dirichlet(L, N, k, iL, iR):\n    \"\"\"\n    Compute spectral radius of the 2x2 iteration matrix for classical overlapping Schwarz\n    with Dirichlet transmission on a 1D Helmholtz problem.\n    \"\"\"\n    h = L / N\n    # Subdomain 1: indices 0..iR, unknowns j=1..iR-1\n    m1 = max(0, iR - 1)\n    A1 = build_tridiag_helmholtz(m1, h, k)\n    # RHS for unit g_R\n    if m1 > 0:\n        b1 = np.zeros(m1, dtype=float)\n        # Contribution from right boundary u_{iR} = g_R to equation at j=iR-1 (index m1-1)\n        b1[-1] += (1.0 / h**2) * 1.0  # g_R = 1\n        # Solve\n        u1 = np.linalg.solve(A1, b1)\n        # Extract u at iL (node index iL) which corresponds to unknown index iL-1 if 1 = iL = iR-1\n        if 1 = iL = iR - 1:\n            alpha = u1[iL - 1]\n        else:\n            # If iL equals 0 or iL equals iR, then the value is boundary: u0=0, u_{iR}=g_R=1\n            # But by construction we ensure iL in [1, iR-1]; however, guard anyway.\n            alpha = 0.0 if iL == 0 else (1.0 if iL == iR else np.nan)\n    else:\n        alpha = np.nan\n\n    # Subdomain 2: indices iL..N, unknowns j=iL+1..N-1\n    m2 = max(0, N - iL - 1)\n    A2 = build_tridiag_helmholtz(m2, h, k)\n    if m2 > 0:\n        b2 = np.zeros(m2, dtype=float)\n        # Contribution from left boundary u_{iL} = g_L to equation at j=iL+1 (index 0)\n        b2[0] += (1.0 / h**2) * 1.0  # g_L = 1\n        v2 = np.linalg.solve(A2, b2)\n        # Extract u at iR (node index iR) which corresponds to unknown index iR - (iL+1)\n        if iL + 1 = iR = N - 1:\n            beta = v2[iR - (iL + 1)]\n        else:\n            beta = 0.0 if iR == N else (1.0 if iR == iL else np.nan)\n    else:\n        beta = np.nan\n\n    # Iteration matrix M = [[0, alpha], [beta, 0]]\n    # Spectral radius is max(abs(eigs)), eigs = ± sqrt(alpha*beta)\n    val = alpha * beta\n    rho = float(np.sqrt(abs(val)))\n    return rho\n\ndef spectral_radius_robin(L, N, k, iG, eta):\n    \"\"\"\n    Compute spectral radius of the 2x2 iteration matrix for non-overlapping optimized Schwarz\n    with complex Robin transmission on a 1D Helmholtz problem.\n    \"\"\"\n    h = L / N\n    # Subdomain 1: unknowns j=1..iG (size m1=iG)\n    m1 = iG\n    if m1 == 0:\n        a = np.nan\n    else:\n        A1 = np.zeros((m1, m1), dtype=complex)\n        b1 = np.zeros(m1, dtype=complex)\n        # Interior rows for j=1..iG-1 map to p=0..m1-2\n        for j in range(1, iG):\n            p = j - 1\n            A1[p, p] += (2.0 / h**2 - k**2)\n            if p - 1 >= 0:\n                A1[p, p - 1] += (-1.0 / h**2)\n            else:\n                # left boundary u0=0 contributes nothing\n                pass\n            if p + 1 = m1 - 1:\n                A1[p, p + 1] += (-1.0 / h**2)\n        # Robin row at j=iG => p=m1-1\n        p = m1 - 1\n        # coefficients: (-1/h) * u_{iG-1} + (1/h + i*eta) * u_{iG} = s_R\n        if m1 - 2 >= 0:\n            A1[p, m1 - 2] += (-1.0 / h)\n        A1[p, m1 - 1] += (1.0 / h + 1j * eta)\n        # Solve for s_R = 1\n        b1[p] = 1.0 + 0j\n        u1 = np.linalg.solve(A1, b1)\n        # Outgoing trace to the left: s_L_out = -(u_{iG} - u_{iG-1})/h + i*eta*u_{iG}\n        u_iG = u1[m1 - 1]\n        u_iGm1 = u1[m1 - 2] if m1 - 2 >= 0 else 0.0 + 0j  # if iG=1, then u_{iG-1} = u0 = 0\n        sL = - (u_iG - u_iGm1) / h + 1j * eta * u_iG\n        a = sL\n\n    # Subdomain 2: unknowns j=iG..N-1 (size m2=N - iG)\n    m2 = N - iG\n    if m2 == 0:\n        b = np.nan\n    else:\n        A2 = np.zeros((m2, m2), dtype=complex)\n        b2 = np.zeros(m2, dtype=complex)\n        # Robin row at left boundary j=iG => p=0\n        # (1/h + i*eta) * u_{iG} + (-1/h) * u_{iG+1} = s_L\n        A2[0, 0] += (1.0 / h + 1j * eta)\n        if m2 - 1 >= 1:\n            A2[0, 1] += (-1.0 / h)\n        # Interior rows for j=iG+1..N-1 map to p=1..m2-1\n        for j in range(iG + 1, N):\n            p = j - iG\n            # p runs 1..m2-1\n            A2[p, p] += (2.0 / h**2 - k**2)\n            A2[p, p - 1] += (-1.0 / h**2)\n            if p + 1 = m2 - 1:\n                A2[p, p + 1] += (-1.0 / h**2)\n            else:\n                # right boundary u_N=0 contributes nothing\n                pass\n        # Solve for s_L = 1\n        b2[0] = 1.0 + 0j\n        v2 = np.linalg.solve(A2, b2)\n        # Outgoing trace to the right: s_R_out = (u_{iG+1} - u_{iG})/h + i*eta*u_{iG}\n        u_iG = v2[0]\n        u_iGp1 = v2[1] if m2 >= 2 else 0.0 + 0j  # if only one unknown, then u_{iG+1}=u_N=0\n        sR = (u_iGp1 - u_iG) / h + 1j * eta * u_iG\n        b = sR\n\n    val = a * b\n    rho = float(np.sqrt(abs(val)))\n    return rho\n\ndef indices_for_overlap(N, ov, h):\n    \"\"\"\n    Compute iL and iR from desired overlap length ov, centered at the middle index.\n    Clamp to satisfy 1 = iL  iR = N-1.\n    \"\"\"\n    mid = N // 2\n    # convert overlap length to number of nodes across the overlapping region\n    ov_nodes = max(1, int(round(ov / h)))\n    half = ov_nodes // 2\n    iL = max(1, mid - half)\n    iR = min(N - 1, mid + (ov_nodes - half))\n    if iL >= iR:\n        # ensure at least one overlap\n        iL = max(1, iL - 1)\n    return iL, iR\n\ndef main():\n    tests = []\n    L = 1.0\n    # Test 1: N=400, k=20*pi, ov=0.05, eta=k\n    tests.append({\"N\": 400, \"k\": 20.0 * np.pi, \"ov\": 0.05, \"eta_factor\": 1.0})\n    # Test 2: N=400, k=6*pi, ov=0.10, eta=k\n    tests.append({\"N\": 400, \"k\": 6.0 * np.pi, \"ov\": 0.10, \"eta_factor\": 1.0})\n    # Test 3: N=400, k=20*pi, ov=h=L/N, eta=0.5*k\n    tests.append({\"N\": 400, \"k\": 20.0 * np.pi, \"ov\": None, \"eta_factor\": 0.5})  # ov to be set as h\n\n    results = []\n    for t in tests:\n        N = t[\"N\"]\n        k = t[\"k\"]\n        h = L / N\n        ov = t[\"ov\"] if t[\"ov\"] is not None else h\n        eta = t[\"eta_factor\"] * k\n        # Indices for overlap\n        iL, iR = indices_for_overlap(N, ov, h)\n        # Interface index for non-overlapping\n        iG = N // 2\n        # Spectral radii\n        rho_D = spectral_radius_dirichlet(L, N, k, iL, iR)\n        rho_R = spectral_radius_robin(L, N, k, iG, eta)\n        results.append(f\"{rho_D:.6f}\")\n        results.append(f\"{rho_R:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    main()\n```"
        },
        {
            "introduction": "在解决了基本收敛性问题后，我们转向一个更高级的挑战：处理带有奇异性的偏微分方程。当一个物理问题（如带有纯诺伊曼（Neumann）边界条件的泊松方程）的解不是唯一时，其对应的离散系统会继承这种奇异性，表现为矩阵存在零空间。本练习将引导您通过计算来探究这一现象，您将发现“浮动”子区域的局部算子以及非重叠方法中的舒尔补（Schur complement）算子都会变得奇异。通过量化这些算子的奇异值，并实现一种增广系统来消除奇异性，您将掌握处理此类问题并确保解的唯一性的关键技术。",
            "id": "3428530",
            "problem": "考虑闭合区间 $[0,1]$ 上带齐次Neumann边界条件的的一维泊松方程模型问题。连续问题是找到一个函数 $u$，使得在 $(0,1)$ 内 $-\\frac{d^2u}{dx^2} = f$，并且 $\\frac{du}{dx}(0) = 0$，$\\frac{du}{dx}(1) = 0$。用 $N$ 个等距网格点离散化该区间，并通过标准的二阶中心有限差分格式来近似负二阶导数。这将产生一个对称半正定线性系统 $A u = b$，其中 $A \\in \\mathbb{R}^{N \\times N}$ 是离散Neumann拉普拉斯算子。对于齐次Neumann边界条件，矩阵 $A$ 有一个与常数向量相关的非平凡零空间。\n\n任务是在离散情况下，从算法和定量角度分析零空间对重叠Schwarz方法和非重叠Schur补方法的影响。仅使用以下基本依据：\n\n- 泊松方程的齐次Neumann边界条件的定义及其离散有限差分表示。\n- 将区域分解为子区域的概念，以及从分块高斯消去和子区域局部算子开始，在代数层面上对重叠Schwarz方法和非重叠Schur补方法的定义。\n- 奇异值分解（Singular Value Decomposition, SVD）的定义，以及使用奇异值来确定零空间的维度并通过最小奇异值来量化奇异性。\n\n待使用的定义：\n\n- “浮动子区域”是指其局部算子在其所有边界上都具有齐次Neumann条件的子区域，从而产生一个由常数向量生成的局部零空间。\n- 在人工子区域边界上采用齐次Neumann条件的重叠Schwarz方法中，每个子区域求解都使用一个局部的离散Neumann算子。\n- 在非重叠Schur补方法中，界面自由度 $\\Gamma$ 被保留，而内部自由度 $I$ 通过分块高斯消去被消除，从而在 $\\Gamma$ 上产生一个凝聚算子。在纯Neumann设定下，该凝聚算子可能是奇异的；一种补救方法是用一个单一约束来增广凝聚系统，以消除全局常数模态（例如，通过拉格朗日乘子强制施加零均值条件）。\n\n为每个测试用例实现以下计算任务：\n\n1.  使用标准的二阶中心有限差分格式，在两端施加齐次Neumann边界条件，构建离散Neumann拉普拉斯矩阵 $A \\in \\mathbb{R}^{N \\times N}$。矩阵元素必须在两个物理边界行上明确反映Neumann条件。\n\n2.  通过计算小于或等于固定绝对容差 $10^{-10}$ 的奇异值数量，确定 $A$ 的零空间维度 $d_{\\text{glob}}$。\n\n3.  对于重叠Schwarz方法，使用一个界面索引 $m$ 和一个重叠大小 $o$ 定义一个双子区域分解，将左子区域定义为连续索引集 $\\{0,1,\\dots,m+o\\}$，右子区域定义为连续索引集 $\\{m-o,\\dots,N-1\\}$。对每个子区域，构建其相应大小的局部离散Neumann算子（如步骤1，但使用子区域大小代替 $N$），并使用相同的奇异值阈值准则计算其零空间维度 $d_{\\text{sub},1}$ 和 $d_{\\text{sub},2}$。报告这些整数。\n\n4.  对于非重叠Schur补方法，定义界面集 $\\Gamma = \\{m\\}$ 和内部集 $I = \\{0,1,\\dots,m-1,m+1,\\dots,N-1\\}$。通过对内点进行分块高斯消去，在 $\\Gamma$ 上构造Schur补 $S$。通过计算其最小奇异值 $s_{\\min}$ 来量化其奇异性。\n\n5.  用一个单一的均值约束来增广凝聚界面系统，以消除 $\\Gamma$ 上的常数模态。具体来说，构造增广的 $2 \\times 2$ 矩阵\n$$\n\\tilde{S} = \\begin{bmatrix}\nS  1 \\\\\n1  0\n\\end{bmatrix},\n$$\n其中标量 $1$ 将界面未知量与一个强制执行该约束的拉格朗日乘子耦合。计算 $\\tilde{S}$ 的最小奇异值 $s_{\\min}^{\\text{aug}}$。\n\n数值考虑：\n\n- 在确定零空间维度时，使用 $10^{-10}$ 的绝对奇异值容差。\n- 所有计算都是无量纲的；不需要物理单位。\n\n测试套件和输出规范：\n\n在以下三个测试用例上运行程序：\n- 测试用例 1: $N=8$, $m=4$, $o=1$。\n- 测试用例 2: $N=7$, $m=3$, $o=2$。\n- 测试用例 3 (边界边缘情况): $N=3$, $m=1$, $o=1$。\n\n对于每个测试用例，按以下顺序生成五个结果：\n- $d_{\\text{glob}}$ (整数),\n- $d_{\\text{sub},1}$ (整数),\n- $d_{\\text{sub},2}$ (整数),\n- $s_{\\min}$ (浮点数),\n- $s_{\\min}^{\\text{aug}}$ (浮点数)。\n\n你的程序应生成单行输出，其中包含所有三个测试用例的结果，按上述顺序连接成一个用逗号分隔并用方括号括起来的列表（例如，$[r_1,r_2,\\dots,r_{15}]$）。每个条目必须是整数或浮点数；输出行中不得有任何其他文本。",
            "solution": "本任务要求对零空间在一维泊松方程（带齐次Neumann边界条件）的两种著名区域分解方法——即重叠Schwarz方法和非重叠Schur补方法——中的影响进行计算分析。该分析始于对连续问题的适当离散化，并通过一系列基于奇异值分解（SVD）的代数操作和量化来进行。\n\n首先，我们处理问题的离散化：找到一个函数 $u$，使得在 $(0,1)$ 内 $-\\frac{d^2u}{dx^2} = f$，边界条件为 $\\frac{du}{dx}(0) = 0$ 和 $\\frac{du}{dx}(1) = 0$。我们使用 $N$ 个等距点 $x_i = i \\cdot h$（其中 $i \\in \\{0, 1, \\dots, N-1\\}$，网格间距 $h = 1/(N-1)$）来离散化区域 $[0,1]$。用于负二阶导数且带齐次Neumann条件的标准、对称、半正定离散算子可从有限元或有限体积方法导出。这会产生一个 $N \\times N$ 矩阵 $A$，经 $1/h^2$ 缩放后，具有以下结构：\n$$\nA = \\frac{1}{h^2} \\begin{pmatrix}\n1  -1    \\mathbf{0} \\\\\n-1  2  -1   \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  -1  2  -1 \\\\\n\\mathbf{0}    -1  1\n\\end{pmatrix}\n$$\n该矩阵 $A$ 是对称且半正定的。它的零空间是一维的，由常数向量 $\\mathbf{1} = [1, 1, \\dots, 1]^T$ 张成，因为每行之和为零，这意味着 $A \\mathbf{1} = \\mathbf{0}$。\n\n计算任务如下：\n\n1.  **全局零空间维度 ($d_{\\text{glob}}$)**：我们如上所述构造全局矩阵 $A \\in \\mathbb{R}^{N \\times N}$。其零空间的维度 $d_{\\text{glob}}$ 通过计算 $A$ 的奇异值并统计其中小于或等于指定容差 $\\tau = 10^{-10}$ 的数量来确定。根据Neumann问题的性质，我们预期 $d_{\\text{glob}} = 1$。\n\n2.  **重叠Schwarz子区域零空间 ($d_{\\text{sub},1}, d_{\\text{sub},2}$)**：区域被分解为两个重叠的子区域。左子区域 $\\Omega_1$ 对应索引 $\\{0, 1, \\dots, m+o\\}$，右子区域 $\\Omega_2$ 对应索引 $\\{m-o, \\dots, N-1\\}$。这些子区域的大小分别为 $N_1 = m+o+1$ 和 $N_2 = (N-1) - (m-o) + 1 = N-m+o$。问题规定，这些子区域的局部算子本身就是离散Neumann拉普拉斯算子，定义在网格间距分别为 $h_1 = 1/(N_1-1)$ 和 $h_2 = 1/(N_2-1)$ 的局部网格上。这些是所谓的“浮动子区域”，因为它们仅具有Neumann边界条件（物理的或人工的）。因此，对于 $k \\in \\{1, 2\\}$，每个局部算子 $A_k \\in \\mathbb{R}^{N_k \\times N_k}$ 都将有其自己的一维零空间。我们通过应用相同的基于SVD的阈值方法来计算零空间维度 $d_{\\text{sub},1}$ 和 $d_{\\text{sub},2}$。我们预期 $d_{\\text{sub},1}=1$ 和 $d_{\\text{sub},2}=1$。\n\n3.  **非重叠Schur补的奇异性 ($s_{\\min}$)**：对于此分析，区域被划分为两个非重叠的内部集合 $I_1 = \\{0, \\dots, m-1\\}$ 和 $I_2 = \\{m+1, \\dots, N-1\\}$，以及一个单节点界面集合 $\\Gamma = \\{m\\}$。全局线性系统 $Au=b$ 根据内部自由度 $I = I_1 \\cup I_2$ 和界面自由度 $\\Gamma$ 重新排序：\n    $$\n    \\begin{pmatrix} A_{II}  A_{I\\Gamma} \\\\ A_{\\Gamma I}  A_{\\Gamma\\Gamma} \\end{pmatrix} \\begin{pmatrix} u_I \\\\ u_\\Gamma \\end{pmatrix} = \\begin{pmatrix} b_I \\\\ b_\\Gamma \\end{pmatrix}\n    $$\n    对内部变量 $u_I$ 进行分块高斯消去，得到界面上的Schur补系统：$S u_\\Gamma = b_\\Gamma - A_{\\Gamma I} A_{II}^{-1} b_I$，其中Schur补算子为 $S = A_{\\Gamma\\Gamma} - A_{\\Gamma I} A_{II}^{-1} A_{I\\Gamma}$。\n    由于内部集合 $I_1$ 和 $I_2$ 不连通，矩阵 $A_{II}$ 是分块对角的，即 $A_{II} = \\text{diag}(A_{I_1I_1}, A_{I_2I_2})$。每个块对应一个一端为Neumann条件、另一端为Dirichlet条件（即与 $\\Gamma$ 连接处）的离散拉普拉斯算子，因此是可逆的。所以，$A_{II}$ 是可逆的。\n    我们可以证明 $S$ 必须是奇异的。因为全局矩阵 $A$ 有一个零向量 $\\mathbf{1}$，我们有 $A\\mathbf{1} = \\mathbf{0}$。以分块形式表示，这给出：\n    $$\n    A_{II} \\mathbf{1}_I + A_{I\\Gamma} \\mathbf{1}_\\Gamma = \\mathbf{0} \\quad \\text{和} \\quad A_{\\Gamma I} \\mathbf{1}_I + A_{\\Gamma\\Gamma} \\mathbf{1}_\\Gamma = \\mathbf{0}\n    $$\n    由于 $A_{II}$ 是可逆的，从第一个方程我们得到 $\\mathbf{1}_I = -A_{II}^{-1} A_{I\\Gamma} \\mathbf{1}_\\Gamma$。将此代入第二个方程得到：\n    $$\n    A_{\\Gamma I} (-A_{II}^{-1} A_{I\\Gamma} \\mathbf{1}_\\Gamma) + A_{\\Gamma\\Gamma} \\mathbf{1}_\\Gamma = (A_{\\Gamma\\Gamma} - A_{\\Gamma I} A_{II}^{-1} A_{I\\Gamma}) \\mathbf{1}_\\Gamma = S \\mathbf{1}_\\Gamma = \\mathbf{0}\n    $$\n    由于我们的界面 $\\Gamma$ 只包含一个节点，因此 $S$ 是一个标量，$\\mathbf{1}_\\Gamma$ 是标量 $1$。这意味着 $S \\cdot 1 = 0$，所以 $S=0$。在数值上，由于浮点运算，我们预期其最小奇异值 $s_{\\min} = |S|$ 将接近于零。\n\n4.  **增广Schur补的正则性 ($s_{\\min}^{\\text{aug}}$)**：$S$ 的奇异性反映了原始Neumann问题的全局零空间。为了获得一个可解的界面系统，可以通过增广Schur补系统来移除这个零空间。一种常见的方法是通过拉格朗日乘子添加一个约束，例如零均值条件。这导致了增广的 $2 \\times 2$ 分块系统：\n    $$\n    \\tilde{S} = \\begin{bmatrix}\n    S  1 \\\\\n    1  0\n    \\end{bmatrix}\n    $$\n    在理想情况 $S=0$ 下，该矩阵为 $\\tilde{S} = \\begin{bmatrix} 0  1 \\\\ 1  0 \\end{bmatrix}$。其特征值为 $\\lambda = \\pm 1$，其奇异值为 $|\\lambda| = 1$。该矩阵是良态的。我们计算数值计算出的 $\\tilde{S}$ 的最小奇异值 $s_{\\min}^{\\text{aug}}$。鉴于 $S \\approx 0$，我们预期 $s_{\\min}^{\\text{aug}} \\approx 1$。\n\n基于这一理论基础，每个测试用例的预期结果是一个形式为 $(1, 1, 1, \\approx 0, \\approx 1)$ 的序列。接下来的实现将通过数值方法验证这些预测。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import svdvals\n\ndef create_neumann_laplacian(N: int, h: float) -> np.ndarray:\n    \"\"\"\n    Constructs the N x N discrete 1D Neumann Laplacian matrix.\n    \n    The matrix corresponds to a second-order finite difference/element\n    discretization of the negative second derivative -d^2/dx^2 on a\n    uniform grid with N points and spacing h, with homogeneous Neumann\n    boundary conditions at both ends.\n    \"\"\"\n    if N == 0:\n        return np.array([[]])\n    if N == 1:\n        # A single point with Neumann conditions on both sides has no 'stiffness'.\n        # The operator is the zero operator. It has a 1D null space.\n        return np.array([[0.0]])\n        \n    A = np.zeros((N, N))\n    \n    # Interior nodes\n    for i in range(1, N - 1):\n        A[i, i - 1] = -1.0\n        A[i, i]     = 2.0\n        A[i, i + 1] = -1.0\n        \n    # Boundary nodes\n    A[0, 0] = 1.0\n    A[0, 1] = -1.0\n    \n    A[N - 1, N - 2] = -1.0\n    A[N - 1, N - 1] = 1.0\n    \n    h2 = h * h\n    if h2 > 0:\n      A /= h2\n      \n    return A\n\ndef solve():\n    \"\"\"\n    Executes the computational tasks for the given test suite and prints results.\n    \"\"\"\n    test_cases = [\n        # (N, m, o)\n        (8, 4, 1),\n        (7, 3, 2),\n        (3, 1, 1),\n    ]\n\n    results = []\n    TOL = 1e-10\n\n    for N, m, o in test_cases:\n        # Task 1  2: Global Operator and Null Space\n        if N > 1:\n            h_glob = 1.0 / (N - 1)\n        else:\n            h_glob = 0.0 # Avoid division by zero, handled by create_neumann_laplacian\n        \n        A = create_neumann_laplacian(N, h_glob)\n        s_glob = svdvals(A)\n        d_glob = np.sum(s_glob = TOL)\n        results.append(int(d_glob))\n\n        # Task 3: Overlapping Schwarz Subdomain Null Spaces\n        # Left subdomain\n        N1 = m + o + 1\n        if N1 > 1:\n            h1 = 1.0 / (N1 - 1)\n        else:\n            h1 = 0.0\n        A1 = create_neumann_laplacian(N1, h1)\n        s1 = svdvals(A1)\n        d_sub_1 = np.sum(s1 = TOL)\n        results.append(int(d_sub_1))\n\n        # Right subdomain\n        N2 = N - m + o\n        if N2 > 1:\n            h2 = 1.0 / (N2 - 1)\n        else:\n            h2 = 0.0\n        A2 = create_neumann_laplacian(N2, h2)\n        s2 = svdvals(A2)\n        d_sub_2 = np.sum(s2 = TOL)\n        results.append(int(d_sub_2))\n\n        # Task 4: Non-overlapping Schur Complement Singularity\n        Gamma = [m]\n        I = list(range(m)) + list(range(m + 1, N))\n        \n        A_GG = A[np.ix_(Gamma, Gamma)]\n        A_GI = A[np.ix_(Gamma, I)]\n        A_IG = A[np.ix_(I, Gamma)]\n        A_II = A[np.ix_(I, I)]\n        \n        # Solve A_II * X = A_IG for X, then S = A_GG - A_GI @ X\n        try:\n            x = np.linalg.solve(A_II, A_IG)\n            S_matrix = A_GG - A_GI @ x\n            S = S_matrix[0, 0]\n        except np.linalg.LinAlgError:\n            # This case shouldn't be reached with the given problem setup\n            # as A_II is invertible.\n            S = np.nan\n\n        # Smallest singular value of S (which is a scalar) is its absolute value.\n        s_min = np.abs(S)\n        results.append(s_min)\n        \n        # Task 5: Augmented Schur Complement\n        S_tilde = np.array([[S, 1.0], [1.0, 0.0]])\n        s_tilde_vals = svdvals(S_tilde)\n        s_min_aug = np.min(s_tilde_vals)\n        results.append(s_min_aug)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}