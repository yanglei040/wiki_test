{
    "hands_on_practices": [
        {
            "introduction": "Many problems in physics and engineering, such as electrostatics or steady-state heat flow on insulated domains, are described by the Poisson equation with pure Neumann boundary conditions. These problems are singular, possessing solutions that are unique only up to an additive constant, which manifests as a null space in the discretized operator. This practice explores how this global singularity impacts both overlapping Schwarz and non-overlapping Schur complement methods, leading to \"floating subdomains\" and a singular interface system. By computationally investigating these null spaces, you will gain a fundamental understanding of the algebraic challenges posed by singular problems and learn how to regularize the Schur complement system to restore well-posedness .",
            "id": "3428530",
            "problem": "Consider the one-dimensional model problem for the Poisson equation with homogeneous Neumann boundary conditions on the closed interval $[0,1]$. The continuous problem is to find a function $u$ such that $-\\frac{d^2u}{dx^2} = f$ in $(0,1)$ and $\\frac{du}{dx}(0) = 0$, $\\frac{du}{dx}(1) = 0$. Discretize the interval with $N$ equally spaced grid points, and approximate the negative second derivative by the standard second-order centered finite difference scheme. This yields a symmetric, positive semidefinite linear system $A u = b$, where $A \\in \\mathbb{R}^{N \\times N}$ is the discrete Neumann Laplacian. For homogeneous Neumann boundary conditions, the matrix $A$ has a nontrivial null space associated with constant vectors.\n\nThe task is to analyze, algorithmically and quantitatively, the effects of null spaces on overlapping Schwarz and non-overlapping Schur complement methods in the discrete setting. Use only the following fundamental bases:\n\n- The definition of homogeneous Neumann boundary conditions for the Poisson equation and their discrete finite difference representation.\n- The concept of domain decomposition into subdomains and the definitions of overlapping Schwarz and non-overlapping Schur complement methods at the algebraic level, starting from block Gaussian elimination and subdomain-local operators.\n- The definition of the singular value decomposition (Singular Value Decomposition (SVD)) and the use of singular values to determine the dimension of the null space and to quantify singularity via the smallest singular value.\n\nDefinitions to be used:\n\n- A \"floating subdomain\" is a subdomain whose local operator has homogeneous Neumann conditions on all of its boundaries, yielding a local null space generated by the constant vector.\n- In an overlapping Schwarz method with homogeneous Neumann conditions on the artificial subdomain boundaries, each subdomain solve uses a local discrete Neumann operator.\n- In a non-overlapping Schur complement method, the interface degrees of freedom $\\Gamma$ are retained while the interior degrees of freedom $I$ are eliminated by block Gaussian elimination, producing a condensed operator on $\\Gamma$. In the pure Neumann setting, the condensed operator can be singular; one remedy is to augment the condensed system with a single constraint that removes the global constant mode (for example, enforcing a zero-mean condition via a Lagrange multiplier).\n\nImplement the following computational tasks for each test case:\n\n1. Construct the discrete Neumann Laplacian $A \\in \\mathbb{R}^{N \\times N}$ using the standard second-order centered finite difference scheme with homogeneous Neumann boundary conditions at both ends. The matrix entries must reflect the Neumann conditions explicitly at the two physical boundary rows.\n\n2. Determine the dimension $d_{\\text{glob}}$ of the null space of $A$ by counting the number of singular values less than or equal to a fixed absolute tolerance $10^{-10}$.\n\n3. For overlapping Schwarz, with a two-subdomain decomposition defined by an interface index $m$ and an overlap size $o$, define the left subdomain as the contiguous index set $\\{0,1,\\dots,m+o\\}$ and the right subdomain as the contiguous index set $\\{m-o,\\dots,N-1\\}$. For each subdomain, construct its local discrete Neumann operator of the appropriate size (as in step 1 but with the subdomain size in place of $N$) and compute the null space dimension $d_{\\text{sub},1}$ and $d_{\\text{sub},2}$ using the same singular value thresholding criterion. Report these integers.\n\n4. For non-overlapping Schur complement, define the interface set $\\Gamma = \\{m\\}$ and the interior set $I = \\{0,1,\\dots,m-1,m+1,\\dots,N-1\\}$. Form the Schur complement $S$ on $\\Gamma$ by block Gaussian elimination of the interior. Quantify its singularity by computing the smallest singular value $s_{\\min}$.\n\n5. Augment the condensed interface system with a single mean-value constraint to remove the constant mode on $\\Gamma$. Concretely, form the augmented $2 \\times 2$ matrix\n$$\n\\tilde{S} = \\begin{bmatrix}\nS & 1 \\\\\n1 & 0\n\\end{bmatrix},\n$$\nwhere the scalar $1$ couples the interface unknown to a Lagrange multiplier enforcing the constraint. Compute the smallest singular value $s_{\\min}^{\\text{aug}}$ of $\\tilde{S}$.\n\nNumerical considerations:\n\n- Use an absolute singular value tolerance of $10^{-10}$ when determining null space dimensions.\n- All computations are dimensionless; no physical units are required.\n\nTest suite and output specification:\n\nRun the program on the following three test cases:\n- Test case 1: $N=8$, $m=4$, $o=1$.\n- Test case 2: $N=7$, $m=3$, $o=2$.\n- Test case 3 (boundary edge case): $N=3$, $m=1$, $o=1$.\n\nFor each test case, produce the five results in the order:\n- $d_{\\text{glob}}$ (integer),\n- $d_{\\text{sub},1}$ (integer),\n- $d_{\\text{sub},2}$ (integer),\n- $s_{\\min}$ (float),\n- $s_{\\min}^{\\text{aug}}$ (float).\n\nYour program should produce a single line of output containing the results for all three test cases concatenated in the above order as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,\\dots,r_{15}]$). Each entry must be an integer or a floating-point number; there must be no additional text in the output line.",
            "solution": "The present task requires a computational analysis of the impact of null spaces on two prominent domain decomposition methods, namely overlapping Schwarz and non-overlapping Schur complement methods, for the one-dimensional Poisson equation with homogeneous Neumann boundary conditions. The analysis begins with a proper discretization of the continuous problem and proceeds through a series of algebraic manipulations and quantifications based on the Singular Value Decomposition (SVD).\n\nFirst, we address the discretization of the problem: find a function $u$ such that $-\\frac{d^2u}{dx^2} = f$ in $(0,1)$ with boundary conditions $\\frac{du}{dx}(0) = 0$ and $\\frac{du}{dx}(1) = 0$. We discretize the domain $[0,1]$ using $N$ equally spaced points $x_i = i \\cdot h$ for $i \\in \\{0, 1, \\dots, N-1\\}$, where the grid spacing is $h = 1/(N-1)$. The standard, symmetric, semi-definite discrete operator for the negative second derivative with homogeneous Neumann conditions is derived from a finite element or finite volume approach. This results in an $N \\times N$ matrix $A$, scaled by $1/h^2$, with the following structure:\n$$\nA = \\frac{1}{h^2} \\begin{pmatrix}\n1 & -1 & & & \\mathbf{0} \\\\\n-1 & 2 & -1 & & \\\\\n& \\ddots & \\ddots & \\ddots & \\\\\n& & -1 & 2 & -1 \\\\\n\\mathbf{0} & & & -1 & 1\n\\end{pmatrix}\n$$\nThis matrix $A$ is symmetric and positive semidefinite. Its null space is one-dimensional and is spanned by the constant vector $\\mathbf{1} = [1, 1, \\dots, 1]^T$, since the sum of each row is zero, which implies $A \\mathbf{1} = \\mathbf{0}$.\n\nThe computational tasks are as follows:\n\n1.  **Global Null Space Dimension ($d_{\\text{glob}}$)**: We construct the global matrix $A \\in \\mathbb{R}^{N \\times N}$ as described above. The dimension of its null space, $d_{\\text{glob}}$, is determined by computing the singular values of $A$ and counting how many are less than or equal to a specified tolerance, $\\tau = 10^{-10}$. Based on the properties of the Neumann problem, we expect $d_{\\text{glob}} = 1$.\n\n2.  **Overlapping Schwarz Subdomain Null Spaces ($d_{\\text{sub},1}, d_{\\text{sub},2}$)**: The domain is decomposed into two overlapping subdomains. The left subdomain $\\Omega_1$ corresponds to indices $\\{0, 1, \\dots, m+o\\}$, and the right subdomain $\\Omega_2$ corresponds to indices $\\{m-o, \\dots, N-1\\}$. The sizes of these subdomains are $N_1 = m+o+1$ and $N_2 = (N-1) - (m-o) + 1 = N-m+o$, respectively. The problem specifies that the local operators for these subdomains are themselves discrete Neumann Laplacians, defined on local grids with spacings $h_1 = 1/(N_1-1)$ and $h_2 = 1/(N_2-1)$. These are so-called \"floating subdomains\" because they possess only Neumann boundary conditions (physical or artificial). Consequently, each local operator $A_k \\in \\mathbb{R}^{N_k \\times N_k}$ for $k \\in \\{1, 2\\}$ will have its own one-dimensional null space. We compute the null space dimensions $d_{\\text{sub},1}$ and $d_{\\text{sub},2}$ by applying the same SVD-based thresholding method. We expect both $d_{\\text{sub},1}=1$ and $d_{\\text{sub},2}=1$.\n\n3.  **Non-overlapping Schur Complement Singularity ($s_{\\min}$)**: For this analysis, the domain is partitioned into two non-overlapping interior sets, $I_1 = \\{0, \\dots, m-1\\}$ and $I_2 = \\{m+1, \\dots, N-1\\}$, and a single-node interface set $\\Gamma = \\{m\\}$. The global linear system $Au=b$ is reordered according to the interior degrees of freedom $I = I_1 \\cup I_2$ and the interface degrees of freedom $\\Gamma$:\n    $$\n    \\begin{pmatrix} A_{II} & A_{I\\Gamma} \\\\ A_{\\Gamma I} & A_{\\Gamma\\Gamma} \\end{pmatrix} \\begin{pmatrix} u_I \\\\ u_\\Gamma \\end{pmatrix} = \\begin{pmatrix} b_I \\\\ b_\\Gamma \\end{pmatrix}\n    $$\n    Block Gaussian elimination of the interior variables $u_I$ yields the Schur complement system on the interface: $S u_\\Gamma = b_\\Gamma - A_{\\Gamma I} A_{II}^{-1} b_I$, where the Schur complement operator is $S = A_{\\Gamma\\Gamma} - A_{\\Gamma I} A_{II}^{-1} A_{I\\Gamma}$.\n    The matrix $A_{II}$ is block diagonal as the interior sets $I_1$ and $I_2$ are disconnected, i.e., $A_{II} = \\text{diag}(A_{I_1I_1}, A_{I_2I_2})$. Each block corresponds to a discrete Laplacian with a Neumann condition at one end and a Dirichlet condition at the other (where it was connected to $\\Gamma$), and is therefore invertible. Thus, $A_{II}$ is invertible.\n    We can show that $S$ must be singular. Since the global matrix $A$ has a null vector $\\mathbf{1}$, we have $A\\mathbf{1} = \\mathbf{0}$. In partitioned form, this gives:\n    $$\n    A_{II} \\mathbf{1}_I + A_{I\\Gamma} \\mathbf{1}_\\Gamma = \\mathbf{0} \\quad \\text{and} \\quad A_{\\Gamma I} \\mathbf{1}_I + A_{\\Gamma\\Gamma} \\mathbf{1}_\\Gamma = \\mathbf{0}\n    $$\n    Since $A_{II}$ is invertible, from the first equation we have $\\mathbf{1}_I = -A_{II}^{-1} A_{I\\Gamma} \\mathbf{1}_\\Gamma$. Substituting this into the second equation gives:\n    $$\n    A_{\\Gamma I} (-A_{II}^{-1} A_{I\\Gamma} \\mathbf{1}_\\Gamma) + A_{\\Gamma\\Gamma} \\mathbf{1}_\\Gamma = (A_{\\Gamma\\Gamma} - A_{\\Gamma I} A_{II}^{-1} A_{I\\Gamma}) \\mathbf{1}_\\Gamma = S \\mathbf{1}_\\Gamma = \\mathbf{0}\n    $$\n    Since our interface $\\Gamma$ consists of a single node, $S$ is a scalar and $\\mathbf{1}_\\Gamma$ is the scalar $1$. This implies $S \\cdot 1 = 0$, so $S=0$. Numerically, we expect its smallest singular value, $s_{\\min} = |S|$, to be close to zero due to floating-point arithmetic.\n\n4.  **Augmented Schur Complement Regularity ($s_{\\min}^{\\text{aug}}$)**: The singularity of $S$ reflects the global null space of the original Neumann problem. To obtain a solvable system for the interface, one can augment the Schur complement system to remove this null space. A common method is to add a constraint, such as a zero-mean condition, via a Lagrange multiplier. This leads to the augmented $2 \\times 2$ block system:\n    $$\n    \\tilde{S} = \\begin{bmatrix}\n    S & 1 \\\\\n    1 & 0\n    \\end{bmatrix}\n    $$\n    In the ideal case where $S=0$, this matrix is $\\tilde{S} = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix}$. Its eigenvalues are $\\lambda = \\pm 1$, and its singular values are $|\\lambda| = 1$. The matrix is well-conditioned. We calculate the smallest singular value $s_{\\min}^{\\text{aug}}$ of the numerically computed $\\tilde{S}$. Given that $S \\approx 0$, we expect $s_{\\min}^{\\text{aug}} \\approx 1$.\n\nBased on this theoretical foundation, the expected results for each test case are a sequence of the form $(1, 1, 1, \\approx 0, \\approx 1)$. The implementation will now proceed to verify these predictions numerically.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import svdvals\n\ndef create_neumann_laplacian(N: int, h: float) -> np.ndarray:\n    \"\"\"\n    Constructs the N x N discrete 1D Neumann Laplacian matrix.\n    \n    The matrix corresponds to a second-order finite difference/element\n    discretization of the negative second derivative -d^2/dx^2 on a\n    uniform grid with N points and spacing h, with homogeneous Neumann\n    boundary conditions at both ends.\n    \"\"\"\n    if N <= 0:\n        return np.array([[]])\n    if N == 1:\n        # A single point with Neumann conditions on both sides has no 'stiffness'.\n        # The operator is the zero operator. It has a 1D null space.\n        return np.array([[0.0]])\n        \n    A = np.zeros((N, N))\n    \n    # Interior nodes\n    for i in range(1, N - 1):\n        A[i, i - 1] = -1.0\n        A[i, i]     = 2.0\n        A[i, i + 1] = -1.0\n        \n    # Boundary nodes\n    A[0, 0] = 1.0\n    A[0, 1] = -1.0\n    \n    A[N - 1, N - 2] = -1.0\n    A[N - 1, N - 1] = 1.0\n    \n    h2 = h * h\n    if h2 > 0:\n      A /= h2\n      \n    return A\n\ndef solve():\n    \"\"\"\n    Executes the computational tasks for the given test suite and prints results.\n    \"\"\"\n    test_cases = [\n        # (N, m, o)\n        (8, 4, 1),\n        (7, 3, 2),\n        (3, 1, 1),\n    ]\n\n    results = []\n    TOL = 1e-10\n\n    for N, m, o in test_cases:\n        # Task 1 & 2: Global Operator and Null Space\n        if N > 1:\n            h_glob = 1.0 / (N - 1)\n        else:\n            h_glob = 0.0 # Avoid division by zero, handled by create_neumann_laplacian\n        \n        A = create_neumann_laplacian(N, h_glob)\n        s_glob = svdvals(A)\n        d_glob = np.sum(s_glob <= TOL)\n        results.append(int(d_glob))\n\n        # Task 3: Overlapping Schwarz Subdomain Null Spaces\n        # Left subdomain\n        N1 = m + o + 1\n        if N1 > 1:\n            h1 = 1.0 / (N1 - 1)\n        else:\n            h1 = 0.0\n        A1 = create_neumann_laplacian(N1, h1)\n        s1 = svdvals(A1)\n        d_sub_1 = np.sum(s1 <= TOL)\n        results.append(int(d_sub_1))\n\n        # Right subdomain\n        N2 = N - m + o\n        if N2 > 1:\n            h2 = 1.0 / (N2 - 1)\n        else:\n            h2 = 0.0\n        A2 = create_neumann_laplacian(N2, h2)\n        s2 = svdvals(A2)\n        d_sub_2 = np.sum(s2 <= TOL)\n        results.append(int(d_sub_2))\n\n        # Task 4: Non-overlapping Schur Complement Singularity\n        Gamma = [m]\n        I = list(range(m)) + list(range(m + 1, N))\n        \n        A_GG = A[np.ix_(Gamma, Gamma)]\n        A_GI = A[np.ix_(Gamma, I)]\n        A_IG = A[np.ix_(I, Gamma)]\n        A_II = A[np.ix_(I, I)]\n        \n        # Solve A_II * X = A_IG for X, then S = A_GG - A_GI @ X\n        try:\n            x = np.linalg.solve(A_II, A_IG)\n            S_matrix = A_GG - A_GI @ x\n            S = S_matrix[0, 0]\n        except np.linalg.LinAlgError:\n            # This case shouldn't be reached with the given problem setup\n            # as A_II is invertible.\n            S = np.nan\n\n        # Smallest singular value of S (which is a scalar) is its absolute value.\n        s_min = np.abs(S)\n        results.append(s_min)\n        \n        # Task 5: Augmented Schur Complement\n        S_tilde = np.array([[S, 1.0], [1.0, 0.0]])\n        s_tilde_vals = svdvals(S_tilde)\n        s_min_aug = np.min(s_tilde_vals)\n        results.append(s_min_aug)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While classical domain decomposition methods are effective for diffusive problems like the Poisson equation, they can fail for wave propagation models like the Helmholtz equation. In this exercise, you will discover this firsthand by implementing a classical overlapping Schwarz method and observing its divergence for a high-frequency wave problem. You will then stabilize the iteration by implementing a non-overlapping method with optimized complex Robin transmission conditions, which act as absorbing boundaries to prevent spurious reflections at the interfaces. This practice provides a compelling demonstration of why modern \"optimized\" Schwarz methods are essential for tackling wave phenomena and allows you to quantify convergence by directly computing the spectral radius of the iteration operators .",
            "id": "3428516",
            "problem": "Consider the one-dimensional constant-coefficient Helmholtz boundary value problem on a closed interval with homogeneous Dirichlet data,\n$$\n-\\,u''(x)\\;-\\;k^2\\,u(x)\\;=\\;0,\\quad x\\in(0,L),\\qquad u(0)=0,\\quad u(L)=0,\n$$\nwhere $L>0$ and $k>0$ are given. You will examine two domain decomposition iterations for the homogeneous error equation and quantify their convergence through the spectral radius of their iteration operators.\n\nMethod A (classical overlapping Schwarz with Dirichlet transmission): Split the global grid into two overlapping subdomains $\\Omega_1=[0,x_R]$ and $\\Omega_2=[x_L,L]$ with overlap $x_R-x_L>0$. In the parallel (Jacobi-in-time) overlapping Schwarz iteration on the homogeneous error equation, each subdomain problem is solved with Dirichlet boundary conditions taken from the outer physical boundary and from the neighbor’s previous iterate at the artificial interface inside the overlap. The interface iteration is defined on the pair of Dirichlet values at the artificial interfaces $g=(g_L,g_R)$, where $g_L$ is the value imposed at $x=x_L$ for $\\Omega_2$ and $g_R$ is the value imposed at $x=x_R$ for $\\Omega_1$. Linearity of the subdomain solves implies a $2\\times 2$ iteration operator of the form\n$$\ng^{(n+1)} \\;=\\; M_D\\, g^{(n)},\\qquad M_D=\\begin{bmatrix} 0 & \\alpha \\\\ \\beta & 0 \\end{bmatrix},\n$$\nwhere the coefficients $\\alpha$ and $\\beta$ are the Dirichlet-to-Dirichlet transfers induced by the two subdomain solves. The iteration converges if and only if the spectral radius $\\rho(M_D)<1$.\n\nMethod B (non-overlapping optimized Schwarz with complex Robin transmission): Partition the domain into two non-overlapping subdomains $\\Omega_1=[0,x_\\Gamma]$ and $\\Omega_2=[x_\\Gamma,L]$. On the common interface at $x=x_\\Gamma$, impose the complex Robin (impedance) transmission operators\n$$\nT_1(u)\\;=\\;\\partial_x u\\;+\\;i\\,\\eta\\,u,\\qquad T_2(u)\\;=\\;-\\partial_x u\\;+\\;i\\,\\eta\\,u,\n$$\nfor a chosen impedance parameter $\\eta>0$. In the parallel iteration on the homogeneous error equation, each subdomain uses as input the neighbor’s previous Robin trace and produces as output its own Robin trace to be sent back. With $s=(s_L,s_R)$ denoting the pair of Robin data injected at the interface for $\\Omega_2$ (left) and $\\Omega_1$ (right), linearity again yields an iteration of the form\n$$\ns^{(n+1)} \\;=\\; M_R\\, s^{(n)},\\qquad M_R=\\begin{bmatrix} 0 & a \\\\ b & 0 \\end{bmatrix},\n$$\nwhere $a$ and $b$ are the Robin-to-Robin transfers. Convergence is characterized by $\\rho(M_R)<1$.\n\nDiscretization and construction of iteration operators: Discretize the interval $[0,L]$ using a uniform mesh with $N+1$ nodes $x_j=jh$, where $h=L/N$ and $j\\in\\{0,1,\\dots,N\\}$. Discretize the Helmholtz operator with the standard second-order centered finite difference scheme,\n$$\n\\left(\\frac{2}{h^2}-k^2\\right)u_j - \\frac{1}{h^2}u_{j-1} - \\frac{1}{h^2}u_{j+1} = 0,\n$$\non interior nodes, and enforce $u_0=0$ and $u_N=0$. For Method A, choose interface indices $i_L$ and $i_R$ with $1\\le i_L<i_R\\le N-1$; define $\\Omega_1=\\{0,1,\\dots,i_R\\}$ and $\\Omega_2=\\{i_L,i_L+1,\\dots,N\\}$. For the subproblem on $\\Omega_1$, solve the discrete homogeneous system with $u_0=0$ and $u_{i_R}=g_R$, then evaluate $u_{i_L}$ to obtain $g_L^{(n+1)}$. For $\\Omega_2$, solve with $u_{i_L}=g_L$ and $u_N=0$, then evaluate $u_{i_R}$ to obtain $g_R^{(n+1)}$. Construct $M_D$ by applying the mapping to the basis inputs $(g_L,g_R)=(1,0)$ and $(0,1)$ and extracting the two off-diagonal entries.\n\nFor Method B, choose a single interface index $i_\\Gamma$ with $1\\le i_\\Gamma\\le N-1$; define $\\Omega_1=\\{0,1,\\dots,i_\\Gamma\\}$ and $\\Omega_2=\\{i_\\Gamma,i_\\Gamma+1,\\dots,N\\}$. Enforce the complex Robin conditions using first-order one-sided finite differences for the normal derivative at the interface:\n$$\n\\text{on }\\Omega_1:\\quad \\frac{u_{i_\\Gamma}-u_{i_\\Gamma-1}}{h} + i\\,\\eta\\,u_{i_\\Gamma} = s_R,\\qquad u_0=0,\n$$\n$$\n\\text{on }\\Omega_2:\\quad -\\,\\frac{u_{i_\\Gamma+1}-u_{i_\\Gamma}}{h} + i\\,\\eta\\,u_{i_\\Gamma} = s_L,\\qquad u_N=0.\n$$\nGiven $s_R$, solve $\\Omega_1$ and compute the outgoing Robin trace to the left,\n$$\ns_L^{(n+1)} = -\\,\\frac{u_{i_\\Gamma}-u_{i_\\Gamma-1}}{h} + i\\,\\eta\\,u_{i_\\Gamma}.\n$$\nGiven $s_L$, solve $\\Omega_2$ and compute the outgoing Robin trace to the right,\n$$\ns_R^{(n+1)} = \\frac{u_{i_\\Gamma+1}-u_{i_\\Gamma}}{h} + i\\,\\eta\\,u_{i_\\Gamma}.\n$$\nConstruct $M_R$ by applying the mapping to the basis inputs $(s_L,s_R)=(1,0)$ and $(0,1)$ and extracting the two off-diagonal entries.\n\nYour task: Implement the above discrete constructions to compute the spectral radii $\\rho(M_D)$ and $\\rho(M_R)$ for the following test suite of parameters. Use $L=1$ and a central interface split. For Method A, translate the overlap length into indices via $i_L=\\lfloor N/2\\rfloor-\\lfloor \\text{ov}/(2h)\\rfloor$ and $i_R=\\lceil N/2\\rceil+\\lceil \\text{ov}/(2h)\\rceil$, clamped to satisfy $1\\le i_L<i_R\\le N-1$. For Method B, use $i_\\Gamma=\\lfloor N/2\\rfloor$.\n\nTest suite:\n- Test $1$: $N=400$, $k=20\\pi$, overlap $\\text{ov}=0.05$, impedance $\\eta=k$.\n- Test $2$: $N=400$, $k=6\\pi$, overlap $\\text{ov}=0.10$, impedance $\\eta=k$.\n- Test $3$: $N=400$, $k=20\\pi$, overlap $\\text{ov}=h$ (i.e., $\\text{ov}=L/N$), impedance $\\eta=0.5\\,k$.\n\nFor each test case, compute two floats: the spectral radii $\\rho(M_D)$ and $\\rho(M_R)$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$$\n[\\;\\rho(M_D)_{\\text{Test }1},\\ \\rho(M_R)_{\\text{Test }1},\\ \\rho(M_D)_{\\text{Test }2},\\ \\rho(M_R)_{\\text{Test }2},\\ \\rho(M_D)_{\\text{Test }3},\\ \\rho(M_R)_{\\text{Test }3}\\;],\n$$\nwith each float rounded to exactly $6$ decimal places. No physical units are involved. Angles are not used. Percentages are not used. The program must be self-contained, require no input, and follow the execution environment specified elsewhere. The mathematical construction must adhere to the description above; do not use shortcut formulas not derivable from the stated finite difference discretization and interface definitions. The correctness criterion is that each entry is a real nonnegative float representing a spectral radius computed from the corresponding discrete iteration matrix.",
            "solution": "We start from the linear constant-coefficient Helmholtz equation on a bounded interval with homogeneous Dirichlet boundary conditions. The core principles needed are linearity of the boundary value problems, the uniqueness of solutions for second-order two-point boundary value problems with two boundary conditions, and the spectral characterization of linear stationary iterations by their iteration matrices.\n\nDiscretization principle: On a uniform grid with spacing $h=L/N$, the standard second-order centered finite difference for $-u''(x)$ at a grid point yields the discrete operator\n$$\n\\mathcal{A}_h u_j \\;=\\; \\left(\\frac{2}{h^2}-k^2\\right)u_j \\;-\\; \\frac{1}{h^2}\\,u_{j-1} \\;-\\; \\frac{1}{h^2}\\,u_{j+1},\n$$\nfor $j\\in\\{1,2,\\dots,N-1\\}$. We enforce $u_0=0$ and $u_N=0$.\n\nMethod A (classical overlapping Schwarz with Dirichlet transmission): The overlapping subdomains are defined by indices $i_L$ and $i_R$ satisfying $1\\le i_L<i_R\\le N-1$, where the overlap length is $(i_R-i_L)h>0$. Because the error equation is homogeneous and the subdomain solves are linear, the mapping from artificial Dirichlet data at one side of a subdomain to the induced Dirichlet value at the opposite interface is linear. For the left-to-right sweep on $\\Omega_1=\\{0,1,\\dots,i_R\\}$, we solve\n$$\n\\mathcal{A}_h u_j=0,\\ \\ j=1,\\dots,i_R-1,\\qquad u_0=0,\\ u_{i_R}=g_R,\n$$\nand extract $u_{i_L}$, which defines $g_L^{(n+1)}$. For the right-to-left sweep on $\\Omega_2=\\{i_L,\\dots,N\\}$, we solve\n$$\n\\mathcal{A}_h u_j=0,\\ \\ j=i_L+1,\\dots,N-1,\\qquad u_{i_L}=g_L,\\ u_N=0,\n$$\nand extract $u_{i_R}$, which defines $g_R^{(n+1)}$. By linearity, the composite iteration on $g=(g_L,g_R)$ is represented by a $2\\times 2$ matrix\n$$\nM_D=\\begin{bmatrix} 0 & \\alpha \\\\ \\beta & 0 \\end{bmatrix},\n$$\nwhere $\\alpha$ is the value of $u_{i_L}$ obtained from the $\\Omega_1$ solve with $g_R=1$ and $\\beta$ is the value of $u_{i_R}$ obtained from the $\\Omega_2$ solve with $g_L=1$. The eigenvalues of $M_D$ are $\\lambda=\\pm\\sqrt{\\alpha\\beta}$. The spectral radius is\n$$\n\\rho(M_D)\\;=\\;\\max_{\\lambda\\in\\sigma(M_D)}|\\lambda|\\;=\\;\\sqrt{|\\alpha\\beta|}.\n$$\nFor indefinite Helmholtz with large $k$, the magnitude $\\sqrt{|\\alpha\\beta|}$ can exceed $1$, leading to divergence of the classical Dirichlet transmission iteration.\n\nMethod B (non-overlapping optimized Schwarz with complex Robin transmission): We split the grid at $i_\\Gamma$ into $\\Omega_1=\\{0,1,\\dots,i_\\Gamma\\}$ and $\\Omega_2=\\{i_\\Gamma,\\dots,N\\}$. The interface conditions incorporate a complex shift (impedance) that mimics Sommerfeld radiation and damps reflections. At the discrete level, we enforce on $\\Omega_1$ the Robin condition\n$$\n\\frac{u_{i_\\Gamma}-u_{i_\\Gamma-1}}{h} + i\\,\\eta\\,u_{i_\\Gamma} = s_R,\n$$\nand on $\\Omega_2$ the Robin condition\n$$\n-\\,\\frac{u_{i_\\Gamma+1}-u_{i_\\Gamma}}{h} + i\\,\\eta\\,u_{i_\\Gamma} = s_L,\n$$\nwith $u_0=0$ and $u_N=0$. These equations replace the interior stencil at $i_\\Gamma$ on each subdomain, respectively. Because the subproblems are linear in the input Robin data, the outgoing Robin traces\n$$\ns_L^{(n+1)} = -\\,\\frac{u_{i_\\Gamma}-u_{i_\\Gamma-1}}{h} + i\\,\\eta\\,u_{i_\\Gamma},\\qquad\ns_R^{(n+1)} = \\frac{u_{i_\\Gamma+1}-u_{i_\\Gamma}}{h} + i\\,\\eta\\,u_{i_\\Gamma},\n$$\ndepend linearly on the incoming $(s_L,s_R)$. Thus the iteration on $s=(s_L,s_R)$ is again represented by a $2\\times 2$ off-diagonal matrix\n$$\nM_R=\\begin{bmatrix} 0 & a \\\\ b & 0 \\end{bmatrix},\n$$\nwhere $a$ is obtained by solving $\\Omega_1$ with $s_R=1$ (and $s_L$ unused for $\\Omega_1$) and computing $s_L^{(n+1)}$, while $b$ is obtained by solving $\\Omega_2$ with $s_L=1$ and computing $s_R^{(n+1)}$. The spectral radius is\n$$\n\\rho(M_R)\\;=\\;\\sqrt{|ab|}.\n$$\nFor a suitable choice of impedance parameter, notably $\\eta\\approx k$, the optimized Robin transmission acts as an absorbing condition and yields $|ab|<1$, stabilizing the Helmholtz iteration even for large $k$.\n\nAlgorithmic construction: In both methods, we do not rely on closed-form solutions but rather assemble small linear systems corresponding to each subdomain. For Method A, the subdomain matrices are tridiagonal with the centered-difference Helmholtz stencil, and the right-hand side encodes Dirichlet boundary values at the artificial interfaces. For Method B, the subdomain matrices are almost tridiagonal but with the interface row replaced by a Robin row that uses a one-sided finite difference for the normal derivative and includes the complex impedance $i\\,\\eta$. For each test, we compute the two scalar transfers by solving the subdomain systems with unit inputs at the interface, assemble the corresponding $2\\times 2$ iteration matrix, and compute its spectral radius via the magnitude of its eigenvalues.\n\nRelation to Schur complement methods: In the non-overlapping setting, the interface equation obtained by eliminating interior degrees of freedom is the Schur complement system. The optimized Schwarz iteration with Robin transmission can be interpreted as a stationary iteration on this interface Schur complement, preconditioned by approximate local impedance operators. The complex shift $i\\,\\eta$ regularizes the discrete Neumann-to-Dirichlet map of the Helmholtz operator, ensuring that the interface iteration contracts.\n\nTest suite and expected phenomena: With $L=1$ and $N=400$, we consider three cases. In Test $1$ with $k=20\\pi$ and overlap $\\text{ov}=0.05$, the classical Dirichlet transmission iteration typically has $\\rho(M_D)>1$, exhibiting divergence; however, the optimized Robin iteration with $\\eta=k$ yields $\\rho(M_R)<1$. In Test $2$ with $k=6\\pi$ and larger overlap, $\\rho(M_D)$ may be closer to, but not guaranteed to be below, $1$, while $\\rho(M_R)$ remains small with $\\eta=k$. In Test $3$ with minimal overlap $\\text{ov}=h$ and suboptimal impedance $\\eta=0.5\\,k$, $\\rho(M_D)$ remains poor for large $k$, and $\\rho(M_R)$ increases compared to the optimized choice, illustrating sensitivity to $\\eta$.\n\nImplementation details: We assemble the subdomain matrices explicitly. For Method A on $\\Omega_1$, the right boundary Dirichlet value $g_R$ enters the last interior equation as a contribution of $(1/h^2)\\,g_R$ to the right-hand side; the left boundary $u_0=0$ contributes nothing. For $\\Omega_2$, the left boundary $g_L$ similarly contributes $(1/h^2)\\,g_L$ to the first equation. For Method B, the Robin rows at $i_\\Gamma$ are\n$$\n\\text{on }\\Omega_1:\\quad \\left(-\\frac{1}{h}\\right)u_{i_\\Gamma-1}+\\left(\\frac{1}{h}+i\\eta\\right)u_{i_\\Gamma}=s_R,\n$$\n$$\n\\text{on }\\Omega_2:\\quad \\left(\\frac{1}{h}+i\\eta\\right)u_{i_\\Gamma}+\\left(-\\frac{1}{h}\\right)u_{i_\\Gamma+1}=s_L.\n$$\nAfter solving with unit inputs, we compute the outgoing traces by the one-sided finite difference formulas. The spectral radii are then computed from the eigenvalues of the $2\\times 2$ iteration matrices, and the results are printed in the required flat list order, each rounded to six decimal places.\n\nThis construction derives directly from linearity, finite difference discretization, and the definition of Schwarz and Schur complement interface iterations, without invoking unstated shortcut formulas. The algorithm thereby quantifies the divergence of classical overlapping Schwarz for Helmholtz at large $k$ and the stabilization achieved by complex Robin transmission.",
            "answer": "```python\nimport numpy as np\n\ndef build_tridiag_helmholtz(m, h, k):\n    \"\"\"\n    Build the m x m tridiagonal matrix for the discrete Helmholtz operator\n    on interior nodes with stencil: (2/h^2 - k^2) on diagonal and -1/h^2 on off-diagonals.\n    \"\"\"\n    if m <= 0:\n        return np.zeros((0, 0), dtype=float)\n    main = (2.0 / h**2 - k**2) * np.ones(m, dtype=float)\n    off = (-1.0 / h**2) * np.ones(m - 1, dtype=float)\n    A = np.diag(main)\n    if m > 1:\n        A += np.diag(off, k=1) + np.diag(off, k=-1)\n    return A\n\ndef spectral_radius_dirichlet(L, N, k, iL, iR):\n    \"\"\"\n    Compute spectral radius of the 2x2 iteration matrix for classical overlapping Schwarz\n    with Dirichlet transmission on a 1D Helmholtz problem.\n    \"\"\"\n    h = L / N\n    # Subdomain 1: indices 0..iR, unknowns j=1..iR-1\n    m1 = max(0, iR - 1)\n    A1 = build_tridiag_helmholtz(m1, h, k)\n    # RHS for unit g_R\n    if m1 > 0:\n        b1 = np.zeros(m1, dtype=float)\n        # Contribution from right boundary u_{iR} = g_R to equation at j=iR-1 (index m1-1)\n        b1[-1] += (1.0 / h**2) * 1.0  # g_R = 1\n        # Solve\n        u1 = np.linalg.solve(A1, b1)\n        # Extract u at iL (node index iL) which corresponds to unknown index iL-1 if 1 <= iL <= iR-1\n        if 1 <= iL <= iR - 1:\n            alpha = u1[iL - 1]\n        else:\n            # If iL equals 0 or iL equals iR, then the value is boundary: u0=0, u_{iR}=g_R=1\n            # But by construction we ensure iL in [1, iR-1]; however, guard anyway.\n            alpha = 0.0 if iL == 0 else (1.0 if iL == iR else np.nan)\n    else:\n        alpha = np.nan\n\n    # Subdomain 2: indices iL..N, unknowns j=iL+1..N-1\n    m2 = max(0, N - iL - 1)\n    A2 = build_tridiag_helmholtz(m2, h, k)\n    if m2 > 0:\n        b2 = np.zeros(m2, dtype=float)\n        # Contribution from left boundary u_{iL} = g_L to equation at j=iL+1 (index 0)\n        b2[0] += (1.0 / h**2) * 1.0  # g_L = 1\n        v2 = np.linalg.solve(A2, b2)\n        # Extract u at iR (node index iR) which corresponds to unknown index iR - (iL+1)\n        if iL + 1 <= iR <= N - 1:\n            beta = v2[iR - (iL + 1)]\n        else:\n            beta = 0.0 if iR == N else (1.0 if iR == iL else np.nan)\n    else:\n        beta = np.nan\n\n    # Iteration matrix M = [[0, alpha], [beta, 0]]\n    # Spectral radius is max(abs(eigs)), eigs = ± sqrt(alpha*beta)\n    val = alpha * beta\n    rho = float(np.sqrt(abs(val)))\n    return rho\n\ndef spectral_radius_robin(L, N, k, iG, eta):\n    \"\"\"\n    Compute spectral radius of the 2x2 iteration matrix for non-overlapping optimized Schwarz\n    with complex Robin transmission on a 1D Helmholtz problem.\n    \"\"\"\n    h = L / N\n    # Subdomain 1: unknowns j=1..iG (size m1=iG)\n    m1 = iG\n    if m1 <= 0:\n        a = np.nan\n    else:\n        A1 = np.zeros((m1, m1), dtype=complex)\n        b1 = np.zeros(m1, dtype=complex)\n        # Interior rows for j=1..iG-1 map to p=0..m1-2\n        for j in range(1, iG):\n            p = j - 1\n            A1[p, p] += (2.0 / h**2 - k**2)\n            if p - 1 >= 0:\n                A1[p, p - 1] += (-1.0 / h**2)\n            else:\n                # left boundary u0=0 contributes nothing\n                pass\n            if p + 1 <= m1 - 1:\n                A1[p, p + 1] += (-1.0 / h**2)\n        # Robin row at j=iG => p=m1-1\n        p = m1 - 1\n        # coefficients: (-1/h) * u_{iG-1} + (1/h + i*eta) * u_{iG} = s_R\n        if m1 - 2 >= 0:\n            A1[p, m1 - 2] += (-1.0 / h)\n        A1[p, m1 - 1] += (1.0 / h + 1j * eta)\n        # Solve for s_R = 1\n        b1[p] = 1.0 + 0j\n        u1 = np.linalg.solve(A1, b1)\n        # Outgoing trace to the left: s_L_out = -(u_{iG} - u_{iG-1})/h + i*eta*u_{iG}\n        u_iG = u1[m1 - 1]\n        u_iGm1 = u1[m1 - 2] if m1 - 2 >= 0 else 0.0 + 0j  # if iG=1, then u_{iG-1} = u0 = 0\n        sL = - (u_iG - u_iGm1) / h + 1j * eta * u_iG\n        a = sL\n\n    # Subdomain 2: unknowns j=iG..N-1 (size m2=N - iG)\n    m2 = N - iG\n    if m2 <= 0:\n        b = np.nan\n    else:\n        A2 = np.zeros((m2, m2), dtype=complex)\n        b2 = np.zeros(m2, dtype=complex)\n        # Robin row at left boundary j=iG => p=0\n        # (1/h + i*eta) * u_{iG} + (-1/h) * u_{iG+1} = s_L\n        A2[0, 0] += (1.0 / h + 1j * eta)\n        if m2 - 1 >= 1:\n            A2[0, 1] += (-1.0 / h)\n        # Interior rows for j=iG+1..N-1 map to p=1..m2-1\n        for j in range(iG + 1, N):\n            p = j - iG\n            # p runs 1..m2-1\n            A2[p, p] += (2.0 / h**2 - k**2)\n            A2[p, p - 1] += (-1.0 / h**2)\n            if p + 1 <= m2 - 1:\n                A2[p, p + 1] += (-1.0 / h**2)\n            else:\n                # right boundary u_N=0 contributes nothing\n                pass\n        # Solve for s_L = 1\n        b2[0] = 1.0 + 0j\n        v2 = np.linalg.solve(A2, b2)\n        # Outgoing trace to the right: s_R_out = (u_{iG+1} - u_{iG})/h + i*eta*u_{iG}\n        u_iG = v2[0]\n        u_iGp1 = v2[1] if m2 >= 2 else 0.0 + 0j  # if only one unknown, then u_{iG+1}=u_N=0\n        sR = (u_iGp1 - u_iG) / h + 1j * eta * u_iG\n        b = sR\n\n    val = a * b\n    rho = float(np.sqrt(abs(val)))\n    return rho\n\ndef indices_for_overlap(N, ov, h):\n    \"\"\"\n    Compute iL and iR from desired overlap length ov, centered at the middle index.\n    Clamp to satisfy 1 <= iL < iR <= N-1.\n    \"\"\"\n    mid = N // 2\n    # convert overlap length to number of nodes across the overlapping region\n    ov_nodes = max(1, int(round(ov / h)))\n    half = ov_nodes // 2\n    iL = max(1, mid - half)\n    iR = min(N - 1, mid + (ov_nodes - half))\n    if iL >= iR:\n        # ensure at least one overlap\n        iL = max(1, iL - 1)\n    return iL, iR\n\ndef main():\n    tests = []\n    L = 1.0\n    # Test 1: N=400, k=20*pi, ov=0.05, eta=k\n    tests.append({\"N\": 400, \"k\": 20.0 * np.pi, \"ov\": 0.05, \"eta_factor\": 1.0})\n    # Test 2: N=400, k=6*pi, ov=0.10, eta=k\n    tests.append({\"N\": 400, \"k\": 6.0 * np.pi, \"ov\": 0.10, \"eta_factor\": 1.0})\n    # Test 3: N=400, k=20*pi, ov=h=L/N, eta=0.5*k\n    tests.append({\"N\": 400, \"k\": 20.0 * np.pi, \"ov\": None, \"eta_factor\": 0.5})  # ov to be set as h\n\n    results = []\n    for t in tests:\n        N = t[\"N\"]\n        k = t[\"k\"]\n        h = L / N\n        ov = t[\"ov\"] if t[\"ov\"] is not None else h\n        eta = t[\"eta_factor\"] * k\n        # Indices for overlap\n        iL, iR = indices_for_overlap(N, ov, h)\n        # Interface index for non-overlapping\n        iG = N // 2\n        # Spectral radii\n        rho_D = spectral_radius_dirichlet(L, N, k, iL, iR)\n        rho_R = spectral_radius_robin(L, N, k, iG, eta)\n        results.append(f\"{rho_D:.6f}\")\n        results.append(f\"{rho_R:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    main()\n```"
        },
        {
            "introduction": "The efficiency of a domain decomposition method is not just an algebraic property; it is deeply connected to the geometry of the partition and the physics of the underlying problem. This becomes especially clear for anisotropic problems, where properties like diffusion vary with direction. In this two-dimensional exercise, you will investigate how the shape of subdomains affects the conditioning of the non-overlapping Schur complement system for an anisotropic diffusion equation. You will learn to use a physically-motivated metric to find an optimal decomposition strategy that aligns with the problem's anisotropy, thereby minimizing the condition number of the interface problem and improving solver performance .",
            "id": "3428524",
            "problem": "Consider the anisotropic diffusion boundary value problem on the unit square domain $\\Omega = (0,1)^2$ with homogeneous Dirichlet boundary conditions, given by the partial differential equation $- \\nabla \\cdot (A \\nabla u) = f$ in $\\Omega$, and $u = 0$ on $\\partial \\Omega$, where $A \\in \\mathbb{R}^{2 \\times 2}$ is a constant, symmetric, positive definite anisotropy tensor. The goal is to study non-overlapping Schur complement methods under subdomain shape choices aligned with the anisotropy tensor $A$, while quantifying the effect of subdomain shape optimization on both the interface measure and the conditioning of the Schur complement.\n\nUse the following fundamental bases:\n- Discretize the operator $- \\nabla \\cdot (A \\nabla u)$ on a uniform grid using a second-order accurate finite difference scheme. For constant $A = \\begin{bmatrix} a_{11} & a_{12} \\\\ a_{12} & a_{22} \\end{bmatrix}$, the continuous operator equals $-a_{11} \\frac{\\partial^2 u}{\\partial x^2} - 2 a_{12} \\frac{\\partial^2 u}{\\partial x \\partial y} - a_{22} \\frac{\\partial^2 u}{\\partial y^2}$, and the discrete approximation employs the standard $5$-point stencil for the second derivatives and the standard central difference approximation for the mixed derivative on a $9$-point stencil.\n- Define a non-overlapping domain decomposition by splitting the interior grid into rectangular subdomains in an $(n_x, n_y)$ pattern, with $n_x$ cuts along the $x$-direction and $n_y$ cuts along the $y$-direction, so that the total number of subdomains equals $n_x \\cdot n_y$. Internal interfaces are the sets where subdomains touch. The Schur complement is formed on the internal interface degrees of freedom by eliminating interior degrees of freedom of each subdomain.\n- The conditioning is quantified by the condition number $\\kappa(S)$ of the Schur complement matrix $S$, defined as the ratio of its largest to smallest eigenvalue.\n\nTask specification:\n1. Construct the discrete stiffness matrix $K$ for the operator $- \\nabla \\cdot (A \\nabla u)$ on a uniform grid with $N = 26$ points in each spatial direction (including boundaries), which yields $N_{\\mathrm{int}} = 24$ interior degrees of freedom along each direction. Use grid spacing $h = 1/(N - 1)$.\n2. For a fixed number of subdomains $S$, enumerate all factorizations $(n_x, n_y)$ with $n_x \\cdot n_y = S$ such that $N_{\\mathrm{int}}$ is divisible by both $n_x$ and $n_y$ (so that subdomains have equal numbers of interior degrees of freedom).\n3. For each $(n_x, n_y)$, define the internal interface set $\\Gamma$ as the union of interior nodes lying on internal vertical boundaries located at indices $i \\in \\{N_{\\mathrm{int}}/n_x, 2 N_{\\mathrm{int}}/n_x, \\dots, (n_x - 1) N_{\\mathrm{int}}/n_x\\}$ and internal horizontal boundaries located at indices $j \\in \\{N_{\\mathrm{int}}/n_y, 2 N_{\\mathrm{int}}/n_y, \\dots, (n_y - 1) N_{\\mathrm{int}}/n_y\\}$. The interior set $I$ is the complement of $\\Gamma$ among interior degrees of freedom.\n4. Form the Schur complement $S = K_{\\Gamma \\Gamma} - K_{\\Gamma I} K_{I I}^{-1} K_{I \\Gamma}$ and compute its condition number $\\kappa(S)$ as the ratio of its largest to smallest eigenvalue, using floating-point arithmetic.\n5. Define the anisotropy-aligned weighted interface measure as\n$$\n|\\Gamma|_A = \\sqrt{e_x^\\top A e_x} \\cdot (n_x - 1) + \\sqrt{e_y^\\top A e_y} \\cdot (n_y - 1),\n$$\nwhere $e_x = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$ and $e_y = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$. This measure reflects the directional weighting of flux across interfaces induced by the anisotropy tensor. Optimize the subdomain shape by choosing $(n_x, n_y)$ that minimizes $|\\Gamma|_A$. In case of ties in $|\\Gamma|_A$, choose the $(n_x, n_y)$ with the smallest $\\kappa(S)$.\n\nTest suite and required outputs:\n- Use three test cases, each with $S = 6$ and $N = 26$:\n  1. $A_1 = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$.\n  2. $A_2 = \\begin{bmatrix} 10 & 0 \\\\ 0 & 1 \\end{bmatrix}$.\n  3. $A_3 = R(\\theta) \\begin{bmatrix} 20 & 0 \\\\ 0 & 1 \\end{bmatrix} R(\\theta)^\\top$ with $\\theta = \\pi/4$ and $R(\\theta)$ the rotation matrix $R(\\theta) = \\begin{bmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix}$.\n\nFor each test case, the program must:\n- Enumerate all valid $(n_x, n_y) \\in \\{(1,6), (2,3), (3,2), (6,1)\\}$.\n- Compute $|\\Gamma|_A$ for each candidate and select the optimal $(n_x, n_y)$ as specified.\n- Compute $\\kappa(S)$ for the optimal $(n_x, n_y)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[|\\Gamma|_{A_1}^\\star, \\kappa(S_{A_1}^\\star), |\\Gamma|_{A_2}^\\star, \\kappa(S_{A_2}^\\star), |\\Gamma|_{A_3}^\\star, \\kappa(S_{A_3}^\\star)],\n$$\nwhere $|\\Gamma|_{A_k}^\\star$ and $\\kappa(S_{A_k}^\\star)$ correspond to the optimized subdomain shape for test case $k$, expressed as floating-point numbers. No physical units are involved; angles are in radians.",
            "solution": "The user provides a valid, well-posed problem in numerical analysis. The task is to analyze the conditioning of a non-overlapping Schur complement method for an anisotropic diffusion problem, optimized for different subdomain geometries. I will proceed with a full solution.\n\nThe problem revolves around the numerical solution of the anisotropic diffusion equation on the unit square $\\Omega = (0,1)^2$:\n$$\n- \\nabla \\cdot (A \\nabla u) = f \\quad \\text{in } \\Omega, \\quad u = 0 \\quad \\text{on } \\partial \\Omega\n$$\nwhere $A = \\begin{bmatrix} a_{11} & a_{12} \\\\ a_{12} & a_{22} \\end{bmatrix}$ is a constant, symmetric, positive definite tensor.\n\n### 1. Finite Difference Discretization\nThe continuous operator is first expanded as:\n$$\n- \\nabla \\cdot (A \\nabla u) = -a_{11} \\frac{\\partial^2 u}{\\partial x^2} - 2 a_{12} \\frac{\\partial^2 u}{\\partial x \\partial y} - a_{22} \\frac{\\partial^2 u}{\\partial y^2}\n$$\nWe discretize this operator on a uniform grid with spacing $h = 1/(N-1)$, where $N=26$. The interior of the grid consists of $N_{\\mathrm{int}} \\times N_{\\mathrm{int}}$ points, where $N_{\\mathrm{int}} = N-2 = 24$. Let $u_{i,j}$ denote the solution at grid point $(ih, jh)$. We use second-order accurate central difference approximations:\n$$\n\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2} \\approx \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x \\partial y} \\approx \\frac{u_{i+1,j+1} - u_{i+1,j-1} - u_{i-1,j+1} + u_{i-1,j-1}}{4h^2}\n$$\nSubstituting these approximations into the PDE yields a 9-point stencil for the discrete operator at each interior node $(i,j)$. The equation for node $(i,j)$ becomes a weighted sum of its value and its eight neighbors. The global system of linear equations is $K\\mathbf{u} = \\mathbf{b}$, where $K$ is the stiffness matrix. The entries of $K$ are derived from the stencil. For a given interior node $(i,j)$, the stencil coefficients (scaled by $h^2$) are:\n-   Center $(i,j)$: $2(a_{11} + a_{22})$\n-   East/West $(i\\pm 1, j)$: $-a_{11}$\n-   North/South $(i, j\\pm 1)$: $-a_{22}$\n-   North-East/South-West $(i\\pm 1, j\\pm 1)$: $-a_{12}/2$\n-   North-West/South-East $(i\\mp 1, j\\pm 1)$: $+a_{12}/2$\n\nThe global stiffness matrix $K$ is assembled by applying this stencil to all $N_{\\mathrm{int}}^2 = 24^2 = 576$ interior grid points, using a row-major ordering of the unknowns.\n\n### 2. Domain Decomposition and Matrix Partitioning\nThe grid of $N_{\\mathrm{int}} \\times N_{\\mathrm{int}}$ interior nodes is decomposed into $S = n_x \\cdot n_y$ non-overlapping rectangular subdomains. For $S=6$ and $N_{\\mathrm{int}}=24$, the valid factorizations $(n_x, n_y)$ are $(1,6), (2,3), (3,2), (6,1)$, since $24$ is divisible by all these factors.\n\nThe set of all interior degrees of freedom (DoFs) is partitioned into two disjoint sets:\n-   The interface set $\\Gamma$: DoFs located on the boundaries between subdomains. A node $(i,j)$ (with $i,j \\in \\{1, \\dots, N_{\\mathrm{int}}\\}$) is in $\\Gamma$ if $i$ is a multiple of $N_{\\mathrm{int}}/n_x$ or $j$ is a multiple of $N_{\\mathrm{int}}/n_y$ (excluding the global boundaries $i=N_{\\mathrm{int}}$ and $j=N_{\\mathrm{int}}$ for vertical and horizontal interfaces, respectively).\n-   The interior set $I$: DoFs strictly inside the subdomains ($\\text{DoFs} \\setminus \\Gamma$).\n\nBy reordering the unknowns such that all interior DoFs come first, followed by all interface DoFs, the stiffness matrix $K$ can be written in block form:\n$$\nK = \\begin{bmatrix} K_{II} & K_{I\\Gamma} \\\\ K_{\\Gamma I} & K_{\\Gamma\\Gamma} \\end{bmatrix}\n$$\nHere, $K_{II}$ couples interior DoFs with each other, $K_{\\Gamma\\Gamma}$ couples interface DoFs with each other, and $K_{I\\Gamma}$ (with its transpose $K_{\\Gamma I}$) describes the coupling between interior and interface DoFs.\n\n### 3. Schur Complement and Condition Number\nThe Schur complement method eliminates the interior DoFs to obtain a smaller system solely for the interface unknowns. The Schur complement matrix $S$ is defined as:\n$$\nS = K_{\\Gamma\\Gamma} - K_{\\Gamma I} K_{II}^{-1} K_{I\\Gamma}\n$$\nThe matrix $K_{II}$ is block-diagonal, where each block corresponds to the interior DoFs of one subdomain, making its inversion computationally feasible. The conditioning of the preconditioned iterative solver for the full system is closely related to the conditioning of $S$. We quantify this by the spectral condition number, $\\kappa(S) = \\lambda_{\\max}(S) / \\lambda_{\\min}(S)$, where $\\lambda_{\\max}$ and $\\lambda_{\\min}$ are the largest and smallest eigenvalues of $S$, respectively. Since $K$ is symmetric positive definite, $S$ is also symmetric positive definite, and its eigenvalues are real and positive.\n\n### 4. Subdomain Shape Optimization\nThe goal is to choose the pair $(n_x, n_y)$ that results in the best-conditioned Schur complement system. The problem proposes a heuristic optimization based on the anisotropy-aligned weighted interface measure:\n$$\n|\\Gamma|_A = \\sqrt{e_x^\\top A e_x} \\cdot (n_x - 1) + \\sqrt{e_y^\\top A e_y} \\cdot (n_y - 1) = \\sqrt{a_{11}}(n_x - 1) + \\sqrt{a_{22}}(n_y - 1)\n$$\nThis measure penalizes decompositions that create long interfaces perpendicular to directions of strong diffusion. The optimal $(n_x, n_y)$ is the one that minimizes $|\\Gamma|_A$. If multiple pairs yield the same minimal $|\\Gamma|_A$, the tie is broken by selecting the pair that produces the smallest condition number $\\kappa(S)$.\n\n### 5. Application to Test Cases\nThis procedure is applied to the three test cases provided. For each case, we determine the optimal $(n_x, n_y)$ and compute the corresponding $|\\Gamma|_A^\\star$ and $\\kappa(S^\\star)$.\n\n**Test Case 1**: $A_1 = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$. Isotropic case.\n$|\\Gamma|_{A_1} = \\sqrt{1}(n_x-1) + \\sqrt{1}(n_y-1) = n_x+n_y-2$.\n- $(1,6): 1+6-2=5$\n- $(2,3): 2+3-2=3$\n- $(3,2): 3+2-2=3$\n- $(6,1): 6+1-2=5$\nThe minimum $|\\Gamma|_{A_1}$ is $3$, achieved by $(2,3)$ and $(3,2)$. Due to the isotropy of $A_1$ and symmetry of the grid, $\\kappa(S)$ will be identical for both configurations. We select $(2,3)$ and compute $\\kappa(S)$.\n\n**Test Case 2**: $A_2 = \\begin{bmatrix} 10 & 0 \\\\ 0 & 1 \\end{bmatrix}$. Axis-aligned anisotropy.\n$|\\Gamma|_{A_2} = \\sqrt{10}(n_x-1) + \\sqrt{1}(n_y-1)$.\n- $(1,6): \\sqrt{10}(0) + 1(5) = 5$\n- $(2,3): \\sqrt{10}(1) + 1(2) \\approx 5.16$\n- $(3,2): \\sqrt{10}(2) + 1(1) \\approx 7.32$\n- $(6,1): \\sqrt{10}(5) + 1(0) \\approx 15.81$\nThe minimum $|\\Gamma|_{A_2}$ is $5$, uniquely achieved by $(1,6)$. We compute $\\kappa(S)$ for this configuration.\n\n**Test Case 3**: $A_3 = R(\\pi/4) \\begin{bmatrix} 20 & 0 \\\\ 0 & 1 \\end{bmatrix} R(\\pi/4)^\\top = \\begin{bmatrix} 10.5 & 9.5 \\\\ 9.5 & 10.5 \\end{bmatrix}$. Rotated anisotropy.\n$|\\Gamma|_{A_3} = \\sqrt{10.5}(n_x-1) + \\sqrt{10.5}(n_y-1) = \\sqrt{10.5}(n_x+n_y-2)$.\n- $(1,6): \\sqrt{10.5}(5) \\approx 16.20$\n- $(2,3): \\sqrt{10.5}(3) \\approx 9.72$\n- $(3,2): \\sqrt{10.5}(3) \\approx 9.72$\n- $(6,1): \\sqrt{10.5}(5) \\approx 16.20$\nThe minimum $|\\Gamma|_{A_3}$ is $3\\sqrt{10.5}$, achieved by $(2,3)$ and $(3,2)$. Since $a_{11} = a_{22}$, the problem is symmetric with respect to exchanging the $x$ and $y$ axes, meaning $\\kappa(S)$ will be identical for $(2,3)$ and $(3,2)$. We select $(2,3)$ and compute $\\kappa(S)$.\n\nThe implementation will now perform these calculations numerically.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef get_stiffness_matrix(N_int, A):\n    \"\"\"\n    Constructs the finite difference stiffness matrix K for the operator -div(A grad(u)).\n    The scaling factor 1/h^2 is omitted as it does not affect the condition number.\n    \"\"\"\n    a11, a12, a22 = A[0, 0], A[0, 1], A[1, 1]\n    \n    total_dofs = N_int * N_int\n    K = lil_matrix((total_dofs, total_dofs))\n\n    # Stencil weights\n    w_c = 2 * (a11 + a22)\n    w_ew = -a11\n    w_ns = -a22\n    w_ne_sw = -a12 / 2.0\n    w_nw_se = a12 / 2.0\n\n    for j in range(1, N_int + 1):  # 1-based grid indexing\n        for i in range(1, N_int + 1):\n            k = (j - 1) * N_int + (i - 1)  # 0-based matrix index\n\n            # Center\n            K[k, k] = w_c\n            \n            # Neighbors\n            # East\n            if i < N_int: K[k, k + 1] = w_ew\n            # West\n            if i > 1: K[k, k - 1] = w_ew\n            # North\n            if j < N_int: K[k, k + N_int] = w_ns\n            # South\n            if j > 1: K[k, k - N_int] = w_ns\n\n            # Mixed-derivative neighbors\n            # North-East\n            if i < N_int and j < N_int: K[k, k + N_int + 1] = w_ne_sw\n            # South-West\n            if i > 1 and j > 1: K[k, k - N_int - 1] = w_ne_sw\n            # North-West\n            if i > 1 and j < N_int: K[k, k + N_int - 1] = w_nw_se\n            # South-East\n            if i < N_int and j > 1: K[k, k - N_int + 1] = w_nw_se\n\n    return K.tocsc()\n\ndef get_schur_complement_kappa(N_int, K, nx, ny):\n    \"\"\"\n    Computes the condition number of the Schur complement matrix.\n    \"\"\"\n    total_dofs = N_int * N_int\n    is_interface = np.zeros(total_dofs, dtype=bool)\n\n    # Identify interface nodes\n    vert_cuts = [k * (N_int // nx) for k in range(1, nx)]\n    horiz_cuts = [k * (N_int // ny) for k in range(1, ny)]\n\n    for j_1based in range(1, N_int + 1):\n        for i_1based in range(1, N_int + 1):\n            if i_1based in vert_cuts or j_1based in horiz_cuts:\n                k = (j_1based - 1) * N_int + (i_1based - 1)\n                is_interface[k] = True\n    \n    interior_indices = np.where(~is_interface)[0]\n    gamma_indices = np.where(is_interface)[0]\n\n    K_II = K[interior_indices, :][:, interior_indices]\n    K_IG = K[interior_indices, :][:, gamma_indices]\n    K_GI = K[gamma_indices, :][:, interior_indices]\n    K_GG = K[gamma_indices, :][:, gamma_indices]\n\n    # Form Schur complement: S = K_GG - K_GI * inv(K_II) * K_IG\n    # To compute this, we solve K_II * X = K_IG for X, then S = K_GG - K_GI * X\n    if K_IG.shape[1] == 0: # No interface\n        return 1.0\n\n    X = spsolve(K_II, K_IG)\n    S_sparse = K_GG - K_GI @ X\n    S = S_sparse if isinstance(S_sparse, np.ndarray) else S_sparse.toarray()\n\n    # Compute condition number\n    eigvals = np.linalg.eigvalsh(S)\n    \n    # Filter out near-zero eigenvalues that might result from floating point inaccuracies\n    # for what should be a positive-definite matrix.\n    tol = 1e-12\n    positive_eigvals = eigvals[eigvals > tol]\n    if len(positive_eigvals) == 0:\n        return np.inf\n\n    return positive_eigvals.max() / positive_eigvals.min()\n\n\ndef solve():\n    N = 26\n    N_int = N - 2\n    \n    # Test cases parameters\n    theta = np.pi / 4\n    R = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])\n    D3 = np.array([[20.0, 0.0], [0.0, 1.0]])\n    A1 = np.array([[1.0, 0.0], [0.0, 1.0]])\n    A2 = np.array([[10.0, 0.0], [0.0, 1.0]])\n    A3 = R @ D3 @ R.T\n\n    test_cases = [A1, A2, A3]\n    candidate_decompositions = [(1, 6), (2, 3), (3, 2), (6, 1)]\n    \n    final_results = []\n\n    for A in test_cases:\n        K = get_stiffness_matrix(N_int, A)\n        \n        # Calculate interface measure for all candidates\n        measures = {}\n        for nx, ny in candidate_decompositions:\n            a11, a22 = A[0, 0], A[1, 1]\n            measure = np.sqrt(a11) * (nx - 1) + np.sqrt(a22) * (ny - 1)\n            measures[(nx, ny)] = measure\n        \n        # Find minimum measure and candidates that achieve it\n        min_measure = min(measures.values())\n        tied_candidates = [k for k, v in measures.items() if np.isclose(v, min_measure)]\n\n        best_nx, best_ny = None, None\n        min_kappa = float('inf')\n\n        # If there's a tie in measure, find best kappa among tied candidates\n        if len(tied_candidates) > 1:\n            for nx, ny in tied_candidates:\n                kappa = get_schur_complement_kappa(N_int, K, nx, ny)\n                if kappa < min_kappa:\n                    min_kappa = kappa\n                    best_nx, best_ny = nx, ny\n        else:\n            best_nx, best_ny = tied_candidates[0]\n            min_kappa = get_schur_complement_kappa(N_int, K, best_nx, best_ny)\n        \n        final_results.append(min_measure)\n        final_results.append(min_kappa)\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}