{
    "hands_on_practices": [
        {
            "introduction": "这个练习将引导您完成一个加性Schwarz（Additive Schwarz, AS）预处理的共轭梯度法（CG）的单步精确计算。通过在一个小规模的一维泊松问题上进行操作，您可以清晰地看到限制（restriction）与延拓（prolongation）算子、子区域求解以及修正量相加这些核心机制是如何协同工作的。这对于初学者建立对重叠型区域分解法基本原理的直观理解至关重要。",
            "id": "3382438",
            "problem": "考虑一个对称正定线性系统 $A x = b$，该系统来自于在均匀网格上对具有齐次狄利克雷边界条件的泊松方程进行一维（$1$D）有限元（FE）离散化。刚度矩阵 $A \\in \\mathbb{R}^{4 \\times 4}$ 由下式给出\n$$\nA \\;=\\; \\begin{pmatrix}\n2  -1  0  0 \\\\\n-1  2  -1  0 \\\\\n0  -1  2  -1 \\\\\n0  0  -1  2\n\\end{pmatrix}.\n$$\n我们考虑一个具有两个重叠子区域的加性 Schwarz (AS) 预条件子。限制矩阵 $R_{1} \\in \\mathbb{R}^{3 \\times 4}$ 和 $R_{2} \\in \\mathbb{R}^{3 \\times 4}$ 分别通过选择子区域自由度 $\\{1,2,3\\}$ 和 $\\{2,3,4\\}$ 来定义：\n$$\nR_{1} \\;=\\; \\begin{pmatrix}\n1  0  0  0\\\\\n0  1  0  0\\\\\n0  0  1  0\n\\end{pmatrix},\n\\qquad\nR_{2} \\;=\\; \\begin{pmatrix}\n0  1  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\n\\end{pmatrix}.\n$$\n局部子区域算子为 $A_{1} \\;=\\; R_{1} A R_{1}^{\\top}$ 和 $A_{2} \\;=\\; R_{2} A R_{2}^{\\top}$，加性 Schwarz 预条件子为\n$$\nM^{-1} \\;=\\; R_{1}^{\\top} A_{1}^{-1} R_{1} \\;+\\; R_{2}^{\\top} A_{2}^{-1} R_{2}.\n$$\n使用左预处理共轭梯度（CG）方法，初始值设为 $x^{(0)} = 0$，残差为 $r^{(0)} = b - A x^{(0)} = b$，预处理残差为 $z^{(0)} = M^{-1} r^{(0)}$，搜索方向为 $p^{(0)} = z^{(0)}$，步长为\n$$\n\\alpha_{0} \\;=\\; \\frac{(r^{(0)}, z^{(0)})}{(p^{(0)}, A p^{(0)})},\n$$\n其中 $(\\cdot,\\cdot)$ 是 $\\mathbb{R}^{4}$ 上的标准欧几里得内积。取右端项为\n$$\nb \\;=\\; \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}.\n$$\n计算此次加性 Schwarz 预处理的 CG 迭代中第一步的步长 $\\alpha_{0}$ 的精确值。答案应为一个精确的实数（不要四舍五入）。",
            "solution": "该问题经验证是自洽的、有科学依据且适定的。这是数值线性代数和区域分解方法领域的一个标准计算。我将开始解题。\n\n目标是计算预处理共轭梯度（CG）方法的第一步步长 $\\alpha_{0}$。$\\alpha_{0}$ 的计算公式如下：\n$$\n\\alpha_{0} \\;=\\; \\frac{(r^{(0)}, z^{(0)})}{(p^{(0)}, A p^{(0)})}\n$$\n其中 $(\\cdot,\\cdot)$ 表示标准欧几里得内积。这可以用向量转置写为：\n$$\n\\alpha_{0} \\;=\\; \\frac{(r^{(0)})^{\\top} z^{(0)}}{(p^{(0)})^{\\top} (A p^{(0)})}\n$$\n我们将逐步计算此表达式中的每一项。\n\n首先，我们确定初始残差 $r^{(0)}$。给定初始猜测 $x^{(0)} = 0$ 和右端向量 $b$ 为 $\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$，我们有：\n$$\nr^{(0)} \\;=\\; b - A x^{(0)} \\;=\\; b - A \\cdot 0 \\;=\\; b \\;=\\; \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n\n接下来，我们计算预处理残差 $z^{(0)} = M^{-1} r^{(0)}$。这需要构造加性 Schwarz 预条件子 $M^{-1}$。\n预条件子定义为：\n$$\nM^{-1} \\;=\\; R_{1}^{\\top} A_{1}^{-1} R_{1} \\;+\\; R_{2}^{\\top} A_{2}^{-1} R_{2}\n$$\n其中 $A_{1} \\;=\\; R_{1} A R_{1}^{\\top}$ 和 $A_{2} \\;=\\; R_{2} A R_{2}^{\\top}$。\n\n让我们计算子区域刚度矩阵 $A_{1}$ 和 $A_{2}$。\n矩阵 $A$ 由下式给出：\n$$\nA \\;=\\; \\begin{pmatrix}\n2  -1  0  0 \\\\\n-1  2  -1  0 \\\\\n0  -1  2  -1 \\\\\n0  0  -1  2\n\\end{pmatrix}\n$$\n限制矩阵为：\n$$\nR_{1} \\;=\\; \\begin{pmatrix}\n1  0  0  0\\\\\n0  1  0  0\\\\\n0  0  1  0\n\\end{pmatrix},\n\\qquad\nR_{2} \\;=\\; \\begin{pmatrix}\n0  1  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\n\\end{pmatrix}\n$$\n操作 $R_{1} A R_{1}^{\\top}$ 提取了 $A$ 中对应于前三个索引的主子矩阵。\n$$\nA_1 \\;=\\; R_{1} A R_{1}^{\\top} \\;=\\; \\begin{pmatrix}\n2  -1  0 \\\\\n-1  2  -1 \\\\\n0  -1  2\n\\end{pmatrix}\n$$\n类似地，操作 $R_{2} A R_{2}^{\\top}$ 提取了 $A$ 中对应于后三个索引（索引 $2$, $3$, $4$）的主子矩阵。\n$$\nA_2 \\;=\\; R_{2} A R_{2}^{\\top} \\;=\\; \\begin{pmatrix}\n2  -1  0 \\\\\n-1  2  -1 \\\\\n0  -1  2\n\\end{pmatrix}\n$$\n我们观察到 $A_{1} = A_{2}$。我们将这个 $3 \\times 3$ 矩阵记为 $A_{sub}$。我们需要计算它的逆矩阵 $A_{sub}^{-1}$。\n$A_{sub}$ 的行列式为：\n$$\n\\det(A_{sub}) \\;=\\; 2(2 \\cdot 2 - (-1)(-1)) - (-1)(-1 \\cdot 2 - (-1) \\cdot 0) \\;=\\; 2(3) - 2 \\;=\\; 4\n$$\n逆矩阵由 $A_{sub}^{-1} = \\frac{1}{\\det(A_{sub})} \\text{adj}(A_{sub})$ 给出。伴随矩阵是代数余子式矩阵的转置。\n$A_{sub}$ 的代数余子式矩阵 $C$ 为：\n$$\nC \\;=\\; \\begin{pmatrix}\n(4-1)  -(-2-0)  (1-0) \\\\\n-(-2-0)  (4-0)  -(-2-0) \\\\\n(1-0)  -(-2-0)  (4-1)\n\\end{pmatrix} \\;=\\; \\begin{pmatrix}\n3  2  1 \\\\\n2  4  2 \\\\\n1  2  3\n\\end{pmatrix}\n$$\n由于 $C$ 是对称的，$\\text{adj}(A_{sub}) = C^{\\top} = C$。因此：\n$$\nA_{1}^{-1} \\;=\\; A_{2}^{-1} \\;=\\; A_{sub}^{-1} \\;=\\; \\frac{1}{4} \\begin{pmatrix}\n3  2  1 \\\\\n2  4  2 \\\\\n1  2  3\n\\end{pmatrix}\n$$\n现在我们组装预条件子 $M^{-1}$。项 $R_{1}^{\\top} A_{1}^{-1} R_{1}$ 将 $A_{1}^{-1}$ 嵌入到一个 $4 \\times 4$ 零矩阵的左上角 $3 \\times 3$ 分块中。项 $R_{2}^{\\top} A_{2}^{-1} R_{2}$ 将 $A_{2}^{-1}$ 嵌入到一个 $4 \\times 4$ 零矩阵的右下角 $3 \\times 3$ 分块（索引为 $2,3,4$）中。\n$$\nR_{1}^{\\top} A_{1}^{-1} R_{1} \\;=\\; \\frac{1}{4} \\begin{pmatrix}\n3  2  1  0 \\\\\n2  4  2  0 \\\\\n1  2  3  0 \\\\\n0  0  0  0\n\\end{pmatrix}\n$$\n$$\nR_{2}^{\\top} A_{2}^{-1} R_{2} \\;=\\; \\frac{1}{4} \\begin{pmatrix}\n0  0  0  0 \\\\\n0  3  2  1 \\\\\n0  2  4  2 \\\\\n0  1  2  3\n\\end{pmatrix}\n$$\n将这两个矩阵相加得到 $M^{-1}$：\n$$\nM^{-1} \\;=\\; \\frac{1}{4} \\begin{pmatrix}\n3  2  1  0 \\\\\n2  4+3  2+2  1 \\\\\n1  2+2  3+4  2 \\\\\n0  1  2  3\n\\end{pmatrix} \\;=\\; \\frac{1}{4} \\begin{pmatrix}\n3  2  1  0 \\\\\n2  7  4  1 \\\\\n1  4  7  2 \\\\\n0  1  2  3\n\\end{pmatrix}\n$$\n现在我们可以计算 $z^{(0)}$：\n$$\nz^{(0)} \\;=\\; M^{-1} r^{(0)} \\;=\\; \\frac{1}{4} \\begin{pmatrix}\n3  2  1  0 \\\\\n2  7  4  1 \\\\\n1  4  7  2 \\\\\n0  1  2  3\n\\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix} \\;=\\; \\frac{1}{4} \\begin{pmatrix} 3 \\\\ 2 \\\\ 1 \\\\ 0 \\end{pmatrix}\n$$\n我们现在可以计算 $\\alpha_{0}$ 的分子：\n$$\n(r^{(0)})^{\\top} z^{(0)} \\;=\\; \\begin{pmatrix} 1  0  0  0 \\end{pmatrix} \\left( \\frac{1}{4} \\begin{pmatrix} 3 \\\\ 2 \\\\ 1 \\\\ 0 \\end{pmatrix} \\right) \\;=\\; \\frac{3}{4}\n$$\n接下来，我们计算分母。初始搜索方向为 $p^{(0)} = z^{(0)}$。因此，我们需要计算 $(p^{(0)})^{\\top} (A p^{(0)})$。\n首先，我们计算乘积 $A p^{(0)}$：\n$$\nA p^{(0)} \\;=\\; A z^{(0)} \\;=\\; \\begin{pmatrix}\n2  -1  0  0 \\\\\n-1  2  -1  0 \\\\\n0  -1  2  -1 \\\\\n0  0  -1  2\n\\end{pmatrix} \\left( \\frac{1}{4} \\begin{pmatrix} 3 \\\\ 2 \\\\ 1 \\\\ 0 \\end{pmatrix} \\right) \\;=\\; \\frac{1}{4} \\begin{pmatrix}\n2(3) - 1(2) \\\\\n-1(3) + 2(2) - 1(1) \\\\\n-1(2) + 2(1) \\\\\n-1(1)\n\\end{pmatrix} \\;=\\; \\frac{1}{4} \\begin{pmatrix}\n4 \\\\ 0 \\\\ 0 \\\\ -1\n\\end{pmatrix}\n$$\n现在，我们计算分母的内积：\n$$\n(p^{(0)})^{\\top} (A p^{(0)}) \\;=\\; (z^{(0)})^{\\top} (A z^{(0)}) \\;=\\; \\left( \\frac{1}{4} \\begin{pmatrix} 3 \\\\ 2 \\\\ 1 \\\\ 0 \\end{pmatrix} \\right)^{\\top} \\left( \\frac{1}{4} \\begin{pmatrix} 4 \\\\ 0 \\\\ 0 \\\\ -1 \\end{pmatrix} \\right)\n$$\n$$\n(p^{(0)})^{\\top} (A p^{(0)}) \\;=\\; \\frac{1}{16} \\begin{pmatrix} 3  2  1  0 \\end{pmatrix} \\begin{pmatrix} 4 \\\\ 0 \\\\ 0 \\\\ -1 \\end{pmatrix} \\;=\\; \\frac{1}{16} (3 \\cdot 4 + 2 \\cdot 0 + 1 \\cdot 0 + 0 \\cdot (-1)) \\;=\\; \\frac{12}{16} \\;=\\; \\frac{3}{4}\n$$\n最后，我们通过计算分子和分母的比值来计算 $\\alpha_{0}$：\n$$\n\\alpha_{0} \\;=\\; \\frac{(r^{(0)})^{\\top} z^{(0)}}{(p^{(0)})^{\\top} (A p^{(0)})} \\;=\\; \\frac{3/4}{3/4} \\;=\\; 1\n$$\n第一步步长的精确值为 $1$。",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "仅含局部求解的一级方法在处理大规模问题时会遇到可扩展性瓶颈，其收敛速度会随问题规模增大而减慢。本练习将通过引入一个“粗糙空间”校正来解决这一问题，指导您编写程序构建一个两级加性Schwarz预处理器。您将亲手实现并数值验证区域分解理论中的一个基石性结论：一个设计良好的两级方法可以使预处理后系统的条件数不依赖于网格尺寸，从而保证算法的可扩展性。",
            "id": "3382437",
            "problem": "考虑单位区间上具有齐次狄利克雷边界条件的一维泊松方程，其强形式由 $-u''(x)=f(x)$ 给出，其中 $x\\in(0,1)$ 且 $u(0)=u(1)=0$。使用有限差分法 (FDM) 在 $N$ 个内点上对问题进行离散化，点间距为均匀的 $h=1/(N+1)$，从而获得一个对称正定 (SPD) 线性系统 $A u = b$，其中 $A\\in\\mathbb{R}^{N\\times N}$ 是标准的三对角刚度矩阵，其元素为 $A_{ii}=\\frac{2}{h^2}$ 和 $A_{i,i\\pm 1}=-\\frac{1}{h^2}$。\n\n将 $N$ 个自由度划分为 $m$ 个构成一维链的连续子区域，并为每个子区域定义一个具有 $p$ 个细网格点重叠量的重叠局部索引集。对每个子区域，设 $R_i\\in\\mathbb{R}^{n_i\\times N}$ 为限制算子，用于提取与重叠子区域索引集对应的局部未知量，并定义局部 SPD 矩阵 $A_i=R_i A R_i^T$。构造一个形式如下的两层加性 Schwarz 预条件子 $M^{-1}$：\n$$\nM^{-1} \\;=\\; \\sum_{i=1}^m R_i^T A_i^{-1} R_i \\;+\\; R_0^T A_0^{-1} R_0,\n$$\n其中 $R_0\\in\\mathbb{R}^{(m-1)\\times N}$ 是一个粗糙限制算子，它由一个基于一维子区域链上的分段线性基向量的代数粗糙空间构建。具体来说，定义粗糙网格点为 $x_j=jH$，$j=0,1,\\dots,m$，$H=1/m$，并形成 $(m-1)$ 个支集在 $[x_{j-1},x_{j+1}]$ 上的帽子函数 $\\{\\phi_j\\}_{j=1}^{m-1}$，每个函数满足 $\\phi_j(x_j)=1$ 和 $\\phi_j(x_{j\\pm 1})=0$，且在 $[x_{j-1},x_j]$ 和 $[x_j,x_{j+1}]$上呈线性变化。在细网格点 $x_k=(k+1)h$（$k=0,\\dots,N-1$）上计算这些基函数的值以组装 $R_0$，使得 $(R_0)_{j,k}=\\phi_j(x_k)$。组装粗糙矩阵 $A_0=R_0 A R_0^T$。\n\n从上述定义以及 SPD 算子和加性 Schwarz 方法的性质出发，推导出一个编程过程来完成以下任务：\n- 从 FDM 离散化构建 $A$。\n- 将自由度划分为 $m$ 个大小均衡的连续子区域，并构建具有重叠量 $p$ 的重叠索引集。\n- 组装局部限制算子 $R_i$ 和局部矩阵 $A_i$。\n- 使用基于子区域端点给出的粗糙网格上的分段线性基向量来构建代数粗糙限制算子 $R_0$，并组装 $A_0$。\n- 构建两层加性 Schwarz 预条件子 $M^{-1}$ 的显式稠密矩阵表示，并计算 $M^{-1}A$ 的谱。\n- 计算谱条件数 $\\kappa(M^{-1}A)=\\lambda_{\\max}/\\lambda_{\\min}$，其中 $\\lambda_{\\max}$ 和 $\\lambda_{\\min}$ 表示 $M^{-1}A$ 的最大和最小特征值。\n\n使用以下参数值测试套件 $(N,m,p)$，其中 $N$ 是内点数，$m$ 是子区域数，$p$ 是细网格点的重叠量：\n1. $(N,m,p)=(120,6,1)$\n2. $(N,m,p)=(240,6,1)$\n3. $(N,m,p)=(480,6,1)$\n4. $(N,m,p)=(96,12,2)\n\n对于每个测试用例，计算 $\\kappa(M^{-1}A)$ 并将结果四舍五入到六位小数。输出不需要物理单位。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[3.142000,3.142000,3.142000,3.142000]\"）。",
            "solution": "该问题为构造一维泊松方程的两层加性 Schwarz 预条件子并分析其性能提供了一套完整且适定的指令。任务是根据这些指令推导出一个编程过程，并为一组给定的参数计算预处理矩阵的谱条件数。该过程如下。\n\n**步骤 1：有限差分法离散化**\n\n在区间 $(0,1)$ 上具有齐次狄利克雷边界条件 $u(0)=u(1)=0$ 的一维泊松方程 $-u''(x)=f(x)$ 使用中心有限差分格式进行离散化。区域 $(0,1)$ 被划分为 $N+1$ 个宽度为 $h = 1/(N+1)$ 的相等子区间。网格点为 $x_k = (k+1)h$，$k=0, 1, \\dots, N-1$。点 $x_k$ 处的二阶导数近似为 $u''(x_k) \\approx \\frac{u(x_{k-1}) - 2u(x_k) + u(x_{k+1})}{h^2}$。将此代入泊松方程，得到一个线性方程组 $Au = b$，其中 $u \\in \\mathbb{R}^N$ 是未知量 $u_k \\approx u(x_k)$ 的向量，$A$ 是 $N \\times N$ 的刚度矩阵。矩阵 $A$ 是对称、正定且三对角的，其元素由下式给出：\n$$\nA_{ij} = \\frac{1}{h^2} \\begin{cases}\n2,  &\\text{if } i=j \\\\\n-1, &\\text{if } |i-j|=1 \\\\\n0,  &\\text{otherwise}\n\\end{cases}\n$$\n此矩阵是为给定数量的内点 $N$ 构建的。\n\n**步骤 2：子区域划分与局部算子**\n\n$N$ 个全局索引的集合 $\\{0, 1, \\dots, N-1\\}$ 被划分为 $m$ 个大小均衡、连续且不重叠的基础子区域。设子区域 $i$ 的基础索引集为 $I_i^{\\text{base}}$，$i=1, \\dots, m$。然后为每个子区域创建一个重叠索引集 $I_i$，方法是将 $I_i^{\\text{base}}$ 向每个方向扩展 $p$ 个网格点，并保持在全局索引边界 $[0, N-1]$ 内。\n\n对于每个子区域 $i$，定义一个限制算子 $R_i \\in \\mathbb{R}^{n_i \\times N}$，其中 $n_i$ 是重叠集 $I_i$ 中的索引数量。$R_i$ 将全局未知量向量映射到子区域 $i$ 的局部向量。在实现中，这对应于选择行和列。每个子区域的局部刚度矩阵 $A_i$ 是一个通过 Galerkin 投影 $A_i = R_i A R_i^T$ 获得的小型、稠密且 SPD 的矩阵。这等效于提取 $A$ 中与 $I_i$ 中的索引对应的子矩阵。\n\n**步骤 3：粗糙空间构建**\n\n引入粗糙空间来处理信息的全局传播，这对于预条件子的可扩展性至关重要。粗糙空间是代数定义的。在 $[0,1]$ 上定义一个粗糙网格，包含 $m+1$ 个点 $x_j^{\\text{coarse}} = jH$，$j=0, 1, \\dots, m$，其中 $H=1/m$。粗糙空间由 $m-1$ 个分段线性的“帽子”基函数 $\\{\\phi_j\\}_{j=1}^{m-1}$ 张成。每个函数 $\\phi_j$ 的支集在粗糙区间 $[x_{j-1}^{\\text{coarse}}, x_{j+1}^{\\text{coarse}}]$ 上，并满足 $\\phi_j(x_j^{\\text{coarse}})=1$ 和 $\\phi_j(x_{k}^{\\text{coarse}})=0$（对于 $k \\neq j$）。\n\n通过在细网格点 $x_k = (k+1)h$ 上计算这些基函数的值来组装粗糙限制算子 $R_0 \\in \\mathbb{R}^{(m-1) \\times N}$。$R_0$ 的元素由 $(R_0)_{j-1, k} = \\phi_j(x_k)$ 给出，$j=1, \\dots, m-1$ 且 $k=0, \\dots, N-1$。具体来说，对于一个细网格点 $x_k$：\n$$\n\\phi_j(x_k) = \\begin{cases}\n(x_k - x_{j-1}^{\\text{coarse}})/H,  &\\text{if } x_{j-1}^{\\text{coarse}} \\le x_k \\le x_j^{\\text{coarse}} \\\\\n(x_{j+1}^{\\text{coarse}} - x_k)/H,  &\\text{if } x_j^{\\text{coarse}} < x_k \\le x_{j+1}^{\\text{coarse}} \\\\\n0,  &\\text{otherwise}\n\\end{cases}\n$$\n然后使用 Galerkin 投影 $A_0 = R_0 A R_0^T$ 形成粗糙矩阵 $A_0 \\in \\mathbb{R}^{(m-1) \\times (m-1)}$。与局部矩阵一样，$A_0$ 也是 SPD 的。\n\n**步骤 4：加性 Schwarz 预条件子组装**\n\n两层加性 Schwarz 预条件子 $M^{-1}$ 是通过对局部子问题和粗糙问题的贡献求和来构造的。公式为：\n$$\nM^{-1} \\;=\\; \\sum_{i=1}^m R_i^T A_i^{-1} R_i \\;+\\; R_0^T A_0^{-1} R_0\n$$\n每一项 $R_i^T A_i^{-1} R_i$ 表示在局部子区域上求解，然后通过延拓（扩展）回到全局网格。这是一个 $N \\times N$ 的矩阵，仅在与索引 $I_i$ 对应的块中非零。项 $R_0^T A_0^{-1} R_0$ 表示粗糙网格校正。在计算上，这涉及对小型矩阵 $A_i$ 和 $A_0$ 求逆，然后通过将所有这些分量矩阵相加来组装完整的 $N \\times N$ 稠密矩阵 $M^{-1}$。\n\n**步骤 5：谱条件数计算**\n\n预条件子的有效性通过预处理矩阵 $M^{-1}A$ 的谱条件数来评估。$M^{-1}A$ 的特征值是实数且为正。条件数定义为最大特征值与最小特征值之比：\n$$\n\\kappa(M^{-1}A) = \\frac{\\lambda_{\\max}(M^{-1}A)}{\\lambda_{\\min}(M^{-1}A)}\n$$\n较小的条件数（理想情况下接近 1 且与问题规模 $N$ 无关）表明预条件子更有效，能使共轭梯度法等迭代求解器更快收敛。为了计算它，我们首先形成稠密矩阵乘积 $P = M^{-1}A$，然后使用数值库找到其特征值，最后计算这些特征值实部的最大值与最小值之比。",
            "answer": "```python\nimport numpy as np\n\ndef compute_kappa(N, m, p):\n    \"\"\"\n    Computes the condition number of the two-level additive Schwarz preconditioned system.\n\n    Args:\n        N (int): Number of interior grid points.\n        m (int): Number of subdomains.\n        p (int): Overlap size in grid points.\n\n    Returns:\n        float: The spectral condition number kappa(M^{-1}A).\n    \"\"\"\n    # Step 1: Construct the global stiffness matrix A\n    h = 1.0 / (N + 1)\n    d = np.full(N, 2.0 / h**2)\n    e = np.full(N - 1, -1.0 / h**2)\n    A = np.diag(d) + np.diag(e, k=1) + np.diag(e, k=-1)\n\n    # Initialize the preconditioner M_inv\n    M_inv = np.zeros((N, N))\n\n    # Step 2: Define subdomains and assemble local contributions to M_inv\n    # Partition the N degrees of freedom into m balanced, contiguous subdomains\n    base_indices = np.array_split(np.arange(N), m)\n    \n    for i in range(m):\n        # Create overlapping index set\n        start = base_indices[i][0]\n        end = base_indices[i][-1]\n        \n        # Extend by p points on each side, respecting boundaries\n        overlap_start = max(0, start - p)\n        overlap_end = min(N - 1, end + p)\n        \n        local_indices = np.arange(overlap_start, overlap_end + 1)\n        \n        # Extract local matrix A_i = R_i A R_i^T\n        A_i = A[np.ix_(local_indices, local_indices)]\n        \n        # Compute A_i^{-1}\n        A_i_inv = np.linalg.inv(A_i)\n        \n        # Add local contribution to M_inv: R_i^T A_i^{-1} R_i\n        M_inv[np.ix_(local_indices, local_indices)] += A_i_inv\n\n    # Step 3: Construct the coarse space and its contribution\n    if m > 1:\n        # Define fine and coarse grids\n        fine_grid_x = np.linspace(h, 1.0 - h, N)\n        coarse_grid_x = np.linspace(0, 1.0, m + 1)\n        H = 1.0 / m\n        \n        # Assemble coarse restriction operator R_0\n        num_coarse_basis = m - 1\n        R_0 = np.zeros((num_coarse_basis, N))\n        \n        for j in range(1, m):  # Loop over hat functions phi_j, j=1,...,m-1\n            # Support of phi_j is [x_{j-1}, x_{j+1}]\n            x_j_minus_1 = coarse_grid_x[j-1]\n            x_j = coarse_grid_x[j]\n            x_j_plus_1 = coarse_grid_x[j+1]\n            \n            for k in range(N): # Loop over fine grid points x_k\n                x_k = fine_grid_x[k]\n                if x_j_minus_1 <= x_k <= x_j:\n                    R_0[j-1, k] = (x_k - x_j_minus_1) / H\n                elif x_j < x_k <= x_j_plus_1:\n                    R_0[j-1, k] = (x_j_plus_1 - x_k) / H\n        \n        # Assemble coarse matrix A_0 = R_0 A R_0^T\n        A_0 = R_0 @ A @ R_0.T\n        \n        # Compute A_0^{-1}\n        A_0_inv = np.linalg.inv(A_0)\n        \n        # Add coarse contribution to M_inv: R_0^T A_0^{-1} R_0\n        coarse_contribution = R_0.T @ A_0_inv @ R_0\n        M_inv += coarse_contribution\n\n    # Step 4: Compute the preconditioned matrix and its eigenvalues\n    preconditioned_matrix = M_inv @ A\n    eigenvalues = np.linalg.eigvals(preconditioned_matrix)\n    \n    # Eigenvalues should be real and positive; take real part to handle numerical noise\n    real_eigenvalues = eigenvalues.real\n    \n    # Step 5: Compute the condition number\n    lambda_max = np.max(real_eigenvalues)\n    lambda_min = np.min(real_eigenvalues)\n    \n    kappa = lambda_max / lambda_min\n    return kappa\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        (120, 6, 1),\n        (240, 6, 1),\n        (480, 6, 1),\n        (96, 12, 2)\n    ]\n\n    results = []\n    for N, m, p in test_cases:\n        kappa = compute_kappa(N, m, p)\n        # Round the result to six decimal places\n        results.append(f\"{kappa:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际工程应用中，不同子区域可能需要使用互不匹配的网格进行离散。本练习将带您探索Mortar方法，这是一种在非重叠子区域之间处理非协调（non-conforming）界面的强大技术。您将通过$L^2$投影来构建连接不同网格的耦合约束，并求解由此产生的KKT（Karush-Kuhn-Tucker）鞍点问题，这是理解FETI等高级方法的关键一步。",
            "id": "3382444",
            "problem": "考虑矩形域 $\\Omega = [-1,1] \\times [0,1]$ 上的标量扩散问题，其中有一条垂直界面 $\\Gamma = \\{0\\} \\times [0,1]$，将 $\\Omega$ 分割成两个子域：$\\Omega_{1} = [-1,0] \\times [0,1]$ 和 $\\Omega_{2} = [0,1] \\times [0,1]$。扩散系数是分段常数，在 $\\Omega_{1}$ 中 $\\alpha_{1} = 2$，在 $\\Omega_{2}$ 中 $\\alpha_{2} = 1$。每个子域中的控制方程是 $-\\nabla \\cdot (\\alpha \\nabla u) = 0$ 的弱形式，通过静态凝聚消除内部自由度后，子域界面问题简化为在 $\\Gamma$ 的迹空间上定义的对称正定 (SPD) 线性系统。\n\n采用砂浆域分解法，在 $\\Gamma$ 上使用不匹配的网格：\n- 在主侧（$\\Omega_{1}$ 的迹），使用一个连续的分片线性迹空间，节点为 $y = 0,\\, 0.5,\\, 1$，对应的节点基函数为 $\\{\\phi_{1}, \\phi_{2}, \\phi_{3}\\}$。\n- 在从侧（$\\Omega_{2}$ 的迹），使用一个连续的分片线性迹空间，节点为 $y = 0,\\, \\tfrac{1}{3},\\, \\tfrac{2}{3},\\, 1$，对应的节点基函数为 $\\{\\psi_{1}, \\psi_{2}, \\psi_{3}, \\psi_{4}\\}$。\n- 使用一个砂浆测试空间，由两个相等的界面子区间上的分片常数构成，$\\chi_{1}$ 支撑在 $[0,0.5]$ 上，$\\chi_{2}$ 支撑在 $[0.5,1]$ 上。\n\n砂浆耦合通过 $L^{2}$ 投影强制施加迹的弱连续性：对于砂浆空间中的任意测试函数 $\\mu$，其跳跃在 $L^{2}$ 意义下为零，即 $\\int_{\\Gamma} \\mu \\,(u_{1|\\Gamma} - u_{2|\\Gamma}) \\,\\mathrm{d}s = 0$。这产生形式为 $A \\mathbf{a} - B \\mathbf{b} = \\mathbf{0}$ 的线性约束，其中 $\\mathbf{a} \\in \\mathbb{R}^{3}$ 是主迹系数，$\\mathbf{b} \\in \\mathbb{R}^{4}$ 是从迹系数，且\n$$\nA_{i,k} = \\int_{0}^{1} \\chi_{i}(y) \\,\\phi_{k}(y)\\,\\mathrm{d}y, \n\\qquad\nB_{i,j} = \\int_{0}^{1} \\chi_{i}(y) \\,\\psi_{j}(y)\\,\\mathrm{d}y.\n$$\n\n假设界面上的子域舒尔补由质量集总的 SPD 算子近似，\n$$\nS_{1} = 2 I_{3}, \\qquad S_{2} = I_{4},\n$$\n这与由扩散系数加权的分片常数 Steklov–Poincaré 代理相一致。在内部消除后，假设有效凝聚载荷向量为\n$$\n\\mathbf{r}_{1} = \\begin{pmatrix} 0 \\\\ \\tfrac{1}{10} \\\\ 0 \\end{pmatrix},\n\\qquad\n\\mathbf{r}_{2} = \\begin{pmatrix} 0 \\\\ \\tfrac{1}{20} \\\\ \\tfrac{1}{20} \\\\ 0 \\end{pmatrix}.\n$$\n\n建立在砂浆约束下最小化界面能量的 Karush–Kuhn–Tucker (KKT) 鞍点系统，\n$$\n\\begin{pmatrix}\nS_{1}  & 0  & A^{\\top} \\\\\n0  & S_{2}  & -B^{\\top} \\\\\nA  & -B  & 0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{a} \\\\ \\mathbf{b} \\\\ \\boldsymbol{\\lambda}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{r}_{1} \\\\ \\mathbf{r}_{2} \\\\ \\mathbf{0}\n\\end{pmatrix},\n$$\n其中 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^{2}$ 是强制施加砂浆约束的拉格朗日乘子。使用基函数的显式定义，首先通过直接 $L^{2}$ 积分来组装砂浆耦合矩阵 $A$ 和 $B$。然后施加约束并求解得到的 KKT 系统，以确定主迹系数 $\\mathbf{a} = (a_{1}, a_{2}, a_{3})^{\\top}$。\n\n中心主迹系数 $a_{2}$ 的精确值是多少？以一个无单位的精确分数形式给出你的答案。",
            "solution": "我们从标量扩散问题的变分形式和域分解原理出发：在消除内部自由度后，界面未知量满足由子域舒尔补表征的对称正定 (SPD) 问题，并且通过砂浆约束弱施加界面连续性。在 $\\Gamma$ 上的 $L^{2}$ 意义下的弱连续性为\n$$\n\\int_{\\Gamma} \\mu \\,\\big(u_{1|\\Gamma} - u_{2|\\Gamma}\\big)\\,\\mathrm{d}s = 0 \\quad \\text{对于所有砂浆测试函数 } \\mu,\n$$\n在所选的迹基中展开后，该式产生一组线性约束，通过由 $L^{2}$ 投影组装的耦合矩阵将主系数 $\\mathbf{a}$ 和从系数 $\\mathbf{b}$ 联系起来。\n\n第一步：定义在 $\\Gamma \\equiv [0,1]$ 上的迹基函数。\n\n- 主侧（节点 $y=0,\\,0.5,\\,1$）：\n  - $\\phi_{1}(y)$ 支撑在 $[0,0.5]$ 上，当 $y \\in [0,0.5]$ 时 $\\phi_{1}(y) = 1 - 2y$，否则为 $0$。\n  - $\\phi_{2}(y)$ 支撑在 $[0,1]$ 上，在 $[0,0.5]$ 上 $\\phi_{2}(y) = 2y$，在 $[0.5,1]$ 上 $\\phi_{2}(y) = 2(1-y)$。\n  - $\\phi_{3}(y)$ 支撑在 $[0.5,1]$ 上，当 $y \\in [0.5,1]$ 时 $\\phi_{3}(y) = 2y - 1$，否则为 $0$。\n\n- 从侧（节点 $y=0,\\,\\tfrac{1}{3},\\,\\tfrac{2}{3},\\,1$）：\n  - $\\psi_{1}(y)$ 支撑在 $[0,\\tfrac{1}{3}]$ 上，在此区间上 $\\psi_{1}(y) = 1 - 3y$。\n  - $\\psi_{2}(y)$ 支撑在 $[0,\\tfrac{2}{3}]$ 上，在 $[0,\\tfrac{1}{3}]$ 上 $\\psi_{2}(y) = 3y$，在 $[\\tfrac{1}{3},\\tfrac{2}{3}]$ 上 $\\psi_{2}(y) = 2 - 3y$。\n  - $\\psi_{3}(y)$ 支撑在 $[\\tfrac{1}{3},1]$ 上，在 $[\\tfrac{1}{3},\\tfrac{2}{3}]$ 上 $\\psi_{3}(y) = 3y - 1$，在 $[\\tfrac{2}{3},1]$ 上 $\\psi_{3}(y) = 3 - 3y$。\n  - $\\psi_{4}(y)$ 支撑在 $[\\tfrac{2}{3},1]$ 上，在此区间上 $\\psi_{4}(y) = 3y - 2$。\n\n- 砂浆测试函数（分片常数）：\n  - 当 $y \\in [0,0.5]$ 时 $\\chi_{1}(y) = 1$，否则为 $0$。\n  - 当 $y \\in [0.5,1]$ 时 $\\chi_{2}(y) = 1$，否则为 $0$。\n\n第二步：通过 $L^{2}$ 内积组装砂浆耦合矩阵 $A$ 和 $B$，\n$$\nA_{i,k} = \\int_{0}^{1} \\chi_{i}(y)\\,\\phi_{k}(y)\\,\\mathrm{d}y, \\qquad B_{i,j} = \\int_{0}^{1} \\chi_{i}(y)\\,\\psi_{j}(y)\\,\\mathrm{d}y.\n$$\n\n对于 $A$：\n$$\n\\begin{aligned}\nA_{1,1} &= \\int_{0}^{0.5} (1-2y)\\,\\mathrm{d}y = \\left[y - y^{2}\\right]_{0}^{0.5} = \\tfrac{1}{2} - \\tfrac{1}{4} = \\tfrac{1}{4}, \\\\\nA_{1,2} &= \\int_{0}^{0.5} 2y\\,\\mathrm{d}y = \\left[y^{2}\\right]_{0}^{0.5} = \\tfrac{1}{4}, \\\\\nA_{1,3} &= 0, \\\\\nA_{2,1} &= 0, \\\\\nA_{2,2} &= \\int_{0.5}^{1} 2(1-y)\\,\\mathrm{d}y = 2\\left[y - \\tfrac{y^{2}}{2}\\right]_{0.5}^{1} = 2\\left(\\tfrac{1}{2} - \\tfrac{3}{8}\\right) = \\tfrac{1}{4}, \\\\\nA_{2,3} &= \\int_{0.5}^{1} (2y-1)\\,\\mathrm{d}y = \\left[y^{2} - y\\right]_{0.5}^{1} = \\left(1-1\\right) - \\left(\\tfrac{1}{4} - \\tfrac{1}{2}\\right) = \\tfrac{1}{4}.\n\\end{aligned}\n$$\n因此，\n$$\nA = \\begin{pmatrix}\n\\tfrac{1}{4} & \\tfrac{1}{4} & 0 \\\\\n0 & \\tfrac{1}{4} & \\tfrac{1}{4}\n\\end{pmatrix}.\n$$\n\n对于 $B$ (第一行在 $[0,0.5]$ 上)：\n$$\n\\begin{aligned}\n\\int_{0}^{0.5} \\psi_{1}(y)\\,\\mathrm{d}y &= \\int_{0}^{1/3} (1 - 3y)\\,\\mathrm{d}y = \\left[y - \\tfrac{3y^{2}}{2}\\right]_{0}^{1/3} = \\tfrac{1}{3} - \\tfrac{1}{6} = \\tfrac{1}{6}, \\\\\n\\int_{0}^{0.5} \\psi_{2}(y)\\,\\mathrm{d}y &= \\int_{0}^{1/3} 3y\\,\\mathrm{d}y + \\int_{1/3}^{0.5} (2 - 3y)\\,\\mathrm{d}y = \\tfrac{1}{6} + \\tfrac{1}{8} = \\tfrac{7}{24}, \\\\\n\\int_{0}^{0.5} \\psi_{3}(y)\\,\\mathrm{d}y &= \\int_{1/3}^{0.5} (3y - 1)\\,\\mathrm{d}y = \\left[\\tfrac{3y^{2}}{2} - y\\right]_{1/3}^{0.5} = -\\tfrac{1}{8} + \\tfrac{1}{6} = \\tfrac{1}{24}, \\\\\n\\int_{0}^{0.5} \\psi_{4}(y)\\,\\mathrm{d}y &= 0.\n\\end{aligned}\n$$\n对于 $B$ (第二行在 $[0.5,1]$ 上)：\n$$\n\\begin{aligned}\n\\int_{0.5}^{1} \\psi_{1}(y)\\,\\mathrm{d}y &= 0, \\\\\n\\int_{0.5}^{1} \\psi_{2}(y)\\,\\mathrm{d}y &= \\int_{0.5}^{2/3} (2 - 3y)\\,\\mathrm{d}y = \\tfrac{1}{24}, \\\\\n\\int_{0.5}^{1} \\psi_{3}(y)\\,\\mathrm{d}y &= \\int_{0.5}^{2/3} (3y - 1)\\,\\mathrm{d}y + \\int_{2/3}^{1} (3 - 3y)\\,\\mathrm{d}y = \\tfrac{1}{8} + \\tfrac{1}{6} = \\tfrac{7}{24}, \\\\\n\\int_{0.5}^{1} \\psi_{4}(y)\\,\\mathrm{d}y &= \\int_{2/3}^{1} (3y - 2)\\,\\mathrm{d}y = \\tfrac{1}{6}.\n\\end{aligned}\n$$\n因此，\n$$\nB = \\begin{pmatrix}\n\\tfrac{1}{6} & \\tfrac{7}{24} & \\tfrac{1}{24} & 0 \\\\\n0 & \\tfrac{1}{24} & \\tfrac{7}{24} & \\tfrac{1}{6}\n\\end{pmatrix}.\n$$\n\n第三步：写出 Karush–Kuhn–Tucker (KKT) 方程。已知 $S_{1} = 2 I_{3}$ 和 $S_{2} = I_{4}$，KKT 系统为\n$$\n\\begin{cases}\n2\\mathbf{a} + A^{\\top}\\boldsymbol{\\lambda} = \\mathbf{r}_{1}, \\\\\n\\mathbf{b} - B^{\\top}\\boldsymbol{\\lambda} = \\mathbf{r}_{2}, \\\\\nA \\mathbf{a} - B \\mathbf{b} = \\mathbf{0}.\n\\end{cases}\n$$\n消去 $\\mathbf{a}$ 和 $\\mathbf{b}$：\n$$\n\\mathbf{a} = \\dfrac{\\mathbf{r}_{1} - A^{\\top}\\boldsymbol{\\lambda}}{2}, \n\\qquad\n\\mathbf{b} = \\mathbf{r}_{2} + B^{\\top}\\boldsymbol{\\lambda}.\n$$\n代入约束条件：\n$$\nA\\left(\\dfrac{\\mathbf{r}_{1} - A^{\\top}\\boldsymbol{\\lambda}}{2}\\right) - B\\left(\\mathbf{r}_{2} + B^{\\top}\\boldsymbol{\\lambda}\\right) = \\mathbf{0},\n$$\n简化为\n$$\n\\left(\\dfrac{A A^{\\top}}{2} + B B^{\\top}\\right)\\boldsymbol{\\lambda} = \\dfrac{A \\mathbf{r}_{1}}{2} - B \\mathbf{r}_{2}.\n$$\n\n第四步：计算 $A A^{\\top}$、 $B B^{\\top}$、 $A \\mathbf{r}_{1}$ 和 $B \\mathbf{r}_{2}$。\n\n计算 $A A^{\\top}$：\n$$\nA A^{\\top} = \n\\begin{pmatrix}\n\\left(\\tfrac{1}{4}\\right)^{2} + \\left(\\tfrac{1}{4}\\right)^{2} & \\tfrac{1}{4}\\cdot 0 + \\tfrac{1}{4}\\cdot \\tfrac{1}{4} + 0\\cdot \\tfrac{1}{4} \\\\\n\\text{sym.} & \\left(\\tfrac{1}{4}\\right)^{2} + \\left(\\tfrac{1}{4}\\right)^{2}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\tfrac{1}{8} & \\tfrac{1}{16} \\\\\n\\tfrac{1}{16} & \\tfrac{1}{8}\n\\end{pmatrix}.\n$$\n计算 $B B^{\\top}$：\n$$\n\\begin{aligned}\n(B B^{\\top})_{11} &= \\left(\\tfrac{1}{6}\\right)^{2} + \\left(\\tfrac{7}{24}\\right)^{2} + \\left(\\tfrac{1}{24}\\right)^{2} = \\tfrac{1}{36} + \\tfrac{49}{576} + \\tfrac{1}{576} = \\tfrac{11}{96}, \\\\\n(B B^{\\top})_{12} &= \\tfrac{7}{24}\\cdot \\tfrac{1}{24} + \\tfrac{1}{24}\\cdot \\tfrac{7}{24} = \\tfrac{7}{576} + \\tfrac{7}{576} = \\tfrac{7}{288}, \\\\\n(B B^{\\top})_{22} &= \\left(\\tfrac{1}{24}\\right)^{2} + \\left(\\tfrac{7}{24}\\right)^{2} + \\left(\\tfrac{1}{6}\\right)^{2} = \\tfrac{1}{576} + \\tfrac{49}{576} + \\tfrac{1}{36} = \\tfrac{11}{96}.\n\\end{aligned}\n$$\n因此，\n$$\nB B^{\\top} = \\begin{pmatrix} \\tfrac{11}{96} & \\tfrac{7}{288} \\\\ \\tfrac{7}{288} & \\tfrac{11}{96} \\end{pmatrix}.\n$$\n计算 $\\dfrac{A A^{\\top}}{2} + B B^{\\top}$：\n$$\n\\dfrac{A A^{\\top}}{2} = \\begin{pmatrix} \\tfrac{1}{16} & \\tfrac{1}{32} \\\\ \\tfrac{1}{32} & \\tfrac{1}{16} \\end{pmatrix},\n\\quad\n\\Rightarrow\n\\quad\nH := \\dfrac{A A^{\\top}}{2} + B B^{\\top} = \\begin{pmatrix} \\tfrac{17}{96} & \\tfrac{1}{18} \\\\ \\tfrac{1}{18} & \\tfrac{17}{96} \\end{pmatrix}.\n$$\n计算 $\\dfrac{A \\mathbf{r}_{1}}{2}$ 和 $B \\mathbf{r}_{2}$：\n$$\nA \\mathbf{r}_{1} = \\begin{pmatrix} \\tfrac{1}{4}\\cdot 0 + \\tfrac{1}{4}\\cdot \\tfrac{1}{10} + 0\\cdot 0 \\\\ 0\\cdot 0 + \\tfrac{1}{4}\\cdot \\tfrac{1}{10} + \\tfrac{1}{4}\\cdot 0 \\end{pmatrix} = \\begin{pmatrix} \\tfrac{1}{40} \\\\ \\tfrac{1}{40} \\end{pmatrix},\n\\quad\n\\dfrac{A \\mathbf{r}_{1}}{2} = \\begin{pmatrix} \\tfrac{1}{80} \\\\ \\tfrac{1}{80} \\end{pmatrix}.\n$$\n$$\nB \\mathbf{r}_{2} = \\begin{pmatrix}\n\\tfrac{1}{6}\\cdot 0 + \\tfrac{7}{24}\\cdot \\tfrac{1}{20} + \\tfrac{1}{24}\\cdot \\tfrac{1}{20} + 0\\cdot 0 \\\\\n0\\cdot 0 + \\tfrac{1}{24}\\cdot \\tfrac{1}{20} + \\tfrac{7}{24}\\cdot \\tfrac{1}{20} + \\tfrac{1}{6}\\cdot 0\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\tfrac{8}{480} \\\\ \\tfrac{8}{480}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\tfrac{1}{60} \\\\ \\tfrac{1}{60}\n\\end{pmatrix}.\n$$\n因此右手边为\n$$\n\\mathbf{g} := \\dfrac{A \\mathbf{r}_{1}}{2} - B \\mathbf{r}_{2} = \\begin{pmatrix} \\tfrac{1}{80} - \\tfrac{1}{60} \\\\ \\tfrac{1}{80} - \\tfrac{1}{60} \\end{pmatrix} = \\begin{pmatrix} -\\tfrac{1}{240} \\\\ -\\tfrac{1}{240} \\end{pmatrix}.\n$$\n\n第五步：求解 $H \\boldsymbol{\\lambda} = \\mathbf{g}$。注意到对称性 $H_{11} = H_{22}$ 和 $H_{12} = H_{21}$ 以及 $\\mathbf{g}$ 的分量相等，我们寻找形式为 $\\boldsymbol{\\lambda} = (t, t)^{\\top}$ 的解。那么\n$$\n\\left(\\tfrac{17}{96} + \\tfrac{1}{18}\\right) t = -\\tfrac{1}{240}.\n$$\n计算系数：\n$$\n\\tfrac{17}{96} + \\tfrac{1}{18} = \\tfrac{51}{288} + \\tfrac{16}{288} = \\tfrac{67}{288}.\n$$\n因此\n$$\n\\tfrac{67}{288}\\, t = -\\tfrac{1}{240}\n\\quad \\Rightarrow \\quad\nt = -\\tfrac{1}{240} \\cdot \\tfrac{288}{67} = -\\tfrac{288}{240 \\cdot 67} = -\\tfrac{6}{335}.\n$$\n所以 $\\boldsymbol{\\lambda} = \\left(-\\tfrac{6}{335}, -\\tfrac{6}{335}\\right)^{\\top}$。\n\n第六步：恢复 $\\mathbf{a}$ 并提取 $a_{2}$。从\n$$\n\\mathbf{a} = \\dfrac{\\mathbf{r}_{1} - A^{\\top}\\boldsymbol{\\lambda}}{2},\n$$\n计算 $A^{\\top}\\boldsymbol{\\lambda}$，其中\n$$\nA^{\\top} = \n\\begin{pmatrix}\n\\tfrac{1}{4} & 0 \\\\\n\\tfrac{1}{4} & \\tfrac{1}{4} \\\\\n0 & \\tfrac{1}{4}\n\\end{pmatrix},\n\\quad\n\\boldsymbol{\\lambda} = \\begin{pmatrix} -\\tfrac{6}{335} \\\\ -\\tfrac{6}{335} \\end{pmatrix}.\n$$\n因此\n$$\nA^{\\top}\\boldsymbol{\\lambda} = \n\\begin{pmatrix}\n\\tfrac{1}{4}\\left(-\\tfrac{6}{335}\\right) + 0 \\\\\n\\tfrac{1}{4}\\left(-\\tfrac{6}{335}\\right) + \\tfrac{1}{4}\\left(-\\tfrac{6}{335}\\right) \\\\\n0 + \\tfrac{1}{4}\\left(-\\tfrac{6}{335}\\right)\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-\\tfrac{3}{670} \\\\\n-\\tfrac{3}{335} \\\\\n-\\tfrac{3}{670}\n\\end{pmatrix}.\n$$\n所以\n$$\n\\mathbf{a} = \\dfrac{1}{2}\n\\begin{pmatrix}\n0 - \\left(-\\tfrac{3}{670}\\right) \\\\\n\\tfrac{1}{10} - \\left(-\\tfrac{3}{335}\\right) \\\\\n0 - \\left(-\\tfrac{3}{670}\\right)\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\tfrac{3}{1340} \\\\\n\\dfrac{\\tfrac{1}{10} + \\tfrac{3}{335}}{2} \\\\\n\\tfrac{3}{1340}\n\\end{pmatrix}.\n$$\n计算 $a_{2}$：\n$$\na_{2} = \\dfrac{\\tfrac{1}{10} + \\tfrac{3}{335}}{2} = \\dfrac{\\tfrac{67}{670} + \\tfrac{6}{670}}{2} = \\dfrac{\\tfrac{73}{670}}{2} = \\tfrac{73}{1340}.\n$$\n因此，中心主迹系数 $a_{2}$ 是精确分数 $\\tfrac{73}{1340}$。",
            "answer": "$$\\boxed{\\frac{73}{1340}}$$"
        }
    ]
}