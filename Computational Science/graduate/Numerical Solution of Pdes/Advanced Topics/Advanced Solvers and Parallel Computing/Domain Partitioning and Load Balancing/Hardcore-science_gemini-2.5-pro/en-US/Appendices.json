{
    "hands_on_practices": [
        {
            "introduction": "To build a strong foundation in domain partitioning, we begin by analyzing an idealized scenario: partitioning a uniform grid using Space-Filling Curves (SFCs). This exercise  guides you through a theoretical analysis comparing two common SFCs, the Hilbert and Morton curves, to derive their expected communication costs. By applying fundamental geometric principles, you will discover how the intrinsic properties of an SFC translate directly into the compactness of its partitions and, consequently, its efficiency in minimizing inter-processor communication.",
            "id": "3382868",
            "problem": "Consider a uniform $N \\times N$ two-dimensional Cartesian grid with $N=2^{K}$, discretizing a second-order elliptic partial differential equation by a standard five-point stencil so that inter-cell coupling occurs only along axis-aligned nearest neighbors. The grid adjacency graph is the undirected graph in which vertices represent grid cells and edges connect $4$-neighbor pairs. A domain partition is a subset of grid cells; its communication volume is defined to be the number of adjacency edges with one endpoint in the partition and the other endpoint outside the partition.\n\nA parallel decomposition is formed by ordering the $N^{2}$ cells using a Space-Filling Curve (SFC), and splitting the resulting one-dimensional sequence into $P$ contiguous segments of equal length, where $P$ divides $N^{2}$. Assume $P \\geq 2$ and define $m := N^{2}/P$. Two SFCs are of interest: the Hilbert curve and the Morton (Z-order) curve. For the Hilbert curve, consecutive cells along the curve are always $4$-neighbors in the grid. For the Morton curve, consecutive cells can be non-$4$-neighbors due to bit-interleaving order; at the scale of $2 \\times 2$ blocks, one step is diagonal.\n\nLet $\\mathcal{V}_{H}(N,P)$ and $\\mathcal{V}_{M}(N,P)$ denote the expected per-partition communication volume under Hilbert and Morton orderings, respectively, where the expectation is over a uniformly random starting index of the contiguous segment in the SFC. Derive the leading-order asymptotic expressions of $\\mathcal{V}_{H}(N,P)$ and $\\mathcal{V}_{M}(N,P)$ for large $N$ and fixed $P$, using only fundamental properties of the grid adjacency and the following well-tested facts:\n\n- Discrete isoperimetric principle on the square lattice: Among all $4$-connected sets of $m$ cells, the minimal boundary length scales as $4\\sqrt{m}$, approached by axis-aligned squares in the limit of large $m$.\n- For contiguous Hilbert segments, the induced partition is $4$-connected and asymptotically compact (diameter scaling as $\\sqrt{m}$).\n- For contiguous Morton segments, fragmentation into multiple $4$-connected components occurs with high probability at the dyadic scale bracketing $m$; asymptotically, the induced partition consists of two $4$-connected components whose areas are approximately equal.\n\nUse these principles to obtain closed-form leading-order expressions for $\\mathcal{V}_{H}(N,P)$ and $\\mathcal{V}_{M}(N,P)$ in terms of $N$ and $P$, and also provide the leading-order ratio $\\rho(N,P) := \\mathcal{V}_{M}(N,P) / \\mathcal{V}_{H}(N,P)$. Your final answers must be exact analytic expressions in $N$ and $P$ (no numerical approximations). No physical units are required.",
            "solution": "### Solution Derivation\nThe communication volume of a partition is equivalent to the length of its boundary within the grid adjacency graph. We are tasked with finding the leading-order asymptotic expressions for the expected communication volume for partitions generated by Hilbert and Morton curves. Let $m = N^{2}/P$ be the number of cells in a single partition. The analysis is performed in the limit of large $N$ (and thus large $m$) for fixed $P$.\n\n**1. Communication Volume for Hilbert Curve Partitioning, $\\mathcal{V}_{H}(N,P)$**\n\nThe problem states that partitions formed by contiguous segments of a Hilbert curve are $4$-connected and asymptotically compact. The term \"compact\" implies that the partition's shape tends to minimize its boundary-to-area ratio. The discrete isoperimetric principle (Fact 1) provides the scaling for this minimal boundary. For a set of $m$ cells, the minimal boundary length is asymptotically given by that of an ideal square-like region, which scales as $4\\sqrt{m}$.\n\nSince a generic partition created by the Hilbert curve is asymptotically compact, its communication volume will be dominated by this minimal scaling. The expectation over a random starting index averages over all possible partitions, but since all such partitions share this asymptotic compactness, the expected volume is simply the volume of a generic compact partition.\n\nTherefore, the leading-order expression for the expected per-partition communication volume is:\n$$\n\\mathcal{V}_{H}(N,P) \\approx 4\\sqrt{m}\n$$\nSubstituting the definition $m = N^{2}/P$:\n$$\n\\mathcal{V}_{H}(N,P) \\approx 4\\sqrt{\\frac{N^{2}}{P}} = \\frac{4N}{\\sqrt{P}}\n$$\n\n**2. Communication Volume for Morton Curve Partitioning, $\\mathcal{V}_{M}(N,P)$**\n\nFor the Morton (Z-order) curve, the problem states a crucial difference in partition topology (Fact 3): a contiguous segment of length $m$ does not form a single compact region. Instead, it asymptotically fragments into two $4$-connected components of approximately equal area.\n\nLet the total number of cells in the partition be $m$. This set of cells is split into two disjoint components, with cell counts $m_{1}$ and $m_{2}$ such that $m_{1} + m_{2} = m$. The problem states that their areas are approximately equal, so we have $m_{1} \\approx m_{2} \\approx m/2$.\n\nThe total communication volume of the partition is the sum of the communication volumes of its constituent components, assuming the components are sufficiently separated such that their boundaries do not overlap, a reasonable assumption in the asymptotic limit. We can apply the isoperimetric principle (Fact 1) to each of these smaller, more compact components.\n\nThe communication volume of the first component is $\\approx 4\\sqrt{m_{1}} \\approx 4\\sqrt{m/2}$.\nThe communication volume of the second component is $\\approx 4\\sqrt{m_{2}} \\approx 4\\sqrt{m/2}$.\n\nThe total expected communication volume for the Morton partition is the sum of these two:\n$$\n\\mathcal{V}_{M}(N,P) \\approx 4\\sqrt{\\frac{m}{2}} + 4\\sqrt{\\frac{m}{2}} = 8\\sqrt{\\frac{m}{2}} = \\frac{8}{\\sqrt{2}}\\sqrt{m} = 4\\sqrt{2}\\sqrt{m}\n$$\nNow, substituting $m = N^{2}/P$:\n$$\n\\mathcal{V}_{M}(N,P) \\approx 4\\sqrt{2}\\sqrt{\\frac{N^{2}}{P}} = \\frac{4\\sqrt{2}N}{\\sqrt{P}}\n$$\n\n**3. The Ratio $\\rho(N,P)$**\n\nThe ratio of the expected communication volumes is defined as $\\rho(N,P) = \\mathcal{V}_{M}(N,P) / \\mathcal{V}_{H}(N,P)$. Using the leading-order expressions derived above:\n$$\n\\rho(N,P) = \\frac{\\mathcal{V}_{M}(N,P)}{\\mathcal{V}_{H}(N,P)} \\approx \\frac{\\frac{4\\sqrt{2}N}{\\sqrt{P}}}{\\frac{4N}{\\sqrt{P}}}\n$$\nThe terms $\\frac{4N}{\\sqrt{P}}$ cancel, leaving a constant:\n$$\n\\rho(N,P) \\approx \\sqrt{2}\n$$\nThis result quantifies the asymptotic communication overhead incurred by using the Morton curve compared to the Hilbert curve for $2D$ problems, arising from the Morton curve's inherent fragmentation property.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{4N}{\\sqrt{P}} & \\frac{4\\sqrt{2}N}{\\sqrt{P}} & \\sqrt{2} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "While SFCs provide an elegant solution for uniform grids, many scientific applications involve highly non-uniform, or anisotropic, meshes where these methods can perform poorly. This practice  presents a more challenging scenario involving a boundary-layer mesh with a high aspect ratio. By modeling and comparing the communication volume of SFC partitions against an anisotropy-aware stripe partition, you will identify the performance limitations of purely geometric approaches and understand the conditions under which more sophisticated graph-based partitioners become essential.",
            "id": "3382849",
            "problem": "You are given a two-dimensional boundary-layer mesh arising from the numerical solution of partial differential equations in a rectangular domain of fixed physical size. The mesh has highly anisotropic cells of aspect ratio $a \\gg 1$, defined as the ratio of the tangential to normal cell sizes near the wall. Let the total number of mesh cells be $N$, arranged on a logically rectangular grid with $n_x$ cells in the streamwise direction and $n_y$ in the wall-normal direction, so that $n_x n_y = N$ and the anisotropy at fixed physical size implies $n_x \\asymp N^{1/2} a^{-1/2}$ and $n_y \\asymp N^{1/2} a^{1/2}$. The mesh is partitioned among $P$ identical processors.\n\nCommunication volume is modeled as the total number of unique inter-partition mesh adjacencies (graph edges) cut by the partition, denoted $V$. You will compare three families of partitions:\n\n- Space-filling curve (SFC) partitions based on contiguous segments of Morton (Z-order) or Hilbert curves defined on the $n_x \\times n_y$ grid. Denote their communication volumes by $V_M$ and $V_H$ respectively.\n- An “optimal” multilevel graph partitioner that can exploit anisotropy by aligning cuts as stripes along the long direction, yielding communication volume $V_G$.\n\nUse the following modeling assumptions derived from core geometric principles:\n\n- For a connected set of $A_b$ grid cells with $A_b \\ll n_x n_y$, the minimal interface length in grid edges satisfies an isoperimetric scaling $L_{\\min}(A_b) \\asymp \\min\\{\\kappa_1 \\sqrt{A_b}, \\kappa_2 A_b/n_x\\}$, where the first term corresponds to nearly square shapes and the second to “strip-like” shapes when the width saturates at $n_x$. Here $\\kappa_1$ and $\\kappa_2$ are constants independent of $a$, $N$, and $P$.\n- A contiguous range of the Hilbert space-filling curve (SFC) produces a single connected block whose interface is within a constant factor of $L_{\\min}(A_b)$, while a Morton SFC block has the same asymptotic exponents but a larger constant. Therefore, neglecting constants, you may take $L_H(A_b) \\asymp \\min\\{\\sqrt{A_b}, A_b/n_x\\}$ and $L_M(A_b) \\asymp \\min\\{\\sqrt{A_b}, A_b/n_x\\}$ for scaling purposes.\n- Partitioning by taking $P$ equal contiguous SFC segments yields $P$ blocks each of area $A_b = N/P$. The total unique cut edges for SFC partitions scale as $V_{\\mathrm{SFC}} \\asymp \\tfrac{P}{2} L_{\\mathrm{SFC}}(A_b)$, up to constants that do not depend on $a$, $N$, or $P$.\n- A stripe partition aligned with the long direction cuts across the short side $n_x$, creating $P-1$ boundaries of length $n_x$, so $V_G \\asymp n_x P$ to leading order.\n\nTasks:\n\n- Starting from the above foundational scalings and the definitions of communication volume as cut size in the dual graph, derive asymptotic formulas for $V_H(a,P,N)$ and $V_M(a,P,N)$ as functions of $a$, $P$, and $N$, including the regime change in $P$ relative to $a$ imposed by the constraint $A_b \\le n_x^2$.\n- Identify the regime in which space-filling curves underperform the stripe-aligned graph partitioning by comparing $V_H$ (or $V_M$) to $V_G$.\n- Finally, determine the asymptotic critical processor count $P^{\\star}(a)$ at which the Hilbert SFC communication volume matches that of the stripe graph partitioner to leading order in $a \\gg 1$ and ignoring constant factors and lower-order terms.\n\nProvide your final answer as a single closed-form expression for $P^{\\star}(a)$ in terms of $a$ only. No numerical rounding is required and no units are to be reported. Clearly state any intermediate regime conditions you use during the derivation, but ensure the final reported quantity is only $P^{\\star}(a)$.",
            "solution": "### Solution Derivation\n\nThe analysis proceeds by deriving the asymptotic scaling laws for the communication volume of each partitioning strategy and then comparing them to find the critical processor count $P^{\\star}(a)$. Asymptotic equivalence is denoted by $\\asymp$, and we will treat it as equality for the purpose of solving for $P^{\\star}$, since we are ignoring constant factors.\n\n**1. Asymptotic Formula for SFC Communication Volume ($V_H$, $V_M$)**\n\nThe communication volume for an SFC partition is given by $V_{\\mathrm{SFC}} \\asymp P \\cdot L_{\\mathrm{SFC}}(A_b)$, where the block area is $A_b = N/P$. The interface length of a single block is $L_{\\mathrm{SFC}}(A_b) \\asymp \\min\\{\\sqrt{A_b}, A_b/n_x\\}$.\n\nThe behavior of the $\\min$ function depends on the comparison between the two terms. The \"squarish\" shape perimeter, $\\sqrt{A_b}$, is the minimal perimeter in an unconstrained grid. This shape is achievable only if the block side length does not exceed the grid's narrowest dimension, i.e., $\\sqrt{A_b} \\le n_x$. If $\\sqrt{A_b} > n_x$, the block is forced into a \"strip-like\" shape of width $n_x$, and its perimeter scales as $A_b/n_x$.\n\nThe crossover condition is $\\sqrt{A_b} = n_x$, which means $A_b = n_x^2$. Substituting $A_b = N/P$ and $n_x^2 \\asymp N/a$, we get $N/P = N/a$, which implies the critical processor count for the regime change is $P = a$.\n\nThis defines two regimes:\n-   **For $P > a$ (small blocks):** $A_b  n_x^2$, so $\\sqrt{A_b}  n_x$. The blocks can be squarish, so the minimal perimeter scaling applies: $L_{\\mathrm{SFC}}(A_b) \\asymp \\sqrt{A_b} = \\sqrt{N/P}$.\n-   **For $P \\le a$ (large blocks):** $A_b \\ge n_x^2$, so $\\sqrt{A_b} \\ge n_x$. The blocks are forced into strips, and the perimeter scaling is: $L_{\\mathrm{SFC}}(A_b) \\asymp A_b/n_x = (N/P)/n_x$.\n\nNow we compute the total communication volume $V_{\\mathrm{SFC}} \\asymp P \\cdot L_{\\mathrm{SFC}}(A_b)$:\n-   **For $P > a$**: $V_{\\mathrm{SFC}} \\asymp P \\sqrt{N/P} = \\sqrt{NP}$.\n-   **For $P \\le a$**: $V_{\\mathrm{SFC}} \\asymp P \\cdot \\frac{N/P}{n_x} = \\frac{N}{n_x}$. Substituting $n_x \\asymp N^{1/2} a^{-1/2}$, we get $V_{\\mathrm{SFC}} \\asymp \\frac{N}{N^{1/2} a^{-1/2}} = N^{1/2} a^{1/2}$.\n\nSo, the asymptotic formula for $V_H$ and $V_M$ is:\n$$V_{\\mathrm{SFC}}(a,P,N) \\asymp \\begin{cases} N^{1/2} a^{1/2}  \\text{for } P \\le a \\\\ \\sqrt{NP}  \\text{for } P > a \\end{cases}$$\nThis shows that for a low number of processors, the communication cost is constant, determined by the grid anisotropy. For a high number of processors, the cost grows as $\\sqrt{P}$.\n\n**2. Asymptotic Formula for Stripe Partitioner ($V_G$)**\n\nThe model for the stripe graph partitioner is given as $V_G \\asymp n_x P$. Substituting the scaling for $n_x$:\n$$V_G(a,P,N) \\asymp (N^{1/2} a^{-1/2}) P = P N^{1/2} a^{-1/2}$$\n\n**3. Comparison and Identification of Underperformance Regime**\n\nWe compare $V_{\\mathrm{SFC}}$ and $V_G$ in the two regimes of $P$.\n-   **Regime 1: $P \\le a$**\n    $V_{\\mathrm{SFC}} \\asymp N^{1/2} a^{1/2}$.\n    $V_G \\asymp P N^{1/2} a^{-1/2}$.\n    The ratio is $\\frac{V_{\\mathrm{SFC}}}{V_G} \\asymp \\frac{N^{1/2} a^{1/2}}{P N^{1/2} a^{-1/2}} = \\frac{a}{P}$.\n    Since $P \\le a$ and $a \\gg 1$, this ratio is $\\ge 1$. Thus, $V_{\\mathrm{SFC}} \\ge V_G$. Space-filling curves underperform (or perform equally when $P=a$) compared to the anisotropy-aware stripe partitioner in this regime.\n\n-   **Regime 2: $P > a$**\n    $V_{\\mathrm{SFC}} \\asymp \\sqrt{NP} = N^{1/2} P^{1/2}$.\n    $V_G \\asymp P N^{1/2} a^{-1/2}$.\n    The ratio is $\\frac{V_{\\mathrm{SFC}}}{V_G} \\asymp \\frac{N^{1/2} P^{1/2}}{P N^{1/2} a^{-1/2}} = \\frac{P^{-1/2}}{a^{-1/2}} = \\sqrt{\\frac{a}{P}}$.\n    Since $P > a$, this ratio is less than $1$. Thus, $V_{\\mathrm{SFC}}  V_G$. In this regime, space-filling curves outperform the stripe partitioner.\n\nThe regime where SFCs underperform is $P \\le a$.\n\n**4. Determination of the Critical Processor Count $P^{\\star}(a)$**\n\nThe critical processor count $P^{\\star}(a)$ is the value of $P$ where the communication volumes are equal, i.e., $V_H(P^{\\star}) \\asymp V_G(P^{\\star})$. From our analysis, the two costs transition at the boundary between the two regimes, which is $P=a$.\nWe can verify this by setting the expressions equal at the boundary $P=a$:\n$$V_{\\mathrm{SFC}}(a,a,N) \\asymp N^{1/2} a^{1/2}$$\n$$V_G(a,a,N) \\asymp a \\cdot N^{1/2} a^{-1/2} = N^{1/2} a^{1/2}$$\nThe two expressions are asymptotically equal at $P=a$. Therefore, the critical processor count is $P^{\\star}(a) = a$. This signifies that for SFC-based partitions to be competitive with an optimal stripe partition on a highly anisotropic grid, the number of processors must scale with the grid's aspect ratio. The final result is requested in terms of $a$ only.\n\n$$P^{\\star}(a) \\asymp a$$",
            "answer": "$$\\boxed{a}$$"
        },
        {
            "introduction": "Effective domain decomposition involves more than just minimizing communication; it also requires optimizing the convergence of the numerical solver. This final practice  synthesizes these concepts by tasking you with finding the optimal overlap in an additive Schwarz preconditioner. You will model the complex trade-off where increasing overlap improves the solver's convergence rate but also increases per-iteration computational and communication costs, developing a program to pinpoint the ideal balance that minimizes the total time to solution.",
            "id": "3382824",
            "problem": "You are asked to design and implement a program that selects the optimal integer overlap size $\\delta$ (in grid points) for an additive Schwarz preconditioner applied to a two-dimensional elliptic partial differential equation, under a model of per-iteration cost and convergence rate that depends on the overlap, the stencil radius, and the domain partition. The goal is to minimize the total time to solution $T(\\delta)$, defined as the product of the number of iterations and the time per iteration. The program must compute the optimal $\\delta$ for several specified test cases and output all results in a single line.\n\nAssume the following fundamental base and well-tested facts.\n\n- The preconditioned Conjugate Gradient method for a symmetric positive definite linear system with condition number $\\kappa$ requires at least\n$$\nn_{\\text{iter}} \\ge \\tfrac{1}{2} \\sqrt{\\kappa} \\, \\ln\\!\\bigl(\\tfrac{2}{\\varepsilon}\\bigr)\n$$\niterations to reduce the relative error below a prescribed tolerance $\\varepsilon$, where $\\ln$ is the natural logarithm.\n\n- For overlapping domain decomposition with the additive Schwarz preconditioner on a two-dimensional elliptic operator with subdomain characteristic diameter $H$ and overlap $\\delta$ (in grid points), rigorous theory gives a bound of the form\n$$\n\\kappa(\\delta) \\le C_{\\kappa} \\, \\bigl(1 + \\tfrac{H}{\\delta}\\bigr)^{2},\n$$\nwhere $C_{\\kappa} \\ge 1$ is a dimensionless constant reflecting properties of the operator, mesh regularity, and the coarse space. In practice, the smallest admissible effective overlap is constrained by the mesh resolution; interpret $\\delta$ in grid-point units and take $\\delta_{\\text{eff}} = \\max(1,\\delta)$ when using this bound. If $\\delta=0$ (non-overlapping block Jacobi), you may model additional degradation by a constant multiplicative factor $\\phi_{0} \\ge 1$ on the iteration count.\n\n- The per-iteration time for a synchronous nearest-neighbor iterative method on a uniform two-dimensional grid partitioned into a logical processor grid of $P_x \\times P_y$ subdomains is dominated by the slowest subdomain. Use a standard linear communication model with latency and bandwidth:\n    - Each subdomain exchanges halo data of thickness equal to the stencil radius $k$ (in grid points) with its up to $4$ face neighbors. Let $k$ be the stencil radius, so that $k=1$ corresponds to a $5$-point stencil and $k=2$ to a $9$-point stencil, in the sense of required halo thickness.\n    - The time to compute one stencil update at one grid point is $\\alpha \\, k$ seconds, reflecting that the floating-point work scales with the stencil radius $k$.\n    - Each neighbor exchange costs a latency of $\\lambda$ seconds and a bandwidth cost of $\\nu$ seconds per grid point communicated. Exchanging a halo of thickness $k$ in two dimensions requires transmitting $k$ columns of height equal to the local extended subdomain height and $k$ rows of width equal to the local extended subdomain width on each corresponding face.\n\n- Consider a uniform rectangular global grid of $N_x \\times N_y$ points, partitioned into $P_x \\times P_y$ rectangular subdomains. The core (non-overlapped) subdomain sizes are distributed as evenly as possible along each coordinate: along $x$, the first $r_x = N_x \\bmod P_x$ subdomains have size $\\lceil N_x / P_x \\rceil$ and the remaining $P_x - r_x$ have size $\\lfloor N_x / P_x \\rfloor$; similarly for $y$. An overlap of $\\delta$ grid points extends each subdomain by $\\delta$ to each interior face; at the global boundary there is no extension beyond the physical domain, so the extension on a boundary side is only on the interior face. Thus, for a subdomain whose core size is $n_x \\times n_y$ and which is interior in $x$ and $y$, the extended size is $(n_x + 2\\delta)\\times(n_y + 2\\delta)$; on a boundary in $x$ and interior in $y$ it is $(n_x + \\delta)\\times(n_y + 2\\delta)$; on a boundary in both $x$ and $y$ it is $(n_x + \\delta)\\times(n_y + \\delta)$.\n\n- The per-iteration compute time for a subdomain with extended size $n_x^{\\text{ext}} \\times n_y^{\\text{ext}}$ is\n$$\nt_{\\text{comp}} = \\alpha \\, k \\, n_x^{\\text{ext}} \\, n_y^{\\text{ext}}.\n$$\nThe per-iteration communication time for that subdomain is\n$$\nt_{\\text{comm}} = \\lambda \\, n_{\\text{nbr}} \\;+\\; \\nu \\, k \\, \\bigl( 2 n_x^{\\text{ext}} + 2 n_y^{\\text{ext}} \\bigr),\n$$\nwhere $n_{\\text{nbr}} \\in \\{2,3,4\\}$ is the number of face neighbors (corners do not communicate in this model). The per-iteration time for the whole parallel step is the maximum over all subdomains of $t_{\\text{comp}} + t_{\\text{comm}}$.\n\n- Let the characteristic subdomain diameter $H$ be taken as the maximum of the core subdomain side lengths along $x$ or $y$ in grid-point units under the even distribution described above.\n\nYour program must, for each test case, compute the optimal integer overlap $\\delta^{\\star} \\in \\{0,1,2,\\dots,\\delta_{\\max}\\}$ that minimizes\n$$\nT(\\delta) \\;=\\; n_{\\text{iter}}(\\delta) \\;\\cdot\\; t_{\\text{iter}}(\\delta),\n$$\nwith\n$$\nn_{\\text{iter}}(\\delta) \\;=\\; \\left\\lceil \\tfrac{1}{2} \\, \\sqrt{\\kappa(\\delta)} \\, \\ln\\!\\bigl(\\tfrac{2}{\\varepsilon}\\bigr) \\cdot \\bigl( \\phi_{0} \\text{ if } \\delta=0 \\text{ else } 1 \\bigr) \\right\\rceil,\n\\quad\n\\kappa(\\delta) \\;=\\; C_{\\kappa} \\, \\bigl( 1 + \\tfrac{H}{\\delta_{\\text{eff}}} \\bigr)^{2},\n\\quad\n\\delta_{\\text{eff}} \\;=\\; \\max(1,\\delta),\n$$\nand $t_{\\text{iter}}(\\delta)$ defined by the maximum over subdomains of $t_{\\text{comp}} + t_{\\text{comm}}$ as above. Break ties by choosing the smallest $\\delta$ that attains the minimum $T(\\delta)$.\n\nTest suite. For each tuple of parameters, use the exact definitions and units stated. Time is in seconds. Angles are not used. Percentages are not used.\n\n- Case $\\#1$: $N_x=4096$, $N_y=4096$, $P_x=8$, $P_y=8$, $k=1$, $\\alpha=4\\times 10^{-10}$, $\\lambda=5\\times 10^{-6}$, $\\nu=8\\times 10^{-10}$, $C_{\\kappa}=4$, $\\varepsilon=10^{-8}$, $\\phi_{0}=3$, $\\delta_{\\max}=8$.\n- Case $\\#2$: $N_x=4096$, $N_y=4096$, $P_x=4$, $P_y=4$, $k=1$, $\\alpha=4\\times 10^{-10}$, $\\lambda=5\\times 10^{-5}$, $\\nu=8\\times 10^{-10}$, $C_{\\kappa}=4$, $\\varepsilon=10^{-8}$, $\\phi_{0}=3$, $\\delta_{\\max}=8$.\n- Case $\\#3$: $N_x=8192$, $N_y=1024$, $P_x=16$, $P_y=2$, $k=3$, $\\alpha=4\\times 10^{-10}$, $\\lambda=5\\times 10^{-6}$, $\\nu=8\\times 10^{-10}$, $C_{\\kappa}=6$, $\\varepsilon=10^{-8}$, $\\phi_{0}=3$, $\\delta_{\\max}=12$.\n- Case $\\#4$: $N_x=3000$, $N_y=3000$, $P_x=7$, $P_y=7$, $k=1$, $\\alpha=3\\times 10^{-10}$, $\\lambda=1\\times 10^{-5}$, $\\nu=1\\times 10^{-9}$, $C_{\\kappa}=5$, $\\varepsilon=10^{-8}$, $\\phi_{0}=3$, $\\delta_{\\max}=10$.\n- Case $\\#5$: $N_x=2048$, $N_y=2048$, $P_x=32$, $P_y=32$, $k=1$, $\\alpha=2\\times 10^{-10}$, $\\lambda=1\\times 10^{-6}$, $\\nu=2\\times 10^{-9}$, $C_{\\kappa}=4$, $\\varepsilon=10^{-8}$, $\\phi_{0}=3$, $\\delta_{\\max}=6$.\n\nFinal output format. Your program should produce a single line of output containing the optimal overlaps for the test cases, in order, as a comma-separated list enclosed in square brackets, for example, $[d_1,d_2,\\dots,d_5]$, where each $d_i$ is the optimal integer $\\delta^{\\star}$ for case $i$.",
            "solution": "The overarching goal is to find the integer overlap size $\\delta^{\\star}$ within the range $\\{0, 1, \\dots, \\delta_{\\max}\\}$ that minimizes the total time to solution, $T(\\delta)$. This time is modeled as the product of the number of iterations required for convergence, $n_{\\text{iter}}(\\delta)$, and the time elapsed per iteration, $t_{\\text{iter}}(\\delta)$.\n$$\nT(\\delta) = n_{\\text{iter}}(\\delta) \\cdot t_{\\text{iter}}(\\delta)\n$$\nThe optimal overlap $\\delta^{\\star}$ is therefore the argument that minimizes this function:\n$$\n\\delta^{\\star} = \\underset{\\delta \\in \\{0, 1, \\dots, \\delta_{\\max}\\}}{\\arg\\min} T(\\delta)\n$$\nIn case of ties, the smallest value of $\\delta$ is chosen. The solution requires systematically evaluating $T(\\delta)$ for each permissible integer value of $\\delta$ and identifying the one that yields the minimum time. This involves deriving expressions for both $n_{\\text{iter}}(\\delta)$ and $t_{\\text{iter}}(\\delta)$ from the provided models.\n\n### Number of Iterations, $n_{\\text{iter}}(\\delta)$\n\nThe number of iterations is determined by the convergence properties of the preconditioned conjugate gradient method, which depend on the condition number $\\kappa(\\delta)$ of the preconditioned system. The model is given by:\n$$\nn_{\\text{iter}}(\\delta) = \\left\\lceil \\tfrac{1}{2} \\, \\sqrt{\\kappa(\\delta)} \\, \\ln\\!\\bigl(\\tfrac{2}{\\varepsilon}\\bigr) \\cdot M(\\delta) \\right\\rceil\n$$\nwhere $\\varepsilon$ is the error tolerance and $M(\\delta)$ is a multiplicative factor defined as:\n$$\nM(\\delta) = \\begin{cases} \\phi_0  \\text{if } \\delta=0 \\\\ 1  \\text{if } \\delta > 0 \\end{cases}\n$$\nThe condition number $\\kappa(\\delta)$ itself depends on the ratio of the characteristic subdomain diameter $H$ to the effective overlap $\\delta_{\\text{eff}}$:\n$$\n\\kappa(\\delta) = C_{\\kappa} \\left( 1 + \\frac{H}{\\delta_{\\text{eff}}} \\right)^{2}, \\quad \\text{with } \\delta_{\\text{eff}} = \\max(1, \\delta)\n$$\nThe characteristic diameter $H$ is the maximum of the largest core subdomain dimensions along each coordinate axis. For a global grid of $N_x \\times N_y$ points partitioned among $P_x \\times P_y$ processors, the largest core dimensions are $\\lceil N_x / P_x \\rceil$ and $\\lceil N_y / P_y \\rceil$. Thus,\n$$\nH = \\max\\left(\\lceil N_x / P_x \\rceil, \\lceil N_y / P_y \\rceil\\right)\n$$\nAs $\\delta$ increases, $\\delta_{\\text{eff}}$ increases, causing $\\kappa(\\delta)$ and consequently $n_{\\text{iter}}(\\delta)$ to decrease monotonically for $\\delta \\ge 1$. The case $\\delta=0$ introduces a penalty factor $\\phi_0$.\n\n### Time per Iteration, $t_{\\text{iter}}(\\delta)$\n\nThe time per iteration, $t_{\\text{iter}}(\\delta)$, is governed by the slowest subdomain in the parallel computation. For any given subdomain $p$, its single-iteration time $t_p$ is the sum of its computation time $t_{\\text{comp}, p}$ and communication time $t_{\\text{comm}, p}$.\n$$\nt_{\\text{iter}}(\\delta) = \\max_{p} \\left( t_{\\text{comp}, p}(\\delta) + t_{\\text{comm}, p}(\\delta) \\right)\n$$\nThe constituents of this time are modeled as:\n$$\nt_{\\text{comp}, p} = \\alpha \\, k \\, n_{x,p}^{\\text{ext}} \\, n_{y,p}^{\\text{ext}}\n$$\n$$\nt_{\\text{comm}, p} = \\lambda \\, n_{\\text{nbr},p} + \\nu \\, k \\, \\bigl( 2 n_{x,p}^{\\text{ext}} + 2 n_{y,p}^{\\text{ext}} \\bigr)\n$$\nHere, $\\alpha$, $k$, $\\lambda$, and $\\nu$ are constants related to computation and communication performance. The terms $n_{x,p}^{\\text{ext}}$, $n_{y,p}^{\\text{ext}}$, and $n_{\\text{nbr},p}$ are properties of the specific subdomain $p$: its extended dimensions and number of neighbors, which depend on its core dimensions and its location within the processor grid.\n\nA subdomain's properties are determined by its processor grid indices $(i, j)$, where $i \\in \\{0, \\dots, P_x-1\\}$ and $j \\in \\{0, \\dots, P_y-1\\}$.\nThe core dimensions are given by:\n$$\nn_{x,i}^{\\text{core}} = \\begin{cases} \\lceil N_x / P_x \\rceil  \\text{if } i  (N_x \\bmod P_x) \\\\ \\lfloor N_x / P_x \\rfloor  \\text{otherwise} \\end{cases}\n$$\n$$\nn_{y,j}^{\\text{core}} = \\begin{cases} \\lceil N_y / P_y \\rceil  \\text{if } j  (N_y \\bmod P_y) \\\\ \\lfloor N_y / P_y \\rfloor  \\text{otherwise} \\end{cases}\n$$\nThe extended dimensions are found by adding the overlap $\\delta$ for each internal face:\n$$\nn_{x,i}^{\\text{ext}} = n_{x,i}^{\\text{core}} + \\delta \\cdot ( (1 \\text{ if } i > 0) + (1 \\text{ if } i  P_x-1) )\n$$\n$$\nn_{y,j}^{\\text{ext}} = n_{y,j}^{\\text{core}} + \\delta \\cdot ( (1 \\text{ if } j > 0) + (1 \\text{ if } j  P_y-1) )\n$$\nThe number of neighbors is:\n$$\nn_{\\text{nbr},ij} = (1 \\text{ if } i > 0) + (1 \\text{ if } i  P_x-1) + (1 \\text{ if } j > 0) + (1 \\text{ if } j  P_y-1)\n$$\nThe time for a subdomain, $t_p(\\delta)$, is a monotonically increasing function of its core dimensions, extended dimensions, and number of neighbors. The extended dimensions and number of neighbors are largest for interior subdomains, and the core dimensions are largest for subdomains with small indices $i, j$. To find the maximum time $t_{\\text{iter}}(\\delta)$, we must identify the subdomain for which the combination of these factors is greatest. This requires evaluating the time for a set of representative subdomains that capture all distinct configurations of core size and processor grid location (corner, edge, interior).\n\n### Algorithmic Solution\n\nThe optimization procedure is as follows:\n1. For a given test case, pre-calculate all parameters that are independent of $\\delta$, such as the subdomain core sizes and the characteristic diameter $H$.\n2. Initialize a minimum time $T_{\\min}$ to infinity and the optimal overlap $\\delta^{\\star}$ to an invalid value.\n3. Loop through each integer $\\delta$ from $0$ to $\\delta_{\\max}$.\n    a. Calculate $n_{\\text{iter}}(\\delta)$ using the formulas above.\n    b. Calculate $t_{\\text{iter}}(\\delta)$ by finding the maximum time over all representative subdomain configurations.\n    c. Compute the total solution time $T(\\delta) = n_{\\text{iter}}(\\delta) \\cdot t_{\\text{iter}}(\\delta)$.\n    d. If $T(\\delta)  T_{\\min}$, update $T_{\\min} = T(\\delta)$ and $\\delta^{\\star} = \\delta$.\n4. After the loop completes, the final value of $\\delta^{\\star}$ is the optimal overlap for the test case. This procedure is repeated for all test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the optimal overlap size delta for a series of test cases based on a\n    performance model for an additive Schwarz preconditioned iterative solver.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, Px, Py, k, alpha, lambda, nu, Ck, epsilon, phi0, delta_max)\n        (4096, 4096, 8, 8, 1, 4e-10, 5e-6, 8e-10, 4, 1e-8, 3, 8),\n        (4096, 4096, 4, 4, 1, 4e-10, 5e-5, 8e-10, 4, 1e-8, 3, 8),\n        (8192, 1024, 16, 2, 3, 4e-10, 5e-6, 8e-10, 6, 1e-8, 3, 12),\n        (3000, 3000, 7, 7, 1, 3e-10, 1e-5, 1e-9, 5, 1e-8, 3, 10),\n        (2048, 2048, 32, 32, 1, 2e-10, 1e-6, 2e-9, 4, 1e-8, 3, 6),\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(find_optimal_delta(case))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_optimal_delta(params):\n    \"\"\"\n    Finds the optimal overlap delta for a single test case.\n    \"\"\"\n    Nx, Ny, Px, Py, k, alpha, lam, nu, Ck, eps, phi0, d_max = params\n\n    # Pre-calculate constants and subdomain size distributions\n    nxl = (Nx + Px - 1) // Px  # ceil(Nx/Px)\n    nxs = Nx // Px             # floor(Nx/Px)\n    nyl = (Ny + Py - 1) // Py  # ceil(Ny/Py)\n    nys = Ny // Py             # floor(Ny/Py)\n    rx = Nx % Px\n    ry = Ny % Py\n\n    H = float(max(nxl, nyl))\n    ln_term = np.log(2.0 / eps)\n\n    # To find the max iteration time, we must check a representative set of\n    # processor indices (i,j) that cover all unique combinations of:\n    # 1. Core size (large/small in x and y)\n    # 2. Location (corner/edge/interior)\n    # These unique configurations are determined by boundaries at i=0, i=rx, i=Px-1\n    # and j=0, j=ry, j=Py-1.\n    i_indices = {0}\n    if Px > 1: i_indices.add(min(1, Px-1))\n    if Px > rx > 0: i_indices.add(rx)\n    \n    j_indices = {0}\n    if Py > 1: j_indices.add(min(1, Py-1))\n    if Py > ry > 0: j_indices.add(ry)\n\n    proc_indices_to_check = set()\n    for i in i_indices:\n        for j in j_indices:\n            proc_indices_to_check.add((i,j))\n\n    best_delta = -1\n    min_T = float('inf')\n\n    for delta in range(d_max + 1):\n        # 1. Calculate number of iterations, n_iter(delta)\n        delta_eff = max(1, delta)\n        kappa = Ck * (1.0 + H / delta_eff)**2\n        \n        n_iter_base = 0.5 * np.sqrt(kappa) * ln_term\n        if delta == 0:\n            n_iter_base *= phi0\n        n_iter = np.ceil(n_iter_base)\n        \n        # 2. Calculate time per iteration, t_iter(delta)\n        max_t_iter = 0.0\n        for i, j in proc_indices_to_check:\n            nx_core = nxl if i  rx else nxs\n            ny_core = nyl if j  ry else nys\n            \n            num_x_neighbors = (1 if i > 0 else 0) + (1 if i  Px - 1 else 0)\n            num_y_neighbors = (1 if j > 0 else 0) + (1 if j  Py - 1 else 0)\n            \n            nx_ext = nx_core + delta * num_x_neighbors\n            ny_ext = ny_core + delta * num_y_neighbors\n            \n            nnbr = num_x_neighbors + num_y_neighbors\n            \n            t_comp = alpha * k * nx_ext * ny_ext\n            t_comm = lam * nnbr + nu * k * (2.0 * nx_ext + 2.0 * ny_ext)\n            \n            current_t = t_comp + t_comm\n            if current_t > max_t_iter:\n                max_t_iter = current_t\n\n        t_iter = max_t_iter\n        \n        # 3. Calculate total time T(delta) and find minimum\n        T_delta = n_iter * t_iter\n        \n        if T_delta  min_T:\n            min_T = T_delta\n            best_delta = delta\n            \n    return best_delta\n\nsolve()\n```"
        }
    ]
}