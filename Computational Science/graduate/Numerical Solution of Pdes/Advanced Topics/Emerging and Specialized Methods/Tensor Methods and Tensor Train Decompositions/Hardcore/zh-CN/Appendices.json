{
    "hands_on_practices": [
        {
            "introduction": "在处理高维问题时，“维度灾难”首先体现在存储需求上，一个$d$阶张量的元素数量会随着维度$d$和每个维度的尺寸$n$呈指数增长。张量链（TT）分解通过将高阶张量表示为一系列低阶核心张量的乘积，为我们提供了一种规避此问题的有效途径。本练习旨在通过直接计算和比较密集存储与TT表示的内存占用，让您亲手量化TT分解在节省存储方面的巨大优势 。",
            "id": "3453133",
            "problem": "考虑一个偏微分方程（PDE）解的高维离散化，得到一个阶为 $d$ 的张量 $u \\in \\mathbb{R}^{n \\times n \\times \\cdots \\times n}$，其中每个模使用相同的网格尺寸 $n$。张量链（TT）分解（也称为矩阵乘积态）通过核心 $G_k \\in \\mathbb{R}^{r_{k-1} \\times n \\times r_k}$（$k=1,\\ldots,d$）来表示 $u(i_1,\\ldots,i_d)$，其中 $r_k$ 为 TT 秩，$r_0 = r_d = 1$ 为边界秩，使得 $u(i_1,\\ldots,i_d)$ 是核心 $G_k$ 沿着物理指标 $i_k$ 的切片的乘积。\n\n从这些核心的定义出发，推导出以下各项的显式公式：\n1. 假设使用双精度浮点数存储（每个标量使用 $8$ 字节），存储 $u$ 所需的密集内存（以字节为单位）。\n2. 将核心 $\\{G_k\\}_{k=1}^d$ 存储为 $n$、$d$ 和秩 $\\{r_k\\}_{k=0}^d$ 的函数时所需的 TT 内存（以字节为单位）（同样，每个标量使用 $8$ 字节）。然后，在所有 $k$ 满足 $r_k \\leq 10$ 的约束下，通过选择秩以在满足 $r_0 = r_d = 1$ 的条件下最大化存储空间，推导出 TT 内存关于 $n$ 和 $d$ 的严格最坏情况上界。\n\n对于 $n=50$ 和 $d=6$，使用与 $r_k \\leq 10$ 一致的最坏情况秩分配来评估这些公式。以字节表示内存。将您的最终数值结果报告为一个包含三个条目的行矩阵：密集内存（字节）、TT 最坏情况内存（字节）以及精确的密集内存与 TT 内存之比（表示为最简分数）。不要对您的答案进行四舍五入。",
            "solution": "该问题陈述经评估有效。其科学依据充分、提法得当、客观，并包含推导唯一解而无矛盾所需的所有信息。我们开始求解。\n\n该问题要求推导高维张量在密集格式和张量链（TT）格式下的内存存储需求，然后对特定参数进行数值评估。\n\n**1. 密集存储内存计算**\n\n一个阶为 $d$、每个模的网格尺寸为 $n$ 的张量 $u \\in \\mathbb{R}^{n \\times n \\times \\cdots \\times n}$ 总共包含 $n^d$ 个标量元素。\n问题规定每个标量值都作为双精度浮点数存储，需要 $8$ 字节。\n因此，以密集格式存储张量 $u$ 所需的总内存（以字节为单位），记为 $M_{\\text{dense}}$，是元素数量与每个元素的字节数的乘积：\n$$\nM_{\\text{dense}} = 8 n^d\n$$\n\n**2. 张量链（TT）内存计算与最坏情况分析**\n\n张量链（TT）分解使用一组 $d$ 个核心 $\\{G_k\\}_{k=1}^d$ 来表示张量 $u$。每个核心 $G_k$ 是一个形状为 $r_{k-1} \\times n \\times r_k$ 的三阶张量。秩 $r_k$（$k=1, \\ldots, d-1$）是 TT 秩，边界秩固定为 $r_0 = 1$ 和 $r_d = 1$。\n\n单个核心 $G_k$ 中的标量元素数量是其维度的乘积：$r_{k-1} \\times n \\times r_k$。\nTT 表示中的总标量元素数量是所有核心中元素数量的总和。因此，TT 格式的总内存（以字节为单位）$M_{\\text{TT}}$ 为：\n$$\nM_{\\text{TT}} = 8 \\sum_{k=1}^{d} (r_{k-1} n r_k)\n$$\n我们可以提出公因式 $8$ 和 $n$：\n$$\nM_{\\text{TT}} = 8n \\sum_{k=1}^{d} r_{k-1} r_k\n$$\n这是 TT 内存存储的一般公式。\n\n接下来，我们必须在给定约束条件下找到该内存的严格最坏情况上界：$r_0=1$，$r_d=1$，以及对于所有内部秩 $k=1, \\ldots, d-1$，有 $r_k \\leq 10$。为了最大化 $M_{\\text{TT}}$，我们必须最大化和式 $\\sum_{k=1}^{d} r_{k-1} r_k$。让我们展开这个和式：\n$$\n\\sum_{k=1}^{d} r_{k-1} r_k = r_0 r_1 + r_1 r_2 + r_2 r_3 + \\cdots + r_{d-2} r_{d-1} + r_{d-1} r_d\n$$\n秩 $r_k$ 代表张量维度，因此是正整数。该和式是关于每个内部秩 $r_k$（$k \\in \\{1, \\ldots, d-1\\}$）的增函数。因此，为了最大化该和式，我们必须为每个这些秩选择可能的最大值，即 $r_k = 10$。\n\n代入边界条件 $r_0=1$，$r_d=1$ 以及最大化选择 $r_k=10$（对于 $k=1, \\ldots, d-1$）：\n第一项是 $r_0 r_1 = 1 \\times 10 = 10$。\n最后一项是 $r_{d-1} r_d = 10 \\times 1 = 10$。\n中间项，对于 $k=2, \\ldots, d-1$，均为 $r_{k-1} r_k = 10 \\times 10 = 100$。共有 $(d-1) - 2 + 1 = d-2$ 个这样的项。\n\n该和式的最大值为：\n$$\n\\left(\\sum_{k=1}^{d} r_{k-1} r_k\\right)_{\\max} = 10 + (d-2) \\times 100 + 10 = 20 + 100(d-2) = 100d - 180\n$$\n因此，TT 内存的最坏情况上界 $M_{\\text{TT, max}}$ 为：\n$$\nM_{\\text{TT, max}} = 8n (100d - 180)\n$$\n\n**3. 数值计算**\n\n我们被要求对 $n=50$ 和 $d=6$ 评估这些公式。\n\n首先，密集内存：\n$$\nM_{\\text{dense}} = 8 \\times 50^6 = 8 \\times (5 \\times 10)^6 = 8 \\times 5^6 \\times 10^6\n$$\n计算 $5^6$：$5^2=25$，$5^3=125$，$5^6 = (5^3)^2 = 125^2 = 15625$。\n$$\nM_{\\text{dense}} = 8 \\times 15625 \\times 10^6 = 125000 \\times 10^6 = 125,000,000,000 \\, \\text{字节}\n$$\n\n接下来，使用推导出的公式和 $n=50$、$d=6$ 计算最坏情况的 TT 内存：\n$$\nM_{\\text{TT, max}} = 8 \\times 50 \\times (100 \\times 6 - 180) = 400 \\times (600 - 180) = 400 \\times 420\n$$\n$$\nM_{\\text{TT, max}} = 168,000 \\, \\text{字节}\n$$\n\n最后，密集内存与 TT 内存之比：\n$$\n\\text{Ratio} = \\frac{M_{\\text{dense}}}{M_{\\text{TT, max}}} = \\frac{125,000,000,000}{168,000} = \\frac{125,000,000}{168}\n$$\n为了化简分数，我们可以将分子和分母同时除以它们的最大公约数。两者都可以被 $8$ 整除：\n$$\n\\frac{125,000,000 \\div 8}{168 \\div 8} = \\frac{15,625,000}{21}\n$$\n分母的质因数是 $3$ 和 $7$。分子的各位数字之和是 $1+5+6+2+5+0+0+0=19$，不能被 $3$ 整除。我们检查是否能被 $7$ 整除：$15625000 = 7 \\times 2232142 + 6$。它不能被 $7$ 整除。因此，该分数已是最简形式。\n\n所需的结果是：\n1. 密集内存：$125,000,000,000$ 字节，或 $1.25 \\times 10^{11}$ 字节。\n2. TT 最坏情况内存：$168,000$ 字节，或 $1.68 \\times 10^5$ 字节。\n3. 密集内存与 TT 内存之比：$\\frac{15,625,000}{21}$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1.25 \\times 10^{11} & 1.68 \\times 10^{5} & \\frac{15625000}{21} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "拥有一个紧凑的表示固然重要，但我们还需要能够高效地在此表示上执行计算。本练习将探讨如何在张量链（TT）格式下高效计算张量的Frobenius范数，这是许多算法（如误差估计和迭代求解器）中的一个基本操作。通过这个过程，您将发现正交化TT核心（一种“规范形式”）如何将一个看似全局的复杂计算简化为仅涉及最后一个核心的局部操作，从而深刻理解TT分解的算法优势 。",
            "id": "3453189",
            "problem": "考虑一个$d$维偏微分方程（PDE）解的离散近似，该近似定义在均匀笛卡尔网格上，每个空间维度有$n$个节点。该解表示为一个具有$d$个模态的张量$\\mathcal{X} \\in \\mathbb{R}^{n \\times \\cdots \\times n}$。假设$\\mathcal{X}$以张量链（TT）表示法（Tensor Train (TT)）给出，其核心为$\\{G^{(k)}\\}_{k=1}^{d}$，其中每个核心$G^{(k)} \\in \\mathbb{R}^{r_{k-1} \\times n \\times r_{k}}$满足$r_{0} = r_{d} = 1$，并且所有$k$的TT秩都遵循$r_{k} \\leq r$。对于索引$i_{k} \\in \\{1,\\dots,n\\}$，用$G^{(k)}(i_{k}) \\in \\mathbb{R}^{r_{k-1} \\times r_{k}}$表示第$k$个核心在模态索引$i_{k}$处的切片。$\\mathcal{X}$的弗罗贝尼乌斯范数定义为$\\|\\mathcal{X}\\|_{F} = \\left( \\sum_{i_{1}=1}^{n} \\cdots \\sum_{i_{d}=1}^{n} \\left( \\mathcal{X}_{i_{1},\\ldots,i_{d}} \\right)^{2} \\right)^{1/2}$。\n\n从TT参数化的核心定义和弗罗贝尼乌斯范数的定义出发，执行以下操作：\n\n- 推导一个用于计算$\\|\\mathcal{X}\\|_{F}$的算法收缩序列，该序列通过逐个模态地收缩TT核心来进行，并通过将算术复杂度界定为$O(d\\,n\\,r^{3})$来证明一般情况下的运算计数。\n\n- 现在假设直到第$(d-1)$个核心的TT核心都是左正交的，即对于每个$k \\in \\{1,\\ldots,d-1\\}$，左展开$G^{(k)}_{(1)} \\in \\mathbb{R}^{(r_{k-1} n) \\times r_{k}}$具有正交列，等价于$\\sum_{i_{k}=1}^{n} \\left( G^{(k)}(i_{k}) \\right)^{\\top} G^{(k)}(i_{k}) = I_{r_{k}}$。利用此正交性简化收缩序列，并将$\\|\\mathcal{X}\\|_{F}$的计算简化为一个仅涉及最后一个核心$G^{(d)}$元素的闭式表达式。\n\n作为最终答案，请提供$\\|\\mathcal{X}\\|_{F}$关于$G^{(d)}$元素的单个解析表达式。最终答案中不要提供任何中间步骤。",
            "solution": "该问题是有效的，因为它科学地基于张量链分解的既定理论，给出了所有必要的定义，问题阐述清晰，并且以客观的数学语言陈述。\n\n张量$\\mathcal{X} \\in \\mathbb{R}^{n \\times \\cdots \\times n}$的弗罗贝尼乌斯范数由其元素平方和的平方根给出。我们首先分析范数的平方：\n$$ \\|\\mathcal{X}\\|_{F}^{2} = \\sum_{i_{1}=1}^{n} \\cdots \\sum_{i_{d}=1}^{n} \\left( \\mathcal{X}_{i_{1},\\ldots,i_{d}} \\right)^{2} $$\n张量链 (TT) 表示法将每个元素$\\mathcal{X}_{i_{1},\\ldots,i_{d}}$表示为矩阵的乘积：\n$$ \\mathcal{X}_{i_{1},\\ldots,i_{d}} = G^{(1)}(i_{1}) G^{(2)}(i_{2}) \\cdots G^{(d)}(i_{d}) $$\n其中$G^{(k)}(i_{k})$是一个大小为$r_{k-1} \\times r_{k}$的矩阵。由于秩的约束$r_{0}=r_{d}=1$，该乘积是一个$1 \\times 1$矩阵，即一个标量。将TT表示代入范数表达式中得到：\n$$ \\|\\mathcal{X}\\|_{F}^{2} = \\sum_{i_{1}=1}^{n} \\cdots \\sum_{i_{d}=1}^{n} \\left( G^{(1)}(i_{1}) \\cdots G^{(d)}(i_{d}) \\right)^{2} $$\n这个表达式可以重写为张量与其自身共轭（由于张量是实数，即其自身）乘积的求和。通过重组求和，可以得到一种更易于计算的形式，这种形式可以优雅地表示为迭代收缩。令$P(i_{1},\\dots,i_{d}) = G^{(1)}(i_{1}) \\cdots G^{(d)}(i_{d})$。那么范数的平方为：\n$$ \\|\\mathcal{X}\\|_{F}^{2} = \\sum_{i_{1},\\dots,i_{d}} P(i_{1},\\dots,i_{d})^{\\top} P(i_{1},\\dots,i_{d}) = \\sum_{i_{1},\\dots,i_{d}} \\left( G^{(d)}(i_{d}) \\right)^{\\top} \\cdots \\left( G^{(1)}(i_{1}) \\right)^{\\top} G^{(1)}(i_{1}) \\cdots G^{(d)}(i_{d}) $$\n由于矩阵乘法的结合律和乘法对加法的分配律，我们可以重新排列运算顺序。我们定义一个矩阵序列$\\{C_{k}\\}_{k=0}^{d}$，其中$C_{k} \\in \\mathbb{R}^{r_{k} \\times r_{k}}$，通过从左到右的扫描计算得出：\n初始化为$C_{0} = I_{r_0} = [1]$，一个$1 \\times 1$的单位矩阵。\n对于$k = 1, 2, \\ldots, d$，计算：\n$$ C_{k} = \\sum_{i_{k}=1}^{n} \\left( G^{(k)}(i_{k}) \\right)^{\\top} C_{k-1} G^{(k)}(i_{k}) $$\n通过展开这个递推关系，我们可以验证它能正确计算范数的平方：\n$$ C_{d} = \\sum_{i_{d}=1}^{n} \\left( G^{(d)}(i_{d}) \\right)^{\\top} C_{d-1} G^{(d)}(i_{d}) = \\sum_{i_{d}=1}^{n} \\left( G^{(d)}(i_{d}) \\right)^{\\top} \\left( \\sum_{i_{d-1}=1}^{n} \\left( G^{(d-1)}(i_{d-1}) \\right)^{\\top} C_{d-2} G^{(d-1)}(i_{d-1}) \\right) G^{(d)}(i_{d}) $$\n$$ C_{d} = \\sum_{i_{1},\\dots,i_{d}} \\left( G^{(d)}(i_{d}) \\right)^{\\top} \\cdots \\left( G^{(1)}(i_{1}) \\right)^{\\top} C_{0} G^{(1)}(i_{1}) \\cdots G^{(d)}(i_{d}) $$\n由于$C_{0}=[1]$，这正是$\\|\\mathcal{X}\\|_{F}^{2}$的表达式。最终结果是$1 \\times 1$矩阵$C_{d}$的单个元素。\n\n### 算法复杂度\n\n这个过程的计算复杂度由迭代中每一步的成本决定。在第$k$步，我们从$C_{k-1}$计算$C_{k}$。矩阵$C_{k-1}$的维度是$r_{k-1} \\times r_{k-1}$，每个矩阵切片$G^{(k)}(i_{k})$的维度是$r_{k-1} \\times r_{k}$。\n对于每个物理索引$i_{k} \\in \\{1,\\dots,n\\}$，项$\\left( G^{(k)}(i_{k}) \\right)^{\\top} C_{k-1} G^{(k)}(i_{k})$的计算可以用两种方式加括号。一种更高效的方式是：\n1.  计算中间矩阵乘积$T_{i_k} = C_{k-1} G^{(k)}(i_{k})$。这是一个$(r_{k-1} \\times r_{k-1})$矩阵和一个$(r_{k-1} \\times r_{k})$矩阵的乘积，需要$O(r_{k-1}^{2} r_{k})$次算术运算。结果$T_{i_k}$是一个$(r_{k-1} \\times r_{k})$矩阵。\n2.  计算乘积$\\left( G^{(k)}(i_{k}) \\right)^{\\top} T_{i_k}$。这是一个$(r_{k} \\times r_{k-1})$矩阵和一个$(r_{k-1} \\times r_{k})$矩阵的乘积，需要$O(r_{k-1} r_{k}^{2})$次运算。\n因此，对于单个$i_{k}$的成本是$O(r_{k-1}^{2} r_{k} + r_{k-1} r_{k}^{2})$。对所有$n$个切片重复此操作，并将结果相加。计算$C_{k}$的总成本是$O(n(r_{k-1}^{2} r_{k} + r_{k-1} r_{k}^{2}))$。\n给定秩的一致上界$r_k \\leq r$（对于所有$k$），第$k$步的成本界定为$O(n(r^{3} + r^{3})) = O(n r^{3})$。由于这个迭代执行$d$次（对于$k=1, \\ldots, d$），计算$\\|\\mathcal{X}\\|_{F}$的总复杂度为$O(d n r^{3})$。\n\n### 使用正交核心进行简化\n\n现在，我们假设对于$k=1, \\ldots, d-1$的核心$G^{(k)}$是左正交的。该条件给出如下：\n$$ \\sum_{i_{k}=1}^{n} \\left( G^{(k)}(i_{k}) \\right)^{\\top} G^{(k)}(i_{k}) = I_{r_{k}} $$\n其中$I_{r_{k}}$是$r_{k} \\times r_{k}$的单位矩阵。我们现在在此条件下重新评估矩阵序列$C_{k}$。\n基础情况是$C_{0} = I_{r_{0}} = [1]$。对于$k=1$：\n$$ C_{1} = \\sum_{i_{1}=1}^{n} \\left( G^{(1)}(i_{1}) \\right)^{\\top} C_{0} G^{(1)}(i_{1}) = \\sum_{i_{1}=1}^{n} \\left( G^{(1)}(i_{1}) \\right)^{\\top} I_{r_0} G^{(1)}(i_{1}) = \\sum_{i_{1}=1}^{n} \\left( G^{(1)}(i_{1}) \\right)^{\\top} G^{(1)}(i_{1}) $$\n由于$1 \\leq d-1$，我们可以对$k=1$应用左正交性条件，这得到$C_{1} = I_{r_{1}}$。\n\n我们通过归纳法进行。假设对于某个$k-1$（其中$1 \\leq k-1  d-1$），我们有$C_{k-1} = I_{r_{k-1}}$。\n那么对于第$k$步：\n$$ C_{k} = \\sum_{i_{k}=1}^{n} \\left( G^{(k)}(i_{k}) \\right)^{\\top} C_{k-1} G^{(k)}(i_{k}) = \\sum_{i_{k}=1}^{n} \\left( G^{(k)}(i_{k}) \\right)^{\\top} I_{r_{k-1}} G^{(k)}(i_{k}) = \\sum_{i_{k}=1}^{n} \\left( G^{(k)}(i_{k}) \\right)^{\\top} G^{(k)}(i_{k}) $$\n由于$k \\leq d-1$，左正交性条件适用，我们得到$C_{k} = I_{r_{k}}$。\n通过归纳法，我们已经确定对于所有$k \\in \\{1, \\ldots, d-1\\}$，都有$C_{k} = I_{r_{k}}$。\n\n最后，我们计算$C_{d}$，它对应于$\\|\\mathcal{X}\\|_{F}^{2}$。正交性条件不一定适用于最后一个核心$G^{(d)}$。\n$$ \\|\\mathcal{X}\\|_{F}^{2} = C_{d} = \\sum_{i_{d}=1}^{n} \\left( G^{(d)}(i_{d}) \\right)^{\\top} C_{d-1} G^{(d)}(i_{d}) $$\n使用我们的结果$C_{d-1} = I_{r_{d-1}}$，这可以简化为：\n$$ \\|\\mathcal{X}\\|_{F}^{2} = \\sum_{i_{d}=1}^{n} \\left( G^{(d)}(i_{d}) \\right)^{\\top} I_{r_{d-1}} G^{(d)}(i_{d}) = \\sum_{i_{d}=1}^{n} \\left( G^{(d)}(i_{d}) \\right)^{\\top} G^{(d)}(i_{d}) $$\n此表达式是最后一个核心$G^{(d)}$的弗罗贝尼乌斯范数平方的定义，该核心被解释为一个大小为$(r_{d-1} \\times n)$的矩阵，且最后一个秩索引$r_d=1$被省略。具体来说，如果我们用$G^{(d)}_{\\alpha_{d-1}, i_d, \\alpha_d}$表示张量$G^{(d)}$的元素，其中$\\alpha_{d-1} \\in \\{1,\\dots,r_{d-1}\\}$，$i_d \\in \\{1,\\dots,n\\}$，且$\\alpha_d \\in \\{1\\}$，则：\n$$ \\|\\mathcal{X}\\|_{F}^{2} = \\sum_{i_{d}=1}^{n} \\sum_{\\alpha_{d-1}=1}^{r_{d-1}} \\left( G^{(d)}_{\\alpha_{d-1}, i_d, 1} \\right)^{2} $$\n这正是最后一个核心的弗罗贝尼乌斯范数的平方，即$\\|G^{(d)}\\|_{F}^{2}$。\n因此，整个张量$\\mathcal{X}$的范数就是其最后一个核心的弗罗贝尼乌斯范数：\n$$ \\|\\mathcal{X}\\|_{F} = \\|G^{(d)}\\|_{F} $$\n对$G^{(d)}$的元素平方和取平方根即可得到最终表达式。",
            "answer": "$$\\boxed{\\left( \\sum_{i_{d}=1}^{n} \\sum_{\\alpha_{d-1}=1}^{r_{d-1}} \\left(G^{(d)}_{\\alpha_{d-1}, i_{d}, 1}\\right)^{2} \\right)^{1/2}}$$"
        },
        {
            "introduction": "在数值计算中，任何近似方法的可信度都取决于我们对其误差的理解和控制能力。张量链（TT）分解本质上是一种近似，而TT-SVD（或称TT舍入）是控制其秩和精度的标准算法。本练习将引导您深入探讨TT近似的精度保证，通过推导TT舍入过程的全局Frobenius范数误差界，揭示局部截断容差如何控制全局近似误差，这是在实际应用中平衡计算成本和数值精度的关键 。",
            "id": "3453148",
            "problem": "考虑一个在高维参数化椭圆偏微分方程，该方程在张量积网格上离散化，从而得到离散解的 $d$ 阶张量表示。设 $\\mathcal{U} \\in \\mathbb{R}^{n_{1} \\times \\cdots \\times n_{d}}$ 和 $\\mathcal{V} \\in \\mathbb{R}^{n_{1} \\times \\cdots \\times n_{d}}$ 是两个张量，表示对应于两个不同源项的近似离散解，两者均以张量链（TT）格式存储。假设两个TT表示都是左正交化的，这意味着除了最后一个核之外，所有核都是等距的，即它们的矩阵化形式具有标准正交的列。\n\n您通过标准的TT加法程序以TT格式构成了精确和 $\\mathcal{W} = \\mathcal{U} + \\mathcal{V}$，该程序通过对核进行块级联来增加中间秩。然后，您对 $\\mathcal{W}$ 应用TT舍入，在 $d-1$ 个展开中的每一个上使用奇异值分解（SVD）截断，并在弗罗贝尼乌斯范数下使用统一的截断容差 $\\tau$。TT舍入包括通过标准正交变换进行的顺序正交化，然后是对每个展开进行SVD截断。\n\n仅从弗罗贝尼乌斯范数的定义、左正交TT核的等距性，以及通过丢弃奇异值来截断矩阵的SVD会产生一个近似误差（其弗罗贝尼乌斯范数等于被丢弃奇异值平方和的平方根）这一事实出发，推导全局弗罗贝尼乌斯范数舍入误差 $\\|\\mathcal{W} - \\operatorname{round}_{\\mathrm{TT}}(\\mathcal{W})\\|_{F}$ 的一个显式界，该界用维度 $d$ 和每个展开的统一容差 $\\tau$ 表示。\n\n然后，对于 $d = 10$ 和 $\\tau = 3.5 \\times 10^{-8}$ 的情况，计算这个界。将您最终的数值界四舍五入到四位有效数字。",
            "solution": "用户希望推导并评估张量链（TT）舍入的弗罗贝尼乌斯范数误差的一个界。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- 一个 $d$ 阶张量 $\\mathcal{W} = \\mathcal{U} + \\mathcal{V} \\in \\mathbb{R}^{n_{1} \\times \\cdots \\times n_{d}}$。\n- $\\mathcal{U}$ 和 $\\mathcal{V}$ 是以左正交化的张量链（TT）格式存储的近似离散解。\n- $\\mathcal{W}$ 是通过标准的TT加法程序构成的。\n- 对 $\\mathcal{W}$ 应用TT舍入以获得 $\\operatorname{round}_{\\mathrm{TT}}(\\mathcal{W})$。\n- 舍入过程在 $d-1$ 个展开中的每一个上使用奇异值分解（SVD）截断。\n- 在每一步 $k$ 的截断是在弗罗贝尼乌斯范数下以统一容差 $\\tau$ 执行的，这意味着该步骤中矩阵近似的误差最多为 $\\tau$。\n- 舍入算法包括顺序正交化和SVD截断。\n- 推导必须从以下定义开始：\n    1. 弗罗贝尼乌斯范数。\n    2. 左正交TT核的等距性。\n    3. SVD截断误差：误差的弗罗贝尼乌斯范数等于被丢弃奇异值平方和的平方根。\n- 任务1：推导全局弗罗贝尼乌斯范数舍入误差 $\\|\\mathcal{W} - \\operatorname{round}_{\\mathrm{TT}}(\\mathcal{W})\\|_{F}$ 的一个显式界，用 $d$ 和 $\\tau$ 表示。\n- 任务2：对于 $d = 10$ 和 $\\tau = 3.5 \\times 10^{-8}$ 的情况，计算这个界。\n- 任务3：将最终数值结果四舍五入到四位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题设置在偏微分方程数值方法的背景下，特别使用了张量分解。所有概念——张量链（TT）格式、弗罗贝尼乌斯范数、SVD、舍入算法、正交性——在数值线性代数和科学计算中都是标准且明确定义的。该问题在科学上和数学上都是合理的。\n- **适定性：** 该问题要求推导一个已知的理论界并进行数值评估。前提条件清晰且足以得出唯一结果。\n- **客观性：** 语言正式，没有主观性或偏见。\n- **完整性和一致性：** 该问题提供了所有必要的定义和约束。对TT舍入（带有指定容差的顺序正交化和SVD截断）的描述与标准的TT-SVD算法相对应，该算法的误差界是公认的。该问题是自洽且一致的。\n\n**步骤3：结论与行动**\n该问题是有效的。将提供一个完整的解决方案。\n\n### 解答\n\n设 $\\mathcal{W} \\in \\mathbb{R}^{n_1 \\times \\cdots \\times n_d}$ 是待舍入的张量，设 $\\tilde{\\mathcal{W}} = \\operatorname{round}_{\\mathrm{TT}}(\\mathcal{W})$ 是其舍入后的近似。TT舍入算法，通常称为TT-SVD，会生成一个中间张量近似序列。我们将此序列表示为 $\\mathcal{W}^{(0)}, \\mathcal{W}^{(1)}, \\dots, \\mathcal{W}^{(d-1)}$，其中 $\\mathcal{W}^{(0)} = \\mathcal{W}$ 且最终结果为 $\\tilde{\\mathcal{W}} = \\mathcal{W}^{(d-1)}$。每个张量 $\\mathcal{W}^{(k)}$ 是通过在第 $k$ 个接口（在模 $k$ 和 $k+1$ 之间）对 $\\mathcal{W}^{(k-1)}$ 进行截断过程得到的。\n\n总舍入误差是初始张量和最终张量之差，可以表示为一个伸缩求和：\n$$\n\\mathcal{E} = \\mathcal{W} - \\tilde{\\mathcal{W}} = \\mathcal{W}^{(0)} - \\mathcal{W}^{(d-1)} = \\sum_{k=1}^{d-1} (\\mathcal{W}^{(k-1)} - \\mathcal{W}^{(k)})\n$$\n我们将第 $k$ 步引入的误差定义为 $\\mathcal{E}_k = \\mathcal{W}^{(k-1)} - \\mathcal{W}^{(k)}$。那么，总误差为 $\\mathcal{E} = \\sum_{k=1}^{d-1} \\mathcal{E}_k$。\n\n标准的TT-SVD舍入算法的设计使得在不同步骤引入的误差关于弗罗贝尼乌斯内积 $\\langle \\mathcal{A}, \\mathcal{B} \\rangle_F = \\sum_{i_1,\\dots,i_d} A_{i_1\\dots i_d} B_{i_1\\dots i_d}$ 是正交的。具体来说，对于 $i \\neq j$，有 $\\langle \\mathcal{E}_i, \\mathcal{E}_j \\rangle_F = 0$。这种正交性源于在第 $k$ 步，$\\mathcal{W}^{(k)}$ 是在第 $k$ 个接口具有较低秩的张量集合中，对 $\\mathcal{W}^{(k-1)}$ 在弗罗贝尼乌斯范数下的最佳近似。这意味着误差 $\\mathcal{E}_k = \\mathcal{W}^{(k-1)} - \\mathcal{W}^{(k)}$ 与这类低秩张量的空间正交，而 $\\mathcal{W}^{(k)}$ 就属于这个空间。所有后续的近似 $\\mathcal{W}^{(j)}$（对于 $j  k$）以及所有后续的误差 $\\mathcal{E}_j$ 也都属于这个空间。因此，对于所有 $jk$，$\\mathcal{E}_k$ 与 $\\mathcal{E}_j$ 正交。\n\n由于这种正交性，总误差的弗罗贝尼乌斯范数的平方等于各个误差范数的平方和（毕达哥拉斯定理的推广）：\n$$\n\\|\\mathcal{W} - \\tilde{\\mathcal{W}}\\|_{F}^2 = \\left\\| \\sum_{k=1}^{d-1} \\mathcal{E}_k \\right\\|_{F}^2 = \\sum_{k=1}^{d-1} \\|\\mathcal{E}_k\\|_{F}^2\n$$\n\n接下来，我们必须界定每一步的误差范数 $\\|\\mathcal{E}_k\\|_{F}$。TT-SVD算法通过一系列正交化和SVD截断进行。一个典型的实现涉及从右到左的扫描，以使核 $G_{d}, G_{d-1}, \\dots, G_2$ 右正交，然后是从左到右的扫描进行截断。\n在从左到右扫描的第 $k$ 步（$k=1, \\dots, d-1$），算法已经为新张量 $\\tilde{\\mathcal{W}}$ 生成了左正交的核 $\\tilde{G}_1, \\dots, \\tilde{G}_{k-1}$。第 $k$ 步的程序涉及处理一个从当前张量状态派生出的矩阵 $M_k$。然后使用SVD将该矩阵截断为 $\\tilde{M}_k$，使得截断误差受容差 $\\tau$ 的限制：\n$$\n\\|M_k - \\tilde{M}_k\\|_F \\le \\tau\n$$\n这一步的误差张量 $\\mathcal{E}_k$ 实际上是由这个矩阵误差 $M_k - \\tilde{M}_k$ 与周围的核结合构造的。该算法的关键特性是，截断点之前的核是左等距的，而其后的核是右等距的（来自初始的正交化扫描）。等距是一种保持范数的线性映射。在TT分解的背景下，左正交和右正交的核作为等距算子作用于张量的剩余部分，保持其弗罗贝尼乌斯范数。\n因此，误差张量 $\\mathcal{E}_k$ 的弗罗贝尼乌斯范数等于产生它的矩阵误差的弗罗贝尼乌斯范数：\n$$\n\\|\\mathcal{E}_k\\|_F = \\|\\mathcal{W}^{(k-1)} - \\mathcal{W}^{(k)}\\|_F = \\|M_k - \\tilde{M}_k\\|_F\n$$\n因此，对于每一步 $k$，我们有：\n$$\n\\|\\mathcal{E}_k\\|_F \\le \\tau\n$$\n将此代入总误差范数的平方和公式中：\n$$\n\\|\\mathcal{W} - \\tilde{\\mathcal{W}}\\|_{F}^2 = \\sum_{k=1}^{d-1} \\|\\mathcal{E}_k\\|_{F}^2 \\le \\sum_{k=1}^{d-1} \\tau^2 = (d-1)\\tau^2\n$$\n对两边取平方根，得到全局弗罗贝尼乌斯范数舍入误差的所需显式界：\n$$\n\\|\\mathcal{W} - \\operatorname{round}_{\\mathrm{TT}}(\\mathcal{W})\\|_{F} \\le \\sqrt{d-1} \\tau\n$$\n\n现在，我们为给定的参数 $d=10$ 和 $\\tau = 3.5 \\times 10^{-8}$ 计算这个界。\n该界由以下公式给出：\n$$\n\\text{误差界} = \\sqrt{10-1} \\times (3.5 \\times 10^{-8})\n$$\n$$\n\\text{误差界} = \\sqrt{9} \\times (3.5 \\times 10^{-8})\n$$\n$$\n\\text{误差界} = 3 \\times 3.5 \\times 10^{-8}\n$$\n$$\n\\text{误差界} = 10.5 \\times 10^{-8}\n$$\n用标准科学记数法表示：\n$$\n\\text{误差界} = 1.05 \\times 10^{-7}\n$$\n问题要求最终答案四舍五入到四位有效数字。\n$$\n\\text{误差界} \\approx 1.050 \\times 10^{-7}\n$$\n这是误差界的最终数值。",
            "answer": "$$\\boxed{1.050 \\times 10^{-7}}$$"
        }
    ]
}