{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any finite element-type method is the ability to compute integrals over the problem domain. In Isogeometric Analysis (IGA), this is accomplished by transforming integrals from the complex physical domain to a simple, structured parametric domain. This hands-on coding exercise  walks you through this fundamental process, where you will use Gaussian quadrature and the Jacobian of the NURBS map, whose determinant is $|\\det J|$, to accurately compute surface area, gaining practical experience with the change of variables formula.",
            "id": "3411147",
            "problem": "You are tasked with implementing element-wise numerical integration over a surface patch parameterized by Non-Uniform Rational B-Splines (NURBS). Starting from the pullback of area integrals through a differentiable mapping, derive and implement a program that computes the surface integral of a constant scalar field using Gaussian quadrature and explicitly quantifies how curvature affects quadrature weights via the Jacobian determinant. Your implementation must use a single tensor-product NURBS surface with a quadratic basis in the angular direction and a linear basis in the radial direction, and it must treat the mapping from the parametric square to the physical plane exactly according to the differentiable mapping rules.\n\nFundamental base:\n- A surface patch is defined by a smooth mapping $S : [0,1]^2 \\to \\mathbb{R}^2$, where $(u,v) \\in [0,1]^2$ are parametric coordinates and $(x,y) = S(u,v)$ are physical coordinates.\n- The change-of-variables formula for surface area integrals states that, for a scalar field $f(x,y)$,\n$$\n\\int_{\\Omega} f(x,y) \\, dA = \\int_{[0,1]^2} f(S(u,v)) \\, \\left|\\det J(u,v)\\right| \\, du \\, dv,\n$$\nwhere $J(u,v)$ is the Jacobian matrix of partial derivatives of $S$ with respect to $(u,v)$ and $\\left|\\det J(u,v)\\right|$ is the absolute value of its determinant.\n- Non-Uniform Rational B-Splines (NURBS) surfaces are constructed from tensor-product rational basis functions. For degrees $p$ in $u$ and $q$ in $v$, define polynomial B-Spline basis functions $N_i(u)$ and $M_j(v)$ for $i=0,\\dots,p$ and $j=0,\\dots,q$, and positive weights $w_{ij}$. The rational basis functions are\n$$\nR_{ij}(u,v) = \\frac{N_i(u) M_j(v) w_{ij}}{W(u,v)}, \\quad W(u,v) = \\sum_{a=0}^{p}\\sum_{b=0}^{q} N_a(u) M_b(v) w_{ab}.\n$$\nThe surface mapping is then\n$$\nS(u,v) = \\sum_{i=0}^{p}\\sum_{j=0}^{q} R_{ij}(u,v) \\, P_{ij},\n$$\nwhere $P_{ij} \\in \\mathbb{R}^2$ are the control points.\n- Gaussian quadrature approximates integrals by a weighted sum of function evaluations at specific nodes. For each parametric direction, use $n_u$ and $n_v$ nodes with weights, and form the tensor-product quadrature for $[0,1]^2$.\n\nRequirements:\n1. Construct a single tensor-product NURBS surface with quadratic basis in the $u$-direction ($p=2$) and linear basis in the $v$-direction ($q=1$). Use clamped knot vectors corresponding to a single element, so the polynomial basis reduces to Bernstein polynomials over $[0,1]$:\n   - In the $u$-direction, use the quadratic Bernstein polynomials on $[0,1]$: $N_0(u)$, $N_1(u)$, $N_2(u)$.\n   - In the $v$-direction, use the linear Bernstein polynomials on $[0,1]$: $M_0(v)$, $M_1(v)$.\n   Provide a consistent definition of their first derivatives with respect to $u$ and $v$.\n2. Define a quarter-annulus geometry in the plane by a tensor-product of a circular arc and a radial segment. The $u$-direction corresponds to the angular coordinate from $0$ to $\\pi/2$, and the $v$-direction corresponds to the radial coordinate. Use a $3 \\times 2$ grid of control points:\n   - For each radius $r \\in \\{r_{\\mathrm{in}}, r_{\\mathrm{out}}\\}$, set\n     $P_{0,\\cdot}(r) = (r, 0)$,\n     $P_{1,\\cdot}(r) = (r, r)$,\n     $P_{2,\\cdot}(r) = (0, r)$,\n     where the $\\cdot$ indicates the two radial positions $r=r_{\\mathrm{in}}$ and $r=r_{\\mathrm{out}}$.\n   - For rational weights along the circular arc, use $(w_{0,\\cdot}, w_{1,\\cdot}, w_{2,\\cdot}) = \\left(1, \\frac{1}{\\sqrt{2}}, 1\\right)$, repeated for both radial positions. This exactly represents a circular arc in the $u$-direction.\n3. Compute the Jacobian matrix $J(u,v)$ via the first derivatives of $S(u,v)$ with respect to $u$ and $v$, obtained from the rational basis and the control points.\n4. Implement tensor-product Gaussian quadrature with $n_u = 5$ nodes in $u$ and $n_v = 5$ nodes in $v$, mapped from $[-1,1]$ to $[0,1]$, and use these to approximate the integral of the constant scalar field $f(x,y)=1$ over the physical surface.\n5. Quantify the effect of curved geometry on quadrature weights by computing the extremal values of $\\left|\\det J(u,v)\\right|$ over all quadrature nodes.\n6. Implement the following test suite of parameter sets, and for each test case compute:\n   - The approximate area $A \\approx \\sum w_u w_v \\left|\\det J(u,v)\\right|$.\n   - The minimum and maximum of $\\left|\\det J(u,v)\\right|$ across all quadrature points.\n   Use these cases:\n   - Case 1 (Happy path, rational circular annulus): $r_{\\mathrm{in}} = 1.0$, $r_{\\mathrm{out}} = 2.0$, weights $(1, 1/\\sqrt{2}, 1)$.\n   - Case 2 (Polynomial, non-rational geometry): $r_{\\mathrm{in}} = 1.0$, $r_{\\mathrm{out}} = 2.0$, weights $(1, 1, 1)$.\n   - Case 3 (Boundary case, degenerate annulus): $r_{\\mathrm{in}} = 1.5$, $r_{\\mathrm{out}} = 1.5$, weights $(1, 1/\\sqrt{2}, 1)$.\n7. Final output format: Your program should produce a single line of output containing a comma-separated list of three sublists, each sublist corresponding to one test case in order, and containing three floating-point numbers $[A, \\min|\\det J|, \\max|\\det J|]$. For example: \"[[A1,min1,max1],[A2,min2,max2],[A3,min3,max3]]\". Express all numbers as unitless floats.\n\nYour program must be self-contained and runnable as is, taking no input, and it must adhere to the specified execution environment and libraries.",
            "solution": "The user-provided problem is assessed as **valid** following a rigorous validation process. The problem is scientifically grounded in differential geometry and numerical analysis, well-posed with a clear objective and sufficient data, and structured objectively. It asks for a standard, verifiable computation in the field of isogeometric analysis.\n\nThe solution proceeds by first deriving the necessary mathematical formulations for the NURBS surface and its derivatives, and then implementing a numerical algorithm to compute the required quantities.\n\n**1. NURBS Surface Parameterization and Basis Functions**\n\nA NURBS surface is defined by a mapping $S(u,v)$ from a parametric domain, here chosen as the unit square $[0,1]^2$, to the physical domain in $\\mathbb{R}^2$. The mapping is a rational function given by:\n$$ S(u,v) = \\frac{\\sum_{i=0}^{p}\\sum_{j=0}^{q} N_i(u) M_j(v) w_{ij} P_{ij}}{\\sum_{a=0}^{p}\\sum_{b=0}^{q} N_a(u) M_b(v) w_{ab}} $$\nwhere $P_{ij} \\in \\mathbb{R}^2$ are the control points, $w_{ij} > 0$ are their associated weights, and $N_i(u)$ and $M_j(v)$ are the B-spline basis functions of degree $p$ and $q$, respectively.\n\nFor this problem, a single patch is considered using clamped knot vectors, which simplifies the B-spline basis functions to Bernstein polynomials.\nThe degrees are specified as $p=2$ (quadratic) in the $u$-direction and $q=1$ (linear) in the $v$-direction.\n\nThe basis functions and their first derivatives are:\n- In the $u$-direction (quadratic Bernstein polynomials on $[0,1]$):\n  - $N_0(u) = (1-u)^2$\n  - $N_1(u) = 2u(1-u)$\n  - $N_2(u) = u^2$\n  - $N_0'(u) = -2(1-u)$\n  - $N_1'(u) = 2 - 4u$\n  - $N_2'(u) = 2u$\n\n- In the $v$-direction (linear Bernstein polynomials on $[0,1]$):\n  - $M_0(v) = 1-v$\n  - $M_1(v) = v$\n  - $M_0'(v) = -1$\n  - $M_1'(v) = 1$\n\n**2. Surface Derivatives and the Jacobian Matrix**\n\nTo compute the surface area, we require the Jacobian of the mapping $S(u,v)$. Let us define the vector-valued numerator and scalar-valued denominator of $S(u,v)$ as:\n$$ \\mathbf{A}(u,v) = \\sum_{i=0}^{2}\\sum_{j=0}^{1} N_i(u) M_j(v) w_{ij} P_{ij} $$\n$$ W(u,v) = \\sum_{i=0}^{2}\\sum_{j=0}^{1} N_i(u) M_j(v) w_{ij} $$\nThe partial derivatives of the surface mapping $S(u,v) = \\mathbf{A}(u,v) / W(u,v)$ are found using the quotient rule:\n$$ \\frac{\\partial S}{\\partial u} = \\frac{1}{W^2} \\left( W \\frac{\\partial \\mathbf{A}}{\\partial u} - \\mathbf{A} \\frac{\\partial W}{\\partial u} \\right) \\quad \\text{and} \\quad \\frac{\\partial S}{\\partial v} = \\frac{1}{W^2} \\left( W \\frac{\\partial \\mathbf{A}}{\\partial v} - \\mathbf{A} \\frac{\\partial W}{\\partial v} \\right) $$\nThe derivatives of $\\mathbf{A}(u,v)$ and $W(u,v)$ are found by differentiating their respective sums term-by-term:\n$$ \\frac{\\partial \\mathbf{A}}{\\partial u} = \\sum_{i=0}^{2}\\sum_{j=0}^{1} N_i'(u) M_j(v) w_{ij} P_{ij} \\quad \\text{and} \\quad \\frac{\\partial W}{\\partial u} = \\sum_{i=0}^{2}\\sum_{j=0}^{1} N_i'(u) M_j(v) w_{ij} $$\n$$ \\frac{\\partial \\mathbf{A}}{\\partial v} = \\sum_{i=0}^{2}\\sum_{j=0}^{1} N_i(u) M_j'(v) w_{ij} P_{ij} \\quad \\text{and} \\quad \\frac{\\partial W}{\\partial v} = \\sum_{i=0}^{2}\\sum_{j=0}^{1} N_i(u) M_j'(v) w_{ij} $$\nThe Jacobian matrix $J(u,v)$ is formed by the partial derivative vectors, which are tangent to the surface along the parametric grid lines:\n$$ J(u,v) = \\begin{bmatrix} \\frac{\\partial S_x}{\\partial u}  \\frac{\\partial S_x}{\\partial v} \\\\ \\frac{\\partial S_y}{\\partial u}  \\frac{\\partial S_y}{\\partial v} \\end{bmatrix} $$\nThe absolute value of its determinant, $|\\det J(u,v)|$, is the local area scaling factor between the parametric and physical domains.\n\n**3. Numerical Integration via Gaussian Quadrature**\n\nThe area of the surface patch, which is the integral of the constant scalar field $f(x,y)=1$, is computed by a change of variables to the parametric domain:\n$$ \\mathrm{Area} = \\int_{\\Omega} 1 \\, dA = \\int_{0}^{1}\\int_{0}^{1} |\\det J(u,v)| \\, du \\, dv $$\nThis two-dimensional integral is approximated numerically using a tensor-product Gauss-Legendre quadrature rule. For the specified $n_u = 5$ nodes in $u$ and $n_v = 5$ nodes in $v$, we first obtain the standard quadrature points $\\{\\xi_k\\}$ and weights $\\{\\omega_k\\}$ for the interval $[-1,1]$. These are mapped to the integration interval $[0,1]$ via the affine transformation $u_k = (\\xi_k + 1)/2$. The corresponding quadrature weights must be scaled by the Jacobian of this transformation, which is $1/2$. Thus, the weights for the $[0,1]$ interval are $w_{u_k} = \\omega_k/2$. The area is then approximated by the discrete sum:\n$$ \\mathrm{Area} \\approx \\sum_{k=1}^{n_u} \\sum_{l=1}^{n_v} w_{u_k} w_{v_l} |\\det J(u_k, v_l)| $$\nwhere $(u_k, v_l)$ are the mapped quadrature points.\n\n**4. Algorithmic Implementation Steps**\n\nThe overall algorithm proceeds as follows for each test case:\n1.  **Initialize Geometry:** Construct the $3 \\times 2$ grid of control points $P_{ij}$ and the corresponding $3 \\times 2$ matrix of weights $w_{ij}$ from the specified radii and weight vector.\n2.  **Prepare Quadrature:** Obtain the $5$ Gauss-Legendre nodes and weights on $[-1,1]$ and map them to create the quadrature rule for the $[0,1]^2$ domain.\n3.  **Integration Loop:** Iterate through the $n_u \\times n_v = 25$ quadrature points $(u_k, v_l)$. At each point:\n    a. Evaluate the Bernstein basis functions $N_i(u_k)$, $M_j(v_l)$ and their derivatives $N_i'(u_k)$, $M_j'(v_l)$.\n    b. Compute $W$ and $\\mathbf{A}$ and their partial derivatives with respect to $u$ and $v$ by summing the contributions from all basis functions, weights, and control points.\n    c. Apply the quotient rule to find the tangent vectors $\\frac{\\partial S}{\\partial u}$ and $\\frac{\\partial S}{\\partial v}$.\n    d. Calculate the determinant of the Jacobian matrix, $\\det J(u_k, v_l)$.\n    e. Add the weighted contribution $w_{u_k} w_{v_l} |\\det J(u_k, v_l)|$ to a running total for the area.\n    f. Store the value of $|\\det J(u_k, v_l)|$ for subsequent analysis.\n4.  **Aggregate Results:** After the loop, the accumulated sum yields the approximate area $A$. The minimum and maximum values from the stored list of Jacobian determinants are found.\n\nThis procedure is executed for all specified test cases to generate the final results. The variation in $|\\det J|$ across the quadrature points provides a quantitative measure of the geometric distortion introduced by the NURBS mapping.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the area and Jacobian determinant statistics for NURBS surfaces.\n    \"\"\"\n    # Test cases: (r_in, r_out, weights_u)\n    test_cases = [\n        (1.0, 2.0, np.array([1.0, 1.0 / np.sqrt(2.0), 1.0])),\n        (1.0, 2.0, np.array([1.0, 1.0, 1.0])),\n        (1.5, 1.5, np.array([1.0, 1.0 / np.sqrt(2.0), 1.0])),\n    ]\n\n    # Gaussian quadrature parameters for a 5-point rule\n    n_points = 5\n    gauss_points, gauss_weights = np.polynomial.legendre.leggauss(n_points)\n\n    # Map nodes and weights from [-1, 1] to [0, 1]\n    # For a function f(x) on [0,1], integral is approx. sum(w_i * f(x_i))\n    # where x_i = (p_i+1)/2 and w_i = q_i/2\n    q_points = 0.5 * (gauss_points + 1)\n    q_weights = 0.5 * gauss_weights\n\n    # --- Basis Functions and their Derivatives ---\n    # Quadratic Bernstein polynomials for u in [0,1]\n    N_funcs = [\n        lambda u: (1 - u)**2,\n        lambda u: 2 * u * (1 - u),\n        lambda u: u**2\n    ]\n    # Derivatives of quadratic Bernstein polynomials\n    dN_du_funcs = [\n        lambda u: -2 * (1 - u),\n        lambda u: 2 - 4 * u,\n        lambda u: 2 * u\n    ]\n    # Linear Bernstein polynomials for v in [0,1]\n    M_funcs = [\n        lambda v: 1 - v,\n        lambda v: v\n    ]\n    # Derivatives of linear Bernstein polynomials\n    dM_dv_funcs = [\n        lambda v: -1.0,\n        lambda v: 1.0\n    ]\n\n    results = []\n    for r_in, r_out, weights_u in test_cases:\n        # --- Define Geometry: Control Points and Weights ---\n        # Control points P[i, j, coord] for a 3x2 grid\n        P = np.zeros((3, 2, 2))\n        radii = [r_in, r_out]\n        \n        for j in range(2): # 0 for r_in, 1 for r_out\n            r = radii[j]\n            P[0, j, :] = [r, 0.0]\n            P[1, j, :] = [r, r]\n            P[2, j, :] = [0.0, r]\n\n        # Weights w[i, j] for a 3x2 grid\n        weights = np.zeros((3, 2))\n        weights[:, 0] = weights_u\n        weights[:, 1] = weights_u\n\n        # --- Numerical Integration ---\n        total_area = 0.0\n        det_J_values = []\n\n        for k in range(n_points):\n            u = q_points[k]\n            wu = q_weights[k]\n            \n            # Evaluate u-basis functions and derivatives\n            N_vals = np.array([f(u) for f in N_funcs])\n            dN_du_vals = np.array([f(u) for f in dN_du_funcs])\n\n            for l in range(n_points):\n                v = q_points[l]\n                wv = q_weights[l]\n\n                # Evaluate v-basis functions and derivatives\n                M_vals = np.array([f(v) for f in M_funcs])\n                dM_dv_vals = np.array([f(v) for f in dM_dv_funcs])\n\n                # --- Calculate S(u,v) derivatives using the quotient rule ---\n                # S(u,v) = A(u,v) / W(u,v)\n                \n                # W and its derivatives\n                W_ij = np.outer(N_vals, M_vals) * weights\n                W = np.sum(W_ij)\n                \n                dW_du_ij = np.outer(dN_du_vals, M_vals) * weights\n                dW_du = np.sum(dW_du_ij)\n\n                dW_dv_ij = np.outer(N_vals, dM_dv_vals) * weights\n                dW_dv = np.sum(dW_dv_ij)\n\n                # A and its derivatives (A is a 2D vector)\n                A = np.einsum('ij,ijk-k', W_ij, P)\n                dA_du = np.einsum('ij,ijk-k', dW_du_ij, P)\n                dA_dv = np.einsum('ij,ijk-k', dW_dv_ij, P)\n\n                # Apply quotient rule for dS/du and dS/dv\n                # dS_du and dS_dv are 2D vectors (tangents)\n                dS_du = (dA_du * W - A * dW_du) / (W**2)\n                dS_dv = (dA_dv * W - A * dW_dv) / (W**2)\n                \n                # Jacobian determinant\n                det_J = dS_du[0] * dS_dv[1] - dS_du[1] * dS_dv[0]\n                abs_det_J = np.abs(det_J)\n                \n                det_J_values.append(abs_det_J)\n                total_area += wu * wv * abs_det_J\n\n        min_det_J = np.min(det_J_values)\n        max_det_J = np.max(det_J_values)\n        \n        results.append([total_area, min_det_J, max_det_J])\n\n    # Format the final output string exactly as required\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        output_str += f\"[{res[0]},{res[1]},{res[2]}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Code verification is a critical step in developing reliable numerical solvers, and the Method of Manufactured Solutions (MMS) is a powerful technique for this purpose. Applying MMS in IGA, however, requires carefully transforming differential operators from the physical domain to the parametric domain. This practice  challenges you to derive the exact source term $f$ for a chosen manufactured solution $u$ in the Poisson equation $-\\nabla^2 u = f$, providing essential skills in handling the chain rule and geometric transformation terms that appear in the weak form of a PDE.",
            "id": "3411193",
            "problem": "Consider the two-dimensional Poisson equation $-\\nabla_{x}\\cdot\\nabla_{x} u = f$ on a curved physical domain $\\Omega$ obtained as the Non-Uniform Rational B-Splines (NURBS) image of the parametric square $\\hat{\\Omega} = [0,1]^{2}$ through a smooth bijective map $F:\\hat{\\Omega}\\to\\Omega$. Let the NURBS mapping be given explicitly by the bilinear (weights equal to $1$) surface\n$$F(\\xi,\\eta) = \\big(x(\\xi,\\eta),y(\\xi,\\eta)\\big) = \\big(\\xi,\\,\\eta + c\\,\\xi\\,\\eta\\big),$$\nwhere $c$ is a fixed real parameter satisfying $c-1$ so that $1+c\\,\\xi0$ for all $(\\xi,\\eta)\\in\\hat{\\Omega}$. Define the manufactured solution by prescribing $u$ through the pullback of a parametric function $\\hat{u}:\\hat{\\Omega}\\to\\mathbb{R}$:\n$$u(x,y) = \\hat{u}\\big(F^{-1}(x,y)\\big),\\qquad \\hat{u}(\\xi,\\eta) = \\sin(\\pi\\,\\xi)\\,\\sin(\\pi\\,\\eta).$$\nYour task is to derive the exact right-hand side $f$ appearing in the Poisson equation in physical coordinates $(x,y)$, in a form that is suitable for Galerkin error verification under isogeometric analysis with NURBS basis functions. You must start from fundamental geometric-conservation identities linking gradients under mappings and the corresponding metric tensor. In particular, use that the physical gradient is obtained from the parametric gradient by the chain rule and the Jacobian matrix $J_{F}(\\xi,\\eta)$ of $F$, and that the Laplacian can be written in terms of the parametric coordinates $(\\xi,\\eta)$ and the metric tensor $G(\\xi,\\eta) = J_{F}(\\xi,\\eta)^{\\top}\\,J_{F}(\\xi,\\eta)$.\n\nCompute $J_{F}$ and $G$, and express the physical Laplacian $\\Delta_{x} u$ in terms of $(\\xi,\\eta)$ using $G^{-1}$ and $\\det(G)$, then evaluate it for the manufactured $\\hat{u}$. Finally, express your answer entirely in physical coordinates $(x,y)$ by substituting $(\\xi,\\eta)=F^{-1}(x,y)$, where the inverse mapping is obtained from $F$. Provide the exact analytic expression for $f(x,y)$, without numerical approximation. No units are required, and no rounding is to be performed.",
            "solution": "The problem is valid. It is a standard, well-posed problem in numerical analysis for partial differential equations, specifically within the framework of the Method of Manufactured Solutions used for code verification in Isogeometric Analysis. All necessary data and definitions are provided, and the problem is scientifically and mathematically sound.\n\nThe objective is to find the source term $f(x,y)$ in the Poisson equation $-\\Delta_{x} u = f$ given a manufactured solution $u(x,y)$. The solution $u$ is defined via a pullback of a function $\\hat{u}(\\xi,\\eta)$ on a parametric domain $\\hat{\\Omega} = [0,1]^2$ to the physical domain $\\Omega$. The mapping is $F:\\hat{\\Omega} \\to \\Omega$, given by $F(\\xi,\\eta) = (x(\\xi,\\eta), y(\\xi,\\eta)) = (\\xi, \\eta+c\\xi\\eta)$. The solution is $u(x,y) = \\hat{u}(F^{-1}(x,y))$ with $\\hat{u}(\\xi,\\eta) = \\sin(\\pi\\xi)\\sin(\\pi\\eta)$.\n\nThe task requires computing the Laplacian of $u$ in physical coordinates, $\\Delta_x u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$. This involves expressing the physical-space partial derivative operators $(\\frac{\\partial}{\\partial x}, \\frac{\\partial}{\\partial y})$ in terms of the parametric-space operators $(\\frac{\\partial}{\\partial \\xi}, \\frac{\\partial}{\\partial \\eta})$ using the chain rule.\n\nFirst, we establish the relationship between the derivative operators. For any smooth function $g(x,y)$, its composition with $F$ gives $\\hat{g}(\\xi, \\eta) = g(F(\\xi, \\eta))$. The chain rule gives:\n$$ \\frac{\\partial \\hat{g}}{\\partial \\xi} = \\frac{\\partial g}{\\partial x}\\frac{\\partial x}{\\partial \\xi} + \\frac{\\partial g}{\\partial y}\\frac{\\partial y}{\\partial \\xi} \\quad \\text{and} \\quad \\frac{\\partial \\hat{g}}{\\partial \\eta} = \\frac{\\partial g}{\\partial x}\\frac{\\partial x}{\\partial \\eta} + \\frac{\\partial g}{\\partial y}\\frac{\\partial y}{\\partial \\eta} $$\nThe partial derivatives of the mapping components are:\n$$ \\frac{\\partial x}{\\partial \\xi} = 1, \\quad \\frac{\\partial x}{\\partial \\eta} = 0, \\quad \\frac{\\partial y}{\\partial \\xi} = c\\eta, \\quad \\frac{\\partial y}{\\partial \\eta} = 1+c\\xi $$\nSubstituting these into the chain rule equations:\n$$ \\frac{\\partial \\hat{g}}{\\partial \\xi} = \\frac{\\partial g}{\\partial x} + c\\eta \\frac{\\partial g}{\\partial y} $$\n$$ \\frac{\\partial \\hat{g}}{\\partial \\eta} = (1+c\\xi) \\frac{\\partial g}{\\partial y} $$\nFrom the second equation, we solve for $\\frac{\\partial g}{\\partial y}$:\n$$ \\frac{\\partial g}{\\partial y} = \\frac{1}{1+c\\xi} \\frac{\\partial \\hat{g}}{\\partial \\eta} $$\nSubstituting this into the first equation allows us to solve for $\\frac{\\partial g}{\\partial x}$:\n$$ \\frac{\\partial \\hat{g}}{\\partial \\xi} = \\frac{\\partial g}{\\partial x} + c\\eta \\left( \\frac{1}{1+c\\xi} \\frac{\\partial \\hat{g}}{\\partial \\eta} \\right) \\implies \\frac{\\partial g}{\\partial x} = \\frac{\\partial \\hat{g}}{\\partial \\xi} - \\frac{c\\eta}{1+c\\xi} \\frac{\\partial \\hat{g}}{\\partial \\eta} $$\nThese expressions define the physical derivative operators acting on functions of $(\\xi, \\eta)$:\n$$ \\frac{\\partial}{\\partial x} \\equiv D_x = D_\\xi - \\frac{c\\eta}{1+c\\xi} D_\\eta $$\n$$ \\frac{\\partial}{\\partial y} \\equiv D_y = \\frac{1}{1+c\\xi} D_\\eta $$\nwhere $D_\\xi = \\frac{\\partial}{\\partial \\xi}$ and $D_\\eta = \\frac{\\partial}{\\partial \\eta}$.\n\nNext, we compute the second partial derivatives by applying these operators twice to $u$, whose parametric representation is $\\hat{u}$.\nFor $\\frac{\\partial^2 u}{\\partial y^2}$:\n$$ \\frac{\\partial^2 u}{\\partial y^2} = D_y(D_y u) = \\left(\\frac{1}{1+c\\xi} D_\\eta\\right) \\left(\\frac{1}{1+c\\xi} D_\\eta \\hat{u}\\right) = \\frac{1}{(1+c\\xi)^2} D_\\eta^2 \\hat{u} = \\frac{1}{(1+c\\xi)^2} \\frac{\\partial^2 \\hat{u}}{\\partial \\eta^2} $$\nFor $\\frac{\\partial^2 u}{\\partial x^2}$:\n$$ \\frac{\\partial^2 u}{\\partial x^2} = D_x(D_x u) = \\left(D_\\xi - \\frac{c\\eta}{1+c\\xi} D_\\eta\\right) \\left(D_\\xi \\hat{u} - \\frac{c\\eta}{1+c\\xi} D_\\eta \\hat{u}\\right) $$\nApplying the product rule carefully:\n$$ \\frac{\\partial^2 u}{\\partial x^2} = D_\\xi\\left(D_\\xi \\hat{u} - \\frac{c\\eta}{1+c\\xi} D_\\eta \\hat{u}\\right) - \\frac{c\\eta}{1+c\\xi} D_\\eta\\left(D_\\xi \\hat{u} - \\frac{c\\eta}{1+c\\xi} D_\\eta \\hat{u}\\right) $$\n$$ = \\left( \\frac{\\partial^2 \\hat{u}}{\\partial \\xi^2} + \\frac{c^2\\eta}{(1+c\\xi)^2}\\frac{\\partial \\hat{u}}{\\partial \\eta} - \\frac{c\\eta}{1+c\\xi}\\frac{\\partial^2 \\hat{u}}{\\partial \\xi \\partial \\eta} \\right) - \\left( \\frac{c\\eta}{1+c\\xi}\\frac{\\partial^2 \\hat{u}}{\\partial \\eta \\partial \\xi} - \\frac{c^2\\eta^2}{(1+c\\xi)^2}\\frac{\\partial^2 \\hat{u}}{\\partial \\eta^2} \\right) $$\nCombining terms, we get:\n$$ \\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial^2 \\hat{u}}{\\partial \\xi^2} - \\frac{2c\\eta}{1+c\\xi}\\frac{\\partial^2 \\hat{u}}{\\partial \\xi \\partial \\eta} + \\frac{c^2\\eta^2}{(1+c\\xi)^2}\\frac{\\partial^2 \\hat{u}}{\\partial \\eta^2} + \\frac{2c^2\\eta}{(1+c\\xi)^2}\\frac{\\partial \\hat{u}}{\\partial \\eta} $$\nThe Laplacian in parametric coordinates is the sum $\\Delta_x u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$:\n$$ \\Delta_x u = \\frac{\\partial^2 \\hat{u}}{\\partial \\xi^2} - \\frac{2c\\eta}{1+c\\xi}\\frac{\\partial^2 \\hat{u}}{\\partial \\xi \\partial \\eta} + \\frac{1+c^2\\eta^2}{(1+c\\xi)^2}\\frac{\\partial^2 \\hat{u}}{\\partial \\eta^2} + \\frac{2c^2\\eta}{(1+c\\xi)^2}\\frac{\\partial \\hat{u}}{\\partial \\eta} $$\nNow, we compute the necessary derivatives of $\\hat{u}(\\xi,\\eta) = \\sin(\\pi\\xi)\\sin(\\pi\\eta)$:\n$$ \\frac{\\partial \\hat{u}}{\\partial \\eta} = \\pi\\sin(\\pi\\xi)\\cos(\\pi\\eta) $$\n$$ \\frac{\\partial^2 \\hat{u}}{\\partial \\xi^2} = -\\pi^2\\sin(\\pi\\xi)\\sin(\\pi\\eta) = -\\pi^2\\hat{u} $$\n$$ \\frac{\\partial^2 \\hat{u}}{\\partial \\eta^2} = -\\pi^2\\sin(\\pi\\xi)\\sin(\\pi\\eta) = -\\pi^2\\hat{u} $$\n$$ \\frac{\\partial^2 \\hat{u}}{\\partial \\xi \\partial \\eta} = \\pi^2\\cos(\\pi\\xi)\\cos(\\pi\\eta) $$\nSubstituting these into the expression for $\\Delta_x u$:\n$$ \\Delta_x u = -\\pi^2\\hat{u} - \\frac{2c\\eta}{1+c\\xi}(\\pi^2\\cos(\\pi\\xi)\\cos(\\pi\\eta)) + \\frac{1+c^2\\eta^2}{(1+c\\xi)^2}(-\\pi^2\\hat{u}) + \\frac{2c^2\\eta}{(1+c\\xi)^2}(\\pi\\sin(\\pi\\xi)\\cos(\\pi\\eta)) $$\nWe can group terms:\n$$ \\Delta_x u = -\\pi^2\\hat{u} \\left(1 + \\frac{1+c^2\\eta^2}{(1+c\\xi)^2}\\right) - \\frac{2c\\eta\\pi^2}{1+c\\xi}\\cos(\\pi\\xi)\\cos(\\pi\\eta) + \\frac{2c^2\\eta\\pi}{(1+c\\xi)^2}\\sin(\\pi\\xi)\\cos(\\pi\\eta) $$\nThe final step is to express this result in physical coordinates $(x,y)$. We need the inverse mapping $F^{-1}(x,y)=(\\xi,\\eta)$.\nFrom $x=\\xi$ and $y=\\eta(1+c\\xi)$, we find:\n$$ \\xi = x \\quad \\text{and} \\quad \\eta = \\frac{y}{1+cx} $$\nSubstituting these into the expression for $\\Delta_x u$:\n$$ \\Delta_x u(x,y) = -\\pi^2 \\sin(\\pi x)\\sin\\left(\\frac{\\pi y}{1+cx}\\right) \\left(1 + \\frac{1+c^2\\left(\\frac{y}{1+cx}\\right)^2}{(1+cx)^2}\\right) - \\frac{2c\\left(\\frac{y}{1+cx}\\right)\\pi^2}{1+cx}\\cos(\\pi x)\\cos\\left(\\frac{\\pi y}{1+cx}\\right) + \\frac{2c^2\\left(\\frac{y}{1+cx}\\right)\\pi}{(1+cx)^2}\\sin(\\pi x)\\cos\\left(\\frac{\\pi y}{1+cx}\\right) $$\nSimplifying the coefficients:\n$$ 1 + \\frac{1+c^2\\frac{y^2}{(1+cx)^2}}{(1+cx)^2} = \\frac{(1+cx)^2 + 1 + \\frac{c^2y^2}{(1+cx)^2}}{(1+cx)^2} = \\frac{(1+cx)^4 + (1+cx)^2 + c^2y^2}{(1+cx)^4} $$\n$$ \\frac{2c\\left(\\frac{y}{1+cx}\\right)\\pi^2}{1+cx} = \\frac{2c\\pi^2 y}{(1+cx)^2} $$\n$$ \\frac{2c^2\\left(\\frac{y}{1+cx}\\right)\\pi}{(1+cx)^2} = \\frac{2c^2\\pi y}{(1+cx)^3} $$\nPutting it all together:\n$$ \\Delta_x u(x,y) = -\\pi^2 \\sin(\\pi x)\\sin\\left(\\frac{\\pi y}{1+cx}\\right)\\frac{(1+cx)^4+(1+cx)^2+c^2y^2}{(1+cx)^4} - \\frac{2c\\pi^2 y}{(1+cx)^2}\\cos(\\pi x)\\cos\\left(\\frac{\\pi y}{1+cx}\\right) + \\frac{2c^2\\pi y}{(1+cx)^3}\\sin(\\pi x)\\cos\\left(\\frac{\\pi y}{1+cx}\\right) $$\nThe source term is $f(x,y) = -\\Delta_x u(x,y)$.\n$$ f(x,y) = \\pi^2 \\sin(\\pi x)\\sin\\left(\\frac{\\pi y}{1+cx}\\right)\\frac{(1+cx)^4+(1+cx)^2+c^2y^2}{(1+cx)^4} + \\frac{2c\\pi y}{(1+cx)^3} \\cos\\left(\\frac{\\pi y}{1+cx}\\right) \\left(\\pi(1+cx)\\cos(\\pi x) - c\\sin(\\pi x)\\right) $$",
            "answer": "$$\\boxed{\\pi^2 \\sin(\\pi x)\\sin\\left(\\frac{\\pi y}{1+cx}\\right) \\frac{(1+cx)^4+(1+cx)^2+c^2y^2}{(1+cx)^4} + \\frac{2c\\pi y}{(1+cx)^3} \\cos\\left(\\frac{\\pi y}{1+cx}\\right) \\left( \\pi(1+cx)\\cos(\\pi x) - c\\sin(\\pi x) \\right)}$$"
        },
        {
            "introduction": "A key challenge in implementing IGA is adapting the standard element-based assembly procedures of the Finite Element Method (FEM) to the non-interpolatory, overlapping B-spline basis. Bézier extraction is an elegant and powerful technique that resolves this by providing an element-local representation of the basis in terms of Bernstein polynomials. This advanced implementation exercise  guides you through the derivation and application of the extraction operator, illustrating how IGA can leverage a computational structure very similar to that of classical FEM.",
            "id": "3411189",
            "problem": "You are asked to implement the element-level Bézier extraction in one dimension for Non-Uniform Rational Basis Spline (NURBS) within the framework of isogeometric analysis. The core goal is to derive, from first principles, the explicit representation of the B-spline basis restricted to a single knot-span element in terms of Bernstein polynomials, and to use this to obtain the rational NURBS basis and its parametric derivatives. You must also analyze how Bézier extraction influences the sparsity pattern and assembly complexity relative to a standard one-dimensional $C^{0}$ Lagrange finite element discretization of the same polynomial degree.\n\nStart from the following foundational definitions and facts only:\n- The Cox–de Boor recursion defines B-spline basis functions $N_{i,p}(u)$ on a knot vector $U = \\{u_{0},u_{1},\\dots,u_{m}\\}$ and degree $p$.\n- A knot span element is any interval $[u_{a},u_{a+1}]$ with $u_{a+1} > u_{a}$. On such an element, any function in the B-spline space of degree $p$ is a polynomial of degree $p$.\n- The Bernstein polynomial basis $\\{B_{j}^{p}(s)\\}_{j=0}^{p}$ spans polynomials of degree $p$ in a local coordinate $s \\in [0,1]$.\n- Rational Non-Uniform Basis Spline (NURBS) basis functions are given by $R_{i,p}(u) = \\dfrac{w_{i} N_{i,p}(u)}{\\sum_{k} w_{k} N_{k,p}(u)}$ where $w_{i} > 0$ are weights.\n\nYour tasks:\n1. For each element $[u_{a},u_{a+1}]$, derive the constant element-level Bézier extraction matrix $C^{(e)} \\in \\mathbb{R}^{(p+1)\\times(p+1)}$ such that the vector of the $p+1$ B-spline basis functions that are nonzero on the element can be written as $N^{(e)}(u(s)) = C^{(e)} B^{p}(s)$ for all $s \\in [0,1]$, where $u(s) = u_{a} + s(u_{a+1}-u_{a})$ and $B^{p}(s)$ collects $\\{B_{j}^{p}(s)\\}_{j=0}^{p}$. Do not invoke any shortcut formulas; construct $C^{(e)}$ only from the stated fundamental definitions, using mathematically sound reasoning.\n2. Using the above representation and the chain rule, derive expressions for the element-level parametric derivatives $\\dfrac{dN^{(e)}}{du}$ and then the NURBS basis and derivatives $\\dfrac{dR^{(e)}}{du}$ in terms of Bernstein polynomials and their derivatives.\n3. Quantitatively verify the correctness of the extraction by computing the maximum absolute discrepancy between the direct Cox–de Boor evaluation of $N_{i,p}(u)$ and the Bézier representation $C^{(e)} B^{p}(s)$ over a small set of interior sample points on each element. Similarly verify derivatives by comparing $\\dfrac{dN_{i,p}}{du}$ from Cox–de Boor differentiation to the derivative obtained via the extracted Bernstein representation and the element map.\n4. Construct the global adjacency (sparsity) pattern induced by element-level assembly for:\n   - Isogeometric analysis (IGA) with B-spline continuity implied by the knot vector (typically $C^{p-1}$ at simple internal knots). The global degrees of freedom are the B-spline basis functions indexed by $i=0,\\dots,n-1$, where $n = m - p$.\n   - Standard one-dimensional $C^{0}$ Lagrange finite elements of degree $p$ on the same element partition. The global degrees of freedom are nodal unknowns $0,\\dots,E \\cdot p$, where $E$ is the number of nonzero knot spans (elements).\n   In both cases, include the diagonal in the adjacency and connect all pairs of basis functions that co-occur on any element. Compute:\n   - The average number of nonzeros per row.\n   - The total number of nonzeros.\n   Report the ratio of the total number of nonzeros for IGA relative to the standard finite element method.\n\nImplementation details and constraints:\n- Work in one dimension with open knot vectors and positive weights.\n- Use only the provided fundamental definitions to construct $C^{(e)}$. The solution must not assume any pre-derived extraction formulas; you may use collocation on $p+1$ distinct interior points within the element to uniquely determine $C^{(e)}$ due to equality of polynomial spaces.\n- Bernstein polynomials and their derivatives are to be used on the local coordinate $s \\in [0,1]$.\n- Derivatives must be parametric with respect to $u$; use the angle unit in radians for any trigonometric evaluations if needed (this problem does not require angles by default).\n\nTest suite:\nProvide computations for the following three cases. For each case, compute the requested errors and sparsity metrics.\n- Case 1 (quadratic, two elements, nonuniform weights): degree $p=2$, knot vector $U=[0,0,0,0.5,1,1,1]$, weights $w=[1,2,1,1]$.\n- Case 2 (cubic, three elements, nonuniform internal knots, nonuniform weights): degree $p=3$, knot vector $U=[0,0,0,0,0.4,0.7,1,1,1,1]$, weights $w=[1,1.5,0.8,2.0,1.0,1.2]$.\n- Case 3 (quadratic, reduced continuity via repeated internal knot): degree $p=2$, knot vector $U=[0,0,0,0.5,0.5,1,1,1]$, weights $w=[1,0.7,1.3,1.1,0.9]$.\n\nOutput specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, return a list containing:\n- The maximum absolute error over all elements and sample points between direct B-spline basis evaluation and its Bézier representation, as a float.\n- The maximum absolute error over all elements and sample points between direct B-spline derivative $\\dfrac{dN}{du}$ and the derivative computed via the Bézier representation and the element map, as a float.\n- The average number of nonzeros per row in the IGA adjacency, as a float.\n- The average number of nonzeros per row in the standard finite element adjacency, as a float.\n- The ratio of total nonzeros for IGA relative to standard finite elements, as a float.\n\nFor example, the final line must look like:\n\"[[errN1,errdN1,avgIGA1,avgFE1,ratio1],[errN2,errdN2,avgIGA2,avgFE2,ratio2],[errN3,errdN3,avgIGA3,avgFE3,ratio3]]\"\n\nAll results are dimensionless real numbers; no physical units are involved. Use decimal numbers.",
            "solution": "The problem requires the implementation and validation of one-dimensional Bézier extraction for isogeometric analysis (IGA) with Non-Uniform Rational B-Splines (NURBS). This process involves expressing B-spline basis functions over a single element in the Bernstein polynomial basis. This translation facilitates element-level computations, mirroring the structure of standard finite element methods (FEM), while preserving the higher-order continuity of the original B-spline basis. The solution proceeds by first deriving the extraction operator, then using it to find expressions for derivatives, numerically verifying the results, and finally analyzing the sparsity patterns of the resulting system matrices.\n\n### 1. Derivation of the Element-Level Bézier Extraction Matrix\n\nA B-spline curve or surface is defined over a knot vector $U = \\{u_0, u_1, \\dots, u_m\\}$ with basis functions $N_{i,p}(u)$ of degree $p$. In isogeometric analysis, the regions between distinct knots, known as knot spans, define the elements. On any non-zero length element $[u_a, u_{a+1}]$, the set of $p+1$ B-spline basis functions that are non-zero, $\\{N_{a-p,p}(u), \\dots, N_{a,p}(u)\\}$, forms a basis for the space of all polynomials of degree at most $p$.\n\nSimilarly, the set of Bernstein polynomials, $\\{B_j^p(s)\\}_{j=0}^p$, where $B_j^p(s) = \\binom{p}{j}s^j(1-s)^{p-j}$, forms a basis for polynomials of degree $p$ on the local coordinate domain $s \\in [0,1]$. A linear mapping relates the global coordinate $u$ on the element $[u_a, u_{a+1}]$ to the local coordinate $s$:\n$$ u(s) = u_a(1-s) + u_{a+1}s = u_a + s(u_{a+1}-u_a) $$\nSince the restricted B-spline basis and the Bernstein basis both span the same polynomial space over the element, there must exist a unique, constant $(p+1)\\times(p+1)$ matrix, the Bézier extraction matrix $C^{(e)}$, that transforms one basis to the other. Let $\\vec{N}^{(e)}(u)$ be the column vector of the $p+1$ active B-spline basis functions on the element, and $\\vec{B}^p(s)$ be the column vector of the Bernstein basis functions. The relationship is:\n$$ \\vec{N}^{(e)}(u(s)) = C^{(e)} \\vec{B}^p(s) $$\nTo determine $C^{(e)}$, we can enforce this equality at $p+1$ distinct points $s_k \\in [0,1]$ for $k=0,\\dots,p$. Let $u_k = u(s_k)$. This yields a system of linear equations:\n$$ [\\vec{N}^{(e)}(u_0) | \\vec{N}^{(e)}(u_1) | \\dots | \\vec{N}^{(e)}(u_p)] = C^{(e)} [\\vec{B}^p(s_0) | \\vec{B}^p(s_1) | \\dots | \\vec{B}^p(s_p)] $$\nLet $\\mathbf{N}$ be the $(p+1)\\times(p+1)$ matrix where $\\mathbf{N}_{ij} = (N^{(e)}_i(u_j))$, and $\\mathbf{B}$ be the matrix where $\\mathbf{B}_{ij} = (B^p_i(s_j))$. The equation becomes $\\mathbf{N} = C^{(e)} \\mathbf{B}$. Since the points $s_k$ are distinct, the matrix $\\mathbf{B}$ is invertible. The extraction matrix is then found by:\n$$ C^{(e)} = \\mathbf{N} \\mathbf{B}^{-1} $$\nFor numerical stability, the collocation points $s_k$ are chosen to be distinct and interior to $[0,1]$. The entries of $\\mathbf{N}$ are computed using the Cox-de Boor recursion formula, and the entries of $\\mathbf{B}$ from the definition of Bernstein polynomials.\n\n### 2. Derivation of Basis Function Derivatives\n\nWith the Bézier representation, derivatives of the basis functions with respect to the global parameter $u$ can be computed using the chain rule. The derivative of $\\vec{N}^{(e)}$ with respect to $u$ is:\n$$ \\frac{d\\vec{N}^{(e)}}{du} = \\frac{d\\vec{N}^{(e)}}{ds} \\frac{ds}{du} $$\nFrom the Bézier representation, $\\frac{d\\vec{N}^{(e)}}{ds} = C^{(e)} \\frac{d\\vec{B}^p(s)}{ds}$. The derivative of the coordinate map is $\\frac{du}{ds} = u_{a+1}-u_a$, a constant for the element. Thus, $\\frac{ds}{du} = \\frac{1}{u_{a+1}-u_a}$. Substituting these gives:\n$$ \\frac{d\\vec{N}^{(e)}}{du} = \\frac{1}{u_{a+1}-u_a} C^{(e)} \\frac{d\\vec{B}^p(s)}{ds} $$\nThe derivative of the Bernstein basis vector $\\frac{d\\vec{B}^p(s)}{ds}$ has entries $\\frac{dB_j^p}{ds} = p(B_{j-1}^{p-1}(s) - B_j^{p-1}(s))$, with the convention that $B_{-1}^{p-1} \\equiv 0$ and $B_p^{p-1} \\equiv 0$.\n\nFor NURBS basis functions, $R_{i,p}(u) = \\frac{w_i N_{i,p}(u)}{W(u)}$, where $W(u) = \\sum_{k} w_k N_{k,p}(u)$ is the weighting function. On an element, we consider only the active basis functions. The derivative $\\frac{dR_{i,p}}{du}$ is found using the quotient rule:\n$$ \\frac{dR_{i,p}}{du} = \\frac{w_i \\frac{dN_{i,p}}{du} W(u) - w_i N_{i,p}(u) \\frac{dW}{du}}{W(u)^2} $$\nwhere $\\frac{dW}{du} = \\sum_{k=a-p}^{a} w_k \\frac{dN_{k,p}}{du}$. All terms on the right-hand side ($N_{k,p}$, $\\frac{dN_{k,p}}{du}$, $W(u)$, and $\\frac{dW}{du}$) are readily computed using the Bézier extraction representation.\n\n### 3. Verification of the Extraction\n\nThe correctness of the derived extraction matrix $C^{(e)}$ and the subsequent derivative calculations is verified numerically. On each element, a set of sample points $u$ is chosen. At each point, two values are computed for each basis function and its derivative:\n1.  **Direct Evaluation**: The B-spline value $N_{i,p}(u)$ is computed using the Cox-de Boor recursion. The derivative $\\frac{dN_{i,p}}{du}$ is computed using the standard recursive formula derived from differentiating the Cox-de Boor relation.\n2.  **Bézier Representation**: The value and derivative are computed using the formulas derived in the sections above, utilizing $C^{(e)}$ and the Bernstein basis.\nThe maximum absolute difference between these two methods over all sample points and all elements serves as a quantifiable error metric.\n\n### 4. Sparsity Pattern Analysis\n\nThe sparsity of the global system matrix, such as a mass or stiffness matrix, is determined by the support of the basis functions. An entry $(i,j)$ in the adjacency matrix is non-zero if basis functions $i$ and $j$ have overlapping support on at least one element.\n\n**Isogeometric Analysis (IGA):**\nThe global degrees of freedom (DoFs) are the coefficients of the $n=m-p$ B-spline basis functions. On any element $[u_a, u_{a+1}]$, the $p+1$ basis functions with global indices $\\{a-p, \\dots, a\\}$ are active. This implies that the submatrix corresponding to these DoFs is dense. The global adjacency matrix is constructed by taking the union of these dense blocks over all elements. The continuity of B-splines ($C^{p-k}$ at a knot of multiplicity $k$) leads to a larger overlap of basis functions compared to $C^0$-continuous elements, generally resulting in denser matrices but with fewer total DoFs for a given mesh resolution.\n\n**Standard $C^0$ Lagrange Finite Elements (FEM):**\nFor a mesh with $E$ elements and degree $p$ Lagrange polynomials, there are $p+1$ nodes per element. With $C^0$ continuity, nodes at element boundaries are shared. This results in a total of $E \\cdot p + 1$ global DoFs. On element $e \\in \\{0, \\dots, E-1\\}$, the active DoFs are locally numbered $\\{0, \\dots, p\\}$, which map to global DoF indices $\\{e \\cdot p, \\dots, (e+1) \\cdot p\\}$. These $p+1$ DoFs form a clique for element $e$. The resulting global matrix has a more narrowly banded structure than the IGA matrix.\n\nThis analysis computes the total number of non-zero entries and the average non-zeros per row for both approaches, and reports their ratio to compare the structural complexity of the resulting linear systems.",
            "answer": "```python\nimport numpy as np\nfrom math import comb\n\nmemo_N = {}\nmemo_dN = {}\n\ndef cox_de_boor_val(u, i, p, U, n_funcs):\n    \"\"\"Computes the value of B-spline basis function N_i,p(u) using recursion with memoization.\"\"\"\n    key = (u, i, p)\n    if key in memo_N:\n        return memo_N[key]\n\n    if p == 0:\n        is_last_span = (i == n_funcs - 1) and (u == U[n_funcs])\n        val = 1.0 if (U[i] = u  U[i+1]) or is_last_span else 0.0\n    else:\n        val = 0.0\n        den1 = U[i+p] - U[i]\n        if den1  1e-12:\n            val += ((u - U[i]) / den1) * cox_de_boor_val(u, i, p-1, U, n_funcs)\n        \n        den2 = U[i+p+1] - U[i+1]\n        if den2  1e-12:\n            val += ((U[i+p+1] - u) / den2) * cox_de_boor_val(u, i+1, p-1, U, n_funcs)\n    \n    memo_N[key] = val\n    return val\n\ndef b_spline_deriv_val(u, i, p, U, n_funcs):\n    \"\"\"Computes the derivative of B-spline basis function N_i,p(u) w.r.t u.\"\"\"\n    key = (u, i, p)\n    if key in memo_dN:\n        return memo_dN[key]\n\n    val = 0.0\n    den1 = U[i+p] - U[i]\n    if den1  1e-12:\n        val += (p / den1) * cox_de_boor_val(u, i, p-1, U, n_funcs)\n    \n    den2 = U[i+p+1] - U[i+1]\n    if den2  1e-12:\n        val -= (p / den2) * cox_de_boor_val(u, i+1, p-1, U, n_funcs)\n    \n    memo_dN[key] = val\n    return val\n\ndef bernstein_poly(j, p, s):\n    \"\"\"Computes the value of Bernstein polynomial B_j,p(s).\"\"\"\n    if j  0 or j  p:\n        return 0.0\n    if abs(s)  1e-12 and j == 0: return 1.0\n    if abs(s)  1e-12 and j  0: return 0.0\n    if abs(1-s)  1e-12 and j == p: return 1.0\n    if abs(1-s)  1e-12 and j  p: return 0.0\n    return comb(p, j) * (s**j) * ((1-s)**(p-j))\n\ndef bernstein_poly_deriv(j, p, s):\n    \"\"\"Computes the derivative of Bernstein polynomial B_j,p(s) w.r.t s.\"\"\"\n    return p * (bernstein_poly(j-1, p-1, s) - bernstein_poly(j, p-1, s))\n\ndef find_span_robust(u, p, U):\n    \"\"\"Finds the knot span index for a given parameter u using binary search.\"\"\"\n    n = len(U) - p - 2\n    if u = U[n + 1]:\n        return n\n    idx = np.searchsorted(U, u, side='right')\n    return idx - 1\n\ndef solve():\n    \"\"\"Main function to process test cases and print results.\"\"\"\n    test_cases = [\n        (2, [0., 0., 0., 0.5, 1., 1., 1.], [1., 2., 1., 1.]),\n        (3, [0., 0., 0., 0., 0.4, 0.7, 1., 1., 1., 1.], [1., 1.5, 0.8, 2.0, 1.0, 1.2]),\n        (2, [0., 0., 0., 0.5, 0.5, 1., 1., 1.], [1., 0.7, 1.3, 1.1, 0.9])\n    ]\n\n    final_results = []\n\n    for p, U_list, w_list in test_cases:\n        U = np.array(U_list, dtype=float)\n        w = np.array(w_list, dtype=float)\n        m = len(U) - 1\n        n_funcs = m - p\n        \n        max_N_error = 0.0\n        max_dN_error = 0.0\n\n        unique_knots = sorted(list(set(U)))\n        elements = []\n        for i in range(len(unique_knots) - 1):\n            if unique_knots[i]  unique_knots[i+1]:\n                elements.append((unique_knots[i], unique_knots[i+1]))\n\n        for u_start, u_end in elements:\n            span_idx = find_span_robust(u_start if u_start  U[0] else (u_start + u_end)/2.0, p, U)\n            \n            s_coll = np.linspace(0, 1, p + 3)[1:-1]\n            u_coll = u_start + s_coll * (u_end - u_start)\n            \n            N_mat = np.zeros((p + 1, p + 1))\n            B_mat = np.zeros((p + 1, p + 1))\n            \n            for j in range(p + 1):\n                memo_N.clear()\n                for i in range(p + 1):\n                    N_mat[i, j] = cox_de_boor_val(u_coll[j], span_idx - p + i, p, U, n_funcs)\n                    B_mat[i, j] = bernstein_poly(i, p, s_coll[j])\n\n            C_e = N_mat @ np.linalg.inv(B_mat)\n\n            s_test = np.linspace(0.01, 0.99, 20)\n            u_test = u_start + s_test * (u_end - u_start)\n\n            for s_val, u_val in zip(s_test, u_test):\n                memo_N.clear()\n                memo_dN.clear()\n                \n                vals_direct = np.array([cox_de_boor_val(u_val, span_idx - p + i, p, U, n_funcs) for i in range(p + 1)])\n                dvals_direct = np.array([b_spline_deriv_val(u_val, span_idx - p + i, p, U, n_funcs) for i in range(p + 1)])\n\n                B_vec = np.array([bernstein_poly(j, p, s_val) for j in range(p + 1)])\n                dB_ds_vec = np.array([bernstein_poly_deriv(j, p, s_val) for j in range(p + 1)])\n                vals_bezier = C_e @ B_vec\n                \n                ds_du = 1.0 / (u_end - u_start)\n                dvals_bezier = (C_e @ dB_ds_vec) * ds_du\n\n                max_N_error = max(max_N_error, np.max(np.abs(vals_direct - vals_bezier)))\n                max_dN_error = max(max_dN_error, np.max(np.abs(dvals_direct - dvals_bezier)))\n\n        # Sparsity Analysis\n        n_iga = n_funcs\n        adj_iga = np.zeros((n_iga, n_iga), dtype=int)\n        for u_start, u_end in elements:\n            span_idx = find_span_robust(u_start if u_start  U[0] else (u_start + u_end)/2.0, p, U)\n            active_dofs = range(span_idx - p, span_idx + 1)\n            for i in active_dofs:\n                for j in active_dofs:\n                    if 0 = i  n_iga and 0 = j  n_iga:\n                       adj_iga[i, j] = 1\n        \n        nnz_iga = np.sum(adj_iga)\n        avg_iga = nnz_iga / n_iga if n_iga  0 else 0.\n\n        E = len(elements)\n        n_fem = E * p + 1\n        adj_fem = np.zeros((n_fem, n_fem), dtype=int)\n        for e in range(E):\n            dofs = range(e * p, (e + 1) * p + 1)\n            for i in dofs:\n                for j in dofs:\n                    if 0 = i  n_fem and 0 = j  n_fem:\n                        adj_fem[i, j] = 1\n\n        nnz_fem = np.sum(adj_fem)\n        avg_fem = nnz_fem / n_fem if n_fem  0 else 0.\n        ratio = nnz_iga / nnz_fem if nnz_fem > 0 else 0.0\n\n        final_results.append([max_N_error, max_dN_error, avg_iga, avg_fem, ratio])\n\n    case_strs = []\n    for res in final_results:\n        case_strs.append(f\"[{','.join(map(str, res))}]\")\n    print(f\"[{','.join(case_strs)}]\")\n\nsolve()\n```"
        }
    ]
}