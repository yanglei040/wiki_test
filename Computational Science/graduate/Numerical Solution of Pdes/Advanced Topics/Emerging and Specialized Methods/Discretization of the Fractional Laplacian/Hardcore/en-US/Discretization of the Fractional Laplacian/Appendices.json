{
    "hands_on_practices": [
        {
            "introduction": "The most direct way to discretize the fractional Laplacian is often in Fourier space, where the non-local operator becomes a simple multiplier. This exercise provides foundational, hands-on experience with this pseudo-spectral approach on a periodic domain, which is diagonalized by Fourier modes $e^{i \\boldsymbol{k} \\cdot \\boldsymbol{x}}$. By implementing the operator and testing it on these exact eigenfunctions, you will directly observe and quantify the phenomenon of aliasing, a critical concept in all spectral methods that determines the limits of their accuracy .",
            "id": "3381273",
            "problem": "Implement a complete program that constructs a pseudo-spectral Fourier discretization of the fractional Laplacian on the periodic domain $\\Omega = [0,2\\pi]^d$, applies it to the complex plane wave $u(\\boldsymbol{x}) = e^{i\\,\\boldsymbol{k}\\cdot \\boldsymbol{x}}$ sampled on a uniform grid with $N$ points per spatial direction, and quantifies the aliasing error as a function of $\\boldsymbol{k}$, $s$, and $N$. Angles must be interpreted in radians. The program must not read any input and must only print a single line in the required format described at the end.\n\nFundamental base to use in your design:\n- Definition of the fractional Laplacian on the torus: the eigenfunctions of $(-\\Delta)^s$ are the Fourier modes $e^{i\\,\\boldsymbol{k}\\cdot \\boldsymbol{x}}$ with integer wavevectors $\\boldsymbol{k}\\in\\mathbb{Z}^d$, with eigenvalues $|\\boldsymbol{k}|^{2s}$, where $|\\boldsymbol{k}|$ denotes the Euclidean norm.\n- Discrete Fourier Transform (DFT) on a uniform grid: sampling a periodic exponential $e^{i\\,\\boldsymbol{k}\\cdot \\boldsymbol{x}}$ on the grid $\\{ \\boldsymbol{x}_{\\boldsymbol{j}} = 2\\pi\\,\\boldsymbol{j}/N : \\boldsymbol{j}\\in\\{0,1,\\dots,N-1\\}^d \\}$ yields a discrete spectrum supported at the frequency bin corresponding to $\\boldsymbol{k}$ reduced modulo $N$ into the principal set $\\{-\\lfloor N/2\\rfloor,\\dots,\\lceil N/2\\rceil-1\\}^d$. This reduction causes aliasing when any component of $\\boldsymbol{k}$ lies outside that principal set.\n\nYour program must:\n1. Construct the grid $\\{ \\boldsymbol{x}_{\\boldsymbol{j}} \\}$ on $\\Omega = [0,2\\pi]^d$ with $N$ points per axis for each test case.\n2. Sample $u(\\boldsymbol{x}) = e^{i\\,\\boldsymbol{k}\\cdot \\boldsymbol{x}}$ on that grid.\n3. Apply the pseudo-spectral fractional Laplacian: compute the $d$-dimensional DFT of the samples, multiply each Fourier coefficient by the symbol $|\\boldsymbol{\\xi}|^{2s}$, where $\\boldsymbol{\\xi}$ is the integer wavevector associated to that DFT bin, and invert the DFT to obtain a grid function.\n4. Form the exact grid function for $(-\\Delta)^s u$ by multiplying the sampled $u$ by the scalar $|\\boldsymbol{k}|^{2s}$.\n5. Quantify the aliasing error as the relative $\\ell^\\infty$ error\n$$\nE_{\\infty}^{\\mathrm{rel}} = \\frac{\\max_{\\boldsymbol{j}} \\left| u_{\\mathrm{num}}(\\boldsymbol{x}_{\\boldsymbol{j}}) - u_{\\mathrm{exact}}(\\boldsymbol{x}_{\\boldsymbol{j}}) \\right|}{\\max_{\\boldsymbol{j}} \\left| u_{\\mathrm{exact}}(\\boldsymbol{x}_{\\boldsymbol{j}}) \\right|},\n$$\nwith the convention that if the denominator is $0$, then $E_{\\infty}^{\\mathrm{rel}}$ is defined to be $0$.\n\nTest Suite:\n- Case $1$ (happy path, no aliasing in one dimension): $d=1$, $N=64$, $s=0.75$, $\\boldsymbol{k}=(10)$.\n- Case $2$ (Nyquist boundary in one dimension): $d=1$, $N=64$, $s=1.0$, $\\boldsymbol{k}=(32)$.\n- Case $3$ (aliasing in one dimension): $d=1$, $N=64$, $s=1.3$, $\\boldsymbol{k}=(50)$.\n- Case $4$ (no aliasing in two dimensions): $d=2$, $N=48$, $s=0.3$, $\\boldsymbol{k}=(10,22)$.\n- Case $5$ (aliasing in two dimensions): $d=2$, $N=32$, $s=0.8$, $\\boldsymbol{k}=(20,5)$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results for the five test cases as a comma-separated list of floating-point numbers enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5]$, where each $r_i$ is the relative $\\ell^\\infty$ error $E_{\\infty}^{\\mathrm{rel}}$ for the corresponding test case.",
            "solution": "The user requests a program to compute the error of a pseudo-spectral approximation of the fractional Laplacian, $(-\\Delta)^s$, acting on a complex plane wave, $u(\\boldsymbol{x}) = e^{i\\,\\boldsymbol{k}\\cdot \\boldsymbol{x}}$. The computation is set on a periodic domain $\\Omega = [0, 2\\pi]^d$. The primary objective is to quantify the aliasing error that arises from this numerical discretization as a function of the operator power $s$, the wavevector $\\boldsymbol{k}$, and the number of grid points $N$.\n\nThe fractional Laplacian $(-\\Delta)^s$ on the $d$-dimensional torus $\\mathbb{T}^d$ (equivalent to the periodic domain $[0, 2\\pi]^d$) is most conveniently defined through its action in Fourier space. The complex exponentials $e^{i\\,\\boldsymbol{m}\\cdot\\boldsymbol{x}}$, where $\\boldsymbol{m} \\in \\mathbb{Z}^d$ is an integer wavevector, are the eigenfunctions of the standard Laplacian $-\\Delta$, with corresponding eigenvalues $|\\boldsymbol{m}|^2 = \\sum_{l=1}^d m_l^2$. The fractional operator $(-\\Delta)^s$ shares these eigenfunctions, with eigenvalues given by $|\\boldsymbol{m}|^{2s}$:\n$$\n(-\\Delta)^s e^{i\\,\\boldsymbol{m}\\cdot\\boldsymbol{x}} = |\\boldsymbol{m}|^{2s} e^{i\\,\\boldsymbol{m}\\cdot\\boldsymbol{x}}\n$$\nThe function prescribed in the problem, $u(\\boldsymbol{x}) = e^{i\\,\\boldsymbol{k}\\cdot \\boldsymbol{x}}$, is an eigenfunction of this operator. Consequently, the exact result of applying $(-\\Delta)^s$ is a simple scaling of the original function:\n$$\nu_{\\mathrm{exact}}(\\boldsymbol{x}) = (-\\Delta)^s u(\\boldsymbol{x}) = |\\boldsymbol{k}|^{2s} u(\\boldsymbol{x}) = |\\boldsymbol{k}|^{2s} e^{i\\,\\boldsymbol{k}\\cdot \\boldsymbol{x}}\n$$\nwhere $|\\boldsymbol{k}|$ is the Euclidean norm of the specified wavevector $\\boldsymbol{k}$.\n\nThe numerical procedure to be implemented is a pseudo-spectral method on a uniform grid, which we outline below.\n\n1.  **Discretization**: The continuous domain $\\Omega = [0, 2\\pi]^d$ is discretized into a uniform Cartesian grid of $N^d$ points. The grid points are defined by\n    $$\n    \\boldsymbol{x}_{\\boldsymbol{j}} = \\frac{2\\pi}{N} \\boldsymbol{j}, \\quad \\text{for } \\boldsymbol{j} = (j_1, \\dots, j_d) \\in \\{0, 1, \\dots, N-1\\}^d\n    $$\n    The continuous function $u(\\boldsymbol{x})$ is sampled at these discrete points, yielding a grid function $U_{\\boldsymbol{j}} = u(\\boldsymbol{x}_{\\boldsymbol{j}})$. The exact solution, when evaluated on this grid, is $U_{\\text{exact}, \\boldsymbol{j}} = |\\boldsymbol{k}|^{2s} U_{\\boldsymbol{j}}$.\n\n2.  **Pseudo-spectral Operator**: The numerical approximation of $(-\\Delta)^s$ acting on the grid function $U$ involves a sequence of operations in Fourier space:\n    a.  First, the $d$-dimensional discrete Fourier transform (DFT) is applied to the grid function $U$, yielding a set of Fourier coefficients $\\hat{U}_{\\boldsymbol{\\xi}}$:\n    $$\n    \\hat{U} = \\text{DFT}_d(U)\n    $$\n    b.  The discrete frequencies of the DFT are represented by integer wavevectors $\\boldsymbol{\\xi}$ belonging to the principal set $K_N = \\{-\\lfloor N/2\\rfloor, \\dots, \\lceil N/2\\rceil-1\\}^d$. Each Fourier coefficient $\\hat{U}_{\\boldsymbol{\\xi}}$ is then multiplied by the symbol of the operator, which is $|\\boldsymbol{\\xi}|^{2s}$. This step represents the action of the differential operator in Fourier space.\n    $$\n    \\hat{U}_{\\text{num}, \\boldsymbol{\\xi}} = |\\boldsymbol{\\xi}|^{2s} \\hat{U}_{\\boldsymbol{\\xi}}\n    $$\n    c.  Finally, the $d$-dimensional inverse DFT (IDFT) is applied to the modified coefficients, transforming the result back to the physical grid and yielding the numerical solution $U_{\\text{num}}$.\n    $$\n    U_{\\text{num}} = \\text{IDFT}_d(\\hat{U}_{\\text{num}})\n    $$\n\n3.  **Aliasing Error**: A critical aspect of this problem is aliasing. When the continuous function $u(\\boldsymbol{x}) = e^{i\\,\\boldsymbol{k}\\cdot \\boldsymbol{x}}$ is sampled on the discrete grid, it becomes indistinguishable from any other plane wave $e^{i\\,\\boldsymbol{k}'\\cdot \\boldsymbol{x}}$ whose wavevector $\\boldsymbol{k}'$ satisfies $(\\boldsymbol{k} - \\boldsymbol{k}') \\cdot \\boldsymbol{x}_{\\boldsymbol{j}} \\in 2\\pi\\mathbb{Z}$ for all grid points $\\boldsymbol{x}_{\\boldsymbol{j}}$. This condition holds if each component of $\\boldsymbol{k} - \\boldsymbol{k}'$ is an integer multiple of $N$. The DFT algorithm implicitly maps any wavevector $\\boldsymbol{k}$ to its unique alias $\\boldsymbol{k}_{\\text{alias}} \\in K_N$ such that $k_l \\equiv (k_{\\text{alias}})_l \\pmod{N}$ for each component $l=1, \\dots, d$.\n\n    As a result of this aliasing, the DFT of the sampled function $U$ is a discrete delta function located at the frequency corresponding to $\\boldsymbol{k}_{\\text{alias}}$. The numerical method, therefore, applies the eigenvalue $|\\boldsymbol{k}_{\\text{alias}}|^{2s}$ instead of the correct eigenvalue, $|\\boldsymbol{k}|^{2s}$. The numerical solution on the grid is thus:\n    $$\n    U_{\\text{num}, \\boldsymbol{j}} = |\\boldsymbol{k}_{\\text{alias}}|^{2s} U_{\\boldsymbol{j}}\n    $$\n    This is the fundamental source of error in the pseudo-spectral method for this problem.\n\n4.  **Error Quantification**: The error is quantified using the relative $\\ell^\\infty$ norm, as specified:\n    $$\n    E_{\\infty}^{\\mathrm{rel}} = \\frac{\\max_{\\boldsymbol{j}} \\left| u_{\\mathrm{num}}(\\boldsymbol{x}_{\\boldsymbol{j}}) - u_{\\mathrm{exact}}(\\boldsymbol{x}_{\\boldsymbol{j}}) \\right|}{\\max_{\\boldsymbol{j}} \\left| u_{\\mathrm{exact}}(\\boldsymbol{x}_{\\boldsymbol{j}}) \\right|} = \\frac{\\max_{\\boldsymbol{j}} \\left| |\\boldsymbol{k}_{\\text{alias}}|^{2s} U_{\\boldsymbol{j}} - |\\boldsymbol{k}|^{2s} U_{\\boldsymbol{j}} \\right|}{\\max_{\\boldsymbol{j}} \\left| |\\boldsymbol{k}|^{2s} U_{\\boldsymbol{j}} \\right|}\n    $$\n    Since $|U_{\\boldsymbol{j}}| = |e^{i\\,\\boldsymbol{k}\\cdot\\boldsymbol{x}_{\\boldsymbol{j}}}| = 1$ for all $\\boldsymbol{j}$, the expression simplifies to:\n    $$\n    E_{\\infty}^{\\mathrm{rel}} = \\frac{\\left| |\\boldsymbol{k}_{\\text{alias}}|^{2s} - |\\boldsymbol{k}|^{2s} \\right|}{\\left| |\\boldsymbol{k}|^{2s} \\right|} = \\left| \\left(\\frac{|\\boldsymbol{k}_{\\text{alias}}|}{|\\boldsymbol{k}|}\\right)^{2s} - 1 \\right|\n    $$\n    If the wavevector $\\boldsymbol{k}$ lies entirely within the principal frequency set $K_N$, then no aliasing occurs, $\\boldsymbol{k}_{\\text{alias}} = \\boldsymbol{k}$, and the error is $0$ (up to machine precision). If any component of $\\boldsymbol{k}$ falls outside this range, aliasing occurs, leading to $\\boldsymbol{k}_{\\text{alias}} \\neq \\boldsymbol{k}$ and a non-zero error, provided $s \\neq 0$. Notably, for a component at the Nyquist frequency (e.g., $k_l=N/2$ for even $N$), the alias is $(k_{\\text{alias}})_l=-N/2$, so $|k_l| = |(k_{\\text{alias}})_l|$. If all components are either non-aliased or at the Nyquist frequency, the norm is preserved, $|\\boldsymbol{k}_{\\text{alias}}| = |\\boldsymbol{k}|$, and the error remains $0$.\n\nThe following program implements this entire procedure, iterating through the provided test cases to compute the aliasing error for each.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs a pseudo-spectral Fourier discretization of the fractional Laplacian,\n    applies it to a complex plane wave, and quantifies the aliasing error.\n    \"\"\"\n    test_cases = [\n        # Case 1: d=1, N=64, s=0.75, k=(10) -> No aliasing\n        {'d': 1, 'N': 64, 's': 0.75, 'k_vec': np.array([10], dtype=float)},\n        # Case 2: d=1, N=64, s=1.0, k=(32) -> Nyquist boundary\n        {'d': 1, 'N': 64, 's': 1.0, 'k_vec': np.array([32], dtype=float)},\n        # Case 3: d=1, N=64, s=1.3, k=(50) -> Aliasing\n        {'d': 1, 'N': 64, 's': 1.3, 'k_vec': np.array([50], dtype=float)},\n        # Case 4: d=2, N=48, s=0.3, k=(10, 22) -> No aliasing\n        {'d': 2, 'N': 48, 's': 0.3, 'k_vec': np.array([10, 22], dtype=float)},\n        # Case 5: d=2, N=32, s=0.8, k=(20, 5) -> Aliasing\n        {'d': 2, 'N': 32, 's': 0.8, 'k_vec': np.array([20, 5], dtype=float)},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        d = case['d']\n        N = case['N']\n        s = case['s']\n        k_vec = case['k_vec']\n\n        # 1. Construct the grid\n        grid_1d_coords = np.arange(N) * (2 * np.pi / N)\n        # Create a list of 1D coordinate arrays for meshgrid\n        coords = [grid_1d_coords] * d\n        # `indexing='ij'` ensures meshgrid output matches matrix indexing\n        grid_coords = np.meshgrid(*coords, indexing='ij')\n\n        # 2. Sample u(x) = exp(i * k.x) on the grid\n        k_dot_x = np.zeros([N] * d)\n        for i in range(d):\n            k_dot_x += k_vec[i] * grid_coords[i]\n        u_grid = np.exp(1j * k_dot_x)\n\n        # 3. Apply the pseudo-spectral fractional Laplacian\n        # a) Compute d-dimensional DFT\n        u_hat = np.fft.fftn(u_grid)\n\n        # b) Construct the grid of Fourier wavevectors (xi)\n        freq_1d = np.fft.fftfreq(N) * N\n        freq_coords = [freq_1d] * d\n        xi_coords = np.meshgrid(*freq_coords, indexing='ij')\n\n        # c) Compute the symbol |xi|^(2s)\n        xi_norm_sq = np.zeros([N] * d)\n        for i in range(d):\n            xi_norm_sq += xi_coords[i]**2\n        \n        # Avoid taking sqrt of 0 and then raising to a power, use properties of exponents.\n        # symbol = |xi|^(2s) = (|xi|^2)^s\n        # Handle the case where xi is the zero vector, symbol should be 0.\n        symbol = np.power(xi_norm_sq, s, where=(xi_norm_sq > 0), out=np.zeros_like(xi_norm_sq))\n\n        # d) Multiply Fourier coefficients by the symbol\n        u_num_hat = symbol * u_hat\n\n        # e) Invert the DFT\n        u_num_grid = np.fft.ifftn(u_num_hat)\n\n        # 4. Form the exact grid function for (-Delta)^s u\n        k_norm = np.linalg.norm(k_vec)\n        \n        # The eigenvalue is 0 if k_vec is the zero vector.\n        if k_norm == 0:\n            exact_eigenvalue = 0.0\n        else:\n            exact_eigenvalue = k_norm**(2 * s)\n            \n        u_exact_grid = exact_eigenvalue * u_grid\n        \n        # 5. Quantify the aliasing error\n        numerator = np.max(np.abs(u_num_grid - u_exact_grid))\n        denominator = np.max(np.abs(u_exact_grid))\n\n        # As per problem, if denominator is 0, error is 0.\n        # This happens if k_vec=0, where exact_eigenvalue=0.\n        if np.isclose(denominator, 0.0):\n            error = 0.0\n        else:\n            error = numerator / denominator\n            \n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from periodic problems to bounded domains with Dirichlet boundary conditions requires a change of basis from Fourier modes to sine functions. This practice explores how to build spectral discretizations using the Discrete Sine Transform (DST), which diagonalizes the standard Dirichlet Laplacian. You will implement and compare two distinct but related approaches—one using the known continuous spectrum and another using the spectrum of a discrete Laplacian—to understand the nuances of discretization and gain experience in the vital skill of performing numerical convergence analysis .",
            "id": "3381295",
            "problem": "Consider the spectral fractional Laplacian, denoted by $(-\\Delta)^s$, on the $d$-dimensional open unit hypercube $\\Omega=(0,1)^d$ with homogeneous Dirichlet boundary conditions. The spectral definition of fractional powers of the Dirichlet Laplacian proceeds from the orthonormal eigenbasis of the standard Dirichlet Laplacian operator. Let $u:\\Omega\\to\\mathbb{R}$ be square-integrable and suppose $u$ is expanded in sine eigenfunctions. The action of $(-\\Delta)^s$ is defined by raising the corresponding Dirichlet Laplacian eigenvalues to the power $s$ within that expansion.\n\nYour task is to design and implement two consistent discretizations of $(-\\Delta)^s$ that act on grid samples of $u$ restricted to the interior grid of $\\Omega=(0,1)^d$. Both discretizations must rely only on fundamental definitions and well-tested numerical facts, starting from the spectral definition of the Dirichlet Laplacian and making use of the orthogonal sine basis on interior grids.\n\nDiscretization A (continuous-spectrum-based):\n- Use the orthonormal sine basis on the interior grid to map $u$ to sine coefficients via the Discrete Sine Transform (DST).\n- Apply the fractional operator by multiplying each sine coefficient by the appropriate continuous Dirichlet Laplacian eigenvalue raised to $s$, and then invert the transform to return to physical space.\n- This discretization is constructed from the continuous Dirichlet eigenpairs and is consistent with the spectral definition by construction.\n\nDiscretization B (finite-difference spectral matrix power):\n- Use the same sine basis on the interior grid; however, instead of continuous eigenvalues, use the eigenvalues of the standard central-difference Dirichlet discrete Laplacian matrix on the interior grid.\n- Apply the fractional operator by raising those discrete eigenvalues to the power $s$ in the sine basis, and invert the transform.\n\nBenchmark suite setup:\n- Use the test function $u(x)=\\prod_{j=1}^d \\sin(\\pi x_j)$, which is a single sine eigenfunction for the Dirichlet Laplacian on $(0,1)^d$.\n- Derive the exact action of $(-\\Delta)^s$ on $u$ from the spectral definition and the characterization of Dirichlet Laplacian eigenpairs on $(0,1)^d$. Use this exact action as the reference solution to compute errors for both discretizations on interior grids.\n- For each test case, form an interior uniform grid with $N$ points per coordinate direction. The interior grid nodes are $x_i=i/(N+1)$ for $i=1,\\dots,N$ in each dimension, and the grid spacing is $h=1/(N+1)$.\n- Compute the error of Discretization A as the maximum absolute pointwise difference between its output and the exact reference at the finest grid.\n- For Discretization B, compute the relative $\\ell^2$ error $\\|e\\|_2/\\|f\\|_2$, where $e$ is the difference between the discrete output and the exact reference on the grid, and $f$ is the exact reference, for three grid sizes. From these three errors and their associated grid spacings, estimate the observed order of convergence by a least-squares fit to $\\log_{10}(\\text{error})$ versus $\\log_{10}(h)$.\n- The Discrete Sine Transform (DST) refers to an orthonormal Fast Fourier Transform (FFT)-based implementation of the sine expansion on grids that respect Dirichlet boundary conditions on $(0,1)^d$.\n\nTest suite:\n- Dimensions $d\\in\\{1,2\\}$.\n- Fractional orders $s\\in\\{0.25,0.5,0.75\\}$.\n- For each pair $(d,s)$, use interior grid sizes $N\\in\\{15,31,63\\}$ to compute errors and estimate the observed convergence rate for Discretization B. Also compute the Discretization A maximum absolute error at the finest grid $N=63$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order:\n    1. First, for each $(d,s)$ pair with $d$ increasing and, within each $d$, $s$ in increasing order, the observed convergence rate for Discretization B, rounded to three decimal places. There are six such rates (two dimensions times three fractional orders).\n    2. Then, for the same $(d,s)$ order, the maximum absolute pointwise error of Discretization A at $N=63$, rounded to twelve decimal places. There are six such errors.\n- For clarity, the output will therefore contain twelve floating-point numbers. No units apply. Angles are not involved, and no percentages are used; all values are pure real numbers without units.\n- Example output format (with placeholder numbers): \"[r11,r12,r13,r21,r22,r23,e11,e12,e13,e21,e22,e23]\" where $r_{ij}$ represents the rate for dimension $i$ and fractional order index $j$, and $e_{ij}$ the corresponding Discretization A error at the finest grid.\n\nYour implementation must be a complete, runnable program that performs the described computations without any external input or files and prints the single required output line.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the theory of partial differential equations and numerical analysis, specifically concerning the spectral definition and numerical approximation of the fractional Laplacian operator. The problem is well-posed, providing a clear objective, a complete set of definitions, a specific test case, and a precisely defined set of required outputs and error metrics. All terms are formally defined and used consistently, and the task is computationally feasible.\n\nThe core of the problem is to discretize the spectral fractional Laplacian $(-\\Delta)^s$ on the domain $\\Omega=(0,1)^d$. The operator is defined via the spectral decomposition of the standard Dirichlet Laplacian $-\\Delta$.\n\nFirst, we establish the analytical foundation. The eigenfunctions and eigenvalues of $-\\Delta$ on $\\Omega=(0,1)^d$ with homogeneous Dirichlet boundary conditions are given by\n$$ \\phi_{\\mathbf{k}}(x) = \\prod_{j=1}^{d} \\sqrt{2} \\sin(k_j \\pi x_j), \\quad \\lambda_{\\mathbf{k}} = \\sum_{j=1}^{d} (k_j \\pi)^2 = \\pi^2 \\|\\mathbf{k}\\|_2^2 $$\nfor a multi-index of positive integers $\\mathbf{k} = (k_1, \\dots, k_d) \\in (\\mathbb{Z}^+)^d$. By spectral definition, the action of $(-\\Delta)^s$ on an eigenfunction is $(-\\Delta)^s \\phi_{\\mathbf{k}} = (\\lambda_{\\mathbf{k}})^s \\phi_{\\mathbf{k}}$.\n\nThe specified test function is $u(x) = \\prod_{j=1}^d \\sin(\\pi x_j)$. This function is proportional to the first eigenfunction $\\phi_{(1,\\dots,1)}(x)$, corresponding to the multi-index $\\mathbf{k}=(1,\\dots,1)$. The associated eigenvalue is $\\lambda_{(1,\\dots,1)} = \\sum_{j=1}^d (1 \\cdot \\pi)^2 = d\\pi^2$.\nTherefore, the exact action of the fractional operator on $u$ is a simple scaling:\n$$ f(x) = (-\\Delta)^s u(x) = (\\lambda_{(1,\\dots,1)})^s u(x) = (d\\pi^2)^s \\prod_{j=1}^d \\sin(\\pi x_j) $$\nThis function $f(x)$ serves as the exact reference solution. We evaluate it on the grid points to obtain the reference grid function $f_{grid}$ for error computations.\n\nThe problem requires discretization on a uniform interior grid with $N$ points in each of the $d$ dimensions. The grid points are $\\mathbf{x}_{\\mathbf{i}} = (i_1 h, \\dots, i_d h)$ for multi-index $\\mathbf{i}=(i_1, \\dots, i_d)$ with $i_j \\in \\{1,\\dots,N\\}$. The grid spacing is $h = 1/(N+1)$.\n\nBoth proposed discretization methods leverage the Discrete Sine Transform (DST). The orthonormal Type-I DST corresponds to a change of basis to the discrete sine functions $\\psi_{\\mathbf{k}}(\\mathbf{i}) \\propto \\prod_{j=1}^d \\sin(\\pi k_j i_j / (N+1))$, which are the exact eigenvectors of the standard central-difference discrete Laplacian on the interior grid. The DST thus diagonalizes the discrete operator, making it the numerical analogue of the continuous sine series expansion. We use the `scipy.fft` library's `dstn` and `idstn` functions with `type=1` and `norm='ortho'`.\n\nDiscretization A (continuous-spectrum-based):\nThis method approximates $(-\\Delta)^s u$ by applying the continuous spectrum in the discrete basis. The algorithm is:\n1.  Compute the grid function $u_{grid}$ by evaluating $u(x)$ at the grid nodes.\n2.  Compute the $d$-dimensional DST of $u_{grid}$ to obtain the coefficients $\\hat{u}_{\\mathbf{k}}$.\n3.  Construct a $d$-dimensional grid of continuous eigenvalues, where the entry at index $\\mathbf{k}$ is $(\\lambda_{\\mathbf{k}})^s = (\\pi^2 \\|\\mathbf{k}\\|_2^2)^s$ for mode $\\mathbf{k}=(k_1,\\dots,k_d)$, with $k_j \\in \\{1,\\dots,N\\}$.\n4.  Multiply the coefficients by the corresponding spectral multipliers: $\\hat{f}_{A,\\mathbf{k}} = (\\lambda_{\\mathbf{k}})^s \\hat{u}_{\\mathbf{k}}$.\n5.  Compute the inverse DST of $\\hat{f}_{A,\\mathbf{k}}$ to obtain the numerical solution $f_{A,grid}$.\nFor the given test function $u(x)$, the grid samples $u_{grid}$ are exactly proportional to the first discrete sine basis vector $\\psi_{(1,\\dots,1)}$. This means its DST, $\\hat{u}_{\\mathbf{k}}$, is a discrete delta function. Since this mode is also an eigenfunction of the continuous operator, and the method uses the exact continuous eigenvalue for this mode, the resulting approximation $f_{A,grid}$ is expected to be identical to the exact solution $f_{grid}$ up to machine precision. The maximum absolute error, $\\max |f_{A,grid} - f_{grid}|$, should therefore be close to zero.\n\nDiscretization B (finite-difference spectral matrix power):\nThis method uses the spectrum of the discrete Laplacian matrix itself. The algorithm is:\n1.  Compute the DST of $u_{grid}$ to get coefficients $\\hat{u}_{\\mathbf{k}}$.\n2.  The eigenvalues of the $d$-dimensional central-difference discrete Laplacian are $\\mu_{\\mathbf{k}} = \\sum_{j=1}^d \\mu_{k_j}$, where the 1D eigenvalues are $\\mu_{k_j} = \\frac{4}{h^2}\\sin^2(\\frac{k_j \\pi h}{2})$.\n3.  Construct a grid of these discrete eigenvalues and compute the spectral multipliers $(\\mu_{\\mathbf{k}})^s$.\n4.  Multiply the coefficients: $\\hat{f}_{B,\\mathbf{k}} = (\\mu_{\\mathbf{k}})^s \\hat{u}_{\\mathbf{k}}$.\n5.  Compute the inverse DST to obtain the numerical solution $f_{B,grid}$.\nThe error in this method comes from approximating the continuous eigenvalues $\\lambda_{\\mathbf{k}}$ with the discrete ones $\\mu_{\\mathbf{k}}$. A Taylor series expansion for small $h$ reveals that $\\mu_k = (k\\pi)^2 - \\frac{(k\\pi)^4}{12}h^2 + O(h^4) = \\lambda_k(1 - \\frac{(k\\pi)^2}{12}h^2 + O(h^4))$. The error in the eigenvalue is of order $O(h^2)$. Consequently, the relative error in the final solution, $\\|f_{B,grid}-f_{grid}\\|_2/\\|f_{grid}\\|_2$, is also expected to be of order $O(h^2)$. The convergence rate, estimated by a least-squares fit on $\\log_{10}(\\text{error})$ versus $\\log_{10}(h)$, should be approximately $2$.\n\nThe implementation will loop over the specified dimensions $d$ and fractional orders $s$. For each pair, it will compute the Discretization A error on the finest grid ($N=63$) and the Discretization B errors for three grid sizes ($N=15, 31, 63$). The latter are used to compute the observed convergence rate for Discretization B. The final results are collected and formatted as specified.",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import dstn, idstn\n\ndef solve():\n    \"\"\"\n    Computes errors and convergence rates for two discretizations\n    of the fractional Laplacian.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases_ds = [(d, s) for d in [1, 2] for s in [0.25, 0.5, 0.75]]\n    Ns = [15, 31, 63]\n\n    rates_B = []\n    errors_A_final = []\n\n    for d, s in test_cases_ds:\n        errors_B_case = []\n        hs_B_case = []\n\n        for N in Ns:\n            # Grid setup\n            h = 1.0 / (N + 1)\n            \n            # Create a list of 1D axes for grid creation\n            axes = [np.arange(1, N + 1)] * d\n            # Create indexing grids for coordinates and modes\n            # `ij` indexing aligns with scipy.fft output for separable transforms\n            indices = np.meshgrid(*axes, indexing='ij')\n\n            # Physical grid coordinates\n            grid_coords = [idx * h for idx in indices]\n\n            # Evaluate test function u(x) on the grid\n            sin_parts_u = [np.sin(np.pi * coord) for coord in grid_coords]\n            u_grid = np.prod(sin_parts_u, axis=0)\n\n            # Evaluate exact solution f(x) on the grid\n            # The continuous eigenvalue for u(x) is d * pi^2\n            lambda_u_continuous = d * np.pi**2\n            f_grid = (lambda_u_continuous**s) * u_grid\n\n            # Perform DST on the grid function\n            # Use Type-I orthonormal DST, which corresponds to the sine expansion\n            # for homogeneous Dirichlet boundary conditions.\n            u_hat = dstn(u_grid, type=1, norm='ortho')\n\n            # --- Discretization B (Finite-difference spectral matrix power) ---\n            \n            # Grid of eigenvalues for discrete Laplacian\n            # Mode indices `k` are captured by `indices`\n            sin_sq_parts_mu = [np.sin(k * np.pi * h / 2.0)**2 for k in indices]\n            sum_sin_sq = np.sum(sin_sq_parts_mu, axis=0)\n            mu_discrete_grid = (4.0 / h**2) * sum_sin_sq\n            \n            # Apply fractional operator in spectral domain\n            f_B_hat = u_hat * (mu_discrete_grid**s)\n            \n            # Inverse DST to return to physical space\n            f_B_grid = idstn(f_B_hat, type=1, norm='ortho')\n            \n            # Compute relative l2 error for Discretization B\n            error_vec_B = f_B_grid - f_grid\n            norm_e = np.linalg.norm(error_vec_B)\n            norm_f = np.linalg.norm(f_grid)\n            \n            relative_l2_error_B = norm_e / norm_f if norm_f > 0 else 0.0\n            \n            errors_B_case.append(relative_l2_error_B)\n            hs_B_case.append(h)\n            \n            # --- Discretization A (Continuous-spectrum-based, only for finest grid) ---\n            if N == Ns[-1]:\n                # Grid of eigenvalues for continuous Laplacian\n                sq_k_parts = [k**2 for k in indices]\n                sum_sq_k = np.sum(sq_k_parts, axis=0)\n                lambda_continuous_grid = np.pi**2 * sum_sq_k\n                \n                # Apply fractional operator\n                f_A_hat = u_hat * (lambda_continuous_grid**s)\n                \n                # Inverse DST\n                f_A_grid = idstn(f_A_hat, type=1, norm='ortho')\n                \n                # Compute maximum absolute error for Discretization A\n                max_abs_error_A = np.max(np.abs(f_A_grid - f_grid))\n                errors_A_final.append(max_abs_error_A)\n\n        # After looping through N, compute convergence rate for B\n        log_h = np.log10(np.array(hs_B_case))\n        log_err = np.log10(np.array(errors_B_case))\n        \n        # Fit a line to log(error) vs log(h) to find the slope (rate)\n        # polyfit returns [slope, intercept]\n        rate_B, _ = np.polyfit(log_h, log_err, 1)\n        rates_B.append(rate_B)\n\n    # Format the results for the final output string\n    # Rates are rounded to 3 decimal places\n    # Errors are rounded to 12 decimal places\n    formatted_rates_B = [f\"{r:.3f}\" for r in rates_B]\n    formatted_errors_A = [f\"{e:.12f}\" for e in errors_A_final]\n    \n    # Combine the lists in the specified order: rates first, then errors\n    all_results = formatted_rates_B + formatted_errors_A\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Solving the linear system of equations that arises from discretizing the fractional Poisson problem, $(-\\Delta)^s u = f$, presents a significant computational challenge due to the dense and severely ill-conditioned nature of the resulting matrix. This exercise tackles this practical issue by exploring preconditioning, a cornerstone technique for efficient iterative solvers. You will numerically investigate the effectiveness of using the standard local Laplacian $(-\\Delta)$ as a preconditioner, estimate the condition number's scaling with mesh refinement, and verify the theoretical predictions that govern solver performance .",
            "id": "3381280",
            "problem": "You are asked to investigate the effectiveness of using the local Laplacian operator as a preconditioner for the fractional Laplacian in one spatial dimension on the unit interval with homogeneous Dirichlet boundary conditions. Work entirely in a purely mathematical and algorithmic setting with no physical units. All angles, when needed, must be treated as dimensionless arguments to trigonometric functions. The task is to design and implement a program that constructs discrete operators for two discretization families and empirically estimates the growth rate of the condition number of the preconditioned system as a function of the mesh size and the fractional order.\n\nStart from the following foundational definitions and facts.\n\n1. For a symmetric positive definite matrix operator $A$, its spectral fractional power $A^{s}$ for $s \\in \\mathbb{R}$ is defined via its spectral decomposition: if $A \\varphi_{i} = \\lambda_{i} \\varphi_{i}$ with orthonormal eigenvectors $\\{\\varphi_{i}\\}$ and eigenvalues $\\{\\lambda_{i}\\} \\subset (0,\\infty)$, then $A^{s} \\varphi_{i} = \\lambda_{i}^{s} \\varphi_{i}$ and extended linearly.\n\n2. The condition number of a symmetric positive definite matrix $B$ with respect to the Euclidean norm is $\\kappa(B) = \\lambda_{\\max}(B)/\\lambda_{\\min}(B)$, where $\\lambda_{\\max}(B)$ and $\\lambda_{\\min}(B)$ are the largest and smallest eigenvalues of $B$, respectively.\n\n3. Consider the one-dimensional interval $(0,1)$ with homogeneous Dirichlet boundary conditions at $x=0$ and $x=1$. Two standard discretizations of the Laplacian are:\n   - A finite difference scheme using the standard three-point stencil on a uniform grid of interior points with spacing $h$.\n   - A finite element method using continuous, piecewise linear basis functions on a uniform mesh of elements of size $h$, with assembled stiffness matrix $K$ and mass matrix $M$.\n\n4. For the finite difference discretization, let $A$ denote the symmetric positive definite discrete Laplacian matrix. For the finite element discretization, consider the generalized eigenproblem $K \\phi_{i} = \\lambda_{i} M \\phi_{i}$, where $K$ is the stiffness matrix and $M$ is the mass matrix.\n\nYour task is as follows.\n\nA. For the finite difference discretization:\n   - Construct the discrete Laplacian operator $A$ on $(0,1)$ with homogeneous Dirichlet boundary conditions using the standard three-point stencil on $n$ interior grid points with spacing $h = 1/(n+1)$.\n   - Define the fractional operator $A^{s}$ for $s \\in (0,1]$ spectrally.\n   - Consider preconditioning the linear system $A^{s} u = f$ by $A$, forming the preconditioned operator $A^{-1} A^{s}$.\n   - Theoretical scaling predicts that $\\kappa(A^{-1} A^{s})$ grows asymptotically like $h^{-p(s)}$ as $h \\to 0$ for some exponent $p(s)$ depending on $s$.\n   - Implement a procedure that, for fixed $s$, computes $\\kappa(A^{-1} A^{s})$ for several values of $n$ (and hence $h$), and estimates the exponent $p(s)$ by a least-squares linear fit of $\\log \\kappa$ versus $\\log h$.\n\nB. For the finite element discretization:\n   - Assemble the stiffness matrix $K$ and mass matrix $M$ for continuous, piecewise linear finite elements on a uniform mesh of $N_{e}$ elements covering $(0,1)$ with homogeneous Dirichlet boundary conditions at the endpoints. The number of interior degrees of freedom is $N = N_{e} - 1$, and the mesh size is $h = 1/N_{e}$.\n   - Consider the generalized eigenpairs $(\\lambda_{i}, \\phi_{i})$ satisfying $K \\phi_{i} = \\lambda_{i} M \\phi_{i}$ with $\\lambda_{i} > 0$.\n   - Define the discrete spectral fractional operator $K^{s}$ via the generalized eigenpairs, and consider preconditioning the linear system $K^{s} u = f$ (interpreted in the consistent discrete sense) by $K$, forming the operator $K^{-1} K^{s}$.\n   - Implement a procedure that, for fixed $s$, computes the generalized extreme eigenvalues needed to determine $\\kappa(K^{-1} K^{s})$ for several values of $N_{e}$ (and hence $h$), and estimates the exponent $p(s)$ by a least-squares linear fit of $\\log \\kappa$ versus $\\log h$.\n\nC. For both discretizations in parts A and B, and for each value of $s \\in \\{0.25, 0.5, 0.75, 1.0\\}$, estimate the growth exponent $p(s)$ from three mesh sizes. The mesh sizes must be:\n   - For the finite difference method, use $n \\in \\{63, 127, 255\\}$ interior points, with $h = 1/(n+1)$.\n   - For the finite element method, use $N_{e} \\in \\{64, 128, 256\\}$ elements, with $h = 1/N_{e}$.\n\nD. Theoretical expectation to be tested: under uniform meshes and standard conforming constructions in one dimension, the eigenvalues of the local Laplacian discretization scale like $h^{-2}$. Using this fact and the spectral definition of fractional powers, the theoretically predicted exponent is $p_{\\mathrm{th}}(s) = 2 (1 - s)$ for both discretizations when preconditioning $(-\\Delta)^{s}$ by $(-\\Delta)$.\n\nE. Implement a program that executes the above procedures and, for each of the following eight test cases, returns whether the empirically estimated exponent $p_{\\mathrm{est}}(s)$ matches the theoretical $p_{\\mathrm{th}}(s)$ within a tolerance of $\\pm 0.3$:\n   - Finite difference with $s = 0.25$.\n   - Finite difference with $s = 0.5$.\n   - Finite difference with $s = 0.75$.\n   - Finite difference with $s = 1.0$.\n   - Finite element with $s = 0.25$.\n   - Finite element with $s = 0.5$.\n   - Finite element with $s = 0.75$.\n   - Finite element with $s = 1.0$.\n\nYour program should produce a single line of output containing the results for these eight cases as a comma-separated list of boolean values enclosed in square brackets (for example, \"[True,False,True,True,False,True,True,True]\"). The order of the results in the list must be exactly as listed above. No inputs are to be read, and no units are involved. Angles used in trigonometric functions are to be interpreted as dimensionless quantities. All computations must be reproducible based solely on the definitions and procedures specified here.",
            "solution": "The problem requires an empirical investigation into the spectral properties of a preconditioned fractional Laplacian system. Specifically, we are to estimate the growth rate of the condition number of the system $(-\\Delta)^{-1}(-\\Delta)^s$ as a function of the mesh size $h$, where $(-\\Delta)$ is the standard one-dimensional Laplacian operator on the interval $(0,1)$ with homogeneous Dirichlet boundary conditions. We will analyze two common discretization schemes: the finite difference method (FDM) and the finite element method (FEM).\n\nThe core of the analysis rests on the spectral definition of fractional matrix powers. For a symmetric positive definite (SPD) matrix operator $A$ with eigenvalues $\\lambda_i$ and corresponding eigenvectors $\\varphi_i$, the operator $A^s$ is defined by its action on the same eigenvectors: $A^s \\varphi_i = \\lambda_i^s \\varphi_i$. The preconditioner is the non-fractional operator $A$ itself. The preconditioned operator is thus $P = A^{-1}A^s$. Since $A^{-1}$ and $A^s$ are both functions of $A$, they commute and share the same eigenvectors $\\varphi_i$. The eigenvalues of the preconditioned operator $P$ are therefore $\\mu_i = \\lambda_i^{-1} \\lambda_i^s = \\lambda_i^{s-1}$.\n\nThe condition number of a symmetric positive definite matrix $B$ is $\\kappa(B) = \\lambda_{\\max}(B)/\\lambda_{\\min}(B)$. For our preconditioned operator $P$, we must determine its extreme eigenvalues. The fractional order $s$ is in the range $(0,1]$, so the exponent $s-1$ is in $(-1,0]$. This means that if $\\lambda_i$ are the eigenvalues of $A$ sorted in increasing order, $\\lambda_{\\min}(A) \\le \\lambda_i \\le \\lambda_{\\max}(A)$, the eigenvalues $\\mu_i = \\lambda_i^{s-1}$ of $P$ will be in reverse order: $\\mu_{\\max}(P) = (\\lambda_{\\min}(A))^{s-1}$ and $\\mu_{\\min}(P) = (\\lambda_{\\max}(A))^{s-1}$. The condition number of the preconditioned system is:\n$$\n\\kappa(P) = \\frac{\\mu_{\\max}(P)}{\\mu_{\\min}(P)} = \\frac{(\\lambda_{\\min}(A))^{s-1}}{(\\lambda_{\\max}(A))^{s-1}} = \\left(\\frac{\\lambda_{\\min}(A)}{\\lambda_{\\max}(A)}\\right)^{s-1} = \\left(\\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)}\\right)^{1-s}\n$$\nThe problem states that for standard discretizations of the 1D Laplacian, the eigenvalues scale as $\\lambda_{\\min}(A) \\approx C_1$ (a constant) and $\\lambda_{\\max}(A) \\approx C_2 h^{-2}$ as the mesh size $h \\to 0$. Substituting this into the expression for the condition number gives the expected asymptotic behavior:\n$$\n\\kappa(P) \\approx \\left(\\frac{C_2 h^{-2}}{C_1}\\right)^{1-s} \\propto (h^{-2})^{1-s} = h^{-2(1-s)}\n$$\nTaking the logarithm of both sides yields a linear relationship: $\\log(\\kappa) = -2(1-s)\\log(h) + \\text{const}$. The theoretical growth exponent is thus $p_{\\mathrm{th}}(s) = 2(1-s)$. Our task is to estimate this exponent $p(s)$ numerically for several values of $s$ and for both FDM and FEM discretizations.\n\nThe numerical estimation procedure is as follows: for a given discretization method and a fixed value of $s$, we compute the condition number $\\kappa$ for three prescribed mesh sizes $h$. This gives us three data points $(\\log(h_i), \\log(\\kappa_i))$. We then perform a linear least-squares fit on these points to find the slope $m$ of the best-fit line $\\log(\\kappa) = m \\log(h) + c$. The estimated exponent is $p_{\\mathrm{est}}(s) = -m$.\n\n**Part A: Finite Difference Method (FDM)**\nFor the FDM, we discretize the operator $-d^2/dx^2$ on a uniform grid with $n$ interior points. The mesh spacing is $h = 1/(n+1)$. The standard three-point central difference stencil leads to the $n \\times n$ symmetric tridiagonal matrix:\n$$\nA = \\frac{1}{h^2}\n\\begin{pmatrix}\n2 & -1 & & & \\mathbf{0} \\\\\n-1 & 2 & -1 & & \\\\\n& \\ddots & \\ddots & \\ddots & \\\\\n& & -1 & 2 & -1 \\\\\n\\mathbf{0} & & & -1 & 2\n\\end{pmatrix}\n$$\nFor each $n \\in \\{63, 127, 255\\}$, we construct this matrix $A$, compute its minimum and maximum eigenvalues $\\lambda_{\\min}(A)$ and $\\lambda_{\\max}(A)$, calculate $\\kappa = (\\lambda_{\\max}(A)/\\lambda_{\\min}(A))^{1-s}$, and record the point $(\\log(h), \\log(\\kappa))$. A linear fit to these three points gives $p_{\\mathrm{est}}(s)$.\n\n**Part B: Finite Element Method (FEM)**\nFor the FEM, we use continuous, piecewise linear basis functions on a uniform mesh of $N_e$ elements. This yields $N = N_e - 1$ interior degrees of freedom. The mesh size is $h = 1/N_e$. The discretization leads to a generalized eigenvalue problem $K\\phi = \\lambda M\\phi$, where $K$ is the stiffness matrix and $M$ is the mass matrix. These $N \\times N$ matrices are:\n$$\nK = \\frac{1}{h}\n\\begin{pmatrix}\n2 & -1 & & & \\mathbf{0} \\\\\n-1 & 2 & -1 & & \\\\\n& \\ddots & \\ddots & \\ddots & \\\\\n& & -1 & 2 & -1 \\\\\n\\mathbf{0} & & & -1 & 2\n\\end{pmatrix}\n\\quad , \\quad\nM = \\frac{h}{6}\n\\begin{pmatrix}\n4 & 1 & & & \\mathbf{0} \\\\\n1 & 4 & 1 & & \\\\\n& \\ddots & \\ddots & \\ddots & \\\\\n& & 1 & 4 & 1 \\\\\n\\mathbf{0} & & & 1 & 4\n\\end{pmatrix}\n$$\nThe condition number of the preconditioned system is again $\\kappa = (\\lambda_{\\max}/\\lambda_{\\min})^{1-s}$, where $\\lambda_{\\min}$ and $\\lambda_{\\max}$ are the smallest and largest generalized eigenvalues of the pair $(K, M)$. For each $N_e \\in \\{64, 128, 256\\}$, we construct $K$ and $M$, solve for the extreme generalized eigenvalues, compute $\\kappa$, and record $(\\log(h), \\log(\\kappa))$. A linear fit provides $p_{\\mathrm{est}}(s)$.\n\n**Part C, D, E: Final Comparison**\nFor each of the eight test cases (FDM/FEM with $s \\in \\{0.25, 0.5, 0.75, 1.0\\}$), we calculate the theoretical exponent $p_{\\mathrm{th}}(s) = 2(1-s)$. We then check if the empirically estimated exponent $p_{\\mathrm{est}}(s)$ falls within the specified tolerance: $|p_{\\mathrm{est}}(s) - p_{\\mathrm{th}}(s)| \\le 0.3$. The boolean result of this check for each case constitutes the final output. For the special case $s=1.0$, $p_{\\mathrm{th}}(1.0) = 0$, and the preconditioned operator is the identity matrix, so $\\kappa=1$ and $\\log(\\kappa)=0$, which should yield $p_{\\mathrm{est}}(1.0)=0$ exactly, providing a useful sanity check for the implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef estimate_p_fdm(s, n_values):\n    \"\"\"\n    Estimates the exponent p(s) for the Finite Difference Method.\n\n    Args:\n        s (float): The fractional order.\n        n_values (list of int): List of numbers of interior grid points.\n\n    Returns:\n        float: The estimated exponent p_est(s).\n    \"\"\"\n    log_h_vals = []\n    log_kappa_vals = []\n\n    for n in n_values:\n        h = 1.0 / (n + 1)\n        \n        # For s=1.0, the preconditioned operator is the identity, kappa=1.\n        if s == 1.0:\n            kappa = 1.0\n        else:\n            # Construct the FDM Laplacian matrix A.\n            # A = (1/h^2) * tridiag(-1, 2, -1)\n            main_diag = 2.0 * np.ones(n)\n            off_diag = -1.0 * np.ones(n - 1)\n            A = (1 / h**2) * (np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1))\n            \n            # Eigenvalues of A. eigvalsh is efficient for symmetric matrices.\n            eigenvalues = np.linalg.eigvalsh(A)\n            lambda_min = eigenvalues[0]\n            lambda_max = eigenvalues[-1]\n            \n            # Condition number of the preconditioned operator.\n            kappa = (lambda_max / lambda_min)**(1.0 - s)\n        \n        log_h_vals.append(np.log(h))\n        log_kappa_vals.append(np.log(kappa))\n        \n    # Perform linear least-squares fit: log(kappa) = m * log(h) + c\n    # The slope m is -p_est.\n    coeffs = np.polyfit(log_h_vals, log_kappa_vals, 1)\n    p_est = -coeffs[0]\n    \n    return p_est\n\ndef estimate_p_fem(s, Ne_values):\n    \"\"\"\n    Estimates the exponent p(s) for the Finite Element Method.\n\n    Args:\n        s (float): The fractional order.\n        Ne_values (list of int): List of numbers of elements.\n\n    Returns:\n        float: The estimated exponent p_est(s).\n    \"\"\"\n    log_h_vals = []\n    log_kappa_vals = []\n\n    for Ne in Ne_values:\n        N = Ne - 1\n        h = 1.0 / Ne\n        \n        if s == 1.0:\n            kappa = 1.0\n        else:\n            # Construct the stiffness matrix K and mass matrix M.\n            # K = (1/h) * tridiag(-1, 2, -1)\n            main_diag_K = 2.0 * np.ones(N)\n            off_diag_K = -1.0 * np.ones(N - 1)\n            K = (1 / h) * (np.diag(main_diag_K) + np.diag(off_diag_K, k=1) + np.diag(off_diag_K, k=-1))\n            \n            # M = (h/6) * tridiag(1, 4, 1)\n            main_diag_M = 4.0 * np.ones(N)\n            off_diag_M = 1.0 * np.ones(N - 1)\n            M = (h / 6.0) * (np.diag(main_diag_M) + np.diag(off_diag_M, k=1) + np.diag(off_diag_M, k=-1))\n            \n            # Solve the generalized eigenvalue problem K*v = lambda*M*v.\n            # eigh is suitable for symmetric/Hermitian matrices.\n            eigenvalues = eigh(K, M, eigvals_only=True)\n            lambda_min = eigenvalues[0]\n            lambda_max = eigenvalues[-1]\n            \n            # Condition number of the preconditioned operator.\n            kappa = (lambda_max / lambda_min)**(1.0 - s)\n            \n        log_h_vals.append(np.log(h))\n        log_kappa_vals.append(np.log(kappa))\n        \n    # Perform linear least-squares fit.\n    coeffs = np.polyfit(log_h_vals, log_kappa_vals, 1)\n    p_est = -coeffs[0]\n    \n    return p_est\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (method, s_value, mesh_sizes)\n        (\"FDM\", 0.25, [63, 127, 255]),\n        (\"FDM\", 0.50, [63, 127, 255]),\n        (\"FDM\", 0.75, [63, 127, 255]),\n        (\"FDM\", 1.00, [63, 127, 255]),\n        (\"FEM\", 0.25, [64, 128, 256]),\n        (\"FEM\", 0.50, [64, 128, 256]),\n        (\"FEM\", 0.75, [64, 128, 256]),\n        (\"FEM\", 1.00, [64, 128, 256]),\n    ]\n    \n    tolerance = 0.3\n    results = []\n\n    for method, s, meshes in test_cases:\n        p_th = 2.0 * (1.0 - s)\n        \n        if method == \"FDM\":\n            p_est = estimate_p_fdm(s, meshes)\n        elif method == \"FEM\":\n            p_est = estimate_p_fem(s, meshes)\n        else:\n            # This case should not be reached with the current test_cases setup.\n            raise ValueError(\"Unknown method specified.\")\n            \n        match = abs(p_est - p_th) = tolerance\n        results.append(match)\n\n    # Final print statement in the exact required format.\n    # str(True) -> 'True', str(False) -> 'False' which is correct for boolean values in the output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}