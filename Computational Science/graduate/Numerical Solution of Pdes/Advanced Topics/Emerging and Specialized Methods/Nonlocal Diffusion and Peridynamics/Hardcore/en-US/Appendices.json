{
    "hands_on_practices": [
        {
            "introduction": "In meshfree methods like peridynamics, we approximate the nonlocal integral operator using a weighted sum over neighboring particles. This exercise guides you through the fundamental task of deriving these quadrature weights from a crucial consistency requirement known as the nonlocal patch test. By ensuring your discrete operator exactly reproduces linear fields, you establish the foundation for a convergent and accurate numerical model, which is a cornerstone of reliable simulation .",
            "id": "3425204",
            "problem": "Consider the meshfree discretization of a nonlocal diffusion operator used in Peridynamics, formulated for a scalar field $u$ as the integral operator over a neighborhood of radius $\\delta$, $$\\mathcal{L}u(\\mathbf{x})=\\int_{B_\\delta(\\mathbf{x})}\\gamma(\\|\\mathbf{y}-\\mathbf{x}\\|)\\,\\big(u(\\mathbf{y})-u(\\mathbf{x})\\big)\\,\\mathrm{d}\\mathbf{y},$$ where $B_\\delta(\\mathbf{x})$ denotes the ball of radius $\\delta$ centered at $\\mathbf{x}$ and $\\gamma$ is a nonnegative influence function. In a meshfree particle method, this operator is approximated by a particle quadrature of the form $$\\mathcal{L}u(\\mathbf{x}_i)\\approx\\sum_{j\\in\\mathcal{N}(i)}\\omega_{ij}\\,\\big(u(\\mathbf{x}_j)-u(\\mathbf{x}_i)\\big),$$ where $\\mathbf{x}_i$ is a particle position, $\\mathcal{N}(i)$ is its neighbor set, and $\\omega_{ij}$ are weights to be determined.\n\nA fundamental requirement for numerical consistency is a nonlocal patch test: exact reproduction of linear fields. That is, for any linear function $u(\\mathbf{x})=a+\\mathbf{b}\\cdot\\mathbf{x}$ with constants $a\\in\\mathbb{R}$ and $\\mathbf{b}\\in\\mathbb{R}^d$, the discrete operator should reproduce the continuous behavior dictated by the integral; for a bond-based model with a symmetric and isotropic kernel, this operator vanishes when applied to a linear field. This is ensured by imposing the following moment constraints on the particle quadrature weights:\n- First-moment cancellation: $$\\sum_{j\\in\\mathcal{N}(i)}\\omega_{ij}\\,(\\mathbf{x}_j-\\mathbf{x}_i)=\\mathbf{0}.$$\n- Isotropic second-moment matching: $$\\sum_{j\\in\\mathcal{N}(i)}\\omega_{ij}\\,(\\mathbf{x}_j-\\mathbf{x}_i)\\otimes(\\mathbf{x}_j-\\mathbf{x}_i)=C\\,I_d,$$ where $I_d$ is the $d\\times d$ identity matrix and $C0$ is a prescribed constant determining the overall magnitude of the second moment.\n\nYour task is to design a meshfree particle quadrature at a single particle $i$ by computing weights $\\omega_{ij}$ for a given neighbor geometry that exactly satisfy the above moment constraints in $d$ spatial dimensions whenever the geometry is sufficiently rich, and otherwise yield the least-squares best approximation to these constraints. The design must start from first principles: the requirement that discrete quadrature exactly reproduces polynomial fields up to linear order for the nonlocal diffusion operator, and the definition of the constraints needed for consistency and isotropy. You must then construct a general algorithm that, for a given dimension $d$, a list of neighbor offsets $\\mathbf{r}_j=\\mathbf{x}_j-\\mathbf{x}_i\\in\\mathbb{R}^d$, and a constant $C$, computes the vector of weights $\\boldsymbol{\\omega}_i=\\{\\omega_{ij}\\}_{j\\in\\mathcal{N}(i)}$ by solving the corresponding moment-fitting problem.\n\nThe program must do the following for each test case:\n1. Take the dimension $d$, a list of neighbor offsets $\\{\\mathbf{r}_j\\}_{j=1}^n$, and a constant $C$.\n2. Formulate the linear moment constraints explicitly as\n   - For each coordinate index $a\\in\\{1,\\dots,d\\}$: $$\\sum_{j=1}^n \\omega_{ij}\\,r_{j,a}=0,$$ where $r_{j,a}$ denotes the $a$-th component of $\\mathbf{r}_j$.\n   - For each pair of distinct indices $a,b$ with $1\\le ab\\le d$: $$\\sum_{j=1}^n \\omega_{ij}\\,r_{j,a}\\,r_{j,b}=0.$$\n   - For each coordinate index $a\\in\\{1,\\dots,d\\}$: $$\\sum_{j=1}^n \\omega_{ij}\\,r_{j,a}^2=C.$$\n3. Compute a weight vector $\\boldsymbol{\\omega}_i$ that exactly satisfies all constraints when the system is consistent and overdetermined in a way that admits a solution with minimal Euclidean norm among all such solutions, and otherwise produces the least-squares best approximation to the constraints.\n4. Return the maximum absolute residual across all constraints, defined as $$\\max\\Big(\\big\\|\\sum_{j=1}^n \\omega_{ij}\\,\\mathbf{r}_j\\big\\|_\\infty,\\ \\max_{1\\le ab\\le d}\\big|\\sum_{j=1}^n \\omega_{ij}\\,r_{j,a}\\,r_{j,b}\\big|,\\ \\max_{1\\le a\\le d}\\big|\\sum_{j=1}^n \\omega_{ij}\\,r_{j,a}^2-C\\big|\\Big),$$ where $\\|\\cdot\\|_\\infty$ denotes the infinity norm of a vector.\n\nTest Suite:\nUse the following four test cases to validate your implementation. In all cases, assume the base particle is located at the origin so that $\\mathbf{r}_j=\\mathbf{x}_j$.\n\n- Case $1$ (one-dimensional, minimal symmetric neighbors, happy path): $d=1$, $h=0.25$, neighbors $\\mathbf{r}_j\\in\\{-h,+h\\}$, $C=1.0$.\n- Case $2$ (two-dimensional, exactly determined system, happy path): $d=2$, $h=0.3$, neighbors $\\mathbf{r}_j\\in\\{(h,0),(-h,0),(0,h),(0,-h),(h,h)\\}$, $C=1.0$.\n- Case $3$ (three-dimensional, overdetermined but consistent system, happy path): $d=3$, $h=0.2$, neighbors $\\mathbf{r}_j\\in\\{(\\pm h,0,0),(0,\\pm h,0),(0,0,\\pm h),(h,h,0),(h,0,h),(0,h,h)\\}$, that is $9$ distinct offsets: $(h,0,0)$, $(-h,0,0)$, $(0,h,0)$, $(0,-h,0)$, $(0,0,h)$, $(0,0,-h)$, $(h,h,0)$, $(h,0,h)$, $(0,h,h)$, with $C=1.0$.\n- Case $4$ (two-dimensional, degenerate geometry, edge case): $d=2$, $h=0.4$, neighbors $\\mathbf{r}_j\\in\\{(h,0),(2h,0),(-h,0),(-2h,0)\\}$, $C=1.0$.\n\nRequired final output format:\nYour program should produce a single line of output containing the maximum absolute residuals for the four test cases as a comma-separated list enclosed in square brackets, for example, $$[r_1,r_2,r_3,r_4],$$ where each $r_k$ is a floating-point number. No other text should be printed. Angles are not involved, and no physical units are required; all quantities are dimensionless real numbers. The results must be computed using double-precision arithmetic.",
            "solution": "The problem at hand requires the computation of quadrature weights for a meshfree particle approximation of a nonlocal diffusion operator, as encountered in peridynamics. The fundamental goal is to ensure that the discrete operator satisfies numerical consistency conditions, specifically, the exact reproduction of linear fields (a first-order patch test) and an isotropic response. These conditions translate into a set of linear algebraic constraints on the weights. My task is to formulate these constraints into a linear system and solve for the weights, accommodating various geometric configurations of neighboring particles.\n\nThe continuous nonlocal operator is given by\n$$\n\\mathcal{L}u(\\mathbf{x})=\\int_{B_\\delta(\\mathbf{x})}\\gamma(\\|\\mathbf{y}-\\mathbf{x}\\|)\\,\\big(u(\\mathbf{y})-u(\\mathbf{x})\\big)\\,\\mathrm{d}\\mathbf{y}\n$$\nand its discrete approximation at a particle $\\mathbf{x}_i$ is\n$$\n\\mathcal{L}u(\\mathbf{x}_i)\\approx\\sum_{j\\in\\mathcal{N}(i)}\\omega_{ij}\\,\\big(u(\\mathbf{x}_j)-u(\\mathbf{x}_i)\\big)\n$$\nwhere $\\boldsymbol{\\omega}_i = \\{\\omega_{ij}\\}$ is the set of weights to be determined for the neighbors $j \\in \\mathcal{N}(i)$ of particle $i$. Let $\\mathbf{r}_j = \\mathbf{x}_j - \\mathbf{x}_i$ denote the neighbor offset vectors.\n\nThe first principle is consistency with linear fields. A linear field is of the form $u(\\mathbf{x}) = a + \\mathbf{b} \\cdot \\mathbf{x}$ for a scalar $a$ and a vector $\\mathbf{b}$. For such a field, the term in the integral becomes $u(\\mathbf{y}) - u(\\mathbf{x}) = (a + \\mathbf{b} \\cdot \\mathbf{y}) - (a + \\mathbf{b} \\cdot \\mathbf{x}) = \\mathbf{b} \\cdot (\\mathbf{y} - \\mathbf{x})$. Due to the radial symmetry of the influence function $\\gamma$ and the integration domain $B_\\delta(\\mathbf{x})$, the continuous operator vanishes: $\\mathcal{L}u(\\mathbf{x}) = \\int_{B_\\delta(\\mathbf{0})} \\gamma(\\|\\mathbf{s}\\|) (\\mathbf{b} \\cdot \\mathbf{s}) \\,\\mathrm{d}\\mathbf{s} = 0$, as the integrand is an odd function over a symmetric domain.\nThe discrete operator must reproduce this behavior:\n$$\n\\sum_{j\\in\\mathcal{N}(i)}\\omega_{ij} \\left( u(\\mathbf{x}_j) - u(\\mathbf{x}_i) \\right) = \\sum_{j\\in\\mathcal{N}(i)}\\omega_{ij} \\left( \\mathbf{b} \\cdot (\\mathbf{x}_j - \\mathbf{x}_i) \\right) = \\mathbf{b} \\cdot \\left( \\sum_{j\\in\\mathcal{N}(i)}\\omega_{ij} \\mathbf{r}_j \\right) = 0.\n$$\nSince this must hold for any arbitrary vector $\\mathbf{b}$, we obtain the first moment cancellation constraint:\n$$\n\\sum_{j\\in\\mathcal{N}(i)}\\omega_{ij}\\,\\mathbf{r}_j = \\mathbf{0}.\n$$\n\nThe second-moment condition ensures that the discrete operator correctly approximates a local diffusion operator (the Laplacian) in the limit of a vanishing non-local horizon. This is achieved by matching the second moments of the discrete kernel with those of the continuous one. This leads to the condition that the discrete second moment tensor must be isotropic, i.e., a scalar multiple of the identity matrix $I_d$:\n$$\n\\sum_{j\\in\\mathcal{N}(i)}\\omega_{ij}\\,\\mathbf{r}_j \\otimes \\mathbf{r}_j = C\\,I_d,\n$$\nfor some prescribed constant $C  0$ which relates to the material's diffusivity.\n\nThese two tensor equations can be broken down into a set of scalar linear equations for the weights $\\omega_{ij}$. For simplicity, let us denote the unknown weights as a vector $\\boldsymbol{\\omega}$ of size $n$, where $n$ is the number of neighbors. The constraints are:\n1.  First-moment cancellation (vector equation, $d$ scalar equations):\n    $$ \\sum_{j=1}^n \\omega_j\\,r_{j,a} = 0 \\quad \\text{for each coordinate } a \\in \\{1, \\dots, d\\}. $$\n2.  Isotropic second-moment matching (matrix equation, $d(d+1)/2$ scalar equations):\n    $$ \\sum_{j=1}^n \\omega_j\\,r_{j,a}\\,r_{j,b} = 0 \\quad \\text{for each pair } a, b \\text{ with } 1 \\le a  b \\le d. $$\n    $$ \\sum_{j=1}^n \\omega_j\\,r_{j,a}^2 = C \\quad \\text{for each coordinate } a \\in \\{1, \\dots, d\\}. $$\n\nThis constitutes a system of $m = d + \\frac{d(d-1)}{2} + d = \\frac{d(d+3)}{2}$ linear equations in $n$ unknowns ($\\omega_1, \\dots, \\omega_n$). We can write this system in the standard matrix form $A\\boldsymbol{\\omega} = \\mathbf{b}$, where $A$ is an $m \\times n$ matrix and $\\mathbf{b}$ is an $m$-dimensional vector.\nThe rows of matrix $A$ are constructed from the coefficients of $\\omega_j$ in the constraint equations. For a given neighbor geometry $\\{\\mathbf{r}_j\\}_{j=1}^n$:\n- The first $d$ rows of $A$ consist of the components of the neighbor vectors: $A_{a,j} = r_{j,a}$. The corresponding entries in $\\mathbf{b}$ are $0$.\n- The next $\\binom{d}{2}$ rows correspond to the off-diagonal second moments: $A_{k,j} = r_{j,a}r_{j,b}$ for pairs $(a,b)$ with $ab$. The corresponding entries in $\\mathbf{b}$ are $0$.\n- The final $d$ rows correspond to the diagonal second moments: $A_{l,j} = r_{j,a}^2$. The corresponding entries in $\\mathbf{b}$ are $C$.\n\nThe problem of finding the weights $\\boldsymbol{\\omega}$ is thus reduced to solving this linear system. Depending on the dimension $d$ and the number and geometric arrangement of the neighbors $n$, this system can be determined ($m=n$), overdetermined ($mn$), or underdetermined ($mn$). Furthermore, the system can be consistent (admitting an exact solution) or inconsistent (admitting no exact solution, as in degenerate geometries).\nTo handle all these cases robustly, we seek a solution in the least-squares sense. We aim to find $\\boldsymbol{\\omega}$ that minimizes the Euclidean norm of the residual, $\\|A\\boldsymbol{\\omega} - \\mathbf{b}\\|_2$. This approach yields:\n- An exact solution if the system is consistent.\n- The best approximation (in the $L_2$ sense) if the system is inconsistent.\n- Among all possible exact solutions for a consistent but underdetermined system, it provides the unique solution with the minimum Euclidean norm $\\|\\boldsymbol{\\omega}\\|_2$.\n\nThis is precisely the problem solved by standard numerical linear algebra routines, such as `numpy.linalg.lstsq` in Python.\n\nThe final step is to calculate the maximum absolute residual across all constraints, grouped as specified in the problem statement. For a computed weight vector $\\boldsymbol{\\omega}$:\n1.  The first-moment residual is $R_1 = \\|\\sum_{j=1}^n \\omega_j \\mathbf{r}_j\\|_\\infty$.\n2.  The off-diagonal second-moment residual is $R_2 = \\max_{1\\le ab\\le d} |\\sum_{j=1}^n \\omega_j r_{j,a} r_{j,b}|$. This is taken as $0$ if $d=1$.\n3.  The diagonal second-moment residual is $R_3 = \\max_{1\\le a\\le d} |\\sum_{j=1}^n \\omega_j r_{j,a}^2 - C|$.\n\nThe final reported value is $\\max(R_1, R_2, R_3)$. This procedure provides a comprehensive method for designing and validating particle quadrature rules for nonlocal operators.",
            "answer": "```python\nimport numpy as np\n\ndef compute_max_residual(d, neighbors_list, C):\n    \"\"\"\n    Computes quadrature weights and the maximum residual for a given particle neighborhood.\n\n    Args:\n        d (int): The spatial dimension.\n        neighbors_list (list): A list of neighbor offset vectors.\n        C (float): The target constant for the diagonal second moments.\n\n    Returns:\n        float: The maximum absolute residual across all constraints.\n    \"\"\"\n    neighbors = np.array(neighbors_list, dtype=np.float64)\n    n = neighbors.shape[0]\n\n    # Total number of constraints\n    num_constraints = d + d * (d - 1) // 2 + d\n    \n    A = np.zeros((num_constraints, n), dtype=np.float64)\n    b = np.zeros(num_constraints, dtype=np.float64)\n\n    row_idx = 0\n\n    # 1. First-moment constraints (d equations)\n    # Sum_j omega_j * r_{j,a} = 0 for a in 0..d-1\n    for a in range(d):\n        A[row_idx, :] = neighbors[:, a]\n        b[row_idx] = 0.0\n        row_idx += 1\n\n    # 2. Second-moment off-diagonal constraints (d*(d-1)/2 equations)\n    # Sum_j omega_j * r_{j,a} * r_{j,b} = 0 for 0 = a  b  d\n    if d  1:\n        for a in range(d):\n            for b_ in range(a + 1, d):\n                A[row_idx, :] = neighbors[:, a] * neighbors[:, b_]\n                b[row_idx] = 0.0\n                row_idx += 1\n\n    # 3. Second-moment diagonal constraints (d equations)\n    # Sum_j omega_j * r_{j,a}^2 = C for a in 0..d-1\n    for a in range(d):\n        A[row_idx, :] = neighbors[:, a] ** 2\n        b[row_idx] = C\n        row_idx += 1\n    \n    # Solve the linear system A*omega = b for the weights omega using least squares.\n    # This handles determined, over-determined, and under-determined systems correctly.\n    omega, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n\n    # --- Calculate residuals based on the problem's specific definition ---\n    \n    # Term 1: Infinity norm of the first-moment vector\n    first_moment_vec = omega @ neighbors\n    res1 = np.max(np.abs(first_moment_vec))\n\n    # Term 2: Maximum absolute value of off-diagonal second moments\n    res2 = 0.0\n    if d  1:\n        off_diag_moments = []\n        for a in range(d):\n            for b_ in range(a + 1, d):\n                moment = np.dot(omega, neighbors[:, a] * neighbors[:, b_])\n                off_diag_moments.append(np.abs(moment))\n        if off_diag_moments:\n            res2 = np.max(off_diag_moments)\n\n    # Term 3: Maximum absolute residual of diagonal second moments\n    diag_moments_res = []\n    for a in range(d):\n        moment = np.dot(omega, neighbors[:, a]**2)\n        diag_moments_res.append(np.abs(moment - C))\n    res3 = np.max(diag_moments_res)\n\n    return np.max([res1, res2, res3])\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    h1 = 0.25\n    case1 = {\n        \"d\": 1,\n        \"neighbors\": [[-h1], [h1]],\n        \"C\": 1.0,\n    }\n\n    h2 = 0.3\n    case2 = {\n        \"d\": 2,\n        \"neighbors\": [\n            [h2, 0.0], [-h2, 0.0],\n            [0.0, h2], [0.0, -h2],\n            [h2, h2]\n        ],\n        \"C\": 1.0,\n    }\n\n    h3 = 0.2\n    case3 = {\n        \"d\": 3,\n        \"neighbors\": [\n             [h3, 0.0, 0.0], [-h3, 0.0, 0.0],\n             [0.0, h3, 0.0], [0.0, -h3, 0.0],\n             [0.0, 0.0, h3], [0.0, 0.0, -h3],\n             [h3, h3, 0.0], [h3, 0.0, h3], [0.0, h3, h3]\n        ],\n        \"C\": 1.0,\n    }\n\n    h4 = 0.4\n    case4 = {\n        \"d\": 2,\n        \"neighbors\": [\n            [h4, 0.0], [2*h4, 0.0], [-h4, 0.0], [-2*h4, 0.0]\n        ],\n        \"C\": 1.0,\n    }\n\n    test_cases = [case1, case2, case3, case4]\n    \n    results = []\n    for case in test_cases:\n        res = compute_max_residual(case[\"d\"], case[\"neighbors\"], case[\"C\"])\n        results.append(res)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After discretizing a nonlocal operator, it is essential to understand its properties and how they relate to the continuum theory, often involving the fractional Laplacian $(-\\Delta)^s$. This practice connects the discrete and continuous worlds by having you compute the eigenvalues of a discretized nonlocal operator on a periodic grid. You will analyze how this discrete spectrum approximates the continuum spectrum, gaining insight into how discretization parameters introduce errors like aliasing and windowing effects .",
            "id": "3425219",
            "problem": "Consider a one-dimensional periodic lattice of length $L$ discretized into $N$ uniformly spaced points with grid spacing $h=L/N$. Define the nonlocal diffusion operator (common in peridynamics) with horizon $\\delta$ acting on a function $u$ as\n$$\n\\mathcal{L}_\\delta u(x) = \\int_{|y|\\delta} \\left(u(x) - u(x+y)\\right)\\,\\gamma_\\delta(|y|)\\,dy,\n$$\nwhere the kernel tail satisfies $\\gamma_\\delta(r) \\sim r^{-d-2s}$ with spatial dimension $d$ and fractional order $s\\in(0,1)$. In this task, restrict to the case $d=1$ and use the discrete periodic lattice to approximate $\\mathcal{L}_\\delta$ by\n$$\n\\left(\\mathcal{L}_\\delta^{h} u\\right)(x_j) = \\sum_{m=1}^{N-1} \\left(u(x_j) - u(x_{j+m})\\right)\\,w_m,\n$$\nwhere $x_j$ denotes the grid point at index $j$, $x_{j+m}$ is understood modulo $N$, and the weights $w_m$ approximate the integral quadrature with\n$$\nw_m = h \\,\\gamma_\\delta(r_m),\n$$\nand $r_m$ is the minimal periodic distance between $x_j$ and $x_{j+m}$ defined by $r_m = h \\,\\min(m, N-m)$. Impose a horizon window by setting $\\gamma_\\delta(r_m)=0$ when $r_m\\delta$ and otherwise $\\gamma_\\delta(r_m)=r_m^{-1-2s}$.\n\nFundamental base for the derivation and algorithm:\n- Translation invariance on a periodic lattice implies that discrete complex Fourier modes are eigenfunctions of convolution-type operators.\n- The discrete spectrum (eigenvalues) of a translation-invariant operator equals the discrete Fourier transform of its stencil or weights.\n- For the fractional Laplacian $(-\\Delta)^s$ on a periodic domain, the Fourier symbol is $|\\xi|^{2s}$, meaning the Fourier mode with frequency $\\xi$ is an eigenfunction with eigenvalue $|\\xi|^{2s}$.\n\nYour tasks:\n- Derive from these fundamental facts the explicit discrete eigenvalue formula for $\\mathcal{L}_\\delta^{h}$ on the periodic lattice. Do not assume any intermediate shortcuts beyond the principles stated above. Carefully handle the singular behavior near $r=0$ through the lattice difference structure and symmetry.\n- Implement a program that constructs the discrete weights $w_m$ for the one-dimensional periodic lattice, computes the discrete eigenvalues $\\lambda_n$ for all discrete lattice frequencies $\\xi_n = 2\\pi n/L$ with $n \\in \\{0,1,\\dots,N-1\\}$, and compares them to the fractional Laplacian eigenvalues $|\\xi_n|^{2s}$.\n- Because the amplitude of $\\lambda_n$ depends on the choice of kernel normalization, fit a single scaling factor $\\alpha0$ by least squares over a small set of low-frequency modes so that $\\lambda_n \\approx \\alpha\\,|\\xi_n|^{2s}$, then report errors for various modes using the calibrated comparison.\n\nDiagnose aliasing and windowing errors:\n- Aliasing arises from discretization and periodic wrapping of the long-range kernel tail, typically impacting high-frequency eigenvalues near the Nyquist frequency. Quantify it by reporting the relative error at the Nyquist mode.\n- Windowing error arises from truncation by $\\delta$ and affects low-frequency behavior. Quantify it by reporting the mean relative error over a set of low-frequency modes for different $\\delta$ and $N$.\n\nTest suite and parameters:\n- Let the domain length be $L=1$. Let the fractional order be $s=0.75$.\n- Use the following four test cases, each returning a single float:\n  1. Happy path resolution: $N=256$, $\\delta=0.25$. Compute the mean relative error over the low-frequency modes $n\\in\\{1,2,3,4,5,6,7,8\\}$ after calibrating $\\alpha$ on the same low modes.\n  2. Coarser grid (aliasing and discretization effect): $N=64$, $\\delta=0.25$. Compute the mean relative error over the low-frequency modes $n\\in\\{1,2,3,4,5,6,7,8\\}$ after calibrating $\\alpha$ on the same low modes.\n  3. Small horizon (windowing error): $N=256$, $\\delta=0.05$. Compute the mean relative error over the low-frequency modes $n\\in\\{1,2,3,4,5,6,7,8\\}$ after calibrating $\\alpha$ on the same low modes.\n  4. Aliasing diagnostic: $N=256$, $\\delta=0.25$. Compute the relative error at the Nyquist mode $n=N/2$ using the $\\alpha$ calibrated on low modes $n\\in\\{1,2,3,4,5,6,7,8\\}$.\n\nFor each test case, the relative error for a mode $n$ is defined as\n$$\n\\mathrm{err}_n = \\frac{\\left|\\lambda_n/\\alpha - |\\xi_n|^{2s}\\right|}{|\\xi_n|^{2s}},\n$$\nand the mean relative error is the arithmetic mean of $\\mathrm{err}_n$ over the specified set of modes.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the four test cases described above (for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$).\n- All outputs must be floats expressed as decimals (no percentage signs).",
            "solution": "The problem is well-posed and scientifically sound, representing a standard task in the numerical analysis of nonlocal operators. It will be solved by first deriving the eigenvalues of the discrete operator and then implementing a numerical procedure to compute these eigenvalues and compare them against the theoretical continuum counterpart.\n\n### Part 1: Derivation of the Discrete Eigenvalues\n\nThe discrete nonlocal operator $\\mathcal{L}_\\delta^h$ acts on a grid function $u = (u_0, u_1, \\dots, u_{N-1})$ defined on $N$ points $x_j=jh$ for $j=0, \\dots, N-1$ with grid spacing $h=L/N$. The operator is defined as:\n$$\n\\left(\\mathcal{L}_\\delta^{h} u\\right)(x_j) = \\sum_{m=1}^{N-1} \\left(u(x_j) - u(x_{j+m})\\right)\\,w_m\n$$\nwhere indices are understood modulo $N$, i.e., $u_{j+m} = u_{(j+m) \\pmod N}$. This operator is translation-invariant on the periodic lattice because the weights $w_m$ do not depend on the position $x_j$. Such an operator can be expressed as a discrete circular convolution.\n\nAs stated in the problem's fundamental principles, the discrete complex Fourier modes are eigenfunctions of any linear translation-invariant operator on a periodic lattice. These modes are given by the vectors $v^{(n)}$ with components $v_j^{(n)} = e^{i \\xi_n x_j} = e^{i (2\\pi n/L)(jh)} = e^{i (2\\pi n/(Nh))(jh)} = e^{i 2\\pi nj/N}$ for each discrete frequency index $n \\in \\{0, 1, \\dots, N-1\\}$.\n\nLet's apply the operator $\\mathcal{L}_\\delta^h$ to one such Fourier mode $v^{(n)}$ to find its corresponding eigenvalue $\\lambda_n$.\n$$\n\\left(\\mathcal{L}_\\delta^{h} v^{(n)}\\right)_j = \\sum_{m=1}^{N-1} \\left(v_j^{(n)} - v_{j+m}^{(n)}\\right) w_m\n$$\nSubstituting the expression for $v_j^{(n)}$:\n$$\n\\left(\\mathcal{L}_\\delta^{h} v^{(n)}\\right)_j = \\sum_{m=1}^{N-1} \\left(e^{i 2\\pi nj/N} - e^{i 2\\pi n(j+m)/N}\\right) w_m\n$$\nWe can factor out the term $e^{i 2\\pi nj/N}$ which is equal to $v_j^{(n)}$:\n$$\n\\left(\\mathcal{L}_\\delta^{h} v^{(n)}\\right)_j = e^{i 2\\pi nj/N} \\sum_{m=1}^{N-1} \\left(1 - e^{i 2\\pi nm/N}\\right) w_m = v_j^{(n)} \\left( \\sum_{m=1}^{N-1} w_m \\left(1 - e^{i 2\\pi nm/N}\\right) \\right)\n$$\nThis is an eigenvalue equation of the form $\\left(\\mathcal{L}_\\delta^{h} v^{(n)}\\right)_j = \\lambda_n v_j^{(n)}$, where the eigenvalue $\\lambda_n$ is identified as:\n$$\n\\lambda_n = \\sum_{m=1}^{N-1} w_m \\left(1 - e^{i 2\\pi nm/N}\\right)\n$$\nThe weights $w_m$ are defined as $w_m = h\\,\\gamma_\\delta(r_m)$ with $r_m = h \\min(m, N-m)$. This definition implies that the weights are symmetric, i.e., $w_m = w_{N-m}$ for $m \\in \\{1, \\dots, N-1\\}$. We can use this symmetry to show that the eigenvalues $\\lambda_n$ are real.\n$$\n\\lambda_n = \\sum_{m=1}^{N-1} w_m \\left(1 - \\cos\\left(\\frac{2\\pi nm}{N}\\right) - i \\sin\\left(\\frac{2\\pi nm}{N}\\right)\\right)\n$$\nThe imaginary part of $\\lambda_n$ is $-\\sum_{m=1}^{N-1} w_m \\sin\\left(\\frac{2\\pi nm}{N}\\right)$. Let's analyze this sum.\n$$\n\\sum_{m=1}^{N-1} w_m \\sin\\left(\\frac{2\\pi nm}{N}\\right) = \\sum_{m=1}^{N-1} w_{N-m} \\sin\\left(\\frac{2\\pi nm}{N}\\right)\n$$\nLet $k=N-m$. As $m$ goes from $1$ to $N-1$, $k$ also goes from $N-1$ to $1$.\n$$\n= \\sum_{k=1}^{N-1} w_k \\sin\\left(\\frac{2\\pi n(N-k)}{N}\\right) = \\sum_{k=1}^{N-1} w_k \\sin\\left(2\\pi n - \\frac{2\\pi nk}{N}\\right) = \\sum_{k=1}^{N-1} w_k \\left(-\\sin\\left(\\frac{2\\pi nk}{N}\\right)\\right) = -\\sum_{k=1}^{N-1} w_k \\sin\\left(\\frac{2\\pi nk}{N}\\right)\n$$\nA sum that is equal to its own negative must be zero. Therefore, the imaginary part of $\\lambda_n$ is zero, and the eigenvalues are real.\nThe expression for the eigenvalues simplifies to:\n$$\n\\lambda_n = \\sum_{m=1}^{N-1} w_m \\left(1 - \\cos\\left(\\frac{2\\pi nm}{N}\\right)\\right)\n$$\nUsing the half-angle identity $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$, we obtain the final explicit formula for the discrete eigenvalues:\n$$\n\\lambda_n = 2 \\sum_{m=1}^{N-1} w_m \\sin^2\\left(\\frac{\\pi nm}{N}\\right)\n$$\nThis formula shows that $\\lambda_0 = 0$ (as $\\sin(0)=0$), which is expected because the operator annihilates constant functions. It also shows the symmetry $\\lambda_n = \\lambda_{N-n}$, since $\\sin^2(\\pi(N-n)m/N) = \\sin^2(\\pi m - \\pi nm/N) = \\sin^2(-\\pi nm/N) = \\sin^2(\\pi nm/N)$.\n\n### Part 2: Algorithmic Implementation\n\nThe program will execute the following steps for each test case $(N, \\delta)$:\n\n1.  **Define Constants and Grid**: Set $L=1$, $s=0.75$, and compute the grid spacing $h=L/N$.\n\n2.  **Construct Discrete Weights $w_m$**: Create an array for the weights $w_m$ for $m \\in \\{1, \\dots, N-1\\}$. For each $m$, calculate the periodic distance $r_m = h \\min(m, N-m)$. If $r_m  \\delta$, set $w_m=0$. Otherwise, compute $w_m = h \\cdot r_m^{-1-2s}$.\n\n3.  **Compute Discrete Eigenvalues $\\lambda_n$**: Using the derived formula $\\lambda_n = 2 \\sum_{m=1}^{N-1} w_m \\sin^2\\left(\\frac{\\pi nm}{N}\\right)$, compute the eigenvalues for all frequency indices $n \\in \\{0, \\dots, N-1\\}$.\n\n4.  **Compute Ideal Continuum Eigenvalues $|\\xi_n^{eff}|^{2s}$**: The ideal eigenvalues for the continuum fractional Laplacian $(-\\Delta)^s$ are $|\\xi|^{2s}$. On a discrete grid, high frequencies are aliased. The effective (unaliased) wavenumber for a mode $n$ is $\\xi_n^{eff} = \\frac{2\\pi}{L} \\min(n, N-n)$ for $n \\in \\{1, \\dots, N-1\\}$ and $\\xi_0^{eff}=0$. We compute the target ideal eigenvalues as $(|\\xi_n^{eff}|)^{2s}$.\n\n5.  **Calibrate Scaling Factor $\\alpha$**: The problem requires fitting a scaling factor $\\alpha$ to relate the discrete and continuum eigenvalues, $\\lambda_n \\approx \\alpha (|\\xi_n^{eff}|)^{2s}$. This is done via a least-squares fit over the low-frequency modes $n_{\\text{calib}} = \\{1, 2, \\dots, 8\\}$. The optimal $\\alpha$ that minimizes $\\sum_n (\\lambda_n - \\alpha |\\xi_n^{eff}|^{2s})^2$ is given by:\n    $$\n    \\alpha = \\frac{\\sum_{n \\in n_{\\text{calib}}} \\lambda_n |\\xi_n^{eff}|^{2s}}{\\sum_{n \\in n_{\\text{calib}}} (|\\xi_n^{eff}|^{2s})^2}\n    $$\n\n6.  **Calculate Errors**:\n    - For test cases 1, 2, and 3, compute the mean relative error over the low-frequency modes $n_{\\text{eval}} = \\{1, 2, \\dots, 8\\}$. The relative error for a single mode $n$ is $\\mathrm{err}_n = |\\lambda_n/\\alpha - |\\xi_n^{eff}|^{2s}| / |\\xi_n^{eff}|^{2s}|$. The mean relative error is the arithmetic average of $\\mathrm{err}_n$ over $n \\in n_{\\text{eval}}$.\n    - For test case 4, compute the relative error $\\mathrm{err}_{N/2}$ at the Nyquist frequency $n=N/2$ using the $\\alpha$ calibrated on the low-frequency modes. This error is a diagnostic for aliasing effects.\n\nThe implementation will consist of a primary function to perform these calculations for a given set of parameters, which is then called for each of the four specified test cases. The results are collected and printed in the required format.",
            "answer": "```python\nimport numpy as np\n\ndef compute_errors(N, delta, L, s, n_calib_indices, eval_config):\n    \"\"\"\n    Computes errors for a given set of parameters for the nonlocal diffusion problem.\n\n    Args:\n        N (int): Number of grid points.\n        delta (float): Horizon for the nonlocal operator.\n        L (float): Length of the periodic domain.\n        s (float): Fractional order of the operator.\n        n_calib_indices (np.ndarray): Array of mode indices for calibration.\n        eval_config (tuple): Configuration for evaluation, either ('mean', indices) or ('single', index).\n\n    Returns:\n        float: The computed error.\n    \"\"\"\n    h = L / N\n    \n    # --- 1. Construct discrete weights w_m ---\n    w = np.zeros(N)\n    m_vals = np.arange(1, N)\n    r_m = h * np.minimum(m_vals, N - m_vals)\n    \n    # Apply horizon condition\n    horizon_mask = r_m = delta\n    \n    # Calculate weights where r_m is within horizon and non-zero\n    r_m_in_horizon = r_m[horizon_mask]\n    \n    # To avoid division by zero if r_m can be zero (which it can't for m=1)\n    non_zero_r = r_m_in_horizon  0\n    indices_in_horizon = m_vals[horizon_mask]\n    \n    if np.any(non_zero_r):\n        w[indices_in_horizon[non_zero_r]] = h * r_m_in_horizon[non_zero_r]**(-1.0 - 2.0 * s)\n\n    # --- 2. Compute discrete eigenvalues lambda_n ---\n    lambda_vals = np.zeros(N)\n    n_vals_all = np.arange(N)\n    m_vals_all = np.arange(1, N)\n    \n    for n in n_vals_all:\n        # Using lambda_n = sum_{m=1}^{N-1} 2 * w_m * sin^2(pi*n*m/N)\n        sin_sq_terms = np.sin(np.pi * n * m_vals_all / N)**2\n        lambda_vals[n] = 2 * np.sum(w[1:] * sin_sq_terms)\n\n    # --- 3. Compute ideal continuum eigenvalues ---\n    # Effective wavenumbers to account for aliasing\n    n_eff_vals = np.minimum(n_vals_all, N - n_vals_all)\n    xi_eff_vals = (2 * np.pi / L) * n_eff_vals\n    ideal_eigs = xi_eff_vals**(2 * s)\n    # Handle the n=0 case to avoid 0**negative power if s0 (not the case here)\n    if s  0:\n        ideal_eigs[0] = 0.0\n\n    # --- 4. Calibrate scaling factor alpha ---\n    lambda_calib = lambda_vals[n_calib_indices]\n    ideal_calib = ideal_eigs[n_calib_indices]\n    alpha = np.dot(lambda_calib, ideal_calib) / np.dot(ideal_calib, ideal_calib)\n\n    # --- 5. Calculate and return error ---\n    eval_mode, eval_indices = eval_config\n    \n    if eval_mode == 'mean_relative':\n        # Avoid division by zero for ideal_eigs[0] if present\n        if np.any(ideal_eigs[eval_indices] == 0):\n            raise ValueError(\"Evaluation indices include n=0, where relative error is undefined.\")\n        \n        errors = np.abs(lambda_vals[eval_indices] / alpha - ideal_eigs[eval_indices]) / ideal_eigs[eval_indices]\n        return np.mean(errors)\n    \n    elif eval_mode == 'single_relative':\n        n_eval = eval_indices\n        if ideal_eigs[n_eval] == 0:\n            raise ValueError(\"Evaluation index is n=0, where relative error is undefined.\")\n        \n        error = np.abs(lambda_vals[n_eval] / alpha - ideal_eigs[n_eval]) / ideal_eigs[n_eval]\n        return error\n    else:\n        raise ValueError(\"Invalid evaluation mode specified.\")\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite and prints the results.\n    \"\"\"\n    L = 1.0\n    s = 0.75\n    \n    # Indices for calibration and low-frequency error evaluation\n    n_calib_indices = np.arange(1, 9)\n    n_eval_indices_low = np.arange(1, 9)\n\n    test_cases = [\n        # (N, delta, eval_config)\n        (256, 0.25, ('mean_relative', n_eval_indices_low)), # Case 1: Happy path\n        (64, 0.25, ('mean_relative', n_eval_indices_low)),  # Case 2: Coarser grid\n        (256, 0.05, ('mean_relative', n_eval_indices_low)),  # Case 3: Small horizon\n        (256, 0.25, ('single_relative', 256 // 2)),       # Case 4: Aliasing diagnostic\n    ]\n\n    results = []\n    for N, delta, eval_config in test_cases:\n        result = compute_errors(N, delta, L, s, n_calib_indices, eval_config)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Unlike local partial differential equations, nonlocal models require boundary conditions to be prescribed on an exterior \"collar\" or interaction domain, which presents unique numerical challenges. This hands-on problem tackles the implementation of nonlocal Dirichlet boundary conditions for a bounded domain, a common scenario in practical applications. You will code and compare two standard techniques—a direct volume constraint and an approximate penalty method—to understand their trade-offs and quantify their impact on the solution accuracy within the boundary layer .",
            "id": "3425272",
            "problem": "Consider the one-dimensional nonlocal diffusion problem on the open interval $\\Omega = (0,1)$ with horizon (interaction radius) $\\delta \\in (0,1)$ and a compactly supported, radial kernel $\\gamma_{\\delta}$. The nonlocal diffusion operator acting on a sufficiently smooth scalar field $u$ is defined by the fundamental nonlocal model\n$$\n(\\mathcal{L}_{\\delta} u)(x) := \\int_{\\mathbb{R}} \\big(u(x) - u(y)\\big)\\,\\gamma_{\\delta}\\big(|x - y|\\big)\\,dy,\\quad x\\in \\Omega,\n$$\nwhere the kernel satisfies $\\gamma_{\\delta}(r) \\ge 0$, $\\gamma_{\\delta}(r)=0$ for $r  \\delta$, and $\\gamma_{\\delta}(r)$ is symmetric. For this problem, use the explicit kernel\n$$\n\\gamma_{\\delta}(r) = \\begin{cases}\n\\delta^{-3},  0 \\le r \\le \\delta,\\\\\n0,  r  \\delta.\n\\end{cases}\n$$\nThe nonlocal Dirichlet data is imposed in the interaction domain $\\Omega_I := \\{x \\in \\mathbb{R}\\setminus \\Omega : \\operatorname{dist}(x,\\Omega) \\le \\delta\\}$ by prescribing $u(x)=g(x)$ for $x \\in \\Omega_I$. The interior equation is\n$$\n(\\mathcal{L}_{\\delta} u)(x) = f(x),\\quad x\\in \\Omega, \\quad u(x)=g(x),\\ x\\in \\Omega_I,\n$$\nwith body force $f(x)$ and boundary data $g(x)$. In this problem, take $f(x) \\equiv 1$ for $x\\in \\Omega$, and $g(x)\\equiv 0$ on $\\Omega_I$.\n\nTwo numerical boundary treatments are to be compared:\n\n- Volume constraint (VC): enforce the nonlocal Dirichlet data in $\\Omega_I$ by including the exterior contributions with the prescribed value $g(x)$ in the quadrature of $(\\mathcal{L}_{\\delta} u)(x)$.\n\n- Soft penalty layer (PEN): restrict the nonlocal interactions to $\\Omega$ only, but add a reaction (penalty) on a boundary-adjacent layer of thickness $c\\,\\delta$ inside $\\Omega$ that drives $u$ toward $g$ within that layer. Here $c0$ is a given dimensionless thickness factor.\n\nDiscretization and numerical model construction must start from the above operator definition. Use a uniform grid with mesh size $h$ on $\\Omega$, with unknowns at the interior nodes $x_i = i h$ for $i \\in \\{1,2,\\dots,M-1\\}$ where $M = 1/h$ is an integer, and assume that $\\delta/h$ is an integer so that the number of grid neighbors within the horizon is integer-valued. Approximate the integral in $(\\mathcal{L}_\\delta u)(x_i)$ by a uniform composite quadrature (rectangle rule) of step size $h$ over the stencil $\\{y_j = j h: |y_j - x_i| \\le \\delta\\}$.\n\n- For VC, include all neighbors $y_j$ with $|y_j-x_i|\\le \\delta$ regardless of whether $y_j\\in\\Omega$ or $y_j\\in\\Omega_I$, and use $u(y_j)=g(y_j)$ for $y_j\\in\\Omega_I$.\n\n- For PEN, include only neighbors $y_j\\in\\Omega$ with $|y_j-x_i|\\le \\delta$, and add an extra penalty term on the left-hand side of the form $\\alpha\\,\\chi_{L_c}(x_i)\\,u(x_i)$ with $\\chi_{L_c}$ the characteristic function of the layer $L_c=\\{x\\in \\Omega:\\operatorname{dist}(x,\\partial\\Omega)\\le c\\,\\delta\\}$, and a coefficient $\\alpha$ that scales with the local interaction mass. Set $\\alpha$ equal to the discrete full interaction mass at $x_i$, i.e., the sum of all kernel quadrature weights that would have been present if the exterior were available, thereby yielding a dimensionally consistent soft reaction. Use $g(x)\\equiv 0$, so the penalty does not add a right-hand side source.\n\nDefine the boundary layer error for a numerical solution $u_h$ as the root-mean-square error relative to a reference VC solution $u_{\\text{ref}}$ computed on a significantly finer grid of mesh size $h_{\\text{ref}}$, restricted to the discrete boundary layer region of thickness $\\delta$ inside $\\Omega$:\n$$\n\\mathcal{E}_{\\text{BL}}(u_h;\\delta,h) := \\left(\\frac{1}{|\\mathcal{I}_{\\text{BL}}|}\\sum_{i\\in \\mathcal{I}_{\\text{BL}}}\\big(u_h(x_i)-u_{\\text{ref}}(x_i)\\big)^2\\right)^{1/2},\n$$\nwhere $\\mathcal{I}_{\\text{BL}} := \\{ i\\in\\{1,\\dots,M-1\\} : \\min(x_i,1-x_i) \\le \\delta\\}$ indexes the interior grid nodes within a distance $\\delta$ of the boundary, and $|\\mathcal{I}_{\\text{BL}}|$ denotes the number of such nodes. The reference solution $u_{\\text{ref}}$ must be computed using the VC formulation at horizon $\\delta$ and mesh size $h_{\\text{ref}}$ with $h_{\\text{ref}} \\ll h$ and $\\delta/h_{\\text{ref}}$ integer, and its values compared at the coarse-grid nodes $x_i$ via exact grid alignment (choose $h$ values that are integer multiples of $h_{\\text{ref}}$).\n\nImplement the two linear systems arising from VC and PEN, solve them for $u_h$, and report the boundary layer error for each method across the following test suite of parameter triples $(\\delta,h,c)$:\n\n- Test $1$: $(\\delta,h,c) = (0.1, 0.02, 1.0)$.\n- Test $2$: $(\\delta,h,c) = (0.1, 0.01, 1.0)$.\n- Test $3$: $(\\delta,h,c) = (0.05, 0.01, 1.0)$.\n- Test $4$: $(\\delta,h,c) = (0.1, 0.02, 0.5)$.\n- Test $5$: $(\\delta,h,c) = (0.1, 0.02, 2.0)$.\n\nUse $h_{\\text{ref}}=0.005$ for all reference solves. For each test, compute two floating-point values: the boundary layer error for VC and for PEN. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$$\n[\\mathcal{E}_{\\text{BL}}^{\\text{VC}}(\\text{Test }1),\\ \\mathcal{E}_{\\text{BL}}^{\\text{PEN}}(\\text{Test }1),\\ \\ldots,\\ \\mathcal{E}_{\\text{BL}}^{\\text{VC}}(\\text{Test }5),\\ \\mathcal{E}_{\\text{BL}}^{\\text{PEN}}(\\text{Test }5)].\n$$\nAll quantities are non-dimensional; no physical units are required. The angle unit is not applicable. The output numbers must be plain decimal floats. The code must be entirely self-contained, use only the specified numerical libraries, and require no user input or external files.",
            "solution": "The user wants to solve a one-dimensional nonlocal diffusion problem and compare two boundary condition treatments: Volume Constraint (VC) and a soft Penalty (PEN) method. First, the problem is validated.\n\n### Step 1: Extract Givens\n- **Domain**: $\\Omega = (0,1)$.\n- **Horizon**: $\\delta \\in (0,1)$.\n- **Nonlocal operator**: $(\\mathcal{L}_{\\delta} u)(x) := \\int_{\\mathbb{R}} \\big(u(x) - u(y)\\big)\\,\\gamma_{\\delta}\\big(|x - y|\\big)\\,dy$.\n- **Kernel**: $\\gamma_{\\delta}(r) = \\delta^{-3}$ for $0 \\le r \\le \\delta$, and $0$ for $r  \\delta$.\n- **Interaction domain (boundary region)**: $\\Omega_I := \\{x \\in \\mathbb{R}\\setminus \\Omega : \\operatorname{dist}(x,\\Omega) \\le \\delta\\}$.\n- **Interior equation**: $(\\mathcal{L}_{\\delta} u)(x) = f(x)$ for $x\\in \\Omega$.\n- **Boundary condition**: $u(x)=g(x)$ for $x\\in \\Omega_I$.\n- **Source term**: $f(x) \\equiv 1$ for $x\\in \\Omega$.\n- **Boundary data**: $g(x) \\equiv 0$ on $\\Omega_I$.\n- **Discretization**: Uniform grid with nodes $x_i=ih$ for $i \\in \\{1,\\dots,M-1\\}$ where $M=1/h$ is an integer. The ratio $k=\\delta/h$ is assumed to be an integer.\n- **Quadrature**: Rectangle rule with step size $h$ over the stencil $\\{y_j=jh : |y_j-x_i|\\le\\delta\\}$.\n- **Volume Constraint (VC) method**: Include all neighbors $y_j$ with $|y_j-x_i|\\le \\delta$. For $y_j \\in \\Omega_I$, use $u(y_j)=g(y_j)=0$.\n- **Penalty (PEN) method**: Restrict interactions to $\\Omega$. Add penalty term $\\alpha\\,\\chi_{L_c}(x_i)\\,u(x_i)$ to the left-hand side. The penalty layer is $L_c=\\{x\\in \\Omega:\\operatorname{dist}(x,\\partial\\Omega)\\le c\\,\\delta\\}$. The penalty coefficient $\\alpha$ is the discrete full interaction mass, $\\alpha = \\sum_{|y_j-x_i|\\le\\delta, j\\ne i} h \\gamma_\\delta(|x_i-y_j|)$.\n- **Error metric**: The boundary layer error is defined as $\\mathcal{E}_{\\text{BL}}(u_h;\\delta,h) := \\left(\\frac{1}{|\\mathcal{I}_{\\text{BL}}|}\\sum_{i\\in \\mathcal{I}_{\\text{BL}}}\\big(u_h(x_i)-u_{\\text{ref}}(x_i)\\big)^2\\right)^{1/2}$.\n- **Boundary layer nodes**: $\\mathcal{I}_{\\text{BL}} := \\{ i\\in\\{1,\\dots,M-1\\} : \\min(x_i,1-x_i) \\le \\delta\\}$.\n- **Reference solution**: $u_{\\text{ref}}$ is computed using the VC formulation with the same $\\delta$ but a finer mesh size $h_{\\text{ref}}=0.005$. `h` is an integer multiple of $h_{\\text{ref}}$.\n- **Test parameters**: Five triples of $(\\delta,h,c)$ are provided.\n- **Output format**: A single line of comma-separated floating-point values in a specific order: $[\\mathcal{E}_{\\text{BL}}^{\\text{VC}}(\\text{Test }1),\\ \\mathcal{E}_{\\text{BL}}^{\\text{PEN}}(\\text{Test }1),\\ \\ldots]$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem describes a nonlocal diffusion equation, a standard topic in the numerical solution of partial differential equations and peridynamics. The operator, kernel, and boundary treatments (VC and PEN) are well-established. This is scientifically sound.\n- **Well-Posed**: The discretization of the nonlocal operator leads to a linear system of equations $A\\mathbf{u}=\\mathbf{b}$. The resulting matrix $A$ is a structured matrix related to a discrete Laplacian, which is generally non-singular, ensuring a unique solution exists. The problem is well-defined and requests a specific, computable result.\n- **Objective**: The problem is stated in precise mathematical terms, free of ambiguity or subjectivity.\n- **Completeness and Consistency**: All required information is provided: the governing equation, kernel, domain, boundary data, discretization scheme, definitions of numerical methods, error metric, reference solution parameters, and test cases. The constraint that $\\delta/h$ and $h/h_{\\text{ref}}$ are integers ensures consistent grid alignment.\n- **Other criteria**: The problem does not violate any other validation criteria. It is a formalizable, non-trivial, and verifiable numerical task.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\n### Solution Derivation\n\nThe problem requires constructing and solving linear systems for two different numerical treatments of a nonlocal diffusion equation. The unknown solution is discretized on a uniform grid $x_i = ih$ for $i \\in \\{1, 2, \\dots, M-1\\}$, where $M=1/h$. Let $\\mathbf{u}$ be the vector of unknowns, with $u_i \\approx u(x_i)$. The system size is $N=M-1$. The kernel is constant over its support, $\\gamma_0 = \\delta^{-3}$. The interaction horizon spans $k = \\delta/h$ grid cells on each side. We are given that $k$ is an integer.\n\nThe discrete form of the operator $(\\mathcal{L}_\\delta u)(x_i)$ at a node $x_i$ using the rectangle rule is:\n$$ (\\mathcal{L}_\\delta u)(x_i) \\approx h \\sum_{j \\text{ s.t. } 0  |x_i-x_j| \\le \\delta} (u_i - u_j) \\gamma_{\\delta}(|x_i-x_j|) = h \\gamma_0 \\sum_{j=i-k, j \\ne i}^{i+k} (u_i - u_j) $$\n\n**1. Volume Constraint (VC) Method**\nIn the VC method, interactions with the exterior domain $\\Omega_I$ are included. The value of the solution in $\\Omega_I$ is prescribed as $u(x)=g(x)=0$. The equation at node $x_i$ is $(\\mathcal{L}_{\\delta} u)(x_i) = 1$.\n$$ h \\gamma_0 \\left( \\sum_{j=i-k, j \\ne i}^{i+k} u_i - \\sum_{j=i-k, j \\ne i}^{i+k} u_j \\right) = 1 $$\nThe first sum is over $2k$ identical terms, giving $2k u_i$. The second sum is split between interior nodes (unknowns) and exterior nodes (prescribed zero).\n$$ h \\gamma_0 \\left( 2k u_i - \\sum_{j \\in \\{1,\\dots,M-1\\}, 0  |i-j| \\le k} u_j - \\sum_{j \\notin \\{1,\\dots,M-1\\}, 0  |i-j| \\le k} u_j \\right) = 1 $$\nSince $u_j = g(x_j) = 0$ for $j \\notin \\{1,\\dots,M-1\\}$, the second sum vanishes. This simplifies to a linear system $A_{VC}\\mathbf{u} = \\mathbf{b}$, where $\\mathbf{b}$ is a vector of all ones. The $(M-1) \\times (M-1)$ matrix $A_{VC}$ has entries (using 1-based indexing for nodes $i,j \\in \\{1,\\dots,M-1\\}$):\n$$ (A_{VC})_{i,j} = \\begin{cases} 2k h \\gamma_0,  i = j \\\\ -h \\gamma_0,  i \\ne j \\text{ and } |i-j| \\le k \\\\ 0,  \\text{otherwise} \\end{cases} $$\nThis matrix is symmetric and banded with bandwidth $k$.\n\n**2. Penalty (PEN) Method**\nIn the PEN method, interactions are truncated at the boundary of $\\Omega$. Here, we interpret this as restricting interactions to the set of unknown nodes $\\{x_1, \\dots, x_{M-1}\\}$. Additionally, a penalty term is added for nodes in the boundary layer $L_c$. The equation for node $x_i$ is:\n$$ \\left( h \\gamma_0 \\sum_{j \\in \\{1,\\dots,M-1\\}, 0  |i-j| \\le k} (u_i - u_j) \\right) + \\alpha \\chi_{L_c}(x_i) u_i = 1 $$\nLet $N_i$ be the number of interior neighbors of node $x_i$, i.e., $N_i = |\\{j \\in \\{1,\\dots,M-1\\} : 0  |i-j| \\le k\\}|$. The equation becomes:\n$$ (h \\gamma_0 N_i + \\alpha \\chi_{L_c}(x_i)) u_i - h \\gamma_0 \\sum_{j \\in \\{1,\\dots,M-1\\}, 0  |i-j| \\le k} u_j = 1 $$\nThe penalty parameter $\\alpha$ is the discrete full interaction mass: $\\alpha = h\\gamma_0 \\sum_{0  |i-j| \\le k} 1 = 2k h \\gamma_0$. The penalty is applied if $x_i \\in L_c$, which means $ih \\le c\\delta$ or $1-ih \\le c\\delta$. This simplifies to $i \\le ck$ or $i \\ge M-ck$.\nThe linear system is $A_{PEN}\\mathbf{u} = \\mathbf{b}$, where $\\mathbf{b}$ is again a vector of all ones. The entries of $A_{PEN}$ are:\n$$ (A_{PEN})_{i,j} = \\begin{cases} N_i h \\gamma_0 + \\alpha \\cdot \\chi_{L_c}(x_i),  i=j \\\\ -h \\gamma_0,  i \\ne j \\text{ and } |i-j| \\le k \\text{ and } j \\in \\{1,\\dots,M-1\\} \\\\ 0,  \\text{otherwise} \\end{cases} $$\nThis matrix is also symmetric.\n\n**3. Error Calculation**\nThe boundary layer error $\\mathcal{E}_{\\text{BL}}$ is calculated against a reference solution $u_{\\text{ref}}$, which is the VC solution computed on a fine grid with $h_{\\text{ref}}=0.005$. The error is the root-mean-square difference in the boundary layer $\\mathcal{I}_{\\text{BL}}$. The node indices in this layer are $i \\in \\{1,\\dots,M-1\\}$ such that $ih\\le\\delta$ or $1-ih \\le \\delta$, which simplifies to $i \\le k$ or $i \\ge M-k$. Given a coarse grid solution $u_h$, its value at node $x_i^{coarse}=ih$ is compared to the reference solution at the same spatial point. Since coarse grid points align with fine grid points ($h/h_{\\text{ref}}$ is an integer), the corresponding fine grid index is $j = i \\cdot (h/h_{\\text{ref}})$. The error is:\n$$ \\mathcal{E}_{\\text{BL}}(u_h) = \\left(\\frac{1}{|\\mathcal{I}_{\\text{BL}}|}\\sum_{i\\in \\mathcal{I}_{\\text{BL}}}\\big(u_h(x_i)-u_{\\text{ref}}(x_{i \\cdot h/h_{\\text{ref}}})\\big)^2\\right)^{1/2} $$\n\nThe implementation will consist of functions to assemble the matrices for VC and PEN, solve the resulting linear systems using `numpy.linalg.solve`, and then compute the errors as described for each test case.",
            "answer": "```python\nimport numpy as np\n\ndef get_vc_solution(delta, h):\n    \"\"\"\n    Computes the solution for the Volume Constraint (VC) method.\n    \"\"\"\n    if not np.isclose(1/h, round(1/h)) or not np.isclose(delta/h, round(delta/h)):\n        raise ValueError(\"1/h and delta/h must be integers.\")\n    M = int(round(1 / h))\n    N = M - 1\n    k = int(round(delta / h))\n    \n    if N = 0:\n        return np.array([])\n        \n    gamma0 = delta**-3.0\n    \n    A = np.zeros((N, N))\n    \n    # Diagonal term\n    diag_val = 2 * k * h * gamma0\n    np.fill_diagonal(A, diag_val)\n    \n    # Off-diagonal terms\n    offdiag_val = -h * gamma0\n    for d in range(1, k + 1):\n        if d  N:\n            A += np.diag([offdiag_val] * (N - d), k=d)\n            A += np.diag([offdiag_val] * (N - d), k=-d)\n            \n    b = np.ones(N)\n    \n    u = np.linalg.solve(A, b)\n    return u\n\ndef get_pen_solution(delta, h, c):\n    \"\"\"\n    Computes the solution for the Penalty (PEN) method.\n    \"\"\"\n    if not np.isclose(1/h, round(1/h)) or not np.isclose(delta/h, round(delta/h)):\n        raise ValueError(\"1/h and delta/h must be integers.\")\n    M = int(round(1 / h))\n    N = M - 1\n    k = int(round(delta / h))\n\n    if N = 0:\n        return np.array([])\n\n    gamma0 = delta**-3.0\n    \n    A = np.zeros((N, N))\n    \n    # Off-diagonal terms\n    offdiag_val = -h * gamma0\n    for d in range(1, k + 1):\n        if d  N:\n            A += np.diag([offdiag_val] * (N - d), k=d)\n            A += np.diag([offdiag_val] * (N - d), k=-d)\n            \n    # Diagonal terms\n    penalty_alpha = 2 * k * h * gamma0\n    for i in range(N):\n        # Number of interior neighbors = number of non-zero off-diagonals\n        num_neighbors = np.count_nonzero(A[i, :])\n        diag_val = num_neighbors * -offdiag_val # equivalent to num_neighbors * h * gamma0\n        \n        # Add penalty if in layer\n        # Node index is i+1, position is (i+1)*h\n        xi = (i + 1) * h\n        if xi = c * delta or (1.0 - xi) = c * delta:\n            diag_val += penalty_alpha\n            \n        A[i, i] = diag_val\n        \n    b = np.ones(N)\n    u = np.linalg.solve(A, b)\n    return u\n\ndef compute_bl_error(u_h, u_ref, delta, h, h_ref):\n    \"\"\"\n    Computes the boundary layer error.\n    \"\"\"\n    if u_h.size == 0:\n        return 0.0\n        \n    M = int(round(1 / h))\n    k = int(round(delta / h))\n    h_ratio = int(round(h / h_ref))\n    \n    bl_indices_1based = []\n    for i in range(1, M):\n        # Node index i corresponds to position i*h\n        if i = k or i = M - k:\n            bl_indices_1based.append(i)\n            \n    if not bl_indices_1based:\n        return 0.0\n\n    squared_error_sum = 0.0\n    for i_node in bl_indices_1based:\n        # 0-based array index for coarse grid solution\n        idx_h = i_node - 1\n        \n        # Corresponding 0-based array index for reference solution\n        # Node x_i^h = i*h = (i*h_ratio)*h_ref = x_{i*h_ratio}^ref\n        # So node index on ref grid is i*h_ratio\n        idx_ref = i_node * h_ratio - 1\n\n        diff = u_h[idx_h] - u_ref[idx_ref]\n        squared_error_sum += diff**2\n        \n    rms_error = np.sqrt(squared_error_sum / len(bl_indices_1based))\n    return rms_error\n\ndef solve():\n    test_cases = [\n        # (delta, h, c)\n        (0.1, 0.02, 1.0),\n        (0.1, 0.01, 1.0),\n        (0.05, 0.01, 1.0),\n        (0.1, 0.02, 0.5),\n        (0.1, 0.02, 2.0),\n    ]\n\n    h_ref = 0.005\n    ref_solutions_cache = {}\n    results = []\n\n    for delta, h, c in test_cases:\n        # Get or compute the reference solution for the given delta\n        if delta not in ref_solutions_cache:\n            u_ref = get_vc_solution(delta, h_ref)\n            ref_solutions_cache[delta] = u_ref\n        u_ref = ref_solutions_cache[delta]\n\n        # Compute VC solution and its error\n        u_vc = get_vc_solution(delta, h)\n        error_vc = compute_bl_error(u_vc, u_ref, delta, h, h_ref)\n        results.append(error_vc)\n\n        # Compute PEN solution and its error\n        u_pen = get_pen_solution(delta, h, c)\n        error_pen = compute_bl_error(u_pen, u_ref, delta, h, h_ref)\n        results.append(error_pen)\n\n    # Format output as a single line of comma-separated floats\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}