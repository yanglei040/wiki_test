{
    "hands_on_practices": [
        {
            "introduction": "在数值科学中，验证代码的正确性至关重要。本练习将通过“人造解”方法来验证空间分数阶拉普拉斯算子的数值解法，这是一种通过构造已知精确解来测试数值方案的标准技术。你将使用谱方法离散分数阶算子，并通过分析网格加密时的收敛速度来评估方法的准确性，这是科学计算中的一项基本技能。",
            "id": "3426256",
            "problem": "考虑一维有界域 $(0,1)$ 上的齐次狄利克雷边界条件。设 $-\\Delta$ 表示与二阶导数相关的经典拉普拉斯算子，并设 $(-\\Delta)^s$（其中 $s \\in (0,1)$）表示在 $(0,1)$ 上通过关于 $-\\Delta$ 在狄利克雷边界条件下的特征基进行泛函演算定义的光谱分数阶拉普拉斯算子。人工解方法构造一个具有已知右端项的精确解，以验证数值方法的有效性。在此问题中，选择人工解为 $u(x) = \\sin(m\\pi x)$（其中 $m$ 为正整数），并定义 $f(x)$ 使得分数阶泊松问题\n$$\n(-\\Delta)^s u(x) = f(x), \\quad x \\in (0,1), \\quad u(0)=u(1)=0,\n$$\n被精确满足。您可以假定 $(-\\Delta)^s$ 在 $(0,1)$ 上带有齐次狄利克雷边界条件的光谱定义，该定义基于经典狄利克雷拉普拉斯算子的特征函数和特征值。三角函数中的角度必须以弧度为单位。\n\n从以下基本出发点开始：\n- 在 $(0,1)$ 上的经典狄利克雷拉普拉斯算子 $-\\Delta$ 有一组具有实正特征值的完备正交归一特征函数。\n- 光谱分数阶拉普拉斯算子 $(-\\Delta)^s$ 是通过在其谱分解中对 $-\\Delta$ 的特征值施加分数次幂 $s$ 来定义的。\n- 在均匀网格上对经典狄利克雷拉普拉斯算子使用有限差分法 (FDM) 会产生一个近似该算子的对称正定矩阵。\n\n设计一个数值方法，该方法：\n- 使用标准的二阶中心有限差分法，在具有 $N$ 个内部点的均匀网格上构建离散狄利克雷拉普拉斯矩阵。\n- 通过其特征分解计算该矩阵的光谱分数次幂。\n- 根据所选的 $u(x)$ 和 $(-\\Delta)^s$ 的光谱定义，求解由人工构造的右端项 $f(x)$ 构成的离散分数阶泊松问题。\n- 在内部网格点上评估数值解 $u_h$，并将其与在相同网格点上的精确解样本 $u(x_i)$ 进行比较。\n- 使用由下式定义的离散 $L^2$ 误差：\n$$\nE(N) = \\left( h \\sum_{i=1}^{N} \\left| u_h(x_i) - u(x_i) \\right|^2 \\right)^{1/2},\n$$\n其中 $h = \\frac{1}{N+1}$，$x_i = i h$ 是内部网格点。\n\n通过计算在两个连续的网格加密过程 $N \\to 2N$ 下的量来估计观察到的收敛率：\n$$\n\\rho(N \\to 2N) = \\frac{\\log\\left(E(N)/E(2N)\\right)}{\\log(2)}.\n$$\n对于每个测试用例，报告一个浮点数，该数等于在三个网格尺寸 $N_1, N_2, N_3$ 下的两个连续加密率 $\\rho(N_1 \\to N_2)$ 和 $\\rho(N_2 \\to N_3)$ 的平均值。\n\n测试套件：\n- 情况 1：$s = 0.25$，$m = 1$，$N_1 = 50$，$N_2 = 100$，$N_3 = 200$。\n- 情况 2：$s = 0.50$，$m = 1$，$N_1 = 50$，$N_2 = 100$，$N_3 = 200$。\n- 情况 3：$s = 0.75$，$m = 3$，$N_1 = 50$，$N_2 = 100$，$N_3 = 200$。\n- 情况 4：$s = 0.99$，$m = 1$，$N_1 = 50$，$N_2 = 100$，$N_3 = 200$。\n\n$\\sin$ 中的所有角度均以弧度为单位。不涉及物理单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 是第 $k$ 个测试用例的两个连续加密率的平均值。每个列表元素必须是浮点数。",
            "solution": "用户提供了一个问题陈述，要求使用人工解来验证一维分数阶泊松问题的数值方法。该问题在科学上是合理的、适定的，并包含了获得唯一解所需的所有必要信息。因此，我们可以着手提供完整的解决方案。\n\n### 1. 数学公式\n\n我们考虑的问题是在域 $\\Omega = (0,1)$ 上带有齐次狄利克雷边界条件的分数阶泊松方程：\n$$\n\\begin{cases}\n(-\\Delta)^s u(x) = f(x),  x \\in (0,1) \\\\\nu(0) = u(1) = 0\n\\end{cases}\n$$\n其中 $s \\in (0,1)$ 是分数阶。算子 $(-\\Delta)^s$ 是光谱分数阶拉普拉斯算子。\n\n在 $(0,1)$ 上带有齐次狄利克雷边界条件的经典拉普拉斯算子 $-\\Delta = -d^2/dx^2$ 有一组已知的特征值 $\\lambda_k$ 和相应的正交归一特征函数 $\\phi_k(x)$：\n$$\n\\lambda_k = (k\\pi)^2, \\quad \\phi_k(x) = \\sqrt{2}\\sin(k\\pi x), \\quad k = 1, 2, 3, \\dots\n$$\n在适当函数空间中的任何函数 $g(x)$ 都可以通过其特征函数展开来表示 $g(x) = \\sum_{k=1}^{\\infty} c_k \\phi_k(x)$，其中 $c_k = \\int_0^1 g(x) \\phi_k(x) dx$。光谱分数阶拉普拉斯算子通过其在此展开式上的作用来定义：\n$$\n(-\\Delta)^s g(x) = \\sum_{k=1}^{\\infty} c_k \\lambda_k^s \\phi_k(x)\n$$\n问题指定了一个人工解 $u(x) = \\sin(m\\pi x)$，其中 $m$ 为某个正整数。这个选择很方便，因为 $u(x)$ 与第 $m$ 个特征函数 $\\phi_m(x)$ 成正比：$u(x) = \\frac{1}{\\sqrt{2}}\\phi_m(x)$。\n将分数阶算子应用于 $u(x)$，我们得到：\n$$\n(-\\Delta)^s u(x) = (-\\Delta)^s \\left( \\frac{1}{\\sqrt{2}}\\phi_m(x) \\right) = \\frac{1}{\\sqrt{2}} \\lambda_m^s \\phi_m(x)\n$$\n代入 $\\lambda_m$ 和 $\\phi_m(x)$ 的表达式：\n$$\n(-\\Delta)^s u(x) = \\frac{1}{\\sqrt{2}} ((m\\pi)^2)^s (\\sqrt{2}\\sin(m\\pi x)) = (m\\pi)^{2s} \\sin(m\\pi x)\n$$\n因此，为了用人工解 $u(x)$ 来满足该方程，右端项函数 $f(x)$ 必须是：\n$$\nf(x) = (m\\pi)^{2s} \\sin(m\\pi x)\n$$\n\n### 2. 数值离散化\n\n连续域 $(0,1)$ 使用一个具有 $N$ 个内部点的均匀网格进行离散化。设网格间距为 $h = 1/(N+1)$。网格点为 $x_i = i h$，其中 $i = 0, 1, \\dots, N+1$。内部点为 $\\{x_i\\}_{i=1}^N$。设 $u_h$ 为 $u(x)$ 在这些内部点上的数值近似向量，即 $u_h = [u(x_1), u(x_2), \\dots, u(x_N)]^T$。\n\n经典拉普拉斯算子 $-\\Delta$ 使用二阶中心有限差分格式进行近似：\n$$\n-\\frac{d^2u}{dx^2}\\bigg|_{x=x_i} \\approx \\frac{-u(x_{i-1}) + 2u(x_i) - u(x_{i+1})}{h^2}\n$$\n结合边界条件 $u(x_0)=u(0)=0$ 和 $u(x_{N+1})=u(1)=0$，这种离散化导致一个 $N \\times N$ 的矩阵系统。离散拉普拉斯算子，记为 $A_h$，是一个对称正定矩阵：\n$$\nA_h = \\frac{1}{h^2}\n\\begin{pmatrix}\n2  &-1  &0  &\\dots  &0 \\\\\n-1  &2  &-1  &\\dots  &0 \\\\\n0  &\\ddots  &\\ddots  &\\ddots  &0 \\\\\n\\vdots   &-1  &2  &-1 \\\\\n0  &\\dots  &0  &-1  &2\n\\end{pmatrix}\n$$\n\n### 3. 求解离散分数阶系统\n\n数值方法是光谱定义的一个离散模拟。离散分数阶拉普拉斯算子 $A_h^s$ 是通过 $A_h$ 的特征分解来计算的。设 $A_h$ 的特征分解为：\n$$\nA_h = V \\Lambda V^T\n$$\n其中 $\\Lambda$ 是一个包含 $A_h$ 特征值 $\\mu_k$ 的对角矩阵，而 $V$ 是一个正交矩阵，其列是相应的特征向量 $v_k$。矩阵幂 $A_h^s$ 则定义为：\n$$\nA_h^s = V \\Lambda^s V^T\n$$\n其中 $\\Lambda^s$ 是对角线元素为 $\\mu_k^s$ 的对角矩阵。\n\n分数阶泊松问题的离散形式是线性系统：\n$$\nA_h^s u_h = f_h\n$$\n其中 $f_h = [f(x_1), f(x_2), \\dots, f(x_N)]^T$ 是在内部网格点上评估的右端项函数的向量。数值近似解 $u_h$ 由下式给出：\n$$\nu_h = (A_h^s)^{-1} f_h = (V \\Lambda^s V^T)^{-1} f_h = V \\Lambda^{-s} V^T f_h\n$$\n这提供了一个计算上稳定且高效的算法：\n1.  构建矩阵 $A_h$。\n2.  使用可靠的数值库函数（例如 `scipy.linalg.eigh`）计算其特征值 $\\Lambda$ 和特征向量 $V$。\n3.  构建向量 $f_h$。\n4.  将 $f_h$ 转换到 $A_h$ 的特征基中：$\\hat{f}_h = V^T f_h$。\n5.  在特征基中缩放分量：$\\hat{u}_h(k) = \\mu_k^{-s} \\hat{f}_h(k)$。这是一个逐分量相乘的操作。\n6.  将结果转换回标准基：$u_h = V \\hat{u}_h$。\n\n### 4. 误差分析与收敛率\n\n为了验证该方法，我们将数值解 $u_h$ 与在网格点上采样的精确解 $u(x)$ 进行比较。精确解值的向量为 $u_{exact} = [u(x_1), u(x_2), \\dots, u(x_N)]^T$。\n\n误差使用离散 $L^2$ 范数进行量化：\n$$\nE(N) = \\left( h \\sum_{i=1}^{N} | u_h(x_i) - u(x_i) |^2 \\right)^{1/2} = \\sqrt{h} \\|u_h - u_{exact}\\|_2\n$$\n其中 $\\|\\cdot\\|_2$ 表示标准的欧几里得向量范数。\n\n收敛阶 $\\rho$ 通过加密网格来估计。如果误差行为如 $E(N) \\approx C h^\\rho = C (N+1)^{-\\rho}$（其中 $C$ 为某个常数），那么对于两个网格尺寸 $N$ 和 $2N$，误差比率近似为 $E(N)/E(2N) \\approx ((N+1)^{-1} / (2N+1)^{-1})^\\rho \\approx 2^\\rho$。取对数即可得到观察到的收敛率公式：\n$$\n\\rho(N \\to 2N) = \\frac{\\log(E(N)/E(2N))}{\\log(2)}\n$$\n问题要求计算两个连续加密过程（$N_1 \\to N_2$ 和 $N_2 \\to N_3$）的这个率（其中并没有假设 $N_2=2N_1$ 和 $N_3=2N_2$，但在测试用例中是这样），并报告这两个率的平均值。这提供了对渐近收敛率更稳定的估计。对于具有光滑人工解的此方法，预期的收敛率是 $\\rho=2$，因为主要误差来源于拉普拉斯算子的二阶有限差分近似。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # (s, m, (N1, N2, N3))\n        {'s': 0.25, 'm': 1, 'N_grid': (50, 100, 200)},\n        {'s': 0.50, 'm': 1, 'N_grid': (50, 100, 200)},\n        {'s': 0.75, 'm': 3, 'N_grid': (50, 100, 200)},\n        {'s': 0.99, 'm': 1, 'N_grid': (50, 100, 200)},\n    ]\n\n    results = []\n    for case in test_cases:\n        mean_rate = compute_mean_convergence_rate(case['s'], case['m'], case['N_grid'])\n        results.append(mean_rate)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_mean_convergence_rate(s, m, N_grid_sizes):\n    \"\"\"\n    Computes the mean convergence rate for a given set of parameters.\n\n    Args:\n        s (float): The fractional order of the Laplacian.\n        m (int): The mode number for the manufactured solution.\n        N_grid_sizes (tuple): A tuple of three integers (N1, N2, N3) for grid sizes.\n\n    Returns:\n        float: The mean of two successive convergence rates.\n    \"\"\"\n    errors = []\n    for N in N_grid_sizes:\n        h = 1.0 / (N + 1)\n        \n        # 1. Define interior grid points\n        x = np.linspace(h, 1.0 - h, N)\n        \n        # 2. Construct the discrete Laplacian matrix A_h\n        main_diag = np.full(N, 2.0)\n        off_diag = np.full(N - 1, -1.0)\n        A_h = (np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)) / (h**2)\n        \n        # 3. Compute the eigendecomposition of A_h.\n        # eigh is used for symmetric matrices.\n        eigenvalues, eigenvectors = eigh(A_h)\n        \n        # 4. Construct the right-hand side vector f_h\n        # f(x) = (m*pi)^(2s) * sin(m*pi*x)\n        f_h = (m * np.pi)**(2 * s) * np.sin(m * np.pi * x)\n        \n        # 5. Solve the linear system A_h^s * u_h = f_h using the spectral method\n        # u_h = V * Lambda^(-s) * V^T * f_h\n        # Step 5.1: Transform f_h to the eigenbasis\n        f_hat = eigenvectors.T @ f_h\n        # Step 5.2: Scale by Lambda^(-s)\n        u_hat = f_hat * (eigenvalues**(-s))\n        # Step 5.3: Transform back to the standard basis\n        u_h = eigenvectors @ u_hat\n        \n        # 6. Compute the exact solution vector u_exact\n        u_exact = np.sin(m * np.pi * x)\n        \n        # 7. Calculate the discrete L2 error E(N)\n        error_norm_sq = np.sum((u_h - u_exact)**2)\n        error_L2 = np.sqrt(h * error_norm_sq)\n        errors.append(error_L2)\n        \n    # 8. Calculate convergence rates\n    E1, E2, E3 = errors\n    \n    # Check for grid refinement ratio. Assume it is 2 for simplicity.\n    grid_ratio1 = N_grid_sizes[1] / N_grid_sizes[0]\n    grid_ratio2 = N_grid_sizes[2] / N_grid_sizes[1]\n\n    rate1 = np.log(E1 / E2) / np.log(grid_ratio1)\n    rate2 = np.log(E2 / E3) / np.log(grid_ratio2)\n    \n    mean_rate = (rate1 + rate2) / 2.0\n    \n    return mean_rate\n\nsolve()\n\n```"
        },
        {
            "introduction": "与整数阶微分方程不同，时间分数阶偏微分方程的解即使在源项和初值条件光滑的情况下，也常常在初始时刻 $t=0$ 处表现出奇异性。本练习通过一个解析推导，揭示了这种“启动奇异性”如何降低标准数值格式的收敛精度。你将分析并确定如何通过设计一种非均匀的“分级网格”来恢复方法的最佳收敛阶，这是开发稳健高效的时间分数阶问题求解器的关键一步。",
            "id": "3426227",
            "problem": "考虑在空间区间 $x \\in (0,1)$ 上的时间分数阶扩散方程，其具有阶数为 $\\alpha \\in (0,1)$ 的 Caputo 分数阶导数、齐次 Dirichlet 边界条件以及一个源项。该源项的选择使得当 $t \\in [0,1]$ 时，精确解为 $u(x,t) = \\sin(\\pi x)\\,t^{\\sigma}$，其中 $\\sigma \\in (0,1]$。通过投影到拉普拉斯算子（Laplacian）的第一个特征模态上，时间演化问题简化为一个关于振幅 $y(t)$ 的标量方程，其精确解为 $y(t) = t^{\\sigma}$。阶数为 $\\alpha$ 的 Caputo 分数阶导数定义为\n$$\n{}^{\\mathrm{C}}D_{t}^{\\alpha} y(t) = \\frac{1}{\\Gamma(1-\\alpha)} \\int_{0}^{t} (t-s)^{-\\alpha}\\,y'(s)\\,\\mathrm{d}s.\n$$\n使用 $N$ 个步长在分级网格 $\\{t_{n}\\}_{n=0}^{N}$ 上对时间区间 $[0,1]$ 进行离散化，该网格由 $t_{n} = \\left(\\frac{n}{N}\\right)^{\\gamma}$ 定义，分级指数 $\\gamma \\geq 1$。通过经典的 $L1$ 格式在 $t=t_{n}$ 处近似 Caputo 导数，\n$$\n\\mathcal{L}_{1}[y](t_{n}) = \\frac{1}{\\Gamma(1-\\alpha)} \\sum_{k=1}^{n} \\left(\\frac{y(t_{k}) - y(t_{k-1})}{t_{k} - t_{k-1}} \\right) \\int_{t_{k-1}}^{t_{k}} (t_{n}-s)^{-\\alpha}\\,\\mathrm{d}s.\n$$\n仅从上述定义以及关于 $L1$ 格式光滑解精度的已知事实出发，分析当 $N \\to \\infty$ 时，对于初始奇异解 $y(t) = t^{\\sigma}$，在 $t=1$ 处的全局离散误差\n$$\nE_{N} = \\left|{}^{\\mathrm{C}}D_{t}^{\\alpha} y(1) - \\mathcal{L}_{1}[y](1)\\right|\n$$\n的主阶行为。然后确定最小分级指数 $\\gamma$，使得总误差满足 $E_{N} = \\mathcal{O}\\!\\left(N^{-(2-\\alpha)}\\right)$，即该方法达到其光滑解的精度阶。你的最终答案必须是关于 $\\alpha$ 和 $\\sigma$ 的单个闭式解析表达式，该表达式表示为确保当 $N \\to \\infty$ 时 $E_{N} = \\mathcal{O}\\!\\left(N^{-(2-\\alpha)}\\right)$ 所需的最小 $\\gamma$。",
            "solution": "该问题要求分析在 $t=1$ 时，对函数 $y(t) = t^{\\sigma}$ 的 $\\alpha$ 阶 Caputo 分数阶导数使用 L1 近似所产生的全局离散误差 $E_{N}$。时间域 $[0,1]$ 使用分级网格 $t_{n} = (n/N)^{\\gamma}$（$n=0, 1, \\dots, N$）进行离散化，其分级指数 $\\gamma \\geq 1$。目标是找到最小的 $\\gamma$，以确保误差 $E_N$ 以最优速率 $\\mathcal{O}(N^{-(2-\\alpha)})$ 收敛，这是对于足够光滑的解的已知速率。\n\n在 $t=t_N=1$ 处的全局误差由下式给出\n$$\nE_{N} = \\left|{}^{\\mathrm{C}}D_{t}^{\\alpha} y(1) - \\mathcal{L}_{1}[y](1)\\right|.\n$$\n通过代入 Caputo 导数和 L1 格式的定义，我们可以将误差表示为在子区间 $[t_{k-1}, t_k]$ 上的局部误差之和：\n$$\nE_{N} = \\frac{1}{\\Gamma(1-\\alpha)} \\left| \\sum_{k=1}^{N} \\int_{t_{k-1}}^{t_{k}} (1-s)^{-\\alpha} \\left( y'(s) - \\frac{y(t_k) - y(t_{k-1})}{t_k - t_{k-1}} \\right) \\mathrm{d}s \\right|.\n$$\n函数为 $y(t) = t^{\\sigma}$，其一阶导数为 $y'(t) = \\sigma t^{\\sigma-1}$，二阶导数为 $y''(t) = \\sigma(\\sigma-1)t^{\\sigma-2}$。在给定范围 $\\sigma \\in (0,1]$ 内，二阶导数 $y''(t)$ 在 $t=0$ 处是奇异的（除非 $\\sigma=1$，此时 $y''(t)=0$，问题变得平凡，因为 L1 格式对线性函数是精确的）。当使用均匀网格时，原点处的这种奇异性是导致收敛阶降低的根源。分级网格通过在 $t=0$ 附近加密点来减弱这种奇异性的影响。\n\n对于具有 $t^{\\sigma}$ 形式的初始代数奇异性的解，在分级网格上对 L1 格式进行的误差分析表明，全局误差由两个相互竞争的因素决定：\n1. 对函数在 $t=0$ 附近的非光滑部分进行近似所产生的误差。该误差由分级指数 $\\gamma$ 和奇异性强度 $\\sigma$ 控制。\n2. 数值方法在定义域较光滑部分上的标准截断误差，该误差对应于正则解（例如 $y \\in C^2[0,1]$）所观察到的收敛速率。\n\n分数阶方程数值分析的一个标准结果指出，对于具有 $y(t)=t^\\sigma$ 正则性的函数，L1 格式在分级网格上的收敛阶由这两个误差源的平衡决定。全局误差 $E_N$ 的形式为：\n$$\nE_N = \\mathcal{O}(N^{-\\min(\\gamma \\sigma, 2-\\alpha)}).\n$$\n$\\mathcal{O}(N^{-\\gamma \\sigma})$ 项表示来自初始奇异性的误差贡献。在 $t=0$ 附近使用更密的网格（更大的 $\\gamma$）或更光滑的解（更大的 $\\sigma$）会导致该误差分量更快地衰减。$\\mathcal{O}(N^{-(2-\\alpha)})$ 项是 L1 格式对光滑解的经典收敛率，问题陈述中称之为“光滑解精度”。总精度受这两个速率中较慢者的限制。\n\n我们的目标是确定最小分级指数 $\\gamma$，使得该方法能达到其最优的光滑解精度。这意味着我们需要总误差为 $E_N = \\mathcal{O}(N^{-(2-\\alpha)})$。要使其成立，由奇异性引起的误差分量 $\\mathcal{O}(N^{-\\gamma \\sigma})$ 的收敛速率必须至少与 $\\mathcal{O}(N^{-(2-\\alpha)})$ 一样快。这对指数施加了如下条件：\n$$\n\\gamma \\sigma \\geq 2-\\alpha.\n$$\n为了找到满足此条件的最小分级指数 $\\gamma$，我们取等号，因为任何更小的 $\\gamma$ 都会导致 $\\mathcal{O}(N^{-\\gamma \\sigma})$ 项占主导地位，从而决定了一个次优的收敛率。\n$$\n\\gamma \\sigma = 2-\\alpha.\n$$\n求解 $\\gamma$，我们得到所需的最小分级指数：\n$$\n\\gamma = \\frac{2-\\alpha}{\\sigma}.\n$$\n我们应该验证该值是否与约束 $\\gamma \\geq 1$ 一致。鉴于 $\\alpha \\in (0,1)$ 且 $\\sigma \\in (0,1]$，分子 $2-\\alpha$ 在区间 $(1,2)$ 内，分母 $\\sigma$ 在区间 $(0,1]$ 内。因此，比值 $\\frac{2-\\alpha}{\\sigma}$ 总是大于 1。该条件得到满足。$\\gamma$ 的这一选择精确地平衡了来自初始奇异性的误差与数值格式的内在误差，从而恢复了最优收敛阶。",
            "answer": "$$\n\\boxed{\\frac{2-\\alpha}{\\sigma}}\n$$"
        },
        {
            "introduction": "分数阶导数具有“记忆”效应，其精确的数值实现需要对历史信息进行严谨处理，尤其是在处理初值条件时。本练习旨在通过一个编程实践，对比一种考虑了初值修正的“Caputo相容”格式和一种简化的“朴素”格式。你将发现，在分数阶 $\\alpha \\to 0^+$ 的极限情况下，只有前者能正确地收敛到问题的物理解，这个练习深刻地揭示了算法实现中细节的重要性。",
            "id": "3426234",
            "problem": "考虑一个源于时间分数阶偏微分方程背景的时间分数阶常微分方程的初值问题，其 Caputo 形式如下：求解函数 $u:[0,T]\\to\\mathbb{R}$，使得\n$\nD_t^\\alpha u(t) = f(t), \\quad t\\in(0,T], \\qquad u(0)=u_0,\n$\n其中 $D_t^\\alpha$ 表示阶数为 $\\alpha\\in(0,1)$ 的 Caputo 分数阶导数，而 $f$ 是一个给定的源项。Caputo 分数阶导数是通过将 $1-\\alpha$ 阶的 Riemann–Liouville 积分作用于一阶导数来定义的，\n$\nD_t^\\alpha u(t) := I^{1-\\alpha} u'(t), \\qquad I^\\beta v(t) := \\frac{1}{\\Gamma(\\beta)}\\int_0^t (t-s)^{\\beta-1} v(s)\\,\\mathrm{d}s, \\quad \\beta>0.\n$\n一个经过充分检验的事实是，对于足够正则的 $u$，当 $\\alpha\\to 0^+$ 时，其极限为\n$\n\\lim_{\\alpha\\to 0^+} D_t^\\alpha u(t) = u(t)-u(0) \\quad \\text{for } t>0,\n$\n这意味着，在形式上，$D_t^\\alpha u = f$ 的解在 $t>0$ 时满足，当 $\\alpha\\to 0^+$ 时有 $u(t)\\to u_0+f(t)$。\n\n你的任务是从基本原理出发，推导一个能够正确捕捉 $\\alpha\\to 0^+$ 极限行为的、稳定且相容的时间步进格式，并加以实现。此外，还需实现一个错误处理极限记忆效应的朴素离散化方法，并诊断其失效的原因。推导應基于以下基本点：\n- Caputo 导数 $D_t^\\alpha u$ 关于 $I^{1-\\alpha} u'(t)$（其中 $\\alpha\\in(0,1)$）的定义。\n- 针对一阶导数的经典向后欧拉方法以及卷积求積 (Convolution Quadrature, CQ) 的概念。对于一个生成函数为 $\\delta(\\zeta)$ 的线性多步法，CQ 通过 $\\delta(\\zeta)^\\alpha$ 的幂级数展开得到离散卷积权重。\n- Caputo 初值修正，即将分数阶算子内的 $u$ 替换为 $u-u(0)$，从而在 $t=0$ 处一致地施加初值条件。\n\n在均匀网格 $t_n = n\\tau$（其中 $n=0,1,\\dots,N$ 且 $\\tau = T/N$）上，设计以下两种全离散时间格式：\n- 一种基于向后欧拉卷积求积 (CQ) 的 Caputo 相容格式，该格式融合了 Caputo 初值修正，使得当 $\\alpha\\to 0^+$ 时，对于 $n\\ge 1$，格式能恢复为 $u^n \\approx u_0 + f(t_n)$。\n- 一种朴素的 Grünwald 型格式，该格式省略了 Caputo 初值修正，因此无法恢复正确的极限，而是在 $\\alpha\\to 0^+$ 时趋向于 $u^n \\approx f(t_n)$。\n\n然后，对于每个离散时间层 $n\\in\\{1,2,\\dots,N\\}$，将每种格式得到的 $u^n$ 与极限目标 $u_0+f(t_n)$ 进行比较，并计算在正时间 $t_n>0$ 上的最大绝对偏差：\n$\nE_{\\mathrm{cap}} := \\max_{1\\le n\\le N} \\big|u^n_{\\mathrm{cap}} - (u_0+f(t_n))\\big|, \\qquad E_{\\mathrm{naive}} := \\max_{1\\le n\\le N} \\big|u^n_{\\mathrm{naive}} - (u_0+f(t_n))\\big|.\n$\n\n角度单位要求：当使用三角函数时，其参数应以弧度为单位。\n\n测试套件。使用以下测试用例评估这些格式。对于每个测试，报告如上指定的两个实数 $E_{\\mathrm{cap}}$ 和 $E_{\\mathrm{naive}}$。\n- 测试 1：$\\alpha=10^{-2}$，$u_0=1.3$，$T=1$，$N=200$，$f(t)=\\sin(t)$，参数以弧度为单位。\n- 测试 2：$\\alpha=10^{-6}$，$u_0=-0.7$，$T=1$，$N=200$，$f(t)=\\mathrm{e}^{-t}$。\n- 测试 3：$\\alpha=10^{-3}$，$u_0=0$，$T=1$，$N=20$，$f(t)=t^2$。\n- 测试 4：$\\alpha=5\\times 10^{-2}$，$u_0=2$，$T=2$，$N=400$，$f(t)=\\cos(3t)$，参数以弧度为单位。\n\n最终输出格式。你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序如下\n$\n[E_{\\mathrm{cap}}^{(1)},E_{\\mathrm{naive}}^{(1)},E_{\\mathrm{cap}}^{(2)},E_{\\mathrm{naive}}^{(2)},E_{\\mathrm{cap}}^{(3)},E_{\\mathrm{naive}}^{(3)},E_{\\mathrm{cap}}^{(4)},E_{\\mathrm{naive}}^{(4)}],\n$\n其中上标表示测试编号。所有输出都必须是实数（浮点数）。不应打印任何其他文本。",
            "solution": "**第 1 步：问题验证**\n\n- **已知条件提取：**\n  - 方程：$D_t^\\alpha u(t) = f(t)$ 对于 $t \\in (0, T]$，其中 $u(0) = u_0$ 且 $\\alpha \\in (0, 1)$。\n  - Caputo 导数：$D_t^\\alpha u(t) := I^{1-\\alpha} u'(t)$。\n  - Riemann-Liouville 积分：$I^\\beta v(t) := \\frac{1}{\\Gamma(\\beta)}\\int_0^t (t-s)^{\\beta-1} v(s)\\,\\mathrm{d}s$。\n  - 极限行为：$\\lim_{\\alpha\\to 0^+} D_t^\\alpha u(t) = u(t)-u(0)$。\n  - 目标极限：$D_t^\\alpha u = f$ 的解应在 $\\alpha \\to 0^+$ 时满足 $u(t) \\to u_0 + f(t)$。\n  - 数值方法：向后欧拉卷积求积 (CQ)。\n  - 格式 1 (Caputo 相容)：必须包含初值修正以恢复正确的极限。\n  - 格式 2 (朴素)：省略修正，无法恢复正确的极限。\n  - 离散化：均匀网格 $t_n = n\\tau$，$\\tau = T/N$。\n  - 误差度量：$E_{\\mathrm{cap}} := \\max_{1\\le n\\le N} |u^n_{\\mathrm{cap}} - (u_0+f(t_n))|$，$E_{\\mathrm{naive}} := \\max_{1\\le n\\le N} |u^n_{\\mathrm{naive}} - (u_0+f(t_n))|$。\n  - 测试用例：提供了四组特定的参数 $(\\alpha, u_0, T, N, f(t))$。\n\n- **有效性检查：**\n  - 该问题在分数阶微积分和数值分析的既有理论中具有**坚实的科学基础**。所引用的定义和性质均为标准内容。\n  - 该问题是**适定的**，提供了明确的目标和达成目标所需的所有必要信息。\n  - 语言是**客观的**和数学化的。\n  - 该问题没有任何指令中列出的无效缺陷（例如，它不是不合理的、不完整的或琐碎的）。\n\n- **结论：**该问题是**有效的**。开始求解。\n\n**第 2 步：数值格式推导**\n\n目标是在均匀网格 $t_n = n\\tau$（其中 $n=0, 1, \\dots, N$）上数值求解初值问题\n$$\nD_t^\\alpha u(t) = f(t), \\quad t\\in(0,T], \\qquad u(0)=u_0,\n$$\n步长为 $\\tau = T/N$。我们将 $u(t_n)$ 的数值近似记为 $u^n$，$f(t_n)$ 记为 $f_n$。\n\n该方法的核心是使用基于向后欧拉方法的卷积求积 (CQ) 来离散化 Caputo 导数算子 $D_t^\\alpha$。连续算子 $D_t^\\alpha$ 的拉普拉斯符号是 $s^\\alpha$。对于向后欧拉方法，一阶导数近似为 $\\frac{v(t) - v(t-\\tau)}{\\tau}$，这在 $z$ 变换域中对应于将微分算子 $\\partial_t$ 替换为 $\\delta(\\zeta)/\\tau = (1-\\zeta^{-1})/\\tau$。我们将使用生成函数 $\\delta(\\zeta)=1-\\zeta$。因此，对应于 $s^\\alpha$ 的离散算子是 $(\\delta(\\zeta)/\\tau)^\\alpha = \\tau^{-\\alpha}(1-\\zeta)^\\alpha$。\n\n离散卷积权重的生成函数 $(1-\\zeta)^\\alpha$ 使用广义二项式定理展开：\n$$\n(1-\\zeta)^\\alpha = \\sum_{j=0}^\\infty \\binom{\\alpha}{j} (-\\zeta)^j =: \\sum_{j=0}^\\infty g_j \\zeta^j.\n$$\n卷积权重为 $g_j = (-1)^j \\binom{\\alpha}{j}$。这些权重可以通过递推关系高效计算：\n$$\ng_0 = 1, \\qquad g_j = \\left(1 - \\frac{\\alpha+1}{j}\\right) g_{j-1} \\quad \\text{for } j \\ge 1.\n$$\n一个时间索引序列 $\\{v^k\\}_{k=0}^N$ 的离散分数阶导数，记为 $(\\partial_\\tau^\\alpha v)^n$，被定义为离散卷积：\n$$\n(\\partial_\\tau^\\alpha v)^n := \\tau^{-\\alpha} \\sum_{j=0}^n g_j v^{n-j}.\n$$\n\n正如问题中所强调的，关键在于如何处理初值条件 $u(0) = u_0$。这导致了两种不同的格式。\n\n**格式 1：Caputo 相容格式**\n\n该格式包含了“初值修正”。其动机是恒等式 $D_t^\\alpha u(t) = D_t^\\alpha (u(t) - u_0)$，该恒等式成立是因为常数的导数为零。我们将离散分数阶算子应用于函数 $v(t) = u(t) - u_0$，该函数的初值为零，即 $v(0)=0$。离散序列为 $v^n = u^n - u_0$，其中 $v^0 = u^0 - u_0 = 0$。\n\n在 $t=t_n$ 处的离散方程为 $(\\partial_\\tau^\\alpha v)^n = f_n$，展开后为：\n$$\n\\tau^{-\\alpha} \\sum_{j=0}^n g_j v^{n-j} = f_n \\implies \\tau^{-\\alpha} \\sum_{j=0}^n g_j (u^{n-j} - u_0) = f_n.\n$$\n整理各项以求解 $u^n$：\n$$\n\\sum_{j=0}^n g_j u^{n-j} - u_0 \\sum_{j=0}^n g_j = \\tau^\\alpha f_n.\n$$\n从第一个和式中分离出 $j=0$ 的项（因为 $g_0=1$）：\n$$\ng_0 u^n + \\sum_{j=1}^n g_j u^{n-j} = \\tau^\\alpha f_n + u_0 \\sum_{j=0}^n g_j.\n$$\n$$\nu^n = \\tau^\\alpha f_n + u_0 \\sum_{j=0}^n g_j - \\sum_{j=1}^n g_j u^{n-j}.\n$$\n这就定义了 Caputo 相容格式 $u^n_{\\mathrm{cap}}$ 的时间步进法则。\n我们来分析其在 $\\alpha \\to 0^+$ 时的行为。对于固定的 $j \\ge 1$，权重 $g_j = (-1)^j \\binom{\\alpha}{j} = O(\\alpha) \\to 0$。权重和 $\\sum_{j=0}^n g_j$ 是 $(1-1)^\\alpha=0$ 级数的截斷部分和。对于任意 $z \\in (-1,1)$，有 $\\sum_{j=0}^\\infty g_j z^j = (1-z)^\\alpha$。当 $\\alpha \\to 0^+$ 时，$(1-z)^\\alpha \\to 1$。直观上，这意味着当 $\\alpha \\to 0^+$ 时 $\\sum_{j=0}^n g_j \\to 1$（因为 $g_0=1$ 且对于 $j \\ge 1$ 有 $g_j \\to 0$）。此外，我们有 $\\tau^\\alpha \\to 1$。\n该格式变为：\n$$\nu^n_{\\mathrm{cap}} \\to 1 \\cdot f_n + u_0 \\cdot 1 - \\sum_{j=1}^n (0) \\cdot u^{n-j}_{\\mathrm{cap}} = u_0 + f_n.\n$$\n这正确地捕捉了所期望的极限行为。\n\n**格式 2：朴素格式**\n\n该格式省略了初值修正，并将离散算子直接应用于序列 $\\{u^n\\}$，该序列并非从零开始（$u^0=u_0$）。\n离散化方程为 $(\\partial_\\tau^\\alpha u)^n = f_n$：\n$$\n\\tau^{-\\alpha} \\sum_{j=0}^n g_j u^{n-j} = f_n.\n$$\n分离出 $j=0$ 的项以求解 $u^n$：\n$$\ng_0 u^n + \\sum_{j=1}^n g_j u^{n-j} = \\tau^\\alpha f_n.\n$$\n$$\nu^n = \\tau^\\alpha f_n - \\sum_{j=1}^n g_j u^{n-j}.\n$$\n这就定义了朴素格式 $u^n_{\\mathrm{naive}}$ 的时间步进法则。\n我们来分析其在 $\\alpha \\to 0^+$ 时的行为。和之前一样，对于 $j \\ge 1$ 有 $g_j \\to 0$，且 $\\tau^\\alpha \\to 1$。\n更新法则简化为：\n$$\nu^n_{\\mathrm{naive}} \\to 1 \\cdot f_n - \\sum_{j=1}^n (0) \\cdot u^{n-j}_{\\mathrm{naive}} = f_n.\n$$\n该格式未能恢复初值条件的贡献，趋向于 $f_n$ 而不是 $u_0 + f_n$。\n\n**实现方案总结**\n\n对于 $n=1, 2, \\dots, N$，且 $u^0 = u_0$：\n- **Caputo 相容格式：**\n  $u^n_{\\mathrm{cap}} = \\tau^\\alpha f_n + u_0 S_n - \\sum_{j=1}^n g_j u^{n-j}_{\\mathrm{cap}}$，其中 $S_n = \\sum_{j=0}^n g_j$。\n- **朴素格式：**\n  $u^n_{\\mathrm{naive}} = \\tau^\\alpha f_n - \\sum_{j=1}^n g_j u^{n-j}_{\\mathrm{naive}}$。\n\n实现时将预先计算权重 $g_j$ 及其累加和 $S_n$，然后进行时间步进循环，在每一步计算卷积和。最后，通过将数值解与目标极限解 $u_0 + f(t_n)$（对于 $n \\ge 1$）进行比较，计算误差 $E_{\\mathrm{cap}}$ 和 $E_{\\mathrm{naive}}$。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(alpha, u0, T, N, f_func):\n    \"\"\"\n    Solves the fractional ODE using two schemes and computes their error.\n\n    Args:\n        alpha (float): The order of the fractional derivative.\n        u0 (float): The initial condition u(0).\n        T (float): The final time.\n        N (int): The number of time steps.\n        f_func (callable): The source function f(t).\n\n    Returns:\n        tuple[float, float]: A tuple containing E_cap and E_naive.\n    \"\"\"\n    # 1. Setup grid and parameters\n    tau = T / N\n    t = np.linspace(0, T, N + 1)\n    f_vals = f_func(t)\n\n    # 2. Precompute convolution weights g_j and their cumulative sum S_j\n    # The weights g_j are related to the coefficients of (1-zeta)^alpha.\n    # g_j = (-1)^j * binom(alpha, j)\n    # The recurrence g_j = g_{j-1} * (1 - (alpha + 1) / j) is used.\n    g = np.zeros(N + 1)\n    g[0] = 1.0\n    for j in range(1, N + 1):\n        g[j] = g[j - 1] * (1 - (alpha + 1) / j)\n\n    S = np.cumsum(g)\n\n    # 3. Initialize solution arrays\n    u_cap = np.zeros(N + 1)\n    u_naive = np.zeros(N + 1)\n    u_cap[0] = u0\n    u_naive[0] = u0\n\n    tau_alpha = tau**alpha\n\n    # 4. Time-stepping loop\n    for n in range(1, N + 1):\n        # Convolution sum: sum_{j=1 to n} g_j * u_{n-j}\n        # u_cap[n-1::-1] is (u_{n-1}, u_{n-2}, ..., u_0)\n        # g[1:n+1] is (g_1, g_2, ..., g_n)\n        conv_cap = np.dot(g[1:n + 1], u_cap[n - 1::-1])\n        conv_naive = np.dot(g[1:n + 1], u_naive[n - 1::-1])\n\n        # Caputo-consistent scheme update\n        u_cap[n] = tau_alpha * f_vals[n] + u0 * S[n] - conv_cap\n\n        # Naive scheme update\n        u_naive[n] = tau_alpha * f_vals[n] - conv_naive\n\n    # 5. Calculate errors against the limiting target solution u0 + f(t)\n    target_solution = u0 + f_vals\n    \n    # Error is max absolute difference for t_n > 0 (i.e., n >= 1)\n    E_cap = np.max(np.abs(u_cap[1:] - target_solution[1:]))\n    E_naive = np.max(np.abs(u_naive[1:] - target_solution[1:]))\n    \n    return E_cap, E_naive\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'alpha': 1e-2, 'u0': 1.3, 'T': 1, 'N': 200, 'f': lambda t: np.sin(t)},\n        {'alpha': 1e-6, 'u0': -0.7, 'T': 1, 'N': 200, 'f': lambda t: np.exp(-t)},\n        {'alpha': 1e-3, 'u0': 0.0, 'T': 1, 'N': 20, 'f': lambda t: t**2},\n        {'alpha': 5e-2, 'u0': 2.0, 'T': 2, 'N': 400, 'f': lambda t: np.cos(3*t)},\n    ]\n\n    results = []\n    for case in test_cases:\n        E_cap, E_naive = run_simulation(case['alpha'], case['u0'], case['T'], case['N'], case['f'])\n        results.append(E_cap)\n        results.append(E_naive)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}