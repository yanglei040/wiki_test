{
    "hands_on_practices": [
        {
            "introduction": "在数值模拟中，精确地表示模型的弯曲边界是一项基本挑战。本练习  将带您实践如何使用高阶“等参”单元来贴合曲线边界，并通过计算雅可比行列式（Jacobian determinant）来评估单元的形状质量，这是确保数值解有效性和准确性的关键一步。",
            "id": "3380293",
            "problem": "考虑一个用于离散化区域边界以数值求解偏微分方程 (PDE) 的单个弯曲六节点 ($6$-node) 等参三角单元。参考单元是 $(\\xi,\\eta)$ 平面中的单位直角三角形，其顶点位于 $(0,0)$、$(1,0)$ 和 $(0,1)$。从参考三角形到物理三角形的等参映射 $\\mathbf{x}(\\xi,\\eta)$ 使用与三个顶点和三个边中点节点相关联的标准二次三角形状函数。\n\n你需要构造一个二次等参映射，其中对应于节点 $1$ 和 $2$ 之间参考边的物理边插值出一条圆弧。该圆形边界的半径为 $R0$，并以原点为中心。该弯曲边的两个端点（节点 $1$ 和 $2$）的物理坐标在圆上选取，其极角分别为 $-\\theta$ 和 $+\\theta$，其中 $0\\theta\\pi$。这条边上的边中点节点（节点 $4$）被放置在极角为 $0$ 的位置。因此，弯曲边上的三个物理点是\n- 节点 $1$：$(R\\cos\\theta,\\,-R\\sin\\theta)$，\n- 节点 $4$：$(R,\\,0)$，\n- 节点 $2$：$(R\\cos\\theta,\\,R\\sin\\theta)$。\n对于剩下的三个节点（弯曲边对面的节点 $3$ 以及直边上的边中点节点 $5$ 和 $6$），放置它们以使得单元的另外两条边是直线段；为确定起见，将节点 $3$ 置于 $(0,0)$，并分别将节点 $5$ 和 $6$ 置于连接节点 $2$ 与节点 $3$ 以及节点 $3$ 与节点 $1$ 的直线段的中点。\n\n从重心坐标和六节点二次三角形状函数的定义出发，构造等参映射 $\\mathbf{x}(\\xi,\\eta)$，通过将第三个重心坐标设为零将其限制在弯曲边上，并用一个从节点 $1$ 运行到节点 $2$ 的标量参数 $t\\in[0,1]$ 来参数化这条边。\n\n使用此构造，推导沿弯曲边的一维雅可比行列式，定义为边度量因子 $J_{e}(t)=\\left\\|\\dfrac{\\partial \\mathbf{x}}{\\partial t}\\right\\|$，并将其表示为关于 $R$、$\\theta$ 和 $t$ 的闭式解析表达式。你的最终答案必须是 $J_{e}(t)$ 的单个闭式表达式。不要提供不等式或需要求解的方程；请提供显式表达式。不需要进行数值四舍五入。",
            "solution": "问题需要进行验证。\n\n### 步骤 1：提取已知条件\n- **单元类型**：单个弯曲六节点 ($6$-node) 等参三角单元。\n- **参考单元**：$(\\xi,\\eta)$ 平面中的单位直角三角形，其顶点位于 $(0,0)$、$(1,0)$ 和 $(0,1)$。\n- **映射**：等参映射，使用标准二次三角形状函数。\n- **弯曲边**：对应于节点 $1$ 和 $2$ 之间参考边的物理边插值出一条以原点为中心的半径为 $R0$ 的圆弧。\n- **弯曲边上的物理坐标**：\n    - 节点 $1$：$\\mathbf{x}_1 = (R\\cos\\theta, -R\\sin\\theta)$。\n    - 节点 $4$ (边中点节点)：$\\mathbf{x}_4 = (R, 0)$。\n    - 节点 $2$：$\\mathbf{x}_2 = (R\\cos\\theta, R\\sin\\theta)$。\n- **角度约束**：$0  \\theta  \\pi$。\n- **其他节点的物理坐标**：\n    - 节点 $3$：$\\mathbf{x}_3 = (0, 0)$。\n    - 节点 $5$ (2-3 边的中点)：$\\mathbf{x}_5 = \\frac{1}{2}(\\mathbf{x}_2 + \\mathbf{x}_3)$。\n    - 节点 $6$ (3-1 边的中点)：$\\mathbf{x}_6 = \\frac{1}{2}(\\mathbfx_3 + \\mathbf{x}_1)$。\n    这些放置确保了另外两条边是直的。\n- **任务**：\n    1. 构造等参映射 $\\mathbf{x}(\\xi,\\eta)$。\n    2. 将其限制在弯曲边上。\n    3. 用参数 $t \\in [0,1]$ 将该边从节点 $1$ 参数化到节点 $2$。\n    4. 推导一维雅可比行列式（边度量因子）$J_{e}(t) = \\left\\|\\frac{\\partial \\mathbf{x}}{\\partial t}\\right\\|$，作为关于 $R$、$\\theta$ 和 $t$ 的闭式表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题是有限元方法 (FEM) 在离散化带弯曲边界的区域时的标准应用。等参映射、形状函数和雅可比行列式的概念是偏微分方程数值分析的基础。\n- **良态性**：问题是完全指定的。参考单元和物理单元的几何形状、插值类型以及所有节点的坐标都已直接或作为其他已知条件的函数给出。这足以唯一确定参数映射及其导数。\n- **客观性**：问题以精确的数学语言陈述，没有主观或模糊的术语。\n- **缺陷检查表**：问题不违反任何无效性标准。它是科学合理的、可形式化的、完整的、一致的、现实的和良态的。这是一个非平凡的推导，是计算力学和有限元方法的核心。\n\n### 步骤 3：结论和行动\n问题是 **有效的**。将推导解答。\n\n### 解答推导\n解答过程首先定义形状函数，然后构造等参映射，对指定边进行参数化，最后推导雅可比行列式。\n\n6 节点三角形的标准节点编号将顶点置于节点 $1, 2, 3$，边中点节点置于 $4$（1-2 边）、$5$（2-3 边）和 $6$（3-1 边）。我们将这些节点与参考 $(\\xi, \\eta)$ 平面中的点相关联。我们采用一个通用约定，即使用重心坐标 $L_1, L_2, L_3$，对于顶点在 $(0,0)$, $(1,0)$ 和 $(0,1)$ 的参考三角形，这些坐标与 $(\\xi, \\eta)$ 相关。我们将节点 $3$ 映射到 $(\\xi, \\eta)=(0,0)$，节点 $1$ 映射到 $(\\xi, \\eta)=(1,0)$，节点 $2$ 映射到 $(\\xi, \\eta)=(0,1)$。\n那么重心坐标为 $L_1 = \\xi$，$L_2 = \\eta$ 和 $L_3 = 1-\\xi-\\eta$。\n重心坐标空间中的节点坐标是：\n- 节点 $1$：$(L_1, L_2, L_3) = (1,0,0)$\n- 节点 $2$：$(L_1, L_2, L_3) = (0,1,0)$\n- 节点 $3$：$(L_1, L_2, L_3) = (0,0,1)$\n- 节点 $4$ (1-2 的中点)：$(1/2, 1/2, 0)$\n- 节点 $5$ (2-3 的中点)：$(0, 1/2, 1/2)$\n- 节点 $6$ (3-1 的中点)：$(1/2, 0, 1/2)$\n\n以重心坐标表示的二次形状函数 $N_i$ 是：\n- 顶点节点 $(i=1, 2, 3)$：$N_i = L_i(2L_i - 1)$\n- 边中点节点：$N_4 = 4L_1L_2$，$N_5 = 4L_2L_3$，$N_6 = 4L_3L_1$\n\n等参映射由 $\\mathbf{x}(\\xi, \\eta) = \\sum_{i=1}^6 N_i(L_1, L_2, L_3) \\mathbf{x}_i$ 给出。我们关心的是连接节点 $1$ 和 $2$ 的边。这条边由 $L_3=0$ 定义，这意味着 $1-\\xi-\\eta=0$，即 $\\eta=1-\\xi$。\n在这条边上，唯一非零的形状函数是 $N_1$、$N_2$ 和 $N_4$：\n- $N_1 = L_1(2L_1-1) = \\xi(2\\xi-1)$\n- $N_2 = L_2(2L_2-1) = \\eta(2\\eta-1) = (1-\\xi)(2(1-\\xi)-1) = (1-\\xi)(1-2\\xi)$\n- $N_4 = 4L_1L_2 = 4\\xi\\eta = 4\\xi(1-\\xi)$\n所有其他形状函数（$N_3, N_5, N_6$）都为零，因为它们包含因子 $L_3$。\n这条边上的映射是 $\\mathbf{x}(\\xi) = N_1(\\xi)\\mathbf{x}_1 + N_2(\\xi)\\mathbf{x}_2 + N_4(\\xi)\\mathbf{x}_4$。\n\n我们需要用一个从节点 $1$ 运行到节点 $2$ 的参数 $t \\in [0,1]$ 来参数化这条边。\n在节点 $1$ 处，$(L_1,L_2,L_3)=(1,0,0)$，所以 $\\xi = 1$。\n在节点 $2$ 处，$(L_1,L_2,L_3)=(0,1,0)$，所以 $\\xi = 0$。\n当我们从节点 $1$ 移动到节点 $2$ 时，参数 $\\xi$ 从 $1$ 变为 $0$。我们选择变换 $t = 1-\\xi$，所以 $\\xi = 1-t$。\n当 $\\xi$ 从 $1$ 变为 $0$ 时，$t$ 从 $0$ 变为 $1$。\n将 $\\xi = 1-t$ 代入形状函数：\n- $L_1 = \\xi = 1-t$\n- $L_2 = \\eta = 1-\\xi = t$\n- $N_1(t) = (1-t)(2(1-t)-1) = (1-t)(1-2t)$\n- $N_2(t) = t(2t-1)$\n- $N_4(t) = 4(1-t)t$\n\n现在该边由 $t$ 参数化：\n$\\mathbf{x}(t) = N_1(t)\\mathbf{x}_1 + N_2(t)\\mathbf{x}_2 + N_4(t)\\mathbf{x}_4$\n$\\mathbf{x}(t) = (1-t)(1-2t)\\mathbf{x}_1 + t(2t-1)\\mathbf{x}_2 + 4t(1-t)\\mathbf{x}_4$\n\n为了求雅可比行列式 $J_e(t)$，我们首先计算切向量 $\\frac{\\partial\\mathbf{x}}{\\partial t}$：\n$\\frac{\\partial\\mathbf{x}}{\\partial t} = \\frac{\\partial N_1}{\\partial t}\\mathbf{x}_1 + \\frac{\\partial N_2}{\\partial t}\\mathbf{x}_2 + \\frac{\\partial N_4}{\\partial t}\\mathbf{x}_4$\n形状函数关于 $t$ 的导数是：\n- $\\frac{\\partial N_1}{\\partial t} = \\frac{\\partial}{\\partial t}(1 - 3t + 2t^2) = 4t-3$\n- $\\frac{\\partial N_2}{\\partial t} = \\frac{\\partial}{\\partial t}(2t^2 - t) = 4t-1$\n- $\\frac{\\partial N_4}{\\partial t} = \\frac{\\partial}{\\partial t}(4t - 4t^2) = 4-8t$\n\n所以，切向量是：\n$\\frac{\\partial\\mathbf{x}}{\\partial t} = (4t-3)\\mathbf{x}_1 + (4t-1)\\mathbf{x}_2 + (4-8t)\\mathbf{x}_4$\n\n现在我们代入物理坐标 $\\mathbf{x}_1 = (R\\cos\\theta, -R\\sin\\theta)$、$\\mathbf{x}_2 = (R\\cos\\theta, R\\sin\\theta)$ 和 $\\mathbf{x}_4 = (R, 0)$。令 $\\frac{\\partial\\mathbf{x}}{\\partial t} = (x'(t), y'(t))$。\n$x$ 分量是：\n$x'(t) = (4t-3)(R\\cos\\theta) + (4t-1)(R\\cos\\theta) + (4-8t)(R)$\n$x'(t) = R [ (4t-3+4t-1)\\cos\\theta + (4-8t) ]$\n$x'(t) = R [ (8t-4)\\cos\\theta - (8t-4) ]$\n$x'(t) = R(8t-4)(\\cos\\theta-1) = 4R(2t-1)(\\cos\\theta-1)$\n\n$y$ 分量是：\n$y'(t) = (4t-3)(-R\\sin\\theta) + (4t-1)(R\\sin\\theta) + (4-8t)(0)$\n$y'(t) = R\\sin\\theta [ -(4t-3) + (4t-1) ]$\n$y'(t) = R\\sin\\theta [ -4t+3+4t-1 ] = 2R\\sin\\theta$\n\n雅可比行列式是该切向量的模：\n$J_e(t) = \\left\\| \\frac{\\partial\\mathbf{x}}{\\partial t} \\right\\| = \\sqrt{(x'(t))^2 + (y'(t))^2}$\n$J_e(t)^2 = [4R(2t-1)(\\cos\\theta-1)]^2 + [2R\\sin\\theta]^2$\n$J_e(t)^2 = 16R^2(2t-1)^2(\\cos\\theta-1)^2 + 4R^2\\sin^2\\theta$\n\n为简化，我们使用半角恒等式：\n$\\cos\\theta-1 = -2\\sin^2\\left(\\frac{\\theta}{2}\\right)$\n$\\sin\\theta = 2\\sin\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)$\n\n将这些代入 $J_e(t)^2$ 的表达式中：\n$J_e(t)^2 = 16R^2(2t-1)^2 \\left(-2\\sin^2\\left(\\frac{\\theta}{2}\\right)\\right)^2 + 4R^2 \\left(2\\sin\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\right)^2$\n$J_e(t)^2 = 16R^2(2t-1)^2 \\left(4\\sin^4\\left(\\frac{\\theta}{2}\\right)\\right) + 4R^2 \\left(4\\sin^2\\left(\\frac{\\theta}{2}\\right)\\cos^2\\left(\\frac{\\theta}{2}\\right)\\right)$\n$J_e(t)^2 = 64R^2(2t-1)^2\\sin^4\\left(\\frac{\\theta}{2}\\right) + 16R^2\\sin^2\\left(\\frac{\\theta}{2}\\right)\\cos^2\\left(\\frac{\\theta}{2}\\right)$\n\n提出公因式 $16R^2\\sin^2\\left(\\frac{\\theta}{2}\\right)$：\n$J_e(t)^2 = 16R^2\\sin^2\\left(\\frac{\\theta}{2}\\right) \\left[ 4(2t-1)^2\\sin^2\\left(\\frac{\\theta}{2}\\right) + \\cos^2\\left(\\frac{\\theta}{2}\\right) \\right]$\n\n取平方根求 $J_e(t)$：\n$J_e(t) = \\sqrt{16R^2\\sin^2\\left(\\frac{\\theta}{2}\\right)} \\sqrt{4(2t-1)^2\\sin^2\\left(\\frac{\\theta}{2}\\right) + \\cos^2\\left(\\frac{\\theta}{2}\\right)}$\n由于 $R0$ 且 $0\\theta\\pi$，我们有 $0\\frac{\\theta}{2}\\frac{\\pi}{2}$，这意味着 $\\sin\\left(\\frac{\\theta}{2}\\right)0$。\n$J_e(t) = 4R\\sin\\left(\\frac{\\theta}{2}\\right) \\sqrt{4(2t-1)^2\\sin^2\\left(\\frac{\\theta}{2}\\right) + \\cos^2\\left(\\frac{\\theta}{2}\\right)}$\n\n这是沿弯曲边的雅可比行列式的最终闭式表达式。",
            "answer": "$$ \\boxed{4R\\sin\\left(\\frac{\\theta}{2}\\right) \\sqrt{4(2t-1)^2\\sin^2\\left(\\frac{\\theta}{2}\\right) + \\cos^2\\left(\\frac{\\theta}{2}\\right)}} $$"
        },
        {
            "introduction": "许多物理问题的解具有随时间演化的局部特征，例如激波或移动界面，静态网格对此往往效率低下。本练习  将指导您实现一个基于“任意拉格朗日-欧拉”（ALE）方法的动态自适应网格。您将通过编写代码，让网格“追随”解的梯度，从而在最需要的地方自动加密，这是一种强大且高效的数值求解策略。",
            "id": "3380280",
            "problem": "考虑一维空间中的任意拉格朗日-欧拉（ALE）方法，其中计算坐标 $\\xi \\in [0,1]$ 通过一个依赖于时间的严格递增映射，映射到物理坐标 $x(\\xi,t) \\in [0,1]$。网格根据网格偏微分方程（PDE）进行演化\n$$\n\\partial_t x(\\xi,t) \\;=\\; \\partial_\\xi\\big(m(x(\\xi,t),t)\\,\\partial_\\xi x(\\xi,t)\\big),\n$$\n其狄利克雷边界条件为 $x(0,t)=0$ 和 $x(1,t)=1$，初始条件为 $x(\\xi,0)=\\xi$。监控函数由下式给出\n$$\nm(x,t) \\;=\\; \\left|\\partial_x u(x,t)\\right|,\n$$\n其中 $u(x,t)$ 是物理域上的一个标量场。目标是构建并分析一个移动网格，该网格在陡峭梯度（类激波特征）附近集中节点，同时保持网格质量。\n\n其基本原理是自适应网格的等分布原则，该原则指出，理想网格会使监控函数加权的单元尺寸等分布，即 $m(x,t)\\,\\partial_\\xi x(\\xi,t)$ 在 $\\xi$ 空间上是常数。上述网格偏微分方程在固定边界位置的约束下，充当了趋向等分布的松弛流。\n\n您必须在一个均匀计算网格 $\\xi_i = i\\,\\Delta\\xi$（其中 $i=0,\\ldots,N-1$，$ \\Delta\\xi = 1/(N-1)$）上，以通量形式离散化该网格偏微分方程，使用一阶显式时间积分和二阶中心空间差分。在每个时间步，定义半整数索引通量\n$$\nF_{i+\\frac{1}{2}}(t) \\;=\\; m\\big(x_{i+\\frac{1}{2}}(t),t\\big)\\,\\frac{x_{i+1}(t)-x_i(t)}{\\Delta\\xi},\n$$\n其中 $x_{i+\\frac{1}{2}}(t) = \\frac{1}{2}\\big(x_i(t)+x_{i+1}(t)\\big)$，并通过下式推进内部节点\n$$\n\\partial_t x_i(t) \\;=\\; \\frac{F_{i+\\frac{1}{2}}(t) - F_{i-\\frac{1}{2}}(t)}{\\Delta\\xi}, \\quad i=1,\\ldots,N-2.\n$$\n为确保显式格式的数值稳定性，选择满足以下条件的时间步长 $\\Delta t$\n$$\n\\Delta t \\;\\le\\; \\alpha\\,\\frac{\\Delta\\xi^2}{\\max_{i} m\\big(x_{i+\\frac{1}{2}}(t),t\\big)},\n$$\n其中 $\\alpha \\in (0,1/2)$ 是一个指定值。\n\n对于激波追踪分析，考虑 $u(x,t)$ 的三种解析选择以及相应的监控函数 $m(x,t)$：\n- 一个由下式定义的光滑激波剖面\n$$\nu(x,t) \\;=\\; \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_c(t)}{\\varepsilon}\\right)\\right), \\quad x_c(t) = x_0 + s\\,t,\n$$\n其导数为\n$$\n\\partial_x u(x,t) \\;=\\; \\frac{1}{2\\,\\varepsilon}\\,\\operatorname{sech}^2\\!\\left(\\frac{x - x_c(t)}{\\varepsilon}\\right),\n$$\n其中 $\\operatorname{sech}(z)=1/\\cosh(z)$。\n- 一个邻近边界的光滑激波，使用相同的形式，但中心 $x_c(t)$ 靠近 $0$。\n- 一个线性剖面 $u(x,t)=x$，其导数为常数 $\\partial_x u(x,t)=1$。\n\n为避免退化并保持监控函数的正性，使用一个正则化的监控函数\n$$\nm_\\delta(x,t) \\;=\\; \\sqrt{\\big(\\partial_x u(x,t)\\big)^2 + \\delta^2},\n$$\n其中 $\\delta0$ 是一个小的固定值。\n\n定义以下在最终时刻 $t=T$ 评估的网格质量度量：\n- 聚集比 $C$，用于衡量对激波的加密程度，\n$$\nC \\;=\\; \\frac{\\overline{h}_{\\text{in}}}{\\overline{h}_{\\text{out}}},\n$$\n其中 $h_i = x_{i+1}(T) - x_i(T)$ 是物理单元尺寸，$\\overline{h}_{\\text{in}}$ 是其单元中点 $x_{i+\\frac{1}{2}}(T)$ 位于指定区间内的 $h_i$ 的平均值，$\\overline{h}_{\\text{out}}$ 是该区间外的平均值。对于激波类型的情况，使用区间 $[x_c(T) - 3\\varepsilon,\\, x_c(T) + 3\\varepsilon]$ 并截断至 $[0,1]$ 范围内。对于线性情况，使用区间 $[0.4,\\,0.6]$。\n- 正性布尔值 $J$，指示网格是否发生缠结，\n$$\nJ \\;=\\; \\text{如果对所有 } i \\text{ 都有 } h_i  0 \\text{ 则为 True，否则为 False}。\n$$\n- 等分布残差 $E$，定义为通量与其空间平均值的相对 $L^\\infty$ 偏差，\n$$\nE \\;=\\; \\frac{\\max_{i}\\left|F_{i+\\frac{1}{2}}(T) - \\overline{F}(T)\\right|}{\\overline{F}(T)}, \\quad \\overline{F}(T) \\;=\\; \\frac{1}{N-1}\\sum_{i=0}^{N-2} F_{i+\\frac{1}{2}}(T).\n$$\n\n您的程序必须实现网格偏微分方程的离散化，为每个测试用例将网格推进到指定的最终时刻，并报告度量指标 $C$、$J$ 和 $E$。\n\n不涉及物理单位；所有量均为无量纲。不涉及角度。\n\n测试套件：\n- 案例 1（光滑内部激波）：$N=51$, $T=0.05$, $x_0=0.30$, $s=0.60$, $\\varepsilon=0.05$, $\\delta=10^{-8}$, $\\alpha=0.40$。\n- 案例 2（邻近边界的激波）：$N=51$, $T=0.05$, $x_0=0.02$, $s=0.00$, $\\varepsilon=0.03$, $\\delta=10^{-8}$, $\\alpha=0.40$。\n- 案例 3（通过线性 $u$ 得到的常数监控函数）：$N=51$, $T=0.05$, $u(x,t)=x$ 因此 $\\partial_x u=1$, $\\delta=10^{-8}$, $\\alpha=0.40$。\n\n答案规格与最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例按顺序贡献一个子列表 $[C,J,E]$。例如，\n$$\n\\text{[}[C_1,J_1,E_1],[C_2,J_2,E_2],[C_3,J_3,E_3]\\text{]}.\n$$\n每个 $C$ 和 $E$ 必须是浮点数，每个 $J$ 必须是布尔值。",
            "solution": "该问题陈述经过了严格验证，并被确定为有效。它在科学上基于偏微分方程数值分析的原理，特别是用于自适应网格生成的任意拉格朗日-欧拉（ALE）方法。该问题是适定的，提供了所有必要的条件、参数和定义。其语言客观且无歧义。它代表了科学计算中一个非平凡但标准的计算任务。\n\n问题的核心是求解一维移动网格偏微分方程：\n$$\n\\partial_t x(\\xi,t) \\;=\\; \\partial_\\xi\\big(m(x(\\xi,t),t)\\,\\partial_\\xi x(\\xi,t)\\big)\n$$\n以获得作为计算坐标 $\\xi \\in [0,1]$ 和时间 $t$ 的函数的物理节点位置 $x(\\xi,t)$。边界条件固定为 $x(0,t)=0$ 和 $x(1,t)=1$，初始网格为均匀网格 $x(\\xi,0)=\\xi$。监控函数 $m(x,t)$ 的作用是驱动网格点向其值较大的区域移动，从而在这些区域加密网格。\n\n数值解是通过离散化定义域和偏微分方程来构建的。计算域 $[0,1]$ 被离散化为一个包含 $N$ 个点的均匀网格，$\\xi_i = i\\,\\Delta\\xi$，$i=0, \\ldots, N-1$，其中网格间距为 $\\Delta\\xi = 1/(N-1)$。令 $x_i(t)$ 为 $x(\\xi_i, t)$ 的近似值。该偏微分方程在空间上使用二阶保守有限差分格式进行离散化。节点 $i$ 和 $i+1$ 之间中点处的通量定义为：\n$$\nF_{i+\\frac{1}{2}}(t) \\;=\\; m\\big(x_{i+\\frac{1}{2}}(t),t\\big)\\,\\frac{x_{i+1}(t)-x_i(t)}{\\Delta\\xi}\n$$\n其中 $x_{i+\\frac{1}{2}}(t) = \\frac{1}{2}(x_i(t)+x_{i+1}(t))$ 是物理中点位置。内部节点（$i=1, \\ldots, N-2$）的半离散方程则为：\n$$\n\\frac{d x_i}{dt} \\;=\\; \\frac{F_{i+\\frac{1}{2}}(t) - F_{i-\\frac{1}{2}}(t)}{\\Delta\\xi}\n$$\n边界节点 $x_0(t)=0$ 和 $x_{N-1}(t)=1$ 保持静止。\n\n对于时间积分，采用一阶显式欧拉方法。从时间步 $n$ 到 $n+1$ 更新内部节点位置的规则是：\n$$\nx_i^{n+1} = x_i^n + \\Delta t \\cdot \\frac{F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n}{\\Delta\\xi}\n$$\n对于这个抛物型网格方程，显式格式的稳定性要求对时间步长 $\\Delta t$ 有一个约束。问题提供了标准的类 Courant-Friedrichs-Lewy (CFL) 条件：\n$$\n\\Delta t \\;\\le\\; \\alpha\\,\\frac{\\Delta\\xi^2}{\\max_{i} m(x_{i+\\frac{1}{2}},t)}\n$$\n其中安全因子 $\\alpha \\in (0, 1/2)$。由于 $\\max(m)$ 在每个时间步都可能改变，因此 $\\Delta t$ 是自适应的。模拟从 $t=0$ 进行到 $t=T$，通过采取连续的时间步，在每一步调整 $\\Delta t$ 以满足稳定性准则，并确保最后一步恰好到达 $T$。\n\n监控函数基于标量场 $u(x,t)$ 的梯度，并经过正则化以防止退化：$m_\\delta(x,t) = \\sqrt{(\\partial_x u)^2 + \\delta^2}$。问题指定了 $u(x,t)$ 的三种情况：两种涉及 $\\tanh$ 剖面以模拟激波，一种是线性剖面（$u(x,t)=x$），它导致一个常数监控函数 $m_\\delta = \\sqrt{1+\\delta^2}$。对于双曲正切情况，$u(x,t) = \\frac{1}{2}(1 + \\tanh((x - x_c(t))/\\varepsilon))$，其导数为 $\\partial_x u(x,t) = \\frac{1}{2\\varepsilon}\\operatorname{sech}^2((x - x_c(t))/\\varepsilon)$。\n\n在将网格推进到最终时刻 $t=T$ 后，计算三个质量度量：\n1. 正性布尔值 $J$，检查网格是否发生缠结。如果所有单元尺寸 $h_i(T) = x_{i+1}(T) - x_i(T)$ 都为正，则为真。\n2. 等分布残差 $E$，测量网格与理想等分布状态（即量 $m\\,\\partial_\\xi x$ 为常数）的接近程度。这通过最终通量与其平均值偏差的相对 $L^\\infty$ 范数量化：\n$$\nE \\;=\\; \\frac{\\max_{i}\\left|F_{i+\\frac{1}{2}}(T) - \\overline{F}(T)\\right|}{\\overline{F}(T)}\n$$\n对于线性 $u(x,t)=x$ 的情况，初始均匀网格已经是稳态解，所以我们预期网格将保持静止，且 $E$ 接近于零。\n3. 聚集比 $C$，量化了特定感兴趣区域内网格加密的程度。它是一个区间内部的平均单元尺寸 $\\overline{h}_{\\text{in}}$ 与区间外部的平均单元尺寸 $\\overline{h}_{\\text{out}}$ 的比率。$C  1$ 的值表示区间内部的单元更小，表明网格聚类成功。这些区间是相对于激波位置定义的，或者对于线性情况是一个固定区间。\n\n实现将包含一个遍历测试用例的主循环。对于每个用例，一个内部的时间步进循环将执行上述算法。最后，将计算并收集这些度量指标。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the moving mesh PDE.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"smooth_interior_shock\",\n            \"N\": 51, \"T\": 0.05, \"x0\": 0.30, \"s\": 0.60,\n            \"eps\": 0.05, \"delta\": 1e-8, \"alpha\": 0.40\n        },\n        {\n            \"name\": \"boundary_adjacent_shock\",\n            \"N\": 51, \"T\": 0.05, \"x0\": 0.02, \"s\": 0.00,\n            \"eps\": 0.03, \"delta\": 1e-8, \"alpha\": 0.40\n        },\n        {\n            \"name\": \"linear_u\",\n            \"N\": 51, \"T\": 0.05, \"x0\": None, \"s\": None,\n            \"eps\": None, \"delta\": 1e-8, \"alpha\": 0.40\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list is [item1, item2, ...], which matches the requirement.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(params):\n    \"\"\"\n    Executes the numerical simulation for a single test case.\n    \"\"\"\n    N = params[\"N\"]\n    T = params[\"T\"]\n    delta = params[\"delta\"]\n    alpha = params[\"alpha\"]\n\n    # Initialize computational grid\n    delta_xi = 1.0 / (N - 1)\n    \n    # Initialize physical grid (initially uniform)\n    x = np.linspace(0.0, 1.0, N)\n    \n    current_t = 0.0\n\n    # Time-stepping loop\n    while current_t  T:\n        # Calculate cell midpoints\n        x_mid = 0.5 * (x[:-1] + x[1:])\n\n        # Calculate monitor function at midpoints\n        if params[\"name\"] == \"linear_u\":\n            du_dx_vals = np.ones_like(x_mid)\n        else:\n            xc = params[\"x0\"] + params[\"s\"] * current_t\n            eps = params[\"eps\"]\n            # sech(z) = 1/cosh(z)\n            arg = (x_mid - xc) / eps\n            sech_vals = 1.0 / np.cosh(arg)\n            du_dx_vals = (1.0 / (2.0 * eps)) * (sech_vals**2)\n        \n        monitor_vals = np.sqrt(du_dx_vals**2 + delta**2)\n\n        # Calculate stable time step\n        max_monitor = np.max(monitor_vals)\n        dt = alpha * delta_xi**2 / max_monitor\n\n        # Ensure we do not step over the final time T\n        if current_t + dt > T:\n            dt = T - current_t\n\n        # Calculate fluxes\n        # h_i / delta_xi\n        h_ratio = (x[1:] - x[:-1]) / delta_xi\n        F = monitor_vals * h_ratio\n\n        # Update interior node positions using Explicit Euler\n        dxdt = (F[1:] - F[:-1]) / delta_xi\n        x[1:-1] += dt * dxdt\n        \n        current_t += dt\n\n    # Final mesh at t=T is now in 'x'\n    # Calculate metrics\n    \n    # Metric J: Positivity\n    h = x[1:] - x[:-1]\n    # Use a small tolerance for floating point comparison\n    J = bool(np.all(h > 1e-15))\n\n    # Metric C: Clustering Ratio\n    x_mid_final = 0.5 * (x[:-1] + x[1:])\n    \n    if params[\"name\"] == \"linear_u\":\n        band = [0.4, 0.6]\n    else:\n        xc_T = params[\"x0\"] + params[\"s\"] * T\n        eps = params[\"eps\"]\n        band_min = max(0.0, xc_T - 3.0 * eps)\n        band_max = min(1.0, xc_T + 3.0 * eps)\n        band = [band_min, band_max]\n        \n    inside_mask = (x_mid_final = band[0])  (x_mid_final = band[1])\n    \n    h_in = h[inside_mask]\n    h_out = h[~inside_mask]\n    \n    # Handle cases where a region might be empty, though unlikely for these params\n    avg_h_in = np.mean(h_in) if len(h_in)  0 else 0.0\n    avg_h_out = np.mean(h_out) if len(h_out)  0 else 1.0 # Avoid division by zero\n    \n    C = avg_h_in / avg_h_out\n\n    # Metric E: Equidistribution Residual\n    # Re-calculate fluxes at the final time T\n    if params[\"name\"] == \"linear_u\":\n        du_dx_final = np.ones_like(x_mid_final)\n    else:\n        xc_T = params[\"x0\"] + params[\"s\"] * T\n        eps = params[\"eps\"]\n        arg_final = (x_mid_final - xc_T) / eps\n        sech_final = 1.0 / np.cosh(arg_final)\n        du_dx_final = (1.0 / (2.0 * eps)) * (sech_final**2)\n        \n    monitor_final = np.sqrt(du_dx_final**2 + delta**2)\n    \n    h_ratio_final = (x[1:] - x[:-1]) / delta_xi\n    F_final = monitor_final * h_ratio_final\n    \n    F_bar = np.mean(F_final)\n    \n    if abs(F_bar)  1e-15:\n        E = np.max(np.abs(F_final - F_bar)) / F_bar\n    else: # Should not happen with regularized monitor\n        E = 0.0\n\n    return [C, J, E]\n\nsolve()\n```"
        },
        {
            "introduction": "在处理由不同材料构成或需要在不同区域采用不同分辨率的复杂域时，生成单一的、协调的（conforming）网格可能极其困难。本练习  介绍了一种先进的区域分解技术——“砂浆法”（Mortar Method）。您将通过编程实践学习如何将两个独立的、不匹配的网格在交界面处耦合起来，同时通过拉格朗日乘子弱形式地保证物理量的连续性，这是解决多物理场和多尺度问题的关键技术。",
            "id": "3380250",
            "problem": "考虑定义在区间 $[0,1]$ 上的一维椭圆界面问题，其中在固定界面位置 $x_0 \\in (0,1)$ 处存在系数跳跃。设扩散系数为分段常数，记为 $a(x) = a_1$（对于 $x \\in [0,x_0]$）和 $a(x) = a_2$（对于 $x \\in [x_0,1]$）。控制偏微分方程 (PDE) 为\n$$\n- \\frac{d}{dx}\\left( a(x)\\,\\frac{du}{dx} \\right) = 0 \\quad \\text{on } (0,1),\n$$\n服从 Dirichlet 边界条件\n$$\nu(0) = 0, \\quad u(1) = 1.\n$$\n在 $x = x_0$ 处需要施加的界面条件是解的连续性和法向通量的连续性，\n$$\nu(x_0^-)=u(x_0^+), \\quad a_1\\,u'(x_0^-)=a_2\\,u'(x_0^+).\n$$\n您必须使用两个不匹配的均匀网格（meshes）来离散化该区域：一个在 $[0,x_0]$ 上的左侧网格，包含 $N_L$ 个单元；另一个在 $[x_0,1]$ 上的右侧网格，包含 $N_R$ 个单元，其中两个网格的内部节点不重合。在每个子区域上使用带有连续分段线性基函数的有限元方法 (FEM)，并引入一个带有单个 Lagrange 乘子的砂浆法 (MM)，以在不匹配的网格间弱形式地施加界面条件。目标是开发并实现离散鞍点格式，该格式通过一个约束来确保解的连续性，并通过 Lagrange 乘子将通量连续性表示为界面上的离散牵引力。\n\n从两个子区域上的弱形式出发，利用变分法和界面牵引力平衡的基本原理，推导耦合两个子区域解（在 $x=0$ 和 $x=1$ 处施加了 Dirichlet 边界条件）和单个界面乘子的离散代数系统。您的实现必须：\n- 针对给定的 Dirichlet 边界条件，为 $- \\frac{d}{dx}\\left( a\\,u' \\right) = 0$ 组装子区域刚度矩阵和载荷向量。\n- 通过 Lagrange 乘子引入界面耦合，该乘子在弱形式中强制实现迹的连续性并代表界面牵引力。\n- 求解得到的鞍点系统，以获得左子区域的节点值、右子区域的节点值以及界面乘子。\n\n定义以下定量诊断指标以分析一致性和通量连续性：\n- 界面处的连续性残差，\n$$\ne_c = \\left| u_L(x_0) - u_R(x_0) \\right|,\n$$\n其中 $u_L(x_0)$ 和 $u_R(x_0)$ 分别是左、右子区域中界面节点处的离散节点值。\n- 界面处的通量连续性残差，\n$$\ne_f = \\left| a_1\\,u_L'(x_0^-) - a_2\\,u_R'(x_0^+) \\right|,\n$$\n其中 $u_L'(x_0^-)$ 是从左侧网格最后一个单元计算出的单边离散导数，而 $u_R'(x_0^+)$ 是从右侧网格第一个单元计算出的单边离散导数。\n- 界面牵引力的相对误差，\n$$\ne_J = \\frac{\\left| \\lambda - J_{\\text{exact}} \\right|}{\\left| J_{\\text{exact}} \\right|},\n$$\n其中 $\\lambda$ 是计算出的 Lagrange 乘子（解释为离散界面牵引力），$J_{\\text{exact}}$ 是针对给定的 PDE、系数、界面位置和 Dirichlet 边界条件解析得到的精确常数通量。\n\n使用以下测试套件，每个套件由元组 $(x_0, a_1, a_2, N_L, N_R)$ 指定：\n- 测试 1（中等对比度和不匹配网格的一般情况）：$(0.3, 1, 2, 20, 35)$。\n- 测试 2（$a_1/a_2 \\gg 1$ 的高对比度情况）：$(0.7, 10^6, 1, 5, 9)$。\n- 测试 3（$a_1/a_2 \\ll 1$ 的高对比度情况）：$(0.4, 10^{-6}, 1, 8, 12)$。\n\n您的程序必须实现推导和计算，然后为每个测试用例评估 $(e_c, e_f, e_J)$。最终输出必须是包含每个测试用例的三元素列表的单行列表，顺序与测试套件中给出的顺序一致。格式必须严格为\n$$\n\\text{[}[e_{c,1},e_{f,1},e_{J,1}],[e_{c,2},e_{f,2},e_{J,2}],[e_{c,3},e_{f,3},e_{J,3}]\\text{]},\n$$\n其中所有条目均为实数。此问题中不需要物理单位。角度单位不适用。百分比必须表示为小数。程序必须是自包含的，无需用户输入，并精确生成指定的单行输出。确保您的设计在 $a_1/a_2 \\gg 1$ 的情况下测试解的一致性、通量连续性和鲁棒性。",
            "solution": "用户提供了一个问题，要求使用有限元方法 (FEM) 和不匹配网格来数值求解一个一维椭圆界面问题，并通过带有单个 Lagrange 乘子的砂浆法进行耦合。\n\n### 步骤 1：提取已知条件\n- **PDE**: $- \\frac{d}{dx}\\left( a(x)\\,\\frac{du}{dx} \\right) = 0$ 在区域 $\\Omega = (0,1)$ 上。\n- **系数**: $a(x)$ 是分段常数：$a(x) = a_1$ 对于 $x \\in [0,x_0]$，$a(x) = a_2$ 对于 $x \\in [x_0,1]$，其中 $x_0 \\in (0,1)$ 是界面位置。\n- **边界条件 (BCs)**: $u(0) = 0$ 和 $u(1) = 1$。\n- **界面条件**: 在 $x=x_0$ 处，解 $u(x)$ 和通量 $a(x)u'(x)$ 是连续的。\n  - $u(x_0^-) = u(x_0^+)$ (解的连续性)\n  - $a_1 u'(x_0^-) = a_2 u_R'(x_0^+)$ (通量/牵引力的连续性)\n- **离散化**: 区域被分解为 $\\Omega_L = [0, x_0]$ 和 $\\Omega_R = [x_0, 1]$。\n  - $\\Omega_L$ 用一个包含 $N_L$ 个单元的均匀网格进行划分。\n  - $\\Omega_R$ 用一个包含 $N_R$ 个单元的均匀网格进行划分。\n- **数值方法**:\n  - 在每个子区域上使用带有连续分段线性基函数的有限元方法。\n  - 使用单个 Lagrange 乘子 $\\lambda$ 来弱形式施加界面条件，从而得到一个鞍点系统。\n- **诊断指标**:\n  - 连续性残差: $e_c = | u_L(x_0) - u_R(x_0) |$。\n  - 通量连续性残差: $e_f = | a_1 u_L'(x_0^-) - a_2 u_R'(x_0^+) |$。\n  - 界面牵引力的相对误差: $e_J = \\frac{| \\lambda - J_{\\text{exact}} |}{| J_{\\text{exact}} |}$，其中 $\\lambda$ 是 Lagrange 乘子，而 $J_{\\text{exact}}$ 是精确的解析通量。\n- **测试套件**: $(x_0, a_1, a_2, N_L, N_R)$ 的元组。\n  - 测试 1: $(0.3, 1, 2, 20, 35)$\n  - 测试 2: $(0.7, 10^6, 1, 5, 9)$\n  - 测试 3: $(0.4, 10^{-6}, 1, 8, 12)$\n\n### 步骤 2：使用提取的已知条件进行验证\n所给问题是偏微分方程数值方法领域一个成熟且标准的练习，特别涉及区域分解和不匹配网格耦合。\n\n- **科学依据（关键）**: 该问题基于椭圆偏微分方程和有限元方法的基本原理。使用 Lagrange 乘子施加约束是变分法和数值分析中的标准技术。\n- **适定的**: 连续问题是适定的，存在唯一解。使用鞍点系统的离散格式对于此类问题也是适定的和标准的。\n- **目标明确（关键）**: 该问题使用精确的数学语言陈述，定义和目标清晰。\n\n问题陈述是自包含、一致的，并且不违反任何无效标准。这是一个与指定主题相关的可形式化的科学问题。\n\n### 步骤 3：结论与行动\n该问题有效。将提供一个完整、合理的解答。\n\n### 基于原理的设计：推导与离散化\n\n求解方法是将问题表述为弱变分形式，使用有限元对其进行离散化，并求解得到的代数系统。\n\n**1. 带 Lagrange 乘子的弱形式**\n\n我们将问题分解为两个子区域，$\\Omega_L = (0, x_0)$ 和 $\\Omega_R = (x_0, 1)$。通过将 PDE 乘以一个测试函数 $v(x)$ 并在每个子区域上积分来推导弱形式。\n\n对于 $\\Omega_L$，设 $v_L$ 是一个满足 $v_L(0)=0$ 的测试函数：\n$$ -\\int_0^{x_0} \\frac{d}{dx}\\left( a_1 \\frac{du_L}{dx} \\right) v_L dx = 0 $$\n分部积分得到：\n$$ \\int_0^{x_0} a_1 \\frac{du_L}{dx} \\frac{dv_L}{dx} dx - \\left[ a_1 \\frac{du_L}{dx} v_L \\right]_0^{x_0} = 0 $$\n$$ \\int_0^{x_0} a_1 u_L' v_L' dx = a_1 u_L'(x_0^-) v_L(x_0) $$\n类似地，对于 $\\Omega_R$，使用满足 $v_R(1)=0$ 的测试函数 $v_R$：\n$$ \\int_{x_0}^1 a_2 u_R' v_R' dx = -a_2 u_R'(x_0^+) v_R(x_0) $$\n\n我们引入一个 Lagrange 乘子 $\\lambda$ 来表示界面牵引力（通量）。我们将牵引力定义为 $T(x) = a(x) u'(x)$。界面条件为 $u_L(x_0)=u_R(x_0)$ 和 $T_L(x_0) = T_R(x_0)$。设 $\\lambda$ 近似这个共同的牵引力值。弱形式变为：求 $u_L, u_R, \\lambda$ 使得\n$$ \\int_0^{x_0} a_1 u_L' v_L' dx = \\lambda v_L(x_0) \\quad \\forall v_L \\in H^1_0(0, x_0) $$\n$$ \\int_{x_0}^1 a_2 u_R' v_R' dx = -\\lambda v_R(x_0) \\quad \\forall v_R \\text{ with } v_R(1)=0 $$\n$$ u_L(x_0) = u_R(x_0) $$\n第二个方程使用 $-\\lambda$ 是因为在 $x_0$ 处，$\\Omega_R$ 的法向量指向 $-x$ 方向。这个公式正确地施加了 $a_1 u_L'(x_0^-) = a_2 u_R'(x_0^+) = \\lambda$。\n\n**2. 有限元离散化**\n\n我们用 $N_L$ 个尺寸为 $h_L = x_0/N_L$ 的线性元离散化 $\\Omega_L$，用 $N_R$ 个尺寸为 $h_R = (1-x_0)/N_R$ 的线性元离散化 $\\Omega_R$。每个子区域上的解由一系列分段线性基（帽）函数 $\\phi_i(x)$ 近似：\n- $u_L(x) \\approx \\sum_{j=0}^{N_L} U_{L,j} \\phi_{L,j}(x)$，其中 $U_{L,0}=0$。未知量为 $\\mathbf{U}_L = [U_{L,1}, \\dots, U_{L,N_L}]^T$。\n- $u_R(x) \\approx \\sum_{j=0}^{N_R} U_{R,j} \\phi_{R,j}(x)$，其中 $U_{R,N_R}=1$。未知量为 $\\mathbf{U}_R = [U_{R,0}, \\dots, U_{R,N_R-1}]^T$。\n\n将这些代入弱形式并选择基函数作为测试函数，会得到一个分块矩阵系统。对于尺寸为 $h$、系数为 $a$ 的单元，其单元刚度矩阵为 $k^e = \\frac{a}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。为每个子区域组装这些单元矩阵，并考虑边界条件，得到子区域刚度矩阵 $A_L$（$N_L \\times N_L$）和 $A_R$（$N_R \\times N_R$）。\n\n离散系统是关于未知向量 $\\mathbf{U}_L$、$\\mathbf{U}_R$ 和标量乘子 $\\lambda$ 的鞍点问题：\n$$\n\\begin{pmatrix}\nA_L  \\mathbf{0}  -B_L \\\\\n\\mathbf{0}  A_R  B_R \\\\\nB_L^T  -B_R^T  0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{U}_L \\\\\n\\mathbf{U}_R \\\\\n\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{0} \\\\\n\\mathbf{F}_{BC} \\\\\n0\n\\end{pmatrix}\n$$\n- $A_L$ 是在 $\\Omega_L$ 上的 $N_L \\times N_L$ 刚度矩阵，已施加在 $x=0$ 处的 Dirichlet 边界条件。\n- $A_R$ 是在 $\\Omega_R$ 上的 $N_R \\times N_R$ 刚度矩阵，目前假设为齐次边界条件。\n- $B_L = [0, \\dots, 0, 1]^T$ 是一个 $N_L \\times 1$ 的向量，它从 $\\mathbf{U}_L$ 中拾取界面节点 $x_0$ 处的值。\n- $B_R = [1, 0, \\dots, 0]^T$ 是一个 $N_R \\times 1$ 的向量，它从 $\\mathbf{U}_R$ 中拾取界面节点 $x_0$ 处的值。\n- $\\mathbf{F}_{BC}$ 是处理非齐次边界条件 $u(1)=1$ 的向量。从组装过程可知，$\\mathbf{F}_{BC} = [0, \\dots, 0, a_2/h_R]^T$。\n\n第一个分块行 $A_L \\mathbf{U}_L - \\lambda B_L = \\mathbf{0}$ 施加了 $\\lambda = a_1 u_L'(x_0^-)$ 在界面处。\n第二个分块行 $A_R \\mathbf{U}_R + \\lambda B_R = \\mathbf{F}_{BC}$ 施加了 $\\lambda = a_2 u_R'(x_0^+)$ 在界面处。\n第三个分块行 $B_L^T \\mathbf{U}_L - B_R^T \\mathbf{U}_R = 0$ 施加了连续性 $U_{L,N_L} = U_{R,0}$。\n\n**3. 解析解与诊断指标**\n\nPDE 意味着牵引力 $T(x) = a(x)u'(x)$ 是一个常数。设此常数为 $J_{\\text{exact}}$。\n$$ u'(x) = \\frac{J_{\\text{exact}}}{a(x)} $$\n从 $x=0$ 到 $x=1$ 积分：\n$$ u(1) - u(0) = \\int_0^1 \\frac{J_{\\text{exact}}}{a(x)} dx = J_{\\text{exact}} \\left( \\int_0^{x_0} \\frac{1}{a_1} dx + \\int_{x_0}^1 \\frac{1}{a_2} dx \\right) $$\n$$ 1 - 0 = J_{\\text{exact}} \\left( \\frac{x_0}{a_1} + \\frac{1-x_0}{a_2} \\right) $$\n因此，精确的常数牵引力（通量）为：\n$$ J_{\\text{exact}} = \\left( \\frac{x_0}{a_1} + \\frac{1-x_0}{a_2} \\right)^{-1} $$\nLagrange 乘子 $\\lambda$ 是我们对这个量的数值近似。\n\n诊断指标计算如下：\n- $e_c = | U_{L,N_L} - U_{R,0} |$：来自左侧解最后一个节点和右侧解第一个节点的值。根据我们系统的构造，这个值应该在机器精度范围内为零。\n- $e_f = | a_1 u_L'(x_0^-) - a_2 u_R'(x_0^+) |$：离散单边导数为 $u_L'(x_0^-) = (U_{L,N_L} - U_{L,N_L-1}) / h_L$ 和 $u_R'(x_0^+) = (U_{R,1} - U_{R,0}) / h_R$。我们的公式意味着 $a_1 u_L' \\approx \\lambda$ 和 $a_2 u_R' \\approx \\lambda$，所以这个残差也应该接近于零。\n- $e_J = \\frac{| \\lambda - J_{\\text{exact}} |}{| J_{\\text{exact}} |}$：计算出的 Lagrange 乘子与精确解析牵引力之间的相对误差。这衡量了该方法的离散误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_mortar_fem(x0, a1, a2, NL, NR):\n    \"\"\"\n    Solves the 1D elliptic interface problem using a mortar FEM formulation.\n\n    Args:\n        x0 (float): Interface location.\n        a1 (float): Diffusion coefficient on the left subdomain [0, x0].\n        a2 (float): Diffusion coefficient on the right subdomain [x0, 1].\n        NL (int): Number of elements in the left subdomain.\n        NR (int): Number of elements in the right subdomain.\n\n    Returns:\n        tuple[float, float, float]: A tuple containing the diagnostics (ec, ef, eJ).\n    \"\"\"\n    # 1. Define mesh parameters\n    hL = x0 / NL\n    hR = (1 - x0) / NR\n\n    # 2. Assemble subdomain stiffness matrices (A_L, A_R)\n    # A_L is an NL x NL matrix for unknowns U_{L,1}, ..., U_{L,NL}\n    # It corresponds to rows/cols 1 to NL of the full (NL+1)x(NL+1) matrix\n    val_L = a1 / hL\n    AL_diag_vals = np.full(NL, 2.0 * val_L)\n    AL_diag_vals[-1] = 1.0 * val_L  # Modification for interface node\n    AL = np.diag(AL_diag_vals)\n    AL_offdiag_vals = np.full(NL - 1, -1.0 * val_L)\n    AL += np.diag(AL_offdiag_vals, k=1)\n    AL += np.diag(AL_offdiag_vals, k=-1)\n\n    # A_R is an NR x NR matrix for unknowns U_{R,0}, ..., U_{R,NR-1}\n    # It corresponds to rows/cols 0 to NR-1 of the full (NR+1)x(NR+1) matrix\n    val_R = a2 / hR\n    AR_diag_vals = np.full(NR, 2.0 * val_R)\n    AR_diag_vals[0] = 1.0 * val_R  # Modification for interface node\n    AR = np.diag(AR_diag_vals)\n    AR_offdiag_vals = np.full(NR - 1, -1.0 * val_R)\n    AR += np.diag(AR_offdiag_vals, k=1)\n    AR += np.diag(AR_offdiag_vals, k=-1)\n\n    # 3. Assemble coupling vectors and block system\n    # B_L selects the last unknown of U_L (U_L,NL)\n    BL = np.zeros((NL, 1))\n    BL[-1, 0] = 1.0\n\n    # B_R selects the first unknown of U_R (U_R,0)\n    BR = np.zeros((NR, 1))\n    BR[0, 0] = 1.0\n\n    # Assemble the full saddle-point matrix K\n    K = np.block([\n        [AL,                 np.zeros((NL, NR)), -BL],\n        [np.zeros((NR, NL)), AR,                  BR],\n        [BL.T,              -BR.T,                0.0]\n    ])\n\n    # 4. Assemble the right-hand side vector F\n    F = np.zeros(NL + NR + 1)\n    # The non-homogeneous Dirichlet BC u(1)=1 affects the equation for U_R,NR-1.\n    # The term from the full stiffness matrix is (A_R_full)_{NR-1, NR} * u(1),\n    # which is (-a2/hR) * 1. Moved to the RHS, it becomes a2/hR.\n    # This entry corresponds to the last row of the A_R block.\n    F[NL + NR - 1] = a2 / hR\n\n    # 5. Solve the linear system\n    try:\n        solution_vec = np.linalg.solve(K, F)\n    except np.linalg.LinAlgError:\n         # Handle potential singularity for ill-conditioned cases, though not expected here\n         return (float('nan'), float('nan'), float('nan'))\n\n    # 6. Extract results from the solution vector\n    U_L = solution_vec[:NL]          # Nodal values U_{L,1}, ..., U_{L,NL}\n    U_R = solution_vec[NL:NL + NR] # Nodal values U_{R,0}, ..., U_{R,NR-1}\n    lmbda = solution_vec[-1]         # Lagrange multiplier lambda\n\n    # 7. Calculate diagnostics\n    # Continuity residual ec\n    # U_L[-1] is the nodal value U_L,NL at x0 from the left.\n    # U_R[0] is the nodal value U_R,0 at x0 from the right.\n    ec = abs(U_L[-1] - U_R[0])\n\n    # Flux continuity residual ef\n    # Get previous nodal value on the left; U_L,0 is 0.\n    U_L_prev = U_L[-2] if NL  1 else 0.0\n    u_prime_L = (U_L[-1] - U_L_prev) / hL\n    \n    # Get next nodal value on the right; U_R,NR is 1.0\n    U_R_next = U_R[1] if NR  1 else 1.0\n    u_prime_R = (U_R_next - U_R[0]) / hR\n    \n    ef = abs(a1 * u_prime_L - a2 * u_prime_R)\n\n    # Relative error in interface traction eJ\n    # The exact traction/flux, J = a(x)u'(x), is constant.\n    J_exact = 1.0 / (x0 / a1 + (1 - x0) / a2)\n    eJ = abs(lmbda - J_exact) / abs(J_exact) if J_exact != 0 else abs(lmbda)\n\n    return (ec, ef, eJ)\n\n\ndef solve():\n    \"\"\"Main function to run the test suite and print results.\"\"\"\n    test_cases = [\n        (0.3, 1, 2, 20, 35),\n        (0.7, 10**6, 1, 5, 9),\n        (0.4, 10**-6, 1, 8, 12),\n    ]\n\n    results = []\n    for case in test_cases:\n        x0, a1, a2, N_L, N_R = case\n        ec, ef, eJ = solve_mortar_fem(x0, a1, a2, N_L, N_R)\n        results.append(f\"[{ec:.16e},{ef:.16e},{eJ:.16e}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}