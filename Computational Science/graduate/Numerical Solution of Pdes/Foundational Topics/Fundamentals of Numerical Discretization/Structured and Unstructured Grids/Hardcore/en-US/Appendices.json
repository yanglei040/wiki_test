{
    "hands_on_practices": [
        {
            "introduction": "Finite element and finite volume methods reduce partial differential equations to systems of algebraic equations by performing integrals over individual grid cells. For unstructured grids composed of triangles or tetrahedra, these integrations are almost always performed numerically using quadrature rules. This exercise  provides a direct calculation to demonstrate the concept of quadrature accuracy, quantifying the error that arises from \"underintegration\"â€”using a rule that is not powerful enough for the complexity of the function being integrated.",
            "id": "3450633",
            "problem": "Consider a two-dimensional, linear triangular finite element drawn from an unstructured grid used in the numerical solution of partial differential equations (PDEs). Let the triangular element have vertices at $(0,0)$, $(1,0)$, and $(0,2)$, so that its area is $A=\\frac{1}{2}\\times 1\\times 2=1$. Suppose the elemental integrand arising from a piecewise smooth field and coefficients is the quadratic polynomial\n$$\np(x,y)=3x^{2}-2xy+5y^{2}+4x-y+7.\n$$\nUsing the fundamental definition of Gaussian quadrature (GQ) as an approximate integration rule that is exact for polynomials up to a specified degree, evaluate the element integral $\\int_{T}p(x,y)\\,\\mathrm{d}A$ via the symmetric $3$-point triangular GQ rule, whose interpolation points are given in barycentric coordinates by the permutations of $\\left(\\frac{2}{3},\\frac{1}{6},\\frac{1}{6}\\right)$ with equal weights, and then evaluate the same integral via the underintegrated $1$-point centroid rule (barycentric coordinates $\\left(\\frac{1}{3},\\frac{1}{3},\\frac{1}{3}\\right)$, single weight equal to $A$). Report the signed error $E=I_{1\\text{-pt}}-I_{\\text{exact}}$, where $I_{\\text{exact}}$ is the integral value obtained by the $3$-point rule (which is exact for quadratic polynomials on a linear triangle), and $I_{1\\text{-pt}}$ is the centroid $1$-point value. Express your final answer as an exact rational number. No units are required.",
            "solution": "The task is to compute the signed error $E=I_{1\\text{-pt}}-I_{\\text{exact}}$ for the integral of a quadratic polynomial $p(x,y)$ over a specific triangular element $T$. $I_{1\\text{-pt}}$ is the integral approximated by the $1$-point centroid rule, and $I_{\\text{exact}}$ is the integral evaluated using a symmetric $3$-point Gaussian quadrature (GQ) rule, which is exact for this class of polynomial.\n\nThe triangular element $T$ has vertices at $v_1=(0,0)$, $v_2=(1,0)$, and $v_3=(0,2)$. Its area is given by $A = \\frac{1}{2}|(x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2))| = \\frac{1}{2}|(0(0-2) + 1(2-0) + 0(0-0))| = \\frac{1}{2}|2| = 1$. This confirms the given area $A=1$.\n\nThe integrand is the quadratic polynomial $p(x,y)=3x^{2}-2xy+5y^{2}+4x-y+7$.\n\nFirst, we evaluate the integral using the $1$-point centroid rule, $I_{1\\text{-pt}}$. This rule approximates the integral as the area of the element multiplied by the value of the integrand at the element's centroid.\nThe barycentric coordinates of the centroid are $(\\lambda_1, \\lambda_2, \\lambda_3) = (\\frac{1}{3}, \\frac{1}{3}, \\frac{1}{3})$.\nThe Cartesian coordinates $(x_c, y_c)$ of the centroid are the average of the vertex coordinates:\n$$x_c = \\frac{x_1+x_2+x_3}{3} = \\frac{0+1+0}{3} = \\frac{1}{3}$$\n$$y_c = \\frac{y_1+y_2+y_3}{3} = \\frac{0+0+2}{3} = \\frac{2}{3}$$\nThe quadrature rule is $\\int_T p(x,y)\\,\\mathrm{d}A \\approx A \\cdot p(x_c, y_c)$.\nWe evaluate $p(x,y)$ at the centroid $(x_c, y_c) = (\\frac{1}{3}, \\frac{2}{3})$:\n$$p\\left(\\frac{1}{3}, \\frac{2}{3}\\right) = 3\\left(\\frac{1}{3}\\right)^{2} - 2\\left(\\frac{1}{3}\\right)\\left(\\frac{2}{3}\\right) + 5\\left(\\frac{2}{3}\\right)^{2} + 4\\left(\\frac{1}{3}\\right) - \\left(\\frac{2}{3}\\right) + 7$$\n$$p\\left(\\frac{1}{3}, \\frac{2}{3}\\right) = 3\\left(\\frac{1}{9}\\right) - \\frac{4}{9} + 5\\left(\\frac{4}{9}\\right) + \\frac{4}{3} - \\frac{2}{3} + 7$$\n$$p\\left(\\frac{1}{3}, \\frac{2}{3}\\right) = \\frac{3}{9} - \\frac{4}{9} + \\frac{20}{9} + \\frac{12}{9} - \\frac{6}{9} + \\frac{63}{9} = \\frac{3-4+20+12-6+63}{9} = \\frac{88}{9}$$\nThus, the value of the integral from the $1$-point rule is:\n$$I_{1\\text{-pt}} = A \\cdot p\\left(\\frac{1}{3}, \\frac{2}{3}\\right) = 1 \\cdot \\frac{88}{9} = \\frac{88}{9}$$\n\nNext, we evaluate the integral using the symmetric $3$-point GQ rule. The problem states this rule is exact for quadratic polynomials on a linear triangle, so the result will be $I_{\\text{exact}}$. The rule is given by $\\int_T f(x,y)\\,\\mathrm{d}A \\approx A \\sum_{i=1}^3 w_i f(x_i, y_i)$.\nThe weights are equal, so $w_1=w_2=w_3=w$. For barycentric-based rules, the sum of the weights is normalized to $1$, so $3w=1$, which gives $w=\\frac{1}{3}$.\nThe quadrature points are given in barycentric coordinates $(\\lambda_1, \\lambda_2, \\lambda_3)$ by the permutations of $(\\frac{2}{3}, \\frac{1}{6}, \\frac{1}{6})$.\nThe mapping from barycentric to Cartesian coordinates $(x,y)$ is given by $(x,y) = \\lambda_1 v_1 + \\lambda_2 v_2 + \\lambda_3 v_3$.\nWith $v_1=(0,0)$, $v_2=(1,0)$, and $v_3=(0,2)$, the mapping is:\n$$(x,y) = \\lambda_1(0,0) + \\lambda_2(1,0) + \\lambda_3(0,2) = (\\lambda_2, 2\\lambda_3)$$\nWe now find the Cartesian coordinates for the three quadrature points and evaluate the polynomial at each point.\n\nPoint 1: $(\\lambda_1, \\lambda_2, \\lambda_3) = (\\frac{2}{3}, \\frac{1}{6}, \\frac{1}{6})$.\nCartesian coordinates: $(x_1, y_1) = (\\frac{1}{6}, 2 \\cdot \\frac{1}{6}) = (\\frac{1}{6}, \\frac{1}{3})$.\n$$p\\left(\\frac{1}{6}, \\frac{1}{3}\\right) = 3\\left(\\frac{1}{36}\\right) - 2\\left(\\frac{1}{6}\\right)\\left(\\frac{1}{3}\\right) + 5\\left(\\frac{1}{9}\\right) + 4\\left(\\frac{1}{6}\\right) - \\frac{1}{3} + 7 = \\frac{3}{36} - \\frac{2}{18} + \\frac{5}{9} + \\frac{4}{6} - \\frac{1}{3} + 7$$\n$$p\\left(\\frac{1}{6}, \\frac{1}{3}\\right) = \\frac{3}{36} - \\frac{4}{36} + \\frac{20}{36} + \\frac{24}{36} - \\frac{12}{36} + \\frac{252}{36} = \\frac{283}{36}$$\n\nPoint 2: $(\\lambda_1, \\lambda_2, \\lambda_3) = (\\frac{1}{6}, \\frac{2}{3}, \\frac{1}{6})$.\nCartesian coordinates: $(x_2, y_2) = (\\frac{2}{3}, 2 \\cdot \\frac{1}{6}) = (\\frac{2}{3}, \\frac{1}{3})$.\n$$p\\left(\\frac{2}{3}, \\frac{1}{3}\\right) = 3\\left(\\frac{4}{9}\\right) - 2\\left(\\frac{2}{3}\\right)\\left(\\frac{1}{3}\\right) + 5\\left(\\frac{1}{9}\\right) + 4\\left(\\frac{2}{3}\\right) - \\frac{1}{3} + 7 = \\frac{12}{9} - \\frac{4}{9} + \\frac{5}{9} + \\frac{8}{3} - \\frac{1}{3} + 7$$\n$$p\\left(\\frac{2}{3}, \\frac{1}{3}\\right) = \\frac{12-4+5}{9} + \\frac{24-3}{9} + \\frac{63}{9} = \\frac{13+21+63}{9} = \\frac{97}{9} = \\frac{388}{36}$$\n\nPoint 3: $(\\lambda_1, \\lambda_2, \\lambda_3) = (\\frac{1}{6}, \\frac{1}{6}, \\frac{2}{3})$.\nCartesian coordinates: $(x_3, y_3) = (\\frac{1}{6}, 2 \\cdot \\frac{2}{3}) = (\\frac{1}{6}, \\frac{4}{3})$.\n$$p\\left(\\frac{1}{6}, \\frac{4}{3}\\right) = 3\\left(\\frac{1}{36}\\right) - 2\\left(\\frac{1}{6}\\right)\\left(\\frac{4}{3}\\right) + 5\\left(\\frac{16}{9}\\right) + 4\\left(\\frac{1}{6}\\right) - \\frac{4}{3} + 7 = \\frac{3}{36} - \\frac{8}{18} + \\frac{80}{9} + \\frac{4}{6} - \\frac{4}{3} + 7$$\n$$p\\left(\\frac{1}{6}, \\frac{4}{3}\\right) = \\frac{3}{36} - \\frac{16}{36} + \\frac{320}{36} + \\frac{24}{36} - \\frac{48}{36} + \\frac{252}{36} = \\frac{3-16+320+24-48+252}{36} = \\frac{535}{36}$$\n\nNow, we compute the exact integral value:\n$$I_{\\text{exact}} = A \\sum_{i=1}^3 w_i p(x_i, y_i) = 1 \\cdot \\frac{1}{3} \\left( p(x_1, y_1) + p(x_2, y_2) + p(x_3, y_3) \\right)$$\n$$I_{\\text{exact}} = \\frac{1}{3} \\left( \\frac{283}{36} + \\frac{388}{36} + \\frac{535}{36} \\right) = \\frac{1}{3} \\left( \\frac{283+388+535}{36} \\right) = \\frac{1}{3} \\left( \\frac{1206}{36} \\right)$$\nSimplifying the fraction $\\frac{1206}{36}$: $\\frac{1206 \\div 6}{36 \\div 6} = \\frac{201}{6} = \\frac{201 \\div 3}{6 \\div 3} = \\frac{67}{2}$.\n$$I_{\\text{exact}} = \\frac{1}{3} \\cdot \\frac{67}{2} = \\frac{67}{6}$$\n\nFinally, we compute the signed error $E = I_{1\\text{-pt}} - I_{\\text{exact}}$:\n$$E = \\frac{88}{9} - \\frac{67}{6}$$\nThe least common multiple of $9$ and $6$ is $18$.\n$$E = \\frac{88 \\cdot 2}{18} - \\frac{67 \\cdot 3}{18} = \\frac{176}{18} - \\frac{201}{18} = \\frac{176 - 201}{18} = -\\frac{25}{18}$$\nThe signed error is $-\\frac{25}{18}$.",
            "answer": "$$\\boxed{-\\frac{25}{18}}$$"
        },
        {
            "introduction": "The theoretical power of unstructured grids to conform to complex geometries comes with a practical challenge: ensuring high-quality mesh elements. Poorly shaped elements, such as \"sliver\" tetrahedra, can severely degrade the performance and accuracy of a numerical method. Through a computational experiment , you will investigate this critical relationship between mesh quality and numerical stability by intentionally creating sliver elements and measuring their impact on the stiffness matrix condition number and the solution error for a 3D Poisson problem.",
            "id": "3450603",
            "problem": "You will study how extremely flat tetrahedra (often called slivers) in an unstructured grid affect the conditioning of the Finite Element Method (FEM) stiffness matrix and the accuracy of the numerical solution for a three-dimensional Poisson problem. Work in the domain $\\Omega = (0,1)^3$ for the scalar field $u$. Consider the model problem with the Laplacian operator, namely the Poisson equation\n$$\n\\Delta u = f \\text{ in } \\Omega,\n$$\nwith Dirichlet boundary conditions\n$$\nu = u^\\star \\text{ on } \\partial \\Omega,\n$$\nwhere the exact solution is prescribed as the quadratic polynomial\n$$\nu^\\star(x,y,z) = x^2 + y^2 + z^2,\n$$\nso that the source term is the Laplacian\n$$\nf = \\Delta u^\\star = 2 + 2 + 2 = 6.\n$$\nYou will use the standard Continuous Galerkin Finite Element Method (CG-FEM) with first-order piecewise linear basis functions on tetrahedra. The stiffness matrix $K$ has entries\n$$\nK_{ij} = \\int_{\\Omega} \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, d\\Omega,\n$$\nand the load vector $b$ has entries\n$$\nb_i = \\int_{\\Omega} f \\, \\phi_i \\, d\\Omega,\n$$\nwhere $\\{\\phi_i\\}$ are the nodal basis functions. Use element-wise assembly with the following fundamental geometric construction for each tetrahedron with vertices $\\mathbf{p}_0,\\mathbf{p}_1,\\mathbf{p}_2,\\mathbf{p}_3 \\in \\mathbb{R}^3$:\n- Define the $3 \\times 3$ Jacobian-like matrix\n$$\nT = \\big[ \\mathbf{p}_1 - \\mathbf{p}_0 \\ \\ \\mathbf{p}_2 - \\mathbf{p}_0 \\ \\ \\mathbf{p}_3 - \\mathbf{p}_0 \\big].\n$$\n- The element volume is\n$$\nV_e = \\frac{|\\det(T)|}{6}.\n$$\n- The gradients of the linear shape functions in physical coordinates are constant on the element and obtained from the reference-element gradients by\n$$\n\\nabla \\phi_0 = -T^{-\\top} \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}, \\quad\n\\nabla \\phi_1 = T^{-\\top} \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\n\\nabla \\phi_2 = T^{-\\top} \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\end{bmatrix}, \\quad\n\\nabla \\phi_3 = T^{-\\top} \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}.\n$$\n- The element stiffness matrix is\n$$\nK^{(e)}_{ij} = V_e \\, \\nabla \\phi_i \\cdot \\nabla \\phi_j.\n$$\n- Since $f$ is constant, use the exact element load vector\n$$\nb^{(e)}_i = f \\, \\int_{e} \\phi_i \\, d\\Omega = f \\, \\frac{V_e}{4}.\n$$\nImpose the Dirichlet boundary conditions by eliminating boundary degrees of freedom: write the unknown vector as $u = \\begin{bmatrix} u_I \\\\ u_B \\end{bmatrix}$ corresponding to interior and boundary nodes, and solve\n$$\nK_{II} \\, u_I = b_I - K_{IB} u_B\n$$\nwith $u_B$ set to the exact boundary values given by $u^\\star$ evaluated at the boundary nodes. After solving, recover the full vector $u$ by inserting $u_I$ and $u_B$.\n\nMesh generation and sliver control must proceed as follows. Start from a structured grid of hexahedra formed by a uniform partition with $N$ subdivisions per coordinate axis on $\\Omega$, and split each hexahedron into $6$ tetrahedra using a consistent long-diagonal pattern, thereby creating an unstructured tetrahedral mesh. To introduce slivers, apply an anisotropic geometric distortion in a slab around the plane $z = 1/2$:\n- Fix a slab half-width $w = 1/4$, a slab center $z_0 = 1/2$, and a scale factor $s \\in (0,1]$.\n- For every mesh node with coordinate $z$, if $|z - z_0| \\le w$, map it to\n$$\nz' = z_0 + s \\, (z - z_0),\n$$\nand leave it unchanged otherwise. This compresses the slab thickness by a factor $s$ and creates sliver tetrahedra with very small height when $s \\ll 1$.\nAs a geometric sliver removal strategy, post-process the distorted mesh by enforcing a minimum scale $s_{\\min} \\in (0,1]$ in the slab through the mapping\n$$\nz' = z_0 + \\max(s, s_{\\min}) \\, (z - z_0)\n$$\nfor all nodes with $|z - z_0| \\le w$. This simple strategy increases the minimal height of tetrahedra in the slab.\n\nQuantify:\n- The spectral condition number of the eliminated stiffness matrix $K_{II}$ defined by\n$$\n\\kappa(K_{II}) = \\frac{\\lambda_{\\max}(K_{II})}{\\lambda_{\\min}(K_{II})},\n$$\nwhere $\\lambda_{\\max}$ and $\\lambda_{\\min}$ are the largest and smallest eigenvalues, respectively.\n- The relative discrete $L^2$ error of the FEM solution $u_h$ with respect to $u^\\star$, approximated by element-wise centroid quadrature:\n$$\n\\| e \\|_{L^2(\\Omega)} \\approx \\left( \\sum_{e} V_e \\, \\big( u_h(\\mathbf{c}_e) - u^\\star(\\mathbf{c}_e) \\big)^2 \\right)^{1/2},\n$$\n$$\n\\| u^\\star \\|_{L^2(\\Omega)} \\approx \\left( \\sum_{e} V_e \\, \\big( u^\\star(\\mathbf{c}_e) \\big)^2 \\right)^{1/2},\n$$\n$$\n\\text{RelErr} = \\frac{\\| e \\|_{L^2(\\Omega)}}{\\| u^\\star \\|_{L^2(\\Omega)}},\n$$\nwhere $\\mathbf{c}_e$ is the centroid of tetrahedron $e$, and $u_h(\\mathbf{c}_e)$ is the average of the nodal values of $u_h$ on that tetrahedron (which is exact for linear $u_h$ at the centroid).\n\nImplement a program that constructs the mesh, assembles and solves the FEM system, computes $\\kappa(K_{II})$ and $\\text{RelErr}$, and aggregates the results for the following test suite:\n- Test $1$ (baseline well-shaped): $N = 6$, $s = 1.0$, no sliver removal (no post-processing).\n- Test $2$ (moderate slivers): $N = 6$, $s = 0.2$, no sliver removal.\n- Test $3$ (extreme slivers): $N = 6$, $s = 0.02$, no sliver removal.\n- Test $4$ (sliver removal applied): $N = 6$, $s = 0.02$, sliver removal with $s_{\\min} = 0.2$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the exact order\n$$\n[\\kappa_1,\\text{RelErr}_1,\\kappa_2,\\text{RelErr}_2,\\kappa_3,\\text{RelErr}_3,\\kappa_4,\\text{RelErr}_4],\n$$\nwhere $\\kappa_i$ and $\\text{RelErr}_i$ correspond to Test $i$ for $i \\in \\{1,2,3,4\\}$. All outputs must be real numbers without units. No user input is required; all parameters must be defined in the code as specified above. Ensure scientific realism by adhering to the definitions and procedures stated here and use only the specified numerical libraries.",
            "solution": "The core task is to solve the three-dimensional Poisson equation $\\Delta u = f$ on the domain $\\Omega = (0,1)^3$. The exact solution is given as $u^\\star(x,y,z) = x^2 + y^2 + z^2$, which implies a constant source term $f = \\Delta u^\\star = 6$. Dirichlet boundary conditions are specified, with $u = u^\\star$ on the boundary $\\partial \\Omega$. We will employ the Continuous Galerkin FEM with piecewise linear basis functions on a tetrahedral mesh.\n\nThe solution process involves four main stages: mesh generation, FEM system assembly, solution of the algebraic system, and computation of analytical metrics (condition number and error). This process is repeated for four distinct test cases, each characterized by a different level of mesh distortion.\n\n**1. Mesh Generation and Distortion**\n\nFirst, a set of nodes is generated on a uniform Cartesian grid. For $N$ subdivisions along each axis, we obtain $(N+1)^3$ nodes $\\mathbf{p}_{ijk} = (x_i, y_j, z_k)$, where $x_i = i/N$, $y_j = j/N$, and $z_k = k/N$ for $i,j,k \\in \\{0, 1, \\dots, N\\}$.\n\nThis regular node distribution is then subjected to an anisotropic geometric distortion to create poorly shaped \"sliver\" tetrahedra. The distortion acts on the $z$-coordinate of nodes located within a slab defined by $z \\in [z_0 - w, z_0 + w]$, where the center is $z_0 = 1/2$ and the half-width is $w = 1/4$. For any node with $z$-coordinate satisfying $|z - z_0| \\le w$, its coordinate is mapped according to:\n$$\nz' = z_0 + s_{\\text{eff}} (z - z_0)\n$$\nwhere $s_{\\text{eff}}$ is an effective scaling factor. For tests without sliver removal, $s_{\\text{eff}} = s$. For the test with sliver removal, the scale factor is corrected to enforce a minimum quality, yielding $s_{\\text{eff}} = \\max(s, s_{\\min})$. Nodes outside the slab remain unchanged. This transformation compresses the mesh in the $z$-direction within the slab, with smaller values of $s_{\\text{eff}}$ leading to more extreme compression and flatter elements.\n\nThe domain $\\Omega$ is partitioned into $N^3$ hexahedral cells. Each hexahedron is then subdivided into $6$ tetrahedra using a consistent pattern based on its main body diagonal. For a hexahedron with local corner vertices indexed $p_0, \\dots, p_7$, we use the diagonal connecting $p_0$ and $p_6$. The six tetrahedra are formed by taking pairs of adjacent faces that meet at this diagonal. For a hexahedron defined by grid indices $(i,j,k)$ to $(i+1,j+1,k+1)$, this results in the following six tetrahedra, specified by their global node indices:\n- $(\\text{idx}(i,j,k), \\text{idx}(i+1,j,k), \\text{idx}(i+1,j+1,k), \\text{idx}(i+1,j+1,k+1))$\n- $(\\text{idx}(i,j,k), \\text{idx}(i,j+1,k), \\text{idx}(i+1,j+1,k), \\text{idx}(i+1,j+1,k+1))$\n- $(\\text{idx}(i,j,k), \\text{idx}(i,j+1,k), \\text{idx}(i,j+1,k+1), \\text{idx}(i+1,j+1,k+1))$\n- $(\\text{idx}(i,j,k), \\text{idx}(i,j,k+1), \\text{idx}(i,j+1,k+1), \\text{idx}(i+1,j+1,k+1))$\n- $(\\text{idx}(i,j,k), \\text{idx}(i,j,k+1), \\text{idx}(i+1,j,k+1), \\text{idx}(i+1,j+1,k+1))$\n- $(\\text{idx}(i,j,k), \\text{idx}(i+1,j,k), \\text{idx}(i+1,j,k+1), \\text{idx}(i+1,j+1,k+1))$\nThis constitutes the final unstructured tetrahedral mesh.\n\n**2. Finite Element System Assembly**\n\nThe FEM discretization leads to a linear system of equations $K u = b$. The global stiffness matrix $K$ and load vector $b$ are assembled from element-level contributions. For each tetrahedral element $e$ with vertices $\\mathbf{p}_0, \\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3$:\n\n- A $3 \\times 3$ matrix $T$ is formed from the vectors spanning the element edges from vertex $\\mathbf{p}_0$: $T = [\\mathbf{p}_1 - \\mathbf{p}_0, \\mathbf{p}_2 - \\mathbf{p}_0, \\mathbf{p}_3 - \\mathbf{p}_0]$.\n- The element's volume is $V_e = |\\det(T)| / 6$.\n- The gradients of the four linear basis functions $\\phi_i$ are constant within the element and are computed using the inverse transpose of $T$: $\\nabla\\phi_0 = -T^{-\\top}[1,1,1]^\\top$, $\\nabla\\phi_1=T^{-\\top}[1,0,0]^\\top$, etc.\n- The $4 \\times 4$ element stiffness matrix $K^{(e)}$ has entries $K^{(e)}_{ij} = V_e (\\nabla \\phi_i \\cdot \\nabla \\phi_j)$.\n- The $4 \\times 1$ element load vector $b^{(e)}$ has entries $b^{(e)}_i = f (V_e / 4)$, where $f=6$.\n\nThese local matrices and vectors are then summed into the corresponding global arrays based on the global indices of the element's vertices.\n\n**3. Boundary Conditions and Solution**\n\nThe Dirichlet boundary conditions are imposed by partitioning the nodes into interior ($I$) and boundary ($B$) sets. The global system $K u = b$ is rearranged as:\n$$\n\\begin{bmatrix} K_{II} & K_{IB} \\\\ K_{BI} & K_{BB} \\end{bmatrix}\n\\begin{bmatrix} u_I \\\\ u_B \\end{bmatrix}\n=\n\\begin{bmatrix} b_I \\\\ b_B \\end{bmatrix}\n$$\nThe values of the solution at the boundary nodes, $u_B$, are known, as they are prescribed by the exact solution: $u_B = u^\\star(\\mathbf{p}_B)$, where $\\mathbf{p}_B$ are the coordinates of the boundary nodes. This allows us to solve for the unknown interior values $u_I$ via the reduced system:\n$$\nK_{II} u_I = b_I - K_{IB} u_B\n$$\nThis linear system is solved for $u_I$. The matrix $K_{II}$ is symmetric and positive definite, guaranteeing a unique solution.\n\n**4. Performance Metrics**\n\nTwo key metrics are computed to evaluate the impact of the mesh distortion:\n\n- **Spectral Condition Number**: The conditioning of the matrix $K_{II}$ is measured by its spectral condition number, $\\kappa(K_{II}) = \\lambda_{\\max}(K_{II}) / \\lambda_{\\min}(K_{II})$, where $\\lambda_{\\max}$ and $\\lambda_{\\min}$ are the maximum and minimum eigenvalues of $K_{II}$. A high condition number indicates numerical sensitivity and potential difficulties for iterative solvers. The eigenvalues are computed from the assembled matrix $K_{II}$.\n\n- **Relative $L^2$ Error**: The accuracy of the numerical solution $u_h$ is quantified by the relative error in the (discrete) $L^2$ norm. This is approximated using a centroid-based quadrature rule over all elements:\n$$\n\\text{RelErr} = \\frac{\\| u_h - u^\\star \\|_{L^2(\\Omega)}}{\\| u^\\star \\|_{L^2(\\Omega)}} \\approx \\frac{\\left( \\sum_{e} V_e \\, (u_h(\\mathbf{c}_e) - u^\\star(\\mathbf{c}_e))^2 \\right)^{1/2}}{\\left( \\sum_{e} V_e \\, (u^\\star(\\mathbf{c}_e))^2 \\right)^{1/2}}\n$$\nHere, $\\mathbf{c}_e$ is the centroid of tetrahedron $e$. For a linear finite element, the value of the solution $u_h$ at the centroid is exactly the average of its four nodal values.\n\nThe procedure is executed for each of the four test cases specified: a baseline case with no distortion ($s=1.0$), two cases with moderate ($s=0.2$) and extreme ($s=0.02$) distortion, and a final case demonstrating sliver removal, which remaps the geometry of the extreme sliver case using a minimum scale factor $s_{\\min}=0.2$. This final test case is expected to recover the results of the moderate sliver case, as the effective scale factor becomes $\\max(0.02, 0.2) = 0.2$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ... is not needed for this problem\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, s, s_min_option) where s_min_option is s_min or None.\n    test_cases = [\n        (6, 1.0, None),    # Test 1: Baseline\n        (6, 0.2, None),    # Test 2: Moderate slivers\n        (6, 0.02, None),   # Test 3: Extreme slivers\n        (6, 0.02, 0.2),    # Test 4: Sliver removal\n    ]\n\n    # Source term f for the Poisson equation.\n    f_source = 6.0\n\n    # Exact solution u_star(x,y,z) = x^2 + y^2 + z^2\n    def u_star(p):\n        return p[0]**2 + p[1]**2 + p[2]**2\n\n    results = []\n    for N, s, s_min_option in test_cases:\n        kappa, rel_err = run_simulation(N, s, s_min_option, f_source, u_star)\n        results.extend([kappa, rel_err])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\ndef run_simulation(N, s, s_min_option, f, u_star_func):\n    \"\"\"\n    Performs a single FEM simulation for a given set of parameters.\n    \"\"\"\n    \n    # --- 1. Mesh Generation ---\n    w = 0.25  # Slab half-width\n    z0 = 0.5  # Slab center\n    \n    s_eff = s\n    if s_min_option is not None:\n        s_eff = max(s, s_min_option)\n\n    # Generate nodes\n    num_nodes = (N + 1)**3\n    nodes = np.zeros((num_nodes, 3))\n    node_idx = lambda i, j, k: i + j * (N + 1) + k * (N + 1)**2\n    \n    for k in range(N + 1):\n        for j in range(N + 1):\n            for i in range(N + 1):\n                idx = node_idx(i, j, k)\n                x, y, z = i/N, j/N, k/N\n                if abs(z - z0) <= w:\n                    z = z0 + s_eff * (z - z0)\n                nodes[idx] = [x, y, z]\n\n    # Generate tetrahedra from hexahedra\n    num_hex = N**3\n    num_tets = 6 * num_hex\n    tets = np.zeros((num_tets, 4), dtype=int)\n    \n    tet_idx = 0\n    for k in range(N):\n        for j in range(N):\n            for i in range(N):\n                # 8 corners of the hex\n                p = [node_idx(i+di, j+dj, k+dk) for dk in range(2) for dj in range(2) for di in range(2)]\n                # p_ijk indices: i is fastest, k is slowest\n                # p[0]=p_000, p[1]=p_100, p[2]=p_010, p[3]=p_110\n                # p[4]=p_001, p[5]=p_101, p[6]=p_011, p[7]=p_111\n                # Custom re-ordering to match the derivation logic\n                p_std = [p[0], p[1], p[3], p[2], p[4], p[5], p[7], p[6]]\n                p0, p1, p2, p3, p4, p5, p6, p7 = p_std\n\n                # Split hex into 6 tets using main diagonal p0-p6\n                tets[tet_idx + 0] = [p0, p1, p2, p6]\n                tets[tet_idx + 1] = [p0, p2, p3, p6]\n                tets[tet_idx + 2] = [p0, p3, p7, p6]\n                tets[tet_idx + 3] = [p0, p4, p7, p6]\n                tets[tet_idx + 4] = [p0, p4, p5, p6]\n                tets[tet_idx + 5] = [p0, p5, p1, p6]\n                tet_idx += 6\n\n    # Identify interior and boundary nodes\n    is_boundary = np.zeros(num_nodes, dtype=bool)\n    for k in range(N + 1):\n        for j in range(N + 1):\n            for i in range(N + 1):\n                if i == 0 or i == N or j == 0 or j == N or k == 0 or k == N:\n                    is_boundary[node_idx(i, j, k)] = True\n    \n    interior_nodes = np.where(~is_boundary)[0]\n    boundary_nodes = np.where(is_boundary)[0]\n    num_interior = len(interior_nodes)\n\n    global_to_interior_map = {glob_idx: i for i, glob_idx in enumerate(interior_nodes)}\n\n    # --- 2. FEM Assembly ---\n    K_II = np.zeros((num_interior, num_interior))\n    K_IB = np.zeros((num_interior, len(boundary_nodes)))\n    b_I = np.zeros(num_interior)\n    \n    # Gradients of barycentric coordinates on reference tet\n    grad_ref = np.array([[-1,-1,-1], [1,0,0], [0,1,0], [0,0,1]], dtype=float).T\n\n    for tet in tets:\n        p0, p1, p2, p3 = nodes[tet[0]], nodes[tet[1]], nodes[tet[2]], nodes[tet[3]]\n        \n        T = np.array([p1 - p0, p2 - p0, p3 - p0]).T\n        T_inv_T = np.linalg.inv(T).T\n        \n        det_T = np.linalg.det(T)\n        vol = abs(det_T) / 6.0\n        \n        # Gradients in physical coordinates\n        grad_phi = T_inv_T @ grad_ref\n        \n        # Element stiffness matrix\n        K_e = vol * (grad_phi.T @ grad_phi)\n        \n        # Element load vector\n        b_e = f * vol / 4.0\n        \n        # Assemble into global system (partitioned)\n        for i_local in range(4):\n            glob_i = tet[i_local]\n            is_i_interior = not is_boundary[glob_i]\n\n            if is_i_interior:\n                ii = global_to_interior_map[glob_i]\n                b_I[ii] += b_e\n                \n            for j_local in range(4):\n                glob_j = tet[j_local]\n                is_j_interior = not is_boundary[glob_j]\n                \n                if is_i_interior and is_j_interior:\n                    ii = global_to_interior_map[glob_i]\n                    jj = global_to_interior_map[glob_j]\n                    K_II[ii, jj] += K_e[i_local, j_local]\n                elif is_i_interior and not is_j_interior:\n                    ii = global_to_interior_map[glob_i]\n                    bj = np.where(boundary_nodes == glob_j)[0][0]\n                    K_IB[ii, bj] += K_e[i_local, j_local]\n\n    # --- 3. Apply BCs and Solve ---\n    u_B = np.array([u_star_func(nodes[idx]) for idx in boundary_nodes])\n    \n    rhs = b_I - K_IB @ u_B\n    u_I = np.linalg.solve(K_II, rhs)\n\n    # --- 4. Compute Metrics ---\n    # Condition number\n    eigvals = np.linalg.eigvalsh(K_II)\n    kappa = eigvals[-1] / eigvals[0]\n    \n    # Reconstruct full solution vector\n    u_full = np.zeros(num_nodes)\n    u_full[interior_nodes] = u_I\n    u_full[boundary_nodes] = u_B\n\n    # L2 Error\n    err_sq_norm = 0.0\n    ustar_sq_norm = 0.0\n    for tet in tets:\n        p_coords = nodes[tet]\n        centroid = np.mean(p_coords, axis=0)\n        \n        # Volume of current tet\n        p0, p1, p2, p3 = p_coords[0], p_coords[1], p_coords[2], p_coords[3]\n        T_mat = np.array([p1 - p0, p2 - p0, p3 - p0]).T\n        vol = abs(np.linalg.det(T_mat)) / 6.0\n        \n        u_h_centroid = np.mean(u_full[tet])\n        u_star_centroid = u_star_func(centroid)\n        \n        err_sq_norm += vol * (u_h_centroid - u_star_centroid)**2\n        ustar_sq_norm += vol * (u_star_centroid)**2\n\n    rel_err = np.sqrt(err_sq_norm / ustar_sq_norm) if ustar_sq_norm > 0 else 0.0\n    \n    return kappa, rel_err\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "A key advantage of modern grid strategies is adaptivity, where the mesh resolution is dynamically adjusted to capture important solution features efficiently. When solving conservation laws on such adaptive grids, it is paramount to ensure that the numerical scheme remains conservative, meaning it does not artificially create or destroy the conserved quantity. This practice  guides you through the implementation of \"refluxing,\" the essential technique used in Adaptive Mesh Refinement (AMR) to enforce discrete conservation across the interfaces between coarse and fine grid levels.",
            "id": "3450641",
            "problem": "You are asked to formalize and implement a two-level Adaptive Mesh Refinement (AMR) strategy for the scalar conservation law in one spatial dimension, focusing on structured and unstructured grid principles for finite volume methods. The governing equation is the linear advection conservation law\n$$\n\\partial_t u + \\partial_x f(u) = 0,\\quad f(u) = a\\,u,\n$$\non the periodic domain $[0,1]$, with constant advection speed $a>0$. The core of the task is to design coarsening and refinement rules that guarantee conservation across levels via refluxing, and to quantify the error introduced by a conservative projection.\n\nYou must start from fundamental definitions: the control volume form of conservation, discrete conservation in finite volume methods, flux consistency, and the notion that any conservative transfer between levels must preserve cell-integrated quantities. Avoid relying on any unproven formulas beyond these fundamental bases.\n\nImplement the following design in a single program:\n\n- Discretize $[0,1]$ by a uniform coarse grid with $N_c$ cells of width $\\Delta x_c = 1/N_c$.\n- Define a single refined patch that aligns to coarse cell boundaries, covering a contiguous set of coarse cells $i\\in\\{i_L,\\dots,i_R-1\\}$, and refine by an integer factor $r\\in\\mathbb{N}$, producing fine cells of width $\\Delta x_f = \\Delta x_c/r$ only within the patch.\n- Use a first-order upwind finite volume scheme for $a>0$. Let $F_{i+1/2}=a\\,U_i$ denote the numerical flux at the right face of cell $i$ for piecewise-constant data.\n- Use time subcycling: take a fine time step $\\Delta t_f = \\mathrm{CFL}\\cdot \\Delta x_f/a$, and one coarse step $\\Delta t_c = r\\,\\Delta t_f$ so that levels synchronize after one coarse step. Assume piecewise-constant-in-time boundary data for filling fine ghost values at the coarse-fine interface. Use periodic boundary conditions on the coarse level. The fine patch is strictly interior to the domain.\n- Accumulate time-integrated fine fluxes across the two coarse-fine interface faces during subcycling. After advancing the coarse level by one step, apply refluxing to the two coarse cells adjacent to the refined patch to replace the coarse time-integrated face flux by the accumulated fine time-integrated flux on that face. Then perform conservative restriction (fine-to-coarse) by averaging the fine cell averages back to their parent coarse cells inside the refined patch.\n- Define conservative coarse-to-fine projection (prolongation) as piecewise-constant injection: each fine child of a coarse cell receives its parent coarse cell average. Quantify the error introduced by this conservative projection at the initial time by computing an $L^1$ cell-average mismatch over the refined patch between the prolongated field and the exact fine cell averages of the initial data.\n\nFor reproducible and verifiable results, use the following initialization via exact cell averages:\n\n- For a trigonometric case, let $u(x)=\\sin(2\\pi k x)$ for integer $k\\ge 1$, whose exact cell average on an interval $[x_L,x_R]$ is\n$$\n\\bar{u} = \\frac{1}{x_R-x_L}\\int_{x_L}^{x_R}\\sin(2\\pi k x)\\,dx = \\frac{\\cos(2\\pi k x_L)-\\cos(2\\pi k x_R)}{2\\pi k (x_R-x_L)}.\n$$\n- For a discontinuous step, let $u(x)=1$ on $[0,\\tfrac{1}{2})$ and $u(x)=0$ otherwise, whose exact cell average is the overlap length of the cell with $[0,\\tfrac{1}{2})$ divided by the cell width.\n\nYour program must compute, for each test, the following outputs:\n- The absolute total mass error after one synchronized coarse step with refluxing, computed as the absolute value of the difference between the total integral of $u$ over $[0,1]$ at the beginning and at the end of the step, where the hierarchy mass is measured by summing coarse cells outside the refined patch and fine cells inside the refined patch.\n- A boolean indicating whether conservation is satisfied to within a tolerance of $10^{-12}$, that is, whether the absolute mass error is less than $10^{-12}$.\n- The absolute $L^1$ projection error of conservative coarse-to-fine projection at initial time over the refined patch, defined as\n$$\nE_{L^1} = \\sum_{j\\in \\text{fine patch}} \\left| U^{\\text{prolong}}_{f,j} - \\bar{u}_j \\right|\\,\\Delta x_f,\n$$\nwhere $U^{\\text{prolong}}_{f,j}$ is the fine value obtained by conservative prolongation from the coarse level, and $\\bar{u}_j$ is the exact fine cell average of the initial data.\n\nTest suite. Run the program on exactly the following three cases, which together probe a smooth mode, a discontinuity, and higher-frequency content, all with $a=1$:\n\n- Case A (smooth mode): $N_c=16$, $r=2$, refined patch $[0.25,0.50]$, $\\mathrm{CFL}=0.5$, $u(x)=\\sin(2\\pi\\cdot 1\\cdot x)$.\n- Case B (discontinuity): $N_c=8$, $r=4$, refined patch $[0.375,0.625]$, $\\mathrm{CFL}=0.8$, $u(x)=\\mathbf{1}_{[0,1/2)}(x)$.\n- Case C (higher frequency): $N_c=10$, $r=5$, refined patch $[0.2,0.4]$, $\\mathrm{CFL}=0.9$, $u(x)=\\sin(2\\pi\\cdot 3\\cdot x)$.\n\nFinal output format. Your program should produce a single line of output containing a flat, comma-separated Python-style list of nine entries in the exact order\n$$\n[\\text{mass\\_err}_A,\\ \\text{is\\_cons}_A,\\ \\text{proj\\_err}_A,\\ \\text{mass\\_err}_B,\\ \\text{is\\_cons}_B,\\ \\text{proj\\_err}_B,\\ \\text{mass\\_err}_C,\\ \\text{is\\_cons}_C,\\ \\text{proj\\_err}_C],\n$$\nwhere $\\text{mass\\_err}$ and $\\text{proj\\_err}$ are floats and $\\text{is\\_cons}$ is a boolean. No other text should be printed.",
            "solution": "The problem requires the formalization and implementation of a two-level adaptive mesh refinement (AMR) scheme for the one-dimensional linear advection equation, $\\partial_t u + a \\partial_x u = 0$, on a periodic domain $[0,1]$. The implementation must be based on a finite volume method and must correctly handle conservation at the interface between coarse and fine grids using refluxing.\n\n**1. Finite Volume Discretization and Conservation**\n\nThe integral form of the conservation law over a control volume (cell) $[x_{i-1/2}, x_{i+1/2}]$ of width $\\Delta x_i = x_{i+1/2} - x_{i-1/2}$ is foundational:\n$$\n\\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx + f(u(x_{i+1/2},t)) - f(u(x_{i-1/2},t)) = 0.\n$$\nDefining the cell average $U_i(t) = \\frac{1}{\\Delta x_i} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$, the equation becomes:\n$$\n\\frac{d}{dt} U_i(t) = -\\frac{1}{\\Delta x_i} [f(u(x_{i+1/2},t)) - f(u(x_{i-1/2},t))].\n$$\nA finite volume method discretizes this in time and approximates the fluxes $f(u)$ at cell interfaces. We use a first-order Euler time step and a first-order upwind flux. For advection speed $a>0$, the flux at interface $i+1/2$ depends on the state in cell $i$ to its left. We approximate the interface flux with $F_{i+1/2} \\approx f(U_i)$. The fully discrete update for a uniform grid of cell width $\\Delta x$ is:\n$$\n\\frac{U_i^{n+1} - U_i^n}{\\Delta t} = -\\frac{F_{i+1/2}^n - F_{i-1/2}^n}{\\Delta x} = -\\frac{a U_i^n - a U_{i-1}^n}{\\Delta x}.\n$$\nThis can be rewritten as $U_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}(F_{i+1/2}^n - F_{i-1/2}^n)$. A key property of this form is that the flux $F_{i+1/2}^n$ leaving cell $i$ is exactly the flux entering cell $i+1$. Summing over all cells in a periodic domain, the fluxes cancel in pairs, and the total mass (integral of $u$) is conserved.\n\n**2. AMR Grid Hierarchy and Time Stepping**\n\nThe domain is discretized by a coarse grid with $N_c$ cells. A sub-region, corresponding to coarse cells $\\{i_L, \\dots, i_R-1\\}$, is refined by a factor $r$, creating a patch of fine cells.\nTo maintain stability, the time step must satisfy the Courant-Friedrichs-Lewy (CFL) condition, $\\Delta t \\le \\frac{\\Delta x}{a}$ for this scheme (with CFL number $\\le 1$). Since the fine grid has smaller cells ($\\Delta x_f = \\Delta x_c / r$), it requires a smaller time step. We use time subcycling: for one coarse time step $\\Delta t_c$, we perform $r$ fine time steps $\\Delta t_f$. To synchronize the grids, we set $\\Delta t_c = r \\Delta t_f$. The fine time step is $\\Delta t_f = \\mathrm{CFL} \\cdot \\Delta x_f / a$.\n\n**3. AMR Algorithm Over One Synchronized Step**\n\nThe algorithm proceeds as follows:\n- **Initialization**: Cell averages on both coarse and fine grids are initialized from the exact continuous initial condition $u(x,0)$. The composite grid state consists of coarse cell values outside the refined patch and fine cell values within it.\n- **Advance Fine Patch**: The fine grid patch is advanced for $r$ sub-steps of size $\\Delta t_f$. For $a>0$, the fine patch requires boundary data at its leftmost face. This data is provided by a ghost cell whose value is set to the value of the adjacent coarse cell, $U_{c, i_L-1}^n$. This value is held constant for all $r$ sub-steps (\"piecewise-constant-in-time\" boundary condition).\n- **Flux Accumulation**: During the $r$ fine sub-steps, we must record the total flux that crosses the coarse-fine interfaces. Let the interfaces be at $x_{i_L-1/2}$ and $x_{i_R-1/2}$. The time-integrated fine flux at the right interface is $\\mathcal{F}_{i_R-1/2}^{\\text{fine}} = \\sum_{k=0}^{r-1} F_{\\text{rightmost fine face}}^k \\Delta t_f$, where $F^k$ is the flux at the $k$-th sub-step.\n- **Advance Coarse Grid**: The coarse cells outside the refined patch are advanced by one step $\\Delta t_c$ using the standard coarse grid numerical fluxes. This is a \"provisional\" update.\n- **Refluxing**: The provisional coarse grid update used a coarse flux at the interface, e.g., $\\mathcal{F}_{i_R-1/2}^{\\text{coarse}} = F_{c, i_R-1/2}^n \\Delta t_c$. This is inconsistent with the more accurate flux computed by the fine grid, $\\mathcal{F}_{i_R-1/2}^{\\text{fine}}$. To ensure conservation, we apply a correction to the adjacent coarse cell. The update for cell $i_R$ receives flux from its left face, $x_{i_R-1/2}$. Its state is corrected by adding the difference in integrated flux:\n$$\n(U_{i_R} \\Delta x_c)^{\\text{corrected}} = (U_{i_R} \\Delta x_c)^{\\text{provisional}} + (\\mathcal{F}_{i_R-1/2}^{\\text{fine}} - \\mathcal{F}_{i_R-1/2}^{\\text{coarse}}).\n$$\nFor the left interface, $x_{i_L-1/2}$, the piecewise-constant-in-time boundary condition implies that the fine boundary flux is constant and equal to the coarse flux, $F_{c, i_L-1/2}^n$. Thus, $\\mathcal{F}_{i_L-1/2}^{\\text{fine}} = (F_{c, i_L-1/2}^n) (r \\Delta t_f) = F_{c, i_L-1/2}^n \\Delta t_c = \\mathcal{F}_{i_L-1/2}^{\\text{coarse}}$. The correction for cell $i_L-1$ is zero.\n- **Restriction**: After the fine grid is fully advanced, the coarse cells $\\{i_L, \\dots, i_R-1\\}$ covered by the patch receive their new values by averaging the final values of their constituent fine cells. For a coarse cell $i_c$, its new value is $U_{i_c}^{n+1} = \\frac{1}{r} \\sum_{k=0}^{r-1} U_{f,j+k}^{n+r}$, where $j$ is the index of the first fine child. This operation is conservative.\n\n**4. Error Quantification**\n\n- **Mass Conservation Error**: The total mass on the AMR hierarchy is the sum of mass in coarse cells outside the patch and mass in fine cells inside the patch. A correctly implemented conservative scheme, including refluxing, must conserve this total mass to machine precision. We compute the absolute difference between the initial total mass and the final total mass.\n- **Projection Error**: At initialization, we can define a fine grid field by prolonging the coarse cell averages. For conservative, piecewise-constant prolongation, each fine cell within a coarse cell $i_c$ is assigned the value $U_{c,i_c}$. The $L^1$ projection error measures the difference between this prolongated field and the true fine-scale representation obtained by directly averaging the initial condition on the fine grid. This error is $E_{L^1} = \\sum_{j \\in \\text{fine patch}} | U_{f,j}^{\\text{prolong}} - U_{f,j}^{\\text{exact}} | \\Delta x_f$. It quantifies the information lost when representing the solution on the coarse grid.\n\nThe provided test cases will verify that the implementation conserves mass and correctly calculates the projection error for both smooth and discontinuous initial data.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the AMR simulation for the specified test cases\n    and print the results in the required format.\n    \"\"\"\n\n    def get_avg_sin(x_L, x_R, k):\n        \"\"\"Computes the exact cell average of sin(2*pi*k*x) over [x_L, x_R].\"\"\"\n        if k == 0:\n            return 0.0\n        \n        width = x_R - x_L\n        if abs(width) < 1e-12:\n            return np.sin(2 * np.pi * k * (x_L + x_R) / 2.0)\n            \n        arg_L = 2 * np.pi * k * x_L\n        arg_R = 2 * np.pi * k * x_R\n        \n        numerator = np.cos(arg_L) - np.cos(arg_R)\n        denominator = 2 * np.pi * k * width\n        \n        return numerator / denominator\n\n    def get_avg_step(x_L, x_R):\n        \"\"\"Computes the exact cell average of I(x in [0, 0.5)) over [x_L, x_R].\"\"\"\n        width = x_R - x_L\n        if abs(width) < 1e-12:\n            return 1.0 if 0 <= (x_L + x_R) / 2.0 < 0.5 else 0.0\n            \n        overlap_start = max(x_L, 0.0)\n        overlap_end = min(x_R, 0.5)\n        \n        overlap_width = max(0.0, overlap_end - overlap_start)\n        \n        return overlap_width / width\n\n    def run_amr_case(Nc, r, patch_bounds, cfl, a, ic_type, ic_params):\n        \"\"\"\n        Executes one full AMR cycle for a given test case configuration.\n        \"\"\"\n        # --- 1. Grid and Parameter Setup ---\n        dx_c = 1.0 / Nc\n        i_L = int(round(patch_bounds[0] / dx_c))\n        i_R = int(round(patch_bounds[1] / dx_c))\n\n        num_fine_cells_in_patch = (i_R - i_L) * r\n        dx_f = dx_c / r\n        \n        dt_f = cfl * dx_f / a\n        dt_c = r * dt_f\n\n        # --- 2. Initialization ---\n        U_c_initial = np.zeros(Nc)\n        for i in range(Nc):\n            x_L_cell, x_R_cell = i * dx_c, (i + 1) * dx_c\n            if ic_type == 'sin':\n                U_c_initial[i] = get_avg_sin(x_L_cell, x_R_cell, **ic_params)\n            elif ic_type == 'step':\n                U_c_initial[i] = get_avg_step(x_L_cell, x_R_cell)\n\n        U_f_initial = np.zeros(num_fine_cells_in_patch)\n        for i_c in range(i_L, i_R):\n            for k in range(r):\n                j = (i_c - i_L) * r + k\n                x_L_fine = i_c * dx_c + k * dx_f\n                x_R_fine = x_L_fine + dx_f\n                if ic_type == 'sin':\n                    U_f_initial[j] = get_avg_sin(x_L_fine, x_R_fine, **ic_params)\n                elif ic_type == 'step':\n                    U_f_initial[j] = get_avg_step(x_L_fine, x_R_fine)\n\n        # --- 3. Compute Initial Mass ---\n        coarse_indices_outside_mask = np.ones(Nc, dtype=bool)\n        coarse_indices_outside_mask[i_L:i_R] = False\n        mass_coarse_outside = np.sum(U_c_initial[coarse_indices_outside_mask]) * dx_c\n        mass_fine_inside = np.sum(U_f_initial) * dx_f\n        mass_total_initial = mass_coarse_outside + mass_fine_inside\n\n        # --- 4. Compute L1 Projection Error ---\n        proj_err = 0.0\n        for i_c in range(i_L, i_R):\n            U_c_prolong = U_c_initial[i_c]\n            for k in range(r):\n                j = (i_c - i_L) * r + k\n                U_f_exact = U_f_initial[j]\n                proj_err += np.abs(U_c_prolong - U_f_exact)\n        proj_err *= dx_f\n\n        # --- 5. AMR Time Step ---\n        U_c_n, U_f_n = U_c_initial.copy(), U_f_initial.copy()\n\n        # 5a. Advance Fine Grid (Subcycling)\n        accumulated_flux_right = 0.0\n        c_left_ghost_idx = (i_L - 1 + Nc) % Nc\n        \n        U_f_current = U_f_n.copy()\n        for _ in range(r):\n            U_f_old_substep = U_f_current.copy()\n            \n            U_f_ext = np.empty(len(U_f_old_substep) + 1)\n            U_f_ext[0] = U_c_n[c_left_ghost_idx]\n            U_f_ext[1:] = U_f_old_substep\n\n            for j in range(len(U_f_current)):\n                flux_left = a * U_f_ext[j]\n                flux_right = a * U_f_ext[j+1]\n                U_f_current[j] = U_f_old_substep[j] - (dt_f / dx_f) * (flux_right - flux_left)\n                \n            flux_at_right_boundary = a * U_f_old_substep[-1]\n            accumulated_flux_right += flux_at_right_boundary * dt_f\n        \n        U_f_final = U_f_current\n\n        # 5b. Advance Coarse Grid (provisional)\n        U_c_final_provisional = np.zeros(Nc)\n        for i in range(Nc):\n            if not coarse_indices_outside_mask[i]:\n                continue\n            i_prev = (i - 1 + Nc) % Nc\n            flux_left = a * U_c_n[i_prev]\n            flux_right = a * U_c_n[i]\n            U_c_final_provisional[i] = U_c_n[i] - (dt_c / dx_c) * (flux_right - flux_left)\n        \n        U_c_final = U_c_final_provisional.copy()\n\n        # 5c. Refluxing\n        i_adj_right = i_R % Nc\n        coarse_flux_integ_right = a * U_c_n[i_R - 1] * dt_c\n        flux_correction = accumulated_flux_right - coarse_flux_integ_right\n        U_c_final[i_adj_right] += flux_correction / dx_c\n\n        # 5d. Restriction\n        for i_c in range(i_L, i_R):\n            j_start = (i_c - i_L) * r\n            j_end = j_start + r\n            U_c_final[i_c] = np.mean(U_f_final[j_start:j_end])\n\n        # --- 6. Compute Final Mass & Error ---\n        mass_coarse_outside_final = np.sum(U_c_final[coarse_indices_outside_mask]) * dx_c\n        mass_fine_inside_final = np.sum(U_f_final) * dx_f\n        mass_total_final = mass_coarse_outside_final + mass_fine_inside_final\n\n        mass_error = np.abs(mass_total_final - mass_total_initial)\n        is_conserved = mass_error < 1e-12\n\n        return mass_error, is_conserved, proj_err\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (Nc, r, patch_bounds, cfl, a, ic_type, ic_params)\n        (16, 2, (0.25, 0.50), 0.5, 1.0, 'sin', {'k': 1}),\n        # Case B:\n        (8, 4, (0.375, 0.625), 0.8, 1.0, 'step', {}),\n        # Case C:\n        (10, 5, (0.2, 0.4), 0.9, 1.0, 'sin', {'k': 3}),\n    ]\n\n    results = []\n    for case in test_cases:\n        mass_err, is_cons, proj_err = run_amr_case(*case)\n        results.extend([mass_err, is_cons, proj_err])\n\n    # Final print statement in the exact required format.\n    # Using specific formatting for floats to ensure precision, and str() for booleans.\n    formatted_results = [f\"{x:.15e}\" if isinstance(x, float) else str(x) for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}