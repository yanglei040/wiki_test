{
    "hands_on_practices": [
        {
            "introduction": "在有限元和有限体积方法中，对网格单元上的函数进行精确积分是计算的核心。由于被积函数可能很复杂，我们通常采用数值求积（如高斯求积）来近似计算这些积分。本练习  将通过一个具体的计算任务，让您亲身体验不同精度的求积法则（精确积分与降阶积分）之间的差异，并量化由此产生的误差，这是理解和分析数值方法误差来源的基础。",
            "id": "3450633",
            "problem": "考虑一个二维线性三角形有限元，该单元取自用于偏微分方程（PDE）数值解的非结构化网格。设该三角形单元的顶点为 $(0,0)$、$(1,0)$ 和 $(0,2)$，因此其面积为 $A=\\frac{1}{2}\\times 1\\times 2=1$。假设由分段光滑场和系数产生的单元被积函数是一个二次多项式\n$$\np(x,y)=3x^{2}-2xy+5y^{2}+4x-y+7.\n$$\n使用高斯求积（GQ）作为一种对特定次数以下的多项式精确的近似积分法则的基本定义，通过对称的3点三角形GQ法则（其插值点以重心坐标形式由等权重的 $\\left(\\frac{2}{3},\\frac{1}{6},\\frac{1}{6}\\right)$ 的排列给出）来计算单元积分 $\\int_{T}p(x,y)\\,\\mathrm{d}A$。然后，通过降阶积分的1点形心法则（重心坐标为 $\\left(\\frac{1}{3},\\frac{1}{3},\\frac{1}{3}\\right)$，单一权重等于 $A$）来计算同一个积分。报告带符号误差 $E=I_{1\\text{-pt}}-I_{\\text{exact}}$，其中 $I_{\\text{exact}}$ 是通过3点法则（该法则对于线性三角形上的二次多项式是精确的）获得的积分值，而 $I_{1\\text{-pt}}$ 是1点形心法则的值。将最终答案表示为一个精确的有理数。无需单位。",
            "solution": "用户提供了一个有效的问题陈述。任务是计算二次多项式 $p(x,y)$ 在特定三角形单元 $T$ 上的积分的带符号误差 $E=I_{1\\text{-pt}}-I_{\\text{exact}}$。$I_{1\\text{-pt}}$ 是通过1点形心法则近似的积分值，$I_{\\text{exact}}$ 是使用对称3点高斯求积（GQ）法则计算的积分值，该法则对此类多项式是精确的。\n\n三角形单元 $T$ 的顶点为 $v_1=(0,0)$，$v_2=(1,0)$ 和 $v_3=(0,2)$。其面积由公式 $A = \\frac{1}{2}|(x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2))| = \\frac{1}{2}|(0(0-2) + 1(2-0) + 0(0-0))| = \\frac{1}{2}|2| = 1$ 给出。这验证了给定的面积 $A=1$。\n\n被积函数是二次多项式 $p(x,y)=3x^{2}-2xy+5y^{2}+4x-y+7$。\n\n首先，我们使用1点形心法则计算积分 $I_{1\\text{-pt}}$。该法则将积分近似为单元面积乘以被积函数在单元形心处的值。\n形心的重心坐标是 $(\\lambda_1, \\lambda_2, \\lambda_3) = (\\frac{1}{3}, \\frac{1}{3}, \\frac{1}{3})$。\n形心的笛卡尔坐标 $(x_c, y_c)$ 是顶点坐标的平均值：\n$$x_c = \\frac{x_1+x_2+x_3}{3} = \\frac{0+1+0}{3} = \\frac{1}{3}$$\n$$y_c = \\frac{y_1+y_2+y_3}{3} = \\frac{0+0+2}{3} = \\frac{2}{3}$$\n求积法则是 $\\int_T p(x,y)\\,\\mathrm{d}A \\approx A \\cdot p(x_c, y_c)$。\n我们在形心 $(x_c, y_c) = (\\frac{1}{3}, \\frac{2}{3})$ 处计算 $p(x,y)$ 的值：\n$$p\\left(\\frac{1}{3}, \\frac{2}{3}\\right) = 3\\left(\\frac{1}{3}\\right)^{2} - 2\\left(\\frac{1}{3}\\right)\\left(\\frac{2}{3}\\right) + 5\\left(\\frac{2}{3}\\right)^{2} + 4\\left(\\frac{1}{3}\\right) - \\left(\\frac{2}{3}\\right) + 7$$\n$$p\\left(\\frac{1}{3}, \\frac{2}{3}\\right) = 3\\left(\\frac{1}{9}\\right) - \\frac{4}{9} + 5\\left(\\frac{4}{9}\\right) + \\frac{4}{3} - \\frac{2}{3} + 7$$\n$$p\\left(\\frac{1}{3}, \\frac{2}{3}\\right) = \\frac{3}{9} - \\frac{4}{9} + \\frac{20}{9} + \\frac{12}{9} - \\frac{6}{9} + \\frac{63}{9} = \\frac{3-4+20+12-6+63}{9} = \\frac{88}{9}$$\n因此，由1点法则得到的积分值为：\n$$I_{1\\text{-pt}} = A \\cdot p\\left(\\frac{1}{3}, \\frac{2}{3}\\right) = 1 \\cdot \\frac{88}{9} = \\frac{88}{9}$$\n\n接下来，我们使用对称3点GQ法则计算积分。问题陈述中提到，该法则对于线性三角形上的二次多项式是精确的，所以结果将是 $I_{\\text{exact}}$。\n该法则由 $\\int_T f(x,y)\\,\\mathrm{d}A \\approx A \\sum_{i=1}^3 w_i f(x_i, y_i)$ 给出。\n权重是相等的，所以 $w_1=w_2=w_3=w$。对于基于重心坐标的法则，权重之和归一化为1，所以 $3w=1$，得出 $w=\\frac{1}{3}$。\n求积点由重心坐标 $(\\lambda_1, \\lambda_2, \\lambda_3)$ 以 $(\\frac{2}{3}, \\frac{1}{6}, \\frac{1}{6})$ 的排列形式给出。\n从重心坐标到笛卡尔坐标 $(x,y)$ 的映射由 $(x,y) = \\lambda_1 v_1 + \\lambda_2 v_2 + \\lambda_3 v_3$ 给出。\n当 $v_1=(0,0)$，$v_2=(1,0)$ 和 $v_3=(0,2)$ 时，映射为：\n$$(x,y) = \\lambda_1(0,0) + \\lambda_2(1,0) + \\lambda_3(0,2) = (\\lambda_2, 2\\lambda_3)$$\n我们现在求出三个求积点的笛卡尔坐标，并在每个点上计算多项式的值。\n\n点 1：$(\\lambda_1, \\lambda_2, \\lambda_3) = (\\frac{2}{3}, \\frac{1}{6}, \\frac{1}{6})$。\n笛卡尔坐标：$(x_1, y_1) = (\\frac{1}{6}, 2 \\cdot \\frac{1}{6}) = (\\frac{1}{6}, \\frac{1}{3})$。\n$$p\\left(\\frac{1}{6}, \\frac{1}{3}\\right) = 3\\left(\\frac{1}{36}\\right) - 2\\left(\\frac{1}{6}\\right)\\left(\\frac{1}{3}\\right) + 5\\left(\\frac{1}{9}\\right) + 4\\left(\\frac{1}{6}\\right) - \\frac{1}{3} + 7 = \\frac{3}{36} - \\frac{2}{18} + \\frac{5}{9} + \\frac{4}{6} - \\frac{1}{3} + 7$$\n$$p\\left(\\frac{1}{6}, \\frac{1}{3}\\right) = \\frac{3}{36} - \\frac{4}{36} + \\frac{20}{36} + \\frac{24}{36} - \\frac{12}{36} + \\frac{252}{36} = \\frac{283}{36}$$\n\n点 2：$(\\lambda_1, \\lambda_2, \\lambda_3) = (\\frac{1}{6}, \\frac{2}{3}, \\frac{1}{6})$。\n笛卡尔坐标：$(x_2, y_2) = (\\frac{2}{3}, 2 \\cdot \\frac{1}{6}) = (\\frac{2}{3}, \\frac{1}{3})$。\n$$p\\left(\\frac{2}{3}, \\frac{1}{3}\\right) = 3\\left(\\frac{4}{9}\\right) - 2\\left(\\frac{2}{3}\\right)\\left(\\frac{1}{3}\\right) + 5\\left(\\frac{1}{9}\\right) + 4\\left(\\frac{2}{3}\\right) - \\frac{1}{3} + 7 = \\frac{12}{9} - \\frac{4}{9} + \\frac{5}{9} + \\frac{8}{3} - \\frac{1}{3} + 7$$\n$$p\\left(\\frac{2}{3}, \\frac{1}{3}\\right) = \\frac{12-4+5}{9} + \\frac{24-3}{9} + \\frac{63}{9} = \\frac{13+21+63}{9} = \\frac{97}{9} = \\frac{388}{36}$$\n\n点 3：$(\\lambda_1, \\lambda_2, \\lambda_3) = (\\frac{1}{6}, \\frac{1}{6}, \\frac{2}{3})$。\n笛卡尔坐标：$(x_3, y_3) = (\\frac{1}{6}, 2 \\cdot \\frac{2}{3}) = (\\frac{1}{6}, \\frac{4}{3})$。\n$$p\\left(\\frac{1}{6}, \\frac{4}{3}\\right) = 3\\left(\\frac{1}{36}\\right) - 2\\left(\\frac{1}{6}\\right)\\left(\\frac{4}{3}\\right) + 5\\left(\\frac{16}{9}\\right) + 4\\left(\\frac{1}{6}\\right) - \\frac{4}{3} + 7 = \\frac{3}{36} - \\frac{8}{18} + \\frac{80}{9} + \\frac{4}{6} - \\frac{4}{3} + 7$$\n$$p\\left(\\frac{1}{6}, \\frac{4}{3}\\right) = \\frac{3}{36} - \\frac{16}{36} + \\frac{320}{36} + \\frac{24}{36} - \\frac{48}{36} + \\frac{252}{36} = \\frac{3-16+320+24-48+252}{36} = \\frac{535}{36}$$\n\n现在，我们计算精确的积分值：\n$$I_{\\text{exact}} = A \\sum_{i=1}^3 w_i p(x_i, y_i) = 1 \\cdot \\frac{1}{3} \\left( p(x_1, y_1) + p(x_2, y_2) + p(x_3, y_3) \\right)$$\n$$I_{\\text{exact}} = \\frac{1}{3} \\left( \\frac{283}{36} + \\frac{388}{36} + \\frac{535}{36} \\right) = \\frac{1}{3} \\left( \\frac{283+388+535}{36} \\right) = \\frac{1}{3} \\left( \\frac{1206}{36} \\right)$$\n化简分数 $\\frac{1206}{36}$：$\\frac{1206 \\div 6}{36 \\div 6} = \\frac{201}{6} = \\frac{201 \\div 3}{6 \\div 3} = \\frac{67}{2}$。\n$$I_{\\text{exact}} = \\frac{1}{3} \\cdot \\frac{67}{2} = \\frac{67}{6}$$\n\n最后，我们计算带符号误差 $E = I_{1\\text{-pt}} - I_{\\text{exact}}$：\n$$E = \\frac{88}{9} - \\frac{67}{6}$$\n9 和 6 的最小公倍数是 18。\n$$E = \\frac{88 \\cdot 2}{18} - \\frac{67 \\cdot 3}{18} = \\frac{176}{18} - \\frac{201}{18} = \\frac{176 - 201}{18} = -\\frac{25}{18}$$\n带符号误差为 $-\\frac{25}{18}$。",
            "answer": "$$\\boxed{-\\frac{25}{18}}$$"
        },
        {
            "introduction": "单个单元的计算精度是基础，但整个网格的质量对全局解的稳定性和准确性有着决定性影响。在非结构网格生成中，我们常常会遇到“薄片”或“退化”单元，它们几何形状极差。本实践练习  是一个编程任务，旨在引导您研究这些劣质单元如何导致有限元刚度矩阵的条件数恶化，并最终污染数值解的精度，从而深刻理解网格质量控制在科学计算中的重要性。",
            "id": "3450603",
            "problem": "您将研究非结构化网格中极度扁平的四面体（通常称为狭长体）如何影响有限元法 (FEM) 刚度矩阵的条件数以及三维泊松问题数值解的精度。在域 $\\Omega = (0,1)^3$ 中研究标量场 $u$。考虑使用拉普拉斯算子的模型问题，即泊松方程\n$$\n\\Delta u = f \\text{ in } \\Omega,\n$$\n其狄利克雷边界条件为\n$$\nu = u^\\star \\text{ on } \\partial \\Omega,\n$$\n其中精确解被指定为二次多项式\n$$\nu^\\star(x,y,z) = x^2 + y^2 + z^2,\n$$\n因此源项是其拉普拉斯\n$$\nf = \\Delta u^\\star = 2 + 2 + 2 = 6.\n$$\n您将使用标准的连续伽辽金有限元法 (CG-FEM)，在四面体上采用一阶分片线性基函数。刚度矩阵 $K$ 的元素为\n$$\nK_{ij} = \\int_{\\Omega} \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, d\\Omega,\n$$\n载荷向量 $b$ 的元素为\n$$\nb_i = \\int_{\\Omega} f \\, \\phi_i \\, d\\Omega,\n$$\n其中 $\\{\\phi_i\\}$ 是节点基函数。使用逐单元集成法，并对每个顶点为 $\\mathbf{p}_0,\\mathbf{p}_1,\\mathbf{p}_2,\\mathbf{p}_3 \\in \\mathbb{R}^3$ 的四面体采用以下基本几何构造：\n- 定义 $3 \\times 3$ 的类雅可比矩阵\n$$\nT = \\big[ \\mathbf{p}_1 - \\mathbf{p}_0 \\ \\ \\mathbf{p}_2 - \\mathbf{p}_0 \\ \\ \\mathbf{p}_3 - \\mathbf{p}_0 \\big].\n$$\n- 单元体积为\n$$\nV_e = \\frac{|\\det(T)|}{6}.\n$$\n- 物理坐标系中线性形函数的梯度在单元上是常数，可通过参考单元的梯度计算得到\n$$\n\\nabla \\phi_0 = -T^{-\\top} \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}, \\quad\n\\nabla \\phi_1 = T^{-\\top} \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\n\\nabla \\phi_2 = T^{-\\top} \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\end{bmatrix}, \\quad\n\\nabla \\phi_3 = T^{-\\top} \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}.\n$$\n- 单元刚度矩阵为\n$$\nK^{(e)}_{ij} = V_e \\, \\nabla \\phi_i \\cdot \\nabla \\phi_j.\n$$\n- 由于 $f$ 是常数，使用精确的单元载荷向量\n$$\nb^{(e)}_i = f \\, \\int_{e} \\phi_i \\, d\\Omega = f \\, \\frac{V_e}{4}.\n$$\n通过消除边界自由度来施加狄利克雷边界条件：将未知向量写为 $u = \\begin{bmatrix} u_I \\\\ u_B \\end{bmatrix}$，分别对应内部节点和边界节点，然后求解\n$$\nK_{II} \\, u_I = b_I - K_{IB} u_B\n$$\n其中 $u_B$ 设置为在边界节点处求值的精确解 $u^\\star$ 得到的精确边界值。求解后，通过插入 $u_I$ 和 $u_B$ 来恢复完整向量 $u$。\n\n网格生成和狭长体控制必须按以下步骤进行。从一个六面体结构化网格开始，该网格通过在 $\\Omega$ 上每个坐标轴进行 $N$ 次均匀剖分形成。然后，使用一致的长对角线模式将每个六面体分割成 $6$ 个四面体，从而创建一个非结构化的四面体网格。为引入狭长体，在平面 $z = 1/2$ 周围的一个板层内应用各向异性几何畸变：\n- 固定板层半宽度 $w = 1/4$，板层中心 $z_0 = 1/2$，以及缩放因子 $s \\in (0,1]$。\n- 对于每个坐标为 $z$ 的网格节点，如果 $|z - z_0| \\le w$，则将其映射到\n$$\nz' = z_0 + s \\, (z - z_0),\n$$\n否则保持不变。这将板层的厚度压缩了因子 $s$，并在 $s \\ll 1$ 时产生高度非常小的狭长四面体。\n作为一种几何狭长体移除策略，通过映射\n$$\nz' = z_0 + \\max(s, s_{\\min}) \\, (z - z_0)\n$$\n对畸变网格进行后处理，在板层中为所有满足 $|z - z_0| \\le w$ 的节点强制施加一个最小尺度 $s_{\\min} \\in (0,1]$。这个简单的策略增加了板层中四面体的最小高度。\n\n量化以下指标：\n- 消元后的刚度矩阵 $K_{II}$ 的谱条件数，定义为\n$$\n\\kappa(K_{II}) = \\frac{\\lambda_{\\max}(K_{II})}{\\lambda_{\\min}(K_{II})},\n$$\n其中 $\\lambda_{\\max}$ 和 $\\lambda_{\\min}$ 分别是最大和最小特征值。\n- FEM 解 $u_h$ 相对于 $u^\\star$ 的相对离散 $L^2$ 误差，通过逐单元质心积分近似：\n$$\n\\| e \\|_{L^2(\\Omega)} \\approx \\left( \\sum_{e} V_e \\, \\big( u_h(\\mathbf{c}_e) - u^\\star(\\mathbf{c}_e) \\big)^2 \\right)^{1/2},\n$$\n$$\n\\| u^\\star \\|_{L^2(\\Omega)} \\approx \\left( \\sum_{e} V_e \\, \\big( u^\\star(\\mathbf{c}_e) \\big)^2 \\right)^{1/2},\n$$\n$$\n\\text{RelErr} = \\frac{\\| e \\|_{L^2(\\Omega)}}{\\| u^\\star \\|_{L^2(\\Omega)}},\n$$\n其中 $\\mathbf{c}_e$ 是四面体 $e$ 的质心，$u_h(\\mathbf{c}_e)$ 是该四面体上 $u_h$ 节点值的平均值（对于线性的 $u_h$ 在质心处，这个值是精确的）。\n\n实现一个程序，该程序构建网格，集成并求解 FEM 系统，计算 $\\kappa(K_{II})$ 和 $\\text{RelErr}$，并为以下测试套件汇总结果：\n- 测试 1（基准，形状良好）：$N = 6$, $s = 1.0$，无狭长体移除（无后处理）。\n- 测试 2（中度狭长体）：$N = 6$, $s = 0.2$，无狭长体移除。\n- 测试 3（极端狭长体）：$N = 6$, $s = 0.02$，无狭长体移除。\n- 测试 4（应用狭长体移除）：$N = 6$, $s = 0.02$，使用 $s_{\\min} = 0.2$ 进行狭长体移除。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果严格按以下顺序排列\n$$\n[\\kappa_1,\\text{RelErr}_1,\\kappa_2,\\text{RelErr}_2,\\kappa_3,\\text{RelErr}_3,\\kappa_4,\\text{RelErr}_4],\n$$\n其中 $\\kappa_i$ 和 $\\text{RelErr}_i$ 对应于测试 $i$（$i \\in \\{1,2,3,4\\}$）。所有输出必须是不带单位的实数。无需用户输入；所有参数必须如上所述在代码中定义。请遵守此处陈述的定义和程序，并仅使用指定的数值库，以确保科学真实性。",
            "solution": "该问题被评估为有效。这是一个适定的、科学上合理的数值实验，旨在研究网格质量对有限元法 (FEM) 的影响。所有必要的参数、方程和程序均已提供，从而可以得到唯一且可验证的解。\n\n核心任务是求解三维泊松方程 $\\Delta u = f$，其定义域为 $\\Omega = (0,1)^3$。精确解给定为 $u^\\star(x,y,z) = x^2 + y^2 + z^2$，这意味着源项是一个常数 $f = \\Delta u^\\star = 6$。指定了狄利克雷边界条件，边界 $\\partial \\Omega$ 上 $u = u^\\star$。我们将采用连续伽辽金 FEM，在四面体网格上使用分片线性基函数。\n\n求解过程包括四个主要阶段：网格生成、FEM 系统集成、代数系统求解以及分析指标（条件数和误差）的计算。对四个不同的测试案例重复此过程，每个案例都具有不同程度的网格畸变。\n\n**1. 网格生成与畸变**\n\n首先，在一组均匀的笛卡尔网格上生成一组节点。对于沿每个轴的 $N$ 个剖分，我们得到 $(N+1)^3$ 个节点 $\\mathbf{p}_{ijk} = (x_i, y_j, z_k)$，其中 $x_i = i/N$, $y_j = j/N$, $z_k = k/N$，对于 $i,j,k \\in \\{0, 1, \\dots, N\\}$。\n\n随后，对这种规则的节点分布施加各向异性几何畸变，以产生形状差的“狭长”四面体。该畸变作用于位于板层 $z \\in [z_0 - w, z_0 + w]$ 内的节点的 $z$ 坐标，其中中心为 $z_0 = 1/2$，半宽度为 $w = 1/4$。对于任何 $z$ 坐标满足 $|z - z_0| \\le w$ 的节点，其坐标根据以下公式进行映射：\n$$\nz' = z_0 + s_{\\text{eff}} (z - z_0)\n$$\n其中 $s_{\\text{eff}}$ 是一个有效缩放因子。对于没有进行狭长体移除的测试，$s_{\\text{eff}} = s$。对于进行了狭长体移除的测试，缩放因子被修正以强制保证最低质量，得到 $s_{\\text{eff}} = \\max(s, s_{\\min})$。板层外的节点保持不变。这种变换在板层内沿 $z$ 方向压缩网格，较小的 $s_{\\text{eff}}$ 值会导致更极端的压缩和更扁平的单元。\n\n域 $\\Omega$ 被剖分成 $N^3$ 个六面体单元。每个六面体随后基于其主体对角线，使用一致的模式被细分为 $6$ 个四面体。对于一个局部角顶点索引为 $p_0, \\dots, p_7$ 的六面体，我们使用连接 $p_0$ 和 $p_6$ 的对角线。这六个四面体是通过取在该对角线上相交的成对相邻面形成的。对于一个由网格索引 $(i,j,k)$ 到 $(i+1,j+1,k+1)$ 定义的六面体，这将产生以下六个由其全局节点索引指定的四面体：\n- $(\\text{idx}(i,j,k), \\text{idx}(i+1,j,k), \\text{idx}(i+1,j+1,k), \\text{idx}(i+1,j+1,k+1))$\n- $(\\text{idx}(i,j,k), \\text{idx}(i,j+1,k), \\text{idx}(i+1,j+1,k), \\text{idx}(i+1,j+1,k+1))$\n- $(\\text{idx}(i,j,k), \\text{idx}(i,j+1,k), \\text{idx}(i,j+1,k+1), \\text{idx}(i+1,j+1,k+1))$\n- $(\\text{idx}(i,j,k), \\text{idx}(i,j,k+1), \\text{idx}(i,j+1,k+1), \\text{idx}(i+1,j+1,k+1))$\n- $(\\text{idx}(i,j,k), \\text{idx}(i,j,k+1), \\text{idx}(i+1,j,k+1), \\text{idx}(i+1,j+1,k+1))$\n- $(\\text{idx}(i,j,k), \\text{idx}(i+1,j,k), \\text{idx}(i+1,j,k+1), \\text{idx}(i+1,j+1,k+1))$\n这就构成了最终的非结构化四面体网格。\n\n**2. 有限元系统集成**\n\nFEM 离散化得到一个线性方程组 $K u = b$。全局刚度矩阵 $K$ 和载荷向量 $b$ 由单元级的贡献组装而成。对于每个顶点为 $\\mathbf{p}_0, \\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3$ 的四面体单元 $e$：\n\n- 从顶点 $\\mathbf{p}_0$ 出发的单元边向量构成一个 $3 \\times 3$ 矩阵 $T$：$T = [\\mathbf{p}_1 - \\mathbf{p}_0, \\mathbf{p}_2 - \\mathbf{p}_0, \\mathbf{p}_3 - \\mathbf{p}_0]$。\n- 单元的体积为 $V_e = |\\det(T)| / 6$。\n- 四个线性基函数 $\\phi_i$ 的梯度在单元内是常数，并使用 $T$ 的逆转置计算：$\\nabla\\phi_0 = -T^{-\\top}[1,1,1]^\\top$，$\\nabla\\phi_1=T^{-\\top}[1,0,0]^\\top$ 等。\n- $4 \\times 4$ 的单元刚度矩阵 $K^{(e)}$ 的元素为 $K^{(e)}_{ij} = V_e (\\nabla \\phi_i \\cdot \\nabla \\phi_j)$。\n- $4 \\times 1$ 的单元载荷向量 $b^{(e)}$ 的元素为 $b^{(e)}_i = f (V_e / 4)$，其中 $f=6$。\n\n然后，这些局部矩阵和向量根据单元顶点的全局索引被累加到相应的全局数组中。\n\n**3. 边界条件与求解**\n\n通过将节点划分为内部 ($I$) 和边界 ($B$) 集合来施加狄利克雷边界条件。全局系统 $K u = b$ 被重排为：\n$$\n\\begin{bmatrix} K_{II}  K_{IB} \\\\ K_{BI}  K_{BB} \\end{bmatrix}\n\\begin{bmatrix} u_I \\\\ u_B \\end{bmatrix}\n=\n\\begin{bmatrix} b_I \\\\ b_B \\end{bmatrix}\n$$\n边界节点处解的值 $u_B$ 是已知的，因为它们是由精确解指定的：$u_B = u^\\star(\\mathbf{p}_B)$，其中 $\\mathbf{p}_B$ 是边界节点的坐标。这使我们能够通过简化的系统求解未知的内部值 $u_I$：\n$$\nK_{II} u_I = b_I - K_{IB} u_B\n$$\n对此线性系统求解 $u_I$。矩阵 $K_{II}$ 是对称正定的，保证了唯一解的存在。\n\n**4. 性能指标**\n\n计算两个关键指标来评估网格畸变的影响：\n\n- **谱条件数**：矩阵 $K_{II}$ 的条件由其谱条件数 $\\kappa(K_{II}) = \\lambda_{\\max}(K_{II}) / \\lambda_{\\min}(K_{II})$ 来衡量，其中 $\\lambda_{\\max}$ 和 $\\lambda_{\\min}$ 分别是 $K_{II}$ 的最大和最小特征值。高条件数表示数值敏感性高，可能给迭代求解器带来困难。特征值由组装好的矩阵 $K_{II}$ 计算得出。\n\n- **相对 $L^2$ 误差**：数值解 $u_h$ 的精度由（离散）$L^2$ 范数下的相对误差来量化。这通过在所有单元上使用基于质心的求积法则来近似：\n$$\n\\text{RelErr} = \\frac{\\| u_h - u^\\star \\|_{L^2(\\Omega)}}{\\| u^\\star \\|_{L^2(\\Omega)}} \\approx \\frac{\\left( \\sum_{e} V_e \\, (u_h(\\mathbf{c}_e) - u^\\star(\\mathbf{c}_e))^2 \\right)^{1/2}}{\\left( \\sum_{e} V_e \\, (u^\\star(\\mathbf{c}_e))^2 \\right)^{1/2}}\n$$\n此处，$\\mathbf{c}_e$ 是四面体 $e$ 的质心。对于线性有限元，解 $u_h$ 在质心处的值恰好是其四个节点值的平均值。\n\n对指定的四个测试案例分别执行该程序：一个无畸变的基准案例（$s=1.0$），两个分别有中度（$s=0.2$）和极端（$s=0.02$）畸变的案例，以及一个演示狭长体移除的最终案例，该案例使用最小缩放因子 $s_{\\min}=0.2$ 重新映射极端狭长体案例的几何形状。预计这最后一个测试案例将恢复中度狭长体案例的结果，因为有效缩放因子变为 $\\max(0.02, 0.2) = 0.2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ... is not needed for this problem\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, s, s_min_option) where s_min_option is s_min or None.\n    test_cases = [\n        (6, 1.0, None),    # Test 1: Baseline\n        (6, 0.2, None),    # Test 2: Moderate slivers\n        (6, 0.02, None),   # Test 3: Extreme slivers\n        (6, 0.02, 0.2),    # Test 4: Sliver removal\n    ]\n\n    # Source term f for the Poisson equation.\n    f_source = 6.0\n\n    # Exact solution u_star(x,y,z) = x^2 + y^2 + z^2\n    def u_star(p):\n        return p[0]**2 + p[1]**2 + p[2]**2\n\n    results = []\n    for N, s, s_min_option in test_cases:\n        kappa, rel_err = run_simulation(N, s, s_min_option, f_source, u_star)\n        results.extend([kappa, rel_err])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\ndef run_simulation(N, s, s_min_option, f, u_star_func):\n    \"\"\"\n    Performs a single FEM simulation for a given set of parameters.\n    \"\"\"\n    \n    # --- 1. Mesh Generation ---\n    w = 0.25  # Slab half-width\n    z0 = 0.5  # Slab center\n    \n    s_eff = s\n    if s_min_option is not None:\n        s_eff = max(s, s_min_option)\n\n    # Generate nodes\n    num_nodes = (N + 1)**3\n    nodes = np.zeros((num_nodes, 3))\n    node_idx = lambda i, j, k: i + j * (N + 1) + k * (N + 1)**2\n    \n    for k in range(N + 1):\n        for j in range(N + 1):\n            for i in range(N + 1):\n                idx = node_idx(i, j, k)\n                x, y, z = i/N, j/N, k/N\n                if abs(z - z0) = w:\n                    z = z0 + s_eff * (z - z0)\n                nodes[idx] = [x, y, z]\n\n    # Generate tetrahedra from hexahedra\n    num_hex = N**3\n    num_tets = 6 * num_hex\n    tets = np.zeros((num_tets, 4), dtype=int)\n    \n    tet_idx = 0\n    for k in range(N):\n        for j in range(N):\n            for i in range(N):\n                # 8 corners of the hex, (i,j,k) to (i+1,j+1,k+1)\n                p0_idx = node_idx(i, j, k)\n                p1_idx = node_idx(i+1, j, k)\n                p2_idx = node_idx(i, j+1, k)\n                p3_idx = node_idx(i+1, j+1, k)\n                p4_idx = node_idx(i, j, k+1)\n                p5_idx = node_idx(i+1, j, k+1)\n                p6_idx = node_idx(i, j+1, k+1)\n                p7_idx = node_idx(i+1, j+1, k+1)\n                \n                # Split hex into 6 tets using main diagonal p0-p7\n                tets[tet_idx + 0] = [p0_idx, p1_idx, p3_idx, p7_idx]\n                tets[tet_idx + 1] = [p0_idx, p2_idx, p3_idx, p7_idx]\n                tets[tet_idx + 2] = [p0_idx, p2_idx, p6_idx, p7_idx]\n                tets[tet_idx + 3] = [p0_idx, p4_idx, p6_idx, p7_idx]\n                tets[tet_idx + 4] = [p0_idx, p4_idx, p5_idx, p7_idx]\n                tets[tet_idx + 5] = [p0_idx, p1_idx, p5_idx, p7_idx]\n                tet_idx += 6\n\n    # Identify interior and boundary nodes\n    is_boundary = np.zeros(num_nodes, dtype=bool)\n    for k in range(N + 1):\n        for j in range(N + 1):\n            for i in range(N + 1):\n                if i == 0 or i == N or j == 0 or j == N or k == 0 or k == N:\n                    is_boundary[node_idx(i, j, k)] = True\n    \n    interior_nodes = np.where(~is_boundary)[0]\n    boundary_nodes = np.where(is_boundary)[0]\n    num_interior = len(interior_nodes)\n\n    global_to_interior_map = {glob_idx: i for i, glob_idx in enumerate(interior_nodes)}\n\n    # --- 2. FEM Assembly ---\n    K_II = np.zeros((num_interior, num_interior))\n    K_IB = np.zeros((num_interior, len(boundary_nodes)))\n    b_I = np.zeros(num_interior)\n    \n    # Gradients of barycentric coordinates on reference tet\n    grad_ref = np.array([[-1,-1,-1], [1,0,0], [0,1,0], [0,0,1]], dtype=float).T\n\n    for tet in tets:\n        p0, p1, p2, p3 = nodes[tet[0]], nodes[tet[1]], nodes[tet[2]], nodes[tet[3]]\n        \n        T = np.array([p1 - p0, p2 - p0, p3 - p0]).T\n        T_inv_T = np.linalg.inv(T).T\n        \n        det_T = np.linalg.det(T)\n        vol = abs(det_T) / 6.0\n        \n        # Gradients in physical coordinates\n        grad_phi = T_inv_T @ grad_ref\n        \n        # Element stiffness matrix\n        K_e = vol * (grad_phi.T @ grad_phi)\n        \n        # Element load vector\n        b_e = f * vol / 4.0\n        \n        # Assemble into global system (partitioned)\n        for i_local in range(4):\n            glob_i = tet[i_local]\n            is_i_interior = not is_boundary[glob_i]\n\n            if is_i_interior:\n                ii = global_to_interior_map[glob_i]\n                b_I[ii] += b_e\n                \n            for j_local in range(4):\n                glob_j = tet[j_local]\n                is_j_interior = not is_boundary[glob_j]\n                \n                if is_i_interior and is_j_interior:\n                    ii = global_to_interior_map[glob_i]\n                    jj = global_to_interior_map[glob_j]\n                    K_II[ii, jj] += K_e[i_local, j_local]\n                elif is_i_interior and not is_j_interior:\n                    ii = global_to_interior_map[glob_i]\n                    bj = np.where(boundary_nodes == glob_j)[0][0]\n                    K_IB[ii, bj] += K_e[i_local, j_local]\n\n    # --- 3. Apply BCs and Solve ---\n    u_B = np.array([u_star_func(nodes[idx]) for idx in boundary_nodes])\n    \n    rhs = b_I - K_IB @ u_B\n    u_I = np.linalg.solve(K_II, rhs)\n\n    # --- 4. Compute Metrics ---\n    # Condition number\n    eigvals = np.linalg.eigvalsh(K_II)\n    kappa = eigvals[-1] / eigvals[0]\n    \n    # Reconstruct full solution vector\n    u_full = np.zeros(num_nodes)\n    u_full[interior_nodes] = u_I\n    u_full[boundary_nodes] = u_B\n\n    # L2 Error\n    err_sq_norm = 0.0\n    ustar_sq_norm = 0.0\n    for tet in tets:\n        p_coords = nodes[tet]\n        centroid = np.mean(p_coords, axis=0)\n        \n        # Volume of current tet\n        p0, p1, p2, p3 = p_coords[0], p_coords[1], p_coords[2], p_coords[3]\n        T_mat = np.array([p1 - p0, p2 - p0, p3 - p0]).T\n        vol = abs(np.linalg.det(T_mat)) / 6.0\n        \n        u_h_centroid = np.mean(u_full[tet])\n        u_star_centroid = u_star_func(centroid)\n        \n        err_sq_norm += vol * (u_h_centroid - u_star_centroid)**2\n        ustar_sq_norm += vol * (u_star_centroid)**2\n\n    rel_err = np.sqrt(err_sq_norm / ustar_sq_norm) if ustar_sq_norm > 0 else 0.0\n    \n    return kappa, rel_err\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "静态的均匀网格在处理局部具有复杂特征的物理问题时效率低下，自适应网格加密（AMR）技术应运而生，它能将计算资源动态地集中在最需要的区域。然而，对于守恒律方程，保证在粗细网格界面处物理量的守恒是一个核心挑战。本高级编程练习  旨在让您亲手实现一个保证守恒的AMR方案，通过实践“通量修正”（refluxing）这一关键技术，确保在多层级网格间传递信息时，物理守恒量（如总质量）得到严格保持。",
            "id": "3450641",
            "problem": "您需要为一维空间中的标量守恒律形式化并实现一个两层自适应网格加密（AMR）策略，重点关注有限体积法的结构化和非结构化网格原理。控制方程是线性平流守恒律\n$$\n\\partial_t u + \\partial_x f(u) = 0,\\quad f(u) = a\\,u,\n$$\n定义在周期性域 $[0,1]$ 上，具有恒定的平流速度 $a0$。本任务的核心是设计粗化和加密规则，通过通量修正（refluxing）来保证跨层级的守恒性，并量化由守恒投影引入的误差。\n\n您必须从基本定义出发：守恒律的控制体积形式、有限体积法中的离散守恒、通量一致性，以及任何层级间的守恒传递都必须保持单元积分量不变的概念。避免在这些基本原理之外依赖任何未经证明的公式。\n\n在单个程序中实现以下设计：\n\n- 用包含 $N_c$ 个单元的均匀粗网格离散化 $[0,1]$，单元宽度为 $\\Delta x_c = 1/N_c$。\n- 定义一个与粗网格单元边界对齐的单一加密区域，覆盖一组连续的粗单元 $i\\in\\{i_L,\\dots,i_R-1\\}$，并按整数因子 $r\\in\\mathbb{N}$ 进行加密，仅在该区域内生成宽度为 $\\Delta x_f = \\Delta x_c/r$ 的细网格单元。\n- 对于 $a0$，使用一阶迎风有限体积格式。设 $F_{i+1/2}=a\\,U_i$ 表示在分片常数数据下，单元 $i$ 右侧界面上的数值通量。\n- 使用时间子循环：取一个细网格时间步长 $\\Delta t_f = \\mathrm{CFL}\\cdot \\Delta x_f/a$ 和一个粗网格步长 $\\Delta t_c = r\\,\\Delta t_f$，以使各层级在一个粗网格步长后同步。在粗细网格界面处，假设边界数据在时间上是分片常数，用于填充细网格的虚拟单元值。在粗网格层级上使用周期性边界条件。细网格加密区域严格位于域的内部。\n- 在子循环期间，累积穿过两个粗细网格界面的时间积分细网格通量。在粗网格层级推进一个步长后，对与加密区域相邻的两个粗单元应用通量修正（refluxing），将该界面上的粗网格时间积分通量替换为累积的细网格时间积分通量。然后执行守恒限制（从细到粗），即将细单元平均值平均化到加密区域内其对应的父粗单元上。\n- 将守恒的粗到细投影（延拓）定义为分片常数注入：一个粗单元的每个子细单元接收其父粗单元的平均值。通过计算延拓场与初始数据的精确细单元平均值在加密区域上的 $L^1$ 单元平均不匹配度，来量化此守恒投影在初始时刻引入的误差。\n\n为获得可复现和可验证的结果，请通过精确单元平均值进行以下初始化：\n\n- 对于三角函数情况，设 $u(x)=\\sin(2\\pi k x)$，其中整数 $k\\ge 1$，其在区间 $[x_L,x_R]$ 上的精确单元平均值为\n$$\n\\bar{u} = \\frac{1}{x_R-x_L}\\int_{x_L}^{x_R}\\sin(2\\pi k x)\\,dx = \\frac{\\cos(2\\pi k x_L)-\\cos(2\\pi k x_R)}{2\\pi k (x_R-x_L)}.\n$$\n- 对于不连续阶跃情况，设当 $x \\in [0,\\tfrac{1}{2})$ 时 $u(x)=1$，否则 $u(x)=0$。其精确单元平均值是单元与 $[0,\\tfrac{1}{2})$ 的重叠长度除以单元宽度。\n\n您的程序必须为每个测试计算以下输出：\n- 在经过一个带通量修正的同步粗网格步长后，计算出的绝对总质量误差。该误差通过计算 $[0,1]$ 上 $u$ 的总积分在步长开始和结束时的差值的绝对值得到，其中层级质量是通过对加密区域外的粗单元和加密区域内的细单元求和来测量的。\n- 一个布尔值，指示守恒性是否在 $10^{-12}$ 的容差内得到满足，即绝对质量误差是否小于 $10^{-12}$。\n- 初始时刻在加密区域上守恒粗到细投影的绝对 $L^1$ 投影误差，定义为\n$$\nE_{L^1} = \\sum_{j\\in \\text{fine patch}} \\left| U^{\\text{prolong}}_{f,j} - \\bar{u}_j \\right|\\,\\Delta x_f,\n$$\n其中 $U^{\\text{prolong}}_{f,j}$ 是从粗网格层级通过守恒延拓得到的细网格值，而 $\\bar{u}_j$ 是初始数据的精确细单元平均值。\n\n测试套件。请在以下三个精确情况下运行程序，这三个情况共同探测了光滑模式、不连续性和高频内容，所有情况均设置 $a=1$：\n\n- 情况 A（光滑模式）：$N_c=16$，$r=2$，加密区域 $[0.25,0.50]$，$\\mathrm{CFL}=0.5$，$u(x)=\\sin(2\\pi\\cdot 1\\cdot x)$。\n- 情况 B（不连续性）：$N_c=8$，$r=4$，加密区域 $[0.375,0.625]$，$\\mathrm{CFL}=0.8$，$u(x)=\\mathbf{1}_{[0,1/2)}(x)$。\n- 情况 C（更高频率）：$N_c=10$，$r=5$，加密区域 $[0.2,0.4]$，$\\mathrm{CFL}=0.9$，$u(x)=\\sin(2\\pi\\cdot 3\\cdot x)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个扁平的、逗号分隔的 Python 风格列表，该列表按确切顺序包含九个条目\n$$\n[\\text{mass\\_err}_A,\\ \\text{is\\_cons}_A,\\ \\text{proj\\_err}_A,\\ \\text{mass\\_err}_B,\\ \\text{is\\_cons}_B,\\ \\text{proj\\_err}_B,\\ \\text{mass\\_err}_C,\\ \\text{is\\_cons}_C,\\ \\text{proj\\_err}_C],\n$$\n其中 $\\text{mass\\_err}$ 和 $\\text{proj\\_err}$ 是浮点数，$\\text{is\\_cons}$ 是布尔值。不应打印任何其他文本。",
            "solution": "该问题要求为一维线性平流方程 $\\partial_t u + a \\partial_x u = 0$（在周期性域 $[0,1]$ 上）形式化并实现一个两层自适应网格加密（AMR）方案。该实现必须基于有限体积法，并且必须使用通量修正（refluxing）来正确处理粗细网格界面处的守恒性。\n\n**1. 有限体积离散化与守恒性**\n\n守恒律在一个宽度为 $\\Delta x_i = x_{i+1/2} - x_{i-1/2}$ 的控制体积（单元）$[x_{i-1/2}, x_{i+1/2}]$ 上的积分形式是基础：\n$$\n\\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx + f(u(x_{i+1/2},t)) - f(u(x_{i-1/2},t)) = 0.\n$$\n定义单元平均值 $U_i(t) = \\frac{1}{\\Delta x_i} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$，方程变为：\n$$\n\\frac{d}{dt} U_i(t) = -\\frac{1}{\\Delta x_i} [f(u(x_{i+1/2},t)) - f(u(x_{i-1/2},t))].\n$$\n有限体积法在时间上对此进行离散，并近似单元界面处的通量 $f(u)$。我们使用一阶欧拉时间步长和一阶迎风格式通量。对于平流速度 $a0$，界面 $i+1/2$ 处的通量取决于其左侧单元 $i$ 的状态。我们用 $F_{i+1/2} \\approx f(U_i)$ 来近似界面通量。对于单元宽度为 $\\Delta x$ 的均匀网格，全离散更新格式为：\n$$\n\\frac{U_i^{n+1} - U_i^n}{\\Delta t} = -\\frac{F_{i+1/2}^n - F_{i-1/2}^n}{\\Delta x} = -\\frac{a U_i^n - a U_{i-1}^n}{\\Delta x}.\n$$\n这可以重写为 $U_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}(F_{i+1/2}^n - F_{i-1/2}^n)$。这种形式的一个关键特性是，离开单元 $i$ 的通量 $F_{i+1/2}^n$ 正是进入单元 $i+1$ 的通量。在周期性域上对所有单元求和，通量成对抵消，总质量（$u$ 的积分）是守恒的。\n\n**2. AMR 网格层级与时间步进**\n\n该域由一个包含 $N_c$ 个单元的粗网格进行离散化。一个对应于粗单元 $\\{i_L, \\dots, i_R-1\\}$ 的子区域被一个因子 $r$ 加密，从而创建一个细网格区域。\n为保持稳定性，时间步长必须满足 Courant-Friedrichs-Lewy (CFL) 条件，对于此格式为 $\\Delta t \\le \\frac{\\Delta x}{a}$（CFL 数 $\\le 1$）。由于细网格具有更小的单元（$\\Delta x_f = \\Delta x_c / r$），它需要更小的时间步长。我们使用时间子循环：对于一个粗网格时间步长 $\\Delta t_c$，我们执行 $r$ 个细网格时间步长 $\\Delta t_f$。为了同步网格，我们设置 $\\Delta t_c = r \\Delta t_f$。细网格时间步长为 $\\Delta t_f = \\mathrm{CFL} \\cdot \\Delta x_f / a$。\n\n**3. 单个同步步长内的 AMR 算法**\n\n该算法按以下步骤进行：\n- **初始化**：粗网格和细网格上的单元平均值都根据精确的连续初始条件 $u(x,0)$ 进行初始化。复合网格状态由加密区域外的粗单元值和区域内的细单元值组成。\n- **推进细网格区域**：细网格区域以大小为 $\\Delta t_f$ 的步长推进 $r$ 个子步。对于 $a0$，细网格区域在其最左侧界面需要边界数据。此数据由一个虚拟单元提供，其值被设置为相邻粗单元的值 $U_{c, i_L-1}^n$。该值在所有 $r$ 个子步中保持不变（“时间上分片常数”的边界条件）。\n- **通量累积**：在 $r$ 个细网格子步期间，我们必须记录穿过粗细网格界面的总通量。设界面位于 $x_{i_L-1/2}$ 和 $x_{i_R-1/2}$。右侧界面的时间积分细网格通量为 $\\mathcal{F}_{i_R-1/2}^{\\text{fine}} = \\sum_{k=0}^{r-1} F_{\\text{rightmost fine face}}^k \\Delta t_f$，其中 $F^k$ 是第 $k$ 个子步的通量。\n- **推进粗网格**：加密区域外的粗单元使用标准粗网格数值通量推进一个步长 $\\Delta t_c$。这是一个“临时”更新。\n- **通量修正**：临时的粗网格更新在界面处使用了粗网格通量，例如 $\\mathcal{F}_{i_R-1/2}^{\\text{coarse}} = F_{c, i_R-1/2}^n \\Delta t_c$。这与细网格计算出的更精确的通量 $\\mathcal{F}_{i_R-1/2}^{\\text{fine}}$ 不一致。为确保守恒性，我们对相邻的粗单元应用修正。单元 $i_R$ 的更新从其左侧界面 $x_{i_R-1/2}$ 接收通量。其状态通过加上积分通量的差值来修正：\n$$\n(U_{i_R} \\Delta x_c)^{\\text{corrected}} = (U_{i_R} \\Delta x_c)^{\\text{provisional}} + (\\mathcal{F}_{i_R-1/2}^{\\text{fine}} - \\mathcal{F}_{i_R-1/2}^{\\text{coarse}}).\n$$\n对于左侧界面 $x_{i_L-1/2}$，时间上分片常数的边界条件意味着细网格边界通量是恒定的，且等于粗网格通量，$F_{c, i_L-1/2}^n$。因此，$\\mathcal{F}_{i_L-1/2}^{\\text{fine}} = (F_{c, i_L-1/2}^n) (r \\Delta t_f) = F_{c, i_L-1/2}^n \\Delta t_c = \\mathcal{F}_{i_L-1/2}^{\\text{coarse}}$。对单元 $i_L-1$ 的修正是零。\n- **限制**：在细网格完全推进后，被加密区域覆盖的粗单元 $\\{i_L, \\dots, i_R-1\\}$ 通过对其组成的细单元的最终值进行平均来接收它们的新值。对于一个粗单元 $i_c$，其新值为 $U_{i_c}^{n+1} = \\frac{1}{r} \\sum_{k=0}^{r-1} U_{f,j+k}^{n+r}$，其中 $j$ 是第一个子细单元的索引。此操作是守恒的。\n\n**4. 误差量化**\n\n- **质量守恒误差**：AMR 层级上的总质量是加密区域外的粗单元质量与区域内的细单元质量之和。一个正确实现的守恒方案，包括通量修正，必须将此总质量守恒到机器精度。我们计算初始总质量和最终总质量之间的绝对差。\n- **投影误差**：在初始化时，我们可以通过延拓粗单元平均值来定义一个细网格场。对于守恒的分片常数延拓，粗单元 $i_c$ 内的每个细单元被赋予值 $U_{c,i_c}$。$L^1$ 投影误差测量了此延拓场与通过直接在细网格上对初始条件进行平均得到的真实细尺度表示之间的差异。该误差为 $E_{L^1} = \\sum_{j \\in \\text{fine patch}} | U_{f,j}^{\\text{prolong}} - U_{f,j}^{\\text{exact}} | \\Delta x_f$。它量化了在粗网格上表示解时丢失的信息。\n\n提供的测试用例将验证该实现是否能守恒质量，并能为光滑和不连续的初始数据正确计算投影误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the AMR simulation for the specified test cases\n    and print the results in the required format.\n    \"\"\"\n\n    def get_avg_sin(x_L, x_R, k):\n        \"\"\"Computes the exact cell average of sin(2*pi*k*x) over [x_L, x_R].\"\"\"\n        if k == 0:\n            return 0.0\n        \n        width = x_R - x_L\n        if abs(width)  1e-12:\n            return np.sin(2 * np.pi * k * (x_L + x_R) / 2.0)\n            \n        arg_L = 2 * np.pi * k * x_L\n        arg_R = 2 * np.pi * k * x_R\n        \n        numerator = np.cos(arg_L) - np.cos(arg_R)\n        denominator = 2 * np.pi * k * width\n        \n        return numerator / denominator\n\n    def get_avg_step(x_L, x_R):\n        \"\"\"Computes the exact cell average of I(x in [0, 0.5)) over [x_L, x_R].\"\"\"\n        width = x_R - x_L\n        if abs(width)  1e-12:\n            return 1.0 if 0 = (x_L + x_R) / 2.0  0.5 else 0.0\n            \n        overlap_start = max(x_L, 0.0)\n        overlap_end = min(x_R, 0.5)\n        \n        overlap_width = max(0.0, overlap_end - overlap_start)\n        \n        return overlap_width / width\n\n    def run_amr_case(Nc, r, patch_bounds, cfl, a, ic_type, ic_params):\n        \"\"\"\n        Executes one full AMR cycle for a given test case configuration.\n        \"\"\"\n        # --- 1. Grid and Parameter Setup ---\n        dx_c = 1.0 / Nc\n        i_L = int(round(patch_bounds[0] / dx_c))\n        i_R = int(round(patch_bounds[1] / dx_c))\n\n        num_fine_cells_in_patch = (i_R - i_L) * r\n        dx_f = dx_c / r\n        \n        dt_f = cfl * dx_f / a\n        dt_c = r * dt_f\n\n        # --- 2. Initialization ---\n        U_c_initial = np.zeros(Nc)\n        for i in range(Nc):\n            x_L_cell, x_R_cell = i * dx_c, (i + 1) * dx_c\n            if ic_type == 'sin':\n                U_c_initial[i] = get_avg_sin(x_L_cell, x_R_cell, **ic_params)\n            elif ic_type == 'step':\n                U_c_initial[i] = get_avg_step(x_L_cell, x_R_cell)\n\n        U_f_initial = np.zeros(num_fine_cells_in_patch)\n        for i_c in range(i_L, i_R):\n            for k in range(r):\n                j = (i_c - i_L) * r + k\n                x_L_fine = i_c * dx_c + k * dx_f\n                x_R_fine = x_L_fine + dx_f\n                if ic_type == 'sin':\n                    U_f_initial[j] = get_avg_sin(x_L_fine, x_R_fine, **ic_params)\n                elif ic_type == 'step':\n                    U_f_initial[j] = get_avg_step(x_L_fine, x_R_fine)\n\n        # --- 3. Compute Initial Mass ---\n        coarse_indices_outside_mask = np.ones(Nc, dtype=bool)\n        coarse_indices_outside_mask[i_L:i_R] = False\n        mass_coarse_outside = np.sum(U_c_initial[coarse_indices_outside_mask]) * dx_c\n        mass_fine_inside = np.sum(U_f_initial) * dx_f\n        mass_total_initial = mass_coarse_outside + mass_fine_inside\n\n        # --- 4. Compute L1 Projection Error ---\n        proj_err = 0.0\n        for i_c in range(i_L, i_R):\n            U_c_prolong = U_c_initial[i_c]\n            for k in range(r):\n                j = (i_c - i_L) * r + k\n                U_f_exact = U_f_initial[j]\n                proj_err += np.abs(U_c_prolong - U_f_exact)\n        proj_err *= dx_f\n\n        # --- 5. AMR Time Step ---\n        U_c_n, U_f_n = U_c_initial.copy(), U_f_initial.copy()\n\n        # 5a. Advance Fine Grid (Subcycling)\n        accumulated_flux_right = 0.0\n        c_left_ghost_idx = (i_L - 1 + Nc) % Nc\n        \n        U_f_current = U_f_n.copy()\n        for _ in range(r):\n            U_f_old_substep = U_f_current.copy()\n            \n            U_f_ext = np.empty(len(U_f_old_substep) + 1)\n            U_f_ext[0] = U_c_n[c_left_ghost_idx]\n            U_f_ext[1:] = U_f_old_substep\n\n            for j in range(len(U_f_current)):\n                flux_left = a * U_f_ext[j]\n                flux_right = a * U_f_ext[j+1]\n                U_f_current[j] = U_f_old_substep[j] - (dt_f / dx_f) * (flux_right - flux_left)\n                \n            flux_at_right_boundary = a * U_f_old_substep[-1]\n            accumulated_flux_right += flux_at_right_boundary * dt_f\n        \n        U_f_final = U_f_current\n\n        # 5b. Advance Coarse Grid (provisional)\n        U_c_final_provisional = np.zeros(Nc)\n        for i in range(Nc):\n            if not coarse_indices_outside_mask[i]:\n                continue\n            i_prev = (i - 1 + Nc) % Nc\n            flux_left = a * U_c_n[i_prev]\n            flux_right = a * U_c_n[i]\n            U_c_final_provisional[i] = U_c_n[i] - (dt_c / dx_c) * (flux_right - flux_left)\n        \n        U_c_final = U_c_final_provisional.copy()\n\n        # 5c. Refluxing\n        i_adj_right = i_R % Nc\n        coarse_flux_integ_right = a * U_c_n[i_R - 1] * dt_c\n        flux_correction = accumulated_flux_right - coarse_flux_integ_right\n        U_c_final[i_adj_right] += flux_correction / dx_c\n\n        # 5d. Restriction\n        for i_c in range(i_L, i_R):\n            j_start = (i_c - i_L) * r\n            j_end = j_start + r\n            U_c_final[i_c] = np.mean(U_f_final[j_start:j_end])\n\n        # --- 6. Compute Final Mass  Error ---\n        mass_coarse_outside_final = np.sum(U_c_final[coarse_indices_outside_mask]) * dx_c\n        mass_fine_inside_final = np.sum(U_f_final) * dx_f\n        mass_total_final = mass_coarse_outside_final + mass_fine_inside_final\n\n        mass_error = np.abs(mass_total_final - mass_total_initial)\n        is_conserved = mass_error  1e-12\n\n        return mass_error, is_conserved, proj_err\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (Nc, r, patch_bounds, cfl, a, ic_type, ic_params)\n        (16, 2, (0.25, 0.50), 0.5, 1.0, 'sin', {'k': 1}),\n        # Case B:\n        (8, 4, (0.375, 0.625), 0.8, 1.0, 'step', {}),\n        # Case C:\n        (10, 5, (0.2, 0.4), 0.9, 1.0, 'sin', {'k': 3}),\n    ]\n\n    results = []\n    for case in test_cases:\n        mass_err, is_cons, proj_err = run_amr_case(*case)\n        results.extend([mass_err, is_cons, proj_err])\n\n    # Final print statement in the exact required format.\n    # Using specific formatting for floats to ensure precision, and str() for booleans.\n    formatted_results = [f\"{x:.15e}\" if isinstance(x, float) else str(x) for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}