{
    "hands_on_practices": [
        {
            "introduction": "分析任何有限差分格式的第一步都是确定其局部截断误差（Local Truncation Error, LTE）。本练习将通过一个典型的一维泊松方程问题，帮助您实践推导局部截断误差最核心的技巧——泰勒级数展开。通过这个过程，您将能亲手验证标准中心差分格式为何具有二阶精度。",
            "id": "3416695",
            "problem": "考虑一维偏微分方程 (PDE) $-u''(x)=f(x)$，定义在区间 $[0,1]$ 上，其狄利克雷边界条件为 $u(0)=\\alpha$ 和 $u(1)=\\beta$。其中 $u\\in C^{4}([0,1])$ 且 $f$ 是连续函数。设一均匀网格由 $x_{i}=ih$ 给出，其中 $i=0,1,\\dots,N$，步长为 $h=1/N$。在内部节点定义离散算子为\n$$\nL_{h}u(x_{i}) \\equiv \\frac{-u(x_{i-1})+2u(x_{i})-u(x_{i+1})}{h^{2}}.\n$$\n在内部网格点 $x_{i}$ 处的局部截断误差 (LTE) 定义为\n$$\n\\tau_{i}(h) \\equiv L_{h}u(x_{i})-f(x_{i}).\n$$\n仅使用 LTE 的定义和在 $u\\in C^{4}([0,1])$ 条件下有效的、带有适当余项的泰勒定理，推导当 $h\\to 0$ 时 $\\tau_{i}(h)$ 的主阶项，并由此证明其关于 $h$ 的阶。你的最终答案必须是内部节点 $x_{i}$ 处 $\\tau_{i}(h)$ 主阶项的单个闭式解析表达式。无需进行数值计算，也无需四舍五入。请用 $h$ 和在 $x_{i}$ 处求值的 $u$ 的导数来表示你的最终答案。",
            "solution": "首先验证问题，以确保其自洽、科学上合理且适定。\n\n### 步骤 1：提取已知条件\n- **PDE**：$-u''(x)=f(x)$，对于 $x \\in [0,1]$。\n- **边界条件**：$u(0)=\\alpha$ 和 $u(1)=\\beta$。\n- **光滑性**：解 $u$ 属于 $C^{4}([0,1])$ 类，且 $f$ 是一个连续函数。\n- **离散化**：均匀网格由 $x_{i}=ih$ 定义，其中 $i=0,1,\\dots,N$，步长 $h=1/N$。\n- **离散算子**：在内部节点 $x_i$ ($i=1, \\dots, N-1$) 处，离散算子为 $L_{h}u(x_{i}) \\equiv \\frac{-u(x_{i-1})+2u(x_{i})-u(x_{i+1})}{h^{2}}$。\n- **局部截断误差 (LTE)**：在内部网格点 $x_i$ 处的 LTE 定义为 $\\tau_{i}(h) \\equiv L_{h}u(x_{i})-f(x_{i})$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题是微分方程数值分析中的一个标准练习，具体涉及有限差分近似的局部截断误差的推导。\n- **科学上合理**：该问题基于微积分的基本原理（泰勒定理）和数值方法。$-u''$ 的有限差分近似是该领域的基石。所有方面在科学和数学上都是合理的。\n- **适定性**：问题陈述清晰，提供了所有必要的定义和条件。光滑性条件 $u \\in C^{4}([0,1])$ 正是为了将泰勒展开到所需阶数而必须的。目标是明确的。\n- **客观性**：问题以精确、形式化的数学语言陈述，没有任何主观性或歧义。\n\n### 步骤 3：结论与行动\n该问题被认为是**有效的**。我们可以继续进行推导。\n\n### 局部截断误差的推导\n\n目标是找出内部节点 $x_i$ 处局部截断误差 $\\tau_{i}(h)$ 的主阶项。\nLTE 的定义为\n$$\n\\tau_{i}(h) \\equiv L_{h}u(x_{i})-f(x_{i}).\n$$\n问题指出，精确解 $u(x)$ 对所有 $x \\in [0,1]$ 满足偏微分方程（在这种一维情况下，即常微分方程）$-u''(x)=f(x)$。因此，在网格点 $x_i$ 处，我们有 $-u''(x_i)=f(x_i)$。将其代入 $\\tau_i(h)$ 的定义，得到：\n$$\n\\tau_{i}(h) = L_{h}u(x_{i}) - (-u''(x_i)) = L_{h}u(x_{i}) + u''(x_i).\n$$\n现在，我们代入离散算子 $L_h u(x_i)$ 的定义：\n$$\n\\tau_{i}(h) = \\frac{-u(x_{i-1})+2u(x_{i})-u(x_{i+1})}{h^{2}} + u''(x_{i}).\n$$\n为分析此表达式，我们使用泰勒定理将 $u(x_{i-1})$ 和 $u(x_{i+1})$ 这两项在点 $x_i$ 周围展开。注意 $x_{i-1} = x_i - h$ 和 $x_{i+1} = x_i + h$。给定的条件 $u \\in C^{4}([0,1])$ 确保了 $u$ 的四阶导数是连续的，这使得泰勒展开到四阶项是有效的。\n\n$u(x_i+h)$ 在 $x_i$ 周围的泰勒展开式为：\n$$\nu(x_{i+1}) = u(x_i+h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2!} u''(x_i) + \\frac{h^3}{3!} u'''(x_i) + \\frac{h^4}{4!} u^{(4)}(x_i) + o(h^4).\n$$\n$u(x_i-h)$ 在 $x_i$ 周围的泰勒展开式为：\n$$\nu(x_{i-1}) = u(x_i-h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2!} u''(x_i) - \\frac{h^3}{3!} u'''(x_i) + \\frac{h^4}{4!} u^{(4)}(x_i) + o(h^4).\n$$\n现在，我们将这些展开式代入 $L_h u(x_i)$ 表达式的分子中：\n$$\n-u(x_{i-1})+2u(x_{i})-u(x_{i+1}) = -[u(x_i-h)] + 2u(x_i) - [u(x_i+h)].\n$$\n让我们按 $u$ 在 $x_i$ 处导数的阶数对各项进行分组：\n\\begin{align*}\n-u(x_{i-1})+2u(x_{i})-u(x_{i+1}) =  -\\left(u(x_i) - h u'(x_i) + \\frac{h^2}{2} u''(x_i) - \\frac{h^3}{6} u'''(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) + o(h^4)\\right) \\\\\n + 2u(x_i) \\\\\n - \\left(u(x_i) + h u'(x_i) + \\frac{h^2}{2} u''(x_i) + \\frac{h^3}{6} u'''(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) + o(h^4)\\right) \\\\\n=  (-1+2-1)u(x_i) + (h-h)u'(x_i) + \\left(-\\frac{h^2}{2} - \\frac{h^2}{2}\\right)u''(x_i) \\\\\n + \\left(\\frac{h^3}{6} - \\frac{h^3}{6}\\right)u'''(x_i) + \\left(-\\frac{h^4}{24} - \\frac{h^4}{24}\\right)u^{(4)}(x_i) + o(h^4) \\\\\n=  0 \\cdot u(x_i) + 0 \\cdot u'(x_i) - h^2 u''(x_i) + 0 \\cdot u'''(x_i) - \\frac{2h^4}{24} u^{(4)}(x_i) + o(h^4) \\\\\n=  -h^2 u''(x_i) - \\frac{h^4}{12} u^{(4)}(x_i) + o(h^4).\n\\end{align*}\n现在，将此结果代回 $\\tau_i(h)$ 的表达式中：\n$$\n\\tau_{i}(h) = \\frac{-h^2 u''(x_i) - \\frac{h^4}{12} u^{(4)}(x_i) + o(h^4)}{h^{2}} + u''(x_i).\n$$\n各项除以 $h^2$，我们得到：\n$$\n\\tau_{i}(h) = \\left(-u''(x_i) - \\frac{h^2}{12} u^{(4)}(x_i) + o(h^2)\\right) + u''(x_i).\n$$\n$u''(x_i)$ 项相互抵消：\n$$\n\\tau_{i}(h) = - \\frac{h^2}{12} u^{(4)}(x_i) + o(h^2).\n$$\n当 $h \\to 0$ 时，此表达式中的主导项是 $h$ 的最低次幂项。这就是主阶项。因此，局部截断误差 $\\tau_i(h)$ 的主阶项是 $-\\frac{h^2}{12} u^{(4)}(x_i)$。\n\n这个结果也证明了有限差分格式的精度阶。由于局部截断误差 $\\tau_i(h)$ 与 $h^2$ 成正比，我们说该方法是 $O(h^2)$ 阶的，或称二阶精度。这意味着如果步长 $h$ 减小为原来的一半，局部误差预计将减小为原来的 $2^2=4$分之一，前提是 $u^{(4)}(x_i)$ 不为零。\n最终答案就是这个主阶项的显式解析表达式。",
            "answer": "$$\n\\boxed{- \\frac{h^{2}}{12} u^{(4)}(x_{i})}\n$$"
        },
        {
            "introduction": "理论分析中常用的均匀网格在实际应用中并不普遍，因为高效的计算往往需要非均匀网格来适应解的局部特征。本练习将探讨从均匀网格到非均匀网格的转变如何影响局部截断误差，并揭示一个重要结论：如果网格划分不够“光滑”，格式的精度可能会意外地从二阶下降到一阶。",
            "id": "3416659",
            "problem": "考虑一维空间中的一个双区间非均匀网格，其节点为 $x_{i-1}$、$x_i$、$x_{i+1}$，局部左间距为 $h_i = x_i - x_{i-1}$，局部右间距为 $h_{i+1} = x_{i+1} - x_i$。设 $u : [0,1] \\to \\mathbb{R}$ 为一个足够光滑的函数。在 $x_i$ 点处二阶导数的标准三点非均匀有限差分近似使用相邻节点值的线性组合\n$$\nD^{2}u_i \\;=\\; \\frac{2}{h_i\\,h_{i+1}\\,(h_i + h_{i+1})}\\,\\Big( h_i\\,u_{i+1} \\;-\\; (h_i + h_{i+1})\\,u_i \\;+\\; h_{i+1}\\,u_{i-1} \\Big),\n$$\n其中 $u_j = u(x_j)$。\n\n任务 A：从 $x_i$ 点周围带积分余项的泰勒定理出发，并假设 $u$ 存在至少四阶连续导数，推导局部截断误差 $\\tau_i = D^{2}u_i - u''(x_i)$，其表达式应包含到与 $u^{(3)}(x_i)$ 和 $u^{(4)}(x_i)$ 成比例的项为止，并以 $h_i$、$h_{i+1}$、$u^{(3)}(x_i)$ 和 $u^{(4)}(x_i)$ 的闭式形式表示。\n\n任务 B：考虑在 $[0,1]$ 上的一维椭圆边值问题 $-u''(x) = f(x)$，其边界条件为齐次狄利克雷边界条件 $u(0) = 0$ 和 $u(1) = 0$。该问题通过在内部节点处用 $D^{2}u_i$ 替换 $u''(x_i)$ 并在端点处施加边界条件来进行离散化。陈述关于网格和解的光滑性的充分条件，以保证当 $h_{\\max} \\to 0$ 时，全局误差 $\\|u - u_h\\|_{\\infty}$ 为 $O(h_{\\max}^{2})$，其中 $h_{\\max} = \\max_j h_j$。在你的条件中，明确指出局部对称性（即 $h_{i+1} - h_i$ 的行为）以及离散算子稳定性的作用。\n\n你的最终答案必须是任务 A 中获得的闭式解析表达式。无需四舍五入。",
            "solution": "所述问题是有限差分法数值分析中的一个标准练习。它具有科学依据、是适定的、客观且完整的。所有组成部分，包括有限差分公式、局部截断误差的概念，以及边值问题的全局误差分析，都是该领域的基础。因此，该问题被认为是有效的，并将在下面提供完整解答。\n\n解答分为两部分，分别对应任务 A 和任务 B。\n\n**任务 A：局部截断误差的推导**\n\n目标是求出局部截断误差 $\\tau_i = D^{2}u_i - u''(x_i)$，其中 $u''(x_i)$ 是函数 $u(x)$ 在节点 $x_i$ 处的精确二阶导数。给定的非均匀网格上二阶导数的三点有限差分近似为：\n$$\nD^{2}u_i = \\frac{2}{h_i h_{i+1} (h_i + h_{i+1})} \\left( h_i u_{i+1} - (h_i + h_{i+1})u_i + h_{i+1} u_{i-1} \\right)\n$$\n这里，$u_j = u(x_j)$，$h_i = x_i - x_{i-1} > 0$ 且 $h_{i+1} = x_{i+1} - x_i > 0$。\n\n给定函数 $u(x)$ 至少有四阶连续导数，即 $u \\in C^4([0,1])$。因此，我们可以使用泰勒定理将 $u_{i+1} = u(x_i + h_{i+1})$ 和 $u_{i-1} = u(x_i - h_i)$ 在点 $x_i$ 周围展开。我们展开到四阶项，更高阶的项用 $O(h^5)$ 表示。\n令 $u^{(k)}(x_i)$ 表示 $u$ 在 $x_i$ 处的 $k$ 阶导数。展开式为：\n$$\nu_{i+1} = u(x_i) + h_{i+1} u^{(1)}(x_i) + \\frac{h_{i+1}^2}{2} u^{(2)}(x_i) + \\frac{h_{i+1}^3}{6} u^{(3)}(x_i) + \\frac{h_{i+1}^4}{24} u^{(4)}(x_i) + O(h_{i+1}^5)\n$$\n$$\nu_{i-1} = u(x_i) - h_i u^{(1)}(x_i) + \\frac{h_i^2}{2} u^{(2)}(x_i) - \\frac{h_i^3}{6} u^{(3)}(x_i) + \\frac{h_i^4}{24} u^{(4)}(x_i) + O(h_i^5)\n$$\n让我们将这些展开式代入线性组合 $h_i u_{i+1} - (h_i + h_{i+1})u_i + h_{i+1} u_{i-1}$。我们按 $u$ 在 $x_i$ 处的导数阶数对各项进行分组。\n\n含 $u(x_i)$ 的项：\n$$\nh_i u(x_i) - (h_i + h_{i+1}) u(x_i) + h_{i+1} u(x_i) = (h_i - h_i - h_{i+1} + h_{i+1}) u(x_i) = 0\n$$\n含 $u^{(1)}(x_i)$ 的项：\n$$\nh_i (h_{i+1} u^{(1)}(x_i)) + h_{i+1} (-h_i u^{(1)}(x_i)) = (h_i h_{i+1} - h_{i+1} h_i) u^{(1)}(x_i) = 0\n$$\n含 $u^{(2)}(x_i)$ 的项：\n$$\nh_i \\left(\\frac{h_{i+1}^2}{2} u^{(2)}(x_i)\\right) + h_{i+1} \\left(\\frac{h_i^2}{2} u^{(2)}(x_i)\\right) = \\left(\\frac{h_i h_{i+1}^2 + h_{i+1} h_i^2}{2}\\right) u^{(2)}(x_i) = \\frac{h_i h_{i+1}(h_{i+1} + h_i)}{2} u^{(2)}(x_i)\n$$\n含 $u^{(3)}(x_i)$ 的项：\n$$\nh_i \\left(\\frac{h_{i+1}^3}{6} u^{(3)}(x_i)\\right) + h_{i+1} \\left(-\\frac{h_i^3}{6} u^{(3)}(x_i)\\right) = \\left(\\frac{h_i h_{i+1}^3 - h_{i+1} h_i^3}{6}\\right) u^{(3)}(x_i) = \\frac{h_i h_{i+1}(h_{i+1}^2 - h_i^2)}{6} u^{(3)}(x_i)\n$$\n使用平方差公式，$h_{i+1}^2 - h_i^2 = (h_{i+1} - h_i)(h_{i+1} + h_i)$。该项变为：\n$$\n\\frac{h_i h_{i+1}(h_{i+1} - h_i)(h_{i+1} + h_i)}{6} u^{(3)}(x_i)\n$$\n含 $u^{(4)}(x_i)$ 的项：\n$$\nh_i \\left(\\frac{h_{i+1}^4}{24} u^{(4)}(x_i)\\right) + h_{i+1} \\left(\\frac{h_i^4}{24} u^{(4)}(x_i)\\right) = \\left(\\frac{h_i h_{i+1}^4 + h_{i+1} h_i^4}{24}\\right) u^{(4)}(x_i) = \\frac{h_i h_{i+1}(h_{i+1}^3 + h_i^3)}{24} u^{(4)}(x_i)\n$$\n使用立方和公式，$h_{i+1}^3 + h_i^3 = (h_{i+1} + h_i)(h_{i+1}^2 - h_i h_{i+1} + h_i^2)$。该项变为：\n$$\n\\frac{h_i h_{i+1}(h_{i+1} + h_i)(h_{i+1}^2 - h_i h_{i+1} + h_i^2)}{24} u^{(4)}(x_i)\n$$\n现在，我们组合这些项并乘以预因子 $\\frac{2}{h_i h_{i+1} (h_i + h_{i+1})}$，得到 $D^{2}u_i$ 的表达式：\n\n$D^{2}u_i = \\frac{2}{h_i h_{i+1} (h_i + h_{i+1})} \\Big[$\n$\\frac{h_i h_{i+1}(h_{i+1} + h_i)}{2} u^{(2)}(x_i) +$\n$\\frac{h_i h_{i+1}(h_{i+1} - h_i)(h_{i+1} + h_i)}{6} u^{(3)}(x_i) +$\n$\\frac{h_i h_{i+1}(h_{i+1} + h_i)(h_{i+1}^2 - h_i h_{i+1} + h_i^2)}{24} u^{(4)}(x_i) + O(h^5) \\Big]$\n\n其中 $h = \\max(h_i, h_{i+1})$。\n乘开后，我们得到：\n$$\nD^{2}u_i = u^{(2)}(x_i) + \\frac{2}{6}(h_{i+1} - h_i) u^{(3)}(x_i) + \\frac{2}{24}(h_{i+1}^2 - h_i h_{i+1} + h_i^2) u^{(4)}(x_i) + O(h^3)\n$$\n$$\nD^{2}u_i = u^{(2)}(x_i) + \\frac{1}{3}(h_{i+1} - h_i) u^{(3)}(x_i) + \\frac{1}{12}(h_i^2 - h_i h_{i+1} + h_{i+1}^2) u^{(4)}(x_i) + O(h^3)\n$$\n局部截断误差 $\\tau_i$ 定义为 $\\tau_i = D^{2}u_i - u^{(2)}(x_i)$。因此，\n$$\n\\tau_i = \\frac{h_{i+1} - h_i}{3} u^{(3)}(x_i) + \\frac{h_i^2 - h_i h_{i+1} + h_{i+1}^2}{12} u^{(4)}(x_i) + O(h^3)\n$$\n包含到与 $u^{(3)}(x_i)$ 和 $u^{(4)}(x_i)$ 成比例的项为止的截断误差表达式即为所求量。\n\n**任务 B：二阶全局误差的条件**\n\n我们考虑边值问题 $-u''(x) = f(x)$，其中 $x \\in [0,1]$ 且 $u(0)=0$、$u(1)=0$。离散化过程用 $-D^2u_i$ 替换 $-u''(x_i)$，从而得到关于数值解向量 $u_h$ 的线性方程组 $A_h u_h = f$。精确解 $u$ 满足 $-D^2 u(x_i) = f(x_i) - \\tau_i$，其中 $\\tau_i$ 是在任务 A 中推导的局部截断误差。因此，全局误差向量 $e = u - u_h$ 满足误差方程 $A_h e = \\tau$，其中 $\\tau$ 是局部截断误差向量。\n\n在最大范数下的全局误差有界，即 $\\|e\\|_{\\infty} \\le \\|A_h^{-1}\\|_{\\infty} \\|\\tau\\|_{\\infty}$。要使全局误差达到二阶，即 $\\|e\\|_{\\infty} = O(h_{\\max}^2)$，我们需要两个主要因素：离散算子的稳定性和格式的二阶相容性。\n\n1.  **离散算子的稳定性：** 这要求逆矩阵的范数 $\\|A_h^{-1}\\|_{\\infty}$ 受一个与网格尺寸 $h_{\\max}$ 无关的常数限制。在非均匀网格上，与算子 $-D^2$ 对应的矩阵 $A_h$ 是一个三对角矩阵。可以证明它是一个 M-矩阵，因此其逆矩阵的元素非负。对于这类矩阵，如果网格是拟均匀的，通常可以保证稳定性。拟均匀意味着存在一个常数 $\\sigma > 0$，使得对于所有相邻区间，$1/\\sigma \\le h_{i+1}/h_i \\le \\sigma$。这个条件防止了非对角元素相对于对角元素变得过大，从而确保算子在 $h_{\\max} \\to 0$ 时保持良态。\n\n2.  **二阶相容性：** 这要求截断误差是二阶的，即 $\\|\\tau\\|_{\\infty} = O(h_{\\max}^2)$。从任务 A 可知，截断误差为\n    $$ \\tau_i = \\frac{h_{i+1} - h_i}{3} u^{(3)}(x_i) + \\frac{h_i^2 - h_i h_{i+1} + h_{i+1}^2}{12} u^{(4)}(x_i) + O(h_{\\max}^3) $$\n    第二项是 $O(h_{\\max}^2)$ 阶的。然而，第一项 $\\frac{1}{3}(h_{i+1} - h_i)u^{(3)}(x_i)$ 通常是 $O(h_{\\max})$ 阶的，这使得该格式只有一阶精确度。“局部对称性”（由项 $h_{i+1} - h_i$ 描述）的作用在这里至关重要。为了使格式达到二阶相容，这个主误差项必须降至 $O(h_{\\max}^2)$。如果网格间距平滑变化，就可以实现这一点，其形式化表述为条件 $|h_{i+1} - h_i| \\le C h_{\\max}^2$ 对某个常数 $C$ 和所有 $i$ 都成立。如果此条件成立，格式就变为二阶相容。均匀网格（$h_{i+1} = h_i$）是满足此条件的一个平凡特例。\n\n3.  **解的光滑性：** 截断误差及其界的推导假设了解 $u(x)$ 足够光滑。$\\tau_i$ 的表达式涉及 $u^{(3)}$ 和 $u^{(4)}$。为了使这些项在整个定义域 $[0,1]$ 上有良好定义且有界，我们需要 $u \\in C^4([0,1])$。根据微分方程 $-u''=f$ 和标准的椭圆正则性理论，如果源项 $f(x)$ 属于 $C^2([0,1])$，那么解 $u(x)$ 将属于 $C^4([0,1])$。\n\n总之，实现 $\\|u - u_h\\|_{\\infty} = O(h_{\\max}^2)$ 全局误差的充分条件是：\n(a) 解具有足够的光滑性，$u \\in C^4([0,1])$，这在 $f \\in C^2([0,1])$ 时可以保证。\n(b) 离散算子是稳定的，这可以通过拟均匀网格条件 $\\exists \\sigma: h_{i+1}/h_i \\le \\sigma$ 来保证。\n(c) 网格是平滑变化的，使得 $|h_{i+1} - h_i| = O(h_{\\max}^2)$。",
            "answer": "$$\\boxed{\\frac{h_{i+1} - h_i}{3} u^{(3)}(x_i) + \\frac{h_i^2 - h_i h_{i+1} + h_{i+1}^2}{12} u^{(4)}(x_i)}$$"
        },
        {
            "introduction": "理论上的局部误差分析与最终得到的全局数值解行为之间有何联系？本计算练习将通过一个二维各向异性扩散问题来揭示这一深刻联系。您将研究离散格式如何因其局部结构（违反 M-矩阵性质）而导致非物理的全局振荡，并通过编程实现一种局部修正方案来恢复解的定性正确性。",
            "id": "3416731",
            "problem": "考虑在单位平方域 $[0,1]\\times[0,1]$ 上，具有齐次狄利克雷边界数据的二维各向异性扩散模型，其精确解为 $u(x,y)=\\sin(\\pi x)\\sin(\\pi y)$。控制椭圆偏微分方程为 $-\\nabla\\cdot(\\boldsymbol{D}\\nabla u)=f$，其中扩散张量为 $\\boldsymbol{D}=\\begin{pmatrix}1\\beta\\\\ \\beta1\\end{pmatrix}$，各向异性参数为常数 $\\beta\\in\\mathbb{R}$。源项 $f$ 的定义使得 $u$ 是精确解，即 $f(x,y)=-\\nabla\\cdot(\\boldsymbol{D}\\nabla u(x,y))$。离散近似使用均匀的笛卡尔网格，每个坐标方向有 $N$ 个内点，网格间距为 $h=1/(N+1)$，内节点坐标分别为 $(x_i,y_j)=(ih,jh)$，其中 $i=1,\\dots,N$，$j=1,\\dots,N$。\n\n你必须使用以下格式来组装作用于内部节点未知数向量的离散算子 $\\boldsymbol{A}$：\n- 二阶导数 $u_{xx}$ 和 $u_{yy}$ 各自通过中心差分和标准的五点格式进行近似，这使得对角线上的权重为 $4/h^2$，四个轴对齐邻居上的权重为 $-1/h^2$。\n- 混合导数 $u_{xy}$ 通过标准的中心差分九点格式贡献进行近似：\n$$u_{xy}(x_i,y_j)\\approx \\frac{u_{i+1,j+1}-u_{i+1,j-1}-u_{i-1,j+1}+u_{i-1,j-1}}{4h^2},$$\n它通过 $-2\\beta\\,u_{xy}$ 对 $-\\nabla\\cdot(\\boldsymbol{D}\\nabla u)$ 中的交叉项产生贡献。这会产生角点权重 $\\pm \\beta/(2h^2)$，符号如上述公式所示。得到的 $\\boldsymbol{A}$ 是对称的。\n\n你的推导和算法设计的基础必须始于一致椭圆算子的连续极值原理、离散算子的 $M$-矩阵概念，以及局部截断误差和全局离散误差的标准定义：\n- 一个特征值有正下界的对称张量 $\\boldsymbol{D}$ 意味着一致椭圆性和一个连续极值原理：如果 $f\\ge 0$ 且边界数据有界，则内部极大值不超过边界极大值。\n- 如果一个稀疏矩阵 $\\boldsymbol{A}$ 的非对角元素非正，并且它按行是弱对角占优的且对角线元素为正，那么它就是一个 $M$-矩阵；这足以保证离散极值原理。\n- 某个网格点上的局部截断误差是将精确解代入离散算子后得到的残差，而全局离散误差是在某种范数（这里是 $L^{\\infty}$ 范数）下度量的离散解与精确解之差。\n\n你必须解决的问题包括三个部分：\n$1.$ 从这些原理出发，清晰地解释为什么各向异性九点格式中局部符号不定的角点权重和过大的负非对角元会违反 $M$-矩阵性质，从而违反离散极值原理，导致出现全局超调，即离散解超过了连续解 $u(x,y)$ 在 $(x,y)=(\\tfrac{1}{2},\\tfrac{1}{2})$ 处达到的连续极大值 $1$。\n$2.$ 提出并实现一个严格的局部代数修复方法，以恢复 $M$-矩阵性质，而不改变与违规项相关的直接行和列之外的离散算子：对于任何正的非对角项 $A_{ij}$（$i \\ne j$），设置 $A_{ij}\\leftarrow 0$ 和 $A_{ji}\\leftarrow 0$，并将对角线元素 $A_{ii}$ 和 $A_{jj}$ 都增加被移除的量，以保持每行的行和一致性。解释为什么这种修复能强制非对角元为非正，增加对角占优性，从而更好地符合离散极值原理。\n$3.$ 量化这种局部修复引起的全局 $L^{\\infty}$ 误差的变化。对于下面定义的每个测试用例，计算原始格式和局部修复后格式的 $L^{\\infty}$ 误差 $E_{\\infty}=\\max_{i,j}|u^{h}_{ij}-u(x_i,y_j)|$，并以浮点数形式报告改进量 $\\Delta E_{\\infty}=E_{\\infty,\\text{orig}}-E_{\\infty,\\text{fix}}$。同时计算修复前后的超调量 $O=\\max\\{0,\\max_{i,j}u^{h}_{ij}-1\\}$，但只需打印 $\\Delta E_{\\infty}$。不涉及物理单位，如果出现任何角度，必须以弧度为单位。\n\n使用以下测试套件 $(N,\\beta)$ 值来检验各种情况：\n- 情况 A（理想情况，各向同性）：$(N,\\beta)=(33,0)$。\n- 情况 B（中等各向异性）：$(N,\\beta)=(33,0.6)$。\n- 情况 C（强各向异性，粗网格）：$(N,\\beta)=(17,0.95)$。\n- 情况 D（负交叉各向异性）：$(N,\\beta)=(33,-0.8)$。\n\n你的程序必须：\n- 从 $u$ 和 $\\boldsymbol{D}$ 解析地获得 $f(x,y)=-\\nabla\\cdot(\\boldsymbol{D}\\nabla u(x,y))$，然后组装 $\\boldsymbol{A}$ 和右端向量 $\\boldsymbol{b}$，其元素为 $b_{ij}=f(x_i,y_j)$。\n- 在应用局部修复前后，求解 $\\boldsymbol{A}\\boldsymbol{u}^{h}=\\boldsymbol{b}$ 以得到内部未知数 $\\boldsymbol{u}^{h}$。\n- 对每种情况计算 $E_{\\infty,\\text{orig}}$、$E_{\\infty,\\text{fix}}$ 和改进量 $\\Delta E_{\\infty}$。\n\n最终输出格式：你的程序应该生成单行输出，其中包含四个改进值，形式为用方括号括起来的逗号分隔列表（例如，$[a,b,c,d]$）。每个条目必须是浮点数。不应打印任何其他文本。",
            "solution": "该问题要求对一个各向异性扩散方程的有限差分离散化进行三部分分析。我们必须首先验证问题的提法，然后提供一个关于潜在数值伪影的理论解释，提出并论证一种修复方法，最后实施一个数值实验来量化该修复方法的效果。\n\n### 问题验证\n\n问题被认为是有效的。它在科学上基于偏微分方程数值分析的既定理论，特别是关于有限差分法、矩阵性质（$M$-矩阵）和极值原理。问题设定是适定的：它在一个简单域上定义了一个具有已知光滑解的线性椭圆偏微分方程，指定了一个一致的离散化方案，并要求对一个已知的数值问题进行可量化的分析。该问题是客观、完整且不含矛盾的。所有参数和测试用例在物理和数学上对于展示指定的数值行为的背景都是合理的。因此，我们可以继续进行求解。\n\n### 第1部分：违反离散极值原理\n\n控制偏微分方程（PDE）为 $-\\nabla\\cdot(\\boldsymbol{D}\\nabla u)=f$，定义在域 $[0,1]\\times[0,1]$ 上，其中 $\\boldsymbol{D}=\\begin{pmatrix}1\\beta\\\\ \\beta1\\end{pmatrix}$。展开散度算子，该PDE变为：\n$$ -\\frac{\\partial}{\\partial x}\\left(1 \\cdot \\frac{\\partial u}{\\partial x} + \\beta \\frac{\\partial u}{\\partial y}\\right) - \\frac{\\partial}{\\partial y}\\left(\\beta \\frac{\\partial u}{\\partial x} + 1 \\cdot \\frac{\\partial u}{\\partial y}\\right) = f $$\n$$ - \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\beta \\frac{\\partial^2 u}{\\partial y \\partial x} \\right) - \\left( \\beta \\frac{\\partial^2 u}{\\partial x \\partial y} + \\frac{\\partial^2 u}{\\partial y^2} \\right) = f $$\n假设 $u$ 足够光滑，使得混合偏导数相等（$u_{xy} = u_{yx}$），则PDE为：\n$$ -u_{xx} - u_{yy} - 2\\beta u_{xy} = f $$\n问题指定了在间距为 $h$ 的均匀网格上的有限差分离散化。二阶导数使用标准中心差分进行近似，混合导数按指定方式近似。对于一个通用内节点 $(i,j)$，令 $u_{i,j}$ 表示在 $(x_i, y_j)$ 处的近似解。在此节点上算子的离散形式为：\n$$ - \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} - \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} - 2\\beta \\frac{u_{i+1,j+1}-u_{i+1,j-1}-u_{i-1,j+1}+u_{i-1,j-1}}{4h^2} = f_{i,j} $$\n按相应的节点值对各项进行分组，我们得到计算格式：\n$$ \\frac{1}{h^2} \\left( 4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} \\right) - \\frac{\\beta}{2h^2} \\left( u_{i+1,j+1}-u_{i+1,j-1}-u_{i-1,j+1}+u_{i-1,j-1} \\right) = f_{i,j} $$\n该方程定义了线性系统 $\\boldsymbol{A}\\boldsymbol{u}^h = \\boldsymbol{b}$ 中的一行。相邻 $u$ 值的系数成为矩阵 $\\boldsymbol{A}$ 的非对角元素。\n对应于节点 $(i,j)$ 的行的格式权重为：\n- 中心点 $(i,j)$：$\\frac{4}{h^2}$（$\\boldsymbol{A}$ 的对角元素）\n- 轴对齐邻点 $(i\\pm1,j)$, $(i,j\\pm1)$：$-\\frac{1}{h^2}$\n- 对角邻点 $(i+1,j+1)$, $(i-1,j-1)$：$-\\frac{\\beta}{2h^2}$\n- 反对角邻点 $(i-1,j+1)$, $(i+1,j-1)$：$+\\frac{\\beta}{2h^2}$\n\n如果一个矩阵 $\\boldsymbol{A}$ 是非奇异的，其对角元素为正（$A_{kk} > 0$），并且其所有非对角元素为非正（$A_{kl} \\le 0$ for $k \\ne l$），则它是一个 $M$-矩阵。一个充分条件是 $\\boldsymbol{A}$ 是弱对角占优的，具有非正的非对角元和正的对角元。$M$-矩阵性质保证了离散极值原理（DMP），确保数值解不会表现出源项或边界数据中不存在的非物理振荡或极值。\n\n从格式权重中，我们观察到 $\\boldsymbol{A}$ 的非对角元素取决于 $\\beta$ 的符号：\n- 如果 $\\beta > 0$，对应于反对角邻点 $(i-1,j+1)$ 和 $(i+1,j-1)$ 的权重为 $+\\frac{\\beta}{2h^2} > 0$。\n- 如果 $\\beta  0$，令 $\\beta = -|\\beta|$。对应于对角邻点 $(i+1,j+1)$ 和 $(i-1,j-1)$ 的权重变为 $-\\frac{-|\\beta|}{2h^2} = +\\frac{|\\beta|}{2h^2} > 0$。\n\n在任何一种情况下，对于任意 $\\beta \\neq 0$，矩阵 $\\boldsymbol{A}$ 都将有正的非对角元素。这违反了 $M$-矩阵的定义。不满足 $M$-矩阵性质意味着离散算子不满足离散极值原理。连续解 $u(x,y)=\\sin(\\pi x)\\sin(\\pi y)$ 在 $(0.5, 0.5)$ 处有最大值 $1$，在边界上为零。DMP的丧失可能导致数值解中出现伪“超调”，即 $\\max_{i,j} u^h_{i,j}$ 可能超过连续最大值 $1$，这是一种非物理的假象。\n\n### 第2部分：恢复 $M$-矩阵性质\n\n为了恢复 $M$-矩阵性质，我们对矩阵 $\\boldsymbol{A}$ 应用一个局部代数修复。目标是消除所有正的非对角元素，而不显著改变与一致性相关的矩阵性质。提出的修复方法如下：\n\n对于每一对索引 $(k,l)$，其中 $k \\ne l$ 且 $A_{kl} > 0$：\n1.  将正的非对角元素设为零：$A_{kl} \\leftarrow 0$。由于原始矩阵 $\\boldsymbol{A}$ 是对称的，我们也设置 $A_{lk} \\leftarrow 0$。\n2.  为了保持原始的行和（这对于该格式的一阶一致性很重要），将被移除的正值加到相应的对角元素上。具体来说，更新 $A_{kk} \\leftarrow A_{kk} + A_{kl, \\text{orig}}$ 和 $A_{ll} \\leftarrow A_{ll} + A_{lk, \\text{orig}}$。\n\n此过程将原始矩阵 $\\boldsymbol{A}_{\\text{orig}}$ 转换为一个新矩阵 $\\boldsymbol{A}_{\\text{fix}}$。让我们分析一下为什么这种修复是有效的：\n- **非正非对角元：** 该过程系统地识别并清零每一个正的非对角元素。原始为负或零的非对角元素保持不变。通过构造，得到的矩阵 $\\boldsymbol{A}_{\\text{fix}}$ 的非对角元素全部为非正。\n- **对角占优性：** $\\boldsymbol{A}_{\\text{orig}}$ 的对角元素是正的（$4/h^2 > 0$）。修复过程将一个非负值（原始的正非对角元素）加到每个参与修改的对角元素上。这严格增加了对角元素相对于非对角元素的大小，从而增强了矩阵的对角占优性。通过构造，行和得以保持。\n- **$M$-矩阵与DMP：** 得到的矩阵 $\\boldsymbol{A}_{\\text{fix}}$ 现在具有正的对角元、非正的非对角元，并且至少与 $\\boldsymbol{A}_{\\text{orig}}$ 一样是对角占优的。这确保了 $\\boldsymbol{A}_{\\text{fix}}$ 是一个 $M$-矩阵。一个可逆的 $M$-矩阵具有非负逆（$\\boldsymbol{A}_{\\text{fix}}^{-1} \\ge 0$），这是离散算子满足极值原理的充分条件。恢复DMP可以抑制非物理的超调，并有望产生一个更稳定、在性质上更正确的数值解。\n\n### 第3部分：量化改进\n\n恢复DMP的理论好处是抑制数值超调和提高稳定性。我们通过测量全局离散误差的变化来量化实际影响。误差在无穷范数（$L^{\\infty}$）下度量，定义为数值解 $u^h$ 与精确解 $u$ 在网格节点上差的绝对值的最大值：$E_{\\infty} = \\max_{i,j}|u^{h}_{ij}-u(x_i,y_j)|$。\n\n通过求解原始矩阵（$\\boldsymbol{A}_{\\text{orig}}\\boldsymbol{u}^h_{\\text{orig}} = \\boldsymbol{b}$）和修复后矩阵（$\\boldsymbol{A}_{\\text{fix}}\\boldsymbol{u}^h_{\\text{fix}} = \\boldsymbol{b}$）的线性系统，我们得到两个数值解。然后我们可以计算它们各自的误差 $E_{\\infty,\\text{orig}}$ 和 $E_{\\infty,\\text{fix}}$。改进量定义为 $\\Delta E_{\\infty} = E_{\\infty,\\text{orig}} - E_{\\infty,\\text{fix}}$。$\\Delta E_{\\infty}$ 的正值表示局部代数修复减少了全局误差度量，从而产生了一个更精确的解，同时在性质上也更正确。提供的代码为指定的测试用例实现了此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import csr_matrix, dok_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef assemble_system(N, beta):\n    \"\"\"\n    Assembles the sparse matrix A and the right-hand side vector b.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    N2 = N * N\n    \n    # Create grid\n    x = np.linspace(h, 1.0 - h, N)\n    y = np.linspace(h, 1.0 - h, N)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Exact solution\n    u_exact = np.sin(np.pi * X) * np.sin(np.pi * Y)\n    \n    # Source term f(x,y)\n    f = (2.0 * np.pi**2 * np.sin(np.pi * X) * np.sin(np.pi * Y) -\n         2.0 * beta * np.pi**2 * np.cos(np.pi * X) * np.cos(np.pi * Y))\n    b = f.flatten()\n\n    # Stencil weights\n    h2 = h * h\n    w_center = 4.0 / h2\n    w_axis = -1.0 / h2\n    w_diag = -beta / (2.0 * h2)\n    w_anti = beta / (2.0 * h2)\n\n    # Assemble A using COO format\n    rows, cols, data = [], [], []\n\n    for i in range(N):\n        for j in range(N):\n            k = i * N + j\n            \n            # Center\n            rows.append(k)\n            cols.append(k)\n            data.append(w_center)\n            \n            # Axis-aligned neighbors\n            if i > 0:   # (i-1, j)\n                rows.append(k); cols.append(k - N); data.append(w_axis)\n            if i  N-1: # (i+1, j)\n                rows.append(k); cols.append(k + N); data.append(w_axis)\n            if j > 0:   # (i, j-1)\n                rows.append(k); cols.append(k - 1); data.append(w_axis)\n            if j  N-1: # (i, j+1)\n                rows.append(k); cols.append(k + 1); data.append(w_axis)\n                \n            # Mixed-derivative neighbors\n            # (i-1, j-1)\n            if i > 0 and j > 0:\n                rows.append(k); cols.append(k - N - 1); data.append(w_diag)\n            # (i+1, j+1)\n            if i  N-1 and j  N-1:\n                rows.append(k); cols.append(k + N + 1); data.append(w_diag)\n            # (i-1, j+1)\n            if i > 0 and j  N-1:\n                rows.append(k); cols.append(k - N + 1); data.append(w_anti)\n            # (i+1, j-1)\n            if i  N-1 and j > 0:\n                rows.append(k); cols.append(k + N - 1); data.append(w_anti)\n\n    A = csr_matrix((data, (rows, cols)), shape=(N2, N2))\n    return A, b, u_exact.flatten()\n\ndef apply_local_fix(A_orig):\n    \"\"\"\n    Applies the local algebraic fix to restore the M-matrix property.\n    \"\"\"\n    A_fix = A_orig.todok()\n    \n    # Find positive off-diagonal entries. Iterate over a copy of keys.\n    positive_off_diagonals = []\n    for (r, c), v in A_fix.items():\n        if r != c and v > 0:\n            positive_off_diagonals.append((r, c))\n\n    for r, c in positive_off_diagonals:\n        # Check if it hasn't been zeroed out by its symmetric partner\n        if A_fix[r, c] > 0:\n            val = A_fix[r, c]\n            A_fix[r, r] += val\n            A_fix[c, c] += val  # Using symmetry, A[c,r] was also positive\n            A_fix[r, c] = 0\n            A_fix[c, r] = 0\n            \n    return A_fix.tocsr()\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute error improvements.\n    \"\"\"\n    test_cases = [\n        (33, 0.0),      # Case A\n        (33, 0.6),      # Case B\n        (17, 0.95),     # Case C\n        (33, -0.8),     # Case D\n    ]\n\n    results = []\n    for N, beta in test_cases:\n        # 1. Assemble original system\n        A_orig, b, u_exact_flat = assemble_system(N, beta)\n        \n        # 2. Solve original system and compute error\n        u_h_orig = spsolve(A_orig, b)\n        e_inf_orig = np.max(np.abs(u_h_orig - u_exact_flat))\n        \n        # 3. Apply fix\n        A_fix = apply_local_fix(A_orig)\n        \n        # 4. Solve fixed system and compute error\n        u_h_fix = spsolve(A_fix, b)\n        e_inf_fix = np.max(np.abs(u_h_fix - u_exact_flat))\n\n        # 5. Calculate error improvement\n        delta_e_inf = e_inf_orig - e_inf_fix\n        results.append(delta_e_inf)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}