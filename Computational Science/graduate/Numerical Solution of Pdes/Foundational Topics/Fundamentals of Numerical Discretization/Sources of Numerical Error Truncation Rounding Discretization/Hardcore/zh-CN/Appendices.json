{
    "hands_on_practices": [
        {
            "introduction": "在数值方法中，一个核心任务是选择离散化参数，例如网格间距 $h$ 和时间步长 $\\Delta t$。这一选择涉及一个根本性的权衡：减小这些参数通常会降低截断误差，但也可能放大舍入误差的影响。这个练习提供了一个简化的总误差模型，让您通过解析方法来探索这种权衡，并从理论上确定最佳的网格间距和时间步长。",
            "id": "3445194",
            "problem": "考虑一个标量场 $v(x,t)$，它由一维域上的线性抛物型偏微分方程（PDE）控制，且具有光滑解。假设使用空间步长为 $h>0$ 的均匀空间网格，对空间导数采用二阶（$2$ 阶）中心差分格式，并使用时间步长为 $\\Delta t \\ge 0$ 的显式一阶（$1$ 阶）前向欧拉法进行时间推进，来对 $v$ 进行数值近似。在浮点运算中，假设机器精度足够小，其主阶舍入行为可由线性模型很好地近似，我们可以将三个主要误差源合并为一个总误差包络：空间截断误差、时间截断误差以及由差分放大的舍入误差。利用泰勒展开分析截断误差，并对二阶导数使用标准的舍入误差放大模型，总误差作为 $h$ 和 $\\Delta t$ 的函数可以建模为\n$$\nE(h,\\Delta t) \\;=\\; C_{1}\\,h^{2} \\;+\\; C_{2}\\,\\Delta t \\;+\\; C_{3}\\,\\frac{u}{h^{2}},\n$$\n其中 $C_{1}>0$、$C_{2}>0$ 和 $C_{3}>0$ 是与问题相关的常数，反映了 $v$ 的光滑度和算法细节，而 $u>0$ 是单位舍入误差。为了进行此优化，假设 $h>0$ 和 $\\Delta t \\ge 0$ 不受稳定性条件的约束。\n\n从第一性原理出发——即二阶中心差分和一阶前向欧拉法的截断误差的泰勒展开，以及浮点舍入误差通过离散二阶导数的传播——论证 $E(h,\\Delta t)$ 中每一项的标度关系，然后解析地求出 $E(h,\\Delta t)$ 在 $h>0$ 和 $\\Delta t \\ge 0$ 上的最小值。\n\n给出最优网格间距 $h^{\\ast}$ 和时间步长 $\\Delta t^{\\ast}$ 关于 $u$、$C_{1}$、$C_{2}$ 和 $C_{3}$ 的封闭形式表达式。将你的最终答案表示为单行矩阵 $\\begin{pmatrix} h^{\\ast}  \\Delta t^{\\ast} \\end{pmatrix}$。无需进行数值计算或舍入。",
            "solution": "该问题要求完成两个主要任务：首先，论证给定的用于一维线性抛物型偏微分方程（PDE）数值解的误差模型中各分量的合理性；其次，找到使该总误差最小化的最优网格间距 $h^{\\ast}$ 和时间步长 $\\Delta t^{\\ast}$。\n\n总误差模型由下式给出：\n$$\nE(h,\\Delta t) = C_{1}\\,h^{2} + C_{2}\\,\\Delta t + C_{3}\\,\\frac{u}{h^{2}}\n$$\n其中 $h > 0$ 是空间网格间距，$\\Delta t \\ge 0$ 是时间步长，$C_{1}$、$C_{2}$、$C_{3}$ 是正常数，$u$ 是单位舍入误差。\n\n**第 1 部分：误差模型各项的论证**\n\n我们将从第一性原理出发，论证每一项关于 $h$ 和 $\\Delta t$ 的标度关系。\n\n**1. 空间截断误差 ($C_{1}h^{2}$):**\n问题陈述使用二阶中心差分来近似空间导数。对于一个足够光滑的标量场 $v(x)$，其在网格点 $x_j$ 处的二阶导数 $\\frac{\\partial^2 v}{\\partial x^2}$ 可近似为：\n$$\n\\frac{\\partial^2 v}{\\partial x^2}\\bigg|_{x_j} \\approx \\frac{v(x_j+h) - 2v(x_j) + v(x_j-h)}{h^2}\n$$\n此近似的截断误差可以通过对 $v(x_j+h)$ 和 $v(x_j-h)$ 在 $x_j$ 点进行泰勒级数展开来求得：\n$$\nv(x_j \\pm h) = v(x_j) \\pm h \\frac{\\partial v}{\\partial x}\\bigg|_{x_j} + \\frac{h^2}{2!} \\frac{\\partial^2 v}{\\partial x^2}\\bigg|_{x_j} \\pm \\frac{h^3}{3!} \\frac{\\partial^3 v}{\\partial x^3}\\bigg|_{x_j} + \\frac{h^4}{4!} \\frac{\\partial^4 v}{\\partial x^4}\\bigg|_{x_j} + O(h^5)\n$$\n将这些展开式代入有限差分公式：\n$$\n\\frac{v(x_j+h) - 2v(x_j) + v(x_j-h)}{h^2} = \\frac{1}{h^2} \\left[ \\left(2v(x_j) + h^2 \\frac{\\partial^2 v}{\\partial x^2}\\bigg|_{x_j} + \\frac{2h^4}{24} \\frac{\\partial^4 v}{\\partial x^4}\\bigg|_{x_j} + O(h^6) \\right) - 2v(x_j) \\right]\n$$\n$$\n= \\frac{\\partial^2 v}{\\partial x^2}\\bigg|_{x_j} + \\frac{h^2}{12} \\frac{\\partial^4 v}{\\partial x^4}\\bigg|_{x_j} + O(h^4)\n$$\n空间导数的局部截断误差 $\\tau_{space}$ 是离散近似与精确导数之差，其主导项与 $h^2$ 成正比。此局部误差在整个区域和时间演化过程中的累积，导致全局空间截断误差分量也按 $h^2$ 标度。常数 $C_1$ 包含了诸如解的四阶导数 $\\frac{\\partial^4 v}{\\partial x^4}$ 的大小等因素。因此，项 $C_1 h^2$ 是合理的。\n\n**2. 时间截断误差 ($C_{2}\\Delta t$):**\n问题使用显式一阶前向欧拉法进行时间推进。一个一般的线性抛物型偏微分方程可以写成 $\\frac{\\partial v}{\\partial t} = \\mathcal{L} v$，其中 $\\mathcal{L}$ 是一个线性空间微分算子。前向欧拉法将其离散化为：\n$$\n\\frac{v^{n+1} - v^n}{\\Delta t} = \\mathcal{L}_h v^n\n$$\n$v(x, t_n + \\Delta t)$ 在 $t_n$ 附近的泰勒级数展开为：\n$$\nv(x, t_n + \\Delta t) = v(x, t_n) + \\Delta t \\frac{\\partial v}{\\partial t}\\bigg|_{t_n} + \\frac{(\\Delta t)^2}{2!} \\frac{\\partial^2 v}{\\partial t^2}\\bigg|_{t_n} + O((\\Delta t)^3)\n$$\n时间上的局部截断误差 $\\tau_{time}$ 主导项与 $\\Delta t$ 成正比。因此，全局时间截断误差按 $\\Delta t$ 标度。常数 $C_2$ 捕捉了解的二阶时间导数 $\\frac{\\partial^2 v}{\\partial t^2}$ 的大小。因此，项 $C_2 \\Delta t$ 是合理的。\n\n**3. 舍入误差放大 ($C_{3}u/h^{2}$):**\n在浮点运算中，网格点 $v(x_j)$ 的存储值为 $\\hat{v}_j = v_j(1+\\delta_j)$，其中 $|\\delta_j| \\le u$，$u$ 是单位舍入误差。\n计算出的二阶导数中由舍入引起的误差为：\n$$\nE_{round} = \\frac{\\hat{v}_{j+1} - 2\\hat{v}_j + \\hat{v}_{j-1}}{h^2} - \\frac{v_{j+1} - 2v_j + v_{j-1}}{h^2} = \\frac{v_{j+1}\\delta_{j+1} - 2v_j\\delta_j + v_{j-1}\\delta_{j-1}}{h^2}\n$$\n该误差的最坏情况下的量级可以用三角不等式来界定。若解的特征尺度为 1，则 $|E_{round}| \\le \\frac{|v_{j+1}|u + 2|v_j|u + |v_{j-1}|u}{h^2} \\approx \\frac{4u}{h^2}$。因此舍入误差按 $\\frac{u}{h^2}$ 标度。常数 $C_3$ 吸收了数值因子和解的尺度。这论证了项 $C_3 \\frac{u}{h^2}$ 的合理性。\n\n**第 2 部分：误差函数的最小化**\n\n我们寻求在定义域 $h > 0$ 和 $\\Delta t \\ge 0$ 上最小化总误差函数 $E(h, \\Delta t)$。\n$$\nE(h, \\Delta t) = C_{1}\\,h^{2} + C_{2}\\,\\Delta t + C_{3}\\,\\frac{u}{h^{2}}\n$$\n该函数是可分的，意味着它可以写成独立变量函数之和：$E(h, \\Delta t) = f(h) + g(\\Delta t)$，其中 $f(h) = C_1 h^2 + C_3 \\frac{u}{h^2}$ 且 $g(\\Delta t) = C_2 \\Delta t$。我们可以分别对每一部分进行最小化。\n\n**关于 $\\Delta t$ 的最小化：**\n我们需要在 $\\Delta t \\ge 0$ 的约束下最小化 $g(\\Delta t) = C_2 \\Delta t$。由于给定 $C_2 > 0$，$g(\\Delta t)$ 是一个关于 $\\Delta t$ 的线性增函数。因此，它在定义域 $\\Delta t \\ge 0$ 上的最小值出现在边界处，即 $\\Delta t = 0$。\n所以，最优时间步长为 $\\Delta t^{\\ast} = 0$。\n\n**关于 $h$ 的最小化：**\n我们需要对 $h > 0$ 最小化 $f(h) = C_1 h^2 + C_3 u h^{-2}$。我们通过将关于 $h$ 的一阶导数设为零来寻找临界点。\n$$\n\\frac{\\mathrm{d}f}{\\mathrm{d}h} = \\frac{\\mathrm{d}}{\\mathrm{d}h} \\left( C_1 h^2 + C_3 u h^{-2} \\right) = 2C_1 h - 2C_3 u h^{-3}\n$$\n令导数为零：\n$$\n2C_1 h - 2C_3 u h^{-3} = 0\n$$\n$$\n2C_1 h = \\frac{2C_3 u}{h^3}\n$$\n$$\nh^4 = \\frac{C_3 u}{C_1}\n$$\n由于 $h>0$，我们取主（正实数）四次方根：\n$$\nh^{\\ast} = \\left( \\frac{C_3 u}{C_1} \\right)^{1/4}\n$$\n为了确认这是一个最小值，我们考察二阶导数：\n$$\n\\frac{\\mathrm{d}^2 f}{\\mathrm{d}h^2} = 2C_1 + 6C_3 u h^{-4}\n$$\n鉴于 $C_1 > 0$、$C_3 > 0$、$u > 0$ 且 $h > 0$，我们在定义域内对所有 $h$ 都有 $\\frac{\\mathrm{d}^2 f}{\\mathrm{d}h^2} > 0$。这证明了 $f(h)$ 是严格凸函数，因此临界点 $h^{\\ast}$ 是唯一的全局最小值。\n\n综合以上结果，最小化总误差 $E(h, \\Delta t)$ 的最优参数为 $h^{\\ast} = \\left(\\frac{C_3 u}{C_1}\\right)^{1/4}$ 和 $\\Delta t^{\\ast} = 0$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\left( \\frac{C_3 u}{C_1} \\right)^{1/4} & 0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "理查森外推法 (Richardson extrapolation) 是一种通过组合不同分辨率网格上的计算结果来提高数值解精度的强大技术。然而，这个过程并非没有代价；虽然它能有效地消除低阶截断误差项，但同时也可能放大舍入误差。本练习将引导您推导外推解，并再次面对权衡问题：找到一个最佳的网格间距，以平衡新的高阶截断误差和被放大了的舍入误差。",
            "id": "3445198",
            "problem": "考虑单位区间上的一维泊松边值问题，\n$$-u''(x)=g(x),\\quad x\\in(0,1),\\qquad u(0)=u(1)=0,$$\n其中 $g$ 足够光滑，使得精确解 $u$ 满足 $u\\in C^{6}([0,1])$。令 $U_{h}$ 表示在间距为 $h$ 的均匀网格上，通过标准二阶中心有限差分格式离散化该方程所得到的数值解，并假设该线性系统由一台机器舍入单位为 $\\epsilon_{\\text{mach}}$ 的计算机，使用后向稳定算法在浮点运算中求解。固定一个内点 $x_{\\star}$，该点同时位于间距为 $h$ 的网格和间距为 $h/2$ 的网格上。假设在点 $x_{\\star}$ 处，计算出的解具有以下渐近误差分解形式\n$$U_{h}(x_{\\star})=u(x_{\\star})+C\\,h^{2}+D\\,h^{4}+\\mathcal{O}(h^{6})+r_{h},$$\n其中 $C$ 和 $D$ 是由中心差分格式的截断展开式确定的实常数，而 $r_{h}$ 则模拟了通过线性求解过程传播的浮点舍入/扰动误差。假设以下经过充分检验的事实成立：\n- 在间距为 $h$ 的网格上，离散负拉普拉斯矩阵的谱条件数满足 $\\kappa(A_{h})\\asymp c_{\\kappa}h^{-2}$ 的标度关系，其中 $c_{\\kappa}>0$ 是一个与问题相关的常数。\n- 对于一个后向稳定的求解器，由舍入引起的解的扰动幅度与 $\\epsilon_{\\text{mach}}\\kappa(A_{h})$ 成正比，因此将 $r_{h}$ 建模为一个零均值随机变量是合适的，其标准差为 $\\sigma_{h}=R\\,h^{-2}$，其中 $R>0$ 是一个包含了与求解器相关的放大效应和 $\\epsilon_{\\text{mach}}$ 的常数。\n- 两种网格分辨率下的舍入扰动是不相关的：$r_{h}$ 和 $r_{h/2}$ 是独立的零均值随机变量，其标准差分别为 $\\sigma_{h}=R\\,h^{-2}$ 和 $\\sigma_{h/2}=R\\,(h/2)^{-2}=4R\\,h^{-2}$。\n\n从以上假设出发，执行以下步骤：\n1. 仅使用渐近形式 $U_{h}(x_{\\star})=u(x_{\\star})+C\\,h^{2}+D\\,h^{4}+\\mathcal{O}(h^{6})+r_{h}$ 及其在网格间距为 $h/2$ 时的对应形式，构造理查森外推估计量 $u_{R}(x_{\\star})$，以消除 $\\mathcal{O}(h^{2})$ 阶的截断误差项。用 $D$ 和 $h$ 表示 $u_{R}(x_{\\star})$ 中余下的主截断项。\n2. 利用 $r_{h}$ 和 $r_{h/2}$ 的独立性假设，推导 $u_{R}(x_{\\star})$ 中舍入分量的标准差，将其表示为 $R$ 和 $h$ 的函数。并以 $R\\,h^{-2}$ 的常数倍的闭式形式表示。\n3. 将 $u_{R}(x_{\\star})$ 中总误差的均方根 (RMS) 大小建模为主截断项大小与舍入标准差之和。引入 $K>0$ 表示外推估计量在 $h^{4}$ 阶继承的主截断项系数的绝对值，从而模型可写为\n$$E(h)=K\\,h^{4}+c\\,R\\,h^{-2},$$\n其中 $c>0$ 是在步骤 2 中求得的显式常数。计算使 $E(h)$ 在 $h>0$ 上最小化的网格间距 $h^{\\star}$，并给出 $h^{\\star}$ 关于 $K$ 和 $R$ 的最终闭式解析表达式。\n你的最终答案必须是单一的闭式解析表达式。不需要进行数值计算，也不应进行任何舍入。",
            "solution": "分析始于所给定的、在固定内部网格点 $x_{\\star}$ 处计算解 $U_h(x_{\\star})$ 的渐近误差分解：\n$$U_{h}(x_{\\star})=u(x_{\\star})+C\\,h^{2}+D\\,h^{4}+\\mathcal{O}(h^{6})+r_{h}$$\n其中 $u(x_{\\star})$ 是精确解，$C$ 和 $D$ 是与有限差分格式的截断误差相关的常数，$r_h$ 是传播的舍入误差。舍入误差 $r_h$ 被建模为一个零均值随机变量，其标准差为 $\\sigma_h = R\\,h^{-2}$。\n\n对于间距为 $h/2$ 的更细网格，相应的分解为：\n$$U_{h/2}(x_{\\star})=u(x_{\\star})+C\\,\\left(\\frac{h}{2}\\right)^{2}+D\\,\\left(\\frac{h}{2}\\right)^{4}+\\mathcal{O}\\left(\\left(\\frac{h}{2}\\right)^{6}\\right)+r_{h/2}$$\n简化后为：\n$$U_{h/2}(x_{\\star})=u(x_{\\star})+\\frac{1}{4}C\\,h^{2}+\\frac{1}{16}D\\,h^{4}+\\mathcal{O}(h^{6})+r_{h/2}$$\n该网格上的舍入误差 $r_{h/2}$ 是一个零均值随机变量，其标准差为 $\\sigma_{h/2} = R\\,(h/2)^{-2} = 4R\\,h^{-2}$，并且它与 $r_h$ 独立。\n\n**步骤 1：理查森外推和主截断误差**\n\n理查森外推的目标是组合 $U_{h}(x_{\\star})$ 和 $U_{h/2}(x_{\\star})$ 以消除 $\\mathcal{O}(h^2)$ 阶的主截断误差项。我们寻求一个线性组合 $u_R(x_{\\star}) = a\\,U_{h/2}(x_{\\star}) + b\\,U_h(x_{\\star})$，它能提供 $u(x_{\\star})$ 的一个更高阶近似。代入误差展开式，我们得到：\n$$u_R(x_{\\star}) = (a+b)u(x_{\\star}) + \\left(\\frac{a}{4}+b\\right)C\\,h^{2} + \\dots$$\n为了使 $u_R(x_{\\star})$ 成为 $u(x_{\\star})$ 的一个相容近似，我们必须使 $a+b=1$。为了消除 $\\mathcal{O}(h^2)$ 误差项，其系数必须为零：$\\frac{a}{4}+b=0$。这给了我们一个关于 $a$ 和 $b$ 的二元线性方程组：\n\\begin{align*} a+b = 1 \\\\ a+4b = 0 \\end{align*}\n求解该方程组得到 $a=4/3$ 和 $b=-1/3$。\n\n因此，理查森外推估计量为：\n$$u_R(x_{\\star}) = \\frac{4}{3}U_{h/2}(x_{\\star}) - \\frac{1}{3}U_h(x_{\\star})$$\n为了找到这个新估计量的主截断误差，我们代入 $U_h$ 和 $U_{h/2}$ 的完整展开式：\n$$u_R(x_{\\star}) = \\frac{4}{3}\\left(u(x_{\\star})+\\frac{1}{4}C\\,h^{2}+\\frac{1}{16}D\\,h^{4}+\\mathcal{O}(h^{6})+r_{h/2}\\right) - \\frac{1}{3}\\left(u(x_{\\star})+C\\,h^{2}+D\\,h^{4}+\\mathcal{O}(h^{6})+r_{h}\\right)$$\n按 $h$ 的幂次收集各项：\n\\begin{itemize}\n    \\item $h^4$ 项：$\\left(\\frac{4}{3}\\cdot\\frac{1}{16}-\\frac{1}{3}\\right)D\\,h^{4} = \\left(\\frac{1}{12}-\\frac{4}{12}\\right)D\\,h^{4} = -\\frac{3}{12}D\\,h^{4} = -\\frac{1}{4}D\\,h^{4}$\n\\end{itemize}\n$u_R(x_{\\star})$ 中余下的主截断项是 $-\\frac{1}{4}D\\,h^{4}$。\n\n**步骤 2：舍入分量的标准差**\n\n$u_R(x_{\\star})$ 中误差的舍入分量是随机变量 $r_R = \\frac{4}{3}r_{h/2} - \\frac{1}{3}r_h$。我们需要求出其标准差 $\\sigma_{r_R}$。由于 $r_h$ 和 $r_{h/2}$ 是零均值且独立的，它们线性组合的方差为：\n$$\\text{Var}(r_R) = \\text{Var}\\left(\\frac{4}{3}r_{h/2} - \\frac{1}{3}r_h\\right) = \\left(\\frac{4}{3}\\right)^2\\text{Var}(r_{h/2}) + \\left(-\\frac{1}{3}\\right)^2\\text{Var}(r_h)$$\n我们已知标准差为 $\\sigma_h = R\\,h^{-2}$ 和 $\\sigma_{h/2} = 4R\\,h^{-2}$。其方差分别为 $\\text{Var}(r_h) = \\sigma_h^2 = R^2\\,h^{-4}$ 和 $\\text{Var}(r_{h/2}) = \\sigma_{h/2}^2 = 16R^2\\,h^{-4}$。\n将这些代入 $r_R$ 的方差表达式中：\n$$\\text{Var}(r_R) = \\frac{16}{9}\\left(16R^2\\,h^{-4}\\right) + \\frac{1}{9}\\left(R^2\\,h^{-4}\\right) = \\left(\\frac{256}{9} + \\frac{1}{9}\\right)R^2\\,h^{-4} = \\frac{257}{9}R^2\\,h^{-4}$$\n标准差是方差的平方根：\n$$\\sigma_{r_R} = \\sqrt{\\frac{257}{9}R^2\\,h^{-4}} = \\frac{\\sqrt{257}}{3}R\\,h^{-2}$$\n这符合 $c\\,R\\,h^{-2}$ 的形式，其中常数 $c=\\frac{\\sqrt{257}}{3}$。\n\n**步骤 3：最优网格间距**\n\n问题将总误差的均方根 (RMS) 大小建模为主截断项大小与舍入标准差之和：\n$$E(h) = K\\,h^{4} + c\\,R\\,h^{-2}$$\n根据步骤 1，主截断项为 $-\\frac{1}{4}D\\,h^4$，因此其大小为 $\\frac{|D|}{4}h^4$。问题将 $K$ 定义为此系数，所以 $K = \\frac{|D|}{4}$。\n根据步骤 2，舍入误差的标准差为 $\\frac{\\sqrt{257}}{3}R\\,h^{-2}$，所以常数 $c$ 为 $\\frac{\\sqrt{257}}{3}$。\n需要最小化的总误差模型为：\n$$E(h) = K\\,h^{4} + \\frac{\\sqrt{257}}{3}R\\,h^{-2}$$\n为了找到在 $h>0$ 上使 $E(h)$ 最小的网格间距 $h^{\\star}$，我们计算其关于 $h$ 的导数并令其为零：\n$$\\frac{dE}{dh} = 4K\\,h^{3} - 2\\frac{\\sqrt{257}}{3}R\\,h^{-3}$$\n令导数为零可得到最优的 $h=h^{\\star}$：\n$$4K\\,(h^{\\star})^{3} = \\frac{2\\sqrt{257}}{3}R\\,(h^{\\star})^{-3}$$\n两边乘以 $(h^{\\star})^3$ 并重新整理以求解 $(h^{\\star})^6$：\n$$(h^{\\star})^{6} = \\frac{2\\sqrt{257}R}{12K} = \\frac{\\sqrt{257}R}{6K}$$\n最后，取正实六次根得到最优网格间距：\n$$h^{\\star} = \\left(\\frac{\\sqrt{257}R}{6K}\\right)^{\\frac{1}{6}}$$\n二阶导数 $\\frac{d^2E}{dh^2} = 12K\\,h^2 + 2\\sqrt{257}R\\,h^{-4}$，对于 $h>0$ 是严格为正的，这证实了该临界点是一个全局最小值。",
            "answer": "$$\n\\boxed{\\left(\\frac{\\sqrt{257}R}{6K}\\right)^{\\frac{1}{6}}}\n$$"
        },
        {
            "introduction": "数值方法的理论稳定性条件，例如显式热方程求解器的稳定性条件，通常是在精确算术的假设下推导出来的。在实际计算中，有限精度的浮点运算可能导致这些条件被意外违反，即使参数表面上满足要求，从而产生非物理的计算结果。本编程练习将通过一个经典的例子——离散最大值原理的破坏——来具体展示这一现象，并要求您实现一个对舍入误差更鲁棒的稳定化方案。",
            "id": "3445163",
            "problem": "考虑一个抛物型偏微分方程，即热方程 $u_t = \\kappa \\nabla^2 u$，它定义在一个具有齐次 Dirichlet 边界条件的一维空间域上。从前向欧拉时间步进和空间中心有限差分的定义出发，为内部网格点构建一个三点线性模板更新。解释在某个依赖于时间步长、扩散系数和网格间距的适当约束下，更新是相邻值的凸组合这一要求如何引出离散极值原理。然后，研究浮点运算层面的舍入如何在稳定性阈值附近扰动计算出的更新系数，并导致违反离散极值原理，即使在精确的数学系数满足条件的情况下也是如此。\n\n你的程序必须实现以下内容：\n\n- 一个包含 $N$ 个节点的一维网格，覆盖长度为 $L$ 的域，网格间距为 $h = L/(N-1)$，并在端点 $x=0$ 和 $x=L$ 处施加齐次 Dirichlet 边界条件。\n- 对内部节点使用中心二阶有限差分模板的前向欧拉显式更新。\n- 两种运算模式，一种使用双精度，另一种使用由国际电气与电子工程师协会（IEEE）754 标准定义的单精度。\n- 一个离散极值原理检测器，在每个时间步断言全局最小值不低于其初始值，全局最大值不高于其初始值。该检测器应返回一个布尔值，指示在所有步骤中是否保持了单调性。\n\n提出并实现一种稳定化方法，通过修改计算出的权重以确保它们在应用更新前是非负的并重新归一化以使总和为 $1$，从而在存在舍入的情况下可证明地保持单调性。此稳定化方法必须在每次更新之前逐点应用于模板系数。\n\n使用以下测试套件。所有量均为无量纲。\n\n- 测试 A（双精度，理想路径）：$N=101$，$L=1$，步数 $T=50$，$\\kappa=1$，初始条件 $u(x)$ 除中点处一个振幅为 $A=1$ 的内部尖峰外处处为零。所有运算使用双精度算术。选择时间步长 $dt$ 为 $dt = 0.49 \\, h^2$，其中 $h=L/(N-1)$。\n- 测试 B（单精度，阈值处的舍入引发的违规）：$N=3$，$L=1$，$T=1$，$\\kappa=1$，$A=1$，及单精度算术。使用时间步长 $dt = 0.125000015$（单精度）。注意，当 $N=3$ 时有 $h=0.5$，因此计算出的模板权重因子实际上处于阈值，并将受到舍入的扰动。\n- 测试 C（单精度，接近机器精度的振幅）：与测试 B 相同，但 $A = \\epsilon_{32}$，其中 $\\epsilon_{32}$ 是单精度机器精度。\n- 测试 D（单精度，略低于阈值）：$N=3$，$L=1$，$T=1$，$\\kappa=1$，$A=1$，单精度算术，以及 $dt = 0.124999985$。\n\n对每个测试，运行朴素显式格式和稳定化格式。你的程序应生成单行输出，包含八个布尔值，顺序如下：测试 A、B、C 和 D 中朴素格式的单调性保持情况，接着是测试 A、B、C 和 D 中稳定化格式的单调性保持情况。输出必须是一个用方括号括起来的逗号分隔列表，例如，“[True,False,True,False,True,True,True,True]”。布尔值必须使用 Python 的默认布尔值格式（“True”或“False”）打印。",
            "solution": "该问题要求分析一维热方程 $u_t = \\kappa u_{xx}$ 的一种数值格式，并研究其关于离散极值原理和浮点舍入误差影响的稳定性。\n\n首先，我们推导数值模板。时间导数 $u_t$ 使用前向欧拉方法近似，空间二阶导数 $u_{xx}$ 使用中心有限差分近似。将这些代入热方程得到：\n$$\n\\frac{u_j^{n+1} - u_j^n}{dt} = \\kappa \\left( \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{h^2} \\right)\n$$\n为求得更新规则，我们解出 $u_j^{n+1}$：\n$$\nu_j^{n+1} = u_j^n + \\frac{\\kappa \\, dt}{h^2} (u_{j+1}^n - 2u_j^n + u_{j-1}^n)\n$$\n我们引入无量纲扩散数 $s = \\frac{\\kappa \\, dt}{h^2}$。重新整理各项得到三点线性模板更新：\n$$\nu_j^{n+1} = s u_{j-1}^n + (1 - 2s) u_j^n + s u_{j+1}^n\n$$\n离散极值原理（DMP）要求更新是相邻值的凸组合。这需要权重非负且和为1。权重之和 $s + (1 - 2s) + s = 1$ 总是满足。非负性要求 $s \\ge 0$（满足）和 $1 - 2s \\ge 0$，即 $s \\le \\frac{1}{2}$。这就是众所周知的稳定性约束。\n\n问题的核心在于此数学条件与有限精度算术的相互作用。在测试 B 中，$N=3, L=1$ 给出 $h=0.5$，因此 $h^2=0.25$。稳定性阈值 $s=1/2$ 对应于 $dt=0.125$。测试 B 使用的 $dt = 0.125000015$ 在单精度下被舍入为一个严格大于 $0.125$ 的数。这导致计算出的 $s$ 严格大于 $0.5$，从而中心权重 $1-2s$ 变为负数。对于尖峰初始条件，这会导致新的极小值产生，违反了 DMP。\n\n为了纠正这个问题，我们实现一个稳定化格式。该方法在应用更新前强制权重为非负并重新归一化，以确保更新始终是凸组合，从而可证明地保持 DMP。\n1.  计算理论权重 $w = [s, 1-2s, s]$。\n2.  应用逐点非负性钳位（clamping）：对每个分量 $k$，有 $w'_k = \\max(0, w_k)$。\n3.  重新归一化权重以确保其和为 $1$：$W = \\sum_k w'_k$。如果 $W > 0$，则最终权重为 $w''_k = w'_k / W$。\n\n这个过程保证了最终的权重是非负的且和为 1，从而稳健地保护了格式免受稳定性边界附近系数因舍入引起的符号翻转的影响。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(N: int, L: float, T: int, kappa: float, A: float, dt: float, dtype: np.dtype, stabilized: bool) -> bool:\n    \"\"\"\n    Runs a 1D heat equation simulation and checks for discrete maximum principle preservation.\n\n    Args:\n        N: Number of grid nodes.\n        L: Length of the spatial domain.\n        T: Number of time steps.\n        kappa: Diffusion coefficient.\n        A: Amplitude of the initial spike.\n        dt: Time step size.\n        dtype: Numpy data type (np.float64 or np.float32) for precision.\n        stabilized: If True, uses the stabilized stencil weights.\n\n    Returns:\n        A boolean indicating if the discrete maximum principle was preserved (True) or not (False).\n    \"\"\"\n    _L = dtype(L)\n    _kappa = dtype(kappa)\n    _A = dtype(A)\n    _dt = dtype(dt)\n\n    h = _L / dtype(N - 1)\n    u = np.zeros(N, dtype=dtype)\n    if N > 1:\n        mid_idx = (N - 1) // 2\n        u[mid_idx] = _A\n\n    min_initial = u.min()\n    max_initial = u.max()\n\n    s = _kappa * _dt / (h**2)\n\n    for _ in range(T):\n        u_old = u.copy()\n        \n        for j in range(1, N - 1):\n            w_left = s\n            w_center = dtype(1.0) - dtype(2.0) * s\n            w_right = s\n\n            if stabilized:\n                weights = [w_left, w_center, w_right]\n                weights = [max(dtype(0.0), w) for w in weights]\n                w_sum = sum(weights)\n                if w_sum > dtype(0.0):\n                    weights = [w / w_sum for w in weights]\n                w_left, w_center, w_right = weights\n\n            u[j] = w_left * u_old[j - 1] + w_center * u_old[j] + w_right * u_old[j + 1]\n\n        if u.min()  min_initial or u.max() > max_initial:\n            return False\n\n    return True\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test suite, printing the results in the required format.\n    \"\"\"\n    h_A = 1.0 / (101 - 1)\n    dt_A = 0.49 * h_A**2\n\n    test_cases = [\n        {'N': 101, 'L': 1.0, 'T': 50, 'kappa': 1.0, 'A': 1.0,   'dt': dt_A, 'dtype': np.float64},\n        {'N': 3,   'L': 1.0, 'T': 1,  'kappa': 1.0, 'A': 1.0,   'dt': 0.125000015, 'dtype': np.float32},\n        {'N': 3,   'L': 1.0, 'T': 1,  'kappa': 1.0, 'A': np.finfo(np.float32).eps, 'dt': 0.125000015, 'dtype': np.float32},\n        {'N': 3,   'L': 1.0, 'T': 1,  'kappa': 1.0, 'A': 1.0,   'dt': 0.124999985, 'dtype': np.float32}\n    ]\n\n    results_naive = []\n    for params in test_cases:\n        res = run_simulation(stabilized=False, **params)\n        results_naive.append(res)\n        \n    results_stabilized = []\n    for params in test_cases:\n        res = run_simulation(stabilized=True, **params)\n        results_stabilized.append(res)\n\n    final_results = results_naive + results_stabilized\n    \n    print(f\"[{','.join(str(r).capitalize() for r in final_results)}]\")\n\nsolve()\n```"
        }
    ]
}