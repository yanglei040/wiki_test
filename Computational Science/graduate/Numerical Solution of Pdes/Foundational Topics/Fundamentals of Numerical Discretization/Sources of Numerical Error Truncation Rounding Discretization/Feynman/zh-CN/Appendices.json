{
    "hands_on_practices": [
        {
            "introduction": "偏微分方程数值解的稳定性是其核心要求之一。本练习将以热传导方程为例，探讨离散最大值原理（DMP），这是一个关键的稳定性判据。您将通过动手编程，亲眼见证一个理论上稳定的数值格式，如何因浮点运算中的舍入误差而违反该原理，并学习如何通过修正计算模板来恢复其单调性，确保结果的物理意义 。",
            "id": "3445163",
            "problem": "考虑定义在一维空间域上且带有齐次狄利克雷边界条件的抛物型偏微分方程，即热方程：$u_t = \\kappa \\nabla^2 u$。从前向欧拉时间步进和空间中心有限差分的定义出发，为内部网格点构建一个三点线性模板更新格式。解释在依赖于时间步长、扩散系数和网格间距的适当约束下，更新是相邻值的凸组合这一要求是如何引出离散极值原理的。然后，研究浮点运算层面的舍入误差如何能在稳定性阈值附近扰动计算出的更新系数，并导致对离散极值原理的违背，即使精确的数学系数满足该条件。\n\n你的程序必须实现以下内容：\n\n- 一个在一维域上包含 $N$ 个节点、长度为 $L$ 的网格，网格间距为 $h = L/(N-1)$，并在端点 $x=0$ 和 $x=L$ 处施加齐次狄利克雷边界条件。\n- 一个对内部节点使用中心二阶有限差分模板的前向欧拉显式更新。\n- 两种算术模式：一种使用双精度，另一种使用由电气和电子工程师协会 (IEEE) 754 标准定义的单精度。\n- 一个离散极值原理检测器，在每个时间步断言全局最小值不低于其初始值，全局最大值不高于其初始值。该检测器应返回一个布尔值，指示在所有步骤中是否保持了单调性。\n\n提出并实现一种稳定化方法，通过修改计算出的权重以确保其非负并在应用更新前重新归一化使其和为 $1$，从而在存在舍入误差时可证明地保持单调性。此稳定化方法必须在每次更新之前逐点应用于模板系数。\n\n使用以下测试套件。所有量均为无量纲。\n\n- 测试 A（双精度，理想情况）：$N=101$, $L=1$, 步数 $T=50$, $\\kappa=1$, 初始条件 $u(x)$ 除中点处一个振幅为 $A=1$ 的尖峰外处处为零。所有运算使用双精度算术。选择时间步长 $dt$ 为 $dt = 0.49 \\, h^2$，其中 $h=L/(N-1)$。\n- 测试 B（单精度，阈值处的舍入导致违背）：$N=3$, $L=1$, $T=1$, $\\kappa=1$, $A=1$，及单精度算术。使用时间步长 $dt = 0.125000015$（单精度）。注意，当 $N=3$ 时，有 $h=0.5$，因此计算出的模板权重因子实际上处于阈值上，并将被舍入误差扰动。\n- 测试 C（单精度，接近机器ε的振幅）：与测试 B 相同，但 $A = \\epsilon_{32}$，其中 $\\epsilon_{32}$ 是单精度机器ε。\n- 测试 D（单精度，略低于阈值）：$N=3$, $L=1$, $T=1$, $\\kappa=1$, $A=1$，单精度算术，以及 $dt = 0.124999985$。\n\n对每个测试，同时运行朴素显式格式和稳定化格式。你的程序应生成单行输出，包含八个布尔值，顺序如下：测试 A、B、C 和 D 中朴素格式的单调性保持情况，随后是测试 A、B、C 和 D 中稳定化格式的单调性保持情况。输出必须是方括号括起来的逗号分隔列表，例如，“[true,false,true,false,true,true,true,true]”。布尔值必须使用 Python 的默认布尔格式（“True”或“False”）打印。",
            "solution": "所述问题在科学上是合理的、适定的，并基于偏微分方程数值分析的既定原则。所有必要的条件和参数都已提供，以获得唯一且有意义的解。其中心主题——理论稳定性准则与在有限精度算术中的实际实现之间的相互作用——是计算科学中一个有效且重要的话题。因此，我们着手提供一个完整的解。\n\n该问题要求分析一维热方程 $u_t = \\kappa \\nabla^2 u$（在一维空间中简化为 $u_t = \\kappa u_{xx}$）的数值格式。我们需要构建一个数值更新规则，并分析其稳定性属性，特别是关于离散极值原理和浮点舍入误差的影响。\n\n首先，我们推导数值模板。我们在一个均匀网格上离散化该偏微分方程，其中 $u_j^n$ 近似真解 $u(x_j, t_n)$，空间网格点为 $x_j = j h$，离散时间层为 $t_n = n \\, dt$。对于长度为 $L$、包含 $N$ 个网格节点的域，空间步长为 $h = L/(N-1)$。\n\n时间导数 $u_t$ 使用前向欧拉法（一种一阶精度的显式格式）来近似：\n$$\nu_t \\approx \\frac{u_j^{n+1} - u_j^n}{dt}\n$$\n空间二阶导数 $u_{xx}$ 使用二阶精度的中心有限差分来近似：\n$$\nu_{xx} \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{h^2}\n$$\n将这些近似代入热方程 $u_t = \\kappa u_{xx}$ 得到：\n$$\n\\frac{u_j^{n+1} - u_j^n}{dt} = \\kappa \\left( \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{h^2} \\right)\n$$\n为了找到更新规则，我们求解 $u_j^{n+1}$：\n$$\nu_j^{n+1} = u_j^n + \\frac{\\kappa \\, dt}{h^2} (u_{j+1}^n - 2u_j^n + u_{j-1}^n)\n$$\n我们引入无量纲扩散数 $s = \\frac{\\kappa \\, dt}{h^2}$。通过代入 $s$ 并根据在时间层 $n$ 的空间位置重新整理各项，我们得到所有内部网格点（$j=1, \\dots, N-2$）的三点线性模板更新：\n$$\nu_j^{n+1} = s u_{j-1}^n + (1 - 2s) u_j^n + s u_{j+1}^n\n$$\n此方程表明，网格点 $(j, n+1)$ 处的解是点 $(j-1, n)$、$(j, n)$ 和 $(j+1, n)$ 处解的线性组合。\n\n接下来，我们分析离散极值原理 (DMP)。DMP 指出，对于齐次热方程，解在整个时空域中的最大值在初始或边界数据上达到。在数值上，如果网格上解的全局最大值不随时间增加，且全局最小值不随时间减少，则称一个格式满足 DMP。\n\n更新规则 $u_j^{n+1} = w_{j-1}u_{j-1}^n + w_j u_j^n + w_{j+1}u_{j+1}^n$（其中权重为 $w_{j-1}=s$, $w_j=1-2s$ 和 $w_{j+1}=s$）是一个凸组合，如果满足两个条件：\n1.  权重非负：$w_k \\ge 0$。\n2.  权重和为一：$\\sum_k w_k = 1$。\n\n我们来检查和：$s + (1 - 2s) + s = 1$。此条件总是满足的。\n对于非负性，我们要求：\n-   $s = \\frac{\\kappa \\, dt}{h^2} \\ge 0$。由于 $\\kappa$、$dt$ 和 $h^2$ 是非负的物理或离散化参数，此条件得到满足。\n-   $1 - 2s \\ge 0$。这是关键约束，它意味着 $s \\le \\frac{1}{2}$。\n\n代入 $s$ 的定义，我们得到这个显式格式著名的稳定性约束：\n$$\n\\frac{\\kappa \\, dt}{h^2} \\le \\frac{1}{2}\n$$\n如果此条件成立，则更新是一个凸组合。因此，$u_j^{n+1}$ 的值必须位于其前一时间步邻居值的范围内：\n$$\n\\min(u_{j-1}^n, u_j^n, u_{j+1}^n) \\le u_j^{n+1} \\le \\max(u_{j-1}^n, u_j^n, u_{j+1}^n)\n$$\n这个局部性质蕴含了一个全局性质。在时间 $n+1$ 时网格上的最大值不能超过时间 $n$ 时的最大值：$\\max_j u_j^{n+1} \\le \\max_j u_j^n$。类似地，$\\min_j u_j^{n+1} \\ge \\min_j u_j^n$。这确保了 DMP 得以满足。齐次狄利克雷边界条件（$u_0^n = u_{N-1}^n = 0$）与此原理是一致的。\n\n问题的核心在于这个数学条件与有限精度计算机算术之间的相互作用。我们来分析测试 B：$N=3, L=1, \\kappa=1$，使用单精度 (float32) 算术。网格间距为 $h = L/(N-1) = 1/(3-1) = 0.5$，所以 $h^2 = 0.25$。稳定性阈值 $s=1/2$ 对应于 $dt = s h^2 / \\kappa = 0.5 \\times 0.25 / 1.0 = 0.125$。值 $dt=0.125$ 在二进制浮点中是可精确表示的。\n测试 B 使用的时间步长为 $dt_{raw} = 0.125000015$。当它被存储为单精度浮点数时，它会被舍入到最接近的可表示数，即 $dt_{comp} \\approx 0.12500001$。这个值严格大于 $0.125$。\n计算出的扩散数为 $s_{comp} = \\kappa \\frac{dt_{comp}}{h^2} = 1.0 \\times \\frac{0.12500001}{0.25} = 0.50000004$。这个值严格大于 $0.5$。\n然后，中心模板权重计算为 $w_j = 1 - 2s_{comp} = 1.0 - 2.0 \\times 0.50000004 = 1.0 - 1.0000001 = -1.1920929 \\times 10^{-7}$，这大约是单精度机器ε的负值。\n由于中心系数是负的，凸组合的条件被违背了。对于单个尖峰的初始条件（$u_1^0 = 1$，且 $u_0^0=u_2^0=0$），更新为 $u_1^1=(1-2s)u_1^0$。由于系数为负，$u_1^1$ 会变为负值。初始最小值为 $0$；新的最小值是负数，因此违背了 DMP。这演示了在标准浮点实现中，由于舍入误差，一个在数学上稳定的参数选择（如果使用任意精度算术的话）如何变得不稳定。测试 C 显示了同样的违背情况，而测试 D 使用了一个略低于阈值的 $dt$，它舍入后的值能维持 $s \\le 1/2$，因此保持了 DMP。\n\n为了纠正这个问题，我们实现一个稳定化格式。问题在于计算出的系数 $[s, 1-2s, s]$ 可能无法通过非负性测试。该稳定化方法直接强制执行此属性：\n1.  计算理论权重 $w = [s, 1-2s, s]$。\n2.  逐点应用非负性钳制：对每个分量 $k$，$w'_k = \\max(0, w_k)$。\n3.  重新归一化权重以确保其和为 $1$：$W = \\sum_k w'_k$。如果 $W > 0$，则最终权重为 $w''_k = w'_k / W$。\n\n此过程保证了最终的权重 $[w''_{j-1}, w''_j, w''_{j+1}]$ 是非负的且和为一。因此，更新被强制为凸组合，并且离散极值原理得到可证明的保持，从而稳健地保护格式免受稳定性边界附近由舍入引起的系数符号翻转的影响。对于远在稳定区域内的情况（如测试 A）或边界附近表现良好的情况（如测试 D），这种稳定化没有效果，因为初始权重已经是非负的且和为 $1$。然而，对于像测试 B 和 C 这样的病态情况，它能正确地将小的负系数裁剪为零，从而防止违背发生。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N: int, L: float, T: int, kappa: float, A: float, dt: float, dtype: np.dtype, stabilized: bool) -> bool:\n    \"\"\"\n    Runs a 1D heat equation simulation and checks for discrete maximum principle preservation.\n\n    Args:\n        N: Number of grid nodes.\n        L: Length of the spatial domain.\n        T: Number of time steps.\n        kappa: Diffusion coefficient.\n        A: Amplitude of the initial spike.\n        dt: Time step size.\n        dtype: Numpy data type (np.float64 or np.float32) for precision.\n        stabilized: If True, uses the stabilized stencil weights.\n\n    Returns:\n        A boolean indicating if the discrete maximum principle was preserved (True) or not (False).\n    \"\"\"\n    # Cast parameters to the specified data type for consistent precision\n    _L = dtype(L)\n    _kappa = dtype(kappa)\n    _A = dtype(A)\n    _dt = dtype(dt)\n\n    # Initialize grid and initial condition\n    h = _L / dtype(N - 1)\n    u = np.zeros(N, dtype=dtype)\n    if N > 1:\n        mid_idx = (N - 1) // 2\n        u[mid_idx] = _A\n\n    # Store initial min/max for DMP check\n    min_initial = u.min()\n    max_initial = u.max()\n\n    # Calculate stencil parameter s\n    s = _kappa * _dt / (h**2)\n\n    # Time-stepping loop\n    for _ in range(T):\n        u_old = u.copy()\n        \n        # Update interior nodes\n        for j in range(1, N - 1):\n            # Calculate theoretical weights\n            w_left = s\n            w_center = dtype(1.0) - dtype(2.0) * s\n            w_right = s\n\n            if stabilized:\n                weights = [w_left, w_center, w_right]\n                # 1. Pointwise non-negativity\n                weights = [max(dtype(0.0), w) for w in weights]\n                # 2. Renormalize to sum to 1\n                w_sum = sum(weights)\n                if w_sum > dtype(0.0):\n                    weights = [w / w_sum for w in weights]\n                \n                w_left, w_center, w_right = weights\n\n            # Apply update\n            u[j] = w_left * u_old[j - 1] + w_center * u_old[j] + w_right * u_old[j + 1]\n\n        # Check for discrete maximum principle violation\n        # The principle states that the min should not decrease and the max should not increase.\n        if u.min() < min_initial or u.max() > max_initial:\n            return False\n\n    return True\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test suite, printing the results in the required format.\n    \"\"\"\n    # Test A: L=1, N=101 => h = 1/100 = 0.01. kappa=1.\n    # dt = 0.49 * h^2 / kappa = 0.49 * (0.01)^2 = 0.000049.\n    h_A = 1.0 / (101 - 1)\n    dt_A = 0.49 * h_A**2\n\n    # Define test cases as specified in the problem statement\n    test_cases = [\n        {'N': 101, 'L': 1.0, 'T': 50, 'kappa': 1.0, 'A': 1.0,   'dt': dt_A, 'dtype': np.float64},\n        {'N': 3,   'L': 1.0, 'T': 1,  'kappa': 1.0, 'A': 1.0,   'dt': 0.125000015, 'dtype': np.float32},\n        {'N': 3,   'L': 1.0, 'T': 1,  'kappa': 1.0, 'A': np.finfo(np.float32).eps, 'dt': 0.125000015, 'dtype': np.float32},\n        {'N': 3,   'L': 1.0, 'T': 1,  'kappa': 1.0, 'A': 1.0,   'dt': 0.124999985, 'dtype': np.float32}\n    ]\n\n    results_naive = []\n    for params in test_cases:\n        res = run_simulation(stabilized=False, **params)\n        results_naive.append(res)\n        \n    results_stabilized = []\n    for params in test_cases:\n        res = run_simulation(stabilized=True, **params)\n        results_stabilized.append(res)\n\n    final_results = results_naive + results_stabilized\n    \n    # Format the final output exactly as required\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "守恒律是许多物理系统的基本属性，数值格式也应尽可能地保持这些性质。本练习将关注线性平流方程，并研究其在中心差分格式下离散能量的守恒特性。您将通过一个精心设计的数值实验，量化并区分由时间离散（截断误差）和浮点运算（舍入误差）分别导致的能量变化，从而深入理解数值耗散的来源 。",
            "id": "3445225",
            "problem": "考虑线性平流偏微分方程 (PDE) $u_t + a u_x = 0$，定义在周期性区间 $[0,1)$ 上，并在一个包含 $N$ 个点、网格间距为 $\\Delta x = 1/N$ 的均匀网格上进行离散化。令 $x_i = i \\Delta x$（其中 $i \\in \\{0,1,\\dots,N-1\\}$），并定义一个离散状态向量 $u \\in \\mathbb{R}^N$，其分量 $u_i \\approx u(x_i,t)$。空间导数的中心二阶有限差分为\n$$\n(Du)_i = \\frac{u_{i+1} - u_{i-1}}{2 \\Delta x},\n$$\n其中索引是周期性的，即 $u_{-1} \\equiv u_{N-1}$ 且 $u_N \\equiv u_0$。该半离散系统为\n$$\n\\frac{d u}{dt} = L(u), \\quad \\text{其中} \\quad L(u) = -a\\, D u.\n$$\n在精确算术中，如果 $L$ 是一个完全的斜对称表示，离散能量 $E(u) = \\tfrac{1}{2} \\|u\\|_2^2$ 在该常微分方程下是守恒的。然而，当使用浮点算术计算 $L(u)$ 时，舍入误差在计算双线性和内积的层面上破坏了精确的斜对称性，导致在单个前向欧拉步中可以观察到非零的能量变化。\n\n您的任务是，对于一个前向欧拉步，\n$$\nu^{n+1} = u^n + \\Delta t\\, L(u^n),\n$$\n量化单步能量变化中由舍入引起的分量相对于截断分量的大小。请纯粹在数学术语下进行操作，不涉及物理单位。初始条件中使用的角度必须解释为弧度。\n\n实现以下步骤：\n\n1. 使用均匀网格点 $x_i = i \\Delta x$ 和上述指定的周期性中心空间差分。使用前向欧拉时间步进方法，时间步长为 $\\Delta t = \\text{CFL} \\cdot \\Delta x / |a|$，其中 $\\text{CFL}$ 是给定的 Courant–Friedrichs–Lewy (CFL) 数。\n\n2. 对于每个指定的测试用例，按以下方式构造初始条件 $u^0$：\n$$\nu^0_i = \\sin(2\\pi k\\, x_i),\n$$\n其中整数波数 $k \\ge 0$ 应解释为弧度。\n\n3. 令 $\\langle \\cdot,\\cdot \\rangle$ 表示标准的欧几里得内积，$\\|\\cdot\\|_2$ 表示相关的范数，两者均在浮点算术中计算。定义离散能量 $E(u) = \\tfrac{1}{2} \\|u\\|_2^2$。在一个前向欧拉步中，计算：\n   - 由舍入引起的单步能量贡献\n     $$\n     R := \\Delta t\\, \\langle u^0, L(u^0) \\rangle,\n     $$\n     如果 $L$ 作为一个斜对称线性算子在精确算术中进行应用和配对，该值将精确为零。\n   - 截断贡献\n     $$\n     T := \\tfrac{1}{2}\\, \\Delta t^2\\, \\|L(u^0)\\|_2^2,\n     $$\n     该项源于对一个保范数连续流的离散时间步进。\n\n4. 计算实际的单步能量变化\n$$\n\\Delta E := E\\big(u^0 + \\Delta t\\, L(u^0)\\big) - E(u^0),\n$$\n和预测值 $\\widehat{\\Delta E} := R + T$。报告比率 $r := |R|/T$（如果 $T = 0$ 则定义 $r := 0$）和相对一致性误差\n$$\ne := \\frac{|\\Delta E - \\widehat{\\Delta E}|}{\\max\\{|\\Delta E|, \\varepsilon\\}},\n$$\n其中 $\\varepsilon = 10^{-300}$ 以避免除以零。所有用于构成 $R$、$T$ 和 $\\Delta E$ 的求和与内积，都必须使用补偿求和（例如 Kahan 求和算法）以确定性和补偿性的方式进行评估，从而最大限度地减少对求和顺序的依赖，并分离出空间算子和单步更新中固有的舍入效应。\n\n测试套件和参数覆盖范围：\n\n- 情况1（正常路径）：$N = 1024$，$a = 1$，$\\text{CFL} = 0.1$，$k = 8$。\n- 情况2（小时间步长，舍入主导）：$N = 1024$，$a = 1$，$\\text{CFL} = 10^{-6}$，$k = 8$。\n- 情况3（高波数，近奈奎斯特内容）：$N = 1024$，$a = 1$，$\\text{CFL} = 0.9$，$k = 256$。\n- 情况4（粗网格边界情况）：$N = 16$，$a = 1$，$\\text{CFL} = 0.1$，$k = 3$。\n- 情况5（零模式边缘情况）：$N = 64$，$a = 1$，$\\text{CFL} = 0.1$，$k = 0$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按上述顺序包含每个案例的浮点数对 $[r,e]$，依次连接成一个长度为 10 的扁平列表。例如，输出格式必须是\n$$\n[\\;r_1,\\;e_1,\\;r_2,\\;e_2,\\;r_3,\\;e_3,\\;r_4,\\;e_4,\\;r_5,\\;e_5\\;].\n$$",
            "solution": "问题陈述已经过仔细审查，并被确定为有效。它提出了一个在数值分析领域中定义明确且具有科学依据的练习，涉及偏微分方程数值积分中的误差来源。该问题是自包含的，所有参数和函数都有明确的定义。它探讨了离散化方法固有的截断误差与浮点算术产生的舍入误差之间微妙但重要的区别。\n\n问题的核心是分析一个守恒量——离散能量，在单个时间步长内的变化。该偏微分方程是线性平流方程 $u_t + a u_x = 0$。在具有 $N$ 个点 $x_i = i \\Delta x$（其中 $\\Delta x=1/N$）的周期域上的半离散化由下式给出\n$$\n\\frac{d u}{dt} = L(u), \\quad \\text{其中} \\quad (L(u))_i = -a (D u)_i = -a \\frac{u_{i+1} - u_{i-1}}{2 \\Delta x}。\n$$\n向量 $u(t) \\in \\mathbb{R}^N$ 的分量为 $u_i(t) \\approx u(x_i, t)$。\n\n在精确算术中，离散算子 $D$ 对于标准欧几里得内积 $\\langle v, w \\rangle = \\sum_i v_i w_i$ 是斜对称的。这个性质 $\\langle v, D w \\rangle = - \\langle D v, w \\rangle$ 可以通过使用周期性边界条件的分部求和法来证明。因此，对于任何实常数 $a$，算子 $L = -a D$ 也是斜对称的。\n斜对称性的一个直接结果是，由该半离散系统生成的流守恒离散能量 $E(u) = \\frac{1}{2} \\|u\\|_2^2 = \\frac{1}{2} \\langle u, u \\rangle$。能量的变化率为\n$$\n\\frac{dE}{dt} = \\frac{d}{dt} \\left( \\frac{1}{2} \\langle u, u \\rangle \\right) = \\langle u, \\frac{du}{dt} \\rangle = \\langle u, L(u) \\rangle。\n$$\n由于 $L$ 是斜对称的，$\\langle u, L(u) \\rangle = 0$，因此能量是守恒的。\n\n问题接着引入了一种时间离散化方法，即前向欧拉法：\n$$\nu^{n+1} = u^n + \\Delta t L(u^n)。\n$$\n即使在精确算术中，该方法也不守恒能量。单步能量变化 $\\Delta E = E(u^{n+1}) - E(u^n)$ 可以计算如下：\n$$\n\\Delta E = \\frac{1}{2} \\langle u^n + \\Delta t L(u^n), u^n + \\Delta t L(u^n) \\rangle - \\frac{1}{2} \\langle u^n, u^n \\rangle\n$$\n$$\n\\Delta E = \\frac{1}{2} \\left( \\langle u^n, u^n \\rangle + 2 \\Delta t \\langle u^n, L(u^n) \\rangle + \\Delta t^2 \\langle L(u^n), L(u^n) \\rangle \\right) - \\frac{1}{2} \\langle u^n, u^n \\rangle\n$$\n$$\n\\Delta E = \\Delta t \\langle u^n, L(u^n) \\rangle + \\frac{1}{2} \\Delta t^2 \\|L(u^n)\\|_2^2。\n$$\n这个代数恒等式将能量变化分为两个部分。\n第一项 $R := \\Delta t \\langle u^n, L(u^n) \\rangle$，在精确算术中由于 $L$ 的斜对称性应精确为零。然而，当使用浮点算术计算时，抵消是不完美的，会留下一个小的残差。因此，该项捕捉了在计算 $L(u^n)$ 及后续内积过程中的舍入误差效应。\n第二项 $T := \\frac{1}{2} \\Delta t^2 \\|L(u^n)\\|_2^2$ 是能量变化相对于 $\\Delta t$ 的泰勒展开中的主导项。它代表了前向欧拉法固有的能量增长，是该方法截断误差的一种表现。\n\n该问题要求计算这些量及其关系。为了精确地解析对 $R$ 有贡献的微小舍入误差，使用高精度求和方法至关重要。为此，指定了 Kahan 求和算法。对于一个浮点数数组 $x_i$，该算法按如下方式计算总和 $S = \\sum_i x_i$：\n初始化总和 $s=0.0$ 和补偿项 $c=0.0$。\n对于每个元素 $x_i$：\n\\begin{enumerate}\n    \\item $y = x_i - c$\n    \\item $t = s + y$\n    \\item $c = (t - s) - y$\n    \\item $s = t$\n\\end{enumerate}\n该算法将用于计算 $R$、$T$ 以及直接计算 $\\Delta E$ 所涉及的所有内积和范数的平方。\n\n每个测试用例的总体流程如下：\n1.  建立具有 $N$ 个点的计算网格，并计算参数 $\\Delta x$ 和 $\\Delta t$。\n2.  使用公式 $u^0_i = \\sin(2\\pi k x_i)$ 构造初始状态向量 $u^0$。\n3.  使用带周期性边界条件的中心差分算子计算向量 $L(u^0)$。\n4.  对内积使用补偿求和，计算舍入贡献 $R = \\Delta t \\langle u^0, L(u^0) \\rangle$。\n5.  对范数的平方使用补偿求和，计算截断贡献 $T = \\frac{1}{2} \\Delta t^2 \\|L(u^0)\\|_2^2$。\n6.  计算下一个状态 $u^1 = u^0 + \\Delta t L(u^0)$。\n7.  对两个范数的平方都使用补偿求和，计算实际的能量变化 $\\Delta E = \\frac{1}{2}\\|u^1\\|_2^2 - \\frac{1}{2}\\|u^0\\|_2^2$。\n8.  计算预测值 $\\widehat{\\Delta E} = R + T$。\n9.  计算最终指标：比率 $r = |R|/T$（如果 $T=0$ 则定义为 $0$）和相对一致性误差 $e = |\\Delta E - \\widehat{\\Delta E}| / \\max\\{|\\Delta E|, \\varepsilon\\}$。误差 $e$ 量化了两种代数上等价的能量变化计算方法之间的差异，这种差异纯粹由浮点运算的不同顺序引起。\n\n以下 Python 代码实现了此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes test cases and prints the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path)\n        (1024, 1.0, 0.1, 8),\n        # Case 2 (small time step, rounding-dominated)\n        (1024, 1.0, 1e-6, 8),\n        # Case 3 (high wavenumber, near-Nyquist content)\n        (1024, 1.0, 0.9, 256),\n        # Case 4 (coarse grid boundary case)\n        (16, 1.0, 0.1, 3),\n        # Case 5 (zero mode edge case)\n        (64, 1.0, 0.1, 0),\n    ]\n\n    results = []\n    for params in test_cases:\n        N, a, CFL, k = params\n        r, e = calculate_errors(N, a, CFL, k)\n        results.extend([r, e])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef kahan_sum(a):\n    \"\"\"\n    Computes the sum of an array of floats using the Kahan summation algorithm.\n    All variables are explicitly cast to np.float64 to ensure consistent arithmetic.\n    \"\"\"\n    s = np.float64(0.0)\n    c = np.float64(0.0)\n    for x_val in a:\n        x = np.float64(x_val)\n        y = x - c\n        t = s + y\n        c = (t - s) - y\n        s = t\n    return s\n\ndef calculate_errors(N, a, CFL, k):\n    \"\"\"\n    Calculates the error metrics r and e for a given set of parameters.\n    \"\"\"\n    # 1. Setup parameters and initial condition\n    # Ensure all calculations are done with np.float64\n    N_f = np.float64(N)\n    a_f = np.float64(a)\n    CFL_f = np.float64(CFL)\n    k_f = np.float64(k)\n    \n    dx = np.float64(1.0) / N_f\n    dt = CFL_f * dx / np.abs(a_f)\n    \n    x = np.arange(N_f) * dx\n    u0 = np.sin(np.float64(2.0) * np.pi * k_f * x)\n\n    # 2. Define and apply the spatial operator L\n    def apply_L(u_vec, a_val, dx_val):\n        u_plus_1 = np.roll(u_vec, -1)\n        u_minus_1 = np.roll(u_vec, 1)\n        Du = (u_plus_1 - u_minus_1) / (np.float64(2.0) * dx_val)\n        return -a_val * Du\n\n    Lu0 = apply_L(u0, a_f, dx)\n\n    # 3. Compute R, T, and Delta_E using compensated summation for all sums\n    \n    # R: Rounding-induced contribution\n    inner_prod_u0_Lu0 = kahan_sum(u0 * Lu0)\n    R = dt * inner_prod_u0_Lu0\n\n    # T: Truncation contribution\n    norm_sq_Lu0 = kahan_sum(Lu0 * Lu0)\n    T = np.float64(0.5) * dt**2 * norm_sq_Lu0\n    \n    # Delta_E: Actual one-step energy change\n    u1 = u0 + dt * Lu0\n    \n    norm_sq_u1 = kahan_sum(u1 * u1)\n    E_u1 = np.float64(0.5) * norm_sq_u1\n\n    norm_sq_u0 = kahan_sum(u0 * u0)\n    E_u0 = np.float64(0.5) * norm_sq_u0\n\n    Delta_E = E_u1 - E_u0\n\n    # 4. Compute final metrics r and e\n    \n    # Predictor for energy change\n    Delta_E_hat = R + T\n\n    # r: Ratio of rounding to truncation effects\n    if T == 0.0:\n        r = 0.0\n    else:\n        r = np.abs(R) / T\n        \n    # e: Relative consistency error\n    epsilon = np.float64(1e-300)\n    numerator_e = np.abs(Delta_E - Delta_E_hat)\n    denominator_e = np.maximum(np.abs(Delta_E), epsilon)\n    e = numerator_e / denominator_e\n    \n    return r, e\n\nsolve()\n```"
        },
        {
            "introduction": "在处理移动边界或自适应网格问题时，任意拉格朗日-欧拉（ALE）方法是一种强大的工具，但它也引入了新的数值挑战，即几何守恒律（GCL）。本练习将引导您探索GCL的重要性，并量化因网格速度离散化方案不一致或几何量舍入误差而导致的GCL违背。通过这个实践，您将理解在复杂计算模型中，保持几何运动与守恒律求解之间离散一致性的重要性 。",
            "id": "3445191",
            "problem": "考虑一个长度为 $L=1$ 的一维周期性域，该域在时间层 $t^n$ 被离散为 $N$ 个均匀的有限体积单元，其节点为 $\\{x_i^n\\}_{i=0}^{N}$，其中 $x_0^n=0$ 且 $x_N^n=1$。设网格根据任意拉格朗日-欧拉 (Arbitrary Lagrangian-Eulerian, ALE) 网格速度场 $w(x,t)$ 移动，并且节点位置的更新由显式前向欧拉方法 $x_i^{n+1}=x_i^n+\\Delta t\\,w(x_i^n,t^n)$ 定义，时间步长为 $\\Delta t$。几何守恒律 (Geometric Conservation Law, GCL) 的连续形式指出，一个控制体体积的变化率等于网格速度通过其边界的通量。在一维情况下，离散单元长度为 $\\Delta x_i^n=x_{i+1}^n-x_i^n$。离散GCL要求恒等式\n$$\n\\Delta x_i^{n+1}-\\Delta x_i^{n}=\\Delta t\\left(w_{i+1}^n-w_i^n\\right)\n$$\n对每个单元 $i$ 都精确成立，其中 $w_i^n$ 是在时间层 $n$ 节点 $i$ 处的网格速度。对该恒等式的偏离反映了由数值误差引起的对离散GCL的违背。这些误差可能源于截断（时间离散）、网格速度的离散（从单元中心值近似面上的值）以及几何量和速度舍入到有限精度。\n\n在本问题中，您将设计一个数值实验，以量化在以下情况中对离散GCL的违背程度：\n- 面上的网格速度或在节点处精确求值，或从单元中心值离散得到。\n- 在计算 $\\Delta x_i^n$ 和 $\\Delta x_i^{n+1}$ 之前，几何度量（用于计算单元长度的节点位置）可选择性地舍入到指定的小数位数。\n- 在使用之前，用于离散GCL残差的网格速度可选择性地舍入到指定的小数位数。\n\n使用光滑的周期性网格速度\n$$\nw(x,t)=a\\sin\\!\\left(2\\pi x\\right)\\cos\\!\\left(2\\pi t\\right),\n$$\n其中 $a$ 是一个无量纲振幅，所有角度均以弧度为单位。在 $t^0=0$ 时，用均匀节点 $x_i^0=i/N$（$i=0,1,\\dots,N$）初始化网格。在每个时间步，通过 $x_i^{n+1}=x_i^n+\\Delta t\\,w(x_i^n,t^n)$ 更新节点，然后为每个单元评估离散GCL残差\n$$\nR_i^n=\\left(\\Delta x_i^{n+1}-\\Delta x_i^{n}\\right)-\\Delta t\\left(\\widehat{w}_{i+1}^n-\\widehat{w}_{i}^n\\right),\n$$\n其中 $\\widehat{w}_i^n$ 表示在节点 $i$ 处专门用于残差评估的离散化（且可能已舍入）的网格速度。通过计算所有单元和所有时间步上的最大绝对残差来报告一个标量度量：\n$$\n\\mathcal{E}=\\max_{0\\le n  N_{\\text{steps}}}\\max_{0\\le i  N}\\left|R_i^n\\right|.\n$$\n\n定义面上网格速度离散的两种选项：\n- 选项A（节点）：$\\widehat{w}_i^n=w(x_i^n,t^n)$。\n- 选项B（中心平均）：计算单元中心速度 $w_{c,i}^n=w\\!\\left(\\tfrac{x_i^n+x_{i+1}^n}{2},t^n\\right)$（$i=0,1,\\dots,N-1$），并设置 $\\widehat{w}_i^n=\\tfrac{1}{2}\\left(w_{c,i-1}^n+w_{c,i}^n\\right)$，采用周期性索引，其中 $w_{c,-1}^n$ 被解释为 $w_{c,N-1}^n$。\n\n当启用舍入时，其应用方式如下：\n- 几何舍入：在计算 $\\Delta x_i^{n}$ 和 $\\Delta x_i^{n+1}$ 之前，将所有节点位置 $\\{x_i^n\\}$ 和 $\\{x_i^{n+1}\\}$ 舍入到指定的小数位数。\n- 速度舍入：在根据选项A或选项B计算 $\\widehat{w}_i^n$ 后，将这些值舍入到指定的小数位数。\n\n实现一个程序，该程序执行网格更新并为以下测试套件计算 $\\mathcal{E}$。每个测试用例是一个元组，指定了 $(N,\\Delta t,N_{\\text{steps}},a,d_g,d_v,\\text{disc})$，其中 $d_g$ 是几何舍入的小数位数（当未指定 $d_g$ 时不进行舍入），$d_v$ 是速度舍入的小数位数（当未指定 $d_v$ 时不进行舍入），$\\text{disc}$ 对于选项A是 \"node\"，对于选项B是 \"center\\_avg\"。\n\n测试套件：\n- 案例1（理想路径，一致的离散化，无舍入）：$(N=\\;128,\\;\\Delta t=\\;1\\times 10^{-3},\\;N_{\\text{steps}}=\\;100,\\;a=\\;0.1,\\;d_g=\\;\\text{None},\\;d_v=\\;\\text{None},\\;\\text{disc}=\\;\\text{\"node\"})$。\n- 案例2（中心平均引起的离散误差）：$(N=\\;64,\\;\\Delta t=\\;1\\times 10^{-3},\\;N_{\\text{steps}}=\\;200,\\;a=\\;0.5,\\;d_g=\\;\\text{None},\\;d_v=\\;\\text{None},\\;\\text{disc}=\\;\\text{\"center\\_avg\"})$。\n- 案例3（极小步长下几何度量的舍入）：$(N=\\;64,\\;\\Delta t=\\;1\\times 10^{-5},\\;N_{\\text{steps}}=\\;1000,\\;a=\\;0.5,\\;d_g=\\;5,\\;d_v=\\;\\text{None},\\;\\text{disc}=\\;\\text{\"node\"})$。\n- 案例4（零运动边缘情况）：$(N=\\;32,\\;\\Delta t=\\;1\\times 10^{-2},\\;N_{\\text{steps}}=\\;10,\\;a=\\;0,\\;d_g=\\;2,\\;d_v=\\;2,\\;\\text{disc}=\\;\\text{\"center\\_avg\"})$。\n- 案例5（一致节点离散化下的速度舍入）：$(N=\\;128,\\;\\Delta t=\\;5\\times 10^{-4},\\;N_{\\text{steps}}=\\;200,\\;a=\\;1,\\;d_g=\\;\\text{None},\\;d_v=\\;3,\\;\\text{disc}=\\;\\text{\"node\"})$。\n\n您的程序应生成单行输出，其中包含五个 $\\mathcal{E}$ 的值，每个测试用例一个，形式为方括号内以逗号分隔的列表，并按上述顺序排列（例如，$[\\mathcal{E}_1,\\mathcal{E}_2,\\mathcal{E}_3,\\mathcal{E}_4,\\mathcal{E}_5]$）。所有量均为无量纲。三角函数中的角度必须以弧度解释。",
            "solution": "该问题要求设计一个数值实验，以量化任意拉格朗日-欧拉 (ALE) 框架中离散几何守恒律 (GCL) 的违背情况。这种违背源于不同的数值误差来源：离散化选择和有限精度舍入。\n\n连续GCL指出，控制体度量的时间变化率必须等于网格速度通过该体积边界的通量。对于长度为 $\\Delta x_i(t) = x_{i+1}(t) - x_i(t)$ 的一维单元 $i$，此定律为 $\\frac{d}{dt}(\\Delta x_i) = w(x_{i+1}, t) - w(x_i, t)$，其中 $w(x,t)$ 是网格速度。\n\n问题定义了一个特定的数值方案来演化网格节点 $\\{x_i^n\\}$ 从时间 $t^n$ 到 $t^{n+1}$。节点位置使用显式前向欧拉方案更新，时间步长为 $\\Delta t$：\n$$\nx_i^{n+1} = x_i^n + \\Delta t \\, w(x_i^n, t^n)\n$$\n其中 $w_i^n \\equiv w(x_i^n, t^n)$ 是在时间 $n$ 节点 $i$ 处的精确网格速度。离散GCL是一个守恒格式必须满足的恒等式。对于给定的前向欧拉更新，相应的离散GCL是：\n$$\n\\Delta x_i^{n+1} - \\Delta x_i^{n} = \\Delta t (w_{i+1}^n - w_i^n)\n$$\n这可以通过对节点 $i+1$ 和 $i$ 的更新规则作差直接推导出来：\n$$\nx_{i+1}^{n+1} - x_i^{n+1} = (x_{i+1}^n + \\Delta t \\, w_{i+1}^n) - (x_i^n + \\Delta t \\, w_i^n)\n$$\n$$\n(x_{i+1}^{n+1} - x_i^{n+1}) - (x_{i+1}^n - x_i^n) = \\Delta t(w_{i+1}^n - w_i^n)\n$$\n$$\n\\Delta x_i^{n+1} - \\Delta x_i^n = \\Delta t(w_{i+1}^n - w_i^n)\n$$\n如果各量以无限精度计算，并且用于检查GCL的网格速度与用于移动网格的速度相同，则该恒等式精确成立。\n\n问题定义了GCL残差 $R_i^n$ 来度量与此恒等式的偏差：\n$$\nR_i^n = (\\Delta x_i^{n+1} - \\Delta x_i^n) - \\Delta t (\\widehat{w}_{i+1}^n - \\widehat{w}_i^n)\n$$\n此处，$\\widehat{w}_i^n$ 表示与网格更新中使用的真实节点速度 $w_i^n$ 相比，节点处可能不同（经过离散或舍入）的速度。单元长度 $\\Delta x_i$ 也可能由舍入后的节点位置计算得出。总误差度量是所有单元和所有时间步上的最大绝对残差，即 $\\mathcal{E} = \\max_{0 \\le n  N_{\\text{steps}}} \\max_{0 \\le i  N} |R_i^n|$。\n\n对于每个测试用例，数值实验将按照以下步骤实现：\n1.  在域 $[0, 1]$ 上均匀初始化网格节点：$x_i^0 = i/N$ 对于 $i=0, \\dots, N$。\n2.  从 $n=0$ 到 $N_{\\text{steps}}-1$ 迭代 $N_{\\text{steps}}$ 个时间步。在每一步 $n$：\n    a. 令 $t^n = n \\Delta t$。当前节点位置为 $\\{x_i^n\\}$。\n    b. 计算“旧”单元长度 $\\{\\Delta x_i^n\\}_{i=0}^{N-1}$。如果指定了几何舍入（即 $d_g$ 是一个数字），则在计算长度 $\\Delta x_i^n = \\text{round}(x_{i+1}^n, d_g) - \\text{round}(x_i^n, d_g)$ 之前，首先对节点位置 $\\{x_i^n\\}$ 进行舍入，保留 $d_g$ 位小数。\n    c. 使用精确的节点速度 $w_i^n = w(x_i^n, t^n)$ 在前向欧拉方案中将节点位置更新到 $t^{n+1}$：$x_i^{n+1} = x_i^n + \\Delta t \\, w_i^n$。注意，网格动力学始终使用未舍入的位置和精确的节点速度函数。\n    d. 计算“新”单元长度 $\\{\\Delta x_i^{n+1}\\}_{i=0}^{N-1}$。与步骤(b)类似，如果指定了几何舍入，则首先对新位置 $\\{x_i^{n+1}\\}$ 进行舍入，保留 $d_g$ 位小数。\n    e. 根据指定的离散化选项 (`disc`)，为GCL残差计算离散化的网格速度 $\\{\\widehat{w}_i^n\\}_{i=0}^N$：\n        - **选项A ('node')**：速度在节点处求值，与网格更新规则一致：$\\widehat{w}_i^n = w(x_i^n, t^n)$。\n        - **选项B ('center\\_avg')**：首先计算单元中心速度，$w_{c,i}^n = w(\\frac{x_i^n+x_{i+1}^n}{2}, t^n)$。然后通过对相邻单元中心值求平均来重构节点速度：$\\widehat{w}_i^n = \\frac{1}{2}(w_{c,i-1}^n + w_{c,i}^n)$。对索引强制执行周期性，因此 $w_{c,-1}^n$ 被视为 $w_{c,N-1}^n$。\n    f. 如果指定了速度舍入（即 $d_v$ 是一个数字），则计算出的速度 $\\{\\widehat{w}_i^n\\}$ 将被舍入到 $d_v$ 位小数。\n    g. 为所有单元 $i=0, \\dots, N-1$ 计算GCL残差：$R_i^n = (\\Delta x_i^{n+1} - \\Delta x_i^n) - \\Delta t (\\widehat{w}_{i+1}^n - \\widehat{w}_i^n)$。\n    h. 使用当前时间步中找到的最大绝对残差更新总最大误差 $\\mathcal{E}$。\n3.  循环结束后，报告 $\\mathcal{E}$ 的最终值。\n\n此过程允许分离和量化不同的误差源：\n- **案例1 ('node', 无舍入)**：在此情况下，$\\widehat{w}_i^n$ 与网格更新中使用的速度 $w_i^n$ 相同，且不应用舍入。从解析上看，残差 $R_i^n$ 必须为零。任何非零结果将完全由机器浮点精度误差引起。\n- **案例2 ('center\\_avg', 无舍入)**：此案例引入了离散误差。GCL残差使用从单元中心平均得到的速度 $\\widehat{w}_i^n$ 进行评估，这些速度与用于移动网格的速度 $w_i^n$ 不相同。残差 $R_i^n$ 将不为零，并将量化中心平均方案的不一致性。\n- **案例3 ('node', 几何舍入)**：速度离散是一致的，但几何量 $\\Delta x_i^n$ 和 $\\Delta x_i^{n+1}$ 是根据舍入后的节点位置计算的。这将引入一个与舍入精度 $10^{-d_g}$ 同量级的误差。选择一个非常小的 $\\Delta t$ 会凸显此误差，因为每步节点位置的实际变化（$\\sim \\Delta t$）可能小于舍入阈值，可能导致计算出的几何变化为零。\n- **案例4（零速度）**：当 $a=0$ 时，速度场为 $w(x,t)=0$。网格是静止的，$x_i^{n+1}=x_i^n$。残差中的所有项 $(\\Delta x^{n+1} - \\Delta x^n)$ 和 $\\Delta t(\\widehat{w}_{i+1}^n - \\widehat{w}_i^n)$，即使对零值量应用舍入，也应评估为零。预期结果为 $\\mathcal{E}=0$。\n- **案例5 ('node', 速度舍入)**：几何计算是精确的，速度离散是一致的。然而，残差中使用的速度 $\\widehat{w}_i^n$ 被舍入了。残差项变为 $R_i^n = \\Delta t [(w_{i+1}^n - w_i^n) - (\\text{round}(w_{i+1}^n,d_v) - \\text{round}(w_i^n,d_v))]$。这直接度量了速度场的有限精度表示所产生的影响。\n\n对于问题陈述中指定的每个测试用例，实现将遵循此逻辑。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    test_cases = [\n        (128, 1e-3, 100, 0.1, None, None, \"node\"),\n        (64, 1e-3, 200, 0.5, None, None, \"center_avg\"),\n        (64, 1e-5, 1000, 0.5, 5, None, \"node\"),\n        (32, 1e-2, 10, 0.0, 2, 2, \"center_avg\"),\n        (128, 5e-4, 200, 1.0, None, 3, \"node\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        error_metric = run_gcl_experiment(*case)\n        results.append(error_metric)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_gcl_experiment(N, dt, N_steps, a, d_g, d_v, disc):\n    \"\"\"\n    Performs a single numerical experiment to compute the GCL violation metric.\n\n    Args:\n        N (int): Number of finite volume cells.\n        dt (float): Time step size.\n        N_steps (int): Number of time steps.\n        a (float): Amplitude of the mesh velocity.\n        d_g (int or None): Number of decimal places for geometric rounding.\n        d_v (int or None): Number of decimal places for velocity rounding.\n        disc (str): Velocity discretization option (\"node\" or \"center_avg\").\n\n    Returns:\n        float: The computed error metric E.\n    \"\"\"\n    \n    # Define the mesh velocity function w(x, t)\n    w_func = lambda x, t: a * np.sin(2.0 * np.pi * x) * np.cos(2.0 * np.pi * t)\n\n    # Helper function for optional rounding to a specified number of decimals\n    def optional_round(arr, digits):\n        if digits is None:\n            return arr\n        return np.round(arr, decimals=digits)\n\n    # Initialize nodal positions on the domain [0, 1]\n    # There are N+1 nodes for N cells.\n    x = np.linspace(0.0, 1.0, N + 1, dtype=np.float64)\n    \n    max_overall_residual = 0.0\n\n    for n in range(N_steps):\n        t_n = n * dt\n        x_n = x\n\n        # 1. Compute old cell lengths, applying geometric rounding if specified.\n        x_n_rounded = optional_round(x_n, d_g)\n        delta_x_n = x_n_rounded[1:] - x_n_rounded[:-1]\n\n        # 2. Update mesh positions using forward Euler with unrounded positions\n        #    and exact nodal velocities. This defines the mesh dynamics.\n        w_update_nodal = w_func(x_n, t_n)\n        x_np1 = x_n + dt * w_update_nodal\n\n        # 3. Compute new cell lengths, applying geometric rounding if specified.\n        x_np1_rounded = optional_round(x_np1, d_g)\n        delta_x_np1 = x_np1_rounded[1:] - x_np1_rounded[:-1]\n\n        # 4. Compute discretized velocities (w_hat) for the GCL residual term.\n        if disc == \"node\":\n            # Option A: Velocities evaluated directly at nodes.\n            w_hat = w_func(x_n, t_n)\n        elif disc == \"center_avg\":\n            # Option B: Velocities averaged from cell-centered values.\n            x_c = 0.5 * (x_n[:-1] + x_n[1:])\n            w_c = w_func(x_c, t_n)\n            \n            w_hat = np.zeros(N + 1, dtype=np.float64)\n            # For internal nodes i = 1, ..., N-1\n            w_hat[1:N] = 0.5 * (w_c[:-1] + w_c[1:])\n            # For boundary nodes, apply periodic boundary conditions.\n            # w_hat[0] uses w_c[-1] and w_c[0]\n            w_hat[0] = 0.5 * (w_c[N-1] + w_c[0])\n            # w_hat[N] should be equal to w_hat[0] for a periodic field\n            w_hat[N] = w_hat[0]\n        else:\n            raise ValueError(f\"Invalid discretization option: {disc}\")\n\n        # 5. Apply velocity rounding to w_hat if specified.\n        w_hat_rounded = optional_round(w_hat, d_v)\n        \n        # 6. Compute the GCL residual for each cell.\n        delta_w_hat = w_hat_rounded[1:] - w_hat_rounded[:-1]\n        residual_n = (delta_x_np1 - delta_x_n) - dt * delta_w_hat\n        \n        # 7. Update the maximum residual seen so far.\n        max_step_residual = np.max(np.abs(residual_n))\n        if max_step_residual > max_overall_residual:\n            max_overall_residual = max_step_residual\n            \n        # 8. Set the new positions for the next time step.\n        x = x_np1\n        \n    return max_overall_residual\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}