{
    "hands_on_practices": [
        {
            "introduction": "叠加原理是线性系统的基石。本练习将这一抽象原理置于一个具体的数值环境中，即离散化的泊松方程 。通过证明离散算子的线性并编写代码进行数值验证，你将体验从理论到实践的过程，加深对线性如何体现在计算中的理解。",
            "id": "3434960",
            "problem": "设一个线性偏微分方程（PDE）在单位正方形域 $(0,1)\\times(0,1)$ 上进行离散化，边界上采用齐次狄利克雷边界条件 $u=0$。考虑泊松方程 $-\\Delta u = f$ 的离散模型，其中离散未知数是内部网格点上的值，离散右侧项是强迫值组成的向量。内部网格在每个空间方向上使用 $n$ 个点，间距为 $h = \\frac{1}{n+1}$，内部坐标为 $x_i = i h, y_j = j h$，其中 $i,j \\in \\{1,2,\\dots,n\\}$。使用拉普拉斯算子的标准五点差分格式，得到的离散线性系统为\n$$\nA u = f,\n$$\n其中 $A \\in \\mathbb{R}^{n^2 \\times n^2}$ 是对称正定矩阵\n$$\nA = \\frac{1}{h^2}\\left(I_n \\otimes K_n + K_n \\otimes I_n\\right),\n$$\n$I_n$ 是 $n\\times n$ 单位矩阵，$\\otimes$ 是克罗内克积，$K_n \\in \\mathbb{R}^{n \\times n}$ 是对角线元素为 $2$、非对角线元素为 $-1$ 的三对角矩阵。离散向量 $f \\in \\mathbb{R}^{n^2}$ 以任意一致的字典序汇集了内部网格上的强迫值 $f_{i,j}$。\n\n仅使用矩阵是线性算子的基本定义以及对称正定矩阵的可逆性准则，推导对于任意分解 $f = f^{(1)} + f^{(2)}$，方程 $A u^{(1)} = f^{(1)}$、$A u^{(2)} = f^{(2)}$ 和 $A u = f$ 的唯一解满足叠加恒等式\n$$\nu = u^{(1)} + u^{(2)}.\n$$\n三角函数中使用的角度必须是弧度。\n\n然后，对以下测试套件数值验证此恒等式。对于每个测试用例，按规定构造矩阵 $A$ 和向量 $f^{(1)}$、$f^{(2)}$，通过求解相应的线性系统计算 $u$、$u^{(1)}$ 和 $u^{(2)}$，并测试是否满足 $\\| u - (u^{(1)} + u^{(2)}) \\|_2 \\le \\varepsilon$，其中容差 $\\varepsilon = 10^{-12}$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots]$），每个条目是一个布尔值，表示测试是否通过。\n\n测试套件：\n- 案例 1：$n=3$。定义 $f^{(1)}_{i,j} = \\sin(\\pi x_i) \\sin(\\pi y_j)$ 和 $f^{(2)}_{i,j} = \\sin(2\\pi x_i) \\sin(\\pi y_j)$，角度单位为弧度。\n- 案例 2：$n=4$。对所有内部索引 $i,j$，定义 $f^{(1)}_{i,j} = 1$ 和 $f^{(2)}_{i,j} = -1$。\n- 案例 3：$n=5$。定义 $f^{(1)}_{i,j}$ 在离散中心点 $(i^*,j^*)$ 处为 $1$，其中 $i^* = \\lceil \\frac{n}{2} \\rceil$ 且 $j^* = \\lceil \\frac{n}{2} \\rceil$，在其他地方为 $0$；定义 $f^{(2)}_{i,j}$ 在所有地方均为 $0$。\n- 案例 4：$n=4$。定义 $f^{(1)}$ 和 $f^{(2)}$ 为网格上 $[0,1)$ 区间内均匀分布随机数的独立实现，为保证可复现性，分别使用固定种子 $42$ 和 $43$。\n- 案例 5：$n=3$。对所有内部索引，定义 $f^{(1)}_{i,j} = 0$，并定义 $f^{(2)}_{i,j} = \\sin(\\pi x_i)\\sin(\\pi y_j)$，角度单位为弧度。\n\n所有三角函数必须使用弧度作为角度单位。最终输出必须是形如 $[b_1,b_2,b_3,b_4,b_5]$ 的单行文本，其中 $b_k$ 对相应案例是 $\\text{True}$ 或 $\\text{False}$。",
            "solution": "问题陈述是有效的。它在科学上基于数值线性代数和偏微分方程离散化的原理。该问题是适定的、客观的，并包含理论推导和数值验证所需的所有必要信息。\n\n### 第 1 部分：叠加原理的推导\n\n目标是证明对于线性系统 $A u = f$，如果强迫项分解为 $f = f^{(1)} + f^{(2)}$，那么解 $u$ 就是各个问题解的和，即 $u = u^{(1)} + u^{(2)}$，其中 $A u^{(1)} = f^{(1)}$ 且 $A u^{(2)} = f^{(2)}$。推导基于问题中提到的两个基本性质：矩阵算子 $A$ 的线性性质以及对称正定（SPD）矩阵的可逆性。\n\n设 $A \\in \\mathbb{R}^{n^2 \\times n^2}$ 是表示离散线性算子的矩阵。离散解向量 $u$ 和离散强迫向量 $f$ 之间的关系由以下线性系统给出：\n$$\nA u = f\n$$\n我们已知强迫向量 $f$ 被分解为两个分量 $f^{(1)}$ 和 $f^{(2)}$，使得：\n$$\nf = f^{(1)} + f^{(2)}\n$$\n设 $u^{(1)}$ 和 $u^{(2)}$ 分别是强迫项为 $f^{(1)}$ 和 $f^{(2)}$ 的线性系统的解：\n$$\nA u^{(1)} = f^{(1)}\n$$\n$$\nA u^{(2)} = f^{(2)}\n$$\n问题要求我们利用矩阵代表一个线性算子这一事实。算子 $A$ 的线性性质指出，对于其定义域中的任意向量 $v_1, v_2$ 和任意标量 $c_1, c_2$，以下关系成立：\n$$\nA(c_1 v_1 + c_2 v_2) = c_1 A v_1 + c_2 A v_2\n$$\n我们可以将此性质应用于向量 $u^{(1)}$ 和 $u^{(2)}$ 的和，通过设置 $c_1=1$ 和 $c_2=1$：\n$$\nA (u^{(1)} + u^{(2)}) = A u^{(1)} + A u^{(2)}\n$$\n现在，我们从它们的定义方程中代入 $A u^{(1)}$ 和 $A u^{(2)}$ 的表达式：\n$$\nA (u^{(1)} + u^{(2)}) = f^{(1)} + f^{(2)}\n$$\n因为已知 $f = f^{(1)} + f^{(2)}$，我们可以将其代入方程的右侧：\n$$\nA (u^{(1)} + u^{(2)}) = f\n$$\n该方程表明向量 $(u^{(1)} + u^{(2)})$ 是原线性系统 $A u = f$ 的一个解。\n\n第二个关键信息是矩阵 $A$ 是对称正定（SPD）的。线性代数中的一个基本定理指出，SPD 矩阵总是可逆的。$A$ 的可逆性意味着对于任何右侧向量 $f$，线性系统 $A x = f$ 都有一个由 $x = A^{-1}f$ 给出的唯一解。\n\n我们已经确定了两个满足强迫项为 $f$ 的方程的向量：\n1. 向量 $u$，根据其定义：$A u = f$。\n2. 向量 $(u^{(1)} + u^{(2)})$，如上所推导：$A(u^{(1)} + u^{(2)}) = f$。\n\n由于该系统的解是唯一的，这两个向量必须相同。因此，我们得出结论：\n$$\nu = u^{(1)} + u^{(2)}\n$$\n这就完成了对该离散线性系统叠加原理的推导。\n\n### 第 2 部分：数值验证\n\n为了数值验证这一原理，我们将实现所述的测试用例。对于每个用例，我们将：\n1.  对给定的维度 $n$ 构造矩阵 $A = \\frac{1}{h^2}(I_n \\otimes K_n + K_n \\otimes I_n)$，其中 $h = \\frac{1}{n+1}$，$I_n$ 是 $n \\times n$ 单位矩阵，$K_n$ 是主对角线上元素为 $2$、超对角线和次对角线上元素为 $-1$ 的 $n \\times n$ 三对角矩阵。\n2.  根据每个测试用例的规范，构造大小为 $n^2 \\times 1$ 的右侧向量 $f^{(1)}$ 和 $f^{(2)}$。这包括创建一个坐标网格 $(x_i, y_j)$ 并计算给定函数的值，然后使用一致的字典序将得到的 $n \\times n$ 矩阵展平为向量。\n3.  计算总强迫向量 $f = f^{(1)} + f^{(2)}$。\n4.  使用标准线性求解器求解三个线性系统 $A u^{(1)} = f^{(1)}$、$A u^{(2)} = f^{(2)}$ 和 $A u = f$，得到解向量 $u^{(1)}$、$u^{(2)}$ 和 $u$。\n5.  计算差向量的 L2-范数：$\\| u - (u^{(1)} + u^{(2)}) \\|_2$。\n6.  将此范数与指定的容差 $\\varepsilon = 10^{-12}$ 进行比较。如果范数小于或等于容差，则测试通过。\n所有测试用例的结果将被收集并以布尔值列表的形式呈现。由于浮点运算的性质，差值不会精确为零，但会在机器精度的数量级上，对于这些良态系统来说，这远小于给定的容差。因此，我们预期所有测试都会通过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and numerically verifies the principle of superposition for the\n    discrete Poisson equation.\n    \"\"\"\n    \n    test_suite = [\n        {'case_id': 1, 'n': 3},\n        {'case_id': 2, 'n': 4},\n        {'case_id': 3, 'n': 5},\n        {'case_id': 4, 'n': 4},\n        {'case_id': 5, 'n': 3},\n    ]\n\n    results = []\n    epsilon = 1e-12\n\n    for test in test_suite:\n        n = test['n']\n        case_id = test['case_id']\n        \n        # 1. Construct the matrix A\n        h = 1.0 / (n + 1)\n        \n        # K_n is the tridiagonal matrix [-1, 2, -1]\n        k_n = (2 * np.identity(n) - \n               np.diag(np.ones(n - 1), k=1) - \n               np.diag(np.ones(n - 1), k=-1))\n               \n        # I_n is the n x n identity matrix\n        i_n = np.identity(n)\n        \n        # A is the discrete Laplacian using Kronecker products\n        A = (1 / h**2) * (np.kron(i_n, k_n) + np.kron(k_n, i_n))\n        \n        # 2. Construct the vectors f^(1) and f^(2)\n        \n        # Grid coordinates\n        # i, j in {1, ..., n}\n        coords = np.arange(1, n + 1) * h\n        X, Y = np.meshgrid(coords, coords, indexing='ij')\n\n        f1 = np.zeros(n * n)\n        f2 = np.zeros(n * n)\n\n        if case_id == 1:\n            # Case 1: n=3, trigonometric functions\n            f1_mat = np.sin(np.pi * X) * np.sin(np.pi * Y)\n            f2_mat = np.sin(2 * np.pi * X) * np.sin(np.pi * Y)\n            f1 = f1_mat.flatten()\n            f2 = f2_mat.flatten()\n        elif case_id == 2:\n            # Case 2: n=4, constant functions\n            f1 = np.ones(n * n)\n            f2 = -np.ones(n * n)\n        elif case_id == 3:\n            # Case 3: n=5, delta function\n            i_star = int(np.ceil(n / 2.0))\n            j_star = int(np.ceil(n / 2.0))\n            # Lexicographic index (row-major) for (i*, j*)\n            # where i,j are 1-based indices\n            k = (i_star - 1) * n + (j_star - 1)\n            f1[k] = 1.0\n            # f2 is already a zero vector\n        elif case_id == 4:\n            # Case 4: n=4, random vectors\n            rng1 = np.random.default_rng(42)\n            f1 = rng1.uniform(0, 1, size=n * n)\n            rng2 = np.random.default_rng(43)\n            f2 = rng2.uniform(0, 1, size=n * n)\n        elif case_id == 5:\n            # Case 5: n=3, zero and trigonometric function\n            # f1 is already a zero vector\n            f2_mat = np.sin(np.pi * X) * np.sin(np.pi * Y)\n            f2 = f2_mat.flatten()\n\n        # 3. Calculate the total forcing vector f\n        f = f1 + f2\n        \n        # 4. Solve the three linear systems\n        u1 = np.linalg.solve(A, f1)\n        u2 = np.linalg.solve(A, f2)\n        u = np.linalg.solve(A, f)\n        \n        # 5. Compute the L2-norm of the error\n        error_norm = np.linalg.norm(u - (u1 + u2), 2)\n        \n        # 6. Compare with tolerance and store result\n        results.append(error_norm = epsilon)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理解一个原理的适用范围和理解其本身同样重要。本练习旨在探讨叠加原理在非线性方程中的失效机制 。通过分析像 p-拉普拉斯算子这样的非线性算子，你将认识到为什么将解简单相加的方法不再适用于非线性问题，这对于正确建模和选择数值方法至关重要。",
            "id": "3434966",
            "problem": "考虑一个有界Lipschitz域 $\\Omega \\subset \\mathbb{R}^d$（其中 $d \\in \\{2,3\\}$）和一个函数空间 $V := H_0^1(\\Omega)$。经典的二阶椭圆边值问题可以写成如下弱形式：求 $u \\in V$，使得\n$$\n\\int_{\\Omega} a(x) \\nabla u \\cdot \\nabla v \\, dx = \\int_{\\Omega} f v \\, dx \\quad \\text{对所有 } v \\in V,\n$$\n成立，其中 $a(x)$ 是一致为正且有界的，并且 $f \\in L^2(\\Omega)$。等式左边定义了一个双线性形式 $a(u,v)$，其相关算子 $L: V \\to V'$ 是线性的。在这些条件下，解的叠加原理适用：若 $L u_1 = f_1$ 且 $L u_2 = f_2$，则 $L(u_1 + u_2) = f_1 + f_2$。\n\n现在考虑将该双线性形式替换为一个非线性泛函，例如替换为以下任意一种：\n$$\na_N(u; v) := \\int_{\\Omega} |\\nabla u|^p v \\, dx,\n$$\n对于某个 $p  1$，或者替换为p-Laplace弱形式\n$$\na_p(u; v) := \\int_{\\Omega} |\\nabla u|^{p-2} \\nabla u \\cdot \\nabla v \\, dx,\n$$\n其中 $p  1$。在这两种情况下，映射 $u \\mapsto a(\\cdot;\\cdot)$ 在 $(u,v)$ 上不是双线性的，且相关算子是非线性的。\n\n在Galerkin离散化中，选择一个有限维子空间 $V_h \\subset V$，其基函数为 $\\{\\phi_i\\}_{i=1}^n$，并将 $u$ 近似为 $u_h = \\sum_{i=1}^n c_i \\phi_i$。通过取 $v = \\phi_j$（$j = 1, \\dots, n$）作为测试函数，可以得到离散残差方程组。\n\n关于叠加原理及其在上述非线性弱形式的数值求解中的影响，以下哪个陈述是正确的？\n\nA. 因为离散试探函数 $u_h$ 是一个叠加形式 $u_h = \\sum_{i=1}^n c_i \\phi_i$，所以在非线性情况下，离散残差方程组关于系数 $\\{c_i\\}$ 是线性的，因此解映射 $f \\mapsto u_h$ 是线性的。\n\nB. 在非线性弱形式中（无论是 $a_N(u; v)$ 还是 $a_p(u; v)$），映射 $f \\mapsto u$ 不是线性的，因此如果 $u_1$ 是 $f_1$ 的解，$u_2$ 是 $f_2$ 的解，那么 $u_1 + u_2$ 通常不是 $f_1 + f_2$ 的解。\n\nC. 在 $a_N(u; v) = \\int_{\\Omega} |\\nabla u|^p v \\, dx$ 中测试函数 $v$ 的存在保证了等式左边关于 $u$ 是线性的，因此叠加原理成立。\n\nD. 当 $p = 2$ 时，p-Laplace弱形式 $a_p(u; v)$ 退化为一个关于 $u$ 线性的双线性形式，并且关于 $f$ 的叠加原理成立。\n\nE. 在非线性弱形式的Galerkin离散化中，组装的刚度矩阵与 $u$ 无关，并且可以对多个右端项 $f$ 重复使用而无需重新计算。",
            "solution": "首先对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- 域：一个有界Lipschitz域 $\\Omega \\subset \\mathbb{R}^d$，$d \\in \\{2,3\\}$。\n- 函数空间：$V := H_0^1(\\Omega)$。\n- 线性弱形式：求 $u \\in V$，使得 $\\int_{\\Omega} a(x) \\nabla u \\cdot \\nabla v \\, dx = \\int_{\\Omega} f v \\, dx$ 对所有 $v \\in V$ 成立。\n- 线性形式的条件：$a(x)$ 一致为正且有界，$f \\in L^2(\\Omega)$。\n- 线性形式的算子：$L: V \\to V'$ 是线性的。\n- 线性形式的叠加原理：若 $L u_1 = f_1$ 且 $L u_2 = f_2$，则 $L(u_1 + u_2) = f_1 + f_2$。\n- 非线性泛函1：$a_N(u; v) := \\int_{\\Omega} |\\nabla u|^p v \\, dx$，对于某个 $p  1$。\n- 非线性泛函2（p-Laplace弱形式）：$a_p(u; v) := \\int_{\\Omega} |\\nabla u|^{p-2} \\nabla u \\cdot \\nabla v \\, dx$，$p  1$。\n- 离散化方案：使用有限维子空间 $V_h \\subset V$ 和基函数 $\\{\\phi_i\\}_{i=1}^n$ 的Galerkin方法。\n- 近似解：$u_h = \\sum_{i=1}^n c_i \\phi_i$。\n- 離散方程：通过取 $v = \\phi_j$（$j = 1, \\dots, n$）作为测试函数构成。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据：**该问题牢固地植根于偏微分方程的数学理论及其通过有限元方法的数值解。弱形式、Sobolev空间（$H_0^1(\\Omega)$）、p-Laplacian算子和Galerkin方法等概念是该领域的标准和基础。该问题在科学上是合理的。\n- **适定性：**该问题要求基于所提供的数学定义来评估几个陈述。这是一个定义明确的概念性问题，允许进行严格的逻辑分析。\n- **客观性：**该问题使用精确的数学术语和定义进行阐述。问题设置中没有主观或模糊的陈述。\n- **一致性和完整性：**问题陈述是自洽的。它定义了线性和非线性问题、叠加原理的背景以及离散化框架。没有内部矛盾。\n\n### 步驟3：結論與行動\n问题陈述是有效的。可以继续对选项进行严格分析。\n\n### 问题分析\n问题的核心在于理解线性算子的定义及其推论——叠加原理。一个映射（或算子）$N: V \\to V'$ 是线性的，如果对任意 $u_1, u_2 \\in V$ 和任意标量 $\\alpha, \\beta$，都有 $N(\\alpha u_1 + \\beta u_2) = \\alpha N(u_1) + \\beta N(u_2)$ 成立。方程 $N(u) = f$ 的叠加原理是这种线性性质的直接推论。具体来说，如果 $N(u_1) = f_1$ 且 $N(u_2) = f_2$，那么 $N(u_1 + u_2) = N(u_1) + N(u_2) = f_1 + f_2$。因此，$u_1+u_2$ 是源项 $f_1+f_2$ 的解。如果算子 $N$ 不是线性的，这个性质通常不成立。\n\n与非线性弱形式相关的算子由关系 $\\langle N(u), v \\rangle = a(u; v)$ 定义，其中 $\\langle \\cdot, \\cdot \\rangle$ 表示 $V'$ 和 $V$ 之間的对偶配对。我们必须检验这些算子关于试探函数 $u$ 的线性性。\n\n对于 $a_N(u; v) = \\int_{\\Omega} |\\nabla u|^p v \\, dx$，对应的算子 $N_N$ 由 $\\langle N_N(u), v \\rangle = \\int_{\\Omega} |\\nabla u|^p v \\, dx$ 给出。\n对于 $a_p(u; v) = \\int_{\\Omega} |\\nabla u|^{p-2} \\nabla u \\cdot \\nabla v \\, dx$，对应的算子 $N_p$ 由 $\\langle N_p(u), v \\rangle = \\int_{\\Omega} |\\nabla u|^{p-2} \\nabla u \\cdot \\nabla v \\, dx$ 给出。\n\n对于一般的 $p1$（且 $p \\neq 2$），算子 $N_N$ 和 $N_p$ 关于 $u$ 都是非线性的。例如，对于 $N_p$，$N_p(\\alpha u) = |\\alpha|^{p-2}\\alpha N_p(u) \\neq \\alpha N_p(u)$，除非 $\\alpha = \\pm 1$ 或 $p=2$。更重要的是，由于对 $\\nabla u$ 的非线性依赖，通常有 $N_p(u_1+u_2) \\neq N_p(u_1)+N_p(u_2)$。\n\n### 逐项评估\n\n**A. 因为离散试探函数 $u_h$ 是一个叠加形式 $u_h = \\sum_{i=1}^n c_i \\phi_i$，所以在非线性情况下，离散残差方程组关于系数 $\\{c_i\\}$ 是线性的，因此解映射 $f \\mapsto u_h$ 是线性的。**\n\n这个陈述混淆了函数在基底中的表示（线性组合）与底层微分算子的线性性。展开式 $u_h = \\sum_{i=1}^n c_i \\phi_i$ 对于所有Galerkin方法（无论线性与否）都是标准的。例如，我们来考察p-Laplacian的离散方程。我们需求解系数向量 $\\mathbf{c} = (c_1, \\dots, c_n)^T$，使得对于每个基函数 $\\phi_j$, $j=1, \\dots, n$：\n$$ \\int_{\\Omega} \\left|\\nabla \\left(\\sum_{i=1}^n c_i \\phi_i\\right)\\right|^{p-2} \\nabla \\left(\\sum_{k=1}^n c_k \\phi_k\\right) \\cdot \\nabla \\phi_j \\, dx = \\int_{\\Omega} f \\phi_j \\, dx $$\n等式左边包含一个幂为 $p-2$ 的项，项内是系数的求和。这导致了一个关于系数 $\\{c_i\\}$ 的非线性代数方程组。由于离散系统是非线性的，从右端向量（由 $f$ 导出）到解向量 $\\mathbf{c}$ 的映射也是非线性的。该陈述有根本性错误。\n\n结论：**错误**。\n\n**B. 在非线性弱形式中（无论是 $a_N(u; v)$ 还是 $a_p(u; v)$），映射 $f \\mapsto u$ 不是线性的，因此如果 $u_1$ 是 $f_1$ 的解，$u_2$ 是 $f_2$ 的解，那么 $u_1 + u_2$ 通常不是 $f_1 + f_2$ 的解。**\n\n该陈述正确地指出了非线性性的核心推论。设 $N(u)$ 是对应于任一非线性形式的算子。问题是 $N(u) = f$。设 $S$ 为解映射，$S(f) = u$。如果 $u_1 = S(f_1)$ 且 $u_2 = S(f_2)$，则 $N(u_1)=f_1$ 且 $N(u_2)=f_2$。叠加原理要求 $u_1+u_2$ 是 $f_1+f_2$ 的解，即 $N(u_1+u_2) = f_1+f_2$。然而，由于 $N$ 是一个非线性算子，通常 $N(u_1+u_2) = N(u_1)+N(u_2)$ 并不成立。因此，$N(u_1+u_2) \\neq f_1+f_2$，解映射 $S$ 不是线性的。该陈述是对非线性问题中叠加原理失效的正确描述。\n\n结论：**正确**。\n\n**C. 在 $a_N(u; v) = \\int_{\\Omega} |\\nabla u|^p v \\, dx$ 中测试函数 $v$ 的存在保证了等式左边关于 $u$ 是线性的，因此叠加原理成立。**\n\n该陈述错误地诊断了线性性的来源。虽然对于固定的 $u$，泛函 $a_N(u;v)$ 确实关于*测试函数* $v$ 是线性的（即，$a_N(u; \\alpha v_1 + \\beta v_2) = \\alpha a_N(u; v_1) + \\beta a_N(u; v_2)$），但这个性质是它定义一个有效弱形式所必需的，并不决定整个问题的线性性。算子的线性性以及叠加原理的适用性，取决于对*试探函数* $u$ 的依赖关系。如前所示，项 $|\\nabla u|^p$ 使得当 $p \\neq 1$ 时映射 $u \\mapsto a_N(u;v)$ 是非线性的。该结论基于一个错误的前提。\n\n结论：**错误**。\n\n**D. 当 $p = 2$ 时，p-Laplace弱形式 $a_p(u; v)$ 退化为一个关于 $u$ 线性的双线性形式，并且关于 $f$ 的叠加原理成立。**\n\n我们将 $p=2$ 代入 $a_p(u;v)$ 的表达式中：\n$$ a_2(u; v) = \\int_{\\Omega} |\\nabla u|^{2-2} \\nabla u \\cdot \\nabla v \\, dx = \\int_{\\Omega} |\\nabla u|^0 \\nabla u \\cdot \\nabla v \\, dx $$\n假设 $\\nabla u \\neq 0$（对于 $H_0^1(\\Omega)$ 中的非平凡解，这几乎处处成立），$|\\nabla u|^0 = 1$。该形式变为：\n$$ a_2(u; v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, dx $$\n这是标准泊松方程 $-\\Delta u = f$ 的弱形式。我们必须检查这是否是一个双线性形式。\n1. 关于 $u$ 的线性性：$a_2(\\alpha u_1 + \\beta u_2; v) = \\int_{\\Omega} \\nabla(\\alpha u_1 + \\beta u_2) \\cdot \\nabla v \\, dx = \\int_{\\Omega} (\\alpha \\nabla u_1 + \\beta \\nabla u_2) \\cdot \\nabla v \\, dx = \\alpha a_2(u_1; v) + \\beta a_2(u_2; v)$。它是关于 $u$ 线性的。\n2. 关于 $v$ 的線性性：$a_2(u; \\alpha v_1 + \\beta v_2) = \\int_{\\Omega} \\nabla u \\cdot \\nabla (\\alpha v_1 + \\beta v_2) \\, dx = \\int_{\\Omega} \\nabla u \\cdot (\\alpha \\nabla v_1 + \\beta \\nabla v_2) \\, dx = \\alpha a_2(u; v_1) + \\beta a_2(u; v_2)$。它是关于 $v$ 线性的。\n由于该形式对两个自变量都是线性的，所以它是一个双线性形式。相应的算子 $L(u) = -\\Delta u$ 是一个线性算子。对于线性算子，如问题前提所述，叠加原理成立。该陈述完全正确。\n\n结论：**正确**。\n\n**E. 在非线性弱形式的Galerkin离散化中，组装的刚度矩阵与 $u$ 无关，并且可以对多个右端项 $f$ 重复使用而无需重新计算。**\n\n这描述了*线性*有限元问题的一个关键特性。在线性情况下，离散系统是 $\\mathbf{A}\\mathbf{c}=\\mathbf{b}$，其中刚度矩阵 $\\mathbf{A}$ 的元素 $A_{ji} = \\int a(x) \\nabla\\phi_i \\cdot \\nabla\\phi_j \\,dx$ 只依赖于问题系数和基函数，而不依赖于解 $u_h$（或其系数向量 $\\mathbf{c}$）。然而，对于非线性问题，离散系统是一组非线性方程 $\\mathbf{R}(\\mathbf{c})=\\mathbf{b}$。这通常用迭代方法求解，例如牛顿法。更新步骤是 $\\mathbf{J}(\\mathbf{c}^{(k)}) \\delta\\mathbf{c} = -(\\mathbf{R}(\\mathbf{c}^{(k)}) - \\mathbf{b})$，其中 $\\mathbf{J}(\\mathbf{c}^{(k)})$ 是在当前迭代点 $\\mathbf{c}^{(k)}$ 处计算的雅可比矩阵（或切线刚度矩阵）。$\\mathbf{J}$ 的元素依赖于当前的解估计值 $\\mathbf{c}^{(k)}$。由于系统矩阵依赖于解，它不能只组装一次并重复使用；它必须在迭代过程中重新计算。因此，该陈述是错误的。\n\n结论：**错误**。",
            "answer": "$$\\boxed{BD}$$"
        },
        {
            "introduction": "在某些情况下，即使基础的偏微分方程是线性的，为保证数值稳定性而引入的算法组件也会破坏叠加原理。本练习将通过一个高级的实践案例来揭示这一微妙之处 。你将探索用于求解线性平流方程的间断Galerkin方法，并量化斜率限制器（一种非线性算子）如何导致叠加原理失效，从而深刻理解数值方法设计中的理论与现实。",
            "id": "3434972",
            "problem": "考虑常平流速度 $a0$ 且定义在周期性空间域 $x \\in [0,1]$ 上的线性平流偏微分方程 (PDE) $u_t + a\\,u_x = 0$。使用分片1次（记为 $P^1$）多项式的间断伽辽金法，在包含 $N$ 个单元的均匀网格上，通过每个单元上的局部勒让德基来表示函数 $u(x)$。对于中心为 $x_i$、宽度为 $h=1/N$ 的单元 $i$，其局部坐标 $\\xi \\in [-1,1]$ 由 $x = x_i + \\tfrac{h}{2}\\,\\xi$ 定义，局部表示为 $u_i(\\xi) = a_{0,i}\\,P_0(\\xi) + a_{1,i}\\,P_1(\\xi)$，其中 $P_0(\\xi) = 1$ 且 $P_1(\\xi) = \\xi$。一个光滑函数 $f(x)$ 到此 $P^1$ 空间上的 $L^2$ 投影系数由勒让德多项式的正交关系给出：\n$$\na_{0,i} = \\frac{1}{2}\\int_{-1}^{1} f\\!\\left(x_i + \\frac{h}{2}\\,\\xi\\right)\\,d\\xi,\\qquad\na_{1,i} = \\frac{3}{2}\\int_{-1}^{1} f\\!\\left(x_i + \\frac{h}{2}\\,\\xi\\right)\\,\\xi\\,d\\xi.\n$$\n为了防止伪振荡，对系数 $a_{1,i}$ 应用斜率限制器。定义相邻单元平均值的差分\n$$\n\\Delta_{i-\\frac{1}{2}} = a_{0,i} - a_{0,i-1},\\qquad \\Delta_{i+\\frac{1}{2}} = a_{0,i+1} - a_{0,i},\n$$\n索引是周期性的。令 $T = M h^2$ 为总变差有界 (TVB) 阈值，其中参数 $M0$。经 TVB 修正的 minmod 限制器将 $a_{1,i}$ 替换为\n$$\n\\tilde{a}_{1,i} = \n\\begin{cases}\n\\operatorname{minmod}\\!\\left(a_{1,i},\\,\\Delta_{i-\\frac{1}{2}},\\,\\Delta_{i+\\frac{1}{2}}\\right),  \\text{if } \\left(|\\Delta_{i-\\frac{1}{2}}|T\\right)\\ \\text{and}\\ \\left(|\\Delta_{i+\\frac{1}{2}}|T\\right),\\\\\na_{1,i},  \\text{otherwise,}\n\\end{cases}\n$$\n其中\n$$\n\\operatorname{minmod}(z_1,z_2,z_3) =\n\\begin{cases}\n\\operatorname{sign}(z_1)\\,\\min\\{|z_1|,|z_2|,|z_3|\\},  \\text{if } \\operatorname{sign}(z_1)=\\operatorname{sign}(z_2)=\\operatorname{sign}(z_3),\\\\\n0,  \\text{otherwise.}\n\\end{cases}\n$$\n这定义了非线性映射 $S:f\\mapsto u^{\\text{DG}}$，其中 $u^{\\text{DG}}$ 是由 $\\{a_{0,i},\\tilde{a}_{1,i}\\}_{i=0}^{N-1}$ 决定的经过限制的 $P^1$ 表示。\n\n对于线性算子，叠加原理要求对所有输入都满足 $S(f_1 + f_2) = S(f_1) + S(f_2)$。在本问题中，您将展示并量化仅由斜率限制器（无需对 $u_t + a\\,u_x = 0$ 进行任何时间步进）引入的对叠加原理的违背。您需要：\n\n- 实现投影公式，根据给定的 $f(x)$ 计算 $\\{a_{0,i}, a_{1,i}\\}$。\n- 对每个单元应用经 TVB 修正的 minmod 限制器，以获得 $\\tilde{a}_{1,i}$。\n- 对于光滑输入 $f_1(x)$ 和 $f_2(x)$，构造 $S(f_1)$、$S(f_2)$ 和 $S(f_1+f_2)$，并验证限制器是否仅对 $S(f_1+f_2)$ 触发。\n- 通过计算差值 $S(f_1)+S(f_2)-S(f_1+f_2)$ 的全局 $L^2$ 范数，并用 $S(f_1)+S(f_2)$ 的全局 $L^2$ 范数对其进行缩放，来量化叠加违背：\n$$\n\\mathcal{V} = \\frac{\\left\\|S(f_1)+S(f_2)-S(f_1+f_2)\\right\\|_{L^2([0,1])}}{\\left\\|S(f_1)+S(f_2)\\right\\|_{L^2([0,1])}},\n$$\n约定如果分母为0，则 $\\mathcal{V}=0$。使用局部勒让德基，在单个单元上具有系数 $(b_{0},b_{1})$ 的表示的 $L^2$ 范数平方为 $h\\left(b_{0}^2 + \\frac{1}{3}b_{1}^2\\right)$，全局范数平方是所有单元上范数平方的总和。\n\n使用具有指定参数的光滑三角函数输入：\n$$\nf_k(x) = A_k \\sin\\!\\left(2\\pi m_k x + \\phi_k\\right),\\qquad k\\in\\{1,2\\},\n$$\n其中 $A_k0$ 是振幅，$m_k\\in\\mathbb{N}$ 是空间波数，$\\phi_k$ 是相位。角度 $\\phi_k$ 必须以弧度为单位解释。\n\n测试套件。实现您的程序以评估以下三个测试用例，每个用例由元组 $(N,M,A_1,m_1,\\phi_1,A_2,m_2,\\phi_2)$ 定义：\n\n- 用例1（设计为限制器仅对 $f_1+f_2$ 触发）：$(N,M,A_1,m_1,\\phi_1,A_2,m_2,\\phi_2) = (100,150,0.02,6,0.0,0.015,9,0.0)$。\n- 用例2（边界情况，对任何输入均不触发限制器）：$(N,M,A_1,m_1,\\phi_1,A_2,m_2,\\phi_2) = (100,1000,0.005,4,0.3,0.004,5,1.2)$。\n- 用例3（边缘情况，限制器对 $f_1$、$f_2$ 以及 $f_1+f_2$ 均触发）：$(N,M,A_1,m_1,\\phi_1,A_2,m_2,\\phi_2) = (100,50,0.04,12,0.0,0.03,10,0.5)$。\n\n对每个用例，计算并返回四个量：\n- $n_1$：对于 $S(f_1)$，限制器修改了 $a_{1,i}$ 的单元数量\n- $n_2$：对于 $S(f_2)$，限制器修改了 $a_{1,i}$ 的单元数量\n- $n_{12}$：对于 $S(f_1+f_2)$，限制器修改了 $a_{1,i}$ 的单元数量\n- $\\mathcal{V}$：如上定义的叠加违背度量\n\n最终输出格式。您的程序应生成单行输出，其中包含三个用例的结果，形式为方括号括起来的逗号分隔列表。用例1的四个量后面跟着用例2的四个量，再后面是用例3的四个量。例如，输出格式必须与 $[n_1^{(1)},n_2^{(1)},n_{12}^{(1)},\\mathcal{V}^{(1)},n_1^{(2)},n_2^{(2)},n_{12}^{(2)},\\mathcal{V}^{(2)},n_1^{(3)},n_2^{(3)},n_{12}^{(3)},\\mathcal{V}^{(3)}]$ 完全一样，其中所有数字都应打印出来，角度以弧度为单位。",
            "solution": "该问题要求分析在间断伽辽金 (DG) 方法中使用的非线性斜率限制器对叠加原理的违背情况。我们得到了一个从函数 $f(x)$ 到其应用了 TVB 修正的 minmod 斜率限制器的 DG 表示的映射 $S$ 的定义。我们必须计算对于函数 $f_1$、$f_2$ 及其和 $f_1+f_2$，限制器被激活的单元数量，并量化叠加违背 $\\mathcal{V} = \\|S(f_1)+S(f_2)-S(f_1+f_2)\\|_{L^2} / \\|S(f_1)+S(f_2)\\|_{L^2}$。\n\n该过程涉及三个主要步骤：\n1.  将给定函数 $f(x)$ 投影到 $P^1$ DG 空间上，以求得系数 $\\{a_{0,i}, a_{1,i}\\}$。\n2.  对斜率系数 $\\{a_{1,i}\\}$ 应用非线性的 TVB 修正 minmod 限制器，以获得受限系数 $\\{\\tilde{a}_{1,i}\\}$。\n3.  使用 DG 表示的性质和给定的 $L^2$ 范数定义，计算所需的量（$n_1, n_2, n_{12}, \\mathcal{V}$）。\n\n**步骤 1：输入函数的解析投影**\n\n输入函数的形式为 $f(x) = A \\sin(2\\pi m x + \\phi)$。第 $i$ 个单元的系数 $a_{0,i}$ 和 $a_{1,i}$ 是通过在局部域 $\\xi \\in [-1,1]$ 上对勒让德基函数 $P_0(\\xi)=1$ 和 $P_1(\\xi)=\\xi$ 进行积分得到的。坐标变换为 $x = x_i + \\frac{h}{2}\\xi$，其中 $x_i = (i+0.5)h$ 是单元中心， $h=1/N$ 是单元宽度。\n\n对于 $a_{0,i}$：\n$$\na_{0,i} = \\frac{1}{2}\\int_{-1}^{1} A \\sin\\!\\left(2\\pi m \\left(x_i + \\frac{h}{2}\\xi\\right) + \\phi\\right) d\\xi\n$$\n令 $\\theta_i = 2\\pi m x_i + \\phi$ 且 $k = \\pi m h$。积分变为：\n$$\na_{0,i} = \\frac{A}{2} \\int_{-1}^{1} \\sin(\\theta_i + k\\xi) d\\xi = \\frac{A}{2} \\left[-\\frac{\\cos(\\theta_i + k\\xi)}{k}\\right]_{-1}^{1} = \\frac{A}{2k} (\\cos(\\theta_i - k) - \\cos(\\theta_i + k))\n$$\n使用恒等式 $\\cos(B) - \\cos(A) = 2\\sin(\\frac{A+B}{2})\\sin(\\frac{A-B}{2})$，我们得到：\n$$\na_{0,i} = A \\frac{\\sin(k)}{k} \\sin(\\theta_i) = A \\frac{\\sin(\\pi m h)}{\\pi m h} \\sin(2\\pi m x_i + \\phi)\n$$\n\n对于 $a_{1,i}$：\n$$\na_{1,i} = \\frac{3}{2}\\int_{-1}^{1} A \\sin\\!\\left(2\\pi m \\left(x_i + \\frac{h}{2}\\xi\\right) + \\phi\\right) \\xi\\,d\\xi\n$$\n积分为 $\\int_{-1}^1 \\xi \\sin(\\theta_i + k\\xi) d\\xi$。使用分部积分法，我们发现：\n$$\n\\int_{-1}^{1} \\xi \\sin(\\theta_i + k\\xi) d\\xi = \\left[-\\frac{\\xi}{k}\\cos(\\theta_i + k\\xi) + \\frac{1}{k^2}\\sin(\\theta_i + k\\xi)\\right]_{-1}^{1} = 2\\cos(\\theta_i)\\left(\\frac{\\sin k - k\\cos k}{k^2}\\right)\n$$\n因此，系数 $a_{1,i}$ 为：\n$$\na_{1,i} = 3A \\cos(2\\pi m x_i + \\phi) \\frac{\\sin(\\pi m h) - \\pi m h \\cos(\\pi m h)}{(\\pi m h)^2}\n$$\n这些解析公式能够精确高效地计算系数，无需使用数值积分。注意，由于 $m \\in \\mathbb{N}$ (即 $m \\ge 1$)，对于 $h0$，分母 $\\pi m h$ 非零。\n\n**步骤 2：应用 TVB 修正的 Minmod 限制器**\n\n该限制器根据相邻单元的单元平均值来修改斜率系数 $a_{1,i}$。首先，我们计算单元平均值的差分：$\\Delta_{i-\\frac{1}{2}} = a_{0,i} - a_{0,i-1}$ 和 $\\Delta_{i+\\frac{1}{2}} = a_{0,i+1} - a_{0,i}$。周期性通过环绕索引来处理（例如，对于 $i=0$，其“左”邻居 $i-1$ 是 $N-1$）。\n\nTVB 阈值为 $T = M h^2$。只有当局部变化足够大时，即 $|\\Delta_{i-\\frac{1}{2}}|  T$ 且 $|\\Delta_{i+\\frac{1}{2}}|  T$ 时，限制器才会被“激活”。如果满足此条件，$a_{1,i}$ 将被替换为 $\\tilde{a}_{1,i} = \\operatorname{minmod}(a_{1,i}, \\Delta_{i-\\frac{1}{2}}, \\Delta_{i+\\frac{1}{2}})$。否则，$\\tilde{a}_{1,i} = a_{1,i}$。\n\nminmod 函数定义为：\n$$\n\\operatorname{minmod}(z_1,z_2,z_3) =\n\\begin{cases}\n\\operatorname{sign}(z_1)\\,\\min\\{|z_1|,|z_2|,|z_3|\\},  \\text{if } \\operatorname{sign}(z_1)=\\operatorname{sign}(z_2)=\\operatorname{sign}(z_3),\\\\\n0,  \\text{otherwise.}\n\\end{cases}\n$$\n该函数本质上是非线性的。对于给定的函数，受限单元的数量 $n$ 是满足 $\\tilde{a}_{1,i} \\neq a_{1,i}$ 的索引 $i$ 的计数。\n\n**步骤 3：计算叠加违背**\n\n问题的核心是分析算子 $S: f \\mapsto u^{\\text{DG}}$，其中 $u^{\\text{DG}}$ 由系数 $\\{a_{0,i}, \\tilde{a}_{1,i}\\}$ 定义。投影步骤（求 $a_{0,i}, a_{1,i}$）是线性的。因此，对于 $f_{1+2} = f_1 + f_2$，初始系数为 $a_{0,i}^{(1+2)} = a_{0,i}^{(1)} + a_{0,i}^{(2)}$ 和 $a_{1,i}^{(1+2)} = a_{1,i}^{(1)} + a_{1,i}^{(2)}$。非线性完全来自于限制器。\n\n叠加违背 $\\mathcal{V}$ 是两个 $L^2$ 范数的比值。我们来分析各项：\n-   $S(f_1)$ 是系数为 $\\{a_{0,i}^{(1)}, \\tilde{a}_{1,i}^{(1)}\\}$ 的 DG 函数。\n-   $S(f_2)$ 是系数为 $\\{a_{0,i}^{(2)}, \\tilde{a}_{1,i}^{(2)}\\}$ 的 DG 函数。\n-   $S(f_1) + S(f_2)$ 是这两个函数的和。其系数为 $\\{a_{0,i}^{(1)} + a_{0,i}^{(2)}, \\tilde{a}_{1,i}^{(1)} + \\tilde{a}_{1,i}^{(2)}\\}$。\n-   $S(f_1+f_2)$ 是通过先求出 $f_1+f_2$ 的系数 $\\{a_{0,i}^{(1)} + a_{0,i}^{(2)}, a_{1,i}^{(1)} + a_{1,i}^{(2)}\\}$，然后应用限制器得到 $\\{a_{0,i}^{(1)} + a_{0,i}^{(2)}, \\tilde{a}_{1,i}^{(1+2)}\\}$。\n\n差函数 $D = S(f_1)+S(f_2)-S(f_1+f_2)$ 的系数为：\n    $d_{0,i} = (a_{0,i}^{(1)} + a_{0,i}^{(2)}) - (a_{0,i}^{(1)} + a_{0,i}^{(2)}) = 0$。\n    $d_{1,i} = (\\tilde{a}_{1,i}^{(1)} + \\tilde{a}_{1,i}^{(2)}) - \\tilde{a}_{1,i}^{(1+2)}$。\n$D$ 的范数平方（$\\mathcal{V}$ 的分子）由下式给出：\n$$\n\\|D\\|_{L^2}^2 = \\sum_{i=0}^{N-1} h\\left(d_{0,i}^2 + \\frac{1}{3}d_{1,i}^2\\right) = \\frac{h}{3} \\sum_{i=0}^{N-1} \\left( (\\tilde{a}_{1,i}^{(1)} + \\tilde{a}_{1,i}^{(2)}) - \\tilde{a}_{1,i}^{(1+2)} \\right)^2\n$$\n和函数 $S(f_1)+S(f_2)$ 的范数平方（$\\mathcal{V}$ 的分母）为：\n$$\n\\|S(f_1)+S(f_2)\\|_{L^2}^2 = \\sum_{i=0}^{N-1} h\\left( (a_{0,i}^{(1)} + a_{0,i}^{(2)})^2 + \\frac{1}{3}(\\tilde{a}_{1,i}^{(1)} + \\tilde{a}_{1,i}^{(2)})^2 \\right)\n$$\n违背度量 $\\mathcal{V}$ 是这两个量之比的平方根。对于每个测试用例，我们遵循此过程来计算 $n_1$（对于 $f_1$）、$n_2$（对于 $f_2$）、$n_{12}$（对于 $f_1+f_2$）和 $\\mathcal{V}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # (N, M, A1, m1, phi1, A2, m2, phi2)\n        (100, 150, 0.02, 6, 0.0, 0.015, 9, 0.0),\n        (100, 1000, 0.005, 4, 0.3, 0.004, 5, 1.2),\n        (100, 50, 0.04, 12, 0.0, 0.03, 10, 0.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, A1, m1, phi1, A2, m2, phi2 = case\n\n        # Project f1 and f2 onto the P1 space\n        a0_1, a1_1 = project_sinusoid(A1, m1, phi1, N)\n        a0_2, a1_2 = project_sinusoid(A2, m2, phi2, N)\n\n        # Apply limiter to f1 and f2\n        a1_tilde_1, n1 = apply_limiter(a0_1, a1_1, N, M)\n        a1_tilde_2, n2 = apply_limiter(a0_2, a1_2, N, M)\n\n        # Coefficients for f1+f2 are the sum of coefficients (linearity of projection)\n        a0_12 = a0_1 + a0_2\n        a1_12 = a1_1 + a1_2\n\n        # Apply limiter to f1+f2\n        a1_tilde_12, n12 = apply_limiter(a0_12, a1_12, N, M)\n\n        # Calculate superposition violation V\n        h = 1.0 / N\n        \n        # Numerator calculation\n        # Coefficients of the difference function D = S(f1)+S(f2)-S(f1+f2)\n        d1 = (a1_tilde_1 + a1_tilde_2) - a1_tilde_12\n        # d0 is zero due to linearity of projection for cell averages\n        num_norm_sq = (h / 3.0) * np.sum(d1**2)\n\n        # Denominator calculation\n        # Coefficients of the sum function S(f1)+S(f2)\n        b0 = a0_1 + a0_2\n        b1 = a1_tilde_1 + a1_tilde_2\n        den_norm_sq = h * np.sum(b0**2 + (1.0 / 3.0) * b1**2)\n\n        if den_norm_sq == 0:\n            V = 0.0\n        else:\n            V = np.sqrt(num_norm_sq / den_norm_sq)\n\n        results.extend([n1, n2, n12, V])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef project_sinusoid(A, m, phi, N):\n    \"\"\"\n    Computes the DG-P1 coefficients a0 and a1 for a function f(x) = A*sin(2*pi*m*x + phi).\n    \n    Args:\n        A (float): Amplitude.\n        m (int): Spatial mode number.\n        phi (float): Phase in radians.\n        N (int): Number of cells.\n        \n    Returns:\n        tuple: (a0, a1) numpy arrays of coefficients.\n    \"\"\"\n    h = 1.0 / N\n    x_i = (np.arange(N) + 0.5) * h\n    \n    # Use analytical formulas for the projection integrals\n    theta_i = 2.0 * np.pi * m * x_i + phi\n    k = np.pi * m * h\n\n    if k == 0: # Note: problem states m is in N, so m>=1, k>0. This is just for safety.\n        a0 = A * np.sin(phi) * np.ones(N)\n        a1 = np.zeros(N)\n        return a0, a1\n\n    sinc_k = np.sin(k) / k\n    a0 = A * sinc_k * np.sin(theta_i)\n\n    # Factor for a1: 3 * (sin(k) - k*cos(k)) / k^2\n    factor_a1 = 3.0 * (np.sin(k) - k * np.cos(k)) / (k**2)\n    a1 = A * factor_a1 * np.cos(theta_i)\n\n    return a0, a1\n\ndef minmod_vec(z1, z2, z3):\n    \"\"\"\n    Vectorized implementation of the minmod function for three arguments.\n    \"\"\"\n    s1, s2, s3 = np.sign(z1), np.sign(z2), np.sign(z3)\n    mask = (s1 == s2)  (s2 == s3)\n    \n    result = np.zeros_like(z1, dtype=np.float64)\n    \n    z_stack = np.stack([np.abs(z1), np.abs(z2), np.abs(z3)], axis=0)\n    min_abs = np.min(z_stack, axis=0)\n    \n    result[mask] = s1[mask] * min_abs[mask]\n    return result\n\ndef apply_limiter(a0, a1, N, M):\n    \"\"\"\n    Applies the TVB-modified minmod limiter to the slope coefficients a1.\n    \n    Args:\n        a0 (np.ndarray): Cell average coefficients.\n        a1 (np.ndarray): Original slope coefficients.\n        N (int): Number of cells.\n        M (float): TVB parameter.\n    \n    Returns:\n        tuple: (a1_tilde, n_limited)\n               a1_tilde: The limited slope coefficients.\n               n_limited: The number of cells where limiting was applied.\n    \"\"\"\n    h = 1.0 / N\n    T = M * h**2\n\n    # Calculate neighbor differences with periodic boundaries\n    a0_im1 = np.roll(a0, 1)  # a0_{i-1}\n    a0_ip1 = np.roll(a0, -1) # a0_{i+1}\n    \n    delta_imhalf = a0 - a0_im1\n    delta_iphalf = a0_ip1 - a0\n\n    # Apply TVB condition to find which cells to limit\n    limit_mask = (np.abs(delta_imhalf) > T)  (np.abs(delta_iphalf) > T)\n    \n    # Initialize modified slopes as the original ones\n    a1_tilde = np.copy(a1)\n    \n    # Apply minmod only where the TVB condition is met\n    if np.any(limit_mask):\n        a1_to_limit = a1[limit_mask]\n        delta_imhalf_to_limit = delta_imhalf[limit_mask]\n        delta_iphalf_to_limit = delta_iphalf[limit_mask]\n\n        limited_slopes = minmod_vec(a1_to_limit, delta_imhalf_to_limit, delta_iphalf_to_limit)\n        a1_tilde[limit_mask] = limited_slopes\n\n    # Count number of limited cells\n    n_limited = np.sum(a1_tilde != a1)\n    \n    return a1_tilde, n_limited\n\nsolve()\n```"
        }
    ]
}