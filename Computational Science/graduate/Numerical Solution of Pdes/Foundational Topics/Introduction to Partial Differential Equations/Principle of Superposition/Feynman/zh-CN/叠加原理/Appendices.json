{
    "hands_on_practices": [
        {
            "introduction": "叠加原理是线性系统的一个基本属性，理解其在数值方法中的应用至关重要。第一个实践提供了一个直接的动手操作机会，通过离散化泊松方程来探索这一概念 。您将分析证明并数值验证，对于一个线性系统 $A u = f$，当源项 $f$ 被分解时，其解是各个独立解的和，从而巩固抽象线性代数与实际计算结果之间的联系。",
            "id": "3434960",
            "problem": "设一个线性偏微分方程 (PDE) 在单位正方形域 $(0,1)\\times(0,1)$ 上进行离散化，边界条件为齐次狄利克雷 (Dirichlet) 边界条件 $u=0$。考虑泊松 (Poisson) 方程 $-\\Delta u = f$ 的离散模型，其中离散未知数是内部网格点上的值，离散右端项是强迫值向量。内部网格在每个空间方向上使用 $n$ 个点，间距为 $h = \\frac{1}{n+1}$，内部坐标为 $x_i = i h$, $y_j = j h$，其中 $i,j \\in \\{1,2,\\dots,n\\}$。使用拉普拉斯算子的标准五点差分格式，得到的离散线性系统为\n$$\nA u = f,\n$$\n其中 $A \\in \\mathbb{R}^{n^2 \\times n^2}$ 是对称正定矩阵\n$$\nA = \\frac{1}{h^2}\\left(I_n \\otimes K_n + K_n \\otimes I_n\\right),\n$$\n其中 $I_n$ 是 $n\\times n$ 单位矩阵，$\\otimes$ 是克罗内克积 (Kronecker product)，$K_n \\in \\mathbb{R}^{n \\times n}$ 是一个三对角矩阵，其对角项为 $2$，非对角项为 $-1$。离散向量 $f \\in \\mathbb{R}^{n^2}$ 以任意一致的字典序汇集了内部网格上的强迫值 $f_{i,j}$。\n\n仅使用“矩阵是线性算子”的基本定义以及对称正定矩阵的可逆性准则，推导对于任意分解 $f = f^{(1)} + f^{(2)}$，方程 $A u^{(1)} = f^{(1)}$、$A u^{(2)} = f^{(2)}$ 和 $A u = f$ 的唯一解满足叠加恒等式\n$$\nu = u^{(1)} + u^{(2)}.\n$$\n三角函数中使用的角度必须以弧度为单位。\n\n然后，对以下测试套件数值验证此恒等式。对于每个测试用例，按规定构建矩阵 $A$ 和向量 $f^{(1)}$、$f^{(2)}$，通过求解相应的线性系统计算 $u$、$u^{(1)}$ 和 $u^{(2)}$，并检验在容差 $\\varepsilon = 10^{-12}$ 下是否满足 $\\| u - (u^{(1)} + u^{(2)}) \\|_2 \\le \\varepsilon$。您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表（例如 $[result_1,result_2,\\dots]$），列表中的每个条目都是一个布尔值，表示该测试是否通过。\n\n测试套件：\n- 用例 1：$n=3$。定义 $f^{(1)}_{i,j} = \\sin(\\pi x_i) \\sin(\\pi y_j)$ 和 $f^{(2)}_{i,j} = \\sin(2\\pi x_i) \\sin(\\pi y_j)$，角度以弧度为单位。\n- 用例 2：$n=4$。对所有内部索引 $i,j$，定义 $f^{(1)}_{i,j} = 1$ 和 $f^{(2)}_{i,j} = -1$。\n- 用例 3：$n=5$。定义 $f^{(1)}_{i,j}$ 在离散中心点 $(i^*,j^*)$（其中 $i^* = \\lceil \\frac{n}{2} \\rceil$，$j^* = \\lceil \\frac{n}{2} \\rceil$）处为 $1$，其他位置为 $0$；定义 $f^{(2)}_{i,j}$ 在所有位置均为 $0$。\n- 用例 4：$n=4$。将 $f^{(1)}$ 和 $f^{(2)}$ 定义为在网格上从 $[0,1)$ 区间内均匀分布的随机数的独立实现，为保证可复现性，分别使用固定种子 $42$ 和 $43$。\n- 用例 5：$n=3$。对所有内部索引，定义 $f^{(1)}_{i,j} = 0$，并定义 $f^{(2)}_{i,j} = \\sin(\\pi x_i)\\sin(\\pi y_j)$，角度以弧度为单位。\n\n所有三角函数必须使用以弧度为单位的角度。最终输出必须是形如 $[b_1,b_2,b_3,b_4,b_5]$ 的单行文本，其中 $b_k$ 对应用例的结果，值为 $\\text{True}$ 或 $\\text{False}$。",
            "solution": "问题陈述是有效的。其科学依据在于数值线性代数和偏微分方程离散化的原理。该问题是适定的、客观的，并包含了进行理论推导和数值验证所需的所有信息。\n\n### 第 1 部分：叠加原理的推导\n\n目标是证明对于线性系统 $A u = f$，如果强迫项分解为 $f = f^{(1)} + f^{(2)}$，那么解 $u$ 就是各个独立问题解的和，即 $u = u^{(1)} + u^{(2)}$，其中 $A u^{(1)} = f^{(1)}$ 且 $A u^{(2)} = f^{(2)}$。该推导基于问题中提到的两个基本性质：矩阵算子 $A$ 的线性性，以及对称正定(SPD)矩阵的可逆性。\n\n设 $A \\in \\mathbb{R}^{n^2 \\times n^2}$ 是表示该离散线性算子的矩阵。离散解向量 $u$ 和离散强迫向量 $f$ 之间的关系由以下线性系统给出：\n$$\nA u = f\n$$\n给定强迫向量 $f$ 分解为两个分量 $f^{(1)}$ 和 $f^{(2)}$，使得：\n$$\nf = f^{(1)} + f^{(2)}\n$$\n设 $u^{(1)}$ 和 $u^{(2)}$ 分别是强迫项为 $f^{(1)}$ 和 $f^{(2)}$ 的线性系统的解：\n$$\nA u^{(1)} = f^{(1)}\n$$\n$$\nA u^{(2)} = f^{(2)}\n$$\n问题要求我们使用矩阵表示线性算子这一事实。算子 $A$ 的线性性质表明，对于其定义域中的任意向量 $v_1, v_2$ 和任意标量 $c_1, c_2$，以下等式成立：\n$$\nA(c_1 v_1 + c_2 v_2) = c_1 A v_1 + c_2 A v_2\n$$\n我们可以通过设置 $c_1=1$ 和 $c_2=1$ 将此性质应用于向量 $u^{(1)}$ 和 $u^{(2)}$ 的和：\n$$\nA (u^{(1)} + u^{(2)}) = A u^{(1)} + A u^{(2)}\n$$\n现在，我们根据定义方程代入 $A u^{(1)}$ 和 $A u^{(2)}$ 的表达式：\n$$\nA (u^{(1)} + u^{(2)}) = f^{(1)} + f^{(2)}\n$$\n因为给定 $f = f^{(1)} + f^{(2)}$，我们可以将其代入方程的右端：\n$$\nA (u^{(1)} + u^{(2)}) = f\n$$\n此方程表明向量 $(u^{(1)} + u^{(2)})$ 是原始线性系统 $A u = f$ 的一个解。\n\n第二个关键信息是矩阵 $A$ 是对称正定(SPD)的。线性代数中的一个基本定理指出，SPD 矩阵总是可逆的。$A$ 的可逆性意味着对于任何右端向量 $f$，线性系统 $A x = f$ 都有唯一解，解由 $x = A^{-1}f$ 给出。\n\n我们已经确定了两个满足关于强迫项 $f$ 的方程的向量：\n1. 向量 $u$，根据其定义：$A u = f$。\n2. 向量 $(u^{(1)} + u^{(2)})$，如上所推导：$A(u^{(1)} + u^{(2)}) = f$。\n\n由于系统的解是唯一的，这两个向量必须是相同的。因此，我们得出结论：\n$$\nu = u^{(1)} + u^{(2)}\n$$\n这就完成了该离散线性系统叠加原理的推导。\n\n### 第 2 部分：数值验证\n\n为了对此原理进行数值验证，我们将实现所述的测试用例。对于每个用例，我们将：\n1.  对于给定的维度 $n$，构建矩阵 $A = \\frac{1}{h^2}(I_n \\otimes K_n + K_n \\otimes I_n)$，其中 $h = \\frac{1}{n+1}$，$I_n$ 是 $n \\times n$ 的单位矩阵，$K_n$ 是一个 $n \\times n$ 的三对角矩阵，其主对角线上的元素为 $2$，超对角线和次对角线上的元素为 $-1$。\n2.  根据每个测试用例的规定，构建大小为 $n^2 \\times 1$ 的右端向量 $f^{(1)}$ 和 $f^{(2)}$。这包括创建坐标网格 $(x_i, y_j)$，计算给定函数的值，然后使用一致的字典序将得到的 $n \\times n$ 矩阵展平为向量。\n3.  计算总强迫向量 $f = f^{(1)} + f^{(2)}$。\n4.  使用标准的线性求解器求解三个线性系统 $A u^{(1)} = f^{(1)}$、$A u^{(2)} = f^{(2)}$ 和 $A u = f$，以获得解向量 $u^{(1)}$、$u^{(2)}$ 和 $u$。\n5.  计算差向量的L2范数：$\\| u - (u^{(1)} + u^{(2)}) \\|_2$。\n6.  将此范数与指定的容差 $\\varepsilon = 10^{-12}$ 进行比较。如果范数小于或等于该容差，则测试通过。\n所有测试用例的结果将被收集并表示为一个布尔值列表。由于浮点运算的性质，差值不会精确为零，而是在机器精度的量级上，对于这些良态系统，该值远小于给定的容差。因此，我们预期所有测试都会通过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and numerically verifies the principle of superposition for the\n    discrete Poisson equation.\n    \"\"\"\n    \n    test_suite = [\n        {'case_id': 1, 'n': 3},\n        {'case_id': 2, 'n': 4},\n        {'case_id': 3, 'n': 5},\n        {'case_id': 4, 'n': 4},\n        {'case_id': 5, 'n': 3},\n    ]\n\n    results = []\n    epsilon = 1e-12\n\n    for test in test_suite:\n        n = test['n']\n        case_id = test['case_id']\n        \n        # 1. Construct the matrix A\n        h = 1.0 / (n + 1)\n        \n        # K_n is the tridiagonal matrix [-1, 2, -1]\n        k_n = (2 * np.identity(n) - \n               np.diag(np.ones(n - 1), k=1) - \n               np.diag(np.ones(n - 1), k=-1))\n               \n        # I_n is the n x n identity matrix\n        i_n = np.identity(n)\n        \n        # A is the discrete Laplacian using Kronecker products\n        A = (1 / h**2) * (np.kron(i_n, k_n) + np.kron(k_n, i_n))\n        \n        # 2. Construct the vectors f^(1) and f^(2)\n        \n        # Grid coordinates\n        # i, j in {1, ..., n}\n        coords = np.arange(1, n + 1) * h\n        X, Y = np.meshgrid(coords, coords, indexing='ij')\n\n        f1 = np.zeros(n * n)\n        f2 = np.zeros(n * n)\n\n        if case_id == 1:\n            # Case 1: n=3, trigonometric functions\n            f1_mat = np.sin(np.pi * X) * np.sin(np.pi * Y)\n            f2_mat = np.sin(2 * np.pi * X) * np.sin(np.pi * Y)\n            f1 = f1_mat.flatten()\n            f2 = f2_mat.flatten()\n        elif case_id == 2:\n            # Case 2: n=4, constant functions\n            f1 = np.ones(n * n)\n            f2 = -np.ones(n * n)\n        elif case_id == 3:\n            # Case 3: n=5, delta function\n            i_star = int(np.ceil(n / 2.0))\n            j_star = int(np.ceil(n / 2.0))\n            # Lexicographic index (row-major) for (i*, j*)\n            # where i,j are 1-based indices\n            k = (i_star - 1) * n + (j_star - 1)\n            f1[k] = 1.0\n            # f2 is already a zero vector\n        elif case_id == 4:\n            # Case 4: n=4, random vectors\n            rng1 = np.random.default_rng(42)\n            f1 = rng1.uniform(0, 1, size=n * n)\n            rng2 = np.random.default_rng(43)\n            f2 = rng2.uniform(0, 1, size=n * n)\n        elif case_id == 5:\n            # Case 5: n=3, zero and trigonometric function\n            # f1 is already a zero vector\n            f2_mat = np.sin(np.pi * X) * np.sin(np.pi * Y)\n            f2 = f2_mat.flatten()\n\n        # 3. Calculate the total forcing vector f\n        f = f1 + f2\n        \n        # 4. Solve the three linear systems\n        u1 = np.linalg.solve(A, f1)\n        u2 = np.linalg.solve(A, f2)\n        u = np.linalg.solve(A, f)\n        \n        # 5. Compute the L2-norm of the error\n        error_norm = np.linalg.norm(u - (u1 + u2), 2)\n        \n        # 6. Compare with tolerance and store result\n        results.append(error_norm = epsilon)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在离散案例的基础上，我们现在转向偏微分方程的连续形式。这个练习将考察叠加原理在边界条件下的应用 。该问题使用拉普拉斯方程来证明，对于合并后的边界数据，其解等于各个独立边界数据下的解之和，并进一步探讨了在有限元方法所使用的弱形式中这一性质是如何得以保持的。通过研究偏微分方程算子和边界迹算子的线性，您将更深刻地理解基本原理在向现代模拟技术所必需的弱形式过渡时是如何被保留下来的。",
            "id": "3434956",
            "problem": "考虑单位正方形域 $\\Omega = (0,1) \\times (0,1)$ 上的齐次拉普拉斯方程\n$$\n-\\Delta u = 0 \\quad \\text{in } \\Omega,\n$$\n其狄利克雷边界条件为 $u = g$ on $\\partial \\Omega$，其中边界数据 $g$ 是一个定义在 $\\overline{\\Omega}$ 上的函数的迹。叠加原理指出，对于一个线性的偏微分方程和线性的边界条件，与边界数据 $g_{1}$ 和 $g_{2}$ 相关联的解之和，是与边界数据 $g_{1} + g_{2}$ 相关联的解。从拉普拉斯算子的线性性和狄利克雷边界条件的定义出发，完成以下任务，并确保所有角度均以弧度表示：\n\n1. 定义两个函数\n$$\nu_{1}(x,y) = \\sinh(\\pi x)\\,\\sin(\\pi y), \\qquad u_{2}(x,y) = \\sinh(2\\pi x)\\,\\sin(2\\pi y),\n$$\n并设 $g_{1}$ 和 $g_{2}$ 分别是它们在边界 $\\partial \\Omega$ 上的迹，即 $g_{1} = u_{1}|_{\\partial \\Omega}$ 和 $g_{2} = u_{2}|_{\\partial \\Omega}$。仅使用拉普拉斯算子和狄利克雷边界条件的基本性质，验证 $u_{1}$ 和 $u_{2}$ 分别是对应于边界数据 $g_{1}$ 和 $g_{2}$ 的狄利克雷问题的有效解。\n\n2. 利用 $-\\Delta$ 的线性性和迹的定义，证明 $u = u_{1} + u_{2}$ 是对应于边界数据 $g = g_{1} + g_{2}$ 的狄利克雷问题的解，并精确解释为什么在这种情况下叠加原理适用。\n\n3. 考虑在 $\\Omega$ 的一个形状正则的三角剖分上，使用一个连续分片多项式空间 $V_{h} \\subset H^{1}(\\Omega)$ 且不强加边界条件的协调有限元方法 (FEM)，其网格尺寸为 $h$。从弱形式和边界 $\\partial \\Omega$ 上的单位外法向量 $\\boldsymbol{n}$ 的定义出发，推导：\n   - 一种对狄利克雷数据 $g$ 的罚函数强制方案，通过在能量中增加一个形式为 $\\frac{\\gamma}{h}\\int_{\\partial \\Omega}(u_{h}-g)^{2}\\,ds$ 的边界罚项，其中 $\\gamma0$ 是一个固定的罚参数。\n   - 一种对狄利克雷数据 $g$ 的对称Nitsche方法，通过添加涉及法向通量的一致性边界项和一个形式为 $\\frac{\\beta}{h}\\int_{\\partial \\Omega}(u_{h}-g)v\\,ds$ 的稳定项，其中 $\\beta0$ 被选择得足够大以确保矫顽性。\n\n   在这两种情况下，仅利用双线性和线性形式的线性性，仔细论证为什么离散解映射 $g \\mapsto u_{h}(g)$ 是线性的，并因此保持叠加性，即 $u_{h}(g_{1}+g_{2}) = u_{h}(g_{1}) + u_{h}(g_{2})$。\n\n4. 计算第2部分中的精确叠加解在点 $(x,y) = \\left(\\frac{1}{2}, \\frac{1}{3}\\right)$ 处的值，并以单一闭式解析表达式的形式给出结果。不需要进行数值舍入。\n\n您的最终答案必须是单一的闭式解析表达式。",
            "solution": "问题陈述被认为是有效的，因为它在偏微分方程和数值分析理论方面具有科学依据，是适定的、客观的且内部一致的。\n\n**第1部分：验证单个解**\n\n我们需要验证 $u_{1}(x,y) = \\sinh(\\pi x)\\sin(\\pi y)$ 和 $u_{2}(x,y) = \\sinh(2\\pi x)\\sin(2\\pi y)$ 分别是其对应狄利克雷问题的有效解。如果一个函数 $u$ 在域 $\\Omega$ 中满足 $-\\Delta u = 0$ 并且在边界 $\\partial \\Omega$ 上满足 $u = g$，那么它就是边界数据为 $g$ 的狄利克雷问题的解。\n\n对于函数 $u_1$：\n首先，我们检查它是否满足齐次拉普拉斯方程 $-\\Delta u_1 = 0$。拉普拉斯算子为 $\\Delta = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$。我们计算 $u_1$ 的二阶偏导数：\n$$ \\frac{\\partial u_1}{\\partial x} = \\pi \\cosh(\\pi x)\\sin(\\pi y) \\implies \\frac{\\partial^2 u_1}{\\partial x^2} = \\pi^2 \\sinh(\\pi x)\\sin(\\pi y) = \\pi^2 u_1(x,y) $$\n$$ \\frac{\\partial u_1}{\\partial y} = \\pi \\sinh(\\pi x)\\cos(\\pi y) \\implies \\frac{\\partial^2 u_1}{\\partial y^2} = -\\pi^2 \\sinh(\\pi x)\\sin(\\pi y) = -\\pi^2 u_1(x,y) $$\n$u_1$ 的拉普拉斯算子是这些二阶偏导数的和：\n$$ \\Delta u_1 = \\frac{\\partial^2 u_1}{\\partial x^2} + \\frac{\\partial^2 u_1}{\\partial y^2} = \\pi^2 u_1(x,y) - \\pi^2 u_1(x,y) = 0 $$\n由于 $\\Delta u_1 = 0$，立即可得 $-\\Delta u_1 = 0$。因此，$u_1$ 在 $\\Omega$ 内满足偏微分方程。\n边界条件是 $u_1 = g_1$ on $\\partial\\Omega$。问题定义 $g_1$ 为 $u_1$ 在边界上的迹，即 $g_1 = u_1|_{\\partial\\Omega}$。根据这个定义，$u_1$ 满足其自身的边界条件。因此，$u_1$ 是边界数据为 $g_1$ 的狄利克雷问题的有效解。\n\n对于函数 $u_2$：\n过程完全相同。我们计算 $u_2$ 的二阶偏导数：\n$$ \\frac{\\partial u_2}{\\partial x} = 2\\pi \\cosh(2\\pi x)\\sin(2\\pi y) \\implies \\frac{\\partial^2 u_2}{\\partial x^2} = (2\\pi)^2 \\sinh(2\\pi x)\\sin(2\\pi y) = (2\\pi)^2 u_2(x,y) $$\n$$ \\frac{\\partial u_2}{\\partial y} = 2\\pi \\sinh(2\\pi x)\\cos(2\\pi y) \\implies \\frac{\\partial^2 u_2}{\\partial y^2} = -(2\\pi)^2 \\sinh(2\\pi x)\\sin(2\\pi y) = -(2\\pi)^2 u_2(x,y) $$\n$u_2$ 的拉普拉斯算子是：\n$$ \\Delta u_2 = \\frac{\\partial^2 u_2}{\\partial x^2} + \\frac{\\partial^2 u_2}{\\partial y^2} = (2\\pi)^2 u_2(x,y) - (2\\pi)^2 u_2(x,y) = 0 $$\n因此，$-\\Delta u_2 = 0$，并且 $u_2$ 满足偏微分方程。\n边界条件是 $u_2 = g_2$ on $\\partial\\Omega$，其中 $g_2$ 被定义为 $g_2 = u_2|_{\\partial\\Omega}$。与 $u_1$ 一样，函数 $u_2$ 根据定义满足其边界条件。因此，$u_2$ 也是其对应狄利克雷问题的有效解。\n\n**第2部分：验证叠加解**\n\n我们需要证明 $u = u_1 + u_2$ 是边界数据为 $g = g_1 + g_2$ 的狄利克雷问题的解。这需要证明 $u$ 同时满足偏微分方程和边界条件。\n\n叠加原理之所以适用，正是因为问题的定义算子是线性的。\n1.  **微分算子的线性性**：算子 $L = -\\Delta$ 是线性的。这意味着对于其定义域中的任意两个函数 $f$ 和 $h$ 以及任意标量常数 $c_1, c_2$，有 $L(c_1 f + c_2 h) = c_1 L(f) + c_2 L(h)$。在我们的例子中，$c_1=c_2=1$：\n    $$ -\\Delta u = -\\Delta(u_1 + u_2) = -\\Delta u_1 - \\Delta u_2 $$\n    从第1部分可知，$-\\Delta u_1 = 0$ 和 $-\\Delta u_2 = 0$。因此，\n    $$ -\\Delta u = 0 + 0 = 0 $$\n    叠加函数 $u$ 满足拉普拉斯方程。\n\n2.  **边界条件算子的线性性**：边界条件由迹算子定义，它将定义在 $\\Omega$ 上的函数映射到其在边界 $\\partial\\Omega$ 上的值。迹算子也是线性的。在我们的例子中：\n    $$ u|_{\\partial \\Omega} = (u_1 + u_2)|_{\\partial \\Omega} = u_1|_{\\partial \\Omega} + u_2|_{\\partial \\Omega} $$\n    根据定义，$g_1 = u_1|_{\\partial\\Omega}$ 和 $g_2 = u_2|_{\\partial\\Omega}$。所以，\n    $$ u|_{\\partial \\Omega} = g_1 + g_2 = g $$\n    叠加函数 $u$ 满足新的、相加后的边界条件。\n\n由于 $u = u_1 + u_2$ 在 $\\Omega$ 内满足偏微分方程 $-\\Delta u = 0$ 并且在 $\\partial\\Omega$ 上满足边界条件 $u = g_1 + g_2$，因此它是指定狄利克雷问题的解。叠加原理的适用性是微分算子 $-\\Delta$ 和边界条件的迹算子两者线性性的直接结果。\n\n**第3部分：有限元法中离散解映射的线性性**\n\n$-\\Delta u=0$ 的弱形式是通过乘以一个测试函数 $v$ 并在 $\\Omega$ 上积分得到的。使用格林第一恒等式 $\\int_\\Omega (-\\Delta u) v \\, d\\boldsymbol{x} = \\int_\\Omega \\nabla u \\cdot \\nabla v \\, d\\boldsymbol{x} - \\int_{\\partial\\Omega} \\frac{\\partial u}{\\partial \\boldsymbol{n}} v \\, ds$，以及 $-\\Delta u = 0$ 这一事实，我们得到精确解 $u$ 的恒等式 $\\int_\\Omega \\nabla u \\cdot \\nabla v \\, d\\boldsymbol{x} = \\int_{\\partial \\Omega} \\frac{\\partial u}{\\partial \\boldsymbol{n}} v \\, ds$。我们寻求一个离散解 $u_h \\in V_h$。\n\n**罚方法：**\n罚方法通过最小化一个修正的能量泛函来寻求 $u_h \\in V_h$。这导致了以下变分问题：求 $u_h \\in V_h$，使得对于所有 $v \\in V_h$，\n$$ \\int_\\Omega \\nabla u_h \\cdot \\nabla v \\, d\\boldsymbol{x} + \\frac{\\gamma}{h} \\int_{\\partial \\Omega} u_h v \\, ds = \\frac{\\gamma}{h} \\int_{\\partial \\Omega} g v \\, ds $$\n这可以写成抽象形式 $a_h(u_h, v) = L_h(v; g)$，其中：\n- 双线性形式 $a_h(u_h, v) = \\int_\\Omega \\nabla u_h \\cdot \\nabla v \\, d\\boldsymbol{x} + \\frac{\\gamma}{h} \\int_{\\partial \\Omega} u_h v \\, ds$ 与边界数据 $g$ 无关。\n- 线性形式 $L_h(v; g) = \\frac{\\gamma}{h} \\int_{\\partial \\Omega} g v \\, ds$ 依赖于边界数据 $g$。\n\n为了证明映射 $g \\mapsto u_h(g)$ 是线性的，设 $u_h(g_1)$ 和 $u_h(g_2)$ 分别是数据 $g_1$ 和 $g_2$ 的解。它们满足：\n$a_h(u_h(g_1), v) = L_h(v; g_1)$ 对所有 $v \\in V_h$ 成立。\n$a_h(u_h(g_2), v) = L_h(v; g_2)$ 对所有 $v \\in V_h$ 成立。\n形式 $L_h(v; g)$ 关于 $g$ 是线性的，因为积分是线性运算：\n$L_h(v; g_1+g_2) = \\frac{\\gamma}{h} \\int_{\\partial \\Omega} (g_1+g_2)v \\, ds = \\frac{\\gamma}{h} \\int_{\\partial \\Omega} g_1 v \\, ds + \\frac{\\gamma}{h} \\int_{\\partial \\Omega} g_2 v \\, ds = L_h(v; g_1) + L_h(v; g_2)$。\n形式 $a_h(u,v)$ 关于其第一个变元是线性的。因此，对于解的和 $u_h(g_1)+u_h(g_2)$：\n$a_h(u_h(g_1)+u_h(g_2), v) = a_h(u_h(g_1), v) + a_h(u_h(g_2), v) = L_h(v; g_1) + L_h(v; g_2) = L_h(v; g_1+g_2)$。\n这表明 $u_h(g_1)+u_h(g_2)$ 是对应于边界数据 $g_1+g_2$ 的解。根据解的唯一性（由 $a_h$ 的矫顽性保证），我们有 $u_h(g_1+g_2) = u_h(g_1)+u_h(g_2)$。\n\n**对称Nitsche方法：**\n对称Nitsche方法由下式给出：求 $u_h \\in V_h$，使得对于所有 $v \\in V_h$，\n$$ \\int_\\Omega \\nabla u_h \\cdot \\nabla v \\, d\\boldsymbol{x} - \\int_{\\partial \\Omega} (\\nabla u_h \\cdot \\boldsymbol{n}) v \\, ds - \\int_{\\partial \\Omega} (u_h - g) (\\nabla v \\cdot \\boldsymbol{n}) \\, ds + \\frac{\\beta}{h} \\int_{\\partial \\Omega} (u_h-g)v \\, ds = 0 $$\n整理各项得到抽象形式 $a_h(u_h, v) = L_h(v;g)$:\n$$ \\underbrace{\\int_\\Omega \\!\\nabla u_h\\!\\cdot\\!\\nabla v d\\boldsymbol{x} \\!-\\! \\int_{\\partial \\Omega} \\!(\\nabla u_h\\!\\cdot\\!\\boldsymbol{n})v ds \\!-\\! \\int_{\\partial \\Omega}\\! u_h (\\nabla v\\!\\cdot\\!\\boldsymbol{n}) ds \\!+\\! \\frac{\\beta}{h}\\! \\int_{\\partial \\Omega} \\!u_h v ds}_{a_h(u_h,v)} = \\underbrace{-\\!\\int_{\\partial \\Omega}\\! g (\\nabla v\\!\\cdot\\!\\boldsymbol{n}) ds \\!+\\! \\frac{\\beta}{h}\\! \\int_{\\partial \\Omega}\\! g v ds}_{L_h(v;g)} $$\n双线性形式 $a_h(u, v)$ 与 $g$ 无关。线性形式 $L_h(v; g)$ 关于 $g$ 是线性的，因为积分是线性的：\n$L_h(v; g_1+g_2) = -\\int_{\\partial \\Omega} (g_1+g_2)(\\nabla v\\cdot \\boldsymbol{n})ds + \\frac{\\beta}{h}\\int_{\\partial \\Omega} (g_1+g_2)v ds = L_h(v;g_1) + L_h(v;g_2)$。\n叠加原理的论证与罚方法相同。问题的结构是 $a_h(u_h,v)=L_h(v;g)$，其中 $a_h$ 是双线性的，而 $L_h$ 关于 $g$ 是线性的。由于 $a_h$ 在其第一个变元上的线性性以及 $L_h$ 关于 $g$ 的线性性，离散解映射 $g \\mapsto u_h(g)$ 是线性的。因此，在离散情况下叠加性得以保持。\n\n**第4部分：叠加解的求值**\n\n我们需要计算精确的叠加解 $u(x,y) = u_1(x,y) + u_2(x,y)$ 在点 $(x,y) = (\\frac{1}{2}, \\frac{1}{3})$ 处的值。\n解为：\n$$ u(x,y) = \\sinh(\\pi x)\\sin(\\pi y) + \\sinh(2\\pi x)\\sin(2\\pi y) $$\n代入坐标 $x = \\frac{1}{2}$ 和 $y = \\frac{1}{3}$：\n$$ u\\left(\\frac{1}{2}, \\frac{1}{3}\\right) = \\sinh\\left(\\pi \\cdot \\frac{1}{2}\\right)\\sin\\left(\\pi \\cdot \\frac{1}{3}\\right) + \\sinh\\left(2\\pi \\cdot \\frac{1}{2}\\right)\\sin\\left(2\\pi \\cdot \\frac{1}{3}\\right) $$\n$$ u\\left(\\frac{1}{2}, \\frac{1}{3}\\right) = \\sinh\\left(\\frac{\\pi}{2}\\right)\\sin\\left(\\frac{\\pi}{3}\\right) + \\sinh(\\pi)\\sin\\left(\\frac{2\\pi}{3}\\right) $$\n三角函数的精确值为：\n$$ \\sin\\left(\\frac{\\pi}{3}\\right) = \\frac{\\sqrt{3}}{2} $$\n$$ \\sin\\left(\\frac{2\\pi}{3}\\right) = \\sin\\left(\\pi - \\frac{\\pi}{3}\\right) = \\sin\\left(\\frac{\\pi}{3}\\right) = \\frac{\\sqrt{3}}{2} $$\n将这些值代回表达式中：\n$$ u\\left(\\frac{1}{2}, \\frac{1}{3}\\right) = \\sinh\\left(\\frac{\\pi}{2}\\right) \\cdot \\frac{\\sqrt{3}}{2} + \\sinh(\\pi) \\cdot \\frac{\\sqrt{3}}{2} $$\n提取公因式 $\\frac{\\sqrt{3}}{2}$ 得到最终的闭式解析表达式：\n$$ u\\left(\\frac{1}{2}, \\frac{1}{3}\\right) = \\frac{\\sqrt{3}}{2} \\left( \\sinh\\left(\\frac{\\pi}{2}\\right) + \\sinh(\\pi) \\right) $$",
            "answer": "$$\n\\boxed{\\frac{\\sqrt{3}}{2}\\left(\\sinh\\left(\\frac{\\pi}{2}\\right) + \\sinh(\\pi)\\right)}\n$$"
        },
        {
            "introduction": "到目前为止，我们已经看到叠加原理在线性问题中成立。但它在何处会失效？这最后一个实践将探讨一个更微妙且高度贴近实际的场景 。我们将研究一个用间断伽辽金 (DG) 方法求解的*线性*平流方程，其中非线性并非源于偏微分方程本身，而是由一个为保证稳定性而设计的数值部件——斜率限制器——引入的。这项高级练习表明，即使底层物理模型是线性的，数值格式本身也可能违背叠加原理。通过实现并量化这种违背，您将对现代高分辨率数值方法的属性建立起批判性的理解，并认识到离散系统的行为可能比它所要解决的连续偏微分方程更为复杂。",
            "id": "3434972",
            "problem": "考虑在周期性空间域 $x \\in [0,1]$ 上，具有恒定平流速度 $a0$ 的线性平流偏微分方程 (PDE) $u_t + a\\,u_x = 0$。使用分片1次多项式（记为 $P^1$）的间断Galerkin方法，在包含 $N$ 个单元的均匀网格上，通过每个单元上的局部勒让德基来表示函数 $u(x)$。对于中心为 $x_i$、宽度为 $h=1/N$ 的单元索引 $i$，局部坐标 $\\xi \\in [-1,1]$ 由 $x = x_i + \\tfrac{h}{2}\\,\\xi$ 定义，其局部表示为 $u_i(\\xi) = a_{0,i}\\,P_0(\\xi) + a_{1,i}\\,P_1(\\xi)$，其中 $P_0(\\xi) = 1$ 且 $P_1(\\xi) = \\xi$。光滑函数 $f(x)$ 在此 $P^1$ 空间上的 $L^2$ 投影，其系数由勒让德多项式的正交关系给出：\n$$\na_{0,i} = \\frac{1}{2}\\int_{-1}^{1} f\\!\\left(x_i + \\frac{h}{2}\\xi\\right)\\,d\\xi,\\qquad\na_{1,i} = \\frac{3}{2}\\int_{-1}^{1} f\\!\\left(x_i + \\frac{h}{2}\\xi\\right)\\,\\xi\\,d\\xi.\n$$\n为了防止伪振荡，对系数 $a_{1,i}$ 应用了斜率限制器。定义相邻单元平均值之差\n$$\n\\Delta_{i-\\frac{1}{2}} = a_{0,i} - a_{0,i-1},\\qquad \\Delta_{i+\\frac{1}{2}} = a_{0,i+1} - a_{0,i},\n$$\n索引采用周期性。设 $T = M h^2$ 为总变差有界 (TVB) 阈值，其中参数 $M0$。TVB修正的minmod限制器将 $a_{1,i}$ 替换为\n$$\n\\tilde{a}_{1,i} = \n\\begin{cases}\n\\operatorname{minmod}\\!\\left(a_{1,i},\\,\\Delta_{i-\\frac{1}{2}},\\,\\Delta_{i+\\frac{1}{2}}\\right),  \\text{如果 } \\left(|\\Delta_{i-\\frac{1}{2}}|T\\right)\\ \\text{且}\\ \\left(|\\Delta_{i+\\frac{1}{2}}|T\\right),\\\\\na_{1,i},  \\text{其他情况,}\n\\end{cases}\n$$\n其中\n$$\n\\operatorname{minmod}(z_1,z_2,z_3) =\n\\begin{cases}\n\\operatorname{sign}(z_1)\\,\\min\\{|z_1|,|z_2|,|z_3|\\},  \\text{如果 } \\operatorname{sign}(z_1)=\\operatorname{sign}(z_2)=\\operatorname{sign}(z_3),\\\\\n0,  \\text{其他情况。}\n\\end{cases}\n$$\n这定义了一个非线性映射 $S:f\\mapsto u^{\\text{DG}}$，其中 $u^{\\text{DG}}$ 是由 $\\{a_{0,i},\\tilde{a}_{1,i}\\}_{i=0}^{N-1}$ 决定的受限 $P^1$ 表示。\n\n对于线性算子，叠加原理要求对所有输入都满足 $S(f_1 + f_2) = S(f_1) + S(f_2)$。在本问题中，您将展示并量化仅由斜率限制器（不对 $u_t + a\\,u_x = 0$ 进行任何时间步进）引入的对叠加原理的违背。您将：\n\n- 实现投影公式，从给定的 $f(x)$ 计算 $\\{a_{0,i}, a_{1,i}\\}$。\n- 应用TVB修正的minmod限制器，为每个单元获得 $\\tilde{a}_{1,i}$。\n- 对于光滑输入 $f_1(x)$ 和 $f_2(x)$，构造 $S(f_1)$、 $S(f_2)$ 和 $S(f_1+f_2)$，并验证限制器是否仅对 $S(f_1+f_2)$ 触发。\n- 通过计算差值 $S(f_1)+S(f_2)-S(f_1+f_2)$ 的全局 $L^2$ 范数，并用 $S(f_1)+S(f_2)$ 的全局 $L^2$ 范数对其进行缩放，来量化叠加违背：\n$$\n\\mathcal{V} = \\frac{\\left\\|S(f_1)+S(f_2)-S(f_1+f_2)\\right\\|_{L^2([0,1])}}{\\left\\|S(f_1)+S(f_2)\\right\\|_{L^2([0,1])}},\n$$\n约定如果分母为0，则 $\\mathcal{V}=0$。使用局部勒让德基，在单个单元上系数为 $(b_{0},b_{1})$ 的表示的 $L^2$ 范数平方为 $h\\left(b_{0}^2 + \\frac{1}{3}b_{1}^2\\right)$，全局范数平方是所有单元上范数平方的总和。\n\n使用具有指定参数的光滑三角函数输入：\n$$\nf_k(x) = A_k \\sin\\!\\left(2\\pi m_k x + \\phi_k\\right),\\qquad k\\in\\{1,2\\},\n$$\n其中 $A_k0$ 是振幅，$m_k\\in\\mathbb{N}$ 是空间模数，$\\phi_k$ 是相位。角度 $\\phi_k$ 必须以弧度解释。\n\n测试套件。实现您的程序以评估以下三个测试案例，每个案例由元组 $(N,M,A_1,m_1,\\phi_1,A_2,m_2,\\phi_2)$ 定义：\n\n- 案例 1（设计为限制器仅对 $f_1+f_2$ 触发）：$(N,M,A_1,m_1,\\phi_1,A_2,m_2,\\phi_2) = (100,150,0.02,6,0.0,0.015,9,0.0)$。\n- 案例 2（边界案例，对任何输入均不触发限制器）：$(N,M,A_1,m_1,\\phi_1,A_2,m_2,\\phi_2) = (100,1000,0.005,4,0.3,0.004,5,1.2)$。\n- 案例 3（边缘案例，限制器对 $f_1$、$f_2$ 以及 $f_1+f_2$ 均触发）：$(N,M,A_1,m_1,\\phi_1,A_2,m_2,\\phi_2) = (100,50,0.04,12,0.0,0.03,10,0.5)$。\n\n对于每个案例，计算并返回四个量：\n- $n_1$：对 $S(f_1)$，限制器修改了 $a_{1,i}$ 的单元数量，\n- $n_2$：对 $S(f_2)$，限制器修改了 $a_{1,i}$ 的单元数量，\n- $n_{12}$：对 $S(f_1+f_2)$，限制器修改了 $a_{1,i}$ 的单元数量，\n- $\\mathcal{V}$：如上定义的叠加违背度量。\n\n最终输出格式。您的程序应生成单行输出，其中包含三个案例的结果，格式为方括号内以逗号分隔的列表，首先是案例1的四个量，然后是案例2的四个量，最后是案例3的四个量。例如，输出格式必须与 $[n_1^{(1)},n_2^{(1)},n_{12}^{(1)},\\mathcal{V}^{(1)},n_1^{(2)},n_2^{(2)},n_{12}^{(2)},\\mathcal{V}^{(2)},n_1^{(3)},n_2^{(3)},n_{12}^{(3)},\\mathcal{V}^{(3)}]$ 完全一样，其中所有数字都应打印，角度以弧度为单位。",
            "solution": "该问题要求分析在间断Galerkin (DG) 方法中使用的非线性斜率限制器对叠加原理的违背情况。我们得到了一个映射 $S$ 的定义，该映射将函数 $f(x)$ 转换为应用了 TVB 修正的 minmod 斜率限制器的 DG 表示。我们必须计算函数 $f_1$、$f_2$ 及其和 $f_1+f_2$ 中限制器被激活的单元数量，并量化叠加违背 $\\mathcal{V} = \\|S(f_1)+S(f_2)-S(f_1+f_2)\\|_{L^2} / \\|S(f_1)+S(f_2)\\|_{L^2}$。\n\n该过程包括三个主要步骤：\n1.  将给定函数 $f(x)$ 投影到 $P^1$ DG 空间以求得系数 $\\{a_{0,i}, a_{1,i}\\}$。\n2.  将非线性的 TVB 修正的 minmod 限制器应用于斜率系数 $\\{a_{1,i}\\}$ 以获得受限系数 $\\{\\tilde{a}_{1,i}\\}$。\n3.  使用 DG 表示的属性和给定的 $L^2$ 范数定义来计算所需的量（$n_1, n_2, n_{12}, \\mathcal{V}$）。\n\n**第1步：输入函数的解析投影**\n\n输入函数的形式为 $f(x) = A \\sin(2\\pi m x + \\phi)$。第 $i$ 个单元的系数 $a_{0,i}$ 和 $a_{1,i}$ 通过在局部域 $\\xi \\in [-1,1]$ 上对勒让德基函数 $P_0(\\xi)=1$ 和 $P_1(\\xi)=\\xi$ 进行积分来求得。坐标变换为 $x = x_i + \\frac{h}{2}\\xi$，其中 $x_i = (i+0.5)h$ 是单元中心，$h=1/N$ 是单元宽度。\n\n对于 $a_{0,i}$：\n$$\na_{0,i} = \\frac{1}{2}\\int_{-1}^{1} A \\sin\\!\\left(2\\pi m \\left(x_i + \\frac{h}{2}\\xi\\right) + \\phi\\right) d\\xi\n$$\n令 $\\theta_i = 2\\pi m x_i + \\phi$ 和 $k = \\pi m h$。积变为：\n$$\na_{0,i} = \\frac{A}{2} \\int_{-1}^{1} \\sin(\\theta_i + k\\xi) d\\xi = \\frac{A}{2} \\left[-\\frac{\\cos(\\theta_i + k\\xi)}{k}\\right]_{-1}^{1} = \\frac{A}{2k} (\\cos(\\theta_i - k) - \\cos(\\theta_i + k))\n$$\n使用恒等式 $\\cos(B) - \\cos(A) = 2\\sin(\\frac{A+B}{2})\\sin(\\frac{A-B}{2})$，我们得到：\n$$\na_{0,i} = A \\frac{\\sin(k)}{k} \\sin(\\theta_i) = A \\frac{\\sin(\\pi m h)}{\\pi m h} \\sin(2\\pi m x_i + \\phi)\n$$\n\n对于 $a_{1,i}$：\n$$\na_{1,i} = \\frac{3}{2}\\int_{-1}^{1} A \\sin\\!\\left(2\\pi m \\left(x_i + \\frac{h}{2}\\xi\\right) + \\phi\\right) \\xi\\,d\\xi\n$$\n积分为 $\\int_{-1}^1 \\xi \\sin(\\theta_i + k\\xi) d\\xi$。使用分部积分法，我们发现：\n$$\n\\int_{-1}^{1} \\xi \\sin(\\theta_i + k\\xi) d\\xi = \\left[-\\frac{\\xi}{k}\\cos(\\theta_i + k\\xi) + \\frac{1}{k^2}\\sin(\\theta_i + k\\xi)\\right]_{-1}^{1} = 2\\cos(\\theta_i)\\left(\\frac{\\sin k - k\\cos k}{k^2}\\right)\n$$\n因此，系数 $a_{1,i}$ 是：\n$$\na_{1,i} = 3A \\cos(2\\pi m x_i + \\phi) \\frac{\\sin(\\pi m h) - \\pi m h \\cos(\\pi m h)}{(\\pi m h)^2}\n$$\n这些解析公式可以在不进行数值积分的情况下，精确而高效地计算系数。注意，由于 $m \\in \\mathbb{N}$（即 $m \\ge 1$），对于 $h0$，分母 $\\pi m h$ 非零。\n\n**第2步：应用 TVB 修正的 Minmod 限制器**\n\n限制器根据相邻单元的单元平均值修改斜率系数 $a_{1,i}$。首先，我们计算单元平均值的差：\n$\\Delta_{i-\\frac{1}{2}} = a_{0,i} - a_{0,i-1}$ 和 $\\Delta_{i+\\frac{1}{2}} = a_{0,i+1} - a_{0,i}$。周期性通过环绕索引来处理（例如，对于 $i=0$，“左”邻居 $i-1$ 是 $N-1$）。\n\nTVB 阈值为 $T = M h^2$。只有当局部变化足够大时，即 $|\\Delta_{i-\\frac{1}{2}}|  T$ 且 $|\\Delta_{i+\\frac{1}{2}}|  T$ 时，限制器才“激活”。如果满足此条件，$a_{1,i}$ 将被替换为 $\\tilde{a}_{1,i} = \\operatorname{minmod}(a_{1,i}, \\Delta_{i-\\frac{1}{2}}, \\Delta_{i+\\frac{1}{2}})$。否则，$\\tilde{a}_{1,i} = a_{1,i}$。\n\nminmod 函数定义为：\n$$\n\\operatorname{minmod}(z_1,z_2,z_3) =\n\\begin{cases}\n\\operatorname{sign}(z_1)\\,\\min\\{|z_1|,|z_2|,|z_3|\\},  \\text{如果 } \\operatorname{sign}(z_1)=\\operatorname{sign}(z_2)=\\operatorname{sign}(z_3),\\\\\n0,  \\text{其他情况。}\n\\end{cases}\n$$\n该函数本质上是非线性的。对于给定函数，受限单元的数量 $n$ 是满足 $\\tilde{a}_{1,i} \\neq a_{1,i}$ 的索引 $i$ 的计数。\n\n**第3步：计算叠加违背**\n\n问题的核心是分析算子 $S: f \\mapsto u^{\\text{DG}}$，其中 $u^{\\text{DG}}$ 由系数 $\\{a_{0,i}, \\tilde{a}_{1,i}\\}$ 定义。投影步骤（求 $a_{0,i}, a_{1,i}$）是线性的。因此，对于 $f_{1+2} = f_1 + f_2$，初始系数为 $a_{0,i}^{(1+2)} = a_{0,i}^{(1)} + a_{0,i}^{(2)}$ 和 $a_{1,i}^{(1+2)} = a_{1,i}^{(1)} + a_{1,i}^{(2)}$。非线性完全源于限制器。\n\n叠加违背 $\\mathcal{V}$ 是两个 $L^2$ 范数之比。让我们分析各项：\n-   $S(f_1)$ 是系数为 $\\{a_{0,i}^{(1)}, \\tilde{a}_{1,i}^{(1)}\\}$ 的 DG 函数。\n-   $S(f_2)$ 是系数为 $\\{a_{0,i}^{(2)}, \\tilde{a}_{1,i}^{(2)}\\}$ 的 DG 函数。\n-   $S(f_1) + S(f_2)$ 是这两个函数的和。其系数为 $\\{a_{0,i}^{(1)} + a_{0,i}^{(2)}, \\tilde{a}_{1,i}^{(1)} + \\tilde{a}_{1,i}^{(2)}\\}$。\n-   $S(f_1+f_2)$ 通过首先求出 $f_1+f_2$ 的系数 $\\{a_{0,i}^{(1)} + a_{0,i}^{(2)}, a_{1,i}^{(1)} + a_{1,i}^{(2)}\\}$，然后应用限制器得到 $\\{a_{0,i}^{(1)} + a_{0,i}^{(2)}, \\tilde{a}_{1,i}^{(1+2)}\\}$。\n\n差函数 $D = S(f_1)+S(f_2)-S(f_1+f_2)$ 的系数为：\n    $d_{0,i} = (a_{0,i}^{(1)} + a_{0,i}^{(2)}) - (a_{0,i}^{(1)} + a_{0,i}^{(2)}) = 0$。\n    $d_{1,i} = (\\tilde{a}_{1,i}^{(1)} + \\tilde{a}_{1,i}^{(2)}) - \\tilde{a}_{1,i}^{(1+2)}$。\n$D$ 的范数平方（$\\mathcal{V}$ 的分子）由下式给出：\n$$\n\\|D\\|_{L^2}^2 = \\sum_{i=0}^{N-1} h\\left(d_{0,i}^2 + \\frac{1}{3}d_{1,i}^2\\right) = \\frac{h}{3} \\sum_{i=0}^{N-1} \\left( (\\tilde{a}_{1,i}^{(1)} + \\tilde{a}_{1,i}^{(2)}) - \\tilde{a}_{1,i}^{(1+2)} \\right)^2\n$$\n和函数 $S(f_1)+S(f_2)$ 的范数平方（$\\mathcal{V}$ 的分母）为：\n$$\n\\|S(f_1)+S(f_2)\\|_{L^2}^2 = \\sum_{i=0}^{N-1} h\\left( (a_{0,i}^{(1)} + a_{0,i}^{(2)})^2 + \\frac{1}{3}(\\tilde{a}_{1,i}^{(1)} + \\tilde{a}_{1,i}^{(2)})^2 \\right)\n$$\n违背度量 $\\mathcal{V}$ 是这两个量之比的平方根。对于每个测试案例，我们遵循此程序计算 $n_1$（对于 $f_1$），$n_2$（对于 $f_2$），$n_{12}$（对于 $f_1+f_2$）和 $\\mathcal{V}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # (N, M, A1, m1, phi1, A2, m2, phi2)\n        (100, 150, 0.02, 6, 0.0, 0.015, 9, 0.0),\n        (100, 1000, 0.005, 4, 0.3, 0.004, 5, 1.2),\n        (100, 50, 0.04, 12, 0.0, 0.03, 10, 0.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, A1, m1, phi1, A2, m2, phi2 = case\n\n        # Project f1 and f2 onto the P1 space\n        a0_1, a1_1 = project_sinusoid(A1, m1, phi1, N)\n        a0_2, a1_2 = project_sinusoid(A2, m2, phi2, N)\n\n        # Apply limiter to f1 and f2\n        a1_tilde_1, n1 = apply_limiter(a0_1, a1_1, N, M)\n        a1_tilde_2, n2 = apply_limiter(a0_2, a1_2, N, M)\n\n        # Coefficients for f1+f2 are the sum of coefficients (linearity of projection)\n        a0_12 = a0_1 + a0_2\n        a1_12 = a1_1 + a1_2\n\n        # Apply limiter to f1+f2\n        a1_tilde_12, n12 = apply_limiter(a0_12, a1_12, N, M)\n\n        # Calculate superposition violation V\n        h = 1.0 / N\n        \n        # Numerator calculation\n        # Coefficients of the difference function D = S(f1)+S(f2)-S(f1+f2)\n        d1 = (a1_tilde_1 + a1_tilde_2) - a1_tilde_12\n        # d0 is zero due to linearity of projection for cell averages\n        num_norm_sq = (h / 3.0) * np.sum(d1**2)\n\n        # Denominator calculation\n        # Coefficients of the sum function S(f1)+S(f2)\n        b0 = a0_1 + a0_2\n        b1 = a1_tilde_1 + a1_tilde_2\n        den_norm_sq = h * np.sum(b0**2 + (1.0 / 3.0) * b1**2)\n\n        if den_norm_sq == 0:\n            V = 0.0\n        else:\n            V = np.sqrt(num_norm_sq / den_norm_sq)\n\n        results.extend([n1, n2, n12, V])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef project_sinusoid(A, m, phi, N):\n    \"\"\"\n    Computes the DG-P1 coefficients a0 and a1 for a function f(x) = A*sin(2*pi*m*x + phi).\n    \n    Args:\n        A (float): Amplitude.\n        m (int): Spatial mode number.\n        phi (float): Phase in radians.\n        N (int): Number of cells.\n        \n    Returns:\n        tuple: (a0, a1) numpy arrays of coefficients.\n    \"\"\"\n    h = 1.0 / N\n    x_i = (np.arange(N) + 0.5) * h\n    \n    # Use analytical formulas for the projection integrals\n    theta_i = 2.0 * np.pi * m * x_i + phi\n    k = np.pi * m * h\n\n    if k == 0: # Note: problem states m is in N, so m>=1, k>0. This is just for safety.\n        a0 = A * np.sin(phi) * np.ones(N)\n        a1 = np.zeros(N)\n        return a0, a1\n\n    sinc_k = np.sin(k) / k\n    a0 = A * sinc_k * np.sin(theta_i)\n\n    # Factor for a1: 3 * (sin(k) - k*cos(k)) / k^2\n    factor_a1 = 3.0 * (np.sin(k) - k * np.cos(k)) / (k**2)\n    a1 = A * factor_a1 * np.cos(theta_i)\n\n    return a0, a1\n\ndef minmod_vec(z1, z2, z3):\n    \"\"\"\n    Vectorized implementation of the minmod function for three arguments.\n    \"\"\"\n    s1, s2, s3 = np.sign(z1), np.sign(z2), np.sign(z3)\n    mask = (s1 == s2)  (s2 == s3)\n    \n    result = np.zeros_like(z1, dtype=np.float64)\n    \n    z_stack = np.stack([np.abs(z1), np.abs(z2), np.abs(z3)], axis=0)\n    min_abs = np.min(z_stack, axis=0)\n    \n    result[mask] = s1[mask] * min_abs[mask]\n    return result\n\ndef apply_limiter(a0, a1, N, M):\n    \"\"\"\n    Applies the TVB-modified minmod limiter to the slope coefficients a1.\n    \n    Args:\n        a0 (np.ndarray): Cell average coefficients.\n        a1 (np.ndarray): Original slope coefficients.\n        N (int): Number of cells.\n        M (float): TVB parameter.\n    \n    Returns:\n        tuple: (a1_tilde, n_limited)\n               a1_tilde: The limited slope coefficients.\n               n_limited: The number of cells where limiting was applied.\n    \"\"\"\n    h = 1.0 / N\n    T = M * h**2\n\n    # Calculate neighbor differences with periodic boundaries\n    a0_im1 = np.roll(a0, 1)  # a0_{i-1}\n    a0_ip1 = np.roll(a0, -1) # a0_{i+1}\n    \n    delta_imhalf = a0 - a0_im1\n    delta_iphalf = a0_ip1 - a0\n\n    # Apply TVB condition to find which cells to limit\n    limit_mask = (np.abs(delta_imhalf) > T)  (np.abs(delta_iphalf) > T)\n    \n    # Initialize modified slopes as the original ones\n    a1_tilde = np.copy(a1)\n    \n    # Apply minmod only where the TVB condition is met\n    if np.any(limit_mask):\n        a1_to_limit = a1[limit_mask]\n        delta_imhalf_to_limit = delta_imhalf[limit_mask]\n        delta_iphalf_to_limit = delta_iphalf[limit_mask]\n\n        limited_slopes = minmod_vec(a1_to_limit, delta_imhalf_to_limit, delta_iphalf_to_limit)\n        a1_tilde[limit_mask] = limited_slopes\n\n    # Count number of limited cells\n    n_limited = np.sum(a1_tilde != a1)\n    \n    return a1_tilde, n_limited\n\nsolve()\n```"
        }
    ]
}