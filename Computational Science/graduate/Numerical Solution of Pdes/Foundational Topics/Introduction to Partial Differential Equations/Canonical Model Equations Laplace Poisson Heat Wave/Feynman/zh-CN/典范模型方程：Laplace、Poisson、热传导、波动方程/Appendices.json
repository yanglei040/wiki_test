{
    "hands_on_practices": [
        {
            "introduction": "接下来，我们将注意力转向作为椭圆型偏微分方程基石的泊松方程。实际问题通常带有复杂的非零边界条件，这给求解带来了挑战。本练习  介绍了一种名为“提升函数”的巧妙技巧，它能将一个具有非齐次边界条件的问题转化为一个更简单的、具有齐次边界条件的问题，而这正是许多高级求解算法的必要前置步骤。",
            "id": "3367912",
            "problem": "考虑单位正方形区域 $\\Omega = (0,1) \\times (0,1)$ 上具有非齐次狄利克雷边界数据的泊松方程：\n$$\n-\\Delta u = f \\quad \\text{in } \\Omega, \\qquad u = g \\quad \\text{on } \\partial \\Omega,\n$$\n其中 $f(x,y) = x + y^{2}$ 且 $g(x,y) = x^{2} + y$。请勿调用任何预封装的边界简化公式，从拉普拉斯算子的线性性质和弱导数的定义出发，通过构造一个与边界值匹配的显式提升函数 $\\ell$，并定义一个具有齐次狄利克雷边界条件的新未知数 $v$，来消除非齐次狄利克雷边界条件。推导 $v$ 在 $\\Omega$ 中满足的强形式方程，并计算修正后的右端项，使其成为 $x$ 和 $y$ 的一个显式解析函数。你的最终答案必须是修正后右端项的单一解析表达式（无需单位；无需四舍五入）。",
            "solution": "该问题是有效的。这是一个良定的数学问题，其基础是偏微分方程理论，具体涉及对泊松方程的非齐次狄利克雷边界条件进行齐次化的标准技术。所有必要的数据和定义都已提供，不存在内部矛盾或科学不准确之处。\n\n该问题要求我们将给定的带有非齐次狄利克雷边界条件的泊松方程，转换为一个具有齐次狄利克雷边界条件的等价问题。原始问题是：\n$$\n-\\Delta u = f \\quad \\text{in } \\Omega = (0,1) \\times (0,1)\n$$\n$$\nu = g \\quad \\text{on } \\partial \\Omega\n$$\n其中源项为 $f(x,y) = x + y^{2}$，边界数据为 $g(x,y) = x^{2} + y$。\n\n该方法涉及将解 $u(x,y)$ 分解为两个函数的和：\n$$\nu(x,y) = v(x,y) + \\ell(x,y)\n$$\n在这里，$\\ell(x,y)$ 是我们必须构造的“提升函数”，而 $v(x,y)$ 是新的未知函数。目标是定义 $v$ 和 $\\ell$，使得关于 $v$ 的问题具有齐次狄利克雷边界条件。\n\n我们在边界 $\\partial\\Omega$ 上施加条件 $v=0$。在边界上计算该分解，我们得到：\n$$\nu|_{\\partial\\Omega} = v|_{\\partial\\Omega} + \\ell|_{\\partial\\Omega}\n$$\n代入已知的边界条件 $u|_{\\partial\\Omega} = g$ 和我们期望的条件 $v|_{\\partial\\Omega} = 0$，我们得到提升函数 $\\ell$ 的必要条件：\n$$\ng = 0 + \\ell|_{\\partial\\Omega} \\implies \\ell(x,y) = g(x,y) \\quad \\text{for } (x,y) \\in \\partial\\Omega\n$$\n我们需要构造一个定义在整个区域 $\\Omega$ 上、足够光滑并在边界 $\\partial\\Omega$ 上与边界数据 $g(x,y) = x^{2} + y$ 相匹配的函数 $\\ell(x,y)$。存在无限多个这样的函数。问题要求进行显式构造。最简单的选择是将函数 $g(x,y)$ 本身扩展到整个区域。我们定义提升函数为：\n$$\n\\ell(x,y) = x^{2} + y\n$$\n这个函数是一个多项式，因此在 $\\Omega$ 上是无限可微的（即 $C^{\\infty}$）。根据其定义，它在边界 $\\partial\\Omega$ 上与 $g(x,y)$ 相匹配。\n\n现在，我们推导 $v$ 的强形式方程。我们将分解式 $u = v + \\ell$ 代入原始的泊松方程中：\n$$\n-\\Delta(v + \\ell) = f\n$$\n拉普拉斯算子 $\\Delta = \\frac{\\partial^{2}}{\\partial x^{2}} + \\frac{\\partial^{2}}{\\partial y^{2}}$ 是一个线性算子。因此，我们可以将其分配到和上：\n$$\n-(\\Delta v + \\Delta \\ell) = f\n$$\n$$\n-\\Delta v - \\Delta \\ell = f\n$$\n重新整理此方程以分离出包含新未知数 $v$ 的项，我们得到 $v$ 的泊松方程：\n$$\n-\\Delta v = f + \\Delta \\ell\n$$\n这个关于 $v$ 的新方程定义在相同的区域 $\\Omega$ 上，但现在它与齐次狄利克雷边界条件 $v=0$ on $\\partial\\Omega$ 相配对。\n\n任务是找到修正后的右端项，我们可以将其表示为 $f_{\\text{mod}}$。它由下式给出：\n$$\nf_{\\text{mod}}(x,y) = f(x,y) + \\Delta \\ell(x,y)\n$$\n我们需要计算我们所选择的提升函数 $\\ell$ 的拉普拉斯算子 $\\Delta \\ell$。\n已知 $\\ell(x,y) = x^{2} + y$，我们求其二阶偏导数：\n一阶偏导数为：\n$$\n\\frac{\\partial \\ell}{\\partial x} = \\frac{\\partial}{\\partial x}(x^{2} + y) = 2x\n$$\n$$\n\\frac{\\partial \\ell}{\\partial y} = \\frac{\\partial}{\\partial y}(x^{2} + y) = 1\n$$\n二阶偏导数为：\n$$\n\\frac{\\partial^{2} \\ell}{\\partial x^{2}} = \\frac{\\partial}{\\partial x}(2x) = 2\n$$\n$$\n\\frac{\\partial^{2} \\ell}{\\partial y^{2}} = \\frac{\\partial}{\\partial y}(1) = 0\n$$\n$\\ell$ 的拉普拉斯算子是这些二阶纯偏导数之和：\n$$\n\\Delta \\ell = \\frac{\\partial^{2} \\ell}{\\partial x^{2}} + \\frac{\\partial^{2} \\ell}{\\partial y^{2}} = 2 + 0 = 2\n$$\n现在我们可以通过代入给定的函数 $f(x,y)$ 和计算出的 $\\Delta \\ell$ 来计算修正后的右端项 $f_{\\text{mod}}(x,y)$：\n$$\nf_{\\text{mod}}(x,y) = (x + y^{2}) + 2\n$$\n$$\nf_{\\text{mod}}(x,y) = x + y^{2} + 2\n$$\n这就是新的关于 $v$ 的泊松方程的修正后右端项的显式解析函数。",
            "answer": "$$\\boxed{x + y^{2} + 2}$$"
        },
        {
            "introduction": "最后，我们从解析技巧转向完整的数值实现。本练习  探索泊松方程的混合公式，其中主要变量（如压力）及其通量被视为独立的未知数。这种方法的巨大优势在于它能确保通量的局部（单元级）守恒，这在许多物理和工程应用中是至关重要的特性。这个编程练习将指导你构建一个基于此物理原理的数值求解器。",
            "id": "3367898",
            "problem": "考虑有界 Lipschitz 域 $\\Omega \\subset \\mathbb{R}^2$ 上的典范泊松方程，其单位外法向量为 $\\boldsymbol{n}$。通过引入通量 $\\boldsymbol{\\sigma} = -\\nabla u$（其中 $u$ 被解释为压力），该方程可写成混合形式：\n$$\n\\boldsymbol{\\sigma} + \\nabla u = \\boldsymbol{0} \\quad \\text{在 } \\Omega \\text{ 内}, \\qquad \\nabla \\cdot \\boldsymbol{\\sigma} = f \\quad \\text{在 } \\Omega \\text{ 内},\n$$\n附带诺伊曼边界条件\n$$\n\\boldsymbol{\\sigma} \\cdot \\boldsymbol{n} = g \\quad \\text{在 } \\partial \\Omega \\text{ 上}.\n$$\n假设全局相容性条件 $\\int_{\\Omega} f\\, \\mathrm{d}\\boldsymbol{x} = \\int_{\\partial \\Omega} g\\, \\mathrm{d}s$ 成立，并通过将压力的平均值设为零来消除零空间模糊性。混合弱形式旨在求解 $\\boldsymbol{\\sigma} \\in H(\\mathrm{div};\\Omega)$ 和 $u \\in L^2(\\Omega)$，以确保在每个单元上强制执行局部守恒。\n\n您的任务是：\n- 从 Sobolev 空间 $H(\\mathrm{div};\\Omega)$、散度算子和泊松方程混合形式的基本定义出发。\n- 在单位正方形域 $\\Omega = [0,1]^2$ 的 $N_x \\times N_y$ 矩形笛卡尔划分上，设计 $H(\\mathrm{div})$-协调的最低阶 Raviart–Thomas 元（也称为 $\\mathrm{RT}_0$），其中 $H(\\mathrm{div})$ 协调性要求法向通量在单元间交界面上是连续的。\n- 推导一个离散格式，该格式在每个单元上强制执行通量的精确局部守恒，表示为通过单元面的向外法向通量之和与源项 $f$ 在该单元上的积分相等，并满足边界上的诺伊曼边界规定 $\\boldsymbol{\\sigma}\\cdot \\boldsymbol{n} = g$。\n- 在正交均匀笛卡尔网格上实现此格式，用于各向同性单位传导率的情况。该格式简化为一种以单元为中心的二点通量近似，与在此类网格上的混合 $\\mathrm{RT}_0$ 方法一致。\n- 通过代数约束对 $u$ 强制施加零均值条件，以确保解的唯一性。\n\n程序要求：\n- 为单位正方形 $\\Omega = [0,1]^2$ 实现所述方法，使用均匀间距 $\\Delta x = 1/N_x$，$\\Delta y = 1/N_y$。\n- 使用中点求积来近似 $\\int_{\\text{cell}} f\\,\\mathrm{d}\\boldsymbol{x}$，并对边界通量贡献 $\\int_{\\text{face}} g\\,\\mathrm{d}s$ 使用精确的边长缩放，即通过在面中点处计算的 $g$ 值乘以面长。\n- 组装一个关于单元压力的对称线性系统，并附加一个拉格朗日乘子来强制执行零均值压力约束，求解该系统，然后计算由以下公式绝对值定义的逐单元净通量不平衡：\n$$\n\\left(\\sum_{\\text{单元的面}} \\text{向外通量}\\right) - \\left(\\int_{\\text{单元}} f\\,\\mathrm{d}\\boldsymbol{x}\\right).\n$$\n\n测试套件：\n对于以下每组参数，构建网格、源项 $f$ 和边界通量 $g$，计算解，并报告所有单元中局部守恒残差的最大绝对值，结果为浮点数。\n\n- 测试用例 1（具有非平凡边界通量的常规情况）：\n  - 网格: $N_x = N_y = 8$。\n  - 源项: $f(x,y) = 0$。\n  - 源于线性压力 $u(x,y) = x + y$ 的边界通量，其产生的通量为 $\\boldsymbol{\\sigma} = -\\nabla u = (-1,-1)$：\n    - 左边界 ($x=0$): $g = 1$。\n    - 右边界 ($x=1$): $g = -1$。\n    - 下边界 ($y=0$): $g = 1$。\n    - 上边界 ($y=1$): $g = -1$。\n- 测试用例 2（与均匀边界通量一致的恒定源项）：\n  - 网格: $N_x = N_y = 16$。\n  - 源项: 对所有 $(x,y)$，$f(x,y) = 1$。\n  - 边界通量: 在所有边界上为常数 $g = 0.25$，满足 $\\int_{\\Omega} f\\,\\mathrm{d}\\boldsymbol{x} = 1$ 和 $\\int_{\\partial \\Omega} g\\,\\mathrm{d}s = 4 \\times 0.25 = 1$。\n- 测试用例 3（单单元边界情况）：\n  - 网格: $N_x = N_y = 1$。\n  - 源项: 对所有 $(x,y)$，$f(x,y) = 0.5$。\n  - 边界通量: 在所有边界上为常数 $g = 0.125$，满足 $\\int_{\\Omega} f\\,\\mathrm{d}\\boldsymbol{x} = 0.5$ 和 $\\int_{\\partial \\Omega} g\\,\\mathrm{d}s = 4 \\times 0.125 = 0.5$。\n\n最终输出规范：\n- 您的程序应生成包含三个测试用例结果的单行输出，结果为逗号分隔的列表，并用方括号括起来，顺序如上所示，即 $[\\text{residual}_1,\\text{residual}_2,\\text{residual}_3]$。\n- 每个残差必须是浮点数。",
            "solution": "用户希望使用以单元为中心的有限体积法求解混合形式的泊松方程，该方法在均匀笛卡尔网格上等价于最低阶 Raviart-Thomas ($\\mathrm{RT}_0$) 混合有限元法。该解法必须强制执行局部质量守恒，并通过施加零均值压力条件来处理纯诺伊曼问题的零空间。\n\n### 1. 数学公式\n\n控制方程是域 $\\Omega \\subset \\mathbb{R}^2$ 上的混合形式泊松方程：\n$$\n\\boldsymbol{\\sigma} + \\nabla u = \\boldsymbol{0} \\quad \\text{在 } \\Omega \\text{ 内},\n$$\n$$\n\\nabla \\cdot \\boldsymbol{\\sigma} = f \\quad \\text{在 } \\Omega \\text{ 内}.\n$$\n这里，$u$ 是标量势（压力），$\\boldsymbol{\\sigma}$ 是通量矢量，$f$ 是源项。该问题假设单位各向同性传导率，因此 $\\nabla u$ 前的系数为 1。该系统服从诺伊曼边界条件：\n$$\n\\boldsymbol{\\sigma} \\cdot \\boldsymbol{n} = g \\quad \\text{在 } \\partial \\Omega \\text{ 上},\n$$\n其中 $\\boldsymbol{n}$ 是边界 $\\partial \\Omega$ 的单位外法向量。为了使解存在，问题必须满足相容性条件：\n$$\n\\int_{\\Omega} f\\, \\mathrm{d}\\boldsymbol{x} = \\int_{\\partial \\Omega} g\\, \\mathrm{d}s.\n$$\n此条件表明，域内的总源量必须等于穿过其边界的总通量。\n\n### 2. 离散化：以单元为中心的有限体积法\n\n我们将域 $\\Omega = [0,1]^2$ 离散化为 $N_x \\times N_y$ 个矩形单元的网格，单元索引为 $(i,j)$，其中 $i \\in \\{0, \\dots, N_x-1\\}$ 且 $j \\in \\{0, \\dots, N_y-1\\}$。每个单元 $K_{i,j}$ 的尺寸为 $\\Delta x = 1/N_x$ 和 $\\Delta y = 1/N_y$。压力 $u$ 被近似为分片常数函数，在每个单元 $(x_i, y_j)$ 的中心有一个单一值 $u_{i,j}$。\n\n有限体积法的核心原理是在每个单元上局部强制守恒。我们将散度方程 $\\nabla \\cdot \\boldsymbol{\\sigma} = f$ 在一个单元 $K_{i,j}$ 上积分：\n$$\n\\int_{K_{i,j}} \\nabla \\cdot \\boldsymbol{\\sigma} \\, \\mathrm{d}\\boldsymbol{x} = \\int_{K_{i,j}} f \\, \\mathrm{d}\\boldsymbol{x}.\n$$\n对左侧应用散度定理，将体积分转换为单元边界 $\\partial K_{i,j}$ 上的面积分：\n$$\n\\oint_{\\partial K_{i,j}} \\boldsymbol{\\sigma} \\cdot \\boldsymbol{n}_{K} \\, \\mathrm{d}s = \\int_{K_{i,j}} f \\, \\mathrm{d}\\boldsymbol{x},\n$$\n其中 $\\boldsymbol{n}_{K}$ 是单元 $K_{i,j}$ 的外法向量。左侧代表从单元流出的总通量，右侧是单元内的总源量。\n\n通量 $\\boldsymbol{\\sigma}$ 通过 $\\boldsymbol{\\sigma} = -\\nabla u$ 与压力 $u$ 相关。我们使用二点通量近似来估算两个相邻单元之间交界面上的法向通量。例如，穿过单元 $(i,j)$ 和 $(i+1,j)$ 之间垂直面的 x 方向通量密度近似为：\n$$\n\\sigma_x \\approx - \\frac{u_{i+1,j} - u_{i,j}}{\\Delta x}.\n$$\n从单元 $(i,j)$ 到 $(i+1,j)$ 的总通量是此密度乘以面长 $\\Delta y$。项 $\\frac{\\Delta y}{\\Delta x}$ 是该面的 x 方向传导系数 $T_x$。类似地，对于水平面，$T_y = \\frac{\\Delta x}{\\Delta y}$。\n\n内部单元 $(i,j)$ 的守恒方程变为：\n$$\nT_x(u_{i,j} - u_{i+1,j}) + T_x(u_{i,j} - u_{i-1,j}) + T_y(u_{i,j} - u_{i,j+1}) + T_y(u_{i,j} - u_{i,j-1}) = f(x_i, y_j) \\Delta x \\Delta y.\n$$\n源项积分使用中点法则进行近似。该方程将单元 $(i,j)$ 中的压力与其四个邻居的压力联系起来。\n\n对于域边界上的单元，一个或多个通量项由诺伊曼条件 $\\boldsymbol{\\sigma} \\cdot \\boldsymbol{n} = g$ 给出。例如，对于左边界上的单元 $(0,j)$，穿过左侧面的外向通量为 $\\int g \\, \\mathrm{d}s \\approx g(0, y_j) \\Delta y$。守恒方程也相应修改。\n\n### 3. 线性系统与唯一性\n\n为所有 $N = N_x N_y$ 个单元组装守恒方程，会得到一个 $A\\boldsymbol{u} = \\boldsymbol{b}$ 形式的线性系统，其中 $\\boldsymbol{u}$ 是未知单元压力的向量。矩阵 $A$ 是对称但奇异的；其零空间由向量 $\\boldsymbol{1} = (1, 1, \\dots, 1)^T$ 张成，这反映了压力仅在相差一个附加常数的情况下是确定的。\n\n为了获得唯一解，我们强制施加均值为零的约束。对于均匀网格，这等价于 $\\sum_{k=0}^{N-1} u_k = 0$。我们使用拉格朗日乘子 $\\lambda$ 来引入此约束，从而得到增广分块矩阵系统：\n$$\n\\begin{pmatrix} A  \\boldsymbol{1} \\\\ \\boldsymbol{1}^T  0 \\end{pmatrix} \\begin{pmatrix} \\boldsymbol{u} \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} \\boldsymbol{b} \\\\ 0 \\end{pmatrix}.\n$$\n这个 $(N+1) \\times (N+1)$ 的系统是非奇异的，可以求解以找到唯一的压力向量 $\\boldsymbol{u}$ 和拉格朗日乘子 $\\lambda$。\n\n### 4. 局部守恒残差\n\n该问题要求计算每个单元 $k$ 的逐单元通量不平衡，或称为局部守恒残差 $R_k$：\n$$\nR_k = \\left| \\left(\\sum_{\\text{单元 } k \\text{ 的面}} \\text{向外通量}\\right) - \\left(\\int_{\\text{单元 } k} f\\,\\mathrm{d}\\boldsymbol{x}\\right) \\right|.\n$$\n我们构建的线性系统 $A\\boldsymbol{u} = \\boldsymbol{b}$ 直接表示了守恒定律，即（净内通量）=（源）-（边界通量）。单元 $k$ 的方程恰好是（总外向通量）$_k$ = （积分源）$_k$。然而，增广系统中的解 $(\\boldsymbol{u}, \\lambda)$ 满足 $A\\boldsymbol{u} + \\boldsymbol{1}\\lambda = \\boldsymbol{b}$，这意味着 $A\\boldsymbol{u} - \\boldsymbol{b} = -\\boldsymbol{1}\\lambda$。\n\n向量 $A\\boldsymbol{u}-\\boldsymbol{b}$ 代表了守恒定律的数值残差。因此，每个单元 $k$ 的残差由 $(A\\boldsymbol{u} - \\boldsymbol{b})_k = -\\lambda$ 给出。因此，绝对局部守恒残差在所有单元上是统一的，等于 $|\\lambda|$。最大残差就是 $|\\lambda|$。$\\lambda$ 的值代表了为满足离散相容性条件所需的调整，由于数值求积误差，它可能非零。对于给定的具有恒定源和边界数据的测试用例，求积是精确的，我们预期 $\\lambda$ 在机器精度范围内为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"grid\": (8, 8),\n            \"f_func\": lambda x, y: 0.0,\n            \"g_func\": lambda x, y: 1.0 if np.isclose(x, 0.0) or np.isclose(y, 0.0) else -1.0\n        },\n        {\n            \"grid\": (16, 16),\n            \"f_func\": lambda x, y: 1.0,\n            \"g_func\": lambda x, y: 0.25\n        },\n        {\n            \"grid\": (1, 1),\n            \"f_func\": lambda x, y: 0.5,\n            \"g_func\": lambda x, y: 0.125\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny = case[\"grid\"]\n        f_func = case[\"f_func\"]\n        g_func = case[\"g_func\"]\n        \n        dx = 1.0 / Nx\n        dy = 1.0 / Ny\n        N = Nx * Ny\n        \n        cell_centers_x = np.linspace(dx / 2.0, 1.0 - dx / 2.0, Nx)\n        cell_centers_y = np.linspace(dy / 2.0, 1.0 - dy / 2.0, Ny)\n        \n        # Assemble the N x N matrix A and N x 1 vector b for Au = b\n        A = np.zeros((N, N))\n        b = np.zeros(N)\n\n        T_x = dy / dx  # Transmissibility in x-direction\n        T_y = dx / dy  # Transmissibility in y-direction\n\n        for i in range(Nx):\n            for j in range(Ny):\n                k = i * Ny + j\n                \n                # Right-hand side source term\n                b[k] = f_func(cell_centers_x[i], cell_centers_y[j]) * dx * dy\n                \n                # Flux contributions to matrix A and RHS b\n                # Right face\n                if i  Nx - 1:\n                    kr = (i + 1) * Ny + j\n                    A[k, k] += T_x\n                    A[k, kr] -= T_x\n                else:  # Right boundary\n                    b[k] -= g_func(1.0, cell_centers_y[j]) * dy\n\n                # Left face\n                if i > 0:\n                    kl = (i - 1) * Ny + j\n                    A[k, k] += T_x\n                    A[k, kl] -= T_x\n                else:  # Left boundary\n                    b[k] -= g_func(0.0, cell_centers_y[j]) * dy\n                    \n                # Top face\n                if j  Ny - 1:\n                    kt = i * Ny + (j + 1)\n                    A[k, k] += T_y\n                    A[k, kt] -= T_y\n                else:  # Top boundary\n                    b[k] -= g_func(cell_centers_x[i], 1.0) * dx\n\n                # Bottom face\n                if j > 0:\n                    kb = i * Ny + (j - 1)\n                    A[k, k] += T_y\n                    A[k, kb] -= T_y\n                else:  # Bottom boundary\n                    b[k] -= g_func(cell_centers_x[i], 0.0) * dx\n\n        # Assemble the augmented (N+1)x(N+1) system\n        M = np.zeros((N + 1, N + 1))\n        rhs_aug = np.zeros(N + 1)\n\n        M[:N, :N] = A\n        M[:N, N] = 1.0  # Lagrange multiplier column (C^T)\n        M[N, :N] = 1.0  # Zero-mean constraint row (C)\n        \n        rhs_aug[:N] = b\n\n        # Solve the augmented system M * sol_aug = rhs_aug\n        sol_aug = np.linalg.solve(M, rhs_aug)\n        \n        # The last element of the solution is the Lagrange multiplier lambda\n        lambda_val = sol_aug[-1]\n        \n        # The maximum absolute local conservation residual is |lambda|\n        results.append(abs(lambda_val))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}