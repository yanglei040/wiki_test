{
    "hands_on_practices": [
        {
            "introduction": "显式格式求解抛物型方程时，最基本的性质是其条件稳定性。本练习旨在通过探索离散极值原理（DMP）及其与Courant-Friedrichs-Lewy（CFL）条件的关系，来帮助你理解这一概念。通过模拟单个网格尖峰的演化，你将亲眼观察到违反稳定性条件如何导致非物理振荡，从而具体地理解时间步长为何会受到限制 。",
            "id": "3389096",
            "problem": "考虑定义在有限区间上、带有齐次 Dirichlet 边界条件的一维热传导方程（一种抛物型偏微分方程（PDE））。设扩散系数为正常数，记为 $a>0$。在闭区间 $[0,1]$ 上使用包含 $N$ 个节点、间距为 $h$ 的均匀空间网格，并采用时间步长为 $k$ 的显式前向欧拉方法进行时间离散。用 $u_i^n$ 表示在空间节点 $x_i$ 和时间层 $t^n$ 上精确解的数值近似值。定义无量纲比率 $\\mu := a\\,k/h^2$。初始条件为单个网格尖峰：除一个值为 1 的内部节点外，所有节点的值均为零。在所有时间，边界值均保持为零。\n\n您的任务如下：\n\n- 从热传导方程的定义、时间上的前向欧拉方法以及空间二阶导数的标准中心有限差分近似出发，推导内部节点上的显式格式以及用 $\\mu$ 表示的相关离散更新系数。\n- 根据离散格式并仅从基本原理出发，论证单个时间步是否会根据 $\\mu$ 的值产生初始数据中不存在的新极值。“新极值”意味着新最小值低于初始最小值，或新最大值高于初始最大值。\n- 对尖峰初始条件和齐次 Dirichlet 边界，数值实现所推导的单步显式更新。对下面测试套件中的每组参数，精确执行单个时间步，并报告是否产生了新极值（为每种情况输出一个布尔值）。\n\n在您的代码中需使用的假设和设置：\n\n- 空间域：$[0,1]$，有 $N$ 个均匀间隔的节点，间距 $h=1/(N-1)$。\n- 齐次 Dirichlet 边界条件：对所有 $n$， $u_0^n=0$ 且 $u_{N-1}^n=0$。\n- 初始数据（单尖峰）：在选定的内部索引 $i^\\star$ 处，$u_{i^\\star}^0=1$，对所有 $i\\neq i^\\star$，$u_i^0=0$。\n- 在代码中使用 $a=1$ 来计算 $\\mu = k/h^2$；但是，您的实现应直接使用 $\\mu$ 进行单步更新。\n\n单步后新极值的检测标准：\n\n- 令 $\\min^0$ 和 $\\max^0$ 表示初始时刻所有网格节点上的最小值和最大值。\n- 令 $\\min^1$ 和 $\\max^1$ 表示经过一个显式时间步后所有网格节点上的最小值和最大值。\n- 输出布尔值 $\\big(\\min^1 < \\min^0\\big)\\ \\lor\\ \\big(\\max^1 > \\max^0\\big)$。\n\n测试套件：\n\n- 对所有情况，使用 $N=11$ 和 $i^\\star=5$。使用以下四个 $\\mu$ 值：\n    - 情况 1：$\\mu=0$。\n    - 情况 2：$\\mu=0.49$。\n    - 情况 3：$\\mu=0.5$。\n    - 情况 4：$\\mu=0.51$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，顺序与测试套件相同（例如，$[\\text{False},\\text{True},\\text{False},\\text{True}]$）。输出中无需物理单位，因为所有量根据构造都是无量纲的。唯一允许的输出类型是如上指定的布尔值。",
            "solution": "该问题是有效的，因为它具有科学依据、是适定的且客观的。它使用标准的、可验证的方法，探讨了偏微分方程数值解中的基本概念。\n\n该问题要求一个包含三部分的回答：数值格式的推导、其性质的理论分析，以及用于验证该分析的数值实现。\n\n**1. 显式格式的推导**\n\n一维热传导方程是一个抛物型偏微分方程（PDE），由下式给出：\n$$\n\\frac{\\partial u}{\\partial t} = a \\frac{\\partial^2 u}{\\partial x^2}\n$$\n其中 $u(x, t)$ 是在位置 $x$ 和时间 $t$ 的温度，而 $a > 0$ 是热扩散系数。\n\n我们在一个空间步长为 $h$、时间步长为 $k$ 的均匀网格上离散化此方程。解在网格点 $(x_i, t^n)$ 上的近似值记为 $u_i^n$。\n\n时间导数 $\\frac{\\partial u}{\\partial t}$ 使用一阶前向差分（前向欧拉方法）进行近似：\n$$\n\\frac{\\partial u}{\\partial t} \\bigg|_{(x_i, t^n)} \\approx \\frac{u_i^{n+1} - u_i^n}{k}\n$$\n\n空间二阶导数 $\\frac{\\partial^2 u}{\\partial x^2}$ 使用二阶中心差分进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2} \\bigg|_{(x_i, t^n)} \\approx \\frac{u_{i-1}^n - 2u_i^n + u_{i+1}^n}{h^2}\n$$\n\n将这些离散近似代入 PDE，得到以下有限差分方程：\n$$\n\\frac{u_i^{n+1} - u_i^n}{k} = a \\left( \\frac{u_{i-1}^n - 2u_i^n + u_{i+1}^n}{h^2} \\right)\n$$\n\n为了找到 $u_i^{n+1}$ 的更新规则，我们整理各项：\n$$\nu_i^{n+1} = u_i^n + \\frac{ak}{h^2} \\left( u_{i-1}^n - 2u_i^n + u_{i+1}^n \\right)\n$$\n\n问题定义了无量纲比率 $\\mu := a k / h^2$。将 $\\mu$ 代入方程得到：\n$$\nu_i^{n+1} = u_i^n + \\mu (u_{i-1}^n - 2u_i^n + u_{i+1}^n)\n$$\n\n最后，我们将在时间层 $n$ 的项组合起来，得到任意内部节点 $i$ 的显式更新格式：\n$$\nu_i^{n+1} = \\mu u_{i-1}^n + (1 - 2\\mu) u_i^n + \\mu u_{i+1}^n\n$$\n\n时间层 $n$ 的模板所对应的离散更新系数为：\n-   $u_{i-1}^n$ 的系数：$\\mu$\n-   $u_i^n$ 的系数：$1 - 2\\mu$\n-   $u_{i+1}^n$ 的系数：$\\mu$\n\n**2. 新极值产生的分析**\n\n如果在经过一个时间步之后，新最小值小于初始最小值（$\\min^1  \\min^0$）或新最大值大于初始最大值（$\\max^1 > \\max^0$），则产生了“新极值”。\n\n更新规则表明，$u_i^{n+1}$ 是其在上一时间步相邻值的线性组合。为使该格式不产生新极值，它必须满足离散极值原理。如果更新是凸组合，即所有系数都为非负，则可以保证这一点。这些系数的和为 $\\mu + (1 - 2\\mu) + \\mu = 1$。\n\n系数为非负的条件是：\n1.  $\\mu \\ge 0$：由于 $a  0$、$k \\ge 0$ 和 $h^2  0$，此条件总是满足的。$\\mu=0$ 的情况对应于 $k=0$，此时解不发生演化。\n2.  $1 - 2\\mu \\ge 0$：这意味着 $2\\mu \\le 1$，即 $\\mu \\le 0.5$。\n\n**情况 A：$0 \\le \\mu \\le 0.5$**\n在这种情况下，更新规则中的所有系数都是非负的。$u_i^{n+1}$ 的值是 $u_{i-1}^n$、$u_i^n$ 和 $u_{i+1}^n$ 的凸组合。因此，其值被这三个值的最小值和最大值所界定：\n$$\n\\min(u_{i-1}^n, u_i^n, u_{i+1}^n) \\le u_i^{n+1} \\le \\max(u_{i-1}^n, u_i^n, u_{i+1}^n)\n$$\n这意味着对于任何内部节点 $i$，都有 $\\min^n \\le u_i^{n+1} \\le \\max^n$。齐次 Dirichlet 边界条件确保了 $u_0^{n+1} = u_{N-1}^{n+1} = 0$。对于 $\\min^0=0$ 和 $\\max^0=1$ 的初始条件，边界值也保持在该范围内。\n因此，对所有节点 $i=0, \\dots, N-1$，我们有 $\\min^0 \\le u_i^1 \\le \\max^0$。这意味着 $\\min^1 \\ge \\min^0$ 且 $\\max^1 \\le \\max^0$。没有新极值产生。测试标准 $(\\min^1  \\min^0) \\lor (\\max^1 > \\max^0)$ 将评估为 **False**。\n\n**情况 B：$\\mu  0.5$**\n在这种情况下，系数 $1 - 2\\mu$ 是负数。该更新不再是凸组合，离散极值原理被违反。让我们分析其对给定尖峰初始条件的影响：$u_{i^\\star}^0=1$ 且对所有 $i \\neq i^\\star$ 有 $u_i^0=0$。初始极值为 $\\min^0=0$ 和 $\\max^0=1$。\n\n我们计算在时间 $n=1$ 时尖峰附近节点的值：\n-   对于 $i = i^\\star-1$： $u_{i^\\star-1}^1 = \\mu u_{i^\\star-2}^0 + (1-2\\mu)u_{i^\\star-1}^0 + \\mu u_{i^\\star}^0 = \\mu(0) + (1-2\\mu)(0) + \\mu(1) = \\mu$。\n-   对于 $i = i^\\star+1$： $u_{i^\\star+1}^1 = \\mu u_{i^\\star}^0 + (1-2\\mu)u_{i^\\star+1}^0 + \\mu u_{i^\\star+2}^0 = \\mu(1) + (1-2\\mu)(0) + \\mu(0) = \\mu$。\n-   对于 $i = i^\\star$： $u_{i^\\star}^1 = \\mu u_{i^\\star-1}^0 + (1-2\\mu)u_{i^\\star}^0 + \\mu u_{i^\\star+1}^0 = \\mu(0) + (1-2\\mu)(1) + \\mu(0) = 1 - 2\\mu$。\n所有其他节点 $u_i^1$ 的值将为 $0$。\n\n由于 $\\mu  0.5$，我们有 $2\\mu  1$，这意味着 $u_{i^\\star}^1 = 1 - 2\\mu  0$。在时间 $n=1$ 时的最小值为 $\\min^1 = \\min(0, \\mu, 1-2\\mu) = 1-2\\mu$。我们有 $\\min^1  0$，而 $\\min^0=0$。因此，$\\min^1  \\min^0$。产生了一个新的最小值，这是一个物理上不真实的下冲（undershoot）。测试标准 $(\\min^1  \\min^0) \\lor (\\max^1 > \\max^0)$ 评估为 **True**。\n\n条件 $\\mu \\le 0.5$ 是该显式格式众所周知的 CFL (Courant-Friedrichs-Lewy) 稳定性条件。\n\n**3. 数值测试用例预测**\n\n-   情况 1 ($\\mu=0$)：$0 \\le 0.5$。预期为 **False**。\n-   情况 2 ($\\mu=0.49$)：$0.49 \\le 0.5$。预期为 **False**。\n-   情况 3 ($\\mu=0.5$)：$0.5 \\le 0.5$。这是稳定性的边界。预期为 **False**。\n-   情况 4 ($\\mu=0.51$)：$0.51  0.5$。格式不稳定。预期为 **True**。\n\n将基于此经过验证的分析进行实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of detecting new extrema in a one-step explicit finite\n    difference scheme for the 1D heat equation.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a value for the dimensionless ratio mu.\n    test_cases = [0.0, 0.49, 0.5, 0.51]\n\n    # Shared parameters for all test cases\n    N = 11      # Number of spatial grid nodes\n    i_star = 5  # Index of the initial spike\n\n    results = []\n    for mu in test_cases:\n        # Perform the one-step update for a single case.\n\n        # 1. Set up initial condition (u0)\n        # u^0 has a single spike at i_star and is zero everywhere else.\n        u0 = np.zeros(N, dtype=float)\n        u0[i_star] = 1.0\n\n        # Initial minimum and maximum are fixed by the problem description.\n        min0 = 0.0\n        max0 = 1.0\n\n        # 2. Compute the solution after one time step (u1)\n        # Initialize u1 to all zeros. The Dirichlet boundary conditions\n        # u1[0] = 0 and u1[N-1] = 0 are thus automatically satisfied.\n        u1 = np.zeros(N, dtype=float)\n\n        # Apply the explicit update rule for interior nodes (i=1 to N-2).\n        # u_i^{n+1} = mu*u_{i-1}^n + (1 - 2*mu)*u_i^n + mu*u_{i+1}^n\n        # A vectorized update is efficient and concise.\n        u1[1:-1] = mu * u0[:-2] + (1.0 - 2.0 * mu) * u0[1:-1] + mu * u0[2:]\n\n        # 3. Detect new extrema\n        # Find the minimum and maximum of the solution at the new time step.\n        min1 = np.min(u1)\n        max1 = np.max(u1)\n\n        # Apply the detection criterion given in the problem statement.\n        # A new extremum is created if the new min is below the old min,\n        # OR the new max is above the old max.\n        new_extremum_created = (min1  min0) or (max1 > max0)\n        results.append(new_extremum_created)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a Python list of booleans.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在确保一个数值格式稳定之后，下一个关键问题是它的精度。本练习聚焦于验证不同时间积分方法（如前向欧拉法和龙格-库塔法）的理论精度阶，它通过分离热方程的单个特征模态来消除空间离散误差，从而能够纯粹地关注时间收敛性。这项编程练习将教会你设计并执行细化研究以凭经验测量收敛阶，这是一项验证数值代码的基本技能 。",
            "id": "3389099",
            "problem": "考虑一维热传导方程，这是一个典型的抛物型偏微分方程，其形式为 $u_t = \\alpha u_{xx}$，定义在空间区间 $(0,1)$ 上，具有齐次狄利克雷边界条件 $u(0,t) = 0$ 和 $u(1,t) = 0$，以及光滑的初始条件 $u(x,0) = \\sin(\\pi x)$。通过分离变量法和在齐次狄利克雷边界条件下空间拉普拉斯算子的特征函数结构，解在所有 $t \\ge 0$ 时都保持为单一模态，并且可以写成 $u(x,t) = a(t)\\sin(\\pi x)$ 的形式，其中模态振幅 $a(t)$ 满足线性常微分方程（ODE） $a'(t) = -\\lambda a(t)$，其中 $\\lambda = \\alpha \\pi^2$ 且 $a(0) = 1$。该常微分方程的精确解为 $a(t) = \\exp(-\\lambda t)$。\n\n这种简化消除了单个受激特征模态的空间离散误差，这等同于将空间分辨率取得足够精细，以至于空间误差可以忽略不计。在此背景下，您需要设计并实现一个显式时间加密研究，以分离出时间收敛性。您的程序必须实现三种应用于标量常微分方程 $a'(t) = -\\lambda a(t)$ 的显式时间推进格式：\n- 一阶显式前向欧拉法。\n- 二阶显式中点龙格-库塔法。\n- 经典四阶显式龙格-库塔法。\n\n对于每种方法，在一个指定的时间步长序列 $\\Delta t$ 和一个固定的最终时间 $T$ 上进行加密研究。对于序列中的每个 $\\Delta t$，使用恰好 $N = T / \\Delta t$ 步将数值解从 $t=0$ 推进到 $t=T$（选择 $T$ 和 $\\Delta t$ 使 $N$ 为整数），然后计算绝对误差 $E(\\Delta t) = \\lvert a_{\\mathrm{num}}(T) - a_{\\mathrm{exact}}(T) \\rvert$，其中 $a_{\\mathrm{exact}}(T) = \\exp(-\\lambda T)$。通过标度关系 $E(\\Delta t) \\approx C (\\Delta t)^p$ 来估计连续时间步长 $\\Delta t_1$ 和 $\\Delta t_2$ 之间的观测阶数 $p$，计算公式为 $p = \\log\\left(E(\\Delta t_1) / E(\\Delta t_2)\\right) \\big/ \\log\\left(\\Delta t_1 / \\Delta t_2\\right)$。\n\n使用的基础知识：\n- 热传导方程 $u_t = \\alpha u_{xx}$ 及其在齐次狄利克雷边界条件下的模态分解。\n- 第一特征模态所得到的标量常微分方程 $a'(t) = -\\lambda a(t)$，其中 $\\lambda = \\alpha \\pi^2$，及其精确解 $a(t) = \\exp(-\\lambda t)$。\n- 应用于常微分方程的显式前向欧拉法和显式龙格-库塔法的定义。\n\n您必须实现以下参数值测试套件，以评估加密研究的不同方面。在所有情况下，使用 $\\alpha = 1$，因此 $\\lambda = \\pi^2$：\n1. 前向欧拉法的理想情况：\n   - 方法：前向欧拉法\n   - 最终时间：$T = 0.3$\n   - 时间步长：$\\Delta t \\in \\{0.05, 0.025, 0.0125\\}$\n\n2. 显式中点龙格-库塔法（二阶）的理想情况：\n   - 方法：显式中点龙格-库塔法\n   - 最终时间：$T = 1.0$\n   - 时间步长：$\\Delta t \\in \\{0.2, 0.1, 0.05\\}$\n\n3. 经典四阶龙格-库塔法的理想情况：\n   - 方法：经典四阶龙格-库塔法\n   - 最终时间：$T = 0.3$\n   - 时间步长：$\\Delta t \\in \\{0.1, 0.05, 0.025\\}$\n\n4. 边界稳定性情况：前向欧拉法在负实轴上接近其稳定域边界：\n   - 方法：前向欧拉法\n   - 最终时间：$T = 0.95$\n   - 时间步长：$\\Delta t \\in \\{0.19, 0.095, 0.0475\\}$\n\n对于每个测试用例，计算序列中第一对和第二对连续时间步长的观测阶数（即，从第一个值到第二个值，以及从第二个值到第三个值）。程序必须以浮点值的形式返回这些观测阶数。\n\n最终输出格式要求：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，观测阶数按测试用例排序，在每个测试用例中再按步长对排序。具体来说，输出应为以下形式：\n$[\\text{p}_{1,1},\\text{p}_{1,2},\\text{p}_{2,1},\\text{p}_{2,2},\\text{p}_{3,1},\\text{p}_{3,2},\\text{p}_{4,1},\\text{p}_{4,2}]$\n其中 $\\text{p}_{j,k}$ 表示测试用例 $j$ 和步长对 $k$ 的观测阶数。不涉及物理单位，且此处不适用任何角度。列表中的值必须是普通的十进制数。",
            "solution": "该问题要求对应用于一个模型常微分方程（ODE）的几种显式时间积分格式进行时间加密研究的实现和分析。该常微分方程源于一维热传导方程 $u_t = \\alpha u_{xx}$ 在齐次狄利克雷边界条件下的模态分解。使用初始条件 $u(x,0) = \\sin(\\pi x)$ 仅激发第一特征模态的特定设置，将偏微分方程（PDE）简化为关于该模态随时间变化的振幅 $a(t)$ 的常微分方程。此过程有效地将时间离散误差与空间离散误差分离开来。\n\n控制第一模态振幅的常微分方程如下：\n$$\na'(t) = -\\lambda a(t)\n$$\n初始条件为 $a(0) = 1$。常数 $\\lambda$ 是对应于第一特征模态 $\\sin(\\pi x)$ 的特征值，即 $\\lambda = \\alpha \\pi^2$。对于所有测试用例，我们使用 $\\alpha=1$，因此 $\\lambda = \\pi^2$。\n\n此初值问题的精确解可通过直接积分得到：\n$$\na_{\\mathrm{exact}}(t) = \\exp(-\\lambda t)\n$$\n\n任务的核心是使用固定的时间步长 $\\Delta t$ 对此常微分方程从 $t=0$ 到最终时间 $T$ 进行数值求解，并研究当 $\\Delta t$ 被加密时，最终时间的误差行为。每次模拟的步数为 $N = T / \\Delta t$。\n\n我们将实现三种显式数值方法：\n\n1.  **一阶显式前向欧拉法：**\n    这是最简单的显式方法。从第 $n$ 步到第 $n+1$ 步的解是使用以下公式推进的：\n    $$\n    a_{n+1} = a_n + \\Delta t \\cdot f(t_n, a_n)\n    $$\n    其中 $f(t_n, a_n) = -\\lambda a_n$。将此代入公式得到迭代映射：\n    $$\n    a_{n+1} = a_n + \\Delta t (-\\lambda a_n) = (1 - \\lambda \\Delta t) a_n\n    $$\n\n2.  **二阶显式中点龙格-库塔法（RK2）：**\n    该方法通过使用预估-校正方法达到二阶精度。它首先使用欧拉法预测的值来评估时间中点的斜率，然后使用该中点斜率来完成整个步长的推进。\n    阶段如下：\n    $$\n    k_1 = f(t_n, a_n) = -\\lambda a_n\n    $$\n    $$\n    k_2 = f\\left(t_n + \\frac{\\Delta t}{2}, a_n + \\frac{\\Delta t}{2} k_1\\right) = -\\lambda \\left(a_n + \\frac{\\Delta t}{2} k_1\\right)\n    $$\n    更新规则为：\n    $$\n    a_{n+1} = a_n + \\Delta t \\cdot k_2\n    $$\n\n3.  **经典四阶显式龙格-库塔法（RK4）：**\n    这是一种广泛使用的方法，它通过使用区间 $\\Delta t$ 内四个斜率估计值的加权平均来提供四阶精度。\n    四个阶段如下：\n    $$\n    k_1 = f(t_n, a_n) = -\\lambda a_n\n    $$\n    $$\n    k_2 = f\\left(t_n + \\frac{\\Delta t}{2}, a_n + \\frac{\\Delta t}{2} k_1\\right) = -\\lambda \\left(a_n + \\frac{\\Delta t}{2} k_1\\right)\n    $$\n    $$\n    k_3 = f\\left(t_n + \\frac{\\Delta t}{2}, a_n + \\frac{\\Delta t}{2} k_2\\right) = -\\lambda \\left(a_n + \\frac{\\Delta t}{2} k_2\\right)\n    $$\n    $$\n    k_4 = f(t_n + \\Delta t, a_n + \\Delta t k_3) = -\\lambda (a_n + \\Delta t k_3)\n    $$\n    最终的更新是这些斜率的加权平均：\n    $$\n    a_{n+1} = a_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n    $$\n\n对于每个测试用例，都会进行一次加密研究。这包括以下步骤：\n1.  对于给定的方法、最终时间 $T$ 和一个递减的时间步长序列 $(\\Delta t_1, \\Delta t_2, \\ldots)$，从 $a(0)=1$ 开始数值积分该常微分方程，以获得每个 $\\Delta t_i$ 的数值解 $a_{\\mathrm{num}}(T)$。\n2.  计算在最终时间的精确解，$a_{\\mathrm{exact}}(T) = \\exp(-\\lambda T)$。\n3.  计算每次模拟的绝对误差：$E(\\Delta t_i) = |a_{\\mathrm{num}}(T) - a_{\\mathrm{exact}}(T)|$。\n4.  一个 $p$ 阶方法的理论收敛性意味着对于足够小的 $\\Delta t$，误差行为如 $E(\\Delta t) \\approx C (\\Delta t)^p$。通过使用时间步长 $\\Delta t_1$ 和 $\\Delta t_2$ 进行的两次模拟，可以利用以下公式估计观测到的收敛阶数 $p$：\n    $$\n    p = \\frac{\\log\\left(E(\\Delta t_1) / E(\\Delta t_2)\\right)}{\\log\\left(\\Delta t_1 / \\Delta t_2\\right)}\n    $$\n\n程序将对四个指定的测试用例中的每一个执行此过程，为每个用例计算两个观测阶数（来自第一对和第二对连续的时间步长），并以指定的格式输出这八个值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the refinement study across all specified test cases.\n    \"\"\"\n\n    def solve_ode(method: str, T: float, dt: float, lambda_val: float) - float:\n        \"\"\"\n        Solves the ODE a'(t) = -lambda * a(t) from t=0 to T with time step dt.\n\n        Args:\n            method: The name of the numerical scheme ('forward_euler', 'rk2', 'rk4').\n            T: The final integration time.\n            dt: The time step size.\n            lambda_val: The coefficient lambda in the ODE.\n\n        Returns:\n            The numerical solution a_num(T).\n        \"\"\"\n        # Ensure the number of steps is an integer, as per problem statement.\n        # Use round to handle potential floating point inaccuracies.\n        N = int(round(T / dt))\n        a_n = 1.0  # Initial condition a(0) = 1\n\n        if method == \"forward_euler\":\n            for _ in range(N):\n                a_n = a_n + dt * (-lambda_val * a_n)\n        elif method == \"rk2\":\n            for _ in range(N):\n                k1 = -lambda_val * a_n\n                k2 = -lambda_val * (a_n + dt / 2.0 * k1)\n                a_n = a_n + dt * k2\n        elif method == \"rk4\":\n            for _ in range(N):\n                k1 = -lambda_val * a_n\n                k2 = -lambda_val * (a_n + dt / 2.0 * k1)\n                k3 = -lambda_val * (a_n + dt / 2.0 * k2)\n                k4 = -lambda_val * (a_n + dt * k3)\n                a_n = a_n + dt / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n        \n        return a_n\n\n    # Map problem statement method names to internal function identifiers.\n    method_map = {\n        \"前向欧拉法\": \"forward_euler\",\n        \"显式中点龙格-库塔法\": \"rk2\",\n        \"经典四阶显式龙格-库塔法\": \"rk4\"\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"method\": \"前向欧拉法\", \"T\": 0.3, \"dts\": [0.05, 0.025, 0.0125]},\n        {\"method\": \"显式中点龙格-库塔法\", \"T\": 1.0, \"dts\": [0.2, 0.1, 0.05]},\n        {\"method\": \"经典四阶显式龙格-库塔法\", \"T\": 0.3, \"dts\": [0.1, 0.05, 0.025]},\n        {\"method\": \"前向欧拉法\", \"T\": 0.95, \"dts\": [0.19, 0.095, 0.0475]}\n    ]\n\n    # Global parameter alpha and derived lambda\n    alpha = 1.0\n    lambda_val = alpha * np.pi**2\n\n    all_orders = []\n\n    for case in test_cases:\n        T = case[\"T\"]\n        dts = case[\"dts\"]\n        method_str = case[\"method\"]\n        method_id = method_map[method_str]\n\n        # Calculate exact solution at final time T\n        a_exact_T = np.exp(-lambda_val * T)\n        \n        # Calculate numerical solution and error for each time step\n        errors = []\n        for dt in dts:\n            a_num_T = solve_ode(method_id, T, dt, lambda_val)\n            error = np.abs(a_num_T - a_exact_T)\n            errors.append(error)\n\n        # Calculate observed convergence orders\n        # p = log(E1/E2) / log(dt1/dt2)\n        \n        # Order for the first pair of time steps (dt_1, dt_2)\n        dt_ratio_1 = dts[0] / dts[1]\n        order1 = np.log(errors[0] / errors[1]) / np.log(dt_ratio_1)\n        all_orders.append(order1)\n        \n        # Order for the second pair of time steps (dt_2, dt_3)\n        dt_ratio_2 = dts[1] / dts[2]\n        order2 = np.log(errors[1] / errors[2]) / np.log(dt_ratio_2)\n        all_orders.append(order2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{order:.7f}' for order in all_orders)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的扩散过程通常是各向异性的，并且发生在多维空间中。本练习将稳定性分析从一维各向同性情况推广到具有各向异性扩散的二维区域。通过应用离散极值原理，你将推导出在更复杂情景下的最大稳定时间步长，这一计算对于建立实际的数值模拟至关重要 。",
            "id": "3389038",
            "problem": "考虑一个定义在矩形域上的二维抛物型偏微分方程 $u_t = \\nabla \\cdot (K \\nabla u)$，其中 $K$ 是一个常数、对称、正定的扩散张量。为构建一个没有混合导数项贡献的特定各向异性和网格方向，同时通过离散极值原理（DMP）对显式时间步长施加严格约束，设 $K$ 与坐标轴对齐，即 $K = \\mathrm{diag}(\\kappa_x,\\kappa_y)$，其各向异性分量为 $\\kappa_x = 7.5$ 和 $\\kappa_y = 0.3$。设网格为沿 $x$ 和 $y$ 轴方向的均匀矩形网格，网格间距为 $h_x = 0.02$ 和 $h_y = 0.015$。空间上使用五点模板上的二阶中心差分进行离散，时间上使用前向欧拉法进行离散。DMP要求每个网格点上的显式更新是当前值和相邻值的凸组合，这通过非负的更新权重来强制执行。计算最大允许时间步长 $\\Delta t_{\\max}$，使得对于此离散化和数据，所有更新权重均为非负，从而证明任何 $\\Delta t  \\Delta t_{\\max}$ 都会因产生负权重而破坏DMP。将 $\\Delta t_{\\max}$ 报告为一个无量纲数，并四舍五入到四位有效数字。",
            "solution": "首先验证问题，以确保其自洽、科学有据且适定。\n\n### 第1步：提取已知条件\n-   **偏微分方程（PDE）：** 在矩形域上的 $u_t = \\nabla \\cdot (K \\nabla u)$。\n-   **扩散张量（$K$）：** 常数、对称、正定。具体来说，$K$ 是对角阵，$K = \\mathrm{diag}(\\kappa_x, \\kappa_y)$。\n-   **张量分量：** $\\kappa_x = 7.5$ 和 $\\kappa_y = 0.3$。\n-   **网格：** 沿 $x$ 和 $y$ 轴方向的均匀矩形网格。\n-   **网格间距：** $h_x = 0.02$ 和 $h_y = 0.015$。\n-   **空间离散化：** 五点模板上的二阶中心差分。\n-   **时间离散化：** 前向欧拉法。\n-   **约束：** 必须满足离散极值原理（DMP），这通过显式格式中所有更新权重均为非负的条件来强制执行。\n-   **目标：** 计算最大允许时间步长 $\\Delta t_{\\max}$，并四舍五入到四位有效数字。\n\n### 第2步：使用提取的已知条件进行验证\n-   **科学有据：** 该问题描述了各向异性热/扩散方程的前向时间中心空间（FTCS）离散化。从离散极值原理导出的稳定性条件是抛物型偏微分方程数值分析中的一个标准和基本概念。该问题在科学和数学上是合理的。\n-   **适定性：** 所有参数（$\\kappa_x, \\kappa_y, h_x, h_y$）都已给出，离散格式已明确定义。DMP的条件导出一个定义明确的不等式，从中可以确定唯一最大时间步长 $\\Delta t_{\\max}$。\n-   **目标：** 问题使用数值分析中的精确、标准术语陈述。没有主观或含糊的陈述。\n\n### 第3步：结论与行动\n该问题是**有效的**。这是一个定义明确的数值分析问题。可以继续求解过程。\n\n### 求解推导\n给定的抛物型偏微分方程为 $u_t = \\nabla \\cdot (K \\nabla u)$。当扩散张量为对角阵 $K = \\mathrm{diag}(\\kappa_x, \\kappa_y)$ 且 $\\kappa_x$ 和 $\\kappa_y$ 为常数时，该方程展开为：\n$$\nu_t = \\frac{\\partial}{\\partial x}\\left(\\kappa_x \\frac{\\partial u}{\\partial x}\\right) + \\frac{\\partial}{\\partial y}\\left(\\kappa_y \\frac{\\partial u}{\\partial y}\\right) = \\kappa_x \\frac{\\partial^2 u}{\\partial x^2} + \\kappa_y \\frac{\\partial^2 u}{\\partial y^2}\n$$\n\n设 $u_{i,j}^n$ 是解 $u$ 在网格点 $(x_i, y_j) = (i h_x, j h_y)$ 和时间 $t_n = n \\Delta t$ 处的数值近似。\n\n我们使用指定的方法对偏微分方程进行离散化。\n时间导数 $u_t$ 使用前向欧拉法近似：\n$$\nu_t \\approx \\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t}\n$$\n空间二阶导数使用二阶中心差分近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n}{h_x^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2} \\approx \\frac{u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n}{h_y^2}\n$$\n将这些近似代入偏微分方程，得到FTCS（前向时间，中心空间）格式：\n$$\n\\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t} = \\kappa_x \\left( \\frac{u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n}{h_x^2} \\right) + \\kappa_y \\left( \\frac{u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n}{h_y^2} \\right)\n$$\n为求更新权重，我们求解 $u_{i,j}^{n+1}$：\n$$\nu_{i,j}^{n+1} = u_{i,j}^n + \\Delta t \\left[ \\kappa_x \\left( \\frac{u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n}{h_x^2} \\right) + \\kappa_y \\left( \\frac{u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n}{h_y^2} \\right) \\right]\n$$\n让我们定义每个方向上的无量纲网格傅里叶数（或类似CFL的数）：\n$$\nr_x = \\frac{\\kappa_x \\Delta t}{h_x^2} \\quad \\text{和} \\quad r_y = \\frac{\\kappa_y \\Delta t}{h_y^2}\n$$\n将这些代入格式，并按时间层 $n$ 的空间位置对各项进行分组：\n$$\nu_{i,j}^{n+1} = u_{i,j}^n + r_x(u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n) + r_y(u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n)\n$$\n$$\nu_{i,j}^{n+1} = (1 - 2r_x - 2r_y)u_{i,j}^n + r_x u_{i+1,j}^n + r_x u_{i-1,j}^n + r_y u_{i,j+1}^n + r_y u_{i,j-1}^n\n$$\n新时间步的值 $u_{i,j}^{n+1}$ 是当前时间步上五点模板值的线性组合。这些系数（权重）是：\n-   中心节点 $u_{i,j}^n$ 的权重：$w_C = 1 - 2r_x - 2r_y$\n-   $x$方向相邻节点 $u_{i\\pm 1,j}^n$ 的权重：$w_{E,W} = r_x$\n-   $y$方向相邻节点 $u_{i,j\\pm 1}^n$ 的权重：$w_{N,S} = r_y$\n\n离散极值原理（DMP）要求在任意点 $(i,j)$ 和时间 $n+1$ 的数值解被计算域上时间 $n$ 的解的最小值和最大值所界定。对于此显式格式，满足DMP的一个充分条件是更新是凸组合，这意味着前面提到的所有权重都必须是非负的。\n\n由于 $\\kappa_x, \\kappa_y, \\Delta t, h_x, h_y$ 都是正数，权重 $r_x$ 和 $r_y$ 天然是非负的。唯一非平凡的约束来自中心节点的权重：\n$$\nw_C = 1 - 2r_x - 2r_y \\ge 0\n$$\n代入 $r_x$ 和 $r_y$ 的定义：\n$$\n1 - 2\\left(\\frac{\\kappa_x \\Delta t}{h_x^2}\\right) - 2\\left(\\frac{\\kappa_y \\Delta t}{h_y^2}\\right) \\ge 0\n$$\n我们可以解此不等式求 $\\Delta t$：\n$$\n1 \\ge 2\\Delta t \\left(\\frac{\\kappa_x}{h_x^2} + \\frac{\\kappa_y}{h_y^2}\\right)\n$$\n$$\n\\Delta t \\le \\frac{1}{2 \\left(\\frac{\\kappa_x}{h_x^2} + \\frac{\\kappa_y}{h_y^2}\\right)}\n$$\n最大允许时间步长 $\\Delta t_{\\max}$ 对应于等式：\n$$\n\\Delta t_{\\max} = \\frac{1}{2 \\left(\\frac{\\kappa_x}{h_x^2} + \\frac{\\kappa_y}{h_y^2}\\right)}\n$$\n任何时间步长 $\\Delta t  \\Delta t_{\\max}$ 都将导致 $w_C  0$，违反了权重的非负性，从而破坏了DMP。\n\n现在，我们代入给定的数值：$\\kappa_x = 7.5$，$\\kappa_y = 0.3$，$h_x = 0.02$ 和 $h_y = 0.015$。\n首先，计算分母中的各项：\n$$\n\\frac{\\kappa_x}{h_x^2} = \\frac{7.5}{(0.02)^2} = \\frac{7.5}{0.0004} = 18750\n$$\n$$\n\\frac{\\kappa_y}{h_y^2} = \\frac{0.3}{(0.015)^2} = \\frac{0.3}{0.000225} = \\frac{3000}{2.25} = \\frac{4000}{3} \\approx 1333.33...\n$$\n现在，计算这些项的和：\n$$\n\\frac{\\kappa_x}{h_x^2} + \\frac{\\kappa_y}{h_y^2} = 18750 + \\frac{4000}{3} = \\frac{56250}{3} + \\frac{4000}{3} = \\frac{60250}{3}\n$$\n最后，计算 $\\Delta t_{\\max}$：\n$$\n\\Delta t_{\\max} = \\frac{1}{2 \\left(\\frac{60250}{3}\\right)} = \\frac{1}{\\frac{120500}{3}} = \\frac{3}{120500}\n$$\n为了得到数值，我们进行除法运算：\n$$\n\\Delta t_{\\max} = 0.00002489626556...\n$$\n问题要求将此值四舍五入到四位有效数字。前四位有效数字是 $2$、$4$、$8$ 和 $9$。第五位有效数字是 $6$。由于 $6 \\ge 5$，我们将第四位数字向上取整。将 $9$ 向上取整得到 $0$ 并产生进位，因此 $2489$ 变为 $2490$。\n因此，$\\Delta t_{\\max} \\approx 0.00002490$。用科学记数法表示为 $2.490 \\times 10^{-5}$。",
            "answer": "$$\n\\boxed{2.490 \\times 10^{-5}}\n$$"
        }
    ]
}